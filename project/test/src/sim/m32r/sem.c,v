head	1.14;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.14
	gdb_7_6-2013-04-26-release:1.14
	gdb_7_6-branch:1.14.0.2
	gdb_7_6-2013-03-12-branchpoint:1.14
	gdb_7_5_1-2012-11-29-release:1.12
	gdb_7_5-2012-08-17-release:1.12
	gdb_7_5-branch:1.12.0.2
	gdb_7_5-2012-07-18-branchpoint:1.12
	gdb_7_4_1-2012-04-26-release:1.11.8.1
	gdb_7_4-2012-01-24-release:1.11.8.1
	gdb_7_4-branch:1.11.0.8
	gdb_7_4-2011-12-13-branchpoint:1.11
	gdb_7_3_1-2011-09-04-release:1.11
	gdb_7_3-2011-07-26-release:1.11
	gdb_7_3-branch:1.11.0.6
	gdb_7_3-2011-04-01-branchpoint:1.11
	gdb_7_2-2010-09-02-release:1.11
	gdb_7_2-branch:1.11.0.4
	gdb_7_2-2010-07-07-branchpoint:1.11
	gdb_7_1-2010-03-18-release:1.11
	gdb_7_1-branch:1.11.0.2
	gdb_7_1-2010-02-18-branchpoint:1.11
	gdb_7_0_1-2009-12-22-release:1.8
	gdb_7_0-2009-10-06-release:1.8
	gdb_7_0-branch:1.8.0.22
	gdb_7_0-2009-09-16-branchpoint:1.8
	arc-sim-20090309:1.8
	msnyder-checkpoint-072509-branch:1.8.0.20
	msnyder-checkpoint-072509-branchpoint:1.8
	arc-insight_6_8-branch:1.8.0.18
	arc-insight_6_8-branchpoint:1.8
	insight_6_8-branch:1.8.0.16
	insight_6_8-branchpoint:1.8
	reverse-20081226-branch:1.8.0.14
	reverse-20081226-branchpoint:1.8
	multiprocess-20081120-branch:1.8.0.12
	multiprocess-20081120-branchpoint:1.8
	reverse-20080930-branch:1.8.0.10
	reverse-20080930-branchpoint:1.8
	reverse-20080717-branch:1.8.0.8
	reverse-20080717-branchpoint:1.8
	msnyder-reverse-20080609-branch:1.8.0.6
	msnyder-reverse-20080609-branchpoint:1.8
	drow-reverse-20070409-branch:1.7.0.50
	drow-reverse-20070409-branchpoint:1.7
	gdb_6_8-2008-03-27-release:1.8
	gdb_6_8-branch:1.8.0.4
	gdb_6_8-2008-02-26-branchpoint:1.8
	gdb_6_7_1-2007-10-29-release:1.8
	gdb_6_7-2007-10-10-release:1.8
	gdb_6_7-branch:1.8.0.2
	gdb_6_7-2007-09-07-branchpoint:1.8
	insight_6_6-20070208-release:1.7
	gdb_6_6-2006-12-18-release:1.7
	gdb_6_6-branch:1.7.0.48
	gdb_6_6-2006-11-15-branchpoint:1.7
	insight_6_5-20061003-release:1.7
	gdb-csl-symbian-6_4_50_20060226-12:1.7
	gdb-csl-sourcerygxx-3_4_4-25:1.7
	nickrob-async-20060828-mergepoint:1.7
	gdb-csl-symbian-6_4_50_20060226-11:1.7
	gdb-csl-sourcerygxx-4_1-17:1.7
	gdb-csl-20060226-branch-local-2:1.7
	gdb-csl-sourcerygxx-4_1-14:1.7
	gdb-csl-sourcerygxx-4_1-13:1.7
	gdb-csl-sourcerygxx-4_1-12:1.7
	gdb-csl-sourcerygxx-3_4_4-21:1.7
	gdb_6_5-20060621-release:1.7
	gdb-csl-sourcerygxx-4_1-9:1.7
	gdb-csl-sourcerygxx-4_1-8:1.7
	gdb-csl-sourcerygxx-4_1-7:1.7
	gdb-csl-arm-2006q1-6:1.7
	gdb-csl-sourcerygxx-4_1-6:1.7
	gdb-csl-symbian-6_4_50_20060226-10:1.7
	gdb-csl-symbian-6_4_50_20060226-9:1.7
	gdb-csl-symbian-6_4_50_20060226-8:1.7
	gdb-csl-coldfire-4_1-11:1.7
	gdb-csl-sourcerygxx-3_4_4-19:1.7
	gdb-csl-coldfire-4_1-10:1.7
	gdb_6_5-branch:1.7.0.46
	gdb_6_5-2006-05-14-branchpoint:1.7
	gdb-csl-sourcerygxx-4_1-5:1.7
	nickrob-async-20060513-branch:1.7.0.44
	nickrob-async-20060513-branchpoint:1.7
	gdb-csl-sourcerygxx-4_1-4:1.7
	msnyder-reverse-20060502-branch:1.7.0.42
	msnyder-reverse-20060502-branchpoint:1.7
	gdb-csl-morpho-4_1-4:1.7
	gdb-csl-sourcerygxx-3_4_4-17:1.7
	readline_5_1-import-branch:1.7.0.40
	readline_5_1-import-branchpoint:1.7
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.7
	gdb-csl-symbian-20060226-branch:1.7.0.38
	gdb-csl-symbian-20060226-branchpoint:1.7
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.7
	msnyder-reverse-20060331-branch:1.7.0.36
	msnyder-reverse-20060331-branchpoint:1.7
	gdb-csl-available-20060303-branch:1.7.0.34
	gdb-csl-available-20060303-branchpoint:1.7
	gdb-csl-20060226-branch:1.7.0.32
	gdb-csl-20060226-branchpoint:1.7
	gdb_6_4-20051202-release:1.7
	msnyder-fork-checkpoint-branch:1.7.0.30
	msnyder-fork-checkpoint-branchpoint:1.7
	gdb-csl-gxxpro-6_3-branch:1.7.0.28
	gdb-csl-gxxpro-6_3-branchpoint:1.7
	gdb_6_4-branch:1.7.0.26
	gdb_6_4-2005-11-01-branchpoint:1.7
	gdb-csl-arm-20051020-branch:1.7.0.24
	gdb-csl-arm-20051020-branchpoint:1.7
	msnyder-tracepoint-checkpoint-branch:1.7.0.22
	msnyder-tracepoint-checkpoint-branchpoint:1.7
	gdb-csl-arm-20050325-2005-q1b:1.7
	gdb-csl-arm-20050325-2005-q1a:1.7
	csl-arm-20050325-branch:1.7.0.20
	csl-arm-20050325-branchpoint:1.7
	gdb_6_3-20041109-release:1.7
	gdb_6_3-branch:1.7.0.16
	gdb_6_3-20041019-branchpoint:1.7
	drow_intercu-merge-20040921:1.7
	drow_intercu-merge-20040915:1.7
	jimb-gdb_6_2-e500-branch:1.7.0.18
	jimb-gdb_6_2-e500-branchpoint:1.7
	gdb_6_2-20040730-release:1.7
	gdb_6_2-branch:1.7.0.14
	gdb_6_2-2004-07-10-gmt-branchpoint:1.7
	gdb_6_1_1-20040616-release:1.7
	gdb_6_1-2004-04-05-release:1.7
	drow_intercu-merge-20040402:1.7
	drow_intercu-merge-20040327:1.7
	ezannoni_pie-20040323-branch:1.7.0.12
	ezannoni_pie-20040323-branchpoint:1.7
	cagney_tramp-20040321-mergepoint:1.7
	cagney_tramp-20040309-branch:1.7.0.10
	cagney_tramp-20040309-branchpoint:1.7
	gdb_6_1-branch:1.7.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.7
	drow_intercu-20040221-branch:1.7.0.6
	drow_intercu-20040221-branchpoint:1.7
	cagney_bfdfile-20040213-branch:1.7.0.4
	cagney_bfdfile-20040213-branchpoint:1.7
	drow-cplus-merge-20040208:1.7
	carlton_dictionary-20040126-merge:1.7
	cagney_bigcore-20040122-branch:1.7.0.2
	cagney_bigcore-20040122-branchpoint:1.7
	drow-cplus-merge-20040113:1.7
	drow-cplus-merge-20031224:1.7
	drow-cplus-merge-20031220:1.7
	carlton_dictionary-20031215-merge:1.7
	drow-cplus-merge-20031214:1.7
	carlton-dictionary-20031111-merge:1.6
	gdb_6_0-2003-10-04-release:1.6
	kettenis_sparc-20030918-branch:1.6.0.40
	kettenis_sparc-20030918-branchpoint:1.6
	carlton_dictionary-20030917-merge:1.6
	ezannoni_pie-20030916-branchpoint:1.6
	ezannoni_pie-20030916-branch:1.6.0.38
	cagney_x86i386-20030821-branch:1.6.0.36
	cagney_x86i386-20030821-branchpoint:1.6
	carlton_dictionary-20030805-merge:1.6
	carlton_dictionary-20030627-merge:1.6
	gdb_6_0-branch:1.6.0.34
	gdb_6_0-2003-06-23-branchpoint:1.6
	jimb-ppc64-linux-20030613-branch:1.6.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.6
	cagney_convert-20030606-branch:1.6.0.30
	cagney_convert-20030606-branchpoint:1.6
	cagney_writestrings-20030508-branch:1.6.0.28
	cagney_writestrings-20030508-branchpoint:1.6
	jimb-ppc64-linux-20030528-branch:1.6.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.6
	carlton_dictionary-20030523-merge:1.6
	cagney_fileio-20030521-branch:1.6.0.24
	cagney_fileio-20030521-branchpoint:1.6
	kettenis_i386newframe-20030517-mergepoint:1.6
	jimb-ppc64-linux-20030509-branch:1.6.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.6
	kettenis_i386newframe-20030504-mergepoint:1.6
	carlton_dictionary-20030430-merge:1.6
	kettenis_i386newframe-20030419-branch:1.6.0.20
	kettenis_i386newframe-20030419-branchpoint:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	kettenis_i386newframe-20030406-branch:1.6.0.18
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.16
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.14
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.12
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.6
	offbyone-20030313-branch:1.6.0.10
	offbyone-20030313-branchpoint:1.6
	kettenis-i386newframe-20030308-branch:1.6.0.8
	kettenis-i386newframe-20030308-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.6
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.6
	interps-20030202-branch:1.6.0.4
	interps-20030202-branchpoint:1.6
	cagney-unwind-20030108-branch:1.6.0.2
	cagney-unwind-20030108-branchpoint:1.6
	carlton_dictionary-20021223-merge:1.6
	gdb_5_3-2002-12-12-release:1.5
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.18
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.16
	carlton_dictionary-20020920-branchpoint:1.5
	gdb_5_3-branch:1.5.0.14
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.12
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.10
	readline_4_3-import-branchpoint:1.5
	gdb_5_2_1-2002-07-23-release:1.5
	kseitz_interps-20020528-branch:1.5.0.8
	kseitz_interps-20020528-branchpoint:1.5
	cagney_regbuf-20020515-branch:1.5.0.6
	cagney_regbuf-20020515-branchpoint:1.5
	jimb-macro-020506-branch:1.5.0.4
	jimb-macro-020506-branchpoint:1.5
	gdb_5_2-2002-04-29-release:1.5
	gdb_5_2-branch:1.5.0.2
	gdb_5_2-2002-03-03-branchpoint:1.5
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	insight-precleanup-2001-01-01:1.3
	gdb-premipsmulti-2000-06-06-branch:1.1.1.5.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.5
	gdb_5_0-2000-05-19-release:1.1.1.5
	gdb_4_18_2-2000-05-18-release:1.1.1.5
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.5
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.5
	gdb_5_0-2000-04-10-branch:1.1.1.5.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.5
	repo-unification-2000-02-06:1.1.1.5
	gdb-2000-02-04:1.1.1.5
	gdb-2000-02-02:1.1.1.5
	gdb-2000-02-01:1.1.1.5
	gdb-2000-01-31:1.1.1.5
	gdb-2000-01-26:1.1.1.5
	gdb-2000-01-24:1.1.1.5
	gdb-2000-01-17:1.1.1.5
	gdb-2000-01-10:1.1.1.5
	gdb-2000-01-05:1.1.1.5
	gdb-1999-12-21:1.1.1.5
	gdb-1999-12-13:1.1.1.5
	gdb-1999-12-07:1.1.1.5
	gdb-1999-12-06:1.1.1.5
	gdb-1999-11-16:1.1.1.5
	gdb-1999-11-08:1.1.1.5
	gdb-1999-11-01:1.1.1.5
	gdb-1999-10-25:1.1.1.5
	gdb-1999-10-18:1.1.1.5
	gdb-1999-10-11:1.1.1.5
	gdb-1999-10-04:1.1.1.5
	gdb-1999-09-28:1.1.1.4
	gdb-1999-09-21:1.1.1.4
	gdb-1999-09-13:1.1.1.4
	gdb-1999-09-08:1.1.1.4
	gdb-1999-08-30:1.1.1.4
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.14
date	2013.01.01.06.41.38;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2012.12.19.07.18.19;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2012.01.04.08.28.13;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2010.02.12.02.44.26;	author devans;	state Exp;
branches
	1.11.8.1;
next	1.10;

1.10
date	2010.01.02.19.09.20;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.04.05.07.00;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2007.08.24.14.28.37;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.11.11.33.44;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.20.02.26.35;	author devans;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.14.19.51.40;	author brolley;	state Exp;
branches
	1.5.16.1
	1.5.18.1;
next	1.4;

1.4
date	2001.03.05.16.05.38;	author brolley;	state Exp;
branches;
next	1.3;

1.3
date	2000.10.06.16.59.56;	author brolley;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.28.18.20.29;	author brolley;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.06;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.11.8.1
date	2012.01.06.04.54.51;	author brobecke;	state Exp;
branches;
next	;

1.5.16.1
date	2002.12.23.19.39.57;	author carlton;	state Exp;
branches;
next	1.5.16.2;

1.5.16.2
date	2003.12.16.00.01.25;	author carlton;	state Exp;
branches;
next	;

1.5.18.1
date	2003.12.14.20.28.25;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.35.06;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.32.58;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.08.09.21.36.23;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.08.31.01.13.13;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.10.05.23.13.55;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* Simulator instruction semantics for m32rbf.

THIS FILE IS MACHINE GENERATED WITH CGEN.

Copyright 1996-2013 Free Software Foundation, Inc.

This file is part of the GNU simulators.

   This file is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License along
   with this program; if not, see <http://www.gnu.org/licenses/>.

*/

#define WANT_CPU m32rbf
#define WANT_CPU_M32RBF

#include "sim-main.h"
#include "cgen-mem.h"
#include "cgen-ops.h"

#undef GET_ATTR
#define GET_ATTR(cpu, num, attr) CGEN_ATTR_VALUE (NULL, abuf->idesc->attrs, CGEN_INSN_##attr)

/* This is used so that we can compile two copies of the semantic code,
   one with full feature support and one without that runs fast(er).
   FAST_P, when desired, is defined on the command line, -DFAST_P=1.  */
#if FAST_P
#define SEM_FN_NAME(cpu,fn) XCONCAT3 (cpu,_semf_,fn)
#undef TRACE_RESULT
#define TRACE_RESULT(cpu, abuf, name, type, val)
#else
#define SEM_FN_NAME(cpu,fn) XCONCAT3 (cpu,_sem_,fn)
#endif

/* x-invalid: --invalid-- */

static SEM_PC
SEM_FN_NAME (m32rbf,x_invalid) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
    /* Update the recorded pc in the cpu state struct.
       Only necessary for WITH_SCACHE case, but to avoid the
       conditional compilation ....  */
    SET_H_PC (pc);
    /* Virtual insns have zero size.  Overwrite vpc with address of next insn
       using the default-insn-bitsize spec.  When executing insns in parallel
       we may want to queue the fault and continue execution.  */
    vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
    vpc = sim_engine_invalid_insn (current_cpu, pc, vpc);
  }

  return vpc;
#undef FLD
}

/* x-after: --after-- */

static SEM_PC
SEM_FN_NAME (m32rbf,x_after) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_M32RBF
    m32rbf_pbb_after (current_cpu, sem_arg);
#endif
  }

  return vpc;
#undef FLD
}

/* x-before: --before-- */

static SEM_PC
SEM_FN_NAME (m32rbf,x_before) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_M32RBF
    m32rbf_pbb_before (current_cpu, sem_arg);
#endif
  }

  return vpc;
#undef FLD
}

/* x-cti-chain: --cti-chain-- */

static SEM_PC
SEM_FN_NAME (m32rbf,x_cti_chain) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_M32RBF
#ifdef DEFINE_SWITCH
    vpc = m32rbf_pbb_cti_chain (current_cpu, sem_arg,
			       pbb_br_type, pbb_br_npc);
    BREAK (sem);
#else
    /* FIXME: Allow provision of explicit ifmt spec in insn spec.  */
    vpc = m32rbf_pbb_cti_chain (current_cpu, sem_arg,
			       CPU_PBB_BR_TYPE (current_cpu),
			       CPU_PBB_BR_NPC (current_cpu));
#endif
#endif
  }

  return vpc;
#undef FLD
}

/* x-chain: --chain-- */

static SEM_PC
SEM_FN_NAME (m32rbf,x_chain) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_M32RBF
    vpc = m32rbf_pbb_chain (current_cpu, sem_arg);
#ifdef DEFINE_SWITCH
    BREAK (sem);
#endif
#endif
  }

  return vpc;
#undef FLD
}

/* x-begin: --begin-- */

static SEM_PC
SEM_FN_NAME (m32rbf,x_begin) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_M32RBF
#if defined DEFINE_SWITCH || defined FAST_P
    /* In the switch case FAST_P is a constant, allowing several optimizations
       in any called inline functions.  */
    vpc = m32rbf_pbb_begin (current_cpu, FAST_P);
#else
#if 0 /* cgen engine can't handle dynamic fast/full switching yet.  */
    vpc = m32rbf_pbb_begin (current_cpu, STATE_RUN_FAST_P (CPU_STATE (current_cpu)));
#else
    vpc = m32rbf_pbb_begin (current_cpu, 0);
#endif
#endif
#endif
  }

  return vpc;
#undef FLD
}

/* add: add $dr,$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,add) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ADDSI (* FLD (i_dr), * FLD (i_sr));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* add3: add3 $dr,$sr,$hash$slo16 */

static SEM_PC
SEM_FN_NAME (m32rbf,add3) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add3.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ADDSI (* FLD (i_sr), FLD (f_simm16));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* and: and $dr,$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,and) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ANDSI (* FLD (i_dr), * FLD (i_sr));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* and3: and3 $dr,$sr,$uimm16 */

static SEM_PC
SEM_FN_NAME (m32rbf,and3) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ANDSI (* FLD (i_sr), FLD (f_uimm16));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* or: or $dr,$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,or) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ORSI (* FLD (i_dr), * FLD (i_sr));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* or3: or3 $dr,$sr,$hash$ulo16 */

static SEM_PC
SEM_FN_NAME (m32rbf,or3) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ORSI (* FLD (i_sr), FLD (f_uimm16));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* xor: xor $dr,$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,xor) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = XORSI (* FLD (i_dr), * FLD (i_sr));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* xor3: xor3 $dr,$sr,$uimm16 */

static SEM_PC
SEM_FN_NAME (m32rbf,xor3) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = XORSI (* FLD (i_sr), FLD (f_uimm16));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* addi: addi $dr,$simm8 */

static SEM_PC
SEM_FN_NAME (m32rbf,addi) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ADDSI (* FLD (i_dr), FLD (f_simm8));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* addv: addv $dr,$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,addv) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI temp0;BI temp1;
  temp0 = ADDSI (* FLD (i_dr), * FLD (i_sr));
  temp1 = ADDOFSI (* FLD (i_dr), * FLD (i_sr), 0);
  {
    SI opval = temp0;
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    BI opval = temp1;
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* addv3: addv3 $dr,$sr,$simm16 */

static SEM_PC
SEM_FN_NAME (m32rbf,addv3) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add3.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

{
  SI temp0;BI temp1;
  temp0 = ADDSI (* FLD (i_sr), FLD (f_simm16));
  temp1 = ADDOFSI (* FLD (i_sr), FLD (f_simm16), 0);
  {
    SI opval = temp0;
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    BI opval = temp1;
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* addx: addx $dr,$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,addx) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI temp0;BI temp1;
  temp0 = ADDCSI (* FLD (i_dr), * FLD (i_sr), CPU (h_cond));
  temp1 = ADDCFSI (* FLD (i_dr), * FLD (i_sr), CPU (h_cond));
  {
    SI opval = temp0;
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    BI opval = temp1;
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* bc8: bc.s $disp8 */

static SEM_PC
SEM_FN_NAME (m32rbf,bc8) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bl8.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (CPU (h_cond)) {
  {
    USI opval = FLD (i_disp8);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bc24: bc.l $disp24 */

static SEM_PC
SEM_FN_NAME (m32rbf,bc24) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bl24.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (CPU (h_cond)) {
  {
    USI opval = FLD (i_disp24);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* beq: beq $src1,$src2,$disp16 */

static SEM_PC
SEM_FN_NAME (m32rbf,beq) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_beq.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (EQSI (* FLD (i_src1), * FLD (i_src2))) {
  {
    USI opval = FLD (i_disp16);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* beqz: beqz $src2,$disp16 */

static SEM_PC
SEM_FN_NAME (m32rbf,beqz) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_beq.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (EQSI (* FLD (i_src2), 0)) {
  {
    USI opval = FLD (i_disp16);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bgez: bgez $src2,$disp16 */

static SEM_PC
SEM_FN_NAME (m32rbf,bgez) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_beq.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (GESI (* FLD (i_src2), 0)) {
  {
    USI opval = FLD (i_disp16);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bgtz: bgtz $src2,$disp16 */

static SEM_PC
SEM_FN_NAME (m32rbf,bgtz) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_beq.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (GTSI (* FLD (i_src2), 0)) {
  {
    USI opval = FLD (i_disp16);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* blez: blez $src2,$disp16 */

static SEM_PC
SEM_FN_NAME (m32rbf,blez) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_beq.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (LESI (* FLD (i_src2), 0)) {
  {
    USI opval = FLD (i_disp16);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bltz: bltz $src2,$disp16 */

static SEM_PC
SEM_FN_NAME (m32rbf,bltz) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_beq.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (LTSI (* FLD (i_src2), 0)) {
  {
    USI opval = FLD (i_disp16);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bnez: bnez $src2,$disp16 */

static SEM_PC
SEM_FN_NAME (m32rbf,bnez) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_beq.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (NESI (* FLD (i_src2), 0)) {
  {
    USI opval = FLD (i_disp16);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bl8: bl.s $disp8 */

static SEM_PC
SEM_FN_NAME (m32rbf,bl8) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bl8.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = ADDSI (ANDSI (pc, -4), 4);
    CPU (h_gr[((UINT) 14)]) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    USI opval = FLD (i_disp8);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bl24: bl.l $disp24 */

static SEM_PC
SEM_FN_NAME (m32rbf,bl24) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bl24.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

{
  {
    SI opval = ADDSI (pc, 4);
    CPU (h_gr[((UINT) 14)]) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    USI opval = FLD (i_disp24);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bnc8: bnc.s $disp8 */

static SEM_PC
SEM_FN_NAME (m32rbf,bnc8) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bl8.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (NOTBI (CPU (h_cond))) {
  {
    USI opval = FLD (i_disp8);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bnc24: bnc.l $disp24 */

static SEM_PC
SEM_FN_NAME (m32rbf,bnc24) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bl24.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (NOTBI (CPU (h_cond))) {
  {
    USI opval = FLD (i_disp24);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bne: bne $src1,$src2,$disp16 */

static SEM_PC
SEM_FN_NAME (m32rbf,bne) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_beq.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (NESI (* FLD (i_src1), * FLD (i_src2))) {
  {
    USI opval = FLD (i_disp16);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bra8: bra.s $disp8 */

static SEM_PC
SEM_FN_NAME (m32rbf,bra8) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bl8.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    USI opval = FLD (i_disp8);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bra24: bra.l $disp24 */

static SEM_PC
SEM_FN_NAME (m32rbf,bra24) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bl24.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    USI opval = FLD (i_disp24);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* cmp: cmp $src1,$src2 */

static SEM_PC
SEM_FN_NAME (m32rbf,cmp) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_st_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = LTSI (* FLD (i_src1), * FLD (i_src2));
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* cmpi: cmpi $src2,$simm16 */

static SEM_PC
SEM_FN_NAME (m32rbf,cmpi) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    BI opval = LTSI (* FLD (i_src2), FLD (f_simm16));
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* cmpu: cmpu $src1,$src2 */

static SEM_PC
SEM_FN_NAME (m32rbf,cmpu) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_st_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = LTUSI (* FLD (i_src1), * FLD (i_src2));
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* cmpui: cmpui $src2,$simm16 */

static SEM_PC
SEM_FN_NAME (m32rbf,cmpui) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    BI opval = LTUSI (* FLD (i_src2), FLD (f_simm16));
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* div: div $dr,$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,div) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (NESI (* FLD (i_sr), 0)) {
  {
    SI opval = DIVSI (* FLD (i_dr), * FLD (i_sr));
    * FLD (i_dr) = opval;
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* divu: divu $dr,$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,divu) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (NESI (* FLD (i_sr), 0)) {
  {
    SI opval = UDIVSI (* FLD (i_dr), * FLD (i_sr));
    * FLD (i_dr) = opval;
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* rem: rem $dr,$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,rem) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (NESI (* FLD (i_sr), 0)) {
  {
    SI opval = MODSI (* FLD (i_dr), * FLD (i_sr));
    * FLD (i_dr) = opval;
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* remu: remu $dr,$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,remu) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (NESI (* FLD (i_sr), 0)) {
  {
    SI opval = UMODSI (* FLD (i_dr), * FLD (i_sr));
    * FLD (i_dr) = opval;
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* jl: jl $sr */

static SEM_PC
SEM_FN_NAME (m32rbf,jl) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_jl.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI temp0;USI temp1;
  temp0 = ADDSI (ANDSI (pc, -4), 4);
  temp1 = ANDSI (* FLD (i_sr), -4);
  {
    SI opval = temp0;
    CPU (h_gr[((UINT) 14)]) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    USI opval = temp1;
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* jmp: jmp $sr */

static SEM_PC
SEM_FN_NAME (m32rbf,jmp) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_jl.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    USI opval = ANDSI (* FLD (i_sr), -4);
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* ld: ld $dr,@@$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,ld) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GETMEMSI (current_cpu, pc, * FLD (i_sr));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* ld-d: ld $dr,@@($slo16,$sr) */

static SEM_PC
SEM_FN_NAME (m32rbf,ld_d) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add3.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = GETMEMSI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16)));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* ldb: ldb $dr,@@$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,ldb) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTQISI (GETMEMQI (current_cpu, pc, * FLD (i_sr)));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* ldb-d: ldb $dr,@@($slo16,$sr) */

static SEM_PC
SEM_FN_NAME (m32rbf,ldb_d) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add3.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = EXTQISI (GETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16))));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* ldh: ldh $dr,@@$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,ldh) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTHISI (GETMEMHI (current_cpu, pc, * FLD (i_sr)));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* ldh-d: ldh $dr,@@($slo16,$sr) */

static SEM_PC
SEM_FN_NAME (m32rbf,ldh_d) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add3.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = EXTHISI (GETMEMHI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16))));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* ldub: ldub $dr,@@$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,ldub) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ZEXTQISI (GETMEMQI (current_cpu, pc, * FLD (i_sr)));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* ldub-d: ldub $dr,@@($slo16,$sr) */

static SEM_PC
SEM_FN_NAME (m32rbf,ldub_d) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add3.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ZEXTQISI (GETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16))));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* lduh: lduh $dr,@@$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,lduh) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ZEXTHISI (GETMEMHI (current_cpu, pc, * FLD (i_sr)));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* lduh-d: lduh $dr,@@($slo16,$sr) */

static SEM_PC
SEM_FN_NAME (m32rbf,lduh_d) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add3.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ZEXTHISI (GETMEMHI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16))));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* ld-plus: ld $dr,@@$sr+ */

static SEM_PC
SEM_FN_NAME (m32rbf,ld_plus) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI temp0;SI temp1;
  temp0 = GETMEMSI (current_cpu, pc, * FLD (i_sr));
  temp1 = ADDSI (* FLD (i_sr), 4);
  {
    SI opval = temp0;
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    SI opval = temp1;
    * FLD (i_sr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* ld24: ld24 $dr,$uimm24 */

static SEM_PC
SEM_FN_NAME (m32rbf,ld24) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_ld24.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = FLD (i_uimm24);
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* ldi8: ldi8 $dr,$simm8 */

static SEM_PC
SEM_FN_NAME (m32rbf,ldi8) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = FLD (f_simm8);
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* ldi16: ldi16 $dr,$hash$slo16 */

static SEM_PC
SEM_FN_NAME (m32rbf,ldi16) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add3.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = FLD (f_simm16);
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* lock: lock $dr,@@$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,lock) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    BI opval = 1;
    CPU (h_lock) = opval;
    TRACE_RESULT (current_cpu, abuf, "lock", 'x', opval);
  }
  {
    SI opval = GETMEMSI (current_cpu, pc, * FLD (i_sr));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* machi: machi $src1,$src2 */

static SEM_PC
SEM_FN_NAME (m32rbf,machi) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_st_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = SRADI (SLLDI (ADDDI (GET_H_ACCUM (), MULDI (EXTSIDI (ANDSI (* FLD (i_src1), 0xffff0000)), EXTHIDI (TRUNCSIHI (SRASI (* FLD (i_src2), 16))))), 8), 8);
    SET_H_ACCUM (opval);
    TRACE_RESULT (current_cpu, abuf, "accum", 'D', opval);
  }

  return vpc;
#undef FLD
}

/* maclo: maclo $src1,$src2 */

static SEM_PC
SEM_FN_NAME (m32rbf,maclo) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_st_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = SRADI (SLLDI (ADDDI (GET_H_ACCUM (), MULDI (EXTSIDI (SLLSI (* FLD (i_src1), 16)), EXTHIDI (TRUNCSIHI (* FLD (i_src2))))), 8), 8);
    SET_H_ACCUM (opval);
    TRACE_RESULT (current_cpu, abuf, "accum", 'D', opval);
  }

  return vpc;
#undef FLD
}

/* macwhi: macwhi $src1,$src2 */

static SEM_PC
SEM_FN_NAME (m32rbf,macwhi) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_st_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = SRADI (SLLDI (ADDDI (GET_H_ACCUM (), MULDI (EXTSIDI (* FLD (i_src1)), EXTHIDI (TRUNCSIHI (SRASI (* FLD (i_src2), 16))))), 8), 8);
    SET_H_ACCUM (opval);
    TRACE_RESULT (current_cpu, abuf, "accum", 'D', opval);
  }

  return vpc;
#undef FLD
}

/* macwlo: macwlo $src1,$src2 */

static SEM_PC
SEM_FN_NAME (m32rbf,macwlo) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_st_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = SRADI (SLLDI (ADDDI (GET_H_ACCUM (), MULDI (EXTSIDI (* FLD (i_src1)), EXTHIDI (TRUNCSIHI (* FLD (i_src2))))), 8), 8);
    SET_H_ACCUM (opval);
    TRACE_RESULT (current_cpu, abuf, "accum", 'D', opval);
  }

  return vpc;
#undef FLD
}

/* mul: mul $dr,$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,mul) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = MULSI (* FLD (i_dr), * FLD (i_sr));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* mulhi: mulhi $src1,$src2 */

static SEM_PC
SEM_FN_NAME (m32rbf,mulhi) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_st_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = SRADI (SLLDI (MULDI (EXTSIDI (ANDSI (* FLD (i_src1), 0xffff0000)), EXTHIDI (TRUNCSIHI (SRASI (* FLD (i_src2), 16)))), 16), 16);
    SET_H_ACCUM (opval);
    TRACE_RESULT (current_cpu, abuf, "accum", 'D', opval);
  }

  return vpc;
#undef FLD
}

/* mullo: mullo $src1,$src2 */

static SEM_PC
SEM_FN_NAME (m32rbf,mullo) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_st_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = SRADI (SLLDI (MULDI (EXTSIDI (SLLSI (* FLD (i_src1), 16)), EXTHIDI (TRUNCSIHI (* FLD (i_src2)))), 16), 16);
    SET_H_ACCUM (opval);
    TRACE_RESULT (current_cpu, abuf, "accum", 'D', opval);
  }

  return vpc;
#undef FLD
}

/* mulwhi: mulwhi $src1,$src2 */

static SEM_PC
SEM_FN_NAME (m32rbf,mulwhi) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_st_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = SRADI (SLLDI (MULDI (EXTSIDI (* FLD (i_src1)), EXTHIDI (TRUNCSIHI (SRASI (* FLD (i_src2), 16)))), 8), 8);
    SET_H_ACCUM (opval);
    TRACE_RESULT (current_cpu, abuf, "accum", 'D', opval);
  }

  return vpc;
#undef FLD
}

/* mulwlo: mulwlo $src1,$src2 */

static SEM_PC
SEM_FN_NAME (m32rbf,mulwlo) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_st_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = SRADI (SLLDI (MULDI (EXTSIDI (* FLD (i_src1)), EXTHIDI (TRUNCSIHI (* FLD (i_src2)))), 8), 8);
    SET_H_ACCUM (opval);
    TRACE_RESULT (current_cpu, abuf, "accum", 'D', opval);
  }

  return vpc;
#undef FLD
}

/* mv: mv $dr,$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,mv) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = * FLD (i_sr);
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* mvfachi: mvfachi $dr */

static SEM_PC
SEM_FN_NAME (m32rbf,mvfachi) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_seth.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = TRUNCDISI (SRADI (GET_H_ACCUM (), 32));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* mvfaclo: mvfaclo $dr */

static SEM_PC
SEM_FN_NAME (m32rbf,mvfaclo) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_seth.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = TRUNCDISI (GET_H_ACCUM ());
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* mvfacmi: mvfacmi $dr */

static SEM_PC
SEM_FN_NAME (m32rbf,mvfacmi) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_seth.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = TRUNCDISI (SRADI (GET_H_ACCUM (), 16));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* mvfc: mvfc $dr,$scr */

static SEM_PC
SEM_FN_NAME (m32rbf,mvfc) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_CR (FLD (f_r2));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* mvtachi: mvtachi $src1 */

static SEM_PC
SEM_FN_NAME (m32rbf,mvtachi) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_st_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = ORDI (ANDDI (GET_H_ACCUM (), MAKEDI (0, 0xffffffff)), SLLDI (EXTSIDI (* FLD (i_src1)), 32));
    SET_H_ACCUM (opval);
    TRACE_RESULT (current_cpu, abuf, "accum", 'D', opval);
  }

  return vpc;
#undef FLD
}

/* mvtaclo: mvtaclo $src1 */

static SEM_PC
SEM_FN_NAME (m32rbf,mvtaclo) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_st_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = ORDI (ANDDI (GET_H_ACCUM (), MAKEDI (0xffffffff, 0)), ZEXTSIDI (* FLD (i_src1)));
    SET_H_ACCUM (opval);
    TRACE_RESULT (current_cpu, abuf, "accum", 'D', opval);
  }

  return vpc;
#undef FLD
}

/* mvtc: mvtc $sr,$dcr */

static SEM_PC
SEM_FN_NAME (m32rbf,mvtc) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    USI opval = * FLD (i_sr);
    SET_H_CR (FLD (f_r1), opval);
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* neg: neg $dr,$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,neg) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = NEGSI (* FLD (i_sr));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* nop: nop */

static SEM_PC
SEM_FN_NAME (m32rbf,nop) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

PROFILE_COUNT_FILLNOPS (current_cpu, abuf->addr);

  return vpc;
#undef FLD
}

/* not: not $dr,$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,not) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = INVSI (* FLD (i_sr));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* rac: rac */

static SEM_PC
SEM_FN_NAME (m32rbf,rac) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_tmp1;
  tmp_tmp1 = SLLDI (GET_H_ACCUM (), 1);
  tmp_tmp1 = ADDDI (tmp_tmp1, MAKEDI (0, 32768));
  {
    DI opval = (GTDI (tmp_tmp1, MAKEDI (32767, 0xffff0000))) ? (MAKEDI (32767, 0xffff0000)) : (LTDI (tmp_tmp1, MAKEDI (0xffff8000, 0))) ? (MAKEDI (0xffff8000, 0)) : (ANDDI (tmp_tmp1, MAKEDI (0xffffffff, 0xffff0000)));
    SET_H_ACCUM (opval);
    TRACE_RESULT (current_cpu, abuf, "accum", 'D', opval);
  }
}

  return vpc;
#undef FLD
}

/* rach: rach */

static SEM_PC
SEM_FN_NAME (m32rbf,rach) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_tmp1;
  tmp_tmp1 = ANDDI (GET_H_ACCUM (), MAKEDI (16777215, 0xffffffff));
if (ANDIF (GEDI (tmp_tmp1, MAKEDI (16383, 0x80000000)), LEDI (tmp_tmp1, MAKEDI (8388607, 0xffffffff)))) {
  tmp_tmp1 = MAKEDI (16383, 0x80000000);
} else {
if (ANDIF (GEDI (tmp_tmp1, MAKEDI (8388608, 0)), LEDI (tmp_tmp1, MAKEDI (16760832, 0)))) {
  tmp_tmp1 = MAKEDI (16760832, 0);
} else {
  tmp_tmp1 = ANDDI (ADDDI (GET_H_ACCUM (), MAKEDI (0, 1073741824)), MAKEDI (0xffffffff, 0x80000000));
}
}
  tmp_tmp1 = SLLDI (tmp_tmp1, 1);
  {
    DI opval = SRADI (SLLDI (tmp_tmp1, 7), 7);
    SET_H_ACCUM (opval);
    TRACE_RESULT (current_cpu, abuf, "accum", 'D', opval);
  }
}

  return vpc;
#undef FLD
}

/* rte: rte */

static SEM_PC
SEM_FN_NAME (m32rbf,rte) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    USI opval = ANDSI (GET_H_CR (((UINT) 6)), -4);
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
  {
    USI opval = GET_H_CR (((UINT) 14));
    SET_H_CR (((UINT) 6), opval);
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }
  {
    UQI opval = CPU (h_bpsw);
    SET_H_PSW (opval);
    TRACE_RESULT (current_cpu, abuf, "psw", 'x', opval);
  }
  {
    UQI opval = CPU (h_bbpsw);
    CPU (h_bpsw) = opval;
    TRACE_RESULT (current_cpu, abuf, "bpsw", 'x', opval);
  }
}

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* seth: seth $dr,$hash$hi16 */

static SEM_PC
SEM_FN_NAME (m32rbf,seth) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_seth.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = SLLSI (FLD (f_hi16), 16);
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* sll: sll $dr,$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,sll) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SLLSI (* FLD (i_dr), ANDSI (* FLD (i_sr), 31));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* sll3: sll3 $dr,$sr,$simm16 */

static SEM_PC
SEM_FN_NAME (m32rbf,sll3) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add3.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = SLLSI (* FLD (i_sr), ANDSI (FLD (f_simm16), 31));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* slli: slli $dr,$uimm5 */

static SEM_PC
SEM_FN_NAME (m32rbf,slli) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_slli.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SLLSI (* FLD (i_dr), FLD (f_uimm5));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* sra: sra $dr,$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,sra) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SRASI (* FLD (i_dr), ANDSI (* FLD (i_sr), 31));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* sra3: sra3 $dr,$sr,$simm16 */

static SEM_PC
SEM_FN_NAME (m32rbf,sra3) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add3.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = SRASI (* FLD (i_sr), ANDSI (FLD (f_simm16), 31));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* srai: srai $dr,$uimm5 */

static SEM_PC
SEM_FN_NAME (m32rbf,srai) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_slli.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SRASI (* FLD (i_dr), FLD (f_uimm5));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* srl: srl $dr,$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,srl) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SRLSI (* FLD (i_dr), ANDSI (* FLD (i_sr), 31));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* srl3: srl3 $dr,$sr,$simm16 */

static SEM_PC
SEM_FN_NAME (m32rbf,srl3) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add3.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = SRLSI (* FLD (i_sr), ANDSI (FLD (f_simm16), 31));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* srli: srli $dr,$uimm5 */

static SEM_PC
SEM_FN_NAME (m32rbf,srli) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_slli.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SRLSI (* FLD (i_dr), FLD (f_uimm5));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* st: st $src1,@@$src2 */

static SEM_PC
SEM_FN_NAME (m32rbf,st) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_st_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = * FLD (i_src1);
    SETMEMSI (current_cpu, pc, * FLD (i_src2), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* st-d: st $src1,@@($slo16,$src2) */

static SEM_PC
SEM_FN_NAME (m32rbf,st_d) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = * FLD (i_src1);
    SETMEMSI (current_cpu, pc, ADDSI (* FLD (i_src2), FLD (f_simm16)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* stb: stb $src1,@@$src2 */

static SEM_PC
SEM_FN_NAME (m32rbf,stb) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_st_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    QI opval = * FLD (i_src1);
    SETMEMQI (current_cpu, pc, * FLD (i_src2), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* stb-d: stb $src1,@@($slo16,$src2) */

static SEM_PC
SEM_FN_NAME (m32rbf,stb_d) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    QI opval = * FLD (i_src1);
    SETMEMQI (current_cpu, pc, ADDSI (* FLD (i_src2), FLD (f_simm16)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* sth: sth $src1,@@$src2 */

static SEM_PC
SEM_FN_NAME (m32rbf,sth) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_st_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    HI opval = * FLD (i_src1);
    SETMEMHI (current_cpu, pc, * FLD (i_src2), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* sth-d: sth $src1,@@($slo16,$src2) */

static SEM_PC
SEM_FN_NAME (m32rbf,sth_d) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    HI opval = * FLD (i_src1);
    SETMEMHI (current_cpu, pc, ADDSI (* FLD (i_src2), FLD (f_simm16)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* st-plus: st $src1,@@+$src2 */

static SEM_PC
SEM_FN_NAME (m32rbf,st_plus) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_st_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI tmp_new_src2;
  tmp_new_src2 = ADDSI (* FLD (i_src2), 4);
  {
    SI opval = * FLD (i_src1);
    SETMEMSI (current_cpu, pc, tmp_new_src2, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = tmp_new_src2;
    * FLD (i_src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* st-minus: st $src1,@@-$src2 */

static SEM_PC
SEM_FN_NAME (m32rbf,st_minus) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_st_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI tmp_new_src2;
  tmp_new_src2 = SUBSI (* FLD (i_src2), 4);
  {
    SI opval = * FLD (i_src1);
    SETMEMSI (current_cpu, pc, tmp_new_src2, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = tmp_new_src2;
    * FLD (i_src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* sub: sub $dr,$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,sub) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SUBSI (* FLD (i_dr), * FLD (i_sr));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* subv: subv $dr,$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,subv) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI temp0;BI temp1;
  temp0 = SUBSI (* FLD (i_dr), * FLD (i_sr));
  temp1 = SUBOFSI (* FLD (i_dr), * FLD (i_sr), 0);
  {
    SI opval = temp0;
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    BI opval = temp1;
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* subx: subx $dr,$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,subx) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_add.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI temp0;BI temp1;
  temp0 = SUBCSI (* FLD (i_dr), * FLD (i_sr), CPU (h_cond));
  temp1 = SUBCFSI (* FLD (i_dr), * FLD (i_sr), CPU (h_cond));
  {
    SI opval = temp0;
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    BI opval = temp1;
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* trap: trap $uimm4 */

static SEM_PC
SEM_FN_NAME (m32rbf,trap) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_trap.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    USI opval = GET_H_CR (((UINT) 6));
    SET_H_CR (((UINT) 14), opval);
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }
  {
    USI opval = ADDSI (pc, 4);
    SET_H_CR (((UINT) 6), opval);
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }
  {
    UQI opval = CPU (h_bpsw);
    CPU (h_bbpsw) = opval;
    TRACE_RESULT (current_cpu, abuf, "bbpsw", 'x', opval);
  }
  {
    UQI opval = GET_H_PSW ();
    CPU (h_bpsw) = opval;
    TRACE_RESULT (current_cpu, abuf, "bpsw", 'x', opval);
  }
  {
    UQI opval = ANDQI (GET_H_PSW (), 128);
    SET_H_PSW (opval);
    TRACE_RESULT (current_cpu, abuf, "psw", 'x', opval);
  }
  {
    SI opval = m32r_trap (current_cpu, pc, FLD (f_uimm4));
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* unlock: unlock $src1,@@$src2 */

static SEM_PC
SEM_FN_NAME (m32rbf,unlock) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_st_plus.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
if (CPU (h_lock)) {
  {
    SI opval = * FLD (i_src1);
    SETMEMSI (current_cpu, pc, * FLD (i_src2), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
}
  {
    BI opval = 0;
    CPU (h_lock) = opval;
    TRACE_RESULT (current_cpu, abuf, "lock", 'x', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* clrpsw: clrpsw $uimm8 */

static SEM_PC
SEM_FN_NAME (m32rbf,clrpsw) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_clrpsw.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    USI opval = ANDSI (GET_H_CR (((UINT) 0)), ORSI (ZEXTQISI (INVQI (FLD (f_uimm8))), 65280));
    SET_H_CR (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* setpsw: setpsw $uimm8 */

static SEM_PC
SEM_FN_NAME (m32rbf,setpsw) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_clrpsw.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    USI opval = FLD (f_uimm8);
    SET_H_CR (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* bset: bset $uimm3,@@($slo16,$sr) */

static SEM_PC
SEM_FN_NAME (m32rbf,bset) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bset.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    QI opval = ORQI (GETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16))), SLLQI (1, SUBSI (7, FLD (f_uimm3))));
    SETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* bclr: bclr $uimm3,@@($slo16,$sr) */

static SEM_PC
SEM_FN_NAME (m32rbf,bclr) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bset.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    QI opval = ANDQI (GETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16))), INVQI (SLLQI (1, SUBSI (7, FLD (f_uimm3)))));
    SETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* btst: btst $uimm3,$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,btst) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bset.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = ANDQI (SRLQI (* FLD (i_sr), SUBSI (7, FLD (f_uimm3))), 1);
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* Table of all semantic fns.  */

static const struct sem_fn_desc sem_fns[] = {
  { M32RBF_INSN_X_INVALID, SEM_FN_NAME (m32rbf,x_invalid) },
  { M32RBF_INSN_X_AFTER, SEM_FN_NAME (m32rbf,x_after) },
  { M32RBF_INSN_X_BEFORE, SEM_FN_NAME (m32rbf,x_before) },
  { M32RBF_INSN_X_CTI_CHAIN, SEM_FN_NAME (m32rbf,x_cti_chain) },
  { M32RBF_INSN_X_CHAIN, SEM_FN_NAME (m32rbf,x_chain) },
  { M32RBF_INSN_X_BEGIN, SEM_FN_NAME (m32rbf,x_begin) },
  { M32RBF_INSN_ADD, SEM_FN_NAME (m32rbf,add) },
  { M32RBF_INSN_ADD3, SEM_FN_NAME (m32rbf,add3) },
  { M32RBF_INSN_AND, SEM_FN_NAME (m32rbf,and) },
  { M32RBF_INSN_AND3, SEM_FN_NAME (m32rbf,and3) },
  { M32RBF_INSN_OR, SEM_FN_NAME (m32rbf,or) },
  { M32RBF_INSN_OR3, SEM_FN_NAME (m32rbf,or3) },
  { M32RBF_INSN_XOR, SEM_FN_NAME (m32rbf,xor) },
  { M32RBF_INSN_XOR3, SEM_FN_NAME (m32rbf,xor3) },
  { M32RBF_INSN_ADDI, SEM_FN_NAME (m32rbf,addi) },
  { M32RBF_INSN_ADDV, SEM_FN_NAME (m32rbf,addv) },
  { M32RBF_INSN_ADDV3, SEM_FN_NAME (m32rbf,addv3) },
  { M32RBF_INSN_ADDX, SEM_FN_NAME (m32rbf,addx) },
  { M32RBF_INSN_BC8, SEM_FN_NAME (m32rbf,bc8) },
  { M32RBF_INSN_BC24, SEM_FN_NAME (m32rbf,bc24) },
  { M32RBF_INSN_BEQ, SEM_FN_NAME (m32rbf,beq) },
  { M32RBF_INSN_BEQZ, SEM_FN_NAME (m32rbf,beqz) },
  { M32RBF_INSN_BGEZ, SEM_FN_NAME (m32rbf,bgez) },
  { M32RBF_INSN_BGTZ, SEM_FN_NAME (m32rbf,bgtz) },
  { M32RBF_INSN_BLEZ, SEM_FN_NAME (m32rbf,blez) },
  { M32RBF_INSN_BLTZ, SEM_FN_NAME (m32rbf,bltz) },
  { M32RBF_INSN_BNEZ, SEM_FN_NAME (m32rbf,bnez) },
  { M32RBF_INSN_BL8, SEM_FN_NAME (m32rbf,bl8) },
  { M32RBF_INSN_BL24, SEM_FN_NAME (m32rbf,bl24) },
  { M32RBF_INSN_BNC8, SEM_FN_NAME (m32rbf,bnc8) },
  { M32RBF_INSN_BNC24, SEM_FN_NAME (m32rbf,bnc24) },
  { M32RBF_INSN_BNE, SEM_FN_NAME (m32rbf,bne) },
  { M32RBF_INSN_BRA8, SEM_FN_NAME (m32rbf,bra8) },
  { M32RBF_INSN_BRA24, SEM_FN_NAME (m32rbf,bra24) },
  { M32RBF_INSN_CMP, SEM_FN_NAME (m32rbf,cmp) },
  { M32RBF_INSN_CMPI, SEM_FN_NAME (m32rbf,cmpi) },
  { M32RBF_INSN_CMPU, SEM_FN_NAME (m32rbf,cmpu) },
  { M32RBF_INSN_CMPUI, SEM_FN_NAME (m32rbf,cmpui) },
  { M32RBF_INSN_DIV, SEM_FN_NAME (m32rbf,div) },
  { M32RBF_INSN_DIVU, SEM_FN_NAME (m32rbf,divu) },
  { M32RBF_INSN_REM, SEM_FN_NAME (m32rbf,rem) },
  { M32RBF_INSN_REMU, SEM_FN_NAME (m32rbf,remu) },
  { M32RBF_INSN_JL, SEM_FN_NAME (m32rbf,jl) },
  { M32RBF_INSN_JMP, SEM_FN_NAME (m32rbf,jmp) },
  { M32RBF_INSN_LD, SEM_FN_NAME (m32rbf,ld) },
  { M32RBF_INSN_LD_D, SEM_FN_NAME (m32rbf,ld_d) },
  { M32RBF_INSN_LDB, SEM_FN_NAME (m32rbf,ldb) },
  { M32RBF_INSN_LDB_D, SEM_FN_NAME (m32rbf,ldb_d) },
  { M32RBF_INSN_LDH, SEM_FN_NAME (m32rbf,ldh) },
  { M32RBF_INSN_LDH_D, SEM_FN_NAME (m32rbf,ldh_d) },
  { M32RBF_INSN_LDUB, SEM_FN_NAME (m32rbf,ldub) },
  { M32RBF_INSN_LDUB_D, SEM_FN_NAME (m32rbf,ldub_d) },
  { M32RBF_INSN_LDUH, SEM_FN_NAME (m32rbf,lduh) },
  { M32RBF_INSN_LDUH_D, SEM_FN_NAME (m32rbf,lduh_d) },
  { M32RBF_INSN_LD_PLUS, SEM_FN_NAME (m32rbf,ld_plus) },
  { M32RBF_INSN_LD24, SEM_FN_NAME (m32rbf,ld24) },
  { M32RBF_INSN_LDI8, SEM_FN_NAME (m32rbf,ldi8) },
  { M32RBF_INSN_LDI16, SEM_FN_NAME (m32rbf,ldi16) },
  { M32RBF_INSN_LOCK, SEM_FN_NAME (m32rbf,lock) },
  { M32RBF_INSN_MACHI, SEM_FN_NAME (m32rbf,machi) },
  { M32RBF_INSN_MACLO, SEM_FN_NAME (m32rbf,maclo) },
  { M32RBF_INSN_MACWHI, SEM_FN_NAME (m32rbf,macwhi) },
  { M32RBF_INSN_MACWLO, SEM_FN_NAME (m32rbf,macwlo) },
  { M32RBF_INSN_MUL, SEM_FN_NAME (m32rbf,mul) },
  { M32RBF_INSN_MULHI, SEM_FN_NAME (m32rbf,mulhi) },
  { M32RBF_INSN_MULLO, SEM_FN_NAME (m32rbf,mullo) },
  { M32RBF_INSN_MULWHI, SEM_FN_NAME (m32rbf,mulwhi) },
  { M32RBF_INSN_MULWLO, SEM_FN_NAME (m32rbf,mulwlo) },
  { M32RBF_INSN_MV, SEM_FN_NAME (m32rbf,mv) },
  { M32RBF_INSN_MVFACHI, SEM_FN_NAME (m32rbf,mvfachi) },
  { M32RBF_INSN_MVFACLO, SEM_FN_NAME (m32rbf,mvfaclo) },
  { M32RBF_INSN_MVFACMI, SEM_FN_NAME (m32rbf,mvfacmi) },
  { M32RBF_INSN_MVFC, SEM_FN_NAME (m32rbf,mvfc) },
  { M32RBF_INSN_MVTACHI, SEM_FN_NAME (m32rbf,mvtachi) },
  { M32RBF_INSN_MVTACLO, SEM_FN_NAME (m32rbf,mvtaclo) },
  { M32RBF_INSN_MVTC, SEM_FN_NAME (m32rbf,mvtc) },
  { M32RBF_INSN_NEG, SEM_FN_NAME (m32rbf,neg) },
  { M32RBF_INSN_NOP, SEM_FN_NAME (m32rbf,nop) },
  { M32RBF_INSN_NOT, SEM_FN_NAME (m32rbf,not) },
  { M32RBF_INSN_RAC, SEM_FN_NAME (m32rbf,rac) },
  { M32RBF_INSN_RACH, SEM_FN_NAME (m32rbf,rach) },
  { M32RBF_INSN_RTE, SEM_FN_NAME (m32rbf,rte) },
  { M32RBF_INSN_SETH, SEM_FN_NAME (m32rbf,seth) },
  { M32RBF_INSN_SLL, SEM_FN_NAME (m32rbf,sll) },
  { M32RBF_INSN_SLL3, SEM_FN_NAME (m32rbf,sll3) },
  { M32RBF_INSN_SLLI, SEM_FN_NAME (m32rbf,slli) },
  { M32RBF_INSN_SRA, SEM_FN_NAME (m32rbf,sra) },
  { M32RBF_INSN_SRA3, SEM_FN_NAME (m32rbf,sra3) },
  { M32RBF_INSN_SRAI, SEM_FN_NAME (m32rbf,srai) },
  { M32RBF_INSN_SRL, SEM_FN_NAME (m32rbf,srl) },
  { M32RBF_INSN_SRL3, SEM_FN_NAME (m32rbf,srl3) },
  { M32RBF_INSN_SRLI, SEM_FN_NAME (m32rbf,srli) },
  { M32RBF_INSN_ST, SEM_FN_NAME (m32rbf,st) },
  { M32RBF_INSN_ST_D, SEM_FN_NAME (m32rbf,st_d) },
  { M32RBF_INSN_STB, SEM_FN_NAME (m32rbf,stb) },
  { M32RBF_INSN_STB_D, SEM_FN_NAME (m32rbf,stb_d) },
  { M32RBF_INSN_STH, SEM_FN_NAME (m32rbf,sth) },
  { M32RBF_INSN_STH_D, SEM_FN_NAME (m32rbf,sth_d) },
  { M32RBF_INSN_ST_PLUS, SEM_FN_NAME (m32rbf,st_plus) },
  { M32RBF_INSN_ST_MINUS, SEM_FN_NAME (m32rbf,st_minus) },
  { M32RBF_INSN_SUB, SEM_FN_NAME (m32rbf,sub) },
  { M32RBF_INSN_SUBV, SEM_FN_NAME (m32rbf,subv) },
  { M32RBF_INSN_SUBX, SEM_FN_NAME (m32rbf,subx) },
  { M32RBF_INSN_TRAP, SEM_FN_NAME (m32rbf,trap) },
  { M32RBF_INSN_UNLOCK, SEM_FN_NAME (m32rbf,unlock) },
  { M32RBF_INSN_CLRPSW, SEM_FN_NAME (m32rbf,clrpsw) },
  { M32RBF_INSN_SETPSW, SEM_FN_NAME (m32rbf,setpsw) },
  { M32RBF_INSN_BSET, SEM_FN_NAME (m32rbf,bset) },
  { M32RBF_INSN_BCLR, SEM_FN_NAME (m32rbf,bclr) },
  { M32RBF_INSN_BTST, SEM_FN_NAME (m32rbf,btst) },
  { 0, 0 }
};

/* Add the semantic fns to IDESC_TABLE.  */

void
SEM_FN_NAME (m32rbf,init_idesc_table) (SIM_CPU *current_cpu)
{
  IDESC *idesc_table = CPU_IDESC (current_cpu);
  const struct sem_fn_desc *sf;
  int mach_num = MACH_NUM (CPU_MACH (current_cpu));

  for (sf = &sem_fns[0]; sf->fn != 0; ++sf)
    {
      const CGEN_INSN *insn = idesc_table[sf->index].idata;
      int valid_p = (CGEN_INSN_VIRTUAL_P (insn)
		     || CGEN_INSN_MACH_HAS_P (insn, mach_num));
#if FAST_P
      if (valid_p)
	idesc_table[sf->index].sem_fast = sf->fn;
      else
	idesc_table[sf->index].sem_fast = SEM_FN_NAME (m32rbf,x_invalid);
#else
      if (valid_p)
	idesc_table[sf->index].sem_full = sf->fn;
      else
	idesc_table[sf->index].sem_full = SEM_FN_NAME (m32rbf,x_invalid);
#endif
    }
}

@


1.13
log
@[sim] Update old contact info in GPL license notices

sim/ChangeLog:

        Update old contact info in GPL license notices.
@
text
@d5 1
a5 1
Copyright 1996-2010, 2012 Free Software Foundation, Inc.
@


1.12
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d20 1
a20 2
   with this program; if not, write to the Free Software Foundation, Inc.,
   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
@


1.11
log
@Regenerate cgen-derived files.
@
text
@d5 1
a5 1
Copyright 1996-2010 Free Software Foundation, Inc.
@


1.11.8.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d5 1
a5 1
Copyright 1996-2010, 2012 Free Software Foundation, Inc.
@


1.10
log
@Regenerate cgen files, update copyright year.
@
text
@a32 1
#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
a33 3
#else
#define GET_ATTR(cpu, num, attr) CGEN_ATTR_VALUE (NULL, abuf->idesc->attrs, CGEN_INSN_/**/attr)
#endif
d51 1
a51 1
#define FLD(f) abuf->fields.fmt_empty.f
d78 1
a78 1
#define FLD(f) abuf->fields.fmt_empty.f
d99 1
a99 1
#define FLD(f) abuf->fields.fmt_empty.f
d120 1
a120 1
#define FLD(f) abuf->fields.fmt_empty.f
d150 1
a150 1
#define FLD(f) abuf->fields.fmt_empty.f
d174 1
a174 1
#define FLD(f) abuf->fields.fmt_empty.f
d1867 1
a1867 1
#define FLD(f) abuf->fields.fmt_empty.f
d1905 1
a1905 1
#define FLD(f) abuf->fields.fmt_empty.f
d1931 1
a1931 1
#define FLD(f) abuf->fields.fmt_empty.f
d1966 1
a1966 1
#define FLD(f) abuf->fields.fmt_empty.f
@


1.9
log
@	* arch.c: Regenerate.
	* arch.h: Regenerate.
	* cpu.c: Regenerate.
	* cpu.h: Regenerate.
	* cpu2.c: Regenerate.
	* cpu2.h: Regenerate.
	* cpuall.h: Regenerate.
	* cpux.c: Regenerate.
	* cpux.h: Regenerate.
	* decode.c: Regenerate.
	* decode.h: Regenerate.
	* decode2.c: Regenerate.
	* decode2.h: Regenerate.
	* decodex.c: Regenerate.
	* decodex.h: Regenerate.
	* model.c: Regenerate.
	* model2.c: Regenerate.
	* modelx.c: Regenerate.
	* sem-switch.c: Regenerate.
	* sem.c: Regenerate.
	* sem2-switch.c: Regenerate.
	* semx-switch.c: Regenerate.
@
text
@d5 1
a5 1
Copyright 1996-2009 Free Software Foundation, Inc.
@


1.8
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d5 1
a5 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d9 13
a21 12
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
d2578 1
a2578 1
    SI opval = ANDSI (GET_H_CR (((UINT) 0)), ORSI (INVBI (FLD (f_uimm8)), 65280));
d2599 1
a2599 1
    SI opval = FLD (f_uimm8);
d2620 1
a2620 1
    QI opval = ORQI (GETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16))), SLLSI (1, SUBSI (7, FLD (f_uimm3))));
d2641 1
a2641 1
    QI opval = ANDQI (GETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16))), INVQI (SLLSI (1, SUBSI (7, FLD (f_uimm3)))));
d2662 1
a2662 1
    BI opval = ANDQI (SRLSI (* FLD (i_sr), SUBSI (7, FLD (f_uimm3))), 1);
@


1.7
log
@Add support for the m32r2 processor
@
text
@d11 2
a12 2
the Free Software Foundation; either version 2, or (at your option)
any later version.
d19 2
a20 3
You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@


1.6
log
@	* arch.c,arch.h,cpuall.h: Regenerate.
	* cpu.c,cpu.h,decode.c,decode.h,model.c,sem-switch.c,sem.c: Regenerate.
	* cpux.c,cpux.h,decodex.c,decodex.h,modelx.c,semx-switch.c: Regenerate.
@
text
@d5 1
a5 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d2566 105
d2779 5
@


1.5
log
@2001-11-14  Dave Brolley  <brolley@@redhat.com>

	* arch.c: Regenerate.
	* arch.h: Regenerate.
	* cpu.c: Regenerate.
	* cpu.h: Regenerate.
	* cpuall.h: Regenerate.
	* cpux.c: Regenerate.
	* cpux.h: Regenerate.
	* decode.c: Regenerate.
	* decode.h: Regenerate.
	* decodex.c: Regenerate.
	* decodex.h: Regenerate.
	* model.c: Regenerate.
	* modelx.c: Regenerate.
	* sem-switch.c: Regenerate.
	* sem.c: Regenerate.
	* semx-switch.c: Regenerate.
@
text
@d5 1
a5 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.5.18.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d5 1
a5 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a2565 105
/* clrpsw: clrpsw $uimm8 */

static SEM_PC
SEM_FN_NAME (m32rbf,clrpsw) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_clrpsw.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ANDSI (GET_H_CR (((UINT) 0)), ORSI (INVBI (FLD (f_uimm8)), 65280));
    SET_H_CR (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* setpsw: setpsw $uimm8 */

static SEM_PC
SEM_FN_NAME (m32rbf,setpsw) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_clrpsw.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = FLD (f_uimm8);
    SET_H_CR (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* bset: bset $uimm3,@@($slo16,$sr) */

static SEM_PC
SEM_FN_NAME (m32rbf,bset) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bset.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    QI opval = ORQI (GETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16))), SLLSI (1, SUBSI (7, FLD (f_uimm3))));
    SETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* bclr: bclr $uimm3,@@($slo16,$sr) */

static SEM_PC
SEM_FN_NAME (m32rbf,bclr) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bset.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    QI opval = ANDQI (GETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16))), INVQI (SLLSI (1, SUBSI (7, FLD (f_uimm3)))));
    SETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* btst: btst $uimm3,$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,btst) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bset.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = ANDQI (SRLSI (* FLD (i_sr), SUBSI (7, FLD (f_uimm3))), 1);
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

  return vpc;
#undef FLD
}

a2673 5
  { M32RBF_INSN_CLRPSW, SEM_FN_NAME (m32rbf,clrpsw) },
  { M32RBF_INSN_SETPSW, SEM_FN_NAME (m32rbf,setpsw) },
  { M32RBF_INSN_BSET, SEM_FN_NAME (m32rbf,bset) },
  { M32RBF_INSN_BCLR, SEM_FN_NAME (m32rbf,bclr) },
  { M32RBF_INSN_BTST, SEM_FN_NAME (m32rbf,btst) },
@


1.5.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d5 1
a5 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
@


1.5.16.2
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d5 1
a5 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a2565 105
/* clrpsw: clrpsw $uimm8 */

static SEM_PC
SEM_FN_NAME (m32rbf,clrpsw) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_clrpsw.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ANDSI (GET_H_CR (((UINT) 0)), ORSI (INVBI (FLD (f_uimm8)), 65280));
    SET_H_CR (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* setpsw: setpsw $uimm8 */

static SEM_PC
SEM_FN_NAME (m32rbf,setpsw) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_clrpsw.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = FLD (f_uimm8);
    SET_H_CR (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* bset: bset $uimm3,@@($slo16,$sr) */

static SEM_PC
SEM_FN_NAME (m32rbf,bset) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bset.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    QI opval = ORQI (GETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16))), SLLSI (1, SUBSI (7, FLD (f_uimm3))));
    SETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* bclr: bclr $uimm3,@@($slo16,$sr) */

static SEM_PC
SEM_FN_NAME (m32rbf,bclr) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bset.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    QI opval = ANDQI (GETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16))), INVQI (SLLSI (1, SUBSI (7, FLD (f_uimm3)))));
    SETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* btst: btst $uimm3,$sr */

static SEM_PC
SEM_FN_NAME (m32rbf,btst) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bset.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = ANDQI (SRLSI (* FLD (i_sr), SUBSI (7, FLD (f_uimm3))), 1);
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

  return vpc;
#undef FLD
}

a2673 5
  { M32RBF_INSN_CLRPSW, SEM_FN_NAME (m32rbf,clrpsw) },
  { M32RBF_INSN_SETPSW, SEM_FN_NAME (m32rbf,setpsw) },
  { M32RBF_INSN_BSET, SEM_FN_NAME (m32rbf,bset) },
  { M32RBF_INSN_BCLR, SEM_FN_NAME (m32rbf,bclr) },
  { M32RBF_INSN_BTST, SEM_FN_NAME (m32rbf,btst) },
@


1.4
log
@2001-03-05  Dave Brolley  <brolley

        arch.c: Regenerate.
        arch.h: Regenerate.
        cpu.c: Regenerate.
        cpu.h: Regenerate.
        cpuall.h: Regenerate.
        cpux.c: Regenerate.
        cpux.h: Regenerate.
        decode.c: Regenerate.
        decode.h: Regenerate.
        decodex.c: Regenerate.
        decodex.h: Regenerate.
        model.c: Regenerate.
        modelx.c: Regenerate.
        sem-switch.c: Regenerate.
        sem.c: Regenerate.
        semx-switch.c: Regenerate.
@
text
@d5 1
a5 1
Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d7 1
a7 1
This file is part of the GNU Simulators.
@


1.3
log
@2000-10-06  Dave Brolley  <brolley@@redhat.com>

	* sem.c: Regenerated.
	* sem-switch.c: Regenerated.
	* semx-switch.c: Regenerated.
@
text
@d5 1
a5 1
Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
d33 1
d35 3
d218 1
a218 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d239 1
a239 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d260 1
a260 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d281 1
a281 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d302 1
a302 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d323 1
a323 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d344 1
a344 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d365 1
a365 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d386 1
a386 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d411 1
a411 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d416 1
a416 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d442 1
a442 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d447 1
a447 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d473 1
a473 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d478 1
a478 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d745 1
a745 1
    TRACE_RESULT (current_cpu, abuf, "gr-14", 'x', opval);
d775 1
a775 1
    TRACE_RESULT (current_cpu, abuf, "gr-14", 'x', opval);
d930 1
a930 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d951 1
a951 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d972 1
a972 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d993 1
a993 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d1016 1
a1016 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1041 1
a1041 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1066 1
a1066 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1091 1
a1091 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1119 1
a1119 1
    TRACE_RESULT (current_cpu, abuf, "gr-14", 'x', opval);
d1170 1
a1170 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1191 1
a1191 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1212 1
a1212 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1233 1
a1233 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1254 1
a1254 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1275 1
a1275 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1296 1
a1296 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1317 1
a1317 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1338 1
a1338 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1359 1
a1359 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1384 1
a1384 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1389 1
a1389 1
    TRACE_RESULT (current_cpu, abuf, "sr", 'x', opval);
d1411 1
a1411 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1432 1
a1432 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1453 1
a1453 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1480 1
a1480 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1586 1
a1586 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1691 1
a1691 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1712 1
a1712 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1733 1
a1733 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1754 1
a1754 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1775 1
a1775 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1838 1
a1838 1
    TRACE_RESULT (current_cpu, abuf, "dcr", 'x', opval);
d1859 1
a1859 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1897 1
a1897 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1986 1
a1986 1
    TRACE_RESULT (current_cpu, abuf, "cr-6", 'x', opval);
d2019 1
a2019 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2040 1
a2040 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2061 1
a2061 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2082 1
a2082 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2103 1
a2103 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2124 1
a2124 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2145 1
a2145 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2166 1
a2166 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2187 1
a2187 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2208 1
a2208 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2363 1
a2363 1
    TRACE_RESULT (current_cpu, abuf, "src2", 'x', opval);
d2393 1
a2393 1
    TRACE_RESULT (current_cpu, abuf, "src2", 'x', opval);
d2415 1
a2415 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2440 1
a2440 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2445 1
a2445 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d2471 1
a2471 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2476 1
a2476 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d2500 1
a2500 1
    TRACE_RESULT (current_cpu, abuf, "cr-14", 'x', opval);
d2505 1
a2505 1
    TRACE_RESULT (current_cpu, abuf, "cr-6", 'x', opval);
@


1.2
log
@2000-08-28  Dave Brolley  <brolley@@redhat.com>

	* Makefile.in: Use of @@true confuses VPATH. Remove it.
	* cpu.h: Regenerated.
	* cpux.h: Regenerated.
	* decode.c: Regenerated.
	* decodex.c: Regenerated.
	* model.c: Regenerated.
	* modelx.c: Regenerated.
	* sem-switch.c: Regenerated.
	* sem.c: Regenerated.
	* semx-switch.c: Regenerated.
@
text
@d182 1
a182 1
#ifdef DEFINE_SWITCH
d187 1
d189 3
@


1.1
log
@Initial revision
@
text
@d35 11
d48 1
a48 1
SEM_PC
d58 3
a60 2
#if WITH_SCACHE
    /* Update the recorded pc in the cpu state struct.  */
d62 5
a66 4
#endif
    sim_engine_invalid_insn (current_cpu, pc);
    sim_io_error (CPU_STATE (current_cpu), "invalid insn not handled\n");
    /* NOTREACHED */
d75 1
a75 1
SEM_PC
d96 1
a96 1
SEM_PC
d117 1
a117 1
SEM_PC
d130 1
a130 1
			       pbb_br_npc_ptr, pbb_br_npc);
d135 1
a135 1
			       CPU_PBB_BR_NPC_PTR (current_cpu),
d147 1
a147 1
SEM_PC
d171 1
a171 1
SEM_PC
d198 1
a198 1
SEM_PC
d201 1
a201 1
#define FLD(f) abuf->fields.fmt_add.f
d219 1
a219 1
SEM_PC
d222 1
a222 1
#define FLD(f) abuf->fields.fmt_add3.f
d240 1
a240 1
SEM_PC
d243 1
a243 1
#define FLD(f) abuf->fields.fmt_add.f
d261 1
a261 1
SEM_PC
d264 1
a264 1
#define FLD(f) abuf->fields.fmt_and3.f
d282 1
a282 1
SEM_PC
d285 1
a285 1
#define FLD(f) abuf->fields.fmt_add.f
d303 1
a303 1
SEM_PC
d306 1
a306 1
#define FLD(f) abuf->fields.fmt_or3.f
d324 1
a324 1
SEM_PC
d327 1
a327 1
#define FLD(f) abuf->fields.fmt_add.f
d345 1
a345 1
SEM_PC
d348 1
a348 1
#define FLD(f) abuf->fields.fmt_and3.f
d366 1
a366 1
SEM_PC
d369 1
a369 1
#define FLD(f) abuf->fields.fmt_addi.f
d387 1
a387 1
SEM_PC
d390 1
a390 1
#define FLD(f) abuf->fields.fmt_addv.f
d396 2
a397 2
do {
  BI temp1;SI temp0;
d410 1
a410 1
} while (0);
d418 1
a418 1
SEM_PC
d421 1
a421 1
#define FLD(f) abuf->fields.fmt_addv3.f
d427 2
a428 2
do {
  BI temp1;SI temp0;
d441 1
a441 1
} while (0);
d449 1
a449 1
SEM_PC
d452 1
a452 1
#define FLD(f) abuf->fields.fmt_addx.f
d458 2
a459 2
do {
  BI temp1;SI temp0;
d472 1
a472 1
} while (0);
d480 1
a480 1
SEM_PC
d483 1
a483 1
#define FLD(f) abuf->fields.cti.fields.fmt_bc8.f
d493 1
a493 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc, SEM_BRANCH_ADDR_CACHE (sem_arg));
d507 1
a507 1
SEM_PC
d510 1
a510 1
#define FLD(f) abuf->fields.cti.fields.fmt_bc24.f
d520 1
a520 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc, SEM_BRANCH_ADDR_CACHE (sem_arg));
d534 1
a534 1
SEM_PC
d537 1
a537 1
#define FLD(f) abuf->fields.cti.fields.fmt_beq.f
d547 1
a547 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc, SEM_BRANCH_ADDR_CACHE (sem_arg));
d561 1
a561 1
SEM_PC
d564 1
a564 1
#define FLD(f) abuf->fields.cti.fields.fmt_beqz.f
d574 1
a574 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc, SEM_BRANCH_ADDR_CACHE (sem_arg));
d588 1
a588 1
SEM_PC
d591 1
a591 1
#define FLD(f) abuf->fields.cti.fields.fmt_beqz.f
d601 1
a601 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc, SEM_BRANCH_ADDR_CACHE (sem_arg));
d615 1
a615 1
SEM_PC
d618 1
a618 1
#define FLD(f) abuf->fields.cti.fields.fmt_beqz.f
d628 1
a628 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc, SEM_BRANCH_ADDR_CACHE (sem_arg));
d642 1
a642 1
SEM_PC
d645 1
a645 1
#define FLD(f) abuf->fields.cti.fields.fmt_beqz.f
d655 1
a655 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc, SEM_BRANCH_ADDR_CACHE (sem_arg));
d669 1
a669 1
SEM_PC
d672 1
a672 1
#define FLD(f) abuf->fields.cti.fields.fmt_beqz.f
d682 1
a682 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc, SEM_BRANCH_ADDR_CACHE (sem_arg));
d696 1
a696 1
SEM_PC
d699 1
a699 1
#define FLD(f) abuf->fields.cti.fields.fmt_beqz.f
d709 1
a709 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc, SEM_BRANCH_ADDR_CACHE (sem_arg));
d723 1
a723 1
SEM_PC
d726 1
a726 1
#define FLD(f) abuf->fields.cti.fields.fmt_bl8.f
d733 1
a733 1
do {
d741 1
a741 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc, SEM_BRANCH_ADDR_CACHE (sem_arg));
d744 1
a744 1
} while (0);
d753 1
a753 1
SEM_PC
d756 1
a756 1
#define FLD(f) abuf->fields.cti.fields.fmt_bl24.f
d763 1
a763 1
do {
d771 1
a771 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc, SEM_BRANCH_ADDR_CACHE (sem_arg));
d774 1
a774 1
} while (0);
d783 1
a783 1
SEM_PC
d786 1
a786 1
#define FLD(f) abuf->fields.cti.fields.fmt_bc8.f
d796 1
a796 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc, SEM_BRANCH_ADDR_CACHE (sem_arg));
d810 1
a810 1
SEM_PC
d813 1
a813 1
#define FLD(f) abuf->fields.cti.fields.fmt_bc24.f
d823 1
a823 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc, SEM_BRANCH_ADDR_CACHE (sem_arg));
d837 1
a837 1
SEM_PC
d840 1
a840 1
#define FLD(f) abuf->fields.cti.fields.fmt_beq.f
d850 1
a850 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc, SEM_BRANCH_ADDR_CACHE (sem_arg));
d864 1
a864 1
SEM_PC
d867 1
a867 1
#define FLD(f) abuf->fields.cti.fields.fmt_bra8.f
d876 1
a876 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc, SEM_BRANCH_ADDR_CACHE (sem_arg));
d887 1
a887 1
SEM_PC
d890 1
a890 1
#define FLD(f) abuf->fields.cti.fields.fmt_bra24.f
d899 1
a899 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc, SEM_BRANCH_ADDR_CACHE (sem_arg));
d910 1
a910 1
SEM_PC
d913 1
a913 1
#define FLD(f) abuf->fields.fmt_cmp.f
d931 1
a931 1
SEM_PC
d934 1
a934 1
#define FLD(f) abuf->fields.fmt_cmpi.f
d952 1
a952 1
SEM_PC
d955 1
a955 1
#define FLD(f) abuf->fields.fmt_cmp.f
d973 1
a973 1
SEM_PC
d976 1
a976 1
#define FLD(f) abuf->fields.fmt_cmpi.f
d994 1
a994 1
SEM_PC
d997 1
a997 1
#define FLD(f) abuf->fields.fmt_div.f
d1019 1
a1019 1
SEM_PC
d1022 1
a1022 1
#define FLD(f) abuf->fields.fmt_div.f
d1044 1
a1044 1
SEM_PC
d1047 1
a1047 1
#define FLD(f) abuf->fields.fmt_div.f
d1069 1
a1069 1
SEM_PC
d1072 1
a1072 1
#define FLD(f) abuf->fields.fmt_div.f
d1094 1
a1094 1
SEM_PC
d1097 1
a1097 1
#define FLD(f) abuf->fields.cti.fields.fmt_jl.f
d1104 2
a1105 2
do {
  USI temp1;SI temp0;
d1118 1
a1118 1
} while (0);
d1127 1
a1127 1
SEM_PC
d1130 1
a1130 1
#define FLD(f) abuf->fields.cti.fields.fmt_jmp.f
d1150 1
a1150 1
SEM_PC
d1153 1
a1153 1
#define FLD(f) abuf->fields.fmt_ld.f
d1171 1
a1171 1
SEM_PC
d1174 1
a1174 1
#define FLD(f) abuf->fields.fmt_ld_d.f
d1192 1
a1192 1
SEM_PC
d1195 1
a1195 1
#define FLD(f) abuf->fields.fmt_ldb.f
d1213 1
a1213 1
SEM_PC
d1216 1
a1216 1
#define FLD(f) abuf->fields.fmt_ldb_d.f
d1234 1
a1234 1
SEM_PC
d1237 1
a1237 1
#define FLD(f) abuf->fields.fmt_ldh.f
d1255 1
a1255 1
SEM_PC
d1258 1
a1258 1
#define FLD(f) abuf->fields.fmt_ldh_d.f
d1276 1
a1276 1
SEM_PC
d1279 1
a1279 1
#define FLD(f) abuf->fields.fmt_ldb.f
d1297 1
a1297 1
SEM_PC
d1300 1
a1300 1
#define FLD(f) abuf->fields.fmt_ldb_d.f
d1318 1
a1318 1
SEM_PC
d1321 1
a1321 1
#define FLD(f) abuf->fields.fmt_ldh.f
d1339 1
a1339 1
SEM_PC
d1342 1
a1342 1
#define FLD(f) abuf->fields.fmt_ldh_d.f
d1360 1
a1360 1
SEM_PC
d1363 1
a1363 1
#define FLD(f) abuf->fields.fmt_ld_plus.f
d1369 2
a1370 2
do {
  SI temp1;SI temp0;
d1383 1
a1383 1
} while (0);
d1391 1
a1391 1
SEM_PC
d1394 1
a1394 1
#define FLD(f) abuf->fields.fmt_ld24.f
d1412 1
a1412 1
SEM_PC
d1415 1
a1415 1
#define FLD(f) abuf->fields.fmt_ldi8.f
d1433 1
a1433 1
SEM_PC
d1436 1
a1436 1
#define FLD(f) abuf->fields.fmt_ldi16.f
d1454 1
a1454 1
SEM_PC
d1457 1
a1457 1
#define FLD(f) abuf->fields.fmt_lock.f
d1463 1
a1463 1
do {
d1467 1
a1467 1
    TRACE_RESULT (current_cpu, abuf, "lock-0", 'x', opval);
d1474 1
a1474 1
} while (0);
d1482 1
a1482 1
SEM_PC
d1485 1
a1485 1
#define FLD(f) abuf->fields.fmt_machi.f
d1503 1
a1503 1
SEM_PC
d1506 1
a1506 1
#define FLD(f) abuf->fields.fmt_machi.f
d1524 1
a1524 1
SEM_PC
d1527 1
a1527 1
#define FLD(f) abuf->fields.fmt_machi.f
d1545 1
a1545 1
SEM_PC
d1548 1
a1548 1
#define FLD(f) abuf->fields.fmt_machi.f
d1566 1
a1566 1
SEM_PC
d1569 1
a1569 1
#define FLD(f) abuf->fields.fmt_add.f
d1587 1
a1587 1
SEM_PC
d1590 1
a1590 1
#define FLD(f) abuf->fields.fmt_mulhi.f
d1608 1
a1608 1
SEM_PC
d1611 1
a1611 1
#define FLD(f) abuf->fields.fmt_mulhi.f
d1629 1
a1629 1
SEM_PC
d1632 1
a1632 1
#define FLD(f) abuf->fields.fmt_mulhi.f
d1650 1
a1650 1
SEM_PC
d1653 1
a1653 1
#define FLD(f) abuf->fields.fmt_mulhi.f
d1671 1
a1671 1
SEM_PC
d1674 1
a1674 1
#define FLD(f) abuf->fields.fmt_mv.f
d1692 1
a1692 1
SEM_PC
d1695 1
a1695 1
#define FLD(f) abuf->fields.fmt_mvfachi.f
d1713 1
a1713 1
SEM_PC
d1716 1
a1716 1
#define FLD(f) abuf->fields.fmt_mvfachi.f
d1734 1
a1734 1
SEM_PC
d1737 1
a1737 1
#define FLD(f) abuf->fields.fmt_mvfachi.f
d1755 1
a1755 1
SEM_PC
d1758 1
a1758 1
#define FLD(f) abuf->fields.fmt_mvfc.f
d1776 1
a1776 1
SEM_PC
d1779 1
a1779 1
#define FLD(f) abuf->fields.fmt_mvtachi.f
d1797 1
a1797 1
SEM_PC
d1800 1
a1800 1
#define FLD(f) abuf->fields.fmt_mvtachi.f
d1818 1
a1818 1
SEM_PC
d1821 1
a1821 1
#define FLD(f) abuf->fields.fmt_mvtc.f
d1839 1
a1839 1
SEM_PC
d1842 1
a1842 1
#define FLD(f) abuf->fields.fmt_mv.f
d1860 1
a1860 1
SEM_PC
d1863 1
a1863 1
#define FLD(f) abuf->fields.fmt_nop.f
d1877 1
a1877 1
SEM_PC
d1880 1
a1880 1
#define FLD(f) abuf->fields.fmt_mv.f
d1898 1
a1898 1
SEM_PC
d1901 1
a1901 1
#define FLD(f) abuf->fields.fmt_rac.f
d1907 1
a1907 1
do {
d1916 1
a1916 1
} while (0);
d1924 1
a1924 1
SEM_PC
d1927 1
a1927 1
#define FLD(f) abuf->fields.fmt_rac.f
d1933 1
a1933 1
do {
d1951 1
a1951 1
} while (0);
d1959 1
a1959 1
SEM_PC
d1962 1
a1962 1
#define FLD(f) abuf->fields.cti.fields.fmt_rte.f
d1969 1
a1969 1
do {
d1983 1
a1983 1
    TRACE_RESULT (current_cpu, abuf, "psw-0", 'x', opval);
d1988 1
a1988 1
    TRACE_RESULT (current_cpu, abuf, "bpsw-0", 'x', opval);
d1990 1
a1990 1
} while (0);
d1999 1
a1999 1
SEM_PC
d2002 1
a2002 1
#define FLD(f) abuf->fields.fmt_seth.f
d2020 1
a2020 1
SEM_PC
d2023 1
a2023 1
#define FLD(f) abuf->fields.fmt_add.f
d2041 1
a2041 1
SEM_PC
d2044 1
a2044 1
#define FLD(f) abuf->fields.fmt_sll3.f
d2062 1
a2062 1
SEM_PC
d2065 1
a2065 1
#define FLD(f) abuf->fields.fmt_slli.f
d2083 1
a2083 1
SEM_PC
d2086 1
a2086 1
#define FLD(f) abuf->fields.fmt_add.f
d2104 1
a2104 1
SEM_PC
d2107 1
a2107 1
#define FLD(f) abuf->fields.fmt_sll3.f
d2125 1
a2125 1
SEM_PC
d2128 1
a2128 1
#define FLD(f) abuf->fields.fmt_slli.f
d2146 1
a2146 1
SEM_PC
d2149 1
a2149 1
#define FLD(f) abuf->fields.fmt_add.f
d2167 1
a2167 1
SEM_PC
d2170 1
a2170 1
#define FLD(f) abuf->fields.fmt_sll3.f
d2188 1
a2188 1
SEM_PC
d2191 1
a2191 1
#define FLD(f) abuf->fields.fmt_slli.f
d2209 1
a2209 1
SEM_PC
d2212 1
a2212 1
#define FLD(f) abuf->fields.fmt_st.f
d2230 1
a2230 1
SEM_PC
d2233 1
a2233 1
#define FLD(f) abuf->fields.fmt_st_d.f
d2251 1
a2251 1
SEM_PC
d2254 1
a2254 1
#define FLD(f) abuf->fields.fmt_stb.f
d2272 1
a2272 1
SEM_PC
d2275 1
a2275 1
#define FLD(f) abuf->fields.fmt_stb_d.f
d2293 1
a2293 1
SEM_PC
d2296 1
a2296 1
#define FLD(f) abuf->fields.fmt_sth.f
d2314 1
a2314 1
SEM_PC
d2317 1
a2317 1
#define FLD(f) abuf->fields.fmt_sth_d.f
d2335 1
a2335 1
SEM_PC
d2338 1
a2338 1
#define FLD(f) abuf->fields.fmt_st_plus.f
d2344 1
a2344 1
do {
d2357 1
a2357 1
} while (0);
d2365 1
a2365 1
SEM_PC
d2368 1
a2368 1
#define FLD(f) abuf->fields.fmt_st_plus.f
d2374 1
a2374 1
do {
d2387 1
a2387 1
} while (0);
d2395 1
a2395 1
SEM_PC
d2398 1
a2398 1
#define FLD(f) abuf->fields.fmt_add.f
d2416 1
a2416 1
SEM_PC
d2419 1
a2419 1
#define FLD(f) abuf->fields.fmt_addv.f
d2425 2
a2426 2
do {
  BI temp1;SI temp0;
d2439 1
a2439 1
} while (0);
d2447 1
a2447 1
SEM_PC
d2450 1
a2450 1
#define FLD(f) abuf->fields.fmt_addx.f
d2456 2
a2457 2
do {
  BI temp1;SI temp0;
d2470 1
a2470 1
} while (0);
d2478 1
a2478 1
SEM_PC
d2481 1
a2481 1
#define FLD(f) abuf->fields.cti.fields.fmt_trap.f
d2488 1
a2488 1
do {
d2502 1
a2502 1
    TRACE_RESULT (current_cpu, abuf, "bbpsw-0", 'x', opval);
d2507 1
a2507 1
    TRACE_RESULT (current_cpu, abuf, "bpsw-0", 'x', opval);
d2512 1
a2512 1
    TRACE_RESULT (current_cpu, abuf, "psw-0", 'x', opval);
d2519 1
a2519 1
} while (0);
d2528 1
a2528 1
SEM_PC
d2531 1
a2531 1
#define FLD(f) abuf->fields.fmt_unlock.f
d2537 1
a2537 1
do {
d2549 1
a2549 1
    TRACE_RESULT (current_cpu, abuf, "lock-0", 'x', opval);
d2551 1
a2551 1
} while (0);
d2556 139
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d383 2
a384 2
{
  SI temp0;BI temp1;
d397 1
a397 1
}
d414 2
a415 2
{
  SI temp0;BI temp1;
d428 1
a428 1
}
d445 2
a446 2
{
  SI temp0;BI temp1;
d459 1
a459 1
}
d720 1
a720 1
{
d731 1
a731 1
}
d750 1
a750 1
{
d761 1
a761 1
}
d1091 2
a1092 2
{
  SI temp0;USI temp1;
d1105 1
a1105 1
}
d1356 2
a1357 2
{
  SI temp0;SI temp1;
d1370 1
a1370 1
}
d1450 1
a1450 1
{
d1454 1
a1454 1
    TRACE_RESULT (current_cpu, abuf, "lock", 'x', opval);
d1461 1
a1461 1
}
d1894 1
a1894 1
{
d1903 1
a1903 1
}
d1920 1
a1920 1
{
d1938 1
a1938 1
}
d1956 1
a1956 1
{
d1970 1
a1970 1
    TRACE_RESULT (current_cpu, abuf, "psw", 'x', opval);
d1975 1
a1975 1
    TRACE_RESULT (current_cpu, abuf, "bpsw", 'x', opval);
d1977 1
a1977 1
}
d2331 1
a2331 1
{
d2344 1
a2344 1
}
d2361 1
a2361 1
{
d2374 1
a2374 1
}
d2412 2
a2413 2
{
  SI temp0;BI temp1;
d2426 1
a2426 1
}
d2443 2
a2444 2
{
  SI temp0;BI temp1;
d2457 1
a2457 1
}
d2475 1
a2475 1
{
d2489 1
a2489 1
    TRACE_RESULT (current_cpu, abuf, "bbpsw", 'x', opval);
d2494 1
a2494 1
    TRACE_RESULT (current_cpu, abuf, "bpsw", 'x', opval);
d2499 1
a2499 1
    TRACE_RESULT (current_cpu, abuf, "psw", 'x', opval);
d2506 1
a2506 1
}
d2524 1
a2524 1
{
d2536 1
a2536 1
    TRACE_RESULT (current_cpu, abuf, "lock", 'x', opval);
d2538 1
a2538 1
}
@


1.1.1.3
log
@import gdb-1999-08-09 snapshot
@
text
@a34 11
/* This is used so that we can compile two copies of the semantic code,
   one with full feature support and one without that runs fast(er).
   FAST_P, when desired, is defined on the command line, -DFAST_P=1.  */
#if FAST_P
#define SEM_FN_NAME(cpu,fn) XCONCAT3 (cpu,_semf_,fn)
#undef TRACE_RESULT
#define TRACE_RESULT(cpu, abuf, name, type, val)
#else
#define SEM_FN_NAME(cpu,fn) XCONCAT3 (cpu,_sem_,fn)
#endif

d37 1
a37 1
static SEM_PC
d62 1
a62 1
static SEM_PC
d83 1
a83 1
static SEM_PC
d104 1
a104 1
static SEM_PC
d117 1
a117 1
			       pbb_br_type, pbb_br_npc);
d122 1
a122 1
			       CPU_PBB_BR_TYPE (current_cpu),
d134 1
a134 1
static SEM_PC
d158 1
a158 1
static SEM_PC
d185 1
a185 1
static SEM_PC
d188 1
a188 1
#define FLD(f) abuf->fields.sfmt_add.f
d206 1
a206 1
static SEM_PC
d209 1
a209 1
#define FLD(f) abuf->fields.sfmt_add3.f
d227 1
a227 1
static SEM_PC
d230 1
a230 1
#define FLD(f) abuf->fields.sfmt_add.f
d248 1
a248 1
static SEM_PC
d251 1
a251 1
#define FLD(f) abuf->fields.sfmt_and3.f
d269 1
a269 1
static SEM_PC
d272 1
a272 1
#define FLD(f) abuf->fields.sfmt_add.f
d290 1
a290 1
static SEM_PC
d293 1
a293 1
#define FLD(f) abuf->fields.sfmt_and3.f
d311 1
a311 1
static SEM_PC
d314 1
a314 1
#define FLD(f) abuf->fields.sfmt_add.f
d332 1
a332 1
static SEM_PC
d335 1
a335 1
#define FLD(f) abuf->fields.sfmt_and3.f
d353 1
a353 1
static SEM_PC
d356 1
a356 1
#define FLD(f) abuf->fields.sfmt_addi.f
d374 1
a374 1
static SEM_PC
d377 1
a377 1
#define FLD(f) abuf->fields.sfmt_add.f
d405 1
a405 1
static SEM_PC
d408 1
a408 1
#define FLD(f) abuf->fields.sfmt_add3.f
d436 1
a436 1
static SEM_PC
d439 1
a439 1
#define FLD(f) abuf->fields.sfmt_add.f
d467 1
a467 1
static SEM_PC
d470 1
a470 1
#define FLD(f) abuf->fields.sfmt_bl8.f
d480 1
a480 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
d494 1
a494 1
static SEM_PC
d497 1
a497 1
#define FLD(f) abuf->fields.sfmt_bl24.f
d507 1
a507 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
d521 1
a521 1
static SEM_PC
d524 1
a524 1
#define FLD(f) abuf->fields.sfmt_beq.f
d534 1
a534 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
d548 1
a548 1
static SEM_PC
d551 1
a551 1
#define FLD(f) abuf->fields.sfmt_beq.f
d561 1
a561 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
d575 1
a575 1
static SEM_PC
d578 1
a578 1
#define FLD(f) abuf->fields.sfmt_beq.f
d588 1
a588 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
d602 1
a602 1
static SEM_PC
d605 1
a605 1
#define FLD(f) abuf->fields.sfmt_beq.f
d615 1
a615 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
d629 1
a629 1
static SEM_PC
d632 1
a632 1
#define FLD(f) abuf->fields.sfmt_beq.f
d642 1
a642 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
d656 1
a656 1
static SEM_PC
d659 1
a659 1
#define FLD(f) abuf->fields.sfmt_beq.f
d669 1
a669 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
d683 1
a683 1
static SEM_PC
d686 1
a686 1
#define FLD(f) abuf->fields.sfmt_beq.f
d696 1
a696 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
d710 1
a710 1
static SEM_PC
d713 1
a713 1
#define FLD(f) abuf->fields.sfmt_bl8.f
d728 1
a728 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
d740 1
a740 1
static SEM_PC
d743 1
a743 1
#define FLD(f) abuf->fields.sfmt_bl24.f
d758 1
a758 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
d770 1
a770 1
static SEM_PC
d773 1
a773 1
#define FLD(f) abuf->fields.sfmt_bl8.f
d783 1
a783 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
d797 1
a797 1
static SEM_PC
d800 1
a800 1
#define FLD(f) abuf->fields.sfmt_bl24.f
d810 1
a810 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
d824 1
a824 1
static SEM_PC
d827 1
a827 1
#define FLD(f) abuf->fields.sfmt_beq.f
d837 1
a837 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
d851 1
a851 1
static SEM_PC
d854 1
a854 1
#define FLD(f) abuf->fields.sfmt_bl8.f
d863 1
a863 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
d874 1
a874 1
static SEM_PC
d877 1
a877 1
#define FLD(f) abuf->fields.sfmt_bl24.f
d886 1
a886 1
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
d897 1
a897 1
static SEM_PC
d900 1
a900 1
#define FLD(f) abuf->fields.sfmt_st_plus.f
d918 1
a918 1
static SEM_PC
d921 1
a921 1
#define FLD(f) abuf->fields.sfmt_st_d.f
d939 1
a939 1
static SEM_PC
d942 1
a942 1
#define FLD(f) abuf->fields.sfmt_st_plus.f
d960 1
a960 1
static SEM_PC
d963 1
a963 1
#define FLD(f) abuf->fields.sfmt_st_d.f
d981 1
a981 1
static SEM_PC
d984 1
a984 1
#define FLD(f) abuf->fields.sfmt_add.f
d1006 1
a1006 1
static SEM_PC
d1009 1
a1009 1
#define FLD(f) abuf->fields.sfmt_add.f
d1031 1
a1031 1
static SEM_PC
d1034 1
a1034 1
#define FLD(f) abuf->fields.sfmt_add.f
d1056 1
a1056 1
static SEM_PC
d1059 1
a1059 1
#define FLD(f) abuf->fields.sfmt_add.f
d1081 1
a1081 1
static SEM_PC
d1084 1
a1084 1
#define FLD(f) abuf->fields.sfmt_jl.f
d1114 1
a1114 1
static SEM_PC
d1117 1
a1117 1
#define FLD(f) abuf->fields.sfmt_mvtc.f
d1137 1
a1137 1
static SEM_PC
d1140 1
a1140 1
#define FLD(f) abuf->fields.sfmt_ld_plus.f
d1158 1
a1158 1
static SEM_PC
d1161 1
a1161 1
#define FLD(f) abuf->fields.sfmt_add3.f
d1179 1
a1179 1
static SEM_PC
d1182 1
a1182 1
#define FLD(f) abuf->fields.sfmt_ld_plus.f
d1200 1
a1200 1
static SEM_PC
d1203 1
a1203 1
#define FLD(f) abuf->fields.sfmt_add3.f
d1221 1
a1221 1
static SEM_PC
d1224 1
a1224 1
#define FLD(f) abuf->fields.sfmt_ld_plus.f
d1242 1
a1242 1
static SEM_PC
d1245 1
a1245 1
#define FLD(f) abuf->fields.sfmt_add3.f
d1263 1
a1263 1
static SEM_PC
d1266 1
a1266 1
#define FLD(f) abuf->fields.sfmt_ld_plus.f
d1284 1
a1284 1
static SEM_PC
d1287 1
a1287 1
#define FLD(f) abuf->fields.sfmt_add3.f
d1305 1
a1305 1
static SEM_PC
d1308 1
a1308 1
#define FLD(f) abuf->fields.sfmt_ld_plus.f
d1326 1
a1326 1
static SEM_PC
d1329 1
a1329 1
#define FLD(f) abuf->fields.sfmt_add3.f
d1347 1
a1347 1
static SEM_PC
d1350 1
a1350 1
#define FLD(f) abuf->fields.sfmt_ld_plus.f
d1378 1
a1378 1
static SEM_PC
d1381 1
a1381 1
#define FLD(f) abuf->fields.sfmt_ld24.f
d1399 1
a1399 1
static SEM_PC
d1402 1
a1402 1
#define FLD(f) abuf->fields.sfmt_addi.f
d1420 1
a1420 1
static SEM_PC
d1423 1
a1423 1
#define FLD(f) abuf->fields.sfmt_add3.f
d1441 1
a1441 1
static SEM_PC
d1444 1
a1444 1
#define FLD(f) abuf->fields.sfmt_ld_plus.f
d1469 1
a1469 1
static SEM_PC
d1472 1
a1472 1
#define FLD(f) abuf->fields.sfmt_st_plus.f
d1490 1
a1490 1
static SEM_PC
d1493 1
a1493 1
#define FLD(f) abuf->fields.sfmt_st_plus.f
d1511 1
a1511 1
static SEM_PC
d1514 1
a1514 1
#define FLD(f) abuf->fields.sfmt_st_plus.f
d1532 1
a1532 1
static SEM_PC
d1535 1
a1535 1
#define FLD(f) abuf->fields.sfmt_st_plus.f
d1553 1
a1553 1
static SEM_PC
d1556 1
a1556 1
#define FLD(f) abuf->fields.sfmt_add.f
d1574 1
a1574 1
static SEM_PC
d1577 1
a1577 1
#define FLD(f) abuf->fields.sfmt_st_plus.f
d1595 1
a1595 1
static SEM_PC
d1598 1
a1598 1
#define FLD(f) abuf->fields.sfmt_st_plus.f
d1616 1
a1616 1
static SEM_PC
d1619 1
a1619 1
#define FLD(f) abuf->fields.sfmt_st_plus.f
d1637 1
a1637 1
static SEM_PC
d1640 1
a1640 1
#define FLD(f) abuf->fields.sfmt_st_plus.f
d1658 1
a1658 1
static SEM_PC
d1661 1
a1661 1
#define FLD(f) abuf->fields.sfmt_ld_plus.f
d1679 1
a1679 1
static SEM_PC
d1682 1
a1682 1
#define FLD(f) abuf->fields.sfmt_seth.f
d1700 1
a1700 1
static SEM_PC
d1703 1
a1703 1
#define FLD(f) abuf->fields.sfmt_seth.f
d1721 1
a1721 1
static SEM_PC
d1724 1
a1724 1
#define FLD(f) abuf->fields.sfmt_seth.f
d1742 1
a1742 1
static SEM_PC
d1745 1
a1745 1
#define FLD(f) abuf->fields.sfmt_mvfc.f
d1763 1
a1763 1
static SEM_PC
d1766 1
a1766 1
#define FLD(f) abuf->fields.sfmt_st_plus.f
d1784 1
a1784 1
static SEM_PC
d1787 1
a1787 1
#define FLD(f) abuf->fields.sfmt_st_plus.f
d1805 1
a1805 1
static SEM_PC
d1808 1
a1808 1
#define FLD(f) abuf->fields.sfmt_mvtc.f
d1826 1
a1826 1
static SEM_PC
d1829 1
a1829 1
#define FLD(f) abuf->fields.sfmt_ld_plus.f
d1847 1
a1847 1
static SEM_PC
d1850 1
a1850 1
#define FLD(f) abuf->fields.fmt_empty.f
d1864 1
a1864 1
static SEM_PC
d1867 1
a1867 1
#define FLD(f) abuf->fields.sfmt_ld_plus.f
d1885 1
a1885 1
static SEM_PC
d1888 1
a1888 1
#define FLD(f) abuf->fields.fmt_empty.f
d1911 1
a1911 1
static SEM_PC
d1914 1
a1914 1
#define FLD(f) abuf->fields.fmt_empty.f
d1946 1
a1946 1
static SEM_PC
d1949 1
a1949 1
#define FLD(f) abuf->fields.fmt_empty.f
d1986 1
a1986 1
static SEM_PC
d1989 1
a1989 1
#define FLD(f) abuf->fields.sfmt_seth.f
d2007 1
a2007 1
static SEM_PC
d2010 1
a2010 1
#define FLD(f) abuf->fields.sfmt_add.f
d2028 1
a2028 1
static SEM_PC
d2031 1
a2031 1
#define FLD(f) abuf->fields.sfmt_add3.f
d2049 1
a2049 1
static SEM_PC
d2052 1
a2052 1
#define FLD(f) abuf->fields.sfmt_slli.f
d2070 1
a2070 1
static SEM_PC
d2073 1
a2073 1
#define FLD(f) abuf->fields.sfmt_add.f
d2091 1
a2091 1
static SEM_PC
d2094 1
a2094 1
#define FLD(f) abuf->fields.sfmt_add3.f
d2112 1
a2112 1
static SEM_PC
d2115 1
a2115 1
#define FLD(f) abuf->fields.sfmt_slli.f
d2133 1
a2133 1
static SEM_PC
d2136 1
a2136 1
#define FLD(f) abuf->fields.sfmt_add.f
d2154 1
a2154 1
static SEM_PC
d2157 1
a2157 1
#define FLD(f) abuf->fields.sfmt_add3.f
d2175 1
a2175 1
static SEM_PC
d2178 1
a2178 1
#define FLD(f) abuf->fields.sfmt_slli.f
d2196 1
a2196 1
static SEM_PC
d2199 1
a2199 1
#define FLD(f) abuf->fields.sfmt_st_plus.f
d2217 1
a2217 1
static SEM_PC
d2220 1
a2220 1
#define FLD(f) abuf->fields.sfmt_st_d.f
d2238 1
a2238 1
static SEM_PC
d2241 1
a2241 1
#define FLD(f) abuf->fields.sfmt_st_plus.f
d2259 1
a2259 1
static SEM_PC
d2262 1
a2262 1
#define FLD(f) abuf->fields.sfmt_st_d.f
d2280 1
a2280 1
static SEM_PC
d2283 1
a2283 1
#define FLD(f) abuf->fields.sfmt_st_plus.f
d2301 1
a2301 1
static SEM_PC
d2304 1
a2304 1
#define FLD(f) abuf->fields.sfmt_st_d.f
d2322 1
a2322 1
static SEM_PC
d2325 1
a2325 1
#define FLD(f) abuf->fields.sfmt_st_plus.f
d2352 1
a2352 1
static SEM_PC
d2355 1
a2355 1
#define FLD(f) abuf->fields.sfmt_st_plus.f
d2382 1
a2382 1
static SEM_PC
d2385 1
a2385 1
#define FLD(f) abuf->fields.sfmt_add.f
d2403 1
a2403 1
static SEM_PC
d2406 1
a2406 1
#define FLD(f) abuf->fields.sfmt_add.f
d2434 1
a2434 1
static SEM_PC
d2437 1
a2437 1
#define FLD(f) abuf->fields.sfmt_add.f
d2465 1
a2465 1
static SEM_PC
d2468 1
a2468 1
#define FLD(f) abuf->fields.sfmt_trap.f
d2515 1
a2515 1
static SEM_PC
d2518 1
a2518 1
#define FLD(f) abuf->fields.sfmt_st_plus.f
a2542 129
}

/* Table of all semantic fns.  */

static const struct sem_fn_desc sem_fns[] = {
  { M32RBF_INSN_X_INVALID, SEM_FN_NAME (m32rbf,x_invalid) },
  { M32RBF_INSN_X_AFTER, SEM_FN_NAME (m32rbf,x_after) },
  { M32RBF_INSN_X_BEFORE, SEM_FN_NAME (m32rbf,x_before) },
  { M32RBF_INSN_X_CTI_CHAIN, SEM_FN_NAME (m32rbf,x_cti_chain) },
  { M32RBF_INSN_X_CHAIN, SEM_FN_NAME (m32rbf,x_chain) },
  { M32RBF_INSN_X_BEGIN, SEM_FN_NAME (m32rbf,x_begin) },
  { M32RBF_INSN_ADD, SEM_FN_NAME (m32rbf,add) },
  { M32RBF_INSN_ADD3, SEM_FN_NAME (m32rbf,add3) },
  { M32RBF_INSN_AND, SEM_FN_NAME (m32rbf,and) },
  { M32RBF_INSN_AND3, SEM_FN_NAME (m32rbf,and3) },
  { M32RBF_INSN_OR, SEM_FN_NAME (m32rbf,or) },
  { M32RBF_INSN_OR3, SEM_FN_NAME (m32rbf,or3) },
  { M32RBF_INSN_XOR, SEM_FN_NAME (m32rbf,xor) },
  { M32RBF_INSN_XOR3, SEM_FN_NAME (m32rbf,xor3) },
  { M32RBF_INSN_ADDI, SEM_FN_NAME (m32rbf,addi) },
  { M32RBF_INSN_ADDV, SEM_FN_NAME (m32rbf,addv) },
  { M32RBF_INSN_ADDV3, SEM_FN_NAME (m32rbf,addv3) },
  { M32RBF_INSN_ADDX, SEM_FN_NAME (m32rbf,addx) },
  { M32RBF_INSN_BC8, SEM_FN_NAME (m32rbf,bc8) },
  { M32RBF_INSN_BC24, SEM_FN_NAME (m32rbf,bc24) },
  { M32RBF_INSN_BEQ, SEM_FN_NAME (m32rbf,beq) },
  { M32RBF_INSN_BEQZ, SEM_FN_NAME (m32rbf,beqz) },
  { M32RBF_INSN_BGEZ, SEM_FN_NAME (m32rbf,bgez) },
  { M32RBF_INSN_BGTZ, SEM_FN_NAME (m32rbf,bgtz) },
  { M32RBF_INSN_BLEZ, SEM_FN_NAME (m32rbf,blez) },
  { M32RBF_INSN_BLTZ, SEM_FN_NAME (m32rbf,bltz) },
  { M32RBF_INSN_BNEZ, SEM_FN_NAME (m32rbf,bnez) },
  { M32RBF_INSN_BL8, SEM_FN_NAME (m32rbf,bl8) },
  { M32RBF_INSN_BL24, SEM_FN_NAME (m32rbf,bl24) },
  { M32RBF_INSN_BNC8, SEM_FN_NAME (m32rbf,bnc8) },
  { M32RBF_INSN_BNC24, SEM_FN_NAME (m32rbf,bnc24) },
  { M32RBF_INSN_BNE, SEM_FN_NAME (m32rbf,bne) },
  { M32RBF_INSN_BRA8, SEM_FN_NAME (m32rbf,bra8) },
  { M32RBF_INSN_BRA24, SEM_FN_NAME (m32rbf,bra24) },
  { M32RBF_INSN_CMP, SEM_FN_NAME (m32rbf,cmp) },
  { M32RBF_INSN_CMPI, SEM_FN_NAME (m32rbf,cmpi) },
  { M32RBF_INSN_CMPU, SEM_FN_NAME (m32rbf,cmpu) },
  { M32RBF_INSN_CMPUI, SEM_FN_NAME (m32rbf,cmpui) },
  { M32RBF_INSN_DIV, SEM_FN_NAME (m32rbf,div) },
  { M32RBF_INSN_DIVU, SEM_FN_NAME (m32rbf,divu) },
  { M32RBF_INSN_REM, SEM_FN_NAME (m32rbf,rem) },
  { M32RBF_INSN_REMU, SEM_FN_NAME (m32rbf,remu) },
  { M32RBF_INSN_JL, SEM_FN_NAME (m32rbf,jl) },
  { M32RBF_INSN_JMP, SEM_FN_NAME (m32rbf,jmp) },
  { M32RBF_INSN_LD, SEM_FN_NAME (m32rbf,ld) },
  { M32RBF_INSN_LD_D, SEM_FN_NAME (m32rbf,ld_d) },
  { M32RBF_INSN_LDB, SEM_FN_NAME (m32rbf,ldb) },
  { M32RBF_INSN_LDB_D, SEM_FN_NAME (m32rbf,ldb_d) },
  { M32RBF_INSN_LDH, SEM_FN_NAME (m32rbf,ldh) },
  { M32RBF_INSN_LDH_D, SEM_FN_NAME (m32rbf,ldh_d) },
  { M32RBF_INSN_LDUB, SEM_FN_NAME (m32rbf,ldub) },
  { M32RBF_INSN_LDUB_D, SEM_FN_NAME (m32rbf,ldub_d) },
  { M32RBF_INSN_LDUH, SEM_FN_NAME (m32rbf,lduh) },
  { M32RBF_INSN_LDUH_D, SEM_FN_NAME (m32rbf,lduh_d) },
  { M32RBF_INSN_LD_PLUS, SEM_FN_NAME (m32rbf,ld_plus) },
  { M32RBF_INSN_LD24, SEM_FN_NAME (m32rbf,ld24) },
  { M32RBF_INSN_LDI8, SEM_FN_NAME (m32rbf,ldi8) },
  { M32RBF_INSN_LDI16, SEM_FN_NAME (m32rbf,ldi16) },
  { M32RBF_INSN_LOCK, SEM_FN_NAME (m32rbf,lock) },
  { M32RBF_INSN_MACHI, SEM_FN_NAME (m32rbf,machi) },
  { M32RBF_INSN_MACLO, SEM_FN_NAME (m32rbf,maclo) },
  { M32RBF_INSN_MACWHI, SEM_FN_NAME (m32rbf,macwhi) },
  { M32RBF_INSN_MACWLO, SEM_FN_NAME (m32rbf,macwlo) },
  { M32RBF_INSN_MUL, SEM_FN_NAME (m32rbf,mul) },
  { M32RBF_INSN_MULHI, SEM_FN_NAME (m32rbf,mulhi) },
  { M32RBF_INSN_MULLO, SEM_FN_NAME (m32rbf,mullo) },
  { M32RBF_INSN_MULWHI, SEM_FN_NAME (m32rbf,mulwhi) },
  { M32RBF_INSN_MULWLO, SEM_FN_NAME (m32rbf,mulwlo) },
  { M32RBF_INSN_MV, SEM_FN_NAME (m32rbf,mv) },
  { M32RBF_INSN_MVFACHI, SEM_FN_NAME (m32rbf,mvfachi) },
  { M32RBF_INSN_MVFACLO, SEM_FN_NAME (m32rbf,mvfaclo) },
  { M32RBF_INSN_MVFACMI, SEM_FN_NAME (m32rbf,mvfacmi) },
  { M32RBF_INSN_MVFC, SEM_FN_NAME (m32rbf,mvfc) },
  { M32RBF_INSN_MVTACHI, SEM_FN_NAME (m32rbf,mvtachi) },
  { M32RBF_INSN_MVTACLO, SEM_FN_NAME (m32rbf,mvtaclo) },
  { M32RBF_INSN_MVTC, SEM_FN_NAME (m32rbf,mvtc) },
  { M32RBF_INSN_NEG, SEM_FN_NAME (m32rbf,neg) },
  { M32RBF_INSN_NOP, SEM_FN_NAME (m32rbf,nop) },
  { M32RBF_INSN_NOT, SEM_FN_NAME (m32rbf,not) },
  { M32RBF_INSN_RAC, SEM_FN_NAME (m32rbf,rac) },
  { M32RBF_INSN_RACH, SEM_FN_NAME (m32rbf,rach) },
  { M32RBF_INSN_RTE, SEM_FN_NAME (m32rbf,rte) },
  { M32RBF_INSN_SETH, SEM_FN_NAME (m32rbf,seth) },
  { M32RBF_INSN_SLL, SEM_FN_NAME (m32rbf,sll) },
  { M32RBF_INSN_SLL3, SEM_FN_NAME (m32rbf,sll3) },
  { M32RBF_INSN_SLLI, SEM_FN_NAME (m32rbf,slli) },
  { M32RBF_INSN_SRA, SEM_FN_NAME (m32rbf,sra) },
  { M32RBF_INSN_SRA3, SEM_FN_NAME (m32rbf,sra3) },
  { M32RBF_INSN_SRAI, SEM_FN_NAME (m32rbf,srai) },
  { M32RBF_INSN_SRL, SEM_FN_NAME (m32rbf,srl) },
  { M32RBF_INSN_SRL3, SEM_FN_NAME (m32rbf,srl3) },
  { M32RBF_INSN_SRLI, SEM_FN_NAME (m32rbf,srli) },
  { M32RBF_INSN_ST, SEM_FN_NAME (m32rbf,st) },
  { M32RBF_INSN_ST_D, SEM_FN_NAME (m32rbf,st_d) },
  { M32RBF_INSN_STB, SEM_FN_NAME (m32rbf,stb) },
  { M32RBF_INSN_STB_D, SEM_FN_NAME (m32rbf,stb_d) },
  { M32RBF_INSN_STH, SEM_FN_NAME (m32rbf,sth) },
  { M32RBF_INSN_STH_D, SEM_FN_NAME (m32rbf,sth_d) },
  { M32RBF_INSN_ST_PLUS, SEM_FN_NAME (m32rbf,st_plus) },
  { M32RBF_INSN_ST_MINUS, SEM_FN_NAME (m32rbf,st_minus) },
  { M32RBF_INSN_SUB, SEM_FN_NAME (m32rbf,sub) },
  { M32RBF_INSN_SUBV, SEM_FN_NAME (m32rbf,subv) },
  { M32RBF_INSN_SUBX, SEM_FN_NAME (m32rbf,subx) },
  { M32RBF_INSN_TRAP, SEM_FN_NAME (m32rbf,trap) },
  { M32RBF_INSN_UNLOCK, SEM_FN_NAME (m32rbf,unlock) },
  { 0, 0 }
};

/* Add the semantic fns to IDESC_TABLE.  */

void
SEM_FN_NAME (m32rbf,init_idesc_table) (SIM_CPU *current_cpu)
{
  IDESC *idesc_table = CPU_IDESC (current_cpu);
  const struct sem_fn_desc *sf;

  for (sf = &sem_fns[0]; sf->fn != 0; ++sf)
    {
#if FAST_P
      idesc_table[sf->index].sem_fast = sf->fn;
#else
      idesc_table[sf->index].sem_full = sf->fn;
#endif
    }
@


1.1.1.4
log
@import gdb-1999-08-30 snapshot
@
text
@a2673 1
  int mach_num = MACH_NUM (CPU_MACH (current_cpu));
a2676 1
      int valid_p = CGEN_INSN_MACH_HAS_P (idesc_table[sf->index].idata, mach_num);
d2678 1
a2678 4
      if (valid_p)
	idesc_table[sf->index].sem_fast = sf->fn;
      else
	idesc_table[sf->index].sem_fast = SEM_FN_NAME (m32rbf,x_invalid);
d2680 1
a2680 4
      if (valid_p)
	idesc_table[sf->index].sem_full = sf->fn;
      else
	idesc_table[sf->index].sem_full = SEM_FN_NAME (m32rbf,x_invalid);
@


1.1.1.5
log
@import gdb-1999-10-04 snapshot
@
text
@d58 2
a59 3
    /* Update the recorded pc in the cpu state struct.
       Only necessary for WITH_SCACHE case, but to avoid the
       conditional compilation ....  */
d61 4
a64 5
    /* Virtual insns have zero size.  Overwrite vpc with address of next insn
       using the default-insn-bitsize spec.  When executing insns in parallel
       we may want to queue the fault and continue execution.  */
    vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
    vpc = sim_engine_invalid_insn (current_cpu, pc, vpc);
d2678 1
a2678 3
      const CGEN_INSN *insn = idesc_table[sf->index].idata;
      int valid_p = (CGEN_INSN_VIRTUAL_P (insn)
		     || CGEN_INSN_MACH_HAS_P (insn, mach_num));
@


