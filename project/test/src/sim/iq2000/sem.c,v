head	1.8;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.8
	gdb_7_6-2013-04-26-release:1.8
	gdb_7_6-branch:1.8.0.2
	gdb_7_6-2013-03-12-branchpoint:1.8
	gdb_7_5_1-2012-11-29-release:1.6
	gdb_7_5-2012-08-17-release:1.6
	gdb_7_5-branch:1.6.0.2
	gdb_7_5-2012-07-18-branchpoint:1.6
	gdb_7_4_1-2012-04-26-release:1.5.8.1
	gdb_7_4-2012-01-24-release:1.5.8.1
	gdb_7_4-branch:1.5.0.8
	gdb_7_4-2011-12-13-branchpoint:1.5
	gdb_7_3_1-2011-09-04-release:1.5
	gdb_7_3-2011-07-26-release:1.5
	gdb_7_3-branch:1.5.0.6
	gdb_7_3-2011-04-01-branchpoint:1.5
	gdb_7_2-2010-09-02-release:1.5
	gdb_7_2-branch:1.5.0.4
	gdb_7_2-2010-07-07-branchpoint:1.5
	gdb_7_1-2010-03-18-release:1.5
	gdb_7_1-branch:1.5.0.2
	gdb_7_1-2010-02-18-branchpoint:1.5
	gdb_7_0_1-2009-12-22-release:1.2
	gdb_7_0-2009-10-06-release:1.2
	gdb_7_0-branch:1.2.0.22
	gdb_7_0-2009-09-16-branchpoint:1.2
	arc-sim-20090309:1.2
	msnyder-checkpoint-072509-branch:1.2.0.20
	msnyder-checkpoint-072509-branchpoint:1.2
	arc-insight_6_8-branch:1.2.0.18
	arc-insight_6_8-branchpoint:1.2
	insight_6_8-branch:1.2.0.16
	insight_6_8-branchpoint:1.2
	reverse-20081226-branch:1.2.0.14
	reverse-20081226-branchpoint:1.2
	multiprocess-20081120-branch:1.2.0.12
	multiprocess-20081120-branchpoint:1.2
	reverse-20080930-branch:1.2.0.10
	reverse-20080930-branchpoint:1.2
	reverse-20080717-branch:1.2.0.8
	reverse-20080717-branchpoint:1.2
	msnyder-reverse-20080609-branch:1.2.0.6
	msnyder-reverse-20080609-branchpoint:1.2
	drow-reverse-20070409-branch:1.1.0.32
	drow-reverse-20070409-branchpoint:1.1
	gdb_6_8-2008-03-27-release:1.2
	gdb_6_8-branch:1.2.0.4
	gdb_6_8-2008-02-26-branchpoint:1.2
	gdb_6_7_1-2007-10-29-release:1.2
	gdb_6_7-2007-10-10-release:1.2
	gdb_6_7-branch:1.2.0.2
	gdb_6_7-2007-09-07-branchpoint:1.2
	insight_6_6-20070208-release:1.1
	gdb_6_6-2006-12-18-release:1.1
	gdb_6_6-branch:1.1.0.30
	gdb_6_6-2006-11-15-branchpoint:1.1
	insight_6_5-20061003-release:1.1
	gdb-csl-symbian-6_4_50_20060226-12:1.1
	gdb-csl-sourcerygxx-3_4_4-25:1.1
	nickrob-async-20060828-mergepoint:1.1
	gdb-csl-symbian-6_4_50_20060226-11:1.1
	gdb-csl-sourcerygxx-4_1-17:1.1
	gdb-csl-20060226-branch-local-2:1.1
	gdb-csl-sourcerygxx-4_1-14:1.1
	gdb-csl-sourcerygxx-4_1-13:1.1
	gdb-csl-sourcerygxx-4_1-12:1.1
	gdb-csl-sourcerygxx-3_4_4-21:1.1
	gdb_6_5-20060621-release:1.1
	gdb-csl-sourcerygxx-4_1-9:1.1
	gdb-csl-sourcerygxx-4_1-8:1.1
	gdb-csl-sourcerygxx-4_1-7:1.1
	gdb-csl-arm-2006q1-6:1.1
	gdb-csl-sourcerygxx-4_1-6:1.1
	gdb-csl-symbian-6_4_50_20060226-10:1.1
	gdb-csl-symbian-6_4_50_20060226-9:1.1
	gdb-csl-symbian-6_4_50_20060226-8:1.1
	gdb-csl-coldfire-4_1-11:1.1
	gdb-csl-sourcerygxx-3_4_4-19:1.1
	gdb-csl-coldfire-4_1-10:1.1
	gdb_6_5-branch:1.1.0.28
	gdb_6_5-2006-05-14-branchpoint:1.1
	gdb-csl-sourcerygxx-4_1-5:1.1
	nickrob-async-20060513-branch:1.1.0.26
	nickrob-async-20060513-branchpoint:1.1
	gdb-csl-sourcerygxx-4_1-4:1.1
	msnyder-reverse-20060502-branch:1.1.0.24
	msnyder-reverse-20060502-branchpoint:1.1
	gdb-csl-morpho-4_1-4:1.1
	gdb-csl-sourcerygxx-3_4_4-17:1.1
	readline_5_1-import-branch:1.1.0.22
	readline_5_1-import-branchpoint:1.1
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.1
	gdb-csl-symbian-20060226-branch:1.1.0.20
	gdb-csl-symbian-20060226-branchpoint:1.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.1
	msnyder-reverse-20060331-branch:1.1.0.18
	msnyder-reverse-20060331-branchpoint:1.1
	gdb-csl-available-20060303-branch:1.1.0.16
	gdb-csl-available-20060303-branchpoint:1.1
	gdb-csl-20060226-branch:1.1.0.14
	gdb-csl-20060226-branchpoint:1.1
	gdb_6_4-20051202-release:1.1
	msnyder-fork-checkpoint-branch:1.1.0.12
	msnyder-fork-checkpoint-branchpoint:1.1
	gdb-csl-gxxpro-6_3-branch:1.1.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.1
	gdb_6_4-branch:1.1.0.8
	gdb_6_4-2005-11-01-branchpoint:1.1
	gdb-csl-arm-20051020-branch:1.1.0.6
	gdb-csl-arm-20051020-branchpoint:1.1
	msnyder-tracepoint-checkpoint-branch:1.1.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.1
	gdb-csl-arm-20050325-2005-q1b:1.1
	gdb-csl-arm-20050325-2005-q1a:1.1
	csl-arm-20050325-branch:1.1.0.2
	csl-arm-20050325-branchpoint:1.1;
locks; strict;
comment	@ * @;


1.8
date	2013.01.01.06.41.37;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2012.12.19.07.18.18;	author brobecke;	state Exp;
branches;
next	1.6;

1.6
date	2012.01.04.08.28.11;	author brobecke;	state Exp;
branches;
next	1.5;

1.5
date	2010.02.12.02.44.25;	author devans;	state Exp;
branches
	1.5.8.1;
next	1.4;

1.4
date	2010.01.02.19.09.20;	author devans;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.04.05.16.33;	author devans;	state Exp;
branches;
next	1.2;

1.2
date	2007.08.24.14.28.36;	author brobecke;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.08.08.55.34;	author corinna;	state Exp;
branches;
next	;

1.5.8.1
date	2012.01.06.04.54.50;	author brobecke;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* Simulator instruction semantics for iq2000bf.

THIS FILE IS MACHINE GENERATED WITH CGEN.

Copyright 1996-2013 Free Software Foundation, Inc.

This file is part of the GNU simulators.

   This file is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License along
   with this program; if not, see <http://www.gnu.org/licenses/>.

*/

#define WANT_CPU iq2000bf
#define WANT_CPU_IQ2000BF

#include "sim-main.h"
#include "cgen-mem.h"
#include "cgen-ops.h"

#undef GET_ATTR
#define GET_ATTR(cpu, num, attr) CGEN_ATTR_VALUE (NULL, abuf->idesc->attrs, CGEN_INSN_##attr)

/* This is used so that we can compile two copies of the semantic code,
   one with full feature support and one without that runs fast(er).
   FAST_P, when desired, is defined on the command line, -DFAST_P=1.  */
#if FAST_P
#define SEM_FN_NAME(cpu,fn) XCONCAT3 (cpu,_semf_,fn)
#undef TRACE_RESULT
#define TRACE_RESULT(cpu, abuf, name, type, val)
#else
#define SEM_FN_NAME(cpu,fn) XCONCAT3 (cpu,_sem_,fn)
#endif

/* x-invalid: --invalid-- */

static SEM_PC
SEM_FN_NAME (iq2000bf,x_invalid) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
    /* Update the recorded pc in the cpu state struct.
       Only necessary for WITH_SCACHE case, but to avoid the
       conditional compilation ....  */
    SET_H_PC (pc);
    /* Virtual insns have zero size.  Overwrite vpc with address of next insn
       using the default-insn-bitsize spec.  When executing insns in parallel
       we may want to queue the fault and continue execution.  */
    vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
    vpc = sim_engine_invalid_insn (current_cpu, pc, vpc);
  }

  return vpc;
#undef FLD
}

/* x-after: --after-- */

static SEM_PC
SEM_FN_NAME (iq2000bf,x_after) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_IQ2000BF
    iq2000bf_pbb_after (current_cpu, sem_arg);
#endif
  }

  return vpc;
#undef FLD
}

/* x-before: --before-- */

static SEM_PC
SEM_FN_NAME (iq2000bf,x_before) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_IQ2000BF
    iq2000bf_pbb_before (current_cpu, sem_arg);
#endif
  }

  return vpc;
#undef FLD
}

/* x-cti-chain: --cti-chain-- */

static SEM_PC
SEM_FN_NAME (iq2000bf,x_cti_chain) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_IQ2000BF
#ifdef DEFINE_SWITCH
    vpc = iq2000bf_pbb_cti_chain (current_cpu, sem_arg,
			       pbb_br_type, pbb_br_npc);
    BREAK (sem);
#else
    /* FIXME: Allow provision of explicit ifmt spec in insn spec.  */
    vpc = iq2000bf_pbb_cti_chain (current_cpu, sem_arg,
			       CPU_PBB_BR_TYPE (current_cpu),
			       CPU_PBB_BR_NPC (current_cpu));
#endif
#endif
  }

  return vpc;
#undef FLD
}

/* x-chain: --chain-- */

static SEM_PC
SEM_FN_NAME (iq2000bf,x_chain) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_IQ2000BF
    vpc = iq2000bf_pbb_chain (current_cpu, sem_arg);
#ifdef DEFINE_SWITCH
    BREAK (sem);
#endif
#endif
  }

  return vpc;
#undef FLD
}

/* x-begin: --begin-- */

static SEM_PC
SEM_FN_NAME (iq2000bf,x_begin) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_IQ2000BF
#if defined DEFINE_SWITCH || defined FAST_P
    /* In the switch case FAST_P is a constant, allowing several optimizations
       in any called inline functions.  */
    vpc = iq2000bf_pbb_begin (current_cpu, FAST_P);
#else
#if 0 /* cgen engine can't handle dynamic fast/full switching yet.  */
    vpc = iq2000bf_pbb_begin (current_cpu, STATE_RUN_FAST_P (CPU_STATE (current_cpu)));
#else
    vpc = iq2000bf_pbb_begin (current_cpu, 0);
#endif
#endif
#endif
  }

  return vpc;
#undef FLD
}

/* add: add $rd,$rs,$rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,add) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_mrgb.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ADDSI (GET_H_GR (FLD (f_rs)), GET_H_GR (FLD (f_rt)));
    SET_H_GR (FLD (f_rd), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* addi: addi $rt,$rs,$lo16 */

static SEM_PC
SEM_FN_NAME (iq2000bf,addi) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ADDSI (GET_H_GR (FLD (f_rs)), EXTHISI (TRUNCSIHI (FLD (f_imm))));
    SET_H_GR (FLD (f_rt), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* addiu: addiu $rt,$rs,$lo16 */

static SEM_PC
SEM_FN_NAME (iq2000bf,addiu) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ADDSI (GET_H_GR (FLD (f_rs)), EXTHISI (TRUNCSIHI (FLD (f_imm))));
    SET_H_GR (FLD (f_rt), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* addu: addu $rd,$rs,$rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,addu) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_mrgb.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ADDSI (GET_H_GR (FLD (f_rs)), GET_H_GR (FLD (f_rt)));
    SET_H_GR (FLD (f_rd), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* ado16: ado16 $rd,$rs,$rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,ado16) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_mrgb.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

{
  HI tmp_high;
  HI tmp_low;
  tmp_low = ADDHI (ANDHI (GET_H_GR (FLD (f_rs)), 65535), ANDHI (GET_H_GR (FLD (f_rt)), 65535));
  tmp_high = ADDHI (SRLSI (GET_H_GR (FLD (f_rs)), 16), SRLSI (GET_H_GR (FLD (f_rt)), 16));
  {
    SI opval = ORSI (SLLSI (tmp_high, 16), tmp_low);
    SET_H_GR (FLD (f_rd), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* and: and $rd,$rs,$rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,and) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_mrgb.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ANDSI (GET_H_GR (FLD (f_rs)), GET_H_GR (FLD (f_rt)));
    SET_H_GR (FLD (f_rd), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* andi: andi $rt,$rs,$lo16 */

static SEM_PC
SEM_FN_NAME (iq2000bf,andi) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ANDSI (GET_H_GR (FLD (f_rs)), ZEXTSISI (FLD (f_imm)));
    SET_H_GR (FLD (f_rt), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* andoi: andoi $rt,$rs,$lo16 */

static SEM_PC
SEM_FN_NAME (iq2000bf,andoi) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ANDSI (GET_H_GR (FLD (f_rs)), ORSI (0xffff0000, EXTHISI (TRUNCSIHI (FLD (f_imm)))));
    SET_H_GR (FLD (f_rt), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* nor: nor $rd,$rs,$rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,nor) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_mrgb.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = INVSI (ORSI (GET_H_GR (FLD (f_rs)), GET_H_GR (FLD (f_rt))));
    SET_H_GR (FLD (f_rd), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* or: or $rd,$rs,$rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,or) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_mrgb.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ORSI (GET_H_GR (FLD (f_rs)), GET_H_GR (FLD (f_rt)));
    SET_H_GR (FLD (f_rd), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* ori: ori $rt,$rs,$lo16 */

static SEM_PC
SEM_FN_NAME (iq2000bf,ori) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ORSI (GET_H_GR (FLD (f_rs)), ZEXTSISI (FLD (f_imm)));
    SET_H_GR (FLD (f_rt), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* ram: ram $rd,$rt,$shamt,$maskl,$maskr */

static SEM_PC
SEM_FN_NAME (iq2000bf,ram) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_ram.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

{
  {
    SI opval = RORSI (GET_H_GR (FLD (f_rt)), FLD (f_shamt));
    SET_H_GR (FLD (f_rd), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    SI opval = ANDSI (GET_H_GR (FLD (f_rd)), SRLSI (0xffffffff, FLD (f_maskl)));
    SET_H_GR (FLD (f_rd), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    SI opval = ANDSI (GET_H_GR (FLD (f_rd)), SLLSI (0xffffffff, FLD (f_rs)));
    SET_H_GR (FLD (f_rd), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* sll: sll $rd,$rt,$shamt */

static SEM_PC
SEM_FN_NAME (iq2000bf,sll) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_ram.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = SLLSI (GET_H_GR (FLD (f_rt)), FLD (f_shamt));
    SET_H_GR (FLD (f_rd), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* sllv: sllv $rd,$rt,$rs */

static SEM_PC
SEM_FN_NAME (iq2000bf,sllv) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_mrgb.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = SLLSI (GET_H_GR (FLD (f_rt)), ANDSI (GET_H_GR (FLD (f_rs)), 31));
    SET_H_GR (FLD (f_rd), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* slmv: slmv $rd,$rt,$rs,$shamt */

static SEM_PC
SEM_FN_NAME (iq2000bf,slmv) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_ram.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ANDSI (SLLSI (GET_H_GR (FLD (f_rt)), FLD (f_shamt)), SRLSI (0xffffffff, GET_H_GR (FLD (f_rs))));
    SET_H_GR (FLD (f_rd), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* slt: slt $rd,$rs,$rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,slt) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_mrgb.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (LTSI (GET_H_GR (FLD (f_rs)), GET_H_GR (FLD (f_rt)))) {
  {
    SI opval = 1;
    SET_H_GR (FLD (f_rd), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
} else {
  {
    SI opval = 0;
    SET_H_GR (FLD (f_rd), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* slti: slti $rt,$rs,$imm */

static SEM_PC
SEM_FN_NAME (iq2000bf,slti) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (LTSI (GET_H_GR (FLD (f_rs)), EXTHISI (TRUNCSIHI (FLD (f_imm))))) {
  {
    SI opval = 1;
    SET_H_GR (FLD (f_rt), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
} else {
  {
    SI opval = 0;
    SET_H_GR (FLD (f_rt), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* sltiu: sltiu $rt,$rs,$imm */

static SEM_PC
SEM_FN_NAME (iq2000bf,sltiu) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (LTUSI (GET_H_GR (FLD (f_rs)), EXTHISI (TRUNCSIHI (FLD (f_imm))))) {
  {
    SI opval = 1;
    SET_H_GR (FLD (f_rt), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
} else {
  {
    SI opval = 0;
    SET_H_GR (FLD (f_rt), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* sltu: sltu $rd,$rs,$rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,sltu) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_mrgb.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (LTUSI (GET_H_GR (FLD (f_rs)), GET_H_GR (FLD (f_rt)))) {
  {
    SI opval = 1;
    SET_H_GR (FLD (f_rd), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
} else {
  {
    SI opval = 0;
    SET_H_GR (FLD (f_rd), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* sra: sra $rd,$rt,$shamt */

static SEM_PC
SEM_FN_NAME (iq2000bf,sra) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_ram.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = SRASI (GET_H_GR (FLD (f_rt)), FLD (f_shamt));
    SET_H_GR (FLD (f_rd), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* srav: srav $rd,$rt,$rs */

static SEM_PC
SEM_FN_NAME (iq2000bf,srav) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_mrgb.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = SRASI (GET_H_GR (FLD (f_rt)), ANDSI (GET_H_GR (FLD (f_rs)), 31));
    SET_H_GR (FLD (f_rd), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* srl: srl $rd,$rt,$shamt */

static SEM_PC
SEM_FN_NAME (iq2000bf,srl) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_ram.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = SRLSI (GET_H_GR (FLD (f_rt)), FLD (f_shamt));
    SET_H_GR (FLD (f_rd), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* srlv: srlv $rd,$rt,$rs */

static SEM_PC
SEM_FN_NAME (iq2000bf,srlv) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_mrgb.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = SRLSI (GET_H_GR (FLD (f_rt)), ANDSI (GET_H_GR (FLD (f_rs)), 31));
    SET_H_GR (FLD (f_rd), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* srmv: srmv $rd,$rt,$rs,$shamt */

static SEM_PC
SEM_FN_NAME (iq2000bf,srmv) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_ram.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ANDSI (SRLSI (GET_H_GR (FLD (f_rt)), FLD (f_shamt)), SLLSI (0xffffffff, GET_H_GR (FLD (f_rs))));
    SET_H_GR (FLD (f_rd), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* sub: sub $rd,$rs,$rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,sub) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_mrgb.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = SUBSI (GET_H_GR (FLD (f_rs)), GET_H_GR (FLD (f_rt)));
    SET_H_GR (FLD (f_rd), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* subu: subu $rd,$rs,$rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,subu) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_mrgb.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = SUBSI (GET_H_GR (FLD (f_rs)), GET_H_GR (FLD (f_rt)));
    SET_H_GR (FLD (f_rd), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* xor: xor $rd,$rs,$rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,xor) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_mrgb.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = XORSI (GET_H_GR (FLD (f_rs)), GET_H_GR (FLD (f_rt)));
    SET_H_GR (FLD (f_rd), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* xori: xori $rt,$rs,$lo16 */

static SEM_PC
SEM_FN_NAME (iq2000bf,xori) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = XORSI (GET_H_GR (FLD (f_rs)), ZEXTSISI (FLD (f_imm)));
    SET_H_GR (FLD (f_rt), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* bbi: bbi $rs($bitnum),$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bbi) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (ANDSI (GET_H_GR (FLD (f_rs)), SLLSI (1, FLD (f_rt)))) {
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bbin: bbin $rs($bitnum),$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bbin) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (NOTSI (ANDSI (GET_H_GR (FLD (f_rs)), SLLSI (1, FLD (f_rt))))) {
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bbv: bbv $rs,$rt,$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bbv) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (ANDSI (GET_H_GR (FLD (f_rs)), SLLSI (1, ANDSI (GET_H_GR (FLD (f_rt)), 31)))) {
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bbvn: bbvn $rs,$rt,$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bbvn) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (NOTSI (ANDSI (GET_H_GR (FLD (f_rs)), SLLSI (1, ANDSI (GET_H_GR (FLD (f_rt)), 31))))) {
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* beq: beq $rs,$rt,$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,beq) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (EQSI (GET_H_GR (FLD (f_rs)), GET_H_GR (FLD (f_rt)))) {
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* beql: beql $rs,$rt,$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,beql) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (EQSI (GET_H_GR (FLD (f_rs)), GET_H_GR (FLD (f_rt)))) {
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
} else {
if (1)
  SEM_SKIP_INSN (current_cpu, sem_arg, vpc);
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bgez: bgez $rs,$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bgez) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (GESI (GET_H_GR (FLD (f_rs)), 0)) {
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bgezal: bgezal $rs,$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bgezal) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (GESI (GET_H_GR (FLD (f_rs)), 0)) {
{
  {
    SI opval = ADDSI (pc, 8);
    SET_H_GR (((UINT) 31), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bgezall: bgezall $rs,$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bgezall) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (GESI (GET_H_GR (FLD (f_rs)), 0)) {
{
  {
    SI opval = ADDSI (pc, 8);
    SET_H_GR (((UINT) 31), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}
} else {
if (1)
  SEM_SKIP_INSN (current_cpu, sem_arg, vpc);
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bgezl: bgezl $rs,$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bgezl) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (GESI (GET_H_GR (FLD (f_rs)), 0)) {
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
} else {
if (1)
  SEM_SKIP_INSN (current_cpu, sem_arg, vpc);
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bltz: bltz $rs,$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bltz) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (LTSI (GET_H_GR (FLD (f_rs)), 0)) {
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bltzl: bltzl $rs,$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bltzl) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (LTSI (GET_H_GR (FLD (f_rs)), 0)) {
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
} else {
if (1)
  SEM_SKIP_INSN (current_cpu, sem_arg, vpc);
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bltzal: bltzal $rs,$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bltzal) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (LTSI (GET_H_GR (FLD (f_rs)), 0)) {
{
  {
    SI opval = ADDSI (pc, 8);
    SET_H_GR (((UINT) 31), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bltzall: bltzall $rs,$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bltzall) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (LTSI (GET_H_GR (FLD (f_rs)), 0)) {
{
  {
    SI opval = ADDSI (pc, 8);
    SET_H_GR (((UINT) 31), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}
} else {
if (1)
  SEM_SKIP_INSN (current_cpu, sem_arg, vpc);
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bmb0: bmb0 $rs,$rt,$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bmb0) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (EQSI (ANDSI (GET_H_GR (FLD (f_rs)), 255), ANDSI (GET_H_GR (FLD (f_rt)), 255))) {
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bmb1: bmb1 $rs,$rt,$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bmb1) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (EQSI (ANDSI (GET_H_GR (FLD (f_rs)), 65280), ANDSI (GET_H_GR (FLD (f_rt)), 65280))) {
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bmb2: bmb2 $rs,$rt,$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bmb2) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (EQSI (ANDSI (GET_H_GR (FLD (f_rs)), 16711680), ANDSI (GET_H_GR (FLD (f_rt)), 16711680))) {
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bmb3: bmb3 $rs,$rt,$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bmb3) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (EQSI (ANDSI (GET_H_GR (FLD (f_rs)), 0xff000000), ANDSI (GET_H_GR (FLD (f_rt)), 0xff000000))) {
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bne: bne $rs,$rt,$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bne) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (NESI (GET_H_GR (FLD (f_rs)), GET_H_GR (FLD (f_rt)))) {
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bnel: bnel $rs,$rt,$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bnel) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (NESI (GET_H_GR (FLD (f_rs)), GET_H_GR (FLD (f_rt)))) {
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
} else {
if (1)
  SEM_SKIP_INSN (current_cpu, sem_arg, vpc);
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* jalr: jalr $rd,$rs */

static SEM_PC
SEM_FN_NAME (iq2000bf,jalr) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_mrgb.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

{
{
  {
    SI opval = ADDSI (pc, 8);
    SET_H_GR (FLD (f_rd), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    USI opval = GET_H_GR (FLD (f_rs));
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* jr: jr $rs */

static SEM_PC
SEM_FN_NAME (iq2000bf,jr) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

{
  {
    USI opval = GET_H_GR (FLD (f_rs));
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* lb: lb $rt,$lo16($base) */

static SEM_PC
SEM_FN_NAME (iq2000bf,lb) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = EXTQISI (GETMEMQI (current_cpu, pc, ADDSI (GET_H_GR (FLD (f_rs)), EXTHISI (TRUNCSIHI (FLD (f_imm))))));
    SET_H_GR (FLD (f_rt), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* lbu: lbu $rt,$lo16($base) */

static SEM_PC
SEM_FN_NAME (iq2000bf,lbu) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ZEXTQISI (GETMEMQI (current_cpu, pc, ADDSI (GET_H_GR (FLD (f_rs)), EXTHISI (TRUNCSIHI (FLD (f_imm))))));
    SET_H_GR (FLD (f_rt), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* lh: lh $rt,$lo16($base) */

static SEM_PC
SEM_FN_NAME (iq2000bf,lh) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = EXTHISI (GETMEMHI (current_cpu, pc, ADDSI (GET_H_GR (FLD (f_rs)), EXTHISI (TRUNCSIHI (FLD (f_imm))))));
    SET_H_GR (FLD (f_rt), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* lhu: lhu $rt,$lo16($base) */

static SEM_PC
SEM_FN_NAME (iq2000bf,lhu) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ZEXTHISI (GETMEMHI (current_cpu, pc, ADDSI (GET_H_GR (FLD (f_rs)), EXTHISI (TRUNCSIHI (FLD (f_imm))))));
    SET_H_GR (FLD (f_rt), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* lui: lui $rt,$hi16 */

static SEM_PC
SEM_FN_NAME (iq2000bf,lui) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = SLLSI (FLD (f_imm), 16);
    SET_H_GR (FLD (f_rt), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* lw: lw $rt,$lo16($base) */

static SEM_PC
SEM_FN_NAME (iq2000bf,lw) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = GETMEMSI (current_cpu, pc, ADDSI (GET_H_GR (FLD (f_rs)), EXTHISI (TRUNCSIHI (FLD (f_imm)))));
    SET_H_GR (FLD (f_rt), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* sb: sb $rt,$lo16($base) */

static SEM_PC
SEM_FN_NAME (iq2000bf,sb) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    QI opval = ANDQI (GET_H_GR (FLD (f_rt)), 255);
    SETMEMQI (current_cpu, pc, ADDSI (GET_H_GR (FLD (f_rs)), EXTHISI (TRUNCSIHI (FLD (f_imm)))), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* sh: sh $rt,$lo16($base) */

static SEM_PC
SEM_FN_NAME (iq2000bf,sh) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    HI opval = ANDHI (GET_H_GR (FLD (f_rt)), 65535);
    SETMEMHI (current_cpu, pc, ADDSI (GET_H_GR (FLD (f_rs)), EXTHISI (TRUNCSIHI (FLD (f_imm)))), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* sw: sw $rt,$lo16($base) */

static SEM_PC
SEM_FN_NAME (iq2000bf,sw) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = GET_H_GR (FLD (f_rt));
    SETMEMSI (current_cpu, pc, ADDSI (GET_H_GR (FLD (f_rs)), EXTHISI (TRUNCSIHI (FLD (f_imm)))), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* break: break */

static SEM_PC
SEM_FN_NAME (iq2000bf,break) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

do_break (current_cpu, pc);

  return vpc;
#undef FLD
}

/* syscall: syscall */

static SEM_PC
SEM_FN_NAME (iq2000bf,syscall) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

do_syscall (current_cpu);

  return vpc;
#undef FLD
}

/* andoui: andoui $rt,$rs,$hi16 */

static SEM_PC
SEM_FN_NAME (iq2000bf,andoui) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ANDSI (GET_H_GR (FLD (f_rs)), ORSI (SLLSI (FLD (f_imm), 16), 65535));
    SET_H_GR (FLD (f_rt), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* orui: orui $rt,$rs,$hi16 */

static SEM_PC
SEM_FN_NAME (iq2000bf,orui) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ORSI (GET_H_GR (FLD (f_rs)), SLLSI (FLD (f_imm), 16));
    SET_H_GR (FLD (f_rt), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* bgtz: bgtz $rs,$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bgtz) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (GTSI (GET_H_GR (FLD (f_rs)), 0)) {
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bgtzl: bgtzl $rs,$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bgtzl) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (GTSI (GET_H_GR (FLD (f_rs)), 0)) {
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
} else {
if (1)
  SEM_SKIP_INSN (current_cpu, sem_arg, vpc);
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* blez: blez $rs,$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,blez) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (LESI (GET_H_GR (FLD (f_rs)), 0)) {
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* blezl: blezl $rs,$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,blezl) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (LESI (GET_H_GR (FLD (f_rs)), 0)) {
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
} else {
if (1)
  SEM_SKIP_INSN (current_cpu, sem_arg, vpc);
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* mrgb: mrgb $rd,$rs,$rt,$mask */

static SEM_PC
SEM_FN_NAME (iq2000bf,mrgb) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_mrgb.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

{
  SI tmp_temp;
if (NOTSI (ANDSI (FLD (f_mask), SLLSI (1, 0)))) {
  tmp_temp = ANDSI (GET_H_GR (FLD (f_rs)), 255);
} else {
  tmp_temp = ANDSI (GET_H_GR (FLD (f_rt)), 255);
}
if (NOTSI (ANDSI (FLD (f_mask), SLLSI (1, 1)))) {
  tmp_temp = ORSI (tmp_temp, ANDSI (GET_H_GR (FLD (f_rs)), 65280));
} else {
  tmp_temp = ORSI (tmp_temp, ANDSI (GET_H_GR (FLD (f_rt)), 65280));
}
if (NOTSI (ANDSI (FLD (f_mask), SLLSI (1, 2)))) {
  tmp_temp = ORSI (tmp_temp, ANDSI (GET_H_GR (FLD (f_rs)), 16711680));
} else {
  tmp_temp = ORSI (tmp_temp, ANDSI (GET_H_GR (FLD (f_rt)), 16711680));
}
if (NOTSI (ANDSI (FLD (f_mask), SLLSI (1, 3)))) {
  tmp_temp = ORSI (tmp_temp, ANDSI (GET_H_GR (FLD (f_rs)), 0xff000000));
} else {
  tmp_temp = ORSI (tmp_temp, ANDSI (GET_H_GR (FLD (f_rt)), 0xff000000));
}
  {
    SI opval = tmp_temp;
    SET_H_GR (FLD (f_rd), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* bctxt: bctxt $rs,$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bctxt) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bc0f: bc0f $offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bc0f) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bc0fl: bc0fl $offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bc0fl) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bc3f: bc3f $offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bc3f) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bc3fl: bc3fl $offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bc3fl) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bc0t: bc0t $offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bc0t) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bc0tl: bc0tl $offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bc0tl) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bc3t: bc3t $offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bc3t) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bc3tl: bc3tl $offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bc3tl) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* cfc0: cfc0 $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,cfc0) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* cfc1: cfc1 $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,cfc1) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* cfc2: cfc2 $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,cfc2) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* cfc3: cfc3 $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,cfc3) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* chkhdr: chkhdr $rd,$rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,chkhdr) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* ctc0: ctc0 $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,ctc0) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* ctc1: ctc1 $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,ctc1) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* ctc2: ctc2 $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,ctc2) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* ctc3: ctc3 $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,ctc3) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* jcr: jcr $rs */

static SEM_PC
SEM_FN_NAME (iq2000bf,jcr) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* luc32: luc32 $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,luc32) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* luc32l: luc32l $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,luc32l) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* luc64: luc64 $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,luc64) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* luc64l: luc64l $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,luc64l) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* luk: luk $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,luk) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* lulck: lulck $rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,lulck) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* lum32: lum32 $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,lum32) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* lum32l: lum32l $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,lum32l) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* lum64: lum64 $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,lum64) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* lum64l: lum64l $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,lum64l) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* lur: lur $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,lur) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* lurl: lurl $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,lurl) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* luulck: luulck $rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,luulck) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* mfc0: mfc0 $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,mfc0) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* mfc1: mfc1 $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,mfc1) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* mfc2: mfc2 $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,mfc2) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* mfc3: mfc3 $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,mfc3) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* mtc0: mtc0 $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,mtc0) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* mtc1: mtc1 $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,mtc1) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* mtc2: mtc2 $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,mtc2) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* mtc3: mtc3 $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,mtc3) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* pkrl: pkrl $rd,$rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,pkrl) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* pkrlr1: pkrlr1 $rt,$_index,$count */

static SEM_PC
SEM_FN_NAME (iq2000bf,pkrlr1) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* pkrlr30: pkrlr30 $rt,$_index,$count */

static SEM_PC
SEM_FN_NAME (iq2000bf,pkrlr30) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* rb: rb $rd,$rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,rb) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* rbr1: rbr1 $rt,$_index,$count */

static SEM_PC
SEM_FN_NAME (iq2000bf,rbr1) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* rbr30: rbr30 $rt,$_index,$count */

static SEM_PC
SEM_FN_NAME (iq2000bf,rbr30) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* rfe: rfe */

static SEM_PC
SEM_FN_NAME (iq2000bf,rfe) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* rx: rx $rd,$rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,rx) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* rxr1: rxr1 $rt,$_index,$count */

static SEM_PC
SEM_FN_NAME (iq2000bf,rxr1) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* rxr30: rxr30 $rt,$_index,$count */

static SEM_PC
SEM_FN_NAME (iq2000bf,rxr30) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* sleep: sleep */

static SEM_PC
SEM_FN_NAME (iq2000bf,sleep) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* srrd: srrd $rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,srrd) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* srrdl: srrdl $rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,srrdl) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* srulck: srulck $rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,srulck) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* srwr: srwr $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,srwr) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* srwru: srwru $rt,$rd */

static SEM_PC
SEM_FN_NAME (iq2000bf,srwru) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* trapqfl: trapqfl */

static SEM_PC
SEM_FN_NAME (iq2000bf,trapqfl) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* trapqne: trapqne */

static SEM_PC
SEM_FN_NAME (iq2000bf,trapqne) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* traprel: traprel $rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,traprel) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* wb: wb $rd,$rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,wb) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* wbu: wbu $rd,$rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,wbu) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* wbr1: wbr1 $rt,$_index,$count */

static SEM_PC
SEM_FN_NAME (iq2000bf,wbr1) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* wbr1u: wbr1u $rt,$_index,$count */

static SEM_PC
SEM_FN_NAME (iq2000bf,wbr1u) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* wbr30: wbr30 $rt,$_index,$count */

static SEM_PC
SEM_FN_NAME (iq2000bf,wbr30) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* wbr30u: wbr30u $rt,$_index,$count */

static SEM_PC
SEM_FN_NAME (iq2000bf,wbr30u) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* wx: wx $rd,$rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,wx) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* wxu: wxu $rd,$rt */

static SEM_PC
SEM_FN_NAME (iq2000bf,wxu) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* wxr1: wxr1 $rt,$_index,$count */

static SEM_PC
SEM_FN_NAME (iq2000bf,wxr1) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* wxr1u: wxr1u $rt,$_index,$count */

static SEM_PC
SEM_FN_NAME (iq2000bf,wxr1u) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* wxr30: wxr30 $rt,$_index,$count */

static SEM_PC
SEM_FN_NAME (iq2000bf,wxr30) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* wxr30u: wxr30u $rt,$_index,$count */

static SEM_PC
SEM_FN_NAME (iq2000bf,wxr30u) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* ldw: ldw $rt,$lo16($base) */

static SEM_PC
SEM_FN_NAME (iq2000bf,ldw) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

{
  SI tmp_addr;
  tmp_addr = ANDSI (ADDSI (GET_H_GR (FLD (f_rs)), FLD (f_imm)), INVSI (3));
  {
    SI opval = GETMEMSI (current_cpu, pc, tmp_addr);
    SET_H_GR (ADDSI (FLD (f_rt), 1), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    SI opval = GETMEMSI (current_cpu, pc, ADDSI (tmp_addr, 4));
    SET_H_GR (FLD (f_rt), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* sdw: sdw $rt,$lo16($base) */

static SEM_PC
SEM_FN_NAME (iq2000bf,sdw) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

{
  SI tmp_addr;
  tmp_addr = ANDSI (ADDSI (GET_H_GR (FLD (f_rs)), FLD (f_imm)), INVSI (3));
  {
    SI opval = GET_H_GR (FLD (f_rt));
    SETMEMSI (current_cpu, pc, ADDSI (tmp_addr, 4), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = GET_H_GR (ADDSI (FLD (f_rt), 1));
    SETMEMSI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* j: j $jmptarg */

static SEM_PC
SEM_FN_NAME (iq2000bf,j) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_j.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

{
  {
    USI opval = FLD (i_jmptarg);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* jal: jal $jmptarg */

static SEM_PC
SEM_FN_NAME (iq2000bf,jal) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_j.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

{
{
  {
    SI opval = ADDSI (pc, 8);
    SET_H_GR (((UINT) 31), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    USI opval = FLD (i_jmptarg);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bmb: bmb $rs,$rt,$offset */

static SEM_PC
SEM_FN_NAME (iq2000bf,bmb) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bbi.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

{
  BI tmp_branch_;
  tmp_branch_ = 0;
if (EQSI (ANDSI (GET_H_GR (FLD (f_rs)), 255), ANDSI (GET_H_GR (FLD (f_rt)), 255))) {
  tmp_branch_ = 1;
}
if (EQSI (ANDSI (GET_H_GR (FLD (f_rs)), 65280), ANDSI (GET_H_GR (FLD (f_rt)), 65280))) {
  tmp_branch_ = 1;
}
if (EQSI (ANDSI (GET_H_GR (FLD (f_rs)), 16711680), ANDSI (GET_H_GR (FLD (f_rt)), 16711680))) {
  tmp_branch_ = 1;
}
if (EQSI (ANDSI (GET_H_GR (FLD (f_rs)), 0xff000000), ANDSI (GET_H_GR (FLD (f_rt)), 0xff000000))) {
  tmp_branch_ = 1;
}
if (tmp_branch_) {
{
  {
    USI opval = FLD (i_offset);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* Table of all semantic fns.  */

static const struct sem_fn_desc sem_fns[] = {
  { IQ2000BF_INSN_X_INVALID, SEM_FN_NAME (iq2000bf,x_invalid) },
  { IQ2000BF_INSN_X_AFTER, SEM_FN_NAME (iq2000bf,x_after) },
  { IQ2000BF_INSN_X_BEFORE, SEM_FN_NAME (iq2000bf,x_before) },
  { IQ2000BF_INSN_X_CTI_CHAIN, SEM_FN_NAME (iq2000bf,x_cti_chain) },
  { IQ2000BF_INSN_X_CHAIN, SEM_FN_NAME (iq2000bf,x_chain) },
  { IQ2000BF_INSN_X_BEGIN, SEM_FN_NAME (iq2000bf,x_begin) },
  { IQ2000BF_INSN_ADD, SEM_FN_NAME (iq2000bf,add) },
  { IQ2000BF_INSN_ADDI, SEM_FN_NAME (iq2000bf,addi) },
  { IQ2000BF_INSN_ADDIU, SEM_FN_NAME (iq2000bf,addiu) },
  { IQ2000BF_INSN_ADDU, SEM_FN_NAME (iq2000bf,addu) },
  { IQ2000BF_INSN_ADO16, SEM_FN_NAME (iq2000bf,ado16) },
  { IQ2000BF_INSN_AND, SEM_FN_NAME (iq2000bf,and) },
  { IQ2000BF_INSN_ANDI, SEM_FN_NAME (iq2000bf,andi) },
  { IQ2000BF_INSN_ANDOI, SEM_FN_NAME (iq2000bf,andoi) },
  { IQ2000BF_INSN_NOR, SEM_FN_NAME (iq2000bf,nor) },
  { IQ2000BF_INSN_OR, SEM_FN_NAME (iq2000bf,or) },
  { IQ2000BF_INSN_ORI, SEM_FN_NAME (iq2000bf,ori) },
  { IQ2000BF_INSN_RAM, SEM_FN_NAME (iq2000bf,ram) },
  { IQ2000BF_INSN_SLL, SEM_FN_NAME (iq2000bf,sll) },
  { IQ2000BF_INSN_SLLV, SEM_FN_NAME (iq2000bf,sllv) },
  { IQ2000BF_INSN_SLMV, SEM_FN_NAME (iq2000bf,slmv) },
  { IQ2000BF_INSN_SLT, SEM_FN_NAME (iq2000bf,slt) },
  { IQ2000BF_INSN_SLTI, SEM_FN_NAME (iq2000bf,slti) },
  { IQ2000BF_INSN_SLTIU, SEM_FN_NAME (iq2000bf,sltiu) },
  { IQ2000BF_INSN_SLTU, SEM_FN_NAME (iq2000bf,sltu) },
  { IQ2000BF_INSN_SRA, SEM_FN_NAME (iq2000bf,sra) },
  { IQ2000BF_INSN_SRAV, SEM_FN_NAME (iq2000bf,srav) },
  { IQ2000BF_INSN_SRL, SEM_FN_NAME (iq2000bf,srl) },
  { IQ2000BF_INSN_SRLV, SEM_FN_NAME (iq2000bf,srlv) },
  { IQ2000BF_INSN_SRMV, SEM_FN_NAME (iq2000bf,srmv) },
  { IQ2000BF_INSN_SUB, SEM_FN_NAME (iq2000bf,sub) },
  { IQ2000BF_INSN_SUBU, SEM_FN_NAME (iq2000bf,subu) },
  { IQ2000BF_INSN_XOR, SEM_FN_NAME (iq2000bf,xor) },
  { IQ2000BF_INSN_XORI, SEM_FN_NAME (iq2000bf,xori) },
  { IQ2000BF_INSN_BBI, SEM_FN_NAME (iq2000bf,bbi) },
  { IQ2000BF_INSN_BBIN, SEM_FN_NAME (iq2000bf,bbin) },
  { IQ2000BF_INSN_BBV, SEM_FN_NAME (iq2000bf,bbv) },
  { IQ2000BF_INSN_BBVN, SEM_FN_NAME (iq2000bf,bbvn) },
  { IQ2000BF_INSN_BEQ, SEM_FN_NAME (iq2000bf,beq) },
  { IQ2000BF_INSN_BEQL, SEM_FN_NAME (iq2000bf,beql) },
  { IQ2000BF_INSN_BGEZ, SEM_FN_NAME (iq2000bf,bgez) },
  { IQ2000BF_INSN_BGEZAL, SEM_FN_NAME (iq2000bf,bgezal) },
  { IQ2000BF_INSN_BGEZALL, SEM_FN_NAME (iq2000bf,bgezall) },
  { IQ2000BF_INSN_BGEZL, SEM_FN_NAME (iq2000bf,bgezl) },
  { IQ2000BF_INSN_BLTZ, SEM_FN_NAME (iq2000bf,bltz) },
  { IQ2000BF_INSN_BLTZL, SEM_FN_NAME (iq2000bf,bltzl) },
  { IQ2000BF_INSN_BLTZAL, SEM_FN_NAME (iq2000bf,bltzal) },
  { IQ2000BF_INSN_BLTZALL, SEM_FN_NAME (iq2000bf,bltzall) },
  { IQ2000BF_INSN_BMB0, SEM_FN_NAME (iq2000bf,bmb0) },
  { IQ2000BF_INSN_BMB1, SEM_FN_NAME (iq2000bf,bmb1) },
  { IQ2000BF_INSN_BMB2, SEM_FN_NAME (iq2000bf,bmb2) },
  { IQ2000BF_INSN_BMB3, SEM_FN_NAME (iq2000bf,bmb3) },
  { IQ2000BF_INSN_BNE, SEM_FN_NAME (iq2000bf,bne) },
  { IQ2000BF_INSN_BNEL, SEM_FN_NAME (iq2000bf,bnel) },
  { IQ2000BF_INSN_JALR, SEM_FN_NAME (iq2000bf,jalr) },
  { IQ2000BF_INSN_JR, SEM_FN_NAME (iq2000bf,jr) },
  { IQ2000BF_INSN_LB, SEM_FN_NAME (iq2000bf,lb) },
  { IQ2000BF_INSN_LBU, SEM_FN_NAME (iq2000bf,lbu) },
  { IQ2000BF_INSN_LH, SEM_FN_NAME (iq2000bf,lh) },
  { IQ2000BF_INSN_LHU, SEM_FN_NAME (iq2000bf,lhu) },
  { IQ2000BF_INSN_LUI, SEM_FN_NAME (iq2000bf,lui) },
  { IQ2000BF_INSN_LW, SEM_FN_NAME (iq2000bf,lw) },
  { IQ2000BF_INSN_SB, SEM_FN_NAME (iq2000bf,sb) },
  { IQ2000BF_INSN_SH, SEM_FN_NAME (iq2000bf,sh) },
  { IQ2000BF_INSN_SW, SEM_FN_NAME (iq2000bf,sw) },
  { IQ2000BF_INSN_BREAK, SEM_FN_NAME (iq2000bf,break) },
  { IQ2000BF_INSN_SYSCALL, SEM_FN_NAME (iq2000bf,syscall) },
  { IQ2000BF_INSN_ANDOUI, SEM_FN_NAME (iq2000bf,andoui) },
  { IQ2000BF_INSN_ORUI, SEM_FN_NAME (iq2000bf,orui) },
  { IQ2000BF_INSN_BGTZ, SEM_FN_NAME (iq2000bf,bgtz) },
  { IQ2000BF_INSN_BGTZL, SEM_FN_NAME (iq2000bf,bgtzl) },
  { IQ2000BF_INSN_BLEZ, SEM_FN_NAME (iq2000bf,blez) },
  { IQ2000BF_INSN_BLEZL, SEM_FN_NAME (iq2000bf,blezl) },
  { IQ2000BF_INSN_MRGB, SEM_FN_NAME (iq2000bf,mrgb) },
  { IQ2000BF_INSN_BCTXT, SEM_FN_NAME (iq2000bf,bctxt) },
  { IQ2000BF_INSN_BC0F, SEM_FN_NAME (iq2000bf,bc0f) },
  { IQ2000BF_INSN_BC0FL, SEM_FN_NAME (iq2000bf,bc0fl) },
  { IQ2000BF_INSN_BC3F, SEM_FN_NAME (iq2000bf,bc3f) },
  { IQ2000BF_INSN_BC3FL, SEM_FN_NAME (iq2000bf,bc3fl) },
  { IQ2000BF_INSN_BC0T, SEM_FN_NAME (iq2000bf,bc0t) },
  { IQ2000BF_INSN_BC0TL, SEM_FN_NAME (iq2000bf,bc0tl) },
  { IQ2000BF_INSN_BC3T, SEM_FN_NAME (iq2000bf,bc3t) },
  { IQ2000BF_INSN_BC3TL, SEM_FN_NAME (iq2000bf,bc3tl) },
  { IQ2000BF_INSN_CFC0, SEM_FN_NAME (iq2000bf,cfc0) },
  { IQ2000BF_INSN_CFC1, SEM_FN_NAME (iq2000bf,cfc1) },
  { IQ2000BF_INSN_CFC2, SEM_FN_NAME (iq2000bf,cfc2) },
  { IQ2000BF_INSN_CFC3, SEM_FN_NAME (iq2000bf,cfc3) },
  { IQ2000BF_INSN_CHKHDR, SEM_FN_NAME (iq2000bf,chkhdr) },
  { IQ2000BF_INSN_CTC0, SEM_FN_NAME (iq2000bf,ctc0) },
  { IQ2000BF_INSN_CTC1, SEM_FN_NAME (iq2000bf,ctc1) },
  { IQ2000BF_INSN_CTC2, SEM_FN_NAME (iq2000bf,ctc2) },
  { IQ2000BF_INSN_CTC3, SEM_FN_NAME (iq2000bf,ctc3) },
  { IQ2000BF_INSN_JCR, SEM_FN_NAME (iq2000bf,jcr) },
  { IQ2000BF_INSN_LUC32, SEM_FN_NAME (iq2000bf,luc32) },
  { IQ2000BF_INSN_LUC32L, SEM_FN_NAME (iq2000bf,luc32l) },
  { IQ2000BF_INSN_LUC64, SEM_FN_NAME (iq2000bf,luc64) },
  { IQ2000BF_INSN_LUC64L, SEM_FN_NAME (iq2000bf,luc64l) },
  { IQ2000BF_INSN_LUK, SEM_FN_NAME (iq2000bf,luk) },
  { IQ2000BF_INSN_LULCK, SEM_FN_NAME (iq2000bf,lulck) },
  { IQ2000BF_INSN_LUM32, SEM_FN_NAME (iq2000bf,lum32) },
  { IQ2000BF_INSN_LUM32L, SEM_FN_NAME (iq2000bf,lum32l) },
  { IQ2000BF_INSN_LUM64, SEM_FN_NAME (iq2000bf,lum64) },
  { IQ2000BF_INSN_LUM64L, SEM_FN_NAME (iq2000bf,lum64l) },
  { IQ2000BF_INSN_LUR, SEM_FN_NAME (iq2000bf,lur) },
  { IQ2000BF_INSN_LURL, SEM_FN_NAME (iq2000bf,lurl) },
  { IQ2000BF_INSN_LUULCK, SEM_FN_NAME (iq2000bf,luulck) },
  { IQ2000BF_INSN_MFC0, SEM_FN_NAME (iq2000bf,mfc0) },
  { IQ2000BF_INSN_MFC1, SEM_FN_NAME (iq2000bf,mfc1) },
  { IQ2000BF_INSN_MFC2, SEM_FN_NAME (iq2000bf,mfc2) },
  { IQ2000BF_INSN_MFC3, SEM_FN_NAME (iq2000bf,mfc3) },
  { IQ2000BF_INSN_MTC0, SEM_FN_NAME (iq2000bf,mtc0) },
  { IQ2000BF_INSN_MTC1, SEM_FN_NAME (iq2000bf,mtc1) },
  { IQ2000BF_INSN_MTC2, SEM_FN_NAME (iq2000bf,mtc2) },
  { IQ2000BF_INSN_MTC3, SEM_FN_NAME (iq2000bf,mtc3) },
  { IQ2000BF_INSN_PKRL, SEM_FN_NAME (iq2000bf,pkrl) },
  { IQ2000BF_INSN_PKRLR1, SEM_FN_NAME (iq2000bf,pkrlr1) },
  { IQ2000BF_INSN_PKRLR30, SEM_FN_NAME (iq2000bf,pkrlr30) },
  { IQ2000BF_INSN_RB, SEM_FN_NAME (iq2000bf,rb) },
  { IQ2000BF_INSN_RBR1, SEM_FN_NAME (iq2000bf,rbr1) },
  { IQ2000BF_INSN_RBR30, SEM_FN_NAME (iq2000bf,rbr30) },
  { IQ2000BF_INSN_RFE, SEM_FN_NAME (iq2000bf,rfe) },
  { IQ2000BF_INSN_RX, SEM_FN_NAME (iq2000bf,rx) },
  { IQ2000BF_INSN_RXR1, SEM_FN_NAME (iq2000bf,rxr1) },
  { IQ2000BF_INSN_RXR30, SEM_FN_NAME (iq2000bf,rxr30) },
  { IQ2000BF_INSN_SLEEP, SEM_FN_NAME (iq2000bf,sleep) },
  { IQ2000BF_INSN_SRRD, SEM_FN_NAME (iq2000bf,srrd) },
  { IQ2000BF_INSN_SRRDL, SEM_FN_NAME (iq2000bf,srrdl) },
  { IQ2000BF_INSN_SRULCK, SEM_FN_NAME (iq2000bf,srulck) },
  { IQ2000BF_INSN_SRWR, SEM_FN_NAME (iq2000bf,srwr) },
  { IQ2000BF_INSN_SRWRU, SEM_FN_NAME (iq2000bf,srwru) },
  { IQ2000BF_INSN_TRAPQFL, SEM_FN_NAME (iq2000bf,trapqfl) },
  { IQ2000BF_INSN_TRAPQNE, SEM_FN_NAME (iq2000bf,trapqne) },
  { IQ2000BF_INSN_TRAPREL, SEM_FN_NAME (iq2000bf,traprel) },
  { IQ2000BF_INSN_WB, SEM_FN_NAME (iq2000bf,wb) },
  { IQ2000BF_INSN_WBU, SEM_FN_NAME (iq2000bf,wbu) },
  { IQ2000BF_INSN_WBR1, SEM_FN_NAME (iq2000bf,wbr1) },
  { IQ2000BF_INSN_WBR1U, SEM_FN_NAME (iq2000bf,wbr1u) },
  { IQ2000BF_INSN_WBR30, SEM_FN_NAME (iq2000bf,wbr30) },
  { IQ2000BF_INSN_WBR30U, SEM_FN_NAME (iq2000bf,wbr30u) },
  { IQ2000BF_INSN_WX, SEM_FN_NAME (iq2000bf,wx) },
  { IQ2000BF_INSN_WXU, SEM_FN_NAME (iq2000bf,wxu) },
  { IQ2000BF_INSN_WXR1, SEM_FN_NAME (iq2000bf,wxr1) },
  { IQ2000BF_INSN_WXR1U, SEM_FN_NAME (iq2000bf,wxr1u) },
  { IQ2000BF_INSN_WXR30, SEM_FN_NAME (iq2000bf,wxr30) },
  { IQ2000BF_INSN_WXR30U, SEM_FN_NAME (iq2000bf,wxr30u) },
  { IQ2000BF_INSN_LDW, SEM_FN_NAME (iq2000bf,ldw) },
  { IQ2000BF_INSN_SDW, SEM_FN_NAME (iq2000bf,sdw) },
  { IQ2000BF_INSN_J, SEM_FN_NAME (iq2000bf,j) },
  { IQ2000BF_INSN_JAL, SEM_FN_NAME (iq2000bf,jal) },
  { IQ2000BF_INSN_BMB, SEM_FN_NAME (iq2000bf,bmb) },
  { 0, 0 }
};

/* Add the semantic fns to IDESC_TABLE.  */

void
SEM_FN_NAME (iq2000bf,init_idesc_table) (SIM_CPU *current_cpu)
{
  IDESC *idesc_table = CPU_IDESC (current_cpu);
  const struct sem_fn_desc *sf;
  int mach_num = MACH_NUM (CPU_MACH (current_cpu));

  for (sf = &sem_fns[0]; sf->fn != 0; ++sf)
    {
      const CGEN_INSN *insn = idesc_table[sf->index].idata;
      int valid_p = (CGEN_INSN_VIRTUAL_P (insn)
		     || CGEN_INSN_MACH_HAS_P (insn, mach_num));
#if FAST_P
      if (valid_p)
	idesc_table[sf->index].sem_fast = sf->fn;
      else
	idesc_table[sf->index].sem_fast = SEM_FN_NAME (iq2000bf,x_invalid);
#else
      if (valid_p)
	idesc_table[sf->index].sem_full = sf->fn;
      else
	idesc_table[sf->index].sem_full = SEM_FN_NAME (iq2000bf,x_invalid);
#endif
    }
}

@


1.7
log
@[sim] Update old contact info in GPL license notices

sim/ChangeLog:

        Update old contact info in GPL license notices.
@
text
@d5 1
a5 1
Copyright 1996-2010, 2012 Free Software Foundation, Inc.
@


1.6
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d20 1
a20 2
   with this program; if not, write to the Free Software Foundation, Inc.,
   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
@


1.5
log
@Regenerate cgen-derived files.
@
text
@d5 1
a5 1
Copyright 1996-2010 Free Software Foundation, Inc.
@


1.5.8.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d5 1
a5 1
Copyright 1996-2010, 2012 Free Software Foundation, Inc.
@


1.4
log
@Regenerate cgen files, update copyright year.
@
text
@a32 1
#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
a33 3
#else
#define GET_ATTR(cpu, num, attr) CGEN_ATTR_VALUE (NULL, abuf->idesc->attrs, CGEN_INSN_/**/attr)
#endif
d51 1
a51 1
#define FLD(f) abuf->fields.fmt_empty.f
d78 1
a78 1
#define FLD(f) abuf->fields.fmt_empty.f
d99 1
a99 1
#define FLD(f) abuf->fields.fmt_empty.f
d120 1
a120 1
#define FLD(f) abuf->fields.fmt_empty.f
d150 1
a150 1
#define FLD(f) abuf->fields.fmt_empty.f
d174 1
a174 1
#define FLD(f) abuf->fields.fmt_empty.f
d1731 1
a1731 1
#define FLD(f) abuf->fields.fmt_empty.f
d1748 1
a1748 1
#define FLD(f) abuf->fields.fmt_empty.f
d1973 1
a1973 1
#define FLD(f) abuf->fields.fmt_empty.f
d1992 1
a1992 1
#define FLD(f) abuf->fields.fmt_empty.f
d2011 1
a2011 1
#define FLD(f) abuf->fields.fmt_empty.f
d2030 1
a2030 1
#define FLD(f) abuf->fields.fmt_empty.f
d2049 1
a2049 1
#define FLD(f) abuf->fields.fmt_empty.f
d2068 1
a2068 1
#define FLD(f) abuf->fields.fmt_empty.f
d2087 1
a2087 1
#define FLD(f) abuf->fields.fmt_empty.f
d2106 1
a2106 1
#define FLD(f) abuf->fields.fmt_empty.f
d2125 1
a2125 1
#define FLD(f) abuf->fields.fmt_empty.f
d2144 1
a2144 1
#define FLD(f) abuf->fields.fmt_empty.f
d2161 1
a2161 1
#define FLD(f) abuf->fields.fmt_empty.f
d2178 1
a2178 1
#define FLD(f) abuf->fields.fmt_empty.f
d2195 1
a2195 1
#define FLD(f) abuf->fields.fmt_empty.f
d2212 1
a2212 1
#define FLD(f) abuf->fields.fmt_empty.f
d2229 1
a2229 1
#define FLD(f) abuf->fields.fmt_empty.f
d2246 1
a2246 1
#define FLD(f) abuf->fields.fmt_empty.f
d2263 1
a2263 1
#define FLD(f) abuf->fields.fmt_empty.f
d2280 1
a2280 1
#define FLD(f) abuf->fields.fmt_empty.f
d2297 1
a2297 1
#define FLD(f) abuf->fields.fmt_empty.f
d2316 1
a2316 1
#define FLD(f) abuf->fields.fmt_empty.f
d2333 1
a2333 1
#define FLD(f) abuf->fields.fmt_empty.f
d2350 1
a2350 1
#define FLD(f) abuf->fields.fmt_empty.f
d2367 1
a2367 1
#define FLD(f) abuf->fields.fmt_empty.f
d2384 1
a2384 1
#define FLD(f) abuf->fields.fmt_empty.f
d2401 1
a2401 1
#define FLD(f) abuf->fields.fmt_empty.f
d2418 1
a2418 1
#define FLD(f) abuf->fields.fmt_empty.f
d2435 1
a2435 1
#define FLD(f) abuf->fields.fmt_empty.f
d2452 1
a2452 1
#define FLD(f) abuf->fields.fmt_empty.f
d2469 1
a2469 1
#define FLD(f) abuf->fields.fmt_empty.f
d2486 1
a2486 1
#define FLD(f) abuf->fields.fmt_empty.f
d2503 1
a2503 1
#define FLD(f) abuf->fields.fmt_empty.f
d2520 1
a2520 1
#define FLD(f) abuf->fields.fmt_empty.f
d2537 1
a2537 1
#define FLD(f) abuf->fields.fmt_empty.f
d2554 1
a2554 1
#define FLD(f) abuf->fields.fmt_empty.f
d2571 1
a2571 1
#define FLD(f) abuf->fields.fmt_empty.f
d2588 1
a2588 1
#define FLD(f) abuf->fields.fmt_empty.f
d2605 1
a2605 1
#define FLD(f) abuf->fields.fmt_empty.f
d2622 1
a2622 1
#define FLD(f) abuf->fields.fmt_empty.f
d2639 1
a2639 1
#define FLD(f) abuf->fields.fmt_empty.f
d2656 1
a2656 1
#define FLD(f) abuf->fields.fmt_empty.f
d2673 1
a2673 1
#define FLD(f) abuf->fields.fmt_empty.f
d2690 1
a2690 1
#define FLD(f) abuf->fields.fmt_empty.f
d2707 1
a2707 1
#define FLD(f) abuf->fields.fmt_empty.f
d2724 1
a2724 1
#define FLD(f) abuf->fields.fmt_empty.f
d2741 1
a2741 1
#define FLD(f) abuf->fields.fmt_empty.f
d2758 1
a2758 1
#define FLD(f) abuf->fields.fmt_empty.f
d2775 1
a2775 1
#define FLD(f) abuf->fields.fmt_empty.f
d2792 1
a2792 1
#define FLD(f) abuf->fields.fmt_empty.f
d2809 1
a2809 1
#define FLD(f) abuf->fields.fmt_empty.f
d2826 1
a2826 1
#define FLD(f) abuf->fields.fmt_empty.f
d2843 1
a2843 1
#define FLD(f) abuf->fields.fmt_empty.f
d2860 1
a2860 1
#define FLD(f) abuf->fields.fmt_empty.f
d2877 1
a2877 1
#define FLD(f) abuf->fields.fmt_empty.f
d2894 1
a2894 1
#define FLD(f) abuf->fields.fmt_empty.f
d2911 1
a2911 1
#define FLD(f) abuf->fields.fmt_empty.f
d2928 1
a2928 1
#define FLD(f) abuf->fields.fmt_empty.f
d2945 1
a2945 1
#define FLD(f) abuf->fields.fmt_empty.f
d2962 1
a2962 1
#define FLD(f) abuf->fields.fmt_empty.f
d2979 1
a2979 1
#define FLD(f) abuf->fields.fmt_empty.f
d2996 1
a2996 1
#define FLD(f) abuf->fields.fmt_empty.f
d3013 1
a3013 1
#define FLD(f) abuf->fields.fmt_empty.f
d3030 1
a3030 1
#define FLD(f) abuf->fields.fmt_empty.f
d3047 1
a3047 1
#define FLD(f) abuf->fields.fmt_empty.f
d3064 1
a3064 1
#define FLD(f) abuf->fields.fmt_empty.f
d3081 1
a3081 1
#define FLD(f) abuf->fields.fmt_empty.f
d3098 1
a3098 1
#define FLD(f) abuf->fields.fmt_empty.f
d3115 1
a3115 1
#define FLD(f) abuf->fields.fmt_empty.f
d3132 1
a3132 1
#define FLD(f) abuf->fields.fmt_empty.f
d3149 1
a3149 1
#define FLD(f) abuf->fields.fmt_empty.f
d3166 1
a3166 1
#define FLD(f) abuf->fields.fmt_empty.f
d3183 1
a3183 1
#define FLD(f) abuf->fields.fmt_empty.f
@


1.3
log
@	* arch.c: Regenerate.
	* arch.h: Regenerate.
	* cpu.c: Regenerate.
	* cpu.h: Regenerate.
	* cpuall.h: Regenerate.
	* decode.c: Regenerate.
	* decode.h: Regenerate.
	* model.c: Regenerate.
	* sem-switch.c: Regenerate.
	* sem.c: Regenerate.
@
text
@d5 1
a5 1
Copyright 1996-2009 Free Software Foundation, Inc.
@


1.2
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d5 1
a5 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d9 13
a21 12
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
d2689 1
a2689 1
/* pkrlr1: pkrlr1 $rt,$index,$count */
d2706 1
a2706 1
/* pkrlr30: pkrlr30 $rt,$index,$count */
d2740 1
a2740 1
/* rbr1: rbr1 $rt,$index,$count */
d2757 1
a2757 1
/* rbr30: rbr30 $rt,$index,$count */
d2808 1
a2808 1
/* rxr1: rxr1 $rt,$index,$count */
d2825 1
a2825 1
/* rxr30: rxr30 $rt,$index,$count */
d3029 1
a3029 1
/* wbr1: wbr1 $rt,$index,$count */
d3046 1
a3046 1
/* wbr1u: wbr1u $rt,$index,$count */
d3063 1
a3063 1
/* wbr30: wbr30 $rt,$index,$count */
d3080 1
a3080 1
/* wbr30u: wbr30u $rt,$index,$count */
d3131 1
a3131 1
/* wxr1: wxr1 $rt,$index,$count */
d3148 1
a3148 1
/* wxr1u: wxr1u $rt,$index,$count */
d3165 1
a3165 1
/* wxr30: wxr30 $rt,$index,$count */
d3182 1
a3182 1
/* wxr30u: wxr30u $rt,$index,$count */
@


1.1
log
@	* iq2000: New target subdirectory.
	* configure.ac: Add iq2000 target.
	* configure: Regenerate.
@
text
@d11 2
a12 2
the Free Software Foundation; either version 2, or (at your option)
any later version.
d19 2
a20 3
You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@

