head	1.10;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.10
	gdb_7_6-2013-04-26-release:1.10
	gdb_7_6-branch:1.10.0.2
	gdb_7_6-2013-03-12-branchpoint:1.10
	gdb_7_5_1-2012-11-29-release:1.8
	gdb_7_5-2012-08-17-release:1.8
	gdb_7_5-branch:1.8.0.2
	gdb_7_5-2012-07-18-branchpoint:1.8
	gdb_7_4_1-2012-04-26-release:1.7.8.1
	gdb_7_4-2012-01-24-release:1.7.8.1
	gdb_7_4-branch:1.7.0.8
	gdb_7_4-2011-12-13-branchpoint:1.7
	gdb_7_3_1-2011-09-04-release:1.7
	gdb_7_3-2011-07-26-release:1.7
	gdb_7_3-branch:1.7.0.6
	gdb_7_3-2011-04-01-branchpoint:1.7
	gdb_7_2-2010-09-02-release:1.7
	gdb_7_2-branch:1.7.0.4
	gdb_7_2-2010-07-07-branchpoint:1.7
	gdb_7_1-2010-03-18-release:1.7
	gdb_7_1-branch:1.7.0.2
	gdb_7_1-2010-02-18-branchpoint:1.7
	gdb_7_0_1-2009-12-22-release:1.1
	gdb_7_0-2009-10-06-release:1.1
	gdb_7_0-branch:1.1.0.4
	gdb_7_0-2009-09-16-branchpoint:1.1
	msnyder-checkpoint-072509-branch:1.1.0.2
	msnyder-checkpoint-072509-branchpoint:1.1;
locks; strict;
comment	@ * @;


1.10
date	2013.01.01.06.41.37;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2012.12.19.07.18.18;	author brobecke;	state Exp;
branches;
next	1.8;

1.8
date	2012.01.04.08.28.12;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2010.02.12.02.44.25;	author devans;	state Exp;
branches
	1.7.8.1;
next	1.6;

1.6
date	2010.01.06.05.10.53;	author devans;	state Exp;
branches;
next	1.5;

1.5
date	2010.01.02.19.09.20;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	2009.11.23.09.37.08;	author devans;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.23.04.12.17;	author devans;	state Exp;
branches;
next	1.2;

1.2
date	2009.11.04.05.42.21;	author devans;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.18.13.25.35;	author jbeniston;	state Exp;
branches;
next	;

1.7.8.1
date	2012.01.06.04.54.50;	author brobecke;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* Simulator instruction decoder for lm32bf.

THIS FILE IS MACHINE GENERATED WITH CGEN.

Copyright 1996-2013 Free Software Foundation, Inc.

This file is part of the GNU simulators.

   This file is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License along
   with this program; if not, see <http://www.gnu.org/licenses/>.

*/

#define WANT_CPU lm32bf
#define WANT_CPU_LM32BF

#include "sim-main.h"
#include "sim-assert.h"

/* The instruction descriptor array.
   This is computed at runtime.  Space for it is not malloc'd to save a
   teensy bit of cpu in the decoder.  Moving it to malloc space is trivial
   but won't be done until necessary (we don't currently support the runtime
   addition of instructions nor an SMP machine with different cpus).  */
static IDESC lm32bf_insn_data[LM32BF_INSN__MAX];

/* Commas between elements are contained in the macros.
   Some of these are conditionally compiled out.  */

static const struct insn_sem lm32bf_insn_sem[] =
{
  { VIRTUAL_INSN_X_INVALID, LM32BF_INSN_X_INVALID, LM32BF_SFMT_EMPTY },
  { VIRTUAL_INSN_X_AFTER, LM32BF_INSN_X_AFTER, LM32BF_SFMT_EMPTY },
  { VIRTUAL_INSN_X_BEFORE, LM32BF_INSN_X_BEFORE, LM32BF_SFMT_EMPTY },
  { VIRTUAL_INSN_X_CTI_CHAIN, LM32BF_INSN_X_CTI_CHAIN, LM32BF_SFMT_EMPTY },
  { VIRTUAL_INSN_X_CHAIN, LM32BF_INSN_X_CHAIN, LM32BF_SFMT_EMPTY },
  { VIRTUAL_INSN_X_BEGIN, LM32BF_INSN_X_BEGIN, LM32BF_SFMT_EMPTY },
  { LM32_INSN_ADD, LM32BF_INSN_ADD, LM32BF_SFMT_ADD },
  { LM32_INSN_ADDI, LM32BF_INSN_ADDI, LM32BF_SFMT_ADDI },
  { LM32_INSN_AND, LM32BF_INSN_AND, LM32BF_SFMT_ADD },
  { LM32_INSN_ANDI, LM32BF_INSN_ANDI, LM32BF_SFMT_ANDI },
  { LM32_INSN_ANDHII, LM32BF_INSN_ANDHII, LM32BF_SFMT_ANDHII },
  { LM32_INSN_B, LM32BF_INSN_B, LM32BF_SFMT_B },
  { LM32_INSN_BI, LM32BF_INSN_BI, LM32BF_SFMT_BI },
  { LM32_INSN_BE, LM32BF_INSN_BE, LM32BF_SFMT_BE },
  { LM32_INSN_BG, LM32BF_INSN_BG, LM32BF_SFMT_BE },
  { LM32_INSN_BGE, LM32BF_INSN_BGE, LM32BF_SFMT_BE },
  { LM32_INSN_BGEU, LM32BF_INSN_BGEU, LM32BF_SFMT_BE },
  { LM32_INSN_BGU, LM32BF_INSN_BGU, LM32BF_SFMT_BE },
  { LM32_INSN_BNE, LM32BF_INSN_BNE, LM32BF_SFMT_BE },
  { LM32_INSN_CALL, LM32BF_INSN_CALL, LM32BF_SFMT_CALL },
  { LM32_INSN_CALLI, LM32BF_INSN_CALLI, LM32BF_SFMT_CALLI },
  { LM32_INSN_CMPE, LM32BF_INSN_CMPE, LM32BF_SFMT_ADD },
  { LM32_INSN_CMPEI, LM32BF_INSN_CMPEI, LM32BF_SFMT_ADDI },
  { LM32_INSN_CMPG, LM32BF_INSN_CMPG, LM32BF_SFMT_ADD },
  { LM32_INSN_CMPGI, LM32BF_INSN_CMPGI, LM32BF_SFMT_ADDI },
  { LM32_INSN_CMPGE, LM32BF_INSN_CMPGE, LM32BF_SFMT_ADD },
  { LM32_INSN_CMPGEI, LM32BF_INSN_CMPGEI, LM32BF_SFMT_ADDI },
  { LM32_INSN_CMPGEU, LM32BF_INSN_CMPGEU, LM32BF_SFMT_ADD },
  { LM32_INSN_CMPGEUI, LM32BF_INSN_CMPGEUI, LM32BF_SFMT_ANDI },
  { LM32_INSN_CMPGU, LM32BF_INSN_CMPGU, LM32BF_SFMT_ADD },
  { LM32_INSN_CMPGUI, LM32BF_INSN_CMPGUI, LM32BF_SFMT_ANDI },
  { LM32_INSN_CMPNE, LM32BF_INSN_CMPNE, LM32BF_SFMT_ADD },
  { LM32_INSN_CMPNEI, LM32BF_INSN_CMPNEI, LM32BF_SFMT_ADDI },
  { LM32_INSN_DIVU, LM32BF_INSN_DIVU, LM32BF_SFMT_DIVU },
  { LM32_INSN_LB, LM32BF_INSN_LB, LM32BF_SFMT_LB },
  { LM32_INSN_LBU, LM32BF_INSN_LBU, LM32BF_SFMT_LB },
  { LM32_INSN_LH, LM32BF_INSN_LH, LM32BF_SFMT_LH },
  { LM32_INSN_LHU, LM32BF_INSN_LHU, LM32BF_SFMT_LH },
  { LM32_INSN_LW, LM32BF_INSN_LW, LM32BF_SFMT_LW },
  { LM32_INSN_MODU, LM32BF_INSN_MODU, LM32BF_SFMT_DIVU },
  { LM32_INSN_MUL, LM32BF_INSN_MUL, LM32BF_SFMT_ADD },
  { LM32_INSN_MULI, LM32BF_INSN_MULI, LM32BF_SFMT_ADDI },
  { LM32_INSN_NOR, LM32BF_INSN_NOR, LM32BF_SFMT_ADD },
  { LM32_INSN_NORI, LM32BF_INSN_NORI, LM32BF_SFMT_ANDI },
  { LM32_INSN_OR, LM32BF_INSN_OR, LM32BF_SFMT_ADD },
  { LM32_INSN_ORI, LM32BF_INSN_ORI, LM32BF_SFMT_ORI },
  { LM32_INSN_ORHII, LM32BF_INSN_ORHII, LM32BF_SFMT_ANDHII },
  { LM32_INSN_RCSR, LM32BF_INSN_RCSR, LM32BF_SFMT_RCSR },
  { LM32_INSN_SB, LM32BF_INSN_SB, LM32BF_SFMT_SB },
  { LM32_INSN_SEXTB, LM32BF_INSN_SEXTB, LM32BF_SFMT_SEXTB },
  { LM32_INSN_SEXTH, LM32BF_INSN_SEXTH, LM32BF_SFMT_SEXTB },
  { LM32_INSN_SH, LM32BF_INSN_SH, LM32BF_SFMT_SH },
  { LM32_INSN_SL, LM32BF_INSN_SL, LM32BF_SFMT_ADD },
  { LM32_INSN_SLI, LM32BF_INSN_SLI, LM32BF_SFMT_ADDI },
  { LM32_INSN_SR, LM32BF_INSN_SR, LM32BF_SFMT_ADD },
  { LM32_INSN_SRI, LM32BF_INSN_SRI, LM32BF_SFMT_ADDI },
  { LM32_INSN_SRU, LM32BF_INSN_SRU, LM32BF_SFMT_ADD },
  { LM32_INSN_SRUI, LM32BF_INSN_SRUI, LM32BF_SFMT_ADDI },
  { LM32_INSN_SUB, LM32BF_INSN_SUB, LM32BF_SFMT_ADD },
  { LM32_INSN_SW, LM32BF_INSN_SW, LM32BF_SFMT_SW },
  { LM32_INSN_USER, LM32BF_INSN_USER, LM32BF_SFMT_USER },
  { LM32_INSN_WCSR, LM32BF_INSN_WCSR, LM32BF_SFMT_WCSR },
  { LM32_INSN_XOR, LM32BF_INSN_XOR, LM32BF_SFMT_ADD },
  { LM32_INSN_XORI, LM32BF_INSN_XORI, LM32BF_SFMT_ANDI },
  { LM32_INSN_XNOR, LM32BF_INSN_XNOR, LM32BF_SFMT_ADD },
  { LM32_INSN_XNORI, LM32BF_INSN_XNORI, LM32BF_SFMT_ANDI },
  { LM32_INSN_BREAK, LM32BF_INSN_BREAK, LM32BF_SFMT_BREAK },
  { LM32_INSN_SCALL, LM32BF_INSN_SCALL, LM32BF_SFMT_BREAK },
};

static const struct insn_sem lm32bf_insn_sem_invalid =
{
  VIRTUAL_INSN_X_INVALID, LM32BF_INSN_X_INVALID, LM32BF_SFMT_EMPTY
};

/* Initialize an IDESC from the compile-time computable parts.  */

static INLINE void
init_idesc (SIM_CPU *cpu, IDESC *id, const struct insn_sem *t)
{
  const CGEN_INSN *insn_table = CGEN_CPU_INSN_TABLE (CPU_CPU_DESC (cpu))->init_entries;

  id->num = t->index;
  id->sfmt = t->sfmt;
  if ((int) t->type <= 0)
    id->idata = & cgen_virtual_insn_table[- (int) t->type];
  else
    id->idata = & insn_table[t->type];
  id->attrs = CGEN_INSN_ATTRS (id->idata);
  /* Oh my god, a magic number.  */
  id->length = CGEN_INSN_BITSIZE (id->idata) / 8;

#if WITH_PROFILE_MODEL_P
  id->timing = & MODEL_TIMING (CPU_MODEL (cpu)) [t->index];
  {
    SIM_DESC sd = CPU_STATE (cpu);
    SIM_ASSERT (t->index == id->timing->num);
  }
#endif

  /* Semantic pointers are initialized elsewhere.  */
}

/* Initialize the instruction descriptor table.  */

void
lm32bf_init_idesc_table (SIM_CPU *cpu)
{
  IDESC *id,*tabend;
  const struct insn_sem *t,*tend;
  int tabsize = LM32BF_INSN__MAX;
  IDESC *table = lm32bf_insn_data;

  memset (table, 0, tabsize * sizeof (IDESC));

  /* First set all entries to the `invalid insn'.  */
  t = & lm32bf_insn_sem_invalid;
  for (id = table, tabend = table + tabsize; id < tabend; ++id)
    init_idesc (cpu, id, t);

  /* Now fill in the values for the chosen cpu.  */
  for (t = lm32bf_insn_sem, tend = t + sizeof (lm32bf_insn_sem) / sizeof (*t);
       t != tend; ++t)
    {
      init_idesc (cpu, & table[t->index], t);
    }

  /* Link the IDESC table into the cpu.  */
  CPU_IDESC (cpu) = table;
}

/* Given an instruction, return a pointer to its IDESC entry.  */

const IDESC *
lm32bf_decode (SIM_CPU *current_cpu, IADDR pc,
              CGEN_INSN_WORD base_insn, CGEN_INSN_WORD entire_insn,
              ARGBUF *abuf)
{
  /* Result of decoder.  */
  LM32BF_INSN_TYPE itype;

  {
    CGEN_INSN_WORD insn = base_insn;

    {
      unsigned int val = (((insn >> 26) & (63 << 0)));
      switch (val)
      {
      case 0 : itype = LM32BF_INSN_SRUI; goto extract_sfmt_addi;
      case 1 : itype = LM32BF_INSN_NORI; goto extract_sfmt_andi;
      case 2 : itype = LM32BF_INSN_MULI; goto extract_sfmt_addi;
      case 3 : itype = LM32BF_INSN_SH; goto extract_sfmt_sh;
      case 4 : itype = LM32BF_INSN_LB; goto extract_sfmt_lb;
      case 5 : itype = LM32BF_INSN_SRI; goto extract_sfmt_addi;
      case 6 : itype = LM32BF_INSN_XORI; goto extract_sfmt_andi;
      case 7 : itype = LM32BF_INSN_LH; goto extract_sfmt_lh;
      case 8 : itype = LM32BF_INSN_ANDI; goto extract_sfmt_andi;
      case 9 : itype = LM32BF_INSN_XNORI; goto extract_sfmt_andi;
      case 10 : itype = LM32BF_INSN_LW; goto extract_sfmt_lw;
      case 11 : itype = LM32BF_INSN_LHU; goto extract_sfmt_lh;
      case 12 : itype = LM32BF_INSN_SB; goto extract_sfmt_sb;
      case 13 : itype = LM32BF_INSN_ADDI; goto extract_sfmt_addi;
      case 14 : itype = LM32BF_INSN_ORI; goto extract_sfmt_ori;
      case 15 : itype = LM32BF_INSN_SLI; goto extract_sfmt_addi;
      case 16 : itype = LM32BF_INSN_LBU; goto extract_sfmt_lb;
      case 17 : itype = LM32BF_INSN_BE; goto extract_sfmt_be;
      case 18 : itype = LM32BF_INSN_BG; goto extract_sfmt_be;
      case 19 : itype = LM32BF_INSN_BGE; goto extract_sfmt_be;
      case 20 : itype = LM32BF_INSN_BGEU; goto extract_sfmt_be;
      case 21 : itype = LM32BF_INSN_BGU; goto extract_sfmt_be;
      case 22 : itype = LM32BF_INSN_SW; goto extract_sfmt_sw;
      case 23 : itype = LM32BF_INSN_BNE; goto extract_sfmt_be;
      case 24 : itype = LM32BF_INSN_ANDHII; goto extract_sfmt_andhii;
      case 25 : itype = LM32BF_INSN_CMPEI; goto extract_sfmt_addi;
      case 26 : itype = LM32BF_INSN_CMPGI; goto extract_sfmt_addi;
      case 27 : itype = LM32BF_INSN_CMPGEI; goto extract_sfmt_addi;
      case 28 : itype = LM32BF_INSN_CMPGEUI; goto extract_sfmt_andi;
      case 29 : itype = LM32BF_INSN_CMPGUI; goto extract_sfmt_andi;
      case 30 : itype = LM32BF_INSN_ORHII; goto extract_sfmt_andhii;
      case 31 : itype = LM32BF_INSN_CMPNEI; goto extract_sfmt_addi;
      case 32 :
        if ((entire_insn & 0xfc0007ff) == 0x80000000)
          { itype = LM32BF_INSN_SRU; goto extract_sfmt_add; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 33 :
        if ((entire_insn & 0xfc0007ff) == 0x84000000)
          { itype = LM32BF_INSN_NOR; goto extract_sfmt_add; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 34 :
        if ((entire_insn & 0xfc0007ff) == 0x88000000)
          { itype = LM32BF_INSN_MUL; goto extract_sfmt_add; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 35 :
        if ((entire_insn & 0xfc0007ff) == 0x8c000000)
          { itype = LM32BF_INSN_DIVU; goto extract_sfmt_divu; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 36 :
        if ((entire_insn & 0xfc1f07ff) == 0x90000000)
          { itype = LM32BF_INSN_RCSR; goto extract_sfmt_rcsr; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 37 :
        if ((entire_insn & 0xfc0007ff) == 0x94000000)
          { itype = LM32BF_INSN_SR; goto extract_sfmt_add; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 38 :
        if ((entire_insn & 0xfc0007ff) == 0x98000000)
          { itype = LM32BF_INSN_XOR; goto extract_sfmt_add; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 40 :
        if ((entire_insn & 0xfc0007ff) == 0xa0000000)
          { itype = LM32BF_INSN_AND; goto extract_sfmt_add; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 41 :
        if ((entire_insn & 0xfc0007ff) == 0xa4000000)
          { itype = LM32BF_INSN_XNOR; goto extract_sfmt_add; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 43 :
        {
          unsigned int val = (((insn >> 1) & (1 << 1)) | ((insn >> 0) & (1 << 0)));
          switch (val)
          {
          case 0 :
            if ((entire_insn & 0xffffffff) == 0xac000002)
              { itype = LM32BF_INSN_BREAK; goto extract_sfmt_break; }
            itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
          case 3 :
            if ((entire_insn & 0xffffffff) == 0xac000007)
              { itype = LM32BF_INSN_SCALL; goto extract_sfmt_break; }
            itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
          default : itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
          }
        }
      case 44 :
        if ((entire_insn & 0xfc1f07ff) == 0xb0000000)
          { itype = LM32BF_INSN_SEXTB; goto extract_sfmt_sextb; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 45 :
        if ((entire_insn & 0xfc0007ff) == 0xb4000000)
          { itype = LM32BF_INSN_ADD; goto extract_sfmt_add; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 46 :
        if ((entire_insn & 0xfc0007ff) == 0xb8000000)
          { itype = LM32BF_INSN_OR; goto extract_sfmt_add; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 47 :
        if ((entire_insn & 0xfc0007ff) == 0xbc000000)
          { itype = LM32BF_INSN_SL; goto extract_sfmt_add; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 48 :
        if ((entire_insn & 0xfc1fffff) == 0xc0000000)
          { itype = LM32BF_INSN_B; goto extract_sfmt_b; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 49 :
        if ((entire_insn & 0xfc0007ff) == 0xc4000000)
          { itype = LM32BF_INSN_MODU; goto extract_sfmt_divu; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 50 :
        if ((entire_insn & 0xfc0007ff) == 0xc8000000)
          { itype = LM32BF_INSN_SUB; goto extract_sfmt_add; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 51 : itype = LM32BF_INSN_USER; goto extract_sfmt_user;
      case 52 :
        if ((entire_insn & 0xfc00ffff) == 0xd0000000)
          { itype = LM32BF_INSN_WCSR; goto extract_sfmt_wcsr; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 54 :
        if ((entire_insn & 0xfc1fffff) == 0xd8000000)
          { itype = LM32BF_INSN_CALL; goto extract_sfmt_call; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 55 :
        if ((entire_insn & 0xfc1f07ff) == 0xdc000000)
          { itype = LM32BF_INSN_SEXTH; goto extract_sfmt_sextb; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 56 : itype = LM32BF_INSN_BI; goto extract_sfmt_bi;
      case 57 :
        if ((entire_insn & 0xfc0007ff) == 0xe4000000)
          { itype = LM32BF_INSN_CMPE; goto extract_sfmt_add; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 58 :
        if ((entire_insn & 0xfc0007ff) == 0xe8000000)
          { itype = LM32BF_INSN_CMPG; goto extract_sfmt_add; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 59 :
        if ((entire_insn & 0xfc0007ff) == 0xec000000)
          { itype = LM32BF_INSN_CMPGE; goto extract_sfmt_add; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 60 :
        if ((entire_insn & 0xfc0007ff) == 0xf0000000)
          { itype = LM32BF_INSN_CMPGEU; goto extract_sfmt_add; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 61 :
        if ((entire_insn & 0xfc0007ff) == 0xf4000000)
          { itype = LM32BF_INSN_CMPGU; goto extract_sfmt_add; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 62 : itype = LM32BF_INSN_CALLI; goto extract_sfmt_calli;
      case 63 :
        if ((entire_insn & 0xfc0007ff) == 0xfc000000)
          { itype = LM32BF_INSN_CMPNE; goto extract_sfmt_add; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      default : itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      }
    }
  }

  /* The instruction has been decoded, now extract the fields.  */

 extract_sfmt_empty:
  {
    const IDESC *idesc = &lm32bf_insn_data[itype];
#define FLD(f) abuf->fields.sfmt_empty.f


  /* Record the fields for the semantic handler.  */
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_empty", (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_add:
  {
    const IDESC *idesc = &lm32bf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_user.f
    UINT f_r0;
    UINT f_r1;
    UINT f_r2;

    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
    f_r2 = EXTRACT_LSB0_UINT (insn, 32, 15, 5);

  /* Record the fields for the semantic handler.  */
  FLD (f_r0) = f_r0;
  FLD (f_r1) = f_r1;
  FLD (f_r2) = f_r2;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_add", "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, "f_r2 0x%x", 'x', f_r2, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_addi:
  {
    const IDESC *idesc = &lm32bf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_addi.f
    UINT f_r0;
    UINT f_r1;
    INT f_imm;

    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
    f_imm = EXTRACT_LSB0_SINT (insn, 32, 15, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_imm) = f_imm;
  FLD (f_r0) = f_r0;
  FLD (f_r1) = f_r1;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_addi", "f_imm 0x%x", 'x', f_imm, "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_andi:
  {
    const IDESC *idesc = &lm32bf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_andi.f
    UINT f_r0;
    UINT f_r1;
    UINT f_uimm;

    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
    f_uimm = EXTRACT_LSB0_UINT (insn, 32, 15, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_r0) = f_r0;
  FLD (f_uimm) = f_uimm;
  FLD (f_r1) = f_r1;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_andi", "f_r0 0x%x", 'x', f_r0, "f_uimm 0x%x", 'x', f_uimm, "f_r1 0x%x", 'x', f_r1, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_andhii:
  {
    const IDESC *idesc = &lm32bf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_andi.f
    UINT f_r0;
    UINT f_r1;
    UINT f_uimm;

    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
    f_uimm = EXTRACT_LSB0_UINT (insn, 32, 15, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_uimm) = f_uimm;
  FLD (f_r0) = f_r0;
  FLD (f_r1) = f_r1;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_andhii", "f_uimm 0x%x", 'x', f_uimm, "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_b:
  {
    const IDESC *idesc = &lm32bf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_be.f
    UINT f_r0;

    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);

  /* Record the fields for the semantic handler.  */
  FLD (f_r0) = f_r0;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_b", "f_r0 0x%x", 'x', f_r0, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_bi:
  {
    const IDESC *idesc = &lm32bf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_bi.f
    SI f_call;

    f_call = ((pc) + (((SI) (((EXTRACT_LSB0_SINT (insn, 32, 25, 26)) << (6))) >> (4))));

  /* Record the fields for the semantic handler.  */
  FLD (i_call) = f_call;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_bi", "call 0x%x", 'x', f_call, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_be:
  {
    const IDESC *idesc = &lm32bf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_be.f
    UINT f_r0;
    UINT f_r1;
    SI f_branch;

    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
    f_branch = ((pc) + (((SI) (((EXTRACT_LSB0_SINT (insn, 32, 15, 16)) << (16))) >> (14))));

  /* Record the fields for the semantic handler.  */
  FLD (f_r0) = f_r0;
  FLD (f_r1) = f_r1;
  FLD (i_branch) = f_branch;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_be", "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, "branch 0x%x", 'x', f_branch, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_call:
  {
    const IDESC *idesc = &lm32bf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_be.f
    UINT f_r0;

    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);

  /* Record the fields for the semantic handler.  */
  FLD (f_r0) = f_r0;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_call", "f_r0 0x%x", 'x', f_r0, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_calli:
  {
    const IDESC *idesc = &lm32bf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_bi.f
    SI f_call;

    f_call = ((pc) + (((SI) (((EXTRACT_LSB0_SINT (insn, 32, 25, 26)) << (6))) >> (4))));

  /* Record the fields for the semantic handler.  */
  FLD (i_call) = f_call;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_calli", "call 0x%x", 'x', f_call, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_divu:
  {
    const IDESC *idesc = &lm32bf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_user.f
    UINT f_r0;
    UINT f_r1;
    UINT f_r2;

    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
    f_r2 = EXTRACT_LSB0_UINT (insn, 32, 15, 5);

  /* Record the fields for the semantic handler.  */
  FLD (f_r0) = f_r0;
  FLD (f_r1) = f_r1;
  FLD (f_r2) = f_r2;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_divu", "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, "f_r2 0x%x", 'x', f_r2, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_lb:
  {
    const IDESC *idesc = &lm32bf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_addi.f
    UINT f_r0;
    UINT f_r1;
    INT f_imm;

    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
    f_imm = EXTRACT_LSB0_SINT (insn, 32, 15, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_imm) = f_imm;
  FLD (f_r0) = f_r0;
  FLD (f_r1) = f_r1;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_lb", "f_imm 0x%x", 'x', f_imm, "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_lh:
  {
    const IDESC *idesc = &lm32bf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_addi.f
    UINT f_r0;
    UINT f_r1;
    INT f_imm;

    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
    f_imm = EXTRACT_LSB0_SINT (insn, 32, 15, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_imm) = f_imm;
  FLD (f_r0) = f_r0;
  FLD (f_r1) = f_r1;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_lh", "f_imm 0x%x", 'x', f_imm, "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_lw:
  {
    const IDESC *idesc = &lm32bf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_addi.f
    UINT f_r0;
    UINT f_r1;
    INT f_imm;

    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
    f_imm = EXTRACT_LSB0_SINT (insn, 32, 15, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_imm) = f_imm;
  FLD (f_r0) = f_r0;
  FLD (f_r1) = f_r1;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_lw", "f_imm 0x%x", 'x', f_imm, "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_ori:
  {
    const IDESC *idesc = &lm32bf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_andi.f
    UINT f_r0;
    UINT f_r1;
    UINT f_uimm;

    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
    f_uimm = EXTRACT_LSB0_UINT (insn, 32, 15, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_uimm) = f_uimm;
  FLD (f_r0) = f_r0;
  FLD (f_r1) = f_r1;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_ori", "f_uimm 0x%x", 'x', f_uimm, "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_rcsr:
  {
    const IDESC *idesc = &lm32bf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_rcsr.f
    UINT f_csr;
    UINT f_r2;

    f_csr = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
    f_r2 = EXTRACT_LSB0_UINT (insn, 32, 15, 5);

  /* Record the fields for the semantic handler.  */
  FLD (f_csr) = f_csr;
  FLD (f_r2) = f_r2;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_rcsr", "f_csr 0x%x", 'x', f_csr, "f_r2 0x%x", 'x', f_r2, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_sb:
  {
    const IDESC *idesc = &lm32bf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_addi.f
    UINT f_r0;
    UINT f_r1;
    INT f_imm;

    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
    f_imm = EXTRACT_LSB0_SINT (insn, 32, 15, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_imm) = f_imm;
  FLD (f_r0) = f_r0;
  FLD (f_r1) = f_r1;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_sb", "f_imm 0x%x", 'x', f_imm, "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_sextb:
  {
    const IDESC *idesc = &lm32bf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_user.f
    UINT f_r0;
    UINT f_r2;

    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
    f_r2 = EXTRACT_LSB0_UINT (insn, 32, 15, 5);

  /* Record the fields for the semantic handler.  */
  FLD (f_r0) = f_r0;
  FLD (f_r2) = f_r2;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_sextb", "f_r0 0x%x", 'x', f_r0, "f_r2 0x%x", 'x', f_r2, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_sh:
  {
    const IDESC *idesc = &lm32bf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_addi.f
    UINT f_r0;
    UINT f_r1;
    INT f_imm;

    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
    f_imm = EXTRACT_LSB0_SINT (insn, 32, 15, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_imm) = f_imm;
  FLD (f_r0) = f_r0;
  FLD (f_r1) = f_r1;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_sh", "f_imm 0x%x", 'x', f_imm, "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_sw:
  {
    const IDESC *idesc = &lm32bf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_addi.f
    UINT f_r0;
    UINT f_r1;
    INT f_imm;

    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
    f_imm = EXTRACT_LSB0_SINT (insn, 32, 15, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_imm) = f_imm;
  FLD (f_r0) = f_r0;
  FLD (f_r1) = f_r1;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_sw", "f_imm 0x%x", 'x', f_imm, "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_user:
  {
    const IDESC *idesc = &lm32bf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_user.f
    UINT f_r0;
    UINT f_r1;
    UINT f_r2;
    UINT f_user;

    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
    f_r2 = EXTRACT_LSB0_UINT (insn, 32, 15, 5);
    f_user = EXTRACT_LSB0_UINT (insn, 32, 10, 11);

  /* Record the fields for the semantic handler.  */
  FLD (f_r0) = f_r0;
  FLD (f_r1) = f_r1;
  FLD (f_user) = f_user;
  FLD (f_r2) = f_r2;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_user", "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, "f_user 0x%x", 'x', f_user, "f_r2 0x%x", 'x', f_r2, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_wcsr:
  {
    const IDESC *idesc = &lm32bf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_wcsr.f
    UINT f_csr;
    UINT f_r1;

    f_csr = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);

  /* Record the fields for the semantic handler.  */
  FLD (f_csr) = f_csr;
  FLD (f_r1) = f_r1;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_wcsr", "f_csr 0x%x", 'x', f_csr, "f_r1 0x%x", 'x', f_r1, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_break:
  {
    const IDESC *idesc = &lm32bf_insn_data[itype];
#define FLD(f) abuf->fields.sfmt_empty.f


  /* Record the fields for the semantic handler.  */
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_break", (char *) 0));

#undef FLD
    return idesc;
  }

}
@


1.9
log
@[sim] Update old contact info in GPL license notices

sim/ChangeLog:

        Update old contact info in GPL license notices.
@
text
@d5 1
a5 1
Copyright 1996-2010, 2012 Free Software Foundation, Inc.
@


1.8
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d20 1
a20 2
   with this program; if not, write to the Free Software Foundation, Inc.,
   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
@


1.7
log
@Regenerate cgen-derived files.
@
text
@d5 1
a5 1
Copyright 1996-2010 Free Software Foundation, Inc.
@


1.7.8.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d5 1
a5 1
Copyright 1996-2010, 2012 Free Software Foundation, Inc.
@


1.6
log
@	* cpu.h: Regenerate.
	* decode.c: Regenerate.
@
text
@d113 2
a114 1
static const struct insn_sem lm32bf_insn_sem_invalid = {
d352 1
a352 1
#define FLD(f) abuf->fields.fmt_empty.f
d818 1
a818 1
#define FLD(f) abuf->fields.fmt_empty.f
@


1.5
log
@Regenerate cgen files, update copyright year.
@
text
@d477 1
a477 1
    f_call = ((pc) + (((int) (((EXTRACT_LSB0_SINT (insn, 32, 25, 26)) << (6))) >> (4))));
d498 1
a498 1
    f_branch = ((pc) + (((int) (((EXTRACT_LSB0_SINT (insn, 32, 15, 16)) << (16))) >> (14))));
d534 1
a534 1
    f_call = ((pc) + (((int) (((EXTRACT_LSB0_SINT (insn, 32, 25, 26)) << (6))) >> (4))));
@


1.4
log
@	* cgen-engine.h (EXTRACT_MSB0_SINT): Renamed from EXTRACT_MSB0_INT.
	(EXTRACT_LSB0_SINT): Renamed from EXTRACT_LSB0_INT.
plus regenerate cgen files
@
text
@d5 1
a5 1
Copyright 1996-2009 Free Software Foundation, Inc.
@


1.3
log
@	* cgen-engine.h (EXTRACT_MSB0_LGSINT, EXTRACT_MSB0_LGUINT): Define.
	(EXTRACT_LSB0_LGSINT, EXTRACT_LSB0_LGUINT): Define.
	(EXTRACT_FN, SEMANTIC_FN): Use CGEN_INSN_WORD in prototype
	instead of CGEN_INSN_INT.
plus, cgen files: Regenerate.
@
text
@d395 1
a395 1
    f_imm = EXTRACT_LSB0_INT (insn, 32, 15, 16);
d477 1
a477 1
    f_call = ((pc) + (((int) (((EXTRACT_LSB0_INT (insn, 32, 25, 26)) << (6))) >> (4))));
d498 1
a498 1
    f_branch = ((pc) + (((int) (((EXTRACT_LSB0_INT (insn, 32, 15, 16)) << (16))) >> (14))));
d534 1
a534 1
    f_call = ((pc) + (((int) (((EXTRACT_LSB0_INT (insn, 32, 25, 26)) << (6))) >> (4))));
d578 1
a578 1
    f_imm = EXTRACT_LSB0_INT (insn, 32, 15, 16);
d601 1
a601 1
    f_imm = EXTRACT_LSB0_INT (insn, 32, 15, 16);
d624 1
a624 1
    f_imm = EXTRACT_LSB0_INT (insn, 32, 15, 16);
d690 1
a690 1
    f_imm = EXTRACT_LSB0_INT (insn, 32, 15, 16);
d733 1
a733 1
    f_imm = EXTRACT_LSB0_INT (insn, 32, 15, 16);
d756 1
a756 1
    f_imm = EXTRACT_LSB0_INT (insn, 32, 15, 16);
@


1.2
log
@	* arch.c: Regenerate.
	* arch.h: Regenerate.
	* cpu.c: Regenerate.
	* cpu.h: Regenerate.
	* cpuall.h: Regenerate.
	* decode.c: Regenerate.
	* decode.h: Regenerate.
	* model.c: Regenerate.
	* sem-switch.c: Regenerate.
	* sem.c: Regenerate.
@
text
@d177 1
a177 1
              CGEN_INSN_INT base_insn, CGEN_INSN_INT entire_insn,
d184 1
a184 1
    CGEN_INSN_INT insn = base_insn;
d364 1
a364 1
    CGEN_INSN_INT insn = entire_insn;
d387 1
a387 1
    CGEN_INSN_INT insn = entire_insn;
d410 1
a410 1
    CGEN_INSN_INT insn = entire_insn;
d433 1
a433 1
    CGEN_INSN_INT insn = entire_insn;
d456 1
a456 1
    CGEN_INSN_INT insn = entire_insn;
d473 1
a473 1
    CGEN_INSN_INT insn = entire_insn;
d490 1
a490 1
    CGEN_INSN_INT insn = entire_insn;
d513 1
a513 1
    CGEN_INSN_INT insn = entire_insn;
d530 1
a530 1
    CGEN_INSN_INT insn = entire_insn;
d547 1
a547 1
    CGEN_INSN_INT insn = entire_insn;
d570 1
a570 1
    CGEN_INSN_INT insn = entire_insn;
d593 1
a593 1
    CGEN_INSN_INT insn = entire_insn;
d616 1
a616 1
    CGEN_INSN_INT insn = entire_insn;
d639 1
a639 1
    CGEN_INSN_INT insn = entire_insn;
d662 1
a662 1
    CGEN_INSN_INT insn = entire_insn;
d682 1
a682 1
    CGEN_INSN_INT insn = entire_insn;
d705 1
a705 1
    CGEN_INSN_INT insn = entire_insn;
d725 1
a725 1
    CGEN_INSN_INT insn = entire_insn;
d748 1
a748 1
    CGEN_INSN_INT insn = entire_insn;
d771 1
a771 1
    CGEN_INSN_INT insn = entire_insn;
d797 1
a797 1
    CGEN_INSN_INT insn = entire_insn;
@


1.1
log
@gdb/
2009-05-18  Jon Beniston <jon@@beniston.com>

        * MAINTAINERS: Add lm32 target.
        * Makefile.in: Add lm32 dependencies.
        * NEWS: Indicate lm32 is a new target.
        * configure.tgt: Add lm32 targets.
        * lm32-tdep.c: New file.

gdb/testsuite
2009-05-18  Jon Beniston <jon@@beniston.com>

        * gdb.asm/asm-source.exp: Add lm32 target.

include/gdb/
2009-05-18  Jon Beniston <jon@@beniston.com>

        * sim-lm32.h: New file.

sim/
2009-05-18  Jon Beniston <jon@@beniston.com>

        * MAINTAINERS: Add Jon Beniston as maintainer of lm32 sim.
        * configure.ac: Add lm32 target.
        * lm32: New directory.

sim/common
2009-05-18  Jon Beniston <jon@@beniston.com>

        * gennltvals.sh: Add lm32 target.
        * nltvals.def: Add lm32 syscall definitions.

sim/lm32/
2009-05-18  Jon Beniston <jon@@beniston.com>

        * Makefile.in: New file.
        * arch.c: New file.
        * arch.h: New file.
        * config.in: New file.
        * configure: New file.
        * configure.ac: New file.
        * cpu.c: New file.
        * cpu.h: New file.
        * cpuall.h: New file.
        * decode.c: New file.
        * decode.h: New file.
        * dv-lm32cpu.c: New file.
        * dv-lm32timer.c: New file.
        * dv-lm32uart.c: New file.
        * lm32.c: New file.
        * lm32-sim.h: New file.
        * mloop.in: New file.
        * model.c: New file.
        * sem.c: New file.
        * sem-switch.c: New file.
        * sim-if.c: New file.
        * sim-main.c: New file.
        * tconfig.in: New file.
        * traps.c: New file.
        * user.c: New file.
@
text
@d5 1
a5 1
Copyright 1996-2005 Free Software Foundation, Inc.
d9 13
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
d95 1
a95 1
  { LM32_INSN_SL, LM32BF_INSN_SL, LM32BF_SFMT_SL },
d97 1
a97 1
  { LM32_INSN_SR, LM32BF_INSN_SR, LM32BF_SFMT_SL },
d99 1
a99 1
  { LM32_INSN_SRU, LM32BF_INSN_SRU, LM32BF_SFMT_SL },
d190 32
a221 128
      case 0 :
        if ((entire_insn & 0xfc000000) == 0x0)
          { itype = LM32BF_INSN_SRUI; goto extract_sfmt_addi; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 1 :
        if ((entire_insn & 0xfc000000) == 0x4000000)
          { itype = LM32BF_INSN_NORI; goto extract_sfmt_andi; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 2 :
        if ((entire_insn & 0xfc000000) == 0x8000000)
          { itype = LM32BF_INSN_MULI; goto extract_sfmt_addi; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 3 :
        if ((entire_insn & 0xfc000000) == 0xc000000)
          { itype = LM32BF_INSN_SH; goto extract_sfmt_sh; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 4 :
        if ((entire_insn & 0xfc000000) == 0x10000000)
          { itype = LM32BF_INSN_LB; goto extract_sfmt_lb; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 5 :
        if ((entire_insn & 0xfc000000) == 0x14000000)
          { itype = LM32BF_INSN_SRI; goto extract_sfmt_addi; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 6 :
        if ((entire_insn & 0xfc000000) == 0x18000000)
          { itype = LM32BF_INSN_XORI; goto extract_sfmt_andi; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 7 :
        if ((entire_insn & 0xfc000000) == 0x1c000000)
          { itype = LM32BF_INSN_LH; goto extract_sfmt_lh; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 8 :
        if ((entire_insn & 0xfc000000) == 0x20000000)
          { itype = LM32BF_INSN_ANDI; goto extract_sfmt_andi; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 9 :
        if ((entire_insn & 0xfc000000) == 0x24000000)
          { itype = LM32BF_INSN_XNORI; goto extract_sfmt_andi; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 10 :
        if ((entire_insn & 0xfc000000) == 0x28000000)
          { itype = LM32BF_INSN_LW; goto extract_sfmt_lw; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 11 :
        if ((entire_insn & 0xfc000000) == 0x2c000000)
          { itype = LM32BF_INSN_LHU; goto extract_sfmt_lh; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 12 :
        if ((entire_insn & 0xfc000000) == 0x30000000)
          { itype = LM32BF_INSN_SB; goto extract_sfmt_sb; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 13 :
        if ((entire_insn & 0xfc000000) == 0x34000000)
          { itype = LM32BF_INSN_ADDI; goto extract_sfmt_addi; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 14 :
        if ((entire_insn & 0xfc000000) == 0x38000000)
          { itype = LM32BF_INSN_ORI; goto extract_sfmt_ori; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 15 :
        if ((entire_insn & 0xfc000000) == 0x3c000000)
          { itype = LM32BF_INSN_SLI; goto extract_sfmt_addi; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 16 :
        if ((entire_insn & 0xfc000000) == 0x40000000)
          { itype = LM32BF_INSN_LBU; goto extract_sfmt_lb; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 17 :
        if ((entire_insn & 0xfc000000) == 0x44000000)
          { itype = LM32BF_INSN_BE; goto extract_sfmt_be; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 18 :
        if ((entire_insn & 0xfc000000) == 0x48000000)
          { itype = LM32BF_INSN_BG; goto extract_sfmt_be; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 19 :
        if ((entire_insn & 0xfc000000) == 0x4c000000)
          { itype = LM32BF_INSN_BGE; goto extract_sfmt_be; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 20 :
        if ((entire_insn & 0xfc000000) == 0x50000000)
          { itype = LM32BF_INSN_BGEU; goto extract_sfmt_be; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 21 :
        if ((entire_insn & 0xfc000000) == 0x54000000)
          { itype = LM32BF_INSN_BGU; goto extract_sfmt_be; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 22 :
        if ((entire_insn & 0xfc000000) == 0x58000000)
          { itype = LM32BF_INSN_SW; goto extract_sfmt_sw; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 23 :
        if ((entire_insn & 0xfc000000) == 0x5c000000)
          { itype = LM32BF_INSN_BNE; goto extract_sfmt_be; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 24 :
        if ((entire_insn & 0xfc000000) == 0x60000000)
          { itype = LM32BF_INSN_ANDHII; goto extract_sfmt_andhii; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 25 :
        if ((entire_insn & 0xfc000000) == 0x64000000)
          { itype = LM32BF_INSN_CMPEI; goto extract_sfmt_addi; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 26 :
        if ((entire_insn & 0xfc000000) == 0x68000000)
          { itype = LM32BF_INSN_CMPGI; goto extract_sfmt_addi; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 27 :
        if ((entire_insn & 0xfc000000) == 0x6c000000)
          { itype = LM32BF_INSN_CMPGEI; goto extract_sfmt_addi; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 28 :
        if ((entire_insn & 0xfc000000) == 0x70000000)
          { itype = LM32BF_INSN_CMPGEUI; goto extract_sfmt_andi; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 29 :
        if ((entire_insn & 0xfc000000) == 0x74000000)
          { itype = LM32BF_INSN_CMPGUI; goto extract_sfmt_andi; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 30 :
        if ((entire_insn & 0xfc000000) == 0x78000000)
          { itype = LM32BF_INSN_ORHII; goto extract_sfmt_andhii; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 31 :
        if ((entire_insn & 0xfc000000) == 0x7c000000)
          { itype = LM32BF_INSN_CMPNEI; goto extract_sfmt_addi; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
d224 1
a224 1
          { itype = LM32BF_INSN_SRU; goto extract_sfmt_sl; }
d244 1
a244 1
          { itype = LM32BF_INSN_SR; goto extract_sfmt_sl; }
d288 1
a288 1
          { itype = LM32BF_INSN_SL; goto extract_sfmt_sl; }
d302 1
a302 4
      case 51 :
        if ((entire_insn & 0xfc000000) == 0xcc000000)
          { itype = LM32BF_INSN_USER; goto extract_sfmt_user; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
d315 1
a315 4
      case 56 :
        if ((entire_insn & 0xfc000000) == 0xe0000000)
          { itype = LM32BF_INSN_BI; goto extract_sfmt_bi; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
d336 1
a336 4
      case 62 :
        if ((entire_insn & 0xfc000000) == 0xf8000000)
          { itype = LM32BF_INSN_CALLI; goto extract_sfmt_calli; }
        itype = LM32BF_INSN_X_INVALID; goto extract_sfmt_empty;
a744 23
 extract_sfmt_sl:
  {
    const IDESC *idesc = &lm32bf_insn_data[itype];
    CGEN_INSN_INT insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_user.f
    UINT f_r0;
    UINT f_r1;
    UINT f_r2;

    f_r0 = EXTRACT_LSB0_UINT (insn, 32, 25, 5);
    f_r1 = EXTRACT_LSB0_UINT (insn, 32, 20, 5);
    f_r2 = EXTRACT_LSB0_UINT (insn, 32, 15, 5);

  /* Record the fields for the semantic handler.  */
  FLD (f_r0) = f_r0;
  FLD (f_r1) = f_r1;
  FLD (f_r2) = f_r2;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_sl", "f_r0 0x%x", 'x', f_r0, "f_r1 0x%x", 'x', f_r1, "f_r2 0x%x", 'x', f_r2, (char *) 0));

#undef FLD
    return idesc;
  }

@

