head	1.1;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.1
	gdb_7_6-2013-04-26-release:1.1
	gdb_7_6-branch:1.1.0.54
	gdb_7_6-2013-03-12-branchpoint:1.1
	gdb_7_5_1-2012-11-29-release:1.1
	gdb_7_5-2012-08-17-release:1.1
	gdb_7_5-branch:1.1.0.52
	gdb_7_5-2012-07-18-branchpoint:1.1
	gdb_7_4_1-2012-04-26-release:1.1
	gdb_7_4-2012-01-24-release:1.1
	gdb_7_4-branch:1.1.0.50
	gdb_7_4-2011-12-13-branchpoint:1.1
	gdb_7_3_1-2011-09-04-release:1.1
	gdb_7_3-2011-07-26-release:1.1
	gdb_7_3-branch:1.1.0.48
	gdb_7_3-2011-04-01-branchpoint:1.1
	gdb_7_2-2010-09-02-release:1.1
	gdb_7_2-branch:1.1.0.46
	gdb_7_2-2010-07-07-branchpoint:1.1
	gdb_7_1-2010-03-18-release:1.1
	gdb_7_1-branch:1.1.0.44
	gdb_7_1-2010-02-18-branchpoint:1.1
	gdb_7_0_1-2009-12-22-release:1.1
	gdb_7_0-2009-10-06-release:1.1
	gdb_7_0-branch:1.1.0.42
	gdb_7_0-2009-09-16-branchpoint:1.1
	arc-sim-20090309:1.1
	msnyder-checkpoint-072509-branch:1.1.0.40
	msnyder-checkpoint-072509-branchpoint:1.1
	arc-insight_6_8-branch:1.1.0.38
	arc-insight_6_8-branchpoint:1.1
	insight_6_8-branch:1.1.0.36
	insight_6_8-branchpoint:1.1
	reverse-20081226-branch:1.1.0.34
	reverse-20081226-branchpoint:1.1
	multiprocess-20081120-branch:1.1.0.32
	multiprocess-20081120-branchpoint:1.1
	reverse-20080930-branch:1.1.0.30
	reverse-20080930-branchpoint:1.1
	reverse-20080717-branch:1.1.0.28
	reverse-20080717-branchpoint:1.1
	msnyder-reverse-20080609-branch:1.1.0.26
	msnyder-reverse-20080609-branchpoint:1.1
	drow-reverse-20070409-branch:1.1.0.24
	drow-reverse-20070409-branchpoint:1.1
	gdb_6_8-2008-03-27-release:1.1
	gdb_6_8-branch:1.1.0.22
	gdb_6_8-2008-02-26-branchpoint:1.1
	gdb_6_7_1-2007-10-29-release:1.1
	gdb_6_7-2007-10-10-release:1.1
	gdb_6_7-branch:1.1.0.20
	gdb_6_7-2007-09-07-branchpoint:1.1
	insight_6_6-20070208-release:1.1
	gdb_6_6-2006-12-18-release:1.1
	gdb_6_6-branch:1.1.0.18
	gdb_6_6-2006-11-15-branchpoint:1.1
	insight_6_5-20061003-release:1.1
	gdb-csl-symbian-6_4_50_20060226-12:1.1
	nickrob-async-20060828-mergepoint:1.1
	gdb-csl-symbian-6_4_50_20060226-11:1.1
	gdb-csl-sourcerygxx-4_1-17:1.1
	gdb-csl-20060226-branch-local-2:1.1
	gdb-csl-sourcerygxx-4_1-14:1.1
	gdb-csl-sourcerygxx-4_1-13:1.1
	gdb-csl-sourcerygxx-4_1-12:1.1
	gdb-csl-sourcerygxx-3_4_4-21:1.1
	gdb_6_5-20060621-release:1.1
	gdb-csl-sourcerygxx-4_1-9:1.1
	gdb-csl-sourcerygxx-4_1-8:1.1
	gdb-csl-sourcerygxx-4_1-7:1.1
	gdb-csl-arm-2006q1-6:1.1
	gdb-csl-sourcerygxx-4_1-6:1.1
	gdb-csl-symbian-6_4_50_20060226-10:1.1
	gdb-csl-symbian-6_4_50_20060226-9:1.1
	gdb-csl-symbian-6_4_50_20060226-8:1.1
	gdb-csl-coldfire-4_1-11:1.1
	gdb-csl-sourcerygxx-3_4_4-19:1.1
	gdb-csl-coldfire-4_1-10:1.1
	gdb_6_5-branch:1.1.0.16
	gdb_6_5-2006-05-14-branchpoint:1.1
	gdb-csl-sourcerygxx-4_1-5:1.1
	nickrob-async-20060513-branch:1.1.0.14
	nickrob-async-20060513-branchpoint:1.1
	gdb-csl-sourcerygxx-4_1-4:1.1
	msnyder-reverse-20060502-branch:1.1.0.12
	msnyder-reverse-20060502-branchpoint:1.1
	gdb-csl-morpho-4_1-4:1.1
	gdb-csl-sourcerygxx-3_4_4-17:1.1
	readline_5_1-import-branch:1.1.0.10
	readline_5_1-import-branchpoint:1.1
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.1
	gdb-csl-symbian-20060226-branch:1.1.0.8
	gdb-csl-symbian-20060226-branchpoint:1.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.1
	msnyder-reverse-20060331-branch:1.1.0.6
	msnyder-reverse-20060331-branchpoint:1.1
	gdb-csl-available-20060303-branch:1.1.0.4
	gdb-csl-available-20060303-branchpoint:1.1
	gdb-csl-20060226-branch:1.1.0.2
	gdb-csl-20060226-branchpoint:1.1;
locks; strict;
comment	@.\" @;


1.1
date	2005.11.21.04.48.19;	author hp;	state Exp;
branches;
next	;


desc
@@


1.1
log
@	* sim/cris: New directory with C and assembly tests for the CRIS
	simulator.
@
text
@#mach: crisv32
#output: Basic clock cycles, total @@: *\n
#output: Memory source stall cycles: 82\n
#output: Memory read-after-write stall cycles: 0\n
#output: Movem source stall cycles: 6\n
#output: Movem destination stall cycles: 880\n
#output: Movem address stall cycles: 4\n
#output: Multiplication source stall cycles: 18\n
#output: Jump source stall cycles: 6\n
#output: Branch misprediction stall cycles: 0\n
#output: Jump target stall cycles: 0\n
#sim: --cris-cycles=basic

 .include "testutils.inc"

; Macros for testing correctness of movem destination stall
; cycles for various insn types.  Beware: macro parameters can
; be comma or space-delimited.  There are problems (i.e. bugs)
; with using space-delimited operands and operands with
; non-alphanumeric characters, like "[]-." so use comma for
; them.  Lots of trouble passing empty parameters and parameters
; with comma.  Ugh.  FIXME: Report bugs, fix bugs, fix other
; shortcomings, fix that darn old macro-parameter-in-string.

; Helper macro.  Unfortunately I find no cleaner way to unify
; one and two-operand cases, the main problem being the comma
; operand delimiter clashing with macro operand delimiter.
 .macro t_S_x_y S insn x y=none
 movem [r7],r6
 .ifc \y,none
  .ifc \S,none
   \insn \x
  .else
   \insn\S \x
  .endif
 .else
  .ifc \S,none
   \insn \x,\y
  .else
   \insn\S \x,\y
  .endif
 .endif
 nop
 nop
 nop
 .endm

; An insn-type that has a single register operand.  The register
; may or may not be a source register for the insn.
 .macro t_r insn
 t_S_x_y none,\insn,r3
 t_S_x_y none,\insn,r8
 .endm

; An insn-type that jumps to the destination of the register.
 .macro t_r_j insn
 move.d 0f,r7
 move.d 1f,r8
 move.d r8,r9
 nop
 nop
 nop
 .section ".rodata"
 .p2align 5
0:
 .dword 1f
 .dword 1f
 .dword 1f
 .dword 1f
 .dword 1f
 .dword 1f
 .dword 1f
 .previous
 t_r \insn
1:
 .endm

; An insn-type that has a size-modifier and two register
; operands.
 .macro t_xr_r S insn
 t_S_x_y \S \insn r3 r8
 t_S_x_y \S \insn r8 r3
 move.d r3,r9
 t_S_x_y \S \insn r4 r3
 t_S_x_y \S \insn r8 r9
 .endm

; An insn-type that has two register operands.
 .macro t_r_r insn
 t_xr_r none \insn
 .endm

; An t_r_rx insn with a byte or word-size modifier.
 .macro t_wbr_r insn
 t_xr_r .b,\insn
 t_xr_r .w,\insn
 .endm

; Ditto with a dword-size modifier.
 .macro t_dwbr_r insn
 t_xr_r .d,\insn
 t_wbr_r \insn
 .endm

; An insn-type that has a size-modifier, a constant and a
; register operand.
 .macro t_xc_r S insn
 t_S_x_y \S \insn 24 r3
 move.d r3,r9
 t_S_x_y \S \insn 24 r8
 .endm

; An insn-type that has a constant and a register operand.
 .macro t_c_r insn
 t_xc_r none \insn
 .endm

; An t_c_r insn with a byte or word-size modifier.
 .macro t_wbc_r insn
 t_xc_r .b,\insn
 t_xc_r .w,\insn
 .endm

; Ditto with a dword-size modifier.
 .macro t_dwbc_r insn
 t_xc_r .d,\insn
 t_wbc_r \insn
 .endm

; An insn-type that has size-modifier, a memory operand and a
; register operand.
 .macro t_xm_r S insn
 move.d 9b,r8
 t_S_x_y \S,\insn,[r4],r3
 move.d r3,r9
 t_S_x_y \S,\insn,[r8],r5
 move.d r5,r9
 t_S_x_y \S,\insn,[r3],r9
 t_S_x_y \S,\insn,[r8],r9
 .endm

; Ditto, to memory.
 .macro t_xr_m S insn
 move.d 9b,r8
 t_S_x_y \S,\insn,r3,[r4]
 t_S_x_y \S,\insn,r8,[r3]
 t_S_x_y \S,\insn,r3,[r8]
 t_S_x_y \S,\insn,r9,[r8]
 .endm

; An insn-type that has a memory operand and a register operand.
 .macro t_m_r insn
 t_xm_r none \insn
 .endm

; An t_m_r insn with a byte or word-size modifier.
 .macro t_wbm_r insn
 t_xm_r .b,\insn
 t_xm_r .w,\insn
 .endm

; Ditto with a dword-size modifier.
 .macro t_dwbm_r insn
 t_xm_r .d,\insn
 t_wbm_r \insn
 .endm

; Insn types of the regular type (r, c, m, size d w b).
 .macro t_dwb insn
 t_dwbr_r \insn
 t_dwbc_r \insn
 t_dwbm_r \insn
 .endm

; Similar, sizes w b.
 .macro t_wb insn
 t_wbr_r \insn
 t_wbc_r \insn
 t_wbm_r \insn
 .endm

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 startnostack

; Initialize registers so they don't contain unknowns.

 move.d 9f,r7
 move.d r7,r8
 moveq 0,r9

; Movem source area.  Register contents must be valid
; addresses, aligned on a cache boundary.
 .section ".rodata"
 .p2align 5
9:
 .dword 9b
 .dword 9b
 .dword 9b
 .dword 9b
 .dword 9b
 .dword 9b
 .dword 9b
 .dword 9b
 .dword 9b
 .dword 9b
 .previous

; The actual tests.  The numbers in the comments specify the
; number of movem destination stall cycles.  Some of them may be
; filed as memory source address stalls, multiplication source
; stalls or jump source stalls, duly marked so.

 t_r_r abs		; 3+3

 t_dwb add		; (3+3+3)*3+3*3+(3+3+3)*3 (6 mem src)

 t_r_r addc		; (3+3+3)
 t_c_r addc		; 3
 t_m_r addc		; (3+3+3) (2 mem src)

 t_dwb move		; (3+3)+(3+3+3)*2+3*2+(3+3+3)*3 (6 mem src)
 t_xr_m .b move		; 3+3+3 (2 mem src)
 t_xr_m .w move		; 3+3+3 (2 mem src)
 t_xr_m .d move		; 3+3+3 (2 mem src)

 t_S_x_y none addi r3.b r8	; 3
 t_S_x_y none addi r8.w r3	; 3
 t_S_x_y none addi r4.d r3	; 3
 t_S_x_y none addi r8.w r9

 ; Addo has three-operand syntax, so we have to expand (a useful
 ; subset of) "t_dwb".
 t_S_x_y none addi r3.b "r8,acr"	; 3
 t_S_x_y none addi r8.w "r3,acr"	; 3
 t_S_x_y none addi r4.d "r3,acr"	; 3
 t_S_x_y none addi r8.w "r9,acr"

 t_S_x_y .b addo 42 "r8,acr"
 t_S_x_y .w addo 4200 "r3,acr"		; 3
 t_S_x_y .d addo 420000 "r3,acr"	; 3

 move.d 9b,r8
 t_S_x_y .d,addo,[r4],"r3,acr"		; 3 (1 mem src)
 t_S_x_y .b,addo,[r3],"r8,acr"		; 3 (1 mem src)
 t_S_x_y .w,addo,[r8],"r3,acr"		; 3
 t_S_x_y .w,addo,[r8],"r9,acr"

 ; Similar for addoq.
 t_S_x_y none addoq 42 "r8,acr"
 t_S_x_y none addoq 42 "r3,acr"		; 3

 t_c_r addq				; 3

 t_wb adds		; (3+3+3)*2+3*2+(3+3+3)*2 (4 mem src)
 t_wb addu		; (3+3+3)*2+3*2+(3+3+3)*2 (4 mem src)

 t_dwb and		; (3+3+3)*3+3*3+(3+3+3)*3 (6 mem src)
 t_c_r andq		; 3

 t_dwbr_r asr		; (3+3+3)*3
 t_c_r asrq		; 3

 t_dwbr_r bound		; (3+3+3)*3
 t_dwbc_r bound		; 3*3

 t_r_r btst		; (3+3+3)
 t_c_r btstq		; 3

 t_dwb cmp		; (3+3+3)*3+3*3+(3+3+3)*3 (6 mem src)
 t_c_r cmpq		; 3

 t_wbc_r cmps		; 3*2
 t_wbc_r cmpu		; 3*2
 t_wbm_r cmps		; (3+3+3)*2 (4 mem src)
 t_wbm_r cmpu		; (3+3+3)*2 (4 mem src)

 t_r_r dstep		; (3+3+3)

 ; FIXME: idxd, fidxi, ftagd, ftagi when supported.

 t_r_j jsr		; 3 (2 jump src)
 t_r_j jump		; 3 (2 jump src)

 t_c_r lapc.d

; The "quick operand" must be in range [. to .+15*2] so we can't
; use t_c_r.
 t_S_x_y none lapcq .+4 r3
 t_S_x_y none lapcq .+4 r8

 t_dwbr_r lsl		; (3+3+3)*3
 t_c_r lslq		; 3

 t_dwbr_r lsr		; (3+3+3)*3
 t_c_r lsrq		; 3

 t_r_r lz		; 3+3

 t_S_x_y none mcp srp r3	; 3
 t_S_x_y none mcp srp r8

 t_c_r moveq

 t_S_x_y none move srp r8
 t_S_x_y none move srp r3
 t_S_x_y none move r8 srp
 t_S_x_y none move r3 srp	; 3

; FIXME: move supreg,Rd and move Rs,supreg when supported.

 t_wb movs	; (3+3)*2+0+(3+3)*2 (4 mem src)
 t_wb movu	; (3+3)*2+0+(3+3)*2 (4 mem src)

 t_dwbr_r muls	; (3+3+3)*3 (9 mul src)
 t_dwbr_r mulu	; (3+3+3)*3 (9 mul src)

 t_dwbr_r neg	; (3+3)*3

 t_r not	; 3 cycles.

 t_dwb or	; (3+3+3)*3+3*3+(3+3+3)*3 (6 mem src)
 t_c_r orq	; 3

 t_r seq

 t_dwb sub	; (3+3+3)*3+3*3+(3+3+3)*3 (6 mem src)
 t_c_r subq	; 3

 t_wb subs	; (3+3+3)*2+3*2+(3+3+3)*2 (4 mem src)
 t_wb subu	; (3+3+3)*2+3*2+(3+3+3)*2 (4 mem src)

 t_r swapw	; 3 cycles.
 t_r swapnwbr	; 3 cycles.

 t_r_j jsrc	; 3 (2 jump src)

 t_r_r xor	; (3+3+3)

 move.d 9b,r7
 nop
 nop
 nop
 t_xm_r none movem	; (3+3) (2 mem src, 1+1 movem addr)
 ; As implied by the comment, all movem destination penalty
 ; cycles (but one) are accounted for as memory source address
 ; and movem source penalties.  There are also two movem address
 ; cache-line straddle penalties.
 t_xr_m none movem	; (3+3+2+2) (2 mem, 6 movem src, +2 movem addr)

 break 15
@
