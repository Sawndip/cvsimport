head	1.2;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.2
	gdb_7_6-2013-04-26-release:1.2
	gdb_7_6-branch:1.2.0.38
	gdb_7_6-2013-03-12-branchpoint:1.2
	gdb_7_5_1-2012-11-29-release:1.2
	gdb_7_5-2012-08-17-release:1.2
	gdb_7_5-branch:1.2.0.36
	gdb_7_5-2012-07-18-branchpoint:1.2
	gdb_7_4_1-2012-04-26-release:1.2
	gdb_7_4-2012-01-24-release:1.2
	gdb_7_4-branch:1.2.0.34
	gdb_7_4-2011-12-13-branchpoint:1.2
	gdb_7_3_1-2011-09-04-release:1.2
	gdb_7_3-2011-07-26-release:1.2
	gdb_7_3-branch:1.2.0.32
	gdb_7_3-2011-04-01-branchpoint:1.2
	gdb_7_2-2010-09-02-release:1.2
	gdb_7_2-branch:1.2.0.30
	gdb_7_2-2010-07-07-branchpoint:1.2
	gdb_7_1-2010-03-18-release:1.2
	gdb_7_1-branch:1.2.0.28
	gdb_7_1-2010-02-18-branchpoint:1.2
	gdb_7_0_1-2009-12-22-release:1.2
	gdb_7_0-2009-10-06-release:1.2
	gdb_7_0-branch:1.2.0.26
	gdb_7_0-2009-09-16-branchpoint:1.2
	arc-sim-20090309:1.2
	msnyder-checkpoint-072509-branch:1.2.0.24
	msnyder-checkpoint-072509-branchpoint:1.2
	arc-insight_6_8-branch:1.2.0.22
	arc-insight_6_8-branchpoint:1.2
	insight_6_8-branch:1.2.0.20
	insight_6_8-branchpoint:1.2
	reverse-20081226-branch:1.2.0.18
	reverse-20081226-branchpoint:1.2
	multiprocess-20081120-branch:1.2.0.16
	multiprocess-20081120-branchpoint:1.2
	reverse-20080930-branch:1.2.0.14
	reverse-20080930-branchpoint:1.2
	reverse-20080717-branch:1.2.0.12
	reverse-20080717-branchpoint:1.2
	msnyder-reverse-20080609-branch:1.2.0.10
	msnyder-reverse-20080609-branchpoint:1.2
	drow-reverse-20070409-branch:1.2.0.8
	drow-reverse-20070409-branchpoint:1.2
	gdb_6_8-2008-03-27-release:1.2
	gdb_6_8-branch:1.2.0.6
	gdb_6_8-2008-02-26-branchpoint:1.2
	gdb_6_7_1-2007-10-29-release:1.2
	gdb_6_7-2007-10-10-release:1.2
	gdb_6_7-branch:1.2.0.4
	gdb_6_7-2007-09-07-branchpoint:1.2
	insight_6_6-20070208-release:1.2
	gdb_6_6-2006-12-18-release:1.2
	gdb_6_6-branch:1.2.0.2
	gdb_6_6-2006-11-15-branchpoint:1.2
	insight_6_5-20061003-release:1.1
	gdb-csl-symbian-6_4_50_20060226-12:1.1
	nickrob-async-20060828-mergepoint:1.1
	gdb-csl-symbian-6_4_50_20060226-11:1.1
	gdb-csl-sourcerygxx-4_1-17:1.1
	gdb-csl-20060226-branch-local-2:1.1
	gdb-csl-sourcerygxx-4_1-14:1.1
	gdb-csl-sourcerygxx-4_1-13:1.1
	gdb-csl-sourcerygxx-4_1-12:1.1
	gdb-csl-sourcerygxx-3_4_4-21:1.1
	gdb_6_5-20060621-release:1.1
	gdb-csl-sourcerygxx-4_1-9:1.1
	gdb-csl-sourcerygxx-4_1-8:1.1
	gdb-csl-sourcerygxx-4_1-7:1.1
	gdb-csl-arm-2006q1-6:1.1
	gdb-csl-sourcerygxx-4_1-6:1.1
	gdb-csl-symbian-6_4_50_20060226-10:1.1
	gdb-csl-symbian-6_4_50_20060226-9:1.1
	gdb-csl-symbian-6_4_50_20060226-8:1.1
	gdb-csl-coldfire-4_1-11:1.1
	gdb-csl-sourcerygxx-3_4_4-19:1.1
	gdb-csl-coldfire-4_1-10:1.1
	gdb_6_5-branch:1.1.0.16
	gdb_6_5-2006-05-14-branchpoint:1.1
	gdb-csl-sourcerygxx-4_1-5:1.1
	nickrob-async-20060513-branch:1.1.0.14
	nickrob-async-20060513-branchpoint:1.1
	gdb-csl-sourcerygxx-4_1-4:1.1
	msnyder-reverse-20060502-branch:1.1.0.12
	msnyder-reverse-20060502-branchpoint:1.1
	gdb-csl-morpho-4_1-4:1.1
	gdb-csl-sourcerygxx-3_4_4-17:1.1
	readline_5_1-import-branch:1.1.0.10
	readline_5_1-import-branchpoint:1.1
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.1
	gdb-csl-symbian-20060226-branch:1.1.0.8
	gdb-csl-symbian-20060226-branchpoint:1.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.1
	msnyder-reverse-20060331-branch:1.1.0.6
	msnyder-reverse-20060331-branchpoint:1.1
	gdb-csl-available-20060303-branch:1.1.0.4
	gdb-csl-available-20060303-branchpoint:1.1
	gdb-csl-20060226-branch:1.1.0.2
	gdb-csl-20060226-branchpoint:1.1;
locks; strict;
comment	@ * @;


1.2
date	2006.09.30.02.34.43;	author hp;	state Exp;
branches;
next	1.1;

1.1
date	2005.11.21.04.48.19;	author hp;	state Exp;
branches;
next	;


desc
@@


1.2
log
@        * sim/cris/c/pipe2.c: Adjust expected output.
	(process): Don't write as much to the pipe as to trig the
	inordinate-amount test in the sim pipe machinery.  Correct test of
	write return-value; check only that pipemax bytes were
	successfully written.  For error-case, emit strerror as well.
	(main): Add a second read.
@
text
@/* Check that closing a pipe with a nonempty buffer works.
#notarget: cris*-*-elf
#output: got: a\ngot: b\nexit: 0\n
*/


#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <limits.h>
#include <unistd.h>
#include <sched.h>
#include <signal.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>
int pip[2];

int pipemax;

int
process (void *arg)
{
  char *s = arg;
  int lots = pipemax + 256;
  char *buf = malloc (lots);
  int ret;

  if (buf == NULL)
    abort ();

  *buf = *s;

  /* The first write should go straight through.  */
  if (write (pip[1], buf, 1) != 1)
    abort ();

  *buf = s[1];

  /* The second write may or may not be successful for the whole
     write, but should be successful for at least the pipemax part.
     As linux/limits.h clamps PIPE_BUF to 4096, but the page size is
     actually 8k, we can get away with that much.  There should be no
     error, though.  Doing this on host shows that for
     x86_64-unknown-linux-gnu (2.6.14-1.1656_FC4) pipemax * 10 can be
     successfully written, perhaps for similar reasons.  */
  ret = write (pip[1], buf, lots);
  if (ret < pipemax)
    {
      fprintf (stderr, "ret: %d, %s, %d\n", ret, strerror (errno), pipemax);
      fflush (0);
      abort ();
    }

  return 0;
}

int
main (void)
{
  int retcode;
  int pid;
  int st = 0;
  long stack[16384];
  char buf[1];

  /* We need to turn this off because we don't want (to have to model) a
     SIGPIPE resulting from the close.  */
  if (signal (SIGPIPE, SIG_IGN) != SIG_DFL)
    abort ();

  retcode = pipe (pip);

  if (retcode != 0)
    {
      fprintf (stderr, "Bad pipe %d\n", retcode);
      abort ();
    }

#ifdef PIPE_MAX
  pipemax = PIPE_MAX;
#else
  pipemax = fpathconf (pip[1], _PC_PIPE_BUF);
#endif

  if (pipemax <= 0)
    {
      fprintf (stderr, "Bad pipemax %d\n", pipemax);
      abort ();
    }

  pid = clone (process, (char *) stack + sizeof (stack) - 64,
	       (CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND)
	       | SIGCHLD, "ab");
  if (pid <= 0)
    {
      fprintf (stderr, "Bad clone %d\n", pid);
      abort ();
    }

  while ((retcode = read (pip[0], buf, 1)) == 0)
    ;

  if (retcode != 1)
    {
      fprintf (stderr, "Bad read 1: %d\n", retcode);
      abort ();
    }

  printf ("got: %c\n", buf[0]);

  /* Need to read out something from the second write too before
     closing, or the writer can get EPIPE. */
  while ((retcode = read (pip[0], buf, 1)) == 0)
    ;

  if (retcode != 1)
    {
      fprintf (stderr, "Bad read 2: %d\n", retcode);
      abort ();
    }

  printf ("got: %c\n", buf[0]);

  if (close (pip[0]) != 0)
    {
      perror ("pip close");
      abort ();
    }

  retcode = waitpid (pid, &st, __WALL);

  if (retcode != pid || !WIFEXITED (st))
    {
      fprintf (stderr, "Bad wait %d:%d %x\n", pid, retcode, st);
      perror ("errno");
      abort ();
    }

  printf ("exit: %d\n", WEXITSTATUS (st));
  return 0;
}
@


1.1
log
@	* sim/cris: New directory with C and assembly tests for the CRIS
	simulator.
@
text
@d3 1
a3 1
#output: got: a\nexit: 0\n
d17 1
a17 1

d26 2
a27 1
  char *buf = malloc (pipemax * 100);
d41 9
a49 4
  /* The second write should only successful for at most the PIPE_MAX
     part, but no error.  */
  ret = write (pip[1], buf, pipemax * 10);
  if (ret != 0 && ret != pipemax - 1 && ret != pipemax)
d51 1
a51 1
      fprintf (stderr, "ret: %d\n", ret);
d113 13
@

