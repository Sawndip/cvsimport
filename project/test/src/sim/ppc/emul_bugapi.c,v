head	1.5;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.5
	gdb_7_6-2013-04-26-release:1.5
	gdb_7_6-branch:1.5.0.2
	gdb_7_6-2013-03-12-branchpoint:1.5
	gdb_7_5_1-2012-11-29-release:1.3
	gdb_7_5-2012-08-17-release:1.3
	gdb_7_5-branch:1.3.0.6
	gdb_7_5-2012-07-18-branchpoint:1.3
	gdb_7_4_1-2012-04-26-release:1.3
	gdb_7_4-2012-01-24-release:1.3
	gdb_7_4-branch:1.3.0.4
	gdb_7_4-2011-12-13-branchpoint:1.3
	gdb_7_3_1-2011-09-04-release:1.3
	gdb_7_3-2011-07-26-release:1.3
	gdb_7_3-branch:1.3.0.2
	gdb_7_3-2011-04-01-branchpoint:1.3
	gdb_7_2-2010-09-02-release:1.2
	gdb_7_2-branch:1.2.0.26
	gdb_7_2-2010-07-07-branchpoint:1.2
	gdb_7_1-2010-03-18-release:1.2
	gdb_7_1-branch:1.2.0.24
	gdb_7_1-2010-02-18-branchpoint:1.2
	gdb_7_0_1-2009-12-22-release:1.2
	gdb_7_0-2009-10-06-release:1.2
	gdb_7_0-branch:1.2.0.22
	gdb_7_0-2009-09-16-branchpoint:1.2
	arc-sim-20090309:1.2
	msnyder-checkpoint-072509-branch:1.2.0.20
	msnyder-checkpoint-072509-branchpoint:1.2
	arc-insight_6_8-branch:1.2.0.18
	arc-insight_6_8-branchpoint:1.2
	insight_6_8-branch:1.2.0.16
	insight_6_8-branchpoint:1.2
	reverse-20081226-branch:1.2.0.14
	reverse-20081226-branchpoint:1.2
	multiprocess-20081120-branch:1.2.0.12
	multiprocess-20081120-branchpoint:1.2
	reverse-20080930-branch:1.2.0.10
	reverse-20080930-branchpoint:1.2
	reverse-20080717-branch:1.2.0.8
	reverse-20080717-branchpoint:1.2
	msnyder-reverse-20080609-branch:1.2.0.6
	msnyder-reverse-20080609-branchpoint:1.2
	drow-reverse-20070409-branch:1.1.1.1.0.120
	drow-reverse-20070409-branchpoint:1.1.1.1
	gdb_6_8-2008-03-27-release:1.2
	gdb_6_8-branch:1.2.0.4
	gdb_6_8-2008-02-26-branchpoint:1.2
	gdb_6_7_1-2007-10-29-release:1.2
	gdb_6_7-2007-10-10-release:1.2
	gdb_6_7-branch:1.2.0.2
	gdb_6_7-2007-09-07-branchpoint:1.2
	insight_6_6-20070208-release:1.1.1.1
	gdb_6_6-2006-12-18-release:1.1.1.1
	gdb_6_6-branch:1.1.1.1.0.118
	gdb_6_6-2006-11-15-branchpoint:1.1.1.1
	insight_6_5-20061003-release:1.1.1.1
	gdb-csl-symbian-6_4_50_20060226-12:1.1.1.1
	gdb-csl-sourcerygxx-3_4_4-25:1.1.1.1
	nickrob-async-20060828-mergepoint:1.1.1.1
	gdb-csl-symbian-6_4_50_20060226-11:1.1.1.1
	gdb-csl-sourcerygxx-4_1-17:1.1.1.1
	gdb-csl-20060226-branch-local-2:1.1.1.1
	gdb-csl-sourcerygxx-4_1-14:1.1.1.1
	gdb-csl-sourcerygxx-4_1-13:1.1.1.1
	gdb-csl-sourcerygxx-4_1-12:1.1.1.1
	gdb-csl-sourcerygxx-3_4_4-21:1.1.1.1
	gdb_6_5-20060621-release:1.1.1.1
	gdb-csl-sourcerygxx-4_1-9:1.1.1.1
	gdb-csl-sourcerygxx-4_1-8:1.1.1.1
	gdb-csl-sourcerygxx-4_1-7:1.1.1.1
	gdb-csl-arm-2006q1-6:1.1.1.1
	gdb-csl-sourcerygxx-4_1-6:1.1.1.1
	gdb-csl-symbian-6_4_50_20060226-10:1.1.1.1
	gdb-csl-symbian-6_4_50_20060226-9:1.1.1.1
	gdb-csl-symbian-6_4_50_20060226-8:1.1.1.1
	gdb-csl-coldfire-4_1-11:1.1.1.1
	gdb-csl-sourcerygxx-3_4_4-19:1.1.1.1
	gdb-csl-coldfire-4_1-10:1.1.1.1
	gdb_6_5-branch:1.1.1.1.0.116
	gdb_6_5-2006-05-14-branchpoint:1.1.1.1
	gdb-csl-sourcerygxx-4_1-5:1.1.1.1
	nickrob-async-20060513-branch:1.1.1.1.0.114
	nickrob-async-20060513-branchpoint:1.1.1.1
	gdb-csl-sourcerygxx-4_1-4:1.1.1.1
	msnyder-reverse-20060502-branch:1.1.1.1.0.112
	msnyder-reverse-20060502-branchpoint:1.1.1.1
	gdb-csl-morpho-4_1-4:1.1.1.1
	gdb-csl-sourcerygxx-3_4_4-17:1.1.1.1
	readline_5_1-import-branch:1.1.1.1.0.110
	readline_5_1-import-branchpoint:1.1.1.1
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.1.1.1
	gdb-csl-symbian-20060226-branch:1.1.1.1.0.108
	gdb-csl-symbian-20060226-branchpoint:1.1.1.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.1.1.1
	msnyder-reverse-20060331-branch:1.1.1.1.0.106
	msnyder-reverse-20060331-branchpoint:1.1.1.1
	gdb-csl-available-20060303-branch:1.1.1.1.0.104
	gdb-csl-available-20060303-branchpoint:1.1.1.1
	gdb-csl-20060226-branch:1.1.1.1.0.102
	gdb-csl-20060226-branchpoint:1.1.1.1
	gdb_6_4-20051202-release:1.1.1.1
	msnyder-fork-checkpoint-branch:1.1.1.1.0.100
	msnyder-fork-checkpoint-branchpoint:1.1.1.1
	gdb-csl-gxxpro-6_3-branch:1.1.1.1.0.98
	gdb-csl-gxxpro-6_3-branchpoint:1.1.1.1
	gdb_6_4-branch:1.1.1.1.0.96
	gdb_6_4-2005-11-01-branchpoint:1.1.1.1
	gdb-csl-arm-20051020-branch:1.1.1.1.0.94
	gdb-csl-arm-20051020-branchpoint:1.1.1.1
	msnyder-tracepoint-checkpoint-branch:1.1.1.1.0.92
	msnyder-tracepoint-checkpoint-branchpoint:1.1.1.1
	gdb-csl-arm-20050325-2005-q1b:1.1.1.1
	gdb-csl-arm-20050325-2005-q1a:1.1.1.1
	csl-arm-20050325-branch:1.1.1.1.0.90
	csl-arm-20050325-branchpoint:1.1.1.1
	gdb_6_3-20041109-release:1.1.1.1
	gdb_6_3-branch:1.1.1.1.0.86
	gdb_6_3-20041019-branchpoint:1.1.1.1
	drow_intercu-merge-20040921:1.1.1.1
	drow_intercu-merge-20040915:1.1.1.1
	jimb-gdb_6_2-e500-branch:1.1.1.1.0.88
	jimb-gdb_6_2-e500-branchpoint:1.1.1.1
	gdb_6_2-20040730-release:1.1.1.1
	gdb_6_2-branch:1.1.1.1.0.84
	gdb_6_2-2004-07-10-gmt-branchpoint:1.1.1.1
	gdb_6_1_1-20040616-release:1.1.1.1
	gdb_6_1-2004-04-05-release:1.1.1.1
	drow_intercu-merge-20040402:1.1.1.1
	drow_intercu-merge-20040327:1.1.1.1
	ezannoni_pie-20040323-branch:1.1.1.1.0.82
	ezannoni_pie-20040323-branchpoint:1.1.1.1
	cagney_tramp-20040321-mergepoint:1.1.1.1
	cagney_tramp-20040309-branch:1.1.1.1.0.80
	cagney_tramp-20040309-branchpoint:1.1.1.1
	gdb_6_1-branch:1.1.1.1.0.78
	gdb_6_1-2004-03-01-gmt-branchpoint:1.1.1.1
	drow_intercu-20040221-branch:1.1.1.1.0.76
	drow_intercu-20040221-branchpoint:1.1.1.1
	cagney_bfdfile-20040213-branch:1.1.1.1.0.74
	cagney_bfdfile-20040213-branchpoint:1.1.1.1
	drow-cplus-merge-20040208:1.1.1.1
	carlton_dictionary-20040126-merge:1.1.1.1
	cagney_bigcore-20040122-branch:1.1.1.1.0.72
	cagney_bigcore-20040122-branchpoint:1.1.1.1
	drow-cplus-merge-20040113:1.1.1.1
	drow-cplus-merge-20031224:1.1.1.1
	drow-cplus-merge-20031220:1.1.1.1
	carlton_dictionary-20031215-merge:1.1.1.1
	drow-cplus-merge-20031214:1.1.1.1
	carlton-dictionary-20031111-merge:1.1.1.1
	gdb_6_0-2003-10-04-release:1.1.1.1
	kettenis_sparc-20030918-branch:1.1.1.1.0.70
	kettenis_sparc-20030918-branchpoint:1.1.1.1
	carlton_dictionary-20030917-merge:1.1.1.1
	ezannoni_pie-20030916-branchpoint:1.1.1.1
	ezannoni_pie-20030916-branch:1.1.1.1.0.68
	cagney_x86i386-20030821-branch:1.1.1.1.0.66
	cagney_x86i386-20030821-branchpoint:1.1.1.1
	carlton_dictionary-20030805-merge:1.1.1.1
	carlton_dictionary-20030627-merge:1.1.1.1
	gdb_6_0-branch:1.1.1.1.0.64
	gdb_6_0-2003-06-23-branchpoint:1.1.1.1
	jimb-ppc64-linux-20030613-branch:1.1.1.1.0.62
	jimb-ppc64-linux-20030613-branchpoint:1.1.1.1
	cagney_convert-20030606-branch:1.1.1.1.0.60
	cagney_convert-20030606-branchpoint:1.1.1.1
	cagney_writestrings-20030508-branch:1.1.1.1.0.58
	cagney_writestrings-20030508-branchpoint:1.1.1.1
	jimb-ppc64-linux-20030528-branch:1.1.1.1.0.56
	jimb-ppc64-linux-20030528-branchpoint:1.1.1.1
	carlton_dictionary-20030523-merge:1.1.1.1
	cagney_fileio-20030521-branch:1.1.1.1.0.54
	cagney_fileio-20030521-branchpoint:1.1.1.1
	kettenis_i386newframe-20030517-mergepoint:1.1.1.1
	jimb-ppc64-linux-20030509-branch:1.1.1.1.0.52
	jimb-ppc64-linux-20030509-branchpoint:1.1.1.1
	kettenis_i386newframe-20030504-mergepoint:1.1.1.1
	carlton_dictionary-20030430-merge:1.1.1.1
	kettenis_i386newframe-20030419-branch:1.1.1.1.0.50
	kettenis_i386newframe-20030419-branchpoint:1.1.1.1
	carlton_dictionary-20030416-merge:1.1.1.1
	cagney_frameaddr-20030409-mergepoint:1.1.1.1
	kettenis_i386newframe-20030406-branch:1.1.1.1.0.48
	kettenis_i386newframe-20030406-branchpoint:1.1.1.1
	cagney_frameaddr-20030403-branchpoint:1.1.1.1
	cagney_frameaddr-20030403-branch:1.1.1.1.0.46
	cagney_framebase-20030330-mergepoint:1.1.1.1
	cagney_framebase-20030326-branch:1.1.1.1.0.44
	cagney_framebase-20030326-branchpoint:1.1.1.1
	cagney_lazyid-20030317-branch:1.1.1.1.0.42
	cagney_lazyid-20030317-branchpoint:1.1.1.1
	kettenis-i386newframe-20030316-mergepoint:1.1.1.1
	offbyone-20030313-branch:1.1.1.1.0.40
	offbyone-20030313-branchpoint:1.1.1.1
	kettenis-i386newframe-20030308-branch:1.1.1.1.0.38
	kettenis-i386newframe-20030308-branchpoint:1.1.1.1
	carlton_dictionary-20030305-merge:1.1.1.1
	cagney_offbyone-20030303-branch:1.1.1.1.0.36
	cagney_offbyone-20030303-branchpoint:1.1.1.1
	carlton_dictionary-20030207-merge:1.1.1.1
	interps-20030202-branch:1.1.1.1.0.34
	interps-20030202-branchpoint:1.1.1.1
	cagney-unwind-20030108-branch:1.1.1.1.0.32
	cagney-unwind-20030108-branchpoint:1.1.1.1
	carlton_dictionary-20021223-merge:1.1.1.1
	gdb_5_3-2002-12-12-release:1.1.1.1
	carlton_dictionary-20021115-merge:1.1.1.1
	kseitz_interps-20021105-merge:1.1.1.1
	kseitz_interps-20021103-merge:1.1.1.1
	drow-cplus-merge-20021020:1.1.1.1
	drow-cplus-merge-20021025:1.1.1.1
	carlton_dictionary-20021025-merge:1.1.1.1
	carlton_dictionary-20021011-merge:1.1.1.1
	drow-cplus-branch:1.1.1.1.0.30
	drow-cplus-branchpoint:1.1.1.1
	kseitz_interps-20020930-merge:1.1.1.1
	carlton_dictionary-20020927-merge:1.1.1.1
	carlton_dictionary-branch:1.1.1.1.0.28
	carlton_dictionary-20020920-branchpoint:1.1.1.1
	gdb_5_3-branch:1.1.1.1.0.26
	gdb_5_3-2002-09-04-branchpoint:1.1.1.1
	kseitz_interps-20020829-merge:1.1.1.1
	cagney_sysregs-20020825-branch:1.1.1.1.0.24
	cagney_sysregs-20020825-branchpoint:1.1.1.1
	readline_4_3-import-branch:1.1.1.1.0.22
	readline_4_3-import-branchpoint:1.1.1.1
	gdb_5_2_1-2002-07-23-release:1.1.1.1
	kseitz_interps-20020528-branch:1.1.1.1.0.20
	kseitz_interps-20020528-branchpoint:1.1.1.1
	cagney_regbuf-20020515-branch:1.1.1.1.0.18
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	jimb-macro-020506-branch:1.1.1.1.0.16
	jimb-macro-020506-branchpoint:1.1.1.1
	gdb_5_2-2002-04-29-release:1.1.1.1
	gdb_5_2-branch:1.1.1.1.0.14
	gdb_5_2-2002-03-03-branchpoint:1.1.1.1
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.1.1.1
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.12
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.10
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.8
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2012.12.19.07.18.20;	author brobecke;	state Exp;
branches;
next	1.4;

1.4
date	2012.12.19.07.12.01;	author brobecke;	state Exp;
branches;
next	1.3;

1.3
date	2011.02.14.05.14.27;	author vapier;	state Exp;
branches;
next	1.2;

1.2
date	2007.09.04.09.45.06;	author guitton;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.08;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.35.08;	author shebs;	state Exp;
branches;
next	;


desc
@@


1.5
log
@[sim] Update old contact info in GPL license notices

sim/ChangeLog:

        Update old contact info in GPL license notices.
@
text
@/*  This file is part of the program psim.

    Copyright (C) 1994-1997, Andrew Cagney <cagney@@highland.com.au>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, see <http://www.gnu.org/licenses/>.

    */


#ifndef _EMUL_BUGAPI_C_
#define _EMUL_BUGAPI_C_

/* Note: this module is called via a table.  There is no benefit in
   making it inline */

#include "emul_generic.h"
#include "emul_bugapi.h"

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#ifdef HAVE_STRING_H
#include <string.h>
#else
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif
#endif


/* EMULATION

   BUG - Motorola's embeded firmware BUG interface

   DESCRIPTION

   

   */


/* from PowerPCBug Debugging Package User's Manual, part 2 of 2 and also bug.S - Dale Rahn */
#define _INCHR		0x000		/* Input character */
#define _INSTAT		0x001		/* Input serial port status */
#define _INLN		0x002		/* Input line (pointer / pointer format) */
#define _READSTR	0x003		/* Input string (pointer / count format) */
#define _READLN		0x004		/* Input line (pointer / count format) */
#define _CHKBRK		0x005		/* Check for break */
#define _DSKRD		0x010		/* Disk read */
#define _DSKWR		0x011		/* Disk write */
#define _DSKCFIG	0x012		/* Disk configure */
#define _DSKFMT		0x014		/* Disk format */
#define _DSKCTRL	0x015		/* Disk control */
#define _NETRD		0x018		/* Read from host */
#define _NETWR		0x019		/* Write to host */
#define _NETCFIG	0x01a		/* Configure network parameters */
#define _NETOPN		0x01b		/* Open file for reading */
#define _NETFRD		0x01c		/* Retreive specified file blocks */
#define _NETCTRL	0x01d		/* Implement special control functions */
#define _OUTCHR		0x020		/* Output character (pointer / pointer format) */
#define _OUTSTR		0x021		/* Output string (pointer / pointer format) */
#define _OUTLN		0x022		/* Output line (pointer / pointer format) */
#define _WRITE		0x023		/* Output string (pointer / count format) */
#define _WRITELN	0x024		/* Output line (pointer / count format) */
#define _WRITDLN	0x025		/* Output line with data (pointer / count format) */
#define _PCRLF		0x026		/* Output carriage return and line feed */
#define _ERASLN		0x027		/* Erase line */
#define _WRITD		0x028		/* Output string with data (pointer / count format) */
#define _SNDBRK		0x029		/* Send break */
#define _DELAY		0x043		/* Timer delay */
#define _RTC_TM		0x050		/* Time initialization for RTC */
#define _RTC_DT		0x051		/* Date initialization for RTC */
#define _RTC_DSP	0x052		/* Display RTC time and date */
#define _RTC_RD		0x053		/* Read the RTC registers */
#define _REDIR		0x060		/* Redirect I/O of a system call function */
#define _REDIR_I	0x061		/* Redirect input */
#define _REDIR_O	0x062		/* Redirect output */
#define _RETURN		0x063		/* Return to PPCbug */
#define _BINDEC		0x064		/* Convert binary to binary coded decimal (BCD) */
#define _CHANGEV	0x067		/* Parse value */
#define _STRCMP		0x068		/* Compare two strings (pointer / count format) */
#define _MULU32		0x069		/* Multiply two 32-bit unsigned integers */
#define _DIVU32		0x06a		/* Divide two 32-bit unsigned integers */
#define _CHK_SUM	0x06b		/* Generate checksum */
#define _BRD_ID		0x070		/* Return pointer to board ID packet */
#define _ENVIRON	0x071		/* Access boot environment parameters */
#define _DIAGFCN	0x074		/* Diagnostic function(s) */
#define _SIOPEPS	0x090		/* Retrieve SCSI pointers */
#define _IOINQ		0x120		/* Port inquire */
#define _IOINFORM	0x124		/* Port inform */
#define _IOCONFIG	0x128		/* Port configure */
#define _IODELETE	0x12c		/* Port delete */
#define _SYMBOLTA	0x130		/* Attach symbol table */
#define _SYMBOLDA	0x131		/* Detach symbol table */

struct bug_map {
  int value;
  const char *info;
};

static const struct bug_map bug_mapping[] = {
  { _INCHR,	".INCHR -- Input character" },
  { _INSTAT,	".INSTAT -- Input serial port status" },
  { _INLN,	".INLN -- Input line (pointer / pointer format)" },
  { _READSTR,	".READSTR -- Input string (pointer / count format)" },
  { _READLN,	".READLN -- Input line (pointer / count format)" },
  { _CHKBRK,	".CHKBRK -- Check for break" },
  { _DSKRD,	".DSKRD -- Disk read" },
  { _DSKWR,	".DSKWR -- Disk write" },
  { _DSKCFIG,	".DSKCFIG -- Disk configure" },
  { _DSKFMT,	".DSKFMT -- Disk format" },
  { _DSKCTRL,	".DSKCTRL -- Disk control" },
  { _NETRD,	".NETRD -- Read from host" },
  { _NETWR,	".NETWR -- Write to host" },
  { _NETCFIG,	".NETCFIG -- Configure network parameters" },
  { _NETOPN,	".NETOPN -- Open file for reading" },
  { _NETFRD,	".NETFRD -- Retreive specified file blocks" },
  { _NETCTRL,	".NETCTRL -- Implement special control functions" },
  { _OUTCHR,	".OUTCHR -- Output character" },
  { _OUTSTR,	".OUTSTR -- Output string (pointer / pointer format)" },
  { _OUTLN,	".OUTLN -- Output line (pointer / pointer format)" },
  { _WRITE,	".WRITE -- Output string (pointer / count format)" },
  { _WRITELN,	".WRITELN -- Output line (pointer / count format)" },
  { _WRITDLN,	".WRITDLN -- Output line with data (pointer / count format)" },
  { _PCRLF,	".PCRLF -- Output carriage return and line feed" },
  { _ERASLN,	".ERASLN -- Erase line" },
  { _WRITD,	".WRITD -- Output string with data (pointer / count format)" },
  { _SNDBRK,	".SNDBRK -- Send break" },
  { _DELAY,	".DELAY -- Timer delay" },
  { _RTC_TM,	".RTC_TM -- Time initialization for RTC" },
  { _RTC_DT,	".RTC_DT -- Date initialization for RTC" },
  { _RTC_DSP,	".RTC_DSP -- Display RTC time and date" },
  { _RTC_RD,	".RTC_RD -- Read the RTC registers" },
  { _REDIR,	".REDIR -- Redirect I/O of a system call function" },
  { _REDIR,	".REDIR -- Redirect input" },
  { _REDIR,	".REDIR -- Redirect output" },
  { _RETURN,	".RETURN -- Return to PPCbug" },
  { _BINDEC,	".BINDEC -- Convert binary to binary coded decimal (BCD)" },
  { _CHANGEV,	".CHANGEV -- Parse value" },
  { _STRCMP,	".STRCMP -- Compare two strings (pointer / count format)" },
  { _MULU32,	".MULU32 -- Multiply two 32-bit unsigned integers" },
  { _DIVU32,	".DIVU32 -- Divide two 32-bit unsigned integers" },
  { _CHK_SUM,	".CHK_SUM -- Generate checksum" },
  { _BRD_ID,	".BRD_ID -- Return pointer to board ID packet" },
  { _ENVIRON,	".ENVIRON -- Access boot environment parameters" },
  { _DIAGFCN,	".DIAGFCN -- Diagnostic function(s)" },
  { _SIOPEPS,	".SIOPEPS -- Retrieve SCSI pointers" },
  { _IOINQ,	".IOINQ -- Port inquire" },
  { _IOINFORM,	".IOINFORM -- Port inform" },
  { _IOCONFIG,	".IOCONFIG -- Port configure" },
  { _IODELETE,	".IODELETE -- Port delete" },
  { _SYMBOLTA,	".SYMBOLTA -- Attach symbol table" },
  { _SYMBOLDA,	".SYMBOLDA -- Detach symbol table" },
};

#ifndef BUGAPI_END_ADDRESS
#define BUGAPI_END_ADDRESS 0x100000
#endif

enum {
  nr_bugapi_disks = 2,
};


struct _os_emul_data {
  device *root;
  unsigned_word memory_size;
  unsigned_word top_of_stack;
  int interrupt_prefix;
  unsigned_word interrupt_vector_address;
  unsigned_word system_call_address;
  unsigned_word stall_cpu_loop_address;
  int little_endian;
  int floating_point_available;
  /* I/O devices */
  device_instance *output;
  device_instance *input;
  device_instance *(disk[nr_bugapi_disks]);
};


static os_emul_data *
emul_bugapi_create(device *root,
		   bfd *image,
		   const char *name)
{
  device *node;
  os_emul_data *bugapi;
  char *filename;

  /* check it really is for us */
  if (name != NULL
      && strcmp(name, "bugapi") != 0
      && strcmp(name, "bug") != 0)
    return NULL;
  if (image != NULL
      && name == NULL
      && bfd_get_start_address(image) >= BUGAPI_END_ADDRESS)
    return NULL;

  bugapi = ZALLOC(os_emul_data);

  /* options */
  emul_add_tree_options(root, image, "bug", "oea",
			1 /*oea-interrupt-prefix*/);

  /* add some real hardware, include eeprom memory for the eeprom trap
     addresses */
  emul_add_tree_hardware(root);
  node = tree_parse(root, "/openprom/memory@@0xfff00000");
  tree_parse(node, "./psim,description \"eeprom trap addresses");
  tree_parse(node, "./reg 0xfff00000 0x3000");

  bugapi->root = root;

  bugapi->memory_size
    = tree_find_integer_property(root, "/openprom/options/oea-memory-size");
  bugapi->interrupt_prefix =
    tree_find_integer_property(root, "/openprom/options/oea-interrupt-prefix");
  bugapi->interrupt_vector_address = (bugapi->interrupt_prefix
				      ? MASK(0, 43)
				      : 0);
  bugapi->system_call_address = (bugapi->interrupt_vector_address + 0x00c00);
  bugapi->stall_cpu_loop_address = (bugapi->system_call_address + 0x000f0);
  bugapi->top_of_stack = bugapi->memory_size - 0x1000;
  bugapi->little_endian
    = tree_find_boolean_property(root, "/options/little-endian?");
  bugapi->floating_point_available
    = tree_find_boolean_property(root, "/openprom/options/floating-point?");
  bugapi->input = NULL;
  bugapi->output = NULL;

  /* initialization */
  if (image != NULL)
    tree_parse(root, "/openprom/init/register/0.pc 0x%lx",
	       (unsigned long)bfd_get_start_address(image));
  tree_parse(root, "/openprom/init/register/pc 0x%lx",
	     (unsigned long)bugapi->stall_cpu_loop_address);
  tree_parse(root, "/openprom/init/register/sp 0x%lx",
	     (unsigned long)(bugapi->top_of_stack - 16));
  tree_parse(root, "/openprom/init/register/msr 0x%x",
	     (msr_recoverable_interrupt
	      | (bugapi->little_endian
		 ? (msr_little_endian_mode
		    | msr_interrupt_little_endian_mode)
		 : 0)
	      | (bugapi->floating_point_available
		 ? msr_floating_point_available
		 : 0)
	      | (bugapi->interrupt_prefix
		 ? msr_interrupt_prefix
		 : 0)
	      ));

  /* patch the system call instruction to call this emulation and then
     do an rfi */
  node = tree_parse(root, "/openprom/init/data@@0x%lx",
		    (unsigned long)bugapi->system_call_address);
  tree_parse(node, "./psim,description \"system-call trap instruction");
  tree_parse(node, "./real-address 0x%lx",
	     (unsigned long)bugapi->system_call_address);
  tree_parse(node, "./data 0x%x", emul_call_instruction);
  node = tree_parse(root, "/openprom/init/data@@0x%lx",
		    (unsigned long)bugapi->system_call_address + 4);
  tree_parse(node, "./psim,description \"return from interrupt instruction");
  tree_parse(node, "./real-address 0x%lx",
	     (unsigned long)bugapi->system_call_address + 4);
  tree_parse(node, "./data 0x%x",
	     emul_rfi_instruction);

  /* patch the end of the system call instruction so that it contains
     a loop to self instruction and point all the cpu's at this */
  node = tree_parse(root, "/openprom/init/data@@0x%lx",
		    (unsigned long)bugapi->stall_cpu_loop_address);
  tree_parse(node, "./psim,description \"cpu-loop instruction");
  tree_parse(node, "./real-address 0x%lx",
	     (unsigned long)bugapi->stall_cpu_loop_address);
  tree_parse(node, "./data 0x%lx",
	     (unsigned long)emul_loop_instruction);

  if (image != NULL)
    tree_parse(root, "/openprom/init/stack/stack-type %s",
	       (image->xvec->flavour == bfd_target_elf_flavour
		? "ppc-elf"
		: "ppc-xcoff"));

  if (image != NULL)
    {
      filename = tree_quote_property (bfd_get_filename(image));
      tree_parse(root, "/openprom/init/load-binary/file-name %s",
		 filename);
      free (filename);
    }

  return bugapi;
}

static void
emul_bugapi_init(os_emul_data *bugapi,
		 int nr_cpus)
{
  int i;
  /* get the current input/output devices that were created during
     device tree initialization */
  bugapi->input = tree_find_ihandle_property(bugapi->root, "/chosen/stdin");
  bugapi->output = tree_find_ihandle_property(bugapi->root, "/chosen/stdout");
  /* if present, extract the selected disk devices */
  for (i = 0; i < nr_bugapi_disks; i++) {
    char disk[32];
    char *chp;
    strcpy(disk, "/chosen/disk0");
    ASSERT(sizeof(disk) > strlen(disk));
    chp = strchr(disk, '0');
    *chp = *chp + i;
    if (tree_find_property(bugapi->root, disk) != NULL)
      bugapi->disk[i] = tree_find_ihandle_property(bugapi->root, disk);
  }
}

static const char *
emul_bugapi_instruction_name(int call_id)
{
  static char buffer[40];
  int i;

  for (i = 0; i < sizeof (bug_mapping) / sizeof (bug_mapping[0]); i++)
    {
      if (bug_mapping[i].value == call_id)
	return bug_mapping[i].info;
    }

  (void) sprintf (buffer, "Unknown bug call 0x%x", call_id);
  return buffer;
}

static int
emul_bugapi_do_read(os_emul_data *bugapi,
		    cpu *processor,
		    unsigned_word cia,
		    unsigned_word buf,
		    int nbytes)
{
  unsigned char *scratch_buffer;
  int status;

  /* get a tempoary bufer */
  scratch_buffer = (unsigned char *) zalloc(nbytes);

  /* check if buffer exists by reading it */
  emul_read_buffer((void *)scratch_buffer, buf, nbytes, processor, cia);

  /* read */
  status = device_instance_read(bugapi->input,
				(void *)scratch_buffer, nbytes);

  /* -1 = error, -2 = nothing available - see "serial" [IEEE1275] */
  if (status < 0) {
    status = 0;
  }

  if (status > 0) {
    emul_write_buffer((void *)scratch_buffer, buf, status, processor, cia);

    /* Bugapi chops off the trailing n, but leaves it in the buffer */
    if (scratch_buffer[status-1] == '\n' || scratch_buffer[status-1] == '\r')
      status--;
  }

  free(scratch_buffer);
  return status;
}

static void
emul_bugapi_do_diskio(os_emul_data *bugapi,
		      cpu *processor,
		      unsigned_word cia,
		      unsigned_word descriptor_addr,
		      int call_id)
{
  struct dskio_descriptor {
    unsigned_1 ctrl_lun;
    unsigned_1 dev_lun;
    unsigned_2 status;
    unsigned_word pbuffer;
    unsigned_4 blk_num;
    unsigned_2 blk_cnt;
    unsigned_1 flag;
#define BUG_FILE_MARK	 0x80
#define IGNORE_FILENUM	 0x02
#define END_OF_FILE	 0x01
    unsigned_1 addr_mod;
  } descriptor;
  int block;
  emul_read_buffer(&descriptor, descriptor_addr, sizeof(descriptor),
		   processor, cia);
  T2H(descriptor.ctrl_lun);
  T2H(descriptor.dev_lun);
  T2H(descriptor.status);
  T2H(descriptor.pbuffer);
  T2H(descriptor.blk_num);
  T2H(descriptor.blk_cnt);
  T2H(descriptor.flag);
  T2H(descriptor.addr_mod);
  if (descriptor.dev_lun >= nr_bugapi_disks
      || bugapi->disk[descriptor.dev_lun] == NULL) {
    error("emul_bugapi_do_diskio: attempt to access unconfigured disk /chosen/disk%d",
	  descriptor.dev_lun);
  }
  else {
    for (block = 0; block < descriptor.blk_cnt; block++) {
      device_instance *disk = bugapi->disk[descriptor.dev_lun];
      unsigned_1 buf[512]; /*????*/
      unsigned_word block_nr = descriptor.blk_num + block;
      unsigned_word byte_nr = block_nr * sizeof(buf);
      unsigned_word block_addr = descriptor.pbuffer + block*sizeof(buf);
      if (device_instance_seek(disk, 0, byte_nr) < 0)
	error("emul_bugapi_do_diskio: bad seek\n");
      switch (call_id) {
      case _DSKRD:
	if (device_instance_read(disk, buf, sizeof(buf)) != sizeof(buf))
	  error("emul_`bugapi_do_diskio: bad read\n");
	emul_write_buffer(buf, block_addr, sizeof(buf), processor, cia);
	break;
      case _DSKWR:
	emul_read_buffer(buf, block_addr, sizeof(buf), processor, cia);
	if (device_instance_write(disk, buf, sizeof(buf)) != sizeof(buf))
	  error("emul_bugapi_do_diskio: bad write\n");
	break;
      default:
	error("emul_bugapi_do_diskio: bad switch\n");
      }
    }
  }
}

static void
emul_bugapi_do_write(os_emul_data *bugapi,
		     cpu *processor,
		     unsigned_word cia,
		     unsigned_word buf,
		     int nbytes,
		     const char *suffix)
{
  void *scratch_buffer = NULL;

  /* get a tempoary bufer */
  if (nbytes > 0)
    {
      scratch_buffer = zalloc(nbytes);

      /* copy in */
      emul_read_buffer(scratch_buffer, buf, nbytes,
		       processor, cia);

      /* write */
      device_instance_write(bugapi->output, scratch_buffer, nbytes);

      free(scratch_buffer);
    }

  if (suffix)
    device_instance_write(bugapi->output, suffix, strlen(suffix));

  flush_stdoutput ();
}

static int
emul_bugapi_instruction_call(cpu *processor,
			     unsigned_word cia,
			     unsigned_word ra,
			     os_emul_data *bugapi)
{
  const int call_id = cpu_registers(processor)->gpr[10];
  unsigned char uc;

#define MY_INDEX itable_instruction_call
  ITRACE (trace_os_emul,
	  (" 0x%x %s, r3 = 0x%lx, r4 = 0x%lx\n",
	   call_id, emul_bugapi_instruction_name (call_id),
	   (long)cpu_registers(processor)->gpr[3],
	   (long)cpu_registers(processor)->gpr[4]));;

  /* check that this isn't an invalid instruction */
  if (cia != bugapi->system_call_address)
    return 0;

  switch (call_id) {
  default:
    error("emul-bugapi: unimplemented bugapi %s from address 0x%lx\n",
	  emul_bugapi_instruction_name (call_id), SRR0);
    break;

  /* read a single character, output r3 = byte */
  /* FIXME: Add support to unbuffer input */
  case _INCHR:
    if (device_instance_read(bugapi->input, (void *)&uc, 1) <= 0)
      uc = 0;
    cpu_registers(processor)->gpr[3] = uc;
    break;

  /* read a line of at most 256 bytes, r3 = ptr to 1st byte, output r3 = ptr to last byte+1  */
  case _INLN:
    cpu_registers(processor)->gpr[3] += emul_bugapi_do_read(bugapi,
							    processor, cia,
							    cpu_registers(processor)->gpr[3],
							    256);
    break;

  /* output a character, r3 = character */
  case _OUTCHR:
    {
      char out = (char)cpu_registers(processor)->gpr[3];
      device_instance_write(bugapi->output, &out, 1);
      break;
    }

  /* output a string, r3 = ptr to 1st byte, r4 = ptr to last byte+1 */
  case _OUTSTR:
    emul_bugapi_do_write(bugapi,
			 processor, cia,
			 cpu_registers(processor)->gpr[3],
			 cpu_registers(processor)->gpr[4] - cpu_registers(processor)->gpr[3],
			 (const char *)0);
    break;

  /* output a string followed by \r\n, r3 = ptr to 1st byte, r4 = ptr to last byte+1 */
  case _OUTLN:

    emul_bugapi_do_write(bugapi,
			 processor, cia,
			 cpu_registers(processor)->gpr[3],
			 cpu_registers(processor)->gpr[4] - cpu_registers(processor)->gpr[3],
			 "\n");
    break;

  /* output a \r\n */
  case _PCRLF:
    device_instance_write(bugapi->output, "\n", 1);
    break;

  /* read/write blocks of data to/from the disk */
  case _DSKWR:
  case _DSKRD:
    emul_bugapi_do_diskio(bugapi, processor, cia,
			  cpu_registers(processor)->gpr[3],
			  call_id);
    break;

  /* return to ppcbug monitor (exiting with gpr[3] as status is not
     part of the bug monitor) */
  case _RETURN:
    cpu_halt(processor, cia, was_exited, cpu_registers(processor)->gpr[3]);
    break;
  }
  return 1;
  /* the instruction following this one is a RFI.  Thus by just
     continuing the return from system call is performed */
}

const os_emul emul_bugapi = {
  "bugapi",
  emul_bugapi_create,
  emul_bugapi_init,
  0, /*system_call*/
  emul_bugapi_instruction_call,
  0 /*data*/
};

#endif
@


1.4
log
@Update sim copyright headers from GPLv2-or-later to GPLv3-or-later.

gdb/sim/ChangeLog:

        Update the non-FSF-copyrighted files in sim to GPLv3 or later.
@
text
@d16 1
a16 2
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@


1.3
log
@sim: punt zfree()

The sim keeps track of which allocations are zero-ed internally (via
zalloc) and then calls a helper "zfree" function rather than "free".
But this "zfree" function simply calls "free" itself.  Since I can
see no point in this and it is simply useless overhead, punt it.

The only real change is in hw-alloc.c where we remove the zalloc_p
tracking, and sim-utils.c where zfree is delete.  The rest of the
changes are a simple `sed` from "zfree" to "free".

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d7 1
a7 1
    the Free Software Foundation; either version 2 of the License, or
@


1.2
log
@	* sim/ppc/emul_bugapi.c (emul_bugapi_create): quote the file
	name property before parsing it.
@
text
@d386 1
a386 1
  zfree(scratch_buffer);
d475 1
a475 1
      zfree(scratch_buffer);
@


1.1
log
@Initial revision
@
text
@d206 1
d305 6
a310 2
    tree_parse(root, "/openprom/init/load-binary/file-name \"%s",
	       bfd_get_filename(image));
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@

