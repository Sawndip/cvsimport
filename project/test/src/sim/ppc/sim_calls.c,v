head	1.19;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.18
	gdb_7_6-2013-04-26-release:1.18
	gdb_7_6-branch:1.18.0.2
	gdb_7_6-2013-03-12-branchpoint:1.18
	gdb_7_5_1-2012-11-29-release:1.16
	gdb_7_5-2012-08-17-release:1.16
	gdb_7_5-branch:1.16.0.2
	gdb_7_5-2012-07-18-branchpoint:1.16
	gdb_7_4_1-2012-04-26-release:1.15
	gdb_7_4-2012-01-24-release:1.15
	gdb_7_4-branch:1.15.0.2
	gdb_7_4-2011-12-13-branchpoint:1.15
	gdb_7_3_1-2011-09-04-release:1.14
	gdb_7_3-2011-07-26-release:1.14
	gdb_7_3-branch:1.14.0.2
	gdb_7_3-2011-04-01-branchpoint:1.14
	gdb_7_2-2010-09-02-release:1.13
	gdb_7_2-branch:1.13.0.2
	gdb_7_2-2010-07-07-branchpoint:1.13
	gdb_7_1-2010-03-18-release:1.12
	gdb_7_1-branch:1.12.0.44
	gdb_7_1-2010-02-18-branchpoint:1.12
	gdb_7_0_1-2009-12-22-release:1.12
	gdb_7_0-2009-10-06-release:1.12
	gdb_7_0-branch:1.12.0.42
	gdb_7_0-2009-09-16-branchpoint:1.12
	arc-sim-20090309:1.12
	msnyder-checkpoint-072509-branch:1.12.0.40
	msnyder-checkpoint-072509-branchpoint:1.12
	arc-insight_6_8-branch:1.12.0.38
	arc-insight_6_8-branchpoint:1.12
	insight_6_8-branch:1.12.0.36
	insight_6_8-branchpoint:1.12
	reverse-20081226-branch:1.12.0.34
	reverse-20081226-branchpoint:1.12
	multiprocess-20081120-branch:1.12.0.32
	multiprocess-20081120-branchpoint:1.12
	reverse-20080930-branch:1.12.0.30
	reverse-20080930-branchpoint:1.12
	reverse-20080717-branch:1.12.0.28
	reverse-20080717-branchpoint:1.12
	msnyder-reverse-20080609-branch:1.12.0.26
	msnyder-reverse-20080609-branchpoint:1.12
	drow-reverse-20070409-branch:1.12.0.24
	drow-reverse-20070409-branchpoint:1.12
	gdb_6_8-2008-03-27-release:1.12
	gdb_6_8-branch:1.12.0.22
	gdb_6_8-2008-02-26-branchpoint:1.12
	gdb_6_7_1-2007-10-29-release:1.12
	gdb_6_7-2007-10-10-release:1.12
	gdb_6_7-branch:1.12.0.20
	gdb_6_7-2007-09-07-branchpoint:1.12
	insight_6_6-20070208-release:1.12
	gdb_6_6-2006-12-18-release:1.12
	gdb_6_6-branch:1.12.0.18
	gdb_6_6-2006-11-15-branchpoint:1.12
	insight_6_5-20061003-release:1.12
	gdb-csl-symbian-6_4_50_20060226-12:1.12
	gdb-csl-sourcerygxx-3_4_4-25:1.11.10.1
	nickrob-async-20060828-mergepoint:1.12
	gdb-csl-symbian-6_4_50_20060226-11:1.12
	gdb-csl-sourcerygxx-4_1-17:1.12
	gdb-csl-20060226-branch-local-2:1.12
	gdb-csl-sourcerygxx-4_1-14:1.12
	gdb-csl-sourcerygxx-4_1-13:1.12
	gdb-csl-sourcerygxx-4_1-12:1.12
	gdb-csl-sourcerygxx-3_4_4-21:1.12
	gdb_6_5-20060621-release:1.12
	gdb-csl-sourcerygxx-4_1-9:1.12
	gdb-csl-sourcerygxx-4_1-8:1.12
	gdb-csl-sourcerygxx-4_1-7:1.12
	gdb-csl-arm-2006q1-6:1.12
	gdb-csl-sourcerygxx-4_1-6:1.12
	gdb-csl-symbian-6_4_50_20060226-10:1.12
	gdb-csl-symbian-6_4_50_20060226-9:1.12
	gdb-csl-symbian-6_4_50_20060226-8:1.12
	gdb-csl-coldfire-4_1-11:1.12
	gdb-csl-sourcerygxx-3_4_4-19:1.12
	gdb-csl-coldfire-4_1-10:1.12
	gdb_6_5-branch:1.12.0.16
	gdb_6_5-2006-05-14-branchpoint:1.12
	gdb-csl-sourcerygxx-4_1-5:1.12
	nickrob-async-20060513-branch:1.12.0.14
	nickrob-async-20060513-branchpoint:1.12
	gdb-csl-sourcerygxx-4_1-4:1.12
	msnyder-reverse-20060502-branch:1.12.0.12
	msnyder-reverse-20060502-branchpoint:1.12
	gdb-csl-morpho-4_1-4:1.12
	gdb-csl-sourcerygxx-3_4_4-17:1.12
	readline_5_1-import-branch:1.12.0.10
	readline_5_1-import-branchpoint:1.12
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.12
	gdb-csl-symbian-20060226-branch:1.12.0.8
	gdb-csl-symbian-20060226-branchpoint:1.12
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.12
	msnyder-reverse-20060331-branch:1.12.0.6
	msnyder-reverse-20060331-branchpoint:1.12
	gdb-csl-available-20060303-branch:1.12.0.4
	gdb-csl-available-20060303-branchpoint:1.12
	gdb-csl-20060226-branch:1.12.0.2
	gdb-csl-20060226-branchpoint:1.12
	gdb_6_4-20051202-release:1.11
	msnyder-fork-checkpoint-branch:1.11.0.12
	msnyder-fork-checkpoint-branchpoint:1.11
	gdb-csl-gxxpro-6_3-branch:1.11.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.11
	gdb_6_4-branch:1.11.0.8
	gdb_6_4-2005-11-01-branchpoint:1.11
	gdb-csl-arm-20051020-branch:1.11.0.6
	gdb-csl-arm-20051020-branchpoint:1.11
	msnyder-tracepoint-checkpoint-branch:1.11.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.11
	gdb-csl-arm-20050325-2005-q1b:1.11
	gdb-csl-arm-20050325-2005-q1a:1.11
	csl-arm-20050325-branch:1.11.0.2
	csl-arm-20050325-branchpoint:1.11
	gdb_6_3-20041109-release:1.10
	gdb_6_3-branch:1.10.0.2
	gdb_6_3-20041019-branchpoint:1.10
	drow_intercu-merge-20040921:1.10
	drow_intercu-merge-20040915:1.10
	jimb-gdb_6_2-e500-branch:1.7.24.1.0.2
	jimb-gdb_6_2-e500-branchpoint:1.7
	gdb_6_2-20040730-release:1.7
	gdb_6_2-branch:1.7.0.22
	gdb_6_2-2004-07-10-gmt-branchpoint:1.7
	gdb_6_1_1-20040616-release:1.7
	gdb_6_1-2004-04-05-release:1.7
	drow_intercu-merge-20040402:1.7
	drow_intercu-merge-20040327:1.7
	ezannoni_pie-20040323-branch:1.7.0.20
	ezannoni_pie-20040323-branchpoint:1.7
	cagney_tramp-20040321-mergepoint:1.7
	cagney_tramp-20040309-branch:1.7.0.18
	cagney_tramp-20040309-branchpoint:1.7
	gdb_6_1-branch:1.7.0.16
	gdb_6_1-2004-03-01-gmt-branchpoint:1.7
	drow_intercu-20040221-branch:1.7.0.14
	drow_intercu-20040221-branchpoint:1.7
	cagney_bfdfile-20040213-branch:1.7.0.12
	cagney_bfdfile-20040213-branchpoint:1.7
	drow-cplus-merge-20040208:1.7
	carlton_dictionary-20040126-merge:1.7
	cagney_bigcore-20040122-branch:1.7.0.10
	cagney_bigcore-20040122-branchpoint:1.7
	drow-cplus-merge-20040113:1.7
	drow-cplus-merge-20031224:1.7
	drow-cplus-merge-20031220:1.7
	carlton_dictionary-20031215-merge:1.7
	drow-cplus-merge-20031214:1.7
	carlton-dictionary-20031111-merge:1.7
	gdb_6_0-2003-10-04-release:1.7
	kettenis_sparc-20030918-branch:1.7.0.8
	kettenis_sparc-20030918-branchpoint:1.7
	carlton_dictionary-20030917-merge:1.7
	ezannoni_pie-20030916-branchpoint:1.7
	ezannoni_pie-20030916-branch:1.7.0.6
	cagney_x86i386-20030821-branch:1.7.0.4
	cagney_x86i386-20030821-branchpoint:1.7
	carlton_dictionary-20030805-merge:1.7
	carlton_dictionary-20030627-merge:1.7
	gdb_6_0-branch:1.7.0.2
	gdb_6_0-2003-06-23-branchpoint:1.7
	jimb-ppc64-linux-20030613-branch:1.6.0.28
	jimb-ppc64-linux-20030613-branchpoint:1.6
	cagney_convert-20030606-branch:1.6.0.26
	cagney_convert-20030606-branchpoint:1.6
	cagney_writestrings-20030508-branch:1.6.0.24
	cagney_writestrings-20030508-branchpoint:1.6
	jimb-ppc64-linux-20030528-branch:1.6.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.6
	carlton_dictionary-20030523-merge:1.6
	cagney_fileio-20030521-branch:1.6.0.20
	cagney_fileio-20030521-branchpoint:1.6
	kettenis_i386newframe-20030517-mergepoint:1.6
	jimb-ppc64-linux-20030509-branch:1.6.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.6
	kettenis_i386newframe-20030504-mergepoint:1.6
	carlton_dictionary-20030430-merge:1.6
	kettenis_i386newframe-20030419-branch:1.6.0.16
	kettenis_i386newframe-20030419-branchpoint:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	kettenis_i386newframe-20030406-branch:1.6.0.14
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.12
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.10
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.8
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.6
	offbyone-20030313-branch:1.6.0.6
	offbyone-20030313-branchpoint:1.6
	kettenis-i386newframe-20030308-branch:1.6.0.4
	kettenis-i386newframe-20030308-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.2
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.14
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.12
	cagney-unwind-20030108-branchpoint:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.5
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.10
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.8
	carlton_dictionary-20020920-branchpoint:1.5
	gdb_5_3-branch:1.5.0.6
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.4
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.2
	readline_4_3-import-branchpoint:1.5
	gdb_5_2_1-2002-07-23-release:1.3
	kseitz_interps-20020528-branch:1.4.0.6
	kseitz_interps-20020528-branchpoint:1.4
	cagney_regbuf-20020515-branch:1.4.0.4
	cagney_regbuf-20020515-branchpoint:1.4
	jimb-macro-020506-branch:1.4.0.2
	jimb-macro-020506-branchpoint:1.4
	gdb_5_2-2002-04-29-release:1.3
	gdb_5_2-branch:1.3.0.2
	gdb_5_2-2002-03-03-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.2
	gdb_5_1_0_1-2002-01-03-release:1.2
	cygnus_cvs_20020108_pre:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.4
	gdb_s390-2001-09-26-branchpoint:1.2
	gdb_5_1-2001-07-29-branch:1.2.0.2
	gdb_5_1-2001-07-29-branchpoint:1.2
	insight-precleanup-2001-01-01:1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.19
date	2013.03.15.17.53.44;	author sje;	state Exp;
branches;
next	1.18;

1.18
date	2012.12.19.07.18.21;	author brobecke;	state Exp;
branches;
next	1.17;

1.17
date	2012.12.19.07.12.02;	author brobecke;	state Exp;
branches;
next	1.16;

1.16
date	2012.05.24.16.51.45;	author palves;	state Exp;
branches;
next	1.15;

1.15
date	2011.04.16.18.16.36;	author vapier;	state Exp;
branches;
next	1.14;

1.14
date	2011.02.14.05.14.28;	author vapier;	state Exp;
branches;
next	1.13;

1.13
date	2010.04.14.07.38.05;	author vapier;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.28.18.33.03;	author mmitchel;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.11.21.58.57;	author schwab;	state Exp;
branches
	1.11.10.1;
next	1.10;

1.10
date	2004.08.05.00.17.52;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.04.18.09.34;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.04.17.04.36;	author jimb;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.20.13.32.34;	author cagney;	state Exp;
branches
	1.7.14.1
	1.7.24.1;
next	1.6;

1.6
date	2003.02.27.23.26.34;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.09.15.45.51;	author cagney;	state Exp;
branches
	1.5.8.1
	1.5.10.1;
next	1.4;

1.4
date	2002.04.15.16.32.55;	author ezannoni;	state Exp;
branches
	1.4.4.1
	1.4.6.1;
next	1.3;

1.3
date	2001.12.15.05.08.44;	author mrg;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.08.01.52.41;	author chastain;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.11;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.11.10.1
date	2005.11.17.06.22.44;	author mmitchel;	state Exp;
branches;
next	;

1.7.14.1
date	2004.09.16.17.02.13;	author drow;	state Exp;
branches;
next	;

1.7.24.1
date	2004.09.01.17.39.06;	author jimb;	state Exp;
branches;
next	;

1.5.8.1
date	2003.03.06.00.56.42;	author carlton;	state Exp;
branches;
next	1.5.8.2;

1.5.8.2
date	2003.06.27.21.50.37;	author carlton;	state Exp;
branches;
next	;

1.5.10.1
date	2003.12.14.20.28.29;	author drow;	state Exp;
branches;
next	;

1.4.4.1
date	2002.06.15.16.43.31;	author cagney;	state Exp;
branches;
next	;

1.4.6.1
date	2002.06.20.01.40.55;	author kseitz;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.35.11;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.33.34;	author shebs;	state Exp;
branches;
next	;


desc
@@


1.19
log
@gdb:

2013-03-15  Steve Ellcey  <sellcey@@mips.com>

	* remote-sim.c (sim_command_completer): Make char arguments const.

include:


2013-03-15  Steve Ellcey  <sellcey@@mips.com>

	* gdb/remote-sim.h (sim_command_completer): Make char arguments const.

sim:

2013-03-15  Steve Ellcey  <sellcey@@mips.com>

	* arm/wrapper.c (sim_complete_command): Make char arguments const.
	* avr/interp.c (sim_complete_command): Ditto.
	* common/sim-options.c (sim_complete_command): Ditto.
	* cr16/interp.c (sim_complete_command): Ditto.
	* erc32/interf.c (sim_complete_command): Ditto.
	* m32c/gdb-if.c (sim_complete_command): Ditto.
	* microblaze/interp.c (sim_complete_command): Ditto.
	* ppc/sim_calls.c (sim_complete_command): Ditto.
	* rl78/gdb-if.c (sim_complete_command): Ditto.
	* rx/gdb-if.c (sim_complete_command): Ditto.
	* sh/interp.c (sim_complete_command): Ditto.
@
text
@/*  This file is part of the program psim.

    Copyright 1994, 1995, 1996, 1998, 2003 Andrew Cagney

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, see <http://www.gnu.org/licenses/>.
 
    */


#include <signal.h> /* FIXME - should be machine dependant version */
#include <stdarg.h>
#include <ctype.h>

#include "psim.h"
#include "options.h"

#undef printf_filtered /* blow away the mapping */

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#ifdef HAVE_STRING_H
#include <string.h>
#else
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif
#endif

#include "libiberty.h"
#include "bfd.h"
#include "gdb/callback.h"
#include "gdb/remote-sim.h"
#include "gdb/signals.h"

/* Define the rate at which the simulator should poll the host
   for a quit. */
#ifndef POLL_QUIT_INTERVAL
#define POLL_QUIT_INTERVAL 0x20
#endif

static int poll_quit_count = POLL_QUIT_INTERVAL;

/* Structures used by the simulator, for gdb just have static structures */

psim *simulator;
static device *root_device;
static host_callback *callbacks;

SIM_DESC
sim_open (SIM_OPEN_KIND kind,
	  host_callback *callback,
	  struct bfd *abfd,
	  char **argv)
{
  callbacks = callback;

  /* Note: The simulation is not created by sim_open() because
     complete information is not yet available */
  /* trace the call */
  TRACE(trace_gdb, ("sim_open called\n"));

  if (root_device != NULL)
    sim_io_printf_filtered("Warning - re-open of simulator leaks memory\n");
  root_device = psim_tree();
  simulator = NULL;

  psim_options(root_device, argv + 1);

  if (ppc_trace[trace_opts])
    print_options ();

  /* fudge our descriptor for now */
  return (SIM_DESC) 1;
}


void
sim_close (SIM_DESC sd, int quitting)
{
  TRACE(trace_gdb, ("sim_close(quitting=%d) called\n", quitting));
  if (ppc_trace[trace_print_info] && simulator != NULL)
    psim_print_info (simulator, ppc_trace[trace_print_info]);
}


SIM_RC
sim_load (SIM_DESC sd, char *prog, bfd *abfd, int from_tty)
{
  TRACE(trace_gdb, ("sim_load(prog=%s, from_tty=%d) called\n",
		    prog, from_tty));
  ASSERT(prog != NULL);

  /* create the simulator */
  TRACE(trace_gdb, ("sim_load() - first time, create the simulator\n"));
  simulator = psim_create(prog, root_device);

  /* bring in all the data section */
  psim_init(simulator);

  /* get the start address */
  if (abfd == NULL)
    {
      abfd = bfd_openr (prog, 0);
      if (abfd == NULL)
	error ("psim: can't open \"%s\": %s\n", 
	       prog, bfd_errmsg (bfd_get_error ()));
      if (!bfd_check_format (abfd, bfd_object)) 
	{
	  const char *errmsg = bfd_errmsg (bfd_get_error ());
	  bfd_close (abfd);
	  error ("psim: \"%s\" is not an object file: %s\n",
		 prog, errmsg);
	}
      bfd_close (abfd);
    }

  return SIM_RC_OK;
}


int
sim_read (SIM_DESC sd, SIM_ADDR mem, unsigned char *buf, int length)
{
  int result = psim_read_memory(simulator, MAX_NR_PROCESSORS,
				buf, mem, length);
  TRACE(trace_gdb, ("sim_read(mem=0x%lx, buf=0x%lx, length=%d) = %d\n",
		    (long)mem, (long)buf, length, result));
  return result;
}


int
sim_write (SIM_DESC sd, SIM_ADDR mem, const unsigned char *buf, int length)
{
  int result = psim_write_memory(simulator, MAX_NR_PROCESSORS,
				 buf, mem, length,
				 1/*violate_ro*/);
  TRACE(trace_gdb, ("sim_write(mem=0x%lx, buf=0x%lx, length=%d) = %d\n",
		    (long)mem, (long)buf, length, result));
  return result;
}

void
sim_info (SIM_DESC sd, int verbose)
{
  TRACE(trace_gdb, ("sim_info(verbose=%d) called\n", verbose));
  psim_print_info (simulator, verbose);
}


SIM_RC
sim_create_inferior (SIM_DESC sd,
		     struct bfd *abfd,
		     char **argv,
		     char **envp)
{
  unsigned_word entry_point;
  TRACE(trace_gdb, ("sim_create_inferior(start_address=0x%x, ...)\n",
		    entry_point));

  if (simulator == NULL)
    error ("No program loaded");

  if (abfd != NULL)
    entry_point = bfd_get_start_address (abfd);
  else
    entry_point = 0xfff00000; /* ??? */

  psim_init(simulator);
  psim_stack(simulator, argv, envp);

  ASSERT (psim_write_register(simulator, -1 /* all start at same PC */,
			      &entry_point, "pc", cooked_transfer) > 0);
  return SIM_RC_OK;
}


void
sim_stop_reason (SIM_DESC sd, enum sim_stop *reason, int *sigrc)
{
  psim_status status = psim_get_status(simulator);

  switch (status.reason) {
  case was_continuing:
    *reason = sim_stopped;
    if (status.signal == 0)
      *sigrc = GDB_SIGNAL_TRAP;
    else
      *sigrc = status.signal;
    break;
  case was_trap:
    *reason = sim_stopped;
    *sigrc = GDB_SIGNAL_TRAP;
    break;
  case was_exited:
    *reason = sim_exited;
    *sigrc = status.signal;
    break;
  case was_signalled:
    *reason = sim_signalled;
    *sigrc = status.signal;
    break;
  }

  TRACE(trace_gdb, ("sim_stop_reason(reason=0x%lx(%ld), sigrc=0x%lx(%ld))\n",
		    (long)reason, (long)*reason, (long)sigrc, (long)*sigrc));
}



/* Run (or resume) the program.  */

int
sim_stop (SIM_DESC sd)
{
  psim_stop (simulator);
  return 1;
}

void
sim_resume (SIM_DESC sd, int step, int siggnal)
{
  TRACE(trace_gdb, ("sim_resume(step=%d, siggnal=%d)\n",
		    step, siggnal));

  if (step)
    {
      psim_step (simulator);
    }
  else
    {
      psim_run (simulator);
    }
}

void
sim_do_command (SIM_DESC sd, char *cmd)
{
  TRACE(trace_gdb, ("sim_do_commands(cmd=%s) called\n",
		    cmd ? cmd : "(null)"));
  if (cmd != NULL) {
    char **argv = buildargv(cmd);
    psim_command(root_device, argv);
    freeargv(argv);
  }
}

char **
sim_complete_command (SIM_DESC sd, const char *text, const char *word)
{
  return NULL;
}

/* Polling, if required */

void
sim_io_poll_quit (void)
{
  if (callbacks->poll_quit != NULL && poll_quit_count-- < 0)
    {
      poll_quit_count = POLL_QUIT_INTERVAL;
      if (callbacks->poll_quit (callbacks))
	psim_stop (simulator);
    }
}



/* Map simulator IO operations onto the corresponding GDB I/O
   functions.
   
   NB: Only a limited subset of operations are mapped across.  More
   advanced operations (such as dup or write) must either be mapped to
   one of the below calls or handled internally */

int
sim_io_read_stdin(char *buf,
		  int sizeof_buf)
{
  switch (CURRENT_STDIO) {
  case DO_USE_STDIO:
    return callbacks->read_stdin(callbacks, buf, sizeof_buf);
    break;
  case DONT_USE_STDIO:
    return callbacks->read(callbacks, 0, buf, sizeof_buf);
    break;
  default:
    error("sim_io_read_stdin: unaccounted switch\n");
    break;
  }
  return 0;
}

int
sim_io_write_stdout(const char *buf,
		    int sizeof_buf)
{
  switch (CURRENT_STDIO) {
  case DO_USE_STDIO:
    return callbacks->write_stdout(callbacks, buf, sizeof_buf);
    break;
  case DONT_USE_STDIO:
    return callbacks->write(callbacks, 1, buf, sizeof_buf);
    break;
  default:
    error("sim_io_write_stdout: unaccounted switch\n");
    break;
  }
  return 0;
}

int
sim_io_write_stderr(const char *buf,
		    int sizeof_buf)
{
  switch (CURRENT_STDIO) {
  case DO_USE_STDIO:
    /* NB: I think there should be an explicit write_stderr callback */
    return callbacks->write(callbacks, 3, buf, sizeof_buf);
    break;
  case DONT_USE_STDIO:
    return callbacks->write(callbacks, 3, buf, sizeof_buf);
    break;
  default:
    error("sim_io_write_stderr: unaccounted switch\n");
    break;
  }
  return 0;
}


void
sim_io_printf_filtered(const char *fmt,
		       ...)
{
  char message[1024];
  va_list ap;
  /* format the message */
  va_start(ap, fmt);
  vsprintf(message, fmt, ap);
  va_end(ap);
  /* sanity check */
  if (strlen(message) >= sizeof(message))
    error("sim_io_printf_filtered: buffer overflow\n");
  callbacks->printf_filtered(callbacks, "%s", message);
}

void
sim_io_flush_stdoutput(void)
{
  switch (CURRENT_STDIO) {
  case DO_USE_STDIO:
    callbacks->flush_stdout (callbacks);
    break;
  case DONT_USE_STDIO:
    break;
  default:
    error("sim_io_read_stdin: unaccounted switch\n");
    break;
  }
}

void
sim_io_error (SIM_DESC sd, const char *fmt, ...)
{
  va_list ap;
  va_start(ap, fmt);
  callbacks->evprintf_filtered (callbacks, fmt, ap);
  va_end(ap);
  callbacks->error (callbacks, "");
}

/****/

void *
zalloc(long size)
{
  void *memory = (void*)xmalloc(size);
  if (memory == NULL)
    error("xmalloc failed\n");
  memset(memory, 0, size);
  return memory;
}
@


1.18
log
@[sim] Update old contact info in GPL license notices

sim/ChangeLog:

        Update old contact info in GPL license notices.
@
text
@d262 1
a262 1
sim_complete_command (SIM_DESC sd, char *text, char *word)
@


1.17
log
@Update sim copyright headers from GPLv2-or-later to GPLv3-or-later.

gdb/sim/ChangeLog:

        Update the non-FSF-copyrighted files in sim to GPLv3 or later.
@
text
@d16 1
a16 2
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@


1.16
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        * gdb/signals.def: Replace TARGET_SIGNAL_ with GDB_SIGNAL_
	throughout.

sim/arm/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/avr/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/cr16/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/d10v/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/erc32/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/m32c/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/ppc/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rl78/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rx/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.
@
text
@d7 1
a7 1
    the Free Software Foundation; either version 2 of the License, or
@


1.15
log
@sim: add sim_complete_command stubs for non-common-using ports

For the ports that don't use the common/ subdir, we need to add stub funcs
to them to avoid build failures with gdb and command completion.  These do
not implement the actual completion functionality ... any port that wants
that can either convert to the common/ subdir, or fill out the function on
their own time.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d201 1
a201 1
      *sigrc = TARGET_SIGNAL_TRAP;
d207 1
a207 1
    *sigrc = TARGET_SIGNAL_TRAP;
@


1.14
log
@sim: punt zfree()

The sim keeps track of which allocations are zero-ed internally (via
zalloc) and then calls a helper "zfree" function rather than "free".
But this "zfree" function simply calls "free" itself.  Since I can
see no point in this and it is simply useless overhead, punt it.

The only real change is in hw-alloc.c where we remove the zalloc_p
tracking, and sim-utils.c where zfree is delete.  The rest of the
changes are a simple `sed` from "zfree" to "free".

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d262 5
@


1.13
log
@sim: constify sim_write source buffer (part 2)

As pointed out by Sandra Loosemore, a bunch of targets define sim_write
themselves instead of using the common/ code.  So constify them too.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@a392 5

void zfree(void *data)
{
  free(data);
}
@


1.12
log
@	* remote-sim.c (gdbsim_wait): Pass target signal numbers to
	sim_resume.  Expect target signal numbers from sim_stop_reason.

	* wrapper.c (gdb/signals.h): Include it.
	(SIGTRAP): Don't define.
	(SIGBUS): Likewise.
	(sim_stop_reason): Use TARGET_SIGNAL_* instead of SIG*.

	* sim-reason.c (sim_stop_reason): Use
	sim_signal_to_target, not sim_signal_to_host.
	* sim-signal.c (sim_signal_to_host): Fix typo.
	(sim_signal_to_target): New function.

	* interp.c (gdb/signals.h): Include it.
	(sim_stop_reason): Use TARGET_SIGNAL_*.

	* interf.c: (gdb/signals.h): Include it.
	(sim_stop_reason): Use TARGET_SIGNAL_*.

	* sim_calls.c (gdb/signals.h): Include it.
	(sim_stop_reason): Use TARGET_SIGNAL_*.
	* psim.c (cntrl_c_simulation): Use TARGET_SIGNAL_*.
@
text
@d147 1
a147 1
sim_write (SIM_DESC sd, SIM_ADDR mem, unsigned char *buf, int length)
@


1.11
log
@sim/erc32:
	* interf.c: Include "libiberty.h" instead of declaring buildargv
	ourselves.

sim/ppc:
	* sim_calls.c: Include "libiberty.h".
@
text
@d47 1
d201 1
a201 1
      *sigrc = SIGTRAP;
d207 1
a207 1
    *sigrc = SIGTRAP;
@


1.11.10.1
log
@	* gdb/remote-sim.c (gdbsim_wait): Don't use target_signal_to_host
	or target_signal_from_host.
	* sim/arm/wrapper.c (gdb/signals.h): Include it.
	(SIGTRAP): Don't define it.
	(SIGBUS): Likewise.
	(sim_stop_reason): Use TARGET_SIGNAL_*.
	* sim/common/sim-reason.c (sim_stop_reason): Use
	sim_signal_to_target, not sim_signal_to_host.
	* sim/common/sim-signal.c (sim_signal_to_host): Fix typo.
	(sim_signal_to_target): New function.
	* sim/common/sim-signal.h: Declare it.
	* sim/d10v/interp.c (gdb/signals.h): Include it.
	(sim_stop_reason): Use TARGET_SIGNAL_*.
	* sim/erc32/interf.c: (gdb/signals.h): Include it.
	(sim_stop_reason): Use TARGET_SIGNAL_*.
	* sim/ppc/sim_calls.c (gdb/signals.h): Include it.
	(sim_stop_reason): Use TARGET_SIGNAL_*.
@
text
@a46 1
#include "gdb/signals.h"
d200 1
a200 1
      *sigrc = TARGET_SIGNAL_TRAP;
d206 1
a206 1
    *sigrc = TARGET_SIGNAL_TRAP;
@


1.10
log
@2004-08-04  Andrew Cagney  <cagney@@gnu.org>
	    Jim Blandy <jimb@@redhat.com>

	* sim_callbacks.h (simulator): Declare.
	* Makefile.in (gdb-sim.o): New rule.
	(MAIN_SRC, GDB_OBJ): Add gdb-sim.o, gdb-sim.c.
	(DEFS_H): Delete.
	(GDB_SIM_PPC_H): Define.
	* gdb-sim.c: New file.
	* sim_calls.c: Do not include "defs.h".
	(simulator): Drop static.
	(sim_store_register, sim_fetch_register): Delete.
@
text
@d43 1
@


1.9
log
@2004-08-04  Andrew Cagney  <cagney@@gnu.org>

	* Back out accidently committed change.
@
text
@a42 1
#include "defs.h"
d57 1
a57 1
static psim *simulator;
a60 23
/* We use GDB's gdbarch_register_name function to map GDB register
   numbers onto names, which we can then look up in the register
   table.  Since the `set architecture' command can select a new
   processor variant at run-time, the meanings of the register numbers
   can change, so we need to make sure the sim uses the same
   name/number mapping that GDB uses.

   (We don't use the REGISTER_NAME macro, which is a wrapper for
   gdbarch_register_name.  We #include GDB's "defs.h", which tries to
   #include GDB's "config.h", but gets ours instead, and REGISTER_NAME
   ends up not getting defined.  Simpler to just use
   gdbarch_register_name directly.)

   We used to just use the REGISTER_NAMES macro from GDB's
   target-dependent header files, which expanded into an initializer
   for an array of strings.  That was kind of nice, because it meant
   that libsim.a had only a compile-time dependency on GDB; using
   gdbarch_register_name directly means that there are now link-time
   and run-time dependencies too.

   Perhaps the host_callback structure could provide a function for
   retrieving register names; that would be cleaner.  */

a154 48

int
sim_fetch_register (SIM_DESC sd, int regno, unsigned char *buf, int length)
{
  const char *regname;

  if (simulator == NULL) {
    return 0;
  }

  /* GDB will sometimes ask for the contents of a register named "";
     we ignore such requests, and leave garbage in *BUF.  In GDB
     terms, the empty string means "the register with this number is
     not present in the currently selected architecture variant."
     That's following the kludge we're using for the MIPS processors.
     But there are loops that just walk through the entire list of
     names and try to get everything.  */
  regname = gdbarch_register_name (current_gdbarch, regno);
  if (! regname || regname[0] == '\0')
    return -1;

  TRACE(trace_gdb, ("sim_fetch_register(regno=%d(%s), buf=0x%lx)\n",
		    regno, regname, (long)buf));
  return psim_read_register(simulator, MAX_NR_PROCESSORS,
			    buf, regname, raw_transfer);
}


int
sim_store_register (SIM_DESC sd, int regno, unsigned char *buf, int length)
{
  const char *regname;

  if (simulator == NULL)
    return 0;

  /* See comments in sim_fetch_register, above.  */
  regname = gdbarch_register_name (current_gdbarch, regno);
  if (! regname || regname[0] == '\0')
    return -1;

  TRACE(trace_gdb, ("sim_store_register(regno=%d(%s), buf=0x%lx)\n",
		    regno, regname, (long)buf));
  return psim_write_register(simulator, MAX_NR_PROCESSORS,
			     buf, regname, raw_transfer);
}


@


1.8
log
@gdb/ChangeLog:
2004-07-20  Jim Blandy  <jimb@@redhat.com>

	Use a fixed register numbering when communicating with the PowerPC
	simulator.
	* ppc-tdep.h (struct gdbarch_tdep): New member: 'sim_regno'.
	* rs6000-tdep.c: #include "sim-regno.h" and "gdb/sim-ppc.h".
	(set_sim_regno, init_sim_regno_table, rs6000_register_sim_regno):
	New functions.
	(rs6000_gdbarch_init): Register rs6000_register_sim_regno.  Call
	init_sim_regno_table.
	* Makefile.in (gdb_sim_ppc_h): New variable.
	(rs6000-tdep.o): Update dependencies.

include/gdb/ChangeLog:
2004-07-20  Jim Blandy  <jimb@@redhat.com>

	* sim-ppc.h: New file.

sim/ppc/ChangeLog:
2004-07-20  Jim Blandy  <jimb@@redhat.com>

	Use a fixed register numbering when communicating with the PowerPC
	simulator.
	* sim_calls.c: #include "registers.h" and "gdb/sim-ppc.h"; do not
	include GDB's "defs.h".
	(gdb_register_name_table): New variable.
	(gdb_register_name_table_size): New enum constant.
	(gdb_register_name): New function.
	(sim_fetch_register, sim_store_register): Use gdb_register_name,
	instead of calling gdbarch_register_name.
	* Makefile.in (GDB_SIM_PPC_H): New variable.
	(DEFS_H): Delete variable.
	(sim_calls.o): Update dependencies.
@
text
@a27 1
#include "registers.h"
d43 1
a46 1
#include "gdb/sim-ppc.h"
d62 23
a179 76
/* A table mapping register numbers (as received from GDB) to register
   names.  This table does not handle special-purpose registers: the
   SPR whose number is N is assigned the register number
   sim_ppc_spr0_regnum + N.  */
static const char *gdb_register_name_table[] = {

  /* General-purpose registers: 0 .. 31.  */
  "r0",   "r1",  "r2",  "r3",  "r4",  "r5",  "r6",  "r7", 
  "r8",   "r9", "r10", "r11", "r12", "r13", "r14", "r15", 
  "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23", 
  "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31", 

  /* Floating-point registers: 32 .. 63.  */
  "f0",   "f1",  "f2",  "f3",  "f4",  "f5",  "f6",  "f7", 
  "f8",   "f9", "f10", "f11", "f12", "f13", "f14", "f15", 
  "f16", "f17", "f18", "f19", "f20", "f21", "f22", "f23", 
  "f24", "f25", "f26", "f27", "f28", "f29", "f30", "f31",

  /* Altivec registers: 64 .. 95.  */
  "vr0",   "vr1",  "vr2",  "vr3",  "vr4",  "vr5",  "vr6",  "vr7", 
  "vr8",   "vr9", "vr10", "vr11", "vr12", "vr13", "vr14", "vr15", 
  "vr16", "vr17", "vr18", "vr19", "vr20", "vr21", "vr22", "vr23", 
  "vr24", "vr25", "vr26", "vr27", "vr28", "vr29", "vr30", "vr31", 
  
  /* SPE APU GPR upper halves: 96 .. 127.  */
  "rh0",   "rh1",  "rh2",  "rh3",  "rh4",  "rh5",  "rh6",  "rh7", 
  "rh8",   "rh9", "rh10", "rh11", "rh12", "rh13", "rh14", "rh15", 
  "rh16", "rh17", "rh18", "rh19", "rh20", "rh21", "rh22", "rh23", 
  "rh24", "rh25", "rh26", "rh27", "rh28", "rh29", "rh30", "rh31", 

  /* SPE APU full 64-bit vector registers: 128 .. 159.  */
  "ev0",   "ev1",  "ev2",  "ev3",  "ev4",  "ev5",  "ev6",  "ev7", 
  "ev8",   "ev9", "ev10", "ev11", "ev12", "ev13", "ev14", "ev15", 
  "ev16", "ev17", "ev18", "ev19", "ev20", "ev21", "ev22", "ev23", 
  "ev24", "ev25", "ev26", "ev27", "ev28", "ev29", "ev30", "ev31", 

  /* Segment registers: 160 .. 175.  */
  "sr0", "sr1",  "sr2",  "sr3",  "sr4",  "sr5",  "sr6",  "sr7", 
  "sr8", "sr9", "sr10", "sr11", "sr12", "sr13", "sr14", "sr15", 

  /* Miscellaneous (not special-purpose!) registers: 176 .. 181.  */
  "pc", "ps", "cr", "fpscr", "acc", "vscr"
};

enum {
  gdb_register_name_table_size = (sizeof (gdb_register_name_table)
                                  / sizeof (gdb_register_name_table[0])),
};


/* Return the name of the register whose number is REGNUM, or zero if
   REGNUM is an invalid register number.  */
static const char *
gdb_register_name (int regnum)
{
  /* Is it a special-purpose register?  */
  if (sim_ppc_spr0_regnum <= regnum
      && regnum < sim_ppc_spr0_regnum + sim_ppc_num_sprs)
    {
      int spr = regnum - sim_ppc_spr0_regnum;
      if (spr_is_valid (spr))
        return spr_name (spr);
      else
        return 0;
    }

  /* Is it a valid non-SPR register number?  */
  else if (0 <= regnum && regnum < gdb_register_name_table_size)
    return gdb_register_name_table[regnum];

  /* Not a valid register number at all.  */
  else
    return 0;
}


d189 9
a197 5
  regname = gdb_register_name (regno);

  /* Occasionally, GDB will pass invalid register numbers to us; it
     wants us to ignore them.  */
  if (! regname)
d215 3
a217 5
  regname = gdb_register_name (regno);

  /* Occasionally, GDB will pass invalid register numbers to us; it
     wants us to ignore them.  */
  if (! regname)
@


1.7
log
@2003-06-20  Andrew Cagney  <cagney@@redhat.com>

	* sim_calls.c (sim_create_inferior): Assert that
	psim_write_register succeeded.
	(sim_fetch_register, sim_store_register): Make "regname" constant.
	Delete Altivec hack.  Return result from psim_read_register /
	psim_write_register.
	* psim.h (psim_read_register, psim_write_register): Change return
	type to int.  Update comments.
	* psim.c: Update copyright.
	(psim_stack): Assert that the psim_read_register worked.
	(psim_read_register, psim_read_register): Return the register's
	size.  Allocate the cooked buffer dynamically.
	* hw_register.c: Update copyright.
	(do_register_init): Check that psim_write_register succeeded.
	* hw_init.c: Update copyright.
	(create_ppc_elf_stack_frame, create_ppc_aix_stack_frame): Assert
	that the register transfer worked.
@
text
@d28 1
a43 1
#include "defs.h"
d47 1
a62 23
/* We use GDB's gdbarch_register_name function to map GDB register
   numbers onto names, which we can then look up in the register
   table.  Since the `set architecture' command can select a new
   processor variant at run-time, the meanings of the register numbers
   can change, so we need to make sure the sim uses the same
   name/number mapping that GDB uses.

   (We don't use the REGISTER_NAME macro, which is a wrapper for
   gdbarch_register_name.  We #include GDB's "defs.h", which tries to
   #include GDB's "config.h", but gets ours instead, and REGISTER_NAME
   ends up not getting defined.  Simpler to just use
   gdbarch_register_name directly.)

   We used to just use the REGISTER_NAMES macro from GDB's
   target-dependent header files, which expanded into an initializer
   for an array of strings.  That was kind of nice, because it meant
   that libsim.a had only a compile-time dependency on GDB; using
   gdbarch_register_name directly means that there are now link-time
   and run-time dependencies too.

   Perhaps the host_callback structure could provide a function for
   retrieving register names; that would be cleaner.  */

d158 76
d243 5
a247 9
  /* GDB will sometimes ask for the contents of a register named "";
     we ignore such requests, and leave garbage in *BUF.  In GDB
     terms, the empty string means "the register with this number is
     not present in the currently selected architecture variant."
     That's following the kludge we're using for the MIPS processors.
     But there are loops that just walk through the entire list of
     names and try to get everything.  */
  regname = gdbarch_register_name (current_gdbarch, regno);
  if (! regname || regname[0] == '\0')
d265 5
a269 3
  /* See comments in sim_fetch_register, above.  */
  regname = gdbarch_register_name (current_gdbarch, regno);
  if (! regname || regname[0] == '\0')
@


1.7.14.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d43 1
d58 1
a58 1
psim *simulator;
d62 23
d179 48
@


1.7.24.1
log
@gdb/ChangeLog:
2004-08-25  Jim Blandy  <jimb@@redhat.com>

	Merge changes from trunk:

	2004-08-09  Jim Blandy  <jimb@@redhat.com>

	* rs6000-tdep.c (set_sim_regno, init_sim_regno_table,
	rs6000_register_sim_regno): Doc fixes.

	2004-08-04  Jim Blandy  <jimb@@redhat.com>

	* ppc-linux-nat.c (fetch_register): Replace 'gdb_assert (0)' with
	a call to 'internal_error', with a more helpful error message.
	* rs6000-tdep.c (e500_pseudo_register_read,
	e500_pseudo_register_write, rs6000_store_return_value): Same.

	Change the layout of the PowerPC E500 raw register cache to allow
	the lower 32-bit halves of the GPRS to be their own raw registers,
	not pseudoregisters.
	* ppc-tdep.h (struct gdbarch_tdep): Remove ppc_gprs_pseudo_p flag;
	add ppc_ev0_upper_regnum flag.
	* rs6000-tdep.c: #include "reggroups.h".
	(spe_register_p): Recognize the ev upper half registers as SPE
	registers.
	(init_sim_regno_table): Build gdb->sim mappings for the upper-half
	registers.
	(e500_move_ev_register): New function.
	(e500_pseudo_register_read, e500_pseudo_register_write): The 'ev'
	vector registers are the pseudo-registers now, formed by splicing
	together the gprs and the upper-half registers.
	(e500_register_reggroup_p): New function.
	(P): Macro deleted.
	(P8, A4): New macro.
	(PPC_EV_REGS, PPC_GPRS_PSEUDO_REGS): Macros deleted.
	(PPC_SPE_GP_REGS, PPC_SPE_UPPER_GP_REGS, PPC_EV_PSEUDO_REGS): New
	macros.
	(registers_e500): Rearrange register set so that the raw register
	set contains 32-bit GPRs and upper-half registers, and the SPE
	vector registers become pseudo-registers.
	(rs6000_gdbarch_init): Don't initialize tdep->ppc_gprs_pseudo_p;
	it has been deleted.  Initialize ppc_ev0_upper_regnum.  Many other
	register numbers are now the same for the E500 as they are for
	other PowerPC variants.  Register e500_register_reggroup_p as the
	register group function for the E500.
	* Makefile.in (rs6000-tdep.o): Update dependencies.

	Adapt PPC E500 native support to the new raw regcache layout.
	* ppc-linux-nat.c (struct gdb_evrregset_t): Doc fixes.
	(read_spliced_spe_reg, write_spliced_spe_reg): Deleted.
	(fetch_spe_register, store_spe_register): Handle fetching/storing
	all the SPE registers at once, if regno == -1.  These now take
	over the job of fetch_spe_registers and store_spe_registers.
	(fetch_spe_registers, store_spe_registers): Deleted.
	(fetch_ppc_registers, store_ppc_registers): Fetch/store gprs
	unconditionally; they're always raw.  Fetch/store SPE upper half
	registers, if present, instead of ev registers.
	(fetch_register, store_register): Remove sanity checks: gprs are
	never pseudo-registers now, so we never need to even mention any
	registers that are ever pseudoregisters.

	Use a fixed register numbering when communicating with the PowerPC
	simulator.
	* ppc-tdep.h (struct gdbarch_tdep): New member: 'sim_regno'.
	* rs6000-tdep.c: #include "sim-regno.h" and "gdb/sim-ppc.h".
	(set_sim_regno, init_sim_regno_table, rs6000_register_sim_regno):
	New functions.
	(rs6000_gdbarch_init): Register rs6000_register_sim_regno.  Call
	init_sim_regno_table.
	* Makefile.in (gdb_sim_ppc_h): New variable.
	(rs6000-tdep.o): Update dependencies.

	2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	Replace DEPRECATED_REGISTER_RAW_SIZE with register_size.
	* rs6000-tdep.c (rs6000_push_dummy_call)
	(rs6000_extract_return_value): Use register_size.
	...
	* ppc-linux-nat.c (fetch_altivec_register, fetch_register)
	(supply_vrregset, store_altivec_register, fill_vrregset): Ditto.

	2004-07-20  Jim Blandy  <jimb@@redhat.com>

	* rs6000-tdep.c (rs6000_gdbarch_init): The register set used for
	bfd_mach_ppc has no segment registers.

	Include PowerPC SPR numbers for special-purpose registers.
	* rs6000-tdep.c (struct reg): Add new member, 'spr_num'.
	(R, R4, R8, R16, F, P, R32, R64, R0): Include value for
	new member in initializer.
	(S, S4, SN4, S64): New macros for defining special-purpose
	registers.
	(PPC_UISA_SPRS, PPC_UISA_NOFP_SPRS, PPC_OEA_SPRS, registers_power,
	registers_403, registers_403GC, registers_505, registers_860,
	registers_601, registers_602, registers_603, registers_604,
	registers_750, registers_e500): Use them.

	* rs6000-tdep.c (rs6000_gdbarch_init): Delete variable 'power';
	replace references with expression used to initialize variable.

	2004-07-16  Jim Blandy  <jimb@@redhat.com>

	* ppc-tdep.h (ppc_spr_asr): Add missing OEA SPR.
        (ppc_spr_mi_dbcam, ppc_spr_mi_dbram0, ppc_spr_mi_dbram1)
	(ppc_spr_md_cam, ppc_spr_md_ram0, ppc_spr_md_ram1): Add
	missing MPC823 SPRs.
	(ppc_spr_m_twb): Renamed from ppc_spr_md_twb; the old name was
	incorrect.  (This was corrected in GDB's register name tables on
	2004-07-14.)

	* rs6000-tdep.c (registers_602): Correct register name: "esassr"
	should be "esasrr" ("ESA Save and Restore Register").

	2004-07-15  Jim Blandy  <jimb@@redhat.com>

	* ppc-tdep.h (struct gdbarch_tdep): New member: ppc_sr0_regnum.
	* rs6000-tdep.c (rs6000_gdbarch_init): Initialize it.

	2004-07-14  Jim Blandy  <jimb@@redhat.com>

	* rs6000-tdep.c (COMMON_UISA_NOFP_REGS): Delete; unused.

	* ppc-tdep.h (ppc_num_vrs): New enum constant.

	* ppc-tdep.h (ppc_num_srs): New enum constant.

	* ppc-tdep.h (ppc_spr_mq, ppc_spr_xer, ppc_spr_rtcu, ppc_spr_rtcl)
	(ppc_spr_lr, ppc_spr_ctr, ppc_spr_cnt, ppc_spr_dsisr, ppc_spr_dar)
	(ppc_spr_dec, ppc_spr_sdr1, ppc_spr_srr0, ppc_spr_srr1)
	(ppc_spr_eie, ppc_spr_eid, ppc_spr_nri, ppc_spr_sp, ppc_spr_cmpa)
	(ppc_spr_cmpb, ppc_spr_cmpc, ppc_spr_cmpd, ppc_spr_icr)
	(ppc_spr_der, ppc_spr_counta, ppc_spr_countb, ppc_spr_cmpe)
	(ppc_spr_cmpf, ppc_spr_cmpg, ppc_spr_cmph, ppc_spr_lctrl1)
	(ppc_spr_lctrl2, ppc_spr_ictrl, ppc_spr_bar, ppc_spr_vrsave)
	(ppc_spr_sprg0, ppc_spr_sprg1, ppc_spr_sprg2, ppc_spr_sprg3)
	(ppc_spr_ear, ppc_spr_tbl, ppc_spr_tbu, ppc_spr_pvr)
	(ppc_spr_spefscr, ppc_spr_ibat0u, ppc_spr_ibat0l, ppc_spr_ibat1u)
	(ppc_spr_ibat1l, ppc_spr_ibat2u, ppc_spr_ibat2l, ppc_spr_ibat3u)
	(ppc_spr_ibat3l, ppc_spr_dbat0u, ppc_spr_dbat0l, ppc_spr_dbat1u)
	(ppc_spr_dbat1l, ppc_spr_dbat2u, ppc_spr_dbat2l, ppc_spr_dbat3u)
	(ppc_spr_dbat3l, ppc_spr_ic_cst, ppc_spr_ic_adr, ppc_spr_ic_dat)
	(ppc_spr_dc_cst, ppc_spr_dc_adr, ppc_spr_dc_dat, ppc_spr_dpdr)
	(ppc_spr_dpir, ppc_spr_immr, ppc_spr_mi_ctr, ppc_spr_mi_ap)
	(ppc_spr_mi_epn, ppc_spr_mi_twc, ppc_spr_mi_rpn, ppc_spr_mi_cam)
	(ppc_spr_mi_ram0, ppc_spr_mi_ram1, ppc_spr_md_ctr, ppc_spr_m_casid)
	(ppc_spr_md_ap, ppc_spr_md_epn, ppc_spr_md_twb, ppc_spr_md_twc)
	(ppc_spr_md_rpn, ppc_spr_m_tw, ppc_spr_md_dbcam, ppc_spr_md_dbram0)
	(ppc_spr_md_dbram1, ppc_spr_ummcr0, ppc_spr_upmc1, ppc_spr_upmc2)
	(ppc_spr_usia, ppc_spr_ummcr1, ppc_spr_upmc3, ppc_spr_upmc4)
	(ppc_spr_zpr, ppc_spr_pid, ppc_spr_mmcr0, ppc_spr_pmc1)
	(ppc_spr_sgr, ppc_spr_pmc2, ppc_spr_dcwr, ppc_spr_sia)
	(ppc_spr_mmcr1, ppc_spr_pmc3, ppc_spr_pmc4, ppc_spr_sda)
	(ppc_spr_tbhu, ppc_spr_tblu, ppc_spr_dmiss, ppc_spr_dcmp)
	(ppc_spr_hash1, ppc_spr_hash2, ppc_spr_icdbdr, ppc_spr_imiss)
	(ppc_spr_esr, ppc_spr_icmp, ppc_spr_dear, ppc_spr_rpa)
	(ppc_spr_evpr, ppc_spr_cdbcr, ppc_spr_tsr, ppc_spr_602_tcr)
	(ppc_spr_403_tcr, ppc_spr_ibr, ppc_spr_pit, ppc_spr_esasrr)
	(ppc_spr_tbhi, ppc_spr_tblo, ppc_spr_srr2, ppc_spr_sebr)
	(ppc_spr_srr3, ppc_spr_ser, ppc_spr_hid0, ppc_spr_dbsr)
	(ppc_spr_hid1, ppc_spr_iabr, ppc_spr_dbcr, ppc_spr_iac1)
	(ppc_spr_dabr, ppc_spr_iac2, ppc_spr_dac1, ppc_spr_dac2)
	(ppc_spr_l2cr, ppc_spr_dccr, ppc_spr_ictc, ppc_spr_iccr)
	(ppc_spr_thrm1, ppc_spr_pbl1, ppc_spr_thrm2, ppc_spr_pbu1)
	(ppc_spr_thrm3, ppc_spr_pbl2, ppc_spr_fpecr, ppc_spr_lt)
	(ppc_spr_pir, ppc_spr_pbu2): New enum constants for PowerPC
	special-purpose register numbers.

	* rs6000-tdep.c (registers_860): Correct register name.  (No PPC
	manual mentions 'md_twb', but many mention 'm_twb', and at that
	point in the register list.)

include/gdb/ChangeLog:
2004-08-04  Andrew Cagney  <cagney@@gnu.org>

	* sim-ppc.h: Add extern "C" wrapper.
	(enum sim_ppc_regnum): Add full list of SPRs.

2004-08-04  Jim Blandy  <jimb@@redhat.com>

	* sim-ppc.h: New file.

sim/ppc/ChangeLog:
2004-08-04  Andrew Cagney  <cagney@@gnu.org>
	    Jim Blandy <jimb@@redhat.com>

	* sim_callbacks.h (simulator): Declare.
	* Makefile.in (gdb-sim.o): New rule.
	(MAIN_SRC, GDB_OBJ): Add gdb-sim.o, gdb-sim.c.
	(DEFS_H): Delete.
	(GDB_SIM_PPC_H): Define.
	* gdb-sim.c: New file.
	* sim_calls.c: Do not include "defs.h".
	(simulator): Drop static.
	(sim_store_register, sim_fetch_register): Delete.
@
text
@d43 1
d58 1
a58 1
psim *simulator;
d62 23
d179 48
@


1.6
log
@Index: arm/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* wrapper.c (sim_create_inferior, sim_open): Rename _bfd to bfd.

Index: common/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim-utils.h (sim_analyze_program, sim_load_file): Rename _bfd to bfd.
	* sim-hload.c (sim_load), sim-base.h (sim_state_base): Ditto.
	* nrun.c (main): Ditto.

Index: d10v/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: erc32/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interf.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: h8300/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* compile.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: h8500/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* compile.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: i960/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim-if.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: m32r/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim-if.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: m68hc11/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_prepare_for_program, sim_open)
	(sim_create_inferior): Rename _bfd to bfd.

Index: mcore/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: mips/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open):
	(sim_create_inferior):

Index: mn10200/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: mn10300/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior, sim_open)
	(sim_create_inferior): Rename _bfd to bfd.

Index: ppc/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim_calls.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: sh/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (init_dsp, sim_open, sim_create_inferior): Rename _bfd
	to bfd.

Index: v850/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: z8k/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* iface.c (sim_open, sim_create_inferior): Rename _bfd to bfd.
@
text
@d3 1
a3 1
    Copyright (C) 1994-1996,1998, Andrew Cagney <cagney@@highland.com.au>
d183 1
a183 1
  char *regname;
d197 1
a197 5
  /* FIXME: ezannoni 2002/04/15 Remove the 'vr' and 'vscr' check
     once AltiVec support is committed.  */
  if (! regname || regname[0] == '\0'
      || (regname[0] == 'v' && regname[1] == 'r')
      || (strcmp (regname, "vscr") == 0))
d202 2
a203 3
  psim_read_register(simulator, MAX_NR_PROCESSORS,
		     buf, regname, raw_transfer);
  return -1;
d210 1
a210 1
  char *regname;
d217 1
a217 5
  /* FIXME: ezannoni 2002/04/15 Remove the 'vr' and 'vscr' check
     once AltiVec support is committed.  */
  if (! regname || regname[0] == '\0'
      || (regname[0] == 'v' && regname[1] == 'r')
      || (strcmp (regname, "vscr") == 0))
d222 2
a223 3
  psim_write_register(simulator, MAX_NR_PROCESSORS,
		      buf, regname, raw_transfer);
  return -1;
d256 2
a257 2
  psim_write_register(simulator, -1 /* all start at same PC */,
		      &entry_point, "pc", cooked_transfer);
@


1.5
log
@Move include/callback.h and include/remote-sim.h to include/gdb/.
Update accordingly.
@
text
@d88 1
a88 1
	  struct _bfd *abfd,
d247 1
a247 1
		     struct _bfd *abfd,
@


1.5.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
    Copyright 1994, 1995, 1996, 1998, 2003 Andrew Cagney
d88 1
a88 1
	  struct bfd *abfd,
d183 1
a183 1
  const char *regname;
d197 5
a201 1
  if (! regname || regname[0] == '\0')
d206 3
a208 2
  return psim_read_register(simulator, MAX_NR_PROCESSORS,
			    buf, regname, raw_transfer);
d215 1
a215 1
  const char *regname;
d222 5
a226 1
  if (! regname || regname[0] == '\0')
d231 3
a233 2
  return psim_write_register(simulator, MAX_NR_PROCESSORS,
			     buf, regname, raw_transfer);
d247 1
a247 1
		     struct bfd *abfd,
d266 2
a267 2
  ASSERT (psim_write_register(simulator, -1 /* all start at same PC */,
			      &entry_point, "pc", cooked_transfer) > 0);
@


1.5.8.1
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d88 1
a88 1
	  struct bfd *abfd,
d247 1
a247 1
		     struct bfd *abfd,
@


1.5.8.2
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d3 1
a3 1
    Copyright 1994, 1995, 1996, 1998, 2003 Andrew Cagney
d183 1
a183 1
  const char *regname;
d197 5
a201 1
  if (! regname || regname[0] == '\0')
d206 3
a208 2
  return psim_read_register(simulator, MAX_NR_PROCESSORS,
			    buf, regname, raw_transfer);
d215 1
a215 1
  const char *regname;
d222 5
a226 1
  if (! regname || regname[0] == '\0')
d231 3
a233 2
  return psim_write_register(simulator, MAX_NR_PROCESSORS,
			     buf, regname, raw_transfer);
d266 2
a267 2
  ASSERT (psim_write_register(simulator, -1 /* all start at same PC */,
			      &entry_point, "pc", cooked_transfer) > 0);
@


1.4
log
@2002-04-15  Elena Zannoni  <ezannoni@@redhat.com>

        * sim_calls.c (sim_fetch_register, sim_store_register): Return -1 for
        AltiVec registers as a temporary stopgap.
@
text
@d45 2
a46 2
#include "callback.h"
#include "remote-sim.h"
@


1.4.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d45 2
a46 2
#include "gdb/callback.h"
#include "gdb/remote-sim.h"
@


1.4.4.1
log
@merge from trunk
@
text
@d45 2
a46 2
#include "gdb/callback.h"
#include "gdb/remote-sim.h"
@


1.3
log
@	* main.c: Include "defs.h", "bfd.h", "callback.h" and "remote-sim.h".
	(sim_io_error): New function.
	* sim_calls.c: (sim_io_error): New function.
@
text
@d197 5
a201 1
  if (! regname || regname[0] == '\0')
d222 5
a226 1
  if (! regname || regname[0] == '\0')
@


1.2
log
@2000-11-15  Jim Blandy  <jimb@@redhat.com>

	* sim_calls.c: Doc fix.
	(sim_fetch_register, sim_store_register): Call
	gdbarch_register_name directly, instead of going through
	REGISTER_NAME macro.
@
text
@d444 10
@


1.1
log
@Initial revision
@
text
@d48 7
d62 19
a80 13
/* We use GDB's reg_names array to map GDB register numbers onto
   names, which we can then look up in the register table.

   We used to just use the REGISTER_NAMES macro, from GDB's
   target-dependent header files.  That was kind of nice, because it
   meant that libsim.a had only a compile-time dependency on GDB;
   using reg_names directly means that there are now link-time and
   run-time dependencies too.

   However, the GDB PPC back-end now modifies the reg_names array when
   the user runs the `set processor' command, which affects the
   meanings of the register numbers.  So the sim needs to see the
   register names GDB is actually using.
d82 2
a83 2
   Perhaps the host_callback structure could contain a pointer to the
   register name table; that would be cleaner.  */
d190 7
a196 7
     we ignore such requests, and leave garbage in *BUF.  In
     REG_NAMES, the empty string means "the register with this
     number is not present in the currently selected architecture
     variant."  That's following the kludge we're using for the MIPS
     processors.  But there are loops that just walk through the
     entire list of names and try to get everything.  */
  regname = REGISTER_NAME (regno);
d217 1
a217 1
  regname = REGISTER_NAME (regno);
d340 1
a340 1
  if (callbacks->poll_quit != NULL)
d342 1
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a47 7
/* Define the rate at which the simulator should poll the host
   for a quit. */
#ifndef POLL_QUIT_INTERVAL
#define POLL_QUIT_INTERVAL 0x20
#endif

static int poll_quit_count = POLL_QUIT_INTERVAL;
d327 1
a327 1
  if (callbacks->poll_quit != NULL && poll_quit_count-- < 0)
a328 1
      poll_quit_count = POLL_QUIT_INTERVAL;
@

