head	1.10;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.10
	gdb_7_6-2013-04-26-release:1.10
	gdb_7_6-branch:1.10.0.2
	gdb_7_6-2013-03-12-branchpoint:1.10
	gdb_7_5_1-2012-11-29-release:1.8
	gdb_7_5-2012-08-17-release:1.8
	gdb_7_5-branch:1.8.0.6
	gdb_7_5-2012-07-18-branchpoint:1.8
	gdb_7_4_1-2012-04-26-release:1.8
	gdb_7_4-2012-01-24-release:1.8
	gdb_7_4-branch:1.8.0.4
	gdb_7_4-2011-12-13-branchpoint:1.8
	gdb_7_3_1-2011-09-04-release:1.8
	gdb_7_3-2011-07-26-release:1.8
	gdb_7_3-branch:1.8.0.2
	gdb_7_3-2011-04-01-branchpoint:1.8
	gdb_7_2-2010-09-02-release:1.7
	gdb_7_2-branch:1.7.0.46
	gdb_7_2-2010-07-07-branchpoint:1.7
	gdb_7_1-2010-03-18-release:1.7
	gdb_7_1-branch:1.7.0.44
	gdb_7_1-2010-02-18-branchpoint:1.7
	gdb_7_0_1-2009-12-22-release:1.7
	gdb_7_0-2009-10-06-release:1.7
	gdb_7_0-branch:1.7.0.42
	gdb_7_0-2009-09-16-branchpoint:1.7
	arc-sim-20090309:1.7
	msnyder-checkpoint-072509-branch:1.7.0.40
	msnyder-checkpoint-072509-branchpoint:1.7
	arc-insight_6_8-branch:1.7.0.38
	arc-insight_6_8-branchpoint:1.7
	insight_6_8-branch:1.7.0.36
	insight_6_8-branchpoint:1.7
	reverse-20081226-branch:1.7.0.34
	reverse-20081226-branchpoint:1.7
	multiprocess-20081120-branch:1.7.0.32
	multiprocess-20081120-branchpoint:1.7
	reverse-20080930-branch:1.7.0.30
	reverse-20080930-branchpoint:1.7
	reverse-20080717-branch:1.7.0.28
	reverse-20080717-branchpoint:1.7
	msnyder-reverse-20080609-branch:1.7.0.26
	msnyder-reverse-20080609-branchpoint:1.7
	drow-reverse-20070409-branch:1.7.0.24
	drow-reverse-20070409-branchpoint:1.7
	gdb_6_8-2008-03-27-release:1.7
	gdb_6_8-branch:1.7.0.22
	gdb_6_8-2008-02-26-branchpoint:1.7
	gdb_6_7_1-2007-10-29-release:1.7
	gdb_6_7-2007-10-10-release:1.7
	gdb_6_7-branch:1.7.0.20
	gdb_6_7-2007-09-07-branchpoint:1.7
	insight_6_6-20070208-release:1.7
	gdb_6_6-2006-12-18-release:1.7
	gdb_6_6-branch:1.7.0.18
	gdb_6_6-2006-11-15-branchpoint:1.7
	insight_6_5-20061003-release:1.7
	gdb-csl-symbian-6_4_50_20060226-12:1.7
	gdb-csl-sourcerygxx-3_4_4-25:1.5.12.2
	nickrob-async-20060828-mergepoint:1.7
	gdb-csl-symbian-6_4_50_20060226-11:1.7
	gdb-csl-sourcerygxx-4_1-17:1.7
	gdb-csl-20060226-branch-local-2:1.7
	gdb-csl-sourcerygxx-4_1-14:1.7
	gdb-csl-sourcerygxx-4_1-13:1.7
	gdb-csl-sourcerygxx-4_1-12:1.7
	gdb-csl-sourcerygxx-3_4_4-21:1.7
	gdb_6_5-20060621-release:1.7
	gdb-csl-sourcerygxx-4_1-9:1.7
	gdb-csl-sourcerygxx-4_1-8:1.7
	gdb-csl-sourcerygxx-4_1-7:1.7
	gdb-csl-arm-2006q1-6:1.7
	gdb-csl-sourcerygxx-4_1-6:1.7
	gdb-csl-symbian-6_4_50_20060226-10:1.7
	gdb-csl-symbian-6_4_50_20060226-9:1.7
	gdb-csl-symbian-6_4_50_20060226-8:1.7
	gdb-csl-coldfire-4_1-11:1.7
	gdb-csl-sourcerygxx-3_4_4-19:1.7
	gdb-csl-coldfire-4_1-10:1.7
	gdb_6_5-branch:1.7.0.16
	gdb_6_5-2006-05-14-branchpoint:1.7
	gdb-csl-sourcerygxx-4_1-5:1.7
	nickrob-async-20060513-branch:1.7.0.14
	nickrob-async-20060513-branchpoint:1.7
	gdb-csl-sourcerygxx-4_1-4:1.7
	msnyder-reverse-20060502-branch:1.7.0.12
	msnyder-reverse-20060502-branchpoint:1.7
	gdb-csl-morpho-4_1-4:1.7
	gdb-csl-sourcerygxx-3_4_4-17:1.7
	readline_5_1-import-branch:1.7.0.10
	readline_5_1-import-branchpoint:1.7
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.7
	gdb-csl-symbian-20060226-branch:1.7.0.8
	gdb-csl-symbian-20060226-branchpoint:1.7
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.7
	msnyder-reverse-20060331-branch:1.7.0.6
	msnyder-reverse-20060331-branchpoint:1.7
	gdb-csl-available-20060303-branch:1.7.0.4
	gdb-csl-available-20060303-branchpoint:1.7
	gdb-csl-20060226-branch:1.7.0.2
	gdb-csl-20060226-branchpoint:1.7
	gdb_6_4-20051202-release:1.5
	msnyder-fork-checkpoint-branch:1.5.0.14
	msnyder-fork-checkpoint-branchpoint:1.5
	gdb-csl-gxxpro-6_3-branch:1.5.0.12
	gdb-csl-gxxpro-6_3-branchpoint:1.5
	gdb_6_4-branch:1.5.0.10
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb-csl-arm-20051020-branch:1.5.0.8
	gdb-csl-arm-20051020-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.6
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb-csl-arm-20050325-2005-q1b:1.5
	gdb-csl-arm-20050325-2005-q1a:1.5
	csl-arm-20050325-branch:1.5.0.4
	csl-arm-20050325-branchpoint:1.5
	gdb_6_3-20041109-release:1.5
	gdb_6_3-branch:1.5.0.2
	gdb_6_3-20041019-branchpoint:1.5
	drow_intercu-merge-20040921:1.4
	drow_intercu-merge-20040915:1.4
	jimb-gdb_6_2-e500-branch:1.4.0.18
	jimb-gdb_6_2-e500-branchpoint:1.4
	gdb_6_2-20040730-release:1.4
	gdb_6_2-branch:1.4.0.14
	gdb_6_2-2004-07-10-gmt-branchpoint:1.4
	gdb_6_1_1-20040616-release:1.4
	gdb_6_1-2004-04-05-release:1.4
	drow_intercu-merge-20040402:1.4
	drow_intercu-merge-20040327:1.4
	ezannoni_pie-20040323-branch:1.4.0.12
	ezannoni_pie-20040323-branchpoint:1.4
	cagney_tramp-20040321-mergepoint:1.4
	cagney_tramp-20040309-branch:1.4.0.10
	cagney_tramp-20040309-branchpoint:1.4
	gdb_6_1-branch:1.4.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.4
	drow_intercu-20040221-branch:1.4.0.6
	drow_intercu-20040221-branchpoint:1.4
	cagney_bfdfile-20040213-branch:1.4.0.4
	cagney_bfdfile-20040213-branchpoint:1.4
	drow-cplus-merge-20040208:1.4
	carlton_dictionary-20040126-merge:1.4
	cagney_bigcore-20040122-branch:1.4.0.2
	cagney_bigcore-20040122-branchpoint:1.4
	drow-cplus-merge-20040113:1.4
	drow-cplus-merge-20031224:1.4
	drow-cplus-merge-20031220:1.4
	carlton_dictionary-20031215-merge:1.4
	drow-cplus-merge-20031214:1.4
	carlton-dictionary-20031111-merge:1.4
	gdb_6_0-2003-10-04-release:1.3
	kettenis_sparc-20030918-branch:1.3.0.64
	kettenis_sparc-20030918-branchpoint:1.3
	carlton_dictionary-20030917-merge:1.3
	ezannoni_pie-20030916-branchpoint:1.3
	ezannoni_pie-20030916-branch:1.3.0.62
	cagney_x86i386-20030821-branch:1.3.0.60
	cagney_x86i386-20030821-branchpoint:1.3
	carlton_dictionary-20030805-merge:1.3
	carlton_dictionary-20030627-merge:1.3
	gdb_6_0-branch:1.3.0.58
	gdb_6_0-2003-06-23-branchpoint:1.3
	jimb-ppc64-linux-20030613-branch:1.3.0.56
	jimb-ppc64-linux-20030613-branchpoint:1.3
	cagney_convert-20030606-branch:1.3.0.54
	cagney_convert-20030606-branchpoint:1.3
	cagney_writestrings-20030508-branch:1.3.0.52
	cagney_writestrings-20030508-branchpoint:1.3
	jimb-ppc64-linux-20030528-branch:1.3.0.50
	jimb-ppc64-linux-20030528-branchpoint:1.3
	carlton_dictionary-20030523-merge:1.3
	cagney_fileio-20030521-branch:1.3.0.48
	cagney_fileio-20030521-branchpoint:1.3
	kettenis_i386newframe-20030517-mergepoint:1.3
	jimb-ppc64-linux-20030509-branch:1.3.0.46
	jimb-ppc64-linux-20030509-branchpoint:1.3
	kettenis_i386newframe-20030504-mergepoint:1.3
	carlton_dictionary-20030430-merge:1.3
	kettenis_i386newframe-20030419-branch:1.3.0.44
	kettenis_i386newframe-20030419-branchpoint:1.3
	carlton_dictionary-20030416-merge:1.3
	cagney_frameaddr-20030409-mergepoint:1.3
	kettenis_i386newframe-20030406-branch:1.3.0.42
	kettenis_i386newframe-20030406-branchpoint:1.3
	cagney_frameaddr-20030403-branchpoint:1.3
	cagney_frameaddr-20030403-branch:1.3.0.40
	cagney_framebase-20030330-mergepoint:1.3
	cagney_framebase-20030326-branch:1.3.0.38
	cagney_framebase-20030326-branchpoint:1.3
	cagney_lazyid-20030317-branch:1.3.0.36
	cagney_lazyid-20030317-branchpoint:1.3
	kettenis-i386newframe-20030316-mergepoint:1.3
	offbyone-20030313-branch:1.3.0.34
	offbyone-20030313-branchpoint:1.3
	kettenis-i386newframe-20030308-branch:1.3.0.32
	kettenis-i386newframe-20030308-branchpoint:1.3
	carlton_dictionary-20030305-merge:1.3
	cagney_offbyone-20030303-branch:1.3.0.30
	cagney_offbyone-20030303-branchpoint:1.3
	carlton_dictionary-20030207-merge:1.3
	interps-20030202-branch:1.3.0.28
	interps-20030202-branchpoint:1.3
	cagney-unwind-20030108-branch:1.3.0.26
	cagney-unwind-20030108-branchpoint:1.3
	carlton_dictionary-20021223-merge:1.3
	gdb_5_3-2002-12-12-release:1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.24
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	carlton_dictionary-branch:1.3.0.22
	carlton_dictionary-20020920-branchpoint:1.3
	gdb_5_3-branch:1.3.0.20
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.18
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.16
	readline_4_3-import-branchpoint:1.3
	gdb_5_2_1-2002-07-23-release:1.3
	kseitz_interps-20020528-branch:1.3.0.14
	kseitz_interps-20020528-branchpoint:1.3
	cagney_regbuf-20020515-branch:1.3.0.12
	cagney_regbuf-20020515-branchpoint:1.3
	jimb-macro-020506-branch:1.3.0.10
	jimb-macro-020506-branchpoint:1.3
	gdb_5_2-2002-04-29-release:1.3
	gdb_5_2-branch:1.3.0.8
	gdb_5_2-2002-03-03-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	cygnus_cvs_20020108_pre:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.4
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.2
	gdb_5_1-2001-07-29-branchpoint:1.3
	insight-precleanup-2001-01-01:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.10
date	2012.12.19.07.18.20;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2012.12.19.07.12.02;	author brobecke;	state Exp;
branches;
next	1.8;

1.8
date	2011.02.14.05.14.27;	author vapier;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.02.06.45.49;	author mmitchel;	state Exp;
branches;
next	1.6;

1.6
date	2005.11.28.23.19.39;	author mmitchel;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.24.18.39.41;	author cagney;	state Exp;
branches
	1.5.12.1;
next	1.4;

1.4
date	2003.10.17.00.15.25;	author msnyder;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.05.16.22.45;	author cagney;	state Exp;
branches
	1.3.22.1
	1.3.24.1;
next	1.2;

1.2
date	2001.01.15.23.24.30;	author geoffk;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.09;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.5.12.1
date	2005.11.17.06.22.44;	author mmitchel;	state Exp;
branches;
next	1.5.12.2;

1.5.12.2
date	2006.02.02.06.50.08;	author mmitchel;	state Exp;
branches;
next	;

1.3.22.1
date	2003.11.11.23.51.21;	author carlton;	state Exp;
branches;
next	;

1.3.24.1
date	2003.12.14.20.28.29;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.35.09;	author shebs;	state Exp;
branches;
next	;


desc
@@


1.10
log
@[sim] Update old contact info in GPL license notices

sim/ChangeLog:

        Update old contact info in GPL license notices.
@
text
@/*  This file is part of the program psim.

    Copyright (C) 1994-1998, Andrew Cagney <cagney@@highland.com.au>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, see <http://www.gnu.org/licenses/>.

    */


#ifndef _EMUL_NETBSD_C_
#define _EMUL_NETBSD_C_


/* Note: this module is called via a table.  There is no benefit in
   making it inline */

#include "emul_generic.h"
#include "emul_netbsd.h"

#ifdef HAVE_STRING_H
#include <string.h>
#else
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif
#endif

#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <signal.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/param.h>
#include <sys/time.h>

#ifdef HAVE_GETRUSAGE
#ifndef HAVE_SYS_RESOURCE_H
#undef HAVE_GETRUSAGE
#endif
#endif

#ifdef HAVE_GETRUSAGE
#include <sys/resource.h>
int getrusage();
#endif

#if HAVE_SYS_IOCTL_H
#include <sys/ioctl.h>
#endif

#if HAVE_DIRENT_H
# include <dirent.h>
# define NAMLEN(dirent) strlen((dirent)->d_name)
#else
# define dirent direct
# define NAMLEN(dirent) (dirent)->d_namlen
# if HAVE_SYS_NDIR_H
#  include <sys/ndir.h>
# endif
# if HAVE_SYS_DIR_H
#  include <sys/dir.h>
# endif
# if HAVE_NDIR_H
#  include <ndir.h>
# endif
#endif

#ifdef HAVE_UNISTD_H
#undef MAXPATHLEN		/* sys/param.h might define this also */
#include <unistd.h>
#endif

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#define WITH_NetBSD_HOST (NetBSD >= 199306)
#if WITH_NetBSD_HOST /* here NetBSD as that is what we're emulating */
#include <sys/syscall.h> /* FIXME - should not be including this one */
#include <sys/sysctl.h>
#include <sys/mount.h>
extern int getdirentries(int fd, char *buf, int nbytes, long *basep);

/* NetBSD post 2.0 has the statfs system call (if COMPAT_20), but does
   not have struct statfs.  In this case don't implement fstatfs.
   FIXME: Should implement fstatvfs.  */
#ifndef HAVE_STRUCT_STATFS
#undef HAVE_FSTATFS
#endif

#else

/* If this is not netbsd, don't allow fstatfs or getdirentries at this time */
#undef HAVE_FSTATFS
#undef HAVE_GETDIRENTRIES
#endif

#if (BSD < 199306) /* here BSD as just a bug */
extern int errno;
#endif

#ifndef STATIC_INLINE_EMUL_NETBSD
#define STATIC_INLINE_EMUL_NETBSD STATIC_INLINE
#endif


#if WITH_NetBSD_HOST
#define SYS(X) ASSERT(call == (SYS_##X))
#else
#define SYS(X)
#endif

#if WITH_NetBSD_HOST && (PATH_MAX != 1024)
#error "PATH_MAX not 1024"
#elif !defined(PATH_MAX)
#define PATH_MAX 1024
#endif


/* EMULATION

   NetBSD - Emulation of user programs for NetBSD/PPC

   DESCRIPTION

   */


/* NetBSD's idea of what is needed to implement emulations */

struct _os_emul_data {
  device *vm;
  emul_syscall *syscalls;
};



STATIC_INLINE_EMUL_NETBSD void
write_stat(unsigned_word addr,
	   struct stat buf,
	   cpu *processor,
	   unsigned_word cia)
{
  H2T(buf.st_dev);
  H2T(buf.st_ino);
  H2T(buf.st_mode);
  H2T(buf.st_nlink);
  H2T(buf.st_uid);
  H2T(buf.st_gid);
  H2T(buf.st_size);
  H2T(buf.st_atime);
  /* H2T(buf.st_spare1); */
  H2T(buf.st_mtime);
  /* H2T(buf.st_spare2); */
  H2T(buf.st_ctime);
  /* H2T(buf.st_spare3); */
#ifdef AC_STRUCT_ST_RDEV
  H2T(buf.st_rdev);
#endif
#ifdef AC_STRUCT_ST_BLKSIZE
  H2T(buf.st_blksize);
#endif
#ifdef AC_STRUCT_ST_BLOCKS
  H2T(buf.st_blocks);
#endif
#if WITH_NetBSD_HOST
  H2T(buf.st_flags);
  H2T(buf.st_gen);
#endif
  emul_write_buffer(&buf, addr, sizeof(buf), processor, cia);
}


#ifdef HAVE_FSTATFS
STATIC_INLINE_EMUL_NETBSD void
write_statfs(unsigned_word addr,
	     struct statfs buf,
	     cpu *processor,
	     unsigned_word cia)
{
  H2T(buf.f_type);
  H2T(buf.f_flags);
  H2T(buf.f_bsize);
  H2T(buf.f_iosize);
  H2T(buf.f_blocks);
  H2T(buf.f_bfree);
  H2T(buf.f_bavail);
  H2T(buf.f_files);
  H2T(buf.f_ffree);
  H2T(buf.f_fsid.val[0]);
  H2T(buf.f_fsid.val[1]);
  H2T(buf.f_owner);
  /* f_spare[4]; */
  /* f_fstypename[MFSNAMELEN]; */
  /* f_mntonname[MNAMELEN]; */
  /* f_mntfromname[MNAMELEN]; */
  emul_write_buffer(&buf, addr, sizeof(buf), processor, cia);
}
#endif


STATIC_INLINE_EMUL_NETBSD void
write_timeval(unsigned_word addr,
	      struct timeval t,
	      cpu *processor,
	      unsigned_word cia)
{
  H2T(t.tv_sec);
  H2T(t.tv_usec);
  emul_write_buffer(&t, addr, sizeof(t), processor, cia);
}

#ifdef HAVE_GETTIMEOFDAY
STATIC_INLINE_EMUL_NETBSD void
write_timezone(unsigned_word addr,
	       struct timezone tz,
	       cpu *processor,
	       unsigned_word cia)
{
  H2T(tz.tz_minuteswest);
  H2T(tz.tz_dsttime);
  emul_write_buffer(&tz, addr, sizeof(tz), processor, cia);
}
#endif

#ifdef HAVE_GETDIRENTRIES
STATIC_INLINE_EMUL_NETBSD void
write_direntries(unsigned_word addr,
		 char *buf,
		 int nbytes,
		 cpu *processor,
		 unsigned_word cia)
{
  while (nbytes > 0) {
    struct dirent *out;
    struct dirent *in = (struct dirent*)buf;
    ASSERT(in->d_reclen <= nbytes);
    out = (struct dirent*)zalloc(in->d_reclen);
    memcpy(out/*dest*/, in/*src*/, in->d_reclen);
    H2T(out->d_fileno);
    H2T(out->d_reclen);
    H2T(out->d_type);
    H2T(out->d_namlen);
    emul_write_buffer(out, addr, in->d_reclen, processor, cia);
    nbytes -= in->d_reclen;
    addr += in->d_reclen;
    buf += in->d_reclen;
    free(out);
  }
}
#endif


#ifdef HAVE_GETRUSAGE
STATIC_INLINE_EMUL_NETBSD void
write_rusage(unsigned_word addr,
	     struct rusage rusage,
	     cpu *processor,
	     unsigned_word cia)
{
  H2T(rusage.ru_utime.tv_sec); /* user time used */
  H2T(rusage.ru_utime.tv_usec);
  H2T(rusage.ru_stime.tv_sec); /* system time used */
  H2T(rusage.ru_stime.tv_usec);
  H2T(rusage.ru_maxrss);          /* integral max resident set size */
  H2T(rusage.ru_ixrss);           /* integral shared text memory size */
  H2T(rusage.ru_idrss);           /* integral unshared data size */
  H2T(rusage.ru_isrss);           /* integral unshared stack size */
  H2T(rusage.ru_minflt);          /* page reclaims */
  H2T(rusage.ru_majflt);          /* page faults */
  H2T(rusage.ru_nswap);           /* swaps */
  H2T(rusage.ru_inblock);         /* block input operations */
  H2T(rusage.ru_oublock);         /* block output operations */
  H2T(rusage.ru_msgsnd);          /* messages sent */
  H2T(rusage.ru_msgrcv);          /* messages received */
  H2T(rusage.ru_nsignals);        /* signals received */
  H2T(rusage.ru_nvcsw);           /* voluntary context switches */
  H2T(rusage.ru_nivcsw);          /* involuntary context switches */
  emul_write_buffer(&rusage, addr, sizeof(rusage), processor, cia);
}
#endif

static void
do_exit(os_emul_data *emul,
	unsigned call,
	const int arg0,
	cpu *processor,
	unsigned_word cia)
{
  int status = (int)cpu_registers(processor)->gpr[arg0];
  SYS(exit);
  if (WITH_TRACE && ppc_trace[trace_os_emul])
    printf_filtered ("%d)\n", status);

  cpu_halt(processor, cia, was_exited, status);
}


static void
do_read(os_emul_data *emul,
	unsigned call,
	const int arg0,
	cpu *processor,
	unsigned_word cia)
{
  void *scratch_buffer;
  int d = (int)cpu_registers(processor)->gpr[arg0];
  unsigned_word buf = cpu_registers(processor)->gpr[arg0+1];
  int nbytes = cpu_registers(processor)->gpr[arg0+2];
  int status;
  SYS(read);

  if (WITH_TRACE && ppc_trace[trace_os_emul])
    printf_filtered ("%d, 0x%lx, %d", d, (long)buf, nbytes);

  /* get a tempoary bufer */
  scratch_buffer = zalloc(nbytes);

  /* check if buffer exists by reading it */
  emul_read_buffer(scratch_buffer, buf, nbytes, processor, cia);

  /* read */
#if 0
  if (d == 0) {
    status = fread (scratch_buffer, 1, nbytes, stdin);
    if (status == 0 && ferror (stdin))
      status = -1;
  }
#endif
  status = read (d, scratch_buffer, nbytes);

  emul_write_status(processor, status, errno);
  if (status > 0)
    emul_write_buffer(scratch_buffer, buf, status, processor, cia);

  free(scratch_buffer);
}


static void
do_write(os_emul_data *emul,
	 unsigned call,
	 const int arg0,
	 cpu *processor,
	 unsigned_word cia)
{
  void *scratch_buffer = NULL;
  int d = (int)cpu_registers(processor)->gpr[arg0];
  unsigned_word buf = cpu_registers(processor)->gpr[arg0+1];
  int nbytes = cpu_registers(processor)->gpr[arg0+2];
  int status;
  SYS(write);

  if (WITH_TRACE && ppc_trace[trace_os_emul])
    printf_filtered ("%d, 0x%lx, %d", d, (long)buf, nbytes);

  /* get a tempoary bufer */
  scratch_buffer = zalloc(nbytes); /* FIXME - nbytes == 0 */

  /* copy in */
  emul_read_buffer(scratch_buffer, buf, nbytes,
		   processor, cia);

  /* write */
  status = write(d, scratch_buffer, nbytes);
  emul_write_status(processor, status, errno);
  free(scratch_buffer);

  flush_stdoutput();
}


static void
do_open(os_emul_data *emul,
	unsigned call,
	const int arg0,
	cpu *processor,
	unsigned_word cia)
{
  unsigned_word path_addr = cpu_registers(processor)->gpr[arg0];
  char path_buf[PATH_MAX];
  char *path = emul_read_string(path_buf, path_addr, PATH_MAX, processor, cia);
  int flags = (int)cpu_registers(processor)->gpr[arg0+1];
  int mode = (int)cpu_registers(processor)->gpr[arg0+2];
  int hostflags;
  int status;

  if (WITH_TRACE && ppc_trace[trace_os_emul])
    printf_filtered ("0x%lx [%s], 0x%x, 0x%x", (long)path_addr, path, flags, mode);

  SYS(open);

  /* Do some translation on 'flags' to match it to the host's version.  */
  /* These flag values were taken from the NetBSD 1.4 header files.  */
  if ((flags & 3) == 0)
    hostflags = O_RDONLY;
  else if ((flags & 3) == 1)
    hostflags = O_WRONLY;
  else
    hostflags = O_RDWR;
  if (flags & 0x00000008)
    hostflags |= O_APPEND;
  if (flags & 0x00000200)
    hostflags |= O_CREAT;
  if (flags & 0x00000400)
    hostflags |= O_TRUNC;
  if (flags & 0x00000800)
    hostflags |= O_EXCL;

  /* Can't combine these statements, cuz open sets errno. */
  status = open(path, hostflags, mode);
  emul_write_status(processor, status, errno);
}


static void
do_close(os_emul_data *emul,
	 unsigned call,
	 const int arg0,
	 cpu *processor,
	 unsigned_word cia)
{
  int d = (int)cpu_registers(processor)->gpr[arg0];
  int status;

  if (WITH_TRACE && ppc_trace[trace_os_emul])
    printf_filtered ("%d", d);

  SYS(close);

  /* Can't combine these statements, cuz close sets errno. */
  status = close(d);
  emul_write_status(processor, status, errno);
}


static void
do_break(os_emul_data *emul,
	 unsigned call,
	 const int arg0,
	 cpu *processor,
	 unsigned_word cia)
{
  /* just pass this onto the `vm' device */
  unsigned_word new_break = cpu_registers(processor)->gpr[arg0];
  int status;

  if (WITH_TRACE && ppc_trace[trace_os_emul])
    printf_filtered ("0x%lx", (long)cpu_registers(processor)->gpr[arg0]);

  SYS(break);
  status = device_ioctl(emul->vm,
			processor,
			cia,
			device_ioctl_break,
			new_break); /*ioctl-data*/
  emul_write_status(processor, 0, status);
}


#ifndef HAVE_GETPID
#define do_getpid 0
#else
static void
do_getpid(os_emul_data *emul,
	  unsigned call,
	  const int arg0,
	  cpu *processor,
	  unsigned_word cia)
{
  SYS(getpid);
  emul_write_status(processor, (int)getpid(), 0);
}
#endif

#ifndef HAVE_GETUID
#define do_getuid 0
#else
static void
do_getuid(os_emul_data *emul,
	  unsigned call,
	  const int arg0,
	  cpu *processor,
	  unsigned_word cia)
{
  SYS(getuid);
  emul_write_status(processor, (int)getuid(), 0);
}
#endif

#ifndef HAVE_GETEUID
#define do_geteuid 0
#else
static void
do_geteuid(os_emul_data *emul,
	   unsigned call,
	   const int arg0,
	   cpu *processor,
	   unsigned_word cia)
{
  SYS(geteuid);
  emul_write_status(processor, (int)geteuid(), 0);
}
#endif

#ifndef HAVE_KILL
#define do_kill 0
#else
static void
do_kill(os_emul_data *emul,
	unsigned call,
	const int arg0,
	cpu *processor,
	unsigned_word cia)
{
  pid_t pid = cpu_registers(processor)->gpr[arg0];
  int sig = cpu_registers(processor)->gpr[arg0+1];

  if (WITH_TRACE && ppc_trace[trace_os_emul])
    printf_filtered ("%d, %d", (int)pid, sig);

  SYS(kill);
  printf_filtered("SYS_kill at 0x%lx - more to this than just being killed\n",
		  (long)cia);
  cpu_halt(processor, cia, was_signalled, sig);
}
#endif

#ifndef HAVE_DUP
#define do_dup 0
#else
static void
do_dup(os_emul_data *emul,
       unsigned call,
       const int arg0,
       cpu *processor,
       unsigned_word cia)
{
  int oldd = cpu_registers(processor)->gpr[arg0];
  int status = dup(oldd);
  int err = errno;

  if (WITH_TRACE && ppc_trace[trace_os_emul])
    printf_filtered ("%d", oldd);

  SYS(dup);
  emul_write_status(processor, status, err);
}
#endif

#ifndef HAVE_GETEGID
#define do_getegid 0
#else
static void
do_getegid(os_emul_data *emul,
	   unsigned call,
	   const int arg0,
	   cpu *processor,
	   unsigned_word cia)
{
  SYS(getegid);
  emul_write_status(processor, (int)getegid(), 0);
}
#endif

#ifndef HAVE_GETGID
#define do_getgid 0
#else
static void
do_getgid(os_emul_data *emul,
	  unsigned call,
	  const int arg0,
	  cpu *processor,
	  unsigned_word cia)
{
  SYS(getgid);
  emul_write_status(processor, (int)getgid(), 0);
}
#endif

#ifndef HAVE_SIGPROCMASK
#define do_sigprocmask 0
#else
static void
do_sigprocmask(os_emul_data *emul,
	       unsigned call,
	       const int arg0,
	       cpu *processor,
	       unsigned_word cia)
{
  natural_word how = cpu_registers(processor)->gpr[arg0];
  unsigned_word set = cpu_registers(processor)->gpr[arg0+1];
  unsigned_word oset = cpu_registers(processor)->gpr[arg0+2];
#ifdef SYS_sigprocmask
  SYS(sigprocmask);
#endif

  if (WITH_TRACE && ppc_trace[trace_os_emul])
    printf_filtered ("%ld, 0x%ld, 0x%ld", (long)how, (long)set, (long)oset);

  emul_write_status(processor, 0, 0);
  cpu_registers(processor)->gpr[4] = set;
}
#endif

#ifndef HAVE_IOCTL
#define do_ioctl 0
#else
static void
do_ioctl(os_emul_data *emul,
	 unsigned call,
	 const int arg0,
	 cpu *processor,
	 unsigned_word cia)
{
  int d = cpu_registers(processor)->gpr[arg0];
  unsigned request = cpu_registers(processor)->gpr[arg0+1];
  unsigned_word argp_addr = cpu_registers(processor)->gpr[arg0+2];

#if !WITH_NetBSD_HOST
  cpu_registers(processor)->gpr[arg0] = 0; /* just succeed */
#else
  unsigned dir = request & IOC_DIRMASK;
  int status;
  SYS(ioctl);
  /* what we haven't done */
  if (dir & IOC_IN /* write into the io device */
      || dir & IOC_OUT
      || !(dir & IOC_VOID))
    error("do_ioctl() read or write of parameter not implemented\n");
  status = ioctl(d, request, NULL);
  emul_write_status(processor, status, errno);
#endif

  if (WITH_TRACE && ppc_trace[trace_os_emul])
    printf_filtered ("%d, 0x%x, 0x%lx", d, request, (long)argp_addr);
}
#endif

#ifndef HAVE_UMASK
#define do_umask 0
#else
static void
do_umask(os_emul_data *emul,
	 unsigned call,
	 const int arg0,
	 cpu *processor,
	 unsigned_word cia)
{
  int mask = cpu_registers(processor)->gpr[arg0];

  if (WITH_TRACE && ppc_trace[trace_os_emul])
    printf_filtered ("0%o", mask);

  SYS(umask);
  emul_write_status(processor, umask(mask), 0);
}
#endif

#ifndef HAVE_DUP2
#define do_dup2 0
#else
static void
do_dup2(os_emul_data *emul,
	unsigned call,
	const int arg0,
	cpu *processor,
	unsigned_word cia)
{
  int oldd = cpu_registers(processor)->gpr[arg0];
  int newd = cpu_registers(processor)->gpr[arg0+1];
  int status = dup2(oldd, newd);
  int err = errno;

  if (WITH_TRACE && ppc_trace[trace_os_emul])
    printf_filtered ("%d, %d", oldd, newd);

  SYS(dup2);
  emul_write_status(processor, status, err);
}
#endif

#ifndef HAVE_FCNTL
#define do_fcntl 0
#else
static void
do_fcntl(os_emul_data *emul,
	 unsigned call,
	 const int arg0,
	 cpu *processor,
	 unsigned_word cia)
{
  int fd = cpu_registers(processor)->gpr[arg0];
  int cmd = cpu_registers(processor)->gpr[arg0+1];
  int arg = cpu_registers(processor)->gpr[arg0+2];
  int status;

  if (WITH_TRACE && ppc_trace[trace_os_emul])
    printf_filtered ("%d, %d, %d", fd, cmd, arg);

  SYS(fcntl);
  status = fcntl(fd, cmd, arg);
  emul_write_status(processor, status, errno);
}
#endif

#ifndef HAVE_GETTIMEOFDAY
#define do_gettimeofday 0
#else
static void
do_gettimeofday(os_emul_data *emul,
		unsigned call,
		const int arg0,
		cpu *processor,
		unsigned_word cia)
{
  unsigned_word t_addr = cpu_registers(processor)->gpr[arg0];
  unsigned_word tz_addr = cpu_registers(processor)->gpr[arg0+1];
  struct timeval t;
  struct timezone tz;
  int status = gettimeofday((t_addr != 0 ? &t : NULL),
			    (tz_addr != 0 ? &tz : NULL));
  int err = errno;

  if (WITH_TRACE && ppc_trace[trace_os_emul])
    printf_filtered ("0x%lx, 0x%lx", (long)t_addr, (long)tz_addr);

  SYS(gettimeofday);
  emul_write_status(processor, status, err);
  if (status == 0) {
    if (t_addr != 0)
      write_timeval(t_addr, t, processor, cia);
    if (tz_addr != 0)
      write_timezone(tz_addr, tz, processor, cia);
  }
}
#endif

#ifndef HAVE_GETRUSAGE
#define do_getrusage 0
#else
static void
do_getrusage(os_emul_data *emul,
	     unsigned call,
	     const int arg0,
	     cpu *processor,
	     unsigned_word cia)
{
  int who = cpu_registers(processor)->gpr[arg0];
  unsigned_word rusage_addr = cpu_registers(processor)->gpr[arg0+1];
  struct rusage rusage;
  int status = getrusage(who, (rusage_addr != 0 ? &rusage : NULL));
  int err = errno;

  if (WITH_TRACE && ppc_trace[trace_os_emul])
    printf_filtered ("%d, 0x%lx", who, (long)rusage_addr);

  SYS(getrusage);
  emul_write_status(processor, status, err);
  if (status == 0) {
    if (rusage_addr != 0)
      write_rusage(rusage_addr, rusage, processor, cia);
  }
}
#endif


#ifndef HAVE_FSTATFS
#define do_fstatfs 0
#else
static void
do_fstatfs(os_emul_data *emul,
	   unsigned call,
	   const int arg0,
	   cpu *processor,
	   unsigned_word cia)
{
  int fd = cpu_registers(processor)->gpr[arg0];
  unsigned_word buf_addr = cpu_registers(processor)->gpr[arg0+1];
  struct statfs buf;
  int status;

  if (WITH_TRACE && ppc_trace[trace_os_emul])
    printf_filtered ("%d, 0x%lx", fd, (long)buf_addr);

  SYS(fstatfs);
  status = fstatfs(fd, (buf_addr == 0 ? NULL : &buf));
  emul_write_status(processor, status, errno);
  if (status == 0) {
    if (buf_addr != 0)
      write_statfs(buf_addr, buf, processor, cia);
  }
}
#endif

#ifndef HAVE_STAT
#define do_stat 0
#else
static void
do_stat(os_emul_data *emul,
	unsigned call,
	const int arg0,
	cpu *processor,
	unsigned_word cia)
{
  char path_buf[PATH_MAX];
  unsigned_word path_addr = cpu_registers(processor)->gpr[arg0];
  unsigned_word stat_buf_addr = cpu_registers(processor)->gpr[arg0+1];
  char *path = emul_read_string(path_buf, path_addr, PATH_MAX, processor, cia);
  struct stat buf;
  int status;
#ifdef SYS_stat
  SYS(stat);
#endif
  status = stat(path, &buf);
  emul_write_status(processor, status, errno);
  if (status == 0)
    write_stat(stat_buf_addr, buf, processor, cia);
}
#endif

#ifndef HAVE_FSTAT
#define do_fstat 0
#else
static void
do_fstat(os_emul_data *emul,
	 unsigned call,
	 const int arg0,
	 cpu *processor,
	 unsigned_word cia)
{
  int fd = cpu_registers(processor)->gpr[arg0];
  unsigned_word stat_buf_addr = cpu_registers(processor)->gpr[arg0+1];
  struct stat buf;
  int status;
#ifdef SYS_fstat
  SYS(fstat);
#endif
  /* Can't combine these statements, cuz fstat sets errno. */
  status = fstat(fd, &buf);
  emul_write_status(processor, status, errno);
  write_stat(stat_buf_addr, buf, processor, cia);
}
#endif

#ifndef HAVE_LSTAT
#define do_lstat 0
#else
static void
do_lstat(os_emul_data *emul,
	 unsigned call,
	 const int arg0,
	 cpu *processor,
	 unsigned_word cia)
{
  char path_buf[PATH_MAX];
  unsigned_word path_addr = cpu_registers(processor)->gpr[arg0];
  char *path = emul_read_string(path_buf, path_addr, PATH_MAX, processor, cia);
  unsigned_word stat_buf_addr = cpu_registers(processor)->gpr[arg0+1];
  struct stat buf;
  int status;
#ifdef SYS_lstat
  SYS(lstat);
#endif
  /* Can't combine these statements, cuz lstat sets errno. */
  status = lstat(path, &buf);
  emul_write_status(processor, status, errno);
  write_stat(stat_buf_addr, buf, processor, cia);
}
#endif

#ifndef HAVE_GETDIRENTRIES
#define do_getdirentries 0
#else
static void
do_getdirentries(os_emul_data *emul,
		 unsigned call,
		 const int arg0,
		 cpu *processor,
		 unsigned_word cia)
{
  int fd = cpu_registers(processor)->gpr[arg0];
  unsigned_word buf_addr = cpu_registers(processor)->gpr[arg0+1];
  char *buf;
  int nbytes = cpu_registers(processor)->gpr[arg0+2];
  unsigned_word basep_addr = cpu_registers(processor)->gpr[arg0+3];
  long basep;
  int status;
#ifdef SYS_getdirentries
  SYS(getdirentries);
#endif
  if (buf_addr != 0 && nbytes >= 0)
    buf = zalloc(nbytes);
  else
    buf = NULL;
  status = getdirentries(fd,
			 (buf_addr == 0 ? NULL : buf),
			 nbytes,
			 (basep_addr == 0 ? NULL : &basep));
  emul_write_status(processor, status, errno);
  if (basep_addr != 0)
    emul_write_word(basep_addr, basep, processor, cia);
  if (status > 0)
    write_direntries(buf_addr, buf, status, processor, cia);
  if (buf != NULL)
    free(buf);
}
#endif


static void
do___syscall(os_emul_data *emul,
	     unsigned call,
	     const int arg0,
	     cpu *processor,
	     unsigned_word cia)
{
  SYS(__syscall);
  emul_do_system_call(emul,
		      emul->syscalls,
		      cpu_registers(processor)->gpr[arg0],
		      arg0 + 1,
		      processor,
		      cia);
}

#ifndef HAVE_LSEEK
#define do_lseek 0
#else
static void
do_lseek(os_emul_data *emul,
	 unsigned call,
	 const int arg0,
	 cpu *processor,
	 unsigned_word cia)
{
  int fildes = cpu_registers(processor)->gpr[arg0];
  off_t offset = emul_read_gpr64(processor, arg0+2);
  int whence = cpu_registers(processor)->gpr[arg0+4];
  off_t status;
  SYS(lseek);
  status = lseek(fildes, offset, whence);
  if (status == -1)
    emul_write_status(processor, -1, errno);
  else {
    emul_write_status(processor, 0, 0); /* success */
    emul_write_gpr64(processor, 3, status);
  }
}
#endif

static void
do___sysctl(os_emul_data *emul,
	    unsigned call,
	    const int arg0,
	    cpu *processor,
	    unsigned_word cia)
{
  /* call the arguments by their real name */
  unsigned_word name = cpu_registers(processor)->gpr[arg0];
  natural_word namelen = cpu_registers(processor)->gpr[arg0+1];
  unsigned_word oldp = cpu_registers(processor)->gpr[arg0+2];
  unsigned_word oldlenp = cpu_registers(processor)->gpr[arg0+3];
  natural_word oldlen;
  natural_word mib;
  natural_word int_val;
  SYS(__sysctl);

  /* pluck out the management information base id */
  if (namelen < 1)
    error("system_call()SYS___sysctl bad name[0]\n");
  mib = vm_data_map_read_word(cpu_data_map(processor),
			      name,
			      processor,
			      cia);
  name += sizeof(mib);

  /* see what to do with it ... */
  switch ((int)mib) {
  case 6/*CTL_HW*/:
#if WITH_NetBSD_HOST && (CTL_HW != 6)
#  error "CTL_HW"
#endif
    if (namelen < 2)
      error("system_call()SYS___sysctl - CTL_HW - bad name[1]\n");
    mib = vm_data_map_read_word(cpu_data_map(processor),
				name,
				processor,
				cia);
    name += sizeof(mib);
    switch ((int)mib) {
    case 7/*HW_PAGESIZE*/:
#if WITH_NetBSD_HOST && (HW_PAGESIZE != 7)
#  error "HW_PAGESIZE"
#endif
      oldlen = vm_data_map_read_word(cpu_data_map(processor),
				     oldlenp,
				     processor,
				     cia);
      if (sizeof(natural_word) > oldlen)
	error("system_call()sysctl - CTL_HW.HW_PAGESIZE - to small\n");
      int_val = 8192;
      oldlen = sizeof(int_val);
      emul_write_word(oldp, int_val, processor, cia);
      emul_write_word(oldlenp, oldlen, processor, cia);
      break;
    default:
      error("sysctl() CTL_HW.%d unknown\n", mib);
      break;
    }
    break;
  default:
    error("sysctl() name[0]=%d unknown\n", (int)mib);
    break;
  }
  emul_write_status(processor, 0, 0); /* always succeed */
}



static emul_syscall_descriptor netbsd_descriptors[] = {
  /* 0 */ { 0, "syscall" },
  /* 1 */ { do_exit, "exit" },
  /* 2 */ { 0, "fork" },
  /* 3 */ { do_read, "read" },
  /* 4 */ { do_write, "write" },
  /* 5 */ { do_open, "open" },
  /* 6 */ { do_close, "close" },
  /* 7 */ { 0, "wait4" },
  { 0, }, /* 8 is old creat */
  /* 9 */ { 0, "link" },
  /* 10 */ { 0, "unlink" },
  { 0, }, /* 11 is obsolete execv */
  /* 12 */ { 0, "chdir" },
  /* 13 */ { 0, "fchdir" },
  /* 14 */ { 0, "mknod" },
  /* 15 */ { 0, "chmod" },
  /* 16 */ { 0, "chown" },
  /* 17 */ { do_break, "break" },
  /* 18 */ { 0, "getfsstat" },
  { 0, }, /* 19 is old lseek */
  /* 20 */ { do_getpid, "getpid" },
  /* 21 */ { 0, "mount" },
  /* 22 */ { 0, "unmount" },
  /* 23 */ { 0, "setuid" },
  /* 24 */ { do_getuid, "getuid" },
  /* 25 */ { do_geteuid, "geteuid" },
  /* 26 */ { 0, "ptrace" },
  /* 27 */ { 0, "recvmsg" },
  /* 28 */ { 0, "sendmsg" },
  /* 29 */ { 0, "recvfrom" },
  /* 30 */ { 0, "accept" },
  /* 31 */ { 0, "getpeername" },
  /* 32 */ { 0, "getsockname" },
  /* 33 */ { 0, "access" },
  /* 34 */ { 0, "chflags" },
  /* 35 */ { 0, "fchflags" },
  /* 36 */ { 0, "sync" },
  /* 37 */ { do_kill, "kill" },
  { 0, }, /* 38 is old stat */
  /* 39 */ { 0, "getppid" },
  { 0, }, /* 40 is old lstat */
  /* 41 */ { do_dup, "dup" },
  /* 42 */ { 0, "pipe" },
  /* 43 */ { do_getegid, "getegid" },
  /* 44 */ { 0, "profil" },
  /* 45 */ { 0, "ktrace" },
  /* 46 */ { 0, "sigaction" },
  /* 47 */ { do_getgid, "getgid" },
  /* 48 */ { do_sigprocmask, "sigprocmask" },
  /* 49 */ { 0, "getlogin" },
  /* 50 */ { 0, "setlogin" },
  /* 51 */ { 0, "acct" },
  /* 52 */ { 0, "sigpending" },
  /* 53 */ { 0, "sigaltstack" },
  /* 54 */ { do_ioctl, "ioctl" },
  /* 55 */ { 0, "reboot" },
  /* 56 */ { 0, "revoke" },
  /* 57 */ { 0, "symlink" },
  /* 58 */ { 0, "readlink" },
  /* 59 */ { 0, "execve" },
  /* 60 */ { do_umask, "umask" },
  /* 61 */ { 0, "chroot" },
  { 0, }, /* 62 is old fstat */
  { 0, }, /* 63 is old getkerninfo */
  { 0, }, /* 64 is old getpagesize */
  /* 65 */ { 0, "msync" },
  /* 66 */ { 0, "vfork" },
  { 0, }, /* 67 is obsolete vread */
  { 0, }, /* 68 is obsolete vwrite */
  /* 69 */ { 0, "sbrk" },
  /* 70 */ { 0, "sstk" },
  { 0, }, /* 71 is old mmap */
  /* 72 */ { 0, "vadvise" },
  /* 73 */ { 0, "munmap" },
  /* 74 */ { 0, "mprotect" },
  /* 75 */ { 0, "madvise" },
  { 0, }, /* 76 is obsolete vhangup */
  { 0, }, /* 77 is obsolete vlimit */
  /* 78 */ { 0, "mincore" },
  /* 79 */ { 0, "getgroups" },
  /* 80 */ { 0, "setgroups" },
  /* 81 */ { 0, "getpgrp" },
  /* 82 */ { 0, "setpgid" },
  /* 83 */ { 0, "setitimer" },
  { 0, }, /* 84 is old wait */
  /* 85 */ { 0, "swapon" },
  /* 86 */ { 0, "getitimer" },
  { 0, }, /* 87 is old gethostname */
  { 0, }, /* 88 is old sethostname */
  { 0, }, /* 89 is old getdtablesize */
  { do_dup2, "dup2" },
  { 0, }, /* 91 */
  /* 92 */ { do_fcntl, "fcntl" },
  /* 93 */ { 0, "select" },
  { 0, }, /* 94 */
  /* 95 */ { 0, "fsync" },
  /* 96 */ { 0, "setpriority" },
  /* 97 */ { 0, "socket" },
  /* 98 */ { 0, "connect" },
  { 0, }, /* 99 is old accept */
  /* 100 */ { 0, "getpriority" },
  { 0, }, /* 101 is old send */
  { 0, }, /* 102 is old recv */
  /* 103 */ { 0, "sigreturn" },
  /* 104 */ { 0, "bind" },
  /* 105 */ { 0, "setsockopt" },
  /* 106 */ { 0, "listen" },
  { 0, }, /* 107 is obsolete vtimes */
  { 0, }, /* 108 is old sigvec */
  { 0, }, /* 109 is old sigblock */
  { 0, }, /* 110 is old sigsetmask */
  /* 111 */ { 0, "sigsuspend" },
  { 0, }, /* 112 is old sigstack */
  { 0, }, /* 113 is old recvmsg */
  { 0, }, /* 114 is old sendmsg */
  /* - is obsolete vtrace */ { 0, "vtrace	115" },
  /* 116 */ { do_gettimeofday, "gettimeofday" },
  /* 117 */ { do_getrusage, "getrusage" },
  /* 118 */ { 0, "getsockopt" },
  /* 119 */ { 0, "resuba" },
  /* 120 */ { 0, "readv" },
  /* 121 */ { 0, "writev" },
  /* 122 */ { 0, "settimeofday" },
  /* 123 */ { 0, "fchown" },
  /* 124 */ { 0, "fchmod" },
  { 0, }, /* 125 is old recvfrom */
  { 0, }, /* 126 is old setreuid */
  { 0, }, /* 127 is old setregid */
  /* 128 */ { 0, "rename" },
  { 0, }, /* 129 is old truncate */
  { 0, }, /* 130 is old ftruncate */
  /* 131 */ { 0, "flock" },
  /* 132 */ { 0, "mkfifo" },
  /* 133 */ { 0, "sendto" },
  /* 134 */ { 0, "shutdown" },
  /* 135 */ { 0, "socketpair" },
  /* 136 */ { 0, "mkdir" },
  /* 137 */ { 0, "rmdir" },
  /* 138 */ { 0, "utimes" },
  { 0, }, /* 139 is obsolete 4.2 sigreturn */
  /* 140 */ { 0, "adjtime" },
  { 0, }, /* 141 is old getpeername */
  { 0, }, /* 142 is old gethostid */
  { 0, }, /* 143 is old sethostid */
  { 0, }, /* 144 is old getrlimit */
  { 0, }, /* 145 is old setrlimit */
  { 0, }, /* 146 is old killpg */
  /* 147 */ { 0, "setsid" },
  /* 148 */ { 0, "quotactl" },
  { 0, }, /* 149 is old quota */
  { 0, }, /* 150 is old getsockname */
  { 0, }, /* 151 */
  { 0, }, /* 152 */
  { 0, }, /* 153 */
  { 0, }, /* 154 */
  /* 155 */ { 0, "nfssvc" },
  { 0, }, /* 156 is old getdirentries */
  /* 157 */ { 0, "statfs" },
  /* 158 */ { do_fstatfs, "fstatfs" },
  { 0, }, /* 159 */
  { 0, }, /* 160 */
  /* 161 */ { 0, "getfh" },
  { 0, }, /* 162 is old getdomainname */
  { 0, }, /* 163 is old setdomainname */
  { 0, }, /* 164 is old uname */
  /* 165 */ { 0, "sysarch" },
  { 0, }, /* 166 */
  { 0, }, /* 167 */
  { 0, }, /* 168 */
  /* 169 */ { 0, "semsys" },
  /* 170 */ { 0, "msgsys" },
  /* 171 */ { 0, "shmsys" },
  { 0, }, /* 172 */
  { 0, }, /* 173 */
  { 0, }, /* 174 */
  { 0, }, /* 175 */
  { 0, }, /* 176 */
  { 0, }, /* 177 */
  { 0, }, /* 178 */
  { 0, }, /* 179 */
  { 0, }, /* 180 */
  /* 181 */ { 0, "setgid" },
  /* 182 */ { 0, "setegid" },
  /* 183 */ { 0, "seteuid" },
  /* 184 */ { 0, "lfs_bmapv" },
  /* 185 */ { 0, "lfs_markv" },
  /* 186 */ { 0, "lfs_segclean" },
  /* 187 */ { 0, "lfs_segwait" },
  /* 188 */ { do_stat, "stat" },
  /* 189 */ { do_fstat, "fstat" },
  /* 190 */ { do_lstat, "lstat" },
  /* 191 */ { 0, "pathconf" },
  /* 192 */ { 0, "fpathconf" },
  { 0, }, /* 193 */
  /* 194 */ { 0, "getrlimit" },
  /* 195 */ { 0, "setrlimit" },
  /* 196 */ { do_getdirentries, "getdirentries" },
  /* 197 */ { 0, "mmap" },
  /* 198 */ { do___syscall, "__syscall" },
  /* 199 */ { do_lseek, "lseek" },
  /* 200 */ { 0, "truncate" },
  /* 201 */ { 0, "ftruncate" },
  /* 202 */ { do___sysctl, "__sysctl" },
  /* 203 */ { 0, "mlock" },
  /* 204 */ { 0, "munlock" },
};

static char *(netbsd_error_names[]) = {
  /* 0 */ "ESUCCESS",
  /* 1 */ "EPERM",
  /* 2 */ "ENOENT",
  /* 3 */ "ESRCH",
  /* 4 */ "EINTR",
  /* 5 */ "EIO",
  /* 6 */ "ENXIO",
  /* 7 */ "E2BIG",
  /* 8 */ "ENOEXEC",
  /* 9 */ "EBADF",
  /* 10 */ "ECHILD",
  /* 11 */ "EDEADLK",
  /* 12 */ "ENOMEM",
  /* 13 */ "EACCES",
  /* 14 */ "EFAULT",
  /* 15 */ "ENOTBLK",
  /* 16 */ "EBUSY",
  /* 17 */ "EEXIST",
  /* 18 */ "EXDEV",
  /* 19 */ "ENODEV",
  /* 20 */ "ENOTDIR",
  /* 21 */ "EISDIR",
  /* 22 */ "EINVAL",
  /* 23 */ "ENFILE",
  /* 24 */ "EMFILE",
  /* 25 */ "ENOTTY",
  /* 26 */ "ETXTBSY",
  /* 27 */ "EFBIG",
  /* 28 */ "ENOSPC",
  /* 29 */ "ESPIPE",
  /* 30 */ "EROFS",
  /* 31 */ "EMLINK",
  /* 32 */ "EPIPE",
  /* 33 */ "EDOM",
  /* 34 */ "ERANGE",
  /* 35 */ "EAGAIN",
  /* 36 */ "EINPROGRESS",
  /* 37 */ "EALREADY",
  /* 38 */ "ENOTSOCK",
  /* 39 */ "EDESTADDRREQ",
  /* 40 */ "EMSGSIZE",
  /* 41 */ "EPROTOTYPE",
  /* 42 */ "ENOPROTOOPT",
  /* 43 */ "EPROTONOSUPPORT",
  /* 44 */ "ESOCKTNOSUPPORT",
  /* 45 */ "EOPNOTSUPP",
  /* 46 */ "EPFNOSUPPORT",
  /* 47 */ "EAFNOSUPPORT",
  /* 48 */ "EADDRINUSE",
  /* 49 */ "EADDRNOTAVAIL",
  /* 50 */ "ENETDOWN",
  /* 51 */ "ENETUNREACH",
  /* 52 */ "ENETRESET",
  /* 53 */ "ECONNABORTED",
  /* 54 */ "ECONNRESET",
  /* 55 */ "ENOBUFS",
  /* 56 */ "EISCONN",
  /* 57 */ "ENOTCONN",
  /* 58 */ "ESHUTDOWN",
  /* 59 */ "ETOOMANYREFS",
  /* 60 */ "ETIMEDOUT",
  /* 61 */ "ECONNREFUSED",
  /* 62 */ "ELOOP",
  /* 63 */ "ENAMETOOLONG",
  /* 64 */ "EHOSTDOWN",
  /* 65 */ "EHOSTUNREACH",
  /* 66 */ "ENOTEMPTY",
  /* 67 */ "EPROCLIM",
  /* 68 */ "EUSERS",
  /* 69 */ "EDQUOT",
  /* 70 */ "ESTALE",
  /* 71 */ "EREMOTE",
  /* 72 */ "EBADRPC",
  /* 73 */ "ERPCMISMATCH",
  /* 74 */ "EPROGUNAVAIL",
  /* 75 */ "EPROGMISMATCH",
  /* 76 */ "EPROCUNAVAIL",
  /* 77 */ "ENOLCK",
  /* 78 */ "ENOSYS",
  /* 79 */ "EFTYPE",
  /* 80 */ "EAUTH",
  /* 81 */ "ENEEDAUTH",
  /* 81 */ "ELAST",
};

static char *(netbsd_signal_names[]) = {
  /* 0 */ 0,
  /* 1 */ "SIGHUP",
  /* 2 */ "SIGINT",
  /* 3 */ "SIGQUIT",
  /* 4 */ "SIGILL",
  /* 5 */ "SIGTRAP",
  /* 6 */ "SIGABRT",
  /* 7 */ "SIGEMT",
  /* 8 */ "SIGFPE",
  /* 9 */ "SIGKILL",
  /* 10 */ "SIGBUS",
  /* 11 */ "SIGSEGV",
  /* 12 */ "SIGSYS",
  /* 13 */ "SIGPIPE",
  /* 14 */ "SIGALRM",
  /* 15 */ "SIGTERM",
  /* 16 */ "SIGURG",
  /* 17 */ "SIGSTOP",
  /* 18 */ "SIGTSTP",
  /* 19 */ "SIGCONT",
  /* 20 */ "SIGCHLD",
  /* 21 */ "SIGTTIN",
  /* 22 */ "SIGTTOU",
  /* 23 */ "SIGIO",
  /* 24 */ "SIGXCPU",
  /* 25 */ "SIGXFSZ",
  /* 26 */ "SIGVTALRM",
  /* 27 */ "SIGPROF",
  /* 28 */ "SIGWINCH",
  /* 29 */ "SIGINFO",
  /* 30 */ "SIGUSR1",
  /* 31 */ "SIGUSR2",
};

static emul_syscall emul_netbsd_syscalls = {
  netbsd_descriptors,
  sizeof(netbsd_descriptors) / sizeof(netbsd_descriptors[0]),
  netbsd_error_names,
  sizeof(netbsd_error_names) / sizeof(netbsd_error_names[0]),
  netbsd_signal_names,
  sizeof(netbsd_signal_names) / sizeof(netbsd_signal_names[0]),
};


/* NetBSD's os_emul interface, most are just passed on to the generic
   syscall stuff */

static os_emul_data *
emul_netbsd_create(device *root,
		   bfd *image,
		   const char *name)
{
  unsigned_word top_of_stack;
  unsigned stack_size;
  int elf_binary;
  os_emul_data *bsd_data;
  device *vm;
  char *filename;

  /* check that this emulation is really for us */
  if (name != NULL && strcmp(name, "netbsd") != 0)
    return NULL;
  if (image == NULL)
    return NULL;


  /* merge any emulation specific entries into the device tree */

  /* establish a few defaults */
  if (image->xvec->flavour == bfd_target_elf_flavour) {
    elf_binary = 1;
    top_of_stack = 0xe0000000;
    stack_size =   0x00100000;
  }
  else {
    elf_binary = 0;
    top_of_stack = 0x20000000;
    stack_size =   0x00100000;
  }

  /* options */
  emul_add_tree_options(root, image, "netbsd",
			(WITH_ENVIRONMENT == USER_ENVIRONMENT
			 ? "user" : "virtual"),
			0 /*oea-interrupt-prefix*/);

  /* virtual memory - handles growth of stack/heap */
  vm = tree_parse(root, "/openprom/vm");
  tree_parse(vm, "./stack-base 0x%lx",
	     (unsigned long)(top_of_stack - stack_size));
  tree_parse(vm, "./nr-bytes 0x%x", stack_size);

  filename = tree_quote_property (bfd_get_filename(image));
  tree_parse(root, "/openprom/vm/map-binary/file-name %s",
	     filename);
  free (filename);

  /* finish the init */
  tree_parse(root, "/openprom/init/register/pc 0x%lx",
	     (unsigned long)bfd_get_start_address(image));
  tree_parse(root, "/openprom/init/register/sp 0x%lx",
	     (unsigned long)top_of_stack);
  tree_parse(root, "/openprom/init/register/msr 0x%x",
	     ((tree_find_boolean_property(root, "/options/little-endian?")
	       ? msr_little_endian_mode
	       : 0)
	      | (tree_find_boolean_property(root, "/openprom/options/floating-point?")
		 ? (msr_floating_point_available
		    | msr_floating_point_exception_mode_0
		    | msr_floating_point_exception_mode_1)
		 : 0)));
  tree_parse(root, "/openprom/init/stack/stack-type %s",
	     (elf_binary ? "ppc-elf" : "ppc-xcoff"));

  /* finally our emulation data */
  bsd_data = ZALLOC(os_emul_data);
  bsd_data->vm = vm;
  bsd_data->syscalls = &emul_netbsd_syscalls;
  return bsd_data;
}

static void
emul_netbsd_init(os_emul_data *emul_data,
		 int nr_cpus)
{
  /* nothing yet */
}

static void
emul_netbsd_system_call(cpu *processor,
			unsigned_word cia,
			os_emul_data *emul_data)
{
  emul_do_system_call(emul_data,
		      emul_data->syscalls,
		      cpu_registers(processor)->gpr[0],
		      3, /*r3 contains arg0*/
		      processor,
		      cia);
}

const os_emul emul_netbsd = {
  "netbsd",
  emul_netbsd_create,
  emul_netbsd_init,
  emul_netbsd_system_call,
  0, /*instruction_call*/
  0 /*data*/
};

#endif	/* _EMUL_NETBSD_C_ */
@


1.9
log
@Update sim copyright headers from GPLv2-or-later to GPLv3-or-later.

gdb/sim/ChangeLog:

        Update the non-FSF-copyrighted files in sim to GPLv3 or later.
@
text
@d16 1
a16 2
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@


1.8
log
@sim: punt zfree()

The sim keeps track of which allocations are zero-ed internally (via
zalloc) and then calls a helper "zfree" function rather than "free".
But this "zfree" function simply calls "free" itself.  Since I can
see no point in this and it is simply useless overhead, punt it.

The only real change is in hw-alloc.c where we remove the zalloc_p
tracking, and sim-utils.c where zfree is delete.  The rest of the
changes are a simple `sed` from "zfree" to "free".

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d7 1
a7 1
    the Free Software Foundation; either version 2 of the License, or
@


1.7
log
@	* emul_netbsd.c (emul_netbsd_create): Quote file-name property.
	* emul_unix.c (emul_unix_create): Likewise.
	* tree.c (libiberty.h): Include it.
	(tree_quote_property): New function.
	* tree.h (tree_quote_property): Declare.
@
text
@d261 1
a261 1
    zfree(out);
d349 1
a349 1
  zfree(scratch_buffer);
d380 1
a380 1
  zfree(scratch_buffer);
d919 1
a919 1
    zfree(buf);
@


1.6
log
@	* configure.ac (USE_WIN32API): Define it.
	* configure.in: Regenerate.
	* config.in: Likewise.
	* emul_netbsd.c (write_timezone): Guard with HAVE_GETTIMEOFDAY.
	* emul_unix.c (do_unix_mkdir): Handle Win32 1-argument mkdir.
@
text
@d1386 1
d1421 1
d1423 2
a1424 1
	     bfd_get_filename(image));
@


1.5
log
@2004-09-24  Ian Lance Taylor <ian@@wasabisystems.com>

	Committed by Andrew Cagney.
	* configure.in: Check for sys/mount.h, sys/vfs.h, sys/statfs.h.
	Check for struct statfs.
	* emul_netbsd.c: If not HAVE_STRUCT_STATFS, #undef HAVE_FSTATFS.
	* configure, config.in: Regenerate.
@
text
@a45 1
#include <sys/errno.h>
d226 1
a226 1

d237 1
a237 1

@


1.5.12.1
log
@	* gdb/remote-sim.c (gdbsim_wait): Don't use target_signal_to_host
	or target_signal_from_host.
	* sim/arm/wrapper.c (gdb/signals.h): Include it.
	(SIGTRAP): Don't define it.
	(SIGBUS): Likewise.
	(sim_stop_reason): Use TARGET_SIGNAL_*.
	* sim/common/sim-reason.c (sim_stop_reason): Use
	sim_signal_to_target, not sim_signal_to_host.
	* sim/common/sim-signal.c (sim_signal_to_host): Fix typo.
	(sim_signal_to_target): New function.
	* sim/common/sim-signal.h: Declare it.
	* sim/d10v/interp.c (gdb/signals.h): Include it.
	(sim_stop_reason): Use TARGET_SIGNAL_*.
	* sim/erc32/interf.c: (gdb/signals.h): Include it.
	(sim_stop_reason): Use TARGET_SIGNAL_*.
	* sim/ppc/sim_calls.c (gdb/signals.h): Include it.
	(sim_stop_reason): Use TARGET_SIGNAL_*.
@
text
@a45 1
#ifdef HAVE_SYS_ERRNO_H
a46 1
#endif
d227 1
a227 1
#ifdef HAVE_GETTIMEOFDAY
a237 1
#endif
@


1.5.12.2
log
@	Backport:
	2006-02-01  Mark Mitchell  <mark@@codesourcery.com>
	* sim/ppc/emul_netbsd.c (emul_netbsd_create): Quote file-name property.
	* sim/ppc/emul_unix.c (emul_unix_create): Likewise.
	* sim/ppc/tree.c (libiberty.h): Include it.
	(tree_quote_property): New function.
	* sim/ppc/tree.h (tree_quote_property): Declare.

	Backport:
	2006-01-23  Mark Mitchell  <mark@@codesourcery.com>
	* sim/ppc/words.h (signed32): Define as "int".
	(unsigned32): Define as "unsigned int".
@
text
@a1389 1
  char *filename;
a1423 1
  filename = tree_quote_property (bfd_get_filename(image));
d1425 1
a1425 2
	     filename);
  free (filename);
@


1.4
log
@2003-10-16  Michael Snyder  <msnyder@@redhat.com>

	* emul_netbsd.c: Only a comment may follow an #endif.
@
text
@d97 8
@


1.3
log
@Fixes for NetBSD 1.5.  NetBSD has been renumbering/renaming its
SYS_* interfaces.
@
text
@d1469 1
a1469 1
#endif _EMUL_NETBSD_C_
@


1.3.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1469 1
a1469 1
#endif	/* _EMUL_NETBSD_C_ */
@


1.3.22.1
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1469 1
a1469 1
#endif	/* _EMUL_NETBSD_C_ */
@


1.2
log
@	* emul_netbsd.c (do_open): Translate the flag parameter to the
	open syscall to the numbers supported by the host.
@
text
@d45 1
d95 1
d600 1
d602 1
d818 1
d820 1
d842 1
d844 1
d868 1
d870 1
d895 1
d897 1
@


1.1
log
@Initial revision
@
text
@d389 1
d397 17
d415 1
a415 1
  status = open(path, flags, mode);
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@

