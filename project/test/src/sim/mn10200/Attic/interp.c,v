head	1.4;
access;
symbols
	gdb_6_3-20041109-release:1.3
	gdb_6_3-branch:1.3.0.4
	gdb_6_3-20041019-branchpoint:1.3
	drow_intercu-merge-20040921:1.3
	drow_intercu-merge-20040915:1.3
	jimb-gdb_6_2-e500-branch:1.3.0.6
	jimb-gdb_6_2-e500-branchpoint:1.3
	gdb_6_2-20040730-release:1.3
	gdb_6_2-branch:1.3.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.3
	gdb_6_1_1-20040616-release:1.2
	gdb_6_1-2004-04-05-release:1.2
	drow_intercu-merge-20040402:1.2
	drow_intercu-merge-20040327:1.2
	ezannoni_pie-20040323-branch:1.2.0.48
	ezannoni_pie-20040323-branchpoint:1.2
	cagney_tramp-20040321-mergepoint:1.2
	cagney_tramp-20040309-branch:1.2.0.46
	cagney_tramp-20040309-branchpoint:1.2
	gdb_6_1-branch:1.2.0.44
	gdb_6_1-2004-03-01-gmt-branchpoint:1.2
	drow_intercu-20040221-branch:1.2.0.42
	drow_intercu-20040221-branchpoint:1.2
	cagney_bfdfile-20040213-branch:1.2.0.40
	cagney_bfdfile-20040213-branchpoint:1.2
	drow-cplus-merge-20040208:1.2
	carlton_dictionary-20040126-merge:1.2
	cagney_bigcore-20040122-branch:1.2.0.38
	cagney_bigcore-20040122-branchpoint:1.2
	drow-cplus-merge-20040113:1.2
	drow-cplus-merge-20031224:1.2
	drow-cplus-merge-20031220:1.2
	carlton_dictionary-20031215-merge:1.2
	drow-cplus-merge-20031214:1.2
	carlton-dictionary-20031111-merge:1.2
	gdb_6_0-2003-10-04-release:1.2
	kettenis_sparc-20030918-branch:1.2.0.36
	kettenis_sparc-20030918-branchpoint:1.2
	carlton_dictionary-20030917-merge:1.2
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.34
	cagney_x86i386-20030821-branch:1.2.0.32
	cagney_x86i386-20030821-branchpoint:1.2
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.2.0.30
	gdb_6_0-2003-06-23-branchpoint:1.2
	jimb-ppc64-linux-20030613-branch:1.2.0.28
	jimb-ppc64-linux-20030613-branchpoint:1.2
	cagney_convert-20030606-branch:1.2.0.26
	cagney_convert-20030606-branchpoint:1.2
	cagney_writestrings-20030508-branch:1.2.0.24
	cagney_writestrings-20030508-branchpoint:1.2
	jimb-ppc64-linux-20030528-branch:1.2.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.2
	carlton_dictionary-20030523-merge:1.2
	cagney_fileio-20030521-branch:1.2.0.20
	cagney_fileio-20030521-branchpoint:1.2
	kettenis_i386newframe-20030517-mergepoint:1.2
	jimb-ppc64-linux-20030509-branch:1.2.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.2
	kettenis_i386newframe-20030504-mergepoint:1.2
	carlton_dictionary-20030430-merge:1.2
	kettenis_i386newframe-20030419-branch:1.2.0.16
	kettenis_i386newframe-20030419-branchpoint:1.2
	carlton_dictionary-20030416-merge:1.2
	cagney_frameaddr-20030409-mergepoint:1.2
	kettenis_i386newframe-20030406-branch:1.2.0.14
	kettenis_i386newframe-20030406-branchpoint:1.2
	cagney_frameaddr-20030403-branchpoint:1.2
	cagney_frameaddr-20030403-branch:1.2.0.12
	cagney_framebase-20030330-mergepoint:1.2
	cagney_framebase-20030326-branch:1.2.0.10
	cagney_framebase-20030326-branchpoint:1.2
	cagney_lazyid-20030317-branch:1.2.0.8
	cagney_lazyid-20030317-branchpoint:1.2
	kettenis-i386newframe-20030316-mergepoint:1.2
	offbyone-20030313-branch:1.2.0.6
	offbyone-20030313-branchpoint:1.2
	kettenis-i386newframe-20030308-branch:1.2.0.4
	kettenis-i386newframe-20030308-branchpoint:1.2
	carlton_dictionary-20030305-merge:1.2
	cagney_offbyone-20030303-branch:1.2.0.2
	cagney_offbyone-20030303-branchpoint:1.2
	carlton_dictionary-20030207-merge:1.1.1.2
	interps-20030202-branch:1.1.1.2.0.32
	interps-20030202-branchpoint:1.1.1.2
	cagney-unwind-20030108-branch:1.1.1.2.0.30
	cagney-unwind-20030108-branchpoint:1.1.1.2
	carlton_dictionary-20021223-merge:1.1.1.2
	gdb_5_3-2002-12-12-release:1.1.1.2
	carlton_dictionary-20021115-merge:1.1.1.2
	kseitz_interps-20021105-merge:1.1.1.2
	kseitz_interps-20021103-merge:1.1.1.2
	drow-cplus-merge-20021020:1.1.1.2
	drow-cplus-merge-20021025:1.1.1.2
	carlton_dictionary-20021025-merge:1.1.1.2
	carlton_dictionary-20021011-merge:1.1.1.2
	drow-cplus-branch:1.1.1.2.0.28
	drow-cplus-branchpoint:1.1.1.2
	kseitz_interps-20020930-merge:1.1.1.2
	carlton_dictionary-20020927-merge:1.1.1.2
	carlton_dictionary-branch:1.1.1.2.0.26
	carlton_dictionary-20020920-branchpoint:1.1.1.2
	gdb_5_3-branch:1.1.1.2.0.24
	gdb_5_3-2002-09-04-branchpoint:1.1.1.2
	kseitz_interps-20020829-merge:1.1.1.2
	cagney_sysregs-20020825-branch:1.1.1.2.0.22
	cagney_sysregs-20020825-branchpoint:1.1.1.2
	readline_4_3-import-branch:1.1.1.2.0.20
	readline_4_3-import-branchpoint:1.1.1.2
	gdb_5_2_1-2002-07-23-release:1.1.1.2
	kseitz_interps-20020528-branch:1.1.1.2.0.18
	kseitz_interps-20020528-branchpoint:1.1.1.2
	cagney_regbuf-20020515-branch:1.1.1.2.0.16
	cagney_regbuf-20020515-branchpoint:1.1.1.2
	jimb-macro-020506-branch:1.1.1.2.0.14
	jimb-macro-020506-branchpoint:1.1.1.2
	gdb_5_2-2002-04-29-release:1.1.1.2
	gdb_5_2-branch:1.1.1.2.0.12
	gdb_5_2-2002-03-03-branchpoint:1.1.1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.2
	gdb_5_1_0_1-2002-01-03-release:1.1.1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.2.0.10
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.2
	gdb_5_1-2001-11-21-release:1.1.1.2
	gdb_s390-2001-09-26-branch:1.1.1.2.0.8
	gdb_s390-2001-09-26-branchpoint:1.1.1.2
	gdb_5_1-2001-07-29-branch:1.1.1.2.0.6
	gdb_5_1-2001-07-29-branchpoint:1.1.1.2
	insight-precleanup-2001-01-01:1.1.1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.4
date	2004.11.12.16.45.31;	author cagney;	state dead;
branches;
next	1.3;

1.3
date	2004.06.29.00.54.00;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.27.23.26.34;	author cagney;	state Exp;
branches
	1.2.42.1;
next	1.1;

1.1
date	99.04.16.01.35.07;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.35.07;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.33.10;	author shebs;	state Exp;
branches
	1.1.1.2.26.1
	1.1.1.2.28.1;
next	;

1.1.1.2.26.1
date	2003.03.06.00.56.42;	author carlton;	state Exp;
branches;
next	;

1.1.1.2.28.1
date	2003.12.14.20.28.28;	author drow;	state Exp;
branches;
next	;

1.2.42.1
date	2004.09.16.17.02.12;	author drow;	state Exp;
branches;
next	;


desc
@@


1.4
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* d30v, fr30, mn10200, z8k: Delete directory.
@
text
@#include <signal.h>
#include "sysdep.h"
#include "bfd.h"

#include "mn10200_sim.h"

#ifdef NEED_UI_LOOP_HOOK
/* How often to run the ui_loop update, when in use */
#define UI_LOOP_POLL_INTERVAL 0x60000

/* Counter for the ui_loop_hook update */
static long ui_loop_hook_counter = UI_LOOP_POLL_INTERVAL;

/* Actual hook to call to run through gdb's gui event loop */
extern int (*deprecated_ui_loop_hook) (int);
#endif /* NEED_UI_LOOP_HOOK */

host_callback *mn10200_callback;
int mn10200_debug;
static SIM_OPEN_KIND sim_kind;
static char *myname;

static void dispatch PARAMS ((uint32, uint32, int));
static long hash PARAMS ((long));
static void init_system PARAMS ((void));
#define MAX_HASH  127

struct hash_entry
{
  struct hash_entry *next;
  long opcode;
  long mask;
  struct simops *ops;
#ifdef HASH_STAT
  unsigned long count;
#endif
};

int max_mem = 0;
struct hash_entry hash_table[MAX_HASH+1];


/* This probably doesn't do a very good job at bucket filling, but
   it's simple... */
static INLINE long 
hash(insn)
     long insn;
{
  /* These are one byte insns.  */
  if ((insn & 0xffffff00) == 0x00)
    {
      if ((insn & 0xf0) != 0x80)
	return ((insn & 0xf0) >> 4) & 0x7f;

      if ((insn & 0xf0) == 0x80
	   && (insn & 0x0c) >> 2 != (insn & 0x03))
	return (insn & 0xf0) & 0x7f;

      return (insn & 0xff) & 0x7f;
    }

  if ((insn & 0xffff0000) == 0)
    {
      if ((insn & 0xf000) == 0xd000)
	return ((insn & 0xfc00) >> 10) & 0x7f;

      if ((insn & 0xf000) == 0xe000)
	return ((insn & 0xff00) >> 8) & 0x7f;

      if ((insn & 0xf200) == 0xf200)
	return ((insn & 0xfff0) >> 4) & 0x7f;

      if ((insn & 0xc000) == 0x4000
	  || (insn & 0xf000) == 0x8000)
	return ((insn & 0xf000) >> 8) & 0x7f;

      if ((insn & 0xf200) == 0xf000)
	return ((insn & 0xffc0) >> 8) & 0x7f;

      return ((insn & 0xff00) >> 8) & 0x7f;
    }

  if ((insn & 0xff000000) == 0)
    {

      if ((insn & 0xf00000) != 0xf00000
	   || (insn & 0xfc0000) == 0xf80000)
	return ((insn & 0xfc0000) >> 16) & 0x7f;

      if ((insn & 0xff0000) == 0xf50000)
	return ((insn & 0xfff000) >> 12) & 0x7f;
      return ((insn & 0xff0000) >> 16) & 0x7f;
    }

  return ((insn & 0xfff0000) >> 20) & 0x7f;
}

static INLINE void
dispatch (insn, extension, length)
     uint32 insn;
     uint32 extension;
     int length;
{
  struct hash_entry *h;

  h = &hash_table[hash(insn)];

  while ((insn & h->mask) != h->opcode
	  || (length != h->ops->length))
    {
      if (!h->next)
	{
	  (*mn10200_callback->printf_filtered) (mn10200_callback,
	    "ERROR looking up hash for 0x%x, PC=0x%x\n", insn, PC);
	  exit(1);
	}
      h = h->next;
    }


#ifdef HASH_STAT
  h->count++;
#endif

  /* Now call the right function.  */
  (h->ops->func)(insn, extension);
  PC += length;
}

/* FIXME These would more efficient to use than load_mem/store_mem,
   but need to be changed to use the memory map.  */

uint32
get_word (x)
      uint8 *x;
{
  uint8 *a = x;
  return (a[3]<<24) + (a[2]<<16) + (a[1]<<8) + (a[0]);
}

void
put_word (addr, data)
     uint8 *addr;
     uint32 data;
{
  uint8 *a = addr;
  a[0] = data & 0xff;
  a[1] = (data >> 8) & 0xff;
  a[2] = (data >> 16) & 0xff;
  a[3] = (data >> 24) & 0xff;
}

void
sim_size (power)
     int power;

{
  if (State.mem)
    free (State.mem);

  max_mem = 1 << power;
  State.mem = (uint8 *) calloc (1,  1 << power);
  if (!State.mem)
    {
      (*mn10200_callback->printf_filtered) (mn10200_callback, "Allocation of main memory failed.\n");
      exit (1);
    }
}

static void
init_system ()
{
  if (!State.mem)
    sim_size(19);
}

int
sim_write (sd,addr, buffer, size)
     SIM_DESC sd;
     SIM_ADDR addr;
     unsigned char *buffer;
     int size;
{
  int i;

  init_system ();

  for (i = 0; i < size; i++)
    store_byte (addr + i, buffer[i]);

  return size;
}

/* Compare two opcode table entries for qsort.  */
static int
compare_simops (arg1, arg2)
     const PTR arg1;
     const PTR arg2;
{
  unsigned long code1 = ((struct simops *)arg1)->opcode;
  unsigned long code2 = ((struct simops *)arg2)->opcode;

  if (code1 < code2)
    return -1;
  if (code2 < code1)
    return 1;
  return 0;
}

SIM_DESC
sim_open (kind, cb, abfd, argv)
     SIM_OPEN_KIND kind;
     host_callback *cb;
     struct bfd *abfd;
     char **argv;
{
  struct simops *s;
  struct hash_entry *h;
  char **p;
  int i;

  mn10200_callback = cb;

  /* Sort the opcode array from smallest opcode to largest.
     This will generally improve simulator performance as the smaller
     opcodes are generally preferred to the larger opcodes.  */
  for (i = 0, s = Simops; s->func; s++, i++)
    ;
  qsort (Simops, i, sizeof (Simops[0]), compare_simops);

  sim_kind = kind;
  myname = argv[0];

  for (p = argv + 1; *p; ++p)
    {
      if (strcmp (*p, "-E") == 0)
	++p; /* ignore endian spec */
      else
#ifdef DEBUG
      if (strcmp (*p, "-t") == 0)
	mn10200_debug = DEBUG;
      else
#endif
	(*mn10200_callback->printf_filtered) (mn10200_callback, "ERROR: unsupported option(s): %s\n",*p);
    }

  /* put all the opcodes in the hash table */
  for (s = Simops; s->func; s++)
    {
      h = &hash_table[hash(s->opcode)];
      
      /* go to the last entry in the chain */
      while (h->next)
	{
	  /* Don't insert the same opcode more than once.  */
	  if (h->opcode == s->opcode
	      && h->mask == s->mask
	      && h->ops == s)
	    break;
	  else
	    h = h->next;
	}

      /* Don't insert the same opcode more than once.  */
      if (h->opcode == s->opcode
	  && h->mask == s->mask
	  && h->ops == s)
	continue;

      if (h->ops)
	{
	  h->next = calloc(1,sizeof(struct hash_entry));
	  h = h->next;
	}
      h->ops = s;
      h->mask = s->mask;
      h->opcode = s->opcode;
#ifdef HASH_STAT
      h->count = 0;
#endif
    }

  /* fudge our descriptor for now */
  return (SIM_DESC) 1;
}


void
sim_set_profile (n)
     int n;
{
  (*mn10200_callback->printf_filtered) (mn10200_callback, "sim_set_profile %d\n", n);
}

void
sim_set_profile_size (n)
     int n;
{
  (*mn10200_callback->printf_filtered) (mn10200_callback, "sim_set_profile_size %d\n", n);
}

int
sim_stop (sd)
     SIM_DESC sd;
{
  State.exception = SIGINT;
  return 1;
}

void
sim_resume (sd, step, siggnal)
     SIM_DESC sd;
     int step, siggnal;
{
  uint32 inst;

  if (step)
    State.exception = SIGTRAP;
  else
    State.exception = 0;

  State.exited = 0;

  do
    {
      unsigned long insn, extension;

#ifdef NEED_UI_LOOP_HOOK
    if (deprecated_ui_loop_hook != NULL && ui_loop_hook_counter-- < 0)
      {
	ui_loop_hook_counter = UI_LOOP_POLL_INTERVAL;
	deprecated_ui_loop_hook (0);
      }
#endif /* NEED_UI_LOOP_HOOK */

      /* Fetch the current instruction, fetch a double word to
	 avoid redundant fetching for the common cases below.  */
      inst = load_mem_big (PC, 2);

      /* Using a giant case statement may seem like a waste because of the
	 code/rodata size the table itself will consume.  However, using
	 a giant case statement speeds up the simulator by 10-15% by avoiding
	 cascading if/else statements or cascading case statements.  */
      switch ((inst >> 8) & 0xff)
	{
	/* All the single byte insns except 0x80, which must
	   be handled specially.  */
	case 0x00:
	case 0x01:
	case 0x02:
	case 0x03:
	case 0x04:
	case 0x05:
	case 0x06:
	case 0x07:
	case 0x08:
	case 0x09:
	case 0x0a:
	case 0x0b:
	case 0x0c:
	case 0x0d:
	case 0x0e:
	case 0x0f:
	case 0x10:
	case 0x11:
	case 0x12:
	case 0x13:
	case 0x14:
	case 0x15:
	case 0x16:
	case 0x17:
	case 0x18:
	case 0x19:
	case 0x1a:
	case 0x1b:
	case 0x1c:
	case 0x1d:
	case 0x1e:
	case 0x1f:
	case 0x20:
	case 0x21:
	case 0x22:
	case 0x23:
	case 0x24:
	case 0x25:
	case 0x26:
	case 0x27:
	case 0x28:
	case 0x29:
	case 0x2a:
	case 0x2b:
	case 0x2c:
	case 0x2d:
	case 0x2e:
	case 0x2f:
	case 0x30:
	case 0x31:
	case 0x32:
	case 0x33:
	case 0x34:
	case 0x35:
	case 0x36:
	case 0x37:
	case 0x38:
	case 0x39:
	case 0x3a:
	case 0x3b:
	case 0x3c:
	case 0x3d:
	case 0x3e:
	case 0x3f:
	case 0x90:
	case 0x91:
	case 0x92:
	case 0x93:
	case 0x94:
	case 0x95:
	case 0x96:
	case 0x97:
	case 0x98:
	case 0x99:
	case 0x9a:
	case 0x9b:
	case 0x9c:
	case 0x9d:
	case 0x9e:
	case 0x9f:
	case 0xa0:
	case 0xa1:
	case 0xa2:
	case 0xa3:
	case 0xa4:
	case 0xa5:
	case 0xa6:
	case 0xa7:
	case 0xa8:
	case 0xa9:
	case 0xaa:
	case 0xab:
	case 0xac:
	case 0xad:
	case 0xae:
	case 0xaf:
	case 0xb0:
	case 0xb1:
	case 0xb2:
	case 0xb3:
	case 0xb4:
	case 0xb5:
	case 0xb6:
	case 0xb7:
	case 0xb8:
	case 0xb9:
	case 0xba:
	case 0xbb:
	case 0xbc:
	case 0xbd:
	case 0xbe:
	case 0xbf:
        case 0xeb:
	case 0xf6:
	case 0xfe:
	case 0xff:
	  insn = (inst >> 8) & 0xff;
	  extension = 0;
	  dispatch (insn, extension, 1);
	  break;

	/* Special case as mov dX,dX really means mov imm8,dX.  */
	case 0x80:
	case 0x85:
	case 0x8a:
	case 0x8f:
	  /* Fetch the full instruction.  */
	  insn = inst;
	  extension = 0;
	  dispatch (insn, extension, 2);
	  break;

	case 0x81:
	case 0x82:
	case 0x83:
	case 0x84:
	case 0x86:
	case 0x87:
	case 0x88:
	case 0x89:
	case 0x8b:
	case 0x8c:
	case 0x8d:
	case 0x8e:
	  insn = (inst >> 8) & 0xff;
	  extension = 0;
	  dispatch (insn, extension, 1);
	  break;

        /* And the two byte insns.  */
	case 0x40:
	case 0x41:
	case 0x42:
	case 0x43:
	case 0x44:
	case 0x45:
	case 0x46:
	case 0x47:
	case 0x48:
	case 0x49:
	case 0x4a:
	case 0x4b:
	case 0x4c:
	case 0x4d:
	case 0x4e:
	case 0x4f:
	case 0x50:
	case 0x51:
	case 0x52:
	case 0x53:
	case 0x54:
	case 0x55:
	case 0x56:
	case 0x57:
	case 0x58:
	case 0x59:
	case 0x5a:
	case 0x5b:
	case 0x5c:
	case 0x5d:
	case 0x5e:
	case 0x5f:
	case 0x60:
	case 0x61:
	case 0x62:
	case 0x63:
	case 0x64:
	case 0x65:
	case 0x66:
	case 0x67:
	case 0x68:
	case 0x69:
	case 0x6a:
	case 0x6b:
	case 0x6c:
	case 0x6d:
	case 0x6e:
	case 0x6f:
	case 0x70:
	case 0x71:
	case 0x72:
	case 0x73:
	case 0x74:
	case 0x75:
	case 0x76:
	case 0x77:
	case 0x78:
	case 0x79:
	case 0x7a:
	case 0x7b:
	case 0x7c:
	case 0x7d:
	case 0x7e:
	case 0x7f:
	case 0xd0:
	case 0xd1:
	case 0xd2:
	case 0xd3:
	case 0xd4:
	case 0xd5:
	case 0xd6:
	case 0xd7:
	case 0xd8:
	case 0xd9:
	case 0xda:
	case 0xdb:
	case 0xe0:
	case 0xe1:
	case 0xe2:
	case 0xe3:
	case 0xe4:
	case 0xe5:
	case 0xe6:
	case 0xe7:
	case 0xe8:
	case 0xe9:
	case 0xea:
	case 0xf0:
	case 0xf1:
	case 0xf2:
	case 0xf3:
	  /* Fetch the full instruction.  */
	  insn = inst;
	  extension = 0;
	  dispatch (insn, extension, 2);
	  break;

	/* And the 3 byte insns with a 16bit operand in little
	   endian format.  */
	case 0xc0:
	case 0xc1:
	case 0xc2:
	case 0xc3:
	case 0xc4:
	case 0xc5:
	case 0xc6:
	case 0xc7:
	case 0xc8:
	case 0xc9:
	case 0xca:
	case 0xcb:
	case 0xcc:
	case 0xcd:
	case 0xce:
	case 0xcf:
	case 0xdc:
	case 0xdd:
	case 0xde:
	case 0xdf:
	case 0xec:
	case 0xed:
	case 0xee:
	case 0xef:
	case 0xf8:
	case 0xf9:
	case 0xfa:
	case 0xfb:
	case 0xfc:
	case 0xfd:
	  insn = load_byte (PC);
	  insn <<= 16;
	  insn |= load_half (PC + 1);
	  extension = 0;
	  dispatch (insn, extension, 3);
	  break;

	/* 3 byte insns without 16bit operand.  */
	case 0xf5:
	  insn = load_mem_big (PC, 3);
	  extension = 0;
	  dispatch (insn, extension, 3);
	  break;

	/* 4 byte insns.  */
	case 0xf7:
	  insn = inst;
	  insn <<= 16;
	  insn |= load_half (PC + 2);
	  extension = 0;
	  dispatch (insn, extension, 4);
	  break;

	case 0xf4:
	  insn = inst;
	  insn <<= 16;
	  insn |= load_mem_big (PC + 4, 1) << 8;
	  insn |= load_mem_big (PC + 3, 1);
	  extension = load_mem_big (PC + 2, 1);
	  dispatch (insn, extension, 5);
	  break;

	default:
	  abort ();
        }
    }
  while (!State.exception);

#ifdef HASH_STAT
  {
    int i;
    for (i = 0; i < MAX_HASH; i++)
      {
        struct hash_entry *h;
	h = &hash_table[i];

	printf("hash 0x%x:\n", i);

	while (h)
	  {
	    printf("h->opcode = 0x%x, count = 0x%x\n", h->opcode, h->count);
	    h = h->next;
	  }

	printf("\n\n");
      }
    fflush (stdout);
  }
#endif
  
}


void
sim_close (sd, quitting)
     SIM_DESC sd;
     int quitting;
{
  /* nothing to do */
}

int
sim_trace (sd)
     SIM_DESC sd;
{
#ifdef DEBUG
  mn10200_debug = DEBUG;
#endif
  sim_resume (sd, 0, 0);
  return 1;
}

void
sim_info (sd, verbose)
     SIM_DESC sd;
     int verbose;
{
  (*mn10200_callback->printf_filtered) (mn10200_callback, "sim_info\n");
}

SIM_RC
sim_create_inferior (sd, abfd, argv, env)
     SIM_DESC sd;
     struct bfd *abfd;
     char **argv;
     char **env;
{
  if (abfd != NULL)
    PC = bfd_get_start_address (abfd);
  else
    PC = 0;
  return SIM_RC_OK;
}

void
sim_set_callbacks (p)
     host_callback *p;
{
  mn10200_callback = p;
}

/* All the code for exiting, signals, etc needs to be revamped.

   This is enough to get c-torture limping though.  */

void
sim_stop_reason (sd, reason, sigrc)
     SIM_DESC sd;
     enum sim_stop *reason;
     int *sigrc;
{
  if (State.exited)
    *reason = sim_exited;
  else
    *reason = sim_stopped;
  if (State.exception == SIGQUIT)
    *sigrc = 0;
  else
    *sigrc = State.exception;
}

int
sim_fetch_register (sd, rn, memory, length)
     SIM_DESC sd;
     int rn;
     unsigned char *memory;
     int length;
{
  put_word (memory, State.regs[rn]);
  return -1;
}
 
int
sim_store_register (sd, rn, memory, length)
     SIM_DESC sd;
     int rn;
     unsigned char *memory;
     int length;
{
  State.regs[rn] = get_word (memory);
  return -1;
}

int
sim_read (sd, addr, buffer, size)
     SIM_DESC sd;
     SIM_ADDR addr;
     unsigned char *buffer;
     int size;
{
  int i;
  for (i = 0; i < size; i++)
    buffer[i] = load_byte (addr + i);

  return size;
} 

void
sim_do_command (sd, cmd)
     SIM_DESC sd;
     char *cmd;
{
  (*mn10200_callback->printf_filtered) (mn10200_callback, "\"%s\" is not a valid mn10200 simulator command.\n", cmd);
}

SIM_RC
sim_load (sd, prog, abfd, from_tty)
     SIM_DESC sd;
     char *prog;
     bfd *abfd;
     int from_tty;
{
  extern bfd *sim_load_file (); /* ??? Don't know where this should live.  */
  bfd *prog_bfd;

  prog_bfd = sim_load_file (sd, myname, mn10200_callback, prog, abfd,
			    sim_kind == SIM_OPEN_DEBUG,
			    0, sim_write);
  if (prog_bfd == NULL)
    return SIM_RC_FAIL;
  if (abfd == NULL)
    bfd_close (prog_bfd);
  return SIM_RC_OK;
} 
@


1.3
log
@Index: mn10200/ChangeLog
2004-06-28  Andrew Cagney  <cagney@@gnu.org>

	* interp.c: Rename ui_loop_hook to deprecated_ui_loop_hook.

Index: d10v/ChangeLog
2004-06-28  Andrew Cagney  <cagney@@gnu.org>

	* interp.c (sim_resume): Rename ui_loop_hook to
	deprecated_ui_loop_hook.

Index: arm/ChangeLog
2004-06-28  Andrew Cagney  <cagney@@gnu.org>

	* armemu.c: Rename ui_loop_hook to deprecated_ui_loop_hook.

Index: common/ChangeLog
2004-06-28  Andrew Cagney  <cagney@@gnu.org>

	* run.c: Rename ui_loop_hook to deprecated_ui_loop_hook.
@
text
@@


1.2
log
@Index: arm/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* wrapper.c (sim_create_inferior, sim_open): Rename _bfd to bfd.

Index: common/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim-utils.h (sim_analyze_program, sim_load_file): Rename _bfd to bfd.
	* sim-hload.c (sim_load), sim-base.h (sim_state_base): Ditto.
	* nrun.c (main): Ditto.

Index: d10v/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: erc32/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interf.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: h8300/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* compile.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: h8500/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* compile.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: i960/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim-if.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: m32r/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim-if.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: m68hc11/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_prepare_for_program, sim_open)
	(sim_create_inferior): Rename _bfd to bfd.

Index: mcore/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: mips/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open):
	(sim_create_inferior):

Index: mn10200/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: mn10300/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior, sim_open)
	(sim_create_inferior): Rename _bfd to bfd.

Index: ppc/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim_calls.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: sh/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (init_dsp, sim_open, sim_create_inferior): Rename _bfd
	to bfd.

Index: v850/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: z8k/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* iface.c (sim_open, sim_create_inferior): Rename _bfd to bfd.
@
text
@d15 1
a15 1
extern int (*ui_loop_hook) (int);
d329 1
a329 1
    if (ui_loop_hook != NULL && ui_loop_hook_counter-- < 0)
d332 1
a332 1
	ui_loop_hook (0);
@


1.2.42.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d15 1
a15 1
extern int (*deprecated_ui_loop_hook) (int);
d329 1
a329 1
    if (deprecated_ui_loop_hook != NULL && ui_loop_hook_counter-- < 0)
d332 1
a332 1
	deprecated_ui_loop_hook (0);
@


1.1
log
@Initial revision
@
text
@d7 11
d214 1
a214 1
     struct _bfd *abfd;
d306 2
a307 1
  return 0;
d328 8
d720 1
a720 1
     struct _bfd *abfd;
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a6 11
#ifdef NEED_UI_LOOP_HOOK
/* How often to run the ui_loop update, when in use */
#define UI_LOOP_POLL_INTERVAL 0x60000

/* Counter for the ui_loop_hook update */
static long ui_loop_hook_counter = UI_LOOP_POLL_INTERVAL;

/* Actual hook to call to run through gdb's gui event loop */
extern int (*ui_loop_hook) (int);
#endif /* NEED_UI_LOOP_HOOK */

d295 1
a295 2
  State.exception = SIGINT;
  return 1;
a314 8

#ifdef NEED_UI_LOOP_HOOK
    if (ui_loop_hook != NULL && ui_loop_hook_counter-- < 0)
      {
	ui_loop_hook_counter = UI_LOOP_POLL_INTERVAL;
	ui_loop_hook (0);
      }
#endif /* NEED_UI_LOOP_HOOK */
@


1.1.1.2.28.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d214 1
a214 1
     struct bfd *abfd;
d720 1
a720 1
     struct bfd *abfd;
@


1.1.1.2.26.1
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d214 1
a214 1
     struct bfd *abfd;
d720 1
a720 1
     struct bfd *abfd;
@


