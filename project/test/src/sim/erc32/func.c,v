head	1.8;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.8
	gdb_7_6-2013-04-26-release:1.8
	gdb_7_6-branch:1.8.0.2
	gdb_7_6-2013-03-12-branchpoint:1.8
	gdb_7_5_1-2012-11-29-release:1.5
	gdb_7_5-2012-08-17-release:1.5
	gdb_7_5-branch:1.5.0.8
	gdb_7_5-2012-07-18-branchpoint:1.5
	gdb_7_4_1-2012-04-26-release:1.5
	gdb_7_4-2012-01-24-release:1.5
	gdb_7_4-branch:1.5.0.6
	gdb_7_4-2011-12-13-branchpoint:1.5
	gdb_7_3_1-2011-09-04-release:1.5
	gdb_7_3-2011-07-26-release:1.5
	gdb_7_3-branch:1.5.0.4
	gdb_7_3-2011-04-01-branchpoint:1.5
	gdb_7_2-2010-09-02-release:1.5
	gdb_7_2-branch:1.5.0.2
	gdb_7_2-2010-07-07-branchpoint:1.5
	gdb_7_1-2010-03-18-release:1.4
	gdb_7_1-branch:1.4.0.52
	gdb_7_1-2010-02-18-branchpoint:1.4
	gdb_7_0_1-2009-12-22-release:1.4
	gdb_7_0-2009-10-06-release:1.4
	gdb_7_0-branch:1.4.0.50
	gdb_7_0-2009-09-16-branchpoint:1.4
	arc-sim-20090309:1.4
	msnyder-checkpoint-072509-branch:1.4.0.48
	msnyder-checkpoint-072509-branchpoint:1.4
	arc-insight_6_8-branch:1.4.0.46
	arc-insight_6_8-branchpoint:1.4
	insight_6_8-branch:1.4.0.44
	insight_6_8-branchpoint:1.4
	reverse-20081226-branch:1.4.0.42
	reverse-20081226-branchpoint:1.4
	multiprocess-20081120-branch:1.4.0.40
	multiprocess-20081120-branchpoint:1.4
	reverse-20080930-branch:1.4.0.38
	reverse-20080930-branchpoint:1.4
	reverse-20080717-branch:1.4.0.36
	reverse-20080717-branchpoint:1.4
	msnyder-reverse-20080609-branch:1.4.0.34
	msnyder-reverse-20080609-branchpoint:1.4
	drow-reverse-20070409-branch:1.4.0.32
	drow-reverse-20070409-branchpoint:1.4
	gdb_6_8-2008-03-27-release:1.4
	gdb_6_8-branch:1.4.0.30
	gdb_6_8-2008-02-26-branchpoint:1.4
	gdb_6_7_1-2007-10-29-release:1.4
	gdb_6_7-2007-10-10-release:1.4
	gdb_6_7-branch:1.4.0.28
	gdb_6_7-2007-09-07-branchpoint:1.4
	insight_6_6-20070208-release:1.4
	gdb_6_6-2006-12-18-release:1.4
	gdb_6_6-branch:1.4.0.26
	gdb_6_6-2006-11-15-branchpoint:1.4
	insight_6_5-20061003-release:1.4
	gdb-csl-symbian-6_4_50_20060226-12:1.4
	gdb-csl-sourcerygxx-3_4_4-25:1.4
	nickrob-async-20060828-mergepoint:1.4
	gdb-csl-symbian-6_4_50_20060226-11:1.4
	gdb-csl-sourcerygxx-4_1-17:1.4
	gdb-csl-20060226-branch-local-2:1.4
	gdb-csl-sourcerygxx-4_1-14:1.4
	gdb-csl-sourcerygxx-4_1-13:1.4
	gdb-csl-sourcerygxx-4_1-12:1.4
	gdb-csl-sourcerygxx-3_4_4-21:1.4
	gdb_6_5-20060621-release:1.4
	gdb-csl-sourcerygxx-4_1-9:1.4
	gdb-csl-sourcerygxx-4_1-8:1.4
	gdb-csl-sourcerygxx-4_1-7:1.4
	gdb-csl-arm-2006q1-6:1.4
	gdb-csl-sourcerygxx-4_1-6:1.4
	gdb-csl-symbian-6_4_50_20060226-10:1.4
	gdb-csl-symbian-6_4_50_20060226-9:1.4
	gdb-csl-symbian-6_4_50_20060226-8:1.4
	gdb-csl-coldfire-4_1-11:1.4
	gdb-csl-sourcerygxx-3_4_4-19:1.4
	gdb-csl-coldfire-4_1-10:1.4
	gdb_6_5-branch:1.4.0.24
	gdb_6_5-2006-05-14-branchpoint:1.4
	gdb-csl-sourcerygxx-4_1-5:1.4
	nickrob-async-20060513-branch:1.4.0.22
	nickrob-async-20060513-branchpoint:1.4
	gdb-csl-sourcerygxx-4_1-4:1.4
	msnyder-reverse-20060502-branch:1.4.0.20
	msnyder-reverse-20060502-branchpoint:1.4
	gdb-csl-morpho-4_1-4:1.4
	gdb-csl-sourcerygxx-3_4_4-17:1.4
	readline_5_1-import-branch:1.4.0.18
	readline_5_1-import-branchpoint:1.4
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.4
	gdb-csl-symbian-20060226-branch:1.4.0.16
	gdb-csl-symbian-20060226-branchpoint:1.4
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.4
	msnyder-reverse-20060331-branch:1.4.0.14
	msnyder-reverse-20060331-branchpoint:1.4
	gdb-csl-available-20060303-branch:1.4.0.12
	gdb-csl-available-20060303-branchpoint:1.4
	gdb-csl-20060226-branch:1.4.0.10
	gdb-csl-20060226-branchpoint:1.4
	gdb_6_4-20051202-release:1.4
	msnyder-fork-checkpoint-branch:1.4.0.8
	msnyder-fork-checkpoint-branchpoint:1.4
	gdb-csl-gxxpro-6_3-branch:1.4.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.4
	gdb_6_4-branch:1.4.0.4
	gdb_6_4-2005-11-01-branchpoint:1.4
	gdb-csl-arm-20051020-branch:1.4.0.2
	gdb-csl-arm-20051020-branchpoint:1.4
	msnyder-tracepoint-checkpoint-branch:1.3.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.3
	gdb-csl-arm-20050325-2005-q1b:1.3
	gdb-csl-arm-20050325-2005-q1a:1.3
	csl-arm-20050325-branch:1.3.0.2
	csl-arm-20050325-branchpoint:1.3
	gdb_6_3-20041109-release:1.2
	gdb_6_3-branch:1.2.0.84
	gdb_6_3-20041019-branchpoint:1.2
	drow_intercu-merge-20040921:1.2
	drow_intercu-merge-20040915:1.2
	jimb-gdb_6_2-e500-branch:1.2.0.86
	jimb-gdb_6_2-e500-branchpoint:1.2
	gdb_6_2-20040730-release:1.2
	gdb_6_2-branch:1.2.0.82
	gdb_6_2-2004-07-10-gmt-branchpoint:1.2
	gdb_6_1_1-20040616-release:1.2
	gdb_6_1-2004-04-05-release:1.2
	drow_intercu-merge-20040402:1.2
	drow_intercu-merge-20040327:1.2
	ezannoni_pie-20040323-branch:1.2.0.80
	ezannoni_pie-20040323-branchpoint:1.2
	cagney_tramp-20040321-mergepoint:1.2
	cagney_tramp-20040309-branch:1.2.0.78
	cagney_tramp-20040309-branchpoint:1.2
	gdb_6_1-branch:1.2.0.76
	gdb_6_1-2004-03-01-gmt-branchpoint:1.2
	drow_intercu-20040221-branch:1.2.0.74
	drow_intercu-20040221-branchpoint:1.2
	cagney_bfdfile-20040213-branch:1.2.0.72
	cagney_bfdfile-20040213-branchpoint:1.2
	drow-cplus-merge-20040208:1.2
	carlton_dictionary-20040126-merge:1.2
	cagney_bigcore-20040122-branch:1.2.0.70
	cagney_bigcore-20040122-branchpoint:1.2
	drow-cplus-merge-20040113:1.2
	drow-cplus-merge-20031224:1.2
	drow-cplus-merge-20031220:1.2
	carlton_dictionary-20031215-merge:1.2
	drow-cplus-merge-20031214:1.2
	carlton-dictionary-20031111-merge:1.2
	gdb_6_0-2003-10-04-release:1.2
	kettenis_sparc-20030918-branch:1.2.0.68
	kettenis_sparc-20030918-branchpoint:1.2
	carlton_dictionary-20030917-merge:1.2
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.66
	cagney_x86i386-20030821-branch:1.2.0.64
	cagney_x86i386-20030821-branchpoint:1.2
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.2.0.62
	gdb_6_0-2003-06-23-branchpoint:1.2
	jimb-ppc64-linux-20030613-branch:1.2.0.60
	jimb-ppc64-linux-20030613-branchpoint:1.2
	cagney_convert-20030606-branch:1.2.0.58
	cagney_convert-20030606-branchpoint:1.2
	cagney_writestrings-20030508-branch:1.2.0.56
	cagney_writestrings-20030508-branchpoint:1.2
	jimb-ppc64-linux-20030528-branch:1.2.0.54
	jimb-ppc64-linux-20030528-branchpoint:1.2
	carlton_dictionary-20030523-merge:1.2
	cagney_fileio-20030521-branch:1.2.0.52
	cagney_fileio-20030521-branchpoint:1.2
	kettenis_i386newframe-20030517-mergepoint:1.2
	jimb-ppc64-linux-20030509-branch:1.2.0.50
	jimb-ppc64-linux-20030509-branchpoint:1.2
	kettenis_i386newframe-20030504-mergepoint:1.2
	carlton_dictionary-20030430-merge:1.2
	kettenis_i386newframe-20030419-branch:1.2.0.48
	kettenis_i386newframe-20030419-branchpoint:1.2
	carlton_dictionary-20030416-merge:1.2
	cagney_frameaddr-20030409-mergepoint:1.2
	kettenis_i386newframe-20030406-branch:1.2.0.46
	kettenis_i386newframe-20030406-branchpoint:1.2
	cagney_frameaddr-20030403-branchpoint:1.2
	cagney_frameaddr-20030403-branch:1.2.0.44
	cagney_framebase-20030330-mergepoint:1.2
	cagney_framebase-20030326-branch:1.2.0.42
	cagney_framebase-20030326-branchpoint:1.2
	cagney_lazyid-20030317-branch:1.2.0.40
	cagney_lazyid-20030317-branchpoint:1.2
	kettenis-i386newframe-20030316-mergepoint:1.2
	offbyone-20030313-branch:1.2.0.38
	offbyone-20030313-branchpoint:1.2
	kettenis-i386newframe-20030308-branch:1.2.0.36
	kettenis-i386newframe-20030308-branchpoint:1.2
	carlton_dictionary-20030305-merge:1.2
	cagney_offbyone-20030303-branch:1.2.0.34
	cagney_offbyone-20030303-branchpoint:1.2
	carlton_dictionary-20030207-merge:1.2
	interps-20030202-branch:1.2.0.32
	interps-20030202-branchpoint:1.2
	cagney-unwind-20030108-branch:1.2.0.30
	cagney-unwind-20030108-branchpoint:1.2
	carlton_dictionary-20021223-merge:1.2
	gdb_5_3-2002-12-12-release:1.2
	carlton_dictionary-20021115-merge:1.2
	kseitz_interps-20021105-merge:1.2
	kseitz_interps-20021103-merge:1.2
	drow-cplus-merge-20021020:1.2
	drow-cplus-merge-20021025:1.2
	carlton_dictionary-20021025-merge:1.2
	carlton_dictionary-20021011-merge:1.2
	drow-cplus-branch:1.2.0.28
	drow-cplus-branchpoint:1.2
	kseitz_interps-20020930-merge:1.2
	carlton_dictionary-20020927-merge:1.2
	carlton_dictionary-branch:1.2.0.26
	carlton_dictionary-20020920-branchpoint:1.2
	gdb_5_3-branch:1.2.0.24
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.22
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.20
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.18
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.16
	cagney_regbuf-20020515-branchpoint:1.2
	jimb-macro-020506-branch:1.2.0.14
	jimb-macro-020506-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.12
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.2
	gdb_5_1_0_1-2002-01-03-release:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.10
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.8
	gdb_s390-2001-09-26-branchpoint:1.2
	gdb_5_1-2001-07-29-branch:1.2.0.6
	gdb_5_1-2001-07-29-branchpoint:1.2
	insight-precleanup-2001-01-01:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.8
date	2012.12.19.07.18.16;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2012.12.19.07.11.59;	author brobecke;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.16.07.56.19;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2010.05.11.14.18.20;	author joel;	state Exp;
branches;
next	1.4;

1.4
date	2005.07.08.08.04.54;	author bje;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.07.11.09.05;	author guitton;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.03.15.00.58;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.00;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.35.00;	author shebs;	state Exp;
branches;
next	;


desc
@@


1.8
log
@[sim] Update old contact info in GPL license notices

sim/ChangeLog:

        Update old contact info in GPL license notices.
@
text
@/*
 * func.c, misc simulator functions. This file is part of SIS.
 * 
 * SIS, SPARC instruction simulator V1.8 Copyright (C) 1995 Jiri Gaisler,
 * European Space Agency
 * 
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 3 of the License, or (at your option)
 * any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, see <http://www.gnu.org/licenses/>.
 * 
 */

#include "config.h"
#include <signal.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include "sis.h"
#include "end.h"
#include <dis-asm.h>
#include "sim-config.h"


#define	VAL(x)	strtoul(x,(char **)NULL,0)

extern int	current_target_byte_order;
struct disassemble_info dinfo;
struct pstate   sregs;
extern struct estate ebase;
int             ctrl_c = 0;
int             sis_verbose = 0;
char           *sis_version = "2.7.5";
int             nfp = 0;
int             ift = 0;
int             wrp = 0;
int             rom8 = 0;
int             uben = 0;
int		termsave;
int             sparclite = 0;		/* emulating SPARClite instructions? */
int             sparclite_board = 0;	/* emulating SPARClite board RAM? */
char            uart_dev1[128] = "";
char            uart_dev2[128] = "";
extern	int	ext_irl;
uint32		last_load_addr = 0;

#ifdef ERRINJ
uint32		errcnt = 0;
uint32		errper = 0;
uint32		errtt = 0;
uint32		errftt = 0;
uint32		errmec = 0;
#endif

/* Forward declarations */

static int	batch PARAMS ((struct pstate *sregs, char *fname));
static void	set_rega PARAMS ((struct pstate *sregs, char *reg, uint32 rval));
static void	disp_reg PARAMS ((struct pstate *sregs, char *reg));
static uint32	limcalc PARAMS ((float32 freq));
static void	int_handler PARAMS ((int32 sig));
static void	init_event PARAMS ((void));
static int	disp_fpu PARAMS ((struct pstate  *sregs));
static void	disp_regs PARAMS ((struct pstate  *sregs, int cwp));
static void	disp_ctrl PARAMS ((struct pstate *sregs));
static void	disp_mem PARAMS ((uint32 addr, uint32 len));

static int 
batch(sregs, fname)
    struct pstate  *sregs;
    char           *fname;
{
    FILE           *fp;
    char            lbuf[1024];

    if ((fp = fopen(fname, "r")) == NULL) {
	fprintf(stderr, "couldn't open batch file %s\n", fname);
	return (0);
    }
    while (!feof(fp)) {
	lbuf[0] = 0;
	fgets(lbuf, 1023, fp);
	if ((strlen(lbuf) > 0) && (lbuf[strlen(lbuf) - 1] == '\n'))
	    lbuf[strlen(lbuf) - 1] = 0;
	printf("sis> %s\n", lbuf);
	exec_cmd(sregs, lbuf);
    }
    fclose(fp);
    return (1);
}

void
set_regi(sregs, reg, rval)
    struct pstate  *sregs;
    int32           reg;
    uint32          rval;
{
    uint32          cwp;

    cwp = ((sregs->psr & 0x7) << 4);
    if ((reg > 0) && (reg < 8)) {
	sregs->g[reg] = rval;
    } else if ((reg >= 8) && (reg < 32)) {
	sregs->r[(cwp + reg) & 0x7f] = rval;
    } else if ((reg >= 32) && (reg < 64)) {
	sregs->fsi[reg - 32] = rval;
    } else {
	switch (reg) {
	case 64:
	    sregs->y = rval;
	    break;
	case 65:
	    sregs->psr = rval;
	    break;
	case 66:
	    sregs->wim = rval;
	    break;
	case 67:
	    sregs->tbr = rval;
	    break;
	case 68:
	    sregs->pc = rval;
	    break;
	case 69:
	    sregs->npc = rval;
	    break;
	case 70:
	    sregs->fsr = rval;
	    set_fsr(rval);
	    break;
    default:break;
	}
    }
}

void
get_regi(struct pstate * sregs, int32 reg, char *buf)
{
    uint32          cwp;
    uint32          rval = 0;

    cwp = ((sregs->psr & 0x7) << 4);
    if ((reg >= 0) && (reg < 8)) {
	rval = sregs->g[reg];
    } else if ((reg >= 8) && (reg < 32)) {
	rval = sregs->r[(cwp + reg) & 0x7f];
    } else if ((reg >= 32) && (reg < 64)) {
	rval = sregs->fsi[reg - 32];
    } else {
	switch (reg) {
	case 64:
	    rval = sregs->y;
	    break;
	case 65:
	    rval = sregs->psr;
	    break;
	case 66:
	    rval = sregs->wim;
	    break;
	case 67:
	    rval = sregs->tbr;
	    break;
	case 68:
	    rval = sregs->pc;
	    break;
	case 69:
	    rval = sregs->npc;
	    break;
	case 70:
	    rval = sregs->fsr;
	    break;
    default:break;
	}
    }
    if (current_target_byte_order == BIG_ENDIAN) {
	buf[0] = (rval >> 24) & 0x0ff;
	buf[1] = (rval >> 16) & 0x0ff;
	buf[2] = (rval >> 8) & 0x0ff;
	buf[3] = rval & 0x0ff;
    }
    else {
	buf[3] = (rval >> 24) & 0x0ff;
	buf[2] = (rval >> 16) & 0x0ff;
	buf[1] = (rval >> 8) & 0x0ff;
	buf[0] = rval & 0x0ff;
    }
}


static void
set_rega(sregs, reg, rval)
    struct pstate  *sregs;
    char           *reg;
    uint32          rval;
{
    uint32          cwp;
    int32           err = 0;

    cwp = ((sregs->psr & 0x7) << 4);
    if (strcmp(reg, "psr") == 0)
	sregs->psr = (rval = (rval & 0x00f03fff));
    else if (strcmp(reg, "tbr") == 0)
	sregs->tbr = (rval = (rval & 0xfffffff0));
    else if (strcmp(reg, "wim") == 0)
	sregs->wim = (rval = (rval & 0x0ff));
    else if (strcmp(reg, "y") == 0)
	sregs->y = rval;
    else if (strcmp(reg, "pc") == 0)
	sregs->pc = rval;
    else if (strcmp(reg, "npc") == 0)
	sregs->npc = rval;
    else if (strcmp(reg, "fsr") == 0) {
	sregs->fsr = rval;
	set_fsr(rval);
    } else if (strcmp(reg, "g0") == 0)
	err = 2;
    else if (strcmp(reg, "g1") == 0)
	sregs->g[1] = rval;
    else if (strcmp(reg, "g2") == 0)
	sregs->g[2] = rval;
    else if (strcmp(reg, "g3") == 0)
	sregs->g[3] = rval;
    else if (strcmp(reg, "g4") == 0)
	sregs->g[4] = rval;
    else if (strcmp(reg, "g5") == 0)
	sregs->g[5] = rval;
    else if (strcmp(reg, "g6") == 0)
	sregs->g[6] = rval;
    else if (strcmp(reg, "g7") == 0)
	sregs->g[7] = rval;
    else if (strcmp(reg, "o0") == 0)
	sregs->r[(cwp + 8) & 0x7f] = rval;
    else if (strcmp(reg, "o1") == 0)
	sregs->r[(cwp + 9) & 0x7f] = rval;
    else if (strcmp(reg, "o2") == 0)
	sregs->r[(cwp + 10) & 0x7f] = rval;
    else if (strcmp(reg, "o3") == 0)
	sregs->r[(cwp + 11) & 0x7f] = rval;
    else if (strcmp(reg, "o4") == 0)
	sregs->r[(cwp + 12) & 0x7f] = rval;
    else if (strcmp(reg, "o5") == 0)
	sregs->r[(cwp + 13) & 0x7f] = rval;
    else if (strcmp(reg, "o6") == 0)
	sregs->r[(cwp + 14) & 0x7f] = rval;
    else if (strcmp(reg, "o7") == 0)
	sregs->r[(cwp + 15) & 0x7f] = rval;
    else if (strcmp(reg, "l0") == 0)
	sregs->r[(cwp + 16) & 0x7f] = rval;
    else if (strcmp(reg, "l1") == 0)
	sregs->r[(cwp + 17) & 0x7f] = rval;
    else if (strcmp(reg, "l2") == 0)
	sregs->r[(cwp + 18) & 0x7f] = rval;
    else if (strcmp(reg, "l3") == 0)
	sregs->r[(cwp + 19) & 0x7f] = rval;
    else if (strcmp(reg, "l4") == 0)
	sregs->r[(cwp + 20) & 0x7f] = rval;
    else if (strcmp(reg, "l5") == 0)
	sregs->r[(cwp + 21) & 0x7f] = rval;
    else if (strcmp(reg, "l6") == 0)
	sregs->r[(cwp + 22) & 0x7f] = rval;
    else if (strcmp(reg, "l7") == 0)
	sregs->r[(cwp + 23) & 0x7f] = rval;
    else if (strcmp(reg, "i0") == 0)
	sregs->r[(cwp + 24) & 0x7f] = rval;
    else if (strcmp(reg, "i1") == 0)
	sregs->r[(cwp + 25) & 0x7f] = rval;
    else if (strcmp(reg, "i2") == 0)
	sregs->r[(cwp + 26) & 0x7f] = rval;
    else if (strcmp(reg, "i3") == 0)
	sregs->r[(cwp + 27) & 0x7f] = rval;
    else if (strcmp(reg, "i4") == 0)
	sregs->r[(cwp + 28) & 0x7f] = rval;
    else if (strcmp(reg, "i5") == 0)
	sregs->r[(cwp + 29) & 0x7f] = rval;
    else if (strcmp(reg, "i6") == 0)
	sregs->r[(cwp + 30) & 0x7f] = rval;
    else if (strcmp(reg, "i7") == 0)
	sregs->r[(cwp + 31) & 0x7f] = rval;
    else
	err = 1;
    switch (err) {
    case 0:
	printf("%s = %d (0x%08x)\n", reg, rval, rval);
	break;
    case 1:
	printf("no such regiser: %s\n", reg);
	break;
    case 2:
	printf("cannot set g0\n");
	break;
    default:
	break;
    }

}

static void
disp_reg(sregs, reg)
    struct pstate  *sregs;
    char           *reg;
{
    if (strncmp(reg, "w",1) == 0)
	disp_regs(sregs, VAL(&reg[1]));
}

#ifdef ERRINJ

void
errinj()
{
    int	err;

    switch (err = (random() % 12)) {
	case 0: errtt = 0x61; break;
	case 1: errtt = 0x62; break;
	case 2: errtt = 0x63; break;
	case 3: errtt = 0x64; break;
	case 4: errtt = 0x65; break;
	case 5: 
	case 6: 
	case 7: errftt = err; 
		break;
	case 8: errmec = 1; break;
	case 9: errmec = 2; break;
	case 10: errmec = 5; break;
	case 11: errmec = 6; break;
    }
    errcnt++;
    if (errper) event(errinj, 0, (random()%errper));
}

void
errinjstart()
{
    if (errper) event(errinj, 0, (random()%errper));
}

#endif

static uint32
limcalc (freq)
    float32		freq;
{
    uint32          unit, lim;
    double	    flim;
    char           *cmd1, *cmd2;

    unit = 1;
    lim = -1;
    if ((cmd1 = strtok(NULL, " \t\n\r")) != NULL) {
        lim = VAL(cmd1);
        if ((cmd2 = strtok(NULL, " \t\n\r")) != NULL) {
            if (strcmp(cmd2,"us")==0) unit = 1;
      	    if (strcmp(cmd2,"ms")==0) unit = 1000;
            if (strcmp(cmd2,"s")==0)  unit = 1000000;
        }
        flim = (double) lim * (double) unit * (double) freq + 
	   (double) ebase.simtime;
        if ((flim > ebase.simtime) && (flim < 4294967296.0)) {
            lim = (uint32) flim;
        } else  {
            printf("error in expression\n");
            lim = -1;
        }
    }
    return (lim);
}
    
int
exec_cmd(sregs, cmd)
    char           *cmd;
    struct pstate  *sregs;
{
    char           *cmd1, *cmd2;
    int32           stat;
    uint32          len, i, clen, j;
    static uint32   daddr = 0;
    char           *cmdsave;

    stat = OK;
    cmdsave = strdup(cmd);
    if ((cmd1 = strtok(cmd, " \t")) != NULL) {
	clen = strlen(cmd1);
	if (strncmp(cmd1, "bp", clen) == 0) {
	    for (i = 0; i < sregs->bptnum; i++) {
		printf("  %d : 0x%08x\n", i + 1, sregs->bpts[i]);
	    }
	} else if (strncmp(cmd1, "+bp", clen) == 0) {
	    if ((cmd1 = strtok(NULL, " \t\n\r")) != NULL) {
		sregs->bpts[sregs->bptnum] = VAL(cmd1) & ~0x3;
		printf("added breakpoint %d at 0x%08x\n",
		       sregs->bptnum + 1, sregs->bpts[sregs->bptnum]);
		sregs->bptnum += 1;
	    }
	} else if (strncmp(cmd1, "-bp", clen) == 0) {
	    if ((cmd1 = strtok(NULL, " \t\n\r")) != NULL) {
		i = VAL(cmd1) - 1;
		if ((i >= 0) && (i < sregs->bptnum)) {
		    printf("deleted breakpoint %d at 0x%08x\n", i + 1,
			   sregs->bpts[i]);
		    for (; i < sregs->bptnum - 1; i++) {
			sregs->bpts[i] = sregs->bpts[i + 1];
		    }
		    sregs->bptnum -= 1;
		}
	    }
	} else if (strncmp(cmd1, "batch", clen) == 0) {
	    if ((cmd1 = strtok(NULL, " \t\n\r")) == NULL) {
		printf("no file specified\n");
	    } else {
		batch(sregs, cmd1);
	    }
	} else if (strncmp(cmd1, "cont", clen) == 0) {
	    if ((cmd1 = strtok(NULL, " \t\n\r")) == NULL) {
		stat = run_sim(sregs, UINT64_MAX, 0);
	    } else {
		stat = run_sim(sregs, VAL(cmd1), 0);
	    }
	    daddr = sregs->pc;
	    sim_halt();
	} else if (strncmp(cmd1, "debug", clen) == 0) {
	    if ((cmd1 = strtok(NULL, " \t\n\r")) != NULL) {
		sis_verbose = VAL(cmd1);
	    }
	    printf("Debug level = %d\n",sis_verbose);
	} else if (strncmp(cmd1, "dis", clen) == 0) {
	    if ((cmd1 = strtok(NULL, " \t\n\r")) != NULL) {
		daddr = VAL(cmd1);
	    }
	    if ((cmd2 = strtok(NULL, " \t\n\r")) != NULL) {
		len = VAL(cmd2);
	    } else
		len = 16;
	    printf("\n");
	    dis_mem(daddr, len, &dinfo);
	    printf("\n");
	    daddr += len * 4;
	} else if (strncmp(cmd1, "echo", clen) == 0) {
	    if ((cmd1 = strtok(NULL, " \t\n\r")) != NULL) {
		printf("%s\n", (&cmdsave[clen+1]));
	    }
#ifdef ERRINJ
	} else if (strncmp(cmd1, "error", clen) == 0) {
	    if ((cmd1 = strtok(NULL, " \t\n\r")) != NULL) {
		errper = VAL(cmd1);
	        if (errper) {
		    event(errinj, 0, (len = (random()%errper)));
		    printf("Error injection started with period %d\n",len);
	        } 
	     } else printf("Injected errors: %d\n",errcnt);
#endif
	} else if (strncmp(cmd1, "float", clen) == 0) {
	    stat = disp_fpu(sregs);
	} else if (strncmp(cmd1, "go", clen) == 0) {
	    if ((cmd1 = strtok(NULL, " \t\n\r")) == NULL) {
		len = last_load_addr;
	    } else {
		len = VAL(cmd1);
	    }
	    sregs->pc = len & ~3;
	    sregs->npc = sregs->pc + 4;
	    printf("resuming at 0x%08x\n",sregs->pc);
	    if ((cmd2 = strtok(NULL, " \t\n\r")) != NULL) {
		stat = run_sim(sregs, VAL(cmd2), 0);
	    } else {
		stat = run_sim(sregs, UINT64_MAX, 0);
	    }
	    daddr = sregs->pc;
	    sim_halt();
	} else if (strncmp(cmd1, "help", clen) == 0) {
	    gen_help();
	} else if (strncmp(cmd1, "history", clen) == 0) {
	    if ((cmd1 = strtok(NULL, " \t\n\r")) != NULL) {
		sregs->histlen = VAL(cmd1);
		if (sregs->histbuf != NULL)
		    free(sregs->histbuf);
		sregs->histbuf = (struct histype *) calloc(sregs->histlen, sizeof(struct histype));
		printf("trace history length = %d\n\r", sregs->histlen);
		sregs->histind = 0;

	    } else {
		j = sregs->histind;
		for (i = 0; i < sregs->histlen; i++) {
		    if (j >= sregs->histlen)
			j = 0;
		    printf(" %8d ", sregs->histbuf[j].time);
		    dis_mem(sregs->histbuf[j].addr, 1, &dinfo);
		    j++;
		}
	    }

	} else if (strncmp(cmd1, "load", clen) == 0) {
	    if ((cmd1 = strtok(NULL, " \t\n\r")) != NULL) {
		last_load_addr = bfd_load(cmd1);
		while ((cmd1 = strtok(NULL, " \t\n\r")) != NULL)
		    last_load_addr = bfd_load(cmd1);
	    } else {
		printf("load: no file specified\n");
	    }
	} else if (strncmp(cmd1, "mem", clen) == 0) {
	    if ((cmd1 = strtok(NULL, " \t\n\r")) != NULL)
		daddr = VAL(cmd1);
	    if ((cmd2 = strtok(NULL, " \t\n\r")) != NULL)
		len = VAL(cmd2);
	    else
		len = 64;
	    disp_mem(daddr, len);
	    daddr += len;
	} else if (strncmp(cmd1, "perf", clen) == 0) {
	    cmd1 = strtok(NULL, " \t\n\r");
	    if ((cmd1 != NULL) &&
		(strncmp(cmd1, "reset", strlen(cmd1)) == 0)) {
		reset_stat(sregs);
	    } else
		show_stat(sregs);
	} else if (strncmp(cmd1, "quit", clen) == 0) {
	    exit(0);
	} else if (strncmp(cmd1, "reg", clen) == 0) {
	    cmd1 = strtok(NULL, " \t\n\r");
	    cmd2 = strtok(NULL, " \t\n\r");
	    if (cmd2 != NULL)
		set_rega(sregs, cmd1, VAL(cmd2));
	    else if (cmd1 != NULL)
		disp_reg(sregs, cmd1);
	    else {
		disp_regs(sregs,sregs->psr);
		disp_ctrl(sregs);
	    }
	} else if (strncmp(cmd1, "reset", clen) == 0) {
	    ebase.simtime = 0;
	    reset_all();
	    reset_stat(sregs);
	} else if (strncmp(cmd1, "run", clen) == 0) {
	    ebase.simtime = 0;
	    reset_all();
	    reset_stat(sregs);
	    if ((cmd1 = strtok(NULL, " \t\n\r")) == NULL) {
		stat = run_sim(sregs, UINT64_MAX, 0);
	    } else {
		stat = run_sim(sregs, VAL(cmd1), 0);
	    }
	    daddr = sregs->pc;
	    sim_halt();
	} else if (strncmp(cmd1, "shell", clen) == 0) {
	    if ((cmd1 = strtok(NULL, " \t\n\r")) != NULL) {
		system(&cmdsave[clen]);
	    }
	} else if (strncmp(cmd1, "step", clen) == 0) {
	    stat = run_sim(sregs, 1, 1);
	    daddr = sregs->pc;
	    sim_halt();
	} else if (strncmp(cmd1, "tcont", clen) == 0) {
	    sregs->tlimit = limcalc(sregs->freq);
	    stat = run_sim(sregs, UINT64_MAX, 0);
	    daddr = sregs->pc;
	    sim_halt();
	} else if (strncmp(cmd1, "tgo", clen) == 0) {
	    if ((cmd1 = strtok(NULL, " \t\n\r")) == NULL) {
		len = last_load_addr;
	    } else {
		len = VAL(cmd1);
	        sregs->tlimit = limcalc(sregs->freq);
	    }
	    sregs->pc = len & ~3;
	    sregs->npc = sregs->pc + 4;
	    printf("resuming at 0x%08x\n",sregs->pc);
	    stat = run_sim(sregs, UINT64_MAX, 0);
	    daddr = sregs->pc;
	    sim_halt();
	} else if (strncmp(cmd1, "tlimit", clen) == 0) {
	   sregs->tlimit = limcalc(sregs->freq);
	   if (sregs->tlimit != (uint32) -1)
              printf("simulation limit = %u (%.3f ms)\n",(uint32) sregs->tlimit,
		sregs->tlimit / sregs->freq / 1000);
	} else if (strncmp(cmd1, "tra", clen) == 0) {
	    if ((cmd1 = strtok(NULL, " \t\n\r")) == NULL) {
		stat = run_sim(sregs, UINT64_MAX, 1);
	    } else {
		stat = run_sim(sregs, VAL(cmd1), 1);
	    }
	    printf("\n");
	    daddr = sregs->pc;
	    sim_halt();
	} else if (strncmp(cmd1, "trun", clen) == 0) {
	    ebase.simtime = 0;
	    reset_all();
	    reset_stat(sregs);
	    sregs->tlimit = limcalc(sregs->freq);
	    stat = run_sim(sregs, UINT64_MAX, 0);
	    daddr = sregs->pc;
	    sim_halt();
	} else
	    printf("syntax error\n");
    }
    if (cmdsave != NULL)
	free(cmdsave);
    return (stat);
}


void
reset_stat(sregs)
    struct pstate  *sregs;
{
    sregs->tottime = 0;
    sregs->pwdtime = 0;
    sregs->ninst = 0;
    sregs->fholdt = 0;
    sregs->holdt = 0;
    sregs->icntt = 0;
    sregs->finst = 0;
    sregs->nstore = 0;
    sregs->nload = 0;
    sregs->nbranch = 0;
    sregs->simstart = ebase.simtime;

}

void
show_stat(sregs)
    struct pstate  *sregs;
{
    uint32          iinst;
    uint32          stime, tottime;

    if (sregs->tottime == 0) tottime = 1; else tottime = sregs->tottime;
    stime = ebase.simtime - sregs->simstart;	/* Total simulated time */
#ifdef STAT

    iinst = sregs->ninst - sregs->finst - sregs->nload - sregs->nstore -
	sregs->nbranch;
#endif

    printf("\n Cycles       : %9d\n\r", ebase.simtime - sregs->simstart);
    printf(" Instructions : %9d\n", sregs->ninst);

#ifdef STAT
    printf("   integer    : %9.2f %%\n", 100.0 * (float) iinst / (float) sregs->ninst);
    printf("   load       : %9.2f %%\n",
	   100.0 * (float) sregs->nload / (float) sregs->ninst);
    printf("   store      : %9.2f %%\n",
	   100.0 * (float) sregs->nstore / (float) sregs->ninst);
    printf("   branch     : %9.2f %%\n",
	   100.0 * (float) sregs->nbranch / (float) sregs->ninst);
    printf("   float      : %9.2f %%\n",
	   100.0 * (float) sregs->finst / (float) sregs->ninst);
    printf(" Integer CPI  : %9.2f\n",
	   ((float) (stime - sregs->pwdtime - sregs->fholdt - sregs->finst))
	   /
	   (float) (sregs->ninst - sregs->finst));
    printf(" Float CPI    : %9.2f\n",
	   ((float) sregs->fholdt / (float) sregs->finst) + 1.0);
#endif
    printf(" Overall CPI  : %9.2f\n",
	   (float) (stime - sregs->pwdtime) / (float) sregs->ninst);
    printf("\n ERC32 performance (%4.1f MHz): %5.2f MOPS (%5.2f MIPS, %5.2f MFLOPS)\n",
	   sregs->freq, sregs->freq * (float) sregs->ninst / (float) (stime - sregs->pwdtime),
	   sregs->freq * (float) (sregs->ninst - sregs->finst) /
	   (float) (stime - sregs->pwdtime),
     sregs->freq * (float) sregs->finst / (float) (stime - sregs->pwdtime));
    printf(" Simulated ERC32 time        : %5.2f ms\n", (float) (ebase.simtime - sregs->simstart) / 1000.0 / sregs->freq);
    printf(" Processor utilisation       : %5.2f %%\n", 100.0 * (1.0 - ((float) sregs->pwdtime / (float) stime)));
    printf(" Real-time / simulator-time  : 1/%.2f \n",
      ((float) sregs->tottime) / ((float) (stime) / (sregs->freq * 1.0E6)));
    printf(" Simulator performance       : %d KIPS\n",sregs->ninst/tottime/1000);
    printf(" Used time (sys + user)      : %3d s\n\n", sregs->tottime);
}



void
init_bpt(sregs)
    struct pstate  *sregs;
{
    sregs->bptnum = 0;
    sregs->histlen = 0;
    sregs->histind = 0;
    sregs->histbuf = NULL;
    sregs->tlimit = -1;
}

static void
int_handler(sig)
    int32           sig;
{
    if (sig != 2)
	printf("\n\n Signal handler error  (%d)\n\n", sig);
    ctrl_c = 1;
}

void
init_signals()
{
    typedef void    (*PFI) ();
    static PFI      int_tab[2];

    int_tab[0] = signal(SIGTERM, int_handler);
    int_tab[1] = signal(SIGINT, int_handler);
}


extern struct disassemble_info dinfo;

struct estate   ebase;
struct evcell   evbuf[EVENT_MAX];
struct irqcell  irqarr[16];

static int
disp_fpu(sregs)
    struct pstate  *sregs;
{

    int         i;
    float	t;

    printf("\n fsr: %08X\n\n", sregs->fsr);

#ifdef HOST_LITTLE_ENDIAN_FLOAT
    for (i = 0; i < 32; i++)
      sregs->fdp[i ^ 1] = sregs->fs[i];
#endif

    for (i = 0; i < 32; i++) {
	t = sregs->fs[i];
	printf(" f%02d  %08x  %14e  ", i, sregs->fsi[i], sregs->fs[i]);
	if (!(i & 1))
	    printf("%14e\n", sregs->fd[i >> 1]);
	else
	    printf("\n");
    }
    printf("\n");
    return (OK);
}

static void
disp_regs(sregs,cwp)
    struct pstate  *sregs;
    int cwp;
{

    int           i;

    cwp = ((cwp & 0x7) << 4);
    printf("\n\t  INS       LOCALS      OUTS     GLOBALS\n");
    for (i = 0; i < 8; i++) {
	printf("   %d:  %08X   %08X   %08X   %08X\n", i,
	       sregs->r[(cwp + i + 24) & 0x7f],
	    sregs->r[(cwp + i + 16) & 0x7f], sregs->r[(cwp + i + 8) & 0x7f],
	       sregs->g[i]);
    }
}

static void
disp_ctrl(sregs)
    struct pstate  *sregs;
{

    unsigned char           i[4];

    printf("\n psr: %08X   wim: %08X   tbr: %08X   y: %08X\n",
	   sregs->psr, sregs->wim, sregs->tbr, sregs->y);
    sis_memory_read(sregs->pc, i, 4);
    printf("\n  pc: %08X = %02X%02X%02X%02X    ", sregs->pc,i[0],i[1],i[2],i[3]);
    print_insn_sparc(sregs->pc, &dinfo);
    sis_memory_read(sregs->npc, i, 4);
    printf("\n npc: %08X = %02X%02X%02X%02X    ",sregs->npc,i[0],i[1],i[2],i[3]);
    print_insn_sparc(sregs->npc, &dinfo);
    if (sregs->err_mode)
	printf("\n IU in error mode");
    printf("\n\n");
}

static void
disp_mem(addr, len)
    uint32          addr;
    uint32          len;
{

    uint32          i;
    unsigned char   data[4];
    uint32          mem[4], j;
    char           *p;

    for (i = addr & ~3; i < ((addr + len) & ~3); i += 16) {
	printf("\n %8X  ", i);
	for (j = 0; j < 4; j++) {
	    sis_memory_read((i + (j * 4)), data, 4);
	    printf("%02x%02x%02x%02x  ", data[0],data[1],data[2],data[3]);
	    mem[j] = *((int *) &data);
	}
	printf("  ");
	p = (char *) mem;
	for (j = 0; j < 16; j++) {
	    if (isprint(p[j]))
		putchar(p[j]);
	    else
		putchar('.');
	}
    }
    printf("\n\n");
}

void
dis_mem(addr, len, info)
    uint32          addr;
    uint32          len;
    struct disassemble_info *info;
{
    uint32          i;
    unsigned char   data[4];

    for (i = addr & -3; i < ((addr & -3) + (len << 2)); i += 4) {
	sis_memory_read(i, data, 4);
	printf(" %08x  %02x%02x%02x%02x  ", i, data[0],data[1],data[2],data[3]);
	print_insn_sparc(i, info);
        if (i >= 0xfffffffc) break;
	printf("\n");
    }
}

/* Add event to event queue */

void
event(cfunc, arg, delta)
    void            (*cfunc) ();
    int32           arg;
    uint64          delta;
{
    struct evcell  *ev1, *evins;

    if (ebase.freeq == NULL) {
	printf("Error, too many events in event queue\n");
	return;
    }
    ev1 = &ebase.eq;
    delta += ebase.simtime;
    while ((ev1->nxt != NULL) && (ev1->nxt->time <= delta)) {
	ev1 = ev1->nxt;
    }
    if (ev1->nxt == NULL) {
	ev1->nxt = ebase.freeq;
	ebase.freeq = ebase.freeq->nxt;
	ev1->nxt->nxt = NULL;
    } else {
	evins = ebase.freeq;
	ebase.freeq = ebase.freeq->nxt;
	evins->nxt = ev1->nxt;
	ev1->nxt = evins;
    }
    ev1->nxt->time = delta;
    ev1->nxt->cfunc = cfunc;
    ev1->nxt->arg = arg;
}

#if 0	/* apparently not used */
void
stop_event()
{
}
#endif

void
init_event()
{
    int32           i;

    ebase.eq.nxt = NULL;
    ebase.freeq = evbuf;
    for (i = 0; i < EVENT_MAX; i++) {
	evbuf[i].nxt = &evbuf[i + 1];
    }
    evbuf[EVENT_MAX - 1].nxt = NULL;
}

void
set_int(level, callback, arg)
    int32           level;
    void            (*callback) ();
    int32           arg;
{
    irqarr[level & 0x0f].callback = callback;
    irqarr[level & 0x0f].arg = arg;
}

/* Advance simulator time */

void
advance_time(sregs)
    struct pstate  *sregs;
{

    struct evcell  *evrem;
    void            (*cfunc) ();
    uint32          arg;
    uint64          endtime;

#ifdef STAT
    sregs->fholdt += sregs->fhold;
    sregs->holdt += sregs->hold;
    sregs->icntt += sregs->icnt;
#endif

    endtime = ebase.simtime + sregs->icnt + sregs->hold + sregs->fhold;

    while ((ebase.eq.nxt->time <= (endtime)) && (ebase.eq.nxt != NULL)) {
	ebase.simtime = ebase.eq.nxt->time;
	cfunc = ebase.eq.nxt->cfunc;
	arg = ebase.eq.nxt->arg;
	evrem = ebase.eq.nxt;
	ebase.eq.nxt = ebase.eq.nxt->nxt;
	evrem->nxt = ebase.freeq;
	ebase.freeq = evrem;
	cfunc(arg);
    }
    ebase.simtime = endtime;

}

uint32
now()
{
    return(ebase.simtime);
}


/* Advance time until an external interrupt is seen */

int
wait_for_irq()
{
    struct evcell  *evrem;
    void            (*cfunc) ();
    int32           arg;
    uint64          endtime;

    if (ebase.eq.nxt == NULL)
	printf("Warning: event queue empty - power-down mode not entered\n");
    endtime = ebase.simtime;
    while (!ext_irl && (ebase.eq.nxt != NULL)) {
	ebase.simtime = ebase.eq.nxt->time;
	cfunc = ebase.eq.nxt->cfunc;
	arg = ebase.eq.nxt->arg;
	evrem = ebase.eq.nxt;
	ebase.eq.nxt = ebase.eq.nxt->nxt;
	evrem->nxt = ebase.freeq;
	ebase.freeq = evrem;
	cfunc(arg);
	if (ctrl_c) {
	    printf("\bwarning: power-down mode interrupted\n");
	    break;
	}
    }
    sregs.pwdtime += ebase.simtime - endtime;
    return (ebase.simtime - endtime);
}

int
check_bpt(sregs)
    struct pstate  *sregs;
{
    int32           i;

    if ((sregs->bphit) || (sregs->annul))
	return (0);
    for (i = 0; i < (int32) sregs->bptnum; i++) {
	if (sregs->pc == sregs->bpts[i])
	    return (BPT_HIT);
    }
    return (0);
}

void
reset_all()
{
    init_event();		/* Clear event queue */
    init_regs(&sregs);
    reset();
#ifdef ERRINJ
    errinjstart();
#endif
}

void
sys_reset()
{
    reset_all();
    sregs.trap = 256;		/* Force fake reset trap */
}

void
sys_halt()
{
    sregs.trap = 257;           /* Force fake halt trap */
}

#include "ansidecl.h"

#include <stdarg.h>

#include "libiberty.h"
#include "bfd.h"

#define min(A, B) (((A) < (B)) ? (A) : (B))
#define LOAD_ADDRESS 0

int
bfd_load(fname)
    char           *fname;
{
    asection       *section;
    bfd            *pbfd;
    const bfd_arch_info_type *arch;

    pbfd = bfd_openr(fname, 0);

    if (pbfd == NULL) {
	printf("open of %s failed\n", fname);
	return (-1);
    }
    if (!bfd_check_format(pbfd, bfd_object)) {
	printf("file %s  doesn't seem to be an object file\n", fname);
	return (-1);
    }

    arch = bfd_get_arch_info (pbfd);
    if (bfd_little_endian (pbfd) || arch->mach == bfd_mach_sparc_sparclite_le)
        current_target_byte_order = LITTLE_ENDIAN;
    else
	current_target_byte_order = BIG_ENDIAN;
    if (sis_verbose)
	printf("file %s is %s-endian.\n", fname,
	       current_target_byte_order == BIG_ENDIAN ? "big" : "little");

    if (sis_verbose)
	printf("loading %s:", fname);
    for (section = pbfd->sections; section; section = section->next) {
	if (bfd_get_section_flags(pbfd, section) & SEC_ALLOC) {
	    bfd_vma         section_address;
	    unsigned long   section_size;
	    const char     *section_name;

	    section_name = bfd_get_section_name(pbfd, section);

	    section_address = bfd_get_section_vma(pbfd, section);
	    /*
	     * Adjust sections from a.out files, since they don't carry their
	     * addresses with.
	     */
	    if (bfd_get_flavour(pbfd) == bfd_target_aout_flavour) {
		if (strcmp (section_name, ".text") == 0)
		    section_address = bfd_get_start_address (pbfd);
		else if (strcmp (section_name, ".data") == 0) {
		    /* Read the first 8 bytes of the data section.
		       There should be the string 'DaTa' followed by
		       a word containing the actual section address. */
		    struct data_marker
		    {
			char signature[4];	/* 'DaTa' */
			unsigned char sdata[4];	/* &sdata */
		    } marker;
		    bfd_get_section_contents (pbfd, section, &marker, 0,
					      sizeof (marker));
		    if (strncmp (marker.signature, "DaTa", 4) == 0)
		      {
			if (current_target_byte_order == BIG_ENDIAN)
			  section_address = bfd_getb32 (marker.sdata);
			else
			  section_address = bfd_getl32 (marker.sdata);
		      }
		}
	    }

	    section_size = bfd_section_size(pbfd, section);

	    if (sis_verbose)
		printf("\nsection %s at 0x%08lx (0x%lx bytes)",
		       section_name, section_address, section_size);

	    /* Text, data or lit */
	    if (bfd_get_section_flags(pbfd, section) & SEC_LOAD) {
		file_ptr        fptr;

		fptr = 0;

		while (section_size > 0) {
		    char            buffer[1024];
		    int             count;

		    count = min(section_size, 1024);

		    bfd_get_section_contents(pbfd, section, buffer, fptr, count);

		    sis_memory_write(section_address, buffer, count);

		    section_address += count;
		    fptr += count;
		    section_size -= count;
		}
	    } else		/* BSS */
		if (sis_verbose)
		    printf("(not loaded)");
	}
    }
    if (sis_verbose)
	printf("\n");

    return(bfd_get_start_address (pbfd));
}
@


1.7
log
@Update sim copyright headers from GPLv2-or-later to GPLv3-or-later.

gdb/sim/ChangeLog:

        Update the non-FSF-copyrighted files in sim to GPLv3 or later.
@
text
@d18 1
a18 2
 * this program; if not, write to the Free Software Foundation, Inc., 675
 * Mass Ave, Cambridge, MA 02139, USA.
@


1.6
log
@	* end.c: Include config.h before system header files.
	* erc32.c: Likewise.
	* exec.c: Likewise.
	* float.c: Likewise.
	* func.c: Likewise.
	* help.c: Likewise.
	* interf.c: Likewise.
@
text
@d9 1
a9 1
 * Software Foundation; either version 2 of the License, or (at your option)
@


1.5
log
@2010-04-20  Tiemen Schut    <T.Schut@@sron.nl>

	* erc32.c (sis_memory_write): Change prototype to const unsigned char *.
	* func.c (exec_cmd, event, advance_time, wait_for_irq): Use uint64
	for counts.
	* interf.c (run_sim): Change icount to uint64_t. Use strtol directly.
	(sim_resume): Specify maximum run time as uint64.
	* sis.c (run_sim): Change icount to uint64_t.
	* sis.h: Define uint64 as uint64_t. Change various fields and
	prototypes to uint64 to support longer simulations.
@
text
@d23 1
@


1.4
log
@	* func.c: Remove ANSI_PROTOTYPES conditional code.
@
text
@d424 1
a424 1
		stat = run_sim(sregs, -1, 0);
d475 1
a475 1
		stat = run_sim(sregs, -1, 0);
d547 1
a547 1
		stat = run_sim(sregs, -1, 0);
d563 1
a563 1
	    stat = run_sim(sregs, -1, 0);
d576 1
a576 1
	    stat = run_sim(sregs, -1, 0);
d586 1
a586 1
		stat = run_sim(sregs, -1, 1);
d598 1
a598 1
	    stat = run_sim(sregs, -1, 0);
d836 1
a836 1
    uint32          delta;
d903 2
a904 1
    uint32          arg, endtime;
d942 2
a943 1
    int32           arg, endtime;
@


1.3
log
@2005-03-07  Jerome Guitton  <guitton@@gnat.com>

	* sim/erc32/float.c (set_fsr): Do not use deprecated multi-line
	strings.
	(clear_accex): Ditto.
	* sim/erc32/interf.c: Remove the redeclaration of fprintf.
	* sim/erc32/sis.c: Ditto.
	* sim/erc32/exec.c: Add missing semicolon.
	* sim/erc32/func.c: Remove definitions of generic_print_address,
	generic_symbol_at_address, buffer_read_memory and perror_memory, as
	they are already defined in opcodes/dis-buf.c.
@
text
@a1004 1
#ifdef ANSI_PROTOTYPES
a1005 3
#else
#include <varargs.h>
#endif
@


1.2
log
@* build patch

2000-03-03  Jonathan Larmour  <jlarmour@@redhat.co.uk>

	* func.c (buffer_read_memory): Change type of size to unsigned to
	match prototype
@
text
@a829 43
int
buffer_read_memory(addr, buffer, size, info)
    bfd_vma         addr;
    bfd_byte       *buffer;
    uint32          size;
    struct disassemble_info *info;
{
    if (size == sis_memory_read(addr, buffer, size))
	return (0);
    else
	return (1);
}

void
perror_memory(status, addr, info)
    int32           status;
    bfd_vma         addr;
    struct disassemble_info *info;
{

    printf("Could not read address 0x%08x\n", (unsigned int) addr);
}

void
generic_print_address(addr, info)
    bfd_vma         addr;
    struct disassemble_info *info;
{

    printf("0x%x", (unsigned int) addr);
}

/* Just return the given address.  */

int
generic_symbol_at_address (addr, info)
     bfd_vma addr;
     struct disassemble_info * info;
{
  return 1;
}


@


1.1
log
@Initial revision
@
text
@d834 1
a834 1
    int32           size;
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@

