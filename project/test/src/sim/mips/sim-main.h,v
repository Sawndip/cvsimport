head	1.37;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.37
	gdb_7_6-2013-04-26-release:1.37
	gdb_7_6-branch:1.37.0.2
	gdb_7_6-2013-03-12-branchpoint:1.37
	gdb_7_5_1-2012-11-29-release:1.36
	gdb_7_5-2012-08-17-release:1.36
	gdb_7_5-branch:1.36.0.2
	gdb_7_5-2012-07-18-branchpoint:1.36
	gdb_7_4_1-2012-04-26-release:1.35.4.1
	gdb_7_4-2012-01-24-release:1.35.4.1
	gdb_7_4-branch:1.35.0.4
	gdb_7_4-2011-12-13-branchpoint:1.35
	gdb_7_3_1-2011-09-04-release:1.35
	gdb_7_3-2011-07-26-release:1.35
	gdb_7_3-branch:1.35.0.2
	gdb_7_3-2011-04-01-branchpoint:1.35
	gdb_7_2-2010-09-02-release:1.34
	gdb_7_2-branch:1.34.0.4
	gdb_7_2-2010-07-07-branchpoint:1.34
	gdb_7_1-2010-03-18-release:1.34
	gdb_7_1-branch:1.34.0.2
	gdb_7_1-2010-02-18-branchpoint:1.34
	gdb_7_0_1-2009-12-22-release:1.33
	gdb_7_0-2009-10-06-release:1.33
	gdb_7_0-branch:1.33.0.4
	gdb_7_0-2009-09-16-branchpoint:1.33
	arc-sim-20090309:1.32
	msnyder-checkpoint-072509-branch:1.33.0.2
	msnyder-checkpoint-072509-branchpoint:1.33
	arc-insight_6_8-branch:1.32.0.16
	arc-insight_6_8-branchpoint:1.32
	insight_6_8-branch:1.32.0.14
	insight_6_8-branchpoint:1.32
	reverse-20081226-branch:1.32.0.12
	reverse-20081226-branchpoint:1.32
	multiprocess-20081120-branch:1.32.0.10
	multiprocess-20081120-branchpoint:1.32
	reverse-20080930-branch:1.32.0.8
	reverse-20080930-branchpoint:1.32
	reverse-20080717-branch:1.32.0.6
	reverse-20080717-branchpoint:1.32
	msnyder-reverse-20080609-branch:1.32.0.4
	msnyder-reverse-20080609-branchpoint:1.32
	drow-reverse-20070409-branch:1.30.0.2
	drow-reverse-20070409-branchpoint:1.30
	gdb_6_8-2008-03-27-release:1.32
	gdb_6_8-branch:1.32.0.2
	gdb_6_8-2008-02-26-branchpoint:1.32
	gdb_6_7_1-2007-10-29-release:1.31
	gdb_6_7-2007-10-10-release:1.31
	gdb_6_7-branch:1.31.0.2
	gdb_6_7-2007-09-07-branchpoint:1.31
	insight_6_6-20070208-release:1.29
	gdb_6_6-2006-12-18-release:1.29
	gdb_6_6-branch:1.29.0.2
	gdb_6_6-2006-11-15-branchpoint:1.29
	insight_6_5-20061003-release:1.28
	gdb-csl-symbian-6_4_50_20060226-12:1.28
	gdb-csl-sourcerygxx-3_4_4-25:1.27
	nickrob-async-20060828-mergepoint:1.28
	gdb-csl-symbian-6_4_50_20060226-11:1.28
	gdb-csl-sourcerygxx-4_1-17:1.28
	gdb-csl-20060226-branch-local-2:1.28
	gdb-csl-sourcerygxx-4_1-14:1.28
	gdb-csl-sourcerygxx-4_1-13:1.28
	gdb-csl-sourcerygxx-4_1-12:1.28
	gdb-csl-sourcerygxx-3_4_4-21:1.28
	gdb_6_5-20060621-release:1.28
	gdb-csl-sourcerygxx-4_1-9:1.28
	gdb-csl-sourcerygxx-4_1-8:1.28
	gdb-csl-sourcerygxx-4_1-7:1.28
	gdb-csl-arm-2006q1-6:1.28
	gdb-csl-sourcerygxx-4_1-6:1.28
	gdb-csl-symbian-6_4_50_20060226-10:1.28
	gdb-csl-symbian-6_4_50_20060226-9:1.28
	gdb-csl-symbian-6_4_50_20060226-8:1.28
	gdb-csl-coldfire-4_1-11:1.28
	gdb-csl-sourcerygxx-3_4_4-19:1.28
	gdb-csl-coldfire-4_1-10:1.28
	gdb_6_5-branch:1.28.0.16
	gdb_6_5-2006-05-14-branchpoint:1.28
	gdb-csl-sourcerygxx-4_1-5:1.28
	nickrob-async-20060513-branch:1.28.0.14
	nickrob-async-20060513-branchpoint:1.28
	gdb-csl-sourcerygxx-4_1-4:1.28
	msnyder-reverse-20060502-branch:1.28.0.12
	msnyder-reverse-20060502-branchpoint:1.28
	gdb-csl-morpho-4_1-4:1.28
	gdb-csl-sourcerygxx-3_4_4-17:1.28
	readline_5_1-import-branch:1.28.0.10
	readline_5_1-import-branchpoint:1.28
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.28
	gdb-csl-symbian-20060226-branch:1.28.0.8
	gdb-csl-symbian-20060226-branchpoint:1.28
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.28
	msnyder-reverse-20060331-branch:1.28.0.6
	msnyder-reverse-20060331-branchpoint:1.28
	gdb-csl-available-20060303-branch:1.28.0.4
	gdb-csl-available-20060303-branchpoint:1.28
	gdb-csl-20060226-branch:1.28.0.2
	gdb-csl-20060226-branchpoint:1.28
	gdb_6_4-20051202-release:1.27
	msnyder-fork-checkpoint-branch:1.27.0.18
	msnyder-fork-checkpoint-branchpoint:1.27
	gdb-csl-gxxpro-6_3-branch:1.27.0.16
	gdb-csl-gxxpro-6_3-branchpoint:1.27
	gdb_6_4-branch:1.27.0.14
	gdb_6_4-2005-11-01-branchpoint:1.27
	gdb-csl-arm-20051020-branch:1.27.0.12
	gdb-csl-arm-20051020-branchpoint:1.27
	msnyder-tracepoint-checkpoint-branch:1.27.0.10
	msnyder-tracepoint-checkpoint-branchpoint:1.27
	gdb-csl-arm-20050325-2005-q1b:1.27
	gdb-csl-arm-20050325-2005-q1a:1.27
	csl-arm-20050325-branch:1.27.0.8
	csl-arm-20050325-branchpoint:1.27
	gdb_6_3-20041109-release:1.27
	gdb_6_3-branch:1.27.0.4
	gdb_6_3-20041019-branchpoint:1.27
	drow_intercu-merge-20040921:1.27
	drow_intercu-merge-20040915:1.27
	jimb-gdb_6_2-e500-branch:1.27.0.6
	jimb-gdb_6_2-e500-branchpoint:1.27
	gdb_6_2-20040730-release:1.27
	gdb_6_2-branch:1.27.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.27
	gdb_6_1_1-20040616-release:1.25.48.1
	gdb_6_1-2004-04-05-release:1.25
	drow_intercu-merge-20040402:1.26
	drow_intercu-merge-20040327:1.25
	ezannoni_pie-20040323-branch:1.25.0.52
	ezannoni_pie-20040323-branchpoint:1.25
	cagney_tramp-20040321-mergepoint:1.25
	cagney_tramp-20040309-branch:1.25.0.50
	cagney_tramp-20040309-branchpoint:1.25
	gdb_6_1-branch:1.25.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.25
	drow_intercu-20040221-branch:1.25.0.46
	drow_intercu-20040221-branchpoint:1.25
	cagney_bfdfile-20040213-branch:1.25.0.44
	cagney_bfdfile-20040213-branchpoint:1.25
	drow-cplus-merge-20040208:1.25
	carlton_dictionary-20040126-merge:1.25
	cagney_bigcore-20040122-branch:1.25.0.42
	cagney_bigcore-20040122-branchpoint:1.25
	drow-cplus-merge-20040113:1.25
	drow-cplus-merge-20031224:1.25
	drow-cplus-merge-20031220:1.25
	carlton_dictionary-20031215-merge:1.25
	drow-cplus-merge-20031214:1.25
	carlton-dictionary-20031111-merge:1.25
	gdb_6_0-2003-10-04-release:1.25
	kettenis_sparc-20030918-branch:1.25.0.40
	kettenis_sparc-20030918-branchpoint:1.25
	carlton_dictionary-20030917-merge:1.25
	ezannoni_pie-20030916-branchpoint:1.25
	ezannoni_pie-20030916-branch:1.25.0.38
	cagney_x86i386-20030821-branch:1.25.0.36
	cagney_x86i386-20030821-branchpoint:1.25
	carlton_dictionary-20030805-merge:1.25
	carlton_dictionary-20030627-merge:1.25
	gdb_6_0-branch:1.25.0.34
	gdb_6_0-2003-06-23-branchpoint:1.25
	jimb-ppc64-linux-20030613-branch:1.25.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.25
	cagney_convert-20030606-branch:1.25.0.30
	cagney_convert-20030606-branchpoint:1.25
	cagney_writestrings-20030508-branch:1.25.0.28
	cagney_writestrings-20030508-branchpoint:1.25
	jimb-ppc64-linux-20030528-branch:1.25.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.25
	carlton_dictionary-20030523-merge:1.25
	cagney_fileio-20030521-branch:1.25.0.24
	cagney_fileio-20030521-branchpoint:1.25
	kettenis_i386newframe-20030517-mergepoint:1.25
	jimb-ppc64-linux-20030509-branch:1.25.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.25
	kettenis_i386newframe-20030504-mergepoint:1.25
	carlton_dictionary-20030430-merge:1.25
	kettenis_i386newframe-20030419-branch:1.25.0.20
	kettenis_i386newframe-20030419-branchpoint:1.25
	carlton_dictionary-20030416-merge:1.25
	cagney_frameaddr-20030409-mergepoint:1.25
	kettenis_i386newframe-20030406-branch:1.25.0.18
	kettenis_i386newframe-20030406-branchpoint:1.25
	cagney_frameaddr-20030403-branchpoint:1.25
	cagney_frameaddr-20030403-branch:1.25.0.16
	cagney_framebase-20030330-mergepoint:1.25
	cagney_framebase-20030326-branch:1.25.0.14
	cagney_framebase-20030326-branchpoint:1.25
	cagney_lazyid-20030317-branch:1.25.0.12
	cagney_lazyid-20030317-branchpoint:1.25
	kettenis-i386newframe-20030316-mergepoint:1.25
	offbyone-20030313-branch:1.25.0.10
	offbyone-20030313-branchpoint:1.25
	kettenis-i386newframe-20030308-branch:1.25.0.8
	kettenis-i386newframe-20030308-branchpoint:1.25
	carlton_dictionary-20030305-merge:1.25
	cagney_offbyone-20030303-branch:1.25.0.6
	cagney_offbyone-20030303-branchpoint:1.25
	carlton_dictionary-20030207-merge:1.25
	interps-20030202-branch:1.25.0.4
	interps-20030202-branchpoint:1.25
	cagney-unwind-20030108-branch:1.25.0.2
	cagney-unwind-20030108-branchpoint:1.25
	carlton_dictionary-20021223-merge:1.23
	gdb_5_3-2002-12-12-release:1.23
	carlton_dictionary-20021115-merge:1.23
	kseitz_interps-20021105-merge:1.23
	kseitz_interps-20021103-merge:1.23
	drow-cplus-merge-20021020:1.23
	drow-cplus-merge-20021025:1.23
	carlton_dictionary-20021025-merge:1.23
	carlton_dictionary-20021011-merge:1.23
	drow-cplus-branch:1.23.0.10
	drow-cplus-branchpoint:1.23
	kseitz_interps-20020930-merge:1.23
	carlton_dictionary-20020927-merge:1.23
	carlton_dictionary-branch:1.23.0.8
	carlton_dictionary-20020920-branchpoint:1.23
	gdb_5_3-branch:1.23.0.6
	gdb_5_3-2002-09-04-branchpoint:1.23
	kseitz_interps-20020829-merge:1.23
	cagney_sysregs-20020825-branch:1.23.0.4
	cagney_sysregs-20020825-branchpoint:1.23
	readline_4_3-import-branch:1.23.0.2
	readline_4_3-import-branchpoint:1.23
	gdb_5_2_1-2002-07-23-release:1.7
	kseitz_interps-20020528-branch:1.13.0.6
	kseitz_interps-20020528-branchpoint:1.13
	cagney_regbuf-20020515-branch:1.13.0.4
	cagney_regbuf-20020515-branchpoint:1.13
	jimb-macro-020506-branch:1.13.0.2
	jimb-macro-020506-branchpoint:1.13
	gdb_5_2-2002-04-29-release:1.7
	gdb_5_2-branch:1.7.0.2
	gdb_5_2-2002-03-03-branchpoint:1.7
	gdb_5_1_1-2002-01-24-release:1.6
	gdb_5_1_0_1-2002-01-03-release:1.6
	gdb_5_1_0_1-2002-01-03-branch:1.6.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.6
	gdb_5_1-2001-11-21-release:1.6
	gdb_s390-2001-09-26-branch:1.6.0.4
	gdb_s390-2001-09-26-branchpoint:1.6
	gdb_5_1-2001-07-29-branch:1.6.0.2
	gdb_5_1-2001-07-29-branchpoint:1.6
	insight-precleanup-2001-01-01:1.3
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.37
date	2013.01.01.06.41.39;	author brobecke;	state Exp;
branches;
next	1.36;

1.36
date	2012.01.04.08.28.20;	author brobecke;	state Exp;
branches;
next	1.35;

1.35
date	2011.01.01.15.34.03;	author brobecke;	state Exp;
branches
	1.35.4.1;
next	1.34;

1.34
date	2010.01.01.10.03.32;	author brobecke;	state Exp;
branches;
next	1.33;

1.33
date	2009.01.14.10.53.08;	author brobecke;	state Exp;
branches;
next	1.32;

1.32
date	2008.01.01.22.53.25;	author drow;	state Exp;
branches;
next	1.31;

1.31
date	2007.08.24.14.28.40;	author brobecke;	state Exp;
branches;
next	1.30;

1.30
date	2007.01.09.17.59.18;	author drow;	state Exp;
branches;
next	1.29;

1.29
date	2006.08.29.12.45.26;	author ths;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.14.23.07.56;	author chaoyingfu;	state Exp;
branches;
next	1.27;

1.27
date	2004.05.12.01.42.33;	author cgd;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.29.21.56.01;	author rsandifo;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.05.07.56.59;	author cgd;	state Exp;
branches
	1.25.46.1
	1.25.48.1;
next	1.24;

1.24
date	2002.12.31.21.31.32;	author cgd;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.14.18.49.09;	author cgd;	state Exp;
branches
	1.23.8.1
	1.23.10.1;
next	1.22;

1.22
date	2002.06.14.04.44.11;	author cgd;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.08.03.05.23;	author cgd;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.07.00.13.24;	author cgd;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.04.22.38.41;	author cgd;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.04.16.17.20;	author cgd;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.04.01.35.23;	author cgd;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.04.00.18.46;	author cgd;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.03.21.00.29;	author cgd;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.02.07.39.26;	author cgd;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.01.23.26.32;	author cgd;	state Exp;
branches
	1.13.4.1
	1.13.6.1;
next	1.12;

1.12
date	2002.05.01.17.26.14;	author cgd;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.06.06.46.29;	author cgd;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.06.06.21.17;	author cgd;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.06.05.41.40;	author cgd;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.05.19.22.13;	author cgd;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.18.06.00.29;	author fnf;	state Exp;
branches;
next	1.6;

1.6
date	2001.04.12.14.53.20;	author jimb;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.24.02.43.11;	author bje;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.19.21.57.03;	author bje;	state Exp;
branches;
next	1.3;

1.3
date	2000.10.19.10.52.52;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.29.19.38.39;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.07;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.35.4.1
date	2012.01.06.04.54.54;	author brobecke;	state Exp;
branches;
next	;

1.25.46.1
date	2004.04.02.16.47.53;	author drow;	state Exp;
branches;
next	1.25.46.2;

1.25.46.2
date	2004.09.16.17.02.12;	author drow;	state Exp;
branches;
next	;

1.25.48.1
date	2004.05.12.01.44.19;	author cgd;	state Exp;
branches;
next	;

1.23.8.1
date	2003.02.07.19.18.06;	author carlton;	state Exp;
branches;
next	;

1.23.10.1
date	2003.12.14.20.28.28;	author drow;	state Exp;
branches;
next	;

1.13.4.1
date	2002.06.15.16.43.28;	author cagney;	state Exp;
branches;
next	;

1.13.6.1
date	2002.06.20.01.40.30;	author kseitz;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.35.07;	author shebs;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* MIPS Simulator definition.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   Contributed by Cygnus Support.

This file is part of GDB, the GNU debugger.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#ifndef SIM_MAIN_H
#define SIM_MAIN_H

/* This simulator doesn't cache the Current Instruction Address */
/* #define SIM_ENGINE_HALT_HOOK(SD, LAST_CPU, CIA) */
/* #define SIM_ENGINE_RESUME_HOOK(SD, LAST_CPU, CIA) */

#define SIM_HAVE_BIENDIAN


/* hobble some common features for moment */
#define WITH_WATCHPOINTS 1
#define WITH_MODULO_MEMORY 1


#define SIM_CORE_SIGNAL(SD,CPU,CIA,MAP,NR_BYTES,ADDR,TRANSFER,ERROR) \
mips_core_signal ((SD), (CPU), (CIA), (MAP), (NR_BYTES), (ADDR), (TRANSFER), (ERROR))

#include "sim-basics.h"

typedef address_word sim_cia;

#include "sim-base.h"
#include "bfd.h"

/* Deprecated macros and types for manipulating 64bit values.  Use
   ../common/sim-bits.h and ../common/sim-endian.h macros instead. */

typedef signed64 word64;
typedef unsigned64 uword64;

#define WORD64LO(t)     (unsigned int)((t)&0xFFFFFFFF)
#define WORD64HI(t)     (unsigned int)(((uword64)(t))>>32)
#define SET64LO(t)      (((uword64)(t))&0xFFFFFFFF)
#define SET64HI(t)	(((uword64)(t))<<32)
#define WORD64(h,l)     ((word64)((SET64HI(h)|SET64LO(l))))
#define UWORD64(h,l)     (SET64HI(h)|SET64LO(l))

/* Check if a value will fit within a halfword: */
#define NOTHALFWORDVALUE(v) ((((((uword64)(v)>>16) == 0) && !((v) & ((unsigned)1 << 15))) || (((((uword64)(v)>>32) == 0xFFFFFFFF) && ((((uword64)(v)>>16) & 0xFFFF) == 0xFFFF)) && ((v) & ((unsigned)1 << 15)))) ? (1 == 0) : (1 == 1))



/* Floating-point operations: */

#include "sim-fpu.h"
#include "cp1.h"

/* FPU registers must be one of the following types. All other values
   are reserved (and undefined). */
typedef enum {
 fmt_single  = 0,
 fmt_double  = 1,
 fmt_word    = 4,
 fmt_long    = 5,
 fmt_ps      = 6,
 /* The following are well outside the normal acceptable format
    range, and are used in the register status vector. */
 fmt_unknown       = 0x10000000,
 fmt_uninterpreted = 0x20000000,
 fmt_uninterpreted_32 = 0x40000000,
 fmt_uninterpreted_64 = 0x80000000U,
} FP_formats;

/* For paired word (pw) operations, the opcode representation is fmt_word,
   but register transfers (StoreFPR, ValueFPR, etc.) are done as fmt_long.  */
#define fmt_pw fmt_long

/* This should be the COC1 value at the start of the preceding
   instruction: */
#define PREVCOC1() ((STATE & simPCOC1) ? 1 : 0)

#ifdef TARGET_ENABLE_FR
/* FIXME: this should be enabled for all targets, but needs testing first. */
#define SizeFGR() (((WITH_TARGET_FLOATING_POINT_BITSIZE) == 64) \
   ? ((SR & status_FR) ? 64 : 32) \
   : (WITH_TARGET_FLOATING_POINT_BITSIZE))
#else
#define SizeFGR() (WITH_TARGET_FLOATING_POINT_BITSIZE)
#endif





/* HI/LO register accesses */

/* For some MIPS targets, the HI/LO registers have certain timing
   restrictions in that, for instance, a read of a HI register must be
   separated by at least three instructions from a preceeding read.

   The struct below is used to record the last access by each of A MT,
   MF or other OP instruction to a HI/LO register.  See mips.igen for
   more details. */

typedef struct _hilo_access {
  signed64 timestamp;
  address_word cia;
} hilo_access;

typedef struct _hilo_history {
  hilo_access mt;
  hilo_access mf;
  hilo_access op;
} hilo_history;




/* Integer ALU operations: */

#include "sim-alu.h"

#define ALU32_END(ANS) \
  if (ALU32_HAD_OVERFLOW) \
    SignalExceptionIntegerOverflow (); \
  (ANS) = (signed32) ALU32_OVERFLOW_RESULT


#define ALU64_END(ANS) \
  if (ALU64_HAD_OVERFLOW) \
    SignalExceptionIntegerOverflow (); \
  (ANS) = ALU64_OVERFLOW_RESULT;





/* The following is probably not used for MIPS IV onwards: */
/* Slots for delayed register updates. For the moment we just have a
   fixed number of slots (rather than a more generic, dynamic
   system). This keeps the simulator fast. However, we only allow
   for the register update to be delayed for a single instruction
   cycle. */
#define PSLOTS (8) /* Maximum number of instruction cycles */

typedef struct _pending_write_queue {
  int in;
  int out;
  int total;
  int slot_delay[PSLOTS];
  int slot_size[PSLOTS];
  int slot_bit[PSLOTS];
  void *slot_dest[PSLOTS];
  unsigned64 slot_value[PSLOTS];
} pending_write_queue;

#ifndef PENDING_TRACE
#define PENDING_TRACE 0
#endif
#define PENDING_IN ((CPU)->pending.in)
#define PENDING_OUT ((CPU)->pending.out)
#define PENDING_TOTAL ((CPU)->pending.total)
#define PENDING_SLOT_SIZE ((CPU)->pending.slot_size)
#define PENDING_SLOT_BIT ((CPU)->pending.slot_bit)
#define PENDING_SLOT_DELAY ((CPU)->pending.slot_delay)
#define PENDING_SLOT_DEST ((CPU)->pending.slot_dest)
#define PENDING_SLOT_VALUE ((CPU)->pending.slot_value)

/* Invalidate the pending write queue, all pending writes are
   discarded. */

#define PENDING_INVALIDATE() \
memset (&(CPU)->pending, 0, sizeof ((CPU)->pending))

/* Schedule a write to DEST for N cycles time.  For 64 bit
   destinations, schedule two writes.  For floating point registers,
   the caller should schedule a write to both the dest register and
   the FPR_STATE register.  When BIT is non-negative, only BIT of DEST
   is updated. */

#define PENDING_SCHED(DEST,VAL,DELAY,BIT)				\
  do {									\
    if (PENDING_SLOT_DEST[PENDING_IN] != NULL)				\
      sim_engine_abort (SD, CPU, cia,					\
		        "PENDING_SCHED - buffer overflow\n");		\
    if (PENDING_TRACE)							\
      sim_io_eprintf (SD, "PENDING_SCHED - 0x%lx - dest 0x%lx, val 0x%lx, bit %d, size %d, pending_in %d, pending_out %d, pending_total %d\n",			\
		      (unsigned long) cia, (unsigned long) &(DEST),	\
		      (unsigned long) (VAL), (BIT), (int) sizeof (DEST),\
		      PENDING_IN, PENDING_OUT, PENDING_TOTAL);		\
    PENDING_SLOT_DELAY[PENDING_IN] = (DELAY) + 1;			\
    PENDING_SLOT_DEST[PENDING_IN] = &(DEST);				\
    PENDING_SLOT_VALUE[PENDING_IN] = (VAL);				\
    PENDING_SLOT_SIZE[PENDING_IN] = sizeof (DEST);			\
    PENDING_SLOT_BIT[PENDING_IN] = (BIT);				\
    PENDING_IN = (PENDING_IN + 1) % PSLOTS;                             \
    PENDING_TOTAL += 1;			                                \
  } while (0)

#define PENDING_WRITE(DEST,VAL,DELAY) PENDING_SCHED(DEST,VAL,DELAY,-1)
#define PENDING_BIT(DEST,VAL,DELAY,BIT) PENDING_SCHED(DEST,VAL,DELAY,BIT)

#define PENDING_TICK() pending_tick (SD, CPU, cia)

#define PENDING_FLUSH() abort () /* think about this one */
#define PENDING_FP() abort () /* think about this one */

/* For backward compatibility */
#define PENDING_FILL(R,VAL) 						\
do {									\
  if ((R) >= FGR_BASE && (R) < FGR_BASE + NR_FGR)			\
    {									\
      PENDING_SCHED(FGR[(R) - FGR_BASE], VAL, 1, -1);			\
      PENDING_SCHED(FPR_STATE[(R) - FGR_BASE], fmt_uninterpreted, 1, -1); \
    }									\
  else									\
    PENDING_SCHED(GPR[(R)], VAL, 1, -1);				\
} while (0)


enum float_operation
  {
    FLOP_ADD,    FLOP_SUB,    FLOP_MUL,    FLOP_MADD,
    FLOP_MSUB,   FLOP_MAX=10, FLOP_MIN,    FLOP_ABS,
    FLOP_ITOF0=14, FLOP_FTOI0=18, FLOP_NEG=23
  };


/* The internal representation of an MDMX accumulator. 
   Note that 24 and 48 bit accumulator elements are represented in
   32 or 64 bits.  Since the accumulators are 2's complement with
   overflow suppressed, high-order bits can be ignored in most contexts.  */

typedef signed32 signed24;
typedef signed64 signed48;

typedef union { 
  signed24  ob[8];
  signed48  qh[4]; 
} MDMX_accumulator;


/* Conventional system arguments.  */ 
#define SIM_STATE  sim_cpu *cpu, address_word cia
#define SIM_ARGS   CPU, cia

struct _sim_cpu {


  /* The following are internal simulator state variables: */
#define CIA_GET(CPU) ((CPU)->registers[PCIDX] + 0)
#define CIA_SET(CPU,CIA) ((CPU)->registers[PCIDX] = (CIA))
  address_word dspc;  /* delay-slot PC */
#define DSPC ((CPU)->dspc)

#define DELAY_SLOT(TARGET) NIA = delayslot32 (SD_, (TARGET))
#define NULLIFY_NEXT_INSTRUCTION() NIA = nullify_next_insn32 (SD_)


  /* State of the simulator */
  unsigned int state;
  unsigned int dsstate;
#define STATE ((CPU)->state)
#define DSSTATE ((CPU)->dsstate)

/* Flags in the "state" variable: */
#define simHALTEX       (1 << 2)  /* 0 = run; 1 = halt on exception */
#define simHALTIN       (1 << 3)  /* 0 = run; 1 = halt on interrupt */
#define simTRACE        (1 << 8)  /* 0 = do nothing; 1 = trace address activity */
#define simPCOC0        (1 << 17) /* COC[1] from current */
#define simPCOC1        (1 << 18) /* COC[1] from previous */
#define simDELAYSLOT    (1 << 24) /* 0 = do nothing; 1 = delay slot entry exists */
#define simSKIPNEXT     (1 << 25) /* 0 = do nothing; 1 = skip instruction */
#define simSIGINT	(1 << 28)  /* 0 = do nothing; 1 = SIGINT has occured */
#define simJALDELAYSLOT	(1 << 29) /* 1 = in jal delay slot */

#ifndef ENGINE_ISSUE_PREFIX_HOOK
#define ENGINE_ISSUE_PREFIX_HOOK() \
  { \
    /* Perform any pending writes */ \
    PENDING_TICK(); \
    /* Set previous flag, depending on current: */ \
    if (STATE & simPCOC0) \
     STATE |= simPCOC1; \
    else \
     STATE &= ~simPCOC1; \
    /* and update the current value: */ \
    if (GETFCC(0)) \
     STATE |= simPCOC0; \
    else \
     STATE &= ~simPCOC0; \
  }
#endif /* ENGINE_ISSUE_PREFIX_HOOK */


/* This is nasty, since we have to rely on matching the register
   numbers used by GDB. Unfortunately, depending on the MIPS target
   GDB uses different register numbers. We cannot just include the
   relevant "gdb/tm.h" link, since GDB may not be configured before
   the sim world, and also the GDB header file requires too much other
   state. */

#ifndef TM_MIPS_H
#define LAST_EMBED_REGNUM (96)
#define NUM_REGS (LAST_EMBED_REGNUM + 1)

#define FP0_REGNUM 38           /* Floating point register 0 (single float) */
#define FCRCS_REGNUM 70         /* FP control/status */
#define FCRIR_REGNUM 71         /* FP implementation/revision */
#endif


/* To keep this default simulator simple, and fast, we use a direct
   vector of registers. The internal simulator engine then uses
   manifests to access the correct slot. */

  unsigned_word registers[LAST_EMBED_REGNUM + 1];

  int register_widths[NUM_REGS];
#define REGISTERS       ((CPU)->registers)

#define GPR     (&REGISTERS[0])
#define GPR_SET(N,VAL) (REGISTERS[(N)] = (VAL))

#define LO      (REGISTERS[33])
#define HI      (REGISTERS[34])
#define PCIDX	37
#define PC      (REGISTERS[PCIDX])
#define CAUSE   (REGISTERS[36])
#define SRIDX   (32)
#define SR      (REGISTERS[SRIDX])      /* CPU status register */
#define FCR0IDX  (71)
#define FCR0    (REGISTERS[FCR0IDX])    /* really a 32bit register */
#define FCR31IDX (70)
#define FCR31   (REGISTERS[FCR31IDX])   /* really a 32bit register */
#define FCSR    (FCR31)
#define Debug	(REGISTERS[86])
#define DEPC	(REGISTERS[87])
#define EPC	(REGISTERS[88])
#define ACX	(REGISTERS[89])

#define AC0LOIDX	(33)	/* Must be the same register as LO */
#define AC0HIIDX	(34)	/* Must be the same register as HI */
#define AC1LOIDX	(90)
#define AC1HIIDX	(91)
#define AC2LOIDX	(92)
#define AC2HIIDX	(93)
#define AC3LOIDX	(94)
#define AC3HIIDX	(95)

#define DSPLO(N)	(REGISTERS[DSPLO_REGNUM[N]])
#define DSPHI(N)	(REGISTERS[DSPHI_REGNUM[N]])

#define DSPCRIDX	(96)	/* DSP control register */
#define DSPCR		(REGISTERS[DSPCRIDX])

#define DSPCR_POS_SHIFT		(0)
#define DSPCR_POS_MASK		(0x3f)
#define DSPCR_POS_SMASK		(DSPCR_POS_MASK << DSPCR_POS_SHIFT)

#define DSPCR_SCOUNT_SHIFT	(7)
#define DSPCR_SCOUNT_MASK	(0x3f)
#define DSPCR_SCOUNT_SMASK	(DSPCR_SCOUNT_MASK << DSPCR_SCOUNT_SHIFT)

#define DSPCR_CARRY_SHIFT	(13)
#define DSPCR_CARRY_MASK	(1)
#define DSPCR_CARRY_SMASK	(DSPCR_CARRY_MASK << DSPCR_CARRY_SHIFT)
#define DSPCR_CARRY		(1 << DSPCR_CARRY_SHIFT)

#define DSPCR_EFI_SHIFT		(14)
#define DSPCR_EFI_MASK		(1)
#define DSPCR_EFI_SMASK		(DSPCR_EFI_MASK << DSPCR_EFI_SHIFT)
#define DSPCR_EFI		(1 << DSPCR_EFI_MASK)

#define DSPCR_OUFLAG_SHIFT	(16)
#define DSPCR_OUFLAG_MASK	(0xff)
#define DSPCR_OUFLAG_SMASK	(DSPCR_OUFLAG_MASK << DSPCR_OUFLAG_SHIFT)
#define DSPCR_OUFLAG4		(1 << (DSPCR_OUFLAG_SHIFT + 4))
#define DSPCR_OUFLAG5		(1 << (DSPCR_OUFLAG_SHIFT + 5))
#define DSPCR_OUFLAG6		(1 << (DSPCR_OUFLAG_SHIFT + 6))
#define DSPCR_OUFLAG7		(1 << (DSPCR_OUFLAG_SHIFT + 7))

#define DSPCR_CCOND_SHIFT	(24)
#define DSPCR_CCOND_MASK	(0xf)
#define DSPCR_CCOND_SMASK	(DSPCR_CCOND_MASK << DSPCR_CCOND_SHIFT)

  /* All internal state modified by signal_exception() that may need to be
     rolled back for passing moment-of-exception image back to gdb. */
  unsigned_word exc_trigger_registers[LAST_EMBED_REGNUM + 1];
  unsigned_word exc_suspend_registers[LAST_EMBED_REGNUM + 1];
  int exc_suspended;

#define SIM_CPU_EXCEPTION_TRIGGER(SD,CPU,CIA) mips_cpu_exception_trigger(SD,CPU,CIA)
#define SIM_CPU_EXCEPTION_SUSPEND(SD,CPU,EXC) mips_cpu_exception_suspend(SD,CPU,EXC)
#define SIM_CPU_EXCEPTION_RESUME(SD,CPU,EXC) mips_cpu_exception_resume(SD,CPU,EXC)

  unsigned_word c0_config_reg;
#define C0_CONFIG ((CPU)->c0_config_reg)

/* The following are pseudonyms for standard registers */
#define ZERO    (REGISTERS[0])
#define V0      (REGISTERS[2])
#define A0      (REGISTERS[4])
#define A1      (REGISTERS[5])
#define A2      (REGISTERS[6])
#define A3      (REGISTERS[7])
#define T8IDX   24
#define T8	(REGISTERS[T8IDX])
#define SPIDX   29
#define SP      (REGISTERS[SPIDX])
#define RAIDX   31
#define RA      (REGISTERS[RAIDX])

  /* While space is allocated in the main registers arrray for some of
     the COP0 registers, that space isn't sufficient.  Unknown COP0
     registers overflow into the array below */

#define NR_COP0_GPR	32
  unsigned_word cop0_gpr[NR_COP0_GPR];
#define COP0_GPR	((CPU)->cop0_gpr)
#define COP0_BADVADDR	(COP0_GPR[8])

  /* While space is allocated for the floating point registers in the
     main registers array, they are stored separatly.  This is because
     their size may not necessarily match the size of either the
     general-purpose or system specific registers.  */
#define NR_FGR    (32)
#define FGR_BASE  FP0_REGNUM
  fp_word fgr[NR_FGR];
#define FGR       ((CPU)->fgr)

  /* Keep the current format state for each register: */
  FP_formats fpr_state[32];
#define FPR_STATE ((CPU)->fpr_state)

  pending_write_queue pending;

  /* The MDMX accumulator (used only for MDMX ASE).  */
  MDMX_accumulator acc; 
#define ACC             ((CPU)->acc)

  /* LLBIT = Load-Linked bit. A bit of "virtual" state used by atomic
     read-write instructions. It is set when a linked load occurs. It
     is tested and cleared by the conditional store. It is cleared
     (during other CPU operations) when a store to the location would
     no longer be atomic. In particular, it is cleared by exception
     return instructions. */
  int llbit;
#define LLBIT ((CPU)->llbit)


/* The HIHISTORY and LOHISTORY timestamps are used to ensure that
   corruptions caused by using the HI or LO register too close to a
   following operation is spotted. See mips.igen for more details. */

  hilo_history hi_history;
#define HIHISTORY (&(CPU)->hi_history)
  hilo_history lo_history;
#define LOHISTORY (&(CPU)->lo_history)


  sim_cpu_base base;
};


/* MIPS specific simulator watch config */

void watch_options_install PARAMS ((SIM_DESC sd));

struct swatch {
  sim_event *pc;
  sim_event *clock;
  sim_event *cycles;
};


/* FIXME: At present much of the simulator is still static */
struct sim_state {

  struct swatch watch;

  sim_cpu cpu[MAX_NR_PROCESSORS];
#if (WITH_SMP)
#define STATE_CPU(sd,n) (&(sd)->cpu[n])
#else
#define STATE_CPU(sd,n) (&(sd)->cpu[0])
#endif


  sim_state_base base;
};



/* Status information: */

/* TODO : these should be the bitmasks for these bits within the
   status register. At the moment the following are VR4300
   bit-positions: */
#define status_KSU_mask  (0x18)         /* mask for KSU bits */
#define status_KSU_shift (3)            /* shift for field */
#define ksu_kernel       (0x0)
#define ksu_supervisor   (0x1)
#define ksu_user         (0x2)
#define ksu_unknown      (0x3)

#define SR_KSU		 ((SR & status_KSU_mask) >> status_KSU_shift)

#define status_IE	 (1 <<  0)      /* Interrupt enable */
#define status_EIE	 (1 << 16)      /* Enable Interrupt Enable */
#define status_EXL	 (1 <<  1)	/* Exception level */
#define status_RE        (1 << 25)      /* Reverse Endian in user mode */
#define status_FR        (1 << 26)      /* enables MIPS III additional FP registers */
#define status_SR        (1 << 20)      /* soft reset or NMI */
#define status_BEV       (1 << 22)      /* Location of general exception vectors */
#define status_TS        (1 << 21)      /* TLB shutdown has occurred */
#define status_ERL       (1 <<  2)      /* Error level */
#define status_IM7       (1 << 15)      /* Timer Interrupt Mask */
#define status_RP        (1 << 27)      /* Reduced Power mode */

/* Specializations for TX39 family */
#define status_IEc       (1 << 0)       /* Interrupt enable (current) */
#define status_KUc       (1 << 1)       /* Kernel/User mode */
#define status_IEp       (1 << 2)       /* Interrupt enable (previous) */
#define status_KUp       (1 << 3)       /* Kernel/User mode */
#define status_IEo       (1 << 4)       /* Interrupt enable (old) */
#define status_KUo       (1 << 5)       /* Kernel/User mode */
#define status_IM_mask   (0xff)         /* Interrupt mask */
#define status_IM_shift  (8)
#define status_NMI       (1 << 20)      /* NMI */
#define status_NMI       (1 << 20)      /* NMI */

/* Status bits used by MIPS32/MIPS64.  */
#define status_UX        (1 <<  5)      /* 64-bit user addrs */
#define status_SX        (1 <<  6)      /* 64-bit supervisor addrs */
#define status_KX        (1 <<  7)      /* 64-bit kernel addrs */
#define status_TS        (1 << 21)      /* TLB shutdown has occurred */
#define status_PX        (1 << 23)      /* Enable 64 bit operations */
#define status_MX        (1 << 24)      /* Enable MDMX resources */
#define status_CU0       (1 << 28)      /* Coprocessor 0 usable */
#define status_CU1       (1 << 29)      /* Coprocessor 1 usable */
#define status_CU2       (1 << 30)      /* Coprocessor 2 usable */
#define status_CU3       (1 << 31)      /* Coprocessor 3 usable */
/* Bits reserved for implementations:  */
#define status_SBX       (1 << 16)      /* Enable SiByte SB-1 extensions.  */

#define cause_BD ((unsigned)1 << 31)    /* L1 Exception in branch delay slot */
#define cause_BD2         (1 << 30)     /* L2 Exception in branch delay slot */
#define cause_CE_mask     0x30000000	/* Coprocessor exception */
#define cause_CE_shift    28
#define cause_EXC2_mask   0x00070000
#define cause_EXC2_shift  16
#define cause_IP7 	  (1 << 15)	/* Interrupt pending */
#define cause_SIOP        (1 << 12)     /* SIO pending */
#define cause_IP3 	  (1 << 11)	/* Int 0 pending */
#define cause_IP2 	  (1 << 10)	/* Int 1 pending */

#define cause_EXC_mask  (0x1c)          /* Exception code */
#define cause_EXC_shift (2)

#define cause_SW0       (1 << 8)        /* Software interrupt 0 */
#define cause_SW1       (1 << 9)        /* Software interrupt 1 */
#define cause_IP_mask   (0x3f)          /* Interrupt pending field */
#define cause_IP_shift  (10)

#define cause_set_EXC(x)  CAUSE = (CAUSE & ~cause_EXC_mask)  | ((x << cause_EXC_shift)  & cause_EXC_mask)
#define cause_set_EXC2(x) CAUSE = (CAUSE & ~cause_EXC2_mask) | ((x << cause_EXC2_shift) & cause_EXC2_mask)


/* NOTE: We keep the following status flags as bit values (1 for true,
   0 for false). This allows them to be used in binary boolean
   operations without worrying about what exactly the non-zero true
   value is. */

/* UserMode */
#ifdef SUBTARGET_R3900
#define UserMode        ((SR & status_KUc) ? 1 : 0)
#else
#define UserMode	((((SR & status_KSU_mask) >> status_KSU_shift) == ksu_user) ? 1 : 0)
#endif /* SUBTARGET_R3900 */

/* BigEndianMem */
/* Hardware configuration. Affects endianness of LoadMemory and
   StoreMemory and the endianness of Kernel and Supervisor mode
   execution. The value is 0 for little-endian; 1 for big-endian. */
#define BigEndianMem    (CURRENT_TARGET_BYTE_ORDER == BIG_ENDIAN)
/*(state & simBE) ? 1 : 0)*/

/* ReverseEndian */
/* This mode is selected if in User mode with the RE bit being set in
   SR (Status Register). It reverses the endianness of load and store
   instructions. */
#define ReverseEndian   (((SR & status_RE) && UserMode) ? 1 : 0)

/* BigEndianCPU */
/* The endianness for load and store instructions (0=little;1=big). In
   User mode this endianness may be switched by setting the state_RE
   bit in the SR register. Thus, BigEndianCPU may be computed as
   (BigEndianMem EOR ReverseEndian). */
#define BigEndianCPU    (BigEndianMem ^ ReverseEndian) /* Already bits */



/* Exceptions: */

/* NOTE: These numbers depend on the processor architecture being
   simulated: */
enum ExceptionCause {
  Interrupt               = 0,
  TLBModification         = 1,
  TLBLoad                 = 2,
  TLBStore                = 3,
  AddressLoad             = 4,
  AddressStore            = 5,
  InstructionFetch        = 6,
  DataReference           = 7,
  SystemCall              = 8,
  BreakPoint              = 9,
  ReservedInstruction     = 10,
  CoProcessorUnusable     = 11,
  IntegerOverflow         = 12,    /* Arithmetic overflow (IDT monitor raises SIGFPE) */
  Trap                    = 13,
  FPE                     = 15,
  DebugBreakPoint         = 16,    /* Impl. dep. in MIPS32/MIPS64.  */
  MDMX                    = 22,
  Watch                   = 23,
  MCheck                  = 24,
  CacheErr                = 30,
  NMIReset                = 31,    /* Reserved in MIPS32/MIPS64.  */


/* The following exception code is actually private to the simulator
   world. It is *NOT* a processor feature, and is used to signal
   run-time errors in the simulator. */
  SimulatorFault      	  = 0xFFFFFFFF
};

#define TLB_REFILL  (0)
#define TLB_INVALID (1)


/* The following break instructions are reserved for use by the
   simulator.  The first is used to halt the simulation.  The second
   is used by gdb for break-points.  NOTE: Care must be taken, since 
   this value may be used in later revisions of the MIPS ISA. */
#define HALT_INSTRUCTION_MASK   (0x03FFFFC0)

#define HALT_INSTRUCTION        (0x03ff000d)
#define HALT_INSTRUCTION2       (0x0000ffcd)


#define BREAKPOINT_INSTRUCTION  (0x0005000d)
#define BREAKPOINT_INSTRUCTION2 (0x0000014d)



void interrupt_event (SIM_DESC sd, void *data);

void signal_exception (SIM_DESC sd, sim_cpu *cpu, address_word cia, int exception, ...);
#define SignalException(exc,instruction)     signal_exception (SD, CPU, cia, (exc), (instruction))
#define SignalExceptionInterrupt(level)      signal_exception (SD, CPU, cia, Interrupt, level)
#define SignalExceptionInstructionFetch()    signal_exception (SD, CPU, cia, InstructionFetch)
#define SignalExceptionAddressStore()        signal_exception (SD, CPU, cia, AddressStore)
#define SignalExceptionAddressLoad()         signal_exception (SD, CPU, cia, AddressLoad)
#define SignalExceptionDataReference()       signal_exception (SD, CPU, cia, DataReference)
#define SignalExceptionSimulatorFault(buf)   signal_exception (SD, CPU, cia, SimulatorFault, buf)
#define SignalExceptionFPE()                 signal_exception (SD, CPU, cia, FPE)
#define SignalExceptionIntegerOverflow()     signal_exception (SD, CPU, cia, IntegerOverflow)
#define SignalExceptionCoProcessorUnusable(cop) signal_exception (SD, CPU, cia, CoProcessorUnusable)
#define SignalExceptionNMIReset()            signal_exception (SD, CPU, cia, NMIReset)
#define SignalExceptionTLBRefillStore()      signal_exception (SD, CPU, cia, TLBStore, TLB_REFILL)
#define SignalExceptionTLBRefillLoad()       signal_exception (SD, CPU, cia, TLBLoad, TLB_REFILL)
#define SignalExceptionTLBInvalidStore()     signal_exception (SD, CPU, cia, TLBStore, TLB_INVALID)
#define SignalExceptionTLBInvalidLoad()      signal_exception (SD, CPU, cia, TLBLoad, TLB_INVALID)
#define SignalExceptionTLBModification()     signal_exception (SD, CPU, cia, TLBModification)
#define SignalExceptionMDMX()                signal_exception (SD, CPU, cia, MDMX)
#define SignalExceptionWatch()               signal_exception (SD, CPU, cia, Watch)
#define SignalExceptionMCheck()              signal_exception (SD, CPU, cia, MCheck)
#define SignalExceptionCacheErr()            signal_exception (SD, CPU, cia, CacheErr)

/* Co-processor accesses */

/* XXX FIXME: For now, assume that FPU (cp1) is always usable.  */
#define COP_Usable(coproc_num)		(coproc_num == 1)

void cop_lw  PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, int coproc_num, int coproc_reg, unsigned int memword));
void cop_ld  PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, int coproc_num, int coproc_reg, uword64 memword));
unsigned int cop_sw PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, int coproc_num, int coproc_reg));
uword64 cop_sd PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, int coproc_num, int coproc_reg));

#define COP_LW(coproc_num,coproc_reg,memword) \
cop_lw (SD, CPU, cia, coproc_num, coproc_reg, memword)
#define COP_LD(coproc_num,coproc_reg,memword) \
cop_ld (SD, CPU, cia, coproc_num, coproc_reg, memword)
#define COP_SW(coproc_num,coproc_reg) \
cop_sw (SD, CPU, cia, coproc_num, coproc_reg)
#define COP_SD(coproc_num,coproc_reg) \
cop_sd (SD, CPU, cia, coproc_num, coproc_reg)


void decode_coproc PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, unsigned int instruction));
#define DecodeCoproc(instruction) \
decode_coproc (SD, CPU, cia, (instruction))

int sim_monitor (SIM_DESC sd, sim_cpu *cpu, address_word cia, unsigned int arg);
  

/* FPR access.  */
unsigned64 value_fpr (SIM_STATE, int fpr, FP_formats);
#define ValueFPR(FPR,FMT) value_fpr (SIM_ARGS, (FPR), (FMT))
void store_fpr (SIM_STATE, int fpr, FP_formats fmt, unsigned64 value);
#define StoreFPR(FPR,FMT,VALUE) store_fpr (SIM_ARGS, (FPR), (FMT), (VALUE))
unsigned64 ps_lower (SIM_STATE, unsigned64 op);
#define PSLower(op) ps_lower (SIM_ARGS, op)
unsigned64 ps_upper (SIM_STATE, unsigned64 op);
#define PSUpper(op) ps_upper (SIM_ARGS, op)
unsigned64 pack_ps (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats from);
#define PackPS(op1,op2) pack_ps (SIM_ARGS, op1, op2, fmt_single)


/* FCR access.  */
unsigned_word value_fcr (SIM_STATE, int fcr);
#define ValueFCR(FCR) value_fcr (SIM_ARGS, (FCR))
void store_fcr (SIM_STATE, int fcr, unsigned_word value);
#define StoreFCR(FCR,VALUE) store_fcr (SIM_ARGS, (FCR), (VALUE))
void test_fcsr (SIM_STATE);
#define TestFCSR() test_fcsr (SIM_ARGS)


/* FPU operations.  */
void fp_cmp (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt, int abs, int cond, int cc);
#define Compare(op1,op2,fmt,cond,cc) fp_cmp(SIM_ARGS, op1, op2, fmt, 0, cond, cc)
unsigned64 fp_abs (SIM_STATE, unsigned64 op, FP_formats fmt);
#define AbsoluteValue(op,fmt) fp_abs(SIM_ARGS, op, fmt)
unsigned64 fp_neg (SIM_STATE, unsigned64 op, FP_formats fmt);
#define Negate(op,fmt) fp_neg(SIM_ARGS, op, fmt)
unsigned64 fp_add (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
#define Add(op1,op2,fmt) fp_add(SIM_ARGS, op1, op2, fmt)
unsigned64 fp_sub (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
#define Sub(op1,op2,fmt) fp_sub(SIM_ARGS, op1, op2, fmt)
unsigned64 fp_mul (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
#define Multiply(op1,op2,fmt) fp_mul(SIM_ARGS, op1, op2, fmt)
unsigned64 fp_div (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
#define Divide(op1,op2,fmt) fp_div(SIM_ARGS, op1, op2, fmt)
unsigned64 fp_recip (SIM_STATE, unsigned64 op, FP_formats fmt);
#define Recip(op,fmt) fp_recip(SIM_ARGS, op, fmt)
unsigned64 fp_sqrt (SIM_STATE, unsigned64 op, FP_formats fmt);
#define SquareRoot(op,fmt) fp_sqrt(SIM_ARGS, op, fmt)
unsigned64 fp_rsqrt (SIM_STATE, unsigned64 op, FP_formats fmt);
#define RSquareRoot(op,fmt) fp_rsqrt(SIM_ARGS, op, fmt)
unsigned64 fp_madd (SIM_STATE, unsigned64 op1, unsigned64 op2,
		    unsigned64 op3, FP_formats fmt);
#define MultiplyAdd(op1,op2,op3,fmt) fp_madd(SIM_ARGS, op1, op2, op3, fmt)
unsigned64 fp_msub (SIM_STATE, unsigned64 op1, unsigned64 op2,
		    unsigned64 op3, FP_formats fmt);
#define MultiplySub(op1,op2,op3,fmt) fp_msub(SIM_ARGS, op1, op2, op3, fmt)
unsigned64 fp_nmadd (SIM_STATE, unsigned64 op1, unsigned64 op2,
		     unsigned64 op3, FP_formats fmt);
#define NegMultiplyAdd(op1,op2,op3,fmt) fp_nmadd(SIM_ARGS, op1, op2, op3, fmt)
unsigned64 fp_nmsub (SIM_STATE, unsigned64 op1, unsigned64 op2,
		     unsigned64 op3, FP_formats fmt);
#define NegMultiplySub(op1,op2,op3,fmt) fp_nmsub(SIM_ARGS, op1, op2, op3, fmt)
unsigned64 convert (SIM_STATE, int rm, unsigned64 op, FP_formats from, FP_formats to);
#define Convert(rm,op,from,to) convert (SIM_ARGS, rm, op, from, to)
unsigned64 convert_ps (SIM_STATE, int rm, unsigned64 op, FP_formats from,
		       FP_formats to);
#define ConvertPS(rm,op,from,to) convert_ps (SIM_ARGS, rm, op, from, to)


/* MIPS-3D ASE operations.  */
#define CompareAbs(op1,op2,fmt,cond,cc) \
fp_cmp(SIM_ARGS, op1, op2, fmt, 1, cond, cc)
unsigned64 fp_add_r (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
#define AddR(op1,op2,fmt) fp_add_r(SIM_ARGS, op1, op2, fmt)
unsigned64 fp_mul_r (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
#define MultiplyR(op1,op2,fmt) fp_mul_r(SIM_ARGS, op1, op2, fmt)
unsigned64 fp_recip1 (SIM_STATE, unsigned64 op, FP_formats fmt);
#define Recip1(op,fmt) fp_recip1(SIM_ARGS, op, fmt)
unsigned64 fp_recip2 (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
#define Recip2(op1,op2,fmt) fp_recip2(SIM_ARGS, op1, op2, fmt)
unsigned64 fp_rsqrt1 (SIM_STATE, unsigned64 op, FP_formats fmt);
#define RSquareRoot1(op,fmt) fp_rsqrt1(SIM_ARGS, op, fmt)
unsigned64 fp_rsqrt2 (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
#define RSquareRoot2(op1,op2,fmt) fp_rsqrt2(SIM_ARGS, op1, op2, fmt)


/* MDMX access.  */

typedef unsigned int MX_fmtsel;   /* MDMX format select field (5 bits).  */
#define ob_fmtsel(sel) (((sel)<<1)|0x0)
#define qh_fmtsel(sel) (((sel)<<2)|0x1)

#define fmt_mdmx fmt_uninterpreted

#define MX_VECT_AND  (0)
#define MX_VECT_NOR  (1)
#define MX_VECT_OR   (2)
#define MX_VECT_XOR  (3)
#define MX_VECT_SLL  (4)
#define MX_VECT_SRL  (5)
#define MX_VECT_ADD  (6)
#define MX_VECT_SUB  (7)
#define MX_VECT_MIN  (8)
#define MX_VECT_MAX  (9)
#define MX_VECT_MUL  (10)
#define MX_VECT_MSGN (11)
#define MX_VECT_SRA  (12)
#define MX_VECT_ABSD (13)		/* SB-1 only.  */
#define MX_VECT_AVG  (14)		/* SB-1 only.  */

unsigned64 mdmx_cpr_op (SIM_STATE, int op, unsigned64 op1, int vt, MX_fmtsel fmtsel);
#define MX_Add(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_ADD, op1, vt, fmtsel)
#define MX_And(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_AND, op1, vt, fmtsel)
#define MX_Max(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_MAX, op1, vt, fmtsel)
#define MX_Min(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_MIN, op1, vt, fmtsel)
#define MX_Msgn(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_MSGN, op1, vt, fmtsel)
#define MX_Mul(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_MUL, op1, vt, fmtsel)
#define MX_Nor(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_NOR, op1, vt, fmtsel)
#define MX_Or(op1,vt,fmtsel)  mdmx_cpr_op(SIM_ARGS, MX_VECT_OR,  op1, vt, fmtsel)
#define MX_ShiftLeftLogical(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_SLL, op1, vt, fmtsel)
#define MX_ShiftRightArith(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_SRA, op1, vt, fmtsel)
#define MX_ShiftRightLogical(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_SRL, op1, vt, fmtsel)
#define MX_Sub(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_SUB, op1, vt, fmtsel)
#define MX_Xor(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_XOR, op1, vt, fmtsel)
#define MX_AbsDiff(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_ABSD, op1, vt, fmtsel)
#define MX_Avg(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_AVG, op1, vt, fmtsel)

#define MX_C_EQ  0x1
#define MX_C_LT  0x4

void mdmx_cc_op (SIM_STATE, int cond, unsigned64 op1, int vt, MX_fmtsel fmtsel);
#define MX_Comp(op1,cond,vt,fmtsel) mdmx_cc_op(SIM_ARGS, cond, op1, vt, fmtsel)

unsigned64 mdmx_pick_op (SIM_STATE, int tf, unsigned64 op1, int vt, MX_fmtsel fmtsel);
#define MX_Pick(tf,op1,vt,fmtsel) mdmx_pick_op(SIM_ARGS, tf, op1, vt, fmtsel)

#define MX_VECT_ADDA  (0)
#define MX_VECT_ADDL  (1)
#define MX_VECT_MULA  (2)
#define MX_VECT_MULL  (3)
#define MX_VECT_MULS  (4)
#define MX_VECT_MULSL (5)
#define MX_VECT_SUBA  (6)
#define MX_VECT_SUBL  (7)
#define MX_VECT_ABSDA (8)		/* SB-1 only.  */

void mdmx_acc_op (SIM_STATE, int op, unsigned64 op1, int vt, MX_fmtsel fmtsel);
#define MX_AddA(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_ADDA, op1, vt, fmtsel)
#define MX_AddL(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_ADDL, op1, vt, fmtsel)
#define MX_MulA(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_MULA, op1, vt, fmtsel)
#define MX_MulL(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_MULL, op1, vt, fmtsel)
#define MX_MulS(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_MULS, op1, vt, fmtsel)
#define MX_MulSL(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_MULSL, op1, vt, fmtsel)
#define MX_SubA(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_SUBA, op1, vt, fmtsel)
#define MX_SubL(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_SUBL, op1, vt, fmtsel)
#define MX_AbsDiffC(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_ABSDA, op1, vt, fmtsel)

#define MX_FMT_OB   (0)
#define MX_FMT_QH   (1)

/* The following codes chosen to indicate the units of shift.  */
#define MX_RAC_L    (0)
#define MX_RAC_M    (1)
#define MX_RAC_H    (2)

unsigned64 mdmx_rac_op (SIM_STATE, int, int);
#define MX_RAC(op,fmt) mdmx_rac_op(SIM_ARGS, op, fmt)

void mdmx_wacl (SIM_STATE, int, unsigned64, unsigned64);
#define MX_WACL(fmt,vs,vt) mdmx_wacl(SIM_ARGS, fmt, vs, vt)
void mdmx_wach (SIM_STATE, int, unsigned64);
#define MX_WACH(fmt,vs) mdmx_wach(SIM_ARGS, fmt, vs)

#define MX_RND_AS   (0)
#define MX_RND_AU   (1)
#define MX_RND_ES   (2)
#define MX_RND_EU   (3)
#define MX_RND_ZS   (4)
#define MX_RND_ZU   (5)

unsigned64 mdmx_round_op (SIM_STATE, int, int, MX_fmtsel);
#define MX_RNAS(vt,fmt) mdmx_round_op(SIM_ARGS, MX_RND_AS, vt, fmt)
#define MX_RNAU(vt,fmt) mdmx_round_op(SIM_ARGS, MX_RND_AU, vt, fmt)
#define MX_RNES(vt,fmt) mdmx_round_op(SIM_ARGS, MX_RND_ES, vt, fmt)
#define MX_RNEU(vt,fmt) mdmx_round_op(SIM_ARGS, MX_RND_EU, vt, fmt)
#define MX_RZS(vt,fmt)  mdmx_round_op(SIM_ARGS, MX_RND_ZS, vt, fmt)
#define MX_RZU(vt,fmt)  mdmx_round_op(SIM_ARGS, MX_RND_ZU, vt, fmt)

unsigned64 mdmx_shuffle (SIM_STATE, int, unsigned64, unsigned64);
#define MX_SHFL(shop,op1,op2) mdmx_shuffle(SIM_ARGS, shop, op1, op2)



/* Memory accesses */

/* The following are generic to all versions of the MIPS architecture
   to date: */

/* Memory Access Types (for CCA): */
#define Uncached                (0)
#define CachedNoncoherent       (1)
#define CachedCoherent          (2)
#define Cached                  (3)

#define isINSTRUCTION   (1 == 0) /* FALSE */
#define isDATA          (1 == 1) /* TRUE */
#define isLOAD          (1 == 0) /* FALSE */
#define isSTORE         (1 == 1) /* TRUE */
#define isREAL          (1 == 0) /* FALSE */
#define isRAW           (1 == 1) /* TRUE */
/* The parameter HOST (isTARGET / isHOST) is ignored */
#define isTARGET        (1 == 0) /* FALSE */
/* #define isHOST          (1 == 1) TRUE */

/* The "AccessLength" specifications for Loads and Stores. NOTE: This
   is the number of bytes minus 1. */
#define AccessLength_BYTE       (0)
#define AccessLength_HALFWORD   (1)
#define AccessLength_TRIPLEBYTE (2)
#define AccessLength_WORD       (3)
#define AccessLength_QUINTIBYTE (4)
#define AccessLength_SEXTIBYTE  (5)
#define AccessLength_SEPTIBYTE  (6)
#define AccessLength_DOUBLEWORD (7)
#define AccessLength_QUADWORD   (15)

#define LOADDRMASK (WITH_TARGET_WORD_BITSIZE == 64 \
		    ? AccessLength_DOUBLEWORD /*7*/ \
		    : AccessLength_WORD /*3*/)
#define PSIZE (WITH_TARGET_ADDRESS_BITSIZE)


INLINE_SIM_MAIN (int) address_translation PARAMS ((SIM_DESC sd, sim_cpu *, address_word cia, address_word vAddr, int IorD, int LorS, address_word *pAddr, int *CCA, int raw));
#define AddressTranslation(vAddr,IorD,LorS,pAddr,CCA,host,raw) \
address_translation (SD, CPU, cia, vAddr, IorD, LorS, pAddr, CCA, raw)

INLINE_SIM_MAIN (void) load_memory PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, uword64* memvalp, uword64* memval1p, int CCA, unsigned int AccessLength, address_word pAddr, address_word vAddr, int IorD));
#define LoadMemory(memvalp,memval1p,CCA,AccessLength,pAddr,vAddr,IorD,raw) \
load_memory (SD, CPU, cia, memvalp, memval1p, CCA, AccessLength, pAddr, vAddr, IorD)

INLINE_SIM_MAIN (void) store_memory PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, int CCA, unsigned int AccessLength, uword64 MemElem, uword64 MemElem1, address_word pAddr, address_word vAddr));
#define StoreMemory(CCA,AccessLength,MemElem,MemElem1,pAddr,vAddr,raw) \
store_memory (SD, CPU, cia, CCA, AccessLength, MemElem, MemElem1, pAddr, vAddr)

INLINE_SIM_MAIN (void) cache_op PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, int op, address_word pAddr, address_word vAddr, unsigned int instruction));
#define CacheOp(op,pAddr,vAddr,instruction) \
cache_op (SD, CPU, cia, op, pAddr, vAddr, instruction)

INLINE_SIM_MAIN (void) sync_operation PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, int stype));
#define SyncOperation(stype) \
sync_operation (SD, CPU, cia, (stype))

INLINE_SIM_MAIN (void) prefetch PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, int CCA, address_word pAddr, address_word vAddr, int DATA, int hint));
#define Prefetch(CCA,pAddr,vAddr,DATA,hint) \
prefetch (SD, CPU, cia, CCA, pAddr, vAddr, DATA, hint)

void unpredictable_action (sim_cpu *cpu, address_word cia);
#define NotWordValue(val)	not_word_value (SD_, (val))
#define Unpredictable()		unpredictable (SD_)
#define UnpredictableResult()	/* For now, do nothing.  */

INLINE_SIM_MAIN (unsigned32) ifetch32 PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, address_word vaddr));
#define IMEM32(CIA) ifetch32 (SD, CPU, (CIA), (CIA))
INLINE_SIM_MAIN (unsigned16) ifetch16 PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, address_word vaddr));
#define IMEM16(CIA) ifetch16 (SD, CPU, (CIA), ((CIA) & ~1))
#define IMEM16_IMMED(CIA,NR) ifetch16 (SD, CPU, (CIA), ((CIA) & ~1) + 2 * (NR))

void dotrace PARAMS ((SIM_DESC sd, sim_cpu *cpu, FILE *tracefh, int type, SIM_ADDR address, int width, char *comment, ...));
extern FILE *tracefh;

extern int DSPLO_REGNUM[4];
extern int DSPHI_REGNUM[4];

INLINE_SIM_MAIN (void) pending_tick PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia));
extern SIM_CORE_SIGNAL_FN mips_core_signal;

char* pr_addr PARAMS ((SIM_ADDR addr));
char* pr_uword64 PARAMS ((uword64 addr));


#define GPR_CLEAR(N) do { GPR_SET((N),0); } while (0)

void mips_cpu_exception_trigger(SIM_DESC sd, sim_cpu* cpu, address_word pc);
void mips_cpu_exception_suspend(SIM_DESC sd, sim_cpu* cpu, int exception);
void mips_cpu_exception_resume(SIM_DESC sd, sim_cpu* cpu, int exception);

#ifdef MIPS_MACH_MULTI
extern int mips_mach_multi(SIM_DESC sd);
#define MIPS_MACH(SD)	mips_mach_multi(SD)
#else
#define	MIPS_MACH(SD)	MIPS_MACH_DEFAULT
#endif

/* Macros for determining whether a MIPS IV or MIPS V part is subject
   to the hi/lo restrictions described in mips.igen.  */

#define MIPS_MACH_HAS_MT_HILO_HAZARD(SD) \
  (MIPS_MACH (SD) != bfd_mach_mips5500)

#define MIPS_MACH_HAS_MULT_HILO_HAZARD(SD) \
  (MIPS_MACH (SD) != bfd_mach_mips5500)

#define MIPS_MACH_HAS_DIV_HILO_HAZARD(SD) \
  (MIPS_MACH (SD) != bfd_mach_mips5500)

#if H_REVEALS_MODULE_P (SIM_MAIN_INLINE)
#include "sim-main.c"
#endif

#endif
@


1.36
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 2
   Copyright (C) 1997-1998, 2003, 2007-2012 Free Software Foundation,
   Inc.
@


1.35
log
@run copyright.sh for 2011.
@
text
@d2 2
a3 2
   Copyright (C) 1997, 1998, 2003, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.35.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 2
   Copyright (C) 1997-1998, 2003, 2007-2012 Free Software Foundation,
   Inc.
@


1.34
log
@Update copyright notices to add year 2010.
@
text
@d2 1
a2 1
   Copyright (C) 1997, 1998, 2003, 2007, 2008, 2009, 2010
@


1.33
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d2 1
a2 1
   Copyright (C) 1997, 1998, 2003, 2007, 2008, 2009
@


1.32
log
@	Updated copyright notices for most files.
@
text
@d2 2
a3 1
   Copyright (C) 1997, 1998, 2003, 2007, 2008 Free Software Foundation, Inc.
@


1.31
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d2 1
a2 1
   Copyright (C) 1997, 1998, 2003, 2007 Free Software Foundation, Inc.
@


1.30
log
@Copyright updates for 2007.
@
text
@d9 2
a10 2
the Free Software Foundation; either version 2, or (at your option)
any later version.
d17 2
a18 3
You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.29
log
@	* configure.ac (mipsisa32r2*-*-*, mipsisa32*-*-*): Add smartmips to
	sim_igen_machine.
	* configure: Regenerate.
	* mips.igen (model): Add smartmips.
	(MADDU): Increment ACX if carry.
	(do_mult): Clear ACX.
	(ROR,RORV): Add smartmips.
	(include): Include smartmips.igen.
	* sim-main.h (ACX): Set to REGISTERS[89].
	* smartmips.igen: New file.
@
text
@d2 1
a2 1
   Copyright (C) 1997, 1998, 2003 Free Software Foundation, Inc.
@


1.28
log
@* Makefile.in (SIM_OBJS): Add dsp.o.
(dsp.o): New dependency.
(IGEN_INCLUDE): Add dsp.igen.
* configure.ac (mipsisa32r2*-*-*, mipsisa32*-*-*, mipsisa64r2*-*-*,
mipsisa64*-*-*): Add dsp to sim_igen_machine.
* configure: Regenerate.
* mips.igen: Add dsp model and include dsp.igen.
(MFHI, MFLO, MTHI, MTLO): Remove mips32, mips32r2, mips64, mips64r2,
because these instructions are extended in DSP ASE.
* sim-main.h (LAST_EMBED_REGNUM): Change from 89 to 96 because of
adding 6 DSP accumulator registers and 1 DSP control register.
(AC0LOIDX, AC0HIIDX, AC1LOIDX, AC1HIIDX, AC2LOIDX, AC2HIIDX, AC3LOIDX,
AC3HIIDX, DSPLO, DSPHI, DSPCRIDX, DSPCR, DSPCR_POS_SHIFT,
DSPCR_POS_MASK, DSPCR_POS_SMASK, DSPCR_SCOUNT_SHIFT, DSPCR_SCOUNT_MASK,
DSPCR_SCOUNT_SMASK, DSPCR_CARRY_SHIFT, DSPCR_CARRY_MASK,
DSPCR_CARRY_SMASK, DSPCR_CARRY, DSPCR_EFI_SHIFT, DSPCR_EFI_MASK,
DSPCR_EFI_SMASK, DSPCR_EFI, DSPCR_OUFLAG_SHIFT, DSPCR_OUFLAG_MASK,
DSPCR_OUFLAG_SMASK, DSPCR_OUFLAG4, DSPCR_OUFLAG5, DSPCR_OUFLAG6,
DSPCR_OUFLAG7, DSPCR_CCOND_SHIFT, DSPCR_CCOND_MASK,
DSPCR_CCOND_SMASK): New define.
(DSPLO_REGNUM, DSPHI_REGNUM): New array for DSP accumulators.
* dsp.c, dsp.igen: New files for MIPS DSP ASE.
@
text
@d351 1
@


1.27
log
@2004-05-11  Maciej W. Rozycki  <macro@@ds2.pg.gda.pl>

        * mips/interp.c (decode_coproc): Sign-extend the address retrieved
        from COP0_BADVADDR.
        * mips/sim-main.h (COP0_BADVADDR): Remove a cast.
@
text
@d315 1
a315 1
#define LAST_EMBED_REGNUM (89)
d352 45
d981 3
@


1.26
log
@	* sim-main.h (MIPS_MACH_HAS_MT_HILO_HAZARD)
	(MIPS_MACH_HAS_MULT_HILO_HAZARD, MIPS_MACH_HAS_DIV_HILO_HAZARD): New.
	* mips.igen (check_mt_hilo, check_mult_hilo, check_div_hilo): Provide
	separate implementations for mipsIV and mipsV.  Use new macros to
	determine whether the restrictions apply.
@
text
@d386 1
a386 1
#define COP0_BADVADDR ((unsigned32)(COP0_GPR[8]))
@


1.25
log
@2003-01-04  Richard Sandiford  <rsandifo@@redhat.com>
	    Andrew Cagney  <ac131313@@redhat.com>
	    Gavin Romig-Koch  <gavin@@redhat.com>
	    Graydon Hoare  <graydon@@redhat.com>
	    Aldy Hernandez  <aldyh@@redhat.com>
	    Dave Brolley  <brolley@@redhat.com>
	    Chris Demetriou  <cgd@@broadcom.com>

	* configure.in (mips64vr*): Define TARGET_ENABLE_FR to 1.
	(sim_mach_default): New variable.
	(mips64vr-*-*, mips64vrel-*-*): New configurations.
	Add a new simulator generator, MULTI.
	* configure: Regenerate.
	* Makefile.in (SIM_MULTI_OBJ, SIM_EXTRA_DISTCLEAN): New variables.
	(multi-run.o): New dependency.
	(SIM_MULTI_ALL, SIM_MULTI_IGEN_CONFIGS): New variables.
	(tmp-mach-multi, tmp-itable-multi, tmp-run-multi): New rules.
	(tmp-multi): Combine them.
	(BUILT_SRC_FROM_MULTI): New variable.  Depend on tmp-multi.
	(clean-extra): Remove sources in BUILT_SRC_FROM_MULTI.
	(distclean-extra): New rule.
	* sim-main.h: Include bfd.h.
	(MIPS_MACH): New macro.
	* mips.igen (vr4120, vr5400, vr5500): New models.
	(clo, clz, dclo, dclz, madd, maddu, msub, msub, mul): Add *vr5500.
	* vr.igen: Replace with new version.
@
text
@d956 12
@


1.25.48.1
log
@2004-05-11  Maciej W. Rozycki  <macro@@ds2.pg.gda.pl>

        * mips/interp.c (decode_coproc): Sign-extend the address retrieved
        from COP0_BADVADDR.
        * mips/sim-main.h (COP0_BADVADDR): Remove a cast.
@
text
@d386 1
a386 1
#define COP0_BADVADDR	(COP0_GPR[8])
@


1.25.46.1
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@a955 12
/* Macros for determining whether a MIPS IV or MIPS V part is subject
   to the hi/lo restrictions described in mips.igen.  */

#define MIPS_MACH_HAS_MT_HILO_HAZARD(SD) \
  (MIPS_MACH (SD) != bfd_mach_mips5500)

#define MIPS_MACH_HAS_MULT_HILO_HAZARD(SD) \
  (MIPS_MACH (SD) != bfd_mach_mips5500)

#define MIPS_MACH_HAS_DIV_HILO_HAZARD(SD) \
  (MIPS_MACH (SD) != bfd_mach_mips5500)

@


1.25.46.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d386 1
a386 1
#define COP0_BADVADDR	(COP0_GPR[8])
@


1.24
log
@2002-12-31  Chris Demetriou  <cgd@@broadcom.com>

        * sim-main.h (check_branch_bug, mark_branch_bug): Remove.
        * mips.igen: Remove all invocations of check_branch_bug and
        mark_branch_bug.
@
text
@d2 1
a2 1
   Copyright (C) 1997, 1998 Free Software Foundation, Inc.
d44 1
a44 1

d949 6
@


1.23
log
@2002-06-14  Chris Demetriou  <cgd@@broadcom.com>
            Ed Satterthwaite  <ehs@@broadcom.com>

	* mips3d.igen: New file which contains MIPS-3D ASE instructions.
	* Makefile.in (IGEN_INCLUDE): Add mips3d.igen.
	* mips.igen: Include mips3d.igen.
	(mips3d): New model name for MIPS-3D ASE instructions.
	(CVT.W.fmt): Don't use this instruction for word (source) format
	instructions.
	* cp1.c (fp_binary_r, fp_add_r, fp_mul_r, fpu_inv1, fpu_inv1_32)
	(fpu_inv1_64, fp_recip1, fp_recip2, fpu_inv_sqrt1, fpu_inv_sqrt1_32)
	(fpu_inv_sqrt1_64, fp_rsqrt1, fp_rsqrt2): New functions.
	(NR_FRAC_GUARD, IMPLICIT_1): New macros.
	* sim-main.h (fmt_pw, CompareAbs, AddR, MultiplyR, Recip1, Recip2)
	(RSquareRoot1, RSquareRoot2): New macros.
	(fp_add_r, fp_mul_r, fp_recip1, fp_recip2, fp_rsqrt1)
	(fp_rsqrt2): New functions.
	* configure.in: Add MIPS-3D support to mipsisa64 simulator.
	* configure: Regenerate.
@
text
@a425 4
#define check_branch_bug() 
#define mark_branch_bug(TARGET) 


@


1.23.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright (C) 1997, 1998, 2003 Free Software Foundation, Inc.
d44 1
a44 1
#include "bfd.h"
d426 4
a952 6
#ifdef MIPS_MACH_MULTI
extern int mips_mach_multi(SIM_DESC sd);
#define MIPS_MACH(SD)	mips_mach_multi(SD)
#else
#define	MIPS_MACH(SD)	MIPS_MACH_DEFAULT
#endif
@


1.23.8.1
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 1
a2 1
   Copyright (C) 1997, 1998, 2003 Free Software Foundation, Inc.
d44 1
a44 1
#include "bfd.h"
d426 4
a952 6
#ifdef MIPS_MACH_MULTI
extern int mips_mach_multi(SIM_DESC sd);
#define MIPS_MACH(SD)	mips_mach_multi(SD)
#else
#define	MIPS_MACH(SD)	MIPS_MACH_DEFAULT
#endif
@


1.22
log
@2002-06-13  Chris Demetriou  <cgd@@broadcom.com>

	* cp1.c (FP_PS_upper, FP_PS_lower, FP_PS_cat, FPQNaN_PS): New macros.
	(value_fpr, store_fpr, fp_cmp, fp_unary, fp_binary, fp_mac)
	(fp_inv_sqrt, fpu_format_name): Add paired-single support.
	(convert): Note that this function is not used for paired-single
	format conversions.
	(ps_lower, ps_upper, pack_ps, convert_ps): New functions.
	* mips.igen (FMT, MOVtf.fmt): Add paired-single support.
	(check_fmt_p): Enable paired-single support.
	(ALNV.PS, CVT.PS.S, CVT.S.PL, CVT.S.PU, PLL.PS, PLU.PS, PUL.PS)
	(PUU.PS): New instructions.
	(CVT.S.fmt): Don't use this instruction for paired-single format
	destinations.
	* sim-main.h (FP_formats): New value 'fmt_ps.'
	(ps_lower, ps_upper, pack_ps, convert_ps): New prototypes.
	(PSLower, PSUpper, PackPS, ConvertPS): New macros.
@
text
@d85 4
d737 17
@


1.21
log
@2002-06-07  Chris Demetriou  <cgd@@broadcom.com>
            Ed Satterthwaite  <ehs@@broadcom.com>

	* cp1.c (inner_mac, fp_mac, inner_rsqrt, fp_inv_sqrt)
	(fp_rsqrt, fp_madd, fp_msub, fp_nmadd, fp_nmsub): New functions.
	* sim-main.h (fp_rsqrt, fp_madd, fp_msub, fp_nmadd)
	(fp_nmsub): New prototypes.
	(RSquareRoot, MultiplyAdd, MultiplySub, NegMultiplyAdd)
	(NegMultiplySub): New defines.
	* mips.igen (RSQRT.fmt): Use RSquareRoot().
	(MADD.D, MADD.S): Replace with...
	(MADD.fmt): New instruction.
	(MSUB.D, MSUB.S): Replace with...
	(MSUB.fmt): New instruction.
	(NMADD.D, NMADD.S): Replace with...
	(NMADD.fmt): New instruction.
	(NMSUB.D, MSUB.S): Replace with...
	(NMSUB.fmt): New instruction.
@
text
@d76 1
d678 6
d730 3
@


1.20
log
@2002-06-06  Chris Demetriou  <cgd@@broadcom.com>
            Ed Satterthwaite  <ehs@@broadcom.com>

	* cp1.h: New file.
	* sim-main.h: Include cp1.h.
	(SETFCC, GETFCC, IR, UF, OF, DX, IO, UO, FP_FLAGS, FP_ENABLE)
	(FP_CAUSE, GETFS, FP_RM_NEAREST, FP_RM_TOZERO, FP_RM_TOPINF)
	(FP_RM_TOMINF, GETRM): Remove.  Moved to cp1.h.
	(FP_FS, FP_MASK_RM, FP_SH_RM, Nan, Less, Equal): Remove.
	(value_fcr, store_fcr, test_fcsr, fp_cmp): New prototypes.
	(ValueFCR, StoreFCR, TestFCSR, Compare): New macros.
	* cp1.c: Don't include sim-fpu.h; already included by
	sim-main.h.  Clean up formatting of some comments.
	(NaN, Equal, Less): Remove.
	(test_fcsr, value_fcr, store_fcr, update_fcsr, fp_test)
	(fp_cmp): New functions.
	* mips.igen (do_c_cond_fmt): Remove.
	(C.cond.fmta, C.cond.fmtb): Replace uses of do_c_cond_fmt_a with
	Compare.  Add result tracing.
	(CxC1): Remove, replace with...
	(CFC1a, CFC1b, CFC1c, CTC1a, CTC1b, CTC1c): New instructions.
	(DMxC1): Remove, replace with...
	(DMFC1a, DMFC1b, DMTC1a, DMTC1b): New instructions.
	(MxC1): Remove, replace with...
	(MFC1a, MFC1b, MTC1a, MTC1b): New instructions.
@
text
@d707 14
@


1.19
log
@2002-06-04  Chris Demetriou  <cgd@@broadcom.com>

        * sim-main.h (FGRIDX): Remove, replace all uses with...
        (FGR_BASE): New macro.
        (FP0_REGNUM, FCRCS_REGNUM, FCRIR_REGNUM): New macros.
        (_sim_cpu): Move 'fgr' member to be right before 'fpr_state' member.
        (NR_FGR, FGR): Likewise.
        * interp.c: Replace all uses of FGRIDX with FGR_BASE.
        * mips.igen: Likewise.
@
text
@d67 1
a83 11
/* Macro to update FPSR condition-code field. This is complicated by
   the fact that there is a hole in the index range of the bits within
   the FCSR register. Also, the number of bits visible depends on the
   MIPS ISA version being supported. */

#define SETFCC(cc,v) {\
  int bit = ((cc == 0) ? 23 : (24 + (cc)));\
  FCSR = ((FCSR & ~(1 << bit)) | ((v) << bit));\
}
#define GETFCC(cc) (((((cc) == 0) ? (FCSR & (1 << 23)) : (FCSR & (1 << (24 + (cc))))) != 0) ? 1U : 0)

a96 30
/* Standard FCRS bits: */
#define IR (0) /* Inexact Result */
#define UF (1) /* UnderFlow */
#define OF (2) /* OverFlow */
#define DZ (3) /* Division by Zero */
#define IO (4) /* Invalid Operation */
#define UO (5) /* Unimplemented Operation */

/* Get masks for individual flags: */
#if 1 /* SAFE version */
#define FP_FLAGS(b)  (((unsigned)(b) < 5) ? (1 << ((b) + 2)) : 0)
#define FP_ENABLE(b) (((unsigned)(b) < 5) ? (1 << ((b) + 7)) : 0)
#define FP_CAUSE(b)  (((unsigned)(b) < 6) ? (1 << ((b) + 12)) : 0)
#else
#define FP_FLAGS(b)  (1 << ((b) + 2))
#define FP_ENABLE(b) (1 << ((b) + 7))
#define FP_CAUSE(b)  (1 << ((b) + 12))
#endif

#define FP_FS         (1 << 24) /* MIPS III onwards : Flush to Zero */

#define FP_MASK_RM    (0x3)
#define FP_SH_RM      (0)
#define FP_RM_NEAREST (0) /* Round to nearest        (Round) */
#define FP_RM_TOZERO  (1) /* Round to zero           (Trunc) */
#define FP_RM_TOPINF  (2) /* Round to Plus infinity  (Ceil) */
#define FP_RM_TOMINF  (3) /* Round to Minus infinity (Floor) */
#define GETRM()       (int)((FCSR >> FP_SH_RM) & FP_MASK_RM)


d679 9
d689 2
a690 3
int NaN (unsigned64 op, FP_formats fmt);
int Less (unsigned64 op1, unsigned64 op2, FP_formats fmt);
int Equal (unsigned64 op1, unsigned64 op2, FP_formats fmt);
@


1.18
log
@2002-06-04  Chris Demetriou  <cgd@@broadcom.com>
            Ed Satterthwaite  <ehs@@broadcom.com>

        * cp1.c (Infinity): Remove.
        * sim-main.h (Infinity): Likewise.

        * cp1.c (fp_unary, fp_binary): New functions.
        (fp_abs, fp_neg, fp_add, fp_sub, fp_mul, fp_div, fp_recip)
        (fp_sqrt): New functions, implemented in terms of the above.
        (AbsoluteValue, Negate, Add, Sub, Multiply, Divide)
        (Recip, SquareRoot): Remove (replaced by functions above).
        * sim-main.h (fp_abs, fp_neg, fp_add, fp_sub, fp_mul, fp_div)
        (fp_recip, fp_sqrt): New prototypes.
        (AbsoluteValue, Negate, Add, Sub, Multiply, Divide)
        (Recip, SquareRoot): Replace prototypes with #defines which
        invoke the functions above.
@
text
@d257 1
a257 1
  if ((R) >= FGRIDX && (R) < FGRIDX + NR_FGR)				\
d259 2
a260 2
      PENDING_SCHED(FGR[(R) - FGRIDX], VAL, 1, -1);			\
      PENDING_SCHED(FPR_STATE[(R) - FGRIDX], fmt_uninterpreted, 1, -1);	\
d353 3
a355 1

a370 9
  /* While space is allocated for the floating point registers in the
     main registers array, they are stored separatly.  This is because
     their size may not necessarily match the size of either the
     general-purpose or system specific registers */
#define NR_FGR  (32)
#define FGRIDX  (38)
  fp_word fgr[NR_FGR];
#define FGR     ((CPU)->fgr)

d422 9
@


1.17
log
@2002-06-03  Chris Demetriou  <cgd@@broadcom.com>

        * sim-main.h (Nan, Infinity, Less, Equal, AbsoluteValue, Negate)
        (Add, Sub, Multiply, Divide, Recip, SquareRoot): Move lower in
        file, remove PARAMS from prototypes.
        (value_fpr, store_fpr, convert): Likewise.  Use SIM_STATE to provide
        simulator state arguments.
        (ValueFPR, StoreFPR, Convert): Move lower in file.  Use SIM_ARGS to
        pass simulator state arguments.
        * cp1.c (SD): Redefine as CPU_STATE(cpu).
        (store_fpr, convert): Remove 'sd' argument.
        (value_fpr): Likewise.  Convert to use 'SD' instead.
@
text
@a718 1
int Infinity (unsigned64 op, FP_formats fmt);
d721 16
a736 8
unsigned64 AbsoluteValue (unsigned64 op, FP_formats fmt);
unsigned64 Negate (unsigned64 op, FP_formats fmt);
unsigned64 Add (unsigned64 op1, unsigned64 op2, FP_formats fmt);
unsigned64 Sub (unsigned64 op1, unsigned64 op2, FP_formats fmt);
unsigned64 Multiply (unsigned64 op1, unsigned64 op2, FP_formats fmt);
unsigned64 Divide (unsigned64 op1, unsigned64 op2, FP_formats fmt);
unsigned64 Recip (unsigned64 op, FP_formats fmt);
unsigned64 SquareRoot (unsigned64 op, FP_formats fmt);
@


1.16
log
@2002-06-03  Chris Demetriou  <cgd@@broadcom.com>

        * cp1.c (Min, Max): Remove #if 0'd functions.
        * sim-main.h (Min, Max): Remove.
@
text
@a82 22
unsigned64 value_fpr PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, int fpr, FP_formats));
#define ValueFPR(FPR,FMT) value_fpr (SD, CPU, cia, (FPR), (FMT))

void store_fpr PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, int fpr, FP_formats fmt, unsigned64 value));
#define StoreFPR(FPR,FMT,VALUE) store_fpr (SD, CPU, cia, (FPR), (FMT), (VALUE))

int NaN PARAMS ((unsigned64 op, FP_formats fmt));
int Infinity PARAMS ((unsigned64 op, FP_formats fmt));
int Less PARAMS ((unsigned64 op1, unsigned64 op2, FP_formats fmt));
int Equal PARAMS ((unsigned64 op1, unsigned64 op2, FP_formats fmt));
unsigned64 AbsoluteValue PARAMS ((unsigned64 op, FP_formats fmt));
unsigned64 Negate PARAMS ((unsigned64 op, FP_formats fmt));
unsigned64 Add PARAMS ((unsigned64 op1, unsigned64 op2, FP_formats fmt));
unsigned64 Sub PARAMS ((unsigned64 op1, unsigned64 op2, FP_formats fmt));
unsigned64 Multiply PARAMS ((unsigned64 op1, unsigned64 op2, FP_formats fmt));
unsigned64 Divide PARAMS ((unsigned64 op1, unsigned64 op2, FP_formats fmt));
unsigned64 Recip PARAMS ((unsigned64 op, FP_formats fmt));
unsigned64 SquareRoot PARAMS ((unsigned64 op, FP_formats fmt));
unsigned64 convert PARAMS ((SIM_DESC sd, sim_cpu *cpu, address_word cia, int rm, unsigned64 op, FP_formats from, FP_formats to));
#define Convert(rm,op,from,to) \
convert (SD, CPU, cia, rm, op, from, to)

d709 24
@


1.15
log
@2002-06-03  Chris Demetriou  <cgd@@broadcom.com>
            Ed Satterthwaite  <ehs@@broadcom.com>

	* configure.in (mipsisa64sb1*-*-*): New target for supporting
	Broadcom SiByte SB-1 processor configurations.
	* configure: Regenerate.
	* sb1.igen: New file.
	* mips.igen: Include sb1.igen.
	(sb1): New model.
	* Makefile.in (IGEN_INCLUDE): Add sb1.igen.
	* mdmx.igen: Add "sb1" model to all appropriate functions and
	instructions.
	* mdmx.c (AbsDiffOB, AvgOB, AccAbsDiffOB): New functions.
	(ob_func, ob_acc): Reference the above.
	(qh_acc): Adjust to keep the same size as ob_acc.
	* sim-main.h (status_SBX, MX_VECT_ABSD, MX_VECT_AVG, MX_AbsDiff)
	(MX_Avg, MX_VECT_ABSDA, MX_AbsDiffC): New macros.
@
text
@a100 2
unsigned64 Max PARAMS ((unsigned64 op1, unsigned64 op2, FP_formats fmt));
unsigned64 Min PARAMS ((unsigned64 op1, unsigned64 op2, FP_formats fmt));
@


1.14
log
@2002-06-02  Chris Demetriou  <cgd@@broadcom.com>
            Ed Satterthwaite  <ehs@@broadcom.com>

	* mips.igen (mdmx): New (pseudo-)model.
	* mdmx.c, mdmx.igen: New files.
	* Makefile.in (SIM_OBJS): Add mdmx.o.
	* sim-main.h (MDMX_accumulator, MX_fmtsel, signed24, signed48):
	New typedefs.
	(ACC, MX_Add, MX_AddA, MX_AddL, MX_And, MX_C_EQ, MX_C_LT, MX_Comp)
	(MX_FMT_OB, MX_FMT_QH, MX_Max, MX_Min, MX_Msgn, MX_Mul, MX_MulA)
	(MX_MulL, MX_MulS, MX_MulSL, MX_Nor, MX_Or, MX_Pick, MX_RAC)
	(MX_RAC_H, MX_RAC_L, MX_RAC_M, MX_RNAS, MX_RNAU, MX_RND_AS)
	(MX_RND_AU, MX_RND_ES, MX_RND_EU, MX_RND_ZS, MX_RND_ZU, MX_RNES)
	(MX_RNEU, MX_RZS, MX_RZU, MX_SHFL, MX_ShiftLeftLogical)
	(MX_ShiftRightArith, MX_ShiftRightLogical, MX_Sub, MX_SubA, MX_SubL)
	(MX_VECT_ADD, MX_VECT_ADDA, MX_VECT_ADDL, MX_VECT_AND)
	(MX_VECT_MAX, MX_VECT_MIN, MX_VECT_MSGN, MX_VECT_MUL, MX_VECT_MULA)
	(MX_VECT_MULL, MX_VECT_MULS, MX_VECT_MULSL, MX_VECT_NOR)
	(MX_VECT_OR, MX_VECT_SLL, MX_VECT_SRA, MX_VECT_SRL, MX_VECT_SUB)
	(MX_VECT_SUBA, MX_VECT_SUBL, MX_VECT_XOR, MX_WACH, MX_WACL, MX_Xor)
	(SIM_ARGS, SIM_STATE, UnpredictableResult, fmt_mdmx, ob_fmtsel)
	(qh_fmtsel): New macros.
	(_sim_cpu): New member "acc".
	(mdmx_acc_op, mdmx_cc_op, mdmx_cpr_op, mdmx_pick_op, mdmx_rac_op)
	(mdmx_round_op, mdmx_shuffle, mdmx_wach, mdmx_wacl): New functions.
@
text
@d570 2
a747 1

d755 2
d772 2
d792 1
d803 1
@


1.13
log
@[ common/ChangeLog ]
2002-05-01  Chris Demetriou  <cgd@@broadcom.com>

        * callback.c: Use 'deprecated' rather than 'depreciated.'

[ igen/ChangeLog ]
2002-05-01  Chris Demetriou  <cgd@@broadcom.com>

        * igen.c: Use 'deprecated' rather than 'depreciated.'

[ mips/ChangeLog ]
2002-05-01  Chris Demetriou  <cgd@@broadcom.com>

        * interp.c: Use 'deprecated' rather than 'depreciated.'
        * sim-main.h: Likewise.
@
text
@d299 18
d460 4
d732 101
d900 1
@


1.13.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@a66 1
#include "cp1.h"
a74 1
 fmt_ps      = 6,
d83 34
a116 3
/* For paired word (pw) operations, the opcode representation is fmt_word,
   but register transfers (StoreFPR, ValueFPR, etc.) are done as fmt_long.  */
#define fmt_pw fmt_long
d131 30
d281 1
a281 1
  if ((R) >= FGR_BASE && (R) < FGR_BASE + NR_FGR)			\
d283 2
a284 2
      PENDING_SCHED(FGR[(R) - FGR_BASE], VAL, 1, -1);			\
      PENDING_SCHED(FPR_STATE[(R) - FGR_BASE], fmt_uninterpreted, 1, -1); \
a298 18
/* The internal representation of an MDMX accumulator. 
   Note that 24 and 48 bit accumulator elements are represented in
   32 or 64 bits.  Since the accumulators are 2's complement with
   overflow suppressed, high-order bits can be ignored in most contexts.  */

typedef signed32 signed24;
typedef signed64 signed48;

typedef union { 
  signed24  ob[8];
  signed48  qh[4]; 
} MDMX_accumulator;


/* Conventional system arguments.  */ 
#define SIM_STATE  sim_cpu *cpu, address_word cia
#define SIM_ARGS   CPU, cia

d359 1
a359 3
#define FP0_REGNUM 38           /* Floating point register 0 (single float) */
#define FCRCS_REGNUM 70         /* FP control/status */
#define FCRIR_REGNUM 71         /* FP implementation/revision */
d375 9
a435 9
  /* While space is allocated for the floating point registers in the
     main registers array, they are stored separatly.  This is because
     their size may not necessarily match the size of either the
     general-purpose or system specific registers.  */
#define NR_FGR    (32)
#define FGR_BASE  FP0_REGNUM
  fp_word fgr[NR_FGR];
#define FGR       ((CPU)->fgr)

a441 4
  /* The MDMX accumulator (used only for MDMX ASE).  */
  MDMX_accumulator acc; 
#define ACC             ((CPU)->acc)

a547 2
/* Bits reserved for implementations:  */
#define status_SBX       (1 << 16)      /* Enable SiByte SB-1 extensions.  */
a709 185
/* FPR access.  */
unsigned64 value_fpr (SIM_STATE, int fpr, FP_formats);
#define ValueFPR(FPR,FMT) value_fpr (SIM_ARGS, (FPR), (FMT))
void store_fpr (SIM_STATE, int fpr, FP_formats fmt, unsigned64 value);
#define StoreFPR(FPR,FMT,VALUE) store_fpr (SIM_ARGS, (FPR), (FMT), (VALUE))
unsigned64 ps_lower (SIM_STATE, unsigned64 op);
#define PSLower(op) ps_lower (SIM_ARGS, op)
unsigned64 ps_upper (SIM_STATE, unsigned64 op);
#define PSUpper(op) ps_upper (SIM_ARGS, op)
unsigned64 pack_ps (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats from);
#define PackPS(op1,op2) pack_ps (SIM_ARGS, op1, op2, fmt_single)


/* FCR access.  */
unsigned_word value_fcr (SIM_STATE, int fcr);
#define ValueFCR(FCR) value_fcr (SIM_ARGS, (FCR))
void store_fcr (SIM_STATE, int fcr, unsigned_word value);
#define StoreFCR(FCR,VALUE) store_fcr (SIM_ARGS, (FCR), (VALUE))
void test_fcsr (SIM_STATE);
#define TestFCSR() test_fcsr (SIM_ARGS)


/* FPU operations.  */
void fp_cmp (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt, int abs, int cond, int cc);
#define Compare(op1,op2,fmt,cond,cc) fp_cmp(SIM_ARGS, op1, op2, fmt, 0, cond, cc)
unsigned64 fp_abs (SIM_STATE, unsigned64 op, FP_formats fmt);
#define AbsoluteValue(op,fmt) fp_abs(SIM_ARGS, op, fmt)
unsigned64 fp_neg (SIM_STATE, unsigned64 op, FP_formats fmt);
#define Negate(op,fmt) fp_neg(SIM_ARGS, op, fmt)
unsigned64 fp_add (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
#define Add(op1,op2,fmt) fp_add(SIM_ARGS, op1, op2, fmt)
unsigned64 fp_sub (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
#define Sub(op1,op2,fmt) fp_sub(SIM_ARGS, op1, op2, fmt)
unsigned64 fp_mul (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
#define Multiply(op1,op2,fmt) fp_mul(SIM_ARGS, op1, op2, fmt)
unsigned64 fp_div (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
#define Divide(op1,op2,fmt) fp_div(SIM_ARGS, op1, op2, fmt)
unsigned64 fp_recip (SIM_STATE, unsigned64 op, FP_formats fmt);
#define Recip(op,fmt) fp_recip(SIM_ARGS, op, fmt)
unsigned64 fp_sqrt (SIM_STATE, unsigned64 op, FP_formats fmt);
#define SquareRoot(op,fmt) fp_sqrt(SIM_ARGS, op, fmt)
unsigned64 fp_rsqrt (SIM_STATE, unsigned64 op, FP_formats fmt);
#define RSquareRoot(op,fmt) fp_rsqrt(SIM_ARGS, op, fmt)
unsigned64 fp_madd (SIM_STATE, unsigned64 op1, unsigned64 op2,
		    unsigned64 op3, FP_formats fmt);
#define MultiplyAdd(op1,op2,op3,fmt) fp_madd(SIM_ARGS, op1, op2, op3, fmt)
unsigned64 fp_msub (SIM_STATE, unsigned64 op1, unsigned64 op2,
		    unsigned64 op3, FP_formats fmt);
#define MultiplySub(op1,op2,op3,fmt) fp_msub(SIM_ARGS, op1, op2, op3, fmt)
unsigned64 fp_nmadd (SIM_STATE, unsigned64 op1, unsigned64 op2,
		     unsigned64 op3, FP_formats fmt);
#define NegMultiplyAdd(op1,op2,op3,fmt) fp_nmadd(SIM_ARGS, op1, op2, op3, fmt)
unsigned64 fp_nmsub (SIM_STATE, unsigned64 op1, unsigned64 op2,
		     unsigned64 op3, FP_formats fmt);
#define NegMultiplySub(op1,op2,op3,fmt) fp_nmsub(SIM_ARGS, op1, op2, op3, fmt)
unsigned64 convert (SIM_STATE, int rm, unsigned64 op, FP_formats from, FP_formats to);
#define Convert(rm,op,from,to) convert (SIM_ARGS, rm, op, from, to)
unsigned64 convert_ps (SIM_STATE, int rm, unsigned64 op, FP_formats from,
		       FP_formats to);
#define ConvertPS(rm,op,from,to) convert_ps (SIM_ARGS, rm, op, from, to)


/* MIPS-3D ASE operations.  */
#define CompareAbs(op1,op2,fmt,cond,cc) \
fp_cmp(SIM_ARGS, op1, op2, fmt, 1, cond, cc)
unsigned64 fp_add_r (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
#define AddR(op1,op2,fmt) fp_add_r(SIM_ARGS, op1, op2, fmt)
unsigned64 fp_mul_r (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
#define MultiplyR(op1,op2,fmt) fp_mul_r(SIM_ARGS, op1, op2, fmt)
unsigned64 fp_recip1 (SIM_STATE, unsigned64 op, FP_formats fmt);
#define Recip1(op,fmt) fp_recip1(SIM_ARGS, op, fmt)
unsigned64 fp_recip2 (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
#define Recip2(op1,op2,fmt) fp_recip2(SIM_ARGS, op1, op2, fmt)
unsigned64 fp_rsqrt1 (SIM_STATE, unsigned64 op, FP_formats fmt);
#define RSquareRoot1(op,fmt) fp_rsqrt1(SIM_ARGS, op, fmt)
unsigned64 fp_rsqrt2 (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
#define RSquareRoot2(op1,op2,fmt) fp_rsqrt2(SIM_ARGS, op1, op2, fmt)


/* MDMX access.  */

typedef unsigned int MX_fmtsel;   /* MDMX format select field (5 bits).  */
#define ob_fmtsel(sel) (((sel)<<1)|0x0)
#define qh_fmtsel(sel) (((sel)<<2)|0x1)

#define fmt_mdmx fmt_uninterpreted

#define MX_VECT_AND  (0)
#define MX_VECT_NOR  (1)
#define MX_VECT_OR   (2)
#define MX_VECT_XOR  (3)
#define MX_VECT_SLL  (4)
#define MX_VECT_SRL  (5)
#define MX_VECT_ADD  (6)
#define MX_VECT_SUB  (7)
#define MX_VECT_MIN  (8)
#define MX_VECT_MAX  (9)
#define MX_VECT_MUL  (10)
#define MX_VECT_MSGN (11)
#define MX_VECT_SRA  (12)
#define MX_VECT_ABSD (13)		/* SB-1 only.  */
#define MX_VECT_AVG  (14)		/* SB-1 only.  */

unsigned64 mdmx_cpr_op (SIM_STATE, int op, unsigned64 op1, int vt, MX_fmtsel fmtsel);
#define MX_Add(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_ADD, op1, vt, fmtsel)
#define MX_And(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_AND, op1, vt, fmtsel)
#define MX_Max(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_MAX, op1, vt, fmtsel)
#define MX_Min(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_MIN, op1, vt, fmtsel)
#define MX_Msgn(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_MSGN, op1, vt, fmtsel)
#define MX_Mul(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_MUL, op1, vt, fmtsel)
#define MX_Nor(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_NOR, op1, vt, fmtsel)
#define MX_Or(op1,vt,fmtsel)  mdmx_cpr_op(SIM_ARGS, MX_VECT_OR,  op1, vt, fmtsel)
#define MX_ShiftLeftLogical(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_SLL, op1, vt, fmtsel)
#define MX_ShiftRightArith(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_SRA, op1, vt, fmtsel)
#define MX_ShiftRightLogical(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_SRL, op1, vt, fmtsel)
#define MX_Sub(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_SUB, op1, vt, fmtsel)
#define MX_Xor(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_XOR, op1, vt, fmtsel)
#define MX_AbsDiff(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_ABSD, op1, vt, fmtsel)
#define MX_Avg(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_AVG, op1, vt, fmtsel)

#define MX_C_EQ  0x1
#define MX_C_LT  0x4

void mdmx_cc_op (SIM_STATE, int cond, unsigned64 op1, int vt, MX_fmtsel fmtsel);
#define MX_Comp(op1,cond,vt,fmtsel) mdmx_cc_op(SIM_ARGS, cond, op1, vt, fmtsel)

unsigned64 mdmx_pick_op (SIM_STATE, int tf, unsigned64 op1, int vt, MX_fmtsel fmtsel);
#define MX_Pick(tf,op1,vt,fmtsel) mdmx_pick_op(SIM_ARGS, tf, op1, vt, fmtsel)

#define MX_VECT_ADDA  (0)
#define MX_VECT_ADDL  (1)
#define MX_VECT_MULA  (2)
#define MX_VECT_MULL  (3)
#define MX_VECT_MULS  (4)
#define MX_VECT_MULSL (5)
#define MX_VECT_SUBA  (6)
#define MX_VECT_SUBL  (7)
#define MX_VECT_ABSDA (8)		/* SB-1 only.  */

void mdmx_acc_op (SIM_STATE, int op, unsigned64 op1, int vt, MX_fmtsel fmtsel);
#define MX_AddA(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_ADDA, op1, vt, fmtsel)
#define MX_AddL(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_ADDL, op1, vt, fmtsel)
#define MX_MulA(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_MULA, op1, vt, fmtsel)
#define MX_MulL(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_MULL, op1, vt, fmtsel)
#define MX_MulS(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_MULS, op1, vt, fmtsel)
#define MX_MulSL(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_MULSL, op1, vt, fmtsel)
#define MX_SubA(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_SUBA, op1, vt, fmtsel)
#define MX_SubL(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_SUBL, op1, vt, fmtsel)
#define MX_AbsDiffC(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_ABSDA, op1, vt, fmtsel)

#define MX_FMT_OB   (0)
#define MX_FMT_QH   (1)

/* The following codes chosen to indicate the units of shift.  */
#define MX_RAC_L    (0)
#define MX_RAC_M    (1)
#define MX_RAC_H    (2)

unsigned64 mdmx_rac_op (SIM_STATE, int, int);
#define MX_RAC(op,fmt) mdmx_rac_op(SIM_ARGS, op, fmt)

void mdmx_wacl (SIM_STATE, int, unsigned64, unsigned64);
#define MX_WACL(fmt,vs,vt) mdmx_wacl(SIM_ARGS, fmt, vs, vt)
void mdmx_wach (SIM_STATE, int, unsigned64);
#define MX_WACH(fmt,vs) mdmx_wach(SIM_ARGS, fmt, vs)

#define MX_RND_AS   (0)
#define MX_RND_AU   (1)
#define MX_RND_ES   (2)
#define MX_RND_EU   (3)
#define MX_RND_ZS   (4)
#define MX_RND_ZU   (5)

unsigned64 mdmx_round_op (SIM_STATE, int, int, MX_fmtsel);
#define MX_RNAS(vt,fmt) mdmx_round_op(SIM_ARGS, MX_RND_AS, vt, fmt)
#define MX_RNAU(vt,fmt) mdmx_round_op(SIM_ARGS, MX_RND_AU, vt, fmt)
#define MX_RNES(vt,fmt) mdmx_round_op(SIM_ARGS, MX_RND_ES, vt, fmt)
#define MX_RNEU(vt,fmt) mdmx_round_op(SIM_ARGS, MX_RND_EU, vt, fmt)
#define MX_RZS(vt,fmt)  mdmx_round_op(SIM_ARGS, MX_RND_ZS, vt, fmt)
#define MX_RZU(vt,fmt)  mdmx_round_op(SIM_ARGS, MX_RND_ZU, vt, fmt)

unsigned64 mdmx_shuffle (SIM_STATE, int, unsigned64, unsigned64);
#define MX_SHFL(shop,op1,op2) mdmx_shuffle(SIM_ARGS, shop, op1, op2)


a776 1
#define UnpredictableResult()	/* For now, do nothing.  */
@


1.13.4.1
log
@merge from trunk
@
text
@a66 1
#include "cp1.h"
a74 1
 fmt_ps      = 6,
d83 34
a116 3
/* For paired word (pw) operations, the opcode representation is fmt_word,
   but register transfers (StoreFPR, ValueFPR, etc.) are done as fmt_long.  */
#define fmt_pw fmt_long
d131 30
d281 1
a281 1
  if ((R) >= FGR_BASE && (R) < FGR_BASE + NR_FGR)			\
d283 2
a284 2
      PENDING_SCHED(FGR[(R) - FGR_BASE], VAL, 1, -1);			\
      PENDING_SCHED(FPR_STATE[(R) - FGR_BASE], fmt_uninterpreted, 1, -1); \
a298 18
/* The internal representation of an MDMX accumulator. 
   Note that 24 and 48 bit accumulator elements are represented in
   32 or 64 bits.  Since the accumulators are 2's complement with
   overflow suppressed, high-order bits can be ignored in most contexts.  */

typedef signed32 signed24;
typedef signed64 signed48;

typedef union { 
  signed24  ob[8];
  signed48  qh[4]; 
} MDMX_accumulator;


/* Conventional system arguments.  */ 
#define SIM_STATE  sim_cpu *cpu, address_word cia
#define SIM_ARGS   CPU, cia

d359 1
a359 3
#define FP0_REGNUM 38           /* Floating point register 0 (single float) */
#define FCRCS_REGNUM 70         /* FP control/status */
#define FCRIR_REGNUM 71         /* FP implementation/revision */
d375 9
a435 9
  /* While space is allocated for the floating point registers in the
     main registers array, they are stored separatly.  This is because
     their size may not necessarily match the size of either the
     general-purpose or system specific registers.  */
#define NR_FGR    (32)
#define FGR_BASE  FP0_REGNUM
  fp_word fgr[NR_FGR];
#define FGR       ((CPU)->fgr)

a441 4
  /* The MDMX accumulator (used only for MDMX ASE).  */
  MDMX_accumulator acc; 
#define ACC             ((CPU)->acc)

a547 2
/* Bits reserved for implementations:  */
#define status_SBX       (1 << 16)      /* Enable SiByte SB-1 extensions.  */
a709 185
/* FPR access.  */
unsigned64 value_fpr (SIM_STATE, int fpr, FP_formats);
#define ValueFPR(FPR,FMT) value_fpr (SIM_ARGS, (FPR), (FMT))
void store_fpr (SIM_STATE, int fpr, FP_formats fmt, unsigned64 value);
#define StoreFPR(FPR,FMT,VALUE) store_fpr (SIM_ARGS, (FPR), (FMT), (VALUE))
unsigned64 ps_lower (SIM_STATE, unsigned64 op);
#define PSLower(op) ps_lower (SIM_ARGS, op)
unsigned64 ps_upper (SIM_STATE, unsigned64 op);
#define PSUpper(op) ps_upper (SIM_ARGS, op)
unsigned64 pack_ps (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats from);
#define PackPS(op1,op2) pack_ps (SIM_ARGS, op1, op2, fmt_single)


/* FCR access.  */
unsigned_word value_fcr (SIM_STATE, int fcr);
#define ValueFCR(FCR) value_fcr (SIM_ARGS, (FCR))
void store_fcr (SIM_STATE, int fcr, unsigned_word value);
#define StoreFCR(FCR,VALUE) store_fcr (SIM_ARGS, (FCR), (VALUE))
void test_fcsr (SIM_STATE);
#define TestFCSR() test_fcsr (SIM_ARGS)


/* FPU operations.  */
void fp_cmp (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt, int abs, int cond, int cc);
#define Compare(op1,op2,fmt,cond,cc) fp_cmp(SIM_ARGS, op1, op2, fmt, 0, cond, cc)
unsigned64 fp_abs (SIM_STATE, unsigned64 op, FP_formats fmt);
#define AbsoluteValue(op,fmt) fp_abs(SIM_ARGS, op, fmt)
unsigned64 fp_neg (SIM_STATE, unsigned64 op, FP_formats fmt);
#define Negate(op,fmt) fp_neg(SIM_ARGS, op, fmt)
unsigned64 fp_add (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
#define Add(op1,op2,fmt) fp_add(SIM_ARGS, op1, op2, fmt)
unsigned64 fp_sub (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
#define Sub(op1,op2,fmt) fp_sub(SIM_ARGS, op1, op2, fmt)
unsigned64 fp_mul (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
#define Multiply(op1,op2,fmt) fp_mul(SIM_ARGS, op1, op2, fmt)
unsigned64 fp_div (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
#define Divide(op1,op2,fmt) fp_div(SIM_ARGS, op1, op2, fmt)
unsigned64 fp_recip (SIM_STATE, unsigned64 op, FP_formats fmt);
#define Recip(op,fmt) fp_recip(SIM_ARGS, op, fmt)
unsigned64 fp_sqrt (SIM_STATE, unsigned64 op, FP_formats fmt);
#define SquareRoot(op,fmt) fp_sqrt(SIM_ARGS, op, fmt)
unsigned64 fp_rsqrt (SIM_STATE, unsigned64 op, FP_formats fmt);
#define RSquareRoot(op,fmt) fp_rsqrt(SIM_ARGS, op, fmt)
unsigned64 fp_madd (SIM_STATE, unsigned64 op1, unsigned64 op2,
		    unsigned64 op3, FP_formats fmt);
#define MultiplyAdd(op1,op2,op3,fmt) fp_madd(SIM_ARGS, op1, op2, op3, fmt)
unsigned64 fp_msub (SIM_STATE, unsigned64 op1, unsigned64 op2,
		    unsigned64 op3, FP_formats fmt);
#define MultiplySub(op1,op2,op3,fmt) fp_msub(SIM_ARGS, op1, op2, op3, fmt)
unsigned64 fp_nmadd (SIM_STATE, unsigned64 op1, unsigned64 op2,
		     unsigned64 op3, FP_formats fmt);
#define NegMultiplyAdd(op1,op2,op3,fmt) fp_nmadd(SIM_ARGS, op1, op2, op3, fmt)
unsigned64 fp_nmsub (SIM_STATE, unsigned64 op1, unsigned64 op2,
		     unsigned64 op3, FP_formats fmt);
#define NegMultiplySub(op1,op2,op3,fmt) fp_nmsub(SIM_ARGS, op1, op2, op3, fmt)
unsigned64 convert (SIM_STATE, int rm, unsigned64 op, FP_formats from, FP_formats to);
#define Convert(rm,op,from,to) convert (SIM_ARGS, rm, op, from, to)
unsigned64 convert_ps (SIM_STATE, int rm, unsigned64 op, FP_formats from,
		       FP_formats to);
#define ConvertPS(rm,op,from,to) convert_ps (SIM_ARGS, rm, op, from, to)


/* MIPS-3D ASE operations.  */
#define CompareAbs(op1,op2,fmt,cond,cc) \
fp_cmp(SIM_ARGS, op1, op2, fmt, 1, cond, cc)
unsigned64 fp_add_r (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
#define AddR(op1,op2,fmt) fp_add_r(SIM_ARGS, op1, op2, fmt)
unsigned64 fp_mul_r (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
#define MultiplyR(op1,op2,fmt) fp_mul_r(SIM_ARGS, op1, op2, fmt)
unsigned64 fp_recip1 (SIM_STATE, unsigned64 op, FP_formats fmt);
#define Recip1(op,fmt) fp_recip1(SIM_ARGS, op, fmt)
unsigned64 fp_recip2 (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
#define Recip2(op1,op2,fmt) fp_recip2(SIM_ARGS, op1, op2, fmt)
unsigned64 fp_rsqrt1 (SIM_STATE, unsigned64 op, FP_formats fmt);
#define RSquareRoot1(op,fmt) fp_rsqrt1(SIM_ARGS, op, fmt)
unsigned64 fp_rsqrt2 (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);
#define RSquareRoot2(op1,op2,fmt) fp_rsqrt2(SIM_ARGS, op1, op2, fmt)


/* MDMX access.  */

typedef unsigned int MX_fmtsel;   /* MDMX format select field (5 bits).  */
#define ob_fmtsel(sel) (((sel)<<1)|0x0)
#define qh_fmtsel(sel) (((sel)<<2)|0x1)

#define fmt_mdmx fmt_uninterpreted

#define MX_VECT_AND  (0)
#define MX_VECT_NOR  (1)
#define MX_VECT_OR   (2)
#define MX_VECT_XOR  (3)
#define MX_VECT_SLL  (4)
#define MX_VECT_SRL  (5)
#define MX_VECT_ADD  (6)
#define MX_VECT_SUB  (7)
#define MX_VECT_MIN  (8)
#define MX_VECT_MAX  (9)
#define MX_VECT_MUL  (10)
#define MX_VECT_MSGN (11)
#define MX_VECT_SRA  (12)
#define MX_VECT_ABSD (13)		/* SB-1 only.  */
#define MX_VECT_AVG  (14)		/* SB-1 only.  */

unsigned64 mdmx_cpr_op (SIM_STATE, int op, unsigned64 op1, int vt, MX_fmtsel fmtsel);
#define MX_Add(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_ADD, op1, vt, fmtsel)
#define MX_And(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_AND, op1, vt, fmtsel)
#define MX_Max(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_MAX, op1, vt, fmtsel)
#define MX_Min(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_MIN, op1, vt, fmtsel)
#define MX_Msgn(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_MSGN, op1, vt, fmtsel)
#define MX_Mul(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_MUL, op1, vt, fmtsel)
#define MX_Nor(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_NOR, op1, vt, fmtsel)
#define MX_Or(op1,vt,fmtsel)  mdmx_cpr_op(SIM_ARGS, MX_VECT_OR,  op1, vt, fmtsel)
#define MX_ShiftLeftLogical(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_SLL, op1, vt, fmtsel)
#define MX_ShiftRightArith(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_SRA, op1, vt, fmtsel)
#define MX_ShiftRightLogical(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_SRL, op1, vt, fmtsel)
#define MX_Sub(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_SUB, op1, vt, fmtsel)
#define MX_Xor(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_XOR, op1, vt, fmtsel)
#define MX_AbsDiff(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_ABSD, op1, vt, fmtsel)
#define MX_Avg(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_AVG, op1, vt, fmtsel)

#define MX_C_EQ  0x1
#define MX_C_LT  0x4

void mdmx_cc_op (SIM_STATE, int cond, unsigned64 op1, int vt, MX_fmtsel fmtsel);
#define MX_Comp(op1,cond,vt,fmtsel) mdmx_cc_op(SIM_ARGS, cond, op1, vt, fmtsel)

unsigned64 mdmx_pick_op (SIM_STATE, int tf, unsigned64 op1, int vt, MX_fmtsel fmtsel);
#define MX_Pick(tf,op1,vt,fmtsel) mdmx_pick_op(SIM_ARGS, tf, op1, vt, fmtsel)

#define MX_VECT_ADDA  (0)
#define MX_VECT_ADDL  (1)
#define MX_VECT_MULA  (2)
#define MX_VECT_MULL  (3)
#define MX_VECT_MULS  (4)
#define MX_VECT_MULSL (5)
#define MX_VECT_SUBA  (6)
#define MX_VECT_SUBL  (7)
#define MX_VECT_ABSDA (8)		/* SB-1 only.  */

void mdmx_acc_op (SIM_STATE, int op, unsigned64 op1, int vt, MX_fmtsel fmtsel);
#define MX_AddA(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_ADDA, op1, vt, fmtsel)
#define MX_AddL(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_ADDL, op1, vt, fmtsel)
#define MX_MulA(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_MULA, op1, vt, fmtsel)
#define MX_MulL(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_MULL, op1, vt, fmtsel)
#define MX_MulS(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_MULS, op1, vt, fmtsel)
#define MX_MulSL(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_MULSL, op1, vt, fmtsel)
#define MX_SubA(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_SUBA, op1, vt, fmtsel)
#define MX_SubL(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_SUBL, op1, vt, fmtsel)
#define MX_AbsDiffC(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_ABSDA, op1, vt, fmtsel)

#define MX_FMT_OB   (0)
#define MX_FMT_QH   (1)

/* The following codes chosen to indicate the units of shift.  */
#define MX_RAC_L    (0)
#define MX_RAC_M    (1)
#define MX_RAC_H    (2)

unsigned64 mdmx_rac_op (SIM_STATE, int, int);
#define MX_RAC(op,fmt) mdmx_rac_op(SIM_ARGS, op, fmt)

void mdmx_wacl (SIM_STATE, int, unsigned64, unsigned64);
#define MX_WACL(fmt,vs,vt) mdmx_wacl(SIM_ARGS, fmt, vs, vt)
void mdmx_wach (SIM_STATE, int, unsigned64);
#define MX_WACH(fmt,vs) mdmx_wach(SIM_ARGS, fmt, vs)

#define MX_RND_AS   (0)
#define MX_RND_AU   (1)
#define MX_RND_ES   (2)
#define MX_RND_EU   (3)
#define MX_RND_ZS   (4)
#define MX_RND_ZU   (5)

unsigned64 mdmx_round_op (SIM_STATE, int, int, MX_fmtsel);
#define MX_RNAS(vt,fmt) mdmx_round_op(SIM_ARGS, MX_RND_AS, vt, fmt)
#define MX_RNAU(vt,fmt) mdmx_round_op(SIM_ARGS, MX_RND_AU, vt, fmt)
#define MX_RNES(vt,fmt) mdmx_round_op(SIM_ARGS, MX_RND_ES, vt, fmt)
#define MX_RNEU(vt,fmt) mdmx_round_op(SIM_ARGS, MX_RND_EU, vt, fmt)
#define MX_RZS(vt,fmt)  mdmx_round_op(SIM_ARGS, MX_RND_ZS, vt, fmt)
#define MX_RZU(vt,fmt)  mdmx_round_op(SIM_ARGS, MX_RND_ZU, vt, fmt)

unsigned64 mdmx_shuffle (SIM_STATE, int, unsigned64, unsigned64);
#define MX_SHFL(shop,op1,op2) mdmx_shuffle(SIM_ARGS, shop, op1, op2)


a776 1
#define UnpredictableResult()	/* For now, do nothing.  */
@


1.12
log
@2002-05-01  Chris Demetriou  <cgd@@broadcom.com>

        * cp1.c (store_fpr): Remove #ifdef'd out call to UndefinedResult
        which wouldn't compile anyway.
        * sim-main.h (unpredictable_action): New function prototype.
        (Unpredictable): Define to call igen function unpredictable().
        (NotWordValue): New macro to call igen function not_word_value().
        (UndefinedResult): Remove.
        * interp.c (undefined_result): Remove.
        (unpredictable_action): New function.
        * mips.igen (not_word_value, unpredictable): New functions.
        (ADD, ADDI, do_addiu, do_addu, BGEZAL, BGEZALL, BLTZAL, BLTZALL)
        (CLO, CLZ, MADD, MADDU, MSUB, MSUBU, MUL, do_mult, do_multu)
        (do_sra, do_srav, do_srl, do_srlv, SUB, do_subu): Invoke
        NotWordValue() to check for unpredictable inputs, then
        Unpredictable() to handle them.
@
text
@d46 1
a46 1
/* Depreciated macros and types for manipulating 64bit values.  Use
@


1.11
log
@2002-03-05  Chris Demetriou  <cgd@@broadcom.com>

        * sim-main.h (UndefinedResult, Unpredictable): New macros
        which currently do nothing.
@
text
@d774 3
a776 2
#define UndefinedResult()
#define Unpredictable()
@


1.10
log
@2002-03-05  Chris Demetriou  <cgd@@broadcom.com>

        * sim-main.h (status_UX, status_SX, status_KX, status_TS)
        (status_PX, status_MX, status_CU0, status_CU1, status_CU2)
        (status_CU3): New definitions.

        * sim-main.h (ExceptionCause): Add new values for MIPS32
        and MIPS64: MDMX, MCheck, CacheErr.  Update comments
        for DebugBreakPoint and NMIReset to note their status in
        MIPS32 and MIPS64.
        (SignalExceptionMDMX, SignalExceptionWatch, SignalExceptionMCheck)
        (SignalExceptionCacheErr): New exception macros.
@
text
@d774 3
@


1.9
log
@2002-03-05  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (check_fpu): Enable check for coprocessor 1 usability.
        * sim-main.h (COP_Usable): Define, but for now coprocessor 1
        is always enabled.
        (SignalExceptionCoProcessorUnusable): Take as argument the
        unusable coprocessor number.
@
text
@d537 12
d626 2
a627 1
  DebugBreakPoint         = 16,
d629 3
a631 1
  NMIReset                = 31,
d678 4
@


1.8
log
@2002-02-05  Chris Demetriou  <cgd@@broadcom.com>

        * sim-main.h (SIGNEXTEND): Remove.
@
text
@d656 1
a656 1
#define SignalExceptionCoProcessorUnusable() signal_exception (SD, CPU, cia, CoProcessorUnusable)
d665 3
@


1.7
log
@	2001-11-17  Fred Fish  <fnf@@redhat.com>
	* sim-main.h (float_operation): Move enum declaration outside
	of _sim_cpu struct declaration.
@
text
@a58 9
/* Sign-extend the given value (e) as a value (b) bits long. We cannot
   assume the HI32bits of the operand are zero, so we must perform a
   mask to ensure we can use the simple subtraction to sign-extend. */
#define SIGNEXTEND(e,b) \
 ((unsigned_word) \
  (((e) & ((uword64) 1 << ((b) - 1))) \
   ? (((e) & (((uword64) 1 << (b)) - 1)) - ((uword64)1 << (b))) \
   : ((e) & (((((uword64) 1 << ((b) - 1)) - 1) << 1) | 1))))

@


1.6
log
@* mips.igen (CFC1, CTC1): Pass the correct register numbers to
PENDING_FILL.  Use PENDING_SCHED directly to handle the pending
set of the FCSR.
* sim-main.h (COCIDX): Remove definition; this isn't supported by
PENDING_FILL, and you can get the intended effect gracefully by
calling PENDING_SCHED directly.
@
text
@d300 7
a370 7

enum float_operation
  {
    FLOP_ADD,    FLOP_SUB,    FLOP_MUL,    FLOP_MADD,
    FLOP_MSUB,   FLOP_MAX=10, FLOP_MIN,    FLOP_ABS,
    FLOP_ITOF0=14, FLOP_FTOI0=18, FLOP_NEG=23
  };
@


1.5
log
@2001-02-23  Ben Elliston  <bje@@redhat.com>

	* sim-main.h (ENGINE_ISSUE_PREFIX_HOOK): Only define if not
	already defined elsewhere.
@
text
@a407 1
#define COCIDX  (LAST_EMBED_REGNUM + 2) /* special case : outside the normal range */
@


1.4
log
@2001-02-19  Ben Elliston  <bje@@redhat.com>

	* sim-main.h (sim_monitor): Return an int.
	* interp.c (sim_monitor): Add return values.
	(signal_exception): Handle error conditions from sim_monitor.
@
text
@d331 1
d347 1
@


1.3
log
@* cleanup

2000-10-19  Frank Ch. Eigler  <fche@@redhat.com>

	On advice from Chris G. Demetriou <cgd@@sibyte.com>:
	* sim-main.h (GPR_CLEAR): Remove unused alternative macro.
@
text
@d693 1
a693 1
void sim_monitor (SIM_DESC sd, sim_cpu *cpu, address_word cia, unsigned int arg);
@


1.2
log
@Define GPR_CLEAR
@
text
@a775 4
/* Some mips flavours split their GPR banks into two halves. */
#ifdef SPLIT_GPR
#define GPR_CLEAR(N) do { GPR_SET((N),0); GPR1_SET((N),0); } while (0)
#else
a776 1
#endif
@


1.1
log
@Initial revision
@
text
@d776 7
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@

