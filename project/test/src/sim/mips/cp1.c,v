head	1.29;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.29
	gdb_7_6-2013-04-26-release:1.29
	gdb_7_6-branch:1.29.0.2
	gdb_7_6-2013-03-12-branchpoint:1.29
	gdb_7_5_1-2012-11-29-release:1.28
	gdb_7_5-2012-08-17-release:1.28
	gdb_7_5-branch:1.28.0.2
	gdb_7_5-2012-07-18-branchpoint:1.28
	gdb_7_4_1-2012-04-26-release:1.27.4.1
	gdb_7_4-2012-01-24-release:1.27.4.1
	gdb_7_4-branch:1.27.0.4
	gdb_7_4-2011-12-13-branchpoint:1.27
	gdb_7_3_1-2011-09-04-release:1.27
	gdb_7_3-2011-07-26-release:1.27
	gdb_7_3-branch:1.27.0.2
	gdb_7_3-2011-04-01-branchpoint:1.27
	gdb_7_2-2010-09-02-release:1.26
	gdb_7_2-branch:1.26.0.4
	gdb_7_2-2010-07-07-branchpoint:1.26
	gdb_7_1-2010-03-18-release:1.26
	gdb_7_1-branch:1.26.0.2
	gdb_7_1-2010-02-18-branchpoint:1.26
	gdb_7_0_1-2009-12-22-release:1.25
	gdb_7_0-2009-10-06-release:1.25
	gdb_7_0-branch:1.25.0.4
	gdb_7_0-2009-09-16-branchpoint:1.25
	arc-sim-20090309:1.24
	msnyder-checkpoint-072509-branch:1.25.0.2
	msnyder-checkpoint-072509-branchpoint:1.25
	arc-insight_6_8-branch:1.24.0.16
	arc-insight_6_8-branchpoint:1.24
	insight_6_8-branch:1.24.0.14
	insight_6_8-branchpoint:1.24
	reverse-20081226-branch:1.24.0.12
	reverse-20081226-branchpoint:1.24
	multiprocess-20081120-branch:1.24.0.10
	multiprocess-20081120-branchpoint:1.24
	reverse-20080930-branch:1.24.0.8
	reverse-20080930-branchpoint:1.24
	reverse-20080717-branch:1.24.0.6
	reverse-20080717-branchpoint:1.24
	msnyder-reverse-20080609-branch:1.24.0.4
	msnyder-reverse-20080609-branchpoint:1.24
	drow-reverse-20070409-branch:1.22.0.2
	drow-reverse-20070409-branchpoint:1.22
	gdb_6_8-2008-03-27-release:1.24
	gdb_6_8-branch:1.24.0.2
	gdb_6_8-2008-02-26-branchpoint:1.24
	gdb_6_7_1-2007-10-29-release:1.23
	gdb_6_7-2007-10-10-release:1.23
	gdb_6_7-branch:1.23.0.2
	gdb_6_7-2007-09-07-branchpoint:1.23
	insight_6_6-20070208-release:1.20
	gdb_6_6-2006-12-18-release:1.20
	gdb_6_6-branch:1.20.0.68
	gdb_6_6-2006-11-15-branchpoint:1.20
	insight_6_5-20061003-release:1.20
	gdb-csl-symbian-6_4_50_20060226-12:1.20
	gdb-csl-sourcerygxx-3_4_4-25:1.20
	nickrob-async-20060828-mergepoint:1.20
	gdb-csl-symbian-6_4_50_20060226-11:1.20
	gdb-csl-sourcerygxx-4_1-17:1.20
	gdb-csl-20060226-branch-local-2:1.20
	gdb-csl-sourcerygxx-4_1-14:1.20
	gdb-csl-sourcerygxx-4_1-13:1.20
	gdb-csl-sourcerygxx-4_1-12:1.20
	gdb-csl-sourcerygxx-3_4_4-21:1.20
	gdb_6_5-20060621-release:1.20
	gdb-csl-sourcerygxx-4_1-9:1.20
	gdb-csl-sourcerygxx-4_1-8:1.20
	gdb-csl-sourcerygxx-4_1-7:1.20
	gdb-csl-arm-2006q1-6:1.20
	gdb-csl-sourcerygxx-4_1-6:1.20
	gdb-csl-symbian-6_4_50_20060226-10:1.20
	gdb-csl-symbian-6_4_50_20060226-9:1.20
	gdb-csl-symbian-6_4_50_20060226-8:1.20
	gdb-csl-coldfire-4_1-11:1.20
	gdb-csl-sourcerygxx-3_4_4-19:1.20
	gdb-csl-coldfire-4_1-10:1.20
	gdb_6_5-branch:1.20.0.66
	gdb_6_5-2006-05-14-branchpoint:1.20
	gdb-csl-sourcerygxx-4_1-5:1.20
	nickrob-async-20060513-branch:1.20.0.64
	nickrob-async-20060513-branchpoint:1.20
	gdb-csl-sourcerygxx-4_1-4:1.20
	msnyder-reverse-20060502-branch:1.20.0.62
	msnyder-reverse-20060502-branchpoint:1.20
	gdb-csl-morpho-4_1-4:1.20
	gdb-csl-sourcerygxx-3_4_4-17:1.20
	readline_5_1-import-branch:1.20.0.60
	readline_5_1-import-branchpoint:1.20
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.20
	gdb-csl-symbian-20060226-branch:1.20.0.58
	gdb-csl-symbian-20060226-branchpoint:1.20
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.20
	msnyder-reverse-20060331-branch:1.20.0.56
	msnyder-reverse-20060331-branchpoint:1.20
	gdb-csl-available-20060303-branch:1.20.0.54
	gdb-csl-available-20060303-branchpoint:1.20
	gdb-csl-20060226-branch:1.20.0.52
	gdb-csl-20060226-branchpoint:1.20
	gdb_6_4-20051202-release:1.20
	msnyder-fork-checkpoint-branch:1.20.0.50
	msnyder-fork-checkpoint-branchpoint:1.20
	gdb-csl-gxxpro-6_3-branch:1.20.0.48
	gdb-csl-gxxpro-6_3-branchpoint:1.20
	gdb_6_4-branch:1.20.0.46
	gdb_6_4-2005-11-01-branchpoint:1.20
	gdb-csl-arm-20051020-branch:1.20.0.44
	gdb-csl-arm-20051020-branchpoint:1.20
	msnyder-tracepoint-checkpoint-branch:1.20.0.42
	msnyder-tracepoint-checkpoint-branchpoint:1.20
	gdb-csl-arm-20050325-2005-q1b:1.20
	gdb-csl-arm-20050325-2005-q1a:1.20
	csl-arm-20050325-branch:1.20.0.40
	csl-arm-20050325-branchpoint:1.20
	gdb_6_3-20041109-release:1.20
	gdb_6_3-branch:1.20.0.36
	gdb_6_3-20041019-branchpoint:1.20
	drow_intercu-merge-20040921:1.20
	drow_intercu-merge-20040915:1.20
	jimb-gdb_6_2-e500-branch:1.20.0.38
	jimb-gdb_6_2-e500-branchpoint:1.20
	gdb_6_2-20040730-release:1.20
	gdb_6_2-branch:1.20.0.34
	gdb_6_2-2004-07-10-gmt-branchpoint:1.20
	gdb_6_1_1-20040616-release:1.20
	gdb_6_1-2004-04-05-release:1.20
	drow_intercu-merge-20040402:1.20
	drow_intercu-merge-20040327:1.20
	ezannoni_pie-20040323-branch:1.20.0.32
	ezannoni_pie-20040323-branchpoint:1.20
	cagney_tramp-20040321-mergepoint:1.20
	cagney_tramp-20040309-branch:1.20.0.30
	cagney_tramp-20040309-branchpoint:1.20
	gdb_6_1-branch:1.20.0.28
	gdb_6_1-2004-03-01-gmt-branchpoint:1.20
	drow_intercu-20040221-branch:1.20.0.26
	drow_intercu-20040221-branchpoint:1.20
	cagney_bfdfile-20040213-branch:1.20.0.24
	cagney_bfdfile-20040213-branchpoint:1.20
	drow-cplus-merge-20040208:1.20
	carlton_dictionary-20040126-merge:1.20
	cagney_bigcore-20040122-branch:1.20.0.22
	cagney_bigcore-20040122-branchpoint:1.20
	drow-cplus-merge-20040113:1.20
	drow-cplus-merge-20031224:1.20
	drow-cplus-merge-20031220:1.20
	carlton_dictionary-20031215-merge:1.20
	drow-cplus-merge-20031214:1.20
	carlton-dictionary-20031111-merge:1.20
	gdb_6_0-2003-10-04-release:1.20
	kettenis_sparc-20030918-branch:1.20.0.20
	kettenis_sparc-20030918-branchpoint:1.20
	carlton_dictionary-20030917-merge:1.20
	ezannoni_pie-20030916-branchpoint:1.20
	ezannoni_pie-20030916-branch:1.20.0.18
	cagney_x86i386-20030821-branch:1.20.0.16
	cagney_x86i386-20030821-branchpoint:1.20
	carlton_dictionary-20030805-merge:1.20
	carlton_dictionary-20030627-merge:1.20
	gdb_6_0-branch:1.20.0.14
	gdb_6_0-2003-06-23-branchpoint:1.20
	jimb-ppc64-linux-20030613-branch:1.20.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.20
	cagney_convert-20030606-branch:1.20.0.10
	cagney_convert-20030606-branchpoint:1.20
	cagney_writestrings-20030508-branch:1.20.0.8
	cagney_writestrings-20030508-branchpoint:1.20
	jimb-ppc64-linux-20030528-branch:1.20.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.20
	carlton_dictionary-20030523-merge:1.20
	cagney_fileio-20030521-branch:1.20.0.4
	cagney_fileio-20030521-branchpoint:1.20
	kettenis_i386newframe-20030517-mergepoint:1.20
	jimb-ppc64-linux-20030509-branch:1.20.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.20
	kettenis_i386newframe-20030504-mergepoint:1.20
	carlton_dictionary-20030430-merge:1.19
	kettenis_i386newframe-20030419-branch:1.19.0.30
	kettenis_i386newframe-20030419-branchpoint:1.19
	carlton_dictionary-20030416-merge:1.19
	cagney_frameaddr-20030409-mergepoint:1.19
	kettenis_i386newframe-20030406-branch:1.19.0.28
	kettenis_i386newframe-20030406-branchpoint:1.19
	cagney_frameaddr-20030403-branchpoint:1.19
	cagney_frameaddr-20030403-branch:1.19.0.26
	cagney_framebase-20030330-mergepoint:1.19
	cagney_framebase-20030326-branch:1.19.0.24
	cagney_framebase-20030326-branchpoint:1.19
	cagney_lazyid-20030317-branch:1.19.0.22
	cagney_lazyid-20030317-branchpoint:1.19
	kettenis-i386newframe-20030316-mergepoint:1.19
	offbyone-20030313-branch:1.19.0.20
	offbyone-20030313-branchpoint:1.19
	kettenis-i386newframe-20030308-branch:1.19.0.18
	kettenis-i386newframe-20030308-branchpoint:1.19
	carlton_dictionary-20030305-merge:1.19
	cagney_offbyone-20030303-branch:1.19.0.16
	cagney_offbyone-20030303-branchpoint:1.19
	carlton_dictionary-20030207-merge:1.19
	interps-20030202-branch:1.19.0.14
	interps-20030202-branchpoint:1.19
	cagney-unwind-20030108-branch:1.19.0.12
	cagney-unwind-20030108-branchpoint:1.19
	carlton_dictionary-20021223-merge:1.19
	gdb_5_3-2002-12-12-release:1.19
	carlton_dictionary-20021115-merge:1.19
	kseitz_interps-20021105-merge:1.19
	kseitz_interps-20021103-merge:1.19
	drow-cplus-merge-20021020:1.19
	drow-cplus-merge-20021025:1.19
	carlton_dictionary-20021025-merge:1.19
	carlton_dictionary-20021011-merge:1.19
	drow-cplus-branch:1.19.0.10
	drow-cplus-branchpoint:1.19
	kseitz_interps-20020930-merge:1.19
	carlton_dictionary-20020927-merge:1.19
	carlton_dictionary-branch:1.19.0.8
	carlton_dictionary-20020920-branchpoint:1.19
	gdb_5_3-branch:1.19.0.6
	gdb_5_3-2002-09-04-branchpoint:1.19
	kseitz_interps-20020829-merge:1.19
	cagney_sysregs-20020825-branch:1.19.0.4
	cagney_sysregs-20020825-branchpoint:1.19
	readline_4_3-import-branch:1.19.0.2
	readline_4_3-import-branchpoint:1.19
	kseitz_interps-20020528-branch:1.5.0.6
	kseitz_interps-20020528-branchpoint:1.5
	cagney_regbuf-20020515-branch:1.5.0.4
	cagney_regbuf-20020515-branchpoint:1.5
	jimb-macro-020506-branch:1.5.0.2
	jimb-macro-020506-branchpoint:1.5;
locks; strict;
comment	@ * @;


1.29
date	2013.01.01.06.41.39;	author brobecke;	state Exp;
branches;
next	1.28;

1.28
date	2012.01.04.08.28.20;	author brobecke;	state Exp;
branches;
next	1.27;

1.27
date	2011.01.01.15.34.03;	author brobecke;	state Exp;
branches
	1.27.4.1;
next	1.26;

1.26
date	2010.01.01.10.03.32;	author brobecke;	state Exp;
branches;
next	1.25;

1.25
date	2009.01.14.10.53.08;	author brobecke;	state Exp;
branches;
next	1.24;

1.24
date	2008.01.01.22.53.25;	author drow;	state Exp;
branches;
next	1.23;

1.23
date	2007.08.24.14.28.40;	author brobecke;	state Exp;
branches;
next	1.22;

1.22
date	2007.02.19.17.31.07;	author ths;	state Exp;
branches;
next	1.21;

1.21
date	2007.01.09.17.59.18;	author drow;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.02.22.17.21;	author cgd;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.29.23.17.10;	author msnyder;	state Exp;
branches
	1.19.8.1
	1.19.10.1
	1.19.30.1;
next	1.18;

1.18
date	2002.06.14.18.49.09;	author cgd;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.14.04.44.11;	author cgd;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.08.03.05.23;	author cgd;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.07.22.55.49;	author cgd;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.07.16.50.42;	author cgd;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.07.16.43.19;	author cgd;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.07.00.13.23;	author cgd;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.04.16.35.24;	author cgd;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.04.16.17.20;	author cgd;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.04.01.35.23;	author cgd;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.04.00.18.46;	author cgd;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.03.22.30.52;	author cgd;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.03.22.05.15;	author cgd;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.01.17.26.14;	author cgd;	state Exp;
branches
	1.5.4.1
	1.5.6.1;
next	1.4;

1.4
date	2002.03.20.07.24.20;	author cgd;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.20.07.10.37;	author cgd;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.20.06.42.05;	author cgd;	state Exp;
branches;
next	1.1;

1.1
date	2002.03.20.01.35.13;	author cgd;	state Exp;
branches;
next	;

1.27.4.1
date	2012.01.06.04.54.54;	author brobecke;	state Exp;
branches;
next	;

1.19.8.1
date	2003.05.23.18.40.57;	author carlton;	state Exp;
branches;
next	;

1.19.10.1
date	2003.12.14.20.28.28;	author drow;	state Exp;
branches;
next	;

1.19.30.1
date	2003.05.04.11.37.51;	author kettenis;	state Exp;
branches;
next	;

1.5.4.1
date	2002.06.15.16.43.27;	author cagney;	state Exp;
branches;
next	;

1.5.6.1
date	2002.06.20.01.40.17;	author kseitz;	state Exp;
branches;
next	1.5.6.2;

1.5.6.2
date	2002.08.09.18.34.38;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/*> cp1.c <*/
/* MIPS Simulator FPU (CoProcessor 1) support.
   Copyright (C) 2002-2013 Free Software Foundation, Inc.
   Originally created by Cygnus Solutions.  Extensive modifications,
   including paired-single operation support and MIPS-3D support
   contributed by Ed Satterthwaite and Chris Demetriou, of Broadcom
   Corporation (SiByte).

This file is part of GDB, the GNU debugger.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* XXX: The following notice should be removed as soon as is practical:  */
/* Floating Point Support for gdb MIPS simulators

   This file is part of the MIPS sim

		THIS SOFTWARE IS NOT COPYRIGHTED
   (by Cygnus.)

   Cygnus offers the following for use in the public domain.  Cygnus
   makes no warranty with regard to the software or it's performance
   and the user accepts the software "AS IS" with all faults.

   CYGNUS DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD TO
   THIS SOFTWARE INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

   (Originally, this code was in interp.c)
*/

#include "sim-main.h"

/* Within cp1.c we refer to sim_cpu directly.  */
#define CPU cpu
#define SD CPU_STATE(cpu)

/*-- FPU support routines ---------------------------------------------------*/

/* Numbers are held in normalized form. The SINGLE and DOUBLE binary
   formats conform to ANSI/IEEE Std 754-1985.

   SINGLE precision floating:
      seeeeeeeefffffffffffffffffffffff
        s =  1bit  = sign
        e =  8bits = exponent
        f = 23bits = fraction

   SINGLE precision fixed:
      siiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
        s =  1bit  = sign
        i = 31bits = integer

   DOUBLE precision floating:
      seeeeeeeeeeeffffffffffffffffffffffffffffffffffffffffffffffffffff
        s =  1bit  = sign
        e = 11bits = exponent
        f = 52bits = fraction

   DOUBLE precision fixed:
      siiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
        s =  1bit  = sign
        i = 63bits = integer

   PAIRED SINGLE precision floating:
      seeeeeeeefffffffffffffffffffffffseeeeeeeefffffffffffffffffffffff
      |         upper                ||         lower                |
        s =  1bit  = sign
        e =  8bits = exponent
        f = 23bits = fraction
    Note: upper = [63..32], lower = [31..0]
 */

/* Extract packed single values:  */
#define FP_PS_upper(v) (((v) >> 32) & (unsigned)0xFFFFFFFF)
#define FP_PS_lower(v) ((v) & (unsigned)0xFFFFFFFF)
#define FP_PS_cat(u,l) (((unsigned64)((u) & (unsigned)0xFFFFFFFF) << 32) \
                        | (unsigned64)((l) & 0xFFFFFFFF))

/* Explicit QNaN values.  */
#define FPQNaN_SINGLE   (0x7FBFFFFF)
#define FPQNaN_WORD     (0x7FFFFFFF)
#define FPQNaN_DOUBLE   (UNSIGNED64 (0x7FF7FFFFFFFFFFFF))
#define FPQNaN_LONG     (UNSIGNED64 (0x7FFFFFFFFFFFFFFF))
#define FPQNaN_PS       (FP_PS_cat (FPQNaN_SINGLE, FPQNaN_SINGLE))

static const char *fpu_format_name (FP_formats fmt);
#ifdef DEBUG
static const char *fpu_rounding_mode_name (int rm);
#endif

uword64
value_fpr (sim_cpu *cpu,
	   address_word cia,
	   int fpr,
	   FP_formats fmt)
{
  uword64 value = 0;
  int err = 0;

  /* Treat unused register values, as fixed-point 64bit values.  */
  if (fmt == fmt_unknown)
    {
#if 1
      /* If request to read data as "unknown", then use the current
	 encoding:  */
      fmt = FPR_STATE[fpr];
#else
      fmt = fmt_long;
#endif
    }

  /* For values not yet accessed, set to the desired format.  */
  if (fmt < fmt_uninterpreted) 
    {
      if (FPR_STATE[fpr] == fmt_uninterpreted)
	{
	  FPR_STATE[fpr] = fmt;
#ifdef DEBUG
	  printf ("DBG: Register %d was fmt_uninterpreted. Now %s\n", fpr,
		  fpu_format_name (fmt));
#endif /* DEBUG */
	}
      else if (fmt != FPR_STATE[fpr])
	{
	  sim_io_eprintf (SD, "FPR %d (format %s) being accessed with format %s - setting to unknown (PC = 0x%s)\n",
			  fpr, fpu_format_name (FPR_STATE[fpr]),
			  fpu_format_name (fmt), pr_addr (cia));
	  FPR_STATE[fpr] = fmt_unknown;
	}
    }

  if (FPR_STATE[fpr] == fmt_unknown)
    {
      /* Set QNaN value:  */
      switch (fmt)
	{
	case fmt_single:  value = FPQNaN_SINGLE;  break;
	case fmt_double:  value = FPQNaN_DOUBLE;  break;
	case fmt_word:    value = FPQNaN_WORD;    break;
	case fmt_long:    value = FPQNaN_LONG;    break;
	case fmt_ps:      value = FPQNaN_PS;      break;
	default:          err = -1;               break;
	}
    }
  else if (SizeFGR () == 64)
    {
      switch (fmt)
	{
	case fmt_uninterpreted_32:
	case fmt_single:
	case fmt_word:
	  value = (FGR[fpr] & 0xFFFFFFFF);
	  break;

	case fmt_uninterpreted_64:
	case fmt_uninterpreted:
	case fmt_double:
	case fmt_long:
	case fmt_ps:
	  value = FGR[fpr];
	  break;

	default:
	  err = -1;
	  break;
	}
    }
  else
    {
      switch (fmt)
	{
	case fmt_uninterpreted_32:
	case fmt_single:
	case fmt_word:
	  value = (FGR[fpr] & 0xFFFFFFFF);
	  break;

	case fmt_uninterpreted_64:
	case fmt_uninterpreted:
	case fmt_double:
	case fmt_long:
	  if ((fpr & 1) == 0)
	    {
	      /* Even register numbers only.  */
#ifdef DEBUG
	      printf ("DBG: ValueFPR: FGR[%d] = %s, FGR[%d] = %s\n",
		      fpr + 1, pr_uword64 ((uword64) FGR[fpr+1]),
		      fpr, pr_uword64 ((uword64) FGR[fpr]));
#endif
	      value = ((((uword64) FGR[fpr+1]) << 32)
		       | (FGR[fpr] & 0xFFFFFFFF));
	    }
	  else
	    {
	      SignalException (ReservedInstruction, 0);
	    }
	  break;

	case fmt_ps:
	  SignalException (ReservedInstruction, 0);
	  break;

	default:
	  err = -1;
	  break;
	}
    }

  if (err)
    SignalExceptionSimulatorFault ("Unrecognised FP format in ValueFPR ()");

#ifdef DEBUG
  printf ("DBG: ValueFPR: fpr = %d, fmt = %s, value = 0x%s : PC = 0x%s : SizeFGR () = %d\n",
	  fpr, fpu_format_name (fmt), pr_uword64 (value), pr_addr (cia),
	  SizeFGR ());
#endif /* DEBUG */

  return (value);
}

void
store_fpr (sim_cpu *cpu,
	   address_word cia,
	   int fpr,
	   FP_formats fmt,
	   uword64 value)
{
  int err = 0;

#ifdef DEBUG
  printf ("DBG: StoreFPR: fpr = %d, fmt = %s, value = 0x%s : PC = 0x%s : SizeFGR () = %d, \n",
	  fpr, fpu_format_name (fmt), pr_uword64 (value), pr_addr (cia),
	  SizeFGR ());
#endif /* DEBUG */

  if (SizeFGR () == 64)
    {
      switch (fmt)
	{
	case fmt_uninterpreted_32:
	  fmt = fmt_uninterpreted;
	case fmt_single:
	case fmt_word:
	  if (STATE_VERBOSE_P (SD))
	    sim_io_eprintf (SD,
			    "Warning: PC 0x%s: interp.c store_fpr DEADCODE\n",
			    pr_addr (cia));
	  FGR[fpr] = (((uword64) 0xDEADC0DE << 32) | (value & 0xFFFFFFFF));
	  FPR_STATE[fpr] = fmt;
	  break;

	case fmt_uninterpreted_64:
	  fmt = fmt_uninterpreted;
	case fmt_uninterpreted:
	case fmt_double:
	case fmt_long:
	case fmt_ps:
	  FGR[fpr] = value;
	  FPR_STATE[fpr] = fmt;
	  break;

	default:
	  FPR_STATE[fpr] = fmt_unknown;
	  err = -1;
	  break;
	}
    }
  else
    {
      switch (fmt)
	{
	case fmt_uninterpreted_32:
	  fmt = fmt_uninterpreted;
	case fmt_single:
	case fmt_word:
	  FGR[fpr] = (value & 0xFFFFFFFF);
	  FPR_STATE[fpr] = fmt;
	  break;

	case fmt_uninterpreted_64:
	  fmt = fmt_uninterpreted;
	case fmt_uninterpreted:
	case fmt_double:
	case fmt_long:
	  if ((fpr & 1) == 0)
	    {
	      /* Even register numbers only.  */
	      FGR[fpr+1] = (value >> 32);
	      FGR[fpr] = (value & 0xFFFFFFFF);
	      FPR_STATE[fpr + 1] = fmt;
	      FPR_STATE[fpr] = fmt;
	    }
	  else
	    {
	      FPR_STATE[fpr] = fmt_unknown;
	      FPR_STATE[fpr ^ 1] = fmt_unknown;
	      SignalException (ReservedInstruction, 0);
	    }
	  break;

	case fmt_ps:
	  FPR_STATE[fpr] = fmt_unknown;
	  SignalException (ReservedInstruction, 0);
	  break;

	default:
	  FPR_STATE[fpr] = fmt_unknown;
	  err = -1;
	  break;
	}
    }

  if (err)
    SignalExceptionSimulatorFault ("Unrecognised FP format in StoreFPR ()");

#ifdef DEBUG
  printf ("DBG: StoreFPR: fpr[%d] = 0x%s (format %s)\n",
	  fpr, pr_uword64 (FGR[fpr]), fpu_format_name (fmt));
#endif /* DEBUG */

  return;
}


/* CP1 control/status register access functions.  */

void
test_fcsr (sim_cpu *cpu,
	   address_word cia)
{
  unsigned int cause;

  cause = (FCSR & fcsr_CAUSE_mask) >> fcsr_CAUSE_shift;
  if ((cause & ((FCSR & fcsr_ENABLES_mask) >> fcsr_ENABLES_shift)) != 0
      || (cause & (1 << UO)))
    {
      SignalExceptionFPE();
    }
}

unsigned_word
value_fcr(sim_cpu *cpu,
	  address_word cia,
	  int fcr)
{
  unsigned32 value = 0;

  switch (fcr)
    {
    case 0:  /* FP Implementation and Revision Register.  */
      value = FCR0;
      break;
    case 25:  /* FP Condition Codes Register (derived from FCSR).  */
      value = (FCR31 & fcsr_FCC_mask) >> fcsr_FCC_shift;
      value = (value & 0x1) | (value >> 1);   /* Close FCC gap.  */
      break;
    case 26:  /* FP Exceptions Register (derived from FCSR).  */
      value = FCR31 & (fcsr_CAUSE_mask | fcsr_FLAGS_mask);
      break;
    case 28:  /* FP Enables Register (derived from FCSR).  */
      value = FCR31 & (fcsr_ENABLES_mask | fcsr_RM_mask);
      if ((FCR31 & fcsr_FS) != 0)
	value |= fenr_FS;
      break;
    case 31:  /* FP Control/Status Register (FCSR).  */
      value = FCR31 & ~fcsr_ZERO_mask;
      break;
    }

  return (EXTEND32 (value));
}

void
store_fcr(sim_cpu *cpu,
	  address_word cia,
	  int fcr,
	  unsigned_word value)
{
  unsigned32 v;

  v = VL4_8(value);
  switch (fcr)
    {
    case 25:  /* FP Condition Codes Register (stored into FCSR).  */
      v = (v << 1) | (v & 0x1);             /* Adjust for FCC gap.  */
      FCR31 &= ~fcsr_FCC_mask;
      FCR31 |= ((v << fcsr_FCC_shift) & fcsr_FCC_mask);
      break;
    case 26:  /* FP Exceptions Register (stored into FCSR).  */
      FCR31 &= ~(fcsr_CAUSE_mask | fcsr_FLAGS_mask);
      FCR31 |= (v & (fcsr_CAUSE_mask | fcsr_FLAGS_mask));
      test_fcsr(cpu, cia);
      break;
    case 28:  /* FP Enables Register (stored into FCSR).  */
      if ((v & fenr_FS) != 0)
	v |= fcsr_FS;
      else
	v &= ~fcsr_FS;
      FCR31 &= (fcsr_FCC_mask | fcsr_CAUSE_mask | fcsr_FLAGS_mask);
      FCR31 |= (v & (fcsr_FS | fcsr_ENABLES_mask | fcsr_RM_mask));
      test_fcsr(cpu, cia);
      break;
    case 31:  /* FP Control/Status Register (FCSR).  */
      FCR31 = v & ~fcsr_ZERO_mask;
      test_fcsr(cpu, cia);
      break;
    }
}

void
update_fcsr (sim_cpu *cpu,
	     address_word cia,
	     sim_fpu_status status)
{
  FCSR &= ~fcsr_CAUSE_mask;

  if (status != 0)
    {
      unsigned int cause = 0;

      /* map between sim_fpu codes and MIPS FCSR */
      if (status & (sim_fpu_status_invalid_snan
		    | sim_fpu_status_invalid_isi
		    | sim_fpu_status_invalid_idi
		    | sim_fpu_status_invalid_zdz
		    | sim_fpu_status_invalid_imz
		    | sim_fpu_status_invalid_cmp
		    | sim_fpu_status_invalid_sqrt
		    | sim_fpu_status_invalid_cvi))
	cause |= (1 << IO);
      if (status & sim_fpu_status_invalid_div0)
	cause |= (1 << DZ);
      if (status & sim_fpu_status_overflow)
	cause |= (1 << OF);
      if (status & sim_fpu_status_underflow)
	cause |= (1 << UF);
      if (status & sim_fpu_status_inexact)
	cause |= (1 << IR);
#if 0 /* Not yet.  */
      /* Implicit clearing of other bits by unimplemented done by callers.  */
      if (status & sim_fpu_status_unimplemented)
	cause |= (1 << UO);
#endif

      FCSR |= (cause << fcsr_CAUSE_shift);
      test_fcsr (cpu, cia);
      FCSR |= ((cause & ~(1 << UO)) << fcsr_FLAGS_shift);
    }
  return;
}

static sim_fpu_round
rounding_mode(int rm)
{
  sim_fpu_round round;

  switch (rm)
    {
    case FP_RM_NEAREST:
      /* Round result to nearest representable value. When two
	 representable values are equally near, round to the value
	 that has a least significant bit of zero (i.e. is even).  */
      round = sim_fpu_round_near;
      break;
    case FP_RM_TOZERO:
      /* Round result to the value closest to, and not greater in
	 magnitude than, the result.  */
      round = sim_fpu_round_zero;
      break;
    case FP_RM_TOPINF:
      /* Round result to the value closest to, and not less than,
	 the result.  */
      round = sim_fpu_round_up;
      break;
    case FP_RM_TOMINF:
      /* Round result to the value closest to, and not greater than,
	 the result.  */
      round = sim_fpu_round_down;
      break;
    default:
      round = 0;
      fprintf (stderr, "Bad switch\n");
      abort ();
    }
  return round;
}

/* When the FS bit is set, MIPS processors return zero for
   denormalized results and optionally replace denormalized inputs
   with zero.  When FS is clear, some implementation trap on input
   and/or output, while other perform the operation in hardware.  */
static sim_fpu_denorm
denorm_mode(sim_cpu *cpu)
{
  sim_fpu_denorm denorm;

  /* XXX: FIXME: Eventually should be CPU model dependent.  */
  if (GETFS())
    denorm = sim_fpu_denorm_zero;
  else
    denorm = 0;
  return denorm;
}


/* Comparison operations.  */

static sim_fpu_status
fp_test(unsigned64 op1,
	unsigned64 op2,
	FP_formats fmt,
	int abs,
	int cond,
	int *condition)
{
  sim_fpu wop1;
  sim_fpu wop2;
  sim_fpu_status status = 0;
  int  less, equal, unordered;

  /* The format type has already been checked:  */
  switch (fmt)
    {
    case fmt_single:
      {
	sim_fpu_32to (&wop1, op1);
	sim_fpu_32to (&wop2, op2);
	break;
      }
    case fmt_double:
      {
	sim_fpu_64to (&wop1, op1);
	sim_fpu_64to (&wop2, op2);
	break;
      }
    default:
      fprintf (stderr, "Bad switch\n");
      abort ();
    }

  if (sim_fpu_is_nan (&wop1) || sim_fpu_is_nan (&wop2))
    {
      if ((cond & (1 << 3)) ||
	  sim_fpu_is_snan (&wop1) || sim_fpu_is_snan (&wop2))
	status = sim_fpu_status_invalid_snan;
      less = 0;
      equal = 0;
      unordered = 1;
    }
  else
    {
      if (abs)
	{
	  status |= sim_fpu_abs (&wop1, &wop1);
	  status |= sim_fpu_abs (&wop2, &wop2);
	}
      equal = sim_fpu_is_eq (&wop1, &wop2);
      less = !equal && sim_fpu_is_lt (&wop1, &wop2);
      unordered = 0;
    }
  *condition = (((cond & (1 << 2)) && less)
		|| ((cond & (1 << 1)) && equal)
		|| ((cond & (1 << 0)) && unordered));
  return status;
}

void
fp_cmp(sim_cpu *cpu,
       address_word cia,
       unsigned64 op1,
       unsigned64 op2,
       FP_formats fmt,
       int abs,
       int cond,
       int cc)
{
  sim_fpu_status status = 0;

  /* The format type should already have been checked.  The FCSR is
     updated before the condition codes so that any exceptions will
     be signalled before the condition codes are changed.  */
  switch (fmt)
    {
    case fmt_single:
    case fmt_double:
      {
	int result;
	status = fp_test(op1, op2, fmt, abs, cond, &result);
	update_fcsr (cpu, cia, status);
	SETFCC (cc, result);
	break;
      }
    case fmt_ps:
      {
	int result0, result1;
	status  = fp_test(FP_PS_lower (op1), FP_PS_lower (op2), fmt_single,
			  abs, cond, &result0);
	status |= fp_test(FP_PS_upper (op1), FP_PS_upper (op2), fmt_single,
			  abs, cond, &result1);
	update_fcsr (cpu, cia, status);
	SETFCC (cc, result0);
	SETFCC (cc+1, result1);
	break;
      }
    default:
      sim_io_eprintf (SD, "Bad switch\n");
      abort ();
    }
}


/* Basic arithmetic operations.  */

static unsigned64
fp_unary(sim_cpu *cpu,
	 address_word cia,
	 int (*sim_fpu_op)(sim_fpu *, const sim_fpu *),
	 unsigned64 op,
	 FP_formats fmt)
{
  sim_fpu wop;
  sim_fpu ans;
  sim_fpu_round round = rounding_mode (GETRM());
  sim_fpu_denorm denorm = denorm_mode (cpu);
  sim_fpu_status status = 0;
  unsigned64 result = 0;

  /* The format type has already been checked: */
  switch (fmt)
    {
    case fmt_single:
      {
	unsigned32 res;
	sim_fpu_32to (&wop, op);
	status |= (*sim_fpu_op) (&ans, &wop);
	status |= sim_fpu_round_32 (&ans, round, denorm);
	sim_fpu_to32 (&res, &ans);
	result = res;
	break;
      }
    case fmt_double:
      {
	unsigned64 res;
	sim_fpu_64to (&wop, op);
	status |= (*sim_fpu_op) (&ans, &wop);
	status |= sim_fpu_round_64 (&ans, round, denorm);
	sim_fpu_to64 (&res, &ans);
	result = res;
	break;
      }
    case fmt_ps:
      {
	int status_u = 0, status_l = 0;
	unsigned32 res_u, res_l;
	sim_fpu_32to (&wop, FP_PS_upper(op));
	status_u |= (*sim_fpu_op) (&ans, &wop);
	sim_fpu_to32 (&res_u, &ans);
	sim_fpu_32to (&wop, FP_PS_lower(op));
	status_l |= (*sim_fpu_op) (&ans, &wop);
	sim_fpu_to32 (&res_l, &ans);
	result = FP_PS_cat(res_u, res_l);
	status = status_u | status_l;
	break;
      }
    default:
      sim_io_eprintf (SD, "Bad switch\n");
      abort ();
    }

  update_fcsr (cpu, cia, status);
  return result;
}

static unsigned64
fp_binary(sim_cpu *cpu,
	  address_word cia,
	  int (*sim_fpu_op)(sim_fpu *, const sim_fpu *, const sim_fpu *),
	  unsigned64 op1,
	  unsigned64 op2,
	  FP_formats fmt)
{
  sim_fpu wop1;
  sim_fpu wop2;
  sim_fpu ans;
  sim_fpu_round round = rounding_mode (GETRM());
  sim_fpu_denorm denorm = denorm_mode (cpu);
  sim_fpu_status status = 0;
  unsigned64 result = 0;

  /* The format type has already been checked: */
  switch (fmt)
    {
    case fmt_single:
      {
	unsigned32 res;
	sim_fpu_32to (&wop1, op1);
	sim_fpu_32to (&wop2, op2);
	status |= (*sim_fpu_op) (&ans, &wop1, &wop2);
	status |= sim_fpu_round_32 (&ans, round, denorm);
	sim_fpu_to32 (&res, &ans);
	result = res;
	break;
      }
    case fmt_double:
      {
	unsigned64 res;
	sim_fpu_64to (&wop1, op1);
	sim_fpu_64to (&wop2, op2);
	status |= (*sim_fpu_op) (&ans, &wop1, &wop2);
	status |= sim_fpu_round_64 (&ans, round, denorm);
	sim_fpu_to64 (&res, &ans);
	result = res;
	break;
      }
    case fmt_ps:
      {
	int status_u = 0, status_l = 0;
	unsigned32 res_u, res_l;
	sim_fpu_32to (&wop1, FP_PS_upper(op1));
	sim_fpu_32to (&wop2, FP_PS_upper(op2));
	status_u |= (*sim_fpu_op) (&ans, &wop1, &wop2);
	sim_fpu_to32 (&res_u, &ans);
	sim_fpu_32to (&wop1, FP_PS_lower(op1));
	sim_fpu_32to (&wop2, FP_PS_lower(op2));
	status_l |= (*sim_fpu_op) (&ans, &wop1, &wop2);
	sim_fpu_to32 (&res_l, &ans);
	result = FP_PS_cat(res_u, res_l);
	status = status_u | status_l;
	break;
      }
    default:
      sim_io_eprintf (SD, "Bad switch\n");
      abort ();
    }

  update_fcsr (cpu, cia, status);
  return result;
}

/* Common MAC code for single operands (.s or .d), defers setting FCSR.  */
static sim_fpu_status
inner_mac(int (*sim_fpu_op)(sim_fpu *, const sim_fpu *, const sim_fpu *),
	  unsigned64 op1,
	  unsigned64 op2,
	  unsigned64 op3,
	  int scale,
	  int negate,
	  FP_formats fmt,
	  sim_fpu_round round,
	  sim_fpu_denorm denorm,
	  unsigned64 *result)
{
  sim_fpu wop1;
  sim_fpu wop2;
  sim_fpu ans;
  sim_fpu_status status = 0;
  sim_fpu_status op_status;
  unsigned64 temp = 0;

  switch (fmt)
    {
    case fmt_single:
      {
	unsigned32 res;
	sim_fpu_32to (&wop1, op1);
	sim_fpu_32to (&wop2, op2);
	status |= sim_fpu_mul (&ans, &wop1, &wop2);
	if (scale != 0 && sim_fpu_is_number (&ans))  /* number or denorm */
	  ans.normal_exp += scale;
	status |= sim_fpu_round_32 (&ans, round, denorm);
	wop1 = ans;
        op_status = 0;
	sim_fpu_32to (&wop2, op3);
	op_status |= (*sim_fpu_op) (&ans, &wop1, &wop2);
	op_status |= sim_fpu_round_32 (&ans, round, denorm);
	status |= op_status;
	if (negate)
	  {
	    wop1 = ans;
	    op_status = sim_fpu_neg (&ans, &wop1);
	    op_status |= sim_fpu_round_32 (&ans, round, denorm);
	    status |= op_status;
	  }
	sim_fpu_to32 (&res, &ans);
	temp = res;
	break;
      }
    case fmt_double:
      {
	unsigned64 res;
	sim_fpu_64to (&wop1, op1);
	sim_fpu_64to (&wop2, op2);
	status |= sim_fpu_mul (&ans, &wop1, &wop2);
	if (scale != 0 && sim_fpu_is_number (&ans))  /* number or denorm */
	  ans.normal_exp += scale;
	status |= sim_fpu_round_64 (&ans, round, denorm);
	wop1 = ans;
        op_status = 0;
	sim_fpu_64to (&wop2, op3);
	op_status |= (*sim_fpu_op) (&ans, &wop1, &wop2);
	op_status |= sim_fpu_round_64 (&ans, round, denorm);
	status |= op_status;
	if (negate)
	  {
	    wop1 = ans;
	    op_status = sim_fpu_neg (&ans, &wop1);
	    op_status |= sim_fpu_round_64 (&ans, round, denorm);
	    status |= op_status;
	  }
	sim_fpu_to64 (&res, &ans);
	temp = res;
	break;
      }
    default:
      fprintf (stderr, "Bad switch\n");
      abort ();
    }
  *result = temp;
  return status;
}

/* Common implementation of madd, nmadd, msub, nmsub that does
   intermediate rounding per spec.  Also used for recip2 and rsqrt2,
   which are transformed into equivalent nmsub operations.  The scale
   argument is an adjustment to the exponent of the intermediate
   product op1*op2.  It is currently non-zero for rsqrt2 (-1), which
   requires an effective division by 2. */
static unsigned64
fp_mac(sim_cpu *cpu,
       address_word cia,
       int (*sim_fpu_op)(sim_fpu *, const sim_fpu *, const sim_fpu *),
       unsigned64 op1,
       unsigned64 op2,
       unsigned64 op3,
       int scale,
       int negate,
       FP_formats fmt)
{
  sim_fpu_round round = rounding_mode (GETRM());
  sim_fpu_denorm denorm = denorm_mode (cpu);
  sim_fpu_status status = 0;
  unsigned64 result = 0;

  /* The format type has already been checked: */
  switch (fmt)
    {
    case fmt_single:
    case fmt_double:
      status = inner_mac(sim_fpu_op, op1, op2, op3, scale,
			 negate, fmt, round, denorm, &result);
      break;
    case fmt_ps:
      {
	int status_u, status_l;
	unsigned64 result_u, result_l;
	status_u = inner_mac(sim_fpu_op, FP_PS_upper(op1), FP_PS_upper(op2),
			     FP_PS_upper(op3), scale, negate, fmt_single,
			     round, denorm, &result_u);
	status_l = inner_mac(sim_fpu_op, FP_PS_lower(op1), FP_PS_lower(op2),
			     FP_PS_lower(op3), scale, negate, fmt_single,
			     round, denorm, &result_l);
	result = FP_PS_cat(result_u, result_l);
	status = status_u | status_l;
	break;
      }
    default:
      sim_io_eprintf (SD, "Bad switch\n");
      abort ();
    }

  update_fcsr (cpu, cia, status);
  return result;
}

/* Common rsqrt code for single operands (.s or .d), intermediate rounding.  */
static sim_fpu_status
inner_rsqrt(unsigned64 op1,
	    FP_formats fmt,
	    sim_fpu_round round,
	    sim_fpu_denorm denorm,
	    unsigned64 *result)
{
  sim_fpu wop1;
  sim_fpu ans;
  sim_fpu_status status = 0;
  sim_fpu_status op_status;
  unsigned64 temp = 0;

  switch (fmt)
    {
    case fmt_single:
      {
	unsigned32 res;
	sim_fpu_32to (&wop1, op1);
	status |= sim_fpu_sqrt (&ans, &wop1);
	status |= sim_fpu_round_32 (&ans, status, round);
	wop1 = ans;
	op_status = sim_fpu_inv (&ans, &wop1);
	op_status |= sim_fpu_round_32 (&ans, round, denorm);
	sim_fpu_to32 (&res, &ans);
	temp = res;
	status |= op_status;
	break;
      }
    case fmt_double:
      {
	unsigned64 res;
	sim_fpu_64to (&wop1, op1);
	status |= sim_fpu_sqrt (&ans, &wop1);
	status |= sim_fpu_round_64 (&ans, round, denorm);
	wop1 = ans;
	op_status = sim_fpu_inv (&ans, &wop1);
	op_status |= sim_fpu_round_64 (&ans, round, denorm);
	sim_fpu_to64 (&res, &ans);
	temp = res;
	status |= op_status;
	break;
      }
    default:
      fprintf (stderr, "Bad switch\n");
      abort ();
    }
  *result = temp;
  return status;
}

static unsigned64
fp_inv_sqrt(sim_cpu *cpu,
	    address_word cia,
	    unsigned64 op1,
	    FP_formats fmt)
{
  sim_fpu_round round = rounding_mode (GETRM());
  sim_fpu_round denorm = denorm_mode (cpu);
  sim_fpu_status status = 0;
  unsigned64 result = 0;

  /* The format type has already been checked: */
  switch (fmt)
    {
    case fmt_single:
    case fmt_double:
      status = inner_rsqrt (op1, fmt, round, denorm, &result);
      break;
    case fmt_ps:
      {
	int status_u, status_l;
	unsigned64 result_u, result_l;
	status_u = inner_rsqrt (FP_PS_upper(op1), fmt_single, round, denorm,
				&result_u);
	status_l = inner_rsqrt (FP_PS_lower(op1), fmt_single, round, denorm,
				&result_l);
	result = FP_PS_cat(result_u, result_l);
	status = status_u | status_l;
	break;
      }
    default:
      sim_io_eprintf (SD, "Bad switch\n");
      abort ();
    }

  update_fcsr (cpu, cia, status);
  return result;
}


unsigned64
fp_abs(sim_cpu *cpu,
       address_word cia,
       unsigned64 op,
       FP_formats fmt)
{
  return fp_unary(cpu, cia, &sim_fpu_abs, op, fmt);
}

unsigned64
fp_neg(sim_cpu *cpu,
       address_word cia,
       unsigned64 op,
       FP_formats fmt)
{
  return fp_unary(cpu, cia, &sim_fpu_neg, op, fmt);
}

unsigned64
fp_add(sim_cpu *cpu,
       address_word cia,
       unsigned64 op1,
       unsigned64 op2,
       FP_formats fmt)
{
  return fp_binary(cpu, cia, &sim_fpu_add, op1, op2, fmt);
}

unsigned64
fp_sub(sim_cpu *cpu,
       address_word cia,
       unsigned64 op1,
       unsigned64 op2,
       FP_formats fmt)
{
  return fp_binary(cpu, cia, &sim_fpu_sub, op1, op2, fmt);
}

unsigned64
fp_mul(sim_cpu *cpu,
       address_word cia,
       unsigned64 op1,
       unsigned64 op2,
       FP_formats fmt)
{
  return fp_binary(cpu, cia, &sim_fpu_mul, op1, op2, fmt);
}

unsigned64
fp_div(sim_cpu *cpu,
       address_word cia,
       unsigned64 op1,
       unsigned64 op2,
       FP_formats fmt)
{
  return fp_binary(cpu, cia, &sim_fpu_div, op1, op2, fmt);
}

unsigned64
fp_recip(sim_cpu *cpu,
         address_word cia,
         unsigned64 op,
         FP_formats fmt)
{
  return fp_unary(cpu, cia, &sim_fpu_inv, op, fmt);
}

unsigned64
fp_sqrt(sim_cpu *cpu,
        address_word cia,
        unsigned64 op,
        FP_formats fmt)
{
  return fp_unary(cpu, cia, &sim_fpu_sqrt, op, fmt);
}

unsigned64
fp_rsqrt(sim_cpu *cpu,
         address_word cia,
         unsigned64 op,
         FP_formats fmt)
{
  return fp_inv_sqrt(cpu, cia, op, fmt);
}

unsigned64
fp_madd(sim_cpu *cpu,
        address_word cia,
        unsigned64 op1,
        unsigned64 op2,
        unsigned64 op3,
        FP_formats fmt)
{
  return fp_mac(cpu, cia, &sim_fpu_add, op1, op2, op3, 0, 0, fmt);
}

unsigned64
fp_msub(sim_cpu *cpu,
        address_word cia,
        unsigned64 op1,
        unsigned64 op2,
        unsigned64 op3,
        FP_formats fmt)
{
  return fp_mac(cpu, cia, &sim_fpu_sub, op1, op2, op3, 0, 0, fmt);
}

unsigned64
fp_nmadd(sim_cpu *cpu,
         address_word cia,
         unsigned64 op1,
         unsigned64 op2,
         unsigned64 op3,
         FP_formats fmt)
{
  return fp_mac(cpu, cia, &sim_fpu_add, op1, op2, op3, 0, 1, fmt);
}

unsigned64
fp_nmsub(sim_cpu *cpu,
         address_word cia,
         unsigned64 op1,
         unsigned64 op2,
         unsigned64 op3,
         FP_formats fmt)
{
  return fp_mac(cpu, cia, &sim_fpu_sub, op1, op2, op3, 0, 1, fmt);
}


/* MIPS-3D ASE operations.  */

/* Variant of fp_binary for *r.ps MIPS-3D operations. */
static unsigned64
fp_binary_r(sim_cpu *cpu,
	    address_word cia,
	    int (*sim_fpu_op)(sim_fpu *, const sim_fpu *, const sim_fpu *),
	    unsigned64 op1,
	    unsigned64 op2) 
{
  sim_fpu wop1;
  sim_fpu wop2;
  sim_fpu ans;
  sim_fpu_round round = rounding_mode (GETRM ());
  sim_fpu_denorm denorm = denorm_mode (cpu);
  sim_fpu_status status_u, status_l;
  unsigned64 result;
  unsigned32 res_u, res_l;

  /* The format must be fmt_ps.  */
  status_u = 0;
  sim_fpu_32to (&wop1, FP_PS_upper (op1));
  sim_fpu_32to (&wop2, FP_PS_lower (op1));
  status_u |= (*sim_fpu_op) (&ans, &wop1, &wop2);
  status_u |= sim_fpu_round_32 (&ans, round, denorm);
  sim_fpu_to32 (&res_u, &ans);
  status_l = 0;
  sim_fpu_32to (&wop1, FP_PS_upper (op2));
  sim_fpu_32to (&wop2, FP_PS_lower (op2));
  status_l |= (*sim_fpu_op) (&ans, &wop1, &wop2);
  status_l |= sim_fpu_round_32 (&ans, round, denorm);
  sim_fpu_to32 (&res_l, &ans);
  result = FP_PS_cat (res_u, res_l);

  update_fcsr (cpu, cia, status_u | status_l);
  return result;
}

unsigned64
fp_add_r(sim_cpu *cpu,
         address_word cia,
         unsigned64 op1,
         unsigned64 op2,
         FP_formats fmt)
{
  return fp_binary_r (cpu, cia, &sim_fpu_add, op1, op2);
}

unsigned64
fp_mul_r(sim_cpu *cpu,
         address_word cia,
         unsigned64 op1,
         unsigned64 op2,
         FP_formats fmt)
{
  return fp_binary_r (cpu, cia, &sim_fpu_mul, op1, op2);
}

#define NR_FRAC_GUARD   (60)
#define IMPLICIT_1 LSBIT64 (NR_FRAC_GUARD)

static int
fpu_inv1(sim_fpu *f, const sim_fpu *l)
{
  static const sim_fpu sim_fpu_one = {
    sim_fpu_class_number, 0, IMPLICIT_1, 0
  };
  int  status = 0;
  sim_fpu t;

  if (sim_fpu_is_zero (l))
    {
      *f = sim_fpu_maxfp;
      f->sign = l->sign;
      return sim_fpu_status_invalid_div0;
    }
  if (sim_fpu_is_infinity (l))
    {
      *f = sim_fpu_zero;
      f->sign = l->sign;
      return status;
    }
  status |= sim_fpu_div (f, &sim_fpu_one, l);
  return status;
}

static int
fpu_inv1_32(sim_fpu *f, const sim_fpu *l)
{
  if (sim_fpu_is_zero (l))
    {
      *f = sim_fpu_max32;
      f->sign = l->sign;
      return sim_fpu_status_invalid_div0;
    }
  return fpu_inv1 (f, l);
}

static int
fpu_inv1_64(sim_fpu *f, const sim_fpu *l)
{
  if (sim_fpu_is_zero (l))
    {
      *f = sim_fpu_max64;
      f->sign = l->sign;
      return sim_fpu_status_invalid_div0;
    }
  return fpu_inv1 (f, l);
}

unsigned64
fp_recip1(sim_cpu *cpu,
          address_word cia,
          unsigned64 op,
          FP_formats fmt)
{
  switch (fmt)
    {
    case fmt_single:
    case fmt_ps:
      return fp_unary (cpu, cia, &fpu_inv1_32, op, fmt);
    case fmt_double:
      return fp_unary (cpu, cia, &fpu_inv1_64, op, fmt);
    }
  return 0;
}

unsigned64
fp_recip2(sim_cpu *cpu,
          address_word cia,
          unsigned64 op1,
          unsigned64 op2,
          FP_formats fmt)
{
  static const unsigned64 one_single = UNSIGNED64 (0x3F800000);
  static const unsigned64 one_double = UNSIGNED64 (0x3FF0000000000000);
  static const unsigned64 one_ps = (UNSIGNED64 (0x3F800000) << 32 | UNSIGNED64 (0x3F800000));
  unsigned64 one;

  /* Implemented as nmsub fd, 1, fs, ft.  */
  switch (fmt)
    {
    case fmt_single:  one = one_single;  break;
    case fmt_double:  one = one_double;  break;
    case fmt_ps:      one = one_ps;      break;
    default:          one = 0;           abort ();
    }
  return fp_mac (cpu, cia, &sim_fpu_sub, op1, op2, one, 0, 1, fmt);
}

static int
fpu_inv_sqrt1(sim_fpu *f, const sim_fpu *l)
{
  static const sim_fpu sim_fpu_one = {
    sim_fpu_class_number, 0, IMPLICIT_1, 0
  };
  int  status = 0;
  sim_fpu t;

  if (sim_fpu_is_zero (l))
    {
      *f = sim_fpu_maxfp;
      f->sign = l->sign;
      return sim_fpu_status_invalid_div0;
    }
  if (sim_fpu_is_infinity (l))
    {
      if (!l->sign)
	{
	  f->class = sim_fpu_class_zero;
	  f->sign = 0;
	}
      else
	{
	  *f = sim_fpu_qnan;
	  status = sim_fpu_status_invalid_sqrt;
	}
      return status;
    }
  status |= sim_fpu_sqrt (&t, l);
  status |= sim_fpu_div (f, &sim_fpu_one, &t);
  return status;
}

static int
fpu_inv_sqrt1_32(sim_fpu *f, const sim_fpu *l)
{
  if (sim_fpu_is_zero (l))
    {
      *f = sim_fpu_max32;
      f->sign = l->sign;
      return sim_fpu_status_invalid_div0;
    }
  return fpu_inv_sqrt1 (f, l);
}

static int
fpu_inv_sqrt1_64(sim_fpu *f, const sim_fpu *l)
{
  if (sim_fpu_is_zero (l))
    {
      *f = sim_fpu_max64;
      f->sign = l->sign;
      return sim_fpu_status_invalid_div0;
    }
  return fpu_inv_sqrt1 (f, l);
}

unsigned64
fp_rsqrt1(sim_cpu *cpu,
          address_word cia,
          unsigned64 op,
          FP_formats fmt)
{
  switch (fmt)
    {
    case fmt_single:
    case fmt_ps:
      return fp_unary (cpu, cia, &fpu_inv_sqrt1_32, op, fmt);
    case fmt_double:
      return fp_unary (cpu, cia, &fpu_inv_sqrt1_64, op, fmt);
    }
  return 0;
}

unsigned64
fp_rsqrt2(sim_cpu *cpu,
          address_word cia,
          unsigned64 op1,
          unsigned64 op2,
          FP_formats fmt)
{
  static const unsigned64 half_single = UNSIGNED64 (0x3F000000);
  static const unsigned64 half_double = UNSIGNED64 (0x3FE0000000000000);
  static const unsigned64 half_ps = (UNSIGNED64 (0x3F000000) << 32 | UNSIGNED64 (0x3F000000));
  unsigned64 half;

  /* Implemented as (nmsub fd, 0.5, fs, ft)/2, where the divide is
     done by scaling the exponent during multiply.  */
  switch (fmt)
    {
    case fmt_single:  half = half_single;  break;
    case fmt_double:  half = half_double;  break;
    case fmt_ps:      half = half_ps;      break;
    default:          half = 0;            abort ();
    }
  return fp_mac (cpu, cia, &sim_fpu_sub, op1, op2, half, -1, 1, fmt);
}


/* Conversion operations.  */

uword64
convert (sim_cpu *cpu,
	 address_word cia,
	 int rm,
	 uword64 op,
	 FP_formats from,
	 FP_formats to)
{
  sim_fpu wop;
  sim_fpu_round round = rounding_mode (rm);
  sim_fpu_denorm denorm = denorm_mode (cpu);
  unsigned32 result32;
  unsigned64 result64;
  sim_fpu_status status = 0;

  /* Convert the input to sim_fpu internal format */
  switch (from)
    {
    case fmt_double:
      sim_fpu_64to (&wop, op);
      break;
    case fmt_single:
      sim_fpu_32to (&wop, op);
      break;
    case fmt_word:
      status = sim_fpu_i32to (&wop, op, round);
      break;
    case fmt_long:
      status = sim_fpu_i64to (&wop, op, round);
      break;
    default:
      sim_io_eprintf (SD, "Bad switch\n");
      abort ();
    }

  /* Convert sim_fpu format into the output */
  /* The value WOP is converted to the destination format, rounding
     using mode RM. When the destination is a fixed-point format, then
     a source value of Infinity, NaN or one which would round to an
     integer outside the fixed point range then an IEEE Invalid Operation
     condition is raised.  Not used if destination format is PS.  */
  switch (to)
    {
    case fmt_single:
      status |= sim_fpu_round_32 (&wop, round, denorm);
      /* For a NaN, normalize mantissa bits (cvt.s.d can't preserve them) */
      if (sim_fpu_is_qnan (&wop))
	wop = sim_fpu_qnan;
      sim_fpu_to32 (&result32, &wop);
      result64 = result32;
      break;
    case fmt_double:
      status |= sim_fpu_round_64 (&wop, round, denorm);
      /* For a NaN, normalize mantissa bits (make cvt.d.s consistent) */
      if (sim_fpu_is_qnan (&wop))
	wop = sim_fpu_qnan;
      sim_fpu_to64 (&result64, &wop);
      break;
    case fmt_word:
      status |= sim_fpu_to32i (&result32, &wop, round);
      result64 = result32;
      break;
    case fmt_long:
      status |= sim_fpu_to64i (&result64, &wop, round);
      break;
    default:
      result64 = 0;
      sim_io_eprintf (SD, "Bad switch\n");
      abort ();
    }

  update_fcsr (cpu, cia, status);
  return result64;
}

unsigned64
ps_lower(sim_cpu *cpu,
         address_word cia,
         unsigned64 op)
{
  return FP_PS_lower (op);
}

unsigned64
ps_upper(sim_cpu *cpu,
         address_word cia,
         unsigned64 op)
{
  return FP_PS_upper(op);
}

unsigned64
pack_ps(sim_cpu *cpu,
        address_word cia,
        unsigned64 op1,
        unsigned64 op2,
        FP_formats fmt)
{
  unsigned64 result = 0;

  /* The registers must specify FPRs valid for operands of type
     "fmt". If they are not valid, the result is undefined. */

  /* The format type should already have been checked: */
  switch (fmt)
    {
    case fmt_single:
      {
	sim_fpu wop;
	unsigned32 res_u, res_l;
	sim_fpu_32to (&wop, op1);
	sim_fpu_to32 (&res_u, &wop);
	sim_fpu_32to (&wop, op2);
	sim_fpu_to32 (&res_l, &wop);
	result = FP_PS_cat(res_u, res_l);
	break;
      }
    default:
      sim_io_eprintf (SD, "Bad switch\n");
      abort ();
    }

  return result;
}

unsigned64
convert_ps (sim_cpu *cpu,
            address_word cia,
            int rm,
            unsigned64 op,
            FP_formats from,
            FP_formats to)
{
  sim_fpu wop_u, wop_l;
  sim_fpu_round round = rounding_mode (rm);
  sim_fpu_denorm denorm = denorm_mode (cpu);
  unsigned32 res_u, res_l;
  unsigned64 result;
  sim_fpu_status status_u = 0, status_l = 0;

  /* As convert, but used only for paired values (formats PS, PW) */

  /* Convert the input to sim_fpu internal format */
  switch (from)
    {
    case fmt_word:   /* fmt_pw */
      sim_fpu_i32to (&wop_u, (op >> 32) & (unsigned)0xFFFFFFFF, round);
      sim_fpu_i32to (&wop_l, op & (unsigned)0xFFFFFFFF, round);
      break;
    case fmt_ps:
      sim_fpu_32to (&wop_u, FP_PS_upper(op));
      sim_fpu_32to (&wop_l, FP_PS_lower(op));
      break;
    default:
      sim_io_eprintf (SD, "Bad switch\n");
      abort ();
    }

  /* Convert sim_fpu format into the output */
  switch (to)
    {
    case fmt_word:   /* fmt_pw */
      status_u |= sim_fpu_to32i (&res_u, &wop_u, round);
      status_l |= sim_fpu_to32i (&res_l, &wop_l, round);
      result = (((unsigned64)res_u) << 32) | (unsigned64)res_l;
      break;
    case fmt_ps:
      status_u |= sim_fpu_round_32 (&wop_u, 0, round);
      status_l |= sim_fpu_round_32 (&wop_l, 0, round);
      sim_fpu_to32 (&res_u, &wop_u);
      sim_fpu_to32 (&res_l, &wop_l);
      result = FP_PS_cat(res_u, res_l);
      break;
    default:
      result = 0;
      sim_io_eprintf (SD, "Bad switch\n");
      abort ();
    }

  update_fcsr (cpu, cia, status_u | status_l);
  return result;
}

static const char *
fpu_format_name (FP_formats fmt)
{
  switch (fmt)
    {
    case fmt_single:
      return "single";
    case fmt_double:
      return "double";
    case fmt_word:
      return "word";
    case fmt_long:
      return "long";
    case fmt_ps:
      return "ps";
    case fmt_unknown:
      return "<unknown>";
    case fmt_uninterpreted:
      return "<uninterpreted>";
    case fmt_uninterpreted_32:
      return "<uninterpreted_32>";
    case fmt_uninterpreted_64:
      return "<uninterpreted_64>";
    default:
      return "<format error>";
    }
}

#ifdef DEBUG
static const char *
fpu_rounding_mode_name (int rm)
{
  switch (rm)
    {
    case FP_RM_NEAREST:
      return "Round";
    case FP_RM_TOZERO:
      return "Trunc";
    case FP_RM_TOPINF:
      return "Ceil";
    case FP_RM_TOMINF:
      return "Floor";
    default:
      return "<rounding mode error>";
    }
}
#endif /* DEBUG */
@


1.28
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright (C) 2002, 2007-2012 Free Software Foundation, Inc.
@


1.27
log
@run copyright.sh for 2011.
@
text
@d3 1
a3 2
   Copyright (C) 2002, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.27.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 2002, 2007-2012 Free Software Foundation, Inc.
@


1.26
log
@Update copyright notices to add year 2010.
@
text
@d3 2
a4 1
   Copyright (C) 2002, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.25
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d3 1
a3 1
   Copyright (C) 2002, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.24
log
@	Updated copyright notices for most files.
@
text
@d3 1
a3 1
   Copyright (C) 2002, 2007, 2008 Free Software Foundation, Inc.
@


1.23
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d3 1
a3 1
   Copyright (C) 2002, 2007 Free Software Foundation, Inc.
@


1.22
log
@	* cp1.c (value_fpr): Don't inherit existing FPR_STATE for
	uninterpreted formats. If fmt is one of the uninterpreted types
	don't update the FPR_STATE. Handle fmt_uninterpreted_32 like
	fmt_word, and fmt_uninterpreted_64 like fmt_long.
	(store_fpr): When writing an invalid odd register, set the
	matching even register to fmt_unknown, not the following register.
	* interp.c (sim_open): If STATE_MEM_SIZE isn't set then set it to
	the the memory window at offset 0 set by --memory-size command
	line option.
	(sim_store_register): Handle storing 4 bytes to an 8 byte floating
	point register.
	(sim_fetch_register): Likewise for reading 4 bytes from an 8 byte
	register.
	(sim_monitor): When returning the memory size to the MIPS
	application, use the value in STATE_MEM_SIZE, not an arbitrary
	hardcoded value.
	(cop_lw): Don' mess around with FPR_STATE, just pass
	fmt_uninterpreted_32 to StoreFPR.
	(cop_sw): Similarly.
	(cop_ld): Pass fmt_uninterpreted_64 not fmt_uninterpreted.
	(cop_sd): Similarly.
	* mips.igen (not_word_value): Single version for mips32, mips64
	and mips16.
@
text
@d13 2
a14 2
the Free Software Foundation; either version 2, or (at your option)
any later version.
d21 2
a22 3
You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.21
log
@Copyright updates for 2007.
@
text
@d114 1
a114 1
  if ((fmt == fmt_uninterpreted) || (fmt == fmt_unknown))
d117 1
a117 1
      /* If request to read data as "uninterpreted", then use the current
d126 1
a126 1
  if (FPR_STATE[fpr] == fmt_uninterpreted)
d128 3
a130 1
      FPR_STATE[fpr] = fmt;
d132 2
a133 2
      printf ("DBG: Register %d was fmt_uninterpreted. Now %s\n", fpr,
	      fpu_format_name (fmt));
d135 8
a142 7
    }
  if (fmt != FPR_STATE[fpr])
    {
      sim_io_eprintf (SD, "FPR %d (format %s) being accessed with format %s - setting to unknown (PC = 0x%s)\n",
		      fpr, fpu_format_name (FPR_STATE[fpr]),
		      fpu_format_name (fmt), pr_addr (cia));
      FPR_STATE[fpr] = fmt_unknown;
d162 1
d168 1
d185 1
d191 1
d309 1
a309 1
	      FPR_STATE[fpr + 1] = fmt_unknown;
@


1.20
log
@[igen/ChangeLog]
2003-05-03  Chris Demetriou  <cgd@@broadcom.com>

        * compare_igen_models: Tweak attribution slightly.

[mips/ChangeLog]
2003-05-03  Chris Demetriou  <cgd@@broadcom.com>

        * cp1.c: Tweak attribution slightly.
        * cp1.h: Likewise.
        * mdmx.c: Likewise.
        * mdmx.igen: Likewise.
        * mips3d.igen: Likewise.
        * sb1.igen: Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2002 Free Software Foundation, Inc.
@


1.19
log
@2002-07-29  Michael Snyder  <msnyder@@redhat.com>

	* cp1.c (fp_recip2): Modify initialization expression so that
	GCC will recognize it as constant.
@
text
@d4 4
a7 3
   Originally created by Cygnus Solutions, modified substially
   by Broadcom Corporation (SiByte).  Paired-single operation support
   and MIPS-3D support contributed by Broadcom Corporation (SiByte).
@


1.19.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d4 3
a6 4
   Originally created by Cygnus Solutions.  Extensive modifications,
   including paired-single operation support and MIPS-3D support
   contributed by Ed Satterthwaite and Chris Demetriou, of Broadcom
   Corporation (SiByte).
@


1.19.8.1
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d4 3
a6 4
   Originally created by Cygnus Solutions.  Extensive modifications,
   including paired-single operation support and MIPS-3D support
   contributed by Ed Satterthwaite and Chris Demetriou, of Broadcom
   Corporation (SiByte).
@


1.19.30.1
log
@Merge from mainline.
@
text
@d4 3
a6 4
   Originally created by Cygnus Solutions.  Extensive modifications,
   including paired-single operation support and MIPS-3D support
   contributed by Ed Satterthwaite and Chris Demetriou, of Broadcom
   Corporation (SiByte).
@


1.18
log
@2002-06-14  Chris Demetriou  <cgd@@broadcom.com>
            Ed Satterthwaite  <ehs@@broadcom.com>

	* mips3d.igen: New file which contains MIPS-3D ASE instructions.
	* Makefile.in (IGEN_INCLUDE): Add mips3d.igen.
	* mips.igen: Include mips3d.igen.
	(mips3d): New model name for MIPS-3D ASE instructions.
	(CVT.W.fmt): Don't use this instruction for word (source) format
	instructions.
	* cp1.c (fp_binary_r, fp_add_r, fp_mul_r, fpu_inv1, fpu_inv1_32)
	(fpu_inv1_64, fp_recip1, fp_recip2, fpu_inv_sqrt1, fpu_inv_sqrt1_32)
	(fpu_inv_sqrt1_64, fp_rsqrt1, fp_rsqrt2): New functions.
	(NR_FRAC_GUARD, IMPLICIT_1): New macros.
	* sim-main.h (fmt_pw, CompareAbs, AddR, MultiplyR, Recip1, Recip2)
	(RSquareRoot1, RSquareRoot2): New macros.
	(fp_add_r, fp_mul_r, fp_recip1, fp_recip2, fp_rsqrt1)
	(fp_rsqrt2): New functions.
	* configure.in: Add MIPS-3D support to mipsisa64 simulator.
	* configure: Regenerate.
@
text
@d1238 1
a1238 1
  static const unsigned64 one_ps = (one_single << 32 | one_single);
d1336 1
a1336 1
  static const unsigned64 half_ps = (half_single << 32 | half_single);
@


1.17
log
@2002-06-13  Chris Demetriou  <cgd@@broadcom.com>

	* cp1.c (FP_PS_upper, FP_PS_lower, FP_PS_cat, FPQNaN_PS): New macros.
	(value_fpr, store_fpr, fp_cmp, fp_unary, fp_binary, fp_mac)
	(fp_inv_sqrt, fpu_format_name): Add paired-single support.
	(convert): Note that this function is not used for paired-single
	format conversions.
	(ps_lower, ps_upper, pack_ps, convert_ps): New functions.
	* mips.igen (FMT, MOVtf.fmt): Add paired-single support.
	(check_fmt_p): Enable paired-single support.
	(ALNV.PS, CVT.PS.S, CVT.S.PL, CVT.S.PU, PLL.PS, PLU.PS, PUL.PS)
	(PUU.PS): New instructions.
	(CVT.S.fmt): Don't use this instruction for paired-single format
	destinations.
	* sim-main.h (FP_formats): New value 'fmt_ps.'
	(ps_lower, ps_upper, pack_ps, convert_ps): New prototypes.
	(PSLower, PSUpper, PackPS, ConvertPS): New macros.
@
text
@d5 2
a6 1
   by Broadcom Corporation (SiByte).
d1099 250
@


1.16
log
@2002-06-07  Chris Demetriou  <cgd@@broadcom.com>
            Ed Satterthwaite  <ehs@@broadcom.com>

	* cp1.c (inner_mac, fp_mac, inner_rsqrt, fp_inv_sqrt)
	(fp_rsqrt, fp_madd, fp_msub, fp_nmadd, fp_nmsub): New functions.
	* sim-main.h (fp_rsqrt, fp_madd, fp_msub, fp_nmadd)
	(fp_nmsub): New prototypes.
	(RSquareRoot, MultiplyAdd, MultiplySub, NegMultiplyAdd)
	(NegMultiplySub): New defines.
	* mips.igen (RSQRT.fmt): Use RSquareRoot().
	(MADD.D, MADD.S): Replace with...
	(MADD.fmt): New instruction.
	(MSUB.D, MSUB.S): Replace with...
	(MSUB.fmt): New instruction.
	(NMADD.D, NMADD.S): Replace with...
	(NMADD.fmt): New instruction.
	(NMSUB.D, MSUB.S): Replace with...
	(NMSUB.fmt): New instruction.
@
text
@d74 8
d84 6
d95 1
d149 1
d165 1
d203 4
d261 1
d305 5
d597 12
d655 14
d719 16
d856 14
d949 12
d1142 2
a1143 2
     integer outside the fixed point range then an IEEE Invalid
     Operation condition is raised.  */
d1178 108
d1299 2
@


1.15
log
@2002-06-07  Chris Demetriou  <cgd@@broadcom.com>
            Ed Satterthwaite  <ehs@@broadcom.com>

        * cp1.c: Fix more comment spelling and formatting.
        (value_fcr, store_fcr): Use fenr_FS rather than hard-coding value.
        (denorm_mode): New function.
        (fpu_unary, fpu_binary): Round results after operation, collect
        status from rounding operations, and update the FCSR.
        (convert): Collect status from integer conversions and rounding
        operations, and update the FCSR.  Adjust NaN values that result
        from conversions.  Convert to use sim_io_eprintf rather than
        fprintf, and remove some debugging code.
        * cp1.h (fenr_FS): New define.
@
text
@d675 200
d950 53
@


1.14
log
@2002-06-07  Chris Demetriou  <cgd@@broadcom.com>

	* cp1.c (convert): Remove unusable debugging code, and move MIPS
	rounding mode to sim FP rounding mode flag conversion code into...
	(rounding_mode): New function.
@
text
@d76 1
a76 1
/* Explicit QNaN values used when value required:  */
d96 1
a96 1
  /* Treat unused register values, as fixed-point 64bit values:  */
d108 1
a108 1
  /* For values not yet accessed, set to the desired format:  */
d171 1
a171 1
	      /* Even registers numbers only.  */
d302 1
a302 1
/* CP1 control/status registers */
d327 1
a327 1
    case 0:  /* FP Implementation and Revision Register */
d330 1
a330 1
    case 25:  /* FP Condition Codes Register */
d332 1
a332 1
      value = (value & 0x1) | (value >> 1);   /* close FCC gap */
d334 1
a334 1
    case 26:  /* FP Exceptions Register */
d337 1
a337 1
    case 28:  /* FP Enables Register */
d339 2
a340 2
      if (FCR31 & fcsr_FS)
	value |= 0x4;                        /* nonstandard FS bit */
d342 1
a342 1
    case 31:  /* FP Control/Status Register */
d361 2
a362 2
    case 25:  /* FP Condition Codes Register */
      v = (v << 1) | (v & 0x1);             /* adjust for FCC gap */
d366 1
a366 1
    case 26:  /* FP Exceptions Register */
d371 2
a372 2
    case 28:  /* FP Enables Register */
      if (v & 0x4)                         /* nonstandard FS bit */
d380 1
a380 1
    case 31:  /* FP Control/Status Register */
d417 1
a417 1
      /* Implicit clearing of other bits by unimplemented done by callers. */
d439 1
a439 1
	 that has a least significant bit of zero (i.e. is even). */
d444 1
a444 1
	 magnitude than, the result. */
d449 1
a449 1
	 the result. */
d454 1
a454 1
	 the result. */
d465 17
d556 3
a558 1
  /* The format type should already have been checked: */
d588 3
d600 2
a601 1
	(*sim_fpu_op) (&ans, &wop);
d610 2
a611 1
	(*sim_fpu_op) (&ans, &wop);
d621 1
d636 3
d649 2
a650 1
	(*sim_fpu_op) (&ans, &wop1, &wop2);
d660 2
a661 1
	(*sim_fpu_op) (&ans, &wop1, &wop2);
d671 1
d765 1
d768 1
d780 1
a780 1
      sim_fpu_i32to (&wop, op, round);
d783 1
a783 1
      sim_fpu_i64to (&wop, op, round);
d786 1
a786 1
      fprintf (stderr, "Bad switch\n");
d799 4
a802 1
      sim_fpu_round_32 (&wop, round, 0);
d807 4
a810 1
      sim_fpu_round_64 (&wop, round, 0);
d814 1
a814 1
      sim_fpu_to32i (&result32, &wop, round);
d818 1
a818 1
      sim_fpu_to64i (&result64, &wop, round);
d822 1
a822 1
      fprintf (stderr, "Bad switch\n");
d826 2
a827 6
#ifdef DEBUG
  printf ("DBG: Convert: returning 0x%s (to format = %s)\n",
	  pr_addr (result64), fpu_format_name (to));
#endif /* DEBUG */

  return (result64);
@


1.13
log
@2002-06-07  Chris Demetriou  <cgd@@broadcom.com>

	* cp1.c: Clean up formatting of a few comments.
	(value_fpr): Reformat switch statement.
@
text
@d429 36
d733 1
a733 1
  sim_fpu_round round;
a735 38

#ifdef DEBUG
#if 0 /* FIXME: doesn't compile */
  printf ("DBG: Convert: mode %s : op 0x%s : from %s : to %s : (PC = 0x%s)\n",
	  fpu_rounding_mode_name (rm), pr_addr (op), fpu_format_name (from),
	  fpu_format_name (to), pr_addr (IPC));
#endif
#endif /* DEBUG */

  switch (rm)
    {
    case FP_RM_NEAREST:
      /* Round result to nearest representable value. When two
	 representable values are equally near, round to the value
	 that has a least significant bit of zero (i.e. is even).  */
      round = sim_fpu_round_near;
      break;
    case FP_RM_TOZERO:
      /* Round result to the value closest to, and not greater in
	 magnitude than, the result.  */
      round = sim_fpu_round_zero;
      break;
    case FP_RM_TOPINF:
      /* Round result to the value closest to, and not less than,
	 the result.  */
      round = sim_fpu_round_up;
      break;

    case FP_RM_TOMINF:
      /* Round result to the value closest to, and not greater than,
	 the result.  */
      round = sim_fpu_round_down;
      break;
    default:
      round = 0;
      fprintf (stderr, "Bad switch\n");
      abort ();
    }
@


1.12
log
@2002-06-06  Chris Demetriou  <cgd@@broadcom.com>
            Ed Satterthwaite  <ehs@@broadcom.com>

	* cp1.h: New file.
	* sim-main.h: Include cp1.h.
	(SETFCC, GETFCC, IR, UF, OF, DX, IO, UO, FP_FLAGS, FP_ENABLE)
	(FP_CAUSE, GETFS, FP_RM_NEAREST, FP_RM_TOZERO, FP_RM_TOPINF)
	(FP_RM_TOMINF, GETRM): Remove.  Moved to cp1.h.
	(FP_FS, FP_MASK_RM, FP_SH_RM, Nan, Less, Equal): Remove.
	(value_fcr, store_fcr, test_fcsr, fp_cmp): New prototypes.
	(ValueFCR, StoreFCR, TestFCSR, Compare): New macros.
	* cp1.c: Don't include sim-fpu.h; already included by
	sim-main.h.  Clean up formatting of some comments.
	(NaN, Equal, Less): Remove.
	(test_fcsr, value_fcr, store_fcr, update_fcsr, fp_test)
	(fp_cmp): New functions.
	* mips.igen (do_c_cond_fmt): Remove.
	(C.cond.fmta, C.cond.fmtb): Replace uses of do_c_cond_fmt_a with
	Compare.  Add result tracing.
	(CxC1): Remove, replace with...
	(CFC1a, CFC1b, CFC1c, CTC1a, CTC1b, CTC1c): New instructions.
	(DMxC1): Remove, replace with...
	(DMFC1a, DMFC1b, DMTC1a, DMTC1b): New instructions.
	(MxC1): Remove, replace with...
	(MFC1a, MFC1b, MTC1a, MTC1b): New instructions.
@
text
@d130 5
a134 19
	case fmt_single:
	  value = FPQNaN_SINGLE;
	  break;

	case fmt_double:
	  value = FPQNaN_DOUBLE;
	  break;

	case fmt_word:
	  value = FPQNaN_WORD;
	  break;

	case fmt_long:
	  value = FPQNaN_LONG;
	  break;

	default:
	  err = -1;
	  break;
d171 1
a171 1
	      /* even registers only */
d269 1
a269 1
	      /* even register number only */
@


1.11
log
@2002-06-04  Chris Demetriou  <cgd@@broadcom.com>

        * cp1.c: Add an FSF Copyright notice to this file.
@
text
@a42 1
#include "sim-fpu.h"
d315 6
a320 4
int
NaN (op, fmt)
     uword64 op;
     FP_formats fmt;
d322 5
a326 2
  int boolean = 0;
  switch (fmt)
d328 1
a328 19
    case fmt_single:
    case fmt_word:
      {
	sim_fpu wop;
	sim_fpu_32to (&wop, op);
	boolean = sim_fpu_is_nan (&wop);
	break;
      }
    case fmt_double:
    case fmt_long:
      {
	sim_fpu wop;
	sim_fpu_64to (&wop, op);
	boolean = sim_fpu_is_nan (&wop);
	break;
      }
    default:
      fprintf (stderr, "Bad switch\n");
      abort ();
d330 1
d332 28
a359 4
#ifdef DEBUG
  printf ("DBG: NaN: returning %d for 0x%s (format = %s)\n",
	  boolean, pr_addr (op), fpu_format_name (fmt));
#endif /* DEBUG */
d361 1
a361 1
  return (boolean);
d364 5
a368 5
int
Less (op1, op2, fmt)
     uword64 op1;
     uword64 op2;
     FP_formats fmt;
d370 73
a442 1
  int boolean = 0;
d444 1
a444 1
  /* Argument checking already performed by the FPCOMPARE code */
d446 12
a457 4
#ifdef DEBUG
  printf ("DBG: Less: %s: op1 = 0x%s : op2 = 0x%s\n",
	  fpu_format_name (fmt), pr_addr (op1), pr_addr (op2));
#endif /* DEBUG */
d459 1
a459 1
  /* The format type should already have been checked:  */
a463 2
	sim_fpu wop1;
	sim_fpu wop2;
a465 1
	boolean = sim_fpu_is_lt (&wop1, &wop2);
a469 2
	sim_fpu wop1;
	sim_fpu wop2;
a471 1
	boolean = sim_fpu_is_lt (&wop1, &wop2);
d479 24
a502 6
#ifdef DEBUG
  printf ("DBG: Less: returning %d (format = %s)\n",
	  boolean, fpu_format_name (fmt));
#endif /* DEBUG */

  return (boolean);
d505 9
a513 5
int
Equal (op1, op2, fmt)
     uword64 op1;
     uword64 op2;
     FP_formats fmt;
d515 1
a515 8
  int boolean = 0;

  /* Argument checking already performed by the FPCOMPARE code */

#ifdef DEBUG
  printf ("DBG: Equal: %s: op1 = 0x%s : op2 = 0x%s\n",
	  fpu_format_name (fmt), pr_addr (op1), pr_addr (op2));
#endif /* DEBUG */
d517 1
a517 1
  /* The format type should already have been checked:  */
a520 8
      {
	sim_fpu wop1;
	sim_fpu wop2;
	sim_fpu_32to (&wop1, op1);
	sim_fpu_32to (&wop2, op2);
	boolean = sim_fpu_is_eq (&wop1, &wop2);
	break;
      }
d523 4
a526 5
	sim_fpu wop1;
	sim_fpu wop2;
	sim_fpu_64to (&wop1, op1);
	sim_fpu_64to (&wop2, op2);
	boolean = sim_fpu_is_eq (&wop1, &wop2);
d530 1
a530 1
      fprintf (stderr, "Bad switch\n");
a532 7

#ifdef DEBUG
  printf ("DBG: Equal: returning %d (format = %s)\n",
	  boolean, fpu_format_name (fmt));
#endif /* DEBUG */

  return (boolean);
d699 2
@


1.10
log
@2002-06-04  Chris Demetriou  <cgd@@broadcom.com>
            Ed Satterthwaite  <ehs@@broadcom.com>

        * cp1.c (Infinity): Remove.
        * sim-main.h (Infinity): Likewise.

        * cp1.c (fp_unary, fp_binary): New functions.
        (fp_abs, fp_neg, fp_add, fp_sub, fp_mul, fp_div, fp_recip)
        (fp_sqrt): New functions, implemented in terms of the above.
        (AbsoluteValue, Negate, Add, Sub, Multiply, Divide)
        (Recip, SquareRoot): Remove (replaced by functions above).
        * sim-main.h (fp_abs, fp_neg, fp_add, fp_sub, fp_mul, fp_div)
        (fp_recip, fp_sqrt): New prototypes.
        (AbsoluteValue, Negate, Add, Sub, Multiply, Divide)
        (Recip, SquareRoot): Replace prototypes with #defines which
        invoke the functions above.
@
text
@d2 22
d29 1
@


1.9
log
@2002-06-03  Chris Demetriou  <cgd@@broadcom.com>

        * sim-main.h (Nan, Infinity, Less, Equal, AbsoluteValue, Negate)
        (Add, Sub, Multiply, Divide, Recip, SquareRoot): Move lower in
        file, remove PARAMS from prototypes.
        (value_fpr, store_fpr, convert): Likewise.  Use SIM_STATE to provide
        simulator state arguments.
        (ValueFPR, StoreFPR, Convert): Move lower in file.  Use SIM_ARGS to
        pass simulator state arguments.
        * cp1.c (SD): Redefine as CPU_STATE(cpu).
        (store_fpr, convert): Remove 'sd' argument.
        (value_fpr): Likewise.  Convert to use 'SD' instead.
@
text
@a330 42
Infinity (op, fmt)
     uword64 op;
     FP_formats fmt;
{
  int boolean = 0;

#ifdef DEBUG
  printf ("DBG: Infinity: format %s 0x%s\n",
	  fpu_format_name (fmt), pr_addr (op));
#endif /* DEBUG */

  switch (fmt)
    {
    case fmt_single:
      {
	sim_fpu wop;
	sim_fpu_32to (&wop, op);
	boolean = sim_fpu_is_infinity (&wop);
	break;
      }
    case fmt_double:
      {
	sim_fpu wop;
	sim_fpu_64to (&wop, op);
	boolean = sim_fpu_is_infinity (&wop);
	break;
      }
    default:
      printf ("DBG: TODO: unrecognised format (%s) for Infinity check\n",
	      fpu_format_name (fmt));
      break;
    }

#ifdef DEBUG
  printf ("DBG: Infinity: returning %d for 0x%s (format = %s)\n",
	  boolean, pr_addr (op), fpu_format_name (fmt));
#endif /* DEBUG */

  return (boolean);
}

int
a427 39
uword64
AbsoluteValue (op, fmt)
     uword64 op;
     FP_formats fmt;
{
  uword64 result = 0;

#ifdef DEBUG
  printf ("DBG: AbsoluteValue: %s: op = 0x%s\n",
	  fpu_format_name (fmt), pr_addr (op));
#endif /* DEBUG */

  /* The format type should already have been checked:  */
  switch (fmt)
    {
    case fmt_single:
      {
	sim_fpu wop;
	unsigned32 ans;
	sim_fpu_32to (&wop, op);
	sim_fpu_abs (&wop, &wop);
	sim_fpu_to32 (&ans, &wop);
	result = ans;
	break;
      }
    case fmt_double:
      {
	sim_fpu wop;
	unsigned64 ans;
	sim_fpu_64to (&wop, op);
	sim_fpu_abs (&wop, &wop);
	sim_fpu_to64 (&ans, &wop);
	result = ans;
	break;
      }
    default:
      fprintf (stderr, "Bad switch\n");
      abort ();
    }
d429 1
a429 2
  return (result);
}
d431 10
a440 11
uword64
Negate (op, fmt)
     uword64 op;
     FP_formats fmt;
{
  uword64 result = 0;

#ifdef DEBUG
  printf ("DBG: Negate: %s: op = 0x%s\n",
	  fpu_format_name (fmt), pr_addr (op));
#endif /* DEBUG */
d442 1
a442 1
  /* The format type should already have been checked:  */
d447 1
a447 2
	sim_fpu wop;
	unsigned32 ans;
d449 3
a451 3
	sim_fpu_neg (&wop, &wop);
	sim_fpu_to32 (&ans, &wop);
	result = ans;
d456 1
a456 2
	sim_fpu wop;
	unsigned64 ans;
d458 3
a460 3
	sim_fpu_neg (&wop, &wop);
	sim_fpu_to64 (&ans, &wop);
	result = ans;
d464 1
a464 1
      fprintf (stderr, "Bad switch\n");
d468 1
a468 1
  return (result);
d471 12
a482 7
uword64
Add (op1, op2, fmt)
     uword64 op1;
     uword64 op2;
     FP_formats fmt;
{
  uword64 result = 0;
d484 1
a484 9
#ifdef DEBUG
  printf ("DBG: Add: %s: op1 = 0x%s : op2 = 0x%s\n",
	  fpu_format_name (fmt), pr_addr (op1), pr_addr (op2));
#endif /* DEBUG */

  /* The registers must specify FPRs valid for operands of type
     "fmt". If they are not valid, the result is undefined.  */
  
  /* The format type should already have been checked:  */
a488 3
	sim_fpu wop1;
	sim_fpu wop2;
	sim_fpu ans;
d492 1
a492 1
	sim_fpu_add (&ans, &wop1, &wop2);
a498 3
	sim_fpu wop1;
	sim_fpu wop2;
	sim_fpu ans;
d502 1
a502 1
	sim_fpu_add (&ans, &wop1, &wop2);
d508 1
a508 1
      fprintf (stderr, "Bad switch\n");
d512 3
a514 4
#ifdef DEBUG
  printf ("DBG: Add: returning 0x%s (format = %s)\n",
	  pr_addr (result), fpu_format_name (fmt));
#endif /* DEBUG */
d516 7
a522 1
  return (result);
d525 5
a529 5
uword64
Sub (op1, op2, fmt)
     uword64 op1;
     uword64 op2;
     FP_formats fmt;
d531 2
a532 1
  uword64 result = 0;
d534 9
a542 4
#ifdef DEBUG
  printf ("DBG: Sub: %s: op1 = 0x%s : op2 = 0x%s\n",
	  fpu_format_name (fmt), pr_addr (op1), pr_addr (op2));
#endif /* DEBUG */
d544 8
a551 43
  /* The registers must specify FPRs valid for operands of type
     "fmt". If they are not valid, the result is undefined.  */

  /* The format type should already have been checked:  */
  switch (fmt)
    {
    case fmt_single:
      {
	sim_fpu wop1;
	sim_fpu wop2;
	sim_fpu ans;
	unsigned32 res;
	sim_fpu_32to (&wop1, op1);
	sim_fpu_32to (&wop2, op2);
	sim_fpu_sub (&ans, &wop1, &wop2);
	sim_fpu_to32 (&res, &ans);
	result = res;
      }
      break;
    case fmt_double:
      {
	sim_fpu wop1;
	sim_fpu wop2;
	sim_fpu ans;
	unsigned64 res;
	sim_fpu_64to (&wop1, op1);
	sim_fpu_64to (&wop2, op2);
	sim_fpu_sub (&ans, &wop1, &wop2);
	sim_fpu_to64 (&res, &ans);
	result = res;
      }
      break;
    default:
      fprintf (stderr, "Bad switch\n");
      abort ();
    }

#ifdef DEBUG
  printf ("DBG: Sub: returning 0x%s (format = %s)\n",
	  pr_addr (result), fpu_format_name (fmt));
#endif /* DEBUG */

  return (result);
d554 6
a559 5
uword64
Multiply (op1, op2, fmt)
     uword64 op1;
     uword64 op2;
     FP_formats fmt;
d561 1
a561 50
  uword64 result = 0;

#ifdef DEBUG
  printf ("DBG: Multiply: %s: op1 = 0x%s : op2 = 0x%s\n",
	  fpu_format_name (fmt), pr_addr (op1), pr_addr (op2));
#endif /* DEBUG */

  /* The registers must specify FPRs valid for operands of type
     "fmt". If they are not valid, the result is undefined.  */

  /* The format type should already have been checked:  */
  switch (fmt)
    {
    case fmt_single:
      {
	sim_fpu wop1;
	sim_fpu wop2;
	sim_fpu ans;
	unsigned32 res;
	sim_fpu_32to (&wop1, op1);
	sim_fpu_32to (&wop2, op2);
	sim_fpu_mul (&ans, &wop1, &wop2);
	sim_fpu_to32 (&res, &ans);
	result = res;
	break;
      }
    case fmt_double:
      {
	sim_fpu wop1;
	sim_fpu wop2;
	sim_fpu ans;
	unsigned64 res;
	sim_fpu_64to (&wop1, op1);
	sim_fpu_64to (&wop2, op2);
	sim_fpu_mul (&ans, &wop1, &wop2);
	sim_fpu_to64 (&res, &ans);
	result = res;
	break;
      }
    default:
      fprintf (stderr, "Bad switch\n");
      abort ();
    }

#ifdef DEBUG
  printf ("DBG: Multiply: returning 0x%s (format = %s)\n",
	  pr_addr (result), fpu_format_name (fmt));
#endif /* DEBUG */

  return (result);
d564 6
a569 5
uword64
Divide (op1, op2, fmt)
     uword64 op1;
     uword64 op2;
     FP_formats fmt;
d571 1
a571 50
  uword64 result = 0;

#ifdef DEBUG
  printf ("DBG: Divide: %s: op1 = 0x%s : op2 = 0x%s\n",
	  fpu_format_name (fmt), pr_addr (op1), pr_addr (op2));
#endif /* DEBUG */

  /* The registers must specify FPRs valid for operands of type
     "fmt". If they are not valid, the result is undefined.  */

  /* The format type should already have been checked:  */
  switch (fmt)
    {
    case fmt_single:
      {
	sim_fpu wop1;
	sim_fpu wop2;
	sim_fpu ans;
	unsigned32 res;
	sim_fpu_32to (&wop1, op1);
	sim_fpu_32to (&wop2, op2);
	sim_fpu_div (&ans, &wop1, &wop2);
	sim_fpu_to32 (&res, &ans);
	result = res;
	break;
      }
    case fmt_double:
      {
	sim_fpu wop1;
	sim_fpu wop2;
	sim_fpu ans;
	unsigned64 res;
	sim_fpu_64to (&wop1, op1);
	sim_fpu_64to (&wop2, op2);
	sim_fpu_div (&ans, &wop1, &wop2);
	sim_fpu_to64 (&res, &ans);
	result = res;
	break;
      }
    default:
      fprintf (stderr, "Bad switch\n");
      abort ();
    }

#ifdef DEBUG
  printf ("DBG: Divide: returning 0x%s (format = %s)\n",
	  pr_addr (result), fpu_format_name (fmt));
#endif /* DEBUG */

  return (result);
d574 5
a578 4
uword64 UNUSED
Recip (op, fmt)
     uword64 op;
     FP_formats fmt;
d580 1
a580 46
  uword64 result = 0;

#ifdef DEBUG
  printf ("DBG: Recip: %s: op = 0x%s\n",
	  fpu_format_name (fmt), pr_addr (op));
#endif /* DEBUG */

  /* The registers must specify FPRs valid for operands of type
     "fmt". If they are not valid, the result is undefined.  */

  /* The format type should already have been checked:  */
  switch (fmt)
    {
    case fmt_single:
      {
	sim_fpu wop;
	sim_fpu ans;
	unsigned32 res;
	sim_fpu_32to (&wop, op);
	sim_fpu_inv (&ans, &wop);
	sim_fpu_to32 (&res, &ans);
	result = res;
	break;
      }
    case fmt_double:
      {
	sim_fpu wop;
	sim_fpu ans;
	unsigned64 res;
	sim_fpu_64to (&wop, op);
	sim_fpu_inv (&ans, &wop);
	sim_fpu_to64 (&res, &ans);
	result = res;
	break;
      }
    default:
      fprintf (stderr, "Bad switch\n");
      abort ();
    }

#ifdef DEBUG
  printf ("DBG: Recip: returning 0x%s (format = %s)\n",
	  pr_addr (result), fpu_format_name (fmt));
#endif /* DEBUG */

  return (result);
d583 5
a587 4
uword64
SquareRoot (op, fmt)
     uword64 op;
     FP_formats fmt;
d589 2
a590 39
  uword64 result = 0;

#ifdef DEBUG
  printf ("DBG: SquareRoot: %s: op = 0x%s\n",
	  fpu_format_name (fmt), pr_addr (op));
#endif /* DEBUG */

  /* The registers must specify FPRs valid for operands of type
     "fmt". If they are not valid, the result is undefined.  */

  /* The format type should already have been checked:  */
  switch (fmt)
    {
    case fmt_single:
      {
	sim_fpu wop;
	sim_fpu ans;
	unsigned32 res;
	sim_fpu_32to (&wop, op);
	sim_fpu_sqrt (&ans, &wop);
	sim_fpu_to32 (&res, &ans);
	result = res;
	break;
      }
    case fmt_double:
      {
	sim_fpu wop;
	sim_fpu ans;
	unsigned64 res;
	sim_fpu_64to (&wop, op);
	sim_fpu_sqrt (&ans, &wop);
	sim_fpu_to64 (&res, &ans);
	result = res;
	break;
      }
    default:
      fprintf (stderr, "Bad switch\n");
      abort ();
    }
a591 7
#ifdef DEBUG
  printf ("DBG: SquareRoot: returning 0x%s (format = %s)\n",
	  pr_addr (result), fpu_format_name (fmt));
#endif /* DEBUG */

  return (result);
}
@


1.8
log
@2002-06-03  Chris Demetriou  <cgd@@broadcom.com>

        * cp1.c (Min, Max): Remove #if 0'd functions.
        * sim-main.h (Min, Max): Remove.
@
text
@d24 1
a24 1
#define SD sd
d66 1
a66 2
value_fpr (SIM_DESC sd,
	   sim_cpu *cpu,
d97 1
a97 1
      sim_io_eprintf (sd, "FPR %d (format %s) being accessed with format %s - setting to unknown (PC = 0x%s)\n",
d197 1
a197 2
store_fpr (SIM_DESC sd,
	   sim_cpu *cpu,
d895 1
a895 2
convert (SIM_DESC sd,
	 sim_cpu *cpu,
@


1.7
log
@2002-06-03  Chris Demetriou  <cgd@@broadcom.com>

        * cp1.c: fix formatting of switch case and default labels.
        * interp.c: Likewise.
        * sim-main.c: Likewise.
@
text
@a895 144
#if 0
uword64
Max (uword64 op1,
     uword64 op2,
     FP_formats fmt)
{
  int cmp;
  unsigned64 result;

#ifdef DEBUG
  printf ("DBG: Max: %s: op1 = 0x%s : op2 = 0x%s\n",
	  fpu_format_name (fmt), pr_addr (op1), pr_addr (op2));
#endif /* DEBUG */

  /* The registers must specify FPRs valid for operands of type
     "fmt". If they are not valid, the result is undefined.  */

  /* The format type should already have been checked:  */
  switch (fmt)
    {
    case fmt_single:
      {
	sim_fpu wop1;
	sim_fpu wop2;
	sim_fpu_32to (&wop1, op1);
	sim_fpu_32to (&wop2, op2);
	cmp = sim_fpu_cmp (&wop1, &wop2);
	break;
      }
    case fmt_double:
      {
	sim_fpu wop1;
	sim_fpu wop2;
	sim_fpu_64to (&wop1, op1);
	sim_fpu_64to (&wop2, op2);
	cmp = sim_fpu_cmp (&wop1, &wop2);
	break;
      }
    default:
      fprintf (stderr, "Bad switch\n");
      abort ();
    }

  switch (cmp)
    {
    case SIM_FPU_IS_SNAN:
    case SIM_FPU_IS_QNAN:
      result = op1;
    case SIM_FPU_IS_NINF:
    case SIM_FPU_IS_NNUMBER:
    case SIM_FPU_IS_NDENORM:
    case SIM_FPU_IS_NZERO:
      result = op2; /* op1 - op2 < 0 */
    case SIM_FPU_IS_PINF:
    case SIM_FPU_IS_PNUMBER:
    case SIM_FPU_IS_PDENORM:
    case SIM_FPU_IS_PZERO:
      result = op1; /* op1 - op2 > 0 */
    default:
      fprintf (stderr, "Bad switch\n");
      abort ();
    }

#ifdef DEBUG
  printf ("DBG: Max: returning 0x%s (format = %s)\n",
	  pr_addr (result), fpu_format_name (fmt));
#endif /* DEBUG */

  return (result);
}
#endif

#if 0
uword64
Min (uword64 op1,
     uword64 op2,
     FP_formats fmt)
{
  int cmp;
  unsigned64 result;

#ifdef DEBUG
  printf ("DBG: Min: %s: op1 = 0x%s : op2 = 0x%s\n",
	  fpu_format_name (fmt), pr_addr (op1), pr_addr (op2));
#endif /* DEBUG */

  /* The registers must specify FPRs valid for operands of type
     "fmt". If they are not valid, the result is undefined.  */

  /* The format type should already have been checked:  */
  switch (fmt)
    {
    case fmt_single:
      {
	sim_fpu wop1;
	sim_fpu wop2;
	sim_fpu_32to (&wop1, op1);
	sim_fpu_32to (&wop2, op2);
	cmp = sim_fpu_cmp (&wop1, &wop2);
	break;
      }
    case fmt_double:
      {
	sim_fpu wop1;
	sim_fpu wop2;
	sim_fpu_64to (&wop1, op1);
	sim_fpu_64to (&wop2, op2);
	cmp = sim_fpu_cmp (&wop1, &wop2);
	break;
      }
    default:
      fprintf (stderr, "Bad switch\n");
      abort ();
    }

  switch (cmp)
    {
    case SIM_FPU_IS_SNAN:
    case SIM_FPU_IS_QNAN:
      result = op1;
    case SIM_FPU_IS_NINF:
    case SIM_FPU_IS_NNUMBER:
    case SIM_FPU_IS_NDENORM:
    case SIM_FPU_IS_NZERO:
      result = op1; /* op1 - op2 < 0 */
    case SIM_FPU_IS_PINF:
    case SIM_FPU_IS_PNUMBER:
    case SIM_FPU_IS_PDENORM:
    case SIM_FPU_IS_PZERO:
      result = op2; /* op1 - op2 > 0 */
    default:
      fprintf (stderr, "Bad switch\n");
      abort ();
    }

#ifdef DEBUG
  printf ("DBG: Min: returning 0x%s (format = %s)\n",
	  pr_addr (result), fpu_format_name (fmt));
#endif /* DEBUG */

  return (result);
}
#endif

@


1.6
log
@2002-06-03  Chris Demetriou  <cgd@@broadcom.com>

	* cp1.c: Clean up comments which describe FP formats.
	 (FPQNaN_DOUBLE, FPQNaN_LONG): Generate using UNSIGNED64.
@
text
@d179 1
a179 1
	default :
d219 2
a220 2
	case fmt_single :
	case fmt_word :
d232 2
a233 2
	case fmt_double :
	case fmt_long :
d238 1
a238 1
	default :
d250 2
a251 2
	case fmt_single :
	case fmt_word :
d259 2
a260 2
	case fmt_double :
	case fmt_long :
d277 1
a277 1
	default :
@


1.5
log
@2002-05-01  Chris Demetriou  <cgd@@broadcom.com>

        * cp1.c (store_fpr): Remove #ifdef'd out call to UndefinedResult
        which wouldn't compile anyway.
        * sim-main.h (unpredictable_action): New function prototype.
        (Unpredictable): Define to call igen function unpredictable().
        (NotWordValue): New macro to call igen function not_word_value().
        (UndefinedResult): Remove.
        * interp.c (undefined_result): Remove.
        (unpredictable_action): New function.
        * mips.igen (not_word_value, unpredictable): New functions.
        (ADD, ADDI, do_addiu, do_addu, BGEZAL, BGEZALL, BLTZAL, BLTZALL)
        (CLO, CLZ, MADD, MADDU, MSUB, MSUBU, MUL, do_mult, do_multu)
        (do_sra, do_srav, do_srl, do_srlv, SUB, do_subu): Invoke
        NotWordValue() to check for unpredictable inputs, then
        Unpredictable() to handle them.
@
text
@d29 23
a51 22
   formats conform to ANSI/IEEE Std 754-1985.  */
/* SINGLE precision floating:
 *    seeeeeeeefffffffffffffffffffffff
 *      s =  1bit  = sign
 *      e =  8bits = exponent
 *      f = 23bits = fraction
 */
/* SINGLE precision fixed:
 *    siiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
 *      s =  1bit  = sign
 *      i = 31bits = integer
 */
/* DOUBLE precision floating:
 *    seeeeeeeeeeeffffffffffffffffffffffffffffffffffffffffffffffffffff
 *      s =  1bit  = sign
 *      e = 11bits = exponent
 *      f = 52bits = fraction
 */
/* DOUBLE precision fixed:
 *    siiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
 *      s =  1bit  = sign
 *      i = 63bits = integer
d57 2
a58 2
#define FPQNaN_DOUBLE   ((((uword64) 0x7FF7FFFF) << 32) | 0xFFFFFFFF)
#define FPQNaN_LONG     ((((uword64) 0x7FFFFFFF) << 32) | 0xFFFFFFFF)
@


1.5.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@a1 23
/* MIPS Simulator FPU (CoProcessor 1) support.
   Copyright (C) 2002 Free Software Foundation, Inc.
   Originally created by Cygnus Solutions, modified substially
   by Broadcom Corporation (SiByte).  Paired-single operation support
   and MIPS-3D support contributed by Broadcom Corporation (SiByte).

This file is part of GDB, the GNU debugger.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* XXX: The following notice should be removed as soon as is practical:  */
a6 1
   (by Cygnus.)
d20 1
d24 1
a24 1
#define SD CPU_STATE(cpu)
d29 22
a50 31
   formats conform to ANSI/IEEE Std 754-1985.

   SINGLE precision floating:
      seeeeeeeefffffffffffffffffffffff
        s =  1bit  = sign
        e =  8bits = exponent
        f = 23bits = fraction

   SINGLE precision fixed:
      siiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
        s =  1bit  = sign
        i = 31bits = integer

   DOUBLE precision floating:
      seeeeeeeeeeeffffffffffffffffffffffffffffffffffffffffffffffffffff
        s =  1bit  = sign
        e = 11bits = exponent
        f = 52bits = fraction

   DOUBLE precision fixed:
      siiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
        s =  1bit  = sign
        i = 63bits = integer

   PAIRED SINGLE precision floating:
      seeeeeeeefffffffffffffffffffffffseeeeeeeefffffffffffffffffffffff
      |         upper                ||         lower                |
        s =  1bit  = sign
        e =  8bits = exponent
        f = 23bits = fraction
    Note: upper = [63..32], lower = [31..0]
d53 1
a53 7
/* Extract packed single values:  */
#define FP_PS_upper(v) (((v) >> 32) & (unsigned)0xFFFFFFFF)
#define FP_PS_lower(v) ((v) & (unsigned)0xFFFFFFFF)
#define FP_PS_cat(u,l) (((unsigned64)((u) & (unsigned)0xFFFFFFFF) << 32) \
                        | (unsigned64)((l) & 0xFFFFFFFF))

/* Explicit QNaN values.  */
d56 2
a57 3
#define FPQNaN_DOUBLE   (UNSIGNED64 (0x7FF7FFFFFFFFFFFF))
#define FPQNaN_LONG     (UNSIGNED64 (0x7FFFFFFFFFFFFFFF))
#define FPQNaN_PS       (FP_PS_cat (FPQNaN_SINGLE, FPQNaN_SINGLE))
d65 2
a66 1
value_fpr (sim_cpu *cpu,
d74 1
a74 1
  /* Treat unused register values, as fixed-point 64bit values.  */
d86 1
a86 1
  /* For values not yet accessed, set to the desired format.  */
d97 1
a97 1
      sim_io_eprintf (SD, "FPR %d (format %s) being accessed with format %s - setting to unknown (PC = 0x%s)\n",
d108 19
a126 6
	case fmt_single:  value = FPQNaN_SINGLE;  break;
	case fmt_double:  value = FPQNaN_DOUBLE;  break;
	case fmt_word:    value = FPQNaN_WORD;    break;
	case fmt_long:    value = FPQNaN_LONG;    break;
	case fmt_ps:      value = FPQNaN_PS;      break;
	default:          err = -1;               break;
a140 1
	case fmt_ps:
d163 1
a163 1
	      /* Even register numbers only.  */
d178 1
a178 5
	case fmt_ps:
	  SignalException (ReservedInstruction, 0);
	  break;

	default:
d197 2
a198 1
store_fpr (sim_cpu *cpu,
d218 2
a219 2
	case fmt_single:
	case fmt_word:
d231 2
a232 3
	case fmt_double:
	case fmt_long:
	case fmt_ps:
d237 1
a237 1
	default:
d249 2
a250 2
	case fmt_single:
	case fmt_word:
d258 2
a259 2
	case fmt_double:
	case fmt_long:
d262 1
a262 1
	      /* Even register numbers only.  */
d276 1
a276 6
	case fmt_ps:
	  FPR_STATE[fpr] = fmt_unknown;
	  SignalException (ReservedInstruction, 0);
	  break;

	default:
d294 4
a297 6

/* CP1 control/status register access functions.  */

void
test_fcsr (sim_cpu *cpu,
	   address_word cia)
d299 2
a300 5
  unsigned int cause;

  cause = (FCSR & fcsr_CAUSE_mask) >> fcsr_CAUSE_shift;
  if ((cause & ((FCSR & fcsr_ENABLES_mask) >> fcsr_ENABLES_shift)) != 0
      || (cause & (1 << UO)))
d302 19
a320 1
      SignalExceptionFPE();
d322 7
d331 4
a334 4
unsigned_word
value_fcr(sim_cpu *cpu,
	  address_word cia,
	  int fcr)
d336 6
a341 1
  unsigned32 value = 0;
d343 1
a343 1
  switch (fcr)
d345 17
a361 17
    case 0:  /* FP Implementation and Revision Register.  */
      value = FCR0;
      break;
    case 25:  /* FP Condition Codes Register (derived from FCSR).  */
      value = (FCR31 & fcsr_FCC_mask) >> fcsr_FCC_shift;
      value = (value & 0x1) | (value >> 1);   /* Close FCC gap.  */
      break;
    case 26:  /* FP Exceptions Register (derived from FCSR).  */
      value = FCR31 & (fcsr_CAUSE_mask | fcsr_FLAGS_mask);
      break;
    case 28:  /* FP Enables Register (derived from FCSR).  */
      value = FCR31 & (fcsr_ENABLES_mask | fcsr_RM_mask);
      if ((FCR31 & fcsr_FS) != 0)
	value |= fenr_FS;
      break;
    case 31:  /* FP Control/Status Register (FCSR).  */
      value = FCR31 & ~fcsr_ZERO_mask;
d365 4
a368 2
  return (EXTEND32 (value));
}
d370 1
a370 35
void
store_fcr(sim_cpu *cpu,
	  address_word cia,
	  int fcr,
	  unsigned_word value)
{
  unsigned32 v;

  v = VL4_8(value);
  switch (fcr)
    {
    case 25:  /* FP Condition Codes Register (stored into FCSR).  */
      v = (v << 1) | (v & 0x1);             /* Adjust for FCC gap.  */
      FCR31 &= ~fcsr_FCC_mask;
      FCR31 |= ((v << fcsr_FCC_shift) & fcsr_FCC_mask);
      break;
    case 26:  /* FP Exceptions Register (stored into FCSR).  */
      FCR31 &= ~(fcsr_CAUSE_mask | fcsr_FLAGS_mask);
      FCR31 |= (v & (fcsr_CAUSE_mask | fcsr_FLAGS_mask));
      test_fcsr(cpu, cia);
      break;
    case 28:  /* FP Enables Register (stored into FCSR).  */
      if ((v & fenr_FS) != 0)
	v |= fcsr_FS;
      else
	v &= ~fcsr_FS;
      FCR31 &= (fcsr_FCC_mask | fcsr_CAUSE_mask | fcsr_FLAGS_mask);
      FCR31 |= (v & (fcsr_FS | fcsr_ENABLES_mask | fcsr_RM_mask));
      test_fcsr(cpu, cia);
      break;
    case 31:  /* FP Control/Status Register (FCSR).  */
      FCR31 = v & ~fcsr_ZERO_mask;
      test_fcsr(cpu, cia);
      break;
    }
d373 5
a377 4
void
update_fcsr (sim_cpu *cpu,
	     address_word cia,
	     sim_fpu_status status)
d379 1
a379 1
  FCSR &= ~fcsr_CAUSE_mask;
d381 1
a381 3
  if (status != 0)
    {
      unsigned int cause = 0;
d383 4
a386 23
      /* map between sim_fpu codes and MIPS FCSR */
      if (status & (sim_fpu_status_invalid_snan
		    | sim_fpu_status_invalid_isi
		    | sim_fpu_status_invalid_idi
		    | sim_fpu_status_invalid_zdz
		    | sim_fpu_status_invalid_imz
		    | sim_fpu_status_invalid_cmp
		    | sim_fpu_status_invalid_sqrt
		    | sim_fpu_status_invalid_cvi))
	cause |= (1 << IO);
      if (status & sim_fpu_status_invalid_div0)
	cause |= (1 << DZ);
      if (status & sim_fpu_status_overflow)
	cause |= (1 << OF);
      if (status & sim_fpu_status_underflow)
	cause |= (1 << UF);
      if (status & sim_fpu_status_inexact)
	cause |= (1 << IR);
#if 0 /* Not yet.  */
      /* Implicit clearing of other bits by unimplemented done by callers.  */
      if (status & sim_fpu_status_unimplemented)
	cause |= (1 << UO);
#endif
d388 2
a389 13
      FCSR |= (cause << fcsr_CAUSE_shift);
      test_fcsr (cpu, cia);
      FCSR |= ((cause & ~(1 << UO)) << fcsr_FLAGS_shift);
    }
  return;
}

static sim_fpu_round
rounding_mode(int rm)
{
  sim_fpu_round round;

  switch (rm)
d391 18
a408 21
    case FP_RM_NEAREST:
      /* Round result to nearest representable value. When two
	 representable values are equally near, round to the value
	 that has a least significant bit of zero (i.e. is even).  */
      round = sim_fpu_round_near;
      break;
    case FP_RM_TOZERO:
      /* Round result to the value closest to, and not greater in
	 magnitude than, the result.  */
      round = sim_fpu_round_zero;
      break;
    case FP_RM_TOPINF:
      /* Round result to the value closest to, and not less than,
	 the result.  */
      round = sim_fpu_round_up;
      break;
    case FP_RM_TOMINF:
      /* Round result to the value closest to, and not greater than,
	 the result.  */
      round = sim_fpu_round_down;
      break;
a409 1
      round = 0;
a412 2
  return round;
}
d414 4
a417 8
/* When the FS bit is set, MIPS processors return zero for
   denormalized results and optionally replace denormalized inputs
   with zero.  When FS is clear, some implementation trap on input
   and/or output, while other perform the operation in hardware.  */
static sim_fpu_denorm
denorm_mode(sim_cpu *cpu)
{
  sim_fpu_denorm denorm;
d419 1
a419 6
  /* XXX: FIXME: Eventually should be CPU model dependent.  */
  if (GETFS())
    denorm = sim_fpu_denorm_zero;
  else
    denorm = 0;
  return denorm;
d422 7
d430 1
a430 1
/* Comparison operations.  */
d432 4
a435 12
static sim_fpu_status
fp_test(unsigned64 op1,
	unsigned64 op2,
	FP_formats fmt,
	int abs,
	int cond,
	int *condition)
{
  sim_fpu wop1;
  sim_fpu wop2;
  sim_fpu_status status = 0;
  int  less, equal, unordered;
d437 1
a437 1
  /* The format type has already been checked:  */
d442 2
d446 1
d451 2
d455 1
d463 6
a468 24
  if (sim_fpu_is_nan (&wop1) || sim_fpu_is_nan (&wop2))
    {
      if ((cond & (1 << 3)) ||
	  sim_fpu_is_snan (&wop1) || sim_fpu_is_snan (&wop2))
	status = sim_fpu_status_invalid_snan;
      less = 0;
      equal = 0;
      unordered = 1;
    }
  else
    {
      if (abs)
	{
	  status |= sim_fpu_abs (&wop1, &wop1);
	  status |= sim_fpu_abs (&wop2, &wop2);
	}
      equal = sim_fpu_is_eq (&wop1, &wop2);
      less = !equal && sim_fpu_is_lt (&wop1, &wop2);
      unordered = 0;
    }
  *condition = (((cond & (1 << 2)) && less)
		|| ((cond & (1 << 1)) && equal)
		|| ((cond & (1 << 0)) && unordered));
  return status;
d471 4
a474 9
void
fp_cmp(sim_cpu *cpu,
       address_word cia,
       unsigned64 op1,
       unsigned64 op2,
       FP_formats fmt,
       int abs,
       int cond,
       int cc)
d476 6
a481 1
  sim_fpu_status status = 0;
d483 1
a483 3
  /* The format type should already have been checked.  The FCSR is
     updated before the condition codes so that any exceptions will
     be signalled before the condition codes are changed.  */
d487 9
d498 6
a503 16
	int result;
	status = fp_test(op1, op2, fmt, abs, cond, &result);
	update_fcsr (cpu, cia, status);
	SETFCC (cc, result);
	break;
      }
    case fmt_ps:
      {
	int result0, result1;
	status  = fp_test(FP_PS_lower (op1), FP_PS_lower (op2), fmt_single,
			  abs, cond, &result0);
	status |= fp_test(FP_PS_upper (op1), FP_PS_upper (op2), fmt_single,
			  abs, cond, &result1);
	update_fcsr (cpu, cia, status);
	SETFCC (cc, result0);
	SETFCC (cc+1, result1);
d507 1
a507 1
      sim_io_eprintf (SD, "Bad switch\n");
d510 2
d514 6
d521 4
a524 15
/* Basic arithmetic operations.  */

static unsigned64
fp_unary(sim_cpu *cpu,
	 address_word cia,
	 int (*sim_fpu_op)(sim_fpu *, const sim_fpu *),
	 unsigned64 op,
	 FP_formats fmt)
{
  sim_fpu wop;
  sim_fpu ans;
  sim_fpu_round round = rounding_mode (GETRM());
  sim_fpu_denorm denorm = denorm_mode (cpu);
  sim_fpu_status status = 0;
  unsigned64 result = 0;
d526 1
a526 1
  /* The format type has already been checked: */
d531 2
a532 1
	unsigned32 res;
d534 3
a536 4
	status |= (*sim_fpu_op) (&ans, &wop);
	status |= sim_fpu_round_32 (&ans, round, denorm);
	sim_fpu_to32 (&res, &ans);
	result = res;
d541 2
a542 1
	unsigned64 res;
d544 3
a546 18
	status |= (*sim_fpu_op) (&ans, &wop);
	status |= sim_fpu_round_64 (&ans, round, denorm);
	sim_fpu_to64 (&res, &ans);
	result = res;
	break;
      }
    case fmt_ps:
      {
	int status_u = 0, status_l = 0;
	unsigned32 res_u, res_l;
	sim_fpu_32to (&wop, FP_PS_upper(op));
	status_u |= (*sim_fpu_op) (&ans, &wop);
	sim_fpu_to32 (&res_u, &ans);
	sim_fpu_32to (&wop, FP_PS_lower(op));
	status_l |= (*sim_fpu_op) (&ans, &wop);
	sim_fpu_to32 (&res_l, &ans);
	result = FP_PS_cat(res_u, res_l);
	status = status_u | status_l;
d550 1
a550 1
      sim_io_eprintf (SD, "Bad switch\n");
d554 1
a554 2
  update_fcsr (cpu, cia, status);
  return result;
d557 5
a561 7
static unsigned64
fp_binary(sim_cpu *cpu,
	  address_word cia,
	  int (*sim_fpu_op)(sim_fpu *, const sim_fpu *, const sim_fpu *),
	  unsigned64 op1,
	  unsigned64 op2,
	  FP_formats fmt)
d563 6
a568 7
  sim_fpu wop1;
  sim_fpu wop2;
  sim_fpu ans;
  sim_fpu_round round = rounding_mode (GETRM());
  sim_fpu_denorm denorm = denorm_mode (cpu);
  sim_fpu_status status = 0;
  unsigned64 result = 0;
d570 4
a573 1
  /* The format type has already been checked: */
d578 3
d584 1
a584 2
	status |= (*sim_fpu_op) (&ans, &wop1, &wop2);
	status |= sim_fpu_round_32 (&ans, round, denorm);
d591 3
d597 1
a597 2
	status |= (*sim_fpu_op) (&ans, &wop1, &wop2);
	status |= sim_fpu_round_64 (&ans, round, denorm);
a601 16
    case fmt_ps:
      {
	int status_u = 0, status_l = 0;
	unsigned32 res_u, res_l;
	sim_fpu_32to (&wop1, FP_PS_upper(op1));
	sim_fpu_32to (&wop2, FP_PS_upper(op2));
	status_u |= (*sim_fpu_op) (&ans, &wop1, &wop2);
	sim_fpu_to32 (&res_u, &ans);
	sim_fpu_32to (&wop1, FP_PS_lower(op1));
	sim_fpu_32to (&wop2, FP_PS_lower(op2));
	status_l |= (*sim_fpu_op) (&ans, &wop1, &wop2);
	sim_fpu_to32 (&res_l, &ans);
	result = FP_PS_cat(res_u, res_l);
	status = status_u | status_l;
	break;
      }
d603 1
a603 1
      sim_io_eprintf (SD, "Bad switch\n");
d607 6
a612 2
  update_fcsr (cpu, cia, status);
  return result;
d615 5
a619 12
/* Common MAC code for single operands (.s or .d), defers setting FCSR.  */
static sim_fpu_status
inner_mac(int (*sim_fpu_op)(sim_fpu *, const sim_fpu *, const sim_fpu *),
	  unsigned64 op1,
	  unsigned64 op2,
	  unsigned64 op3,
	  int scale,
	  int negate,
	  FP_formats fmt,
	  sim_fpu_round round,
	  sim_fpu_denorm denorm,
	  unsigned64 *result)
d621 9
a629 6
  sim_fpu wop1;
  sim_fpu wop2;
  sim_fpu ans;
  sim_fpu_status status = 0;
  sim_fpu_status op_status;
  unsigned64 temp = 0;
d631 1
d636 3
d642 1
a642 17
	status |= sim_fpu_mul (&ans, &wop1, &wop2);
	if (scale != 0 && sim_fpu_is_number (&ans))  /* number or denorm */
	  ans.normal_exp += scale;
	status |= sim_fpu_round_32 (&ans, round, denorm);
	wop1 = ans;
        op_status = 0;
	sim_fpu_32to (&wop2, op3);
	op_status |= (*sim_fpu_op) (&ans, &wop1, &wop2);
	op_status |= sim_fpu_round_32 (&ans, round, denorm);
	status |= op_status;
	if (negate)
	  {
	    wop1 = ans;
	    op_status = sim_fpu_neg (&ans, &wop1);
	    op_status |= sim_fpu_round_32 (&ans, round, denorm);
	    status |= op_status;
	  }
d644 1
a644 2
	temp = res;
	break;
d646 1
d649 3
d655 1
a655 17
	status |= sim_fpu_mul (&ans, &wop1, &wop2);
	if (scale != 0 && sim_fpu_is_number (&ans))  /* number or denorm */
	  ans.normal_exp += scale;
	status |= sim_fpu_round_64 (&ans, round, denorm);
	wop1 = ans;
        op_status = 0;
	sim_fpu_64to (&wop2, op3);
	op_status |= (*sim_fpu_op) (&ans, &wop1, &wop2);
	op_status |= sim_fpu_round_64 (&ans, round, denorm);
	status |= op_status;
	if (negate)
	  {
	    wop1 = ans;
	    op_status = sim_fpu_neg (&ans, &wop1);
	    op_status |= sim_fpu_round_64 (&ans, round, denorm);
	    status |= op_status;
	  }
d657 1
a657 2
	temp = res;
	break;
d659 1
d664 7
a670 2
  *result = temp;
  return status;
d673 5
a677 16
/* Common implementation of madd, nmadd, msub, nmsub that does
   intermediate rounding per spec.  Also used for recip2 and rsqrt2,
   which are transformed into equivalent nmsub operations.  The scale
   argument is an adjustment to the exponent of the intermediate
   product op1*op2.  It is currently non-zero for rsqrt2 (-1), which
   requires an effective division by 2. */
static unsigned64
fp_mac(sim_cpu *cpu,
       address_word cia,
       int (*sim_fpu_op)(sim_fpu *, const sim_fpu *, const sim_fpu *),
       unsigned64 op1,
       unsigned64 op2,
       unsigned64 op3,
       int scale,
       int negate,
       FP_formats fmt)
d679 1
a679 4
  sim_fpu_round round = rounding_mode (GETRM());
  sim_fpu_denorm denorm = denorm_mode (cpu);
  sim_fpu_status status = 0;
  unsigned64 result = 0;
d681 4
a684 26
  /* The format type has already been checked: */
  switch (fmt)
    {
    case fmt_single:
    case fmt_double:
      status = inner_mac(sim_fpu_op, op1, op2, op3, scale,
			 negate, fmt, round, denorm, &result);
      break;
    case fmt_ps:
      {
	int status_u, status_l;
	unsigned64 result_u, result_l;
	status_u = inner_mac(sim_fpu_op, FP_PS_upper(op1), FP_PS_upper(op2),
			     FP_PS_upper(op3), scale, negate, fmt_single,
			     round, denorm, &result_u);
	status_l = inner_mac(sim_fpu_op, FP_PS_lower(op1), FP_PS_lower(op2),
			     FP_PS_lower(op3), scale, negate, fmt_single,
			     round, denorm, &result_l);
	result = FP_PS_cat(result_u, result_l);
	status = status_u | status_l;
	break;
      }
    default:
      sim_io_eprintf (SD, "Bad switch\n");
      abort ();
    }
d686 2
a687 17
  update_fcsr (cpu, cia, status);
  return result;
}

/* Common rsqrt code for single operands (.s or .d), intermediate rounding.  */
static sim_fpu_status
inner_rsqrt(unsigned64 op1,
	    FP_formats fmt,
	    sim_fpu_round round,
	    sim_fpu_denorm denorm,
	    unsigned64 *result)
{
  sim_fpu wop1;
  sim_fpu ans;
  sim_fpu_status status = 0;
  sim_fpu_status op_status;
  unsigned64 temp = 0;
d689 1
d694 3
d699 2
a700 5
	status |= sim_fpu_sqrt (&ans, &wop1);
	status |= sim_fpu_round_32 (&ans, status, round);
	wop1 = ans;
	op_status = sim_fpu_inv (&ans, &wop1);
	op_status |= sim_fpu_round_32 (&ans, round, denorm);
d702 1
a702 2
	temp = res;
	status |= op_status;
d707 3
d712 2
a713 5
	status |= sim_fpu_sqrt (&ans, &wop1);
	status |= sim_fpu_round_64 (&ans, round, denorm);
	wop1 = ans;
	op_status = sim_fpu_inv (&ans, &wop1);
	op_status |= sim_fpu_round_64 (&ans, round, denorm);
d715 1
a715 2
	temp = res;
	status |= op_status;
d722 7
a728 2
  *result = temp;
  return status;
d731 5
a735 5
static unsigned64
fp_inv_sqrt(sim_cpu *cpu,
	    address_word cia,
	    unsigned64 op1,
	    FP_formats fmt)
d737 1
a737 4
  sim_fpu_round round = rounding_mode (GETRM());
  sim_fpu_round denorm = denorm_mode (cpu);
  sim_fpu_status status = 0;
  unsigned64 result = 0;
d739 9
a747 1
  /* The format type has already been checked: */
d751 12
a763 3
      status = inner_rsqrt (op1, fmt, round, denorm, &result);
      break;
    case fmt_ps:
d765 9
a773 8
	int status_u, status_l;
	unsigned64 result_u, result_l;
	status_u = inner_rsqrt (FP_PS_upper(op1), fmt_single, round, denorm,
				&result_u);
	status_l = inner_rsqrt (FP_PS_lower(op1), fmt_single, round, denorm,
				&result_l);
	result = FP_PS_cat(result_u, result_l);
	status = status_u | status_l;
d777 1
a777 1
      sim_io_eprintf (SD, "Bad switch\n");
d781 4
a784 4
  update_fcsr (cpu, cia, status);
  return result;
}

d786 1
a786 7
unsigned64
fp_abs(sim_cpu *cpu,
       address_word cia,
       unsigned64 op,
       FP_formats fmt)
{
  return fp_unary(cpu, cia, &sim_fpu_abs, op, fmt);
d789 4
a792 5
unsigned64
fp_neg(sim_cpu *cpu,
       address_word cia,
       unsigned64 op,
       FP_formats fmt)
d794 1
a794 2
  return fp_unary(cpu, cia, &sim_fpu_neg, op, fmt);
}
d796 4
a799 9
unsigned64
fp_add(sim_cpu *cpu,
       address_word cia,
       unsigned64 op1,
       unsigned64 op2,
       FP_formats fmt)
{
  return fp_binary(cpu, cia, &sim_fpu_add, op1, op2, fmt);
}
d801 2
a802 9
unsigned64
fp_sub(sim_cpu *cpu,
       address_word cia,
       unsigned64 op1,
       unsigned64 op2,
       FP_formats fmt)
{
  return fp_binary(cpu, cia, &sim_fpu_sub, op1, op2, fmt);
}
d804 29
a832 9
unsigned64
fp_mul(sim_cpu *cpu,
       address_word cia,
       unsigned64 op1,
       unsigned64 op2,
       FP_formats fmt)
{
  return fp_binary(cpu, cia, &sim_fpu_mul, op1, op2, fmt);
}
d834 4
a837 9
unsigned64
fp_div(sim_cpu *cpu,
       address_word cia,
       unsigned64 op1,
       unsigned64 op2,
       FP_formats fmt)
{
  return fp_binary(cpu, cia, &sim_fpu_div, op1, op2, fmt);
}
d839 1
a839 7
unsigned64
fp_recip(sim_cpu *cpu,
         address_word cia,
         unsigned64 op,
         FP_formats fmt)
{
  return fp_unary(cpu, cia, &sim_fpu_inv, op, fmt);
d842 4
a845 5
unsigned64
fp_sqrt(sim_cpu *cpu,
        address_word cia,
        unsigned64 op,
        FP_formats fmt)
d847 1
a847 2
  return fp_unary(cpu, cia, &sim_fpu_sqrt, op, fmt);
}
d849 4
a852 8
unsigned64
fp_rsqrt(sim_cpu *cpu,
         address_word cia,
         unsigned64 op,
         FP_formats fmt)
{
  return fp_inv_sqrt(cpu, cia, op, fmt);
}
d854 2
a855 10
unsigned64
fp_madd(sim_cpu *cpu,
        address_word cia,
        unsigned64 op1,
        unsigned64 op2,
        unsigned64 op3,
        FP_formats fmt)
{
  return fp_mac(cpu, cia, &sim_fpu_add, op1, op2, op3, 0, 0, fmt);
}
d857 29
a885 10
unsigned64
fp_msub(sim_cpu *cpu,
        address_word cia,
        unsigned64 op1,
        unsigned64 op2,
        unsigned64 op3,
        FP_formats fmt)
{
  return fp_mac(cpu, cia, &sim_fpu_sub, op1, op2, op3, 0, 0, fmt);
}
d887 4
a890 10
unsigned64
fp_nmadd(sim_cpu *cpu,
         address_word cia,
         unsigned64 op1,
         unsigned64 op2,
         unsigned64 op3,
         FP_formats fmt)
{
  return fp_mac(cpu, cia, &sim_fpu_add, op1, op2, op3, 0, 1, fmt);
}
d892 1
a892 9
unsigned64
fp_nmsub(sim_cpu *cpu,
         address_word cia,
         unsigned64 op1,
         unsigned64 op2,
         unsigned64 op3,
         FP_formats fmt)
{
  return fp_mac(cpu, cia, &sim_fpu_sub, op1, op2, op3, 0, 1, fmt);
d895 5
a899 10

/* MIPS-3D ASE operations.  */

/* Variant of fp_binary for *r.ps MIPS-3D operations. */
static unsigned64
fp_binary_r(sim_cpu *cpu,
	    address_word cia,
	    int (*sim_fpu_op)(sim_fpu *, const sim_fpu *, const sim_fpu *),
	    unsigned64 op1,
	    unsigned64 op2) 
d901 1
a901 6
  sim_fpu wop1;
  sim_fpu wop2;
  sim_fpu ans;
  sim_fpu_round round = rounding_mode (GETRM ());
  sim_fpu_denorm denorm = denorm_mode (cpu);
  sim_fpu_status status_u, status_l;
a902 1
  unsigned32 res_u, res_l;
d904 4
a907 14
  /* The format must be fmt_ps.  */
  status_u = 0;
  sim_fpu_32to (&wop1, FP_PS_upper (op1));
  sim_fpu_32to (&wop2, FP_PS_lower (op1));
  status_u |= (*sim_fpu_op) (&ans, &wop1, &wop2);
  status_u |= sim_fpu_round_32 (&ans, round, denorm);
  sim_fpu_to32 (&res_u, &ans);
  status_l = 0;
  sim_fpu_32to (&wop1, FP_PS_upper (op2));
  sim_fpu_32to (&wop2, FP_PS_lower (op2));
  status_l |= (*sim_fpu_op) (&ans, &wop1, &wop2);
  status_l |= sim_fpu_round_32 (&ans, round, denorm);
  sim_fpu_to32 (&res_l, &ans);
  result = FP_PS_cat (res_u, res_l);
d909 2
a910 3
  update_fcsr (cpu, cia, status_u | status_l);
  return result;
}
d912 1
a912 78
unsigned64
fp_add_r(sim_cpu *cpu,
         address_word cia,
         unsigned64 op1,
         unsigned64 op2,
         FP_formats fmt)
{
  return fp_binary_r (cpu, cia, &sim_fpu_add, op1, op2);
}

unsigned64
fp_mul_r(sim_cpu *cpu,
         address_word cia,
         unsigned64 op1,
         unsigned64 op2,
         FP_formats fmt)
{
  return fp_binary_r (cpu, cia, &sim_fpu_mul, op1, op2);
}

#define NR_FRAC_GUARD   (60)
#define IMPLICIT_1 LSBIT64 (NR_FRAC_GUARD)

static int
fpu_inv1(sim_fpu *f, const sim_fpu *l)
{
  static const sim_fpu sim_fpu_one = {
    sim_fpu_class_number, 0, IMPLICIT_1, 0
  };
  int  status = 0;
  sim_fpu t;

  if (sim_fpu_is_zero (l))
    {
      *f = sim_fpu_maxfp;
      f->sign = l->sign;
      return sim_fpu_status_invalid_div0;
    }
  if (sim_fpu_is_infinity (l))
    {
      *f = sim_fpu_zero;
      f->sign = l->sign;
      return status;
    }
  status |= sim_fpu_div (f, &sim_fpu_one, l);
  return status;
}

static int
fpu_inv1_32(sim_fpu *f, const sim_fpu *l)
{
  if (sim_fpu_is_zero (l))
    {
      *f = sim_fpu_max32;
      f->sign = l->sign;
      return sim_fpu_status_invalid_div0;
    }
  return fpu_inv1 (f, l);
}

static int
fpu_inv1_64(sim_fpu *f, const sim_fpu *l)
{
  if (sim_fpu_is_zero (l))
    {
      *f = sim_fpu_max64;
      f->sign = l->sign;
      return sim_fpu_status_invalid_div0;
    }
  return fpu_inv1 (f, l);
}

unsigned64
fp_recip1(sim_cpu *cpu,
          address_word cia,
          unsigned64 op,
          FP_formats fmt)
{
d916 8
a923 2
    case fmt_ps:
      return fp_unary (cpu, cia, &fpu_inv1_32, op, fmt);
d925 11
a935 1
      return fp_unary (cpu, cia, &fpu_inv1_64, op, fmt);
a936 2
  return 0;
}
d938 1
a938 14
unsigned64
fp_recip2(sim_cpu *cpu,
          address_word cia,
          unsigned64 op1,
          unsigned64 op2,
          FP_formats fmt)
{
  static const unsigned64 one_single = UNSIGNED64 (0x3F800000);
  static const unsigned64 one_double = UNSIGNED64 (0x3FF0000000000000);
  static const unsigned64 one_ps = (one_single << 32 | one_single);
  unsigned64 one;

  /* Implemented as nmsub fd, 1, fs, ft.  */
  switch (fmt)
d940 16
a955 4
    case fmt_single:  one = one_single;  break;
    case fmt_double:  one = one_double;  break;
    case fmt_ps:      one = one_ps;      break;
    default:          one = 0;           abort ();
a956 2
  return fp_mac (cpu, cia, &sim_fpu_sub, op1, op2, one, 0, 1, fmt);
}
d958 4
a961 8
static int
fpu_inv_sqrt1(sim_fpu *f, const sim_fpu *l)
{
  static const sim_fpu sim_fpu_one = {
    sim_fpu_class_number, 0, IMPLICIT_1, 0
  };
  int  status = 0;
  sim_fpu t;
d963 1
a963 23
  if (sim_fpu_is_zero (l))
    {
      *f = sim_fpu_maxfp;
      f->sign = l->sign;
      return sim_fpu_status_invalid_div0;
    }
  if (sim_fpu_is_infinity (l))
    {
      if (!l->sign)
	{
	  f->class = sim_fpu_class_zero;
	  f->sign = 0;
	}
      else
	{
	  *f = sim_fpu_qnan;
	  status = sim_fpu_status_invalid_sqrt;
	}
      return status;
    }
  status |= sim_fpu_sqrt (&t, l);
  status |= sim_fpu_div (f, &sim_fpu_one, &t);
  return status;
d965 1
d967 5
a971 2
static int
fpu_inv_sqrt1_32(sim_fpu *f, const sim_fpu *l)
d973 7
a979 8
  if (sim_fpu_is_zero (l))
    {
      *f = sim_fpu_max32;
      f->sign = l->sign;
      return sim_fpu_status_invalid_div0;
    }
  return fpu_inv_sqrt1 (f, l);
}
d981 2
a982 11
static int
fpu_inv_sqrt1_64(sim_fpu *f, const sim_fpu *l)
{
  if (sim_fpu_is_zero (l))
    {
      *f = sim_fpu_max64;
      f->sign = l->sign;
      return sim_fpu_status_invalid_div0;
    }
  return fpu_inv_sqrt1 (f, l);
}
d984 1
a984 6
unsigned64
fp_rsqrt1(sim_cpu *cpu,
          address_word cia,
          unsigned64 op,
          FP_formats fmt)
{
d988 8
a995 2
    case fmt_ps:
      return fp_unary (cpu, cia, &fpu_inv_sqrt1_32, op, fmt);
d997 11
a1007 1
      return fp_unary (cpu, cia, &fpu_inv_sqrt1_64, op, fmt);
a1008 2
  return 0;
}
d1010 1
a1010 15
unsigned64
fp_rsqrt2(sim_cpu *cpu,
          address_word cia,
          unsigned64 op1,
          unsigned64 op2,
          FP_formats fmt)
{
  static const unsigned64 half_single = UNSIGNED64 (0x3F000000);
  static const unsigned64 half_double = UNSIGNED64 (0x3FE0000000000000);
  static const unsigned64 half_ps = (half_single << 32 | half_single);
  unsigned64 half;

  /* Implemented as (nmsub fd, 0.5, fs, ft)/2, where the divide is
     done by scaling the exponent during multiply.  */
  switch (fmt)
d1012 16
a1027 4
    case fmt_single:  half = half_single;  break;
    case fmt_double:  half = half_double;  break;
    case fmt_ps:      half = half_ps;      break;
    default:          half = 0;            abort ();
a1028 2
  return fp_mac (cpu, cia, &sim_fpu_sub, op1, op2, half, -1, 1, fmt);
}
d1030 4
d1035 3
a1037 1
/* Conversion operations.  */
d1040 2
a1041 1
convert (sim_cpu *cpu,
d1049 1
a1049 2
  sim_fpu_round round = rounding_mode (rm);
  sim_fpu_denorm denorm = denorm_mode (cpu);
d1052 38
a1089 1
  sim_fpu_status status = 0;
d1101 1
a1101 1
      status = sim_fpu_i32to (&wop, op, round);
d1104 1
a1104 1
      status = sim_fpu_i64to (&wop, op, round);
d1107 1
a1107 1
      sim_io_eprintf (SD, "Bad switch\n");
d1115 2
a1116 2
     integer outside the fixed point range then an IEEE Invalid Operation
     condition is raised.  Not used if destination format is PS.  */
d1120 1
a1120 4
      status |= sim_fpu_round_32 (&wop, round, denorm);
      /* For a NaN, normalize mantissa bits (cvt.s.d can't preserve them) */
      if (sim_fpu_is_qnan (&wop))
	wop = sim_fpu_qnan;
d1125 1
a1125 4
      status |= sim_fpu_round_64 (&wop, round, denorm);
      /* For a NaN, normalize mantissa bits (make cvt.d.s consistent) */
      if (sim_fpu_is_qnan (&wop))
	wop = sim_fpu_qnan;
d1129 1
a1129 1
      status |= sim_fpu_to32i (&result32, &wop, round);
d1133 1
a1133 1
      status |= sim_fpu_to64i (&result64, &wop, round);
d1137 1
a1137 1
      sim_io_eprintf (SD, "Bad switch\n");
d1141 4
a1144 107
  update_fcsr (cpu, cia, status);
  return result64;
}

unsigned64
ps_lower(sim_cpu *cpu,
         address_word cia,
         unsigned64 op)
{
  return FP_PS_lower (op);
}

unsigned64
ps_upper(sim_cpu *cpu,
         address_word cia,
         unsigned64 op)
{
  return FP_PS_upper(op);
}

unsigned64
pack_ps(sim_cpu *cpu,
        address_word cia,
        unsigned64 op1,
        unsigned64 op2,
        FP_formats fmt)
{
  unsigned64 result = 0;

  /* The registers must specify FPRs valid for operands of type
     "fmt". If they are not valid, the result is undefined. */

  /* The format type should already have been checked: */
  switch (fmt)
    {
    case fmt_single:
      {
	sim_fpu wop;
	unsigned32 res_u, res_l;
	sim_fpu_32to (&wop, op1);
	sim_fpu_to32 (&res_u, &wop);
	sim_fpu_32to (&wop, op2);
	sim_fpu_to32 (&res_l, &wop);
	result = FP_PS_cat(res_u, res_l);
	break;
      }
    default:
      sim_io_eprintf (SD, "Bad switch\n");
      abort ();
    }

  return result;
}

unsigned64
convert_ps (sim_cpu *cpu,
            address_word cia,
            int rm,
            unsigned64 op,
            FP_formats from,
            FP_formats to)
{
  sim_fpu wop_u, wop_l;
  sim_fpu_round round = rounding_mode (rm);
  sim_fpu_denorm denorm = denorm_mode (cpu);
  unsigned32 res_u, res_l;
  unsigned64 result;
  sim_fpu_status status_u = 0, status_l = 0;

  /* As convert, but used only for paired values (formats PS, PW) */

  /* Convert the input to sim_fpu internal format */
  switch (from)
    {
    case fmt_word:   /* fmt_pw */
      sim_fpu_i32to (&wop_u, (op >> 32) & (unsigned)0xFFFFFFFF, round);
      sim_fpu_i32to (&wop_l, op & (unsigned)0xFFFFFFFF, round);
      break;
    case fmt_ps:
      sim_fpu_32to (&wop_u, FP_PS_upper(op));
      sim_fpu_32to (&wop_l, FP_PS_lower(op));
      break;
    default:
      sim_io_eprintf (SD, "Bad switch\n");
      abort ();
    }

  /* Convert sim_fpu format into the output */
  switch (to)
    {
    case fmt_word:   /* fmt_pw */
      status_u |= sim_fpu_to32i (&res_u, &wop_u, round);
      status_l |= sim_fpu_to32i (&res_l, &wop_l, round);
      result = (((unsigned64)res_u) << 32) | (unsigned64)res_l;
      break;
    case fmt_ps:
      status_u |= sim_fpu_round_32 (&wop_u, 0, round);
      status_l |= sim_fpu_round_32 (&wop_l, 0, round);
      sim_fpu_to32 (&res_u, &wop_u);
      sim_fpu_to32 (&res_l, &wop_l);
      result = FP_PS_cat(res_u, res_l);
      break;
    default:
      result = 0;
      sim_io_eprintf (SD, "Bad switch\n");
      abort ();
    }
d1146 1
a1146 2
  update_fcsr (cpu, cia, status_u | status_l);
  return result;
a1161 2
    case fmt_ps:
      return "ps";
@


1.5.6.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d1238 1
a1238 1
  static const unsigned64 one_ps = (UNSIGNED64 (0x3F800000) << 32 | UNSIGNED64 (0x3F800000));
d1336 1
a1336 1
  static const unsigned64 half_ps = (UNSIGNED64 (0x3F000000) << 32 | UNSIGNED64 (0x3F000000));
@


1.5.4.1
log
@merge from trunk
@
text
@a1 23
/* MIPS Simulator FPU (CoProcessor 1) support.
   Copyright (C) 2002 Free Software Foundation, Inc.
   Originally created by Cygnus Solutions, modified substially
   by Broadcom Corporation (SiByte).  Paired-single operation support
   and MIPS-3D support contributed by Broadcom Corporation (SiByte).

This file is part of GDB, the GNU debugger.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/* XXX: The following notice should be removed as soon as is practical:  */
a6 1
   (by Cygnus.)
d20 1
d24 1
a24 1
#define SD CPU_STATE(cpu)
d29 22
a50 31
   formats conform to ANSI/IEEE Std 754-1985.

   SINGLE precision floating:
      seeeeeeeefffffffffffffffffffffff
        s =  1bit  = sign
        e =  8bits = exponent
        f = 23bits = fraction

   SINGLE precision fixed:
      siiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
        s =  1bit  = sign
        i = 31bits = integer

   DOUBLE precision floating:
      seeeeeeeeeeeffffffffffffffffffffffffffffffffffffffffffffffffffff
        s =  1bit  = sign
        e = 11bits = exponent
        f = 52bits = fraction

   DOUBLE precision fixed:
      siiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
        s =  1bit  = sign
        i = 63bits = integer

   PAIRED SINGLE precision floating:
      seeeeeeeefffffffffffffffffffffffseeeeeeeefffffffffffffffffffffff
      |         upper                ||         lower                |
        s =  1bit  = sign
        e =  8bits = exponent
        f = 23bits = fraction
    Note: upper = [63..32], lower = [31..0]
d53 1
a53 7
/* Extract packed single values:  */
#define FP_PS_upper(v) (((v) >> 32) & (unsigned)0xFFFFFFFF)
#define FP_PS_lower(v) ((v) & (unsigned)0xFFFFFFFF)
#define FP_PS_cat(u,l) (((unsigned64)((u) & (unsigned)0xFFFFFFFF) << 32) \
                        | (unsigned64)((l) & 0xFFFFFFFF))

/* Explicit QNaN values.  */
d56 2
a57 3
#define FPQNaN_DOUBLE   (UNSIGNED64 (0x7FF7FFFFFFFFFFFF))
#define FPQNaN_LONG     (UNSIGNED64 (0x7FFFFFFFFFFFFFFF))
#define FPQNaN_PS       (FP_PS_cat (FPQNaN_SINGLE, FPQNaN_SINGLE))
d65 2
a66 1
value_fpr (sim_cpu *cpu,
d74 1
a74 1
  /* Treat unused register values, as fixed-point 64bit values.  */
d86 1
a86 1
  /* For values not yet accessed, set to the desired format.  */
d97 1
a97 1
      sim_io_eprintf (SD, "FPR %d (format %s) being accessed with format %s - setting to unknown (PC = 0x%s)\n",
d108 19
a126 6
	case fmt_single:  value = FPQNaN_SINGLE;  break;
	case fmt_double:  value = FPQNaN_DOUBLE;  break;
	case fmt_word:    value = FPQNaN_WORD;    break;
	case fmt_long:    value = FPQNaN_LONG;    break;
	case fmt_ps:      value = FPQNaN_PS;      break;
	default:          err = -1;               break;
a140 1
	case fmt_ps:
d163 1
a163 1
	      /* Even register numbers only.  */
d178 1
a178 5
	case fmt_ps:
	  SignalException (ReservedInstruction, 0);
	  break;

	default:
d197 2
a198 1
store_fpr (sim_cpu *cpu,
d218 2
a219 2
	case fmt_single:
	case fmt_word:
d231 2
a232 3
	case fmt_double:
	case fmt_long:
	case fmt_ps:
d237 1
a237 1
	default:
d249 2
a250 2
	case fmt_single:
	case fmt_word:
d258 2
a259 2
	case fmt_double:
	case fmt_long:
d262 1
a262 1
	      /* Even register numbers only.  */
d276 1
a276 6
	case fmt_ps:
	  FPR_STATE[fpr] = fmt_unknown;
	  SignalException (ReservedInstruction, 0);
	  break;

	default:
d294 4
a297 6

/* CP1 control/status register access functions.  */

void
test_fcsr (sim_cpu *cpu,
	   address_word cia)
d299 2
a300 5
  unsigned int cause;

  cause = (FCSR & fcsr_CAUSE_mask) >> fcsr_CAUSE_shift;
  if ((cause & ((FCSR & fcsr_ENABLES_mask) >> fcsr_ENABLES_shift)) != 0
      || (cause & (1 << UO)))
d302 19
a320 1
      SignalExceptionFPE();
d322 7
d331 4
a334 4
unsigned_word
value_fcr(sim_cpu *cpu,
	  address_word cia,
	  int fcr)
d336 6
a341 1
  unsigned32 value = 0;
d343 1
a343 1
  switch (fcr)
d345 17
a361 17
    case 0:  /* FP Implementation and Revision Register.  */
      value = FCR0;
      break;
    case 25:  /* FP Condition Codes Register (derived from FCSR).  */
      value = (FCR31 & fcsr_FCC_mask) >> fcsr_FCC_shift;
      value = (value & 0x1) | (value >> 1);   /* Close FCC gap.  */
      break;
    case 26:  /* FP Exceptions Register (derived from FCSR).  */
      value = FCR31 & (fcsr_CAUSE_mask | fcsr_FLAGS_mask);
      break;
    case 28:  /* FP Enables Register (derived from FCSR).  */
      value = FCR31 & (fcsr_ENABLES_mask | fcsr_RM_mask);
      if ((FCR31 & fcsr_FS) != 0)
	value |= fenr_FS;
      break;
    case 31:  /* FP Control/Status Register (FCSR).  */
      value = FCR31 & ~fcsr_ZERO_mask;
d365 4
a368 2
  return (EXTEND32 (value));
}
d370 1
a370 35
void
store_fcr(sim_cpu *cpu,
	  address_word cia,
	  int fcr,
	  unsigned_word value)
{
  unsigned32 v;

  v = VL4_8(value);
  switch (fcr)
    {
    case 25:  /* FP Condition Codes Register (stored into FCSR).  */
      v = (v << 1) | (v & 0x1);             /* Adjust for FCC gap.  */
      FCR31 &= ~fcsr_FCC_mask;
      FCR31 |= ((v << fcsr_FCC_shift) & fcsr_FCC_mask);
      break;
    case 26:  /* FP Exceptions Register (stored into FCSR).  */
      FCR31 &= ~(fcsr_CAUSE_mask | fcsr_FLAGS_mask);
      FCR31 |= (v & (fcsr_CAUSE_mask | fcsr_FLAGS_mask));
      test_fcsr(cpu, cia);
      break;
    case 28:  /* FP Enables Register (stored into FCSR).  */
      if ((v & fenr_FS) != 0)
	v |= fcsr_FS;
      else
	v &= ~fcsr_FS;
      FCR31 &= (fcsr_FCC_mask | fcsr_CAUSE_mask | fcsr_FLAGS_mask);
      FCR31 |= (v & (fcsr_FS | fcsr_ENABLES_mask | fcsr_RM_mask));
      test_fcsr(cpu, cia);
      break;
    case 31:  /* FP Control/Status Register (FCSR).  */
      FCR31 = v & ~fcsr_ZERO_mask;
      test_fcsr(cpu, cia);
      break;
    }
d373 5
a377 4
void
update_fcsr (sim_cpu *cpu,
	     address_word cia,
	     sim_fpu_status status)
d379 1
a379 1
  FCSR &= ~fcsr_CAUSE_mask;
d381 1
a381 3
  if (status != 0)
    {
      unsigned int cause = 0;
d383 4
a386 23
      /* map between sim_fpu codes and MIPS FCSR */
      if (status & (sim_fpu_status_invalid_snan
		    | sim_fpu_status_invalid_isi
		    | sim_fpu_status_invalid_idi
		    | sim_fpu_status_invalid_zdz
		    | sim_fpu_status_invalid_imz
		    | sim_fpu_status_invalid_cmp
		    | sim_fpu_status_invalid_sqrt
		    | sim_fpu_status_invalid_cvi))
	cause |= (1 << IO);
      if (status & sim_fpu_status_invalid_div0)
	cause |= (1 << DZ);
      if (status & sim_fpu_status_overflow)
	cause |= (1 << OF);
      if (status & sim_fpu_status_underflow)
	cause |= (1 << UF);
      if (status & sim_fpu_status_inexact)
	cause |= (1 << IR);
#if 0 /* Not yet.  */
      /* Implicit clearing of other bits by unimplemented done by callers.  */
      if (status & sim_fpu_status_unimplemented)
	cause |= (1 << UO);
#endif
d388 2
a389 13
      FCSR |= (cause << fcsr_CAUSE_shift);
      test_fcsr (cpu, cia);
      FCSR |= ((cause & ~(1 << UO)) << fcsr_FLAGS_shift);
    }
  return;
}

static sim_fpu_round
rounding_mode(int rm)
{
  sim_fpu_round round;

  switch (rm)
d391 18
a408 21
    case FP_RM_NEAREST:
      /* Round result to nearest representable value. When two
	 representable values are equally near, round to the value
	 that has a least significant bit of zero (i.e. is even).  */
      round = sim_fpu_round_near;
      break;
    case FP_RM_TOZERO:
      /* Round result to the value closest to, and not greater in
	 magnitude than, the result.  */
      round = sim_fpu_round_zero;
      break;
    case FP_RM_TOPINF:
      /* Round result to the value closest to, and not less than,
	 the result.  */
      round = sim_fpu_round_up;
      break;
    case FP_RM_TOMINF:
      /* Round result to the value closest to, and not greater than,
	 the result.  */
      round = sim_fpu_round_down;
      break;
a409 1
      round = 0;
a412 2
  return round;
}
d414 4
a417 8
/* When the FS bit is set, MIPS processors return zero for
   denormalized results and optionally replace denormalized inputs
   with zero.  When FS is clear, some implementation trap on input
   and/or output, while other perform the operation in hardware.  */
static sim_fpu_denorm
denorm_mode(sim_cpu *cpu)
{
  sim_fpu_denorm denorm;
d419 1
a419 6
  /* XXX: FIXME: Eventually should be CPU model dependent.  */
  if (GETFS())
    denorm = sim_fpu_denorm_zero;
  else
    denorm = 0;
  return denorm;
d422 7
d430 1
a430 1
/* Comparison operations.  */
d432 4
a435 12
static sim_fpu_status
fp_test(unsigned64 op1,
	unsigned64 op2,
	FP_formats fmt,
	int abs,
	int cond,
	int *condition)
{
  sim_fpu wop1;
  sim_fpu wop2;
  sim_fpu_status status = 0;
  int  less, equal, unordered;
d437 1
a437 1
  /* The format type has already been checked:  */
d442 2
d446 1
d451 2
d455 1
d463 6
a468 24
  if (sim_fpu_is_nan (&wop1) || sim_fpu_is_nan (&wop2))
    {
      if ((cond & (1 << 3)) ||
	  sim_fpu_is_snan (&wop1) || sim_fpu_is_snan (&wop2))
	status = sim_fpu_status_invalid_snan;
      less = 0;
      equal = 0;
      unordered = 1;
    }
  else
    {
      if (abs)
	{
	  status |= sim_fpu_abs (&wop1, &wop1);
	  status |= sim_fpu_abs (&wop2, &wop2);
	}
      equal = sim_fpu_is_eq (&wop1, &wop2);
      less = !equal && sim_fpu_is_lt (&wop1, &wop2);
      unordered = 0;
    }
  *condition = (((cond & (1 << 2)) && less)
		|| ((cond & (1 << 1)) && equal)
		|| ((cond & (1 << 0)) && unordered));
  return status;
d471 4
a474 9
void
fp_cmp(sim_cpu *cpu,
       address_word cia,
       unsigned64 op1,
       unsigned64 op2,
       FP_formats fmt,
       int abs,
       int cond,
       int cc)
d476 6
a481 1
  sim_fpu_status status = 0;
d483 1
a483 3
  /* The format type should already have been checked.  The FCSR is
     updated before the condition codes so that any exceptions will
     be signalled before the condition codes are changed.  */
d487 9
d498 6
a503 16
	int result;
	status = fp_test(op1, op2, fmt, abs, cond, &result);
	update_fcsr (cpu, cia, status);
	SETFCC (cc, result);
	break;
      }
    case fmt_ps:
      {
	int result0, result1;
	status  = fp_test(FP_PS_lower (op1), FP_PS_lower (op2), fmt_single,
			  abs, cond, &result0);
	status |= fp_test(FP_PS_upper (op1), FP_PS_upper (op2), fmt_single,
			  abs, cond, &result1);
	update_fcsr (cpu, cia, status);
	SETFCC (cc, result0);
	SETFCC (cc+1, result1);
d507 1
a507 1
      sim_io_eprintf (SD, "Bad switch\n");
d510 2
d514 6
d521 4
a524 15
/* Basic arithmetic operations.  */

static unsigned64
fp_unary(sim_cpu *cpu,
	 address_word cia,
	 int (*sim_fpu_op)(sim_fpu *, const sim_fpu *),
	 unsigned64 op,
	 FP_formats fmt)
{
  sim_fpu wop;
  sim_fpu ans;
  sim_fpu_round round = rounding_mode (GETRM());
  sim_fpu_denorm denorm = denorm_mode (cpu);
  sim_fpu_status status = 0;
  unsigned64 result = 0;
d526 1
a526 1
  /* The format type has already been checked: */
d531 2
a532 1
	unsigned32 res;
d534 3
a536 4
	status |= (*sim_fpu_op) (&ans, &wop);
	status |= sim_fpu_round_32 (&ans, round, denorm);
	sim_fpu_to32 (&res, &ans);
	result = res;
d541 2
a542 1
	unsigned64 res;
d544 3
a546 18
	status |= (*sim_fpu_op) (&ans, &wop);
	status |= sim_fpu_round_64 (&ans, round, denorm);
	sim_fpu_to64 (&res, &ans);
	result = res;
	break;
      }
    case fmt_ps:
      {
	int status_u = 0, status_l = 0;
	unsigned32 res_u, res_l;
	sim_fpu_32to (&wop, FP_PS_upper(op));
	status_u |= (*sim_fpu_op) (&ans, &wop);
	sim_fpu_to32 (&res_u, &ans);
	sim_fpu_32to (&wop, FP_PS_lower(op));
	status_l |= (*sim_fpu_op) (&ans, &wop);
	sim_fpu_to32 (&res_l, &ans);
	result = FP_PS_cat(res_u, res_l);
	status = status_u | status_l;
d550 1
a550 1
      sim_io_eprintf (SD, "Bad switch\n");
d554 1
a554 2
  update_fcsr (cpu, cia, status);
  return result;
d557 5
a561 7
static unsigned64
fp_binary(sim_cpu *cpu,
	  address_word cia,
	  int (*sim_fpu_op)(sim_fpu *, const sim_fpu *, const sim_fpu *),
	  unsigned64 op1,
	  unsigned64 op2,
	  FP_formats fmt)
d563 6
a568 7
  sim_fpu wop1;
  sim_fpu wop2;
  sim_fpu ans;
  sim_fpu_round round = rounding_mode (GETRM());
  sim_fpu_denorm denorm = denorm_mode (cpu);
  sim_fpu_status status = 0;
  unsigned64 result = 0;
d570 4
a573 1
  /* The format type has already been checked: */
d578 3
d584 1
a584 2
	status |= (*sim_fpu_op) (&ans, &wop1, &wop2);
	status |= sim_fpu_round_32 (&ans, round, denorm);
d591 3
d597 1
a597 2
	status |= (*sim_fpu_op) (&ans, &wop1, &wop2);
	status |= sim_fpu_round_64 (&ans, round, denorm);
a601 16
    case fmt_ps:
      {
	int status_u = 0, status_l = 0;
	unsigned32 res_u, res_l;
	sim_fpu_32to (&wop1, FP_PS_upper(op1));
	sim_fpu_32to (&wop2, FP_PS_upper(op2));
	status_u |= (*sim_fpu_op) (&ans, &wop1, &wop2);
	sim_fpu_to32 (&res_u, &ans);
	sim_fpu_32to (&wop1, FP_PS_lower(op1));
	sim_fpu_32to (&wop2, FP_PS_lower(op2));
	status_l |= (*sim_fpu_op) (&ans, &wop1, &wop2);
	sim_fpu_to32 (&res_l, &ans);
	result = FP_PS_cat(res_u, res_l);
	status = status_u | status_l;
	break;
      }
d603 1
a603 1
      sim_io_eprintf (SD, "Bad switch\n");
d607 6
a612 2
  update_fcsr (cpu, cia, status);
  return result;
d615 5
a619 12
/* Common MAC code for single operands (.s or .d), defers setting FCSR.  */
static sim_fpu_status
inner_mac(int (*sim_fpu_op)(sim_fpu *, const sim_fpu *, const sim_fpu *),
	  unsigned64 op1,
	  unsigned64 op2,
	  unsigned64 op3,
	  int scale,
	  int negate,
	  FP_formats fmt,
	  sim_fpu_round round,
	  sim_fpu_denorm denorm,
	  unsigned64 *result)
d621 9
a629 6
  sim_fpu wop1;
  sim_fpu wop2;
  sim_fpu ans;
  sim_fpu_status status = 0;
  sim_fpu_status op_status;
  unsigned64 temp = 0;
d631 1
d636 3
d642 1
a642 17
	status |= sim_fpu_mul (&ans, &wop1, &wop2);
	if (scale != 0 && sim_fpu_is_number (&ans))  /* number or denorm */
	  ans.normal_exp += scale;
	status |= sim_fpu_round_32 (&ans, round, denorm);
	wop1 = ans;
        op_status = 0;
	sim_fpu_32to (&wop2, op3);
	op_status |= (*sim_fpu_op) (&ans, &wop1, &wop2);
	op_status |= sim_fpu_round_32 (&ans, round, denorm);
	status |= op_status;
	if (negate)
	  {
	    wop1 = ans;
	    op_status = sim_fpu_neg (&ans, &wop1);
	    op_status |= sim_fpu_round_32 (&ans, round, denorm);
	    status |= op_status;
	  }
d644 1
a644 2
	temp = res;
	break;
d646 1
d649 3
d655 1
a655 17
	status |= sim_fpu_mul (&ans, &wop1, &wop2);
	if (scale != 0 && sim_fpu_is_number (&ans))  /* number or denorm */
	  ans.normal_exp += scale;
	status |= sim_fpu_round_64 (&ans, round, denorm);
	wop1 = ans;
        op_status = 0;
	sim_fpu_64to (&wop2, op3);
	op_status |= (*sim_fpu_op) (&ans, &wop1, &wop2);
	op_status |= sim_fpu_round_64 (&ans, round, denorm);
	status |= op_status;
	if (negate)
	  {
	    wop1 = ans;
	    op_status = sim_fpu_neg (&ans, &wop1);
	    op_status |= sim_fpu_round_64 (&ans, round, denorm);
	    status |= op_status;
	  }
d657 1
a657 2
	temp = res;
	break;
d659 1
d664 7
a670 2
  *result = temp;
  return status;
d673 5
a677 16
/* Common implementation of madd, nmadd, msub, nmsub that does
   intermediate rounding per spec.  Also used for recip2 and rsqrt2,
   which are transformed into equivalent nmsub operations.  The scale
   argument is an adjustment to the exponent of the intermediate
   product op1*op2.  It is currently non-zero for rsqrt2 (-1), which
   requires an effective division by 2. */
static unsigned64
fp_mac(sim_cpu *cpu,
       address_word cia,
       int (*sim_fpu_op)(sim_fpu *, const sim_fpu *, const sim_fpu *),
       unsigned64 op1,
       unsigned64 op2,
       unsigned64 op3,
       int scale,
       int negate,
       FP_formats fmt)
d679 1
a679 4
  sim_fpu_round round = rounding_mode (GETRM());
  sim_fpu_denorm denorm = denorm_mode (cpu);
  sim_fpu_status status = 0;
  unsigned64 result = 0;
d681 4
a684 26
  /* The format type has already been checked: */
  switch (fmt)
    {
    case fmt_single:
    case fmt_double:
      status = inner_mac(sim_fpu_op, op1, op2, op3, scale,
			 negate, fmt, round, denorm, &result);
      break;
    case fmt_ps:
      {
	int status_u, status_l;
	unsigned64 result_u, result_l;
	status_u = inner_mac(sim_fpu_op, FP_PS_upper(op1), FP_PS_upper(op2),
			     FP_PS_upper(op3), scale, negate, fmt_single,
			     round, denorm, &result_u);
	status_l = inner_mac(sim_fpu_op, FP_PS_lower(op1), FP_PS_lower(op2),
			     FP_PS_lower(op3), scale, negate, fmt_single,
			     round, denorm, &result_l);
	result = FP_PS_cat(result_u, result_l);
	status = status_u | status_l;
	break;
      }
    default:
      sim_io_eprintf (SD, "Bad switch\n");
      abort ();
    }
d686 2
a687 17
  update_fcsr (cpu, cia, status);
  return result;
}

/* Common rsqrt code for single operands (.s or .d), intermediate rounding.  */
static sim_fpu_status
inner_rsqrt(unsigned64 op1,
	    FP_formats fmt,
	    sim_fpu_round round,
	    sim_fpu_denorm denorm,
	    unsigned64 *result)
{
  sim_fpu wop1;
  sim_fpu ans;
  sim_fpu_status status = 0;
  sim_fpu_status op_status;
  unsigned64 temp = 0;
d689 1
d694 3
d699 2
a700 5
	status |= sim_fpu_sqrt (&ans, &wop1);
	status |= sim_fpu_round_32 (&ans, status, round);
	wop1 = ans;
	op_status = sim_fpu_inv (&ans, &wop1);
	op_status |= sim_fpu_round_32 (&ans, round, denorm);
d702 1
a702 2
	temp = res;
	status |= op_status;
d707 3
d712 2
a713 5
	status |= sim_fpu_sqrt (&ans, &wop1);
	status |= sim_fpu_round_64 (&ans, round, denorm);
	wop1 = ans;
	op_status = sim_fpu_inv (&ans, &wop1);
	op_status |= sim_fpu_round_64 (&ans, round, denorm);
d715 1
a715 2
	temp = res;
	status |= op_status;
d722 7
a728 2
  *result = temp;
  return status;
d731 5
a735 5
static unsigned64
fp_inv_sqrt(sim_cpu *cpu,
	    address_word cia,
	    unsigned64 op1,
	    FP_formats fmt)
d737 1
a737 4
  sim_fpu_round round = rounding_mode (GETRM());
  sim_fpu_round denorm = denorm_mode (cpu);
  sim_fpu_status status = 0;
  unsigned64 result = 0;
d739 9
a747 1
  /* The format type has already been checked: */
d751 12
a763 3
      status = inner_rsqrt (op1, fmt, round, denorm, &result);
      break;
    case fmt_ps:
d765 9
a773 8
	int status_u, status_l;
	unsigned64 result_u, result_l;
	status_u = inner_rsqrt (FP_PS_upper(op1), fmt_single, round, denorm,
				&result_u);
	status_l = inner_rsqrt (FP_PS_lower(op1), fmt_single, round, denorm,
				&result_l);
	result = FP_PS_cat(result_u, result_l);
	status = status_u | status_l;
d777 1
a777 1
      sim_io_eprintf (SD, "Bad switch\n");
d781 4
a784 4
  update_fcsr (cpu, cia, status);
  return result;
}

d786 1
a786 7
unsigned64
fp_abs(sim_cpu *cpu,
       address_word cia,
       unsigned64 op,
       FP_formats fmt)
{
  return fp_unary(cpu, cia, &sim_fpu_abs, op, fmt);
d789 4
a792 5
unsigned64
fp_neg(sim_cpu *cpu,
       address_word cia,
       unsigned64 op,
       FP_formats fmt)
d794 1
a794 2
  return fp_unary(cpu, cia, &sim_fpu_neg, op, fmt);
}
d796 4
a799 9
unsigned64
fp_add(sim_cpu *cpu,
       address_word cia,
       unsigned64 op1,
       unsigned64 op2,
       FP_formats fmt)
{
  return fp_binary(cpu, cia, &sim_fpu_add, op1, op2, fmt);
}
d801 2
a802 9
unsigned64
fp_sub(sim_cpu *cpu,
       address_word cia,
       unsigned64 op1,
       unsigned64 op2,
       FP_formats fmt)
{
  return fp_binary(cpu, cia, &sim_fpu_sub, op1, op2, fmt);
}
d804 29
a832 9
unsigned64
fp_mul(sim_cpu *cpu,
       address_word cia,
       unsigned64 op1,
       unsigned64 op2,
       FP_formats fmt)
{
  return fp_binary(cpu, cia, &sim_fpu_mul, op1, op2, fmt);
}
d834 4
a837 9
unsigned64
fp_div(sim_cpu *cpu,
       address_word cia,
       unsigned64 op1,
       unsigned64 op2,
       FP_formats fmt)
{
  return fp_binary(cpu, cia, &sim_fpu_div, op1, op2, fmt);
}
d839 1
a839 7
unsigned64
fp_recip(sim_cpu *cpu,
         address_word cia,
         unsigned64 op,
         FP_formats fmt)
{
  return fp_unary(cpu, cia, &sim_fpu_inv, op, fmt);
d842 4
a845 5
unsigned64
fp_sqrt(sim_cpu *cpu,
        address_word cia,
        unsigned64 op,
        FP_formats fmt)
d847 1
a847 2
  return fp_unary(cpu, cia, &sim_fpu_sqrt, op, fmt);
}
d849 4
a852 8
unsigned64
fp_rsqrt(sim_cpu *cpu,
         address_word cia,
         unsigned64 op,
         FP_formats fmt)
{
  return fp_inv_sqrt(cpu, cia, op, fmt);
}
d854 2
a855 10
unsigned64
fp_madd(sim_cpu *cpu,
        address_word cia,
        unsigned64 op1,
        unsigned64 op2,
        unsigned64 op3,
        FP_formats fmt)
{
  return fp_mac(cpu, cia, &sim_fpu_add, op1, op2, op3, 0, 0, fmt);
}
d857 29
a885 10
unsigned64
fp_msub(sim_cpu *cpu,
        address_word cia,
        unsigned64 op1,
        unsigned64 op2,
        unsigned64 op3,
        FP_formats fmt)
{
  return fp_mac(cpu, cia, &sim_fpu_sub, op1, op2, op3, 0, 0, fmt);
}
d887 4
a890 10
unsigned64
fp_nmadd(sim_cpu *cpu,
         address_word cia,
         unsigned64 op1,
         unsigned64 op2,
         unsigned64 op3,
         FP_formats fmt)
{
  return fp_mac(cpu, cia, &sim_fpu_add, op1, op2, op3, 0, 1, fmt);
}
d892 1
a892 9
unsigned64
fp_nmsub(sim_cpu *cpu,
         address_word cia,
         unsigned64 op1,
         unsigned64 op2,
         unsigned64 op3,
         FP_formats fmt)
{
  return fp_mac(cpu, cia, &sim_fpu_sub, op1, op2, op3, 0, 1, fmt);
d895 5
a899 10

/* MIPS-3D ASE operations.  */

/* Variant of fp_binary for *r.ps MIPS-3D operations. */
static unsigned64
fp_binary_r(sim_cpu *cpu,
	    address_word cia,
	    int (*sim_fpu_op)(sim_fpu *, const sim_fpu *, const sim_fpu *),
	    unsigned64 op1,
	    unsigned64 op2) 
d901 1
a901 6
  sim_fpu wop1;
  sim_fpu wop2;
  sim_fpu ans;
  sim_fpu_round round = rounding_mode (GETRM ());
  sim_fpu_denorm denorm = denorm_mode (cpu);
  sim_fpu_status status_u, status_l;
a902 1
  unsigned32 res_u, res_l;
d904 4
a907 14
  /* The format must be fmt_ps.  */
  status_u = 0;
  sim_fpu_32to (&wop1, FP_PS_upper (op1));
  sim_fpu_32to (&wop2, FP_PS_lower (op1));
  status_u |= (*sim_fpu_op) (&ans, &wop1, &wop2);
  status_u |= sim_fpu_round_32 (&ans, round, denorm);
  sim_fpu_to32 (&res_u, &ans);
  status_l = 0;
  sim_fpu_32to (&wop1, FP_PS_upper (op2));
  sim_fpu_32to (&wop2, FP_PS_lower (op2));
  status_l |= (*sim_fpu_op) (&ans, &wop1, &wop2);
  status_l |= sim_fpu_round_32 (&ans, round, denorm);
  sim_fpu_to32 (&res_l, &ans);
  result = FP_PS_cat (res_u, res_l);
d909 2
a910 3
  update_fcsr (cpu, cia, status_u | status_l);
  return result;
}
d912 1
a912 78
unsigned64
fp_add_r(sim_cpu *cpu,
         address_word cia,
         unsigned64 op1,
         unsigned64 op2,
         FP_formats fmt)
{
  return fp_binary_r (cpu, cia, &sim_fpu_add, op1, op2);
}

unsigned64
fp_mul_r(sim_cpu *cpu,
         address_word cia,
         unsigned64 op1,
         unsigned64 op2,
         FP_formats fmt)
{
  return fp_binary_r (cpu, cia, &sim_fpu_mul, op1, op2);
}

#define NR_FRAC_GUARD   (60)
#define IMPLICIT_1 LSBIT64 (NR_FRAC_GUARD)

static int
fpu_inv1(sim_fpu *f, const sim_fpu *l)
{
  static const sim_fpu sim_fpu_one = {
    sim_fpu_class_number, 0, IMPLICIT_1, 0
  };
  int  status = 0;
  sim_fpu t;

  if (sim_fpu_is_zero (l))
    {
      *f = sim_fpu_maxfp;
      f->sign = l->sign;
      return sim_fpu_status_invalid_div0;
    }
  if (sim_fpu_is_infinity (l))
    {
      *f = sim_fpu_zero;
      f->sign = l->sign;
      return status;
    }
  status |= sim_fpu_div (f, &sim_fpu_one, l);
  return status;
}

static int
fpu_inv1_32(sim_fpu *f, const sim_fpu *l)
{
  if (sim_fpu_is_zero (l))
    {
      *f = sim_fpu_max32;
      f->sign = l->sign;
      return sim_fpu_status_invalid_div0;
    }
  return fpu_inv1 (f, l);
}

static int
fpu_inv1_64(sim_fpu *f, const sim_fpu *l)
{
  if (sim_fpu_is_zero (l))
    {
      *f = sim_fpu_max64;
      f->sign = l->sign;
      return sim_fpu_status_invalid_div0;
    }
  return fpu_inv1 (f, l);
}

unsigned64
fp_recip1(sim_cpu *cpu,
          address_word cia,
          unsigned64 op,
          FP_formats fmt)
{
d916 8
a923 2
    case fmt_ps:
      return fp_unary (cpu, cia, &fpu_inv1_32, op, fmt);
d925 11
a935 1
      return fp_unary (cpu, cia, &fpu_inv1_64, op, fmt);
a936 2
  return 0;
}
d938 1
a938 14
unsigned64
fp_recip2(sim_cpu *cpu,
          address_word cia,
          unsigned64 op1,
          unsigned64 op2,
          FP_formats fmt)
{
  static const unsigned64 one_single = UNSIGNED64 (0x3F800000);
  static const unsigned64 one_double = UNSIGNED64 (0x3FF0000000000000);
  static const unsigned64 one_ps = (one_single << 32 | one_single);
  unsigned64 one;

  /* Implemented as nmsub fd, 1, fs, ft.  */
  switch (fmt)
d940 16
a955 4
    case fmt_single:  one = one_single;  break;
    case fmt_double:  one = one_double;  break;
    case fmt_ps:      one = one_ps;      break;
    default:          one = 0;           abort ();
a956 2
  return fp_mac (cpu, cia, &sim_fpu_sub, op1, op2, one, 0, 1, fmt);
}
d958 4
a961 8
static int
fpu_inv_sqrt1(sim_fpu *f, const sim_fpu *l)
{
  static const sim_fpu sim_fpu_one = {
    sim_fpu_class_number, 0, IMPLICIT_1, 0
  };
  int  status = 0;
  sim_fpu t;
d963 1
a963 23
  if (sim_fpu_is_zero (l))
    {
      *f = sim_fpu_maxfp;
      f->sign = l->sign;
      return sim_fpu_status_invalid_div0;
    }
  if (sim_fpu_is_infinity (l))
    {
      if (!l->sign)
	{
	  f->class = sim_fpu_class_zero;
	  f->sign = 0;
	}
      else
	{
	  *f = sim_fpu_qnan;
	  status = sim_fpu_status_invalid_sqrt;
	}
      return status;
    }
  status |= sim_fpu_sqrt (&t, l);
  status |= sim_fpu_div (f, &sim_fpu_one, &t);
  return status;
d965 1
d967 5
a971 2
static int
fpu_inv_sqrt1_32(sim_fpu *f, const sim_fpu *l)
d973 7
a979 8
  if (sim_fpu_is_zero (l))
    {
      *f = sim_fpu_max32;
      f->sign = l->sign;
      return sim_fpu_status_invalid_div0;
    }
  return fpu_inv_sqrt1 (f, l);
}
d981 2
a982 11
static int
fpu_inv_sqrt1_64(sim_fpu *f, const sim_fpu *l)
{
  if (sim_fpu_is_zero (l))
    {
      *f = sim_fpu_max64;
      f->sign = l->sign;
      return sim_fpu_status_invalid_div0;
    }
  return fpu_inv_sqrt1 (f, l);
}
d984 1
a984 6
unsigned64
fp_rsqrt1(sim_cpu *cpu,
          address_word cia,
          unsigned64 op,
          FP_formats fmt)
{
d988 8
a995 2
    case fmt_ps:
      return fp_unary (cpu, cia, &fpu_inv_sqrt1_32, op, fmt);
d997 11
a1007 1
      return fp_unary (cpu, cia, &fpu_inv_sqrt1_64, op, fmt);
a1008 2
  return 0;
}
d1010 1
a1010 15
unsigned64
fp_rsqrt2(sim_cpu *cpu,
          address_word cia,
          unsigned64 op1,
          unsigned64 op2,
          FP_formats fmt)
{
  static const unsigned64 half_single = UNSIGNED64 (0x3F000000);
  static const unsigned64 half_double = UNSIGNED64 (0x3FE0000000000000);
  static const unsigned64 half_ps = (half_single << 32 | half_single);
  unsigned64 half;

  /* Implemented as (nmsub fd, 0.5, fs, ft)/2, where the divide is
     done by scaling the exponent during multiply.  */
  switch (fmt)
d1012 16
a1027 4
    case fmt_single:  half = half_single;  break;
    case fmt_double:  half = half_double;  break;
    case fmt_ps:      half = half_ps;      break;
    default:          half = 0;            abort ();
a1028 2
  return fp_mac (cpu, cia, &sim_fpu_sub, op1, op2, half, -1, 1, fmt);
}
d1030 4
d1035 3
a1037 1
/* Conversion operations.  */
d1040 2
a1041 1
convert (sim_cpu *cpu,
d1049 1
a1049 2
  sim_fpu_round round = rounding_mode (rm);
  sim_fpu_denorm denorm = denorm_mode (cpu);
d1052 38
a1089 1
  sim_fpu_status status = 0;
d1101 1
a1101 1
      status = sim_fpu_i32to (&wop, op, round);
d1104 1
a1104 1
      status = sim_fpu_i64to (&wop, op, round);
d1107 1
a1107 1
      sim_io_eprintf (SD, "Bad switch\n");
d1115 2
a1116 2
     integer outside the fixed point range then an IEEE Invalid Operation
     condition is raised.  Not used if destination format is PS.  */
d1120 1
a1120 4
      status |= sim_fpu_round_32 (&wop, round, denorm);
      /* For a NaN, normalize mantissa bits (cvt.s.d can't preserve them) */
      if (sim_fpu_is_qnan (&wop))
	wop = sim_fpu_qnan;
d1125 1
a1125 4
      status |= sim_fpu_round_64 (&wop, round, denorm);
      /* For a NaN, normalize mantissa bits (make cvt.d.s consistent) */
      if (sim_fpu_is_qnan (&wop))
	wop = sim_fpu_qnan;
d1129 1
a1129 1
      status |= sim_fpu_to32i (&result32, &wop, round);
d1133 1
a1133 1
      status |= sim_fpu_to64i (&result64, &wop, round);
d1137 1
a1137 1
      sim_io_eprintf (SD, "Bad switch\n");
d1141 4
a1144 107
  update_fcsr (cpu, cia, status);
  return result64;
}

unsigned64
ps_lower(sim_cpu *cpu,
         address_word cia,
         unsigned64 op)
{
  return FP_PS_lower (op);
}

unsigned64
ps_upper(sim_cpu *cpu,
         address_word cia,
         unsigned64 op)
{
  return FP_PS_upper(op);
}

unsigned64
pack_ps(sim_cpu *cpu,
        address_word cia,
        unsigned64 op1,
        unsigned64 op2,
        FP_formats fmt)
{
  unsigned64 result = 0;

  /* The registers must specify FPRs valid for operands of type
     "fmt". If they are not valid, the result is undefined. */

  /* The format type should already have been checked: */
  switch (fmt)
    {
    case fmt_single:
      {
	sim_fpu wop;
	unsigned32 res_u, res_l;
	sim_fpu_32to (&wop, op1);
	sim_fpu_to32 (&res_u, &wop);
	sim_fpu_32to (&wop, op2);
	sim_fpu_to32 (&res_l, &wop);
	result = FP_PS_cat(res_u, res_l);
	break;
      }
    default:
      sim_io_eprintf (SD, "Bad switch\n");
      abort ();
    }

  return result;
}

unsigned64
convert_ps (sim_cpu *cpu,
            address_word cia,
            int rm,
            unsigned64 op,
            FP_formats from,
            FP_formats to)
{
  sim_fpu wop_u, wop_l;
  sim_fpu_round round = rounding_mode (rm);
  sim_fpu_denorm denorm = denorm_mode (cpu);
  unsigned32 res_u, res_l;
  unsigned64 result;
  sim_fpu_status status_u = 0, status_l = 0;

  /* As convert, but used only for paired values (formats PS, PW) */

  /* Convert the input to sim_fpu internal format */
  switch (from)
    {
    case fmt_word:   /* fmt_pw */
      sim_fpu_i32to (&wop_u, (op >> 32) & (unsigned)0xFFFFFFFF, round);
      sim_fpu_i32to (&wop_l, op & (unsigned)0xFFFFFFFF, round);
      break;
    case fmt_ps:
      sim_fpu_32to (&wop_u, FP_PS_upper(op));
      sim_fpu_32to (&wop_l, FP_PS_lower(op));
      break;
    default:
      sim_io_eprintf (SD, "Bad switch\n");
      abort ();
    }

  /* Convert sim_fpu format into the output */
  switch (to)
    {
    case fmt_word:   /* fmt_pw */
      status_u |= sim_fpu_to32i (&res_u, &wop_u, round);
      status_l |= sim_fpu_to32i (&res_l, &wop_l, round);
      result = (((unsigned64)res_u) << 32) | (unsigned64)res_l;
      break;
    case fmt_ps:
      status_u |= sim_fpu_round_32 (&wop_u, 0, round);
      status_l |= sim_fpu_round_32 (&wop_l, 0, round);
      sim_fpu_to32 (&res_u, &wop_u);
      sim_fpu_to32 (&res_l, &wop_l);
      result = FP_PS_cat(res_u, res_l);
      break;
    default:
      result = 0;
      sim_io_eprintf (SD, "Bad switch\n");
      abort ();
    }
d1146 1
a1146 2
  update_fcsr (cpu, cia, status_u | status_l);
  return result;
a1161 2
    case fmt_ps:
      return "ps";
@


1.4
log
@2002-03-19  Chris Demetriou  <cgd@@broadcom.com>

        * cp1.c (FP_S_s, FP_D_s, FP_S_be, FP_D_be, FP_S_e, FP_D_e, FP_S_f)
        (FP_D_f, FP_S_fb, FP_D_fb, FPINF_SINGLE, FPINF_DOUBLE): Remove
        unused definitions.
@
text
@a281 4
#if defined(WARN_RESULT)
  else
    UndefinedResult ();
#endif /* WARN_RESULT */
@


1.3
log
@2002-03-19  Chris Demetriou  <cgd@@broadcom.com>

        * cp1.c: Fix many formatting issues.
@
text
@a52 16
/* Extract sign-bit:  */
#define FP_S_s(v)       (((v) & (((unsigned) 1) << 31)) ? 1 : 0)
#define FP_D_s(v)       (((v) & (((uword64) 1) << 63)) ? 1 : 0)
/* Extract biased exponent:  */
#define FP_S_be(v)      (((v) >> 23) & 0xFF)
#define FP_D_be(v)      (((v) >> 52) & 0x7FF)
/* Extract unbiased Exponent:  */
#define FP_S_e(v)       (FP_S_be (v) - 0x7F)
#define FP_D_e(v)       (FP_D_be (v) - 0x3FF)
/* Extract complete fraction field:  */
#define FP_S_f(v)       ((v) & ~(((unsigned) 0x1FF) << 23))
#define FP_D_f(v)       ((v) & ~(((uword64) 0xFFF) << 52))
/* Extract numbered fraction bit:  */
#define FP_S_fb(b, v)   (((v) & (1 << (23 - (b)))) ? 1 : 0)
#define FP_D_fb(b, v)   (((v) & (1 << (52 - (b)))) ? 1 : 0)

a57 4

/* Explicit Infinity values used when required:  */
#define FPINF_SINGLE    (0x7F800000)
#define FPINF_DOUBLE    ((((uword64) 0x7FF00000) << 32) | 0x00000000)
@


1.2
log
@2002-03-19  Chris G. Demetriou  <cgd@@broadcom.com>

        * cp1.c (fpu_format_name): New function to replace...
        (DOFMT): This.  Delete, and update all callers.
        (fpu_rounding_mode_name): New function to replace...
        (RMMODE): This.  Delete, and update all callers.
@
text
@d29 1
a29 1
   formats conform to ANSI/IEEE Std 754-1985. */
d53 15
a67 15
/* Extract sign-bit: */
#define FP_S_s(v)    (((v) & ((unsigned)1 << 31)) ? 1 : 0)
#define FP_D_s(v)    (((v) & ((uword64)1 << 63)) ? 1 : 0)
/* Extract biased exponent: */
#define FP_S_be(v)   (((v) >> 23) & 0xFF)
#define FP_D_be(v)   (((v) >> 52) & 0x7FF)
/* Extract unbiased Exponent: */
#define FP_S_e(v)    (FP_S_be(v) - 0x7F)
#define FP_D_e(v)    (FP_D_be(v) - 0x3FF)
/* Extract complete fraction field: */
#define FP_S_f(v)    ((v) & ~((unsigned)0x1FF << 23))
#define FP_D_f(v)    ((v) & ~((uword64)0xFFF << 52))
/* Extract numbered fraction bit: */
#define FP_S_fb(b,v) (((v) & (1 << (23 - (b)))) ? 1 : 0)
#define FP_D_fb(b,v) (((v) & (1 << (52 - (b)))) ? 1 : 0)
d69 1
a69 1
/* Explicit QNaN values used when value required: */
d72 2
a73 2
#define FPQNaN_DOUBLE   (((uword64)0x7FF7FFFF << 32) | 0xFFFFFFFF)
#define FPQNaN_LONG     (((uword64)0x7FFFFFFF << 32) | 0xFFFFFFFF)
d75 1
a75 1
/* Explicit Infinity values used when required: */
d77 1
a77 1
#define FPINF_DOUBLE    (((uword64)0x7FF00000 << 32) | 0x00000000)
d94 1
a94 1
  /* Treat unused register values, as fixed-point 64bit values: */
d96 1
d98 3
a100 3
   /* If request to read data as "uninterpreted", then use the current
      encoding: */
   fmt = FPR_STATE[fpr];
d102 1
a102 1
   fmt = fmt_long;
d104 1
d106 16
a121 18
  /* For values not yet accessed, set to the desired format: */
  if (FPR_STATE[fpr] == fmt_uninterpreted) {
    FPR_STATE[fpr] = fmt;
#ifdef DEBUG
    printf("DBG: Register %d was fmt_uninterpreted. Now %s\n",fpr, fpu_format_name (fmt));
#endif /* DEBUG */
  }
  if (fmt != FPR_STATE[fpr]) {
    sim_io_eprintf(sd,"FPR %d (format %s) being accessed with format %s - setting to unknown (PC = 0x%s)\n",fpr, fpu_format_name (FPR_STATE[fpr]), fpu_format_name (fmt),pr_addr(cia));
    FPR_STATE[fpr] = fmt_unknown;
  }

  if (FPR_STATE[fpr] == fmt_unknown) {
   /* Set QNaN value: */
   switch (fmt) {
    case fmt_single:
     value = FPQNaN_SINGLE;
     break;
d123 8
a130 3
    case fmt_double:
     value = FPQNaN_DOUBLE;
     break;
d132 3
a134 3
    case fmt_word:
     value = FPQNaN_WORD;
     break;
d136 3
a138 3
    case fmt_long:
     value = FPQNaN_LONG;
     break;
d140 3
a142 10
    default:
     err = -1;
     break;
   }
  } else if (SizeFGR() == 64) {
    switch (fmt) {
     case fmt_single:
     case fmt_word:
      value = (FGR[fpr] & 0xFFFFFFFF);
      break;
d144 24
a167 9
     case fmt_uninterpreted:
     case fmt_double:
     case fmt_long:
      value = FGR[fpr];
      break;

     default :
      err = -1;
      break;
d169 19
a187 15
  } else {
    switch (fmt) {
     case fmt_single:
     case fmt_word:
      value = (FGR[fpr] & 0xFFFFFFFF);
      break;

     case fmt_uninterpreted:
     case fmt_double:
     case fmt_long:
      if ((fpr & 1) == 0) { /* even registers only */
#ifdef DEBUG
	printf("DBG: ValueFPR: FGR[%d] = %s, FGR[%d] = %s\n", 
	       fpr+1, pr_uword64( (uword64) FGR[fpr+1] ),
	       fpr, pr_uword64( (uword64) FGR[fpr] ));
d189 13
a201 9
	value = ((((uword64)FGR[fpr+1]) << 32) | (FGR[fpr] & 0xFFFFFFFF));
      } else {
	SignalException(ReservedInstruction,0);
      }
      break;

     default :
      err = -1;
      break;
a202 1
  }
d205 1
a205 1
   SignalExceptionSimulatorFault ("Unrecognised FP format in ValueFPR()");
d208 3
a210 1
  printf("DBG: ValueFPR: fpr = %d, fmt = %s, value = 0x%s : PC = 0x%s : SizeFGR() = %d\n",fpr, fpu_format_name (fmt),pr_uword64(value),pr_addr(cia),SizeFGR());
d213 1
a213 1
  return(value);
d227 29
a255 2
  printf("DBG: StoreFPR: fpr = %d, fmt = %s, value = 0x%s : PC = 0x%s : SizeFGR() = %d,\n",fpr, fpu_format_name (fmt),pr_uword64(value),pr_addr(cia),SizeFGR());
#endif /* DEBUG */
d257 14
a270 44
  if (SizeFGR() == 64) {
    switch (fmt) {
      case fmt_uninterpreted_32:
	fmt = fmt_uninterpreted;
      case fmt_single :
      case fmt_word :
       if (STATE_VERBOSE_P(SD))
         sim_io_eprintf (SD, "Warning: PC 0x%s: interp.c store_fpr DEADCODE\n",
	   pr_addr(cia));
       FGR[fpr] = (((uword64)0xDEADC0DE << 32) | (value & 0xFFFFFFFF));
       FPR_STATE[fpr] = fmt;
       break;

      case fmt_uninterpreted_64:
	fmt = fmt_uninterpreted;
      case fmt_uninterpreted:
      case fmt_double :
      case fmt_long :
       FGR[fpr] = value;
       FPR_STATE[fpr] = fmt;
       break;

      default :
       FPR_STATE[fpr] = fmt_unknown;
       err = -1;
       break;
    }
  } else {
    switch (fmt) {
      case fmt_uninterpreted_32:
	fmt = fmt_uninterpreted;
      case fmt_single :
      case fmt_word :
       FGR[fpr] = (value & 0xFFFFFFFF);
       FPR_STATE[fpr] = fmt;
       break;

      case fmt_uninterpreted_64:
	fmt = fmt_uninterpreted;
      case fmt_uninterpreted:
      case fmt_double :
      case fmt_long :
	if ((fpr & 1) == 0) { /* even register number only */
	  FGR[fpr+1] = (value >> 32);
a271 1
	  FPR_STATE[fpr + 1] = fmt;
d273 24
a296 1
	} else {
d298 2
a299 2
	  FPR_STATE[fpr + 1] = fmt_unknown;
	  SignalException(ReservedInstruction,0);
a300 6
       break;

      default :
       FPR_STATE[fpr] = fmt_unknown;
       err = -1;
       break;
a301 1
  }
d304 1
a304 1
    UndefinedResult();
d308 1
a308 1
   SignalExceptionSimulatorFault ("Unrecognised FP format in StoreFPR()");
d311 2
a312 1
  printf("DBG: StoreFPR: fpr[%d] = 0x%s (format %s)\n",fpr,pr_uword64(FGR[fpr]), fpu_format_name (fmt));
d319 1
a319 1
NaN(op,fmt)
d321 1
a321 1
     FP_formats fmt; 
d324 1
a324 3
  switch (fmt) {
   case fmt_single:
   case fmt_word:
d326 19
a344 4
      sim_fpu wop;
      sim_fpu_32to (&wop, op);
      boolean = sim_fpu_is_nan (&wop);
      break;
a345 12
   case fmt_double:
   case fmt_long:
    {
      sim_fpu wop;
      sim_fpu_64to (&wop, op);
      boolean = sim_fpu_is_nan (&wop);
      break;
    }
   default:
    fprintf (stderr, "Bad switch\n");
    abort ();
  }
d348 2
a349 1
printf("DBG: NaN: returning %d for 0x%s (format = %s)\n",boolean,pr_addr(op), fpu_format_name (fmt));
d352 1
a352 1
  return(boolean);
d356 1
a356 1
Infinity(op,fmt)
d358 1
a358 1
     FP_formats fmt; 
d363 2
a364 1
  printf("DBG: Infinity: format %s 0x%s\n", fpu_format_name (fmt),pr_addr(op));
d367 1
a367 2
  switch (fmt) {
   case fmt_single:
d369 17
a385 3
      sim_fpu wop;
      sim_fpu_32to (&wop, op);
      boolean = sim_fpu_is_infinity (&wop);
a387 11
   case fmt_double:
    {
      sim_fpu wop;
      sim_fpu_64to (&wop, op);
      boolean = sim_fpu_is_infinity (&wop);
      break;
    }
   default:
    printf("DBG: TODO: unrecognised format (%s) for Infinity check\n", fpu_format_name (fmt));
    break;
  }
d390 2
a391 1
  printf("DBG: Infinity: returning %d for 0x%s (format = %s)\n",boolean,pr_addr(op), fpu_format_name (fmt));
d394 1
a394 1
  return(boolean);
d398 1
a398 1
Less(op1,op2,fmt)
d401 1
a401 1
     FP_formats fmt; 
d408 2
a409 1
  printf("DBG: Less: %s: op1 = 0x%s : op2 = 0x%s\n", fpu_format_name (fmt),pr_addr(op1),pr_addr(op2));
d412 2
a413 12
  /* The format type should already have been checked: */
  switch (fmt) {
   case fmt_single:
    {
      sim_fpu wop1;
      sim_fpu wop2;
      sim_fpu_32to (&wop1, op1);
      sim_fpu_32to (&wop2, op2);
      boolean = sim_fpu_is_lt (&wop1, &wop2);
      break;
    }
   case fmt_double:
d415 21
a435 6
      sim_fpu wop1;
      sim_fpu wop2;
      sim_fpu_64to (&wop1, op1);
      sim_fpu_64to (&wop2, op2);
      boolean = sim_fpu_is_lt (&wop1, &wop2);
      break;
a436 4
   default:
    fprintf (stderr, "Bad switch\n");
    abort ();
  }
d439 2
a440 1
  printf("DBG: Less: returning %d (format = %s)\n",boolean, fpu_format_name (fmt));
d443 1
a443 1
  return(boolean);
d447 1
a447 1
Equal(op1,op2,fmt)
d450 1
a450 1
     FP_formats fmt; 
d457 2
a458 1
  printf("DBG: Equal: %s: op1 = 0x%s : op2 = 0x%s\n", fpu_format_name (fmt),pr_addr(op1),pr_addr(op2));
d461 2
a462 12
  /* The format type should already have been checked: */
  switch (fmt) {
   case fmt_single:
    {
      sim_fpu wop1;
      sim_fpu wop2;
      sim_fpu_32to (&wop1, op1);
      sim_fpu_32to (&wop2, op2);
      boolean = sim_fpu_is_eq (&wop1, &wop2);
      break;
    }
   case fmt_double:
d464 21
a484 6
      sim_fpu wop1;
      sim_fpu wop2;
      sim_fpu_64to (&wop1, op1);
      sim_fpu_64to (&wop2, op2);
      boolean = sim_fpu_is_eq (&wop1, &wop2);
      break;
a485 4
   default:
    fprintf (stderr, "Bad switch\n");
    abort ();
  }
d488 2
a489 1
  printf("DBG: Equal: returning %d (format = %s)\n",boolean, fpu_format_name (fmt));
d492 1
a492 1
  return(boolean);
d496 1
a496 1
AbsoluteValue(op,fmt)
d498 1
a498 1
     FP_formats fmt; 
d503 2
a504 1
  printf("DBG: AbsoluteValue: %s: op = 0x%s\n", fpu_format_name (fmt),pr_addr(op));
d507 2
a508 3
  /* The format type should already have been checked: */
  switch (fmt) {
   case fmt_single:
d510 23
a532 17
      sim_fpu wop;
      unsigned32 ans;
      sim_fpu_32to (&wop, op);
      sim_fpu_abs (&wop, &wop);
      sim_fpu_to32 (&ans, &wop);
      result = ans;
      break;
    }
   case fmt_double:
    {
      sim_fpu wop;
      unsigned64 ans;
      sim_fpu_64to (&wop, op);
      sim_fpu_abs (&wop, &wop);
      sim_fpu_to64 (&ans, &wop);
      result = ans;
      break;
a533 4
   default:
    fprintf (stderr, "Bad switch\n");
    abort ();
  }
d535 1
a535 1
  return(result);
d539 1
a539 1
Negate(op,fmt)
d541 1
a541 1
     FP_formats fmt; 
d546 2
a547 1
  printf("DBG: Negate: %s: op = 0x%s\n", fpu_format_name (fmt),pr_addr(op));
d550 2
a551 3
  /* The format type should already have been checked: */
  switch (fmt) {
   case fmt_single:
d553 23
a575 7
      sim_fpu wop;
      unsigned32 ans;
      sim_fpu_32to (&wop, op);
      sim_fpu_neg (&wop, &wop);
      sim_fpu_to32 (&ans, &wop);
      result = ans;
      break;
a576 14
   case fmt_double:
    {
      sim_fpu wop;
      unsigned64 ans;
      sim_fpu_64to (&wop, op);
      sim_fpu_neg (&wop, &wop);
      sim_fpu_to64 (&ans, &wop);
      result = ans;
      break;
    }
   default:
    fprintf (stderr, "Bad switch\n");
    abort ();
  }
d578 1
a578 1
  return(result);
d582 1
a582 1
Add(op1,op2,fmt)
d585 1
a585 1
     FP_formats fmt; 
d590 2
a591 1
  printf("DBG: Add: %s: op1 = 0x%s : op2 = 0x%s\n", fpu_format_name (fmt),pr_addr(op1),pr_addr(op2));
d595 4
a598 18
     "fmt". If they are not valid, the result is undefined. */

  /* The format type should already have been checked: */
  switch (fmt) {
   case fmt_single:
    {
      sim_fpu wop1;
      sim_fpu wop2;
      sim_fpu ans;
      unsigned32 res;
      sim_fpu_32to (&wop1, op1);
      sim_fpu_32to (&wop2, op2);
      sim_fpu_add (&ans, &wop1, &wop2);
      sim_fpu_to32 (&res, &ans);
      result = res;
      break;
    }
   case fmt_double:
d600 29
a628 10
      sim_fpu wop1;
      sim_fpu wop2;
      sim_fpu ans;
      unsigned64 res;
      sim_fpu_64to (&wop1, op1);
      sim_fpu_64to (&wop2, op2);
      sim_fpu_add (&ans, &wop1, &wop2);
      sim_fpu_to64 (&res, &ans);
      result = res;
      break;
a629 4
   default:
    fprintf (stderr, "Bad switch\n");
    abort ();
  }
d632 2
a633 1
  printf("DBG: Add: returning 0x%s (format = %s)\n",pr_addr(result), fpu_format_name (fmt));
d636 1
a636 1
  return(result);
d640 1
a640 1
Sub(op1,op2,fmt)
d643 1
a643 1
     FP_formats fmt; 
d648 2
a649 1
  printf("DBG: Sub: %s: op1 = 0x%s : op2 = 0x%s\n", fpu_format_name (fmt),pr_addr(op1),pr_addr(op2));
d653 1
a653 1
     "fmt". If they are not valid, the result is undefined. */
d655 33
a687 32
  /* The format type should already have been checked: */
  switch (fmt) {
   case fmt_single:
    {
      sim_fpu wop1;
      sim_fpu wop2;
      sim_fpu ans;
      unsigned32 res;
      sim_fpu_32to (&wop1, op1);
      sim_fpu_32to (&wop2, op2);
      sim_fpu_sub (&ans, &wop1, &wop2);
      sim_fpu_to32 (&res, &ans);
      result = res;
    }
    break;
   case fmt_double:
    {
      sim_fpu wop1;
      sim_fpu wop2;
      sim_fpu ans;
      unsigned64 res;
      sim_fpu_64to (&wop1, op1);
      sim_fpu_64to (&wop2, op2);
      sim_fpu_sub (&ans, &wop1, &wop2);
      sim_fpu_to64 (&res, &ans);
      result = res;
    }
    break;
   default:
    fprintf (stderr, "Bad switch\n");
    abort ();
  }
d690 2
a691 1
  printf("DBG: Sub: returning 0x%s (format = %s)\n",pr_addr(result), fpu_format_name (fmt));
d694 1
a694 1
  return(result);
d698 1
a698 1
Multiply(op1,op2,fmt)
d701 1
a701 1
     FP_formats fmt; 
d706 2
a707 1
  printf("DBG: Multiply: %s: op1 = 0x%s : op2 = 0x%s\n", fpu_format_name (fmt),pr_addr(op1),pr_addr(op2));
d711 1
a711 1
     "fmt". If they are not valid, the result is undefined. */
d713 2
a714 16
  /* The format type should already have been checked: */
  switch (fmt) {
   case fmt_single:
    {
      sim_fpu wop1;
      sim_fpu wop2;
      sim_fpu ans;
      unsigned32 res;
      sim_fpu_32to (&wop1, op1);
      sim_fpu_32to (&wop2, op2);
      sim_fpu_mul (&ans, &wop1, &wop2);
      sim_fpu_to32 (&res, &ans);
      result = res;
      break;
    }
   case fmt_double:
d716 29
a744 10
      sim_fpu wop1;
      sim_fpu wop2;
      sim_fpu ans;
      unsigned64 res;
      sim_fpu_64to (&wop1, op1);
      sim_fpu_64to (&wop2, op2);
      sim_fpu_mul (&ans, &wop1, &wop2);
      sim_fpu_to64 (&res, &ans);
      result = res;
      break;
a745 4
   default:
    fprintf (stderr, "Bad switch\n");
    abort ();
  }
d748 2
a749 1
  printf("DBG: Multiply: returning 0x%s (format = %s)\n",pr_addr(result), fpu_format_name (fmt));
d752 1
a752 1
  return(result);
d756 1
a756 1
Divide(op1,op2,fmt)
d759 1
a759 1
     FP_formats fmt; 
d764 2
a765 1
  printf("DBG: Divide: %s: op1 = 0x%s : op2 = 0x%s\n", fpu_format_name (fmt),pr_addr(op1),pr_addr(op2));
d769 1
a769 1
     "fmt". If they are not valid, the result is undefined. */
d771 2
a772 16
  /* The format type should already have been checked: */
  switch (fmt) {
   case fmt_single:
    {
      sim_fpu wop1;
      sim_fpu wop2;
      sim_fpu ans;
      unsigned32 res;
      sim_fpu_32to (&wop1, op1);
      sim_fpu_32to (&wop2, op2);
      sim_fpu_div (&ans, &wop1, &wop2);
      sim_fpu_to32 (&res, &ans);
      result = res;
      break;
    }
   case fmt_double:
d774 29
a802 10
      sim_fpu wop1;
      sim_fpu wop2;
      sim_fpu ans;
      unsigned64 res;
      sim_fpu_64to (&wop1, op1);
      sim_fpu_64to (&wop2, op2);
      sim_fpu_div (&ans, &wop1, &wop2);
      sim_fpu_to64 (&res, &ans);
      result = res;
      break;
a803 4
   default:
    fprintf (stderr, "Bad switch\n");
    abort ();
  }
d806 2
a807 1
  printf("DBG: Divide: returning 0x%s (format = %s)\n",pr_addr(result), fpu_format_name (fmt));
d810 1
a810 1
  return(result);
d814 1
a814 1
Recip(op,fmt)
d816 1
a816 1
     FP_formats fmt; 
d821 2
a822 1
  printf("DBG: Recip: %s: op = 0x%s\n", fpu_format_name (fmt),pr_addr(op));
d826 1
a826 1
     "fmt". If they are not valid, the result is undefined. */
d828 2
a829 14
  /* The format type should already have been checked: */
  switch (fmt) {
   case fmt_single:
    {
      sim_fpu wop;
      sim_fpu ans;
      unsigned32 res;
      sim_fpu_32to (&wop, op);
      sim_fpu_inv (&ans, &wop);
      sim_fpu_to32 (&res, &ans);
      result = res;
      break;
    }
   case fmt_double:
d831 25
a855 8
      sim_fpu wop;
      sim_fpu ans;
      unsigned64 res;
      sim_fpu_64to (&wop, op);
      sim_fpu_inv (&ans, &wop);
      sim_fpu_to64 (&res, &ans);
      result = res;
      break;
a856 4
   default:
    fprintf (stderr, "Bad switch\n");
    abort ();
  }
d859 2
a860 1
  printf("DBG: Recip: returning 0x%s (format = %s)\n",pr_addr(result), fpu_format_name (fmt));
d863 1
a863 1
  return(result);
d867 1
a867 1
SquareRoot(op,fmt)
d869 1
a869 1
     FP_formats fmt; 
d874 2
a875 1
  printf("DBG: SquareRoot: %s: op = 0x%s\n", fpu_format_name (fmt),pr_addr(op));
d879 1
a879 1
     "fmt". If they are not valid, the result is undefined. */
d881 2
a882 14
  /* The format type should already have been checked: */
  switch (fmt) {
   case fmt_single:
    {
      sim_fpu wop;
      sim_fpu ans;
      unsigned32 res;
      sim_fpu_32to (&wop, op);
      sim_fpu_sqrt (&ans, &wop);
      sim_fpu_to32 (&res, &ans);
      result = res;
      break;
    }
   case fmt_double:
d884 25
a908 8
      sim_fpu wop;
      sim_fpu ans;
      unsigned64 res;
      sim_fpu_64to (&wop, op);
      sim_fpu_sqrt (&ans, &wop);
      sim_fpu_to64 (&res, &ans);
      result = res;
      break;
a909 4
   default:
    fprintf (stderr, "Bad switch\n");
    abort ();
  }
d912 2
a913 1
  printf("DBG: SquareRoot: returning 0x%s (format = %s)\n",pr_addr(result), fpu_format_name (fmt));
d916 1
a916 1
  return(result);
d929 2
a930 1
  printf("DBG: Max: %s: op1 = 0x%s : op2 = 0x%s\n", fpu_format_name (fmt),pr_addr(op1),pr_addr(op2));
d934 1
a934 1
     "fmt". If they are not valid, the result is undefined. */
d936 1
a936 1
  /* The format type should already have been checked: */
d961 1
a961 1
  
d983 2
a984 1
  printf("DBG: Max: returning 0x%s (format = %s)\n",pr_addr(result), fpu_format_name (fmt));
d987 1
a987 1
  return(result);
d989 1
a989 1
#endif 
d1001 2
a1002 1
  printf("DBG: Min: %s: op1 = 0x%s : op2 = 0x%s\n", fpu_format_name (fmt),pr_addr(op1),pr_addr(op2));
d1006 1
a1006 1
     "fmt". If they are not valid, the result is undefined. */
d1008 1
a1008 1
  /* The format type should already have been checked: */
d1033 1
a1033 1
  
d1055 2
a1056 1
  printf("DBG: Min: returning 0x%s (format = %s)\n",pr_addr(result), fpu_format_name (fmt));
d1059 1
a1059 1
  return(result);
d1079 3
a1081 1
  printf("DBG: Convert: mode %s : op 0x%s : from %s : to %s : (PC = 0x%s)\n", fpu_rounding_mode_name (rm),pr_addr(op), fpu_format_name (from), fpu_format_name (to),pr_addr(IPC));
d1090 1
a1090 1
	 that has a least significant bit of zero (i.e. is even). */
d1095 1
a1095 1
	 magnitude than, the result. */
d1100 1
a1100 1
	 the result. */
d1103 1
a1103 1
      
d1106 1
a1106 1
	 the result. */
d1114 1
a1114 1
  
d1140 1
a1140 1
     Operation condition is raised. */
d1164 1
a1164 1
 
d1166 2
a1167 1
  printf("DBG: Convert: returning 0x%s (to format = %s)\n",pr_addr(result64), fpu_format_name (to));
d1170 1
a1170 1
  return(result64);
@


1.1
log
@2002-03-19  Chris G. Demetriou  <cgd@@broadcom.com>

        * interp.c: Move FPU support routines from here to...
        * cp1.c: Here.  New file.
        * Makefile.in (SIM_OBJS): Add cp1.o to object list.
        (cp1.o): New target.
@
text
@d79 4
a82 2
#define RMMODE(v) (((v) == FP_RM_NEAREST) ? "Round" : (((v) == FP_RM_TOZERO) ? "Trunc" : (((v) == FP_RM_TOPINF) ? "Ceil" : "Floor")))
#define DOFMT(v)  (((v) == fmt_single) ? "single" : (((v) == fmt_double) ? "double" : (((v) == fmt_word) ? "word" : (((v) == fmt_long) ? "long" : (((v) == fmt_unknown) ? "<unknown>" : (((v) == fmt_uninterpreted) ? "<uninterpreted>" : (((v) == fmt_uninterpreted_32) ? "<uninterpreted_32>" : (((v) == fmt_uninterpreted_64) ? "<uninterpreted_64>" : "<format error>"))))))))
d108 1
a108 1
    printf("DBG: Register %d was fmt_uninterpreted. Now %s\n",fpr,DOFMT(fmt));
d112 1
a112 1
    sim_io_eprintf(sd,"FPR %d (format %s) being accessed with format %s - setting to unknown (PC = 0x%s)\n",fpr,DOFMT(FPR_STATE[fpr]),DOFMT(fmt),pr_addr(cia));
d188 1
a188 1
  printf("DBG: ValueFPR: fpr = %d, fmt = %s, value = 0x%s : PC = 0x%s : SizeFGR() = %d\n",fpr,DOFMT(fmt),pr_uword64(value),pr_addr(cia),SizeFGR());
d205 1
a205 1
  printf("DBG: StoreFPR: fpr = %d, fmt = %s, value = 0x%s : PC = 0x%s : SizeFGR() = %d,\n",fpr,DOFMT(fmt),pr_uword64(value),pr_addr(cia),SizeFGR());
d277 1
a277 1
  printf("DBG: StoreFPR: fpr[%d] = 0x%s (format %s)\n",fpr,pr_uword64(FGR[fpr]),DOFMT(fmt));
d312 1
a312 1
printf("DBG: NaN: returning %d for 0x%s (format = %s)\n",boolean,pr_addr(op),DOFMT(fmt));
d326 1
a326 1
  printf("DBG: Infinity: format %s 0x%s\n",DOFMT(fmt),pr_addr(op));
d345 1
a345 1
    printf("DBG: TODO: unrecognised format (%s) for Infinity check\n",DOFMT(fmt));
d350 1
a350 1
  printf("DBG: Infinity: returning %d for 0x%s (format = %s)\n",boolean,pr_addr(op),DOFMT(fmt));
d367 1
a367 1
  printf("DBG: Less: %s: op1 = 0x%s : op2 = 0x%s\n",DOFMT(fmt),pr_addr(op1),pr_addr(op2));
d396 1
a396 1
  printf("DBG: Less: returning %d (format = %s)\n",boolean,DOFMT(fmt));
d413 1
a413 1
  printf("DBG: Equal: %s: op1 = 0x%s : op2 = 0x%s\n",DOFMT(fmt),pr_addr(op1),pr_addr(op2));
d442 1
a442 1
  printf("DBG: Equal: returning %d (format = %s)\n",boolean,DOFMT(fmt));
d456 1
a456 1
  printf("DBG: AbsoluteValue: %s: op = 0x%s\n",DOFMT(fmt),pr_addr(op));
d497 1
a497 1
  printf("DBG: Negate: %s: op = 0x%s\n",DOFMT(fmt),pr_addr(op));
d539 1
a539 1
  printf("DBG: Add: %s: op1 = 0x%s : op2 = 0x%s\n",DOFMT(fmt),pr_addr(op1),pr_addr(op2));
d579 1
a579 1
  printf("DBG: Add: returning 0x%s (format = %s)\n",pr_addr(result),DOFMT(fmt));
d594 1
a594 1
  printf("DBG: Sub: %s: op1 = 0x%s : op2 = 0x%s\n",DOFMT(fmt),pr_addr(op1),pr_addr(op2));
d634 1
a634 1
  printf("DBG: Sub: returning 0x%s (format = %s)\n",pr_addr(result),DOFMT(fmt));
d649 1
a649 1
  printf("DBG: Multiply: %s: op1 = 0x%s : op2 = 0x%s\n",DOFMT(fmt),pr_addr(op1),pr_addr(op2));
d689 1
a689 1
  printf("DBG: Multiply: returning 0x%s (format = %s)\n",pr_addr(result),DOFMT(fmt));
d704 1
a704 1
  printf("DBG: Divide: %s: op1 = 0x%s : op2 = 0x%s\n",DOFMT(fmt),pr_addr(op1),pr_addr(op2));
d744 1
a744 1
  printf("DBG: Divide: returning 0x%s (format = %s)\n",pr_addr(result),DOFMT(fmt));
d758 1
a758 1
  printf("DBG: Recip: %s: op = 0x%s\n",DOFMT(fmt),pr_addr(op));
d794 1
a794 1
  printf("DBG: Recip: returning 0x%s (format = %s)\n",pr_addr(result),DOFMT(fmt));
d808 1
a808 1
  printf("DBG: SquareRoot: %s: op = 0x%s\n",DOFMT(fmt),pr_addr(op));
d844 1
a844 1
  printf("DBG: SquareRoot: returning 0x%s (format = %s)\n",pr_addr(result),DOFMT(fmt));
d860 1
a860 1
  printf("DBG: Max: %s: op1 = 0x%s : op2 = 0x%s\n",DOFMT(fmt),pr_addr(op1),pr_addr(op2));
d913 1
a913 1
  printf("DBG: Max: returning 0x%s (format = %s)\n",pr_addr(result),DOFMT(fmt));
d930 1
a930 1
  printf("DBG: Min: %s: op1 = 0x%s : op2 = 0x%s\n",DOFMT(fmt),pr_addr(op1),pr_addr(op2));
d983 1
a983 1
  printf("DBG: Min: returning 0x%s (format = %s)\n",pr_addr(result),DOFMT(fmt));
d1006 1
a1006 1
  printf("DBG: Convert: mode %s : op 0x%s : from %s : to %s : (PC = 0x%s)\n",RMMODE(rm),pr_addr(op),DOFMT(from),DOFMT(to),pr_addr(IPC));
d1091 1
a1091 1
  printf("DBG: Convert: returning 0x%s (to format = %s)\n",pr_addr(result64),DOFMT(to));
d1097 25
d1123 19
@

