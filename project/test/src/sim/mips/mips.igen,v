head	1.68;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.68
	gdb_7_6-2013-04-26-release:1.68
	gdb_7_6-branch:1.68.0.32
	gdb_7_6-2013-03-12-branchpoint:1.68
	gdb_7_5_1-2012-11-29-release:1.68
	gdb_7_5-2012-08-17-release:1.68
	gdb_7_5-branch:1.68.0.30
	gdb_7_5-2012-07-18-branchpoint:1.68
	gdb_7_4_1-2012-04-26-release:1.68
	gdb_7_4-2012-01-24-release:1.68
	gdb_7_4-branch:1.68.0.28
	gdb_7_4-2011-12-13-branchpoint:1.68
	gdb_7_3_1-2011-09-04-release:1.68
	gdb_7_3-2011-07-26-release:1.68
	gdb_7_3-branch:1.68.0.26
	gdb_7_3-2011-04-01-branchpoint:1.68
	gdb_7_2-2010-09-02-release:1.68
	gdb_7_2-branch:1.68.0.24
	gdb_7_2-2010-07-07-branchpoint:1.68
	gdb_7_1-2010-03-18-release:1.68
	gdb_7_1-branch:1.68.0.22
	gdb_7_1-2010-02-18-branchpoint:1.68
	gdb_7_0_1-2009-12-22-release:1.68
	gdb_7_0-2009-10-06-release:1.68
	gdb_7_0-branch:1.68.0.20
	gdb_7_0-2009-09-16-branchpoint:1.68
	arc-sim-20090309:1.68
	msnyder-checkpoint-072509-branch:1.68.0.18
	msnyder-checkpoint-072509-branchpoint:1.68
	arc-insight_6_8-branch:1.68.0.16
	arc-insight_6_8-branchpoint:1.68
	insight_6_8-branch:1.68.0.14
	insight_6_8-branchpoint:1.68
	reverse-20081226-branch:1.68.0.12
	reverse-20081226-branchpoint:1.68
	multiprocess-20081120-branch:1.68.0.10
	multiprocess-20081120-branchpoint:1.68
	reverse-20080930-branch:1.68.0.8
	reverse-20080930-branchpoint:1.68
	reverse-20080717-branch:1.68.0.6
	reverse-20080717-branchpoint:1.68
	msnyder-reverse-20080609-branch:1.68.0.4
	msnyder-reverse-20080609-branchpoint:1.68
	drow-reverse-20070409-branch:1.65.0.2
	drow-reverse-20070409-branchpoint:1.65
	gdb_6_8-2008-03-27-release:1.68
	gdb_6_8-branch:1.68.0.2
	gdb_6_8-2008-02-26-branchpoint:1.68
	gdb_6_7_1-2007-10-29-release:1.66
	gdb_6_7-2007-10-10-release:1.66
	gdb_6_7-branch:1.66.0.2
	gdb_6_7-2007-09-07-branchpoint:1.66
	insight_6_6-20070208-release:1.61
	gdb_6_6-2006-12-18-release:1.61
	gdb_6_6-branch:1.61.0.2
	gdb_6_6-2006-11-15-branchpoint:1.61
	insight_6_5-20061003-release:1.60
	gdb-csl-symbian-6_4_50_20060226-12:1.60
	gdb-csl-sourcerygxx-3_4_4-25:1.59
	nickrob-async-20060828-mergepoint:1.60
	gdb-csl-symbian-6_4_50_20060226-11:1.60
	gdb-csl-sourcerygxx-4_1-17:1.60
	gdb-csl-20060226-branch-local-2:1.60
	gdb-csl-sourcerygxx-4_1-14:1.60
	gdb-csl-sourcerygxx-4_1-13:1.60
	gdb-csl-sourcerygxx-4_1-12:1.60
	gdb-csl-sourcerygxx-3_4_4-21:1.60
	gdb_6_5-20060621-release:1.60
	gdb-csl-sourcerygxx-4_1-9:1.60
	gdb-csl-sourcerygxx-4_1-8:1.60
	gdb-csl-sourcerygxx-4_1-7:1.60
	gdb-csl-arm-2006q1-6:1.60
	gdb-csl-sourcerygxx-4_1-6:1.60
	gdb-csl-symbian-6_4_50_20060226-10:1.60
	gdb-csl-symbian-6_4_50_20060226-9:1.60
	gdb-csl-symbian-6_4_50_20060226-8:1.60
	gdb-csl-coldfire-4_1-11:1.60
	gdb-csl-sourcerygxx-3_4_4-19:1.60
	gdb-csl-coldfire-4_1-10:1.60
	gdb_6_5-branch:1.60.0.16
	gdb_6_5-2006-05-14-branchpoint:1.60
	gdb-csl-sourcerygxx-4_1-5:1.60
	nickrob-async-20060513-branch:1.60.0.14
	nickrob-async-20060513-branchpoint:1.60
	gdb-csl-sourcerygxx-4_1-4:1.60
	msnyder-reverse-20060502-branch:1.60.0.12
	msnyder-reverse-20060502-branchpoint:1.60
	gdb-csl-morpho-4_1-4:1.60
	gdb-csl-sourcerygxx-3_4_4-17:1.60
	readline_5_1-import-branch:1.60.0.10
	readline_5_1-import-branchpoint:1.60
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.60
	gdb-csl-symbian-20060226-branch:1.60.0.8
	gdb-csl-symbian-20060226-branchpoint:1.60
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.60
	msnyder-reverse-20060331-branch:1.60.0.6
	msnyder-reverse-20060331-branchpoint:1.60
	gdb-csl-available-20060303-branch:1.60.0.4
	gdb-csl-available-20060303-branchpoint:1.60
	gdb-csl-20060226-branch:1.60.0.2
	gdb-csl-20060226-branchpoint:1.60
	gdb_6_4-20051202-release:1.59
	msnyder-fork-checkpoint-branch:1.59.0.8
	msnyder-fork-checkpoint-branchpoint:1.59
	gdb-csl-gxxpro-6_3-branch:1.59.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.59
	gdb_6_4-branch:1.59.0.4
	gdb_6_4-2005-11-01-branchpoint:1.59
	gdb-csl-arm-20051020-branch:1.59.0.2
	gdb-csl-arm-20051020-branchpoint:1.59
	msnyder-tracepoint-checkpoint-branch:1.58.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.58
	gdb-csl-arm-20050325-2005-q1b:1.57
	gdb-csl-arm-20050325-2005-q1a:1.57
	csl-arm-20050325-branch:1.57.0.8
	csl-arm-20050325-branchpoint:1.57
	gdb_6_3-20041109-release:1.57
	gdb_6_3-branch:1.57.0.4
	gdb_6_3-20041019-branchpoint:1.57
	drow_intercu-merge-20040921:1.57
	drow_intercu-merge-20040915:1.57
	jimb-gdb_6_2-e500-branch:1.57.0.6
	jimb-gdb_6_2-e500-branchpoint:1.57
	gdb_6_2-20040730-release:1.57
	gdb_6_2-branch:1.57.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.57
	gdb_6_1_1-20040616-release:1.55
	gdb_6_1-2004-04-05-release:1.55
	drow_intercu-merge-20040402:1.56
	drow_intercu-merge-20040327:1.55
	ezannoni_pie-20040323-branch:1.55.0.12
	ezannoni_pie-20040323-branchpoint:1.55
	cagney_tramp-20040321-mergepoint:1.55
	cagney_tramp-20040309-branch:1.55.0.10
	cagney_tramp-20040309-branchpoint:1.55
	gdb_6_1-branch:1.55.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.55
	drow_intercu-20040221-branch:1.55.0.6
	drow_intercu-20040221-branchpoint:1.55
	cagney_bfdfile-20040213-branch:1.55.0.4
	cagney_bfdfile-20040213-branchpoint:1.55
	drow-cplus-merge-20040208:1.55
	carlton_dictionary-20040126-merge:1.55
	cagney_bigcore-20040122-branch:1.55.0.2
	cagney_bigcore-20040122-branchpoint:1.55
	drow-cplus-merge-20040113:1.54
	drow-cplus-merge-20031224:1.54
	drow-cplus-merge-20031220:1.54
	carlton_dictionary-20031215-merge:1.54
	drow-cplus-merge-20031214:1.54
	carlton-dictionary-20031111-merge:1.54
	gdb_6_0-2003-10-04-release:1.54
	kettenis_sparc-20030918-branch:1.54.0.8
	kettenis_sparc-20030918-branchpoint:1.54
	carlton_dictionary-20030917-merge:1.54
	ezannoni_pie-20030916-branchpoint:1.54
	ezannoni_pie-20030916-branch:1.54.0.6
	cagney_x86i386-20030821-branch:1.54.0.4
	cagney_x86i386-20030821-branchpoint:1.54
	carlton_dictionary-20030805-merge:1.54
	carlton_dictionary-20030627-merge:1.54
	gdb_6_0-branch:1.54.0.2
	gdb_6_0-2003-06-23-branchpoint:1.54
	jimb-ppc64-linux-20030613-branch:1.53.0.30
	jimb-ppc64-linux-20030613-branchpoint:1.53
	cagney_convert-20030606-branch:1.53.0.28
	cagney_convert-20030606-branchpoint:1.53
	cagney_writestrings-20030508-branch:1.53.0.26
	cagney_writestrings-20030508-branchpoint:1.53
	jimb-ppc64-linux-20030528-branch:1.53.0.24
	jimb-ppc64-linux-20030528-branchpoint:1.53
	carlton_dictionary-20030523-merge:1.53
	cagney_fileio-20030521-branch:1.53.0.22
	cagney_fileio-20030521-branchpoint:1.53
	kettenis_i386newframe-20030517-mergepoint:1.53
	jimb-ppc64-linux-20030509-branch:1.53.0.20
	jimb-ppc64-linux-20030509-branchpoint:1.53
	kettenis_i386newframe-20030504-mergepoint:1.53
	carlton_dictionary-20030430-merge:1.53
	kettenis_i386newframe-20030419-branch:1.53.0.18
	kettenis_i386newframe-20030419-branchpoint:1.53
	carlton_dictionary-20030416-merge:1.53
	cagney_frameaddr-20030409-mergepoint:1.53
	kettenis_i386newframe-20030406-branch:1.53.0.16
	kettenis_i386newframe-20030406-branchpoint:1.53
	cagney_frameaddr-20030403-branchpoint:1.53
	cagney_frameaddr-20030403-branch:1.53.0.14
	cagney_framebase-20030330-mergepoint:1.53
	cagney_framebase-20030326-branch:1.53.0.12
	cagney_framebase-20030326-branchpoint:1.53
	cagney_lazyid-20030317-branch:1.53.0.10
	cagney_lazyid-20030317-branchpoint:1.53
	kettenis-i386newframe-20030316-mergepoint:1.53
	offbyone-20030313-branch:1.53.0.8
	offbyone-20030313-branchpoint:1.53
	kettenis-i386newframe-20030308-branch:1.53.0.6
	kettenis-i386newframe-20030308-branchpoint:1.53
	carlton_dictionary-20030305-merge:1.53
	cagney_offbyone-20030303-branch:1.53.0.4
	cagney_offbyone-20030303-branchpoint:1.53
	carlton_dictionary-20030207-merge:1.53
	interps-20030202-branch:1.53.0.2
	interps-20030202-branchpoint:1.53
	cagney-unwind-20030108-branch:1.51.0.2
	cagney-unwind-20030108-branchpoint:1.51
	carlton_dictionary-20021223-merge:1.49
	gdb_5_3-2002-12-12-release:1.49
	carlton_dictionary-20021115-merge:1.49
	kseitz_interps-20021105-merge:1.49
	kseitz_interps-20021103-merge:1.49
	drow-cplus-merge-20021020:1.49
	drow-cplus-merge-20021025:1.49
	carlton_dictionary-20021025-merge:1.49
	carlton_dictionary-20021011-merge:1.49
	drow-cplus-branch:1.49.0.10
	drow-cplus-branchpoint:1.49
	kseitz_interps-20020930-merge:1.49
	carlton_dictionary-20020927-merge:1.49
	carlton_dictionary-branch:1.49.0.8
	carlton_dictionary-20020920-branchpoint:1.49
	gdb_5_3-branch:1.49.0.6
	gdb_5_3-2002-09-04-branchpoint:1.49
	kseitz_interps-20020829-merge:1.49
	cagney_sysregs-20020825-branch:1.49.0.4
	cagney_sysregs-20020825-branchpoint:1.49
	readline_4_3-import-branch:1.49.0.2
	readline_4_3-import-branchpoint:1.49
	gdb_5_2_1-2002-07-23-release:1.24
	kseitz_interps-20020528-branch:1.38.0.6
	kseitz_interps-20020528-branchpoint:1.38
	cagney_regbuf-20020515-branch:1.38.0.4
	cagney_regbuf-20020515-branchpoint:1.38
	jimb-macro-020506-branch:1.38.0.2
	jimb-macro-020506-branchpoint:1.38
	gdb_5_2-2002-04-29-release:1.24
	gdb_5_2-branch:1.24.0.2
	gdb_5_2-2002-03-03-branchpoint:1.24
	gdb_5_1_1-2002-01-24-release:1.7
	gdb_5_1_0_1-2002-01-03-release:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.7.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.7
	gdb_5_1-2001-11-21-release:1.7
	gdb_s390-2001-09-26-branch:1.7.0.4
	gdb_s390-2001-09-26-branchpoint:1.7
	gdb_5_1-2001-07-29-branch:1.7.0.2
	gdb_5_1-2001-07-29-branchpoint:1.7
	insight-precleanup-2001-01-01:1.6
	gdb-premipsmulti-2000-06-06-branch:1.4.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.4
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.7
	gdb-2000-02-04:1.1.1.7
	gdb-2000-02-02:1.1.1.7
	gdb-2000-02-01:1.1.1.7
	gdb-2000-01-31:1.1.1.7
	gdb-2000-01-26:1.1.1.7
	gdb-2000-01-24:1.1.1.7
	gdb-2000-01-17:1.1.1.7
	gdb-2000-01-10:1.1.1.7
	gdb-2000-01-05:1.1.1.7
	gdb-1999-12-21:1.1.1.7
	gdb-1999-12-13:1.1.1.7
	gdb-1999-12-07:1.1.1.7
	gdb-1999-12-06:1.1.1.7
	gdb-1999-11-16:1.1.1.6
	gdb-1999-11-08:1.1.1.6
	gdb-1999-11-01:1.1.1.6
	gdb-1999-10-25:1.1.1.6
	gdb-1999-10-18:1.1.1.5
	gdb-1999-10-11:1.1.1.5
	gdb-1999-10-04:1.1.1.5
	gdb-1999-09-28:1.1.1.5
	gdb-1999-09-21:1.1.1.5
	gdb-1999-09-13:1.1.1.5
	gdb-1999-09-08:1.1.1.4
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.68
date	2007.10.22.20.02.25;	author rsandifo;	state Exp;
branches;
next	1.67;

1.67
date	2007.10.07.09.04.43;	author rsandifo;	state Exp;
branches;
next	1.66;

1.66
date	2007.05.14.16.24.25;	author ths;	state Exp;
branches;
next	1.65;

1.65
date	2007.03.01.14.29.26;	author ths;	state Exp;
branches;
next	1.64;

1.64
date	2007.02.20.13.28.55;	author ths;	state Exp;
branches;
next	1.63;

1.63
date	2007.02.19.17.53.29;	author ths;	state Exp;
branches;
next	1.62;

1.62
date	2007.02.19.17.31.08;	author ths;	state Exp;
branches;
next	1.61;

1.61
date	2006.08.29.12.45.26;	author ths;	state Exp;
branches;
next	1.60;

1.60
date	2005.12.14.23.07.56;	author chaoyingfu;	state Exp;
branches;
next	1.59;

1.59
date	2005.06.16.15.15.49;	author davidu;	state Exp;
branches;
next	1.58;

1.58
date	2005.05.26.21.31.57;	author cgd;	state Exp;
branches;
next	1.57;

1.57
date	2004.04.10.06.51.49;	author cgd;	state Exp;
branches;
next	1.56;

1.56
date	2004.03.29.21.56.02;	author rsandifo;	state Exp;
branches;
next	1.55;

1.55
date	2004.01.20.07.06.14;	author cgd;	state Exp;
branches
	1.55.6.1;
next	1.54;

1.54
date	2003.06.18.01.12.03;	author cgd;	state Exp;
branches;
next	1.53;

1.53
date	2003.01.14.19.01.41;	author cgd;	state Exp;
branches;
next	1.52;

1.52
date	2003.01.14.18.15.08;	author cgd;	state Exp;
branches;
next	1.51;

1.51
date	2003.01.05.07.56.59;	author cgd;	state Exp;
branches;
next	1.50;

1.50
date	2002.12.31.21.31.32;	author cgd;	state Exp;
branches;
next	1.49;

1.49
date	2002.07.31.05.44.54;	author cgd;	state Exp;
branches
	1.49.8.1
	1.49.10.1;
next	1.48;

1.48
date	2002.06.14.18.49.09;	author cgd;	state Exp;
branches;
next	1.47;

1.47
date	2002.06.14.04.44.11;	author cgd;	state Exp;
branches;
next	1.46;

1.46
date	2002.06.12.23.32.05;	author cgd;	state Exp;
branches;
next	1.45;

1.45
date	2002.06.12.23.20.56;	author cgd;	state Exp;
branches;
next	1.44;

1.44
date	2002.06.12.22.22.41;	author cgd;	state Exp;
branches;
next	1.43;

1.43
date	2002.06.08.03.05.23;	author cgd;	state Exp;
branches;
next	1.42;

1.42
date	2002.06.07.00.13.24;	author cgd;	state Exp;
branches;
next	1.41;

1.41
date	2002.06.04.22.38.41;	author cgd;	state Exp;
branches;
next	1.40;

1.40
date	2002.06.03.21.00.29;	author cgd;	state Exp;
branches;
next	1.39;

1.39
date	2002.06.02.07.39.26;	author cgd;	state Exp;
branches;
next	1.38;

1.38
date	2002.05.01.17.26.14;	author cgd;	state Exp;
branches
	1.38.4.1
	1.38.6.1;
next	1.37;

1.37
date	2002.04.25.05.37.03;	author cgd;	state Exp;
branches;
next	1.36;

1.36
date	2002.03.12.22.53.01;	author cgd;	state Exp;
branches;
next	1.35;

1.35
date	2002.03.08.00.37.14;	author cgd;	state Exp;
branches;
next	1.34;

1.34
date	2002.03.06.05.41.40;	author cgd;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.05.22.24.24;	author cgd;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.05.07.34.01;	author cgd;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.05.03.14.56;	author cgd;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.04.04.14.51;	author cgd;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.04.04.06.47;	author cgd;	state Exp;
branches;
next	1.28;

1.28
date	2002.03.04.03.19.49;	author cgd;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.03.07.36.42;	author cgd;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.03.06.49.43;	author cgd;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.03.02.11.23;	author cgd;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.01.23.51.18;	author cgd;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.01.23.40.51;	author cgd;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.01.19.55.42;	author cgd;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.01.07.53.46;	author cgd;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.01.07.34.57;	author cgd;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.01.06.40.28;	author cgd;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.01.06.34.21;	author cgd;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.28.07.07.56;	author cgd;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.28.07.01.14;	author cgd;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.28.02.57.34;	author cgd;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.27.22.46.35;	author cgd;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.27.21.52.52;	author cgd;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.19.08.10.44;	author cgd;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.11.23.35.07;	author cgd;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.11.22.49.45;	author cgd;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.11.06.13.49;	author cgd;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.11.02.19.38;	author cgd;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.12.14.53.20;	author jimb;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.04.02.32.58;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.23.12.39.41;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.29.19.35.50;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.01.07.06.10;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.02.18.14.02;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.06;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.55.6.1
date	2004.04.02.16.47.53;	author drow;	state Exp;
branches;
next	1.55.6.2;

1.55.6.2
date	2004.09.16.17.02.11;	author drow;	state Exp;
branches;
next	;

1.49.8.1
date	2003.02.07.19.18.05;	author carlton;	state Exp;
branches;
next	1.49.8.2;

1.49.8.2
date	2003.06.27.21.50.33;	author carlton;	state Exp;
branches;
next	1.49.8.3;

1.49.8.3
date	2004.01.26.19.11.54;	author carlton;	state Exp;
branches;
next	;

1.49.10.1
date	2003.12.14.20.28.28;	author drow;	state Exp;
branches;
next	1.49.10.2;

1.49.10.2
date	2004.02.09.19.44.03;	author drow;	state Exp;
branches;
next	;

1.38.4.1
date	2002.06.15.16.43.28;	author cagney;	state Exp;
branches;
next	;

1.38.6.1
date	2002.06.20.01.40.26;	author kseitz;	state Exp;
branches;
next	1.38.6.2;

1.38.6.2
date	2002.08.09.18.34.38;	author kseitz;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.35.06;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.33.07;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.17.31.55;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.09.09.00.01.59;	author shebs;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.09.13.21.39.49;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.10.26.03.43.48;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.12.07.03.56.42;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.68
log
@sim/mips/
	* mips.igen (check_fmt_p): Provide a separate mips32r2 definition
	that unconditionally allows fmt_ps.
	(ALNV.PS, CEIL.L.fmt, CVT.L.fmt, CVT.PS.S, CVT.S.PL, CVT.S.PU)
	(FLOOR.L.fmt, LWXC1, MADD.fmt, MSUB.fmt, NMADD.fmt, NMSUB.fmt)
	(PLL.PS, PLU.PS, PUL.PS, PUU.PS, ROUND.L.fmt, TRUNC.L.fmt): Change
	filter from 64,f to 32,f.
	(PREFX): Change filter from 64 to 32.
	(LDXC1, LUXC1): Provide separate mips32r2 implementations
	that use do_load_double instead of do_load.  Make both LUXC1
	versions unpredictable if SizeFGR () != 64.
	(SDXC1, SUXC1): Extend to mips32r2, using do_store_double
	instead of do_store.  Remove unused variable.  Make both SUXC1
	versions unpredictable if SizeFGR () != 64.
@
text
@// -*- C -*-
//
//    <insn> ::=
//        <insn-word> { "+" <insn-word> }
//        ":" <format-name>
//        ":" <filter-flags>
//        ":" <options>
//        ":" <name>
//        <nl>
//        { <insn-model> }
//        { <insn-mnemonic> }
//        <code-block>
//


// IGEN config - mips16
// :option:16::insn-bit-size:16
// :option:16::hi-bit-nr:15
:option:16::insn-specifying-widths:true
:option:16::gen-delayed-branch:false

// IGEN config - mips32/64..
// :option:32::insn-bit-size:32
// :option:32::hi-bit-nr:31
:option:32::insn-specifying-widths:true
:option:32::gen-delayed-branch:false


// Generate separate simulators for each target
// :option:::multi-sim:true


// Models known by this simulator are defined below.
//
// When placing models in the instruction descriptions, please place
// them one per line, in the order given here.

//  MIPS ISAs:
//
//  Instructions and related functions for these models are included in
//  this file.
:model:::mipsI:mips3000:
:model:::mipsII:mips6000:
:model:::mipsIII:mips4000:
:model:::mipsIV:mips8000:
:model:::mipsV:mipsisaV:
:model:::mips32:mipsisa32:
:model:::mips32r2:mipsisa32r2:
:model:::mips64:mipsisa64:
:model:::mips64r2:mipsisa64r2:

//  Vendor ISAs:
//
//  Standard MIPS ISA instructions used for these models are listed here,
//  as are functions needed by those standard instructions.  Instructions
//  which are model-dependent and which are not in the standard MIPS ISAs
//  (or which pre-date or use different encodings than the standard
//  instructions) are (for the most part) in separate .igen files.
:model:::vr4100:mips4100:		// vr.igen
:model:::vr4120:mips4120:
:model:::vr5000:mips5000:
:model:::vr5400:mips5400:
:model:::vr5500:mips5500:
:model:::r3900:mips3900:		// tx.igen

//  MIPS Application Specific Extensions (ASEs)
//
//  Instructions for the ASEs are in separate .igen files.
//  ASEs add instructions on to a base ISA.
:model:::mips16:mips16:			// m16.igen (and m16.dc)
:model:::mips16e:mips16e:		// m16e.igen
:model:::mips3d:mips3d:			// mips3d.igen
:model:::mdmx:mdmx:			// mdmx.igen
:model:::dsp:dsp:			// dsp.igen
:model:::dsp2:dsp2:			// dsp2.igen
:model:::smartmips:smartmips:		// smartmips.igen

//  Vendor Extensions
//
//  Instructions specific to these extensions are in separate .igen files.
//  Extensions add instructions on to a base ISA.
:model:::sb1:sb1:			// sb1.igen


// Pseudo instructions known by IGEN
:internal::::illegal:
{
  SignalException (ReservedInstruction, 0);
}


// Pseudo instructions known by interp.c
// For grep - RSVD_INSTRUCTION, RSVD_INSTRUCTION_MASK
000000,5.*,5.*,5.*,5.OP,000101:SPECIAL:32::RSVD
"rsvd <OP>"
{
  SignalException (ReservedInstruction, instruction_0);
}



// Helper:
//
// Simulate a 32 bit delayslot instruction
//

:function:::address_word:delayslot32:address_word target
{
  instruction_word delay_insn;
  sim_events_slip (SD, 1);
  DSPC = CIA;
  CIA = CIA + 4; /* NOTE not mips16 */
  STATE |= simDELAYSLOT;
  delay_insn = IMEM32 (CIA); /* NOTE not mips16 */
  ENGINE_ISSUE_PREFIX_HOOK();
  idecode_issue (CPU_, delay_insn, (CIA));
  STATE &= ~simDELAYSLOT;
  return target;
}

:function:::address_word:nullify_next_insn32:
{
  sim_events_slip (SD, 1);
  dotrace (SD, CPU, tracefh, 2, CIA + 4, 4, "load instruction");
  return CIA + 8;
}


// Helper:
//
// Calculate an effective address given a base and an offset.
//

:function:::address_word:loadstore_ea:address_word base, address_word offset
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*vr4100:
*vr5000:
*r3900:
{
  return base + offset;
}

:function:::address_word:loadstore_ea:address_word base, address_word offset
*mips64:
*mips64r2:
{
#if 0 /* XXX FIXME: enable this only after some additional testing.  */
  /* If in user mode and UX is not set, use 32-bit compatibility effective
     address computations as defined in the MIPS64 Architecture for
     Programmers Volume III, Revision 0.95, section 4.9.  */
  if ((SR & (status_KSU_mask|status_EXL|status_ERL|status_UX))
      == (ksu_user << status_KSU_shift))
    return (address_word)((signed32)base + (signed32)offset);
#endif
  return base + offset;
}


// Helper:
//
// Check that a 32-bit register value is properly sign-extended.
// (See NotWordValue in ISA spec.)
//

:function:::int:not_word_value:unsigned_word value
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*vr4100:
*vr5000:
*r3900:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
{
#if WITH_TARGET_WORD_BITSIZE == 64
  return value != (((value & 0xffffffff) ^ 0x80000000) - 0x80000000);
#else
  return 0;
#endif
}

// Helper:
//
// Handle UNPREDICTABLE operation behaviour.  The goal here is to prevent
// theoretically portable code which invokes non-portable behaviour from
// running with no indication of the portability issue.
// (See definition of UNPREDICTABLE in ISA spec.)
//

:function:::void:unpredictable:
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*vr4100:
*vr5000:
*r3900:
{
}

:function:::void:unpredictable:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
{
  unpredictable_action (CPU, CIA);
}


// Helpers:
//
// Check that an access to a HI/LO register meets timing requirements
//
// In all MIPS ISAs,
//
//	OP {HI and LO} followed by MT{LO or HI} (and not MT{HI or LO})
//	makes subsequent MF{HI or LO} UNPREDICTABLE. (1)
//
// The following restrictions exist for MIPS I - MIPS III:
//
//	MF{HI or LO} followed by MT{HI or LO} w/ less than 2 instructions
//	in between makes MF UNPREDICTABLE. (2)
//
//	MF{HI or LO} followed by OP {HI and LO} w/ less than 2 instructions
//	in between makes MF UNPREDICTABLE. (3)
//
// On the r3900, restriction (2) is not present, and restriction (3) is not
// present for multiplication.
//
// Unfortunately, there seems to be some confusion about whether the last
// two restrictions should apply to "MIPS IV" as well.  One edition of
// the MIPS IV ISA says they do, but references in later ISA documents
// suggest they don't.
//
// In reality, some MIPS IV parts, such as the VR5000 and VR5400, do have
// these restrictions, while others, like the VR5500, don't.  To accomodate
// such differences, the MIPS IV and MIPS V version of these helper functions
// use auxillary routines to determine whether the restriction applies.

// check_mf_cycles:
//
// Helper used by check_mt_hilo, check_mult_hilo, and check_div_hilo
// to check for restrictions (2) and (3) above.
//
:function:::int:check_mf_cycles:hilo_history *history, signed64 time, const char *new
{
  if (history->mf.timestamp + 3 > time)
    {
      sim_engine_abort (SD, CPU, CIA, "HILO: %s: %s at 0x%08lx too close to MF at 0x%08lx\n",
			itable[MY_INDEX].name,
			new, (long) CIA,
			(long) history->mf.cia);
      return 0;
    }
  return 1;
}


// check_mt_hilo:
//
// Check for restriction (2) above (for ISAs/processors that have it),
// and record timestamps for restriction (1) above.
//
:function:::int:check_mt_hilo:hilo_history *history
*mipsI:
*mipsII:
*mipsIII:
*vr4100:
*vr5000:
{
  signed64 time = sim_events_time (SD);
  int ok = check_mf_cycles (SD_, history, time, "MT");
  history->mt.timestamp = time;
  history->mt.cia = CIA;
  return ok;
}

:function:::int:check_mt_hilo:hilo_history *history
*mipsIV:
*mipsV:
{
  signed64 time = sim_events_time (SD);
  int ok = (! MIPS_MACH_HAS_MT_HILO_HAZARD (SD)
	    || check_mf_cycles (SD_, history, time, "MT"));
  history->mt.timestamp = time;
  history->mt.cia = CIA;
  return ok;
}

:function:::int:check_mt_hilo:hilo_history *history
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*r3900:
{
  signed64 time = sim_events_time (SD);
  history->mt.timestamp = time;
  history->mt.cia = CIA;
  return 1;
}


// check_mf_hilo:
//
// Check for restriction (1) above, and record timestamps for
// restriction (2) and (3) above.
//
:function:::int:check_mf_hilo:hilo_history *history, hilo_history *peer
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  signed64 time = sim_events_time (SD);
  int ok = 1;
  if (peer != NULL
      && peer->mt.timestamp > history->op.timestamp
      && history->mt.timestamp < history->op.timestamp
      && ! (history->mf.timestamp > history->op.timestamp
	    && history->mf.timestamp < peer->mt.timestamp)
      && ! (peer->mf.timestamp > history->op.timestamp
	    && peer->mf.timestamp < peer->mt.timestamp))
    {
      /* The peer has been written to since the last OP yet we have
         not */
      sim_engine_abort (SD, CPU, CIA, "HILO: %s: MF at 0x%08lx following OP at 0x%08lx corrupted by MT at 0x%08lx\n",
			itable[MY_INDEX].name,
			(long) CIA,
			(long) history->op.cia,
			(long) peer->mt.cia);
      ok = 0;
    }
  history->mf.timestamp = time;
  history->mf.cia = CIA;
  return ok;
}



// check_mult_hilo:
//
// Check for restriction (3) above (for ISAs/processors that have it)
// for MULT ops, and record timestamps for restriction (1) above.
//
:function:::int:check_mult_hilo:hilo_history *hi, hilo_history *lo
*mipsI:
*mipsII:
*mipsIII:
*vr4100:
*vr5000:
{
  signed64 time = sim_events_time (SD);
  int ok = (check_mf_cycles (SD_, hi, time, "OP")
	    && check_mf_cycles (SD_, lo, time, "OP"));
  hi->op.timestamp = time;
  lo->op.timestamp = time;
  hi->op.cia = CIA;
  lo->op.cia = CIA;
  return ok;
}

:function:::int:check_mult_hilo:hilo_history *hi, hilo_history *lo
*mipsIV:
*mipsV:
{
  signed64 time = sim_events_time (SD);
  int ok = (! MIPS_MACH_HAS_MULT_HILO_HAZARD (SD)
	    || (check_mf_cycles (SD_, hi, time, "OP")
	        && check_mf_cycles (SD_, lo, time, "OP")));
  hi->op.timestamp = time;
  lo->op.timestamp = time;
  hi->op.cia = CIA;
  lo->op.cia = CIA;
  return ok;
}

:function:::int:check_mult_hilo:hilo_history *hi, hilo_history *lo
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*r3900:
{
  /* FIXME: could record the fact that a stall occured if we want */
  signed64 time = sim_events_time (SD);
  hi->op.timestamp = time;
  lo->op.timestamp = time;
  hi->op.cia = CIA;
  lo->op.cia = CIA;
  return 1;
}


// check_div_hilo:
//
// Check for restriction (3) above (for ISAs/processors that have it)
// for DIV ops, and record timestamps for restriction (1) above.
//
:function:::int:check_div_hilo:hilo_history *hi, hilo_history *lo
*mipsI:
*mipsII:
*mipsIII:
*vr4100:
*vr5000:
*r3900:
{
  signed64 time = sim_events_time (SD);
  int ok = (check_mf_cycles (SD_, hi, time, "OP")
	    && check_mf_cycles (SD_, lo, time, "OP"));
  hi->op.timestamp = time;
  lo->op.timestamp = time;
  hi->op.cia = CIA;
  lo->op.cia = CIA;
  return ok;
}

:function:::int:check_div_hilo:hilo_history *hi, hilo_history *lo
*mipsIV:
*mipsV:
{
  signed64 time = sim_events_time (SD);
  int ok = (! MIPS_MACH_HAS_DIV_HILO_HAZARD (SD)
	    || (check_mf_cycles (SD_, hi, time, "OP")
	        && check_mf_cycles (SD_, lo, time, "OP")));
  hi->op.timestamp = time;
  lo->op.timestamp = time;
  hi->op.cia = CIA;
  lo->op.cia = CIA;
  return ok;
}

:function:::int:check_div_hilo:hilo_history *hi, hilo_history *lo
*mips32:
*mips32r2:
*mips64:
*mips64r2:
{
  signed64 time = sim_events_time (SD);
  hi->op.timestamp = time;
  lo->op.timestamp = time;
  hi->op.cia = CIA;
  lo->op.cia = CIA;
  return 1;
}


// Helper:
//
// Check that the 64-bit instruction can currently be used, and signal
// a ReservedInstruction exception if not.
//

:function:::void:check_u64:instruction_word insn
*mipsIII:
*mipsIV:
*mipsV:
*vr4100:
*vr5000:
*vr5400:
*vr5500:
{
  // The check should be similar to mips64 for any with PX/UX bit equivalents.
}

:function:::void:check_u64:instruction_word insn
*mips16e:
*mips64:
*mips64r2:
{
#if 0 /* XXX FIXME: enable this only after some additional testing.  */
  if (UserMode && (SR & (status_UX|status_PX)) == 0)
    SignalException (ReservedInstruction, insn);
#endif
}



//
// MIPS Architecture:
//
//        CPU Instruction Set (mipsI - mipsV, mips32/r2, mips64/r2)
//



000000,5.RS,5.RT,5.RD,00000,100000:SPECIAL:32::ADD
"add r<RD>, r<RS>, r<RT>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
  {
    ALU32_BEGIN (GPR[RS]);
    ALU32_ADD (GPR[RT]);
    ALU32_END (GPR[RD]);   /* This checks for overflow.  */
  }
  TRACE_ALU_RESULT (GPR[RD]);
}



001000,5.RS,5.RT,16.IMMEDIATE:NORMAL:32::ADDI
"addi r<RT>, r<RS>, <IMMEDIATE>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  if (NotWordValue (GPR[RS]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[RS], EXTEND16 (IMMEDIATE));
  {
    ALU32_BEGIN (GPR[RS]);
    ALU32_ADD (EXTEND16 (IMMEDIATE));
    ALU32_END (GPR[RT]);   /* This checks for overflow.  */
  }
  TRACE_ALU_RESULT (GPR[RT]);
}



:function:::void:do_addiu:int rs, int rt, unsigned16 immediate
{
  if (NotWordValue (GPR[rs]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));
  GPR[rt] = EXTEND32 (GPR[rs] + EXTEND16 (immediate));
  TRACE_ALU_RESULT (GPR[rt]);
}

001001,5.RS,5.RT,16.IMMEDIATE:NORMAL:32::ADDIU
"addiu r<RT>, r<RS>, <IMMEDIATE>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_addiu (SD_, RS, RT, IMMEDIATE);
}



:function:::void:do_addu:int rs, int rt, int rd
{
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = EXTEND32 (GPR[rs] + GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}

000000,5.RS,5.RT,5.RD,00000,100001:SPECIAL:32::ADDU
"addu r<RD>, r<RS>, r<RT>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_addu (SD_, RS, RT, RD);
}



:function:::void:do_and:int rs, int rt, int rd
{
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = GPR[rs] & GPR[rt];
  TRACE_ALU_RESULT (GPR[rd]);
}

000000,5.RS,5.RT,5.RD,00000,100100:SPECIAL:32::AND
"and r<RD>, r<RS>, r<RT>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_and (SD_, RS, RT, RD);
}



001100,5.RS,5.RT,16.IMMEDIATE:NORMAL:32::ANDI
"andi r<RT>, r<RS>, %#lx<IMMEDIATE>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  TRACE_ALU_INPUT2 (GPR[RS], IMMEDIATE);
  GPR[RT] = GPR[RS] & IMMEDIATE;
  TRACE_ALU_RESULT (GPR[RT]);
}



000100,5.RS,5.RT,16.OFFSET:NORMAL:32::BEQ
"beq r<RS>, r<RT>, <OFFSET>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  if ((signed_word) GPR[RS] == (signed_word) GPR[RT])
    {
      DELAY_SLOT (NIA + offset);
    }
}



010100,5.RS,5.RT,16.OFFSET:NORMAL:32::BEQL
"beql r<RS>, r<RT>, <OFFSET>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  if ((signed_word) GPR[RS] == (signed_word) GPR[RT])
    {
      DELAY_SLOT (NIA + offset);
    }
  else
    NULLIFY_NEXT_INSTRUCTION ();
}



000001,5.RS,00001,16.OFFSET:REGIMM:32::BGEZ
"bgez r<RS>, <OFFSET>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  if ((signed_word) GPR[RS] >= 0)
    {
      DELAY_SLOT (NIA + offset);
    }
}



000001,5.RS!31,10001,16.OFFSET:REGIMM:32::BGEZAL
"bgezal r<RS>, <OFFSET>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  if (RS == 31)
    Unpredictable ();
  RA = (CIA + 8);
  if ((signed_word) GPR[RS] >= 0)
    {
      DELAY_SLOT (NIA + offset);
    }
}



000001,5.RS!31,10011,16.OFFSET:REGIMM:32::BGEZALL
"bgezall r<RS>, <OFFSET>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  if (RS == 31)
    Unpredictable ();
  RA = (CIA + 8);
  /* NOTE: The branch occurs AFTER the next instruction has been
     executed */
  if ((signed_word) GPR[RS] >= 0)
    {
      DELAY_SLOT (NIA + offset);
    }
  else
    NULLIFY_NEXT_INSTRUCTION ();
}



000001,5.RS,00011,16.OFFSET:REGIMM:32::BGEZL
"bgezl r<RS>, <OFFSET>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  if ((signed_word) GPR[RS] >= 0)
    {
      DELAY_SLOT (NIA + offset);
    }
  else
    NULLIFY_NEXT_INSTRUCTION ();
}



000111,5.RS,00000,16.OFFSET:NORMAL:32::BGTZ
"bgtz r<RS>, <OFFSET>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  if ((signed_word) GPR[RS] > 0)
    {
      DELAY_SLOT (NIA + offset);
    }
}



010111,5.RS,00000,16.OFFSET:NORMAL:32::BGTZL
"bgtzl r<RS>, <OFFSET>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  /* NOTE: The branch occurs AFTER the next instruction has been
     executed */
  if ((signed_word) GPR[RS] > 0)
    {
      DELAY_SLOT (NIA + offset);
    }
  else
    NULLIFY_NEXT_INSTRUCTION ();
}



000110,5.RS,00000,16.OFFSET:NORMAL:32::BLEZ
"blez r<RS>, <OFFSET>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  /* NOTE: The branch occurs AFTER the next instruction has been
     executed */
  if ((signed_word) GPR[RS] <= 0)
    {
      DELAY_SLOT (NIA + offset);
    }
}



010110,5.RS,00000,16.OFFSET:NORMAL:32::BLEZL
"bgezl r<RS>, <OFFSET>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  if ((signed_word) GPR[RS] <= 0)
    {
      DELAY_SLOT (NIA + offset);
    }
  else
    NULLIFY_NEXT_INSTRUCTION ();
}



000001,5.RS,00000,16.OFFSET:REGIMM:32::BLTZ
"bltz r<RS>, <OFFSET>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  if ((signed_word) GPR[RS] < 0)
    {
      DELAY_SLOT (NIA + offset);
    }
}



000001,5.RS!31,10000,16.OFFSET:REGIMM:32::BLTZAL
"bltzal r<RS>, <OFFSET>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  if (RS == 31)
    Unpredictable ();
  RA = (CIA + 8);
  /* NOTE: The branch occurs AFTER the next instruction has been
     executed */
  if ((signed_word) GPR[RS] < 0)
    {
      DELAY_SLOT (NIA + offset);
    }
}



000001,5.RS!31,10010,16.OFFSET:REGIMM:32::BLTZALL
"bltzall r<RS>, <OFFSET>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  if (RS == 31)
    Unpredictable ();
  RA = (CIA + 8);
  if ((signed_word) GPR[RS] < 0)
    {
      DELAY_SLOT (NIA + offset);
    }
  else
    NULLIFY_NEXT_INSTRUCTION ();
}



000001,5.RS,00010,16.OFFSET:REGIMM:32::BLTZL
"bltzl r<RS>, <OFFSET>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  /* NOTE: The branch occurs AFTER the next instruction has been
     executed */
  if ((signed_word) GPR[RS] < 0)
    {
      DELAY_SLOT (NIA + offset);
    }
  else
    NULLIFY_NEXT_INSTRUCTION ();
}



000101,5.RS,5.RT,16.OFFSET:NORMAL:32::BNE
"bne r<RS>, r<RT>, <OFFSET>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  if ((signed_word) GPR[RS] != (signed_word) GPR[RT])
    {
      DELAY_SLOT (NIA + offset);
    }
}



010101,5.RS,5.RT,16.OFFSET:NORMAL:32::BNEL
"bnel r<RS>, r<RT>, <OFFSET>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  address_word offset = EXTEND16 (OFFSET) << 2;
  if ((signed_word) GPR[RS] != (signed_word) GPR[RT])
    {
      DELAY_SLOT (NIA + offset);
    }
  else
    NULLIFY_NEXT_INSTRUCTION ();
}



000000,20.CODE,001101:SPECIAL:32::BREAK
"break %#lx<CODE>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  /* Check for some break instruction which are reserved for use by the simulator.  */
  unsigned int break_code = instruction_0 & HALT_INSTRUCTION_MASK;
  if (break_code == (HALT_INSTRUCTION  & HALT_INSTRUCTION_MASK) ||
      break_code == (HALT_INSTRUCTION2 & HALT_INSTRUCTION_MASK))
    {
      sim_engine_halt (SD, CPU, NULL, cia,
                       sim_exited, (unsigned int)(A0 & 0xFFFFFFFF));
    }
  else if (break_code == (BREAKPOINT_INSTRUCTION  & HALT_INSTRUCTION_MASK) ||
           break_code == (BREAKPOINT_INSTRUCTION2 & HALT_INSTRUCTION_MASK))
    {
      if (STATE & simDELAYSLOT)
        PC = cia - 4; /* reference the branch instruction */
      else
        PC = cia;
      SignalException (BreakPoint, instruction_0);
    }

  else
    {
      /* If we get this far, we're not an instruction reserved by the sim.  Raise
	 the exception. */
      SignalException (BreakPoint, instruction_0);
    }
}



011100,5.RS,5.RT,5.RD,00000,100001:SPECIAL2:32::CLO
"clo r<RD>, r<RS>"
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr5500:
{
  unsigned32 temp = GPR[RS];
  unsigned32 i, mask;
  if (RT != RD)
    Unpredictable ();
  if (NotWordValue (GPR[RS]))
    Unpredictable ();
  TRACE_ALU_INPUT1 (GPR[RS]);
  for (mask = ((unsigned32)1<<31), i = 0; i < 32; ++i)
    {
      if ((temp & mask) == 0)
	break;
      mask >>= 1;
    }
  GPR[RD] = EXTEND32 (i);
  TRACE_ALU_RESULT (GPR[RD]);
}



011100,5.RS,5.RT,5.RD,00000,100000:SPECIAL2:32::CLZ
"clz r<RD>, r<RS>"
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr5500:
{
  unsigned32 temp = GPR[RS];
  unsigned32 i, mask;
  if (RT != RD)
    Unpredictable ();
  if (NotWordValue (GPR[RS]))
    Unpredictable ();
  TRACE_ALU_INPUT1 (GPR[RS]);
  for (mask = ((unsigned32)1<<31), i = 0; i < 32; ++i)
    {
      if ((temp & mask) != 0)
	break;
      mask >>= 1;
    }
  GPR[RD] = EXTEND32 (i);
  TRACE_ALU_RESULT (GPR[RD]);
}



000000,5.RS,5.RT,5.RD,00000,101100:SPECIAL:64::DADD
"dadd r<RD>, r<RS>, r<RT>"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  check_u64 (SD_, instruction_0);
  TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
  {
    ALU64_BEGIN (GPR[RS]);
    ALU64_ADD (GPR[RT]);
    ALU64_END (GPR[RD]);   /* This checks for overflow.  */
  }
  TRACE_ALU_RESULT (GPR[RD]);
}



011000,5.RS,5.RT,16.IMMEDIATE:NORMAL:64::DADDI
"daddi r<RT>, r<RS>, <IMMEDIATE>"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  check_u64 (SD_, instruction_0);
  TRACE_ALU_INPUT2 (GPR[RS], EXTEND16 (IMMEDIATE));
  {
    ALU64_BEGIN (GPR[RS]);
    ALU64_ADD (EXTEND16 (IMMEDIATE));
    ALU64_END (GPR[RT]);   /* This checks for overflow.  */
  }
  TRACE_ALU_RESULT (GPR[RT]);
}



:function:::void:do_daddiu:int rs, int rt, unsigned16 immediate
{
  TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));
  GPR[rt] = GPR[rs] + EXTEND16 (immediate);
  TRACE_ALU_RESULT (GPR[rt]);
}

011001,5.RS,5.RT,16.IMMEDIATE:NORMAL:64::DADDIU
"daddiu r<RT>, r<RS>, <IMMEDIATE>"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  check_u64 (SD_, instruction_0);
  do_daddiu (SD_, RS, RT, IMMEDIATE);
}



:function:::void:do_daddu:int rs, int rt, int rd
{
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = GPR[rs] + GPR[rt];
  TRACE_ALU_RESULT (GPR[rd]);
}

000000,5.RS,5.RT,5.RD,00000,101101:SPECIAL:64::DADDU
"daddu r<RD>, r<RS>, r<RT>"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  check_u64 (SD_, instruction_0);
  do_daddu (SD_, RS, RT, RD);
}



011100,5.RS,5.RT,5.RD,00000,100101:SPECIAL2:64::DCLO
"dclo r<RD>, r<RS>"
*mips64:
*mips64r2:
*vr5500:
{
  unsigned64 temp = GPR[RS];
  unsigned32 i;
  unsigned64 mask;
  check_u64 (SD_, instruction_0);
  if (RT != RD)
    Unpredictable ();
  TRACE_ALU_INPUT1 (GPR[RS]);
  for (mask = ((unsigned64)1<<63), i = 0; i < 64; ++i)
    {
      if ((temp & mask) == 0)
	break;
      mask >>= 1;
    }
  GPR[RD] = EXTEND32 (i);
  TRACE_ALU_RESULT (GPR[RD]);
}



011100,5.RS,5.RT,5.RD,00000,100100:SPECIAL2:64::DCLZ
"dclz r<RD>, r<RS>"
*mips64:
*mips64r2:
*vr5500:
{
  unsigned64 temp = GPR[RS];
  unsigned32 i;
  unsigned64 mask;
  check_u64 (SD_, instruction_0);
  if (RT != RD)
    Unpredictable ();
  TRACE_ALU_INPUT1 (GPR[RS]);
  for (mask = ((unsigned64)1<<63), i = 0; i < 64; ++i)
    {
      if ((temp & mask) != 0)
	break;
      mask >>= 1;
    }
  GPR[RD] = EXTEND32 (i);
  TRACE_ALU_RESULT (GPR[RD]);
}



:function:::void:do_ddiv:int rs, int rt
{
  check_div_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  {
    signed64 n = GPR[rs];
    signed64 d = GPR[rt];
    signed64 hi;
    signed64 lo;
    if (d == 0)
      {
	lo = SIGNED64 (0x8000000000000000);
	hi = 0;
      }
    else if (d == -1 && n == SIGNED64 (0x8000000000000000))
      {
	lo = SIGNED64 (0x8000000000000000);
	hi = 0;
      }
    else
      {
	lo = (n / d);
	hi = (n % d);
      }
    HI = hi;
    LO = lo;
  }
  TRACE_ALU_RESULT2 (HI, LO);
}

000000,5.RS,5.RT,0000000000,011110:SPECIAL:64::DDIV
"ddiv r<RS>, r<RT>"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  check_u64 (SD_, instruction_0);
  do_ddiv (SD_, RS, RT);
}



:function:::void:do_ddivu:int rs, int rt
{
  check_div_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  {
    unsigned64 n = GPR[rs];
    unsigned64 d = GPR[rt];
    unsigned64 hi;
    unsigned64 lo;
    if (d == 0)
      {
	lo = SIGNED64 (0x8000000000000000);
	hi = 0;
      }
    else
      {
	lo = (n / d);
	hi = (n % d);
      }
    HI = hi;
    LO = lo;
  }
  TRACE_ALU_RESULT2 (HI, LO);
}

000000,5.RS,5.RT,0000000000,011111:SPECIAL:64::DDIVU
"ddivu r<RS>, r<RT>"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  check_u64 (SD_, instruction_0);
  do_ddivu (SD_, RS, RT);
}

:function:::void:do_div:int rs, int rt
{
  check_div_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  {
    signed32 n = GPR[rs];
    signed32 d = GPR[rt];
    if (d == 0)
      {
	LO = EXTEND32 (0x80000000);
	HI = EXTEND32 (0);
      }
    else if (n == SIGNED32 (0x80000000) && d == -1)
      {
	LO = EXTEND32 (0x80000000);
	HI = EXTEND32 (0);
      }
    else
      {
	LO = EXTEND32 (n / d);
	HI = EXTEND32 (n % d);
      }
  }
  TRACE_ALU_RESULT2 (HI, LO);
}

000000,5.RS,5.RT,0000000000,011010:SPECIAL:32::DIV
"div r<RS>, r<RT>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_div (SD_, RS, RT);
}



:function:::void:do_divu:int rs, int rt
{
  check_div_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  {
    unsigned32 n = GPR[rs];
    unsigned32 d = GPR[rt];
    if (d == 0)
      {
	LO = EXTEND32 (0x80000000);
	HI = EXTEND32 (0);
      }
    else
      {
	LO = EXTEND32 (n / d);
	HI = EXTEND32 (n % d);
      }
  }
  TRACE_ALU_RESULT2 (HI, LO);
}

000000,5.RS,5.RT,0000000000,011011:SPECIAL:32::DIVU
"divu r<RS>, r<RT>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_divu (SD_, RS, RT);
}


:function:::void:do_dmultx:int rs, int rt, int rd, int signed_p
{
  unsigned64 lo;
  unsigned64 hi;
  unsigned64 m00;
  unsigned64 m01;
  unsigned64 m10;
  unsigned64 m11;
  unsigned64 mid;
  int sign;
  unsigned64 op1 = GPR[rs];
  unsigned64 op2 = GPR[rt];
  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  /* make signed multiply unsigned */
  sign = 0;
  if (signed_p)
    {
      if ((signed64) op1 < 0)
	{
	  op1 = - op1;
	  ++sign;
	}
      if ((signed64) op2 < 0)
	{
	  op2 = - op2;
	  ++sign;
	}
    }
  /* multiply out the 4 sub products */
  m00 = ((unsigned64) VL4_8 (op1) * (unsigned64) VL4_8 (op2));
  m10 = ((unsigned64) VH4_8 (op1) * (unsigned64) VL4_8 (op2));
  m01 = ((unsigned64) VL4_8 (op1) * (unsigned64) VH4_8 (op2));
  m11 = ((unsigned64) VH4_8 (op1) * (unsigned64) VH4_8 (op2));
  /* add the products */
  mid = ((unsigned64) VH4_8 (m00)
	 + (unsigned64) VL4_8 (m10)
	 + (unsigned64) VL4_8 (m01));
  lo = U8_4 (mid, m00);
  hi = (m11
	+ (unsigned64) VH4_8 (mid)
	+ (unsigned64) VH4_8 (m01)
	+ (unsigned64) VH4_8 (m10));
  /* fix the sign */
  if (sign & 1)
    {
      lo = -lo;
      if (lo == 0)
	hi = -hi;
      else
	hi = -hi - 1;
    }
  /* save the result HI/LO (and a gpr) */
  LO = lo;
  HI = hi;
  if (rd != 0)
    GPR[rd] = lo;
  TRACE_ALU_RESULT2 (HI, LO);
}

:function:::void:do_dmult:int rs, int rt, int rd
{
  do_dmultx (SD_, rs, rt, rd, 1);
}

000000,5.RS,5.RT,0000000000,011100:SPECIAL:64::DMULT
"dmult r<RS>, r<RT>"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
{
  check_u64 (SD_, instruction_0);
  do_dmult (SD_, RS, RT, 0);
}

000000,5.RS,5.RT,5.RD,00000,011100:SPECIAL:64::DMULT
"dmult r<RS>, r<RT>":RD == 0
"dmult r<RD>, r<RS>, r<RT>"
*vr5000:
{
  check_u64 (SD_, instruction_0);
  do_dmult (SD_, RS, RT, RD);
}



:function:::void:do_dmultu:int rs, int rt, int rd
{
  do_dmultx (SD_, rs, rt, rd, 0);
}

000000,5.RS,5.RT,0000000000,011101:SPECIAL:64::DMULTU
"dmultu r<RS>, r<RT>"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
{
  check_u64 (SD_, instruction_0);
  do_dmultu (SD_, RS, RT, 0);
}

000000,5.RS,5.RT,5.RD,00000,011101:SPECIAL:64::DMULTU
"dmultu r<RD>, r<RS>, r<RT>":RD == 0
"dmultu r<RS>, r<RT>"
*vr5000:
{
  check_u64 (SD_, instruction_0);
  do_dmultu (SD_, RS, RT, RD);
}


:function:::unsigned64:do_dror:unsigned64 x,unsigned64 y
{
  unsigned64 result;

  y &= 63;
  TRACE_ALU_INPUT2 (x, y);
  result = ROTR64 (x, y);
  TRACE_ALU_RESULT (result);
  return result;
}

000000,00001,5.RT,5.RD,5.SHIFT,111010::64::DROR
"dror r<RD>, r<RT>, <SHIFT>"
*mips64r2:
*vr5400:
*vr5500:
{
  check_u64 (SD_, instruction_0);
  GPR[RD] = do_dror (SD_, GPR[RT], SHIFT);
}

000000,00001,5.RT,5.RD,5.SHIFT,111110::64::DROR32
"dror32 r<RD>, r<RT>, <SHIFT>"
*mips64r2:
*vr5400:
*vr5500:
{
  check_u64 (SD_, instruction_0);
  GPR[RD] = do_dror (SD_, GPR[RT], SHIFT + 32);
}

000000,5.RS,5.RT,5.RD,00001,010110::64::DRORV
"drorv r<RD>, r<RT>, r<RS>"
*mips64r2:
*vr5400:
*vr5500:
{
  check_u64 (SD_, instruction_0);
  GPR[RD] = do_dror (SD_, GPR[RT], GPR[RS]);
}


:function:::void:do_dsll:int rt, int rd, int shift
{
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = GPR[rt] << shift;
  TRACE_ALU_RESULT (GPR[rd]);
}

000000,00000,5.RT,5.RD,5.SHIFT,111000:SPECIAL:64::DSLL
"dsll r<RD>, r<RT>, <SHIFT>"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  check_u64 (SD_, instruction_0);
  do_dsll (SD_, RT, RD, SHIFT);
}


000000,00000,5.RT,5.RD,5.SHIFT,111100:SPECIAL:64::DSLL32
"dsll32 r<RD>, r<RT>, <SHIFT>"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  int s = 32 + SHIFT;
  check_u64 (SD_, instruction_0);
  TRACE_ALU_INPUT2 (GPR[RT], s);
  GPR[RD] = GPR[RT] << s;
  TRACE_ALU_RESULT (GPR[RD]);
}

:function:::void:do_dsllv:int rs, int rt, int rd
{
  int s = MASKED64 (GPR[rs], 5, 0);
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = GPR[rt] << s;
  TRACE_ALU_RESULT (GPR[rd]);
}

000000,5.RS,5.RT,5.RD,00000,010100:SPECIAL:64::DSLLV
"dsllv r<RD>, r<RT>, r<RS>"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  check_u64 (SD_, instruction_0);
  do_dsllv (SD_, RS, RT, RD);
}

:function:::void:do_dsra:int rt, int rd, int shift
{
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = ((signed64) GPR[rt]) >> shift;
  TRACE_ALU_RESULT (GPR[rd]);
}


000000,00000,5.RT,5.RD,5.SHIFT,111011:SPECIAL:64::DSRA
"dsra r<RD>, r<RT>, <SHIFT>"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  check_u64 (SD_, instruction_0);
  do_dsra (SD_, RT, RD, SHIFT);
}


000000,00000,5.RT,5.RD,5.SHIFT,111111:SPECIAL:64::DSRA32
"dsra32 r<RD>, r<RT>, <SHIFT>"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  int s = 32 + SHIFT;
  check_u64 (SD_, instruction_0);
  TRACE_ALU_INPUT2 (GPR[RT], s);
  GPR[RD] = ((signed64) GPR[RT]) >> s;
  TRACE_ALU_RESULT (GPR[RD]);
}


:function:::void:do_dsrav:int rs, int rt, int rd
{
  int s = MASKED64 (GPR[rs], 5, 0);
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = ((signed64) GPR[rt]) >> s;
  TRACE_ALU_RESULT (GPR[rd]);
}

000000,5.RS,5.RT,5.RD,00000,010111:SPECIAL:64::DSRAV
"dsrav r<RD>, r<RT>, r<RS>"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  check_u64 (SD_, instruction_0);
  do_dsrav (SD_, RS, RT, RD);
}

:function:::void:do_dsrl:int rt, int rd, int shift
{
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = (unsigned64) GPR[rt] >> shift;
  TRACE_ALU_RESULT (GPR[rd]);
}


000000,00000,5.RT,5.RD,5.SHIFT,111010:SPECIAL:64::DSRL
"dsrl r<RD>, r<RT>, <SHIFT>"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  check_u64 (SD_, instruction_0);
  do_dsrl (SD_, RT, RD, SHIFT);
}


000000,00000,5.RT,5.RD,5.SHIFT,111110:SPECIAL:64::DSRL32
"dsrl32 r<RD>, r<RT>, <SHIFT>"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  int s = 32 + SHIFT;
  check_u64 (SD_, instruction_0);
  TRACE_ALU_INPUT2 (GPR[RT], s);
  GPR[RD] = (unsigned64) GPR[RT] >> s;
  TRACE_ALU_RESULT (GPR[RD]);
}


:function:::void:do_dsrlv:int rs, int rt, int rd
{
  int s = MASKED64 (GPR[rs], 5, 0);
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = (unsigned64) GPR[rt] >> s;
  TRACE_ALU_RESULT (GPR[rd]);
}



000000,5.RS,5.RT,5.RD,00000,010110:SPECIAL:64::DSRLV
"dsrlv r<RD>, r<RT>, r<RS>"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  check_u64 (SD_, instruction_0);
  do_dsrlv (SD_, RS, RT, RD);
}


000000,5.RS,5.RT,5.RD,00000,101110:SPECIAL:64::DSUB
"dsub r<RD>, r<RS>, r<RT>"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  check_u64 (SD_, instruction_0);
  TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
  {
    ALU64_BEGIN (GPR[RS]);
    ALU64_SUB (GPR[RT]);
    ALU64_END (GPR[RD]);   /* This checks for overflow.  */
  }
  TRACE_ALU_RESULT (GPR[RD]);
}


:function:::void:do_dsubu:int rs, int rt, int rd
{
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = GPR[rs] - GPR[rt];
  TRACE_ALU_RESULT (GPR[rd]);
}

000000,5.RS,5.RT,5.RD,00000,101111:SPECIAL:64::DSUBU
"dsubu r<RD>, r<RS>, r<RT>"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  check_u64 (SD_, instruction_0);
  do_dsubu (SD_, RS, RT, RD);
}


000010,26.INSTR_INDEX:NORMAL:32::J
"j <INSTR_INDEX>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  /* NOTE: The region used is that of the delay slot NIA and NOT the
     current instruction */
  address_word region = (NIA & MASK (63, 28));
  DELAY_SLOT (region | (INSTR_INDEX << 2));
}


000011,26.INSTR_INDEX:NORMAL:32::JAL
"jal <INSTR_INDEX>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  /* NOTE: The region used is that of the delay slot and NOT the
     current instruction */
  address_word region = (NIA & MASK (63, 28));
  GPR[31] = CIA + 8;
  DELAY_SLOT (region | (INSTR_INDEX << 2));
}

000000,5.RS,00000,5.RD,00000,001001:SPECIAL:32::JALR
"jalr r<RS>":RD == 31
"jalr r<RD>, r<RS>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  address_word temp = GPR[RS];
  GPR[RD] = CIA + 8;
  DELAY_SLOT (temp);
}

000000,5.RS,00000,5.RD,10000,001001:SPECIAL:32::JALR_HB
"jalr.hb r<RS>":RD == 31
"jalr.hb r<RD>, r<RS>"
*mips32r2:
*mips64r2:
{
  address_word temp = GPR[RS];
  GPR[RD] = CIA + 8;
  DELAY_SLOT (temp);
}

000000,5.RS,0000000000,00000,001000:SPECIAL:32::JR
"jr r<RS>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  DELAY_SLOT (GPR[RS]);
}

000000,5.RS,0000000000,10000,001000:SPECIAL:32::JR_HB
"jr.hb r<RS>"
*mips32r2:
*mips64r2:
{
  DELAY_SLOT (GPR[RS]);
}

:function:::unsigned_word:do_load:unsigned access, address_word base, address_word offset
{
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? (mask ^ access) : 0);
  address_word bigendiancpu = (BigEndianCPU ? (mask ^ access) : 0);
  unsigned int byte;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;

  vaddr = loadstore_ea (SD_, base, offset);
  if ((vaddr & access) != 0)
    {
      SIM_CORE_SIGNAL (SD, STATE_CPU (SD, 0), cia, read_map, access+1, vaddr, read_transfer, sim_core_unaligned_signal);
    }
  AddressTranslation (vaddr, isDATA, isLOAD, &paddr, &uncached, isTARGET, isREAL);
  paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
  LoadMemory (&memval, NULL, uncached, access, paddr, vaddr, isDATA, isREAL);
  byte = ((vaddr & mask) ^ bigendiancpu);
  return (memval >> (8 * byte));
}

:function:::unsigned_word:do_load_left:unsigned access, address_word base, address_word offset, unsigned_word rt
{
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? -1 : 0);
  address_word bigendiancpu = (BigEndianCPU ? -1 : 0);
  unsigned int byte;
  unsigned int word;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;
  int nr_lhs_bits;
  int nr_rhs_bits;
  unsigned_word lhs_mask;
  unsigned_word temp;

  vaddr = loadstore_ea (SD_, base, offset);
  AddressTranslation (vaddr, isDATA, isLOAD, &paddr, &uncached, isTARGET, isREAL);
  paddr = (paddr ^ (reverseendian & mask));
  if (BigEndianMem == 0)
    paddr = paddr & ~access;

  /* compute where within the word/mem we are */
  byte = ((vaddr ^ bigendiancpu) & access); /* 0..access */
  word = ((vaddr ^ bigendiancpu) & (mask & ~access)) / (access + 1); /* 0..1 */
  nr_lhs_bits = 8 * byte + 8;
  nr_rhs_bits = 8 * access - 8 * byte;
  /* nr_lhs_bits + nr_rhs_bits == 8 * (accesss + 1) */

  /* fprintf (stderr, "l[wd]l: 0x%08lx%08lx 0x%08lx%08lx %d:%d %d+%d\n",
	   (long) ((unsigned64) vaddr >> 32), (long) vaddr,
	   (long) ((unsigned64) paddr >> 32), (long) paddr,
	   word, byte, nr_lhs_bits, nr_rhs_bits); */

  LoadMemory (&memval, NULL, uncached, byte, paddr, vaddr, isDATA, isREAL);
  if (word == 0)
    {
      /* GPR{31..32-NR_LHS_BITS} = memval{NR_LHS_BITS-1..0} */
      temp = (memval << nr_rhs_bits);
    }
  else
    {
      /* GPR{31..32-NR_LHS_BITS = memval{32+NR_LHS_BITS..32} */
      temp = (memval >> nr_lhs_bits);
    }
  lhs_mask = LSMASK (nr_lhs_bits + nr_rhs_bits - 1, nr_rhs_bits);
  rt = (rt & ~lhs_mask) | (temp & lhs_mask);

  /* fprintf (stderr, "l[wd]l: 0x%08lx%08lx -> 0x%08lx%08lx & 0x%08lx%08lx -> 0x%08lx%08lx\n",
	   (long) ((unsigned64) memval >> 32), (long) memval,
	   (long) ((unsigned64) temp >> 32), (long) temp,
	   (long) ((unsigned64) lhs_mask >> 32), (long) lhs_mask,
	   (long) (rt >> 32), (long) rt); */
  return rt;
}

:function:::unsigned_word:do_load_right:unsigned access, address_word base, address_word offset, unsigned_word rt
{
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? -1 : 0);
  address_word bigendiancpu = (BigEndianCPU ? -1 : 0);
  unsigned int byte;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;

  vaddr = loadstore_ea (SD_, base, offset);
  AddressTranslation (vaddr, isDATA, isLOAD, &paddr, &uncached, isTARGET, isREAL);
  /* NOTE: SPEC is wrong, has `BigEndianMem == 0' not `BigEndianMem != 0' */
  paddr = (paddr ^ (reverseendian & mask));
  if (BigEndianMem != 0)
    paddr = paddr & ~access;
  byte = ((vaddr & mask) ^ (bigendiancpu & mask));
  /* NOTE: SPEC is wrong, had `byte' not `access - byte'.  See SW. */
  LoadMemory (&memval, NULL, uncached, access - (access & byte), paddr, vaddr, isDATA, isREAL);
  /* printf ("lr: 0x%08lx %d@@0x%08lx 0x%08lx\n",
     (long) paddr, byte, (long) paddr, (long) memval); */
  {
    unsigned_word screen = LSMASK (8 * (access - (byte & access) + 1) - 1, 0);
    rt &= ~screen;
    rt |= (memval >> (8 * byte)) & screen;
  }
  return rt;
}


100000,5.BASE,5.RT,16.OFFSET:NORMAL:32::LB
"lb r<RT>, <OFFSET>(r<BASE>)"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  GPR[RT] = EXTEND8 (do_load (SD_, AccessLength_BYTE, GPR[BASE], EXTEND16 (OFFSET)));
}


100100,5.BASE,5.RT,16.OFFSET:NORMAL:32::LBU
"lbu r<RT>, <OFFSET>(r<BASE>)"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  GPR[RT] = do_load (SD_, AccessLength_BYTE, GPR[BASE], EXTEND16 (OFFSET));
}


110111,5.BASE,5.RT,16.OFFSET:NORMAL:64::LD
"ld r<RT>, <OFFSET>(r<BASE>)"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  check_u64 (SD_, instruction_0);
  GPR[RT] = EXTEND64 (do_load (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET)));
}


1101,ZZ!0!1!3,5.BASE,5.RT,16.OFFSET:NORMAL:64::LDCz
"ldc<ZZ> r<RT>, <OFFSET>(r<BASE>)"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  COP_LD (ZZ, RT, do_load (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET)));
}




011010,5.BASE,5.RT,16.OFFSET:NORMAL:64::LDL
"ldl r<RT>, <OFFSET>(r<BASE>)"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  check_u64 (SD_, instruction_0);
  GPR[RT] = do_load_left (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
}


011011,5.BASE,5.RT,16.OFFSET:NORMAL:64::LDR
"ldr r<RT>, <OFFSET>(r<BASE>)"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  check_u64 (SD_, instruction_0);
  GPR[RT] = do_load_right (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
}


100001,5.BASE,5.RT,16.OFFSET:NORMAL:32::LH
"lh r<RT>, <OFFSET>(r<BASE>)"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  GPR[RT] = EXTEND16 (do_load (SD_, AccessLength_HALFWORD, GPR[BASE], EXTEND16 (OFFSET)));
}


100101,5.BASE,5.RT,16.OFFSET:NORMAL:32::LHU
"lhu r<RT>, <OFFSET>(r<BASE>)"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  GPR[RT] = do_load (SD_, AccessLength_HALFWORD, GPR[BASE], EXTEND16 (OFFSET));
}


110000,5.BASE,5.RT,16.OFFSET:NORMAL:32::LL
"ll r<RT>, <OFFSET>(r<BASE>)"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  address_word base = GPR[BASE];
  address_word offset = EXTEND16 (OFFSET);
  {
    address_word vaddr = loadstore_ea (SD_, base, offset);
    address_word paddr;
    int uncached;
    if ((vaddr & 3) != 0)
      {
        SIM_CORE_SIGNAL (SD, CPU, cia, read_map, 4, vaddr, read_transfer, sim_core_unaligned_signal);
      }
    else
      {
	if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
	  {
	    unsigned64 memval = 0;
	    unsigned64 memval1 = 0;
	    unsigned64 mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
	    unsigned int shift = 2;
	    unsigned int reverse = (ReverseEndian ? (mask >> shift) : 0);
	    unsigned int bigend = (BigEndianCPU ? (mask >> shift) : 0);
	    unsigned int byte;
	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ (reverse << shift)));
	    LoadMemory(&memval,&memval1,uncached,AccessLength_WORD,paddr,vaddr,isDATA,isREAL);
	    byte = ((vaddr & mask) ^ (bigend << shift));
	    GPR[RT] = EXTEND32 (memval >> (8 * byte));
	    LLBIT = 1;
	  }
      }
  }
}


110100,5.BASE,5.RT,16.OFFSET:NORMAL:64::LLD
"lld r<RT>, <OFFSET>(r<BASE>)"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  address_word base = GPR[BASE];
  address_word offset = EXTEND16 (OFFSET);
  check_u64 (SD_, instruction_0);
  {
    address_word vaddr = loadstore_ea (SD_, base, offset);
    address_word paddr;
    int uncached;
    if ((vaddr & 7) != 0)
      {
	SIM_CORE_SIGNAL (SD, CPU, cia, read_map, 8, vaddr, read_transfer, sim_core_unaligned_signal);
      }
    else
      {
	if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
	  {
	    unsigned64 memval = 0;
	    unsigned64 memval1 = 0;
	    LoadMemory(&memval,&memval1,uncached,AccessLength_DOUBLEWORD,paddr,vaddr,isDATA,isREAL);
	    GPR[RT] = memval;
	    LLBIT = 1;
	  }
      }
  }
}


001111,00000,5.RT,16.IMMEDIATE:NORMAL:32::LUI
"lui r<RT>, %#lx<IMMEDIATE>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  TRACE_ALU_INPUT1 (IMMEDIATE);
  GPR[RT] = EXTEND32 (IMMEDIATE << 16);
  TRACE_ALU_RESULT (GPR[RT]);
}


100011,5.BASE,5.RT,16.OFFSET:NORMAL:32::LW
"lw r<RT>, <OFFSET>(r<BASE>)"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  GPR[RT] = EXTEND32 (do_load (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET)));
}


1100,ZZ!0!1!3,5.BASE,5.RT,16.OFFSET:NORMAL:32::LWCz
"lwc<ZZ> r<RT>, <OFFSET>(r<BASE>)"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  COP_LW (ZZ, RT, do_load (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET)));
}


100010,5.BASE,5.RT,16.OFFSET:NORMAL:32::LWL
"lwl r<RT>, <OFFSET>(r<BASE>)"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  GPR[RT] = EXTEND32 (do_load_left (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]));
}


100110,5.BASE,5.RT,16.OFFSET:NORMAL:32::LWR
"lwr r<RT>, <OFFSET>(r<BASE>)"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  GPR[RT] = EXTEND32 (do_load_right (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]));
}


100111,5.BASE,5.RT,16.OFFSET:NORMAL:64::LWU
"lwu r<RT>, <OFFSET>(r<BASE>)"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  check_u64 (SD_, instruction_0);
  GPR[RT] = do_load (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET));
}



011100,5.RS,5.RT,00000,00000,000000:SPECIAL2:32::MADD
"madd r<RS>, r<RT>"
*mips32:
*mips64:
*vr5500:
{
  signed64 temp;
  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
  temp = (U8_4 (VL4_8 (HI), VL4_8 (LO))
          + ((signed64) EXTEND32 (GPR[RT]) * (signed64) EXTEND32 (GPR[RS])));
  LO = EXTEND32 (temp);
  HI = EXTEND32 (VH4_8 (temp));
  TRACE_ALU_RESULT2 (HI, LO);
}


011100,5.RS,5.RT,000,2.AC,00000,000000:SPECIAL2:32::MADD
"madd r<RS>, r<RT>":AC == 0
"madd ac<AC>, r<RS>, r<RT>"
*mips32r2:
*mips64r2:
*dsp2:
{
  signed64 temp;
  if (AC == 0)
    check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
  temp = (U8_4 (VL4_8 (DSPHI(AC)), VL4_8 (DSPLO(AC)))
	  + ((signed64) EXTEND32 (GPR[RT]) * (signed64) EXTEND32 (GPR[RS])));
  DSPLO(AC) = EXTEND32 (temp);
  DSPHI(AC) = EXTEND32 (VH4_8 (temp));
  if (AC == 0)
    TRACE_ALU_RESULT2 (HI, LO);
}


011100,5.RS,5.RT,00000,00000,000001:SPECIAL2:32::MADDU
"maddu r<RS>, r<RT>"
*mips32:
*mips64:
*vr5500:
{
  unsigned64 temp;
  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
  temp = (U8_4 (VL4_8 (HI), VL4_8 (LO))
          + ((unsigned64) VL4_8 (GPR[RS]) * (unsigned64) VL4_8 (GPR[RT])));
  ACX += U8_4 (VL4_8 (HI), VL4_8 (LO)) < temp;  /* SmartMIPS */ 
  LO = EXTEND32 (temp);
  HI = EXTEND32 (VH4_8 (temp));
  TRACE_ALU_RESULT2 (HI, LO);
}


011100,5.RS,5.RT,000,2.AC,00000,000001:SPECIAL2:32::MADDU
"maddu r<RS>, r<RT>":AC == 0
"maddu ac<AC>, r<RS>, r<RT>"
*mips32r2:
*mips64r2:
*dsp2:
{
  unsigned64 temp;
  if (AC == 0)
    check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
  temp = (U8_4 (VL4_8 (DSPHI(AC)), VL4_8 (DSPLO(AC)))
	  + ((unsigned64) VL4_8 (GPR[RS]) * (unsigned64) VL4_8 (GPR[RT])));
  if (AC == 0)
    ACX += U8_4 (VL4_8 (HI), VL4_8 (LO)) < temp;  /* SmartMIPS */
  DSPLO(AC) = EXTEND32 (temp);
  DSPHI(AC) = EXTEND32 (VH4_8 (temp));
  if (AC == 0)
    TRACE_ALU_RESULT2 (HI, LO);
}


:function:::void:do_mfhi:int rd
{
  check_mf_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT1 (HI);
  GPR[rd] = HI;
  TRACE_ALU_RESULT (GPR[rd]);
}

000000,0000000000,5.RD,00000,010000:SPECIAL:32::MFHI
"mfhi r<RD>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*vr4100:
*vr5000:
*r3900:
*mips32:
*mips64:
{
  do_mfhi (SD_, RD);
}


000000,000,2.AC,00000,5.RD,00000,010000:SPECIAL:32::MFHI
"mfhi r<RD>":AC == 0
"mfhi r<RD>, ac<AC>"
*mips32r2:
*mips64r2:
*dsp:
{
  if (AC == 0)
    do_mfhi (SD_, RD);
  else
    GPR[RD] = DSPHI(AC);
}


:function:::void:do_mflo:int rd
{
  check_mf_hilo (SD_, LOHISTORY, HIHISTORY);
  TRACE_ALU_INPUT1 (LO);
  GPR[rd] = LO;
  TRACE_ALU_RESULT (GPR[rd]);
}

000000,0000000000,5.RD,00000,010010:SPECIAL:32::MFLO
"mflo r<RD>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*vr4100:
*vr5000:
*r3900:
*mips32:
*mips64:
{
  do_mflo (SD_, RD);
}


000000,000,2.AC,00000,5.RD,00000,010010:SPECIAL:32::MFLO
"mflo r<RD>":AC == 0
"mflo r<RD>, ac<AC>"
*mips32r2:
*mips64r2:
*dsp:
{
  if (AC == 0)
    do_mflo (SD_, RD);
  else
    GPR[RD] = DSPLO(AC);
}


000000,5.RS,5.RT,5.RD,00000,001011:SPECIAL:32::MOVN
"movn r<RD>, r<RS>, r<RT>"
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr5000:
{
  if (GPR[RT] != 0)
    {
      GPR[RD] = GPR[RS];
      TRACE_ALU_RESULT (GPR[RD]);
    }
}



000000,5.RS,5.RT,5.RD,00000,001010:SPECIAL:32::MOVZ
"movz r<RD>, r<RS>, r<RT>"
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr5000:
{
  if (GPR[RT] == 0)
    {
      GPR[RD] = GPR[RS];
      TRACE_ALU_RESULT (GPR[RD]);
    }
}



011100,5.RS,5.RT,00000,00000,000100:SPECIAL2:32::MSUB
"msub r<RS>, r<RT>"
*mips32:
*mips64:
*vr5500:
{
  signed64 temp;
  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
  temp = (U8_4 (VL4_8 (HI), VL4_8 (LO))
          - ((signed64) EXTEND32 (GPR[RT]) * (signed64) EXTEND32 (GPR[RS])));
  LO = EXTEND32 (temp);
  HI = EXTEND32 (VH4_8 (temp));
  TRACE_ALU_RESULT2 (HI, LO);
}


011100,5.RS,5.RT,000,2.AC,00000,000100:SPECIAL2:32::MSUB
"msub r<RS>, r<RT>":AC == 0
"msub ac<AC>, r<RS>, r<RT>"
*mips32r2:
*mips64r2:
*dsp2:
{
  signed64 temp;
  if (AC == 0)
    check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
  temp = (U8_4 (VL4_8 (DSPHI(AC)), VL4_8 (DSPLO(AC)))
	  - ((signed64) EXTEND32 (GPR[RT]) * (signed64) EXTEND32 (GPR[RS])));
  DSPLO(AC) = EXTEND32 (temp);
  DSPHI(AC) = EXTEND32 (VH4_8 (temp));
  if (AC == 0)
    TRACE_ALU_RESULT2 (HI, LO);
}


011100,5.RS,5.RT,00000,00000,000101:SPECIAL2:32::MSUBU
"msubu r<RS>, r<RT>"
*mips32:
*mips64:
*vr5500:
{
  unsigned64 temp;
  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
  temp = (U8_4 (VL4_8 (HI), VL4_8 (LO))
          - ((unsigned64) VL4_8 (GPR[RS]) * (unsigned64) VL4_8 (GPR[RT])));
  LO = EXTEND32 (temp);
  HI = EXTEND32 (VH4_8 (temp));
  TRACE_ALU_RESULT2 (HI, LO);
}


011100,5.RS,5.RT,000,2.AC,00000,000101:SPECIAL2:32::MSUBU
"msubu r<RS>, r<RT>":AC == 0
"msubu ac<AC>, r<RS>, r<RT>"
*mips32r2:
*mips64r2:
*dsp2:
{
  unsigned64 temp;
  if (AC == 0)
    check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
  temp = (U8_4 (VL4_8 (DSPHI(AC)), VL4_8 (DSPLO(AC)))
          - ((unsigned64) VL4_8 (GPR[RS]) * (unsigned64) VL4_8 (GPR[RT])));
  DSPLO(AC) = EXTEND32 (temp);
  DSPHI(AC) = EXTEND32 (VH4_8 (temp));
  if (AC == 0)
    TRACE_ALU_RESULT2 (HI, LO);
}


000000,5.RS,000000000000000,010001:SPECIAL:32::MTHI
"mthi r<RS>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*vr4100:
*vr5000:
*r3900:
*mips32:
*mips64:
{
  check_mt_hilo (SD_, HIHISTORY);
  HI = GPR[RS];
}


000000,5.RS,00000,000,2.AC,00000,010001:SPECIAL:32::MTHI
"mthi r<RS>":AC == 0
"mthi r<RS>, ac<AC>"
*mips32r2:
*mips64r2:
*dsp:
{
  if (AC == 0)
    check_mt_hilo (SD_, HIHISTORY);
  DSPHI(AC) = GPR[RS];
}


000000,5.RS,000000000000000,010011:SPECIAL:32::MTLO
"mtlo r<RS>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*vr4100:
*vr5000:
*r3900:
*mips32:
*mips64:
{
  check_mt_hilo (SD_, LOHISTORY);
  LO = GPR[RS];
}


000000,5.RS,00000,000,2.AC,00000,010011:SPECIAL:32::MTLO
"mtlo r<RS>":AC == 0
"mtlo r<RS>, ac<AC>"
*mips32r2:
*mips64r2:
*dsp:
{
  if (AC == 0)
    check_mt_hilo (SD_, LOHISTORY);
  DSPLO(AC) = GPR[RS];
}


011100,5.RS,5.RT,5.RD,00000,000010:SPECIAL2:32::MUL
"mul r<RD>, r<RS>, r<RT>"
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr5500:
{
  signed64 prod;
  if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
  prod = (((signed64)(signed32) GPR[RS])
          * ((signed64)(signed32) GPR[RT]));
  GPR[RD] = EXTEND32 (VL4_8 (prod));
  TRACE_ALU_RESULT (GPR[RD]);
}



:function:::void:do_mult:int rs, int rt, int rd
{
  signed64 prod;
  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  prod = (((signed64)(signed32) GPR[rs])
	  * ((signed64)(signed32) GPR[rt]));
  LO = EXTEND32 (VL4_8 (prod));
  HI = EXTEND32 (VH4_8 (prod));
  ACX = 0;  /* SmartMIPS */
  if (rd != 0)
    GPR[rd] = LO;
  TRACE_ALU_RESULT2 (HI, LO);
}

000000,5.RS,5.RT,0000000000,011000:SPECIAL:32::MULT
"mult r<RS>, r<RT>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips64:
*vr4100:
{
  do_mult (SD_, RS, RT, 0);
}


000000,5.RS,5.RT,000,2.AC,00000,011000:SPECIAL:32::MULT
"mult r<RS>, r<RT>":AC == 0
"mult ac<AC>, r<RS>, r<RT>"
*mips32r2:
*mips64r2:
*dsp2:
{
  signed64 prod;
  if (AC == 0)
    check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
  prod = ((signed64)(signed32) GPR[RS])
	  * ((signed64)(signed32) GPR[RT]);
  DSPLO(AC) = EXTEND32 (VL4_8 (prod));
  DSPHI(AC) = EXTEND32 (VH4_8 (prod));
  if (AC == 0)
    {
      ACX = 0;  /* SmartMIPS */
      TRACE_ALU_RESULT2 (HI, LO);
    }
}


000000,5.RS,5.RT,5.RD,00000,011000:SPECIAL:32::MULT
"mult r<RS>, r<RT>":RD == 0
"mult r<RD>, r<RS>, r<RT>"
*vr5000:
*r3900:
{
  do_mult (SD_, RS, RT, RD);
}


:function:::void:do_multu:int rs, int rt, int rd
{
  unsigned64 prod;
  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  prod = (((unsigned64)(unsigned32) GPR[rs])
	  * ((unsigned64)(unsigned32) GPR[rt]));
  LO = EXTEND32 (VL4_8 (prod));
  HI = EXTEND32 (VH4_8 (prod));
  if (rd != 0)
    GPR[rd] = LO;
  TRACE_ALU_RESULT2 (HI, LO);
}

000000,5.RS,5.RT,0000000000,011001:SPECIAL:32::MULTU
"multu r<RS>, r<RT>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips64:
*vr4100:
{
  do_multu (SD_, RS, RT, 0);
}


000000,5.RS,5.RT,000,2.AC,00000,011001:SPECIAL:32::MULTU
"multu r<RS>, r<RT>":AC == 0
"multu r<RS>, r<RT>"
*mips32r2:
*mips64r2:
*dsp2:
{
  unsigned64 prod;
  if (AC == 0)
    check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
  prod = ((unsigned64)(unsigned32) GPR[RS])
          * ((unsigned64)(unsigned32) GPR[RT]);
  DSPLO(AC) = EXTEND32 (VL4_8 (prod));
  DSPHI(AC) = EXTEND32 (VH4_8 (prod));
  if (AC == 0)
    TRACE_ALU_RESULT2 (HI, LO);
}


000000,5.RS,5.RT,5.RD,00000,011001:SPECIAL:32::MULTU
"multu r<RS>, r<RT>":RD == 0
"multu r<RD>, r<RS>, r<RT>"
*vr5000:
*r3900:
{
  do_multu (SD_, RS, RT, RD);
}


:function:::void:do_nor:int rs, int rt, int rd
{
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = ~ (GPR[rs] | GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}

000000,5.RS,5.RT,5.RD,00000,100111:SPECIAL:32::NOR
"nor r<RD>, r<RS>, r<RT>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_nor (SD_, RS, RT, RD);
}


:function:::void:do_or:int rs, int rt, int rd
{
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = (GPR[rs] | GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}

000000,5.RS,5.RT,5.RD,00000,100101:SPECIAL:32::OR
"or r<RD>, r<RS>, r<RT>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_or (SD_, RS, RT, RD);
}



:function:::void:do_ori:int rs, int rt, unsigned immediate
{
  TRACE_ALU_INPUT2 (GPR[rs], immediate);
  GPR[rt] = (GPR[rs] | immediate);
  TRACE_ALU_RESULT (GPR[rt]);
}

001101,5.RS,5.RT,16.IMMEDIATE:NORMAL:32::ORI
"ori r<RT>, r<RS>, %#lx<IMMEDIATE>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_ori (SD_, RS, RT, IMMEDIATE);
}


110011,5.BASE,5.HINT,16.OFFSET:NORMAL:32::PREF
"pref <HINT>, <OFFSET>(r<BASE>)"
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr5000:
{
  address_word base = GPR[BASE];
  address_word offset = EXTEND16 (OFFSET);
  {
    address_word vaddr = loadstore_ea (SD_, base, offset);
    address_word paddr;
    int uncached;
    {
      if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
	Prefetch(uncached,paddr,vaddr,isDATA,HINT);
    }
  }
}


:function:::unsigned64:do_ror:unsigned32 x,unsigned32 y
{
  unsigned64 result;

  y &= 31;
  TRACE_ALU_INPUT2 (x, y);
  result = EXTEND32 (ROTR32 (x, y));
  TRACE_ALU_RESULT (result);
  return result;
}

000000,00001,5.RT,5.RD,5.SHIFT,000010::32::ROR
"ror r<RD>, r<RT>, <SHIFT>"
*mips32r2:
*mips64r2:
*smartmips:
*vr5400:
*vr5500:
{
  GPR[RD] = do_ror (SD_, GPR[RT], SHIFT);
}

000000,5.RS,5.RT,5.RD,00001,000110::32::RORV
"rorv r<RD>, r<RT>, r<RS>"
*mips32r2:
*mips64r2:
*smartmips:
*vr5400:
*vr5500:
{
  GPR[RD] = do_ror (SD_, GPR[RT], GPR[RS]);
}


:function:::void:do_store:unsigned access, address_word base, address_word offset, unsigned_word word
{
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? (mask ^ access) : 0);
  address_word bigendiancpu = (BigEndianCPU ? (mask ^ access) : 0);
  unsigned int byte;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;

  vaddr = loadstore_ea (SD_, base, offset);
  if ((vaddr & access) != 0)
    {
      SIM_CORE_SIGNAL (SD, STATE_CPU(SD, 0), cia, read_map, access+1, vaddr, write_transfer, sim_core_unaligned_signal);
    }
  AddressTranslation (vaddr, isDATA, isSTORE, &paddr, &uncached, isTARGET, isREAL);
  paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
  byte = ((vaddr & mask) ^ bigendiancpu);
  memval = (word << (8 * byte));
  StoreMemory (uncached, access, memval, 0, paddr, vaddr, isREAL);
}

:function:::void:do_store_left:unsigned access, address_word base, address_word offset, unsigned_word rt
{
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? -1 : 0);
  address_word bigendiancpu = (BigEndianCPU ? -1 : 0);
  unsigned int byte;
  unsigned int word;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;
  int nr_lhs_bits;
  int nr_rhs_bits;

  vaddr = loadstore_ea (SD_, base, offset);
  AddressTranslation (vaddr, isDATA, isSTORE, &paddr, &uncached, isTARGET, isREAL);
  paddr = (paddr ^ (reverseendian & mask));
  if (BigEndianMem == 0)
    paddr = paddr & ~access;

  /* compute where within the word/mem we are */
  byte = ((vaddr ^ bigendiancpu) & access); /* 0..access */
  word = ((vaddr ^ bigendiancpu) & (mask & ~access)) / (access + 1); /* 0..1 */
  nr_lhs_bits = 8 * byte + 8;
  nr_rhs_bits = 8 * access - 8 * byte;
  /* nr_lhs_bits + nr_rhs_bits == 8 * (accesss + 1) */
  /* fprintf (stderr, "s[wd]l: 0x%08lx%08lx 0x%08lx%08lx %d:%d %d+%d\n",
	   (long) ((unsigned64) vaddr >> 32), (long) vaddr,
	   (long) ((unsigned64) paddr >> 32), (long) paddr,
	   word, byte, nr_lhs_bits, nr_rhs_bits); */

  if (word == 0)
    {
      memval = (rt >> nr_rhs_bits);
    }
  else
    {
      memval = (rt << nr_lhs_bits);
    }
  /* fprintf (stderr, "s[wd]l: 0x%08lx%08lx -> 0x%08lx%08lx\n",
	   (long) ((unsigned64) rt >> 32), (long) rt,
	   (long) ((unsigned64) memval >> 32), (long) memval); */
  StoreMemory (uncached, byte, memval, 0, paddr, vaddr, isREAL);
}

:function:::void:do_store_right:unsigned access, address_word base, address_word offset, unsigned_word rt
{
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? -1 : 0);
  address_word bigendiancpu = (BigEndianCPU ? -1 : 0);
  unsigned int byte;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;

  vaddr = loadstore_ea (SD_, base, offset);
  AddressTranslation (vaddr, isDATA, isSTORE, &paddr, &uncached, isTARGET, isREAL);
  paddr = (paddr ^ (reverseendian & mask));
  if (BigEndianMem != 0)
    paddr &= ~access;
  byte = ((vaddr & mask) ^ (bigendiancpu & mask));
  memval = (rt << (byte * 8));
  StoreMemory (uncached, access - (access & byte), memval, 0, paddr, vaddr, isREAL);
}


101000,5.BASE,5.RT,16.OFFSET:NORMAL:32::SB
"sb r<RT>, <OFFSET>(r<BASE>)"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_store (SD_, AccessLength_BYTE, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
}


111000,5.BASE,5.RT,16.OFFSET:NORMAL:32::SC
"sc r<RT>, <OFFSET>(r<BASE>)"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  unsigned32 instruction = instruction_0;
  address_word base = GPR[BASE];
  address_word offset = EXTEND16 (OFFSET);
  {
    address_word vaddr = loadstore_ea (SD_, base, offset);
    address_word paddr;
    int uncached;
    if ((vaddr & 3) != 0)
      {
	SIM_CORE_SIGNAL (SD, CPU, cia, read_map, 4, vaddr, write_transfer, sim_core_unaligned_signal);
      }
    else
      {
	if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
	  {
	    unsigned64 memval = 0;
	    unsigned64 memval1 = 0;
	    unsigned64 mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
	    address_word reverseendian = (ReverseEndian ? (mask ^ AccessLength_WORD) : 0);
	    address_word bigendiancpu = (BigEndianCPU ? (mask ^ AccessLength_WORD) : 0);
	    unsigned int byte;
	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
	    byte = ((vaddr & mask) ^ bigendiancpu);
	    memval = ((unsigned64) GPR[RT] << (8 * byte));
	    if (LLBIT)
	      {
		StoreMemory(uncached,AccessLength_WORD,memval,memval1,paddr,vaddr,isREAL);
	      }
	    GPR[RT] = LLBIT;
	  }
      }
  }
}


111100,5.BASE,5.RT,16.OFFSET:NORMAL:64::SCD
"scd r<RT>, <OFFSET>(r<BASE>)"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  address_word base = GPR[BASE];
  address_word offset = EXTEND16 (OFFSET);
  check_u64 (SD_, instruction_0);
  {
    address_word vaddr = loadstore_ea (SD_, base, offset);
    address_word paddr;
    int uncached;
    if ((vaddr & 7) != 0)
      {
	SIM_CORE_SIGNAL (SD, CPU, cia, read_map, 8, vaddr, write_transfer, sim_core_unaligned_signal);
      }
    else
      {
	if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
	  {
	    unsigned64 memval = 0;
	    unsigned64 memval1 = 0;
	    memval = GPR[RT];
	    if (LLBIT)
	      {
		StoreMemory(uncached,AccessLength_DOUBLEWORD,memval,memval1,paddr,vaddr,isREAL);
	      }
	    GPR[RT] = LLBIT;
	  }
      }
  }
}


111111,5.BASE,5.RT,16.OFFSET:NORMAL:64::SD
"sd r<RT>, <OFFSET>(r<BASE>)"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  check_u64 (SD_, instruction_0);
  do_store (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
}


1111,ZZ!0!1!3,5.BASE,5.RT,16.OFFSET:NORMAL:64::SDCz
"sdc<ZZ> r<RT>, <OFFSET>(r<BASE>)"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  do_store (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET), COP_SD (ZZ, RT));
}


101100,5.BASE,5.RT,16.OFFSET:NORMAL:64::SDL
"sdl r<RT>, <OFFSET>(r<BASE>)"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  check_u64 (SD_, instruction_0);
  do_store_left (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
}


101101,5.BASE,5.RT,16.OFFSET:NORMAL:64::SDR
"sdr r<RT>, <OFFSET>(r<BASE>)"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  check_u64 (SD_, instruction_0);
  do_store_right (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
}



101001,5.BASE,5.RT,16.OFFSET:NORMAL:32::SH
"sh r<RT>, <OFFSET>(r<BASE>)"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_store (SD_, AccessLength_HALFWORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
}


:function:::void:do_sll:int rt, int rd, int shift
{
  unsigned32 temp = (GPR[rt] << shift);
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}

000000,00000,5.RT,5.RD,5.SHIFT,000000:SPECIAL:32::SLLa
"nop":RD == 0 && RT == 0 && SHIFT == 0
"sll r<RD>, r<RT>, <SHIFT>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*vr4100:
*vr5000:
*r3900:
{
  /* Skip shift for NOP, so that there won't be lots of extraneous
     trace output.  */
  if (RD != 0 || RT != 0 || SHIFT != 0)
    do_sll (SD_, RT, RD, SHIFT);
}

000000,00000,5.RT,5.RD,5.SHIFT,000000:SPECIAL:32::SLLb
"nop":RD == 0 && RT == 0 && SHIFT == 0
"ssnop":RD == 0 && RT == 0 && SHIFT == 1
"sll r<RD>, r<RT>, <SHIFT>"
*mips32:
*mips32r2:
*mips64:
*mips64r2:
{
  /* Skip shift for NOP and SSNOP, so that there won't be lots of
     extraneous trace output.  */
  if (RD != 0 || RT != 0 || (SHIFT != 0 && SHIFT != 1))
    do_sll (SD_, RT, RD, SHIFT);
}


:function:::void:do_sllv:int rs, int rt, int rd
{
  int s = MASKED (GPR[rs], 4, 0);
  unsigned32 temp = (GPR[rt] << s);
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}

000000,5.RS,5.RT,5.RD,00000,000100:SPECIAL:32::SLLV
"sllv r<RD>, r<RT>, r<RS>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_sllv (SD_, RS, RT, RD);
}


:function:::void:do_slt:int rs, int rt, int rd
{
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = ((signed_word) GPR[rs] < (signed_word) GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}

000000,5.RS,5.RT,5.RD,00000,101010:SPECIAL:32::SLT
"slt r<RD>, r<RS>, r<RT>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_slt (SD_, RS, RT, RD);
}


:function:::void:do_slti:int rs, int rt, unsigned16 immediate
{
  TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));
  GPR[rt] = ((signed_word) GPR[rs] < (signed_word) EXTEND16 (immediate));
  TRACE_ALU_RESULT (GPR[rt]);
}

001010,5.RS,5.RT,16.IMMEDIATE:NORMAL:32::SLTI
"slti r<RT>, r<RS>, <IMMEDIATE>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_slti (SD_, RS, RT, IMMEDIATE);
}


:function:::void:do_sltiu:int rs, int rt, unsigned16 immediate
{
  TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));
  GPR[rt] = ((unsigned_word) GPR[rs] < (unsigned_word) EXTEND16 (immediate));
  TRACE_ALU_RESULT (GPR[rt]);
}

001011,5.RS,5.RT,16.IMMEDIATE:NORMAL:32::SLTIU
"sltiu r<RT>, r<RS>, <IMMEDIATE>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_sltiu (SD_, RS, RT, IMMEDIATE);
}



:function:::void:do_sltu:int rs, int rt, int rd
{
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = ((unsigned_word) GPR[rs] < (unsigned_word) GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}

000000,5.RS,5.RT,5.RD,00000,101011:SPECIAL:32::SLTU
"sltu r<RD>, r<RS>, r<RT>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_sltu (SD_, RS, RT, RD);
}


:function:::void:do_sra:int rt, int rd, int shift
{
  signed32 temp = (signed32) GPR[rt] >> shift;
  if (NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}

000000,00000,5.RT,5.RD,5.SHIFT,000011:SPECIAL:32::SRA
"sra r<RD>, r<RT>, <SHIFT>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_sra (SD_, RT, RD, SHIFT);
}



:function:::void:do_srav:int rs, int rt, int rd
{
  int s = MASKED (GPR[rs], 4, 0);
  signed32 temp = (signed32) GPR[rt] >> s;
  if (NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}

000000,5.RS,5.RT,5.RD,00000,000111:SPECIAL:32::SRAV
"srav r<RD>, r<RT>, r<RS>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_srav (SD_, RS, RT, RD);
}



:function:::void:do_srl:int rt, int rd, int shift
{
  unsigned32 temp = (unsigned32) GPR[rt] >> shift;
  if (NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}

000000,00000,5.RT,5.RD,5.SHIFT,000010:SPECIAL:32::SRL
"srl r<RD>, r<RT>, <SHIFT>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_srl (SD_, RT, RD, SHIFT);
}


:function:::void:do_srlv:int rs, int rt, int rd
{
  int s = MASKED (GPR[rs], 4, 0);
  unsigned32 temp = (unsigned32) GPR[rt] >> s;
  if (NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}

000000,5.RS,5.RT,5.RD,00000,000110:SPECIAL:32::SRLV
"srlv r<RD>, r<RT>, r<RS>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_srlv (SD_, RS, RT, RD);
}


000000,5.RS,5.RT,5.RD,00000,100010:SPECIAL:32::SUB
"sub r<RD>, r<RS>, r<RT>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  if (NotWordValue (GPR[RS]) || NotWordValue (GPR[RT]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);
  {
    ALU32_BEGIN (GPR[RS]);
    ALU32_SUB (GPR[RT]);
    ALU32_END (GPR[RD]);   /* This checks for overflow.  */
  }
  TRACE_ALU_RESULT (GPR[RD]);
}


:function:::void:do_subu:int rs, int rt, int rd
{
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = EXTEND32 (GPR[rs] - GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}

000000,5.RS,5.RT,5.RD,00000,100011:SPECIAL:32::SUBU
"subu r<RD>, r<RS>, r<RT>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_subu (SD_, RS, RT, RD);
}


101011,5.BASE,5.RT,16.OFFSET:NORMAL:32::SW
"sw r<RT>, <OFFSET>(r<BASE>)"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*r3900:
*vr5000:
{
  do_store (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
}


1110,ZZ!0!1!3,5.BASE,5.RT,16.OFFSET:NORMAL:32::SWCz
"swc<ZZ> r<RT>, <OFFSET>(r<BASE>)"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_store (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), COP_SW (ZZ, RT));
}


101010,5.BASE,5.RT,16.OFFSET:NORMAL:32::SWL
"swl r<RT>, <OFFSET>(r<BASE>)"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_store_left (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
}


101110,5.BASE,5.RT,16.OFFSET:NORMAL:32::SWR
"swr r<RT>, <OFFSET>(r<BASE>)"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_store_right (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]);
}


000000,000000000000000,5.STYPE,001111:SPECIAL:32::SYNC
"sync":STYPE == 0
"sync <STYPE>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  SyncOperation (STYPE);
}


000000,20.CODE,001100:SPECIAL:32::SYSCALL
"syscall %#lx<CODE>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  SignalException (SystemCall, instruction_0);
}


000000,5.RS,5.RT,10.CODE,110100:SPECIAL:32::TEQ
"teq r<RS>, r<RT>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  if ((signed_word) GPR[RS] == (signed_word) GPR[RT])
    SignalException (Trap, instruction_0);
}


000001,5.RS,01100,16.IMMEDIATE:REGIMM:32::TEQI
"teqi r<RS>, <IMMEDIATE>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  if ((signed_word) GPR[RS] == (signed_word) EXTEND16 (IMMEDIATE))
    SignalException (Trap, instruction_0);
}


000000,5.RS,5.RT,10.CODE,110000:SPECIAL:32::TGE
"tge r<RS>, r<RT>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  if ((signed_word) GPR[RS] >= (signed_word) GPR[RT])
    SignalException (Trap, instruction_0);
}


000001,5.RS,01000,16.IMMEDIATE:REGIMM:32::TGEI
"tgei r<RS>, <IMMEDIATE>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  if ((signed_word) GPR[RS] >= (signed_word) EXTEND16 (IMMEDIATE))
    SignalException (Trap, instruction_0);
}


000001,5.RS,01001,16.IMMEDIATE:REGIMM:32::TGEIU
"tgeiu r<RS>, <IMMEDIATE>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  if ((unsigned_word) GPR[RS] >= (unsigned_word) EXTEND16 (IMMEDIATE))
    SignalException (Trap, instruction_0);
}


000000,5.RS,5.RT,10.CODE,110001:SPECIAL:32::TGEU
"tgeu r<RS>, r<RT>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  if ((unsigned_word) GPR[RS] >= (unsigned_word) GPR[RT])
    SignalException (Trap, instruction_0);
}


000000,5.RS,5.RT,10.CODE,110010:SPECIAL:32::TLT
"tlt r<RS>, r<RT>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  if ((signed_word) GPR[RS] < (signed_word) GPR[RT])
    SignalException (Trap, instruction_0);
}


000001,5.RS,01010,16.IMMEDIATE:REGIMM:32::TLTI
"tlti r<RS>, <IMMEDIATE>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  if ((signed_word) GPR[RS] < (signed_word) EXTEND16 (IMMEDIATE))
    SignalException (Trap, instruction_0);
}


000001,5.RS,01011,16.IMMEDIATE:REGIMM:32::TLTIU
"tltiu r<RS>, <IMMEDIATE>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  if ((unsigned_word) GPR[RS] < (unsigned_word) EXTEND16 (IMMEDIATE))
    SignalException (Trap, instruction_0);
}


000000,5.RS,5.RT,10.CODE,110011:SPECIAL:32::TLTU
"tltu r<RS>, r<RT>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  if ((unsigned_word) GPR[RS] < (unsigned_word) GPR[RT])
    SignalException (Trap, instruction_0);
}


000000,5.RS,5.RT,10.CODE,110110:SPECIAL:32::TNE
"tne r<RS>, r<RT>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  if ((signed_word) GPR[RS] != (signed_word) GPR[RT])
    SignalException (Trap, instruction_0);
}


000001,5.RS,01110,16.IMMEDIATE:REGIMM:32::TNEI
"tnei r<RS>, <IMMEDIATE>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  if ((signed_word) GPR[RS] != (signed_word) EXTEND16 (IMMEDIATE))
    SignalException (Trap, instruction_0);
}


:function:::void:do_xor:int rs, int rt, int rd
{
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = GPR[rs] ^ GPR[rt];
  TRACE_ALU_RESULT (GPR[rd]);
}

000000,5.RS,5.RT,5.RD,00000,100110:SPECIAL:32::XOR
"xor r<RD>, r<RS>, r<RT>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_xor (SD_, RS, RT, RD);
}


:function:::void:do_xori:int rs, int rt, unsigned16 immediate
{
  TRACE_ALU_INPUT2 (GPR[rs], immediate);
  GPR[rt] = GPR[rs] ^ immediate;
  TRACE_ALU_RESULT (GPR[rt]);
}

001110,5.RS,5.RT,16.IMMEDIATE:NORMAL:32::XORI
"xori r<RT>, r<RS>, %#lx<IMMEDIATE>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  do_xori (SD_, RS, RT, IMMEDIATE);
}


//
// MIPS Architecture:
//
//        FPU Instruction Set (COP1 & COP1X)
//


:%s::::FMT:int fmt
{
  switch (fmt)
    {
    case fmt_single: return "s";
    case fmt_double: return "d";
    case fmt_word: return "w";
    case fmt_long: return "l";
    case fmt_ps: return "ps";
    default: return "?";
    }
}

:%s::::TF:int tf
{
  if (tf)
    return "t";
  else
    return "f";
}

:%s::::ND:int nd
{
  if (nd)
    return "l";
  else
    return "";
}

:%s::::COND:int cond
{
  switch (cond)
    {
    case 00: return "f";
    case 01: return "un";
    case 02: return "eq";
    case 03: return "ueq";
    case 04: return "olt";
    case 05: return "ult";
    case 06: return "ole";
    case 07: return "ule";
    case 010: return "sf";
    case 011: return "ngle";
    case 012: return "seq";
    case 013: return "ngl";
    case 014: return "lt";
    case 015: return "nge";
    case 016: return "le";
    case 017: return "ngt";
    default: return "?";
    }
}


// Helpers:
//
// Check that the given FPU format is usable, and signal a
// ReservedInstruction exception if not.
//

// check_fmt_p checks that the format is single, double, or paired single.
:function:::void:check_fmt_p:int fmt, instruction_word insn
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mips32:
*vr4100:
*vr5000:
*r3900:
{
  /* None of these ISAs support Paired Single, so just fall back to
     the single/double check.  */
  if ((fmt != fmt_single) && (fmt != fmt_double))
    SignalException (ReservedInstruction, insn);
}

:function:::void:check_fmt_p:int fmt, instruction_word insn
*mips32r2:
{
  if ((fmt != fmt_single) && (fmt != fmt_double) && (fmt != fmt_ps))
    SignalException (ReservedInstruction, insn);
}

:function:::void:check_fmt_p:int fmt, instruction_word insn
*mipsV:
*mips64:
*mips64r2:
{
  if ((fmt != fmt_single) && (fmt != fmt_double)
      && (fmt != fmt_ps || (UserMode && (SR & (status_UX|status_PX)) == 0)))
    SignalException (ReservedInstruction, insn);
}


// Helper:
//
// Check that the FPU is currently usable, and signal a CoProcessorUnusable
// exception if not.
//

:function:::void:check_fpu:
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  if (! COP_Usable (1))
    SignalExceptionCoProcessorUnusable (1);
}


// Helper:
//
// Load a double word FP value using 2 32-bit memory cycles a la MIPS II
// or MIPS32.  do_load cannot be used instead because it returns an
// unsigned_word, which is limited to the size of the machine's registers.
//

:function:::unsigned64:do_load_double:address_word base, address_word offset
*mipsII:
*mips32:
*mips32r2:
{
  int bigendian = (BigEndianCPU ? ! ReverseEndian : ReverseEndian);
  address_word vaddr;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  unsigned64 v;

  vaddr = loadstore_ea (SD_, base, offset);
  if ((vaddr & AccessLength_DOUBLEWORD) != 0)
    {
      SIM_CORE_SIGNAL (SD, STATE_CPU (SD, 0), cia, read_map,
		       AccessLength_DOUBLEWORD + 1, vaddr, read_transfer,
		       sim_core_unaligned_signal);
    }
  AddressTranslation (vaddr, isDATA, isLOAD, &paddr, &uncached, isTARGET,
		      isREAL);
  LoadMemory (&memval, NULL, uncached, AccessLength_WORD, paddr, vaddr,
	      isDATA, isREAL);
  v = (unsigned64)memval;
  LoadMemory (&memval, NULL, uncached, AccessLength_WORD, paddr + 4, vaddr + 4,
	      isDATA, isREAL);
  return (bigendian ? ((v << 32) | memval) : (v | (memval << 32)));
}


// Helper:
//
// Store a double word FP value using 2 32-bit memory cycles a la MIPS II
// or MIPS32.  do_load cannot be used instead because it returns an
// unsigned_word, which is limited to the size of the machine's registers.
//

:function:::void:do_store_double:address_word base, address_word offset, unsigned64 v
*mipsII:
*mips32:
*mips32r2:
{
  int bigendian = (BigEndianCPU ? ! ReverseEndian : ReverseEndian);
  address_word vaddr;
  address_word paddr;
  int uncached;
  unsigned64 memval;

  vaddr = loadstore_ea (SD_, base, offset);
  if ((vaddr & AccessLength_DOUBLEWORD) != 0)
    {
      SIM_CORE_SIGNAL (SD, STATE_CPU(SD, 0), cia, read_map,
		       AccessLength_DOUBLEWORD + 1, vaddr, write_transfer,
		       sim_core_unaligned_signal);
    }
  AddressTranslation (vaddr, isDATA, isSTORE, &paddr, &uncached, isTARGET,
		      isREAL);
  memval = (bigendian ? (v >> 32) : (v & 0xFFFFFFFF));
  StoreMemory (uncached, AccessLength_WORD, memval, 0, paddr, vaddr,
	       isREAL);
  memval = (bigendian ? (v & 0xFFFFFFFF) : (v >> 32));
  StoreMemory (uncached, AccessLength_WORD, memval, 0, paddr + 4, vaddr + 4,
	       isREAL);
}


010001,10,3.FMT!2!3!4!5!7,00000,5.FS,5.FD,000101:COP1:32,f::ABS.fmt
"abs.%s<FMT> f<FD>, f<FS>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  int fmt = FMT;
  check_fpu (SD_);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (FD, fmt, AbsoluteValue (ValueFPR (FS, fmt), fmt));
}



010001,10,3.FMT!2!3!4!5!7,5.FT,5.FS,5.FD,000000:COP1:32,f::ADD.fmt
"add.%s<FMT> f<FD>, f<FS>, f<FT>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  int fmt = FMT;
  check_fpu (SD_);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (FD, fmt, Add (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
}


010011,5.RS,5.FT,5.FS,5.FD,011,110:COP1X:32,f::ALNV.PS
"alnv.ps f<FD>, f<FS>, f<FT>, r<RS>"
*mipsV:
*mips32r2:
*mips64:
*mips64r2:
{
  unsigned64 fs;
  unsigned64 ft;
  unsigned64 fd;
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  fs = ValueFPR (FS, fmt_ps);
  if ((GPR[RS] & 0x3) != 0)
    Unpredictable ();
  if ((GPR[RS] & 0x4) == 0)
    fd = fs;
  else
    {
      ft = ValueFPR (FT, fmt_ps);
      if (BigEndianCPU)
	fd = PackPS (PSLower (fs), PSUpper (ft));
      else
	fd = PackPS (PSLower (ft), PSUpper (fs));
    }
  StoreFPR (FD, fmt_ps, fd);
}


// BC1F
// BC1FL
// BC1T
// BC1TL

010001,01000,3.0,1.ND,1.TF,16.OFFSET:COP1S:32,f::BC1a
"bc1%s<TF>%s<ND> <OFFSET>"
*mipsI:
*mipsII:
*mipsIII:
{
  check_fpu (SD_);
  TRACE_BRANCH_INPUT (PREVCOC1());
  if (PREVCOC1() == TF)
    {
      address_word dest = NIA + (EXTEND16 (OFFSET) << 2);
      TRACE_BRANCH_RESULT (dest);
      DELAY_SLOT (dest);
    }
  else if (ND)
    {
      TRACE_BRANCH_RESULT (0);
      NULLIFY_NEXT_INSTRUCTION ();
    }
  else
    {
      TRACE_BRANCH_RESULT (NIA);
    }
}

010001,01000,3.CC,1.ND,1.TF,16.OFFSET:COP1S:32,f::BC1b
"bc1%s<TF>%s<ND> <OFFSET>":CC == 0
"bc1%s<TF>%s<ND> <CC>, <OFFSET>"
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
#*vr4100:
*vr5000:
*r3900:
{
  check_fpu (SD_);
  if (GETFCC(CC) == TF)
    {
      address_word dest = NIA + (EXTEND16 (OFFSET) << 2);
      DELAY_SLOT (dest);
    }
  else if (ND)
    {
      NULLIFY_NEXT_INSTRUCTION ();
    }
}


010001,10,3.FMT!2!3!4!5!6!7,5.FT,5.FS,3.0,00,11,4.COND:COP1:32,f::C.cond.fmta
"c.%s<COND>.%s<FMT> f<FS>, f<FT>"
*mipsI:
*mipsII:
*mipsIII:
{
  int fmt = FMT;
  check_fpu (SD_);
  Compare (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt, COND, 0);
  TRACE_ALU_RESULT (ValueFCR (31));
}

010001,10,3.FMT!2!3!4!5!7,5.FT,5.FS,3.CC,00,11,4.COND:COP1:32,f::C.cond.fmtb
"c.%s<COND>.%s<FMT> f<FS>, f<FT>":CC == 0
"c.%s<COND>.%s<FMT> <CC>, f<FS>, f<FT>"
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  int fmt = FMT;
  check_fpu (SD_);
  check_fmt_p (SD_, fmt, instruction_0);
  Compare (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt, COND, CC);
  TRACE_ALU_RESULT (ValueFCR (31));
}


010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,001010:COP1:32,f::CEIL.L.fmt
"ceil.l.%s<FMT> f<FD>, f<FS>"
*mipsIII:
*mipsIV:
*mipsV:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  int fmt = FMT;
  check_fpu (SD_);
  StoreFPR (FD, fmt_long, Convert (FP_RM_TOPINF, ValueFPR (FS, fmt), fmt,
	    fmt_long));
}


010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,001110:COP1:32,f::CEIL.W
"ceil.w.%s<FMT> f<FD>, f<FS>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  int fmt = FMT;
  check_fpu (SD_);
  StoreFPR (FD, fmt_word, Convert (FP_RM_TOPINF, ValueFPR (FS, fmt), fmt,
	    fmt_word));
}


010001,00010,5.RT,5.FS,00000000000:COP1:32,f::CFC1a
"cfc1 r<RT>, f<FS>"
*mipsI:
*mipsII:
*mipsIII:
{
  check_fpu (SD_);
  if (FS == 0)
    PENDING_FILL (RT, EXTEND32 (FCR0));
  else if (FS == 31)
    PENDING_FILL (RT, EXTEND32 (FCR31));
  /* else NOP */
}

010001,00010,5.RT,5.FS,00000000000:COP1:32,f::CFC1b
"cfc1 r<RT>, f<FS>"
*mipsIV:
*vr4100:
*vr5000:
*r3900:
{
  check_fpu (SD_);
  if (FS == 0 || FS == 31)
    {
      unsigned_word  fcr = ValueFCR (FS);
      TRACE_ALU_INPUT1 (fcr);
      GPR[RT] = fcr;
    }
  /* else NOP */
  TRACE_ALU_RESULT (GPR[RT]);
}

010001,00010,5.RT,5.FS,00000000000:COP1:32,f::CFC1c
"cfc1 r<RT>, f<FS>"
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
{
  check_fpu (SD_);
  if (FS == 0 || FS == 25 || FS == 26 || FS == 28 || FS == 31)
    {
      unsigned_word  fcr = ValueFCR (FS);
      TRACE_ALU_INPUT1 (fcr);
      GPR[RT] = fcr;
    }
  /* else NOP */
  TRACE_ALU_RESULT (GPR[RT]);
}

010001,00110,5.RT,5.FS,00000000000:COP1:32,f::CTC1a
"ctc1 r<RT>, f<FS>"
*mipsI:
*mipsII:
*mipsIII:
{
  check_fpu (SD_);
  if (FS == 31)
    PENDING_FILL (FCRCS_REGNUM, VL4_8 (GPR[RT]));
  /* else NOP */
}

010001,00110,5.RT,5.FS,00000000000:COP1:32,f::CTC1b
"ctc1 r<RT>, f<FS>"
*mipsIV:
*vr4100:
*vr5000:
*r3900:
{
  check_fpu (SD_);
  TRACE_ALU_INPUT1 (GPR[RT]);
  if (FS == 31)
    StoreFCR (FS, GPR[RT]);
  /* else NOP */
}

010001,00110,5.RT,5.FS,00000000000:COP1:32,f::CTC1c
"ctc1 r<RT>, f<FS>"
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
{
  check_fpu (SD_);
  TRACE_ALU_INPUT1 (GPR[RT]);
  if (FS == 25 || FS == 26 || FS == 28 || FS == 31)
      StoreFCR (FS, GPR[RT]);
  /* else NOP */
}


//
// FIXME: Does not correctly differentiate between mips*
//
010001,10,3.FMT!1!2!3!6!7,00000,5.FS,5.FD,100001:COP1:32,f::CVT.D.fmt
"cvt.d.%s<FMT> f<FD>, f<FS>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  int fmt = FMT;
  check_fpu (SD_);
  if ((fmt == fmt_double) | 0)
    SignalException (ReservedInstruction, instruction_0);
  StoreFPR (FD, fmt_double, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
	    fmt_double));
}


010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,100101:COP1:32,f::CVT.L.fmt
"cvt.l.%s<FMT> f<FD>, f<FS>"
*mipsIII:
*mipsIV:
*mipsV:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  int fmt = FMT;
  check_fpu (SD_);
  if ((fmt == fmt_long) | ((fmt == fmt_long) || (fmt == fmt_word)))
    SignalException (ReservedInstruction, instruction_0);
  StoreFPR (FD, fmt_long, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
	    fmt_long));
}


010001,10,000,5.FT,5.FS,5.FD,100110:COP1:32,f::CVT.PS.S
"cvt.ps.s f<FD>, f<FS>, f<FT>"
*mipsV:
*mips32r2:
*mips64:
*mips64r2:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  StoreFPR (FD, fmt_ps, PackPS (ValueFPR (FS, fmt_single),
				ValueFPR (FT, fmt_single)));
}


//
// FIXME: Does not correctly differentiate between mips*
//
010001,10,3.FMT!0!2!3!6!7,00000,5.FS,5.FD,100000:COP1:32,f::CVT.S.fmt
"cvt.s.%s<FMT> f<FD>, f<FS>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  int fmt = FMT;
  check_fpu (SD_);
  if ((fmt == fmt_single) | 0)
    SignalException (ReservedInstruction, instruction_0);
  StoreFPR (FD, fmt_single, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
	    fmt_single));
}


010001,10,110,00000,5.FS,5.FD,101000:COP1:32,f::CVT.S.PL
"cvt.s.pl f<FD>, f<FS>"
*mipsV:
*mips32r2:
*mips64:
*mips64r2:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  StoreFPR (FD, fmt_single, PSLower (ValueFPR (FS, fmt_ps)));
}


010001,10,110,00000,5.FS,5.FD,100000:COP1:32,f::CVT.S.PU
"cvt.s.pu f<FD>, f<FS>"
*mipsV:
*mips32r2:
*mips64:
*mips64r2:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  StoreFPR (FD, fmt_single, PSUpper (ValueFPR (FS, fmt_ps)));
}


010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,100100:COP1:32,f::CVT.W.fmt
"cvt.w.%s<FMT> f<FD>, f<FS>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  int fmt = FMT;
  check_fpu (SD_);
  if ((fmt == fmt_word) | ((fmt == fmt_long) || (fmt == fmt_word)))
    SignalException (ReservedInstruction, instruction_0);
  StoreFPR (FD, fmt_word, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
	    fmt_word));
}


010001,10,3.FMT!2!3!4!5!6!7,5.FT,5.FS,5.FD,000011:COP1:32,f::DIV.fmt
"div.%s<FMT> f<FD>, f<FS>, f<FT>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  int fmt = FMT;
  check_fpu (SD_);
  StoreFPR (FD, fmt, Divide (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
}


010001,00001,5.RT,5.FS,00000000000:COP1:64,f::DMFC1a
"dmfc1 r<RT>, f<FS>"
*mipsIII:
{
  unsigned64 v;
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  if (SizeFGR () == 64)
    v = FGR[FS];
  else if ((FS & 0x1) == 0)
    v = SET64HI (FGR[FS+1]) | FGR[FS];
  else
    v = SET64HI (0xDEADC0DE) | 0xBAD0BAD0;
  PENDING_FILL (RT, v);
  TRACE_ALU_RESULT (v);
}

010001,00001,5.RT,5.FS,00000000000:COP1:64,f::DMFC1b
"dmfc1 r<RT>, f<FS>"
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  if (SizeFGR () == 64)
    GPR[RT] = FGR[FS];
  else if ((FS & 0x1) == 0)
    GPR[RT] = SET64HI (FGR[FS+1]) | FGR[FS];
  else
    GPR[RT] = SET64HI (0xDEADC0DE) | 0xBAD0BAD0;
  TRACE_ALU_RESULT (GPR[RT]);
}


010001,00101,5.RT,5.FS,00000000000:COP1:64,f::DMTC1a
"dmtc1 r<RT>, f<FS>"
*mipsIII:
{
  unsigned64 v;
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  if (SizeFGR () == 64)
    PENDING_FILL ((FS + FGR_BASE), GPR[RT]);
  else if ((FS & 0x1) == 0)
    {
      PENDING_FILL (((FS + 1) + FGR_BASE), VH4_8 (GPR[RT]));
      PENDING_FILL ((FS + FGR_BASE), VL4_8 (GPR[RT]));
    }
  else
    Unpredictable ();
  TRACE_FP_RESULT (GPR[RT]);
}

010001,00101,5.RT,5.FS,00000000000:COP1:64,f::DMTC1b
"dmtc1 r<RT>, f<FS>"
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  if (SizeFGR () == 64)
    StoreFPR (FS, fmt_uninterpreted_64, GPR[RT]);
  else if ((FS & 0x1) == 0)
    StoreFPR (FS, fmt_uninterpreted_64, GPR[RT]);
  else
    Unpredictable ();
}


010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,001011:COP1:32,f::FLOOR.L.fmt
"floor.l.%s<FMT> f<FD>, f<FS>"
*mipsIII:
*mipsIV:
*mipsV:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  int fmt = FMT;
  check_fpu (SD_);
  StoreFPR (FD, fmt_long, Convert (FP_RM_TOMINF, ValueFPR (FS, fmt), fmt,
	    fmt_long));
}


010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,001111:COP1:32,f::FLOOR.W.fmt
"floor.w.%s<FMT> f<FD>, f<FS>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  int fmt = FMT;
  check_fpu (SD_);
  StoreFPR (FD, fmt_word, Convert (FP_RM_TOMINF, ValueFPR (FS, fmt), fmt,
	    fmt_word));
}


110101,5.BASE,5.FT,16.OFFSET:COP1:32,f::LDC1a
"ldc1 f<FT>, <OFFSET>(r<BASE>)"
*mipsII:
*mips32:
*mips32r2:
{
  check_fpu (SD_);
  COP_LD (1, FT, do_load_double (SD_, GPR[BASE], EXTEND16 (OFFSET)));
}


110101,5.BASE,5.FT,16.OFFSET:COP1:32,f::LDC1b
"ldc1 f<FT>, <OFFSET>(r<BASE>)"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  check_fpu (SD_);
  COP_LD (1, FT, do_load (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET)));
}


010011,5.BASE,5.INDEX,5.0,5.FD,000001:COP1X:32,f::LDXC1
"ldxc1 f<FD>, r<INDEX>(r<BASE>)"
*mips32r2:
{
  check_fpu (SD_);
  COP_LD (1, FD, do_load_double (SD_, GPR[BASE], GPR[INDEX]));
}


010011,5.BASE,5.INDEX,5.0,5.FD,000001:COP1X:64,f::LDXC1
"ldxc1 f<FD>, r<INDEX>(r<BASE>)"
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr5000:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  COP_LD (1, FD, do_load (SD_, AccessLength_DOUBLEWORD, GPR[BASE], GPR[INDEX]));
}


010011,5.BASE,5.INDEX,5.0,5.FD,000101:COP1X:32,f::LUXC1
"luxc1 f<FD>, r<INDEX>(r<BASE>)"
*mips32r2:
{
  address_word base = GPR[BASE];
  address_word index = GPR[INDEX];
  address_word vaddr = base + index;
  check_fpu (SD_);
  if (SizeFGR () != 64)
    Unpredictable ();
  /* Arrange for the bottom 3 bits of (base + index) to be 0.  */
  if ((vaddr & 0x7) != 0)
    index -= (vaddr & 0x7);
  COP_LD (1, FD, do_load_double (SD_, base, index));
}


010011,5.BASE,5.INDEX,5.0,5.FD,000101:COP1X:64,f::LUXC1
"luxc1 f<FD>, r<INDEX>(r<BASE>)"
*mipsV:
*mips64:
*mips64r2:
{
  address_word base = GPR[BASE];
  address_word index = GPR[INDEX];
  address_word vaddr = base + index;
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  if (SizeFGR () != 64)
    Unpredictable ();
  /* Arrange for the bottom 3 bits of (base + index) to be 0.  */
  if ((vaddr & 0x7) != 0)
    index -= (vaddr & 0x7);
  COP_LD (1, FD, do_load (SD_, AccessLength_DOUBLEWORD, base, index));
}


110001,5.BASE,5.FT,16.OFFSET:COP1:32,f::LWC1
"lwc1 f<FT>, <OFFSET>(r<BASE>)"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  check_fpu (SD_);
  COP_LW (1, FT, do_load (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET)));
}


010011,5.BASE,5.INDEX,5.0,5.FD,000000:COP1X:32,f::LWXC1
"lwxc1 f<FD>, r<INDEX>(r<BASE>)"
*mipsIV:
*mipsV:
*mips32r2:
*mips64:
*mips64r2:
*vr5000:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  COP_LW (1, FD, do_load (SD_, AccessLength_WORD, GPR[BASE], GPR[INDEX]));
}



010011,5.FR,5.FT,5.FS,5.FD,100,3.FMT!2!3!4!5!7:COP1X:32,f::MADD.fmt
"madd.%s<FMT> f<FD>, f<FR>, f<FS>, f<FT>"
*mipsIV:
*mipsV:
*mips32r2:
*mips64:
*mips64r2:
*vr5000:
{
  int fmt = FMT;
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0); 
  StoreFPR (FD, fmt, MultiplyAdd (ValueFPR (FS, fmt), ValueFPR (FT, fmt),
				  ValueFPR (FR, fmt), fmt));
}


010001,00000,5.RT,5.FS,00000000000:COP1:32,f::MFC1a
"mfc1 r<RT>, f<FS>"
*mipsI:
*mipsII:
*mipsIII:
{
  unsigned64 v;
  check_fpu (SD_);
  v = EXTEND32 (FGR[FS]);
  PENDING_FILL (RT, v);
  TRACE_ALU_RESULT (v);
}
  
010001,00000,5.RT,5.FS,00000000000:COP1:32,f::MFC1b
"mfc1 r<RT>, f<FS>"
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{ 
  check_fpu (SD_);
  GPR[RT] = EXTEND32 (FGR[FS]);
  TRACE_ALU_RESULT (GPR[RT]);
}


010001,10,3.FMT!2!3!4!5!7,00000,5.FS,5.FD,000110:COP1:32,f::MOV.fmt
"mov.%s<FMT> f<FD>, f<FS>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  int fmt = FMT;
  check_fpu (SD_);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (FD, fmt, ValueFPR (FS, fmt));
}


// MOVF
// MOVT
000000,5.RS,3.CC,0,1.TF,5.RD,00000,000001:SPECIAL:32,f::MOVtf
"mov%s<TF> r<RD>, r<RS>, <CC>"
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr5000:
{
  check_fpu (SD_);
  if (GETFCC(CC) == TF)
    GPR[RD] = GPR[RS];
}


// MOVF.fmt
// MOVT.fmt
010001,10,3.FMT!2!3!4!5!7,3.CC,0,1.TF,5.FS,5.FD,010001:COP1:32,f::MOVtf.fmt
"mov%s<TF>.%s<FMT> f<FD>, f<FS>, <CC>"
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr5000:
{
  int fmt = FMT;
  check_fpu (SD_);
  if (fmt != fmt_ps)
    {
      if (GETFCC(CC) == TF)
	StoreFPR (FD, fmt, ValueFPR (FS, fmt));
      else
	StoreFPR (FD, fmt, ValueFPR (FD, fmt));   /* set fmt */
    }
  else
    {
      unsigned64 fd;
      fd = PackPS (PSUpper (ValueFPR ((GETFCC (CC+1) == TF) ? FS : FD,
				      fmt_ps)),
		   PSLower (ValueFPR ((GETFCC (CC+0) == TF) ? FS : FD,
				      fmt_ps)));
      StoreFPR (FD, fmt_ps, fd);
    }
}


010001,10,3.FMT!2!3!4!5!7,5.RT,5.FS,5.FD,010011:COP1:32,f::MOVN.fmt
"movn.%s<FMT> f<FD>, f<FS>, r<RT>"
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr5000:
{
  check_fpu (SD_);
  if (GPR[RT] != 0)
    StoreFPR (FD, FMT, ValueFPR (FS, FMT));
  else
    StoreFPR (FD, FMT, ValueFPR (FD, FMT));
}


// MOVT see MOVtf


// MOVT.fmt see MOVtf.fmt



010001,10,3.FMT!2!3!4!5!7,5.RT,5.FS,5.FD,010010:COP1:32,f::MOVZ.fmt
"movz.%s<FMT> f<FD>, f<FS>, r<RT>"
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr5000:
{
  check_fpu (SD_);
  if (GPR[RT] == 0)
    StoreFPR (FD, FMT, ValueFPR (FS, FMT));
  else
    StoreFPR (FD, FMT, ValueFPR (FD, FMT));
}


010011,5.FR,5.FT,5.FS,5.FD,101,3.FMT!2!3!4!5!7:COP1X:32,f::MSUB.fmt
"msub.%s<FMT> f<FD>, f<FR>, f<FS>, f<FT>"
*mipsIV:
*mipsV:
*mips32r2:
*mips64:
*mips64r2:
*vr5000:
{
  int fmt = FMT;
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (FD, fmt, MultiplySub (ValueFPR (FS, fmt), ValueFPR (FT, fmt),
				  ValueFPR (FR, fmt), fmt));
}


010001,00100,5.RT,5.FS,00000000000:COP1:32,f::MTC1a
"mtc1 r<RT>, f<FS>"
*mipsI:
*mipsII:
*mipsIII:
{ 
  check_fpu (SD_);
  if (SizeFGR () == 64)
    PENDING_FILL ((FS + FGR_BASE), (SET64HI (0xDEADC0DE) | VL4_8 (GPR[RT])));
  else
    PENDING_FILL ((FS + FGR_BASE), VL4_8 (GPR[RT]));
  TRACE_FP_RESULT (GPR[RT]);
} 

010001,00100,5.RT,5.FS,00000000000:COP1:32,f::MTC1b
"mtc1 r<RT>, f<FS>"
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  check_fpu (SD_); 
  StoreFPR (FS, fmt_uninterpreted_32, VL4_8 (GPR[RT]));
}


010001,10,3.FMT!2!3!4!5!7,5.FT,5.FS,5.FD,000010:COP1:32,f::MUL.fmt
"mul.%s<FMT> f<FD>, f<FS>, f<FT>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  int fmt = FMT;
  check_fpu (SD_);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (FD, fmt, Multiply (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
}


010001,10,3.FMT!2!3!4!5!7,00000,5.FS,5.FD,000111:COP1:32,f::NEG.fmt
"neg.%s<FMT> f<FD>, f<FS>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  int fmt = FMT;
  check_fpu (SD_);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (FD, fmt, Negate (ValueFPR (FS, fmt), fmt));
}


010011,5.FR,5.FT,5.FS,5.FD,110,3.FMT!2!3!4!5!7:COP1X:32,f::NMADD.fmt
"nmadd.%s<FMT> f<FD>, f<FR>, f<FS>, f<FT>"
*mipsIV:
*mipsV:
*mips32r2:
*mips64:
*mips64r2:
*vr5000:
{
  int fmt = FMT;
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (FD, fmt, NegMultiplyAdd (ValueFPR (FS, fmt), ValueFPR (FT, fmt),
				     ValueFPR (FR, fmt), fmt));
}


010011,5.FR,5.FT,5.FS,5.FD,111,3.FMT!2!3!4!5!7:COP1X:32,f::NMSUB.fmt
"nmsub.%s<FMT> f<FD>, f<FR>, f<FS>, f<FT>"
*mipsIV:
*mipsV:
*mips32r2:
*mips64:
*mips64r2:
*vr5000:
{
  int fmt = FMT;
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (FD, fmt, NegMultiplySub (ValueFPR (FS, fmt), ValueFPR (FT, fmt),
				     ValueFPR (FR, fmt), fmt));
}


010001,10,110,5.FT,5.FS,5.FD,101100:COP1:32,f::PLL.PS
"pll.ps f<FD>, f<FS>, f<FT>"
*mipsV:
*mips32r2:
*mips64:
*mips64r2:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  StoreFPR (FD, fmt_ps, PackPS (PSLower (ValueFPR (FS, fmt_ps)),
				PSLower (ValueFPR (FT, fmt_ps))));
}


010001,10,110,5.FT,5.FS,5.FD,101101:COP1:32,f::PLU.PS
"plu.ps f<FD>, f<FS>, f<FT>"
*mipsV:
*mips32r2:
*mips64:
*mips64r2:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  StoreFPR (FD, fmt_ps, PackPS (PSLower (ValueFPR (FS, fmt_ps)),
				PSUpper (ValueFPR (FT, fmt_ps))));
}


010011,5.BASE,5.INDEX,5.HINT,00000,001111:COP1X:32::PREFX
"prefx <HINT>, r<INDEX>(r<BASE>)"
*mipsIV:
*mipsV:
*mips32r2:
*mips64:
*mips64r2:
*vr5000:
{
  address_word base = GPR[BASE];
  address_word index = GPR[INDEX];
  {
    address_word vaddr = loadstore_ea (SD_, base, index);
    address_word paddr;
    int uncached;
    if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
      Prefetch(uncached,paddr,vaddr,isDATA,HINT);
  }
}


010001,10,110,5.FT,5.FS,5.FD,101110:COP1:32,f::PUL.PS
"pul.ps f<FD>, f<FS>, f<FT>"
*mipsV:
*mips32r2:
*mips64:
*mips64r2:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  StoreFPR (FD, fmt_ps, PackPS (PSUpper (ValueFPR (FS, fmt_ps)),
				PSLower (ValueFPR (FT, fmt_ps))));
}


010001,10,110,5.FT,5.FS,5.FD,101111:COP1:32,f::PUU.PS
"puu.ps f<FD>, f<FS>, f<FT>"
*mipsV:
*mips32r2:
*mips64:
*mips64r2:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  StoreFPR (FD, fmt_ps, PackPS (PSUpper (ValueFPR (FS, fmt_ps)),
				PSUpper (ValueFPR (FT, fmt_ps))));
}


010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,010101:COP1:32,f::RECIP.fmt
"recip.%s<FMT> f<FD>, f<FS>"
*mipsIV:
*mipsV:
*mips32r2:
*mips64:
*mips64r2:
*vr5000:
{
  int fmt = FMT;
  check_fpu (SD_);
  StoreFPR (FD, fmt, Recip (ValueFPR (FS, fmt), fmt));
}


010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,001000:COP1:32,f::ROUND.L.fmt
"round.l.%s<FMT> f<FD>, f<FS>"
*mipsIII:
*mipsIV:
*mipsV:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  int fmt = FMT;
  check_fpu (SD_);
  StoreFPR (FD, fmt_long, Convert (FP_RM_NEAREST, ValueFPR (FS, fmt), fmt,
	    fmt_long));
}


010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,001100:COP1:32,f::ROUND.W.fmt
"round.w.%s<FMT> f<FD>, f<FS>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  int fmt = FMT;
  check_fpu (SD_);
  StoreFPR (FD, fmt_word, Convert (FP_RM_NEAREST, ValueFPR (FS, fmt), fmt,
	    fmt_word));
}


010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,010110:COP1:32,f::RSQRT.fmt
"rsqrt.%s<FMT> f<FD>, f<FS>"
*mipsIV:
*mipsV:
*mips32r2:
*mips64:
*mips64r2:
*vr5000:
{
  int fmt = FMT;
  check_fpu (SD_);
  StoreFPR (FD, fmt, RSquareRoot (ValueFPR (FS, fmt), fmt));
}


111101,5.BASE,5.FT,16.OFFSET:COP1:32,f::SDC1a
"sdc1 f<FT>, <OFFSET>(r<BASE>)"
*mipsII:
*mips32:
*mips32r2:
{
  check_fpu (SD_);
  do_store_double (SD_, GPR[BASE], EXTEND16 (OFFSET), COP_SD (1, FT));
}


111101,5.BASE,5.FT,16.OFFSET:COP1:32,f::SDC1b
"sdc1 f<FT>, <OFFSET>(r<BASE>)"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  check_fpu (SD_);
  do_store (SD_, AccessLength_DOUBLEWORD, GPR[BASE], EXTEND16 (OFFSET), COP_SD (1, FT));
}


010011,5.BASE,5.INDEX,5.FS,00000001001:COP1X:32,f::SDXC1
"sdxc1 f<FS>, r<INDEX>(r<BASE>)"
*mips32r2
{
  check_fpu (SD_);
  do_store_double (SD_, GPR[BASE], GPR[INDEX], COP_SD (1, FS));
}


010011,5.BASE,5.INDEX,5.FS,00000001001:COP1X:64,f::SDXC1
"sdxc1 f<FS>, r<INDEX>(r<BASE>)"
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
*vr5000:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  do_store (SD_, AccessLength_DOUBLEWORD, GPR[BASE], GPR[INDEX], COP_SD (1, FS));
}


010011,5.BASE,5.INDEX,5.FS,00000,001101:COP1X:32,f::SUXC1
"suxc1 f<FS>, r<INDEX>(r<BASE>)"
*mips32r2:
{
  address_word base = GPR[BASE];
  address_word index = GPR[INDEX];
  address_word vaddr = base + index;
  check_fpu (SD_);
  if (SizeFGR () != 64)
    Unpredictable ();
  /* Arrange for the bottom 3 bits of (base + index) to be 0.  */
  if ((vaddr & 0x7) != 0)
    index -= (vaddr & 0x7);
  do_store_double (SD_, base, index, COP_SD (1, FS));
}


010011,5.BASE,5.INDEX,5.FS,00000,001101:COP1X:64,f::SUXC1
"suxc1 f<FS>, r<INDEX>(r<BASE>)"
*mipsV:
*mips64:
*mips64r2:
{
  address_word base = GPR[BASE];
  address_word index = GPR[INDEX];
  address_word vaddr = base + index;
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  if (SizeFGR () != 64)
    Unpredictable ();
  /* Arrange for the bottom 3 bits of (base + index) to be 0.  */
  if ((vaddr & 0x7) != 0)
    index -= (vaddr & 0x7);
  do_store (SD_, AccessLength_DOUBLEWORD, base, index, COP_SD (1, FS));
}


010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,000100:COP1:32,f::SQRT.fmt
"sqrt.%s<FMT> f<FD>, f<FS>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  int fmt = FMT;
  check_fpu (SD_);
  StoreFPR (FD, fmt,  (SquareRoot (ValueFPR (FS, fmt), fmt)));
}


010001,10,3.FMT!2!3!4!5!7,5.FT,5.FS,5.FD,000001:COP1:32,f::SUB.fmt
"sub.%s<FMT> f<FD>, f<FS>, f<FT>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  int fmt = FMT;
  check_fpu (SD_);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (FD, fmt, Sub (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
}



111001,5.BASE,5.FT,16.OFFSET:COP1:32,f::SWC1
"swc1 f<FT>, <OFFSET>(r<BASE>)"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  address_word base = GPR[BASE];
  address_word offset = EXTEND16 (OFFSET);
  check_fpu (SD_);
  {
    address_word vaddr = loadstore_ea (SD_, base, offset);
    address_word paddr;
    int uncached;
    if ((vaddr & 3) != 0)
      {
	SIM_CORE_SIGNAL (SD, CPU, cia, read_map, AccessLength_WORD+1, vaddr, write_transfer, sim_core_unaligned_signal);
      }
    else
      {
	if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
	  {
	    uword64 memval = 0;
	    uword64 memval1 = 0;
	    uword64 mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
	    address_word reverseendian = (ReverseEndian ?(mask ^ AccessLength_WORD): 0);
	    address_word bigendiancpu = (BigEndianCPU ?(mask ^ AccessLength_WORD): 0);
	    unsigned int byte;
	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
	    byte = ((vaddr & mask) ^ bigendiancpu);
	    memval = (((uword64)COP_SW(((instruction_0 >> 26) & 0x3),FT)) << (8 * byte));
	    StoreMemory(uncached,AccessLength_WORD,memval,memval1,paddr,vaddr,isREAL);
	  }
      }
  }
}


010011,5.BASE,5.INDEX,5.FS,00000,001000:COP1X:32,f::SWXC1
"swxc1 f<FS>, r<INDEX>(r<BASE>)"
*mipsIV:
*mipsV:
*mips32r2:
*mips64:
*mips64r2:
*vr5000:
{

  address_word base = GPR[BASE];
  address_word index = GPR[INDEX];
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  {
   address_word vaddr = loadstore_ea (SD_, base, index);
   address_word paddr;
   int uncached;
   if ((vaddr & 3) != 0)
     {
       SIM_CORE_SIGNAL (SD, CPU, cia, read_map, 4, vaddr, write_transfer, sim_core_unaligned_signal);
     }
   else
   {
    if (AddressTranslation(vaddr,isDATA,isSTORE,&paddr,&uncached,isTARGET,isREAL))
    {
     unsigned64 memval = 0;
     unsigned64 memval1 = 0;
     unsigned64 mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
     address_word reverseendian = (ReverseEndian ? (mask ^ AccessLength_WORD) : 0);
     address_word bigendiancpu = (BigEndianCPU ? (mask ^ AccessLength_WORD) : 0);
     unsigned int byte;
     paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
     byte = ((vaddr & mask) ^ bigendiancpu);
     memval = (((unsigned64)COP_SW(1,FS)) << (8 * byte));
      {
       StoreMemory(uncached,AccessLength_WORD,memval,memval1,paddr,vaddr,isREAL);
      }
    }
   }
  }
}


010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,001001:COP1:32,f::TRUNC.L.fmt
"trunc.l.%s<FMT> f<FD>, f<FS>"
*mipsIII:
*mipsIV:
*mipsV:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  int fmt = FMT;
  check_fpu (SD_);
  StoreFPR (FD, fmt_long, Convert (FP_RM_TOZERO, ValueFPR (FS, fmt), fmt,
	    fmt_long));
}


010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,001101:COP1:32,f::TRUNC.W
"trunc.w.%s<FMT> f<FD>, f<FS>"
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  int fmt = FMT;
  check_fpu (SD_);
  StoreFPR (FD, fmt_word, Convert (FP_RM_TOZERO, ValueFPR (FS, fmt), fmt,
	    fmt_word));
}


//
// MIPS Architecture:
//
//        System Control Instruction Set (COP0)
//


010000,01000,00000,16.OFFSET:COP0:32::BC0F
"bc0f <OFFSET>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:

010000,01000,00000,16.OFFSET:COP0:32::BC0F
"bc0f <OFFSET>"
// stub needed for eCos as tx39 hardware bug workaround
*r3900:
{
  /* do nothing */
}


010000,01000,00010,16.OFFSET:COP0:32::BC0FL
"bc0fl <OFFSET>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:


010000,01000,00001,16.OFFSET:COP0:32::BC0T
"bc0t <OFFSET>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:


010000,01000,00011,16.OFFSET:COP0:32::BC0TL
"bc0tl <OFFSET>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:


101111,5.BASE,5.OP,16.OFFSET:NORMAL:32::CACHE
"cache <OP>, <OFFSET>(r<BASE>)"
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  address_word base = GPR[BASE];
  address_word offset = EXTEND16 (OFFSET);
  {
    address_word vaddr = loadstore_ea (SD_, base, offset);
    address_word paddr;
    int uncached;
    if (AddressTranslation(vaddr,isDATA,isLOAD,&paddr,&uncached,isTARGET,isREAL))
      CacheOp(OP,vaddr,paddr,instruction_0);
  }
}


010000,00001,5.RT,5.RD,00000000000:COP0:64::DMFC0
"dmfc0 r<RT>, r<RD>"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
{
  check_u64 (SD_, instruction_0);
  DecodeCoproc (instruction_0);
}


010000,00101,5.RT,5.RD,00000000000:COP0:64::DMTC0
"dmtc0 r<RT>, r<RD>"
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*mips64r2:
{
  check_u64 (SD_, instruction_0);
  DecodeCoproc (instruction_0);
}


010000,1,0000000000000000000,011000:COP0:32::ERET
"eret"
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
{
  if (SR & status_ERL)
    {
      /* Oops, not yet available */
      sim_io_printf (SD, "Warning: ERET when SR[ERL] set not supported");
      NIA = EPC;
      SR &= ~status_ERL;
    }
  else
    {
      NIA = EPC;
      SR &= ~status_EXL;
    }
}


010000,00000,5.RT,5.RD,00000,6.REGX:COP0:32::MFC0
"mfc0 r<RT>, r<RD> # <REGX>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  TRACE_ALU_INPUT0 ();
  DecodeCoproc (instruction_0);
  TRACE_ALU_RESULT (GPR[RT]);
}

010000,00100,5.RT,5.RD,00000,6.REGX:COP0:32::MTC0
"mtc0 r<RT>, r<RD> # <REGX>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:
*r3900:
{
  DecodeCoproc (instruction_0);
}


010000,1,0000000000000000000,010000:COP0:32::RFE
"rfe"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*vr4100:
*vr5000:
*r3900:
{
  DecodeCoproc (instruction_0);
}


0100,ZZ!0!1!3,5.COP_FUN0!8,5.COP_FUN1,16.COP_FUN2:NORMAL:32::COPz
"cop<ZZ> <COP_FUN0><COP_FUN1><COP_FUN2>"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*r3900:
{
  DecodeCoproc (instruction_0);
}



010000,1,0000000000000000000,001000:COP0:32::TLBP
"tlbp"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:


010000,1,0000000000000000000,000001:COP0:32::TLBR
"tlbr"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:


010000,1,0000000000000000000,000010:COP0:32::TLBWI
"tlbwi"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:


010000,1,0000000000000000000,000110:COP0:32::TLBWR
"tlbwr"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips32r2:
*mips64:
*mips64r2:
*vr4100:
*vr5000:


:include:::mips3264r2.igen
:include:::m16.igen
:include:::m16e.igen
:include:::mdmx.igen
:include:::mips3d.igen
:include:::sb1.igen
:include:::tx.igen
:include:::vr.igen
:include:::dsp.igen
:include:::dsp2.igen
:include:::smartmips.igen

@


1.67
log
@sim/mips/
	* mips.igen (ll): Fix mask for WITH_TARGET_WORD_BITSIZE == 32.
	(sc, swxc1): Likewise.  Also fix big-endian and reverse-endian
	shifts for that case.
@
text
@a4146 1
*mips32r2:
d4158 7
d4318 1
a4318 1
010011,5.RS,5.FT,5.FS,5.FD,011,110:COP1X:64,f::ALNV.PS
d4436 1
a4436 1
010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,001010:COP1:64,f::CEIL.L.fmt
d4596 1
a4596 1
010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,100101:COP1:64,f::CVT.L.fmt
d4617 1
a4617 1
010001,10,000,5.FT,5.FS,5.FD,100110:COP1:64,f::CVT.PS.S
d4658 1
a4658 1
010001,10,110,00000,5.FS,5.FD,101000:COP1:64,f::CVT.S.PL
d4671 1
a4671 1
010001,10,110,00000,5.FS,5.FD,100000:COP1:64,f::CVT.S.PU
d4808 1
a4808 1
010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,001011:COP1:64,f::FLOOR.L.fmt
d4875 9
a4887 1
*mips32r2:
d4898 17
a4917 1
*mips32r2:
d4926 2
d4955 1
a4955 1
010011,5.BASE,5.INDEX,5.0,5.FD,000000:COP1X:64,f::LWXC1
d4971 1
a4971 1
010011,5.FR,5.FT,5.FS,5.FD,100,3.FMT!2!3!4!5!7:COP1X:64,f::MADD.fmt
d5136 1
a5136 1
010011,5.FR,5.FT,5.FS,5.FD,101,3.FMT!2!3!4!5!7:COP1X:64,f::MSUB.fmt
d5229 1
a5229 1
010011,5.FR,5.FT,5.FS,5.FD,110,3.FMT!2!3!4!5!7:COP1X:64,f::NMADD.fmt
d5247 1
a5247 1
010011,5.FR,5.FT,5.FS,5.FD,111,3.FMT!2!3!4!5!7:COP1X:64,f::NMSUB.fmt
d5265 1
a5265 1
010001,10,110,5.FT,5.FS,5.FD,101100:COP1:64,f::PLL.PS
d5279 1
a5279 1
010001,10,110,5.FT,5.FS,5.FD,101101:COP1:64,f::PLU.PS
d5293 1
a5293 1
010011,5.BASE,5.INDEX,5.HINT,00000,001111:COP1X:64::PREFX
d5314 1
a5314 1
010001,10,110,5.FT,5.FS,5.FD,101110:COP1:64,f::PUL.PS
d5328 1
a5328 1
010001,10,110,5.FT,5.FS,5.FD,101111:COP1:64,f::PUU.PS
d5357 1
a5357 1
010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,001000:COP1:64,f::ROUND.L.fmt
d5439 9
d5462 17
a5484 1
  unsigned64 v;
d5490 2
d5632 1
a5632 1
010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,001001:COP1:64,f::TRUNC.L.fmt
@


1.66
log
@	* mips.igen (ALNV.PS, CEIL.L.fmt, CVT.L.fmt, CVT.PS.S, CVT.S.PL,
	CVT.S.PU, FLOOR.L.fmt, LDXC1, LUXC1, LWXC1, MADD.fmt, MSUB.fmt,
	NMADD.fmt, NMSUB.fmt, PLL.PS, PLU.PS, PREFX, PUL.PS, PUU.PS,
	RECIP.fmt, ROUND.L.fmt, RSQRT.fmt, SWXC1, TRUNC.L.fmt): Add support
	for mips32r2.
@
text
@d2266 1
a2266 1
	    unsigned64 mask = 0x7;
d3202 3
a3204 1
	    unsigned64 mask = 0x7;
d3206 2
a3207 2
	    paddr = ((paddr & ~mask) | ((paddr & mask) ^ (ReverseEndian << 2)));
	    byte = ((vaddr & mask) ^ (BigEndianCPU << 2));
d5557 3
a5559 1
     unsigned64 mask = 0x7;
d5561 2
a5562 2
     paddr = ((paddr & ~mask) | ((paddr & mask) ^ (ReverseEndian << 2)));
     byte = ((vaddr & mask) ^ (BigEndianCPU << 2));
@


1.65
log
@	* mips.igen (MFHI, MFLO, MTHI, MTLO): Restore support for mips32
	and mips64.
@
text
@d4313 1
d4433 1
d4593 1
d4612 1
d4653 1
d4666 1
d4805 1
d4871 1
d4885 1
d4925 1
d4941 1
d5106 1
d5199 1
d5217 1
d5234 1
d5248 1
d5263 1
d5283 1
d5297 1
d5312 1
d5328 1
d5367 1
d5531 1
d5574 1
@


1.64
log
@	[ gas/ChangeLog ]
	* config/tc-mips.c (mips_set_options, mips_opts, file_ase_dspr2,
	ISA_SUPPORTS_DSPR2_ASE, MIPS_CPU_ASE_DSPR2): Add DSP R2 ASE support.
	(macro_build): Add case '2'.
	(macro): Expand M_BALIGN to nop, packrl.ph or balign.
	(validate_mips_insn): Add support for balign instruction.
	(mips_ip): Handle DSP R2 instructions. Support balign instruction.
	(OPTION_DSPR2, OPTION_NO_DSPR2, OPTION_COMPAT_ARCH_BASE,
	md_parse_option, mips_after_parse_args): Add -mdspr2 and -mno-dspr2
	command line options.
	(s_mipsset): Add support for .set dspr2 and .set nodspr2 directives.
	(md_show_usage): Add -mdspr2 and -mno-dspr2 help output.
	* doc/c-mips.texi, doc/as.texinfo: Document -mdspr2, -mno-dspr2,
	.set dspr2, .set nodspr2.

	[ gas/testsuite/ChangeLog ]
	* gas/mips/mips32-dspr2.s, gas/mips/mips32-dspr2.d: New test for
	DSP R2.
	* gas/mips/mips.exp: Run new test.

	[ include/opcode/Changelog ]
	* mips.h (OP_SH_BP, OP_MASK_BP): Add support for balign instruction.
	(INSN_DSPR2): Add flag for DSP R2 instructions.
	(M_BALIGN): New macro.

	[ opcodes/ChangeLog ]
	* mips-dis.c (mips_arch_choices): Add DSP R2 support.
	(print_insn_args): Add support for balign instruction.
	* mips-opc.c (D33): New shortcut for DSP R2 instructions.
	(mips_builtin_opcodes): Add DSP R2 instructions.

	[ sim/mips/ChangeLog ]
	* Makefile.in (IGEN_INCLUDE): Add dsp2.igen.
	* configure.ac (mips*-sde-elf*, mipsisa32r2*-*-*, mipsisa64r2*-*-*):
	Add dsp2 to sim_igen_machine.
	* configure: Regenerate.
	* dsp.igen (do_ph_op): Add MUL support when op = 2.
	(do_ph_mulq): New function to support mulq_rs.ph and mulq_s.ph.
	(mulq_rs.ph): Use do_ph_mulq.
	(MFHI, MFLO, MTHI, MTLO): Move these instructions to mips.igen.
	* mips.igen: Add dsp2 model and include dsp2.igen.
	(MFHI, MFLO, MTHI, MTLO): Extend these instructions for
	for *mips32r2, *mips64r2, *dsp.
	(MADD, MADDU, MSUB, MSUBU, MULT, MULTU): Extend these instructions
	for *mips32r2, *mips64r2, *dsp2.
	* dsp2.igen: New file for MIPS DSP REV 2 ASE.

	[ sim/testsuite/sim/mips/ChangeLog ]
	* basic.exp: Run the dsp2 test.
	* utils-dsp.inc (dspckacc_astio, dspck_tsimm): New macro.
	* mips32-dsp2.s: New test.
@
text
@d2534 2
d2573 2
d2724 2
d2755 2
@


1.63
log
@	* mips.igen (jalr.hb, jr.hb): Add decoder for mip32r2/mips64r2
	jumps with hazard barrier.
@
text
@d75 1
a2433 1
*mips32r2:
a2434 1
*mips64r2:
d2450 21
a2474 1
*mips32r2:
a2475 1
*mips64r2:
d2492 24
d2539 13
d2576 13
a2630 1
*mips32r2:
a2631 1
*mips64r2:
d2647 21
a2671 1
*mips32r2:
a2672 1
*mips64r2:
d2688 21
d2726 12
d2755 12
a2812 1
*mips32r2:
a2813 1
*mips64r2:
d2820 25
a2878 1
*mips32r2:
a2879 1
*mips64r2:
d2885 23
d5871 1
@


1.62
log
@	* cp1.c (value_fpr): Don't inherit existing FPR_STATE for
	uninterpreted formats. If fmt is one of the uninterpreted types
	don't update the FPR_STATE. Handle fmt_uninterpreted_32 like
	fmt_word, and fmt_uninterpreted_64 like fmt_long.
	(store_fpr): When writing an invalid odd register, set the
	matching even register to fmt_unknown, not the following register.
	* interp.c (sim_open): If STATE_MEM_SIZE isn't set then set it to
	the the memory window at offset 0 set by --memory-size command
	line option.
	(sim_store_register): Handle storing 4 bytes to an 8 byte floating
	point register.
	(sim_fetch_register): Likewise for reading 4 bytes from an 8 byte
	register.
	(sim_monitor): When returning the memory size to the MIPS
	application, use the value in STATE_MEM_SIZE, not an arbitrary
	hardcoded value.
	(cop_lw): Don' mess around with FPR_STATE, just pass
	fmt_uninterpreted_32 to StoreFPR.
	(cop_sw): Similarly.
	(cop_ld): Pass fmt_uninterpreted_64 not fmt_uninterpreted.
	(cop_sd): Similarly.
	* mips.igen (not_word_value): Single version for mips32, mips64
	and mips16.
@
text
@d1948 10
d1959 1
a1959 1
000000,5.RS,000000000000000,001000:SPECIAL:32::JR
d1977 7
@


1.61
log
@	* configure.ac (mipsisa32r2*-*-*, mipsisa32*-*-*): Add smartmips to
	sim_igen_machine.
	* configure: Regenerate.
	* mips.igen (model): Add smartmips.
	(MADDU): Increment ACX if carry.
	(do_mult): Clear ACX.
	(ROR,RORV): Add smartmips.
	(include): Include smartmips.igen.
	* sim-main.h (ACX): Set to REGISTERS[89].
	* smartmips.igen: New file.
@
text
@a178 8
{
  /* For historical simulator compatibility (until documentation is
     found that makes these operations unpredictable on some of these
     architectures), this check never returns true.  */
  return 0;
}

:function:::int:not_word_value:unsigned_word value
a180 6
{
  /* On MIPS32, since registers are 32-bits, there's no check to be done.  */
  return 0;
}

:function:::int:not_word_value:unsigned_word value
d184 5
a188 1
  return ((value >> 32) != (value & 0x80000000 ? 0xFFFFFFFF : 0));
a190 1

@


1.60
log
@* Makefile.in (SIM_OBJS): Add dsp.o.
(dsp.o): New dependency.
(IGEN_INCLUDE): Add dsp.igen.
* configure.ac (mipsisa32r2*-*-*, mipsisa32*-*-*, mipsisa64r2*-*-*,
mipsisa64*-*-*): Add dsp to sim_igen_machine.
* configure: Regenerate.
* mips.igen: Add dsp model and include dsp.igen.
(MFHI, MFLO, MTHI, MTLO): Remove mips32, mips32r2, mips64, mips64r2,
because these instructions are extended in DSP ASE.
* sim-main.h (LAST_EMBED_REGNUM): Change from 89 to 96 because of
adding 6 DSP accumulator registers and 1 DSP control register.
(AC0LOIDX, AC0HIIDX, AC1LOIDX, AC1HIIDX, AC2LOIDX, AC2HIIDX, AC3LOIDX,
AC3HIIDX, DSPLO, DSPHI, DSPCRIDX, DSPCR, DSPCR_POS_SHIFT,
DSPCR_POS_MASK, DSPCR_POS_SMASK, DSPCR_SCOUNT_SHIFT, DSPCR_SCOUNT_MASK,
DSPCR_SCOUNT_SMASK, DSPCR_CARRY_SHIFT, DSPCR_CARRY_MASK,
DSPCR_CARRY_SMASK, DSPCR_CARRY, DSPCR_EFI_SHIFT, DSPCR_EFI_MASK,
DSPCR_EFI_SMASK, DSPCR_EFI, DSPCR_OUFLAG_SHIFT, DSPCR_OUFLAG_MASK,
DSPCR_OUFLAG_SMASK, DSPCR_OUFLAG4, DSPCR_OUFLAG5, DSPCR_OUFLAG6,
DSPCR_OUFLAG7, DSPCR_CCOND_SHIFT, DSPCR_CCOND_MASK,
DSPCR_CCOND_SMASK): New define.
(DSPLO_REGNUM, DSPHI_REGNUM): New array for DSP accumulators.
* dsp.c, dsp.igen: New files for MIPS DSP ASE.
@
text
@d75 1
d2461 1
d2663 1
d2856 1
d2867 1
d5691 1
@


1.59
log
@* mips.igen: New mips16e model and include m16e.igen.
(check_u64): Add mips16e tag.
* m16e.igen: New file for MIPS16e instructions.
* configure.ac (mipsisa32*-*-*, mipsisa32r2*-*-*, mipsisa64*-*-*,
mipsisa64r2*-*-*): Change sim_gen to M16, add mips16 and mips16e
models.
* configure: Regenerate.
@
text
@d74 1
a2480 4
*mips32:
*mips32r2:
*mips64:
*mips64r2:
a2504 4
*mips32:
*mips32r2:
*mips64:
*mips64r2:
a2602 4
*mips32:
*mips32r2:
*mips64:
*mips64r2:
a2619 4
*mips32:
*mips32r2:
*mips64:
*mips64r2:
d5685 1
@


1.58
log
@2005-05-26  David Ung  <davidu@@mips.com>

        * mips.igen (mips32r2, mips64r2): New ISA models.  Add new model
        tags to all instructions which are applicable to the new ISAs.
        (do_ror, do_dror, ROR, RORV, DROR, DROR32, DRORV): Add, moved from
        vr.igen.
        * mips3264r2.igen: New file for MIPS 32/64 revision 2 specific
        instructions.
        * vr.igen (do_ror, do_dror, ROR, RORV, DROR, DROR32, DRORV): Move
        to mips.igen.
        * configure.ac (mipsisa32r2*-*-*, mipsisa64r2*-*-*): Add new targets.
        * configure: Regenerate.
@
text
@d71 1
d495 1
d5694 1
@


1.57
log
@2004-04-09  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (check_fmt): Remove.
        (ABS.fmt, ADD.fmt, C.cond.fmta, C.cond.fmtb, CEIL.L.fmt, CEIL.W)
        (CVT.D.fmt, CVT.L.fmt, CVT.S.fmt, CVT.W.fmt, DIV.fmt, FLOOR.L.fmt)
        (FLOOR.W.fmt, MADD.fmt, MOV.fmt, MOVtf.fmt, MOVN.fmt, MOVZ.fmt)
        (MSUB.fmt, MUL.fmt, NEG.fmt, NMADD.fmt, NMSUB.fmt, RECIP.fmt)
        (ROUND.L.fmt, ROUND.W.fmt, RSQRT.fmt, SQRT.fmt, SUB.fmt)
        (TRUNC.L.fmt, TRUNC.W): Explicitly specify allowed FPU formats.
        (check_fmt_p, CEIL.L.fmt, CEIL.W, DIV.fmt, FLOOR.L.fmt)
        (FLOOR.W.fmt, RECIP.fmt, ROUND.L.fmt, ROUND.W.fmt, RSQRT.fmt)
        (SQRT.fmt, TRUNC.L.fmt, TRUNC.W): Remove all uses of check_fmt.
        (C.cnd.fmta): Remove incorrect call to check_fmt_p.
@
text
@d48 1
d50 1
d137 1
d147 1
d185 1
d193 1
d221 1
d223 1
d311 1
d313 1
d335 1
d337 1
d407 1
d409 1
d462 1
d464 1
d487 2
d495 1
d508 1
a508 1
//        CPU Instruction Set (mipsI - mipsV, mips32, mips64)
d521 1
d523 1
d549 1
d551 1
d586 1
d588 1
d615 1
d617 1
d642 1
d644 1
d662 1
d664 1
d684 1
d686 1
d707 1
d709 1
d733 1
d735 1
d757 1
d759 1
d783 1
d785 1
d813 1
d815 1
d839 1
d841 1
d862 1
d864 1
d890 1
d892 1
d915 1
d917 1
d941 1
d943 1
d965 1
d967 1
d993 1
d995 1
d1021 1
d1023 1
d1049 1
d1051 1
d1072 1
d1074 1
d1098 1
d1100 1
d1136 1
d1138 1
d1163 1
d1165 1
d1193 1
d1215 1
d1244 1
d1267 1
d1280 1
d1305 1
d1363 1
d1404 1
a1411 2


d1446 1
d1448 1
d1487 1
d1489 1
a1497 1

d1569 1
d1598 1
d1614 43
d1670 1
d1685 1
d1710 1
d1732 1
d1747 1
d1773 1
d1795 1
d1810 1
d1838 1
d1853 1
d1881 1
d1898 1
d1900 1
d1920 1
d1922 1
d1943 1
d1945 1
d1964 1
d1966 1
d2093 1
d2095 1
d2112 1
d2114 1
d2129 1
d2145 1
d2147 1
d2164 1
d2179 1
d2196 1
d2198 1
d2215 1
d2217 1
d2233 1
d2235 1
d2277 1
d2315 1
d2317 1
d2336 1
d2338 1
d2355 1
d2357 1
d2374 1
d2376 1
d2393 1
d2395 1
d2410 1
d2423 1
d2425 1
d2445 1
d2447 1
d2479 1
d2481 1
d2507 1
d2509 1
d2524 1
d2526 1
d2543 1
d2545 1
d2560 1
d2562 1
d2582 1
d2584 1
d2609 1
d2611 1
d2630 1
d2632 1
d2646 1
d2648 1
d2687 1
d2689 1
d2730 1
d2732 1
d2763 1
d2765 1
d2789 1
d2791 1
d2816 1
d2818 1
d2832 1
d2834 1
d2851 32
d2981 1
d2983 1
d2999 1
d3001 1
d3044 1
d3083 1
d3099 1
d3101 1
d3115 1
d3130 1
d3139 1
d3148 1
d3150 1
d3190 1
d3192 1
d3218 1
d3220 1
d3244 1
d3246 1
d3270 1
d3272 1
d3296 1
d3298 1
d3323 1
d3325 1
d3352 1
d3354 1
d3383 1
d3385 1
d3413 1
d3415 1
d3443 1
d3445 1
d3462 1
d3464 1
d3498 1
d3500 1
d3517 1
d3519 1
d3536 1
d3538 1
d3555 1
d3557 1
d3574 1
d3576 1
d3593 1
d3595 1
d3612 1
d3614 1
d3630 1
d3632 1
d3648 1
d3650 1
d3666 1
d3668 1
d3684 1
d3686 1
d3702 1
d3704 1
d3720 1
d3722 1
d3738 1
d3740 1
d3756 1
d3758 1
d3774 1
d3776 1
d3792 1
d3794 1
d3810 1
d3812 1
d3828 1
d3830 1
d3854 1
d3856 1
d3880 1
d3882 1
d3965 1
d3979 1
d4000 1
d4002 1
d4022 1
d4059 1
d4093 1
d4095 1
d4116 1
d4118 1
d4134 1
d4194 1
d4196 1
d4232 1
d4234 1
d4253 1
d4272 1
d4274 1
d4322 1
d4324 1
d4367 1
d4369 1
d4390 1
d4392 1
d4412 1
d4430 1
d4450 1
d4452 1
d4470 1
d4482 1
d4498 1
d4500 1
d4522 1
d4524 1
d4557 1
d4598 1
d4620 1
d4639 1
d4641 1
d4657 1
d4670 1
d4685 1
d4698 1
d4720 1
d4722 1
d4737 1
d4752 1
d4782 1
d4784 1
d4803 1
d4805 1
d4824 1
d4826 1
d4842 1
d4844 1
d4873 1
d4875 1
d4898 1
d4900 1
d4916 1
d4947 1
d4949 1
d4967 1
d4969 1
d4989 1
d4991 1
d5008 1
d5025 1
d5041 1
d5054 1
d5068 1
d5087 1
d5100 1
d5114 1
d5129 1
d5148 1
d5150 1
d5167 1
d5180 1
d5193 1
d5208 1
d5221 1
d5243 1
d5245 1
d5264 1
d5266 1
d5287 1
d5289 1
d5330 1
d5372 1
d5391 1
d5393 1
d5420 1
d5422 1
d5443 1
d5445 1
d5458 1
d5460 1
d5472 1
d5474 1
d5485 1
d5487 1
d5510 1
d5523 1
d5536 1
d5538 1
d5565 1
d5567 1
d5585 1
d5587 1
d5619 1
d5621 1
d5638 1
d5640 1
d5653 1
d5655 1
d5668 1
d5670 1
d5683 1
d5685 1
d5689 2
a5690 1

d5697 1
a5697 1

@


1.56
log
@	* sim-main.h (MIPS_MACH_HAS_MT_HILO_HAZARD)
	(MIPS_MACH_HAS_MULT_HILO_HAZARD, MIPS_MACH_HAS_DIV_HILO_HAZARD): New.
	* mips.igen (check_mt_hilo, check_mult_hilo, check_div_hilo): Provide
	separate implementations for mipsIV and mipsV.  Use new macros to
	determine whether the restrictions apply.
@
text
@a3645 17
// check_fmt checks that the format is single or double.
:function:::void:check_fmt:int fmt, instruction_word insn
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips32:
*mips64:
*vr4100:
*vr5000:
*r3900:
{
  if ((fmt != fmt_single) && (fmt != fmt_double))
    SignalException (ReservedInstruction, insn);
}

d3659 2
a3660 1
  check_fmt (SD_, fmt, insn);
d3767 1
a3767 1
010001,10,3.FMT,00000,5.FS,5.FD,000101:COP1:32,f::ABS.fmt
d3788 1
a3788 1
010001,10,3.FMT,5.FT,5.FS,5.FD,000000:COP1:32,f::ADD.fmt
d3889 1
a3889 1
010001,10,3.FMT,5.FT,5.FS,3.0,00,11,4.COND:COP1:32,f::C.cond.fmta
a3896 1
  check_fmt_p (SD_, fmt, instruction_0);
d3901 1
a3901 1
010001,10,3.FMT,5.FT,5.FS,3.CC,00,11,4.COND:COP1:32,f::C.cond.fmtb
d3920 1
a3920 1
010001,10,3.FMT,00000,5.FS,5.FD,001010:COP1:64,f::CEIL.L.fmt
a3931 1
  check_fmt (SD_, fmt, instruction_0);
d3937 1
a3937 1
010001,10,3.FMT,00000,5.FS,5.FD,001110:COP1:32,f::CEIL.W
a3950 1
  check_fmt (SD_, fmt, instruction_0);
d4048 1
a4048 1
010001,10,3.FMT,00000,5.FS,5.FD,100001:COP1:32,f::CVT.D.fmt
d4070 1
a4070 1
010001,10,3.FMT,00000,5.FS,5.FD,100101:COP1:64,f::CVT.L.fmt
d4104 1
a4104 1
010001,10,3.FMT!6,00000,5.FS,5.FD,100000:COP1:32,f::CVT.S.fmt
d4148 1
a4148 1
010001,10,3.FMT!6,00000,5.FS,5.FD,100100:COP1:32,f::CVT.W.fmt
d4170 1
a4170 1
010001,10,3.FMT,5.FT,5.FS,5.FD,000011:COP1:32,f::DIV.fmt
a4184 1
  check_fmt (SD_, fmt, instruction_0);
d4266 1
a4266 1
010001,10,3.FMT,00000,5.FS,5.FD,001011:COP1:64,f::FLOOR.L.fmt
a4277 1
  check_fmt (SD_, fmt, instruction_0);
d4283 1
a4283 1
010001,10,3.FMT,00000,5.FS,5.FD,001111:COP1:32,f::FLOOR.W.fmt
a4296 1
  check_fmt (SD_, fmt, instruction_0);
d4389 1
a4389 1
010011,5.FR,5.FT,5.FS,5.FD,100,3.FMT:COP1X:64,f::MADD.fmt
d4434 1
a4434 1
010001,10,3.FMT,00000,5.FS,5.FD,000110:COP1:32,f::MOV.fmt
d4472 1
a4472 1
010001,10,3.FMT,3.CC,0,1.TF,5.FS,5.FD,010001:COP1:32,f::MOVtf.fmt
d4501 1
a4501 1
010001,10,3.FMT,5.RT,5.FS,5.FD,010011:COP1:32,f::MOVN.fmt
d4524 1
a4524 1
010001,10,3.FMT,5.RT,5.FS,5.FD,010010:COP1:32,f::MOVZ.fmt
d4540 1
a4540 1
010011,5.FR,5.FT,5.FS,5.FD,101,3.FMT:COP1X:64,f::MSUB.fmt
d4585 1
a4585 1
010001,10,3.FMT,5.FT,5.FS,5.FD,000010:COP1:32,f::MUL.fmt
d4605 1
a4605 1
010001,10,3.FMT,00000,5.FS,5.FD,000111:COP1:32,f::NEG.fmt
d4625 1
a4625 1
010011,5.FR,5.FT,5.FS,5.FD,110,3.FMT:COP1X:64,f::NMADD.fmt
d4641 1
a4641 1
010011,5.FR,5.FT,5.FS,5.FD,111,3.FMT:COP1X:64,f::NMSUB.fmt
d4724 1
a4724 1
010001,10,3.FMT,00000,5.FS,5.FD,010101:COP1:32,f::RECIP.fmt
a4732 1
  check_fmt (SD_, fmt, instruction_0);
d4737 1
a4737 1
010001,10,3.FMT,00000,5.FS,5.FD,001000:COP1:64,f::ROUND.L.fmt
a4748 1
  check_fmt (SD_, fmt, instruction_0);
d4754 1
a4754 1
010001,10,3.FMT,00000,5.FS,5.FD,001100:COP1:32,f::ROUND.W.fmt
a4767 1
  check_fmt (SD_, fmt, instruction_0);
d4773 1
a4773 1
010001,10,3.FMT,00000,5.FS,5.FD,010110:COP1:32,f::RSQRT.fmt
a4781 1
  check_fmt (SD_, fmt, instruction_0);
d4842 1
a4842 1
010001,10,3.FMT,00000,5.FS,5.FD,000100:COP1:32,f::SQRT.fmt
a4855 1
  check_fmt (SD_, fmt, instruction_0);
d4860 1
a4860 1
010001,10,3.FMT,5.FT,5.FS,5.FD,000001:COP1:32,f::SUB.fmt
d4965 1
a4965 1
010001,10,3.FMT,00000,5.FS,5.FD,001001:COP1:64,f::TRUNC.L.fmt
a4976 1
  check_fmt (SD_, fmt, instruction_0);
d4982 1
a4982 1
010001,10,3.FMT,00000,5.FS,5.FD,001101:COP1:32,f::TRUNC.W
a4995 1
  check_fmt (SD_, fmt, instruction_0);
@


1.55
log
@2004-01-19  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (check_mf_cycles, check_mt_hilo, check_mf_hilo)
        (check_mult_hilo): Improve comments.
        (check_div_hilo): Likewise.  Also, fork off a new version
        to handle mips32/mips64 (since there are no hazards to check
        in MIPS32/MIPS64).
@
text
@d241 9
a249 7
// For now this code is paranoid.  Historically the simulator
// enforced restrictions (2) and (3) for more ISAs and CPU types than
// necessary.  Unfortunately, at least some MIPS IV and later parts'
// documentation describes them as having these hazards (e.g. vr5000),
// so they can't be removed for at leats MIPS IV.  MIPS V hasn't been
// checked (since there are no known hardware implementations).
// 
a278 2
*mipsIV:
*mipsV:
d290 12
a364 2
*mipsIV:
*mipsV:
d379 15
a416 2
*mipsIV:
*mipsV:
d424 15
@


1.55.6.1
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d241 7
a247 9
// Unfortunately, there seems to be some confusion about whether the last
// two restrictions should apply to "MIPS IV" as well.  One edition of
// the MIPS IV ISA says they do, but references in later ISA documents
// suggest they don't.
//
// In reality, some MIPS IV parts, such as the VR5000 and VR5400, do have
// these restrictions, while others, like the VR5500, don't.  To accomodate
// such differences, the MIPS IV and MIPS V version of these helper functions
// use auxillary routines to determine whether the restriction applies.
d277 2
a289 12
*mipsIV:
*mipsV:
{
  signed64 time = sim_events_time (SD);
  int ok = (! MIPS_MACH_HAS_MT_HILO_HAZARD (SD)
	    || check_mf_cycles (SD_, history, time, "MT"));
  history->mt.timestamp = time;
  history->mt.cia = CIA;
  return ok;
}

:function:::int:check_mt_hilo:hilo_history *history
d353 2
a368 15
*mipsIV:
*mipsV:
{
  signed64 time = sim_events_time (SD);
  int ok = (! MIPS_MACH_HAS_MULT_HILO_HAZARD (SD)
	    || (check_mf_cycles (SD_, hi, time, "OP")
	        && check_mf_cycles (SD_, lo, time, "OP")));
  hi->op.timestamp = time;
  lo->op.timestamp = time;
  hi->op.cia = CIA;
  lo->op.cia = CIA;
  return ok;
}

:function:::int:check_mult_hilo:hilo_history *hi, hilo_history *lo
d392 2
a400 15
  hi->op.timestamp = time;
  lo->op.timestamp = time;
  hi->op.cia = CIA;
  lo->op.cia = CIA;
  return ok;
}

:function:::int:check_div_hilo:hilo_history *hi, hilo_history *lo
*mipsIV:
*mipsV:
{
  signed64 time = sim_events_time (SD);
  int ok = (! MIPS_MACH_HAS_DIV_HILO_HAZARD (SD)
	    || (check_mf_cycles (SD_, hi, time, "OP")
	        && check_mf_cycles (SD_, lo, time, "OP")));
@


1.55.6.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3646 17
d3676 1
a3676 2
  if ((fmt != fmt_single) && (fmt != fmt_double))
    SignalException (ReservedInstruction, insn);
d3783 1
a3783 1
010001,10,3.FMT!2!3!4!5!7,00000,5.FS,5.FD,000101:COP1:32,f::ABS.fmt
d3804 1
a3804 1
010001,10,3.FMT!2!3!4!5!7,5.FT,5.FS,5.FD,000000:COP1:32,f::ADD.fmt
d3905 1
a3905 1
010001,10,3.FMT!2!3!4!5!6!7,5.FT,5.FS,3.0,00,11,4.COND:COP1:32,f::C.cond.fmta
d3913 1
d3918 1
a3918 1
010001,10,3.FMT!2!3!4!5!7,5.FT,5.FS,3.CC,00,11,4.COND:COP1:32,f::C.cond.fmtb
d3937 1
a3937 1
010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,001010:COP1:64,f::CEIL.L.fmt
d3949 1
d3955 1
a3955 1
010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,001110:COP1:32,f::CEIL.W
d3969 1
d4067 1
a4067 1
010001,10,3.FMT!1!2!3!6!7,00000,5.FS,5.FD,100001:COP1:32,f::CVT.D.fmt
d4089 1
a4089 1
010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,100101:COP1:64,f::CVT.L.fmt
d4123 1
a4123 1
010001,10,3.FMT!0!2!3!6!7,00000,5.FS,5.FD,100000:COP1:32,f::CVT.S.fmt
d4167 1
a4167 1
010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,100100:COP1:32,f::CVT.W.fmt
d4189 1
a4189 1
010001,10,3.FMT!2!3!4!5!6!7,5.FT,5.FS,5.FD,000011:COP1:32,f::DIV.fmt
d4204 1
d4286 1
a4286 1
010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,001011:COP1:64,f::FLOOR.L.fmt
d4298 1
d4304 1
a4304 1
010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,001111:COP1:32,f::FLOOR.W.fmt
d4318 1
d4411 1
a4411 1
010011,5.FR,5.FT,5.FS,5.FD,100,3.FMT!2!3!4!5!7:COP1X:64,f::MADD.fmt
d4456 1
a4456 1
010001,10,3.FMT!2!3!4!5!7,00000,5.FS,5.FD,000110:COP1:32,f::MOV.fmt
d4494 1
a4494 1
010001,10,3.FMT!2!3!4!5!7,3.CC,0,1.TF,5.FS,5.FD,010001:COP1:32,f::MOVtf.fmt
d4523 1
a4523 1
010001,10,3.FMT!2!3!4!5!7,5.RT,5.FS,5.FD,010011:COP1:32,f::MOVN.fmt
d4546 1
a4546 1
010001,10,3.FMT!2!3!4!5!7,5.RT,5.FS,5.FD,010010:COP1:32,f::MOVZ.fmt
d4562 1
a4562 1
010011,5.FR,5.FT,5.FS,5.FD,101,3.FMT!2!3!4!5!7:COP1X:64,f::MSUB.fmt
d4607 1
a4607 1
010001,10,3.FMT!2!3!4!5!7,5.FT,5.FS,5.FD,000010:COP1:32,f::MUL.fmt
d4627 1
a4627 1
010001,10,3.FMT!2!3!4!5!7,00000,5.FS,5.FD,000111:COP1:32,f::NEG.fmt
d4647 1
a4647 1
010011,5.FR,5.FT,5.FS,5.FD,110,3.FMT!2!3!4!5!7:COP1X:64,f::NMADD.fmt
d4663 1
a4663 1
010011,5.FR,5.FT,5.FS,5.FD,111,3.FMT!2!3!4!5!7:COP1X:64,f::NMSUB.fmt
d4746 1
a4746 1
010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,010101:COP1:32,f::RECIP.fmt
d4755 1
d4760 1
a4760 1
010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,001000:COP1:64,f::ROUND.L.fmt
d4772 1
d4778 1
a4778 1
010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,001100:COP1:32,f::ROUND.W.fmt
d4792 1
d4798 1
a4798 1
010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,010110:COP1:32,f::RSQRT.fmt
d4807 1
d4868 1
a4868 1
010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,000100:COP1:32,f::SQRT.fmt
d4882 1
d4887 1
a4887 1
010001,10,3.FMT!2!3!4!5!7,5.FT,5.FS,5.FD,000001:COP1:32,f::SUB.fmt
d4992 1
a4992 1
010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,001001:COP1:64,f::TRUNC.L.fmt
d5004 1
d5010 1
a5010 1
010001,10,3.FMT!2!3!4!5!6!7,00000,5.FS,5.FD,001101:COP1:32,f::TRUNC.W
d5024 1
@


1.54
log
@2003-06-17  Richard Sandiford  <rsandifo@@redhat.com>

        * mips.igen (do_dmultx): Fix check for negative operands.
@
text
@d221 1
a221 1
// Helper:
d225 1
a225 1
// The following requirements exist:
d227 2
a228 4
//   -  A MT {HI,LO} update was not immediatly preceeded by a MF {HI,LO} read
//   -  A OP {HI,LO} update was not immediatly preceeded by a MF {HI,LO} read
//   -  A MF {HI,LO} read was not corrupted by a preceeding MT{LO,HI} update
//      corruption occures when MT{LO,HI} is preceeded by a OP {HI,LO}.
d230 18
d249 5
d267 6
d301 5
d344 5
a367 2
// The r3900 mult and multu insns _can_ be exectuted immediatly after
// a mf{hi,lo}
d383 5
a393 2
*mips32:
*mips64:
d406 12
@


1.53
log
@2003-01-14  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (LUXC1, SUXC1): New, for mipsV and mips64.
@
text
@d1350 1
a1350 1
      if (op1 < 0)
d1355 1
a1355 1
      if (op2 < 0)
@


1.52
log
@2003-01-14  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (EI, DI): Remove.
@
text
@d4274 16
d4759 18
@


1.51
log
@2003-01-04  Richard Sandiford  <rsandifo@@redhat.com>
	    Andrew Cagney  <ac131313@@redhat.com>
	    Gavin Romig-Koch  <gavin@@redhat.com>
	    Graydon Hoare  <graydon@@redhat.com>
	    Aldy Hernandez  <aldyh@@redhat.com>
	    Dave Brolley  <brolley@@redhat.com>
	    Chris Demetriou  <cgd@@broadcom.com>

	* configure.in (mips64vr*): Define TARGET_ENABLE_FR to 1.
	(sim_mach_default): New variable.
	(mips64vr-*-*, mips64vrel-*-*): New configurations.
	Add a new simulator generator, MULTI.
	* configure: Regenerate.
	* Makefile.in (SIM_MULTI_OBJ, SIM_EXTRA_DISTCLEAN): New variables.
	(multi-run.o): New dependency.
	(SIM_MULTI_ALL, SIM_MULTI_IGEN_CONFIGS): New variables.
	(tmp-mach-multi, tmp-itable-multi, tmp-run-multi): New rules.
	(tmp-multi): Combine them.
	(BUILT_SRC_FROM_MULTI): New variable.  Depend on tmp-multi.
	(clean-extra): Remove sources in BUILT_SRC_FROM_MULTI.
	(distclean-extra): New rule.
	* sim-main.h: Include bfd.h.
	(MIPS_MACH): New macro.
	* mips.igen (vr4120, vr5400, vr5500): New models.
	(clo, clz, dclo, dclz, madd, maddu, msub, msub, mul): Add *vr5500.
	* vr.igen: Replace with new version.
@
text
@a4996 11
010000,1,0000000000000000000,111001:COP0:32::DI
"di"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*vr4100:
*vr5000:


a5018 12


010000,1,0000000000000000000,111000:COP0:32::EI
"ei"
*mipsI:
*mipsII:
*mipsIII:
*mipsIV:
*mipsV:
*mips64:
*vr4100:
*vr5000:
@


1.50
log
@2002-12-31  Chris Demetriou  <cgd@@broadcom.com>

        * sim-main.h (check_branch_bug, mark_branch_bug): Remove.
        * mips.igen: Remove all invocations of check_branch_bug and
        mark_branch_bug.
@
text
@d58 1
d60 2
d984 1
d1009 1
d1119 1
d1143 1
d2167 1
d2187 1
d2292 1
d2312 1
d2370 1
@


1.49
log
@2002-07-30  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (do_load_double, do_store_double): New functions.
        (LDC1, SDC1): Rename to...
        (LDC1b, SDC1b): respectively.
        (LDC1a, SDC1a): New instructions for MIPS II and MIPS32 support.
@
text
@a567 1
  check_branch_bug ();
a569 1
      mark_branch_bug (NIA+offset);
a588 1
  check_branch_bug ();
a590 1
      mark_branch_bug (NIA+offset);
a612 1
  check_branch_bug ();
a614 1
      mark_branch_bug (NIA+offset);
a634 1
  check_branch_bug ();
a639 1
      mark_branch_bug (NIA+offset);
a658 1
  check_branch_bug ();
a665 1
      mark_branch_bug (NIA+offset);
a686 1
  check_branch_bug ();
a688 1
      mark_branch_bug (NIA+offset);
a710 1
  check_branch_bug ();
a712 1
      mark_branch_bug (NIA+offset);
a731 1
  check_branch_bug ();
a735 1
      mark_branch_bug (NIA+offset);
a757 1
  check_branch_bug ();
a761 1
      mark_branch_bug (NIA+offset);
a780 1
  check_branch_bug ();
a782 1
      mark_branch_bug (NIA+offset);
a804 1
  check_branch_bug ();
a806 1
      mark_branch_bug (NIA+offset);
a826 1
  check_branch_bug ();
a833 1
      mark_branch_bug (NIA+offset);
a852 1
  check_branch_bug ();
a857 1
      mark_branch_bug (NIA+offset);
a878 1
  check_branch_bug ();
a882 1
      mark_branch_bug (NIA+offset);
a904 1
  check_branch_bug ();
a906 1
      mark_branch_bug (NIA+offset);
a925 1
  check_branch_bug ();
a927 1
      mark_branch_bug (NIA+offset);
a3762 1
  check_branch_bug ();
a3767 1
      mark_branch_bug (dest);
a3792 1
  check_branch_bug ();
a3795 1
      mark_branch_bug (dest);
@


1.49.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a57 1
:model:::vr4120:mips4120:
a58 2
:model:::vr5400:mips5400:
:model:::vr5500:mips5500:
d568 1
d571 1
d591 1
d594 1
d617 1
d620 1
d641 1
d647 1
d667 1
d675 1
d697 1
d700 1
d723 1
d726 1
d746 1
d751 1
d774 1
d779 1
d799 1
d802 1
d825 1
d828 1
d849 1
d857 1
d877 1
d883 1
d905 1
d910 1
d933 1
d936 1
d956 1
d959 1
a1012 1
*vr5500:
a1036 1
*vr5500:
a1145 1
*vr5500:
a1168 1
*vr5500:
d1375 1
a1375 1
      if ((signed64) op1 < 0)
d1380 1
a1380 1
      if ((signed64) op2 < 0)
a2191 1
*vr5500:
a2210 1
*vr5500:
a2314 1
*vr5500:
a2333 1
*vr5500:
a2390 1
*vr5500:
d3795 1
d3801 1
d3827 1
d3831 1
a4297 16
010011,5.BASE,5.INDEX,5.0,5.FD,000101:COP1X:64,f::LUXC1
"luxc1 f<FD>, r<INDEX>(r<BASE>)"
*mipsV:
*mips64:
{
  address_word base = GPR[BASE];
  address_word index = GPR[INDEX];
  address_word vaddr = base + index;
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  /* Arrange for the bottom 3 bits of (base + index) to be 0.  */
  if ((vaddr & 0x7) != 0)
    index -= (vaddr & 0x7);
  COP_LD (1, FD, do_load (SD_, AccessLength_DOUBLEWORD, base, index));
}

a4769 18
010011,5.BASE,5.INDEX,5.FS,00000,001101:COP1X:64,f::SUXC1
"suxc1 f<FS>, r<INDEX>(r<BASE>)"
*mipsV:
*mips64:
{
  unsigned64 v;
  address_word base = GPR[BASE];
  address_word index = GPR[INDEX];
  address_word vaddr = base + index;
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  /* Arrange for the bottom 3 bits of (base + index) to be 0.  */
  if ((vaddr & 0x7) != 0)
    index -= (vaddr & 0x7);
  do_store (SD_, AccessLength_DOUBLEWORD, base, index, COP_SD (1, FS));
}


d5021 11
d5054 12
@


1.49.10.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d221 1
a221 1
// Helpers:
d225 1
a225 1
// In all MIPS ISAs,
d227 4
a230 2
//	OP {HI and LO} followed by MT{LO or HI} (and not MT{HI or LO})
//	makes subsequent MF{HI or LO} UNPREDICTABLE. (1)
a231 18
// The following restrictions exist for MIPS I - MIPS III:
//
//	MF{HI or LO} followed by MT{HI or LO} w/ less than 2 instructions
//	in between makes MF UNPREDICTABLE. (2)
//
//	MF{HI or LO} followed by OP {HI and LO} w/ less than 2 instructions
//	in between makes MF UNPREDICTABLE. (3)
//
// On the r3900, restriction (2) is not present, and restriction (3) is not
// present for multiplication.
//
// For now this code is paranoid.  Historically the simulator
// enforced restrictions (2) and (3) for more ISAs and CPU types than
// necessary.  Unfortunately, at least some MIPS IV and later parts'
// documentation describes them as having these hazards (e.g. vr5000),
// so they can't be removed for at leats MIPS IV.  MIPS V hasn't been
// checked (since there are no known hardware implementations).
// 
a232 5
// check_mf_cycles:
//
// Helper used by check_mt_hilo, check_mult_hilo, and check_div_hilo
// to check for restrictions (2) and (3) above.
//
a245 6

// check_mt_hilo:
//
// Check for restriction (2) above (for ISAs/processors that have it),
// and record timestamps for restriction (1) above.
//
a273 5
// check_mf_hilo:
//
// Check for restriction (1) above, and record timestamps for
// restriction (2) and (3) above.
//
a311 5
// check_mult_hilo:
//
// Check for restriction (3) above (for ISAs/processors that have it)
// for MULT ops, and record timestamps for restriction (1) above.
//
d331 2
a347 5
// check_div_hilo:
//
// Check for restriction (3) above (for ISAs/processors that have it)
// for DIV ops, and record timestamps for restriction (1) above.
//
d354 2
a367 12
}

:function:::int:check_div_hilo:hilo_history *hi, hilo_history *lo
*mips32:
*mips64:
{
  signed64 time = sim_events_time (SD);
  hi->op.timestamp = time;
  lo->op.timestamp = time;
  hi->op.cia = CIA;
  lo->op.cia = CIA;
  return 1;
@


1.49.8.1
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a57 1
:model:::vr4120:mips4120:
a58 2
:model:::vr5400:mips5400:
:model:::vr5500:mips5500:
d568 1
d571 1
d591 1
d594 1
d617 1
d620 1
d641 1
d647 1
d667 1
d675 1
d697 1
d700 1
d723 1
d726 1
d746 1
d751 1
d774 1
d779 1
d799 1
d802 1
d825 1
d828 1
d849 1
d857 1
d877 1
d883 1
d905 1
d910 1
d933 1
d936 1
d956 1
d959 1
a1012 1
*vr5500:
a1036 1
*vr5500:
a1145 1
*vr5500:
a1168 1
*vr5500:
a2191 1
*vr5500:
a2210 1
*vr5500:
a2314 1
*vr5500:
a2333 1
*vr5500:
a2390 1
*vr5500:
d3795 1
d3801 1
d3827 1
d3831 1
a4297 16
010011,5.BASE,5.INDEX,5.0,5.FD,000101:COP1X:64,f::LUXC1
"luxc1 f<FD>, r<INDEX>(r<BASE>)"
*mipsV:
*mips64:
{
  address_word base = GPR[BASE];
  address_word index = GPR[INDEX];
  address_word vaddr = base + index;
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  /* Arrange for the bottom 3 bits of (base + index) to be 0.  */
  if ((vaddr & 0x7) != 0)
    index -= (vaddr & 0x7);
  COP_LD (1, FD, do_load (SD_, AccessLength_DOUBLEWORD, base, index));
}

a4769 18
010011,5.BASE,5.INDEX,5.FS,00000,001101:COP1X:64,f::SUXC1
"suxc1 f<FS>, r<INDEX>(r<BASE>)"
*mipsV:
*mips64:
{
  unsigned64 v;
  address_word base = GPR[BASE];
  address_word index = GPR[INDEX];
  address_word vaddr = base + index;
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  /* Arrange for the bottom 3 bits of (base + index) to be 0.  */
  if ((vaddr & 0x7) != 0)
    index -= (vaddr & 0x7);
  do_store (SD_, AccessLength_DOUBLEWORD, base, index, COP_SD (1, FS));
}


d5021 11
d5054 12
@


1.49.8.2
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d1350 1
a1350 1
      if ((signed64) op1 < 0)
d1355 1
a1355 1
      if ((signed64) op2 < 0)
@


1.49.8.3
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d221 1
a221 1
// Helpers:
d225 1
a225 1
// In all MIPS ISAs,
d227 4
a230 2
//	OP {HI and LO} followed by MT{LO or HI} (and not MT{HI or LO})
//	makes subsequent MF{HI or LO} UNPREDICTABLE. (1)
a231 18
// The following restrictions exist for MIPS I - MIPS III:
//
//	MF{HI or LO} followed by MT{HI or LO} w/ less than 2 instructions
//	in between makes MF UNPREDICTABLE. (2)
//
//	MF{HI or LO} followed by OP {HI and LO} w/ less than 2 instructions
//	in between makes MF UNPREDICTABLE. (3)
//
// On the r3900, restriction (2) is not present, and restriction (3) is not
// present for multiplication.
//
// For now this code is paranoid.  Historically the simulator
// enforced restrictions (2) and (3) for more ISAs and CPU types than
// necessary.  Unfortunately, at least some MIPS IV and later parts'
// documentation describes them as having these hazards (e.g. vr5000),
// so they can't be removed for at leats MIPS IV.  MIPS V hasn't been
// checked (since there are no known hardware implementations).
// 
a232 5
// check_mf_cycles:
//
// Helper used by check_mt_hilo, check_mult_hilo, and check_div_hilo
// to check for restrictions (2) and (3) above.
//
a245 6

// check_mt_hilo:
//
// Check for restriction (2) above (for ISAs/processors that have it),
// and record timestamps for restriction (1) above.
//
a273 5
// check_mf_hilo:
//
// Check for restriction (1) above, and record timestamps for
// restriction (2) and (3) above.
//
a311 5
// check_mult_hilo:
//
// Check for restriction (3) above (for ISAs/processors that have it)
// for MULT ops, and record timestamps for restriction (1) above.
//
d331 2
a347 5
// check_div_hilo:
//
// Check for restriction (3) above (for ISAs/processors that have it)
// for DIV ops, and record timestamps for restriction (1) above.
//
d354 2
a367 12
}

:function:::int:check_div_hilo:hilo_history *hi, hilo_history *lo
*mips32:
*mips64:
{
  signed64 time = sim_events_time (SD);
  hi->op.timestamp = time;
  lo->op.timestamp = time;
  hi->op.cia = CIA;
  lo->op.cia = CIA;
  return 1;
@


1.48
log
@2002-06-14  Chris Demetriou  <cgd@@broadcom.com>
            Ed Satterthwaite  <ehs@@broadcom.com>

	* mips3d.igen: New file which contains MIPS-3D ASE instructions.
	* Makefile.in (IGEN_INCLUDE): Add mips3d.igen.
	* mips.igen: Include mips3d.igen.
	(mips3d): New model name for MIPS-3D ASE instructions.
	(CVT.W.fmt): Don't use this instruction for word (source) format
	instructions.
	* cp1.c (fp_binary_r, fp_add_r, fp_mul_r, fpu_inv1, fpu_inv1_32)
	(fpu_inv1_64, fp_recip1, fp_recip2, fpu_inv_sqrt1, fpu_inv_sqrt1_32)
	(fpu_inv_sqrt1_64, fp_rsqrt1, fp_rsqrt2): New functions.
	(NR_FRAC_GUARD, IMPLICIT_1): New macros.
	* sim-main.h (fmt_pw, CompareAbs, AddR, MultiplyR, Recip1, Recip2)
	(RSquareRoot1, RSquareRoot2): New macros.
	(fp_add_r, fp_mul_r, fp_recip1, fp_recip2, fp_rsqrt1)
	(fp_rsqrt2): New functions.
	* configure.in: Add MIPS-3D support to mipsisa64 simulator.
	* configure: Regenerate.
@
text
@d3644 71
d4260 1
a4260 1
110101,5.BASE,5.FT,16.OFFSET:COP1:32,f::LDC1
d4263 9
a4274 1
*mips32:
d4732 1
a4732 1
111101,5.BASE,5.FT,16.OFFSET:COP1:32,f::SDC1
d4735 9
a4746 1
*mips32:
@


1.47
log
@2002-06-13  Chris Demetriou  <cgd@@broadcom.com>

	* cp1.c (FP_PS_upper, FP_PS_lower, FP_PS_cat, FPQNaN_PS): New macros.
	(value_fpr, store_fpr, fp_cmp, fp_unary, fp_binary, fp_mac)
	(fp_inv_sqrt, fpu_format_name): Add paired-single support.
	(convert): Note that this function is not used for paired-single
	format conversions.
	(ps_lower, ps_upper, pack_ps, convert_ps): New functions.
	* mips.igen (FMT, MOVtf.fmt): Add paired-single support.
	(check_fmt_p): Enable paired-single support.
	(ALNV.PS, CVT.PS.S, CVT.S.PL, CVT.S.PU, PLL.PS, PLU.PS, PUL.PS)
	(PUU.PS): New instructions.
	(CVT.S.fmt): Don't use this instruction for paired-single format
	destinations.
	* sim-main.h (FP_formats): New value 'fmt_ps.'
	(ps_lower, ps_upper, pack_ps, convert_ps): New prototypes.
	(PSLower, PSUpper, PackPS, ConvertPS): New macros.
@
text
@d66 1
d4032 1
a4032 1
010001,10,3.FMT,00000,5.FS,5.FD,100100:COP1:32,f::CVT.W.fmt
d5127 1
@


1.46
log
@2002-06-12  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen: Fix formatting of function calls in
        many FP operations.
@
text
@d3525 1
a3613 1
#if 0 /* XXX FIXME: FP code doesn't yet support paired single ops.  */
a3616 3
#else
  check_fmt (SD_, fmt, insn);
#endif
d3684 26
d3972 12
d3987 1
a3987 1
010001,10,3.FMT,00000,5.FS,5.FD,100000:COP1:32,f::CVT.S.fmt
d4009 22
d4344 16
a4359 6
  {
   if (GETFCC(CC) == TF)
     StoreFPR (FD, fmt, ValueFPR (FS, fmt));
   else
     StoreFPR (FD, fmt, ValueFPR (FD, fmt));
  }
d4519 24
d4560 25
@


1.45
log
@2002-06-12  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (MOVN, MOVZ): Trace result.
        (TNEI): Print "tnei" as the opcode name in traces.
        (CEIL.W): Add disassembly string for traces.
        (RSQRT.fmt): Make location of disassembly string consistent
        with other instructions.
@
text
@d3662 1
a3662 1
  StoreFPR(FD,fmt,AbsoluteValue(ValueFPR(FS,fmt),fmt));
d3683 1
a3683 1
  StoreFPR(FD,fmt,Add(ValueFPR(FS,fmt),ValueFPR(FT,fmt),fmt));
d3791 2
a3792 1
  StoreFPR(FD,fmt_long,Convert(FP_RM_TOPINF,ValueFPR(FS,fmt),fmt,fmt_long));
d3811 2
a3812 1
  StoreFPR(FD,fmt_word,Convert(FP_RM_TOPINF,ValueFPR(FS,fmt),fmt,fmt_word));
d3923 4
a3926 6
  {
    if ((fmt == fmt_double) | 0)
      SignalException (ReservedInstruction, instruction_0);
    else
      StoreFPR(FD,fmt_double,Convert(GETRM(),ValueFPR(FS,fmt),fmt,fmt_double));
  }
d3942 4
a3945 6
  {
    if ((fmt == fmt_long) | ((fmt == fmt_long) || (fmt == fmt_word)))
      SignalException (ReservedInstruction, instruction_0);
    else
      StoreFPR(FD,fmt_long,Convert(GETRM(),ValueFPR(FS,fmt),fmt,fmt_long));
  }
d3967 4
a3970 6
  {
    if ((fmt == fmt_single) | 0)
      SignalException (ReservedInstruction, instruction_0);
    else
      StoreFPR(FD,fmt_single,Convert(GETRM(),ValueFPR(FS,fmt),fmt,fmt_single));
  }
d3989 4
a3992 6
  {
    if ((fmt == fmt_word) | ((fmt == fmt_long) || (fmt == fmt_word)))
      SignalException (ReservedInstruction, instruction_0);
    else
      StoreFPR(FD,fmt_word,Convert(GETRM(),ValueFPR(FS,fmt),fmt,fmt_word));
  }
d4012 1
a4012 1
  StoreFPR(FD,fmt,Divide(ValueFPR(FS,fmt),ValueFPR(FT,fmt),fmt));
d4106 2
a4107 1
  StoreFPR(FD,fmt_long,Convert(FP_RM_TOMINF,ValueFPR(FS,fmt),fmt,fmt_long));
d4126 2
a4127 1
  StoreFPR(FD,fmt_word,Convert(FP_RM_TOMINF,ValueFPR(FS,fmt),fmt,fmt_word));
d4255 1
a4255 1
  StoreFPR(FD,fmt,ValueFPR(FS,fmt));
d4396 1
a4396 1
  StoreFPR(FD,fmt,Multiply(ValueFPR(FS,fmt),ValueFPR(FT,fmt),fmt));
d4416 1
a4416 1
  StoreFPR(FD,fmt,Negate(ValueFPR(FS,fmt),fmt));
d4480 1
a4480 1
  StoreFPR(FD,fmt,Recip(ValueFPR(FS,fmt),fmt));
d4497 2
a4498 1
  StoreFPR(FD,fmt_long,Convert(FP_RM_NEAREST,ValueFPR(FS,fmt),fmt,fmt_long));
d4517 2
a4518 1
  StoreFPR(FD,fmt_word,Convert(FP_RM_NEAREST,ValueFPR(FS,fmt),fmt,fmt_word));
d4581 1
a4581 1
  StoreFPR(FD,fmt,(SquareRoot(ValueFPR(FS,fmt),fmt)));
d4601 1
a4601 1
  StoreFPR(FD,fmt,Sub(ValueFPR(FS,fmt),ValueFPR(FT,fmt),fmt));
d4703 2
a4704 1
  StoreFPR(FD,fmt_long,Convert(FP_RM_TOZERO,ValueFPR(FS,fmt),fmt,fmt_long));
d4723 2
a4724 1
  StoreFPR(FD,fmt_word,Convert(FP_RM_TOZERO,ValueFPR(FS,fmt),fmt,fmt_word));
@


1.44
log
@2002-06-12  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (X): Delete unused function.
@
text
@d2285 4
a2288 1
    GPR[RD] = GPR[RS];
d2302 4
a2305 1
    GPR[RD] = GPR[RS];
d3447 1
a3447 1
"tne r<RS>, <IMMEDIATE>"
d3796 1
d4525 1
a4528 1
"rsqrt.%s<FMT> f<FD>, f<FS>"
@


1.43
log
@2002-06-07  Chris Demetriou  <cgd@@broadcom.com>
            Ed Satterthwaite  <ehs@@broadcom.com>

	* cp1.c (inner_mac, fp_mac, inner_rsqrt, fp_inv_sqrt)
	(fp_rsqrt, fp_madd, fp_msub, fp_nmadd, fp_nmsub): New functions.
	* sim-main.h (fp_rsqrt, fp_madd, fp_msub, fp_nmadd)
	(fp_nmsub): New prototypes.
	(RSquareRoot, MultiplyAdd, MultiplySub, NegMultiplyAdd)
	(NegMultiplySub): New defines.
	* mips.igen (RSQRT.fmt): Use RSquareRoot().
	(MADD.D, MADD.S): Replace with...
	(MADD.fmt): New instruction.
	(MSUB.D, MSUB.S): Replace with...
	(MSUB.fmt): New instruction.
	(NMADD.D, NMADD.S): Replace with...
	(NMADD.fmt): New instruction.
	(NMSUB.D, MSUB.S): Replace with...
	(NMSUB.fmt): New instruction.
@
text
@a3522 10
:%s::::X:int x
{
  switch (x)
    {
    case 0: return "f";
    case 1: return "t";
    default: return "?";
    }
}

@


1.42
log
@2002-06-06  Chris Demetriou  <cgd@@broadcom.com>
            Ed Satterthwaite  <ehs@@broadcom.com>

	* cp1.h: New file.
	* sim-main.h: Include cp1.h.
	(SETFCC, GETFCC, IR, UF, OF, DX, IO, UO, FP_FLAGS, FP_ENABLE)
	(FP_CAUSE, GETFS, FP_RM_NEAREST, FP_RM_TOZERO, FP_RM_TOPINF)
	(FP_RM_TOMINF, GETRM): Remove.  Moved to cp1.h.
	(FP_FS, FP_MASK_RM, FP_SH_RM, Nan, Less, Equal): Remove.
	(value_fcr, store_fcr, test_fcsr, fp_cmp): New prototypes.
	(ValueFCR, StoreFCR, TestFCSR, Compare): New macros.
	* cp1.c: Don't include sim-fpu.h; already included by
	sim-main.h.  Clean up formatting of some comments.
	(NaN, Equal, Less): Remove.
	(test_fcsr, value_fcr, store_fcr, update_fcsr, fp_test)
	(fp_cmp): New functions.
	* mips.igen (do_c_cond_fmt): Remove.
	(C.cond.fmta, C.cond.fmtb): Replace uses of do_c_cond_fmt_a with
	Compare.  Add result tracing.
	(CxC1): Remove, replace with...
	(CFC1a, CFC1b, CFC1c, CTC1a, CTC1b, CTC1c): New instructions.
	(DMxC1): Remove, replace with...
	(DMFC1a, DMFC1b, DMTC1a, DMTC1b): New instructions.
	(MxC1): Remove, replace with...
	(MFC1a, MFC1b, MTC1a, MTC1b): New instructions.
@
text
@d4201 2
a4202 19
//
// FIXME: Not correct for mips*
//
010011,5.FR,5.FT,5.FS,5.FD,100,001:COP1X:32,f::MADD.D
"madd.d f<FD>, f<FR>, f<FS>, f<FT>"
*mipsIV:
*mipsV:
*mips64:
*vr5000:
{
  check_fpu (SD_);
  {
    StoreFPR(FD,fmt_double,Add(Multiply(ValueFPR(FS,fmt_double),ValueFPR(FT,fmt_double),fmt_double),ValueFPR(FR,fmt_double),fmt_double));
  }
}


010011,5.FR,5.FT,5.FS,5.FD,100,000:COP1X:32,f::MADD.S
"madd.s f<FD>, f<FR>, f<FS>, f<FT>"
d4208 1
d4210 4
a4213 3
  {
    StoreFPR(FD,fmt_single,Add(Multiply(ValueFPR(FS,fmt_single),ValueFPR(FT,fmt_single),fmt_single),ValueFPR(FR,fmt_single),fmt_single));
  }
d4342 2
a4343 3
// MSUB.fmt
010011,5.FR,5.FT,5.FS,5.FD,101,001:COP1X:32,f::MSUB.D
"msub.d f<FD>, f<FR>, f<FS>, f<FT>"
d4349 1
d4351 4
a4354 14
  StoreFPR(FD,fmt_double,Sub(Multiply(ValueFPR(FS,fmt_double),ValueFPR(FT,fmt_double),fmt_double),ValueFPR(FR,fmt_double),fmt_double));
}


// MSUB.fmt
010011,5.FR,5.FT,5.FS,5.FD,101000:COP1X:32,f::MSUB.S
"msub.s f<FD>, f<FR>, f<FS>, f<FT>"
*mipsIV:
*mipsV:
*mips64:
*vr5000:
{
  check_fpu (SD_);
  StoreFPR(FD,fmt_single,Sub(Multiply(ValueFPR(FS,fmt_single),ValueFPR(FT,fmt_single),fmt_single),ValueFPR(FR,fmt_single),fmt_single));
d4427 2
a4428 3
// NMADD.fmt
010011,5.FR,5.FT,5.FS,5.FD,110001:COP1X:32,f::NMADD.D
"nmadd.d f<FD>, f<FR>, f<FS>, f<FT>"
d4434 1
d4436 4
a4439 1
  StoreFPR(FD,fmt_double,Negate(Add(Multiply(ValueFPR(FS,fmt_double),ValueFPR(FT,fmt_double),fmt_double),ValueFPR(FR,fmt_double),fmt_double),fmt_double));
d4443 2
a4444 3
// NMADD.fmt
010011,5.FR,5.FT,5.FS,5.FD,110000:COP1X:32,f::NMADD.S
"nmadd.s f<FD>, f<FR>, f<FS>, f<FT>"
d4450 1
d4452 4
a4455 27
  StoreFPR(FD,fmt_single,Negate(Add(Multiply(ValueFPR(FS,fmt_single),ValueFPR(FT,fmt_single),fmt_single),ValueFPR(FR,fmt_single),fmt_single),fmt_single));
}


// NMSUB.fmt
010011,5.FR,5.FT,5.FS,5.FD,111001:COP1X:32,f::NMSUB.D
"nmsub.d f<FD>, f<FR>, f<FS>, f<FT>"
*mipsIV:
*mipsV:
*mips64:
*vr5000:
{
  check_fpu (SD_);
  StoreFPR(FD,fmt_double,Negate(Sub(Multiply(ValueFPR(FS,fmt_double),ValueFPR(FT,fmt_double),fmt_double),ValueFPR(FR,fmt_double),fmt_double),fmt_double));
}


// NMSUB.fmt
010011,5.FR,5.FT,5.FS,5.FD,111000:COP1X:32,f::NMSUB.S
"nmsub.s f<FD>, f<FR>, f<FS>, f<FT>"
*mipsIV:
*mipsV:
*mips64:
*vr5000:
{
  check_fpu (SD_);
  StoreFPR(FD,fmt_single,Negate(Sub(Multiply(ValueFPR(FS,fmt_single),ValueFPR(FT,fmt_single),fmt_single),ValueFPR(FR,fmt_single),fmt_single),fmt_single));
d4537 1
a4537 1
  StoreFPR(FD,fmt,Recip(SquareRoot(ValueFPR(FS,fmt),fmt),fmt));
@


1.41
log
@2002-06-04  Chris Demetriou  <cgd@@broadcom.com>

        * sim-main.h (FGRIDX): Remove, replace all uses with...
        (FGR_BASE): New macro.
        (FP0_REGNUM, FCRCS_REGNUM, FCRIR_REGNUM): New macros.
        (_sim_cpu): Move 'fgr' member to be right before 'fpr_state' member.
        (NR_FGR, FGR): Likewise.
        * interp.c: Replace all uses of FGRIDX with FGR_BASE.
        * mips.igen: Likewise.
@
text
@a3749 39




// C.EQ.S
// C.EQ.D
// ...

:function:::void:do_c_cond_fmt:int fmt, int ft, int fs, int cc, int cond, instruction_word insn
{
  int less;
  int equal;
  int unordered;
  int condition;
  unsigned64 ofs = ValueFPR (fs, fmt);
  unsigned64 oft = ValueFPR (ft, fmt);
  if (NaN (ofs, fmt) || NaN (oft, fmt))
    {
      if (FCSR & FP_ENABLE (IO))
	{
	  FCSR |= FP_CAUSE (IO);
	  SignalExceptionFPE ();
	}
      less = 0;
      equal = 0;
      unordered = 1;
    }
  else
    {
      less = Less (ofs, oft, fmt);
      equal = Equal (ofs, oft, fmt);
      unordered = 0;
    }
  condition = (((cond & (1 << 2)) && less)
	       || ((cond & (1 << 1)) && equal)
	       || ((cond & (1 << 0)) && unordered));
  SETFCC (cc, condition);
}

d3759 2
a3760 1
  do_c_cond_fmt (SD_, fmt, FT, FS, 0, COND, instruction_0);
d3777 2
a3778 1
  do_c_cond_fmt (SD_, fmt, FT, FS, CC, COND, instruction_0);
d3817 2
a3818 4
// CFC1
// CTC1
010001,00,X,10,5.RT,5.FS,00000000000:COP1Sa:32,f::CxC1
"c%s<X>c1 r<RT>, f<FS>"
d3824 16
a3839 1
  if (X)
d3841 3
a3843 14
      if (FS == 0)
	PENDING_FILL(FCR0IDX,VL4_8(GPR[RT]));
      else if (FS == 31)
	PENDING_FILL(FCR31IDX,VL4_8(GPR[RT]));
      /* else NOP */
      PENDING_SCHED(FCSR, FCR31 & (1<<23), 1, 23);
    }
  else
    { /* control from */
      if (FS == 0)
 	PENDING_FILL(RT, EXTEND32 (FCR0));
      else if (FS == 31)
 	PENDING_FILL(RT, EXTEND32 (FCR31));
      /* else NOP */
d3845 2
d3848 3
a3850 3
010001,00,X,10,5.RT,5.FS,00000000000:COP1Sb:32,f::CxC1
"c%s<X>c1 r<RT>, f<FS>"
*mipsIV:
d3854 27
d3886 17
a3902 36
  if (X)
    {
      /* control to */
      TRACE_ALU_INPUT1 (GPR[RT]);
      if (FS == 0)
	{
	  FCR0 = VL4_8(GPR[RT]);
	  TRACE_ALU_RESULT (FCR0);
	}
      else if (FS == 31)
	{
	  FCR31 = VL4_8(GPR[RT]);
	  SETFCC(0,((FCR31 & (1 << 23)) ? 1 : 0));
	  TRACE_ALU_RESULT (FCR31);
	}
      else
	{
	  TRACE_ALU_RESULT0 ();
	}
      /* else NOP */
    }
  else
    { /* control from */
      if (FS == 0)
	{
	  TRACE_ALU_INPUT1 (FCR0);
	  GPR[RT] = EXTEND32 (FCR0);
	}
      else if (FS == 31)
	{
	  TRACE_ALU_INPUT1 (FCR31);
	  GPR[RT] = EXTEND32 (FCR31);
	}
      TRACE_ALU_RESULT (GPR[RT]);
      /* else NOP */
    }
d4025 2
a4026 4
// DMFC1
// DMTC1
010001,00,X,01,5.RT,5.FS,00000000000:COP1Sa:64,f::DMxC1
"dm%s<X>c1 r<RT>, f<FS>"
d4029 1
d4032 41
a4072 1
  if (X)
d4074 2
a4075 7
      if (SizeFGR() == 64)
	PENDING_FILL((FS + FGR_BASE),GPR[RT]);
      else if ((FS & 0x1) == 0)
	{
	  PENDING_FILL(((FS + 1) + FGR_BASE),VH4_8(GPR[RT]));
	  PENDING_FILL((FS + FGR_BASE),VL4_8(GPR[RT]));
	}
d4078 2
a4079 14
    {
      if (SizeFGR() == 64)
	PENDING_FILL(RT,FGR[FS]);
      else if ((FS & 0x1) == 0)
	PENDING_FILL(RT,(SET64HI(FGR[FS+1]) | FGR[FS]));
      else
	{
	  if (STATE_VERBOSE_P(SD))
	    sim_io_eprintf (SD,
	      "Warning: PC 0x%lx: semantic_DMxC1_COP1Sa 32-bit use of odd FPR number\n",
	      (long) CIA);
	  PENDING_FILL(RT,SET64HI(0xDEADC0DE) | 0xBAD0BAD0);
	}
    }
d4081 3
a4083 2
010001,00,X,01,5.RT,5.FS,00000000000:COP1Sb:64,f::DMxC1
"dm%s<X>c1 r<RT>, f<FS>"
d4093 4
a4096 7
  if (X)
    {
      if (SizeFGR() == 64)
	StoreFPR (FS, fmt_uninterpreted_64, GPR[RT]);
      else if ((FS & 0x1) == 0)
	StoreFPR (FS, fmt_uninterpreted_64, SET64HI (FGR[FS+1]) | FGR[FS]);
    }
d4098 1
a4098 14
    {
      if (SizeFGR() == 64)
	GPR[RT] = FGR[FS];
      else if ((FS & 0x1) == 0)
	GPR[RT] = SET64HI (FGR[FS+1]) | FGR[FS];
      else
	{
	  if (STATE_VERBOSE_P(SD))
	    sim_io_eprintf (SD,
	      "Warning: PC 0x%lx: DMxC1 32-bit use of odd FPR number\n",
			    (long) CIA);
	  GPR[RT] = SET64HI (0xDEADC0DE) | 0xBAD0BAD0;
	}
    }
d4232 2
a4233 4
// MFC1
// MTC1
010001,00,X,00,5.RT,5.FS,00000000000:COP1Sa:32,f::MxC1
"m%s<X>c1 r<RT>, f<FS>"
d4238 1
d4240 3
a4242 15
  if (X)
    { /*MTC1*/
      if (SizeFGR() == 64)
	{
	  if (STATE_VERBOSE_P(SD))
	    sim_io_eprintf (SD,
			    "Warning:  PC 0x%lx: MTC1 not DMTC1 with 64 bit regs\n",
			    (long) CIA);
	  PENDING_FILL ((FS + FGR_BASE), (SET64HI(0xDEADC0DE) | VL4_8(GPR[RT])));
	}
      else
	PENDING_FILL ((FS + FGR_BASE), VL4_8(GPR[RT]));
    }
  else /*MFC1*/
    PENDING_FILL (RT, EXTEND32 (FGR[FS]));
d4244 3
a4246 2
010001,00,X,00,5.RT,5.FS,00000000000:COP1Sb:32,f::MxC1
"m%s<X>c1 r<RT>, f<FS>"
d4254 1
a4254 2
{
  int fs = FS;
d4256 2
a4257 5
  if (X)
    /*MTC1*/
    StoreFPR (FS, fmt_uninterpreted_32, VL4_8 (GPR[RT]));
  else /*MFC1*/
    GPR[RT] = EXTEND32 (FGR[FS]);
d4383 27
a4409 1
// MTC1 see MxC1
@


1.40
log
@2002-06-03  Chris Demetriou  <cgd@@broadcom.com>
            Ed Satterthwaite  <ehs@@broadcom.com>

	* configure.in (mipsisa64sb1*-*-*): New target for supporting
	Broadcom SiByte SB-1 processor configurations.
	* configure: Regenerate.
	* sb1.igen: New file.
	* mips.igen: Include sb1.igen.
	(sb1): New model.
	* Makefile.in (IGEN_INCLUDE): Add sb1.igen.
	* mdmx.igen: Add "sb1" model to all appropriate functions and
	instructions.
	* mdmx.c (AbsDiffOB, AvgOB, AccAbsDiffOB): New functions.
	(ob_func, ob_acc): Reference the above.
	(qh_acc): Adjust to keep the same size as ob_acc.
	* sim-main.h (status_SBX, MX_VECT_ABSD, MX_VECT_AVG, MX_AbsDiff)
	(MX_Avg, MX_VECT_ABSDA, MX_AbsDiffC): New macros.
@
text
@d4061 1
a4061 1
	PENDING_FILL((FS + FGRIDX),GPR[RT]);
d4064 2
a4065 2
	  PENDING_FILL(((FS + 1) + FGRIDX),VH4_8(GPR[RT]));
	  PENDING_FILL((FS + FGRIDX),VL4_8(GPR[RT]));
d4267 1
a4267 1
	  PENDING_FILL ((FS + FGRIDX), (SET64HI(0xDEADC0DE) | VL4_8(GPR[RT])));
d4270 1
a4270 1
	PENDING_FILL ((FS + FGRIDX), VL4_8(GPR[RT]));
@


1.39
log
@2002-06-02  Chris Demetriou  <cgd@@broadcom.com>
            Ed Satterthwaite  <ehs@@broadcom.com>

	* mips.igen (mdmx): New (pseudo-)model.
	* mdmx.c, mdmx.igen: New files.
	* Makefile.in (SIM_OBJS): Add mdmx.o.
	* sim-main.h (MDMX_accumulator, MX_fmtsel, signed24, signed48):
	New typedefs.
	(ACC, MX_Add, MX_AddA, MX_AddL, MX_And, MX_C_EQ, MX_C_LT, MX_Comp)
	(MX_FMT_OB, MX_FMT_QH, MX_Max, MX_Min, MX_Msgn, MX_Mul, MX_MulA)
	(MX_MulL, MX_MulS, MX_MulSL, MX_Nor, MX_Or, MX_Pick, MX_RAC)
	(MX_RAC_H, MX_RAC_L, MX_RAC_M, MX_RNAS, MX_RNAU, MX_RND_AS)
	(MX_RND_AU, MX_RND_ES, MX_RND_EU, MX_RND_ZS, MX_RND_ZU, MX_RNES)
	(MX_RNEU, MX_RZS, MX_RZU, MX_SHFL, MX_ShiftLeftLogical)
	(MX_ShiftRightArith, MX_ShiftRightLogical, MX_Sub, MX_SubA, MX_SubL)
	(MX_VECT_ADD, MX_VECT_ADDA, MX_VECT_ADDL, MX_VECT_AND)
	(MX_VECT_MAX, MX_VECT_MIN, MX_VECT_MSGN, MX_VECT_MUL, MX_VECT_MULA)
	(MX_VECT_MULL, MX_VECT_MULS, MX_VECT_MULSL, MX_VECT_NOR)
	(MX_VECT_OR, MX_VECT_SLL, MX_VECT_SRA, MX_VECT_SRL, MX_VECT_SUB)
	(MX_VECT_SUBA, MX_VECT_SUBL, MX_VECT_XOR, MX_WACH, MX_WACL, MX_Xor)
	(SIM_ARGS, SIM_STATE, UnpredictableResult, fmt_mdmx, ob_fmtsel)
	(qh_fmtsel): New macros.
	(_sim_cpu): New member "acc".
	(mdmx_acc_op, mdmx_cc_op, mdmx_cpr_op, mdmx_pick_op, mdmx_rac_op)
	(mdmx_round_op, mdmx_shuffle, mdmx_wach, mdmx_wacl): New functions.
@
text
@d68 6
d5066 1
@


1.38
log
@2002-05-01  Chris Demetriou  <cgd@@broadcom.com>

        * cp1.c (store_fpr): Remove #ifdef'd out call to UndefinedResult
        which wouldn't compile anyway.
        * sim-main.h (unpredictable_action): New function prototype.
        (Unpredictable): Define to call igen function unpredictable().
        (NotWordValue): New macro to call igen function not_word_value().
        (UndefinedResult): Remove.
        * interp.c (undefined_result): Remove.
        (unpredictable_action): New function.
        * mips.igen (not_word_value, unpredictable): New functions.
        (ADD, ADDI, do_addiu, do_addu, BGEZAL, BGEZALL, BLTZAL, BLTZALL)
        (CLO, CLZ, MADD, MADDU, MSUB, MSUBU, MUL, do_mult, do_multu)
        (do_sra, do_srav, do_srl, do_srlv, SUB, do_subu): Invoke
        NotWordValue() to check for unpredictable inputs, then
        Unpredictable() to handle them.
@
text
@d64 1
d66 1
d5059 1
@


1.38.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@a63 1
//  ASEs add instructions on to a base ISA.
a64 8
:model:::mips3d:mips3d:			// mips3d.igen
:model:::mdmx:mdmx:			// mdmx.igen

//  Vendor Extensions
//
//  Instructions specific to these extensions are in separate .igen files.
//  Extensions add instructions on to a base ISA.
:model:::sb1:sb1:			// sb1.igen
d2277 1
a2277 4
    {
      GPR[RD] = GPR[RS];
      TRACE_ALU_RESULT (GPR[RD]);
    }
d2291 1
a2291 4
    {
      GPR[RD] = GPR[RS];
      TRACE_ALU_RESULT (GPR[RD]);
    }
d3433 1
a3433 1
"tnei r<RS>, <IMMEDIATE>"
d3511 10
a3520 1
    case fmt_ps: return "ps";
d3609 1
d3613 3
d3658 1
a3658 1
  StoreFPR (FD, fmt, AbsoluteValue (ValueFPR (FS, fmt), fmt));
d3679 1
a3679 1
  StoreFPR (FD, fmt, Add (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
a3682 26
010011,5.RS,5.FT,5.FS,5.FD,011,110:COP1X:64,f::ALNV.PS
"alnv.ps f<FD>, f<FS>, f<FT>, r<RS>"
*mipsV:
*mips64:
{
  unsigned64 fs;
  unsigned64 ft;
  unsigned64 fd;
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  fs = ValueFPR (FS, fmt_ps);
  if ((GPR[RS] & 0x3) != 0)
    Unpredictable ();
  if ((GPR[RS] & 0x4) == 0)
    fd = fs;
  else
    {
      ft = ValueFPR (FT, fmt_ps);
      if (BigEndianCPU)
	fd = PackPS (PSLower (fs), PSUpper (ft));
      else
	fd = PackPS (PSLower (ft), PSUpper (fs));
    }
  StoreFPR (FD, fmt_ps, fd);
}

d3742 39
d3790 1
a3790 2
  Compare (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt, COND, 0);
  TRACE_ALU_RESULT (ValueFCR (31));
d3807 1
a3807 2
  Compare (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt, COND, CC);
  TRACE_ALU_RESULT (ValueFCR (31));
d3824 1
a3824 2
  StoreFPR (FD, fmt_long, Convert (FP_RM_TOPINF, ValueFPR (FS, fmt), fmt,
	    fmt_long));
a3828 1
"ceil.w.%s<FMT> f<FD>, f<FS>"
d3842 1
a3842 2
  StoreFPR (FD, fmt_word, Convert (FP_RM_TOPINF, ValueFPR (FS, fmt), fmt,
	    fmt_word));
d3846 4
a3849 2
010001,00010,5.RT,5.FS,00000000000:COP1:32,f::CFC1a
"cfc1 r<RT>, f<FS>"
d3855 1
a3855 16
  if (FS == 0)
    PENDING_FILL (RT, EXTEND32 (FCR0));
  else if (FS == 31)
    PENDING_FILL (RT, EXTEND32 (FCR31));
  /* else NOP */
}

010001,00010,5.RT,5.FS,00000000000:COP1:32,f::CFC1b
"cfc1 r<RT>, f<FS>"
*mipsIV:
*vr4100:
*vr5000:
*r3900:
{
  check_fpu (SD_);
  if (FS == 0 || FS == 31)
d3857 14
a3870 3
      unsigned_word  fcr = ValueFCR (FS);
      TRACE_ALU_INPUT1 (fcr);
      GPR[RT] = fcr;
a3871 2
  /* else NOP */
  TRACE_ALU_RESULT (GPR[RT]);
d3873 3
a3875 3

010001,00010,5.RT,5.FS,00000000000:COP1:32,f::CFC1c
"cfc1 r<RT>, f<FS>"
a3878 27
{
  check_fpu (SD_);
  if (FS == 0 || FS == 25 || FS == 26 || FS == 28 || FS == 31)
    {
      unsigned_word  fcr = ValueFCR (FS);
      TRACE_ALU_INPUT1 (fcr);
      GPR[RT] = fcr;
    }
  /* else NOP */
  TRACE_ALU_RESULT (GPR[RT]);
}

010001,00110,5.RT,5.FS,00000000000:COP1:32,f::CTC1a
"ctc1 r<RT>, f<FS>"
*mipsI:
*mipsII:
*mipsIII:
{
  check_fpu (SD_);
  if (FS == 31)
    PENDING_FILL (FCRCS_REGNUM, VL4_8 (GPR[RT]));
  /* else NOP */
}

010001,00110,5.RT,5.FS,00000000000:COP1:32,f::CTC1b
"ctc1 r<RT>, f<FS>"
*mipsIV:
d3884 36
a3919 17
  TRACE_ALU_INPUT1 (GPR[RT]);
  if (FS == 31)
    StoreFCR (FS, GPR[RT]);
  /* else NOP */
}

010001,00110,5.RT,5.FS,00000000000:COP1:32,f::CTC1c
"ctc1 r<RT>, f<FS>"
*mipsV:
*mips32:
*mips64:
{
  check_fpu (SD_);
  TRACE_ALU_INPUT1 (GPR[RT]);
  if (FS == 25 || FS == 26 || FS == 28 || FS == 31)
      StoreFCR (FS, GPR[RT]);
  /* else NOP */
d3941 6
a3946 4
  if ((fmt == fmt_double) | 0)
    SignalException (ReservedInstruction, instruction_0);
  StoreFPR (FD, fmt_double, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
	    fmt_double));
d3962 6
a3967 16
  if ((fmt == fmt_long) | ((fmt == fmt_long) || (fmt == fmt_word)))
    SignalException (ReservedInstruction, instruction_0);
  StoreFPR (FD, fmt_long, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
	    fmt_long));
}


010001,10,000,5.FT,5.FS,5.FD,100110:COP1:64,f::CVT.PS.S
"cvt.ps.s f<FD>, f<FS>, f<FT>"
*mipsV:
*mips64:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  StoreFPR (FD, fmt_ps, PackPS (ValueFPR (FS, fmt_single),
				ValueFPR (FT, fmt_single)));
d3974 1
a3974 1
010001,10,3.FMT!6,00000,5.FS,5.FD,100000:COP1:32,f::CVT.S.fmt
d3989 6
a3994 26
  if ((fmt == fmt_single) | 0)
    SignalException (ReservedInstruction, instruction_0);
  StoreFPR (FD, fmt_single, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
	    fmt_single));
}


010001,10,110,00000,5.FS,5.FD,101000:COP1:64,f::CVT.S.PL
"cvt.s.pl f<FD>, f<FS>"
*mipsV:
*mips64:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  StoreFPR (FD, fmt_single, PSLower (ValueFPR (FS, fmt_ps)));
}


010001,10,110,00000,5.FS,5.FD,100000:COP1:64,f::CVT.S.PU
"cvt.s.pu f<FD>, f<FS>"
*mipsV:
*mips64:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  StoreFPR (FD, fmt_single, PSUpper (ValueFPR (FS, fmt_ps)));
d3998 1
a3998 1
010001,10,3.FMT!6,00000,5.FS,5.FD,100100:COP1:32,f::CVT.W.fmt
d4013 6
a4018 4
  if ((fmt == fmt_word) | ((fmt == fmt_long) || (fmt == fmt_word)))
    SignalException (ReservedInstruction, instruction_0);
  StoreFPR (FD, fmt_word, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
	    fmt_word));
d4038 1
a4038 1
  StoreFPR (FD, fmt, Divide (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
d4042 4
a4045 2
010001,00001,5.RT,5.FS,00000000000:COP1:64,f::DMFC1a
"dmfc1 r<RT>, f<FS>"
a4047 1
  unsigned64 v;
d4050 10
a4059 4
  if (SizeFGR () == 64)
    v = FGR[FS];
  else if ((FS & 0x1) == 0)
    v = SET64HI (FGR[FS+1]) | FGR[FS];
d4061 14
a4074 3
    v = SET64HI (0xDEADC0DE) | 0xBAD0BAD0;
  PENDING_FILL (RT, v);
  TRACE_ALU_RESULT (v);
d4076 2
a4077 3

010001,00001,5.RT,5.FS,00000000000:COP1:64,f::DMFC1b
"dmfc1 r<RT>, f<FS>"
d4087 7
a4093 4
  if (SizeFGR () == 64)
    GPR[RT] = FGR[FS];
  else if ((FS & 0x1) == 0)
    GPR[RT] = SET64HI (FGR[FS+1]) | FGR[FS];
a4094 15
    GPR[RT] = SET64HI (0xDEADC0DE) | 0xBAD0BAD0;
  TRACE_ALU_RESULT (GPR[RT]);
}


010001,00101,5.RT,5.FS,00000000000:COP1:64,f::DMTC1a
"dmtc1 r<RT>, f<FS>"
*mipsIII:
{
  unsigned64 v;
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  if (SizeFGR () == 64)
    PENDING_FILL ((FS + FGR_BASE), GPR[RT]);
  else if ((FS & 0x1) == 0)
d4096 12
a4107 2
      PENDING_FILL (((FS + 1) + FGR_BASE), VH4_8 (GPR[RT]));
      PENDING_FILL ((FS + FGR_BASE), VL4_8 (GPR[RT]));
a4108 22
  else
    Unpredictable ();
  TRACE_FP_RESULT (GPR[RT]);
}

010001,00101,5.RT,5.FS,00000000000:COP1:64,f::DMTC1b
"dmtc1 r<RT>, f<FS>"
*mipsIV:
*mipsV:
*mips64:
*vr4100:
*vr5000:
*r3900:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  if (SizeFGR () == 64)
    StoreFPR (FS, fmt_uninterpreted_64, GPR[RT]);
  else if ((FS & 0x1) == 0)
    StoreFPR (FS, fmt_uninterpreted_64, GPR[RT]);
  else
    Unpredictable ();
d4125 1
a4125 2
  StoreFPR (FD, fmt_long, Convert (FP_RM_TOMINF, ValueFPR (FS, fmt), fmt,
	    fmt_long));
d4144 1
a4144 2
  StoreFPR (FD, fmt_word, Convert (FP_RM_TOMINF, ValueFPR (FS, fmt), fmt,
	    fmt_word));
d4211 19
a4229 2
010011,5.FR,5.FT,5.FS,5.FD,100,3.FMT:COP1X:64,f::MADD.fmt
"madd.%s<FMT> f<FD>, f<FR>, f<FS>, f<FT>"
a4234 1
  int fmt = FMT;
d4236 3
a4238 4
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0); 
  StoreFPR (FD, fmt, MultiplyAdd (ValueFPR (FS, fmt), ValueFPR (FT, fmt),
				  ValueFPR (FR, fmt), fmt));
d4242 4
a4245 2
010001,00000,5.RT,5.FS,00000000000:COP1:32,f::MFC1a
"mfc1 r<RT>, f<FS>"
a4249 1
  unsigned64 v;
d4251 15
a4265 3
  v = EXTEND32 (FGR[FS]);
  PENDING_FILL (RT, v);
  TRACE_ALU_RESULT (v);
d4267 2
a4268 3
  
010001,00000,5.RT,5.FS,00000000000:COP1:32,f::MFC1b
"mfc1 r<RT>, f<FS>"
d4276 2
a4277 1
{ 
d4279 5
a4283 2
  GPR[RT] = EXTEND32 (FGR[FS]);
  TRACE_ALU_RESULT (GPR[RT]);
d4303 1
a4303 1
  StoreFPR (FD, fmt, ValueFPR (FS, fmt));
d4335 6
a4340 16
  if (fmt != fmt_ps)
    {
      if (GETFCC(CC) == TF)
	StoreFPR (FD, fmt, ValueFPR (FS, fmt));
      else
	StoreFPR (FD, fmt, ValueFPR (FD, fmt));   /* set fmt */
    }
  else
    {
      unsigned64 fd;
      fd = PackPS (PSUpper (ValueFPR ((GETFCC (CC+1) == TF) ? FS : FD,
				      fmt_ps)),
		   PSLower (ValueFPR ((GETFCC (CC+0) == TF) ? FS : FD,
				      fmt_ps)));
      StoreFPR (FD, fmt_ps, fd);
    }
d4383 3
a4385 2
010011,5.FR,5.FT,5.FS,5.FD,101,3.FMT:COP1X:64,f::MSUB.fmt
"msub.%s<FMT> f<FD>, f<FR>, f<FS>, f<FT>"
a4390 1
  int fmt = FMT;
d4392 1
a4392 4
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (FD, fmt, MultiplySub (ValueFPR (FS, fmt), ValueFPR (FT, fmt),
				  ValueFPR (FR, fmt), fmt));
d4396 3
a4398 16
010001,00100,5.RT,5.FS,00000000000:COP1:32,f::MTC1a
"mtc1 r<RT>, f<FS>"
*mipsI:
*mipsII:
*mipsIII:
{ 
  check_fpu (SD_);
  if (SizeFGR () == 64)
    PENDING_FILL ((FS + FGR_BASE), (SET64HI (0xDEADC0DE) | VL4_8 (GPR[RT])));
  else
    PENDING_FILL ((FS + FGR_BASE), VL4_8 (GPR[RT]));
  TRACE_FP_RESULT (GPR[RT]);
} 

010001,00100,5.RT,5.FS,00000000000:COP1:32,f::MTC1b
"mtc1 r<RT>, f<FS>"
a4400 1
*mips32:
a4401 1
*vr4100:
a4402 1
*r3900:
d4404 2
a4405 2
  check_fpu (SD_); 
  StoreFPR (FS, fmt_uninterpreted_32, VL4_8 (GPR[RT]));
d4409 3
d4428 1
a4428 1
  StoreFPR (FD, fmt, Multiply (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
d4448 1
a4448 1
  StoreFPR (FD, fmt, Negate (ValueFPR (FS, fmt), fmt));
d4452 3
a4454 2
010011,5.FR,5.FT,5.FS,5.FD,110,3.FMT:COP1X:64,f::NMADD.fmt
"nmadd.%s<FMT> f<FD>, f<FR>, f<FS>, f<FT>"
a4459 1
  int fmt = FMT;
d4461 1
a4461 4
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (FD, fmt, NegMultiplyAdd (ValueFPR (FS, fmt), ValueFPR (FT, fmt),
				     ValueFPR (FR, fmt), fmt));
d4465 3
a4467 2
010011,5.FR,5.FT,5.FS,5.FD,111,3.FMT:COP1X:64,f::NMSUB.fmt
"nmsub.%s<FMT> f<FD>, f<FR>, f<FS>, f<FT>"
a4472 1
  int fmt = FMT;
d4474 1
a4474 4
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (FD, fmt, NegMultiplySub (ValueFPR (FS, fmt), ValueFPR (FT, fmt),
				     ValueFPR (FR, fmt), fmt));
d4478 4
a4481 2
010001,10,110,5.FT,5.FS,5.FD,101100:COP1:64,f::PLL.PS
"pll.ps f<FD>, f<FS>, f<FT>"
d4484 1
d4487 1
a4487 3
  check_u64 (SD_, instruction_0);
  StoreFPR (FD, fmt_ps, PackPS (PSLower (ValueFPR (FS, fmt_ps)),
				PSLower (ValueFPR (FT, fmt_ps))));
d4491 4
a4494 2
010001,10,110,5.FT,5.FS,5.FD,101101:COP1:64,f::PLU.PS
"plu.ps f<FD>, f<FS>, f<FT>"
d4497 1
d4500 1
a4500 3
  check_u64 (SD_, instruction_0);
  StoreFPR (FD, fmt_ps, PackPS (PSLower (ValueFPR (FS, fmt_ps)),
				PSUpper (ValueFPR (FT, fmt_ps))));
a4521 25

010001,10,110,5.FT,5.FS,5.FD,101110:COP1:64,f::PUL.PS
"pul.ps f<FD>, f<FS>, f<FT>"
*mipsV:
*mips64:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  StoreFPR (FD, fmt_ps, PackPS (PSUpper (ValueFPR (FS, fmt_ps)),
				PSLower (ValueFPR (FT, fmt_ps))));
}


010001,10,110,5.FT,5.FS,5.FD,101111:COP1:64,f::PUU.PS
"puu.ps f<FD>, f<FS>, f<FT>"
*mipsV:
*mips64:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  StoreFPR (FD, fmt_ps, PackPS (PSUpper (ValueFPR (FS, fmt_ps)),
				PSUpper (ValueFPR (FT, fmt_ps))));
}


d4532 1
a4532 1
  StoreFPR (FD, fmt, Recip (ValueFPR (FS, fmt), fmt));
d4549 1
a4549 2
  StoreFPR (FD, fmt_long, Convert (FP_RM_NEAREST, ValueFPR (FS, fmt), fmt,
	    fmt_long));
d4568 1
a4568 2
  StoreFPR (FD, fmt_word, Convert (FP_RM_NEAREST, ValueFPR (FS, fmt), fmt,
	    fmt_word));
a4572 1
"rsqrt.%s<FMT> f<FD>, f<FS>"
d4576 1
d4582 1
a4582 1
  StoreFPR (FD, fmt, RSquareRoot (ValueFPR (FS, fmt), fmt));
d4631 1
a4631 1
  StoreFPR (FD, fmt,  (SquareRoot (ValueFPR (FS, fmt), fmt)));
d4651 1
a4651 1
  StoreFPR (FD, fmt, Sub (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
d4753 1
a4753 2
  StoreFPR (FD, fmt_long, Convert (FP_RM_TOZERO, ValueFPR (FS, fmt), fmt,
	    fmt_long));
d4772 1
a4772 2
  StoreFPR (FD, fmt_word, Convert (FP_RM_TOZERO, ValueFPR (FS, fmt), fmt,
	    fmt_word));
a5056 3
:include:::mdmx.igen
:include:::mips3d.igen
:include:::sb1.igen
@


1.38.6.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@a3643 71
// Helper:
//
// Load a double word FP value using 2 32-bit memory cycles a la MIPS II
// or MIPS32.  do_load cannot be used instead because it returns an
// unsigned_word, which is limited to the size of the machine's registers.
//

:function:::unsigned64:do_load_double:address_word base, address_word offset
*mipsII:
*mips32:
{
  int bigendian = (BigEndianCPU ? ! ReverseEndian : ReverseEndian);
  address_word vaddr;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  unsigned64 v;

  vaddr = loadstore_ea (SD_, base, offset);
  if ((vaddr & AccessLength_DOUBLEWORD) != 0)
    {
      SIM_CORE_SIGNAL (SD, STATE_CPU (SD, 0), cia, read_map,
		       AccessLength_DOUBLEWORD + 1, vaddr, read_transfer,
		       sim_core_unaligned_signal);
    }
  AddressTranslation (vaddr, isDATA, isLOAD, &paddr, &uncached, isTARGET,
		      isREAL);
  LoadMemory (&memval, NULL, uncached, AccessLength_WORD, paddr, vaddr,
	      isDATA, isREAL);
  v = (unsigned64)memval;
  LoadMemory (&memval, NULL, uncached, AccessLength_WORD, paddr + 4, vaddr + 4,
	      isDATA, isREAL);
  return (bigendian ? ((v << 32) | memval) : (v | (memval << 32)));
}


// Helper:
//
// Store a double word FP value using 2 32-bit memory cycles a la MIPS II
// or MIPS32.  do_load cannot be used instead because it returns an
// unsigned_word, which is limited to the size of the machine's registers.
//

:function:::void:do_store_double:address_word base, address_word offset, unsigned64 v
*mipsII:
*mips32:
{
  int bigendian = (BigEndianCPU ? ! ReverseEndian : ReverseEndian);
  address_word vaddr;
  address_word paddr;
  int uncached;
  unsigned64 memval;

  vaddr = loadstore_ea (SD_, base, offset);
  if ((vaddr & AccessLength_DOUBLEWORD) != 0)
    {
      SIM_CORE_SIGNAL (SD, STATE_CPU(SD, 0), cia, read_map,
		       AccessLength_DOUBLEWORD + 1, vaddr, write_transfer,
		       sim_core_unaligned_signal);
    }
  AddressTranslation (vaddr, isDATA, isSTORE, &paddr, &uncached, isTARGET,
		      isREAL);
  memval = (bigendian ? (v >> 32) : (v & 0xFFFFFFFF));
  StoreMemory (uncached, AccessLength_WORD, memval, 0, paddr, vaddr,
	       isREAL);
  memval = (bigendian ? (v & 0xFFFFFFFF) : (v >> 32));
  StoreMemory (uncached, AccessLength_WORD, memval, 0, paddr + 4, vaddr + 4,
	       isREAL);
}


d4189 1
a4189 1
110101,5.BASE,5.FT,16.OFFSET:COP1:32,f::LDC1a
a4191 9
*mips32:
{
  check_fpu (SD_);
  COP_LD (1, FT, do_load_double (SD_, GPR[BASE], EXTEND16 (OFFSET)));
}


110101,5.BASE,5.FT,16.OFFSET:COP1:32,f::LDC1b
"ldc1 f<FT>, <OFFSET>(r<BASE>)"
d4195 1
d4653 1
a4653 1
111101,5.BASE,5.FT,16.OFFSET:COP1:32,f::SDC1a
a4655 9
*mips32:
{
  check_fpu (SD_);
  do_store_double (SD_, GPR[BASE], EXTEND16 (OFFSET), COP_SD (1, FT));
}


111101,5.BASE,5.FT,16.OFFSET:COP1:32,f::SDC1b
"sdc1 f<FT>, <OFFSET>(r<BASE>)"
d4659 1
@


1.38.4.1
log
@merge from trunk
@
text
@a63 1
//  ASEs add instructions on to a base ISA.
a64 8
:model:::mips3d:mips3d:			// mips3d.igen
:model:::mdmx:mdmx:			// mdmx.igen

//  Vendor Extensions
//
//  Instructions specific to these extensions are in separate .igen files.
//  Extensions add instructions on to a base ISA.
:model:::sb1:sb1:			// sb1.igen
d2277 1
a2277 4
    {
      GPR[RD] = GPR[RS];
      TRACE_ALU_RESULT (GPR[RD]);
    }
d2291 1
a2291 4
    {
      GPR[RD] = GPR[RS];
      TRACE_ALU_RESULT (GPR[RD]);
    }
d3433 1
a3433 1
"tnei r<RS>, <IMMEDIATE>"
d3511 10
a3520 1
    case fmt_ps: return "ps";
d3609 1
d3613 3
d3658 1
a3658 1
  StoreFPR (FD, fmt, AbsoluteValue (ValueFPR (FS, fmt), fmt));
d3679 1
a3679 1
  StoreFPR (FD, fmt, Add (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
a3682 26
010011,5.RS,5.FT,5.FS,5.FD,011,110:COP1X:64,f::ALNV.PS
"alnv.ps f<FD>, f<FS>, f<FT>, r<RS>"
*mipsV:
*mips64:
{
  unsigned64 fs;
  unsigned64 ft;
  unsigned64 fd;
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  fs = ValueFPR (FS, fmt_ps);
  if ((GPR[RS] & 0x3) != 0)
    Unpredictable ();
  if ((GPR[RS] & 0x4) == 0)
    fd = fs;
  else
    {
      ft = ValueFPR (FT, fmt_ps);
      if (BigEndianCPU)
	fd = PackPS (PSLower (fs), PSUpper (ft));
      else
	fd = PackPS (PSLower (ft), PSUpper (fs));
    }
  StoreFPR (FD, fmt_ps, fd);
}

d3742 39
d3790 1
a3790 2
  Compare (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt, COND, 0);
  TRACE_ALU_RESULT (ValueFCR (31));
d3807 1
a3807 2
  Compare (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt, COND, CC);
  TRACE_ALU_RESULT (ValueFCR (31));
d3824 1
a3824 2
  StoreFPR (FD, fmt_long, Convert (FP_RM_TOPINF, ValueFPR (FS, fmt), fmt,
	    fmt_long));
a3828 1
"ceil.w.%s<FMT> f<FD>, f<FS>"
d3842 1
a3842 2
  StoreFPR (FD, fmt_word, Convert (FP_RM_TOPINF, ValueFPR (FS, fmt), fmt,
	    fmt_word));
d3846 4
a3849 2
010001,00010,5.RT,5.FS,00000000000:COP1:32,f::CFC1a
"cfc1 r<RT>, f<FS>"
d3855 1
a3855 16
  if (FS == 0)
    PENDING_FILL (RT, EXTEND32 (FCR0));
  else if (FS == 31)
    PENDING_FILL (RT, EXTEND32 (FCR31));
  /* else NOP */
}

010001,00010,5.RT,5.FS,00000000000:COP1:32,f::CFC1b
"cfc1 r<RT>, f<FS>"
*mipsIV:
*vr4100:
*vr5000:
*r3900:
{
  check_fpu (SD_);
  if (FS == 0 || FS == 31)
d3857 14
a3870 3
      unsigned_word  fcr = ValueFCR (FS);
      TRACE_ALU_INPUT1 (fcr);
      GPR[RT] = fcr;
a3871 2
  /* else NOP */
  TRACE_ALU_RESULT (GPR[RT]);
d3873 3
a3875 3

010001,00010,5.RT,5.FS,00000000000:COP1:32,f::CFC1c
"cfc1 r<RT>, f<FS>"
a3878 27
{
  check_fpu (SD_);
  if (FS == 0 || FS == 25 || FS == 26 || FS == 28 || FS == 31)
    {
      unsigned_word  fcr = ValueFCR (FS);
      TRACE_ALU_INPUT1 (fcr);
      GPR[RT] = fcr;
    }
  /* else NOP */
  TRACE_ALU_RESULT (GPR[RT]);
}

010001,00110,5.RT,5.FS,00000000000:COP1:32,f::CTC1a
"ctc1 r<RT>, f<FS>"
*mipsI:
*mipsII:
*mipsIII:
{
  check_fpu (SD_);
  if (FS == 31)
    PENDING_FILL (FCRCS_REGNUM, VL4_8 (GPR[RT]));
  /* else NOP */
}

010001,00110,5.RT,5.FS,00000000000:COP1:32,f::CTC1b
"ctc1 r<RT>, f<FS>"
*mipsIV:
d3884 36
a3919 17
  TRACE_ALU_INPUT1 (GPR[RT]);
  if (FS == 31)
    StoreFCR (FS, GPR[RT]);
  /* else NOP */
}

010001,00110,5.RT,5.FS,00000000000:COP1:32,f::CTC1c
"ctc1 r<RT>, f<FS>"
*mipsV:
*mips32:
*mips64:
{
  check_fpu (SD_);
  TRACE_ALU_INPUT1 (GPR[RT]);
  if (FS == 25 || FS == 26 || FS == 28 || FS == 31)
      StoreFCR (FS, GPR[RT]);
  /* else NOP */
d3941 6
a3946 4
  if ((fmt == fmt_double) | 0)
    SignalException (ReservedInstruction, instruction_0);
  StoreFPR (FD, fmt_double, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
	    fmt_double));
d3962 6
a3967 16
  if ((fmt == fmt_long) | ((fmt == fmt_long) || (fmt == fmt_word)))
    SignalException (ReservedInstruction, instruction_0);
  StoreFPR (FD, fmt_long, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
	    fmt_long));
}


010001,10,000,5.FT,5.FS,5.FD,100110:COP1:64,f::CVT.PS.S
"cvt.ps.s f<FD>, f<FS>, f<FT>"
*mipsV:
*mips64:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  StoreFPR (FD, fmt_ps, PackPS (ValueFPR (FS, fmt_single),
				ValueFPR (FT, fmt_single)));
d3974 1
a3974 1
010001,10,3.FMT!6,00000,5.FS,5.FD,100000:COP1:32,f::CVT.S.fmt
d3989 6
a3994 26
  if ((fmt == fmt_single) | 0)
    SignalException (ReservedInstruction, instruction_0);
  StoreFPR (FD, fmt_single, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
	    fmt_single));
}


010001,10,110,00000,5.FS,5.FD,101000:COP1:64,f::CVT.S.PL
"cvt.s.pl f<FD>, f<FS>"
*mipsV:
*mips64:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  StoreFPR (FD, fmt_single, PSLower (ValueFPR (FS, fmt_ps)));
}


010001,10,110,00000,5.FS,5.FD,100000:COP1:64,f::CVT.S.PU
"cvt.s.pu f<FD>, f<FS>"
*mipsV:
*mips64:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  StoreFPR (FD, fmt_single, PSUpper (ValueFPR (FS, fmt_ps)));
d3998 1
a3998 1
010001,10,3.FMT!6,00000,5.FS,5.FD,100100:COP1:32,f::CVT.W.fmt
d4013 6
a4018 4
  if ((fmt == fmt_word) | ((fmt == fmt_long) || (fmt == fmt_word)))
    SignalException (ReservedInstruction, instruction_0);
  StoreFPR (FD, fmt_word, Convert (GETRM (), ValueFPR (FS, fmt), fmt,
	    fmt_word));
d4038 1
a4038 1
  StoreFPR (FD, fmt, Divide (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
d4042 4
a4045 2
010001,00001,5.RT,5.FS,00000000000:COP1:64,f::DMFC1a
"dmfc1 r<RT>, f<FS>"
a4047 1
  unsigned64 v;
d4050 10
a4059 4
  if (SizeFGR () == 64)
    v = FGR[FS];
  else if ((FS & 0x1) == 0)
    v = SET64HI (FGR[FS+1]) | FGR[FS];
d4061 14
a4074 3
    v = SET64HI (0xDEADC0DE) | 0xBAD0BAD0;
  PENDING_FILL (RT, v);
  TRACE_ALU_RESULT (v);
d4076 2
a4077 3

010001,00001,5.RT,5.FS,00000000000:COP1:64,f::DMFC1b
"dmfc1 r<RT>, f<FS>"
d4087 7
a4093 4
  if (SizeFGR () == 64)
    GPR[RT] = FGR[FS];
  else if ((FS & 0x1) == 0)
    GPR[RT] = SET64HI (FGR[FS+1]) | FGR[FS];
a4094 15
    GPR[RT] = SET64HI (0xDEADC0DE) | 0xBAD0BAD0;
  TRACE_ALU_RESULT (GPR[RT]);
}


010001,00101,5.RT,5.FS,00000000000:COP1:64,f::DMTC1a
"dmtc1 r<RT>, f<FS>"
*mipsIII:
{
  unsigned64 v;
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  if (SizeFGR () == 64)
    PENDING_FILL ((FS + FGR_BASE), GPR[RT]);
  else if ((FS & 0x1) == 0)
d4096 12
a4107 2
      PENDING_FILL (((FS + 1) + FGR_BASE), VH4_8 (GPR[RT]));
      PENDING_FILL ((FS + FGR_BASE), VL4_8 (GPR[RT]));
a4108 22
  else
    Unpredictable ();
  TRACE_FP_RESULT (GPR[RT]);
}

010001,00101,5.RT,5.FS,00000000000:COP1:64,f::DMTC1b
"dmtc1 r<RT>, f<FS>"
*mipsIV:
*mipsV:
*mips64:
*vr4100:
*vr5000:
*r3900:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  if (SizeFGR () == 64)
    StoreFPR (FS, fmt_uninterpreted_64, GPR[RT]);
  else if ((FS & 0x1) == 0)
    StoreFPR (FS, fmt_uninterpreted_64, GPR[RT]);
  else
    Unpredictable ();
d4125 1
a4125 2
  StoreFPR (FD, fmt_long, Convert (FP_RM_TOMINF, ValueFPR (FS, fmt), fmt,
	    fmt_long));
d4144 1
a4144 2
  StoreFPR (FD, fmt_word, Convert (FP_RM_TOMINF, ValueFPR (FS, fmt), fmt,
	    fmt_word));
d4211 19
a4229 2
010011,5.FR,5.FT,5.FS,5.FD,100,3.FMT:COP1X:64,f::MADD.fmt
"madd.%s<FMT> f<FD>, f<FR>, f<FS>, f<FT>"
a4234 1
  int fmt = FMT;
d4236 3
a4238 4
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0); 
  StoreFPR (FD, fmt, MultiplyAdd (ValueFPR (FS, fmt), ValueFPR (FT, fmt),
				  ValueFPR (FR, fmt), fmt));
d4242 4
a4245 2
010001,00000,5.RT,5.FS,00000000000:COP1:32,f::MFC1a
"mfc1 r<RT>, f<FS>"
a4249 1
  unsigned64 v;
d4251 15
a4265 3
  v = EXTEND32 (FGR[FS]);
  PENDING_FILL (RT, v);
  TRACE_ALU_RESULT (v);
d4267 2
a4268 3
  
010001,00000,5.RT,5.FS,00000000000:COP1:32,f::MFC1b
"mfc1 r<RT>, f<FS>"
d4276 2
a4277 1
{ 
d4279 5
a4283 2
  GPR[RT] = EXTEND32 (FGR[FS]);
  TRACE_ALU_RESULT (GPR[RT]);
d4303 1
a4303 1
  StoreFPR (FD, fmt, ValueFPR (FS, fmt));
d4335 6
a4340 16
  if (fmt != fmt_ps)
    {
      if (GETFCC(CC) == TF)
	StoreFPR (FD, fmt, ValueFPR (FS, fmt));
      else
	StoreFPR (FD, fmt, ValueFPR (FD, fmt));   /* set fmt */
    }
  else
    {
      unsigned64 fd;
      fd = PackPS (PSUpper (ValueFPR ((GETFCC (CC+1) == TF) ? FS : FD,
				      fmt_ps)),
		   PSLower (ValueFPR ((GETFCC (CC+0) == TF) ? FS : FD,
				      fmt_ps)));
      StoreFPR (FD, fmt_ps, fd);
    }
d4383 3
a4385 2
010011,5.FR,5.FT,5.FS,5.FD,101,3.FMT:COP1X:64,f::MSUB.fmt
"msub.%s<FMT> f<FD>, f<FR>, f<FS>, f<FT>"
a4390 1
  int fmt = FMT;
d4392 1
a4392 4
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (FD, fmt, MultiplySub (ValueFPR (FS, fmt), ValueFPR (FT, fmt),
				  ValueFPR (FR, fmt), fmt));
d4396 3
a4398 16
010001,00100,5.RT,5.FS,00000000000:COP1:32,f::MTC1a
"mtc1 r<RT>, f<FS>"
*mipsI:
*mipsII:
*mipsIII:
{ 
  check_fpu (SD_);
  if (SizeFGR () == 64)
    PENDING_FILL ((FS + FGR_BASE), (SET64HI (0xDEADC0DE) | VL4_8 (GPR[RT])));
  else
    PENDING_FILL ((FS + FGR_BASE), VL4_8 (GPR[RT]));
  TRACE_FP_RESULT (GPR[RT]);
} 

010001,00100,5.RT,5.FS,00000000000:COP1:32,f::MTC1b
"mtc1 r<RT>, f<FS>"
a4400 1
*mips32:
a4401 1
*vr4100:
a4402 1
*r3900:
d4404 2
a4405 2
  check_fpu (SD_); 
  StoreFPR (FS, fmt_uninterpreted_32, VL4_8 (GPR[RT]));
d4409 3
d4428 1
a4428 1
  StoreFPR (FD, fmt, Multiply (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
d4448 1
a4448 1
  StoreFPR (FD, fmt, Negate (ValueFPR (FS, fmt), fmt));
d4452 3
a4454 2
010011,5.FR,5.FT,5.FS,5.FD,110,3.FMT:COP1X:64,f::NMADD.fmt
"nmadd.%s<FMT> f<FD>, f<FR>, f<FS>, f<FT>"
a4459 1
  int fmt = FMT;
d4461 1
a4461 4
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (FD, fmt, NegMultiplyAdd (ValueFPR (FS, fmt), ValueFPR (FT, fmt),
				     ValueFPR (FR, fmt), fmt));
d4465 3
a4467 2
010011,5.FR,5.FT,5.FS,5.FD,111,3.FMT:COP1X:64,f::NMSUB.fmt
"nmsub.%s<FMT> f<FD>, f<FR>, f<FS>, f<FT>"
a4472 1
  int fmt = FMT;
d4474 1
a4474 4
  check_u64 (SD_, instruction_0);
  check_fmt_p (SD_, fmt, instruction_0);
  StoreFPR (FD, fmt, NegMultiplySub (ValueFPR (FS, fmt), ValueFPR (FT, fmt),
				     ValueFPR (FR, fmt), fmt));
d4478 4
a4481 2
010001,10,110,5.FT,5.FS,5.FD,101100:COP1:64,f::PLL.PS
"pll.ps f<FD>, f<FS>, f<FT>"
d4484 1
d4487 1
a4487 3
  check_u64 (SD_, instruction_0);
  StoreFPR (FD, fmt_ps, PackPS (PSLower (ValueFPR (FS, fmt_ps)),
				PSLower (ValueFPR (FT, fmt_ps))));
d4491 4
a4494 2
010001,10,110,5.FT,5.FS,5.FD,101101:COP1:64,f::PLU.PS
"plu.ps f<FD>, f<FS>, f<FT>"
d4497 1
d4500 1
a4500 3
  check_u64 (SD_, instruction_0);
  StoreFPR (FD, fmt_ps, PackPS (PSLower (ValueFPR (FS, fmt_ps)),
				PSUpper (ValueFPR (FT, fmt_ps))));
a4521 25

010001,10,110,5.FT,5.FS,5.FD,101110:COP1:64,f::PUL.PS
"pul.ps f<FD>, f<FS>, f<FT>"
*mipsV:
*mips64:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  StoreFPR (FD, fmt_ps, PackPS (PSUpper (ValueFPR (FS, fmt_ps)),
				PSLower (ValueFPR (FT, fmt_ps))));
}


010001,10,110,5.FT,5.FS,5.FD,101111:COP1:64,f::PUU.PS
"puu.ps f<FD>, f<FS>, f<FT>"
*mipsV:
*mips64:
{
  check_fpu (SD_);
  check_u64 (SD_, instruction_0);
  StoreFPR (FD, fmt_ps, PackPS (PSUpper (ValueFPR (FS, fmt_ps)),
				PSUpper (ValueFPR (FT, fmt_ps))));
}


d4532 1
a4532 1
  StoreFPR (FD, fmt, Recip (ValueFPR (FS, fmt), fmt));
d4549 1
a4549 2
  StoreFPR (FD, fmt_long, Convert (FP_RM_NEAREST, ValueFPR (FS, fmt), fmt,
	    fmt_long));
d4568 1
a4568 2
  StoreFPR (FD, fmt_word, Convert (FP_RM_NEAREST, ValueFPR (FS, fmt), fmt,
	    fmt_word));
a4572 1
"rsqrt.%s<FMT> f<FD>, f<FS>"
d4576 1
d4582 1
a4582 1
  StoreFPR (FD, fmt, RSquareRoot (ValueFPR (FS, fmt), fmt));
d4631 1
a4631 1
  StoreFPR (FD, fmt,  (SquareRoot (ValueFPR (FS, fmt), fmt)));
d4651 1
a4651 1
  StoreFPR (FD, fmt, Sub (ValueFPR (FS, fmt), ValueFPR (FT, fmt), fmt));
d4753 1
a4753 2
  StoreFPR (FD, fmt_long, Convert (FP_RM_TOZERO, ValueFPR (FS, fmt), fmt,
	    fmt_long));
d4772 1
a4772 2
  StoreFPR (FD, fmt_word, Convert (FP_RM_TOZERO, ValueFPR (FS, fmt), fmt,
	    fmt_word));
a5056 3
:include:::mdmx.igen
:include:::mips3d.igen
:include:::sb1.igen
@


1.37
log
@2002-02-24  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen: Fix formatting of calls to Unpredictable().
@
text
@d147 64
d407 2
d433 2
d448 2
d475 2
d633 2
d659 2
d841 2
d869 2
d1009 2
d1033 2
d2186 2
d2205 2
d2303 2
d2322 2
d2378 2
d2393 2
d2434 2
d2994 2
d3023 2
d3051 2
d3079 2
d3116 2
d3130 2
@


1.36
log
@2002-03-12  Chris Demetriou  <cgd@@broadcom.com>

        * configure.in (mipsisa32*-*-*, mipsisa64*-*-*): New targets.
        * mips.igen (mips32, mips64): New models, add to all instructions
        and functions as appropriate.
        (loadstore_ea, check_u64): New variant for model mips64.
        (check_fmt_p): New variant for models mipsV and mips64, remove
        mipsV model marking fro other variant.
        (SLL) Rename to...
        (SLLa) this.
        (CLO, CLZ, MADD, MADDU, MSUB, MSUBU, MUL, SLLb): New instructions
        for mips32 and mips64.
        (DCLO, DCLZ): New instructions for mips64.
@
text
@d928 1
a928 1
    Unpredictable();
d950 1
a950 1
    Unpredictable();
d1059 1
a1059 1
    Unpredictable();
d1082 1
a1082 1
    Unpredictable();
@


1.35
log
@2002-03-07  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (BREAK, LUI, ORI, SYSCALL, XORI): Print
        immediate or code as a hex value with the "%#lx" format.
        (ANDI): Likewise, and fix printed instruction name.
@
text
@d47 2
d122 1
d130 14
d187 2
d204 2
d258 2
d278 2
a307 1
  // On mips64, if UserMode check SR:PX & SR:UX bits.
d311 9
d325 1
a325 1
//        CPU Instruction Set (mipsI - mipsV)
d337 2
d361 2
d392 2
d417 2
d442 2
d460 2
d480 2
d503 2
d529 2
d553 2
d577 2
d605 2
d631 2
d654 2
d682 2
d707 2
d733 2
d757 2
d783 2
d809 2
d837 2
d860 2
d886 2
d920 44
d969 1
d990 1
d1018 1
d1040 1
d1050 46
d1131 1
d1171 1
d1214 2
d1253 2
d1334 1
d1362 1
d1390 1
d1404 1
d1428 1
d1449 1
d1463 1
d1488 1
d1509 1
d1523 1
d1550 1
d1564 1
d1591 1
d1607 2
d1627 2
d1648 2
d1667 2
d1794 2
d1811 2
d1826 1
d1841 2
d1858 1
d1872 1
d1888 2
d1905 2
d1921 2
d1963 1
d2000 2
d2019 2
d2036 2
d2053 2
d2070 2
d2085 1
d2094 34
d2143 2
d2169 2
d2184 2
d2198 2
d2208 34
d2249 2
d2268 2
d2280 15
d2316 2
d2355 2
d2386 2
d2410 2
d2435 2
d2449 2
d2564 2
d2580 2
d2623 1
d2661 1
d2676 2
d2690 1
d2704 1
d2720 2
d2738 1
a2738 1
000000,00000,5.RT,5.RD,5.SHIFT,000000:SPECIAL:32::SLL
d2756 13
d2786 2
d2810 2
d2834 2
d2858 2
d2883 2
d2908 2
d2935 2
d2961 2
d2987 2
d3004 2
d3034 2
d3051 2
d3068 2
d3085 2
d3102 2
d3119 2
d3136 2
d3152 2
d3168 2
d3184 2
d3200 2
d3216 2
d3232 2
d3248 2
d3264 2
d3280 2
d3296 2
d3312 2
d3328 2
d3352 2
d3376 2
d3469 2
d3485 1
a3485 1
*mipsV:
a3491 1
  /* XXX FIXME: not true for mipsV, but we don't support .ps insns yet.  */
d3495 13
d3521 2
d3539 2
d3560 2
d3611 2
d3688 2
d3706 1
d3723 2
d3767 2
d3823 2
d3845 1
d3871 2
d3895 2
d3919 2
d3970 1
d4007 1
d4025 2
d4044 2
d4059 1
d4076 2
d4091 1
d4108 1
d4122 1
d4161 2
d4184 2
d4203 2
d4219 2
d4238 2
d4261 2
d4278 1
d4291 1
d4309 2
d4329 2
d4347 1
d4360 1
d4373 1
d4386 1
d4398 1
d4416 1
d4431 1
d4449 2
d4465 1
d4482 2
d4497 1
d4512 2
d4532 2
d4553 2
d4594 1
d4635 1
d4653 2
d4680 2
d4701 2
d4714 2
d4726 2
d4737 2
d4771 1
d4783 1
d4797 1
d4807 2
d4834 2
d4852 2
d4884 2
d4901 2
d4914 2
d4927 2
d4940 2
@


1.34
log
@2002-03-05  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (check_fpu): Enable check for coprocessor 1 usability.
        * sim-main.h (COP_Usable): Define, but for now coprocessor 1
        is always enabled.
        (SignalExceptionCoProcessorUnusable): Take as argument the
        unusable coprocessor number.
@
text
@d411 1
a411 1
"and r<RT>, r<RS>, <IMMEDIATE>"
d803 1
a803 1
"break <CODE>"
d1778 1
a1778 1
"lui r<RT>, <IMMEDIATE>"
d2099 1
a2099 1
"ori r<RT>, r<RS>, <IMMEDIATE>"
d2739 1
a2739 1
"syscall <CODE>"
d2951 1
a2951 1
"xori r<RT>, r<RS>, <IMMEDIATE>"
@


1.33
log
@2002-03-05  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen: Fix formatting of all SignalException calls.
@
text
@a3089 1
#if 0	/* XXX FIXME: For now, never treat the FPU as disabled.  */
a3091 1
#endif
@


1.32
log
@2002-02-04  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen: Remove gencode comment from top of file, fix
        spelling in another comment.
@
text
@d828 1
a828 1
      SignalException(BreakPoint, instruction_0);
d835 1
a835 1
      SignalException(BreakPoint, instruction_0);
d2749 1
a2749 1
  SignalException(SystemCall, instruction_0);
d2763 1
a2763 1
    SignalException(Trap, instruction_0);
d2777 1
a2777 1
    SignalException(Trap, instruction_0);
d2791 1
a2791 1
    SignalException(Trap, instruction_0);
d2805 1
a2805 1
    SignalException(Trap, instruction_0);
d2819 1
a2819 1
    SignalException(Trap, instruction_0);
d2833 1
a2833 1
    SignalException(Trap, instruction_0);
d2847 1
a2847 1
    SignalException(Trap, instruction_0);
d2861 1
a2861 1
    SignalException(Trap, instruction_0);
d2875 1
a2875 1
    SignalException(Trap, instruction_0);
d2889 1
a2889 1
    SignalException(Trap, instruction_0);
d2903 1
a2903 1
    SignalException(Trap, instruction_0);
d2917 1
a2917 1
    SignalException(Trap, instruction_0);
d3383 1
a3383 1
      SignalException(ReservedInstruction,instruction_0);
d3403 1
a3403 1
      SignalException(ReservedInstruction,instruction_0);
d3428 1
a3428 1
      SignalException(ReservedInstruction,instruction_0);
d3450 1
a3450 1
      SignalException(ReservedInstruction,instruction_0);
@


1.31
log
@2002-02-04  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (check_fmt, check_fmt_p): New functions to check
        whether specific floating point formats are usable.
        (ABS.fmt, ADD.fmt, CEIL.L.fmt, CEIL.W, DIV.fmt, FLOOR.L.fmt)
        (FLOOR.W.fmt, MOV.fmt, MUL.fmt, NEG.fmt, RECIP.fmt, ROUND.L.fmt)
        (ROUND.W.fmt, RSQRT.fmt, SQRT.fmt, SUB.fmt, TRUNC.L.fmt, TRUNC.W):
        Use the new functions.
        (do_c_cond_fmt): Remove format checks...
        (C.cond.fmta, C.cond.fmtb): And move them into all callers.
@
text
@a2 4
// In mips.igen, the semantics for many of the instructions were created
// using code generated by gencode.  Those semantic segments could be
// greatly simplified.
//
d273 1
a273 1
// an ReservedInstruction exception if not.
@


1.30
log
@2002-02-03  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen: Fix formatting of check_fpu calls.
@
text
@d3038 40
d3114 2
a3115 6
  {
    if ((fmt != fmt_single) && (fmt != fmt_double))
      SignalException(ReservedInstruction,instruction_0);
    else
      StoreFPR(FD,fmt,AbsoluteValue(ValueFPR(FS,fmt),fmt));
  }
d3133 2
a3134 6
  {
    if ((fmt != fmt_single) && (fmt != fmt_double))
      SignalException(ReservedInstruction, instruction_0);
    else
      StoreFPR(FD,fmt,Add(ValueFPR(FS,fmt),ValueFPR(FT,fmt),fmt));
  }
d3205 7
a3211 3
  if ((fmt != fmt_single) && (fmt != fmt_double))
    SignalException (ReservedInstruction, insn);
  else
d3213 1
a3213 7
      int less;
      int equal;
      int unordered;
      int condition;
      unsigned64 ofs = ValueFPR (fs, fmt);
      unsigned64 oft = ValueFPR (ft, fmt);
      if (NaN (ofs, fmt) || NaN (oft, fmt))
d3215 2
a3216 8
	  if (FCSR & FP_ENABLE (IO))
	    {
	      FCSR |= FP_CAUSE (IO);
	      SignalExceptionFPE ();
	    }
	  less = 0;
	  equal = 0;
	  unordered = 1;
d3218 9
a3226 10
      else
	{
	  less = Less (ofs, oft, fmt);
	  equal = Equal (ofs, oft, fmt);
	  unordered = 0;
	}
      condition = (((cond & (1 << 2)) && less)
		   || ((cond & (1 << 1)) && equal)
		   || ((cond & (1 << 0)) && unordered));
      SETFCC (cc, condition);
d3228 4
d3240 1
d3242 2
a3243 1
  do_c_cond_fmt (SD_, FMT, FT, FS, 0, COND, instruction_0);
d3255 1
d3257 2
a3258 1
  do_c_cond_fmt (SD_, FMT, FT, FS, CC, COND, instruction_0);
d3273 2
a3274 6
  {
    if ((fmt != fmt_single) && (fmt != fmt_double))
      SignalException(ReservedInstruction,instruction_0);
    else
      StoreFPR(FD,fmt_long,Convert(FP_RM_TOPINF,ValueFPR(FS,fmt),fmt,fmt_long));
  }
d3289 2
a3290 6
  {
  if ((fmt != fmt_single) && (fmt != fmt_double))
   SignalException(ReservedInstruction,instruction_0);
  else
   StoreFPR(FD,fmt_word,Convert(FP_RM_TOPINF,ValueFPR(FS,fmt),fmt,fmt_word));
  }
d3474 2
a3475 6
  {
    if ((fmt != fmt_single) && (fmt != fmt_double))
      SignalException(ReservedInstruction,instruction_0);
    else
      StoreFPR(FD,fmt,Divide(ValueFPR(FS,fmt),ValueFPR(FT,fmt),fmt));
  }
d3559 2
a3560 6
  {
    if ((fmt != fmt_single) && (fmt != fmt_double))
      SignalException(ReservedInstruction,instruction_0);
    else
      StoreFPR(FD,fmt_long,Convert(FP_RM_TOMINF,ValueFPR(FS,fmt),fmt,fmt_long));
  }
d3576 2
a3577 6
  {
    if ((fmt != fmt_single) && (fmt != fmt_double))
      SignalException(ReservedInstruction,instruction_0);
    else
      StoreFPR(FD,fmt_word,Convert(FP_RM_TOMINF,ValueFPR(FS,fmt),fmt,fmt_word));
  }
d3723 1
d3836 2
a3837 6
  {
    if ((fmt != fmt_single) && (fmt != fmt_double))
      SignalException(ReservedInstruction,instruction_0);
    else
      StoreFPR(FD,fmt,Multiply(ValueFPR(FS,fmt),ValueFPR(FT,fmt),fmt));
  }
d3854 2
a3855 6
  {
    if ((fmt != fmt_single) && (fmt != fmt_double))
      SignalException(ReservedInstruction,instruction_0);
    else
      StoreFPR(FD,fmt,Negate(ValueFPR(FS,fmt),fmt));
  }
d3932 2
a3933 6
  {
  if ((fmt != fmt_single) && (fmt != fmt_double))
   SignalException(ReservedInstruction,instruction_0);
  else
   StoreFPR(FD,fmt,Recip(ValueFPR(FS,fmt),fmt));
  }
d3948 2
a3949 6
  {
    if ((fmt != fmt_single) && (fmt != fmt_double))
      SignalException(ReservedInstruction,instruction_0);
    else
      StoreFPR(FD,fmt_long,Convert(FP_RM_NEAREST,ValueFPR(FS,fmt),fmt,fmt_long));
  }
d3965 2
a3966 6
  {
  if ((fmt != fmt_single) && (fmt != fmt_double))
   SignalException(ReservedInstruction,instruction_0);
  else
   StoreFPR(FD,fmt_word,Convert(FP_RM_NEAREST,ValueFPR(FS,fmt),fmt,fmt_word));
  }
d3978 2
a3979 6
  {
  if ((fmt != fmt_single) && (fmt != fmt_double))
   SignalException(ReservedInstruction,instruction_0);
  else
   StoreFPR(FD,fmt,Recip(SquareRoot(ValueFPR(FS,fmt),fmt),fmt));
  }
d4022 2
a4023 6
  {
    if ((fmt != fmt_single) && (fmt != fmt_double))
      SignalException(ReservedInstruction,instruction_0);
    else
      StoreFPR(FD,fmt,(SquareRoot(ValueFPR(FS,fmt),fmt)));
  }
d4040 2
a4041 6
  {
    if ((fmt != fmt_single) && (fmt != fmt_double))
      SignalException(ReservedInstruction,instruction_0);
    else
      StoreFPR(FD,fmt,Sub(ValueFPR(FS,fmt),ValueFPR(FT,fmt),fmt));
  }
d4138 2
a4139 6
  {
  if ((fmt != fmt_single) && (fmt != fmt_double))
   SignalException(ReservedInstruction,instruction_0);
  else
   StoreFPR(FD,fmt_long,Convert(FP_RM_TOZERO,ValueFPR(FS,fmt),fmt,fmt_long));
  }
d4155 2
a4156 6
  {
  if ((fmt != fmt_single) && (fmt != fmt_double))
   SignalException(ReservedInstruction,instruction_0);
  else
   StoreFPR(FD,fmt_word,Convert(FP_RM_TOZERO,ValueFPR(FS,fmt),fmt,fmt_word));
  }
@


1.29
log
@2002-03-03  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (FLOOR.L.fmt): Store correct destination register.
@
text
@d3073 1
a3073 1
  check_fpu(SD_);
d3096 1
a3096 1
  check_fpu(SD_);
d3118 1
a3118 1
  check_fpu(SD_);
d3148 1
a3148 1
  check_fpu(SD_);
d3213 1
a3213 1
  check_fpu(SD_);
d3226 1
a3226 1
  check_fpu(SD_);
d3241 1
a3241 1
  check_fpu(SD_);
d3261 1
a3261 1
  check_fpu(SD_);
d3279 1
a3279 1
  check_fpu(SD_);
d3306 1
a3306 1
  check_fpu(SD_);
d3361 1
a3361 1
  check_fpu(SD_);
d3381 1
a3381 1
  check_fpu(SD_);
d3406 1
a3406 1
  check_fpu(SD_);
d3428 1
a3428 1
  check_fpu(SD_);
d3450 1
a3450 1
  check_fpu(SD_);
d3466 1
a3466 1
  check_fpu(SD_);
d3502 1
a3502 1
  check_fpu(SD_);
d3539 1
a3539 1
  check_fpu(SD_);
d3560 1
a3560 1
  check_fpu(SD_);
d3580 1
a3580 1
  check_fpu(SD_);
d3591 1
a3591 1
  check_fpu(SD_);
d3609 1
a3609 1
  check_fpu(SD_);
d3620 1
a3620 1
  check_fpu(SD_);
d3636 1
a3636 1
  check_fpu(SD_);
d3649 1
a3649 1
  check_fpu(SD_);
d3664 1
a3664 1
  check_fpu(SD_);
d3690 1
a3690 1
  check_fpu(SD_);
d3711 1
a3711 1
  check_fpu(SD_);
d3724 1
a3724 1
  check_fpu(SD_);
d3739 1
a3739 1
  check_fpu(SD_);
d3755 1
a3755 1
  check_fpu(SD_);
d3776 1
a3776 1
  check_fpu(SD_);
d3791 1
a3791 1
  check_fpu(SD_);
d3803 1
a3803 1
  check_fpu(SD_);
d3823 1
a3823 1
  check_fpu(SD_);
d3845 1
a3845 1
  check_fpu(SD_);
d3862 1
a3862 1
  check_fpu(SD_);
d3874 1
a3874 1
  check_fpu(SD_);
d3886 1
a3886 1
  check_fpu(SD_);
d3898 1
a3898 1
  check_fpu(SD_);
d3927 1
a3927 1
  check_fpu(SD_);
d3947 1
a3947 1
  check_fpu(SD_);
d3968 1
a3968 1
  check_fpu(SD_);
d3985 1
a3985 1
  check_fpu(SD_);
d4005 1
a4005 1
  check_fpu(SD_);
d4016 1
a4016 1
  check_fpu(SD_);
d4033 1
a4033 1
  check_fpu(SD_);
d4055 1
a4055 1
  check_fpu(SD_);
d4079 1
a4079 1
  check_fpu(SD_);
d4117 1
a4117 1
  check_fpu(SD_);
d4157 1
a4157 1
  check_fpu(SD_);
d4178 1
a4178 1
  check_fpu(SD_);
@


1.28
log
@2002-03-03  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen: Remove whitespace at end of lines.
@
text
@d3544 1
a3544 1
      StoreFPR(FS,fmt_long,Convert(FP_RM_TOMINF,ValueFPR(FS,fmt),fmt,fmt_long));
@


1.27
log
@2002-03-02  Chris Demetriou  <cgd@@broadcom.com>

	* mips.igen (loadstore_ea): New function to do effective
	address calculations.
	(do_load, do_load_left, do_load_right, LL, LDD, PREF, do_store,
	do_store_left, do_store_right, SC, SCD, PREFX, SWC1, SWXC1,
	CACHE): Use loadstore_ea to do effective address computations.
@
text
@d133 1
a133 1
// 
d151 1
a151 1
			(long) history->mf.cia);      
d209 1
a209 1
			(long) peer->mt.cia);      
d275 1
a275 1
// 
d837 1
a837 1
      /* If we get this far, we're not an instruction reserved by the sim.  Raise 
d1103 1
a1103 1
  /* make signed multiply unsigned */ 
d3039 1
a3039 1
// 
d3045 1
a3045 1
*mipsI: 
d3487 1
a3487 1
	    sim_io_eprintf (SD, 
d3520 1
a3520 1
	    sim_io_eprintf (SD, 
d3598 1
a3598 1
110001,5.BASE,5.FT,16.OFFSET:COP1:32,f::LWC1 
d3670 1
a3670 1
	    sim_io_eprintf (SD, 
@


1.26
log
@2002-03-02  Chris Demetriou  <cgd@@broadcom.com>

	* interp.c (load_word): Use EXTEND32 rather than SIGNEXTEND.
	* mips.igen (LL, CxC1, MxC1): Likewise.
@
text
@d112 20
d1492 1
a1492 1
  vaddr = base + offset;
d1520 1
a1520 1
  vaddr = base + offset;
d1571 1
a1571 1
  vaddr = base + offset;
d1718 1
a1718 1
    address_word vaddr = ((unsigned64)base + offset);
d1759 1
a1759 1
    address_word vaddr = ((unsigned64)base + offset);
d2126 1
a2126 1
    address_word vaddr = ((unsigned64)base + offset);
d2148 1
a2148 1
  vaddr = base + offset;
d2174 1
a2174 1
  vaddr = base + offset;
d2216 1
a2216 1
  vaddr = base + offset;
d2255 1
a2255 1
    address_word vaddr = ((unsigned64)base + offset);
d2296 1
a2296 1
    address_word vaddr = ((unsigned64)base + offset);
d3912 1
a3912 1
    address_word vaddr = ((unsigned64)base + (unsigned64)index);
d4077 2
a4078 1
  signed_word offset = EXTEND16 (OFFSET);
d4081 1
a4081 1
    address_word vaddr = ((uword64)GPR[BASE] + offset);
d4120 1
a4120 1
   address_word vaddr = ((unsigned64)base + index);
d4258 1
a4258 1
    address_word vaddr = (base + offset);
@


1.25
log
@2002-03-02  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (LL, LLD, PREF, SC, SCD, ABS.fmt, ADD.fmt, CEIL.L.fmt,
        CEIL.W, CVT.D.fmt, CVT.L.fmt, CVT.S.fmt, CVT.W.fmt, DIV.fmt,
        FLOOR.L.fmt, FLOOR.W.fmt, MADD.D, MADD.S, MOV.fmt, MOVtf.fmt,
        MSUB.D, MSUB.S, MUL.fmt, NEG.fmt, NMADD.D, NMADD.S, NMSUB.D,
        NMSUB.S, PREFX, RECIP.fmt, ROUND.L.fmt, ROUND.W.fmt, RSQRT.fmt,
        SQRT.fmt, SUB.fmt, SWC1, SWXC1, TRUNC.L.fmt, TRUNC.W, CACHE):
        Don't split opcode fields by hand, use the opcode field values
        provided by igen.
@
text
@d1719 1
a1719 1
	    GPR[RT] = (SIGNEXTEND(((memval >> (8 * byte)) & 0xFFFFFFFF),32));
d3272 1
a3272 1
 	PENDING_FILL(RT,SIGNEXTEND(FCR0,32));
d3274 1
a3274 1
 	PENDING_FILL(RT,SIGNEXTEND(FCR31,32));
d3313 1
a3313 1
	  GPR[RT] = SIGNEXTEND (FCR0, 32);
d3318 1
a3318 1
	  GPR[RT] = SIGNEXTEND (FCR31, 32);
d3659 1
a3659 1
    PENDING_FILL (RT, SIGNEXTEND(FGR[FS],32));
d3675 1
a3675 1
    GPR[RT] = SIGNEXTEND(FGR[FS],32);
@


1.24
log
@2002-03-01  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (do_divu): Fix spacing.

        * mips.igen (do_dsllv): Move to be right before DSLLV,
        to match the rest of the do_<shift> functions.
@
text
@d1695 2
a1696 4
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  int destreg = ((instruction >> 16) & 0x0000001F);
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
d1698 1
a1698 1
    address_word vaddr = ((unsigned64)op1 + offset);
d1719 1
a1719 1
	    GPR[destreg] = (SIGNEXTEND(((memval >> (8 * byte)) & 0xFFFFFFFF),32));
d1735 2
a1736 4
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  int destreg = ((instruction >> 16) & 0x0000001F);
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
d1739 1
a1739 1
    address_word vaddr = ((unsigned64)op1 + offset);
d1753 1
a1753 1
	    GPR[destreg] = memval;
d2103 2
a2104 4
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  int hint = ((instruction >> 16) & 0x0000001F);
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
d2106 1
a2106 1
    address_word vaddr = ((unsigned64)op1 + offset);
d2111 1
a2111 1
	Prefetch(uncached,paddr,vaddr,isDATA,hint);
d2232 2
a2233 3
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  signed_word op2 = GPR[((instruction >> 16) & 0x0000001F)];
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
d2235 1
a2235 1
    address_word vaddr = ((unsigned64)op1 + offset);
d2252 1
a2252 1
	    memval = ((unsigned64) op2 << (8 * byte));
d2257 1
a2257 1
	    GPR[(instruction >> 16) & 0x0000001F] = LLBIT;
d2272 2
a2273 4
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  signed_word op2 = GPR[((instruction >> 16) & 0x0000001F)];
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
d2276 1
a2276 1
    address_word vaddr = ((unsigned64)op1 + offset);
d2289 1
a2289 1
	    memval = op2;
d2294 1
a2294 1
	    GPR[(instruction >> 16) & 0x0000001F] = LLBIT;
d3052 1
a3052 4
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
d3055 2
a3056 2
    if ((format != fmt_single) && (format != fmt_double))
      SignalException(ReservedInstruction,instruction);
d3058 1
a3058 1
      StoreFPR(destreg,format,AbsoluteValue(ValueFPR(fs,format),format));
d3075 1
a3075 5
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int ft = ((instruction >> 16) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
d3078 2
a3079 2
    if ((format != fmt_single) && (format != fmt_double))
      SignalException(ReservedInstruction, instruction);
d3081 1
a3081 1
      StoreFPR(destreg,format,Add(ValueFPR(fs,format),ValueFPR(ft,format),format));
d3220 1
a3220 4
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
d3223 2
a3224 2
    if ((format != fmt_single) && (format != fmt_double))
      SignalException(ReservedInstruction,instruction);
d3226 1
a3226 1
      StoreFPR(destreg,fmt_long,Convert(FP_RM_TOPINF,ValueFPR(fs,format),format,fmt_long));
d3240 1
a3240 4
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
d3243 2
a3244 2
  if ((format != fmt_single) && (format != fmt_double))
   SignalException(ReservedInstruction,instruction);
d3246 1
a3246 1
   StoreFPR(destreg,fmt_word,Convert(FP_RM_TOPINF,ValueFPR(fs,format),format,fmt_word));
d3340 1
a3340 4
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
d3343 2
a3344 2
    if ((format == fmt_double) | 0)
      SignalException(ReservedInstruction,instruction);
d3346 1
a3346 1
      StoreFPR(destreg,fmt_double,Convert(GETRM(),ValueFPR(fs,format),format,fmt_double));
d3360 1
a3360 4
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
d3363 2
a3364 2
    if ((format == fmt_long) | ((format == fmt_long) || (format == fmt_word)))
      SignalException(ReservedInstruction,instruction);
d3366 1
a3366 1
      StoreFPR(destreg,fmt_long,Convert(GETRM(),ValueFPR(fs,format),format,fmt_long));
d3385 1
a3385 4
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
d3388 2
a3389 2
    if ((format == fmt_single) | 0)
      SignalException(ReservedInstruction,instruction);
d3391 1
a3391 1
      StoreFPR(destreg,fmt_single,Convert(GETRM(),ValueFPR(fs,format),format,fmt_single));
d3407 1
a3407 4
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
d3410 2
a3411 2
    if ((format == fmt_word) | ((format == fmt_long) || (format == fmt_word)))
      SignalException(ReservedInstruction,instruction);
d3413 1
a3413 1
      StoreFPR(destreg,fmt_word,Convert(GETRM(),ValueFPR(fs,format),format,fmt_word));
d3429 1
a3429 5
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int ft = ((instruction >> 16) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
d3432 2
a3433 2
    if ((format != fmt_single) && (format != fmt_double))
      SignalException(ReservedInstruction,instruction);
d3435 1
a3435 1
      StoreFPR(destreg,format,Divide(ValueFPR(fs,format),ValueFPR(ft,format),format));
d3518 1
a3518 4
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
d3521 2
a3522 2
    if ((format != fmt_single) && (format != fmt_double))
      SignalException(ReservedInstruction,instruction);
d3524 1
a3524 1
      StoreFPR(destreg,fmt_long,Convert(FP_RM_TOMINF,ValueFPR(fs,format),format,fmt_long));
d3539 1
a3539 4
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
d3542 2
a3543 2
    if ((format != fmt_single) && (format != fmt_double))
      SignalException(ReservedInstruction,instruction);
d3545 1
a3545 1
      StoreFPR(destreg,fmt_word,Convert(FP_RM_TOMINF,ValueFPR(fs,format),format,fmt_word));
a3615 5
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int ft = ((instruction >> 16) & 0x0000001F);
  int fr = ((instruction >> 21) & 0x0000001F);
d3618 1
a3618 1
    StoreFPR(destreg,fmt_double,Add(Multiply(ValueFPR(fs,fmt_double),ValueFPR(ft,fmt_double),fmt_double),ValueFPR(fr,fmt_double),fmt_double));
a3628 5
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int ft = ((instruction >> 16) & 0x0000001F);
  int fr = ((instruction >> 21) & 0x0000001F);
d3631 1
a3631 1
    StoreFPR(destreg,fmt_single,Add(Multiply(ValueFPR(fs,fmt_single),ValueFPR(ft,fmt_single),fmt_single),ValueFPR(fr,fmt_single),fmt_single));
d3690 1
a3690 4
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
d3692 1
a3692 3
  {
    StoreFPR(destreg,format,ValueFPR(fs,format));
  }
d3718 1
a3718 2
  unsigned32 instruction = instruction_0;
  int format = ((instruction >> 21) & 0x00000007);
d3722 1
a3722 1
     StoreFPR (FD, format, ValueFPR (FS, format));
d3724 1
a3724 1
     StoreFPR (FD, format, ValueFPR (FD, format));
a3770 5
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int ft = ((instruction >> 16) & 0x0000001F);
  int fr = ((instruction >> 21) & 0x0000001F);
d3772 1
a3772 3
  {
    StoreFPR(destreg,fmt_double,Sub(Multiply(ValueFPR(fs,fmt_double),ValueFPR(ft,fmt_double),fmt_double),ValueFPR(fr,fmt_double),fmt_double));
  }
a3782 5
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int ft = ((instruction >> 16) & 0x0000001F);
  int fr = ((instruction >> 21) & 0x0000001F);
d3784 1
a3784 3
  {
   StoreFPR(destreg,fmt_single,Sub(Multiply(ValueFPR(fs,fmt_single),ValueFPR(ft,fmt_single),fmt_single),ValueFPR(fr,fmt_single),fmt_single));
  }
d3802 1
a3802 5
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int ft = ((instruction >> 16) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
d3805 2
a3806 2
    if ((format != fmt_single) && (format != fmt_double))
      SignalException(ReservedInstruction,instruction);
d3808 1
a3808 1
      StoreFPR(destreg,format,Multiply(ValueFPR(fs,format),ValueFPR(ft,format),format));
d3824 1
a3824 4
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
d3827 2
a3828 2
    if ((format != fmt_single) && (format != fmt_double))
      SignalException(ReservedInstruction,instruction);
d3830 1
a3830 1
      StoreFPR(destreg,format,Negate(ValueFPR(fs,format),format));
a3841 5
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int ft = ((instruction >> 16) & 0x0000001F);
  int fr = ((instruction >> 21) & 0x0000001F);
d3843 1
a3843 3
  {
   StoreFPR(destreg,fmt_double,Negate(Add(Multiply(ValueFPR(fs,fmt_double),ValueFPR(ft,fmt_double),fmt_double),ValueFPR(fr,fmt_double),fmt_double),fmt_double));
  }
a3853 5
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int ft = ((instruction >> 16) & 0x0000001F);
  int fr = ((instruction >> 21) & 0x0000001F);
d3855 1
a3855 3
  {
   StoreFPR(destreg,fmt_single,Negate(Add(Multiply(ValueFPR(fs,fmt_single),ValueFPR(ft,fmt_single),fmt_single),ValueFPR(fr,fmt_single),fmt_single),fmt_single));
  }
a3865 5
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int ft = ((instruction >> 16) & 0x0000001F);
  int fr = ((instruction >> 21) & 0x0000001F);
d3867 1
a3867 3
  {
   StoreFPR(destreg,fmt_double,Negate(Sub(Multiply(ValueFPR(fs,fmt_double),ValueFPR(ft,fmt_double),fmt_double),ValueFPR(fr,fmt_double),fmt_double),fmt_double));
  }
a3877 5
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int ft = ((instruction >> 16) & 0x0000001F);
  int fr = ((instruction >> 21) & 0x0000001F);
d3879 1
a3879 3
  {
    StoreFPR(destreg,fmt_single,Negate(Sub(Multiply(ValueFPR(fs,fmt_single),ValueFPR(ft,fmt_single),fmt_single),ValueFPR(fr,fmt_single),fmt_single),fmt_single));
  }
d3889 2
a3890 4
  unsigned32 instruction = instruction_0;
  int fs = ((instruction >> 11) & 0x0000001F);
  signed_word op2 = GPR[((instruction >> 16) & 0x0000001F)];
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
d3892 1
a3892 1
    address_word vaddr = ((unsigned64)op1 + (unsigned64)op2);
d3896 1
a3896 1
      Prefetch(uncached,paddr,vaddr,isDATA,fs);
d3906 1
a3906 4
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
d3909 2
a3910 2
  if ((format != fmt_single) && (format != fmt_double))
   SignalException(ReservedInstruction,instruction);
d3912 1
a3912 1
   StoreFPR(destreg,format,Recip(ValueFPR(fs,format),format));
d3926 1
a3926 4
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
d3929 2
a3930 2
    if ((format != fmt_single) && (format != fmt_double))
      SignalException(ReservedInstruction,instruction);
d3932 1
a3932 1
      StoreFPR(destreg,fmt_long,Convert(FP_RM_NEAREST,ValueFPR(fs,format),format,fmt_long));
d3947 1
a3947 4
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
d3950 2
a3951 2
  if ((format != fmt_single) && (format != fmt_double))
   SignalException(ReservedInstruction,instruction);
d3953 1
a3953 1
   StoreFPR(destreg,fmt_word,Convert(FP_RM_NEAREST,ValueFPR(fs,format),format,fmt_word));
d3964 1
a3964 4
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
d3967 2
a3968 2
  if ((format != fmt_single) && (format != fmt_double))
   SignalException(ReservedInstruction,instruction);
d3970 1
a3970 1
   StoreFPR(destreg,format,Recip(SquareRoot(ValueFPR(fs,format),format),format));
d4012 1
a4012 4
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
d4015 2
a4016 2
    if ((format != fmt_single) && (format != fmt_double))
      SignalException(ReservedInstruction,instruction);
d4018 1
a4018 1
      StoreFPR(destreg,format,(SquareRoot(ValueFPR(fs,format),format)));
d4034 1
a4034 5
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int ft = ((instruction >> 16) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
d4037 2
a4038 2
    if ((format != fmt_single) && (format != fmt_double))
      SignalException(ReservedInstruction,instruction);
d4040 1
a4040 1
      StoreFPR(destreg,format,Sub(ValueFPR(fs,format),ValueFPR(ft,format),format));
a4056 1
  unsigned32 instruction = instruction_0;
a4057 2
  int destreg UNUSED = ((instruction >> 16) & 0x0000001F);
  signed_word op1 UNUSED = GPR[((instruction >> 21) & 0x0000001F)];
d4060 1
a4060 1
    address_word vaddr = ((uword64)op1 + offset);
d4079 1
a4079 1
	    memval = (((uword64)COP_SW(((instruction >> 26) & 0x3),destreg)) << (8 * byte));
d4093 3
a4095 4
  unsigned32 instruction = instruction_0;
  int fs = ((instruction >> 11) & 0x0000001F);
  signed_word op2 = GPR[((instruction >> 16) & 0x0000001F)];
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
d4099 1
a4099 1
   address_word vaddr = ((unsigned64)op1 + op2);
d4116 1
a4116 1
     memval = (((unsigned64)COP_SW(1,fs)) << (8 * byte));
d4135 1
a4135 4
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
d4138 2
a4139 2
  if ((format != fmt_single) && (format != fmt_double))
   SignalException(ReservedInstruction,instruction);
d4141 1
a4141 1
   StoreFPR(destreg,fmt_long,Convert(FP_RM_TOZERO,ValueFPR(fs,format),format,fmt_long));
d4156 1
a4156 4
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
d4159 2
a4160 2
  if ((format != fmt_single) && (format != fmt_double))
   SignalException(ReservedInstruction,instruction);
d4162 1
a4162 1
   StoreFPR(destreg,fmt_word,Convert(FP_RM_TOZERO,ValueFPR(fs,format),format,fmt_word));
d4234 2
a4235 4
  unsigned32 instruction = instruction_0;
  signed_word offset = SIGNEXTEND((signed_word)((instruction >> 0) & 0x0000FFFF),16);
  int hint = ((instruction >> 16) & 0x0000001F);
  signed_word op1 = GPR[((instruction >> 21) & 0x0000001F)];
d4237 1
a4237 1
    address_word vaddr = (op1 + offset);
d4241 1
a4241 1
      CacheOp(hint,vaddr,paddr,instruction);
@


1.23
log
@2002-03-01  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (do_dsll, do_dsllv, DSLL32, do_dsra, DSRA32, do_dsrl,
        DSRL32, do_dsrlv): Trace inputs and results.
@
text
@d1044 5
a1048 5
   else
     {
       LO = EXTEND32 (n / d);
       HI = EXTEND32 (n % d);
     }
a1187 9
:function:::void:do_dsllv:int rs, int rt, int rd
{
  int s = MASKED64 (GPR[rs], 5, 0);
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = GPR[rt] << s;
  TRACE_ALU_RESULT (GPR[rd]);
}


d1214 8
@


1.22
log
@2002-03-01  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (CACHE): Provide instruction-printing string.

        * interp.c (signal_exception): Comment tokens after #endif.
@
text
@d1183 1
d1185 1
d1191 1
d1193 1
d1220 1
d1222 1
d1239 1
d1241 1
d1268 1
d1270 1
d1296 1
d1298 1
d1325 1
d1327 1
d1334 1
d1336 1
@


1.21
log
@2002-02-28  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (LWXC1): Mark with filter "64,f", rather than just "32".
        (MOVtf, MxC1, MxC1, DMxC1, DMxC1, CxC1, CxC1, SQRT.fmt, MOV.fmt,
        NEG.fmt, ROUND.L.fmt, TRUNC.L.fmt, CEIL.L.fmt, FLOOR.L.fmt,
        ROUND.W.fmt, TRUNC.W, CEIL.W, FLOOR.W.fmt, RECIP.fmt, RSQRT.fmt,
        CVT.S.fmt, CVT.D.fmt, CVT.W.fmt, CVT.L.fmt, MOVtf.fmt, C.cond.fmta,
        C.cond.fmtb, SUB.fmt, MUL.fmt, DIV.fmt, MOVZ.fmt, MOVN.fmt, LDXC1,
        SWXC1, SDXC1, MSUB.D, MSUB.S, NMADD.S, NMADD.D, NMSUB.S, NMSUB.D,
        LWC1, SWC1): Add "f" to filter, since these are FP instructions.
@
text
@d4351 1
@


1.20
log
@2002-02-28  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (DSRA32, DSRAV): Fix order of arguments in
        instruction-printing string.
        (LWU): Use '64' as the filter flag.
@
text
@d3188 1
a3188 1
010001,10,3.FMT,5.FT,5.FS,3.0,00,11,4.COND:COP1:32::C.cond.fmta
d3198 1
a3198 1
010001,10,3.FMT,5.FT,5.FS,3.CC,00,11,4.COND:COP1:32::C.cond.fmtb
d3212 1
a3212 1
010001,10,3.FMT,00000,5.FS,5.FD,001010:COP1:64::CEIL.L.fmt
d3235 1
a3235 1
010001,10,3.FMT,00000,5.FS,5.FD,001110:COP1:32::CEIL.W
d3260 1
a3260 1
010001,00,X,10,5.RT,5.FS,00000000000:COP1Sa:32::CxC1
d3285 1
a3285 1
010001,00,X,10,5.RT,5.FS,00000000000:COP1Sb:32::CxC1
d3336 1
a3336 1
010001,10,3.FMT,00000,5.FS,5.FD,100001:COP1:32::CVT.D.fmt
d3361 1
a3361 1
010001,10,3.FMT,00000,5.FS,5.FD,100101:COP1:64::CVT.L.fmt
d3387 1
a3387 1
010001,10,3.FMT,00000,5.FS,5.FD,100000:COP1:32::CVT.S.fmt
d3412 1
a3412 1
010001,10,3.FMT,00000,5.FS,5.FD,100100:COP1:32::CVT.W.fmt
d3437 1
a3437 1
010001,10,3.FMT,5.FT,5.FS,5.FD,000011:COP1:32::DIV.fmt
d3465 1
a3465 1
010001,00,X,01,5.RT,5.FS,00000000000:COP1Sa:64::DMxC1
d3497 1
a3497 1
010001,00,X,01,5.RT,5.FS,00000000000:COP1Sb:64::DMxC1
d3532 1
a3532 1
010001,10,3.FMT,00000,5.FS,5.FD,001011:COP1:64::FLOOR.L.fmt
d3555 1
a3555 1
010001,10,3.FMT,00000,5.FS,5.FD,001111:COP1:32::FLOOR.W.fmt
d3594 1
a3594 1
010011,5.BASE,5.INDEX,5.0,5.FD,000001:COP1X:64::LDXC1
d3607 1
a3607 1
110001,5.BASE,5.FT,16.OFFSET:COP1:32::LWC1 
d3623 1
a3623 1
010011,5.BASE,5.INDEX,5.0,5.FD,000000:COP1X:32::LWXC1
d3677 1
a3677 1
010001,00,X,00,5.RT,5.FS,00000000000:COP1Sa:32::MxC1
d3700 1
a3700 1
010001,00,X,00,5.RT,5.FS,00000000000:COP1Sb:32::MxC1
d3718 1
a3718 1
010001,10,3.FMT,00000,5.FS,5.FD,000110:COP1:32::MOV.fmt
d3742 1
a3742 1
000000,5.RS,3.CC,0,1.TF,5.RD,00000,000001:SPECIAL:32::MOVtf
d3756 1
a3756 1
010001,10,3.FMT,3.CC,0,1.TF,5.FS,5.FD,010001:COP1:32::MOVtf.fmt
d3774 1
a3774 1
010001,10,3.FMT,5.RT,5.FS,5.FD,010011:COP1:32::MOVN.fmt
d3795 1
a3795 1
010001,10,3.FMT,5.RT,5.FS,5.FD,010010:COP1:32::MOVZ.fmt
d3810 1
a3810 1
010011,5.FR,5.FT,5.FS,5.FD,101,001:COP1X:32::MSUB.D
d3829 1
a3829 1
010011,5.FR,5.FT,5.FS,5.FD,101000:COP1X:32::MSUB.S
d3850 1
a3850 1
010001,10,3.FMT,5.FT,5.FS,5.FD,000010:COP1:32::MUL.fmt
d3876 1
a3876 1
010001,10,3.FMT,00000,5.FS,5.FD,000111:COP1:32::NEG.fmt
d3902 1
a3902 1
010011,5.FR,5.FT,5.FS,5.FD,110001:COP1X:32::NMADD.D
d3921 1
a3921 1
010011,5.FR,5.FT,5.FS,5.FD,110000:COP1X:32::NMADD.S
d3940 1
a3940 1
010011,5.FR,5.FT,5.FS,5.FD,111001:COP1X:32::NMSUB.D
d3959 1
a3959 1
010011,5.FR,5.FT,5.FS,5.FD,111000:COP1X:32::NMSUB.S
d3996 1
a3996 1
010001,10,3.FMT,00000,5.FS,5.FD,010101:COP1:32::RECIP.fmt
d4016 1
a4016 1
010001,10,3.FMT,00000,5.FS,5.FD,001000:COP1:64::ROUND.L.fmt
d4039 1
a4039 1
010001,10,3.FMT,00000,5.FS,5.FD,001100:COP1:32::ROUND.W.fmt
d4063 1
a4063 1
010001,10,3.FMT,00000,5.FS,5.FD,010110:COP1:32::RSQRT.fmt
d4098 1
a4098 1
010011,5.BASE,5.INDEX,5.FS,00000001001:COP1X:64::SDXC1
d4110 1
a4110 1
010001,10,3.FMT,00000,5.FS,5.FD,000100:COP1:32::SQRT.fmt
d4134 1
a4134 1
010001,10,3.FMT,5.FT,5.FS,5.FD,000001:COP1:32::SUB.fmt
d4161 1
a4161 1
111001,5.BASE,5.FT,16.OFFSET:COP1:32::SWC1
d4205 1
a4205 1
010011,5.BASE,5.INDEX,5.FS,00000,001000:COP1X:32::SWXC1
d4245 1
a4245 1
010001,10,3.FMT,00000,5.FS,5.FD,001001:COP1:64::TRUNC.L.fmt
d4268 1
a4268 1
010001,10,3.FMT,00000,5.FS,5.FD,001101:COP1:32::TRUNC.W
@


1.19
log
@2002-02-28  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (SDXC1): Fix instruction-printing string.
@
text
@d1251 1
a1251 1
"dsra32 r<RT>, r<RD>, <SHIFT>"
d1273 1
a1273 1
"dsrav r<RT>, r<RD>, r<RS>"
d1827 1
a1827 1
100111,5.BASE,5.RT,16.OFFSET:NORMAL:32::LWU
@


1.18
log
@2002-02-28  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (LDC1, SDC1): Remove mipsI model, and mark with
        filter flags "32,f".
@
text
@d4099 1
a4099 1
"ldxc1 f<FS>, r<INDEX>(r<BASE>)"
@


1.17
log
@2002-02-27  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (PREFX): This is a 64-bit instruction, use '64'
        as the filter flag.
@
text
@d3579 1
a3579 1
110101,5.BASE,5.FT,16.OFFSET:COP1:64::LDC1
a3580 1
*mipsI:
d4083 1
a4083 1
111101,5.BASE,5.FT,16.OFFSET:COP1:64::SDC1
a4084 1
*mipsI:
@


1.16
log
@2002-02-27  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (PREFX): Tweak instruction opcode fields (i.e.,
        add a comma) so that it more closely match the MIPS ISA
        documentation opcode partitioning.
        (PREF): Put useful names on opcode fields, and include
        instruction-printing string.
@
text
@d3978 1
a3978 1
010011,5.BASE,5.INDEX,5.HINT,00000,001111:COP1X:32::PREFX
@


1.15
log
@2002-02-27  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (check_u64): New function which in the future will
        check whether 64-bit instructions are usable and signal an
        exception if not.  Currently a no-op.
        (DADD, DADDI, DADDIU, DADDU, DDIV, DDIVU, DMULT, DMULTU, DSLL,
        DSLL32, DSLLV, DSRA, DSRA32, DSRAV, DSRL, DSRL32, DSRLV, DSUB,
        DSUBU, LD, LDL, LDR, LLD, LWU, SCD, SD, SDL, SDR, DMxC1, LDXC1,
        LWXC1, SDXC1, SWXC1, DMFC0, DMTC0): Use check_u64.

        * mips.igen (check_fpu): New function which in the future will
        check whether FPU instructions are usable and signal an exception
        if not.  Currently a no-op.
        (ABS.fmt, ADD.fmt, BC1a, BC1b, C.cond.fmta, C.cond.fmtb,
        CEIL.L.fmt, CEIL.W, CxC1, CVT.D.fmt, CVT.L.fmt, CVT.S.fmt,
        CVT.W.fmt, DIV.fmt, DMxC1, DMxC1, FLOOR.L.fmt, FLOOR.W.fmt, LDC1,
        LDXC1, LWC1, LWXC1, MADD.D, MADD.S, MxC1, MOV.fmt, MOVtf,
        MOVtf.fmt, MOVN.fmt, MOVZ.fmt, MSUB.D, MSUB.S, MUL.fmt, NEG.fmt,
        NMADD.D, NMADD.S, NMSUB.D, NMSUB.S, RECIP.fmt, ROUND.L.fmt,
        ROUND.W.fmt, RSQRT.fmt, SDC1, SDXC1, SQRT.fmt, SUB.fmt, SWC1,
        SWXC1, TRUNC.L.fmt, TRUNC.W): Use check_fpu.
@
text
@d2086 2
a2087 1
110011,5.RS,nnnnn,16.OFFSET:NORMAL:32::PREF
d3978 1
a3978 1
010011,5.BASE,5.INDEX,5.HINT,00000001111:COP1X:32::PREFX
@


1.14
log
@2002-02-27  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (do_load_left, do_load_right): Move to be immediately
        following do_load.
        (do_store_left, do_store_right): Move to be immediately following
        do_store.
@
text
@d254 16
d833 1
d853 1
d880 1
d901 1
d945 1
d984 1
d1141 1
d1150 1
d1168 1
d1177 1
d1201 1
d1215 1
d1227 1
d1245 1
d1259 1
d1280 1
d1298 1
d1312 1
d1333 1
d1346 1
d1372 1
d1594 1
d1623 1
d1636 1
d1726 1
d1835 1
d2267 1
d2302 1
d2328 1
d2341 1
d3011 22
d3049 1
d3076 1
d3098 1
d3128 1
d3193 1
d3206 1
d3224 1
d3247 1
d3265 1
d3292 1
d3350 1
d3373 1
d3401 1
d3426 1
d3452 1
d3468 2
d3504 2
d3544 1
d3568 1
d3589 1
d3600 2
d3618 1
d3629 2
d3650 1
d3668 1
d3683 1
d3709 1
d3733 1
d3748 1
d3764 1
d3780 1
d3801 1
d3821 1
d3840 1
d3866 1
d3891 1
d3913 1
d3932 1
d3951 1
d3970 1
d4006 1
d4029 1
d4053 1
d4073 1
d4094 1
d4105 2
d4125 1
d4151 1
d4177 1
d4216 2
d4259 1
d4283 1
d4390 1
d4401 1
@


1.13
log
@2002-02-27  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (mipsV): New model name.  Also, add it to
        all instructions and functions where it is appropriate.
@
text
@d1432 86
a1755 57
:function:::unsigned_word:do_load_left:unsigned access, address_word base, address_word offset, unsigned_word rt
{
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? -1 : 0);
  address_word bigendiancpu = (BigEndianCPU ? -1 : 0);
  unsigned int byte;
  unsigned int word;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;
  int nr_lhs_bits;
  int nr_rhs_bits;
  unsigned_word lhs_mask;
  unsigned_word temp;

  vaddr = base + offset;
  AddressTranslation (vaddr, isDATA, isLOAD, &paddr, &uncached, isTARGET, isREAL);
  paddr = (paddr ^ (reverseendian & mask));
  if (BigEndianMem == 0)
    paddr = paddr & ~access;

  /* compute where within the word/mem we are */
  byte = ((vaddr ^ bigendiancpu) & access); /* 0..access */
  word = ((vaddr ^ bigendiancpu) & (mask & ~access)) / (access + 1); /* 0..1 */
  nr_lhs_bits = 8 * byte + 8;
  nr_rhs_bits = 8 * access - 8 * byte;
  /* nr_lhs_bits + nr_rhs_bits == 8 * (accesss + 1) */

  /* fprintf (stderr, "l[wd]l: 0x%08lx%08lx 0x%08lx%08lx %d:%d %d+%d\n",
	   (long) ((unsigned64) vaddr >> 32), (long) vaddr,
	   (long) ((unsigned64) paddr >> 32), (long) paddr,
	   word, byte, nr_lhs_bits, nr_rhs_bits); */

  LoadMemory (&memval, NULL, uncached, byte, paddr, vaddr, isDATA, isREAL);
  if (word == 0)
    {
      /* GPR{31..32-NR_LHS_BITS} = memval{NR_LHS_BITS-1..0} */
      temp = (memval << nr_rhs_bits);
    }
  else
    {
      /* GPR{31..32-NR_LHS_BITS = memval{32+NR_LHS_BITS..32} */
      temp = (memval >> nr_lhs_bits);
    }
  lhs_mask = LSMASK (nr_lhs_bits + nr_rhs_bits - 1, nr_rhs_bits);
  rt = (rt & ~lhs_mask) | (temp & lhs_mask);

  /* fprintf (stderr, "l[wd]l: 0x%08lx%08lx -> 0x%08lx%08lx & 0x%08lx%08lx -> 0x%08lx%08lx\n",
	   (long) ((unsigned64) memval >> 32), (long) memval,
	   (long) ((unsigned64) temp >> 32), (long) temp,
	   (long) ((unsigned64) lhs_mask >> 32), (long) lhs_mask,
	   (long) (rt >> 32), (long) rt); */
  return rt;
}


a1770 31
:function:::unsigned_word:do_load_right:unsigned access, address_word base, address_word offset, unsigned_word rt
{
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? -1 : 0);
  address_word bigendiancpu = (BigEndianCPU ? -1 : 0);
  unsigned int byte;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;

  vaddr = base + offset;
  AddressTranslation (vaddr, isDATA, isLOAD, &paddr, &uncached, isTARGET, isREAL);
  /* NOTE: SPEC is wrong, has `BigEndianMem == 0' not `BigEndianMem != 0' */
  paddr = (paddr ^ (reverseendian & mask));
  if (BigEndianMem != 0)
    paddr = paddr & ~access;
  byte = ((vaddr & mask) ^ (bigendiancpu & mask));
  /* NOTE: SPEC is wrong, had `byte' not `access - byte'.  See SW. */
  LoadMemory (&memval, NULL, uncached, access - (access & byte), paddr, vaddr, isDATA, isREAL);
  /* printf ("lr: 0x%08lx %d@@0x%08lx 0x%08lx\n",
     (long) paddr, byte, (long) paddr, (long) memval); */
  {
    unsigned_word screen = LSMASK (8 * (access - (byte & access) + 1) - 1, 0);
    rt &= ~screen;
    rt |= (memval >> (8 * byte)) & screen;
  }
  return rt;
}


d2064 1
d2088 66
a2623 47

:function:::void:do_store_left:unsigned access, address_word base, address_word offset, unsigned_word rt
{
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? -1 : 0);
  address_word bigendiancpu = (BigEndianCPU ? -1 : 0);
  unsigned int byte;
  unsigned int word;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;
  int nr_lhs_bits;
  int nr_rhs_bits;

  vaddr = base + offset;
  AddressTranslation (vaddr, isDATA, isSTORE, &paddr, &uncached, isTARGET, isREAL);
  paddr = (paddr ^ (reverseendian & mask));
  if (BigEndianMem == 0)
    paddr = paddr & ~access;

  /* compute where within the word/mem we are */
  byte = ((vaddr ^ bigendiancpu) & access); /* 0..access */
  word = ((vaddr ^ bigendiancpu) & (mask & ~access)) / (access + 1); /* 0..1 */
  nr_lhs_bits = 8 * byte + 8;
  nr_rhs_bits = 8 * access - 8 * byte;
  /* nr_lhs_bits + nr_rhs_bits == 8 * (accesss + 1) */
  /* fprintf (stderr, "s[wd]l: 0x%08lx%08lx 0x%08lx%08lx %d:%d %d+%d\n",
	   (long) ((unsigned64) vaddr >> 32), (long) vaddr,
	   (long) ((unsigned64) paddr >> 32), (long) paddr,
	   word, byte, nr_lhs_bits, nr_rhs_bits); */

  if (word == 0)
    {
      memval = (rt >> nr_rhs_bits);
    }
  else
    {
      memval = (rt << nr_lhs_bits);
    }
  /* fprintf (stderr, "s[wd]l: 0x%08lx%08lx -> 0x%08lx%08lx\n",
	   (long) ((unsigned64) rt >> 32), (long) rt,
	   (long) ((unsigned64) memval >> 32), (long) memval); */
  StoreMemory (uncached, byte, memval, 0, paddr, vaddr, isREAL);
}


a2637 21

:function:::void:do_store_right:unsigned access, address_word base, address_word offset, unsigned_word rt
{
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? -1 : 0);
  address_word bigendiancpu = (BigEndianCPU ? -1 : 0);
  unsigned int byte;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;

  vaddr = base + offset;
  AddressTranslation (vaddr, isDATA, isSTORE, &paddr, &uncached, isTARGET, isREAL);
  paddr = (paddr ^ (reverseendian & mask));
  if (BigEndianMem != 0)
    paddr &= ~access;
  byte = ((vaddr & mask) ^ (bigendiancpu & mask));
  memval = (rt << (byte * 8));
  StoreMemory (uncached, access - (access & byte), memval, 0, paddr, vaddr, isREAL);
}
@


1.12
log
@2002-02-18  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen: For all functions and instructions, list model
        names that support that instruction one per line.
@
text
@d50 1
d142 1
d168 1
d204 1
d238 1
d260 1
a260 1
//        CPU Instruction Set (mipsI - mipsIV)
d271 1
d293 1
d322 1
d345 1
d368 1
d384 1
d402 1
d423 1
d447 1
d469 1
d491 1
d517 1
d541 1
d562 1
d588 1
d611 1
d635 1
d657 1
d681 1
d705 1
d731 1
d752 1
d776 1
d813 1
d832 1
d858 1
d878 1
d921 1
d959 1
d1000 1
d1037 1
d1116 1
d1141 1
d1171 1
d1183 1
d1195 1
d1212 1
d1224 1
d1245 1
d1262 1
d1274 1
d1295 1
d1307 1
d1332 1
d1346 1
d1364 1
d1383 1
d1400 1
d1439 1
d1454 1
d1467 1
d1480 1
d1495 1
d1507 1
d1521 1
d1536 1
d1550 1
d1592 1
d1629 1
d1646 1
d1661 1
d1733 1
d1779 1
d1792 1
d1814 1
d1838 1
d1851 1
d1863 1
d1878 1
d1895 1
d1926 1
d1963 1
d1992 1
d2014 1
d2037 1
d2048 1
d2096 1
d2110 1
d2152 1
d2190 1
d2203 1
d2215 1
d2227 1
d2241 1
d2265 1
d2292 1
d2314 1
d2336 1
d2358 1
d2381 1
d2404 1
d2429 1
d2453 1
d2477 1
d2492 1
d2520 1
d2535 1
d2550 1
d2612 1
d2648 1
d2663 1
d2678 1
d2692 1
d2706 1
d2720 1
d2734 1
d2748 1
d2762 1
d2776 1
d2790 1
d2804 1
d2818 1
d2832 1
d2846 1
d2868 1
d2890 1
d2975 1
d3000 1
d3055 1
d3131 1
d3144 1
d3166 1
d3213 1
d3266 1
d3288 1
d3315 1
d3339 1
d3363 1
d3417 1
d3451 1
d3474 1
d3498 1
d3510 1
d3524 1
d3536 1
d3550 1
d3567 1
d3608 1
d3628 1
d3648 1
d3661 1
d3678 1
d3698 1
d3712 1
d3730 1
d3753 1
d3778 1
d3800 1
d3818 1
d3836 1
d3854 1
d3871 1
d3890 1
d3910 1
d3933 1
d3953 1
d3976 1
d3988 1
d4000 1
d4024 1
d4050 1
d4090 1
d4129 1
d4152 1
d4183 1
d4202 1
d4213 1
d4223 1
d4231 1
d4256 1
d4265 1
d4275 1
d4287 1
d4296 1
d4321 1
d4337 1
d4352 1
d4367 1
d4382 1
d4393 1
d4404 1
d4415 1
@


1.11
log
@2002-02-11  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen: Add some additional comments about supported
        models, and about which instructions go where.
        (BC1b, MFC0, MTC0, RFE): Sort supported models in the same
        order as is used in the rest of the file.
@
text
@d38 3
d137 4
a140 1
*mipsI,mipsII,mipsIII,mipsIV:
d162 4
a165 1
*mipsI,mipsII,mipsIII,mipsIV:
d197 4
a200 1
*mipsI,mipsII,mipsIII,mipsIV:
d230 4
a233 1
*mipsI,mipsII,mipsIII,mipsIV:
d262 4
a265 1
*mipsI,mipsII,mipsIII,mipsIV:
d283 4
a286 1
*mipsI,mipsII,mipsIII,mipsIV:
d311 4
a314 1
*mipsI,mipsII,mipsIII,mipsIV:
d333 4
a336 1
*mipsI,mipsII,mipsIII,mipsIV:
d355 4
a358 1
*mipsI,mipsII,mipsIII,mipsIV:
d370 4
a373 1
*mipsI,mipsII,mipsIII,mipsIV:
d387 4
a390 1
*mipsI,mipsII,mipsIII,mipsIV:
d430 4
a433 1
*mipsI,mipsII,mipsIII,mipsIV:
d451 4
a454 1
*mipsI,mipsII,mipsIII,mipsIV:
d520 4
a523 1
*mipsI,mipsII,mipsIII,mipsIV:
d565 4
a568 1
*mipsI,mipsII,mipsIII,mipsIV:
d610 4
a613 1
*mipsI,mipsII,mipsIII,mipsIV:
d631 4
a634 1
*mipsI,mipsII,mipsIII,mipsIV:
d702 4
a705 1
*mipsI,mipsII,mipsIII,mipsIV:
d745 4
a748 1
*mipsI,mipsII,mipsIII,mipsIV:
d962 4
a965 1
*mipsI,mipsII,mipsIII,mipsIV:
d998 4
a1001 1
*mipsI,mipsII,mipsIII,mipsIV:
d1078 2
a1079 1
*mipsIII,mipsIV:
d1102 2
a1103 1
*mipsIII,mipsIV:
d1293 4
a1296 1
*mipsI,mipsII,mipsIII,mipsIV:
d1310 4
a1313 1
*mipsI,mipsII,mipsIII,mipsIV:
d1328 4
a1331 1
*mipsI,mipsII,mipsIII,mipsIV:
d1344 4
a1347 1
*mipsI,mipsII,mipsIII,mipsIV:
d1382 4
a1385 1
*mipsI,mipsII,mipsIII,mipsIV:
d1396 4
a1399 1
*mipsI,mipsII,mipsIII,mipsIV:
d1458 4
a1461 1
*mipsI,mipsII,mipsIII,mipsIV:
d1472 4
a1475 1
*mipsI,mipsII,mipsIII,mipsIV:
d1562 4
a1565 1
*mipsI,mipsII,mipsIII,mipsIV:
d1578 4
a1581 1
*mipsI,mipsII,mipsIII,mipsIV:
d1592 4
a1595 1
*mipsI,mipsII,mipsIII,mipsIV:
d1663 4
a1666 1
*mipsI,mipsII,mipsIII,mipsIV:
d1708 4
a1711 1
*mipsI,mipsII,mipsIII,mipsIV:
d1741 4
a1744 1
*mipsI,mipsII,mipsIII,mipsIV:
d1764 4
a1767 1
*mipsI,mipsII,mipsIII,mipsIV:
d1801 4
a1804 1
*mipsI,mipsII,mipsIII,mipsIV:
d1817 4
a1820 1
*mipsI,mipsII,mipsIII,mipsIV:
d1847 4
a1850 1
*mipsI,mipsII,mipsIII,mipsIV:
d1883 4
a1886 1
*mipsI,mipsII,mipsIII,mipsIV:
d1911 4
a1914 1
*mipsI,mipsII,mipsIII,mipsIV:
d1932 4
a1935 1
*mipsI,mipsII,mipsIII,mipsIV:
d1954 4
a1957 1
*mipsI,mipsII,mipsIII,mipsIV:
d2011 4
a2014 1
*mipsI,mipsII,mipsIII,mipsIV:
d2149 4
a2152 1
*mipsI,mipsII,mipsIII,mipsIV:
d2172 4
a2175 1
*mipsI,mipsII,mipsIII,mipsIV:
d2198 4
a2201 1
*mipsI,mipsII,mipsIII,mipsIV:
d2219 4
a2222 1
*mipsI,mipsII,mipsIII,mipsIV:
d2240 4
a2243 1
*mipsI,mipsII,mipsIII,mipsIV:
d2261 4
a2264 1
*mipsI,mipsII,mipsIII,mipsIV:
d2283 4
a2286 1
*mipsI,mipsII,mipsIII,mipsIV:
d2305 4
a2308 1
*mipsI,mipsII,mipsIII,mipsIV:
d2329 4
a2332 1
*mipsI,mipsII,mipsIII,mipsIV:
d2352 4
a2355 1
*mipsI,mipsII,mipsIII,mipsIV:
d2375 4
a2378 1
*mipsI,mipsII,mipsIII,mipsIV:
d2389 4
a2392 1
*mipsI,mipsII,mipsIII,mipsIV:
d2416 4
a2419 1
*mipsI,mipsII,mipsIII,mipsIV:
d2430 4
a2433 1
*mipsI,mipsII,mipsIII,mipsIV:
d2444 4
a2447 1
*mipsI,mipsII,mipsIII,mipsIV:
d2505 4
a2508 1
*mipsI,mipsII,mipsIII,mipsIV:
d2540 4
a2543 1
*mipsI,mipsII,mipsIII,mipsIV:
d2568 4
a2571 1
*mipsI,mipsII,mipsIII,mipsIV:
d2745 4
a2748 1
*mipsI,mipsII,mipsIII,mipsIV:
d2766 4
a2769 1
*mipsI,mipsII,mipsIII,mipsIV:
d2850 4
a2853 1
*mipsI,mipsII,mipsIII,mipsIV:
d2874 4
a2877 1
*mipsI,mipsII,mipsIII,mipsIV:
d2904 3
a2906 1
*mipsI,mipsII,mipsIII:
d2996 3
a2998 1
*mipsI,mipsII,mipsIII:
d3134 4
a3137 1
*mipsI,mipsII,mipsIII,mipsIV:
d3181 4
a3184 1
*mipsI,mipsII,mipsIII,mipsIV:
d3204 4
a3207 1
*mipsI,mipsII,mipsIII,mipsIV:
d3227 4
a3230 1
*mipsI,mipsII,mipsIII,mipsIV:
d3382 4
a3385 1
*mipsI,mipsII,mipsIII,mipsIV:
d3481 4
a3484 1
*mipsI,mipsII,mipsIII,mipsIV:
d3599 4
a3602 1
*mipsI,mipsII,mipsIII,mipsIV:
d3623 4
a3626 1
*mipsI,mipsII,mipsIII,mipsIV:
d3856 4
a3859 1
*mipsI,mipsII,mipsIII,mipsIV:
d3881 4
a3884 1
*mipsI,mipsII,mipsIII,mipsIV:
d4010 4
a4013 1
*mipsI,mipsII,mipsIII,mipsIV:
d4028 4
a4031 1
*mipsI,mipsII,mipsIII,mipsIV:
d4038 4
a4041 1
*mipsI,mipsII,mipsIII,mipsIV:
d4047 4
a4050 1
*mipsI,mipsII,mipsIII,mipsIV:
d4078 4
a4081 1
*mipsI,mipsII,mipsIII,mipsIV:
d4088 2
a4089 1
*mipsIII,mipsIV:
d4097 2
a4098 1
*mipsIII,mipsIV:
d4106 4
a4109 1
*mipsI,mipsII,mipsIII,mipsIV:
d4138 4
a4141 1
*mipsI,mipsII,mipsIII,mipsIV:
d4153 4
a4156 1
*mipsI,mipsII,mipsIII,mipsIV:
d4167 4
a4170 1
*mipsI,mipsII,mipsIII,mipsIV:
d4181 4
a4184 1
*mipsI,mipsII,mipsIII,mipsIV:
d4195 4
a4198 1
*mipsI,mipsII,mipsIII,mipsIV:
d4205 4
a4208 1
*mipsI,mipsII,mipsIII,mipsIV:
d4215 4
a4218 1
*mipsI,mipsII,mipsIII,mipsIV:
d4225 4
a4228 1
*mipsI,mipsII,mipsIII,mipsIV:
@


1.10
log
@2002-02-11  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (ADD, ADDI, DADDI, DSUB, SUB): Add comment
        indicating that ALU32_END or ALU64_END are there to check
        for overflow.
        (DADD): Likewise, but also remove previous comment about
        overflow checking.
@
text
@d37 6
a42 1
// Models known by this simulator
d47 9
a55 3
:model:::mips16:mips16:
:model:::r3900:mips3900:
:model:::vr4100:mips4100:
d57 1
d59 4
d238 1
a238 1
// Mips Architecture:
d2727 1
a2728 1
#*vr4100:
a3881 1
*r3900:
d3884 1
a3893 1
*r3900:
d3896 1
a3904 1
*r3900:
d3907 1
@


1.9
log
@2002-02-10  Chris Demetriou  <cgd@@broadcom.com>

        * mips.igen (DDIV, DIV, DIVU, DMULT, DMULTU, DSLL, DSLL32,
        DSLLV, DSRA, DSRA32, DSRAV, DSRL, DSRL32, DSRLV, DSUB, DSUBU,
        JALR, JR, MOVN, MOVZ, MTLO, MULT, MULTU, SLL, SLLV, SLT, SLTU,
        SRAV, SRLV, SUB, SUBU, SYNC, XOR, MOVtf, DI, DMFC0, DMTC0, EI,
        ERET, RFE, TLBP, TLBR, TLBWI, TLBWR): Tweak instruction opcode
        fields (i.e., add and move commas) so that they more closely
        match the MIPS ISA documentation opcode partitioning.
@
text
@d240 1
a240 1
    ALU32_END (GPR[RD]);
d258 1
a258 1
    ALU32_END (GPR[RT]);
a711 1
  /* this check's for overflow */
d716 1
a716 1
    ALU64_END (GPR[RD]);
d734 1
a734 1
    ALU64_END (GPR[RT]);
d1183 1
a1183 1
    ALU64_END (GPR[RD]);
d2212 1
a2212 1
    ALU32_END (GPR[RD]);
@


1.8
log
@2002-02-10  Chris Demetriou  cgd@@sibyte.com

        * mips.igen (ADDI): Print immediate value.
        (BREAK): Print code.
        (DADDIU, DSRAV, DSRLV): Print correct instruction name.
        (SLL): Print "nop" specially, and don't run the code
        that does the shift for the "nop" case.
@
text
@d810 1
a810 1
000000,5.RS,5.RT,0000000000011110:SPECIAL:64::DDIV
d885 1
a885 1
000000,5.RS,5.RT,0000000000011010:SPECIAL:32::DIV
d918 1
a918 1
000000,5.RS,5.RT,0000000000011011:SPECIAL:32::DIVU
d995 1
a995 1
000000,5.RS,5.RT,0000000000011100:SPECIAL:64::DMULT
d1003 1
a1003 1
000000,5.RS,5.RT,5.RD,00000011100:SPECIAL:64::DMULT
d1018 1
a1018 1
000000,5.RS,5.RT,0000000000011101:SPECIAL:64::DMULTU
d1026 1
a1026 1
000000,5.RS,5.RT,5.RD,00000011101:SPECIAL:64::DMULTU
d1046 1
a1046 1
00000000000,5.RT,5.RD,5.SHIFT,111000:SPECIAL:64::DSLL
d1057 1
a1057 1
00000000000,5.RT,5.RD,5.SHIFT,111100:SPECIAL:64::DSLL32
d1068 1
a1068 1
000000,5.RS,5.RT,5.RD,00000010100:SPECIAL:64::DSLLV
d1084 1
a1084 1
00000000000,5.RT,5.RD,5.SHIFT,111011:SPECIAL:64::DSRA
d1095 1
a1095 1
00000000000,5.RT,5.RD,5.SHIFT,111111:SPECIAL:64::DSRA32
d1115 1
a1115 1
000000,5.RS,5.RT,5.RD,00000010111:SPECIAL:64::DSRAV
d1131 1
a1131 1
00000000000,5.RT,5.RD,5.SHIFT,111010:SPECIAL:64::DSRL
d1142 1
a1142 1
00000000000,5.RT,5.RD,5.SHIFT,111110:SPECIAL:64::DSRL32
d1162 1
a1162 1
000000,5.RS,5.RT,5.RD,00000010110:SPECIAL:64::DSRLV
d1173 1
a1173 1
000000,5.RS,5.RT,5.RD,00000101110:SPECIAL:64::DSUB
d1197 1
a1197 1
000000,5.RS,5.RT,5.RD,00000101111:SPECIAL:64::DSUBU
d1236 1
a1236 1
000000,5.RS,00000,5.RD,00000001001:SPECIAL:32::JALR
d1250 1
a1250 1
000000,5.RS,000000000000000001000:SPECIAL:32::JR
d1649 1
a1649 1
000000,5.RS,5.RT,5.RD,00000001011:SPECIAL:32::MOVN
d1660 1
a1660 1
000000,5.RS,5.RT,5.RD,00000001010:SPECIAL:32::MOVZ
d1684 1
a1684 1
000000,5.RS,000000000000000010011:SPECIAL:32::MTLO
d1711 1
a1711 1
000000,5.RS,5.RT,00000,00000011000:SPECIAL:32::MULT
d1720 1
a1720 1
000000,5.RS,5.RT,5.RD,00000011000:SPECIAL:32::MULT
d1744 1
a1744 1
000000,5.RS,5.RT,00000,00000011001:SPECIAL:32::MULTU
d1752 1
a1752 1
000000,5.RS,5.RT,5.RD,00000011001:SPECIAL:32::MULTU
d2014 1
a2014 1
00000000000,5.RT,5.RD,5.SHIFT,000000:SPECIAL:32::SLL
d2038 1
a2038 1
000000,5.RS,5.RT,5.RD,00000000100:SPECIAL:32::SLLV
d2056 1
a2056 1
000000,5.RS,5.RT,5.RD,00000101010:SPECIAL:32::SLT
d2111 1
a2111 1
000000,5.RS,5.RT,5.RD,00000101011:SPECIAL:32::SLTU
d2151 1
a2151 1
000000,5.RS,5.RT,5.RD,00000000111:SPECIAL:32::SRAV
d2191 1
a2191 1
000000,5.RS,5.RT,5.RD,00000000110:SPECIAL:32::SRLV
d2202 1
a2202 1
000000,5.RS,5.RT,5.RD,00000100010:SPECIAL:32::SUB
d2226 1
a2226 1
000000,5.RS,5.RT,5.RD,00000100011:SPECIAL:32::SUBU
d2349 1
a2349 1
000000000000000000000,5.STYPE,001111:SPECIAL:32::SYNC
d2537 1
a2537 1
000000,5.RS,5.RT,5.RD,00000100110:SPECIAL:32::XOR
d3261 1
a3261 1
000000,5.RS,3.CC,0,1.TF,5.RD,00000000001:SPECIAL:32::MOVtf
d3812 1
a3812 1
010000,10000,000000000000000,111001:COP0:32::DI
d3819 1
a3819 1
010000,00001,5.RT,5.RD,000,0000,0000:COP0:64::DMFC0
d3827 1
a3827 1
010000,00101,5.RT,5.RD,000,0000,0000:COP0:64::DMTC0
d3835 1
a3835 1
010000,10000,000000000000000,111000:COP0:32::EI
d3842 1
a3842 1
010000,10000,000000000000000,011000:COP0:32::ERET
d3887 1
a3887 1
010000,10000,000000000000000,010000:COP0:32::RFE
d3909 1
a3909 1
010000,10000,000000000000000,001000:COP0:32::TLBP
d3916 1
a3916 1
010000,10000,000000000000000,000001:COP0:32::TLBR
d3923 1
a3923 1
010000,10000,000000000000000,000010:COP0:32::TLBWI
d3930 1
a3930 1
010000,10000,000000000000000,000110:COP0:32::TLBWR
@


1.7
log
@* mips.igen (CFC1, CTC1): Pass the correct register numbers to
PENDING_FILL.  Use PENDING_SCHED directly to handle the pending
set of the FCSR.
* sim-main.h (COCIDX): Remove definition; this isn't supported by
PENDING_FILL, and you can get the intended effect gracefully by
calling PENDING_SCHED directly.
@
text
@d248 1
a248 1
"addi r<RT>, r<RS>, IMMEDIATE"
d671 1
a671 1
"break"
d750 1
a750 1
"daddu r<RT>, r<RS>, <IMMEDIATE>"
d1116 1
a1116 1
"dsra32 r<RT>, r<RD>, r<RS>"
d1163 1
a1163 1
"dsrl32 r<RD>, r<RT>, r<RS>"
d2015 1
d2022 4
a2025 1
  do_sll (SD_, RT, RD, SHIFT);
@


1.6
log
@Fix MOVN.fmt and MOVZ.fmt, need to test GPR[RT].
@
text
@d2842 1
a2842 1
	PENDING_FILL((FS + FCR0IDX),VL4_8(GPR[RT]));
d2844 1
a2844 1
	PENDING_FILL((FS + FCR31IDX),VL4_8(GPR[RT]));
d2846 1
a2846 1
      PENDING_FILL(COCIDX,0); /* special case */
@


1.5
log
@Fix printf arguments.
@
text
@d3286 1
d3290 4
a3293 7
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
    StoreFPR(destreg,format,ValueFPR(fs,format));
  }
d3309 4
a3312 7
  unsigned32 instruction = instruction_0;
  int destreg = ((instruction >> 6) & 0x0000001F);
  int fs = ((instruction >> 11) & 0x0000001F);
  int format = ((instruction >> 21) & 0x00000007);
  {
   StoreFPR(destreg,format,ValueFPR(fs,format));
  }
@


1.4
log
@fix spelling mistake in comment
@
text
@d3037 2
a3038 2
	      "Warning: PC 0x%x: semantic_DMxC1_COP1Sa 32-bit use of odd FPR number\n",
	      CIA);
d3212 2
a3213 1
	      "Warning:  PC 0x%x: MTC1 not DMTC1 with 64 bit regs\n", CIA);
@


1.3
log
@* mips.igen (DMxC1): Fix format arguments for sim_io_eprintf call.
@
text
@d959 1
a959 1
  /* multuply out the 4 sub products */
@


1.2
log
@* autoconf correction
* merge from internal repo -> sourceware

2000-03-02  Frank Ch. Eigler  <fche@@redhat.com>

	* configure: Regenerated.

Tue Feb  8 18:35:01 2000  Donald Lindsay  <dlindsay@@hound.cygnus.com>

	* interp.c, mips.igen: all 5 DEADC0DE situations now have sim_io_eprintf
	calls, conditional on the simulator being in verbose mode.
@
text
@d3067 2
a3068 1
	      "Warning: PC 0x%x: DMxC1 32-bit use of odd FPR number\n", CIA);
@


1.1
log
@Initial revision
@
text
@d79 1
a704 3



d1552 1
a1552 1
  GPR[RT] = EXTEND32 (do_load_left (SD_, AccessLength_WORD, GPR[BASE], EXTEND32 (OFFSET), GPR[RT]));
d1721 1
d1753 1
d1758 1
a1758 1
  do_multu (SD_, RS, RT, 0);
d3034 7
a3040 1
	PENDING_FILL(RT,SET64HI(0xDEADC0DE) | 0xBAD0BAD0);
d3064 6
a3069 1
	GPR[RT] = SET64HI (0xDEADC0DE) | 0xBAD0BAD0;
d3119 1
d3208 6
a3213 1
	PENDING_FILL ((FS + FGRIDX), (SET64HI(0xDEADC0DE) | VL4_8(GPR[RT])));
d3254 1
d3266 1
d3484 1
a3485 1
"recip.%s<FMT> f<FD>, f<FS>"
d3564 1
d3761 8
d3816 16
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d1554 1
a1554 1
  GPR[RT] = EXTEND32 (do_load_left (SD_, AccessLength_WORD, GPR[BASE], EXTEND16 (OFFSET), GPR[RT]));
a3739 8

010000,01000,00000,16.OFFSET:COP0:32::BC0F
"bc0f <OFFSET>"
// stub needed for eCos as tx39 hardware bug workaround
*r3900:
{
  /* do nothing */
}
@


1.1.1.3
log
@import gdb-1999-07-07 pre reformat
@
text
@a1722 1
"mult r<RS>, r<RT>":RD == 0
a1753 1
"multu r<RS>, r<RT>":RD == 0
a3795 16


010000,00001,5.RT,5.RD,000,0000,0000:COP0:64::DMFC0
"dmfc0 r<RT>, r<RD>"
*mipsIII,mipsIV:
{
  DecodeCoproc (instruction_0);
}


010000,00101,5.RT,5.RD,000,0000,0000:COP0:64::DMTC0
"dmtc0 r<RT>, r<RD>"
*mipsIII,mipsIV:
{
  DecodeCoproc (instruction_0);
}
@


1.1.1.4
log
@import gdb-1999-09-08 snapshot
@
text
@a78 1
  ENGINE_ISSUE_PREFIX_HOOK();
d1751 1
a1751 1
  do_multu (SD_, RS, RT, RD);
@


1.1.1.5
log
@import gdb-1999-09-13 snapshot
@
text
@d1752 1
a1752 1
  do_multu (SD_, RS, RT, 0);
d1761 1
a1761 1
  do_multu (SD_, RS, RT, RD);
@


1.1.1.6
log
@import gdb-1999-10-25 snapshot
@
text
@d705 3
a3110 1
*mipsI:
d3468 1
a3469 1
*mipsIV:
a3547 1
*mipsI:
@


1.1.1.7
log
@import gdb-1999-12-06 snapshot
@
text
@a3237 1
// MOVT
a3248 1
// MOVT.fmt
@


