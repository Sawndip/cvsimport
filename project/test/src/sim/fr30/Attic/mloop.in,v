head	1.3;
access;
symbols
	gdb_6_3-20041109-release:1.2
	gdb_6_3-branch:1.2.0.66
	gdb_6_3-20041019-branchpoint:1.2
	drow_intercu-merge-20040921:1.2
	drow_intercu-merge-20040915:1.2
	jimb-gdb_6_2-e500-branch:1.2.0.68
	jimb-gdb_6_2-e500-branchpoint:1.2
	gdb_6_2-20040730-release:1.2
	gdb_6_2-branch:1.2.0.64
	gdb_6_2-2004-07-10-gmt-branchpoint:1.2
	gdb_6_1_1-20040616-release:1.2
	gdb_6_1-2004-04-05-release:1.2
	drow_intercu-merge-20040402:1.2
	drow_intercu-merge-20040327:1.2
	ezannoni_pie-20040323-branch:1.2.0.62
	ezannoni_pie-20040323-branchpoint:1.2
	cagney_tramp-20040321-mergepoint:1.2
	cagney_tramp-20040309-branch:1.2.0.60
	cagney_tramp-20040309-branchpoint:1.2
	gdb_6_1-branch:1.2.0.58
	gdb_6_1-2004-03-01-gmt-branchpoint:1.2
	drow_intercu-20040221-branch:1.2.0.56
	drow_intercu-20040221-branchpoint:1.2
	cagney_bfdfile-20040213-branch:1.2.0.54
	cagney_bfdfile-20040213-branchpoint:1.2
	drow-cplus-merge-20040208:1.2
	carlton_dictionary-20040126-merge:1.2
	cagney_bigcore-20040122-branch:1.2.0.52
	cagney_bigcore-20040122-branchpoint:1.2
	drow-cplus-merge-20040113:1.2
	drow-cplus-merge-20031224:1.2
	drow-cplus-merge-20031220:1.2
	carlton_dictionary-20031215-merge:1.2
	drow-cplus-merge-20031214:1.2
	carlton-dictionary-20031111-merge:1.2
	gdb_6_0-2003-10-04-release:1.2
	kettenis_sparc-20030918-branch:1.2.0.50
	kettenis_sparc-20030918-branchpoint:1.2
	carlton_dictionary-20030917-merge:1.2
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.48
	cagney_x86i386-20030821-branch:1.2.0.46
	cagney_x86i386-20030821-branchpoint:1.2
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.2.0.44
	gdb_6_0-2003-06-23-branchpoint:1.2
	jimb-ppc64-linux-20030613-branch:1.2.0.42
	jimb-ppc64-linux-20030613-branchpoint:1.2
	cagney_convert-20030606-branch:1.2.0.40
	cagney_convert-20030606-branchpoint:1.2
	cagney_writestrings-20030508-branch:1.2.0.38
	cagney_writestrings-20030508-branchpoint:1.2
	jimb-ppc64-linux-20030528-branch:1.2.0.36
	jimb-ppc64-linux-20030528-branchpoint:1.2
	carlton_dictionary-20030523-merge:1.2
	cagney_fileio-20030521-branch:1.2.0.34
	cagney_fileio-20030521-branchpoint:1.2
	kettenis_i386newframe-20030517-mergepoint:1.2
	jimb-ppc64-linux-20030509-branch:1.2.0.32
	jimb-ppc64-linux-20030509-branchpoint:1.2
	kettenis_i386newframe-20030504-mergepoint:1.2
	carlton_dictionary-20030430-merge:1.2
	kettenis_i386newframe-20030419-branch:1.2.0.30
	kettenis_i386newframe-20030419-branchpoint:1.2
	carlton_dictionary-20030416-merge:1.2
	cagney_frameaddr-20030409-mergepoint:1.2
	kettenis_i386newframe-20030406-branch:1.2.0.28
	kettenis_i386newframe-20030406-branchpoint:1.2
	cagney_frameaddr-20030403-branchpoint:1.2
	cagney_frameaddr-20030403-branch:1.2.0.26
	cagney_framebase-20030330-mergepoint:1.2
	cagney_framebase-20030326-branch:1.2.0.24
	cagney_framebase-20030326-branchpoint:1.2
	cagney_lazyid-20030317-branch:1.2.0.22
	cagney_lazyid-20030317-branchpoint:1.2
	kettenis-i386newframe-20030316-mergepoint:1.2
	offbyone-20030313-branch:1.2.0.20
	offbyone-20030313-branchpoint:1.2
	kettenis-i386newframe-20030308-branch:1.2.0.18
	kettenis-i386newframe-20030308-branchpoint:1.2
	carlton_dictionary-20030305-merge:1.2
	cagney_offbyone-20030303-branch:1.2.0.16
	cagney_offbyone-20030303-branchpoint:1.2
	carlton_dictionary-20030207-merge:1.2
	interps-20030202-branch:1.2.0.14
	interps-20030202-branchpoint:1.2
	cagney-unwind-20030108-branch:1.2.0.12
	cagney-unwind-20030108-branchpoint:1.2
	carlton_dictionary-20021223-merge:1.2
	gdb_5_3-2002-12-12-release:1.2
	carlton_dictionary-20021115-merge:1.2
	kseitz_interps-20021105-merge:1.2
	kseitz_interps-20021103-merge:1.2
	drow-cplus-merge-20021020:1.2
	drow-cplus-merge-20021025:1.2
	carlton_dictionary-20021025-merge:1.2
	carlton_dictionary-20021011-merge:1.2
	drow-cplus-branch:1.2.0.10
	drow-cplus-branchpoint:1.2
	kseitz_interps-20020930-merge:1.2
	carlton_dictionary-20020927-merge:1.2
	carlton_dictionary-branch:1.2.0.8
	carlton_dictionary-20020920-branchpoint:1.2
	gdb_5_3-branch:1.2.0.6
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.4
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.2
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.1.1.1
	kseitz_interps-20020528-branch:1.1.1.1.0.20
	kseitz_interps-20020528-branchpoint:1.1.1.1
	cagney_regbuf-20020515-branch:1.1.1.1.0.18
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	jimb-macro-020506-branch:1.1.1.1.0.16
	jimb-macro-020506-branchpoint:1.1.1.1
	gdb_5_2-2002-04-29-release:1.1.1.1
	gdb_5_2-branch:1.1.1.1.0.14
	gdb_5_2-2002-03-03-branchpoint:1.1.1.1
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.12
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.10
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.8
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2004.11.12.16.45.27;	author cagney;	state dead;
branches;
next	1.2;

1.2
date	2002.07.16.14.30.14;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.35.02;	author shebs;	state Exp;
branches
	1.1.1.1.20.1;
next	;

1.1.1.1.20.1
date	2002.07.22.21.47.26;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.3
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* d30v, fr30, mn10200, z8k: Delete directory.
@
text
@# OBSOLETE # Simulator main loop for fr30. -*- C -*-
# OBSOLETE # Copyright (C) 1998, 1999 Free Software Foundation, Inc.
# OBSOLETE # Contributed by Cygnus Solutions.
# OBSOLETE #
# OBSOLETE # This file is part of the GNU Simulators.
# OBSOLETE #
# OBSOLETE # This program is free software; you can redistribute it and/or modify
# OBSOLETE # it under the terms of the GNU General Public License as published by
# OBSOLETE # the Free Software Foundation; either version 2, or (at your option)
# OBSOLETE # any later version.
# OBSOLETE #
# OBSOLETE # This program is distributed in the hope that it will be useful,
# OBSOLETE # but WITHOUT ANY WARRANTY; without even the implied warranty of
# OBSOLETE # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# OBSOLETE # GNU General Public License for more details.
# OBSOLETE #
# OBSOLETE # You should have received a copy of the GNU General Public License along
# OBSOLETE # with this program; if not, write to the Free Software Foundation, Inc.,
# OBSOLETE # 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# OBSOLETE 
# OBSOLETE # Syntax:
# OBSOLETE # /bin/sh mainloop.in command
# OBSOLETE #
# OBSOLETE # Command is one of:
# OBSOLETE #
# OBSOLETE # init
# OBSOLETE # support
# OBSOLETE # extract-{simple,scache,pbb}
# OBSOLETE # {full,fast}-exec-{simple,scache,pbb}
# OBSOLETE #
# OBSOLETE # A target need only provide a "full" version of one of simple,scache,pbb.
# OBSOLETE # If the target wants it can also provide a fast version of same.
# OBSOLETE # It can't provide more than this, however for illustration's sake the FR30
# OBSOLETE # port provides examples of all.
# OBSOLETE 
# OBSOLETE # ??? After a few more ports are done, revisit.
# OBSOLETE # Will eventually need to machine generate a lot of this.
# OBSOLETE 
# OBSOLETE case "x$1" in
# OBSOLETE 
# OBSOLETE xsupport)
# OBSOLETE 
# OBSOLETE cat <<EOF
# OBSOLETE 
# OBSOLETE static INLINE const IDESC *
# OBSOLETE extract (SIM_CPU *current_cpu, PCADDR pc, CGEN_INSN_INT insn, ARGBUF *abuf,
# OBSOLETE          int fast_p)
# OBSOLETE {
# OBSOLETE   const IDESC *id = @@cpu@@_decode (current_cpu, pc, insn, abuf);
# OBSOLETE   @@cpu@@_fill_argbuf (current_cpu, abuf, id, pc, fast_p);
# OBSOLETE   if (! fast_p)
# OBSOLETE     {
# OBSOLETE       int trace_p = PC_IN_TRACE_RANGE_P (current_cpu, pc);
# OBSOLETE       int profile_p = PC_IN_PROFILE_RANGE_P (current_cpu, pc);
# OBSOLETE       @@cpu@@_fill_argbuf_tp (current_cpu, abuf, trace_p, profile_p);
# OBSOLETE     }
# OBSOLETE   return id;
# OBSOLETE }
# OBSOLETE 
# OBSOLETE static INLINE SEM_PC
# OBSOLETE execute (SIM_CPU *current_cpu, SCACHE *sc, int fast_p)
# OBSOLETE {
# OBSOLETE   SEM_PC vpc;
# OBSOLETE 
# OBSOLETE   if (fast_p)
# OBSOLETE     {
# OBSOLETE #if ! WITH_SEM_SWITCH_FAST
# OBSOLETE #if WITH_SCACHE
# OBSOLETE       vpc = (*sc->argbuf.semantic.sem_fast) (current_cpu, sc);
# OBSOLETE #else
# OBSOLETE       vpc = (*sc->argbuf.semantic.sem_fast) (current_cpu, &sc->argbuf);
# OBSOLETE #endif
# OBSOLETE #else
# OBSOLETE       abort ();
# OBSOLETE #endif /* WITH_SEM_SWITCH_FAST */
# OBSOLETE     }
# OBSOLETE   else
# OBSOLETE     {
# OBSOLETE #if ! WITH_SEM_SWITCH_FULL
# OBSOLETE       ARGBUF *abuf = &sc->argbuf;
# OBSOLETE       const IDESC *idesc = abuf->idesc;
# OBSOLETE #if WITH_SCACHE_PBB
# OBSOLETE       int virtual_p = CGEN_ATTR_VALUE (NULL, idesc->attrs, CGEN_INSN_VIRTUAL);
# OBSOLETE #else
# OBSOLETE       int virtual_p = 0;
# OBSOLETE #endif
# OBSOLETE 
# OBSOLETE       if (! virtual_p)
# OBSOLETE 	{
# OBSOLETE 	  /* FIXME: call x-before */
# OBSOLETE 	  if (ARGBUF_PROFILE_P (abuf))
# OBSOLETE 	    PROFILE_COUNT_INSN (current_cpu, abuf->addr, idesc->num);
# OBSOLETE 	  /* FIXME: Later make cover macros: PROFILE_INSN_{INIT,FINI}.  */
# OBSOLETE 	  if (PROFILE_MODEL_P (current_cpu)
# OBSOLETE 	      && ARGBUF_PROFILE_P (abuf))
# OBSOLETE 	    @@cpu@@_model_insn_before (current_cpu, 1 /*first_p*/);
# OBSOLETE 	  TRACE_INSN_INIT (current_cpu, abuf, 1);
# OBSOLETE 	  TRACE_INSN (current_cpu, idesc->idata,
# OBSOLETE 		      (const struct argbuf *) abuf, abuf->addr);
# OBSOLETE 	}
# OBSOLETE #if WITH_SCACHE
# OBSOLETE       vpc = (*sc->argbuf.semantic.sem_full) (current_cpu, sc);
# OBSOLETE #else
# OBSOLETE       vpc = (*sc->argbuf.semantic.sem_full) (current_cpu, abuf);
# OBSOLETE #endif
# OBSOLETE       if (! virtual_p)
# OBSOLETE 	{
# OBSOLETE 	  /* FIXME: call x-after */
# OBSOLETE 	  if (PROFILE_MODEL_P (current_cpu)
# OBSOLETE 	      && ARGBUF_PROFILE_P (abuf))
# OBSOLETE 	    {
# OBSOLETE 	      int cycles;
# OBSOLETE 
# OBSOLETE 	      cycles = (*idesc->timing->model_fn) (current_cpu, sc);
# OBSOLETE 	      @@cpu@@_model_insn_after (current_cpu, 1 /*last_p*/, cycles);
# OBSOLETE 	    }
# OBSOLETE 	  TRACE_INSN_FINI (current_cpu, abuf, 1);
# OBSOLETE 	}
# OBSOLETE #else
# OBSOLETE       abort ();
# OBSOLETE #endif /* WITH_SEM_SWITCH_FULL */
# OBSOLETE     }
# OBSOLETE 
# OBSOLETE   return vpc;
# OBSOLETE }
# OBSOLETE 
# OBSOLETE EOF
# OBSOLETE 
# OBSOLETE ;;
# OBSOLETE 
# OBSOLETE xinit)
# OBSOLETE 
# OBSOLETE cat <<EOF
# OBSOLETE /*xxxinit*/
# OBSOLETE EOF
# OBSOLETE 
# OBSOLETE ;;
# OBSOLETE 
# OBSOLETE xextract-simple | xextract-scache)
# OBSOLETE 
# OBSOLETE # Inputs:  current_cpu, vpc, sc, FAST_P
# OBSOLETE # Outputs: sc filled in
# OBSOLETE 
# OBSOLETE cat <<EOF
# OBSOLETE {
# OBSOLETE   CGEN_INSN_INT insn = GETIMEMUHI (current_cpu, vpc);
# OBSOLETE   extract (current_cpu, vpc, insn, SEM_ARGBUF (sc), FAST_P);
# OBSOLETE }
# OBSOLETE EOF
# OBSOLETE 
# OBSOLETE ;;
# OBSOLETE 
# OBSOLETE xextract-pbb)
# OBSOLETE 
# OBSOLETE # Inputs:  current_cpu, pc, sc, max_insns, FAST_P
# OBSOLETE # Outputs: sc, pc
# OBSOLETE # sc must be left pointing past the last created entry.
# OBSOLETE # pc must be left pointing past the last created entry.
# OBSOLETE # If the pbb is terminated by a cti insn, SET_CTI_VPC(sc) must be called
# OBSOLETE # to record the vpc of the cti insn.
# OBSOLETE # SET_INSN_COUNT(n) must be called to record number of real insns.
# OBSOLETE 
# OBSOLETE cat <<EOF
# OBSOLETE {
# OBSOLETE   const IDESC *idesc;
# OBSOLETE   int icount = 0;
# OBSOLETE 
# OBSOLETE   while (max_insns > 0)
# OBSOLETE     {
# OBSOLETE       UHI insn = GETIMEMUHI (current_cpu, pc);
# OBSOLETE       idesc = extract (current_cpu, pc, insn, &sc->argbuf, FAST_P);
# OBSOLETE       ++sc;
# OBSOLETE       --max_insns;
# OBSOLETE       ++icount;
# OBSOLETE       pc += idesc->length;
# OBSOLETE       if (IDESC_CTI_P (idesc))
# OBSOLETE 	{
# OBSOLETE 	  SET_CTI_VPC (sc - 1);
# OBSOLETE 
# OBSOLETE 	  /* Delay slot? */
# OBSOLETE 	  /* ??? breakpoints in delay slots */
# OBSOLETE 	  if (CGEN_ATTR_VALUE (NULL, idesc->attrs, CGEN_INSN_DELAY_SLOT))
# OBSOLETE 	    {
# OBSOLETE 	      UHI insn = GETIMEMUHI (current_cpu, pc);
# OBSOLETE 	      idesc = extract (current_cpu, pc, insn, &sc->argbuf, FAST_P);
# OBSOLETE 	      if (CGEN_ATTR_VALUE (NULL, idesc->attrs, CGEN_INSN_NOT_IN_DELAY_SLOT))
# OBSOLETE 		{
# OBSOLETE 		  /* malformed program */
# OBSOLETE 		  sim_io_eprintf (CPU_STATE (current_cpu),
# OBSOLETE 				  "malformed program, \`%s' insn in delay slot\n",
# OBSOLETE 				  CGEN_INSN_NAME (idesc->idata));
# OBSOLETE 		}
# OBSOLETE 	      else
# OBSOLETE 		{
# OBSOLETE 		  ++sc;
# OBSOLETE 		  --max_insns;
# OBSOLETE 		  ++icount;
# OBSOLETE 		  pc += idesc->length;
# OBSOLETE 		}
# OBSOLETE 	    }
# OBSOLETE 	  break;
# OBSOLETE 	}
# OBSOLETE     }
# OBSOLETE 
# OBSOLETE  Finish:
# OBSOLETE   SET_INSN_COUNT (icount);
# OBSOLETE }
# OBSOLETE EOF
# OBSOLETE 
# OBSOLETE ;;
# OBSOLETE 
# OBSOLETE xfull-exec-* | xfast-exec-*)
# OBSOLETE 
# OBSOLETE # Inputs: current_cpu, sc, FAST_P
# OBSOLETE # Outputs: vpc
# OBSOLETE # vpc contains the address of the next insn to execute
# OBSOLETE 
# OBSOLETE cat <<EOF
# OBSOLETE {
# OBSOLETE #if (! FAST_P && WITH_SEM_SWITCH_FULL) || (FAST_P && WITH_SEM_SWITCH_FAST)
# OBSOLETE #define DEFINE_SWITCH
# OBSOLETE #include "sem-switch.c"
# OBSOLETE #else
# OBSOLETE   vpc = execute (current_cpu, vpc, FAST_P);
# OBSOLETE #endif
# OBSOLETE }
# OBSOLETE EOF
# OBSOLETE 
# OBSOLETE ;;
# OBSOLETE 
# OBSOLETE *)
# OBSOLETE   echo "Invalid argument to mainloop.in: $1" >&2
# OBSOLETE   exit 1
# OBSOLETE   ;;
# OBSOLETE 
# OBSOLETE esac
@


1.2
log
@Obsolete fr30.
@
text
@@


1.1
log
@Initial revision
@
text
@d1 236
a236 236
# Simulator main loop for fr30. -*- C -*-
# Copyright (C) 1998, 1999 Free Software Foundation, Inc.
# Contributed by Cygnus Solutions.
#
# This file is part of the GNU Simulators.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# Syntax:
# /bin/sh mainloop.in command
#
# Command is one of:
#
# init
# support
# extract-{simple,scache,pbb}
# {full,fast}-exec-{simple,scache,pbb}
#
# A target need only provide a "full" version of one of simple,scache,pbb.
# If the target wants it can also provide a fast version of same.
# It can't provide more than this, however for illustration's sake the FR30
# port provides examples of all.

# ??? After a few more ports are done, revisit.
# Will eventually need to machine generate a lot of this.

case "x$1" in

xsupport)

cat <<EOF

static INLINE const IDESC *
extract (SIM_CPU *current_cpu, PCADDR pc, CGEN_INSN_INT insn, ARGBUF *abuf,
         int fast_p)
{
  const IDESC *id = @@cpu@@_decode (current_cpu, pc, insn, abuf);
  @@cpu@@_fill_argbuf (current_cpu, abuf, id, pc, fast_p);
  if (! fast_p)
    {
      int trace_p = PC_IN_TRACE_RANGE_P (current_cpu, pc);
      int profile_p = PC_IN_PROFILE_RANGE_P (current_cpu, pc);
      @@cpu@@_fill_argbuf_tp (current_cpu, abuf, trace_p, profile_p);
    }
  return id;
}

static INLINE SEM_PC
execute (SIM_CPU *current_cpu, SCACHE *sc, int fast_p)
{
  SEM_PC vpc;

  if (fast_p)
    {
#if ! WITH_SEM_SWITCH_FAST
#if WITH_SCACHE
      vpc = (*sc->argbuf.semantic.sem_fast) (current_cpu, sc);
#else
      vpc = (*sc->argbuf.semantic.sem_fast) (current_cpu, &sc->argbuf);
#endif
#else
      abort ();
#endif /* WITH_SEM_SWITCH_FAST */
    }
  else
    {
#if ! WITH_SEM_SWITCH_FULL
      ARGBUF *abuf = &sc->argbuf;
      const IDESC *idesc = abuf->idesc;
#if WITH_SCACHE_PBB
      int virtual_p = CGEN_ATTR_VALUE (NULL, idesc->attrs, CGEN_INSN_VIRTUAL);
#else
      int virtual_p = 0;
#endif

      if (! virtual_p)
	{
	  /* FIXME: call x-before */
	  if (ARGBUF_PROFILE_P (abuf))
	    PROFILE_COUNT_INSN (current_cpu, abuf->addr, idesc->num);
	  /* FIXME: Later make cover macros: PROFILE_INSN_{INIT,FINI}.  */
	  if (PROFILE_MODEL_P (current_cpu)
	      && ARGBUF_PROFILE_P (abuf))
	    @@cpu@@_model_insn_before (current_cpu, 1 /*first_p*/);
	  TRACE_INSN_INIT (current_cpu, abuf, 1);
	  TRACE_INSN (current_cpu, idesc->idata,
		      (const struct argbuf *) abuf, abuf->addr);
	}
#if WITH_SCACHE
      vpc = (*sc->argbuf.semantic.sem_full) (current_cpu, sc);
#else
      vpc = (*sc->argbuf.semantic.sem_full) (current_cpu, abuf);
#endif
      if (! virtual_p)
	{
	  /* FIXME: call x-after */
	  if (PROFILE_MODEL_P (current_cpu)
	      && ARGBUF_PROFILE_P (abuf))
	    {
	      int cycles;

	      cycles = (*idesc->timing->model_fn) (current_cpu, sc);
	      @@cpu@@_model_insn_after (current_cpu, 1 /*last_p*/, cycles);
	    }
	  TRACE_INSN_FINI (current_cpu, abuf, 1);
	}
#else
      abort ();
#endif /* WITH_SEM_SWITCH_FULL */
    }

  return vpc;
}

EOF

;;

xinit)

cat <<EOF
/*xxxinit*/
EOF

;;

xextract-simple | xextract-scache)

# Inputs:  current_cpu, vpc, sc, FAST_P
# Outputs: sc filled in

cat <<EOF
{
  CGEN_INSN_INT insn = GETIMEMUHI (current_cpu, vpc);
  extract (current_cpu, vpc, insn, SEM_ARGBUF (sc), FAST_P);
}
EOF

;;

xextract-pbb)

# Inputs:  current_cpu, pc, sc, max_insns, FAST_P
# Outputs: sc, pc
# sc must be left pointing past the last created entry.
# pc must be left pointing past the last created entry.
# If the pbb is terminated by a cti insn, SET_CTI_VPC(sc) must be called
# to record the vpc of the cti insn.
# SET_INSN_COUNT(n) must be called to record number of real insns.

cat <<EOF
{
  const IDESC *idesc;
  int icount = 0;

  while (max_insns > 0)
    {
      UHI insn = GETIMEMUHI (current_cpu, pc);
      idesc = extract (current_cpu, pc, insn, &sc->argbuf, FAST_P);
      ++sc;
      --max_insns;
      ++icount;
      pc += idesc->length;
      if (IDESC_CTI_P (idesc))
	{
	  SET_CTI_VPC (sc - 1);

	  /* Delay slot? */
	  /* ??? breakpoints in delay slots */
	  if (CGEN_ATTR_VALUE (NULL, idesc->attrs, CGEN_INSN_DELAY_SLOT))
	    {
	      UHI insn = GETIMEMUHI (current_cpu, pc);
	      idesc = extract (current_cpu, pc, insn, &sc->argbuf, FAST_P);
	      if (CGEN_ATTR_VALUE (NULL, idesc->attrs, CGEN_INSN_NOT_IN_DELAY_SLOT))
		{
		  /* malformed program */
		  sim_io_eprintf (CPU_STATE (current_cpu),
				  "malformed program, \`%s' insn in delay slot\n",
				  CGEN_INSN_NAME (idesc->idata));
		}
	      else
		{
		  ++sc;
		  --max_insns;
		  ++icount;
		  pc += idesc->length;
		}
	    }
	  break;
	}
    }

 Finish:
  SET_INSN_COUNT (icount);
}
EOF

;;

xfull-exec-* | xfast-exec-*)

# Inputs: current_cpu, sc, FAST_P
# Outputs: vpc
# vpc contains the address of the next insn to execute

cat <<EOF
{
#if (! FAST_P && WITH_SEM_SWITCH_FULL) || (FAST_P && WITH_SEM_SWITCH_FAST)
#define DEFINE_SWITCH
#include "sem-switch.c"
#else
  vpc = execute (current_cpu, vpc, FAST_P);
#endif
}
EOF

;;

*)
  echo "Invalid argument to mainloop.in: $1" >&2
  exit 1
  ;;

esac
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.1.20.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d1 236
a236 236
# OBSOLETE # Simulator main loop for fr30. -*- C -*-
# OBSOLETE # Copyright (C) 1998, 1999 Free Software Foundation, Inc.
# OBSOLETE # Contributed by Cygnus Solutions.
# OBSOLETE #
# OBSOLETE # This file is part of the GNU Simulators.
# OBSOLETE #
# OBSOLETE # This program is free software; you can redistribute it and/or modify
# OBSOLETE # it under the terms of the GNU General Public License as published by
# OBSOLETE # the Free Software Foundation; either version 2, or (at your option)
# OBSOLETE # any later version.
# OBSOLETE #
# OBSOLETE # This program is distributed in the hope that it will be useful,
# OBSOLETE # but WITHOUT ANY WARRANTY; without even the implied warranty of
# OBSOLETE # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# OBSOLETE # GNU General Public License for more details.
# OBSOLETE #
# OBSOLETE # You should have received a copy of the GNU General Public License along
# OBSOLETE # with this program; if not, write to the Free Software Foundation, Inc.,
# OBSOLETE # 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# OBSOLETE 
# OBSOLETE # Syntax:
# OBSOLETE # /bin/sh mainloop.in command
# OBSOLETE #
# OBSOLETE # Command is one of:
# OBSOLETE #
# OBSOLETE # init
# OBSOLETE # support
# OBSOLETE # extract-{simple,scache,pbb}
# OBSOLETE # {full,fast}-exec-{simple,scache,pbb}
# OBSOLETE #
# OBSOLETE # A target need only provide a "full" version of one of simple,scache,pbb.
# OBSOLETE # If the target wants it can also provide a fast version of same.
# OBSOLETE # It can't provide more than this, however for illustration's sake the FR30
# OBSOLETE # port provides examples of all.
# OBSOLETE 
# OBSOLETE # ??? After a few more ports are done, revisit.
# OBSOLETE # Will eventually need to machine generate a lot of this.
# OBSOLETE 
# OBSOLETE case "x$1" in
# OBSOLETE 
# OBSOLETE xsupport)
# OBSOLETE 
# OBSOLETE cat <<EOF
# OBSOLETE 
# OBSOLETE static INLINE const IDESC *
# OBSOLETE extract (SIM_CPU *current_cpu, PCADDR pc, CGEN_INSN_INT insn, ARGBUF *abuf,
# OBSOLETE          int fast_p)
# OBSOLETE {
# OBSOLETE   const IDESC *id = @@cpu@@_decode (current_cpu, pc, insn, abuf);
# OBSOLETE   @@cpu@@_fill_argbuf (current_cpu, abuf, id, pc, fast_p);
# OBSOLETE   if (! fast_p)
# OBSOLETE     {
# OBSOLETE       int trace_p = PC_IN_TRACE_RANGE_P (current_cpu, pc);
# OBSOLETE       int profile_p = PC_IN_PROFILE_RANGE_P (current_cpu, pc);
# OBSOLETE       @@cpu@@_fill_argbuf_tp (current_cpu, abuf, trace_p, profile_p);
# OBSOLETE     }
# OBSOLETE   return id;
# OBSOLETE }
# OBSOLETE 
# OBSOLETE static INLINE SEM_PC
# OBSOLETE execute (SIM_CPU *current_cpu, SCACHE *sc, int fast_p)
# OBSOLETE {
# OBSOLETE   SEM_PC vpc;
# OBSOLETE 
# OBSOLETE   if (fast_p)
# OBSOLETE     {
# OBSOLETE #if ! WITH_SEM_SWITCH_FAST
# OBSOLETE #if WITH_SCACHE
# OBSOLETE       vpc = (*sc->argbuf.semantic.sem_fast) (current_cpu, sc);
# OBSOLETE #else
# OBSOLETE       vpc = (*sc->argbuf.semantic.sem_fast) (current_cpu, &sc->argbuf);
# OBSOLETE #endif
# OBSOLETE #else
# OBSOLETE       abort ();
# OBSOLETE #endif /* WITH_SEM_SWITCH_FAST */
# OBSOLETE     }
# OBSOLETE   else
# OBSOLETE     {
# OBSOLETE #if ! WITH_SEM_SWITCH_FULL
# OBSOLETE       ARGBUF *abuf = &sc->argbuf;
# OBSOLETE       const IDESC *idesc = abuf->idesc;
# OBSOLETE #if WITH_SCACHE_PBB
# OBSOLETE       int virtual_p = CGEN_ATTR_VALUE (NULL, idesc->attrs, CGEN_INSN_VIRTUAL);
# OBSOLETE #else
# OBSOLETE       int virtual_p = 0;
# OBSOLETE #endif
# OBSOLETE 
# OBSOLETE       if (! virtual_p)
# OBSOLETE 	{
# OBSOLETE 	  /* FIXME: call x-before */
# OBSOLETE 	  if (ARGBUF_PROFILE_P (abuf))
# OBSOLETE 	    PROFILE_COUNT_INSN (current_cpu, abuf->addr, idesc->num);
# OBSOLETE 	  /* FIXME: Later make cover macros: PROFILE_INSN_{INIT,FINI}.  */
# OBSOLETE 	  if (PROFILE_MODEL_P (current_cpu)
# OBSOLETE 	      && ARGBUF_PROFILE_P (abuf))
# OBSOLETE 	    @@cpu@@_model_insn_before (current_cpu, 1 /*first_p*/);
# OBSOLETE 	  TRACE_INSN_INIT (current_cpu, abuf, 1);
# OBSOLETE 	  TRACE_INSN (current_cpu, idesc->idata,
# OBSOLETE 		      (const struct argbuf *) abuf, abuf->addr);
# OBSOLETE 	}
# OBSOLETE #if WITH_SCACHE
# OBSOLETE       vpc = (*sc->argbuf.semantic.sem_full) (current_cpu, sc);
# OBSOLETE #else
# OBSOLETE       vpc = (*sc->argbuf.semantic.sem_full) (current_cpu, abuf);
# OBSOLETE #endif
# OBSOLETE       if (! virtual_p)
# OBSOLETE 	{
# OBSOLETE 	  /* FIXME: call x-after */
# OBSOLETE 	  if (PROFILE_MODEL_P (current_cpu)
# OBSOLETE 	      && ARGBUF_PROFILE_P (abuf))
# OBSOLETE 	    {
# OBSOLETE 	      int cycles;
# OBSOLETE 
# OBSOLETE 	      cycles = (*idesc->timing->model_fn) (current_cpu, sc);
# OBSOLETE 	      @@cpu@@_model_insn_after (current_cpu, 1 /*last_p*/, cycles);
# OBSOLETE 	    }
# OBSOLETE 	  TRACE_INSN_FINI (current_cpu, abuf, 1);
# OBSOLETE 	}
# OBSOLETE #else
# OBSOLETE       abort ();
# OBSOLETE #endif /* WITH_SEM_SWITCH_FULL */
# OBSOLETE     }
# OBSOLETE 
# OBSOLETE   return vpc;
# OBSOLETE }
# OBSOLETE 
# OBSOLETE EOF
# OBSOLETE 
# OBSOLETE ;;
# OBSOLETE 
# OBSOLETE xinit)
# OBSOLETE 
# OBSOLETE cat <<EOF
# OBSOLETE /*xxxinit*/
# OBSOLETE EOF
# OBSOLETE 
# OBSOLETE ;;
# OBSOLETE 
# OBSOLETE xextract-simple | xextract-scache)
# OBSOLETE 
# OBSOLETE # Inputs:  current_cpu, vpc, sc, FAST_P
# OBSOLETE # Outputs: sc filled in
# OBSOLETE 
# OBSOLETE cat <<EOF
# OBSOLETE {
# OBSOLETE   CGEN_INSN_INT insn = GETIMEMUHI (current_cpu, vpc);
# OBSOLETE   extract (current_cpu, vpc, insn, SEM_ARGBUF (sc), FAST_P);
# OBSOLETE }
# OBSOLETE EOF
# OBSOLETE 
# OBSOLETE ;;
# OBSOLETE 
# OBSOLETE xextract-pbb)
# OBSOLETE 
# OBSOLETE # Inputs:  current_cpu, pc, sc, max_insns, FAST_P
# OBSOLETE # Outputs: sc, pc
# OBSOLETE # sc must be left pointing past the last created entry.
# OBSOLETE # pc must be left pointing past the last created entry.
# OBSOLETE # If the pbb is terminated by a cti insn, SET_CTI_VPC(sc) must be called
# OBSOLETE # to record the vpc of the cti insn.
# OBSOLETE # SET_INSN_COUNT(n) must be called to record number of real insns.
# OBSOLETE 
# OBSOLETE cat <<EOF
# OBSOLETE {
# OBSOLETE   const IDESC *idesc;
# OBSOLETE   int icount = 0;
# OBSOLETE 
# OBSOLETE   while (max_insns > 0)
# OBSOLETE     {
# OBSOLETE       UHI insn = GETIMEMUHI (current_cpu, pc);
# OBSOLETE       idesc = extract (current_cpu, pc, insn, &sc->argbuf, FAST_P);
# OBSOLETE       ++sc;
# OBSOLETE       --max_insns;
# OBSOLETE       ++icount;
# OBSOLETE       pc += idesc->length;
# OBSOLETE       if (IDESC_CTI_P (idesc))
# OBSOLETE 	{
# OBSOLETE 	  SET_CTI_VPC (sc - 1);
# OBSOLETE 
# OBSOLETE 	  /* Delay slot? */
# OBSOLETE 	  /* ??? breakpoints in delay slots */
# OBSOLETE 	  if (CGEN_ATTR_VALUE (NULL, idesc->attrs, CGEN_INSN_DELAY_SLOT))
# OBSOLETE 	    {
# OBSOLETE 	      UHI insn = GETIMEMUHI (current_cpu, pc);
# OBSOLETE 	      idesc = extract (current_cpu, pc, insn, &sc->argbuf, FAST_P);
# OBSOLETE 	      if (CGEN_ATTR_VALUE (NULL, idesc->attrs, CGEN_INSN_NOT_IN_DELAY_SLOT))
# OBSOLETE 		{
# OBSOLETE 		  /* malformed program */
# OBSOLETE 		  sim_io_eprintf (CPU_STATE (current_cpu),
# OBSOLETE 				  "malformed program, \`%s' insn in delay slot\n",
# OBSOLETE 				  CGEN_INSN_NAME (idesc->idata));
# OBSOLETE 		}
# OBSOLETE 	      else
# OBSOLETE 		{
# OBSOLETE 		  ++sc;
# OBSOLETE 		  --max_insns;
# OBSOLETE 		  ++icount;
# OBSOLETE 		  pc += idesc->length;
# OBSOLETE 		}
# OBSOLETE 	    }
# OBSOLETE 	  break;
# OBSOLETE 	}
# OBSOLETE     }
# OBSOLETE 
# OBSOLETE  Finish:
# OBSOLETE   SET_INSN_COUNT (icount);
# OBSOLETE }
# OBSOLETE EOF
# OBSOLETE 
# OBSOLETE ;;
# OBSOLETE 
# OBSOLETE xfull-exec-* | xfast-exec-*)
# OBSOLETE 
# OBSOLETE # Inputs: current_cpu, sc, FAST_P
# OBSOLETE # Outputs: vpc
# OBSOLETE # vpc contains the address of the next insn to execute
# OBSOLETE 
# OBSOLETE cat <<EOF
# OBSOLETE {
# OBSOLETE #if (! FAST_P && WITH_SEM_SWITCH_FULL) || (FAST_P && WITH_SEM_SWITCH_FAST)
# OBSOLETE #define DEFINE_SWITCH
# OBSOLETE #include "sem-switch.c"
# OBSOLETE #else
# OBSOLETE   vpc = execute (current_cpu, vpc, FAST_P);
# OBSOLETE #endif
# OBSOLETE }
# OBSOLETE EOF
# OBSOLETE 
# OBSOLETE ;;
# OBSOLETE 
# OBSOLETE *)
# OBSOLETE   echo "Invalid argument to mainloop.in: $1" >&2
# OBSOLETE   exit 1
# OBSOLETE   ;;
# OBSOLETE 
# OBSOLETE esac
@


