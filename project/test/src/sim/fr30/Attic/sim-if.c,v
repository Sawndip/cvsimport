head	1.3;
access;
symbols
	gdb_6_3-20041109-release:1.2
	gdb_6_3-branch:1.2.0.66
	gdb_6_3-20041019-branchpoint:1.2
	drow_intercu-merge-20040921:1.2
	drow_intercu-merge-20040915:1.2
	jimb-gdb_6_2-e500-branch:1.2.0.68
	jimb-gdb_6_2-e500-branchpoint:1.2
	gdb_6_2-20040730-release:1.2
	gdb_6_2-branch:1.2.0.64
	gdb_6_2-2004-07-10-gmt-branchpoint:1.2
	gdb_6_1_1-20040616-release:1.2
	gdb_6_1-2004-04-05-release:1.2
	drow_intercu-merge-20040402:1.2
	drow_intercu-merge-20040327:1.2
	ezannoni_pie-20040323-branch:1.2.0.62
	ezannoni_pie-20040323-branchpoint:1.2
	cagney_tramp-20040321-mergepoint:1.2
	cagney_tramp-20040309-branch:1.2.0.60
	cagney_tramp-20040309-branchpoint:1.2
	gdb_6_1-branch:1.2.0.58
	gdb_6_1-2004-03-01-gmt-branchpoint:1.2
	drow_intercu-20040221-branch:1.2.0.56
	drow_intercu-20040221-branchpoint:1.2
	cagney_bfdfile-20040213-branch:1.2.0.54
	cagney_bfdfile-20040213-branchpoint:1.2
	drow-cplus-merge-20040208:1.2
	carlton_dictionary-20040126-merge:1.2
	cagney_bigcore-20040122-branch:1.2.0.52
	cagney_bigcore-20040122-branchpoint:1.2
	drow-cplus-merge-20040113:1.2
	drow-cplus-merge-20031224:1.2
	drow-cplus-merge-20031220:1.2
	carlton_dictionary-20031215-merge:1.2
	drow-cplus-merge-20031214:1.2
	carlton-dictionary-20031111-merge:1.2
	gdb_6_0-2003-10-04-release:1.2
	kettenis_sparc-20030918-branch:1.2.0.50
	kettenis_sparc-20030918-branchpoint:1.2
	carlton_dictionary-20030917-merge:1.2
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.48
	cagney_x86i386-20030821-branch:1.2.0.46
	cagney_x86i386-20030821-branchpoint:1.2
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.2.0.44
	gdb_6_0-2003-06-23-branchpoint:1.2
	jimb-ppc64-linux-20030613-branch:1.2.0.42
	jimb-ppc64-linux-20030613-branchpoint:1.2
	cagney_convert-20030606-branch:1.2.0.40
	cagney_convert-20030606-branchpoint:1.2
	cagney_writestrings-20030508-branch:1.2.0.38
	cagney_writestrings-20030508-branchpoint:1.2
	jimb-ppc64-linux-20030528-branch:1.2.0.36
	jimb-ppc64-linux-20030528-branchpoint:1.2
	carlton_dictionary-20030523-merge:1.2
	cagney_fileio-20030521-branch:1.2.0.34
	cagney_fileio-20030521-branchpoint:1.2
	kettenis_i386newframe-20030517-mergepoint:1.2
	jimb-ppc64-linux-20030509-branch:1.2.0.32
	jimb-ppc64-linux-20030509-branchpoint:1.2
	kettenis_i386newframe-20030504-mergepoint:1.2
	carlton_dictionary-20030430-merge:1.2
	kettenis_i386newframe-20030419-branch:1.2.0.30
	kettenis_i386newframe-20030419-branchpoint:1.2
	carlton_dictionary-20030416-merge:1.2
	cagney_frameaddr-20030409-mergepoint:1.2
	kettenis_i386newframe-20030406-branch:1.2.0.28
	kettenis_i386newframe-20030406-branchpoint:1.2
	cagney_frameaddr-20030403-branchpoint:1.2
	cagney_frameaddr-20030403-branch:1.2.0.26
	cagney_framebase-20030330-mergepoint:1.2
	cagney_framebase-20030326-branch:1.2.0.24
	cagney_framebase-20030326-branchpoint:1.2
	cagney_lazyid-20030317-branch:1.2.0.22
	cagney_lazyid-20030317-branchpoint:1.2
	kettenis-i386newframe-20030316-mergepoint:1.2
	offbyone-20030313-branch:1.2.0.20
	offbyone-20030313-branchpoint:1.2
	kettenis-i386newframe-20030308-branch:1.2.0.18
	kettenis-i386newframe-20030308-branchpoint:1.2
	carlton_dictionary-20030305-merge:1.2
	cagney_offbyone-20030303-branch:1.2.0.16
	cagney_offbyone-20030303-branchpoint:1.2
	carlton_dictionary-20030207-merge:1.2
	interps-20030202-branch:1.2.0.14
	interps-20030202-branchpoint:1.2
	cagney-unwind-20030108-branch:1.2.0.12
	cagney-unwind-20030108-branchpoint:1.2
	carlton_dictionary-20021223-merge:1.2
	gdb_5_3-2002-12-12-release:1.2
	carlton_dictionary-20021115-merge:1.2
	kseitz_interps-20021105-merge:1.2
	kseitz_interps-20021103-merge:1.2
	drow-cplus-merge-20021020:1.2
	drow-cplus-merge-20021025:1.2
	carlton_dictionary-20021025-merge:1.2
	carlton_dictionary-20021011-merge:1.2
	drow-cplus-branch:1.2.0.10
	drow-cplus-branchpoint:1.2
	kseitz_interps-20020930-merge:1.2
	carlton_dictionary-20020927-merge:1.2
	carlton_dictionary-branch:1.2.0.8
	carlton_dictionary-20020920-branchpoint:1.2
	gdb_5_3-branch:1.2.0.6
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.4
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.2
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.1.1.2
	kseitz_interps-20020528-branch:1.1.1.2.0.18
	kseitz_interps-20020528-branchpoint:1.1.1.2
	cagney_regbuf-20020515-branch:1.1.1.2.0.16
	cagney_regbuf-20020515-branchpoint:1.1.1.2
	jimb-macro-020506-branch:1.1.1.2.0.14
	jimb-macro-020506-branchpoint:1.1.1.2
	gdb_5_2-2002-04-29-release:1.1.1.2
	gdb_5_2-branch:1.1.1.2.0.12
	gdb_5_2-2002-03-03-branchpoint:1.1.1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.2
	gdb_5_1_0_1-2002-01-03-release:1.1.1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.2.0.10
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.2
	gdb_5_1-2001-11-21-release:1.1.1.2
	gdb_s390-2001-09-26-branch:1.1.1.2.0.8
	gdb_s390-2001-09-26-branchpoint:1.1.1.2
	gdb_5_1-2001-07-29-branch:1.1.1.2.0.6
	gdb_5_1-2001-07-29-branchpoint:1.1.1.2
	insight-precleanup-2001-01-01:1.1.1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.3
date	2004.11.12.16.45.29;	author cagney;	state dead;
branches;
next	1.2;

1.2
date	2002.07.16.14.30.14;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.35.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.32.17;	author shebs;	state Exp;
branches
	1.1.1.2.18.1;
next	;

1.1.1.2.18.1
date	2002.07.22.21.47.26;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.3
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* d30v, fr30, mn10200, z8k: Delete directory.
@
text
@// OBSOLETE /* Main simulator entry points specific to the FR30.
// OBSOLETE    Copyright (C) 1998, 1999 Free Software Foundation, Inc.
// OBSOLETE    Contributed by Cygnus Solutions.
// OBSOLETE 
// OBSOLETE This file is part of the GNU simulators.
// OBSOLETE 
// OBSOLETE This program is free software; you can redistribute it and/or modify
// OBSOLETE it under the terms of the GNU General Public License as published by
// OBSOLETE the Free Software Foundation; either version 2, or (at your option)
// OBSOLETE any later version.
// OBSOLETE 
// OBSOLETE This program is distributed in the hope that it will be useful,
// OBSOLETE but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE You should have received a copy of the GNU General Public License along
// OBSOLETE with this program; if not, write to the Free Software Foundation, Inc.,
// OBSOLETE 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "sim-main.h"
// OBSOLETE #ifdef HAVE_STDLIB_H
// OBSOLETE #include <stdlib.h>
// OBSOLETE #endif
// OBSOLETE #include "sim-options.h"
// OBSOLETE #include "libiberty.h"
// OBSOLETE #include "bfd.h"
// OBSOLETE 
// OBSOLETE static void free_state (SIM_DESC);
// OBSOLETE static void print_fr30_misc_cpu (SIM_CPU *cpu, int verbose);
// OBSOLETE 
// OBSOLETE /* Records simulator descriptor so utilities like fr30_dump_regs can be
// OBSOLETE    called from gdb.  */
// OBSOLETE SIM_DESC current_state;
// OBSOLETE 
// OBSOLETE /* Cover function of sim_state_free to free the cpu buffers as well.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE free_state (SIM_DESC sd)
// OBSOLETE {
// OBSOLETE   if (STATE_MODULES (sd) != NULL)
// OBSOLETE     sim_module_uninstall (sd);
// OBSOLETE   sim_cpu_free_all (sd);
// OBSOLETE   sim_state_free (sd);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Create an instance of the simulator.  */
// OBSOLETE 
// OBSOLETE SIM_DESC
// OBSOLETE sim_open (kind, callback, abfd, argv)
// OBSOLETE      SIM_OPEN_KIND kind;
// OBSOLETE      host_callback *callback;
// OBSOLETE      struct _bfd *abfd;
// OBSOLETE      char **argv;
// OBSOLETE {
// OBSOLETE   char c;
// OBSOLETE   int i;
// OBSOLETE   SIM_DESC sd = sim_state_alloc (kind, callback);
// OBSOLETE 
// OBSOLETE   /* The cpu data is kept in a separately allocated chunk of memory.  */
// OBSOLETE   if (sim_cpu_alloc_all (sd, 1, cgen_cpu_max_extra_bytes ()) != SIM_RC_OK)
// OBSOLETE     {
// OBSOLETE       free_state (sd);
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE #if 0 /* FIXME: pc is in mach-specific struct */
// OBSOLETE   /* FIXME: watchpoints code shouldn't need this */
// OBSOLETE   {
// OBSOLETE     SIM_CPU *current_cpu = STATE_CPU (sd, 0);
// OBSOLETE     STATE_WATCHPOINTS (sd)->pc = &(PC);
// OBSOLETE     STATE_WATCHPOINTS (sd)->sizeof_pc = sizeof (PC);
// OBSOLETE   }
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE   if (sim_pre_argv_init (sd, argv[0]) != SIM_RC_OK)
// OBSOLETE     {
// OBSOLETE       free_state (sd);
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE #if 0 /* FIXME: 'twould be nice if we could do this */
// OBSOLETE   /* These options override any module options.
// OBSOLETE      Obviously ambiguity should be avoided, however the caller may wish to
// OBSOLETE      augment the meaning of an option.  */
// OBSOLETE   if (extra_options != NULL)
// OBSOLETE     sim_add_option_table (sd, extra_options);
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE   /* getopt will print the error message so we just have to exit if this fails.
// OBSOLETE      FIXME: Hmmm...  in the case of gdb we need getopt to call
// OBSOLETE      print_filtered.  */
// OBSOLETE   if (sim_parse_args (sd, argv) != SIM_RC_OK)
// OBSOLETE     {
// OBSOLETE       free_state (sd);
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE   /* Allocate a handler for the control registers and other devices
// OBSOLETE      if no memory for that range has been allocated by the user.
// OBSOLETE      All are allocated in one chunk to keep things from being
// OBSOLETE      unnecessarily complicated.  */
// OBSOLETE   if (sim_core_read_buffer (sd, NULL, read_map, &c, FR30_DEVICE_ADDR, 1) == 0)
// OBSOLETE     sim_core_attach (sd, NULL,
// OBSOLETE 		     0 /*level*/,
// OBSOLETE 		     access_read_write,
// OBSOLETE 		     0 /*space ???*/,
// OBSOLETE 		     FR30_DEVICE_ADDR, FR30_DEVICE_LEN /*nr_bytes*/,
// OBSOLETE 		     0 /*modulo*/,
// OBSOLETE 		     &fr30_devices,
// OBSOLETE 		     NULL /*buffer*/);
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE   /* Allocate core managed memory if none specified by user.
// OBSOLETE      Use address 4 here in case the user wanted address 0 unmapped.  */
// OBSOLETE   if (sim_core_read_buffer (sd, NULL, read_map, &c, 4, 1) == 0)
// OBSOLETE     sim_do_commandf (sd, "memory region 0,0x%lx", FR30_DEFAULT_MEM_SIZE);
// OBSOLETE 
// OBSOLETE   /* check for/establish the reference program image */
// OBSOLETE   if (sim_analyze_program (sd,
// OBSOLETE 			   (STATE_PROG_ARGV (sd) != NULL
// OBSOLETE 			    ? *STATE_PROG_ARGV (sd)
// OBSOLETE 			    : NULL),
// OBSOLETE 			   abfd) != SIM_RC_OK)
// OBSOLETE     {
// OBSOLETE       free_state (sd);
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Establish any remaining configuration options.  */
// OBSOLETE   if (sim_config (sd) != SIM_RC_OK)
// OBSOLETE     {
// OBSOLETE       free_state (sd);
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (sim_post_argv_init (sd) != SIM_RC_OK)
// OBSOLETE     {
// OBSOLETE       free_state (sd);
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Open a copy of the cpu descriptor table.  */
// OBSOLETE   {
// OBSOLETE     CGEN_CPU_DESC cd = fr30_cgen_cpu_open_1 (STATE_ARCHITECTURE (sd)->printable_name,
// OBSOLETE 					     CGEN_ENDIAN_BIG);
// OBSOLETE     for (i = 0; i < MAX_NR_PROCESSORS; ++i)
// OBSOLETE       {
// OBSOLETE 	SIM_CPU *cpu = STATE_CPU (sd, i);
// OBSOLETE 	CPU_CPU_DESC (cpu) = cd;
// OBSOLETE 	CPU_DISASSEMBLER (cpu) = sim_cgen_disassemble_insn;
// OBSOLETE       }
// OBSOLETE     fr30_cgen_init_dis (cd);
// OBSOLETE   }
// OBSOLETE 
// OBSOLETE   /* Initialize various cgen things not done by common framework.
// OBSOLETE      Must be done after fr30_cgen_cpu_open.  */
// OBSOLETE   cgen_init (sd);
// OBSOLETE 
// OBSOLETE   /* Store in a global so things like sparc32_dump_regs can be invoked
// OBSOLETE      from the gdb command line.  */
// OBSOLETE   current_state = sd;
// OBSOLETE 
// OBSOLETE   return sd;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE sim_close (sd, quitting)
// OBSOLETE      SIM_DESC sd;
// OBSOLETE      int quitting;
// OBSOLETE {
// OBSOLETE   fr30_cgen_cpu_close (CPU_CPU_DESC (STATE_CPU (sd, 0)));
// OBSOLETE   sim_module_uninstall (sd);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE SIM_RC
// OBSOLETE sim_create_inferior (sd, abfd, argv, envp)
// OBSOLETE      SIM_DESC sd;
// OBSOLETE      struct _bfd *abfd;
// OBSOLETE      char **argv;
// OBSOLETE      char **envp;
// OBSOLETE {
// OBSOLETE   SIM_CPU *current_cpu = STATE_CPU (sd, 0);
// OBSOLETE   SIM_ADDR addr;
// OBSOLETE 
// OBSOLETE   if (abfd != NULL)
// OBSOLETE     addr = bfd_get_start_address (abfd);
// OBSOLETE   else
// OBSOLETE     addr = 0;
// OBSOLETE   sim_pc_set (current_cpu, addr);
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE   STATE_ARGV (sd) = sim_copy_argv (argv);
// OBSOLETE   STATE_ENVP (sd) = sim_copy_argv (envp);
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE   return SIM_RC_OK;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE sim_do_command (sd, cmd)
// OBSOLETE      SIM_DESC sd;
// OBSOLETE      char *cmd;
// OBSOLETE { 
// OBSOLETE   if (sim_args_command (sd, cmd) != SIM_RC_OK)
// OBSOLETE     sim_io_eprintf (sd, "Unknown command `%s'\n", cmd);
// OBSOLETE }
@


1.2
log
@Obsolete fr30.
@
text
@@


1.1
log
@Initial revision
@
text
@d1 208
a208 208
/* Main simulator entry points specific to the FR30.
   Copyright (C) 1998, 1999 Free Software Foundation, Inc.
   Contributed by Cygnus Solutions.

This file is part of the GNU simulators.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "sim-main.h"
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#include "sim-options.h"
#include "libiberty.h"
#include "bfd.h"

static void free_state (SIM_DESC);
static void print_fr30_misc_cpu (SIM_CPU *cpu, int verbose);

/* Records simulator descriptor so utilities like fr30_dump_regs can be
   called from gdb.  */
SIM_DESC current_state;

/* Cover function of sim_state_free to free the cpu buffers as well.  */

static void
free_state (SIM_DESC sd)
{
  if (STATE_MODULES (sd) != NULL)
    sim_module_uninstall (sd);
  sim_cpu_free_all (sd);
  sim_state_free (sd);
}

/* Create an instance of the simulator.  */

SIM_DESC
sim_open (kind, callback, abfd, argv)
     SIM_OPEN_KIND kind;
     host_callback *callback;
     struct _bfd *abfd;
     char **argv;
{
  char c;
  int i;
  SIM_DESC sd = sim_state_alloc (kind, callback);

  /* The cpu data is kept in a separately allocated chunk of memory.  */
  if (sim_cpu_alloc_all (sd, 1, cgen_cpu_max_extra_bytes ()) != SIM_RC_OK)
    {
      free_state (sd);
      return 0;
    }

#if 0 /* FIXME: pc is in mach-specific struct */
  /* FIXME: watchpoints code shouldn't need this */
  {
    SIM_CPU *current_cpu = STATE_CPU (sd, 0);
    STATE_WATCHPOINTS (sd)->pc = &(PC);
    STATE_WATCHPOINTS (sd)->sizeof_pc = sizeof (PC);
  }
#endif

  if (sim_pre_argv_init (sd, argv[0]) != SIM_RC_OK)
    {
      free_state (sd);
      return 0;
    }

#if 0 /* FIXME: 'twould be nice if we could do this */
  /* These options override any module options.
     Obviously ambiguity should be avoided, however the caller may wish to
     augment the meaning of an option.  */
  if (extra_options != NULL)
    sim_add_option_table (sd, extra_options);
#endif

  /* getopt will print the error message so we just have to exit if this fails.
     FIXME: Hmmm...  in the case of gdb we need getopt to call
     print_filtered.  */
  if (sim_parse_args (sd, argv) != SIM_RC_OK)
    {
      free_state (sd);
      return 0;
    }

#if 0
  /* Allocate a handler for the control registers and other devices
     if no memory for that range has been allocated by the user.
     All are allocated in one chunk to keep things from being
     unnecessarily complicated.  */
  if (sim_core_read_buffer (sd, NULL, read_map, &c, FR30_DEVICE_ADDR, 1) == 0)
    sim_core_attach (sd, NULL,
		     0 /*level*/,
		     access_read_write,
		     0 /*space ???*/,
		     FR30_DEVICE_ADDR, FR30_DEVICE_LEN /*nr_bytes*/,
		     0 /*modulo*/,
		     &fr30_devices,
		     NULL /*buffer*/);
#endif

  /* Allocate core managed memory if none specified by user.
     Use address 4 here in case the user wanted address 0 unmapped.  */
  if (sim_core_read_buffer (sd, NULL, read_map, &c, 4, 1) == 0)
    sim_do_commandf (sd, "memory region 0,0x%lx", FR30_DEFAULT_MEM_SIZE);

  /* check for/establish the reference program image */
  if (sim_analyze_program (sd,
			   (STATE_PROG_ARGV (sd) != NULL
			    ? *STATE_PROG_ARGV (sd)
			    : NULL),
			   abfd) != SIM_RC_OK)
    {
      free_state (sd);
      return 0;
    }

  /* Establish any remaining configuration options.  */
  if (sim_config (sd) != SIM_RC_OK)
    {
      free_state (sd);
      return 0;
    }

  if (sim_post_argv_init (sd) != SIM_RC_OK)
    {
      free_state (sd);
      return 0;
    }

  /* Open a copy of the cpu descriptor table.  */
  {
    CGEN_CPU_DESC cd = fr30_cgen_cpu_open (STATE_ARCHITECTURE (sd)->mach,
					   CGEN_ENDIAN_BIG);
    for (i = 0; i < MAX_NR_PROCESSORS; ++i)
      {
	SIM_CPU *cpu = STATE_CPU (sd, i);
	CPU_CPU_DESC (cpu) = cd;
	CPU_DISASSEMBLER (cpu) = sim_cgen_disassemble_insn;
      }
    fr30_cgen_init_dis (cd);
  }

  /* Initialize various cgen things not done by common framework.
     Must be done after fr30_cgen_cpu_open.  */
  cgen_init (sd);

  /* Store in a global so things like sparc32_dump_regs can be invoked
     from the gdb command line.  */
  current_state = sd;

  return sd;
}

void
sim_close (sd, quitting)
     SIM_DESC sd;
     int quitting;
{
  fr30_cgen_cpu_close (CPU_CPU_DESC (STATE_CPU (sd, 0)));
  sim_module_uninstall (sd);
}

SIM_RC
sim_create_inferior (sd, abfd, argv, envp)
     SIM_DESC sd;
     struct _bfd *abfd;
     char **argv;
     char **envp;
{
  SIM_CPU *current_cpu = STATE_CPU (sd, 0);
  SIM_ADDR addr;

  if (abfd != NULL)
    addr = bfd_get_start_address (abfd);
  else
    addr = 0;
  sim_pc_set (current_cpu, addr);

#if 0
  STATE_ARGV (sd) = sim_copy_argv (argv);
  STATE_ENVP (sd) = sim_copy_argv (envp);
#endif

  return SIM_RC_OK;
}

void
sim_do_command (sd, cmd)
     SIM_DESC sd;
     char *cmd;
{ 
  if (sim_args_command (sd, cmd) != SIM_RC_OK)
    sim_io_eprintf (sd, "Unknown command `%s'\n", cmd);
}
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d146 2
a147 2
    CGEN_CPU_DESC cd = fr30_cgen_cpu_open_1 (STATE_ARCHITECTURE (sd)->printable_name,
					     CGEN_ENDIAN_BIG);
@


1.1.1.2.18.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d1 208
a208 208
// OBSOLETE /* Main simulator entry points specific to the FR30.
// OBSOLETE    Copyright (C) 1998, 1999 Free Software Foundation, Inc.
// OBSOLETE    Contributed by Cygnus Solutions.
// OBSOLETE 
// OBSOLETE This file is part of the GNU simulators.
// OBSOLETE 
// OBSOLETE This program is free software; you can redistribute it and/or modify
// OBSOLETE it under the terms of the GNU General Public License as published by
// OBSOLETE the Free Software Foundation; either version 2, or (at your option)
// OBSOLETE any later version.
// OBSOLETE 
// OBSOLETE This program is distributed in the hope that it will be useful,
// OBSOLETE but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE You should have received a copy of the GNU General Public License along
// OBSOLETE with this program; if not, write to the Free Software Foundation, Inc.,
// OBSOLETE 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "sim-main.h"
// OBSOLETE #ifdef HAVE_STDLIB_H
// OBSOLETE #include <stdlib.h>
// OBSOLETE #endif
// OBSOLETE #include "sim-options.h"
// OBSOLETE #include "libiberty.h"
// OBSOLETE #include "bfd.h"
// OBSOLETE 
// OBSOLETE static void free_state (SIM_DESC);
// OBSOLETE static void print_fr30_misc_cpu (SIM_CPU *cpu, int verbose);
// OBSOLETE 
// OBSOLETE /* Records simulator descriptor so utilities like fr30_dump_regs can be
// OBSOLETE    called from gdb.  */
// OBSOLETE SIM_DESC current_state;
// OBSOLETE 
// OBSOLETE /* Cover function of sim_state_free to free the cpu buffers as well.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE free_state (SIM_DESC sd)
// OBSOLETE {
// OBSOLETE   if (STATE_MODULES (sd) != NULL)
// OBSOLETE     sim_module_uninstall (sd);
// OBSOLETE   sim_cpu_free_all (sd);
// OBSOLETE   sim_state_free (sd);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Create an instance of the simulator.  */
// OBSOLETE 
// OBSOLETE SIM_DESC
// OBSOLETE sim_open (kind, callback, abfd, argv)
// OBSOLETE      SIM_OPEN_KIND kind;
// OBSOLETE      host_callback *callback;
// OBSOLETE      struct _bfd *abfd;
// OBSOLETE      char **argv;
// OBSOLETE {
// OBSOLETE   char c;
// OBSOLETE   int i;
// OBSOLETE   SIM_DESC sd = sim_state_alloc (kind, callback);
// OBSOLETE 
// OBSOLETE   /* The cpu data is kept in a separately allocated chunk of memory.  */
// OBSOLETE   if (sim_cpu_alloc_all (sd, 1, cgen_cpu_max_extra_bytes ()) != SIM_RC_OK)
// OBSOLETE     {
// OBSOLETE       free_state (sd);
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE #if 0 /* FIXME: pc is in mach-specific struct */
// OBSOLETE   /* FIXME: watchpoints code shouldn't need this */
// OBSOLETE   {
// OBSOLETE     SIM_CPU *current_cpu = STATE_CPU (sd, 0);
// OBSOLETE     STATE_WATCHPOINTS (sd)->pc = &(PC);
// OBSOLETE     STATE_WATCHPOINTS (sd)->sizeof_pc = sizeof (PC);
// OBSOLETE   }
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE   if (sim_pre_argv_init (sd, argv[0]) != SIM_RC_OK)
// OBSOLETE     {
// OBSOLETE       free_state (sd);
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE #if 0 /* FIXME: 'twould be nice if we could do this */
// OBSOLETE   /* These options override any module options.
// OBSOLETE      Obviously ambiguity should be avoided, however the caller may wish to
// OBSOLETE      augment the meaning of an option.  */
// OBSOLETE   if (extra_options != NULL)
// OBSOLETE     sim_add_option_table (sd, extra_options);
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE   /* getopt will print the error message so we just have to exit if this fails.
// OBSOLETE      FIXME: Hmmm...  in the case of gdb we need getopt to call
// OBSOLETE      print_filtered.  */
// OBSOLETE   if (sim_parse_args (sd, argv) != SIM_RC_OK)
// OBSOLETE     {
// OBSOLETE       free_state (sd);
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE   /* Allocate a handler for the control registers and other devices
// OBSOLETE      if no memory for that range has been allocated by the user.
// OBSOLETE      All are allocated in one chunk to keep things from being
// OBSOLETE      unnecessarily complicated.  */
// OBSOLETE   if (sim_core_read_buffer (sd, NULL, read_map, &c, FR30_DEVICE_ADDR, 1) == 0)
// OBSOLETE     sim_core_attach (sd, NULL,
// OBSOLETE 		     0 /*level*/,
// OBSOLETE 		     access_read_write,
// OBSOLETE 		     0 /*space ???*/,
// OBSOLETE 		     FR30_DEVICE_ADDR, FR30_DEVICE_LEN /*nr_bytes*/,
// OBSOLETE 		     0 /*modulo*/,
// OBSOLETE 		     &fr30_devices,
// OBSOLETE 		     NULL /*buffer*/);
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE   /* Allocate core managed memory if none specified by user.
// OBSOLETE      Use address 4 here in case the user wanted address 0 unmapped.  */
// OBSOLETE   if (sim_core_read_buffer (sd, NULL, read_map, &c, 4, 1) == 0)
// OBSOLETE     sim_do_commandf (sd, "memory region 0,0x%lx", FR30_DEFAULT_MEM_SIZE);
// OBSOLETE 
// OBSOLETE   /* check for/establish the reference program image */
// OBSOLETE   if (sim_analyze_program (sd,
// OBSOLETE 			   (STATE_PROG_ARGV (sd) != NULL
// OBSOLETE 			    ? *STATE_PROG_ARGV (sd)
// OBSOLETE 			    : NULL),
// OBSOLETE 			   abfd) != SIM_RC_OK)
// OBSOLETE     {
// OBSOLETE       free_state (sd);
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Establish any remaining configuration options.  */
// OBSOLETE   if (sim_config (sd) != SIM_RC_OK)
// OBSOLETE     {
// OBSOLETE       free_state (sd);
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   if (sim_post_argv_init (sd) != SIM_RC_OK)
// OBSOLETE     {
// OBSOLETE       free_state (sd);
// OBSOLETE       return 0;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Open a copy of the cpu descriptor table.  */
// OBSOLETE   {
// OBSOLETE     CGEN_CPU_DESC cd = fr30_cgen_cpu_open_1 (STATE_ARCHITECTURE (sd)->printable_name,
// OBSOLETE 					     CGEN_ENDIAN_BIG);
// OBSOLETE     for (i = 0; i < MAX_NR_PROCESSORS; ++i)
// OBSOLETE       {
// OBSOLETE 	SIM_CPU *cpu = STATE_CPU (sd, i);
// OBSOLETE 	CPU_CPU_DESC (cpu) = cd;
// OBSOLETE 	CPU_DISASSEMBLER (cpu) = sim_cgen_disassemble_insn;
// OBSOLETE       }
// OBSOLETE     fr30_cgen_init_dis (cd);
// OBSOLETE   }
// OBSOLETE 
// OBSOLETE   /* Initialize various cgen things not done by common framework.
// OBSOLETE      Must be done after fr30_cgen_cpu_open.  */
// OBSOLETE   cgen_init (sd);
// OBSOLETE 
// OBSOLETE   /* Store in a global so things like sparc32_dump_regs can be invoked
// OBSOLETE      from the gdb command line.  */
// OBSOLETE   current_state = sd;
// OBSOLETE 
// OBSOLETE   return sd;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE sim_close (sd, quitting)
// OBSOLETE      SIM_DESC sd;
// OBSOLETE      int quitting;
// OBSOLETE {
// OBSOLETE   fr30_cgen_cpu_close (CPU_CPU_DESC (STATE_CPU (sd, 0)));
// OBSOLETE   sim_module_uninstall (sd);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE SIM_RC
// OBSOLETE sim_create_inferior (sd, abfd, argv, envp)
// OBSOLETE      SIM_DESC sd;
// OBSOLETE      struct _bfd *abfd;
// OBSOLETE      char **argv;
// OBSOLETE      char **envp;
// OBSOLETE {
// OBSOLETE   SIM_CPU *current_cpu = STATE_CPU (sd, 0);
// OBSOLETE   SIM_ADDR addr;
// OBSOLETE 
// OBSOLETE   if (abfd != NULL)
// OBSOLETE     addr = bfd_get_start_address (abfd);
// OBSOLETE   else
// OBSOLETE     addr = 0;
// OBSOLETE   sim_pc_set (current_cpu, addr);
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE   STATE_ARGV (sd) = sim_copy_argv (argv);
// OBSOLETE   STATE_ENVP (sd) = sim_copy_argv (envp);
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE   return SIM_RC_OK;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE sim_do_command (sd, cmd)
// OBSOLETE      SIM_DESC sd;
// OBSOLETE      char *cmd;
// OBSOLETE { 
// OBSOLETE   if (sim_args_command (sd, cmd) != SIM_RC_OK)
// OBSOLETE     sim_io_eprintf (sd, "Unknown command `%s'\n", cmd);
// OBSOLETE }
@


