head	1.3;
access;
symbols
	gdb_6_3-20041109-release:1.2
	gdb_6_3-branch:1.2.0.66
	gdb_6_3-20041019-branchpoint:1.2
	drow_intercu-merge-20040921:1.2
	drow_intercu-merge-20040915:1.2
	jimb-gdb_6_2-e500-branch:1.2.0.68
	jimb-gdb_6_2-e500-branchpoint:1.2
	gdb_6_2-20040730-release:1.2
	gdb_6_2-branch:1.2.0.64
	gdb_6_2-2004-07-10-gmt-branchpoint:1.2
	gdb_6_1_1-20040616-release:1.2
	gdb_6_1-2004-04-05-release:1.2
	drow_intercu-merge-20040402:1.2
	drow_intercu-merge-20040327:1.2
	ezannoni_pie-20040323-branch:1.2.0.62
	ezannoni_pie-20040323-branchpoint:1.2
	cagney_tramp-20040321-mergepoint:1.2
	cagney_tramp-20040309-branch:1.2.0.60
	cagney_tramp-20040309-branchpoint:1.2
	gdb_6_1-branch:1.2.0.58
	gdb_6_1-2004-03-01-gmt-branchpoint:1.2
	drow_intercu-20040221-branch:1.2.0.56
	drow_intercu-20040221-branchpoint:1.2
	cagney_bfdfile-20040213-branch:1.2.0.54
	cagney_bfdfile-20040213-branchpoint:1.2
	drow-cplus-merge-20040208:1.2
	carlton_dictionary-20040126-merge:1.2
	cagney_bigcore-20040122-branch:1.2.0.52
	cagney_bigcore-20040122-branchpoint:1.2
	drow-cplus-merge-20040113:1.2
	drow-cplus-merge-20031224:1.2
	drow-cplus-merge-20031220:1.2
	carlton_dictionary-20031215-merge:1.2
	drow-cplus-merge-20031214:1.2
	carlton-dictionary-20031111-merge:1.2
	gdb_6_0-2003-10-04-release:1.2
	kettenis_sparc-20030918-branch:1.2.0.50
	kettenis_sparc-20030918-branchpoint:1.2
	carlton_dictionary-20030917-merge:1.2
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.48
	cagney_x86i386-20030821-branch:1.2.0.46
	cagney_x86i386-20030821-branchpoint:1.2
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.2.0.44
	gdb_6_0-2003-06-23-branchpoint:1.2
	jimb-ppc64-linux-20030613-branch:1.2.0.42
	jimb-ppc64-linux-20030613-branchpoint:1.2
	cagney_convert-20030606-branch:1.2.0.40
	cagney_convert-20030606-branchpoint:1.2
	cagney_writestrings-20030508-branch:1.2.0.38
	cagney_writestrings-20030508-branchpoint:1.2
	jimb-ppc64-linux-20030528-branch:1.2.0.36
	jimb-ppc64-linux-20030528-branchpoint:1.2
	carlton_dictionary-20030523-merge:1.2
	cagney_fileio-20030521-branch:1.2.0.34
	cagney_fileio-20030521-branchpoint:1.2
	kettenis_i386newframe-20030517-mergepoint:1.2
	jimb-ppc64-linux-20030509-branch:1.2.0.32
	jimb-ppc64-linux-20030509-branchpoint:1.2
	kettenis_i386newframe-20030504-mergepoint:1.2
	carlton_dictionary-20030430-merge:1.2
	kettenis_i386newframe-20030419-branch:1.2.0.30
	kettenis_i386newframe-20030419-branchpoint:1.2
	carlton_dictionary-20030416-merge:1.2
	cagney_frameaddr-20030409-mergepoint:1.2
	kettenis_i386newframe-20030406-branch:1.2.0.28
	kettenis_i386newframe-20030406-branchpoint:1.2
	cagney_frameaddr-20030403-branchpoint:1.2
	cagney_frameaddr-20030403-branch:1.2.0.26
	cagney_framebase-20030330-mergepoint:1.2
	cagney_framebase-20030326-branch:1.2.0.24
	cagney_framebase-20030326-branchpoint:1.2
	cagney_lazyid-20030317-branch:1.2.0.22
	cagney_lazyid-20030317-branchpoint:1.2
	kettenis-i386newframe-20030316-mergepoint:1.2
	offbyone-20030313-branch:1.2.0.20
	offbyone-20030313-branchpoint:1.2
	kettenis-i386newframe-20030308-branch:1.2.0.18
	kettenis-i386newframe-20030308-branchpoint:1.2
	carlton_dictionary-20030305-merge:1.2
	cagney_offbyone-20030303-branch:1.2.0.16
	cagney_offbyone-20030303-branchpoint:1.2
	carlton_dictionary-20030207-merge:1.2
	interps-20030202-branch:1.2.0.14
	interps-20030202-branchpoint:1.2
	cagney-unwind-20030108-branch:1.2.0.12
	cagney-unwind-20030108-branchpoint:1.2
	carlton_dictionary-20021223-merge:1.2
	gdb_5_3-2002-12-12-release:1.2
	carlton_dictionary-20021115-merge:1.2
	kseitz_interps-20021105-merge:1.2
	kseitz_interps-20021103-merge:1.2
	drow-cplus-merge-20021020:1.2
	drow-cplus-merge-20021025:1.2
	carlton_dictionary-20021025-merge:1.2
	carlton_dictionary-20021011-merge:1.2
	drow-cplus-branch:1.2.0.10
	drow-cplus-branchpoint:1.2
	kseitz_interps-20020930-merge:1.2
	carlton_dictionary-20020927-merge:1.2
	carlton_dictionary-branch:1.2.0.8
	carlton_dictionary-20020920-branchpoint:1.2
	gdb_5_3-branch:1.2.0.6
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.4
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.2
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.1.1.3
	kseitz_interps-20020528-branch:1.1.1.3.0.18
	kseitz_interps-20020528-branchpoint:1.1.1.3
	cagney_regbuf-20020515-branch:1.1.1.3.0.16
	cagney_regbuf-20020515-branchpoint:1.1.1.3
	jimb-macro-020506-branch:1.1.1.3.0.14
	jimb-macro-020506-branchpoint:1.1.1.3
	gdb_5_2-2002-04-29-release:1.1.1.3
	gdb_5_2-branch:1.1.1.3.0.12
	gdb_5_2-2002-03-03-branchpoint:1.1.1.3
	gdb_5_1_1-2002-01-24-release:1.1.1.3
	gdb_5_1_0_1-2002-01-03-release:1.1.1.3
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.3.0.10
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.3
	gdb_5_1-2001-11-21-release:1.1.1.3
	gdb_s390-2001-09-26-branch:1.1.1.3.0.8
	gdb_s390-2001-09-26-branchpoint:1.1.1.3
	gdb_5_1-2001-07-29-branch:1.1.1.3.0.6
	gdb_5_1-2001-07-29-branchpoint:1.1.1.3
	insight-precleanup-2001-01-01:1.1.1.3
	gdb-premipsmulti-2000-06-06-branch:1.1.1.3.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.3
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.3
date	2004.11.12.16.45.30;	author cagney;	state dead;
branches;
next	1.2;

1.2
date	2002.07.16.14.30.14;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.35.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.32.18;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.10.05.23.13.38;	author jsm;	state Exp;
branches
	1.1.1.3.18.1;
next	;

1.1.1.3.18.1
date	2002.07.22.21.47.26;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.3
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* d30v, fr30, mn10200, z8k: Delete directory.
@
text
@// OBSOLETE /* fr30 exception, interrupt, and trap (EIT) support
// OBSOLETE    Copyright (C) 1998, 1999 Free Software Foundation, Inc.
// OBSOLETE    Contributed by Cygnus Solutions.
// OBSOLETE 
// OBSOLETE This file is part of the GNU simulators.
// OBSOLETE 
// OBSOLETE This program is free software; you can redistribute it and/or modify
// OBSOLETE it under the terms of the GNU General Public License as published by
// OBSOLETE the Free Software Foundation; either version 2, or (at your option)
// OBSOLETE any later version.
// OBSOLETE 
// OBSOLETE This program is distributed in the hope that it will be useful,
// OBSOLETE but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE You should have received a copy of the GNU General Public License along
// OBSOLETE with this program; if not, write to the Free Software Foundation, Inc.,
// OBSOLETE 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "sim-main.h"
// OBSOLETE #include "targ-vals.h"
// OBSOLETE #include "cgen-engine.h"
// OBSOLETE 
// OBSOLETE /* The semantic code invokes this for invalid (unrecognized) instructions.  */
// OBSOLETE 
// OBSOLETE SEM_PC
// OBSOLETE sim_engine_invalid_insn (SIM_CPU *current_cpu, IADDR cia, SEM_PC vpc)
// OBSOLETE {
// OBSOLETE   SIM_DESC sd = CPU_STATE (current_cpu);
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE   if (STATE_ENVIRONMENT (sd) == OPERATING_ENVIRONMENT)
// OBSOLETE     {
// OBSOLETE       h_bsm_set (current_cpu, h_sm_get (current_cpu));
// OBSOLETE       h_bie_set (current_cpu, h_ie_get (current_cpu));
// OBSOLETE       h_bcond_set (current_cpu, h_cond_get (current_cpu));
// OBSOLETE       /* sm not changed */
// OBSOLETE       h_ie_set (current_cpu, 0);
// OBSOLETE       h_cond_set (current_cpu, 0);
// OBSOLETE 
// OBSOLETE       h_bpc_set (current_cpu, cia);
// OBSOLETE 
// OBSOLETE       sim_engine_restart (CPU_STATE (current_cpu), current_cpu, NULL,
// OBSOLETE 			  EIT_RSVD_INSN_ADDR);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE #endif
// OBSOLETE     sim_engine_halt (sd, current_cpu, NULL, cia, sim_stopped, SIM_SIGILL);
// OBSOLETE   return vpc;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Process an address exception.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fr30_core_signal (SIM_DESC sd, SIM_CPU *current_cpu, sim_cia cia,
// OBSOLETE 		  unsigned int map, int nr_bytes, address_word addr,
// OBSOLETE 		  transfer_type transfer, sim_core_signals sig)
// OBSOLETE {
// OBSOLETE #if 0
// OBSOLETE   if (STATE_ENVIRONMENT (sd) == OPERATING_ENVIRONMENT)
// OBSOLETE     {
// OBSOLETE       h_bsm_set (current_cpu, h_sm_get (current_cpu));
// OBSOLETE       h_bie_set (current_cpu, h_ie_get (current_cpu));
// OBSOLETE       h_bcond_set (current_cpu, h_cond_get (current_cpu));
// OBSOLETE       /* sm not changed */
// OBSOLETE       h_ie_set (current_cpu, 0);
// OBSOLETE       h_cond_set (current_cpu, 0);
// OBSOLETE 
// OBSOLETE       h_bpc_set (current_cpu, cia);
// OBSOLETE 
// OBSOLETE       sim_engine_restart (CPU_STATE (current_cpu), current_cpu, NULL,
// OBSOLETE 			  EIT_ADDR_EXCP_ADDR);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE #endif
// OBSOLETE     sim_core_signal (sd, current_cpu, cia, map, nr_bytes, addr,
// OBSOLETE 		     transfer, sig);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Read/write functions for system call interface.  */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE syscall_read_mem (host_callback *cb, struct cb_syscall *sc,
// OBSOLETE 		  unsigned long taddr, char *buf, int bytes)
// OBSOLETE {
// OBSOLETE   SIM_DESC sd = (SIM_DESC) sc->p1;
// OBSOLETE   SIM_CPU *cpu = (SIM_CPU *) sc->p2;
// OBSOLETE 
// OBSOLETE   return sim_core_read_buffer (sd, cpu, read_map, buf, taddr, bytes);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE syscall_write_mem (host_callback *cb, struct cb_syscall *sc,
// OBSOLETE 		   unsigned long taddr, const char *buf, int bytes)
// OBSOLETE {
// OBSOLETE   SIM_DESC sd = (SIM_DESC) sc->p1;
// OBSOLETE   SIM_CPU *cpu = (SIM_CPU *) sc->p2;
// OBSOLETE 
// OBSOLETE   return sim_core_write_buffer (sd, cpu, write_map, buf, taddr, bytes);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Subroutine of fr30_int to save the PS and PC and setup for INT and INTE.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE setup_int (SIM_CPU *current_cpu, PCADDR pc)
// OBSOLETE {
// OBSOLETE   USI ssp = fr30bf_h_dr_get (current_cpu, H_DR_SSP);
// OBSOLETE   USI ps = fr30bf_h_ps_get (current_cpu);
// OBSOLETE 
// OBSOLETE   ssp -= 4;
// OBSOLETE   SETMEMSI (current_cpu, pc, ssp, ps);
// OBSOLETE   ssp -= 4;
// OBSOLETE   SETMEMSI (current_cpu, pc, ssp, pc + 2);
// OBSOLETE   fr30bf_h_dr_set (current_cpu, H_DR_SSP, ssp);
// OBSOLETE   fr30bf_h_sbit_set (current_cpu, 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Trap support.
// OBSOLETE    The result is the pc address to continue at.
// OBSOLETE    Preprocessing like saving the various registers has already been done.  */
// OBSOLETE 
// OBSOLETE USI
// OBSOLETE fr30_int (SIM_CPU *current_cpu, PCADDR pc, int num)
// OBSOLETE {
// OBSOLETE   SIM_DESC sd = CPU_STATE (current_cpu);
// OBSOLETE   host_callback *cb = STATE_CALLBACK (sd);
// OBSOLETE 
// OBSOLETE #ifdef SIM_HAVE_BREAKPOINTS
// OBSOLETE   /* Check for breakpoints "owned" by the simulator first, regardless
// OBSOLETE      of --environment.  */
// OBSOLETE   if (num == TRAP_BREAKPOINT)
// OBSOLETE     {
// OBSOLETE       /* First try sim-break.c.  If it's a breakpoint the simulator "owns"
// OBSOLETE 	 it doesn't return.  Otherwise it returns and let's us try.  */
// OBSOLETE       sim_handle_breakpoint (sd, current_cpu, pc);
// OBSOLETE       /* Fall through.  */
// OBSOLETE     }
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE   if (STATE_ENVIRONMENT (sd) == OPERATING_ENVIRONMENT)
// OBSOLETE     {
// OBSOLETE       /* The new pc is the trap vector entry.
// OBSOLETE 	 We assume there's a branch there to some handler.  */
// OBSOLETE       USI new_pc;
// OBSOLETE       setup_int (current_cpu, pc);
// OBSOLETE       fr30bf_h_ibit_set (current_cpu, 0);
// OBSOLETE       new_pc = GETMEMSI (current_cpu, pc,
// OBSOLETE 			 fr30bf_h_dr_get (current_cpu, H_DR_TBR)
// OBSOLETE 			 + 1024 - ((num + 1) * 4));
// OBSOLETE       return new_pc;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   switch (num)
// OBSOLETE     {
// OBSOLETE     case TRAP_SYSCALL :
// OBSOLETE       {
// OBSOLETE 	/* TODO: find out what the ABI for this is */
// OBSOLETE 	CB_SYSCALL s;
// OBSOLETE 
// OBSOLETE 	CB_SYSCALL_INIT (&s);
// OBSOLETE 	s.func = fr30bf_h_gr_get (current_cpu, 0);
// OBSOLETE 	s.arg1 = fr30bf_h_gr_get (current_cpu, 4);
// OBSOLETE 	s.arg2 = fr30bf_h_gr_get (current_cpu, 5);
// OBSOLETE 	s.arg3 = fr30bf_h_gr_get (current_cpu, 6);
// OBSOLETE 
// OBSOLETE 	if (s.func == TARGET_SYS_exit)
// OBSOLETE 	  {
// OBSOLETE 	    sim_engine_halt (sd, current_cpu, NULL, pc, sim_exited, s.arg1);
// OBSOLETE 	  }
// OBSOLETE 
// OBSOLETE 	s.p1 = (PTR) sd;
// OBSOLETE 	s.p2 = (PTR) current_cpu;
// OBSOLETE 	s.read_mem = syscall_read_mem;
// OBSOLETE 	s.write_mem = syscall_write_mem;
// OBSOLETE 	cb_syscall (cb, &s);
// OBSOLETE 	fr30bf_h_gr_set (current_cpu, 2, s.errcode); /* TODO: check this one */
// OBSOLETE 	fr30bf_h_gr_set (current_cpu, 4, s.result);
// OBSOLETE 	fr30bf_h_gr_set (current_cpu, 1, s.result2); /* TODO: check this one */
// OBSOLETE 	break;
// OBSOLETE       }
// OBSOLETE 
// OBSOLETE     case TRAP_BREAKPOINT:
// OBSOLETE       sim_engine_halt (sd, current_cpu, NULL, pc,
// OBSOLETE 		       sim_stopped, SIM_SIGTRAP);
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     default :
// OBSOLETE       {
// OBSOLETE 	USI new_pc;
// OBSOLETE 	setup_int (current_cpu, pc);
// OBSOLETE 	fr30bf_h_ibit_set (current_cpu, 0);
// OBSOLETE 	new_pc = GETMEMSI (current_cpu, pc,
// OBSOLETE 			   fr30bf_h_dr_get (current_cpu, H_DR_TBR)
// OBSOLETE 			   + 1024 - ((num + 1) * 4));
// OBSOLETE 	return new_pc;
// OBSOLETE       }
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Fake an "reti" insn.
// OBSOLETE      Since we didn't push anything to stack, all we need to do is
// OBSOLETE      update pc.  */
// OBSOLETE   return pc + 2;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE USI
// OBSOLETE fr30_inte (SIM_CPU *current_cpu, PCADDR pc, int num)
// OBSOLETE {
// OBSOLETE   /* The new pc is the trap #9 vector entry.
// OBSOLETE      We assume there's a branch there to some handler.  */
// OBSOLETE   USI new_pc;
// OBSOLETE   setup_int (current_cpu, pc);
// OBSOLETE   fr30bf_h_ilm_set (current_cpu, 4);
// OBSOLETE   new_pc = GETMEMSI (current_cpu, pc,
// OBSOLETE 		     fr30bf_h_dr_get (current_cpu, H_DR_TBR)
// OBSOLETE 		     + 1024 - ((9 + 1) * 4));
// OBSOLETE   return new_pc;
// OBSOLETE }
@


1.2
log
@Obsolete fr30.
@
text
@@


1.1
log
@Initial revision
@
text
@d1 218
a218 217
/* fr30 exception, interrupt, and trap (EIT) support
   Copyright (C) 1998, 1999 Free Software Foundation, Inc.
   Contributed by Cygnus Solutions.

This file is part of the GNU simulators.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "sim-main.h"
#include "targ-vals.h"
#include "cgen-engine.h"

/* The semantic code invokes this for invalid (unrecognized) instructions.  */

void
sim_engine_invalid_insn (SIM_CPU *current_cpu, IADDR cia)
{
  SIM_DESC sd = CPU_STATE (current_cpu);

#if 0
  if (STATE_ENVIRONMENT (sd) == OPERATING_ENVIRONMENT)
    {
      h_bsm_set (current_cpu, h_sm_get (current_cpu));
      h_bie_set (current_cpu, h_ie_get (current_cpu));
      h_bcond_set (current_cpu, h_cond_get (current_cpu));
      /* sm not changed */
      h_ie_set (current_cpu, 0);
      h_cond_set (current_cpu, 0);

      h_bpc_set (current_cpu, cia);

      sim_engine_restart (CPU_STATE (current_cpu), current_cpu, NULL,
			  EIT_RSVD_INSN_ADDR);
    }
  else
#endif
    sim_engine_halt (sd, current_cpu, NULL, cia, sim_stopped, SIM_SIGILL);
}

/* Process an address exception.  */

void
fr30_core_signal (SIM_DESC sd, SIM_CPU *current_cpu, sim_cia cia,
		  unsigned int map, int nr_bytes, address_word addr,
		  transfer_type transfer, sim_core_signals sig)
{
#if 0
  if (STATE_ENVIRONMENT (sd) == OPERATING_ENVIRONMENT)
    {
      h_bsm_set (current_cpu, h_sm_get (current_cpu));
      h_bie_set (current_cpu, h_ie_get (current_cpu));
      h_bcond_set (current_cpu, h_cond_get (current_cpu));
      /* sm not changed */
      h_ie_set (current_cpu, 0);
      h_cond_set (current_cpu, 0);

      h_bpc_set (current_cpu, cia);

      sim_engine_restart (CPU_STATE (current_cpu), current_cpu, NULL,
			  EIT_ADDR_EXCP_ADDR);
    }
  else
#endif
    sim_core_signal (sd, current_cpu, cia, map, nr_bytes, addr,
		     transfer, sig);
}

/* Read/write functions for system call interface.  */

static int
syscall_read_mem (host_callback *cb, struct cb_syscall *sc,
		  unsigned long taddr, char *buf, int bytes)
{
  SIM_DESC sd = (SIM_DESC) sc->p1;
  SIM_CPU *cpu = (SIM_CPU *) sc->p2;

  return sim_core_read_buffer (sd, cpu, read_map, buf, taddr, bytes);
}

static int
syscall_write_mem (host_callback *cb, struct cb_syscall *sc,
		   unsigned long taddr, const char *buf, int bytes)
{
  SIM_DESC sd = (SIM_DESC) sc->p1;
  SIM_CPU *cpu = (SIM_CPU *) sc->p2;

  return sim_core_write_buffer (sd, cpu, write_map, buf, taddr, bytes);
}

/* Subroutine of fr30_int to save the PS and PC and setup for INT and INTE.  */

static void
setup_int (SIM_CPU *current_cpu, PCADDR pc)
{
  USI ssp = a_fr30_h_dr_get (current_cpu, H_DR_SSP);
  USI ps = a_fr30_h_ps_get (current_cpu);

  ssp -= 4;
  SETMEMSI (current_cpu, pc, ssp, ps);
  ssp -= 4;
  SETMEMSI (current_cpu, pc, ssp, pc + 2);
  a_fr30_h_dr_set (current_cpu, H_DR_SSP, ssp);
  a_fr30_h_sbit_set (current_cpu, 0);
}

/* Trap support.
   The result is the pc address to continue at.
   Preprocessing like saving the various registers has already been done.  */

USI
fr30_int (SIM_CPU *current_cpu, PCADDR pc, int num)
{
  SIM_DESC sd = CPU_STATE (current_cpu);
  host_callback *cb = STATE_CALLBACK (sd);

#ifdef SIM_HAVE_BREAKPOINTS
  /* Check for breakpoints "owned" by the simulator first, regardless
     of --environment.  */
  if (num == TRAP_BREAKPOINT)
    {
      /* First try sim-break.c.  If it's a breakpoint the simulator "owns"
	 it doesn't return.  Otherwise it returns and let's us try.  */
      sim_handle_breakpoint (sd, current_cpu, pc);
      /* Fall through.  */
    }
#endif

  if (STATE_ENVIRONMENT (sd) == OPERATING_ENVIRONMENT)
    {
      /* The new pc is the trap vector entry.
	 We assume there's a branch there to some handler.  */
      USI new_pc;
      setup_int (current_cpu, pc);
      a_fr30_h_ibit_set (current_cpu, 0);
      new_pc = GETMEMSI (current_cpu, pc,
			 a_fr30_h_dr_get (current_cpu, H_DR_TBR)
			 + 1024 - ((num + 1) * 4));
      return new_pc;
    }

  switch (num)
    {
    case TRAP_SYSCALL :
      {
	/* TODO: find out what the ABI for this is */
	CB_SYSCALL s;

	CB_SYSCALL_INIT (&s);
	s.func = a_fr30_h_gr_get (current_cpu, 0);
	s.arg1 = a_fr30_h_gr_get (current_cpu, 4);
	s.arg2 = a_fr30_h_gr_get (current_cpu, 5);
	s.arg3 = a_fr30_h_gr_get (current_cpu, 6);

	if (s.func == TARGET_SYS_exit)
	  {
	    sim_engine_halt (sd, current_cpu, NULL, pc, sim_exited, s.arg1);
	  }

	s.p1 = (PTR) sd;
	s.p2 = (PTR) current_cpu;
	s.read_mem = syscall_read_mem;
	s.write_mem = syscall_write_mem;
	cb_syscall (cb, &s);
	a_fr30_h_gr_set (current_cpu, 2, s.errcode); /* TODO: check this one */
	a_fr30_h_gr_set (current_cpu, 4, s.result);
	a_fr30_h_gr_set (current_cpu, 1, s.result2); /* TODO: check this one */
	break;
      }

    case TRAP_BREAKPOINT:
      sim_engine_halt (sd, current_cpu, NULL, pc,
		       sim_stopped, SIM_SIGTRAP);
      break;

    default :
      {
	USI new_pc;
	setup_int (current_cpu, pc);
	a_fr30_h_ibit_set (current_cpu, 0);
	new_pc = GETMEMSI (current_cpu, pc,
			   a_fr30_h_dr_get (current_cpu, H_DR_TBR)
			   + 1024 - ((num + 1) * 4));
	return new_pc;
      }
    }

  /* Fake an "reti" insn.
     Since we didn't push anything to stack, all we need to do is
     update pc.  */
  return pc + 2;
}

USI
fr30_inte (SIM_CPU *current_cpu, PCADDR pc, int num)
{
  /* The new pc is the trap #9 vector entry.
     We assume there's a branch there to some handler.  */
  USI new_pc;
  setup_int (current_cpu, pc);
  a_fr30_h_ilm_set (current_cpu, 4);
  new_pc = GETMEMSI (current_cpu, pc,
		     a_fr30_h_dr_get (current_cpu, H_DR_TBR)
		     + 1024 - ((9 + 1) * 4));
  return new_pc;
}
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d107 2
a108 2
  USI ssp = fr30bf_h_dr_get (current_cpu, H_DR_SSP);
  USI ps = fr30bf_h_ps_get (current_cpu);
d114 2
a115 2
  fr30bf_h_dr_set (current_cpu, H_DR_SSP, ssp);
  fr30bf_h_sbit_set (current_cpu, 0);
d146 1
a146 1
      fr30bf_h_ibit_set (current_cpu, 0);
d148 1
a148 1
			 fr30bf_h_dr_get (current_cpu, H_DR_TBR)
d161 4
a164 4
	s.func = fr30bf_h_gr_get (current_cpu, 0);
	s.arg1 = fr30bf_h_gr_get (current_cpu, 4);
	s.arg2 = fr30bf_h_gr_get (current_cpu, 5);
	s.arg3 = fr30bf_h_gr_get (current_cpu, 6);
d176 3
a178 3
	fr30bf_h_gr_set (current_cpu, 2, s.errcode); /* TODO: check this one */
	fr30bf_h_gr_set (current_cpu, 4, s.result);
	fr30bf_h_gr_set (current_cpu, 1, s.result2); /* TODO: check this one */
d191 1
a191 1
	fr30bf_h_ibit_set (current_cpu, 0);
d193 1
a193 1
			   fr30bf_h_dr_get (current_cpu, H_DR_TBR)
d212 1
a212 1
  fr30bf_h_ilm_set (current_cpu, 4);
d214 1
a214 1
		     fr30bf_h_dr_get (current_cpu, H_DR_TBR)
@


1.1.1.3
log
@import gdb-1999-10-04 snapshot
@
text
@d27 2
a28 2
SEM_PC
sim_engine_invalid_insn (SIM_CPU *current_cpu, IADDR cia, SEM_PC vpc)
a49 1
  return vpc;
@


1.1.1.3.18.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d1 218
a218 218
// OBSOLETE /* fr30 exception, interrupt, and trap (EIT) support
// OBSOLETE    Copyright (C) 1998, 1999 Free Software Foundation, Inc.
// OBSOLETE    Contributed by Cygnus Solutions.
// OBSOLETE 
// OBSOLETE This file is part of the GNU simulators.
// OBSOLETE 
// OBSOLETE This program is free software; you can redistribute it and/or modify
// OBSOLETE it under the terms of the GNU General Public License as published by
// OBSOLETE the Free Software Foundation; either version 2, or (at your option)
// OBSOLETE any later version.
// OBSOLETE 
// OBSOLETE This program is distributed in the hope that it will be useful,
// OBSOLETE but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE You should have received a copy of the GNU General Public License along
// OBSOLETE with this program; if not, write to the Free Software Foundation, Inc.,
// OBSOLETE 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #include "sim-main.h"
// OBSOLETE #include "targ-vals.h"
// OBSOLETE #include "cgen-engine.h"
// OBSOLETE 
// OBSOLETE /* The semantic code invokes this for invalid (unrecognized) instructions.  */
// OBSOLETE 
// OBSOLETE SEM_PC
// OBSOLETE sim_engine_invalid_insn (SIM_CPU *current_cpu, IADDR cia, SEM_PC vpc)
// OBSOLETE {
// OBSOLETE   SIM_DESC sd = CPU_STATE (current_cpu);
// OBSOLETE 
// OBSOLETE #if 0
// OBSOLETE   if (STATE_ENVIRONMENT (sd) == OPERATING_ENVIRONMENT)
// OBSOLETE     {
// OBSOLETE       h_bsm_set (current_cpu, h_sm_get (current_cpu));
// OBSOLETE       h_bie_set (current_cpu, h_ie_get (current_cpu));
// OBSOLETE       h_bcond_set (current_cpu, h_cond_get (current_cpu));
// OBSOLETE       /* sm not changed */
// OBSOLETE       h_ie_set (current_cpu, 0);
// OBSOLETE       h_cond_set (current_cpu, 0);
// OBSOLETE 
// OBSOLETE       h_bpc_set (current_cpu, cia);
// OBSOLETE 
// OBSOLETE       sim_engine_restart (CPU_STATE (current_cpu), current_cpu, NULL,
// OBSOLETE 			  EIT_RSVD_INSN_ADDR);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE #endif
// OBSOLETE     sim_engine_halt (sd, current_cpu, NULL, cia, sim_stopped, SIM_SIGILL);
// OBSOLETE   return vpc;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Process an address exception.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fr30_core_signal (SIM_DESC sd, SIM_CPU *current_cpu, sim_cia cia,
// OBSOLETE 		  unsigned int map, int nr_bytes, address_word addr,
// OBSOLETE 		  transfer_type transfer, sim_core_signals sig)
// OBSOLETE {
// OBSOLETE #if 0
// OBSOLETE   if (STATE_ENVIRONMENT (sd) == OPERATING_ENVIRONMENT)
// OBSOLETE     {
// OBSOLETE       h_bsm_set (current_cpu, h_sm_get (current_cpu));
// OBSOLETE       h_bie_set (current_cpu, h_ie_get (current_cpu));
// OBSOLETE       h_bcond_set (current_cpu, h_cond_get (current_cpu));
// OBSOLETE       /* sm not changed */
// OBSOLETE       h_ie_set (current_cpu, 0);
// OBSOLETE       h_cond_set (current_cpu, 0);
// OBSOLETE 
// OBSOLETE       h_bpc_set (current_cpu, cia);
// OBSOLETE 
// OBSOLETE       sim_engine_restart (CPU_STATE (current_cpu), current_cpu, NULL,
// OBSOLETE 			  EIT_ADDR_EXCP_ADDR);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE #endif
// OBSOLETE     sim_core_signal (sd, current_cpu, cia, map, nr_bytes, addr,
// OBSOLETE 		     transfer, sig);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Read/write functions for system call interface.  */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE syscall_read_mem (host_callback *cb, struct cb_syscall *sc,
// OBSOLETE 		  unsigned long taddr, char *buf, int bytes)
// OBSOLETE {
// OBSOLETE   SIM_DESC sd = (SIM_DESC) sc->p1;
// OBSOLETE   SIM_CPU *cpu = (SIM_CPU *) sc->p2;
// OBSOLETE 
// OBSOLETE   return sim_core_read_buffer (sd, cpu, read_map, buf, taddr, bytes);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE syscall_write_mem (host_callback *cb, struct cb_syscall *sc,
// OBSOLETE 		   unsigned long taddr, const char *buf, int bytes)
// OBSOLETE {
// OBSOLETE   SIM_DESC sd = (SIM_DESC) sc->p1;
// OBSOLETE   SIM_CPU *cpu = (SIM_CPU *) sc->p2;
// OBSOLETE 
// OBSOLETE   return sim_core_write_buffer (sd, cpu, write_map, buf, taddr, bytes);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Subroutine of fr30_int to save the PS and PC and setup for INT and INTE.  */
// OBSOLETE 
// OBSOLETE static void
// OBSOLETE setup_int (SIM_CPU *current_cpu, PCADDR pc)
// OBSOLETE {
// OBSOLETE   USI ssp = fr30bf_h_dr_get (current_cpu, H_DR_SSP);
// OBSOLETE   USI ps = fr30bf_h_ps_get (current_cpu);
// OBSOLETE 
// OBSOLETE   ssp -= 4;
// OBSOLETE   SETMEMSI (current_cpu, pc, ssp, ps);
// OBSOLETE   ssp -= 4;
// OBSOLETE   SETMEMSI (current_cpu, pc, ssp, pc + 2);
// OBSOLETE   fr30bf_h_dr_set (current_cpu, H_DR_SSP, ssp);
// OBSOLETE   fr30bf_h_sbit_set (current_cpu, 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Trap support.
// OBSOLETE    The result is the pc address to continue at.
// OBSOLETE    Preprocessing like saving the various registers has already been done.  */
// OBSOLETE 
// OBSOLETE USI
// OBSOLETE fr30_int (SIM_CPU *current_cpu, PCADDR pc, int num)
// OBSOLETE {
// OBSOLETE   SIM_DESC sd = CPU_STATE (current_cpu);
// OBSOLETE   host_callback *cb = STATE_CALLBACK (sd);
// OBSOLETE 
// OBSOLETE #ifdef SIM_HAVE_BREAKPOINTS
// OBSOLETE   /* Check for breakpoints "owned" by the simulator first, regardless
// OBSOLETE      of --environment.  */
// OBSOLETE   if (num == TRAP_BREAKPOINT)
// OBSOLETE     {
// OBSOLETE       /* First try sim-break.c.  If it's a breakpoint the simulator "owns"
// OBSOLETE 	 it doesn't return.  Otherwise it returns and let's us try.  */
// OBSOLETE       sim_handle_breakpoint (sd, current_cpu, pc);
// OBSOLETE       /* Fall through.  */
// OBSOLETE     }
// OBSOLETE #endif
// OBSOLETE 
// OBSOLETE   if (STATE_ENVIRONMENT (sd) == OPERATING_ENVIRONMENT)
// OBSOLETE     {
// OBSOLETE       /* The new pc is the trap vector entry.
// OBSOLETE 	 We assume there's a branch there to some handler.  */
// OBSOLETE       USI new_pc;
// OBSOLETE       setup_int (current_cpu, pc);
// OBSOLETE       fr30bf_h_ibit_set (current_cpu, 0);
// OBSOLETE       new_pc = GETMEMSI (current_cpu, pc,
// OBSOLETE 			 fr30bf_h_dr_get (current_cpu, H_DR_TBR)
// OBSOLETE 			 + 1024 - ((num + 1) * 4));
// OBSOLETE       return new_pc;
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   switch (num)
// OBSOLETE     {
// OBSOLETE     case TRAP_SYSCALL :
// OBSOLETE       {
// OBSOLETE 	/* TODO: find out what the ABI for this is */
// OBSOLETE 	CB_SYSCALL s;
// OBSOLETE 
// OBSOLETE 	CB_SYSCALL_INIT (&s);
// OBSOLETE 	s.func = fr30bf_h_gr_get (current_cpu, 0);
// OBSOLETE 	s.arg1 = fr30bf_h_gr_get (current_cpu, 4);
// OBSOLETE 	s.arg2 = fr30bf_h_gr_get (current_cpu, 5);
// OBSOLETE 	s.arg3 = fr30bf_h_gr_get (current_cpu, 6);
// OBSOLETE 
// OBSOLETE 	if (s.func == TARGET_SYS_exit)
// OBSOLETE 	  {
// OBSOLETE 	    sim_engine_halt (sd, current_cpu, NULL, pc, sim_exited, s.arg1);
// OBSOLETE 	  }
// OBSOLETE 
// OBSOLETE 	s.p1 = (PTR) sd;
// OBSOLETE 	s.p2 = (PTR) current_cpu;
// OBSOLETE 	s.read_mem = syscall_read_mem;
// OBSOLETE 	s.write_mem = syscall_write_mem;
// OBSOLETE 	cb_syscall (cb, &s);
// OBSOLETE 	fr30bf_h_gr_set (current_cpu, 2, s.errcode); /* TODO: check this one */
// OBSOLETE 	fr30bf_h_gr_set (current_cpu, 4, s.result);
// OBSOLETE 	fr30bf_h_gr_set (current_cpu, 1, s.result2); /* TODO: check this one */
// OBSOLETE 	break;
// OBSOLETE       }
// OBSOLETE 
// OBSOLETE     case TRAP_BREAKPOINT:
// OBSOLETE       sim_engine_halt (sd, current_cpu, NULL, pc,
// OBSOLETE 		       sim_stopped, SIM_SIGTRAP);
// OBSOLETE       break;
// OBSOLETE 
// OBSOLETE     default :
// OBSOLETE       {
// OBSOLETE 	USI new_pc;
// OBSOLETE 	setup_int (current_cpu, pc);
// OBSOLETE 	fr30bf_h_ibit_set (current_cpu, 0);
// OBSOLETE 	new_pc = GETMEMSI (current_cpu, pc,
// OBSOLETE 			   fr30bf_h_dr_get (current_cpu, H_DR_TBR)
// OBSOLETE 			   + 1024 - ((num + 1) * 4));
// OBSOLETE 	return new_pc;
// OBSOLETE       }
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* Fake an "reti" insn.
// OBSOLETE      Since we didn't push anything to stack, all we need to do is
// OBSOLETE      update pc.  */
// OBSOLETE   return pc + 2;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE USI
// OBSOLETE fr30_inte (SIM_CPU *current_cpu, PCADDR pc, int num)
// OBSOLETE {
// OBSOLETE   /* The new pc is the trap #9 vector entry.
// OBSOLETE      We assume there's a branch there to some handler.  */
// OBSOLETE   USI new_pc;
// OBSOLETE   setup_int (current_cpu, pc);
// OBSOLETE   fr30bf_h_ilm_set (current_cpu, 4);
// OBSOLETE   new_pc = GETMEMSI (current_cpu, pc,
// OBSOLETE 		     fr30bf_h_dr_get (current_cpu, H_DR_TBR)
// OBSOLETE 		     + 1024 - ((9 + 1) * 4));
// OBSOLETE   return new_pc;
// OBSOLETE }
@


