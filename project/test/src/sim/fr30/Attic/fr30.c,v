head	1.3;
access;
symbols
	gdb_6_3-20041109-release:1.2
	gdb_6_3-branch:1.2.0.66
	gdb_6_3-20041019-branchpoint:1.2
	drow_intercu-merge-20040921:1.2
	drow_intercu-merge-20040915:1.2
	jimb-gdb_6_2-e500-branch:1.2.0.68
	jimb-gdb_6_2-e500-branchpoint:1.2
	gdb_6_2-20040730-release:1.2
	gdb_6_2-branch:1.2.0.64
	gdb_6_2-2004-07-10-gmt-branchpoint:1.2
	gdb_6_1_1-20040616-release:1.2
	gdb_6_1-2004-04-05-release:1.2
	drow_intercu-merge-20040402:1.2
	drow_intercu-merge-20040327:1.2
	ezannoni_pie-20040323-branch:1.2.0.62
	ezannoni_pie-20040323-branchpoint:1.2
	cagney_tramp-20040321-mergepoint:1.2
	cagney_tramp-20040309-branch:1.2.0.60
	cagney_tramp-20040309-branchpoint:1.2
	gdb_6_1-branch:1.2.0.58
	gdb_6_1-2004-03-01-gmt-branchpoint:1.2
	drow_intercu-20040221-branch:1.2.0.56
	drow_intercu-20040221-branchpoint:1.2
	cagney_bfdfile-20040213-branch:1.2.0.54
	cagney_bfdfile-20040213-branchpoint:1.2
	drow-cplus-merge-20040208:1.2
	carlton_dictionary-20040126-merge:1.2
	cagney_bigcore-20040122-branch:1.2.0.52
	cagney_bigcore-20040122-branchpoint:1.2
	drow-cplus-merge-20040113:1.2
	drow-cplus-merge-20031224:1.2
	drow-cplus-merge-20031220:1.2
	carlton_dictionary-20031215-merge:1.2
	drow-cplus-merge-20031214:1.2
	carlton-dictionary-20031111-merge:1.2
	gdb_6_0-2003-10-04-release:1.2
	kettenis_sparc-20030918-branch:1.2.0.50
	kettenis_sparc-20030918-branchpoint:1.2
	carlton_dictionary-20030917-merge:1.2
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.48
	cagney_x86i386-20030821-branch:1.2.0.46
	cagney_x86i386-20030821-branchpoint:1.2
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.2.0.44
	gdb_6_0-2003-06-23-branchpoint:1.2
	jimb-ppc64-linux-20030613-branch:1.2.0.42
	jimb-ppc64-linux-20030613-branchpoint:1.2
	cagney_convert-20030606-branch:1.2.0.40
	cagney_convert-20030606-branchpoint:1.2
	cagney_writestrings-20030508-branch:1.2.0.38
	cagney_writestrings-20030508-branchpoint:1.2
	jimb-ppc64-linux-20030528-branch:1.2.0.36
	jimb-ppc64-linux-20030528-branchpoint:1.2
	carlton_dictionary-20030523-merge:1.2
	cagney_fileio-20030521-branch:1.2.0.34
	cagney_fileio-20030521-branchpoint:1.2
	kettenis_i386newframe-20030517-mergepoint:1.2
	jimb-ppc64-linux-20030509-branch:1.2.0.32
	jimb-ppc64-linux-20030509-branchpoint:1.2
	kettenis_i386newframe-20030504-mergepoint:1.2
	carlton_dictionary-20030430-merge:1.2
	kettenis_i386newframe-20030419-branch:1.2.0.30
	kettenis_i386newframe-20030419-branchpoint:1.2
	carlton_dictionary-20030416-merge:1.2
	cagney_frameaddr-20030409-mergepoint:1.2
	kettenis_i386newframe-20030406-branch:1.2.0.28
	kettenis_i386newframe-20030406-branchpoint:1.2
	cagney_frameaddr-20030403-branchpoint:1.2
	cagney_frameaddr-20030403-branch:1.2.0.26
	cagney_framebase-20030330-mergepoint:1.2
	cagney_framebase-20030326-branch:1.2.0.24
	cagney_framebase-20030326-branchpoint:1.2
	cagney_lazyid-20030317-branch:1.2.0.22
	cagney_lazyid-20030317-branchpoint:1.2
	kettenis-i386newframe-20030316-mergepoint:1.2
	offbyone-20030313-branch:1.2.0.20
	offbyone-20030313-branchpoint:1.2
	kettenis-i386newframe-20030308-branch:1.2.0.18
	kettenis-i386newframe-20030308-branchpoint:1.2
	carlton_dictionary-20030305-merge:1.2
	cagney_offbyone-20030303-branch:1.2.0.16
	cagney_offbyone-20030303-branchpoint:1.2
	carlton_dictionary-20030207-merge:1.2
	interps-20030202-branch:1.2.0.14
	interps-20030202-branchpoint:1.2
	cagney-unwind-20030108-branch:1.2.0.12
	cagney-unwind-20030108-branchpoint:1.2
	carlton_dictionary-20021223-merge:1.2
	gdb_5_3-2002-12-12-release:1.2
	carlton_dictionary-20021115-merge:1.2
	kseitz_interps-20021105-merge:1.2
	kseitz_interps-20021103-merge:1.2
	drow-cplus-merge-20021020:1.2
	drow-cplus-merge-20021025:1.2
	carlton_dictionary-20021025-merge:1.2
	carlton_dictionary-20021011-merge:1.2
	drow-cplus-branch:1.2.0.10
	drow-cplus-branchpoint:1.2
	kseitz_interps-20020930-merge:1.2
	carlton_dictionary-20020927-merge:1.2
	carlton_dictionary-branch:1.2.0.8
	carlton_dictionary-20020920-branchpoint:1.2
	gdb_5_3-branch:1.2.0.6
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.4
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.2
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.1.1.2
	kseitz_interps-20020528-branch:1.1.1.2.0.18
	kseitz_interps-20020528-branchpoint:1.1.1.2
	cagney_regbuf-20020515-branch:1.1.1.2.0.16
	cagney_regbuf-20020515-branchpoint:1.1.1.2
	jimb-macro-020506-branch:1.1.1.2.0.14
	jimb-macro-020506-branchpoint:1.1.1.2
	gdb_5_2-2002-04-29-release:1.1.1.2
	gdb_5_2-branch:1.1.1.2.0.12
	gdb_5_2-2002-03-03-branchpoint:1.1.1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.2
	gdb_5_1_0_1-2002-01-03-release:1.1.1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.2.0.10
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.2
	gdb_5_1-2001-11-21-release:1.1.1.2
	gdb_s390-2001-09-26-branch:1.1.1.2.0.8
	gdb_s390-2001-09-26-branchpoint:1.1.1.2
	gdb_5_1-2001-07-29-branch:1.1.1.2.0.6
	gdb_5_1-2001-07-29-branchpoint:1.1.1.2
	insight-precleanup-2001-01-01:1.1.1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.3
date	2004.11.12.16.45.27;	author cagney;	state dead;
branches;
next	1.2;

1.2
date	2002.07.16.14.30.14;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.35.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.32.13;	author shebs;	state Exp;
branches
	1.1.1.2.18.1;
next	;

1.1.1.2.18.1
date	2002.07.22.21.47.26;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.3
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* d30v, fr30, mn10200, z8k: Delete directory.
@
text
@// OBSOLETE /* fr30 simulator support code
// OBSOLETE    Copyright (C) 1998, 1999 Free Software Foundation, Inc.
// OBSOLETE    Contributed by Cygnus Solutions.
// OBSOLETE 
// OBSOLETE This file is part of the GNU simulators.
// OBSOLETE 
// OBSOLETE This program is free software; you can redistribute it and/or modify
// OBSOLETE it under the terms of the GNU General Public License as published by
// OBSOLETE the Free Software Foundation; either version 2, or (at your option)
// OBSOLETE any later version.
// OBSOLETE 
// OBSOLETE This program is distributed in the hope that it will be useful,
// OBSOLETE but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE You should have received a copy of the GNU General Public License along
// OBSOLETE with this program; if not, write to the Free Software Foundation, Inc.,
// OBSOLETE 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #define WANT_CPU
// OBSOLETE #define WANT_CPU_FR30BF
// OBSOLETE 
// OBSOLETE #include "sim-main.h"
// OBSOLETE #include "cgen-mem.h"
// OBSOLETE #include "cgen-ops.h"
// OBSOLETE 
// OBSOLETE /* Convert gdb dedicated register number to actual dr reg number.  */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE decode_gdb_dr_regnum (int gdb_regnum)
// OBSOLETE {
// OBSOLETE   switch (gdb_regnum)
// OBSOLETE     {
// OBSOLETE     case TBR_REGNUM : return H_DR_TBR;
// OBSOLETE     case RP_REGNUM : return H_DR_RP;
// OBSOLETE     case SSP_REGNUM : return H_DR_SSP;
// OBSOLETE     case USP_REGNUM : return H_DR_USP;
// OBSOLETE     case MDH_REGNUM : return H_DR_MDH;
// OBSOLETE     case MDL_REGNUM : return H_DR_MDL;
// OBSOLETE     }
// OBSOLETE   abort ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* The contents of BUF are in target byte order.  */
// OBSOLETE 
// OBSOLETE int
// OBSOLETE fr30bf_fetch_register (SIM_CPU *current_cpu, int rn, unsigned char *buf, int len)
// OBSOLETE {
// OBSOLETE   if (rn < 16)
// OBSOLETE     SETTWI (buf, fr30bf_h_gr_get (current_cpu, rn));
// OBSOLETE   else
// OBSOLETE     switch (rn)
// OBSOLETE       {
// OBSOLETE       case PC_REGNUM :
// OBSOLETE 	SETTWI (buf, fr30bf_h_pc_get (current_cpu));
// OBSOLETE 	break;
// OBSOLETE       case PS_REGNUM :
// OBSOLETE 	SETTWI (buf, fr30bf_h_ps_get (current_cpu));
// OBSOLETE 	break;
// OBSOLETE       case TBR_REGNUM :
// OBSOLETE       case RP_REGNUM :
// OBSOLETE       case SSP_REGNUM :
// OBSOLETE       case USP_REGNUM :
// OBSOLETE       case MDH_REGNUM :
// OBSOLETE       case MDL_REGNUM :
// OBSOLETE 	SETTWI (buf, fr30bf_h_dr_get (current_cpu,
// OBSOLETE 				      decode_gdb_dr_regnum (rn)));
// OBSOLETE 	break;
// OBSOLETE       default :
// OBSOLETE 	return 0;
// OBSOLETE       }
// OBSOLETE 
// OBSOLETE   return -1; /*FIXME*/
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* The contents of BUF are in target byte order.  */
// OBSOLETE 
// OBSOLETE int
// OBSOLETE fr30bf_store_register (SIM_CPU *current_cpu, int rn, unsigned char *buf, int len)
// OBSOLETE {
// OBSOLETE   if (rn < 16)
// OBSOLETE     fr30bf_h_gr_set (current_cpu, rn, GETTWI (buf));
// OBSOLETE   else
// OBSOLETE     switch (rn)
// OBSOLETE       {
// OBSOLETE       case PC_REGNUM :
// OBSOLETE 	fr30bf_h_pc_set (current_cpu, GETTWI (buf));
// OBSOLETE 	break;
// OBSOLETE       case PS_REGNUM :
// OBSOLETE 	fr30bf_h_ps_set (current_cpu, GETTWI (buf));
// OBSOLETE 	break;
// OBSOLETE       case TBR_REGNUM :
// OBSOLETE       case RP_REGNUM :
// OBSOLETE       case SSP_REGNUM :
// OBSOLETE       case USP_REGNUM :
// OBSOLETE       case MDH_REGNUM :
// OBSOLETE       case MDL_REGNUM :
// OBSOLETE 	fr30bf_h_dr_set (current_cpu,
// OBSOLETE 			 decode_gdb_dr_regnum (rn),
// OBSOLETE 			 GETTWI (buf));
// OBSOLETE 	break;
// OBSOLETE       default :
// OBSOLETE 	return 0;
// OBSOLETE       }
// OBSOLETE 
// OBSOLETE   return -1; /*FIXME*/
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Cover fns to access the ccr bits.  */
// OBSOLETE 
// OBSOLETE BI
// OBSOLETE fr30bf_h_sbit_get_handler (SIM_CPU *current_cpu)
// OBSOLETE {
// OBSOLETE   return CPU (h_sbit);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fr30bf_h_sbit_set_handler (SIM_CPU *current_cpu, BI newval)
// OBSOLETE {
// OBSOLETE   int old_sbit = CPU (h_sbit);
// OBSOLETE   int new_sbit = (newval != 0);
// OBSOLETE 
// OBSOLETE   CPU (h_sbit) = new_sbit;
// OBSOLETE 
// OBSOLETE   /* When switching stack modes, update the registers.  */
// OBSOLETE   if (old_sbit != new_sbit)
// OBSOLETE     {
// OBSOLETE       if (old_sbit)
// OBSOLETE 	{
// OBSOLETE 	  /* Switching user -> system.  */
// OBSOLETE 	  CPU (h_dr[H_DR_USP]) = CPU (h_gr[H_GR_SP]);
// OBSOLETE 	  CPU (h_gr[H_GR_SP]) = CPU (h_dr[H_DR_SSP]);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  /* Switching system -> user.  */
// OBSOLETE 	  CPU (h_dr[H_DR_SSP]) = CPU (h_gr[H_GR_SP]);
// OBSOLETE 	  CPU (h_gr[H_GR_SP]) = CPU (h_dr[H_DR_USP]);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* TODO: r15 interlock */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Cover fns to access the ccr bits.  */
// OBSOLETE 
// OBSOLETE UQI
// OBSOLETE fr30bf_h_ccr_get_handler (SIM_CPU *current_cpu)
// OBSOLETE {
// OBSOLETE   int ccr = (  (GET_H_CBIT () << 0)
// OBSOLETE 	     | (GET_H_VBIT () << 1)
// OBSOLETE 	     | (GET_H_ZBIT () << 2)
// OBSOLETE 	     | (GET_H_NBIT () << 3)
// OBSOLETE 	     | (GET_H_IBIT () << 4)
// OBSOLETE 	     | (GET_H_SBIT () << 5));
// OBSOLETE 
// OBSOLETE   return ccr;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fr30bf_h_ccr_set_handler (SIM_CPU *current_cpu, UQI newval)
// OBSOLETE {
// OBSOLETE   int ccr = newval & 0x3f;
// OBSOLETE 
// OBSOLETE   SET_H_CBIT ((ccr & 1) != 0);
// OBSOLETE   SET_H_VBIT ((ccr & 2) != 0);
// OBSOLETE   SET_H_ZBIT ((ccr & 4) != 0);
// OBSOLETE   SET_H_NBIT ((ccr & 8) != 0);
// OBSOLETE   SET_H_IBIT ((ccr & 0x10) != 0);
// OBSOLETE   SET_H_SBIT ((ccr & 0x20) != 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Cover fns to access the scr bits.  */
// OBSOLETE 
// OBSOLETE UQI
// OBSOLETE fr30bf_h_scr_get_handler (SIM_CPU *current_cpu)
// OBSOLETE {
// OBSOLETE   int scr = (  (GET_H_TBIT () << 0)
// OBSOLETE 	     | (GET_H_D0BIT () << 1)
// OBSOLETE 	     | (GET_H_D1BIT () << 2));
// OBSOLETE   return scr;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fr30bf_h_scr_set_handler (SIM_CPU *current_cpu, UQI newval)
// OBSOLETE {
// OBSOLETE   int scr = newval & 7;
// OBSOLETE 
// OBSOLETE   SET_H_TBIT  ((scr & 1) != 0);
// OBSOLETE   SET_H_D0BIT ((scr & 2) != 0);
// OBSOLETE   SET_H_D1BIT ((scr & 4) != 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Cover fns to access the ilm bits.  */
// OBSOLETE 
// OBSOLETE UQI
// OBSOLETE fr30bf_h_ilm_get_handler (SIM_CPU *current_cpu)
// OBSOLETE {
// OBSOLETE   return CPU (h_ilm);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fr30bf_h_ilm_set_handler (SIM_CPU *current_cpu, UQI newval)
// OBSOLETE {
// OBSOLETE   int ilm = newval & 0x1f;
// OBSOLETE   int current_ilm = CPU (h_ilm);
// OBSOLETE 
// OBSOLETE   /* We can only set new ilm values < 16 if the current ilm is < 16.  Otherwise
// OBSOLETE      we add 16 to the value we are given.  */
// OBSOLETE   if (current_ilm >= 16 && ilm < 16)
// OBSOLETE     ilm += 16;
// OBSOLETE 
// OBSOLETE   CPU (h_ilm) = ilm;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Cover fns to access the ps register.  */
// OBSOLETE 
// OBSOLETE USI
// OBSOLETE fr30bf_h_ps_get_handler (SIM_CPU *current_cpu)
// OBSOLETE {
// OBSOLETE   int ccr = GET_H_CCR ();
// OBSOLETE   int scr = GET_H_SCR ();
// OBSOLETE   int ilm = GET_H_ILM ();
// OBSOLETE 
// OBSOLETE   return ccr | (scr << 8) | (ilm << 16);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fr30bf_h_ps_set_handler (SIM_CPU *current_cpu, USI newval)
// OBSOLETE {
// OBSOLETE   int ccr = newval & 0xff;
// OBSOLETE   int scr = (newval >> 8) & 7;
// OBSOLETE   int ilm = (newval >> 16) & 0x1f;
// OBSOLETE 
// OBSOLETE   SET_H_CCR (ccr);
// OBSOLETE   SET_H_SCR (scr);
// OBSOLETE   SET_H_ILM (ilm);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Cover fns to access the dedicated registers.  */
// OBSOLETE 
// OBSOLETE SI
// OBSOLETE fr30bf_h_dr_get_handler (SIM_CPU *current_cpu, UINT dr)
// OBSOLETE {
// OBSOLETE   switch (dr)
// OBSOLETE     {
// OBSOLETE     case H_DR_SSP :
// OBSOLETE       if (! GET_H_SBIT ())
// OBSOLETE 	return GET_H_GR (H_GR_SP);
// OBSOLETE       else
// OBSOLETE 	return CPU (h_dr[H_DR_SSP]);
// OBSOLETE     case H_DR_USP :
// OBSOLETE       if (GET_H_SBIT ())
// OBSOLETE 	return GET_H_GR (H_GR_SP);
// OBSOLETE       else
// OBSOLETE 	return CPU (h_dr[H_DR_USP]);
// OBSOLETE     case H_DR_TBR :
// OBSOLETE     case H_DR_RP :
// OBSOLETE     case H_DR_MDH :
// OBSOLETE     case H_DR_MDL :
// OBSOLETE       return CPU (h_dr[dr]);
// OBSOLETE     }
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fr30bf_h_dr_set_handler (SIM_CPU *current_cpu, UINT dr, SI newval)
// OBSOLETE {
// OBSOLETE   switch (dr)
// OBSOLETE     {
// OBSOLETE     case H_DR_SSP :
// OBSOLETE       if (! GET_H_SBIT ())
// OBSOLETE 	SET_H_GR (H_GR_SP, newval);
// OBSOLETE       else
// OBSOLETE 	CPU (h_dr[H_DR_SSP]) = newval;
// OBSOLETE       break;
// OBSOLETE     case H_DR_USP :
// OBSOLETE       if (GET_H_SBIT ())
// OBSOLETE 	SET_H_GR (H_GR_SP, newval);
// OBSOLETE       else
// OBSOLETE 	CPU (h_dr[H_DR_USP]) = newval;
// OBSOLETE       break;
// OBSOLETE     case H_DR_TBR :
// OBSOLETE     case H_DR_RP :
// OBSOLETE     case H_DR_MDH :
// OBSOLETE     case H_DR_MDL :
// OBSOLETE       CPU (h_dr[dr]) = newval;
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #if WITH_PROFILE_MODEL_P
// OBSOLETE 
// OBSOLETE /* FIXME: Some of these should be inline or macros.  Later.  */
// OBSOLETE 
// OBSOLETE /* Initialize cycle counting for an insn.
// OBSOLETE    FIRST_P is non-zero if this is the first insn in a set of parallel
// OBSOLETE    insns.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fr30bf_model_insn_before (SIM_CPU *cpu, int first_p)
// OBSOLETE {
// OBSOLETE   MODEL_FR30_1_DATA *d = CPU_MODEL_DATA (cpu);
// OBSOLETE   d->load_regs_pending = 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Record the cycles computed for an insn.
// OBSOLETE    LAST_P is non-zero if this is the last insn in a set of parallel insns,
// OBSOLETE    and we update the total cycle count.
// OBSOLETE    CYCLES is the cycle count of the insn.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fr30bf_model_insn_after (SIM_CPU *cpu, int last_p, int cycles)
// OBSOLETE {
// OBSOLETE   PROFILE_DATA *p = CPU_PROFILE_DATA (cpu);
// OBSOLETE   MODEL_FR30_1_DATA *d = CPU_MODEL_DATA (cpu);
// OBSOLETE 
// OBSOLETE   PROFILE_MODEL_TOTAL_CYCLES (p) += cycles;
// OBSOLETE   PROFILE_MODEL_CUR_INSN_CYCLES (p) = cycles;
// OBSOLETE   d->load_regs = d->load_regs_pending;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static INLINE int
// OBSOLETE check_load_stall (SIM_CPU *cpu, int regno)
// OBSOLETE {
// OBSOLETE   const MODEL_FR30_1_DATA *d = CPU_MODEL_DATA (cpu);
// OBSOLETE   UINT load_regs = d->load_regs;
// OBSOLETE 
// OBSOLETE   if (regno != -1
// OBSOLETE       && (load_regs & (1 << regno)) != 0)
// OBSOLETE     {
// OBSOLETE       PROFILE_DATA *p = CPU_PROFILE_DATA (cpu);
// OBSOLETE       ++ PROFILE_MODEL_LOAD_STALL_CYCLES (p);
// OBSOLETE       if (TRACE_INSN_P (cpu))
// OBSOLETE 	cgen_trace_printf (cpu, " ; Load stall.");
// OBSOLETE       return 1;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE fr30bf_model_fr30_1_u_exec (SIM_CPU *cpu, const IDESC *idesc,
// OBSOLETE 			    int unit_num, int referenced,
// OBSOLETE 			    INT in_Ri, INT in_Rj, INT out_Ri)
// OBSOLETE {
// OBSOLETE   int cycles = idesc->timing->units[unit_num].done;
// OBSOLETE   cycles += check_load_stall (cpu, in_Ri);
// OBSOLETE   cycles += check_load_stall (cpu, in_Rj);
// OBSOLETE   return cycles;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE fr30bf_model_fr30_1_u_cti (SIM_CPU *cpu, const IDESC *idesc,
// OBSOLETE 			   int unit_num, int referenced,
// OBSOLETE 			   INT in_Ri)
// OBSOLETE {
// OBSOLETE   PROFILE_DATA *p = CPU_PROFILE_DATA (cpu);
// OBSOLETE   /* (1 << 1): The pc is the 2nd element in inputs, outputs.
// OBSOLETE      ??? can be cleaned up */
// OBSOLETE   int taken_p = (referenced & (1 << 1)) != 0;
// OBSOLETE   int cycles = idesc->timing->units[unit_num].done;
// OBSOLETE   int delay_slot_p = CGEN_ATTR_VALUE (NULL, idesc->attrs, CGEN_INSN_DELAY_SLOT);
// OBSOLETE 
// OBSOLETE   cycles += check_load_stall (cpu, in_Ri);
// OBSOLETE   if (taken_p)
// OBSOLETE     {
// OBSOLETE       /* ??? Handling cti's without delay slots this way will run afoul of
// OBSOLETE 	 accurate system simulation.  Later.  */
// OBSOLETE       if (! delay_slot_p)
// OBSOLETE 	{
// OBSOLETE 	  ++cycles;
// OBSOLETE 	  ++PROFILE_MODEL_CTI_STALL_CYCLES (p);
// OBSOLETE 	}
// OBSOLETE       ++PROFILE_MODEL_TAKEN_COUNT (p);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     ++PROFILE_MODEL_UNTAKEN_COUNT (p);
// OBSOLETE 
// OBSOLETE   return cycles;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE fr30bf_model_fr30_1_u_load (SIM_CPU *cpu, const IDESC *idesc,
// OBSOLETE 			    int unit_num, int referenced,
// OBSOLETE 			    INT in_Rj, INT out_Ri)
// OBSOLETE {
// OBSOLETE   MODEL_FR30_1_DATA *d = CPU_MODEL_DATA (cpu);
// OBSOLETE   int cycles = idesc->timing->units[unit_num].done;
// OBSOLETE   d->load_regs_pending |= 1 << out_Ri;
// OBSOLETE   cycles += check_load_stall (cpu, in_Rj);
// OBSOLETE   return cycles;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE fr30bf_model_fr30_1_u_store (SIM_CPU *cpu, const IDESC *idesc,
// OBSOLETE 			     int unit_num, int referenced,
// OBSOLETE 			     INT in_Ri, INT in_Rj)
// OBSOLETE {
// OBSOLETE   int cycles = idesc->timing->units[unit_num].done;
// OBSOLETE   cycles += check_load_stall (cpu, in_Ri);
// OBSOLETE   cycles += check_load_stall (cpu, in_Rj);
// OBSOLETE   return cycles;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE fr30bf_model_fr30_1_u_ldm (SIM_CPU *cpu, const IDESC *idesc,
// OBSOLETE 			   int unit_num, int referenced,
// OBSOLETE 			   INT reglist)
// OBSOLETE {
// OBSOLETE   return idesc->timing->units[unit_num].done;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE fr30bf_model_fr30_1_u_stm (SIM_CPU *cpu, const IDESC *idesc,
// OBSOLETE 			   int unit_num, int referenced,
// OBSOLETE 			   INT reglist)
// OBSOLETE {
// OBSOLETE   return idesc->timing->units[unit_num].done;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #endif /* WITH_PROFILE_MODEL_P */
@


1.2
log
@Obsolete fr30.
@
text
@@


1.1
log
@Initial revision
@
text
@d1 423
a423 423
/* fr30 simulator support code
   Copyright (C) 1998, 1999 Free Software Foundation, Inc.
   Contributed by Cygnus Solutions.

This file is part of the GNU simulators.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#define WANT_CPU
#define WANT_CPU_FR30BF

#include "sim-main.h"
#include "cgen-mem.h"
#include "cgen-ops.h"

/* Convert gdb dedicated register number to actual dr reg number.  */

static int
decode_gdb_dr_regnum (int gdb_regnum)
{
  switch (gdb_regnum)
    {
    case TBR_REGNUM : return H_DR_TBR;
    case RP_REGNUM : return H_DR_RP;
    case SSP_REGNUM : return H_DR_SSP;
    case USP_REGNUM : return H_DR_USP;
    case MDH_REGNUM : return H_DR_MDH;
    case MDL_REGNUM : return H_DR_MDL;
    }
  abort ();
}

/* The contents of BUF are in target byte order.  */

int
fr30bf_fetch_register (SIM_CPU *current_cpu, int rn, unsigned char *buf, int len)
{
  if (rn < 16)
    SETTWI (buf, a_fr30_h_gr_get (current_cpu, rn));
  else
    switch (rn)
      {
      case PC_REGNUM :
	SETTWI (buf, a_fr30_h_pc_get (current_cpu));
	break;
      case PS_REGNUM :
	SETTWI (buf, a_fr30_h_ps_get (current_cpu));
	break;
      case TBR_REGNUM :
      case RP_REGNUM :
      case SSP_REGNUM :
      case USP_REGNUM :
      case MDH_REGNUM :
      case MDL_REGNUM :
	SETTWI (buf, a_fr30_h_dr_get (current_cpu,
				      decode_gdb_dr_regnum (rn)));
	break;
      default :
	return 0;
      }

  return -1; /*FIXME*/
}

/* The contents of BUF are in target byte order.  */

int
fr30bf_store_register (SIM_CPU *current_cpu, int rn, unsigned char *buf, int len)
{
  if (rn < 16)
    a_fr30_h_gr_set (current_cpu, rn, GETTWI (buf));
  else
    switch (rn)
      {
      case PC_REGNUM :
	a_fr30_h_pc_set (current_cpu, GETTWI (buf));
	break;
      case PS_REGNUM :
	a_fr30_h_ps_set (current_cpu, GETTWI (buf));
	break;
      case TBR_REGNUM :
      case RP_REGNUM :
      case SSP_REGNUM :
      case USP_REGNUM :
      case MDH_REGNUM :
      case MDL_REGNUM :
	a_fr30_h_dr_set (current_cpu,
			 decode_gdb_dr_regnum (rn),
			 GETTWI (buf));
	break;
      default :
	return 0;
      }

  return -1; /*FIXME*/
}

/* Cover fns to access the ccr bits.  */

BI
fr30bf_h_sbit_get_handler (SIM_CPU *current_cpu)
{
  return CPU (h_sbit);
}

void
fr30bf_h_sbit_set_handler (SIM_CPU *current_cpu, BI newval)
{
  int old_sbit = CPU (h_sbit);
  int new_sbit = (newval != 0);

  CPU (h_sbit) = new_sbit;

  /* When switching stack modes, update the registers.  */
  if (old_sbit != new_sbit)
    {
      if (old_sbit)
	{
	  /* Switching user -> system.  */
	  CPU (h_dr[H_DR_USP]) = CPU (h_gr[H_GR_SP]);
	  CPU (h_gr[H_GR_SP]) = CPU (h_dr[H_DR_SSP]);
	}
      else
	{
	  /* Switching system -> user.  */
	  CPU (h_dr[H_DR_SSP]) = CPU (h_gr[H_GR_SP]);
	  CPU (h_gr[H_GR_SP]) = CPU (h_dr[H_DR_USP]);
	}
    }

  /* TODO: r15 interlock */
}

/* Cover fns to access the ccr bits.  */

UQI
fr30bf_h_ccr_get_handler (SIM_CPU *current_cpu)
{
  int ccr = (  (GET_H_CBIT () << 0)
	     | (GET_H_VBIT () << 1)
	     | (GET_H_ZBIT () << 2)
	     | (GET_H_NBIT () << 3)
	     | (GET_H_IBIT () << 4)
	     | (GET_H_SBIT () << 5));

  return ccr;
}

void
fr30bf_h_ccr_set_handler (SIM_CPU *current_cpu, UQI newval)
{
  int ccr = newval & 0x3f;

  SET_H_CBIT ((ccr & 1) != 0);
  SET_H_VBIT ((ccr & 2) != 0);
  SET_H_ZBIT ((ccr & 4) != 0);
  SET_H_NBIT ((ccr & 8) != 0);
  SET_H_IBIT ((ccr & 0x10) != 0);
  SET_H_SBIT ((ccr & 0x20) != 0);
}

/* Cover fns to access the scr bits.  */

UQI
fr30bf_h_scr_get_handler (SIM_CPU *current_cpu)
{
  int scr = (  (GET_H_TBIT () << 0)
	     | (GET_H_D0BIT () << 1)
	     | (GET_H_D1BIT () << 2));
  return scr;
}

void
fr30bf_h_scr_set_handler (SIM_CPU *current_cpu, UQI newval)
{
  int scr = newval & 7;

  SET_H_TBIT  ((scr & 1) != 0);
  SET_H_D0BIT ((scr & 2) != 0);
  SET_H_D1BIT ((scr & 4) != 0);
}

/* Cover fns to access the ilm bits.  */

UQI
fr30bf_h_ilm_get_handler (SIM_CPU *current_cpu)
{
  return CPU (h_ilm);
}

void
fr30bf_h_ilm_set_handler (SIM_CPU *current_cpu, UQI newval)
{
  int ilm = newval & 0x1f;
  int current_ilm = CPU (h_ilm);

  /* We can only set new ilm values < 16 if the current ilm is < 16.  Otherwise
     we add 16 to the value we are given.  */
  if (current_ilm >= 16 && ilm < 16)
    ilm += 16;

  CPU (h_ilm) = ilm;
}

/* Cover fns to access the ps register.  */

USI
fr30bf_h_ps_get_handler (SIM_CPU *current_cpu)
{
  int ccr = GET_H_CCR ();
  int scr = GET_H_SCR ();
  int ilm = GET_H_ILM ();

  return ccr | (scr << 8) | (ilm << 16);
}

void
fr30bf_h_ps_set_handler (SIM_CPU *current_cpu, USI newval)
{
  int ccr = newval & 0xff;
  int scr = (newval >> 8) & 7;
  int ilm = (newval >> 16) & 0x1f;

  SET_H_CCR (ccr);
  SET_H_SCR (scr);
  SET_H_ILM (ilm);
}

/* Cover fns to access the dedicated registers.  */

SI
fr30bf_h_dr_get_handler (SIM_CPU *current_cpu, UINT dr)
{
  switch (dr)
    {
    case H_DR_SSP :
      if (! GET_H_SBIT ())
	return GET_H_GR (H_GR_SP);
      else
	return CPU (h_dr[H_DR_SSP]);
    case H_DR_USP :
      if (GET_H_SBIT ())
	return GET_H_GR (H_GR_SP);
      else
	return CPU (h_dr[H_DR_USP]);
    case H_DR_TBR :
    case H_DR_RP :
    case H_DR_MDH :
    case H_DR_MDL :
      return CPU (h_dr[dr]);
    }
  return 0;
}

void
fr30bf_h_dr_set_handler (SIM_CPU *current_cpu, UINT dr, SI newval)
{
  switch (dr)
    {
    case H_DR_SSP :
      if (! GET_H_SBIT ())
	SET_H_GR (H_GR_SP, newval);
      else
	CPU (h_dr[H_DR_SSP]) = newval;
      break;
    case H_DR_USP :
      if (GET_H_SBIT ())
	SET_H_GR (H_GR_SP, newval);
      else
	CPU (h_dr[H_DR_USP]) = newval;
      break;
    case H_DR_TBR :
    case H_DR_RP :
    case H_DR_MDH :
    case H_DR_MDL :
      CPU (h_dr[dr]) = newval;
      break;
    }
}

#if WITH_PROFILE_MODEL_P

/* FIXME: Some of these should be inline or macros.  Later.  */

/* Initialize cycle counting for an insn.
   FIRST_P is non-zero if this is the first insn in a set of parallel
   insns.  */

void
fr30bf_model_insn_before (SIM_CPU *cpu, int first_p)
{
  MODEL_FR30_1_DATA *d = CPU_MODEL_DATA (cpu);
  d->load_regs_pending = 0;
}

/* Record the cycles computed for an insn.
   LAST_P is non-zero if this is the last insn in a set of parallel insns,
   and we update the total cycle count.
   CYCLES is the cycle count of the insn.  */

void
fr30bf_model_insn_after (SIM_CPU *cpu, int last_p, int cycles)
{
  PROFILE_DATA *p = CPU_PROFILE_DATA (cpu);
  MODEL_FR30_1_DATA *d = CPU_MODEL_DATA (cpu);

  PROFILE_MODEL_TOTAL_CYCLES (p) += cycles;
  PROFILE_MODEL_CUR_INSN_CYCLES (p) = cycles;
  d->load_regs = d->load_regs_pending;
}

static INLINE int
check_load_stall (SIM_CPU *cpu, int regno)
{
  const MODEL_FR30_1_DATA *d = CPU_MODEL_DATA (cpu);
  UINT load_regs = d->load_regs;

  if (regno != -1
      && (load_regs & (1 << regno)) != 0)
    {
      PROFILE_DATA *p = CPU_PROFILE_DATA (cpu);
      ++ PROFILE_MODEL_LOAD_STALL_CYCLES (p);
      if (TRACE_INSN_P (cpu))
	cgen_trace_printf (cpu, " ; Load stall.");
      return 1;
    }
  else
    return 0;
}

int
fr30bf_model_fr30_1_u_exec (SIM_CPU *cpu, const IDESC *idesc,
			    int unit_num, int referenced,
			    INT in_Ri, INT in_Rj, INT out_Ri)
{
  int cycles = idesc->timing->units[unit_num].done;
  cycles += check_load_stall (cpu, in_Ri);
  cycles += check_load_stall (cpu, in_Rj);
  return cycles;
}

int
fr30bf_model_fr30_1_u_cti (SIM_CPU *cpu, const IDESC *idesc,
			   int unit_num, int referenced,
			   INT in_Ri)
{
  PROFILE_DATA *p = CPU_PROFILE_DATA (cpu);
  /* (1 << 1): The pc is the 2nd element in inputs, outputs.
     ??? can be cleaned up */
  int taken_p = (referenced & (1 << 1)) != 0;
  int cycles = idesc->timing->units[unit_num].done;
  int delay_slot_p = CGEN_ATTR_VALUE (NULL, idesc->attrs, CGEN_INSN_DELAY_SLOT);

  cycles += check_load_stall (cpu, in_Ri);
  if (taken_p)
    {
      /* ??? Handling cti's without delay slots this way will run afoul of
	 accurate system simulation.  Later.  */
      if (! delay_slot_p)
	{
	  ++cycles;
	  ++PROFILE_MODEL_CTI_STALL_CYCLES (p);
	}
      ++PROFILE_MODEL_TAKEN_COUNT (p);
    }
  else
    ++PROFILE_MODEL_UNTAKEN_COUNT (p);

  return cycles;
}

int
fr30bf_model_fr30_1_u_load (SIM_CPU *cpu, const IDESC *idesc,
			    int unit_num, int referenced,
			    INT in_Rj, INT out_Ri)
{
  MODEL_FR30_1_DATA *d = CPU_MODEL_DATA (cpu);
  int cycles = idesc->timing->units[unit_num].done;
  d->load_regs_pending |= 1 << out_Ri;
  cycles += check_load_stall (cpu, in_Rj);
  return cycles;
}

int
fr30bf_model_fr30_1_u_store (SIM_CPU *cpu, const IDESC *idesc,
			     int unit_num, int referenced,
			     INT in_Ri, INT in_Rj)
{
  int cycles = idesc->timing->units[unit_num].done;
  cycles += check_load_stall (cpu, in_Ri);
  cycles += check_load_stall (cpu, in_Rj);
  return cycles;
}

int
fr30bf_model_fr30_1_u_ldm (SIM_CPU *cpu, const IDESC *idesc,
			   int unit_num, int referenced,
			   INT reglist)
{
  return idesc->timing->units[unit_num].done;
}

int
fr30bf_model_fr30_1_u_stm (SIM_CPU *cpu, const IDESC *idesc,
			   int unit_num, int referenced,
			   INT reglist)
{
  return idesc->timing->units[unit_num].done;
}

#endif /* WITH_PROFILE_MODEL_P */
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d51 1
a51 1
    SETTWI (buf, fr30bf_h_gr_get (current_cpu, rn));
d56 1
a56 1
	SETTWI (buf, fr30bf_h_pc_get (current_cpu));
d59 1
a59 1
	SETTWI (buf, fr30bf_h_ps_get (current_cpu));
d67 1
a67 1
	SETTWI (buf, fr30bf_h_dr_get (current_cpu,
d83 1
a83 1
    fr30bf_h_gr_set (current_cpu, rn, GETTWI (buf));
d88 1
a88 1
	fr30bf_h_pc_set (current_cpu, GETTWI (buf));
d91 1
a91 1
	fr30bf_h_ps_set (current_cpu, GETTWI (buf));
d99 1
a99 1
	fr30bf_h_dr_set (current_cpu,
@


1.1.1.2.18.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d1 423
a423 423
// OBSOLETE /* fr30 simulator support code
// OBSOLETE    Copyright (C) 1998, 1999 Free Software Foundation, Inc.
// OBSOLETE    Contributed by Cygnus Solutions.
// OBSOLETE 
// OBSOLETE This file is part of the GNU simulators.
// OBSOLETE 
// OBSOLETE This program is free software; you can redistribute it and/or modify
// OBSOLETE it under the terms of the GNU General Public License as published by
// OBSOLETE the Free Software Foundation; either version 2, or (at your option)
// OBSOLETE any later version.
// OBSOLETE 
// OBSOLETE This program is distributed in the hope that it will be useful,
// OBSOLETE but WITHOUT ANY WARRANTY; without even the implied warranty of
// OBSOLETE MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// OBSOLETE GNU General Public License for more details.
// OBSOLETE 
// OBSOLETE You should have received a copy of the GNU General Public License along
// OBSOLETE with this program; if not, write to the Free Software Foundation, Inc.,
// OBSOLETE 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
// OBSOLETE 
// OBSOLETE #define WANT_CPU
// OBSOLETE #define WANT_CPU_FR30BF
// OBSOLETE 
// OBSOLETE #include "sim-main.h"
// OBSOLETE #include "cgen-mem.h"
// OBSOLETE #include "cgen-ops.h"
// OBSOLETE 
// OBSOLETE /* Convert gdb dedicated register number to actual dr reg number.  */
// OBSOLETE 
// OBSOLETE static int
// OBSOLETE decode_gdb_dr_regnum (int gdb_regnum)
// OBSOLETE {
// OBSOLETE   switch (gdb_regnum)
// OBSOLETE     {
// OBSOLETE     case TBR_REGNUM : return H_DR_TBR;
// OBSOLETE     case RP_REGNUM : return H_DR_RP;
// OBSOLETE     case SSP_REGNUM : return H_DR_SSP;
// OBSOLETE     case USP_REGNUM : return H_DR_USP;
// OBSOLETE     case MDH_REGNUM : return H_DR_MDH;
// OBSOLETE     case MDL_REGNUM : return H_DR_MDL;
// OBSOLETE     }
// OBSOLETE   abort ();
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* The contents of BUF are in target byte order.  */
// OBSOLETE 
// OBSOLETE int
// OBSOLETE fr30bf_fetch_register (SIM_CPU *current_cpu, int rn, unsigned char *buf, int len)
// OBSOLETE {
// OBSOLETE   if (rn < 16)
// OBSOLETE     SETTWI (buf, fr30bf_h_gr_get (current_cpu, rn));
// OBSOLETE   else
// OBSOLETE     switch (rn)
// OBSOLETE       {
// OBSOLETE       case PC_REGNUM :
// OBSOLETE 	SETTWI (buf, fr30bf_h_pc_get (current_cpu));
// OBSOLETE 	break;
// OBSOLETE       case PS_REGNUM :
// OBSOLETE 	SETTWI (buf, fr30bf_h_ps_get (current_cpu));
// OBSOLETE 	break;
// OBSOLETE       case TBR_REGNUM :
// OBSOLETE       case RP_REGNUM :
// OBSOLETE       case SSP_REGNUM :
// OBSOLETE       case USP_REGNUM :
// OBSOLETE       case MDH_REGNUM :
// OBSOLETE       case MDL_REGNUM :
// OBSOLETE 	SETTWI (buf, fr30bf_h_dr_get (current_cpu,
// OBSOLETE 				      decode_gdb_dr_regnum (rn)));
// OBSOLETE 	break;
// OBSOLETE       default :
// OBSOLETE 	return 0;
// OBSOLETE       }
// OBSOLETE 
// OBSOLETE   return -1; /*FIXME*/
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* The contents of BUF are in target byte order.  */
// OBSOLETE 
// OBSOLETE int
// OBSOLETE fr30bf_store_register (SIM_CPU *current_cpu, int rn, unsigned char *buf, int len)
// OBSOLETE {
// OBSOLETE   if (rn < 16)
// OBSOLETE     fr30bf_h_gr_set (current_cpu, rn, GETTWI (buf));
// OBSOLETE   else
// OBSOLETE     switch (rn)
// OBSOLETE       {
// OBSOLETE       case PC_REGNUM :
// OBSOLETE 	fr30bf_h_pc_set (current_cpu, GETTWI (buf));
// OBSOLETE 	break;
// OBSOLETE       case PS_REGNUM :
// OBSOLETE 	fr30bf_h_ps_set (current_cpu, GETTWI (buf));
// OBSOLETE 	break;
// OBSOLETE       case TBR_REGNUM :
// OBSOLETE       case RP_REGNUM :
// OBSOLETE       case SSP_REGNUM :
// OBSOLETE       case USP_REGNUM :
// OBSOLETE       case MDH_REGNUM :
// OBSOLETE       case MDL_REGNUM :
// OBSOLETE 	fr30bf_h_dr_set (current_cpu,
// OBSOLETE 			 decode_gdb_dr_regnum (rn),
// OBSOLETE 			 GETTWI (buf));
// OBSOLETE 	break;
// OBSOLETE       default :
// OBSOLETE 	return 0;
// OBSOLETE       }
// OBSOLETE 
// OBSOLETE   return -1; /*FIXME*/
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Cover fns to access the ccr bits.  */
// OBSOLETE 
// OBSOLETE BI
// OBSOLETE fr30bf_h_sbit_get_handler (SIM_CPU *current_cpu)
// OBSOLETE {
// OBSOLETE   return CPU (h_sbit);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fr30bf_h_sbit_set_handler (SIM_CPU *current_cpu, BI newval)
// OBSOLETE {
// OBSOLETE   int old_sbit = CPU (h_sbit);
// OBSOLETE   int new_sbit = (newval != 0);
// OBSOLETE 
// OBSOLETE   CPU (h_sbit) = new_sbit;
// OBSOLETE 
// OBSOLETE   /* When switching stack modes, update the registers.  */
// OBSOLETE   if (old_sbit != new_sbit)
// OBSOLETE     {
// OBSOLETE       if (old_sbit)
// OBSOLETE 	{
// OBSOLETE 	  /* Switching user -> system.  */
// OBSOLETE 	  CPU (h_dr[H_DR_USP]) = CPU (h_gr[H_GR_SP]);
// OBSOLETE 	  CPU (h_gr[H_GR_SP]) = CPU (h_dr[H_DR_SSP]);
// OBSOLETE 	}
// OBSOLETE       else
// OBSOLETE 	{
// OBSOLETE 	  /* Switching system -> user.  */
// OBSOLETE 	  CPU (h_dr[H_DR_SSP]) = CPU (h_gr[H_GR_SP]);
// OBSOLETE 	  CPU (h_gr[H_GR_SP]) = CPU (h_dr[H_DR_USP]);
// OBSOLETE 	}
// OBSOLETE     }
// OBSOLETE 
// OBSOLETE   /* TODO: r15 interlock */
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Cover fns to access the ccr bits.  */
// OBSOLETE 
// OBSOLETE UQI
// OBSOLETE fr30bf_h_ccr_get_handler (SIM_CPU *current_cpu)
// OBSOLETE {
// OBSOLETE   int ccr = (  (GET_H_CBIT () << 0)
// OBSOLETE 	     | (GET_H_VBIT () << 1)
// OBSOLETE 	     | (GET_H_ZBIT () << 2)
// OBSOLETE 	     | (GET_H_NBIT () << 3)
// OBSOLETE 	     | (GET_H_IBIT () << 4)
// OBSOLETE 	     | (GET_H_SBIT () << 5));
// OBSOLETE 
// OBSOLETE   return ccr;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fr30bf_h_ccr_set_handler (SIM_CPU *current_cpu, UQI newval)
// OBSOLETE {
// OBSOLETE   int ccr = newval & 0x3f;
// OBSOLETE 
// OBSOLETE   SET_H_CBIT ((ccr & 1) != 0);
// OBSOLETE   SET_H_VBIT ((ccr & 2) != 0);
// OBSOLETE   SET_H_ZBIT ((ccr & 4) != 0);
// OBSOLETE   SET_H_NBIT ((ccr & 8) != 0);
// OBSOLETE   SET_H_IBIT ((ccr & 0x10) != 0);
// OBSOLETE   SET_H_SBIT ((ccr & 0x20) != 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Cover fns to access the scr bits.  */
// OBSOLETE 
// OBSOLETE UQI
// OBSOLETE fr30bf_h_scr_get_handler (SIM_CPU *current_cpu)
// OBSOLETE {
// OBSOLETE   int scr = (  (GET_H_TBIT () << 0)
// OBSOLETE 	     | (GET_H_D0BIT () << 1)
// OBSOLETE 	     | (GET_H_D1BIT () << 2));
// OBSOLETE   return scr;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fr30bf_h_scr_set_handler (SIM_CPU *current_cpu, UQI newval)
// OBSOLETE {
// OBSOLETE   int scr = newval & 7;
// OBSOLETE 
// OBSOLETE   SET_H_TBIT  ((scr & 1) != 0);
// OBSOLETE   SET_H_D0BIT ((scr & 2) != 0);
// OBSOLETE   SET_H_D1BIT ((scr & 4) != 0);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Cover fns to access the ilm bits.  */
// OBSOLETE 
// OBSOLETE UQI
// OBSOLETE fr30bf_h_ilm_get_handler (SIM_CPU *current_cpu)
// OBSOLETE {
// OBSOLETE   return CPU (h_ilm);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fr30bf_h_ilm_set_handler (SIM_CPU *current_cpu, UQI newval)
// OBSOLETE {
// OBSOLETE   int ilm = newval & 0x1f;
// OBSOLETE   int current_ilm = CPU (h_ilm);
// OBSOLETE 
// OBSOLETE   /* We can only set new ilm values < 16 if the current ilm is < 16.  Otherwise
// OBSOLETE      we add 16 to the value we are given.  */
// OBSOLETE   if (current_ilm >= 16 && ilm < 16)
// OBSOLETE     ilm += 16;
// OBSOLETE 
// OBSOLETE   CPU (h_ilm) = ilm;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Cover fns to access the ps register.  */
// OBSOLETE 
// OBSOLETE USI
// OBSOLETE fr30bf_h_ps_get_handler (SIM_CPU *current_cpu)
// OBSOLETE {
// OBSOLETE   int ccr = GET_H_CCR ();
// OBSOLETE   int scr = GET_H_SCR ();
// OBSOLETE   int ilm = GET_H_ILM ();
// OBSOLETE 
// OBSOLETE   return ccr | (scr << 8) | (ilm << 16);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fr30bf_h_ps_set_handler (SIM_CPU *current_cpu, USI newval)
// OBSOLETE {
// OBSOLETE   int ccr = newval & 0xff;
// OBSOLETE   int scr = (newval >> 8) & 7;
// OBSOLETE   int ilm = (newval >> 16) & 0x1f;
// OBSOLETE 
// OBSOLETE   SET_H_CCR (ccr);
// OBSOLETE   SET_H_SCR (scr);
// OBSOLETE   SET_H_ILM (ilm);
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Cover fns to access the dedicated registers.  */
// OBSOLETE 
// OBSOLETE SI
// OBSOLETE fr30bf_h_dr_get_handler (SIM_CPU *current_cpu, UINT dr)
// OBSOLETE {
// OBSOLETE   switch (dr)
// OBSOLETE     {
// OBSOLETE     case H_DR_SSP :
// OBSOLETE       if (! GET_H_SBIT ())
// OBSOLETE 	return GET_H_GR (H_GR_SP);
// OBSOLETE       else
// OBSOLETE 	return CPU (h_dr[H_DR_SSP]);
// OBSOLETE     case H_DR_USP :
// OBSOLETE       if (GET_H_SBIT ())
// OBSOLETE 	return GET_H_GR (H_GR_SP);
// OBSOLETE       else
// OBSOLETE 	return CPU (h_dr[H_DR_USP]);
// OBSOLETE     case H_DR_TBR :
// OBSOLETE     case H_DR_RP :
// OBSOLETE     case H_DR_MDH :
// OBSOLETE     case H_DR_MDL :
// OBSOLETE       return CPU (h_dr[dr]);
// OBSOLETE     }
// OBSOLETE   return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fr30bf_h_dr_set_handler (SIM_CPU *current_cpu, UINT dr, SI newval)
// OBSOLETE {
// OBSOLETE   switch (dr)
// OBSOLETE     {
// OBSOLETE     case H_DR_SSP :
// OBSOLETE       if (! GET_H_SBIT ())
// OBSOLETE 	SET_H_GR (H_GR_SP, newval);
// OBSOLETE       else
// OBSOLETE 	CPU (h_dr[H_DR_SSP]) = newval;
// OBSOLETE       break;
// OBSOLETE     case H_DR_USP :
// OBSOLETE       if (GET_H_SBIT ())
// OBSOLETE 	SET_H_GR (H_GR_SP, newval);
// OBSOLETE       else
// OBSOLETE 	CPU (h_dr[H_DR_USP]) = newval;
// OBSOLETE       break;
// OBSOLETE     case H_DR_TBR :
// OBSOLETE     case H_DR_RP :
// OBSOLETE     case H_DR_MDH :
// OBSOLETE     case H_DR_MDL :
// OBSOLETE       CPU (h_dr[dr]) = newval;
// OBSOLETE       break;
// OBSOLETE     }
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #if WITH_PROFILE_MODEL_P
// OBSOLETE 
// OBSOLETE /* FIXME: Some of these should be inline or macros.  Later.  */
// OBSOLETE 
// OBSOLETE /* Initialize cycle counting for an insn.
// OBSOLETE    FIRST_P is non-zero if this is the first insn in a set of parallel
// OBSOLETE    insns.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fr30bf_model_insn_before (SIM_CPU *cpu, int first_p)
// OBSOLETE {
// OBSOLETE   MODEL_FR30_1_DATA *d = CPU_MODEL_DATA (cpu);
// OBSOLETE   d->load_regs_pending = 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE /* Record the cycles computed for an insn.
// OBSOLETE    LAST_P is non-zero if this is the last insn in a set of parallel insns,
// OBSOLETE    and we update the total cycle count.
// OBSOLETE    CYCLES is the cycle count of the insn.  */
// OBSOLETE 
// OBSOLETE void
// OBSOLETE fr30bf_model_insn_after (SIM_CPU *cpu, int last_p, int cycles)
// OBSOLETE {
// OBSOLETE   PROFILE_DATA *p = CPU_PROFILE_DATA (cpu);
// OBSOLETE   MODEL_FR30_1_DATA *d = CPU_MODEL_DATA (cpu);
// OBSOLETE 
// OBSOLETE   PROFILE_MODEL_TOTAL_CYCLES (p) += cycles;
// OBSOLETE   PROFILE_MODEL_CUR_INSN_CYCLES (p) = cycles;
// OBSOLETE   d->load_regs = d->load_regs_pending;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE static INLINE int
// OBSOLETE check_load_stall (SIM_CPU *cpu, int regno)
// OBSOLETE {
// OBSOLETE   const MODEL_FR30_1_DATA *d = CPU_MODEL_DATA (cpu);
// OBSOLETE   UINT load_regs = d->load_regs;
// OBSOLETE 
// OBSOLETE   if (regno != -1
// OBSOLETE       && (load_regs & (1 << regno)) != 0)
// OBSOLETE     {
// OBSOLETE       PROFILE_DATA *p = CPU_PROFILE_DATA (cpu);
// OBSOLETE       ++ PROFILE_MODEL_LOAD_STALL_CYCLES (p);
// OBSOLETE       if (TRACE_INSN_P (cpu))
// OBSOLETE 	cgen_trace_printf (cpu, " ; Load stall.");
// OBSOLETE       return 1;
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     return 0;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE fr30bf_model_fr30_1_u_exec (SIM_CPU *cpu, const IDESC *idesc,
// OBSOLETE 			    int unit_num, int referenced,
// OBSOLETE 			    INT in_Ri, INT in_Rj, INT out_Ri)
// OBSOLETE {
// OBSOLETE   int cycles = idesc->timing->units[unit_num].done;
// OBSOLETE   cycles += check_load_stall (cpu, in_Ri);
// OBSOLETE   cycles += check_load_stall (cpu, in_Rj);
// OBSOLETE   return cycles;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE fr30bf_model_fr30_1_u_cti (SIM_CPU *cpu, const IDESC *idesc,
// OBSOLETE 			   int unit_num, int referenced,
// OBSOLETE 			   INT in_Ri)
// OBSOLETE {
// OBSOLETE   PROFILE_DATA *p = CPU_PROFILE_DATA (cpu);
// OBSOLETE   /* (1 << 1): The pc is the 2nd element in inputs, outputs.
// OBSOLETE      ??? can be cleaned up */
// OBSOLETE   int taken_p = (referenced & (1 << 1)) != 0;
// OBSOLETE   int cycles = idesc->timing->units[unit_num].done;
// OBSOLETE   int delay_slot_p = CGEN_ATTR_VALUE (NULL, idesc->attrs, CGEN_INSN_DELAY_SLOT);
// OBSOLETE 
// OBSOLETE   cycles += check_load_stall (cpu, in_Ri);
// OBSOLETE   if (taken_p)
// OBSOLETE     {
// OBSOLETE       /* ??? Handling cti's without delay slots this way will run afoul of
// OBSOLETE 	 accurate system simulation.  Later.  */
// OBSOLETE       if (! delay_slot_p)
// OBSOLETE 	{
// OBSOLETE 	  ++cycles;
// OBSOLETE 	  ++PROFILE_MODEL_CTI_STALL_CYCLES (p);
// OBSOLETE 	}
// OBSOLETE       ++PROFILE_MODEL_TAKEN_COUNT (p);
// OBSOLETE     }
// OBSOLETE   else
// OBSOLETE     ++PROFILE_MODEL_UNTAKEN_COUNT (p);
// OBSOLETE 
// OBSOLETE   return cycles;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE fr30bf_model_fr30_1_u_load (SIM_CPU *cpu, const IDESC *idesc,
// OBSOLETE 			    int unit_num, int referenced,
// OBSOLETE 			    INT in_Rj, INT out_Ri)
// OBSOLETE {
// OBSOLETE   MODEL_FR30_1_DATA *d = CPU_MODEL_DATA (cpu);
// OBSOLETE   int cycles = idesc->timing->units[unit_num].done;
// OBSOLETE   d->load_regs_pending |= 1 << out_Ri;
// OBSOLETE   cycles += check_load_stall (cpu, in_Rj);
// OBSOLETE   return cycles;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE fr30bf_model_fr30_1_u_store (SIM_CPU *cpu, const IDESC *idesc,
// OBSOLETE 			     int unit_num, int referenced,
// OBSOLETE 			     INT in_Ri, INT in_Rj)
// OBSOLETE {
// OBSOLETE   int cycles = idesc->timing->units[unit_num].done;
// OBSOLETE   cycles += check_load_stall (cpu, in_Ri);
// OBSOLETE   cycles += check_load_stall (cpu, in_Rj);
// OBSOLETE   return cycles;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE fr30bf_model_fr30_1_u_ldm (SIM_CPU *cpu, const IDESC *idesc,
// OBSOLETE 			   int unit_num, int referenced,
// OBSOLETE 			   INT reglist)
// OBSOLETE {
// OBSOLETE   return idesc->timing->units[unit_num].done;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE int
// OBSOLETE fr30bf_model_fr30_1_u_stm (SIM_CPU *cpu, const IDESC *idesc,
// OBSOLETE 			   int unit_num, int referenced,
// OBSOLETE 			   INT reglist)
// OBSOLETE {
// OBSOLETE   return idesc->timing->units[unit_num].done;
// OBSOLETE }
// OBSOLETE 
// OBSOLETE #endif /* WITH_PROFILE_MODEL_P */
@


