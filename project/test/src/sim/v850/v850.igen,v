head	1.14;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.13
	gdb_7_6-2013-04-26-release:1.13
	gdb_7_6-branch:1.13.0.2
	gdb_7_6-2013-03-12-branchpoint:1.13
	gdb_7_5_1-2012-11-29-release:1.10
	gdb_7_5-2012-08-17-release:1.10
	gdb_7_5-branch:1.10.0.2
	gdb_7_5-2012-07-18-branchpoint:1.10
	gdb_7_4_1-2012-04-26-release:1.9
	gdb_7_4-2012-01-24-release:1.9
	gdb_7_4-branch:1.9.0.28
	gdb_7_4-2011-12-13-branchpoint:1.9
	gdb_7_3_1-2011-09-04-release:1.9
	gdb_7_3-2011-07-26-release:1.9
	gdb_7_3-branch:1.9.0.26
	gdb_7_3-2011-04-01-branchpoint:1.9
	gdb_7_2-2010-09-02-release:1.9
	gdb_7_2-branch:1.9.0.24
	gdb_7_2-2010-07-07-branchpoint:1.9
	gdb_7_1-2010-03-18-release:1.9
	gdb_7_1-branch:1.9.0.22
	gdb_7_1-2010-02-18-branchpoint:1.9
	gdb_7_0_1-2009-12-22-release:1.9
	gdb_7_0-2009-10-06-release:1.9
	gdb_7_0-branch:1.9.0.20
	gdb_7_0-2009-09-16-branchpoint:1.9
	arc-sim-20090309:1.9
	msnyder-checkpoint-072509-branch:1.9.0.18
	msnyder-checkpoint-072509-branchpoint:1.9
	arc-insight_6_8-branch:1.9.0.16
	arc-insight_6_8-branchpoint:1.9
	insight_6_8-branch:1.9.0.14
	insight_6_8-branchpoint:1.9
	reverse-20081226-branch:1.9.0.12
	reverse-20081226-branchpoint:1.9
	multiprocess-20081120-branch:1.9.0.10
	multiprocess-20081120-branchpoint:1.9
	reverse-20080930-branch:1.9.0.8
	reverse-20080930-branchpoint:1.9
	reverse-20080717-branch:1.9.0.6
	reverse-20080717-branchpoint:1.9
	msnyder-reverse-20080609-branch:1.9.0.4
	msnyder-reverse-20080609-branchpoint:1.9
	drow-reverse-20070409-branch:1.7.0.56
	drow-reverse-20070409-branchpoint:1.7
	gdb_6_8-2008-03-27-release:1.9
	gdb_6_8-branch:1.9.0.2
	gdb_6_8-2008-02-26-branchpoint:1.9
	gdb_6_7_1-2007-10-29-release:1.7
	gdb_6_7-2007-10-10-release:1.7
	gdb_6_7-branch:1.7.0.54
	gdb_6_7-2007-09-07-branchpoint:1.7
	insight_6_6-20070208-release:1.7
	gdb_6_6-2006-12-18-release:1.7
	gdb_6_6-branch:1.7.0.52
	gdb_6_6-2006-11-15-branchpoint:1.7
	insight_6_5-20061003-release:1.7
	gdb-csl-symbian-6_4_50_20060226-12:1.7
	gdb-csl-sourcerygxx-3_4_4-25:1.7
	nickrob-async-20060828-mergepoint:1.7
	gdb-csl-symbian-6_4_50_20060226-11:1.7
	gdb-csl-sourcerygxx-4_1-17:1.7
	gdb-csl-20060226-branch-local-2:1.7
	gdb-csl-sourcerygxx-4_1-14:1.7
	gdb-csl-sourcerygxx-4_1-13:1.7
	gdb-csl-sourcerygxx-4_1-12:1.7
	gdb-csl-sourcerygxx-3_4_4-21:1.7
	gdb_6_5-20060621-release:1.7
	gdb-csl-sourcerygxx-4_1-9:1.7
	gdb-csl-sourcerygxx-4_1-8:1.7
	gdb-csl-sourcerygxx-4_1-7:1.7
	gdb-csl-arm-2006q1-6:1.7
	gdb-csl-sourcerygxx-4_1-6:1.7
	gdb-csl-symbian-6_4_50_20060226-10:1.7
	gdb-csl-symbian-6_4_50_20060226-9:1.7
	gdb-csl-symbian-6_4_50_20060226-8:1.7
	gdb-csl-coldfire-4_1-11:1.7
	gdb-csl-sourcerygxx-3_4_4-19:1.7
	gdb-csl-coldfire-4_1-10:1.7
	gdb_6_5-branch:1.7.0.50
	gdb_6_5-2006-05-14-branchpoint:1.7
	gdb-csl-sourcerygxx-4_1-5:1.7
	nickrob-async-20060513-branch:1.7.0.48
	nickrob-async-20060513-branchpoint:1.7
	gdb-csl-sourcerygxx-4_1-4:1.7
	msnyder-reverse-20060502-branch:1.7.0.46
	msnyder-reverse-20060502-branchpoint:1.7
	gdb-csl-morpho-4_1-4:1.7
	gdb-csl-sourcerygxx-3_4_4-17:1.7
	readline_5_1-import-branch:1.7.0.44
	readline_5_1-import-branchpoint:1.7
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.7
	gdb-csl-symbian-20060226-branch:1.7.0.42
	gdb-csl-symbian-20060226-branchpoint:1.7
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.7
	msnyder-reverse-20060331-branch:1.7.0.40
	msnyder-reverse-20060331-branchpoint:1.7
	gdb-csl-available-20060303-branch:1.7.0.38
	gdb-csl-available-20060303-branchpoint:1.7
	gdb-csl-20060226-branch:1.7.0.36
	gdb-csl-20060226-branchpoint:1.7
	gdb_6_4-20051202-release:1.7
	msnyder-fork-checkpoint-branch:1.7.0.34
	msnyder-fork-checkpoint-branchpoint:1.7
	gdb-csl-gxxpro-6_3-branch:1.7.0.32
	gdb-csl-gxxpro-6_3-branchpoint:1.7
	gdb_6_4-branch:1.7.0.30
	gdb_6_4-2005-11-01-branchpoint:1.7
	gdb-csl-arm-20051020-branch:1.7.0.28
	gdb-csl-arm-20051020-branchpoint:1.7
	msnyder-tracepoint-checkpoint-branch:1.7.0.26
	msnyder-tracepoint-checkpoint-branchpoint:1.7
	gdb-csl-arm-20050325-2005-q1b:1.7
	gdb-csl-arm-20050325-2005-q1a:1.7
	csl-arm-20050325-branch:1.7.0.24
	csl-arm-20050325-branchpoint:1.7
	gdb_6_3-20041109-release:1.7
	gdb_6_3-branch:1.7.0.20
	gdb_6_3-20041019-branchpoint:1.7
	drow_intercu-merge-20040921:1.7
	drow_intercu-merge-20040915:1.7
	jimb-gdb_6_2-e500-branch:1.7.0.22
	jimb-gdb_6_2-e500-branchpoint:1.7
	gdb_6_2-20040730-release:1.7
	gdb_6_2-branch:1.7.0.18
	gdb_6_2-2004-07-10-gmt-branchpoint:1.7
	gdb_6_1_1-20040616-release:1.7
	gdb_6_1-2004-04-05-release:1.7
	drow_intercu-merge-20040402:1.7
	drow_intercu-merge-20040327:1.7
	ezannoni_pie-20040323-branch:1.7.0.16
	ezannoni_pie-20040323-branchpoint:1.7
	cagney_tramp-20040321-mergepoint:1.7
	cagney_tramp-20040309-branch:1.7.0.14
	cagney_tramp-20040309-branchpoint:1.7
	gdb_6_1-branch:1.7.0.12
	gdb_6_1-2004-03-01-gmt-branchpoint:1.7
	drow_intercu-20040221-branch:1.7.0.10
	drow_intercu-20040221-branchpoint:1.7
	cagney_bfdfile-20040213-branch:1.7.0.8
	cagney_bfdfile-20040213-branchpoint:1.7
	drow-cplus-merge-20040208:1.7
	carlton_dictionary-20040126-merge:1.7
	cagney_bigcore-20040122-branch:1.7.0.6
	cagney_bigcore-20040122-branchpoint:1.7
	drow-cplus-merge-20040113:1.7
	drow-cplus-merge-20031224:1.7
	drow-cplus-merge-20031220:1.7
	carlton_dictionary-20031215-merge:1.7
	drow-cplus-merge-20031214:1.7
	carlton-dictionary-20031111-merge:1.7
	gdb_6_0-2003-10-04-release:1.6
	kettenis_sparc-20030918-branch:1.7.0.4
	kettenis_sparc-20030918-branchpoint:1.7
	carlton_dictionary-20030917-merge:1.7
	ezannoni_pie-20030916-branchpoint:1.7
	ezannoni_pie-20030916-branch:1.7.0.2
	cagney_x86i386-20030821-branch:1.6.0.20
	cagney_x86i386-20030821-branchpoint:1.6
	carlton_dictionary-20030805-merge:1.6
	carlton_dictionary-20030627-merge:1.6
	gdb_6_0-branch:1.6.0.18
	gdb_6_0-2003-06-23-branchpoint:1.6
	jimb-ppc64-linux-20030613-branch:1.6.0.16
	jimb-ppc64-linux-20030613-branchpoint:1.6
	cagney_convert-20030606-branch:1.6.0.14
	cagney_convert-20030606-branchpoint:1.6
	cagney_writestrings-20030508-branch:1.6.0.12
	cagney_writestrings-20030508-branchpoint:1.6
	jimb-ppc64-linux-20030528-branch:1.6.0.10
	jimb-ppc64-linux-20030528-branchpoint:1.6
	carlton_dictionary-20030523-merge:1.6
	cagney_fileio-20030521-branch:1.6.0.8
	cagney_fileio-20030521-branchpoint:1.6
	kettenis_i386newframe-20030517-mergepoint:1.6
	jimb-ppc64-linux-20030509-branch:1.6.0.6
	jimb-ppc64-linux-20030509-branchpoint:1.6
	kettenis_i386newframe-20030504-mergepoint:1.6
	carlton_dictionary-20030430-merge:1.6
	kettenis_i386newframe-20030419-branch:1.6.0.4
	kettenis_i386newframe-20030419-branchpoint:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	kettenis_i386newframe-20030406-branch:1.6.0.2
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.20
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.18
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.16
	cagney_lazyid-20030317-branchpoint:1.5
	kettenis-i386newframe-20030316-mergepoint:1.5
	offbyone-20030313-branch:1.5.0.14
	offbyone-20030313-branchpoint:1.5
	kettenis-i386newframe-20030308-branch:1.5.0.12
	kettenis-i386newframe-20030308-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.10
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.8
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.6
	cagney-unwind-20030108-branchpoint:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.4
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.4
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.2
	carlton_dictionary-20020920-branchpoint:1.5
	gdb_5_3-branch:1.4.0.22
	gdb_5_3-2002-09-04-branchpoint:1.4
	kseitz_interps-20020829-merge:1.4
	cagney_sysregs-20020825-branch:1.4.0.20
	cagney_sysregs-20020825-branchpoint:1.4
	readline_4_3-import-branch:1.4.0.18
	readline_4_3-import-branchpoint:1.4
	gdb_5_2_1-2002-07-23-release:1.4
	kseitz_interps-20020528-branch:1.4.0.16
	kseitz_interps-20020528-branchpoint:1.4
	cagney_regbuf-20020515-branch:1.4.0.14
	cagney_regbuf-20020515-branchpoint:1.4
	jimb-macro-020506-branch:1.4.0.12
	jimb-macro-020506-branchpoint:1.4
	gdb_5_2-2002-04-29-release:1.4
	gdb_5_2-branch:1.4.0.10
	gdb_5_2-2002-03-03-branchpoint:1.4
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.6
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.4
	gdb_5_1-2001-07-29-branchpoint:1.4
	insight-precleanup-2001-01-01:1.4
	gdb-premipsmulti-2000-06-06-branch:1.4.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.4
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.14
date	2013.05.13.10.52.52;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2013.01.28.10.06.51;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2013.01.10.09.57.02;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2012.09.13.08.09.26;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2012.03.29.00.57.19;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2008.02.06.04.41.26;	author dj;	state Exp;
branches;
next	1.8;

1.8
date	2008.02.06.00.40.05;	author dj;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.05.17.46.52;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.06.08.51.04;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.19.07.52.02;	author nickc;	state Exp;
branches
	1.5.2.1
	1.5.4.1
	1.5.20.1;
next	1.4;

1.4
date	2000.05.30.18.36.57;	author nickc;	state Exp;
branches
	1.4.16.1;
next	1.3;

1.3
date	2000.05.08.23.07.39;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.25.00.17.21;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.12;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.5.2.1
date	2003.04.16.19.57.08;	author carlton;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2003.09.17.21.29.05;	author carlton;	state Exp;
branches;
next	;

1.5.4.1
date	2003.12.14.20.28.39;	author drow;	state Exp;
branches;
next	;

1.5.20.1
date	2003.04.10.21.33.55;	author cagney;	state Exp;
branches;
next	;

1.4.16.1
date	2002.10.01.00.46.48;	author kseitz;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.35.12;	author shebs;	state Exp;
branches;
next	;


desc
@@


1.14
log
@	* v850.igen (LDSR): Accept but ignore a selID parameter.
@
text
@:option:::insn-bit-size:16
:option:::hi-bit-nr:15


:option:::format-names:I,II,III,IV,V,VI,VII,VIII,IX,X
:option:::format-names:XI,XII,XIII
:option:::format-names:XIV,XV
:option:::format-names:Z
:option:::format-names:F_I


:model:::v850:v850:

:option:::multi-sim:true
:model:::v850e:v850e:
:option:::multi-sim:true
:model:::v850e1:v850e1:
:option:::multi-sim:true
:model:::v850e2:v850e2:
:option:::multi-sim:true
:model:::v850e2v3:v850e2v3:
:option:::multi-sim:true
:model:::v850e3v5:v850e3v5:

// Cache macros

:cache:::unsigned:reg1:RRRRR:(RRRRR)
:cache:::unsigned:reg2:rrrrr:(rrrrr)
:cache:::unsigned:reg3:wwwww:(wwwww)
:cache:::unsigned:reg4:W,WWWW:(W + (WWWW << 1))

:cache:::unsigned:reg1e:RRRR:(RRRR << 1)
:cache:::unsigned:reg2e:rrrr:(rrrr << 1)
:cache:::unsigned:reg3e:wwww:(wwww << 1)
:cache:::unsigned:reg4e:mmmm:(mmmm << 1)

:cache:::unsigned:disp4:dddd:(dddd)
:cache:::unsigned:disp5:dddd:(dddd << 1)
:cache:::unsigned:disp7:ddddddd:ddddddd
:cache:::unsigned:disp8:ddddddd:(ddddddd << 1)
:cache:::unsigned:disp8:dddddd:(dddddd << 2)
:cache:::unsigned:disp9:ddddd,ddd:SEXT32 ((ddddd << 4) + (ddd << 1), 9 - 1)
:cache:::unsigned:disp16:dddddddddddddddd:EXTEND16 (dddddddddddddddd)
:cache:::unsigned:disp16:ddddddddddddddd: EXTEND16 (ddddddddddddddd << 1)
:cache:::unsigned:disp17:d,ddddddddddddddd:SEXT32 (((d <<16) + (ddddddddddddddd << 1)), 17 - 1)
:cache:::unsigned:disp22:dddddd,ddddddddddddddd: SEXT32 ((dddddd << 16) + (ddddddddddddddd << 1), 22 - 1)
:cache:::unsigned:disp23:ddddddd,dddddddddddddddd: SEXT32 ((ddddddd) + (dddddddddddddddd << 7), 23 - 1)
:cache:::unsigned:disp23:dddddd,dddddddddddddddd: SEXT32 ((dddddd << 1) + (dddddddddddddddd << 7), 23 - 1)

:cache:::unsigned:imm5:iiiii:SEXT32 (iiiii, 4)
:cache:::unsigned:imm6:iiiiii:iiiiii
:cache:::unsigned:imm9:iiiii,IIII:SEXT ((IIII << 5) + iiiii, 9 - 1)
:cache:::unsigned:imm5:iiii:(32 - (iiii << 1))
:cache:::unsigned:simm16:iiiiiiiiiiiiiiii:EXTEND16 (iiiiiiiiiiiiiiii)
:cache:::unsigned:uimm16:iiiiiiiiiiiiiiii:iiiiiiiiiiiiiiii
:cache:::unsigned:imm32:iiiiiiiiiiiiiiii,IIIIIIIIIIIIIIII:(iiiiiiiiiiiiiiii < 16 + IIIIIIIIIIIIIIII)
:cache:::unsigned:uimm32:iiiiiiiiiiiiiiii,dddddddddddddddd:((iiiiiiiiiiiiiiii << 16) + dddddddddddddddd)

:cache:::unsigned:vector:iiiii:iiiii

:cache:::unsigned:list12:L,LLLLLLLLLLL:((L << 11) + LLLLLLLLLLL)
:cache:::unsigned:list18:LLLL,LLLLLLLLLLLL:((LLLL << 12) + LLLLLLLLLLLL)

:cache:::unsigned:bit3:bbb:bbb
:cache:::unsigned:bit4:bbbb:bbbb
:cache:::unsigned:bit13:B,BBB:((B << 3) + BBB)


// What do we do with an illegal instruction?
:internal::::illegal:
{
  sim_io_eprintf (SD, "Illegal instruction at address 0x%lx\n",
		  (unsigned long) cia);
  sim_engine_halt (SD, CPU, NULL, cia, sim_signalled, SIM_SIGILL);
}



// ADD
rrrrr,001110,RRRRR:I:::add
"add r<reg1>, r<reg2>"
{
  COMPAT_1 (OP_1C0 ());
}

rrrrr,010010,iiiii:II:::add
"add <imm5>,r<reg2>"
{
  COMPAT_1 (OP_240 ());
}



// ADDI
rrrrr,110000,RRRRR + iiiiiiiiiiiiiiii:VI:::addi
"addi <simm16>, r<reg1>, r<reg2>"
{
  COMPAT_2 (OP_600 ());
}



// ADF
rrrrr,111111,RRRRR + wwwww,011101,cccc!13,0:XI:::adf
*v850e2
*v850e2v3
*v850e3v5
"adf %s<cccc>, r<reg1>, r<reg2>, r<reg3>"
{
  int cond = condition_met (cccc);
  TRACE_ALU_INPUT3 (cond, GR[reg1], GR[reg2]);
  GR[reg3] = GR[reg1] + GR[reg2] + (cond ? 1 : 0);
  TRACE_ALU_RESULT1 (GR[reg3]);
}



// AND
rrrrr,001010,RRRRR:I:::and
"and r<reg1>, r<reg2>"
{
  COMPAT_1 (OP_140 ());
}



// ANDI
rrrrr,110110,RRRRR + iiiiiiiiiiiiiiii:VI:::andi
"andi <uimm16>, r<reg1>, r<reg2>"
{
  COMPAT_2 (OP_6C0 ());
}



// Map condition code to a string
:%s::::cccc:int cccc
{
  switch (cccc)
    {
    case 0xf: return "gt";
    case 0xe: return "ge";
    case 0x6: return "lt";

    case 0x7: return "le";

    case 0xb: return "h";
    case 0x9: return "nl";
    case 0x1: return "l";

    case 0x3: return "nh";

    case 0x2: return "e";

    case 0xa: return "ne";

    case 0x0: return "v";
    case 0x8: return "nv";
    case 0x4: return "n";
    case 0xc: return "p";
      /* case 0x1: return "c"; */
      /* case 0x9: return "nc"; */
      /* case 0x2: return "z"; */
      /* case 0xa: return "nz"; */
    case 0x5: return "r"; /* always */
    case 0xd: return "sa";
    }
  return "(null)";
}


// Bcond
ddddd,1011,ddd,cccc:III:::Bcond
"b%s<cccc> <disp9>"
{
  int cond;
  if ((ddddd == 0x00) && (ddd == 0x00) && (cccc == 0x05)) {
    // Special case - treat "br *" like illegal instruction
    sim_engine_halt (SD, CPU, NULL, cia, sim_stopped, SIM_SIGTRAP);
  } else {
    cond = condition_met (cccc);
    if (cond)
      nia = cia + disp9;
    TRACE_BRANCH1 (cond);
  }
}

00000111111,d,cccc + ddddddddddddddd,1:VII:::Bcond
"breakpoint":((disp17 == 0) && (cccc == 0x05))
"b%s<cccc> <disp17>"
*v850e2v3
*v850e3v5
{
  int cond;
  cond = condition_met (cccc);
  if (cond)
    nia = cia + disp17;
  TRACE_BRANCH_INPUT1 (cond);
  TRACE_BRANCH_RESULT (nia);
}



// BSH
rrrrr,11111100000 + wwwww,01101000010:XII:::bsh
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"bsh r<reg2>, r<reg3>"
{
  unsigned32 value;
  TRACE_ALU_INPUT1 (GR[reg2]);

  value = (MOVED32 (GR[reg2], 23, 16, 31, 24)
	   | MOVED32 (GR[reg2], 31, 24, 23, 16)
	   | MOVED32 (GR[reg2], 7, 0, 15, 8)
	   | MOVED32 (GR[reg2], 15, 8, 7, 0));

  GR[reg3] = value;
  PSW &= ~(PSW_Z | PSW_S | PSW_CY | PSW_OV);
  if ((value & 0xffff) == 0) PSW |= PSW_Z;
  if (value & 0x80000000) PSW |= PSW_S;
  if (((value & 0xff) == 0) || ((value & 0xff00) == 0)) PSW |= PSW_CY;

  TRACE_ALU_RESULT (GR[reg3]);
}



// BSW
rrrrr,11111100000 + wwwww,01101000000:XII:::bsw
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"bsw r<reg2>, r<reg3>"
{
#define WORDHASNULLBYTE(x) (((x) - 0x01010101) & ~(x)&0x80808080)
  unsigned32 value;
  TRACE_ALU_INPUT1 (GR[reg2]);

  value = GR[reg2];
  value >>= 24;
  value |= (GR[reg2] << 24);
  value |= ((GR[reg2] << 8) & 0x00ff0000);
  value |= ((GR[reg2] >> 8) & 0x0000ff00);
  GR[reg3] = value;

  PSW &= ~(PSW_Z | PSW_S | PSW_CY | PSW_OV);

  if (value == 0) PSW |= PSW_Z;
  if (value & 0x80000000) PSW |= PSW_S;
  if (WORDHASNULLBYTE (value)) PSW |= PSW_CY;

  TRACE_ALU_RESULT (GR[reg3]);
}



// CALLT
0000001000,iiiiii:II:::callt
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"callt <imm6>"
{
  unsigned32 adr;
  unsigned32 off;
  CTPC  = cia + 2;
  CTPSW = PSW;
  adr = (CTBP & ~1) + (imm6 << 1);
  off = load_mem (adr, 2) & ~1; /* Force alignment */
  nia = (CTBP & ~1) + off;
  TRACE_BRANCH3 (adr, CTBP, off);
}



// CAXI
rrrrr,111111,RRRRR + wwwww,00011101110:IX:::caxi
*v850e2
*v850e2v3
*v850e3v5
"caxi [reg1], reg2, reg3"
{
  unsigned int z,s,cy,ov;
  unsigned32 addr;
  unsigned32 token,result;

  addr = GR[reg1];

  if (mpu_load_mem_test(sd, addr, 4, reg1) 
      && mpu_store_mem_test(sd, addr, 4, reg1))
    {
      token = load_data_mem (sd, addr, 4);

      TRACE_ALU_INPUT2 (token, GR[reg2]);

      result = GR[reg2] - token;

      z = (result == 0);
      s = (result & 0x80000000);
      cy = (GR[reg2] < token);
      ov = ((GR[reg2] & 0x80000000) != (token & 0x80000000)
	    && (GR[reg2] & 0x80000000) != (result & 0x80000000));

      if (result == 0)
	{
	  store_data_mem (sd, addr, 4, GR[reg3]);
	  GR[reg3] = token;
	}
      else
	{
	  store_data_mem (sd, addr, 4, token);
	  GR[reg3] = token;
	}
  
      /* Set condition codes.  */
      PSW &= ~(PSW_Z | PSW_S | PSW_CY | PSW_OV);
      PSW |= ((z ? PSW_Z : 0) | (s ? PSW_S : 0)
	      | (cy ? PSW_CY : 0) | (ov ? PSW_OV : 0));

      TRACE_ALU_RESULT1 (GR[reg3]);
    }
}


// CLR1
10,bbb,111110,RRRRR + dddddddddddddddd:VIII:::clr1
"clr1 <bit3>, <disp16>[r<reg1>]"
{
  COMPAT_2 (OP_87C0 ());
}

rrrrr,111111,RRRRR + 0000000011100100:IX:::clr1
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"clr1 r<reg2>, [r<reg1>]"
{
  COMPAT_2 (OP_E407E0 ());
}



// CTRET
0000011111100000 + 0000000101000100:X:::ctret
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"ctret"
{
  nia  = (CTPC & ~1);
  PSW = (CTPSW & (CPU)->psw_mask);
  TRACE_BRANCH1 (PSW);
}



// CMOV
rrrrr,111111,RRRRR + wwwww,011001,cccc,0:XI:::cmov
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"cmov %s<cccc>, r<reg1>, r<reg2>, r<reg3>"
{
  int cond = condition_met (cccc);
  TRACE_ALU_INPUT3 (cond, GR[reg1], GR[reg2]);
  GR[reg3] = cond ? GR[reg1] : GR[reg2];
  TRACE_ALU_RESULT (GR[reg3]);
}

rrrrr,111111,iiiii + wwwww,011000,cccc,0:XII:::cmov
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"cmov %s<cccc>, <imm5>, r<reg2>, r<reg3>"
{
  int cond = condition_met (cccc);
  TRACE_ALU_INPUT3 (cond, imm5, GR[reg2]);
  GR[reg3] = cond ? imm5 : GR[reg2];
  TRACE_ALU_RESULT (GR[reg3]);
}



// CMP
rrrrr,001111,RRRRR:I:::cmp
"cmp r<reg1>, r<reg2>"
{
  COMPAT_1 (OP_1E0 ());
}

rrrrr,010011,iiiii:II:::cmp
"cmp <imm5>, r<reg2>"
{
  COMPAT_1 (OP_260 ());
}



// DI
0000011111100000 + 0000000101100000:X:::di
"di"
{
  COMPAT_2 (OP_16007E0 ());
}



// DISPOSE
// 0000011001,iiiii,L + LLLLLLLLLLL,00000:XIII:::dispose
// "dispose <imm5>, <list12>"
0000011001,iiiii,L + LLLLLLLLLLL,RRRRR:XIII:::dispose
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"dispose <imm5>, <list12>":RRRRR == 0
"dispose <imm5>, <list12>, [reg1]"
{
  int i;
  SAVE_2;
      
  trace_input ("dispose", OP_PUSHPOP1, 0);

  SP += (OP[3] & 0x3e) << 1;

  /* Load the registers with lower number registers being retrieved
     from higher addresses.  */
  for (i = 12; i--;)
    if ((OP[3] & (1 << type1_regs[ i ])))
      {
	State.regs[ 20 + i ] = load_mem (SP, 4);
	SP += 4;
      }
  
  if ((OP[3] & 0x1f0000) != 0)
    {
      nia = State.regs[ (OP[3] >> 16) & 0x1f];
    }
  
  trace_output (OP_PUSHPOP1);
}



// DIV
rrrrr,111111,RRRRR + wwwww,01011000000:XI:::div
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"div r<reg1>, r<reg2>, r<reg3>"
{
  COMPAT_2 (OP_2C007E0 ());
}


// DIVH
rrrrr!0,000010,RRRRR!0:I:::divh
"divh r<reg1>, r<reg2>"
{
  unsigned32 ov, s, z;
  signed long int op0, op1, result;

  trace_input ("divh", OP_REG_REG, 0);

  PC = cia;
  OP[0] = instruction_0 & 0x1f;
  OP[1] = (instruction_0 >> 11) & 0x1f;

  /* Compute the result.  */
  op0 = EXTEND16 (State.regs[OP[0]]);
  op1 = State.regs[OP[1]];
  
  if (op0 == -1 && op1 == 0x80000000)
    {
      PSW &= ~PSW_Z;
      PSW |= PSW_OV | PSW_S;
      State.regs[OP[1]] = 0x80000000;
    }
  else if (op0 == 0)
    {
      PSW |= PSW_OV;
    }
  else
    {
      result = (signed32) op1 / op0;
      ov = 0;

      /* Compute the condition codes.  */
      z = (result == 0);
      s = (result & 0x80000000);
  
      /* Store the result and condition codes.  */
      State.regs[OP[1]] = result;
      PSW &= ~(PSW_Z | PSW_S | PSW_OV);
      PSW |= ((z ? PSW_Z : 0) | (s ? PSW_S : 0) | (ov ? PSW_OV : 0));
    }

  trace_output (OP_REG_REG);

  PC += 2;
  nia = PC;
}

rrrrr,111111,RRRRR + wwwww,01010000000:XI:::divh
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"divh r<reg1>, r<reg2>, r<reg3>"
{
  COMPAT_2 (OP_28007E0 ());
}


// DIVHU
rrrrr,111111,RRRRR + wwwww,01010000010:XI:::divhu
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"divhu r<reg1>, r<reg2>, r<reg3>"
{
  COMPAT_2 (OP_28207E0 ());
}


// DIVU
rrrrr,111111,RRRRR + wwwww,01011000010:XI:::divu
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"divu r<reg1>, r<reg2>, r<reg3>"
{
  COMPAT_2 (OP_2C207E0 ());
}


// DIVQ
rrrrr,111111,RRRRR + wwwww,01011111100:XI:::divq
*v850e2
*v850e2v3
*v850e3v5
"divq r<reg1>, r<reg2>, r<reg3>"
{
  unsigned int quotient;
  unsigned int remainder;
  unsigned int divide_by;
  unsigned int divide_this;

  TRACE_ALU_INPUT2 (GR[reg1], GR[reg2]);

  divide_by   = GR[reg1];
  divide_this = GR[reg2];
  v850_div (sd, divide_by, divide_this, &quotient, &remainder);
  GR[reg2] = quotient;
  GR[reg3] = remainder;

  TRACE_ALU_RESULT2 (GR[reg2], GR[reg3]);
}


// DIVQU
rrrrr,111111,RRRRR + wwwww,01011111110:XI:::divqu
*v850e2
*v850e2v3
*v850e3v5
"divq r<reg1>, r<reg2>, r<reg3>"
{
  unsigned int quotient;
  unsigned int remainder;
  unsigned int divide_by;
  unsigned int divide_this;

  TRACE_ALU_INPUT2 (GR[reg1], GR[reg2]);
  
  divide_by   = GR[reg1];
  divide_this = GR[reg2];
  v850_divu (sd, divide_by, divide_this, &quotient, &remainder);
  GR[reg2] = quotient;
  GR[reg3] = remainder;

  TRACE_ALU_RESULT2 (GR[reg2], GR[reg3]);
}


// EI
1000011111100000 + 0000000101100000:X:::ei
"ei"
{
  COMPAT_2 (OP_16087E0 ());
}



// EIRET
0000011111100000 + 0000000101001000:X:::eiret
"eiret"
*v850e2
*v850e2v3
*v850e3v5
{
  TRACE_ALU_INPUT1 (MPM & MPM_AUE);

  nia = EIPC;	/* next PC */
  if (MPM & MPM_AUE)
    {
      PSW = EIPSW;
    }
  else
    {
      PSW = (PSW & (PSW_NPV | PSW_DMP | PSW_IMP))
	| (EIPSW & ~(PSW_NPV | PSW_DMP | PSW_IMP));
    }

  TRACE_ALU_RESULT1 (PSW);
  TRACE_BRANCH_RESULT (nia);
}



// FERET
0000011111100000 + 0000000101001010:X:::feret
"feret"
*v850e2
*v850e2v3
*v850e3v5
{
  TRACE_ALU_INPUT1 (MPM & MPM_AUE);

  nia = FEPC;	/* next PC */
  if (MPM & MPM_AUE)
    {
      PSW = FEPSW;
    }
  else
    {
      PSW = (PSW & (PSW_NPV | PSW_DMP | PSW_IMP))
	| (FEPSW & ~(PSW_NPV | PSW_DMP | PSW_IMP));
    }

  TRACE_ALU_RESULT1 (PSW);
  TRACE_BRANCH_RESULT (nia);
}


// FETRAP
0,bbbb!0,00001000000:I:::fetrap
"fetrap"
*v850e2
*v850e2v3
*v850e3v5
{
  TRACE_ALU_INPUT0 ();

  FEPC = PC + 2;
  FEPSW = PSW;
  ECR &= ~ECR_FECC;
  ECR |= (0x30 + bit4) << 16;
  FEIC = 0x30 + bit4;
  PSW |= PSW_EP | PSW_ID | PSW_NP;
  nia = 0x30;	/* next PC */

  TRACE_ALU_RESULT1 (PSW);
  TRACE_BRANCH_RESULT (nia);
}


// HALT
0000011111100000 + 0000000100100000:X:::halt
"halt"
{
  COMPAT_2 (OP_12007E0 ());
}



// HSH
rrrrr,11111100000 + wwwww,01101000110:XII:::hsh
*v850e2
*v850e2v3
*v850e3v5
"hsh r<reg2>, r<reg3>"
{
  unsigned32 value;
  TRACE_ALU_INPUT1 (GR[reg2]);

  value = 0xffff & GR[reg2];
  GR[reg3] = GR[reg2];

  PSW &= ~(PSW_Z | PSW_S | PSW_CY | PSW_OV);

  if (value == 0) { PSW |= PSW_Z; PSW |= PSW_CY; }
  if (value & 0x80000000) PSW |= PSW_S;

  TRACE_ALU_RESULT1 (GR[reg3]);
}


// HSW
rrrrr,11111100000 + wwwww,01101000100:XII:::hsw
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"hsw r<reg2>, r<reg3>"
{
  unsigned32 value;
  TRACE_ALU_INPUT1 (GR[reg2]);

  value = GR[reg2];
  value >>= 16;
  value |= (GR[reg2] << 16);
  
  GR[reg3] = value;

  PSW &= ~(PSW_Z | PSW_S | PSW_CY | PSW_OV);

  if (value == 0) PSW |= PSW_Z;
  if (value & 0x80000000) PSW |= PSW_S;
  if (((value & 0xffff) == 0) || (value & 0xffff0000) == 0) PSW |= PSW_CY;

  TRACE_ALU_RESULT (GR[reg3]);
}



// JARL
rrrrr!0,11110,dddddd + ddddddddddddddd,0:V:::jarl
"jarl <disp22>, r<reg2>"
{
  GR[reg2] = nia;
  nia = cia + disp22;
  TRACE_BRANCH1 (GR[reg2]);
}

00000010111,RRRRR!0 + iiiiiiiiiiiiiiii + IIIIIIIIIIIIIIII:VI:::jarl32
*v850e2
*v850e2v3
*v850e3v5
"jarl <imm32>, r<reg1>"
{
  GR[reg1] = nia;
  nia = (cia + imm32) & ~1;

  TRACE_BRANCH_RESULT (nia);
}


11000111111,RRRRR + wwwww!0,00101100000:XI:::jarl_reg
*v850e3v5
"jarl [r<reg1>], r<reg3>"
{
  GR[reg3] = nia;
  nia = GR[reg1];
  TRACE_BRANCH_RESULT (nia);
}


// JMP
00000000011,RRRRR:I:::jmp
"jmp [r<reg1>]"
{
  nia = GR[reg1] & ~1;
  TRACE_BRANCH0 ();
}

00000110111,RRRRR + iiiiiiiiiiiiiiii + IIIIIIIIIIIIIIII:VI:::jmp32
*v850e2
*v850e2v3
*v850e3v5
"jmp <imm32>[r<reg1>]"
{
  nia = (GR[reg1] + imm32) & ~1;

  TRACE_BRANCH_RESULT (nia);
}


// JR
0000011110,dddddd + ddddddddddddddd,0:V:::jr
"jr <disp22>"
{
  nia = cia + disp22;
  TRACE_BRANCH0 ();
}


// JR32
0000001011100000 + iiiiiiiiiiiiiiii + IIIIIIIIIIIIIIII:VI:::jr32
*v850e2
*v850e2v3
*v850e3v5
"jr <imm32>"
{
  nia = (cia + imm32) & ~1;

  TRACE_BRANCH_RESULT (nia);
}


// LD
rrrrr,111000,RRRRR + dddddddddddddddd:VII:::ld.b
"ld.b <disp16>[r<reg1>], r<reg2>"
{
  COMPAT_2 (OP_700 ());
}

00000111100,RRRRR+wwwww,ddddddd,0101+dddddddddddddddd:XIV:::ld.b
"ld.b <disp23>[r<reg1>], r<reg3>"
*v850e2v3
*v850e3v5
{
  unsigned32 addr = GR[reg1] + disp23;
  unsigned32 result = EXTEND8 (load_data_mem (sd, addr, 1));
  GR[reg3] = result;
  TRACE_LD (addr, result);
}

rrrrr,111001,RRRRR + ddddddddddddddd,0:VII:::ld.h
"ld.h <disp16>[r<reg1>], r<reg2>"
{
  COMPAT_2 (OP_720 ());
}

00000111100,RRRRR+wwwww,dddddd,00111+dddddddddddddddd:XIV:::ld.h
*v850e2v3
*v850e3v5
"ld.h <disp23>[r<reg1>], r<reg3>"
{
  unsigned32 addr = GR[reg1] + disp23;
  unsigned32 result = EXTEND16 (load_data_mem (sd, addr, 2));
  GR[reg3] = result;
  TRACE_LD (addr, result);
}

rrrrr,111001,RRRRR + ddddddddddddddd,1:VII:::ld.w
"ld.w <disp16>[r<reg1>], r<reg2>"
{
  COMPAT_2 (OP_10720 ());
}

00000111100,RRRRR+wwwww,dddddd,01001+dddddddddddddddd:XIV:::ld.w
*v850e2v3
*v850e3v5
"ld.w <disp23>[r<reg1>], r<reg3>"
{
  unsigned32 addr = GR[reg1] + disp23;
  unsigned32 result = load_data_mem (sd, addr, 4);
  GR[reg3] = result;
  TRACE_LD (addr, result);
}

00000111101,RRRRR+wwwww,dddddd,01001+dddddddddddddddd:XIV:::ld.dw
*v850e3v5
"ld.dw <disp23>[r<reg1>], r<reg3>"
{
  unsigned32 addr = GR[reg1] + disp23;
  unsigned32 result = load_data_mem (sd, addr, 4);
  GR[reg3] = result;
  TRACE_LD (addr, result);
  result = load_data_mem (sd, addr + 4, 4);
  GR[reg3 + 1] = result;
  TRACE_LD (addr + 4, result);
}

rrrrr!0,11110,b,RRRRR + ddddddddddddddd,1:VII:::ld.bu
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"ld.bu <disp16>[r<reg1>], r<reg2>"
{
  COMPAT_2 (OP_10780 ());
}

00000111101,RRRRR+wwwww,ddddddd,0101+dddddddddddddddd:XIV:::ld.bu
*v850e2v3
*v850e3v5
"ld.bu <disp23>[r<reg1>], r<reg3>"
{ 
  unsigned32 addr = GR[reg1] + disp23;
  unsigned32 result = load_data_mem (sd, addr, 1);
  GR[reg3] = result;
  TRACE_LD (addr, result);
}

rrrrr!0,111111,RRRRR + ddddddddddddddd,1:VII:::ld.hu
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"ld.hu <disp16>[r<reg1>], r<reg2>"
{
  COMPAT_2 (OP_107E0 ());
}

00000111101,RRRRR+wwwww,dddddd,00111+dddddddddddddddd:XIV:::ld.hu
*v850e2v3
*v850e3v5
"ld.hu <disp23>[r<reg1>], r<reg3>"
{
  unsigned32 addr = GR[reg1] + disp23;
  unsigned32 result = load_data_mem (sd, addr, 2);
  GR[reg3] = result;
  TRACE_LD (addr, result);
}



// LDSR
regID,111111,RRRRR + selID,00000100000:IX:::ldsr
"ldsr r<reg1>, s<regID>":(selID == 0)
"ldsr r<reg1>, s<regID>, <selID>"
{
  uint32 sreg = GR[reg1];
  TRACE_ALU_INPUT1 (GR[reg1]);
  
  /* FIXME: For now we ignore the selID.  */
  if (   (idecode_issue == idecode_v850e2_issue
       || idecode_issue == idecode_v850e3v5_issue
       || idecode_issue == idecode_v850e2v3_issue)
      && regID < 28)
    {
      int protect_p = (PSW & PSW_NPV) ? 1 : 0;

      
      switch (BSEL & 0xffff)
	{
	case 0x0000:
	  if ((PSW & PSW_NPV)
	      && ((regID >= 8 && regID <= 12)
		  || (regID >= 22 && regID <= 27)
		  || regID == PSW_REGNO))
	    {
	      protect_p = 0;
	    }
	  break;
	case 0x1000:	/* MPU0 */
	  break;
	case 0x1001:	/* MPU1 */
	  break;
	case 0x2000:	/* FPU */
	  if ((PSW & PSW_NPV)
	      && ((/* regID >= 0 && */ regID <= 5)
		  || regID == 8 
		  || regID == 9 
		  || regID == 10 
		  || (regID >= 11 && regID <= 26)))
	    {
	      protect_p = 0;
	    }
	  break;
	case 0xff00:
	  if ((PSW & PSW_NPV)
	       && (regID == 6 
		   || regID == 7 
		   || regID == 8 
		   || regID == 9 
		   || regID == 10 
		   || (regID >= 11 && regID <= 15)
		   || regID == 18 
		   || regID == 19 
		   || (regID >= 21 && regID <= 27)))
	    {
	      protect_p = 0;
	    }
	  break;
	case 0xffff:
	  if ((PSW & PSW_NPV)
	       && (regID == 6 
		   || regID == 7 
		   || regID == 8 
		   || regID == 9 
		   || regID == 10 
		   || regID == 11 
		   || regID == 12 
		   || regID == 15 
		   || regID == 18 
		   || regID == 19 
		   || (regID >= 21 && regID <= 27)))
	    {
	      protect_p = 0;
	    }
	  break;
	}

      if (!protect_p)
	{
	  switch (BSEL & 0xffff)
	    {
	    case 0x0000:
	    case 0xff00:	/* user0 bank */
	    case 0xffff:	/* user1 bank */
	      if(regID == PSW_REGNO)
		{
		  SR[regID] = sreg & ((PSW & PSW_NPV) ? 0xf : ~0);
		}
	      else
		{
		  SR[regID] = sreg;
		}
	      break;
	    case 0x1000:
	      MPU0_SR[regID] = sreg;
	      break;
	    case 0x1001:
	      if (regID == MPC_REGNO)
		{
		  PPC &= ~PPC_PPE;
		  SPAL &= ~SPAL_SPE;
		  IPA0L &= ~IPA_IPE;
		  IPA1L &= ~IPA_IPE;
		  IPA2L &= ~IPA_IPE;
		  IPA3L &= ~IPA_IPE;
		  DPA0L &= ~DPA_DPE;
		  DPA1L &= ~DPA_DPE;
		  DCC &= ~(DCC_DCE0 | DCC_DCE1);
		}
	      else
		{
		  MPU1_SR[regID] = sreg;
		}
	      break;
	    case 0x2000:	/* FPU */
	      if (regID == FPST_REGNO)
		{
		  unsigned int val = FPSR & ~(FPSR_PR | FPSR_XC | FPSR_XP);
	      
		  val |= ((sreg & FPST_PR) ? FPSR_PR : 0)
		    | ((sreg & FPST_XCE) ? FPSR_XCE : 0)
		    | ((sreg & FPST_XCV) ? FPSR_XCV : 0)
		    | ((sreg & FPST_XCZ) ? FPSR_XCZ : 0)
		    | ((sreg & FPST_XCO) ? FPSR_XCO : 0)
		    | ((sreg & FPST_XCU) ? FPSR_XCU : 0)
		    | ((sreg & FPST_XCI) ? FPSR_XCI : 0)
		    | ((sreg & FPST_XPV) ? FPSR_XPV : 0)
		    | ((sreg & FPST_XPZ) ? FPSR_XPZ : 0)
		    | ((sreg & FPST_XPO) ? FPSR_XPO : 0)
		    | ((sreg & FPST_XPU) ? FPSR_XPU : 0)
		    | ((sreg & FPST_XPI) ? FPSR_XPI : 0);
		  FPSR = val;
		}
	      else if (regID == FPCFG_REGNO)
		{
		  unsigned int val = FPSR & ~(FPSR_RM | FPSR_XE);

		  val |= (((sreg & FPCFG_RM) >> 7) << 18)
		    | ((sreg & FPCFG_XEV) ? FPSR_XEV : 0)
		    | ((sreg & FPCFG_XEZ) ? FPSR_XEZ : 0)
		    | ((sreg & FPCFG_XEO) ? FPSR_XEO : 0)
		    | ((sreg & FPCFG_XEU) ? FPSR_XEU : 0)
		    | ((sreg & FPCFG_XEI) ? FPSR_XEI : 0);
		  FPSR = val;
		}

	      FPU_SR[regID] = sreg;
	      break;
	    }
	}
    }
  else
    {
      SR[regID] = sreg;
    }
 
  TRACE_ALU_RESULT (sreg);
}



// MAC
rrrrr,111111,RRRRR + wwww,0011110,mmmm,0:XI:::mac
*v850e2
*v850e2v3
*v850e3v5
"mac r<reg1>, r<reg2>, r<reg3e>, r<reg4e>"
{
  unsigned long op0;
  unsigned long op1;
  unsigned long op2;
  unsigned long op2hi;
  unsigned long lo;
  unsigned long mid1;
  unsigned long mid2;
  unsigned long hi;
  unsigned long RdLo;
  unsigned long RdHi;
  int           carry;
  bfd_boolean sign;

  op0 = GR[reg1];
  op1 = GR[reg2];
  op2 = GR[reg3e];
  op2hi = GR[reg3e+1];

  TRACE_ALU_INPUT4 (op0, op1, op2, op2hi);

  sign = (op0 ^ op1) & 0x80000000;
	  
  if (((signed long) op0) < 0)
    op0 = - op0;
	  
  if (((signed long) op1) < 0)
    op1 = - op1;
      
  /* We can split the 32x32 into four 16x16 operations. This ensures
     that we do not lose precision on 32bit only hosts: */
  lo   = ( (op0        & 0xFFFF) *  (op1        & 0xFFFF));
  mid1 = ( (op0        & 0xFFFF) * ((op1 >> 16) & 0xFFFF));
  mid2 = (((op0 >> 16) & 0xFFFF) *  (op1        & 0xFFFF));
  hi   = (((op0 >> 16) & 0xFFFF) * ((op1 >> 16) & 0xFFFF));
  
  /* We now need to add all of these results together, taking care
     to propogate the carries from the additions: */
  RdLo = Add32 (lo, (mid1 << 16), & carry);
  RdHi = carry;
  RdLo = Add32 (RdLo, (mid2 << 16), & carry);
  RdHi += (carry + ((mid1 >> 16) & 0xFFFF) + ((mid2 >> 16) & 0xFFFF) + hi);

  if (sign)
    {
      RdLo = ~ RdLo;
      RdHi = ~ RdHi;
      if (RdLo == 0xFFFFFFFF)
	{
	  RdLo = 0;
	  RdHi += 1;
	}
      else
	RdLo += 1;
    }

  RdLo = Add32 (RdLo, op2, & carry);
  RdHi += carry + op2hi; 

  /* Store the result and condition codes.  */
  GR[reg4e] = RdLo;
  GR[reg4e + 1 ] = RdHi;

  TRACE_ALU_RESULT2 (RdLo, RdHi);
}



// MACU
rrrrr,111111,RRRRR + wwww,0011111,mmmm,0:XI:::macu
*v850e2
*v850e2v3
*v850e3v5
"macu r<reg1>, r<reg2>, r<reg3e>, r<reg4e>"
{
  unsigned long op0;
  unsigned long op1;
  unsigned long op2;
  unsigned long op2hi;
  unsigned long lo;
  unsigned long mid1;
  unsigned long mid2;
  unsigned long hi;
  unsigned long RdLo;
  unsigned long RdHi;
  int           carry;
  
  op0 = GR[reg1];
  op1 = GR[reg2];
  op2 = GR[reg3e];
  op2hi = GR[reg3e + 1];

  TRACE_ALU_INPUT4 (op0, op1, op2, op2hi);

  /* We can split the 32x32 into four 16x16 operations. This ensures
     that we do not lose precision on 32bit only hosts: */
  lo   = ( (op0        & 0xFFFF) *  (op1        & 0xFFFF));
  mid1 = ( (op0        & 0xFFFF) * ((op1 >> 16) & 0xFFFF));
  mid2 = (((op0 >> 16) & 0xFFFF) *  (op1        & 0xFFFF));
  hi   = (((op0 >> 16) & 0xFFFF) * ((op1 >> 16) & 0xFFFF));
  
  /* We now need to add all of these results together, taking care
     to propogate the carries from the additions: */
  RdLo = Add32 (lo, (mid1 << 16), & carry);
  RdHi = carry;
  RdLo = Add32 (RdLo, (mid2 << 16), & carry);
  RdHi += (carry + ((mid1 >> 16) & 0xFFFF) + ((mid2 >> 16) & 0xFFFF) + hi);

  RdLo = Add32 (RdLo, op2, & carry);
  RdHi += carry + op2hi; 

  /* Store the result and condition codes.  */
  GR[reg4e] = RdLo;
  GR[reg4e+1] = RdHi;

  TRACE_ALU_RESULT2 (RdLo, RdHi);
}



// MOV
rrrrr!0,000000,RRRRR:I:::mov
"mov r<reg1>, r<reg2>"
{
  TRACE_ALU_INPUT0 ();
  GR[reg2] = GR[reg1];
  TRACE_ALU_RESULT (GR[reg2]);
}

rrrrr!0,010000,iiiii:II:::mov
"mov <imm5>, r<reg2>"
{
  COMPAT_1 (OP_200 ());
}

00000110001,RRRRR + iiiiiiiiiiiiiiii + IIIIIIIIIIIIIIII:VI:::mov
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"mov <imm32>, r<reg1>"
{
  SAVE_2;
  trace_input ("mov", OP_IMM_REG, 4);
  State.regs[ OP[0] ] = load_mem (PC + 2, 4);
  trace_output (OP_IMM_REG);
}



// MOVEA
rrrrr!0,110001,RRRRR + iiiiiiiiiiiiiiii:VI:::movea
"movea <simm16>, r<reg1>, r<reg2>"
{
  TRACE_ALU_INPUT2 (GR[reg1], simm16);
  GR[reg2] = GR[reg1] + simm16;
  TRACE_ALU_RESULT (GR[reg2]);
}



// MOVHI
rrrrr!0,110010,RRRRR + iiiiiiiiiiiiiiii:VI:::movhi
"movhi <uimm16>, r<reg1>, r<reg2>"
{
  COMPAT_2 (OP_640 ());
}



// MUL
rrrrr,111111,RRRRR + wwwww,01000100000:XI:::mul
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"mul r<reg1>, r<reg2>, r<reg3>"
{
  COMPAT_2 (OP_22007E0 ());
}

rrrrr,111111,iiiii + wwwww,01001,IIII,00:XII:::mul
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"mul <imm9>, r<reg2>, r<reg3>"
{
  COMPAT_2 (OP_24007E0 ());
}


// MULH
rrrrr!0,000111,RRRRR:I:::mulh
"mulh r<reg1>, r<reg2>"
{
  COMPAT_1 (OP_E0 ());
}

rrrrr!0,010111,iiiii:II:::mulh
"mulh <imm5>, r<reg2>"
{
  COMPAT_1 (OP_2E0 ());
}



// MULHI
rrrrr!0,110111,RRRRR + iiiiiiiiiiiiiiii:VI:::mulhi
"mulhi <uimm16>, r<reg1>, r<reg2>"
{
  COMPAT_2 (OP_6E0 ());
}



// MULU
rrrrr,111111,RRRRR + wwwww,01000100010:XI:::mulu
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"mulu r<reg1>, r<reg2>, r<reg3>"
{
  COMPAT_2 (OP_22207E0 ());
}

rrrrr,111111,iiiii + wwwww,01001,IIII,10:XII:::mulu
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"mulu <imm9>, r<reg2>, r<reg3>"
{
  COMPAT_2 (OP_24207E0 ());
}



// NOP
0000000000000000:I:::nop
"nop"
{
  /* do nothing, trace nothing */
}



// NOT
rrrrr,000001,RRRRR:I:::not
"not r<reg1>, r<reg2>"
{
  COMPAT_1 (OP_20 ());
}



// NOT1
01,bbb,111110,RRRRR + dddddddddddddddd:VIII:::not1
"not1 <bit3>, <disp16>[r<reg1>]"
{
  COMPAT_2 (OP_47C0 ());
}

rrrrr,111111,RRRRR + 0000000011100010:IX:::not1
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"not1 r<reg2>, r<reg1>"
{
  COMPAT_2 (OP_E207E0 ());
}



// OR
rrrrr,001000,RRRRR:I:::or
"or r<reg1>, r<reg2>"
{
  COMPAT_1 (OP_100 ());
}



// ORI 
rrrrr,110100,RRRRR + iiiiiiiiiiiiiiii:VI:::ori
"ori <uimm16>, r<reg1>, r<reg2>"
{
  COMPAT_2 (OP_680 ());
}



// PREPARE
0000011110,iiiii,L + LLLLLLLLLLL,00001:XIII:::prepare
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"prepare <list12>, <imm5>"
{
  int  i;
  SAVE_2;
  
  trace_input ("prepare", OP_PUSHPOP1, 0);
  
  /* Store the registers with lower number registers being placed at
     higher addresses.  */
  for (i = 0; i < 12; i++)
    if ((OP[3] & (1 << type1_regs[ i ])))
      {
	SP -= 4;
	store_mem (SP, 4, State.regs[ 20 + i ]);
      }
  
  SP -= (OP[3] & 0x3e) << 1;
  
  trace_output (OP_PUSHPOP1);
}


0000011110,iiiii,L + LLLLLLLLLLL,00011:XIII:::prepare00
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"prepare <list12>, <imm5>, sp"
{
  COMPAT_2 (OP_30780 ());
}

0000011110,iiiii,L + LLLLLLLLLLL,01011 + iiiiiiiiiiiiiiii:XIII:::prepare01
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"prepare <list12>, <imm5>, <uimm16>"
{
  COMPAT_2 (OP_B0780 ());
}

0000011110,iiiii,L + LLLLLLLLLLL,10011 + iiiiiiiiiiiiiiii:XIII:::prepare10
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"prepare <list12>, <imm5>, <uimm16>"
{
  COMPAT_2 (OP_130780 ());
}

0000011110,iiiii,L + LLLLLLLLLLL,11011 + iiiiiiiiiiiiiiii + dddddddddddddddd:XIII:::prepare11
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"prepare <list12>, <imm5>, <uimm32>"
{
  COMPAT_2 (OP_1B0780 ());
}



// RETI
0000011111100000 + 0000000101000000:X:::reti
"reti"
{
  if ((PSW & PSW_EP))
    {
      nia = (EIPC & ~1);
      PSW = EIPSW;
    }
  else if ((PSW & PSW_NP))
    {
      nia = (FEPC & ~1);
      PSW = FEPSW;
    }
  else
    {
      nia = (EIPC & ~1);
      PSW = EIPSW;
    }
  TRACE_BRANCH1 (PSW);
}



// SAR
rrrrr,111111,RRRRR + 0000000010100000:IX:::sar
"sar r<reg1>, r<reg2>"
{
  COMPAT_2 (OP_A007E0 ());
}

rrrrr,010101,iiiii:II:::sar
"sar <imm5>, r<reg2>"
{
  COMPAT_1 (OP_2A0 ());
}

rrrrr,111111,RRRRR + wwwww,00010100010:XI:::sar
*v850e2
*v850e2v3
*v850e3v5
"sar r<reg1>, r<reg2>, r<reg3>"
{
  TRACE_ALU_INPUT2 (GR[reg1], GR[reg2]);
  v850_sar(sd, GR[reg1], GR[reg2], &GR[reg3]); 
  TRACE_ALU_RESULT1 (GR[reg3]);
}


// SASF
rrrrr,1111110,cccc + 0000001000000000:IX:::sasf
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"sasf %s<cccc>, r<reg2>"
{
  COMPAT_2 (OP_20007E0 ());
}



// SATADD
rrrrr!0,000110,RRRRR:I:::satadd
"satadd r<reg1>, r<reg2>"
{
  COMPAT_1 (OP_C0 ());
}

rrrrr!0,010001,iiiii:II:::satadd
"satadd <imm5>, r<reg2>"
{
  COMPAT_1 (OP_220 ());
}

rrrrr,111111,RRRRR + wwwww,01110111010:XI:::satadd
*v850e2
*v850e2v3
*v850e3v5
"satadd r<reg1>, r<reg2>, r<reg3>"
{
  TRACE_ALU_INPUT2 (GR[reg1], GR[reg2]);
  v850_satadd (sd, GR[reg1], GR[reg2], &GR[reg3]);
  TRACE_ALU_RESULT1 (GR[reg3]);
}



// SATSUB
rrrrr!0,000101,RRRRR:I:::satsub
"satsub r<reg1>, r<reg2>"
{
  COMPAT_1 (OP_A0 ());
}

rrrrr,111111,RRRRR + wwwww,01110011010:XI:::satsub
*v850e2
*v850e2v3
*v850e3v5
"satsub r<reg1>, r<reg2>, r<reg3>"
{
  TRACE_ALU_INPUT2 (GR[reg1], GR[reg2]);
  v850_satsub (sd, GR[reg1], GR[reg2], &GR[reg3]);
  TRACE_ALU_RESULT1 (GR[reg3]);
}



// SATSUBI
rrrrr!0,110011,RRRRR + iiiiiiiiiiiiiiii:VI:::satsubi
"satsubi <simm16>, r<reg1>, r<reg2>"
{
  COMPAT_2 (OP_660 ());
}



// SATSUBR
rrrrr!0,000100,RRRRR:I:::satsubr
"satsubr r<reg1>, r<reg2>"
{
  COMPAT_1 (OP_80 ());
}



//SBF
rrrrr,111111,RRRRR + wwwww,011100,cccc!13,0:XI:::sbf
*v850e2
*v850e2v3
*v850e3v5
"sbf %s<cccc>, r<reg1>, r<reg2>, r<reg3>"
{
  int cond = condition_met (cccc);
  TRACE_ALU_INPUT3 (cond, GR[reg1], GR[reg2]);
  GR[reg3] = GR[reg2] - GR[reg1] - (cond ? 1 : 0);
  TRACE_ALU_RESULT1 (GR[reg3]);
}



// SCH0L
rrrrr,11111100000 + wwwww,01101100100:IX:::sch0l
*v850e2
*v850e2v3
*v850e3v5
"sch0l r<reg2>, r<reg3>"
{
  unsigned int pos, op0;

  TRACE_ALU_INPUT1 (GR[reg2]);

  op0 = GR[reg2];

  if (op0 == 0xffffffff)
    {
      PSW &= ~PSW_CY;
      PSW &= ~PSW_OV;
      PSW &= ~PSW_S;
      PSW |= PSW_Z;
      pos = 0;
    }
  else if (op0 == 0xfffffffe)
    {
      PSW |= PSW_CY;
      PSW &= ~PSW_OV;
      PSW &= ~PSW_S;
      PSW &= ~PSW_Z;
      pos = 32;
    }
  else
    {
      pos = 1;
      while (op0 & 0x80000000) 
	{
	  op0 <<= 1; 
	  pos++;
	}
      PSW &= ~PSW_CY;
      PSW &= ~PSW_OV;
      PSW &= ~PSW_S;
      PSW &= ~PSW_Z;
    }

  GR[reg3] = pos;

  TRACE_ALU_RESULT1 (GR[reg3]);
}



// SCH0R
rrrrr,11111100000 + wwwww,01101100000:IX:::sch0r
*v850e2
*v850e2v3
*v850e3v5
"sch0r r<reg2>, r<reg3>"
{
  unsigned int pos, op0;

  TRACE_ALU_INPUT1 (GR[reg2]);

  op0 = GR[reg2];

  if (op0 == 0xffffffff)
    {
      PSW &= ~PSW_CY;
      PSW &= ~PSW_OV;
      PSW &= ~PSW_S;
      PSW |= PSW_Z;
      pos = 0;
    }
  else if (op0 == 0x7fffffff)
    {
      PSW |= PSW_CY;
      PSW &= ~PSW_OV;
      PSW &= ~PSW_S;
      PSW &= ~PSW_Z;
      pos = 32;
    }
  else
    {
      pos = 1;
      while (op0 & 0x00000001) 
	{
	  op0 >>= 1; 
	  pos++;
	}
      PSW &= ~PSW_CY;
      PSW &= ~PSW_OV;
      PSW &= ~PSW_S;
      PSW &= ~PSW_Z;
    }

  GR[reg3] = pos;

  TRACE_ALU_RESULT1 (GR[reg3]);
}

// SCH1L
rrrrr,11111100000 + wwwww,01101100110:IX:::sch1l
*v850e2
*v850e2v3
*v850e3v5
"sch1l r<reg2>, r<reg3>"
{
  unsigned int pos, op0;

  TRACE_ALU_INPUT1 (GR[reg2]);

  op0 = GR[reg2];

  if (op0 == 0x00000000)
    {
      PSW &= ~PSW_CY;
      PSW &= ~PSW_OV;
      PSW &= ~PSW_S;
      PSW |= PSW_Z;
      pos = 0;
    }
  else if (op0 == 0x00000001)
    {
      PSW |= PSW_CY;
      PSW &= ~PSW_OV;
      PSW &= ~PSW_S;
      PSW &= ~PSW_Z;
      pos = 32;
    }
  else
    {
      pos = 1;
      while (!(op0 & 0x80000000)) 
	{
	  op0 <<= 1; 
	  pos++;
	}
      PSW &= ~PSW_CY;
      PSW &= ~PSW_OV;
      PSW &= ~PSW_S;
      PSW &= ~PSW_Z;
    }

  GR[reg3] = pos;

  TRACE_ALU_RESULT1 (GR[reg3]);
}

// SCH1R
rrrrr,11111100000 + wwwww,01101100010:IX:::sch1r
*v850e2
*v850e2v3
*v850e3v5
"sch1r r<reg2>, r<reg3>"
{
  unsigned int pos, op0;

  TRACE_ALU_INPUT1 (GR[reg2]);

  op0 = GR[reg2];

  if (op0 == 0x00000000)
    {
      PSW &= ~PSW_CY;
      PSW &= ~PSW_OV;
      PSW &= ~PSW_S;
      PSW |= PSW_Z;
      pos = 0;
    }
  else if (op0 == 0x80000000)
    {
      PSW |= PSW_CY;
      PSW &= ~PSW_OV;
      PSW &= ~PSW_S;
      PSW &= ~PSW_Z;
      pos = 32;
    }
  else
    {
      pos = 1;
      while (!(op0 & 0x00000001)) 
	{
	  op0 >>= 1;
	  pos++;
	}
      PSW &= ~PSW_CY;
      PSW &= ~PSW_OV;
      PSW &= ~PSW_S;
      PSW &= ~PSW_Z;
    }

  GR[reg3] = pos;

  TRACE_ALU_RESULT1 (GR[reg3]);
}

//SHL
rrrrr,111111,RRRRR + wwwww,00011000010:XI:::shl
*v850e2
*v850e2v3
*v850e3v5
"shl r<reg1>, r<reg2>, r<reg3>"
{
  TRACE_ALU_INPUT2 (GR[reg1], GR[reg2]);
  v850_shl(sd, GR[reg1], GR[reg2], &GR[reg3]);
  TRACE_ALU_RESULT1 (GR[reg3]);
}

//SHR
rrrrr,111111,RRRRR + wwwww,00010000010:XI:::shr
*v850e2
*v850e2v3
*v850e3v5
"shr r<reg1>, r<reg2>, r<reg3>"
{
  TRACE_ALU_INPUT2 (GR[reg1], GR[reg2]);
  v850_shr(sd, GR[reg1], GR[reg2], &GR[reg3]);
  TRACE_ALU_RESULT1 (GR[reg3]);
}



// SETF
rrrrr,1111110,cccc + 0000000000000000:IX:::setf
"setf %s<cccc>, r<reg2>"
{
  COMPAT_2 (OP_7E0 ());
}



// SET1
00,bbb,111110,RRRRR + dddddddddddddddd:VIII:::set1
"set1 <bit3>, <disp16>[r<reg1>]"
{
  COMPAT_2 (OP_7C0 ());
}

rrrrr,111111,RRRRR + 0000000011100000:IX:::set1
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"set1 r<reg2>, [r<reg1>]"
{
  COMPAT_2 (OP_E007E0 ());
}



// SHL
rrrrr,111111,RRRRR + 0000000011000000:IX:::shl
"shl r<reg1>, r<reg2>"
{
  COMPAT_2 (OP_C007E0 ());
}

rrrrr,010110,iiiii:II:::shl
"shl <imm5>, r<reg2>"
{
  COMPAT_1 (OP_2C0 ());
}



// SHR
rrrrr,111111,RRRRR + 0000000010000000:IX:::shr
"shr r<reg1>, r<reg2>"
{
  COMPAT_2 (OP_8007E0 ());
}

rrrrr,010100,iiiii:II:::shr
"shr <imm5>, r<reg2>"
{
  COMPAT_1 (OP_280 ());
}



// SLD
rrrrr,0110,ddddddd:IV:::sld.b
"sld.bu <disp7>[ep], r<reg2>":(PSW & PSW_US)
"sld.b <disp7>[ep], r<reg2>"
{
  unsigned32 addr = EP + disp7;
  unsigned32 result = load_mem (addr, 1);
  if (PSW & PSW_US)
    {
      GR[reg2] = result;
      TRACE_LD_NAME ("sld.bu", addr, result);
    }
  else
    {
      result = EXTEND8 (result);
      GR[reg2] = result;
      TRACE_LD (addr, result);
    }
}

rrrrr,1000,ddddddd:IV:::sld.h
"sld.hu <disp8>[ep], r<reg2>":(PSW & PSW_US)
"sld.h <disp8>[ep], r<reg2>"
{
  unsigned32 addr = EP + disp8;
  unsigned32 result = load_mem (addr, 2);
  if (PSW & PSW_US)
    {
      GR[reg2] = result;
      TRACE_LD_NAME ("sld.hu", addr, result);
    }
  else
    {
      result = EXTEND16 (result);
      GR[reg2] = result;
      TRACE_LD (addr, result);
    }
}

rrrrr,1010,dddddd,0:IV:::sld.w
"sld.w <disp8>[ep], r<reg2>"
{
  unsigned32 addr = EP + disp8;
  unsigned32 result = load_mem (addr, 4);
  GR[reg2] = result;
  TRACE_LD (addr, result);
}

rrrrr!0,0000110,dddd:IV:::sld.bu
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"sld.b <disp4>[ep], r<reg2>":(PSW & PSW_US)
"sld.bu <disp4>[ep], r<reg2>"
{
  unsigned32 addr = EP + disp4;
  unsigned32 result = load_mem (addr, 1);
  if (PSW & PSW_US)
    {
      result = EXTEND8 (result);
      GR[reg2] = result;
      TRACE_LD_NAME ("sld.b", addr, result);
    }
  else
    {
      GR[reg2] = result;
      TRACE_LD (addr, result);
    }
}

rrrrr!0,0000111,dddd:IV:::sld.hu
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"sld.h <disp5>[ep], r<reg2>":(PSW & PSW_US)
"sld.hu <disp5>[ep], r<reg2>"
{
  unsigned32 addr = EP + disp5;
  unsigned32 result = load_mem (addr, 2);
  if (PSW & PSW_US)
    {
      result = EXTEND16 (result);
      GR[reg2] = result;
      TRACE_LD_NAME ("sld.h", addr, result);
    }
  else
    {
      GR[reg2] = result;
      TRACE_LD (addr, result);
    }
}



// SST
rrrrr,0111,ddddddd:IV:::sst.b
"sst.b r<reg2>, <disp7>[ep]"
{
  COMPAT_1 (OP_380 ());
}

rrrrr,1001,ddddddd:IV:::sst.h
"sst.h r<reg2>, <disp8>[ep]"
{
  COMPAT_1 (OP_480 ());
}

rrrrr,1010,dddddd,1:IV:::sst.w
"sst.w r<reg2>, <disp8>[ep]"
{
  COMPAT_1 (OP_501 ());
}

// ST
rrrrr,111010,RRRRR + dddddddddddddddd:VII:::st.b
"st.b r<reg2>, <disp16>[r<reg1>]"
{
  COMPAT_2 (OP_740 ());
}

00000111100,RRRRR + wwwww,ddddddd,1101 + dddddddddddddddd:XIV:::st.b
*v850e2v3
*v850e3v5
"st.b r<reg3>, <disp23>[r<reg1>]"
{
  unsigned32 addr = GR[reg1] + disp23;
  store_data_mem (sd, addr, 1, GR[reg3]);
  TRACE_ST (addr, GR[reg3]);
}

rrrrr,111011,RRRRR + ddddddddddddddd,0:VII:::st.h
"st.h r<reg2>, <disp16>[r<reg1>]"
{
  COMPAT_2 (OP_760 ());
}

00000111101,RRRRR+wwwww,dddddd,01101+dddddddddddddddd:XIV:::st.h
*v850e2v3
*v850e3v5
"st.h r<reg3>, <disp23>[r<reg1>]"
{
  unsigned32 addr = GR[reg1] + disp23;
  store_data_mem (sd, addr, 2, GR[reg3]);
  TRACE_ST (addr, GR[reg3]);
}

rrrrr,111011,RRRRR + ddddddddddddddd,1:VII:::st.w
"st.w r<reg2>, <disp16>[r<reg1>]"
{
  COMPAT_2 (OP_10760 ());
}

00000111100,RRRRR+wwwww,dddddd,01111+dddddddddddddddd:XIV:::st.w
*v850e2v3
*v850e3v5
"st.w r<reg3>, <disp23>[r<reg1>]"
{
  unsigned32 addr = GR[reg1] + disp23;
  store_data_mem (sd, addr, 4, GR[reg3]);
  TRACE_ST (addr, GR[reg3]);
}

00000111101,RRRRR+wwwww,dddddd,01111+dddddddddddddddd:XIV:::st.dw
*v850e3v5
"st.dw r<reg3>, <disp23>[r<reg1>]"
{
  unsigned32 addr = GR[reg1] + disp23;
  store_data_mem (sd, addr, 4, GR[reg3]);
  TRACE_ST (addr, GR[reg3]);
  store_data_mem (sd, addr + 4, 4, GR[reg3 + 1]);
  TRACE_ST (addr + 4, GR[reg3 + 1]);
}


// STSR
rrrrr,111111,regID + 0000000001000000:IX:::stsr
"stsr s<regID>, r<reg2>"
{
  uint32 sreg = 0;

  if ((idecode_issue == idecode_v850e2_issue
       || idecode_issue == idecode_v850e3v5_issue
       || idecode_issue == idecode_v850e2v3_issue)
      && regID < 28)
    {
      switch (BSEL & 0xffff)
	{
	case 0x0000:
	case 0xff00:	/* USER 0 */
	case 0xffff:	/* USER 1 */
	  sreg = SR[regID];
	  break;
	case 0x1000:
	  sreg = MPU0_SR[regID];
	  break;
	case 0x1001:
	  sreg = MPU1_SR[regID];
	  break;
	case 0x2000:
	  if (regID == FPST_REGNO)
	    {
	      sreg = ((FPSR & FPSR_PR) ? FPST_PR : 0)
		| ((FPSR & FPSR_XCE) ? FPST_XCE : 0)
		| ((FPSR & FPSR_XCV) ? FPST_XCV : 0)
		| ((FPSR & FPSR_XCZ) ? FPST_XCZ : 0)
		| ((FPSR & FPSR_XCO) ? FPST_XCO : 0)
		| ((FPSR & FPSR_XCU) ? FPST_XCU : 0)
		| ((FPSR & FPSR_XCI) ? FPST_XCI : 0)
		| ((FPSR & FPSR_XPV) ? FPST_XPV : 0)
		| ((FPSR & FPSR_XPZ) ? FPST_XPZ : 0)
		| ((FPSR & FPSR_XPO) ? FPST_XPO : 0)
		| ((FPSR & FPSR_XPU) ? FPST_XPU : 0)
		| ((FPSR & FPSR_XPI) ? FPST_XPI : 0);
	    }
	  else if (regID == FPCFG_REGNO)
	    {
	      sreg = (((FPSR & FPSR_RM) >> 18) << 7)
		| ((FPSR & FPSR_XEV) ? FPCFG_XEV : 0)
		| ((FPSR & FPSR_XEZ) ? FPCFG_XEZ : 0)
		| ((FPSR & FPSR_XEO) ? FPCFG_XEO : 0)
		| ((FPSR & FPSR_XEU) ? FPCFG_XEU : 0)
		| ((FPSR & FPSR_XEI) ? FPCFG_XEI : 0);
	    }
	  else
	    {
	      sreg = FPU_SR[regID];
	    }
	  break;
	}
    }
  else
    {
      sreg = SR[regID];
    }

  TRACE_ALU_INPUT1 (sreg);
  GR[reg2] = sreg;
  TRACE_ALU_RESULT (GR[reg2]);
}

// SUB
rrrrr,001101,RRRRR:I:::sub
"sub r<reg1>, r<reg2>"
{
  COMPAT_1 (OP_1A0 ());
}

// SUBR
rrrrr,001100,RRRRR:I:::subr
"subr r<reg1>, r<reg2>"
{
  COMPAT_1 (OP_180 ());
}

// SWITCH
00000000010,RRRRR:I:::switch
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"switch r<reg1>"
{
  unsigned long adr;
  SAVE_1;
  trace_input ("switch", OP_REG, 0);
  adr = (cia + 2) + (State.regs[ reg1 ] << 1);
  nia = (cia + 2) + (EXTEND16 (load_mem (adr, 2)) << 1);
  trace_output (OP_REG);
}

// SXB
00000000101,RRRRR:I:::sxb
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"sxb r<reg1>"
{
  TRACE_ALU_INPUT1 (GR[reg1]);
  GR[reg1] = EXTEND8 (GR[reg1]);
  TRACE_ALU_RESULT (GR[reg1]);
}

// SXH
00000000111,RRRRR:I:::sxh
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"sxh r<reg1>"
{
  TRACE_ALU_INPUT1 (GR[reg1]);
  GR[reg1] = EXTEND16 (GR[reg1]);
  TRACE_ALU_RESULT (GR[reg1]);
}

// TRAP
00000111111,iiiii + 0000000100000000:X:::trap
"trap <vector>"
{
  COMPAT_2 (OP_10007E0 ());
}

// TST
rrrrr,001011,RRRRR:I:::tst
"tst r<reg1>, r<reg2>"
{
  COMPAT_1 (OP_160 ());
}

// TST1
11,bbb,111110,RRRRR + dddddddddddddddd:VIII:::tst1
"tst1 <bit3>, <disp16>[r<reg1>]"
{
  COMPAT_2 (OP_C7C0 ());
}

rrrrr,111111,RRRRR + 0000000011100110:IX:::tst1
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"tst1 r<reg2>, [r<reg1>]"
{
  COMPAT_2 (OP_E607E0 ());
}

// XOR
rrrrr,001001,RRRRR:I:::xor
"xor r<reg1>, r<reg2>"
{
  COMPAT_1 (OP_120 ());
}

// XORI
rrrrr,110101,RRRRR + iiiiiiiiiiiiiiii:VI:::xori
"xori <uimm16>, r<reg1>, r<reg2>"
{
  COMPAT_2 (OP_6A0 ());
}

// ZXB
00000000100,RRRRR:I:::zxb
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"zxb r<reg1>"
{
  TRACE_ALU_INPUT1 (GR[reg1]);
  GR[reg1] = GR[reg1] & 0xff;
  TRACE_ALU_RESULT (GR[reg1]);
}

// ZXH
00000000110,RRRRR:I:::zxh
*v850e
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"zxh r<reg1>"
{
  TRACE_ALU_INPUT1 (GR[reg1]);
  GR[reg1] = GR[reg1] & 0xffff;
  TRACE_ALU_RESULT (GR[reg1]);
}

// Right field must be zero so that it doesn't clash with DIVH
// Left field must be non-zero so that it doesn't clash with SWITCH
11111,000010,00000:I:::break
*v850
*v850e
{
  sim_engine_halt (SD, CPU, NULL, cia, sim_stopped, SIM_SIGTRAP);
}

11111,000010,00000:I:::dbtrap
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"dbtrap"
{
  if (STATE_OPEN_KIND (SD) == SIM_OPEN_DEBUG)
    {
      sim_engine_halt (SD, CPU, NULL, cia, sim_stopped, SIM_SIGTRAP);
    }
  else 
    {
    DBPC = cia + 2;
    DBPSW = PSW;
    PSW = PSW | (PSW_NP | PSW_EP | PSW_ID);
    PC = 0x00000060;
    nia = 0x00000060;
    TRACE_BRANCH0 ();
    }
}

// New breakpoint: 0x7E0 0x7E0
00000,111111,00000 + 00000,11111,100000:X:::ilgop
{
  sim_engine_halt (SD, CPU, NULL, cia, sim_stopped, SIM_SIGTRAP);
}

// Return from debug trap: 0x146007e0
0000011111100000 + 0000000101000110:X:::dbret
*v850e1
*v850e2
*v850e2v3
*v850e3v5
"dbret"
{
  nia = DBPC;
  PSW = DBPSW;
  TRACE_BRANCH1 (PSW);
}


//
// FLOAT
//

// Map condition code to a string
:%s::::FFFF:int FFFF
{
  switch (FFFF)
    {
    case 0: return "f";
    case 1: return "un";
    case 2: return "eq";
    case 3: return "ueq";
    case 4: return "olt";
    case 5: return "ult";
    case 6: return "ole";
    case 7: return "ule";
    case 8: return "sf";
    case 9: return "ngle";
    case 10: return "seq";
    case 11: return "ngl";
    case 12: return "lt";
    case 13: return "nge";
    case 14: return "le";
    case 15: return "ngt";
    }
  return "(null)";
}

// ABSF.D
rrrr,011111100000 + wwww,010001011000:F_I:::absf_d
*v850e2v3
*v850e3v5
"absf.d r<reg2e>, r<reg3e>"
{
  sim_fpu ans, wop;
  sim_fpu_status status;

  sim_fpu_232to (&wop, GR[reg2e+1], GR[reg2e]);
  TRACE_FP_INPUT_FPU1 (&wop);

  status = sim_fpu_abs (&ans, &wop);
  check_invalid_snan(sd, status, 1);

  sim_fpu_to232 (&GR[reg3e+1], &GR[reg3e], &ans);

  TRACE_FP_RESULT_FPU1 (&ans);
}

// ABSF.S
rrrrr,11111100000 + wwwww,10001001000:F_I:::absf_s
*v850e2v3
*v850e3v5
"absf.s r<reg2>, r<reg3>"
{
  sim_fpu ans, wop;
  sim_fpu_status status;

  sim_fpu_32to (&wop, GR[reg2]);
  TRACE_FP_INPUT_FPU1 (&wop);

  status = sim_fpu_abs (&ans, &wop);
  check_invalid_snan(sd, status, 0);

  sim_fpu_to32 (&GR[reg3], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// ADDF.D
rrrr,0111111,RRRR,0 + wwww,010001110000:F_I:::addf_d
*v850e2v3
*v850e3v5
"addf.d r<reg1e>, r<reg2e>, r<reg3e>"
{
  sim_fpu ans, wop1, wop2;
  sim_fpu_status status;

  sim_fpu_232to (&wop1, GR[reg1e+1], GR[reg1e]);
  sim_fpu_232to (&wop2, GR[reg2e+1], GR[reg2e]);
  TRACE_FP_INPUT_FPU2 (&wop1, &wop2);

  status = sim_fpu_add (&ans, &wop1, &wop2);
  status |= sim_fpu_round_64 (&ans, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);

  update_fpsr (sd, status, FPSR_XEV | FPSR_XEI | FPSR_XEO | FPSR_XEU, 1);

  sim_fpu_to232 (&GR[reg3e+1], &GR[reg3e], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// ADDF.S
rrrrr,111111,RRRRR + wwwww,10001100000:F_I:::addf_s
*v850e2v3
*v850e3v5
"addf.s r<reg1>, r<reg2>, r<reg3>"
{
  sim_fpu ans, wop1, wop2;
  sim_fpu_status status;

  sim_fpu_32to (&wop1, GR[reg1]);
  sim_fpu_32to (&wop2, GR[reg2]);
  TRACE_FP_INPUT_FPU2 (&wop1, &wop2);

  status = sim_fpu_add (&ans, &wop1, &wop2);
  status |= sim_fpu_round_32 (&ans, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);

  update_fpsr (sd, status, FPSR_XEV | FPSR_XEI | FPSR_XEO | FPSR_XEU, 0);

  sim_fpu_to32 (&GR[reg3], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// CMOVF.D
rrrr,0111111,RRRR,0 + wwww!0,01000001,bbb,0:F_I:::cmovf_d
*v850e2v3
*v850e3v5
"cmovf.d <bbb>, r<reg1e>, r<reg2e>, r<reg3e>"
{
  unsigned int ophi,oplow;
  sim_fpu ans, wop1, wop2;

  sim_fpu_232to (&wop1, GR[reg1e+1], GR[reg1e]);
  sim_fpu_232to (&wop2, GR[reg2e+1], GR[reg2e]);
  TRACE_FP_INPUT_BOOL1_FPU2 (TEST_FPCC(bbb), &wop1, &wop2);

  if (TEST_FPCC(bbb)) 
    {
      ophi = GR[reg1e+1];
      oplow = GR[reg1e];
      ans = wop1;
    }
  else
    {
      ophi = GR[reg2e+1];
      oplow = GR[reg2e];
      ans = wop2;
    }

  GR[reg3e+1] = ophi;
  GR[reg3e] = oplow;
  TRACE_FP_RESULT_FPU1 (&ans);;
}

// CMOVF.S
rrrrr,111111,RRRRR!0 + wwwww!0,1000000,bbb,0:F_I:::cmovf_s
*v850e2v3
*v850e3v5
"cmovf.d <bbb>, r<reg1>, r<reg2>, r<reg3>"
{
  unsigned int op;
  sim_fpu ans, wop1, wop2;

  sim_fpu_32to (&wop1, GR[reg1]);
  sim_fpu_32to (&wop2, GR[reg2]);
  TRACE_FP_INPUT_BOOL1_FPU2 (TEST_FPCC(bbb), &wop1, &wop2);

  if (TEST_FPCC(bbb)) 
  {
    op = GR[reg1];
    ans = wop1;
  }
  else
  {
    op = GR[reg2];
    ans = wop2;
  }

  GR[reg3] = op;
  TRACE_FP_RESULT_FPU1 (&ans);
}

// CMPF.D
rrrr,0111111,RRRR,0 + 0,FFFF,1000011,bbb,0:F_I:::cmpf_d
*v850e2v3
*v850e3v5
"cmpf.d %s<FFFF>, r<reg2e>, r<reg1e>":(bbb == 0)
"cmpf.d %s<FFFF>, r<reg2e>, r<reg1e>, <bbb>"
{
  int result;
  sim_fpu wop1;
  sim_fpu wop2;
  
  sim_fpu_232to (&wop1, GR[reg1e+1], GR[reg1e]);
  sim_fpu_232to (&wop2, GR[reg2e+1], GR[reg2e]);
  TRACE_FP_INPUT_FPU2 (&wop2, &wop1);

  result = v850_float_compare(sd, FFFF, wop2, wop1, 1);

  if (result)  
    SET_FPCC(bbb);
  else
    CLEAR_FPCC(bbb);

  TRACE_FP_RESULT_BOOL (result);
}

// CMPF.S
rrrrr,111111,RRRRR + 0,FFFF,1000010,bbb,0:F_I:::cmpf_s
*v850e2v3
*v850e3v5
"cmpf.s %s<FFFF>, r<reg2>, r<reg1>":(bbb == 0)
"cmpf.s %s<FFFF>, r<reg2>, r<reg1>, <bbb>"
{
  int result; 
  sim_fpu wop1;
  sim_fpu wop2;

  sim_fpu_32to( &wop1, GR[reg1] );
  sim_fpu_32to( &wop2, GR[reg2] );
  TRACE_FP_INPUT_FPU2 (&wop2, &wop1);

  result = v850_float_compare(sd, FFFF, wop2, wop1, 0);

  if (result)  
    SET_FPCC(bbb);
  else
    CLEAR_FPCC(bbb);

  TRACE_FP_RESULT_BOOL (result);
}

// CVTF.DL
rrrr,011111100100 + wwww,010001010100:F_I:::cvtf_dl
*v850e2v3
*v850e3v5
"cvtf.dl r<reg2e>, r<reg3e>"
{
  unsigned64 ans;
  sim_fpu wop;
  sim_fpu_status status;

  sim_fpu_232to (&wop, GR[reg2e+1], GR[reg2e]);
  TRACE_FP_INPUT_FPU1 (&wop);

  status = sim_fpu_round_64 (&wop, FPSR_GET_ROUND(), sim_fpu_denorm_zero);
  status |= sim_fpu_to64i (&ans, &wop, FPSR_GET_ROUND());

  check_cvt_fi(sd, status, 1);

  GR[reg3e] = ans;
  GR[reg3e+1] = ans>>32L;
  TRACE_FP_RESULT_WORD2 (GR[reg3e], GR[reg3e+1]);
}

// CVTF.DS
rrrr,011111100011 + wwwww,10001010010:F_I:::cvtf_ds
*v850e2v3
*v850e3v5
"cvtf.ds r<reg2e>, r<reg3>"
{
  sim_fpu wop;
  sim_fpu_status status;

  sim_fpu_232to (&wop, GR[reg2e+1], GR[reg2e]);
  TRACE_FP_INPUT_FPU1 (&wop);

  status = sim_fpu_round_32 (&wop, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);

  check_cvt_fi(sd, status, 0);

  sim_fpu_to32 (&GR[reg3], &wop);
  TRACE_FP_RESULT_FPU1 (&wop);
}

// CVTF.DW
rrrr,011111100100 + wwwww,10001010000:F_I:::cvtf_dw
*v850e2v3
*v850e3v5
"cvtf.dw r<reg2e>, r<reg3>"
{
  uint32 ans;
  sim_fpu wop;
  sim_fpu_status status;

  sim_fpu_232to (&wop, GR[reg2e+1], GR[reg2e]);
  TRACE_FP_INPUT_FPU1 (&wop);

  status = sim_fpu_round_32 (&wop, FPSR_GET_ROUND(), sim_fpu_denorm_zero);
  status |= sim_fpu_to32i (&ans, &wop, FPSR_GET_ROUND());

  check_cvt_fi(sd, status, 1);

  GR[reg3] = ans;
  TRACE_FP_RESULT_WORD1 (ans);
}

// CVTF.LD
rrrr,011111100001 + wwww,010001010010:F_I:::cvtf_ld
*v850e2v3
*v850e3v5
"cvtf.ld r<reg2e>, r<reg3e>"
{
  signed64 op;
  sim_fpu wop;
  sim_fpu_status status;

  op = ((signed64)GR[reg2e+1] << 32L) | GR[reg2e];
  TRACE_FP_INPUT_WORD2 (GR[reg2e], GR[reg2e+1]);

  sim_fpu_i64to (&wop, op, FPSR_GET_ROUND());
  status = sim_fpu_round_64 (&wop, FPSR_GET_ROUND(), sim_fpu_denorm_zero);

  check_cvt_if(sd, status, 1);

  sim_fpu_to232 (&GR[reg3e+1], &GR[reg3e], &wop);
  TRACE_FP_RESULT_FPU1 (&wop);
}

// CVTF.LS
rrrr,011111100001 + wwwww,10001000010:F_I:::cvtf_ls
*v850e2v3
*v850e3v5
"cvtf.ls r<reg2e>, r<reg3>"
{
  signed64 op;
  sim_fpu wop;
  sim_fpu_status status;

  op = ((signed64)GR[reg2e+1] << 32L) | GR[reg2e];
  TRACE_FP_INPUT_WORD2 (GR[reg2e], GR[reg2e+1]);

  sim_fpu_i64to (&wop, op, FPSR_GET_ROUND());
  status = sim_fpu_round_32 (&wop, FPSR_GET_ROUND(), sim_fpu_denorm_zero);

  check_cvt_if(sd, status, 0);

  sim_fpu_to32 (&GR[reg3], &wop);
  TRACE_FP_RESULT_FPU1 (&wop);
}

// CVTF.SD
rrrrr,11111100010 + wwww,010001010010:F_I:::cvtf_sd
*v850e2v3
*v850e3v5
"cvtf.sd r<reg2>, r<reg3e>"
{
  sim_fpu wop;
  sim_fpu_status status;

  sim_fpu_32to (&wop, GR[reg2]);
  TRACE_FP_INPUT_FPU1 (&wop);
  status = sim_fpu_round_64 (&wop, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);

  check_cvt_ff(sd, status, 1);

  sim_fpu_to232 (&GR[reg3e+1], &GR[reg3e], &wop);
  TRACE_FP_RESULT_FPU1 (&wop);
}

// CVTF.SL
rrrrr,11111100100 + wwww,010001000100:F_I:::cvtf_sl
*v850e2v3
*v850e3v5
"cvtf.sl r<reg2>, r<reg3e>"
{
  signed64 ans;
  sim_fpu wop;
  sim_fpu_status status;

  sim_fpu_32to (&wop, GR[reg2]);
  TRACE_FP_INPUT_FPU1 (&wop);

  status = sim_fpu_round_64 (&wop, FPSR_GET_ROUND(), sim_fpu_denorm_zero);
  status |= sim_fpu_to64i (&ans, &wop, FPSR_GET_ROUND());

  check_cvt_fi(sd, status, 0);

  GR[reg3e] = ans;
  GR[reg3e+1] = ans >> 32L;
  TRACE_FP_RESULT_WORD2 (GR[reg3e], GR[reg3e+1]);
}

// CVTF.SW
rrrrr,11111100100 + wwwww,10001000000:F_I:::cvtf_sw
*v850e2v3
*v850e3v5
"cvtf.sw r<reg2>, r<reg3>"
{
  uint32 ans;
  sim_fpu wop;
  sim_fpu_status status;

  sim_fpu_32to (&wop, GR[reg2]);
  TRACE_FP_INPUT_FPU1 (&wop);

  status = sim_fpu_round_32 (&wop, FPSR_GET_ROUND(), sim_fpu_denorm_zero);
  status |= sim_fpu_to32i (&ans, &wop, sim_fpu_round_zero);

  check_cvt_fi(sd, status, 0);

  GR[reg3] = ans;
  TRACE_FP_RESULT_WORD1 (ans);
}

// CVTF.WD
rrrrr,11111100000 + wwww,010001010010:F_I:::cvtf_wd
*v850e2v3
*v850e3v5
"cvtf.wd r<reg2>, r<reg3e>"
{
  sim_fpu wop;
  sim_fpu_status status;

  TRACE_FP_INPUT_WORD1 (GR[reg2]);
  sim_fpu_i32to (&wop, GR[reg2], FPSR_GET_ROUND());
  status = sim_fpu_round_64 (&wop, FPSR_GET_ROUND(), sim_fpu_denorm_zero);

  check_cvt_if(sd, status, 1);

  sim_fpu_to232 (&GR[reg3e+1], &GR[reg3e], &wop);
  TRACE_FP_RESULT_FPU1 (&wop);
}

// CVTF.WS
rrrrr,11111100000 + wwwww,10001000010:F_I:::cvtf_ws
*v850e2v3
*v850e3v5
"cvtf.ws r<reg2>, r<reg3>"
{
  sim_fpu wop;
  sim_fpu_status status;

  TRACE_FP_INPUT_WORD1 (GR[reg2]);
  sim_fpu_i32to (&wop, GR[reg2], FPSR_GET_ROUND());
  status = sim_fpu_round_32 (&wop, FPSR_GET_ROUND(), sim_fpu_denorm_zero);

  check_cvt_if(sd, status, 0);

  sim_fpu_to32 (&GR[reg3], &wop);
  TRACE_FP_RESULT_FPU1 (&wop);
}

// DIVF.D
rrrr,0111111,RRRR,0 + wwww,010001111110:F_I:::divf_d
*v850e2v3
*v850e3v5
"divf.d r<reg1e>, r<reg2e>, r<reg3e>"
{
  sim_fpu ans, wop1, wop2;
  sim_fpu_status status;

  sim_fpu_232to (&wop1, GR[reg1e+1], GR[reg1e]);
  sim_fpu_232to (&wop2, GR[reg2e+1], GR[reg2e]);
  TRACE_FP_INPUT_FPU2 (&wop1, &wop2);

  status = sim_fpu_div (&ans, &wop2, &wop1);
  status |= sim_fpu_round_64 (&ans, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);

  update_fpsr (sd, status, FPSR_XEV | FPSR_XEZ | FPSR_XEI | FPSR_XEO | FPSR_XEU, 1);

  sim_fpu_to232 (&GR[reg3e+1], &GR[reg3e], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// DIVF.S
rrrrr,111111,RRRRR + wwwww,10001101110:F_I:::divf_s
*v850e2v3
*v850e3v5
"divf.s r<reg1>, r<reg2>, r<reg3>"
{
  sim_fpu ans, wop1, wop2;
  sim_fpu_status status;

  sim_fpu_32to (&wop1, GR[reg1]);
  sim_fpu_32to (&wop2, GR[reg2]);
  TRACE_FP_INPUT_FPU2 (&wop1, &wop2);

  status = sim_fpu_div (&ans, &wop2, &wop1);
  status |= sim_fpu_round_32 (&ans, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);

  update_fpsr (sd, status, FPSR_XEV | FPSR_XEZ | FPSR_XEI | FPSR_XEO | FPSR_XEU, 0);

  sim_fpu_to32 (&GR[reg3], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// MADDF.S
rrrrr,111111,RRRRR + wwwww,101,W,00,WWWW,0:F_I:::maddf_s
*v850e2v3
*v850e3v5
"maddf.s r<reg1>, r<reg2>, r<reg3>, r<reg4>"
{
  sim_fpu ans, wop1, wop2, wop3;
  sim_fpu_status status;

  sim_fpu_32to (&wop1, GR[reg1]);
  sim_fpu_32to (&wop2, GR[reg2]);
  sim_fpu_32to (&wop3, GR[reg3]);
  TRACE_FP_INPUT_FPU3 (&wop1, &wop2, &wop3);

  status = sim_fpu_mul (&ans, &wop1, &wop2);
  wop1 = ans;
  status |= sim_fpu_add (&ans, &wop1, &wop3);
  status |= sim_fpu_round_64 (&ans, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);

  update_fpsr (sd, status, FPSR_XEV | FPSR_XEI | FPSR_XEO | FPSR_XEU, 0);

  sim_fpu_to32 (&GR[reg4], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// MAXF.D
rrrr,0111111,RRRR,0 + wwww,010001111000:F_I:::maxf_d
*v850e2v3
*v850e3v5
"maxf.d r<reg1e>, r<reg2e>, r<reg3e>"
{
  sim_fpu ans, wop1, wop2;

  sim_fpu_232to (&wop1, GR[reg1e+1], GR[reg1e]);
  sim_fpu_232to (&wop2, GR[reg2e+1], GR[reg2e]);
  TRACE_FP_INPUT_FPU2 (&wop1, &wop2);

  if (sim_fpu_is_nan(&wop1) || sim_fpu_is_nan(&wop2))
    {
      if (FPSR & FPSR_XEV)
	{
	  SignalExceptionFPE(sd, 1);
	}
      else
	{
	  ans = sim_fpu_qnan;
	}
    }
  else if (FPSR & FPSR_FS
	   && ((sim_fpu_is_zero (&wop1) || sim_fpu_is_denorm (&wop1))
	       && (sim_fpu_is_zero (&wop2) || sim_fpu_is_denorm (&wop2)))) 
    {
      ans = sim_fpu_zero;
    }
  else
    {
      sim_fpu_max (&ans, &wop1, &wop2);
    }
  
  sim_fpu_to232 (&GR[reg3e+1], &GR[reg3e], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// MAXF.S
rrrrr,111111,RRRRR + wwwww,10001101000:F_I:::maxf_s
*v850e2v3
*v850e3v5
"maxf.s r<reg1>, r<reg2>, r<reg3>"
{
  sim_fpu ans, wop1, wop2;

  sim_fpu_32to (&wop1, GR[reg1]);
  sim_fpu_32to (&wop2, GR[reg2]);
  TRACE_FP_INPUT_FPU2 (&wop1, &wop2);

  if (sim_fpu_is_nan(&wop1) || sim_fpu_is_nan(&wop2))
    {
      if (FPSR & FPSR_XEV)
	{
	  SignalExceptionFPE(sd, 0);
	}
      else
	{
	  ans = sim_fpu_qnan;
	}
    }
  else if ((FPSR & FPSR_FS)
	   && ((sim_fpu_is_zero (&wop1) || sim_fpu_is_denorm (&wop1))
	       && (sim_fpu_is_zero (&wop2)|| sim_fpu_is_denorm (&wop2))))
    {
      ans = sim_fpu_zero;
    }
  else
    {
      sim_fpu_max (&ans, &wop1, &wop2);
    }
  
  sim_fpu_to32 (&GR[reg3], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// MINF.D
rrrr,0111111,RRRR,0 + wwww,010001111010:F_I:::minf_d
*v850e2v3
*v850e3v5
"minf.d r<reg1e>, r<reg2e>, r<reg3e>"
{
  sim_fpu ans, wop1, wop2;

  sim_fpu_232to (&wop1, GR[reg1e+1], GR[reg1e]);
  sim_fpu_232to (&wop2, GR[reg2e+1], GR[reg2e]);
  TRACE_FP_INPUT_FPU2 (&wop1, &wop2);

  if (sim_fpu_is_nan(&wop1) || sim_fpu_is_nan(&wop2))
    {
      if (FPSR & FPSR_XEV)
	{
	  SignalExceptionFPE(sd, 1);
	}
      else
	{
	  ans = sim_fpu_qnan;
	}
    }
  else if (FPSR & FPSR_FS
	   && ((sim_fpu_is_zero (&wop1) || sim_fpu_is_denorm (&wop1))
	       && (sim_fpu_is_zero (&wop2) || sim_fpu_is_denorm (&wop2)))) 
    {
      ans = sim_fpu_zero;
    }
  else
    {
      sim_fpu_min (&ans, &wop1, &wop2);
    }
  
  sim_fpu_to232 (&GR[reg3e+1], &GR[reg3e], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// MINF.S
rrrrr,111111,RRRRR + wwwww,10001101010:F_I:::minf_s
*v850e2v3
*v850e3v5
"minf.s r<reg1>, r<reg2>, r<reg3>"
{
  sim_fpu ans, wop1, wop2;

  sim_fpu_32to (&wop1, GR[reg1]);
  sim_fpu_32to (&wop2, GR[reg2]);
  TRACE_FP_INPUT_FPU2 (&wop1, &wop2);

  if (sim_fpu_is_nan(&wop1) || sim_fpu_is_nan(&wop2))
    {
      if (FPSR & FPSR_XEV)
	{
	  SignalExceptionFPE(sd, 0);
	}
      else
	{
	  ans = sim_fpu_qnan;
	}
    }
  else if (FPSR & FPSR_FS
	   && ((sim_fpu_is_zero (&wop1) || sim_fpu_is_denorm (&wop1))
	       && (sim_fpu_is_zero (&wop2) || sim_fpu_is_denorm (&wop2))))
    {
      ans = sim_fpu_zero;
    }
  else
    {
      sim_fpu_min (&ans, &wop1, &wop2);
    }
  
  sim_fpu_to32 (&GR[reg3], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// MSUBF.S
rrrrr,111111,RRRRR + wwwww,101,W,01,WWWW,0:F_I:::msubf_s
*v850e2v3
*v850e3v5
"msubf.s r<reg1>, r<reg2>, r<reg3>, r<reg4>"
{
  sim_fpu ans, wop1, wop2, wop3;
  sim_fpu_status status;

  sim_fpu_32to (&wop1, GR[reg1]);
  sim_fpu_32to (&wop2, GR[reg2]);
  sim_fpu_32to (&wop3, GR[reg3]);
  TRACE_FP_INPUT_FPU3 (&wop1, &wop2, &wop3);

  status = sim_fpu_mul (&ans, &wop1, &wop2);
  status |= sim_fpu_round_64 (&ans, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);
  wop1 = ans;
  status |= sim_fpu_sub (&ans, &wop1, &wop3);
  status |= sim_fpu_round_64 (&ans, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);

  update_fpsr (sd, status, FPSR_XEV | FPSR_XEI | FPSR_XEO | FPSR_XEU, 0);

  sim_fpu_to32 (&GR[reg4], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// MULF.D
rrrr,0111111,RRRR,0 + wwww,010001110100:F_I:::mulf_d
*v850e2v3
*v850e3v5
"mulf.d r<reg1e>, r<reg2e>, r<reg3e>"
{
  sim_fpu ans, wop1, wop2;
  sim_fpu_status status;

  sim_fpu_232to (&wop1, GR[reg1e+1], GR[reg1e]);
  sim_fpu_232to (&wop2, GR[reg2e+1], GR[reg2e]);
  TRACE_FP_INPUT_FPU2 (&wop1, &wop2);

  status = sim_fpu_mul (&ans, &wop1, &wop2);
  status |= sim_fpu_round_64 (&ans, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);

  update_fpsr (sd, status, FPSR_XEV | FPSR_XEI | FPSR_XEO | FPSR_XEU, 1);

  sim_fpu_to232 (&GR[reg3e+1], &GR[reg3e], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// MULF.S
rrrrr,111111,RRRRR + wwwww,10001100100:F_I:::mulf_s
*v850e2v3
*v850e3v5
"mulf.s r<reg1>, r<reg2>, r<reg3>"
{
  sim_fpu ans, wop1, wop2;
  sim_fpu_status status;

  sim_fpu_32to (&wop1, GR[reg1]);
  sim_fpu_32to (&wop2, GR[reg2]);
  TRACE_FP_INPUT_FPU2 (&wop1, &wop2);

  status = sim_fpu_mul (&ans, &wop1, &wop2);
  status |= sim_fpu_round_32 (&ans, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);

  update_fpsr (sd, status, FPSR_XEV | FPSR_XEI | FPSR_XEO | FPSR_XEU, 0);

  sim_fpu_to32 (&GR[reg3], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// NEGF.D
rrrr,011111100001 + wwww,010001011000:F_I:::negf_d
*v850e2v3
*v850e3v5
"negf.d r<reg2e>, r<reg3e>"
{
  sim_fpu ans, wop;
  sim_fpu_status status;

  sim_fpu_232to (&wop, GR[reg2e+1], GR[reg2e]);
  TRACE_FP_INPUT_FPU1 (&wop);

  status = sim_fpu_neg (&ans, &wop);

  check_invalid_snan(sd, status, 1);

  sim_fpu_to232 (&GR[reg3e+1], &GR[reg3e], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// NEGF.S
rrrrr,11111100001 + wwwww,10001001000:F_I:::negf_s
*v850e2v3
*v850e3v5
"negf.s r<reg2>, r<reg3>"
{
  sim_fpu ans, wop;
  sim_fpu_status status;

  sim_fpu_32to (&wop, GR[reg2]);
  TRACE_FP_INPUT_FPU1 (&wop);

  status = sim_fpu_neg (&ans, &wop);

  check_invalid_snan(sd, status, 0);

  sim_fpu_to32 (&GR[reg3], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// NMADDF.S
rrrrr,111111,RRRRR + wwwww,101,W,10,WWWW,0:F_I:::nmaddf_s
*v850e2v3
*v850e3v5
"nmaddf.s r<reg1>, r<reg2>, r<reg3>, r<reg4>"
{
  sim_fpu ans, wop1, wop2, wop3;
  sim_fpu_status status;

  sim_fpu_32to (&wop1, GR[reg1]);
  sim_fpu_32to (&wop2, GR[reg2]);
  sim_fpu_32to (&wop3, GR[reg3]);
  TRACE_FP_INPUT_FPU3 (&wop1, &wop2, &wop3);

  status = sim_fpu_mul (&ans, &wop1, &wop2);
  wop1 = ans;
  status |= sim_fpu_add (&ans, &wop1, &wop3);
  status |= sim_fpu_round_64 (&ans, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);
  wop1 = ans;
  status |= sim_fpu_neg (&ans, &wop1);

  update_fpsr (sd, status, FPSR_XEV | FPSR_XEI | FPSR_XEO | FPSR_XEU, 0);

  sim_fpu_to32 (&GR[reg4], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// NMSUBF.S
rrrrr,111111,RRRRR + wwwww,101,W,11,WWWW,0:F_I:::nmsubf_s
*v850e2v3
*v850e3v5
"nmsubf.s r<reg1>, r<reg2>, r<reg3>, r<reg4>"
{
  sim_fpu ans, wop1, wop2, wop3;
  sim_fpu_status status;

  sim_fpu_32to (&wop1, GR[reg1]);
  sim_fpu_32to (&wop2, GR[reg2]);
  sim_fpu_32to (&wop3, GR[reg3]);
  TRACE_FP_INPUT_FPU3 (&wop1, &wop2, &wop3);

  status = sim_fpu_mul (&ans, &wop1, &wop2);
  status |= sim_fpu_round_64 (&ans, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);
  wop1 = ans;
  status |= sim_fpu_sub (&ans, &wop1, &wop3);
  status |= sim_fpu_round_64 (&ans, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);
  wop1 = ans;
  status |= sim_fpu_neg (&ans, &wop1);

  update_fpsr (sd, status, FPSR_XEV | FPSR_XEI | FPSR_XEO | FPSR_XEU, 0);

  sim_fpu_to32 (&GR[reg4], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// RECIPF.D
rrrr,011111100001 + wwww,010001011110:F_I:::recipf.d
*v850e2v3
*v850e3v5
"recipf.d r<reg2e>, r<reg3e>"
{
  sim_fpu ans, wop;
  sim_fpu_status status;

  sim_fpu_232to (&wop, GR[reg2e+1], GR[reg2e]);
  TRACE_FP_INPUT_FPU1 (&wop);

  status = sim_fpu_div (&ans, &sim_fpu_one, &wop);
  status |= sim_fpu_round_64 (&ans, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);

  update_fpsr (sd, status, FPSR_XEV | FPSR_XEZ | FPSR_XEI | FPSR_XEO | FPSR_XEU, 1);

  sim_fpu_to232 (&GR[reg3e+1], &GR[reg3e], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// RECIPF.S
rrrrr,11111100001 + wwwww,10001001110:F_I:::recipf.s
*v850e2v3
*v850e3v5
"recipf.s r<reg2>, r<reg3>"
{
  sim_fpu ans, wop;
  sim_fpu_status status;

  sim_fpu_32to (&wop, GR[reg2]);
  TRACE_FP_INPUT_FPU1 (&wop);

  status = sim_fpu_div (&ans, &sim_fpu_one, &wop);
  status |= sim_fpu_round_64 (&ans, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);

  update_fpsr (sd, status, FPSR_XEV | FPSR_XEZ | FPSR_XEI | FPSR_XEO | FPSR_XEU, 0);

  sim_fpu_to32 (&GR[reg3], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// RSQRTF.D
rrrr,011111100010 + wwww,010001011110:F_I:::rsqrtf.d
*v850e2v3
*v850e3v5
"rsqrtf.d r<reg2e>, r<reg3e>"
{
  sim_fpu ans, wop;
  sim_fpu_status status;

  sim_fpu_232to (&wop, GR[reg2e+1], GR[reg2e]);
  TRACE_FP_INPUT_FPU1 (&wop);

  status = sim_fpu_sqrt (&ans, &wop);
  status |= sim_fpu_round_64 (&ans, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);
  wop = ans;
  status = sim_fpu_div (&ans, &sim_fpu_one, &wop);
  status |= sim_fpu_round_64 (&ans, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);

  update_fpsr (sd, status, FPSR_XEV | FPSR_XEZ | FPSR_XEI | FPSR_XEO | FPSR_XEU, 1);

  sim_fpu_to232 (&GR[reg3e+1], &GR[reg3e], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// RSQRTF.S
rrrrr,11111100010 + wwwww,10001001110:F_I:::rsqrtf.s
*v850e2v3
*v850e3v5
"rsqrtf.s r<reg2>, r<reg3>"
{
  sim_fpu ans, wop;
  sim_fpu_status status;

  sim_fpu_32to (&wop, GR[reg2]);
  TRACE_FP_INPUT_FPU1 (&wop);

  status = sim_fpu_sqrt (&ans, &wop);
  status |= sim_fpu_round_32 (&ans, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);
  wop = ans;
  status = sim_fpu_div (&ans, &sim_fpu_one, &wop);
  status |= sim_fpu_round_32 (&ans, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);

  update_fpsr (sd, status, FPSR_XEV | FPSR_XEZ | FPSR_XEI | FPSR_XEO | FPSR_XEU, 0);

  sim_fpu_to32 (&GR[reg3], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// SQRTF.D
rrrr,011111100000 + wwww,010001011110:F_I:::sqrtf.d
*v850e2v3
*v850e3v5
"sqrtf.d r<reg2e>, r<reg3e>"
{
  sim_fpu ans, wop;
  sim_fpu_status status;

  sim_fpu_232to (&wop, GR[reg2e+1], GR[reg2e]);
  TRACE_FP_INPUT_FPU1 (&wop);

  status = sim_fpu_sqrt (&ans, &wop);
  status |= sim_fpu_round_64 (&ans, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);

  update_fpsr (sd, status, FPSR_XEV | FPSR_XEI, 1);

  sim_fpu_to232 (&GR[reg3e+1], &GR[reg3e], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// SQRTF.S
rrrrr,11111100000 + wwwww,10001001110:F_I:::sqrtf.s
*v850e2v3
*v850e3v5
"sqrtf.s r<reg2>, r<reg3>"
{
  sim_fpu ans, wop;
  sim_fpu_status status;

  sim_fpu_32to (&wop, GR[reg2]);
  TRACE_FP_INPUT_FPU1 (&wop);

  status = sim_fpu_sqrt (&ans, &wop);
  status |= sim_fpu_round_32 (&ans, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);

  update_fpsr (sd, status, FPSR_XEV | FPSR_XEI, 0);

  sim_fpu_to32 (&GR[reg3], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// SUBF.D
rrrr,0111111,RRRR,0 + wwww,010001110010:F_I:::subf.d
*v850e2v3
*v850e3v5
"subf.d r<reg1e>, r<reg2e>, r<reg3e>"
{
  sim_fpu ans, wop1, wop2;
  sim_fpu_status status;

  sim_fpu_232to (&wop1, GR[reg1e+1], GR[reg1e]);
  sim_fpu_232to (&wop2, GR[reg2e+1], GR[reg2e]);
  TRACE_FP_INPUT_FPU2 (&wop1, &wop2);

  status = sim_fpu_sub (&ans, &wop2, &wop1);
  status |= sim_fpu_round_64 (&ans, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);

  update_fpsr (sd, status, FPSR_XEV | FPSR_XEI | FPSR_XEO | FPSR_XEU, 1);

  sim_fpu_to232 (&GR[reg3e+1], &GR[reg3e], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// SUBF.S
rrrrr,111111,RRRRR + wwwww,10001100010:F_I:::subf.s
*v850e2v3
*v850e3v5
"subf.s r<reg1>, r<reg2>, r<reg3>"
{
  sim_fpu ans, wop1, wop2;
  sim_fpu_status status;

  sim_fpu_32to (&wop1, GR[reg1]);
  sim_fpu_32to (&wop2, GR[reg2]);
  TRACE_FP_INPUT_FPU2 (&wop1, &wop2);

  status = sim_fpu_sub (&ans, &wop2, &wop1);
  status |= sim_fpu_round_32 (&ans, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);

  update_fpsr (sd, status, FPSR_XEV | FPSR_XEI | FPSR_XEO | FPSR_XEU, 0);

  sim_fpu_to32 (&GR[reg3], &ans);
  TRACE_FP_RESULT_FPU1 (&ans);
}

// TRFSR
0000011111100000 + 000001000000,bbb,0:F_I:::trfsr
*v850e2v3
*v850e3v5
"trfsr":(bbb == 0)
"trfsr <bbb>"
{
  TRACE_ALU_INPUT1 (GET_FPCC());

  if (TEST_FPCC (bbb))
    PSW |= PSW_Z;
  else 
    PSW &= ~PSW_Z;  

  TRACE_ALU_RESULT1 (PSW);
}

// TRNCF.DL
rrrr,011111100001 + wwww,010001010100:F_I:::trncf_dl
*v850e2v3
*v850e3v5
"trncf.dl r<reg2e>, r<reg3e>"
{
  signed64 ans;
  sim_fpu wop;
  sim_fpu_status status;

  sim_fpu_232to (&wop, GR[reg2e+1], GR[reg2e]);
  TRACE_FP_INPUT_FPU1 (&wop);

  status = sim_fpu_to64i (&ans, &wop, sim_fpu_round_zero);

  check_cvt_fi(sd, status, 1);

  GR[reg3e] = ans;
  GR[reg3e+1] = ans>>32L;
  TRACE_FP_RESULT_WORD2 (GR[reg3e], GR[reg3e+1]);
}

// TRNCF.DUL
rrrr,011111110001 + wwww,010001010100:F_I:::trncf_dul
*v850e2v3
*v850e3v5
"trncf.dul r<reg2e>, r<reg3e>"
{
  signed64 ans;
  sim_fpu wop;
  sim_fpu_status status;

  sim_fpu_232to (&wop, GR[reg2e+1], GR[reg2e]);
  TRACE_FP_INPUT_FPU1 (&wop);

  status = sim_fpu_to64u (&ans, &wop, sim_fpu_round_zero);

  check_cvt_fi(sd, status, 1);

  GR[reg3e] = ans;
  GR[reg3e+1] = ans>>32L;
  TRACE_FP_RESULT_WORD2 (GR[reg3e], GR[reg3e+1]);
}

// TRNCF.DW
rrrr,011111100001 + wwwww,10001010000:F_I:::trncf_dw
*v850e2v3
*v850e3v5
"trncf.dw r<reg2e>, r<reg3>"
{
  uint32 ans;
  sim_fpu wop;
  sim_fpu_status status;

  sim_fpu_232to (&wop, GR[reg2e+1], GR[reg2e]);
  TRACE_FP_INPUT_FPU1 (&wop);

  status = sim_fpu_to32i (&ans, &wop, sim_fpu_round_zero);

  check_cvt_fi(sd, status, 1);

  GR[reg3] = ans;
  TRACE_FP_RESULT_WORD1 (ans);
}

// TRNCF.DUW
rrrr,011111110001 + wwwww,10001010000:F_I:::trncf_duw
*v850e2v3
*v850e3v5
"trncf.duw r<reg2e>, r<reg3>"
{
  uint32 ans;
  sim_fpu wop;
  sim_fpu_status status;

  sim_fpu_232to (&wop, GR[reg2e+1], GR[reg2e]);
  TRACE_FP_INPUT_FPU1 (&wop);

  status = sim_fpu_to32u (&ans, &wop, sim_fpu_round_zero);

  check_cvt_fi(sd, status, 1);

  GR[reg3] = ans;
  TRACE_FP_RESULT_WORD1 (ans);
}

// TRNCF.SL
rrrrr,11111100001 + wwww,010001000100:F_I:::trncf_sl
*v850e2v3
*v850e3v5
"trncf.sl r<reg2>, r<reg3e>"
{
  signed64 ans;
  sim_fpu wop;
  sim_fpu_status status;

  sim_fpu_32to (&wop, GR[reg2]);
  TRACE_FP_INPUT_FPU1 (&wop);

  status = sim_fpu_to64i (&ans, &wop, sim_fpu_round_zero);

  GR[reg3e] = ans;
  GR[reg3e+1] = ans >> 32L;
  TRACE_FP_RESULT_WORD2 (GR[reg3e], GR[reg3e+1]);
}

// TRNCF.SUL
rrrrr,11111110001 + wwww,010001000100:F_I:::trncf_sul
*v850e2v3
*v850e3v5
"trncf.sul r<reg2>, r<reg3e>"
{
  signed64 ans;
  sim_fpu wop;
  sim_fpu_status status;

  sim_fpu_32to (&wop, GR[reg2]);
  TRACE_FP_INPUT_FPU1 (&wop);

  status = sim_fpu_to64u (&ans, &wop, sim_fpu_round_zero);

  GR[reg3e] = ans;
  GR[reg3e+1] = ans >> 32L;
  TRACE_FP_RESULT_WORD2 (GR[reg3e], GR[reg3e+1]);
}

// TRNCF.SW
rrrrr,11111100001 + wwwww,10001000000:F_I:::trncf_sw
*v850e2v3
*v850e3v5
"trncf.sw r<reg2>, r<reg3>"
{
  uint32 ans;
  sim_fpu wop;
  sim_fpu_status status;

  sim_fpu_32to (&wop, GR[reg2]);
  TRACE_FP_INPUT_FPU1 (&wop);

  status = sim_fpu_to32i (&ans, &wop, sim_fpu_round_zero);

  check_cvt_fi(sd, status, 0);

  GR[reg3] = ans;
  TRACE_FP_RESULT_WORD1 (ans);
}


// TRNCF.SUW
rrrrr,11111110001 + wwwww,10001000000:F_I:::trncf_suw
*v850e2v3
*v850e3v5
"trncf.suw r<reg2>, r<reg3>"
{
  uint32 ans;
  sim_fpu wop;
  sim_fpu_status status;

  sim_fpu_32to (&wop, GR[reg2]);
  TRACE_FP_INPUT_FPU1 (&wop);

  status = sim_fpu_to32u (&ans, &wop, sim_fpu_round_zero);

  check_cvt_fi(sd, status, 0);

  GR[reg3] = ans;
  TRACE_FP_RESULT_WORD1 (ans);
}


// ROTL
rrrrr,111111,iiiii+wwwww,00011000100:VII:::rotl_imm
*v850e3v5
"rotl imm5, r<reg2>, r<reg3>"
{
  TRACE_ALU_INPUT1 (GR[reg2]);
  v850_rotl (sd, imm5, GR[reg2], & GR[reg3]);
  TRACE_ALU_RESULT1 (GR[reg3]);
}

rrrrr,111111,RRRRR+wwwww,00011000110:VII:::rotl
*v850e3v5
"rotl r<reg1>, r<reg2>, r<reg3>"
{
  TRACE_ALU_INPUT2 (GR[reg1], GR[reg2]);
  v850_rotl (sd, GR[reg1], GR[reg2], & GR[reg3]);
  TRACE_ALU_RESULT1 (GR[reg3]);
}

// BINS
rrrrr,111111,RRRRR+bbbb,B,0001001,BBB,0:IX:::bins_top
*v850e3v5
"bins r<reg1>, <bit13> + 16, <bit4> - <bit13> + 17, r<reg2>"
{
  TRACE_ALU_INPUT1 (GR[reg1]);
  v850_bins (sd, GR[reg1], bit13 + 16, bit4 + 16, & GR[reg2]);
  TRACE_ALU_RESULT1 (GR[reg2]);
}

rrrrr,111111,RRRRR+bbbb,B,0001011,BBB,0:IX:::bins_middle
*v850e3v5
"bins r<reg1>, <bit13>, <bit4> - <bit13> + 17, r<reg2>"
{
  TRACE_ALU_INPUT1 (GR[reg1]);
  v850_bins (sd, GR[reg1], bit13, bit4 + 16, & GR[reg2]);
  TRACE_ALU_RESULT1 (GR[reg2]);
}

rrrrr,111111,RRRRR+bbbb,B,0001101,BBB,0:IX:::bins_bottom
*v850e3v5
"bins r<reg1>, <bit13>, <bit4> - <bit13> + 1, r<reg2>"
{
  TRACE_ALU_INPUT1 (GR[reg1]);
  v850_bins (sd, GR[reg1], bit13, bit4, & GR[reg2]);
  TRACE_ALU_RESULT1 (GR[reg2]);
}
@


1.13
log
@	* simops.c (v850_rotl): New function.
	(v850_bins): New function.
	* simops.h: Add prototypes fir v850_rotl and v850_bins.
	* v850-dc: Add entries for V850e3v5.
	* v850.igen: Add support for v850e3v5.
	(ld.dw, st.dw, rotl, bins): New patterns.
@
text
@d937 3
a939 2
regID,111111,RRRRR + 0000000000100000:IX:::ldsr
"ldsr r<reg1>, s<regID>"
d944 2
a945 1
   if ((idecode_issue == idecode_v850e2_issue
@


1.12
log
@	* interp.c (sim_open): Add support for bfd_arch_v850_rh850
	architecture type.  Add support for bfd_mach_v850e2 and
	bfd_mach_v850e2v3 machine numbers.
        * v850.igen (dbtrap): Add support for SIM_OPEN_DEBUG.
        (cmpf.d): Correct order of operands.
        (cmpf.s): Likewise.
        (trncf.dul): New pattern.
        (trncf.duw): New pattern.
        (trncf.sul): New pattern.
        (trncf.suw): New pattern.
        * v850-dc: Correct bitfield selection for TRNCF.SW and CVTF.SW.
@
text
@d22 2
d66 1
d107 1
d192 1
d210 1
d238 1
d269 1
d288 1
d345 1
d359 1
d375 1
d389 1
d432 1
d468 1
d528 1
d541 1
d554 1
d565 1
d589 1
d623 1
d649 1
d674 1
d704 1
d728 1
d763 1
d773 10
d794 1
d816 1
d835 1
d851 1
d868 1
d877 13
d895 1
d903 1
d917 1
d925 1
d944 1
d1099 1
d1173 1
d1241 1
d1278 1
d1289 1
d1326 1
d1337 1
d1375 1
d1407 1
d1435 1
d1446 1
d1457 1
d1468 1
d1516 1
d1531 1
d1555 1
d1575 1
d1607 1
d1622 1
d1672 1
d1720 1
d1768 1
d1816 1
d1828 1
d1859 1
d1950 1
d1974 1
d2023 1
d2039 1
d2055 1
d2063 11
d2082 1
d2161 1
d2178 1
d2192 1
d2226 1
d2252 1
d2266 1
d2287 1
d2316 1
d2357 1
d2377 1
d2396 1
d2418 1
d2440 1
d2471 1
d2499 1
d2524 1
d2549 1
d2572 1
d2592 1
d2614 1
d2636 1
d2658 1
d2677 1
d2700 1
d2722 1
d2741 1
d2760 1
d2782 1
d2804 1
d2829 1
d2867 1
d2905 1
d2943 1
d2981 1
d3007 1
d3029 1
d3051 1
d3071 1
d3091 1
d3118 1
d3146 1
d3167 1
d3188 1
d3212 1
d3236 1
d3257 1
d3278 1
d3300 1
d3322 1
d3339 1
d3361 1
d3383 1
d3404 1
d3425 1
d3445 1
d3465 1
d3487 1
d3504 48
@


1.11
log
@	* v850.igen (W,WWWW): Correct computation of register number.
	(JR32): Remove unnecessary comma.
	(cmovf.s): Register 0 is an invalid source register.
	(maddf.s): Remove bogus intermediary rounding.
	(nmaddf.s): Likewise.
	(trncf.sl): Remove bogus initial rounding.
	(trncf.dw): Likewise.
	(trncf.sl): Likewise.
	(trncf.sw): Likewise.
@
text
@d2182 13
a2194 6
  DBPC = cia + 2;
  DBPSW = PSW;
  PSW = PSW | (PSW_NP | PSW_EP | PSW_ID);
  PC = 0x00000060;
  nia = 0x00000060;
  TRACE_BRANCH0 ();
d2384 2
a2385 2
"cmpf.d %s<FFFF>, r<reg1e>, r<reg2e>":(bbb == 0)
"cmpf.d %s<FFFF>, r<reg1e>, r<reg2e>, <bbb>"
d2393 1
a2393 1
  TRACE_FP_INPUT_FPU2 (&wop1, &wop2);
d2395 1
a2395 1
  result = v850_float_compare(sd, FFFF, wop1, wop2, 1);
d2408 2
a2409 2
"cmpf.s %s<FFFF>, r<reg1>, r<reg2>":(bbb == 0)
"cmpf.s %s<FFFF>, r<reg1>, r<reg2>, <bbb>"
d2417 1
a2417 1
  TRACE_FP_INPUT_FPU2 (&wop1, &wop2);
d2419 1
a2419 1
  result = v850_float_compare(sd, FFFF, wop1, wop2, 0);
d3207 21
d3248 20
d3287 19
d3325 21
@


1.10
log
@Commit gdb and sim support for v850e2 and v850e2v3 on behalf of
Rathish C <Rathish.C@@kpitcummins.com>.
@
text
@d28 1
a28 1
:cache:::unsigned:reg4:W,WWWW:((W << 4) + WWWW)
d776 1
a776 1
00000010111,00000 + iiiiiiiiiiiiiiii + IIIIIIIIIIIIIIII:VI:::jr32
d2348 1
a2348 1
rrrrr,111111,RRRRR + wwwww!0,1000000,bbb,0:F_I:::cmovf_s
a2678 1
  status |= sim_fpu_round_64 (&ans, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);
a2955 1
  status |= sim_fpu_round_64 (&ans, FPSR_GET_ROUND(), sim_fpu_denorm_underflow_inexact);
d3191 1
a3191 2
  status = sim_fpu_round_64 (&wop, sim_fpu_round_zero, sim_fpu_denorm_zero);
  status |= sim_fpu_to64i (&ans, &wop, sim_fpu_round_zero);
d3212 1
a3212 2
  status = sim_fpu_round_32 (&wop, sim_fpu_round_zero, sim_fpu_denorm_zero);
  status |= sim_fpu_to32i (&ans, &wop, sim_fpu_round_zero);
d3232 1
a3232 2
  status = sim_fpu_round_64 (&wop, sim_fpu_round_zero, sim_fpu_denorm_zero);
  status |= sim_fpu_to64i (&ans, &wop, sim_fpu_round_zero);
d3251 1
a3251 2
  status = sim_fpu_round_32 (&wop, sim_fpu_round_zero, sim_fpu_denorm_zero);
  status |= sim_fpu_to32i (&ans, &wop, sim_fpu_round_zero);
a3257 1

@


1.9
log
@* simops.c (OP_1C007E0): Compensate for 64 bit hosts.
(OP_18007E0): Likewise.
(OP_2C007E0): Likewise.
(OP_28007E0): Likewise.
* v850.igen (divh): Likewise.
@
text
@d9 1
d18 4
d28 6
d43 1
d45 2
d63 1
d76 1
a76 2
// Add

d100 14
d184 13
d203 2
d224 2
d230 2
d254 2
d260 2
d275 49
d334 2
d342 1
d347 2
d356 2
d362 2
d375 2
d385 2
d417 2
d447 1
d452 2
d511 2
d523 2
d535 2
d543 46
d598 70
d677 21
d702 2
d735 10
d755 9
d775 11
d794 10
d810 10
d826 10
d839 2
d846 10
d859 2
d866 11
d882 1
d885 141
a1025 2
  if (&PSW == &SR[regID])
    PSW = (GR[reg1] & (CPU)->psw_mask);
d1027 113
a1139 1
    SR[regID] = GR[reg1];
d1141 15
a1155 1
  TRACE_ALU_RESULT (SR[regID]);
a1168 1

d1178 2
d1214 2
d1224 2
d1260 2
d1270 2
d1307 2
d1338 2
d1365 2
d1375 2
d1385 2
d1395 2
d1441 9
d1456 2
a1464 1

d1478 10
d1497 10
d1527 228
d1774 2
d1864 2
d1887 2
d1907 2
d1935 9
d1950 9
d1965 10
d1979 60
a2038 4
  TRACE_ALU_INPUT1 (SR[regID]);
  GR[reg2] = SR[regID];
  TRACE_ALU_RESULT (GR[reg2]);
}
d2058 2
d2074 2
d2087 2
d2120 2
d2145 2
d2158 2
d2178 2
d2199 2
d2207 1058
@


1.8
log
@Index: ChangeLog

	* configure.ac (v850): V850 now has a testsuite.
	* configure (v850): Likewise.

Index: testsuite/ChangeLog

	* sim/v850/: New directory.
	* sim/v850/allinsns.exp: New.
	* sim/v850/bsh.cgs: New.
	* sim/v850/div.cgs: New.
	* sim/v850/divh.cgs: New.
	* sim/v850/divh_3.cgs: New.
	* sim/v850/divhu.cgs: New.
	* sim/v850/divu.cgs: New.
	* sim/v850/sar.cgs: New.
	* sim/v850/satadd.cgs: New.
	* sim/v850/satsub.cgs: New.
	* sim/v850/satsubi.cgs: New.
	* sim/v850/satsubr.cgs: New.
	* sim/v850/shl.cgs: New.
	* sim/v850/shr.cgs: New.
	* sim/v850/testutils.cgs: New.
	* sim/v850/testutils.inc: New.

Index: v850/ChangeLog

	* simops.c (OP_C0): Correct saturation logic.
	(OP_220): Likewise.
	(OP_A0): Likewise.
	(OP_660): Likewise.
	(OP_80): Likewise.

	* simops.c (OP_2A0): If the shift count is zero, clear the
	carry.
	(OP_A007E0): Likewise.
	(OP_2C0): Likewise.
	(OP_C007E0): Likewise.
	(OP_280): Likewise.
	(OP_8007E0): Likewise.

	* simops.c (OP_2C207E0): Correct PSW flags for special divu
	conditions.
	(OP_2C007E0): Likewise, for div.
	(OP_28207E0): Likewise, for divhu.
	(OP_28007E0): Likewise, for divh.  Also, sign-extend the correct
	operand.
	* v850.igen (divh): Likewise, for 2-op divh.

	* v850.igen (bsh): Fix carry logic.
@
text
@d359 1
a359 1
  if (op0 == 0xffffffff && op1 == 0x80000000)
d371 1
a371 1
      result = op1 / op0;
@


1.7
log
@Add support for v850e1 instructions
@
text
@d174 1
a174 1
  if (value == 0) PSW |= PSW_Z;
d176 1
a176 1
  if (((value & 0xff) == 0) || (value & 0x00ff) == 0) PSW |= PSW_CY;
d361 3
a363 2
      result = 0x80000000;
      ov = 1;
d365 1
a365 1
  else if (op0 != 0)
d367 1
a367 2
      result = op1 / op0;
      ov = 0;
d371 11
a381 2
      result = 0x0;
      ov = 1;
a382 9
  
  /* Compute the condition codes.  */
  z = (result == 0);
  s = (result & 0x80000000);
  
  /* Store the result and condition codes.  */
  State.regs[OP[1]] = result;
  PSW &= ~(PSW_Z | PSW_S | PSW_OV);
  PSW |= ((z ? PSW_Z : 0) | (s ? PSW_S : 0) | (ov ? PSW_OV : 0));
@


1.6
log
@* simops.c (OP_40): Delete.  Move code to...
* v850-igen.c (): ...Here. Sign extend the first operand.
* simops.h (OP_40): Remove prototype.
@
text
@d15 2
d161 1
d184 1
d210 1
d233 1
d243 1
d254 1
d265 1
d303 1
d335 1
d392 1
d402 1
d412 1
d440 1
d515 1
d523 1
d564 1
d598 1
d606 1
d640 1
d648 1
d683 1
d712 1
d737 1
d745 1
d753 1
d761 1
d811 1
d880 1
d968 1
d989 1
d1072 1
d1086 1
d1097 1
d1128 1
d1151 1
d1162 1
d1173 2
d1179 12
d1195 10
@


1.5
log
@Remove v850ea references
@
text
@d335 42
a376 1
  COMPAT_1 (OP_40 ());
@


1.5.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a14 2
:option:::multi-sim:true
:model:::v850e1:v850e1:
a158 1
*v850e1
a180 1
*v850e1
a205 1
*v850e1
a227 1
*v850e1
a236 1
*v850e1
a246 1
*v850e1
a256 1
*v850e1
a293 1
*v850e1
a324 1
*v850e1
d335 1
a335 42
  unsigned32 ov, s, z;
  signed long int op0, op1, result;

  trace_input ("divh", OP_REG_REG, 0);

  PC = cia;
  OP[0] = instruction_0 & 0x1f;
  OP[1] = (instruction_0 >> 11) & 0x1f;

  /* Compute the result.  */
  op0 = EXTEND16 (State.regs[OP[0]]);
  op1 = State.regs[OP[1]];
  
  if (op0 == 0xffffffff && op1 == 0x80000000)
    {
      result = 0x80000000;
      ov = 1;
    }
  else if (op0 != 0)
    {
      result = op1 / op0;
      ov = 0;
    }
  else
    {
      result = 0x0;
      ov = 1;
    }
  
  /* Compute the condition codes.  */
  z = (result == 0);
  s = (result & 0x80000000);
  
  /* Store the result and condition codes.  */
  State.regs[OP[1]] = result;
  PSW &= ~(PSW_Z | PSW_S | PSW_OV);
  PSW |= ((z ? PSW_Z : 0) | (s ? PSW_S : 0) | (ov ? PSW_OV : 0));

  trace_output (OP_REG_REG);

  PC += 2;
  nia = PC;
a339 1
*v850e1
a348 1
*v850e1
a357 1
*v850e1
a384 1
*v850e1
a458 1
*v850e1
a465 1
*v850e1
a505 1
*v850e1
a538 1
*v850e1
a545 1
*v850e1
a578 1
*v850e1
a585 1
*v850e1
a619 1
*v850e1
a647 1
*v850e1
a671 1
*v850e1
a678 1
*v850e1
a685 1
*v850e1
a692 1
*v850e1
a741 1
*v850e1
a809 1
*v850e1
a896 1
*v850e1
a916 1
*v850e1
a998 1
*v850e1
a1011 1
*v850e1
a1021 1
*v850e1
a1051 1
*v850e1
a1073 1
*v850e1
a1083 1
*v850e1
a1093 2
*v850
*v850e
a1097 12
11111,000010,00000:I:::dbtrap
*v850e1
"dbtrap"
{
  DBPC = cia + 2;
  DBPSW = PSW;
  PSW = PSW | (PSW_NP | PSW_EP | PSW_ID);
  PC = 0x00000060;
  nia = 0x00000060;
  TRACE_BRANCH0 ();
}

a1101 10
}

// Return from debug trap: 0x146007e0
0000011111100000 + 0000000101000110:X:::dbret
*v850e1
"dbret"
{
  nia = DBPC;
  PSW = DBPSW;
  TRACE_BRANCH1 (PSW);
@


1.5.2.1
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d335 1
a335 42
  unsigned32 ov, s, z;
  signed long int op0, op1, result;

  trace_input ("divh", OP_REG_REG, 0);

  PC = cia;
  OP[0] = instruction_0 & 0x1f;
  OP[1] = (instruction_0 >> 11) & 0x1f;

  /* Compute the result.  */
  op0 = EXTEND16 (State.regs[OP[0]]);
  op1 = State.regs[OP[1]];
  
  if (op0 == 0xffffffff && op1 == 0x80000000)
    {
      result = 0x80000000;
      ov = 1;
    }
  else if (op0 != 0)
    {
      result = op1 / op0;
      ov = 0;
    }
  else
    {
      result = 0x0;
      ov = 1;
    }
  
  /* Compute the condition codes.  */
  z = (result == 0);
  s = (result & 0x80000000);
  
  /* Store the result and condition codes.  */
  State.regs[OP[1]] = result;
  PSW &= ~(PSW_Z | PSW_S | PSW_OV);
  PSW |= ((z ? PSW_Z : 0) | (s ? PSW_S : 0) | (ov ? PSW_OV : 0));

  trace_output (OP_REG_REG);

  PC += 2;
  nia = PC;
@


1.5.2.2
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a14 2
:option:::multi-sim:true
:model:::v850e1:v850e1:
a158 1
*v850e1
a180 1
*v850e1
a205 1
*v850e1
a227 1
*v850e1
a236 1
*v850e1
a246 1
*v850e1
a256 1
*v850e1
a293 1
*v850e1
a324 1
*v850e1
a380 1
*v850e1
a389 1
*v850e1
a398 1
*v850e1
a425 1
*v850e1
a499 1
*v850e1
a506 1
*v850e1
a546 1
*v850e1
a579 1
*v850e1
a586 1
*v850e1
a619 1
*v850e1
a626 1
*v850e1
a660 1
*v850e1
a688 1
*v850e1
a712 1
*v850e1
a719 1
*v850e1
a726 1
*v850e1
a733 1
*v850e1
a782 1
*v850e1
a850 1
*v850e1
a937 1
*v850e1
a957 1
*v850e1
a1039 1
*v850e1
a1052 1
*v850e1
a1062 1
*v850e1
a1092 1
*v850e1
a1114 1
*v850e1
a1124 1
*v850e1
a1134 2
*v850
*v850e
a1138 12
11111,000010,00000:I:::dbtrap
*v850e1
"dbtrap"
{
  DBPC = cia + 2;
  DBPSW = PSW;
  PSW = PSW | (PSW_NP | PSW_EP | PSW_ID);
  PC = 0x00000060;
  nia = 0x00000060;
  TRACE_BRANCH0 ();
}

a1142 10
}

// Return from debug trap: 0x146007e0
0000011111100000 + 0000000101000110:X:::dbret
*v850e1
"dbret"
{
  nia = DBPC;
  PSW = DBPSW;
  TRACE_BRANCH1 (PSW);
@


1.5.20.1
log
@Merge with mainline.
@
text
@d335 1
a335 42
  unsigned32 ov, s, z;
  signed long int op0, op1, result;

  trace_input ("divh", OP_REG_REG, 0);

  PC = cia;
  OP[0] = instruction_0 & 0x1f;
  OP[1] = (instruction_0 >> 11) & 0x1f;

  /* Compute the result.  */
  op0 = EXTEND16 (State.regs[OP[0]]);
  op1 = State.regs[OP[1]];
  
  if (op0 == 0xffffffff && op1 == 0x80000000)
    {
      result = 0x80000000;
      ov = 1;
    }
  else if (op0 != 0)
    {
      result = op1 / op0;
      ov = 0;
    }
  else
    {
      result = 0x0;
      ov = 1;
    }
  
  /* Compute the condition codes.  */
  z = (result == 0);
  s = (result & 0x80000000);
  
  /* Store the result and condition codes.  */
  State.regs[OP[1]] = result;
  PSW &= ~(PSW_Z | PSW_S | PSW_OV);
  PSW |= ((z ? PSW_Z : 0) | (s ? PSW_S : 0) | (ov ? PSW_OV : 0));

  trace_output (OP_REG_REG);

  PC += 2;
  nia = PC;
@


1.4
log
@Remove illegal instruciton pattern, since it is the same as the breakpoint
pattern.
@
text
@a15 5
:option:::multi-sim:true
:model:::v850ea:v850ea:



a158 1
*v850ea
a180 1
*v850ea
a205 1
*v850ea
a227 1
*v850ea
a236 1
*v850ea
a246 1
*v850ea
a256 1
*v850ea
a293 1
*v850ea
a384 1
*v850ea
a458 1
*v850ea
a465 1
*v850ea
a505 1
*v850ea
a538 1
*v850ea
a545 1
*v850ea
a578 1
*v850ea
a585 1
*v850ea
a619 1
*v850ea
a647 1
*v850ea
a671 1
*v850ea
a678 1
*v850ea
a685 1
*v850ea
a692 1
*v850ea
a741 1
*v850ea
a809 1
*v850ea
a896 1
*v850ea
a916 1
*v850ea
a934 1

a953 2


a972 2


a981 2


a988 2


a995 2


a998 1
*v850ea
a1008 1

a1011 1
*v850ea
a1021 1
*v850ea
a1028 2


a1035 2


a1042 2


a1051 1
*v850ea
a1056 2


a1063 2


a1070 2


a1073 1
*v850ea
a1083 1
*v850ea
a1090 1

a1097 1

a1102 253

// DIVHN
rrrrr,111111,RRRRR + wwwww,01010,iiii,00:XI:::divhn
*v850ea
"divhn <imm5>, r<reg1>, r<reg2>, r<reg3>"
{
  signed32 quotient;
  signed32 remainder;
  signed32 divide_by;
  signed32 divide_this;
  boolean overflow = false;
  SAVE_2;
      
  trace_input ("divhn", OP_IMM_REG_REG_REG, 0);

  divide_by   = EXTEND16 (State.regs[ reg1 ]);
  divide_this = State.regs[ reg2 ];
  
  divn (imm5, divide_by, divide_this, & quotient, & remainder, & overflow);
  
  State.regs[ reg2 ] = quotient;
  State.regs[ reg3 ] = remainder;
  
  /* Set condition codes.  */
  PSW &= ~(PSW_Z | PSW_S | PSW_OV);
  
  if (overflow)      PSW |= PSW_OV;
  if (quotient == 0) PSW |= PSW_Z;
  if (quotient <  0) PSW |= PSW_S;
  
  trace_output (OP_IMM_REG_REG_REG);
}



// DIVHUN
rrrrr,111111,RRRRR + wwwww,01010,iiii,10:XI:::divhun
*v850ea
"divhun <imm5>, r<reg1>, r<reg2>, r<reg3>"
{
  signed32 quotient;
  signed32 remainder;
  signed32 divide_by;
  signed32 divide_this;
  boolean overflow = false;
  SAVE_2;
      
  trace_input ("divhun", OP_IMM_REG_REG_REG, 0);
  
  divide_by   = State.regs[ reg1 ] & 0xffff;
  divide_this = State.regs[ reg2 ];
  
  divun (imm5, divide_by, divide_this, & quotient, & remainder, & overflow);
  
  State.regs[ reg2 ] = quotient;
  State.regs[ reg3 ] = remainder;
  
  /* Set condition codes.  */
  PSW &= ~(PSW_Z | PSW_S | PSW_OV);
  
  if (overflow)      PSW |= PSW_OV;
  if (quotient == 0) PSW |= PSW_Z;
  if (quotient & 0x80000000) PSW |= PSW_S;

  trace_output (OP_IMM_REG_REG_REG);
}



// DIVN
rrrrr,111111,RRRRR + wwwww,01011,iiii,00:XI:::divn
*v850ea
"divn <imm5>, r<reg1>, r<reg2>, r<reg3>"
{
  signed32 quotient;
  signed32 remainder;
  signed32 divide_by;
  signed32 divide_this;
  boolean overflow = false;
  SAVE_2;
      
  trace_input ("divn", OP_IMM_REG_REG_REG, 0);

  divide_by   = State.regs[ reg1 ];
  divide_this = State.regs[ reg2 ];

  divn (imm5, divide_by, divide_this, & quotient, & remainder, & overflow);
      
  State.regs[ reg2 ] = quotient;
  State.regs[ reg3 ] = remainder;
      
  /* Set condition codes.  */
  PSW &= ~(PSW_Z | PSW_S | PSW_OV);
  
  if (overflow)      PSW |= PSW_OV;
  if (quotient == 0) PSW |= PSW_Z;
  if (quotient <  0) PSW |= PSW_S;
  
  trace_output (OP_IMM_REG_REG_REG);
}



// DIVUN
rrrrr,111111,RRRRR + wwwww,01011,iiii,10:XI:::divun
*v850ea
"divun <imm5>, r<reg1>, r<reg2>, r<reg3>"
{
  signed32 quotient;
  signed32 remainder;
  signed32 divide_by;
  signed32 divide_this;
  boolean overflow = false;
  SAVE_2;

  trace_input ("divun", OP_IMM_REG_REG_REG, 0);

  divide_by   = State.regs[ reg1 ];
  divide_this = State.regs[ reg2 ];

  divun (imm5, divide_by, divide_this, & quotient, & remainder, & overflow);
      
  State.regs[ reg2 ] = quotient;
  State.regs[ reg3 ] = remainder;
      
  /* Set condition codes.  */
  PSW &= ~(PSW_Z | PSW_S | PSW_OV);
      
  if (overflow)      PSW |= PSW_OV;
  if (quotient == 0) PSW |= PSW_Z;
  if (quotient & 0x80000000) PSW |= PSW_S;

  trace_output (OP_IMM_REG_REG_REG);
}



// SDIVHN
rrrrr,111111,RRRRR + wwwww,00110,iiii,00:XI:::sdivhn
*v850ea
"sdivhn <imm5>, r<reg1>, r<reg2>, r<reg3>"
{
  COMPAT_2 (OP_18007E0 ());
}



// SDIVHUN
rrrrr,111111,RRRRR + wwwww,00110,iiii,10:XI:::sdivhun
*v850ea
"sdivhun <imm5>, r<reg1>, r<reg2>, r<reg3>"
{
  COMPAT_2 (OP_18207E0 ());
}



// SDIVN
rrrrr,111111,RRRRR + wwwww,00111,iiii,00:XI:::sdivn
*v850ea
"sdivn <imm5>, r<reg1>, r<reg2>, r<reg3>"
{
  COMPAT_2 (OP_1C007E0 ());
}



// SDIVUN
rrrrr,111111,RRRRR + wwwww,00111,iiii,10:XI:::sdivun
*v850ea
"sdivun <imm5>, r<reg1>, r<reg2>, r<reg3>"
{
  COMPAT_2 (OP_1C207E0 ());
}



// PUSHML
000001111110,LLLL + LLLLLLLLLLLL,S,001:XIV:::pushml
*v850ea
"pushml <list18>"
{
  int i;
  SAVE_2;
  
  trace_input ("pushml", OP_PUSHPOP3, 0);
  
  /* Store the registers with lower number registers being placed at
     higher addresses.  */

  for (i = 0; i < 15; i++)
    if ((OP[3] & (1 << type3_regs[ i ])))
      {
	SP -= 4;
	store_mem (SP & ~ 3, 4, State.regs[ i + 1 ]);
      }
  
  if (OP[3] & (1 << 3))
    {
      SP -= 4;
      
      store_mem (SP & ~ 3, 4, PSW);
    }
  
  if (OP[3] & (1 << 19))
    {
      SP -= 8;
      
      if ((PSW & PSW_NP) && ((PSW & PSW_EP) == 0))
	{
	  store_mem ((SP + 4) & ~ 3, 4, FEPC);
	  store_mem ( SP      & ~ 3, 4, FEPSW);
	}
      else
	{
	  store_mem ((SP + 4) & ~ 3, 4, EIPC);
	  store_mem ( SP      & ~ 3, 4, EIPSW);
	}
    }
  
  trace_output (OP_PUSHPOP2);
}



// PUSHHML
000001111110,LLLL + LLLLLLLLLLLL,S,011:XIV:::pushmh
*v850ea
"pushhml <list18>"
{
  COMPAT_2 (OP_307E0 ());
}



// POPML
000001111111,LLLL + LLLLLLLLLLLL,S,001:XIV:::popml
*v850ea
"popml <list18>"
{
  COMPAT_2 (OP_107F0 ());
}



// POPMH
000001111111,LLLL + LLLLLLLLLLLL,S,011:XIV:::popmh
*v850ea
"popmh <list18>"
{
  COMPAT_2 (OP_307F0 ());
}

@


1.4.16.1
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d16 5
d164 1
d187 1
d213 1
d236 1
d246 1
d257 1
d268 1
d306 1
d398 1
d473 1
d481 1
d522 1
d556 1
d564 1
d598 1
d606 1
d641 1
d670 1
d695 1
d703 1
d711 1
d719 1
d769 1
d838 1
d926 1
d947 1
d966 1
d986 2
d1007 2
d1018 2
d1027 2
d1036 2
d1041 1
d1052 1
d1056 1
d1067 1
d1075 2
d1084 2
d1093 2
d1104 1
d1110 2
d1119 2
d1128 2
d1133 1
d1144 1
d1152 1
d1160 1
d1166 253
@


1.3
log
@* merge from internal tree

2000-04-14  Gary Thomas  <gthomas@@redhat.com>

	* v850.igen: Define 'br *' as illegal since this is the only
	way to provide a breakpoint on some v850 family processors.
@
text
@a1166 7
// True illegal instruction
00000,111111,00000 + 00000,11111,100000:X:::ilgop
{
  sim_engine_halt (SD, CPU, NULL, cia, sim_stopped, SIM_SIGTRAP);
}


@


1.2
log
@* more compatibility with v850 hardware
2000-03-24  Frank Ch. Eigler  <fche@@redhat.com>

	* v850.igen (ilgop): New insn pattern for four-byte breakpoints.
@
text
@d147 10
a156 4
  int cond = condition_met (cccc);
  if (cond)
    nia = cia + disp9;
  TRACE_BRANCH1 (cond);
d1167 5
@


1.1
log
@Initial revision
@
text
@d1155 7
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@

