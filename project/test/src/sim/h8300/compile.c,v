head	1.50;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.50
	gdb_7_6-2013-04-26-release:1.50
	gdb_7_6-branch:1.50.0.4
	gdb_7_6-2013-03-12-branchpoint:1.50
	gdb_7_5_1-2012-11-29-release:1.50
	gdb_7_5-2012-08-17-release:1.50
	gdb_7_5-branch:1.50.0.2
	gdb_7_5-2012-07-18-branchpoint:1.50
	gdb_7_4_1-2012-04-26-release:1.49
	gdb_7_4-2012-01-24-release:1.49
	gdb_7_4-branch:1.49.0.2
	gdb_7_4-2011-12-13-branchpoint:1.49
	gdb_7_3_1-2011-09-04-release:1.48
	gdb_7_3-2011-07-26-release:1.48
	gdb_7_3-branch:1.48.0.2
	gdb_7_3-2011-04-01-branchpoint:1.48
	gdb_7_2-2010-09-02-release:1.47
	gdb_7_2-branch:1.47.0.2
	gdb_7_2-2010-07-07-branchpoint:1.47
	gdb_7_1-2010-03-18-release:1.46
	gdb_7_1-branch:1.46.0.2
	gdb_7_1-2010-02-18-branchpoint:1.46
	gdb_7_0_1-2009-12-22-release:1.45
	gdb_7_0-2009-10-06-release:1.45
	gdb_7_0-branch:1.45.0.6
	gdb_7_0-2009-09-16-branchpoint:1.45
	arc-sim-20090309:1.44
	msnyder-checkpoint-072509-branch:1.45.0.4
	msnyder-checkpoint-072509-branchpoint:1.45
	arc-insight_6_8-branch:1.44.0.16
	arc-insight_6_8-branchpoint:1.44
	insight_6_8-branch:1.44.0.14
	insight_6_8-branchpoint:1.44
	reverse-20081226-branch:1.45.0.2
	reverse-20081226-branchpoint:1.45
	multiprocess-20081120-branch:1.44.0.12
	multiprocess-20081120-branchpoint:1.44
	reverse-20080930-branch:1.44.0.10
	reverse-20080930-branchpoint:1.44
	reverse-20080717-branch:1.44.0.8
	reverse-20080717-branchpoint:1.44
	msnyder-reverse-20080609-branch:1.44.0.6
	msnyder-reverse-20080609-branchpoint:1.44
	drow-reverse-20070409-branch:1.43.0.4
	drow-reverse-20070409-branchpoint:1.43
	gdb_6_8-2008-03-27-release:1.44
	gdb_6_8-branch:1.44.0.4
	gdb_6_8-2008-02-26-branchpoint:1.44
	gdb_6_7_1-2007-10-29-release:1.44
	gdb_6_7-2007-10-10-release:1.44
	gdb_6_7-branch:1.44.0.2
	gdb_6_7-2007-09-07-branchpoint:1.44
	insight_6_6-20070208-release:1.43
	gdb_6_6-2006-12-18-release:1.43
	gdb_6_6-branch:1.43.0.2
	gdb_6_6-2006-11-15-branchpoint:1.43
	insight_6_5-20061003-release:1.42
	gdb-csl-symbian-6_4_50_20060226-12:1.42
	gdb-csl-sourcerygxx-3_4_4-25:1.42
	nickrob-async-20060828-mergepoint:1.43
	gdb-csl-symbian-6_4_50_20060226-11:1.42
	gdb-csl-sourcerygxx-4_1-17:1.42
	gdb-csl-20060226-branch-local-2:1.42
	gdb-csl-sourcerygxx-4_1-14:1.42
	gdb-csl-sourcerygxx-4_1-13:1.42
	gdb-csl-sourcerygxx-4_1-12:1.42
	gdb-csl-sourcerygxx-3_4_4-21:1.42
	gdb_6_5-20060621-release:1.42
	gdb-csl-sourcerygxx-4_1-9:1.42
	gdb-csl-sourcerygxx-4_1-8:1.42
	gdb-csl-sourcerygxx-4_1-7:1.42
	gdb-csl-arm-2006q1-6:1.42
	gdb-csl-sourcerygxx-4_1-6:1.42
	gdb-csl-symbian-6_4_50_20060226-10:1.42
	gdb-csl-symbian-6_4_50_20060226-9:1.42
	gdb-csl-symbian-6_4_50_20060226-8:1.42
	gdb-csl-coldfire-4_1-11:1.42
	gdb-csl-sourcerygxx-3_4_4-19:1.42
	gdb-csl-coldfire-4_1-10:1.42
	gdb_6_5-branch:1.42.0.34
	gdb_6_5-2006-05-14-branchpoint:1.42
	gdb-csl-sourcerygxx-4_1-5:1.42
	nickrob-async-20060513-branch:1.42.0.32
	nickrob-async-20060513-branchpoint:1.42
	gdb-csl-sourcerygxx-4_1-4:1.42
	msnyder-reverse-20060502-branch:1.42.0.30
	msnyder-reverse-20060502-branchpoint:1.42
	gdb-csl-morpho-4_1-4:1.42
	gdb-csl-sourcerygxx-3_4_4-17:1.42
	readline_5_1-import-branch:1.42.0.28
	readline_5_1-import-branchpoint:1.42
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.42
	gdb-csl-symbian-20060226-branch:1.42.0.26
	gdb-csl-symbian-20060226-branchpoint:1.42
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.42
	msnyder-reverse-20060331-branch:1.42.0.24
	msnyder-reverse-20060331-branchpoint:1.42
	gdb-csl-available-20060303-branch:1.42.0.22
	gdb-csl-available-20060303-branchpoint:1.42
	gdb-csl-20060226-branch:1.42.0.20
	gdb-csl-20060226-branchpoint:1.42
	gdb_6_4-20051202-release:1.42
	msnyder-fork-checkpoint-branch:1.42.0.18
	msnyder-fork-checkpoint-branchpoint:1.42
	gdb-csl-gxxpro-6_3-branch:1.42.0.16
	gdb-csl-gxxpro-6_3-branchpoint:1.42
	gdb_6_4-branch:1.42.0.14
	gdb_6_4-2005-11-01-branchpoint:1.42
	gdb-csl-arm-20051020-branch:1.42.0.12
	gdb-csl-arm-20051020-branchpoint:1.42
	msnyder-tracepoint-checkpoint-branch:1.42.0.10
	msnyder-tracepoint-checkpoint-branchpoint:1.42
	gdb-csl-arm-20050325-2005-q1b:1.42
	gdb-csl-arm-20050325-2005-q1a:1.42
	csl-arm-20050325-branch:1.42.0.8
	csl-arm-20050325-branchpoint:1.42
	gdb_6_3-20041109-release:1.42
	gdb_6_3-branch:1.42.0.4
	gdb_6_3-20041019-branchpoint:1.42
	drow_intercu-merge-20040921:1.42
	drow_intercu-merge-20040915:1.42
	jimb-gdb_6_2-e500-branch:1.42.0.6
	jimb-gdb_6_2-e500-branchpoint:1.42
	gdb_6_2-20040730-release:1.42
	gdb_6_2-branch:1.42.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.42
	gdb_6_1_1-20040616-release:1.39
	gdb_6_1-2004-04-05-release:1.39
	drow_intercu-merge-20040402:1.39
	drow_intercu-merge-20040327:1.39
	ezannoni_pie-20040323-branch:1.39.0.12
	ezannoni_pie-20040323-branchpoint:1.39
	cagney_tramp-20040321-mergepoint:1.39
	cagney_tramp-20040309-branch:1.39.0.10
	cagney_tramp-20040309-branchpoint:1.39
	gdb_6_1-branch:1.39.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.39
	drow_intercu-20040221-branch:1.39.0.6
	drow_intercu-20040221-branchpoint:1.39
	cagney_bfdfile-20040213-branch:1.39.0.4
	cagney_bfdfile-20040213-branchpoint:1.39
	drow-cplus-merge-20040208:1.39
	carlton_dictionary-20040126-merge:1.39
	cagney_bigcore-20040122-branch:1.39.0.2
	cagney_bigcore-20040122-branchpoint:1.39
	drow-cplus-merge-20040113:1.39
	drow-cplus-merge-20031224:1.38
	drow-cplus-merge-20031220:1.38
	carlton_dictionary-20031215-merge:1.38
	drow-cplus-merge-20031214:1.38
	carlton-dictionary-20031111-merge:1.37
	gdb_6_0-2003-10-04-release:1.31
	kettenis_sparc-20030918-branch:1.36.0.6
	kettenis_sparc-20030918-branchpoint:1.36
	carlton_dictionary-20030917-merge:1.36
	ezannoni_pie-20030916-branchpoint:1.36
	ezannoni_pie-20030916-branch:1.36.0.4
	cagney_x86i386-20030821-branch:1.36.0.2
	cagney_x86i386-20030821-branchpoint:1.36
	carlton_dictionary-20030805-merge:1.36
	carlton_dictionary-20030627-merge:1.31
	gdb_6_0-branch:1.31.0.2
	gdb_6_0-2003-06-23-branchpoint:1.31
	jimb-ppc64-linux-20030613-branch:1.29.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.29
	cagney_convert-20030606-branch:1.29.0.2
	cagney_convert-20030606-branchpoint:1.29
	cagney_writestrings-20030508-branch:1.26.0.10
	cagney_writestrings-20030508-branchpoint:1.26
	jimb-ppc64-linux-20030528-branch:1.26.0.8
	jimb-ppc64-linux-20030528-branchpoint:1.26
	carlton_dictionary-20030523-merge:1.26
	cagney_fileio-20030521-branch:1.26.0.6
	cagney_fileio-20030521-branchpoint:1.26
	kettenis_i386newframe-20030517-mergepoint:1.26
	jimb-ppc64-linux-20030509-branch:1.26.0.4
	jimb-ppc64-linux-20030509-branchpoint:1.26
	kettenis_i386newframe-20030504-mergepoint:1.26
	carlton_dictionary-20030430-merge:1.26
	kettenis_i386newframe-20030419-branch:1.26.0.2
	kettenis_i386newframe-20030419-branchpoint:1.26
	carlton_dictionary-20030416-merge:1.26
	cagney_frameaddr-20030409-mergepoint:1.25
	kettenis_i386newframe-20030406-branch:1.25.0.6
	kettenis_i386newframe-20030406-branchpoint:1.25
	cagney_frameaddr-20030403-branchpoint:1.25
	cagney_frameaddr-20030403-branch:1.25.0.4
	cagney_framebase-20030330-mergepoint:1.25
	cagney_framebase-20030326-branch:1.25.0.2
	cagney_framebase-20030326-branchpoint:1.25
	cagney_lazyid-20030317-branch:1.24.0.2
	cagney_lazyid-20030317-branchpoint:1.24
	kettenis-i386newframe-20030316-mergepoint:1.24
	offbyone-20030313-branch:1.23.0.6
	offbyone-20030313-branchpoint:1.23
	kettenis-i386newframe-20030308-branch:1.23.0.4
	kettenis-i386newframe-20030308-branchpoint:1.23
	carlton_dictionary-20030305-merge:1.23
	cagney_offbyone-20030303-branch:1.23.0.2
	cagney_offbyone-20030303-branchpoint:1.23
	carlton_dictionary-20030207-merge:1.22
	interps-20030202-branch:1.21.0.2
	interps-20030202-branchpoint:1.21
	cagney-unwind-20030108-branch:1.18.0.2
	cagney-unwind-20030108-branchpoint:1.18
	carlton_dictionary-20021223-merge:1.17
	gdb_5_3-2002-12-12-release:1.17
	carlton_dictionary-20021115-merge:1.17
	kseitz_interps-20021105-merge:1.17
	kseitz_interps-20021103-merge:1.17
	drow-cplus-merge-20021020:1.17
	drow-cplus-merge-20021025:1.17
	carlton_dictionary-20021025-merge:1.17
	carlton_dictionary-20021011-merge:1.17
	drow-cplus-branch:1.17.0.10
	drow-cplus-branchpoint:1.17
	kseitz_interps-20020930-merge:1.17
	carlton_dictionary-20020927-merge:1.17
	carlton_dictionary-branch:1.17.0.8
	carlton_dictionary-20020920-branchpoint:1.17
	gdb_5_3-branch:1.17.0.6
	gdb_5_3-2002-09-04-branchpoint:1.17
	kseitz_interps-20020829-merge:1.17
	cagney_sysregs-20020825-branch:1.17.0.4
	cagney_sysregs-20020825-branchpoint:1.17
	readline_4_3-import-branch:1.17.0.2
	readline_4_3-import-branchpoint:1.17
	gdb_5_2_1-2002-07-23-release:1.8.2.1
	kseitz_interps-20020528-branch:1.15.0.2
	kseitz_interps-20020528-branchpoint:1.15
	cagney_regbuf-20020515-branch:1.8.0.6
	cagney_regbuf-20020515-branchpoint:1.8
	jimb-macro-020506-branch:1.8.0.4
	jimb-macro-020506-branchpoint:1.8
	gdb_5_2-2002-04-29-release:1.8
	gdb_5_2-branch:1.8.0.2
	gdb_5_2-2002-03-03-branchpoint:1.8
	gdb_5_1_1-2002-01-24-release:1.6
	gdb_5_1_0_1-2002-01-03-release:1.6
	gdb_5_1_0_1-2002-01-03-branch:1.6.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.6
	gdb_5_1-2001-11-21-release:1.6
	gdb_s390-2001-09-26-branch:1.6.0.4
	gdb_s390-2001-09-26-branchpoint:1.6
	gdb_5_1-2001-07-29-branch:1.6.0.2
	gdb_5_1-2001-07-29-branchpoint:1.6
	insight-precleanup-2001-01-01:1.6
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.50
date	2012.05.19.16.46.15;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	2011.07.05.19.06.37;	author vapier;	state Exp;
branches;
next	1.48;

1.48
date	2011.01.11.14.19.32;	author aburgess;	state Exp;
branches;
next	1.47;

1.47
date	2010.04.14.07.38.04;	author vapier;	state Exp;
branches;
next	1.46;

1.46
date	2009.12.09.05.32.16;	author ysato;	state Exp;
branches;
next	1.45;

1.45
date	2008.12.01.16.10.45;	author joel;	state Exp;
branches;
next	1.44;

1.44
date	2007.07.03.17.19.38;	author drow;	state Exp;
branches;
next	1.43;

1.43
date	2006.07.19.06.27.04;	author ysato;	state Exp;
branches;
next	1.42;

1.42
date	2004.06.28.19.26.37;	author aoliva;	state Exp;
branches;
next	1.41;

1.41
date	2004.06.28.19.25.43;	author aoliva;	state Exp;
branches;
next	1.40;

1.40
date	2004.06.10.20.22.17;	author msnyder;	state Exp;
branches;
next	1.39;

1.39
date	2004.01.06.00.58.48;	author msnyder;	state Exp;
branches
	1.39.6.1;
next	1.38;

1.38
date	2003.12.11.06.21.12;	author drd;	state Exp;
branches;
next	1.37;

1.37
date	2003.10.17.12.45.55;	author shrinivas;	state Exp;
branches;
next	1.36;

1.36
date	2003.07.29.21.03.39;	author msnyder;	state Exp;
branches;
next	1.35;

1.35
date	2003.07.22.19.07.30;	author msnyder;	state Exp;
branches;
next	1.34;

1.34
date	2003.07.18.00.10.41;	author msnyder;	state Exp;
branches;
next	1.33;

1.33
date	2003.07.18.00.08.23;	author msnyder;	state Exp;
branches;
next	1.32;

1.32
date	2003.07.02.19.04.58;	author msnyder;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.19.02.14.14;	author msnyder;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.19.00.49.33;	author msnyder;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.05.02.18.01;	author msnyder;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.04.18.28.21;	author msnyder;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.03.21.38.26;	author msnyder;	state Exp;
branches;
next	1.26;

1.26
date	2003.04.13.17.06.29;	author msnyder;	state Exp;
branches;
next	1.25;

1.25
date	2003.03.20.06.00.25;	author venkat;	state Exp;
branches;
next	1.24;

1.24
date	2003.03.14.04.12.01;	author venkat;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.27.23.26.33;	author cagney;	state Exp;
branches
	1.23.4.1;
next	1.22;

1.22
date	2003.02.05.23.10.27;	author kazu;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.01.03.00.14;	author kazu;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.16.20.03.30;	author msnyder;	state Exp;
branches;
next	1.19;

1.19
date	2003.01.16.19.54.35;	author msnyder;	state Exp;
branches;
next	1.18;

1.18
date	2002.12.26.05.44.46;	author kazu;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.29.17.01.57;	author avolkov;	state Exp;
branches
	1.17.8.1
	1.17.10.1;
next	1.16;

1.16
date	2002.06.09.15.45.47;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.19.12.52.54;	author kazu;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2002.05.18.11.40.19;	author kazu;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.17.19.22.14;	author avolkov;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.17.19.19.24;	author avolkov;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.17.19.09.13;	author avolkov;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.17.18.55.13;	author avolkov;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.17.18.47.14;	author avolkov;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.20.17.36.23;	author kazu;	state Exp;
branches
	1.8.2.1
	1.8.6.1;
next	1.7;

1.7
date	2001.12.20.16.47.52;	author kazu;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.11.02.03.02;	author kazu;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.27.09.39.50;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.20.21.12.33;	author fche;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.13.20.32.01;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.13.19.54.56;	author law;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.39.6.1
date	2004.09.16.17.02.09;	author drow;	state Exp;
branches;
next	;

1.23.4.1
date	2003.03.16.14.01.56;	author kettenis;	state Exp;
branches;
next	;

1.17.8.1
date	2003.02.07.19.18.05;	author carlton;	state Exp;
branches;
next	1.17.8.2;

1.17.8.2
date	2003.03.06.00.56.41;	author carlton;	state Exp;
branches;
next	1.17.8.3;

1.17.8.3
date	2003.04.16.19.57.08;	author carlton;	state Exp;
branches;
next	1.17.8.4;

1.17.8.4
date	2003.06.27.21.50.32;	author carlton;	state Exp;
branches;
next	1.17.8.5;

1.17.8.5
date	2003.08.05.17.13.33;	author carlton;	state Exp;
branches;
next	1.17.8.6;

1.17.8.6
date	2003.11.11.23.51.19;	author carlton;	state Exp;
branches;
next	1.17.8.7;

1.17.8.7
date	2003.12.16.00.01.21;	author carlton;	state Exp;
branches;
next	1.17.8.8;

1.17.8.8
date	2004.01.26.19.11.53;	author carlton;	state Exp;
branches;
next	;

1.17.10.1
date	2003.12.14.20.28.21;	author drow;	state Exp;
branches;
next	1.17.10.2;

1.17.10.2
date	2004.01.13.16.12.23;	author drow;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.20.01.39.32;	author kseitz;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.08.09.18.34.38;	author kseitz;	state Exp;
branches;
next	;

1.8.2.1
date	2002.05.17.13.24.13;	author avolkov;	state Exp;
branches;
next	;

1.8.6.1
date	2002.06.15.16.43.24;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.35.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.32.21;	author shebs;	state Exp;
branches;
next	;


desc
@@


1.50
log
@	PR 14072
	* wrapper.c: Include config.h before system header files.

	* callback.c: Include config.h before system header files.
	* cgen-trace.c: Likewise.
	* cgen-utils.c: Likewise.
	* gentmap.c: Likewise.

	* sim-if.c: Include config.h before system header files.

	* compile.c: Include config.h before system header files.
	* sim-main.h: Likewise.

	* gdb-if.c: Include config.h before system header files.
	* load.c: Likewise.
	* syscalls.c: Likewise.
	* trace.c: Likewise.

	* interp.c: Include config.h before system header files.
@
text
@/*
 * Simulator for the Renesas (formerly Hitachi) H8/300 architecture.
 *
 * Written by Steve Chamberlain of Cygnus Support. sac@@cygnus.com
 *
 * This file is part of H8/300 sim
 *
 *
 * THIS SOFTWARE IS NOT COPYRIGHTED
 *
 * Cygnus offers the following for use in the public domain.  Cygnus makes no
 * warranty with regard to the software or its performance and the user
 * accepts the software "AS IS" with all faults.
 *
 * CYGNUS DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD TO THIS
 * SOFTWARE INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include "config.h"
#include <signal.h>
#ifdef HAVE_TIME_H
#include <time.h>
#endif
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif

#include "bfd.h"
#include "sim-main.h"
#include "gdb/sim-h8300.h"
#include "sys/stat.h"
#include "sys/types.h"

#ifndef SIGTRAP
# define SIGTRAP 5
#endif

int debug;

host_callback *sim_callback;

static SIM_OPEN_KIND sim_kind;
static char *myname;

/* FIXME: Needs to live in header file.
   This header should also include the things in remote-sim.h.
   One could move this to remote-sim.h but this function isn't needed
   by gdb.  */
static void set_simcache_size (SIM_DESC, int);

#define X(op, size)  (op * 4 + size)

#define SP (h8300hmode && !h8300_normal_mode ? SL : SW)

#define h8_opcodes ops
#define DEFINE_TABLE
#include "opcode/h8300.h"

/* CPU data object: */

static int
sim_state_initialize (SIM_DESC sd, sim_cpu *cpu)
{
  /* FIXME: not really necessary, since sim_cpu_alloc calls zalloc.  */

  memset (&cpu->regs, 0, sizeof(cpu->regs));
  cpu->regs[SBR_REGNUM] = 0xFFFFFF00;
  cpu->pc = 0;
  cpu->delayed_branch = 0;
  cpu->memory = NULL;
  cpu->eightbit = NULL;
  cpu->mask = 0;

  /* Initialize local simulator state.  */
  sd->sim_cache = NULL;
  sd->sim_cache_size = 0;
  sd->cache_idx = NULL;
  sd->cache_top = 0;
  sd->memory_size = 0;
  sd->compiles = 0;
#ifdef ADEBUG
  memset (&cpu->stats, 0, sizeof (cpu->stats));
#endif
  return 0;
}

static unsigned int
h8_get_pc (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> pc;
}

static void
h8_set_pc (SIM_DESC sd, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> pc = val;
}

static unsigned int
h8_get_ccr (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[CCR_REGNUM];
}

static void
h8_set_ccr (SIM_DESC sd, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> regs[CCR_REGNUM] = val;
}

static unsigned int
h8_get_exr (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[EXR_REGNUM];
}

static void
h8_set_exr (SIM_DESC sd, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> regs[EXR_REGNUM] = val;
}

static int
h8_get_sbr (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[SBR_REGNUM];
}

static void
h8_set_sbr (SIM_DESC sd, int val)
{
  (STATE_CPU (sd, 0)) -> regs[SBR_REGNUM] = val;
}

static int
h8_get_vbr (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[VBR_REGNUM];
}

static void
h8_set_vbr (SIM_DESC sd, int val)
{
  (STATE_CPU (sd, 0)) -> regs[VBR_REGNUM] = val;
}

static int
h8_get_cache_top (SIM_DESC sd)
{
  return sd -> cache_top;
}

static void
h8_set_cache_top (SIM_DESC sd, int val)
{
  sd -> cache_top = val;
}

static int
h8_get_mask (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> mask;
}

static void
h8_set_mask (SIM_DESC sd, int val)
{
  (STATE_CPU (sd, 0)) -> mask = val;
}
#if 0
static int
h8_get_exception (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> exception;
}

static void
h8_set_exception (SIM_DESC sd, int val)
{
  (STATE_CPU (sd, 0)) -> exception = val;
}

static enum h8300_sim_state
h8_get_state (SIM_DESC sd)
{
  return sd -> state;
}

static void
h8_set_state (SIM_DESC sd, enum h8300_sim_state val)
{
  sd -> state = val;
}
#endif
static unsigned int
h8_get_cycles (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[CYCLE_REGNUM];
}

static void
h8_set_cycles (SIM_DESC sd, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> regs[CYCLE_REGNUM] = val;
}

static unsigned int
h8_get_insts (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[INST_REGNUM];
}

static void
h8_set_insts (SIM_DESC sd, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> regs[INST_REGNUM] = val;
}

static unsigned int
h8_get_ticks (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[TICK_REGNUM];
}

static void
h8_set_ticks (SIM_DESC sd, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> regs[TICK_REGNUM] = val;
}

static unsigned int
h8_get_mach (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[MACH_REGNUM];
}

static void
h8_set_mach (SIM_DESC sd, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> regs[MACH_REGNUM] = val;
}

static unsigned int
h8_get_macl (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[MACL_REGNUM];
}

static void
h8_set_macl (SIM_DESC sd, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> regs[MACL_REGNUM] = val;
}

static int
h8_get_compiles (SIM_DESC sd)
{
  return sd -> compiles;
}

static void
h8_increment_compiles (SIM_DESC sd)
{
  sd -> compiles ++;
}

static unsigned int *
h8_get_reg_buf (SIM_DESC sd)
{
  return &(((STATE_CPU (sd, 0)) -> regs)[0]);
}

static unsigned int
h8_get_reg (SIM_DESC sd, int regnum)
{
  return (STATE_CPU (sd, 0)) -> regs[regnum];
}

static void
h8_set_reg (SIM_DESC sd, int regnum, int val)
{
  (STATE_CPU (sd, 0)) -> regs[regnum] = val;
}

#ifdef ADEBUG
static int
h8_get_stats (SIM_DESC sd, int idx)
{
  return sd -> stats[idx];
}

static void
h8_increment_stats (SIM_DESC sd, int idx)
{
  sd -> stats[idx] ++;
}
#endif /* ADEBUG */

static unsigned short *
h8_get_cache_idx_buf (SIM_DESC sd)
{
  return sd -> cache_idx;
}

static void
h8_set_cache_idx_buf (SIM_DESC sd, unsigned short *ptr)
{
  sd -> cache_idx = ptr;
}

static unsigned short
h8_get_cache_idx (SIM_DESC sd, unsigned int idx)
{
  if (idx > sd->memory_size)
    return (unsigned short) -1;
  return sd -> cache_idx[idx];
}

static void
h8_set_cache_idx (SIM_DESC sd, int idx, unsigned int val)
{
  sd -> cache_idx[idx] = (unsigned short) val;
}

static unsigned char *
h8_get_memory_buf (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> memory;
}

static void
h8_set_memory_buf (SIM_DESC sd, unsigned char *ptr)
{
  (STATE_CPU (sd, 0)) -> memory = ptr;
}

static unsigned char
h8_get_memory (SIM_DESC sd, int idx)
{
  return (STATE_CPU (sd, 0)) -> memory[idx];
}

static void
h8_set_memory (SIM_DESC sd, int idx, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> memory[idx] = (unsigned char) val;
}

static unsigned char *
h8_get_eightbit_buf (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> eightbit;
}

static void
h8_set_eightbit_buf (SIM_DESC sd, unsigned char *ptr)
{
  (STATE_CPU (sd, 0)) -> eightbit = ptr;
}

static unsigned char
h8_get_eightbit (SIM_DESC sd, int idx)
{
  return (STATE_CPU (sd, 0)) -> eightbit[idx];
}

static void
h8_set_eightbit (SIM_DESC sd, int idx, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> eightbit[idx] = (unsigned char) val;
}

static unsigned int
h8_get_delayed_branch (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> delayed_branch;
}

static void
h8_set_delayed_branch (SIM_DESC sd, unsigned int dest)
{
  (STATE_CPU (sd, 0)) -> delayed_branch = dest;
}

static char **
h8_get_command_line (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> command_line;
}

static void
h8_set_command_line (SIM_DESC sd, char ** val)
{
  (STATE_CPU (sd, 0)) -> command_line = val;
}

static char *
h8_get_cmdline_arg (SIM_DESC sd, int index)
{
  return (STATE_CPU (sd, 0)) -> command_line[index];
}

static void
h8_set_cmdline_arg (SIM_DESC sd, int index, char * val)
{
  (STATE_CPU (sd, 0)) -> command_line[index] = val;
}

/* MAC Saturation Mode */
static int
h8_get_macS (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> macS;
}

static void
h8_set_macS (SIM_DESC sd, int val)
{
  (STATE_CPU (sd, 0)) -> macS = (val != 0);
}

/* MAC Zero Flag */
static int
h8_get_macZ (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> macZ;
}

static void
h8_set_macZ (SIM_DESC sd, int val)
{
  (STATE_CPU (sd, 0)) -> macZ = (val != 0);
}

/* MAC Negative Flag */
static int
h8_get_macN (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> macN;
}

static void
h8_set_macN (SIM_DESC sd, int val)
{
  (STATE_CPU (sd, 0)) -> macN = (val != 0);
}

/* MAC Overflow Flag */
static int
h8_get_macV (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> macV;
}

static void
h8_set_macV (SIM_DESC sd, int val)
{
  (STATE_CPU (sd, 0)) -> macV = (val != 0);
}

/* End CPU data object.  */

/* The rate at which to call the host's poll_quit callback.  */

enum { POLL_QUIT_INTERVAL = 0x80000 };

#define LOW_BYTE(x) ((x) & 0xff)
#define HIGH_BYTE(x) (((x) >> 8) & 0xff)
#define P(X, Y) ((X << 8) | Y)

#define C (c != 0)
#define Z (nz == 0)
#define V (v != 0)
#define N (n != 0)
#define U (u != 0)
#define H (h != 0)
#define UI (ui != 0)
#define I (intMaskBit != 0)

#define BUILDSR(SD)						\
  h8_set_ccr (SD, (I << 7) | (UI << 6) | (H << 5) | (U << 4)	\
	     | (N << 3) | (Z << 2) | (V << 1) | C)

#define GETSR(SD) \
  /* Get Status Register (flags).  */		\
  c = (h8_get_ccr (sd) >> 0) & 1;		\
  v = (h8_get_ccr (sd) >> 1) & 1;		\
  nz = !((h8_get_ccr (sd) >> 2) & 1);		\
  n = (h8_get_ccr (sd) >> 3) & 1;		\
  u = (h8_get_ccr (sd) >> 4) & 1;		\
  h = (h8_get_ccr (sd) >> 5) & 1;		\
  ui = ((h8_get_ccr (sd) >> 6) & 1);		\
  intMaskBit = (h8_get_ccr (sd) >> 7) & 1


#ifdef __CHAR_IS_SIGNED__
#define SEXTCHAR(x) ((char) (x))
#endif

#ifndef SEXTCHAR
#define SEXTCHAR(x) ((x & 0x80) ? (x | ~0xff) : x & 0xff)
#endif

#define UEXTCHAR(x) ((x) & 0xff)
#define UEXTSHORT(x) ((x) & 0xffff)
#define SEXTSHORT(x) ((short) (x))

int h8300hmode  = 0;
int h8300smode  = 0;
int h8300_normal_mode  = 0;
int h8300sxmode = 0;

static int memory_size;

static int
get_now (void)
{
  return time (0);	/* WinXX HAS UNIX like 'time', so why not use it? */
}

static int
now_persec (void)
{
  return 1;
}

static int
bitfrom (int x)
{
  switch (x & SIZE)
    {
    case L_8:
      return SB;
    case L_16:
    case L_16U:
      return SW;
    case L_32:
      return SL;
    case L_P:
      return (h8300hmode && !h8300_normal_mode)? SL : SW;
    }
  return 0;
}

/* Simulate an indirection / dereference.  
   return 0 for success, -1 for failure.
*/

static unsigned int
lvalue (SIM_DESC sd, int x, int rn, unsigned int *val)
{
  if (val == NULL)	/* Paranoia.  */
    return -1;

  switch (x / 4)
    {
    case OP_DISP:
      if (rn == ZERO_REGNUM)
	*val = X (OP_IMM, SP);
      else
	*val = X (OP_REG, SP);
      break;
    case OP_MEM:
      *val = X (OP_MEM, SP);
      break;
    default:
      sim_engine_set_run_state (sd, sim_stopped, SIGSEGV);
      return -1;
    }
  return 0;
}

static int
cmdline_location()
{
  if (h8300smode && !h8300_normal_mode)
    return 0xffff00L;
  else if (h8300hmode && !h8300_normal_mode)
    return 0x2ff00L;
  else
    return 0xff00L;
}

static void
decode (SIM_DESC sd, int addr, unsigned char *data, decoded_inst *dst)
{
  int cst[3]   = {0, 0, 0};
  int reg[3]   = {0, 0, 0};
  int rdisp[3] = {0, 0, 0};
  int opnum;
  const struct h8_opcode *q;

  dst->dst.type = -1;
  dst->src.type = -1;

  /* Find the exact opcode/arg combo.  */
  for (q = h8_opcodes; q->name; q++)
    {
      const op_type *nib = q->data.nib;
      unsigned int len = 0;

      if ((q->available == AV_H8SX && !h8300sxmode) ||
	  (q->available == AV_H8S  && !h8300smode)  ||
	  (q->available == AV_H8H  && !h8300hmode))
	continue;

      cst[0]   = cst[1]   = cst[2]   = 0;
      reg[0]   = reg[1]   = reg[2]   = 0;
      rdisp[0] = rdisp[1] = rdisp[2] = 0;

      while (1)
	{
	  op_type looking_for = *nib;
	  int thisnib = data[len / 2];

	  thisnib = (len & 1) ? (thisnib & 0xf) : ((thisnib >> 4) & 0xf);
	  opnum = ((looking_for & OP3) ? 2 :
		   (looking_for & DST) ? 1 : 0);

	  if (looking_for < 16 && looking_for >= 0)
	    {
	      if (looking_for != thisnib)
		goto fail;
	    }
	  else
	    {
	      if (looking_for & B31)
		{
		  if (!((thisnib & 0x8) != 0))
		    goto fail;

		  looking_for = (op_type) (looking_for & ~B31);
		  thisnib &= 0x7;
		}
	      else if (looking_for & B30)
		{
		  if (!((thisnib & 0x8) == 0))
		    goto fail;

		  looking_for = (op_type) (looking_for & ~B30);
		}

	      if (looking_for & B21)
		{
		  if (!((thisnib & 0x4) != 0))
		    goto fail;

		  looking_for = (op_type) (looking_for & ~B21);
		  thisnib &= 0xb;
		}
	      else if (looking_for & B20)
		{
		  if (!((thisnib & 0x4) == 0))
		    goto fail;

		  looking_for = (op_type) (looking_for & ~B20);
		}

	      if (looking_for & B11)
		{
		  if (!((thisnib & 0x2) != 0))
		    goto fail;

		  looking_for = (op_type) (looking_for & ~B11);
		  thisnib &= 0xd;
		}
	      else if (looking_for & B10)
		{
		  if (!((thisnib & 0x2) == 0))
		    goto fail;

		  looking_for = (op_type) (looking_for & ~B10);
		}

	      if (looking_for & B01)
		{
		  if (!((thisnib & 0x1) != 0))
		    goto fail;

		  looking_for = (op_type) (looking_for & ~B01);
		  thisnib &= 0xe;
		}
	      else if (looking_for & B00)
		{
		  if (!((thisnib & 0x1) == 0))
		    goto fail;

		  looking_for = (op_type) (looking_for & ~B00);
		}

	      if (looking_for & IGNORE)
		{
		  /* Hitachi has declared that IGNORE must be zero.  */
		  if (thisnib != 0)
		    goto fail;
		}
	      else if ((looking_for & MODE) == DATA)
		{
		  ;			/* Skip embedded data.  */
		}
	      else if ((looking_for & MODE) == DBIT)
		{
		  /* Exclude adds/subs by looking at bit 0 and 2, and
                     make sure the operand size, either w or l,
                     matches by looking at bit 1.  */
		  if ((looking_for & 7) != (thisnib & 7))
		    goto fail;

		  cst[opnum] = (thisnib & 0x8) ? 2 : 1;
		}
	      else if ((looking_for & MODE) == REG     ||
		       (looking_for & MODE) == LOWREG  ||
		       (looking_for & MODE) == IND     ||
		       (looking_for & MODE) == PREINC  ||
		       (looking_for & MODE) == POSTINC ||
		       (looking_for & MODE) == PREDEC  ||
		       (looking_for & MODE) == POSTDEC)
		{
		  reg[opnum] = thisnib;
		}
	      else if (looking_for & CTRL)
		{
		  thisnib &= 7;
		  if (((looking_for & MODE) == CCR  && (thisnib != C_CCR))  ||
		      ((looking_for & MODE) == EXR  && (thisnib != C_EXR))  ||
		      ((looking_for & MODE) == MACH && (thisnib != C_MACH)) ||
		      ((looking_for & MODE) == MACL && (thisnib != C_MACL)) ||
		      ((looking_for & MODE) == VBR  && (thisnib != C_VBR))  ||
		      ((looking_for & MODE) == SBR  && (thisnib != C_SBR)))
		    goto fail;
		  if (((looking_for & MODE) == CCR_EXR && 
		       (thisnib != C_CCR && thisnib != C_EXR)) ||
		      ((looking_for & MODE) == VBR_SBR && 
		       (thisnib != C_VBR && thisnib != C_SBR)) ||
		      ((looking_for & MODE) == MACREG && 
		       (thisnib != C_MACH && thisnib != C_MACL)))
		    goto fail;
		  if (((looking_for & MODE) == CC_EX_VB_SB && 
		       (thisnib != C_CCR && thisnib != C_EXR &&
			thisnib != C_VBR && thisnib != C_SBR)))
		    goto fail;

		  reg[opnum] = thisnib;
		}
	      else if ((looking_for & MODE) == ABS)
		{
		  /* Absolute addresses are unsigned.  */
		  switch (looking_for & SIZE)
		    {
		    case L_8:
		      cst[opnum] = UEXTCHAR (data[len / 2]);
		      break;
		    case L_16:
		    case L_16U:
		      cst[opnum] = (data[len / 2] << 8) + data[len / 2 + 1];
		      break;
		    case L_32:
		      cst[opnum] = 
			(data[len / 2 + 0] << 24) + 
			(data[len / 2 + 1] << 16) +
			(data[len / 2 + 2] <<  8) +  
			(data[len / 2 + 3]);
		      break;
		    default:
		      printf ("decode: bad size ABS: %d\n", 
			      (looking_for & SIZE));
		      goto end;
		    }
		}
	      else if ((looking_for & MODE) == DISP   ||
		       (looking_for & MODE) == PCREL  ||
		       (looking_for & MODE) == INDEXB ||
		       (looking_for & MODE) == INDEXW ||
		       (looking_for & MODE) == INDEXL)
		{
		  switch (looking_for & SIZE)
		    {
		    case L_2:
		      cst[opnum] = thisnib & 3;
		      break;
		    case L_8:
		      cst[opnum] = SEXTCHAR (data[len / 2]);
		      break;
		    case L_16:
		      cst[opnum] = (data[len / 2] << 8) + data[len / 2 + 1];
		      cst[opnum] = (short) cst[opnum];	/* Sign extend.  */
		      break;
		    case L_16U:
		      cst[opnum] = (data[len / 2] << 8) + data[len / 2 + 1];
		      break;
		    case L_32:
		      cst[opnum] = 
			(data[len / 2 + 0] << 24) + 
			(data[len / 2 + 1] << 16) +
			(data[len / 2 + 2] <<  8) +  
			(data[len / 2 + 3]);
		      break;
		    default:
		      printf ("decode: bad size DISP/PCREL/INDEX: %d\n", 
			      (looking_for & SIZE));
		      goto end;
		    }
		}
	      else if ((looking_for & SIZE) == L_16 ||
		       (looking_for & SIZE) == L_16U)
		{
		  cst[opnum] = (data[len / 2] << 8) + data[len / 2 + 1];
		  /* Immediates are always unsigned.  */
		  if ((looking_for & SIZE) != L_16U &&
		      (looking_for & MODE) != IMM)
		    cst[opnum] = (short) cst[opnum];	/* Sign extend.  */
		}
	      else if (looking_for & ABSJMP)
		{
		  switch (looking_for & SIZE) {
		  case L_24:
		    cst[opnum] = (data[1] << 16) | (data[2] << 8) | (data[3]);
		    break;
		  case L_32:
		    cst[opnum] = 
		      (data[len / 2 + 0] << 24) + 
		      (data[len / 2 + 1] << 16) +
		      (data[len / 2 + 2] <<  8) +  
		      (data[len / 2 + 3]);
		    break;
		  default:
		    printf ("decode: bad size ABSJMP: %d\n", 
			    (looking_for & SIZE));
		      goto end;
		  }
		}
	      else if ((looking_for & MODE) == MEMIND)
		{
		  cst[opnum] = data[1];
		}
	      else if ((looking_for & MODE) == VECIND)
		{
		  if(h8300_normal_mode)
		    cst[opnum] = ((data[1] & 0x7f) + 0x80) * 2;
		  else
		    cst[opnum] = ((data[1] & 0x7f) + 0x80) * 4;
		  cst[opnum] += h8_get_vbr (sd); /* Add vector base reg.  */
		}
	      else if ((looking_for & SIZE) == L_32)
		{
		  int i = len / 2;

		  cst[opnum] = 
		    (data[i + 0] << 24) |
		    (data[i + 1] << 16) |
		    (data[i + 2] <<  8) |
		    (data[i + 3]);
		}
	      else if ((looking_for & SIZE) == L_24)
		{
		  int i = len / 2;

		  cst[opnum] = 
		    (data[i + 0] << 16) | 
		    (data[i + 1] << 8) | 
		    (data[i + 2]);
		}
	      else if (looking_for & DISPREG)
		{
		  rdisp[opnum] = thisnib & 0x7;
		}
	      else if ((looking_for & MODE) == KBIT)
		{
		  switch (thisnib)
		    {
		    case 9:
		      cst[opnum] = 4;
		      break;
		    case 8:
		      cst[opnum] = 2;
		      break;
		    case 0:
		      cst[opnum] = 1;
		      break;
		    default:
		      goto fail;
		    }
		}
	      else if ((looking_for & SIZE) == L_8)
		{
		  if ((looking_for & MODE) == ABS)
		    {
		      /* Will be combined with contents of SBR_REGNUM
			 by fetch ().  For all modes except h8sx, this
			 will always contain the value 0xFFFFFF00.  */
		      cst[opnum] = data[len / 2] & 0xff;
		    }
		  else
		    {
		      cst[opnum] = data[len / 2] & 0xff;
		    }
		}
	      else if ((looking_for & SIZE) == L_2)
		{
		  cst[opnum] = thisnib & 3;
		}
	      else if ((looking_for & SIZE) == L_3 ||
		       (looking_for & SIZE) == L_3NZ)
		{
		  cst[opnum] = thisnib & 7;
		  if (cst[opnum] == 0 && (looking_for & SIZE) == L_3NZ)
		    goto fail;
		}
	      else if ((looking_for & SIZE) == L_4)
		{
		  cst[opnum] = thisnib & 15;
		}
	      else if ((looking_for & SIZE) == L_5)
		{
		  cst[opnum] = data[len / 2] & 0x1f;
		}
	      else if (looking_for == E)
		{
#ifdef ADEBUG
		  dst->op = q;
#endif
		  /* Fill in the args.  */
		  {
		    const op_type *args = q->args.nib;
		    int hadone = 0;
		    int nargs;

		    for (nargs = 0; 
			 nargs < 3 && *args != E; 
			 nargs++)
		      {
			int x = *args;
			ea_type *p;

			opnum = ((x & OP3) ? 2 :
				 (x & DST) ? 1 : 0);
			if (x & DST)
			  p = &dst->dst;
			else if (x & OP3)
			  p = &dst->op3;
			else
			  p = &dst->src;

			if ((x & MODE) == IMM  ||
			    (x & MODE) == KBIT ||
			    (x & MODE) == DBIT)
			  {
			    /* Use the instruction to determine 
			       the operand size.  */
			    p->type = X (OP_IMM, OP_SIZE (q->how));
			    p->literal = cst[opnum];
			  }
			else if ((x & MODE) == CONST_2 ||
				 (x & MODE) == CONST_4 ||
				 (x & MODE) == CONST_8 ||
				 (x & MODE) == CONST_16)
			  {
			    /* Use the instruction to determine 
			       the operand size.  */
			    p->type = X (OP_IMM, OP_SIZE (q->how));
			    switch (x & MODE) {
			    case CONST_2:	p->literal =  2; break;
			    case CONST_4:	p->literal =  4; break;
			    case CONST_8:	p->literal =  8; break;
			    case CONST_16:	p->literal = 16; break;
			    }
			  }
			else if ((x & MODE) == REG)
			  {
			    p->type = X (OP_REG, bitfrom (x));
			    p->reg = reg[opnum];
			  }
			else if ((x & MODE) == LOWREG)
			  {
			    p->type = X (OP_LOWREG, bitfrom (x));
			    p->reg = reg[opnum];
			  }
			else if ((x & MODE) == PREINC)
			  {
			    /* Use the instruction to determine 
			       the operand size.  */
			    p->type = X (OP_PREINC, OP_SIZE (q->how));
			    p->reg = reg[opnum] & 0x7;
			  }
			else if ((x & MODE) == POSTINC)
			  {
			    /* Use the instruction to determine 
			       the operand size.  */
			    p->type = X (OP_POSTINC, OP_SIZE (q->how));
			    p->reg = reg[opnum] & 0x7;
			  }
			else if ((x & MODE) == PREDEC)
			  {
			    /* Use the instruction to determine 
			       the operand size.  */
			    p->type = X (OP_PREDEC, OP_SIZE (q->how));
			    p->reg = reg[opnum] & 0x7;
			  }
			else if ((x & MODE) == POSTDEC)
			  {
			    /* Use the instruction to determine 
			       the operand size.  */
			    p->type = X (OP_POSTDEC, OP_SIZE (q->how));
			    p->reg = reg[opnum] & 0x7;
			  }
			else if ((x & MODE) == IND)
			  {
			    /* Note: an indirect is transformed into
			       a displacement of zero.  
			    */
			    /* Use the instruction to determine 
			       the operand size.  */
			    p->type = X (OP_DISP, OP_SIZE (q->how));
			    p->reg = reg[opnum] & 0x7;
			    p->literal = 0;
			    if (OP_KIND (q->how) == O_JSR ||
				OP_KIND (q->how) == O_JMP)
			      if (lvalue (sd, p->type, p->reg, (unsigned int *)&p->type))
				goto end;
			  }
			else if ((x & MODE) == ABS)
			  {
			    /* Note: a 16 or 32 bit ABS is transformed into a 
			       displacement from pseudo-register ZERO_REGNUM,
			       which is always zero.  An 8 bit ABS becomes
			       a displacement from SBR_REGNUM.
			    */
			    /* Use the instruction to determine 
			       the operand size.  */
			    p->type = X (OP_DISP, OP_SIZE (q->how));
			    p->literal = cst[opnum];

			    /* 8-bit ABS is displacement from SBR.
			       16 and 32-bit ABS are displacement from ZERO.
			       (SBR will always be zero except for h8/sx)
			    */
			    if ((x & SIZE) == L_8)
			      p->reg = SBR_REGNUM;
			    else
			      p->reg = ZERO_REGNUM;;
			  }
			else if ((x & MODE) == MEMIND ||
				 (x & MODE) == VECIND)
			  {
			    /* Size doesn't matter.  */
			    p->type = X (OP_MEM, SB);
			    p->literal = cst[opnum];
			    if (OP_KIND (q->how) == O_JSR ||
				OP_KIND (q->how) == O_JMP)
			      if (lvalue (sd, p->type, p->reg, (unsigned int *)&p->type))
				goto end;
			  }
			else if ((x & MODE) == PCREL)
			  {
			    /* Size doesn't matter.  */
			    p->type = X (OP_PCREL, SB);
			    p->literal = cst[opnum];
			  }
			else if (x & ABSJMP)
			  {
			    p->type = X (OP_IMM, SP);
			    p->literal = cst[opnum];
			  }
			else if ((x & MODE) == INDEXB)
			  {
			    p->type = X (OP_INDEXB, OP_SIZE (q->how));
			    p->literal = cst[opnum];
			    p->reg     = rdisp[opnum];
			  }
			else if ((x & MODE) == INDEXW)
			  {
			    p->type = X (OP_INDEXW, OP_SIZE (q->how));
			    p->literal = cst[opnum];
			    p->reg     = rdisp[opnum];
			  }
			else if ((x & MODE) == INDEXL)
			  {
			    p->type = X (OP_INDEXL, OP_SIZE (q->how));
			    p->literal = cst[opnum];
			    p->reg     = rdisp[opnum];
			  }
			else if ((x & MODE) == DISP)
			  {
			    /* Yuck -- special for mova args.  */
			    if (strncmp (q->name, "mova", 4) == 0 &&
				(x & SIZE) == L_2)
			      {
				/* Mova can have a DISP2 dest, with an
				   INDEXB or INDEXW src.  The multiplier
				   for the displacement value is determined
				   by the src operand, not by the insn.  */

				switch (OP_KIND (dst->src.type))
				  {
				  case OP_INDEXB:
				    p->type = X (OP_DISP, SB);
				    p->literal = cst[opnum];
				    break;
				  case OP_INDEXW:
				    p->type = X (OP_DISP, SW);
				    p->literal = cst[opnum] * 2;
				    break;
				  default:
				    goto fail;
				  }
			      }
			    else
			      {
				p->type = X (OP_DISP,   OP_SIZE (q->how));
				p->literal = cst[opnum];
				/* DISP2 is special.  */
				if ((x & SIZE) == L_2)
				  switch (OP_SIZE (q->how))
				    {
				    case SB:                  break;
				    case SW: p->literal *= 2; break;
				    case SL: p->literal *= 4; break;
				    }
			      }
			    p->reg     = rdisp[opnum];
			  }
			else if (x & CTRL)
			  {
			    switch (reg[opnum])
			      {
			      case C_CCR:
				p->type = X (OP_CCR, SB);
				break;
			      case C_EXR:
				p->type = X (OP_EXR, SB);
				break;
			      case C_MACH:
				p->type = X (OP_MACH, SL);
				break;
			      case C_MACL:
				p->type = X (OP_MACL, SL);
				break;
			      case C_VBR:
				p->type = X (OP_VBR, SL);
				break;
			      case C_SBR:
				p->type = X (OP_SBR, SL);
				break;
			      }
			  }
			else if ((x & MODE) == CCR)
			  {
			    p->type = OP_CCR;
			  }
			else if ((x & MODE) == EXR)
			  {
			    p->type = OP_EXR;
			  }
			else
			  printf ("Hmmmm 0x%x...\n", x);

			args++;
		      }
		  }

		  /* Unary operators: treat src and dst as equivalent.  */
		  if (dst->dst.type == -1)
		    dst->dst = dst->src;
		  if (dst->src.type == -1)
		    dst->src = dst->dst;

		  dst->opcode = q->how;
		  dst->cycles = q->time;

		  /* And jsr's to these locations are turned into 
		     magic traps.  */

		  if (OP_KIND (dst->opcode) == O_JSR)
		    {
		      switch (dst->src.literal)
			{
			case 0xc5:
			  dst->opcode = O (O_SYS_OPEN, SB);
			  break;
			case 0xc6:
			  dst->opcode = O (O_SYS_READ, SB);
			  break;
			case 0xc7:
			  dst->opcode = O (O_SYS_WRITE, SB);
			  break;
			case 0xc8:
			  dst->opcode = O (O_SYS_LSEEK, SB);
			  break;
			case 0xc9:
			  dst->opcode = O (O_SYS_CLOSE, SB);
			  break;
			case 0xca:
			  dst->opcode = O (O_SYS_STAT, SB);
			  break;
			case 0xcb:
			  dst->opcode = O (O_SYS_FSTAT, SB);
			  break;
			case 0xcc:
			  dst->opcode = O (O_SYS_CMDLINE, SB);
			  break;
			}
		      /* End of Processing for system calls.  */
		    }

		  dst->next_pc = addr + len / 2;
		  return;
		}
	      else
		printf ("Don't understand 0x%x \n", looking_for);
	    }

	  len++;
	  nib++;
	}

    fail:
      ;
    }
 end:
  /* Fell off the end.  */
  dst->opcode = O (O_ILL, SB);
}

static void
compile (SIM_DESC sd, int pc)
{
  int idx;

  /* Find the next cache entry to use.  */
  idx = h8_get_cache_top (sd) + 1;
  h8_increment_compiles (sd);
  if (idx >= sd->sim_cache_size)
    {
      idx = 1;
    }
  h8_set_cache_top (sd, idx);

  /* Throw away its old meaning.  */
  h8_set_cache_idx (sd, sd->sim_cache[idx].oldpc, 0);

  /* Set to new address.  */
  sd->sim_cache[idx].oldpc = pc;

  /* Fill in instruction info.  */
  decode (sd, pc, h8_get_memory_buf (sd) + pc, sd->sim_cache + idx);

  /* Point to new cache entry.  */
  h8_set_cache_idx (sd, pc, idx);
}


static unsigned char  *breg[32];
static unsigned short *wreg[16];
static unsigned int   *lreg[18];

#define GET_B_REG(X)     *(breg[X])
#define SET_B_REG(X, Y) (*(breg[X])) = (Y)
#define GET_W_REG(X)     *(wreg[X])
#define SET_W_REG(X, Y) (*(wreg[X])) = (Y)
#define GET_L_REG(X)     h8_get_reg (sd, X)
#define SET_L_REG(X, Y)  h8_set_reg (sd, X, Y)

#define GET_MEMORY_L(X) \
  ((X) < memory_size \
   ? ((h8_get_memory (sd, (X)+0) << 24) | (h8_get_memory (sd, (X)+1) << 16)  \
    | (h8_get_memory (sd, (X)+2) <<  8) | (h8_get_memory (sd, (X)+3) <<  0)) \
   : ((h8_get_eightbit (sd, ((X)+0) & 0xff) << 24) \
    | (h8_get_eightbit (sd, ((X)+1) & 0xff) << 16) \
    | (h8_get_eightbit (sd, ((X)+2) & 0xff) <<  8) \
    | (h8_get_eightbit (sd, ((X)+3) & 0xff) <<  0)))

#define GET_MEMORY_W(X) \
  ((X) < memory_size \
   ? ((h8_get_memory   (sd, (X)+0) << 8) \
    | (h8_get_memory   (sd, (X)+1) << 0)) \
   : ((h8_get_eightbit (sd, ((X)+0) & 0xff) << 8) \
    | (h8_get_eightbit (sd, ((X)+1) & 0xff) << 0)))


#define GET_MEMORY_B(X) \
  ((X) < memory_size ? (h8_get_memory   (sd, (X))) \
                     : (h8_get_eightbit (sd, (X) & 0xff)))

#define SET_MEMORY_L(X, Y)  \
{  register unsigned char *_p; register int __y = (Y); \
   _p = ((X) < memory_size ? h8_get_memory_buf   (sd) +  (X) : \
                             h8_get_eightbit_buf (sd) + ((X) & 0xff)); \
   _p[0] = __y >> 24; _p[1] = __y >> 16; \
   _p[2] = __y >>  8; _p[3] = __y >>  0; \
}

#define SET_MEMORY_W(X, Y) \
{  register unsigned char *_p; register int __y = (Y); \
   _p = ((X) < memory_size ? h8_get_memory_buf   (sd) +  (X) : \
                             h8_get_eightbit_buf (sd) + ((X) & 0xff)); \
   _p[0] = __y >> 8; _p[1] = __y; \
}

#define SET_MEMORY_B(X, Y) \
  ((X) < memory_size ? (h8_set_memory   (sd, (X), (Y))) \
                     : (h8_set_eightbit (sd, (X) & 0xff, (Y))))

/* Simulate a memory fetch.
   Return 0 for success, -1 for failure.
*/

static int
fetch_1 (SIM_DESC sd, ea_type *arg, int *val, int twice)
{
  int rn = arg->reg;
  int abs = arg->literal;
  int r;
  int t;

  if (val == NULL)
    return -1;		/* Paranoia.  */

  switch (arg->type)
    {
      /* Indexed register plus displacement mode:

	 This new family of addressing modes are similar to OP_DISP
	 (register plus displacement), with two differences:
	   1) INDEXB uses only the least significant byte of the register,
	      INDEXW uses only the least significant word, and
	      INDEXL uses the entire register (just like OP_DISP).
	 and
	   2) The displacement value in abs is multiplied by two
	      for SW-sized operations, and by four for SL-size.

	This gives nine possible variations.
      */

    case X (OP_INDEXB, SB):
    case X (OP_INDEXB, SW):
    case X (OP_INDEXB, SL):
    case X (OP_INDEXW, SB):
    case X (OP_INDEXW, SW):
    case X (OP_INDEXW, SL):
    case X (OP_INDEXL, SB):
    case X (OP_INDEXL, SW):
    case X (OP_INDEXL, SL):
      t = GET_L_REG (rn);
      switch (OP_KIND (arg->type)) {
      case OP_INDEXB:	t &= 0xff;	break;
      case OP_INDEXW:	t &= 0xffff;	break;
      case OP_INDEXL:
      default:		break;
      }
      switch (OP_SIZE (arg->type)) {
      case SB:
	*val = GET_MEMORY_B ((t * 1 + abs) & h8_get_mask (sd));
	break;
      case SW:
	*val = GET_MEMORY_W ((t * 2 + abs) & h8_get_mask (sd));
	break;
      case SL:
	*val = GET_MEMORY_L ((t * 4 + abs) & h8_get_mask (sd));
	break;
      }
      break;

    case X (OP_LOWREG, SB):
      *val = GET_L_REG (rn) & 0xff;
      break;
    case X (OP_LOWREG, SW):
      *val = GET_L_REG (rn) & 0xffff; 
      break;

    case X (OP_REG, SB):	/* Register direct, byte.  */
      *val = GET_B_REG (rn);
      break;
    case X (OP_REG, SW):	/* Register direct, word.  */
      *val = GET_W_REG (rn);
      break;
    case X (OP_REG, SL):	/* Register direct, long.  */
      *val = GET_L_REG (rn);
      break;
    case X (OP_IMM, SB):	/* Immediate, byte.  */
    case X (OP_IMM, SW):	/* Immediate, word.  */
    case X (OP_IMM, SL):	/* Immediate, long.  */
      *val = abs;
      break;
    case X (OP_POSTINC, SB):	/* Register indirect w/post-incr: byte.  */
      t = GET_L_REG (rn);
      r = GET_MEMORY_B (t & h8_get_mask (sd));
      if (!twice)
	t += 1;
      SET_L_REG (rn, t);
      *val = r;
      break;
    case X (OP_POSTINC, SW):	/* Register indirect w/post-incr: word.  */
      t = GET_L_REG (rn);
      r = GET_MEMORY_W (t & h8_get_mask (sd));
      if (!twice)
	t += 2;
      SET_L_REG (rn, t);
      *val = r;
      break;
    case X (OP_POSTINC, SL):	/* Register indirect w/post-incr: long.  */
      t = GET_L_REG (rn);
      r = GET_MEMORY_L (t & h8_get_mask (sd));
      if (!twice)
	t += 4;
      SET_L_REG (rn, t);
      *val = r;
      break;

    case X (OP_POSTDEC, SB):	/* Register indirect w/post-decr: byte.  */
      t = GET_L_REG (rn);
      r = GET_MEMORY_B (t & h8_get_mask (sd));
      if (!twice)
	t -= 1;
      SET_L_REG (rn, t);
      *val = r;
      break;
    case X (OP_POSTDEC, SW):	/* Register indirect w/post-decr: word.  */
      t = GET_L_REG (rn);
      r = GET_MEMORY_W (t & h8_get_mask (sd));
      if (!twice)
	t -= 2;
      SET_L_REG (rn, t);
      *val = r;
      break;
    case X (OP_POSTDEC, SL):	/* Register indirect w/post-decr: long.  */
      t = GET_L_REG (rn);
      r = GET_MEMORY_L (t & h8_get_mask (sd));
      if (!twice)
	t -= 4;
      SET_L_REG (rn, t);
      *val = r;
      break;

    case X (OP_PREDEC, SB):	/* Register indirect w/pre-decr: byte.  */
      t = GET_L_REG (rn) - 1;
      SET_L_REG (rn, t);
      t &= h8_get_mask (sd);
      *val = GET_MEMORY_B (t);
      break;
      
    case X (OP_PREDEC, SW):	/* Register indirect w/pre-decr: word.  */
      t = GET_L_REG (rn) - 2;
      SET_L_REG (rn, t);
      t &= h8_get_mask (sd);
      *val = GET_MEMORY_W (t);
      break;
      
    case X (OP_PREDEC, SL):	/* Register indirect w/pre-decr: long.  */
      t = GET_L_REG (rn) - 4;
      SET_L_REG (rn, t);
      t &= h8_get_mask (sd);
      *val = GET_MEMORY_L (t);
      break;
      
    case X (OP_PREINC, SB):	/* Register indirect w/pre-incr: byte.  */
      t = GET_L_REG (rn) + 1;
      SET_L_REG (rn, t);
      t &= h8_get_mask (sd);
      *val = GET_MEMORY_B (t);
      break;

    case X (OP_PREINC, SW):	/* Register indirect w/pre-incr: long.  */
      t = GET_L_REG (rn) + 2;
      SET_L_REG (rn, t);
      t &= h8_get_mask (sd);
      *val = GET_MEMORY_W (t);
      break;

    case X (OP_PREINC, SL):	/* Register indirect w/pre-incr: long.  */
      t = GET_L_REG (rn) + 4;
      SET_L_REG (rn, t);
      t &= h8_get_mask (sd);
      *val = GET_MEMORY_L (t);
      break;

    case X (OP_DISP, SB):	/* Register indirect w/displacement: byte.  */
      t = GET_L_REG (rn) + abs;
      t &= h8_get_mask (sd);
      *val = GET_MEMORY_B (t);
      break;

    case X (OP_DISP, SW):	/* Register indirect w/displacement: word.  */
      t = GET_L_REG (rn) + abs;
      t &= h8_get_mask (sd);
      *val = GET_MEMORY_W (t);
      break;

    case X (OP_DISP, SL):	/* Register indirect w/displacement: long.  */
      t = GET_L_REG (rn) + abs;
      t &= h8_get_mask (sd);
      *val =GET_MEMORY_L (t);
      break;

    case X (OP_MEM, SL):	/* Absolute memory address, long.  */
      t = GET_MEMORY_L (abs);
      t &= h8_get_mask (sd);
      *val = t;
      break;

    case X (OP_MEM, SW):	/* Absolute memory address, word.  */
      t = GET_MEMORY_W (abs);
      t &= h8_get_mask (sd);
      *val = t;
      break;

    case X (OP_PCREL, SB):	/* PC relative (for jump, branch etc).  */
    case X (OP_PCREL, SW):
    case X (OP_PCREL, SL):
    case X (OP_PCREL, SN):
      *val = abs;
      break;

    case X (OP_MEM, SB):	/* Why isn't this implemented?  */
    default:
      sim_engine_set_run_state (sd, sim_stopped, SIGSEGV);
      return -1;
    }
  return 0;	/* Success.  */
}

/* Normal fetch.  */

static int
fetch (SIM_DESC sd, ea_type *arg, int *val)
{
  return fetch_1 (sd, arg, val, 0);
}

/* Fetch which will be followed by a store to the same location.
   The difference being that we don't want to do a post-increment
   or post-decrement at this time: we'll do it when we store.  */

static int
fetch2 (SIM_DESC sd, ea_type *arg, int *val)
{
  return fetch_1 (sd, arg, val, 1);
}

/* Simulate a memory store.
   Return 0 for success, -1 for failure.
*/

static int
store_1 (SIM_DESC sd, ea_type *arg, int n, int twice)
{
  int rn = arg->reg;
  int abs = arg->literal;
  int t;

  switch (arg->type)
    {
      /* Indexed register plus displacement mode:

	 This new family of addressing modes are similar to OP_DISP
	 (register plus displacement), with two differences:
	   1) INDEXB uses only the least significant byte of the register,
	      INDEXW uses only the least significant word, and
	      INDEXL uses the entire register (just like OP_DISP).
	 and
	   2) The displacement value in abs is multiplied by two
	      for SW-sized operations, and by four for SL-size.

	This gives nine possible variations.
      */

    case X (OP_INDEXB, SB):
    case X (OP_INDEXB, SW):
    case X (OP_INDEXB, SL):
    case X (OP_INDEXW, SB):
    case X (OP_INDEXW, SW):
    case X (OP_INDEXW, SL):
    case X (OP_INDEXL, SB):
    case X (OP_INDEXL, SW):
    case X (OP_INDEXL, SL):
      t = GET_L_REG (rn);
      switch (OP_KIND (arg->type)) {
      case OP_INDEXB:	t &= 0xff;	break;
      case OP_INDEXW:	t &= 0xffff;	break;
      case OP_INDEXL:
      default:		break;
      }
      switch (OP_SIZE (arg->type)) {
      case SB:
	SET_MEMORY_B ((t * 1 + abs) & h8_get_mask (sd), n);
	break;
      case SW:
	SET_MEMORY_W ((t * 2 + abs) & h8_get_mask (sd), n);
	break;
      case SL:
	SET_MEMORY_L ((t * 4 + abs) & h8_get_mask (sd), n);
	break;
      }
      break;

    case X (OP_REG, SB):	/* Register direct, byte.  */
      SET_B_REG (rn, n);
      break;
    case X (OP_REG, SW):	/* Register direct, word.  */
      SET_W_REG (rn, n);
      break;
    case X (OP_REG, SL):	/* Register direct, long.  */
      SET_L_REG (rn, n);
      break;

    case X (OP_PREDEC, SB):	/* Register indirect w/pre-decr, byte.  */
      t = GET_L_REG (rn);
      if (!twice)
	t -= 1;
      SET_L_REG (rn, t);
      t &= h8_get_mask (sd);
      SET_MEMORY_B (t, n);

      break;
    case X (OP_PREDEC, SW):	/* Register indirect w/pre-decr, word.  */
      t = GET_L_REG (rn);
      if (!twice)
	t -= 2;
      SET_L_REG (rn, t);
      t &= h8_get_mask (sd);
      SET_MEMORY_W (t, n);
      break;

    case X (OP_PREDEC, SL):	/* Register indirect w/pre-decr, long.  */
      t = GET_L_REG (rn);
      if (!twice)
	t -= 4;
      SET_L_REG (rn, t);
      t &= h8_get_mask (sd);
      SET_MEMORY_L (t, n);
      break;

    case X (OP_PREINC, SB):	/* Register indirect w/pre-incr, byte.  */
      t = GET_L_REG (rn);
      if (!twice)
	t += 1;
      SET_L_REG (rn, t);
      t &= h8_get_mask (sd);
      SET_MEMORY_B (t, n);

      break;
    case X (OP_PREINC, SW):	/* Register indirect w/pre-incr, word.  */
      t = GET_L_REG (rn);
      if (!twice)
	t += 2;
      SET_L_REG (rn, t);
      t &= h8_get_mask (sd);
      SET_MEMORY_W (t, n);
      break;

    case X (OP_PREINC, SL):	/* Register indirect w/pre-incr, long.  */
      t = GET_L_REG (rn);
      if (!twice)
	t += 4;
      SET_L_REG (rn, t);
      t &= h8_get_mask (sd);
      SET_MEMORY_L (t, n);
      break;

    case X (OP_POSTDEC, SB):	/* Register indirect w/post-decr, byte.  */
      t = GET_L_REG (rn);
      SET_L_REG (rn, t - 1);
      t &= h8_get_mask (sd);
      SET_MEMORY_B (t, n);
      break;

    case X (OP_POSTDEC, SW):	/* Register indirect w/post-decr, word.  */
      t = GET_L_REG (rn);
      SET_L_REG (rn, t - 2);
      t &= h8_get_mask (sd);
      SET_MEMORY_W (t, n);
      break;

    case X (OP_POSTDEC, SL):	/* Register indirect w/post-decr, long.  */
      t = GET_L_REG (rn);
      SET_L_REG (rn, t - 4);
      t &= h8_get_mask (sd);
      SET_MEMORY_L (t, n);
      break;

    case X (OP_POSTINC, SB):	/* Register indirect w/post-incr, byte.  */
      t = GET_L_REG (rn);
      SET_L_REG (rn, t + 1);
      t &= h8_get_mask (sd);
      SET_MEMORY_B (t, n);
      break;

    case X (OP_POSTINC, SW):	/* Register indirect w/post-incr, word.  */
      t = GET_L_REG (rn);
      SET_L_REG (rn, t + 2);
      t &= h8_get_mask (sd);
      SET_MEMORY_W (t, n);
      break;

    case X (OP_POSTINC, SL):	/* Register indirect w/post-incr, long.  */
      t = GET_L_REG (rn);
      SET_L_REG (rn, t + 4);
      t &= h8_get_mask (sd);
      SET_MEMORY_L (t, n);
      break;

    case X (OP_DISP, SB):	/* Register indirect w/displacement, byte.  */
      t = GET_L_REG (rn) + abs;
      t &= h8_get_mask (sd);
      SET_MEMORY_B (t, n);
      break;

    case X (OP_DISP, SW):	/* Register indirect w/displacement, word.  */
      t = GET_L_REG (rn) + abs;
      t &= h8_get_mask (sd);
      SET_MEMORY_W (t, n);
      break;

    case X (OP_DISP, SL):	/* Register indirect w/displacement, long.  */
      t = GET_L_REG (rn) + abs;
      t &= h8_get_mask (sd);
      SET_MEMORY_L (t, n);
      break;


    case X (OP_MEM, SB):	/* Why isn't this implemented?  */
    case X (OP_MEM, SW):	/* Why isn't this implemented?  */
    case X (OP_MEM, SL):	/* Why isn't this implemented?  */
    default:
      sim_engine_set_run_state (sd, sim_stopped, SIGSEGV);
      return -1;
    }
  return 0;
}

/* Normal store.  */

static int
store (SIM_DESC sd, ea_type *arg, int n)
{
  return store_1 (sd, arg, n, 0);
}

/* Store which follows a fetch from the same location.
   The difference being that we don't want to do a pre-increment
   or pre-decrement at this time: it was already done when we fetched.  */

static int
store2 (SIM_DESC sd, ea_type *arg, int n)
{
  return store_1 (sd, arg, n, 1);
}

static union
{
  short int i;
  struct
    {
      char low;
      char high;
    }
  u;
} littleendian;

/* Flag to be set whenever a new SIM_DESC object is created.  */
static int init_pointers_needed = 1;

static void
init_pointers (SIM_DESC sd)
{
  if (init_pointers_needed)
    {
      int i;

      littleendian.i = 1;

      if (h8300smode && !h8300_normal_mode)
	memory_size = H8300S_MSIZE;
      else if (h8300hmode && !h8300_normal_mode)
	memory_size = H8300H_MSIZE;
      else
	memory_size = H8300_MSIZE;
      /* `msize' must be a power of two.  */
      if ((memory_size & (memory_size - 1)) != 0)
	{
	  (*sim_callback->printf_filtered) 
	    (sim_callback,
	     "init_pointers: bad memory size %d, defaulting to %d.\n", 
	     memory_size, memory_size = H8300S_MSIZE);
	}

      if (h8_get_memory_buf (sd))
	free (h8_get_memory_buf (sd));
      if (h8_get_cache_idx_buf (sd))
	free (h8_get_cache_idx_buf (sd));
      if (h8_get_eightbit_buf (sd))
	free (h8_get_eightbit_buf (sd));

      h8_set_memory_buf (sd, (unsigned char *) 
			 calloc (sizeof (char), memory_size));
      h8_set_cache_idx_buf (sd, (unsigned short *) 
			    calloc (sizeof (short), memory_size));
      sd->memory_size = memory_size;
      h8_set_eightbit_buf (sd, (unsigned char *) calloc (sizeof (char), 256));

      h8_set_mask (sd, memory_size - 1);

      memset (h8_get_reg_buf (sd), 0, sizeof (((STATE_CPU (sd, 0))->regs)));

      for (i = 0; i < 8; i++)
	{
	  /* FIXME: rewrite using local buffer.  */
	  unsigned char *p = (unsigned char *) (h8_get_reg_buf (sd) + i);
	  unsigned char *e = (unsigned char *) (h8_get_reg_buf (sd) + i + 1);
	  unsigned short *q = (unsigned short *) (h8_get_reg_buf (sd) + i);
	  unsigned short *u = (unsigned short *) (h8_get_reg_buf (sd) + i + 1);
	  h8_set_reg (sd, i, 0x00112233);

	  while (p < e)
	    {
	      if (*p == 0x22)
		  breg[i] = p;
	      if (*p == 0x33)
		  breg[i + 8] = p;
	      if (*p == 0x11)
		breg[i + 16] = p;
	      if (*p == 0x00)
		breg[i + 24] = p;
	      p++;
	    }

	  wreg[i] = wreg[i + 8] = 0;
	  while (q < u)
	    {
	      if (*q == 0x2233)
		{
		  wreg[i] = q;
		}
	      if (*q == 0x0011)
		{
		  wreg[i + 8] = q;
		}
	      q++;
	    }

	  if (wreg[i] == 0 || wreg[i + 8] == 0)
	    (*sim_callback->printf_filtered) (sim_callback, 
					      "init_pointers: internal error.\n");

	  h8_set_reg (sd, i, 0);
	  lreg[i] = h8_get_reg_buf (sd) + i;
	}

      /* Note: sim uses pseudo-register ZERO as a zero register.  */
      lreg[ZERO_REGNUM] = h8_get_reg_buf (sd) + ZERO_REGNUM;
      init_pointers_needed = 0;

      /* Initialize the seg registers.  */
      if (!sd->sim_cache)
	set_simcache_size (sd, CSIZE);
    }
}

/* Grotty global variable for use by control_c signal handler.  */
static SIM_DESC control_c_sim_desc;

static void
control_c (int sig)
{
  sim_engine_set_run_state (control_c_sim_desc, sim_stopped, SIGINT);
}

int
sim_stop (SIM_DESC sd)
{
  /* FIXME: use a real signal value.  */
  sim_engine_set_run_state (sd, sim_stopped, SIGINT);
  return 1;
}

#define OBITOP(name, f, s, op) 			\
case O (name, SB):				\
{						\
  int m, tmp;					\
	 					\
  if (f)					\
    if (fetch (sd, &code->dst, &ea))		\
      goto end;					\
  if (fetch (sd, &code->src, &tmp))		\
    goto end;					\
  m = 1 << (tmp & 7);				\
  op;						\
  if (s)					\
    if (store (sd, &code->dst,ea))		\
      goto end;					\
  goto next;					\
}

void
sim_resume (SIM_DESC sd, int step, int siggnal)
{
  static int init1;
  int cycles = 0;
  int insts = 0;
  int tick_start = get_now ();
  void (*prev) ();
  int poll_count = 0;
  int res;
  int tmp;
  int rd;
  int ea;
  int bit;
  int pc;
  int c, nz, v, n, u, h, ui, intMaskBit;
  int trace, intMask;
  int oldmask;
  enum sim_stop reason;
  int sigrc;

  init_pointers (sd);

  control_c_sim_desc = sd;
  prev = signal (SIGINT, control_c);

  if (step)
    {
      sim_engine_set_run_state (sd, sim_stopped, SIGTRAP);
    }
  else
    {
      sim_engine_set_run_state (sd, sim_running, 0);
    }

  pc = h8_get_pc (sd);

  /* The PC should never be odd.  */
  if (pc & 0x1)
    {
      sim_engine_set_run_state (sd, sim_stopped, SIGBUS);
      return;
    }

  /* Get Status Register (flags).  */
  GETSR (sd);

  if (h8300smode)	/* Get exr.  */
    {
      trace = (h8_get_exr (sd) >> 7) & 1;
      intMask = h8_get_exr (sd) & 7;
    }

  oldmask = h8_get_mask (sd);
  if (!h8300hmode || h8300_normal_mode)
    h8_set_mask (sd, 0xffff);
  do
    {
      unsigned short cidx;
      decoded_inst *code;

    top:
      cidx = h8_get_cache_idx (sd, pc);
      if (cidx == (unsigned short) -1 ||
	  cidx >= sd->sim_cache_size)
	goto illegal;
	  
      code = sd->sim_cache + cidx;

#if ADEBUG
      if (debug)
	{
	  printf ("%x %d %s\n", pc, code->opcode,
		  code->op ? code->op->name : "**");
	}
      h8_increment_stats (sd, code->opcode);
#endif

      if (code->opcode)
	{
	  cycles += code->cycles;
	  insts++;
	}

      switch (code->opcode)
	{
	case 0:
	  /*
	   * This opcode is a fake for when we get to an
	   * instruction which hasnt been compiled
	   */
	  compile (sd, pc);
	  goto top;
	  break;

	case O (O_MOVAB, SL):
	case O (O_MOVAW, SL):
	case O (O_MOVAL, SL):
	  /* 1) Evaluate 2nd argument (dst).
	     2) Mask / zero extend according to whether 1st argument (src)
	        is INDEXB, INDEXW, or INDEXL.
	     3) Left-shift the result by 0, 1 or 2, according to size of mova
	        (mova/b, mova/w, mova/l).
	     4) Add literal value of 1st argument (src).
	     5) Store result in 3rd argument (op3).
	  */

	  /* Alas, since this is the only instruction with 3 arguments, 
	     decode doesn't handle them very well.  Some fix-up is required.

	     a) The size of dst is determined by whether src is 
	        INDEXB or INDEXW.  */

	  if (OP_KIND (code->src.type) == OP_INDEXB)
	    code->dst.type = X (OP_KIND (code->dst.type), SB);
	  else if (OP_KIND (code->src.type) == OP_INDEXW)
	    code->dst.type = X (OP_KIND (code->dst.type), SW);

	  /* b) If op3 == null, then this is the short form of the insn.
	        Dst is the dispreg of src, and op3 is the 32-bit form
		of the same register.
	  */

	  if (code->op3.type == 0)
	    {
	      /* Short form: src == INDEXB/INDEXW, dst == op3 == 0.
		 We get to compose dst and op3 as follows:

		     op3 is a 32-bit register, ID == src.reg.
		     dst is the same register, but 8 or 16 bits
		     depending on whether src is INDEXB or INDEXW.
	      */

	      code->op3.type = X (OP_REG, SL);
	      code->op3.reg  = code->src.reg;
	      code->op3.literal = 0;

	      if (OP_KIND (code->src.type) == OP_INDEXB)
		{
		  code->dst.type = X (OP_REG, SB);
		  code->dst.reg = code->op3.reg + 8;
		}
	      else
		code->dst.type = X (OP_REG, SW);
	    }

	  if (fetch (sd, &code->dst, &ea))
	    goto end;

	  switch (OP_KIND (code->src.type)) {
	  case OP_INDEXB:    ea = ea & 0xff;		break;
	  case OP_INDEXW:    ea = ea & 0xffff;		break;
	  case OP_INDEXL:    				break;
	  default:	     goto illegal;
	  }

	  switch (code->opcode) {
	  case O (O_MOVAB, SL):	    			break;
	  case O (O_MOVAW, SL):	    ea = ea << 1;	break;
	  case O (O_MOVAL, SL):     ea = ea << 2;	break;
	  default: 		    goto illegal;
	  }
	  
	  ea = ea + code->src.literal;

	  if (store (sd, &code->op3, ea))
	    goto end;

	  goto next;	  

	case O (O_SUBX, SB):	/* subx, extended sub */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = -(ea + C);
	  res = rd + ea;
	  goto alu8;

	case O (O_SUBX, SW):	/* subx, extended sub */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = -(ea + C);
	  res = rd + ea;
	  goto alu16;

	case O (O_SUBX, SL):	/* subx, extended sub */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = -(ea + C);
	  res = rd + ea;
	  goto alu32;

	case O (O_ADDX, SB):	/* addx, extended add */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = ea + C;
	  res = rd + ea;
	  goto alu8;

	case O (O_ADDX, SW):	/* addx, extended add */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = ea + C;
	  res = rd + ea;
	  goto alu16;

	case O (O_ADDX, SL):	/* addx, extended add */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = ea + C;
	  res = rd + ea;
	  goto alu32;

	case O (O_SUB, SB):		/* sub.b */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  ea = -ea;
	  res = rd + ea;
	  goto alu8;

	case O (O_SUB, SW):		/* sub.w */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  ea = -ea;
	  res = rd + ea;
	  goto alu16;

	case O (O_SUB, SL):		/* sub.l */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  ea = -ea;
	  res = rd + ea;
	  goto alu32;

	case O (O_NEG, SB):		/* neg.b */
	  /* Fetch ea.  */
	  if (fetch2 (sd, &code->src, &ea)) 
	    goto end;
	  ea = -ea;
	  rd = 0;
	  res = rd + ea;
	  goto alu8;

	case O (O_NEG, SW):		/* neg.w */
	  /* Fetch ea.  */
	  if (fetch2 (sd, &code->src, &ea)) 
	    goto end;
	  ea = -ea;
	  rd = 0;
	  res = rd + ea;
	  goto alu16;

	case O (O_NEG, SL):		/* neg.l */
	  /* Fetch ea.  */
	  if (fetch2 (sd, &code->src, &ea)) 
	    goto end;
	  ea = -ea;
	  rd = 0;
	  res = rd + ea;
	  goto alu32;

	case O (O_ADD, SB):		/* add.b */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  res = rd + ea;
	  goto alu8;

	case O (O_ADD, SW):		/* add.w */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  res = rd + ea;
	  goto alu16;

	case O (O_ADD, SL):		/* add.l */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  res = rd + ea;
	  goto alu32;

	case O (O_AND, SB):		/* and.b */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd & ea;
	  goto log8;

	case O (O_AND, SW):		/* and.w */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd & ea;
	  goto log16;

	case O (O_AND, SL):		/* and.l */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd & ea;
	  goto log32;

	case O (O_OR, SB):		/* or.b */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd | ea;
	  goto log8;

	case O (O_OR, SW):		/* or.w */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd | ea;
	  goto log16;

	case O (O_OR, SL):		/* or.l */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd | ea;
	  goto log32;

	case O (O_XOR, SB):		/* xor.b */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd ^ ea;
	  goto log8;

	case O (O_XOR, SW):		/* xor.w */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd ^ ea;
	  goto log16;

	case O (O_XOR, SL):		/* xor.l */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd ^ ea;
	  goto log32;

	case O (O_MOV, SB):
	  if (fetch (sd, &code->src, &res))
	    goto end;
	  if (store (sd, &code->dst, res))
	    goto end;
	  goto just_flags_log8;
	case O (O_MOV, SW):
	  if (fetch (sd, &code->src, &res))
	    goto end;
	  if (store (sd, &code->dst, res))
	    goto end;
	  goto just_flags_log16;
	case O (O_MOV, SL):
	  if (fetch (sd, &code->src, &res))
	    goto end;
	  if (store (sd, &code->dst, res))
	    goto end;
	  goto just_flags_log32;

	case O (O_MOVMD, SB):		/* movmd.b */
	  ea = GET_W_REG (4);
	  if (ea == 0)
	    ea = 0x10000;

	  while (ea--)
	    {
	      rd = GET_MEMORY_B (GET_L_REG (5));
	      SET_MEMORY_B (GET_L_REG (6), rd);
	      SET_L_REG (5, GET_L_REG (5) + 1);
	      SET_L_REG (6, GET_L_REG (6) + 1);
	      SET_W_REG (4, ea);
	    }
	  goto next;

	case O (O_MOVMD, SW):		/* movmd.w */
	  ea = GET_W_REG (4);
	  if (ea == 0)
	    ea = 0x10000;

	  while (ea--)
	    {
	      rd = GET_MEMORY_W (GET_L_REG (5));
	      SET_MEMORY_W (GET_L_REG (6), rd);
	      SET_L_REG (5, GET_L_REG (5) + 2);
	      SET_L_REG (6, GET_L_REG (6) + 2);
	      SET_W_REG (4, ea);
	    }
	  goto next;

	case O (O_MOVMD, SL):		/* movmd.l */
	  ea = GET_W_REG (4);
	  if (ea == 0)
	    ea = 0x10000;

	  while (ea--)
	    {
	      rd = GET_MEMORY_L (GET_L_REG (5));
	      SET_MEMORY_L (GET_L_REG (6), rd);
	      SET_L_REG (5, GET_L_REG (5) + 4);
	      SET_L_REG (6, GET_L_REG (6) + 4);
	      SET_W_REG (4, ea);
	    }
	  goto next;

	case O (O_MOVSD, SB):		/* movsd.b */
	  /* This instruction implements strncpy, with a conditional branch.
	     r4 contains n, r5 contains src, and r6 contains dst.
	     The 16-bit displacement operand is added to the pc
	     if and only if the end of string is reached before
	     n bytes are transferred.  */

	  ea = GET_L_REG (4) & 0xffff;
	  if (ea == 0)
	    ea = 0x10000;

	  while (ea--)
	    {
	      rd = GET_MEMORY_B (GET_L_REG (5));
	      SET_MEMORY_B (GET_L_REG (6), rd);
	      SET_L_REG (5, GET_L_REG (5) + 1);
	      SET_L_REG (6, GET_L_REG (6) + 1);
	      SET_W_REG (4, ea); 
	      if (rd == 0)
		goto condtrue;
	    }
	  goto next;

	case O (O_EEPMOV, SB):		/* eepmov.b */
	case O (O_EEPMOV, SW):		/* eepmov.w */
	  if (h8300hmode || h8300smode)
	    {
	      register unsigned char *_src, *_dst;
	      unsigned int count = ((code->opcode == O (O_EEPMOV, SW))
				    ? h8_get_reg (sd, R4_REGNUM) & 0xffff
				    : h8_get_reg (sd, R4_REGNUM) & 0xff);

	      _src = (h8_get_reg (sd, R5_REGNUM) < memory_size
		      ? h8_get_memory_buf   (sd) + h8_get_reg (sd, R5_REGNUM)
		      : h8_get_eightbit_buf (sd) + 
		       (h8_get_reg (sd, R5_REGNUM) & 0xff));
	      if ((_src + count) >= (h8_get_memory_buf (sd) + memory_size))
		{
		  if ((_src + count) >= (h8_get_eightbit_buf (sd) + 0x100))
		    goto illegal;
		}
	      _dst = (h8_get_reg (sd, R6_REGNUM) < memory_size
		      ? h8_get_memory_buf   (sd) + h8_get_reg (sd, R6_REGNUM)
		      : h8_get_eightbit_buf (sd) + 
		       (h8_get_reg (sd, R6_REGNUM) & 0xff));

	      if ((_dst + count) >= (h8_get_memory_buf (sd) + memory_size))
		{
		  if ((_dst + count) >= (h8_get_eightbit_buf (sd) + 0x100))
		    goto illegal;
		}
	      memcpy (_dst, _src, count);

	      h8_set_reg (sd, R5_REGNUM, h8_get_reg (sd, R5_REGNUM) + count);
	      h8_set_reg (sd, R6_REGNUM, h8_get_reg (sd, R6_REGNUM) + count);
	      h8_set_reg (sd, R4_REGNUM, h8_get_reg (sd, R4_REGNUM) &
			  ((code->opcode == O (O_EEPMOV, SW))
			  ? (~0xffff) : (~0xff)));
	      cycles += 2 * count;
	      goto next;
	    }
	  goto illegal;

	case O (O_ADDS, SL):		/* adds (.l) */
	  /* FIXME fetch.
	   * This insn only uses register operands, but still
	   * it would be cleaner to use fetch and store...  */	  
	  SET_L_REG (code->dst.reg,
		     GET_L_REG (code->dst.reg)
		     + code->src.literal);

	  goto next;

	case O (O_SUBS, SL):		/* subs (.l) */
	  /* FIXME fetch.
	   * This insn only uses register operands, but still
	   * it would be cleaner to use fetch and store...  */	  
	  SET_L_REG (code->dst.reg,
		     GET_L_REG (code->dst.reg)
		     - code->src.literal);
	  goto next;

	case O (O_CMP, SB):		/* cmp.b */
	  if (fetch (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = -ea;
	  res = rd + ea;
	  goto just_flags_alu8;

	case O (O_CMP, SW):		/* cmp.w */
	  if (fetch (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = -ea;
	  res = rd + ea;
	  goto just_flags_alu16;

	case O (O_CMP, SL):		/* cmp.l */
	  if (fetch (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = -ea;
	  res = rd + ea;
	  goto just_flags_alu32;

	case O (O_DEC, SB):		/* dec.b */
	  /* FIXME fetch.
	   * This insn only uses register operands, but still
	   * it would be cleaner to use fetch and store...  */	  
	  rd = GET_B_REG (code->src.reg);
	  ea = -1;
	  res = rd + ea;
	  SET_B_REG (code->src.reg, res);
	  goto just_flags_inc8;

	case O (O_DEC, SW):		/* dec.w */
	  /* FIXME fetch.
	   * This insn only uses register operands, but still
	   * it would be cleaner to use fetch and store...  */	  
	  rd = GET_W_REG (code->dst.reg);
	  ea = -code->src.literal;
	  res = rd + ea;
	  SET_W_REG (code->dst.reg, res);
	  goto just_flags_inc16;

	case O (O_DEC, SL):		/* dec.l */
	  /* FIXME fetch.
	   * This insn only uses register operands, but still
	   * it would be cleaner to use fetch and store...  */	  
	  rd = GET_L_REG (code->dst.reg);
	  ea = -code->src.literal;
	  res = rd + ea;
	  SET_L_REG (code->dst.reg, res);
	  goto just_flags_inc32;

	case O (O_INC, SB):		/* inc.b */
	  /* FIXME fetch.
	   * This insn only uses register operands, but still
	   * it would be cleaner to use fetch and store...  */	  
	  rd = GET_B_REG (code->src.reg);
	  ea = 1;
	  res = rd + ea;
	  SET_B_REG (code->src.reg, res);
	  goto just_flags_inc8;

	case O (O_INC, SW):		/* inc.w */
	  /* FIXME fetch.
	   * This insn only uses register operands, but still
	   * it would be cleaner to use fetch and store...  */	  
	  rd = GET_W_REG (code->dst.reg);
	  ea = code->src.literal;
	  res = rd + ea;
	  SET_W_REG (code->dst.reg, res);
	  goto just_flags_inc16;

	case O (O_INC, SL):		/* inc.l */
	  /* FIXME fetch.
	   * This insn only uses register operands, but still
	   * it would be cleaner to use fetch and store...  */	  
	  rd = GET_L_REG (code->dst.reg);
	  ea = code->src.literal;
	  res = rd + ea;
	  SET_L_REG (code->dst.reg, res);
	  goto just_flags_inc32;

	case O (O_LDC, SB):		/* ldc.b */
	  if (fetch (sd, &code->src, &res))
	    goto end;
	  goto setc;

	case O (O_LDC, SW):		/* ldc.w */
	  if (fetch (sd, &code->src, &res))
	    goto end;

	  /* Word operand, value from MSB, must be shifted.  */
	  res >>= 8;
	  goto setc;

	case O (O_LDC, SL):		/* ldc.l */
	  if (fetch (sd, &code->src, &res))
	    goto end;
	  switch (code->dst.type) {
	  case X (OP_SBR, SL):
	    h8_set_sbr (sd, res);
	    break;
	  case X (OP_VBR, SL):
	    h8_set_vbr (sd, res);
	    break;
	  default:
	    goto illegal;
	  }
	  goto next;

	case O (O_STC, SW):		/* stc.w */
	case O (O_STC, SB):		/* stc.b */
	  if (code->src.type == X (OP_CCR, SB))
	    {
	      BUILDSR (sd);
	      res = h8_get_ccr (sd);
	    }
	  else if (code->src.type == X (OP_EXR, SB) && h8300smode)
	    {
	      if (h8300smode)
		h8_set_exr (sd, (trace << 7) | intMask);
	      res = h8_get_exr (sd);
	    }
	  else
	    goto illegal;

	  /* Word operand, value to MSB, must be shifted.  */
	  if (code->opcode == X (O_STC, SW))
	    res <<= 8;
	  if (store (sd, &code->dst, res))
	    goto end;
	  goto next;
	case O (O_STC, SL):		/* stc.l */
	  switch (code->src.type) {
	  case X (OP_SBR, SL):
	    res = h8_get_sbr (sd);
	    break;
	  case X (OP_VBR, SL):
	    res = h8_get_vbr (sd);
	    break;
	  default:
	    goto illegal;
	  }
	  if (store (sd, &code->dst, res))
	    goto end;
	  goto next;

	case O (O_ANDC, SB):		/* andc.b */
	  if (code->dst.type == X (OP_CCR, SB))
	    {
	      BUILDSR (sd);
	      rd = h8_get_ccr (sd);
	    }
	  else if (code->dst.type == X (OP_EXR, SB) && h8300smode)
	    {
	      if (h8300smode)
		h8_set_exr (sd, (trace << 7) | intMask);
	      rd = h8_get_exr (sd);
	    }
	  else
	    goto illegal;
	  ea = code->src.literal;
	  res = rd & ea;
	  goto setc;

	case O (O_ORC, SB):		/* orc.b */
	  if (code->dst.type == X (OP_CCR, SB))
	    {
	      BUILDSR (sd);
	      rd = h8_get_ccr (sd);
	    }
	  else if (code->dst.type == X (OP_EXR, SB) && h8300smode)
	    {
	      if (h8300smode)
		h8_set_exr (sd, (trace << 7) | intMask);
	      rd = h8_get_exr (sd);
	    }
	  else
	    goto illegal;
	  ea = code->src.literal;
	  res = rd | ea;
	  goto setc;

	case O (O_XORC, SB):		/* xorc.b */
	  if (code->dst.type == X (OP_CCR, SB))
	    {
	      BUILDSR (sd);
	      rd = h8_get_ccr (sd);
	    }
	  else if (code->dst.type == X (OP_EXR, SB) && h8300smode)
	    {
	      if (h8300smode)
		h8_set_exr (sd, (trace << 7) | intMask);
	      rd = h8_get_exr (sd);
	    }
	  else
	    goto illegal;
	  ea = code->src.literal;
	  res = rd ^ ea;
	  goto setc;

	case O (O_BRAS, SB):		/* bra/s  */
	  /* This is basically an ordinary branch, with a delay slot.  */
	  if (fetch (sd, &code->src, &res))
	    goto end;

	  if ((res & 1) == 0)
	    goto illegal;

	  res -= 1;

	  /* Execution continues at next instruction, but
	     delayed_branch is set up for next cycle.  */
	  h8_set_delayed_branch (sd, code->next_pc + res);
	  pc = code->next_pc;
	  goto end;

	case O (O_BRAB, SB):		/* bra rd.b */
	case O (O_BRAW, SW):		/* bra rd.w */
	case O (O_BRAL, SL):		/* bra erd.l */
	  if (fetch (sd, &code->src, &rd))
	    goto end;
	  switch (OP_SIZE (code->opcode)) {
	  case SB:	rd &= 0xff;		break;
	  case SW:	rd &= 0xffff;		break;
	  case SL:	rd &= 0xffffffff;	break;
	  }
	  pc = code->next_pc + rd;
	  goto end;

	case O (O_BRABC, SB):		/* bra/bc, branch if bit clear */
	case O (O_BRABS, SB):		/* bra/bs, branch if bit set   */
	case O (O_BSRBC, SB):		/* bsr/bc, call   if bit clear */
	case O (O_BSRBS, SB):		/* bsr/bs, call   if bit set   */
	  if (fetch (sd, &code->dst, &rd) ||
	      fetch (sd, &code->src, &bit))
	    goto end;

	  if (code->opcode == O (O_BRABC, SB) || /* branch if clear */
	      code->opcode == O (O_BSRBC, SB))	 /* call   if clear */
	    {
	      if ((rd & (1 << bit)))		/* no branch */
		goto next;
	    }
	  else					/* branch/call if set */
	    {
	      if (!(rd & (1 << bit)))		/* no branch */
		goto next;
	    }

	  if (fetch (sd, &code->op3, &res))	/* branch */
	    goto end;
	  pc = code->next_pc + res;

	  if (code->opcode == O (O_BRABC, SB) ||
	      code->opcode == O (O_BRABS, SB))	/* branch */
	    goto end;
	  else					/* call   */
	    goto call;

	case O (O_BRA, SN):
	case O (O_BRA, SL):
	case O (O_BRA, SW):
	case O (O_BRA, SB):		/* bra, branch always */
	  if (1)
	    goto condtrue;
	  goto next;

	case O (O_BRN, SB):		/* brn, ;-/  branch never? */
	  if (0)
	    goto condtrue;
	  goto next;

	case O (O_BHI, SB):		/* bhi */
	  if ((C || Z) == 0)
	    goto condtrue;
	  goto next;


	case O (O_BLS, SB):		/* bls */
	  if ((C || Z))
	    goto condtrue;
	  goto next;

	case O (O_BCS, SB):		/* bcs, branch if carry set */
	  if ((C == 1))
	    goto condtrue;
	  goto next;

	case O (O_BCC, SB):		/* bcc, branch if carry clear */
	  if ((C == 0))
	    goto condtrue;
	  goto next;

	case O (O_BEQ, SB):		/* beq, branch if zero set */
	  if (Z)
	    goto condtrue;
	  goto next;
	case O (O_BGT, SB):		/* bgt */
	  if (((Z || (N ^ V)) == 0))
	    goto condtrue;
	  goto next;

	case O (O_BLE, SB):		/* ble */
	  if (((Z || (N ^ V)) == 1))
	    goto condtrue;
	  goto next;

	case O (O_BGE, SB):		/* bge */
	  if ((N ^ V) == 0)
	    goto condtrue;
	  goto next;
	case O (O_BLT, SB):		/* blt */
	  if ((N ^ V))
	    goto condtrue;
	  goto next;
	case O (O_BMI, SB):		/* bmi */
	  if ((N))
	    goto condtrue;
	  goto next;
	case O (O_BNE, SB):		/* bne, branch if zero clear */
	  if ((Z == 0))
	    goto condtrue;
	  goto next;

	case O (O_BPL, SB):		/* bpl */
	  if (N == 0)
	    goto condtrue;
	  goto next;
	case O (O_BVC, SB):		/* bvc */
	  if ((V == 0))
	    goto condtrue;
	  goto next;
	case O (O_BVS, SB):		/* bvs */
	  if ((V == 1))
	    goto condtrue;
	  goto next;

	/* Trap for Command Line setup.  */
	case O (O_SYS_CMDLINE, SB):
	  {
	    int i = 0;		/* Loop counter.  */
	    int j = 0;		/* Loop counter.  */
	    int ind_arg_len = 0;	/* Length of each argument.  */
	    int no_of_args = 0;	/* The no. or cmdline args.  */
	    int current_location = 0;	/* Location of string.  */
	    int old_sp = 0;	/* The Initial Stack Pointer.  */
	    int no_of_slots = 0;	/* No. of slots required on the stack
					   for storing cmdline args.  */
	    int sp_move = 0;	/* No. of locations by which the stack needs
				   to grow.  */
	    int new_sp = 0;	/* The final stack pointer location passed
				   back.  */
	    int *argv_ptrs;	/* Pointers of argv strings to be stored.  */
	    int argv_ptrs_location = 0;	/* Location of pointers to cmdline
					   args on the stack.  */
	    int char_ptr_size = 0;	/* Size of a character pointer on
					   target machine.  */
	    int addr_cmdline = 0;	/* Memory location where cmdline has
					   to be stored.  */
	    int size_cmdline = 0;	/* Size of cmdline.  */

	    /* Set the address of 256 free locations where command line is
	       stored.  */
	    addr_cmdline = cmdline_location();
	    h8_set_reg (sd, 0, addr_cmdline);

	    /* Counting the no. of commandline arguments.  */
	    for (i = 0; h8_get_cmdline_arg (sd, i) != NULL; i++)
	      continue;

	    /* No. of arguments in the command line.  */
	    no_of_args = i;

	    /* Current location is just a temporary variable,which we are
	       setting to the point to the start of our commandline string.  */
	    current_location = addr_cmdline;

	    /* Allocating space for storing pointers of the command line
	       arguments.  */
	    argv_ptrs = (int *) malloc (sizeof (int) * no_of_args);

	    /* Setting char_ptr_size to the sizeof (char *) on the different
	       architectures.  */
	    if ((h8300hmode || h8300smode) && !h8300_normal_mode)
	      {
		char_ptr_size = 4;
	      }
	    else
	      {
		char_ptr_size = 2;
	      }

	    for (i = 0; i < no_of_args; i++)
	      {
		ind_arg_len = 0;

		/* The size of the commandline argument.  */
		ind_arg_len = strlen (h8_get_cmdline_arg (sd, i)) + 1;

		/* The total size of the command line string.  */
		size_cmdline += ind_arg_len;

		/* As we have only 256 bytes, we need to provide a graceful
		   exit. Anyways, a program using command line arguments 
		   where we cannot store all the command line arguments
		   given may behave unpredictably.  */
		if (size_cmdline >= 256)
		  {
		    h8_set_reg (sd, 0, 0);
		    goto next;
		  }
		else
		  {
		    /* current_location points to the memory where the next
		       commandline argument is stored.  */
		    argv_ptrs[i] = current_location;
		    for (j = 0; j < ind_arg_len; j++)
		      {
			SET_MEMORY_B ((current_location +
				       (sizeof (char) * j)),
				      *(h8_get_cmdline_arg (sd, i) + 
				       sizeof (char) * j));
		      }

		    /* Setting current_location to the starting of next
		       argument.  */
		    current_location += ind_arg_len;
		  }
	      }

	    /* This is the original position of the stack pointer.  */
	    old_sp = h8_get_reg (sd, SP_REGNUM);

	    /* We need space from the stack to store the pointers to argvs.  */
	    /* As we will infringe on the stack, we need to shift the stack
	       pointer so that the data is not overwritten. We calculate how
	       much space is required.  */
	    sp_move = (no_of_args) * (char_ptr_size);

	    /* The final position of stack pointer, we have thus taken some
	       space from the stack.  */
	    new_sp = old_sp - sp_move;

	    /* Temporary variable holding value where the argv pointers need
	       to be stored.  */
	    argv_ptrs_location = new_sp;

	    /* The argv pointers are stored at sequential locations. As per
	       the H8300 ABI.  */
	    for (i = 0; i < no_of_args; i++)
	      {
		/* Saving the argv pointer.  */
		if ((h8300hmode || h8300smode) && !h8300_normal_mode)
		  {
		    SET_MEMORY_L (argv_ptrs_location, argv_ptrs[i]);
		  }
		else
		  {
		    SET_MEMORY_W (argv_ptrs_location, argv_ptrs[i]);
		  }
	
		/* The next location where the pointer to the next argv
		   string has to be stored.  */    
		argv_ptrs_location += char_ptr_size;
	      }

	    /* Required by POSIX, Setting 0x0 at the end of the list of argv
	       pointers.  */
	    if ((h8300hmode || h8300smode) && !h8300_normal_mode)
	      {
		SET_MEMORY_L (old_sp, 0x0);
	      }
	    else
	      {
		SET_MEMORY_W (old_sp, 0x0);
	      }

	    /* Freeing allocated memory.  */
	    free (argv_ptrs);
	    for (i = 0; i <= no_of_args; i++)
	      {
		free (h8_get_cmdline_arg (sd, i));
	      }
	    free (h8_get_command_line (sd));

	    /* The no. of argv arguments are returned in Reg 0.  */
	    h8_set_reg (sd, 0, no_of_args);
	    /* The Pointer to argv in Register 1.  */
	    h8_set_reg (sd, 1, new_sp);
	    /* Setting the stack pointer to the new value.  */
	    h8_set_reg (sd, SP_REGNUM, new_sp);
	  }
	  goto next;

	  /* System call processing starts.  */
	case O (O_SYS_OPEN, SB):
	  {
	    int len = 0;	/* Length of filename.  */
	    char *filename;	/* Filename would go here.  */
	    char temp_char;	/* Temporary character */
	    int mode = 0;	/* Mode bits for the file.  */
	    int open_return;	/* Return value of open, file descriptor.  */
	    int i;		/* Loop counter */
	    int filename_ptr;	/* Pointer to filename in cpu memory.  */

	    /* Setting filename_ptr to first argument of open,  */
	    /* and trying to get mode.  */
	    if ((h8300sxmode || h8300hmode || h8300smode) && !h8300_normal_mode)
	      {
		filename_ptr = GET_L_REG (0);
		mode = GET_MEMORY_L (h8_get_reg (sd, SP_REGNUM) + 4);
	      }
	    else
	      {
		filename_ptr = GET_W_REG (0);
		mode = GET_MEMORY_W (h8_get_reg (sd, SP_REGNUM) + 2);
	      }

	    /* Trying to find the length of the filename.  */
	    temp_char = GET_MEMORY_B (h8_get_reg (sd, 0));

	    len = 1;
	    while (temp_char != '\0')
	      {
		temp_char = GET_MEMORY_B (filename_ptr + len);
		len++;
	      }

	    /* Allocating space for the filename.  */
	    filename = (char *) malloc (sizeof (char) * len);

	    /* String copying the filename from memory.  */
	    for (i = 0; i < len; i++)
	      {
		temp_char = GET_MEMORY_B (filename_ptr + i);
		filename[i] = temp_char;
	      }

	    /* Callback to open and return the file descriptor.  */
	    open_return = sim_callback->open (sim_callback, filename, mode);

	    /* Return value in register 0.  */
	    h8_set_reg (sd, 0, open_return);

	    /* Freeing memory used for filename. */
	    free (filename);
	  }
	  goto next;

	case O (O_SYS_READ, SB):
	  {
	    char *char_ptr;	/* Where characters read would be stored.  */
	    int fd;		/* File descriptor */
	    int buf_size;	/* BUF_SIZE parameter in read.  */
	    int i = 0;		/* Temporary Loop counter */
	    int read_return = 0;	/* Return value from callback to
					   read.  */

	    fd = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (0) : GET_W_REG (0);
	    buf_size = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (2) : GET_W_REG (2);

	    char_ptr = (char *) malloc (sizeof (char) * buf_size);

	    /* Callback to read and return the no. of characters read.  */
	    read_return =
	      sim_callback->read (sim_callback, fd, char_ptr, buf_size);

	    /* The characters read are stored in cpu memory.  */
	    for (i = 0; i < buf_size; i++)
	      {
		SET_MEMORY_B ((h8_get_reg (sd, 1) + (sizeof (char) * i)),
			      *(char_ptr + (sizeof (char) * i)));
	      }

	    /* Return value in Register 0.  */
	    h8_set_reg (sd, 0, read_return);

	    /* Freeing memory used as buffer.  */
	    free (char_ptr);
	  }
	  goto next;

	case O (O_SYS_WRITE, SB):
	  {
	    int fd;		/* File descriptor */
	    char temp_char;	/* Temporary character */
	    int len;		/* Length of write, Parameter II to write.  */
	    int char_ptr;	/* Character Pointer, Parameter I of write.  */
	    char *ptr;		/* Where characters to be written are stored. 
				 */
	    int write_return;	/* Return value from callback to write.  */
	    int i = 0;		/* Loop counter */

	    fd = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (0) : GET_W_REG (0);
	    char_ptr = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (1) : GET_W_REG (1);
	    len = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (2) : GET_W_REG (2);

	    /* Allocating space for the characters to be written.  */
	    ptr = (char *) malloc (sizeof (char) * len);

	    /* Fetching the characters from cpu memory.  */
	    for (i = 0; i < len; i++)
	      {
		temp_char = GET_MEMORY_B (char_ptr + i);
		ptr[i] = temp_char;
	      }

	    /* Callback write and return the no. of characters written.  */
	    write_return = sim_callback->write (sim_callback, fd, ptr, len);

	    /* Return value in Register 0.  */
	    h8_set_reg (sd, 0, write_return);

	    /* Freeing memory used as buffer.  */
	    free (ptr);
	  }
	  goto next;

	case O (O_SYS_LSEEK, SB):
	  {
	    int fd;		/* File descriptor */
	    int offset;		/* Offset */
	    int origin;		/* Origin */
	    int lseek_return;	/* Return value from callback to lseek.  */

	    fd = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (0) : GET_W_REG (0);
	    offset = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (1) : GET_W_REG (1);
	    origin = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (2) : GET_W_REG (2);

	    /* Callback lseek and return offset.  */
	    lseek_return =
	      sim_callback->lseek (sim_callback, fd, offset, origin);

	    /* Return value in register 0.  */
	    h8_set_reg (sd, 0, lseek_return);
	  }
	  goto next;

	case O (O_SYS_CLOSE, SB):
	  {
	    int fd;		/* File descriptor */
	    int close_return;	/* Return value from callback to close.  */

	    fd = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (0) : GET_W_REG (0);

	    /* Callback close and return.  */
	    close_return = sim_callback->close (sim_callback, fd);

	    /* Return value in register 0.  */
	    h8_set_reg (sd, 0, close_return);
	  }
	  goto next;

	case O (O_SYS_FSTAT, SB):
	  {
	    int fd;		/* File descriptor */
	    struct stat stat_rec;	/* Stat record */
	    int fstat_return;	/* Return value from callback to stat.  */
	    int stat_ptr;	/* Pointer to stat record.  */
	    char *temp_stat_ptr;	/* Temporary stat_rec pointer.  */

	    fd = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (0) : GET_W_REG (0);

	    /* Setting stat_ptr to second argument of stat.  */
	    stat_ptr = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (1) : GET_W_REG (1);

	    /* Callback stat and return.  */
	    fstat_return = sim_callback->fstat (sim_callback, fd, &stat_rec);

	    /* Have stat_ptr point to starting of stat_rec.  */
	    temp_stat_ptr = (char *) (&stat_rec);

	    /* Setting up the stat structure returned.  */
	    SET_MEMORY_W (stat_ptr, stat_rec.st_dev);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_ino);
	    stat_ptr += 2;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_mode);
	    stat_ptr += 4;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_nlink);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_uid);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_gid);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_rdev);
	    stat_ptr += 2;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_size);
	    stat_ptr += 4;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_atime);
	    stat_ptr += 8;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_mtime);
	    stat_ptr += 8;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_ctime);

	    /* Return value in register 0.  */
	    h8_set_reg (sd, 0, fstat_return);
	  }
	  goto next;

	case O (O_SYS_STAT, SB):
	  {
	    int len = 0;	/* Length of filename.  */
	    char *filename;	/* Filename would go here.  */
	    char temp_char;	/* Temporary character */
	    int filename_ptr;	/* Pointer to filename in cpu memory.  */
	    struct stat stat_rec;	/* Stat record */
	    int stat_return;	/* Return value from callback to stat */
	    int stat_ptr;	/* Pointer to stat record.  */
	    char *temp_stat_ptr;	/* Temporary stat_rec pointer.  */
	    int i = 0;		/* Loop Counter */

	    /* Setting filename_ptr to first argument of open.  */
	    filename_ptr = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (0) : GET_W_REG (0);

	    /* Trying to find the length of the filename.  */
	    temp_char = GET_MEMORY_B (h8_get_reg (sd, 0));

	    len = 1;
	    while (temp_char != '\0')
	      {
		temp_char = GET_MEMORY_B (filename_ptr + len);
		len++;
	      }

	    /* Allocating space for the filename.  */
	    filename = (char *) malloc (sizeof (char) * len);

	    /* String copying the filename from memory.  */
	    for (i = 0; i < len; i++)
	      {
		temp_char = GET_MEMORY_B (filename_ptr + i);
		filename[i] = temp_char;
	      }

	    /* Setting stat_ptr to second argument of stat.  */
	    /* stat_ptr = h8_get_reg (sd, 1); */
	    stat_ptr = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (1) : GET_W_REG (1);

	    /* Callback stat and return.  */
	    stat_return =
	      sim_callback->stat (sim_callback, filename, &stat_rec);

	    /* Have stat_ptr point to starting of stat_rec.  */
	    temp_stat_ptr = (char *) (&stat_rec);
 
	    /* Freeing memory used for filename.  */
	    free (filename);
 
	    /* Setting up the stat structure returned.  */
	    SET_MEMORY_W (stat_ptr, stat_rec.st_dev);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_ino);
	    stat_ptr += 2;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_mode);
	    stat_ptr += 4;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_nlink);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_uid);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_gid);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_rdev);
	    stat_ptr += 2;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_size);
	    stat_ptr += 4;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_atime);
	    stat_ptr += 8;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_mtime);
	    stat_ptr += 8;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_ctime);
 
	    /* Return value in register 0.  */
	    h8_set_reg (sd, 0, stat_return);
	  }
	  goto next;
	  /* End of system call processing.  */

	case O (O_NOT, SB):		/* not.b */
	  if (fetch2 (sd, &code->src, &rd))
	    goto end;
	  rd = ~rd; 
	  v = 0;
	  goto shift8;

	case O (O_NOT, SW):		/* not.w */
	  if (fetch2 (sd, &code->src, &rd))
	    goto end;
	  rd = ~rd; 
	  v = 0;
	  goto shift16;

	case O (O_NOT, SL):		/* not.l */
	  if (fetch2 (sd, &code->src, &rd))
	    goto end;
	  rd = ~rd; 
	  v = 0;
	  goto shift32;

	case O (O_SHLL, SB):	/* shll.b */
	case O (O_SHLR, SB):	/* shlr.b */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;

	  if (memcmp (&code->src, &code->dst, sizeof (code->src)) == 0)
	    ea = 1;		/* unary  op */
	  else			/* binary op */
	    fetch (sd, &code->src, &ea);

	  if (code->opcode == O (O_SHLL, SB))
	    {
	      v = (ea > 8);
	      c = rd & (0x80 >> (ea - 1));
	      rd <<= ea;
	    }
	  else
	    {
	      v = 0;
	      c = rd & (1 << (ea - 1));
	      rd = (unsigned char) rd >> ea;
	    }
	  goto shift8;

	case O (O_SHLL, SW):	/* shll.w */
	case O (O_SHLR, SW):	/* shlr.w */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;

	  if (memcmp (&code->src, &code->dst, sizeof (code->src)) == 0)
	    ea = 1;		/* unary  op */
	  else
	    fetch (sd, &code->src, &ea);

	  if (code->opcode == O (O_SHLL, SW))
	    {
	      v = (ea > 16);
	      c = rd & (0x8000 >> (ea - 1));
	      rd <<= ea;
	    }
	  else
	    {
	      v = 0;
	      c = rd & (1 << (ea - 1));
	      rd = (unsigned short) rd >> ea;
	    }
	  goto shift16;

	case O (O_SHLL, SL):	/* shll.l */
	case O (O_SHLR, SL):	/* shlr.l */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;

	  if (memcmp (&code->src, &code->dst, sizeof (code->src)) == 0)
	    ea = 1;		/* unary  op */
	  else
	    fetch (sd, &code->src, &ea);

	  if (code->opcode == O (O_SHLL, SL))
	    {
	      v = (ea > 32);
	      c = rd & (0x80000000 >> (ea - 1));
	      rd <<= ea;
	    }
	  else
	    {
	      v = 0;
	      c = rd & (1 << (ea - 1));
	      rd = (unsigned int) rd >> ea;
	    }
	  goto shift32;

	case O (O_SHAL, SB):
	case O (O_SHAR, SB):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;

	  if (code->src.type == X (OP_IMM, SB))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;

	  if (code->opcode == O (O_SHAL, SB))
	    {
	      c = rd & (0x80 >> (ea - 1));
	      res = rd >> (7 - ea);
	      v = ((res & 1) && !(res & 2)) 
		|| (!(res & 1) && (res & 2));
	      rd <<= ea;
	    }
	  else
	    {
	      c = rd & (1 << (ea - 1));
	      v = 0;
	      rd = ((signed char) rd) >> ea;
	    }
	  goto shift8;

	case O (O_SHAL, SW):
	case O (O_SHAR, SW):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;

	  if (code->src.type == X (OP_IMM, SW))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;

	  if (code->opcode == O (O_SHAL, SW))
	    {
	      c = rd & (0x8000 >> (ea - 1));
	      res = rd >> (15 - ea);
	      v = ((res & 1) && !(res & 2)) 
		|| (!(res & 1) && (res & 2));
	      rd <<= ea;
	    }
	  else
	    {
	      c = rd & (1 << (ea - 1));
	      v = 0;
	      rd = ((signed short) rd) >> ea;
	    }
	  goto shift16;

	case O (O_SHAL, SL):
	case O (O_SHAR, SL):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;

	  if (code->src.type == X (OP_IMM, SL))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;

	  if (code->opcode == O (O_SHAL, SL))
	    {
	      c = rd & (0x80000000 >> (ea - 1));
	      res = rd >> (31 - ea);
	      v = ((res & 1) && !(res & 2)) 
		|| (!(res & 1) && (res & 2));
	      rd <<= ea;
	    }
	  else
	    {
	      c = rd & (1 << (ea - 1));
	      v = 0;
	      rd = ((signed int) rd) >> ea;
	    }
	  goto shift32;

	case O (O_ROTL, SB):
	case O (O_ROTR, SB):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;

	  if (code->src.type == X (OP_IMM, SB))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;

	  while (ea--)
	    if (code->opcode == O (O_ROTL, SB))
	      {
		c = rd & 0x80;
		rd <<= 1;
		if (c)
		  rd |= 1;
	      }
	    else
	      {
		c = rd & 1;
		rd = ((unsigned char) rd) >> 1;
		if (c)
		  rd |= 0x80;
	      }

	  v = 0;
	  goto shift8;

	case O (O_ROTL, SW):
	case O (O_ROTR, SW):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;

	  if (code->src.type == X (OP_IMM, SW))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;

	  while (ea--)
	    if (code->opcode == O (O_ROTL, SW))
	      {
		c = rd & 0x8000;
		rd <<= 1;
		if (c)
		  rd |= 1;
	      }
	    else
	      {
		c = rd & 1;
		rd = ((unsigned short) rd) >> 1;
		if (c)
		  rd |= 0x8000;
	      }

	  v = 0;
	  goto shift16;

	case O (O_ROTL, SL):
	case O (O_ROTR, SL):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;

	  if (code->src.type == X (OP_IMM, SL))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;

	  while (ea--)
	    if (code->opcode == O (O_ROTL, SL))
	      {
		c = rd & 0x80000000;
		rd <<= 1;
		if (c)
		  rd |= 1;
	      }
	    else
	      {
		c = rd & 1;
		rd = ((unsigned int) rd) >> 1;
		if (c)
		  rd |= 0x80000000;
	      }

	  v = 0;
	  goto shift32;

	case O (O_ROTXL, SB):
	case O (O_ROTXR, SB):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;

	  if (code->src.type == X (OP_IMM, SB))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;

	  while (ea--)
	    if (code->opcode == O (O_ROTXL, SB))
	      {
		res = rd & 0x80;
		rd <<= 1;
		if (C)
		  rd |= 1;
		c = res;
	      }
	    else
	      {
		res = rd & 1;
		rd = ((unsigned char) rd) >> 1;
		if (C)
		  rd |= 0x80;
		c = res;
	      }

	  v = 0;
	  goto shift8;

	case O (O_ROTXL, SW):
	case O (O_ROTXR, SW):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;

	  if (code->src.type == X (OP_IMM, SW))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;

	  while (ea--)
	    if (code->opcode == O (O_ROTXL, SW))
	      {
		res = rd & 0x8000;
		rd <<= 1;
		if (C)
		  rd |= 1;
		c = res;
	      }
	    else
	      {
		res = rd & 1;
		rd = ((unsigned short) rd) >> 1;
		if (C)
		  rd |= 0x8000;
		c = res;
	      }

	  v = 0;
	  goto shift16;

	case O (O_ROTXL, SL):
	case O (O_ROTXR, SL):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;

	  if (code->src.type == X (OP_IMM, SL))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;

	  while (ea--)
	    if (code->opcode == O (O_ROTXL, SL))
	      {
		res = rd & 0x80000000;
		rd <<= 1;
		if (C)
		  rd |= 1;
		c = res;
	      }
	    else
	      {
		res = rd & 1;
		rd = ((unsigned int) rd) >> 1;
		if (C)
		  rd |= 0x80000000;
		c = res;
	      }

	  v = 0;
	  goto shift32;

        case O (O_JMP, SN):
        case O (O_JMP, SL):
        case O (O_JMP, SB):		/* jmp */
        case O (O_JMP, SW):
	  fetch (sd, &code->src, &pc);
	  goto end;

	case O (O_JSR, SN):
	case O (O_JSR, SL):
	case O (O_JSR, SB):		/* jsr, jump to subroutine */
	case O (O_JSR, SW):
	  if (fetch (sd, &code->src, &pc))
	    goto end;
	call:
	  tmp = h8_get_reg (sd, SP_REGNUM);

	  if (h8300hmode && !h8300_normal_mode)
	    {
	      tmp -= 4;
	      SET_MEMORY_L (tmp, code->next_pc);
	    }
	  else
	    {
	      tmp -= 2;
	      SET_MEMORY_W (tmp, code->next_pc);
	    }
	  h8_set_reg (sd, SP_REGNUM, tmp);

	  goto end;

	case O (O_BSR, SW):
	case O (O_BSR, SL):
	case O (O_BSR, SB):		/* bsr, branch to subroutine */
	  if (fetch (sd, &code->src, &res))
	    goto end;
	  pc = code->next_pc + res;
	  goto call;

	case O (O_RTE, SN):		/* rte, return from exception */
	rte:
	  /* Pops exr and ccr before pc -- otherwise identical to rts.  */
	  tmp = h8_get_reg (sd, SP_REGNUM);

	  if (h8300smode)			/* pop exr */
	    {
	      h8_set_exr (sd, GET_MEMORY_L (tmp));
	      tmp += 4;
	    }
	  if (h8300hmode && !h8300_normal_mode)
	    {
	      h8_set_ccr (sd, GET_MEMORY_L (tmp));
	      tmp += 4;
	      pc = GET_MEMORY_L (tmp);
	      tmp += 4;
	    }
	  else
	    {
	      h8_set_ccr (sd, GET_MEMORY_W (tmp));
	      tmp += 2;
	      pc = GET_MEMORY_W (tmp);
	      tmp += 2;
	    }

	  GETSR (sd);
	  h8_set_reg (sd, SP_REGNUM, tmp);
	  goto end;

	case O (O_RTS, SN):		/* rts, return from subroutine */
	rts:
	  tmp = h8_get_reg (sd, SP_REGNUM);

	  if (h8300hmode && !h8300_normal_mode)
	    {
	      pc = GET_MEMORY_L (tmp);
	      tmp += 4;
	    }
	  else
	    {
	      pc = GET_MEMORY_W (tmp);
	      tmp += 2;
	    }

	  h8_set_reg (sd, SP_REGNUM, tmp);
	  goto end;

	case O (O_ILL, SB):		/* illegal */
	  sim_engine_set_run_state (sd, sim_stopped, SIGILL);
	  goto end;

	case O (O_SLEEP, SN):		/* sleep */
	  /* Check for magic numbers in r1 and r2.  */
	  if ((h8_get_reg (sd, R1_REGNUM) & 0xffff) == LIBC_EXIT_MAGIC1 &&
	      (h8_get_reg (sd, R2_REGNUM) & 0xffff) == LIBC_EXIT_MAGIC2 &&
	      SIM_WIFEXITED (h8_get_reg (sd, 0)))
	    {
	      /* This trap comes from _exit, not from gdb.  */
	      sim_engine_set_run_state (sd, sim_exited, 
					SIM_WEXITSTATUS (h8_get_reg (sd, 0)));
	    }
#if 0
	  /* Unfortunately this won't really work, because
	     when we take a breakpoint trap, R0 has a "random", 
	     user-defined value.  Don't see any immediate solution.  */
	  else if (SIM_WIFSTOPPED (h8_get_reg (sd, 0)))
	    {
	      /* Pass the stop signal up to gdb.  */
	      sim_engine_set_run_state (sd, sim_stopped, 
					SIM_WSTOPSIG (h8_get_reg (sd, 0)));
	    }
#endif
	  else
	    {
	      /* Treat it as a sigtrap.  */
	      sim_engine_set_run_state (sd, sim_stopped, SIGTRAP);
	    }
	  goto end;

	case O (O_TRAPA, SB):		/* trapa */
	  if (fetch (sd, &code->src, &res))
   	    goto end;			/* res is vector number.  */
  
   	  tmp = h8_get_reg (sd, SP_REGNUM);
   	  if(h8300_normal_mode)
   	    {
   	      tmp -= 2;
   	      SET_MEMORY_W (tmp, code->next_pc);
   	      tmp -= 2;
   	      SET_MEMORY_W (tmp, h8_get_ccr (sd));
   	    }
   	  else
   	    {
   	      tmp -= 4;
   	      SET_MEMORY_L (tmp, code->next_pc);
   	      tmp -= 4;
   	      SET_MEMORY_L (tmp, h8_get_ccr (sd));
   	    }
   	  intMaskBit = 1;
   	  BUILDSR (sd);
 
	  if (h8300smode)
	    {
	      tmp -= 4;
	      SET_MEMORY_L (tmp, h8_get_exr (sd));
	    }

	  h8_set_reg (sd, SP_REGNUM, tmp);

	  if(h8300_normal_mode)
	    pc = GET_MEMORY_L (0x10 + res * 2); /* Vector addresses are 0x10,0x12,0x14 and 0x16 */
	  else
	    pc = GET_MEMORY_L (0x20 + res * 4);
	  goto end;

	case O (O_BPT, SN):
	  sim_engine_set_run_state (sd, sim_stopped, SIGTRAP);
	  goto end;

	case O (O_BSETEQ, SB):
	  if (Z)
	    goto bset;
	  goto next;

	case O (O_BSETNE, SB):
	  if (!Z)
	    goto bset;
	  goto next;

	case O (O_BCLREQ, SB):
	  if (Z)
	    goto bclr;
	  goto next;

	case O (O_BCLRNE, SB):
	  if (!Z)
	    goto bclr;
	  goto next;

	  OBITOP (O_BNOT, 1, 1, ea ^= m);		/* bnot */
	  OBITOP (O_BTST, 1, 0, nz = ea & m);		/* btst */
	bset:
	  OBITOP (O_BSET, 1, 1, ea |= m);		/* bset */
	bclr:
	  OBITOP (O_BCLR, 1, 1, ea &= ~m);		/* bclr */
	  OBITOP (O_BLD, 1, 0, c = ea & m);		/* bld  */
	  OBITOP (O_BILD, 1, 0, c = !(ea & m));		/* bild */
	  OBITOP (O_BST, 1, 1, ea &= ~m;
		  if (C) ea |= m);			/* bst  */
	  OBITOP (O_BIST, 1, 1, ea &= ~m;
		  if (!C) ea |= m);			/* bist */
	  OBITOP (O_BSTZ, 1, 1, ea &= ~m;
		  if (Z) ea |= m);			/* bstz */
	  OBITOP (O_BISTZ, 1, 1, ea &= ~m;
		  if (!Z) ea |= m);			/* bistz */
	  OBITOP (O_BAND, 1, 0, c = (ea & m) && C);	/* band */
	  OBITOP (O_BIAND, 1, 0, c = !(ea & m) && C);	/* biand */
	  OBITOP (O_BOR, 1, 0, c = (ea & m) || C);	/* bor  */
	  OBITOP (O_BIOR, 1, 0, c = !(ea & m) || C);	/* bior */
	  OBITOP (O_BXOR, 1, 0, c = ((ea & m) != 0)!= C);	/* bxor */
	  OBITOP (O_BIXOR, 1, 0, c = !(ea & m) != C);	/* bixor */

	case O (O_BFLD, SB):				/* bfld */
	  /* bitfield load */
	  ea = 0;
	  if (fetch (sd, &code->src, &bit))
	    goto end;

	  if (bit != 0)
	    {
	      if (fetch (sd, &code->dst, &ea))
		goto end;

	      ea &= bit;
	      while (!(bit & 1))
		{
		  ea  >>= 1;
		  bit >>= 1;
		}
	    }
	  if (store (sd, &code->op3, ea))
	    goto end;

	  goto next;

	case O(O_BFST, SB):			/* bfst */
	  /* bitfield store */
	  /* NOTE: the imm8 value is in dst, and the ea value
	     (which is actually the destination) is in op3.
	     It has to be that way, to avoid breaking the assembler.  */

	  if (fetch (sd, &code->dst, &bit))	/* imm8 */
	    goto end;
	  if (bit == 0)				/* noop -- nothing to do.  */
	    goto next;

	  if (fetch (sd, &code->src, &rd))	/* reg8 src */
	    goto end;

	  if (fetch2 (sd, &code->op3, &ea))	/* ea dst */
	    goto end;

	  /* Left-shift the register data into position.  */
	  for (tmp = bit; !(tmp & 1); tmp >>= 1)
	    rd <<= 1;

	  /* Combine it with the neighboring bits.  */
	  ea = (ea & ~bit) | (rd & bit);

	  /* Put it back.  */
	  if (store2 (sd, &code->op3, ea))
	    goto end;
	  goto next;

	case O (O_CLRMAC, SN):		/* clrmac */
	  h8_set_mach (sd, 0);
	  h8_set_macl (sd, 0);
	  h8_set_macZ (sd, 1);
	  h8_set_macV (sd, 0);
	  h8_set_macN (sd, 0);
	  goto next;

	case O (O_STMAC, SL):		/* stmac, 260 */
	  switch (code->src.type) {
	  case X (OP_MACH, SL): 
	    res = h8_get_mach (sd);
	    if (res & 0x200)		/* sign extend */
	      res |= 0xfffffc00;
	    break;
	  case X (OP_MACL, SL): 
	    res = h8_get_macl (sd);
	    break;
	  default:	goto illegal;
	  }
	  nz = !h8_get_macZ (sd);
	  n = h8_get_macN (sd);
	  v = h8_get_macV (sd);

	  if (store (sd, &code->dst, res))
	    goto end;

	  goto next;

	case O (O_LDMAC, SL):		/* ldmac, 179 */
	  if (fetch (sd, &code->src, &rd))
	    goto end;

	  switch (code->dst.type) {
	  case X (OP_MACH, SL):	
	    rd &= 0x3ff;		/* Truncate to 10 bits */
	    h8_set_mach (sd, rd);
	    break;
	  case X (OP_MACL, SL):	
	    h8_set_macl (sd, rd);
	    break;
	  default:	goto illegal;
	  }
	  h8_set_macV (sd, 0);
	  goto next;

	case O (O_MAC, SW):
	  if (fetch (sd, &code->src, &rd) ||
	      fetch (sd, &code->dst, &res))
	    goto end;

	  /* Ye gods, this is non-portable!
	     However, the existing mul/div code is similar.  */
	  res = SEXTSHORT (res) * SEXTSHORT (rd);

	  if (h8_get_macS (sd))		/* Saturating mode */
	    {
	      long long mac = h8_get_macl (sd);

	      if (mac & 0x80000000)		/* sign extend */
		mac |= 0xffffffff00000000LL;

	      mac += res;
	      if (mac > 0x7fffffff || mac < 0xffffffff80000000LL)
		h8_set_macV (sd, 1);
	      h8_set_macZ (sd, (mac == 0));
	      h8_set_macN (sd, (mac  < 0));
	      h8_set_macl (sd, (int) mac);
	    }
	  else				/* "Less Saturating" mode */
	    {
	      long long mac = h8_get_mach (sd);
	      mac <<= 32;
	      mac += h8_get_macl (sd);

	      if (mac & 0x20000000000LL)	/* sign extend */
		mac |= 0xfffffc0000000000LL;

	      mac += res;
	      if (mac > 0x1ffffffffffLL || 
		  mac < (long long) 0xfffffe0000000000LL)
		h8_set_macV (sd, 1);
	      h8_set_macZ (sd, (mac == 0));
	      h8_set_macN (sd, (mac  < 0));
	      h8_set_macl (sd, (int) mac);
	      mac >>= 32;
	      h8_set_mach (sd, (int) (mac & 0x3ff));
	    }
	  goto next;

	case O (O_MULS, SW):		/* muls.w */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  ea = SEXTSHORT (ea);
	  res = SEXTSHORT (ea * SEXTSHORT (rd));

	  n  = res & 0x8000;
	  nz = res & 0xffff;
	  if (store (sd, &code->dst, res))
	    goto end;

	  goto next;

	case O (O_MULS, SL):		/* muls.l */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  res = ea * rd;

	  n  = res & 0x80000000;
	  nz = res & 0xffffffff;
	  if (store (sd, &code->dst, res))
	    goto end;
	  goto next;

	case O (O_MULSU, SL):		/* muls/u.l */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  /* Compute upper 32 bits of the 64-bit result.  */
	  res = (((long long) ea) * ((long long) rd)) >> 32;

	  n  = res & 0x80000000;
	  nz = res & 0xffffffff;
	  if (store (sd, &code->dst, res))
	    goto end;
	  goto next;

	case O (O_MULU, SW):		/* mulu.w */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  res = UEXTSHORT ((UEXTSHORT (ea) * UEXTSHORT (rd)));

	  /* Don't set Z or N.  */
	  if (store (sd, &code->dst, res))
	    goto end;

	  goto next;

	case O (O_MULU, SL):		/* mulu.l */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  res = ea * rd;

	  /* Don't set Z or N.  */
	  if (store (sd, &code->dst, res))
	    goto end;

	  goto next;

	case O (O_MULUU, SL):		/* mulu/u.l */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  /* Compute upper 32 bits of the 64-bit result.  */
	  res = (((unsigned long long) (unsigned) ea) *
		 ((unsigned long long) (unsigned) rd)) >> 32;

	  /* Don't set Z or N.  */
	  if (store (sd, &code->dst, res))
	    goto end;

	  goto next;

	case O (O_MULXS, SB):		/* mulxs.b */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  ea = SEXTCHAR (ea);
	  res = ea * SEXTCHAR (rd);

	  n  = res & 0x8000;
	  nz = res & 0xffff;
	  if (store (sd, &code->dst, res))
	    goto end;

	  goto next;

	case O (O_MULXS, SW):		/* mulxs.w */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  ea = SEXTSHORT (ea);
	  res = ea * SEXTSHORT (rd & 0xffff);

	  n  = res & 0x80000000;
	  nz = res & 0xffffffff;
	  if (store (sd, &code->dst, res))
	    goto end;

	  goto next;

	case O (O_MULXU, SB):		/* mulxu.b */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  res = UEXTCHAR (ea) * UEXTCHAR (rd);

	  if (store (sd, &code->dst, res))
	    goto end;

	  goto next;

	case O (O_MULXU, SW):		/* mulxu.w */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  res = UEXTSHORT (ea) * UEXTSHORT (rd);

	  if (store (sd, &code->dst, res))
	    goto end;

	  goto next;

	case O (O_TAS, SB):		/* tas (test and set) */
	  if (!h8300sxmode)		/* h8sx can use any register. */
	    switch (code->src.reg)
	      {
	      case R0_REGNUM:
	      case R1_REGNUM:
	      case R4_REGNUM:
	      case R5_REGNUM:
		break;
	      default:
		goto illegal;
	      }

	  if (fetch (sd, &code->src, &res))
	    goto end;
	  if (store (sd, &code->src, res | 0x80))
	    goto end;

	  goto just_flags_log8;

	case O (O_DIVU, SW):			/* divu.w */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  n  = ea & 0x8000;
	  nz = ea & 0xffff;
	  if (ea)
	    res = (unsigned) (UEXTSHORT (rd) / UEXTSHORT (ea));
	  else
	    res = 0;

	  if (store (sd, &code->dst, res))
	    goto end;
	  goto next;

	case O (O_DIVU, SL):			/* divu.l */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  n  = ea & 0x80000000;
	  nz = ea & 0xffffffff;
	  if (ea)
	    res = (unsigned) rd / ea;
	  else
	    res = 0;

	  if (store (sd, &code->dst, res))
	    goto end;
	  goto next;

	case O (O_DIVS, SW):			/* divs.w */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  if (ea)
	    {
	      res = SEXTSHORT (rd) / SEXTSHORT (ea);
	      nz  = 1;
	    }
	  else
	    {
	      res = 0;
	      nz  = 0;
	    }

	  n = res & 0x8000;
	  if (store (sd, &code->dst, res))
	    goto end;
	  goto next;

	case O (O_DIVS, SL):			/* divs.l */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  if (ea)
	    {
	      res = rd / ea;
	      nz  = 1;
	    }
	  else
	    {
	      res = 0;
	      nz  = 0;
	    }

	  n = res & 0x80000000;
	  if (store (sd, &code->dst, res))
	    goto end;
	  goto next;

	case O (O_DIVXU, SB):			/* divxu.b */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  rd = UEXTSHORT (rd);
	  ea = UEXTCHAR (ea);

	  n  = ea & 0x80;
	  nz = ea & 0xff;
	  if (ea)
	    {
	      tmp = (unsigned) rd % ea;
	      res = (unsigned) rd / ea;
	    }
	  else
	    {
	      tmp = 0;
	      res = 0;
	    }

	  if (store (sd, &code->dst, (res & 0xff) | (tmp << 8)))
	    goto end;
	  goto next;

	case O (O_DIVXU, SW):			/* divxu.w */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  ea = UEXTSHORT (ea);

	  n  = ea & 0x8000;
	  nz = ea & 0xffff;
	  if (ea)
	    {
	      tmp = (unsigned) rd % ea;
	      res = (unsigned) rd / ea;
	    }
	  else
	    {
	      tmp = 0;
	      res = 0;
	    }

	  if (store (sd, &code->dst, (res & 0xffff) | (tmp << 16)))
	    goto end;
	  goto next;

	case O (O_DIVXS, SB):			/* divxs.b */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  rd = SEXTSHORT (rd);
	  ea = SEXTCHAR (ea);

	  if (ea)
	    {
	      tmp = (int) rd % (int) ea;
	      res = (int) rd / (int) ea;
	      nz  = 1;
	    }
	  else
	    {
	      tmp = 0;
	      res = 0;
	      nz  = 0;
	    }

	  n = res & 0x8000;
	  if (store (sd, &code->dst, (res & 0xff) | (tmp << 8)))
	    goto end;
	  goto next;

	case O (O_DIVXS, SW):			/* divxs.w */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  ea = SEXTSHORT (ea);

	  if (ea)
	    {
	      tmp = (int) rd % (int) ea;
	      res = (int) rd / (int) ea;
	      nz  = 1;
	    }
	  else
	    {
	      tmp = 0;
	      res = 0;
	      nz  = 0;
	    }

	  n = res & 0x80000000;
	  if (store (sd, &code->dst, (res & 0xffff) | (tmp << 16)))
	    goto end;
	  goto next;

	case O (O_EXTS, SW):			/* exts.w, signed extend */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  ea = rd & 0x80 ? -256 : 0;
	  res = (rd & 0xff) + ea;
	  goto log16;

	case O (O_EXTS, SL):			/* exts.l, signed extend */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (code->src.type == X (OP_IMM, SL))
	    {
	      if (fetch (sd, &code->src, &ea))
		goto end;

	      if (ea == 2)			/* exts.l #2, nn */
		{
		  /* Sign-extend from 8-bit to 32-bit.  */
		  ea = rd & 0x80 ? -256 : 0;
		  res = (rd & 0xff) + ea;
		  goto log32;
		}
	    }
	  /* Sign-extend from 16-bit to 32-bit.  */
	  ea = rd & 0x8000 ? -65536 : 0;
	  res = (rd & 0xffff) + ea;
	  goto log32;

	case O (O_EXTU, SW):			/* extu.w, unsigned extend */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  ea = 0;
	  res = (rd & 0xff) + ea;
	  goto log16;

	case O (O_EXTU, SL):			/* extu.l, unsigned extend */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (code->src.type == X (OP_IMM, SL))
	    {
	      if (fetch (sd, &code->src, &ea))
		goto end;

	      if (ea == 2)			/* extu.l #2, nn */
		{
		  /* Zero-extend from 8-bit to 32-bit.  */
		  ea = 0;
		  res = (rd & 0xff) + ea;
		  goto log32;
		}
	    }
	  /* Zero-extend from 16-bit to 32-bit.  */
	  ea = 0;
	  res = (rd & 0xffff) + ea;
	  goto log32;

	case O (O_NOP, SN):			/* nop */
	  goto next;

	case O (O_STM, SL):			/* stm, store to memory */
	  {
	    int nregs, firstreg, i;

	    nregs = GET_MEMORY_B (pc + 1);
	    nregs >>= 4;
	    nregs &= 0xf;
	    firstreg = code->src.reg;
	    firstreg &= 0xf;
	    for (i = firstreg; i <= firstreg + nregs; i++)
	      {
		h8_set_reg (sd, SP_REGNUM, h8_get_reg (sd, SP_REGNUM) - 4);
		SET_MEMORY_L (h8_get_reg (sd, SP_REGNUM), h8_get_reg (sd, i));
	      }
	  }
	  goto next;

	case O (O_LDM, SL):			/* ldm,  load from memory */
	case O (O_RTEL, SN):			/* rte/l, ldm plus rte */
	case O (O_RTSL, SN):			/* rts/l, ldm plus rts */
	  {
	    int nregs, firstreg, i;

	    nregs = ((GET_MEMORY_B (pc + 1) >> 4) & 0xf);
	    firstreg = code->dst.reg & 0xf;
	    for (i = firstreg; i >= firstreg - nregs; i--)
	      {
		h8_set_reg (sd, i, GET_MEMORY_L (h8_get_reg (sd, SP_REGNUM)));
		h8_set_reg (sd, SP_REGNUM, h8_get_reg (sd, SP_REGNUM) + 4);
	      }
	  }
	  switch (code->opcode) {
	  case O (O_RTEL, SN):
	    goto rte;
	  case O (O_RTSL, SN):
	    goto rts;
	  case O (O_LDM, SL):
	    goto next;
	  default:
	    goto illegal;
	  }

	case O (O_DAA, SB):
	  /* Decimal Adjust Addition.  This is for BCD arithmetic.  */
	  res = GET_B_REG (code->src.reg);	/* FIXME fetch? */
	  if (!c && (0 <= (res >>  4) && (res >>  4) <= 9) && 
	      !h && (0 <= (res & 0xf) && (res & 0xf) <= 9))
	    res = res;		/* Value added == 0.  */
	  else if (!c && (0  <= (res >>  4) && (res >>  4) <=  8) && 
		   !h && (10 <= (res & 0xf) && (res & 0xf) <= 15))
	    res = res + 0x6;		/* Value added == 6.  */
	  else if (!c && (0 <= (res >>  4) && (res >>  4) <= 9) && 
		    h && (0 <= (res & 0xf) && (res & 0xf) <= 3))
	    res = res + 0x6;		/* Value added == 6.  */
	  else if (!c && (10 <= (res >>  4) && (res >>  4) <= 15) && 
		   !h && (0  <= (res & 0xf) && (res & 0xf) <=  9))
	    res = res + 0x60;		/* Value added == 60.  */
	  else if (!c && (9  <= (res >>  4) && (res >>  4) <= 15) && 
		   !h && (10 <= (res & 0xf) && (res & 0xf) <= 15))
	    res = res + 0x66;		/* Value added == 66.  */
	  else if (!c && (10 <= (res >>  4) && (res >>  4) <= 15) && 
		    h && (0  <= (res & 0xf) && (res & 0xf) <=  3))
	    res = res + 0x66;		/* Value added == 66.  */
	  else if ( c && (1 <= (res >>  4) && (res >>  4) <= 2) && 
		   !h && (0 <= (res & 0xf) && (res & 0xf) <= 9))
	    res = res + 0x60;		/* Value added == 60.  */
	  else if ( c && (1  <= (res >>  4) && (res >>  4) <=  2) && 
		   !h && (10 <= (res & 0xf) && (res & 0xf) <= 15))
	    res = res + 0x66;		/* Value added == 66.  */
	  else if (c && (1 <= (res >>  4) && (res >>  4) <= 3) && 
		   h && (0 <= (res & 0xf) && (res & 0xf) <= 3))
	    res = res + 0x66;		/* Value added == 66.  */

	  goto alu8;

	case O (O_DAS, SB):
	  /* Decimal Adjust Subtraction.  This is for BCD arithmetic.  */
	  res = GET_B_REG (code->src.reg); /* FIXME fetch, fetch2... */
	  if (!c && (0 <= (res >>  4) && (res >>  4) <= 9) && 
	      !h && (0 <= (res & 0xf) && (res & 0xf) <= 9))
	    res = res;		/* Value added == 0.  */
	  else if (!c && (0 <= (res >>  4) && (res >>  4) <=  8) && 
		    h && (6 <= (res & 0xf) && (res & 0xf) <= 15))
	    res = res + 0xfa;		/* Value added == 0xfa.  */
	  else if ( c && (7 <= (res >>  4) && (res >>  4) <= 15) && 
		   !h && (0 <= (res & 0xf) && (res & 0xf) <=  9))
	    res = res + 0xa0;		/* Value added == 0xa0.  */
	  else if (c && (6 <= (res >>  4) && (res >>  4) <= 15) && 
		   h && (6 <= (res & 0xf) && (res & 0xf) <= 15))
	    res = res + 0x9a;		/* Value added == 0x9a.  */

	  goto alu8;

	default:
	illegal:
	  sim_engine_set_run_state (sd, sim_stopped, SIGILL);
	  goto end;

	}

      (*sim_callback->printf_filtered) (sim_callback,
					"sim_resume: internal error.\n");
      sim_engine_set_run_state (sd, sim_stopped, SIGILL);
      goto end;

    setc:
      if (code->dst.type == X (OP_CCR, SB) ||
	  code->dst.type == X (OP_CCR, SW))
	{
	  h8_set_ccr (sd, res);
	  GETSR (sd);
	}
      else if (h8300smode &&
	       (code->dst.type == X (OP_EXR, SB) ||
		code->dst.type == X (OP_EXR, SW)))
	{
	  h8_set_exr (sd, res);
	  if (h8300smode)	/* Get exr.  */
	    {
	      trace = (h8_get_exr (sd) >> 7) & 1;
	      intMask = h8_get_exr (sd) & 7;
	    }
	}
      else
	goto illegal;

      goto next;

    condtrue:
      /* When a branch works */
      if (fetch (sd, &code->src, &res))
	goto end;
      if (res & 1)		/* bad address */
	goto illegal;
      pc = code->next_pc + res;
      goto end;

      /* Set the cond codes from res */
    bitop:

      /* Set the flags after an 8 bit inc/dec operation */
    just_flags_inc8:
      n = res & 0x80;
      nz = res & 0xff;
      v = (rd & 0x7f) == 0x7f;
      goto next;

      /* Set the flags after an 16 bit inc/dec operation */
    just_flags_inc16:
      n = res & 0x8000;
      nz = res & 0xffff;
      v = (rd & 0x7fff) == 0x7fff;
      goto next;

      /* Set the flags after an 32 bit inc/dec operation */
    just_flags_inc32:
      n = res & 0x80000000;
      nz = res & 0xffffffff;
      v = (rd & 0x7fffffff) == 0x7fffffff;
      goto next;

    shift8:
      /* Set flags after an 8 bit shift op, carry,overflow set in insn */
      n = (rd & 0x80);
      nz = rd & 0xff;
      if (store2 (sd, &code->dst, rd))
	goto end;
      goto next;

    shift16:
      /* Set flags after an 16 bit shift op, carry,overflow set in insn */
      n = (rd & 0x8000);
      nz = rd & 0xffff;
      if (store2 (sd, &code->dst, rd))
	goto end;
      goto next;

    shift32:
      /* Set flags after an 32 bit shift op, carry,overflow set in insn */
      n = (rd & 0x80000000);
      nz = rd & 0xffffffff;
      if (store2 (sd, &code->dst, rd))
	goto end;
      goto next;

    log32:
      if (store2 (sd, &code->dst, res))
	goto end;

    just_flags_log32:
      /* flags after a 32bit logical operation */
      n = res & 0x80000000;
      nz = res & 0xffffffff;
      v = 0;
      goto next;

    log16:
      if (store2 (sd, &code->dst, res))
	goto end;

    just_flags_log16:
      /* flags after a 16bit logical operation */
      n = res & 0x8000;
      nz = res & 0xffff;
      v = 0;
      goto next;

    log8:
      if (store2 (sd, &code->dst, res))
	goto end;

    just_flags_log8:
      n = res & 0x80;
      nz = res & 0xff;
      v = 0;
      goto next;

    alu8:
      if (store2 (sd, &code->dst, res))
	goto end;

    just_flags_alu8:
      n = res & 0x80;
      nz = res & 0xff;
      c = (res & 0x100);
      switch (code->opcode / 4)
	{
	case O_ADD:
	case O_ADDX:
	  v = ((rd & 0x80) == (ea & 0x80)
	       && (rd & 0x80) != (res & 0x80));
	  break;
	case O_SUB:
	case O_SUBX:
	case O_CMP:
	  v = ((rd & 0x80) != (-ea & 0x80)
	       && (rd & 0x80) != (res & 0x80));
	  break;
	case O_NEG:
	  v = (rd == 0x80);
	  break;
	case O_DAA:
	case O_DAS:
	  break;	/* No effect on v flag.  */
	}
      goto next;

    alu16:
      if (store2 (sd, &code->dst, res))
	goto end;

    just_flags_alu16:
      n = res & 0x8000;
      nz = res & 0xffff;
      c = (res & 0x10000);
      switch (code->opcode / 4)
	{
	case O_ADD:
	case O_ADDX:
	  v = ((rd & 0x8000) == (ea & 0x8000)
	       && (rd & 0x8000) != (res & 0x8000));
	  break;
	case O_SUB:
	case O_SUBX:
	case O_CMP:
	  v = ((rd & 0x8000) != (-ea & 0x8000)
	       && (rd & 0x8000) != (res & 0x8000));
	  break;
	case O_NEG:
	  v = (rd == 0x8000);
	  break;
	}
      goto next;

    alu32:
      if (store2 (sd, &code->dst, res))
	goto end;

    just_flags_alu32:
      n = res & 0x80000000;
      nz = res & 0xffffffff;
      switch (code->opcode / 4)
	{
	case O_ADD:
	case O_ADDX:
	  v = ((rd & 0x80000000) == (ea & 0x80000000)
	       && (rd & 0x80000000) != (res & 0x80000000));
	  c = ((unsigned) res < (unsigned) rd) || 
	    ((unsigned) res < (unsigned) ea);
	  break;
	case O_SUB:
	case O_SUBX:
	case O_CMP:
	  v = ((rd & 0x80000000) != (-ea & 0x80000000)
	       && (rd & 0x80000000) != (res & 0x80000000));
	  c = (unsigned) rd < (unsigned) -ea;
	  break;
	case O_NEG:
	  v = (rd == 0x80000000);
	  c = res != 0;
	  break;
	}
      goto next;

    next:
      if ((res = h8_get_delayed_branch (sd)) != 0)
	{
	  pc = res;
	  h8_set_delayed_branch (sd, 0);
	}
      else
	pc = code->next_pc;

    end:
      
      if (--poll_count < 0)
	{
	  poll_count = POLL_QUIT_INTERVAL;
	  if ((*sim_callback->poll_quit) != NULL
	      && (*sim_callback->poll_quit) (sim_callback))
	    sim_engine_set_run_state (sd, sim_stopped, SIGINT);
	}
      sim_engine_get_run_state (sd, &reason, &sigrc);
    } while (reason == sim_running);

  h8_set_ticks (sd, h8_get_ticks (sd) + get_now () - tick_start);
  h8_set_cycles (sd, h8_get_cycles (sd) + cycles);
  h8_set_insts (sd, h8_get_insts (sd) + insts);
  h8_set_pc (sd, pc);
  BUILDSR (sd);

  if (h8300smode)
    h8_set_exr (sd, (trace<<7) | intMask);

  h8_set_mask (sd, oldmask);
  signal (SIGINT, prev);
}

int
sim_trace (SIM_DESC sd)
{
  /* FIXME: Unfinished.  */
  (*sim_callback->printf_filtered) (sim_callback,
				    "sim_trace: trace not supported.\n");
  return 1;	/* Done.  */
}

int
sim_write (SIM_DESC sd, SIM_ADDR addr, const unsigned char *buffer, int size)
{
  int i;

  init_pointers (sd);
  if (addr < 0)
    return 0;
  for (i = 0; i < size; i++)
    {
      if (addr < memory_size)
	{
	  h8_set_memory    (sd, addr + i, buffer[i]);
	  h8_set_cache_idx (sd, addr + i,  0);
	}
      else
	{
	  h8_set_eightbit (sd, (addr + i) & 0xff, buffer[i]);
	}
    }
  return size;
}

int
sim_read (SIM_DESC sd, SIM_ADDR addr, unsigned char *buffer, int size)
{
  init_pointers (sd);
  if (addr < 0)
    return 0;
  if (addr < memory_size)
    memcpy (buffer, h8_get_memory_buf (sd) + addr, size);
  else
    memcpy (buffer, h8_get_eightbit_buf (sd) + (addr & 0xff), size);
  return size;
}


int
sim_store_register (SIM_DESC sd, int rn, unsigned char *value, int length)
{
  int longval;
  int shortval;
  int intval;
  longval = (value[0] << 24) | (value[1] << 16) | (value[2] << 8) | value[3];
  shortval = (value[0] << 8) | (value[1]);
  intval = h8300hmode ? longval : shortval;

  init_pointers (sd);
  switch (rn)
    {
    case PC_REGNUM:
      if(h8300_normal_mode)
        h8_set_pc (sd, shortval); /* PC for Normal mode is 2 bytes */
      else
        h8_set_pc (sd, intval);
      break;
    default:
      (*sim_callback->printf_filtered) (sim_callback, 
					"sim_store_register: bad regnum %d.\n",
					rn);
    case R0_REGNUM:
    case R1_REGNUM:
    case R2_REGNUM:
    case R3_REGNUM:
    case R4_REGNUM:
    case R5_REGNUM:
    case R6_REGNUM:
    case R7_REGNUM:
      h8_set_reg (sd, rn, intval);
      break;
    case CCR_REGNUM:
      h8_set_ccr (sd, intval);
      break;
    case EXR_REGNUM:
      h8_set_exr (sd, intval);
      break;
    case SBR_REGNUM:
      h8_set_sbr (sd, intval);
      break;
    case VBR_REGNUM:
      h8_set_vbr (sd, intval);
      break;
    case MACH_REGNUM:
      h8_set_mach (sd, intval);
      break;
    case MACL_REGNUM:
      h8_set_macl (sd, intval);
      break;
    case CYCLE_REGNUM:
      h8_set_cycles (sd, longval);
      break;

    case INST_REGNUM:
      h8_set_insts (sd, longval);
      break;

    case TICK_REGNUM:
      h8_set_ticks (sd, longval);
      break;
    }
  return length;
}

int
sim_fetch_register (SIM_DESC sd, int rn, unsigned char *buf, int length)
{
  int v;
  int longreg = 0;

  init_pointers (sd);

  if (!h8300smode && rn >= EXR_REGNUM)
    rn++;
  switch (rn)
    {
    default:
      (*sim_callback->printf_filtered) (sim_callback, 
					"sim_fetch_register: bad regnum %d.\n",
					rn);
      v = 0;
      break;
    case CCR_REGNUM:
      v = h8_get_ccr (sd);
      break;
    case EXR_REGNUM:
      v = h8_get_exr (sd);
      break;
    case PC_REGNUM:
      v = h8_get_pc (sd);
      break;
    case SBR_REGNUM:
      v = h8_get_sbr (sd);
      break;
    case VBR_REGNUM:
      v = h8_get_vbr (sd);
      break;
    case MACH_REGNUM:
      v = h8_get_mach (sd);
      break;
    case MACL_REGNUM:
      v = h8_get_macl (sd);
      break;
    case R0_REGNUM:
    case R1_REGNUM:
    case R2_REGNUM:
    case R3_REGNUM:
    case R4_REGNUM:
    case R5_REGNUM:
    case R6_REGNUM:
    case R7_REGNUM:
      v = h8_get_reg (sd, rn);
      break;
    case CYCLE_REGNUM:
      v = h8_get_cycles (sd);
      longreg = 1;
      break;
    case TICK_REGNUM:
      v = h8_get_ticks (sd);
      longreg = 1;
      break;
    case INST_REGNUM:
      v = h8_get_insts (sd);
      longreg = 1;
      break;
    }
  /* In Normal mode PC is 2 byte, but other registers are 4 byte */
  if ((h8300hmode || longreg) && !(rn == PC_REGNUM && h8300_normal_mode))
    {
      buf[0] = v >> 24;
      buf[1] = v >> 16;
      buf[2] = v >> 8;
      buf[3] = v >> 0;
    }
  else
    {
      buf[0] = v >> 8;
      buf[1] = v;
    }
  return -1;
}

void
sim_stop_reason (SIM_DESC sd, enum sim_stop *reason, int *sigrc)
{
  sim_engine_get_run_state (sd, reason, sigrc);
}

/* FIXME: Rename to sim_set_mem_size.  */

void
sim_size (int n)
{
  /* Memory size is fixed.  */
}

static void
set_simcache_size (SIM_DESC sd, int n)
{
  if (sd->sim_cache)
    free (sd->sim_cache);
  if (n < 2)
    n = 2;
  sd->sim_cache = (decoded_inst *) malloc (sizeof (decoded_inst) * n);
  memset (sd->sim_cache, 0, sizeof (decoded_inst) * n);
  sd->sim_cache_size = n;
}


void
sim_info (SIM_DESC sd, int verbose)
{
  double timetaken = (double) h8_get_ticks (sd) / (double) now_persec ();
  double virttime = h8_get_cycles (sd) / 10.0e6;

  (*sim_callback->printf_filtered) (sim_callback,
				    "\n\n#instructions executed  %10d\n",
				    h8_get_insts (sd));
  (*sim_callback->printf_filtered) (sim_callback,
				    "#cycles (v approximate) %10d\n",
				    h8_get_cycles (sd));
  (*sim_callback->printf_filtered) (sim_callback,
				    "#real time taken        %10.4f\n",
				    timetaken);
  (*sim_callback->printf_filtered) (sim_callback,
				    "#virtual time taken     %10.4f\n",
				    virttime);
  if (timetaken != 0.0)
    (*sim_callback->printf_filtered) (sim_callback,
				      "#simulation ratio       %10.4f\n",
				      virttime / timetaken);
  (*sim_callback->printf_filtered) (sim_callback,
				    "#compiles               %10d\n",
				    h8_get_compiles (sd));
  (*sim_callback->printf_filtered) (sim_callback,
				    "#cache size             %10d\n",
				    sd->sim_cache_size);

#ifdef ADEBUG
  /* This to be conditional on `what' (aka `verbose'),
     however it was never passed as non-zero.  */
  if (1)
    {
      int i;
      for (i = 0; i < O_LAST; i++)
	{
	  if (h8_get_stats (sd, i))
	    (*sim_callback->printf_filtered) (sim_callback, "%d: %d\n", 
					      i, h8_get_stats (sd, i));
	}
    }
#endif
}

/* Indicate whether the cpu is an H8/300 or H8/300H.
   FLAG is non-zero for the H8/300H.  */

void
set_h8300h (unsigned long machine)
{
  /* FIXME: Much of the code in sim_load can be moved to sim_open.
     This function being replaced by a sim_open:ARGV configuration
     option.  */

  h8300hmode = h8300smode = h8300sxmode = h8300_normal_mode = 0;

  if (machine == bfd_mach_h8300sx || machine == bfd_mach_h8300sxn)
    h8300sxmode = 1;

  if (machine == bfd_mach_h8300s || machine == bfd_mach_h8300sn || h8300sxmode)
    h8300smode = 1;

  if (machine == bfd_mach_h8300h || machine == bfd_mach_h8300hn || h8300smode)
    h8300hmode = 1;

  if(machine == bfd_mach_h8300hn || machine == bfd_mach_h8300sn || machine == bfd_mach_h8300sxn)
    h8300_normal_mode = 1;
}

/* Cover function of sim_state_free to free the cpu buffers as well.  */

static void
free_state (SIM_DESC sd)
{
  if (STATE_MODULES (sd) != NULL)
    sim_module_uninstall (sd);

  /* Fixme: free buffers in _sim_cpu.  */
  sim_state_free (sd);
}

SIM_DESC
sim_open (SIM_OPEN_KIND kind, 
	  struct host_callback_struct *callback, 
	  struct bfd *abfd, 
	  char **argv)
{
  SIM_DESC sd;
  sim_cpu *cpu;

  sd = sim_state_alloc (kind, callback);
  sd->cpu = sim_cpu_alloc (sd, 0);
  cpu = STATE_CPU (sd, 0);
  SIM_ASSERT (STATE_MAGIC (sd) == SIM_MAGIC_NUMBER);
  sim_state_initialize (sd, cpu);
  /* sim_cpu object is new, so some initialization is needed.  */
  init_pointers_needed = 1;

  /* For compatibility (FIXME: is this right?).  */
  current_alignment = NONSTRICT_ALIGNMENT;
  current_target_byte_order = BIG_ENDIAN;

  if (sim_pre_argv_init (sd, argv[0]) != SIM_RC_OK)
    {
      free_state (sd);
      return 0;
    }

    /* getopt will print the error message so we just have to exit if
       this fails.  FIXME: Hmmm...  in the case of gdb we need getopt
       to call print_filtered.  */
  if (sim_parse_args (sd, argv) != SIM_RC_OK)
    {
      /* Uninstall the modules to avoid memory leaks,
         file descriptor leaks, etc.  */
      free_state (sd);
      return 0;
    }

  /* Check for/establish the a reference program image.  */
  if (sim_analyze_program (sd,
			   (STATE_PROG_ARGV (sd) != NULL
			    ? *STATE_PROG_ARGV (sd)
			    : NULL), abfd) != SIM_RC_OK)
    {
      free_state (sd);
      return 0;
    }

  /* Establish any remaining configuration options.  */
  if (sim_config (sd) != SIM_RC_OK)
    {
      free_state (sd);
      return 0;
    }

  if (sim_post_argv_init (sd) != SIM_RC_OK)
    {
      /* Uninstall the modules to avoid memory leaks,
         file descriptor leaks, etc.  */
      free_state (sd);
      return 0;
    }

  /*  sim_hw_configure (sd); */

  /* FIXME: Much of the code in sim_load can be moved here.  */

  sim_kind = kind;
  myname = argv[0];
  sim_callback = callback;
  return sd;
}

void
sim_close (SIM_DESC sd, int quitting)
{
  /* Nothing to do.  */
}

/* Called by gdb to load a program into memory.  */

SIM_RC
sim_load (SIM_DESC sd, char *prog, bfd *abfd, int from_tty)
{
  bfd *prog_bfd;

  /* FIXME: The code below that sets a specific variant of the H8/300
     being simulated should be moved to sim_open().  */

  /* See if the file is for the H8/300 or H8/300H.  */
  /* ??? This may not be the most efficient way.  The z8k simulator
     does this via a different mechanism (INIT_EXTRA_SYMTAB_INFO).  */
  if (abfd != NULL)
    prog_bfd = abfd;
  else
    prog_bfd = bfd_openr (prog, NULL);
  if (prog_bfd != NULL)
    {
      /* Set the cpu type.  We ignore failure from bfd_check_format
	 and bfd_openr as sim_load_file checks too.  */
      if (bfd_check_format (prog_bfd, bfd_object))
	{
	  set_h8300h (bfd_get_mach (prog_bfd));
	}
    }

  /* If we're using gdb attached to the simulator, then we have to
     reallocate memory for the simulator.

     When gdb first starts, it calls fetch_registers (among other
     functions), which in turn calls init_pointers, which allocates
     simulator memory.

     The problem is when we do that, we don't know whether we're
     debugging an H8/300 or H8/300H program.

     This is the first point at which we can make that determination,
     so we just reallocate memory now; this will also allow us to handle
     switching between H8/300 and H8/300H programs without exiting
     gdb.  */

  if (h8300smode && !h8300_normal_mode)
    memory_size = H8300S_MSIZE;
  else if (h8300hmode && !h8300_normal_mode)
    memory_size = H8300H_MSIZE;
  else
    memory_size = H8300_MSIZE;

  if (h8_get_memory_buf (sd))
    free (h8_get_memory_buf (sd));
  if (h8_get_cache_idx_buf (sd))
    free (h8_get_cache_idx_buf (sd));
  if (h8_get_eightbit_buf (sd))
    free (h8_get_eightbit_buf (sd));

  h8_set_memory_buf (sd, (unsigned char *) 
		     calloc (sizeof (char), memory_size));
  h8_set_cache_idx_buf (sd, (unsigned short *) 
			calloc (sizeof (short), memory_size));
  sd->memory_size = memory_size;
  h8_set_eightbit_buf (sd, (unsigned char *) calloc (sizeof (char), 256));

  /* `msize' must be a power of two.  */
  if ((memory_size & (memory_size - 1)) != 0)
    {
      (*sim_callback->printf_filtered) (sim_callback, 
					"sim_load: bad memory size.\n");
      return SIM_RC_FAIL;
    }
  h8_set_mask (sd, memory_size - 1);

  if (sim_load_file (sd, myname, sim_callback, prog, prog_bfd,
		     sim_kind == SIM_OPEN_DEBUG,
		     0, sim_write)
      == NULL)
    {
      /* Close the bfd if we opened it.  */
      if (abfd == NULL && prog_bfd != NULL)
	bfd_close (prog_bfd);
      return SIM_RC_FAIL;
    }

  /* Close the bfd if we opened it.  */
  if (abfd == NULL && prog_bfd != NULL)
    bfd_close (prog_bfd);
  return SIM_RC_OK;
}

SIM_RC
sim_create_inferior (SIM_DESC sd, struct bfd *abfd, char **argv, char **env)
{
  int i = 0;
  int len_arg = 0;
  int no_of_args = 0;

  if (abfd != NULL)
    h8_set_pc (sd, bfd_get_start_address (abfd));
  else
    h8_set_pc (sd, 0);

  /* Command Line support.  */
  if (argv != NULL)
    {
      /* Counting the no. of commandline arguments.  */
      for (no_of_args = 0; argv[no_of_args] != NULL; no_of_args++)
        continue;

      /* Allocating memory for the argv pointers.  */
      h8_set_command_line (sd, (char **) malloc ((sizeof (char *))
						 * (no_of_args + 1)));

      for (i = 0; i < no_of_args; i++)
	{
	  /* Copying the argument string.  */
	  h8_set_cmdline_arg (sd, i, (char *) strdup (argv[i]));
	}
      h8_set_cmdline_arg (sd, i, NULL);
    }
  
  return SIM_RC_OK;
}

void
sim_set_callbacks (struct host_callback_struct *ptr)
{
  sim_callback = ptr;
}
@


1.49
log
@sim: start a unified sim_do_command

Since sim_do_command for many people simply calls sim_args_command, start
a unified version of it.  For people who handle their own options, they
could switch to this by using sim_add_option_table instead.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d20 1
@


1.48
log
@http://sourceware.org/ml/gdb-patches/2010-11/msg00112.html
gdb/ChangeLog
	* remote-sim.c (gdbsim_store_register): Update API to
	sim_store_register to check more error conditions.
include/gdb/ChangeLog
	* remote-sim.h (sim_store_register): Update the API
	documentation for this function.
sim/erc32/ChangeLog
sim/h8300/ChangeLog
sim/m32c/ChangeLog
sim/mn10300/ChangeLog
sim/ppc/ChangeLog
sim/rx/ChangeLog
sim/v850/ChangeLog
	* ???.c (sim_store_register): Update return value to
	match new API.
@
text
@a5110 7
sim_do_command (SIM_DESC sd, char *cmd)
{
  (*sim_callback->printf_filtered) (sim_callback,
				    "This simulator does not accept any commands.\n");
}

void
@


1.47
log
@sim: constify sim_write source buffer (part 2)

As pointed out by Sandra Loosemore, a bunch of targets define sim_write
themselves instead of using the common/ code.  So constify them too.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d4718 1
a4718 1
  return -1;
@


1.46
log
@2009-12-09  Yoshinori Sato <ysato@@users.sourceforge.jp>
	* compile.c(fetch_1): Fix pre-dec, pre-inc, post-dec and post-inc.
	Index registers not masked memory areas.
	Only simply increment or decrement.
	* compile.c(store_1): Ditto.
@
text
@d4619 1
a4619 1
sim_write (SIM_DESC sd, SIM_ADDR addr, unsigned char *buffer, int size)
@


1.45
log
@2008-12-01  Joel Sherrill <joel.sherrill@@oarcorp.com>

	* compile.c: Add const to remove warning.
@
text
@d1389 1
a1389 2
      t &= h8_get_mask (sd);
      r = GET_MEMORY_B (t);
a1391 1
      t = t & h8_get_mask (sd);
d1397 1
a1397 2
      t &= h8_get_mask (sd);
      r = GET_MEMORY_W (t);
a1399 1
      t = t & h8_get_mask (sd);
d1405 1
a1405 2
      t &= h8_get_mask (sd);
      r = GET_MEMORY_L (t);
a1407 1
      t = t & h8_get_mask (sd);
d1414 1
a1414 2
      t &= h8_get_mask (sd);
      r = GET_MEMORY_B (t);
a1416 1
      t = t & h8_get_mask (sd);
d1422 1
a1422 2
      t &= h8_get_mask (sd);
      r = GET_MEMORY_W (t);
a1424 1
      t = t & h8_get_mask (sd);
d1430 1
a1430 2
      t &= h8_get_mask (sd);
      r = GET_MEMORY_L (t);
a1432 1
      t = t & h8_get_mask (sd);
d1439 1
a1440 1
      SET_L_REG (rn, t);
d1446 1
a1447 1
      SET_L_REG (rn, t);
d1453 1
a1454 1
      SET_L_REG (rn, t);
d1460 1
a1461 1
      SET_L_REG (rn, t);
d1467 1
a1468 1
      SET_L_REG (rn, t);
d1474 1
a1475 1
      SET_L_REG (rn, t);
d1612 1
a1613 1
      SET_L_REG (rn, t);
d1621 1
a1622 1
      SET_L_REG (rn, t);
d1630 1
a1631 1
      SET_L_REG (rn, t);
d1639 1
a1640 1
      SET_L_REG (rn, t);
d1648 1
a1649 1
      SET_L_REG (rn, t);
d1657 1
a1658 1
      SET_L_REG (rn, t);
d1663 3
a1665 1
      t = GET_L_REG (rn) & h8_get_mask (sd);
a1666 1
      SET_L_REG (rn, t - 1);
d1670 3
a1672 1
      t = GET_L_REG (rn) & h8_get_mask (sd);
a1673 1
      SET_L_REG (rn, t - 2);
d1677 3
a1679 1
      t = GET_L_REG (rn) & h8_get_mask (sd);
a1680 1
      SET_L_REG (rn, t - 4);
d1684 3
a1686 1
      t = GET_L_REG (rn) & h8_get_mask (sd);
a1687 1
      SET_L_REG (rn, t + 1);
d1691 3
a1693 1
      t = GET_L_REG (rn) & h8_get_mask (sd);
a1694 1
      SET_L_REG (rn, t + 2);
d1698 3
a1700 1
      t = GET_L_REG (rn) & h8_get_mask (sd);
a1701 1
      SET_L_REG (rn, t + 4);
@


1.44
log
@2007-07-03  Yoshinori Sato <ysato@@users.sourceforge.jp>

	* compile.c (sim_resume): Fix the last byte of ARGV for
	SYS_CMDLINE.
@
text
@d602 1
a602 1
      op_type *nib = q->data.nib;
d927 1
a927 1
		    op_type *args = q->args.nib;
@


1.43
log
@compile.c (OBITOP): Bit address mask low three bit.
compile.c (decode): Fix warning.
@
text
@d2813 1
a2813 1
		ind_arg_len = strlen (h8_get_cmdline_arg (sd, i) + 1);
@


1.42
log
@sim/h8300/ChangeLog:
2003-07-23  Richard Sandiford  <rsandifo@@redhat.com>
* compile.c (sim_resume): Make sure that dst.reg refers to the
right register byte in mova/sz.l @@(dd,RnL),ERn.
2003-07-21  Richard Sandiford  <rsandifo@@redhat.com>
* compile.c (sim_resume): Zero-extend immediate to muls, mulsu,
mulxs, divs and divxs.
sim/testsuite/sim/h8300/ChangeLog:
2003-07-22  Michael Snyder  <msnyder@@redhat.com>
* mul.s: Don't try to use negative immediate (it's always
unsigned).
* div.s: Ditto.
@
text
@d1021 1
a1021 1
			      if (lvalue (sd, p->type, p->reg, &p->type))
d1053 1
a1053 1
			      if (lvalue (sd, p->type, p->reg, &p->type))
d1894 1
a1894 1
  m = 1 << tmp;					\
@


1.41
log
@* compile.c (sim_load): Update sd->memory_size.
@
text
@d2040 4
a2043 1
		code->dst.type = X (OP_REG, SB);
d3892 1
a3892 7
	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfff0;
	  else
	    ea = SEXTSHORT (ea);

a3906 5
	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfffffff0;

a3919 5
	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfffffff0;

d3975 1
a3975 7
	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfffffff0;
	  else
	    ea = SEXTCHAR (ea);

d3990 1
a3990 7
	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfff0;
	  else
	    ea = SEXTSHORT (ea);

a4080 5
	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfffffff0;

a4101 5
	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfffffff0;

d4173 1
a4173 7

	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfffffff0;
	  else
	    ea = SEXTCHAR (ea);
d4198 1
a4198 6
	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfffffff0;
	  else
	    ea = SEXTSHORT (ea);
@


1.40
log
@2004-06-10  Michael Snyder  <msnyder@@redhat.com>
        Patch submitted by Nitin Yewale <NitinY@@KPITCummins.com>.
        * compile.c (sim_resume): Corrected ANDC operation on EXR for H8S.
@
text
@d5099 1
@


1.39
log
@2004-01-05  Michael Snyder  <msnyder@@redhat.com>

        * compile.c (sim_load):	Don't pass a type to bfd_openr.
@
text
@d2569 1
a2569 1
	      res = h8_get_exr (sd);
@


1.39.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2040 1
a2040 4
		{
		  code->dst.type = X (OP_REG, SB);
		  code->dst.reg = code->op3.reg + 8;
		}
d2569 1
a2569 1
	      rd = h8_get_exr (sd);
d3889 7
a3895 1
	  ea = SEXTSHORT (ea);
d3910 5
d3928 5
d3988 7
a3994 1
	  ea = SEXTCHAR (ea);
d4009 7
a4015 1
	  ea = SEXTSHORT (ea);
d4106 5
d4132 5
d4208 7
a4214 1
	  ea = SEXTCHAR (ea);
d4239 6
a4244 1
	  ea = SEXTSHORT (ea);
a5098 1
  sd->memory_size = memory_size;
@


1.38
log
@ Fix GDB crash problem when object file of different H8 cpu is loaded
@
text
@d5055 1
a5055 1
    prog_bfd = bfd_openr (prog, "coff-h8300");
@


1.37
log
@2003-10-17  Shrinivas Atre  <shrinivasa@@KPITCummins.com>
     * h8300/compile.c : Addition of extern variable h8300_normal_mode
        (SP) : Handle normal mode
        (bitfrom) : Use normal mode flag to return suitable value
        (lvalue) : Use normal mode flag to return command line location
        (decode) : Decode instruction correctly for normal mode
        (init_pointers) : Initialise memory correctly for normal mode
        (sim_resume) : Handle cases for normal mode using h8300_normal_mode flag
        (sim_store_register) : Handle 2 byte PC for normal mode
        (sim_fetch_register) : Handle 2 byte PC for normal mode
        (set_h8300h) : Set normal mode flag as per architechture
        (sim_load) : Allocate 64K for normal mode instead of bigger memory
@
text
@d4933 2
@


1.36
log
@2003-07-18  Michael Snyder  <msnyder@@redhat.com>

        * compile.c (decode): Enhancements for mova.
        Initialize cst, reg, and rdisp inside the loop, for each
        new instruction.  Defer correction of the disp2 values until
        later, and then adjust them by the size of the first operand,
        rather than the size of the instruction.
        (sim_resume): For mova, adjust the size of the second operand
        according to the type of the first operand (INDEXB vs. INDEXW).
        In cases where there is only one operand, the other two must
        both be composed on the fly.
@
text
@d56 1
a56 1
#define SP (h8300hmode ? SL : SW)
d513 1
d543 1
a543 1
      return h8300hmode ? SL : SW;
d579 1
a579 1
  if (h8300smode)
d581 1
a581 1
  else if (h8300hmode)
d841 4
a844 2
		  /* FIXME: Multiplier should be 2 for "normal" mode.  */
		  cst[opnum] = ((data[1] & 0x7f) + 0x80) * 4;
d1780 1
a1780 1
      if (h8300smode)
d1782 1
a1782 1
      else if (h8300hmode)
d1956 1
a1956 1
  if (!h8300hmode)
d2796 1
a2796 1
	    if (h8300hmode || h8300smode)
d2865 1
a2865 1
		if (h8300hmode || h8300smode)
d2881 1
a2881 1
	    if (h8300hmode || h8300smode)
d2920 1
a2920 1
	    if (h8300sxmode || h8300hmode || h8300smode)
d2971 2
a2972 2
	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);
	    buf_size = h8300hmode ? GET_L_REG (2) : GET_W_REG (2);
d3006 3
a3008 3
	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);
	    char_ptr = h8300hmode ? GET_L_REG (1) : GET_W_REG (1);
	    len = h8300hmode ? GET_L_REG (2) : GET_W_REG (2);
d3038 3
a3040 3
	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);
	    offset = h8300hmode ? GET_L_REG (1) : GET_W_REG (1);
	    origin = h8300hmode ? GET_L_REG (2) : GET_W_REG (2);
d3056 1
a3056 1
	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);
d3074 1
a3074 1
	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);
d3077 1
a3077 1
	    stat_ptr = h8300hmode ? GET_L_REG (1) : GET_W_REG (1);
d3126 1
a3126 1
	    filename_ptr = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);
d3150 1
a3150 1
	    stat_ptr = h8300hmode ? GET_L_REG (1) : GET_W_REG (1);
d3558 1
a3558 1
	  if (h8300hmode)
d3590 1
a3590 1
	  if (h8300hmode)
d3613 1
a3613 1
	  if (h8300hmode)
d3661 20
a3680 10
	    goto end;			/* res is vector number.  */

	  tmp = h8_get_reg (sd, SP_REGNUM);
	  tmp -= 4;
	  SET_MEMORY_L (tmp, code->next_pc);
	  tmp -= 4; 
	  SET_MEMORY_L (tmp, h8_get_ccr (sd));
	  intMaskBit = 1;
	  BUILDSR (sd);

d3689 4
a3692 2
	  /* FIXME: "normal" mode should use 2-byte ptrs.  */
	  pc = GET_MEMORY_L (0x20 + res * 4);
d4721 4
a4724 1
      h8_set_pc (sd, intval);
d4835 2
a4836 1
  if (h8300hmode || longreg)
d4941 3
d5079 1
a5079 1
  if (h8300smode)
d5081 1
a5081 1
  else if (h8300hmode)
@


1.35
log
@2003-07-22  Michael Snyder  <msnyder@@redhat.com>

        * compile.c (sim_resume): Revert 6-24 change, it does not
        work with gdb breakpoints.
@
text
@d609 4
a776 1

a781 14

		      /* DISP2 special treatment.  */
		      if ((looking_for & MODE) == DISP)
			{
			  switch (OP_SIZE (q->how)) {
			  default: break;
			  case SW:
			    cst[opnum] *= 2;
			    break;
			  case SL:
			    cst[opnum] *= 4;
			    break;
			  }
			}
d1064 7
a1070 4
			else if ((x & MODE) == INDEXB ||
				 (x & MODE) == INDEXW ||
				 (x & MODE) == INDEXL ||
				 (x & MODE) == DISP)
d1072 7
a1078 17
			    /* Use the instruction to determine 
			       the operand size.  */
			    switch (x & MODE) {
			    case INDEXB:
			      p->type = X (OP_INDEXB, OP_SIZE (q->how));
			      break;
			    case INDEXW:
			      p->type = X (OP_INDEXW, OP_SIZE (q->how));
			      break;
			    case INDEXL:
			      p->type = X (OP_INDEXL, OP_SIZE (q->how));
			      break;
			    case DISP:
			      p->type = X (OP_DISP,   OP_SIZE (q->how));
			      break;
			    }

d1082 40
d2004 1
d2006 14
d2021 21
d3639 3
@


1.34
log
@2003-07-17  Michael Snyder  <msnyder@@redhat.com>

        * compile.c (sim_resume): Handle shll reg, reg and shlr reg, reg.
@
text
@d3580 1
d3587 1
@


1.33
log
@2003-07-17  Michael Snyder  <msnyder@@redhat.com>

        * compile.c (decode): IMM16 is always zero-extended.
@
text
@d3156 3
a3158 1
	  if (code->src.type == X (OP_IMM, SB))
a3159 2
	  else
	    ea = 1;
d3180 3
a3182 1
	  if (code->src.type == X (OP_IMM, SW))
a3183 2
	  else
	    ea = 1;
d3204 3
a3206 1
	  if (code->src.type == X (OP_IMM, SL))
a3207 2
	  else
	    ea = 1;
@


1.32
log
@2003-06-24  Michael Snyder  <msnyder@@redhat.com>

	* sim-main.h (SIM_WIFSTOPPED, SIM_WSTOPSIG): Define.
	* compile.c (sim_resume): Use the above to return stop signal.
@
text
@d821 3
a823 1
		  if ((looking_for & SIZE) != L_16U)
@


1.31
log
@2003-06-18  Michael Snyder  <msnyder@@redhat.com>

        * compile.c: Replace "Hitachi" with "Renesas".
        (decode): Distinguish AV_H8S from AV_H8H.
        (sim_resume): H8SX can use any register for TAS.
        (decode): Add support for VECIND.
        (sim_resume): Implement rte/l and rts/l.
        (GETSR): New macro (actually old macro reincarnated).
        (decode): Add handling for IMM2.
        (sim_resume): Drop extra block around jmp, jsr, rts.
        Add handling for trapa and rte.
        For divxu.b, change 0xffff mask to 0xff.
        (set_h8300h): Add bfd_mach_h8300sxn machine.
@
text
@d3578 6
@


1.30
log
@2003-06-05  Michael Snyder  <msnyder@@redhat.com>

	* compile.c (sim_fetch_register): Handle SBR, VBR, MACH, MACL.
	(sim_store_register): Ditto.
@
text
@d2 1
a2 1
 * Simulator for the Hitachi H8/300 architecture.
d487 12
d605 1
d847 6
d907 4
d1051 2
a1052 1
			else if ((x & MODE) == MEMIND)
d1131 1
a1131 1
			  printf ("Hmmmm %x...\n", x);
d1185 1
a1185 1
		printf ("Don't understand %x \n", looking_for);
d1920 1
a1920 8
  c = (h8_get_ccr (sd) >> 0) & 1;
  v = (h8_get_ccr (sd) >> 1) & 1;
  nz = !((h8_get_ccr (sd) >> 2) & 1);
  n = (h8_get_ccr (sd) >> 3) & 1;
  u = (h8_get_ccr (sd) >> 4) & 1;
  h = (h8_get_ccr (sd) >> 5) & 1;
  ui = ((h8_get_ccr (sd) >> 6) & 1);
  intMaskBit = (h8_get_ccr (sd) >> 7) & 1;
d2217 1
a2217 1
	case O (O_MOVMD, SB):		/* movsd.b */
d2232 1
a2232 1
	case O (O_MOVMD, SW):		/* movsd.b */
d2247 1
a2247 1
	case O (O_MOVMD, SL):		/* movsd.b */
d3483 2
a3484 4
	  {
	    fetch (sd, &code->src, &pc);
	    goto end;
	  }
d3490 4
a3493 6
	  {
	    int tmp;
	    if (fetch (sd, &code->src, &pc))
	      goto end;
	  call:
	    tmp = h8_get_reg (sd, SP_REGNUM);
d3495 11
a3505 11
	    if (h8300hmode)
	      {
		tmp -= 4;
		SET_MEMORY_L (tmp, code->next_pc);
	      }
	    else
	      {
		tmp -= 2;
		SET_MEMORY_W (tmp, code->next_pc);
	      }
	    h8_set_reg (sd, SP_REGNUM, tmp);
d3507 1
a3507 2
	    goto end;
	  }
d3517 29
d3547 2
a3548 2
	  {
	    int tmp;
d3550 10
a3559 1
	    tmp = h8_get_reg (sd, SP_REGNUM);
d3561 2
a3562 14
	    if (h8300hmode)
	      {
		pc = GET_MEMORY_L (tmp);
		tmp += 4;
	      }
	    else
	      {
		pc = GET_MEMORY_W (tmp);
		tmp += 2;
	      }

	    h8_set_reg (sd, SP_REGNUM, tmp);
	    goto end;
	  }
d3585 24
d3963 13
a3975 13
	case O (O_TAS, SB):		/* tas, (test and set?) */
	  if (!h8300smode || code->src.type != X (OP_REG, SL))
	    goto illegal;
	  switch (code->src.reg)
	    {
	    case R0_REGNUM:
	    case R1_REGNUM:
	    case R4_REGNUM:
	    case R5_REGNUM:
	      break;
	    default:
	      goto illegal;
	    }
d4088 1
a4088 1
	  if (store (sd, &code->dst, (res & 0xffff) | (tmp << 8)))
d4255 2
d4260 2
a4261 5
	    nregs = GET_MEMORY_B (pc + 1);
	    nregs >>= 4;
	    nregs &= 0xf;
	    firstreg = code->dst.reg;
	    firstreg &= 0xf;
d4268 10
a4277 1
	  goto next;
d4281 1
a4281 1
	  res = GET_B_REG (code->src.reg);
d4347 1
a4347 9
	  /* Get Status Register (flags).  */
	  c = (h8_get_ccr (sd) >> 0) & 1;
	  v = (h8_get_ccr (sd) >> 1) & 1;
	  nz = !((h8_get_ccr (sd) >> 2) & 1);
	  n = (h8_get_ccr (sd) >> 3) & 1;
	  u = (h8_get_ccr (sd) >> 4) & 1;
	  h = (h8_get_ccr (sd) >> 5) & 1;
	  ui = ((h8_get_ccr (sd) >> 6) & 1);
	  intMaskBit = (h8_get_ccr (sd) >> 7) & 1;
d4634 3
a4650 3
    case PC_REGNUM:
      h8_set_pc (sd, intval);
      break;
d4672 1
d4676 1
d4843 1
a4843 1
  if (machine == bfd_mach_h8300sx)
@


1.29
log
@2003-06-04  Michael Snyder  <msnyder@@redhat.com>

	* compile.c (sim_info): Fix typo in output.

	* h8300/compile.c (set_h8300h): Replace 'flag' arguments
	with a bfd_machine argument, and decode it inline.
	Check for bfd_mach_h8300hn and bfd_mach_h8300sn.
@
text
@a4571 3
    case PC_REGNUM:
      h8_set_pc (sd, intval);
      break;
d4586 3
d4595 12
a4609 1

a4612 1

d4646 12
@


1.28
log
@2003-06-04  Michael Snyder  <msnyder@@redhat.com>

	* compile.c (sim_info): Fix typo in output.
@
text
@d4751 1
a4751 1
set_h8300h (int h_flag, int s_flag, int sx_flag)
d4757 8
a4764 3
  h8300hmode  = h_flag;
  h8300smode  = s_flag;
  h8300sxmode = sx_flag;
d4881 1
a4881 8
	  unsigned long mach = bfd_get_mach (prog_bfd);

	  set_h8300h (mach == bfd_mach_h8300h || 
		      mach == bfd_mach_h8300s ||
		      mach == bfd_mach_h8300sx,
		      mach == bfd_mach_h8300s ||
		      mach == bfd_mach_h8300sx,
		      mach == bfd_mach_h8300sx);
@


1.27
log
@2003-06-03  Michael Snyder  <msnyder@@redhat.com>

	* h8300/compile.c: Add h8300sx insns and addressing modes.
	* h8300/sim-main.h: Replaces h8300/inst.h.
	* h8300/Makefile.in: Tweak to bring in some sim/common stuff.
@
text
@d4718 1
a4718 1
				    "#virtual time taked     %10.4f\n",
@


1.26
log
@2003-04-13  Michael Snyder  <msnyder@@redhat.com>

	* compile.c (sim_resume): Implement 'daa' and 'das' instructions.
@
text
@a19 3
#include "config.h"

#include <stdio.h>
d30 1
a30 1
#include "ansidecl.h"
d32 1
a32 2
#include "gdb/callback.h"
#include "gdb/remote-sim.h"
d52 1
a52 1
void sim_set_simcache_size PARAMS ((int));
d54 1
a54 1
#define X(op, size)  op * 4 + size
d57 1
a57 13
#define SB 0
#define SW 1
#define SL 2
#define OP_REG 1
#define OP_DEC 2
#define OP_DISP 3
#define OP_INC 4
#define OP_PCREL 5
#define OP_MEM 6
#define OP_CCR 7
#define OP_IMM 8
#define OP_ABS 10
#define OP_EXR 11
d62 27
a88 1
#include "inst.h"
d90 5
a94 1
/* The rate at which to call the host's poll_quit callback.  */
d96 5
a100 1
#define POLL_QUIT_INTERVAL 0x80000
d102 5
a106 3
#define LOW_BYTE(x) ((x) & 0xff)
#define HIGH_BYTE(x) (((x) >> 8) & 0xff)
#define P(X,Y) ((X << 8) | Y)
d108 5
a112 23
#define BUILDSR()					\
  cpu.ccr = ((I << 7) | (UI << 6) | (H << 5) | (U << 4)	\
	     | (N << 3) | (Z << 2) | (V << 1) | C);

#define BUILDEXR()	    \
  if (h8300smode) cpu.exr = (trace<<7) | intMask;

#define GETSR()		    \
  c = (cpu.ccr >> 0) & 1;\
  v = (cpu.ccr >> 1) & 1;\
  nz = !((cpu.ccr >> 2) & 1);\
  n = (cpu.ccr >> 3) & 1;\
  u = (cpu.ccr >> 4) & 1;\
  h = (cpu.ccr >> 5) & 1;\
  ui = ((cpu.ccr >> 6) & 1);\
  intMaskBit = (cpu.ccr >> 7) & 1;

#define GETEXR()				\
  if (h8300smode)				\
    {						\
      trace = (cpu.exr >> 7) & 1;		\
      intMask = cpu.exr & 7;			\
    }
d114 5
a118 3
#ifdef __CHAR_IS_SIGNED__
#define SEXTCHAR(x) ((char) (x))
#endif
d120 5
a124 3
#ifndef SEXTCHAR
#define SEXTCHAR(x) ((x & 0x80) ? (x | ~0xff) : x & 0xff)
#endif
d126 5
a130 3
#define UEXTCHAR(x) ((x) & 0xff)
#define UEXTSHORT(x) ((x) & 0xffff)
#define SEXTSHORT(x) ((short) (x))
d132 5
a136 1
static cpu_state_type cpu;
d138 5
a142 2
int h8300hmode = 0;
int h8300smode = 0;
d144 5
a148 1
static int memory_size;
d151 7
a157 1
get_now (void)
d159 1
a159 1
  return time (0);	/* WinXX HAS UNIX like 'time', so why not using it? */
d163 1
a163 1
now_persec (void)
d165 1
a165 1
  return 1;
d168 6
d175 13
a187 1
bitfrom (int x)
d189 1
a189 11
  switch (x & SIZE)
    {
    case L_8:
      return SB;
    case L_16:
      return SW;
    case L_32:
      return SL;
    case L_P:
      return h8300hmode ? SL : SW;
    }
d192 6
d199 1
a199 1
lvalue (int x, int rn)
d201 2
a202 8
  switch (x / 4)
    {
    case OP_DISP:
      if (rn == 8)
	{
	  return X (OP_IMM, SP);
	}
      return X (OP_REG, SP);
d204 5
a208 2
    case OP_MEM:
      return X (OP_MEM, SP);
d210 4
a213 3
    default:
      abort (); /* ?? May be something more usefull? */
    }
d216 2
a217 2
static int
cmdline_location()
d219 1
a219 6
  if (h8300smode)
    return 0xffff00L;
  else if (h8300hmode)
    return 0x2ff00L;
  else
    return 0xff00L;
d223 1
a223 1
decode (int addr, unsigned char *data, decoded_inst *dst)
d225 2
a226 8
  int rs = 0;
  int rd = 0;
  int rdisp = 0;
  int abs = 0;
  int bit = 0;
  int plen = 0;
  struct h8_opcode *q;
  int size = 0;
d228 5
a232 2
  dst->dst.type = -1;
  dst->src.type = -1;
d234 5
a238 5
  /* Find the exact opcode/arg combo.  */
  for (q = h8_opcodes; q->name; q++)
    {
      op_type *nib = q->data.nib;
      unsigned int len = 0;
d240 5
a244 4
      while (1)
	{
	  op_type looking_for = *nib;
	  int thisnib = data[len >> 1];
d246 5
a250 1
	  thisnib = (len & 1) ? (thisnib & 0xf) : ((thisnib >> 4) & 0xf);
d252 5
a256 11
	  if (looking_for < 16 && looking_for >= 0)
	    {
	      if (looking_for != thisnib)
		goto fail;
	    }
	  else
	    {
	      if ((int) looking_for & (int) B31)
		{
		  if (!(((int) thisnib & 0x8) != 0))
		    goto fail;
d258 5
a262 3
		  looking_for = (op_type) ((int) looking_for & ~(int) B31);
		  thisnib &= 0x7;
		}
d264 5
a268 4
	      if ((int) looking_for & (int) B30)
		{
		  if (!(((int) thisnib & 0x8) == 0))
		    goto fail;
d270 5
a274 2
		  looking_for = (op_type) ((int) looking_for & ~(int) B30);
		}
d276 5
a280 7
	      if (looking_for & DBIT)
		{
		  /* Exclude adds/subs by looking at bit 0 and 2, and
                     make sure the operand size, either w or l,
                     matches by looking at bit 1.  */
		  if ((looking_for & 7) != (thisnib & 7))
		    goto fail;
d282 5
a286 34
		  abs = (thisnib & 0x8) ? 2 : 1;
		}
	      else if (looking_for & (REG | IND | INC | DEC))
		{
		  if (looking_for & REG)
		    {
		      /* Can work out size from the register.  */
		      size = bitfrom (looking_for);
		    }
		  if (looking_for & SRC)
		    rs = thisnib;
		  else
		    rd = thisnib;
		}
	      else if (looking_for & L_16)
		{
		  abs = (data[len >> 1]) * 256 + data[(len + 2) >> 1];
		  plen = 16;
		  if (looking_for & (PCREL | DISP))
		    {
		      abs = (short) (abs);
		    }
		}
	      else if (looking_for & ABSJMP)
		{
		  abs = (data[1] << 16) | (data[2] << 8) | (data[3]);
		}
	      else if (looking_for & MEMIND)
		{
		  abs = data[1];
		}
	      else if (looking_for & L_32)
		{
		  int i = len >> 1;
d288 6
a293 4
		  abs = (data[i] << 24)
		    | (data[i + 1] << 16)
		    | (data[i + 2] << 8)
		    | (data[i + 3]);
d295 6
a300 5
		  plen = 32;
		}
	      else if (looking_for & L_24)
		{
		  int i = len >> 1;
d302 5
a306 31
		  abs = (data[i] << 16) | (data[i + 1] << 8) | (data[i + 2]);
		  plen = 24;
		}
	      else if (looking_for & IGNORE)
		{
		  ;
		}
	      else if (looking_for & DISPREG)
		{
		  rdisp = thisnib & 0x7;
		}
	      else if (looking_for & KBIT)
		{
		  switch (thisnib)
		    {
		    case 9:
		      abs = 4;
		      break;
		    case 8:
		      abs = 2;
		      break;
		    case 0:
		      abs = 1;
		      break;
		    default:
		      goto fail;
		    }
		}
	      else if (looking_for & L_8)
		{
		  plen = 8;
d308 5
a312 18
		  if (looking_for & PCREL)
		    {
		      abs = SEXTCHAR (data[len >> 1]);
		    }
		  else if (looking_for & ABS8MEM)
		    {
		      plen = 8;
		      abs = h8300hmode ? ~0xff0000ff : ~0xffff00ff;
		      abs |= data[len >> 1] & 0xff;
		    }
		  else
		    {
		      abs = data[len >> 1] & 0xff;
		    }
		}
	      else if (looking_for & L_3)
		{
		  plen = 3;
d314 7
a320 5
		  bit = thisnib;
		}
	      else if (looking_for == E)
		{
		  dst->op = q;
d322 5
a326 4
		  /* Fill in the args.  */
		  {
		    op_type *args = q->args.nib;
		    int hadone = 0;
d328 5
a332 5
		    while (*args != E)
		      {
			int x = *args;
			int rn = (x & DST) ? rd : rs;
			ea_type *p;
d334 5
a338 4
			if (x & DST)
			  p = &(dst->dst);
			else
			  p = &(dst->src);
d340 11
a350 14
			if (x & L_3)
			  {
			    p->type = X (OP_IMM, size);
			    p->literal = bit;
			  }
			else if (x & (IMM | KBIT | DBIT))
			  {
			    p->type = X (OP_IMM, size);
			    p->literal = abs;
			  }
			else if (x & REG)
			  {
			    /* Reset the size.
			       Some ops (like mul) have two sizes.  */
d352 5
a356 59
			    size = bitfrom (x);
			    p->type = X (OP_REG, size);
			    p->reg = rn;
			  }
			else if (x & INC)
			  {
			    p->type = X (OP_INC, size);
			    p->reg = rn & 0x7;
			  }
			else if (x & DEC)
			  {
			    p->type = X (OP_DEC, size);
			    p->reg = rn & 0x7;
			  }
			else if (x & IND)
			  {
			    p->type = X (OP_DISP, size);
			    p->reg = rn & 0x7;
			    p->literal = 0;
			  }
			else if (x & (ABS | ABSJMP | ABS8MEM))
			  {
			    p->type = X (OP_DISP, size);
			    p->literal = abs;
			    p->reg = 8;
			  }
			else if (x & MEMIND)
			  {
			    p->type = X (OP_MEM, size);
			    p->literal = abs;
			  }
			else if (x & PCREL)
			  {
			    p->type = X (OP_PCREL, size);
			    p->literal = abs + addr + 2;
			    if (x & L_16)
			      p->literal += 2;
			  }
			else if (x & ABSJMP)
			  {
			    p->type = X (OP_IMM, SP);
			    p->literal = abs;
			  }
			else if (x & DISP)
			  {
			    p->type = X (OP_DISP, size);
			    p->literal = abs;
			    p->reg = rdisp & 0x7;
			  }
			else if (x & CCR)
			  {
			    p->type = OP_CCR;
			  }
			else if (x & EXR)
			  {
			    p->type = OP_EXR;
			  }
			else
			  printf ("Hmmmm %x", x);
d358 5
a362 3
			args++;
		      }
		  }
d364 5
a368 8
		  /* But a jmp or a jsr gets automagically lvalued,
		     since we branch to their address not their
		     contents.  */
		  if (q->how == O (O_JSR, SB)
		      || q->how == O (O_JMP, SB))
		    {
		      dst->src.type = lvalue (dst->src.type, dst->src.reg);
		    }
d370 5
a374 2
		  if (dst->dst.type == -1)
		    dst->dst = dst->src;
d376 5
a380 2
		  dst->opcode = q->how;
		  dst->cycles = q->time;
d382 5
a386 2
		  /* And a jsr to these locations are turned into magic
		     traps.  */
d388 5
a392 31
		  if (dst->opcode == O (O_JSR, SB))
		    {
		      switch (dst->src.literal)
			{
			case 0xc5:
			  dst->opcode = O (O_SYS_OPEN, SB);
			  break;
			case 0xc6:
			  dst->opcode = O (O_SYS_READ, SB);
			  break;
			case 0xc7:
			  dst->opcode = O (O_SYS_WRITE, SB);
			  break;
			case 0xc8:
			  dst->opcode = O (O_SYS_LSEEK, SB);
			  break;
			case 0xc9:
			  dst->opcode = O (O_SYS_CLOSE, SB);
			  break;
			case 0xca:
			  dst->opcode = O (O_SYS_STAT, SB);
			  break;
			case 0xcb:
			  dst->opcode = O (O_SYS_FSTAT, SB);
			  break;
			case 0xcc:
			  dst->opcode = O (O_SYS_CMDLINE, SB);
			  break;
			}
		      /* End of Processing for system calls.  */
		    }
d394 5
a398 6
		  dst->next_pc = addr + len / 2;
		  return;
		}
	      else
		printf ("Don't understand %x \n", looking_for);
	    }
d400 5
a404 3
	  len++;
	  nib++;
	}
d406 5
a410 3
    fail:
      ;
    }
d412 5
a416 2
  /* Fell off the end.  */
  dst->opcode = O (O_ILL, SB);
d420 8
a427 1
compile (int pc)
d429 2
a430 1
  int idx;
d432 5
a436 8
  /* Find the next cache entry to use.  */
  idx = cpu.cache_top + 1;
  cpu.compiles++;
  if (idx >= cpu.csize)
    {
      idx = 1;
    }
  cpu.cache_top = idx;
d438 6
a443 2
  /* Throw away its old meaning.  */
  cpu.cache_idx[cpu.cache[idx].oldpc] = 0;
d445 5
a449 2
  /* Set to new address.  */
  cpu.cache[idx].oldpc = pc;
d451 6
a456 2
  /* Fill in instruction info.  */
  decode (pc, cpu.memory + pc, cpu.cache + idx);
d458 4
a461 2
  /* Point to new cache entry.  */
  cpu.cache_idx[pc] = idx;
d464 3
d468 1
a468 3
static unsigned char *breg[18];
static unsigned short *wreg[18];
static unsigned int *lreg[18];
d470 3
a472 4
#define GET_B_REG(x) *(breg[x])
#define SET_B_REG(x,y) (*(breg[x])) = (y)
#define GET_W_REG(x) *(wreg[x])
#define SET_W_REG(x,y) (*(wreg[x])) = (y)
d474 8
a481 2
#define GET_L_REG(x) *(lreg[x])
#define SET_L_REG(x,y) (*(lreg[x])) = (y)
d483 3
a485 6
#define GET_MEMORY_L(x) \
  (x < memory_size \
   ? ((cpu.memory[x+0] << 24) | (cpu.memory[x+1] << 16) \
      | (cpu.memory[x+2] << 8) | cpu.memory[x+3]) \
   : ((cpu.eightbit[(x+0) & 0xff] << 24) | (cpu.eightbit[(x+1) & 0xff] << 16) \
      | (cpu.eightbit[(x+2) & 0xff] << 8) | cpu.eightbit[(x+3) & 0xff]))
d487 3
a489 4
#define GET_MEMORY_W(x) \
  (x < memory_size \
   ? ((cpu.memory[x+0] << 8) | (cpu.memory[x+1] << 0)) \
   : ((cpu.eightbit[(x+0) & 0xff] << 8) | (cpu.eightbit[(x+1) & 0xff] << 0)))
d491 3
d495 3
a497 2
#define GET_MEMORY_B(x) \
  (x < memory_size ? (cpu.memory[x]) : (cpu.eightbit[x & 0xff]))
d499 3
a501 5
#define SET_MEMORY_L(x,y)  \
{  register unsigned char *_p; register int __y = y; \
   _p = (x < memory_size ? cpu.memory+x : cpu.eightbit + (x & 0xff)); \
   _p[0] = (__y)>>24; _p[1] = (__y)>>16; \
   _p[2] = (__y)>>8; _p[3] = (__y)>>0;}
d503 1
a503 4
#define SET_MEMORY_W(x,y) \
{  register unsigned char *_p; register int __y = y; \
   _p = (x < memory_size ? cpu.memory+x : cpu.eightbit + (x & 0xff)); \
   _p[0] = (__y)>>8; _p[1] =(__y);}
d505 5
a509 2
#define SET_MEMORY_B(x,y) \
  (x < memory_size ? (cpu.memory[(x)] = y) : (cpu.eightbit[x & 0xff] = y))
d512 1
a512 1
fetch (ea_type *arg)
d514 2
a515 4
  int rn = arg->reg;
  int abs = arg->literal;
  int r;
  int t;
d517 4
a520 1
  switch (arg->type)
d522 12
a533 12
    case X (OP_REG, SB):
      return GET_B_REG (rn);
    case X (OP_REG, SW):
      return GET_W_REG (rn);
    case X (OP_REG, SL):
      return GET_L_REG (rn);
    case X (OP_IMM, SB):
    case X (OP_IMM, SW):
    case X (OP_IMM, SL):
      return abs;
    case X (OP_DEC, SB):
      abort ();
d535 3
a537 21
    case X (OP_INC, SB):
      t = GET_L_REG (rn);
      t &= cpu.mask;
      r = GET_MEMORY_B (t);
      t++;
      t = t & cpu.mask;
      SET_L_REG (rn, t);
      return r;
      break;
    case X (OP_INC, SW):
      t = GET_L_REG (rn);
      t &= cpu.mask;
      r = GET_MEMORY_W (t);
      t += 2;
      t = t & cpu.mask;
      SET_L_REG (rn, t);
      return r;
    case X (OP_INC, SL):
      t = GET_L_REG (rn);
      t &= cpu.mask;
      r = GET_MEMORY_L (t);
d539 5
a543 29
      t += 4;
      t = t & cpu.mask;
      SET_L_REG (rn, t);
      return r;

    case X (OP_DISP, SB):
      t = GET_L_REG (rn) + abs;
      t &= cpu.mask;
      return GET_MEMORY_B (t);

    case X (OP_DISP, SW):
      t = GET_L_REG (rn) + abs;
      t &= cpu.mask;
      return GET_MEMORY_W (t);

    case X (OP_DISP, SL):
      t = GET_L_REG (rn) + abs;
      t &= cpu.mask;
      return GET_MEMORY_L (t);

    case X (OP_MEM, SL):
      t = GET_MEMORY_L (abs);
      t &= cpu.mask;
      return t;

    case X (OP_MEM, SW):
      t = GET_MEMORY_W (abs);
      t &= cpu.mask;
      return t;
d545 11
d557 2
a558 2
      abort (); /* ?? May be something more usefull? */

d560 1
d563 10
d575 1
a575 1
store (ea_type *arg, int n)
d577 8
a584 3
  int rn = arg->reg;
  int abs = arg->literal;
  int t;
d586 2
a587 1
  switch (arg->type)
d589 2
a590 9
    case X (OP_REG, SB):
      SET_B_REG (rn, n);
      break;
    case X (OP_REG, SW):
      SET_W_REG (rn, n);
      break;
    case X (OP_REG, SL):
      SET_L_REG (rn, n);
      break;
d592 3
a594 5
    case X (OP_DEC, SB):
      t = GET_L_REG (rn) - 1;
      t &= cpu.mask;
      SET_L_REG (rn, t);
      SET_MEMORY_B (t, n);
d596 4
a599 6
      break;
    case X (OP_DEC, SW):
      t = (GET_L_REG (rn) - 2) & cpu.mask;
      SET_L_REG (rn, t);
      SET_MEMORY_W (t, n);
      break;
d601 3
a603 5
    case X (OP_DEC, SL):
      t = (GET_L_REG (rn) - 4) & cpu.mask;
      SET_L_REG (rn, t);
      SET_MEMORY_L (t, n);
      break;
d605 11
a615 5
    case X (OP_DISP, SB):
      t = GET_L_REG (rn) + abs;
      t &= cpu.mask;
      SET_MEMORY_B (t, n);
      break;
d617 7
a623 5
    case X (OP_DISP, SW):
      t = GET_L_REG (rn) + abs;
      t &= cpu.mask;
      SET_MEMORY_W (t, n);
      break;
d625 2
a626 9
    case X (OP_DISP, SL):
      t = GET_L_REG (rn) + abs;
      t &= cpu.mask;
      SET_MEMORY_L (t, n);
      break;
    default:
      abort ();
    }
}
d628 4
d633 7
a639 10
static union
{
  short int i;
  struct
    {
      char low;
      char high;
    }
  u;
}
d641 2
a642 1
littleendian;
d644 4
a647 4
static void
init_pointers (void)
{
  static int init;
d649 7
a655 3
  if (!init)
    {
      int i;
d657 2
a658 2
      init = 1;
      littleendian.i = 1;
d660 4
a663 9
      if (h8300smode)
	memory_size = H8300S_MSIZE;
      else if (h8300hmode)
	memory_size = H8300H_MSIZE;
      else
	memory_size = H8300_MSIZE;
      cpu.memory = (unsigned char *) calloc (sizeof (char), memory_size);
      cpu.cache_idx = (unsigned short *) calloc (sizeof (short), memory_size);
      cpu.eightbit = (unsigned char *) calloc (sizeof (char), 256);
d665 7
a671 4
      /* `msize' must be a power of two.  */
      if ((memory_size & (memory_size - 1)) != 0)
	abort ();
      cpu.mask = memory_size - 1;
d673 2
a674 4
      for (i = 0; i < 9; i++)
	{
	  cpu.regs[i] = 0;
	}
d676 1
a676 10
      for (i = 0; i < 8; i++)
	{
	  unsigned char *p = (unsigned char *) (cpu.regs + i);
	  unsigned char *e = (unsigned char *) (cpu.regs + i + 1);
	  unsigned short *q = (unsigned short *) (cpu.regs + i);
	  unsigned short *u = (unsigned short *) (cpu.regs + i + 1);
	  cpu.regs[i] = 0x00112233;
	  while (p < e)
	    {
	      if (*p == 0x22)
d678 3
a680 1
		  breg[i] = p;
d682 1
a682 1
	      if (*p == 0x33)
d684 1
a684 1
		  breg[i + 8] = p;
d686 1
a686 6
	      p++;
	    }
	  wreg[i] = wreg[i + 8] = 0;
	  while (q < u)
	    {
	      if (*q == 0x2233)
d688 7
a694 1
		  wreg[i] = q;
d696 7
a702 1
	      if (*q == 0x0011)
d704 1
a704 1
		  wreg[i + 8] = q;
d706 21
a726 7
	      q++;
	    }
	  if (wreg[i] == 0 || wreg[i + 8] == 0)
	    abort ();
	  cpu.regs[i] = 0;
	  lreg[i] = &cpu.regs[i];
	}
d728 32
a759 1
      lreg[8] = &cpu.regs[8];
d761 5
a765 5
      /* Initialize the seg registers.  */
      if (!cpu.cache)
	sim_set_simcache_size (CSIZE);
    }
}
d767 70
a836 6
static void
control_c (int sig)
{
  cpu.state = SIM_STATE_STOPPED;
  cpu.exception = SIGINT;
}
d838 9
a846 8
#define C (c != 0)
#define Z (nz == 0)
#define V (v != 0)
#define N (n != 0)
#define U (u != 0)
#define H (h != 0)
#define UI (ui != 0)
#define I (intMaskBit != 0)
d848 65
a912 24
static int
mop (decoded_inst *code, int bsize, int sign)
{
  int multiplier;
  int multiplicand;
  int result;
  int n, nz;

  if (sign)
    {
      multiplicand =
	bsize ? SEXTCHAR (GET_W_REG (code->dst.reg)) :
	SEXTSHORT (GET_W_REG (code->dst.reg));
      multiplier =
	bsize ? SEXTCHAR (GET_B_REG (code->src.reg)) :
	SEXTSHORT (GET_W_REG (code->src.reg));
    }
  else
    {
      multiplicand = bsize ? UEXTCHAR (GET_W_REG (code->dst.reg)) :
	UEXTSHORT (GET_W_REG (code->dst.reg));
      multiplier =
	bsize ? UEXTCHAR (GET_B_REG (code->src.reg)) :
	UEXTSHORT (GET_W_REG (code->src.reg));
d914 6
a919 2
    }
  result = multiplier * multiplicand;
d921 8
a928 17
  if (sign)
    {
      n = result & (bsize ? 0x8000 : 0x80000000);
      nz = result & (bsize ? 0xffff : 0xffffffff);
    }
  if (bsize)
    {
      SET_W_REG (code->dst.reg, result);
    }
  else
    {
      SET_L_REG (code->dst.reg, result);
    }
#if 0
  return ((n == 1) << 1) | (nz == 1);
#endif
}
d930 140
a1069 25
#define ONOT(name, how) \
case O (name, SB):				\
{						\
  int t;					\
  int hm = 0x80;				\
  rd = GET_B_REG (code->src.reg);		\
  how; 						\
  goto shift8;					\
} 						\
case O (name, SW):				\
{ 						\
  int t;					\
  int hm = 0x8000;				\
  rd = GET_W_REG (code->src.reg); 		\
  how; 						\
  goto shift16;					\
} 						\
case O (name, SL):				\
{						\
  int t;					\
  int hm = 0x80000000; 				\
  rd = GET_L_REG (code->src.reg);		\
  how; 						\
  goto shift32;					\
}
d1071 130
a1200 45
#define OSHIFTS(name, how1, how2) \
case O (name, SB):				\
{						\
  int t;					\
  int hm = 0x80;				\
  rd = GET_B_REG (code->src.reg);		\
  if ((GET_MEMORY_B (pc + 1) & 0x40) == 0)	\
    {						\
      how1;					\
    }						\
  else						\
    {						\
      how2;					\
    }						\
  goto shift8;					\
} 						\
case O (name, SW):				\
{ 						\
  int t;					\
  int hm = 0x8000;				\
  rd = GET_W_REG (code->src.reg); 		\
  if ((GET_MEMORY_B (pc + 1) & 0x40) == 0)	\
    {						\
      how1;					\
    }						\
  else						\
    {						\
      how2;					\
    }						\
  goto shift16;					\
} 						\
case O (name, SL):				\
{						\
  int t;					\
  int hm = 0x80000000; 				\
  rd = GET_L_REG (code->src.reg);		\
  if ((GET_MEMORY_B (pc + 1) & 0x40) == 0)	\
    {						\
      how1;					\
    }						\
  else						\
    {						\
      how2;					\
    }						\
  goto shift32;					\
d1203 39
a1241 9
#define OBITOP(name,f, s, op) 			\
case O (name, SB):				\
{						\
  int m;					\
  int b; 					\
  if (f) ea = fetch (&code->dst);		\
  m=1<< fetch (&code->src);			\
  op;						\
  if (s) store (&code->dst,ea); goto next;	\
d1244 5
a1248 6
int
sim_stop (SIM_DESC sd)
{
  cpu.state = SIM_STATE_STOPPED;
  cpu.exception = SIGINT;
  return 1;
d1251 7
a1257 21
#define R0_REGNUM	0
#define R1_REGNUM	1
#define R2_REGNUM	2
#define R3_REGNUM	3
#define R4_REGNUM	4
#define R5_REGNUM	5
#define R6_REGNUM	6
#define R7_REGNUM	7

#define SP_REGNUM       R7_REGNUM	/* Contains address of top of stack */
#define FP_REGNUM       R6_REGNUM	/* Contains address of executing
					 * stack frame */

#define CCR_REGNUM      8	/* Contains processor status */
#define PC_REGNUM       9	/* Contains program counter */

#define CYCLE_REGNUM    10

#define EXR_REGNUM	11
#define INST_REGNUM     12
#define TICK_REGNUM     13
d1259 2
a1260 2
void
sim_resume (SIM_DESC sd, int step, int siggnal)
d1262 4
a1265 16
  static int init1;
  int cycles = 0;
  int insts = 0;
  int tick_start = get_now ();
  void (*prev) ();
  int poll_count = 0;
  int res;
  int tmp;
  int rd;
  int ea;
  int bit;
  int pc;
  int c, nz, v, n, u, h, ui, intMaskBit;
  int trace, intMask;
  int oldmask;
  init_pointers ();
d1267 2
a1268 1
  prev = signal (SIGINT, control_c);
d1270 1
a1270 1
  if (step)
d1272 209
a1480 2
      cpu.state = SIM_STATE_STOPPED;
      cpu.exception = SIGTRAP;
d1482 33
a1514 1
  else
d1516 52
a1567 3
      cpu.state = SIM_STATE_RUNNING;
      cpu.exception = 0;
    }
d1569 7
a1575 1
  pc = cpu.pc;
d1577 9
a1585 3
  /* The PC should never be odd.  */
  if (pc & 0x1)
    abort ();
d1587 8
a1594 2
  GETSR ();
  GETEXR ();
d1596 7
a1602 7
  oldmask = cpu.mask;
  if (!h8300hmode)
    cpu.mask = 0xffff;
  do
    {
      int cidx;
      decoded_inst *code;
d1604 9
a1612 3
    top:
      cidx = cpu.cache_idx[pc];
      code = cpu.cache + cidx;
d1614 8
d1623 5
a1627 4
#define ALUOP(STORE, NAME, HOW) \
    case O (NAME, SB): HOW; if (STORE) goto alu8;  else goto just_flags_alu8;  \
    case O (NAME, SW): HOW; if (STORE) goto alu16; else goto just_flags_alu16; \
    case O (NAME, SL): HOW; if (STORE) goto alu32; else goto just_flags_alu32;
d1629 1328
d2958 3
a2960 4
#define LOGOP(NAME, HOW)			\
    case O (NAME, SB): HOW; goto log8;		\
    case O (NAME, SW): HOW; goto log16;		\
    case O (NAME, SL): HOW; goto log32;
d2962 3
d2966 4
d2971 4
a2974 7
#if ADEBUG
      if (debug)
	{
	  printf ("%x %d %s\n", pc, code->opcode,
		  code->op ? code->op->name : "**");
	}
      cpu.stats[code->opcode]++;
d2976 1
a2976 1
#endif
d2978 2
a2979 5
      if (code->opcode)
	{
	  cycles += code->cycles;
	  insts++;
	}
d2981 4
a2984 10
      switch (code->opcode)
	{
	case 0:
	  /*
	   * This opcode is a fake for when we get to an
	   * instruction which hasnt been compiled
	   */
	  compile (pc);
	  goto top;
	  break;
d2986 7
d2994 1
a2994 6
	case O (O_SUBX, SB):
	  rd = fetch (&code->dst);
	  ea = fetch (&code->src);
	  ea = -(ea + C);
	  res = rd + ea;
	  goto alu8;
d2996 2
a2997 6
	case O (O_ADDX, SB):
	  rd = fetch (&code->dst);
	  ea = fetch (&code->src);
	  ea = C + ea;
	  res = rd + ea;
	  goto alu8;
d2999 2
a3000 2
#define EA    ea = fetch (&code->src);
#define RD_EA ea = fetch (&code->src); rd = fetch (&code->dst);
d3002 2
a3003 23
	  ALUOP (1, O_SUB, RD_EA;
		 ea = -ea;
		 res = rd + ea);
	  ALUOP (1, O_NEG, EA;
		 ea = -ea;
		 rd = 0;
		 res = rd + ea);

	case O (O_ADD, SB):
	  rd = GET_B_REG (code->dst.reg);
	  ea = fetch (&code->src);
	  res = rd + ea;
	  goto alu8;
	case O (O_ADD, SW):
	  rd = GET_W_REG (code->dst.reg);
	  ea = fetch (&code->src);
	  res = rd + ea;
	  goto alu16;
	case O (O_ADD, SL):
	  rd = GET_L_REG (code->dst.reg);
	  ea = fetch (&code->src);
	  res = rd + ea;
	  goto alu32;
d3005 22
d3028 4
a3031 2
	  LOGOP (O_AND, RD_EA;
		 res = rd & ea);
d3033 11
a3043 2
	  LOGOP (O_OR, RD_EA;
		 res = rd | ea);
d3045 2
a3046 2
	  LOGOP (O_XOR, RD_EA;
		 res = rd ^ ea);
d3048 2
d3051 6
a3056 9
	case O (O_MOV_TO_MEM, SB):
	  res = GET_B_REG (code->src.reg);
	  goto log8;
	case O (O_MOV_TO_MEM, SW):
	  res = GET_W_REG (code->src.reg);
	  goto log16;
	case O (O_MOV_TO_MEM, SL):
	  res = GET_L_REG (code->src.reg);
	  goto log32;
d3058 2
d3061 6
a3066 12
	case O (O_MOV_TO_REG, SB):
	  res = fetch (&code->src);
	  SET_B_REG (code->dst.reg, res);
	  goto just_flags_log8;
	case O (O_MOV_TO_REG, SW):
	  res = fetch (&code->src);
	  SET_W_REG (code->dst.reg, res);
	  goto just_flags_log16;
	case O (O_MOV_TO_REG, SL):
	  res = fetch (&code->src);
	  SET_L_REG (code->dst.reg, res);
	  goto just_flags_log32;
d3068 3
a3070 8
	case O (O_EEPMOV, SB):
	case O (O_EEPMOV, SW):
	  if (h8300hmode || h8300smode)
	    {
	      register unsigned char *_src, *_dst;
	      unsigned int count = ((code->opcode == O (O_EEPMOV, SW))
				    ? cpu.regs[R4_REGNUM] & 0xffff
				    : cpu.regs[R4_REGNUM] & 0xff);
d3072 3
a3074 31
	      _src = (cpu.regs[R5_REGNUM] < memory_size
		      ? cpu.memory + cpu.regs[R5_REGNUM]
		      : cpu.eightbit + (cpu.regs[R5_REGNUM] & 0xff));
	      if ((_src + count) >= (cpu.memory + memory_size))
		{
		  if ((_src + count) >= (cpu.eightbit + 0x100))
		    goto illegal;
		}
	      _dst = (cpu.regs[R6_REGNUM] < memory_size
		      ? cpu.memory + cpu.regs[R6_REGNUM]
		      : cpu.eightbit + (cpu.regs[R6_REGNUM] & 0xff));
	      if ((_dst + count) >= (cpu.memory + memory_size))
		{
		  if ((_dst + count) >= (cpu.eightbit + 0x100))
		    goto illegal;
		}
	      memcpy (_dst, _src, count);

	      cpu.regs[R5_REGNUM] += count;
	      cpu.regs[R6_REGNUM] += count;
	      cpu.regs[R4_REGNUM] &= ((code->opcode == O (O_EEPMOV, SW))
				      ? (~0xffff) : (~0xff));
	      cycles += 2 * count;
	      goto next;
	    }
	  goto illegal;

	case O (O_ADDS, SL):
	  SET_L_REG (code->dst.reg,
		     GET_L_REG (code->dst.reg)
		     + code->src.literal);
d3076 32
d3109 1
d3111 6
a3116 5
	case O (O_SUBS, SL):
	  SET_L_REG (code->dst.reg,
		     GET_L_REG (code->dst.reg)
		     - code->src.literal);
	  goto next;
d3118 6
a3123 6
	case O (O_CMP, SB):
	  rd = fetch (&code->dst);
	  ea = fetch (&code->src);
	  ea = -ea;
	  res = rd + ea;
	  goto just_flags_alu8;
d3125 11
a3135 6
	case O (O_CMP, SW):
	  rd = fetch (&code->dst);
	  ea = fetch (&code->src);
	  ea = -ea;
	  res = rd + ea;
	  goto just_flags_alu16;
d3137 4
a3140 6
	case O (O_CMP, SL):
	  rd = fetch (&code->dst);
	  ea = fetch (&code->src);
	  ea = -ea;
	  res = rd + ea;
	  goto just_flags_alu32;
d3142 13
d3156 4
a3159 6
	case O (O_DEC, SB):
	  rd = GET_B_REG (code->src.reg);
	  ea = -1;
	  res = rd + ea;
	  SET_B_REG (code->src.reg, res);
	  goto just_flags_inc8;
d3161 4
a3164 6
	case O (O_DEC, SW):
	  rd = GET_W_REG (code->dst.reg);
	  ea = -code->src.literal;
	  res = rd + ea;
	  SET_W_REG (code->dst.reg, res);
	  goto just_flags_inc16;
d3166 13
a3178 6
	case O (O_DEC, SL):
	  rd = GET_L_REG (code->dst.reg);
	  ea = -code->src.literal;
	  res = rd + ea;
	  SET_L_REG (code->dst.reg, res);
	  goto just_flags_inc32;
d3180 4
d3185 4
a3188 23
	case O (O_INC, SB):
	  rd = GET_B_REG (code->src.reg);
	  ea = 1;
	  res = rd + ea;
	  SET_B_REG (code->src.reg, res);
	  goto just_flags_inc8;

	case O (O_INC, SW):
	  rd = GET_W_REG (code->dst.reg);
	  ea = code->src.literal;
	  res = rd + ea;
	  SET_W_REG (code->dst.reg, res);
	  goto just_flags_inc16;

	case O (O_INC, SL):
	  rd = GET_L_REG (code->dst.reg);
	  ea = code->src.literal;
	  res = rd + ea;
	  SET_L_REG (code->dst.reg, res);
	  goto just_flags_inc32;

#define GET_CCR(x) BUILDSR();x = cpu.ccr
#define GET_EXR(x) BUILDEXR ();x = cpu.exr
d3190 1
a3190 7
	case O (O_LDC, SB):
	case O (O_LDC, SW):
	  res = fetch (&code->src);
	  goto setc;
	case O (O_STC, SB):
	case O (O_STC, SW):
	  if (code->src.type == OP_CCR)
d3192 3
a3194 1
	      GET_CCR (res);
d3196 1
a3196 1
	  else if (code->src.type == OP_EXR && h8300smode)
d3198 3
a3200 1
	      GET_EXR (res);
d3202 9
d3212 1
a3212 3
	    goto illegal;
	  store (&code->dst, res);
	  goto next;
d3214 1
a3214 2
	case O (O_ANDC, SB):
	  if (code->dst.type == OP_CCR)
d3216 5
a3220 1
	      GET_CCR (rd);
d3222 1
a3222 1
	  else if (code->dst.type == OP_EXR && h8300smode)
d3224 3
a3226 1
	      GET_EXR (rd);
d3228 9
d3238 1
a3238 4
	    goto illegal;
	  ea = code->src.literal;
	  res = rd & ea;
	  goto setc;
d3240 1
a3240 2
	case O (O_ORC, SB):
	  if (code->dst.type == OP_CCR)
d3242 5
a3246 1
	      GET_CCR (rd);
d3248 1
a3248 1
	  else if (code->dst.type == OP_EXR && h8300smode)
d3250 3
a3252 1
	      GET_EXR (rd);
d3254 9
d3264 1
a3264 4
	    goto illegal;
	  ea = code->src.literal;
	  res = rd | ea;
	  goto setc;
d3266 1
a3266 2
	case O (O_XORC, SB):
	  if (code->dst.type == OP_CCR)
d3268 5
a3272 1
	      GET_CCR (rd);
d3274 1
a3274 1
	  else if (code->dst.type == OP_EXR && h8300smode)
d3276 3
a3278 1
	      GET_EXR (rd);
d3280 1
a3280 5
	  else
	    goto illegal;
	  ea = code->src.literal;
	  res = rd ^ ea;
	  goto setc;
d3282 4
d3287 4
a3290 4
	case O (O_BRA, SB):
	  if (1)
	    goto condtrue;
	  goto next;
d3292 15
a3306 4
	case O (O_BRN, SB):
	  if (0)
	    goto condtrue;
	  goto next;
d3308 2
a3309 4
	case O (O_BHI, SB):
	  if ((C || Z) == 0)
	    goto condtrue;
	  goto next;
d3311 4
d3316 4
a3319 4
	case O (O_BLS, SB):
	  if ((C || Z))
	    goto condtrue;
	  goto next;
d3321 15
a3335 4
	case O (O_BCS, SB):
	  if ((C == 1))
	    goto condtrue;
	  goto next;
d3337 2
a3338 4
	case O (O_BCC, SB):
	  if ((C == 0))
	    goto condtrue;
	  goto next;
d3340 4
a3343 8
	case O (O_BEQ, SB):
	  if (Z)
	    goto condtrue;
	  goto next;
	case O (O_BGT, SB):
	  if (((Z || (N ^ V)) == 0))
	    goto condtrue;
	  goto next;
d3345 4
d3350 15
a3364 4
	case O (O_BLE, SB):
	  if (((Z || (N ^ V)) == 1))
	    goto condtrue;
	  goto next;
d3366 2
a3367 16
	case O (O_BGE, SB):
	  if ((N ^ V) == 0)
	    goto condtrue;
	  goto next;
	case O (O_BLT, SB):
	  if ((N ^ V))
	    goto condtrue;
	  goto next;
	case O (O_BMI, SB):
	  if ((N))
	    goto condtrue;
	  goto next;
	case O (O_BNE, SB):
	  if ((Z == 0))
	    goto condtrue;
	  goto next;
d3369 4
a3372 12
	case O (O_BPL, SB):
	  if (N == 0)
	    goto condtrue;
	  goto next;
	case O (O_BVC, SB):
	  if ((V == 0))
	    goto condtrue;
	  goto next;
	case O (O_BVS, SB):
	  if ((V == 1))
	    goto condtrue;
	  goto next;
d3374 4
a3377 23
	/* Trap for Command Line setup.  */
	case O (O_SYS_CMDLINE, SB):
	  {
	    int i = 0;		/* Loop counter.  */
	    int j = 0;		/* Loop counter.  */
	    int ind_arg_len = 0;	/* Length of each argument.  */
	    int no_of_args = 0;	/* The no. or cmdline args.  */
	    int current_location = 0;	/* Location of string.  */
	    int old_sp = 0;	/* The Initial Stack Pointer.  */
	    int no_of_slots = 0;	/* No. of slots required on the stack
					   for storing cmdline args.  */
	    int sp_move = 0;	/* No. of locations by which the stack needs
				   to grow.  */
	    int new_sp = 0;	/* The final stack pointer location passed
				   back.  */
	    int *argv_ptrs;	/* Pointers of argv strings to be stored.  */
	    int argv_ptrs_location = 0;	/* Location of pointers to cmdline
					   args on the stack.  */
	    int char_ptr_size = 0;	/* Size of a character pointer on
					   target machine.  */
	    int addr_cmdline = 0;	/* Memory location where cmdline has
					   to be stored.  */
	    int size_cmdline = 0;	/* Size of cmdline.  */
d3379 17
a3395 4
	    /* Set the address of 256 free locations where command line is
	       stored.  */
	    addr_cmdline = cmdline_location();
	    cpu.regs[0] = addr_cmdline;
d3397 2
a3398 3
	    /* Counting the no. of commandline arguments.  */
	    for (i = 0; ptr_command_line[i] != NULL; i++)
	      continue;
d3400 4
a3403 2
	    /* No. of arguments in the command line.  */
	    no_of_args = i;
d3405 4
a3408 7
	    /* Current location is just a temporary variable,which we are
	       setting to the point to the start of our commandline string.  */
	    current_location = addr_cmdline;

	    /* Allocating space for storing pointers of the command line
	       arguments.  */
	    argv_ptrs = (int *) malloc (sizeof (int) * no_of_args);
d3410 2
a3411 3
	    /* Setting char_ptr_size to the sizeof (char *) on the different
	       architectures.  */
	    if (h8300hmode || h8300smode)
d3413 5
a3417 1
		char_ptr_size = 4;
d3421 5
a3425 1
		char_ptr_size = 2;
d3428 2
a3429 3
	    for (i = 0; i < no_of_args; i++)
	      {
		ind_arg_len = 0;
d3431 4
a3434 2
		/* The size of the commandline argument.  */
		ind_arg_len = (strlen (ptr_command_line[i]) + 1);
d3436 4
a3439 2
		/* The total size of the command line string.  */
		size_cmdline += ind_arg_len;
d3441 16
a3456 26
		/* As we have only 256 bytes, we need to provide a graceful
		   exit. Anyways, a program using command line arguments 
		   where we cannot store all the command line arguments
		   given may behave unpredictably.  */
		if (size_cmdline >= 256)
		  {
		    cpu.regs[0] = 0;
		    goto next;
		  }
		else
		  {
		    /* current_location points to the memory where the next
		       commandline argument is stored.  */
		    argv_ptrs[i] = current_location;
		    for (j = 0; j < ind_arg_len; j++)
		      {
			SET_MEMORY_B ((current_location +
				       (sizeof (char) * j)),
				      *(ptr_command_line[i] + 
				       sizeof (char) * j));
		      }

		    /* Setting current_location to the starting of next
		       argument.  */
		    current_location += ind_arg_len;
		  }
d3459 2
a3460 2
	    /* This is the original position of the stack pointer.  */
	    old_sp = cpu.regs[7];
d3462 8
a3469 5
	    /* We need space from the stack to store the pointers to argvs.  */
	    /* As we will infringe on the stack, we need to shift the stack
	       pointer so that the data is not overwritten. We calculate how
	       much space is required.  */
	    sp_move = (no_of_args) * (char_ptr_size);
d3471 10
a3480 3
	    /* The final position of stack pointer, we have thus taken some
	       space from the stack.  */
	    new_sp = old_sp - sp_move;
d3482 1
a3482 7
	    /* Temporary variable holding value where the argv pointers need
	       to be stored.  */
	    argv_ptrs_location = new_sp;

	    /* The argv pointers are stored at sequential locations. As per
	       the H8300 ABI.  */
	    for (i = 0; i < no_of_args; i++)
d3484 2
a3485 20
		/* Saving the argv pointer.  */
		if (h8300hmode || h8300smode)
		  {
		    SET_MEMORY_L (argv_ptrs_location, argv_ptrs[i]);
		  }
		else
		  {
		    SET_MEMORY_W (argv_ptrs_location, argv_ptrs[i]);
		  }
	
		/* The next location where the pointer to the next argv
		   string has to be stored.  */    
		argv_ptrs_location += char_ptr_size;
	      }

	    /* Required by POSIX, Setting 0x0 at the end of the list of argv
	       pointers.  */
	    if (h8300hmode || h8300smode)
	      {
		SET_MEMORY_L (old_sp, 0x0);
d3489 2
a3490 1
		SET_MEMORY_W (old_sp, 0x0);
d3492 1
d3494 2
a3495 7
	    /* Freeing allocated memory.  */
	    free (argv_ptrs);
	    for (i = 0; i <= no_of_args; i++)
	      {
		free (ptr_command_line[i]);
	      }
	    free (ptr_command_line);
d3497 7
a3503 8
	    /* The no. of argv arguments are returned in Reg 0.  */
	    cpu.regs[0] = no_of_args;
	    /* The Pointer to argv in Register 1.  */
	    cpu.regs[1] = new_sp;
	    /* Setting the stack pointer to the new value.  */
	    cpu.regs[7] = new_sp;
	  }
	  goto next;
d3505 1
a3505 2
	  /* System call processing starts.  */
	case O (O_SYS_OPEN, SB):
d3507 1
a3507 7
	    int len = 0;	/* Length of filename.  */
	    char *filename;	/* Filename would go here.  */
	    char temp_char;	/* Temporary character */
	    int mode = 0;	/* Mode bits for the file.  */
	    int open_return;	/* Return value of open, file descriptor.  */
	    int i;		/* Loop counter */
	    int filename_ptr;	/* Pointer to filename in cpu memory.  */
d3509 1
a3509 2
	    /* Setting filename_ptr to first argument of open.  */
	    filename_ptr = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);
d3511 4
a3514 4
	    /* Trying to get mode.  */
	    if (h8300hmode || h8300smode)
	      {
		mode = GET_MEMORY_L (cpu.regs[7] + 4);
d3518 2
a3519 1
		mode = GET_MEMORY_W (cpu.regs[7] + 2);
d3522 7
a3528 2
	    /* Trying to find the length of the filename.  */
	    temp_char = GET_MEMORY_B (cpu.regs[0]);
d3530 16
a3545 6
	    len = 1;
	    while (temp_char != '\0')
	      {
		temp_char = GET_MEMORY_B (filename_ptr + len);
		len++;
	      }
d3547 3
a3549 2
	    /* Allocating space for the filename.  */
	    filename = (char *) malloc (sizeof (char) * len);
d3551 4
a3554 6
	    /* String copying the filename from memory.  */
	    for (i = 0; i < len; i++)
	      {
		temp_char = GET_MEMORY_B (filename_ptr + i);
		filename[i] = temp_char;
	      }
d3556 4
a3559 2
	    /* Callback to open and return the file descriptor.  */
	    open_return = sim_callback->open (sim_callback, filename, mode);
d3561 4
a3564 2
	    /* Return value in register 0.  */
	    cpu.regs[0] = open_return;
d3566 3
a3568 3
	    /* Freeing memory used for filename. */
	    free (filename);
	  }
d3571 22
a3592 8
	case O (O_SYS_READ, SB):
	  {
	    char *char_ptr;	/* Where characters read would be stored.  */
	    int fd;		/* File descriptor */
	    int buf_size;	/* BUF_SIZE parameter in read.  */
	    int i = 0;		/* Temporary Loop counter */
	    int read_return = 0;	/* Return value from callback to
					   read.  */
d3594 5
a3598 2
	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);
	    buf_size = h8300hmode ? GET_L_REG (2) : GET_W_REG (2);
d3600 4
a3603 1
	    char_ptr = (char *) malloc (sizeof (char) * buf_size);
d3605 9
a3613 3
	    /* Callback to read and return the no. of characters read.  */
	    read_return =
	      sim_callback->read (sim_callback, fd, char_ptr, buf_size);
d3615 1
a3615 6
	    /* The characters read are stored in cpu memory.  */
	    for (i = 0; i < buf_size; i++)
	      {
		SET_MEMORY_B ((cpu.regs[1] + (sizeof (char) * i)),
			      *(char_ptr + (sizeof (char) * i)));
	      }
d3617 5
a3621 2
	    /* Return value in Register 0.  */
	    cpu.regs[0] = read_return;
d3623 4
a3626 4
	    /* Freeing memory used as buffer.  */
	    free (char_ptr);
	  }
	  goto next;
d3628 2
a3629 10
	case O (O_SYS_WRITE, SB):
	  {
	    int fd;		/* File descriptor */
	    char temp_char;	/* Temporary character */
	    int len;		/* Length of write, Parameter II to write.  */
	    int char_ptr;	/* Character Pointer, Parameter I of write.  */
	    char *ptr;		/* Where characters to be written are stored. 
				 */
	    int write_return;	/* Return value from callback to write.  */
	    int i = 0;		/* Loop counter */
d3631 2
a3632 3
	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);
	    char_ptr = h8300hmode ? GET_L_REG (1) : GET_W_REG (1);
	    len = h8300hmode ? GET_L_REG (2) : GET_W_REG (2);
d3634 3
a3636 2
	    /* Allocating space for the characters to be written.  */
	    ptr = (char *) malloc (sizeof (char) * len);
d3638 2
a3639 6
	    /* Fetching the characters from cpu memory.  */
	    for (i = 0; i < len; i++)
	      {
		temp_char = GET_MEMORY_B (char_ptr + i);
		ptr[i] = temp_char;
	      }
d3641 4
a3644 2
	    /* Callback write and return the no. of characters written.  */
	    write_return = sim_callback->write (sim_callback, fd, ptr, len);
d3646 7
a3652 2
	    /* Return value in Register 0.  */
	    cpu.regs[0] = write_return;
d3654 11
a3664 2
	    /* Freeing memory used as buffer.  */
	    free (ptr);
d3666 3
a3668 1
	  goto next;
d3670 2
a3671 6
	case O (O_SYS_LSEEK, SB):
	  {
	    int fd;		/* File descriptor */
	    int offset;		/* Offset */
	    int origin;		/* Origin */
	    int lseek_return;	/* Return value from callback to lseek.  */
d3673 1
a3673 3
	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);
	    offset = h8300hmode ? GET_L_REG (1) : GET_W_REG (1);
	    origin = h8300hmode ? GET_L_REG (2) : GET_W_REG (2);
d3675 3
a3677 3
	    /* Callback lseek and return offset.  */
	    lseek_return =
	      sim_callback->lseek (sim_callback, fd, offset, origin);
d3679 9
a3687 2
	    /* Return value in register 0.  */
	    cpu.regs[0] = lseek_return;
d3689 1
d3692 8
a3699 4
	case O (O_SYS_CLOSE, SB):
	  {
	    int fd;		/* File descriptor */
	    int close_return;	/* Return value from callback to close.  */
d3701 3
a3703 1
	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);
d3705 2
a3706 2
	    /* Callback close and return.  */
	    close_return = sim_callback->close (sim_callback, fd);
d3708 26
a3733 3
	    /* Return value in register 0.  */
	    cpu.regs[0] = close_return;
	  }
d3736 13
a3748 7
	case O (O_SYS_FSTAT, SB):
	  {
	    int fd;		/* File descriptor */
	    struct stat stat_rec;	/* Stat record */
	    int fstat_return;	/* Return value from callback to stat.  */
	    int stat_ptr;	/* Pointer to stat record.  */
	    char *temp_stat_ptr;	/* Temporary stat_rec pointer.  */
d3750 4
a3753 1
	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);
d3755 1
a3755 2
	    /* Setting stat_ptr to second argument of stat.  */
	    stat_ptr = h8300hmode ? GET_L_REG (1) : GET_W_REG (1);
d3757 4
a3760 2
	    /* Callback stat and return.  */
	    fstat_return = sim_callback->fstat (sim_callback, fd, &stat_rec);
d3762 12
a3773 2
	    /* Have stat_ptr point to starting of stat_rec.  */
	    temp_stat_ptr = (char *) (&stat_rec);
d3775 4
a3778 22
	    /* Setting up the stat structure returned.  */
	    SET_MEMORY_W (stat_ptr, stat_rec.st_dev);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_ino);
	    stat_ptr += 2;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_mode);
	    stat_ptr += 4;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_nlink);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_uid);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_gid);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_rdev);
	    stat_ptr += 2;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_size);
	    stat_ptr += 4;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_atime);
	    stat_ptr += 8;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_mtime);
	    stat_ptr += 8;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_ctime);
d3780 12
a3791 3
	    /* Return value in register 0.  */
	    cpu.regs[0] = fstat_return;
	  }
d3794 4
a3797 11
	case O (O_SYS_STAT, SB):
	  {
	    int len = 0;	/* Length of filename.  */
	    char *filename;	/* Filename would go here.  */
	    char temp_char;	/* Temporary character */
	    int filename_ptr;	/* Pointer to filename in cpu memory.  */
	    struct stat stat_rec;	/* Stat record */
	    int stat_return;	/* Return value from callback to stat */
	    int stat_ptr;	/* Pointer to stat record.  */
	    char *temp_stat_ptr;	/* Temporary stat_rec pointer.  */
	    int i = 0;		/* Loop Counter */
d3799 1
a3799 2
	    /* Setting filename_ptr to first argument of open.  */
	    filename_ptr = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);
d3801 3
a3803 2
	    /* Trying to find the length of the filename.  */
	    temp_char = GET_MEMORY_B (cpu.regs[0]);
d3805 1
a3805 6
	    len = 1;
	    while (temp_char != '\0')
	      {
		temp_char = GET_MEMORY_B (filename_ptr + len);
		len++;
	      }
d3807 4
a3810 2
	    /* Allocating space for the filename.  */
	    filename = (char *) malloc (sizeof (char) * len);
d3812 1
a3812 6
	    /* String copying the filename from memory.  */
	    for (i = 0; i < len; i++)
	      {
		temp_char = GET_MEMORY_B (filename_ptr + i);
		filename[i] = temp_char;
	      }
d3814 3
a3816 3
	    /* Setting stat_ptr to second argument of stat.  */
	    /* stat_ptr = cpu.regs[1]; */
	    stat_ptr = h8300hmode ? GET_L_REG (1) : GET_W_REG (1);
d3818 1
a3818 3
	    /* Callback stat and return.  */
	    stat_return =
	      sim_callback->stat (sim_callback, filename, &stat_rec);
d3820 4
a3823 2
	    /* Have stat_ptr point to starting of stat_rec.  */
	    temp_stat_ptr = (char *) (&stat_rec);
d3825 3
a3827 2
	    /* Freeing memory used for filename.  */
	    free (filename);
d3829 3
a3831 22
	    /* Setting up the stat structure returned.  */
	    SET_MEMORY_W (stat_ptr, stat_rec.st_dev);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_ino);
	    stat_ptr += 2;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_mode);
	    stat_ptr += 4;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_nlink);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_uid);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_gid);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_rdev);
	    stat_ptr += 2;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_size);
	    stat_ptr += 4;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_atime);
	    stat_ptr += 8;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_mtime);
	    stat_ptr += 8;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_ctime);
a3832 3
	    /* Return value in register 0.  */
	    cpu.regs[0] = stat_return;
	  }
a3833 1
	  /* End of system call processing.  */
d3835 20
a3854 25
	  ONOT (O_NOT, rd = ~rd; v = 0;);
	  OSHIFTS (O_SHLL,
		   c = rd & hm; v = 0; rd <<= 1,
		   c = rd & (hm >> 1); v = 0; rd <<= 2);
	  OSHIFTS (O_SHLR,
		   c = rd & 1; v = 0; rd = (unsigned int) rd >> 1,
		   c = rd & 2; v = 0; rd = (unsigned int) rd >> 2);
	  OSHIFTS (O_SHAL,
		   c = rd & hm; v = (rd & hm) != ((rd & (hm >> 1)) << 1); rd <<= 1,
		   c = rd & (hm >> 1); v = (rd & (hm >> 1)) != ((rd & (hm >> 2)) << 2); rd <<= 2);
	  OSHIFTS (O_SHAR,
		   t = rd & hm; c = rd & 1; v = 0; rd >>= 1; rd |= t,
		   t = rd & hm; c = rd & 2; v = 0; rd >>= 2; rd |= t | t >> 1);
	  OSHIFTS (O_ROTL,
		   c = rd & hm; v = 0; rd <<= 1; rd |= C,
		   c = rd & hm; v = 0; rd <<= 1; rd |= C; c = rd & hm; rd <<= 1; rd |= C);
	  OSHIFTS (O_ROTR,
		   c = rd & 1; v = 0; rd = (unsigned int) rd >> 1; if (c) rd |= hm,
		   c = rd & 1; v = 0; rd = (unsigned int) rd >> 1; if (c) rd |= hm; c = rd & 1; rd = (unsigned int) rd >> 1; if (c) rd |= hm);
	  OSHIFTS (O_ROTXL,
		   t = rd & hm; rd <<= 1; rd |= C; c = t; v = 0,
		   t = rd & hm; rd <<= 1; rd |= C; c = t; v = 0; t = rd & hm; rd <<= 1; rd |= C; c = t);
	  OSHIFTS (O_ROTXR,
		   t = rd & 1; rd = (unsigned int) rd >> 1; if (C) rd |= hm; c = t; v = 0,
		   t = rd & 1; rd = (unsigned int) rd >> 1; if (C) rd |= hm; c = t; v = 0; t = rd & 1; rd = (unsigned int) rd >> 1; if (C) rd |= hm; c = t);
d3856 3
a3858 3
	case O (O_JMP, SB):
	  {
	    pc = fetch (&code->src);
d3861 8
a3868 1
	  }
d3870 4
a3873 6
	case O (O_JSR, SB):
	  {
	    int tmp;
	    pc = fetch (&code->src);
	  call:
	    tmp = cpu.regs[7];
d3875 1
a3875 11
	    if (h8300hmode)
	      {
		tmp -= 4;
		SET_MEMORY_L (tmp, code->next_pc);
	      }
	    else
	      {
		tmp -= 2;
		SET_MEMORY_W (tmp, code->next_pc);
	      }
	    cpu.regs[7] = tmp;
d3877 3
a3880 4
	  }
	case O (O_BSR, SB):
	  pc = code->src.literal;
	  goto call;
d3882 1
a3882 3
	case O (O_RTS, SN):
	  {
	    int tmp;
d3884 2
a3885 1
	    tmp = cpu.regs[7];
d3887 1
a3887 10
	    if (h8300hmode)
	      {
		pc = GET_MEMORY_L (tmp);
		tmp += 4;
	      }
	    else
	      {
		pc = GET_MEMORY_W (tmp);
		tmp += 2;
	      }
d3889 3
a3891 1
	    cpu.regs[7] = tmp;
a3892 1
	  }
d3894 1
a3894 21
	case O (O_ILL, SB):
	  cpu.state = SIM_STATE_STOPPED;
	  cpu.exception = SIGILL;
	  goto end;
	case O (O_SLEEP, SN):
	  /* FIXME: Doesn't this break for breakpoints when r0
	     contains just the right (er, wrong) value?  */
	  cpu.state = SIM_STATE_STOPPED;
	  /* The format of r0 is defined by target newlib.  Expand
             the macros here instead of looking for .../sys/wait.h.  */
#define SIM_WIFEXITED(v) (((v) & 0xff) == 0)
#define SIM_WIFSIGNALED(v) (((v) & 0x7f) > 0 && (((v) & 0x7f) < 0x7f))
  	  if (! SIM_WIFEXITED (cpu.regs[0]) && SIM_WIFSIGNALED (cpu.regs[0]))
	    cpu.exception = SIGILL;
	  else
	    cpu.exception = SIGTRAP;
	  goto end;
	case O (O_BPT, SN):
	  cpu.state = SIM_STATE_STOPPED;
	  cpu.exception = SIGTRAP;
	  goto end;
d3896 2
a3897 20
	  OBITOP (O_BNOT, 1, 1, ea ^= m);
	  OBITOP (O_BTST, 1, 0, nz = ea & m);
	  OBITOP (O_BCLR, 1, 1, ea &= ~m);
	  OBITOP (O_BSET, 1, 1, ea |= m);
	  OBITOP (O_BLD, 1, 0, c = ea & m);
	  OBITOP (O_BILD, 1, 0, c = !(ea & m));
	  OBITOP (O_BST, 1, 1, ea &= ~m;
		  if (C) ea |= m);
	  OBITOP (O_BIST, 1, 1, ea &= ~m;
		  if (!C) ea |= m);
	  OBITOP (O_BAND, 1, 0, c = (ea & m) && C);
	  OBITOP (O_BIAND, 1, 0, c = !(ea & m) && C);
	  OBITOP (O_BOR, 1, 0, c = (ea & m) || C);
	  OBITOP (O_BIOR, 1, 0, c = !(ea & m) || C);
	  OBITOP (O_BXOR, 1, 0, c = ((ea & m) != 0) != C);
	  OBITOP (O_BIXOR, 1, 0, c = !(ea & m) != C);

#define MOP(bsize, signed)			\
  mop (code, bsize, signed);			\
  goto next;
d3899 1
a3899 12
	case O (O_MULS, SB):
	  MOP (1, 1);
	  break;
	case O (O_MULS, SW):
	  MOP (0, 1);
	  break;
	case O (O_MULU, SB):
	  MOP (1, 0);
	  break;
	case O (O_MULU, SW):
	  MOP (0, 0);
	  break;
d3901 1
a3901 1
	case O (O_TAS, SB):
d3914 5
a3918 2
	  res = fetch (&code->src);
	  store (&code->src, res | 0x80);
d3921 176
a4096 12
	case O (O_DIVU, SB):
	  {
	    rd = GET_W_REG (code->dst.reg);
	    ea = GET_B_REG (code->src.reg);
	    if (ea)
	      {
		tmp = (unsigned) rd % ea;
		rd = (unsigned) rd / ea;
	      }
	    SET_W_REG (code->dst.reg, (rd & 0xff) | (tmp << 8));
	    n = ea & 0x80;
	    nz = ea & 0xff;
d4098 12
a4109 16
	    goto next;
	  }
	case O (O_DIVU, SW):
	  {
	    rd = GET_L_REG (code->dst.reg);
	    ea = GET_W_REG (code->src.reg);
	    n = ea & 0x8000;
	    nz = ea & 0xffff;
	    if (ea)
	      {
		tmp = (unsigned) rd % ea;
		rd = (unsigned) rd / ea;
	      }
	    SET_L_REG (code->dst.reg, (rd & 0xffff) | (tmp << 16));
	    goto next;
	  }
d4111 4
a4114 2
	case O (O_DIVS, SB):
	  {
d4116 3
a4118 32
	    rd = SEXTSHORT (GET_W_REG (code->dst.reg));
	    ea = SEXTCHAR (GET_B_REG (code->src.reg));
	    if (ea)
	      {
		tmp = (int) rd % (int) ea;
		rd = (int) rd / (int) ea;
		n = rd & 0x8000;
		nz = 1;
	      }
	    else
	      nz = 0;
	    SET_W_REG (code->dst.reg, (rd & 0xff) | (tmp << 8));
	    goto next;
	  }
	case O (O_DIVS, SW):
	  {
	    rd = GET_L_REG (code->dst.reg);
	    ea = SEXTSHORT (GET_W_REG (code->src.reg));
	    if (ea)
	      {
		tmp = (int) rd % (int) ea;
		rd = (int) rd / (int) ea;
		n = rd & 0x80000000;
		nz = 1;
	      }
	    else
	      nz = 0;
	    SET_L_REG (code->dst.reg, (rd & 0xffff) | (tmp << 16));
	    goto next;
	  }
	case O (O_EXTS, SW):
	  rd = GET_W_REG (code->src.reg) & 0xff; /* Yes, src, not dst.  */
d4120 1
a4120 1
	  res = rd + ea;
d4122 18
a4139 2
	case O (O_EXTS, SL):
	  rd = GET_W_REG (code->src.reg) & 0xffff;
d4141 1
a4141 1
	  res = rd + ea;
d4143 4
a4146 2
	case O (O_EXTU, SW):
	  rd = GET_W_REG (code->src.reg) & 0xff;
d4148 1
a4148 1
	  res = rd + ea;
d4150 18
a4167 2
	case O (O_EXTU, SL):
	  rd = GET_W_REG (code->src.reg) & 0xffff;
d4169 1
a4169 1
	  res = rd + ea;
d4172 1
a4172 1
	case O (O_NOP, SN):
d4175 1
a4175 1
	case O (O_STM, SL):
d4182 1
a4182 1
	    firstreg = GET_MEMORY_B (pc + 3);
d4186 2
a4187 2
		cpu.regs[7] -= 4;
		SET_MEMORY_L (cpu.regs[7], cpu.regs[i]);
d4192 1
a4192 1
	case O (O_LDM, SL):
d4199 1
a4199 1
	    firstreg = GET_MEMORY_B (pc + 3);
d4203 2
a4204 2
		cpu.regs[i] = GET_MEMORY_L (cpu.regs[7]);
		cpu.regs[7] += 4;
d4212 2
a4213 2
	  if (!c && (0 <= (res >>  4) && (res >>  4) <= 9) 
	      && !h && (0 <= (res & 0xf) && (res & 0xf) <= 9))
d4215 2
a4216 2
	  else if (!c && (0  <= (res >>  4) && (res >>  4) <=  8) 
		   && !h && (10 <= (res & 0xf) && (res & 0xf) <= 15))
d4218 2
a4219 2
	  else if (!c && (0 <= (res >>  4) && (res >>  4) <= 9) 
		   && h && (0 <= (res & 0xf) && (res & 0xf) <= 3))
d4221 2
a4222 2
	  else if (!c && (10 <= (res >>  4) && (res >>  4) <= 15) 
		   && !h && (0  <= (res & 0xf) && (res & 0xf) <=  9))
d4224 2
a4225 2
	  else if (!c && (9  <= (res >>  4) && (res >>  4) <= 15) 
		   && !h && (10 <= (res & 0xf) && (res & 0xf) <= 15))
d4227 11
a4237 2
	  else if (!c && (10 <= (res >>  4) && (res >>  4) <= 15) 
		   && h && (0  <= (res & 0xf) && (res & 0xf) <=  3))
a4238 9
	  else if (c && (1 <= (res >>  4) && (res >>  4) <= 2) 
		   && !h && (0 <= (res & 0xf) && (res & 0xf) <= 9))
	    res = res + 0x160;		/* Value added == 60, plus 'carry'.  */
	  else if (c && (1  <= (res >>  4) && (res >>  4) <=  2) 
		   && !h && (10 <= (res & 0xf) && (res & 0xf) <= 15))
	    res = res + 0x166;		/* Value added == 66, plus 'carry'.  */
	  else if (c && (1 <= (res >>  4) && (res >>  4) <= 3) 
		   && h && (0 <= (res & 0xf) && (res & 0xf) <= 3))
	    res = res + 0x166;		/* Value added == 66, plus 'carry'.  */
d4245 2
a4246 2
	  if (!c && (0 <= (res >>  4) && (res >>  4) <= 9) 
	      && !h && (0 <= (res & 0xf) && (res & 0xf) <= 9))
d4248 2
a4249 2
	  else if (!c && (0 <= (res >>  4) && (res >>  4) <=  8) 
		   && h && (6 <= (res & 0xf) && (res & 0xf) <= 15))
d4251 2
a4252 2
	  else if (c && (7 <= (res >>  4) && (res >>  4) <= 15) 
		   && !h && (0 <= (res & 0xf) && (res & 0xf) <=  9))
d4254 2
a4255 2
	  else if (c && (6 <= (res >>  4) && (res >>  4) <= 15) 
		   && h && (6 <= (res & 0xf) && (res & 0xf) <= 15))
d4262 1
a4262 2
	  cpu.state = SIM_STATE_STOPPED;
	  cpu.exception = SIGILL;
d4266 5
a4270 1
      abort ();
d4273 2
a4274 1
      if (code->dst.type == OP_CCR)
d4276 10
a4285 2
	  cpu.ccr = res;
	  GETSR ();
d4287 3
a4289 1
      else if (code->dst.type == OP_EXR && h8300smode)
d4291 6
a4296 2
	  cpu.exr = res;
	  GETEXR ();
d4305 5
a4309 1
      pc = code->src.literal;
a4321 1

a4328 1

a4335 1

d4340 2
a4341 1
      SET_B_REG (code->src.reg, rd);
d4348 2
a4349 1
      SET_W_REG (code->src.reg, rd);
d4356 2
a4357 1
      SET_L_REG (code->src.reg, rd);
d4361 3
a4363 1
      store (&code->dst, res);
d4372 3
a4374 1
      store (&code->dst, res);
d4382 3
a4385 2
    log8:
      store (&code->dst, res);
d4393 3
a4395 1
      SET_B_REG (code->dst.reg, res);
d4403 1
d4408 1
d4416 3
d4423 3
a4425 1
      SET_W_REG (code->dst.reg, res);
d4433 1
d4438 1
d4450 3
a4452 1
      SET_L_REG (code->dst.reg, res);
d4459 1
d4462 2
a4463 1
	  c = ((unsigned) res < (unsigned) rd) || ((unsigned) res < (unsigned) ea);
d4466 1
d4479 8
a4486 2
    next:;
      pc = code->next_pc;
d4489 1
a4489 6
      ;
#if 0
      if (cpu.regs[8])
	abort ();
#endif

d4495 1
a4495 1
	    sim_stop (sd);
d4497 11
d4509 1
a4509 10
    }
  while (cpu.state == SIM_STATE_RUNNING);
  cpu.ticks += get_now () - tick_start;
  cpu.cycles += cycles;
  cpu.insts += insts;

  cpu.pc = pc;
  BUILDSR ();
  BUILDEXR ();
  cpu.mask = oldmask;
d4517 3
a4519 1
  abort ();
d4527 1
a4527 1
  init_pointers ();
d4534 2
a4535 2
	  cpu.memory[addr + i] = buffer[i];
	  cpu.cache_idx[addr + i] = 0;
d4538 3
a4540 1
	cpu.eightbit[(addr + i) & 0xff] = buffer[i];
d4548 1
a4548 1
  init_pointers ();
d4552 1
a4552 1
    memcpy (buffer, cpu.memory + addr, size);
d4554 1
a4554 1
    memcpy (buffer, cpu.eightbit + (addr & 0xff), size);
d4569 1
a4569 1
  init_pointers ();
d4573 1
a4573 1
      cpu.pc = intval;
d4576 3
a4578 1
      abort ();
d4587 1
a4587 1
      cpu.regs[rn] = intval;
d4590 1
a4590 1
      cpu.ccr = intval;
d4593 1
a4593 1
      cpu.exr = intval;
d4596 1
a4596 1
      cpu.cycles = longval;
d4600 1
a4600 1
      cpu.insts = longval;
d4604 1
a4604 1
      cpu.ticks = longval;
d4616 1
a4616 1
  init_pointers ();
d4623 5
a4627 1
      abort ();
d4629 1
a4629 1
      v = cpu.ccr;
d4632 1
a4632 1
      v = cpu.exr;
d4635 1
a4635 1
      v = cpu.pc;
d4645 1
a4645 1
      v = cpu.regs[rn];
d4648 1
a4648 1
      v = cpu.cycles;
d4652 1
a4652 1
      v = cpu.ticks;
d4656 1
a4656 1
      v = cpu.insts;
d4678 1
a4678 13
#if 0 /* FIXME: This should work but we can't use it.
	 grep for SLEEP above.  */
  switch (cpu.state)
    {
    case SIM_STATE_EXITED : *reason = sim_exited; break;
    case SIM_STATE_SIGNALLED : *reason = sim_signalled; break;
    case SIM_STATE_STOPPED : *reason = sim_stopped; break;
    default : abort ();
    }
#else
  *reason = sim_stopped;
#endif
  *sigrc = cpu.exception;
d4689 2
a4690 2
void
sim_set_simcache_size (int n)
d4692 2
a4693 2
  if (cpu.cache)
    free (cpu.cache);
d4696 3
a4698 3
  cpu.cache = (decoded_inst *) malloc (sizeof (decoded_inst) * n);
  memset (cpu.cache, 0, sizeof (decoded_inst) * n);
  cpu.csize = n;
d4705 2
a4706 2
  double timetaken = (double) cpu.ticks / (double) now_persec ();
  double virttime = cpu.cycles / 10.0e6;
d4710 1
a4710 1
				    cpu.insts);
d4713 1
a4713 1
				    cpu.cycles);
d4726 1
a4726 1
				    cpu.compiles);
d4729 1
a4729 1
				    cpu.csize);
d4739 3
a4741 3
	  if (cpu.stats[i])
	    (*sim_callback->printf_filtered) (sim_callback,
					      "%d: %d\n", i, cpu.stats[i]);
d4751 1
a4751 1
set_h8300h (int h_flag, int s_flag)
d4756 16
a4771 2
  h8300hmode = h_flag;
  h8300smode = s_flag;
d4776 1
a4776 1
	  struct host_callback_struct *ptr, 
d4780 59
d4843 2
a4844 3
  sim_callback = ptr;
  /* Fudge our descriptor.  */
  return (SIM_DESC) 1;
d4877 7
a4883 2
	  set_h8300h (mach == bfd_mach_h8300h || mach == bfd_mach_h8300s,
		      mach == bfd_mach_h8300s);
d4909 12
a4920 10
  if (cpu.memory)
    free (cpu.memory);
  if (cpu.cache_idx)
    free (cpu.cache_idx);
  if (cpu.eightbit)
    free (cpu.eightbit);

  cpu.memory = (unsigned char *) calloc (sizeof (char), memory_size);
  cpu.cache_idx = (unsigned short *) calloc (sizeof (short), memory_size);
  cpu.eightbit = (unsigned char *) calloc (sizeof (char), 256);
d4924 6
a4929 2
    abort ();
  cpu.mask = memory_size - 1;
d4954 1
a4954 1
  
d4956 1
a4956 1
    cpu.pc = bfd_get_start_address (abfd);
d4958 1
a4958 1
    cpu.pc = 0;
d4968 2
a4969 2
      ptr_command_line = (char **) malloc ((sizeof (char *))
		         * (no_of_args + 1));
a4972 3
	  /* Calculating the length of argument for allocating memory.  */
	  len_arg = strlen (argv[i] + 1);
	  ptr_command_line[i] = (char *) malloc (sizeof (char) * len_arg);
d4974 1
a4974 1
	  ptr_command_line[i] = (char *) strdup (argv[i]);
d4976 1
a4976 1
      ptr_command_line[i] = NULL;
@


1.25
log
@Added Commandline Support.
2003-03-20  D.Venkatasubramanian  <dvenkat@@noida.hcltech.com>

        * compile.c (cmdline_location): Added function to
        return the location of 8-bit (256 locations) where the
        Command Line arguments would be stored.
        (decode): Added a TRAP to 0xcc for Commandline
        processing using pseudo opcode O_SYS_CMDLINE.
        (sim_resume): Added handling of O_SYS_CMDLINE Trap.
        (sim_create_inferior): Setting a pointer to
        Commandline Args array.
        * inst.h: Added a new variable ptr_command_line for
        storing pointer to Commandline array.
@
text
@d2141 51
@


1.24
log
@File I/O Support added.
2003-03-14  D.Venkatasubramanian <dvenkat@@noida.hcltech.com>

        * compile.c (decode): Added code for some more magic traps.
        * compile.c (sim_resume): Added support for File I/O system
        calls through callback to host_system.
        System calls provided support for :
        open, read, write, lseek, close, stat, fstat
        Only basic support for stat and fstat.
@
text
@d179 11
d491 3
d1427 157
d2705 4
d2713 23
@


1.23
log
@Index: arm/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* wrapper.c (sim_create_inferior, sim_open): Rename _bfd to bfd.

Index: common/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim-utils.h (sim_analyze_program, sim_load_file): Rename _bfd to bfd.
	* sim-hload.c (sim_load), sim-base.h (sim_state_base): Ditto.
	* nrun.c (main): Ditto.

Index: d10v/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: erc32/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interf.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: h8300/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* compile.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: h8500/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* compile.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: i960/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim-if.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: m32r/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim-if.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: m68hc11/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_prepare_for_program, sim_open)
	(sim_create_inferior): Rename _bfd to bfd.

Index: mcore/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: mips/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open):
	(sim_create_inferior):

Index: mn10200/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: mn10300/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior, sim_open)
	(sim_create_inferior): Rename _bfd to bfd.

Index: ppc/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim_calls.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: sh/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (init_dsp, sim_open, sim_create_inferior): Rename _bfd
	to bfd.

Index: v850/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: z8k/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* iface.c (sim_open, sim_create_inferior): Rename _bfd to bfd.
@
text
@d38 2
d452 2
a453 1
		  /* And a jsr to 0xc4 is turned into a magic trap.  */
d457 1
a457 1
		      if (dst->src.literal == 0xc4)
d459 21
a479 1
			  dst->opcode = O (O_SYSCALL, SB);
d481 1
d1413 2
a1414 1
	case O (O_SYSCALL, SB):
d1416 277
a1692 2
	    char c = cpu.regs[2];
	    sim_callback->write_stdout (sim_callback, &c, 1);
d1695 1
@


1.23.4.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@a37 2
#include "sys/stat.h"
#include "sys/types.h"
d450 1
a450 2
		  /* And a jsr to these locations are turned into magic
		     traps.  */
d454 1
a454 1
		      switch (dst->src.literal)
d456 1
a456 21
			case 0xc5:
			  dst->opcode = O (O_SYS_OPEN, SB);
			  break;
			case 0xc6:
			  dst->opcode = O (O_SYS_READ, SB);
			  break;
			case 0xc7:
			  dst->opcode = O (O_SYS_WRITE, SB);
			  break;
			case 0xc8:
			  dst->opcode = O (O_SYS_LSEEK, SB);
			  break;
			case 0xc9:
			  dst->opcode = O (O_SYS_CLOSE, SB);
			  break;
			case 0xca:
			  dst->opcode = O (O_SYS_STAT, SB);
			  break;
			case 0xcb:
			  dst->opcode = O (O_SYS_FSTAT, SB);
			  break;
a457 1
		      /* End of Processing for system calls.  */
d1389 1
a1389 2
	  /* System call processing starts.  */
	case O (O_SYS_OPEN, SB):
d1391 2
a1392 277
	    int len = 0;	/* Length of filename.  */
	    char *filename;	/* Filename would go here.  */
	    char temp_char;	/* Temporary character */
	    int mode = 0;	/* Mode bits for the file.  */
	    int open_return;	/* Return value of open, file descriptor.  */
	    int i;		/* Loop counter */
	    int filename_ptr;	/* Pointer to filename in cpu memory.  */

	    /* Setting filename_ptr to first argument of open.  */
	    filename_ptr = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);

	    /* Trying to get mode.  */
	    if (h8300hmode || h8300smode)
	      {
		mode = GET_MEMORY_L (cpu.regs[7] + 4);
	      }
	    else
	      {
		mode = GET_MEMORY_W (cpu.regs[7] + 2);
	      }

	    /* Trying to find the length of the filename.  */
	    temp_char = GET_MEMORY_B (cpu.regs[0]);

	    len = 1;
	    while (temp_char != '\0')
	      {
		temp_char = GET_MEMORY_B (filename_ptr + len);
		len++;
	      }

	    /* Allocating space for the filename.  */
	    filename = (char *) malloc (sizeof (char) * len);

	    /* String copying the filename from memory.  */
	    for (i = 0; i < len; i++)
	      {
		temp_char = GET_MEMORY_B (filename_ptr + i);
		filename[i] = temp_char;
	      }

	    /* Callback to open and return the file descriptor.  */
	    open_return = sim_callback->open (sim_callback, filename, mode);

	    /* Return value in register 0.  */
	    cpu.regs[0] = open_return;

	    /* Freeing memory used for filename. */
	    free (filename);
	  }
	  goto next;

	case O (O_SYS_READ, SB):
	  {
	    char *char_ptr;	/* Where characters read would be stored.  */
	    int fd;		/* File descriptor */
	    int buf_size;	/* BUF_SIZE parameter in read.  */
	    int i = 0;		/* Temporary Loop counter */
	    int read_return = 0;	/* Return value from callback to
					   read.  */

	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);
	    buf_size = h8300hmode ? GET_L_REG (2) : GET_W_REG (2);

	    char_ptr = (char *) malloc (sizeof (char) * buf_size);

	    /* Callback to read and return the no. of characters read.  */
	    read_return =
	      sim_callback->read (sim_callback, fd, char_ptr, buf_size);

	    /* The characters read are stored in cpu memory.  */
	    for (i = 0; i < buf_size; i++)
	      {
		SET_MEMORY_B ((cpu.regs[1] + (sizeof (char) * i)),
			      *(char_ptr + (sizeof (char) * i)));
	      }

	    /* Return value in Register 0.  */
	    cpu.regs[0] = read_return;

	    /* Freeing memory used as buffer.  */
	    free (char_ptr);
	  }
	  goto next;

	case O (O_SYS_WRITE, SB):
	  {
	    int fd;		/* File descriptor */
	    char temp_char;	/* Temporary character */
	    int len;		/* Length of write, Parameter II to write.  */
	    int char_ptr;	/* Character Pointer, Parameter I of write.  */
	    char *ptr;		/* Where characters to be written are stored. 
				 */
	    int write_return;	/* Return value from callback to write.  */
	    int i = 0;		/* Loop counter */

	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);
	    char_ptr = h8300hmode ? GET_L_REG (1) : GET_W_REG (1);
	    len = h8300hmode ? GET_L_REG (2) : GET_W_REG (2);

	    /* Allocating space for the characters to be written.  */
	    ptr = (char *) malloc (sizeof (char) * len);

	    /* Fetching the characters from cpu memory.  */
	    for (i = 0; i < len; i++)
	      {
		temp_char = GET_MEMORY_B (char_ptr + i);
		ptr[i] = temp_char;
	      }

	    /* Callback write and return the no. of characters written.  */
	    write_return = sim_callback->write (sim_callback, fd, ptr, len);

	    /* Return value in Register 0.  */
	    cpu.regs[0] = write_return;

	    /* Freeing memory used as buffer.  */
	    free (ptr);
	  }
	  goto next;

	case O (O_SYS_LSEEK, SB):
	  {
	    int fd;		/* File descriptor */
	    int offset;		/* Offset */
	    int origin;		/* Origin */
	    int lseek_return;	/* Return value from callback to lseek.  */

	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);
	    offset = h8300hmode ? GET_L_REG (1) : GET_W_REG (1);
	    origin = h8300hmode ? GET_L_REG (2) : GET_W_REG (2);

	    /* Callback lseek and return offset.  */
	    lseek_return =
	      sim_callback->lseek (sim_callback, fd, offset, origin);

	    /* Return value in register 0.  */
	    cpu.regs[0] = lseek_return;
	  }
	  goto next;

	case O (O_SYS_CLOSE, SB):
	  {
	    int fd;		/* File descriptor */
	    int close_return;	/* Return value from callback to close.  */

	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);

	    /* Callback close and return.  */
	    close_return = sim_callback->close (sim_callback, fd);

	    /* Return value in register 0.  */
	    cpu.regs[0] = close_return;
	  }
	  goto next;

	case O (O_SYS_FSTAT, SB):
	  {
	    int fd;		/* File descriptor */
	    struct stat stat_rec;	/* Stat record */
	    int fstat_return;	/* Return value from callback to stat.  */
	    int stat_ptr;	/* Pointer to stat record.  */
	    char *temp_stat_ptr;	/* Temporary stat_rec pointer.  */

	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);

	    /* Setting stat_ptr to second argument of stat.  */
	    stat_ptr = h8300hmode ? GET_L_REG (1) : GET_W_REG (1);

	    /* Callback stat and return.  */
	    fstat_return = sim_callback->fstat (sim_callback, fd, &stat_rec);

	    /* Have stat_ptr point to starting of stat_rec.  */
	    temp_stat_ptr = (char *) (&stat_rec);

	    /* Setting up the stat structure returned.  */
	    SET_MEMORY_W (stat_ptr, stat_rec.st_dev);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_ino);
	    stat_ptr += 2;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_mode);
	    stat_ptr += 4;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_nlink);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_uid);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_gid);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_rdev);
	    stat_ptr += 2;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_size);
	    stat_ptr += 4;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_atime);
	    stat_ptr += 8;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_mtime);
	    stat_ptr += 8;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_ctime);

	    /* Return value in register 0.  */
	    cpu.regs[0] = fstat_return;
	  }
	  goto next;

	case O (O_SYS_STAT, SB):
	  {
	    int len = 0;	/* Length of filename.  */
	    char *filename;	/* Filename would go here.  */
	    char temp_char;	/* Temporary character */
	    int filename_ptr;	/* Pointer to filename in cpu memory.  */
	    struct stat stat_rec;	/* Stat record */
	    int stat_return;	/* Return value from callback to stat */
	    int stat_ptr;	/* Pointer to stat record.  */
	    char *temp_stat_ptr;	/* Temporary stat_rec pointer.  */
	    int i = 0;		/* Loop Counter */

	    /* Setting filename_ptr to first argument of open.  */
	    filename_ptr = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);

	    /* Trying to find the length of the filename.  */
	    temp_char = GET_MEMORY_B (cpu.regs[0]);

	    len = 1;
	    while (temp_char != '\0')
	      {
		temp_char = GET_MEMORY_B (filename_ptr + len);
		len++;
	      }

	    /* Allocating space for the filename.  */
	    filename = (char *) malloc (sizeof (char) * len);

	    /* String copying the filename from memory.  */
	    for (i = 0; i < len; i++)
	      {
		temp_char = GET_MEMORY_B (filename_ptr + i);
		filename[i] = temp_char;
	      }

	    /* Setting stat_ptr to second argument of stat.  */
	    /* stat_ptr = cpu.regs[1]; */
	    stat_ptr = h8300hmode ? GET_L_REG (1) : GET_W_REG (1);

	    /* Callback stat and return.  */
	    stat_return =
	      sim_callback->stat (sim_callback, filename, &stat_rec);

	    /* Have stat_ptr point to starting of stat_rec.  */
	    temp_stat_ptr = (char *) (&stat_rec);

	    /* Freeing memory used for filename.  */
	    free (filename);

	    /* Setting up the stat structure returned.  */
	    SET_MEMORY_W (stat_ptr, stat_rec.st_dev);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_ino);
	    stat_ptr += 2;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_mode);
	    stat_ptr += 4;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_nlink);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_uid);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_gid);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_rdev);
	    stat_ptr += 2;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_size);
	    stat_ptr += 4;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_atime);
	    stat_ptr += 8;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_mtime);
	    stat_ptr += 8;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_ctime);

	    /* Return value in register 0.  */
	    cpu.regs[0] = stat_return;
a1394 1
	  /* End of system call processing.  */
@


1.22
log
@	* compile.c (init_pointers): Abort if wreg never gets initialized.
	(sim_resume): Fix the handling of exts.w and extu.w.
@
text
@d2128 1
a2128 1
	  struct _bfd *abfd, 
d2231 1
a2231 1
sim_create_inferior (SIM_DESC sd, struct _bfd *abfd, char **argv, char **env)
@


1.21
log
@	* compile.c (sim_resume): Fix the handling of bxor.
@
text
@d756 1
d769 2
d1612 1
a1612 1
	  rd = GET_B_REG (code->src.reg + 8) & 0xff; /* Yes, src, not dst.  */
d1622 1
a1622 1
	  rd = GET_B_REG (code->src.reg + 8) & 0xff;
@


1.20
log
@Missed one...
@
text
@d1508 1
a1508 1
	  OBITOP (O_BXOR, 1, 0, c = (ea & m) != C);
@


1.19
log
@2003-01-16  Michael Snyder  <msnyder@@redhat.com>

	* compile.c: Change K&R function definitions to ISO.
	(fetch): Make static, and eliminate unused parameter 'n'.
@
text
@d927 1
a927 2
sim_stop (sd)
     SIM_DESC sd;
@


1.18
log
@	* compile.c: Fix formatting.
	* inst.h: Likewise.
@
text
@d130 1
a130 1
get_now ()
d136 1
a136 1
now_persec ()
d142 1
a142 1
bitfrom (x)
d158 1
a158 1
lvalue (x, rn)
d178 1
a178 5
decode (addr, data, dst)
     int addr;
     unsigned char *data;
     decoded_inst *dst;

d480 1
a480 1
compile (pc)
d549 2
a550 3
int
fetch (arg, n)
     ea_type *arg;
d632 1
a632 3
store (arg, n)
     ea_type *arg;
     int n;
d706 1
a706 1
init_pointers ()
d781 1
a781 5
control_c (sig, code, scp, addr)
     int sig;
     int code;
     char *scp;
     char *addr;
d797 1
a797 4
mop (code, bsize, sign)
     decoded_inst *code;
     int bsize;
     int sign;
d958 1
a958 2
sim_resume (sd, step, siggnal)
     SIM_DESC sd;
d1875 1
a1875 2
sim_trace (sd)
     SIM_DESC sd;
d1882 1
a1882 5
sim_write (sd, addr, buffer, size)
     SIM_DESC sd;
     SIM_ADDR addr;
     unsigned char *buffer;
     int size;
d1903 1
a1903 5
sim_read (sd, addr, buffer, size)
     SIM_DESC sd;
     SIM_ADDR addr;
     unsigned char *buffer;
     int size;
d1917 1
a1917 5
sim_store_register (sd, rn, value, length)
     SIM_DESC sd;
     int rn;
     unsigned char *value;
     int length;
d1966 1
a1966 5
sim_fetch_register (sd, rn, buf, length)
     SIM_DESC sd;
     int rn;
     unsigned char *buf;
     int length;
d2027 1
a2027 4
sim_stop_reason (sd, reason, sigrc)
     SIM_DESC sd;
     enum sim_stop *reason;
     int *sigrc;
d2047 1
a2047 2
sim_size (n)
     int n;
d2053 1
a2053 1
sim_set_simcache_size (n)
d2066 1
a2066 3
sim_info (sd, verbose)
     SIM_DESC sd;
     int verbose;
d2114 1
a2114 2
set_h8300h (h_flag, s_flag)
     int h_flag, s_flag;
d2124 4
a2127 5
sim_open (kind, ptr, abfd, argv)
     SIM_OPEN_KIND kind;
     struct host_callback_struct *ptr;
     struct _bfd *abfd;
     char **argv;
d2139 1
a2139 3
sim_close (sd, quitting)
     SIM_DESC sd;
     int quitting;
d2147 1
a2147 5
sim_load (sd, prog, abfd, from_tty)
     SIM_DESC sd;
     char *prog;
     bfd *abfd;
     int from_tty;
d2229 1
a2229 5
sim_create_inferior (sd, abfd, argv, env)
     SIM_DESC sd;
     struct _bfd *abfd;
     char **argv;
     char **env;
d2239 1
a2239 3
sim_do_command (sd, cmd)
     SIM_DESC sd;
     char *cmd;
d2246 1
a2246 2
sim_set_callbacks (ptr)
     struct host_callback_struct *ptr;
@


1.17
log
@Add dependences to Makefile.in and include sim-h8300 in compile.c
@
text
@d86 3
a88 2
#define BUILDSR()   cpu.ccr = (I << 7) | (UI << 6)| (H<<5) | (U<<4) | \
                              (N << 3) | (Z << 2) | (V<<1) | C;
d103 6
a108 4
#define GETEXR()	    \
  if (h8300smode) { \
    trace = (cpu.exr >> 7) & 1;\
    intMask = cpu.exr & 7; }
d115 1
a115 1
#define SEXTCHAR(x) ((x & 0x80) ? (x | ~0xff): x & 0xff)
d1028 3
a1030 3
    case O (NAME,SB):  HOW; if (STORE)goto alu8;else goto just_flags_alu8;  \
    case O (NAME, SW): HOW; if (STORE)goto alu16;else goto just_flags_alu16; \
    case O (NAME,SL):  HOW; if (STORE)goto alu32;else goto just_flags_alu32;
d1033 4
a1036 4
#define LOGOP(NAME, HOW) \
    case O (NAME,SB): HOW; goto log8;\
    case O (NAME, SW): HOW; goto log16;\
    case O (NAME,SL): HOW; goto log32;
d1146 1
a1146 1
	  if (h8300hmode||h8300smode)
d1148 9
a1156 7
	      register unsigned char *_src,*_dst;
	      unsigned int count = (code->opcode == O(O_EEPMOV, SW))?cpu.regs[R4_REGNUM]&0xffff:
		cpu.regs[R4_REGNUM]&0xff;

	      _src = cpu.regs[R5_REGNUM] < memory_size ? cpu.memory+cpu.regs[R5_REGNUM] :
		cpu.eightbit + (cpu.regs[R5_REGNUM] & 0xff);
	      if ((_src+count)>=(cpu.memory+memory_size))
d1158 1
a1158 1
		  if ((_src+count)>=(cpu.eightbit+0x100))
d1161 4
a1164 3
	      _dst = cpu.regs[R6_REGNUM] < memory_size ? cpu.memory+cpu.regs[R6_REGNUM] :
	           				       	      cpu.eightbit + (cpu.regs[R6_REGNUM] & 0xff);
	      if ((_dst+count)>=(cpu.memory+memory_size))
d1166 1
a1166 1
		  if ((_dst+count)>=(cpu.eightbit+0x100))
d1169 1
a1169 1
	      memcpy(_dst,_src,count);
d1171 5
a1175 4
	      cpu.regs[R5_REGNUM]+=count;
	      cpu.regs[R6_REGNUM]+=count;
	      cpu.regs[R4_REGNUM]&=(code->opcode == O(O_EEPMOV, SW))?(~0xffff):(~0xff);
	      cycles += 2*count;
d1558 1
a1558 1
	  store (&code->src,res|0x80);
d1683 1
a1683 1
        illegal:
d2005 1
a2005 1
  if (!h8300smode && rn >=EXR_REGNUM)
@


1.17.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
 * Simulator for the Renesas (formerly Hitachi) H8/300 architecture.
d20 3
d33 1
a33 1

d35 2
a36 1
#include "sim-main.h"
a37 2
#include "sys/stat.h"
#include "sys/types.h"
d54 1
a54 1
static void set_simcache_size (SIM_DESC, int);
d56 1
a56 3
#define X(op, size)  (op * 4 + size)

#define SP (h8300hmode && !h8300_normal_mode ? SL : SW)
d58 14
d76 1
a76 1
/* CPU data object: */
d78 1
a78 4
static int
sim_state_initialize (SIM_DESC sd, sim_cpu *cpu)
{
  /* FIXME: not really necessary, since sim_cpu_alloc calls zalloc.  */
d80 1
a80 20
  memset (&cpu->regs, 0, sizeof(cpu->regs));
  cpu->regs[SBR_REGNUM] = 0xFFFFFF00;
  cpu->pc = 0;
  cpu->delayed_branch = 0;
  cpu->memory = NULL;
  cpu->eightbit = NULL;
  cpu->mask = 0;

  /* Initialize local simulator state.  */
  sd->sim_cache = NULL;
  sd->sim_cache_size = 0;
  sd->cache_idx = NULL;
  sd->cache_top = 0;
  sd->memory_size = 0;
  sd->compiles = 0;
#ifdef ADEBUG
  memset (&cpu->stats, 0, sizeof (cpu->stats));
#endif
  return 0;
}
d82 3
a84 5
static unsigned int
h8_get_pc (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> pc;
}
d86 2
a87 5
static void
h8_set_pc (SIM_DESC sd, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> pc = val;
}
d89 2
a90 5
static unsigned int
h8_get_ccr (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[CCR_REGNUM];
}
d92 14
a105 5
static void
h8_set_ccr (SIM_DESC sd, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> regs[CCR_REGNUM] = val;
}
d107 3
a109 5
static unsigned int
h8_get_exr (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[EXR_REGNUM];
}
d111 3
a113 5
static void
h8_set_exr (SIM_DESC sd, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> regs[EXR_REGNUM] = val;
}
d115 3
a117 5
static int
h8_get_sbr (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[SBR_REGNUM];
}
d119 1
a119 5
static void
h8_set_sbr (SIM_DESC sd, int val)
{
  (STATE_CPU (sd, 0)) -> regs[SBR_REGNUM] = val;
}
d121 2
a122 5
static int
h8_get_vbr (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[VBR_REGNUM];
}
d124 1
a124 5
static void
h8_set_vbr (SIM_DESC sd, int val)
{
  (STATE_CPU (sd, 0)) -> regs[VBR_REGNUM] = val;
}
d127 1
a127 7
h8_get_cache_top (SIM_DESC sd)
{
  return sd -> cache_top;
}

static void
h8_set_cache_top (SIM_DESC sd, int val)
d129 1
a129 1
  sd -> cache_top = val;
d133 1
a133 1
h8_get_mask (SIM_DESC sd)
d135 1
a135 1
  return (STATE_CPU (sd, 0)) -> mask;
a137 6
static void
h8_set_mask (SIM_DESC sd, int val)
{
  (STATE_CPU (sd, 0)) -> mask = val;
}
#if 0
d139 1
a139 1
h8_get_exception (SIM_DESC sd)
d141 11
a151 13
  return (STATE_CPU (sd, 0)) -> exception;
}

static void
h8_set_exception (SIM_DESC sd, int val)
{
  (STATE_CPU (sd, 0)) -> exception = val;
}

static enum h8300_sim_state
h8_get_state (SIM_DESC sd)
{
  return sd -> state;
a153 6
static void
h8_set_state (SIM_DESC sd, enum h8300_sim_state val)
{
  sd -> state = val;
}
#endif
d155 1
a155 1
h8_get_cycles (SIM_DESC sd)
d157 8
a164 2
  return (STATE_CPU (sd, 0)) -> regs[CYCLE_REGNUM];
}
d166 2
a167 5
static void
h8_set_cycles (SIM_DESC sd, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> regs[CYCLE_REGNUM] = val;
}
d169 3
a171 10
static unsigned int
h8_get_insts (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[INST_REGNUM];
}

static void
h8_set_insts (SIM_DESC sd, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> regs[INST_REGNUM] = val;
d175 4
a178 4
h8_get_ticks (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[TICK_REGNUM];
}
a179 2
static void
h8_set_ticks (SIM_DESC sd, unsigned int val)
d181 8
a188 2
  (STATE_CPU (sd, 0)) -> regs[TICK_REGNUM] = val;
}
d190 2
a191 5
static unsigned int
h8_get_mach (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[MACH_REGNUM];
}
d193 5
a197 5
static void
h8_set_mach (SIM_DESC sd, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> regs[MACH_REGNUM] = val;
}
d199 4
a202 5
static unsigned int
h8_get_macl (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[MACL_REGNUM];
}
d204 1
a204 5
static void
h8_set_macl (SIM_DESC sd, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> regs[MACL_REGNUM] = val;
}
d206 11
a216 5
static int
h8_get_compiles (SIM_DESC sd)
{
  return sd -> compiles;
}
d218 3
a220 5
static void
h8_increment_compiles (SIM_DESC sd)
{
  sd -> compiles ++;
}
d222 4
a225 5
static unsigned int *
h8_get_reg_buf (SIM_DESC sd)
{
  return &(((STATE_CPU (sd, 0)) -> regs)[0]);
}
d227 2
a228 5
static unsigned int
h8_get_reg (SIM_DESC sd, int regnum)
{
  return (STATE_CPU (sd, 0)) -> regs[regnum];
}
d230 7
a236 5
static void
h8_set_reg (SIM_DESC sd, int regnum, int val)
{
  (STATE_CPU (sd, 0)) -> regs[regnum] = val;
}
d238 34
a271 6
#ifdef ADEBUG
static int
h8_get_stats (SIM_DESC sd, int idx)
{
  return sd -> stats[idx];
}
d273 4
a276 6
static void
h8_increment_stats (SIM_DESC sd, int idx)
{
  sd -> stats[idx] ++;
}
#endif /* ADEBUG */
d278 5
a282 5
static unsigned short *
h8_get_cache_idx_buf (SIM_DESC sd)
{
  return sd -> cache_idx;
}
d284 31
a314 5
static void
h8_set_cache_idx_buf (SIM_DESC sd, unsigned short *ptr)
{
  sd -> cache_idx = ptr;
}
d316 18
a333 7
static unsigned short
h8_get_cache_idx (SIM_DESC sd, unsigned int idx)
{
  if (idx > sd->memory_size)
    return (unsigned short) -1;
  return sd -> cache_idx[idx];
}
d335 5
a339 5
static void
h8_set_cache_idx (SIM_DESC sd, int idx, unsigned int val)
{
  sd -> cache_idx[idx] = (unsigned short) val;
}
d341 4
a344 5
static unsigned char *
h8_get_memory_buf (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> memory;
}
d346 5
a350 5
static void
h8_set_memory_buf (SIM_DESC sd, unsigned char *ptr)
{
  (STATE_CPU (sd, 0)) -> memory = ptr;
}
d352 4
a355 5
static unsigned char
h8_get_memory (SIM_DESC sd, int idx)
{
  return (STATE_CPU (sd, 0)) -> memory[idx];
}
d357 14
a370 5
static void
h8_set_memory (SIM_DESC sd, int idx, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> memory[idx] = (unsigned char) val;
}
d372 88
a459 5
static unsigned char *
h8_get_eightbit_buf (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> eightbit;
}
d461 6
a466 5
static void
h8_set_eightbit_buf (SIM_DESC sd, unsigned char *ptr)
{
  (STATE_CPU (sd, 0)) -> eightbit = ptr;
}
d468 3
a470 5
static unsigned char
h8_get_eightbit (SIM_DESC sd, int idx)
{
  return (STATE_CPU (sd, 0)) -> eightbit[idx];
}
d472 3
a474 5
static void
h8_set_eightbit (SIM_DESC sd, int idx, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> eightbit[idx] = (unsigned char) val;
}
d476 2
a477 4
static unsigned int
h8_get_delayed_branch (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> delayed_branch;
d481 1
a481 1
h8_set_delayed_branch (SIM_DESC sd, unsigned int dest)
d483 1
a483 2
  (STATE_CPU (sd, 0)) -> delayed_branch = dest;
}
d485 8
a492 5
static char **
h8_get_command_line (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> command_line;
}
d494 2
a495 5
static void
h8_set_command_line (SIM_DESC sd, char ** val)
{
  (STATE_CPU (sd, 0)) -> command_line = val;
}
d497 2
a498 5
static char *
h8_get_cmdline_arg (SIM_DESC sd, int index)
{
  return (STATE_CPU (sd, 0)) -> command_line[index];
}
d500 2
a501 5
static void
h8_set_cmdline_arg (SIM_DESC sd, int index, char * val)
{
  (STATE_CPU (sd, 0)) -> command_line[index] = val;
}
d503 2
a504 5
/* MAC Saturation Mode */
static int
h8_get_macS (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> macS;
a506 5
static void
h8_set_macS (SIM_DESC sd, int val)
{
  (STATE_CPU (sd, 0)) -> macS = (val != 0);
}
d508 3
a510 6
/* MAC Zero Flag */
static int
h8_get_macZ (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> macZ;
}
d512 4
a515 5
static void
h8_set_macZ (SIM_DESC sd, int val)
{
  (STATE_CPU (sd, 0)) -> macZ = (val != 0);
}
d517 2
a518 6
/* MAC Negative Flag */
static int
h8_get_macN (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> macN;
}
d520 6
a525 5
static void
h8_set_macN (SIM_DESC sd, int val)
{
  (STATE_CPU (sd, 0)) -> macN = (val != 0);
}
d527 4
a530 6
/* MAC Overflow Flag */
static int
h8_get_macV (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> macV;
}
a531 5
static void
h8_set_macV (SIM_DESC sd, int val)
{
  (STATE_CPU (sd, 0)) -> macV = (val != 0);
}
d533 2
a534 1
/* End CPU data object.  */
d536 5
a540 1
/* The rate at which to call the host's poll_quit callback.  */
d542 4
a545 1
enum { POLL_QUIT_INTERVAL = 0x80000 };
d547 2
a548 3
#define LOW_BYTE(x) ((x) & 0xff)
#define HIGH_BYTE(x) (((x) >> 8) & 0xff)
#define P(X, Y) ((X << 8) | Y)
d550 8
a557 8
#define C (c != 0)
#define Z (nz == 0)
#define V (v != 0)
#define N (n != 0)
#define U (u != 0)
#define H (h != 0)
#define UI (ui != 0)
#define I (intMaskBit != 0)
d559 14
a572 14
#define BUILDSR(SD)						\
  h8_set_ccr (SD, (I << 7) | (UI << 6) | (H << 5) | (U << 4)	\
	     | (N << 3) | (Z << 2) | (V << 1) | C)

#define GETSR(SD) \
  /* Get Status Register (flags).  */		\
  c = (h8_get_ccr (sd) >> 0) & 1;		\
  v = (h8_get_ccr (sd) >> 1) & 1;		\
  nz = !((h8_get_ccr (sd) >> 2) & 1);		\
  n = (h8_get_ccr (sd) >> 3) & 1;		\
  u = (h8_get_ccr (sd) >> 4) & 1;		\
  h = (h8_get_ccr (sd) >> 5) & 1;		\
  ui = ((h8_get_ccr (sd) >> 6) & 1);		\
  intMaskBit = (h8_get_ccr (sd) >> 7) & 1
d574 21
d596 4
a599 3
#ifdef __CHAR_IS_SIGNED__
#define SEXTCHAR(x) ((char) (x))
#endif
d601 4
a604 3
#ifndef SEXTCHAR
#define SEXTCHAR(x) ((x & 0x80) ? (x | ~0xff) : x & 0xff)
#endif
d606 4
a609 3
#define UEXTCHAR(x) ((x) & 0xff)
#define UEXTSHORT(x) ((x) & 0xffff)
#define SEXTSHORT(x) ((short) (x))
d611 4
a614 4
int h8300hmode  = 0;
int h8300smode  = 0;
int h8300_normal_mode  = 0;
int h8300sxmode = 0;
d616 4
a619 1
static int memory_size;
d621 4
a624 5
static int
get_now (void)
{
  return time (0);	/* WinXX HAS UNIX like 'time', so why not use it? */
}
d626 2
a627 5
static int
now_persec (void)
{
  return 1;
}
a628 14
static int
bitfrom (int x)
{
  switch (x & SIZE)
    {
    case L_8:
      return SB;
    case L_16:
    case L_16U:
      return SW;
    case L_32:
      return SL;
    case L_P:
      return (h8300hmode && !h8300_normal_mode)? SL : SW;
a629 1
  return 0;
a631 3
/* Simulate an indirection / dereference.  
   return 0 for success, -1 for failure.
*/
d633 4
a636 2
static unsigned int
lvalue (SIM_DESC sd, int x, int rn, unsigned int *val)
d638 3
a640 2
  if (val == NULL)	/* Paranoia.  */
    return -1;
d642 1
a642 1
  switch (x / 4)
d644 39
a682 5
    case OP_DISP:
      if (rn == ZERO_REGNUM)
	*val = X (OP_IMM, SP);
      else
	*val = X (OP_REG, SP);
d684 5
a688 2
    case OP_MEM:
      *val = X (OP_MEM, SP);
d691 1
a691 2
      sim_engine_set_run_state (sd, sim_stopped, SIGSEGV);
      return -1;
a692 1
  return 0;
d695 2
a696 2
static int
cmdline_location()
d698 7
a704 6
  if (h8300smode && !h8300_normal_mode)
    return 0xffff00L;
  else if (h8300hmode && !h8300_normal_mode)
    return 0x2ff00L;
  else
    return 0xff00L;
d707 2
d710 1
a710 1
decode (SIM_DESC sd, int addr, unsigned char *data, decoded_inst *dst)
d712 5
a716 5
  int cst[3]   = {0, 0, 0};
  int reg[3]   = {0, 0, 0};
  int rdisp[3] = {0, 0, 0};
  int opnum;
  const struct h8_opcode *q;
d718 2
a719 2
  dst->dst.type = -1;
  dst->src.type = -1;
d721 9
a729 5
  /* Find the exact opcode/arg combo.  */
  for (q = h8_opcodes; q->name; q++)
    {
      op_type *nib = q->data.nib;
      unsigned int len = 0;
d731 4
a734 8
      if ((q->available == AV_H8SX && !h8300sxmode) ||
	  (q->available == AV_H8S  && !h8300smode)  ||
	  (q->available == AV_H8H  && !h8300hmode))
	continue;

      cst[0]   = cst[1]   = cst[2]   = 0;
      reg[0]   = reg[1]   = reg[2]   = 0;
      rdisp[0] = rdisp[1] = rdisp[2] = 0;
d736 1
a736 1
      while (1)
d738 2
a739 2
	  op_type looking_for = *nib;
	  int thisnib = data[len / 2];
d741 8
a748 5
	  thisnib = (len & 1) ? (thisnib & 0xf) : ((thisnib >> 4) & 0xf);
	  opnum = ((looking_for & OP3) ? 2 :
		   (looking_for & DST) ? 1 : 0);

	  if (looking_for < 16 && looking_for >= 0)
d750 1
a750 6
	      if (looking_for != thisnib)
		goto fail;
	    }
	  else
	    {
	      if (looking_for & B31)
d752 3
a754 7
		  if (!((thisnib & 0x8) != 0))
		    goto fail;

		  looking_for = (op_type) (looking_for & ~B31);
		  thisnib &= 0x7;
		}
	      else if (looking_for & B30)
d756 1
a756 4
		  if (!((thisnib & 0x8) == 0))
		    goto fail;

		  looking_for = (op_type) (looking_for & ~B30);
d758 5
a762 2

	      if (looking_for & B21)
d764 1
a764 5
		  if (!((thisnib & 0x4) != 0))
		    goto fail;

		  looking_for = (op_type) (looking_for & ~B21);
		  thisnib &= 0xb;
d766 1
a766 1
	      else if (looking_for & B20)
d768 1
a768 4
		  if (!((thisnib & 0x4) == 0))
		    goto fail;

		  looking_for = (op_type) (looking_for & ~B20);
d770 1
a770 552

	      if (looking_for & B11)
		{
		  if (!((thisnib & 0x2) != 0))
		    goto fail;

		  looking_for = (op_type) (looking_for & ~B11);
		  thisnib &= 0xd;
		}
	      else if (looking_for & B10)
		{
		  if (!((thisnib & 0x2) == 0))
		    goto fail;

		  looking_for = (op_type) (looking_for & ~B10);
		}

	      if (looking_for & B01)
		{
		  if (!((thisnib & 0x1) != 0))
		    goto fail;

		  looking_for = (op_type) (looking_for & ~B01);
		  thisnib &= 0xe;
		}
	      else if (looking_for & B00)
		{
		  if (!((thisnib & 0x1) == 0))
		    goto fail;

		  looking_for = (op_type) (looking_for & ~B00);
		}

	      if (looking_for & IGNORE)
		{
		  /* Hitachi has declared that IGNORE must be zero.  */
		  if (thisnib != 0)
		    goto fail;
		}
	      else if ((looking_for & MODE) == DATA)
		{
		  ;			/* Skip embedded data.  */
		}
	      else if ((looking_for & MODE) == DBIT)
		{
		  /* Exclude adds/subs by looking at bit 0 and 2, and
                     make sure the operand size, either w or l,
                     matches by looking at bit 1.  */
		  if ((looking_for & 7) != (thisnib & 7))
		    goto fail;

		  cst[opnum] = (thisnib & 0x8) ? 2 : 1;
		}
	      else if ((looking_for & MODE) == REG     ||
		       (looking_for & MODE) == LOWREG  ||
		       (looking_for & MODE) == IND     ||
		       (looking_for & MODE) == PREINC  ||
		       (looking_for & MODE) == POSTINC ||
		       (looking_for & MODE) == PREDEC  ||
		       (looking_for & MODE) == POSTDEC)
		{
		  reg[opnum] = thisnib;
		}
	      else if (looking_for & CTRL)
		{
		  thisnib &= 7;
		  if (((looking_for & MODE) == CCR  && (thisnib != C_CCR))  ||
		      ((looking_for & MODE) == EXR  && (thisnib != C_EXR))  ||
		      ((looking_for & MODE) == MACH && (thisnib != C_MACH)) ||
		      ((looking_for & MODE) == MACL && (thisnib != C_MACL)) ||
		      ((looking_for & MODE) == VBR  && (thisnib != C_VBR))  ||
		      ((looking_for & MODE) == SBR  && (thisnib != C_SBR)))
		    goto fail;
		  if (((looking_for & MODE) == CCR_EXR && 
		       (thisnib != C_CCR && thisnib != C_EXR)) ||
		      ((looking_for & MODE) == VBR_SBR && 
		       (thisnib != C_VBR && thisnib != C_SBR)) ||
		      ((looking_for & MODE) == MACREG && 
		       (thisnib != C_MACH && thisnib != C_MACL)))
		    goto fail;
		  if (((looking_for & MODE) == CC_EX_VB_SB && 
		       (thisnib != C_CCR && thisnib != C_EXR &&
			thisnib != C_VBR && thisnib != C_SBR)))
		    goto fail;

		  reg[opnum] = thisnib;
		}
	      else if ((looking_for & MODE) == ABS)
		{
		  /* Absolute addresses are unsigned.  */
		  switch (looking_for & SIZE)
		    {
		    case L_8:
		      cst[opnum] = UEXTCHAR (data[len / 2]);
		      break;
		    case L_16:
		    case L_16U:
		      cst[opnum] = (data[len / 2] << 8) + data[len / 2 + 1];
		      break;
		    case L_32:
		      cst[opnum] = 
			(data[len / 2 + 0] << 24) + 
			(data[len / 2 + 1] << 16) +
			(data[len / 2 + 2] <<  8) +  
			(data[len / 2 + 3]);
		      break;
		    default:
		      printf ("decode: bad size ABS: %d\n", 
			      (looking_for & SIZE));
		      goto end;
		    }
		}
	      else if ((looking_for & MODE) == DISP   ||
		       (looking_for & MODE) == PCREL  ||
		       (looking_for & MODE) == INDEXB ||
		       (looking_for & MODE) == INDEXW ||
		       (looking_for & MODE) == INDEXL)
		{
		  switch (looking_for & SIZE)
		    {
		    case L_2:
		      cst[opnum] = thisnib & 3;
		      break;
		    case L_8:
		      cst[opnum] = SEXTCHAR (data[len / 2]);
		      break;
		    case L_16:
		      cst[opnum] = (data[len / 2] << 8) + data[len / 2 + 1];
		      cst[opnum] = (short) cst[opnum];	/* Sign extend.  */
		      break;
		    case L_16U:
		      cst[opnum] = (data[len / 2] << 8) + data[len / 2 + 1];
		      break;
		    case L_32:
		      cst[opnum] = 
			(data[len / 2 + 0] << 24) + 
			(data[len / 2 + 1] << 16) +
			(data[len / 2 + 2] <<  8) +  
			(data[len / 2 + 3]);
		      break;
		    default:
		      printf ("decode: bad size DISP/PCREL/INDEX: %d\n", 
			      (looking_for & SIZE));
		      goto end;
		    }
		}
	      else if ((looking_for & SIZE) == L_16 ||
		       (looking_for & SIZE) == L_16U)
		{
		  cst[opnum] = (data[len / 2] << 8) + data[len / 2 + 1];
		  /* Immediates are always unsigned.  */
		  if ((looking_for & SIZE) != L_16U &&
		      (looking_for & MODE) != IMM)
		    cst[opnum] = (short) cst[opnum];	/* Sign extend.  */
		}
	      else if (looking_for & ABSJMP)
		{
		  switch (looking_for & SIZE) {
		  case L_24:
		    cst[opnum] = (data[1] << 16) | (data[2] << 8) | (data[3]);
		    break;
		  case L_32:
		    cst[opnum] = 
		      (data[len / 2 + 0] << 24) + 
		      (data[len / 2 + 1] << 16) +
		      (data[len / 2 + 2] <<  8) +  
		      (data[len / 2 + 3]);
		    break;
		  default:
		    printf ("decode: bad size ABSJMP: %d\n", 
			    (looking_for & SIZE));
		      goto end;
		  }
		}
	      else if ((looking_for & MODE) == MEMIND)
		{
		  cst[opnum] = data[1];
		}
	      else if ((looking_for & MODE) == VECIND)
		{
		  if(h8300_normal_mode)
		    cst[opnum] = ((data[1] & 0x7f) + 0x80) * 2;
		  else
		    cst[opnum] = ((data[1] & 0x7f) + 0x80) * 4;
		  cst[opnum] += h8_get_vbr (sd); /* Add vector base reg.  */
		}
	      else if ((looking_for & SIZE) == L_32)
		{
		  int i = len / 2;

		  cst[opnum] = 
		    (data[i + 0] << 24) |
		    (data[i + 1] << 16) |
		    (data[i + 2] <<  8) |
		    (data[i + 3]);
		}
	      else if ((looking_for & SIZE) == L_24)
		{
		  int i = len / 2;

		  cst[opnum] = 
		    (data[i + 0] << 16) | 
		    (data[i + 1] << 8) | 
		    (data[i + 2]);
		}
	      else if (looking_for & DISPREG)
		{
		  rdisp[opnum] = thisnib & 0x7;
		}
	      else if ((looking_for & MODE) == KBIT)
		{
		  switch (thisnib)
		    {
		    case 9:
		      cst[opnum] = 4;
		      break;
		    case 8:
		      cst[opnum] = 2;
		      break;
		    case 0:
		      cst[opnum] = 1;
		      break;
		    default:
		      goto fail;
		    }
		}
	      else if ((looking_for & SIZE) == L_8)
		{
		  if ((looking_for & MODE) == ABS)
		    {
		      /* Will be combined with contents of SBR_REGNUM
			 by fetch ().  For all modes except h8sx, this
			 will always contain the value 0xFFFFFF00.  */
		      cst[opnum] = data[len / 2] & 0xff;
		    }
		  else
		    {
		      cst[opnum] = data[len / 2] & 0xff;
		    }
		}
	      else if ((looking_for & SIZE) == L_2)
		{
		  cst[opnum] = thisnib & 3;
		}
	      else if ((looking_for & SIZE) == L_3 ||
		       (looking_for & SIZE) == L_3NZ)
		{
		  cst[opnum] = thisnib & 7;
		  if (cst[opnum] == 0 && (looking_for & SIZE) == L_3NZ)
		    goto fail;
		}
	      else if ((looking_for & SIZE) == L_4)
		{
		  cst[opnum] = thisnib & 15;
		}
	      else if ((looking_for & SIZE) == L_5)
		{
		  cst[opnum] = data[len / 2] & 0x1f;
		}
	      else if (looking_for == E)
		{
#ifdef ADEBUG
		  dst->op = q;
#endif
		  /* Fill in the args.  */
		  {
		    op_type *args = q->args.nib;
		    int hadone = 0;
		    int nargs;

		    for (nargs = 0; 
			 nargs < 3 && *args != E; 
			 nargs++)
		      {
			int x = *args;
			ea_type *p;

			opnum = ((x & OP3) ? 2 :
				 (x & DST) ? 1 : 0);
			if (x & DST)
			  p = &dst->dst;
			else if (x & OP3)
			  p = &dst->op3;
			else
			  p = &dst->src;

			if ((x & MODE) == IMM  ||
			    (x & MODE) == KBIT ||
			    (x & MODE) == DBIT)
			  {
			    /* Use the instruction to determine 
			       the operand size.  */
			    p->type = X (OP_IMM, OP_SIZE (q->how));
			    p->literal = cst[opnum];
			  }
			else if ((x & MODE) == CONST_2 ||
				 (x & MODE) == CONST_4 ||
				 (x & MODE) == CONST_8 ||
				 (x & MODE) == CONST_16)
			  {
			    /* Use the instruction to determine 
			       the operand size.  */
			    p->type = X (OP_IMM, OP_SIZE (q->how));
			    switch (x & MODE) {
			    case CONST_2:	p->literal =  2; break;
			    case CONST_4:	p->literal =  4; break;
			    case CONST_8:	p->literal =  8; break;
			    case CONST_16:	p->literal = 16; break;
			    }
			  }
			else if ((x & MODE) == REG)
			  {
			    p->type = X (OP_REG, bitfrom (x));
			    p->reg = reg[opnum];
			  }
			else if ((x & MODE) == LOWREG)
			  {
			    p->type = X (OP_LOWREG, bitfrom (x));
			    p->reg = reg[opnum];
			  }
			else if ((x & MODE) == PREINC)
			  {
			    /* Use the instruction to determine 
			       the operand size.  */
			    p->type = X (OP_PREINC, OP_SIZE (q->how));
			    p->reg = reg[opnum] & 0x7;
			  }
			else if ((x & MODE) == POSTINC)
			  {
			    /* Use the instruction to determine 
			       the operand size.  */
			    p->type = X (OP_POSTINC, OP_SIZE (q->how));
			    p->reg = reg[opnum] & 0x7;
			  }
			else if ((x & MODE) == PREDEC)
			  {
			    /* Use the instruction to determine 
			       the operand size.  */
			    p->type = X (OP_PREDEC, OP_SIZE (q->how));
			    p->reg = reg[opnum] & 0x7;
			  }
			else if ((x & MODE) == POSTDEC)
			  {
			    /* Use the instruction to determine 
			       the operand size.  */
			    p->type = X (OP_POSTDEC, OP_SIZE (q->how));
			    p->reg = reg[opnum] & 0x7;
			  }
			else if ((x & MODE) == IND)
			  {
			    /* Note: an indirect is transformed into
			       a displacement of zero.  
			    */
			    /* Use the instruction to determine 
			       the operand size.  */
			    p->type = X (OP_DISP, OP_SIZE (q->how));
			    p->reg = reg[opnum] & 0x7;
			    p->literal = 0;
			    if (OP_KIND (q->how) == O_JSR ||
				OP_KIND (q->how) == O_JMP)
			      if (lvalue (sd, p->type, p->reg, &p->type))
				goto end;
			  }
			else if ((x & MODE) == ABS)
			  {
			    /* Note: a 16 or 32 bit ABS is transformed into a 
			       displacement from pseudo-register ZERO_REGNUM,
			       which is always zero.  An 8 bit ABS becomes
			       a displacement from SBR_REGNUM.
			    */
			    /* Use the instruction to determine 
			       the operand size.  */
			    p->type = X (OP_DISP, OP_SIZE (q->how));
			    p->literal = cst[opnum];

			    /* 8-bit ABS is displacement from SBR.
			       16 and 32-bit ABS are displacement from ZERO.
			       (SBR will always be zero except for h8/sx)
			    */
			    if ((x & SIZE) == L_8)
			      p->reg = SBR_REGNUM;
			    else
			      p->reg = ZERO_REGNUM;;
			  }
			else if ((x & MODE) == MEMIND ||
				 (x & MODE) == VECIND)
			  {
			    /* Size doesn't matter.  */
			    p->type = X (OP_MEM, SB);
			    p->literal = cst[opnum];
			    if (OP_KIND (q->how) == O_JSR ||
				OP_KIND (q->how) == O_JMP)
			      if (lvalue (sd, p->type, p->reg, &p->type))
				goto end;
			  }
			else if ((x & MODE) == PCREL)
			  {
			    /* Size doesn't matter.  */
			    p->type = X (OP_PCREL, SB);
			    p->literal = cst[opnum];
			  }
			else if (x & ABSJMP)
			  {
			    p->type = X (OP_IMM, SP);
			    p->literal = cst[opnum];
			  }
			else if ((x & MODE) == INDEXB)
			  {
			    p->type = X (OP_INDEXB, OP_SIZE (q->how));
			    p->literal = cst[opnum];
			    p->reg     = rdisp[opnum];
			  }
			else if ((x & MODE) == INDEXW)
			  {
			    p->type = X (OP_INDEXW, OP_SIZE (q->how));
			    p->literal = cst[opnum];
			    p->reg     = rdisp[opnum];
			  }
			else if ((x & MODE) == INDEXL)
			  {
			    p->type = X (OP_INDEXL, OP_SIZE (q->how));
			    p->literal = cst[opnum];
			    p->reg     = rdisp[opnum];
			  }
			else if ((x & MODE) == DISP)
			  {
			    /* Yuck -- special for mova args.  */
			    if (strncmp (q->name, "mova", 4) == 0 &&
				(x & SIZE) == L_2)
			      {
				/* Mova can have a DISP2 dest, with an
				   INDEXB or INDEXW src.  The multiplier
				   for the displacement value is determined
				   by the src operand, not by the insn.  */

				switch (OP_KIND (dst->src.type))
				  {
				  case OP_INDEXB:
				    p->type = X (OP_DISP, SB);
				    p->literal = cst[opnum];
				    break;
				  case OP_INDEXW:
				    p->type = X (OP_DISP, SW);
				    p->literal = cst[opnum] * 2;
				    break;
				  default:
				    goto fail;
				  }
			      }
			    else
			      {
				p->type = X (OP_DISP,   OP_SIZE (q->how));
				p->literal = cst[opnum];
				/* DISP2 is special.  */
				if ((x & SIZE) == L_2)
				  switch (OP_SIZE (q->how))
				    {
				    case SB:                  break;
				    case SW: p->literal *= 2; break;
				    case SL: p->literal *= 4; break;
				    }
			      }
			    p->reg     = rdisp[opnum];
			  }
			else if (x & CTRL)
			  {
			    switch (reg[opnum])
			      {
			      case C_CCR:
				p->type = X (OP_CCR, SB);
				break;
			      case C_EXR:
				p->type = X (OP_EXR, SB);
				break;
			      case C_MACH:
				p->type = X (OP_MACH, SL);
				break;
			      case C_MACL:
				p->type = X (OP_MACL, SL);
				break;
			      case C_VBR:
				p->type = X (OP_VBR, SL);
				break;
			      case C_SBR:
				p->type = X (OP_SBR, SL);
				break;
			      }
			  }
			else if ((x & MODE) == CCR)
			  {
			    p->type = OP_CCR;
			  }
			else if ((x & MODE) == EXR)
			  {
			    p->type = OP_EXR;
			  }
			else
			  printf ("Hmmmm 0x%x...\n", x);

			args++;
		      }
		  }

		  /* Unary operators: treat src and dst as equivalent.  */
		  if (dst->dst.type == -1)
		    dst->dst = dst->src;
		  if (dst->src.type == -1)
		    dst->src = dst->dst;

		  dst->opcode = q->how;
		  dst->cycles = q->time;

		  /* And jsr's to these locations are turned into 
		     magic traps.  */

		  if (OP_KIND (dst->opcode) == O_JSR)
		    {
		      switch (dst->src.literal)
			{
			case 0xc5:
			  dst->opcode = O (O_SYS_OPEN, SB);
			  break;
			case 0xc6:
			  dst->opcode = O (O_SYS_READ, SB);
			  break;
			case 0xc7:
			  dst->opcode = O (O_SYS_WRITE, SB);
			  break;
			case 0xc8:
			  dst->opcode = O (O_SYS_LSEEK, SB);
			  break;
			case 0xc9:
			  dst->opcode = O (O_SYS_CLOSE, SB);
			  break;
			case 0xca:
			  dst->opcode = O (O_SYS_STAT, SB);
			  break;
			case 0xcb:
			  dst->opcode = O (O_SYS_FSTAT, SB);
			  break;
			case 0xcc:
			  dst->opcode = O (O_SYS_CMDLINE, SB);
			  break;
			}
		      /* End of Processing for system calls.  */
		    }

		  dst->next_pc = addr + len / 2;
		  return;
		}
	      else
		printf ("Don't understand 0x%x \n", looking_for);
d772 3
d776 1
a776 3
	  len++;
	  nib++;
	}
d778 3
a780 2
    fail:
      ;
a781 3
 end:
  /* Fell off the end.  */
  dst->opcode = O (O_ILL, SB);
d785 5
a789 1
compile (SIM_DESC sd, int pc)
d791 12
a802 1
  int idx;
d804 21
a824 4
  /* Find the next cache entry to use.  */
  idx = h8_get_cache_top (sd) + 1;
  h8_increment_compiles (sd);
  if (idx >= sd->sim_cache_size)
d826 6
a831 1
      idx = 1;
d833 1
a833 1
  h8_set_cache_top (sd, idx);
d835 17
a851 2
  /* Throw away its old meaning.  */
  h8_set_cache_idx (sd, sd->sim_cache[idx].oldpc, 0);
d853 25
a877 2
  /* Set to new address.  */
  sd->sim_cache[idx].oldpc = pc;
d879 45
a923 5
  /* Fill in instruction info.  */
  decode (sd, pc, h8_get_memory_buf (sd) + pc, sd->sim_cache + idx);

  /* Point to new cache entry.  */
  h8_set_cache_idx (sd, pc, idx);
d926 9
a934 501

static unsigned char  *breg[32];
static unsigned short *wreg[16];
static unsigned int   *lreg[18];

#define GET_B_REG(X)     *(breg[X])
#define SET_B_REG(X, Y) (*(breg[X])) = (Y)
#define GET_W_REG(X)     *(wreg[X])
#define SET_W_REG(X, Y) (*(wreg[X])) = (Y)
#define GET_L_REG(X)     h8_get_reg (sd, X)
#define SET_L_REG(X, Y)  h8_set_reg (sd, X, Y)

#define GET_MEMORY_L(X) \
  ((X) < memory_size \
   ? ((h8_get_memory (sd, (X)+0) << 24) | (h8_get_memory (sd, (X)+1) << 16)  \
    | (h8_get_memory (sd, (X)+2) <<  8) | (h8_get_memory (sd, (X)+3) <<  0)) \
   : ((h8_get_eightbit (sd, ((X)+0) & 0xff) << 24) \
    | (h8_get_eightbit (sd, ((X)+1) & 0xff) << 16) \
    | (h8_get_eightbit (sd, ((X)+2) & 0xff) <<  8) \
    | (h8_get_eightbit (sd, ((X)+3) & 0xff) <<  0)))

#define GET_MEMORY_W(X) \
  ((X) < memory_size \
   ? ((h8_get_memory   (sd, (X)+0) << 8) \
    | (h8_get_memory   (sd, (X)+1) << 0)) \
   : ((h8_get_eightbit (sd, ((X)+0) & 0xff) << 8) \
    | (h8_get_eightbit (sd, ((X)+1) & 0xff) << 0)))


#define GET_MEMORY_B(X) \
  ((X) < memory_size ? (h8_get_memory   (sd, (X))) \
                     : (h8_get_eightbit (sd, (X) & 0xff)))

#define SET_MEMORY_L(X, Y)  \
{  register unsigned char *_p; register int __y = (Y); \
   _p = ((X) < memory_size ? h8_get_memory_buf   (sd) +  (X) : \
                             h8_get_eightbit_buf (sd) + ((X) & 0xff)); \
   _p[0] = __y >> 24; _p[1] = __y >> 16; \
   _p[2] = __y >>  8; _p[3] = __y >>  0; \
}

#define SET_MEMORY_W(X, Y) \
{  register unsigned char *_p; register int __y = (Y); \
   _p = ((X) < memory_size ? h8_get_memory_buf   (sd) +  (X) : \
                             h8_get_eightbit_buf (sd) + ((X) & 0xff)); \
   _p[0] = __y >> 8; _p[1] = __y; \
}

#define SET_MEMORY_B(X, Y) \
  ((X) < memory_size ? (h8_set_memory   (sd, (X), (Y))) \
                     : (h8_set_eightbit (sd, (X) & 0xff, (Y))))

/* Simulate a memory fetch.
   Return 0 for success, -1 for failure.
*/

static int
fetch_1 (SIM_DESC sd, ea_type *arg, int *val, int twice)
{
  int rn = arg->reg;
  int abs = arg->literal;
  int r;
  int t;

  if (val == NULL)
    return -1;		/* Paranoia.  */

  switch (arg->type)
    {
      /* Indexed register plus displacement mode:

	 This new family of addressing modes are similar to OP_DISP
	 (register plus displacement), with two differences:
	   1) INDEXB uses only the least significant byte of the register,
	      INDEXW uses only the least significant word, and
	      INDEXL uses the entire register (just like OP_DISP).
	 and
	   2) The displacement value in abs is multiplied by two
	      for SW-sized operations, and by four for SL-size.

	This gives nine possible variations.
      */

    case X (OP_INDEXB, SB):
    case X (OP_INDEXB, SW):
    case X (OP_INDEXB, SL):
    case X (OP_INDEXW, SB):
    case X (OP_INDEXW, SW):
    case X (OP_INDEXW, SL):
    case X (OP_INDEXL, SB):
    case X (OP_INDEXL, SW):
    case X (OP_INDEXL, SL):
      t = GET_L_REG (rn);
      switch (OP_KIND (arg->type)) {
      case OP_INDEXB:	t &= 0xff;	break;
      case OP_INDEXW:	t &= 0xffff;	break;
      case OP_INDEXL:
      default:		break;
      }
      switch (OP_SIZE (arg->type)) {
      case SB:
	*val = GET_MEMORY_B ((t * 1 + abs) & h8_get_mask (sd));
	break;
      case SW:
	*val = GET_MEMORY_W ((t * 2 + abs) & h8_get_mask (sd));
	break;
      case SL:
	*val = GET_MEMORY_L ((t * 4 + abs) & h8_get_mask (sd));
	break;
      }
      break;

    case X (OP_LOWREG, SB):
      *val = GET_L_REG (rn) & 0xff;
      break;
    case X (OP_LOWREG, SW):
      *val = GET_L_REG (rn) & 0xffff; 
      break;

    case X (OP_REG, SB):	/* Register direct, byte.  */
      *val = GET_B_REG (rn);
      break;
    case X (OP_REG, SW):	/* Register direct, word.  */
      *val = GET_W_REG (rn);
      break;
    case X (OP_REG, SL):	/* Register direct, long.  */
      *val = GET_L_REG (rn);
      break;
    case X (OP_IMM, SB):	/* Immediate, byte.  */
    case X (OP_IMM, SW):	/* Immediate, word.  */
    case X (OP_IMM, SL):	/* Immediate, long.  */
      *val = abs;
      break;
    case X (OP_POSTINC, SB):	/* Register indirect w/post-incr: byte.  */
      t = GET_L_REG (rn);
      t &= h8_get_mask (sd);
      r = GET_MEMORY_B (t);
      if (!twice)
	t += 1;
      t = t & h8_get_mask (sd);
      SET_L_REG (rn, t);
      *val = r;
      break;
    case X (OP_POSTINC, SW):	/* Register indirect w/post-incr: word.  */
      t = GET_L_REG (rn);
      t &= h8_get_mask (sd);
      r = GET_MEMORY_W (t);
      if (!twice)
	t += 2;
      t = t & h8_get_mask (sd);
      SET_L_REG (rn, t);
      *val = r;
      break;
    case X (OP_POSTINC, SL):	/* Register indirect w/post-incr: long.  */
      t = GET_L_REG (rn);
      t &= h8_get_mask (sd);
      r = GET_MEMORY_L (t);
      if (!twice)
	t += 4;
      t = t & h8_get_mask (sd);
      SET_L_REG (rn, t);
      *val = r;
      break;

    case X (OP_POSTDEC, SB):	/* Register indirect w/post-decr: byte.  */
      t = GET_L_REG (rn);
      t &= h8_get_mask (sd);
      r = GET_MEMORY_B (t);
      if (!twice)
	t -= 1;
      t = t & h8_get_mask (sd);
      SET_L_REG (rn, t);
      *val = r;
      break;
    case X (OP_POSTDEC, SW):	/* Register indirect w/post-decr: word.  */
      t = GET_L_REG (rn);
      t &= h8_get_mask (sd);
      r = GET_MEMORY_W (t);
      if (!twice)
	t -= 2;
      t = t & h8_get_mask (sd);
      SET_L_REG (rn, t);
      *val = r;
      break;
    case X (OP_POSTDEC, SL):	/* Register indirect w/post-decr: long.  */
      t = GET_L_REG (rn);
      t &= h8_get_mask (sd);
      r = GET_MEMORY_L (t);
      if (!twice)
	t -= 4;
      t = t & h8_get_mask (sd);
      SET_L_REG (rn, t);
      *val = r;
      break;

    case X (OP_PREDEC, SB):	/* Register indirect w/pre-decr: byte.  */
      t = GET_L_REG (rn) - 1;
      t &= h8_get_mask (sd);
      SET_L_REG (rn, t);
      *val = GET_MEMORY_B (t);
      break;
      
    case X (OP_PREDEC, SW):	/* Register indirect w/pre-decr: word.  */
      t = GET_L_REG (rn) - 2;
      t &= h8_get_mask (sd);
      SET_L_REG (rn, t);
      *val = GET_MEMORY_W (t);
      break;
      
    case X (OP_PREDEC, SL):	/* Register indirect w/pre-decr: long.  */
      t = GET_L_REG (rn) - 4;
      t &= h8_get_mask (sd);
      SET_L_REG (rn, t);
      *val = GET_MEMORY_L (t);
      break;
      
    case X (OP_PREINC, SB):	/* Register indirect w/pre-incr: byte.  */
      t = GET_L_REG (rn) + 1;
      t &= h8_get_mask (sd);
      SET_L_REG (rn, t);
      *val = GET_MEMORY_B (t);
      break;

    case X (OP_PREINC, SW):	/* Register indirect w/pre-incr: long.  */
      t = GET_L_REG (rn) + 2;
      t &= h8_get_mask (sd);
      SET_L_REG (rn, t);
      *val = GET_MEMORY_W (t);
      break;

    case X (OP_PREINC, SL):	/* Register indirect w/pre-incr: long.  */
      t = GET_L_REG (rn) + 4;
      t &= h8_get_mask (sd);
      SET_L_REG (rn, t);
      *val = GET_MEMORY_L (t);
      break;

    case X (OP_DISP, SB):	/* Register indirect w/displacement: byte.  */
      t = GET_L_REG (rn) + abs;
      t &= h8_get_mask (sd);
      *val = GET_MEMORY_B (t);
      break;

    case X (OP_DISP, SW):	/* Register indirect w/displacement: word.  */
      t = GET_L_REG (rn) + abs;
      t &= h8_get_mask (sd);
      *val = GET_MEMORY_W (t);
      break;

    case X (OP_DISP, SL):	/* Register indirect w/displacement: long.  */
      t = GET_L_REG (rn) + abs;
      t &= h8_get_mask (sd);
      *val =GET_MEMORY_L (t);
      break;

    case X (OP_MEM, SL):	/* Absolute memory address, long.  */
      t = GET_MEMORY_L (abs);
      t &= h8_get_mask (sd);
      *val = t;
      break;

    case X (OP_MEM, SW):	/* Absolute memory address, word.  */
      t = GET_MEMORY_W (abs);
      t &= h8_get_mask (sd);
      *val = t;
      break;

    case X (OP_PCREL, SB):	/* PC relative (for jump, branch etc).  */
    case X (OP_PCREL, SW):
    case X (OP_PCREL, SL):
    case X (OP_PCREL, SN):
      *val = abs;
      break;

    case X (OP_MEM, SB):	/* Why isn't this implemented?  */
    default:
      sim_engine_set_run_state (sd, sim_stopped, SIGSEGV);
      return -1;
    }
  return 0;	/* Success.  */
}

/* Normal fetch.  */

static int
fetch (SIM_DESC sd, ea_type *arg, int *val)
{
  return fetch_1 (sd, arg, val, 0);
}

/* Fetch which will be followed by a store to the same location.
   The difference being that we don't want to do a post-increment
   or post-decrement at this time: we'll do it when we store.  */

static int
fetch2 (SIM_DESC sd, ea_type *arg, int *val)
{
  return fetch_1 (sd, arg, val, 1);
}

/* Simulate a memory store.
   Return 0 for success, -1 for failure.
*/

static int
store_1 (SIM_DESC sd, ea_type *arg, int n, int twice)
{
  int rn = arg->reg;
  int abs = arg->literal;
  int t;

  switch (arg->type)
    {
      /* Indexed register plus displacement mode:

	 This new family of addressing modes are similar to OP_DISP
	 (register plus displacement), with two differences:
	   1) INDEXB uses only the least significant byte of the register,
	      INDEXW uses only the least significant word, and
	      INDEXL uses the entire register (just like OP_DISP).
	 and
	   2) The displacement value in abs is multiplied by two
	      for SW-sized operations, and by four for SL-size.

	This gives nine possible variations.
      */

    case X (OP_INDEXB, SB):
    case X (OP_INDEXB, SW):
    case X (OP_INDEXB, SL):
    case X (OP_INDEXW, SB):
    case X (OP_INDEXW, SW):
    case X (OP_INDEXW, SL):
    case X (OP_INDEXL, SB):
    case X (OP_INDEXL, SW):
    case X (OP_INDEXL, SL):
      t = GET_L_REG (rn);
      switch (OP_KIND (arg->type)) {
      case OP_INDEXB:	t &= 0xff;	break;
      case OP_INDEXW:	t &= 0xffff;	break;
      case OP_INDEXL:
      default:		break;
      }
      switch (OP_SIZE (arg->type)) {
      case SB:
	SET_MEMORY_B ((t * 1 + abs) & h8_get_mask (sd), n);
	break;
      case SW:
	SET_MEMORY_W ((t * 2 + abs) & h8_get_mask (sd), n);
	break;
      case SL:
	SET_MEMORY_L ((t * 4 + abs) & h8_get_mask (sd), n);
	break;
      }
      break;

    case X (OP_REG, SB):	/* Register direct, byte.  */
      SET_B_REG (rn, n);
      break;
    case X (OP_REG, SW):	/* Register direct, word.  */
      SET_W_REG (rn, n);
      break;
    case X (OP_REG, SL):	/* Register direct, long.  */
      SET_L_REG (rn, n);
      break;

    case X (OP_PREDEC, SB):	/* Register indirect w/pre-decr, byte.  */
      t = GET_L_REG (rn);
      if (!twice)
	t -= 1;
      t &= h8_get_mask (sd);
      SET_L_REG (rn, t);
      SET_MEMORY_B (t, n);

      break;
    case X (OP_PREDEC, SW):	/* Register indirect w/pre-decr, word.  */
      t = GET_L_REG (rn);
      if (!twice)
	t -= 2;
      t &= h8_get_mask (sd);
      SET_L_REG (rn, t);
      SET_MEMORY_W (t, n);
      break;

    case X (OP_PREDEC, SL):	/* Register indirect w/pre-decr, long.  */
      t = GET_L_REG (rn);
      if (!twice)
	t -= 4;
      t &= h8_get_mask (sd);
      SET_L_REG (rn, t);
      SET_MEMORY_L (t, n);
      break;

    case X (OP_PREINC, SB):	/* Register indirect w/pre-incr, byte.  */
      t = GET_L_REG (rn);
      if (!twice)
	t += 1;
      t &= h8_get_mask (sd);
      SET_L_REG (rn, t);
      SET_MEMORY_B (t, n);

      break;
    case X (OP_PREINC, SW):	/* Register indirect w/pre-incr, word.  */
      t = GET_L_REG (rn);
      if (!twice)
	t += 2;
      t &= h8_get_mask (sd);
      SET_L_REG (rn, t);
      SET_MEMORY_W (t, n);
      break;

    case X (OP_PREINC, SL):	/* Register indirect w/pre-incr, long.  */
      t = GET_L_REG (rn);
      if (!twice)
	t += 4;
      t &= h8_get_mask (sd);
      SET_L_REG (rn, t);
      SET_MEMORY_L (t, n);
      break;

    case X (OP_POSTDEC, SB):	/* Register indirect w/post-decr, byte.  */
      t = GET_L_REG (rn) & h8_get_mask (sd);
      SET_MEMORY_B (t, n);
      SET_L_REG (rn, t - 1);
      break;

    case X (OP_POSTDEC, SW):	/* Register indirect w/post-decr, word.  */
      t = GET_L_REG (rn) & h8_get_mask (sd);
      SET_MEMORY_W (t, n);
      SET_L_REG (rn, t - 2);
      break;

    case X (OP_POSTDEC, SL):	/* Register indirect w/post-decr, long.  */
      t = GET_L_REG (rn) & h8_get_mask (sd);
      SET_MEMORY_L (t, n);
      SET_L_REG (rn, t - 4);
      break;

    case X (OP_POSTINC, SB):	/* Register indirect w/post-incr, byte.  */
      t = GET_L_REG (rn) & h8_get_mask (sd);
      SET_MEMORY_B (t, n);
      SET_L_REG (rn, t + 1);
      break;

    case X (OP_POSTINC, SW):	/* Register indirect w/post-incr, word.  */
      t = GET_L_REG (rn) & h8_get_mask (sd);
      SET_MEMORY_W (t, n);
      SET_L_REG (rn, t + 2);
      break;

    case X (OP_POSTINC, SL):	/* Register indirect w/post-incr, long.  */
      t = GET_L_REG (rn) & h8_get_mask (sd);
      SET_MEMORY_L (t, n);
      SET_L_REG (rn, t + 4);
      break;

    case X (OP_DISP, SB):	/* Register indirect w/displacement, byte.  */
      t = GET_L_REG (rn) + abs;
      t &= h8_get_mask (sd);
      SET_MEMORY_B (t, n);
      break;

    case X (OP_DISP, SW):	/* Register indirect w/displacement, word.  */
      t = GET_L_REG (rn) + abs;
      t &= h8_get_mask (sd);
      SET_MEMORY_W (t, n);
      break;

    case X (OP_DISP, SL):	/* Register indirect w/displacement, long.  */
      t = GET_L_REG (rn) + abs;
      t &= h8_get_mask (sd);
      SET_MEMORY_L (t, n);
      break;


    case X (OP_MEM, SB):	/* Why isn't this implemented?  */
    case X (OP_MEM, SW):	/* Why isn't this implemented?  */
    case X (OP_MEM, SL):	/* Why isn't this implemented?  */
    default:
      sim_engine_set_run_state (sd, sim_stopped, SIGSEGV);
      return -1;
    }
  return 0;
}

/* Normal store.  */

static int
store (SIM_DESC sd, ea_type *arg, int n)
{
  return store_1 (sd, arg, n, 0);
}

/* Store which follows a fetch from the same location.
   The difference being that we don't want to do a pre-increment
   or pre-decrement at this time: it was already done when we fetched.  */

static int
store2 (SIM_DESC sd, ea_type *arg, int n)
{
  return store_1 (sd, arg, n, 1);
d937 8
a944 1931
static union
{
  short int i;
  struct
    {
      char low;
      char high;
    }
  u;
} littleendian;

/* Flag to be set whenever a new SIM_DESC object is created.  */
static int init_pointers_needed = 1;

static void
init_pointers (SIM_DESC sd)
{
  if (init_pointers_needed)
    {
      int i;

      littleendian.i = 1;

      if (h8300smode && !h8300_normal_mode)
	memory_size = H8300S_MSIZE;
      else if (h8300hmode && !h8300_normal_mode)
	memory_size = H8300H_MSIZE;
      else
	memory_size = H8300_MSIZE;
      /* `msize' must be a power of two.  */
      if ((memory_size & (memory_size - 1)) != 0)
	{
	  (*sim_callback->printf_filtered) 
	    (sim_callback,
	     "init_pointers: bad memory size %d, defaulting to %d.\n", 
	     memory_size, memory_size = H8300S_MSIZE);
	}

      if (h8_get_memory_buf (sd))
	free (h8_get_memory_buf (sd));
      if (h8_get_cache_idx_buf (sd))
	free (h8_get_cache_idx_buf (sd));
      if (h8_get_eightbit_buf (sd))
	free (h8_get_eightbit_buf (sd));

      h8_set_memory_buf (sd, (unsigned char *) 
			 calloc (sizeof (char), memory_size));
      h8_set_cache_idx_buf (sd, (unsigned short *) 
			    calloc (sizeof (short), memory_size));
      sd->memory_size = memory_size;
      h8_set_eightbit_buf (sd, (unsigned char *) calloc (sizeof (char), 256));

      h8_set_mask (sd, memory_size - 1);

      memset (h8_get_reg_buf (sd), 0, sizeof (((STATE_CPU (sd, 0))->regs)));

      for (i = 0; i < 8; i++)
	{
	  /* FIXME: rewrite using local buffer.  */
	  unsigned char *p = (unsigned char *) (h8_get_reg_buf (sd) + i);
	  unsigned char *e = (unsigned char *) (h8_get_reg_buf (sd) + i + 1);
	  unsigned short *q = (unsigned short *) (h8_get_reg_buf (sd) + i);
	  unsigned short *u = (unsigned short *) (h8_get_reg_buf (sd) + i + 1);
	  h8_set_reg (sd, i, 0x00112233);

	  while (p < e)
	    {
	      if (*p == 0x22)
		  breg[i] = p;
	      if (*p == 0x33)
		  breg[i + 8] = p;
	      if (*p == 0x11)
		breg[i + 16] = p;
	      if (*p == 0x00)
		breg[i + 24] = p;
	      p++;
	    }

	  wreg[i] = wreg[i + 8] = 0;
	  while (q < u)
	    {
	      if (*q == 0x2233)
		{
		  wreg[i] = q;
		}
	      if (*q == 0x0011)
		{
		  wreg[i + 8] = q;
		}
	      q++;
	    }

	  if (wreg[i] == 0 || wreg[i + 8] == 0)
	    (*sim_callback->printf_filtered) (sim_callback, 
					      "init_pointers: internal error.\n");

	  h8_set_reg (sd, i, 0);
	  lreg[i] = h8_get_reg_buf (sd) + i;
	}

      /* Note: sim uses pseudo-register ZERO as a zero register.  */
      lreg[ZERO_REGNUM] = h8_get_reg_buf (sd) + ZERO_REGNUM;
      init_pointers_needed = 0;

      /* Initialize the seg registers.  */
      if (!sd->sim_cache)
	set_simcache_size (sd, CSIZE);
    }
}

/* Grotty global variable for use by control_c signal handler.  */
static SIM_DESC control_c_sim_desc;

static void
control_c (int sig)
{
  sim_engine_set_run_state (control_c_sim_desc, sim_stopped, SIGINT);
}

int
sim_stop (SIM_DESC sd)
{
  /* FIXME: use a real signal value.  */
  sim_engine_set_run_state (sd, sim_stopped, SIGINT);
  return 1;
}

#define OBITOP(name, f, s, op) 			\
case O (name, SB):				\
{						\
  int m, tmp;					\
	 					\
  if (f)					\
    if (fetch (sd, &code->dst, &ea))		\
      goto end;					\
  if (fetch (sd, &code->src, &tmp))		\
    goto end;					\
  m = 1 << tmp;					\
  op;						\
  if (s)					\
    if (store (sd, &code->dst,ea))		\
      goto end;					\
  goto next;					\
}

void
sim_resume (SIM_DESC sd, int step, int siggnal)
{
  static int init1;
  int cycles = 0;
  int insts = 0;
  int tick_start = get_now ();
  void (*prev) ();
  int poll_count = 0;
  int res;
  int tmp;
  int rd;
  int ea;
  int bit;
  int pc;
  int c, nz, v, n, u, h, ui, intMaskBit;
  int trace, intMask;
  int oldmask;
  enum sim_stop reason;
  int sigrc;

  init_pointers (sd);

  control_c_sim_desc = sd;
  prev = signal (SIGINT, control_c);

  if (step)
    {
      sim_engine_set_run_state (sd, sim_stopped, SIGTRAP);
    }
  else
    {
      sim_engine_set_run_state (sd, sim_running, 0);
    }

  pc = h8_get_pc (sd);

  /* The PC should never be odd.  */
  if (pc & 0x1)
    {
      sim_engine_set_run_state (sd, sim_stopped, SIGBUS);
      return;
    }

  /* Get Status Register (flags).  */
  GETSR (sd);

  if (h8300smode)	/* Get exr.  */
    {
      trace = (h8_get_exr (sd) >> 7) & 1;
      intMask = h8_get_exr (sd) & 7;
    }

  oldmask = h8_get_mask (sd);
  if (!h8300hmode || h8300_normal_mode)
    h8_set_mask (sd, 0xffff);
  do
    {
      unsigned short cidx;
      decoded_inst *code;

    top:
      cidx = h8_get_cache_idx (sd, pc);
      if (cidx == (unsigned short) -1 ||
	  cidx >= sd->sim_cache_size)
	goto illegal;
	  
      code = sd->sim_cache + cidx;

#if ADEBUG
      if (debug)
	{
	  printf ("%x %d %s\n", pc, code->opcode,
		  code->op ? code->op->name : "**");
	}
      h8_increment_stats (sd, code->opcode);
#endif

      if (code->opcode)
	{
	  cycles += code->cycles;
	  insts++;
	}

      switch (code->opcode)
	{
	case 0:
	  /*
	   * This opcode is a fake for when we get to an
	   * instruction which hasnt been compiled
	   */
	  compile (sd, pc);
	  goto top;
	  break;

	case O (O_MOVAB, SL):
	case O (O_MOVAW, SL):
	case O (O_MOVAL, SL):
	  /* 1) Evaluate 2nd argument (dst).
	     2) Mask / zero extend according to whether 1st argument (src)
	        is INDEXB, INDEXW, or INDEXL.
	     3) Left-shift the result by 0, 1 or 2, according to size of mova
	        (mova/b, mova/w, mova/l).
	     4) Add literal value of 1st argument (src).
	     5) Store result in 3rd argument (op3).
	  */

	  /* Alas, since this is the only instruction with 3 arguments, 
	     decode doesn't handle them very well.  Some fix-up is required.

	     a) The size of dst is determined by whether src is 
	        INDEXB or INDEXW.  */

	  if (OP_KIND (code->src.type) == OP_INDEXB)
	    code->dst.type = X (OP_KIND (code->dst.type), SB);
	  else if (OP_KIND (code->src.type) == OP_INDEXW)
	    code->dst.type = X (OP_KIND (code->dst.type), SW);

	  /* b) If op3 == null, then this is the short form of the insn.
	        Dst is the dispreg of src, and op3 is the 32-bit form
		of the same register.
	  */

	  if (code->op3.type == 0)
	    {
	      /* Short form: src == INDEXB/INDEXW, dst == op3 == 0.
		 We get to compose dst and op3 as follows:

		     op3 is a 32-bit register, ID == src.reg.
		     dst is the same register, but 8 or 16 bits
		     depending on whether src is INDEXB or INDEXW.
	      */

	      code->op3.type = X (OP_REG, SL);
	      code->op3.reg  = code->src.reg;
	      code->op3.literal = 0;

	      if (OP_KIND (code->src.type) == OP_INDEXB)
		code->dst.type = X (OP_REG, SB);
	      else
		code->dst.type = X (OP_REG, SW);
	    }

	  if (fetch (sd, &code->dst, &ea))
	    goto end;

	  switch (OP_KIND (code->src.type)) {
	  case OP_INDEXB:    ea = ea & 0xff;		break;
	  case OP_INDEXW:    ea = ea & 0xffff;		break;
	  case OP_INDEXL:    				break;
	  default:	     goto illegal;
	  }

	  switch (code->opcode) {
	  case O (O_MOVAB, SL):	    			break;
	  case O (O_MOVAW, SL):	    ea = ea << 1;	break;
	  case O (O_MOVAL, SL):     ea = ea << 2;	break;
	  default: 		    goto illegal;
	  }
	  
	  ea = ea + code->src.literal;

	  if (store (sd, &code->op3, ea))
	    goto end;

	  goto next;	  

	case O (O_SUBX, SB):	/* subx, extended sub */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = -(ea + C);
	  res = rd + ea;
	  goto alu8;

	case O (O_SUBX, SW):	/* subx, extended sub */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = -(ea + C);
	  res = rd + ea;
	  goto alu16;

	case O (O_SUBX, SL):	/* subx, extended sub */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = -(ea + C);
	  res = rd + ea;
	  goto alu32;

	case O (O_ADDX, SB):	/* addx, extended add */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = ea + C;
	  res = rd + ea;
	  goto alu8;

	case O (O_ADDX, SW):	/* addx, extended add */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = ea + C;
	  res = rd + ea;
	  goto alu16;

	case O (O_ADDX, SL):	/* addx, extended add */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = ea + C;
	  res = rd + ea;
	  goto alu32;

	case O (O_SUB, SB):		/* sub.b */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  ea = -ea;
	  res = rd + ea;
	  goto alu8;

	case O (O_SUB, SW):		/* sub.w */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  ea = -ea;
	  res = rd + ea;
	  goto alu16;

	case O (O_SUB, SL):		/* sub.l */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  ea = -ea;
	  res = rd + ea;
	  goto alu32;

	case O (O_NEG, SB):		/* neg.b */
	  /* Fetch ea.  */
	  if (fetch2 (sd, &code->src, &ea)) 
	    goto end;
	  ea = -ea;
	  rd = 0;
	  res = rd + ea;
	  goto alu8;

	case O (O_NEG, SW):		/* neg.w */
	  /* Fetch ea.  */
	  if (fetch2 (sd, &code->src, &ea)) 
	    goto end;
	  ea = -ea;
	  rd = 0;
	  res = rd + ea;
	  goto alu16;

	case O (O_NEG, SL):		/* neg.l */
	  /* Fetch ea.  */
	  if (fetch2 (sd, &code->src, &ea)) 
	    goto end;
	  ea = -ea;
	  rd = 0;
	  res = rd + ea;
	  goto alu32;

	case O (O_ADD, SB):		/* add.b */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  res = rd + ea;
	  goto alu8;

	case O (O_ADD, SW):		/* add.w */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  res = rd + ea;
	  goto alu16;

	case O (O_ADD, SL):		/* add.l */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  res = rd + ea;
	  goto alu32;

	case O (O_AND, SB):		/* and.b */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd & ea;
	  goto log8;

	case O (O_AND, SW):		/* and.w */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd & ea;
	  goto log16;

	case O (O_AND, SL):		/* and.l */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd & ea;
	  goto log32;

	case O (O_OR, SB):		/* or.b */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd | ea;
	  goto log8;

	case O (O_OR, SW):		/* or.w */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd | ea;
	  goto log16;

	case O (O_OR, SL):		/* or.l */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd | ea;
	  goto log32;

	case O (O_XOR, SB):		/* xor.b */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd ^ ea;
	  goto log8;

	case O (O_XOR, SW):		/* xor.w */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd ^ ea;
	  goto log16;

	case O (O_XOR, SL):		/* xor.l */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd ^ ea;
	  goto log32;

	case O (O_MOV, SB):
	  if (fetch (sd, &code->src, &res))
	    goto end;
	  if (store (sd, &code->dst, res))
	    goto end;
	  goto just_flags_log8;
	case O (O_MOV, SW):
	  if (fetch (sd, &code->src, &res))
	    goto end;
	  if (store (sd, &code->dst, res))
	    goto end;
	  goto just_flags_log16;
	case O (O_MOV, SL):
	  if (fetch (sd, &code->src, &res))
	    goto end;
	  if (store (sd, &code->dst, res))
	    goto end;
	  goto just_flags_log32;

	case O (O_MOVMD, SB):		/* movmd.b */
	  ea = GET_W_REG (4);
	  if (ea == 0)
	    ea = 0x10000;

	  while (ea--)
	    {
	      rd = GET_MEMORY_B (GET_L_REG (5));
	      SET_MEMORY_B (GET_L_REG (6), rd);
	      SET_L_REG (5, GET_L_REG (5) + 1);
	      SET_L_REG (6, GET_L_REG (6) + 1);
	      SET_W_REG (4, ea);
	    }
	  goto next;

	case O (O_MOVMD, SW):		/* movmd.w */
	  ea = GET_W_REG (4);
	  if (ea == 0)
	    ea = 0x10000;

	  while (ea--)
	    {
	      rd = GET_MEMORY_W (GET_L_REG (5));
	      SET_MEMORY_W (GET_L_REG (6), rd);
	      SET_L_REG (5, GET_L_REG (5) + 2);
	      SET_L_REG (6, GET_L_REG (6) + 2);
	      SET_W_REG (4, ea);
	    }
	  goto next;

	case O (O_MOVMD, SL):		/* movmd.l */
	  ea = GET_W_REG (4);
	  if (ea == 0)
	    ea = 0x10000;

	  while (ea--)
	    {
	      rd = GET_MEMORY_L (GET_L_REG (5));
	      SET_MEMORY_L (GET_L_REG (6), rd);
	      SET_L_REG (5, GET_L_REG (5) + 4);
	      SET_L_REG (6, GET_L_REG (6) + 4);
	      SET_W_REG (4, ea);
	    }
	  goto next;

	case O (O_MOVSD, SB):		/* movsd.b */
	  /* This instruction implements strncpy, with a conditional branch.
	     r4 contains n, r5 contains src, and r6 contains dst.
	     The 16-bit displacement operand is added to the pc
	     if and only if the end of string is reached before
	     n bytes are transferred.  */

	  ea = GET_L_REG (4) & 0xffff;
	  if (ea == 0)
	    ea = 0x10000;

	  while (ea--)
	    {
	      rd = GET_MEMORY_B (GET_L_REG (5));
	      SET_MEMORY_B (GET_L_REG (6), rd);
	      SET_L_REG (5, GET_L_REG (5) + 1);
	      SET_L_REG (6, GET_L_REG (6) + 1);
	      SET_W_REG (4, ea); 
	      if (rd == 0)
		goto condtrue;
	    }
	  goto next;

	case O (O_EEPMOV, SB):		/* eepmov.b */
	case O (O_EEPMOV, SW):		/* eepmov.w */
	  if (h8300hmode || h8300smode)
	    {
	      register unsigned char *_src, *_dst;
	      unsigned int count = ((code->opcode == O (O_EEPMOV, SW))
				    ? h8_get_reg (sd, R4_REGNUM) & 0xffff
				    : h8_get_reg (sd, R4_REGNUM) & 0xff);

	      _src = (h8_get_reg (sd, R5_REGNUM) < memory_size
		      ? h8_get_memory_buf   (sd) + h8_get_reg (sd, R5_REGNUM)
		      : h8_get_eightbit_buf (sd) + 
		       (h8_get_reg (sd, R5_REGNUM) & 0xff));
	      if ((_src + count) >= (h8_get_memory_buf (sd) + memory_size))
		{
		  if ((_src + count) >= (h8_get_eightbit_buf (sd) + 0x100))
		    goto illegal;
		}
	      _dst = (h8_get_reg (sd, R6_REGNUM) < memory_size
		      ? h8_get_memory_buf   (sd) + h8_get_reg (sd, R6_REGNUM)
		      : h8_get_eightbit_buf (sd) + 
		       (h8_get_reg (sd, R6_REGNUM) & 0xff));

	      if ((_dst + count) >= (h8_get_memory_buf (sd) + memory_size))
		{
		  if ((_dst + count) >= (h8_get_eightbit_buf (sd) + 0x100))
		    goto illegal;
		}
	      memcpy (_dst, _src, count);

	      h8_set_reg (sd, R5_REGNUM, h8_get_reg (sd, R5_REGNUM) + count);
	      h8_set_reg (sd, R6_REGNUM, h8_get_reg (sd, R6_REGNUM) + count);
	      h8_set_reg (sd, R4_REGNUM, h8_get_reg (sd, R4_REGNUM) &
			  ((code->opcode == O (O_EEPMOV, SW))
			  ? (~0xffff) : (~0xff)));
	      cycles += 2 * count;
	      goto next;
	    }
	  goto illegal;

	case O (O_ADDS, SL):		/* adds (.l) */
	  /* FIXME fetch.
	   * This insn only uses register operands, but still
	   * it would be cleaner to use fetch and store...  */	  
	  SET_L_REG (code->dst.reg,
		     GET_L_REG (code->dst.reg)
		     + code->src.literal);

	  goto next;

	case O (O_SUBS, SL):		/* subs (.l) */
	  /* FIXME fetch.
	   * This insn only uses register operands, but still
	   * it would be cleaner to use fetch and store...  */	  
	  SET_L_REG (code->dst.reg,
		     GET_L_REG (code->dst.reg)
		     - code->src.literal);
	  goto next;

	case O (O_CMP, SB):		/* cmp.b */
	  if (fetch (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = -ea;
	  res = rd + ea;
	  goto just_flags_alu8;

	case O (O_CMP, SW):		/* cmp.w */
	  if (fetch (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = -ea;
	  res = rd + ea;
	  goto just_flags_alu16;

	case O (O_CMP, SL):		/* cmp.l */
	  if (fetch (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = -ea;
	  res = rd + ea;
	  goto just_flags_alu32;

	case O (O_DEC, SB):		/* dec.b */
	  /* FIXME fetch.
	   * This insn only uses register operands, but still
	   * it would be cleaner to use fetch and store...  */	  
	  rd = GET_B_REG (code->src.reg);
	  ea = -1;
	  res = rd + ea;
	  SET_B_REG (code->src.reg, res);
	  goto just_flags_inc8;

	case O (O_DEC, SW):		/* dec.w */
	  /* FIXME fetch.
	   * This insn only uses register operands, but still
	   * it would be cleaner to use fetch and store...  */	  
	  rd = GET_W_REG (code->dst.reg);
	  ea = -code->src.literal;
	  res = rd + ea;
	  SET_W_REG (code->dst.reg, res);
	  goto just_flags_inc16;

	case O (O_DEC, SL):		/* dec.l */
	  /* FIXME fetch.
	   * This insn only uses register operands, but still
	   * it would be cleaner to use fetch and store...  */	  
	  rd = GET_L_REG (code->dst.reg);
	  ea = -code->src.literal;
	  res = rd + ea;
	  SET_L_REG (code->dst.reg, res);
	  goto just_flags_inc32;

	case O (O_INC, SB):		/* inc.b */
	  /* FIXME fetch.
	   * This insn only uses register operands, but still
	   * it would be cleaner to use fetch and store...  */	  
	  rd = GET_B_REG (code->src.reg);
	  ea = 1;
	  res = rd + ea;
	  SET_B_REG (code->src.reg, res);
	  goto just_flags_inc8;

	case O (O_INC, SW):		/* inc.w */
	  /* FIXME fetch.
	   * This insn only uses register operands, but still
	   * it would be cleaner to use fetch and store...  */	  
	  rd = GET_W_REG (code->dst.reg);
	  ea = code->src.literal;
	  res = rd + ea;
	  SET_W_REG (code->dst.reg, res);
	  goto just_flags_inc16;

	case O (O_INC, SL):		/* inc.l */
	  /* FIXME fetch.
	   * This insn only uses register operands, but still
	   * it would be cleaner to use fetch and store...  */	  
	  rd = GET_L_REG (code->dst.reg);
	  ea = code->src.literal;
	  res = rd + ea;
	  SET_L_REG (code->dst.reg, res);
	  goto just_flags_inc32;

	case O (O_LDC, SB):		/* ldc.b */
	  if (fetch (sd, &code->src, &res))
	    goto end;
	  goto setc;

	case O (O_LDC, SW):		/* ldc.w */
	  if (fetch (sd, &code->src, &res))
	    goto end;

	  /* Word operand, value from MSB, must be shifted.  */
	  res >>= 8;
	  goto setc;

	case O (O_LDC, SL):		/* ldc.l */
	  if (fetch (sd, &code->src, &res))
	    goto end;
	  switch (code->dst.type) {
	  case X (OP_SBR, SL):
	    h8_set_sbr (sd, res);
	    break;
	  case X (OP_VBR, SL):
	    h8_set_vbr (sd, res);
	    break;
	  default:
	    goto illegal;
	  }
	  goto next;

	case O (O_STC, SW):		/* stc.w */
	case O (O_STC, SB):		/* stc.b */
	  if (code->src.type == X (OP_CCR, SB))
	    {
	      BUILDSR (sd);
	      res = h8_get_ccr (sd);
	    }
	  else if (code->src.type == X (OP_EXR, SB) && h8300smode)
	    {
	      if (h8300smode)
		h8_set_exr (sd, (trace << 7) | intMask);
	      res = h8_get_exr (sd);
	    }
	  else
	    goto illegal;

	  /* Word operand, value to MSB, must be shifted.  */
	  if (code->opcode == X (O_STC, SW))
	    res <<= 8;
	  if (store (sd, &code->dst, res))
	    goto end;
	  goto next;
	case O (O_STC, SL):		/* stc.l */
	  switch (code->src.type) {
	  case X (OP_SBR, SL):
	    res = h8_get_sbr (sd);
	    break;
	  case X (OP_VBR, SL):
	    res = h8_get_vbr (sd);
	    break;
	  default:
	    goto illegal;
	  }
	  if (store (sd, &code->dst, res))
	    goto end;
	  goto next;

	case O (O_ANDC, SB):		/* andc.b */
	  if (code->dst.type == X (OP_CCR, SB))
	    {
	      BUILDSR (sd);
	      rd = h8_get_ccr (sd);
	    }
	  else if (code->dst.type == X (OP_EXR, SB) && h8300smode)
	    {
	      if (h8300smode)
		h8_set_exr (sd, (trace << 7) | intMask);
	      res = h8_get_exr (sd);
	    }
	  else
	    goto illegal;
	  ea = code->src.literal;
	  res = rd & ea;
	  goto setc;

	case O (O_ORC, SB):		/* orc.b */
	  if (code->dst.type == X (OP_CCR, SB))
	    {
	      BUILDSR (sd);
	      rd = h8_get_ccr (sd);
	    }
	  else if (code->dst.type == X (OP_EXR, SB) && h8300smode)
	    {
	      if (h8300smode)
		h8_set_exr (sd, (trace << 7) | intMask);
	      rd = h8_get_exr (sd);
	    }
	  else
	    goto illegal;
	  ea = code->src.literal;
	  res = rd | ea;
	  goto setc;

	case O (O_XORC, SB):		/* xorc.b */
	  if (code->dst.type == X (OP_CCR, SB))
	    {
	      BUILDSR (sd);
	      rd = h8_get_ccr (sd);
	    }
	  else if (code->dst.type == X (OP_EXR, SB) && h8300smode)
	    {
	      if (h8300smode)
		h8_set_exr (sd, (trace << 7) | intMask);
	      rd = h8_get_exr (sd);
	    }
	  else
	    goto illegal;
	  ea = code->src.literal;
	  res = rd ^ ea;
	  goto setc;

	case O (O_BRAS, SB):		/* bra/s  */
	  /* This is basically an ordinary branch, with a delay slot.  */
	  if (fetch (sd, &code->src, &res))
	    goto end;

	  if ((res & 1) == 0)
	    goto illegal;

	  res -= 1;

	  /* Execution continues at next instruction, but
	     delayed_branch is set up for next cycle.  */
	  h8_set_delayed_branch (sd, code->next_pc + res);
	  pc = code->next_pc;
	  goto end;

	case O (O_BRAB, SB):		/* bra rd.b */
	case O (O_BRAW, SW):		/* bra rd.w */
	case O (O_BRAL, SL):		/* bra erd.l */
	  if (fetch (sd, &code->src, &rd))
	    goto end;
	  switch (OP_SIZE (code->opcode)) {
	  case SB:	rd &= 0xff;		break;
	  case SW:	rd &= 0xffff;		break;
	  case SL:	rd &= 0xffffffff;	break;
	  }
	  pc = code->next_pc + rd;
	  goto end;

	case O (O_BRABC, SB):		/* bra/bc, branch if bit clear */
	case O (O_BRABS, SB):		/* bra/bs, branch if bit set   */
	case O (O_BSRBC, SB):		/* bsr/bc, call   if bit clear */
	case O (O_BSRBS, SB):		/* bsr/bs, call   if bit set   */
	  if (fetch (sd, &code->dst, &rd) ||
	      fetch (sd, &code->src, &bit))
	    goto end;

	  if (code->opcode == O (O_BRABC, SB) || /* branch if clear */
	      code->opcode == O (O_BSRBC, SB))	 /* call   if clear */
	    {
	      if ((rd & (1 << bit)))		/* no branch */
		goto next;
	    }
	  else					/* branch/call if set */
	    {
	      if (!(rd & (1 << bit)))		/* no branch */
		goto next;
	    }

	  if (fetch (sd, &code->op3, &res))	/* branch */
	    goto end;
	  pc = code->next_pc + res;

	  if (code->opcode == O (O_BRABC, SB) ||
	      code->opcode == O (O_BRABS, SB))	/* branch */
	    goto end;
	  else					/* call   */
	    goto call;

	case O (O_BRA, SN):
	case O (O_BRA, SL):
	case O (O_BRA, SW):
	case O (O_BRA, SB):		/* bra, branch always */
	  if (1)
	    goto condtrue;
	  goto next;

	case O (O_BRN, SB):		/* brn, ;-/  branch never? */
	  if (0)
	    goto condtrue;
	  goto next;

	case O (O_BHI, SB):		/* bhi */
	  if ((C || Z) == 0)
	    goto condtrue;
	  goto next;


	case O (O_BLS, SB):		/* bls */
	  if ((C || Z))
	    goto condtrue;
	  goto next;

	case O (O_BCS, SB):		/* bcs, branch if carry set */
	  if ((C == 1))
	    goto condtrue;
	  goto next;

	case O (O_BCC, SB):		/* bcc, branch if carry clear */
	  if ((C == 0))
	    goto condtrue;
	  goto next;

	case O (O_BEQ, SB):		/* beq, branch if zero set */
	  if (Z)
	    goto condtrue;
	  goto next;
	case O (O_BGT, SB):		/* bgt */
	  if (((Z || (N ^ V)) == 0))
	    goto condtrue;
	  goto next;

	case O (O_BLE, SB):		/* ble */
	  if (((Z || (N ^ V)) == 1))
	    goto condtrue;
	  goto next;

	case O (O_BGE, SB):		/* bge */
	  if ((N ^ V) == 0)
	    goto condtrue;
	  goto next;
	case O (O_BLT, SB):		/* blt */
	  if ((N ^ V))
	    goto condtrue;
	  goto next;
	case O (O_BMI, SB):		/* bmi */
	  if ((N))
	    goto condtrue;
	  goto next;
	case O (O_BNE, SB):		/* bne, branch if zero clear */
	  if ((Z == 0))
	    goto condtrue;
	  goto next;

	case O (O_BPL, SB):		/* bpl */
	  if (N == 0)
	    goto condtrue;
	  goto next;
	case O (O_BVC, SB):		/* bvc */
	  if ((V == 0))
	    goto condtrue;
	  goto next;
	case O (O_BVS, SB):		/* bvs */
	  if ((V == 1))
	    goto condtrue;
	  goto next;

	/* Trap for Command Line setup.  */
	case O (O_SYS_CMDLINE, SB):
	  {
	    int i = 0;		/* Loop counter.  */
	    int j = 0;		/* Loop counter.  */
	    int ind_arg_len = 0;	/* Length of each argument.  */
	    int no_of_args = 0;	/* The no. or cmdline args.  */
	    int current_location = 0;	/* Location of string.  */
	    int old_sp = 0;	/* The Initial Stack Pointer.  */
	    int no_of_slots = 0;	/* No. of slots required on the stack
					   for storing cmdline args.  */
	    int sp_move = 0;	/* No. of locations by which the stack needs
				   to grow.  */
	    int new_sp = 0;	/* The final stack pointer location passed
				   back.  */
	    int *argv_ptrs;	/* Pointers of argv strings to be stored.  */
	    int argv_ptrs_location = 0;	/* Location of pointers to cmdline
					   args on the stack.  */
	    int char_ptr_size = 0;	/* Size of a character pointer on
					   target machine.  */
	    int addr_cmdline = 0;	/* Memory location where cmdline has
					   to be stored.  */
	    int size_cmdline = 0;	/* Size of cmdline.  */

	    /* Set the address of 256 free locations where command line is
	       stored.  */
	    addr_cmdline = cmdline_location();
	    h8_set_reg (sd, 0, addr_cmdline);

	    /* Counting the no. of commandline arguments.  */
	    for (i = 0; h8_get_cmdline_arg (sd, i) != NULL; i++)
	      continue;

	    /* No. of arguments in the command line.  */
	    no_of_args = i;

	    /* Current location is just a temporary variable,which we are
	       setting to the point to the start of our commandline string.  */
	    current_location = addr_cmdline;

	    /* Allocating space for storing pointers of the command line
	       arguments.  */
	    argv_ptrs = (int *) malloc (sizeof (int) * no_of_args);

	    /* Setting char_ptr_size to the sizeof (char *) on the different
	       architectures.  */
	    if ((h8300hmode || h8300smode) && !h8300_normal_mode)
	      {
		char_ptr_size = 4;
	      }
	    else
	      {
		char_ptr_size = 2;
	      }

	    for (i = 0; i < no_of_args; i++)
	      {
		ind_arg_len = 0;

		/* The size of the commandline argument.  */
		ind_arg_len = strlen (h8_get_cmdline_arg (sd, i) + 1);

		/* The total size of the command line string.  */
		size_cmdline += ind_arg_len;

		/* As we have only 256 bytes, we need to provide a graceful
		   exit. Anyways, a program using command line arguments 
		   where we cannot store all the command line arguments
		   given may behave unpredictably.  */
		if (size_cmdline >= 256)
		  {
		    h8_set_reg (sd, 0, 0);
		    goto next;
		  }
		else
		  {
		    /* current_location points to the memory where the next
		       commandline argument is stored.  */
		    argv_ptrs[i] = current_location;
		    for (j = 0; j < ind_arg_len; j++)
		      {
			SET_MEMORY_B ((current_location +
				       (sizeof (char) * j)),
				      *(h8_get_cmdline_arg (sd, i) + 
				       sizeof (char) * j));
		      }

		    /* Setting current_location to the starting of next
		       argument.  */
		    current_location += ind_arg_len;
		  }
	      }

	    /* This is the original position of the stack pointer.  */
	    old_sp = h8_get_reg (sd, SP_REGNUM);

	    /* We need space from the stack to store the pointers to argvs.  */
	    /* As we will infringe on the stack, we need to shift the stack
	       pointer so that the data is not overwritten. We calculate how
	       much space is required.  */
	    sp_move = (no_of_args) * (char_ptr_size);

	    /* The final position of stack pointer, we have thus taken some
	       space from the stack.  */
	    new_sp = old_sp - sp_move;

	    /* Temporary variable holding value where the argv pointers need
	       to be stored.  */
	    argv_ptrs_location = new_sp;

	    /* The argv pointers are stored at sequential locations. As per
	       the H8300 ABI.  */
	    for (i = 0; i < no_of_args; i++)
	      {
		/* Saving the argv pointer.  */
		if ((h8300hmode || h8300smode) && !h8300_normal_mode)
		  {
		    SET_MEMORY_L (argv_ptrs_location, argv_ptrs[i]);
		  }
		else
		  {
		    SET_MEMORY_W (argv_ptrs_location, argv_ptrs[i]);
		  }
	
		/* The next location where the pointer to the next argv
		   string has to be stored.  */    
		argv_ptrs_location += char_ptr_size;
	      }

	    /* Required by POSIX, Setting 0x0 at the end of the list of argv
	       pointers.  */
	    if ((h8300hmode || h8300smode) && !h8300_normal_mode)
	      {
		SET_MEMORY_L (old_sp, 0x0);
	      }
	    else
	      {
		SET_MEMORY_W (old_sp, 0x0);
	      }

	    /* Freeing allocated memory.  */
	    free (argv_ptrs);
	    for (i = 0; i <= no_of_args; i++)
	      {
		free (h8_get_cmdline_arg (sd, i));
	      }
	    free (h8_get_command_line (sd));

	    /* The no. of argv arguments are returned in Reg 0.  */
	    h8_set_reg (sd, 0, no_of_args);
	    /* The Pointer to argv in Register 1.  */
	    h8_set_reg (sd, 1, new_sp);
	    /* Setting the stack pointer to the new value.  */
	    h8_set_reg (sd, SP_REGNUM, new_sp);
	  }
	  goto next;

	  /* System call processing starts.  */
	case O (O_SYS_OPEN, SB):
	  {
	    int len = 0;	/* Length of filename.  */
	    char *filename;	/* Filename would go here.  */
	    char temp_char;	/* Temporary character */
	    int mode = 0;	/* Mode bits for the file.  */
	    int open_return;	/* Return value of open, file descriptor.  */
	    int i;		/* Loop counter */
	    int filename_ptr;	/* Pointer to filename in cpu memory.  */

	    /* Setting filename_ptr to first argument of open,  */
	    /* and trying to get mode.  */
	    if ((h8300sxmode || h8300hmode || h8300smode) && !h8300_normal_mode)
	      {
		filename_ptr = GET_L_REG (0);
		mode = GET_MEMORY_L (h8_get_reg (sd, SP_REGNUM) + 4);
	      }
	    else
	      {
		filename_ptr = GET_W_REG (0);
		mode = GET_MEMORY_W (h8_get_reg (sd, SP_REGNUM) + 2);
	      }

	    /* Trying to find the length of the filename.  */
	    temp_char = GET_MEMORY_B (h8_get_reg (sd, 0));

	    len = 1;
	    while (temp_char != '\0')
	      {
		temp_char = GET_MEMORY_B (filename_ptr + len);
		len++;
	      }

	    /* Allocating space for the filename.  */
	    filename = (char *) malloc (sizeof (char) * len);

	    /* String copying the filename from memory.  */
	    for (i = 0; i < len; i++)
	      {
		temp_char = GET_MEMORY_B (filename_ptr + i);
		filename[i] = temp_char;
	      }

	    /* Callback to open and return the file descriptor.  */
	    open_return = sim_callback->open (sim_callback, filename, mode);

	    /* Return value in register 0.  */
	    h8_set_reg (sd, 0, open_return);

	    /* Freeing memory used for filename. */
	    free (filename);
	  }
	  goto next;

	case O (O_SYS_READ, SB):
	  {
	    char *char_ptr;	/* Where characters read would be stored.  */
	    int fd;		/* File descriptor */
	    int buf_size;	/* BUF_SIZE parameter in read.  */
	    int i = 0;		/* Temporary Loop counter */
	    int read_return = 0;	/* Return value from callback to
					   read.  */

	    fd = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (0) : GET_W_REG (0);
	    buf_size = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (2) : GET_W_REG (2);

	    char_ptr = (char *) malloc (sizeof (char) * buf_size);

	    /* Callback to read and return the no. of characters read.  */
	    read_return =
	      sim_callback->read (sim_callback, fd, char_ptr, buf_size);

	    /* The characters read are stored in cpu memory.  */
	    for (i = 0; i < buf_size; i++)
	      {
		SET_MEMORY_B ((h8_get_reg (sd, 1) + (sizeof (char) * i)),
			      *(char_ptr + (sizeof (char) * i)));
	      }

	    /* Return value in Register 0.  */
	    h8_set_reg (sd, 0, read_return);

	    /* Freeing memory used as buffer.  */
	    free (char_ptr);
	  }
	  goto next;

	case O (O_SYS_WRITE, SB):
	  {
	    int fd;		/* File descriptor */
	    char temp_char;	/* Temporary character */
	    int len;		/* Length of write, Parameter II to write.  */
	    int char_ptr;	/* Character Pointer, Parameter I of write.  */
	    char *ptr;		/* Where characters to be written are stored. 
				 */
	    int write_return;	/* Return value from callback to write.  */
	    int i = 0;		/* Loop counter */

	    fd = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (0) : GET_W_REG (0);
	    char_ptr = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (1) : GET_W_REG (1);
	    len = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (2) : GET_W_REG (2);

	    /* Allocating space for the characters to be written.  */
	    ptr = (char *) malloc (sizeof (char) * len);

	    /* Fetching the characters from cpu memory.  */
	    for (i = 0; i < len; i++)
	      {
		temp_char = GET_MEMORY_B (char_ptr + i);
		ptr[i] = temp_char;
	      }

	    /* Callback write and return the no. of characters written.  */
	    write_return = sim_callback->write (sim_callback, fd, ptr, len);

	    /* Return value in Register 0.  */
	    h8_set_reg (sd, 0, write_return);

	    /* Freeing memory used as buffer.  */
	    free (ptr);
	  }
	  goto next;

	case O (O_SYS_LSEEK, SB):
	  {
	    int fd;		/* File descriptor */
	    int offset;		/* Offset */
	    int origin;		/* Origin */
	    int lseek_return;	/* Return value from callback to lseek.  */

	    fd = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (0) : GET_W_REG (0);
	    offset = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (1) : GET_W_REG (1);
	    origin = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (2) : GET_W_REG (2);

	    /* Callback lseek and return offset.  */
	    lseek_return =
	      sim_callback->lseek (sim_callback, fd, offset, origin);

	    /* Return value in register 0.  */
	    h8_set_reg (sd, 0, lseek_return);
	  }
	  goto next;

	case O (O_SYS_CLOSE, SB):
	  {
	    int fd;		/* File descriptor */
	    int close_return;	/* Return value from callback to close.  */

	    fd = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (0) : GET_W_REG (0);

	    /* Callback close and return.  */
	    close_return = sim_callback->close (sim_callback, fd);

	    /* Return value in register 0.  */
	    h8_set_reg (sd, 0, close_return);
	  }
	  goto next;

	case O (O_SYS_FSTAT, SB):
	  {
	    int fd;		/* File descriptor */
	    struct stat stat_rec;	/* Stat record */
	    int fstat_return;	/* Return value from callback to stat.  */
	    int stat_ptr;	/* Pointer to stat record.  */
	    char *temp_stat_ptr;	/* Temporary stat_rec pointer.  */

	    fd = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (0) : GET_W_REG (0);

	    /* Setting stat_ptr to second argument of stat.  */
	    stat_ptr = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (1) : GET_W_REG (1);

	    /* Callback stat and return.  */
	    fstat_return = sim_callback->fstat (sim_callback, fd, &stat_rec);

	    /* Have stat_ptr point to starting of stat_rec.  */
	    temp_stat_ptr = (char *) (&stat_rec);

	    /* Setting up the stat structure returned.  */
	    SET_MEMORY_W (stat_ptr, stat_rec.st_dev);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_ino);
	    stat_ptr += 2;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_mode);
	    stat_ptr += 4;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_nlink);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_uid);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_gid);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_rdev);
	    stat_ptr += 2;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_size);
	    stat_ptr += 4;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_atime);
	    stat_ptr += 8;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_mtime);
	    stat_ptr += 8;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_ctime);

	    /* Return value in register 0.  */
	    h8_set_reg (sd, 0, fstat_return);
	  }
	  goto next;

	case O (O_SYS_STAT, SB):
	  {
	    int len = 0;	/* Length of filename.  */
	    char *filename;	/* Filename would go here.  */
	    char temp_char;	/* Temporary character */
	    int filename_ptr;	/* Pointer to filename in cpu memory.  */
	    struct stat stat_rec;	/* Stat record */
	    int stat_return;	/* Return value from callback to stat */
	    int stat_ptr;	/* Pointer to stat record.  */
	    char *temp_stat_ptr;	/* Temporary stat_rec pointer.  */
	    int i = 0;		/* Loop Counter */

	    /* Setting filename_ptr to first argument of open.  */
	    filename_ptr = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (0) : GET_W_REG (0);

	    /* Trying to find the length of the filename.  */
	    temp_char = GET_MEMORY_B (h8_get_reg (sd, 0));

	    len = 1;
	    while (temp_char != '\0')
	      {
		temp_char = GET_MEMORY_B (filename_ptr + len);
		len++;
	      }

	    /* Allocating space for the filename.  */
	    filename = (char *) malloc (sizeof (char) * len);

	    /* String copying the filename from memory.  */
	    for (i = 0; i < len; i++)
	      {
		temp_char = GET_MEMORY_B (filename_ptr + i);
		filename[i] = temp_char;
	      }

	    /* Setting stat_ptr to second argument of stat.  */
	    /* stat_ptr = h8_get_reg (sd, 1); */
	    stat_ptr = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (1) : GET_W_REG (1);

	    /* Callback stat and return.  */
	    stat_return =
	      sim_callback->stat (sim_callback, filename, &stat_rec);

	    /* Have stat_ptr point to starting of stat_rec.  */
	    temp_stat_ptr = (char *) (&stat_rec);
 
	    /* Freeing memory used for filename.  */
	    free (filename);
 
	    /* Setting up the stat structure returned.  */
	    SET_MEMORY_W (stat_ptr, stat_rec.st_dev);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_ino);
	    stat_ptr += 2;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_mode);
	    stat_ptr += 4;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_nlink);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_uid);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_gid);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_rdev);
	    stat_ptr += 2;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_size);
	    stat_ptr += 4;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_atime);
	    stat_ptr += 8;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_mtime);
	    stat_ptr += 8;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_ctime);
 
	    /* Return value in register 0.  */
	    h8_set_reg (sd, 0, stat_return);
	  }
	  goto next;
	  /* End of system call processing.  */

	case O (O_NOT, SB):		/* not.b */
	  if (fetch2 (sd, &code->src, &rd))
	    goto end;
	  rd = ~rd; 
	  v = 0;
	  goto shift8;

	case O (O_NOT, SW):		/* not.w */
	  if (fetch2 (sd, &code->src, &rd))
	    goto end;
	  rd = ~rd; 
	  v = 0;
	  goto shift16;

	case O (O_NOT, SL):		/* not.l */
	  if (fetch2 (sd, &code->src, &rd))
	    goto end;
	  rd = ~rd; 
	  v = 0;
	  goto shift32;

	case O (O_SHLL, SB):	/* shll.b */
	case O (O_SHLR, SB):	/* shlr.b */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;

	  if (memcmp (&code->src, &code->dst, sizeof (code->src)) == 0)
	    ea = 1;		/* unary  op */
	  else			/* binary op */
	    fetch (sd, &code->src, &ea);

	  if (code->opcode == O (O_SHLL, SB))
	    {
	      v = (ea > 8);
	      c = rd & (0x80 >> (ea - 1));
	      rd <<= ea;
	    }
	  else
	    {
	      v = 0;
	      c = rd & (1 << (ea - 1));
	      rd = (unsigned char) rd >> ea;
	    }
	  goto shift8;

	case O (O_SHLL, SW):	/* shll.w */
	case O (O_SHLR, SW):	/* shlr.w */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;

	  if (memcmp (&code->src, &code->dst, sizeof (code->src)) == 0)
	    ea = 1;		/* unary  op */
	  else
	    fetch (sd, &code->src, &ea);

	  if (code->opcode == O (O_SHLL, SW))
	    {
	      v = (ea > 16);
	      c = rd & (0x8000 >> (ea - 1));
	      rd <<= ea;
	    }
	  else
	    {
	      v = 0;
	      c = rd & (1 << (ea - 1));
	      rd = (unsigned short) rd >> ea;
	    }
	  goto shift16;

	case O (O_SHLL, SL):	/* shll.l */
	case O (O_SHLR, SL):	/* shlr.l */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;

	  if (memcmp (&code->src, &code->dst, sizeof (code->src)) == 0)
	    ea = 1;		/* unary  op */
	  else
	    fetch (sd, &code->src, &ea);

	  if (code->opcode == O (O_SHLL, SL))
	    {
	      v = (ea > 32);
	      c = rd & (0x80000000 >> (ea - 1));
	      rd <<= ea;
	    }
	  else
	    {
	      v = 0;
	      c = rd & (1 << (ea - 1));
	      rd = (unsigned int) rd >> ea;
	    }
	  goto shift32;

	case O (O_SHAL, SB):
	case O (O_SHAR, SB):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;

	  if (code->src.type == X (OP_IMM, SB))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;

	  if (code->opcode == O (O_SHAL, SB))
	    {
	      c = rd & (0x80 >> (ea - 1));
	      res = rd >> (7 - ea);
	      v = ((res & 1) && !(res & 2)) 
		|| (!(res & 1) && (res & 2));
	      rd <<= ea;
	    }
	  else
	    {
	      c = rd & (1 << (ea - 1));
	      v = 0;
	      rd = ((signed char) rd) >> ea;
	    }
	  goto shift8;

	case O (O_SHAL, SW):
	case O (O_SHAR, SW):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;

	  if (code->src.type == X (OP_IMM, SW))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;

	  if (code->opcode == O (O_SHAL, SW))
	    {
	      c = rd & (0x8000 >> (ea - 1));
	      res = rd >> (15 - ea);
	      v = ((res & 1) && !(res & 2)) 
		|| (!(res & 1) && (res & 2));
	      rd <<= ea;
	    }
	  else
	    {
	      c = rd & (1 << (ea - 1));
	      v = 0;
	      rd = ((signed short) rd) >> ea;
	    }
	  goto shift16;

	case O (O_SHAL, SL):
	case O (O_SHAR, SL):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;

	  if (code->src.type == X (OP_IMM, SL))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;

	  if (code->opcode == O (O_SHAL, SL))
	    {
	      c = rd & (0x80000000 >> (ea - 1));
	      res = rd >> (31 - ea);
	      v = ((res & 1) && !(res & 2)) 
		|| (!(res & 1) && (res & 2));
	      rd <<= ea;
	    }
	  else
	    {
	      c = rd & (1 << (ea - 1));
	      v = 0;
	      rd = ((signed int) rd) >> ea;
	    }
	  goto shift32;

	case O (O_ROTL, SB):
	case O (O_ROTR, SB):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;

	  if (code->src.type == X (OP_IMM, SB))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;

	  while (ea--)
	    if (code->opcode == O (O_ROTL, SB))
	      {
		c = rd & 0x80;
		rd <<= 1;
		if (c)
		  rd |= 1;
	      }
	    else
	      {
		c = rd & 1;
		rd = ((unsigned char) rd) >> 1;
		if (c)
		  rd |= 0x80;
	      }

	  v = 0;
	  goto shift8;

	case O (O_ROTL, SW):
	case O (O_ROTR, SW):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;

	  if (code->src.type == X (OP_IMM, SW))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;

	  while (ea--)
	    if (code->opcode == O (O_ROTL, SW))
	      {
		c = rd & 0x8000;
		rd <<= 1;
		if (c)
		  rd |= 1;
	      }
	    else
	      {
		c = rd & 1;
		rd = ((unsigned short) rd) >> 1;
		if (c)
		  rd |= 0x8000;
	      }

	  v = 0;
	  goto shift16;

	case O (O_ROTL, SL):
	case O (O_ROTR, SL):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;

	  if (code->src.type == X (OP_IMM, SL))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;

	  while (ea--)
	    if (code->opcode == O (O_ROTL, SL))
	      {
		c = rd & 0x80000000;
		rd <<= 1;
		if (c)
		  rd |= 1;
	      }
	    else
	      {
		c = rd & 1;
		rd = ((unsigned int) rd) >> 1;
		if (c)
		  rd |= 0x80000000;
	      }

	  v = 0;
	  goto shift32;

	case O (O_ROTXL, SB):
	case O (O_ROTXR, SB):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;

	  if (code->src.type == X (OP_IMM, SB))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;

	  while (ea--)
	    if (code->opcode == O (O_ROTXL, SB))
	      {
		res = rd & 0x80;
		rd <<= 1;
		if (C)
		  rd |= 1;
		c = res;
	      }
	    else
	      {
		res = rd & 1;
		rd = ((unsigned char) rd) >> 1;
		if (C)
		  rd |= 0x80;
		c = res;
	      }

	  v = 0;
	  goto shift8;

	case O (O_ROTXL, SW):
	case O (O_ROTXR, SW):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;

	  if (code->src.type == X (OP_IMM, SW))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;

	  while (ea--)
	    if (code->opcode == O (O_ROTXL, SW))
	      {
		res = rd & 0x8000;
		rd <<= 1;
		if (C)
		  rd |= 1;
		c = res;
	      }
	    else
	      {
		res = rd & 1;
		rd = ((unsigned short) rd) >> 1;
		if (C)
		  rd |= 0x8000;
		c = res;
	      }

	  v = 0;
	  goto shift16;

	case O (O_ROTXL, SL):
	case O (O_ROTXR, SL):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;

	  if (code->src.type == X (OP_IMM, SL))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;

	  while (ea--)
	    if (code->opcode == O (O_ROTXL, SL))
	      {
		res = rd & 0x80000000;
		rd <<= 1;
		if (C)
		  rd |= 1;
		c = res;
	      }
	    else
	      {
		res = rd & 1;
		rd = ((unsigned int) rd) >> 1;
		if (C)
		  rd |= 0x80000000;
		c = res;
	      }

	  v = 0;
	  goto shift32;

        case O (O_JMP, SN):
        case O (O_JMP, SL):
        case O (O_JMP, SB):		/* jmp */
        case O (O_JMP, SW):
	  fetch (sd, &code->src, &pc);
	  goto end;

	case O (O_JSR, SN):
	case O (O_JSR, SL):
	case O (O_JSR, SB):		/* jsr, jump to subroutine */
	case O (O_JSR, SW):
	  if (fetch (sd, &code->src, &pc))
	    goto end;
	call:
	  tmp = h8_get_reg (sd, SP_REGNUM);

	  if (h8300hmode && !h8300_normal_mode)
	    {
	      tmp -= 4;
	      SET_MEMORY_L (tmp, code->next_pc);
	    }
	  else
	    {
	      tmp -= 2;
	      SET_MEMORY_W (tmp, code->next_pc);
	    }
	  h8_set_reg (sd, SP_REGNUM, tmp);

	  goto end;

	case O (O_BSR, SW):
	case O (O_BSR, SL):
	case O (O_BSR, SB):		/* bsr, branch to subroutine */
	  if (fetch (sd, &code->src, &res))
	    goto end;
	  pc = code->next_pc + res;
	  goto call;

	case O (O_RTE, SN):		/* rte, return from exception */
	rte:
	  /* Pops exr and ccr before pc -- otherwise identical to rts.  */
	  tmp = h8_get_reg (sd, SP_REGNUM);

	  if (h8300smode)			/* pop exr */
	    {
	      h8_set_exr (sd, GET_MEMORY_L (tmp));
	      tmp += 4;
	    }
	  if (h8300hmode && !h8300_normal_mode)
	    {
	      h8_set_ccr (sd, GET_MEMORY_L (tmp));
	      tmp += 4;
	      pc = GET_MEMORY_L (tmp);
	      tmp += 4;
	    }
	  else
	    {
	      h8_set_ccr (sd, GET_MEMORY_W (tmp));
	      tmp += 2;
	      pc = GET_MEMORY_W (tmp);
	      tmp += 2;
	    }

	  GETSR (sd);
	  h8_set_reg (sd, SP_REGNUM, tmp);
	  goto end;

	case O (O_RTS, SN):		/* rts, return from subroutine */
	rts:
	  tmp = h8_get_reg (sd, SP_REGNUM);

	  if (h8300hmode && !h8300_normal_mode)
	    {
	      pc = GET_MEMORY_L (tmp);
	      tmp += 4;
	    }
	  else
	    {
	      pc = GET_MEMORY_W (tmp);
	      tmp += 2;
	    }

	  h8_set_reg (sd, SP_REGNUM, tmp);
	  goto end;

	case O (O_ILL, SB):		/* illegal */
	  sim_engine_set_run_state (sd, sim_stopped, SIGILL);
	  goto end;

	case O (O_SLEEP, SN):		/* sleep */
	  /* Check for magic numbers in r1 and r2.  */
	  if ((h8_get_reg (sd, R1_REGNUM) & 0xffff) == LIBC_EXIT_MAGIC1 &&
	      (h8_get_reg (sd, R2_REGNUM) & 0xffff) == LIBC_EXIT_MAGIC2 &&
	      SIM_WIFEXITED (h8_get_reg (sd, 0)))
	    {
	      /* This trap comes from _exit, not from gdb.  */
	      sim_engine_set_run_state (sd, sim_exited, 
					SIM_WEXITSTATUS (h8_get_reg (sd, 0)));
	    }
#if 0
	  /* Unfortunately this won't really work, because
	     when we take a breakpoint trap, R0 has a "random", 
	     user-defined value.  Don't see any immediate solution.  */
	  else if (SIM_WIFSTOPPED (h8_get_reg (sd, 0)))
	    {
	      /* Pass the stop signal up to gdb.  */
	      sim_engine_set_run_state (sd, sim_stopped, 
					SIM_WSTOPSIG (h8_get_reg (sd, 0)));
	    }
#endif
	  else
	    {
	      /* Treat it as a sigtrap.  */
	      sim_engine_set_run_state (sd, sim_stopped, SIGTRAP);
	    }
	  goto end;

	case O (O_TRAPA, SB):		/* trapa */
	  if (fetch (sd, &code->src, &res))
   	    goto end;			/* res is vector number.  */
  
   	  tmp = h8_get_reg (sd, SP_REGNUM);
   	  if(h8300_normal_mode)
   	    {
   	      tmp -= 2;
   	      SET_MEMORY_W (tmp, code->next_pc);
   	      tmp -= 2;
   	      SET_MEMORY_W (tmp, h8_get_ccr (sd));
   	    }
   	  else
   	    {
   	      tmp -= 4;
   	      SET_MEMORY_L (tmp, code->next_pc);
   	      tmp -= 4;
   	      SET_MEMORY_L (tmp, h8_get_ccr (sd));
   	    }
   	  intMaskBit = 1;
   	  BUILDSR (sd);
 
	  if (h8300smode)
	    {
	      tmp -= 4;
	      SET_MEMORY_L (tmp, h8_get_exr (sd));
	    }

	  h8_set_reg (sd, SP_REGNUM, tmp);
d946 21
a966 5
	  if(h8300_normal_mode)
	    pc = GET_MEMORY_L (0x10 + res * 2); /* Vector addresses are 0x10,0x12,0x14 and 0x16 */
	  else
	    pc = GET_MEMORY_L (0x20 + res * 4);
	  goto end;
d968 20
a987 3
	case O (O_BPT, SN):
	  sim_engine_set_run_state (sd, sim_stopped, SIGTRAP);
	  goto end;
d989 1
a989 4
	case O (O_BSETEQ, SB):
	  if (Z)
	    goto bset;
	  goto next;
d991 10
a1000 4
	case O (O_BSETNE, SB):
	  if (!Z)
	    goto bset;
	  goto next;
d1002 1
a1002 4
	case O (O_BCLREQ, SB):
	  if (Z)
	    goto bclr;
	  goto next;
d1004 3
a1006 4
	case O (O_BCLRNE, SB):
	  if (!Z)
	    goto bclr;
	  goto next;
d1008 2
a1009 22
	  OBITOP (O_BNOT, 1, 1, ea ^= m);		/* bnot */
	  OBITOP (O_BTST, 1, 0, nz = ea & m);		/* btst */
	bset:
	  OBITOP (O_BSET, 1, 1, ea |= m);		/* bset */
	bclr:
	  OBITOP (O_BCLR, 1, 1, ea &= ~m);		/* bclr */
	  OBITOP (O_BLD, 1, 0, c = ea & m);		/* bld  */
	  OBITOP (O_BILD, 1, 0, c = !(ea & m));		/* bild */
	  OBITOP (O_BST, 1, 1, ea &= ~m;
		  if (C) ea |= m);			/* bst  */
	  OBITOP (O_BIST, 1, 1, ea &= ~m;
		  if (!C) ea |= m);			/* bist */
	  OBITOP (O_BSTZ, 1, 1, ea &= ~m;
		  if (Z) ea |= m);			/* bstz */
	  OBITOP (O_BISTZ, 1, 1, ea &= ~m;
		  if (!Z) ea |= m);			/* bistz */
	  OBITOP (O_BAND, 1, 0, c = (ea & m) && C);	/* band */
	  OBITOP (O_BIAND, 1, 0, c = !(ea & m) && C);	/* biand */
	  OBITOP (O_BOR, 1, 0, c = (ea & m) || C);	/* bor  */
	  OBITOP (O_BIOR, 1, 0, c = !(ea & m) || C);	/* bior */
	  OBITOP (O_BXOR, 1, 0, c = ((ea & m) != 0)!= C);	/* bxor */
	  OBITOP (O_BIXOR, 1, 0, c = !(ea & m) != C);	/* bixor */
d1011 7
a1017 5
	case O (O_BFLD, SB):				/* bfld */
	  /* bitfield load */
	  ea = 0;
	  if (fetch (sd, &code->src, &bit))
	    goto end;
d1019 3
a1021 4
	  if (bit != 0)
	    {
	      if (fetch (sd, &code->dst, &ea))
		goto end;
a1022 9
	      ea &= bit;
	      while (!(bit & 1))
		{
		  ea  >>= 1;
		  bit >>= 1;
		}
	    }
	  if (store (sd, &code->op3, ea))
	    goto end;
d1024 4
a1027 1
	  goto next;
a1028 5
	case O(O_BFST, SB):			/* bfst */
	  /* bitfield store */
	  /* NOTE: the imm8 value is in dst, and the ea value
	     (which is actually the destination) is in op3.
	     It has to be that way, to avoid breaking the assembler.  */
d1030 4
a1033 4
	  if (fetch (sd, &code->dst, &bit))	/* imm8 */
	    goto end;
	  if (bit == 0)				/* noop -- nothing to do.  */
	    goto next;
a1034 2
	  if (fetch (sd, &code->src, &rd))	/* reg8 src */
	    goto end;
a1035 2
	  if (fetch2 (sd, &code->op3, &ea))	/* ea dst */
	    goto end;
d1037 7
a1043 3
	  /* Left-shift the register data into position.  */
	  for (tmp = bit; !(tmp & 1); tmp >>= 1)
	    rd <<= 1;
d1045 1
a1045 2
	  /* Combine it with the neighboring bits.  */
	  ea = (ea & ~bit) | (rd & bit);
d1047 5
a1051 4
	  /* Put it back.  */
	  if (store2 (sd, &code->op3, ea))
	    goto end;
	  goto next;
d1053 10
a1062 7
	case O (O_CLRMAC, SN):		/* clrmac */
	  h8_set_mach (sd, 0);
	  h8_set_macl (sd, 0);
	  h8_set_macZ (sd, 1);
	  h8_set_macV (sd, 0);
	  h8_set_macN (sd, 0);
	  goto next;
a1063 15
	case O (O_STMAC, SL):		/* stmac, 260 */
	  switch (code->src.type) {
	  case X (OP_MACH, SL): 
	    res = h8_get_mach (sd);
	    if (res & 0x200)		/* sign extend */
	      res |= 0xfffffc00;
	    break;
	  case X (OP_MACL, SL): 
	    res = h8_get_macl (sd);
	    break;
	  default:	goto illegal;
	  }
	  nz = !h8_get_macZ (sd);
	  n = h8_get_macN (sd);
	  v = h8_get_macV (sd);
d1065 6
a1070 2
	  if (store (sd, &code->dst, res))
	    goto end;
d1072 6
a1077 1
	  goto next;
d1079 2
a1080 3
	case O (O_LDMAC, SL):		/* ldmac, 179 */
	  if (fetch (sd, &code->src, &rd))
	    goto end;
d1082 23
a1104 12
	  switch (code->dst.type) {
	  case X (OP_MACH, SL):	
	    rd &= 0x3ff;		/* Truncate to 10 bits */
	    h8_set_mach (sd, rd);
	    break;
	  case X (OP_MACL, SL):	
	    h8_set_macl (sd, rd);
	    break;
	  default:	goto illegal;
	  }
	  h8_set_macV (sd, 0);
	  goto next;
a1105 4
	case O (O_MAC, SW):
	  if (fetch (sd, &code->src, &rd) ||
	      fetch (sd, &code->dst, &res))
	    goto end;
d1107 2
a1108 3
	  /* Ye gods, this is non-portable!
	     However, the existing mul/div code is similar.  */
	  res = SEXTSHORT (res) * SEXTSHORT (rd);
d1110 2
a1111 3
	  if (h8_get_macS (sd))		/* Saturating mode */
	    {
	      long long mac = h8_get_macl (sd);
d1113 2
a1114 2
	      if (mac & 0x80000000)		/* sign extend */
		mac |= 0xffffffff00000000LL;
a1115 27
	      mac += res;
	      if (mac > 0x7fffffff || mac < 0xffffffff80000000LL)
		h8_set_macV (sd, 1);
	      h8_set_macZ (sd, (mac == 0));
	      h8_set_macN (sd, (mac  < 0));
	      h8_set_macl (sd, (int) mac);
	    }
	  else				/* "Less Saturating" mode */
	    {
	      long long mac = h8_get_mach (sd);
	      mac <<= 32;
	      mac += h8_get_macl (sd);

	      if (mac & 0x20000000000LL)	/* sign extend */
		mac |= 0xfffffc0000000000LL;

	      mac += res;
	      if (mac > 0x1ffffffffffLL || 
		  mac < (long long) 0xfffffe0000000000LL)
		h8_set_macV (sd, 1);
	      h8_set_macZ (sd, (mac == 0));
	      h8_set_macN (sd, (mac  < 0));
	      h8_set_macl (sd, (int) mac);
	      mac >>= 32;
	      h8_set_mach (sd, (int) (mac & 0x3ff));
	    }
	  goto next;
d1117 9
a1125 4
	case O (O_MULS, SW):		/* muls.w */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
a1126 6
	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfff0;
	  else
	    ea = SEXTSHORT (ea);
d1128 12
a1139 1
	  res = SEXTSHORT (ea * SEXTSHORT (rd));
d1141 23
a1163 4
	  n  = res & 0x8000;
	  nz = res & 0xffff;
	  if (store (sd, &code->dst, res))
	    goto end;
d1165 7
a1171 1
	  goto next;
d1173 4
a1176 4
	case O (O_MULS, SL):		/* muls.l */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
a1177 11
	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfffffff0;

	  res = ea * rd;

	  n  = res & 0x80000000;
	  nz = res & 0xffffffff;
	  if (store (sd, &code->dst, res))
	    goto end;
d1180 4
a1183 17
	case O (O_MULSU, SL):		/* muls/u.l */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfffffff0;

	  /* Compute upper 32 bits of the 64-bit result.  */
	  res = (((long long) ea) * ((long long) rd)) >> 32;

	  n  = res & 0x80000000;
	  nz = res & 0xffffffff;
	  if (store (sd, &code->dst, res))
	    goto end;
d1186 6
a1191 4
	case O (O_MULU, SW):		/* mulu.w */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
d1193 6
a1198 1
	  res = UEXTSHORT ((UEXTSHORT (ea) * UEXTSHORT (rd)));
d1200 6
a1205 3
	  /* Don't set Z or N.  */
	  if (store (sd, &code->dst, res))
	    goto end;
a1206 1
	  goto next;
d1208 6
a1213 4
	case O (O_MULU, SL):		/* mulu.l */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
d1215 6
a1220 1
	  res = ea * rd;
d1222 6
a1227 3
	  /* Don't set Z or N.  */
	  if (store (sd, &code->dst, res))
	    goto end;
a1228 1
	  goto next;
d1230 6
a1235 4
	case O (O_MULUU, SL):		/* mulu/u.l */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
d1237 6
a1242 3
	  /* Compute upper 32 bits of the 64-bit result.  */
	  res = (((unsigned long long) (unsigned) ea) *
		 ((unsigned long long) (unsigned) rd)) >> 32;
d1244 6
a1249 3
	  /* Don't set Z or N.  */
	  if (store (sd, &code->dst, res))
	    goto end;
d1251 2
a1252 1
	  goto next;
d1254 14
a1267 9
	case O (O_MULXS, SB):		/* mulxs.b */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfffffff0;
d1269 2
a1270 9
	    ea = SEXTCHAR (ea);

	  res = ea * SEXTCHAR (rd);

	  n  = res & 0x8000;
	  nz = res & 0xffff;
	  if (store (sd, &code->dst, res))
	    goto end;

d1273 14
a1286 4
	case O (O_MULXS, SW):		/* mulxs.w */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
d1288 9
a1296 4
	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfff0;
d1298 4
a1301 1
	    ea = SEXTSHORT (ea);
d1303 14
a1316 1
	  res = ea * SEXTSHORT (rd & 0xffff);
a1317 4
	  n  = res & 0x80000000;
	  nz = res & 0xffffffff;
	  if (store (sd, &code->dst, res))
	    goto end;
d1319 3
d1324 4
a1327 9
	case O (O_MULXU, SB):		/* mulxu.b */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  res = UEXTCHAR (ea) * UEXTCHAR (rd);

	  if (store (sd, &code->dst, res))
	    goto end;
d1329 3
a1333 9
	case O (O_MULXU, SW):		/* mulxu.w */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  res = UEXTSHORT (ea) * UEXTSHORT (rd);

	  if (store (sd, &code->dst, res))
	    goto end;
d1335 3
d1340 3
a1342 34
	case O (O_TAS, SB):		/* tas (test and set) */
	  if (!h8300sxmode)		/* h8sx can use any register. */
	    switch (code->src.reg)
	      {
	      case R0_REGNUM:
	      case R1_REGNUM:
	      case R4_REGNUM:
	      case R5_REGNUM:
		break;
	      default:
		goto illegal;
	      }

	  if (fetch (sd, &code->src, &res))
	    goto end;
	  if (store (sd, &code->src, res | 0x80))
	    goto end;

	  goto just_flags_log8;

	case O (O_DIVU, SW):			/* divu.w */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  n  = ea & 0x8000;
	  nz = ea & 0xffff;
	  if (ea)
	    res = (unsigned) (UEXTSHORT (rd) / UEXTSHORT (ea));
	  else
	    res = 0;

	  if (store (sd, &code->dst, res))
	    goto end;
d1345 4
a1348 4
	case O (O_DIVU, SL):			/* divu.l */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
d1350 7
a1356 9
	  n  = ea & 0x80000000;
	  nz = ea & 0xffffffff;
	  if (ea)
	    res = (unsigned) rd / ea;
	  else
	    res = 0;

	  if (store (sd, &code->dst, res))
	    goto end;
a1358 4
	case O (O_DIVS, SW):			/* divs.w */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
d1360 4
a1363 4
	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfffffff0;
d1365 16
a1380 10
	  if (ea)
	    {
	      res = SEXTSHORT (rd) / SEXTSHORT (ea);
	      nz  = 1;
	    }
	  else
	    {
	      res = 0;
	      nz  = 0;
	    }
d1382 11
a1392 3
	  n = res & 0x8000;
	  if (store (sd, &code->dst, res))
	    goto end;
d1395 6
a1400 4
	case O (O_DIVS, SL):			/* divs.l */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
d1402 25
a1426 4
	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfffffff0;
d1428 3
a1430 13
	  if (ea)
	    {
	      res = rd / ea;
	      nz  = 1;
	    }
	  else
	    {
	      res = 0;
	      nz  = 0;
	    }

	  n = res & 0x80000000;
	  if (store (sd, &code->dst, res))
a1431 1
	  goto next;
d1433 1
a1433 4
	case O (O_DIVXU, SB):			/* divxu.b */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
d1435 6
a1440 2
	  rd = UEXTSHORT (rd);
	  ea = UEXTCHAR (ea);
d1442 11
a1452 12
	  n  = ea & 0x80;
	  nz = ea & 0xff;
	  if (ea)
	    {
	      tmp = (unsigned) rd % ea;
	      res = (unsigned) rd / ea;
	    }
	  else
	    {
	      tmp = 0;
	      res = 0;
	    }
a1453 1
	  if (store (sd, &code->dst, (res & 0xff) | (tmp << 8)))
d1455 4
a1458 1
	  goto next;
d1460 3
a1462 4
	case O (O_DIVXU, SW):			/* divxu.w */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
d1464 1
a1464 1
	  ea = UEXTSHORT (ea);
d1466 10
a1475 12
	  n  = ea & 0x8000;
	  nz = ea & 0xffff;
	  if (ea)
	    {
	      tmp = (unsigned) rd % ea;
	      res = (unsigned) rd / ea;
	    }
	  else
	    {
	      tmp = 0;
	      res = 0;
	    }
d1477 1
a1477 1
	  if (store (sd, &code->dst, (res & 0xffff) | (tmp << 16)))
d1479 1
a1479 1
	  goto next;
d1481 21
a1501 4
	case O (O_DIVXS, SB):			/* divxs.b */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
d1503 20
a1522 1
	  rd = SEXTSHORT (rd);
d1524 12
a1535 6
	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfffffff0;
	  else
	    ea = SEXTCHAR (ea);
d1537 4
a1540 1
	  if (ea)
d1542 7
a1548 9
	      tmp = (int) rd % (int) ea;
	      res = (int) rd / (int) ea;
	      nz  = 1;
	    }
	  else
	    {
	      tmp = 0;
	      res = 0;
	      nz  = 0;
d1550 3
d1554 12
a1565 4
	  n = res & 0x8000;
	  if (store (sd, &code->dst, (res & 0xff) | (tmp << 8)))
	    goto end;
	  goto next;
d1567 16
a1582 4
	case O (O_DIVXS, SW):			/* divxs.w */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
d1584 2
a1585 6
	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfffffff0;
	  else
	    ea = SEXTSHORT (ea);
d1587 32
a1618 21
	  if (ea)
	    {
	      tmp = (int) rd % (int) ea;
	      res = (int) rd / (int) ea;
	      nz  = 1;
	    }
	  else
	    {
	      tmp = 0;
	      res = 0;
	      nz  = 0;
	    }

	  n = res & 0x80000000;
	  if (store (sd, &code->dst, (res & 0xffff) | (tmp << 16)))
	    goto end;
	  goto next;

	case O (O_EXTS, SW):			/* exts.w, signed extend */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
d1620 1
a1620 1
	  res = (rd & 0xff) + ea;
d1622 2
a1623 18

	case O (O_EXTS, SL):			/* exts.l, signed extend */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (code->src.type == X (OP_IMM, SL))
	    {
	      if (fetch (sd, &code->src, &ea))
		goto end;

	      if (ea == 2)			/* exts.l #2, nn */
		{
		  /* Sign-extend from 8-bit to 32-bit.  */
		  ea = rd & 0x80 ? -256 : 0;
		  res = (rd & 0xff) + ea;
		  goto log32;
		}
	    }
	  /* Sign-extend from 16-bit to 32-bit.  */
d1625 1
a1625 1
	  res = (rd & 0xffff) + ea;
d1627 2
a1628 4

	case O (O_EXTU, SW):			/* extu.w, unsigned extend */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
d1630 1
a1630 1
	  res = (rd & 0xff) + ea;
d1632 2
a1633 18

	case O (O_EXTU, SL):			/* extu.l, unsigned extend */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (code->src.type == X (OP_IMM, SL))
	    {
	      if (fetch (sd, &code->src, &ea))
		goto end;

	      if (ea == 2)			/* extu.l #2, nn */
		{
		  /* Zero-extend from 8-bit to 32-bit.  */
		  ea = 0;
		  res = (rd & 0xff) + ea;
		  goto log32;
		}
	    }
	  /* Zero-extend from 16-bit to 32-bit.  */
d1635 1
a1635 1
	  res = (rd & 0xffff) + ea;
d1638 1
a1638 1
	case O (O_NOP, SN):			/* nop */
d1641 1
a1641 1
	case O (O_STM, SL):			/* stm, store to memory */
d1648 1
a1648 1
	    firstreg = code->src.reg;
d1652 2
a1653 2
		h8_set_reg (sd, SP_REGNUM, h8_get_reg (sd, SP_REGNUM) - 4);
		SET_MEMORY_L (h8_get_reg (sd, SP_REGNUM), h8_get_reg (sd, i));
d1658 1
a1658 3
	case O (O_LDM, SL):			/* ldm,  load from memory */
	case O (O_RTEL, SN):			/* rte/l, ldm plus rte */
	case O (O_RTSL, SN):			/* rts/l, ldm plus rts */
d1662 5
a1666 2
	    nregs = ((GET_MEMORY_B (pc + 1) >> 4) & 0xf);
	    firstreg = code->dst.reg & 0xf;
d1669 2
a1670 2
		h8_set_reg (sd, i, GET_MEMORY_L (h8_get_reg (sd, SP_REGNUM)));
		h8_set_reg (sd, SP_REGNUM, h8_get_reg (sd, SP_REGNUM) + 4);
d1673 1
a1673 61
	  switch (code->opcode) {
	  case O (O_RTEL, SN):
	    goto rte;
	  case O (O_RTSL, SN):
	    goto rts;
	  case O (O_LDM, SL):
	    goto next;
	  default:
	    goto illegal;
	  }

	case O (O_DAA, SB):
	  /* Decimal Adjust Addition.  This is for BCD arithmetic.  */
	  res = GET_B_REG (code->src.reg);	/* FIXME fetch? */
	  if (!c && (0 <= (res >>  4) && (res >>  4) <= 9) && 
	      !h && (0 <= (res & 0xf) && (res & 0xf) <= 9))
	    res = res;		/* Value added == 0.  */
	  else if (!c && (0  <= (res >>  4) && (res >>  4) <=  8) && 
		   !h && (10 <= (res & 0xf) && (res & 0xf) <= 15))
	    res = res + 0x6;		/* Value added == 6.  */
	  else if (!c && (0 <= (res >>  4) && (res >>  4) <= 9) && 
		    h && (0 <= (res & 0xf) && (res & 0xf) <= 3))
	    res = res + 0x6;		/* Value added == 6.  */
	  else if (!c && (10 <= (res >>  4) && (res >>  4) <= 15) && 
		   !h && (0  <= (res & 0xf) && (res & 0xf) <=  9))
	    res = res + 0x60;		/* Value added == 60.  */
	  else if (!c && (9  <= (res >>  4) && (res >>  4) <= 15) && 
		   !h && (10 <= (res & 0xf) && (res & 0xf) <= 15))
	    res = res + 0x66;		/* Value added == 66.  */
	  else if (!c && (10 <= (res >>  4) && (res >>  4) <= 15) && 
		    h && (0  <= (res & 0xf) && (res & 0xf) <=  3))
	    res = res + 0x66;		/* Value added == 66.  */
	  else if ( c && (1 <= (res >>  4) && (res >>  4) <= 2) && 
		   !h && (0 <= (res & 0xf) && (res & 0xf) <= 9))
	    res = res + 0x60;		/* Value added == 60.  */
	  else if ( c && (1  <= (res >>  4) && (res >>  4) <=  2) && 
		   !h && (10 <= (res & 0xf) && (res & 0xf) <= 15))
	    res = res + 0x66;		/* Value added == 66.  */
	  else if (c && (1 <= (res >>  4) && (res >>  4) <= 3) && 
		   h && (0 <= (res & 0xf) && (res & 0xf) <= 3))
	    res = res + 0x66;		/* Value added == 66.  */

	  goto alu8;

	case O (O_DAS, SB):
	  /* Decimal Adjust Subtraction.  This is for BCD arithmetic.  */
	  res = GET_B_REG (code->src.reg); /* FIXME fetch, fetch2... */
	  if (!c && (0 <= (res >>  4) && (res >>  4) <= 9) && 
	      !h && (0 <= (res & 0xf) && (res & 0xf) <= 9))
	    res = res;		/* Value added == 0.  */
	  else if (!c && (0 <= (res >>  4) && (res >>  4) <=  8) && 
		    h && (6 <= (res & 0xf) && (res & 0xf) <= 15))
	    res = res + 0xfa;		/* Value added == 0xfa.  */
	  else if ( c && (7 <= (res >>  4) && (res >>  4) <= 15) && 
		   !h && (0 <= (res & 0xf) && (res & 0xf) <=  9))
	    res = res + 0xa0;		/* Value added == 0xa0.  */
	  else if (c && (6 <= (res >>  4) && (res >>  4) <= 15) && 
		   h && (6 <= (res & 0xf) && (res & 0xf) <= 15))
	    res = res + 0x9a;		/* Value added == 0x9a.  */

	  goto alu8;
d1676 3
a1678 2
	illegal:
	  sim_engine_set_run_state (sd, sim_stopped, SIGILL);
d1682 1
a1682 5

      (*sim_callback->printf_filtered) (sim_callback,
					"sim_resume: internal error.\n");
      sim_engine_set_run_state (sd, sim_stopped, SIGILL);
      goto end;
d1685 1
a1685 2
      if (code->dst.type == X (OP_CCR, SB) ||
	  code->dst.type == X (OP_CCR, SW))
d1687 2
a1688 2
	  h8_set_ccr (sd, res);
	  GETSR (sd);
d1690 1
a1690 3
      else if (h8300smode &&
	       (code->dst.type == X (OP_EXR, SB) ||
		code->dst.type == X (OP_EXR, SW)))
d1692 2
a1693 6
	  h8_set_exr (sd, res);
	  if (h8300smode)	/* Get exr.  */
	    {
	      trace = (h8_get_exr (sd) >> 7) & 1;
	      intMask = h8_get_exr (sd) & 7;
	    }
d1702 1
a1702 5
      if (fetch (sd, &code->src, &res))
	goto end;
      if (res & 1)		/* bad address */
	goto illegal;
      pc = code->next_pc + res;
d1715 1
d1723 1
d1731 1
d1736 1
a1736 2
      if (store2 (sd, &code->dst, rd))
	goto end;
d1743 1
a1743 2
      if (store2 (sd, &code->dst, rd))
	goto end;
d1750 1
a1750 2
      if (store2 (sd, &code->dst, rd))
	goto end;
d1754 1
a1754 3
      if (store2 (sd, &code->dst, res))
	goto end;

d1763 1
a1763 3
      if (store2 (sd, &code->dst, res))
	goto end;

d1771 1
d1773 1
a1773 3
      if (store2 (sd, &code->dst, res))
	goto end;

d1781 1
a1781 3
      if (store2 (sd, &code->dst, res))
	goto end;

a1788 1
	case O_ADDX:
a1792 1
	case O_SUBX:
a1799 3
	case O_DAA:
	case O_DAS:
	  break;	/* No effect on v flag.  */
d1804 1
a1804 3
      if (store2 (sd, &code->dst, res))
	goto end;

a1811 1
	case O_ADDX:
a1815 1
	case O_SUBX:
d1827 1
a1827 3
      if (store2 (sd, &code->dst, res))
	goto end;

a1833 1
	case O_ADDX:
d1836 1
a1836 2
	  c = ((unsigned) res < (unsigned) rd) || 
	    ((unsigned) res < (unsigned) ea);
a1838 1
	case O_SUBX:
d1851 2
a1852 8
    next:
      if ((res = h8_get_delayed_branch (sd)) != 0)
	{
	  pc = res;
	  h8_set_delayed_branch (sd, 0);
	}
      else
	pc = code->next_pc;
d1855 6
a1860 1
      
d1866 1
a1866 1
	    sim_engine_set_run_state (sd, sim_stopped, SIGINT);
a1867 2
      sim_engine_get_run_state (sd, &reason, &sigrc);
    } while (reason == sim_running);
d1869 10
a1878 10
  h8_set_ticks (sd, h8_get_ticks (sd) + get_now () - tick_start);
  h8_set_cycles (sd, h8_get_cycles (sd) + cycles);
  h8_set_insts (sd, h8_get_insts (sd) + insts);
  h8_set_pc (sd, pc);
  BUILDSR (sd);

  if (h8300smode)
    h8_set_exr (sd, (trace<<7) | intMask);

  h8_set_mask (sd, oldmask);
d1883 2
a1884 1
sim_trace (SIM_DESC sd)
d1887 1
a1887 3
  (*sim_callback->printf_filtered) (sim_callback,
				    "sim_trace: trace not supported.\n");
  return 1;	/* Done.  */
d1891 5
a1895 1
sim_write (SIM_DESC sd, SIM_ADDR addr, unsigned char *buffer, int size)
d1899 1
a1899 1
  init_pointers (sd);
d1906 2
a1907 2
	  h8_set_memory    (sd, addr + i, buffer[i]);
	  h8_set_cache_idx (sd, addr + i,  0);
d1910 1
a1910 3
	{
	  h8_set_eightbit (sd, (addr + i) & 0xff, buffer[i]);
	}
d1916 5
a1920 1
sim_read (SIM_DESC sd, SIM_ADDR addr, unsigned char *buffer, int size)
d1922 1
a1922 1
  init_pointers (sd);
d1926 1
a1926 1
    memcpy (buffer, h8_get_memory_buf (sd) + addr, size);
d1928 1
a1928 1
    memcpy (buffer, h8_get_eightbit_buf (sd) + (addr & 0xff), size);
d1934 5
a1938 1
sim_store_register (SIM_DESC sd, int rn, unsigned char *value, int length)
d1947 1
a1947 1
  init_pointers (sd);
d1951 1
a1951 4
      if(h8300_normal_mode)
        h8_set_pc (sd, shortval); /* PC for Normal mode is 2 bytes */
      else
        h8_set_pc (sd, intval);
d1954 1
a1954 3
      (*sim_callback->printf_filtered) (sim_callback, 
					"sim_store_register: bad regnum %d.\n",
					rn);
d1963 1
a1963 1
      h8_set_reg (sd, rn, intval);
d1966 1
a1966 1
      h8_set_ccr (sd, intval);
d1969 1
a1969 13
      h8_set_exr (sd, intval);
      break;
    case SBR_REGNUM:
      h8_set_sbr (sd, intval);
      break;
    case VBR_REGNUM:
      h8_set_vbr (sd, intval);
      break;
    case MACH_REGNUM:
      h8_set_mach (sd, intval);
      break;
    case MACL_REGNUM:
      h8_set_macl (sd, intval);
d1972 1
a1972 1
      h8_set_cycles (sd, longval);
d1976 1
a1976 1
      h8_set_insts (sd, longval);
d1980 1
a1980 1
      h8_set_ticks (sd, longval);
d1987 5
a1991 1
sim_fetch_register (SIM_DESC sd, int rn, unsigned char *buf, int length)
d1996 1
a1996 1
  init_pointers (sd);
d1998 1
a1998 1
  if (!h8300smode && rn >= EXR_REGNUM)
d2003 1
a2003 5
      (*sim_callback->printf_filtered) (sim_callback, 
					"sim_fetch_register: bad regnum %d.\n",
					rn);
      v = 0;
      break;
d2005 1
a2005 1
      v = h8_get_ccr (sd);
d2008 1
a2008 1
      v = h8_get_exr (sd);
d2011 1
a2011 13
      v = h8_get_pc (sd);
      break;
    case SBR_REGNUM:
      v = h8_get_sbr (sd);
      break;
    case VBR_REGNUM:
      v = h8_get_vbr (sd);
      break;
    case MACH_REGNUM:
      v = h8_get_mach (sd);
      break;
    case MACL_REGNUM:
      v = h8_get_macl (sd);
d2021 1
a2021 1
      v = h8_get_reg (sd, rn);
d2024 1
a2024 1
      v = h8_get_cycles (sd);
d2028 1
a2028 1
      v = h8_get_ticks (sd);
d2032 1
a2032 1
      v = h8_get_insts (sd);
d2036 1
a2036 2
  /* In Normal mode PC is 2 byte, but other registers are 4 byte */
  if ((h8300hmode || longreg) && !(rn == PC_REGNUM && h8300_normal_mode))
d2052 18
a2069 3
sim_stop_reason (SIM_DESC sd, enum sim_stop *reason, int *sigrc)
{
  sim_engine_get_run_state (sd, reason, sigrc);
d2075 2
a2076 1
sim_size (int n)
d2081 2
a2082 2
static void
set_simcache_size (SIM_DESC sd, int n)
d2084 2
a2085 2
  if (sd->sim_cache)
    free (sd->sim_cache);
d2088 3
a2090 3
  sd->sim_cache = (decoded_inst *) malloc (sizeof (decoded_inst) * n);
  memset (sd->sim_cache, 0, sizeof (decoded_inst) * n);
  sd->sim_cache_size = n;
d2095 3
a2097 1
sim_info (SIM_DESC sd, int verbose)
d2099 2
a2100 2
  double timetaken = (double) h8_get_ticks (sd) / (double) now_persec ();
  double virttime = h8_get_cycles (sd) / 10.0e6;
d2104 1
a2104 1
				    h8_get_insts (sd));
d2107 1
a2107 1
				    h8_get_cycles (sd));
d2112 1
a2112 1
				    "#virtual time taken     %10.4f\n",
d2120 1
a2120 1
				    h8_get_compiles (sd));
d2123 1
a2123 1
				    sd->sim_cache_size);
d2133 3
a2135 3
	  if (h8_get_stats (sd, i))
	    (*sim_callback->printf_filtered) (sim_callback, "%d: %d\n", 
					      i, h8_get_stats (sd, i));
d2145 2
a2146 1
set_h8300h (unsigned long machine)
d2151 2
a2152 26

  h8300hmode = h8300smode = h8300sxmode = h8300_normal_mode = 0;

  if (machine == bfd_mach_h8300sx || machine == bfd_mach_h8300sxn)
    h8300sxmode = 1;

  if (machine == bfd_mach_h8300s || machine == bfd_mach_h8300sn || h8300sxmode)
    h8300smode = 1;

  if (machine == bfd_mach_h8300h || machine == bfd_mach_h8300hn || h8300smode)
    h8300hmode = 1;

  if(machine == bfd_mach_h8300hn || machine == bfd_mach_h8300sn || machine == bfd_mach_h8300sxn)
    h8300_normal_mode = 1;
}

/* Cover function of sim_state_free to free the cpu buffers as well.  */

static void
free_state (SIM_DESC sd)
{
  if (STATE_MODULES (sd) != NULL)
    sim_module_uninstall (sd);

  /* Fixme: free buffers in _sim_cpu.  */
  sim_state_free (sd);
d2156 5
a2160 4
sim_open (SIM_OPEN_KIND kind, 
	  struct host_callback_struct *callback, 
	  struct bfd *abfd, 
	  char **argv)
a2161 59
  SIM_DESC sd;
  sim_cpu *cpu;

  sd = sim_state_alloc (kind, callback);
  sd->cpu = sim_cpu_alloc (sd, 0);
  cpu = STATE_CPU (sd, 0);
  SIM_ASSERT (STATE_MAGIC (sd) == SIM_MAGIC_NUMBER);
  sim_state_initialize (sd, cpu);
  /* sim_cpu object is new, so some initialization is needed.  */
  init_pointers_needed = 1;

  /* For compatibility (FIXME: is this right?).  */
  current_alignment = NONSTRICT_ALIGNMENT;
  current_target_byte_order = BIG_ENDIAN;

  if (sim_pre_argv_init (sd, argv[0]) != SIM_RC_OK)
    {
      free_state (sd);
      return 0;
    }

    /* getopt will print the error message so we just have to exit if
       this fails.  FIXME: Hmmm...  in the case of gdb we need getopt
       to call print_filtered.  */
  if (sim_parse_args (sd, argv) != SIM_RC_OK)
    {
      /* Uninstall the modules to avoid memory leaks,
         file descriptor leaks, etc.  */
      free_state (sd);
      return 0;
    }

  /* Check for/establish the a reference program image.  */
  if (sim_analyze_program (sd,
			   (STATE_PROG_ARGV (sd) != NULL
			    ? *STATE_PROG_ARGV (sd)
			    : NULL), abfd) != SIM_RC_OK)
    {
      free_state (sd);
      return 0;
    }

  /* Establish any remaining configuration options.  */
  if (sim_config (sd) != SIM_RC_OK)
    {
      free_state (sd);
      return 0;
    }

  if (sim_post_argv_init (sd) != SIM_RC_OK)
    {
      /* Uninstall the modules to avoid memory leaks,
         file descriptor leaks, etc.  */
      free_state (sd);
      return 0;
    }

  /*  sim_hw_configure (sd); */

d2166 3
a2168 2
  sim_callback = callback;
  return sd;
d2172 3
a2174 1
sim_close (SIM_DESC sd, int quitting)
d2182 5
a2186 1
sim_load (SIM_DESC sd, char *prog, bfd *abfd, int from_tty)
d2206 3
a2208 1
	  set_h8300h (bfd_get_mach (prog_bfd));
d2227 1
a2227 1
  if (h8300smode && !h8300_normal_mode)
d2229 1
a2229 1
  else if (h8300hmode && !h8300_normal_mode)
d2234 10
a2243 12
  if (h8_get_memory_buf (sd))
    free (h8_get_memory_buf (sd));
  if (h8_get_cache_idx_buf (sd))
    free (h8_get_cache_idx_buf (sd));
  if (h8_get_eightbit_buf (sd))
    free (h8_get_eightbit_buf (sd));

  h8_set_memory_buf (sd, (unsigned char *) 
		     calloc (sizeof (char), memory_size));
  h8_set_cache_idx_buf (sd, (unsigned short *) 
			calloc (sizeof (short), memory_size));
  h8_set_eightbit_buf (sd, (unsigned char *) calloc (sizeof (char), 256));
d2247 2
a2248 6
    {
      (*sim_callback->printf_filtered) (sim_callback, 
					"sim_load: bad memory size.\n");
      return SIM_RC_FAIL;
    }
  h8_set_mask (sd, memory_size - 1);
d2268 5
a2272 1
sim_create_inferior (SIM_DESC sd, struct bfd *abfd, char **argv, char **env)
a2273 4
  int i = 0;
  int len_arg = 0;
  int no_of_args = 0;

d2275 1
a2275 1
    h8_set_pc (sd, bfd_get_start_address (abfd));
d2277 1
a2277 21
    h8_set_pc (sd, 0);

  /* Command Line support.  */
  if (argv != NULL)
    {
      /* Counting the no. of commandline arguments.  */
      for (no_of_args = 0; argv[no_of_args] != NULL; no_of_args++)
        continue;

      /* Allocating memory for the argv pointers.  */
      h8_set_command_line (sd, (char **) malloc ((sizeof (char *))
						 * (no_of_args + 1)));

      for (i = 0; i < no_of_args; i++)
	{
	  /* Copying the argument string.  */
	  h8_set_cmdline_arg (sd, i, (char *) strdup (argv[i]));
	}
      h8_set_cmdline_arg (sd, i, NULL);
    }
  
d2282 3
a2284 1
sim_do_command (SIM_DESC sd, char *cmd)
d2291 2
a2292 1
sim_set_callbacks (struct host_callback_struct *ptr)
@


1.17.10.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d5055 1
a5055 1
    prog_bfd = bfd_openr (prog, NULL);
@


1.17.8.1
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d86 2
a87 3
#define BUILDSR()					\
  cpu.ccr = ((I << 7) | (UI << 6) | (H << 5) | (U << 4)	\
	     | (N << 3) | (Z << 2) | (V << 1) | C);
d102 4
a105 6
#define GETEXR()				\
  if (h8300smode)				\
    {						\
      trace = (cpu.exr >> 7) & 1;		\
      intMask = cpu.exr & 7;			\
    }
d112 1
a112 1
#define SEXTCHAR(x) ((x & 0x80) ? (x | ~0xff) : x & 0xff)
d127 1
a127 1
get_now (void)
d133 1
a133 1
now_persec (void)
d139 1
a139 1
bitfrom (int x)
d155 1
a155 1
lvalue (int x, int rn)
d175 5
a179 1
decode (int addr, unsigned char *data, decoded_inst *dst)
d481 1
a481 1
compile (int pc)
d550 3
a552 2
static int
fetch (ea_type *arg)
d634 3
a636 1
store (ea_type *arg, int n)
d710 1
a710 1
init_pointers (void)
a759 1
	  wreg[i] = wreg[i + 8] = 0;
a771 2
	  if (wreg[i] == 0 || wreg[i + 8] == 0)
	    abort ();
d785 5
a789 1
control_c (int sig)
d805 4
a808 1
mop (decoded_inst *code, int bsize, int sign)
d938 2
a939 1
sim_stop (SIM_DESC sd)
d969 2
a970 1
sim_resume (SIM_DESC sd, int step, int siggnal)
d1025 3
a1027 3
    case O (NAME, SB): HOW; if (STORE) goto alu8;  else goto just_flags_alu8;  \
    case O (NAME, SW): HOW; if (STORE) goto alu16; else goto just_flags_alu16; \
    case O (NAME, SL): HOW; if (STORE) goto alu32; else goto just_flags_alu32;
d1030 4
a1033 4
#define LOGOP(NAME, HOW)			\
    case O (NAME, SB): HOW; goto log8;		\
    case O (NAME, SW): HOW; goto log16;		\
    case O (NAME, SL): HOW; goto log32;
d1143 1
a1143 1
	  if (h8300hmode || h8300smode)
d1145 7
a1151 9
	      register unsigned char *_src, *_dst;
	      unsigned int count = ((code->opcode == O (O_EEPMOV, SW))
				    ? cpu.regs[R4_REGNUM] & 0xffff
				    : cpu.regs[R4_REGNUM] & 0xff);

	      _src = (cpu.regs[R5_REGNUM] < memory_size
		      ? cpu.memory + cpu.regs[R5_REGNUM]
		      : cpu.eightbit + (cpu.regs[R5_REGNUM] & 0xff));
	      if ((_src + count) >= (cpu.memory + memory_size))
d1153 1
a1153 1
		  if ((_src + count) >= (cpu.eightbit + 0x100))
d1156 3
a1158 4
	      _dst = (cpu.regs[R6_REGNUM] < memory_size
		      ? cpu.memory + cpu.regs[R6_REGNUM]
		      : cpu.eightbit + (cpu.regs[R6_REGNUM] & 0xff));
	      if ((_dst + count) >= (cpu.memory + memory_size))
d1160 1
a1160 1
		  if ((_dst + count) >= (cpu.eightbit + 0x100))
d1163 1
a1163 1
	      memcpy (_dst, _src, count);
d1165 4
a1168 5
	      cpu.regs[R5_REGNUM] += count;
	      cpu.regs[R6_REGNUM] += count;
	      cpu.regs[R4_REGNUM] &= ((code->opcode == O (O_EEPMOV, SW))
				      ? (~0xffff) : (~0xff));
	      cycles += 2 * count;
d1517 1
a1517 1
	  OBITOP (O_BXOR, 1, 0, c = ((ea & m) != 0) != C);
d1551 1
a1551 1
	  store (&code->src, res | 0x80);
d1618 1
a1618 1
	  rd = GET_W_REG (code->src.reg) & 0xff; /* Yes, src, not dst.  */
d1628 1
a1628 1
	  rd = GET_W_REG (code->src.reg) & 0xff;
d1676 1
a1676 1
	illegal:
d1883 2
a1884 1
sim_trace (SIM_DESC sd)
d1891 5
a1895 1
sim_write (SIM_DESC sd, SIM_ADDR addr, unsigned char *buffer, int size)
d1916 5
a1920 1
sim_read (SIM_DESC sd, SIM_ADDR addr, unsigned char *buffer, int size)
d1934 5
a1938 1
sim_store_register (SIM_DESC sd, int rn, unsigned char *value, int length)
d1987 5
a1991 1
sim_fetch_register (SIM_DESC sd, int rn, unsigned char *buf, int length)
d1998 1
a1998 1
  if (!h8300smode && rn >= EXR_REGNUM)
d2052 4
a2055 1
sim_stop_reason (SIM_DESC sd, enum sim_stop *reason, int *sigrc)
d2075 2
a2076 1
sim_size (int n)
d2082 1
a2082 1
sim_set_simcache_size (int n)
d2095 3
a2097 1
sim_info (SIM_DESC sd, int verbose)
d2145 2
a2146 1
set_h8300h (int h_flag, int s_flag)
d2156 5
a2160 4
sim_open (SIM_OPEN_KIND kind, 
	  struct host_callback_struct *ptr, 
	  struct _bfd *abfd, 
	  char **argv)
d2172 3
a2174 1
sim_close (SIM_DESC sd, int quitting)
d2182 5
a2186 1
sim_load (SIM_DESC sd, char *prog, bfd *abfd, int from_tty)
d2268 5
a2272 1
sim_create_inferior (SIM_DESC sd, struct _bfd *abfd, char **argv, char **env)
d2282 3
a2284 1
sim_do_command (SIM_DESC sd, char *cmd)
d2291 2
a2292 1
sim_set_callbacks (struct host_callback_struct *ptr)
@


1.17.8.2
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d2128 1
a2128 1
	  struct bfd *abfd, 
d2231 1
a2231 1
sim_create_inferior (SIM_DESC sd, struct bfd *abfd, char **argv, char **env)
@


1.17.8.3
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a37 2
#include "sys/stat.h"
#include "sys/types.h"
a176 11
static int
cmdline_location()
{
  if (h8300smode)
    return 0xffff00L;
  else if (h8300hmode)
    return 0x2ff00L;
  else
    return 0xff00L;
}

d450 1
a450 2
		  /* And a jsr to these locations are turned into magic
		     traps.  */
d454 1
a454 1
		      switch (dst->src.literal)
d456 1
a456 24
			case 0xc5:
			  dst->opcode = O (O_SYS_OPEN, SB);
			  break;
			case 0xc6:
			  dst->opcode = O (O_SYS_READ, SB);
			  break;
			case 0xc7:
			  dst->opcode = O (O_SYS_WRITE, SB);
			  break;
			case 0xc8:
			  dst->opcode = O (O_SYS_LSEEK, SB);
			  break;
			case 0xc9:
			  dst->opcode = O (O_SYS_CLOSE, SB);
			  break;
			case 0xca:
			  dst->opcode = O (O_SYS_STAT, SB);
			  break;
			case 0xcb:
			  dst->opcode = O (O_SYS_FSTAT, SB);
			  break;
			case 0xcc:
			  dst->opcode = O (O_SYS_CMDLINE, SB);
			  break;
a457 1
		      /* End of Processing for system calls.  */
d1389 1
a1389 213
	/* Trap for Command Line setup.  */
	case O (O_SYS_CMDLINE, SB):
	  {
	    int i = 0;		/* Loop counter.  */
	    int j = 0;		/* Loop counter.  */
	    int ind_arg_len = 0;	/* Length of each argument.  */
	    int no_of_args = 0;	/* The no. or cmdline args.  */
	    int current_location = 0;	/* Location of string.  */
	    int old_sp = 0;	/* The Initial Stack Pointer.  */
	    int no_of_slots = 0;	/* No. of slots required on the stack
					   for storing cmdline args.  */
	    int sp_move = 0;	/* No. of locations by which the stack needs
				   to grow.  */
	    int new_sp = 0;	/* The final stack pointer location passed
				   back.  */
	    int *argv_ptrs;	/* Pointers of argv strings to be stored.  */
	    int argv_ptrs_location = 0;	/* Location of pointers to cmdline
					   args on the stack.  */
	    int char_ptr_size = 0;	/* Size of a character pointer on
					   target machine.  */
	    int addr_cmdline = 0;	/* Memory location where cmdline has
					   to be stored.  */
	    int size_cmdline = 0;	/* Size of cmdline.  */

	    /* Set the address of 256 free locations where command line is
	       stored.  */
	    addr_cmdline = cmdline_location();
	    cpu.regs[0] = addr_cmdline;

	    /* Counting the no. of commandline arguments.  */
	    for (i = 0; ptr_command_line[i] != NULL; i++)
	      continue;

	    /* No. of arguments in the command line.  */
	    no_of_args = i;

	    /* Current location is just a temporary variable,which we are
	       setting to the point to the start of our commandline string.  */
	    current_location = addr_cmdline;

	    /* Allocating space for storing pointers of the command line
	       arguments.  */
	    argv_ptrs = (int *) malloc (sizeof (int) * no_of_args);

	    /* Setting char_ptr_size to the sizeof (char *) on the different
	       architectures.  */
	    if (h8300hmode || h8300smode)
	      {
		char_ptr_size = 4;
	      }
	    else
	      {
		char_ptr_size = 2;
	      }

	    for (i = 0; i < no_of_args; i++)
	      {
		ind_arg_len = 0;

		/* The size of the commandline argument.  */
		ind_arg_len = (strlen (ptr_command_line[i]) + 1);

		/* The total size of the command line string.  */
		size_cmdline += ind_arg_len;

		/* As we have only 256 bytes, we need to provide a graceful
		   exit. Anyways, a program using command line arguments 
		   where we cannot store all the command line arguments
		   given may behave unpredictably.  */
		if (size_cmdline >= 256)
		  {
		    cpu.regs[0] = 0;
		    goto next;
		  }
		else
		  {
		    /* current_location points to the memory where the next
		       commandline argument is stored.  */
		    argv_ptrs[i] = current_location;
		    for (j = 0; j < ind_arg_len; j++)
		      {
			SET_MEMORY_B ((current_location +
				       (sizeof (char) * j)),
				      *(ptr_command_line[i] + 
				       sizeof (char) * j));
		      }

		    /* Setting current_location to the starting of next
		       argument.  */
		    current_location += ind_arg_len;
		  }
	      }

	    /* This is the original position of the stack pointer.  */
	    old_sp = cpu.regs[7];

	    /* We need space from the stack to store the pointers to argvs.  */
	    /* As we will infringe on the stack, we need to shift the stack
	       pointer so that the data is not overwritten. We calculate how
	       much space is required.  */
	    sp_move = (no_of_args) * (char_ptr_size);

	    /* The final position of stack pointer, we have thus taken some
	       space from the stack.  */
	    new_sp = old_sp - sp_move;

	    /* Temporary variable holding value where the argv pointers need
	       to be stored.  */
	    argv_ptrs_location = new_sp;

	    /* The argv pointers are stored at sequential locations. As per
	       the H8300 ABI.  */
	    for (i = 0; i < no_of_args; i++)
	      {
		/* Saving the argv pointer.  */
		if (h8300hmode || h8300smode)
		  {
		    SET_MEMORY_L (argv_ptrs_location, argv_ptrs[i]);
		  }
		else
		  {
		    SET_MEMORY_W (argv_ptrs_location, argv_ptrs[i]);
		  }
	
		/* The next location where the pointer to the next argv
		   string has to be stored.  */    
		argv_ptrs_location += char_ptr_size;
	      }

	    /* Required by POSIX, Setting 0x0 at the end of the list of argv
	       pointers.  */
	    if (h8300hmode || h8300smode)
	      {
		SET_MEMORY_L (old_sp, 0x0);
	      }
	    else
	      {
		SET_MEMORY_W (old_sp, 0x0);
	      }

	    /* Freeing allocated memory.  */
	    free (argv_ptrs);
	    for (i = 0; i <= no_of_args; i++)
	      {
		free (ptr_command_line[i]);
	      }
	    free (ptr_command_line);

	    /* The no. of argv arguments are returned in Reg 0.  */
	    cpu.regs[0] = no_of_args;
	    /* The Pointer to argv in Register 1.  */
	    cpu.regs[1] = new_sp;
	    /* Setting the stack pointer to the new value.  */
	    cpu.regs[7] = new_sp;
	  }
	  goto next;

	  /* System call processing starts.  */
	case O (O_SYS_OPEN, SB):
	  {
	    int len = 0;	/* Length of filename.  */
	    char *filename;	/* Filename would go here.  */
	    char temp_char;	/* Temporary character */
	    int mode = 0;	/* Mode bits for the file.  */
	    int open_return;	/* Return value of open, file descriptor.  */
	    int i;		/* Loop counter */
	    int filename_ptr;	/* Pointer to filename in cpu memory.  */

	    /* Setting filename_ptr to first argument of open.  */
	    filename_ptr = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);

	    /* Trying to get mode.  */
	    if (h8300hmode || h8300smode)
	      {
		mode = GET_MEMORY_L (cpu.regs[7] + 4);
	      }
	    else
	      {
		mode = GET_MEMORY_W (cpu.regs[7] + 2);
	      }

	    /* Trying to find the length of the filename.  */
	    temp_char = GET_MEMORY_B (cpu.regs[0]);

	    len = 1;
	    while (temp_char != '\0')
	      {
		temp_char = GET_MEMORY_B (filename_ptr + len);
		len++;
	      }

	    /* Allocating space for the filename.  */
	    filename = (char *) malloc (sizeof (char) * len);

	    /* String copying the filename from memory.  */
	    for (i = 0; i < len; i++)
	      {
		temp_char = GET_MEMORY_B (filename_ptr + i);
		filename[i] = temp_char;
	      }

	    /* Callback to open and return the file descriptor.  */
	    open_return = sim_callback->open (sim_callback, filename, mode);

	    /* Return value in register 0.  */
	    cpu.regs[0] = open_return;

	    /* Freeing memory used for filename. */
	    free (filename);
	  }
	  goto next;

	case O (O_SYS_READ, SB):
d1391 2
a1392 28
	    char *char_ptr;	/* Where characters read would be stored.  */
	    int fd;		/* File descriptor */
	    int buf_size;	/* BUF_SIZE parameter in read.  */
	    int i = 0;		/* Temporary Loop counter */
	    int read_return = 0;	/* Return value from callback to
					   read.  */

	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);
	    buf_size = h8300hmode ? GET_L_REG (2) : GET_W_REG (2);

	    char_ptr = (char *) malloc (sizeof (char) * buf_size);

	    /* Callback to read and return the no. of characters read.  */
	    read_return =
	      sim_callback->read (sim_callback, fd, char_ptr, buf_size);

	    /* The characters read are stored in cpu memory.  */
	    for (i = 0; i < buf_size; i++)
	      {
		SET_MEMORY_B ((cpu.regs[1] + (sizeof (char) * i)),
			      *(char_ptr + (sizeof (char) * i)));
	      }

	    /* Return value in Register 0.  */
	    cpu.regs[0] = read_return;

	    /* Freeing memory used as buffer.  */
	    free (char_ptr);
a1395 196
	case O (O_SYS_WRITE, SB):
	  {
	    int fd;		/* File descriptor */
	    char temp_char;	/* Temporary character */
	    int len;		/* Length of write, Parameter II to write.  */
	    int char_ptr;	/* Character Pointer, Parameter I of write.  */
	    char *ptr;		/* Where characters to be written are stored. 
				 */
	    int write_return;	/* Return value from callback to write.  */
	    int i = 0;		/* Loop counter */

	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);
	    char_ptr = h8300hmode ? GET_L_REG (1) : GET_W_REG (1);
	    len = h8300hmode ? GET_L_REG (2) : GET_W_REG (2);

	    /* Allocating space for the characters to be written.  */
	    ptr = (char *) malloc (sizeof (char) * len);

	    /* Fetching the characters from cpu memory.  */
	    for (i = 0; i < len; i++)
	      {
		temp_char = GET_MEMORY_B (char_ptr + i);
		ptr[i] = temp_char;
	      }

	    /* Callback write and return the no. of characters written.  */
	    write_return = sim_callback->write (sim_callback, fd, ptr, len);

	    /* Return value in Register 0.  */
	    cpu.regs[0] = write_return;

	    /* Freeing memory used as buffer.  */
	    free (ptr);
	  }
	  goto next;

	case O (O_SYS_LSEEK, SB):
	  {
	    int fd;		/* File descriptor */
	    int offset;		/* Offset */
	    int origin;		/* Origin */
	    int lseek_return;	/* Return value from callback to lseek.  */

	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);
	    offset = h8300hmode ? GET_L_REG (1) : GET_W_REG (1);
	    origin = h8300hmode ? GET_L_REG (2) : GET_W_REG (2);

	    /* Callback lseek and return offset.  */
	    lseek_return =
	      sim_callback->lseek (sim_callback, fd, offset, origin);

	    /* Return value in register 0.  */
	    cpu.regs[0] = lseek_return;
	  }
	  goto next;

	case O (O_SYS_CLOSE, SB):
	  {
	    int fd;		/* File descriptor */
	    int close_return;	/* Return value from callback to close.  */

	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);

	    /* Callback close and return.  */
	    close_return = sim_callback->close (sim_callback, fd);

	    /* Return value in register 0.  */
	    cpu.regs[0] = close_return;
	  }
	  goto next;

	case O (O_SYS_FSTAT, SB):
	  {
	    int fd;		/* File descriptor */
	    struct stat stat_rec;	/* Stat record */
	    int fstat_return;	/* Return value from callback to stat.  */
	    int stat_ptr;	/* Pointer to stat record.  */
	    char *temp_stat_ptr;	/* Temporary stat_rec pointer.  */

	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);

	    /* Setting stat_ptr to second argument of stat.  */
	    stat_ptr = h8300hmode ? GET_L_REG (1) : GET_W_REG (1);

	    /* Callback stat and return.  */
	    fstat_return = sim_callback->fstat (sim_callback, fd, &stat_rec);

	    /* Have stat_ptr point to starting of stat_rec.  */
	    temp_stat_ptr = (char *) (&stat_rec);

	    /* Setting up the stat structure returned.  */
	    SET_MEMORY_W (stat_ptr, stat_rec.st_dev);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_ino);
	    stat_ptr += 2;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_mode);
	    stat_ptr += 4;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_nlink);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_uid);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_gid);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_rdev);
	    stat_ptr += 2;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_size);
	    stat_ptr += 4;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_atime);
	    stat_ptr += 8;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_mtime);
	    stat_ptr += 8;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_ctime);

	    /* Return value in register 0.  */
	    cpu.regs[0] = fstat_return;
	  }
	  goto next;

	case O (O_SYS_STAT, SB):
	  {
	    int len = 0;	/* Length of filename.  */
	    char *filename;	/* Filename would go here.  */
	    char temp_char;	/* Temporary character */
	    int filename_ptr;	/* Pointer to filename in cpu memory.  */
	    struct stat stat_rec;	/* Stat record */
	    int stat_return;	/* Return value from callback to stat */
	    int stat_ptr;	/* Pointer to stat record.  */
	    char *temp_stat_ptr;	/* Temporary stat_rec pointer.  */
	    int i = 0;		/* Loop Counter */

	    /* Setting filename_ptr to first argument of open.  */
	    filename_ptr = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);

	    /* Trying to find the length of the filename.  */
	    temp_char = GET_MEMORY_B (cpu.regs[0]);

	    len = 1;
	    while (temp_char != '\0')
	      {
		temp_char = GET_MEMORY_B (filename_ptr + len);
		len++;
	      }

	    /* Allocating space for the filename.  */
	    filename = (char *) malloc (sizeof (char) * len);

	    /* String copying the filename from memory.  */
	    for (i = 0; i < len; i++)
	      {
		temp_char = GET_MEMORY_B (filename_ptr + i);
		filename[i] = temp_char;
	      }

	    /* Setting stat_ptr to second argument of stat.  */
	    /* stat_ptr = cpu.regs[1]; */
	    stat_ptr = h8300hmode ? GET_L_REG (1) : GET_W_REG (1);

	    /* Callback stat and return.  */
	    stat_return =
	      sim_callback->stat (sim_callback, filename, &stat_rec);

	    /* Have stat_ptr point to starting of stat_rec.  */
	    temp_stat_ptr = (char *) (&stat_rec);

	    /* Freeing memory used for filename.  */
	    free (filename);

	    /* Setting up the stat structure returned.  */
	    SET_MEMORY_W (stat_ptr, stat_rec.st_dev);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_ino);
	    stat_ptr += 2;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_mode);
	    stat_ptr += 4;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_nlink);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_uid);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_gid);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_rdev);
	    stat_ptr += 2;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_size);
	    stat_ptr += 4;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_atime);
	    stat_ptr += 8;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_mtime);
	    stat_ptr += 8;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_ctime);

	    /* Return value in register 0.  */
	    cpu.regs[0] = stat_return;
	  }
	  goto next;
	  /* End of system call processing.  */

a1668 51
	case O (O_DAA, SB):
	  /* Decimal Adjust Addition.  This is for BCD arithmetic.  */
	  res = GET_B_REG (code->src.reg);
	  if (!c && (0 <= (res >>  4) && (res >>  4) <= 9) 
	      && !h && (0 <= (res & 0xf) && (res & 0xf) <= 9))
	    res = res;		/* Value added == 0.  */
	  else if (!c && (0  <= (res >>  4) && (res >>  4) <=  8) 
		   && !h && (10 <= (res & 0xf) && (res & 0xf) <= 15))
	    res = res + 0x6;		/* Value added == 6.  */
	  else if (!c && (0 <= (res >>  4) && (res >>  4) <= 9) 
		   && h && (0 <= (res & 0xf) && (res & 0xf) <= 3))
	    res = res + 0x6;		/* Value added == 6.  */
	  else if (!c && (10 <= (res >>  4) && (res >>  4) <= 15) 
		   && !h && (0  <= (res & 0xf) && (res & 0xf) <=  9))
	    res = res + 0x60;		/* Value added == 60.  */
	  else if (!c && (9  <= (res >>  4) && (res >>  4) <= 15) 
		   && !h && (10 <= (res & 0xf) && (res & 0xf) <= 15))
	    res = res + 0x66;		/* Value added == 66.  */
	  else if (!c && (10 <= (res >>  4) && (res >>  4) <= 15) 
		   && h && (0  <= (res & 0xf) && (res & 0xf) <=  3))
	    res = res + 0x66;		/* Value added == 66.  */
	  else if (c && (1 <= (res >>  4) && (res >>  4) <= 2) 
		   && !h && (0 <= (res & 0xf) && (res & 0xf) <= 9))
	    res = res + 0x160;		/* Value added == 60, plus 'carry'.  */
	  else if (c && (1  <= (res >>  4) && (res >>  4) <=  2) 
		   && !h && (10 <= (res & 0xf) && (res & 0xf) <= 15))
	    res = res + 0x166;		/* Value added == 66, plus 'carry'.  */
	  else if (c && (1 <= (res >>  4) && (res >>  4) <= 3) 
		   && h && (0 <= (res & 0xf) && (res & 0xf) <= 3))
	    res = res + 0x166;		/* Value added == 66, plus 'carry'.  */

	  goto alu8;

	case O (O_DAS, SB):
	  /* Decimal Adjust Subtraction.  This is for BCD arithmetic.  */
	  res = GET_B_REG (code->src.reg); /* FIXME fetch, fetch2... */
	  if (!c && (0 <= (res >>  4) && (res >>  4) <= 9) 
	      && !h && (0 <= (res & 0xf) && (res & 0xf) <= 9))
	    res = res;		/* Value added == 0.  */
	  else if (!c && (0 <= (res >>  4) && (res >>  4) <=  8) 
		   && h && (6 <= (res & 0xf) && (res & 0xf) <= 15))
	    res = res + 0xfa;		/* Value added == 0xfa.  */
	  else if (c && (7 <= (res >>  4) && (res >>  4) <= 15) 
		   && !h && (0 <= (res & 0xf) && (res & 0xf) <=  9))
	    res = res + 0xa0;		/* Value added == 0xa0.  */
	  else if (c && (6 <= (res >>  4) && (res >>  4) <= 15) 
		   && h && (6 <= (res & 0xf) && (res & 0xf) <= 15))
	    res = res + 0x9a;		/* Value added == 0x9a.  */

	  goto alu8;

a2232 4
  int i = 0;
  int len_arg = 0;
  int no_of_args = 0;
  
a2236 23

  /* Command Line support.  */
  if (argv != NULL)
    {
      /* Counting the no. of commandline arguments.  */
      for (no_of_args = 0; argv[no_of_args] != NULL; no_of_args++)
        continue;

      /* Allocating memory for the argv pointers.  */
      ptr_command_line = (char **) malloc ((sizeof (char *))
		         * (no_of_args + 1));

      for (i = 0; i < no_of_args; i++)
	{
	  /* Calculating the length of argument for allocating memory.  */
	  len_arg = strlen (argv[i] + 1);
	  ptr_command_line[i] = (char *) malloc (sizeof (char) * len_arg);
	  /* Copying the argument string.  */
	  ptr_command_line[i] = (char *) strdup (argv[i]);
	}
      ptr_command_line[i] = NULL;
    }
  
@


1.17.8.4
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d2 1
a2 1
 * Simulator for the Renesas (formerly Hitachi) H8/300 architecture.
d20 3
d33 1
a33 1

d35 2
a36 1
#include "sim-main.h"
d56 1
a56 1
static void set_simcache_size (SIM_DESC, int);
d58 1
a58 1
#define X(op, size)  (op * 4 + size)
d61 13
a73 1

d78 1
a78 1
/* CPU data object: */
d80 1
a80 4
static int
sim_state_initialize (SIM_DESC sd, sim_cpu *cpu)
{
  /* FIXME: not really necessary, since sim_cpu_alloc calls zalloc.  */
d82 1
a82 20
  memset (&cpu->regs, 0, sizeof(cpu->regs));
  cpu->regs[SBR_REGNUM] = 0xFFFFFF00;
  cpu->pc = 0;
  cpu->delayed_branch = 0;
  cpu->memory = NULL;
  cpu->eightbit = NULL;
  cpu->mask = 0;

  /* Initialize local simulator state.  */
  sd->sim_cache = NULL;
  sd->sim_cache_size = 0;
  sd->cache_idx = NULL;
  sd->cache_top = 0;
  sd->memory_size = 0;
  sd->compiles = 0;
#ifdef ADEBUG
  memset (&cpu->stats, 0, sizeof (cpu->stats));
#endif
  return 0;
}
d84 3
a86 5
static unsigned int
h8_get_pc (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> pc;
}
d88 23
a110 5
static void
h8_set_pc (SIM_DESC sd, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> pc = val;
}
d112 3
a114 5
static unsigned int
h8_get_ccr (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[CCR_REGNUM];
}
d116 3
a118 5
static void
h8_set_ccr (SIM_DESC sd, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> regs[CCR_REGNUM] = val;
}
d120 3
a122 5
static unsigned int
h8_get_exr (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[EXR_REGNUM];
}
d124 1
a124 5
static void
h8_set_exr (SIM_DESC sd, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> regs[EXR_REGNUM] = val;
}
d126 2
a127 5
static int
h8_get_sbr (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[SBR_REGNUM];
}
d129 1
a129 5
static void
h8_set_sbr (SIM_DESC sd, int val)
{
  (STATE_CPU (sd, 0)) -> regs[SBR_REGNUM] = val;
}
d132 1
a132 7
h8_get_vbr (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[VBR_REGNUM];
}

static void
h8_set_vbr (SIM_DESC sd, int val)
d134 1
a134 1
  (STATE_CPU (sd, 0)) -> regs[VBR_REGNUM] = val;
d138 1
a138 1
h8_get_cache_top (SIM_DESC sd)
d140 1
a140 7
  return sd -> cache_top;
}

static void
h8_set_cache_top (SIM_DESC sd, int val)
{
  sd -> cache_top = val;
d144 1
a144 1
h8_get_mask (SIM_DESC sd)
d146 11
a156 1
  return (STATE_CPU (sd, 0)) -> mask;
d159 2
a160 2
static void
h8_set_mask (SIM_DESC sd, int val)
d162 8
a169 8
  (STATE_CPU (sd, 0)) -> mask = val;
}
#if 0
static int
h8_get_exception (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> exception;
}
d171 2
a172 5
static void
h8_set_exception (SIM_DESC sd, int val)
{
  (STATE_CPU (sd, 0)) -> exception = val;
}
d174 3
a176 4
static enum h8300_sim_state
h8_get_state (SIM_DESC sd)
{
  return sd -> state;
d179 2
a180 2
static void
h8_set_state (SIM_DESC sd, enum h8300_sim_state val)
d182 6
a187 13
  sd -> state = val;
}
#endif
static unsigned int
h8_get_cycles (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[CYCLE_REGNUM];
}

static void
h8_set_cycles (SIM_DESC sd, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> regs[CYCLE_REGNUM] = val;
d191 1
a191 1
h8_get_insts (SIM_DESC sd)
d193 8
a200 2
  return (STATE_CPU (sd, 0)) -> regs[INST_REGNUM];
}
d202 2
a203 5
static void
h8_set_insts (SIM_DESC sd, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> regs[INST_REGNUM] = val;
}
d205 5
a209 5
static unsigned int
h8_get_ticks (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[TICK_REGNUM];
}
d211 4
a214 5
static void
h8_set_ticks (SIM_DESC sd, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> regs[TICK_REGNUM] = val;
}
d216 1
a216 5
static unsigned int
h8_get_mach (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[MACH_REGNUM];
}
d218 11
a228 5
static void
h8_set_mach (SIM_DESC sd, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> regs[MACH_REGNUM] = val;
}
d230 3
a232 5
static unsigned int
h8_get_macl (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> regs[MACL_REGNUM];
}
d234 4
a237 5
static void
h8_set_macl (SIM_DESC sd, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> regs[MACL_REGNUM] = val;
}
d239 2
a240 5
static int
h8_get_compiles (SIM_DESC sd)
{
  return sd -> compiles;
}
d242 7
a248 5
static void
h8_increment_compiles (SIM_DESC sd)
{
  sd -> compiles ++;
}
d250 34
a283 5
static unsigned int *
h8_get_reg_buf (SIM_DESC sd)
{
  return &(((STATE_CPU (sd, 0)) -> regs)[0]);
}
d285 4
a288 5
static unsigned int
h8_get_reg (SIM_DESC sd, int regnum)
{
  return (STATE_CPU (sd, 0)) -> regs[regnum];
}
d290 5
a294 5
static void
h8_set_reg (SIM_DESC sd, int regnum, int val)
{
  (STATE_CPU (sd, 0)) -> regs[regnum] = val;
}
d296 31
a326 6
#ifdef ADEBUG
static int
h8_get_stats (SIM_DESC sd, int idx)
{
  return sd -> stats[idx];
}
d328 18
a345 6
static void
h8_increment_stats (SIM_DESC sd, int idx)
{
  sd -> stats[idx] ++;
}
#endif /* ADEBUG */
d347 5
a351 5
static unsigned short *
h8_get_cache_idx_buf (SIM_DESC sd)
{
  return sd -> cache_idx;
}
d353 4
a356 5
static void
h8_set_cache_idx_buf (SIM_DESC sd, unsigned short *ptr)
{
  sd -> cache_idx = ptr;
}
d358 5
a362 7
static unsigned short
h8_get_cache_idx (SIM_DESC sd, unsigned int idx)
{
  if (idx > sd->memory_size)
    return (unsigned short) -1;
  return sd -> cache_idx[idx];
}
d364 4
a367 5
static void
h8_set_cache_idx (SIM_DESC sd, int idx, unsigned int val)
{
  sd -> cache_idx[idx] = (unsigned short) val;
}
d369 14
a382 5
static unsigned char *
h8_get_memory_buf (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> memory;
}
d384 75
a458 5
static void
h8_set_memory_buf (SIM_DESC sd, unsigned char *ptr)
{
  (STATE_CPU (sd, 0)) -> memory = ptr;
}
d460 2
a461 5
static unsigned char
h8_get_memory (SIM_DESC sd, int idx)
{
  return (STATE_CPU (sd, 0)) -> memory[idx];
}
d463 2
a464 5
static void
h8_set_memory (SIM_DESC sd, int idx, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> memory[idx] = (unsigned char) val;
}
d466 31
a496 5
static unsigned char *
h8_get_eightbit_buf (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> eightbit;
}
d498 6
a503 5
static void
h8_set_eightbit_buf (SIM_DESC sd, unsigned char *ptr)
{
  (STATE_CPU (sd, 0)) -> eightbit = ptr;
}
d505 3
a507 5
static unsigned char
h8_get_eightbit (SIM_DESC sd, int idx)
{
  return (STATE_CPU (sd, 0)) -> eightbit[idx];
}
d509 3
a511 5
static void
h8_set_eightbit (SIM_DESC sd, int idx, unsigned int val)
{
  (STATE_CPU (sd, 0)) -> eightbit[idx] = (unsigned char) val;
}
d513 2
a514 4
static unsigned int
h8_get_delayed_branch (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> delayed_branch;
d518 1
a518 1
h8_set_delayed_branch (SIM_DESC sd, unsigned int dest)
d520 1
a520 2
  (STATE_CPU (sd, 0)) -> delayed_branch = dest;
}
d522 8
a529 5
static char **
h8_get_command_line (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> command_line;
}
d531 2
a532 5
static void
h8_set_command_line (SIM_DESC sd, char ** val)
{
  (STATE_CPU (sd, 0)) -> command_line = val;
}
d534 2
a535 5
static char *
h8_get_cmdline_arg (SIM_DESC sd, int index)
{
  return (STATE_CPU (sd, 0)) -> command_line[index];
}
d537 2
a538 5
static void
h8_set_cmdline_arg (SIM_DESC sd, int index, char * val)
{
  (STATE_CPU (sd, 0)) -> command_line[index] = val;
}
d540 2
a541 5
/* MAC Saturation Mode */
static int
h8_get_macS (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> macS;
a543 5
static void
h8_set_macS (SIM_DESC sd, int val)
{
  (STATE_CPU (sd, 0)) -> macS = (val != 0);
}
d545 3
a547 6
/* MAC Zero Flag */
static int
h8_get_macZ (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> macZ;
}
d549 4
a552 5
static void
h8_set_macZ (SIM_DESC sd, int val)
{
  (STATE_CPU (sd, 0)) -> macZ = (val != 0);
}
d554 2
a555 6
/* MAC Negative Flag */
static int
h8_get_macN (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> macN;
}
d557 6
a562 5
static void
h8_set_macN (SIM_DESC sd, int val)
{
  (STATE_CPU (sd, 0)) -> macN = (val != 0);
}
d564 4
a567 6
/* MAC Overflow Flag */
static int
h8_get_macV (SIM_DESC sd)
{
  return (STATE_CPU (sd, 0)) -> macV;
}
a568 5
static void
h8_set_macV (SIM_DESC sd, int val)
{
  (STATE_CPU (sd, 0)) -> macV = (val != 0);
}
d570 2
a571 1
/* End CPU data object.  */
d573 5
a577 1
/* The rate at which to call the host's poll_quit callback.  */
d579 4
a582 1
enum { POLL_QUIT_INTERVAL = 0x80000 };
d584 2
a585 3
#define LOW_BYTE(x) ((x) & 0xff)
#define HIGH_BYTE(x) (((x) >> 8) & 0xff)
#define P(X, Y) ((X << 8) | Y)
d587 7
a593 8
#define C (c != 0)
#define Z (nz == 0)
#define V (v != 0)
#define N (n != 0)
#define U (u != 0)
#define H (h != 0)
#define UI (ui != 0)
#define I (intMaskBit != 0)
d595 14
a608 14
#define BUILDSR(SD)						\
  h8_set_ccr (SD, (I << 7) | (UI << 6) | (H << 5) | (U << 4)	\
	     | (N << 3) | (Z << 2) | (V << 1) | C)

#define GETSR(SD) \
  /* Get Status Register (flags).  */		\
  c = (h8_get_ccr (sd) >> 0) & 1;		\
  v = (h8_get_ccr (sd) >> 1) & 1;		\
  nz = !((h8_get_ccr (sd) >> 2) & 1);		\
  n = (h8_get_ccr (sd) >> 3) & 1;		\
  u = (h8_get_ccr (sd) >> 4) & 1;		\
  h = (h8_get_ccr (sd) >> 5) & 1;		\
  ui = ((h8_get_ccr (sd) >> 6) & 1);		\
  intMaskBit = (h8_get_ccr (sd) >> 7) & 1
d610 21
d632 4
a635 3
#ifdef __CHAR_IS_SIGNED__
#define SEXTCHAR(x) ((char) (x))
#endif
d637 4
a640 3
#ifndef SEXTCHAR
#define SEXTCHAR(x) ((x & 0x80) ? (x | ~0xff) : x & 0xff)
#endif
d642 4
a645 3
#define UEXTCHAR(x) ((x) & 0xff)
#define UEXTSHORT(x) ((x) & 0xffff)
#define SEXTSHORT(x) ((short) (x))
d647 4
a650 3
int h8300hmode  = 0;
int h8300smode  = 0;
int h8300sxmode = 0;
d652 4
a655 1
static int memory_size;
d657 4
a660 5
static int
get_now (void)
{
  return time (0);	/* WinXX HAS UNIX like 'time', so why not use it? */
}
d662 2
a663 5
static int
now_persec (void)
{
  return 1;
}
a664 14
static int
bitfrom (int x)
{
  switch (x & SIZE)
    {
    case L_8:
      return SB;
    case L_16:
    case L_16U:
      return SW;
    case L_32:
      return SL;
    case L_P:
      return h8300hmode ? SL : SW;
a665 1
  return 0;
a667 3
/* Simulate an indirection / dereference.  
   return 0 for success, -1 for failure.
*/
d669 2
a670 2
static unsigned int
lvalue (SIM_DESC sd, int x, int rn, unsigned int *val)
d672 3
a674 2
  if (val == NULL)	/* Paranoia.  */
    return -1;
d676 1
a676 1
  switch (x / 4)
d678 39
a716 5
    case OP_DISP:
      if (rn == ZERO_REGNUM)
	*val = X (OP_IMM, SP);
      else
	*val = X (OP_REG, SP);
d718 5
a722 2
    case OP_MEM:
      *val = X (OP_MEM, SP);
d725 1
a725 2
      sim_engine_set_run_state (sd, sim_stopped, SIGSEGV);
      return -1;
a726 1
  return 0;
d729 2
a730 2
static int
cmdline_location()
d732 7
a738 6
  if (h8300smode)
    return 0xffff00L;
  else if (h8300hmode)
    return 0x2ff00L;
  else
    return 0xff00L;
d741 2
d744 1
a744 1
decode (SIM_DESC sd, int addr, unsigned char *data, decoded_inst *dst)
d746 5
a750 5
  int cst[3]   = {0, 0, 0};
  int reg[3]   = {0, 0, 0};
  int rdisp[3] = {0, 0, 0};
  int opnum;
  const struct h8_opcode *q;
d752 2
a753 2
  dst->dst.type = -1;
  dst->src.type = -1;
d755 9
a763 5
  /* Find the exact opcode/arg combo.  */
  for (q = h8_opcodes; q->name; q++)
    {
      op_type *nib = q->data.nib;
      unsigned int len = 0;
d765 4
a768 4
      if ((q->available == AV_H8SX && !h8300sxmode) ||
	  (q->available == AV_H8S  && !h8300smode)  ||
	  (q->available == AV_H8H  && !h8300hmode))
	continue;
d770 1
a770 1
      while (1)
d772 2
a773 2
	  op_type looking_for = *nib;
	  int thisnib = data[len / 2];
d775 8
a782 5
	  thisnib = (len & 1) ? (thisnib & 0xf) : ((thisnib >> 4) & 0xf);
	  opnum = ((looking_for & OP3) ? 2 :
		   (looking_for & DST) ? 1 : 0);

	  if (looking_for < 16 && looking_for >= 0)
d784 1
a784 6
	      if (looking_for != thisnib)
		goto fail;
	    }
	  else
	    {
	      if (looking_for & B31)
d786 1
a786 5
		  if (!((thisnib & 0x8) != 0))
		    goto fail;

		  looking_for = (op_type) (looking_for & ~B31);
		  thisnib &= 0x7;
d788 1
a788 1
	      else if (looking_for & B30)
d790 1
a790 4
		  if (!((thisnib & 0x8) == 0))
		    goto fail;

		  looking_for = (op_type) (looking_for & ~B30);
d792 6
a797 2

	      if (looking_for & B21)
d799 1
a799 5
		  if (!((thisnib & 0x4) != 0))
		    goto fail;

		  looking_for = (op_type) (looking_for & ~B21);
		  thisnib &= 0xb;
d801 1
a801 1
	      else if (looking_for & B20)
d803 1
a803 4
		  if (!((thisnib & 0x4) == 0))
		    goto fail;

		  looking_for = (op_type) (looking_for & ~B20);
d805 7
d813 1
a813 4
	      if (looking_for & B11)
		{
		  if (!((thisnib & 0x2) != 0))
		    goto fail;
d815 5
a819 7
		  looking_for = (op_type) (looking_for & ~B11);
		  thisnib &= 0xd;
		}
	      else if (looking_for & B10)
		{
		  if (!((thisnib & 0x2) == 0))
		    goto fail;
d821 6
a826 2
		  looking_for = (op_type) (looking_for & ~B10);
		}
d828 8
a835 4
	      if (looking_for & B01)
		{
		  if (!((thisnib & 0x1) != 0))
		    goto fail;
d837 24
a860 7
		  looking_for = (op_type) (looking_for & ~B01);
		  thisnib &= 0xe;
		}
	      else if (looking_for & B00)
		{
		  if (!((thisnib & 0x1) == 0))
		    goto fail;
d862 2
a863 2
		  looking_for = (op_type) (looking_for & ~B00);
		}
d865 15
a879 241
	      if (looking_for & IGNORE)
		{
		  /* Hitachi has declared that IGNORE must be zero.  */
		  if (thisnib != 0)
		    goto fail;
		}
	      else if ((looking_for & MODE) == DATA)
		{
		  ;			/* Skip embedded data.  */
		}
	      else if ((looking_for & MODE) == DBIT)
		{
		  /* Exclude adds/subs by looking at bit 0 and 2, and
                     make sure the operand size, either w or l,
                     matches by looking at bit 1.  */
		  if ((looking_for & 7) != (thisnib & 7))
		    goto fail;

		  cst[opnum] = (thisnib & 0x8) ? 2 : 1;
		}
	      else if ((looking_for & MODE) == REG     ||
		       (looking_for & MODE) == LOWREG  ||
		       (looking_for & MODE) == IND     ||
		       (looking_for & MODE) == PREINC  ||
		       (looking_for & MODE) == POSTINC ||
		       (looking_for & MODE) == PREDEC  ||
		       (looking_for & MODE) == POSTDEC)
		{
		  reg[opnum] = thisnib;
		}
	      else if (looking_for & CTRL)
		{
		  thisnib &= 7;
		  if (((looking_for & MODE) == CCR  && (thisnib != C_CCR))  ||
		      ((looking_for & MODE) == EXR  && (thisnib != C_EXR))  ||
		      ((looking_for & MODE) == MACH && (thisnib != C_MACH)) ||
		      ((looking_for & MODE) == MACL && (thisnib != C_MACL)) ||
		      ((looking_for & MODE) == VBR  && (thisnib != C_VBR))  ||
		      ((looking_for & MODE) == SBR  && (thisnib != C_SBR)))
		    goto fail;
		  if (((looking_for & MODE) == CCR_EXR && 
		       (thisnib != C_CCR && thisnib != C_EXR)) ||
		      ((looking_for & MODE) == VBR_SBR && 
		       (thisnib != C_VBR && thisnib != C_SBR)) ||
		      ((looking_for & MODE) == MACREG && 
		       (thisnib != C_MACH && thisnib != C_MACL)))
		    goto fail;
		  if (((looking_for & MODE) == CC_EX_VB_SB && 
		       (thisnib != C_CCR && thisnib != C_EXR &&
			thisnib != C_VBR && thisnib != C_SBR)))
		    goto fail;

		  reg[opnum] = thisnib;
		}
	      else if ((looking_for & MODE) == ABS)
		{
		  /* Absolute addresses are unsigned.  */
		  switch (looking_for & SIZE)
		    {
		    case L_8:
		      cst[opnum] = UEXTCHAR (data[len / 2]);
		      break;
		    case L_16:
		    case L_16U:
		      cst[opnum] = (data[len / 2] << 8) + data[len / 2 + 1];
		      break;
		    case L_32:
		      cst[opnum] = 
			(data[len / 2 + 0] << 24) + 
			(data[len / 2 + 1] << 16) +
			(data[len / 2 + 2] <<  8) +  
			(data[len / 2 + 3]);
		      break;
		    default:
		      printf ("decode: bad size ABS: %d\n", 
			      (looking_for & SIZE));
		      goto end;
		    }
		}
	      else if ((looking_for & MODE) == DISP   ||
		       (looking_for & MODE) == PCREL  ||
		       (looking_for & MODE) == INDEXB ||
		       (looking_for & MODE) == INDEXW ||
		       (looking_for & MODE) == INDEXL)

		{
		  switch (looking_for & SIZE)
		    {
		    case L_2:
		      cst[opnum] = thisnib & 3;

		      /* DISP2 special treatment.  */
		      if ((looking_for & MODE) == DISP)
			{
			  switch (OP_SIZE (q->how)) {
			  default: break;
			  case SW:
			    cst[opnum] *= 2;
			    break;
			  case SL:
			    cst[opnum] *= 4;
			    break;
			  }
			}
		      break;
		    case L_8:
		      cst[opnum] = SEXTCHAR (data[len / 2]);
		      break;
		    case L_16:
		      cst[opnum] = (data[len / 2] << 8) + data[len / 2 + 1];
		      cst[opnum] = (short) cst[opnum];	/* Sign extend.  */
		      break;
		    case L_16U:
		      cst[opnum] = (data[len / 2] << 8) + data[len / 2 + 1];
		      break;
		    case L_32:
		      cst[opnum] = 
			(data[len / 2 + 0] << 24) + 
			(data[len / 2 + 1] << 16) +
			(data[len / 2 + 2] <<  8) +  
			(data[len / 2 + 3]);
		      break;
		    default:
		      printf ("decode: bad size DISP/PCREL/INDEX: %d\n", 
			      (looking_for & SIZE));
		      goto end;
		    }
		}
	      else if ((looking_for & SIZE) == L_16 ||
		       (looking_for & SIZE) == L_16U)
		{
		  cst[opnum] = (data[len / 2] << 8) + data[len / 2 + 1];
		  if ((looking_for & SIZE) != L_16U)
		    cst[opnum] = (short) cst[opnum];	/* Sign extend.  */
		}
	      else if (looking_for & ABSJMP)
		{
		  switch (looking_for & SIZE) {
		  case L_24:
		    cst[opnum] = (data[1] << 16) | (data[2] << 8) | (data[3]);
		    break;
		  case L_32:
		    cst[opnum] = 
		      (data[len / 2 + 0] << 24) + 
		      (data[len / 2 + 1] << 16) +
		      (data[len / 2 + 2] <<  8) +  
		      (data[len / 2 + 3]);
		    break;
		  default:
		    printf ("decode: bad size ABSJMP: %d\n", 
			    (looking_for & SIZE));
		      goto end;
		  }
		}
	      else if ((looking_for & MODE) == MEMIND)
		{
		  cst[opnum] = data[1];
		}
	      else if ((looking_for & MODE) == VECIND)
		{
		  /* FIXME: Multiplier should be 2 for "normal" mode.  */
		  cst[opnum] = ((data[1] & 0x7f) + 0x80) * 4;
		  cst[opnum] += h8_get_vbr (sd); /* Add vector base reg.  */
		}
	      else if ((looking_for & SIZE) == L_32)
		{
		  int i = len / 2;

		  cst[opnum] = 
		    (data[i + 0] << 24) |
		    (data[i + 1] << 16) |
		    (data[i + 2] <<  8) |
		    (data[i + 3]);
		}
	      else if ((looking_for & SIZE) == L_24)
		{
		  int i = len / 2;

		  cst[opnum] = 
		    (data[i + 0] << 16) | 
		    (data[i + 1] << 8) | 
		    (data[i + 2]);
		}
	      else if (looking_for & DISPREG)
		{
		  rdisp[opnum] = thisnib & 0x7;
		}
	      else if ((looking_for & MODE) == KBIT)
		{
		  switch (thisnib)
		    {
		    case 9:
		      cst[opnum] = 4;
		      break;
		    case 8:
		      cst[opnum] = 2;
		      break;
		    case 0:
		      cst[opnum] = 1;
		      break;
		    default:
		      goto fail;
		    }
		}
	      else if ((looking_for & SIZE) == L_8)
		{
		  if ((looking_for & MODE) == ABS)
		    {
		      /* Will be combined with contents of SBR_REGNUM
			 by fetch ().  For all modes except h8sx, this
			 will always contain the value 0xFFFFFF00.  */
		      cst[opnum] = data[len / 2] & 0xff;
		    }
		  else
		    {
		      cst[opnum] = data[len / 2] & 0xff;
		    }
		}
	      else if ((looking_for & SIZE) == L_2)
		{
		  cst[opnum] = thisnib & 3;
		}
	      else if ((looking_for & SIZE) == L_3 ||
		       (looking_for & SIZE) == L_3NZ)
		{
		  cst[opnum] = thisnib & 7;
		  if (cst[opnum] == 0 && (looking_for & SIZE) == L_3NZ)
		    goto fail;
		}
	      else if ((looking_for & SIZE) == L_4)
		{
		  cst[opnum] = thisnib & 15;
		}
	      else if ((looking_for & SIZE) == L_5)
		{
		  cst[opnum] = data[len / 2] & 0x1f;
		}
	      else if (looking_for == E)
		{
#ifdef ADEBUG
		  dst->op = q;
d881 1
a881 5
		  /* Fill in the args.  */
		  {
		    op_type *args = q->args.nib;
		    int hadone = 0;
		    int nargs;
d883 25
a907 6
		    for (nargs = 0; 
			 nargs < 3 && *args != E; 
			 nargs++)
		      {
			int x = *args;
			ea_type *p;
d909 46
a954 2117
			opnum = ((x & OP3) ? 2 :
				 (x & DST) ? 1 : 0);
			if (x & DST)
			  p = &dst->dst;
			else if (x & OP3)
			  p = &dst->op3;
			else
			  p = &dst->src;

			if ((x & MODE) == IMM  ||
			    (x & MODE) == KBIT ||
			    (x & MODE) == DBIT)
			  {
			    /* Use the instruction to determine 
			       the operand size.  */
			    p->type = X (OP_IMM, OP_SIZE (q->how));
			    p->literal = cst[opnum];
			  }
			else if ((x & MODE) == CONST_2 ||
				 (x & MODE) == CONST_4 ||
				 (x & MODE) == CONST_8 ||
				 (x & MODE) == CONST_16)
			  {
			    /* Use the instruction to determine 
			       the operand size.  */
			    p->type = X (OP_IMM, OP_SIZE (q->how));
			    switch (x & MODE) {
			    case CONST_2:	p->literal =  2; break;
			    case CONST_4:	p->literal =  4; break;
			    case CONST_8:	p->literal =  8; break;
			    case CONST_16:	p->literal = 16; break;
			    }
			  }
			else if ((x & MODE) == REG)
			  {
			    p->type = X (OP_REG, bitfrom (x));
			    p->reg = reg[opnum];
			  }
			else if ((x & MODE) == LOWREG)
			  {
			    p->type = X (OP_LOWREG, bitfrom (x));
			    p->reg = reg[opnum];
			  }
			else if ((x & MODE) == PREINC)
			  {
			    /* Use the instruction to determine 
			       the operand size.  */
			    p->type = X (OP_PREINC, OP_SIZE (q->how));
			    p->reg = reg[opnum] & 0x7;
			  }
			else if ((x & MODE) == POSTINC)
			  {
			    /* Use the instruction to determine 
			       the operand size.  */
			    p->type = X (OP_POSTINC, OP_SIZE (q->how));
			    p->reg = reg[opnum] & 0x7;
			  }
			else if ((x & MODE) == PREDEC)
			  {
			    /* Use the instruction to determine 
			       the operand size.  */
			    p->type = X (OP_PREDEC, OP_SIZE (q->how));
			    p->reg = reg[opnum] & 0x7;
			  }
			else if ((x & MODE) == POSTDEC)
			  {
			    /* Use the instruction to determine 
			       the operand size.  */
			    p->type = X (OP_POSTDEC, OP_SIZE (q->how));
			    p->reg = reg[opnum] & 0x7;
			  }
			else if ((x & MODE) == IND)
			  {
			    /* Note: an indirect is transformed into
			       a displacement of zero.  
			    */
			    /* Use the instruction to determine 
			       the operand size.  */
			    p->type = X (OP_DISP, OP_SIZE (q->how));
			    p->reg = reg[opnum] & 0x7;
			    p->literal = 0;
			    if (OP_KIND (q->how) == O_JSR ||
				OP_KIND (q->how) == O_JMP)
			      if (lvalue (sd, p->type, p->reg, &p->type))
				goto end;
			  }
			else if ((x & MODE) == ABS)
			  {
			    /* Note: a 16 or 32 bit ABS is transformed into a 
			       displacement from pseudo-register ZERO_REGNUM,
			       which is always zero.  An 8 bit ABS becomes
			       a displacement from SBR_REGNUM.
			    */
			    /* Use the instruction to determine 
			       the operand size.  */
			    p->type = X (OP_DISP, OP_SIZE (q->how));
			    p->literal = cst[opnum];

			    /* 8-bit ABS is displacement from SBR.
			       16 and 32-bit ABS are displacement from ZERO.
			       (SBR will always be zero except for h8/sx)
			    */
			    if ((x & SIZE) == L_8)
			      p->reg = SBR_REGNUM;
			    else
			      p->reg = ZERO_REGNUM;;
			  }
			else if ((x & MODE) == MEMIND ||
				 (x & MODE) == VECIND)
			  {
			    /* Size doesn't matter.  */
			    p->type = X (OP_MEM, SB);
			    p->literal = cst[opnum];
			    if (OP_KIND (q->how) == O_JSR ||
				OP_KIND (q->how) == O_JMP)
			      if (lvalue (sd, p->type, p->reg, &p->type))
				goto end;
			  }
			else if ((x & MODE) == PCREL)
			  {
			    /* Size doesn't matter.  */
			    p->type = X (OP_PCREL, SB);
			    p->literal = cst[opnum];
			  }
			else if (x & ABSJMP)
			  {
			    p->type = X (OP_IMM, SP);
			    p->literal = cst[opnum];
			  }
			else if ((x & MODE) == INDEXB ||
				 (x & MODE) == INDEXW ||
				 (x & MODE) == INDEXL ||
				 (x & MODE) == DISP)
			  {
			    /* Use the instruction to determine 
			       the operand size.  */
			    switch (x & MODE) {
			    case INDEXB:
			      p->type = X (OP_INDEXB, OP_SIZE (q->how));
			      break;
			    case INDEXW:
			      p->type = X (OP_INDEXW, OP_SIZE (q->how));
			      break;
			    case INDEXL:
			      p->type = X (OP_INDEXL, OP_SIZE (q->how));
			      break;
			    case DISP:
			      p->type = X (OP_DISP,   OP_SIZE (q->how));
			      break;
			    }

			    p->literal = cst[opnum];
			    p->reg     = rdisp[opnum];
			  }
			else if (x & CTRL)
			  {
			    switch (reg[opnum])
			      {
			      case C_CCR:
				p->type = X (OP_CCR, SB);
				break;
			      case C_EXR:
				p->type = X (OP_EXR, SB);
				break;
			      case C_MACH:
				p->type = X (OP_MACH, SL);
				break;
			      case C_MACL:
				p->type = X (OP_MACL, SL);
				break;
			      case C_VBR:
				p->type = X (OP_VBR, SL);
				break;
			      case C_SBR:
				p->type = X (OP_SBR, SL);
				break;
			      }
			  }
			else if ((x & MODE) == CCR)
			  {
			    p->type = OP_CCR;
			  }
			else if ((x & MODE) == EXR)
			  {
			    p->type = OP_EXR;
			  }
			else
			  printf ("Hmmmm 0x%x...\n", x);

			args++;
		      }
		  }

		  /* Unary operators: treat src and dst as equivalent.  */
		  if (dst->dst.type == -1)
		    dst->dst = dst->src;
		  if (dst->src.type == -1)
		    dst->src = dst->dst;

		  dst->opcode = q->how;
		  dst->cycles = q->time;

		  /* And jsr's to these locations are turned into 
		     magic traps.  */

		  if (OP_KIND (dst->opcode) == O_JSR)
		    {
		      switch (dst->src.literal)
			{
			case 0xc5:
			  dst->opcode = O (O_SYS_OPEN, SB);
			  break;
			case 0xc6:
			  dst->opcode = O (O_SYS_READ, SB);
			  break;
			case 0xc7:
			  dst->opcode = O (O_SYS_WRITE, SB);
			  break;
			case 0xc8:
			  dst->opcode = O (O_SYS_LSEEK, SB);
			  break;
			case 0xc9:
			  dst->opcode = O (O_SYS_CLOSE, SB);
			  break;
			case 0xca:
			  dst->opcode = O (O_SYS_STAT, SB);
			  break;
			case 0xcb:
			  dst->opcode = O (O_SYS_FSTAT, SB);
			  break;
			case 0xcc:
			  dst->opcode = O (O_SYS_CMDLINE, SB);
			  break;
			}
		      /* End of Processing for system calls.  */
		    }

		  dst->next_pc = addr + len / 2;
		  return;
		}
	      else
		printf ("Don't understand 0x%x \n", looking_for);
	    }

	  len++;
	  nib++;
	}

    fail:
      ;
    }
 end:
  /* Fell off the end.  */
  dst->opcode = O (O_ILL, SB);
}

static void
compile (SIM_DESC sd, int pc)
{
  int idx;

  /* Find the next cache entry to use.  */
  idx = h8_get_cache_top (sd) + 1;
  h8_increment_compiles (sd);
  if (idx >= sd->sim_cache_size)
    {
      idx = 1;
    }
  h8_set_cache_top (sd, idx);

  /* Throw away its old meaning.  */
  h8_set_cache_idx (sd, sd->sim_cache[idx].oldpc, 0);

  /* Set to new address.  */
  sd->sim_cache[idx].oldpc = pc;

  /* Fill in instruction info.  */
  decode (sd, pc, h8_get_memory_buf (sd) + pc, sd->sim_cache + idx);

  /* Point to new cache entry.  */
  h8_set_cache_idx (sd, pc, idx);
}


static unsigned char  *breg[32];
static unsigned short *wreg[16];
static unsigned int   *lreg[18];

#define GET_B_REG(X)     *(breg[X])
#define SET_B_REG(X, Y) (*(breg[X])) = (Y)
#define GET_W_REG(X)     *(wreg[X])
#define SET_W_REG(X, Y) (*(wreg[X])) = (Y)
#define GET_L_REG(X)     h8_get_reg (sd, X)
#define SET_L_REG(X, Y)  h8_set_reg (sd, X, Y)

#define GET_MEMORY_L(X) \
  ((X) < memory_size \
   ? ((h8_get_memory (sd, (X)+0) << 24) | (h8_get_memory (sd, (X)+1) << 16)  \
    | (h8_get_memory (sd, (X)+2) <<  8) | (h8_get_memory (sd, (X)+3) <<  0)) \
   : ((h8_get_eightbit (sd, ((X)+0) & 0xff) << 24) \
    | (h8_get_eightbit (sd, ((X)+1) & 0xff) << 16) \
    | (h8_get_eightbit (sd, ((X)+2) & 0xff) <<  8) \
    | (h8_get_eightbit (sd, ((X)+3) & 0xff) <<  0)))

#define GET_MEMORY_W(X) \
  ((X) < memory_size \
   ? ((h8_get_memory   (sd, (X)+0) << 8) \
    | (h8_get_memory   (sd, (X)+1) << 0)) \
   : ((h8_get_eightbit (sd, ((X)+0) & 0xff) << 8) \
    | (h8_get_eightbit (sd, ((X)+1) & 0xff) << 0)))


#define GET_MEMORY_B(X) \
  ((X) < memory_size ? (h8_get_memory   (sd, (X))) \
                     : (h8_get_eightbit (sd, (X) & 0xff)))

#define SET_MEMORY_L(X, Y)  \
{  register unsigned char *_p; register int __y = (Y); \
   _p = ((X) < memory_size ? h8_get_memory_buf   (sd) +  (X) : \
                             h8_get_eightbit_buf (sd) + ((X) & 0xff)); \
   _p[0] = __y >> 24; _p[1] = __y >> 16; \
   _p[2] = __y >>  8; _p[3] = __y >>  0; \
}

#define SET_MEMORY_W(X, Y) \
{  register unsigned char *_p; register int __y = (Y); \
   _p = ((X) < memory_size ? h8_get_memory_buf   (sd) +  (X) : \
                             h8_get_eightbit_buf (sd) + ((X) & 0xff)); \
   _p[0] = __y >> 8; _p[1] = __y; \
}

#define SET_MEMORY_B(X, Y) \
  ((X) < memory_size ? (h8_set_memory   (sd, (X), (Y))) \
                     : (h8_set_eightbit (sd, (X) & 0xff, (Y))))

/* Simulate a memory fetch.
   Return 0 for success, -1 for failure.
*/

static int
fetch_1 (SIM_DESC sd, ea_type *arg, int *val, int twice)
{
  int rn = arg->reg;
  int abs = arg->literal;
  int r;
  int t;

  if (val == NULL)
    return -1;		/* Paranoia.  */

  switch (arg->type)
    {
      /* Indexed register plus displacement mode:

	 This new family of addressing modes are similar to OP_DISP
	 (register plus displacement), with two differences:
	   1) INDEXB uses only the least significant byte of the register,
	      INDEXW uses only the least significant word, and
	      INDEXL uses the entire register (just like OP_DISP).
	 and
	   2) The displacement value in abs is multiplied by two
	      for SW-sized operations, and by four for SL-size.

	This gives nine possible variations.
      */

    case X (OP_INDEXB, SB):
    case X (OP_INDEXB, SW):
    case X (OP_INDEXB, SL):
    case X (OP_INDEXW, SB):
    case X (OP_INDEXW, SW):
    case X (OP_INDEXW, SL):
    case X (OP_INDEXL, SB):
    case X (OP_INDEXL, SW):
    case X (OP_INDEXL, SL):
      t = GET_L_REG (rn);
      switch (OP_KIND (arg->type)) {
      case OP_INDEXB:	t &= 0xff;	break;
      case OP_INDEXW:	t &= 0xffff;	break;
      case OP_INDEXL:
      default:		break;
      }
      switch (OP_SIZE (arg->type)) {
      case SB:
	*val = GET_MEMORY_B ((t * 1 + abs) & h8_get_mask (sd));
	break;
      case SW:
	*val = GET_MEMORY_W ((t * 2 + abs) & h8_get_mask (sd));
	break;
      case SL:
	*val = GET_MEMORY_L ((t * 4 + abs) & h8_get_mask (sd));
	break;
      }
      break;

    case X (OP_LOWREG, SB):
      *val = GET_L_REG (rn) & 0xff;
      break;
    case X (OP_LOWREG, SW):
      *val = GET_L_REG (rn) & 0xffff; 
      break;

    case X (OP_REG, SB):	/* Register direct, byte.  */
      *val = GET_B_REG (rn);
      break;
    case X (OP_REG, SW):	/* Register direct, word.  */
      *val = GET_W_REG (rn);
      break;
    case X (OP_REG, SL):	/* Register direct, long.  */
      *val = GET_L_REG (rn);
      break;
    case X (OP_IMM, SB):	/* Immediate, byte.  */
    case X (OP_IMM, SW):	/* Immediate, word.  */
    case X (OP_IMM, SL):	/* Immediate, long.  */
      *val = abs;
      break;
    case X (OP_POSTINC, SB):	/* Register indirect w/post-incr: byte.  */
      t = GET_L_REG (rn);
      t &= h8_get_mask (sd);
      r = GET_MEMORY_B (t);
      if (!twice)
	t += 1;
      t = t & h8_get_mask (sd);
      SET_L_REG (rn, t);
      *val = r;
      break;
    case X (OP_POSTINC, SW):	/* Register indirect w/post-incr: word.  */
      t = GET_L_REG (rn);
      t &= h8_get_mask (sd);
      r = GET_MEMORY_W (t);
      if (!twice)
	t += 2;
      t = t & h8_get_mask (sd);
      SET_L_REG (rn, t);
      *val = r;
      break;
    case X (OP_POSTINC, SL):	/* Register indirect w/post-incr: long.  */
      t = GET_L_REG (rn);
      t &= h8_get_mask (sd);
      r = GET_MEMORY_L (t);
      if (!twice)
	t += 4;
      t = t & h8_get_mask (sd);
      SET_L_REG (rn, t);
      *val = r;
      break;

    case X (OP_POSTDEC, SB):	/* Register indirect w/post-decr: byte.  */
      t = GET_L_REG (rn);
      t &= h8_get_mask (sd);
      r = GET_MEMORY_B (t);
      if (!twice)
	t -= 1;
      t = t & h8_get_mask (sd);
      SET_L_REG (rn, t);
      *val = r;
      break;
    case X (OP_POSTDEC, SW):	/* Register indirect w/post-decr: word.  */
      t = GET_L_REG (rn);
      t &= h8_get_mask (sd);
      r = GET_MEMORY_W (t);
      if (!twice)
	t -= 2;
      t = t & h8_get_mask (sd);
      SET_L_REG (rn, t);
      *val = r;
      break;
    case X (OP_POSTDEC, SL):	/* Register indirect w/post-decr: long.  */
      t = GET_L_REG (rn);
      t &= h8_get_mask (sd);
      r = GET_MEMORY_L (t);
      if (!twice)
	t -= 4;
      t = t & h8_get_mask (sd);
      SET_L_REG (rn, t);
      *val = r;
      break;

    case X (OP_PREDEC, SB):	/* Register indirect w/pre-decr: byte.  */
      t = GET_L_REG (rn) - 1;
      t &= h8_get_mask (sd);
      SET_L_REG (rn, t);
      *val = GET_MEMORY_B (t);
      break;
      
    case X (OP_PREDEC, SW):	/* Register indirect w/pre-decr: word.  */
      t = GET_L_REG (rn) - 2;
      t &= h8_get_mask (sd);
      SET_L_REG (rn, t);
      *val = GET_MEMORY_W (t);
      break;
      
    case X (OP_PREDEC, SL):	/* Register indirect w/pre-decr: long.  */
      t = GET_L_REG (rn) - 4;
      t &= h8_get_mask (sd);
      SET_L_REG (rn, t);
      *val = GET_MEMORY_L (t);
      break;
      
    case X (OP_PREINC, SB):	/* Register indirect w/pre-incr: byte.  */
      t = GET_L_REG (rn) + 1;
      t &= h8_get_mask (sd);
      SET_L_REG (rn, t);
      *val = GET_MEMORY_B (t);
      break;

    case X (OP_PREINC, SW):	/* Register indirect w/pre-incr: long.  */
      t = GET_L_REG (rn) + 2;
      t &= h8_get_mask (sd);
      SET_L_REG (rn, t);
      *val = GET_MEMORY_W (t);
      break;

    case X (OP_PREINC, SL):	/* Register indirect w/pre-incr: long.  */
      t = GET_L_REG (rn) + 4;
      t &= h8_get_mask (sd);
      SET_L_REG (rn, t);
      *val = GET_MEMORY_L (t);
      break;

    case X (OP_DISP, SB):	/* Register indirect w/displacement: byte.  */
      t = GET_L_REG (rn) + abs;
      t &= h8_get_mask (sd);
      *val = GET_MEMORY_B (t);
      break;

    case X (OP_DISP, SW):	/* Register indirect w/displacement: word.  */
      t = GET_L_REG (rn) + abs;
      t &= h8_get_mask (sd);
      *val = GET_MEMORY_W (t);
      break;

    case X (OP_DISP, SL):	/* Register indirect w/displacement: long.  */
      t = GET_L_REG (rn) + abs;
      t &= h8_get_mask (sd);
      *val =GET_MEMORY_L (t);
      break;

    case X (OP_MEM, SL):	/* Absolute memory address, long.  */
      t = GET_MEMORY_L (abs);
      t &= h8_get_mask (sd);
      *val = t;
      break;

    case X (OP_MEM, SW):	/* Absolute memory address, word.  */
      t = GET_MEMORY_W (abs);
      t &= h8_get_mask (sd);
      *val = t;
      break;

    case X (OP_PCREL, SB):	/* PC relative (for jump, branch etc).  */
    case X (OP_PCREL, SW):
    case X (OP_PCREL, SL):
    case X (OP_PCREL, SN):
      *val = abs;
      break;

    case X (OP_MEM, SB):	/* Why isn't this implemented?  */
    default:
      sim_engine_set_run_state (sd, sim_stopped, SIGSEGV);
      return -1;
    }
  return 0;	/* Success.  */
}

/* Normal fetch.  */

static int
fetch (SIM_DESC sd, ea_type *arg, int *val)
{
  return fetch_1 (sd, arg, val, 0);
}

/* Fetch which will be followed by a store to the same location.
   The difference being that we don't want to do a post-increment
   or post-decrement at this time: we'll do it when we store.  */

static int
fetch2 (SIM_DESC sd, ea_type *arg, int *val)
{
  return fetch_1 (sd, arg, val, 1);
}

/* Simulate a memory store.
   Return 0 for success, -1 for failure.
*/

static int
store_1 (SIM_DESC sd, ea_type *arg, int n, int twice)
{
  int rn = arg->reg;
  int abs = arg->literal;
  int t;

  switch (arg->type)
    {
      /* Indexed register plus displacement mode:

	 This new family of addressing modes are similar to OP_DISP
	 (register plus displacement), with two differences:
	   1) INDEXB uses only the least significant byte of the register,
	      INDEXW uses only the least significant word, and
	      INDEXL uses the entire register (just like OP_DISP).
	 and
	   2) The displacement value in abs is multiplied by two
	      for SW-sized operations, and by four for SL-size.

	This gives nine possible variations.
      */

    case X (OP_INDEXB, SB):
    case X (OP_INDEXB, SW):
    case X (OP_INDEXB, SL):
    case X (OP_INDEXW, SB):
    case X (OP_INDEXW, SW):
    case X (OP_INDEXW, SL):
    case X (OP_INDEXL, SB):
    case X (OP_INDEXL, SW):
    case X (OP_INDEXL, SL):
      t = GET_L_REG (rn);
      switch (OP_KIND (arg->type)) {
      case OP_INDEXB:	t &= 0xff;	break;
      case OP_INDEXW:	t &= 0xffff;	break;
      case OP_INDEXL:
      default:		break;
      }
      switch (OP_SIZE (arg->type)) {
      case SB:
	SET_MEMORY_B ((t * 1 + abs) & h8_get_mask (sd), n);
	break;
      case SW:
	SET_MEMORY_W ((t * 2 + abs) & h8_get_mask (sd), n);
	break;
      case SL:
	SET_MEMORY_L ((t * 4 + abs) & h8_get_mask (sd), n);
	break;
      }
      break;

    case X (OP_REG, SB):	/* Register direct, byte.  */
      SET_B_REG (rn, n);
      break;
    case X (OP_REG, SW):	/* Register direct, word.  */
      SET_W_REG (rn, n);
      break;
    case X (OP_REG, SL):	/* Register direct, long.  */
      SET_L_REG (rn, n);
      break;

    case X (OP_PREDEC, SB):	/* Register indirect w/pre-decr, byte.  */
      t = GET_L_REG (rn);
      if (!twice)
	t -= 1;
      t &= h8_get_mask (sd);
      SET_L_REG (rn, t);
      SET_MEMORY_B (t, n);

      break;
    case X (OP_PREDEC, SW):	/* Register indirect w/pre-decr, word.  */
      t = GET_L_REG (rn);
      if (!twice)
	t -= 2;
      t &= h8_get_mask (sd);
      SET_L_REG (rn, t);
      SET_MEMORY_W (t, n);
      break;

    case X (OP_PREDEC, SL):	/* Register indirect w/pre-decr, long.  */
      t = GET_L_REG (rn);
      if (!twice)
	t -= 4;
      t &= h8_get_mask (sd);
      SET_L_REG (rn, t);
      SET_MEMORY_L (t, n);
      break;

    case X (OP_PREINC, SB):	/* Register indirect w/pre-incr, byte.  */
      t = GET_L_REG (rn);
      if (!twice)
	t += 1;
      t &= h8_get_mask (sd);
      SET_L_REG (rn, t);
      SET_MEMORY_B (t, n);

      break;
    case X (OP_PREINC, SW):	/* Register indirect w/pre-incr, word.  */
      t = GET_L_REG (rn);
      if (!twice)
	t += 2;
      t &= h8_get_mask (sd);
      SET_L_REG (rn, t);
      SET_MEMORY_W (t, n);
      break;

    case X (OP_PREINC, SL):	/* Register indirect w/pre-incr, long.  */
      t = GET_L_REG (rn);
      if (!twice)
	t += 4;
      t &= h8_get_mask (sd);
      SET_L_REG (rn, t);
      SET_MEMORY_L (t, n);
      break;

    case X (OP_POSTDEC, SB):	/* Register indirect w/post-decr, byte.  */
      t = GET_L_REG (rn) & h8_get_mask (sd);
      SET_MEMORY_B (t, n);
      SET_L_REG (rn, t - 1);
      break;

    case X (OP_POSTDEC, SW):	/* Register indirect w/post-decr, word.  */
      t = GET_L_REG (rn) & h8_get_mask (sd);
      SET_MEMORY_W (t, n);
      SET_L_REG (rn, t - 2);
      break;

    case X (OP_POSTDEC, SL):	/* Register indirect w/post-decr, long.  */
      t = GET_L_REG (rn) & h8_get_mask (sd);
      SET_MEMORY_L (t, n);
      SET_L_REG (rn, t - 4);
      break;

    case X (OP_POSTINC, SB):	/* Register indirect w/post-incr, byte.  */
      t = GET_L_REG (rn) & h8_get_mask (sd);
      SET_MEMORY_B (t, n);
      SET_L_REG (rn, t + 1);
      break;

    case X (OP_POSTINC, SW):	/* Register indirect w/post-incr, word.  */
      t = GET_L_REG (rn) & h8_get_mask (sd);
      SET_MEMORY_W (t, n);
      SET_L_REG (rn, t + 2);
      break;

    case X (OP_POSTINC, SL):	/* Register indirect w/post-incr, long.  */
      t = GET_L_REG (rn) & h8_get_mask (sd);
      SET_MEMORY_L (t, n);
      SET_L_REG (rn, t + 4);
      break;

    case X (OP_DISP, SB):	/* Register indirect w/displacement, byte.  */
      t = GET_L_REG (rn) + abs;
      t &= h8_get_mask (sd);
      SET_MEMORY_B (t, n);
      break;

    case X (OP_DISP, SW):	/* Register indirect w/displacement, word.  */
      t = GET_L_REG (rn) + abs;
      t &= h8_get_mask (sd);
      SET_MEMORY_W (t, n);
      break;

    case X (OP_DISP, SL):	/* Register indirect w/displacement, long.  */
      t = GET_L_REG (rn) + abs;
      t &= h8_get_mask (sd);
      SET_MEMORY_L (t, n);
      break;


    case X (OP_MEM, SB):	/* Why isn't this implemented?  */
    case X (OP_MEM, SW):	/* Why isn't this implemented?  */
    case X (OP_MEM, SL):	/* Why isn't this implemented?  */
    default:
      sim_engine_set_run_state (sd, sim_stopped, SIGSEGV);
      return -1;
    }
  return 0;
}

/* Normal store.  */

static int
store (SIM_DESC sd, ea_type *arg, int n)
{
  return store_1 (sd, arg, n, 0);
}

/* Store which follows a fetch from the same location.
   The difference being that we don't want to do a pre-increment
   or pre-decrement at this time: it was already done when we fetched.  */

static int
store2 (SIM_DESC sd, ea_type *arg, int n)
{
  return store_1 (sd, arg, n, 1);
}

static union
{
  short int i;
  struct
    {
      char low;
      char high;
    }
  u;
} littleendian;

/* Flag to be set whenever a new SIM_DESC object is created.  */
static int init_pointers_needed = 1;

static void
init_pointers (SIM_DESC sd)
{
  if (init_pointers_needed)
    {
      int i;

      littleendian.i = 1;

      if (h8300smode)
	memory_size = H8300S_MSIZE;
      else if (h8300hmode)
	memory_size = H8300H_MSIZE;
      else
	memory_size = H8300_MSIZE;
      /* `msize' must be a power of two.  */
      if ((memory_size & (memory_size - 1)) != 0)
	{
	  (*sim_callback->printf_filtered) 
	    (sim_callback,
	     "init_pointers: bad memory size %d, defaulting to %d.\n", 
	     memory_size, memory_size = H8300S_MSIZE);
	}

      if (h8_get_memory_buf (sd))
	free (h8_get_memory_buf (sd));
      if (h8_get_cache_idx_buf (sd))
	free (h8_get_cache_idx_buf (sd));
      if (h8_get_eightbit_buf (sd))
	free (h8_get_eightbit_buf (sd));

      h8_set_memory_buf (sd, (unsigned char *) 
			 calloc (sizeof (char), memory_size));
      h8_set_cache_idx_buf (sd, (unsigned short *) 
			    calloc (sizeof (short), memory_size));
      sd->memory_size = memory_size;
      h8_set_eightbit_buf (sd, (unsigned char *) calloc (sizeof (char), 256));

      h8_set_mask (sd, memory_size - 1);

      memset (h8_get_reg_buf (sd), 0, sizeof (((STATE_CPU (sd, 0))->regs)));

      for (i = 0; i < 8; i++)
	{
	  /* FIXME: rewrite using local buffer.  */
	  unsigned char *p = (unsigned char *) (h8_get_reg_buf (sd) + i);
	  unsigned char *e = (unsigned char *) (h8_get_reg_buf (sd) + i + 1);
	  unsigned short *q = (unsigned short *) (h8_get_reg_buf (sd) + i);
	  unsigned short *u = (unsigned short *) (h8_get_reg_buf (sd) + i + 1);
	  h8_set_reg (sd, i, 0x00112233);

	  while (p < e)
	    {
	      if (*p == 0x22)
		  breg[i] = p;
	      if (*p == 0x33)
		  breg[i + 8] = p;
	      if (*p == 0x11)
		breg[i + 16] = p;
	      if (*p == 0x00)
		breg[i + 24] = p;
	      p++;
	    }

	  wreg[i] = wreg[i + 8] = 0;
	  while (q < u)
	    {
	      if (*q == 0x2233)
		{
		  wreg[i] = q;
		}
	      if (*q == 0x0011)
		{
		  wreg[i + 8] = q;
		}
	      q++;
	    }

	  if (wreg[i] == 0 || wreg[i + 8] == 0)
	    (*sim_callback->printf_filtered) (sim_callback, 
					      "init_pointers: internal error.\n");

	  h8_set_reg (sd, i, 0);
	  lreg[i] = h8_get_reg_buf (sd) + i;
	}

      /* Note: sim uses pseudo-register ZERO as a zero register.  */
      lreg[ZERO_REGNUM] = h8_get_reg_buf (sd) + ZERO_REGNUM;
      init_pointers_needed = 0;

      /* Initialize the seg registers.  */
      if (!sd->sim_cache)
	set_simcache_size (sd, CSIZE);
    }
}

/* Grotty global variable for use by control_c signal handler.  */
static SIM_DESC control_c_sim_desc;

static void
control_c (int sig)
{
  sim_engine_set_run_state (control_c_sim_desc, sim_stopped, SIGINT);
}

int
sim_stop (SIM_DESC sd)
{
  /* FIXME: use a real signal value.  */
  sim_engine_set_run_state (sd, sim_stopped, SIGINT);
  return 1;
}

#define OBITOP(name, f, s, op) 			\
case O (name, SB):				\
{						\
  int m, tmp;					\
	 					\
  if (f)					\
    if (fetch (sd, &code->dst, &ea))		\
      goto end;					\
  if (fetch (sd, &code->src, &tmp))		\
    goto end;					\
  m = 1 << tmp;					\
  op;						\
  if (s)					\
    if (store (sd, &code->dst,ea))		\
      goto end;					\
  goto next;					\
}

void
sim_resume (SIM_DESC sd, int step, int siggnal)
{
  static int init1;
  int cycles = 0;
  int insts = 0;
  int tick_start = get_now ();
  void (*prev) ();
  int poll_count = 0;
  int res;
  int tmp;
  int rd;
  int ea;
  int bit;
  int pc;
  int c, nz, v, n, u, h, ui, intMaskBit;
  int trace, intMask;
  int oldmask;
  enum sim_stop reason;
  int sigrc;

  init_pointers (sd);

  control_c_sim_desc = sd;
  prev = signal (SIGINT, control_c);

  if (step)
    {
      sim_engine_set_run_state (sd, sim_stopped, SIGTRAP);
    }
  else
    {
      sim_engine_set_run_state (sd, sim_running, 0);
    }

  pc = h8_get_pc (sd);

  /* The PC should never be odd.  */
  if (pc & 0x1)
    {
      sim_engine_set_run_state (sd, sim_stopped, SIGBUS);
      return;
    }

  /* Get Status Register (flags).  */
  GETSR (sd);

  if (h8300smode)	/* Get exr.  */
    {
      trace = (h8_get_exr (sd) >> 7) & 1;
      intMask = h8_get_exr (sd) & 7;
    }

  oldmask = h8_get_mask (sd);
  if (!h8300hmode)
    h8_set_mask (sd, 0xffff);
  do
    {
      unsigned short cidx;
      decoded_inst *code;

    top:
      cidx = h8_get_cache_idx (sd, pc);
      if (cidx == (unsigned short) -1 ||
	  cidx >= sd->sim_cache_size)
	goto illegal;
	  
      code = sd->sim_cache + cidx;

#if ADEBUG
      if (debug)
	{
	  printf ("%x %d %s\n", pc, code->opcode,
		  code->op ? code->op->name : "**");
	}
      h8_increment_stats (sd, code->opcode);
#endif

      if (code->opcode)
	{
	  cycles += code->cycles;
	  insts++;
	}

      switch (code->opcode)
	{
	case 0:
	  /*
	   * This opcode is a fake for when we get to an
	   * instruction which hasnt been compiled
	   */
	  compile (sd, pc);
	  goto top;
	  break;

	case O (O_MOVAB, SL):
	case O (O_MOVAW, SL):
	case O (O_MOVAL, SL):
	  /* 1) Evaluate 2nd argument (dst).
	     2) Mask / zero extend according to whether 1st argument (src)
	        is INDEXB, INDEXW, or INDEXL.
	     3) Left-shift the result by 0, 1 or 2, according to size of mova
	        (mova/b, mova/w, mova/l).
	     4) Add literal value of 1st argument (src).
	     5) Store result in 3rd argument (op3).

	  */
	  if (fetch (sd, &code->dst, &ea))
	    goto end;

	  switch (OP_KIND (code->src.type)) {
	  case OP_INDEXB:    ea = ea & 0xff;		break;
	  case OP_INDEXW:    ea = ea & 0xffff;		break;
	  case OP_INDEXL:    				break;
	  default:	     goto illegal;
	  }

	  switch (code->opcode) {
	  case O (O_MOVAB, SL):	    			break;
	  case O (O_MOVAW, SL):	    ea = ea << 1;	break;
	  case O (O_MOVAL, SL):     ea = ea << 2;	break;
	  default: 		    goto illegal;
	  }
	  
	  ea = ea + code->src.literal;

	  if (store (sd, &code->op3, ea))
	    goto end;

	  goto next;	  

	case O (O_SUBX, SB):	/* subx, extended sub */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = -(ea + C);
	  res = rd + ea;
	  goto alu8;

	case O (O_SUBX, SW):	/* subx, extended sub */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = -(ea + C);
	  res = rd + ea;
	  goto alu16;

	case O (O_SUBX, SL):	/* subx, extended sub */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = -(ea + C);
	  res = rd + ea;
	  goto alu32;

	case O (O_ADDX, SB):	/* addx, extended add */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = ea + C;
	  res = rd + ea;
	  goto alu8;

	case O (O_ADDX, SW):	/* addx, extended add */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = ea + C;
	  res = rd + ea;
	  goto alu16;

	case O (O_ADDX, SL):	/* addx, extended add */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = ea + C;
	  res = rd + ea;
	  goto alu32;

	case O (O_SUB, SB):		/* sub.b */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  ea = -ea;
	  res = rd + ea;
	  goto alu8;

	case O (O_SUB, SW):		/* sub.w */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  ea = -ea;
	  res = rd + ea;
	  goto alu16;

	case O (O_SUB, SL):		/* sub.l */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  ea = -ea;
	  res = rd + ea;
	  goto alu32;

	case O (O_NEG, SB):		/* neg.b */
	  /* Fetch ea.  */
	  if (fetch2 (sd, &code->src, &ea)) 
	    goto end;
	  ea = -ea;
	  rd = 0;
	  res = rd + ea;
	  goto alu8;

	case O (O_NEG, SW):		/* neg.w */
	  /* Fetch ea.  */
	  if (fetch2 (sd, &code->src, &ea)) 
	    goto end;
	  ea = -ea;
	  rd = 0;
	  res = rd + ea;
	  goto alu16;

	case O (O_NEG, SL):		/* neg.l */
	  /* Fetch ea.  */
	  if (fetch2 (sd, &code->src, &ea)) 
	    goto end;
	  ea = -ea;
	  rd = 0;
	  res = rd + ea;
	  goto alu32;

	case O (O_ADD, SB):		/* add.b */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  res = rd + ea;
	  goto alu8;

	case O (O_ADD, SW):		/* add.w */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  res = rd + ea;
	  goto alu16;

	case O (O_ADD, SL):		/* add.l */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  res = rd + ea;
	  goto alu32;

	case O (O_AND, SB):		/* and.b */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd & ea;
	  goto log8;

	case O (O_AND, SW):		/* and.w */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd & ea;
	  goto log16;

	case O (O_AND, SL):		/* and.l */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd & ea;
	  goto log32;

	case O (O_OR, SB):		/* or.b */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd | ea;
	  goto log8;

	case O (O_OR, SW):		/* or.w */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd | ea;
	  goto log16;

	case O (O_OR, SL):		/* or.l */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd | ea;
	  goto log32;

	case O (O_XOR, SB):		/* xor.b */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd ^ ea;
	  goto log8;

	case O (O_XOR, SW):		/* xor.w */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd ^ ea;
	  goto log16;

	case O (O_XOR, SL):		/* xor.l */
	  /* Fetch rd and ea.  */
	  if (fetch (sd, &code->src, &ea) || fetch2 (sd, &code->dst, &rd)) 
	    goto end;
	  res = rd ^ ea;
	  goto log32;

	case O (O_MOV, SB):
	  if (fetch (sd, &code->src, &res))
	    goto end;
	  if (store (sd, &code->dst, res))
	    goto end;
	  goto just_flags_log8;
	case O (O_MOV, SW):
	  if (fetch (sd, &code->src, &res))
	    goto end;
	  if (store (sd, &code->dst, res))
	    goto end;
	  goto just_flags_log16;
	case O (O_MOV, SL):
	  if (fetch (sd, &code->src, &res))
	    goto end;
	  if (store (sd, &code->dst, res))
	    goto end;
	  goto just_flags_log32;

	case O (O_MOVMD, SB):		/* movmd.b */
	  ea = GET_W_REG (4);
	  if (ea == 0)
	    ea = 0x10000;

	  while (ea--)
	    {
	      rd = GET_MEMORY_B (GET_L_REG (5));
	      SET_MEMORY_B (GET_L_REG (6), rd);
	      SET_L_REG (5, GET_L_REG (5) + 1);
	      SET_L_REG (6, GET_L_REG (6) + 1);
	      SET_W_REG (4, ea);
	    }
	  goto next;

	case O (O_MOVMD, SW):		/* movmd.w */
	  ea = GET_W_REG (4);
	  if (ea == 0)
	    ea = 0x10000;

	  while (ea--)
	    {
	      rd = GET_MEMORY_W (GET_L_REG (5));
	      SET_MEMORY_W (GET_L_REG (6), rd);
	      SET_L_REG (5, GET_L_REG (5) + 2);
	      SET_L_REG (6, GET_L_REG (6) + 2);
	      SET_W_REG (4, ea);
	    }
	  goto next;

	case O (O_MOVMD, SL):		/* movmd.l */
	  ea = GET_W_REG (4);
	  if (ea == 0)
	    ea = 0x10000;

	  while (ea--)
	    {
	      rd = GET_MEMORY_L (GET_L_REG (5));
	      SET_MEMORY_L (GET_L_REG (6), rd);
	      SET_L_REG (5, GET_L_REG (5) + 4);
	      SET_L_REG (6, GET_L_REG (6) + 4);
	      SET_W_REG (4, ea);
	    }
	  goto next;

	case O (O_MOVSD, SB):		/* movsd.b */
	  /* This instruction implements strncpy, with a conditional branch.
	     r4 contains n, r5 contains src, and r6 contains dst.
	     The 16-bit displacement operand is added to the pc
	     if and only if the end of string is reached before
	     n bytes are transferred.  */

	  ea = GET_L_REG (4) & 0xffff;
	  if (ea == 0)
	    ea = 0x10000;

	  while (ea--)
	    {
	      rd = GET_MEMORY_B (GET_L_REG (5));
	      SET_MEMORY_B (GET_L_REG (6), rd);
	      SET_L_REG (5, GET_L_REG (5) + 1);
	      SET_L_REG (6, GET_L_REG (6) + 1);
	      SET_W_REG (4, ea); 
	      if (rd == 0)
		goto condtrue;
	    }
	  goto next;

	case O (O_EEPMOV, SB):		/* eepmov.b */
	case O (O_EEPMOV, SW):		/* eepmov.w */
	  if (h8300hmode || h8300smode)
	    {
	      register unsigned char *_src, *_dst;
	      unsigned int count = ((code->opcode == O (O_EEPMOV, SW))
				    ? h8_get_reg (sd, R4_REGNUM) & 0xffff
				    : h8_get_reg (sd, R4_REGNUM) & 0xff);

	      _src = (h8_get_reg (sd, R5_REGNUM) < memory_size
		      ? h8_get_memory_buf   (sd) + h8_get_reg (sd, R5_REGNUM)
		      : h8_get_eightbit_buf (sd) + 
		       (h8_get_reg (sd, R5_REGNUM) & 0xff));
	      if ((_src + count) >= (h8_get_memory_buf (sd) + memory_size))
		{
		  if ((_src + count) >= (h8_get_eightbit_buf (sd) + 0x100))
		    goto illegal;
		}
	      _dst = (h8_get_reg (sd, R6_REGNUM) < memory_size
		      ? h8_get_memory_buf   (sd) + h8_get_reg (sd, R6_REGNUM)
		      : h8_get_eightbit_buf (sd) + 
		       (h8_get_reg (sd, R6_REGNUM) & 0xff));

	      if ((_dst + count) >= (h8_get_memory_buf (sd) + memory_size))
		{
		  if ((_dst + count) >= (h8_get_eightbit_buf (sd) + 0x100))
		    goto illegal;
		}
	      memcpy (_dst, _src, count);

	      h8_set_reg (sd, R5_REGNUM, h8_get_reg (sd, R5_REGNUM) + count);
	      h8_set_reg (sd, R6_REGNUM, h8_get_reg (sd, R6_REGNUM) + count);
	      h8_set_reg (sd, R4_REGNUM, h8_get_reg (sd, R4_REGNUM) &
			  ((code->opcode == O (O_EEPMOV, SW))
			  ? (~0xffff) : (~0xff)));
	      cycles += 2 * count;
	      goto next;
	    }
	  goto illegal;

	case O (O_ADDS, SL):		/* adds (.l) */
	  /* FIXME fetch.
	   * This insn only uses register operands, but still
	   * it would be cleaner to use fetch and store...  */	  
	  SET_L_REG (code->dst.reg,
		     GET_L_REG (code->dst.reg)
		     + code->src.literal);

	  goto next;

	case O (O_SUBS, SL):		/* subs (.l) */
	  /* FIXME fetch.
	   * This insn only uses register operands, but still
	   * it would be cleaner to use fetch and store...  */	  
	  SET_L_REG (code->dst.reg,
		     GET_L_REG (code->dst.reg)
		     - code->src.literal);
	  goto next;

	case O (O_CMP, SB):		/* cmp.b */
	  if (fetch (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = -ea;
	  res = rd + ea;
	  goto just_flags_alu8;

	case O (O_CMP, SW):		/* cmp.w */
	  if (fetch (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = -ea;
	  res = rd + ea;
	  goto just_flags_alu16;

	case O (O_CMP, SL):		/* cmp.l */
	  if (fetch (sd, &code->dst, &rd))
	    goto end;
	  if (fetch (sd, &code->src, &ea))
	    goto end;
	  ea = -ea;
	  res = rd + ea;
	  goto just_flags_alu32;

	case O (O_DEC, SB):		/* dec.b */
	  /* FIXME fetch.
	   * This insn only uses register operands, but still
	   * it would be cleaner to use fetch and store...  */	  
	  rd = GET_B_REG (code->src.reg);
	  ea = -1;
	  res = rd + ea;
	  SET_B_REG (code->src.reg, res);
	  goto just_flags_inc8;

	case O (O_DEC, SW):		/* dec.w */
	  /* FIXME fetch.
	   * This insn only uses register operands, but still
	   * it would be cleaner to use fetch and store...  */	  
	  rd = GET_W_REG (code->dst.reg);
	  ea = -code->src.literal;
	  res = rd + ea;
	  SET_W_REG (code->dst.reg, res);
	  goto just_flags_inc16;

	case O (O_DEC, SL):		/* dec.l */
	  /* FIXME fetch.
	   * This insn only uses register operands, but still
	   * it would be cleaner to use fetch and store...  */	  
	  rd = GET_L_REG (code->dst.reg);
	  ea = -code->src.literal;
	  res = rd + ea;
	  SET_L_REG (code->dst.reg, res);
	  goto just_flags_inc32;

	case O (O_INC, SB):		/* inc.b */
	  /* FIXME fetch.
	   * This insn only uses register operands, but still
	   * it would be cleaner to use fetch and store...  */	  
	  rd = GET_B_REG (code->src.reg);
	  ea = 1;
	  res = rd + ea;
	  SET_B_REG (code->src.reg, res);
	  goto just_flags_inc8;

	case O (O_INC, SW):		/* inc.w */
	  /* FIXME fetch.
	   * This insn only uses register operands, but still
	   * it would be cleaner to use fetch and store...  */	  
	  rd = GET_W_REG (code->dst.reg);
	  ea = code->src.literal;
	  res = rd + ea;
	  SET_W_REG (code->dst.reg, res);
	  goto just_flags_inc16;

	case O (O_INC, SL):		/* inc.l */
	  /* FIXME fetch.
	   * This insn only uses register operands, but still
	   * it would be cleaner to use fetch and store...  */	  
	  rd = GET_L_REG (code->dst.reg);
	  ea = code->src.literal;
	  res = rd + ea;
	  SET_L_REG (code->dst.reg, res);
	  goto just_flags_inc32;

	case O (O_LDC, SB):		/* ldc.b */
	  if (fetch (sd, &code->src, &res))
	    goto end;
	  goto setc;

	case O (O_LDC, SW):		/* ldc.w */
	  if (fetch (sd, &code->src, &res))
	    goto end;

	  /* Word operand, value from MSB, must be shifted.  */
	  res >>= 8;
	  goto setc;

	case O (O_LDC, SL):		/* ldc.l */
	  if (fetch (sd, &code->src, &res))
	    goto end;
	  switch (code->dst.type) {
	  case X (OP_SBR, SL):
	    h8_set_sbr (sd, res);
	    break;
	  case X (OP_VBR, SL):
	    h8_set_vbr (sd, res);
	    break;
	  default:
	    goto illegal;
	  }
	  goto next;

	case O (O_STC, SW):		/* stc.w */
	case O (O_STC, SB):		/* stc.b */
	  if (code->src.type == X (OP_CCR, SB))
	    {
	      BUILDSR (sd);
	      res = h8_get_ccr (sd);
	    }
	  else if (code->src.type == X (OP_EXR, SB) && h8300smode)
	    {
	      if (h8300smode)
		h8_set_exr (sd, (trace << 7) | intMask);
	      res = h8_get_exr (sd);
	    }
	  else
	    goto illegal;

	  /* Word operand, value to MSB, must be shifted.  */
	  if (code->opcode == X (O_STC, SW))
	    res <<= 8;
	  if (store (sd, &code->dst, res))
	    goto end;
	  goto next;
	case O (O_STC, SL):		/* stc.l */
	  switch (code->src.type) {
	  case X (OP_SBR, SL):
	    res = h8_get_sbr (sd);
	    break;
	  case X (OP_VBR, SL):
	    res = h8_get_vbr (sd);
	    break;
	  default:
	    goto illegal;
	  }
	  if (store (sd, &code->dst, res))
	    goto end;
	  goto next;

	case O (O_ANDC, SB):		/* andc.b */
	  if (code->dst.type == X (OP_CCR, SB))
	    {
	      BUILDSR (sd);
	      rd = h8_get_ccr (sd);
	    }
	  else if (code->dst.type == X (OP_EXR, SB) && h8300smode)
	    {
	      if (h8300smode)
		h8_set_exr (sd, (trace << 7) | intMask);
	      res = h8_get_exr (sd);
	    }
	  else
	    goto illegal;
	  ea = code->src.literal;
	  res = rd & ea;
	  goto setc;

	case O (O_ORC, SB):		/* orc.b */
	  if (code->dst.type == X (OP_CCR, SB))
	    {
	      BUILDSR (sd);
	      rd = h8_get_ccr (sd);
	    }
	  else if (code->dst.type == X (OP_EXR, SB) && h8300smode)
	    {
	      if (h8300smode)
		h8_set_exr (sd, (trace << 7) | intMask);
	      rd = h8_get_exr (sd);
	    }
	  else
	    goto illegal;
	  ea = code->src.literal;
	  res = rd | ea;
	  goto setc;

	case O (O_XORC, SB):		/* xorc.b */
	  if (code->dst.type == X (OP_CCR, SB))
	    {
	      BUILDSR (sd);
	      rd = h8_get_ccr (sd);
	    }
	  else if (code->dst.type == X (OP_EXR, SB) && h8300smode)
	    {
	      if (h8300smode)
		h8_set_exr (sd, (trace << 7) | intMask);
	      rd = h8_get_exr (sd);
	    }
	  else
	    goto illegal;
	  ea = code->src.literal;
	  res = rd ^ ea;
	  goto setc;

	case O (O_BRAS, SB):		/* bra/s  */
	  /* This is basically an ordinary branch, with a delay slot.  */
	  if (fetch (sd, &code->src, &res))
	    goto end;

	  if ((res & 1) == 0)
	    goto illegal;

	  res -= 1;

	  /* Execution continues at next instruction, but
	     delayed_branch is set up for next cycle.  */
	  h8_set_delayed_branch (sd, code->next_pc + res);
	  pc = code->next_pc;
	  goto end;

	case O (O_BRAB, SB):		/* bra rd.b */
	case O (O_BRAW, SW):		/* bra rd.w */
	case O (O_BRAL, SL):		/* bra erd.l */
	  if (fetch (sd, &code->src, &rd))
	    goto end;
	  switch (OP_SIZE (code->opcode)) {
	  case SB:	rd &= 0xff;		break;
	  case SW:	rd &= 0xffff;		break;
	  case SL:	rd &= 0xffffffff;	break;
	  }
	  pc = code->next_pc + rd;
	  goto end;

	case O (O_BRABC, SB):		/* bra/bc, branch if bit clear */
	case O (O_BRABS, SB):		/* bra/bs, branch if bit set   */
	case O (O_BSRBC, SB):		/* bsr/bc, call   if bit clear */
	case O (O_BSRBS, SB):		/* bsr/bs, call   if bit set   */
	  if (fetch (sd, &code->dst, &rd) ||
	      fetch (sd, &code->src, &bit))
	    goto end;

	  if (code->opcode == O (O_BRABC, SB) || /* branch if clear */
	      code->opcode == O (O_BSRBC, SB))	 /* call   if clear */
	    {
	      if ((rd & (1 << bit)))		/* no branch */
		goto next;
	    }
	  else					/* branch/call if set */
	    {
	      if (!(rd & (1 << bit)))		/* no branch */
		goto next;
	    }

	  if (fetch (sd, &code->op3, &res))	/* branch */
	    goto end;
	  pc = code->next_pc + res;

	  if (code->opcode == O (O_BRABC, SB) ||
	      code->opcode == O (O_BRABS, SB))	/* branch */
	    goto end;
	  else					/* call   */
	    goto call;

	case O (O_BRA, SN):
	case O (O_BRA, SL):
	case O (O_BRA, SW):
	case O (O_BRA, SB):		/* bra, branch always */
	  if (1)
	    goto condtrue;
	  goto next;

	case O (O_BRN, SB):		/* brn, ;-/  branch never? */
	  if (0)
	    goto condtrue;
	  goto next;

	case O (O_BHI, SB):		/* bhi */
	  if ((C || Z) == 0)
	    goto condtrue;
	  goto next;


	case O (O_BLS, SB):		/* bls */
	  if ((C || Z))
	    goto condtrue;
	  goto next;

	case O (O_BCS, SB):		/* bcs, branch if carry set */
	  if ((C == 1))
	    goto condtrue;
	  goto next;

	case O (O_BCC, SB):		/* bcc, branch if carry clear */
	  if ((C == 0))
	    goto condtrue;
	  goto next;

	case O (O_BEQ, SB):		/* beq, branch if zero set */
	  if (Z)
	    goto condtrue;
	  goto next;
	case O (O_BGT, SB):		/* bgt */
	  if (((Z || (N ^ V)) == 0))
	    goto condtrue;
	  goto next;

	case O (O_BLE, SB):		/* ble */
	  if (((Z || (N ^ V)) == 1))
	    goto condtrue;
	  goto next;

	case O (O_BGE, SB):		/* bge */
	  if ((N ^ V) == 0)
	    goto condtrue;
	  goto next;
	case O (O_BLT, SB):		/* blt */
	  if ((N ^ V))
	    goto condtrue;
	  goto next;
	case O (O_BMI, SB):		/* bmi */
	  if ((N))
	    goto condtrue;
	  goto next;
	case O (O_BNE, SB):		/* bne, branch if zero clear */
	  if ((Z == 0))
	    goto condtrue;
	  goto next;

	case O (O_BPL, SB):		/* bpl */
	  if (N == 0)
	    goto condtrue;
	  goto next;
	case O (O_BVC, SB):		/* bvc */
	  if ((V == 0))
	    goto condtrue;
	  goto next;
	case O (O_BVS, SB):		/* bvs */
	  if ((V == 1))
	    goto condtrue;
	  goto next;

	/* Trap for Command Line setup.  */
	case O (O_SYS_CMDLINE, SB):
	  {
	    int i = 0;		/* Loop counter.  */
	    int j = 0;		/* Loop counter.  */
	    int ind_arg_len = 0;	/* Length of each argument.  */
	    int no_of_args = 0;	/* The no. or cmdline args.  */
	    int current_location = 0;	/* Location of string.  */
	    int old_sp = 0;	/* The Initial Stack Pointer.  */
	    int no_of_slots = 0;	/* No. of slots required on the stack
					   for storing cmdline args.  */
	    int sp_move = 0;	/* No. of locations by which the stack needs
				   to grow.  */
	    int new_sp = 0;	/* The final stack pointer location passed
				   back.  */
	    int *argv_ptrs;	/* Pointers of argv strings to be stored.  */
	    int argv_ptrs_location = 0;	/* Location of pointers to cmdline
					   args on the stack.  */
	    int char_ptr_size = 0;	/* Size of a character pointer on
					   target machine.  */
	    int addr_cmdline = 0;	/* Memory location where cmdline has
					   to be stored.  */
	    int size_cmdline = 0;	/* Size of cmdline.  */

	    /* Set the address of 256 free locations where command line is
	       stored.  */
	    addr_cmdline = cmdline_location();
	    h8_set_reg (sd, 0, addr_cmdline);

	    /* Counting the no. of commandline arguments.  */
	    for (i = 0; h8_get_cmdline_arg (sd, i) != NULL; i++)
	      continue;

	    /* No. of arguments in the command line.  */
	    no_of_args = i;

	    /* Current location is just a temporary variable,which we are
	       setting to the point to the start of our commandline string.  */
	    current_location = addr_cmdline;

	    /* Allocating space for storing pointers of the command line
	       arguments.  */
	    argv_ptrs = (int *) malloc (sizeof (int) * no_of_args);

	    /* Setting char_ptr_size to the sizeof (char *) on the different
	       architectures.  */
	    if (h8300hmode || h8300smode)
	      {
		char_ptr_size = 4;
	      }
	    else
	      {
		char_ptr_size = 2;
	      }

	    for (i = 0; i < no_of_args; i++)
	      {
		ind_arg_len = 0;

		/* The size of the commandline argument.  */
		ind_arg_len = strlen (h8_get_cmdline_arg (sd, i) + 1);

		/* The total size of the command line string.  */
		size_cmdline += ind_arg_len;

		/* As we have only 256 bytes, we need to provide a graceful
		   exit. Anyways, a program using command line arguments 
		   where we cannot store all the command line arguments
		   given may behave unpredictably.  */
		if (size_cmdline >= 256)
		  {
		    h8_set_reg (sd, 0, 0);
		    goto next;
		  }
		else
		  {
		    /* current_location points to the memory where the next
		       commandline argument is stored.  */
		    argv_ptrs[i] = current_location;
		    for (j = 0; j < ind_arg_len; j++)
		      {
			SET_MEMORY_B ((current_location +
				       (sizeof (char) * j)),
				      *(h8_get_cmdline_arg (sd, i) + 
				       sizeof (char) * j));
		      }

		    /* Setting current_location to the starting of next
		       argument.  */
		    current_location += ind_arg_len;
		  }
	      }

	    /* This is the original position of the stack pointer.  */
	    old_sp = h8_get_reg (sd, SP_REGNUM);

	    /* We need space from the stack to store the pointers to argvs.  */
	    /* As we will infringe on the stack, we need to shift the stack
	       pointer so that the data is not overwritten. We calculate how
	       much space is required.  */
	    sp_move = (no_of_args) * (char_ptr_size);

	    /* The final position of stack pointer, we have thus taken some
	       space from the stack.  */
	    new_sp = old_sp - sp_move;

	    /* Temporary variable holding value where the argv pointers need
	       to be stored.  */
	    argv_ptrs_location = new_sp;

	    /* The argv pointers are stored at sequential locations. As per
	       the H8300 ABI.  */
	    for (i = 0; i < no_of_args; i++)
	      {
		/* Saving the argv pointer.  */
		if (h8300hmode || h8300smode)
		  {
		    SET_MEMORY_L (argv_ptrs_location, argv_ptrs[i]);
		  }
		else
		  {
		    SET_MEMORY_W (argv_ptrs_location, argv_ptrs[i]);
		  }
	
		/* The next location where the pointer to the next argv
		   string has to be stored.  */    
		argv_ptrs_location += char_ptr_size;
	      }

	    /* Required by POSIX, Setting 0x0 at the end of the list of argv
	       pointers.  */
	    if (h8300hmode || h8300smode)
	      {
		SET_MEMORY_L (old_sp, 0x0);
	      }
	    else
	      {
		SET_MEMORY_W (old_sp, 0x0);
	      }

	    /* Freeing allocated memory.  */
	    free (argv_ptrs);
	    for (i = 0; i <= no_of_args; i++)
	      {
		free (h8_get_cmdline_arg (sd, i));
	      }
	    free (h8_get_command_line (sd));

	    /* The no. of argv arguments are returned in Reg 0.  */
	    h8_set_reg (sd, 0, no_of_args);
	    /* The Pointer to argv in Register 1.  */
	    h8_set_reg (sd, 1, new_sp);
	    /* Setting the stack pointer to the new value.  */
	    h8_set_reg (sd, SP_REGNUM, new_sp);
	  }
	  goto next;

	  /* System call processing starts.  */
	case O (O_SYS_OPEN, SB):
	  {
	    int len = 0;	/* Length of filename.  */
	    char *filename;	/* Filename would go here.  */
	    char temp_char;	/* Temporary character */
	    int mode = 0;	/* Mode bits for the file.  */
	    int open_return;	/* Return value of open, file descriptor.  */
	    int i;		/* Loop counter */
	    int filename_ptr;	/* Pointer to filename in cpu memory.  */

	    /* Setting filename_ptr to first argument of open,  */
	    /* and trying to get mode.  */
	    if (h8300sxmode || h8300hmode || h8300smode)
	      {
		filename_ptr = GET_L_REG (0);
		mode = GET_MEMORY_L (h8_get_reg (sd, SP_REGNUM) + 4);
	      }
	    else
	      {
		filename_ptr = GET_W_REG (0);
		mode = GET_MEMORY_W (h8_get_reg (sd, SP_REGNUM) + 2);
	      }

	    /* Trying to find the length of the filename.  */
	    temp_char = GET_MEMORY_B (h8_get_reg (sd, 0));

	    len = 1;
	    while (temp_char != '\0')
	      {
		temp_char = GET_MEMORY_B (filename_ptr + len);
		len++;
	      }

	    /* Allocating space for the filename.  */
	    filename = (char *) malloc (sizeof (char) * len);

	    /* String copying the filename from memory.  */
	    for (i = 0; i < len; i++)
	      {
		temp_char = GET_MEMORY_B (filename_ptr + i);
		filename[i] = temp_char;
	      }

	    /* Callback to open and return the file descriptor.  */
	    open_return = sim_callback->open (sim_callback, filename, mode);

	    /* Return value in register 0.  */
	    h8_set_reg (sd, 0, open_return);

	    /* Freeing memory used for filename. */
	    free (filename);
	  }
	  goto next;

	case O (O_SYS_READ, SB):
	  {
	    char *char_ptr;	/* Where characters read would be stored.  */
	    int fd;		/* File descriptor */
	    int buf_size;	/* BUF_SIZE parameter in read.  */
	    int i = 0;		/* Temporary Loop counter */
	    int read_return = 0;	/* Return value from callback to
					   read.  */

	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);
	    buf_size = h8300hmode ? GET_L_REG (2) : GET_W_REG (2);

	    char_ptr = (char *) malloc (sizeof (char) * buf_size);

	    /* Callback to read and return the no. of characters read.  */
	    read_return =
	      sim_callback->read (sim_callback, fd, char_ptr, buf_size);

	    /* The characters read are stored in cpu memory.  */
	    for (i = 0; i < buf_size; i++)
	      {
		SET_MEMORY_B ((h8_get_reg (sd, 1) + (sizeof (char) * i)),
			      *(char_ptr + (sizeof (char) * i)));
	      }

	    /* Return value in Register 0.  */
	    h8_set_reg (sd, 0, read_return);

	    /* Freeing memory used as buffer.  */
	    free (char_ptr);
	  }
	  goto next;

	case O (O_SYS_WRITE, SB):
	  {
	    int fd;		/* File descriptor */
	    char temp_char;	/* Temporary character */
	    int len;		/* Length of write, Parameter II to write.  */
	    int char_ptr;	/* Character Pointer, Parameter I of write.  */
	    char *ptr;		/* Where characters to be written are stored. 
				 */
	    int write_return;	/* Return value from callback to write.  */
	    int i = 0;		/* Loop counter */

	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);
	    char_ptr = h8300hmode ? GET_L_REG (1) : GET_W_REG (1);
	    len = h8300hmode ? GET_L_REG (2) : GET_W_REG (2);

	    /* Allocating space for the characters to be written.  */
	    ptr = (char *) malloc (sizeof (char) * len);

	    /* Fetching the characters from cpu memory.  */
	    for (i = 0; i < len; i++)
	      {
		temp_char = GET_MEMORY_B (char_ptr + i);
		ptr[i] = temp_char;
	      }

	    /* Callback write and return the no. of characters written.  */
	    write_return = sim_callback->write (sim_callback, fd, ptr, len);

	    /* Return value in Register 0.  */
	    h8_set_reg (sd, 0, write_return);

	    /* Freeing memory used as buffer.  */
	    free (ptr);
	  }
	  goto next;

	case O (O_SYS_LSEEK, SB):
	  {
	    int fd;		/* File descriptor */
	    int offset;		/* Offset */
	    int origin;		/* Origin */
	    int lseek_return;	/* Return value from callback to lseek.  */

	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);
	    offset = h8300hmode ? GET_L_REG (1) : GET_W_REG (1);
	    origin = h8300hmode ? GET_L_REG (2) : GET_W_REG (2);

	    /* Callback lseek and return offset.  */
	    lseek_return =
	      sim_callback->lseek (sim_callback, fd, offset, origin);

	    /* Return value in register 0.  */
	    h8_set_reg (sd, 0, lseek_return);
	  }
	  goto next;

	case O (O_SYS_CLOSE, SB):
	  {
	    int fd;		/* File descriptor */
	    int close_return;	/* Return value from callback to close.  */

	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);

	    /* Callback close and return.  */
	    close_return = sim_callback->close (sim_callback, fd);

	    /* Return value in register 0.  */
	    h8_set_reg (sd, 0, close_return);
	  }
	  goto next;

	case O (O_SYS_FSTAT, SB):
	  {
	    int fd;		/* File descriptor */
	    struct stat stat_rec;	/* Stat record */
	    int fstat_return;	/* Return value from callback to stat.  */
	    int stat_ptr;	/* Pointer to stat record.  */
	    char *temp_stat_ptr;	/* Temporary stat_rec pointer.  */

	    fd = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);

	    /* Setting stat_ptr to second argument of stat.  */
	    stat_ptr = h8300hmode ? GET_L_REG (1) : GET_W_REG (1);

	    /* Callback stat and return.  */
	    fstat_return = sim_callback->fstat (sim_callback, fd, &stat_rec);

	    /* Have stat_ptr point to starting of stat_rec.  */
	    temp_stat_ptr = (char *) (&stat_rec);

	    /* Setting up the stat structure returned.  */
	    SET_MEMORY_W (stat_ptr, stat_rec.st_dev);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_ino);
	    stat_ptr += 2;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_mode);
	    stat_ptr += 4;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_nlink);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_uid);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_gid);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_rdev);
	    stat_ptr += 2;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_size);
	    stat_ptr += 4;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_atime);
	    stat_ptr += 8;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_mtime);
	    stat_ptr += 8;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_ctime);

	    /* Return value in register 0.  */
	    h8_set_reg (sd, 0, fstat_return);
	  }
	  goto next;

	case O (O_SYS_STAT, SB):
	  {
	    int len = 0;	/* Length of filename.  */
	    char *filename;	/* Filename would go here.  */
	    char temp_char;	/* Temporary character */
	    int filename_ptr;	/* Pointer to filename in cpu memory.  */
	    struct stat stat_rec;	/* Stat record */
	    int stat_return;	/* Return value from callback to stat */
	    int stat_ptr;	/* Pointer to stat record.  */
	    char *temp_stat_ptr;	/* Temporary stat_rec pointer.  */
	    int i = 0;		/* Loop Counter */
d956 10
a965 2
	    /* Setting filename_ptr to first argument of open.  */
	    filename_ptr = h8300hmode ? GET_L_REG (0) : GET_W_REG (0);
d967 7
a973 2
	    /* Trying to find the length of the filename.  */
	    temp_char = GET_MEMORY_B (h8_get_reg (sd, 0));
d975 21
a995 6
	    len = 1;
	    while (temp_char != '\0')
	      {
		temp_char = GET_MEMORY_B (filename_ptr + len);
		len++;
	      }
d997 19
a1015 2
	    /* Allocating space for the filename.  */
	    filename = (char *) malloc (sizeof (char) * len);
d1017 1
a1017 6
	    /* String copying the filename from memory.  */
	    for (i = 0; i < len; i++)
	      {
		temp_char = GET_MEMORY_B (filename_ptr + i);
		filename[i] = temp_char;
	      }
d1019 10
a1028 3
	    /* Setting stat_ptr to second argument of stat.  */
	    /* stat_ptr = h8_get_reg (sd, 1); */
	    stat_ptr = h8300hmode ? GET_L_REG (1) : GET_W_REG (1);
d1030 1
a1030 3
	    /* Callback stat and return.  */
	    stat_return =
	      sim_callback->stat (sim_callback, filename, &stat_rec);
d1032 3
a1034 34
	    /* Have stat_ptr point to starting of stat_rec.  */
	    temp_stat_ptr = (char *) (&stat_rec);
 
	    /* Freeing memory used for filename.  */
	    free (filename);
 
	    /* Setting up the stat structure returned.  */
	    SET_MEMORY_W (stat_ptr, stat_rec.st_dev);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_ino);
	    stat_ptr += 2;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_mode);
	    stat_ptr += 4;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_nlink);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_uid);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_gid);
	    stat_ptr += 2;
	    SET_MEMORY_W (stat_ptr, stat_rec.st_rdev);
	    stat_ptr += 2;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_size);
	    stat_ptr += 4;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_atime);
	    stat_ptr += 8;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_mtime);
	    stat_ptr += 8;
	    SET_MEMORY_L (stat_ptr, stat_rec.st_ctime);
 
	    /* Return value in register 0.  */
	    h8_set_reg (sd, 0, stat_return);
	  }
	  goto next;
	  /* End of system call processing.  */
d1036 2
a1037 6
	case O (O_NOT, SB):		/* not.b */
	  if (fetch2 (sd, &code->src, &rd))
	    goto end;
	  rd = ~rd; 
	  v = 0;
	  goto shift8;
d1039 7
a1045 6
	case O (O_NOT, SW):		/* not.w */
	  if (fetch2 (sd, &code->src, &rd))
	    goto end;
	  rd = ~rd; 
	  v = 0;
	  goto shift16;
d1047 3
a1049 11
	case O (O_NOT, SL):		/* not.l */
	  if (fetch2 (sd, &code->src, &rd))
	    goto end;
	  rd = ~rd; 
	  v = 0;
	  goto shift32;

	case O (O_SHLL, SB):	/* shll.b */
	case O (O_SHLR, SB):	/* shlr.b */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
a1050 4
	  if (code->src.type == X (OP_IMM, SB))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;
d1052 4
a1055 13
	  if (code->opcode == O (O_SHLL, SB))
	    {
	      v = (ea > 8);
	      c = rd & (0x80 >> (ea - 1));
	      rd <<= ea;
	    }
	  else
	    {
	      v = 0;
	      c = rd & (1 << (ea - 1));
	      rd = (unsigned char) rd >> ea;
	    }
	  goto shift8;
a1056 4
	case O (O_SHLL, SW):	/* shll.w */
	case O (O_SHLR, SW):	/* shlr.w */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
d1058 4
a1061 4
	  if (code->src.type == X (OP_IMM, SW))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;
a1062 13
	  if (code->opcode == O (O_SHLL, SW))
	    {
	      v = (ea > 16);
	      c = rd & (0x8000 >> (ea - 1));
	      rd <<= ea;
	    }
	  else
	    {
	      v = 0;
	      c = rd & (1 << (ea - 1));
	      rd = (unsigned short) rd >> ea;
	    }
	  goto shift16;
a1063 4
	case O (O_SHLL, SL):	/* shll.l */
	case O (O_SHLR, SL):	/* shlr.l */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
d1065 7
a1071 4
	  if (code->src.type == X (OP_IMM, SL))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;
d1073 1
a1073 13
	  if (code->opcode == O (O_SHLL, SL))
	    {
	      v = (ea > 32);
	      c = rd & (0x80000000 >> (ea - 1));
	      rd <<= ea;
	    }
	  else
	    {
	      v = 0;
	      c = rd & (1 << (ea - 1));
	      rd = (unsigned int) rd >> ea;
	    }
	  goto shift32;
d1075 5
a1079 4
	case O (O_SHAL, SB):
	case O (O_SHAR, SB):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
d1081 10
a1090 4
	  if (code->src.type == X (OP_IMM, SB))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;
a1091 15
	  if (code->opcode == O (O_SHAL, SB))
	    {
	      c = rd & (0x80 >> (ea - 1));
	      res = rd >> (7 - ea);
	      v = ((res & 1) && !(res & 2)) 
		|| (!(res & 1) && (res & 2));
	      rd <<= ea;
	    }
	  else
	    {
	      c = rd & (1 << (ea - 1));
	      v = 0;
	      rd = ((signed char) rd) >> ea;
	    }
	  goto shift8;
d1093 6
a1098 4
	case O (O_SHAL, SW):
	case O (O_SHAR, SW):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
d1100 6
a1105 4
	  if (code->src.type == X (OP_IMM, SW))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;
d1107 2
a1108 15
	  if (code->opcode == O (O_SHAL, SW))
	    {
	      c = rd & (0x8000 >> (ea - 1));
	      res = rd >> (15 - ea);
	      v = ((res & 1) && !(res & 2)) 
		|| (!(res & 1) && (res & 2));
	      rd <<= ea;
	    }
	  else
	    {
	      c = rd & (1 << (ea - 1));
	      v = 0;
	      rd = ((signed short) rd) >> ea;
	    }
	  goto shift16;
d1110 23
a1132 4
	case O (O_SHAL, SL):
	case O (O_SHAR, SL):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
a1133 4
	  if (code->src.type == X (OP_IMM, SL))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;
d1135 2
a1136 15
	  if (code->opcode == O (O_SHAL, SL))
	    {
	      c = rd & (0x80000000 >> (ea - 1));
	      res = rd >> (31 - ea);
	      v = ((res & 1) && !(res & 2)) 
		|| (!(res & 1) && (res & 2));
	      rd <<= ea;
	    }
	  else
	    {
	      c = rd & (1 << (ea - 1));
	      v = 0;
	      rd = ((signed int) rd) >> ea;
	    }
	  goto shift32;
d1138 2
a1139 4
	case O (O_ROTL, SB):
	case O (O_ROTR, SB):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
d1141 2
a1142 4
	  if (code->src.type == X (OP_IMM, SB))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;
a1143 15
	  while (ea--)
	    if (code->opcode == O (O_ROTL, SB))
	      {
		c = rd & 0x80;
		rd <<= 1;
		if (c)
		  rd |= 1;
	      }
	    else
	      {
		c = rd & 1;
		rd = ((unsigned char) rd) >> 1;
		if (c)
		  rd |= 0x80;
	      }
d1145 9
a1153 2
	  v = 0;
	  goto shift8;
a1154 4
	case O (O_ROTL, SW):
	case O (O_ROTR, SW):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
d1156 12
a1167 4
	  if (code->src.type == X (OP_IMM, SW))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;
d1169 8
a1176 15
	  while (ea--)
	    if (code->opcode == O (O_ROTL, SW))
	      {
		c = rd & 0x8000;
		rd <<= 1;
		if (c)
		  rd |= 1;
	      }
	    else
	      {
		c = rd & 1;
		rd = ((unsigned short) rd) >> 1;
		if (c)
		  rd |= 0x8000;
	      }
d1178 17
a1194 2
	  v = 0;
	  goto shift16;
d1196 8
a1203 4
	case O (O_ROTL, SL):
	case O (O_ROTR, SL):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
d1205 4
a1208 4
	  if (code->src.type == X (OP_IMM, SL))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;
d1210 1
a1210 15
	  while (ea--)
	    if (code->opcode == O (O_ROTL, SL))
	      {
		c = rd & 0x80000000;
		rd <<= 1;
		if (c)
		  rd |= 1;
	      }
	    else
	      {
		c = rd & 1;
		rd = ((unsigned int) rd) >> 1;
		if (c)
		  rd |= 0x80000000;
	      }
d1212 5
a1216 2
	  v = 0;
	  goto shift32;
d1218 6
a1223 4
	case O (O_ROTXL, SB):
	case O (O_ROTXR, SB):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
d1225 6
a1230 4
	  if (code->src.type == X (OP_IMM, SB))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;
d1232 6
a1237 17
	  while (ea--)
	    if (code->opcode == O (O_ROTXL, SB))
	      {
		res = rd & 0x80;
		rd <<= 1;
		if (C)
		  rd |= 1;
		c = res;
	      }
	    else
	      {
		res = rd & 1;
		rd = ((unsigned char) rd) >> 1;
		if (C)
		  rd |= 0x80;
		c = res;
	      }
a1238 2
	  v = 0;
	  goto shift8;
d1240 6
a1245 4
	case O (O_ROTXL, SW):
	case O (O_ROTXR, SW):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
d1247 6
a1252 4
	  if (code->src.type == X (OP_IMM, SW))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;
d1254 6
a1259 17
	  while (ea--)
	    if (code->opcode == O (O_ROTXL, SW))
	      {
		res = rd & 0x8000;
		rd <<= 1;
		if (C)
		  rd |= 1;
		c = res;
	      }
	    else
	      {
		res = rd & 1;
		rd = ((unsigned short) rd) >> 1;
		if (C)
		  rd |= 0x8000;
		c = res;
	      }
a1260 2
	  v = 0;
	  goto shift16;
d1262 6
a1267 4
	case O (O_ROTXL, SL):
	case O (O_ROTXR, SL):
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
d1269 6
a1274 4
	  if (code->src.type == X (OP_IMM, SL))
	    fetch (sd, &code->src, &ea);
	  else
	    ea = 1;
d1276 6
a1281 17
	  while (ea--)
	    if (code->opcode == O (O_ROTXL, SL))
	      {
		res = rd & 0x80000000;
		rd <<= 1;
		if (C)
		  rd |= 1;
		c = res;
	      }
	    else
	      {
		res = rd & 1;
		rd = ((unsigned int) rd) >> 1;
		if (C)
		  rd |= 0x80000000;
		c = res;
	      }
d1283 2
a1284 2
	  v = 0;
	  goto shift32;
d1286 7
a1292 17
        case O (O_JMP, SN):
        case O (O_JMP, SL):
        case O (O_JMP, SB):		/* jmp */
        case O (O_JMP, SW):
	  fetch (sd, &code->src, &pc);
	  goto end;

	case O (O_JSR, SN):
	case O (O_JSR, SL):
	case O (O_JSR, SB):		/* jsr, jump to subroutine */
	case O (O_JSR, SW):
	  if (fetch (sd, &code->src, &pc))
	    goto end;
	call:
	  tmp = h8_get_reg (sd, SP_REGNUM);

	  if (h8300hmode)
d1294 1
a1294 2
	      tmp -= 4;
	      SET_MEMORY_L (tmp, code->next_pc);
d1296 1
a1296 1
	  else
d1298 1
a1298 2
	      tmp -= 2;
	      SET_MEMORY_W (tmp, code->next_pc);
d1300 4
a1303 1
	  h8_set_reg (sd, SP_REGNUM, tmp);
d1305 2
a1306 16
	  goto end;

	case O (O_BSR, SW):
	case O (O_BSR, SL):
	case O (O_BSR, SB):		/* bsr, branch to subroutine */
	  if (fetch (sd, &code->src, &res))
	    goto end;
	  pc = code->next_pc + res;
	  goto call;

	case O (O_RTE, SN):		/* rte, return from exception */
	rte:
	  /* Pops exr and ccr before pc -- otherwise identical to rts.  */
	  tmp = h8_get_reg (sd, SP_REGNUM);

	  if (h8300smode)			/* pop exr */
d1308 1
a1308 2
	      h8_set_exr (sd, GET_MEMORY_L (tmp));
	      tmp += 4;
d1310 1
a1310 1
	  if (h8300hmode)
d1312 1
a1312 4
	      h8_set_ccr (sd, GET_MEMORY_L (tmp));
	      tmp += 4;
	      pc = GET_MEMORY_L (tmp);
	      tmp += 4;
d1315 11
d1327 1
a1327 4
	      h8_set_ccr (sd, GET_MEMORY_W (tmp));
	      tmp += 2;
	      pc = GET_MEMORY_W (tmp);
	      tmp += 2;
d1329 5
d1335 2
a1336 9
	  GETSR (sd);
	  h8_set_reg (sd, SP_REGNUM, tmp);
	  goto end;

	case O (O_RTS, SN):		/* rts, return from subroutine */
	rts:
	  tmp = h8_get_reg (sd, SP_REGNUM);

	  if (h8300hmode)
d1338 1
a1338 2
	      pc = GET_MEMORY_L (tmp);
	      tmp += 4;
d1340 1
a1340 1
	  else
d1342 1
a1342 2
	      pc = GET_MEMORY_W (tmp);
	      tmp += 2;
d1344 5
a1349 2
	  h8_set_reg (sd, SP_REGNUM, tmp);
	  goto end;
d1351 4
a1354 3
	case O (O_ILL, SB):		/* illegal */
	  sim_engine_set_run_state (sd, sim_stopped, SIGILL);
	  goto end;
d1356 4
a1359 16
	case O (O_SLEEP, SN):		/* sleep */
	  /* Check for magic numbers in r1 and r2.  */
	  if ((h8_get_reg (sd, R1_REGNUM) & 0xffff) == LIBC_EXIT_MAGIC1 &&
	      (h8_get_reg (sd, R2_REGNUM) & 0xffff) == LIBC_EXIT_MAGIC2 &&
	      SIM_WIFEXITED (h8_get_reg (sd, 0)))
	    {
	      /* This trap comes from _exit, not from gdb.  */
	      sim_engine_set_run_state (sd, sim_exited, 
					SIM_WEXITSTATUS (h8_get_reg (sd, 0)));
	    }
	  else
	    {
	      /* Treat it as a sigtrap.  */
	      sim_engine_set_run_state (sd, sim_stopped, SIGTRAP);
	    }
	  goto end;
d1361 4
a1364 11
	case O (O_TRAPA, SB):		/* trapa */
	  if (fetch (sd, &code->src, &res))
	    goto end;			/* res is vector number.  */

	  tmp = h8_get_reg (sd, SP_REGNUM);
	  tmp -= 4;
	  SET_MEMORY_L (tmp, code->next_pc);
	  tmp -= 4; 
	  SET_MEMORY_L (tmp, h8_get_ccr (sd));
	  intMaskBit = 1;
	  BUILDSR (sd);
a1365 5
	  if (h8300smode)
	    {
	      tmp -= 4;
	      SET_MEMORY_L (tmp, h8_get_exr (sd));
	    }
d1367 4
a1370 1
	  h8_set_reg (sd, SP_REGNUM, tmp);
d1372 4
a1375 3
	  /* FIXME: "normal" mode should use 2-byte ptrs.  */
	  pc = GET_MEMORY_L (0x20 + res * 4);
	  goto end;
d1377 4
a1380 3
	case O (O_BPT, SN):
	  sim_engine_set_run_state (sd, sim_stopped, SIGTRAP);
	  goto end;
d1382 1
a1382 1
	case O (O_BSETEQ, SB):
d1384 5
a1388 1
	    goto bset;
d1391 4
a1394 3
	case O (O_BSETNE, SB):
	  if (!Z)
	    goto bset;
d1397 15
a1411 3
	case O (O_BCLREQ, SB):
	  if (Z)
	    goto bclr;
d1414 11
a1424 3
	case O (O_BCLRNE, SB):
	  if (!Z)
	    goto bclr;
d1427 128
a1554 22
	  OBITOP (O_BNOT, 1, 1, ea ^= m);		/* bnot */
	  OBITOP (O_BTST, 1, 0, nz = ea & m);		/* btst */
	bset:
	  OBITOP (O_BSET, 1, 1, ea |= m);		/* bset */
	bclr:
	  OBITOP (O_BCLR, 1, 1, ea &= ~m);		/* bclr */
	  OBITOP (O_BLD, 1, 0, c = ea & m);		/* bld  */
	  OBITOP (O_BILD, 1, 0, c = !(ea & m));		/* bild */
	  OBITOP (O_BST, 1, 1, ea &= ~m;
		  if (C) ea |= m);			/* bst  */
	  OBITOP (O_BIST, 1, 1, ea &= ~m;
		  if (!C) ea |= m);			/* bist */
	  OBITOP (O_BSTZ, 1, 1, ea &= ~m;
		  if (Z) ea |= m);			/* bstz */
	  OBITOP (O_BISTZ, 1, 1, ea &= ~m;
		  if (!Z) ea |= m);			/* bistz */
	  OBITOP (O_BAND, 1, 0, c = (ea & m) && C);	/* band */
	  OBITOP (O_BIAND, 1, 0, c = !(ea & m) && C);	/* biand */
	  OBITOP (O_BOR, 1, 0, c = (ea & m) || C);	/* bor  */
	  OBITOP (O_BIOR, 1, 0, c = !(ea & m) || C);	/* bior */
	  OBITOP (O_BXOR, 1, 0, c = ((ea & m) != 0)!= C);	/* bxor */
	  OBITOP (O_BIXOR, 1, 0, c = !(ea & m) != C);	/* bixor */
d1556 10
a1565 5
	case O (O_BFLD, SB):				/* bfld */
	  /* bitfield load */
	  ea = 0;
	  if (fetch (sd, &code->src, &bit))
	    goto end;
d1567 7
a1573 14
	  if (bit != 0)
	    {
	      if (fetch (sd, &code->dst, &ea))
		goto end;

	      ea &= bit;
	      while (!(bit & 1))
		{
		  ea  >>= 1;
		  bit >>= 1;
		}
	    }
	  if (store (sd, &code->op3, ea))
	    goto end;
d1575 7
d1584 10
a1593 5
	case O(O_BFST, SB):			/* bfst */
	  /* bitfield store */
	  /* NOTE: the imm8 value is in dst, and the ea value
	     (which is actually the destination) is in op3.
	     It has to be that way, to avoid breaking the assembler.  */
d1595 2
a1596 4
	  if (fetch (sd, &code->dst, &bit))	/* imm8 */
	    goto end;
	  if (bit == 0)				/* noop -- nothing to do.  */
	    goto next;
d1598 9
a1606 2
	  if (fetch (sd, &code->src, &rd))	/* reg8 src */
	    goto end;
d1608 2
a1609 2
	  if (fetch2 (sd, &code->op3, &ea))	/* ea dst */
	    goto end;
d1611 6
a1616 3
	  /* Left-shift the register data into position.  */
	  for (tmp = bit; !(tmp & 1); tmp >>= 1)
	    rd <<= 1;
d1618 2
a1619 2
	  /* Combine it with the neighboring bits.  */
	  ea = (ea & ~bit) | (rd & bit);
d1621 6
a1626 4
	  /* Put it back.  */
	  if (store2 (sd, &code->op3, ea))
	    goto end;
	  goto next;
d1628 2
a1629 7
	case O (O_CLRMAC, SN):		/* clrmac */
	  h8_set_mach (sd, 0);
	  h8_set_macl (sd, 0);
	  h8_set_macZ (sd, 1);
	  h8_set_macV (sd, 0);
	  h8_set_macN (sd, 0);
	  goto next;
d1631 2
a1632 15
	case O (O_STMAC, SL):		/* stmac, 260 */
	  switch (code->src.type) {
	  case X (OP_MACH, SL): 
	    res = h8_get_mach (sd);
	    if (res & 0x200)		/* sign extend */
	      res |= 0xfffffc00;
	    break;
	  case X (OP_MACL, SL): 
	    res = h8_get_macl (sd);
	    break;
	  default:	goto illegal;
	  }
	  nz = !h8_get_macZ (sd);
	  n = h8_get_macN (sd);
	  v = h8_get_macV (sd);
d1634 2
a1635 18
	  if (store (sd, &code->dst, res))
	    goto end;

	  goto next;

	case O (O_LDMAC, SL):		/* ldmac, 179 */
	  if (fetch (sd, &code->src, &rd))
	    goto end;

	  switch (code->dst.type) {
	  case X (OP_MACH, SL):	
	    rd &= 0x3ff;		/* Truncate to 10 bits */
	    h8_set_mach (sd, rd);
	    break;
	  case X (OP_MACL, SL):	
	    h8_set_macl (sd, rd);
	    break;
	  default:	goto illegal;
a1636 1
	  h8_set_macV (sd, 0);
d1639 8
a1646 4
	case O (O_MAC, SW):
	  if (fetch (sd, &code->src, &rd) ||
	      fetch (sd, &code->dst, &res))
	    goto end;
d1648 2
a1649 3
	  /* Ye gods, this is non-portable!
	     However, the existing mul/div code is similar.  */
	  res = SEXTSHORT (res) * SEXTSHORT (rd);
d1651 1
a1651 3
	  if (h8_get_macS (sd))		/* Saturating mode */
	    {
	      long long mac = h8_get_macl (sd);
d1653 3
a1655 2
	      if (mac & 0x80000000)		/* sign extend */
		mac |= 0xffffffff00000000LL;
d1657 6
a1662 27
	      mac += res;
	      if (mac > 0x7fffffff || mac < 0xffffffff80000000LL)
		h8_set_macV (sd, 1);
	      h8_set_macZ (sd, (mac == 0));
	      h8_set_macN (sd, (mac  < 0));
	      h8_set_macl (sd, (int) mac);
	    }
	  else				/* "Less Saturating" mode */
	    {
	      long long mac = h8_get_mach (sd);
	      mac <<= 32;
	      mac += h8_get_macl (sd);

	      if (mac & 0x20000000000LL)	/* sign extend */
		mac |= 0xfffffc0000000000LL;

	      mac += res;
	      if (mac > 0x1ffffffffffLL || 
		  mac < (long long) 0xfffffe0000000000LL)
		h8_set_macV (sd, 1);
	      h8_set_macZ (sd, (mac == 0));
	      h8_set_macN (sd, (mac  < 0));
	      h8_set_macl (sd, (int) mac);
	      mac >>= 32;
	      h8_set_mach (sd, (int) (mac & 0x3ff));
	    }
	  goto next;
d1664 2
a1665 18
	case O (O_MULS, SW):		/* muls.w */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfff0;
	  else
	    ea = SEXTSHORT (ea);

	  res = SEXTSHORT (ea * SEXTSHORT (rd));

	  n  = res & 0x8000;
	  nz = res & 0xffff;
	  if (store (sd, &code->dst, res))
	    goto end;
d1667 3
d1672 10
a1681 4
	case O (O_MULS, SL):		/* muls.l */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
d1683 3
a1685 12
	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfffffff0;

	  res = ea * rd;

	  n  = res & 0x80000000;
	  nz = res & 0xffffffff;
	  if (store (sd, &code->dst, res))
	    goto end;
	  goto next;
d1687 2
a1688 4
	case O (O_MULSU, SL):		/* muls/u.l */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
d1690 6
a1695 13
	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfffffff0;

	  /* Compute upper 32 bits of the 64-bit result.  */
	  res = (((long long) ea) * ((long long) rd)) >> 32;

	  n  = res & 0x80000000;
	  nz = res & 0xffffffff;
	  if (store (sd, &code->dst, res))
	    goto end;
	  goto next;
d1697 2
a1698 4
	case O (O_MULU, SW):		/* mulu.w */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
d1700 2
a1701 5
	  res = UEXTSHORT ((UEXTSHORT (ea) * UEXTSHORT (rd)));

	  /* Don't set Z or N.  */
	  if (store (sd, &code->dst, res))
	    goto end;
d1703 3
d1708 6
a1713 4
	case O (O_MULU, SL):		/* mulu.l */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
d1715 3
a1717 1
	  res = ea * rd;
d1719 3
a1721 3
	  /* Don't set Z or N.  */
	  if (store (sd, &code->dst, res))
	    goto end;
d1723 3
d1728 4
a1731 4
	case O (O_MULUU, SL):		/* mulu/u.l */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
d1733 1
a1733 3
	  /* Compute upper 32 bits of the 64-bit result.  */
	  res = (((unsigned long long) (unsigned) ea) *
		 ((unsigned long long) (unsigned) rd)) >> 32;
d1735 2
a1736 3
	  /* Don't set Z or N.  */
	  if (store (sd, &code->dst, res))
	    goto end;
d1738 3
d1743 7
a1749 4
	case O (O_MULXS, SB):		/* mulxs.b */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
d1751 1
a1751 6
	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfffffff0;
	  else
	    ea = SEXTCHAR (ea);
d1753 2
a1754 1
	  res = ea * SEXTCHAR (rd);
d1756 2
a1757 4
	  n  = res & 0x8000;
	  nz = res & 0xffff;
	  if (store (sd, &code->dst, res))
	    goto end;
d1759 2
a1760 1
	  goto next;
d1762 22
a1783 18
	case O (O_MULXS, SW):		/* mulxs.w */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfff0;
	  else
	    ea = SEXTSHORT (ea);

	  res = ea * SEXTSHORT (rd & 0xffff);

	  n  = res & 0x80000000;
	  nz = res & 0xffffffff;
	  if (store (sd, &code->dst, res))
	    goto end;
d1785 3
d1790 11
a1800 4
	case O (O_MULXU, SB):		/* mulxu.b */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
d1802 2
a1803 1
	  res = UEXTCHAR (ea) * UEXTCHAR (rd);
d1805 2
a1806 2
	  if (store (sd, &code->dst, res))
	    goto end;
d1808 6
a1813 1
	  goto next;
d1815 2
a1816 11
	case O (O_MULXU, SW):		/* mulxu.w */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  res = UEXTSHORT (ea) * UEXTSHORT (rd);

	  if (store (sd, &code->dst, res))
	    goto end;

	  goto next;
d1818 2
a1819 3
	case O (O_TAS, SB):		/* tas (test and set) */
	  if (!h8300sxmode)		/* h8sx can use any register. */
	    switch (code->src.reg)
d1821 2
a1822 7
	      case R0_REGNUM:
	      case R1_REGNUM:
	      case R4_REGNUM:
	      case R5_REGNUM:
		break;
	      default:
		goto illegal;
d1825 3
a1827 4
	  if (fetch (sd, &code->src, &res))
	    goto end;
	  if (store (sd, &code->src, res | 0x80))
	    goto end;
d1829 3
a1831 1
	  goto just_flags_log8;
d1833 2
a1834 4
	case O (O_DIVU, SW):			/* divu.w */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
d1836 2
a1837 6
	  n  = ea & 0x8000;
	  nz = ea & 0xffff;
	  if (ea)
	    res = (unsigned) (UEXTSHORT (rd) / UEXTSHORT (ea));
	  else
	    res = 0;
d1839 22
a1860 3
	  if (store (sd, &code->dst, res))
	    goto end;
	  goto next;
d1862 3
a1864 14
	case O (O_DIVU, SL):			/* divu.l */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  n  = ea & 0x80000000;
	  nz = ea & 0xffffffff;
	  if (ea)
	    res = (unsigned) rd / ea;
	  else
	    res = 0;

	  if (store (sd, &code->dst, res))
	    goto end;
d1866 1
d1868 25
a1892 9
	case O (O_DIVS, SW):			/* divs.w */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfffffff0;
d1894 3
a1896 13
	  if (ea)
	    {
	      res = SEXTSHORT (rd) / SEXTSHORT (ea);
	      nz  = 1;
	    }
	  else
	    {
	      res = 0;
	      nz  = 0;
	    }

	  n = res & 0x8000;
	  if (store (sd, &code->dst, res))
a1897 1
	  goto next;
d1899 1
a1899 4
	case O (O_DIVS, SL):			/* divs.l */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
d1901 6
a1906 4
	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfffffff0;
d1908 11
a1918 10
	  if (ea)
	    {
	      res = rd / ea;
	      nz  = 1;
	    }
	  else
	    {
	      res = 0;
	      nz  = 0;
	    }
a1919 2
	  n = res & 0x80000000;
	  if (store (sd, &code->dst, res))
d1921 4
a1924 1
	  goto next;
d1926 3
a1928 4
	case O (O_DIVXU, SB):			/* divxu.b */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
d1930 1
a1930 2
	  rd = UEXTSHORT (rd);
	  ea = UEXTCHAR (ea);
d1932 10
a1941 12
	  n  = ea & 0x80;
	  nz = ea & 0xff;
	  if (ea)
	    {
	      tmp = (unsigned) rd % ea;
	      res = (unsigned) rd / ea;
	    }
	  else
	    {
	      tmp = 0;
	      res = 0;
	    }
d1943 1
a1943 1
	  if (store (sd, &code->dst, (res & 0xff) | (tmp << 8)))
d1945 1
a1945 1
	  goto next;
d1947 14
a1960 14
	case O (O_DIVXU, SW):			/* divxu.w */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;

	  ea = UEXTSHORT (ea);

	  n  = ea & 0x8000;
	  nz = ea & 0xffff;
	  if (ea)
	    {
	      tmp = (unsigned) rd % ea;
	      res = (unsigned) rd / ea;
	    }
d1962 6
a1967 4
	    {
	      tmp = 0;
	      res = 0;
	    }
d1969 20
a1988 3
	  if (store (sd, &code->dst, (res & 0xffff) | (tmp << 16)))
	    goto end;
	  goto next;
d1990 12
a2001 4
	case O (O_DIVXS, SB):			/* divxs.b */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
d2003 4
a2006 10
	  rd = SEXTSHORT (rd);

	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfffffff0;
	  else
	    ea = SEXTCHAR (ea);

	  if (ea)
d2008 7
a2014 9
	      tmp = (int) rd % (int) ea;
	      res = (int) rd / (int) ea;
	      nz  = 1;
	    }
	  else
	    {
	      tmp = 0;
	      res = 0;
	      nz  = 0;
d2016 3
d2020 12
a2031 4
	  n = res & 0x8000;
	  if (store (sd, &code->dst, (res & 0xff) | (tmp << 8)))
	    goto end;
	  goto next;
d2033 16
a2048 4
	case O (O_DIVXS, SW):			/* divxs.w */
	  if (fetch (sd, &code->src, &ea) ||
	      fetch (sd, &code->dst, &rd))
	    goto end;
d2050 2
a2051 6
	  /* FIXME: is this the right place to be doing sign extend?  */
	  if (OP_KIND (code->src.type) == OP_IMM &&
	      (ea & 8) != 0)
	    ea |= 0xfffffff0;
	  else
	    ea = SEXTSHORT (ea);
d2053 32
a2084 21
	  if (ea)
	    {
	      tmp = (int) rd % (int) ea;
	      res = (int) rd / (int) ea;
	      nz  = 1;
	    }
	  else
	    {
	      tmp = 0;
	      res = 0;
	      nz  = 0;
	    }

	  n = res & 0x80000000;
	  if (store (sd, &code->dst, (res & 0xffff) | (tmp << 16)))
	    goto end;
	  goto next;

	case O (O_EXTS, SW):			/* exts.w, signed extend */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
d2086 1
a2086 1
	  res = (rd & 0xff) + ea;
d2088 2
a2089 18

	case O (O_EXTS, SL):			/* exts.l, signed extend */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (code->src.type == X (OP_IMM, SL))
	    {
	      if (fetch (sd, &code->src, &ea))
		goto end;

	      if (ea == 2)			/* exts.l #2, nn */
		{
		  /* Sign-extend from 8-bit to 32-bit.  */
		  ea = rd & 0x80 ? -256 : 0;
		  res = (rd & 0xff) + ea;
		  goto log32;
		}
	    }
	  /* Sign-extend from 16-bit to 32-bit.  */
d2091 1
a2091 1
	  res = (rd & 0xffff) + ea;
d2093 2
a2094 4

	case O (O_EXTU, SW):			/* extu.w, unsigned extend */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
d2096 1
a2096 1
	  res = (rd & 0xff) + ea;
d2098 2
a2099 18

	case O (O_EXTU, SL):			/* extu.l, unsigned extend */
	  if (fetch2 (sd, &code->dst, &rd))
	    goto end;
	  if (code->src.type == X (OP_IMM, SL))
	    {
	      if (fetch (sd, &code->src, &ea))
		goto end;

	      if (ea == 2)			/* extu.l #2, nn */
		{
		  /* Zero-extend from 8-bit to 32-bit.  */
		  ea = 0;
		  res = (rd & 0xff) + ea;
		  goto log32;
		}
	    }
	  /* Zero-extend from 16-bit to 32-bit.  */
d2101 1
a2101 1
	  res = (rd & 0xffff) + ea;
d2104 1
a2104 1
	case O (O_NOP, SN):			/* nop */
d2107 1
a2107 1
	case O (O_STM, SL):			/* stm, store to memory */
d2114 1
a2114 1
	    firstreg = code->src.reg;
d2118 2
a2119 2
		h8_set_reg (sd, SP_REGNUM, h8_get_reg (sd, SP_REGNUM) - 4);
		SET_MEMORY_L (h8_get_reg (sd, SP_REGNUM), h8_get_reg (sd, i));
d2124 1
a2124 3
	case O (O_LDM, SL):			/* ldm,  load from memory */
	case O (O_RTEL, SN):			/* rte/l, ldm plus rte */
	case O (O_RTSL, SN):			/* rts/l, ldm plus rts */
d2128 5
a2132 2
	    nregs = ((GET_MEMORY_B (pc + 1) >> 4) & 0xf);
	    firstreg = code->dst.reg & 0xf;
d2135 2
a2136 2
		h8_set_reg (sd, i, GET_MEMORY_L (h8_get_reg (sd, SP_REGNUM)));
		h8_set_reg (sd, SP_REGNUM, h8_get_reg (sd, SP_REGNUM) + 4);
d2139 1
a2139 10
	  switch (code->opcode) {
	  case O (O_RTEL, SN):
	    goto rte;
	  case O (O_RTSL, SN):
	    goto rts;
	  case O (O_LDM, SL):
	    goto next;
	  default:
	    goto illegal;
	  }
d2143 3
a2145 3
	  res = GET_B_REG (code->src.reg);	/* FIXME fetch? */
	  if (!c && (0 <= (res >>  4) && (res >>  4) <= 9) && 
	      !h && (0 <= (res & 0xf) && (res & 0xf) <= 9))
d2147 2
a2148 2
	  else if (!c && (0  <= (res >>  4) && (res >>  4) <=  8) && 
		   !h && (10 <= (res & 0xf) && (res & 0xf) <= 15))
d2150 2
a2151 2
	  else if (!c && (0 <= (res >>  4) && (res >>  4) <= 9) && 
		    h && (0 <= (res & 0xf) && (res & 0xf) <= 3))
d2153 2
a2154 11
	  else if (!c && (10 <= (res >>  4) && (res >>  4) <= 15) && 
		   !h && (0  <= (res & 0xf) && (res & 0xf) <=  9))
	    res = res + 0x60;		/* Value added == 60.  */
	  else if (!c && (9  <= (res >>  4) && (res >>  4) <= 15) && 
		   !h && (10 <= (res & 0xf) && (res & 0xf) <= 15))
	    res = res + 0x66;		/* Value added == 66.  */
	  else if (!c && (10 <= (res >>  4) && (res >>  4) <= 15) && 
		    h && (0  <= (res & 0xf) && (res & 0xf) <=  3))
	    res = res + 0x66;		/* Value added == 66.  */
	  else if ( c && (1 <= (res >>  4) && (res >>  4) <= 2) && 
		   !h && (0 <= (res & 0xf) && (res & 0xf) <= 9))
d2156 2
a2157 2
	  else if ( c && (1  <= (res >>  4) && (res >>  4) <=  2) && 
		   !h && (10 <= (res & 0xf) && (res & 0xf) <= 15))
d2159 2
a2160 2
	  else if (c && (1 <= (res >>  4) && (res >>  4) <= 3) && 
		   h && (0 <= (res & 0xf) && (res & 0xf) <= 3))
d2162 9
d2177 2
a2178 2
	  if (!c && (0 <= (res >>  4) && (res >>  4) <= 9) && 
	      !h && (0 <= (res & 0xf) && (res & 0xf) <= 9))
d2180 2
a2181 2
	  else if (!c && (0 <= (res >>  4) && (res >>  4) <=  8) && 
		    h && (6 <= (res & 0xf) && (res & 0xf) <= 15))
d2183 2
a2184 2
	  else if ( c && (7 <= (res >>  4) && (res >>  4) <= 15) && 
		   !h && (0 <= (res & 0xf) && (res & 0xf) <=  9))
d2186 2
a2187 2
	  else if (c && (6 <= (res >>  4) && (res >>  4) <= 15) && 
		   h && (6 <= (res & 0xf) && (res & 0xf) <= 15))
d2194 2
a2195 1
	  sim_engine_set_run_state (sd, sim_stopped, SIGILL);
d2199 1
a2199 5

      (*sim_callback->printf_filtered) (sim_callback,
					"sim_resume: internal error.\n");
      sim_engine_set_run_state (sd, sim_stopped, SIGILL);
      goto end;
d2202 1
a2202 2
      if (code->dst.type == X (OP_CCR, SB) ||
	  code->dst.type == X (OP_CCR, SW))
d2204 2
a2205 2
	  h8_set_ccr (sd, res);
	  GETSR (sd);
d2207 1
a2207 3
      else if (h8300smode &&
	       (code->dst.type == X (OP_EXR, SB) ||
		code->dst.type == X (OP_EXR, SW)))
d2209 2
a2210 6
	  h8_set_exr (sd, res);
	  if (h8300smode)	/* Get exr.  */
	    {
	      trace = (h8_get_exr (sd) >> 7) & 1;
	      intMask = h8_get_exr (sd) & 7;
	    }
d2219 1
a2219 5
      if (fetch (sd, &code->src, &res))
	goto end;
      if (res & 1)		/* bad address */
	goto illegal;
      pc = code->next_pc + res;
d2232 1
d2240 1
d2248 1
d2253 1
a2253 2
      if (store2 (sd, &code->dst, rd))
	goto end;
d2260 1
a2260 2
      if (store2 (sd, &code->dst, rd))
	goto end;
d2267 1
a2267 2
      if (store2 (sd, &code->dst, rd))
	goto end;
d2271 1
a2271 3
      if (store2 (sd, &code->dst, res))
	goto end;

d2280 1
a2280 3
      if (store2 (sd, &code->dst, res))
	goto end;

d2288 1
d2290 1
a2290 3
      if (store2 (sd, &code->dst, res))
	goto end;

d2298 1
a2298 3
      if (store2 (sd, &code->dst, res))
	goto end;

a2305 1
	case O_ADDX:
a2309 1
	case O_SUBX:
a2316 3
	case O_DAA:
	case O_DAS:
	  break;	/* No effect on v flag.  */
d2321 1
a2321 3
      if (store2 (sd, &code->dst, res))
	goto end;

a2328 1
	case O_ADDX:
a2332 1
	case O_SUBX:
d2344 1
a2344 3
      if (store2 (sd, &code->dst, res))
	goto end;

a2350 1
	case O_ADDX:
d2353 1
a2353 2
	  c = ((unsigned) res < (unsigned) rd) || 
	    ((unsigned) res < (unsigned) ea);
a2355 1
	case O_SUBX:
d2368 2
a2369 8
    next:
      if ((res = h8_get_delayed_branch (sd)) != 0)
	{
	  pc = res;
	  h8_set_delayed_branch (sd, 0);
	}
      else
	pc = code->next_pc;
d2372 6
a2377 1
      
d2383 1
a2383 1
	    sim_engine_set_run_state (sd, sim_stopped, SIGINT);
a2384 2
      sim_engine_get_run_state (sd, &reason, &sigrc);
    } while (reason == sim_running);
d2386 10
a2395 10
  h8_set_ticks (sd, h8_get_ticks (sd) + get_now () - tick_start);
  h8_set_cycles (sd, h8_get_cycles (sd) + cycles);
  h8_set_insts (sd, h8_get_insts (sd) + insts);
  h8_set_pc (sd, pc);
  BUILDSR (sd);

  if (h8300smode)
    h8_set_exr (sd, (trace<<7) | intMask);

  h8_set_mask (sd, oldmask);
d2403 1
a2403 3
  (*sim_callback->printf_filtered) (sim_callback,
				    "sim_trace: trace not supported.\n");
  return 1;	/* Done.  */
d2411 1
a2411 1
  init_pointers (sd);
d2418 2
a2419 2
	  h8_set_memory    (sd, addr + i, buffer[i]);
	  h8_set_cache_idx (sd, addr + i,  0);
d2422 1
a2422 3
	{
	  h8_set_eightbit (sd, (addr + i) & 0xff, buffer[i]);
	}
d2430 1
a2430 1
  init_pointers (sd);
d2434 1
a2434 1
    memcpy (buffer, h8_get_memory_buf (sd) + addr, size);
d2436 1
a2436 1
    memcpy (buffer, h8_get_eightbit_buf (sd) + (addr & 0xff), size);
d2451 1
a2451 1
  init_pointers (sd);
d2455 1
a2455 1
      h8_set_pc (sd, intval);
d2458 1
a2458 3
      (*sim_callback->printf_filtered) (sim_callback, 
					"sim_store_register: bad regnum %d.\n",
					rn);
d2467 1
a2467 1
      h8_set_reg (sd, rn, intval);
d2470 1
a2470 1
      h8_set_ccr (sd, intval);
d2473 1
a2473 13
      h8_set_exr (sd, intval);
      break;
    case SBR_REGNUM:
      h8_set_sbr (sd, intval);
      break;
    case VBR_REGNUM:
      h8_set_vbr (sd, intval);
      break;
    case MACH_REGNUM:
      h8_set_mach (sd, intval);
      break;
    case MACL_REGNUM:
      h8_set_macl (sd, intval);
d2476 1
a2476 1
      h8_set_cycles (sd, longval);
d2480 1
a2480 1
      h8_set_insts (sd, longval);
d2484 1
a2484 1
      h8_set_ticks (sd, longval);
d2496 1
a2496 1
  init_pointers (sd);
d2503 1
a2503 5
      (*sim_callback->printf_filtered) (sim_callback, 
					"sim_fetch_register: bad regnum %d.\n",
					rn);
      v = 0;
      break;
d2505 1
a2505 1
      v = h8_get_ccr (sd);
d2508 1
a2508 1
      v = h8_get_exr (sd);
d2511 1
a2511 13
      v = h8_get_pc (sd);
      break;
    case SBR_REGNUM:
      v = h8_get_sbr (sd);
      break;
    case VBR_REGNUM:
      v = h8_get_vbr (sd);
      break;
    case MACH_REGNUM:
      v = h8_get_mach (sd);
      break;
    case MACL_REGNUM:
      v = h8_get_macl (sd);
d2521 1
a2521 1
      v = h8_get_reg (sd, rn);
d2524 1
a2524 1
      v = h8_get_cycles (sd);
d2528 1
a2528 1
      v = h8_get_ticks (sd);
d2532 1
a2532 1
      v = h8_get_insts (sd);
d2554 13
a2566 1
  sim_engine_get_run_state (sd, reason, sigrc);
d2577 2
a2578 2
static void
set_simcache_size (SIM_DESC sd, int n)
d2580 2
a2581 2
  if (sd->sim_cache)
    free (sd->sim_cache);
d2584 3
a2586 3
  sd->sim_cache = (decoded_inst *) malloc (sizeof (decoded_inst) * n);
  memset (sd->sim_cache, 0, sizeof (decoded_inst) * n);
  sd->sim_cache_size = n;
d2593 2
a2594 2
  double timetaken = (double) h8_get_ticks (sd) / (double) now_persec ();
  double virttime = h8_get_cycles (sd) / 10.0e6;
d2598 1
a2598 1
				    h8_get_insts (sd));
d2601 1
a2601 1
				    h8_get_cycles (sd));
d2606 1
a2606 1
				    "#virtual time taken     %10.4f\n",
d2614 1
a2614 1
				    h8_get_compiles (sd));
d2617 1
a2617 1
				    sd->sim_cache_size);
d2627 3
a2629 3
	  if (h8_get_stats (sd, i))
	    (*sim_callback->printf_filtered) (sim_callback, "%d: %d\n", 
					      i, h8_get_stats (sd, i));
d2639 1
a2639 1
set_h8300h (unsigned long machine)
d2644 2
a2645 21

  if (machine == bfd_mach_h8300sx || machine == bfd_mach_h8300sxn)
    h8300sxmode = 1;

  if (machine == bfd_mach_h8300s || machine == bfd_mach_h8300sn || h8300sxmode)
    h8300smode = 1;

  if (machine == bfd_mach_h8300h || machine == bfd_mach_h8300hn || h8300smode)
    h8300hmode = 1;
}

/* Cover function of sim_state_free to free the cpu buffers as well.  */

static void
free_state (SIM_DESC sd)
{
  if (STATE_MODULES (sd) != NULL)
    sim_module_uninstall (sd);

  /* Fixme: free buffers in _sim_cpu.  */
  sim_state_free (sd);
d2650 1
a2650 1
	  struct host_callback_struct *callback, 
a2653 59
  SIM_DESC sd;
  sim_cpu *cpu;

  sd = sim_state_alloc (kind, callback);
  sd->cpu = sim_cpu_alloc (sd, 0);
  cpu = STATE_CPU (sd, 0);
  SIM_ASSERT (STATE_MAGIC (sd) == SIM_MAGIC_NUMBER);
  sim_state_initialize (sd, cpu);
  /* sim_cpu object is new, so some initialization is needed.  */
  init_pointers_needed = 1;

  /* For compatibility (FIXME: is this right?).  */
  current_alignment = NONSTRICT_ALIGNMENT;
  current_target_byte_order = BIG_ENDIAN;

  if (sim_pre_argv_init (sd, argv[0]) != SIM_RC_OK)
    {
      free_state (sd);
      return 0;
    }

    /* getopt will print the error message so we just have to exit if
       this fails.  FIXME: Hmmm...  in the case of gdb we need getopt
       to call print_filtered.  */
  if (sim_parse_args (sd, argv) != SIM_RC_OK)
    {
      /* Uninstall the modules to avoid memory leaks,
         file descriptor leaks, etc.  */
      free_state (sd);
      return 0;
    }

  /* Check for/establish the a reference program image.  */
  if (sim_analyze_program (sd,
			   (STATE_PROG_ARGV (sd) != NULL
			    ? *STATE_PROG_ARGV (sd)
			    : NULL), abfd) != SIM_RC_OK)
    {
      free_state (sd);
      return 0;
    }

  /* Establish any remaining configuration options.  */
  if (sim_config (sd) != SIM_RC_OK)
    {
      free_state (sd);
      return 0;
    }

  if (sim_post_argv_init (sd) != SIM_RC_OK)
    {
      /* Uninstall the modules to avoid memory leaks,
         file descriptor leaks, etc.  */
      free_state (sd);
      return 0;
    }

  /*  sim_hw_configure (sd); */

d2658 3
a2660 2
  sim_callback = callback;
  return sd;
d2692 3
a2694 1
	  set_h8300h (bfd_get_mach (prog_bfd));
d2720 10
a2729 12
  if (h8_get_memory_buf (sd))
    free (h8_get_memory_buf (sd));
  if (h8_get_cache_idx_buf (sd))
    free (h8_get_cache_idx_buf (sd));
  if (h8_get_eightbit_buf (sd))
    free (h8_get_eightbit_buf (sd));

  h8_set_memory_buf (sd, (unsigned char *) 
		     calloc (sizeof (char), memory_size));
  h8_set_cache_idx_buf (sd, (unsigned short *) 
			calloc (sizeof (short), memory_size));
  h8_set_eightbit_buf (sd, (unsigned char *) calloc (sizeof (char), 256));
d2733 2
a2734 6
    {
      (*sim_callback->printf_filtered) (sim_callback, 
					"sim_load: bad memory size.\n");
      return SIM_RC_FAIL;
    }
  h8_set_mask (sd, memory_size - 1);
d2759 1
a2759 1

d2761 1
a2761 1
    h8_set_pc (sd, bfd_get_start_address (abfd));
d2763 1
a2763 1
    h8_set_pc (sd, 0);
d2773 2
a2774 2
      h8_set_command_line (sd, (char **) malloc ((sizeof (char *))
						 * (no_of_args + 1)));
d2778 3
d2782 1
a2782 1
	  h8_set_cmdline_arg (sd, i, (char *) strdup (argv[i]));
d2784 1
a2784 1
      h8_set_cmdline_arg (sd, i, NULL);
@


1.17.8.5
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a608 4
      cst[0]   = cst[1]   = cst[2]   = 0;
      reg[0]   = reg[1]   = reg[2]   = 0;
      rdisp[0] = rdisp[1] = rdisp[2] = 0;

d773 1
d779 14
d821 1
a821 3
		  /* Immediates are always unsigned.  */
		  if ((looking_for & SIZE) != L_16U &&
		      (looking_for & MODE) != IMM)
d1073 4
a1076 1
			else if ((x & MODE) == INDEXB)
d1078 17
a1094 1
			    p->type = X (OP_INDEXB, OP_SIZE (q->how));
a1097 52
			else if ((x & MODE) == INDEXW)
			  {
			    p->type = X (OP_INDEXW, OP_SIZE (q->how));
			    p->literal = cst[opnum];
			    p->reg     = rdisp[opnum];
			  }
			else if ((x & MODE) == INDEXL)
			  {
			    p->type = X (OP_INDEXL, OP_SIZE (q->how));
			    p->literal = cst[opnum];
			    p->reg     = rdisp[opnum];
			  }
			else if ((x & MODE) == DISP)
			  {
			    /* Yuck -- special for mova args.  */
			    if (strncmp (q->name, "mova", 4) == 0 &&
				(x & SIZE) == L_2)
			      {
				/* Mova can have a DISP2 dest, with an
				   INDEXB or INDEXW src.  The multiplier
				   for the displacement value is determined
				   by the src operand, not by the insn.  */

				switch (OP_KIND (dst->src.type))
				  {
				  case OP_INDEXB:
				    p->type = X (OP_DISP, SB);
				    p->literal = cst[opnum];
				    break;
				  case OP_INDEXW:
				    p->type = X (OP_DISP, SW);
				    p->literal = cst[opnum] * 2;
				    break;
				  default:
				    goto fail;
				  }
			      }
			    else
			      {
				p->type = X (OP_DISP,   OP_SIZE (q->how));
				p->literal = cst[opnum];
				/* DISP2 is special.  */
				if ((x & SIZE) == L_2)
				  switch (OP_SIZE (q->how))
				    {
				    case SB:                  break;
				    case SW: p->literal *= 2; break;
				    case SL: p->literal *= 4; break;
				    }
			      }
			    p->reg     = rdisp[opnum];
			  }
a1979 4
	  */

	  /* Alas, since this is the only instruction with 3 arguments, 
	     decode doesn't handle them very well.  Some fix-up is required.
a1980 11
	     a) The size of dst is determined by whether src is 
	        INDEXB or INDEXW.  */

	  if (OP_KIND (code->src.type) == OP_INDEXB)
	    code->dst.type = X (OP_KIND (code->dst.type), SB);
	  else if (OP_KIND (code->src.type) == OP_INDEXW)
	    code->dst.type = X (OP_KIND (code->dst.type), SW);

	  /* b) If op3 == null, then this is the short form of the insn.
	        Dst is the dispreg of src, and op3 is the 32-bit form
		of the same register.
a1981 21

	  if (code->op3.type == 0)
	    {
	      /* Short form: src == INDEXB/INDEXW, dst == op3 == 0.
		 We get to compose dst and op3 as follows:

		     op3 is a 32-bit register, ID == src.reg.
		     dst is the same register, but 8 or 16 bits
		     depending on whether src is INDEXB or INDEXW.
	      */

	      code->op3.type = X (OP_REG, SL);
	      code->op3.reg  = code->src.reg;
	      code->op3.literal = 0;

	      if (OP_KIND (code->src.type) == OP_INDEXB)
		code->dst.type = X (OP_REG, SB);
	      else
		code->dst.type = X (OP_REG, SW);
	    }

d3154 1
a3154 3
	  if (memcmp (&code->src, &code->dst, sizeof (code->src)) == 0)
	    ea = 1;		/* unary  op */
	  else			/* binary op */
d3156 2
d3178 2
a3179 2
	  if (memcmp (&code->src, &code->dst, sizeof (code->src)) == 0)
	    ea = 1;		/* unary  op */
d3181 1
a3181 1
	    fetch (sd, &code->src, &ea);
d3202 2
a3203 2
	  if (memcmp (&code->src, &code->dst, sizeof (code->src)) == 0)
	    ea = 1;		/* unary  op */
d3205 1
a3205 1
	    fetch (sd, &code->src, &ea);
a3577 11
#if 0
	  /* Unfortunately this won't really work, because
	     when we take a breakpoint trap, R0 has a "random", 
	     user-defined value.  Don't see any immediate solution.  */
	  else if (SIM_WIFSTOPPED (h8_get_reg (sd, 0)))
	    {
	      /* Pass the stop signal up to gdb.  */
	      sim_engine_set_run_state (sd, sim_stopped, 
					SIM_WSTOPSIG (h8_get_reg (sd, 0)));
	    }
#endif
@


1.17.8.6
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d56 1
a56 1
#define SP (h8300hmode && !h8300_normal_mode ? SL : SW)
a512 1
int h8300_normal_mode  = 0;
d542 1
a542 1
      return (h8300hmode && !h8300_normal_mode)? SL : SW;
d578 1
a578 1
  if (h8300smode && !h8300_normal_mode)
d580 1
a580 1
  else if (h8300hmode && !h8300_normal_mode)
d840 2
a841 4
		  if(h8300_normal_mode)
		    cst[opnum] = ((data[1] & 0x7f) + 0x80) * 2;
		  else
		    cst[opnum] = ((data[1] & 0x7f) + 0x80) * 4;
d1777 1
a1777 1
      if (h8300smode && !h8300_normal_mode)
d1779 1
a1779 1
      else if (h8300hmode && !h8300_normal_mode)
d1953 1
a1953 1
  if (!h8300hmode || h8300_normal_mode)
d2793 1
a2793 1
	    if ((h8300hmode || h8300smode) && !h8300_normal_mode)
d2862 1
a2862 1
		if ((h8300hmode || h8300smode) && !h8300_normal_mode)
d2878 1
a2878 1
	    if ((h8300hmode || h8300smode) && !h8300_normal_mode)
d2917 1
a2917 1
	    if ((h8300sxmode || h8300hmode || h8300smode) && !h8300_normal_mode)
d2968 2
a2969 2
	    fd = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (0) : GET_W_REG (0);
	    buf_size = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (2) : GET_W_REG (2);
d3003 3
a3005 3
	    fd = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (0) : GET_W_REG (0);
	    char_ptr = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (1) : GET_W_REG (1);
	    len = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (2) : GET_W_REG (2);
d3035 3
a3037 3
	    fd = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (0) : GET_W_REG (0);
	    offset = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (1) : GET_W_REG (1);
	    origin = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (2) : GET_W_REG (2);
d3053 1
a3053 1
	    fd = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (0) : GET_W_REG (0);
d3071 1
a3071 1
	    fd = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (0) : GET_W_REG (0);
d3074 1
a3074 1
	    stat_ptr = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (1) : GET_W_REG (1);
d3123 1
a3123 1
	    filename_ptr = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (0) : GET_W_REG (0);
d3147 1
a3147 1
	    stat_ptr = (h8300hmode && !h8300_normal_mode) ? GET_L_REG (1) : GET_W_REG (1);
d3555 1
a3555 1
	  if (h8300hmode && !h8300_normal_mode)
d3587 1
a3587 1
	  if (h8300hmode && !h8300_normal_mode)
d3610 1
a3610 1
	  if (h8300hmode && !h8300_normal_mode)
d3658 10
a3667 20
   	    goto end;			/* res is vector number.  */
  
   	  tmp = h8_get_reg (sd, SP_REGNUM);
   	  if(h8300_normal_mode)
   	    {
   	      tmp -= 2;
   	      SET_MEMORY_W (tmp, code->next_pc);
   	      tmp -= 2;
   	      SET_MEMORY_W (tmp, h8_get_ccr (sd));
   	    }
   	  else
   	    {
   	      tmp -= 4;
   	      SET_MEMORY_L (tmp, code->next_pc);
   	      tmp -= 4;
   	      SET_MEMORY_L (tmp, h8_get_ccr (sd));
   	    }
   	  intMaskBit = 1;
   	  BUILDSR (sd);
 
d3676 2
a3677 4
	  if(h8300_normal_mode)
	    pc = GET_MEMORY_L (0x10 + res * 2); /* Vector addresses are 0x10,0x12,0x14 and 0x16 */
	  else
	    pc = GET_MEMORY_L (0x20 + res * 4);
d4706 1
a4706 4
      if(h8300_normal_mode)
        h8_set_pc (sd, shortval); /* PC for Normal mode is 2 bytes */
      else
        h8_set_pc (sd, intval);
d4817 1
a4817 2
  /* In Normal mode PC is 2 byte, but other registers are 4 byte */
  if ((h8300hmode || longreg) && !(rn == PC_REGNUM && h8300_normal_mode))
a4921 3

  if(machine == bfd_mach_h8300hn || machine == bfd_mach_h8300sn || machine == bfd_mach_h8300sxn)
    h8300_normal_mode = 1;
d5057 1
a5057 1
  if (h8300smode && !h8300_normal_mode)
d5059 1
a5059 1
  else if (h8300hmode && !h8300_normal_mode)
@


1.17.8.7
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@a4932 2
  h8300hmode = h8300smode = h8300sxmode = h8300_normal_mode = 0;

@


1.17.8.8
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d5055 1
a5055 1
    prog_bfd = bfd_openr (prog, NULL);
@


1.16
log
@Move include/callback.h and include/remote-sim.h to include/gdb/.
Update accordingly.
@
text
@d37 1
@


1.15
log
@	* compile.c: Fix formatting.
@
text
@d35 2
a36 2
#include "callback.h"
#include "remote-sim.h"
@


1.15.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d35 2
a36 2
#include "gdb/callback.h"
#include "gdb/remote-sim.h"
@


1.15.2.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@a36 1
#include "gdb/sim-h8300.h"
@


1.14
log
@	* compile.c: Fix formatting.
@
text
@d89 1
a89 1
  if( h8300smode ) cpu.exr = ( trace<<7 ) | intMask;
d102 1
a102 1
  if( h8300smode ) { \
d853 1
a853 1
case O(name, SB):				\
d861 1
a861 1
case O(name, SW):				\
d869 1
a869 1
case O(name, SL):				\
d879 1
a879 1
case O(name, SB):				\
d894 1
a894 1
case O(name, SW):				\
d909 1
a909 1
case O(name, SL):				\
d926 1
a926 1
case  O(name, SB):				\
d931 1
a931 1
  m=1<< fetch(&code->src);			\
d933 1
a933 1
  if(s) store (&code->dst,ea); goto next;	\
d1024 3
a1026 3
    case O(NAME,SB):  HOW; if(STORE)goto alu8;else goto just_flags_alu8;  \
    case O(NAME, SW): HOW; if(STORE)goto alu16;else goto just_flags_alu16; \
    case O(NAME,SL):  HOW; if(STORE)goto alu32;else goto just_flags_alu32;
d1030 3
a1032 3
    case O(NAME,SB): HOW; goto log8;\
    case O(NAME, SW): HOW; goto log16;\
    case O(NAME,SL): HOW; goto log32;
d1078 2
a1079 2
#define EA    ea = fetch(&code->src);
#define RD_EA ea = fetch(&code->src); rd = fetch(&code->dst);
d1142 1
a1142 1
	  if(h8300hmode||h8300smode)
d1145 1
a1145 1
	      unsigned int count = (code->opcode==O(O_EEPMOV, SW))?cpu.regs[R4_REGNUM]&0xffff:
d1150 1
a1150 1
	      if((_src+count)>=(cpu.memory+memory_size))
d1152 1
a1152 1
		  if((_src+count)>=(cpu.eightbit+0x100))
d1157 1
a1157 1
	      if((_dst+count)>=(cpu.memory+memory_size))
d1159 1
a1159 1
		  if((_dst+count)>=(cpu.eightbit+0x100))
d1166 1
a1166 1
	      cpu.regs[R4_REGNUM]&=(code->opcode==O(O_EEPMOV, SW))?(~0xffff):(~0xff);
d1251 1
a1251 1
#define GET_EXR(x) BUILDEXR();x = cpu.exr
d1255 1
a1255 1
	  res = fetch(&code->src);
d1259 1
a1259 1
	  if(code->src.type==OP_CCR)
d1261 1
a1261 1
	      GET_CCR(res);
d1263 1
a1263 1
	  else if(code->src.type==OP_EXR && h8300smode)
d1265 1
a1265 1
	      GET_EXR(res);
d1273 1
a1273 1
	  if(code->dst.type==OP_CCR)
d1277 1
a1277 1
	  else if(code->dst.type==OP_EXR && h8300smode)
d1288 1
a1288 1
	  if(code->dst.type==OP_CCR)
d1292 1
a1292 1
	  else if(code->dst.type==OP_EXR && h8300smode)
d1303 1
a1303 1
	  if(code->dst.type==OP_CCR)
d1307 1
a1307 1
	  else if(code->dst.type==OP_EXR && h8300smode)
d1413 1
a1413 1
		   t = rd & hm; c = rd & 2; v = 0; rd >>= 2; rd |= t | t >> 1 );
d1537 1
a1537 1
	  if( !h8300smode || code->src.type != X (OP_REG, SL) )
d1539 1
a1539 1
	  switch(code->src.reg)
d1684 1
a1684 1
      if(code->dst.type==OP_CCR)
d1689 1
a1689 1
      else if(code->dst.type==OP_EXR && h8300smode)
d1876 1
a1876 1
  BUILDEXR();
d1997 1
a1997 1
  if(!h8300smode && rn >=EXR_REGNUM)
@


1.13
log
@* compile.c: Add absented opcodes: LDC, STC, EEPMOV, TAS.
@
text
@d1047 4
a1050 4
       {
        cycles += code->cycles;
        insts++;
       }
d1142 14
a1155 14
		 if(h8300hmode||h8300smode)
	          {
		    register unsigned char *_src,*_dst;
		    unsigned int count = (code->opcode==O(O_EEPMOV, SW))?cpu.regs[R4_REGNUM]&0xffff:
									 cpu.regs[R4_REGNUM]&0xff;

		   _src = cpu.regs[R5_REGNUM] < memory_size ? cpu.memory+cpu.regs[R5_REGNUM] :
	           				       	      cpu.eightbit + (cpu.regs[R5_REGNUM] & 0xff);
		   if((_src+count)>=(cpu.memory+memory_size))
		   {
			   if((_src+count)>=(cpu.eightbit+0x100))
			      goto illegal;
		   }
		   _dst = cpu.regs[R6_REGNUM] < memory_size ? cpu.memory+cpu.regs[R6_REGNUM] :
d1157 14
a1170 14
		   if((_dst+count)>=(cpu.memory+memory_size))
		   {
			   if((_dst+count)>=(cpu.eightbit+0x100))
			      goto illegal;
		   }
		   memcpy(_dst,_src,count);

		   cpu.regs[R5_REGNUM]+=count;
		   cpu.regs[R6_REGNUM]+=count;
		   cpu.regs[R4_REGNUM]&=(code->opcode==O(O_EEPMOV, SW))?(~0xffff):(~0xff);
		   cycles += 2*count;
	           goto next;
	     }
	    goto illegal;
d1259 9
a1267 9
          if(code->src.type==OP_CCR)
          {
	     GET_CCR(res);
          }
          else if(code->src.type==OP_EXR && h8300smode)
          {
	     GET_EXR(res);
          }
          else
d1273 9
a1281 9
          if(code->dst.type==OP_CCR)
          {
	     GET_CCR (rd);
          }
          else if(code->dst.type==OP_EXR && h8300smode)
          {
	     GET_EXR (rd);
          }
          else
d1288 9
a1296 9
          if(code->dst.type==OP_CCR)
          {
	     GET_CCR (rd);
          }
          else if(code->dst.type==OP_EXR && h8300smode)
          {
	     GET_EXR (rd);
          }
          else
d1303 9
a1311 9
          if(code->dst.type==OP_CCR)
          {
	     GET_CCR (rd);
          }
          else if(code->dst.type==OP_EXR && h8300smode)
          {
	     GET_EXR (rd);
          }
          else
d1492 1
a1492 1
  	  if (! SIM_WIFEXITED (cpu.regs[0]) && SIM_WIFSIGNALED (cpu.regs[0])) 
d1505 1
a1505 1
	  OBITOP (O_BSET, 1, 1, ea |= m);	
d1537 14
a1550 14
          if( !h8300smode || code->src.type != X (OP_REG, SL) )
          	goto illegal;
          switch(code->src.reg)
          {
           case R0_REGNUM:
           case R1_REGNUM:
           case R4_REGNUM:
           case R5_REGNUM:
           	break;
           default:
             goto illegal;
          }
          res =  fetch (&code->src);
          store (&code->src,res|0x80);
d1685 4
a1688 4
      {
       cpu.ccr = res;
       GETSR ();
      }
d1690 4
a1693 4
      {
       cpu.exr = res;
       GETEXR ();
      }
d1695 1
a1695 1
	 goto illegal;
d1998 1
a1998 1
  	rn++;
@


1.12
log
@h8300: Add support of EXR register
@
text
@d945 22
d1140 31
a1249 1

d1253 19
d1536 16
a1929 22


#define R0_REGNUM	0
#define R1_REGNUM	1
#define R2_REGNUM	2
#define R3_REGNUM	3
#define R4_REGNUM	4
#define R5_REGNUM	5
#define R6_REGNUM	6
#define R7_REGNUM	7

#define SP_REGNUM       R7_REGNUM	/* Contains address of top of stack */
#define FP_REGNUM       R6_REGNUM	/* Contains address of executing
					 * stack frame */

#define CCR_REGNUM      8	/* Contains processor status */
#define PC_REGNUM       9	/* Contains program counter */

#define CYCLE_REGNUM    10
#define EXR_REGNUM	11      /* Contains extended processor status */
#define INST_REGNUM     11
#define TICK_REGNUM     12
@


1.11
log
@* h8300s now new target, not alias of h8300h
@
text
@d70 1
d88 3
d101 5
d424 4
d962 1
d986 2
d1199 1
d1202 10
a1211 1
	  GET_CCR (rd);
d1217 10
a1226 1
	  GET_CCR (rd);
d1232 10
a1241 1
	  GET_CCR (rd);
d1588 1
d1597 13
a1609 2
      cpu.ccr = res;
      GETSR ();
d1789 1
d1862 1
d1902 3
d1932 2
d1940 3
@


1.10
log
@*compile.c: Add additional CCR flags (I,UI,H,U)
@
text
@d707 3
a709 1
      if (h8300hmode)
d2013 2
a2014 2
set_h8300h (flag)
     int flag;
d2019 2
a2020 1
  h8300hmode = flag;
d2075 2
a2076 2
	  set_h8300h (mach == bfd_mach_h8300h
		      || mach == bfd_mach_h8300s);
d2094 4
a2097 1
  if (h8300hmode)
@


1.9
log
@
* compile.c: Change literal regnumbers to REGNUMS.
@
text
@d84 2
a85 1
#define BUILDSR()   cpu.ccr = (N << 3) | (Z << 2) | (V << 1) | C;
d91 5
a95 1
  n = (cpu.ccr >> 3) & 1;
d783 4
d946 1
a946 1
  int c, nz, v, n;
@


1.8
log
@	* compile.c: Fix formatting.
@
text
@d114 1
a114 4
#ifndef WIN32
  return time (0);
#endif
  return 0;
d155 1
a155 1
      abort ();
d608 1
a608 1
      abort ();
d997 6
a1002 2
      cycles += code->cycles;
      insts++;
d1864 1
a1864 1
    case 8:
d1867 1
a1867 1
    case 9:
d1880 1
a1880 1
    case 10:
d1884 1
a1884 1
    case 11:
d1888 1
a1888 1
    case 12:
@


1.8.6.1
log
@merge from trunk
@
text
@d35 2
a36 2
#include "gdb/callback.h"
#include "gdb/remote-sim.h"
a69 1
#define OP_EXR 11
d84 1
a84 5
#define BUILDSR()   cpu.ccr = (I << 7) | (UI << 6)| (H<<5) | (U<<4) | \
                              (N << 3) | (Z << 2) | (V<<1) | C;

#define BUILDEXR()	    \
  if (h8300smode) cpu.exr = (trace<<7) | intMask;
d90 1
a90 10
  n = (cpu.ccr >> 3) & 1;\
  u = (cpu.ccr >> 4) & 1;\
  h = (cpu.ccr >> 5) & 1;\
  ui = ((cpu.ccr >> 6) & 1);\
  intMaskBit = (cpu.ccr >> 7) & 1;

#define GETEXR()	    \
  if (h8300smode) { \
    trace = (cpu.exr >> 7) & 1;\
    intMask = cpu.exr & 7; }
d114 4
a117 1
  return time (0);	/* WinXX HAS UNIX like 'time', so why not using it? */
d158 1
a158 1
      abort (); /* ?? May be something more usefull? */
a412 4
			else if (x & EXR)
			  {
			    p->type = OP_EXR;
			  }
d611 1
a611 1
      abort (); /* ?? May be something more usefull? */
d705 1
a705 3
      if (h8300smode)
	memory_size = H8300S_MSIZE;
      else if (h8300hmode)
a780 4
#define U (u != 0)
#define H (h != 0)
#define UI (ui != 0)
#define I (intMaskBit != 0)
d832 1
a832 1
case O (name, SB):				\
d840 1
a840 1
case O (name, SW):				\
d848 1
a848 1
case O (name, SL):				\
d858 1
a858 1
case O (name, SB):				\
d873 1
a873 1
case O (name, SW):				\
d888 1
a888 1
case O (name, SL):				\
d905 1
a905 1
case O (name, SB):				\
d910 1
a910 1
  m=1<< fetch (&code->src);			\
d912 1
a912 1
  if (s) store (&code->dst,ea); goto next;	\
a923 22
#define R0_REGNUM	0
#define R1_REGNUM	1
#define R2_REGNUM	2
#define R3_REGNUM	3
#define R4_REGNUM	4
#define R5_REGNUM	5
#define R6_REGNUM	6
#define R7_REGNUM	7

#define SP_REGNUM       R7_REGNUM	/* Contains address of top of stack */
#define FP_REGNUM       R6_REGNUM	/* Contains address of executing
					 * stack frame */

#define CCR_REGNUM      8	/* Contains processor status */
#define PC_REGNUM       9	/* Contains program counter */

#define CYCLE_REGNUM    10

#define EXR_REGNUM	11
#define INST_REGNUM     12
#define TICK_REGNUM     13

d940 1
a940 2
  int c, nz, v, n, u, h, ui, intMaskBit;
  int trace, intMask;
a963 2
  GETEXR ();

d978 3
a980 3
    case O (NAME,SB):  HOW; if (STORE)goto alu8;else goto just_flags_alu8;  \
    case O (NAME, SW): HOW; if (STORE)goto alu16;else goto just_flags_alu16; \
    case O (NAME,SL):  HOW; if (STORE)goto alu32;else goto just_flags_alu32;
d984 3
a986 3
    case O (NAME,SB): HOW; goto log8;\
    case O (NAME, SW): HOW; goto log16;\
    case O (NAME,SL): HOW; goto log32;
d1000 2
a1001 6
      if (code->opcode)
	{
	  cycles += code->cycles;
	  insts++;
	}

d1028 2
a1029 2
#define EA    ea = fetch (&code->src);
#define RD_EA ea = fetch (&code->src); rd = fetch (&code->dst);
a1089 31
	case O (O_EEPMOV, SB):
	case O (O_EEPMOV, SW):
	  if (h8300hmode||h8300smode)
	    {
	      register unsigned char *_src,*_dst;
	      unsigned int count = (code->opcode == O(O_EEPMOV, SW))?cpu.regs[R4_REGNUM]&0xffff:
		cpu.regs[R4_REGNUM]&0xff;

	      _src = cpu.regs[R5_REGNUM] < memory_size ? cpu.memory+cpu.regs[R5_REGNUM] :
		cpu.eightbit + (cpu.regs[R5_REGNUM] & 0xff);
	      if ((_src+count)>=(cpu.memory+memory_size))
		{
		  if ((_src+count)>=(cpu.eightbit+0x100))
		    goto illegal;
		}
	      _dst = cpu.regs[R6_REGNUM] < memory_size ? cpu.memory+cpu.regs[R6_REGNUM] :
	           				       	      cpu.eightbit + (cpu.regs[R6_REGNUM] & 0xff);
	      if ((_dst+count)>=(cpu.memory+memory_size))
		{
		  if ((_dst+count)>=(cpu.eightbit+0x100))
		    goto illegal;
		}
	      memcpy(_dst,_src,count);

	      cpu.regs[R5_REGNUM]+=count;
	      cpu.regs[R6_REGNUM]+=count;
	      cpu.regs[R4_REGNUM]&=(code->opcode == O(O_EEPMOV, SW))?(~0xffff):(~0xff);
	      cycles += 2*count;
	      goto next;
	    }
	  goto illegal;
d1169 1
a1170 20
#define GET_EXR(x) BUILDEXR ();x = cpu.exr

	case O (O_LDC, SB):
	case O (O_LDC, SW):
	  res = fetch (&code->src);
	  goto setc;
	case O (O_STC, SB):
	case O (O_STC, SW):
	  if (code->src.type == OP_CCR)
	    {
	      GET_CCR (res);
	    }
	  else if (code->src.type == OP_EXR && h8300smode)
	    {
	      GET_EXR (res);
	    }
	  else
	    goto illegal;
	  store (&code->dst, res);
	  goto next;
d1173 1
a1173 10
	  if (code->dst.type == OP_CCR)
	    {
	      GET_CCR (rd);
	    }
	  else if (code->dst.type == OP_EXR && h8300smode)
	    {
	      GET_EXR (rd);
	    }
	  else
	    goto illegal;
d1179 1
a1179 10
	  if (code->dst.type == OP_CCR)
	    {
	      GET_CCR (rd);
	    }
	  else if (code->dst.type == OP_EXR && h8300smode)
	    {
	      GET_EXR (rd);
	    }
	  else
	    goto illegal;
d1185 1
a1185 10
	  if (code->dst.type == OP_CCR)
	    {
	      GET_CCR (rd);
	    }
	  else if (code->dst.type == OP_EXR && h8300smode)
	    {
	      GET_EXR (rd);
	    }
	  else
	    goto illegal;
d1286 1
a1286 1
		   t = rd & hm; c = rd & 2; v = 0; rd >>= 2; rd |= t | t >> 1);
d1365 1
a1365 1
  	  if (! SIM_WIFEXITED (cpu.regs[0]) && SIM_WIFSIGNALED (cpu.regs[0]))
d1378 1
a1378 1
	  OBITOP (O_BSET, 1, 1, ea |= m);
a1408 16
	case O (O_TAS, SB):
	  if (!h8300smode || code->src.type != X (OP_REG, SL))
	    goto illegal;
	  switch (code->src.reg)
	    {
	    case R0_REGNUM:
	    case R1_REGNUM:
	    case R4_REGNUM:
	    case R5_REGNUM:
	      break;
	    default:
	      goto illegal;
	    }
	  res = fetch (&code->src);
	  store (&code->src,res|0x80);
	  goto just_flags_log8;
a1531 1
        illegal:
d1540 2
a1541 13
      if (code->dst.type == OP_CCR)
	{
	  cpu.ccr = res;
	  GETSR ();
	}
      else if (code->dst.type == OP_EXR && h8300smode)
	{
	  cpu.exr = res;
	  GETEXR ();
	}
      else
	goto illegal;

a1720 1
  BUILDEXR ();
d1776 21
a1831 3
    case EXR_REGNUM:
      cpu.exr = intval;
      break;
a1858 2
  if (!h8300smode && rn >=EXR_REGNUM)
    rn++;
d1863 1
a1863 1
    case CCR_REGNUM:
d1866 1
a1866 4
    case EXR_REGNUM:
      v = cpu.exr;
      break;
    case PC_REGNUM:
d1879 1
a1879 1
    case CYCLE_REGNUM:
d1883 1
a1883 1
    case TICK_REGNUM:
d1887 1
a1887 1
    case INST_REGNUM:
d2001 2
a2002 2
set_h8300h (h_flag, s_flag)
     int h_flag, s_flag;
d2007 1
a2007 2
  h8300hmode = h_flag;
  h8300smode = s_flag;
d2062 2
a2063 2
	  set_h8300h (mach == bfd_mach_h8300h || mach == bfd_mach_h8300s,
		      mach == bfd_mach_h8300s);
d2081 1
a2081 4

  if (h8300smode)
    memory_size = H8300S_MSIZE;
  else if (h8300hmode)
@


1.8.2.1
log
@2002-05-17  Andrey Volkov  (avolkov@@sources.redhat.com)
	* compile.c: Change literal regnumbers to REGNUMS,
	  fix instruction and cycles counting.
@
text
@d114 4
a117 1
  return time (0);	/* WinXX HAS UNIX like 'time', so why not using it? */
d158 1
a158 1
      abort (); /* ?? May be something more usefull? */
d611 1
a611 1
      abort (); /* ?? May be something more usefull? */
d1000 2
a1001 6
      if (code->opcode)
       {
        cycles += code->cycles;
        insts++;
       }

d1863 1
a1863 1
    case CCR_REGNUM:
d1866 1
a1866 1
    case PC_REGNUM:
d1879 1
a1879 1
    case CYCLE_REGNUM:
d1883 1
a1883 1
    case TICK_REGNUM:
d1887 1
a1887 1
    case INST_REGNUM:
@


1.7
log
@	* compile.c: Fix comment typos.
@
text
@d55 1
a55 1
#define X(op, size)  op*4+size
d57 1
a57 1
#define SP (h8300hmode ? SL:SW)
d81 2
a82 2
#define HIGH_BYTE(x) (((x)>>8) & 0xff)
#define P(X,Y) ((X<<8) | Y)
d84 1
a84 1
#define BUILDSR()   cpu.ccr = (N << 3) | (Z << 2) | (V<<1) | C;
d93 1
a93 1
#define SEXTCHAR(x) ((char)(x))
d102 1
a102 1
#define SEXTSHORT(x) ((short)(x))
d617 1
a617 2
static
void
d693 1
a693 2
static
void
d826 3
a828 2
/*  return ((n==1) << 1) | (nz==1); */

d1392 3
a1394 2

#define MOP(bsize, signed) mop(code, bsize,signed); goto next;
d1416 2
a1417 2
		tmp = (unsigned)rd % ea;
		rd = (unsigned)rd / ea;
d1433 2
a1434 2
		tmp = (unsigned)rd % ea;
		rd = (unsigned)rd / ea;
d1700 4
a1703 1
      /*      if (cpu.regs[8] ) abort(); */
d1718 1
a1718 1
  
d2059 1
a2059 1
      if (bfd_check_format (prog_bfd, bfd_object)) 
@


1.6
log
@2000-08-10  Kazu Hirata  <kazu@@hxi.com>

	* compile.c (decode): Clean up the code.
@
text
@d469 1
a469 2
  /* find the next cache entry to use */

d478 1
a478 1
  /* Throw away its old meaning */
d481 1
a481 1
  /* set to new address */
d484 1
a484 1
  /* fill in instruction info */
d487 1
a487 1
  /* point to new cache entry */
d715 1
a715 1
      /* `msize' must be a power of two */
d762 1
a762 1
      /* initialize the seg registers */
d1726 1
a1726 1
  /* FIXME: unfinished */
d1784 1
a1784 1
					   * stack frame */
d1994 2
a1995 2
/* Indicate whether the cpu is an h8/300 or h8/300h.
   FLAG is non-zero for the h8/300h.  */
d2003 1
a2003 1
     option */
d2014 1
a2014 1
  /* FIXME: Much of the code in sim_load can be moved here */
d2019 1
a2019 1
  /* fudge our descriptor */
d2028 1
a2028 1
  /* nothing to do */
d2042 2
a2043 2
  /* FIXME: The code below that sets a specific variant of the h8/300
     being simulated should be moved to sim_open(). */
d2045 1
a2045 1
  /* See if the file is for the h8/300 or h8/300h.  */
d2072 1
a2072 1
     debugging an h8/300 or h8/300h program.
d2076 1
a2076 1
     switching between h8/300 and h8/300h programs without exiting
d2094 1
a2094 1
  /* `msize' must be a power of two */
@


1.5
log
@* compile.c (decode): Distinguish inc/dec.[wl] and adds/subs
correctly.
@
text
@d175 1
a175 1
  struct h8_opcode *q = h8_opcodes;
d182 1
a182 1
  while (q->name)
d184 1
a184 1
      op_type *nib;
a186 2
      nib = q->data.nib;

d357 2
a358 2
			    /* Reset the size, some
			       ops (like mul) have two sizes */
d457 1
a457 1
      q++;
@


1.4
log
@* build fix

2000-06-20  Frank Ch. Eigler  <fche@@redhat.com>

	* compile.c: Don't include "wait.h".
	(sim_resume): Use local SIM_WIFEXITED and SIM_WIFSIGNALED macros
	instead of WIF* from host.
@
text
@d222 4
a225 1
		  if ((looking_for & 5) != (thisnib & 5))
d298 2
@


1.3
log
@* "Dont" -> "Don't"

2000-06-13  Frank Ch. Eigler  <fche@@redhat.com>

	* compile.c, writecode.c: Correct typo.
@
text
@a32 1
#include "wait.h"
a1356 18
	  /* The format of r0 is defined by devo/include/wait.h.  */
#if 0 /* FIXME: Ugh.  A breakpoint is the sleep insn.  */
	  if (WIFEXITED (cpu.regs[0]))
	    {
	      cpu.state = SIM_STATE_EXITED;
	      cpu.exception = WEXITSTATUS (cpu.regs[0]);
	    }
	  else if (WIFSTOPPED (cpu.regs[0]))
	    {
	      cpu.state = SIM_STATE_STOPPED;
	      cpu.exception = WSTOPSIG (cpu.regs[0]);
	    }
	  else
	    {
	      cpu.state = SIM_STATE_SIGNALLED;
	      cpu.exception = WTERMSIG (cpu.regs[0]);
	    }
#else
d1360 5
a1364 1
	  if (! WIFEXITED (cpu.regs[0]) && WIFSIGNALED (cpu.regs[0]))
a1367 1
#endif
@


1.2
log
@2000-06-13  Kazu Hirata  <kazu@@hxi.com>

        * compile.c: Fix formatting.
@
text
@d447 1
a447 1
		printf ("Dont understand %x \n", looking_for);
@


1.1
log
@Initial revision
@
text
@d77 4
a111 1

a126 1

d143 1
a143 2
static
unsigned int
d156 1
a157 1
      return X (OP_MEM, SP);
d174 1
a175 2
  int bit = 0;

d178 1
d181 2
a182 1
  /* Find the exact opcode/arg combo */
d208 2
a209 2
		  looking_for = (op_type) ((int) looking_for & ~(int)
					   B31);
d212 1
d217 1
d220 1
d225 1
d232 1
a232 4
		      /*
		       * Can work out size from the
		       * register
		       */
d236 1
a236 3
		    {
		      rs = thisnib;
		    }
d238 1
a238 3
		    {
		      rd = thisnib;
		    }
d251 1
a251 4
		  abs =
		    (data[1] << 16)
		    | (data[2] << 8)
		    | (data[3]);
d260 1
d271 1
d277 1
a277 1
		  /* nothing to do */
d310 1
a310 1
		      abs |= data[len >> 1] & 0xff ;
d312 1
a312 1
		   else
d327 1
a327 1
		  /* Fill in the args */
d339 1
a339 3
			  {
			    p = &(dst->dst);
			  }
d341 1
a341 3
			  {
			    p = &(dst->src);
			  }
d343 1
a343 1
			if (x & (L_3))
d418 3
a420 6
		  /*
		     * But a jmp or a jsr gets
		     * automagically lvalued, since we
		     * branch to their address not their
		     * contents
		   */
d433 1
a433 1
		  /* And a jsr to 0xc4 is turned into a magic trap */
d447 1
a447 3
		{
		  printf ("Dont understand %x \n", looking_for);
		}
d458 1
a461 1

d1718 1
a1718 1
	  poll_count = 100;
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a76 4
/* The rate at which to call the host's poll_quit callback. */

#define POLL_QUIT_INTERVAL 0x80000

d1729 1
a1729 1
	  poll_count = POLL_QUIT_INTERVAL;
@

