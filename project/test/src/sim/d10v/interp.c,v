head	1.21;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.21
	gdb_7_6-2013-04-26-release:1.21
	gdb_7_6-branch:1.21.0.4
	gdb_7_6-2013-03-12-branchpoint:1.21
	gdb_7_5_1-2012-11-29-release:1.21
	gdb_7_5-2012-08-17-release:1.21
	gdb_7_5-branch:1.21.0.2
	gdb_7_5-2012-07-18-branchpoint:1.21
	gdb_7_4_1-2012-04-26-release:1.19
	gdb_7_4-2012-01-24-release:1.19
	gdb_7_4-branch:1.19.0.6
	gdb_7_4-2011-12-13-branchpoint:1.19
	gdb_7_3_1-2011-09-04-release:1.19
	gdb_7_3-2011-07-26-release:1.19
	gdb_7_3-branch:1.19.0.4
	gdb_7_3-2011-04-01-branchpoint:1.19
	gdb_7_2-2010-09-02-release:1.19
	gdb_7_2-branch:1.19.0.2
	gdb_7_2-2010-07-07-branchpoint:1.19
	gdb_7_1-2010-03-18-release:1.18
	gdb_7_1-branch:1.18.0.36
	gdb_7_1-2010-02-18-branchpoint:1.18
	gdb_7_0_1-2009-12-22-release:1.18
	gdb_7_0-2009-10-06-release:1.18
	gdb_7_0-branch:1.18.0.34
	gdb_7_0-2009-09-16-branchpoint:1.18
	arc-sim-20090309:1.18
	msnyder-checkpoint-072509-branch:1.18.0.32
	msnyder-checkpoint-072509-branchpoint:1.18
	arc-insight_6_8-branch:1.18.0.30
	arc-insight_6_8-branchpoint:1.18
	insight_6_8-branch:1.18.0.28
	insight_6_8-branchpoint:1.18
	reverse-20081226-branch:1.18.0.26
	reverse-20081226-branchpoint:1.18
	multiprocess-20081120-branch:1.18.0.24
	multiprocess-20081120-branchpoint:1.18
	reverse-20080930-branch:1.18.0.22
	reverse-20080930-branchpoint:1.18
	reverse-20080717-branch:1.18.0.20
	reverse-20080717-branchpoint:1.18
	msnyder-reverse-20080609-branch:1.18.0.18
	msnyder-reverse-20080609-branchpoint:1.18
	drow-reverse-20070409-branch:1.18.0.16
	drow-reverse-20070409-branchpoint:1.18
	gdb_6_8-2008-03-27-release:1.18
	gdb_6_8-branch:1.18.0.14
	gdb_6_8-2008-02-26-branchpoint:1.18
	gdb_6_7_1-2007-10-29-release:1.18
	gdb_6_7-2007-10-10-release:1.18
	gdb_6_7-branch:1.18.0.12
	gdb_6_7-2007-09-07-branchpoint:1.18
	insight_6_6-20070208-release:1.18
	gdb_6_6-2006-12-18-release:1.18
	gdb_6_6-branch:1.18.0.10
	gdb_6_6-2006-11-15-branchpoint:1.18
	insight_6_5-20061003-release:1.18
	gdb-csl-symbian-6_4_50_20060226-12:1.17
	gdb-csl-sourcerygxx-3_4_4-25:1.16.16.1
	nickrob-async-20060828-mergepoint:1.18
	gdb-csl-symbian-6_4_50_20060226-11:1.17
	gdb-csl-sourcerygxx-4_1-17:1.17
	gdb-csl-20060226-branch-local-2:1.17
	gdb-csl-sourcerygxx-4_1-14:1.17
	gdb-csl-sourcerygxx-4_1-13:1.17
	gdb-csl-sourcerygxx-4_1-12:1.17
	gdb-csl-sourcerygxx-3_4_4-21:1.17
	gdb_6_5-20060621-release:1.18
	gdb-csl-sourcerygxx-4_1-9:1.17
	gdb-csl-sourcerygxx-4_1-8:1.17
	gdb-csl-sourcerygxx-4_1-7:1.17
	gdb-csl-arm-2006q1-6:1.17
	gdb-csl-sourcerygxx-4_1-6:1.17
	gdb-csl-symbian-6_4_50_20060226-10:1.17
	gdb-csl-symbian-6_4_50_20060226-9:1.17
	gdb-csl-symbian-6_4_50_20060226-8:1.17
	gdb-csl-coldfire-4_1-11:1.17
	gdb-csl-sourcerygxx-3_4_4-19:1.17
	gdb-csl-coldfire-4_1-10:1.17
	gdb_6_5-branch:1.18.0.8
	gdb_6_5-2006-05-14-branchpoint:1.18
	gdb-csl-sourcerygxx-4_1-5:1.17
	nickrob-async-20060513-branch:1.18.0.6
	nickrob-async-20060513-branchpoint:1.18
	gdb-csl-sourcerygxx-4_1-4:1.17
	msnyder-reverse-20060502-branch:1.18.0.4
	msnyder-reverse-20060502-branchpoint:1.18
	gdb-csl-morpho-4_1-4:1.17
	gdb-csl-sourcerygxx-3_4_4-17:1.17
	readline_5_1-import-branch:1.18.0.2
	readline_5_1-import-branchpoint:1.18
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.17
	gdb-csl-symbian-20060226-branch:1.17.0.8
	gdb-csl-symbian-20060226-branchpoint:1.17
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.17
	msnyder-reverse-20060331-branch:1.17.0.6
	msnyder-reverse-20060331-branchpoint:1.17
	gdb-csl-available-20060303-branch:1.17.0.4
	gdb-csl-available-20060303-branchpoint:1.17
	gdb-csl-20060226-branch:1.17.0.2
	gdb-csl-20060226-branchpoint:1.17
	gdb_6_4-20051202-release:1.16
	msnyder-fork-checkpoint-branch:1.16.0.18
	msnyder-fork-checkpoint-branchpoint:1.16
	gdb-csl-gxxpro-6_3-branch:1.16.0.16
	gdb-csl-gxxpro-6_3-branchpoint:1.16
	gdb_6_4-branch:1.16.0.14
	gdb_6_4-2005-11-01-branchpoint:1.16
	gdb-csl-arm-20051020-branch:1.16.0.12
	gdb-csl-arm-20051020-branchpoint:1.16
	msnyder-tracepoint-checkpoint-branch:1.16.0.10
	msnyder-tracepoint-checkpoint-branchpoint:1.16
	gdb-csl-arm-20050325-2005-q1b:1.16
	gdb-csl-arm-20050325-2005-q1a:1.16
	csl-arm-20050325-branch:1.16.0.8
	csl-arm-20050325-branchpoint:1.16
	gdb_6_3-20041109-release:1.16
	gdb_6_3-branch:1.16.0.4
	gdb_6_3-20041019-branchpoint:1.16
	drow_intercu-merge-20040921:1.16
	drow_intercu-merge-20040915:1.16
	jimb-gdb_6_2-e500-branch:1.16.0.6
	jimb-gdb_6_2-e500-branchpoint:1.16
	gdb_6_2-20040730-release:1.16
	gdb_6_2-branch:1.16.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.16
	gdb_6_1_1-20040616-release:1.15
	gdb_6_1-2004-04-05-release:1.15
	drow_intercu-merge-20040402:1.15
	drow_intercu-merge-20040327:1.15
	ezannoni_pie-20040323-branch:1.15.0.20
	ezannoni_pie-20040323-branchpoint:1.15
	cagney_tramp-20040321-mergepoint:1.15
	cagney_tramp-20040309-branch:1.15.0.18
	cagney_tramp-20040309-branchpoint:1.15
	gdb_6_1-branch:1.15.0.16
	gdb_6_1-2004-03-01-gmt-branchpoint:1.15
	drow_intercu-20040221-branch:1.15.0.14
	drow_intercu-20040221-branchpoint:1.15
	cagney_bfdfile-20040213-branch:1.15.0.12
	cagney_bfdfile-20040213-branchpoint:1.15
	drow-cplus-merge-20040208:1.15
	carlton_dictionary-20040126-merge:1.15
	cagney_bigcore-20040122-branch:1.15.0.10
	cagney_bigcore-20040122-branchpoint:1.15
	drow-cplus-merge-20040113:1.15
	drow-cplus-merge-20031224:1.15
	drow-cplus-merge-20031220:1.15
	carlton_dictionary-20031215-merge:1.15
	drow-cplus-merge-20031214:1.15
	carlton-dictionary-20031111-merge:1.15
	gdb_6_0-2003-10-04-release:1.15
	kettenis_sparc-20030918-branch:1.15.0.8
	kettenis_sparc-20030918-branchpoint:1.15
	carlton_dictionary-20030917-merge:1.15
	ezannoni_pie-20030916-branchpoint:1.15
	ezannoni_pie-20030916-branch:1.15.0.6
	cagney_x86i386-20030821-branch:1.15.0.4
	cagney_x86i386-20030821-branchpoint:1.15
	carlton_dictionary-20030805-merge:1.15
	carlton_dictionary-20030627-merge:1.15
	gdb_6_0-branch:1.15.0.2
	gdb_6_0-2003-06-23-branchpoint:1.15
	jimb-ppc64-linux-20030613-branch:1.14.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.14
	cagney_convert-20030606-branch:1.14.0.10
	cagney_convert-20030606-branchpoint:1.14
	cagney_writestrings-20030508-branch:1.14.0.8
	cagney_writestrings-20030508-branchpoint:1.14
	jimb-ppc64-linux-20030528-branch:1.14.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.14
	carlton_dictionary-20030523-merge:1.14
	cagney_fileio-20030521-branch:1.14.0.4
	cagney_fileio-20030521-branchpoint:1.14
	kettenis_i386newframe-20030517-mergepoint:1.14
	jimb-ppc64-linux-20030509-branch:1.14.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.14
	kettenis_i386newframe-20030504-mergepoint:1.13
	carlton_dictionary-20030430-merge:1.13
	kettenis_i386newframe-20030419-branch:1.13.0.16
	kettenis_i386newframe-20030419-branchpoint:1.13
	carlton_dictionary-20030416-merge:1.13
	cagney_frameaddr-20030409-mergepoint:1.13
	kettenis_i386newframe-20030406-branch:1.13.0.14
	kettenis_i386newframe-20030406-branchpoint:1.13
	cagney_frameaddr-20030403-branchpoint:1.13
	cagney_frameaddr-20030403-branch:1.13.0.12
	cagney_framebase-20030330-mergepoint:1.13
	cagney_framebase-20030326-branch:1.13.0.10
	cagney_framebase-20030326-branchpoint:1.13
	cagney_lazyid-20030317-branch:1.13.0.8
	cagney_lazyid-20030317-branchpoint:1.13
	kettenis-i386newframe-20030316-mergepoint:1.13
	offbyone-20030313-branch:1.13.0.6
	offbyone-20030313-branchpoint:1.13
	kettenis-i386newframe-20030308-branch:1.13.0.4
	kettenis-i386newframe-20030308-branchpoint:1.13
	carlton_dictionary-20030305-merge:1.13
	cagney_offbyone-20030303-branch:1.13.0.2
	cagney_offbyone-20030303-branchpoint:1.13
	carlton_dictionary-20030207-merge:1.12
	interps-20030202-branch:1.12.0.14
	interps-20030202-branchpoint:1.12
	cagney-unwind-20030108-branch:1.12.0.12
	cagney-unwind-20030108-branchpoint:1.12
	carlton_dictionary-20021223-merge:1.12
	gdb_5_3-2002-12-12-release:1.12
	carlton_dictionary-20021115-merge:1.12
	kseitz_interps-20021105-merge:1.12
	kseitz_interps-20021103-merge:1.12
	drow-cplus-merge-20021020:1.12
	drow-cplus-merge-20021025:1.12
	carlton_dictionary-20021025-merge:1.12
	carlton_dictionary-20021011-merge:1.12
	drow-cplus-branch:1.12.0.10
	drow-cplus-branchpoint:1.12
	kseitz_interps-20020930-merge:1.12
	carlton_dictionary-20020927-merge:1.12
	carlton_dictionary-branch:1.12.0.8
	carlton_dictionary-20020920-branchpoint:1.12
	gdb_5_3-branch:1.12.0.6
	gdb_5_3-2002-09-04-branchpoint:1.12
	kseitz_interps-20020829-merge:1.12
	cagney_sysregs-20020825-branch:1.12.0.4
	cagney_sysregs-20020825-branchpoint:1.12
	readline_4_3-import-branch:1.12.0.2
	readline_4_3-import-branchpoint:1.12
	gdb_5_2_1-2002-07-23-release:1.6
	kseitz_interps-20020528-branch:1.8.0.2
	kseitz_interps-20020528-branchpoint:1.8
	cagney_regbuf-20020515-branch:1.6.0.6
	cagney_regbuf-20020515-branchpoint:1.6
	jimb-macro-020506-branch:1.6.0.4
	jimb-macro-020506-branchpoint:1.6
	gdb_5_2-2002-04-29-release:1.6
	gdb_5_2-branch:1.6.0.2
	gdb_5_2-2002-03-03-branchpoint:1.6
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.6
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.4
	gdb_5_1-2001-07-29-branchpoint:1.5
	insight-precleanup-2001-01-01:1.5
	gdb-premipsmulti-2000-06-06-branch:1.5.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.5
	gdb_5_0-2000-05-19-release:1.3.2.1
	gdb_4_18_2-2000-05-18-release:1.3.2.1
	gdb_4_95_1-2000-05-11-snapshot:1.3.2.1
	gdb_4_95_0-2000-04-27-snapshot:1.3
	gdb_5_0-2000-04-10-branch:1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.3
	repo-unification-2000-02-06:1.1.1.5
	gdb-2000-02-04:1.1.1.5
	gdb-2000-02-02:1.1.1.5
	gdb-2000-02-01:1.1.1.5
	gdb-2000-01-31:1.1.1.5
	gdb-2000-01-26:1.1.1.5
	gdb-2000-01-24:1.1.1.5
	gdb-2000-01-17:1.1.1.5
	gdb-2000-01-10:1.1.1.5
	gdb-2000-01-05:1.1.1.5
	gdb-1999-12-21:1.1.1.4
	gdb-1999-12-13:1.1.1.4
	gdb-1999-12-07:1.1.1.4
	gdb-1999-12-06:1.1.1.4
	gdb-1999-11-16:1.1.1.4
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.21
date	2012.06.19.22.46.57;	author brobecke;	state Exp;
branches;
next	1.20;

1.20
date	2012.05.24.16.51.42;	author palves;	state Exp;
branches;
next	1.19;

1.19
date	2010.04.14.07.38.04;	author vapier;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.18.09.15.29;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.28.18.33.03;	author mmitchel;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.29.00.54.00;	author cagney;	state Exp;
branches
	1.16.16.1;
next	1.15;

1.15
date	2003.06.22.13.38.28;	author cagney;	state Exp;
branches
	1.15.14.1;
next	1.14;

1.14
date	2003.05.07.19.21.12;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.27.23.26.33;	author cagney;	state Exp;
branches
	1.13.16.1;
next	1.12;

1.12
date	2002.06.15.11.01.34;	author trix;	state Exp;
branches
	1.12.8.1
	1.12.10.1;
next	1.11;

1.11
date	2002.06.09.15.45.46;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.08.22.19.56;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.01.18.15.43;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.28.15.49.52;	author ezannoni;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2002.05.24.00.12.16;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.02.00.50.38;	author juanito;	state Exp;
branches
	1.6.6.1;
next	1.5;

1.5
date	2000.05.03.09.26.07;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.18.07.55.35;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.22.08.52.21;	author cagney;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.02.09.05.08.42;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.00;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.16.16.1
date	2005.11.17.06.22.44;	author mmitchel;	state Exp;
branches;
next	;

1.15.14.1
date	2004.09.16.17.02.04;	author drow;	state Exp;
branches;
next	;

1.13.16.1
date	2003.05.18.09.44.51;	author kettenis;	state Exp;
branches;
next	;

1.12.8.1
date	2003.03.06.00.56.41;	author carlton;	state Exp;
branches;
next	1.12.8.2;

1.12.8.2
date	2003.05.23.18.40.57;	author carlton;	state Exp;
branches;
next	1.12.8.3;

1.12.8.3
date	2003.06.27.21.50.32;	author carlton;	state Exp;
branches;
next	;

1.12.10.1
date	2003.12.14.20.28.19;	author drow;	state Exp;
branches;
next	;

1.8.2.1
date	2002.06.20.01.39.14;	author kseitz;	state Exp;
branches;
next	;

1.6.6.1
date	2002.06.15.16.43.23;	author cagney;	state Exp;
branches;
next	1.6.6.2;

1.6.6.2
date	2002.06.21.15.48.36;	author cagney;	state Exp;
branches;
next	;

1.3.2.1
date	2000.05.03.09.25.43;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.35.00;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.31.48;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.09.13.21.39.35;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.11.17.02.30.58;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.01.06.03.07.13;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.21
log
@include "config.h" instead of BFD's sysdep.h in d10v/interp.c

The change of include file introduces some new warnings about functions
being used without a prototype. So a few more system includes have been
added to compensate for that.

sim/d10v/ChangeLog:

        * interp.c: #include "config.h" instead of "sysdep.h".
        Add conditional include of string.h or strings.h, as well as
        conditional include of stdlib.h.
@
text
@#include "config.h"
#include <signal.h>
#include "bfd.h"
#include "gdb/callback.h"
#include "gdb/remote-sim.h"

#include "d10v_sim.h"
#include "gdb/sim-d10v.h"
#include "gdb/signals.h"

#ifdef HAVE_STRING_H
#include <string.h>
#else
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif /* HAVE_STRING_H */
#endif /* HAVE_STRINGS_H */

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

enum _leftright { LEFT_FIRST, RIGHT_FIRST };

static char *myname;
static SIM_OPEN_KIND sim_kind;
int d10v_debug;

/* Set this to true to get the previous segment layout. */

int old_segment_mapping;

host_callback *d10v_callback;
unsigned long ins_type_counters[ (int)INS_MAX ];

uint16 OP[4];

static int init_text_p = 0;
/* non-zero if we opened prog_bfd */
static int prog_bfd_was_opened_p;
bfd *prog_bfd;
asection *text;
bfd_vma text_start;
bfd_vma text_end;

static long hash PARAMS ((long insn, int format));
static struct hash_entry *lookup_hash PARAMS ((uint32 ins, int size));
static void get_operands PARAMS ((struct simops *s, uint32 ins));
static void do_long PARAMS ((uint32 ins));
static void do_2_short PARAMS ((uint16 ins1, uint16 ins2, enum _leftright leftright));
static void do_parallel PARAMS ((uint16 ins1, uint16 ins2));
static char *add_commas PARAMS ((char *buf, int sizeof_buf, unsigned long value));
extern void sim_set_profile PARAMS ((int n));
extern void sim_set_profile_size PARAMS ((int n));
static INLINE uint8 *map_memory (unsigned phys_addr);

#ifdef NEED_UI_LOOP_HOOK
/* How often to run the ui_loop update, when in use */
#define UI_LOOP_POLL_INTERVAL 0x14000

/* Counter for the ui_loop_hook update */
static long ui_loop_hook_counter = UI_LOOP_POLL_INTERVAL;

/* Actual hook to call to run through gdb's gui event loop */
extern int (*deprecated_ui_loop_hook) PARAMS ((int signo));
#endif /* NEED_UI_LOOP_HOOK */

#ifndef INLINE
#if defined(__GNUC__) && defined(__OPTIMIZE__)
#define INLINE __inline__
#else
#define INLINE
#endif
#endif

#define MAX_HASH  63
struct hash_entry
{
  struct hash_entry *next;
  uint32 opcode;
  uint32 mask;
  int size;
  struct simops *ops;
};

struct hash_entry hash_table[MAX_HASH+1];

INLINE static long 
hash(insn, format)
     long insn;
     int format;
{
  if (format & LONG_OPCODE)
    return ((insn & 0x3F000000) >> 24);
  else
    return((insn & 0x7E00) >> 9);
}

INLINE static struct hash_entry *
lookup_hash (ins, size)
     uint32 ins;
     int size;
{
  struct hash_entry *h;

  if (size)
    h = &hash_table[(ins & 0x3F000000) >> 24];
  else
    h = &hash_table[(ins & 0x7E00) >> 9];

  while ((ins & h->mask) != h->opcode || h->size != size)
    {
      if (h->next == NULL)
	{
	  State.exception = SIGILL;
	  State.pc_changed = 1; /* Don't increment the PC. */
	  return NULL;
	}
      h = h->next;
    }
  return (h);
}

INLINE static void
get_operands (struct simops *s, uint32 ins)
{
  int i, shift, bits, flags;
  uint32 mask;
  for (i=0; i < s->numops; i++)
    {
      shift = s->operands[3*i];
      bits = s->operands[3*i+1];
      flags = s->operands[3*i+2];
      mask = 0x7FFFFFFF >> (31 - bits);
      OP[i] = (ins >> shift) & mask;
    }
  /* FIXME: for tracing, update values that need to be updated each
     instruction decode cycle */
  State.trace.psw = PSW;
}

bfd_vma
decode_pc ()
{
  asection *s;
  if (!init_text_p && prog_bfd != NULL)
    {
      init_text_p = 1;
      for (s = prog_bfd->sections; s; s = s->next)
	if (strcmp (bfd_get_section_name (prog_bfd, s), ".text") == 0)
	  {
	    text = s;
	    text_start = bfd_get_section_vma (prog_bfd, s);
	    text_end = text_start + bfd_section_size (prog_bfd, s);
	    break;
	  }
    }

  return (PC << 2) + text_start;
}

static void
do_long (ins)
     uint32 ins;
{
  struct hash_entry *h;
#ifdef DEBUG
  if ((d10v_debug & DEBUG_INSTRUCTION) != 0)
    (*d10v_callback->printf_filtered) (d10v_callback, "do_long 0x%x\n", ins);
#endif
  h = lookup_hash (ins, 1);
  if (h == NULL)
    return;
  get_operands (h->ops, ins);
  State.ins_type = INS_LONG;
  ins_type_counters[ (int)State.ins_type ]++;
  (h->ops->func)();
}

static void
do_2_short (ins1, ins2, leftright)
     uint16 ins1, ins2;
     enum _leftright leftright;
{
  struct hash_entry *h;
  enum _ins_type first, second;

#ifdef DEBUG
  if ((d10v_debug & DEBUG_INSTRUCTION) != 0)
    (*d10v_callback->printf_filtered) (d10v_callback, "do_2_short 0x%x (%s) -> 0x%x\n",
				       ins1, (leftright) ? "left" : "right", ins2);
#endif

  if (leftright == LEFT_FIRST)
    {
      first = INS_LEFT;
      second = INS_RIGHT;
      ins_type_counters[ (int)INS_LEFTRIGHT ]++;
    }
  else
    {
      first = INS_RIGHT;
      second = INS_LEFT;
      ins_type_counters[ (int)INS_RIGHTLEFT ]++;
    }

  /* Issue the first instruction */
  h = lookup_hash (ins1, 0);
  if (h == NULL)
    return;
  get_operands (h->ops, ins1);
  State.ins_type = first;
  ins_type_counters[ (int)State.ins_type ]++;
  (h->ops->func)();

  /* Issue the second instruction (if the PC hasn't changed) */
  if (!State.pc_changed && !State.exception)
    {
      /* finish any existing instructions */
      SLOT_FLUSH ();
      h = lookup_hash (ins2, 0);
      if (h == NULL)
	return;
      get_operands (h->ops, ins2);
      State.ins_type = second;
      ins_type_counters[ (int)State.ins_type ]++;
      ins_type_counters[ (int)INS_CYCLES ]++;
      (h->ops->func)();
    }
  else if (!State.exception)
    ins_type_counters[ (int)INS_COND_JUMP ]++;
}

static void
do_parallel (ins1, ins2)
     uint16 ins1, ins2;
{
  struct hash_entry *h1, *h2;
#ifdef DEBUG
  if ((d10v_debug & DEBUG_INSTRUCTION) != 0)
    (*d10v_callback->printf_filtered) (d10v_callback, "do_parallel 0x%x || 0x%x\n", ins1, ins2);
#endif
  ins_type_counters[ (int)INS_PARALLEL ]++;
  h1 = lookup_hash (ins1, 0);
  if (h1 == NULL)
    return;
  h2 = lookup_hash (ins2, 0);
  if (h2 == NULL)
    return;

  if (h1->ops->exec_type == PARONLY)
    {
      get_operands (h1->ops, ins1);
      State.ins_type = INS_LEFT_COND_TEST;
      ins_type_counters[ (int)State.ins_type ]++;
      (h1->ops->func)();
      if (State.exe)
	{
	  ins_type_counters[ (int)INS_COND_TRUE ]++;
	  get_operands (h2->ops, ins2);
	  State.ins_type = INS_RIGHT_COND_EXE;
	  ins_type_counters[ (int)State.ins_type ]++;
	  (h2->ops->func)();
	}
      else
	ins_type_counters[ (int)INS_COND_FALSE ]++;
    }
  else if (h2->ops->exec_type == PARONLY)
    {
      get_operands (h2->ops, ins2);
      State.ins_type = INS_RIGHT_COND_TEST;
      ins_type_counters[ (int)State.ins_type ]++;
      (h2->ops->func)();
      if (State.exe)
	{
	  ins_type_counters[ (int)INS_COND_TRUE ]++;
	  get_operands (h1->ops, ins1);
	  State.ins_type = INS_LEFT_COND_EXE;
	  ins_type_counters[ (int)State.ins_type ]++;
	  (h1->ops->func)();
	}
      else
	ins_type_counters[ (int)INS_COND_FALSE ]++;
    }
  else
    {
      get_operands (h1->ops, ins1);
      State.ins_type = INS_LEFT_PARALLEL;
      ins_type_counters[ (int)State.ins_type ]++;
      (h1->ops->func)();
      if (!State.exception)
	{
	  get_operands (h2->ops, ins2);
	  State.ins_type = INS_RIGHT_PARALLEL;
	  ins_type_counters[ (int)State.ins_type ]++;
	  (h2->ops->func)();
	}
    }
}
 
static char *
add_commas(buf, sizeof_buf, value)
     char *buf;
     int sizeof_buf;
     unsigned long value;
{
  int comma = 3;
  char *endbuf = buf + sizeof_buf - 1;

  *--endbuf = '\0';
  do {
    if (comma-- == 0)
      {
	*--endbuf = ',';
	comma = 2;
      }

    *--endbuf = (value % 10) + '0';
  } while ((value /= 10) != 0);

  return endbuf;
}

void
sim_size (power)
     int power;

{
  int i;
  for (i = 0; i < IMEM_SEGMENTS; i++)
    {
      if (State.mem.insn[i])
	free (State.mem.insn[i]);
    }
  for (i = 0; i < DMEM_SEGMENTS; i++)
    {
      if (State.mem.data[i])
	free (State.mem.data[i]);
    }
  for (i = 0; i < UMEM_SEGMENTS; i++)
    {
      if (State.mem.unif[i])
	free (State.mem.unif[i]);
    }
  /* Always allocate dmem segment 0.  This contains the IMAP and DMAP
     registers. */
  State.mem.data[0] = calloc (1, SEGMENT_SIZE);
}

/* For tracing - leave info on last access around. */
static char *last_segname = "invalid";
static char *last_from = "invalid";
static char *last_to = "invalid";

enum
  {
    IMAP0_OFFSET = 0xff00,
    DMAP0_OFFSET = 0xff08,
    DMAP2_SHADDOW = 0xff04,
    DMAP2_OFFSET = 0xff0c
  };

static void
set_dmap_register (int reg_nr, unsigned long value)
{
  uint8 *raw = map_memory (SIM_D10V_MEMORY_DATA
			   + DMAP0_OFFSET + 2 * reg_nr);
  WRITE_16 (raw, value);
#ifdef DEBUG
  if ((d10v_debug & DEBUG_MEMORY))
    {
      (*d10v_callback->printf_filtered)
	(d10v_callback, "mem: dmap%d=0x%04lx\n", reg_nr, value);
    }
#endif
}

static unsigned long
dmap_register (void *regcache, int reg_nr)
{
  uint8 *raw = map_memory (SIM_D10V_MEMORY_DATA
			   + DMAP0_OFFSET + 2 * reg_nr);
  return READ_16 (raw);
}

static void
set_imap_register (int reg_nr, unsigned long value)
{
  uint8 *raw = map_memory (SIM_D10V_MEMORY_DATA
			   + IMAP0_OFFSET + 2 * reg_nr);
  WRITE_16 (raw, value);
#ifdef DEBUG
  if ((d10v_debug & DEBUG_MEMORY))
    {
      (*d10v_callback->printf_filtered)
	(d10v_callback, "mem: imap%d=0x%04lx\n", reg_nr, value);
    }
#endif
}

static unsigned long
imap_register (void *regcache, int reg_nr)
{
  uint8 *raw = map_memory (SIM_D10V_MEMORY_DATA
			   + IMAP0_OFFSET + 2 * reg_nr);
  return READ_16 (raw);
}

enum
  {
    HELD_SPI_IDX = 0,
    HELD_SPU_IDX = 1
  };

static unsigned long
spu_register (void)
{
  if (PSW_SM)
    return GPR (SP_IDX);
  else
    return HELD_SP (HELD_SPU_IDX);
}

static unsigned long
spi_register (void)
{
  if (!PSW_SM)
    return GPR (SP_IDX);
  else
    return HELD_SP (HELD_SPI_IDX);
}

static void
set_spi_register (unsigned long value)
{
  if (!PSW_SM)
    SET_GPR (SP_IDX, value);
  SET_HELD_SP (HELD_SPI_IDX, value);
}

static void
set_spu_register  (unsigned long value)
{
  if (PSW_SM)
    SET_GPR (SP_IDX, value);
  SET_HELD_SP (HELD_SPU_IDX, value);
}

/* Given a virtual address in the DMAP address space, translate it
   into a physical address. */

unsigned long
sim_d10v_translate_dmap_addr (unsigned long offset,
			      int nr_bytes,
			      unsigned long *phys,
			      void *regcache,
			      unsigned long (*dmap_register) (void *regcache,
							      int reg_nr))
{
  short map;
  int regno;
  last_from = "logical-data";
  if (offset >= DMAP_BLOCK_SIZE * SIM_D10V_NR_DMAP_REGS)
    {
      /* Logical address out side of data segments, not supported */
      return 0;
    }
  regno = (offset / DMAP_BLOCK_SIZE);
  offset = (offset % DMAP_BLOCK_SIZE);
  if ((offset % DMAP_BLOCK_SIZE) + nr_bytes > DMAP_BLOCK_SIZE)
    {
      /* Don't cross a BLOCK boundary */
      nr_bytes = DMAP_BLOCK_SIZE - (offset % DMAP_BLOCK_SIZE);
    }
  map = dmap_register (regcache, regno);
  if (regno == 3)
    {
      /* Always maps to data memory */
      int iospi = (offset / 0x1000) % 4;
      int iosp = (map >> (4 * (3 - iospi))) % 0x10;
      last_to = "io-space";
      *phys = (SIM_D10V_MEMORY_DATA + (iosp * 0x10000) + 0xc000 + offset);
    }
  else
    {
      int sp = ((map & 0x3000) >> 12);
      int segno = (map & 0x3ff);
      switch (sp)
	{
	case 0: /* 00: Unified memory */
	  *phys = SIM_D10V_MEMORY_UNIFIED + (segno * DMAP_BLOCK_SIZE) + offset;
	  last_to = "unified";
	  break;
	case 1: /* 01: Instruction Memory */
	  *phys = SIM_D10V_MEMORY_INSN + (segno * DMAP_BLOCK_SIZE) + offset;
	  last_to = "chip-insn";
	  break;
	case 2: /* 10: Internal data memory */
	  *phys = SIM_D10V_MEMORY_DATA + (segno << 16) + (regno * DMAP_BLOCK_SIZE) + offset;
	  last_to = "chip-data";
	  break;
	case 3: /* 11: Reserved */
	  return 0;
	}
    }
  return nr_bytes;
}

/* Given a virtual address in the IMAP address space, translate it
   into a physical address. */

unsigned long
sim_d10v_translate_imap_addr (unsigned long offset,
			      int nr_bytes,
			      unsigned long *phys,
			      void *regcache,
			      unsigned long (*imap_register) (void *regcache,
							      int reg_nr))
{
  short map;
  int regno;
  int sp;
  int segno;
  last_from = "logical-insn";
  if (offset >= (IMAP_BLOCK_SIZE * SIM_D10V_NR_IMAP_REGS))
    {
      /* Logical address outside of IMAP segments, not supported */
      return 0;
    }
  regno = (offset / IMAP_BLOCK_SIZE);
  offset = (offset % IMAP_BLOCK_SIZE);
  if (offset + nr_bytes > IMAP_BLOCK_SIZE)
    {
      /* Don't cross a BLOCK boundary */
      nr_bytes = IMAP_BLOCK_SIZE - offset;
    }
  map = imap_register (regcache, regno);
  sp = (map & 0x3000) >> 12;
  segno = (map & 0x007f);
  switch (sp)
    {
    case 0: /* 00: unified memory */
      *phys = SIM_D10V_MEMORY_UNIFIED + (segno << 17) + offset;
      last_to = "unified";
      break;
    case 1: /* 01: instruction memory */
      *phys = SIM_D10V_MEMORY_INSN + (IMAP_BLOCK_SIZE * regno) + offset;
      last_to = "chip-insn";
      break;
    case 2: /*10*/
      /* Reserved. */
      return 0;
    case 3: /* 11: for testing  - instruction memory */
      offset = (offset % 0x800);
      *phys = SIM_D10V_MEMORY_INSN + offset;
      if (offset + nr_bytes > 0x800)
	/* don't cross VM boundary */
	nr_bytes = 0x800 - offset;
      last_to = "test-insn";
      break;
    }
  return nr_bytes;
}

unsigned long
sim_d10v_translate_addr (unsigned long memaddr,
			 int nr_bytes,
			 unsigned long *targ_addr,
			 void *regcache,
			 unsigned long (*dmap_register) (void *regcache,
							 int reg_nr),
			 unsigned long (*imap_register) (void *regcache,
							 int reg_nr))
{
  unsigned long phys;
  unsigned long seg;
  unsigned long off;

  last_from = "unknown";
  last_to = "unknown";

  seg = (memaddr >> 24);
  off = (memaddr & 0xffffffL);

  /* However, if we've asked to use the previous generation of segment
     mapping, rearrange the segments as follows. */

  if (old_segment_mapping)
    {
      switch (seg)
	{
	case 0x00: /* DMAP translated memory */
	  seg = 0x10;
	  break;
	case 0x01: /* IMAP translated memory */
	  seg = 0x11;
	  break;
	case 0x10: /* On-chip data memory */
	  seg = 0x02;
	  break;
	case 0x11: /* On-chip insn memory */
	  seg = 0x01;
	  break;
	case 0x12: /* Unified memory */
	  seg = 0x00;
	  break;
	}
    }

  switch (seg)
    {
    case 0x00:			/* Physical unified memory */
      last_from = "phys-unified";
      last_to = "unified";
      phys = SIM_D10V_MEMORY_UNIFIED + off;
      if ((off % SEGMENT_SIZE) + nr_bytes > SEGMENT_SIZE)
	nr_bytes = SEGMENT_SIZE - (off % SEGMENT_SIZE);
      break;

    case 0x01:			/* Physical instruction memory */
      last_from = "phys-insn";
      last_to = "chip-insn";
      phys = SIM_D10V_MEMORY_INSN + off;
      if ((off % SEGMENT_SIZE) + nr_bytes > SEGMENT_SIZE)
	nr_bytes = SEGMENT_SIZE - (off % SEGMENT_SIZE);
      break;

    case 0x02:			/* Physical data memory segment */
      last_from = "phys-data";
      last_to = "chip-data";
      phys = SIM_D10V_MEMORY_DATA + off;
      if ((off % SEGMENT_SIZE) + nr_bytes > SEGMENT_SIZE)
	nr_bytes = SEGMENT_SIZE - (off % SEGMENT_SIZE);
      break;

    case 0x10:			/* in logical data address segment */
      nr_bytes = sim_d10v_translate_dmap_addr (off, nr_bytes, &phys, regcache,
					       dmap_register);
      break;

    case 0x11:			/* in logical instruction address segment */
      nr_bytes = sim_d10v_translate_imap_addr (off, nr_bytes, &phys, regcache,
					       imap_register);
      break;

    default:
      return 0;
    }

  *targ_addr = phys;
  return nr_bytes;
}

/* Return a pointer into the raw buffer designated by phys_addr.  It
   is assumed that the client has already ensured that the access
   isn't going to cross a segment boundary. */

uint8 *
map_memory (unsigned phys_addr)
{
  uint8 **memory;
  uint8 *raw;
  unsigned offset;
  int segment = ((phys_addr >> 24) & 0xff);
  
  switch (segment)
    {
      
    case 0x00: /* Unified memory */
      {
	memory = &State.mem.unif[(phys_addr / SEGMENT_SIZE) % UMEM_SEGMENTS];
	last_segname = "umem";
	break;
      }
    
    case 0x01: /* On-chip insn memory */
      {
	memory = &State.mem.insn[(phys_addr / SEGMENT_SIZE) % IMEM_SEGMENTS];
	last_segname = "imem";
	break;
      }
    
    case 0x02: /* On-chip data memory */
      {
	if ((phys_addr & 0xff00) == 0xff00)
	  {
	    phys_addr = (phys_addr & 0xffff);
	    if (phys_addr == DMAP2_SHADDOW)
	      {
		phys_addr = DMAP2_OFFSET;
		last_segname = "dmap";
	      }
	    else
	      last_segname = "reg";
	  }
	else
	  last_segname = "dmem";
	memory = &State.mem.data[(phys_addr / SEGMENT_SIZE) % DMEM_SEGMENTS];
	break;
      }
    
    default:
      /* OOPS! */
      last_segname = "scrap";
      return State.mem.fault;
    }
  
  if (*memory == NULL)
    {
      *memory = calloc (1, SEGMENT_SIZE);
      if (*memory == NULL)
	{
	  (*d10v_callback->printf_filtered) (d10v_callback, "Malloc failed.\n");
	  return State.mem.fault;
	}
    }
  
  offset = (phys_addr % SEGMENT_SIZE);
  raw = *memory + offset;
  return raw;
}
  
/* Transfer data to/from simulated memory.  Since a bug in either the
   simulated program or in gdb or the simulator itself may cause a
   bogus address to be passed in, we need to do some sanity checking
   on addresses to make sure they are within bounds.  When an address
   fails the bounds check, treat it as a zero length read/write rather
   than aborting the entire run. */

static int
xfer_mem (SIM_ADDR virt,
	  unsigned char *buffer,
	  int size,
	  int write_p)
{
  uint8 *memory;
  unsigned long phys;
  int phys_size;
  phys_size = sim_d10v_translate_addr (virt, size, &phys, NULL,
				       dmap_register, imap_register);
  if (phys_size == 0)
    return 0;

  memory = map_memory (phys);

#ifdef DEBUG
  if ((d10v_debug & DEBUG_INSTRUCTION) != 0)
    {
      (*d10v_callback->printf_filtered)
	(d10v_callback,
	 "sim_%s %d bytes: 0x%08lx (%s) -> 0x%08lx (%s) -> 0x%08lx (%s)\n",
	     (write_p ? "write" : "read"),
	 phys_size, virt, last_from,
	 phys, last_to,
	 (long) memory, last_segname);
    }
#endif

  if (write_p)
    {
      memcpy (memory, buffer, phys_size);
    }
  else
    {
      memcpy (buffer, memory, phys_size);
    }
  
  return phys_size;
}


int
sim_write (sd, addr, buffer, size)
     SIM_DESC sd;
     SIM_ADDR addr;
     const unsigned char *buffer;
     int size;
{
  /* FIXME: this should be performing a virtual transfer */
  return xfer_mem( addr, buffer, size, 1);
}

int
sim_read (sd, addr, buffer, size)
     SIM_DESC sd;
     SIM_ADDR addr;
     unsigned char *buffer;
     int size;
{
  /* FIXME: this should be performing a virtual transfer */
  return xfer_mem( addr, buffer, size, 0);
}


SIM_DESC
sim_open (kind, callback, abfd, argv)
     SIM_OPEN_KIND kind;
     host_callback *callback;
     struct bfd *abfd;
     char **argv;
{
  struct simops *s;
  struct hash_entry *h;
  static int init_p = 0;
  char **p;

  sim_kind = kind;
  d10v_callback = callback;
  myname = argv[0];
  old_segment_mapping = 0;

  /* NOTE: This argument parsing is only effective when this function
     is called by GDB. Standalone argument parsing is handled by
     sim/common/run.c. */
  for (p = argv + 1; *p; ++p)
    {
      if (strcmp (*p, "-oldseg") == 0)
	old_segment_mapping = 1;
#ifdef DEBUG
      else if (strcmp (*p, "-t") == 0)
	d10v_debug = DEBUG;
      else if (strncmp (*p, "-t", 2) == 0)
	d10v_debug = atoi (*p + 2);
#endif
      else
	(*d10v_callback->printf_filtered) (d10v_callback, "ERROR: unsupported option(s): %s\n",*p);
    }
  
  /* put all the opcodes in the hash table */
  if (!init_p++)
    {
      for (s = Simops; s->func; s++)
	{
	  h = &hash_table[hash(s->opcode,s->format)];
      
	  /* go to the last entry in the chain */
	  while (h->next)
	    h = h->next;

	  if (h->ops)
	    {
	      h->next = (struct hash_entry *) calloc(1,sizeof(struct hash_entry));
	      if (!h->next)
		perror ("malloc failure");

	      h = h->next;
	    }
	  h->ops = s;
	  h->mask = s->mask;
	  h->opcode = s->opcode;
	  h->size = s->is_long;
	}
    }

  /* reset the processor state */
  if (!State.mem.data[0])
    sim_size (1);
  sim_create_inferior ((SIM_DESC) 1, NULL, NULL, NULL);

  /* Fudge our descriptor.  */
  return (SIM_DESC) 1;
}


void
sim_close (sd, quitting)
     SIM_DESC sd;
     int quitting;
{
  if (prog_bfd != NULL && prog_bfd_was_opened_p)
    {
      bfd_close (prog_bfd);
      prog_bfd = NULL;
      prog_bfd_was_opened_p = 0;
    }
}

void
sim_set_profile (n)
     int n;
{
  (*d10v_callback->printf_filtered) (d10v_callback, "sim_set_profile %d\n",n);
}

void
sim_set_profile_size (n)
     int n;
{
  (*d10v_callback->printf_filtered) (d10v_callback, "sim_set_profile_size %d\n",n);
}

uint8 *
dmem_addr (uint16 offset)
{
  unsigned long phys;
  uint8 *mem;
  int phys_size;

  /* Note: DMEM address range is 0..0x10000. Calling code can compute
     things like ``0xfffe + 0x0e60 == 0x10e5d''.  Since offset's type
     is uint16 this is modulo'ed onto 0x0e5d. */

  phys_size = sim_d10v_translate_dmap_addr (offset, 1, &phys, NULL,
					    dmap_register);
  if (phys_size == 0)
    {
      mem = State.mem.fault;
    }
  else
    mem = map_memory (phys);
#ifdef DEBUG
  if ((d10v_debug & DEBUG_MEMORY))
    {
      (*d10v_callback->printf_filtered)
	(d10v_callback,
	 "mem: 0x%08x (%s) -> 0x%08lx %d (%s) -> 0x%08lx (%s)\n",
	 offset, last_from,
	 phys, phys_size, last_to,
	 (long) mem, last_segname);
    }
#endif
  return mem;
}

uint8 *
imem_addr (uint32 offset)
{
  unsigned long phys;
  uint8 *mem;
  int phys_size = sim_d10v_translate_imap_addr (offset, 1, &phys, NULL,
						imap_register);
  if (phys_size == 0)
    {
      return State.mem.fault;
    }
  mem = map_memory (phys); 
#ifdef DEBUG
  if ((d10v_debug & DEBUG_MEMORY))
    {
      (*d10v_callback->printf_filtered)
	(d10v_callback,
	 "mem: 0x%08x (%s) -> 0x%08lx %d (%s) -> 0x%08lx (%s)\n",
	 offset, last_from,
	 phys, phys_size, last_to,
	 (long) mem, last_segname);
    }
#endif
  return mem;
}

static int stop_simulator = 0;

int
sim_stop (sd)
     SIM_DESC sd;
{
  stop_simulator = 1;
  return 1;
}


/* Run (or resume) the program.  */
void
sim_resume (sd, step, siggnal)
     SIM_DESC sd;
     int step, siggnal;
{
  uint32 inst;
  uint8 *iaddr;

/*   (*d10v_callback->printf_filtered) (d10v_callback, "sim_resume (%d,%d)  PC=0x%x\n",step,siggnal,PC); */
  State.exception = 0;
  if (step)
    sim_stop (sd);

  switch (siggnal)
    {
    case 0:
      break;
#ifdef SIGBUS
    case SIGBUS:
#endif
    case SIGSEGV:
      SET_BPC (PC);
      SET_BPSW (PSW);
      SET_HW_PSW ((PSW & (PSW_F0_BIT | PSW_F1_BIT | PSW_C_BIT)));
      JMP (AE_VECTOR_START);
      SLOT_FLUSH ();
      break;
    case SIGILL:
      SET_BPC (PC);
      SET_BPSW (PSW);
      SET_HW_PSW ((PSW & (PSW_F0_BIT | PSW_F1_BIT | PSW_C_BIT)));
      JMP (RIE_VECTOR_START);
      SLOT_FLUSH ();
      break;
    default:
      /* just ignore it */
      break;
    }

  do
    {
      iaddr = imem_addr ((uint32)PC << 2);
      if (iaddr == State.mem.fault)
 	{
 	  State.exception = SIGBUS;
 	  break;
 	}
 
      inst = get_longword( iaddr ); 
 
      State.pc_changed = 0;
      ins_type_counters[ (int)INS_CYCLES ]++;
      
      switch (inst & 0xC0000000)
	{
	case 0xC0000000:
	  /* long instruction */
	  do_long (inst & 0x3FFFFFFF);
	  break;
	case 0x80000000:
	  /* R -> L */
	  do_2_short ( inst & 0x7FFF, (inst & 0x3FFF8000) >> 15, RIGHT_FIRST);
	  break;
	case 0x40000000:
	  /* L -> R */
	  do_2_short ((inst & 0x3FFF8000) >> 15, inst & 0x7FFF, LEFT_FIRST);
	  break;
	case 0:
	  do_parallel ((inst & 0x3FFF8000) >> 15, inst & 0x7FFF);
	  break;
	}
      
      /* If the PC of the current instruction matches RPT_E then
	 schedule a branch to the loop start.  If one of those
	 instructions happens to be a branch, than that instruction
	 will be ignored */
      if (!State.pc_changed)
	{
	  if (PSW_RP && PC == RPT_E)
	    {
	      /* Note: The behavour of a branch instruction at RPT_E
		 is implementation dependant, this simulator takes the
		 branch.  Branching to RPT_E is valid, the instruction
		 must be executed before the loop is taken.  */
	      if (RPT_C == 1)
		{
		  SET_PSW_RP (0);
		  SET_RPT_C (0);
		  SET_PC (PC + 1);
		}
	      else
		{
		  SET_RPT_C (RPT_C - 1);
		  SET_PC (RPT_S);
		}
	    }
	  else
	    SET_PC (PC + 1);
	}	  
      
      /* Check for a breakpoint trap on this instruction.  This
	 overrides any pending branches or loops */
      if (PSW_DB && PC == IBA)
	{
	  SET_BPC (PC);
	  SET_BPSW (PSW);
	  SET_PSW (PSW & PSW_SM_BIT);
	  SET_PC (SDBT_VECTOR_START);
	}

      /* Writeback all the DATA / PC changes */
      SLOT_FLUSH ();

#ifdef NEED_UI_LOOP_HOOK
      if (deprecated_ui_loop_hook != NULL && ui_loop_hook_counter-- < 0)
	{
	  ui_loop_hook_counter = UI_LOOP_POLL_INTERVAL;
	  deprecated_ui_loop_hook (0);
	}
#endif /* NEED_UI_LOOP_HOOK */
    }
  while ( !State.exception && !stop_simulator);
  
  if (step && !State.exception)
    State.exception = SIGTRAP;
}

void
sim_set_trace (void)
{
#ifdef DEBUG
  d10v_debug = DEBUG;
#endif
}

void
sim_info (sd, verbose)
     SIM_DESC sd;
     int verbose;
{
  char buf1[40];
  char buf2[40];
  char buf3[40];
  char buf4[40];
  char buf5[40];
  unsigned long left		= ins_type_counters[ (int)INS_LEFT ] + ins_type_counters[ (int)INS_LEFT_COND_EXE ];
  unsigned long left_nops	= ins_type_counters[ (int)INS_LEFT_NOPS ];
  unsigned long left_parallel	= ins_type_counters[ (int)INS_LEFT_PARALLEL ];
  unsigned long left_cond	= ins_type_counters[ (int)INS_LEFT_COND_TEST ];
  unsigned long left_total	= left + left_parallel + left_cond + left_nops;

  unsigned long right		= ins_type_counters[ (int)INS_RIGHT ] + ins_type_counters[ (int)INS_RIGHT_COND_EXE ];
  unsigned long right_nops	= ins_type_counters[ (int)INS_RIGHT_NOPS ];
  unsigned long right_parallel	= ins_type_counters[ (int)INS_RIGHT_PARALLEL ];
  unsigned long right_cond	= ins_type_counters[ (int)INS_RIGHT_COND_TEST ];
  unsigned long right_total	= right + right_parallel + right_cond + right_nops;

  unsigned long unknown		= ins_type_counters[ (int)INS_UNKNOWN ];
  unsigned long ins_long	= ins_type_counters[ (int)INS_LONG ];
  unsigned long parallel	= ins_type_counters[ (int)INS_PARALLEL ];
  unsigned long leftright	= ins_type_counters[ (int)INS_LEFTRIGHT ];
  unsigned long rightleft	= ins_type_counters[ (int)INS_RIGHTLEFT ];
  unsigned long cond_true	= ins_type_counters[ (int)INS_COND_TRUE ];
  unsigned long cond_false	= ins_type_counters[ (int)INS_COND_FALSE ];
  unsigned long cond_jump	= ins_type_counters[ (int)INS_COND_JUMP ];
  unsigned long cycles		= ins_type_counters[ (int)INS_CYCLES ];
  unsigned long total		= (unknown + left_total + right_total + ins_long);

  int size			= strlen (add_commas (buf1, sizeof (buf1), total));
  int parallel_size		= strlen (add_commas (buf1, sizeof (buf1),
						      (left_parallel > right_parallel) ? left_parallel : right_parallel));
  int cond_size			= strlen (add_commas (buf1, sizeof (buf1), (left_cond > right_cond) ? left_cond : right_cond));
  int nop_size			= strlen (add_commas (buf1, sizeof (buf1), (left_nops > right_nops) ? left_nops : right_nops));
  int normal_size		= strlen (add_commas (buf1, sizeof (buf1), (left > right) ? left : right));

  (*d10v_callback->printf_filtered) (d10v_callback,
				     "executed %*s left  instruction(s), %*s normal, %*s parallel, %*s EXExxx, %*s nops\n",
				     size, add_commas (buf1, sizeof (buf1), left_total),
				     normal_size, add_commas (buf2, sizeof (buf2), left),
				     parallel_size, add_commas (buf3, sizeof (buf3), left_parallel),
				     cond_size, add_commas (buf4, sizeof (buf4), left_cond),
				     nop_size, add_commas (buf5, sizeof (buf5), left_nops));

  (*d10v_callback->printf_filtered) (d10v_callback,
				     "executed %*s right instruction(s), %*s normal, %*s parallel, %*s EXExxx, %*s nops\n",
				     size, add_commas (buf1, sizeof (buf1), right_total),
				     normal_size, add_commas (buf2, sizeof (buf2), right),
				     parallel_size, add_commas (buf3, sizeof (buf3), right_parallel),
				     cond_size, add_commas (buf4, sizeof (buf4), right_cond),
				     nop_size, add_commas (buf5, sizeof (buf5), right_nops));

  if (ins_long)
    (*d10v_callback->printf_filtered) (d10v_callback,
				       "executed %*s long instruction(s)\n",
				       size, add_commas (buf1, sizeof (buf1), ins_long));

  if (parallel)
    (*d10v_callback->printf_filtered) (d10v_callback,
				       "executed %*s parallel instruction(s)\n",
				       size, add_commas (buf1, sizeof (buf1), parallel));

  if (leftright)
    (*d10v_callback->printf_filtered) (d10v_callback,
				       "executed %*s instruction(s) encoded L->R\n",
				       size, add_commas (buf1, sizeof (buf1), leftright));

  if (rightleft)
    (*d10v_callback->printf_filtered) (d10v_callback,
				       "executed %*s instruction(s) encoded R->L\n",
				       size, add_commas (buf1, sizeof (buf1), rightleft));

  if (unknown)
    (*d10v_callback->printf_filtered) (d10v_callback,
				       "executed %*s unknown instruction(s)\n",
				       size, add_commas (buf1, sizeof (buf1), unknown));

  if (cond_true)
    (*d10v_callback->printf_filtered) (d10v_callback,
				       "executed %*s instruction(s) due to EXExxx condition being true\n",
				       size, add_commas (buf1, sizeof (buf1), cond_true));

  if (cond_false)
    (*d10v_callback->printf_filtered) (d10v_callback,
				       "skipped  %*s instruction(s) due to EXExxx condition being false\n",
				       size, add_commas (buf1, sizeof (buf1), cond_false));

  if (cond_jump)
    (*d10v_callback->printf_filtered) (d10v_callback,
				       "skipped  %*s instruction(s) due to conditional branch succeeding\n",
				       size, add_commas (buf1, sizeof (buf1), cond_jump));

  (*d10v_callback->printf_filtered) (d10v_callback,
				     "executed %*s cycle(s)\n",
				     size, add_commas (buf1, sizeof (buf1), cycles));

  (*d10v_callback->printf_filtered) (d10v_callback,
				     "executed %*s total instructions\n",
				     size, add_commas (buf1, sizeof (buf1), total));
}

SIM_RC
sim_create_inferior (sd, abfd, argv, env)
     SIM_DESC sd;
     struct bfd *abfd;
     char **argv;
     char **env;
{
  bfd_vma start_address;

  /* reset all state information */
  memset (&State.regs, 0, (int)&State.mem - (int)&State.regs);

  /* There was a hack here to copy the values of argc and argv into r0
     and r1.  The values were also saved into some high memory that
     won't be overwritten by the stack (0x7C00).  The reason for doing
     this was to allow the 'run' program to accept arguments.  Without
     the hack, this is not possible anymore.  If the simulator is run
     from the debugger, arguments cannot be passed in, so this makes
     no difference.  */

  /* set PC */
  if (abfd != NULL)
    start_address = bfd_get_start_address (abfd);
  else
    start_address = 0xffc0 << 2;
#ifdef DEBUG
  if (d10v_debug)
    (*d10v_callback->printf_filtered) (d10v_callback, "sim_create_inferior:  PC=0x%lx\n", (long) start_address);
#endif
  SET_CREG (PC_CR, start_address >> 2);

  /* cpu resets imap0 to 0 and imap1 to 0x7f, but D10V-EVA board
     initializes imap0 and imap1 to 0x1000 as part of its ROM
     initialization. */
  if (old_segment_mapping)
    {
      /* External memory startup.  This is the HARD reset state. */
      set_imap_register (0, 0x0000);
      set_imap_register (1, 0x007f);
      set_dmap_register (0, 0x2000);
      set_dmap_register (1, 0x2000);
      set_dmap_register (2, 0x0000); /* Old DMAP */
      set_dmap_register (3, 0x0000);
    }
  else
    {
      /* Internal memory startup. This is the ROM intialized state. */
      set_imap_register (0, 0x1000);
      set_imap_register (1, 0x1000);
      set_dmap_register (0, 0x2000);
      set_dmap_register (1, 0x2000);
      set_dmap_register (2, 0x2000); /* DMAP2 initial internal value is
					0x2000 on the new board. */
      set_dmap_register (3, 0x0000);
    }

  SLOT_FLUSH ();
  return SIM_RC_OK;
}


void
sim_set_callbacks (p)
     host_callback *p;
{
  d10v_callback = p;
}

void
sim_stop_reason (sd, reason, sigrc)
     SIM_DESC sd;
     enum sim_stop *reason;
     int *sigrc;
{
/*   (*d10v_callback->printf_filtered) (d10v_callback, "sim_stop_reason:  PC=0x%x\n",PC<<2); */

  switch (State.exception)
    {
    case SIG_D10V_STOP:			/* stop instruction */
      *reason = sim_exited;
      *sigrc = 0;
      break;

    case SIG_D10V_EXIT:			/* exit trap */
      *reason = sim_exited;
      *sigrc = GPR (0);
      break;

    case SIG_D10V_BUS:
      *reason = sim_stopped;
      *sigrc = GDB_SIGNAL_BUS;
      break;

    default:				/* some signal */
      *reason = sim_stopped;
      if (stop_simulator && !State.exception)
	*sigrc = GDB_SIGNAL_INT;
      else
	*sigrc = State.exception;
      break;
    }

  stop_simulator = 0;
}

int
sim_fetch_register (sd, rn, memory, length)
     SIM_DESC sd;
     int rn;
     unsigned char *memory;
     int length;
{
  int size;
  switch ((enum sim_d10v_regs) rn)
    {
    case SIM_D10V_R0_REGNUM:
    case SIM_D10V_R1_REGNUM:
    case SIM_D10V_R2_REGNUM:
    case SIM_D10V_R3_REGNUM:
    case SIM_D10V_R4_REGNUM:
    case SIM_D10V_R5_REGNUM:
    case SIM_D10V_R6_REGNUM:
    case SIM_D10V_R7_REGNUM:
    case SIM_D10V_R8_REGNUM:
    case SIM_D10V_R9_REGNUM:
    case SIM_D10V_R10_REGNUM:
    case SIM_D10V_R11_REGNUM:
    case SIM_D10V_R12_REGNUM:
    case SIM_D10V_R13_REGNUM:
    case SIM_D10V_R14_REGNUM:
    case SIM_D10V_R15_REGNUM:
      WRITE_16 (memory, GPR (rn - SIM_D10V_R0_REGNUM));
      size = 2;
      break;
    case SIM_D10V_CR0_REGNUM:
    case SIM_D10V_CR1_REGNUM:
    case SIM_D10V_CR2_REGNUM:
    case SIM_D10V_CR3_REGNUM:
    case SIM_D10V_CR4_REGNUM:
    case SIM_D10V_CR5_REGNUM:
    case SIM_D10V_CR6_REGNUM:
    case SIM_D10V_CR7_REGNUM:
    case SIM_D10V_CR8_REGNUM:
    case SIM_D10V_CR9_REGNUM:
    case SIM_D10V_CR10_REGNUM:
    case SIM_D10V_CR11_REGNUM:
    case SIM_D10V_CR12_REGNUM:
    case SIM_D10V_CR13_REGNUM:
    case SIM_D10V_CR14_REGNUM:
    case SIM_D10V_CR15_REGNUM:
      WRITE_16 (memory, CREG (rn - SIM_D10V_CR0_REGNUM));
      size = 2;
      break;
    case SIM_D10V_A0_REGNUM:
    case SIM_D10V_A1_REGNUM:
      WRITE_64 (memory, ACC (rn - SIM_D10V_A0_REGNUM));
      size = 8;
      break;
    case SIM_D10V_SPI_REGNUM:
      /* PSW_SM indicates that the current SP is the USER
         stack-pointer. */
      WRITE_16 (memory, spi_register ());
      size = 2;
      break;
    case SIM_D10V_SPU_REGNUM:
      /* PSW_SM indicates that the current SP is the USER
         stack-pointer. */
      WRITE_16 (memory, spu_register ());
      size = 2;
      break;
    case SIM_D10V_IMAP0_REGNUM:
    case SIM_D10V_IMAP1_REGNUM:
      WRITE_16 (memory, imap_register (NULL, rn - SIM_D10V_IMAP0_REGNUM));
      size = 2;
      break;
    case SIM_D10V_DMAP0_REGNUM:
    case SIM_D10V_DMAP1_REGNUM:
    case SIM_D10V_DMAP2_REGNUM:
    case SIM_D10V_DMAP3_REGNUM:
      WRITE_16 (memory, dmap_register (NULL, rn - SIM_D10V_DMAP0_REGNUM));
      size = 2;
      break;
    case SIM_D10V_TS2_DMAP_REGNUM:
      size = 0;
      break;
    default:
      size = 0;
      break;
    }
  return size;
}
 
int
sim_store_register (sd, rn, memory, length)
     SIM_DESC sd;
     int rn;
     unsigned char *memory;
     int length;
{
  int size;
  switch ((enum sim_d10v_regs) rn)
    {
    case SIM_D10V_R0_REGNUM:
    case SIM_D10V_R1_REGNUM:
    case SIM_D10V_R2_REGNUM:
    case SIM_D10V_R3_REGNUM:
    case SIM_D10V_R4_REGNUM:
    case SIM_D10V_R5_REGNUM:
    case SIM_D10V_R6_REGNUM:
    case SIM_D10V_R7_REGNUM:
    case SIM_D10V_R8_REGNUM:
    case SIM_D10V_R9_REGNUM:
    case SIM_D10V_R10_REGNUM:
    case SIM_D10V_R11_REGNUM:
    case SIM_D10V_R12_REGNUM:
    case SIM_D10V_R13_REGNUM:
    case SIM_D10V_R14_REGNUM:
    case SIM_D10V_R15_REGNUM:
      SET_GPR (rn - SIM_D10V_R0_REGNUM, READ_16 (memory));
      size = 2;
      break;
    case SIM_D10V_CR0_REGNUM:
    case SIM_D10V_CR1_REGNUM:
    case SIM_D10V_CR2_REGNUM:
    case SIM_D10V_CR3_REGNUM:
    case SIM_D10V_CR4_REGNUM:
    case SIM_D10V_CR5_REGNUM:
    case SIM_D10V_CR6_REGNUM:
    case SIM_D10V_CR7_REGNUM:
    case SIM_D10V_CR8_REGNUM:
    case SIM_D10V_CR9_REGNUM:
    case SIM_D10V_CR10_REGNUM:
    case SIM_D10V_CR11_REGNUM:
    case SIM_D10V_CR12_REGNUM:
    case SIM_D10V_CR13_REGNUM:
    case SIM_D10V_CR14_REGNUM:
    case SIM_D10V_CR15_REGNUM:
      SET_CREG (rn - SIM_D10V_CR0_REGNUM, READ_16 (memory));
      size = 2;
      break;
    case SIM_D10V_A0_REGNUM:
    case SIM_D10V_A1_REGNUM:
      SET_ACC (rn - SIM_D10V_A0_REGNUM, READ_64 (memory) & MASK40);
      size = 8;
      break;
    case SIM_D10V_SPI_REGNUM:
      /* PSW_SM indicates that the current SP is the USER
         stack-pointer. */
      set_spi_register (READ_16 (memory));
      size = 2;
      break;
    case SIM_D10V_SPU_REGNUM:
      set_spu_register (READ_16 (memory));
      size = 2;
      break;
    case SIM_D10V_IMAP0_REGNUM:
    case SIM_D10V_IMAP1_REGNUM:
      set_imap_register (rn - SIM_D10V_IMAP0_REGNUM, READ_16(memory));
      size = 2;
      break;
    case SIM_D10V_DMAP0_REGNUM:
    case SIM_D10V_DMAP1_REGNUM:
    case SIM_D10V_DMAP2_REGNUM:
    case SIM_D10V_DMAP3_REGNUM:
      set_dmap_register (rn - SIM_D10V_DMAP0_REGNUM, READ_16(memory));
      size = 2;
      break;
    case SIM_D10V_TS2_DMAP_REGNUM:
      size = 0;
      break;
    default:
      size = 0;
      break;
    }
  SLOT_FLUSH ();
  return size;
}


void
sim_do_command (sd, cmd)
     SIM_DESC sd;
     char *cmd;
{ 
  (*d10v_callback->printf_filtered) (d10v_callback, "sim_do_command: %s\n",cmd);
}

SIM_RC
sim_load (sd, prog, abfd, from_tty)
     SIM_DESC sd;
     char *prog;
     bfd *abfd;
     int from_tty;
{
  extern bfd *sim_load_file (); /* ??? Don't know where this should live.  */

  if (prog_bfd != NULL && prog_bfd_was_opened_p)
    {
      bfd_close (prog_bfd);
      prog_bfd_was_opened_p = 0;
    }
  prog_bfd = sim_load_file (sd, myname, d10v_callback, prog, abfd,
			    sim_kind == SIM_OPEN_DEBUG,
			    1/*LMA*/, sim_write);
  if (prog_bfd == NULL)
    return SIM_RC_FAIL;
  prog_bfd_was_opened_p = abfd == NULL;
  return SIM_RC_OK;
} 
@


1.20
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        * gdb/signals.def: Replace TARGET_SIGNAL_ with GDB_SIGNAL_
	throughout.

sim/arm/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/avr/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/cr16/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/d10v/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/erc32/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/m32c/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/ppc/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rl78/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rx/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.
@
text
@d1 1
a2 1
#include "sysdep.h"
d11 12
@


1.19
log
@sim: constify sim_write source buffer (part 2)

As pointed out by Sandra Loosemore, a bunch of targets define sim_write
themselves instead of using the common/ code.  So constify them too.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d1281 1
a1281 1
      *sigrc = TARGET_SIGNAL_BUS;
d1287 1
a1287 1
	*sigrc = TARGET_SIGNAL_INT;
@


1.18
log
@* interp.c (sim_stop_reason): Fix typo.
@
text
@d764 1
a764 1
     unsigned char *buffer;
@


1.17
log
@	* remote-sim.c (gdbsim_wait): Pass target signal numbers to
	sim_resume.  Expect target signal numbers from sim_stop_reason.

	* wrapper.c (gdb/signals.h): Include it.
	(SIGTRAP): Don't define.
	(SIGBUS): Likewise.
	(sim_stop_reason): Use TARGET_SIGNAL_* instead of SIG*.

	* sim-reason.c (sim_stop_reason): Use
	sim_signal_to_target, not sim_signal_to_host.
	* sim-signal.c (sim_signal_to_host): Fix typo.
	(sim_signal_to_target): New function.

	* interp.c (gdb/signals.h): Include it.
	(sim_stop_reason): Use TARGET_SIGNAL_*.

	* interf.c: (gdb/signals.h): Include it.
	(sim_stop_reason): Use TARGET_SIGNAL_*.

	* sim_calls.c (gdb/signals.h): Include it.
	(sim_stop_reason): Use TARGET_SIGNAL_*.
	* psim.c (cntrl_c_simulation): Use TARGET_SIGNAL_*.
@
text
@d1281 1
a1281 1
      *reson = TARGET_SIGNAL_BUS;
@


1.16
log
@Index: mn10200/ChangeLog
2004-06-28  Andrew Cagney  <cagney@@gnu.org>

	* interp.c: Rename ui_loop_hook to deprecated_ui_loop_hook.

Index: d10v/ChangeLog
2004-06-28  Andrew Cagney  <cagney@@gnu.org>

	* interp.c (sim_resume): Rename ui_loop_hook to
	deprecated_ui_loop_hook.

Index: arm/ChangeLog
2004-06-28  Andrew Cagney  <cagney@@gnu.org>

	* armemu.c: Rename ui_loop_hook to deprecated_ui_loop_hook.

Index: common/ChangeLog
2004-06-28  Andrew Cagney  <cagney@@gnu.org>

	* run.c: Rename ui_loop_hook to deprecated_ui_loop_hook.
@
text
@d9 1
d1281 1
a1281 5
#ifdef SIGBUS
      *sigrc = SIGBUS;
#else
      *sigrc = SIGSEGV;
#endif
d1287 1
a1287 1
	*sigrc = SIGINT;
@


1.16.16.1
log
@	* gdb/remote-sim.c (gdbsim_wait): Don't use target_signal_to_host
	or target_signal_from_host.
	* sim/arm/wrapper.c (gdb/signals.h): Include it.
	(SIGTRAP): Don't define it.
	(SIGBUS): Likewise.
	(sim_stop_reason): Use TARGET_SIGNAL_*.
	* sim/common/sim-reason.c (sim_stop_reason): Use
	sim_signal_to_target, not sim_signal_to_host.
	* sim/common/sim-signal.c (sim_signal_to_host): Fix typo.
	(sim_signal_to_target): New function.
	* sim/common/sim-signal.h: Declare it.
	* sim/d10v/interp.c (gdb/signals.h): Include it.
	(sim_stop_reason): Use TARGET_SIGNAL_*.
	* sim/erc32/interf.c: (gdb/signals.h): Include it.
	(sim_stop_reason): Use TARGET_SIGNAL_*.
	* sim/ppc/sim_calls.c (gdb/signals.h): Include it.
	(sim_stop_reason): Use TARGET_SIGNAL_*.
@
text
@a8 1
#include "gdb/signals.h"
d1280 5
a1284 1
      *reson = TARGET_SIGNAL_BUS;
d1290 1
a1290 1
	*sigrc = TARGET_SIGNAL_INT;
@


1.15
log
@2003-06-22  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (xfer_mem): Simplify.  Only do a single partial
	transfer.  Problem reported by Tom Rix.
@
text
@d52 1
a52 1
extern int (*ui_loop_hook) PARAMS ((int signo));
d1064 1
a1064 1
      if (ui_loop_hook != NULL && ui_loop_hook_counter-- < 0)
d1067 1
a1067 1
	  ui_loop_hook (0);
@


1.15.14.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d52 1
a52 1
extern int (*deprecated_ui_loop_hook) PARAMS ((int signo));
d1064 1
a1064 1
      if (deprecated_ui_loop_hook != NULL && ui_loop_hook_counter-- < 0)
d1067 1
a1067 1
	  deprecated_ui_loop_hook (0);
@


1.14
log
@Index: gdb/ChangeLog
2003-05-07  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (remote_d10v_translate_xfer_address): Add
	"regcache".
	(d10v_print_registers_info): Update.
	(d10v_dmap_register, d10v_imap_register): Delete functions.
	(struct gdbarch_tdep): Add "regcache" parameter to "dmap_register"
	and "imap_register".
	(d10v_ts2_dmap_register, d10v_ts2_imap_register): Add "regcache".
	(d10v_ts3_dmap_register, d10v_ts3_imap_register): Add "regcache".
	* arch-utils.c (generic_remote_translate_xfer_address): Add
	"regcache" and "gdbarch" parameters.
	* gdbarch.sh (REMOTE_TRANSLATE_XFER_ADDRESS): Add "regcache"
	parameter.  Change class to multi-arch.
	* gdbarch.h, gdbarch.c: Re-generate.
	* remote.c (remote_xfer_memory): Use
	gdbarch_remote_translate_xfer_address.

Index: include/gdb/ChangeLog
2003-05-07  Andrew Cagney  <cagney@@redhat.com>

	* sim-d10v.h (sim_d10v_translate_addr): Add regcache parameter.
	(sim_d10v_translate_imap_addr): Add regcache parameter.
	(sim_d10v_translate_dmap_addr): Ditto.

Index: sim/d10v/ChangeLog
2003-05-07  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_d10v_translate_addr): Add "regcache" parameter.
	(sim_d10v_translate_imap_addr): Ditto.
	(sim_d10v_translate_dmap_addr): Ditto.
	(xfer_mem): Pass NULL regcache to sim_d10v_translate_addr.
	(dmem_addr): Pass NULL regcache to sim_d10v_translate_dmap_addr.
	(dmap_register, imap_register): Add "regcache" parameter.
	(imem_addr): Pass NULL regcache to sim_d10v_translate_imap_addr.
	(sim_fetch_register): Pass NULL regcache to imap_register and
	dmap_register.
@
text
@d723 7
a729 1
  int xfered = 0;
d731 1
a731 11
  while (0 < size)
    {
      uint8 *memory;
      unsigned long phys;
      int phys_size;
      phys_size = sim_d10v_translate_addr (virt, size, &phys, NULL,
					   dmap_register, imap_register);
      if (phys_size == 0)
	return xfered;

      memory = map_memory (phys);
d734 5
a738 5
      if ((d10v_debug & DEBUG_INSTRUCTION) != 0)
	{
	  (*d10v_callback->printf_filtered)
	    (d10v_callback,
	     "sim_%s %d bytes: 0x%08lx (%s) -> 0x%08lx (%s) -> 0x%08lx (%s)\n",
d740 4
a743 4
	     phys_size, virt, last_from,
	     phys, last_to,
	     (long) memory, last_segname);
	}
d746 7
a752 13
      if (write_p)
	{
	  memcpy (memory, buffer, phys_size);
	}
      else
	{
	  memcpy (buffer, memory, phys_size);
	}

      virt += phys_size;
      buffer += phys_size;
      xfered += phys_size;
      size -= phys_size;
d754 2
a755 2

  return xfered;
@


1.13
log
@Index: arm/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* wrapper.c (sim_create_inferior, sim_open): Rename _bfd to bfd.

Index: common/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim-utils.h (sim_analyze_program, sim_load_file): Rename _bfd to bfd.
	* sim-hload.c (sim_load), sim-base.h (sim_state_base): Ditto.
	* nrun.c (main): Ditto.

Index: d10v/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: erc32/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interf.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: h8300/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* compile.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: h8500/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* compile.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: i960/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim-if.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: m32r/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim-if.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: m68hc11/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_prepare_for_program, sim_open)
	(sim_create_inferior): Rename _bfd to bfd.

Index: mcore/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: mips/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open):
	(sim_create_inferior):

Index: mn10200/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: mn10300/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior, sim_open)
	(sim_create_inferior): Rename _bfd to bfd.

Index: ppc/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim_calls.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: sh/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (init_dsp, sim_open, sim_create_inferior): Rename _bfd
	to bfd.

Index: v850/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: z8k/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* iface.c (sim_open, sim_create_inferior): Rename _bfd to bfd.
@
text
@d366 1
a366 1
dmap_register (int reg_nr)
d389 1
a389 1
imap_register (int reg_nr)
d443 3
a445 1
			      unsigned long (*dmap_register) (int reg_nr))
d462 1
a462 1
  map = dmap_register (regno);
d503 3
a505 1
			      unsigned long (*imap_register) (int reg_nr))
d524 1
a524 1
  map = imap_register (regno);
d556 5
a560 2
			 unsigned long (*dmap_register) (int reg_nr),
			 unsigned long (*imap_register) (int reg_nr))
d624 1
a624 1
      nr_bytes = sim_d10v_translate_dmap_addr (off, nr_bytes, &phys,
d629 1
a629 1
      nr_bytes = sim_d10v_translate_imap_addr (off, nr_bytes, &phys,
d730 2
a731 4
      phys_size = sim_d10v_translate_addr (virt, size,
					   &phys,
					   dmap_register,
					   imap_register);
d900 1
a900 1
  phys_size = sim_d10v_translate_dmap_addr (offset, 1, &phys,
d927 2
a928 1
  int phys_size = sim_d10v_translate_imap_addr (offset, 1, &phys, imap_register);
d1376 1
a1376 1
      WRITE_16 (memory, imap_register (rn - SIM_D10V_IMAP0_REGNUM));
d1383 1
a1383 1
      WRITE_16 (memory, dmap_register (rn - SIM_D10V_DMAP0_REGNUM));
@


1.13.16.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d366 1
a366 1
dmap_register (void *regcache, int reg_nr)
d389 1
a389 1
imap_register (void *regcache, int reg_nr)
d443 1
a443 3
			      void *regcache,
			      unsigned long (*dmap_register) (void *regcache,
							      int reg_nr))
d460 1
a460 1
  map = dmap_register (regcache, regno);
d501 1
a501 3
			      void *regcache,
			      unsigned long (*imap_register) (void *regcache,
							      int reg_nr))
d520 1
a520 1
  map = imap_register (regcache, regno);
d552 2
a553 5
			 void *regcache,
			 unsigned long (*dmap_register) (void *regcache,
							 int reg_nr),
			 unsigned long (*imap_register) (void *regcache,
							 int reg_nr))
d617 1
a617 1
      nr_bytes = sim_d10v_translate_dmap_addr (off, nr_bytes, &phys, regcache,
d622 1
a622 1
      nr_bytes = sim_d10v_translate_imap_addr (off, nr_bytes, &phys, regcache,
d723 4
a726 2
      phys_size = sim_d10v_translate_addr (virt, size, &phys, NULL,
					   dmap_register, imap_register);
d895 1
a895 1
  phys_size = sim_d10v_translate_dmap_addr (offset, 1, &phys, NULL,
d922 1
a922 2
  int phys_size = sim_d10v_translate_imap_addr (offset, 1, &phys, NULL,
						imap_register);
d1370 1
a1370 1
      WRITE_16 (memory, imap_register (NULL, rn - SIM_D10V_IMAP0_REGNUM));
d1377 1
a1377 1
      WRITE_16 (memory, dmap_register (NULL, rn - SIM_D10V_DMAP0_REGNUM));
@


1.12
log
@Fix for transfers across segments.
@
text
@d791 1
a791 1
     struct _bfd *abfd;
d1197 1
a1197 1
     struct _bfd *abfd;
@


1.12.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d366 1
a366 1
dmap_register (void *regcache, int reg_nr)
d389 1
a389 1
imap_register (void *regcache, int reg_nr)
d443 1
a443 3
			      void *regcache,
			      unsigned long (*dmap_register) (void *regcache,
							      int reg_nr))
d460 1
a460 1
  map = dmap_register (regcache, regno);
d501 1
a501 3
			      void *regcache,
			      unsigned long (*imap_register) (void *regcache,
							      int reg_nr))
d520 1
a520 1
  map = imap_register (regcache, regno);
d552 2
a553 5
			 void *regcache,
			 unsigned long (*dmap_register) (void *regcache,
							 int reg_nr),
			 unsigned long (*imap_register) (void *regcache,
							 int reg_nr))
d617 1
a617 1
      nr_bytes = sim_d10v_translate_dmap_addr (off, nr_bytes, &phys, regcache,
d622 1
a622 1
      nr_bytes = sim_d10v_translate_imap_addr (off, nr_bytes, &phys, regcache,
d716 13
a728 7
  uint8 *memory;
  unsigned long phys;
  int phys_size;
  phys_size = sim_d10v_translate_addr (virt, size, &phys, NULL,
				       dmap_register, imap_register);
  if (phys_size == 0)
    return 0;
d730 1
a730 1
  memory = map_memory (phys);
d733 5
a737 5
  if ((d10v_debug & DEBUG_INSTRUCTION) != 0)
    {
      (*d10v_callback->printf_filtered)
	(d10v_callback,
	 "sim_%s %d bytes: 0x%08lx (%s) -> 0x%08lx (%s) -> 0x%08lx (%s)\n",
d739 4
a742 4
	 phys_size, virt, last_from,
	 phys, last_to,
	 (long) memory, last_segname);
    }
d745 13
a757 3
  if (write_p)
    {
      memcpy (memory, buffer, phys_size);
d759 2
a760 6
  else
    {
      memcpy (buffer, memory, phys_size);
    }
  
  return phys_size;
d791 1
a791 1
     struct bfd *abfd;
d895 1
a895 1
  phys_size = sim_d10v_translate_dmap_addr (offset, 1, &phys, NULL,
d922 1
a922 2
  int phys_size = sim_d10v_translate_imap_addr (offset, 1, &phys, NULL,
						imap_register);
d1197 1
a1197 1
     struct bfd *abfd;
d1370 1
a1370 1
      WRITE_16 (memory, imap_register (NULL, rn - SIM_D10V_IMAP0_REGNUM));
d1377 1
a1377 1
      WRITE_16 (memory, dmap_register (NULL, rn - SIM_D10V_DMAP0_REGNUM));
@


1.12.8.1
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d791 1
a791 1
     struct bfd *abfd;
d1197 1
a1197 1
     struct bfd *abfd;
@


1.12.8.2
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d366 1
a366 1
dmap_register (void *regcache, int reg_nr)
d389 1
a389 1
imap_register (void *regcache, int reg_nr)
d443 1
a443 3
			      void *regcache,
			      unsigned long (*dmap_register) (void *regcache,
							      int reg_nr))
d460 1
a460 1
  map = dmap_register (regcache, regno);
d501 1
a501 3
			      void *regcache,
			      unsigned long (*imap_register) (void *regcache,
							      int reg_nr))
d520 1
a520 1
  map = imap_register (regcache, regno);
d552 2
a553 5
			 void *regcache,
			 unsigned long (*dmap_register) (void *regcache,
							 int reg_nr),
			 unsigned long (*imap_register) (void *regcache,
							 int reg_nr))
d617 1
a617 1
      nr_bytes = sim_d10v_translate_dmap_addr (off, nr_bytes, &phys, regcache,
d622 1
a622 1
      nr_bytes = sim_d10v_translate_imap_addr (off, nr_bytes, &phys, regcache,
d723 4
a726 2
      phys_size = sim_d10v_translate_addr (virt, size, &phys, NULL,
					   dmap_register, imap_register);
d895 1
a895 1
  phys_size = sim_d10v_translate_dmap_addr (offset, 1, &phys, NULL,
d922 1
a922 2
  int phys_size = sim_d10v_translate_imap_addr (offset, 1, &phys, NULL,
						imap_register);
d1370 1
a1370 1
      WRITE_16 (memory, imap_register (NULL, rn - SIM_D10V_IMAP0_REGNUM));
d1377 1
a1377 1
      WRITE_16 (memory, dmap_register (NULL, rn - SIM_D10V_DMAP0_REGNUM));
@


1.12.8.3
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d723 1
a723 7
  uint8 *memory;
  unsigned long phys;
  int phys_size;
  phys_size = sim_d10v_translate_addr (virt, size, &phys, NULL,
				       dmap_register, imap_register);
  if (phys_size == 0)
    return 0;
d725 11
a735 1
  memory = map_memory (phys);
d738 5
a742 5
  if ((d10v_debug & DEBUG_INSTRUCTION) != 0)
    {
      (*d10v_callback->printf_filtered)
	(d10v_callback,
	 "sim_%s %d bytes: 0x%08lx (%s) -> 0x%08lx (%s) -> 0x%08lx (%s)\n",
d744 4
a747 4
	 phys_size, virt, last_from,
	 phys, last_to,
	 (long) memory, last_segname);
    }
d750 13
a762 3
  if (write_p)
    {
      memcpy (memory, buffer, phys_size);
d764 2
a765 6
  else
    {
      memcpy (buffer, memory, phys_size);
    }
  
  return phys_size;
@


1.11
log
@Move include/callback.h and include/remote-sim.h to include/gdb/.
Update accordingly.
@
text
@d718 1
a718 1
  while (xfered < size)
d757 1
d760 1
a760 1
  return size;
@


1.10
log
@Fix name of enum used in cast (sim_fetch_register, sim_store_register).
@
text
@d4 2
a5 2
#include "callback.h"
#include "remote-sim.h"
@


1.9
log
@Fill-out d10v enum so that there are no ``=''.
@
text
@d1310 1
a1310 1
  switch ((enum gdb_d10v_regs) rn)
d1397 1
a1397 1
  switch ((enum sim_d10v_reg) rn)
@


1.8
log
@2002-05-28  Elena Zannoni  <ezannoni@@redhat.com>

	* interp.c (sim_create_inferior): Add comment.

	From Alan Matsuoka <alanm@@redhat.com>:
	From 2001-04-27 Jason Eckhardt <jle@@cygnus.com>:
	* simops.c (OP_4400): Output "mvf0f" instead of "mf0f".
	(OP_4401): Output "mvf0t" instead of "mf0t".
	(OP_460B): Do not output a flag register.
	(OP_4609): Do not output a flag register.
@
text
@d1310 1
a1310 4
  if (rn < 0)
    size = 0;
  else if (rn >= SIM_D10V_R0_REGNUM
	   && rn < SIM_D10V_R0_REGNUM + SIM_D10V_NR_R_REGS)
d1312 16
d1330 17
a1346 4
    }
  else if (rn >= SIM_D10V_CR0_REGNUM
	   && rn < SIM_D10V_CR0_REGNUM + SIM_D10V_NR_CR_REGS)
    {
d1349 3
a1351 4
    }
  else if (rn >= SIM_D10V_A0_REGNUM
	   && rn < SIM_D10V_A0_REGNUM + SIM_D10V_NR_A_REGS)
    {
d1354 2
a1355 3
    }
  else if (rn == SIM_D10V_SPI_REGNUM)
    {
d1360 2
a1361 3
    }
  else if (rn == SIM_D10V_SPU_REGNUM)
    {
d1366 3
a1368 4
    }
  else if (rn >= SIM_D10V_IMAP0_REGNUM
	   && rn < SIM_D10V_IMAP0_REGNUM + SIM_D10V_NR_IMAP_REGS)
    {
d1371 5
a1375 4
    }
  else if (rn >= SIM_D10V_DMAP0_REGNUM
	   && rn < SIM_D10V_DMAP0_REGNUM + SIM_D10V_NR_DMAP_REGS)
    {
d1378 7
a1385 2
  else
    size = 0;
d1397 1
a1397 4
  if (rn < 0)
    size = 0;
  else if (rn >= SIM_D10V_R0_REGNUM
	   && rn < SIM_D10V_R0_REGNUM + SIM_D10V_NR_R_REGS)
d1399 16
d1417 17
a1433 4
    }
  else if (rn >= SIM_D10V_CR0_REGNUM
	   && rn < SIM_D10V_CR0_REGNUM + SIM_D10V_NR_CR_REGS)
    {
d1436 3
a1438 4
    }
  else if (rn >= SIM_D10V_A0_REGNUM
	   && rn < SIM_D10V_A0_REGNUM + SIM_D10V_NR_A_REGS)
    {
d1441 2
a1442 3
    }
  else if (rn == SIM_D10V_SPI_REGNUM)
    {
d1447 2
a1448 3
    }
  else if (rn == SIM_D10V_SPU_REGNUM)
    {
d1451 3
a1453 4
    }
  else if (rn >= SIM_D10V_IMAP0_REGNUM
	   && rn < SIM_D10V_IMAP0_REGNUM + SIM_D10V_NR_IMAP_REGS)
    {
d1456 5
a1460 4
    }
  else if (rn >= SIM_D10V_DMAP0_REGNUM
	   && rn < SIM_D10V_DMAP0_REGNUM + SIM_D10V_NR_DMAP_REGS)
    {
d1463 7
a1470 2
  else
    size = 0;
@


1.8.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d4 2
a5 2
#include "gdb/callback.h"
#include "gdb/remote-sim.h"
d718 1
a718 1
  while (0 < size)
a756 1
      size -= phys_size;
d759 1
a759 1
  return xfered;
d1310 4
a1313 1
  switch ((enum sim_d10v_regs) rn)
a1314 16
    case SIM_D10V_R0_REGNUM:
    case SIM_D10V_R1_REGNUM:
    case SIM_D10V_R2_REGNUM:
    case SIM_D10V_R3_REGNUM:
    case SIM_D10V_R4_REGNUM:
    case SIM_D10V_R5_REGNUM:
    case SIM_D10V_R6_REGNUM:
    case SIM_D10V_R7_REGNUM:
    case SIM_D10V_R8_REGNUM:
    case SIM_D10V_R9_REGNUM:
    case SIM_D10V_R10_REGNUM:
    case SIM_D10V_R11_REGNUM:
    case SIM_D10V_R12_REGNUM:
    case SIM_D10V_R13_REGNUM:
    case SIM_D10V_R14_REGNUM:
    case SIM_D10V_R15_REGNUM:
d1317 4
a1320 17
      break;
    case SIM_D10V_CR0_REGNUM:
    case SIM_D10V_CR1_REGNUM:
    case SIM_D10V_CR2_REGNUM:
    case SIM_D10V_CR3_REGNUM:
    case SIM_D10V_CR4_REGNUM:
    case SIM_D10V_CR5_REGNUM:
    case SIM_D10V_CR6_REGNUM:
    case SIM_D10V_CR7_REGNUM:
    case SIM_D10V_CR8_REGNUM:
    case SIM_D10V_CR9_REGNUM:
    case SIM_D10V_CR10_REGNUM:
    case SIM_D10V_CR11_REGNUM:
    case SIM_D10V_CR12_REGNUM:
    case SIM_D10V_CR13_REGNUM:
    case SIM_D10V_CR14_REGNUM:
    case SIM_D10V_CR15_REGNUM:
d1323 4
a1326 3
      break;
    case SIM_D10V_A0_REGNUM:
    case SIM_D10V_A1_REGNUM:
d1329 3
a1331 2
      break;
    case SIM_D10V_SPI_REGNUM:
d1336 3
a1338 2
      break;
    case SIM_D10V_SPU_REGNUM:
d1343 4
a1346 3
      break;
    case SIM_D10V_IMAP0_REGNUM:
    case SIM_D10V_IMAP1_REGNUM:
d1349 4
a1352 5
      break;
    case SIM_D10V_DMAP0_REGNUM:
    case SIM_D10V_DMAP1_REGNUM:
    case SIM_D10V_DMAP2_REGNUM:
    case SIM_D10V_DMAP3_REGNUM:
a1354 7
      break;
    case SIM_D10V_TS2_DMAP_REGNUM:
      size = 0;
      break;
    default:
      size = 0;
      break;
d1356 2
d1369 4
a1372 1
  switch ((enum sim_d10v_regs) rn)
a1373 16
    case SIM_D10V_R0_REGNUM:
    case SIM_D10V_R1_REGNUM:
    case SIM_D10V_R2_REGNUM:
    case SIM_D10V_R3_REGNUM:
    case SIM_D10V_R4_REGNUM:
    case SIM_D10V_R5_REGNUM:
    case SIM_D10V_R6_REGNUM:
    case SIM_D10V_R7_REGNUM:
    case SIM_D10V_R8_REGNUM:
    case SIM_D10V_R9_REGNUM:
    case SIM_D10V_R10_REGNUM:
    case SIM_D10V_R11_REGNUM:
    case SIM_D10V_R12_REGNUM:
    case SIM_D10V_R13_REGNUM:
    case SIM_D10V_R14_REGNUM:
    case SIM_D10V_R15_REGNUM:
d1376 4
a1379 17
      break;
    case SIM_D10V_CR0_REGNUM:
    case SIM_D10V_CR1_REGNUM:
    case SIM_D10V_CR2_REGNUM:
    case SIM_D10V_CR3_REGNUM:
    case SIM_D10V_CR4_REGNUM:
    case SIM_D10V_CR5_REGNUM:
    case SIM_D10V_CR6_REGNUM:
    case SIM_D10V_CR7_REGNUM:
    case SIM_D10V_CR8_REGNUM:
    case SIM_D10V_CR9_REGNUM:
    case SIM_D10V_CR10_REGNUM:
    case SIM_D10V_CR11_REGNUM:
    case SIM_D10V_CR12_REGNUM:
    case SIM_D10V_CR13_REGNUM:
    case SIM_D10V_CR14_REGNUM:
    case SIM_D10V_CR15_REGNUM:
d1382 4
a1385 3
      break;
    case SIM_D10V_A0_REGNUM:
    case SIM_D10V_A1_REGNUM:
d1388 3
a1390 2
      break;
    case SIM_D10V_SPI_REGNUM:
d1395 3
a1397 2
      break;
    case SIM_D10V_SPU_REGNUM:
d1400 4
a1403 3
      break;
    case SIM_D10V_IMAP0_REGNUM:
    case SIM_D10V_IMAP1_REGNUM:
d1406 4
a1409 5
      break;
    case SIM_D10V_DMAP0_REGNUM:
    case SIM_D10V_DMAP1_REGNUM:
    case SIM_D10V_DMAP2_REGNUM:
    case SIM_D10V_DMAP3_REGNUM:
a1411 7
      break;
    case SIM_D10V_TS2_DMAP_REGNUM:
      size = 0;
      break;
    default:
      size = 0;
      break;
d1413 2
@


1.7
log
@* sim-d10v.h: Delete file.  Moved to include/gdb/.

* sim-d10v.h: New file.  Moved from include/sim-d10v.h.

* Makefile.in (INCLUDE): Add "gdb/sim-d10v.h".
* interp.c: Include "gdb/sim-d10v.h" instead of "sim-d10v.h".

* d10v-tdep.c: Include "gdb/sim-d10v.h" instead of "sim-d10v.h".
* Makefile.in (sim_d10v_h): Update definition.
@
text
@d1205 8
@


1.6
log
@Removed a section of code that didn't do anything, but left values in
memory. This was labeled as a hack to set r0/r1 with argc/argv.
@
text
@d8 1
a8 1
#include "sim-d10v.h"
@


1.6.6.1
log
@merge from trunk
@
text
@d4 2
a5 2
#include "gdb/callback.h"
#include "gdb/remote-sim.h"
d8 1
a8 1
#include "gdb/sim-d10v.h"
a1204 8
  /* There was a hack here to copy the values of argc and argv into r0
     and r1.  The values were also saved into some high memory that
     won't be overwritten by the stack (0x7C00).  The reason for doing
     this was to allow the 'run' program to accept arguments.  Without
     the hack, this is not possible anymore.  If the simulator is run
     from the debugger, arguments cannot be passed in, so this makes
     no difference.  */

d1302 4
a1305 1
  switch ((enum sim_d10v_regs) rn)
a1306 16
    case SIM_D10V_R0_REGNUM:
    case SIM_D10V_R1_REGNUM:
    case SIM_D10V_R2_REGNUM:
    case SIM_D10V_R3_REGNUM:
    case SIM_D10V_R4_REGNUM:
    case SIM_D10V_R5_REGNUM:
    case SIM_D10V_R6_REGNUM:
    case SIM_D10V_R7_REGNUM:
    case SIM_D10V_R8_REGNUM:
    case SIM_D10V_R9_REGNUM:
    case SIM_D10V_R10_REGNUM:
    case SIM_D10V_R11_REGNUM:
    case SIM_D10V_R12_REGNUM:
    case SIM_D10V_R13_REGNUM:
    case SIM_D10V_R14_REGNUM:
    case SIM_D10V_R15_REGNUM:
d1309 4
a1312 17
      break;
    case SIM_D10V_CR0_REGNUM:
    case SIM_D10V_CR1_REGNUM:
    case SIM_D10V_CR2_REGNUM:
    case SIM_D10V_CR3_REGNUM:
    case SIM_D10V_CR4_REGNUM:
    case SIM_D10V_CR5_REGNUM:
    case SIM_D10V_CR6_REGNUM:
    case SIM_D10V_CR7_REGNUM:
    case SIM_D10V_CR8_REGNUM:
    case SIM_D10V_CR9_REGNUM:
    case SIM_D10V_CR10_REGNUM:
    case SIM_D10V_CR11_REGNUM:
    case SIM_D10V_CR12_REGNUM:
    case SIM_D10V_CR13_REGNUM:
    case SIM_D10V_CR14_REGNUM:
    case SIM_D10V_CR15_REGNUM:
d1315 4
a1318 3
      break;
    case SIM_D10V_A0_REGNUM:
    case SIM_D10V_A1_REGNUM:
d1321 3
a1323 2
      break;
    case SIM_D10V_SPI_REGNUM:
d1328 3
a1330 2
      break;
    case SIM_D10V_SPU_REGNUM:
d1335 4
a1338 3
      break;
    case SIM_D10V_IMAP0_REGNUM:
    case SIM_D10V_IMAP1_REGNUM:
d1341 4
a1344 5
      break;
    case SIM_D10V_DMAP0_REGNUM:
    case SIM_D10V_DMAP1_REGNUM:
    case SIM_D10V_DMAP2_REGNUM:
    case SIM_D10V_DMAP3_REGNUM:
a1346 7
      break;
    case SIM_D10V_TS2_DMAP_REGNUM:
      size = 0;
      break;
    default:
      size = 0;
      break;
d1348 2
d1361 4
a1364 1
  switch ((enum sim_d10v_regs) rn)
a1365 16
    case SIM_D10V_R0_REGNUM:
    case SIM_D10V_R1_REGNUM:
    case SIM_D10V_R2_REGNUM:
    case SIM_D10V_R3_REGNUM:
    case SIM_D10V_R4_REGNUM:
    case SIM_D10V_R5_REGNUM:
    case SIM_D10V_R6_REGNUM:
    case SIM_D10V_R7_REGNUM:
    case SIM_D10V_R8_REGNUM:
    case SIM_D10V_R9_REGNUM:
    case SIM_D10V_R10_REGNUM:
    case SIM_D10V_R11_REGNUM:
    case SIM_D10V_R12_REGNUM:
    case SIM_D10V_R13_REGNUM:
    case SIM_D10V_R14_REGNUM:
    case SIM_D10V_R15_REGNUM:
d1368 4
a1371 17
      break;
    case SIM_D10V_CR0_REGNUM:
    case SIM_D10V_CR1_REGNUM:
    case SIM_D10V_CR2_REGNUM:
    case SIM_D10V_CR3_REGNUM:
    case SIM_D10V_CR4_REGNUM:
    case SIM_D10V_CR5_REGNUM:
    case SIM_D10V_CR6_REGNUM:
    case SIM_D10V_CR7_REGNUM:
    case SIM_D10V_CR8_REGNUM:
    case SIM_D10V_CR9_REGNUM:
    case SIM_D10V_CR10_REGNUM:
    case SIM_D10V_CR11_REGNUM:
    case SIM_D10V_CR12_REGNUM:
    case SIM_D10V_CR13_REGNUM:
    case SIM_D10V_CR14_REGNUM:
    case SIM_D10V_CR15_REGNUM:
d1374 4
a1377 3
      break;
    case SIM_D10V_A0_REGNUM:
    case SIM_D10V_A1_REGNUM:
d1380 3
a1382 2
      break;
    case SIM_D10V_SPI_REGNUM:
d1387 3
a1389 2
      break;
    case SIM_D10V_SPU_REGNUM:
d1392 4
a1395 3
      break;
    case SIM_D10V_IMAP0_REGNUM:
    case SIM_D10V_IMAP1_REGNUM:
d1398 4
a1401 5
      break;
    case SIM_D10V_DMAP0_REGNUM:
    case SIM_D10V_DMAP1_REGNUM:
    case SIM_D10V_DMAP2_REGNUM:
    case SIM_D10V_DMAP3_REGNUM:
a1403 7
      break;
    case SIM_D10V_TS2_DMAP_REGNUM:
      size = 0;
      break;
    default:
      size = 0;
      break;
d1405 2
@


1.6.6.2
log
@merge with trunk
@
text
@d718 1
a718 1
  while (0 < size)
a756 1
      size -= phys_size;
d759 1
a759 1
  return xfered;
@


1.5
log
@Add missing ChangeLog.
Sync with mitsu's version.
@
text
@a1204 19
  if (argv)
    {
      /* a hack to set r0/r1 with argc/argv */
      /* some high memory that won't be overwritten by the stack soon */
      bfd_vma addr = 0x7C00;
      int p = 20;
      int i = 0;
      while (argv[i])
 	{
 	  int size = strlen (argv[i]) + 1;
 	  SW (addr + 2*i, addr + p); 
 	  sim_write (sd, addr + 0, argv[i], size);
 	  p += size;
 	  i++;
 	}
      SET_GPR (0, addr);
      SET_GPR (1, i);
    }

@


1.4
log
@Add support for SIGILL (reserved-instruction-exception).
@
text
@d1255 2
a1256 1
      set_dmap_register (2, 0x0000); /* Old DMAP, Value is not 0x2000 */
@


1.3
log
@When SIM_HAVE_ENVIRONMENT: use sim_set_trace() to enable tracing
instead of sim_trace() to run the program; include support for ``-o''
option (operating environment); when a signal occurs, only continue
execution when operating environment mode.
Update d10v.
@
text
@a101 2
	  (*d10v_callback->printf_filtered)
	    (d10v_callback, "ERROR: Illegal instruction %x at PC %x\n", ins, PC);
d978 7
@


1.3.2.1
log
@Import d10v fixes from trunk.
@
text
@d102 2
a981 7
    case SIGILL:
      SET_BPC (PC);
      SET_BPSW (PSW);
      SET_HW_PSW ((PSW & (PSW_F0_BIT | PSW_F1_BIT | PSW_C_BIT)));
      JMP (RIE_VECTOR_START);
      SLOT_FLUSH ();
      break;
d1250 1
a1250 2
      set_dmap_register (2, 0x2000); /* DMAP2 initial internal value is
					0x2000 on the new board. */
@


1.2
log
@Report SIGBUS and halt simulation when ld/st detect a misaligned address.
@
text
@d1075 2
a1076 3
int
sim_trace (sd)
     SIM_DESC sd;
a1077 2
  enum sim_stop reason;
  static int sigrc = 0;
a1080 5
  /* NOTE: SIGRC starts with zero and is then, always the value
     returned by the last sim_stop_reason() call. */
  sim_resume (sd, 0, sigrc);
  sim_stop_reason (sd, &reason, &sigrc);
  return (reason != sim_stopped || sigrc != SIGINT);
@


1.1
log
@Initial revision
@
text
@d8 1
a8 5

#define IMEM_SIZE 18		/* D10V instruction memory size is 18 bits */
#define DMEM_SIZE 16		/* Data memory is 64K (but only 32K internal RAM) */
#define UMEM_SIZE 17		/* Each unified memory segment is 17 bits */
#define UMEM_SEGMENTS 128	/* Number of segments in unified memory region */
d15 5
d42 12
d102 5
a106 2
	  (*d10v_callback->printf_filtered) (d10v_callback, "ERROR looking up hash for %x at PC %x\n",ins, PC);
	  exit (1);
d161 2
d198 2
d211 2
d234 2
d237 2
d319 11
a329 2

  if (State.imem)
d331 2
a332 10
      for (i=0;i<UMEM_SEGMENTS;i++)
	{
	  if (State.umem[i])
	    {
	      free (State.umem[i]);
	      State.umem[i] = NULL;
	    }
	}
      free (State.imem);
      free (State.dmem);
d334 17
d352 8
a359 9
  State.imem = (uint8 *)calloc(1,1<<IMEM_SIZE);
  State.dmem = (uint8 *)calloc(1,1<<DMEM_SIZE);
  for (i=1;i<(UMEM_SEGMENTS-1);i++)
    State.umem[i] = NULL;
  State.umem[0] = (uint8 *)calloc(1,1<<UMEM_SIZE);
  State.umem[1] = (uint8 *)calloc(1,1<<UMEM_SIZE);
  State.umem[2] = (uint8 *)calloc(1,1<<UMEM_SIZE);
  State.umem[UMEM_SEGMENTS-1] = (uint8 *)calloc(1,1<<UMEM_SIZE);
  if (!State.imem || !State.dmem || !State.umem[0] || !State.umem[1] || !State.umem[2] || !State.umem[UMEM_SEGMENTS-1] )
d361 2
a362 2
      (*d10v_callback->printf_filtered) (d10v_callback, "Memory allocation failed.\n");
      exit(1);
d364 17
a380 1
  
d382 1
a382 1
  if ((d10v_debug & DEBUG_MEMSIZE) != 0)
d384 2
a385 7
      char buffer[20];
      (*d10v_callback->printf_filtered) (d10v_callback,
					 "Allocated %s bytes instruction memory and\n",
					 add_commas (buffer, sizeof (buffer), (1UL<<IMEM_SIZE)));

      (*d10v_callback->printf_filtered) (d10v_callback, "          %s bytes data memory.\n",
					 add_commas (buffer, sizeof (buffer), (1UL<<IMEM_SIZE)));
d390 39
a428 6
/* Transfer data to/from simulated memory.  Since a bug in either the
   simulated program or in gdb or the simulator itself may cause a
   bogus address to be passed in, we need to do some sanity checking
   on addresses to make sure they are within bounds.  When an address
   fails the bounds check, treat it as a zero length read/write rather
   than aborting the entire run. */
d430 2
a431 5
static int
xfer_mem (SIM_ADDR addr,
	  unsigned char *buffer,
	  int size,
	  int write_p)
d433 7
a439 3
  unsigned char *memory;
  int segment = ((addr >> 24) & 0xff);
  addr = (addr & 0x00ffffff);
d441 31
a471 2
#ifdef DEBUG
  if ((d10v_debug & DEBUG_INSTRUCTION) != 0)
d473 3
a475 1
      if (write_p)
d477 14
a490 1
	  (*d10v_callback->printf_filtered) (d10v_callback, "sim_write %d bytes to 0x%02x:%06x\n", size, segment, addr);
d492 81
a572 1
      else
d574 15
a588 1
	  (*d10v_callback->printf_filtered) (d10v_callback, "sim_read %d bytes from 0x%2x:%6x\n", size, segment, addr);
a590 1
#endif
d592 47
a638 7
  /* to access data, we use the following mapping 
      0x00xxxxxx: Logical data address segment        (DMAP translated memory)
      0x01xxxxxx: Logical instruction address segment (IMAP translated memory)
      0x10xxxxxx: Physical data memory segment        (On-chip data memory)
      0x11xxxxxx: Physical instruction memory segment (On-chip insn memory)
      0x12xxxxxx: Phisical unified memory segment     (Unified memory)
   */
d640 8
d650 2
a651 1
    case 0x00: /* DMAP translated memory */
d653 2
a654 40
	int byte;
	for (byte = 0; byte < size; byte++)
	  {
	    uint8 *mem = dmem_addr (addr + byte);
	    if (mem == NULL)
	      return byte;
	    else if (write_p)
	      *mem = buffer[byte];
	    else
	      buffer[byte] = *mem;
	  }
	return byte;
      }

    case 0x01: /* IMAP translated memory */
      {
	int byte;
	for (byte = 0; byte < size; byte++)
	  {
	    uint8 *mem = imem_addr (addr + byte);
	    if (mem == NULL)
	      return byte;
	    else if (write_p)
	      *mem = buffer[byte];
	    else
	      buffer[byte] = *mem;
	  }
	return byte;
      }

    case 0x10: /* On-chip data memory */
      {
	addr &= ((1 << DMEM_SIZE) - 1);
	if ((addr + size) > (1 << DMEM_SIZE))
	  {
	    (*d10v_callback->printf_filtered) (d10v_callback, "ERROR: data address 0x%x is outside range 0-0x%x.\n",
					       addr + size - 1, (1 << DMEM_SIZE) - 1);
	    return (0);
	  }
	memory = State.dmem + addr;
d657 2
a658 2

    case 0x11: /* On-chip insn memory */
d660 2
a661 8
	addr &= ((1 << IMEM_SIZE) - 1);
	if ((addr + size) > (1 << IMEM_SIZE))
	  {
	    (*d10v_callback->printf_filtered) (d10v_callback, "ERROR: instruction address 0x%x is outside range 0-0x%x.\n",
					       addr + size - 1, (1 << IMEM_SIZE) - 1);
	    return (0);
	  }
	memory = State.imem + addr;
d664 2
a665 2

    case 0x12: /* Unified memory */
d667 1
a667 12
	int startsegment, startoffset;	/* Segment and offset within segment where xfer starts */
	int endsegment, endoffset;	/* Segment and offset within segment where xfer ends */
	
	startsegment = addr >> UMEM_SIZE;
	startoffset = addr & ((1 << UMEM_SIZE) - 1);
	endsegment = (addr + size) >> UMEM_SIZE;
	endoffset = (addr + size) & ((1 << UMEM_SIZE) - 1);
	
	/* FIXME: We do not currently implement xfers across segments,
           so detect this case and fail gracefully. */
	
	if ((startsegment != endsegment) && !((endsegment == (startsegment + 1)) && endoffset == 0))
d669 2
a670 7
	    (*d10v_callback->printf_filtered) (d10v_callback, "ERROR: Unimplemented support for transfers across unified memory segment boundaries\n");
	    return (0);
	  }
	if (!State.umem[startsegment])
	  {
#ifdef DEBUG
	    if ((d10v_debug & DEBUG_MEMSIZE) != 0)
d672 2
a673 2
		(*d10v_callback->printf_filtered) (d10v_callback,"Allocating %s bytes unified memory to region %d\n",
						   add_commas (buffer, sizeof (buffer), (1UL<<IMEM_SIZE)), startsegment);
d675 2
a676 7
#endif
	    State.umem[startsegment] = (uint8 *)calloc(1,1<<UMEM_SIZE);
	  }
	if (!State.umem[startsegment])
	  {
	    (*d10v_callback->printf_filtered) (d10v_callback, "ERROR: Memory allocation of 0x%x bytes failed.\n", 1<<UMEM_SIZE);
	    return (0);
d678 3
a680 1
	memory = State.umem[startsegment] + startoffset;
d683 1
a683 1

d685 3
a687 9
      {
	(*d10v_callback->printf_filtered) (d10v_callback, "ERROR: address 0x%lx is not in valid range\n", (long) addr);
 	(*d10v_callback->printf_filtered) (d10v_callback, "0x00xxxxxx:  Logical data address segment		(DMAP translated memory)\n");
 	(*d10v_callback->printf_filtered) (d10v_callback, "0x01xxxxxx:  Logical instruction address segment	(IMAP translated memory)\n");
 	(*d10v_callback->printf_filtered) (d10v_callback, "0x10xxxxxx:  Physical data memory segment		(On-chip data memory)\n");
 	(*d10v_callback->printf_filtered) (d10v_callback, "0x11xxxxxx:  Physical instruction memory segment	(On-chip insn memory)\n");
 	(*d10v_callback->printf_filtered) (d10v_callback, "0x12xxxxxx:  Phisical unified memory segment		(Unified memory)\n");
	return (0);
      }
d689 2
a690 2

  if (write_p)
d692 6
a697 1
      memcpy (memory, buffer, size);
d699 22
a720 1
  else
d722 37
a758 1
      memcpy (buffer, memory, size);
d803 1
d805 3
d810 2
d813 1
a813 1
      if (strcmp (*p, "-t") == 0)
d815 3
a818 1
#endif
d849 2
a850 2
  if (!State.imem)
    sim_size(1);
a884 1

d886 1
a886 2
dmem_addr( addr )
     uint32 addr;
d888 3
a890 1
  int seg;
d892 3
a894 1
  addr &= 0xffff;
d896 3
a898 1
  if (addr > 0xbfff)
d900 1
a900 8
      if ( (addr & 0xfff0) != 0xff00)
	{
	  (*d10v_callback->printf_filtered) (d10v_callback, "Data address 0x%lx is in I/O space, pc = 0x%lx.\n",
					     (long)addr, (long)decode_pc ());
	  State.exception = SIGBUS;
	}

      return State.dmem + addr;
d902 4
a905 2
  
  if (addr > 0x7fff)
d907 7
a913 15
      if (DMAP & 0x1000)
	{
	  /* instruction memory */
 	  return (DMAP & 0xf) * 0x4000 + State.imem + (addr - 0x8000);
	}
      else 
	{
	  /* unified memory */
	  /* this is ugly because we allocate unified memory in 128K segments and */
	  /* dmap addresses 16k segments */
	  seg = (DMAP & 0x3ff) >> 3;
	  if (State.umem[seg] == NULL)
	    {
#ifdef DEBUG
	      (*d10v_callback->printf_filtered) (d10v_callback,"Allocating %d bytes unified memory to region %d\n", 1<<UMEM_SIZE, seg);
d915 1
a915 13
	      State.umem[seg] = (uint8 *)calloc(1,1<<UMEM_SIZE);
	      if (!State.umem[seg])
		{
		  (*d10v_callback->printf_filtered) (d10v_callback, 
		      "ERROR:  alloc failed. unified memory region %d unmapped, pc = 0x%lx\n", 
		      seg, (long)decode_pc ());
		  State.exception = SIGBUS;
		}
	    }
	  return State.umem[seg] + (DMAP & 7) * 0x4000 + (addr - 0x8000);
	}
    }
  return State.dmem + addr;
a917 1

d919 1
a919 1
imem_addr (uint32 pc)
d921 20
a940 17
  uint16 imap;

  if (pc & 0x20000)
    imap = IMAP1;
  else
    imap = IMAP0;
  
  if (imap & 0x1000)
    return State.imem + pc;

  if (State.umem[imap & 0xff] == NULL)
    return 0;

  /* Discard upper bit(s) of PC in case IMAP1 selects unified memory. */
  pc &= (1 << UMEM_SIZE) - 1;

  return State.umem[imap & 0xff] + pc;
a942 1

d968 19
d990 1
a990 1
      if (iaddr == NULL)
d1061 7
d1079 2
d1084 5
a1088 2
  sim_resume (sd, 0, 0);
  return 1;
d1206 1
a1206 1
  memset (&State.regs, 0, (int)&State.imem - (int)&State.regs[0]);
d1238 12
a1249 7
  /* cpu resets imap0 to 0 and imap1 to 0x7f, but D10V-EVA board */
  /* resets imap0 and imap1 to 0x1000. */
  if (1)
    {
      SET_IMAP0 (0x0000);
      SET_IMAP1 (0x007f);
      SET_DMAP (0x0000);
d1253 7
a1259 3
      SET_IMAP0 (0x1000);
      SET_IMAP1 (0x1000);
      SET_DMAP(0);
d1294 9
d1322 47
a1368 10
  if (rn > 34)
    WRITE_64 (memory, ACC (rn-35));
  else if (rn == 32)
    WRITE_16 (memory, IMAP0);
  else if (rn == 33)
    WRITE_16 (memory, IMAP1);
  else if (rn == 34)
    WRITE_16 (memory, DMAP);
  else if (rn >= 16)
    WRITE_16 (memory, CREG (rn - 16));
d1370 2
a1371 2
    WRITE_16 (memory, GPR (rn));
  return -1;
d1381 45
a1425 10
  if (rn > 34)
    SET_ACC (rn-35, READ_64 (memory) & MASK40);
  else if (rn == 34)
    SET_DMAP( READ_16(memory) );
  else if (rn == 33)
    SET_IMAP1( READ_16(memory) );
  else if (rn == 32)
    SET_IMAP0( READ_16(memory) );
  else if (rn >= 16)
    SET_CREG (rn - 16, READ_16 (memory));
d1427 1
a1427 1
    SET_GPR (rn, READ_16 (memory));
d1429 1
a1429 1
  return -1;
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a41 11
#ifdef NEED_UI_LOOP_HOOK
/* How often to run the ui_loop update, when in use */
#define UI_LOOP_POLL_INTERVAL 0x14000

/* Counter for the ui_loop_hook update */
static long ui_loop_hook_counter = UI_LOOP_POLL_INTERVAL;

/* Actual hook to call to run through gdb's gui event loop */
extern int (*ui_loop_hook) PARAMS ((int signo));
#endif /* NEED_UI_LOOP_HOOK */

a786 7
#ifdef NEED_UI_LOOP_HOOK
      if (ui_loop_hook != NULL && ui_loop_hook_counter-- < 0)
	{
	  ui_loop_hook_counter = UI_LOOP_POLL_INTERVAL;
	  ui_loop_hook (0);
	}
#endif /* NEED_UI_LOOP_HOOK */
@


1.1.1.3
log
@import gdb-1999-09-13 snapshot
@
text
@a18 5

/* Set this to true to get the previous segment layout. */

int old_segment_mapping;

d378 6
a383 17
  /* To access data, we use the following mappings:

     0x00xxxxxx: Physical unified memory segment     (Unified memory)
     0x01xxxxxx: Physical instruction memory segment (On-chip insn memory)
     0x02xxxxxx: Physical data memory segment        (On-chip data memory)
     0x10xxxxxx: Logical data address segment        (DMAP translated memory)
     0x11xxxxxx: Logical instruction address segment (IMAP translated memory)

     Alternatively, the "old segment mapping" is still available by setting
     old_segment_mapping to 1.  It looks like this:

     0x00xxxxxx: Logical data address segment        (DMAP translated memory)
     0x01xxxxxx: Logical instruction address segment (IMAP translated memory)
     0x10xxxxxx: Physical data memory segment        (On-chip data memory)
     0x11xxxxxx: Physical instruction memory segment (On-chip insn memory)
     0x12xxxxxx: Physical unified memory segment     (Unified memory)

a385 25
  /* However, if we've asked to use the previous generation of segment
     mapping, rearrange the segments as follows. */

  if (old_segment_mapping)
    {
      switch (segment)
	{
	case 0x00: /* DMAP translated memory */
	  segment = 0x10;
	  break;
	case 0x01: /* IMAP translated memory */
	  segment = 0x11;
	  break;
	case 0x10: /* On-chip data memory */
	  segment = 0x02;
	  break;
	case 0x11: /* On-chip insn memory */
	  segment = 0x01;
	  break;
	case 0x12: /* Unified memory */
	  segment = 0x00;
	  break;
	}
    }

d388 1
a388 1
    case 0x10: /* DMAP translated memory */
d404 1
a404 1
    case 0x11: /* IMAP translated memory */
d420 1
a420 1
    case 0x02: /* On-chip data memory */
d433 1
a433 1
    case 0x01: /* On-chip insn memory */
d446 1
a446 1
    case 0x00: /* Unified memory */
d487 6
a492 17
	if (old_segment_mapping)
	  {
	    (*d10v_callback->printf_filtered) (d10v_callback, "0x00xxxxxx:  Logical data address segment            (DMAP translated memory)\n");
	    (*d10v_callback->printf_filtered) (d10v_callback, "0x01xxxxxx:  Logical instruction address segment     (IMAP translated memory)\n");
	    (*d10v_callback->printf_filtered) (d10v_callback, "0x10xxxxxx:  Physical data memory segment            (On-chip data memory)\n");
	    (*d10v_callback->printf_filtered) (d10v_callback, "0x11xxxxxx:  Physical instruction memory segment     (On-chip insn memory)\n");
	    (*d10v_callback->printf_filtered) (d10v_callback, "0x12xxxxxx:  Phisical unified memory segment         (Unified memory)\n");
	  }
	else
	  {
	    (*d10v_callback->printf_filtered) (d10v_callback, "0x00xxxxxx:  Physical unified memory segment		(Unified memory)\n");
	    (*d10v_callback->printf_filtered) (d10v_callback, "0x01xxxxxx:  Physical instruction memory segment	(On-chip insn memory)\n");
	    (*d10v_callback->printf_filtered) (d10v_callback, "0x02xxxxxx:  Physical data memory segment		(On-chip data memory)\n");
	    (*d10v_callback->printf_filtered) (d10v_callback, "0x10xxxxxx:  Logical data address segment		(DMAP translated memory)\n");
	    (*d10v_callback->printf_filtered) (d10v_callback, "0x11xxxxxx:  Logical instruction address segment	(IMAP translated memory)\n");
	  }
 	return (0);
a546 1
  old_segment_mapping = 0;
a549 2
      if (strcmp (*p, "-oldseg") == 0)
	old_segment_mapping = 1;
d551 1
a551 1
      else if (strcmp (*p, "-t") == 0)
d553 1
a554 1
      else
d972 1
a972 1
  if (old_segment_mapping)
@


1.1.1.4
log
@import gdb-1999-11-16 snapshot
@
text
@d8 5
a12 1
#include "sim-d10v.h"
a45 1
static INLINE uint8 *map_memory (unsigned phys_addr);
d105 2
a106 4
	  (*d10v_callback->printf_filtered)
	    (d10v_callback, "ERROR: Illegal instruction %x at PC %x\n", ins, PC);
	  State.exception = SIGILL;
	  return NULL;
a160 2
  if (h == NULL)
    return;
a195 2
  if (h == NULL)
    return;
a206 2
      if (h == NULL)
	return;
a227 2
  if (h1 == NULL)
    return;
a228 2
  if (h2 == NULL)
    return;
d309 2
a310 1
  for (i = 0; i < IMEM_SEGMENTS; i++)
d312 10
a321 2
      if (State.mem.insn[i])
	free (State.mem.insn[i]);
d323 10
a332 1
  for (i = 0; i < DMEM_SEGMENTS; i++)
d334 2
a335 2
      if (State.mem.data[i])
	free (State.mem.data[i]);
d337 1
a337 29
  for (i = 0; i < UMEM_SEGMENTS; i++)
    {
      if (State.mem.unif[i])
	free (State.mem.unif[i]);
    }
  /* Always allocate dmem segment 0.  This contains the IMAP and DMAP
     registers. */
  State.mem.data[0] = calloc (1, SEGMENT_SIZE);
}

/* For tracing - leave info on last access around. */
static char *last_segname = "invalid";
static char *last_from = "invalid";
static char *last_to = "invalid";

enum
  {
    IMAP0_OFFSET = 0xff00,
    DMAP0_OFFSET = 0xff08,
    DMAP2_SHADDOW = 0xff04,
    DMAP2_OFFSET = 0xff0c
  };

static void
set_dmap_register (int reg_nr, unsigned long value)
{
  uint8 *raw = map_memory (SIM_D10V_MEMORY_DATA
			   + DMAP0_OFFSET + 2 * reg_nr);
  WRITE_16 (raw, value);
d339 1
a339 1
  if ((d10v_debug & DEBUG_MEMORY))
d341 4
a344 5
      (*d10v_callback->printf_filtered)
	(d10v_callback, "mem: dmap%d=0x%04lx\n", reg_nr, value);
    }
#endif
}
d346 2
a347 19
static unsigned long
dmap_register (int reg_nr)
{
  uint8 *raw = map_memory (SIM_D10V_MEMORY_DATA
			   + DMAP0_OFFSET + 2 * reg_nr);
  return READ_16 (raw);
}

static void
set_imap_register (int reg_nr, unsigned long value)
{
  uint8 *raw = map_memory (SIM_D10V_MEMORY_DATA
			   + IMAP0_OFFSET + 2 * reg_nr);
  WRITE_16 (raw, value);
#ifdef DEBUG
  if ((d10v_debug & DEBUG_MEMORY))
    {
      (*d10v_callback->printf_filtered)
	(d10v_callback, "mem: imap%d=0x%04lx\n", reg_nr, value);
d352 6
a357 7
static unsigned long
imap_register (int reg_nr)
{
  uint8 *raw = map_memory (SIM_D10V_MEMORY_DATA
			   + IMAP0_OFFSET + 2 * reg_nr);
  return READ_16 (raw);
}
d359 5
a363 8
enum
  {
    HELD_SPI_IDX = 0,
    HELD_SPU_IDX = 1
  };

static unsigned long
spu_register (void)
d365 3
a367 5
  if (PSW_SM)
    return GPR (SP_IDX);
  else
    return HELD_SP (HELD_SPU_IDX);
}
d369 2
a370 38
static unsigned long
spi_register (void)
{
  if (!PSW_SM)
    return GPR (SP_IDX);
  else
    return HELD_SP (HELD_SPI_IDX);
}

static void
set_spi_register (unsigned long value)
{
  if (!PSW_SM)
    SET_GPR (SP_IDX, value);
  SET_HELD_SP (HELD_SPI_IDX, value);
}

static void
set_spu_register  (unsigned long value)
{
  if (PSW_SM)
    SET_GPR (SP_IDX, value);
  SET_HELD_SP (HELD_SPU_IDX, value);
}

/* Given a virtual address in the DMAP address space, translate it
   into a physical address. */

unsigned long
sim_d10v_translate_dmap_addr (unsigned long offset,
			      int nr_bytes,
			      unsigned long *phys,
			      unsigned long (*dmap_register) (int reg_nr))
{
  short map;
  int regno;
  last_from = "logical-data";
  if (offset >= DMAP_BLOCK_SIZE * SIM_D10V_NR_DMAP_REGS)
d372 5
a376 24
      /* Logical address out side of data segments, not supported */
      return 0;
    }
  regno = (offset / DMAP_BLOCK_SIZE);
  offset = (offset % DMAP_BLOCK_SIZE);
  if ((offset % DMAP_BLOCK_SIZE) + nr_bytes > DMAP_BLOCK_SIZE)
    {
      /* Don't cross a BLOCK boundary */
      nr_bytes = DMAP_BLOCK_SIZE - (offset % DMAP_BLOCK_SIZE);
    }
  map = dmap_register (regno);
  if (regno == 3)
    {
      /* Always maps to data memory */
      int iospi = (offset / 0x1000) % 4;
      int iosp = (map >> (4 * (3 - iospi))) % 0x10;
      last_to = "io-space";
      *phys = (SIM_D10V_MEMORY_DATA + (iosp * 0x10000) + 0xc000 + offset);
    }
  else
    {
      int sp = ((map & 0x3000) >> 12);
      int segno = (map & 0x3ff);
      switch (sp)
d378 1
a378 14
	case 0: /* 00: Unified memory */
	  *phys = SIM_D10V_MEMORY_UNIFIED + (segno * DMAP_BLOCK_SIZE) + offset;
	  last_to = "unified";
	  break;
	case 1: /* 01: Instruction Memory */
	  *phys = SIM_D10V_MEMORY_INSN + (segno * DMAP_BLOCK_SIZE) + offset;
	  last_to = "chip-insn";
	  break;
	case 2: /* 10: Internal data memory */
	  *phys = SIM_D10V_MEMORY_DATA + (segno << 16) + (regno * DMAP_BLOCK_SIZE) + offset;
	  last_to = "chip-data";
	  break;
	case 3: /* 11: Reserved */
	  return 0;
d381 1
a381 56
  return nr_bytes;
}

/* Given a virtual address in the IMAP address space, translate it
   into a physical address. */

unsigned long
sim_d10v_translate_imap_addr (unsigned long offset,
			      int nr_bytes,
			      unsigned long *phys,
			      unsigned long (*imap_register) (int reg_nr))
{
  short map;
  int regno;
  int sp;
  int segno;
  last_from = "logical-insn";
  if (offset >= (IMAP_BLOCK_SIZE * SIM_D10V_NR_IMAP_REGS))
    {
      /* Logical address outside of IMAP segments, not supported */
      return 0;
    }
  regno = (offset / IMAP_BLOCK_SIZE);
  offset = (offset % IMAP_BLOCK_SIZE);
  if (offset + nr_bytes > IMAP_BLOCK_SIZE)
    {
      /* Don't cross a BLOCK boundary */
      nr_bytes = IMAP_BLOCK_SIZE - offset;
    }
  map = imap_register (regno);
  sp = (map & 0x3000) >> 12;
  segno = (map & 0x007f);
  switch (sp)
    {
    case 0: /* 00: unified memory */
      *phys = SIM_D10V_MEMORY_UNIFIED + (segno << 17) + offset;
      last_to = "unified";
      break;
    case 1: /* 01: instruction memory */
      *phys = SIM_D10V_MEMORY_INSN + (IMAP_BLOCK_SIZE * regno) + offset;
      last_to = "chip-insn";
      break;
    case 2: /*10*/
      /* Reserved. */
      return 0;
    case 3: /* 11: for testing  - instruction memory */
      offset = (offset % 0x800);
      *phys = SIM_D10V_MEMORY_INSN + offset;
      if (offset + nr_bytes > 0x800)
	/* don't cross VM boundary */
	nr_bytes = 0x800 - offset;
      last_to = "test-insn";
      break;
    }
  return nr_bytes;
}
d383 1
a383 10
unsigned long
sim_d10v_translate_addr (unsigned long memaddr,
			 int nr_bytes,
			 unsigned long *targ_addr,
			 unsigned long (*dmap_register) (int reg_nr),
			 unsigned long (*imap_register) (int reg_nr))
{
  unsigned long phys;
  unsigned long seg;
  unsigned long off;
d385 14
a398 2
  last_from = "unknown";
  last_to = "unknown";
d400 1
a400 2
  seg = (memaddr >> 24);
  off = (memaddr & 0xffffffL);
d407 1
a407 1
      switch (seg)
d410 1
a410 1
	  seg = 0x10;
d413 1
a413 1
	  seg = 0x11;
d416 1
a416 1
	  seg = 0x02;
d419 1
a419 1
	  seg = 0x01;
d422 1
a422 1
	  seg = 0x00;
d427 1
a427 1
  switch (seg)
d429 15
a443 7
    case 0x00:			/* Physical unified memory */
      last_from = "phys-unified";
      last_to = "unified";
      phys = SIM_D10V_MEMORY_UNIFIED + off;
      if ((off % SEGMENT_SIZE) + nr_bytes > SEGMENT_SIZE)
	nr_bytes = SEGMENT_SIZE - (off % SEGMENT_SIZE);
      break;
d445 15
a459 7
    case 0x01:			/* Physical instruction memory */
      last_from = "phys-insn";
      last_to = "chip-insn";
      phys = SIM_D10V_MEMORY_INSN + off;
      if ((off % SEGMENT_SIZE) + nr_bytes > SEGMENT_SIZE)
	nr_bytes = SEGMENT_SIZE - (off % SEGMENT_SIZE);
      break;
d461 1
a461 42
    case 0x02:			/* Physical data memory segment */
      last_from = "phys-data";
      last_to = "chip-data";
      phys = SIM_D10V_MEMORY_DATA + off;
      if ((off % SEGMENT_SIZE) + nr_bytes > SEGMENT_SIZE)
	nr_bytes = SEGMENT_SIZE - (off % SEGMENT_SIZE);
      break;

    case 0x10:			/* in logical data address segment */
      nr_bytes = sim_d10v_translate_dmap_addr (off, nr_bytes, &phys,
					       dmap_register);
      break;

    case 0x11:			/* in logical instruction address segment */
      nr_bytes = sim_d10v_translate_imap_addr (off, nr_bytes, &phys,
					       imap_register);
      break;

    default:
      return 0;
    }

  *targ_addr = phys;
  return nr_bytes;
}

/* Return a pointer into the raw buffer designated by phys_addr.  It
   is assumed that the client has already ensured that the access
   isn't going to cross a segment boundary. */

uint8 *
map_memory (unsigned phys_addr)
{
  uint8 **memory;
  uint8 *raw;
  unsigned offset;
  int segment = ((phys_addr >> 24) & 0xff);
  
  switch (segment)
    {
      
    case 0x00: /* Unified memory */
d463 8
a470 2
	memory = &State.mem.unif[(phys_addr / SEGMENT_SIZE) % UMEM_SEGMENTS];
	last_segname = "umem";
d473 1
a473 1
    
d476 8
a483 2
	memory = &State.mem.insn[(phys_addr / SEGMENT_SIZE) % IMEM_SEGMENTS];
	last_segname = "imem";
d486 2
a487 2
    
    case 0x02: /* On-chip data memory */
d489 17
a505 1
	if ((phys_addr & 0xff00) == 0xff00)
d507 2
a508 2
	    phys_addr = (phys_addr & 0xffff);
	    if (phys_addr == DMAP2_SHADDOW)
d510 2
a511 2
		phys_addr = DMAP2_OFFSET;
		last_segname = "dmap";
d513 7
a519 2
	    else
	      last_segname = "reg";
d521 1
a521 3
	else
	  last_segname = "dmem";
	memory = &State.mem.data[(phys_addr / SEGMENT_SIZE) % DMEM_SEGMENTS];
d524 1
a524 1
    
d526 20
a545 3
      /* OOPS! */
      last_segname = "scrap";
      return State.mem.fault;
d547 2
a548 2
  
  if (*memory == NULL)
d550 1
a550 6
      *memory = calloc (1, SEGMENT_SIZE);
      if (*memory == NULL)
	{
	  (*d10v_callback->printf_filtered) (d10v_callback, "Malloc failed.\n");
	  return State.mem.fault;
	}
d552 1
a552 22
  
  offset = (phys_addr % SEGMENT_SIZE);
  raw = *memory + offset;
  return raw;
}
  
/* Transfer data to/from simulated memory.  Since a bug in either the
   simulated program or in gdb or the simulator itself may cause a
   bogus address to be passed in, we need to do some sanity checking
   on addresses to make sure they are within bounds.  When an address
   fails the bounds check, treat it as a zero length read/write rather
   than aborting the entire run. */

static int
xfer_mem (SIM_ADDR virt,
	  unsigned char *buffer,
	  int size,
	  int write_p)
{
  int xfered = 0;

  while (xfered < size)
d554 1
a554 37
      uint8 *memory;
      unsigned long phys;
      int phys_size;
      phys_size = sim_d10v_translate_addr (virt, size,
					   &phys,
					   dmap_register,
					   imap_register);
      if (phys_size == 0)
	return xfered;

      memory = map_memory (phys);

#ifdef DEBUG
      if ((d10v_debug & DEBUG_INSTRUCTION) != 0)
	{
	  (*d10v_callback->printf_filtered)
	    (d10v_callback,
	     "sim_%s %d bytes: 0x%08lx (%s) -> 0x%08lx (%s) -> 0x%08lx (%s)\n",
	     (write_p ? "write" : "read"),
	     phys_size, virt, last_from,
	     phys, last_to,
	     (long) memory, last_segname);
	}
#endif

      if (write_p)
	{
	  memcpy (memory, buffer, phys_size);
	}
      else
	{
	  memcpy (buffer, memory, phys_size);
	}

      virt += phys_size;
      buffer += phys_size;
      xfered += phys_size;
a600 3
  /* NOTE: This argument parsing is only effective when this function
     is called by GDB. Standalone argument parsing is handled by
     sim/common/run.c. */
a607 2
      else if (strncmp (*p, "-t", 2) == 0)
	d10v_debug = atoi (*p + 2);
d640 2
a641 2
  if (!State.mem.data[0])
    sim_size (1);
d676 1
d678 2
a679 1
dmem_addr (uint16 offset)
d681 1
a681 3
  unsigned long phys;
  uint8 *mem;
  int phys_size;
d683 1
a683 3
  /* Note: DMEM address range is 0..0x10000. Calling code can compute
     things like ``0xfffe + 0x0e60 == 0x10e5d''.  Since offset's type
     is uint16 this is modulo'ed onto 0x0e5d. */
d685 1
a685 3
  phys_size = sim_d10v_translate_dmap_addr (offset, 1, &phys,
					    dmap_register);
  if (phys_size == 0)
d687 8
a694 1
      mem = State.mem.fault;
d696 16
a711 2
  else
    mem = map_memory (phys);
d713 13
a725 8
  if ((d10v_debug & DEBUG_MEMORY))
    {
      (*d10v_callback->printf_filtered)
	(d10v_callback,
	 "mem: 0x%08x (%s) -> 0x%08lx %d (%s) -> 0x%08lx (%s)\n",
	 offset, last_from,
	 phys, phys_size, last_to,
	 (long) mem, last_segname);
d727 1
a727 2
#endif
  return mem;
d730 1
d732 1
a732 1
imem_addr (uint32 offset)
d734 17
a750 20
  unsigned long phys;
  uint8 *mem;
  int phys_size = sim_d10v_translate_imap_addr (offset, 1, &phys, imap_register);
  if (phys_size == 0)
    {
      return State.mem.fault;
    }
  mem = map_memory (phys); 
#ifdef DEBUG
  if ((d10v_debug & DEBUG_MEMORY))
    {
      (*d10v_callback->printf_filtered)
	(d10v_callback,
	 "mem: 0x%08x (%s) -> 0x%08lx %d (%s) -> 0x%08lx (%s)\n",
	 offset, last_from,
	 phys, phys_size, last_to,
	 (long) mem, last_segname);
    }
#endif
  return mem;
d753 1
d782 1
a782 1
      if (iaddr == State.mem.fault)
d993 1
a993 1
  memset (&State.regs, 0, (int)&State.mem - (int)&State.regs);
d1025 2
a1026 3
  /* cpu resets imap0 to 0 and imap1 to 0x7f, but D10V-EVA board
     initializes imap0 and imap1 to 0x1000 as part of its ROM
     initialization. */
d1029 3
a1031 7
      /* External memory startup.  This is the HARD reset state. */
      set_imap_register (0, 0x0000);
      set_imap_register (1, 0x007f);
      set_dmap_register (0, 0x2000);
      set_dmap_register (1, 0x2000);
      set_dmap_register (2, 0x0000); /* Old DMAP */
      set_dmap_register (3, 0x0000);
d1035 3
a1037 7
      /* Internal memory startup. This is the ROM intialized state. */
      set_imap_register (0, 0x1000);
      set_imap_register (1, 0x1000);
      set_dmap_register (0, 0x2000);
      set_dmap_register (1, 0x2000);
      set_dmap_register (2, 0x0000); /* Old DMAP, Value is not 0x2000 */
      set_dmap_register (3, 0x0000);
d1091 10
a1100 47
  int size;
  if (rn < 0)
    size = 0;
  else if (rn >= SIM_D10V_R0_REGNUM
	   && rn < SIM_D10V_R0_REGNUM + SIM_D10V_NR_R_REGS)
    {
      WRITE_16 (memory, GPR (rn - SIM_D10V_R0_REGNUM));
      size = 2;
    }
  else if (rn >= SIM_D10V_CR0_REGNUM
	   && rn < SIM_D10V_CR0_REGNUM + SIM_D10V_NR_CR_REGS)
    {
      WRITE_16 (memory, CREG (rn - SIM_D10V_CR0_REGNUM));
      size = 2;
    }
  else if (rn >= SIM_D10V_A0_REGNUM
	   && rn < SIM_D10V_A0_REGNUM + SIM_D10V_NR_A_REGS)
    {
      WRITE_64 (memory, ACC (rn - SIM_D10V_A0_REGNUM));
      size = 8;
    }
  else if (rn == SIM_D10V_SPI_REGNUM)
    {
      /* PSW_SM indicates that the current SP is the USER
         stack-pointer. */
      WRITE_16 (memory, spi_register ());
      size = 2;
    }
  else if (rn == SIM_D10V_SPU_REGNUM)
    {
      /* PSW_SM indicates that the current SP is the USER
         stack-pointer. */
      WRITE_16 (memory, spu_register ());
      size = 2;
    }
  else if (rn >= SIM_D10V_IMAP0_REGNUM
	   && rn < SIM_D10V_IMAP0_REGNUM + SIM_D10V_NR_IMAP_REGS)
    {
      WRITE_16 (memory, imap_register (rn - SIM_D10V_IMAP0_REGNUM));
      size = 2;
    }
  else if (rn >= SIM_D10V_DMAP0_REGNUM
	   && rn < SIM_D10V_DMAP0_REGNUM + SIM_D10V_NR_DMAP_REGS)
    {
      WRITE_16 (memory, dmap_register (rn - SIM_D10V_DMAP0_REGNUM));
      size = 2;
    }
d1102 2
a1103 2
    size = 0;
  return size;
d1113 10
a1122 45
  int size;
  if (rn < 0)
    size = 0;
  else if (rn >= SIM_D10V_R0_REGNUM
	   && rn < SIM_D10V_R0_REGNUM + SIM_D10V_NR_R_REGS)
    {
      SET_GPR (rn - SIM_D10V_R0_REGNUM, READ_16 (memory));
      size = 2;
    }
  else if (rn >= SIM_D10V_CR0_REGNUM
	   && rn < SIM_D10V_CR0_REGNUM + SIM_D10V_NR_CR_REGS)
    {
      SET_CREG (rn - SIM_D10V_CR0_REGNUM, READ_16 (memory));
      size = 2;
    }
  else if (rn >= SIM_D10V_A0_REGNUM
	   && rn < SIM_D10V_A0_REGNUM + SIM_D10V_NR_A_REGS)
    {
      SET_ACC (rn - SIM_D10V_A0_REGNUM, READ_64 (memory) & MASK40);
      size = 8;
    }
  else if (rn == SIM_D10V_SPI_REGNUM)
    {
      /* PSW_SM indicates that the current SP is the USER
         stack-pointer. */
      set_spi_register (READ_16 (memory));
      size = 2;
    }
  else if (rn == SIM_D10V_SPU_REGNUM)
    {
      set_spu_register (READ_16 (memory));
      size = 2;
    }
  else if (rn >= SIM_D10V_IMAP0_REGNUM
	   && rn < SIM_D10V_IMAP0_REGNUM + SIM_D10V_NR_IMAP_REGS)
    {
      set_imap_register (rn - SIM_D10V_IMAP0_REGNUM, READ_16(memory));
      size = 2;
    }
  else if (rn >= SIM_D10V_DMAP0_REGNUM
	   && rn < SIM_D10V_DMAP0_REGNUM + SIM_D10V_NR_DMAP_REGS)
    {
      set_dmap_register (rn - SIM_D10V_DMAP0_REGNUM, READ_16(memory));
      size = 2;
    }
d1124 1
a1124 1
    size = 0;
d1126 1
a1126 1
  return size;
@


1.1.1.5
log
@import gdb-2000-01-05 snapshot
@
text
@a104 1
	  State.pc_changed = 1; /* Don't increment the PC. */
@


