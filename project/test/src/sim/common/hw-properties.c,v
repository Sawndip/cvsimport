head	1.14;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.14
	gdb_7_6-2013-04-26-release:1.14
	gdb_7_6-branch:1.14.0.2
	gdb_7_6-2013-03-12-branchpoint:1.14
	gdb_7_5_1-2012-11-29-release:1.13
	gdb_7_5-2012-08-17-release:1.13
	gdb_7_5-branch:1.13.0.2
	gdb_7_5-2012-07-18-branchpoint:1.13
	gdb_7_4_1-2012-04-26-release:1.12.2.1
	gdb_7_4-2012-01-24-release:1.12.2.1
	gdb_7_4-branch:1.12.0.2
	gdb_7_4-2011-12-13-branchpoint:1.12
	gdb_7_3_1-2011-09-04-release:1.10.2.1
	gdb_7_3-2011-07-26-release:1.10.2.1
	gdb_7_3-branch:1.10.0.2
	gdb_7_3-2011-04-01-branchpoint:1.10
	gdb_7_2-2010-09-02-release:1.8
	gdb_7_2-branch:1.8.0.2
	gdb_7_2-2010-07-07-branchpoint:1.8
	gdb_7_1-2010-03-18-release:1.7
	gdb_7_1-branch:1.7.0.2
	gdb_7_1-2010-02-18-branchpoint:1.7
	gdb_7_0_1-2009-12-22-release:1.6
	gdb_7_0-2009-10-06-release:1.6
	gdb_7_0-branch:1.6.0.4
	gdb_7_0-2009-09-16-branchpoint:1.6
	arc-sim-20090309:1.5
	msnyder-checkpoint-072509-branch:1.6.0.2
	msnyder-checkpoint-072509-branchpoint:1.6
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	reverse-20081226-branch:1.5.0.12
	reverse-20081226-branchpoint:1.5
	multiprocess-20081120-branch:1.5.0.10
	multiprocess-20081120-branchpoint:1.5
	reverse-20080930-branch:1.5.0.8
	reverse-20080930-branchpoint:1.5
	reverse-20080717-branch:1.5.0.6
	reverse-20080717-branchpoint:1.5
	msnyder-reverse-20080609-branch:1.5.0.4
	msnyder-reverse-20080609-branchpoint:1.5
	drow-reverse-20070409-branch:1.3.0.2
	drow-reverse-20070409-branchpoint:1.3
	gdb_6_8-2008-03-27-release:1.5
	gdb_6_8-branch:1.5.0.2
	gdb_6_8-2008-02-26-branchpoint:1.5
	gdb_6_7_1-2007-10-29-release:1.4
	gdb_6_7-2007-10-10-release:1.4
	gdb_6_7-branch:1.4.0.2
	gdb_6_7-2007-09-07-branchpoint:1.4
	insight_6_6-20070208-release:1.2
	gdb_6_6-2006-12-18-release:1.2
	gdb_6_6-branch:1.2.0.88
	gdb_6_6-2006-11-15-branchpoint:1.2
	insight_6_5-20061003-release:1.2
	gdb-csl-symbian-6_4_50_20060226-12:1.2
	gdb-csl-sourcerygxx-3_4_4-25:1.2
	nickrob-async-20060828-mergepoint:1.2
	gdb-csl-symbian-6_4_50_20060226-11:1.2
	gdb-csl-sourcerygxx-4_1-17:1.2
	gdb-csl-20060226-branch-local-2:1.2
	gdb-csl-sourcerygxx-4_1-14:1.2
	gdb-csl-sourcerygxx-4_1-13:1.2
	gdb-csl-sourcerygxx-4_1-12:1.2
	gdb-csl-sourcerygxx-3_4_4-21:1.2
	gdb_6_5-20060621-release:1.2
	gdb-csl-sourcerygxx-4_1-9:1.2
	gdb-csl-sourcerygxx-4_1-8:1.2
	gdb-csl-sourcerygxx-4_1-7:1.2
	gdb-csl-arm-2006q1-6:1.2
	gdb-csl-sourcerygxx-4_1-6:1.2
	gdb-csl-symbian-6_4_50_20060226-10:1.2
	gdb-csl-symbian-6_4_50_20060226-9:1.2
	gdb-csl-symbian-6_4_50_20060226-8:1.2
	gdb-csl-coldfire-4_1-11:1.2
	gdb-csl-sourcerygxx-3_4_4-19:1.2
	gdb-csl-coldfire-4_1-10:1.2
	gdb_6_5-branch:1.2.0.86
	gdb_6_5-2006-05-14-branchpoint:1.2
	gdb-csl-sourcerygxx-4_1-5:1.2
	nickrob-async-20060513-branch:1.2.0.84
	nickrob-async-20060513-branchpoint:1.2
	gdb-csl-sourcerygxx-4_1-4:1.2
	msnyder-reverse-20060502-branch:1.2.0.82
	msnyder-reverse-20060502-branchpoint:1.2
	gdb-csl-morpho-4_1-4:1.2
	gdb-csl-sourcerygxx-3_4_4-17:1.2
	readline_5_1-import-branch:1.2.0.80
	readline_5_1-import-branchpoint:1.2
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.2
	gdb-csl-symbian-20060226-branch:1.2.0.78
	gdb-csl-symbian-20060226-branchpoint:1.2
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.2
	msnyder-reverse-20060331-branch:1.2.0.76
	msnyder-reverse-20060331-branchpoint:1.2
	gdb-csl-available-20060303-branch:1.2.0.74
	gdb-csl-available-20060303-branchpoint:1.2
	gdb-csl-20060226-branch:1.2.0.72
	gdb-csl-20060226-branchpoint:1.2
	gdb_6_4-20051202-release:1.2
	msnyder-fork-checkpoint-branch:1.2.0.70
	msnyder-fork-checkpoint-branchpoint:1.2
	gdb-csl-gxxpro-6_3-branch:1.2.0.68
	gdb-csl-gxxpro-6_3-branchpoint:1.2
	gdb_6_4-branch:1.2.0.66
	gdb_6_4-2005-11-01-branchpoint:1.2
	gdb-csl-arm-20051020-branch:1.2.0.64
	gdb-csl-arm-20051020-branchpoint:1.2
	msnyder-tracepoint-checkpoint-branch:1.2.0.62
	msnyder-tracepoint-checkpoint-branchpoint:1.2
	gdb-csl-arm-20050325-2005-q1b:1.2
	gdb-csl-arm-20050325-2005-q1a:1.2
	csl-arm-20050325-branch:1.2.0.60
	csl-arm-20050325-branchpoint:1.2
	gdb_6_3-20041109-release:1.2
	gdb_6_3-branch:1.2.0.56
	gdb_6_3-20041019-branchpoint:1.2
	drow_intercu-merge-20040921:1.2
	drow_intercu-merge-20040915:1.2
	jimb-gdb_6_2-e500-branch:1.2.0.58
	jimb-gdb_6_2-e500-branchpoint:1.2
	gdb_6_2-20040730-release:1.2
	gdb_6_2-branch:1.2.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.2
	gdb_6_1_1-20040616-release:1.2
	gdb_6_1-2004-04-05-release:1.2
	drow_intercu-merge-20040402:1.2
	drow_intercu-merge-20040327:1.2
	ezannoni_pie-20040323-branch:1.2.0.52
	ezannoni_pie-20040323-branchpoint:1.2
	cagney_tramp-20040321-mergepoint:1.2
	cagney_tramp-20040309-branch:1.2.0.50
	cagney_tramp-20040309-branchpoint:1.2
	gdb_6_1-branch:1.2.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.2
	drow_intercu-20040221-branch:1.2.0.46
	drow_intercu-20040221-branchpoint:1.2
	cagney_bfdfile-20040213-branch:1.2.0.44
	cagney_bfdfile-20040213-branchpoint:1.2
	drow-cplus-merge-20040208:1.2
	carlton_dictionary-20040126-merge:1.2
	cagney_bigcore-20040122-branch:1.2.0.42
	cagney_bigcore-20040122-branchpoint:1.2
	drow-cplus-merge-20040113:1.2
	drow-cplus-merge-20031224:1.2
	drow-cplus-merge-20031220:1.2
	carlton_dictionary-20031215-merge:1.2
	drow-cplus-merge-20031214:1.2
	carlton-dictionary-20031111-merge:1.2
	gdb_6_0-2003-10-04-release:1.2
	kettenis_sparc-20030918-branch:1.2.0.40
	kettenis_sparc-20030918-branchpoint:1.2
	carlton_dictionary-20030917-merge:1.2
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.38
	cagney_x86i386-20030821-branch:1.2.0.36
	cagney_x86i386-20030821-branchpoint:1.2
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.2.0.34
	gdb_6_0-2003-06-23-branchpoint:1.2
	jimb-ppc64-linux-20030613-branch:1.2.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.2
	cagney_convert-20030606-branch:1.2.0.30
	cagney_convert-20030606-branchpoint:1.2
	cagney_writestrings-20030508-branch:1.2.0.28
	cagney_writestrings-20030508-branchpoint:1.2
	jimb-ppc64-linux-20030528-branch:1.2.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.2
	carlton_dictionary-20030523-merge:1.2
	cagney_fileio-20030521-branch:1.2.0.24
	cagney_fileio-20030521-branchpoint:1.2
	kettenis_i386newframe-20030517-mergepoint:1.2
	jimb-ppc64-linux-20030509-branch:1.2.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.2
	kettenis_i386newframe-20030504-mergepoint:1.2
	carlton_dictionary-20030430-merge:1.2
	kettenis_i386newframe-20030419-branch:1.2.0.20
	kettenis_i386newframe-20030419-branchpoint:1.2
	carlton_dictionary-20030416-merge:1.2
	cagney_frameaddr-20030409-mergepoint:1.2
	kettenis_i386newframe-20030406-branch:1.2.0.18
	kettenis_i386newframe-20030406-branchpoint:1.2
	cagney_frameaddr-20030403-branchpoint:1.2
	cagney_frameaddr-20030403-branch:1.2.0.16
	cagney_framebase-20030330-mergepoint:1.2
	cagney_framebase-20030326-branch:1.2.0.14
	cagney_framebase-20030326-branchpoint:1.2
	cagney_lazyid-20030317-branch:1.2.0.12
	cagney_lazyid-20030317-branchpoint:1.2
	kettenis-i386newframe-20030316-mergepoint:1.2
	offbyone-20030313-branch:1.2.0.10
	offbyone-20030313-branchpoint:1.2
	kettenis-i386newframe-20030308-branch:1.2.0.8
	kettenis-i386newframe-20030308-branchpoint:1.2
	carlton_dictionary-20030305-merge:1.2
	cagney_offbyone-20030303-branch:1.2.0.6
	cagney_offbyone-20030303-branchpoint:1.2
	carlton_dictionary-20030207-merge:1.2
	interps-20030202-branch:1.2.0.4
	interps-20030202-branchpoint:1.2
	cagney-unwind-20030108-branch:1.2.0.2
	cagney-unwind-20030108-branchpoint:1.2
	carlton_dictionary-20021223-merge:1.2
	gdb_5_3-2002-12-12-release:1.1.1.2.24.1
	carlton_dictionary-20021115-merge:1.1.1.2
	kseitz_interps-20021105-merge:1.1.1.2
	kseitz_interps-20021103-merge:1.1.1.2
	drow-cplus-merge-20021020:1.1.1.2
	drow-cplus-merge-20021025:1.1.1.2
	carlton_dictionary-20021025-merge:1.1.1.2
	carlton_dictionary-20021011-merge:1.1.1.2
	drow-cplus-branch:1.1.1.2.0.28
	drow-cplus-branchpoint:1.1.1.2
	kseitz_interps-20020930-merge:1.1.1.2
	carlton_dictionary-20020927-merge:1.1.1.2
	carlton_dictionary-branch:1.1.1.2.0.26
	carlton_dictionary-20020920-branchpoint:1.1.1.2
	gdb_5_3-branch:1.1.1.2.0.24
	gdb_5_3-2002-09-04-branchpoint:1.1.1.2
	kseitz_interps-20020829-merge:1.1.1.2
	cagney_sysregs-20020825-branch:1.1.1.2.0.22
	cagney_sysregs-20020825-branchpoint:1.1.1.2
	readline_4_3-import-branch:1.1.1.2.0.20
	readline_4_3-import-branchpoint:1.1.1.2
	gdb_5_2_1-2002-07-23-release:1.1.1.2
	kseitz_interps-20020528-branch:1.1.1.2.0.18
	kseitz_interps-20020528-branchpoint:1.1.1.2
	cagney_regbuf-20020515-branch:1.1.1.2.0.16
	cagney_regbuf-20020515-branchpoint:1.1.1.2
	jimb-macro-020506-branch:1.1.1.2.0.14
	jimb-macro-020506-branchpoint:1.1.1.2
	gdb_5_2-2002-04-29-release:1.1.1.2
	gdb_5_2-branch:1.1.1.2.0.12
	gdb_5_2-2002-03-03-branchpoint:1.1.1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.2
	gdb_5_1_0_1-2002-01-03-release:1.1.1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.2.0.10
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.2
	gdb_5_1-2001-11-21-release:1.1.1.2
	gdb_s390-2001-09-26-branch:1.1.1.2.0.8
	gdb_s390-2001-09-26-branchpoint:1.1.1.2
	gdb_5_1-2001-07-29-branch:1.1.1.2.0.6
	gdb_5_1-2001-07-29-branchpoint:1.1.1.2
	insight-precleanup-2001-01-01:1.1.1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.14
date	2013.01.01.06.41.33;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2012.01.04.08.28.05;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2011.05.11.20.02.42;	author vapier;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2011.04.02.05.30.16;	author vapier;	state Exp;
branches;
next	1.10;

1.10
date	2011.03.15.03.16.17;	author vapier;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2011.01.01.15.33.56;	author brobecke;	state Exp;
branches;
next	1.8;

1.8
date	2010.03.16.20.58.53;	author vapier;	state Exp;
branches;
next	1.7;

1.7
date	2010.01.01.10.03.27;	author brobecke;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.14.10.53.06;	author brobecke;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.01.22.53.23;	author drow;	state Exp;
branches;
next	1.4;

1.4
date	2007.08.24.14.28.35;	author brobecke;	state Exp;
branches;
next	1.3;

1.3
date	2007.01.09.17.59.16;	author drow;	state Exp;
branches;
next	1.2;

1.2
date	2002.11.23.01.12.05;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.56;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.12.2.1
date	2012.01.06.04.54.39;	author brobecke;	state Exp;
branches;
next	;

1.10.2.1
date	2011.05.17.21.27.55;	author brobecke;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.56;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.09.22.03.28.06;	author jsm;	state Exp;
branches
	1.1.1.2.24.1
	1.1.1.2.26.1
	1.1.1.2.28.1;
next	;

1.1.1.2.24.1
date	2002.11.23.01.12.34;	author cagney;	state Exp;
branches;
next	;

1.1.1.2.26.1
date	2002.12.23.19.39.51;	author carlton;	state Exp;
branches;
next	;

1.1.1.2.28.1
date	2003.12.14.20.28.18;	author drow;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* The common simulator framework for GDB, the GNU Debugger.

   Copyright 2002-2013 Free Software Foundation, Inc.

   Contributed by Andrew Cagney and Red Hat.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "hw-main.h"
#include "hw-base.h"

#include "sim-io.h"
#include "sim-assert.h"

#ifdef HAVE_STRING_H
#include <string.h>
#else
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif
#endif

/* property entries */

struct hw_property_data
{
  struct hw_property_data *next;
  struct hw_property *property;
  const void *init_array;
  unsigned sizeof_init_array;
};

void
create_hw_property_data (struct hw *me)
{
}

void
delete_hw_property_data (struct hw *me)
{
}


/* Device Properties: */

static struct hw_property_data *
find_property_data (struct hw *me,
		    const char *property)
{
  struct hw_property_data *entry;
  ASSERT (property != NULL);
  entry = me->properties_of_hw;
  while (entry != NULL)
    {
      if (strcmp (entry->property->name, property) == 0)
	return entry;
      entry = entry->next;
    }
  return NULL;
}


static void
hw_add_property (struct hw *me,
		 const char *property,
		 hw_property_type type,
		 const void *init_array,
		 unsigned sizeof_init_array,
		 const void *array,
		 unsigned sizeof_array,
		 const struct hw_property *original,
		 object_disposition disposition)
{
  struct hw_property_data *new_entry = NULL;
  struct hw_property *new_value = NULL;

  /* find the list end */
  struct hw_property_data **insertion_point = &me->properties_of_hw;
  while (*insertion_point != NULL)
    {
      if (strcmp ((*insertion_point)->property->name, property) == 0)
	return;
      insertion_point = &(*insertion_point)->next;
    }

  /* create a new value */
  new_value = HW_ZALLOC (me, struct hw_property);
  new_value->name = (char *) strdup (property);
  new_value->type = type;
  if (sizeof_array > 0)
    {
      void *new_array = hw_zalloc (me, sizeof_array);
      memcpy (new_array, array, sizeof_array);
      new_value->array = new_array;
      new_value->sizeof_array = sizeof_array;
    }
  new_value->owner = me;
  new_value->original = original;
  new_value->disposition = disposition;

  /* insert the value into the list */
  new_entry = HW_ZALLOC (me, struct hw_property_data);
  *insertion_point = new_entry;
  if (sizeof_init_array > 0)
    {
      void *new_init_array = hw_zalloc (me, sizeof_init_array);
      memcpy (new_init_array, init_array, sizeof_init_array);
      new_entry->init_array = new_init_array;
      new_entry->sizeof_init_array = sizeof_init_array;
    }
  new_entry->property = new_value;
}


static void
hw_set_property (struct hw *me,
		 const char *property,
		 hw_property_type type,
		 const void *array,
		 int sizeof_array)
{
  /* find the property */
  struct hw_property_data *entry = find_property_data (me, property);
  if (entry != NULL)
    {
      /* existing property - update it */
      void *new_array = 0;
      struct hw_property *value = entry->property;
      /* check the type matches */
      if (value->type != type)
	hw_abort (me, "conflict between type of new and old value for property %s", property);
      /* replace its value */
      if (value->array != NULL)
	hw_free (me, (void*)value->array);
      new_array = (sizeof_array > 0
		   ? hw_zalloc (me, sizeof_array)
		   : (void*)0);
      value->array = new_array;
      value->sizeof_array = sizeof_array;
      if (sizeof_array > 0)
	memcpy (new_array, array, sizeof_array);
      return;
    }
  else
    {
      /* new property - create it */
      hw_add_property (me, property, type,
		       NULL, 0, array, sizeof_array,
		       NULL, temporary_object);
    }
}


#if 0
static void
clean_hw_properties (struct hw *me)
{
  struct hw_property_data **delete_point = &me->properties_of_hw;
  while (*delete_point != NULL)
    {
      struct hw_property_data *current = *delete_point;
      switch (current->property->disposition)
	{
	case permenant_object:
	  /* zap the current value, will be initialized later */
	  ASSERT (current->init_array != NULL);
	  if (current->property->array != NULL)
	    {
	      hw_free (me, (void*)current->property->array);
	      current->property->array = NULL;
	    }
	  delete_point = &(*delete_point)->next;
	  break;
	case temporary_object:
	  /* zap the actual property, was created during simulation run */
	  ASSERT (current->init_array == NULL);
	  *delete_point = current->next;
	  if (current->property->array != NULL)
	    hw_free (me, (void*)current->property->array);
	  hw_free (me, current->property);
	  hw_free (me, current);
	  break;
	}
    }
}
#endif

#if 0
void
hw_init_static_properties (SIM_DESC sd,
			   struct hw *me,
			   void *data)
{
  struct hw_property_data *property;
  for (property = me->properties_of_hw;
       property != NULL;
       property = property->next)
    {
      ASSERT (property->init_array != NULL);
      ASSERT (property->property->array == NULL);
      ASSERT (property->property->disposition == permenant_object);
      switch (property->property->type)
	{
	case array_property:
	case boolean_property:
	case range_array_property:
	case reg_array_property:
	case string_property:
	case string_array_property:
	case integer_property:
	  /* delete the property, and replace it with the original */
	  hw_set_property (me, property->property->name,
			   property->property->type,
			   property->init_array,
			   property->sizeof_init_array);
	  break;
#if 0
	case ihandle_property:
	  break;
#endif
	}
    }
}
#endif


#if 0
void
hw_init_runtime_properties (SIM_DESC sd,
			    struct hw *me,
			    void *data)
{
  struct hw_property_data *property;
  for (property = me->properties_of_hw;
       property != NULL;
       property = property->next)
    {
      switch (property->property->disposition)
	{
	case permenant_object:
	  switch (property->property->type)
	    {
#if 0
	    case ihandle_property:
	      {
		struct hw_instance *ihandle;
		ihandle_runtime_property_spec spec;
		ASSERT (property->init_array != NULL);
		ASSERT (property->property->array == NULL);
		hw_find_ihandle_runtime_property (me, property->property->name, &spec);
		ihandle = tree_instance (me, spec.full_path);
		hw_set_ihandle_property (me, property->property->name, ihandle);
		break;
	      }
#endif
	    case array_property:
	    case boolean_property:
	    case range_array_property:
	    case integer_property:
	    case reg_array_property:
	    case string_property:
	    case string_array_property:
	      ASSERT (property->init_array != NULL);
	      ASSERT (property->property->array != NULL);
	      break;
	    }
	  break;
	case temporary_object:
	  ASSERT (property->init_array == NULL);
	  ASSERT (property->property->array != NULL);
	  break;
	}
    }
}
#endif



const struct hw_property *
hw_next_property (const struct hw_property *property)
{
  /* find the property in the list */
  struct hw *owner = property->owner;
  struct hw_property_data *entry = owner->properties_of_hw;
  while (entry != NULL && entry->property != property)
    entry = entry->next;
  /* now return the following property */
  ASSERT (entry != NULL); /* must be a member! */
  if (entry->next != NULL)
    return entry->next->property;
  else
    return NULL;
}


const struct hw_property *
hw_find_property (struct hw *me,
		  const char *property)
{
  if (me == NULL)
    {
      return NULL;
    }
  else if (property == NULL || strcmp (property, "") == 0)
    {
      if (me->properties_of_hw == NULL)
	return NULL;
      else
	return me->properties_of_hw->property;
    }
  else
    {
      struct hw_property_data *entry = find_property_data (me, property);
      if (entry != NULL)
	return entry->property;
    }
  return NULL;
}


void
hw_add_array_property (struct hw *me,
		       const char *property,
		       const void *array,
		       int sizeof_array)
{
  hw_add_property (me, property, array_property,
		   array, sizeof_array, array, sizeof_array,
		   NULL, permenant_object);
}

void
hw_set_array_property (struct hw *me,
		       const char *property,
		       const void *array,
		       int sizeof_array)
{
  hw_set_property (me, property, array_property, array, sizeof_array);
}

const struct hw_property *
hw_find_array_property (struct hw *me,
			const char *property)
{
  const struct hw_property *node;
  node = hw_find_property (me, property);
  if (node == NULL)
    hw_abort (me, "property \"%s\" not found", property);
  if (node->type != array_property)
    hw_abort (me, "property \"%s\" of wrong type (array)", property);
  return node;
}



void
hw_add_boolean_property (struct hw *me,
			 const char *property,
			 int boolean)
{
  signed32 new_boolean = (boolean ? -1 : 0);
  hw_add_property (me, property, boolean_property,
		   &new_boolean, sizeof (new_boolean),
		   &new_boolean, sizeof (new_boolean),
		   NULL, permenant_object);
}

int
hw_find_boolean_property (struct hw *me,
			  const char *property)
{
  const struct hw_property *node;
  unsigned_cell boolean;
  node = hw_find_property (me, property);
  if (node == NULL)
    hw_abort (me, "property \"%s\" not found", property);
  if (node->type != boolean_property)
    hw_abort (me, "property \"%s\" of wrong type (boolean)", property);
  ASSERT (sizeof (boolean) == node->sizeof_array);
  memcpy (&boolean, node->array, sizeof (boolean));
  return boolean;
}



#if 0
void
hw_add_ihandle_runtime_property (struct hw *me,
				 const char *property,
				 const ihandle_runtime_property_spec *ihandle)
{
  /* enter the full path as the init array */
  hw_add_property (me, property, ihandle_property,
		   ihandle->full_path, strlen (ihandle->full_path) + 1,
		   NULL, 0,
		   NULL, permenant_object);
}
#endif

#if 0
void
hw_find_ihandle_runtime_property (struct hw *me,
				  const char *property,
				  ihandle_runtime_property_spec *ihandle)
{
  struct hw_property_data *entry = find_property_data (me, property);
  HW_TRACE ((me, "hw_find_ihandle_runtime_property(property=%s)\n", property));
  if (entry == NULL)
    hw_abort (me, "property \"%s\" not found", property);
  if (entry->property->type != ihandle_property
      || entry->property->disposition != permenant_object)
    hw_abort (me, "property \"%s\" of wrong type", property);
  ASSERT (entry->init_array != NULL);
  /* the full path */
  ihandle->full_path = entry->init_array;
}
#endif



#if 0
void
hw_set_ihandle_property (struct hw *me,
			 const char *property,
			 hw_instance *ihandle)
{
  unsigned_cell cells;
  cells = H2BE_cell (hw_instance_to_external (ihandle));
  hw_set_property (me, property, ihandle_property,
		   &cells, sizeof (cells));

}
#endif

#if 0
hw_instance *
hw_find_ihandle_property (struct hw *me,
			  const char *property)
{
  const hw_property_data *node;
  unsigned_cell ihandle;
  hw_instance *instance;

  node = hw_find_property (me, property);
  if (node == NULL)
    hw_abort (me, "property \"%s\" not found", property);
  if (node->type != ihandle_property)
    hw_abort (me, "property \"%s\" of wrong type (ihandle)", property);
  if (node->array == NULL)
    hw_abort (me, "runtime property \"%s\" not yet initialized", property);

  ASSERT (sizeof (ihandle) == node->sizeof_array);
  memcpy (&ihandle, node->array, sizeof (ihandle));
  instance = external_to_hw_instance (me, BE2H_cell (ihandle));
  ASSERT (instance != NULL);
  return instance;
}
#endif


void
hw_add_integer_property (struct hw *me,
			 const char *property,
			 signed_cell integer)
{
  H2BE (integer);
  hw_add_property (me, property, integer_property,
		   &integer, sizeof (integer),
		   &integer, sizeof (integer),
		   NULL, permenant_object);
}

signed_cell
hw_find_integer_property (struct hw *me,
			  const char *property)
{
  const struct hw_property *node;
  signed_cell integer;
  HW_TRACE ((me, "hw_find_integer(property=%s)\n", property));
  node = hw_find_property (me, property);
  if (node == NULL)
    hw_abort (me, "property \"%s\" not found", property);
  if (node->type != integer_property)
    hw_abort (me, "property \"%s\" of wrong type (integer)", property);
  ASSERT (sizeof (integer) == node->sizeof_array);
  memcpy (&integer, node->array, sizeof (integer));
  return BE2H_cell (integer);
}

int
hw_find_integer_array_property (struct hw *me,
				const char *property,
				unsigned index,
				signed_cell *integer)
{
  const struct hw_property *node;
  int sizeof_integer = sizeof (*integer);
  signed_cell *cell;
  HW_TRACE ((me, "hw_find_integer(property=%s)\n", property));

  /* check things sane */
  node = hw_find_property (me, property);
  if (node == NULL)
    hw_abort (me, "property \"%s\" not found", property);
  if (node->type != integer_property
      && node->type != array_property)
    hw_abort (me, "property \"%s\" of wrong type (integer or array)", property);
  if ((node->sizeof_array % sizeof_integer) != 0)
    hw_abort (me, "property \"%s\" contains an incomplete number of cells", property);
  if (node->sizeof_array <= sizeof_integer * index)
    return 0;

  /* Find and convert the value */
  cell = ((signed_cell*)node->array) + index;
  *integer = BE2H_cell (*cell);

  return node->sizeof_array / sizeof_integer;
}


static unsigned_cell *
unit_address_to_cells (const hw_unit *unit,
		       unsigned_cell *cell,
		       int nr_cells)
{
  int i;
  ASSERT (nr_cells == unit->nr_cells);
  for (i = 0; i < unit->nr_cells; i++)
    {
      *cell = H2BE_cell (unit->cells[i]);
      cell += 1;
    }
  return cell;
}


static const unsigned_cell *
cells_to_unit_address (const unsigned_cell *cell,
		       hw_unit *unit,
		       int nr_cells)
{
  int i;
  memset (unit, 0, sizeof (*unit));
  unit->nr_cells = nr_cells;
  for (i = 0; i < unit->nr_cells; i++)
    {
      unit->cells[i] = BE2H_cell (*cell);
      cell += 1;
    }
  return cell;
}


static unsigned
nr_range_property_cells (struct hw *me,
			 int nr_ranges)
{
  return ((hw_unit_nr_address_cells (me)
	   + hw_unit_nr_address_cells (hw_parent (me))
	   + hw_unit_nr_size_cells (me))
	  ) * nr_ranges;
}

void
hw_add_range_array_property (struct hw *me,
			     const char *property,
			     const range_property_spec *ranges,
			     unsigned nr_ranges)
{
  unsigned sizeof_cells = (nr_range_property_cells (me, nr_ranges)
			   * sizeof (unsigned_cell));
  unsigned_cell *cells = hw_zalloc (me, sizeof_cells);
  unsigned_cell *cell;
  int i;

  /* copy the property elements over */
  cell = cells;
  for (i = 0; i < nr_ranges; i++)
    {
      const range_property_spec *range = &ranges[i];
      /* copy the child address */
      cell = unit_address_to_cells (&range->child_address, cell,
				    hw_unit_nr_address_cells (me));
      /* copy the parent address */
      cell = unit_address_to_cells (&range->parent_address, cell,
				    hw_unit_nr_address_cells (hw_parent (me)));
      /* copy the size */
      cell = unit_address_to_cells (&range->size, cell,
				    hw_unit_nr_size_cells (me));
    }
  ASSERT (cell == &cells[nr_range_property_cells (me, nr_ranges)]);

  /* add it */
  hw_add_property (me, property, range_array_property,
		   cells, sizeof_cells,
		   cells, sizeof_cells,
		   NULL, permenant_object);

  hw_free (me, cells);
}

int
hw_find_range_array_property (struct hw *me,
			      const char *property,
			      unsigned index,
			      range_property_spec *range)
{
  const struct hw_property *node;
  unsigned sizeof_entry = (nr_range_property_cells (me, 1)
			   * sizeof (unsigned_cell));
  const unsigned_cell *cells;

  /* locate the property */
  node = hw_find_property (me, property);
  if (node == NULL)
    hw_abort (me, "property \"%s\" not found", property);
  if (node->type != range_array_property)
    hw_abort (me, "property \"%s\" of wrong type (range array)", property);

  /* aligned ? */
  if ((node->sizeof_array % sizeof_entry) != 0)
    hw_abort (me, "property \"%s\" contains an incomplete number of entries",
	      property);

  /* within bounds? */
  if (node->sizeof_array < sizeof_entry * (index + 1))
    return 0;

  /* find the range of interest */
  cells = (unsigned_cell*)((char*)node->array + sizeof_entry * index);

  /* copy the child address out - converting as we go */
  cells = cells_to_unit_address (cells, &range->child_address,
				 hw_unit_nr_address_cells (me));

  /* copy the parent address out - converting as we go */
  cells = cells_to_unit_address (cells, &range->parent_address,
				 hw_unit_nr_address_cells (hw_parent (me)));

  /* copy the size - converting as we go */
  cells = cells_to_unit_address (cells, &range->size,
				 hw_unit_nr_size_cells (me));

  return node->sizeof_array / sizeof_entry;
}


static unsigned
nr_reg_property_cells (struct hw *me,
		       int nr_regs)
{
  return (hw_unit_nr_address_cells (hw_parent (me))
	  + hw_unit_nr_size_cells (hw_parent (me))
	  ) * nr_regs;
}

void
hw_add_reg_array_property (struct hw *me,
			   const char *property,
			   const reg_property_spec *regs,
			   unsigned nr_regs)
{
  unsigned sizeof_cells = (nr_reg_property_cells (me, nr_regs)
			   * sizeof (unsigned_cell));
  unsigned_cell *cells = hw_zalloc (me, sizeof_cells);
  unsigned_cell *cell;
  int i;

  /* copy the property elements over */
  cell = cells;
  for (i = 0; i < nr_regs; i++)
    {
      const reg_property_spec *reg = &regs[i];
      /* copy the address */
      cell = unit_address_to_cells (&reg->address, cell,
				    hw_unit_nr_address_cells (hw_parent (me)));
      /* copy the size */
      cell = unit_address_to_cells (&reg->size, cell,
				    hw_unit_nr_size_cells (hw_parent (me)));
    }
  ASSERT (cell == &cells[nr_reg_property_cells (me, nr_regs)]);

  /* add it */
  hw_add_property (me, property, reg_array_property,
		   cells, sizeof_cells,
		   cells, sizeof_cells,
		   NULL, permenant_object);

  hw_free (me, cells);
}

int
hw_find_reg_array_property (struct hw *me,
			    const char *property,
			    unsigned index,
			    reg_property_spec *reg)
{
  const struct hw_property *node;
  unsigned sizeof_entry = (nr_reg_property_cells (me, 1)
			   * sizeof (unsigned_cell));
  const unsigned_cell *cells;

  /* locate the property */
  node = hw_find_property (me, property);
  if (node == NULL)
    hw_abort (me, "property \"%s\" not found", property);
  if (node->type != reg_array_property)
    hw_abort (me, "property \"%s\" of wrong type (reg array)", property);

  /* aligned ? */
  if ((node->sizeof_array % sizeof_entry) != 0)
    hw_abort (me, "property \"%s\" contains an incomplete number of entries",
	      property);

  /* within bounds? */
  if (node->sizeof_array < sizeof_entry * (index + 1))
    return 0;

  /* find the range of interest */
  cells = (unsigned_cell*)((char*)node->array + sizeof_entry * index);

  /* copy the address out - converting as we go */
  cells = cells_to_unit_address (cells, &reg->address,
				 hw_unit_nr_address_cells (hw_parent (me)));

  /* copy the size out - converting as we go */
  cells = cells_to_unit_address (cells, &reg->size,
				 hw_unit_nr_size_cells (hw_parent (me)));

  return node->sizeof_array / sizeof_entry;
}


void
hw_add_string_property (struct hw *me,
			const char *property,
			const char *string)
{
  hw_add_property (me, property, string_property,
		   string, strlen (string) + 1,
		   string, strlen (string) + 1,
		   NULL, permenant_object);
}

const char *
hw_find_string_property (struct hw *me,
			 const char *property)
{
  const struct hw_property *node;
  const char *string;
  node = hw_find_property (me, property);
  if (node == NULL)
    hw_abort (me, "property \"%s\" not found", property);
  if (node->type != string_property)
    hw_abort (me, "property \"%s\" of wrong type (string)", property);
  string = node->array;
  ASSERT (strlen (string) + 1 == node->sizeof_array);
  return string;
}

void
hw_add_string_array_property (struct hw *me,
			      const char *property,
			      const string_property_spec *strings,
			      unsigned nr_strings)
{
  int sizeof_array;
  int string_nr;
  char *array;
  char *chp;
  if (nr_strings == 0)
    hw_abort (me, "property \"%s\" must be non-null", property);
  /* total up the size of the needed array */
  for (sizeof_array = 0, string_nr = 0;
       string_nr < nr_strings;
       string_nr ++)
    {
      sizeof_array += strlen (strings[string_nr]) + 1;
    }
  /* create the array */
  array = (char*) hw_zalloc (me, sizeof_array);
  chp = array;
  for (string_nr = 0;
       string_nr < nr_strings;
       string_nr++)
    {
      strcpy (chp, strings[string_nr]);
      chp += strlen (chp) + 1;
    }
  ASSERT (chp == array + sizeof_array);
  /* now enter it */
  hw_add_property (me, property, string_array_property,
		   array, sizeof_array,
		   array, sizeof_array,
		   NULL, permenant_object);
}

int
hw_find_string_array_property (struct hw *me,
			       const char *property,
			       unsigned index,
			       string_property_spec *string)
{
  const struct hw_property *node;
  node = hw_find_property (me, property);
  if (node == NULL)
    hw_abort (me, "property \"%s\" not found", property);
  switch (node->type)
    {
    default:
      hw_abort (me, "property \"%s\" of wrong type", property);
      break;
    case string_property:
      if (index == 0)
	{
	  *string = node->array;
	  ASSERT (strlen (*string) + 1 == node->sizeof_array);
	  return 1;
	}
      break;
    case array_property:
      if (node->sizeof_array == 0
	  || ((char*)node->array)[node->sizeof_array - 1] != '\0')
	hw_abort (me, "property \"%s\" invalid for string array", property);
      /* FALL THROUGH */
    case string_array_property:
      ASSERT (node->sizeof_array > 0);
      ASSERT (((char*)node->array)[node->sizeof_array - 1] == '\0');
      {
	const char *chp = node->array;
	int nr_entries = 0;
	/* count the number of strings, keeping an eye out for the one
	   we're looking for */
	*string = chp;
	do
	  {
	    if (*chp == '\0')
	      {
		/* next string */
		nr_entries++;
		chp++;
		if (nr_entries == index)
		  *string = chp;
	      }
	    else
	      {
		chp++;
	      }
	  } while (chp < (char*)node->array + node->sizeof_array);
	if (index < nr_entries)
	  return nr_entries;
	else
	  {
	    *string = NULL;
	    return 0;
	  }
      }
      break;
    }
  return 0;
}

void
hw_add_duplicate_property (struct hw *me,
			   const char *property,
			   const struct hw_property *original)
{
  struct hw_property_data *master;
  HW_TRACE ((me, "hw_add_duplicate_property(property=%s, ...)\n", property));
  if (original->disposition != permenant_object)
    hw_abort (me, "Can only duplicate permenant objects");
  /* find the original's master */
  master = original->owner->properties_of_hw;
  while (master->property != original)
    {
      master = master->next;
      ASSERT (master != NULL);
    }
  /* now duplicate it */
  hw_add_property (me, property,
		   original->type,
		   master->init_array, master->sizeof_init_array,
		   original->array, original->sizeof_array,
		   original, permenant_object);
}
@


1.13
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright 2002, 2007-2012 Free Software Foundation, Inc.
@


1.12
log
@sim: fix func call style (space before paren)

Committed this as obvious:
	-foo(...);
	+foo (...);

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.12.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright 2002, 2007-2012 Free Software Foundation, Inc.
@


1.11
log
@sim: fix up style a bit

This touches up the code a bit to match GNU style.  No functional changes.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d214 1
a214 1
      ASSERT(property->property->disposition == permenant_object);
d376 2
a377 2
		   &new_boolean, sizeof(new_boolean),
		   &new_boolean, sizeof(new_boolean),
d407 1
a407 1
		   ihandle->full_path, strlen(ihandle->full_path) + 1,
d461 1
a461 1
    hw_abort(me, "property \"%s\" of wrong type (ihandle)", property);
d463 1
a463 1
    hw_abort(me, "runtime property \"%s\" not yet initialized", property);
d465 3
a467 3
  ASSERT (sizeof(ihandle) == node->sizeof_array);
  memcpy (&ihandle, node->array, sizeof(ihandle));
  instance = external_to_hw_instance (me, BE2H_cell(ihandle));
d481 2
a482 2
		   &integer, sizeof(integer),
		   &integer, sizeof(integer),
d498 1
a498 1
  ASSERT (sizeof(integer) == node->sizeof_array);
d540 1
a540 1
  ASSERT(nr_cells == unit->nr_cells);
d556 1
a556 1
  memset(unit, 0, sizeof(*unit));
d665 2
a666 2
  return (hw_unit_nr_address_cells (hw_parent(me))
	  + hw_unit_nr_size_cells (hw_parent(me))
d753 2
a754 2
		   string, strlen(string) + 1,
		   string, strlen(string) + 1,
d770 1
a770 1
  ASSERT (strlen(string) + 1 == node->sizeof_array);
d830 1
a830 1
	  ASSERT (strlen(*string) + 1 == node->sizeof_array);
d890 1
a890 1
      ASSERT(master != NULL);
@


1.10
log
@sim: common: trim trailing whitespace
@
text
@d38 2
a39 1
struct hw_property_data {
@


1.10.2.1
log
@sim: fix up style a bit

This touches up the code a bit to match GNU style.  No functional changes.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d38 1
a38 2
struct hw_property_data
{
@


1.9
log
@run copyright.sh for 2011.
@
text
@d88 1
a88 1
  
d97 1
a97 1
  
d112 1
a112 1
  
d443 1
a443 1
		      
d512 1
a512 1
  
d524 1
a524 1
  
d528 1
a528 1
  
d587 1
a587 1
  
d597 1
a597 1
      cell = unit_address_to_cells (&range->parent_address, cell, 
d600 1
a600 1
      cell = unit_address_to_cells (&range->size, cell, 
d604 1
a604 1
  
d610 1
a610 1
  
d624 1
a624 1
  
d631 1
a631 1
  
d636 1
a636 1
  
d640 1
a640 1
  
d643 1
a643 1
  
d647 1
a647 1
  
d651 1
a651 1
  
d655 1
a655 1
  
d680 1
a680 1
  
d694 1
a694 1
  
d700 1
a700 1
  
d714 1
a714 1
  
d721 1
a721 1
  
d726 1
a726 1
  
d730 1
a730 1
  
d733 1
a733 1
  
d737 1
a737 1
  
d741 1
a741 1
  
@


1.8
log
@sim: avoid TRACE redefine warnings

The common code sets up an autoconf option --enable-sim-trace which adds
-DTRACE= to CPPFLAGS.  This causes warnings in the building of some files
that declare a local TRACE() helper macro.  So punt it from hw-ports.c
(since it isn't actually used) and convert hw-properties.c to HW_TRACE().
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.7
log
@Update copyright notices to add year 2010.
@
text
@a35 2
#define TRACE(A,B)

d419 1
a419 3
  TRACE (trace_devices,
	 ("hw_find_ihandle_runtime_property(me=0x%lx, property=%s)\n",
	  (long)me, property));
d491 1
a491 3
  TRACE (trace_devices,
	 ("hw_find_integer(me=0x%lx, property=%s)\n",
	  (long)me, property));
d511 1
a511 3
  TRACE (trace_devices,
	 ("hw_find_integer(me=0x%lx, property=%s)\n",
	  (long)me, property));
d881 1
a881 3
  TRACE (trace_devices,
	 ("hw_add_duplicate_property(me=0x%lx, property=%s, ...)\n",
	  (long)me, property));
@


1.6
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.5
log
@	Updated copyright notices for most files.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008 Free Software Foundation, Inc.
@


1.4
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d3 1
a3 1
   Copyright 2002, 2007 Free Software Foundation, Inc.
@


1.3
log
@Copyright updates for 2007.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.2
log
@2002-11-22  Andrew Cagney  <ac131313@@redhat.com>

	* dv-core.c: Update copyright.  sim/common contributed to the FSF.
	* dv-glue.c, dv-pal.c, hw-base.c, hw-base.h, hw-device.c: Ditto.
	* hw-device.h, hw-handles.c, hw-handles.h: Ditto.
	* hw-instances.c, hw-instances.h, hw-properties.c: Ditto.
	* hw-properties.h, hw-tree.c, hw-tree.h, sim-alu.h: Ditto.
	* sim-basics.h, sim-bits.c, sim-bits.h, sim-config.c: Ditto.
	* sim-config.h, sim-core.c, sim-core.h, sim-endian.c: Ditto.
	* sim-endian.h, sim-events.c, sim-events.h, sim-inline.c: Ditto.
	* sim-inline.h, sim-io.c, sim-io.h, sim-n-bits.h: Ditto.
	* sim-n-core.h, sim-n-endian.h, sim-types.h: Ditto.
@
text
@d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*  This file is part of the program psim.
d3 1
a3 1
    Copyright (C) 1994-1998, Andrew Cagney <cagney@@highland.com.au>
d5 18
a22 15
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
    */
d27 1
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-09-21
@
text
@a23 1
#include "sim-io.h"
@


1.1.1.2.28.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1 1
a1 1
/* The common simulator framework for GDB, the GNU Debugger.
d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d5 15
a19 18
   Contributed by Andrew Cagney and Red Hat.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.1.1.2.26.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d1 1
a1 1
/* The common simulator framework for GDB, the GNU Debugger.
d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d5 15
a19 18
   Contributed by Andrew Cagney and Red Hat.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.1.1.2.24.1
log
@2002-11-22  Andrew Cagney  <ac131313@@redhat.com>

	* dv-core.c: Update copyright.  sim/common contributed to the FSF.
	* dv-glue.c, dv-pal.c, hw-base.c, hw-base.h, hw-device.c: Ditto.
	* hw-device.h, hw-handles.c, hw-handles.h: Ditto.
	* hw-instances.c, hw-instances.h, hw-properties.c: Ditto.
	* hw-properties.h, hw-tree.c, hw-tree.h, sim-alu.h: Ditto.
	* sim-basics.h, sim-bits.c, sim-bits.h, sim-config.c: Ditto.
	* sim-config.h, sim-core.c, sim-core.h, sim-endian.c: Ditto.
	* sim-endian.h, sim-events.c, sim-events.h, sim-inline.c: Ditto.
	* sim-inline.h, sim-io.c, sim-io.h, sim-n-bits.h: Ditto.
	* sim-n-core.h, sim-n-endian.h, sim-types.h: Ditto.
@
text
@d1 1
a1 1
/* The common simulator framework for GDB, the GNU Debugger.
d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d5 15
a19 18
   Contributed by Andrew Cagney and Red Hat.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


