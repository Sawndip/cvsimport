head	1.18;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.18
	gdb_7_6-2013-04-26-release:1.18
	gdb_7_6-branch:1.18.0.2
	gdb_7_6-2013-03-12-branchpoint:1.18
	gdb_7_5_1-2012-11-29-release:1.17
	gdb_7_5-2012-08-17-release:1.17
	gdb_7_5-branch:1.17.0.2
	gdb_7_5-2012-07-18-branchpoint:1.17
	gdb_7_4_1-2012-04-26-release:1.15.2.1
	gdb_7_4-2012-01-24-release:1.15.2.1
	gdb_7_4-branch:1.15.0.2
	gdb_7_4-2011-12-13-branchpoint:1.15
	gdb_7_3_1-2011-09-04-release:1.14
	gdb_7_3-2011-07-26-release:1.14
	gdb_7_3-branch:1.14.0.2
	gdb_7_3-2011-04-01-branchpoint:1.14
	gdb_7_2-2010-09-02-release:1.12
	gdb_7_2-branch:1.12.0.2
	gdb_7_2-2010-07-07-branchpoint:1.12
	gdb_7_1-2010-03-18-release:1.8
	gdb_7_1-branch:1.8.0.2
	gdb_7_1-2010-02-18-branchpoint:1.8
	gdb_7_0_1-2009-12-22-release:1.7
	gdb_7_0-2009-10-06-release:1.7
	gdb_7_0-branch:1.7.0.4
	gdb_7_0-2009-09-16-branchpoint:1.7
	arc-sim-20090309:1.6
	msnyder-checkpoint-072509-branch:1.7.0.2
	msnyder-checkpoint-072509-branchpoint:1.7
	arc-insight_6_8-branch:1.6.0.16
	arc-insight_6_8-branchpoint:1.6
	insight_6_8-branch:1.6.0.14
	insight_6_8-branchpoint:1.6
	reverse-20081226-branch:1.6.0.12
	reverse-20081226-branchpoint:1.6
	multiprocess-20081120-branch:1.6.0.10
	multiprocess-20081120-branchpoint:1.6
	reverse-20080930-branch:1.6.0.8
	reverse-20080930-branchpoint:1.6
	reverse-20080717-branch:1.6.0.6
	reverse-20080717-branchpoint:1.6
	msnyder-reverse-20080609-branch:1.6.0.4
	msnyder-reverse-20080609-branchpoint:1.6
	drow-reverse-20070409-branch:1.4.0.2
	drow-reverse-20070409-branchpoint:1.4
	gdb_6_8-2008-03-27-release:1.6
	gdb_6_8-branch:1.6.0.2
	gdb_6_8-2008-02-26-branchpoint:1.6
	gdb_6_7_1-2007-10-29-release:1.5
	gdb_6_7-2007-10-10-release:1.5
	gdb_6_7-branch:1.5.0.2
	gdb_6_7-2007-09-07-branchpoint:1.5
	insight_6_6-20070208-release:1.3
	gdb_6_6-2006-12-18-release:1.3
	gdb_6_6-branch:1.3.0.48
	gdb_6_6-2006-11-15-branchpoint:1.3
	insight_6_5-20061003-release:1.3
	gdb-csl-symbian-6_4_50_20060226-12:1.3
	gdb-csl-sourcerygxx-3_4_4-25:1.3
	nickrob-async-20060828-mergepoint:1.3
	gdb-csl-symbian-6_4_50_20060226-11:1.3
	gdb-csl-sourcerygxx-4_1-17:1.3
	gdb-csl-20060226-branch-local-2:1.3
	gdb-csl-sourcerygxx-4_1-14:1.3
	gdb-csl-sourcerygxx-4_1-13:1.3
	gdb-csl-sourcerygxx-4_1-12:1.3
	gdb-csl-sourcerygxx-3_4_4-21:1.3
	gdb_6_5-20060621-release:1.3
	gdb-csl-sourcerygxx-4_1-9:1.3
	gdb-csl-sourcerygxx-4_1-8:1.3
	gdb-csl-sourcerygxx-4_1-7:1.3
	gdb-csl-arm-2006q1-6:1.3
	gdb-csl-sourcerygxx-4_1-6:1.3
	gdb-csl-symbian-6_4_50_20060226-10:1.3
	gdb-csl-symbian-6_4_50_20060226-9:1.3
	gdb-csl-symbian-6_4_50_20060226-8:1.3
	gdb-csl-coldfire-4_1-11:1.3
	gdb-csl-sourcerygxx-3_4_4-19:1.3
	gdb-csl-coldfire-4_1-10:1.3
	gdb_6_5-branch:1.3.0.46
	gdb_6_5-2006-05-14-branchpoint:1.3
	gdb-csl-sourcerygxx-4_1-5:1.3
	nickrob-async-20060513-branch:1.3.0.44
	nickrob-async-20060513-branchpoint:1.3
	gdb-csl-sourcerygxx-4_1-4:1.3
	msnyder-reverse-20060502-branch:1.3.0.42
	msnyder-reverse-20060502-branchpoint:1.3
	gdb-csl-morpho-4_1-4:1.3
	gdb-csl-sourcerygxx-3_4_4-17:1.3
	readline_5_1-import-branch:1.3.0.40
	readline_5_1-import-branchpoint:1.3
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.3
	gdb-csl-symbian-20060226-branch:1.3.0.38
	gdb-csl-symbian-20060226-branchpoint:1.3
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.3
	msnyder-reverse-20060331-branch:1.3.0.36
	msnyder-reverse-20060331-branchpoint:1.3
	gdb-csl-available-20060303-branch:1.3.0.34
	gdb-csl-available-20060303-branchpoint:1.3
	gdb-csl-20060226-branch:1.3.0.32
	gdb-csl-20060226-branchpoint:1.3
	gdb_6_4-20051202-release:1.3
	msnyder-fork-checkpoint-branch:1.3.0.30
	msnyder-fork-checkpoint-branchpoint:1.3
	gdb-csl-gxxpro-6_3-branch:1.3.0.28
	gdb-csl-gxxpro-6_3-branchpoint:1.3
	gdb_6_4-branch:1.3.0.26
	gdb_6_4-2005-11-01-branchpoint:1.3
	gdb-csl-arm-20051020-branch:1.3.0.24
	gdb-csl-arm-20051020-branchpoint:1.3
	msnyder-tracepoint-checkpoint-branch:1.3.0.22
	msnyder-tracepoint-checkpoint-branchpoint:1.3
	gdb-csl-arm-20050325-2005-q1b:1.3
	gdb-csl-arm-20050325-2005-q1a:1.3
	csl-arm-20050325-branch:1.3.0.20
	csl-arm-20050325-branchpoint:1.3
	gdb_6_3-20041109-release:1.3
	gdb_6_3-branch:1.3.0.16
	gdb_6_3-20041019-branchpoint:1.3
	drow_intercu-merge-20040921:1.3
	drow_intercu-merge-20040915:1.3
	jimb-gdb_6_2-e500-branch:1.3.0.18
	jimb-gdb_6_2-e500-branchpoint:1.3
	gdb_6_2-20040730-release:1.3
	gdb_6_2-branch:1.3.0.14
	gdb_6_2-2004-07-10-gmt-branchpoint:1.3
	gdb_6_1_1-20040616-release:1.3
	gdb_6_1-2004-04-05-release:1.3
	drow_intercu-merge-20040402:1.3
	drow_intercu-merge-20040327:1.3
	ezannoni_pie-20040323-branch:1.3.0.12
	ezannoni_pie-20040323-branchpoint:1.3
	cagney_tramp-20040321-mergepoint:1.3
	cagney_tramp-20040309-branch:1.3.0.10
	cagney_tramp-20040309-branchpoint:1.3
	gdb_6_1-branch:1.3.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.3
	drow_intercu-20040221-branch:1.3.0.6
	drow_intercu-20040221-branchpoint:1.3
	cagney_bfdfile-20040213-branch:1.3.0.4
	cagney_bfdfile-20040213-branchpoint:1.3
	drow-cplus-merge-20040208:1.3
	carlton_dictionary-20040126-merge:1.3
	cagney_bigcore-20040122-branch:1.3.0.2
	cagney_bigcore-20040122-branchpoint:1.3
	drow-cplus-merge-20040113:1.3
	drow-cplus-merge-20031224:1.3
	drow-cplus-merge-20031220:1.3
	carlton_dictionary-20031215-merge:1.3
	drow-cplus-merge-20031214:1.3
	carlton-dictionary-20031111-merge:1.3
	gdb_6_0-2003-10-04-release:1.2
	kettenis_sparc-20030918-branch:1.2.0.64
	kettenis_sparc-20030918-branchpoint:1.2
	carlton_dictionary-20030917-merge:1.2
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.62
	cagney_x86i386-20030821-branch:1.2.0.60
	cagney_x86i386-20030821-branchpoint:1.2
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.2.0.58
	gdb_6_0-2003-06-23-branchpoint:1.2
	jimb-ppc64-linux-20030613-branch:1.2.0.56
	jimb-ppc64-linux-20030613-branchpoint:1.2
	cagney_convert-20030606-branch:1.2.0.54
	cagney_convert-20030606-branchpoint:1.2
	cagney_writestrings-20030508-branch:1.2.0.52
	cagney_writestrings-20030508-branchpoint:1.2
	jimb-ppc64-linux-20030528-branch:1.2.0.50
	jimb-ppc64-linux-20030528-branchpoint:1.2
	carlton_dictionary-20030523-merge:1.2
	cagney_fileio-20030521-branch:1.2.0.48
	cagney_fileio-20030521-branchpoint:1.2
	kettenis_i386newframe-20030517-mergepoint:1.2
	jimb-ppc64-linux-20030509-branch:1.2.0.46
	jimb-ppc64-linux-20030509-branchpoint:1.2
	kettenis_i386newframe-20030504-mergepoint:1.2
	carlton_dictionary-20030430-merge:1.2
	kettenis_i386newframe-20030419-branch:1.2.0.44
	kettenis_i386newframe-20030419-branchpoint:1.2
	carlton_dictionary-20030416-merge:1.2
	cagney_frameaddr-20030409-mergepoint:1.2
	kettenis_i386newframe-20030406-branch:1.2.0.42
	kettenis_i386newframe-20030406-branchpoint:1.2
	cagney_frameaddr-20030403-branchpoint:1.2
	cagney_frameaddr-20030403-branch:1.2.0.40
	cagney_framebase-20030330-mergepoint:1.2
	cagney_framebase-20030326-branch:1.2.0.38
	cagney_framebase-20030326-branchpoint:1.2
	cagney_lazyid-20030317-branch:1.2.0.36
	cagney_lazyid-20030317-branchpoint:1.2
	kettenis-i386newframe-20030316-mergepoint:1.2
	offbyone-20030313-branch:1.2.0.34
	offbyone-20030313-branchpoint:1.2
	kettenis-i386newframe-20030308-branch:1.2.0.32
	kettenis-i386newframe-20030308-branchpoint:1.2
	carlton_dictionary-20030305-merge:1.2
	cagney_offbyone-20030303-branch:1.2.0.30
	cagney_offbyone-20030303-branchpoint:1.2
	carlton_dictionary-20030207-merge:1.2
	interps-20030202-branch:1.2.0.28
	interps-20030202-branchpoint:1.2
	cagney-unwind-20030108-branch:1.2.0.26
	cagney-unwind-20030108-branchpoint:1.2
	carlton_dictionary-20021223-merge:1.2
	gdb_5_3-2002-12-12-release:1.2
	carlton_dictionary-20021115-merge:1.2
	kseitz_interps-20021105-merge:1.2
	kseitz_interps-20021103-merge:1.2
	drow-cplus-merge-20021020:1.2
	drow-cplus-merge-20021025:1.2
	carlton_dictionary-20021025-merge:1.2
	carlton_dictionary-20021011-merge:1.2
	drow-cplus-branch:1.2.0.24
	drow-cplus-branchpoint:1.2
	kseitz_interps-20020930-merge:1.2
	carlton_dictionary-20020927-merge:1.2
	carlton_dictionary-branch:1.2.0.22
	carlton_dictionary-20020920-branchpoint:1.2
	gdb_5_3-branch:1.2.0.20
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.18
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.16
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.14
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.12
	cagney_regbuf-20020515-branchpoint:1.2
	jimb-macro-020506-branch:1.2.0.10
	jimb-macro-020506-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.8
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.2
	gdb_5_1_0_1-2002-01-03-release:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.4
	gdb_s390-2001-09-26-branchpoint:1.2
	gdb_5_1-2001-07-29-branch:1.2.0.2
	gdb_5_1-2001-07-29-branchpoint:1.2
	insight-precleanup-2001-01-01:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.18
date	2013.01.01.06.41.33;	author brobecke;	state Exp;
branches;
next	1.17;

1.17
date	2012.03.29.00.57.19;	author kevinb;	state Exp;
branches;
next	1.16;

1.16
date	2012.01.04.08.28.06;	author brobecke;	state Exp;
branches;
next	1.15;

1.15
date	2011.05.26.00.09.59;	author vapier;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2011.03.15.03.16.17;	author vapier;	state Exp;
branches;
next	1.13;

1.13
date	2011.01.01.15.33.56;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2010.04.12.16.53.33;	author vapier;	state Exp;
branches;
next	1.11;

1.11
date	2010.04.10.08.00.58;	author vapier;	state Exp;
branches;
next	1.10;

1.10
date	2010.03.30.20.39.38;	author vapier;	state Exp;
branches;
next	1.9;

1.9
date	2010.03.30.19.43.42;	author vapier;	state Exp;
branches;
next	1.8;

1.8
date	2010.01.01.10.03.27;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.14.10.53.06;	author brobecke;	state Exp;
branches;
next	1.6;

1.6
date	2008.01.01.22.53.23;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2007.08.24.14.28.35;	author brobecke;	state Exp;
branches;
next	1.4;

1.4
date	2007.01.09.17.59.16;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.31.05.32.46;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.22.20.47.49;	author bje;	state Exp;
branches
	1.2.22.1
	1.2.24.1;
next	1.1;

1.1
date	99.04.16.01.34.59;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.15.2.1
date	2012.01.06.04.54.40;	author brobecke;	state Exp;
branches;
next	;

1.2.22.1
date	2003.11.11.23.51.18;	author carlton;	state Exp;
branches;
next	;

1.2.24.1
date	2003.12.14.20.28.19;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.59;	author shebs;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* Simulator tracing/debugging support.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   Contributed by Cygnus Support.

This file is part of GDB, the GNU debugger.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "sim-main.h"
#include "sim-io.h"
#include "sim-options.h"
#include "sim-fpu.h"

#include "bfd.h"
#include "libiberty.h"

#include "sim-assert.h"

#ifdef HAVE_STRING_H
#include <string.h>
#else
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif
#endif
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#ifndef SIZE_PHASE
#define SIZE_PHASE 8
#endif

#ifndef SIZE_LOCATION
#define SIZE_LOCATION 20
#endif

#ifndef SIZE_PC
#define SIZE_PC 6
#endif

#ifndef SIZE_LINE_NUMBER
#define SIZE_LINE_NUMBER 4
#endif

static MODULE_INIT_FN trace_init;
static MODULE_UNINSTALL_FN trace_uninstall;

static DECLARE_OPTION_HANDLER (trace_option_handler);

enum {
  OPTION_TRACE_INSN	= OPTION_START,
  OPTION_TRACE_DECODE,
  OPTION_TRACE_EXTRACT,
  OPTION_TRACE_LINENUM,
  OPTION_TRACE_MEMORY,
  OPTION_TRACE_MODEL,
  OPTION_TRACE_ALU,
  OPTION_TRACE_CORE,
  OPTION_TRACE_EVENTS,
  OPTION_TRACE_FPU,
  OPTION_TRACE_BRANCH,
  OPTION_TRACE_SEMANTICS,
  OPTION_TRACE_RANGE,
  OPTION_TRACE_FUNCTION,
  OPTION_TRACE_DEBUG,
  OPTION_TRACE_FILE,
  OPTION_TRACE_VPU,
  OPTION_TRACE_SYSCALL
};

static const OPTION trace_options[] =
{
  /* This table is organized to group related instructions together.  */
  { {"trace", optional_argument, NULL, 't'},
      't', "on|off", "Trace useful things",
      trace_option_handler, NULL },
  { {"trace-insn", optional_argument, NULL, OPTION_TRACE_INSN},
      '\0', "on|off", "Perform instruction tracing",
      trace_option_handler, NULL },
  { {"trace-decode", optional_argument, NULL, OPTION_TRACE_DECODE},
      '\0', "on|off", "Trace instruction decoding",
      trace_option_handler, NULL },
  { {"trace-extract", optional_argument, NULL, OPTION_TRACE_EXTRACT},
      '\0', "on|off", "Trace instruction extraction",
      trace_option_handler, NULL },
  { {"trace-linenum", optional_argument, NULL, OPTION_TRACE_LINENUM},
      '\0', "on|off", "Perform line number tracing (implies --trace-insn)",
      trace_option_handler, NULL },
  { {"trace-memory", optional_argument, NULL, OPTION_TRACE_MEMORY},
      '\0', "on|off", "Trace memory operations",
      trace_option_handler, NULL },
  { {"trace-alu", optional_argument, NULL, OPTION_TRACE_ALU},
      '\0', "on|off", "Trace ALU operations",
      trace_option_handler, NULL },
  { {"trace-fpu", optional_argument, NULL, OPTION_TRACE_FPU},
      '\0', "on|off", "Trace FPU operations",
      trace_option_handler, NULL },
  { {"trace-vpu", optional_argument, NULL, OPTION_TRACE_VPU},
      '\0', "on|off", "Trace VPU operations",
      trace_option_handler, NULL },
  { {"trace-branch", optional_argument, NULL, OPTION_TRACE_BRANCH},
      '\0', "on|off", "Trace branching",
      trace_option_handler, NULL },
  { {"trace-semantics", optional_argument, NULL, OPTION_TRACE_SEMANTICS},
      '\0', "on|off", "Perform ALU, FPU, MEMORY, and BRANCH tracing",
      trace_option_handler, NULL },
  { {"trace-model", optional_argument, NULL, OPTION_TRACE_MODEL},
      '\0', "on|off", "Include model performance data",
      trace_option_handler, NULL },
  { {"trace-core", optional_argument, NULL, OPTION_TRACE_CORE},
      '\0', "on|off", "Trace core operations",
      trace_option_handler, NULL },
  { {"trace-events", optional_argument, NULL, OPTION_TRACE_EVENTS},
      '\0', "on|off", "Trace events",
      trace_option_handler, NULL },
  { {"trace-syscall", optional_argument, NULL, OPTION_TRACE_SYSCALL},
      '\0', "on|off", "Trace system calls",
      trace_option_handler, NULL },
#ifdef SIM_HAVE_ADDR_RANGE
  { {"trace-range", required_argument, NULL, OPTION_TRACE_RANGE},
      '\0', "START,END", "Specify range of addresses for instruction tracing",
      trace_option_handler, NULL },
#if 0 /*wip*/
  { {"trace-function", required_argument, NULL, OPTION_TRACE_FUNCTION},
      '\0', "FUNCTION", "Specify function to trace",
      trace_option_handler, NULL },
#endif
#endif
  { {"trace-debug", optional_argument, NULL, OPTION_TRACE_DEBUG},
      '\0', "on|off", "Add information useful for debugging the simulator to the tracing output",
      trace_option_handler, NULL },
  { {"trace-file", required_argument, NULL, OPTION_TRACE_FILE},
      '\0', "FILE NAME", "Specify tracing output file",
      trace_option_handler, NULL },
  { {NULL, no_argument, NULL, 0}, '\0', NULL, NULL, NULL, NULL }
};

/* Set/reset the trace options indicated in MASK.  */

static SIM_RC
set_trace_option_mask (SIM_DESC sd, const char *name, int mask, const char *arg)
{
  int trace_nr;
  int cpu_nr;
  int trace_val = 1;

  if (arg != NULL)
    {
      if (strcmp (arg, "yes") == 0
	  || strcmp (arg, "on") == 0
	  || strcmp (arg, "1") == 0)
	trace_val = 1;
      else if (strcmp (arg, "no") == 0
	       || strcmp (arg, "off") == 0
	       || strcmp (arg, "0") == 0)
	trace_val = 0;
      else
	{
	  sim_io_eprintf (sd, "Argument `%s' for `--trace%s' invalid, one of `on', `off', `yes', `no' expected\n", arg, name);
	  return SIM_RC_FAIL;
	}
    }

  /* update applicable trace bits */
  for (trace_nr = 0; trace_nr < MAX_TRACE_VALUES; ++trace_nr)
    {
      if ((mask & (1 << trace_nr)) == 0)
	continue;

      /* Set non-cpu specific values.  */
      switch (trace_nr)
	{
	case TRACE_EVENTS_IDX:
	  STATE_EVENTS (sd)->trace = trace_val;
	  break;
	case TRACE_DEBUG_IDX:
	  STATE_TRACE_FLAGS (sd)[trace_nr] = trace_val;
	  break;
	}

      /* Set cpu values.  */
      for (cpu_nr = 0; cpu_nr < MAX_NR_PROCESSORS; cpu_nr++)
	{
	  CPU_TRACE_FLAGS (STATE_CPU (sd, cpu_nr))[trace_nr] = trace_val;
	}
    }

  /* Re-compute the cpu trace summary.  */
  if (trace_val)
    {
      for (cpu_nr = 0; cpu_nr < MAX_NR_PROCESSORS; cpu_nr++)
	CPU_TRACE_DATA (STATE_CPU (sd, cpu_nr))->trace_any_p = 1;
    }
  else
    {
      for (cpu_nr = 0; cpu_nr < MAX_NR_PROCESSORS; cpu_nr++)
	{
	  CPU_TRACE_DATA (STATE_CPU (sd, cpu_nr))->trace_any_p = 0;
	  for (trace_nr = 0; trace_nr < MAX_TRACE_VALUES; ++trace_nr)
	    {
	      if (CPU_TRACE_FLAGS (STATE_CPU (sd, cpu_nr))[trace_nr])
		{
		  CPU_TRACE_DATA (STATE_CPU (sd, cpu_nr))->trace_any_p = 1;
		  break;
		}
	    }
	}
    }

  return SIM_RC_OK;
}

/* Set one trace option based on its IDX value.  */

static SIM_RC
set_trace_option (SIM_DESC sd, const char *name, int idx, const char *arg)
{
  return set_trace_option_mask (sd, name, 1 << idx, arg);
}


static SIM_RC
trace_option_handler (SIM_DESC sd, sim_cpu *cpu, int opt,
		      char *arg, int is_command)
{
  int n;

  switch (opt)
    {
    case 't' :
      if (! WITH_TRACE)
	sim_io_eprintf (sd, "Tracing not compiled in, `-t' ignored\n");
      else
	return set_trace_option_mask (sd, "trace", TRACE_USEFUL_MASK, arg);
      break;

    case OPTION_TRACE_INSN :
      if (WITH_TRACE_INSN_P)
	return set_trace_option (sd, "-insn", TRACE_INSN_IDX, arg);
      else
	sim_io_eprintf (sd, "Instruction tracing not compiled in, `--trace-insn' ignored\n");
      break;

    case OPTION_TRACE_DECODE :
      if (WITH_TRACE_DECODE_P)
	return set_trace_option (sd, "-decode", TRACE_DECODE_IDX, arg);
      else
	sim_io_eprintf (sd, "Decode tracing not compiled in, `--trace-decode' ignored\n");
      break;

    case OPTION_TRACE_EXTRACT :
      if (WITH_TRACE_EXTRACT_P)
	return set_trace_option (sd, "-extract", TRACE_EXTRACT_IDX, arg);
      else
	sim_io_eprintf (sd, "Extract tracing not compiled in, `--trace-extract' ignored\n");
      break;

    case OPTION_TRACE_LINENUM :
      if (WITH_TRACE_LINENUM_P && WITH_TRACE_INSN_P)
	{
	  if (set_trace_option (sd, "-linenum", TRACE_LINENUM_IDX, arg) != SIM_RC_OK
	      || set_trace_option (sd, "-linenum", TRACE_INSN_IDX, arg) != SIM_RC_OK)
	    return SIM_RC_FAIL;
	}
      else
	sim_io_eprintf (sd, "Line number or instruction tracing not compiled in, `--trace-linenum' ignored\n");
      break;

    case OPTION_TRACE_MEMORY :
      if (WITH_TRACE_MEMORY_P)
	return set_trace_option (sd, "-memory", TRACE_MEMORY_IDX, arg);
      else
	sim_io_eprintf (sd, "Memory tracing not compiled in, `--trace-memory' ignored\n");
      break;

    case OPTION_TRACE_MODEL :
      if (WITH_TRACE_MODEL_P)
	return set_trace_option (sd, "-model", TRACE_MODEL_IDX, arg);
      else
	sim_io_eprintf (sd, "Model tracing not compiled in, `--trace-model' ignored\n");
      break;

    case OPTION_TRACE_ALU :
      if (WITH_TRACE_ALU_P)
	return set_trace_option (sd, "-alu", TRACE_ALU_IDX, arg);
      else
	sim_io_eprintf (sd, "ALU tracing not compiled in, `--trace-alu' ignored\n");
      break;

    case OPTION_TRACE_CORE :
      if (WITH_TRACE_CORE_P)
	return set_trace_option (sd, "-core", TRACE_CORE_IDX, arg);
      else
	sim_io_eprintf (sd, "CORE tracing not compiled in, `--trace-core' ignored\n");
      break;

    case OPTION_TRACE_EVENTS :
      if (WITH_TRACE_EVENTS_P)
	return set_trace_option (sd, "-events", TRACE_EVENTS_IDX, arg);
      else
	sim_io_eprintf (sd, "EVENTS tracing not compiled in, `--trace-events' ignored\n");
      break;

    case OPTION_TRACE_FPU :
      if (WITH_TRACE_FPU_P)
	return set_trace_option (sd, "-fpu", TRACE_FPU_IDX, arg);
      else
	sim_io_eprintf (sd, "FPU tracing not compiled in, `--trace-fpu' ignored\n");
      break;

    case OPTION_TRACE_VPU :
      if (WITH_TRACE_VPU_P)
	return set_trace_option (sd, "-vpu", TRACE_VPU_IDX, arg);
      else
	sim_io_eprintf (sd, "VPU tracing not compiled in, `--trace-vpu' ignored\n");
      break;

    case OPTION_TRACE_BRANCH :
      if (WITH_TRACE_BRANCH_P)
	return set_trace_option (sd, "-branch", TRACE_BRANCH_IDX, arg);
      else
	sim_io_eprintf (sd, "Branch tracing not compiled in, `--trace-branch' ignored\n");
      break;

    case OPTION_TRACE_SYSCALL :
      if (WITH_TRACE_SYSCALL_P)
	return set_trace_option (sd, "-syscall", TRACE_SYSCALL_IDX, arg);
      else
	sim_io_eprintf (sd, "System call tracing not compiled in, `--trace-syscall' ignored\n");
      break;

    case OPTION_TRACE_SEMANTICS :
      if (WITH_TRACE_ALU_P
	  && WITH_TRACE_FPU_P
	  && WITH_TRACE_MEMORY_P
	  && WITH_TRACE_BRANCH_P)
	{
	  if (set_trace_option (sd, "-semantics", TRACE_ALU_IDX, arg) != SIM_RC_OK
	      || set_trace_option (sd, "-semantics", TRACE_FPU_IDX, arg) != SIM_RC_OK
	      || set_trace_option (sd, "-semantics", TRACE_VPU_IDX, arg) != SIM_RC_OK
	      || set_trace_option (sd, "-semantics", TRACE_MEMORY_IDX, arg) != SIM_RC_OK
	      || set_trace_option (sd, "-semantics", TRACE_BRANCH_IDX, arg) != SIM_RC_OK)
	    return SIM_RC_FAIL;
	}
      else
	sim_io_eprintf (sd, "Alu, fpu, memory, and/or branch tracing not compiled in, `--trace-semantics' ignored\n");
      break;

#ifdef SIM_HAVE_ADDR_RANGE
    case OPTION_TRACE_RANGE :
      if (WITH_TRACE)
	{
	  int cpu_nr;
	  char *chp = arg;
	  unsigned long start,end;
	  start = strtoul (chp, &chp, 0);
	  if (*chp != ',')
	    {
	      sim_io_eprintf (sd, "--trace-range missing END argument\n");
	      return SIM_RC_FAIL;
	    }
	  end = strtoul (chp + 1, NULL, 0);
	  /* FIXME: Argument validation.  */
	  if (cpu != NULL)
	    sim_addr_range_add (TRACE_RANGE (CPU_PROFILE_DATA (cpu)),
				start, end);
	  else
	    for (cpu_nr = 0; cpu_nr < MAX_NR_PROCESSORS; ++cpu_nr)
	      sim_addr_range_add (TRACE_RANGE (CPU_TRACE_DATA (STATE_CPU (sd, cpu_nr))),
				  start, end);
	}
      else
	sim_io_eprintf (sd, "Tracing not compiled in, `--trace-range' ignored\n");
      break;

    case OPTION_TRACE_FUNCTION :
      if (WITH_TRACE)
	{
	  /*wip: need to compute function range given name*/
	}
      else
	sim_io_eprintf (sd, "Tracing not compiled in, `--trace-function' ignored\n");
      break;
#endif /* SIM_HAVE_ADDR_RANGE */

    case OPTION_TRACE_DEBUG :
      if (WITH_TRACE_DEBUG_P)
	return set_trace_option (sd, "-debug", TRACE_DEBUG_IDX, arg);
      else
	sim_io_eprintf (sd, "Tracing debug support not compiled in, `--trace-debug' ignored\n");
      break;

    case OPTION_TRACE_FILE :
      if (! WITH_TRACE)
	sim_io_eprintf (sd, "Tracing not compiled in, `--trace-file' ignored\n");
      else
	{
	  FILE *f = fopen (arg, "w");

	  if (f == NULL)
	    {
	      sim_io_eprintf (sd, "Unable to open trace output file `%s'\n", arg);
	      return SIM_RC_FAIL;
	    }
	  for (n = 0; n < MAX_NR_PROCESSORS; ++n)
	    TRACE_FILE (CPU_TRACE_DATA (STATE_CPU (sd, n))) = f;
	  TRACE_FILE (STATE_TRACE_DATA (sd)) = f;
	}
      break;
    }

  return SIM_RC_OK;
}

/* Install tracing support.  */

SIM_RC
trace_install (SIM_DESC sd)
{
  int i;

  SIM_ASSERT (STATE_MAGIC (sd) == SIM_MAGIC_NUMBER);

  sim_add_option_table (sd, NULL, trace_options);
  memset (STATE_TRACE_DATA (sd), 0, sizeof (* STATE_TRACE_DATA (sd)));
  for (i = 0; i < MAX_NR_PROCESSORS; ++i)
    memset (CPU_TRACE_DATA (STATE_CPU (sd, i)), 0,
	    sizeof (* CPU_TRACE_DATA (STATE_CPU (sd, i))));
  sim_module_add_init_fn (sd, trace_init);
  sim_module_add_uninstall_fn (sd, trace_uninstall);
  return SIM_RC_OK;
}

static SIM_RC
trace_init (SIM_DESC sd)
{
#ifdef SIM_HAVE_ADDR_RANGE
  /* Check if a range has been specified without specifying what to
     collect.  */
  {
    int i;

    for (i = 0; i < MAX_NR_PROCESSORS; ++i)
      {
	sim_cpu *cpu = STATE_CPU (sd, i);

	if (ADDR_RANGE_RANGES (TRACE_RANGE (CPU_TRACE_DATA (cpu)))
	    && ! TRACE_INSN_P (cpu))
	  {
	    sim_io_eprintf_cpu (cpu, "Tracing address range specified without --trace-insn.\n");
	    sim_io_eprintf_cpu (cpu, "Address range ignored.\n");
	    sim_addr_range_delete (TRACE_RANGE (CPU_TRACE_DATA (cpu)),
				   0, ~ (address_word) 0);
	  }
      }
  }
#endif

  return SIM_RC_OK;
}

static void
trace_uninstall (SIM_DESC sd)
{
  int i,j;
  FILE *sfile = TRACE_FILE (STATE_TRACE_DATA (sd));

  if (sfile != NULL)
    fclose (sfile);

  for (i = 0; i < MAX_NR_PROCESSORS; ++i)
    {
      FILE *cfile = TRACE_FILE (CPU_TRACE_DATA (STATE_CPU (sd, i)));
      if (cfile != NULL && cfile != sfile)
	{
	  /* If output from different cpus is going to the same file,
	     avoid closing the file twice.  */
	  for (j = 0; j < i; ++j)
	    if (TRACE_FILE (CPU_TRACE_DATA (STATE_CPU (sd, j))) == cfile)
	      break;
	  if (i == j)
	    fclose (cfile);
	}
    }
}

/* compute the nr of trace data units consumed by data */
static int
save_data_size (TRACE_DATA *data,
		long size)
{
  return ((size + sizeof (TRACE_INPUT_DATA (data) [0]) - 1)
	  / sizeof (TRACE_INPUT_DATA (data) [0]));
}


/* Archive DATA into the trace buffer */
void
save_data (SIM_DESC sd,
	   TRACE_DATA *data,
	   data_fmt fmt,
	   long size,
	   const void *buf)
{
  int i = TRACE_INPUT_IDX (data);
  if (i == sizeof (TRACE_INPUT_FMT (data)))
    sim_io_error (sd, "trace buffer overflow");
  TRACE_INPUT_FMT (data) [i] = fmt;
  TRACE_INPUT_SIZE (data) [i] = size;
  memcpy (&TRACE_INPUT_DATA (data) [i], buf, size);
  i += save_data_size (data, size);
  TRACE_INPUT_IDX (data) = i;
}

static void
print_data (SIM_DESC sd,
	    sim_cpu *cpu,
	    data_fmt fmt,
	    long size,
	    void *data)
{
  switch (fmt)
    {
    case trace_fmt_instruction_incomplete:
      trace_printf (sd, cpu, " (instruction incomplete)");
      break;
    case trace_fmt_word:
    case trace_fmt_addr:
      {
	switch (size)
	  {
	  case sizeof (unsigned32):
	    trace_printf (sd, cpu, " 0x%08lx", (long) * (unsigned32*) data);
	    break;
	  case sizeof (unsigned64):
	    trace_printf (sd, cpu, " 0x%08lx%08lx",
			  (long) ((* (unsigned64*) data) >> 32),
			  (long) * (unsigned64*) data);
	    break;
	  default:
	    abort ();
	  }
	break;
      }
    case trace_fmt_bool:
      {
	SIM_ASSERT (size == sizeof (int));
	trace_printf (sd, cpu, " %-8s",
		      (* (int*) data) ? "true" : "false");
	break;
      }
    case trace_fmt_fp:
      {
	sim_fpu fp;
	switch (size)
	  {
	    /* FIXME: Assumes sizeof float == 4; sizeof double == 8 */
	  case 4:
	    sim_fpu_32to (&fp, *(unsigned32*)data);
	    break;
	  case 8:
	    sim_fpu_64to (&fp, *(unsigned64*)data);
	    break;
	  default:
	    abort ();
	  }
	trace_printf (sd, cpu, " %8g", sim_fpu_2d (&fp));
	switch (size)
	  {
	  case 4:
	    trace_printf (sd, cpu, " (0x%08lx)",
			  (long) *(unsigned32*)data);
	    break;
	  case 8:
	    trace_printf (sd, cpu, " (0x%08lx%08lx)",
			  (long) (*(unsigned64*)data >> 32),
			  (long) (*(unsigned64*)data));
	    break;
	  default:
	    abort ();
	  }
	break;
      }
    case trace_fmt_fpu:
      /* FIXME: At present sim_fpu data is stored as a double */
      trace_printf (sd, cpu, " %8g", * (double*) data);
      break;
    case trace_fmt_string:
      trace_printf (sd, cpu, " %-8s", (char*) data);
      break;
    default:
      abort ();
    }
}

static const char *
trace_idx_to_str (int trace_idx)
{
  static char num[8];
  switch (trace_idx)
    {
    case TRACE_ALU_IDX:     return "alu:     ";
    case TRACE_INSN_IDX:    return "insn:    ";
    case TRACE_DECODE_IDX:  return "decode:  ";
    case TRACE_EXTRACT_IDX: return "extract: ";
    case TRACE_MEMORY_IDX:  return "memory:  ";
    case TRACE_CORE_IDX:    return "core:    ";
    case TRACE_EVENTS_IDX:  return "events:  ";
    case TRACE_FPU_IDX:     return "fpu:     ";
    case TRACE_BRANCH_IDX:  return "branch:  ";
    case TRACE_SYSCALL_IDX: return "syscall: ";
    case TRACE_VPU_IDX:     return "vpu:     ";
    default:
      sprintf (num, "?%d?", trace_idx);
      return num;
    }
}

static void
trace_results (SIM_DESC sd,
	       sim_cpu *cpu,
	       int trace_idx,
	       int last_input)
{
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  int nr_out;
  int i;

  /* cross check trace_idx against TRACE_IDX (data)? */

  /* prefix */
  trace_printf (sd, cpu, "%s %s",
		trace_idx_to_str (TRACE_IDX (data)),
		TRACE_PREFIX (data));
  TRACE_IDX (data) = 0;

  for (i = 0, nr_out = 0;
       i < TRACE_INPUT_IDX (data);
       i += save_data_size (data, TRACE_INPUT_SIZE (data) [i]), nr_out++)
    {
      if (i == last_input)
	{
	  int pad = (strlen (" 0x") + sizeof (unsigned_word) * 2);
	  int padding = pad * (3 - nr_out);
	  if (padding < 0)
	    padding = 0;
	  padding += strlen (" ::");
	  trace_printf (sd, cpu, "%*s", padding, " ::");
	}
      print_data (sd, cpu,
		  TRACE_INPUT_FMT (data) [i],
		  TRACE_INPUT_SIZE (data) [i],
		  &TRACE_INPUT_DATA (data) [i]);
    }
  trace_printf (sd, cpu, "\n");
}

void
trace_prefix (SIM_DESC sd,
	      sim_cpu *cpu,
	      sim_cia cia,
	      address_word pc,
	      int line_p,
	      const char *filename,
	      int linenum,
	      const char *fmt,
	      ...)
{
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  va_list ap;
  char *prefix = TRACE_PREFIX (data);
  char *chp;
 /* FIXME: The TRACE_PREFIX_WIDTH should be determined at build time using
    known information about the disassembled instructions. */
#ifndef TRACE_PREFIX_WIDTH
#define TRACE_PREFIX_WIDTH 48
#endif
  int width = TRACE_PREFIX_WIDTH;

  /* if the previous trace data wasn't flushed, flush it now with a
     note indicating that the trace was incomplete. */
  if (TRACE_IDX (data) != 0)
    {
      int last_input = TRACE_INPUT_IDX (data);
      save_data (sd, data, trace_fmt_instruction_incomplete, 1, "");
      trace_results (sd, cpu, TRACE_IDX (data), last_input);
    }
  TRACE_IDX (data) = 0;
  TRACE_INPUT_IDX (data) = 0;

  /* Create the text prefix for this new instruction: */
  if (!line_p)
    {
      if (filename)
	{
	  sprintf (prefix, "%s:%-*d 0x%.*lx ",
		   filename,
		   SIZE_LINE_NUMBER, linenum,
		   SIZE_PC, (long) pc);
	}
      else
	{
	  sprintf (prefix, "0x%.*lx ",
		   SIZE_PC, (long) pc);
	  /* Shrink the width by the amount that we didn't print.  */
	  width -= SIZE_LINE_NUMBER + SIZE_PC + 8;
	}
      chp = strchr (prefix, '\0');
      va_start (ap, fmt);
      vsprintf (chp, fmt, ap);
      va_end (ap);
    }
  else
    {
      char buf[256];
      buf[0] = 0;
      if (STATE_TEXT_SECTION (CPU_STATE (cpu))
	  && pc >= STATE_TEXT_START (CPU_STATE (cpu))
	  && pc < STATE_TEXT_END (CPU_STATE (cpu)))
	{
	  const char *pc_filename = (const char *)0;
	  const char *pc_function = (const char *)0;
	  unsigned int pc_linenum = 0;
	  bfd *abfd;
	  asymbol **asymbols;

	  abfd = STATE_PROG_BFD (CPU_STATE (cpu));
	  asymbols = STATE_PROG_SYMS (CPU_STATE (cpu));
	  if (asymbols == NULL)
	    {
	      long symsize;
	      long symbol_count;

	      symsize = bfd_get_symtab_upper_bound (abfd);
	      if (symsize < 0)
		{
		  sim_engine_abort (sd, cpu, cia, "could not read symbols");
		}
	      asymbols = (asymbol **) xmalloc (symsize);
	      symbol_count = bfd_canonicalize_symtab (abfd, asymbols);
	      if (symbol_count < 0)
		{
		  sim_engine_abort (sd, cpu, cia, "could not canonicalize symbols");
		}
	      STATE_PROG_SYMS (CPU_STATE (cpu)) = asymbols;
	    }

	  if (bfd_find_nearest_line (abfd,
				     STATE_TEXT_SECTION (CPU_STATE (cpu)),
				     asymbols,
				     pc - STATE_TEXT_START (CPU_STATE (cpu)),
				     &pc_filename, &pc_function, &pc_linenum))
	    {
	      char *p = buf;
	      if (pc_linenum)
		{
		  sprintf (p, "#%-*d ", SIZE_LINE_NUMBER, pc_linenum);
		  p += strlen (p);
		}
	      else
		{
		  sprintf (p, "%-*s ", SIZE_LINE_NUMBER+1, "---");
		  p += SIZE_LINE_NUMBER+2;
		}

	      if (pc_function)
		{
		  sprintf (p, "%s ", pc_function);
		  p += strlen (p);
		}
	      else if (pc_filename)
		{
		  char *q = (char *) strrchr (pc_filename, '/');
		  sprintf (p, "%s ", (q) ? q+1 : pc_filename);
		  p += strlen (p);
		}

	      if (*p == ' ')
		*p = '\0';
	    }
	}

      sprintf (prefix, "0x%.*x %-*.*s ",
	       SIZE_PC, (unsigned) pc,
	       SIZE_LOCATION, SIZE_LOCATION, buf);
      chp = strchr (prefix, '\0');
      va_start (ap, fmt);
      vsprintf (chp, fmt, ap);
      va_end (ap);
    }

  /* Pad it out to TRACE_PREFIX_WIDTH.  */
  chp = strchr (prefix, '\0');
  if (chp - prefix < width)
    {
      memset (chp, ' ', width - (chp - prefix));
      chp = &prefix [width];
      *chp = '\0';
    }
  strcpy (chp, " -");

  /* check that we've not over flowed the prefix buffer */
  if (strlen (prefix) >= sizeof (TRACE_PREFIX (data)))
    abort ();
}

void
trace_generic (SIM_DESC sd,
	       sim_cpu *cpu,
	       int trace_idx,
	       const char *fmt,
	       ...)
{
  va_list ap;
  trace_printf (sd, cpu, "%s %s",
		trace_idx_to_str (trace_idx),
		TRACE_PREFIX (CPU_TRACE_DATA (cpu)));
  va_start (ap, fmt);
  trace_vprintf (sd, cpu, fmt, ap);
  va_end (ap);
  trace_printf (sd, cpu, "\n");
}

void
trace_input0 (SIM_DESC sd,
	      sim_cpu *cpu,
	      int trace_idx)
{
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  TRACE_IDX (data) = trace_idx;
}

void
trace_input_word1 (SIM_DESC sd,
		   sim_cpu *cpu,
		   int trace_idx,
		   unsigned_word d0)
{
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  TRACE_IDX (data) = trace_idx;
  save_data (sd, data, trace_fmt_word, sizeof (unsigned_word), &d0);
}

void
trace_input_word2 (SIM_DESC sd,
		   sim_cpu *cpu,
		   int trace_idx,
		   unsigned_word d0,
		   unsigned_word d1)
{
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  TRACE_IDX (data) = trace_idx;
  save_data (sd, data, trace_fmt_word, sizeof (unsigned_word), &d0);
  save_data (sd, data, trace_fmt_word, sizeof (unsigned_word), &d1);
}

void
trace_input_word3 (SIM_DESC sd,
		   sim_cpu *cpu,
		   int trace_idx,
		   unsigned_word d0,
		   unsigned_word d1,
		   unsigned_word d2)
{
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  TRACE_IDX (data) = trace_idx;
  save_data (sd, data, trace_fmt_word, sizeof (unsigned_word), &d0);
  save_data (sd, data, trace_fmt_word, sizeof (unsigned_word), &d1);
  save_data (sd, data, trace_fmt_word, sizeof (unsigned_word), &d2);
}

void
trace_input_word4 (SIM_DESC sd,
		   sim_cpu *cpu,
		   int trace_idx,
		   unsigned_word d0,
		   unsigned_word d1,
		   unsigned_word d2,
		   unsigned_word d3)
{
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  TRACE_IDX (data) = trace_idx;
  save_data (sd, data, trace_fmt_word, sizeof (d0), &d0);
  save_data (sd, data, trace_fmt_word, sizeof (d1), &d1);
  save_data (sd, data, trace_fmt_word, sizeof (d2), &d2);
  save_data (sd, data, trace_fmt_word, sizeof (d3), &d3);
}

void
trace_input_bool1 (SIM_DESC sd,
		   sim_cpu *cpu,
		   int trace_idx,
		   int d0)
{
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  TRACE_IDX (data) = trace_idx;
  save_data (sd, data, trace_fmt_bool, sizeof (d0), &d0);
}

void
trace_input_addr1 (SIM_DESC sd,
		   sim_cpu *cpu,
		   int trace_idx,
		   address_word d0)
{
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  TRACE_IDX (data) = trace_idx;
  save_data (sd, data, trace_fmt_addr, sizeof (d0), &d0);
}

void
trace_input_fp1 (SIM_DESC sd,
		 sim_cpu *cpu,
		 int trace_idx,
		 fp_word f0)
{
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  TRACE_IDX (data) = trace_idx;
  save_data (sd, data, trace_fmt_fp, sizeof (fp_word), &f0);
}

void
trace_input_fp2 (SIM_DESC sd,
		 sim_cpu *cpu,
		 int trace_idx,
		 fp_word f0,
		 fp_word f1)
{
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  TRACE_IDX (data) = trace_idx;
  save_data (sd, data, trace_fmt_fp, sizeof (fp_word), &f0);
  save_data (sd, data, trace_fmt_fp, sizeof (fp_word), &f1);
}

void
trace_input_fp3 (SIM_DESC sd,
		 sim_cpu *cpu,
		 int trace_idx,
		 fp_word f0,
		 fp_word f1,
		 fp_word f2)
{
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  TRACE_IDX (data) = trace_idx;
  save_data (sd, data, trace_fmt_fp, sizeof (fp_word), &f0);
  save_data (sd, data, trace_fmt_fp, sizeof (fp_word), &f1);
  save_data (sd, data, trace_fmt_fp, sizeof (fp_word), &f2);
}

void
trace_input_fpu1 (SIM_DESC sd,
		  sim_cpu *cpu,
		  int trace_idx,
		  sim_fpu *f0)
{
  double d;
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  TRACE_IDX (data) = trace_idx;
  d = sim_fpu_2d (f0);
  save_data (sd, data, trace_fmt_fp, sizeof (double), &d);
}

void
trace_input_fpu2 (SIM_DESC sd,
		  sim_cpu *cpu,
		  int trace_idx,
		  sim_fpu *f0,
		  sim_fpu *f1)
{
  double d;
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  TRACE_IDX (data) = trace_idx;
  d = sim_fpu_2d (f0);
  save_data (sd, data, trace_fmt_fp, sizeof (double), &d);
  d = sim_fpu_2d (f1);
  save_data (sd, data, trace_fmt_fp, sizeof (double), &d);
}

void
trace_input_fpu3 (SIM_DESC sd,
		  sim_cpu *cpu,
		  int trace_idx,
		  sim_fpu *f0,
		  sim_fpu *f1,
		  sim_fpu *f2)
{
  double d;
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  TRACE_IDX (data) = trace_idx;
  d = sim_fpu_2d (f0);
  save_data (sd, data, trace_fmt_fp, sizeof (double), &d);
  d = sim_fpu_2d (f1);
  save_data (sd, data, trace_fmt_fp, sizeof (double), &d);
  d = sim_fpu_2d (f2);
  save_data (sd, data, trace_fmt_fp, sizeof (double), &d);
}

void
trace_result_word1 (SIM_DESC sd,
		    sim_cpu *cpu,
		    int trace_idx,
		    unsigned_word r0)
{
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  int last_input;

  /* Append any results to the end of the inputs */
  last_input = TRACE_INPUT_IDX (data);
  save_data (sd, data, trace_fmt_word, sizeof (unsigned_word), &r0);

  trace_results (sd, cpu, trace_idx, last_input);
}

void
trace_result0 (SIM_DESC sd,
	       sim_cpu *cpu,
	       int trace_idx)
{
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  int last_input;

  /* Append any results to the end of the inputs */
  last_input = TRACE_INPUT_IDX (data);

  trace_results (sd, cpu, trace_idx, last_input);
}

void
trace_result_word2 (SIM_DESC sd,
		    sim_cpu *cpu,
		    int trace_idx,
		    unsigned_word r0,
		    unsigned_word r1)
{
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  int last_input;

  /* Append any results to the end of the inputs */
  last_input = TRACE_INPUT_IDX (data);
  save_data (sd, data, trace_fmt_word, sizeof (r0), &r0);
  save_data (sd, data, trace_fmt_word, sizeof (r1), &r1);

  trace_results (sd, cpu, trace_idx, last_input);
}

void
trace_result_word4 (SIM_DESC sd,
		    sim_cpu *cpu,
		    int trace_idx,
		    unsigned_word r0,
		    unsigned_word r1,
		    unsigned_word r2,
		    unsigned_word r3)
{
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  int last_input;

  /* Append any results to the end of the inputs */
  last_input = TRACE_INPUT_IDX (data);
  save_data (sd, data, trace_fmt_word, sizeof (r0), &r0);
  save_data (sd, data, trace_fmt_word, sizeof (r1), &r1);
  save_data (sd, data, trace_fmt_word, sizeof (r2), &r2);
  save_data (sd, data, trace_fmt_word, sizeof (r3), &r3);

  trace_results (sd, cpu, trace_idx, last_input);
}

void
trace_result_bool1 (SIM_DESC sd,
		    sim_cpu *cpu,
		    int trace_idx,
		    int r0)
{
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  int last_input;

  /* Append any results to the end of the inputs */
  last_input = TRACE_INPUT_IDX (data);
  save_data (sd, data, trace_fmt_bool, sizeof (r0), &r0);

  trace_results (sd, cpu, trace_idx, last_input);
}

void
trace_result_addr1 (SIM_DESC sd,
		    sim_cpu *cpu,
		    int trace_idx,
		    address_word r0)
{
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  int last_input;

  /* Append any results to the end of the inputs */
  last_input = TRACE_INPUT_IDX (data);
  save_data (sd, data, trace_fmt_addr, sizeof (r0), &r0);

  trace_results (sd, cpu, trace_idx, last_input);
}

void
trace_result_fp1 (SIM_DESC sd,
		  sim_cpu *cpu,
		  int trace_idx,
		  fp_word f0)
{
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  int last_input;

  /* Append any results to the end of the inputs */
  last_input = TRACE_INPUT_IDX (data);
  save_data (sd, data, trace_fmt_fp, sizeof (fp_word), &f0);

  trace_results (sd, cpu, trace_idx, last_input);
}

void
trace_result_fp2 (SIM_DESC sd,
		  sim_cpu *cpu,
		  int trace_idx,
		  fp_word f0,
		  fp_word f1)
{
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  int last_input;

  /* Append any results to the end of the inputs */
  last_input = TRACE_INPUT_IDX (data);
  save_data (sd, data, trace_fmt_fp, sizeof (f0), &f0);
  save_data (sd, data, trace_fmt_fp, sizeof (f1), &f1);

  trace_results (sd, cpu, trace_idx, last_input);
}

void
trace_result_fpu1 (SIM_DESC sd,
		   sim_cpu *cpu,
		   int trace_idx,
		   sim_fpu *f0)
{
  double d;
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  int last_input;

  /* Append any results to the end of the inputs */
  last_input = TRACE_INPUT_IDX (data);
  d = sim_fpu_2d (f0);
  save_data (sd, data, trace_fmt_fp, sizeof (double), &d);

  trace_results (sd, cpu, trace_idx, last_input);
}

void
trace_result_string1 (SIM_DESC sd,
		      sim_cpu *cpu,
		      int trace_idx,
		      char *s0)
{
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  int last_input;

  /* Append any results to the end of the inputs */
  last_input = TRACE_INPUT_IDX (data);
  save_data (sd, data, trace_fmt_string, strlen (s0) + 1, s0);

  trace_results (sd, cpu, trace_idx, last_input);
}

void
trace_result_word1_string1 (SIM_DESC sd,
			    sim_cpu *cpu,
			    int trace_idx,
			    unsigned_word r0,
			    char *s0)
{
  TRACE_DATA *data = CPU_TRACE_DATA (cpu);
  int last_input;

  /* Append any results to the end of the inputs */
  last_input = TRACE_INPUT_IDX (data);
  save_data (sd, data, trace_fmt_word, sizeof (unsigned_word), &r0);
  save_data (sd, data, trace_fmt_string, strlen (s0) + 1, s0);

  trace_results (sd, cpu, trace_idx, last_input);
}

void
trace_vprintf (SIM_DESC sd, sim_cpu *cpu, const char *fmt, va_list ap)
{
  if (cpu != NULL)
    {
      if (TRACE_FILE (CPU_TRACE_DATA (cpu)) != NULL)
	vfprintf (TRACE_FILE (CPU_TRACE_DATA (cpu)), fmt, ap);
      else
	sim_io_evprintf (sd, fmt, ap);
    }
  else
    {
      if (TRACE_FILE (STATE_TRACE_DATA (sd)) != NULL)
	vfprintf (TRACE_FILE (STATE_TRACE_DATA (sd)), fmt, ap);
      else
	sim_io_evprintf (sd, fmt, ap);
    }
}

/* The function trace_one_insn has been replaced by the function pair
   trace_prefix() + trace_generic().  It is still used. */
void
trace_one_insn (SIM_DESC sd, sim_cpu *cpu, address_word pc,
		int line_p, const char *filename, int linenum,
		const char *phase_wo_colon, const char *fmt,
		...)
{
  va_list ap;
  char phase[SIZE_PHASE+2];

  strncpy (phase, phase_wo_colon, SIZE_PHASE);
  strcat (phase, ":");

  if (!line_p)
    {
      trace_printf (sd, cpu, "%-*s %s:%-*d 0x%.*lx ",
		    SIZE_PHASE+1, phase,
		    filename,
		    SIZE_LINE_NUMBER, linenum,
		    SIZE_PC, (long)pc);
      va_start (ap, fmt);
      trace_vprintf (sd, cpu, fmt, ap);
      va_end (ap);
      trace_printf (sd, cpu, "\n");
    }
  else
    {
      char buf[256];

      buf[0] = 0;
      if (STATE_TEXT_SECTION (CPU_STATE (cpu))
	  && pc >= STATE_TEXT_START (CPU_STATE (cpu))
	  && pc < STATE_TEXT_END (CPU_STATE (cpu)))
	{
	  const char *pc_filename = (const char *)0;
	  const char *pc_function = (const char *)0;
	  unsigned int pc_linenum = 0;

	  if (bfd_find_nearest_line (STATE_PROG_BFD (CPU_STATE (cpu)),
				     STATE_TEXT_SECTION (CPU_STATE (cpu)),
				     (struct bfd_symbol **) 0,
				     pc - STATE_TEXT_START (CPU_STATE (cpu)),
				     &pc_filename, &pc_function, &pc_linenum))
	    {
	      char *p = buf;
	      if (pc_linenum)
		{
		  sprintf (p, "#%-*d ", SIZE_LINE_NUMBER, pc_linenum);
		  p += strlen (p);
		}
	      else
		{
		  sprintf (p, "%-*s ", SIZE_LINE_NUMBER+1, "---");
		  p += SIZE_LINE_NUMBER+2;
		}

	      if (pc_function)
		{
		  sprintf (p, "%s ", pc_function);
		  p += strlen (p);
		}
	      else if (pc_filename)
		{
		  char *q = (char *) strrchr (pc_filename, '/');
		  sprintf (p, "%s ", (q) ? q+1 : pc_filename);
		  p += strlen (p);
		}

	      if (*p == ' ')
		*p = '\0';
	    }
	}

      trace_printf (sd, cpu, "%-*s 0x%.*x %-*.*s ",
		    SIZE_PHASE+1, phase,
		    SIZE_PC, (unsigned) pc,
		    SIZE_LOCATION, SIZE_LOCATION, buf);
      va_start (ap, fmt);
      trace_vprintf (sd, cpu, fmt, ap);
      va_end (ap);
      trace_printf (sd, cpu, "\n");
    }
}

void
trace_printf VPARAMS ((SIM_DESC sd, sim_cpu *cpu, const char *fmt, ...))
{
#if !defined __STDC__ && !defined ALMOST_STDC
  SIM_DESC sd;
  sim_cpu *cpu;
  const char *fmt;
#endif
  va_list ap;

  VA_START (ap, fmt);
#if !defined __STDC__ && !defined ALMOST_STDC
  sd = va_arg (ap, SIM_DESC);
  cpu = va_arg (ap, sim_cpu *);
  fmt = va_arg (ap, const char *);
#endif

  trace_vprintf (sd, cpu, fmt, ap);

  va_end (ap);
}

void
debug_printf VPARAMS ((sim_cpu *cpu, const char *fmt, ...))
{
#if !defined __STDC__ && !defined ALMOST_STDC
  sim_cpu *cpu;
  const char *fmt;
#endif
  va_list ap;

  VA_START (ap, fmt);
#if !defined __STDC__ && !defined ALMOST_STDC
  cpu = va_arg (ap, sim_cpu *);
  fmt = va_arg (ap, const char *);
#endif

  if (CPU_DEBUG_FILE (cpu) == NULL)
    (* STATE_CALLBACK (CPU_STATE (cpu))->evprintf_filtered)
      (STATE_CALLBACK (CPU_STATE (cpu)), fmt, ap);
  else
    vfprintf (CPU_DEBUG_FILE (cpu), fmt, ap);

  va_end (ap);
}
@


1.17
log
@Commit gdb and sim support for v850e2 and v850e2v3 on behalf of
Rathish C <Rathish.C@@kpitcummins.com>.
@
text
@d2 1
a2 2
   Copyright (C) 1997-1998, 2001, 2007-2012 Free Software Foundation,
   Inc.
@


1.16
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@a499 11
typedef enum {
  trace_fmt_invalid,
  trace_fmt_word,
  trace_fmt_fp,
  trace_fmt_fpu,
  trace_fmt_string,
  trace_fmt_bool,
  trace_fmt_addr,
  trace_fmt_instruction_incomplete,
} data_fmt;

d511 1
a511 1
static void
@


1.15
log
@sim: add syscall tracing level

It's useful to be able to trace just the system calls the simulated
program is calling, so add a new --trace-syscall option for ports to
leverage if they choose.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d2 2
a3 2
   Copyright (C) 1997, 1998, 2001, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.15.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 2
   Copyright (C) 1997-1998, 2001, 2007-2012 Free Software Foundation,
   Inc.
@


1.14
log
@sim: common: trim trailing whitespace
@
text
@d80 2
a81 1
  OPTION_TRACE_VPU
d129 3
d338 7
d635 1
@


1.13
log
@run copyright.sh for 2011.
@
text
@d217 1
a217 1
    }  
d608 1
a608 1
		  
d1024 1
a1024 1
}	      
d1038 1
a1038 1
}	      
d1056 1
a1056 1
}	      
d1078 1
a1078 1
}	      
d1094 1
a1094 1
}	      
d1110 1
a1110 1
}	      
d1126 1
a1126 1
}	      
d1144 1
a1144 1
}	      
d1162 1
a1162 1
}	      
d1178 1
a1178 1
}	      
d1196 1
a1196 1
}	      
@


1.12
log
@sim: add missing values to array initializers

The sim code has a lot of static initializer for options and devices, but
since they aren't using newer struct style, they have to specify a value
for every option otherwise gcc spits a lot of warnings about "missing
initializer".  So add NULL/0 stubs for pointers/values.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d2 1
a2 1
   Copyright (C) 1997, 1998, 2001, 2007, 2008, 2009, 2010
@


1.11
log
@sim: constify save_data()

The local save_data() function takes a pointer to a buffer and only uses it as
the source to the memcpy() function.  Since it is given const strings, GCC
likes to spit out warnings:
common/sim-trace.c: In function 'trace_prefix':
common/sim-trace.c:697: warning: passing argument 5 of 'save_data' discards
	qualifiers from pointer target type

So I've committed this as obvious.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d88 1
a88 1
      trace_option_handler },
d91 1
a91 1
      trace_option_handler },
d94 1
a94 1
      trace_option_handler },
d97 1
a97 1
      trace_option_handler },
d100 1
a100 1
      trace_option_handler },
d103 1
a103 1
      trace_option_handler },
d106 1
a106 1
      trace_option_handler },
d109 1
a109 1
      trace_option_handler },
d112 1
a112 1
      trace_option_handler },
d115 1
a115 1
      trace_option_handler },
d118 1
a118 1
      trace_option_handler },
d121 1
a121 1
      trace_option_handler },
d124 1
a124 1
      trace_option_handler },
d127 1
a127 1
      trace_option_handler },
d131 1
a131 1
      trace_option_handler },
d135 1
a135 1
      trace_option_handler },
d140 1
a140 1
      trace_option_handler },
d143 2
a144 2
      trace_option_handler },
  { {NULL, no_argument, NULL, 0}, '\0', NULL, NULL, NULL }
@


1.10
log
@sim: fix unused cpu_nr warnings

The trace_option_handler() function only uses cpu_nr when the
SIM_HAVE_ADDR_RANGE define is enabled.  So move the decl down
to where the code exists.  Otherwise GCC warns:
sim-trace.c: In function 'trace_option_handler':
sim-trace.c:236: warning: unused variable 'cpu_nr'
@
text
@d516 1
a516 1
	   void *buf)
@


1.9
log
@sim: convert old style function definitions

GCC currently emits warnings like:
nrun.c: In function 'usage':
nrun.c:223: warning: old-style function definition
@
text
@a235 1
  int cpu_nr;
d355 1
@


1.8
log
@Update copyright notices to add year 2010.
@
text
@d150 1
a150 5
set_trace_option_mask (sd, name, mask, arg)
     SIM_DESC sd;
     const char *name;
     int mask;
     const char *arg;
d225 1
a225 5
set_trace_option (sd, name, idx, arg)
     SIM_DESC sd;
     const char *name;
     int idx;
     const char *arg;
@


1.7
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d2 1
a2 1
   Copyright (C) 1997, 1998, 2001, 2007, 2008, 2009
@


1.6
log
@	Updated copyright notices for most files.
@
text
@d2 2
a3 1
   Copyright (C) 1997, 1998, 2001, 2007, 2008 Free Software Foundation, Inc.
@


1.5
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d2 1
a2 1
   Copyright (C) 1997, 1998, 2001, 2007 Free Software Foundation, Inc.
@


1.4
log
@Copyright updates for 2007.
@
text
@d9 2
a10 2
the Free Software Foundation; either version 2, or (at your option)
any later version.
d17 2
a18 3
You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.3
log
@Index: sim/frv/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* traps.c: Replace "struct symbol_cache_entry" with "struct
	bfd_symbol".

Index: sim/d10v/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* simops.c: Replace "struct symbol_cache_entry" with "struct
	bfd_symbol".

Index: sim/common/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* sim-trace.c, sim-base.h: Replace "struct symbol_cache_entry"
	with "struct bfd_symbol".

Index: ld/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* emultempl/pe.em, pe-dll.c: Replace "struct symbol_cache_entry"
	with "struct bfd_symbol".

Index: bfd/ChangeLog
2003-10-30  Andrew Cagney  <cagney@@redhat.com>

	* syms.c: Replace "struct symbol_cache_entry" with "struct
	bfd_symbol".
	* vms.h, targets.c, section.c, reloc.c, peicode.h: Ditto.
	* mipsbsd.c, elf.c, linker.c, elf-bfd.h, ecoff.c: Ditto.
	* cpu-z8k.c, cpu-ns32k.c, cpu-h8500.c, bfd.c, bfd-in.h: Ditto.
	* bfd-in2.h: Re-generate.
@
text
@d2 1
a2 1
   Copyright (C) 1997, 1998, 2001 Free Software Foundation, Inc.
@


1.2
log
@2001-02-22  Ben Elliston  <bje@@redhat.com>

	* sim-trace.h (TRACE_VPU_IDX): Add.
	(TRACE_vpu): Define.
	(WITH_TRACE_VPU_P): Likewise.
	(TRACE_VPU_P): Likewise.
	* sim-trace.c (OPTION_TRACE_VPU): Define.
	(trace_options): Add --trace-vpu.
	(trace_option_handler): Handle OPTION_TRACE_VPU.
	(trace_option_handler): Include VPU tracing in --trace-semantics.
	(trace_idx_to_str): Handle TRACE_VPU_IDX.
@
text
@d1266 1
a1266 1
				     (struct symbol_cache_entry **) 0,
@


1.2.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1266 1
a1266 1
				     (struct bfd_symbol **) 0,
@


1.2.22.1
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1266 1
a1266 1
				     (struct bfd_symbol **) 0,
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1997, 1998 Free Software Foundation, Inc.
d79 2
a80 1
  OPTION_TRACE_FILE
d110 3
d329 7
d351 1
d632 1
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@

