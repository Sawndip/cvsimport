head	1.13;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.13
	gdb_7_6-2013-04-26-release:1.13
	gdb_7_6-branch:1.13.0.2
	gdb_7_6-2013-03-12-branchpoint:1.13
	gdb_7_5_1-2012-11-29-release:1.12
	gdb_7_5-2012-08-17-release:1.12
	gdb_7_5-branch:1.12.0.2
	gdb_7_5-2012-07-18-branchpoint:1.12
	gdb_7_4_1-2012-04-26-release:1.11.2.1
	gdb_7_4-2012-01-24-release:1.11.2.1
	gdb_7_4-branch:1.11.0.2
	gdb_7_4-2011-12-13-branchpoint:1.11
	gdb_7_3_1-2011-09-04-release:1.10
	gdb_7_3-2011-07-26-release:1.10
	gdb_7_3-branch:1.10.0.2
	gdb_7_3-2011-04-01-branchpoint:1.10
	gdb_7_2-2010-09-02-release:1.8
	gdb_7_2-branch:1.8.0.4
	gdb_7_2-2010-07-07-branchpoint:1.8
	gdb_7_1-2010-03-18-release:1.8
	gdb_7_1-branch:1.8.0.2
	gdb_7_1-2010-02-18-branchpoint:1.8
	gdb_7_0_1-2009-12-22-release:1.7
	gdb_7_0-2009-10-06-release:1.7
	gdb_7_0-branch:1.7.0.4
	gdb_7_0-2009-09-16-branchpoint:1.7
	arc-sim-20090309:1.6
	msnyder-checkpoint-072509-branch:1.7.0.2
	msnyder-checkpoint-072509-branchpoint:1.7
	arc-insight_6_8-branch:1.6.0.16
	arc-insight_6_8-branchpoint:1.6
	insight_6_8-branch:1.6.0.14
	insight_6_8-branchpoint:1.6
	reverse-20081226-branch:1.6.0.12
	reverse-20081226-branchpoint:1.6
	multiprocess-20081120-branch:1.6.0.10
	multiprocess-20081120-branchpoint:1.6
	reverse-20080930-branch:1.6.0.8
	reverse-20080930-branchpoint:1.6
	reverse-20080717-branch:1.6.0.6
	reverse-20080717-branchpoint:1.6
	msnyder-reverse-20080609-branch:1.6.0.4
	msnyder-reverse-20080609-branchpoint:1.6
	drow-reverse-20070409-branch:1.4.0.2
	drow-reverse-20070409-branchpoint:1.4
	gdb_6_8-2008-03-27-release:1.6
	gdb_6_8-branch:1.6.0.2
	gdb_6_8-2008-02-26-branchpoint:1.6
	gdb_6_7_1-2007-10-29-release:1.5
	gdb_6_7-2007-10-10-release:1.5
	gdb_6_7-branch:1.5.0.2
	gdb_6_7-2007-09-07-branchpoint:1.5
	insight_6_6-20070208-release:1.3
	gdb_6_6-2006-12-18-release:1.3
	gdb_6_6-branch:1.3.0.88
	gdb_6_6-2006-11-15-branchpoint:1.3
	insight_6_5-20061003-release:1.3
	gdb-csl-symbian-6_4_50_20060226-12:1.3
	gdb-csl-sourcerygxx-3_4_4-25:1.3
	nickrob-async-20060828-mergepoint:1.3
	gdb-csl-symbian-6_4_50_20060226-11:1.3
	gdb-csl-sourcerygxx-4_1-17:1.3
	gdb-csl-20060226-branch-local-2:1.3
	gdb-csl-sourcerygxx-4_1-14:1.3
	gdb-csl-sourcerygxx-4_1-13:1.3
	gdb-csl-sourcerygxx-4_1-12:1.3
	gdb-csl-sourcerygxx-3_4_4-21:1.3
	gdb_6_5-20060621-release:1.3
	gdb-csl-sourcerygxx-4_1-9:1.3
	gdb-csl-sourcerygxx-4_1-8:1.3
	gdb-csl-sourcerygxx-4_1-7:1.3
	gdb-csl-arm-2006q1-6:1.3
	gdb-csl-sourcerygxx-4_1-6:1.3
	gdb-csl-symbian-6_4_50_20060226-10:1.3
	gdb-csl-symbian-6_4_50_20060226-9:1.3
	gdb-csl-symbian-6_4_50_20060226-8:1.3
	gdb-csl-coldfire-4_1-11:1.3
	gdb-csl-sourcerygxx-3_4_4-19:1.3
	gdb-csl-coldfire-4_1-10:1.3
	gdb_6_5-branch:1.3.0.86
	gdb_6_5-2006-05-14-branchpoint:1.3
	gdb-csl-sourcerygxx-4_1-5:1.3
	nickrob-async-20060513-branch:1.3.0.84
	nickrob-async-20060513-branchpoint:1.3
	gdb-csl-sourcerygxx-4_1-4:1.3
	msnyder-reverse-20060502-branch:1.3.0.82
	msnyder-reverse-20060502-branchpoint:1.3
	gdb-csl-morpho-4_1-4:1.3
	gdb-csl-sourcerygxx-3_4_4-17:1.3
	readline_5_1-import-branch:1.3.0.80
	readline_5_1-import-branchpoint:1.3
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.3
	gdb-csl-symbian-20060226-branch:1.3.0.78
	gdb-csl-symbian-20060226-branchpoint:1.3
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.3
	msnyder-reverse-20060331-branch:1.3.0.76
	msnyder-reverse-20060331-branchpoint:1.3
	gdb-csl-available-20060303-branch:1.3.0.74
	gdb-csl-available-20060303-branchpoint:1.3
	gdb-csl-20060226-branch:1.3.0.72
	gdb-csl-20060226-branchpoint:1.3
	gdb_6_4-20051202-release:1.3
	msnyder-fork-checkpoint-branch:1.3.0.70
	msnyder-fork-checkpoint-branchpoint:1.3
	gdb-csl-gxxpro-6_3-branch:1.3.0.68
	gdb-csl-gxxpro-6_3-branchpoint:1.3
	gdb_6_4-branch:1.3.0.66
	gdb_6_4-2005-11-01-branchpoint:1.3
	gdb-csl-arm-20051020-branch:1.3.0.64
	gdb-csl-arm-20051020-branchpoint:1.3
	msnyder-tracepoint-checkpoint-branch:1.3.0.62
	msnyder-tracepoint-checkpoint-branchpoint:1.3
	gdb-csl-arm-20050325-2005-q1b:1.3
	gdb-csl-arm-20050325-2005-q1a:1.3
	csl-arm-20050325-branch:1.3.0.60
	csl-arm-20050325-branchpoint:1.3
	gdb_6_3-20041109-release:1.3
	gdb_6_3-branch:1.3.0.56
	gdb_6_3-20041019-branchpoint:1.3
	drow_intercu-merge-20040921:1.3
	drow_intercu-merge-20040915:1.3
	jimb-gdb_6_2-e500-branch:1.3.0.58
	jimb-gdb_6_2-e500-branchpoint:1.3
	gdb_6_2-20040730-release:1.3
	gdb_6_2-branch:1.3.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.3
	gdb_6_1_1-20040616-release:1.3
	gdb_6_1-2004-04-05-release:1.3
	drow_intercu-merge-20040402:1.3
	drow_intercu-merge-20040327:1.3
	ezannoni_pie-20040323-branch:1.3.0.52
	ezannoni_pie-20040323-branchpoint:1.3
	cagney_tramp-20040321-mergepoint:1.3
	cagney_tramp-20040309-branch:1.3.0.50
	cagney_tramp-20040309-branchpoint:1.3
	gdb_6_1-branch:1.3.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.3
	drow_intercu-20040221-branch:1.3.0.46
	drow_intercu-20040221-branchpoint:1.3
	cagney_bfdfile-20040213-branch:1.3.0.44
	cagney_bfdfile-20040213-branchpoint:1.3
	drow-cplus-merge-20040208:1.3
	carlton_dictionary-20040126-merge:1.3
	cagney_bigcore-20040122-branch:1.3.0.42
	cagney_bigcore-20040122-branchpoint:1.3
	drow-cplus-merge-20040113:1.3
	drow-cplus-merge-20031224:1.3
	drow-cplus-merge-20031220:1.3
	carlton_dictionary-20031215-merge:1.3
	drow-cplus-merge-20031214:1.3
	carlton-dictionary-20031111-merge:1.3
	gdb_6_0-2003-10-04-release:1.3
	kettenis_sparc-20030918-branch:1.3.0.40
	kettenis_sparc-20030918-branchpoint:1.3
	carlton_dictionary-20030917-merge:1.3
	ezannoni_pie-20030916-branchpoint:1.3
	ezannoni_pie-20030916-branch:1.3.0.38
	cagney_x86i386-20030821-branch:1.3.0.36
	cagney_x86i386-20030821-branchpoint:1.3
	carlton_dictionary-20030805-merge:1.3
	carlton_dictionary-20030627-merge:1.3
	gdb_6_0-branch:1.3.0.34
	gdb_6_0-2003-06-23-branchpoint:1.3
	jimb-ppc64-linux-20030613-branch:1.3.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.3
	cagney_convert-20030606-branch:1.3.0.30
	cagney_convert-20030606-branchpoint:1.3
	cagney_writestrings-20030508-branch:1.3.0.28
	cagney_writestrings-20030508-branchpoint:1.3
	jimb-ppc64-linux-20030528-branch:1.3.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.3
	carlton_dictionary-20030523-merge:1.3
	cagney_fileio-20030521-branch:1.3.0.24
	cagney_fileio-20030521-branchpoint:1.3
	kettenis_i386newframe-20030517-mergepoint:1.3
	jimb-ppc64-linux-20030509-branch:1.3.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.3
	kettenis_i386newframe-20030504-mergepoint:1.3
	carlton_dictionary-20030430-merge:1.3
	kettenis_i386newframe-20030419-branch:1.3.0.20
	kettenis_i386newframe-20030419-branchpoint:1.3
	carlton_dictionary-20030416-merge:1.3
	cagney_frameaddr-20030409-mergepoint:1.3
	kettenis_i386newframe-20030406-branch:1.3.0.18
	kettenis_i386newframe-20030406-branchpoint:1.3
	cagney_frameaddr-20030403-branchpoint:1.3
	cagney_frameaddr-20030403-branch:1.3.0.16
	cagney_framebase-20030330-mergepoint:1.3
	cagney_framebase-20030326-branch:1.3.0.14
	cagney_framebase-20030326-branchpoint:1.3
	cagney_lazyid-20030317-branch:1.3.0.12
	cagney_lazyid-20030317-branchpoint:1.3
	kettenis-i386newframe-20030316-mergepoint:1.3
	offbyone-20030313-branch:1.3.0.10
	offbyone-20030313-branchpoint:1.3
	kettenis-i386newframe-20030308-branch:1.3.0.8
	kettenis-i386newframe-20030308-branchpoint:1.3
	carlton_dictionary-20030305-merge:1.3
	cagney_offbyone-20030303-branch:1.3.0.6
	cagney_offbyone-20030303-branchpoint:1.3
	carlton_dictionary-20030207-merge:1.3
	interps-20030202-branch:1.3.0.4
	interps-20030202-branchpoint:1.3
	cagney-unwind-20030108-branch:1.3.0.2
	cagney-unwind-20030108-branchpoint:1.3
	carlton_dictionary-20021223-merge:1.3
	gdb_5_3-2002-12-12-release:1.2.14.1
	carlton_dictionary-20021115-merge:1.2
	kseitz_interps-20021105-merge:1.2
	kseitz_interps-20021103-merge:1.2
	drow-cplus-merge-20021020:1.2
	drow-cplus-merge-20021025:1.2
	carlton_dictionary-20021025-merge:1.2
	carlton_dictionary-20021011-merge:1.2
	drow-cplus-branch:1.2.0.18
	drow-cplus-branchpoint:1.2
	kseitz_interps-20020930-merge:1.2
	carlton_dictionary-20020927-merge:1.2
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	gdb_5_3-branch:1.2.0.14
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.12
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.10
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.8
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.6
	cagney_regbuf-20020515-branchpoint:1.2
	jimb-macro-020506-branch:1.2.0.4
	jimb-macro-020506-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.12
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.10
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.8
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.13
date	2013.01.01.06.41.33;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2012.01.04.08.28.06;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2011.10.14.19.31.46;	author tromey;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2011.03.15.03.16.17;	author vapier;	state Exp;
branches;
next	1.9;

1.9
date	2011.01.01.15.33.56;	author brobecke;	state Exp;
branches;
next	1.8;

1.8
date	2010.01.01.10.03.27;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.14.10.53.06;	author brobecke;	state Exp;
branches;
next	1.6;

1.6
date	2008.01.01.22.53.23;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2007.08.24.14.28.35;	author brobecke;	state Exp;
branches;
next	1.4;

1.4
date	2007.01.09.17.59.16;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.23.01.12.05;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.10.23.11.37;	author cgd;	state Exp;
branches
	1.2.14.1
	1.2.16.1
	1.2.18.1;
next	1.1;

1.1
date	99.04.16.01.34.57;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.11.2.1
date	2012.01.06.04.54.39;	author brobecke;	state Exp;
branches;
next	;

1.2.14.1
date	2002.11.23.01.12.34;	author cagney;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.39.51;	author carlton;	state Exp;
branches;
next	;

1.2.18.1
date	2003.12.14.20.28.18;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.57;	author shebs;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* The common simulator framework for GDB, the GNU Debugger.

   Copyright 2002-2013 Free Software Foundation, Inc.

   Contributed by Andrew Cagney and Red Hat.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */


#ifndef _SIM_ALU_H_
#define _SIM_ALU_H_

#include "symcat.h"


/* INTEGER ALU MODULE:

   This module provides an implementation of 2's complement arithmetic
   including the recording of carry and overflow status bits.


   EXAMPLE:

   Code using this module includes it into sim-main.h and then, as a
   convention, defines macro's ALU*_END that records the result of any
   arithmetic performed.  Ex:

   	#include "sim-alu.h"
	#define ALU32_END(RES) \
	(RES) = ALU32_OVERFLOW_RESULT; \
	carry = ALU32_HAD_CARRY_BORROW; \
	overflow = ALU32_HAD_OVERFLOW

   The macro's are then used vis:

        {
	  ALU32_BEGIN (GPR[i]);
	  ALU32_ADDC (GPR[j]);
	  ALU32_END (GPR[k]);
	}


   NOTES:

   Macros exist for efficiently computing 8, 16, 32 and 64 bit
   arithmetic - ALU8_*, ALU16_*, ....  In addition, according to
   TARGET_WORD_BITSIZE a set of short-hand macros are defined - ALU_*

   Initialization:

	ALU*_BEGIN(ACC): Declare initialize the ALU accumulator with ACC.

   Results:

        The calculation of the final result may be computed a number
        of different ways.  Three different overflow macro's are
        defined, the most efficient one to use depends on which other
        outputs from the alu are being used.

	ALU*_RESULT: Generic ALU result output.

   	ALU*_HAD_OVERFLOW: Returns a nonzero value if signed overflow
   	occurred.

	ALU*_OVERFLOW_RESULT: If the macro ALU*_HAD_OVERFLOW is being
	used this is the most efficient result available.  Ex:

		#define ALU16_END(RES) \
		if (ALU16_HAD_OVERFLOW) \
		  sim_engine_halt (...); \
		(RES) = ALU16_OVERFLOW_RESULT

   	ALU*_HAD_CARRY_BORROW: Returns a nonzero value if unsigned
   	overflow or underflow (also referred to as carry and borrow)
   	occurred.

	ALU*_CARRY_BORROW_RESULT: If the macro ALU*_HAD_CARRY_BORROW is being
	used this is the most efficient result available.  Ex:

		#define ALU64_END(RES) \
		State.carry = ALU64_HAD_CARRY_BORROW; \
		(RES) = ALU64_CARRY_BORROW_RESULT


   Addition:

	ALU*_ADD(VAL): Add VAL to the ALU accumulator.  Record any
	overflow as well as the final result.

	ALU*_ADDC(VAL): Add VAL to the ALU accumulator.  Record any
	carry-out or overflow as well as the final result.

	ALU*_ADDC_C(VAL,CI): Add VAL and CI (carry-in).  Record any
	carry-out or overflow as well as the final result.

   Subtraction:

	ALU*_SUB(VAL): Subtract VAL from the ALU accumulator.  Record
	any underflow as well as the final result.

	ALU*_SUBC(VAL): Subtract VAL from the ALU accumulator using
	negated addition.  Record any underflow or carry-out as well
	as the final result.

	ALU*_SUBB(VAL): Subtract VAL from the ALU accumulator using
	direct subtraction (ACC+~VAL+1).  Record any underflow or
	borrow-out as well as the final result.

	ALU*_SUBC_X(VAL,CI): Subtract VAL and CI (carry-in) from the
	ALU accumulator using extended negated addition (ACC+~VAL+CI).
	Record any underflow or carry-out as well as the final result.

	ALU*_SUBB_B(VAL,BI): Subtract VAL and BI (borrow-in) from the
	ALU accumulator using direct subtraction.  Record any
	underflow or borrow-out as well as the final result.


 */



/* Twos complement arithmetic - addition/subtraction - carry/borrow
   (or you thought you knew the answer to 0-0)



   Notation and Properties:


   Xn denotes the value X stored in N bits.

   MSBn (X): The most significant (sign) bit of X treated as an N bit
   value.

   SEXTn (X): The infinite sign extension of X treated as an N bit
   value.

   MAXn, MINn: The upper and lower bound of a signed, two's
   complement N bit value.

   UMAXn: The upper bound of an unsigned N bit value (the lower
   bound is always zero).

   Un: UMAXn + 1.  Unsigned arithmetic is computed `modulo (Un)'.

   X[p]: Is bit P of X.  X[0] denotes the least significant bit.

   ~X[p]: Is the inversion of bit X[p]. Also equal to 1-X[p],
   (1+X[p])mod(2).



   Addition - Overflow - Introduction:


   Overflow/Overflow indicates an error in computation of signed
   arithmetic.  i.e. given X,Y in [MINn..MAXn]; overflow
   indicates that the result X+Y > MAXn or X+Y < MIN_INTx.

   Hardware traditionally implements overflow by computing the XOR of
   carry-in/carry-out of the most significant bit of the ALU. Here
   other methods need to be found.



   Addition - Overflow - method 1:


   Overflow occurs when the sign (most significant bit) of the two N
   bit operands is identical but different to the sign of the result:

                Rn = (Xn + Yn)
		V = MSBn (~(Xn ^ Yn) & (Rn ^ Xn))



   Addition - Overflow - method 2:


   The two N bit operands are sign extended to M>N bits and then
   added.  Overflow occurs when SIGN_BIT<n> and SIGN_BIT<m> do not
   match.

   		Rm = (SEXTn (Xn) + SEXTn (Yn))
		V = MSBn ((Rm >> (M - N)) ^ Rm)



   Addition - Overflow - method 3:


   The two N bit operands are sign extended to M>N bits and then
   added.  Overflow occurs when the result is outside of the sign
   extended range [MINn .. MAXn].



   Addition - Overflow - method 4:


   Given the Result and Carry-out bits, the oVerflow from the addition
   of X, Y and carry-In can be computed using the equation:

                Rn = (Xn + Yn)
		V = (MSBn ((Xn ^ Yn) ^ Rn)) ^ C)

   As shown in the table below:

         I  X  Y  R  C | V | X^Y  ^R  ^C
        ---------------+---+-------------
         0  0  0  0  0 | 0 |  0    0   0
         0  0  1  1  0 | 0 |  1    0   0
         0  1  0  1  0 | 0 |  1    0   0
         0  1  1  0  1 | 1 |  0    0   1
         1  0  0  1  0 | 1 |  0    1   1
         1  0  1  0  1 | 0 |  1    1   0
         1  1  0  0  1 | 0 |  1    1   0
         1  1  1  1  1 | 0 |  0    1   0



   Addition - Carry - Introduction:


   Carry (poorly named) indicates that an overflow occurred for
   unsigned N bit addition.  i.e. given X, Y in [0..UMAXn] then
   carry indicates X+Y > UMAXn or X+Y >= Un.

   The following table lists the output for all given inputs into a
   full-adder.

         I  X  Y  R | C
        ------------+---
         0  0  0  0 | 0
         0  0  1  1 | 0
         0  1  0  1 | 0
         0  1  1  0 | 1
         1  0  0  1 | 0
         1  0  1  0 | 1
         1  1  0  0 | 1
         1  1  1  1 | 1

   (carry-In, X, Y, Result, Carry-out):



   Addition - Carry - method 1:


   Looking at the terms X, Y and R we want an equation for C.

       XY\R  0  1
          +-------
       00 |  0  0
       01 |  1  0
       11 |  1  1
       10 |  1  0

   This giving us the sum-of-prod equation:

		MSBn ((Xn & Yn) | (Xn & ~Rn) | (Yn & ~Rn))

   Verifying:

         I  X  Y  R | C | X&Y  X&~R Y&~R
        ------------+---+---------------
         0  0  0  0 | 0 |  0    0    0
         0  0  1  1 | 0 |  0    0    0
         0  1  0  1 | 0 |  0    0    0
         0  1  1  0 | 1 |  1    1    1
         1  0  0  1 | 0 |  0    0    0
         1  0  1  0 | 1 |  0    0    1
         1  1  0  0 | 1 |  0    1    0
         1  1  1  1 | 1 |  1    0    0



   Addition - Carry - method 2:


   Given two signed N bit numbers, a carry can be detected by treating
   the numbers as N bit unsigned and adding them using M>N unsigned
   arithmetic.  Carry is indicated by bit (1 << N) being set (result
   >= 2**N).



   Addition - Carry - method 3:


   Given the oVerflow bit.  The carry can be computed from:

		(~R&V) | (R&V)



   Addition - Carry - method 4:

   Given two signed numbers.  Treating them as unsigned we have:

		0 <= X < Un, 0 <= Y < Un
	==>	X + Y < 2 Un

   Consider Y when carry occurs:

		X + Y >= Un, Y < Un
	==>	(Un - X) <= Y < Un               # rearrange
	==>	Un <= X + Y < Un + X < 2 Un      # add Xn
	==>	0 <= (X + Y) mod Un < X mod Un

   or when carry as occurred:

               (X + Y) mod Un < X mod Un

   Consider Y when carry does not occur:

		X + Y < Un
	have	X < Un, Y >= 0
	==>	X <= X + Y < Un
	==>     X mod Un <= (X + Y) mod Un

   or when carry has not occurred:

	        ! ( (X + Y) mod Un < X mod Un)

   hence we get carry by computing in N bit unsigned arithmetic.

                carry <- (Xn + Yn) < Xn



   Subtraction - Introduction


   There are two different ways of computing the signed two's
   complement difference of two numbers.  The first is based on
   negative addition, the second on direct subtraction.



   Subtraction - Carry - Introduction - Negated Addition


   The equation X - Y can be computed using:

   		X + (-Y)
	==>	X + ~Y + 1		# -Y = ~Y + 1

   In addition to the result, the equation produces Carry-out.  For
   succeeding extended precision calculations, the more general
   equation can be used:

		C[p]:R[p]  =  X[p] + ~Y[p] + C[p-1]
 	where	C[0]:R[0]  =  X[0] + ~Y[0] + 1



   Subtraction - Borrow - Introduction - Direct Subtraction


   The alternative to negative addition is direct subtraction where
   `X-Y is computed directly.  In addition to the result of the
   calculation, a Borrow bit is produced.  In general terms:

		B[p]:R[p]  =  X[p] - Y[p] - B[p-1]
	where	B[0]:R[0]  =  X[0] - Y[0]

   The Borrow bit is the complement of the Carry bit produced by
   Negated Addition above.  A dodgy proof follows:

   	Case 0:
		C[0]:R[0] = X[0] + ~Y[0] + 1
	==>	C[0]:R[0] = X[0] + 1 - Y[0] + 1	# ~Y[0] = (1 - Y[0])?
	==>	C[0]:R[0] = 2 + X[0] - Y[0]
	==>	C[0]:R[0] = 2 + B[0]:R[0]
	==>	C[0]:R[0] = (1 + B[0]):R[0]
	==>	C[0] = ~B[0]			# (1 + B[0]) mod 2 = ~B[0]?

	Case P:
		C[p]:R[p] = X[p] + ~Y[p] + C[p-1]
	==>	C[p]:R[p] = X[p] + 1 - Y[0] + 1 - B[p-1]
	==>	C[p]:R[p] = 2 + X[p] - Y[0] - B[p-1]
	==>	C[p]:R[p] = 2 + B[p]:R[p]
	==>	C[p]:R[p] = (1 + B[p]):R[p]
	==>     C[p] = ~B[p]

   The table below lists all possible inputs/outputs for a
   full-subtractor:

   	X  Y  I  |  R  B
	0  0  0  |  0  0
	0  0  1  |  1  1
	0  1  0  |  1  1
	0  1  1  |  0  1
	1  0  0  |  1  0
	1  0  1  |  0  0
	1  1  0  |  0  0
	1  1  1  |  1  1



   Subtraction - Method 1


   Treating Xn and Yn as unsigned values then a borrow (unsigned
   underflow) occurs when:

		B = Xn < Yn
	==>	C = Xn >= Yn

 */



/* 8 bit target expressions:

   Since the host's natural bitsize > 8 bits, carry method 2 and
   overflow method 2 are used. */

#define ALU8_BEGIN(VAL) \
unsigned alu8_cr = (unsigned8) (VAL); \
signed alu8_vr = (signed8) (alu8_cr)

#define ALU8_SET(VAL) \
alu8_cr = (unsigned8) (VAL); \
alu8_vr = (signed8) (alu8_cr)

#define ALU8_SET_CARRY_BORROW(CARRY)					\
do {									\
  if (CARRY)								\
    alu8_cr |= ((signed)-1) << 8;					\
  else									\
    alu8_cr &= 0xff;							\
} while (0)

#define ALU8_HAD_CARRY_BORROW (alu8_cr & LSBIT32(8))
#define ALU8_HAD_OVERFLOW (((alu8_vr >> 8) ^ alu8_vr) & LSBIT32 (8-1))

#define ALU8_RESULT ((unsigned8) alu8_cr)
#define ALU8_CARRY_BORROW_RESULT ((unsigned8) alu8_cr)
#define ALU8_OVERFLOW_RESULT ((unsigned8) alu8_vr)

/* #define ALU8_END ????? - target dependant */



/* 16 bit target expressions:

   Since the host's natural bitsize > 16 bits, carry method 2 and
   overflow method 2 are used. */

#define ALU16_BEGIN(VAL) \
signed alu16_cr = (unsigned16) (VAL); \
unsigned alu16_vr = (signed16) (alu16_cr)

#define ALU16_SET(VAL) \
alu16_cr = (unsigned16) (VAL); \
alu16_vr = (signed16) (alu16_cr)

#define ALU16_SET_CARRY_BORROW(CARRY)					\
do {									\
  if (CARRY)								\
    alu16_cr |= ((signed)-1) << 16;					\
  else									\
    alu16_cr &= 0xffff;							\
} while (0)

#define ALU16_HAD_CARRY_BORROW (alu16_cr & LSBIT32(16))
#define ALU16_HAD_OVERFLOW (((alu16_vr >> 16) ^ alu16_vr) & LSBIT32 (16-1))

#define ALU16_RESULT ((unsigned16) alu16_cr)
#define ALU16_CARRY_BORROW_RESULT ((unsigned16) alu16_cr)
#define ALU16_OVERFLOW_RESULT ((unsigned16) alu16_vr)

/* #define ALU16_END ????? - target dependant */



/* 32 bit target expressions:

   Since most hosts do not support 64 (> 32) bit arithmetic, carry
   method 4 and overflow method 4 are used. */

#define ALU32_BEGIN(VAL) \
unsigned32 alu32_r = (VAL); \
int alu32_c = 0; \
int alu32_v = 0

#define ALU32_SET(VAL) \
alu32_r = (VAL); \
alu32_c = 0; \
alu32_v = 0

#define ALU32_SET_CARRY_BORROW(CARRY) alu32_c = (CARRY)

#define ALU32_HAD_CARRY_BORROW (alu32_c)
#define ALU32_HAD_OVERFLOW (alu32_v)

#define ALU32_RESULT (alu32_r)
#define ALU32_CARRY_BORROW_RESULT (alu32_r)
#define ALU32_OVERFLOW_RESULT (alu32_r)



/* 64 bit target expressions:

   Even though the host typically doesn't support native 64 bit
   arithmetic, it is still used. */

#define ALU64_BEGIN(VAL) \
unsigned64 alu64_r = (VAL); \
int alu64_c = 0; \
int alu64_v = 0

#define ALU64_SET(VAL) \
alu64_r = (VAL); \
alu64_c = 0; \
alu64_v = 0

#define ALU64_SET_CARRY_BORROW(CARRY) alu64_c = (CARRY)

#define ALU64_HAD_CARRY_BORROW (alu64_c)
#define ALU64_HAD_OVERFLOW (alu64_v)

#define ALU64_RESULT (alu64_r)
#define ALU64_CARRY_BORROW_RESULT (alu64_r)
#define ALU64_OVERFLOW_RESULT (alu64_r)



/* Generic versions of above macros */

#define ALU_BEGIN	    XCONCAT3(ALU,WITH_TARGET_WORD_BITSIZE,_BEGIN)
#define ALU_SET		    XCONCAT3(ALU,WITH_TARGET_WORD_BITSIZE,_SET)
#define ALU_SET_CARRY	    XCONCAT3(ALU,WITH_TARGET_WORD_BITSIZE,_SET_CARRY)

#define ALU_HAD_OVERFLOW    XCONCAT3(ALU,WITH_TARGET_WORD_BITSIZE,_HAD_OVERFLOW)
#define ALU_HAD_CARRY       XCONCAT3(ALU,WITH_TARGET_WORD_BITSIZE,_HAD_CARRY)

#define ALU_RESULT          XCONCAT3(ALU,WITH_TARGET_WORD_BITSIZE,_RESULT)
#define ALU_OVERFLOW_RESULT XCONCAT3(ALU,WITH_TARGET_WORD_BITSIZE,_OVERFLOW_RESULT)
#define ALU_CARRY_RESULT    XCONCAT3(ALU,WITH_TARGET_WORD_BITSIZE,_CARRY_RESULT)



/* Basic operation - add (overflowing) */

#define ALU8_ADD(VAL)							\
do {									\
  unsigned8 alu8add_val = (VAL);					\
  ALU8_ADDC (alu8add_val);						\
} while (0)

#define ALU16_ADD(VAL)							\
do {									\
  unsigned16 alu16add_val = (VAL);					\
  ALU16_ADDC (alu8add_val);						\
} while (0)

#define ALU32_ADD(VAL)							\
do {									\
  unsigned32 alu32add_val = (VAL);					\
  ALU32_ADDC (alu32add_val);						\
} while (0)

#define ALU64_ADD(VAL)							\
do {									\
  unsigned64 alu64add_val = (unsigned64) (VAL);				\
  ALU64_ADDC (alu64add_val);						\
} while (0)

#define ALU_ADD XCONCAT3(ALU,WITH_TARGET_WORD_BITSIZE,_ADD)



/* Basic operation - add carrying (and overflowing) */

#define ALU8_ADDC(VAL)							\
do {									\
  unsigned8 alu8addc_val = (VAL);					\
  alu8_cr += (unsigned8)(alu8addc_val);					\
  alu8_vr += (signed8)(alu8addc_val);					\
} while (0)

#define ALU16_ADDC(VAL)							\
do {									\
  unsigned16 alu16addc_val = (VAL);					\
  alu16_cr += (unsigned16)(alu16addc_val);				\
  alu16_vr += (signed16)(alu16addc_val);				\
} while (0)

#define ALU32_ADDC(VAL)							\
do {									\
  unsigned32 alu32addc_val = (VAL);					\
  unsigned32 alu32addc_sign = alu32addc_val ^ alu32_r;			\
  alu32_r += (alu32addc_val);						\
  alu32_c = (alu32_r < alu32addc_val);					\
  alu32_v = ((alu32addc_sign ^ - (unsigned32)alu32_c) ^ alu32_r) >> 31;	\
} while (0)

#define ALU64_ADDC(VAL)							\
do {									\
  unsigned64 alu64addc_val = (unsigned64) (VAL);			\
  unsigned64 alu64addc_sign = alu64addc_val ^ alu64_r;			\
  alu64_r += (alu64addc_val);						\
  alu64_c = (alu64_r < alu64addc_val);					\
  alu64_v = ((alu64addc_sign ^ - (unsigned64)alu64_c) ^ alu64_r) >> 63;	\
} while (0)

#define ALU_ADDC XCONCAT3(ALU,WITH_TARGET_WORD_BITSIZE,_ADDC)



/* Compound operation - add carrying (and overflowing) with carry-in */

#define ALU8_ADDC_C(VAL,C)						\
do {									\
  unsigned8 alu8addcc_val = (VAL);					\
  unsigned8 alu8addcc_c = (C);						\
  alu8_cr += (unsigned)(unsigned8)alu8addcc_val + alu8addcc_c;		\
  alu8_vr += (signed)(signed8)(alu8addcc_val) + alu8addcc_c;		\
} while (0)

#define ALU16_ADDC_C(VAL,C)						\
do {									\
  unsigned16 alu16addcc_val = (VAL);					\
  unsigned16 alu16addcc_c = (C);					\
  alu16_cr += (unsigned)(unsigned16)alu16addcc_val + alu16addcc_c;	\
  alu16_vr += (signed)(signed16)(alu16addcc_val) + alu16addcc_c;	\
} while (0)

#define ALU32_ADDC_C(VAL,C)						\
do {									\
  unsigned32 alu32addcc_val = (VAL);					\
  unsigned32 alu32addcc_c = (C);					\
  unsigned32 alu32addcc_sign = (alu32addcc_val ^ alu32_r);		\
  alu32_r += (alu32addcc_val + alu32addcc_c);				\
  alu32_c = ((alu32_r < alu32addcc_val)					\
             || (alu32addcc_c && alu32_r == alu32addcc_val));		\
  alu32_v = ((alu32addcc_sign ^ - (unsigned32)alu32_c) ^ alu32_r) >> 31;\
} while (0)

#define ALU64_ADDC_C(VAL,C)						\
do {									\
  unsigned64 alu64addcc_val = (VAL);					\
  unsigned64 alu64addcc_c = (C);					\
  unsigned64 alu64addcc_sign = (alu64addcc_val ^ alu64_r);		\
  alu64_r += (alu64addcc_val + alu64addcc_c);				\
  alu64_c = ((alu64_r < alu64addcc_val)					\
             || (alu64addcc_c && alu64_r == alu64addcc_val));		\
  alu64_v = ((alu64addcc_sign ^ - (unsigned64)alu64_c) ^ alu64_r) >> 63;\
} while (0)

#define ALU_ADDC_C XCONCAT3(ALU,WITH_TARGET_WORD_BITSIZE,_ADDC_C)



/* Basic operation - subtract (overflowing) */

#define ALU8_SUB(VAL)							\
do {									\
  unsigned8 alu8sub_val = (VAL);					\
  ALU8_ADDC_C (~alu8sub_val, 1);					\
} while (0)

#define ALU16_SUB(VAL)							\
do {									\
  unsigned16 alu16sub_val = (VAL);					\
  ALU16_ADDC_C (~alu16sub_val, 1);					\
} while (0)

#define ALU32_SUB(VAL)							\
do {									\
  unsigned32 alu32sub_val = (VAL);					\
  ALU32_ADDC_C (~alu32sub_val, 1);					\
} while (0)

#define ALU64_SUB(VAL)							\
do {									\
  unsigned64 alu64sub_val = (VAL);					\
  ALU64_ADDC_C (~alu64sub_val, 1);					\
} while (0)

#define ALU_SUB XCONCAT3(ALU,WITH_TARGET_WORD_BITSIZE,_SUB)



/* Basic operation - subtract carrying (and overflowing) */

#define ALU8_SUBC(VAL)							\
do {									\
  unsigned8 alu8subc_val = (VAL);					\
  ALU8_ADDC_C (~alu8subc_val, 1);					\
} while (0)

#define ALU16_SUBC(VAL)							\
do {									\
  unsigned16 alu16subc_val = (VAL);					\
  ALU16_ADDC_C (~alu16subc_val, 1);					\
} while (0)

#define ALU32_SUBC(VAL)							\
do {									\
  unsigned32 alu32subc_val = (VAL);					\
  ALU32_ADDC_C (~alu32subc_val, 1);					\
} while (0)

#define ALU64_SUBC(VAL)							\
do {									\
  unsigned64 alu64subc_val = (VAL);					\
  ALU64_ADDC_C (~alu64subc_val, 1);					\
} while (0)

#define ALU_SUBC XCONCAT3(ALU,WITH_TARGET_WORD_BITSIZE,_SUBC)



/* Compound operation - subtract carrying (and overflowing), extended */

#define ALU8_SUBC_X(VAL,C)						\
do {									\
  unsigned8 alu8subcx_val = (VAL);					\
  unsigned8 alu8subcx_c = (C);						\
  ALU8_ADDC_C (~alu8subcx_val, alu8subcx_c);				\
} while (0)

#define ALU16_SUBC_X(VAL,C)						\
do {									\
  unsigned16 alu16subcx_val = (VAL);					\
  unsigned16 alu16subcx_c = (C);					\
  ALU16_ADDC_C (~alu16subcx_val, alu16subcx_c);				\
} while (0)

#define ALU32_SUBC_X(VAL,C)						\
do {									\
  unsigned32 alu32subcx_val = (VAL);					\
  unsigned32 alu32subcx_c = (C);					\
  ALU32_ADDC_C (~alu32subcx_val, alu32subcx_c);				\
} while (0)

#define ALU64_SUBC_X(VAL,C)						\
do {									\
  unsigned64 alu64subcx_val = (VAL);					\
  unsigned64 alu64subcx_c = (C);					\
  ALU64_ADDC_C (~alu64subcx_val, alu64subcx_c);				\
} while (0)

#define ALU_SUBC_X XCONCAT3(ALU,WITH_TARGET_WORD_BITSIZE,_SUBC_X)



/* Basic operation - subtract borrowing (and overflowing) */

#define ALU8_SUBB(VAL)							\
do {									\
  unsigned8 alu8subb_val = (VAL);					\
  alu8_cr -= (unsigned)(unsigned8)alu8subb_val;				\
  alu8_vr -= (signed)(signed8)alu8subb_val;				\
} while (0)

#define ALU16_SUBB(VAL)							\
do {									\
  unsigned16 alu16subb_val = (VAL);					\
  alu16_cr -= (unsigned)(unsigned16)alu16subb_val;			\
  alu16_vr -= (signed)(signed16)alu16subb_val;				\
} while (0)

#define ALU32_SUBB(VAL)							\
do {									\
  unsigned32 alu32subb_val = (VAL);					\
  unsigned32 alu32subb_sign = alu32subb_val ^ alu32_r;			\
  alu32_c = (alu32_r < alu32subb_val);					\
  alu32_r -= (alu32subb_val);						\
  alu32_v = ((alu32subb_sign ^ - (unsigned32)alu32_c) ^ alu32_r) >> 31;	\
} while (0)

#define ALU64_SUBB(VAL)							\
do {									\
  unsigned64 alu64subb_val = (VAL);					\
  unsigned64 alu64subb_sign = alu64subb_val ^ alu64_r;			\
  alu64_c = (alu64_r < alu64subb_val);					\
  alu64_r -= (alu64subb_val);						\
  alu64_v = ((alu64subb_sign ^ - (unsigned64)alu64_c) ^ alu64_r) >> 31;	\
} while (0)

#define ALU_SUBB XCONCAT3(ALU,WITH_TARGET_WORD_BITSIZE,_SUBB)



/* Compound operation - subtract borrowing (and overflowing) with borrow-in */

#define ALU8_SUBB_B(VAL,B)						\
do {									\
  unsigned8 alu8subbb_val = (VAL);					\
  unsigned8 alu8subbb_b = (B);						\
  alu8_cr -= (unsigned)(unsigned8)alu8subbb_val;			\
  alu8_cr -= (unsigned)(unsigned8)alu8subbb_b;				\
  alu8_vr -= (signed)(signed8)alu8subbb_val + alu8subbb_b;		\
} while (0)

#define ALU16_SUBB_B(VAL,B)						\
do {									\
  unsigned16 alu16subbb_val = (VAL);					\
  unsigned16 alu16subbb_b = (B);					\
  alu16_cr -= (unsigned)(unsigned16)alu16subbb_val;			\
  alu16_cr -= (unsigned)(unsigned16)alu16subbb_b;			\
  alu16_vr -= (signed)(signed16)alu16subbb_val + alu16subbb_b;		\
} while (0)

#define ALU32_SUBB_B(VAL,B)						\
do {									\
  unsigned32 alu32subbb_val = (VAL);					\
  unsigned32 alu32subbb_b = (B);					\
  ALU32_ADDC_C (~alu32subbb_val, !alu32subbb_b);			\
  alu32_c = !alu32_c;							\
} while (0)

#define ALU64_SUBB_B(VAL,B)						\
do {									\
  unsigned64 alu64subbb_val = (VAL);					\
  unsigned64 alu64subbb_b = (B);					\
  ALU64_ADDC_C (~alu64subbb_val, !alu64subbb_b);			\
  alu64_c = !alu64_c;							\
} while (0)

#define ALU_SUBB_B XCONCAT3(ALU,WITH_TARGET_WORD_BITSIZE,_SUBB_B)



/* Basic operation - negate (overflowing) */

#define ALU8_NEG()							\
do {									\
  signed alu8neg_val = (ALU8_RESULT);					\
  ALU8_SET (1);								\
  ALU8_ADDC (~alu8neg_val);						\
} while (0)

#define ALU16_NEG()							\
do {									\
  signed alu16neg_val = (ALU16_RESULT);				\
  ALU16_SET (1);							\
  ALU16_ADDC (~alu16neg_val);						\
} while (0)

#define ALU32_NEG()							\
do {									\
  unsigned32 alu32neg_val = (ALU32_RESULT);				\
  ALU32_SET (1);							\
  ALU32_ADDC (~alu32neg_val);						\
} while(0)

#define ALU64_NEG()							\
do {									\
  unsigned64 alu64neg_val = (ALU64_RESULT);				\
  ALU64_SET (1);							\
  ALU64_ADDC (~alu64neg_val);						\
} while (0)

#define ALU_NEG XCONCAT3(ALU,WITH_TARGET_WORD_BITSIZE,_NEG)




/* Basic operation - negate carrying (and overflowing) */

#define ALU8_NEGC()							\
do {									\
  signed alu8negc_val = (ALU8_RESULT);					\
  ALU8_SET (1);								\
  ALU8_ADDC (~alu8negc_val);						\
} while (0)

#define ALU16_NEGC()							\
do {									\
  signed alu16negc_val = (ALU16_RESULT);				\
  ALU16_SET (1);							\
  ALU16_ADDC (~alu16negc_val);						\
} while (0)

#define ALU32_NEGC()							\
do {									\
  unsigned32 alu32negc_val = (ALU32_RESULT);				\
  ALU32_SET (1);							\
  ALU32_ADDC (~alu32negc_val);						\
} while(0)

#define ALU64_NEGC()							\
do {									\
  unsigned64 alu64negc_val = (ALU64_RESULT);				\
  ALU64_SET (1);							\
  ALU64_ADDC (~alu64negc_val);						\
} while (0)

#define ALU_NEGC XCONCAT3(ALU,WITH_TARGET_WORD_BITSIZE,_NEGC)




/* Basic operation - negate borrowing (and overflowing) */

#define ALU8_NEGB()							\
do {									\
  signed alu8negb_val = (ALU8_RESULT);					\
  ALU8_SET (0);								\
  ALU8_SUBB (alu8negb_val);						\
} while (0)

#define ALU16_NEGB()							\
do {									\
  signed alu16negb_val = (ALU16_RESULT);				\
  ALU16_SET (0);							\
  ALU16_SUBB (alu16negb_val);						\
} while (0)

#define ALU32_NEGB()							\
do {									\
  unsigned32 alu32negb_val = (ALU32_RESULT);				\
  ALU32_SET (0);							\
  ALU32_SUBB (alu32negb_val);						\
} while(0)

#define ALU64_NEGB()							\
do {									\
  unsigned64 alu64negb_val = (ALU64_RESULT);				\
  ALU64_SET (0);							\
  ALU64_SUBB (alu64negb_val);						\
} while (0)

#define ALU_NEGB XCONCAT3(ALU,WITH_TARGET_WORD_BITSIZE,_NEGB)




/* Other */

#define ALU8_OR(VAL)							\
do {									\
  error("ALU16_OR");							\
} while (0)

#define ALU16_OR(VAL)							\
do {									\
  error("ALU16_OR");							\
} while (0)

#define ALU32_OR(VAL)							\
do {									\
  alu32_r |= (VAL);							\
  alu32_c = 0;								\
  alu32_v = 0;								\
} while (0)

#define ALU64_OR(VAL)							\
do {									\
  alu64_r |= (VAL);							\
  alu64_c = 0;								\
  alu64_v = 0;								\
} while (0)

#define ALU_OR(VAL) XCONCAT3(ALU,WITH_TARGET_WORD_BITSIZE,_OR)(VAL)



#define ALU16_XOR(VAL)							\
do {									\
  error("ALU16_XOR");							\
} while (0)

#define ALU32_XOR(VAL)							\
do {									\
  alu32_r ^= (VAL);							\
  alu32_c = 0;								\
  alu32_v = 0;								\
} while (0)

#define ALU64_XOR(VAL)							\
do {									\
  alu64_r ^= (VAL);							\
  alu64_c = 0;								\
  alu64_v = 0;								\
} while (0)

#define ALU_XOR(VAL) XCONCAT3(ALU,WITH_TARGET_WORD_BITSIZE,_XOR)(VAL)




#define ALU16_AND(VAL)							\
do {									\
  error("ALU_AND16");							\
} while (0)

#define ALU32_AND(VAL)							\
do {									\
  alu32_r &= (VAL);							\
  alu32_c = 0;								\
  alu32_v = 0;								\
} while (0)

#define ALU64_AND(VAL)							\
do {									\
  alu64_r &= (VAL);							\
  alu64_c = 0;								\
  alu64_v = 0;								\
} while (0)

#define ALU_AND(VAL) XCONCAT3(ALU,WITH_TARGET_WORD_BITSIZE,_AND)(VAL)




#define ALU16_NOT(VAL)							\
do {									\
  error("ALU_NOT16");							\
} while (0)

#define ALU32_NOT							\
do {									\
  alu32_r = ~alu32_r;							\
  alu32_c = 0;								\
  alu32_v = 0;								\
} while (0)

#define ALU64_NOT							\
do {									\
  alu64_r = ~alu64_r;							\
  alu64_c = 0;								\
  alu64_v = 0;								\
} while (0)

#define ALU_NOT XCONCAT3(ALU,WITH_TARGET_WORD_BITSIZE,_NOT)

#endif
@


1.12
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright 2002, 2007-2012 Free Software Foundation, Inc.
@


1.11
log
@2011-10-14  Alexey Makhalov  <makhaloff@@gmail.com>

	* sim-alu.h (ALU32_AND): Clear carry flag.
	(ALU32_AND): Clear carry flag.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.11.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright 2002, 2007-2012 Free Software Foundation, Inc.
@


1.10
log
@sim: common: trim trailing whitespace
@
text
@d1010 1
a1010 1
  alu32_r = 0;								\
d1017 1
a1017 1
  alu64_r = 0;								\
@


1.9
log
@run copyright.sh for 2011.
@
text
@d85 1
a85 1
   
d96 2
a97 2
   
   
d138 1
a138 1
   
d157 1
a157 1
   Un: UMAXn + 1.  Unsigned arithmetic is computed `modulo (Un)'.  
d196 1
a196 1
  
d244 1
a244 1
  
d267 1
a267 1
       00 |  0  0 
d278 1
a278 1
         I  X  Y  R | C | X&Y  X&~R Y&~R 
@


1.8
log
@Update copyright notices to add year 2010.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.7
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.6
log
@	Updated copyright notices for most files.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008 Free Software Foundation, Inc.
@


1.5
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d3 1
a3 1
   Copyright 2002, 2007 Free Software Foundation, Inc.
@


1.4
log
@Copyright updates for 2007.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.3
log
@2002-11-22  Andrew Cagney  <ac131313@@redhat.com>

	* dv-core.c: Update copyright.  sim/common contributed to the FSF.
	* dv-glue.c, dv-pal.c, hw-base.c, hw-base.h, hw-device.c: Ditto.
	* hw-device.h, hw-handles.c, hw-handles.h: Ditto.
	* hw-instances.c, hw-instances.h, hw-properties.c: Ditto.
	* hw-properties.h, hw-tree.c, hw-tree.h, sim-alu.h: Ditto.
	* sim-basics.h, sim-bits.c, sim-bits.h, sim-config.c: Ditto.
	* sim-config.h, sim-core.c, sim-core.h, sim-endian.c: Ditto.
	* sim-endian.h, sim-events.c, sim-events.h, sim-inline.c: Ditto.
	* sim-inline.h, sim-io.c, sim-io.h, sim-n-bits.h: Ditto.
	* sim-n-core.h, sim-n-endian.h, sim-types.h: Ditto.
@
text
@d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
@


1.2
log
@2002-02-10  Chris Demetriou  <cgd@@broadcom.com>

        * callback.c: Fix some spelling errors.
        * hw-device.h: Likewise.
        * hw-tree.c: Likewise.
        * sim-abort.c: Likewise.
        * sim-alu.h: Likewise.
        * sim-core.h: Likewise.
        * sim-events.c: Likewise.
        * sim-events.h: Likewise.
        * sim-fpu.h: Likewise.
        * sim-profile.h: Likewise.
        * sim-utils.c: Likewise.
@
text
@d1 1
a1 1
/*  This file is part of the program psim.
d3 1
a3 2
    Copyright (C) 1994-1996, Andrew Cagney <cagney@@highland.com.au>
    Copyright (C) 1997, Free Software Foundation, Inc.
d5 18
a22 15
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
    */
@


1.2.18.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1 1
a1 1
/* The common simulator framework for GDB, the GNU Debugger.
d3 2
a4 1
   Copyright 2002 Free Software Foundation, Inc.
d6 15
a20 18
   Contributed by Andrew Cagney and Red Hat.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d1 1
a1 1
/* The common simulator framework for GDB, the GNU Debugger.
d3 2
a4 1
   Copyright 2002 Free Software Foundation, Inc.
d6 15
a20 18
   Contributed by Andrew Cagney and Red Hat.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.2.14.1
log
@2002-11-22  Andrew Cagney  <ac131313@@redhat.com>

	* dv-core.c: Update copyright.  sim/common contributed to the FSF.
	* dv-glue.c, dv-pal.c, hw-base.c, hw-base.h, hw-device.c: Ditto.
	* hw-device.h, hw-handles.c, hw-handles.h: Ditto.
	* hw-instances.c, hw-instances.h, hw-properties.c: Ditto.
	* hw-properties.h, hw-tree.c, hw-tree.h, sim-alu.h: Ditto.
	* sim-basics.h, sim-bits.c, sim-bits.h, sim-config.c: Ditto.
	* sim-config.h, sim-core.c, sim-core.h, sim-endian.c: Ditto.
	* sim-endian.h, sim-events.c, sim-events.h, sim-inline.c: Ditto.
	* sim-inline.h, sim-io.c, sim-io.h, sim-n-bits.h: Ditto.
	* sim-n-core.h, sim-n-endian.h, sim-types.h: Ditto.
@
text
@d1 1
a1 1
/* The common simulator framework for GDB, the GNU Debugger.
d3 2
a4 1
   Copyright 2002 Free Software Foundation, Inc.
d6 15
a20 18
   Contributed by Andrew Cagney and Red Hat.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.1
log
@Initial revision
@
text
@d39 1
a39 1
   aritmetic performed.  Ex:
d76 1
a76 1
   	occured.
d87 2
a88 2
   	overflow or underflow (also refered to as carry and borrow)
   	occured.
d135 1
a135 1
/* Twos complement aritmetic - addition/subtraction - carry/borrow
d157 1
a157 1
   Un: UMAXn + 1.  Unsigned arrithmetic is computed `modulo (Un)'.  
d159 1
a159 1
   X[p]: Is bit P of X.  X[0] denotes the least signifant bit.
d170 1
a170 1
   arrithmetic.  i.e. given X,Y in [MINn..MAXn]; overflow
d182 1
a182 1
   Overflow occures when the sign (most significant bit) of the two N
d194 1
a194 1
   added.  Overflow occures when SIGN_BIT<n> and SIGN_BIT<m> do not
d206 1
a206 1
   added.  Overflow occures when the result is outside of the sign
d238 1
a238 1
   Carry (poorly named) indicates that an overflow occured for
d296 1
a296 1
   arrithmetic.  Carry is indicated by bit (1 << N) being set (result
d317 1
a317 1
   Consider Y when carry occures:
d320 1
a320 1
	==>	(Un - X) <= Y < Un               # re-arange
d324 1
a324 1
   or when carry as occured:
d328 1
a328 1
   Consider Y when carry does not occure:
d335 1
a335 1
   or when carry has not occured:
d339 1
a339 1
   hence we get carry by computing in N bit unsigned arrithmetic.
d363 1
a363 1
   succeeding extended prrcision calculations, the more general
d419 1
a419 1
   underflow) occures when:
d494 1
a494 1
   Since most hosts do not support 64 (> 32) bit arrithmetic, carry
d521 1
a521 1
   arrithmetic, it is still used. */
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@

