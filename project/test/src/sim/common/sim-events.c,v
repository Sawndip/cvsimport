head	1.16;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.16
	gdb_7_6-2013-04-26-release:1.16
	gdb_7_6-branch:1.16.0.2
	gdb_7_6-2013-03-12-branchpoint:1.16
	gdb_7_5_1-2012-11-29-release:1.15
	gdb_7_5-2012-08-17-release:1.15
	gdb_7_5-branch:1.15.0.2
	gdb_7_5-2012-07-18-branchpoint:1.15
	gdb_7_4_1-2012-04-26-release:1.14.2.1
	gdb_7_4-2012-01-24-release:1.14.2.1
	gdb_7_4-branch:1.14.0.2
	gdb_7_4-2011-12-13-branchpoint:1.14
	gdb_7_3_1-2011-09-04-release:1.13
	gdb_7_3-2011-07-26-release:1.13
	gdb_7_3-branch:1.13.0.2
	gdb_7_3-2011-04-01-branchpoint:1.13
	gdb_7_2-2010-09-02-release:1.11
	gdb_7_2-branch:1.11.0.4
	gdb_7_2-2010-07-07-branchpoint:1.11
	gdb_7_1-2010-03-18-release:1.11
	gdb_7_1-branch:1.11.0.2
	gdb_7_1-2010-02-18-branchpoint:1.11
	gdb_7_0_1-2009-12-22-release:1.10
	gdb_7_0-2009-10-06-release:1.10
	gdb_7_0-branch:1.10.0.4
	gdb_7_0-2009-09-16-branchpoint:1.10
	arc-sim-20090309:1.9
	msnyder-checkpoint-072509-branch:1.10.0.2
	msnyder-checkpoint-072509-branchpoint:1.10
	arc-insight_6_8-branch:1.9.0.16
	arc-insight_6_8-branchpoint:1.9
	insight_6_8-branch:1.9.0.14
	insight_6_8-branchpoint:1.9
	reverse-20081226-branch:1.9.0.12
	reverse-20081226-branchpoint:1.9
	multiprocess-20081120-branch:1.9.0.10
	multiprocess-20081120-branchpoint:1.9
	reverse-20080930-branch:1.9.0.8
	reverse-20080930-branchpoint:1.9
	reverse-20080717-branch:1.9.0.6
	reverse-20080717-branchpoint:1.9
	msnyder-reverse-20080609-branch:1.9.0.4
	msnyder-reverse-20080609-branchpoint:1.9
	drow-reverse-20070409-branch:1.7.0.2
	drow-reverse-20070409-branchpoint:1.7
	gdb_6_8-2008-03-27-release:1.9
	gdb_6_8-branch:1.9.0.2
	gdb_6_8-2008-02-26-branchpoint:1.9
	gdb_6_7_1-2007-10-29-release:1.8
	gdb_6_7-2007-10-10-release:1.8
	gdb_6_7-branch:1.8.0.2
	gdb_6_7-2007-09-07-branchpoint:1.8
	insight_6_6-20070208-release:1.6
	gdb_6_6-2006-12-18-release:1.6
	gdb_6_6-branch:1.6.0.88
	gdb_6_6-2006-11-15-branchpoint:1.6
	insight_6_5-20061003-release:1.6
	gdb-csl-symbian-6_4_50_20060226-12:1.6
	gdb-csl-sourcerygxx-3_4_4-25:1.6
	nickrob-async-20060828-mergepoint:1.6
	gdb-csl-symbian-6_4_50_20060226-11:1.6
	gdb-csl-sourcerygxx-4_1-17:1.6
	gdb-csl-20060226-branch-local-2:1.6
	gdb-csl-sourcerygxx-4_1-14:1.6
	gdb-csl-sourcerygxx-4_1-13:1.6
	gdb-csl-sourcerygxx-4_1-12:1.6
	gdb-csl-sourcerygxx-3_4_4-21:1.6
	gdb_6_5-20060621-release:1.6
	gdb-csl-sourcerygxx-4_1-9:1.6
	gdb-csl-sourcerygxx-4_1-8:1.6
	gdb-csl-sourcerygxx-4_1-7:1.6
	gdb-csl-arm-2006q1-6:1.6
	gdb-csl-sourcerygxx-4_1-6:1.6
	gdb-csl-symbian-6_4_50_20060226-10:1.6
	gdb-csl-symbian-6_4_50_20060226-9:1.6
	gdb-csl-symbian-6_4_50_20060226-8:1.6
	gdb-csl-coldfire-4_1-11:1.6
	gdb-csl-sourcerygxx-3_4_4-19:1.6
	gdb-csl-coldfire-4_1-10:1.6
	gdb_6_5-branch:1.6.0.86
	gdb_6_5-2006-05-14-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-5:1.6
	nickrob-async-20060513-branch:1.6.0.84
	nickrob-async-20060513-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-4:1.6
	msnyder-reverse-20060502-branch:1.6.0.82
	msnyder-reverse-20060502-branchpoint:1.6
	gdb-csl-morpho-4_1-4:1.6
	gdb-csl-sourcerygxx-3_4_4-17:1.6
	readline_5_1-import-branch:1.6.0.80
	readline_5_1-import-branchpoint:1.6
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.6
	gdb-csl-symbian-20060226-branch:1.6.0.78
	gdb-csl-symbian-20060226-branchpoint:1.6
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.6
	msnyder-reverse-20060331-branch:1.6.0.76
	msnyder-reverse-20060331-branchpoint:1.6
	gdb-csl-available-20060303-branch:1.6.0.74
	gdb-csl-available-20060303-branchpoint:1.6
	gdb-csl-20060226-branch:1.6.0.72
	gdb-csl-20060226-branchpoint:1.6
	gdb_6_4-20051202-release:1.6
	msnyder-fork-checkpoint-branch:1.6.0.70
	msnyder-fork-checkpoint-branchpoint:1.6
	gdb-csl-gxxpro-6_3-branch:1.6.0.68
	gdb-csl-gxxpro-6_3-branchpoint:1.6
	gdb_6_4-branch:1.6.0.66
	gdb_6_4-2005-11-01-branchpoint:1.6
	gdb-csl-arm-20051020-branch:1.6.0.64
	gdb-csl-arm-20051020-branchpoint:1.6
	msnyder-tracepoint-checkpoint-branch:1.6.0.62
	msnyder-tracepoint-checkpoint-branchpoint:1.6
	gdb-csl-arm-20050325-2005-q1b:1.6
	gdb-csl-arm-20050325-2005-q1a:1.6
	csl-arm-20050325-branch:1.6.0.60
	csl-arm-20050325-branchpoint:1.6
	gdb_6_3-20041109-release:1.6
	gdb_6_3-branch:1.6.0.56
	gdb_6_3-20041019-branchpoint:1.6
	drow_intercu-merge-20040921:1.6
	drow_intercu-merge-20040915:1.6
	jimb-gdb_6_2-e500-branch:1.6.0.58
	jimb-gdb_6_2-e500-branchpoint:1.6
	gdb_6_2-20040730-release:1.6
	gdb_6_2-branch:1.6.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.6
	gdb_6_1_1-20040616-release:1.6
	gdb_6_1-2004-04-05-release:1.6
	drow_intercu-merge-20040402:1.6
	drow_intercu-merge-20040327:1.6
	ezannoni_pie-20040323-branch:1.6.0.52
	ezannoni_pie-20040323-branchpoint:1.6
	cagney_tramp-20040321-mergepoint:1.6
	cagney_tramp-20040309-branch:1.6.0.50
	cagney_tramp-20040309-branchpoint:1.6
	gdb_6_1-branch:1.6.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	drow_intercu-20040221-branch:1.6.0.46
	drow_intercu-20040221-branchpoint:1.6
	cagney_bfdfile-20040213-branch:1.6.0.44
	cagney_bfdfile-20040213-branchpoint:1.6
	drow-cplus-merge-20040208:1.6
	carlton_dictionary-20040126-merge:1.6
	cagney_bigcore-20040122-branch:1.6.0.42
	cagney_bigcore-20040122-branchpoint:1.6
	drow-cplus-merge-20040113:1.6
	drow-cplus-merge-20031224:1.6
	drow-cplus-merge-20031220:1.6
	carlton_dictionary-20031215-merge:1.6
	drow-cplus-merge-20031214:1.6
	carlton-dictionary-20031111-merge:1.6
	gdb_6_0-2003-10-04-release:1.6
	kettenis_sparc-20030918-branch:1.6.0.40
	kettenis_sparc-20030918-branchpoint:1.6
	carlton_dictionary-20030917-merge:1.6
	ezannoni_pie-20030916-branchpoint:1.6
	ezannoni_pie-20030916-branch:1.6.0.38
	cagney_x86i386-20030821-branch:1.6.0.36
	cagney_x86i386-20030821-branchpoint:1.6
	carlton_dictionary-20030805-merge:1.6
	carlton_dictionary-20030627-merge:1.6
	gdb_6_0-branch:1.6.0.34
	gdb_6_0-2003-06-23-branchpoint:1.6
	jimb-ppc64-linux-20030613-branch:1.6.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.6
	cagney_convert-20030606-branch:1.6.0.30
	cagney_convert-20030606-branchpoint:1.6
	cagney_writestrings-20030508-branch:1.6.0.28
	cagney_writestrings-20030508-branchpoint:1.6
	jimb-ppc64-linux-20030528-branch:1.6.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.6
	carlton_dictionary-20030523-merge:1.6
	cagney_fileio-20030521-branch:1.6.0.24
	cagney_fileio-20030521-branchpoint:1.6
	kettenis_i386newframe-20030517-mergepoint:1.6
	jimb-ppc64-linux-20030509-branch:1.6.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.6
	kettenis_i386newframe-20030504-mergepoint:1.6
	carlton_dictionary-20030430-merge:1.6
	kettenis_i386newframe-20030419-branch:1.6.0.20
	kettenis_i386newframe-20030419-branchpoint:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	kettenis_i386newframe-20030406-branch:1.6.0.18
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.16
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.14
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.12
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.6
	offbyone-20030313-branch:1.6.0.10
	offbyone-20030313-branchpoint:1.6
	kettenis-i386newframe-20030308-branch:1.6.0.8
	kettenis-i386newframe-20030308-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.6
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.6
	interps-20030202-branch:1.6.0.4
	interps-20030202-branchpoint:1.6
	cagney-unwind-20030108-branch:1.6.0.2
	cagney-unwind-20030108-branchpoint:1.6
	carlton_dictionary-20021223-merge:1.6
	gdb_5_3-2002-12-12-release:1.5.6.1
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.10
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.8
	carlton_dictionary-20020920-branchpoint:1.5
	gdb_5_3-branch:1.5.0.6
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.4
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.2
	readline_4_3-import-branchpoint:1.5
	gdb_5_2_1-2002-07-23-release:1.4
	kseitz_interps-20020528-branch:1.4.0.8
	kseitz_interps-20020528-branchpoint:1.4
	cagney_regbuf-20020515-branch:1.4.0.6
	cagney_regbuf-20020515-branchpoint:1.4
	jimb-macro-020506-branch:1.4.0.4
	jimb-macro-020506-branchpoint:1.4
	gdb_5_2-2002-04-29-release:1.4
	gdb_5_2-branch:1.4.0.2
	gdb_5_2-2002-03-03-branchpoint:1.4
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.4
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.2
	gdb_5_1-2001-07-29-branchpoint:1.3
	insight-precleanup-2001-01-01:1.3
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.16
date	2013.01.01.06.41.33;	author brobecke;	state Exp;
branches;
next	1.15;

1.15
date	2012.01.04.08.28.06;	author brobecke;	state Exp;
branches;
next	1.14;

1.14
date	2011.05.11.20.02.42;	author vapier;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2011.03.15.03.16.17;	author vapier;	state Exp;
branches;
next	1.12;

1.12
date	2011.01.01.15.33.56;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2010.01.01.10.03.27;	author brobecke;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.14.10.53.06;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2008.01.01.22.53.23;	author drow;	state Exp;
branches;
next	1.8;

1.8
date	2007.08.24.14.28.35;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.09.17.59.16;	author drow;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.23.01.12.05;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.17.21.45.54;	author cagney;	state Exp;
branches
	1.5.6.1
	1.5.8.1
	1.5.10.1;
next	1.4;

1.4
date	2002.02.10.23.11.37;	author cgd;	state Exp;
branches
	1.4.6.1
	1.4.8.1;
next	1.3;

1.3
date	2000.07.27.11.37.34;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.28.06.13.46;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.57;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.14.2.1
date	2012.01.06.04.54.39;	author brobecke;	state Exp;
branches;
next	;

1.5.6.1
date	2002.11.23.01.12.34;	author cagney;	state Exp;
branches;
next	;

1.5.8.1
date	2002.12.23.19.39.53;	author carlton;	state Exp;
branches;
next	;

1.5.10.1
date	2003.12.14.20.28.19;	author drow;	state Exp;
branches;
next	;

1.4.6.1
date	2002.06.21.15.48.33;	author cagney;	state Exp;
branches;
next	;

1.4.8.1
date	2002.06.20.01.38.59;	author kseitz;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.57;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.31.39;	author shebs;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* The common simulator framework for GDB, the GNU Debugger.

   Copyright 2002-2013 Free Software Foundation, Inc.

   Contributed by Andrew Cagney and Red Hat.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */


#ifndef _SIM_EVENTS_C_
#define _SIM_EVENTS_C_

#include "sim-main.h"
#include "sim-assert.h"

#ifdef HAVE_STRING_H
#include <string.h>
#else
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif
#endif

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#include <signal.h> /* For SIGPROCMASK et al. */

typedef enum {
  watch_invalid,

  /* core - target byte order */
  watch_core_targ_1,
  watch_core_targ_2,
  watch_core_targ_4,
  watch_core_targ_8,
  /* core - big-endian */
  watch_core_be_1,
  watch_core_be_2,
  watch_core_be_4,
  watch_core_be_8,
  /* core - little-endian */
  watch_core_le_1,
  watch_core_le_2,
  watch_core_le_4,
  watch_core_le_8,

  /* sim - host byte order */
  watch_sim_host_1,
  watch_sim_host_2,
  watch_sim_host_4,
  watch_sim_host_8,
  /* sim - big-endian */
  watch_sim_be_1,
  watch_sim_be_2,
  watch_sim_be_4,
  watch_sim_be_8,
  /* sim - little-endian */
  watch_sim_le_1,
  watch_sim_le_2,
  watch_sim_le_4,
  watch_sim_le_8,

  /* wallclock */
  watch_clock,

  /* timer */
  watch_timer,
} sim_event_watchpoints;


struct _sim_event {
  sim_event_watchpoints watching;
  void *data;
  sim_event_handler *handler;
  /* timer event */
  signed64 time_of_event;
  /* watch wallclock event */
  unsigned wallclock;
  /* watch core address */
  address_word core_addr;
  unsigned core_map;
  /* watch sim addr */
  void *host_addr;
  /* watch core/sim range */
  int is_within; /* 0/1 */
  unsigned ub;
  unsigned lb;
  unsigned64 ub64;
  unsigned64 lb64;
  /* trace info (if any) */
  char *trace;
  /* list */
  sim_event *next;
};


/* The event queue maintains a single absolute time using two
   variables.

   TIME_OF_EVENT: this holds the time at which the next event is ment
   to occur.  If no next event it will hold the time of the last
   event.

   TIME_FROM_EVENT: The current distance from TIME_OF_EVENT.  A value
   <= 0 (except when poll-event is being processed) indicates that
   event processing is due.  This variable is decremented once for
   each iteration of a clock cycle.

   Initially, the clock is started at time one (0) with TIME_OF_EVENT
   == 0 and TIME_FROM_EVENT == 0 and with NR_TICKS_TO_PROCESS == 1.

   Clearly there is a bug in that this code assumes that the absolute
   time counter will never become greater than 2^62.

   To avoid the need to use 64bit arithmetic, the event queue always
   contains at least one event scheduled every 16 000 ticks.  This
   limits the time from event counter to values less than
   16 000. */


#if !defined (SIM_EVENTS_POLL_RATE)
#define SIM_EVENTS_POLL_RATE 0x1000
#endif


#define _ETRACE sd, NULL

#undef ETRACE_P
#define ETRACE_P (WITH_TRACE && STATE_EVENTS (sd)->trace)

#undef ETRACE
#define ETRACE(ARGS) \
do \
  { \
    if (ETRACE_P) \
      { \
        if (STRACE_DEBUG_P (sd)) \
	  { \
	    const char *file; \
	    SIM_FILTER_PATH (file, __FILE__); \
	    trace_printf (sd, NULL, "%s:%d: ", file, __LINE__); \
	  } \
        trace_printf  ARGS; \
      } \
  } \
while (0)


/* event queue iterator - don't iterate over the held queue. */

#if EXTERN_SIM_EVENTS_P
static sim_event **
next_event_queue (SIM_DESC sd,
		  sim_event **queue)
{
  if (queue == NULL)
    return &STATE_EVENTS (sd)->queue;
  else if (queue == &STATE_EVENTS (sd)->queue)
    return &STATE_EVENTS (sd)->watchpoints;
  else if (queue == &STATE_EVENTS (sd)->watchpoints)
    return &STATE_EVENTS (sd)->watchedpoints;
  else if (queue == &STATE_EVENTS (sd)->watchedpoints)
    return NULL;
  else
    sim_io_error (sd, "next_event_queue - bad queue");
  return NULL;
}
#endif


STATIC_INLINE_SIM_EVENTS\
(void)
sim_events_poll (SIM_DESC sd,
		 void *data)
{
  /* just re-schedule in 1000 million ticks time */
  sim_events_schedule (sd, SIM_EVENTS_POLL_RATE, sim_events_poll, sd);
  sim_io_poll_quit (sd);
}


/* "events" module install handler.
   This is called via sim_module_install to install the "events" subsystem
   into the simulator.  */

#if EXTERN_SIM_EVENTS_P
STATIC_SIM_EVENTS (MODULE_UNINSTALL_FN) sim_events_uninstall;
STATIC_SIM_EVENTS (MODULE_INIT_FN) sim_events_init;
STATIC_SIM_EVENTS (MODULE_RESUME_FN) sim_events_resume;
STATIC_SIM_EVENTS (MODULE_SUSPEND_FN) sim_events_suspend;
#endif

#if EXTERN_SIM_EVENTS_P
SIM_RC
sim_events_install (SIM_DESC sd)
{
  SIM_ASSERT (STATE_MAGIC (sd) == SIM_MAGIC_NUMBER);
  sim_module_add_uninstall_fn (sd, sim_events_uninstall);
  sim_module_add_init_fn (sd, sim_events_init);
  sim_module_add_resume_fn (sd, sim_events_resume);
  sim_module_add_suspend_fn (sd, sim_events_suspend);
  return SIM_RC_OK;
}
#endif


/* Suspend/resume the event queue manager when the simulator is not
   running */

#if EXTERN_SIM_EVENTS_P
static SIM_RC
sim_events_resume (SIM_DESC sd)
{
  sim_events *events = STATE_EVENTS (sd);
  SIM_ASSERT (STATE_MAGIC (sd) == SIM_MAGIC_NUMBER);
  SIM_ASSERT (events->resume_wallclock == 0);
  events->resume_wallclock = sim_elapsed_time_get ();
  return SIM_RC_OK;
}
#endif

#if EXTERN_SIM_EVENTS_P
static SIM_RC
sim_events_suspend (SIM_DESC sd)
{
  sim_events *events = STATE_EVENTS (sd);
  SIM_ASSERT (STATE_MAGIC (sd) == SIM_MAGIC_NUMBER);
  SIM_ASSERT (events->resume_wallclock != 0);
  events->elapsed_wallclock += sim_elapsed_time_since (events->resume_wallclock);
  events->resume_wallclock = 0;
  return SIM_RC_OK;
}
#endif


/* Uninstall the "events" subsystem from the simulator.  */

#if EXTERN_SIM_EVENTS_P
static void
sim_events_uninstall (SIM_DESC sd)
{
  SIM_ASSERT (STATE_MAGIC (sd) == SIM_MAGIC_NUMBER);
  /* FIXME: free buffers, etc. */
}
#endif


/* malloc/free */

#if EXTERN_SIM_EVENTS_P
static sim_event *
sim_events_zalloc (SIM_DESC sd)
{
  sim_events *events = STATE_EVENTS (sd);
  sim_event *new = events->free_list;
  if (new != NULL)
    {
      events->free_list = new->next;
      memset (new, 0, sizeof (*new));
    }
  else
    {
#if defined (HAVE_SIGPROCMASK) && defined (SIG_SETMASK)
      /*-LOCK-*/
      sigset_t old_mask;
      sigset_t new_mask;
      sigfillset (&new_mask);
      sigprocmask (SIG_SETMASK, &new_mask, &old_mask);
#endif
      new = ZALLOC (sim_event);
#if defined (HAVE_SIGPROCMASK) && defined (SIG_SETMASK)
      /*-UNLOCK-*/
      sigprocmask (SIG_SETMASK, &old_mask, NULL);
#endif
    }
  return new;
}
#endif

STATIC_INLINE_SIM_EVENTS\
(void)
sim_events_free (SIM_DESC sd,
		 sim_event *dead)
{
  sim_events *events = STATE_EVENTS (sd);
  dead->next = events->free_list;
  events->free_list = dead;
  if (dead->trace != NULL)
    {
      free (dead->trace); /* NB: asprintf returns a `free' buf */
      dead->trace = NULL;
    }
}


/* Initialize the simulator event manager */

#if EXTERN_SIM_EVENTS_P
SIM_RC
sim_events_init (SIM_DESC sd)
{
  sim_events *events = STATE_EVENTS (sd);

  /* drain the interrupt queue */
  events->nr_held = 0;
  if (events->held == NULL)
    events->held = NZALLOC (sim_event, MAX_NR_SIGNAL_SIM_EVENTS);

  /* drain the normal queues */
  {
    sim_event **queue = NULL;
    while ((queue = next_event_queue (sd, queue)) != NULL)
      {
	if (queue == NULL) break;
	while (*queue != NULL)
	  {
	    sim_event *dead = *queue;
	    *queue = dead->next;
	    sim_events_free (sd, dead);
	  }
	*queue = NULL;
      }
  }

  /* wind time back to zero */
  events->nr_ticks_to_process = 1; /* start by doing queue */
  events->time_of_event = 0;
  events->time_from_event = 0;
  events->elapsed_wallclock = 0;
  events->resume_wallclock = 0;

  /* schedule our initial counter event */
  sim_events_schedule (sd, 0, sim_events_poll, sd);

  /* from now on, except when the large-int event is being processed
     the event queue is non empty */
  SIM_ASSERT (events->queue != NULL);

  return SIM_RC_OK;
}
#endif


INLINE_SIM_EVENTS\
(signed64)
sim_events_time (SIM_DESC sd)
{
  sim_events *events = STATE_EVENTS (sd);
  return (events->time_of_event - events->time_from_event);
}


INLINE_SIM_EVENTS\
(unsigned long)
sim_events_elapsed_time (SIM_DESC sd)
{
  unsigned long elapsed = STATE_EVENTS (sd)->elapsed_wallclock;

  /* Are we being called inside sim_resume?
     (Is there a simulation in progress?)  */
  if (STATE_EVENTS (sd)->resume_wallclock != 0)
     elapsed += sim_elapsed_time_since (STATE_EVENTS (sd)->resume_wallclock);

  return elapsed;
}


/* Returns the time that remains before the event is raised. */
INLINE_SIM_EVENTS\
(signed64)
sim_events_remain_time (SIM_DESC sd, sim_event *event)
{
  if (event == 0)
    return 0;

  return (event->time_of_event - sim_events_time (sd));
}



STATIC_INLINE_SIM_EVENTS\
(void)
update_time_from_event (SIM_DESC sd)
{
  sim_events *events = STATE_EVENTS (sd);
  signed64 current_time = sim_events_time (sd);
  if (events->queue != NULL)
    {
      events->time_of_event = events->queue->time_of_event;
      events->time_from_event = (events->queue->time_of_event - current_time);
    }
  else
    {
      events->time_of_event = current_time - 1;
      events->time_from_event = -1;
    }
  if (ETRACE_P)
    {
      sim_event *event;
      int i;
      for (event = events->queue, i = 0;
	   event != NULL;
	   event = event->next, i++)
	{
	  ETRACE ((_ETRACE,
		   "event time-from-event - time %ld, delta %ld - event %d, tag 0x%lx, time %ld, handler 0x%lx, data 0x%lx%s%s\n",
		   (long)current_time,
		   (long)events->time_from_event,
		   i,
		   (long)event,
		   (long)event->time_of_event,
		   (long)event->handler,
		   (long)event->data,
		   (event->trace != NULL) ? ", " : "",
		   (event->trace != NULL) ? event->trace : ""));
	}
    }
  SIM_ASSERT (current_time == sim_events_time (sd));
}


#if EXTERN_SIM_EVENTS_P
static void
insert_sim_event (SIM_DESC sd,
		  sim_event *new_event,
		  signed64 delta)
{
  sim_events *events = STATE_EVENTS (sd);
  sim_event *curr;
  sim_event **prev;
  signed64 time_of_event;

  if (delta < 0)
    sim_io_error (sd, "what is past is past!\n");

  /* compute when the event should occur */
  time_of_event = sim_events_time (sd) + delta;

  /* find the queue insertion point - things are time ordered */
  prev = &events->queue;
  curr = events->queue;
  while (curr != NULL && time_of_event >= curr->time_of_event)
    {
      SIM_ASSERT (curr->next == NULL
		  || curr->time_of_event <= curr->next->time_of_event);
      prev = &curr->next;
      curr = curr->next;
    }
  SIM_ASSERT (curr == NULL || time_of_event < curr->time_of_event);

  /* insert it */
  new_event->next = curr;
  *prev = new_event;
  new_event->time_of_event = time_of_event;

  /* adjust the time until the first event */
  update_time_from_event (sd);
}
#endif


#if EXTERN_SIM_EVENTS_P
sim_event *
sim_events_schedule (SIM_DESC sd,
		     signed64 delta_time,
		     sim_event_handler *handler,
		     void *data)
{
  va_list dummy;
  memset (&dummy, 0, sizeof dummy);
  return sim_events_schedule_vtracef (sd, delta_time, handler, data,
				      NULL, dummy);
}
#endif


#if EXTERN_SIM_EVENTS_P
sim_event *
sim_events_schedule_tracef (SIM_DESC sd,
			    signed64 delta_time,
			    sim_event_handler *handler,
			    void *data,
			    const char *fmt,
			    ...)
{
  sim_event *new_event;
  va_list ap;
  va_start (ap, fmt);
  new_event = sim_events_schedule_vtracef (sd, delta_time, handler, data, fmt, ap);
  va_end (ap);
  return new_event;
}
#endif


#if EXTERN_SIM_EVENTS_P
sim_event *
sim_events_schedule_vtracef (SIM_DESC sd,
			     signed64 delta_time,
			     sim_event_handler *handler,
			     void *data,
			     const char *fmt,
			     va_list ap)
{
  sim_event *new_event = sim_events_zalloc (sd);
  new_event->data = data;
  new_event->handler = handler;
  new_event->watching = watch_timer;
  if (fmt == NULL || !ETRACE_P || vasprintf (&new_event->trace, fmt, ap) < 0)
    new_event->trace = NULL;
  insert_sim_event (sd, new_event, delta_time);
  ETRACE ((_ETRACE,
	   "event scheduled at %ld - tag 0x%lx - time %ld, handler 0x%lx, data 0x%lx%s%s\n",
	   (long)sim_events_time (sd),
	   (long)new_event,
	   (long)new_event->time_of_event,
	   (long)new_event->handler,
	   (long)new_event->data,
	   (new_event->trace != NULL) ? ", " : "",
	   (new_event->trace != NULL) ? new_event->trace : ""));
  return new_event;
}
#endif


#if EXTERN_SIM_EVENTS_P
void
sim_events_schedule_after_signal (SIM_DESC sd,
				  signed64 delta_time,
				  sim_event_handler *handler,
				  void *data)
{
  sim_events *events = STATE_EVENTS (sd);
  sim_event *new_event;
#if defined (HAVE_SIGPROCMASK) && defined (SIG_SETMASK)
  /*-LOCK-*/
  sigset_t old_mask;
  sigset_t new_mask;
  sigfillset (&new_mask);
  sigprocmask (SIG_SETMASK, &new_mask, &old_mask);
#endif

  /* allocate an event entry from the signal buffer */
  new_event = &events->held [events->nr_held];
  events->nr_held ++;
  if (events->nr_held > MAX_NR_SIGNAL_SIM_EVENTS)
    {
      sim_engine_abort (NULL, NULL, NULL_CIA,
			"sim_events_schedule_after_signal - buffer oveflow");
    }

  new_event->data = data;
  new_event->handler = handler;
  new_event->time_of_event = delta_time; /* work it out later */
  new_event->next = NULL;

  events->work_pending = 1; /* notify main process */

#if defined (HAVE_SIGPROCMASK) && defined (SIG_SETMASK)
  /*-UNLOCK-*/
  sigprocmask (SIG_SETMASK, &old_mask, NULL);
#endif

  ETRACE ((_ETRACE,
	   "signal scheduled at %ld - tag 0x%lx - time %ld, handler 0x%lx, data 0x%lx\n",
	   (long)sim_events_time (sd),
	   (long)new_event,
	   (long)new_event->time_of_event,
	   (long)new_event->handler,
	   (long)new_event->data));
}
#endif


#if EXTERN_SIM_EVENTS_P
sim_event *
sim_events_watch_clock (SIM_DESC sd,
			unsigned delta_ms_time,
			sim_event_handler *handler,
			void *data)
{
  sim_events *events = STATE_EVENTS (sd);
  sim_event *new_event = sim_events_zalloc (sd);
  /* type */
  new_event->watching = watch_clock;
  /* handler */
  new_event->data = data;
  new_event->handler = handler;
  /* data */
  if (events->resume_wallclock == 0)
    new_event->wallclock = (events->elapsed_wallclock + delta_ms_time);
  else
    new_event->wallclock = (events->elapsed_wallclock
			    + sim_elapsed_time_since (events->resume_wallclock)
			    + delta_ms_time);
  /* insert */
  new_event->next = events->watchpoints;
  events->watchpoints = new_event;
  events->work_pending = 1;
  ETRACE ((_ETRACE,
	  "event watching clock at %ld - tag 0x%lx - wallclock %ld, handler 0x%lx, data 0x%lx\n",
	   (long)sim_events_time (sd),
	   (long)new_event,
	   (long)new_event->wallclock,
	   (long)new_event->handler,
	   (long)new_event->data));
  return new_event;
}
#endif


#if EXTERN_SIM_EVENTS_P
sim_event *
sim_events_watch_sim (SIM_DESC sd,
		      void *host_addr,
		      int nr_bytes,
		      int byte_order,
		      int is_within,
		      unsigned64 lb,
		      unsigned64 ub,
		      sim_event_handler *handler,
		      void *data)
{
  sim_events *events = STATE_EVENTS (sd);
  sim_event *new_event = sim_events_zalloc (sd);
  /* type */
  switch (byte_order)
    {
    case 0:
      switch (nr_bytes)
	{
	case 1: new_event->watching = watch_sim_host_1; break;
	case 2: new_event->watching = watch_sim_host_2; break;
	case 4: new_event->watching = watch_sim_host_4; break;
	case 8: new_event->watching = watch_sim_host_8; break;
	default: sim_io_error (sd, "sim_events_watch_sim - invalid nr bytes");
	}
      break;
    case BIG_ENDIAN:
      switch (nr_bytes)
	{
	case 1: new_event->watching = watch_sim_be_1; break;
	case 2: new_event->watching = watch_sim_be_2; break;
	case 4: new_event->watching = watch_sim_be_4; break;
	case 8: new_event->watching = watch_sim_be_8; break;
	default: sim_io_error (sd, "sim_events_watch_sim - invalid nr bytes");
	}
      break;
    case LITTLE_ENDIAN:
      switch (nr_bytes)
	{
	case 1: new_event->watching = watch_sim_le_1; break;
	case 2: new_event->watching = watch_sim_le_2; break;
	case 4: new_event->watching = watch_sim_le_4; break;
	case 8: new_event->watching = watch_sim_le_8; break;
	default: sim_io_error (sd, "sim_events_watch_sim - invalid nr bytes");
	}
      break;
    default:
      sim_io_error (sd, "sim_events_watch_sim - invalid byte order");
    }
  /* handler */
  new_event->data = data;
  new_event->handler = handler;
  /* data */
  new_event->host_addr = host_addr;
  new_event->lb = lb;
  new_event->lb64 = lb;
  new_event->ub = ub;
  new_event->ub64 = ub;
  new_event->is_within = (is_within != 0);
  /* insert */
  new_event->next = events->watchpoints;
  events->watchpoints = new_event;
  events->work_pending = 1;
  ETRACE ((_ETRACE,
	   "event watching host at %ld - tag 0x%lx - host-addr 0x%lx, 0x%lx..0x%lx, handler 0x%lx, data 0x%lx\n",
	   (long)sim_events_time (sd),
	   (long)new_event,
	   (long)new_event->host_addr,
	   (long)new_event->lb,
	   (long)new_event->ub,
	   (long)new_event->handler,
	   (long)new_event->data));
  return new_event;
}
#endif


#if EXTERN_SIM_EVENTS_P
sim_event *
sim_events_watch_core (SIM_DESC sd,
		       address_word core_addr,
		       unsigned core_map,
		       int nr_bytes,
		       int byte_order,
		       int is_within,
		       unsigned64 lb,
		       unsigned64 ub,
		       sim_event_handler *handler,
		       void *data)
{
  sim_events *events = STATE_EVENTS (sd);
  sim_event *new_event = sim_events_zalloc (sd);
  /* type */
  switch (byte_order)
    {
    case 0:
      switch (nr_bytes)
	{
	case 1: new_event->watching = watch_core_targ_1; break;
	case 2: new_event->watching = watch_core_targ_2; break;
	case 4: new_event->watching = watch_core_targ_4; break;
	case 8: new_event->watching = watch_core_targ_8; break;
	default: sim_io_error (sd, "sim_events_watch_core - invalid nr bytes");
	}
      break;
    case BIG_ENDIAN:
      switch (nr_bytes)
	{
	case 1: new_event->watching = watch_core_be_1; break;
	case 2: new_event->watching = watch_core_be_2; break;
	case 4: new_event->watching = watch_core_be_4; break;
	case 8: new_event->watching = watch_core_be_8; break;
	default: sim_io_error (sd, "sim_events_watch_core - invalid nr bytes");
	}
      break;
    case LITTLE_ENDIAN:
      switch (nr_bytes)
	{
	case 1: new_event->watching = watch_core_le_1; break;
	case 2: new_event->watching = watch_core_le_2; break;
	case 4: new_event->watching = watch_core_le_4; break;
	case 8: new_event->watching = watch_core_le_8; break;
	default: sim_io_error (sd, "sim_events_watch_core - invalid nr bytes");
	}
      break;
    default:
      sim_io_error (sd, "sim_events_watch_core - invalid byte order");
    }
  /* handler */
  new_event->data = data;
  new_event->handler = handler;
  /* data */
  new_event->core_addr = core_addr;
  new_event->core_map = core_map;
  new_event->lb = lb;
  new_event->lb64 = lb;
  new_event->ub = ub;
  new_event->ub64 = ub;
  new_event->is_within = (is_within != 0);
  /* insert */
  new_event->next = events->watchpoints;
  events->watchpoints = new_event;
  events->work_pending = 1;
  ETRACE ((_ETRACE,
	   "event watching host at %ld - tag 0x%lx - host-addr 0x%lx, 0x%lx..0x%lx, handler 0x%lx, data 0x%lx\n",
	   (long)sim_events_time (sd),
	   (long)new_event,
	   (long)new_event->host_addr,
	   (long)new_event->lb,
	   (long)new_event->ub,
	   (long)new_event->handler,
	   (long)new_event->data));
  return new_event;
}
#endif


#if EXTERN_SIM_EVENTS_P
void
sim_events_deschedule (SIM_DESC sd,
		       sim_event *event_to_remove)
{
  sim_events *events = STATE_EVENTS (sd);
  sim_event *to_remove = (sim_event*)event_to_remove;
  if (event_to_remove != NULL)
    {
      sim_event **queue = NULL;
      while ((queue = next_event_queue (sd, queue)) != NULL)
	{
	  sim_event **ptr_to_current;
	  for (ptr_to_current = queue;
	       *ptr_to_current != NULL && *ptr_to_current != to_remove;
	       ptr_to_current = &(*ptr_to_current)->next);
	  if (*ptr_to_current == to_remove)
	    {
	      sim_event *dead = *ptr_to_current;
	      *ptr_to_current = dead->next;
	      ETRACE ((_ETRACE,
		       "event/watch descheduled at %ld - tag 0x%lx - time %ld, handler 0x%lx, data 0x%lx%s%s\n",
		       (long) sim_events_time (sd),
		       (long) event_to_remove,
		       (long) dead->time_of_event,
		       (long) dead->handler,
		       (long) dead->data,
		       (dead->trace != NULL) ? ", " : "",
		       (dead->trace != NULL) ? dead->trace : ""));
	      sim_events_free (sd, dead);
	      update_time_from_event (sd);
	      SIM_ASSERT ((events->time_from_event >= 0) == (events->queue != NULL));
	      return;
	    }
	}
    }
  ETRACE ((_ETRACE,
	   "event/watch descheduled at %ld - tag 0x%lx - not found\n",
	   (long) sim_events_time (sd),
	   (long) event_to_remove));
}
#endif


STATIC_INLINE_SIM_EVENTS\
(int)
sim_watch_valid (SIM_DESC sd,
		 sim_event *to_do)
{
  switch (to_do->watching)
    {

#define WATCH_CORE(N,OP,EXT) \
      int ok; \
      unsigned_##N word = 0; \
      int nr_read = sim_core_read_buffer (sd, NULL, to_do->core_map, &word, \
					  to_do->core_addr, sizeof (word)); \
      OP (word); \
      ok = (nr_read == sizeof (unsigned_##N) \
	    && (to_do->is_within \
		== (word >= to_do->lb##EXT \
		    && word <= to_do->ub##EXT)));

    case watch_core_targ_1:
      {
	WATCH_CORE (1, T2H,);
	return ok;
      }
    case watch_core_targ_2:
      {
        WATCH_CORE (2, T2H,);
	return ok;
      }
    case watch_core_targ_4:
      {
        WATCH_CORE (4, T2H,);
	return ok;
      }
    case watch_core_targ_8:
      {
        WATCH_CORE (8, T2H,64);
	return ok;
      }

    case watch_core_be_1:
      {
        WATCH_CORE (1, BE2H,);
	return ok;
      }
    case watch_core_be_2:
      {
        WATCH_CORE (2, BE2H,);
	return ok;
      }
    case watch_core_be_4:
      {
        WATCH_CORE (4, BE2H,);
	return ok;
      }
    case watch_core_be_8:
      {
        WATCH_CORE (8, BE2H,64);
	return ok;
      }

    case watch_core_le_1:
      {
        WATCH_CORE (1, LE2H,);
	return ok;
      }
    case watch_core_le_2:
      {
        WATCH_CORE (2, LE2H,);
	return ok;
      }
    case watch_core_le_4:
      {
        WATCH_CORE (4, LE2H,);
	return ok;
      }
    case watch_core_le_8:
      {
        WATCH_CORE (8, LE2H,64);
	return ok;
      }
#undef WATCH_CORE

#define WATCH_SIM(N,OP,EXT) \
      int ok; \
      unsigned_##N word = *(unsigned_##N*)to_do->host_addr; \
      OP (word); \
      ok = (to_do->is_within \
	    == (word >= to_do->lb##EXT \
		&& word <= to_do->ub##EXT));

    case watch_sim_host_1:
      {
        WATCH_SIM (1, word = ,);
	return ok;
      }
    case watch_sim_host_2:
      {
        WATCH_SIM (2, word = ,);
	return ok;
      }
    case watch_sim_host_4:
      {
        WATCH_SIM (4, word = ,);
	return ok;
      }
    case watch_sim_host_8:
      {
        WATCH_SIM (8, word = ,64);
	return ok;
      }

    case watch_sim_be_1:
      {
        WATCH_SIM (1, BE2H,);
	return ok;
      }
    case watch_sim_be_2:
      {
        WATCH_SIM (2, BE2H,);
	return ok;
      }
    case watch_sim_be_4:
      {
        WATCH_SIM (4, BE2H,);
	return ok;
      }
    case watch_sim_be_8:
      {
        WATCH_SIM (8, BE2H,64);
	return ok;
      }

    case watch_sim_le_1:
      {
        WATCH_SIM (1, LE2H,);
	return ok;
      }
    case watch_sim_le_2:
      {
        WATCH_SIM (1, LE2H,);
	return ok;
      }
    case watch_sim_le_4:
      {
        WATCH_SIM (1, LE2H,);
	return ok;
      }
    case watch_sim_le_8:
      {
        WATCH_SIM (1, LE2H,64);
	return ok;
      }
#undef WATCH_SIM

    case watch_clock: /* wallclock */
      {
	unsigned long elapsed_time = sim_events_elapsed_time (sd);
	return (elapsed_time >= to_do->wallclock);
      }

    default:
      sim_io_error (sd, "sim_watch_valid - bad switch");
      break;

    }
  return 1;
}


INLINE_SIM_EVENTS\
(int)
sim_events_tick (SIM_DESC sd)
{
  sim_events *events = STATE_EVENTS (sd);

  /* this should only be called after the previous ticks have been
     fully processed */

  /* Advance the time but *only* if there is nothing to process */
  if (events->work_pending
      || events->time_from_event == 0)
    {
      events->nr_ticks_to_process += 1;
      return 1;
    }
  else
    {
      events->time_from_event -= 1;
      return 0;
    }
}


INLINE_SIM_EVENTS\
(int)
sim_events_tickn (SIM_DESC sd,
		  int n)
{
  sim_events *events = STATE_EVENTS (sd);
  SIM_ASSERT (n > 0);

  /* this should only be called after the previous ticks have been
     fully processed */

  /* Advance the time but *only* if there is nothing to process */
  if (events->work_pending || events->time_from_event < n)
    {
      events->nr_ticks_to_process += n;
      return 1;
    }
  else
    {
      events->time_from_event -= n;
      return 0;
    }
}


INLINE_SIM_EVENTS\
(void)
sim_events_slip (SIM_DESC sd,
		 int slip)
{
  sim_events *events = STATE_EVENTS (sd);
  SIM_ASSERT (slip > 0);

  /* Flag a ready event with work_pending instead of number of ticks
     to process so that the time continues to be correct */
  if (events->time_from_event < slip)
    {
      events->work_pending = 1;
    }
  events->time_from_event -= slip;
}


INLINE_SIM_EVENTS\
(void)
sim_events_preprocess (SIM_DESC sd,
		       int events_were_last,
		       int events_were_next)
{
  sim_events *events = STATE_EVENTS (sd);
  if (events_were_last)
    {
      /* Halted part way through event processing */
      ASSERT (events->nr_ticks_to_process != 0);
      /* The external world can't tell if the event that stopped the
         simulator was the last event to process. */
      ASSERT (events_were_next);
      sim_events_process (sd);
    }
  else if (events_were_next)
    {
      /* Halted by the last processor */
      if (sim_events_tick (sd))
	sim_events_process (sd);
    }
}


INLINE_SIM_EVENTS\
(void)
sim_events_process (SIM_DESC sd)
{
  sim_events *events = STATE_EVENTS (sd);
  signed64 event_time = sim_events_time (sd);

  /* Clear work_pending before checking nr_held.  Clearing
     work_pending after nr_held (with out a lock could loose an
     event). */
  events->work_pending = 0;

  /* move any events that were asynchronously queued by any signal
     handlers onto the real event queue.  */
  if (events->nr_held > 0)
    {
      int i;

#if defined(HAVE_SIGPROCMASK) && defined(SIG_SETMASK)
      /*-LOCK-*/
      sigset_t old_mask;
      sigset_t new_mask;
      sigfillset (&new_mask);
      sigprocmask (SIG_SETMASK, &new_mask, &old_mask);
#endif

      for (i = 0; i < events->nr_held; i++)
	{
	  sim_event *entry = &events->held [i];
	  sim_events_schedule (sd,
			       entry->time_of_event,
			       entry->handler,
			       entry->data);
	}
      events->nr_held = 0;

#if defined(HAVE_SIGPROCMASK) && defined(SIG_SETMASK)
      /*-UNLOCK-*/
      sigprocmask (SIG_SETMASK, &old_mask, NULL);
#endif

    }

  /* Process any watchpoints. Be careful to allow a watchpoint to
     appear/disappear under our feet.
     To ensure that watchpoints are processed only once per cycle,
     they are moved onto a watched queue, this returned to the
     watchpoint queue when all queue processing has been
     completed. */
  while (events->watchpoints != NULL)
    {
      sim_event *to_do = events->watchpoints;
      events->watchpoints = to_do->next;
      if (sim_watch_valid (sd, to_do))
	{
	  sim_event_handler *handler = to_do->handler;
	  void *data = to_do->data;
	  ETRACE ((_ETRACE,
		   "event issued at %ld - tag 0x%lx - handler 0x%lx, data 0x%lx%s%s\n",
		   (long) event_time,
		   (long) to_do,
		   (long) handler,
		   (long) data,
		   (to_do->trace != NULL) ? ", " : "",
		   (to_do->trace != NULL) ? to_do->trace : ""));
	  sim_events_free (sd, to_do);
	  handler (sd, data);
	}
      else
	{
	  to_do->next = events->watchedpoints;
	  events->watchedpoints = to_do;
	}
    }

  /* consume all events for this or earlier times.  Be careful to
     allow an event to appear/disappear under our feet */
  while (events->queue->time_of_event <
	 (event_time + events->nr_ticks_to_process))
    {
      sim_event *to_do = events->queue;
      sim_event_handler *handler = to_do->handler;
      void *data = to_do->data;
      events->queue = to_do->next;
      update_time_from_event (sd);
      ETRACE ((_ETRACE,
	       "event issued at %ld - tag 0x%lx - handler 0x%lx, data 0x%lx%s%s\n",
	       (long) event_time,
	       (long) to_do,
	       (long) handler,
	       (long) data,
	       (to_do->trace != NULL) ? ", " : "",
	       (to_do->trace != NULL) ? to_do->trace : ""));
      sim_events_free (sd, to_do);
      handler (sd, data);
    }

  /* put things back where they belong ready for the next iteration */
  events->watchpoints = events->watchedpoints;
  events->watchedpoints = NULL;
  if (events->watchpoints != NULL)
    events->work_pending = 1;

  /* advance the time */
  SIM_ASSERT (events->time_from_event >= events->nr_ticks_to_process);
  SIM_ASSERT (events->queue != NULL); /* always poll event */
  events->time_from_event -= events->nr_ticks_to_process;

  /* this round of processing complete */
  events->nr_ticks_to_process = 0;
}

#endif
@


1.15
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright 2002, 2007-2012 Free Software Foundation, Inc.
@


1.14
log
@sim: fix func call style (space before paren)

Committed this as obvious:
	-foo(...);
	+foo (...);

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.14.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright 2002, 2007-2012 Free Software Foundation, Inc.
@


1.13
log
@sim: common: trim trailing whitespace
@
text
@d282 1
a282 1
      sigfillset(&new_mask);
d526 10
a535 10
  insert_sim_event(sd, new_event, delta_time);
  ETRACE((_ETRACE,
	  "event scheduled at %ld - tag 0x%lx - time %ld, handler 0x%lx, data 0x%lx%s%s\n",
	  (long)sim_events_time(sd),
	  (long)new_event,
	  (long)new_event->time_of_event,
	  (long)new_event->handler,
	  (long)new_event->data,
	  (new_event->trace != NULL) ? ", " : "",
	  (new_event->trace != NULL) ? new_event->trace : ""));
d554 1
a554 1
  sigfillset(&new_mask);
d581 1
a581 1
	   (long)sim_events_time(sd),
d1072 1
a1072 1
  sim_events *events = STATE_EVENTS(sd);
d1095 2
a1096 2
  sim_events *events = STATE_EVENTS(sd);
  signed64 event_time = sim_events_time(sd);
d1113 2
a1114 2
      sigfillset(&new_mask);
      sigprocmask(SIG_SETMASK, &new_mask, &old_mask);
d1129 1
a1129 1
      sigprocmask(SIG_SETMASK, &old_mask, NULL);
d1148 8
a1155 8
	  ETRACE((_ETRACE,
		  "event issued at %ld - tag 0x%lx - handler 0x%lx, data 0x%lx%s%s\n",
		  (long) event_time,
		  (long) to_do,
		  (long) handler,
		  (long) data,
		  (to_do->trace != NULL) ? ", " : "",
		  (to_do->trace != NULL) ? to_do->trace : ""));
d1176 8
a1183 8
      ETRACE((_ETRACE,
	      "event issued at %ld - tag 0x%lx - handler 0x%lx, data 0x%lx%s%s\n",
	      (long) event_time,
	      (long) to_do,
	      (long) handler,
	      (long) data,
	      (to_do->trace != NULL) ? ", " : "",
	      (to_do->trace != NULL) ? to_do->trace : ""));
@


1.12
log
@run copyright.sh for 2011.
@
text
@d77 1
a77 1
  
d114 1
a114 1
   
d390 1
a390 1
  
d450 1
a450 1
  
d453 1
a453 1
  
d465 1
a465 1
  
d470 1
a470 1
  
d557 1
a557 1
  
d566 1
a566 1
  
d578 1
a578 1
  
d1108 1
a1108 1
      
d1126 1
a1126 1
      
d1131 1
a1131 1
      
d1133 1
a1133 1
  
d1165 1
a1165 1
  
d1187 1
a1187 1
  
d1193 1
a1193 1
  
@


1.11
log
@Update copyright notices to add year 2010.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.10
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.9
log
@	Updated copyright notices for most files.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008 Free Software Foundation, Inc.
@


1.8
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d3 1
a3 1
   Copyright 2002, 2007 Free Software Foundation, Inc.
@


1.7
log
@Copyright updates for 2007.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.6
log
@2002-11-22  Andrew Cagney  <ac131313@@redhat.com>

	* dv-core.c: Update copyright.  sim/common contributed to the FSF.
	* dv-glue.c, dv-pal.c, hw-base.c, hw-base.h, hw-device.c: Ditto.
	* hw-device.h, hw-handles.c, hw-handles.h: Ditto.
	* hw-instances.c, hw-instances.h, hw-properties.c: Ditto.
	* hw-properties.h, hw-tree.c, hw-tree.h, sim-alu.h: Ditto.
	* sim-basics.h, sim-bits.c, sim-bits.h, sim-config.c: Ditto.
	* sim-config.h, sim-core.c, sim-core.h, sim-endian.c: Ditto.
	* sim-endian.h, sim-events.c, sim-events.h, sim-inline.c: Ditto.
	* sim-inline.h, sim-io.c, sim-io.h, sim-n-bits.h: Ditto.
	* sim-n-core.h, sim-n-endian.h, sim-types.h: Ditto.
@
text
@d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
@


1.5
log
@* sim-memopt.c: Include <unistd.h>.
(do_memopt_add): Fix printf format.
* sim-events.c (sim_events_schedule): Initialize ``dummy''.
@
text
@d1 1
a1 1
/*  This file is part of the program psim.
d3 1
a3 1
    Copyright (C) 1994-1997, Andrew Cagney <cagney@@highland.com.au>
d5 18
a22 15
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
    */
@


1.5.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1 1
a1 1
/* The common simulator framework for GDB, the GNU Debugger.
d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d5 15
a19 18
   Contributed by Andrew Cagney and Red Hat.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.5.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d1 1
a1 1
/* The common simulator framework for GDB, the GNU Debugger.
d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d5 15
a19 18
   Contributed by Andrew Cagney and Red Hat.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.5.6.1
log
@2002-11-22  Andrew Cagney  <ac131313@@redhat.com>

	* dv-core.c: Update copyright.  sim/common contributed to the FSF.
	* dv-glue.c, dv-pal.c, hw-base.c, hw-base.h, hw-device.c: Ditto.
	* hw-device.h, hw-handles.c, hw-handles.h: Ditto.
	* hw-instances.c, hw-instances.h, hw-properties.c: Ditto.
	* hw-properties.h, hw-tree.c, hw-tree.h, sim-alu.h: Ditto.
	* sim-basics.h, sim-bits.c, sim-bits.h, sim-config.c: Ditto.
	* sim-config.h, sim-core.c, sim-core.h, sim-endian.c: Ditto.
	* sim-endian.h, sim-events.c, sim-events.h, sim-inline.c: Ditto.
	* sim-inline.h, sim-io.c, sim-io.h, sim-n-bits.h: Ditto.
	* sim-n-core.h, sim-n-endian.h, sim-types.h: Ditto.
@
text
@d1 1
a1 1
/* The common simulator framework for GDB, the GNU Debugger.
d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d5 15
a19 18
   Contributed by Andrew Cagney and Red Hat.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.4
log
@2002-02-10  Chris Demetriou  <cgd@@broadcom.com>

        * callback.c: Fix some spelling errors.
        * hw-device.h: Likewise.
        * hw-tree.c: Likewise.
        * sim-abort.c: Likewise.
        * sim-alu.h: Likewise.
        * sim-core.h: Likewise.
        * sim-events.c: Likewise.
        * sim-events.h: Likewise.
        * sim-fpu.h: Likewise.
        * sim-profile.h: Likewise.
        * sim-utils.c: Likewise.
@
text
@d484 1
@


1.4.6.1
log
@merge with trunk
@
text
@a483 1
  memset (&dummy, 0, sizeof dummy);
@


1.4.8.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@a483 1
  memset (&dummy, 0, sizeof dummy);
@


1.3
log
@2000-06-25  Stephane Carrez  <Stephane.Carrez@@worldnet.fr>

        * sim-events.c (sim_events_remain_time): New function returning
        the time that remains before the event is raised.
        * hw-events.c (hw_event_remain_time): Likewise.
        * sim-events.h (sim_events_remain_time): Declare.
        * hw-events.h (hw_event_remain_time): Declare.
@
text
@d40 1
a40 1
#include <signal.h> /* For SIGPROCMASK et.al. */
d115 1
a115 1
   to occure.  If no next event it will hold the time of the last
d450 1
a450 1
  /* compute when the event should occure */
@


1.2
log
@Provide more detailed traces of the event queue.
@
text
@d382 13
@


1.1
log
@Initial revision
@
text
@a41 9
#if __CYGWIN32__
/* The ui_loop_hook is called to keep the GUI alive while the simulator
   is running.  The counter is to make sure we do not wake it too often.
*/

extern void (*ui_loop_hook) PARAMS ((int));
static unsigned int ui_loop_hook_counter = 0;
#endif

d398 21
a1185 12

#if __CYGWIN32__
  /* Now call the ui_loop_hook to give the gui a chance to
     process events. */
  
  if (ui_loop_hook != NULL)
    {
      /* attempt to limit calls to 1-10 per second */
      if (! (ui_loop_hook_counter++ & 0xf))
	(*ui_loop_hook) (-2); /* magic */
    }
#endif
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d42 9
d1174 12
@

