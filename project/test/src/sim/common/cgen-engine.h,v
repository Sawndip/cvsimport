head	1.13;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.13
	gdb_7_6-2013-04-26-release:1.13
	gdb_7_6-branch:1.13.0.2
	gdb_7_6-2013-03-12-branchpoint:1.13
	gdb_7_5_1-2012-11-29-release:1.12
	gdb_7_5-2012-08-17-release:1.12
	gdb_7_5-branch:1.12.0.2
	gdb_7_5-2012-07-18-branchpoint:1.12
	gdb_7_4_1-2012-04-26-release:1.11.4.1
	gdb_7_4-2012-01-24-release:1.11.4.1
	gdb_7_4-branch:1.11.0.4
	gdb_7_4-2011-12-13-branchpoint:1.11
	gdb_7_3_1-2011-09-04-release:1.11
	gdb_7_3-2011-07-26-release:1.11
	gdb_7_3-branch:1.11.0.2
	gdb_7_3-2011-04-01-branchpoint:1.11
	gdb_7_2-2010-09-02-release:1.9
	gdb_7_2-branch:1.9.0.4
	gdb_7_2-2010-07-07-branchpoint:1.9
	gdb_7_1-2010-03-18-release:1.9
	gdb_7_1-branch:1.9.0.2
	gdb_7_1-2010-02-18-branchpoint:1.9
	gdb_7_0_1-2009-12-22-release:1.5
	gdb_7_0-2009-10-06-release:1.5
	gdb_7_0-branch:1.5.0.4
	gdb_7_0-2009-09-16-branchpoint:1.5
	arc-sim-20090309:1.4
	msnyder-checkpoint-072509-branch:1.5.0.2
	msnyder-checkpoint-072509-branchpoint:1.5
	arc-insight_6_8-branch:1.4.0.16
	arc-insight_6_8-branchpoint:1.4
	insight_6_8-branch:1.4.0.14
	insight_6_8-branchpoint:1.4
	reverse-20081226-branch:1.4.0.12
	reverse-20081226-branchpoint:1.4
	multiprocess-20081120-branch:1.4.0.10
	multiprocess-20081120-branchpoint:1.4
	reverse-20080930-branch:1.4.0.8
	reverse-20080930-branchpoint:1.4
	reverse-20080717-branch:1.4.0.6
	reverse-20080717-branchpoint:1.4
	msnyder-reverse-20080609-branch:1.4.0.4
	msnyder-reverse-20080609-branchpoint:1.4
	drow-reverse-20070409-branch:1.2.0.2
	drow-reverse-20070409-branchpoint:1.2
	gdb_6_8-2008-03-27-release:1.4
	gdb_6_8-branch:1.4.0.2
	gdb_6_8-2008-02-26-branchpoint:1.4
	gdb_6_7_1-2007-10-29-release:1.3
	gdb_6_7-2007-10-10-release:1.3
	gdb_6_7-branch:1.3.0.2
	gdb_6_7-2007-09-07-branchpoint:1.3
	insight_6_6-20070208-release:1.1.1.5
	gdb_6_6-2006-12-18-release:1.1.1.5
	gdb_6_6-branch:1.1.1.5.0.116
	gdb_6_6-2006-11-15-branchpoint:1.1.1.5
	insight_6_5-20061003-release:1.1.1.5
	gdb-csl-symbian-6_4_50_20060226-12:1.1.1.5
	gdb-csl-sourcerygxx-3_4_4-25:1.1.1.5
	nickrob-async-20060828-mergepoint:1.1.1.5
	gdb-csl-symbian-6_4_50_20060226-11:1.1.1.5
	gdb-csl-sourcerygxx-4_1-17:1.1.1.5
	gdb-csl-20060226-branch-local-2:1.1.1.5
	gdb-csl-sourcerygxx-4_1-14:1.1.1.5
	gdb-csl-sourcerygxx-4_1-13:1.1.1.5
	gdb-csl-sourcerygxx-4_1-12:1.1.1.5
	gdb-csl-sourcerygxx-3_4_4-21:1.1.1.5
	gdb_6_5-20060621-release:1.1.1.5
	gdb-csl-sourcerygxx-4_1-9:1.1.1.5
	gdb-csl-sourcerygxx-4_1-8:1.1.1.5
	gdb-csl-sourcerygxx-4_1-7:1.1.1.5
	gdb-csl-arm-2006q1-6:1.1.1.5
	gdb-csl-sourcerygxx-4_1-6:1.1.1.5
	gdb-csl-symbian-6_4_50_20060226-10:1.1.1.5
	gdb-csl-symbian-6_4_50_20060226-9:1.1.1.5
	gdb-csl-symbian-6_4_50_20060226-8:1.1.1.5
	gdb-csl-coldfire-4_1-11:1.1.1.5
	gdb-csl-sourcerygxx-3_4_4-19:1.1.1.5
	gdb-csl-coldfire-4_1-10:1.1.1.5
	gdb_6_5-branch:1.1.1.5.0.114
	gdb_6_5-2006-05-14-branchpoint:1.1.1.5
	gdb-csl-sourcerygxx-4_1-5:1.1.1.5
	nickrob-async-20060513-branch:1.1.1.5.0.112
	nickrob-async-20060513-branchpoint:1.1.1.5
	gdb-csl-sourcerygxx-4_1-4:1.1.1.5
	msnyder-reverse-20060502-branch:1.1.1.5.0.110
	msnyder-reverse-20060502-branchpoint:1.1.1.5
	gdb-csl-morpho-4_1-4:1.1.1.5
	gdb-csl-sourcerygxx-3_4_4-17:1.1.1.5
	readline_5_1-import-branch:1.1.1.5.0.108
	readline_5_1-import-branchpoint:1.1.1.5
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.1.1.5
	gdb-csl-symbian-20060226-branch:1.1.1.5.0.106
	gdb-csl-symbian-20060226-branchpoint:1.1.1.5
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.1.1.5
	msnyder-reverse-20060331-branch:1.1.1.5.0.104
	msnyder-reverse-20060331-branchpoint:1.1.1.5
	gdb-csl-available-20060303-branch:1.1.1.5.0.102
	gdb-csl-available-20060303-branchpoint:1.1.1.5
	gdb-csl-20060226-branch:1.1.1.5.0.100
	gdb-csl-20060226-branchpoint:1.1.1.5
	gdb_6_4-20051202-release:1.1.1.5
	msnyder-fork-checkpoint-branch:1.1.1.5.0.98
	msnyder-fork-checkpoint-branchpoint:1.1.1.5
	gdb-csl-gxxpro-6_3-branch:1.1.1.5.0.96
	gdb-csl-gxxpro-6_3-branchpoint:1.1.1.5
	gdb_6_4-branch:1.1.1.5.0.94
	gdb_6_4-2005-11-01-branchpoint:1.1.1.5
	gdb-csl-arm-20051020-branch:1.1.1.5.0.92
	gdb-csl-arm-20051020-branchpoint:1.1.1.5
	msnyder-tracepoint-checkpoint-branch:1.1.1.5.0.90
	msnyder-tracepoint-checkpoint-branchpoint:1.1.1.5
	gdb-csl-arm-20050325-2005-q1b:1.1.1.5
	gdb-csl-arm-20050325-2005-q1a:1.1.1.5
	csl-arm-20050325-branch:1.1.1.5.0.88
	csl-arm-20050325-branchpoint:1.1.1.5
	gdb_6_3-20041109-release:1.1.1.5
	gdb_6_3-branch:1.1.1.5.0.84
	gdb_6_3-20041019-branchpoint:1.1.1.5
	drow_intercu-merge-20040921:1.1.1.5
	drow_intercu-merge-20040915:1.1.1.5
	jimb-gdb_6_2-e500-branch:1.1.1.5.0.86
	jimb-gdb_6_2-e500-branchpoint:1.1.1.5
	gdb_6_2-20040730-release:1.1.1.5
	gdb_6_2-branch:1.1.1.5.0.82
	gdb_6_2-2004-07-10-gmt-branchpoint:1.1.1.5
	gdb_6_1_1-20040616-release:1.1.1.5
	gdb_6_1-2004-04-05-release:1.1.1.5
	drow_intercu-merge-20040402:1.1.1.5
	drow_intercu-merge-20040327:1.1.1.5
	ezannoni_pie-20040323-branch:1.1.1.5.0.80
	ezannoni_pie-20040323-branchpoint:1.1.1.5
	cagney_tramp-20040321-mergepoint:1.1.1.5
	cagney_tramp-20040309-branch:1.1.1.5.0.78
	cagney_tramp-20040309-branchpoint:1.1.1.5
	gdb_6_1-branch:1.1.1.5.0.76
	gdb_6_1-2004-03-01-gmt-branchpoint:1.1.1.5
	drow_intercu-20040221-branch:1.1.1.5.0.74
	drow_intercu-20040221-branchpoint:1.1.1.5
	cagney_bfdfile-20040213-branch:1.1.1.5.0.72
	cagney_bfdfile-20040213-branchpoint:1.1.1.5
	drow-cplus-merge-20040208:1.1.1.5
	carlton_dictionary-20040126-merge:1.1.1.5
	cagney_bigcore-20040122-branch:1.1.1.5.0.70
	cagney_bigcore-20040122-branchpoint:1.1.1.5
	drow-cplus-merge-20040113:1.1.1.5
	drow-cplus-merge-20031224:1.1.1.5
	drow-cplus-merge-20031220:1.1.1.5
	carlton_dictionary-20031215-merge:1.1.1.5
	drow-cplus-merge-20031214:1.1.1.5
	carlton-dictionary-20031111-merge:1.1.1.5
	gdb_6_0-2003-10-04-release:1.1.1.5
	kettenis_sparc-20030918-branch:1.1.1.5.0.68
	kettenis_sparc-20030918-branchpoint:1.1.1.5
	carlton_dictionary-20030917-merge:1.1.1.5
	ezannoni_pie-20030916-branchpoint:1.1.1.5
	ezannoni_pie-20030916-branch:1.1.1.5.0.66
	cagney_x86i386-20030821-branch:1.1.1.5.0.64
	cagney_x86i386-20030821-branchpoint:1.1.1.5
	carlton_dictionary-20030805-merge:1.1.1.5
	carlton_dictionary-20030627-merge:1.1.1.5
	gdb_6_0-branch:1.1.1.5.0.62
	gdb_6_0-2003-06-23-branchpoint:1.1.1.5
	jimb-ppc64-linux-20030613-branch:1.1.1.5.0.60
	jimb-ppc64-linux-20030613-branchpoint:1.1.1.5
	cagney_convert-20030606-branch:1.1.1.5.0.58
	cagney_convert-20030606-branchpoint:1.1.1.5
	cagney_writestrings-20030508-branch:1.1.1.5.0.56
	cagney_writestrings-20030508-branchpoint:1.1.1.5
	jimb-ppc64-linux-20030528-branch:1.1.1.5.0.54
	jimb-ppc64-linux-20030528-branchpoint:1.1.1.5
	carlton_dictionary-20030523-merge:1.1.1.5
	cagney_fileio-20030521-branch:1.1.1.5.0.52
	cagney_fileio-20030521-branchpoint:1.1.1.5
	kettenis_i386newframe-20030517-mergepoint:1.1.1.5
	jimb-ppc64-linux-20030509-branch:1.1.1.5.0.50
	jimb-ppc64-linux-20030509-branchpoint:1.1.1.5
	kettenis_i386newframe-20030504-mergepoint:1.1.1.5
	carlton_dictionary-20030430-merge:1.1.1.5
	kettenis_i386newframe-20030419-branch:1.1.1.5.0.48
	kettenis_i386newframe-20030419-branchpoint:1.1.1.5
	carlton_dictionary-20030416-merge:1.1.1.5
	cagney_frameaddr-20030409-mergepoint:1.1.1.5
	kettenis_i386newframe-20030406-branch:1.1.1.5.0.46
	kettenis_i386newframe-20030406-branchpoint:1.1.1.5
	cagney_frameaddr-20030403-branchpoint:1.1.1.5
	cagney_frameaddr-20030403-branch:1.1.1.5.0.44
	cagney_framebase-20030330-mergepoint:1.1.1.5
	cagney_framebase-20030326-branch:1.1.1.5.0.42
	cagney_framebase-20030326-branchpoint:1.1.1.5
	cagney_lazyid-20030317-branch:1.1.1.5.0.40
	cagney_lazyid-20030317-branchpoint:1.1.1.5
	kettenis-i386newframe-20030316-mergepoint:1.1.1.5
	offbyone-20030313-branch:1.1.1.5.0.38
	offbyone-20030313-branchpoint:1.1.1.5
	kettenis-i386newframe-20030308-branch:1.1.1.5.0.36
	kettenis-i386newframe-20030308-branchpoint:1.1.1.5
	carlton_dictionary-20030305-merge:1.1.1.5
	cagney_offbyone-20030303-branch:1.1.1.5.0.34
	cagney_offbyone-20030303-branchpoint:1.1.1.5
	carlton_dictionary-20030207-merge:1.1.1.5
	interps-20030202-branch:1.1.1.5.0.32
	interps-20030202-branchpoint:1.1.1.5
	cagney-unwind-20030108-branch:1.1.1.5.0.30
	cagney-unwind-20030108-branchpoint:1.1.1.5
	carlton_dictionary-20021223-merge:1.1.1.5
	gdb_5_3-2002-12-12-release:1.1.1.5
	carlton_dictionary-20021115-merge:1.1.1.5
	kseitz_interps-20021105-merge:1.1.1.5
	kseitz_interps-20021103-merge:1.1.1.5
	drow-cplus-merge-20021020:1.1.1.5
	drow-cplus-merge-20021025:1.1.1.5
	carlton_dictionary-20021025-merge:1.1.1.5
	carlton_dictionary-20021011-merge:1.1.1.5
	drow-cplus-branch:1.1.1.5.0.28
	drow-cplus-branchpoint:1.1.1.5
	kseitz_interps-20020930-merge:1.1.1.5
	carlton_dictionary-20020927-merge:1.1.1.5
	carlton_dictionary-branch:1.1.1.5.0.26
	carlton_dictionary-20020920-branchpoint:1.1.1.5
	gdb_5_3-branch:1.1.1.5.0.24
	gdb_5_3-2002-09-04-branchpoint:1.1.1.5
	kseitz_interps-20020829-merge:1.1.1.5
	cagney_sysregs-20020825-branch:1.1.1.5.0.22
	cagney_sysregs-20020825-branchpoint:1.1.1.5
	readline_4_3-import-branch:1.1.1.5.0.20
	readline_4_3-import-branchpoint:1.1.1.5
	gdb_5_2_1-2002-07-23-release:1.1.1.5
	kseitz_interps-20020528-branch:1.1.1.5.0.18
	kseitz_interps-20020528-branchpoint:1.1.1.5
	cagney_regbuf-20020515-branch:1.1.1.5.0.16
	cagney_regbuf-20020515-branchpoint:1.1.1.5
	jimb-macro-020506-branch:1.1.1.5.0.14
	jimb-macro-020506-branchpoint:1.1.1.5
	gdb_5_2-2002-04-29-release:1.1.1.5
	gdb_5_2-branch:1.1.1.5.0.12
	gdb_5_2-2002-03-03-branchpoint:1.1.1.5
	gdb_5_1_1-2002-01-24-release:1.1.1.5
	gdb_5_1_0_1-2002-01-03-release:1.1.1.5
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.5.0.10
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.5
	gdb_5_1-2001-11-21-release:1.1.1.5
	gdb_s390-2001-09-26-branch:1.1.1.5.0.8
	gdb_s390-2001-09-26-branchpoint:1.1.1.5
	gdb_5_1-2001-07-29-branch:1.1.1.5.0.6
	gdb_5_1-2001-07-29-branchpoint:1.1.1.5
	insight-precleanup-2001-01-01:1.1.1.5
	gdb-premipsmulti-2000-06-06-branch:1.1.1.5.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.5
	gdb_5_0-2000-05-19-release:1.1.1.5
	gdb_4_18_2-2000-05-18-release:1.1.1.5
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.5
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.5
	gdb_5_0-2000-04-10-branch:1.1.1.5.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.5
	repo-unification-2000-02-06:1.1.1.5
	gdb-2000-02-04:1.1.1.5
	gdb-2000-02-02:1.1.1.5
	gdb-2000-02-01:1.1.1.5
	gdb-2000-01-31:1.1.1.5
	gdb-2000-01-26:1.1.1.5
	gdb-2000-01-24:1.1.1.5
	gdb-2000-01-17:1.1.1.5
	gdb-2000-01-10:1.1.1.5
	gdb-2000-01-05:1.1.1.5
	gdb-1999-12-21:1.1.1.5
	gdb-1999-12-13:1.1.1.5
	gdb-1999-12-07:1.1.1.5
	gdb-1999-12-06:1.1.1.5
	gdb-1999-11-16:1.1.1.5
	gdb-1999-11-08:1.1.1.5
	gdb-1999-11-01:1.1.1.5
	gdb-1999-10-25:1.1.1.5
	gdb-1999-10-18:1.1.1.5
	gdb-1999-10-11:1.1.1.4
	gdb-1999-10-04:1.1.1.4
	gdb-1999-09-28:1.1.1.4
	gdb-1999-09-21:1.1.1.4
	gdb-1999-09-13:1.1.1.4
	gdb-1999-09-08:1.1.1.4
	gdb-1999-08-30:1.1.1.4
	gdb-1999-08-23:1.1.1.4
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.13
date	2013.01.01.06.41.33;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2012.01.04.08.28.04;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2011.03.15.03.16.16;	author vapier;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2011.01.01.15.33.55;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2010.01.01.10.03.27;	author brobecke;	state Exp;
branches;
next	1.8;

1.8
date	2009.12.02.17.25.56;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2009.11.23.09.37.07;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2009.11.23.04.12.16;	author devans;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.14.10.53.05;	author brobecke;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.01.22.53.23;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2007.08.24.14.28.35;	author brobecke;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.09.17.59.16;	author drow;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.56;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.11.4.1
date	2012.01.06.04.54.38;	author brobecke;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.56;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.06.28.16.05.43;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.08.09.21.36.05;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.08.23.22.39.55;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.10.19.02.47.02;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* Engine header for Cpu tools GENerated simulators.
   Copyright (C) 1998-2013 Free Software Foundation, Inc.
   Contributed by Cygnus Support.

This file is part of GDB, the GNU debugger.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* This file is included by ${cpu}.h.
   It needs CGEN_INSN_WORD which is defined by ${cpu}.h.
   ??? A lot of this could be moved to genmloop.sh to be put in eng.h
   and thus remove some conditional compilation.  We'd still need
   CGEN_INSN_WORD though.  */

/* Semantic functions come in six versions on two axes:
   fast/full-featured, and using one of the simple/scache/compilation engines.
   A full featured simulator is always provided.  --enable-sim-fast includes
   support for fast execution by duplicating the semantic code but leaving
   out all features like tracing and profiling.
   Using the scache is selected with --enable-sim-scache.  */
/* FIXME: --enable-sim-fast not implemented yet.  */
/* FIXME: undecided how to handle WITH_SCACHE_PBB.  */

/* There are several styles of engines, all generally supported by the
   same code:

   WITH_SCACHE && WITH_SCACHE_PBB - pseudo-basic-block scaching
   WITH_SCACHE && !WITH_SCACHE_PBB - scaching on an insn by insn basis
   !WITH_SCACHE - simple engine: fetch an insn, execute an insn

   The !WITH_SCACHE case can also be broken up into two flavours:
   extract the fields of the insn into an ARGBUF struct, or defer the
   extraction to the semantic handler.  The former can be viewed as the
   WITH_SCACHE case with a cache size of 1 (thus there's no need for a
   WITH_EXTRACTION macro).  The WITH_SCACHE case always extracts the fields
   into an ARGBUF struct.  */

#ifndef CGEN_ENGINE_H
#define CGEN_ENGINE_H

/* Instruction field support macros.  */

#define EXTRACT_MSB0_SINT(val, total, start, length) \
(((INT) (val) << ((sizeof (INT) * 8) - (total) + (start))) \
 >> ((sizeof (INT) * 8) - (length)))
#define EXTRACT_MSB0_UINT(val, total, start, length) \
(((UINT) (val) << ((sizeof (UINT) * 8) - (total) + (start))) \
 >> ((sizeof (UINT) * 8) - (length)))

#define EXTRACT_LSB0_SINT(val, total, start, length) \
(((INT) (val) << ((sizeof (INT) * 8) - (start) - 1)) \
 >> ((sizeof (INT) * 8) - (length)))
#define EXTRACT_LSB0_UINT(val, total, start, length) \
(((UINT) (val) << ((sizeof (UINT) * 8) - (start) - 1)) \
 >> ((sizeof (UINT) * 8) - (length)))

#define EXTRACT_MSB0_LGSINT(val, total, start, length) \
(((CGEN_INSN_LGSINT) (val) << ((sizeof (CGEN_INSN_LGSINT) * 8) - (total) + (start))) \
 >> ((sizeof (CGEN_INSN_LGSINT) * 8) - (length)))
#define EXTRACT_MSB0_LGUINT(val, total, start, length) \
(((CGEN_INSN_UINT) (val) << ((sizeof (CGEN_INSN_LGUINT) * 8) - (total) + (start))) \
 >> ((sizeof (CGEN_INSN_LGUINT) * 8) - (length)))

#define EXTRACT_LSB0_LGSINT(val, total, start, length) \
(((CGEN_INSN_LGSINT) (val) << ((sizeof (CGEN_INSN_LGSINT) * 8) - (start) - 1)) \
 >> ((sizeof (CGEN_INSN_LGSINT) * 8) - (length)))
#define EXTRACT_LSB0_LGUINT(val, total, start, length) \
(((CGEN_INSN_LGUINT) (val) << ((sizeof (CGEN_INSN_LGUINT) * 8) - (start) - 1)) \
 >> ((sizeof (CGEN_INSN_LGUINT) * 8) - (length)))

/* Semantic routines.  */

/* Type of the machine generated extraction fns.  */
/* ??? No longer used.  */
typedef void (EXTRACT_FN) (SIM_CPU *, IADDR, CGEN_INSN_WORD, ARGBUF *);

/* Type of the machine generated semantic fns.  */

#if WITH_SCACHE

/* Instruction fields are extracted into ARGBUF before calling the
   semantic routine.  */
#if HAVE_PARALLEL_INSNS && ! WITH_PARALLEL_GENWRITE
typedef SEM_PC (SEMANTIC_FN) (SIM_CPU *, SEM_ARG, PAREXEC *);
#else
typedef SEM_PC (SEMANTIC_FN) (SIM_CPU *, SEM_ARG);
#endif

#else

/* Result of semantic routines is a status indicator (wip).  */
typedef unsigned int SEM_STATUS;

/* Instruction fields are extracted by the semantic routine.
   ??? TODO: multi word insns.  */
#if HAVE_PARALLEL_INSNS && ! WITH_PARALLEL_GENWRITE
typedef SEM_STATUS (SEMANTIC_FN) (SIM_CPU *, SEM_ARG, PAREXEC *, CGEN_INSN_WORD);
#else
typedef SEM_STATUS (SEMANTIC_FN) (SIM_CPU *, SEM_ARG, CGEN_INSN_WORD);
#endif

#endif

/* In the ARGBUF struct, a pointer to the semantic routine for the insn.  */

union sem {
#if ! WITH_SEM_SWITCH_FULL
  SEMANTIC_FN *sem_full;
#endif
#if ! WITH_SEM_SWITCH_FAST
  SEMANTIC_FN *sem_fast;
#endif
#if WITH_SEM_SWITCH_FULL || WITH_SEM_SWITCH_FAST
#ifdef __GNUC__
  void *sem_case;
#else
  int sem_case;
#endif
#endif
};

/* Set the appropriate semantic handler in ABUF.  */

#if WITH_SEM_SWITCH_FULL
#ifdef __GNUC__
#define SEM_SET_FULL_CODE(abuf, idesc) \
  do { (abuf)->semantic.sem_case = (idesc)->sem_full_lab; } while (0)
#else
#define SEM_SET_FULL_CODE(abuf, idesc) \
  do { (abuf)->semantic.sem_case = (idesc)->num; } while (0)
#endif
#else
#define SEM_SET_FULL_CODE(abuf, idesc) \
  do { (abuf)->semantic.sem_full = (idesc)->sem_full; } while (0)
#endif

#if WITH_SEM_SWITCH_FAST
#ifdef __GNUC__
#define SEM_SET_FAST_CODE(abuf, idesc) \
  do { (abuf)->semantic.sem_case = (idesc)->sem_fast_lab; } while (0)
#else
#define SEM_SET_FAST_CODE(abuf, idesc) \
  do { (abuf)->semantic.sem_case = (idesc)->num; } while (0)
#endif
#else
#define SEM_SET_FAST_CODE(abuf, idesc) \
  do { (abuf)->semantic.sem_fast = (idesc)->sem_fast; } while (0)
#endif

#define SEM_SET_CODE(abuf, idesc, fast_p) \
do { \
  if (fast_p) \
    SEM_SET_FAST_CODE ((abuf), (idesc)); \
  else \
    SEM_SET_FULL_CODE ((abuf), (idesc)); \
} while (0)

/* Return non-zero if IDESC is a conditional or unconditional CTI.  */

#define IDESC_CTI_P(idesc) \
     ((CGEN_ATTR_BOOLS (CGEN_INSN_ATTRS ((idesc)->idata)) \
       & (CGEN_ATTR_MASK (CGEN_INSN_COND_CTI) \
	  | CGEN_ATTR_MASK (CGEN_INSN_UNCOND_CTI))) \
      != 0)

/* Return non-zero if IDESC is a skip insn.  */

#define IDESC_SKIP_P(idesc) \
     ((CGEN_ATTR_BOOLS (CGEN_INSN_ATTRS ((idesc)->idata)) \
       & CGEN_ATTR_MASK (CGEN_INSN_SKIP_CTI)) \
      != 0)

/* Return pointer to ARGBUF given ptr to SCACHE.  */
#define SEM_ARGBUF(sem_arg) (& (sem_arg) -> argbuf)

#if WITH_SCACHE

#define CIA_ADDR(cia) (cia)

#if WITH_SCACHE_PBB

/* Return the scache pointer of the current insn.  */
#define SEM_SEM_ARG(vpc, sc) (vpc)

/* Return the virtual pc of the next insn to execute
   (assuming this isn't a cti or the branch isn't taken).  */
#define SEM_NEXT_VPC(sem_arg, pc, len) ((sem_arg) + 1)

/* Update the instruction counter.  */
#define PBB_UPDATE_INSN_COUNT(cpu,sc) \
  (CPU_INSN_COUNT (cpu) += SEM_ARGBUF (sc) -> fields.chain.insn_count)

/* Do not append a `;' to invocations of this.
   npc,br_type are for communication between the cti insn and cti-chain.  */
#define SEM_BRANCH_INIT \
  IADDR npc = 0; /* assign a value for -Wall */ \
  SEM_BRANCH_TYPE br_type = SEM_BRANCH_UNTAKEN;

/* SEM_IN_SWITCH is defined at the top of the mainloop.c files
   generated by genmloop.sh.  It exists so generated semantic code needn't
   care whether it's being put in a switch or in a function.  */
#ifdef SEM_IN_SWITCH
#define SEM_BRANCH_FINI(pcvar) \
do { \
  pbb_br_npc = npc; \
  pbb_br_type = br_type; \
} while (0)
#else /* 1 semantic function per instruction */
#define SEM_BRANCH_FINI(pcvar) \
do { \
  CPU_PBB_BR_NPC (current_cpu) = npc; \
  CPU_PBB_BR_TYPE (current_cpu) = br_type; \
} while (0)
#endif

#define SEM_BRANCH_VIA_CACHE(cpu, sc, newval, pcvar) \
do { \
  npc = (newval); \
  br_type = SEM_BRANCH_CACHEABLE; \
} while (0)

#define SEM_BRANCH_VIA_ADDR(cpu, sc, newval, pcvar) \
do { \
  npc = (newval); \
  br_type = SEM_BRANCH_UNCACHEABLE; \
} while (0)

#define SEM_SKIP_COMPILE(cpu, sc, skip) \
do { \
  SEM_ARGBUF (sc) -> skip_count = (skip); \
} while (0)

#define SEM_SKIP_INSN(cpu, sc, vpcvar) \
do { \
  (vpcvar) += SEM_ARGBUF (sc) -> skip_count; \
} while (0)

#else /* ! WITH_SCACHE_PBB */

#define SEM_SEM_ARG(vpc, sc) (sc)

#define SEM_NEXT_VPC(sem_arg, pc, len) ((pc) + (len))

/* ??? May wish to move taken_p out of here and make it explicit.  */
#define SEM_BRANCH_INIT \
  int taken_p = 0;

#ifndef TARGET_SEM_BRANCH_FINI
#define TARGET_SEM_BRANCH_FINI(pcvar, taken_p)
#endif
#define SEM_BRANCH_FINI(pcvar) \
  do { TARGET_SEM_BRANCH_FINI (pcvar, taken_p); } while (0)

#define SEM_BRANCH_VIA_CACHE(cpu, sc, newval, pcvar) \
do { \
  (pcvar) = (newval); \
  taken_p = 1; \
} while (0)

#define SEM_BRANCH_VIA_ADDR(cpu, sc, newval, pcvar) \
do { \
  (pcvar) = (newval); \
  taken_p = 1; \
} while (0)

#endif /* ! WITH_SCACHE_PBB */

#else /* ! WITH_SCACHE */

/* This is the "simple" engine case.  */

#define CIA_ADDR(cia) (cia)

#define SEM_SEM_ARG(vpc, sc) (sc)

#define SEM_NEXT_VPC(sem_arg, pc, len) ((pc) + (len))

#define SEM_BRANCH_INIT \
  int taken_p = 0;

#define SEM_BRANCH_VIA_CACHE(cpu, abuf, newval, pcvar) \
do { \
  (pcvar) = (newval); \
  taken_p = 1; \
} while (0)

#define SEM_BRANCH_VIA_ADDR(cpu, abuf, newval, pcvar) \
do { \
  (pcvar) = (newval); \
  taken_p = 1; \
} while (0)

/* Finish off branch insns.
   The target must define TARGET_SEM_BRANCH_FINI.
   ??? This can probably go away when define-execute is finished.  */
#define SEM_BRANCH_FINI(pcvar, bool_attrs) \
  do { TARGET_SEM_BRANCH_FINI ((pcvar), (bool_attrs), taken_p); } while (0)

/* Finish off non-branch insns.
   The target must define TARGET_SEM_NBRANCH_FINI.
   ??? This can probably go away when define-execute is finished.  */
#define SEM_NBRANCH_FINI(pcvar, bool_attrs) \
  do { TARGET_SEM_NBRANCH_FINI ((pcvar), (bool_attrs)); } while (0)

#endif /* ! WITH_SCACHE */

/* Instruction information.  */

/* Sanity check, at most one of these may be true.  */
#if WITH_PARALLEL_READ + WITH_PARALLEL_WRITE + WITH_PARALLEL_GENWRITE > 1
#error "At most one of WITH_PARALLEL_{READ,WRITE,GENWRITE} can be true."
#endif

/* Compile time computable instruction data.  */

struct insn_sem {
  /* The instruction type (a number that identifies each insn over the
     entire architecture).  */
  CGEN_INSN_TYPE type;

  /* Index in IDESC table.  */
  int index;

  /* Semantic format number.  */
  int sfmt;

#if HAVE_PARALLEL_INSNS && ! WITH_PARALLEL_ONLY
  /* Index in IDESC table of parallel handler.  */
  int par_index;
#endif

#if WITH_PARALLEL_READ
  /* Index in IDESC table of read handler.  */
  int read_index;
#endif

#if WITH_PARALLEL_WRITE
  /* Index in IDESC table of writeback handler.  */
  int write_index;
#endif
};

/* Entry in semantic function table.
   This information is copied to the insn descriptor table at run-time.  */

struct sem_fn_desc {
  /* Index in IDESC table.  */
  int index;

  /* Function to perform the semantics of the insn.  */
  SEMANTIC_FN *fn;
};

/* Run-time computed instruction descriptor.  */

struct idesc {
#if WITH_SEM_SWITCH_FAST
#ifdef __GNUC__
  void *sem_fast_lab;
#else
  /* nothing needed, switch's on `num' member */
#endif
#else
  SEMANTIC_FN *sem_fast;
#endif

#if WITH_SEM_SWITCH_FULL
#ifdef __GNUC__
  void *sem_full_lab;
#else
  /* nothing needed, switch's on `num' member */
#endif
#else
  SEMANTIC_FN *sem_full;
#endif

  /* Parallel support.  */
#if HAVE_PARALLEL_INSNS && (! WITH_PARALLEL_ONLY || (WITH_PARALLEL_ONLY && ! WITH_PARALLEL_GENWRITE))
  /* Pointer to parallel handler if serial insn.
     Pointer to readahead/writeback handler if parallel insn.  */
  struct idesc *par_idesc;
#endif

  /* Instruction number (index in IDESC table, profile table).
     Also used to switch on in non-gcc semantic switches.  */
  int num;

  /* Semantic format id.  */
  int sfmt;

  /* instruction data (name, attributes, size, etc.) */
  const CGEN_INSN *idata;

  /* instruction attributes, copied from `idata' for speed */
  const CGEN_INSN_ATTR_TYPE *attrs;

  /* instruction length in bytes, copied from `idata' for speed */
  int length;

  /* profiling/modelling support */
  const INSN_TIMING *timing;
};

/* Tracing/profiling.  */

/* Return non-zero if a before/after handler is needed.
   When tracing/profiling a selected range there's no need to slow
   down simulation of the other insns (except to get more accurate data!).

   ??? May wish to profile all insns if doing insn tracing, or to
   get more accurate cycle data.

   First test ANY_P so we avoid a potentially expensive HIT_P call
   [if there are lots of address ranges].  */

#define PC_IN_TRACE_RANGE_P(cpu, pc) \
  (TRACE_ANY_P (cpu) \
   && ADDR_RANGE_HIT_P (TRACE_RANGE (CPU_TRACE_DATA (cpu)), (pc)))
#define PC_IN_PROFILE_RANGE_P(cpu, pc) \
  (PROFILE_ANY_P (cpu) \
   && ADDR_RANGE_HIT_P (PROFILE_RANGE (CPU_PROFILE_DATA (cpu)), (pc)))

#endif /* CGEN_ENGINE_H */
@


1.12
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 1
   Copyright (C) 1998-1999, 2007-2012 Free Software Foundation, Inc.
@


1.11
log
@sim: common: trim trailing whitespace
@
text
@d2 1
a2 2
   Copyright (C) 1998, 1999, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.11.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 1
   Copyright (C) 1998-1999, 2007-2012 Free Software Foundation, Inc.
@


1.10
log
@run copyright.sh for 2011.
@
text
@d140 1
a140 1
#else 
d153 1
a153 1
#else 
@


1.9
log
@Update copyright notices to add year 2010.
@
text
@d2 1
a2 1
   Copyright (C) 1998, 1999, 2007, 2008, 2009, 2010
@


1.8
log
@	* cgen-engine.h: Remove duplicated comment.
@
text
@d2 2
a3 1
   Copyright (C) 1998, 1999, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.7
log
@	* cgen-engine.h (EXTRACT_MSB0_SINT): Renamed from EXTRACT_MSB0_INT.
	(EXTRACT_LSB0_SINT): Renamed from EXTRACT_LSB0_INT.
plus regenerate cgen files
@
text
@a186 12
/* There are several styles of engines, all generally supported by the
   same code:

   WITH_SCACHE && WITH_SCACHE_PBB - pseudo-basic-block scaching
   WITH_SCACHE && !WITH_SCACHE_PBB - scaching on an insn by insn basis
   !WITH_SCACHE - simple engine: fetch an insn, execute an insn

   ??? The !WITH_SCACHE case can also be broken up into two flavours:
   extract the fields of the insn into an ARGBUF struct, or defer the
   extraction to the semantic handler.  The WITH_SCACHE case always
   extracts the fields into an ARGBUF struct.  */

@


1.6
log
@	* cgen-engine.h (EXTRACT_MSB0_LGSINT, EXTRACT_MSB0_LGUINT): Define.
	(EXTRACT_LSB0_LGSINT, EXTRACT_LSB0_LGUINT): Define.
	(EXTRACT_FN, SEMANTIC_FN): Use CGEN_INSN_WORD in prototype
	instead of CGEN_INSN_INT.
plus, cgen files: Regenerate.
@
text
@d54 1
a54 1
#define EXTRACT_MSB0_INT(val, total, start, length) \
d61 1
a61 1
#define EXTRACT_LSB0_INT(val, total, start, length) \
@


1.5
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d20 2
a21 1
/* This file must be included after eng.h and before ${cpu}.h.
d23 2
a24 1
   and thus remove some conditional compilation.  Worth it?  */
d67 14
d86 1
a86 1
typedef void (EXTRACT_FN) (SIM_CPU *, IADDR, CGEN_INSN_INT, ARGBUF *);
d108 1
a108 1
typedef SEM_STATUS (SEMANTIC_FN) (SIM_CPU *, SEM_ARG, PAREXEC *, CGEN_INSN_INT);
d110 1
a110 1
typedef SEM_STATUS (SEMANTIC_FN) (SIM_CPU *, SEM_ARG, CGEN_INSN_INT);
@


1.4
log
@	Updated copyright notices for most files.
@
text
@d2 1
a2 1
   Copyright (C) 1998, 1999, 2007, 2008 Free Software Foundation, Inc.
@


1.3
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d2 1
a2 1
   Copyright (C) 1998, 1999, 2007 Free Software Foundation, Inc.
@


1.2
log
@Copyright updates for 2007.
@
text
@d9 2
a10 2
the Free Software Foundation; either version 2, or (at your option)
any later version.
d17 2
a18 3
You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1998, 1999 Free Software Foundation, Inc.
d21 3
a23 1
/* This file must be included after eng.h and before ${cpu}.h.  */
a65 16

#if CGEN_INSN_LSB0_P

#define EXTRACT_INT(val, total, start, length) \
  EXTRACT_LSB0_INT ((val), (total), (start), (length))
#define EXTRACT_UINT(val, total, start, length) \
  EXTRACT_LSB0_UINT ((val), (total), (start), (length))

#else

#define EXTRACT_INT(val, total, start, length) \
  EXTRACT_MSB0_INT ((val), (total), (start), (length))
#define EXTRACT_UINT(val, total, start, length) \
  EXTRACT_MSB0_UINT ((val), (total), (start), (length))

#endif
d79 1
a79 1
#if HAVE_PARALLEL_INSNS
d92 1
a92 1
#if HAVE_PARALLEL_INSNS
a168 5
/* These are used so that we can compile two copies of the semantic code,
   one with full feature support and one without that runs fast(er).  */
#define SEM_FN_NAME(cpu,fn) XCONCAT3 (cpu,_sem_,fn)
#define SEMF_FN_NAME(cpu,fn) XCONCAT3 (cpu,_semf_,fn)

a200 11
/* Value for br_addr_ptr indicating branch wasn't taken.  */
#define SEM_BRANCH_UNTAKEN ((SEM_PC *) 0)

/* Value for br_addr_ptr indicating branch was taken to uncacheable
   address (e.g. j reg).  */
#define SEM_BRANCH_UNCACHEABLE ((SEM_PC *) 1)

/* Initialize next-pbb link for SEM_BRANCH_VIA_CACHE.  */
#define SEM_BRANCH_INIT_EXTRACT(abuf) \
do { (abuf)->fields.cti.addr_cache = 0; } while (0)

d202 1
a202 1
   npc,npc_ptr are for communication between the cti insn and cti-chain.  */
d205 1
a205 1
  SEM_PC *npc_ptr = SEM_BRANCH_UNTAKEN;
d214 1
a214 1
  pbb_br_npc_ptr = npc_ptr; \
d220 1
a220 1
  CPU_PBB_BR_NPC_PTR (current_cpu) = npc_ptr; \
d224 1
a224 5
/* Return address of cached branch address value.  */
#define SEM_BRANCH_ADDR_CACHE(sem_arg) \
  (& SEM_ARGBUF (sem_arg)->fields.cti.addr_cache)

#define SEM_BRANCH_VIA_CACHE(cpu, sc, newval, pcvar, cachevarptr) \
d227 1
a227 1
  npc_ptr = (cachevarptr); \
d233 11
a243 1
  npc_ptr = SEM_BRANCH_UNCACHEABLE; \
a251 2
#define SEM_BRANCH_INIT_EXTRACT(abuf) do { } while (0)

d256 1
a256 1
#ifndef TARGET_SEM_BRANCH_FINI(pcvar, taken_p)
d262 1
a262 3
#define SEM_BRANCH_ADDR_CACHE(sem_arg) shouldnt_be_used

#define SEM_BRANCH_VIA_CACHE(cpu, sc, newval, pcvar, cachevar) \
d289 1
a289 3
#define SEM_BRANCH_ADDR_CACHE(sem_arg) shouldnt_be_used

#define SEM_BRANCH_VIA_CACHE(cpu, abuf, newval, pcvar, cachevar) \
d317 4
a320 1
/* Compile time computable instruction data.
d322 1
a322 2
   ??? May wish to move parallel execution support into its own struct.
   It's a fair bit of "clutter" for the "normal" case.  */
d332 2
a333 4
  /* Sanity check, at most one of these may be true.  */
#if WITH_PARALLEL_READ && WITH_PARALLEL_WRITE
#error "Both WITH_PARALLEL_READ && WITH_PARALLEL_WRITE can't be true."
#endif
d335 1
a335 1
#if WITH_PARALLEL_READ || WITH_PARALLEL_WRITE
d341 2
a342 7
#ifndef __GNUC__
  /* Semantic format number of pre-read handler.
     Only used by chips that support parallel execution of several insns.
     It is always implemented as a `switch'.  In the case of GNUC we use
     computed gotos.  When not GNUC, this is the argument to `switch'.  */
  int fmt;
#endif
d346 1
a346 2
  /* Index in IDESC table of writeback handler.
     Only used by chips that support parallel execution of several insns.  */
d349 8
d358 2
a359 9
  /* Routines to execute the insn.
     The full version has all features (profiling,tracing) compiled in.
     The fast version has none of that.  */
#if ! WITH_SEM_SWITCH_FULL
  SEMANTIC_FN *sem_full;
#endif
#if WITH_FAST && ! WITH_SEM_SWITCH_FAST
  SEMANTIC_FN *sem_fast;
#endif
d365 1
a365 3
  /* Parallel read-before-exec support.  */
#if WITH_PARALLEL_READ
  struct idesc *par_idesc;
d367 1
a367 1
  void *read;
d369 1
a369 1
  int fmt;
d371 2
a372 7
#endif

  /* Parallel write-after-exec support.  */
#if WITH_PARALLEL_WRITE
  /* Pointer to parallel handler if serial insn.
     Pointer to writeback handler if parallel insn.  */
  struct idesc *par_idesc;
d385 5
a389 8
#if WITH_SEM_SWITCH_FAST
#ifdef __GNUC__
  void *sem_fast_lab;
#else
  /* nothing needed, switch's on `num' member */
#endif
#else
  SEMANTIC_FN *sem_fast;
d396 3
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-06-28 snapshot
@
text
@d282 1
a282 1
#ifndef TARGET_SEM_BRANCH_FINI
@


1.1.1.3
log
@import gdb-1999-08-09 snapshot
@
text
@d183 5
d220 11
d232 1
a232 1
   npc,br_type are for communication between the cti insn and cti-chain.  */
d235 1
a235 1
  SEM_BRANCH_TYPE br_type = SEM_BRANCH_UNTAKEN;
d244 1
a244 1
  pbb_br_type = br_type; \
d250 1
a250 1
  CPU_PBB_BR_TYPE (current_cpu) = br_type; \
d254 5
a258 1
#define SEM_BRANCH_VIA_CACHE(cpu, sc, newval, pcvar) \
d261 1
a261 1
  br_type = SEM_BRANCH_CACHEABLE; \
d267 1
a267 11
  br_type = SEM_BRANCH_UNCACHEABLE; \
} while (0)

#define SEM_SKIP_COMPILE(cpu, sc, skip) \
do { \
  SEM_ARGBUF (sc) -> skip_count = (skip); \
} while (0)

#define SEM_SKIP_INSN(cpu, sc, vpcvar) \
do { \
  (vpcvar) += SEM_ARGBUF (sc) -> skip_count; \
d276 2
d288 3
a290 1
#define SEM_BRANCH_VIA_CACHE(cpu, sc, newval, pcvar) \
d317 3
a319 1
#define SEM_BRANCH_VIA_CACHE(cpu, abuf, newval, pcvar) \
d347 1
a347 4
/* Sanity check, at most one of these may be true.  */
#if WITH_PARALLEL_READ && WITH_PARALLEL_WRITE
#error "Both WITH_PARALLEL_READ && WITH_PARALLEL_WRITE can't be true."
#endif
d349 2
a350 1
/* Compile time computable instruction data.  */
d360 4
a363 2
  /* Semantic format number.  */
  int sfmt;
d371 7
a377 2
  /* Index in IDESC table of read handler.  */
  int read_index;
d381 2
a382 1
  /* Index in IDESC table of writeback handler.  */
a384 1
};
d386 9
a394 9
/* Entry in semantic function table.
   This information is copied to the insn descriptor table at run-time.  */

struct sem_fn_desc {
  /* Index in IDESC table.  */
  int index;

  /* Function to perform the semantics of the insn.  */
  SEMANTIC_FN *fn;
d400 3
a402 1
#if WITH_SEM_SWITCH_FAST
d404 1
a404 1
  void *sem_fast_lab;
d406 2
a407 1
  /* nothing needed, switch's on `num' member */
d409 6
a414 2
#else
  SEMANTIC_FN *sem_fast;
d427 8
a434 5
  /* Parallel support.  */
#if WITH_PARALLEL_READ || WITH_PARALLEL_WRITE
  /* Pointer to parallel handler if serial insn.
     Pointer to readahead/writeback handler if parallel insn.  */
  struct idesc *par_idesc;
a439 3

  /* Semantic format id.  */
  int sfmt;
@


1.1.1.4
log
@import gdb-1999-08-23 snapshot
@
text
@d93 1
a93 1
#if HAVE_PARALLEL_INSNS && ! WITH_PARALLEL_GENWRITE
d106 1
a106 1
#if HAVE_PARALLEL_INSNS && ! WITH_PARALLEL_GENWRITE
d332 2
a333 2
#if WITH_PARALLEL_READ + WITH_PARALLEL_WRITE + WITH_PARALLEL_GENWRITE > 1
#error "At most one of WITH_PARALLEL_{READ,WRITE,GENWRITE} can be true."
d349 1
a349 1
#if HAVE_PARALLEL_INSNS && ! WITH_PARALLEL_ONLY
d400 1
a400 1
#if HAVE_PARALLEL_INSNS && (! WITH_PARALLEL_ONLY || (WITH_PARALLEL_ONLY && ! WITH_PARALLEL_GENWRITE))
@


1.1.1.5
log
@import gdb-1999-10-18 snapshot
@
text
@d21 1
a21 3
/* This file must be included after eng.h and before ${cpu}.h.
   ??? A lot of this could be moved to genmloop.sh to be put in eng.h
   and thus remove some conditional compilation.  Worth it?  */
d64 16
@


