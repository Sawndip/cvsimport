head	1.22;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.22
	gdb_7_6-2013-04-26-release:1.22
	gdb_7_6-branch:1.22.0.2
	gdb_7_6-2013-03-12-branchpoint:1.22
	gdb_7_5_1-2012-11-29-release:1.21
	gdb_7_5-2012-08-17-release:1.21
	gdb_7_5-branch:1.21.0.2
	gdb_7_5-2012-07-18-branchpoint:1.21
	gdb_7_4_1-2012-04-26-release:1.20.2.1
	gdb_7_4-2012-01-24-release:1.20.2.1
	gdb_7_4-branch:1.20.0.2
	gdb_7_4-2011-12-13-branchpoint:1.20
	gdb_7_3_1-2011-09-04-release:1.18
	gdb_7_3-2011-07-26-release:1.18
	gdb_7_3-branch:1.18.0.2
	gdb_7_3-2011-04-01-branchpoint:1.18
	gdb_7_2-2010-09-02-release:1.14
	gdb_7_2-branch:1.14.0.2
	gdb_7_2-2010-07-07-branchpoint:1.14
	gdb_7_1-2010-03-18-release:1.11
	gdb_7_1-branch:1.11.0.2
	gdb_7_1-2010-02-18-branchpoint:1.11
	gdb_7_0_1-2009-12-22-release:1.10
	gdb_7_0-2009-10-06-release:1.10
	gdb_7_0-branch:1.10.0.4
	gdb_7_0-2009-09-16-branchpoint:1.10
	arc-sim-20090309:1.9
	msnyder-checkpoint-072509-branch:1.10.0.2
	msnyder-checkpoint-072509-branchpoint:1.10
	arc-insight_6_8-branch:1.9.0.16
	arc-insight_6_8-branchpoint:1.9
	insight_6_8-branch:1.9.0.14
	insight_6_8-branchpoint:1.9
	reverse-20081226-branch:1.9.0.12
	reverse-20081226-branchpoint:1.9
	multiprocess-20081120-branch:1.9.0.10
	multiprocess-20081120-branchpoint:1.9
	reverse-20080930-branch:1.9.0.8
	reverse-20080930-branchpoint:1.9
	reverse-20080717-branch:1.9.0.6
	reverse-20080717-branchpoint:1.9
	msnyder-reverse-20080609-branch:1.9.0.4
	msnyder-reverse-20080609-branchpoint:1.9
	drow-reverse-20070409-branch:1.7.0.2
	drow-reverse-20070409-branchpoint:1.7
	gdb_6_8-2008-03-27-release:1.9
	gdb_6_8-branch:1.9.0.2
	gdb_6_8-2008-02-26-branchpoint:1.9
	gdb_6_7_1-2007-10-29-release:1.8
	gdb_6_7-2007-10-10-release:1.8
	gdb_6_7-branch:1.8.0.2
	gdb_6_7-2007-09-07-branchpoint:1.8
	insight_6_6-20070208-release:1.6
	gdb_6_6-2006-12-18-release:1.6
	gdb_6_6-branch:1.6.0.2
	gdb_6_6-2006-11-15-branchpoint:1.6
	insight_6_5-20061003-release:1.5
	gdb-csl-symbian-6_4_50_20060226-12:1.5
	gdb-csl-sourcerygxx-3_4_4-25:1.5
	nickrob-async-20060828-mergepoint:1.5
	gdb-csl-symbian-6_4_50_20060226-11:1.5
	gdb-csl-sourcerygxx-4_1-17:1.5
	gdb-csl-20060226-branch-local-2:1.5
	gdb-csl-sourcerygxx-4_1-14:1.5
	gdb-csl-sourcerygxx-4_1-13:1.5
	gdb-csl-sourcerygxx-4_1-12:1.5
	gdb-csl-sourcerygxx-3_4_4-21:1.5
	gdb_6_5-20060621-release:1.5
	gdb-csl-sourcerygxx-4_1-9:1.5
	gdb-csl-sourcerygxx-4_1-8:1.5
	gdb-csl-sourcerygxx-4_1-7:1.5
	gdb-csl-arm-2006q1-6:1.5
	gdb-csl-sourcerygxx-4_1-6:1.5
	gdb-csl-symbian-6_4_50_20060226-10:1.5
	gdb-csl-symbian-6_4_50_20060226-9:1.5
	gdb-csl-symbian-6_4_50_20060226-8:1.5
	gdb-csl-coldfire-4_1-11:1.5
	gdb-csl-sourcerygxx-3_4_4-19:1.5
	gdb-csl-coldfire-4_1-10:1.5
	gdb_6_5-branch:1.5.0.110
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb-csl-sourcerygxx-4_1-5:1.5
	nickrob-async-20060513-branch:1.5.0.108
	nickrob-async-20060513-branchpoint:1.5
	gdb-csl-sourcerygxx-4_1-4:1.5
	msnyder-reverse-20060502-branch:1.5.0.106
	msnyder-reverse-20060502-branchpoint:1.5
	gdb-csl-morpho-4_1-4:1.5
	gdb-csl-sourcerygxx-3_4_4-17:1.5
	readline_5_1-import-branch:1.5.0.104
	readline_5_1-import-branchpoint:1.5
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.5
	gdb-csl-symbian-20060226-branch:1.5.0.102
	gdb-csl-symbian-20060226-branchpoint:1.5
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.5
	msnyder-reverse-20060331-branch:1.5.0.100
	msnyder-reverse-20060331-branchpoint:1.5
	gdb-csl-available-20060303-branch:1.5.0.98
	gdb-csl-available-20060303-branchpoint:1.5
	gdb-csl-20060226-branch:1.5.0.96
	gdb-csl-20060226-branchpoint:1.5
	gdb_6_4-20051202-release:1.5
	msnyder-fork-checkpoint-branch:1.5.0.94
	msnyder-fork-checkpoint-branchpoint:1.5
	gdb-csl-gxxpro-6_3-branch:1.5.0.92
	gdb-csl-gxxpro-6_3-branchpoint:1.5
	gdb_6_4-branch:1.5.0.90
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb-csl-arm-20051020-branch:1.5.0.88
	gdb-csl-arm-20051020-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.86
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb-csl-arm-20050325-2005-q1b:1.5
	gdb-csl-arm-20050325-2005-q1a:1.5
	csl-arm-20050325-branch:1.5.0.84
	csl-arm-20050325-branchpoint:1.5
	gdb_6_3-20041109-release:1.5
	gdb_6_3-branch:1.5.0.80
	gdb_6_3-20041019-branchpoint:1.5
	drow_intercu-merge-20040921:1.5
	drow_intercu-merge-20040915:1.5
	jimb-gdb_6_2-e500-branch:1.5.0.82
	jimb-gdb_6_2-e500-branchpoint:1.5
	gdb_6_2-20040730-release:1.5
	gdb_6_2-branch:1.5.0.78
	gdb_6_2-2004-07-10-gmt-branchpoint:1.5
	gdb_6_1_1-20040616-release:1.5
	gdb_6_1-2004-04-05-release:1.5
	drow_intercu-merge-20040402:1.5
	drow_intercu-merge-20040327:1.5
	ezannoni_pie-20040323-branch:1.5.0.76
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.74
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.72
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow_intercu-20040221-branch:1.5.0.70
	drow_intercu-20040221-branchpoint:1.5
	cagney_bfdfile-20040213-branch:1.5.0.68
	cagney_bfdfile-20040213-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	cagney_bigcore-20040122-branch:1.5.0.66
	cagney_bigcore-20040122-branchpoint:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	kettenis_sparc-20030918-branch:1.5.0.64
	kettenis_sparc-20030918-branchpoint:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.62
	cagney_x86i386-20030821-branch:1.5.0.60
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.58
	gdb_6_0-2003-06-23-branchpoint:1.5
	jimb-ppc64-linux-20030613-branch:1.5.0.56
	jimb-ppc64-linux-20030613-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.54
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.52
	cagney_writestrings-20030508-branchpoint:1.5
	jimb-ppc64-linux-20030528-branch:1.5.0.50
	jimb-ppc64-linux-20030528-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.48
	cagney_fileio-20030521-branchpoint:1.5
	kettenis_i386newframe-20030517-mergepoint:1.5
	jimb-ppc64-linux-20030509-branch:1.5.0.46
	jimb-ppc64-linux-20030509-branchpoint:1.5
	kettenis_i386newframe-20030504-mergepoint:1.5
	carlton_dictionary-20030430-merge:1.5
	kettenis_i386newframe-20030419-branch:1.5.0.44
	kettenis_i386newframe-20030419-branchpoint:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	kettenis_i386newframe-20030406-branch:1.5.0.42
	kettenis_i386newframe-20030406-branchpoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.40
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.38
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.36
	cagney_lazyid-20030317-branchpoint:1.5
	kettenis-i386newframe-20030316-mergepoint:1.5
	offbyone-20030313-branch:1.5.0.34
	offbyone-20030313-branchpoint:1.5
	kettenis-i386newframe-20030308-branch:1.5.0.32
	kettenis-i386newframe-20030308-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.30
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.28
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.26
	cagney-unwind-20030108-branchpoint:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.5
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.24
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.22
	carlton_dictionary-20020920-branchpoint:1.5
	gdb_5_3-branch:1.5.0.20
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.18
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.16
	readline_4_3-import-branchpoint:1.5
	gdb_5_2_1-2002-07-23-release:1.5
	kseitz_interps-20020528-branch:1.5.0.14
	kseitz_interps-20020528-branchpoint:1.5
	cagney_regbuf-20020515-branch:1.5.0.12
	cagney_regbuf-20020515-branchpoint:1.5
	jimb-macro-020506-branch:1.5.0.10
	jimb-macro-020506-branchpoint:1.5
	gdb_5_2-2002-04-29-release:1.5
	gdb_5_2-branch:1.5.0.8
	gdb_5_2-2002-03-03-branchpoint:1.5
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.4
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.2
	gdb_5_1-2001-07-29-branchpoint:1.5
	insight-precleanup-2001-01-01:1.4
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.22
date	2013.01.01.06.41.33;	author brobecke;	state Exp;
branches;
next	1.21;

1.21
date	2012.01.04.08.28.06;	author brobecke;	state Exp;
branches;
next	1.20;

1.20
date	2011.10.19.00.54.03;	author brobecke;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2011.05.11.20.02.42;	author vapier;	state Exp;
branches;
next	1.18;

1.18
date	2011.03.15.03.16.17;	author vapier;	state Exp;
branches;
next	1.17;

1.17
date	2011.02.14.05.14.26;	author vapier;	state Exp;
branches;
next	1.16;

1.16
date	2011.01.01.15.33.56;	author brobecke;	state Exp;
branches;
next	1.15;

1.15
date	2010.11.23.02.48.54;	author vapier;	state Exp;
branches;
next	1.14;

1.14
date	2010.04.22.00.26.08;	author vapier;	state Exp;
branches;
next	1.13;

1.13
date	2010.04.12.16.53.33;	author vapier;	state Exp;
branches;
next	1.12;

1.12
date	2010.03.30.20.35.39;	author vapier;	state Exp;
branches;
next	1.11;

1.11
date	2010.01.01.10.03.27;	author brobecke;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.14.10.53.06;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2008.01.01.22.53.23;	author drow;	state Exp;
branches;
next	1.8;

1.8
date	2007.08.24.14.28.35;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.09.17.59.16;	author drow;	state Exp;
branches;
next	1.6;

1.6
date	2006.08.29.13.16.19;	author ths;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.15.21.14.40;	author bje;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.03.04.23.54;	author bje;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.15.18.49.50;	author brolley;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.15.18.39.02;	author brolley;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.58;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.20.2.1
date	2012.01.06.04.54.40;	author brobecke;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.58;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.12.22.21.45.38;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* Default profiling support.
   Copyright (C) 1996-2013 Free Software Foundation, Inc.
   Contributed by Cygnus Support.

This file is part of GDB, the GNU debugger.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "sim-main.h"
#include "sim-io.h"
#include "sim-options.h"
#include "sim-assert.h"

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#ifdef HAVE_STRING_H
#include <string.h>
#else
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif
#endif
#include <ctype.h>

#if !WITH_PROFILE_PC_P
static unsigned int _profile_stub;
# define PROFILE_PC_FREQ(p) _profile_stub
# define PROFILE_PC_NR_BUCKETS(p) _profile_stub
# define PROFILE_PC_SHIFT(p) _profile_stub
# define PROFILE_PC_START(p) _profile_stub
# define PROFILE_PC_END(p) _profile_stub
# define PROFILE_INSN_COUNT(p) &_profile_stub
#endif

#define COMMAS(n) sim_add_commas (comma_buf, sizeof (comma_buf), (n))

static MODULE_INIT_FN profile_init;
static MODULE_UNINSTALL_FN profile_uninstall;

static DECLARE_OPTION_HANDLER (profile_option_handler);

enum {
  OPTION_PROFILE_INSN = OPTION_START,
  OPTION_PROFILE_MEMORY,
  OPTION_PROFILE_MODEL,
  OPTION_PROFILE_FILE,
  OPTION_PROFILE_CORE,
  OPTION_PROFILE_CPU_FREQUENCY,
  OPTION_PROFILE_PC,
  OPTION_PROFILE_PC_RANGE,
  OPTION_PROFILE_PC_GRANULARITY,
  OPTION_PROFILE_RANGE,
  OPTION_PROFILE_FUNCTION
};

static const OPTION profile_options[] = {
  { {"profile", optional_argument, NULL, 'p'},
      'p', "on|off", "Perform profiling",
      profile_option_handler, NULL },
  { {"profile-insn", optional_argument, NULL, OPTION_PROFILE_INSN},
      '\0', "on|off", "Perform instruction profiling",
      profile_option_handler, NULL },
  { {"profile-memory", optional_argument, NULL, OPTION_PROFILE_MEMORY},
      '\0', "on|off", "Perform memory profiling",
      profile_option_handler, NULL },
  { {"profile-core", optional_argument, NULL, OPTION_PROFILE_CORE},
      '\0', "on|off", "Perform CORE profiling",
      profile_option_handler, NULL },
  { {"profile-model", optional_argument, NULL, OPTION_PROFILE_MODEL},
      '\0', "on|off", "Perform model profiling",
      profile_option_handler, NULL },
  { {"profile-cpu-frequency", required_argument, NULL,
     OPTION_PROFILE_CPU_FREQUENCY},
      '\0', "CPU FREQUENCY", "Specify the speed of the simulated cpu clock",
      profile_option_handler, NULL },

  { {"profile-file", required_argument, NULL, OPTION_PROFILE_FILE},
      '\0', "FILE NAME", "Specify profile output file",
      profile_option_handler, NULL },

  { {"profile-pc", optional_argument, NULL, OPTION_PROFILE_PC},
      '\0', "on|off", "Perform PC profiling",
      profile_option_handler, NULL },
  { {"profile-pc-frequency", required_argument, NULL, 'F'},
      'F', "PC PROFILE FREQUENCY", "Specified PC profiling frequency",
      profile_option_handler, NULL },
  { {"profile-pc-size", required_argument, NULL, 'S'},
      'S', "PC PROFILE SIZE", "Specify PC profiling size",
      profile_option_handler, NULL },
  { {"profile-pc-granularity", required_argument, NULL, OPTION_PROFILE_PC_GRANULARITY},
      '\0', "PC PROFILE GRANULARITY", "Specify PC profiling sample coverage",
      profile_option_handler, NULL },
  { {"profile-pc-range", required_argument, NULL, OPTION_PROFILE_PC_RANGE},
      '\0', "BASE,BOUND", "Specify PC profiling address range",
      profile_option_handler, NULL },

#ifdef SIM_HAVE_ADDR_RANGE
  { {"profile-range", required_argument, NULL, OPTION_PROFILE_RANGE},
      '\0', "START,END", "Specify range of addresses for instruction and model profiling",
      profile_option_handler, NULL },
#if 0 /*wip*/
  { {"profile-function", required_argument, NULL, OPTION_PROFILE_FUNCTION},
      '\0', "FUNCTION", "Specify function to profile",
      profile_option_handler, NULL },
#endif
#endif

  { {NULL, no_argument, NULL, 0}, '\0', NULL, NULL, NULL, NULL }
};

/* Set/reset the profile options indicated in MASK.  */

SIM_RC
set_profile_option_mask (SIM_DESC sd, const char *name, int mask, const char *arg)
{
  int profile_nr;
  int cpu_nr;
  int profile_val = 1;

  if (arg != NULL)
    {
      if (strcmp (arg, "yes") == 0
	  || strcmp (arg, "on") == 0
	  || strcmp (arg, "1") == 0)
	profile_val = 1;
      else if (strcmp (arg, "no") == 0
	       || strcmp (arg, "off") == 0
	       || strcmp (arg, "0") == 0)
	profile_val = 0;
      else
	{
	  sim_io_eprintf (sd, "Argument `%s' for `--profile%s' invalid, one of `on', `off', `yes', `no' expected\n", arg, name);
	  return SIM_RC_FAIL;
	}
    }

  /* update applicable profile bits */
  for (profile_nr = 0; profile_nr < MAX_PROFILE_VALUES; ++profile_nr)
    {
      if ((mask & (1 << profile_nr)) == 0)
	continue;

#if 0 /* see sim-trace.c, set flags in STATE here if/when there are any */
      /* Set non-cpu specific values.  */
      switch (profile_nr)
	{
	case ??? :
	  break;
	}
#endif

      /* Set cpu values.  */
      for (cpu_nr = 0; cpu_nr < MAX_NR_PROCESSORS; cpu_nr++)
	{
	  CPU_PROFILE_FLAGS (STATE_CPU (sd, cpu_nr))[profile_nr] = profile_val;
	}
    }

  /* Re-compute the cpu profile summary.  */
  if (profile_val)
    {
      for (cpu_nr = 0; cpu_nr < MAX_NR_PROCESSORS; cpu_nr++)
	CPU_PROFILE_DATA (STATE_CPU (sd, cpu_nr))->profile_any_p = 1;
    }
  else
    {
      for (cpu_nr = 0; cpu_nr < MAX_NR_PROCESSORS; cpu_nr++)
	{
	  CPU_PROFILE_DATA (STATE_CPU (sd, cpu_nr))->profile_any_p = 0;
	  for (profile_nr = 0; profile_nr < MAX_PROFILE_VALUES; ++profile_nr)
	    {
	      if (CPU_PROFILE_FLAGS (STATE_CPU (sd, cpu_nr))[profile_nr])
		{
		  CPU_PROFILE_DATA (STATE_CPU (sd, cpu_nr))->profile_any_p = 1;
		  break;
		}
	    }
	}
    }

  return SIM_RC_OK;
}

/* Set one profile option based on its IDX value.
   Not static as cgen-scache.c uses it.  */

SIM_RC
sim_profile_set_option (SIM_DESC sd, const char *name, int idx, const char *arg)
{
  return set_profile_option_mask (sd, name, 1 << idx, arg);
}

static SIM_RC
parse_frequency (SIM_DESC sd, const char *arg, unsigned long *freq)
{
  const char *ch;
  /* First, parse a decimal number.  */
  *freq = 0;
  ch = arg;
  if (isdigit (*arg))
    {
      for (/**/; *ch != '\0'; ++ch)
	{
	  if (! isdigit (*ch))
	    break;
	  *freq = *freq * 10 + (*ch - '0');
	}

      /* Accept KHz, MHz or Hz as a suffix.  */
      if (tolower (*ch) == 'm')
	{
	  *freq *= 1000000;
	  ++ch;
	}
      else if (tolower (*ch) == 'k')
	{
	  *freq *= 1000;
	  ++ch;
	}

      if (tolower (*ch) == 'h')
	{
	  ++ch;
	  if (tolower (*ch) == 'z')
	    ++ch;
	}
    }

  if (*ch != '\0')
    {
      sim_io_eprintf (sd, "Invalid argument for --profile-cpu-frequency: %s\n",
		      arg);
      *freq = 0;
      return SIM_RC_FAIL;
    }

  return SIM_RC_OK;
}

static SIM_RC
profile_option_handler (SIM_DESC sd,
			sim_cpu *cpu,
			int opt,
			char *arg,
			int is_command)
{
  int cpu_nr;

  /* FIXME: Need to handle `cpu' arg.  */

  switch (opt)
    {
    case 'p' :
      if (! WITH_PROFILE)
	sim_io_eprintf (sd, "Profiling not compiled in, `-p' ignored\n");
      else
	return set_profile_option_mask (sd, "profile", PROFILE_USEFUL_MASK,
					arg);
      break;

    case OPTION_PROFILE_INSN :
      if (WITH_PROFILE_INSN_P)
	return sim_profile_set_option (sd, "-insn", PROFILE_INSN_IDX, arg);
      else
	sim_io_eprintf (sd, "Instruction profiling not compiled in, `--profile-insn' ignored\n");
      break;

    case OPTION_PROFILE_MEMORY :
      if (WITH_PROFILE_MEMORY_P)
	return sim_profile_set_option (sd, "-memory", PROFILE_MEMORY_IDX, arg);
      else
	sim_io_eprintf (sd, "Memory profiling not compiled in, `--profile-memory' ignored\n");
      break;

    case OPTION_PROFILE_CORE :
      if (WITH_PROFILE_CORE_P)
	return sim_profile_set_option (sd, "-core", PROFILE_CORE_IDX, arg);
      else
	sim_io_eprintf (sd, "CORE profiling not compiled in, `--profile-core' ignored\n");
      break;

    case OPTION_PROFILE_MODEL :
      if (WITH_PROFILE_MODEL_P)
	return sim_profile_set_option (sd, "-model", PROFILE_MODEL_IDX, arg);
      else
	sim_io_eprintf (sd, "Model profiling not compiled in, `--profile-model' ignored\n");
      break;

    case OPTION_PROFILE_CPU_FREQUENCY :
      {
	unsigned long val;
	SIM_RC rc = parse_frequency (sd, arg, &val);
	if (rc == SIM_RC_OK)
	  {
	    for (cpu_nr = 0; cpu_nr < MAX_NR_PROCESSORS; ++cpu_nr)
	      PROFILE_CPU_FREQ (CPU_PROFILE_DATA (STATE_CPU (sd,cpu_nr))) = val;
	  }
	return rc;
      }

    case OPTION_PROFILE_FILE :
      /* FIXME: Might want this to apply to pc profiling only,
	 or have two profile file options.  */
      if (! WITH_PROFILE)
	sim_io_eprintf (sd, "Profiling not compiled in, `--profile-file' ignored\n");
      else
	{
	  FILE *f = fopen (arg, "w");

	  if (f == NULL)
	    {
	      sim_io_eprintf (sd, "Unable to open profile output file `%s'\n", arg);
	      return SIM_RC_FAIL;
	    }
	  for (cpu_nr = 0; cpu_nr < MAX_NR_PROCESSORS; ++cpu_nr)
	    PROFILE_FILE (CPU_PROFILE_DATA (STATE_CPU (sd, cpu_nr))) = f;
	}
      break;

    case OPTION_PROFILE_PC:
      if (WITH_PROFILE_PC_P)
	return sim_profile_set_option (sd, "-pc", PROFILE_PC_IDX, arg);
      else
	sim_io_eprintf (sd, "PC profiling not compiled in, `--profile-pc' ignored\n");
      break;

    case 'F' :
      if (WITH_PROFILE_PC_P)
	{
	  /* FIXME: Validate arg.  */
	  int val = atoi (arg);
	  for (cpu_nr = 0; cpu_nr < MAX_NR_PROCESSORS; ++cpu_nr)
	    PROFILE_PC_FREQ (CPU_PROFILE_DATA (STATE_CPU (sd, cpu_nr))) = val;
	  for (cpu_nr = 0; cpu_nr < MAX_NR_PROCESSORS; ++cpu_nr)
	    CPU_PROFILE_FLAGS (STATE_CPU (sd, cpu_nr))[PROFILE_PC_IDX] = 1;
	}
      else
	sim_io_eprintf (sd, "PC profiling not compiled in, `--profile-pc-frequency' ignored\n");
      break;

    case 'S' :
      if (WITH_PROFILE_PC_P)
	{
	  /* FIXME: Validate arg.  */
	  int val = atoi (arg);
	  for (cpu_nr = 0; cpu_nr < MAX_NR_PROCESSORS; ++cpu_nr)
	    PROFILE_PC_NR_BUCKETS (CPU_PROFILE_DATA (STATE_CPU (sd, cpu_nr))) = val;
	  for (cpu_nr = 0; cpu_nr < MAX_NR_PROCESSORS; ++cpu_nr)
	    CPU_PROFILE_FLAGS (STATE_CPU (sd, cpu_nr))[PROFILE_PC_IDX] = 1;
	}
      else
	sim_io_eprintf (sd, "PC profiling not compiled in, `--profile-pc-size' ignored\n");
      break;

    case OPTION_PROFILE_PC_GRANULARITY:
      if (WITH_PROFILE_PC_P)
	{
	  int shift;
	  int val = atoi (arg);
	  /* check that the granularity is a power of two */
	  shift = 0;
	  while (val > (1 << shift))
	    {
	      shift += 1;
	    }
	  if (val != (1 << shift))
	    {
	      sim_io_eprintf (sd, "PC profiling granularity not a power of two\n");
	      return SIM_RC_FAIL;
	    }
	  if (shift == 0)
	    {
	      sim_io_eprintf (sd, "PC profiling granularity too small");
	      return SIM_RC_FAIL;
	    }
	  for (cpu_nr = 0; cpu_nr < MAX_NR_PROCESSORS; ++cpu_nr)
	    PROFILE_PC_SHIFT (CPU_PROFILE_DATA (STATE_CPU (sd, cpu_nr))) = shift;
	  for (cpu_nr = 0; cpu_nr < MAX_NR_PROCESSORS; ++cpu_nr)
	    CPU_PROFILE_FLAGS (STATE_CPU (sd, cpu_nr))[PROFILE_PC_IDX] = 1;
	}
      else
	sim_io_eprintf (sd, "PC profiling not compiled in, `--profile-pc-granularity' ignored\n");
      break;

    case OPTION_PROFILE_PC_RANGE:
      if (WITH_PROFILE_PC_P)
	{
	  /* FIXME: Validate args */
	  char *chp = arg;
	  unsigned long base;
	  unsigned long bound;
	  base = strtoul (chp, &chp, 0);
	  if (*chp != ',')
	    {
	      sim_io_eprintf (sd, "--profile-pc-range missing BOUND argument\n");
	      return SIM_RC_FAIL;
	    }
	  bound = strtoul (chp + 1, NULL, 0);
	  for (cpu_nr = 0; cpu_nr < MAX_NR_PROCESSORS; ++cpu_nr)
	    {
	      PROFILE_PC_START (CPU_PROFILE_DATA (STATE_CPU (sd, cpu_nr))) = base;
	      PROFILE_PC_END (CPU_PROFILE_DATA (STATE_CPU (sd, cpu_nr))) = bound;
	    }
	  for (cpu_nr = 0; cpu_nr < MAX_NR_PROCESSORS; ++cpu_nr)
	    CPU_PROFILE_FLAGS (STATE_CPU (sd, cpu_nr))[PROFILE_PC_IDX] = 1;
	}
      else
	sim_io_eprintf (sd, "PC profiling not compiled in, `--profile-pc-range' ignored\n");
      break;

#ifdef SIM_HAVE_ADDR_RANGE
    case OPTION_PROFILE_RANGE :
      if (WITH_PROFILE)
	{
	  char *chp = arg;
	  unsigned long start,end;
	  start = strtoul (chp, &chp, 0);
	  if (*chp != ',')
	    {
	      sim_io_eprintf (sd, "--profile-range missing END argument\n");
	      return SIM_RC_FAIL;
	    }
	  end = strtoul (chp + 1, NULL, 0);
	  /* FIXME: Argument validation.  */
	  if (cpu != NULL)
	    sim_addr_range_add (PROFILE_RANGE (CPU_PROFILE_DATA (cpu)),
				start, end);
	  else
	    for (cpu_nr = 0; cpu_nr < MAX_NR_PROCESSORS; ++cpu_nr)
	      sim_addr_range_add (PROFILE_RANGE (CPU_PROFILE_DATA (STATE_CPU (sd, cpu_nr))),
				  start, end);
	}
      else
	sim_io_eprintf (sd, "Profiling not compiled in, `--profile-range' ignored\n");
      break;

    case OPTION_PROFILE_FUNCTION :
      if (WITH_PROFILE)
	{
	  /*wip: need to compute function range given name*/
	}
      else
	sim_io_eprintf (sd, "Profiling not compiled in, `--profile-function' ignored\n");
      break;
#endif /* SIM_HAVE_ADDR_RANGE */
    }

  return SIM_RC_OK;
}

/* Profiling output hooks.  */

static void
profile_vprintf (SIM_DESC sd, sim_cpu *cpu, const char *fmt, va_list ap)
{
  FILE *fp = PROFILE_FILE (CPU_PROFILE_DATA (cpu));

  /* If an output file was given, redirect output to that.  */
  if (fp != NULL)
    vfprintf (fp, fmt, ap);
  else
    sim_io_evprintf (sd, fmt, ap);
}

__attribute__ ((format (printf, 3, 4)))
static void
profile_printf (SIM_DESC sd, sim_cpu *cpu, const char *fmt, ...)
{
  va_list ap;

  va_start (ap, fmt);
  profile_vprintf (sd, cpu, fmt, ap);
  va_end (ap);
}

/* PC profiling support */

#if WITH_PROFILE_PC_P

static void
profile_pc_cleanup (SIM_DESC sd)
{
  int n;
  for (n = 0; n < MAX_NR_PROCESSORS; n++)
    {
      sim_cpu *cpu = STATE_CPU (sd, n);
      PROFILE_DATA *data = CPU_PROFILE_DATA (cpu);
      if (PROFILE_PC_COUNT (data) != NULL)
	free (PROFILE_PC_COUNT (data));
      PROFILE_PC_COUNT (data) = NULL;
      if (PROFILE_PC_EVENT (data) != NULL)
	sim_events_deschedule (sd, PROFILE_PC_EVENT (data));
      PROFILE_PC_EVENT (data) = NULL;
    }
}


static void
profile_pc_uninstall (SIM_DESC sd)
{
  profile_pc_cleanup (sd);
}

static void
profile_pc_event (SIM_DESC sd,
		  void *data)
{
  sim_cpu *cpu = (sim_cpu*) data;
  PROFILE_DATA *profile = CPU_PROFILE_DATA (cpu);
  address_word pc;
  unsigned i;
  switch (STATE_WATCHPOINTS (sd)->sizeof_pc)
    {
    case 2: pc = *(unsigned_2*)(STATE_WATCHPOINTS (sd)->pc) ; break;
    case 4: pc = *(unsigned_4*)(STATE_WATCHPOINTS (sd)->pc) ; break;
    case 8: pc = *(unsigned_8*)(STATE_WATCHPOINTS (sd)->pc) ; break;
    default: pc = 0;
    }
  i = (pc - PROFILE_PC_START (profile)) >> PROFILE_PC_SHIFT (profile);
  if (i < PROFILE_PC_NR_BUCKETS (profile))
    PROFILE_PC_COUNT (profile) [i] += 1; /* Overflow? */
  else
    PROFILE_PC_COUNT (profile) [PROFILE_PC_NR_BUCKETS (profile)] += 1;
  PROFILE_PC_EVENT (profile) =
    sim_events_schedule (sd, PROFILE_PC_FREQ (profile), profile_pc_event, cpu);
}

static SIM_RC
profile_pc_init (SIM_DESC sd)
{
  int n;
  profile_pc_cleanup (sd);
  for (n = 0; n < MAX_NR_PROCESSORS; n++)
    {
      sim_cpu *cpu = STATE_CPU (sd, n);
      PROFILE_DATA *data = CPU_PROFILE_DATA (cpu);
      if (CPU_PROFILE_FLAGS (STATE_CPU (sd, n))[PROFILE_PC_IDX]
	  && STATE_WATCHPOINTS (sd)->pc != NULL)
	{
	  int bucket_size;
	  /* fill in the frequency if not specified */
	  if (PROFILE_PC_FREQ (data) == 0)
	    PROFILE_PC_FREQ (data) = 257;
	  /* fill in the start/end if not specified */
	  if (PROFILE_PC_END (data) == 0)
	    {
	      PROFILE_PC_START (data) = STATE_TEXT_START (sd);
	      PROFILE_PC_END (data) = STATE_TEXT_END (sd);
	    }
	  /* Compute the number of buckets if not specified. */
	  if (PROFILE_PC_NR_BUCKETS (data) == 0)
	    {
	      if (PROFILE_PC_BUCKET_SIZE (data) == 0)
		PROFILE_PC_NR_BUCKETS (data) = 16;
	      else
		{
		  if (PROFILE_PC_END (data) == 0)
		    {
		      /* nr_buckets = (full-address-range / 2) / (bucket_size / 2) */
		      PROFILE_PC_NR_BUCKETS (data) =
			((1 << (STATE_WATCHPOINTS (sd)->sizeof_pc) * (8 - 1))
			 / (PROFILE_PC_BUCKET_SIZE (data) / 2));
		    }
		  else
		    {
		      PROFILE_PC_NR_BUCKETS (data) =
			((PROFILE_PC_END (data)
			  - PROFILE_PC_START (data)
			  + PROFILE_PC_BUCKET_SIZE (data) - 1)
			 / PROFILE_PC_BUCKET_SIZE (data));
		    }
		}
	    }
	  /* Compute the bucket size if not specified.  Ensure that it
             is rounded up to the next power of two */
	  if (PROFILE_PC_BUCKET_SIZE (data) == 0)
	    {
	      if (PROFILE_PC_END (data) == 0)
		/* bucket_size = (full-address-range / 2) / (nr_buckets / 2) */
		bucket_size = ((1 << ((STATE_WATCHPOINTS (sd)->sizeof_pc * 8) - 1))
			       / (PROFILE_PC_NR_BUCKETS (data) / 2));
	      else
		bucket_size = ((PROFILE_PC_END (data)
				- PROFILE_PC_START (data)
				+ PROFILE_PC_NR_BUCKETS (data) - 1)
			       / PROFILE_PC_NR_BUCKETS (data));
	      PROFILE_PC_SHIFT (data) = 0;
	      while (bucket_size > PROFILE_PC_BUCKET_SIZE (data))
		{
		  PROFILE_PC_SHIFT (data) += 1;
		}
	    }
	  /* Align the end address with bucket size */
	  if (PROFILE_PC_END (data) != 0)
	    PROFILE_PC_END (data) = (PROFILE_PC_START (data)
				     + (PROFILE_PC_BUCKET_SIZE (data)
					* PROFILE_PC_NR_BUCKETS (data)));
	  /* create the relevant buffers */
	  PROFILE_PC_COUNT (data) =
	    NZALLOC (unsigned, PROFILE_PC_NR_BUCKETS (data) + 1);
	  PROFILE_PC_EVENT (data) =
	    sim_events_schedule (sd,
				 PROFILE_PC_FREQ (data),
				 profile_pc_event,
				 cpu);
	}
    }
  return SIM_RC_OK;
}

static void
profile_print_pc (sim_cpu *cpu, int verbose)
{
  SIM_DESC sd = CPU_STATE (cpu);
  PROFILE_DATA *profile = CPU_PROFILE_DATA (cpu);
  char comma_buf[20];
  unsigned max_val;
  unsigned total;
  unsigned i;

  if (PROFILE_PC_COUNT (profile) == 0)
    return;

  profile_printf (sd, cpu, "Program Counter Statistics:\n\n");

  /* First pass over data computes various things.  */
  max_val = 0;
  total = 0;
  for (i = 0; i <= PROFILE_PC_NR_BUCKETS (profile); ++i)
    {
      total += PROFILE_PC_COUNT (profile) [i];
      if (PROFILE_PC_COUNT (profile) [i] > max_val)
	max_val = PROFILE_PC_COUNT (profile) [i];
    }

  profile_printf (sd, cpu, "  Total samples: %s\n",
		  COMMAS (total));
  profile_printf (sd, cpu, "  Granularity: %s bytes per bucket\n",
		  COMMAS (PROFILE_PC_BUCKET_SIZE (profile)));
  profile_printf (sd, cpu, "  Size: %s buckets\n",
		  COMMAS (PROFILE_PC_NR_BUCKETS (profile)));
  profile_printf (sd, cpu, "  Frequency: %s cycles per sample\n",
		  COMMAS (PROFILE_PC_FREQ (profile)));

  if (PROFILE_PC_END (profile) != 0)
    profile_printf (sd, cpu, "  Range: 0x%lx 0x%lx\n",
		    (long) PROFILE_PC_START (profile),
		   (long) PROFILE_PC_END (profile));

  if (verbose && max_val != 0)
    {
      /* Now we can print the histogram.  */
      profile_printf (sd, cpu, "\n");
      for (i = 0; i <= PROFILE_PC_NR_BUCKETS (profile); ++i)
	{
	  if (PROFILE_PC_COUNT (profile) [i] != 0)
	    {
	      profile_printf (sd, cpu, "  ");
	      if (i == PROFILE_PC_NR_BUCKETS (profile))
		profile_printf (sd, cpu, "%10s:", "overflow");
	      else
		profile_printf (sd, cpu, "0x%08lx:",
				(long) (PROFILE_PC_START (profile)
					+ (i * PROFILE_PC_BUCKET_SIZE (profile))));
	      profile_printf (sd, cpu, " %*s",
			      max_val < 10000 ? 5 : 10,
			      COMMAS (PROFILE_PC_COUNT (profile) [i]));
	      profile_printf (sd, cpu, " %4.1f",
			      (PROFILE_PC_COUNT (profile) [i] * 100.0) / total);
	      profile_printf (sd, cpu, ": ");
	      sim_profile_print_bar (sd, cpu, PROFILE_HISTOGRAM_WIDTH,
				     PROFILE_PC_COUNT (profile) [i],
				     max_val);
	      profile_printf (sd, cpu, "\n");
	    }
	}
    }

  /* dump the histogram to the file "gmon.out" using BSD's gprof file
     format */
  /* Since a profile data file is in the native format of the host on
     which the profile is being, endian issues are not considered in
     the code below. */
  /* FIXME: Is this the best place for this code? */
  {
    FILE *pf = fopen ("gmon.out", "wb");

    if (pf == NULL)
      sim_io_eprintf (sd, "Failed to open \"gmon.out\" profile file\n");
    else
      {
	int ok;
	/* FIXME: what if the target has a 64 bit PC? */
	unsigned32 header[3];
	unsigned loop;
	if (PROFILE_PC_END (profile) != 0)
	  {
	    header[0] = PROFILE_PC_START (profile);
	    header[1] = PROFILE_PC_END (profile);
	  }
	else
	  {
	    header[0] = 0;
	    header[1] = 0;
	  }
	/* size of sample buffer (+ header) */
	header[2] = PROFILE_PC_NR_BUCKETS (profile) * 2 + sizeof (header);

	/* Header must be written out in target byte order.  */
	H2T (header[0]);
	H2T (header[1]);
	H2T (header[2]);

	ok = fwrite (&header, sizeof (header), 1, pf);
	for (loop = 0;
	     ok && (loop < PROFILE_PC_NR_BUCKETS (profile));
	     loop++)
	  {
	    signed16 sample;
	    if (PROFILE_PC_COUNT (profile) [loop] >= 0xffff)
	      sample = 0xffff;
	    else
	      sample = PROFILE_PC_COUNT (profile) [loop];
 	    H2T (sample);
	    ok = fwrite (&sample, sizeof (sample), 1, pf);
	  }
	if (ok == 0)
	  sim_io_eprintf (sd, "Failed to write to \"gmon.out\" profile file\n");
	fclose (pf);
      }
  }

  profile_printf (sd, cpu, "\n");
}

#endif

/* Summary printing support.  */

#if WITH_PROFILE_INSN_P

static SIM_RC
profile_insn_init (SIM_DESC sd)
{
  int c;

  for (c = 0; c < MAX_NR_PROCESSORS; ++c)
    {
      sim_cpu *cpu = STATE_CPU (sd, c);

      if (CPU_MAX_INSNS (cpu) > 0)
	PROFILE_INSN_COUNT (CPU_PROFILE_DATA (cpu)) = NZALLOC (unsigned int, CPU_MAX_INSNS (cpu));
    }

  return SIM_RC_OK;
}

static void
profile_print_insn (sim_cpu *cpu, int verbose)
{
  unsigned int i, n, total, max_val, max_name_len;
  SIM_DESC sd = CPU_STATE (cpu);
  PROFILE_DATA *data = CPU_PROFILE_DATA (cpu);
  char comma_buf[20];

  /* If MAX_INSNS not set, insn profiling isn't supported.  */
  if (CPU_MAX_INSNS (cpu) == 0)
    return;

  profile_printf (sd, cpu, "Instruction Statistics");
#ifdef SIM_HAVE_ADDR_RANGE
  if (PROFILE_RANGE (data)->ranges)
    profile_printf (sd, cpu, " (for selected address range(s))");
#endif
  profile_printf (sd, cpu, "\n\n");

  /* First pass over data computes various things.  */
  max_val = 0;
  total = 0;
  max_name_len = 0;
  for (i = 0; i < CPU_MAX_INSNS (cpu); ++i)
    {
      const char *name = (*CPU_INSN_NAME (cpu)) (cpu, i);

      if (name == NULL)
	continue;
      total += PROFILE_INSN_COUNT (data) [i];
      if (PROFILE_INSN_COUNT (data) [i] > max_val)
	max_val = PROFILE_INSN_COUNT (data) [i];
      n = strlen (name);
      if (n > max_name_len)
	max_name_len = n;
    }
  /* set the total insn count, in case client is being lazy */
  if (! PROFILE_TOTAL_INSN_COUNT (data))
    PROFILE_TOTAL_INSN_COUNT (data) = total;

  profile_printf (sd, cpu, "  Total: %s insns\n", COMMAS (total));

  if (verbose && max_val != 0)
    {
      /* Now we can print the histogram.  */
      profile_printf (sd, cpu, "\n");
      for (i = 0; i < CPU_MAX_INSNS (cpu); ++i)
	{
	  const char *name = (*CPU_INSN_NAME (cpu)) (cpu, i);

	  if (name == NULL)
	    continue;
	  if (PROFILE_INSN_COUNT (data) [i] != 0)
	    {
	      profile_printf (sd, cpu, "   %*s: %*s: ",
			      max_name_len, name,
			      max_val < 10000 ? 5 : 10,
			      COMMAS (PROFILE_INSN_COUNT (data) [i]));
	      sim_profile_print_bar (sd, cpu, PROFILE_HISTOGRAM_WIDTH,
				     PROFILE_INSN_COUNT (data) [i],
				     max_val);
	      profile_printf (sd, cpu, "\n");
	    }
	}
    }

  profile_printf (sd, cpu, "\n");
}

#endif

#if WITH_PROFILE_MEMORY_P

static void
profile_print_memory (sim_cpu *cpu, int verbose)
{
  unsigned int i, n;
  unsigned int total_read, total_write;
  unsigned int max_val, max_name_len;
  /* FIXME: Need to add smp support.  */
  SIM_DESC sd = CPU_STATE (cpu);
  PROFILE_DATA *data = CPU_PROFILE_DATA (cpu);
  char comma_buf[20];

  profile_printf (sd, cpu, "Memory Access Statistics\n\n");

  /* First pass over data computes various things.  */
  max_val = total_read = total_write = max_name_len = 0;
  for (i = 0; i < MODE_TARGET_MAX; ++i)
    {
      total_read += PROFILE_READ_COUNT (data) [i];
      total_write += PROFILE_WRITE_COUNT (data) [i];
      if (PROFILE_READ_COUNT (data) [i] > max_val)
	max_val = PROFILE_READ_COUNT (data) [i];
      if (PROFILE_WRITE_COUNT (data) [i] > max_val)
	max_val = PROFILE_WRITE_COUNT (data) [i];
      n = strlen (MODE_NAME (i));
      if (n > max_name_len)
	max_name_len = n;
    }

  /* One could use PROFILE_LABEL_WIDTH here.  I chose not to.  */
  profile_printf (sd, cpu, "  Total read:  %s accesses\n",
		  COMMAS (total_read));
  profile_printf (sd, cpu, "  Total write: %s accesses\n",
		  COMMAS (total_write));

  if (verbose && max_val != 0)
    {
      /* FIXME: Need to separate instruction fetches from data fetches
	 as the former swamps the latter.  */
      /* Now we can print the histogram.  */
      profile_printf (sd, cpu, "\n");
      for (i = 0; i < MODE_TARGET_MAX; ++i)
	{
	  if (PROFILE_READ_COUNT (data) [i] != 0)
	    {
	      profile_printf (sd, cpu, "   %*s read:  %*s: ",
			      max_name_len, MODE_NAME (i),
			      max_val < 10000 ? 5 : 10,
			      COMMAS (PROFILE_READ_COUNT (data) [i]));
	      sim_profile_print_bar (sd, cpu, PROFILE_HISTOGRAM_WIDTH,
				     PROFILE_READ_COUNT (data) [i],
				     max_val);
	      profile_printf (sd, cpu, "\n");
	    }
	  if (PROFILE_WRITE_COUNT (data) [i] != 0)
	    {
	      profile_printf (sd, cpu, "   %*s write: %*s: ",
			      max_name_len, MODE_NAME (i),
			      max_val < 10000 ? 5 : 10,
			      COMMAS (PROFILE_WRITE_COUNT (data) [i]));
	      sim_profile_print_bar (sd, cpu, PROFILE_HISTOGRAM_WIDTH,
				     PROFILE_WRITE_COUNT (data) [i],
				     max_val);
	      profile_printf (sd, cpu, "\n");
	    }
	}
    }

  profile_printf (sd, cpu, "\n");
}

#endif

#if WITH_PROFILE_CORE_P

static void
profile_print_core (sim_cpu *cpu, int verbose)
{
  unsigned int total;
  unsigned int max_val;
  /* FIXME: Need to add smp support.  */
  SIM_DESC sd = CPU_STATE (cpu);
  PROFILE_DATA *data = CPU_PROFILE_DATA (cpu);
  char comma_buf[20];

  profile_printf (sd, cpu, "CORE Statistics\n\n");

  /* First pass over data computes various things.  */
  {
    unsigned map;
    total = 0;
    max_val = 0;
    for (map = 0; map < nr_maps; map++)
      {
	total += PROFILE_CORE_COUNT (data) [map];
	if (PROFILE_CORE_COUNT (data) [map] > max_val)
	  max_val = PROFILE_CORE_COUNT (data) [map];
      }
  }

  /* One could use PROFILE_LABEL_WIDTH here.  I chose not to.  */
  profile_printf (sd, cpu, "  Total:  %s accesses\n",
		  COMMAS (total));

  if (verbose && max_val != 0)
    {
      unsigned map;
      /* Now we can print the histogram.  */
      profile_printf (sd, cpu, "\n");
      for (map = 0; map < nr_maps; map++)
	{
	  if (PROFILE_CORE_COUNT (data) [map] != 0)
	    {
	      profile_printf (sd, cpu, "%10s:", map_to_str (map));
	      profile_printf (sd, cpu, "%*s: ",
			      max_val < 10000 ? 5 : 10,
			      COMMAS (PROFILE_CORE_COUNT (data) [map]));
	      sim_profile_print_bar (sd, cpu, PROFILE_HISTOGRAM_WIDTH,
				     PROFILE_CORE_COUNT (data) [map],
				     max_val);
	      profile_printf (sd, cpu, "\n");
	    }
	}
    }

  profile_printf (sd, cpu, "\n");
}

#endif

#if WITH_PROFILE_MODEL_P

static void
profile_print_model (sim_cpu *cpu, int verbose)
{
  SIM_DESC sd = CPU_STATE (cpu);
  PROFILE_DATA *data = CPU_PROFILE_DATA (cpu);
  unsigned long cti_stall_cycles = PROFILE_MODEL_CTI_STALL_CYCLES (data);
  unsigned long load_stall_cycles = PROFILE_MODEL_LOAD_STALL_CYCLES (data);
  unsigned long total_cycles = PROFILE_MODEL_TOTAL_CYCLES (data);
  char comma_buf[20];

  profile_printf (sd, cpu, "Model %s Timing Information",
		  MODEL_NAME (CPU_MODEL (cpu)));
#ifdef SIM_HAVE_ADDR_RANGE
  if (PROFILE_RANGE (data)->ranges)
    profile_printf (sd, cpu, " (for selected address range(s))");
#endif
  profile_printf (sd, cpu, "\n\n");
  profile_printf (sd, cpu, "  %-*s %s\n",
		  PROFILE_LABEL_WIDTH, "Taken branches:",
		  COMMAS (PROFILE_MODEL_TAKEN_COUNT (data)));
  profile_printf (sd, cpu, "  %-*s %s\n",
		  PROFILE_LABEL_WIDTH, "Untaken branches:",
		  COMMAS (PROFILE_MODEL_UNTAKEN_COUNT (data)));
  profile_printf (sd, cpu, "  %-*s %s\n",
		  PROFILE_LABEL_WIDTH, "Cycles stalled due to branches:",
		  COMMAS (cti_stall_cycles));
  profile_printf (sd, cpu, "  %-*s %s\n",
		  PROFILE_LABEL_WIDTH, "Cycles stalled due to loads:",
		  COMMAS (load_stall_cycles));
  profile_printf (sd, cpu, "  %-*s %s\n",
		  PROFILE_LABEL_WIDTH, "Total cycles (*approximate*):",
		  COMMAS (total_cycles));
  profile_printf (sd, cpu, "\n");
}

#endif

void
sim_profile_print_bar (SIM_DESC sd, sim_cpu *cpu, unsigned int width,
		       unsigned int val, unsigned int max_val)
{
  unsigned int i, count;

  count = ((double) val / (double) max_val) * (double) width;

  for (i = 0; i < count; ++i)
    profile_printf (sd, cpu, "*");
}

/* Print the simulator's execution speed for CPU.  */

static void
profile_print_speed (sim_cpu *cpu)
{
  SIM_DESC sd = CPU_STATE (cpu);
  PROFILE_DATA *data = CPU_PROFILE_DATA (cpu);
  unsigned long milliseconds = sim_events_elapsed_time (sd);
  unsigned long total = PROFILE_TOTAL_INSN_COUNT (data);
  double clock;
  double secs;
  char comma_buf[20];

  profile_printf (sd, cpu, "Simulator Execution Speed\n\n");

  if (total != 0)
    profile_printf (sd, cpu, "  Total instructions:      %s\n", COMMAS (total));

  if (milliseconds < 1000)
    profile_printf (sd, cpu, "  Total execution time:    < 1 second\n\n");
  else
    {
      /* The printing of the time rounded to 2 decimal places makes the speed
	 calculation seem incorrect [even though it is correct].  So round
	 MILLISECONDS first. This can marginally affect the result, but it's
	 better that the user not perceive there's a math error.  */
      secs = (double) milliseconds / 1000;
      secs = ((double) (unsigned long) (secs * 100 + .5)) / 100;
      profile_printf (sd, cpu, "  Total execution time   : %.2f seconds\n", secs);
      /* Don't confuse things with data that isn't useful.
	 If we ran for less than 2 seconds, only use the data if we
	 executed more than 100,000 insns.  */
      if (secs >= 2 || total >= 100000)
	profile_printf (sd, cpu, "  Simulator speed:         %s insns/second\n",
			COMMAS ((unsigned long) ((double) total / secs)));
    }

  /* Print simulated execution time if the cpu frequency has been specified.  */
  clock = PROFILE_CPU_FREQ (data);
  if (clock != 0)
    {
      if (clock >= 1000000)
	profile_printf (sd, cpu, "  Simulated cpu frequency: %.2f MHz\n",
			clock / 1000000);
      else
	profile_printf (sd, cpu, "  Simulated cpu frequency: %.2f Hz\n", clock);

#if WITH_PROFILE_MODEL_P
      if (PROFILE_FLAGS (data) [PROFILE_MODEL_IDX])
	{
	  /* The printing of the time rounded to 2 decimal places makes the
	     speed calculation seem incorrect [even though it is correct].
	     So round 	 SECS first. This can marginally affect the result,
	     but it's 	 better that the user not perceive there's a math
	     error.  */
	  secs = PROFILE_MODEL_TOTAL_CYCLES (data) / clock;
	  secs = ((double) (unsigned long) (secs * 100 + .5)) / 100;
	  profile_printf (sd, cpu, "  Simulated execution time: %.2f seconds\n",
			  secs);
	}
#endif /* WITH_PROFILE_MODEL_P */
    }
}

#ifdef SIM_HAVE_ADDR_RANGE
/* Print selected address ranges.  */

static void
profile_print_addr_ranges (sim_cpu *cpu)
{
  ADDR_SUBRANGE *asr = PROFILE_RANGE (CPU_PROFILE_DATA (cpu))->ranges;
  SIM_DESC sd = CPU_STATE (cpu);

  if (asr)
    {
      profile_printf (sd, cpu, "Selected address ranges\n\n");
      while (asr != NULL)
	{
	  profile_printf (sd, cpu, "  0x%lx - 0x%lx\n",
			  (long) asr->start, (long) asr->end);
	  asr = asr->next;
	}
      profile_printf (sd, cpu, "\n");
    }
}
#endif

/* Top level function to print all summary profile information.
   It is [currently] intended that all such data is printed by this function.
   I'd rather keep it all in one place for now.  To that end, MISC_CPU and
   MISC are callbacks used to print any miscellaneous data.

   One might want to add a user option that allows printing by type or by cpu
   (i.e. print all insn data for each cpu first, or print data cpu by cpu).
   This may be a case of featuritis so it's currently left out.

   Note that results are indented two spaces to distinguish them from
   section titles.  */

static void
profile_info (SIM_DESC sd, int verbose)
{
  int i,c;
  int print_title_p = 0;

  /* Only print the title if some data has been collected.  */
  /* ??? Why don't we just exit if no data collected?  */
  /* FIXME: If the number of processors can be selected on the command line,
     then MAX_NR_PROCESSORS will need to take an argument of `sd'.  */

  for (c = 0; c < MAX_NR_PROCESSORS && !print_title_p; ++c)
    {
      sim_cpu *cpu = STATE_CPU (sd, c);
      PROFILE_DATA *data = CPU_PROFILE_DATA (cpu);

      for (i = 0; i < MAX_PROFILE_VALUES; ++i)
	if (PROFILE_FLAGS (data) [i])
	  {
	    profile_printf (sd, cpu, "Summary profiling results:\n\n");
	    print_title_p = 1;
	    break;
	  }
    }

  /* Loop, cpu by cpu, printing results.  */

  for (c = 0; c < MAX_NR_PROCESSORS; ++c)
    {
      sim_cpu *cpu = STATE_CPU (sd, c);
      PROFILE_DATA *data = CPU_PROFILE_DATA (cpu);

      if (MAX_NR_PROCESSORS > 1
	  && (0
#if WITH_PROFILE_INSN_P
	      || PROFILE_FLAGS (data) [PROFILE_INSN_IDX]
#endif
#if WITH_PROFILE_MEMORY_P
	      || PROFILE_FLAGS (data) [PROFILE_MEMORY_IDX]
#endif
#if WITH_PROFILE_CORE_P
	      || PROFILE_FLAGS (data) [PROFILE_CORE_IDX]
#endif
#if WITH_PROFILE_MODEL_P
	      || PROFILE_FLAGS (data) [PROFILE_MODEL_IDX]
#endif
#if WITH_PROFILE_SCACHE_P && WITH_SCACHE
	      || PROFILE_FLAGS (data) [PROFILE_SCACHE_IDX]
#endif
#if WITH_PROFILE_PC_P
	      || PROFILE_FLAGS (data) [PROFILE_PC_IDX]
#endif
	      ))
	{
	  profile_printf (sd, cpu, "CPU %d\n\n", c);
	}

#ifdef SIM_HAVE_ADDR_RANGE
      if (print_title_p
	  && (PROFILE_INSN_P (cpu)
	      || PROFILE_MODEL_P (cpu)))
	profile_print_addr_ranges (cpu);
#endif

#if WITH_PROFILE_INSN_P
      if (PROFILE_FLAGS (data) [PROFILE_INSN_IDX])
	profile_print_insn (cpu, verbose);
#endif

#if WITH_PROFILE_MEMORY_P
      if (PROFILE_FLAGS (data) [PROFILE_MEMORY_IDX])
	profile_print_memory (cpu, verbose);
#endif

#if WITH_PROFILE_CORE_P
      if (PROFILE_FLAGS (data) [PROFILE_CORE_IDX])
	profile_print_core (cpu, verbose);
#endif

#if WITH_PROFILE_MODEL_P
      if (PROFILE_FLAGS (data) [PROFILE_MODEL_IDX])
	profile_print_model (cpu, verbose);
#endif

#if WITH_PROFILE_SCACHE_P && WITH_SCACHE
      if (PROFILE_FLAGS (data) [PROFILE_SCACHE_IDX])
	scache_print_profile (cpu, verbose);
#endif

#if WITH_PROFILE_PC_P
      if (PROFILE_FLAGS (data) [PROFILE_PC_IDX])
	profile_print_pc (cpu, verbose);
#endif

      /* Print cpu-specific data before the execution speed.  */
      if (PROFILE_INFO_CPU_CALLBACK (data) != NULL)
	PROFILE_INFO_CPU_CALLBACK (data) (cpu, verbose);

      /* Always try to print execution time and speed.  */
      if (verbose
	  || PROFILE_FLAGS (data) [PROFILE_INSN_IDX])
	profile_print_speed (cpu);
    }

  /* Finally print non-cpu specific miscellaneous data.  */
  if (STATE_PROFILE_INFO_CALLBACK (sd))
    STATE_PROFILE_INFO_CALLBACK (sd) (sd, verbose);

}

/* Install profiling support in the simulator.  */

SIM_RC
profile_install (SIM_DESC sd)
{
  int i;

  SIM_ASSERT (STATE_MAGIC (sd) == SIM_MAGIC_NUMBER);
  sim_add_option_table (sd, NULL, profile_options);
  for (i = 0; i < MAX_NR_PROCESSORS; ++i)
    memset (CPU_PROFILE_DATA (STATE_CPU (sd, i)), 0,
	    sizeof (* CPU_PROFILE_DATA (STATE_CPU (sd, i))));
#if WITH_PROFILE_INSN_P
  sim_module_add_init_fn (sd, profile_insn_init);
#endif
#if WITH_PROFILE_PC_P
  sim_module_add_uninstall_fn (sd, profile_pc_uninstall);
  sim_module_add_init_fn (sd, profile_pc_init);
#endif
  sim_module_add_init_fn (sd, profile_init);
  sim_module_add_uninstall_fn (sd, profile_uninstall);
  sim_module_add_info_fn (sd, profile_info);
  return SIM_RC_OK;
}

static SIM_RC
profile_init (SIM_DESC sd)
{
#ifdef SIM_HAVE_ADDR_RANGE
  /* Check if a range has been specified without specifying what to
     collect.  */
  {
    int i;

    for (i = 0; i < MAX_NR_PROCESSORS; ++i)
      {
	sim_cpu *cpu = STATE_CPU (sd, i);

	if (ADDR_RANGE_RANGES (PROFILE_RANGE (CPU_PROFILE_DATA (cpu)))
	    && ! (PROFILE_INSN_P (cpu)
		  || PROFILE_MODEL_P (cpu)))
	  {
	    sim_io_eprintf_cpu (cpu, "Profiling address range specified without --profile-insn or --profile-model.\n");
	    sim_io_eprintf_cpu (cpu, "Address range ignored.\n");
	    sim_addr_range_delete (PROFILE_RANGE (CPU_PROFILE_DATA (cpu)),
				   0, ~ (address_word) 0);
	  }
      }
  }
#endif

  return SIM_RC_OK;
}

static void
profile_uninstall (SIM_DESC sd)
{
  int i,j;

  for (i = 0; i < MAX_NR_PROCESSORS; ++i)
    {
      sim_cpu *cpu = STATE_CPU (sd, i);
      PROFILE_DATA *data = CPU_PROFILE_DATA (cpu);

      if (PROFILE_FILE (data) != NULL)
	{
	  /* If output from different cpus is going to the same file,
	     avoid closing the file twice.  */
	  for (j = 0; j < i; ++j)
	    if (PROFILE_FILE (CPU_PROFILE_DATA (STATE_CPU (sd, j)))
		== PROFILE_FILE (data))
	      break;
	  if (i == j)
	    fclose (PROFILE_FILE (data));
	}

      if (PROFILE_INSN_COUNT (data) != NULL)
	free (PROFILE_INSN_COUNT (data));
    }
}
@


1.21
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 2
   Copyright (C) 1996-1998, 2000-2001, 2007-2012 Free Software
   Foundation, Inc.
@


1.20
log
@[sim]: Only print the profile info title once.

sim/common/ChangeLog:

        From John Wehle  <john@@feith.com>  (tiny patch)
	* sim-profile.c (profile_info): Only print the title once.
@
text
@d2 2
a3 2
   Copyright (C) 1996, 1997, 1998, 2000, 2001, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.20.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 2
   Copyright (C) 1996-1998, 2000-2001, 2007-2012 Free Software
   Foundation, Inc.
@


1.19
log
@sim: fix func call style (space before paren)

Committed this as obvious:
	-foo(...);
	+foo (...);

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d1135 1
a1135 1
  for (c = 0; c < MAX_NR_PROCESSORS; ++c)
d1145 1
@


1.18
log
@sim: common: trim trailing whitespace
@
text
@d743 1
a743 1
	fclose(pf);
@


1.17
log
@sim: punt zfree()

The sim keeps track of which allocations are zero-ed internally (via
zalloc) and then calls a helper "zfree" function rather than "free".
But this "zfree" function simply calls "free" itself.  Since I can
see no point in this and it is simply useless overhead, punt it.

The only real change is in hw-alloc.c where we remove the zalloc_p
tracking, and sim-utils.c where zfree is delete.  The rest of the
changes are a simple `sed` from "zfree" to "free".

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d193 1
a193 1
    }  
d417 1
a417 1
	    }	      
d538 1
a538 1
  PROFILE_PC_EVENT (profile) = 
d701 1
a701 1
    
@


1.16
log
@run copyright.sh for 2011.
@
text
@d503 1
a503 1
	zfree (PROFILE_PC_COUNT (data));
d1310 1
a1310 1
	zfree (PROFILE_INSN_COUNT (data));
@


1.15
log
@sim: profile: fix building with --disable-sim-profile

When the sim is configured with profile support disabled, the build fails:
./../common/sim-profile.c: In function 'profile_option_handler':
./../common/sim-profile.c:337:6: warning: implicit declaration of function 'PROFILE_PC_FREQ'
./../common/sim-profile.c:337:6: error: lvalue required as left operand of assignment
./../common/sim-profile.c:351:6: warning: implicit declaration of function 'PROFILE_PC_NR_BUCKETS'
./../common/sim-profile.c:351:6: error: lvalue required as left operand of assignment
./../common/sim-profile.c:381:6: warning: implicit declaration of function 'PROFILE_PC_SHIFT'
./../common/sim-profile.c:381:6: error: lvalue required as left operand of assignment
./../common/sim-profile.c:405:8: warning: implicit declaration of function 'PROFILE_PC_START'
./../common/sim-profile.c:405:8: error: lvalue required as left operand of assignment
./../common/sim-profile.c:406:8: warning: implicit declaration of function 'PROFILE_PC_END'
./../common/sim-profile.c:406:8: error: lvalue required as left operand of assignment
./../common/sim-profile.c: In function 'profile_uninstall':
./../common/sim-profile.c:1299:7: warning: implicit declaration of function 'PROFILE_INSN_COUNT'
./../common/sim-profile.c:1299:37: warning: comparison between pointer and integer
./../common/sim-profile.c:1300:2: warning: passing argument 1 of 'zfree' makes pointer from integer without a cast
../common/sim-utils.h:30:6: note: expected 'void *' but argument is of type 'int'
make[2]: *** [sim-profile.o] Error 1

So add some stubs similar to how some of the other subsystems are
stubbed out so things build correctly.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 2000, 2001, 2007, 2008, 2009, 2010
@


1.14
log
@sim: profile: implement --profile-file backend

The profile code already has options and handling for accepting a file to
write the profile output like the trace code, but it doesn't actually use
it.  At the moment, it simply opens the file at the start and closes it at
the end.  So add two new local functions the way the trace code is doing
it and have them figure out whether to write the output to stdout or the
specified file.  Then convert all existing output in the profile code to
use these helpers.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d39 10
@


1.13
log
@sim: add missing values to array initializers

The sim code has a lot of static initializer for options and devices, but
since they aren't using newer struct style, they have to specify a value
for every option otherwise gcc spits a lot of warnings about "missing
initializer".  So add NULL/0 stubs for pointers/values.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d455 25
d628 1
a628 1
  sim_io_printf (sd, "Program Counter Statistics:\n\n");
d640 8
a647 8
  sim_io_printf (sd, "  Total samples: %s\n",
		 COMMAS (total));
  sim_io_printf (sd, "  Granularity: %s bytes per bucket\n",
		 COMMAS (PROFILE_PC_BUCKET_SIZE (profile)));
  sim_io_printf (sd, "  Size: %s buckets\n",
		 COMMAS (PROFILE_PC_NR_BUCKETS (profile)));
  sim_io_printf (sd, "  Frequency: %s cycles per sample\n",
		 COMMAS (PROFILE_PC_FREQ (profile)));
d650 2
a651 2
    sim_io_printf (sd, "  Range: 0x%lx 0x%lx\n",
		   (long) PROFILE_PC_START (profile),
d657 1
a657 1
      sim_io_printf (sd, "\n");
d662 1
a662 1
	      sim_io_printf (sd, "  ");
d664 1
a664 1
		sim_io_printf (sd, "%10s:", "overflow");
d666 10
a675 10
		sim_io_printf (sd, "0x%08lx:",
			       (long) (PROFILE_PC_START (profile)
				       + (i * PROFILE_PC_BUCKET_SIZE (profile))));
	      sim_io_printf (sd, " %*s",
			     max_val < 10000 ? 5 : 10,
			     COMMAS (PROFILE_PC_COUNT (profile) [i]));
	      sim_io_printf (sd, " %4.1f",
			     (PROFILE_PC_COUNT (profile) [i] * 100.0) / total);
	      sim_io_printf (sd, ": ");
	      sim_profile_print_bar (sd, PROFILE_HISTOGRAM_WIDTH,
d678 1
a678 1
	      sim_io_printf (sd, "\n");
d737 1
a737 1
  sim_io_printf (sd, "\n");
d774 1
a774 1
  sim_io_printf (sd, "Instruction Statistics");
d777 1
a777 1
    sim_io_printf (sd, " (for selected address range(s))");
d779 1
a779 1
  sim_io_printf (sd, "\n\n");
d802 1
a802 1
  sim_io_printf (sd, "  Total: %s insns\n", COMMAS (total));
d807 1
a807 1
      sim_io_printf (sd, "\n");
d816 5
a820 5
	      sim_io_printf (sd, "   %*s: %*s: ",
			     max_name_len, name,
			     max_val < 10000 ? 5 : 10,
			     COMMAS (PROFILE_INSN_COUNT (data) [i]));
	      sim_profile_print_bar (sd, PROFILE_HISTOGRAM_WIDTH,
d823 1
a823 1
	      sim_io_printf (sd, "\n");
d828 1
a828 1
  sim_io_printf (sd, "\n");
d846 1
a846 1
  sim_io_printf (sd, "Memory Access Statistics\n\n");
d864 4
a867 4
  sim_io_printf (sd, "  Total read:  %s accesses\n",
		 COMMAS (total_read));
  sim_io_printf (sd, "  Total write: %s accesses\n",
		 COMMAS (total_write));
d874 1
a874 1
      sim_io_printf (sd, "\n");
d879 5
a883 5
	      sim_io_printf (sd, "   %*s read:  %*s: ",
			     max_name_len, MODE_NAME (i),
			     max_val < 10000 ? 5 : 10,
			     COMMAS (PROFILE_READ_COUNT (data) [i]));
	      sim_profile_print_bar (sd, PROFILE_HISTOGRAM_WIDTH,
d886 1
a886 1
	      sim_io_printf (sd, "\n");
d890 5
a894 5
	      sim_io_printf (sd, "   %*s write: %*s: ",
			     max_name_len, MODE_NAME (i),
			     max_val < 10000 ? 5 : 10,
			     COMMAS (PROFILE_WRITE_COUNT (data) [i]));
	      sim_profile_print_bar (sd, PROFILE_HISTOGRAM_WIDTH,
d897 1
a897 1
	      sim_io_printf (sd, "\n");
d902 1
a902 1
  sim_io_printf (sd, "\n");
d919 1
a919 1
  sim_io_printf (sd, "CORE Statistics\n\n");
d935 2
a936 2
  sim_io_printf (sd, "  Total:  %s accesses\n",
		 COMMAS (total));
d942 1
a942 1
      sim_io_printf (sd, "\n");
d947 5
a951 5
	      sim_io_printf (sd, "%10s:", map_to_str (map));
	      sim_io_printf (sd, "%*s: ",
			     max_val < 10000 ? 5 : 10,
			     COMMAS (PROFILE_CORE_COUNT (data) [map]));
	      sim_profile_print_bar (sd, PROFILE_HISTOGRAM_WIDTH,
d954 1
a954 1
	      sim_io_printf (sd, "\n");
d959 1
a959 1
  sim_io_printf (sd, "\n");
d976 2
a977 2
  sim_io_printf (sd, "Model %s Timing Information",
		 MODEL_NAME (CPU_MODEL (cpu)));
d980 1
a980 1
    sim_io_printf (sd, " (for selected address range(s))");
d982 17
a998 17
  sim_io_printf (sd, "\n\n");
  sim_io_printf (sd, "  %-*s %s\n",
		 PROFILE_LABEL_WIDTH, "Taken branches:",
		 COMMAS (PROFILE_MODEL_TAKEN_COUNT (data)));
  sim_io_printf (sd, "  %-*s %s\n",
		 PROFILE_LABEL_WIDTH, "Untaken branches:",
		 COMMAS (PROFILE_MODEL_UNTAKEN_COUNT (data)));
  sim_io_printf (sd, "  %-*s %s\n",
		 PROFILE_LABEL_WIDTH, "Cycles stalled due to branches:",
		 COMMAS (cti_stall_cycles));
  sim_io_printf (sd, "  %-*s %s\n",
		 PROFILE_LABEL_WIDTH, "Cycles stalled due to loads:",
		 COMMAS (load_stall_cycles));
  sim_io_printf (sd, "  %-*s %s\n",
		 PROFILE_LABEL_WIDTH, "Total cycles (*approximate*):",
		 COMMAS (total_cycles));
  sim_io_printf (sd, "\n");
d1004 1
a1004 1
sim_profile_print_bar (SIM_DESC sd, unsigned int width,
d1012 1
a1012 1
    sim_io_printf (sd, "*");
d1028 1
a1028 1
  sim_io_printf (sd, "Simulator Execution Speed\n\n");
d1031 1
a1031 1
    sim_io_printf (sd, "  Total instructions:      %s\n", COMMAS (total));
d1034 1
a1034 1
    sim_io_printf (sd, "  Total execution time:    < 1 second\n\n");
d1043 1
a1043 1
      sim_io_printf (sd, "  Total execution time   : %.2f seconds\n", secs);
d1048 2
a1049 2
	sim_io_printf (sd, "  Simulator speed:         %s insns/second\n",
		       COMMAS ((unsigned long) ((double) total / secs)));
d1057 2
a1058 2
	sim_io_printf (sd, "  Simulated cpu frequency: %.2f MHz\n",
		       clock / 1000000);
d1060 1
a1060 1
	sim_io_printf (sd, "  Simulated cpu frequency: %.2f Hz\n", clock);
d1072 2
a1073 2
	  sim_io_printf (sd, "  Simulated execution time: %.2f seconds\n",
			 secs);
d1090 1
a1090 1
      sim_io_printf (sd, "Selected address ranges\n\n");
d1093 2
a1094 2
	  sim_io_printf (sd, "  0x%lx - 0x%lx\n",
			 (long) asr->start, (long) asr->end);
d1097 1
a1097 1
      sim_io_printf (sd, "\n");
d1132 4
a1135 2
	  print_title_p = 1;
      /* One could break out early if print_title_p is set.  */
a1136 2
  if (print_title_p)
    sim_io_printf (sd, "Summary profiling results:\n\n");
d1167 1
a1167 1
	  sim_io_printf (sd, "CPU %d\n\n", c);
@


1.12
log
@sim: fix unused profile_print_addr_ranges warning

The profile_print_addr_ranges() function is only used when
SIM_HAVE_ADDR_RANGE is defined, so #ifdef it accordingly.
@
text
@d63 1
a63 1
      profile_option_handler },
d66 1
a66 1
      profile_option_handler },
d69 1
a69 1
      profile_option_handler },
d72 1
a72 1
      profile_option_handler },
d75 1
a75 1
      profile_option_handler },
d79 1
a79 1
      profile_option_handler },
d83 1
a83 1
      profile_option_handler },
d87 1
a87 1
      profile_option_handler },
d90 1
a90 1
      profile_option_handler },
d93 1
a93 1
      profile_option_handler },
d96 1
a96 1
      profile_option_handler },
d99 1
a99 1
      profile_option_handler },
d104 1
a104 1
      profile_option_handler },
d108 1
a108 1
      profile_option_handler },
d112 1
a112 1
  { {NULL, no_argument, NULL, 0}, '\0', NULL, NULL, NULL }
@


1.11
log
@Update copyright notices to add year 2010.
@
text
@d1054 1
d1075 1
@


1.10
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 2000, 2001, 2007, 2008, 2009
@


1.9
log
@	Updated copyright notices for most files.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 2000, 2001, 2007, 2008
@


1.8
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 2000, 2001, 2007
@


1.7
log
@Copyright updates for 2007.
@
text
@d10 2
a11 2
the Free Software Foundation; either version 2, or (at your option)
any later version.
d18 2
a19 3
You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.6
log
@	* sim-profile.c (profile_pc_init): Initialise default profiling
	frequency to a prime number.
	(profile_print_pc): Convert gmon.out sample data into target
	byte order.
@
text
@d2 2
a3 1
   Copyright (C) 1996, 1997, 1998, 2000, 2001 Free Software Foundation, Inc.
@


1.5
log
@* profiling bug fixes.

2001-02-09  Ben Elliston  <bje@@redhat.com>

	* (profile_print_pc): Write header out in target byte order.

2001-02-09  Ben Elliston  <bje@@redhat.com>

	* sim-profile.c (profile_pc_init): Correct bug in loop logic when
	adjusting the pc shift value.
@
text
@d522 1
a522 1
	    PROFILE_PC_FREQ (data) = 256;
d703 1
@


1.4
log
@2000-12-03  Ben Elliston  <bje@@redhat.com>

	* sim-profile.c (profile_option_handler): Remove unused prof_nr.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
d567 1
a567 1
	      while (bucket_size < PROFILE_PC_BUCKET_SIZE (data))
d687 6
@


1.3
log
@2000-08-15  Dave Brolley  <brolley@@redhat.com>

	* sim-profile.c (profile_print_speed): Print cpu frequency if not zero.
@
text
@d251 1
a251 1
  int cpu_nr,prof_nr;
@


1.2
log
@2000-08-15  Dave Brolley  <brolley@@redhat.com>

	* sim-profile.h (PROFILE_DATA): Add cpu_freq.
	(PROFILE_CPU_FREQ): New macro.
	* sim-profile.c (OPTION_PROFILE_CPU_FREQUENCY): New enumerator.
	(profile-options): Add profile-cpu-frequency.
	(parse_frequency): New function.
	(profile_option_handler): Handle OPTION_PROFILE_CPU_FREQUENCY.
	(profile_print_speed): Print cpu frequency and simulated execution time.
	Re-indent other items to match.
@
text
@a1019 1
#if WITH_PROFILE_MODEL_P
d1030 1
d1043 1
a1044 1
#endif /* WITH_PROFILE_MODEL_P */
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
d37 1
d52 1
d76 4
d117 1
a117 1
static SIM_RC
d198 47
d293 12
d992 2
d999 1
a999 1
    sim_io_printf (sd, "  Total instructions:   %s\n", COMMAS (total));
d1002 1
a1002 1
    sim_io_printf (sd, "  Total execution time: < 1 second\n\n");
d1009 1
a1009 1
      double secs = (double) milliseconds / 1000;
d1011 1
a1011 1
      sim_io_printf (sd, "  Total execution time: %.2f seconds\n", secs);
d1016 1
a1016 1
	sim_io_printf (sd, "  Simulator speed:      %s insns/second\n\n",
d1019 26
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-12-21 snapshot
@
text
@d111 1
a111 1
SIM_RC
@


