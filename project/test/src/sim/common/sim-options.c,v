head	1.31;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.29
	gdb_7_6-2013-04-26-release:1.29
	gdb_7_6-branch:1.29.0.2
	gdb_7_6-2013-03-12-branchpoint:1.29
	gdb_7_5_1-2012-11-29-release:1.28
	gdb_7_5-2012-08-17-release:1.28
	gdb_7_5-branch:1.28.0.2
	gdb_7_5-2012-07-18-branchpoint:1.28
	gdb_7_4_1-2012-04-26-release:1.27.2.1
	gdb_7_4-2012-01-24-release:1.27.2.1
	gdb_7_4-branch:1.27.0.2
	gdb_7_4-2011-12-13-branchpoint:1.27
	gdb_7_3_1-2011-09-04-release:1.23
	gdb_7_3-2011-07-26-release:1.23
	gdb_7_3-branch:1.23.0.2
	gdb_7_3-2011-04-01-branchpoint:1.23
	gdb_7_2-2010-09-02-release:1.19
	gdb_7_2-branch:1.19.0.2
	gdb_7_2-2010-07-07-branchpoint:1.19
	gdb_7_1-2010-03-18-release:1.14
	gdb_7_1-branch:1.14.0.2
	gdb_7_1-2010-02-18-branchpoint:1.14
	gdb_7_0_1-2009-12-22-release:1.13
	gdb_7_0-2009-10-06-release:1.13
	gdb_7_0-branch:1.13.0.4
	gdb_7_0-2009-09-16-branchpoint:1.13
	arc-sim-20090309:1.12
	msnyder-checkpoint-072509-branch:1.13.0.2
	msnyder-checkpoint-072509-branchpoint:1.13
	arc-insight_6_8-branch:1.12.0.16
	arc-insight_6_8-branchpoint:1.12
	insight_6_8-branch:1.12.0.14
	insight_6_8-branchpoint:1.12
	reverse-20081226-branch:1.12.0.12
	reverse-20081226-branchpoint:1.12
	multiprocess-20081120-branch:1.12.0.10
	multiprocess-20081120-branchpoint:1.12
	reverse-20080930-branch:1.12.0.8
	reverse-20080930-branchpoint:1.12
	reverse-20080717-branch:1.12.0.6
	reverse-20080717-branchpoint:1.12
	msnyder-reverse-20080609-branch:1.12.0.4
	msnyder-reverse-20080609-branchpoint:1.12
	drow-reverse-20070409-branch:1.9.0.2
	drow-reverse-20070409-branchpoint:1.9
	gdb_6_8-2008-03-27-release:1.12
	gdb_6_8-branch:1.12.0.2
	gdb_6_8-2008-02-26-branchpoint:1.12
	gdb_6_7_1-2007-10-29-release:1.11
	gdb_6_7-2007-10-10-release:1.11
	gdb_6_7-branch:1.11.0.2
	gdb_6_7-2007-09-07-branchpoint:1.11
	insight_6_6-20070208-release:1.8
	gdb_6_6-2006-12-18-release:1.8
	gdb_6_6-branch:1.8.0.30
	gdb_6_6-2006-11-15-branchpoint:1.8
	insight_6_5-20061003-release:1.8
	gdb-csl-symbian-6_4_50_20060226-12:1.8
	gdb-csl-sourcerygxx-3_4_4-25:1.8
	nickrob-async-20060828-mergepoint:1.8
	gdb-csl-symbian-6_4_50_20060226-11:1.8
	gdb-csl-sourcerygxx-4_1-17:1.8
	gdb-csl-20060226-branch-local-2:1.8
	gdb-csl-sourcerygxx-4_1-14:1.8
	gdb-csl-sourcerygxx-4_1-13:1.8
	gdb-csl-sourcerygxx-4_1-12:1.8
	gdb-csl-sourcerygxx-3_4_4-21:1.8
	gdb_6_5-20060621-release:1.8
	gdb-csl-sourcerygxx-4_1-9:1.8
	gdb-csl-sourcerygxx-4_1-8:1.8
	gdb-csl-sourcerygxx-4_1-7:1.8
	gdb-csl-arm-2006q1-6:1.8
	gdb-csl-sourcerygxx-4_1-6:1.8
	gdb-csl-symbian-6_4_50_20060226-10:1.8
	gdb-csl-symbian-6_4_50_20060226-9:1.8
	gdb-csl-symbian-6_4_50_20060226-8:1.8
	gdb-csl-coldfire-4_1-11:1.8
	gdb-csl-sourcerygxx-3_4_4-19:1.8
	gdb-csl-coldfire-4_1-10:1.8
	gdb_6_5-branch:1.8.0.28
	gdb_6_5-2006-05-14-branchpoint:1.8
	gdb-csl-sourcerygxx-4_1-5:1.8
	nickrob-async-20060513-branch:1.8.0.26
	nickrob-async-20060513-branchpoint:1.8
	gdb-csl-sourcerygxx-4_1-4:1.8
	msnyder-reverse-20060502-branch:1.8.0.24
	msnyder-reverse-20060502-branchpoint:1.8
	gdb-csl-morpho-4_1-4:1.8
	gdb-csl-sourcerygxx-3_4_4-17:1.8
	readline_5_1-import-branch:1.8.0.22
	readline_5_1-import-branchpoint:1.8
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.8
	gdb-csl-symbian-20060226-branch:1.8.0.20
	gdb-csl-symbian-20060226-branchpoint:1.8
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.8
	msnyder-reverse-20060331-branch:1.8.0.18
	msnyder-reverse-20060331-branchpoint:1.8
	gdb-csl-available-20060303-branch:1.8.0.16
	gdb-csl-available-20060303-branchpoint:1.8
	gdb-csl-20060226-branch:1.8.0.14
	gdb-csl-20060226-branchpoint:1.8
	gdb_6_4-20051202-release:1.8
	msnyder-fork-checkpoint-branch:1.8.0.12
	msnyder-fork-checkpoint-branchpoint:1.8
	gdb-csl-gxxpro-6_3-branch:1.8.0.10
	gdb-csl-gxxpro-6_3-branchpoint:1.8
	gdb_6_4-branch:1.8.0.8
	gdb_6_4-2005-11-01-branchpoint:1.8
	gdb-csl-arm-20051020-branch:1.8.0.6
	gdb-csl-arm-20051020-branchpoint:1.8
	msnyder-tracepoint-checkpoint-branch:1.8.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.8
	gdb-csl-arm-20050325-2005-q1b:1.8
	gdb-csl-arm-20050325-2005-q1a:1.8
	csl-arm-20050325-branch:1.8.0.2
	csl-arm-20050325-branchpoint:1.8
	gdb_6_3-20041109-release:1.7
	gdb_6_3-branch:1.7.0.2
	gdb_6_3-20041019-branchpoint:1.7
	drow_intercu-merge-20040921:1.7
	drow_intercu-merge-20040915:1.7
	jimb-gdb_6_2-e500-branch:1.6.0.18
	jimb-gdb_6_2-e500-branchpoint:1.6
	gdb_6_2-20040730-release:1.6
	gdb_6_2-branch:1.6.0.14
	gdb_6_2-2004-07-10-gmt-branchpoint:1.6
	gdb_6_1_1-20040616-release:1.6
	gdb_6_1-2004-04-05-release:1.6
	drow_intercu-merge-20040402:1.6
	drow_intercu-merge-20040327:1.6
	ezannoni_pie-20040323-branch:1.6.0.12
	ezannoni_pie-20040323-branchpoint:1.6
	cagney_tramp-20040321-mergepoint:1.6
	cagney_tramp-20040309-branch:1.6.0.10
	cagney_tramp-20040309-branchpoint:1.6
	gdb_6_1-branch:1.6.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	drow_intercu-20040221-branch:1.6.0.6
	drow_intercu-20040221-branchpoint:1.6
	cagney_bfdfile-20040213-branch:1.6.0.4
	cagney_bfdfile-20040213-branchpoint:1.6
	drow-cplus-merge-20040208:1.6
	carlton_dictionary-20040126-merge:1.6
	cagney_bigcore-20040122-branch:1.6.0.2
	cagney_bigcore-20040122-branchpoint:1.6
	drow-cplus-merge-20040113:1.6
	drow-cplus-merge-20031224:1.6
	drow-cplus-merge-20031220:1.6
	carlton_dictionary-20031215-merge:1.6
	drow-cplus-merge-20031214:1.6
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.4
	kettenis_sparc-20030918-branch:1.5.0.4
	kettenis_sparc-20030918-branchpoint:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.2
	cagney_x86i386-20030821-branch:1.4.0.8
	cagney_x86i386-20030821-branchpoint:1.4
	carlton_dictionary-20030805-merge:1.4
	carlton_dictionary-20030627-merge:1.4
	gdb_6_0-branch:1.4.0.6
	gdb_6_0-2003-06-23-branchpoint:1.4
	jimb-ppc64-linux-20030613-branch:1.4.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.4
	cagney_convert-20030606-branch:1.4.0.2
	cagney_convert-20030606-branchpoint:1.4
	cagney_writestrings-20030508-branch:1.3.0.40
	cagney_writestrings-20030508-branchpoint:1.3
	jimb-ppc64-linux-20030528-branch:1.3.0.38
	jimb-ppc64-linux-20030528-branchpoint:1.3
	carlton_dictionary-20030523-merge:1.3
	cagney_fileio-20030521-branch:1.3.0.36
	cagney_fileio-20030521-branchpoint:1.3
	kettenis_i386newframe-20030517-mergepoint:1.3
	jimb-ppc64-linux-20030509-branch:1.3.0.34
	jimb-ppc64-linux-20030509-branchpoint:1.3
	kettenis_i386newframe-20030504-mergepoint:1.3
	carlton_dictionary-20030430-merge:1.3
	kettenis_i386newframe-20030419-branch:1.3.0.32
	kettenis_i386newframe-20030419-branchpoint:1.3
	carlton_dictionary-20030416-merge:1.3
	cagney_frameaddr-20030409-mergepoint:1.3
	kettenis_i386newframe-20030406-branch:1.3.0.30
	kettenis_i386newframe-20030406-branchpoint:1.3
	cagney_frameaddr-20030403-branchpoint:1.3
	cagney_frameaddr-20030403-branch:1.3.0.28
	cagney_framebase-20030330-mergepoint:1.3
	cagney_framebase-20030326-branch:1.3.0.26
	cagney_framebase-20030326-branchpoint:1.3
	cagney_lazyid-20030317-branch:1.3.0.24
	cagney_lazyid-20030317-branchpoint:1.3
	kettenis-i386newframe-20030316-mergepoint:1.3
	offbyone-20030313-branch:1.3.0.22
	offbyone-20030313-branchpoint:1.3
	kettenis-i386newframe-20030308-branch:1.3.0.20
	kettenis-i386newframe-20030308-branchpoint:1.3
	carlton_dictionary-20030305-merge:1.3
	cagney_offbyone-20030303-branch:1.3.0.18
	cagney_offbyone-20030303-branchpoint:1.3
	carlton_dictionary-20030207-merge:1.3
	interps-20030202-branch:1.3.0.16
	interps-20030202-branchpoint:1.3
	cagney-unwind-20030108-branch:1.3.0.14
	cagney-unwind-20030108-branchpoint:1.3
	carlton_dictionary-20021223-merge:1.3
	gdb_5_3-2002-12-12-release:1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.12
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	carlton_dictionary-branch:1.3.0.10
	carlton_dictionary-20020920-branchpoint:1.3
	gdb_5_3-branch:1.3.0.8
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.6
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.4
	readline_4_3-import-branchpoint:1.3
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.3.0.2
	kseitz_interps-20020528-branchpoint:1.3
	cagney_regbuf-20020515-branch:1.2.0.12
	cagney_regbuf-20020515-branchpoint:1.2
	jimb-macro-020506-branch:1.2.0.10
	jimb-macro-020506-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.8
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.2
	gdb_5_1_0_1-2002-01-03-release:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.4
	gdb_s390-2001-09-26-branchpoint:1.2
	gdb_5_1-2001-07-29-branch:1.2.0.2
	gdb_5_1-2001-07-29-branchpoint:1.2
	insight-precleanup-2001-01-01:1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.3.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.3
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.31
date	2013.09.03.20.45.08;	author vapier;	state Exp;
branches;
next	1.30;

1.30
date	2013.03.15.17.53.42;	author sje;	state Exp;
branches;
next	1.29;

1.29
date	2013.01.01.06.41.33;	author brobecke;	state Exp;
branches;
next	1.28;

1.28
date	2012.01.04.08.28.06;	author brobecke;	state Exp;
branches;
next	1.27;

1.27
date	2011.05.27.18.05.16;	author vapier;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2011.05.11.20.02.42;	author vapier;	state Exp;
branches;
next	1.25;

1.25
date	2011.04.15.16.23.19;	author vapier;	state Exp;
branches;
next	1.24;

1.24
date	2011.04.15.03.43.46;	author vapier;	state Exp;
branches;
next	1.23;

1.23
date	2011.03.15.03.16.17;	author vapier;	state Exp;
branches;
next	1.22;

1.22
date	2011.02.14.05.14.26;	author vapier;	state Exp;
branches;
next	1.21;

1.21
date	2011.01.12.21.58.08;	author vapier;	state Exp;
branches;
next	1.20;

1.20
date	2011.01.01.15.33.56;	author brobecke;	state Exp;
branches;
next	1.19;

1.19
date	2010.04.12.16.53.33;	author vapier;	state Exp;
branches;
next	1.18;

1.18
date	2010.04.12.16.00.44;	author vapier;	state Exp;
branches;
next	1.17;

1.17
date	2010.04.10.07.35.35;	author vapier;	state Exp;
branches;
next	1.16;

1.16
date	2010.03.30.19.43.42;	author vapier;	state Exp;
branches;
next	1.15;

1.15
date	2010.03.22.23.10.39;	author vapier;	state Exp;
branches;
next	1.14;

1.14
date	2010.01.01.10.03.27;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.14.10.53.06;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2008.01.01.22.53.23;	author drow;	state Exp;
branches;
next	1.11;

1.11
date	2007.08.24.14.28.35;	author brobecke;	state Exp;
branches;
next	1.10;

1.10
date	2007.08.10.14.26.33;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.09.17.59.16;	author drow;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.08.00.40.30;	author hp;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.10.00.40.25;	author bje;	state Exp;
branches;
next	1.6;

1.6
date	2003.11.22.21.37.49;	author kazu;	state Exp;
branches
	1.6.6.1;
next	1.5;

1.5
date	2003.08.28.17.02.00;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.05.02.17.29;	author msnyder;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.17.19.09.12;	author avolkov;	state Exp;
branches
	1.3.10.1
	1.3.12.1;
next	1.2;

1.2
date	2000.11.25.09.16.22;	author ciceron;	state Exp;
branches
	1.2.12.1;
next	1.1;

1.1
date	99.04.16.01.34.58;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.27.2.1
date	2012.01.06.04.54.40;	author brobecke;	state Exp;
branches;
next	;

1.6.6.1
date	2004.09.16.17.02.03;	author drow;	state Exp;
branches;
next	;

1.3.10.1
date	2003.06.27.21.50.32;	author carlton;	state Exp;
branches;
next	1.3.10.2;

1.3.10.2
date	2003.09.17.21.29.01;	author carlton;	state Exp;
branches;
next	1.3.10.3;

1.3.10.3
date	2003.12.16.00.01.21;	author carlton;	state Exp;
branches;
next	;

1.3.12.1
date	2003.12.14.20.28.19;	author drow;	state Exp;
branches;
next	;

1.2.12.1
date	2002.06.15.16.43.22;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.58;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.12.11.14.07;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.12.14.01.06.04;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.31
log
@sim: mark complete_option_list args const to fix build warnings

The completion API was updated, but this func missed having its
text/word args const.
@
text
@/* Simulator option handling.
   Copyright (C) 1996-2013 Free Software Foundation, Inc.
   Contributed by Cygnus Support.

This file is part of GDB, the GNU debugger.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "sim-main.h"
#ifdef HAVE_STRING_H
#include <string.h>
#else
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif
#endif
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#include <ctype.h>
#include "libiberty.h"
#include "sim-options.h"
#include "sim-io.h"
#include "sim-assert.h"

#include "bfd.h"

/* Add a set of options to the simulator.
   TABLE is an array of OPTIONS terminated by a NULL `opt.name' entry.
   This is intended to be called by modules in their `install' handler.  */

SIM_RC
sim_add_option_table (SIM_DESC sd, sim_cpu *cpu, const OPTION *table)
{
  struct option_list *ol = ((struct option_list *)
			    xmalloc (sizeof (struct option_list)));

  /* Note: The list is constructed in the reverse order we're called so
     later calls will override earlier ones (in case that ever happens).
     This is the intended behaviour.  */

  if (cpu)
    {
      ol->next = CPU_OPTIONS (cpu);
      ol->options = table;
      CPU_OPTIONS (cpu) = ol;
    }
  else
    {
      ol->next = STATE_OPTIONS (sd);
      ol->options = table;
      STATE_OPTIONS (sd) = ol;
    }

  return SIM_RC_OK;
}

/* Standard option table.
   Modules may specify additional ones.
   The caller of sim_parse_args may also specify additional options
   by calling sim_add_option_table first.  */

static DECLARE_OPTION_HANDLER (standard_option_handler);

/* FIXME: We shouldn't print in --help output options that aren't usable.
   Some fine tuning will be necessary.  One can either move less general
   options to another table or use a HAVE_FOO macro to ifdef out unavailable
   options.  */

/* ??? One might want to conditionally compile out the entries that
   aren't enabled.  There's a distinction, however, between options a
   simulator can't support and options that haven't been configured in.
   Certainly options a simulator can't support shouldn't appear in the
   output of --help.  Whether the same thing applies to options that haven't
   been configured in or not isn't something I can get worked up over.
   [Note that conditionally compiling them out might simply involve moving
   the option to another table.]
   If you decide to conditionally compile them out as well, delete this
   comment and add a comment saying that that is the rule.  */

typedef enum {
  OPTION_DEBUG_INSN = OPTION_START,
  OPTION_DEBUG_FILE,
  OPTION_DO_COMMAND,
  OPTION_ARCHITECTURE,
  OPTION_TARGET,
  OPTION_ARCHITECTURE_INFO,
  OPTION_ENVIRONMENT,
  OPTION_ALIGNMENT,
  OPTION_VERBOSE,
  OPTION_ENDIAN,
  OPTION_DEBUG,
#ifdef SIM_HAVE_FLATMEM
  OPTION_MEM_SIZE,
#endif
  OPTION_HELP,
#ifdef SIM_H8300 /* FIXME: Should be movable to h8300 dir.  */
  OPTION_H8300H,
  OPTION_H8300S,
  OPTION_H8300SX,
#endif
  OPTION_LOAD_LMA,
  OPTION_LOAD_VMA,
  OPTION_SYSROOT
} STANDARD_OPTIONS;

static const OPTION standard_options[] =
{
  { {"verbose", no_argument, NULL, OPTION_VERBOSE},
      'v', NULL, "Verbose output",
      standard_option_handler, NULL },

  { {"endian", required_argument, NULL, OPTION_ENDIAN},
      'E', "big|little", "Set endianness",
      standard_option_handler, NULL },

#ifdef SIM_HAVE_ENVIRONMENT
  /* This option isn't supported unless all choices are supported in keeping
     with the goal of not printing in --help output things the simulator can't
     do [as opposed to things that just haven't been configured in].  */
  { {"environment", required_argument, NULL, OPTION_ENVIRONMENT},
      '\0', "user|virtual|operating", "Set running environment",
      standard_option_handler },
#endif

  { {"alignment", required_argument, NULL, OPTION_ALIGNMENT},
      '\0', "strict|nonstrict|forced", "Set memory access alignment",
      standard_option_handler },

  { {"debug", no_argument, NULL, OPTION_DEBUG},
      'D', NULL, "Print debugging messages",
      standard_option_handler },
  { {"debug-insn", no_argument, NULL, OPTION_DEBUG_INSN},
      '\0', NULL, "Print instruction debugging messages",
      standard_option_handler },
  { {"debug-file", required_argument, NULL, OPTION_DEBUG_FILE},
      '\0', "FILE NAME", "Specify debugging output file",
      standard_option_handler },

#ifdef SIM_H8300 /* FIXME: Should be movable to h8300 dir.  */
  { {"h8300h", no_argument, NULL, OPTION_H8300H},
      'h', NULL, "Indicate the CPU is H8/300H",
      standard_option_handler },
  { {"h8300s", no_argument, NULL, OPTION_H8300S},
      'S', NULL, "Indicate the CPU is H8S",
      standard_option_handler },
  { {"h8300sx", no_argument, NULL, OPTION_H8300SX},
      'x', NULL, "Indicate the CPU is H8SX",
      standard_option_handler },
#endif

#ifdef SIM_HAVE_FLATMEM
  { {"mem-size", required_argument, NULL, OPTION_MEM_SIZE},
     'm', "<size>[in bytes, Kb (k suffix), Mb (m suffix) or Gb (g suffix)]",
     "Specify memory size", standard_option_handler },
#endif

  { {"do-command", required_argument, NULL, OPTION_DO_COMMAND},
      '\0', "COMMAND", ""/*undocumented*/,
      standard_option_handler },

  { {"help", no_argument, NULL, OPTION_HELP},
      'H', NULL, "Print help information",
      standard_option_handler },

  { {"architecture", required_argument, NULL, OPTION_ARCHITECTURE},
      '\0', "MACHINE", "Specify the architecture to use",
      standard_option_handler },
  { {"architecture-info", no_argument, NULL, OPTION_ARCHITECTURE_INFO},
      '\0', NULL, "List supported architectures",
      standard_option_handler },
  { {"info-architecture", no_argument, NULL, OPTION_ARCHITECTURE_INFO},
      '\0', NULL, NULL,
      standard_option_handler },

  { {"target", required_argument, NULL, OPTION_TARGET},
      '\0', "BFDNAME", "Specify the object-code format for the object files",
      standard_option_handler },

#ifdef SIM_HANDLES_LMA
  { {"load-lma", no_argument, NULL, OPTION_LOAD_LMA},
      '\0', NULL,
#if SIM_HANDLES_LMA
    "Use VMA or LMA addresses when loading image (default LMA)",
#else
    "Use VMA or LMA addresses when loading image (default VMA)",
#endif
      standard_option_handler, "load-{lma,vma}" },
  { {"load-vma", no_argument, NULL, OPTION_LOAD_VMA},
      '\0', NULL, "", standard_option_handler,  "" },
#endif

  { {"sysroot", required_argument, NULL, OPTION_SYSROOT},
      '\0', "SYSROOT",
    "Root for system calls with absolute file-names and cwd at start",
      standard_option_handler, NULL },

  { {NULL, no_argument, NULL, 0}, '\0', NULL, NULL, NULL, NULL }
};

static SIM_RC
standard_option_handler (SIM_DESC sd, sim_cpu *cpu, int opt,
			 char *arg, int is_command)
{
  int i,n;

  switch ((STANDARD_OPTIONS) opt)
    {
    case OPTION_VERBOSE:
      STATE_VERBOSE_P (sd) = 1;
      break;

    case OPTION_ENDIAN:
      if (strcmp (arg, "big") == 0)
	{
	  if (WITH_TARGET_BYTE_ORDER == LITTLE_ENDIAN)
	    {
	      sim_io_eprintf (sd, "Simulator compiled for little endian only.\n");
	      return SIM_RC_FAIL;
	    }
	  /* FIXME:wip: Need to set something in STATE_CONFIG.  */
	  current_target_byte_order = BIG_ENDIAN;
	}
      else if (strcmp (arg, "little") == 0)
	{
	  if (WITH_TARGET_BYTE_ORDER == BIG_ENDIAN)
	    {
	      sim_io_eprintf (sd, "Simulator compiled for big endian only.\n");
	      return SIM_RC_FAIL;
	    }
	  /* FIXME:wip: Need to set something in STATE_CONFIG.  */
	  current_target_byte_order = LITTLE_ENDIAN;
	}
      else
	{
	  sim_io_eprintf (sd, "Invalid endian specification `%s'\n", arg);
	  return SIM_RC_FAIL;
	}
      break;

    case OPTION_ENVIRONMENT:
      if (strcmp (arg, "user") == 0)
	STATE_ENVIRONMENT (sd) = USER_ENVIRONMENT;
      else if (strcmp (arg, "virtual") == 0)
	STATE_ENVIRONMENT (sd) = VIRTUAL_ENVIRONMENT;
      else if (strcmp (arg, "operating") == 0)
	STATE_ENVIRONMENT (sd) = OPERATING_ENVIRONMENT;
      else
	{
	  sim_io_eprintf (sd, "Invalid environment specification `%s'\n", arg);
	  return SIM_RC_FAIL;
	}
      if (WITH_ENVIRONMENT != ALL_ENVIRONMENT
	  && WITH_ENVIRONMENT != STATE_ENVIRONMENT (sd))
	{
	  const char *type;
	  switch (WITH_ENVIRONMENT)
	    {
	    case USER_ENVIRONMENT: type = "user"; break;
	    case VIRTUAL_ENVIRONMENT: type = "virtual"; break;
	    case OPERATING_ENVIRONMENT: type = "operating"; break;
	    }
	  sim_io_eprintf (sd, "Simulator compiled for the %s environment only.\n",
			  type);
	  return SIM_RC_FAIL;
	}
      break;

    case OPTION_ALIGNMENT:
      if (strcmp (arg, "strict") == 0)
	{
	  if (WITH_ALIGNMENT == 0 || WITH_ALIGNMENT == STRICT_ALIGNMENT)
	    {
	      current_alignment = STRICT_ALIGNMENT;
	      break;
	    }
	}
      else if (strcmp (arg, "nonstrict") == 0)
	{
	  if (WITH_ALIGNMENT == 0 || WITH_ALIGNMENT == NONSTRICT_ALIGNMENT)
	    {
	      current_alignment = NONSTRICT_ALIGNMENT;
	      break;
	    }
	}
      else if (strcmp (arg, "forced") == 0)
	{
	  if (WITH_ALIGNMENT == 0 || WITH_ALIGNMENT == FORCED_ALIGNMENT)
	    {
	      current_alignment = FORCED_ALIGNMENT;
	      break;
	    }
	}
      else
	{
	  sim_io_eprintf (sd, "Invalid alignment specification `%s'\n", arg);
	  return SIM_RC_FAIL;
	}
      switch (WITH_ALIGNMENT)
	{
	case STRICT_ALIGNMENT:
	  sim_io_eprintf (sd, "Simulator compiled for strict alignment only.\n");
	  break;
	case NONSTRICT_ALIGNMENT:
	  sim_io_eprintf (sd, "Simulator compiled for nonstrict alignment only.\n");
	  break;
	case FORCED_ALIGNMENT:
	  sim_io_eprintf (sd, "Simulator compiled for forced alignment only.\n");
	  break;
	}
      return SIM_RC_FAIL;

    case OPTION_DEBUG:
      if (! WITH_DEBUG)
	sim_io_eprintf (sd, "Debugging not compiled in, `-D' ignored\n");
      else
	{
	  for (n = 0; n < MAX_NR_PROCESSORS; ++n)
	    for (i = 0; i < MAX_DEBUG_VALUES; ++i)
	      CPU_DEBUG_FLAGS (STATE_CPU (sd, n))[i] = 1;
	}
      break;

    case OPTION_DEBUG_INSN :
      if (! WITH_DEBUG)
	sim_io_eprintf (sd, "Debugging not compiled in, `--debug-insn' ignored\n");
      else
	{
	  for (n = 0; n < MAX_NR_PROCESSORS; ++n)
	    CPU_DEBUG_FLAGS (STATE_CPU (sd, n))[DEBUG_INSN_IDX] = 1;
	}
      break;

    case OPTION_DEBUG_FILE :
      if (! WITH_DEBUG)
	sim_io_eprintf (sd, "Debugging not compiled in, `--debug-file' ignored\n");
      else
	{
	  FILE *f = fopen (arg, "w");

	  if (f == NULL)
	    {
	      sim_io_eprintf (sd, "Unable to open debug output file `%s'\n", arg);
	      return SIM_RC_FAIL;
	    }
	  for (n = 0; n < MAX_NR_PROCESSORS; ++n)
	    CPU_DEBUG_FILE (STATE_CPU (sd, n)) = f;
	}
      break;

#ifdef SIM_H8300 /* FIXME: Can be moved to h8300 dir.  */
    case OPTION_H8300H:
      set_h8300h (bfd_mach_h8300h);
      break;
    case OPTION_H8300S:
      set_h8300h (bfd_mach_h8300s);
      break;
    case OPTION_H8300SX:
      set_h8300h (bfd_mach_h8300sx);
      break;
#endif

#ifdef SIM_HAVE_FLATMEM
    case OPTION_MEM_SIZE:
      {
	char * endp;
	unsigned long ul = strtol (arg, &endp, 0);

	switch (* endp)
	  {
	  case 'k': case 'K': size <<= 10; break;
	  case 'm': case 'M': size <<= 20; break;
	  case 'g': case 'G': size <<= 30; break;
	  case ' ': case '\0': case '\t':  break;
	  default:
	    if (ul > 0)
	      sim_io_eprintf (sd, "Ignoring strange character at end of memory size: %c\n", * endp);
	    break;
	  }

	/* 16384: some minimal amount */
	if (! isdigit (arg[0]) || ul < 16384)
	  {
	    sim_io_eprintf (sd, "Invalid memory size `%s'", arg);
	    return SIM_RC_FAIL;
	  }
	STATE_MEM_SIZE (sd) = ul;
      }
      break;
#endif

    case OPTION_DO_COMMAND:
      sim_do_command (sd, arg);
      break;

    case OPTION_ARCHITECTURE:
      {
	const struct bfd_arch_info *ap = bfd_scan_arch (arg);
	if (ap == NULL)
	  {
	    sim_io_eprintf (sd, "Architecture `%s' unknown\n", arg);
	    return SIM_RC_FAIL;
	  }
	STATE_ARCHITECTURE (sd) = ap;
	break;
      }

    case OPTION_ARCHITECTURE_INFO:
      {
	const char **list = bfd_arch_list ();
	const char **lp;
	if (list == NULL)
	  abort ();
	sim_io_printf (sd, "Possible architectures:");
	for (lp = list; *lp != NULL; lp++)
	  sim_io_printf (sd, " %s", *lp);
	sim_io_printf (sd, "\n");
	free (list);
	break;
      }

    case OPTION_TARGET:
      {
	STATE_TARGET (sd) = xstrdup (arg);
	break;
      }

    case OPTION_LOAD_LMA:
      {
	STATE_LOAD_AT_LMA_P (sd) = 1;
	break;
      }

    case OPTION_LOAD_VMA:
      {
	STATE_LOAD_AT_LMA_P (sd) = 0;
	break;
      }

    case OPTION_HELP:
      sim_print_help (sd, is_command);
      if (STATE_OPEN_KIND (sd) == SIM_OPEN_STANDALONE)
	exit (0);
      /* FIXME: 'twould be nice to do something similar if gdb.  */
      break;

    case OPTION_SYSROOT:
      /* Don't leak memory in the odd event that there's lots of
	 --sysroot=... options.  We treat "" specially since this
	 is the statically initialized value and cannot free it.  */
      if (simulator_sysroot[0] != '\0')
	free (simulator_sysroot);
      if (arg[0] != '\0')
	simulator_sysroot = xstrdup (arg);
      else
	simulator_sysroot = "";
      break;
    }

  return SIM_RC_OK;
}

/* Add the standard option list to the simulator.  */

SIM_RC
standard_install (SIM_DESC sd)
{
  SIM_ASSERT (STATE_MAGIC (sd) == SIM_MAGIC_NUMBER);
  if (sim_add_option_table (sd, NULL, standard_options) != SIM_RC_OK)
    return SIM_RC_FAIL;
#ifdef SIM_HANDLES_LMA
  STATE_LOAD_AT_LMA_P (sd) = SIM_HANDLES_LMA;
#endif
  return SIM_RC_OK;
}

/* Return non-zero if arg is a duplicate argument.
   If ARG is NULL, initialize.  */

#define ARG_HASH_SIZE 97
#define ARG_HASH(a) ((256 * (unsigned char) a[0] + (unsigned char) a[1]) % ARG_HASH_SIZE)

static int
dup_arg_p (const char *arg)
{
  int hash;
  static const char **arg_table = NULL;

  if (arg == NULL)
    {
      if (arg_table == NULL)
	arg_table = (const char **) xmalloc (ARG_HASH_SIZE * sizeof (char *));
      memset (arg_table, 0, ARG_HASH_SIZE * sizeof (char *));
      return 0;
    }

  hash = ARG_HASH (arg);
  while (arg_table[hash] != NULL)
    {
      if (strcmp (arg, arg_table[hash]) == 0)
	return 1;
      /* We assume there won't be more than ARG_HASH_SIZE arguments so we
	 don't check if the table is full.  */
      if (++hash == ARG_HASH_SIZE)
	hash = 0;
    }
  arg_table[hash] = arg;
  return 0;
}

/* Called by sim_open to parse the arguments.  */

SIM_RC
sim_parse_args (SIM_DESC sd, char **argv)
{
  int c, i, argc, num_opts;
  char *p, *short_options;
  /* The `val' option struct entry is dynamically assigned for options that
     only come in the long form.  ORIG_VAL is used to get the original value
     back.  */
  int *orig_val;
  struct option *lp, *long_options;
  const struct option_list *ol;
  const OPTION *opt;
  OPTION_HANDLER **handlers;
  sim_cpu **opt_cpu;
  SIM_RC result = SIM_RC_OK;

  /* Count the number of arguments.  */
  for (argc = 0; argv[argc] != NULL; ++argc)
    continue;

  /* Count the number of options.  */
  num_opts = 0;
  for (ol = STATE_OPTIONS (sd); ol != NULL; ol = ol->next)
    for (opt = ol->options; OPTION_VALID_P (opt); ++opt)
      ++num_opts;
  for (i = 0; i < MAX_NR_PROCESSORS; ++i)
    for (ol = CPU_OPTIONS (STATE_CPU (sd, i)); ol != NULL; ol = ol->next)
      for (opt = ol->options; OPTION_VALID_P (opt); ++opt)
	++num_opts;

  /* Initialize duplicate argument checker.  */
  (void) dup_arg_p (NULL);

  /* Build the option table for getopt.  */

  long_options = NZALLOC (struct option, num_opts + 1);
  lp = long_options;
  short_options = NZALLOC (char, num_opts * 3 + 1);
  p = short_options;
  handlers = NZALLOC (OPTION_HANDLER *, OPTION_START + num_opts);
  orig_val = NZALLOC (int, OPTION_START + num_opts);
  opt_cpu = NZALLOC (sim_cpu *, OPTION_START + num_opts);

  /* Set '+' as first char so argument permutation isn't done.  This
     is done to stop getopt_long returning options that appear after
     the target program.  Such options should be passed unchanged into
     the program image. */
  *p++ = '+';

  for (i = OPTION_START, ol = STATE_OPTIONS (sd); ol != NULL; ol = ol->next)
    for (opt = ol->options; OPTION_VALID_P (opt); ++opt)
      {
	if (dup_arg_p (opt->opt.name))
	  continue;
	if (opt->shortopt != 0)
	  {
	    *p++ = opt->shortopt;
	    if (opt->opt.has_arg == required_argument)
	      *p++ = ':';
	    else if (opt->opt.has_arg == optional_argument)
	      { *p++ = ':'; *p++ = ':'; }
	    handlers[(unsigned char) opt->shortopt] = opt->handler;
	    if (opt->opt.val != 0)
	      orig_val[(unsigned char) opt->shortopt] = opt->opt.val;
	    else
	      orig_val[(unsigned char) opt->shortopt] = opt->shortopt;
	  }
	if (opt->opt.name != NULL)
	  {
	    *lp = opt->opt;
	    /* Dynamically assign `val' numbers for long options. */
	    lp->val = i++;
	    handlers[lp->val] = opt->handler;
	    orig_val[lp->val] = opt->opt.val;
	    opt_cpu[lp->val] = NULL;
	    ++lp;
	  }
      }

  for (c = 0; c < MAX_NR_PROCESSORS; ++c)
    {
      sim_cpu *cpu = STATE_CPU (sd, c);
      for (ol = CPU_OPTIONS (cpu); ol != NULL; ol = ol->next)
	for (opt = ol->options; OPTION_VALID_P (opt); ++opt)
	  {
#if 0 /* Each option is prepended with --<cpuname>- so this greatly cuts down
	 on the need for dup_arg_p checking.  Maybe in the future it'll be
	 needed so this is just commented out, and not deleted.  */
	    if (dup_arg_p (opt->opt.name))
	      continue;
#endif
	    /* Don't allow short versions of cpu specific options for now.  */
	    if (opt->shortopt != 0)
	      {
		sim_io_eprintf (sd, "internal error, short cpu specific option");
		result = SIM_RC_FAIL;
		break;
	      }
	    if (opt->opt.name != NULL)
	      {
		char *name;
		*lp = opt->opt;
		/* Prepend --<cpuname>- to the option.  */
		if (asprintf (&name, "%s-%s", CPU_NAME (cpu), lp->name) < 0)
		  {
		    sim_io_eprintf (sd, "internal error, out of memory");
		    result = SIM_RC_FAIL;
		    break;
		  }
		lp->name = name;
		/* Dynamically assign `val' numbers for long options. */
		lp->val = i++;
		handlers[lp->val] = opt->handler;
		orig_val[lp->val] = opt->opt.val;
		opt_cpu[lp->val] = cpu;
		++lp;
	      }
	  }
    }

  /* Terminate the short and long option lists.  */
  *p = 0;
  lp->name = NULL;

  /* Ensure getopt is initialized.  */
  optind = 0;

  while (1)
    {
      int longind, optc;

      optc = getopt_long (argc, argv, short_options, long_options, &longind);
      if (optc == -1)
	{
	  if (STATE_OPEN_KIND (sd) == SIM_OPEN_STANDALONE)
	    STATE_PROG_ARGV (sd) = dupargv (argv + optind);
	  break;
	}
      if (optc == '?')
	{
	  result = SIM_RC_FAIL;
	  break;
	}

      if ((*handlers[optc]) (sd, opt_cpu[optc], orig_val[optc], optarg, 0/*!is_command*/) == SIM_RC_FAIL)
	{
	  result = SIM_RC_FAIL;
	  break;
	}
    }

  free (long_options);
  free (short_options);
  free (handlers);
  free (opt_cpu);
  free (orig_val);
  return result;
}

/* Utility of sim_print_help to print a list of option tables.  */

static void
print_help (SIM_DESC sd, sim_cpu *cpu, const struct option_list *ol, int is_command)
{
  const OPTION *opt;

  for ( ; ol != NULL; ol = ol->next)
    for (opt = ol->options; OPTION_VALID_P (opt); ++opt)
      {
	const int indent = 30;
	int comma, len;
	const OPTION *o;

	if (dup_arg_p (opt->opt.name))
	  continue;

	if (opt->doc == NULL)
	  continue;

	if (opt->doc_name != NULL && opt->doc_name [0] == '\0')
	  continue;

	sim_io_printf (sd, "  ");

	comma = 0;
	len = 2;

	/* list any short options (aliases) for the current OPT */
	if (!is_command)
	  {
	    o = opt;
	    do
	      {
		if (o->shortopt != '\0')
		  {
		    sim_io_printf (sd, "%s-%c", comma ? ", " : "", o->shortopt);
		    len += (comma ? 2 : 0) + 2;
		    if (o->arg != NULL)
		      {
			if (o->opt.has_arg == optional_argument)
			  {
			    sim_io_printf (sd, "[%s]", o->arg);
			    len += 1 + strlen (o->arg) + 1;
			  }
			else
			  {
			    sim_io_printf (sd, " %s", o->arg);
			    len += 1 + strlen (o->arg);
			  }
		      }
		    comma = 1;
		  }
		++o;
	      }
	    while (OPTION_VALID_P (o) && o->doc == NULL);
	  }

	/* list any long options (aliases) for the current OPT */
	o = opt;
	do
	  {
	    const char *name;
	    const char *cpu_prefix = cpu ? CPU_NAME (cpu) : NULL;
	    if (o->doc_name != NULL)
	      name = o->doc_name;
	    else
	      name = o->opt.name;
	    if (name != NULL)
	      {
		sim_io_printf (sd, "%s%s%s%s%s",
			       comma ? ", " : "",
			       is_command ? "" : "--",
			       cpu ? cpu_prefix : "",
			       cpu ? "-" : "",
			       name);
		len += ((comma ? 2 : 0)
			+ (is_command ? 0 : 2)
			+ strlen (name));
		if (o->arg != NULL)
		  {
		    if (o->opt.has_arg == optional_argument)
		      {
			sim_io_printf (sd, "[=%s]", o->arg);
			len += 2 + strlen (o->arg) + 1;
		      }
		    else
		      {
			sim_io_printf (sd, " %s", o->arg);
			len += 1 + strlen (o->arg);
		      }
		  }
		comma = 1;
	      }
	    ++o;
	  }
	while (OPTION_VALID_P (o) && o->doc == NULL);

	if (len >= indent)
	  {
	    sim_io_printf (sd, "\n%*s", indent, "");
	  }
	else
	  sim_io_printf (sd, "%*s", indent - len, "");

	/* print the description, word wrap long lines */
	{
	  const char *chp = opt->doc;
	  unsigned doc_width = 80 - indent;
	  while (strlen (chp) >= doc_width) /* some slack */
	    {
	      const char *end = chp + doc_width - 1;
	      while (end > chp && !isspace (*end))
		end --;
	      if (end == chp)
		end = chp + doc_width - 1;
	      /* The cast should be ok - its distances between to
                 points in a string.  */
	      sim_io_printf (sd, "%.*s\n%*s", (int) (end - chp), chp, indent,
			     "");
	      chp = end;
	      while (isspace (*chp) && *chp != '\0')
		chp++;
	    }
	  sim_io_printf (sd, "%s\n", chp);
	}
      }
}

/* Print help messages for the options.  */

void
sim_print_help (SIM_DESC sd, int is_command)
{
  if (STATE_OPEN_KIND (sd) == SIM_OPEN_STANDALONE)
    sim_io_printf (sd, "Usage: %s [options] program [program args]\n",
		   STATE_MY_NAME (sd));

  /* Initialize duplicate argument checker.  */
  (void) dup_arg_p (NULL);

  if (STATE_OPEN_KIND (sd) == SIM_OPEN_STANDALONE)
    sim_io_printf (sd, "Options:\n");
  else
    sim_io_printf (sd, "Commands:\n");

  print_help (sd, NULL, STATE_OPTIONS (sd), is_command);
  sim_io_printf (sd, "\n");

  /* Print cpu-specific options.  */
  {
    int i;

    for (i = 0; i < MAX_NR_PROCESSORS; ++i)
      {
	sim_cpu *cpu = STATE_CPU (sd, i);
	if (CPU_OPTIONS (cpu) == NULL)
	  continue;
	sim_io_printf (sd, "CPU %s specific options:\n", CPU_NAME (cpu));
	print_help (sd, cpu, CPU_OPTIONS (cpu), is_command);
	sim_io_printf (sd, "\n");
      }
  }

  sim_io_printf (sd, "Note: Depending on the simulator configuration some %ss\n",
		 STATE_OPEN_KIND (sd) == SIM_OPEN_STANDALONE ? "option" : "command");
  sim_io_printf (sd, "      may not be applicable\n");

  if (STATE_OPEN_KIND (sd) == SIM_OPEN_STANDALONE)
    {
      sim_io_printf (sd, "\n");
      sim_io_printf (sd, "program args    Arguments to pass to simulated program.\n");
      sim_io_printf (sd, "                Note: Very few simulators support this.\n");
    }
}

/* Utility of sim_args_command to find the closest match for a command.
   Commands that have "-" in them can be specified as separate words.
   e.g. sim memory-region 0x800000,0x4000
   or   sim memory region 0x800000,0x4000
   If CPU is non-null, use its option table list, otherwise use the main one.
   *PARGI is where to start looking in ARGV.  It is updated to point past
   the found option.  */

static const OPTION *
find_match (SIM_DESC sd, sim_cpu *cpu, char *argv[], int *pargi)
{
  const struct option_list *ol;
  const OPTION *opt;
  /* most recent option match */
  const OPTION *matching_opt = NULL;
  int matching_argi = -1;

  if (cpu)
    ol = CPU_OPTIONS (cpu);
  else
    ol = STATE_OPTIONS (sd);

  /* Skip passed elements specified by *PARGI.  */
  argv += *pargi;

  for ( ; ol != NULL; ol = ol->next)
    for (opt = ol->options; OPTION_VALID_P (opt); ++opt)
      {
	int argi = 0;
	const char *name = opt->opt.name;
	if (name == NULL)
	  continue;
	while (argv [argi] != NULL
	       && strncmp (name, argv [argi], strlen (argv [argi])) == 0)
	  {
	    name = &name [strlen (argv[argi])];
	    if (name [0] == '-')
	      {
		/* leading match ...<a-b-c>-d-e-f - continue search */
		name ++; /* skip `-' */
		argi ++;
		continue;
	      }
	    else if (name [0] == '\0')
	      {
		/* exact match ...<a-b-c-d-e-f> - better than before? */
		if (argi > matching_argi)
		  {
		    matching_argi = argi;
		    matching_opt = opt;
		  }
		break;
	      }
	    else
	      break;
	  }
      }

  *pargi = matching_argi;
  return matching_opt;
}

static char **
complete_option_list (char **ret, size_t *cnt, const struct option_list *ol,
		      const char *text, const char *word)
{
  const OPTION *opt = NULL;
  int argi;
  size_t len = strlen (word);

  for ( ; ol != NULL; ol = ol->next)
    for (opt = ol->options; OPTION_VALID_P (opt); ++opt)
      {
	const char *name = opt->opt.name;

	/* A long option to match against?  */
	if (!name)
	  continue;

	/* Does this option actually match?  */
	if (strncmp (name, word, len))
	  continue;

	ret = xrealloc (ret, ++*cnt * sizeof (ret[0]));
	ret[*cnt - 2] = xstrdup (name);
      }

  return ret;
}

/* All leading text is stored in @@text, while the current word being
   completed is stored in @@word.  Trailing text of @@word is not.  */

char **
sim_complete_command (SIM_DESC sd, const char *text, const char *word)
{
  char **ret = NULL;
  size_t cnt = 1;
  sim_cpu *cpu;

  /* Only complete first word for now.  */
  if (text != word)
    return ret;

  cpu = STATE_CPU (sd, 0);
  if (cpu)
    ret = complete_option_list (ret, &cnt, CPU_OPTIONS (cpu), text, word);
  ret = complete_option_list (ret, &cnt, STATE_OPTIONS (sd), text, word);

  if (ret)
    ret[cnt - 1] = NULL;
  return ret;
}

SIM_RC
sim_args_command (SIM_DESC sd, char *cmd)
{
  /* something to do? */
  if (cmd == NULL)
    return SIM_RC_OK; /* FIXME - perhaps help would be better */

  if (cmd [0] == '-')
    {
      /* user specified -<opt> ... form? */
      char **argv = buildargv (cmd);
      SIM_RC rc = sim_parse_args (sd, argv);
      freeargv (argv);
      return rc;
    }
  else
    {
      char **argv = buildargv (cmd);
      const OPTION *matching_opt = NULL;
      int matching_argi;
      sim_cpu *cpu;

      if (argv [0] == NULL)
	return SIM_RC_OK; /* FIXME - perhaps help would be better */

      /* First check for a cpu selector.  */
      {
	char *cpu_name = xstrdup (argv[0]);
	char *hyphen = strchr (cpu_name, '-');
	if (hyphen)
	  *hyphen = 0;
	cpu = sim_cpu_lookup (sd, cpu_name);
	if (cpu)
	  {
	    /* If <cpuname>-<command>, point argv[0] at <command>.  */
	    if (hyphen)
	      {
		matching_argi = 0;
		argv[0] += hyphen - cpu_name + 1;
	      }
	    else
	      matching_argi = 1;
	    matching_opt = find_match (sd, cpu, argv, &matching_argi);
	    /* If hyphen found restore argv[0].  */
	    if (hyphen)
	      argv[0] -= hyphen - cpu_name + 1;
	  }
	free (cpu_name);
      }

      /* If that failed, try the main table.  */
      if (matching_opt == NULL)
	{
	  matching_argi = 0;
	  matching_opt = find_match (sd, NULL, argv, &matching_argi);
	}

      if (matching_opt != NULL)
	{
	  switch (matching_opt->opt.has_arg)
	    {
	    case no_argument:
	      if (argv [matching_argi + 1] == NULL)
		matching_opt->handler (sd, cpu, matching_opt->opt.val,
				       NULL, 1/*is_command*/);
	      else
		sim_io_eprintf (sd, "Command `%s' takes no arguments\n",
				matching_opt->opt.name);
	      break;
	    case optional_argument:
	      if (argv [matching_argi + 1] == NULL)
		matching_opt->handler (sd, cpu, matching_opt->opt.val,
				       NULL, 1/*is_command*/);
	      else if (argv [matching_argi + 2] == NULL)
		matching_opt->handler (sd, cpu, matching_opt->opt.val,
				       argv [matching_argi + 1], 1/*is_command*/);
	      else
		sim_io_eprintf (sd, "Command `%s' requires no more than one argument\n",
				matching_opt->opt.name);
	      break;
	    case required_argument:
	      if (argv [matching_argi + 1] == NULL)
		sim_io_eprintf (sd, "Command `%s' requires an argument\n",
				matching_opt->opt.name);
	      else if (argv [matching_argi + 2] == NULL)
		matching_opt->handler (sd, cpu, matching_opt->opt.val,
				       argv [matching_argi + 1], 1/*is_command*/);
	      else
		sim_io_eprintf (sd, "Command `%s' requires only one argument\n",
				matching_opt->opt.name);
	    }
	  freeargv (argv);
	  return SIM_RC_OK;
	}

      freeargv (argv);
    }

  /* didn't find anything that remotly matched */
  return SIM_RC_FAIL;
}
@


1.30
log
@gdb:

2013-03-15  Steve Ellcey  <sellcey@@mips.com>

	* remote-sim.c (sim_command_completer): Make char arguments const.

include:


2013-03-15  Steve Ellcey  <sellcey@@mips.com>

	* gdb/remote-sim.h (sim_command_completer): Make char arguments const.

sim:

2013-03-15  Steve Ellcey  <sellcey@@mips.com>

	* arm/wrapper.c (sim_complete_command): Make char arguments const.
	* avr/interp.c (sim_complete_command): Ditto.
	* common/sim-options.c (sim_complete_command): Ditto.
	* cr16/interp.c (sim_complete_command): Ditto.
	* erc32/interf.c (sim_complete_command): Ditto.
	* m32c/gdb-if.c (sim_complete_command): Ditto.
	* microblaze/interp.c (sim_complete_command): Ditto.
	* ppc/sim_calls.c (sim_complete_command): Ditto.
	* rl78/gdb-if.c (sim_complete_command): Ditto.
	* rx/gdb-if.c (sim_complete_command): Ditto.
	* sh/interp.c (sim_complete_command): Ditto.
@
text
@d923 1
a923 1
		      char *text, char *word)
@


1.29
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d953 1
a953 1
sim_complete_command (SIM_DESC sd, char *text, char *word)
@


1.28
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 2
   Copyright (C) 1996-1997, 2004, 2007-2012 Free Software Foundation,
   Inc.
@


1.27
log
@sim: fix minor --sysroot mem leak

The current --sysroot parsing attempts to keep from leaking memory by
treating the empty string specially (sine this is the initial value),
but it ends up leaking memory when the arg is an empty string.  So if
someone uses --sysroot "", the old value is leaked, as is the new one.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d2 2
a3 2
   Copyright (C) 1996, 1997, 2004, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.27.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 2
   Copyright (C) 1996-1997, 2004, 2007-2012 Free Software Foundation,
   Inc.
@


1.26
log
@sim: fix func call style (space before paren)

Committed this as obvious:
	-foo(...);
	+foo (...);

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d461 3
a463 2
	 --sysroot=... options.  */
      if (simulator_sysroot[0] != '\0' && arg[0] != '\0')
d465 4
a468 1
      simulator_sysroot = xstrdup (arg);
@


1.25
log
@gdb: sim: add style fixes lost between git->cvs
@
text
@d422 1
a422 1
	const char **list = bfd_arch_list();
@


1.24
log
@gdb: sim: add command line completion

For now, only the sub-command name is completed.  No support yet for
completing options to that command.  But even this is a huge step as
currently, nothing is completed, and the basic "help sim" is fairly
obtuse as to what exactly the "sim" command accepts.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d948 1
@


1.23
log
@sim: common: trim trailing whitespace
@
text
@d918 51
@


1.22
log
@sim: punt zfree()

The sim keeps track of which allocations are zero-ed internally (via
zalloc) and then calls a helper "zfree" function rather than "free".
But this "zfree" function simply calls "free" itself.  Since I can
see no point in this and it is simply useless overhead, punt it.

The only real change is in hw-alloc.c where we remove the zalloc_p
tracking, and sim-utils.c where zfree is delete.  The rest of the
changes are a simple `sed` from "zfree" to "free".

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d518 1
a518 1
     
d640 1
a640 1
	    
d737 1
a737 1
	
d924 1
a924 1
  
d1015 1
a1015 1
      
@


1.21
log
@sim: check asprintf return values

These are the last sources of build warnings (asprintf usage) that I see.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d672 5
a676 5
  zfree (long_options);
  zfree (short_options);
  zfree (handlers);
  zfree (opt_cpu);
  zfree (orig_val);
@


1.20
log
@run copyright.sh for 2011.
@
text
@d624 6
a629 1
		asprintf (&name, "%s-%s", CPU_NAME (cpu), lp->name);
@


1.19
log
@sim: add missing values to array initializers

The sim code has a lot of static initializer for options and devices, but
since they aren't using newer struct style, they have to specify a value
for every option otherwise gcc spits a lot of warnings about "missing
initializer".  So add NULL/0 stubs for pointers/values.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 2004, 2007, 2008, 2009, 2010
@


1.18
log
@sim: constify dup_arg_p

The dup_arg_p function is only given const strings, and it maintains a
local table of those const strings.  So constify the whole thing to fix
the GCC warnings:

common/sim-options.c: In function 'sim_parse_args':
common/sim-options.c:559: warning: passing argument 1 of 'dup_arg_p'
	discards qualifiers from pointer target type
common/sim-options.c: In function 'print_help':
common/sim-options.c:675: warning: passing argument 1 of 'dup_arg_p'
	discards qualifiers from pointer target type

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d123 1
a123 1
      standard_option_handler },
d127 1
a127 1
      standard_option_handler },
d208 1
a208 1
      standard_option_handler },
d210 1
a210 1
  { {NULL, no_argument, NULL, 0}, '\0', NULL, NULL, NULL }
@


1.17
log
@sim: add const markings to env string

The sim-options code assigns a const string to "char *" in decoding the
current environment settings, and only uses it to pass to a printf.  GCC
outputs the warnings:
common/sim-options.c: In function 'standard_option_handler':
common/sim-options.c:271: warning: assignment discards qualifiers from pointer
target type
common/sim-options.c:272: warning: assignment discards qualifiers from pointer
target type
common/sim-options.c:273: warning: assignment discards qualifiers from pointer
target type

So I've committed this as "obvious".

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d492 1
a492 1
dup_arg_p (char *arg)
d495 1
a495 1
  static char **arg_table = NULL;
d500 1
a500 1
	arg_table = (char **) xmalloc (ARG_HASH_SIZE * sizeof (char *));
@


1.16
log
@sim: convert old style function definitions

GCC currently emits warnings like:
nrun.c: In function 'usage':
nrun.c:223: warning: old-style function definition
@
text
@d268 1
a268 1
	  char *type;
@


1.15
log
@sim: always enable support for the --endian option

The gdb code always passes down -E <little|big> to the sim core when using
the sim target.  But the sim core only recognizes this option when the sim
supports big endian systems.  So for little endian simulators, any attempt
to use the sim target fails with:

(gdb) target sim
gdbsim: invalid option -- 'E'
unable to create simulator instance

Since always respecting the option doesn't cause any problems, do just
that.  If someone tries to use an invalid endian, they'll get an error
anyways.
@
text
@d492 1
a492 2
dup_arg_p (arg)
     char *arg;
d522 1
a522 3
sim_parse_args (sd, argv)
     SIM_DESC sd;
     char **argv;
d807 1
a807 3
sim_print_help (sd, is_command)
     SIM_DESC sd;
     int is_command;
@


1.14
log
@Update copyright notices to add year 2010.
@
text
@a102 1
#if defined (SIM_HAVE_BIENDIAN)
a103 1
#endif
a124 1
#if defined (SIM_HAVE_BIENDIAN) /* ??? && WITH_TARGET_BYTE_ORDER == 0 */
a127 1
#endif
a224 1
#ifdef SIM_HAVE_BIENDIAN
a251 1
#endif
@


1.13
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 2004, 2007, 2008, 2009
@


1.12
log
@	Updated copyright notices for most files.
@
text
@d2 2
a3 1
   Copyright (C) 1996, 1997, 2004, 2007, 2008 Free Software Foundation, Inc.
@


1.11
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 2004, 2007 Free Software Foundation, Inc.
@


1.10
log
@* sim-memopt.c (memory_options): Mention that the memory-size switch accepts suffixes.
  (parse_size): Handle a suffix on the size value.
* sim-options.c (standard_options): Mention that the mem-size switch accepts suffixes.
  (standard_option_handler): Handle a suffix on the size value.
@
text
@d9 2
a10 2
the Free Software Foundation; either version 2, or (at your option)
any later version.
d17 2
a18 3
You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.9
log
@Copyright updates for 2007.
@
text
@d170 2
a171 2
      'm', "MEMORY SIZE", "Specify memory size",
      standard_option_handler },
d384 15
a398 1
	unsigned long ul = strtol (arg, NULL, 0);
@


1.8
log
@	* run.1: Document --sysroot=filepath.
	* sim-options.c (STANDARD_OPTIONS): New member OPTION_SYSROOT.
	(standard_options): Support --sysroot=<path>.
	(standard_option_handler): Handle OPTION_SYSROOT.
	* syscall.c (simulator_sysroot): Define, initialized empty.
	(get_path): Prepend simulator_sysroot to absolute file path.
	[HAVE_STRING_H]: Include string.h.
	[!HAVE_STRING_H && HAVE_STRINGS_H]: Include strings.h.
	* nrun.c [HAVE_UNISTD_H]: Include unistd.h.
	(main): If simulator_sysroot is not empty, chdir there.
	* sim-config.h (simulator_sysroot): Declare.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 2004 Free Software Foundation, Inc.
@


1.7
log
@	* hw-tree.c (parse_integer_property): Typo fix in comments.
	* sim-options.c	(sim_args_command): Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997 Free Software Foundation, Inc.
d118 1
d209 5
d450 8
@


1.6
log
@	* sim-options.c (standard_options): Fix the names of H8
	variants.
@
text
@d901 1
a901 1
    return SIM_RC_OK; /* FIXME - perhaphs help would be better */
d919 1
a919 1
	return SIM_RC_OK; /* FIXME - perhaphs help would be better */
@


1.6.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d901 1
a901 1
    return SIM_RC_OK; /* FIXME - perhaps help would be better */
d919 1
a919 1
	return SIM_RC_OK; /* FIXME - perhaps help would be better */
@


1.5
log
@Index: common/ChangeLog
2003-08-28  Andrew Cagney  <cagney@@redhat.com>

	* dv-glue.c (hw_glue_finish): Change %d to %ld to match sizeof.
	* sim-options.c (print_help): Cast the format with specifier to
	"int".

Index: mn10300/ChangeLog
2003-08-28  Andrew Cagney  <cagney@@redhat.com>

	* dv-mn103ser.c (do_polling_event): Change type of "serial_reg" to
	"long".
	(read_status_reg): Cast "serial_reg" to "long".
	* dv-mn103tim.c (do_counter_event): Change type of "timer_nr" to
	"long".
	(do_counter6_event, write_mode_reg, write_tm6md): Ditto.
@
text
@d157 1
a157 1
      'h', NULL, "Indicate the CPU is h8/300h",
d160 1
a160 1
      'S', NULL, "Indicate the CPU is h8/300s",
d163 1
a163 1
      'x', NULL, "Indicate the CPU is h8/300sx",
@


1.4
log
@2003-06-04  Michael Snyder  <msnyder@@redhat.com>

	* common/run.c (main): Remove SIM_H8300 ifdef.
	(usage): Ditto.
	* common/sim-options.c (STANDARD_OPTIONS): Add SIM_H8300SX.
	(standard_options): Add '-x' for h8/300sx.
	(standard_option_handler): Add case for SIM_H8300SX.
@
text
@d772 4
a775 1
	      sim_io_printf (sd, "%.*s\n%*s", end - chp, chp, indent, "");
@


1.3
log
@* h8300s now new target, not alias of h8300h
@
text
@d112 1
a112 1
  OPTION_H8300,
d114 1
d156 1
a156 1
  { {"h8300h", no_argument, NULL, OPTION_H8300},
d162 3
d364 2
a365 2
    case OPTION_H8300:
      set_h8300h (1,0);
d368 4
a371 1
      set_h8300h (1,1);
@


1.3.12.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d112 1
a112 1
  OPTION_H8300H,
a113 1
  OPTION_H8300SX,
d155 2
a156 2
  { {"h8300h", no_argument, NULL, OPTION_H8300H},
      'h', NULL, "Indicate the CPU is H8/300H",
d159 1
a159 4
      'S', NULL, "Indicate the CPU is H8S",
      standard_option_handler },
  { {"h8300sx", no_argument, NULL, OPTION_H8300SX},
      'x', NULL, "Indicate the CPU is H8SX",
d360 2
a361 2
    case OPTION_H8300H:
      set_h8300h (bfd_mach_h8300h);
d364 1
a364 4
      set_h8300h (bfd_mach_h8300s);
      break;
    case OPTION_H8300SX:
      set_h8300h (bfd_mach_h8300sx);
d765 1
a765 4
	      /* The cast should be ok - its distances between to
                 points in a string.  */
	      sim_io_printf (sd, "%.*s\n%*s", (int) (end - chp), chp, indent,
			     "");
@


1.3.10.1
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d112 1
a112 1
  OPTION_H8300H,
a113 1
  OPTION_H8300SX,
d155 1
a155 1
  { {"h8300h", no_argument, NULL, OPTION_H8300H},
a160 3
  { {"h8300sx", no_argument, NULL, OPTION_H8300SX},
      'x', NULL, "Indicate the CPU is h8/300sx",
      standard_option_handler },
d360 2
a361 2
    case OPTION_H8300H:
      set_h8300h (bfd_mach_h8300h);
d364 1
a364 4
      set_h8300h (bfd_mach_h8300s);
      break;
    case OPTION_H8300SX:
      set_h8300h (bfd_mach_h8300sx);
@


1.3.10.2
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d772 1
a772 4
	      /* The cast should be ok - its distances between to
                 points in a string.  */
	      sim_io_printf (sd, "%.*s\n%*s", (int) (end - chp), chp, indent,
			     "");
@


1.3.10.3
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d157 1
a157 1
      'h', NULL, "Indicate the CPU is H8/300H",
d160 1
a160 1
      'S', NULL, "Indicate the CPU is H8S",
d163 1
a163 1
      'x', NULL, "Indicate the CPU is H8SX",
@


1.2
log
@Fix memory leak in sim_parse_args
@
text
@d113 1
d156 4
a159 1
      'h', NULL, "Indicate the CPU is h8/300h or h8/300s",
d361 4
a364 1
      set_h8300h (1);
@


1.2.12.1
log
@merge from trunk
@
text
@a112 1
  OPTION_H8300S,
d155 1
a155 4
      'h', NULL, "Indicate the CPU is h8/300h",
      standard_option_handler },
  { {"h8300s", no_argument, NULL, OPTION_H8300S},
      'S', NULL, "Indicate the CPU is h8/300s",
d357 1
a357 4
      set_h8300h (1,0);
      break;
    case OPTION_H8300S:
      set_h8300h (1,1);
@


1.1
log
@Initial revision
@
text
@d114 2
d187 13
d412 12
d443 3
d502 1
d583 2
a584 1
		return SIM_RC_FAIL;
d622 4
a625 1
	return SIM_RC_FAIL;
d628 4
a631 1
	return SIM_RC_FAIL;
d634 6
a639 1
  return SIM_RC_OK;
d725 1
a725 1
			sim_io_printf (sd, " [%s]", o->arg);
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-12 snapshot
@
text
@a113 2
  OPTION_LOAD_LMA,
  OPTION_LOAD_VMA,
a184 13
#ifdef SIM_HANDLES_LMA
  { {"load-lma", no_argument, NULL, OPTION_LOAD_LMA},
      '\0', NULL,
#if SIM_HANDLES_LMA
    "Use VMA or LMA addresses when loading image (default LMA)",
#else
    "Use VMA or LMA addresses when loading image (default VMA)",
#endif
      standard_option_handler, "load-{lma,vma}" },
  { {"load-vma", no_argument, NULL, OPTION_LOAD_VMA},
      '\0', NULL, "", standard_option_handler,  "" },
#endif

a396 12
    case OPTION_LOAD_LMA:
      {
	STATE_LOAD_AT_LMA_P (sd) = 1;
	break;
      }

    case OPTION_LOAD_VMA:
      {
	STATE_LOAD_AT_LMA_P (sd) = 0;
	break;
      }

a415 3
#ifdef SIM_HANDLES_LMA
  STATE_LOAD_AT_LMA_P (sd) = SIM_HANDLES_LMA;
#endif
@


1.1.1.3
log
@import gdb-1999-12-13 snapshot
@
text
@d712 1
a712 1
			sim_io_printf (sd, "[=%s]", o->arg);
@


