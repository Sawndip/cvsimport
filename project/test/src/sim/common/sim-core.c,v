head	1.17;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.17
	gdb_7_6-2013-04-26-release:1.17
	gdb_7_6-branch:1.17.0.2
	gdb_7_6-2013-03-12-branchpoint:1.17
	gdb_7_5_1-2012-11-29-release:1.16
	gdb_7_5-2012-08-17-release:1.16
	gdb_7_5-branch:1.16.0.2
	gdb_7_5-2012-07-18-branchpoint:1.16
	gdb_7_4_1-2012-04-26-release:1.15.2.1
	gdb_7_4-2012-01-24-release:1.15.2.1
	gdb_7_4-branch:1.15.0.2
	gdb_7_4-2011-12-13-branchpoint:1.15
	gdb_7_3_1-2011-09-04-release:1.14
	gdb_7_3-2011-07-26-release:1.14
	gdb_7_3-branch:1.14.0.2
	gdb_7_3-2011-04-01-branchpoint:1.14
	gdb_7_2-2010-09-02-release:1.10
	gdb_7_2-branch:1.10.0.2
	gdb_7_2-2010-07-07-branchpoint:1.10
	gdb_7_1-2010-03-18-release:1.9
	gdb_7_1-branch:1.9.0.2
	gdb_7_1-2010-02-18-branchpoint:1.9
	gdb_7_0_1-2009-12-22-release:1.8
	gdb_7_0-2009-10-06-release:1.8
	gdb_7_0-branch:1.8.0.4
	gdb_7_0-2009-09-16-branchpoint:1.8
	arc-sim-20090309:1.7
	msnyder-checkpoint-072509-branch:1.8.0.2
	msnyder-checkpoint-072509-branchpoint:1.8
	arc-insight_6_8-branch:1.7.0.16
	arc-insight_6_8-branchpoint:1.7
	insight_6_8-branch:1.7.0.14
	insight_6_8-branchpoint:1.7
	reverse-20081226-branch:1.7.0.12
	reverse-20081226-branchpoint:1.7
	multiprocess-20081120-branch:1.7.0.10
	multiprocess-20081120-branchpoint:1.7
	reverse-20080930-branch:1.7.0.8
	reverse-20080930-branchpoint:1.7
	reverse-20080717-branch:1.7.0.6
	reverse-20080717-branchpoint:1.7
	msnyder-reverse-20080609-branch:1.7.0.4
	msnyder-reverse-20080609-branchpoint:1.7
	drow-reverse-20070409-branch:1.5.0.2
	drow-reverse-20070409-branchpoint:1.5
	gdb_6_8-2008-03-27-release:1.7
	gdb_6_8-branch:1.7.0.2
	gdb_6_8-2008-02-26-branchpoint:1.7
	gdb_6_7_1-2007-10-29-release:1.6
	gdb_6_7-2007-10-10-release:1.6
	gdb_6_7-branch:1.6.0.2
	gdb_6_7-2007-09-07-branchpoint:1.6
	insight_6_6-20070208-release:1.4
	gdb_6_6-2006-12-18-release:1.4
	gdb_6_6-branch:1.4.0.48
	gdb_6_6-2006-11-15-branchpoint:1.4
	insight_6_5-20061003-release:1.4
	gdb-csl-symbian-6_4_50_20060226-12:1.4
	gdb-csl-sourcerygxx-3_4_4-25:1.4
	nickrob-async-20060828-mergepoint:1.4
	gdb-csl-symbian-6_4_50_20060226-11:1.4
	gdb-csl-sourcerygxx-4_1-17:1.4
	gdb-csl-20060226-branch-local-2:1.4
	gdb-csl-sourcerygxx-4_1-14:1.4
	gdb-csl-sourcerygxx-4_1-13:1.4
	gdb-csl-sourcerygxx-4_1-12:1.4
	gdb-csl-sourcerygxx-3_4_4-21:1.4
	gdb_6_5-20060621-release:1.4
	gdb-csl-sourcerygxx-4_1-9:1.4
	gdb-csl-sourcerygxx-4_1-8:1.4
	gdb-csl-sourcerygxx-4_1-7:1.4
	gdb-csl-arm-2006q1-6:1.4
	gdb-csl-sourcerygxx-4_1-6:1.4
	gdb-csl-symbian-6_4_50_20060226-10:1.4
	gdb-csl-symbian-6_4_50_20060226-9:1.4
	gdb-csl-symbian-6_4_50_20060226-8:1.4
	gdb-csl-coldfire-4_1-11:1.4
	gdb-csl-sourcerygxx-3_4_4-19:1.4
	gdb-csl-coldfire-4_1-10:1.4
	gdb_6_5-branch:1.4.0.46
	gdb_6_5-2006-05-14-branchpoint:1.4
	gdb-csl-sourcerygxx-4_1-5:1.4
	nickrob-async-20060513-branch:1.4.0.44
	nickrob-async-20060513-branchpoint:1.4
	gdb-csl-sourcerygxx-4_1-4:1.4
	msnyder-reverse-20060502-branch:1.4.0.42
	msnyder-reverse-20060502-branchpoint:1.4
	gdb-csl-morpho-4_1-4:1.4
	gdb-csl-sourcerygxx-3_4_4-17:1.4
	readline_5_1-import-branch:1.4.0.40
	readline_5_1-import-branchpoint:1.4
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.4
	gdb-csl-symbian-20060226-branch:1.4.0.38
	gdb-csl-symbian-20060226-branchpoint:1.4
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.4
	msnyder-reverse-20060331-branch:1.4.0.36
	msnyder-reverse-20060331-branchpoint:1.4
	gdb-csl-available-20060303-branch:1.4.0.34
	gdb-csl-available-20060303-branchpoint:1.4
	gdb-csl-20060226-branch:1.4.0.32
	gdb-csl-20060226-branchpoint:1.4
	gdb_6_4-20051202-release:1.4
	msnyder-fork-checkpoint-branch:1.4.0.30
	msnyder-fork-checkpoint-branchpoint:1.4
	gdb-csl-gxxpro-6_3-branch:1.4.0.28
	gdb-csl-gxxpro-6_3-branchpoint:1.4
	gdb_6_4-branch:1.4.0.26
	gdb_6_4-2005-11-01-branchpoint:1.4
	gdb-csl-arm-20051020-branch:1.4.0.24
	gdb-csl-arm-20051020-branchpoint:1.4
	msnyder-tracepoint-checkpoint-branch:1.4.0.22
	msnyder-tracepoint-checkpoint-branchpoint:1.4
	gdb-csl-arm-20050325-2005-q1b:1.4
	gdb-csl-arm-20050325-2005-q1a:1.4
	csl-arm-20050325-branch:1.4.0.20
	csl-arm-20050325-branchpoint:1.4
	gdb_6_3-20041109-release:1.4
	gdb_6_3-branch:1.4.0.16
	gdb_6_3-20041019-branchpoint:1.4
	drow_intercu-merge-20040921:1.4
	drow_intercu-merge-20040915:1.4
	jimb-gdb_6_2-e500-branch:1.4.0.18
	jimb-gdb_6_2-e500-branchpoint:1.4
	gdb_6_2-20040730-release:1.4
	gdb_6_2-branch:1.4.0.14
	gdb_6_2-2004-07-10-gmt-branchpoint:1.4
	gdb_6_1_1-20040616-release:1.4
	gdb_6_1-2004-04-05-release:1.4
	drow_intercu-merge-20040402:1.4
	drow_intercu-merge-20040327:1.4
	ezannoni_pie-20040323-branch:1.4.0.12
	ezannoni_pie-20040323-branchpoint:1.4
	cagney_tramp-20040321-mergepoint:1.4
	cagney_tramp-20040309-branch:1.4.0.10
	cagney_tramp-20040309-branchpoint:1.4
	gdb_6_1-branch:1.4.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.4
	drow_intercu-20040221-branch:1.4.0.6
	drow_intercu-20040221-branchpoint:1.4
	cagney_bfdfile-20040213-branch:1.4.0.4
	cagney_bfdfile-20040213-branchpoint:1.4
	drow-cplus-merge-20040208:1.4
	carlton_dictionary-20040126-merge:1.4
	cagney_bigcore-20040122-branch:1.4.0.2
	cagney_bigcore-20040122-branchpoint:1.4
	drow-cplus-merge-20040113:1.4
	drow-cplus-merge-20031224:1.4
	drow-cplus-merge-20031220:1.4
	carlton_dictionary-20031215-merge:1.3
	drow-cplus-merge-20031214:1.3
	carlton-dictionary-20031111-merge:1.3
	gdb_6_0-2003-10-04-release:1.3
	kettenis_sparc-20030918-branch:1.3.0.40
	kettenis_sparc-20030918-branchpoint:1.3
	carlton_dictionary-20030917-merge:1.3
	ezannoni_pie-20030916-branchpoint:1.3
	ezannoni_pie-20030916-branch:1.3.0.38
	cagney_x86i386-20030821-branch:1.3.0.36
	cagney_x86i386-20030821-branchpoint:1.3
	carlton_dictionary-20030805-merge:1.3
	carlton_dictionary-20030627-merge:1.3
	gdb_6_0-branch:1.3.0.34
	gdb_6_0-2003-06-23-branchpoint:1.3
	jimb-ppc64-linux-20030613-branch:1.3.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.3
	cagney_convert-20030606-branch:1.3.0.30
	cagney_convert-20030606-branchpoint:1.3
	cagney_writestrings-20030508-branch:1.3.0.28
	cagney_writestrings-20030508-branchpoint:1.3
	jimb-ppc64-linux-20030528-branch:1.3.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.3
	carlton_dictionary-20030523-merge:1.3
	cagney_fileio-20030521-branch:1.3.0.24
	cagney_fileio-20030521-branchpoint:1.3
	kettenis_i386newframe-20030517-mergepoint:1.3
	jimb-ppc64-linux-20030509-branch:1.3.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.3
	kettenis_i386newframe-20030504-mergepoint:1.3
	carlton_dictionary-20030430-merge:1.3
	kettenis_i386newframe-20030419-branch:1.3.0.20
	kettenis_i386newframe-20030419-branchpoint:1.3
	carlton_dictionary-20030416-merge:1.3
	cagney_frameaddr-20030409-mergepoint:1.3
	kettenis_i386newframe-20030406-branch:1.3.0.18
	kettenis_i386newframe-20030406-branchpoint:1.3
	cagney_frameaddr-20030403-branchpoint:1.3
	cagney_frameaddr-20030403-branch:1.3.0.16
	cagney_framebase-20030330-mergepoint:1.3
	cagney_framebase-20030326-branch:1.3.0.14
	cagney_framebase-20030326-branchpoint:1.3
	cagney_lazyid-20030317-branch:1.3.0.12
	cagney_lazyid-20030317-branchpoint:1.3
	kettenis-i386newframe-20030316-mergepoint:1.3
	offbyone-20030313-branch:1.3.0.10
	offbyone-20030313-branchpoint:1.3
	kettenis-i386newframe-20030308-branch:1.3.0.8
	kettenis-i386newframe-20030308-branchpoint:1.3
	carlton_dictionary-20030305-merge:1.3
	cagney_offbyone-20030303-branch:1.3.0.6
	cagney_offbyone-20030303-branchpoint:1.3
	carlton_dictionary-20030207-merge:1.3
	interps-20030202-branch:1.3.0.4
	interps-20030202-branchpoint:1.3
	cagney-unwind-20030108-branch:1.3.0.2
	cagney-unwind-20030108-branchpoint:1.3
	carlton_dictionary-20021223-merge:1.3
	gdb_5_3-2002-12-12-release:1.2.20.1
	carlton_dictionary-20021115-merge:1.2
	kseitz_interps-20021105-merge:1.2
	kseitz_interps-20021103-merge:1.2
	drow-cplus-merge-20021020:1.2
	drow-cplus-merge-20021025:1.2
	carlton_dictionary-20021025-merge:1.2
	carlton_dictionary-20021011-merge:1.2
	drow-cplus-branch:1.2.0.24
	drow-cplus-branchpoint:1.2
	kseitz_interps-20020930-merge:1.2
	carlton_dictionary-20020927-merge:1.2
	carlton_dictionary-branch:1.2.0.22
	carlton_dictionary-20020920-branchpoint:1.2
	gdb_5_3-branch:1.2.0.20
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.18
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.16
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.14
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.12
	cagney_regbuf-20020515-branchpoint:1.2
	jimb-macro-020506-branch:1.2.0.10
	jimb-macro-020506-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.8
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.2
	gdb_5_1_0_1-2002-01-03-release:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.4
	gdb_s390-2001-09-26-branchpoint:1.2
	gdb_5_1-2001-07-29-branch:1.2.0.2
	gdb_5_1-2001-07-29-branchpoint:1.2
	insight-precleanup-2001-01-01:1.1.1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.17
date	2013.01.01.06.41.33;	author brobecke;	state Exp;
branches;
next	1.16;

1.16
date	2012.01.04.08.28.06;	author brobecke;	state Exp;
branches;
next	1.15;

1.15
date	2011.05.11.20.02.42;	author vapier;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2011.03.15.03.16.17;	author vapier;	state Exp;
branches;
next	1.13;

1.13
date	2011.02.14.05.14.26;	author vapier;	state Exp;
branches;
next	1.12;

1.12
date	2011.01.01.15.33.56;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2010.11.23.02.45.29;	author vapier;	state Exp;
branches;
next	1.10;

1.10
date	2010.03.30.20.40.27;	author vapier;	state Exp;
branches;
next	1.9;

1.9
date	2010.01.01.10.03.27;	author brobecke;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.14.10.53.06;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2008.01.01.22.53.23;	author drow;	state Exp;
branches;
next	1.6;

1.6
date	2007.08.24.14.28.35;	author brobecke;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.09.17.59.16;	author drow;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.19.11.43.56;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.23.01.12.05;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.16.03.20.26;	author fche;	state Exp;
branches
	1.2.20.1
	1.2.22.1
	1.2.24.1;
next	1.1;

1.1
date	99.04.16.01.34.57;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.15.2.1
date	2012.01.06.04.54.39;	author brobecke;	state Exp;
branches;
next	;

1.2.20.1
date	2002.11.23.01.12.34;	author cagney;	state Exp;
branches;
next	;

1.2.22.1
date	2002.12.23.19.39.52;	author carlton;	state Exp;
branches;
next	1.2.22.2;

1.2.22.2
date	2004.01.26.19.11.53;	author carlton;	state Exp;
branches;
next	;

1.2.24.1
date	2003.12.14.20.28.19;	author drow;	state Exp;
branches;
next	1.2.24.2;

1.2.24.2
date	2003.12.20.18.16.52;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.57;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.31.37;	author shebs;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* The common simulator framework for GDB, the GNU Debugger.

   Copyright 2002-2013 Free Software Foundation, Inc.

   Contributed by Andrew Cagney and Red Hat.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */


#ifndef SIM_CORE_C
#define SIM_CORE_C

#include "sim-main.h"
#include "sim-assert.h"

#if (WITH_HW)
#include "sim-hw.h"
#define device_error(client, ...) device_error ((device *)(client), __VA_ARGS__)
#define device_io_read_buffer(client, ...) device_io_read_buffer ((device *)(client), __VA_ARGS__)
#define device_io_write_buffer(client, ...) device_io_write_buffer ((device *)(client), __VA_ARGS__)
#endif

/* "core" module install handler.

   This is called via sim_module_install to install the "core"
   subsystem into the simulator.  */

#if EXTERN_SIM_CORE_P
static MODULE_INIT_FN sim_core_init;
static MODULE_UNINSTALL_FN sim_core_uninstall;
#endif

#if EXTERN_SIM_CORE_P
SIM_RC
sim_core_install (SIM_DESC sd)
{
  SIM_ASSERT (STATE_MAGIC (sd) == SIM_MAGIC_NUMBER);

  /* establish the other handlers */
  sim_module_add_uninstall_fn (sd, sim_core_uninstall);
  sim_module_add_init_fn (sd, sim_core_init);

  /* establish any initial data structures - none */
  return SIM_RC_OK;
}
#endif


/* Uninstall the "core" subsystem from the simulator.  */

#if EXTERN_SIM_CORE_P
static void
sim_core_uninstall (SIM_DESC sd)
{
  sim_core *core = STATE_CORE (sd);
  unsigned map;
  /* blow away any mappings */
  for (map = 0; map < nr_maps; map++) {
    sim_core_mapping *curr = core->common.map[map].first;
    while (curr != NULL) {
      sim_core_mapping *tbd = curr;
      curr = curr->next;
      if (tbd->free_buffer != NULL) {
	SIM_ASSERT (tbd->buffer != NULL);
	free (tbd->free_buffer);
      }
      free (tbd);
    }
    core->common.map[map].first = NULL;
  }
}
#endif


#if EXTERN_SIM_CORE_P
static SIM_RC
sim_core_init (SIM_DESC sd)
{
  /* Nothing to do */
  return SIM_RC_OK;
}
#endif



#ifndef SIM_CORE_SIGNAL
#define SIM_CORE_SIGNAL(SD,CPU,CIA,MAP,NR_BYTES,ADDR,TRANSFER,ERROR) \
sim_core_signal ((SD), (CPU), (CIA), (MAP), (NR_BYTES), (ADDR), (TRANSFER), (ERROR))
#endif

#if EXTERN_SIM_CORE_P
void
sim_core_signal (SIM_DESC sd,
		 sim_cpu *cpu,
		 sim_cia cia,
		 unsigned map,
		 int nr_bytes,
		 address_word addr,
		 transfer_type transfer,
		 sim_core_signals sig)
{
  const char *copy = (transfer == read_transfer ? "read" : "write");
  address_word ip = CIA_ADDR (cia);
  switch (sig)
    {
    case sim_core_unmapped_signal:
      sim_io_eprintf (sd, "core: %d byte %s to unmapped address 0x%lx at 0x%lx\n",
		      nr_bytes, copy, (unsigned long) addr, (unsigned long) ip);
      sim_engine_halt (sd, cpu, NULL, cia, sim_stopped, SIM_SIGSEGV);
      break;
    case sim_core_unaligned_signal:
      sim_io_eprintf (sd, "core: %d byte misaligned %s to address 0x%lx at 0x%lx\n",
		      nr_bytes, copy, (unsigned long) addr, (unsigned long) ip);
      sim_engine_halt (sd, cpu, NULL, cia, sim_stopped, SIM_SIGBUS);
      break;
    default:
      sim_engine_abort (sd, cpu, cia,
			"sim_core_signal - internal error - bad switch");
    }
}
#endif


#if EXTERN_SIM_CORE_P
static sim_core_mapping *
new_sim_core_mapping (SIM_DESC sd,
		      int level,
		      int space,
		      address_word addr,
		      address_word nr_bytes,
		      unsigned modulo,
#if WITH_HW
		      struct hw *device,
#else
		      device *device,
#endif
		      void *buffer,
		      void *free_buffer)
{
  sim_core_mapping *new_mapping = ZALLOC (sim_core_mapping);
  /* common */
  new_mapping->level = level;
  new_mapping->space = space;
  new_mapping->base = addr;
  new_mapping->nr_bytes = nr_bytes;
  new_mapping->bound = addr + (nr_bytes - 1);
  if (modulo == 0)
    new_mapping->mask = (unsigned) 0 - 1;
  else
    new_mapping->mask = modulo - 1;
  new_mapping->buffer = buffer;
  new_mapping->free_buffer = free_buffer;
  new_mapping->device = device;
  return new_mapping;
}
#endif


#if EXTERN_SIM_CORE_P
static void
sim_core_map_attach (SIM_DESC sd,
		     sim_core_map *access_map,
		     int level,
		     int space,
		     address_word addr,
		     address_word nr_bytes,
		     unsigned modulo,
#if WITH_HW
		     struct hw *client, /*callback/default*/
#else
		     device *client, /*callback/default*/
#endif
		     void *buffer, /*raw_memory*/
		     void *free_buffer) /*raw_memory*/
{
  /* find the insertion point for this additional mapping and then
     insert */
  sim_core_mapping *next_mapping;
  sim_core_mapping **last_mapping;

  SIM_ASSERT ((client == NULL) != (buffer == NULL));
  SIM_ASSERT ((client == NULL) >= (free_buffer != NULL));

  /* actually do occasionally get a zero size map */
  if (nr_bytes == 0)
    {
#if (WITH_DEVICES)
      device_error (client, "called on sim_core_map_attach with size zero");
#endif
#if (WITH_HW)
      sim_hw_abort (sd, client, "called on sim_core_map_attach with size zero");
#endif
      sim_io_error (sd, "called on sim_core_map_attach with size zero");
    }

  /* find the insertion point (between last/next) */
  next_mapping = access_map->first;
  last_mapping = &access_map->first;
  while (next_mapping != NULL
	&& (next_mapping->level < level
	    || (next_mapping->level == level
		&& next_mapping->bound < addr)))
    {
      /* provided levels are the same */
      /* assert: next_mapping->base > all bases before next_mapping */
      /* assert: next_mapping->bound >= all bounds before next_mapping */
      last_mapping = &next_mapping->next;
      next_mapping = next_mapping->next;
    }

  /* check insertion point correct */
  SIM_ASSERT (next_mapping == NULL || next_mapping->level >= level);
  if (next_mapping != NULL && next_mapping->level == level
      && next_mapping->base < (addr + (nr_bytes - 1)))
    {
#if (WITH_DEVICES)
      device_error (client, "memory map %d:0x%lx..0x%lx (%ld bytes) overlaps %d:0x%lx..0x%lx (%ld bytes)",
		    space,
		    (long) addr,
		    (long) (addr + nr_bytes - 1),
		    (long) nr_bytes,
		    next_mapping->space,
		    (long) next_mapping->base,
		    (long) next_mapping->bound,
		    (long) next_mapping->nr_bytes);
#endif
#if WITH_HW
      sim_hw_abort (sd, client, "memory map %d:0x%lx..0x%lx (%ld bytes) overlaps %d:0x%lx..0x%lx (%ld bytes)",
		    space,
		    (long) addr,
		    (long) (addr + (nr_bytes - 1)),
		    (long) nr_bytes,
		    next_mapping->space,
		    (long) next_mapping->base,
		    (long) next_mapping->bound,
		    (long) next_mapping->nr_bytes);
#endif
      sim_io_error (sd, "memory map %d:0x%lx..0x%lx (%ld bytes) overlaps %d:0x%lx..0x%lx (%ld bytes)",
		    space,
		    (long) addr,
		    (long) (addr + (nr_bytes - 1)),
		    (long) nr_bytes,
		    next_mapping->space,
		    (long) next_mapping->base,
		    (long) next_mapping->bound,
		    (long) next_mapping->nr_bytes);
  }

  /* create/insert the new mapping */
  *last_mapping = new_sim_core_mapping (sd,
					level,
					space, addr, nr_bytes, modulo,
					client, buffer, free_buffer);
  (*last_mapping)->next = next_mapping;
}
#endif


/* Attach memory or a memory mapped device to the simulator.
   See sim-core.h for a full description.  */

#if EXTERN_SIM_CORE_P
void
sim_core_attach (SIM_DESC sd,
		 sim_cpu *cpu,
		 int level,
		 unsigned mapmask,
		 int space,
		 address_word addr,
		 address_word nr_bytes,
		 unsigned modulo,
#if WITH_HW
		 struct hw *client,
#else
		 device *client,
#endif
		 void *optional_buffer)
{
  sim_core *memory = STATE_CORE (sd);
  unsigned map;
  void *buffer;
  void *free_buffer;

  /* check for for attempt to use unimplemented per-processor core map */
  if (cpu != NULL)
    sim_io_error (sd, "sim_core_map_attach - processor specific memory map not yet supported");

  /* verify modulo memory */
  if (!WITH_MODULO_MEMORY && modulo != 0)
    {
#if (WITH_DEVICES)
      device_error (client, "sim_core_attach - internal error - modulo memory disabled");
#endif
#if (WITH_HW)
      sim_hw_abort (sd, client, "sim_core_attach - internal error - modulo memory disabled");
#endif
      sim_io_error (sd, "sim_core_attach - internal error - modulo memory disabled");
    }
  if (client != NULL && modulo != 0)
    {
#if (WITH_DEVICES)
      device_error (client, "sim_core_attach - internal error - modulo and callback memory conflict");
#endif
#if (WITH_HW)
      sim_hw_abort (sd, client, "sim_core_attach - internal error - modulo and callback memory conflict");
#endif
      sim_io_error (sd, "sim_core_attach - internal error - modulo and callback memory conflict");
    }
  if (modulo != 0)
    {
      unsigned mask = modulo - 1;
      /* any zero bits */
      while (mask >= sizeof (unsigned64)) /* minimum modulo */
	{
	  if ((mask & 1) == 0)
	    mask = 0;
	  else
	    mask >>= 1;
	}
      if (mask != sizeof (unsigned64) - 1)
	{
#if (WITH_DEVICES)
	  device_error (client, "sim_core_attach - internal error - modulo %lx not power of two", (long) modulo);
#endif
#if (WITH_HW)
	  sim_hw_abort (sd, client, "sim_core_attach - internal error - modulo %lx not power of two", (long) modulo);
#endif
	  sim_io_error (sd, "sim_core_attach - internal error - modulo %lx not power of two", (long) modulo);
	}
    }

  /* verify consistency between device and buffer */
  if (client != NULL && optional_buffer != NULL)
    {
#if (WITH_DEVICES)
      device_error (client, "sim_core_attach - internal error - conflicting buffer and attach arguments");
#endif
#if (WITH_HW)
      sim_hw_abort (sd, client, "sim_core_attach - internal error - conflicting buffer and attach arguments");
#endif
      sim_io_error (sd, "sim_core_attach - internal error - conflicting buffer and attach arguments");
    }
  if (client == NULL)
    {
      if (optional_buffer == NULL)
	{
	  int padding = (addr % sizeof (unsigned64));
	  unsigned long bytes = (modulo == 0 ? nr_bytes : modulo) + padding;
	  free_buffer = zalloc (bytes);
	  buffer = (char*) free_buffer + padding;
	}
      else
	{
	  buffer = optional_buffer;
	  free_buffer = NULL;
	}
    }
  else
    {
      /* a device */
      buffer = NULL;
      free_buffer = NULL;
    }

  /* attach the region to all applicable access maps */
  for (map = 0;
       map < nr_maps;
       map++)
    {
      if (mapmask & (1 << map))
	{
	  sim_core_map_attach (sd, &memory->common.map[map],
			       level, space, addr, nr_bytes, modulo,
			       client, buffer, free_buffer);
	  free_buffer = NULL;
	}
    }

  /* Just copy this map to each of the processor specific data structures.
     FIXME - later this will be replaced by true processor specific
     maps. */
  {
    int i;
    for (i = 0; i < MAX_NR_PROCESSORS; i++)
      {
	CPU_CORE (STATE_CPU (sd, i))->common = STATE_CORE (sd)->common;
      }
  }
}
#endif


/* Remove any memory reference related to this address */
#if EXTERN_SIM_CORE_P
static void
sim_core_map_detach (SIM_DESC sd,
		     sim_core_map *access_map,
		     int level,
		     int space,
		     address_word addr)
{
  sim_core_mapping **entry;
  for (entry = &access_map->first;
       (*entry) != NULL;
       entry = &(*entry)->next)
    {
      if ((*entry)->base == addr
	  && (*entry)->level == level
	  && (*entry)->space == space)
	{
	  sim_core_mapping *dead = (*entry);
	  (*entry) = dead->next;
	  if (dead->free_buffer != NULL)
	    free (dead->free_buffer);
	  free (dead);
	  return;
	}
    }
}
#endif

#if EXTERN_SIM_CORE_P
void
sim_core_detach (SIM_DESC sd,
		 sim_cpu *cpu,
		 int level,
		 int address_space,
		 address_word addr)
{
  sim_core *memory = STATE_CORE (sd);
  unsigned map;
  for (map = 0; map < nr_maps; map++)
    {
      sim_core_map_detach (sd, &memory->common.map[map],
			   level, address_space, addr);
    }
  /* Just copy this update to each of the processor specific data
     structures.  FIXME - later this will be replaced by true
     processor specific maps. */
  {
    int i;
    for (i = 0; i < MAX_NR_PROCESSORS; i++)
      {
	CPU_CORE (STATE_CPU (sd, i))->common = STATE_CORE (sd)->common;
      }
  }
}
#endif


STATIC_INLINE_SIM_CORE\
(sim_core_mapping *)
sim_core_find_mapping (sim_core_common *core,
		       unsigned map,
		       address_word addr,
		       unsigned nr_bytes,
		       transfer_type transfer,
		       int abort, /*either 0 or 1 - hint to inline/-O */
		       sim_cpu *cpu, /* abort => cpu != NULL */
		       sim_cia cia)
{
  sim_core_mapping *mapping = core->map[map].first;
  ASSERT ((addr & (nr_bytes - 1)) == 0); /* must be aligned */
  ASSERT ((addr + (nr_bytes - 1)) >= addr); /* must not wrap */
  ASSERT (!abort || cpu != NULL); /* abort needs a non null CPU */
  while (mapping != NULL)
    {
      if (addr >= mapping->base
	  && (addr + (nr_bytes - 1)) <= mapping->bound)
	return mapping;
      mapping = mapping->next;
    }
  if (abort)
    {
      SIM_CORE_SIGNAL (CPU_STATE (cpu), cpu, cia, map, nr_bytes, addr, transfer,
		       sim_core_unmapped_signal);
    }
  return NULL;
}


STATIC_INLINE_SIM_CORE\
(void *)
sim_core_translate (sim_core_mapping *mapping,
		    address_word addr)
{
  if (WITH_MODULO_MEMORY)
    return (void *)((unsigned8 *) mapping->buffer
		    + ((addr - mapping->base) & mapping->mask));
  else
    return (void *)((unsigned8 *) mapping->buffer
		    + addr - mapping->base);
}


#if EXTERN_SIM_CORE_P
unsigned
sim_core_read_buffer (SIM_DESC sd,
		      sim_cpu *cpu,
		      unsigned map,
		      void *buffer,
		      address_word addr,
		      unsigned len)
{
  sim_core_common *core = (cpu == NULL ? &STATE_CORE (sd)->common : &CPU_CORE (cpu)->common);
  unsigned count = 0;
  while (count < len)
 {
    address_word raddr = addr + count;
    sim_core_mapping *mapping =
      sim_core_find_mapping (core, map,
			    raddr, /*nr-bytes*/1,
			    read_transfer,
			    0 /*dont-abort*/, NULL, NULL_CIA);
    if (mapping == NULL)
      break;
#if (WITH_DEVICES)
    if (mapping->device != NULL)
      {
	int nr_bytes = len - count;
	sim_cia cia = cpu ? CIA_GET (cpu) : NULL_CIA;
	if (raddr + nr_bytes - 1> mapping->bound)
	  nr_bytes = mapping->bound - raddr + 1;
	if (device_io_read_buffer (mapping->device,
				   (unsigned_1*)buffer + count,
				   mapping->space,
				   raddr,
				   nr_bytes,
				   sd,
				   cpu,
				   cia) != nr_bytes)
	  break;
	count += nr_bytes;
	continue;
      }
#endif
#if (WITH_HW)
    if (mapping->device != NULL)
      {
	int nr_bytes = len - count;
	if (raddr + nr_bytes - 1> mapping->bound)
	  nr_bytes = mapping->bound - raddr + 1;
	if (sim_hw_io_read_buffer (sd, mapping->device,
				   (unsigned_1*)buffer + count,
				   mapping->space,
				   raddr,
				   nr_bytes) != nr_bytes)
	  break;
	count += nr_bytes;
	continue;
      }
#endif
    ((unsigned_1*)buffer)[count] =
      *(unsigned_1*)sim_core_translate (mapping, raddr);
    count += 1;
 }
  return count;
}
#endif


#if EXTERN_SIM_CORE_P
unsigned
sim_core_write_buffer (SIM_DESC sd,
		       sim_cpu *cpu,
		       unsigned map,
		       const void *buffer,
		       address_word addr,
		       unsigned len)
{
  sim_core_common *core = (cpu == NULL ? &STATE_CORE (sd)->common : &CPU_CORE (cpu)->common);
  unsigned count = 0;
  while (count < len)
    {
      address_word raddr = addr + count;
      sim_core_mapping *mapping =
	sim_core_find_mapping (core, map,
			       raddr, /*nr-bytes*/1,
			       write_transfer,
			       0 /*dont-abort*/, NULL, NULL_CIA);
      if (mapping == NULL)
	break;
#if (WITH_DEVICES)
      if (WITH_CALLBACK_MEMORY
	  && mapping->device != NULL)
	{
	  int nr_bytes = len - count;
	  sim_cia cia = cpu ? CIA_GET (cpu) : NULL_CIA;
	  if (raddr + nr_bytes - 1 > mapping->bound)
	    nr_bytes = mapping->bound - raddr + 1;
	  if (device_io_write_buffer (mapping->device,
				      (unsigned_1*)buffer + count,
				      mapping->space,
				      raddr,
				      nr_bytes,
				      sd,
				      cpu,
				      cia) != nr_bytes)
	    break;
	  count += nr_bytes;
	  continue;
	}
#endif
#if (WITH_HW)
      if (WITH_CALLBACK_MEMORY
	  && mapping->device != NULL)
	{
	  int nr_bytes = len - count;
	  if (raddr + nr_bytes - 1 > mapping->bound)
	    nr_bytes = mapping->bound - raddr + 1;
	  if (sim_hw_io_write_buffer (sd, mapping->device,
				      (unsigned_1*)buffer + count,
				      mapping->space,
				      raddr,
				      nr_bytes) != nr_bytes)
	    break;
	  count += nr_bytes;
	  continue;
	}
#endif
      *(unsigned_1*)sim_core_translate (mapping, raddr) =
	((unsigned_1*)buffer)[count];
      count += 1;
    }
  return count;
}
#endif


#if EXTERN_SIM_CORE_P
void
sim_core_set_xor (SIM_DESC sd,
		  sim_cpu *cpu,
		  int is_xor)
{
  /* set up the XOR map if required. */
  if (WITH_XOR_ENDIAN) {
    {
      sim_core *core = STATE_CORE (sd);
      sim_cpu_core *cpu_core = (cpu != NULL ? CPU_CORE (cpu) : NULL);
      if (cpu_core != NULL)
	{
	  int i = 1;
	  unsigned mask;
	  if (is_xor)
	    mask = WITH_XOR_ENDIAN - 1;
	  else
	    mask = 0;
	  while (i - 1 < WITH_XOR_ENDIAN)
	    {
	      cpu_core->xor[i-1] = mask;
	      mask = (mask << 1) & (WITH_XOR_ENDIAN - 1);
	      i = (i << 1);
	    }
	}
      else
	{
	  if (is_xor)
	    core->byte_xor = WITH_XOR_ENDIAN - 1;
	  else
	    core->byte_xor = 0;
	}
    }
  }
  else {
    if (is_xor)
      sim_engine_abort (sd, NULL, NULL_CIA,
			"Attempted to enable xor-endian mode when permenantly disabled.");
  }
}
#endif


#if EXTERN_SIM_CORE_P
static void
reverse_n (unsigned_1 *dest,
	   const unsigned_1 *src,
	   int nr_bytes)
{
  int i;
  for (i = 0; i < nr_bytes; i++)
    {
      dest [nr_bytes - i - 1] = src [i];
    }
}
#endif


#if EXTERN_SIM_CORE_P
unsigned
sim_core_xor_read_buffer (SIM_DESC sd,
			  sim_cpu *cpu,
			  unsigned map,
			  void *buffer,
			  address_word addr,
			  unsigned nr_bytes)
{
  address_word byte_xor = (cpu == NULL ? STATE_CORE (sd)->byte_xor : CPU_CORE (cpu)->xor[0]);
  if (!WITH_XOR_ENDIAN || !byte_xor)
    return sim_core_read_buffer (sd, cpu, map, buffer, addr, nr_bytes);
  else
    /* only break up transfers when xor-endian is both selected and enabled */
    {
      unsigned_1 x[WITH_XOR_ENDIAN + 1]; /* +1 to avoid zero-sized array */
      unsigned nr_transfered = 0;
      address_word start = addr;
      unsigned nr_this_transfer = (WITH_XOR_ENDIAN - (addr & ~(WITH_XOR_ENDIAN - 1)));
      address_word stop;
      /* initial and intermediate transfers are broken when they cross
         an XOR endian boundary */
      while (nr_transfered + nr_this_transfer < nr_bytes)
	/* initial/intermediate transfers */
	{
	  /* since xor-endian is enabled stop^xor defines the start
             address of the transfer */
	  stop = start + nr_this_transfer - 1;
	  SIM_ASSERT (start <= stop);
	  SIM_ASSERT ((stop ^ byte_xor) <= (start ^ byte_xor));
	  if (sim_core_read_buffer (sd, cpu, map, x, stop ^ byte_xor, nr_this_transfer)
	      != nr_this_transfer)
	    return nr_transfered;
	  reverse_n (&((unsigned_1*)buffer)[nr_transfered], x, nr_this_transfer);
	  nr_transfered += nr_this_transfer;
	  nr_this_transfer = WITH_XOR_ENDIAN;
	  start = stop + 1;
	}
      /* final transfer */
      nr_this_transfer = nr_bytes - nr_transfered;
      stop = start + nr_this_transfer - 1;
      SIM_ASSERT (stop == (addr + nr_bytes - 1));
      if (sim_core_read_buffer (sd, cpu, map, x, stop ^ byte_xor, nr_this_transfer)
	  != nr_this_transfer)
	return nr_transfered;
      reverse_n (&((unsigned_1*)buffer)[nr_transfered], x, nr_this_transfer);
      return nr_bytes;
    }
}
#endif


#if EXTERN_SIM_CORE_P
unsigned
sim_core_xor_write_buffer (SIM_DESC sd,
			   sim_cpu *cpu,
			   unsigned map,
			   const void *buffer,
			   address_word addr,
			   unsigned nr_bytes)
{
  address_word byte_xor = (cpu == NULL ? STATE_CORE (sd)->byte_xor : CPU_CORE (cpu)->xor[0]);
  if (!WITH_XOR_ENDIAN || !byte_xor)
    return sim_core_write_buffer (sd, cpu, map, buffer, addr, nr_bytes);
  else
    /* only break up transfers when xor-endian is both selected and enabled */
    {
      unsigned_1 x[WITH_XOR_ENDIAN + 1]; /* +1 to avoid zero sized array */
      unsigned nr_transfered = 0;
      address_word start = addr;
      unsigned nr_this_transfer = (WITH_XOR_ENDIAN - (addr & ~(WITH_XOR_ENDIAN - 1)));
      address_word stop;
      /* initial and intermediate transfers are broken when they cross
         an XOR endian boundary */
      while (nr_transfered + nr_this_transfer < nr_bytes)
	/* initial/intermediate transfers */
	{
	  /* since xor-endian is enabled stop^xor defines the start
             address of the transfer */
	  stop = start + nr_this_transfer - 1;
	  SIM_ASSERT (start <= stop);
	  SIM_ASSERT ((stop ^ byte_xor) <= (start ^ byte_xor));
	  reverse_n (x, &((unsigned_1*)buffer)[nr_transfered], nr_this_transfer);
	  if (sim_core_read_buffer (sd, cpu, map, x, stop ^ byte_xor, nr_this_transfer)
	      != nr_this_transfer)
	    return nr_transfered;
	  nr_transfered += nr_this_transfer;
	  nr_this_transfer = WITH_XOR_ENDIAN;
	  start = stop + 1;
	}
      /* final transfer */
      nr_this_transfer = nr_bytes - nr_transfered;
      stop = start + nr_this_transfer - 1;
      SIM_ASSERT (stop == (addr + nr_bytes - 1));
      reverse_n (x, &((unsigned_1*)buffer)[nr_transfered], nr_this_transfer);
      if (sim_core_read_buffer (sd, cpu, map, x, stop ^ byte_xor, nr_this_transfer)
	  != nr_this_transfer)
	return nr_transfered;
      return nr_bytes;
    }
}
#endif

#if EXTERN_SIM_CORE_P
void *
sim_core_trans_addr (SIM_DESC sd,
                     sim_cpu *cpu,
                     unsigned map,
                     address_word addr)
{
  sim_core_common *core = (cpu == NULL ? &STATE_CORE (sd)->common : &CPU_CORE (cpu)->common);
  sim_core_mapping *mapping =
    sim_core_find_mapping (core, map,
                           addr, /*nr-bytes*/1,
                           write_transfer,
                           0 /*dont-abort*/, NULL, NULL_CIA);
  if (mapping == NULL)
    return NULL;
  return sim_core_translate (mapping, addr);
}
#endif



/* define the read/write 1/2/4/8/16/word functions */

#define N 16
#include "sim-n-core.h"

#define N 8
#include "sim-n-core.h"

#define N 7
#define M 8
#include "sim-n-core.h"

#define N 6
#define M 8
#include "sim-n-core.h"

#define N 5
#define M 8
#include "sim-n-core.h"

#define N 4
#include "sim-n-core.h"

#define N 3
#define M 4
#include "sim-n-core.h"

#define N 2
#include "sim-n-core.h"

#define N 1
#include "sim-n-core.h"

#endif
@


1.16
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright 2002, 2007-2012 Free Software Foundation, Inc.
@


1.15
log
@sim: fix func call style (space before paren)

Committed this as obvious:
	-foo(...);
	+foo (...);

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.15.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright 2002, 2007-2012 Free Software Foundation, Inc.
@


1.14
log
@sim: common: trim trailing whitespace
@
text
@d68 1
a68 1
  sim_core *core = STATE_CORE(sd);
d77 2
a78 2
	SIM_ASSERT(tbd->buffer != NULL);
	free(tbd->free_buffer);
d80 1
a80 1
      free(tbd);
d153 1
a153 1
  sim_core_mapping *new_mapping = ZALLOC(sim_core_mapping);
d201 1
a201 1
      device_error(client, "called on sim_core_map_attach with size zero");
d212 1
a212 1
  while(next_mapping != NULL
d263 4
a266 4
  *last_mapping = new_sim_core_mapping(sd,
				       level,
				       space, addr, nr_bytes, modulo,
				       client, buffer, free_buffer);
d292 1
a292 1
  sim_core *memory = STATE_CORE(sd);
d466 8
a473 8
sim_core_find_mapping(sim_core_common *core,
		      unsigned map,
		      address_word addr,
		      unsigned nr_bytes,
		      transfer_type transfer,
		      int abort, /*either 0 or 1 - hint to inline/-O */
		      sim_cpu *cpu, /* abort => cpu != NULL */
		      sim_cia cia)
d567 1
a567 1
      *(unsigned_1*)sim_core_translate(mapping, raddr);
d634 1
a634 1
      *(unsigned_1*)sim_core_translate(mapping, raddr) =
d820 1
a820 1
  return sim_core_translate(mapping, addr);
@


1.13
log
@sim: punt zfree()

The sim keeps track of which allocations are zero-ed internally (via
zalloc) and then calls a helper "zfree" function rather than "free".
But this "zfree" function simply calls "free" itself.  Since I can
see no point in this and it is simply useless overhead, punt it.

The only real change is in hw-alloc.c where we remove the zalloc_p
tracking, and sim-utils.c where zfree is delete.  The rest of the
changes are a simple `sed` from "zfree" to "free".

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d223 1
a223 1
  
d379 1
a379 1
  for (map = 0; 
d391 1
a391 1
  
d541 1
a541 1
				   nr_bytes, 
d543 1
a543 1
				   cpu, 
d610 1
a610 1
				      cpu, 
d675 1
a675 1
	}	  
d752 2
a753 2
  
  
@


1.12
log
@run copyright.sh for 2011.
@
text
@d78 1
a78 1
	zfree(tbd->free_buffer);
d80 1
a80 1
      zfree(tbd);
d427 2
a428 2
	    zfree (dead->free_buffer);
	  zfree (dead);
@


1.11
log
@sim: cast away hw/device differences

When building with device and hw support, the sim-core code generates a
lot of build time warnings such as:

./../common/sim-core.c: In function 'sim_core_map_attach':
./../common/sim-core.c:198:7: warning: passing argument 1 of 'device_error' from incompatible pointer type
../common/sim-core.h:347:6: note: expected 'struct device *' but argument is of type 'struct hw *'
./../common/sim-core.c:235:7: warning: passing argument 1 of 'device_error' from incompatible pointer type
../common/sim-core.h:347:6: note: expected 'struct device *' but argument is of type 'struct hw *'

In reality, these two structures get cast back and forth in the core
code already and so are "compatible".  So tweak the three functions
that generate all of these warnings to include the casts automatically.
I know this isn't exactly clean, but the current device/hw ifdef
approach is full of landmines itself and I'm not entirely sure how
to unscrew it.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.10
log
@sim: change raddr to address_word

The sim read/write buffer functions deal with address_word's, not
unsigned_words's, so make sure the local raddr variable matches
accordingly.
@
text
@d31 3
@


1.9
log
@Update copyright notices to add year 2010.
@
text
@d519 1
a519 1
    unsigned_word raddr = addr + count;
d585 1
a585 1
      unsigned_word raddr = addr + count;
@


1.8
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.7
log
@	Updated copyright notices for most files.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008 Free Software Foundation, Inc.
@


1.6
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d3 1
a3 1
   Copyright 2002, 2007 Free Software Foundation, Inc.
@


1.5
log
@Copyright updates for 2007.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.4
log
@Add support for m32r-linux target, including a RELA ABI and PIC.
@
text
@d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
@


1.3
log
@2002-11-22  Andrew Cagney  <ac131313@@redhat.com>

	* dv-core.c: Update copyright.  sim/common contributed to the FSF.
	* dv-glue.c, dv-pal.c, hw-base.c, hw-base.h, hw-device.c: Ditto.
	* hw-device.h, hw-handles.c, hw-handles.h: Ditto.
	* hw-instances.c, hw-instances.h, hw-properties.c: Ditto.
	* hw-properties.h, hw-tree.c, hw-tree.h, sim-alu.h: Ditto.
	* sim-basics.h, sim-bits.c, sim-bits.h, sim-config.c: Ditto.
	* sim-config.h, sim-core.c, sim-core.h, sim-endian.c: Ditto.
	* sim-endian.h, sim-events.c, sim-events.h, sim-inline.c: Ditto.
	* sim-inline.h, sim-io.c, sim-io.h, sim-n-bits.h: Ditto.
	* sim-n-core.h, sim-n-endian.h, sim-types.h: Ditto.
@
text
@d804 19
@


1.2
log
@* tweak

2001-03-15  Frank Ch. Eigler  <fche@@redhat.com>

	* sim-core.c (sim_core_map_attach): Correct overlap-related
	error messages.
@
text
@d1 1
a1 1
/*  This file is part of the program psim.
d3 1
a3 1
    Copyright (C) 1994-1997, Andrew Cagney <cagney@@highland.com.au>
d5 18
a22 15
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
    */
@


1.2.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1 1
a1 1
/* The common simulator framework for GDB, the GNU Debugger.
d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d5 15
a19 18
   Contributed by Andrew Cagney and Red Hat.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.2.24.2
log
@Merge from mainline.
@
text
@a803 19
#if EXTERN_SIM_CORE_P
void *
sim_core_trans_addr (SIM_DESC sd,
                     sim_cpu *cpu,
                     unsigned map,
                     address_word addr)
{
  sim_core_common *core = (cpu == NULL ? &STATE_CORE (sd)->common : &CPU_CORE (cpu)->common);
  sim_core_mapping *mapping =
    sim_core_find_mapping (core, map,
                           addr, /*nr-bytes*/1,
                           write_transfer,
                           0 /*dont-abort*/, NULL, NULL_CIA);
  if (mapping == NULL)
    return NULL;
  return sim_core_translate(mapping, addr);
}
#endif

@


1.2.22.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d1 1
a1 1
/* The common simulator framework for GDB, the GNU Debugger.
d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d5 15
a19 18
   Contributed by Andrew Cagney and Red Hat.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.2.22.2
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@a803 19
#if EXTERN_SIM_CORE_P
void *
sim_core_trans_addr (SIM_DESC sd,
                     sim_cpu *cpu,
                     unsigned map,
                     address_word addr)
{
  sim_core_common *core = (cpu == NULL ? &STATE_CORE (sd)->common : &CPU_CORE (cpu)->common);
  sim_core_mapping *mapping =
    sim_core_find_mapping (core, map,
                           addr, /*nr-bytes*/1,
                           write_transfer,
                           0 /*dont-abort*/, NULL, NULL_CIA);
  if (mapping == NULL)
    return NULL;
  return sim_core_translate(mapping, addr);
}
#endif

@


1.2.20.1
log
@2002-11-22  Andrew Cagney  <ac131313@@redhat.com>

	* dv-core.c: Update copyright.  sim/common contributed to the FSF.
	* dv-glue.c, dv-pal.c, hw-base.c, hw-base.h, hw-device.c: Ditto.
	* hw-device.h, hw-handles.c, hw-handles.h: Ditto.
	* hw-instances.c, hw-instances.h, hw-properties.c: Ditto.
	* hw-properties.h, hw-tree.c, hw-tree.h, sim-alu.h: Ditto.
	* sim-basics.h, sim-bits.c, sim-bits.h, sim-config.c: Ditto.
	* sim-config.h, sim-core.c, sim-core.h, sim-endian.c: Ditto.
	* sim-endian.h, sim-events.c, sim-events.h, sim-inline.c: Ditto.
	* sim-inline.h, sim-io.c, sim-io.h, sim-n-bits.h: Ditto.
	* sim-n-core.h, sim-n-endian.h, sim-types.h: Ditto.
@
text
@d1 1
a1 1
/* The common simulator framework for GDB, the GNU Debugger.
d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d5 15
a19 18
   Contributed by Andrew Cagney and Red Hat.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.1
log
@Initial revision
@
text
@a31 7
#if (WITH_DEVICES)
/* TODO: create sim/common/device.h */
void device_error (device *me, char* message, ...);
int device_io_read_buffer(device *me, void *dest, int space, address_word addr, unsigned nr_bytes, sim_cpu *processor, sim_cia cia);
int device_io_write_buffer(device *me, const void *source, int space, address_word addr, unsigned nr_bytes, sim_cpu *processor, sim_cia cia);
#endif

d229 1
a230 1
		    (long) (addr + (nr_bytes - 1)),
d240 1
a241 1
		    (long) (addr + (nr_bytes - 1)),
d250 1
a251 1
		    (long) (addr + (nr_bytes - 1)),
d530 1
d538 1
d540 1
a540 1
				   CIA_GET (cpu)) != nr_bytes)
d597 1
d605 1
d607 1
a607 1
				      CIA_GET(cpu)) != nr_bytes)
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d32 7
a536 1
	sim_cia cia = cpu ? CIA_GET (cpu) : NULL_CIA;
a543 1
				   sd,
d545 1
a545 1
				   cia) != nr_bytes)
a601 1
	  sim_cia cia = cpu ? CIA_GET (cpu) : NULL_CIA;
a608 1
				      sd,
d610 1
a610 1
				      cia) != nr_bytes)
@

