head	1.16;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.16
	gdb_7_6-2013-04-26-release:1.16
	gdb_7_6-branch:1.16.0.2
	gdb_7_6-2013-03-12-branchpoint:1.16
	gdb_7_5_1-2012-11-29-release:1.15
	gdb_7_5-2012-08-17-release:1.15
	gdb_7_5-branch:1.15.0.2
	gdb_7_5-2012-07-18-branchpoint:1.15
	gdb_7_4_1-2012-04-26-release:1.14.4.1
	gdb_7_4-2012-01-24-release:1.14.4.1
	gdb_7_4-branch:1.14.0.4
	gdb_7_4-2011-12-13-branchpoint:1.14
	gdb_7_3_1-2011-09-04-release:1.14
	gdb_7_3-2011-07-26-release:1.14
	gdb_7_3-branch:1.14.0.2
	gdb_7_3-2011-04-01-branchpoint:1.14
	gdb_7_2-2010-09-02-release:1.13
	gdb_7_2-branch:1.13.0.4
	gdb_7_2-2010-07-07-branchpoint:1.13
	gdb_7_1-2010-03-18-release:1.13
	gdb_7_1-branch:1.13.0.2
	gdb_7_1-2010-02-18-branchpoint:1.13
	gdb_7_0_1-2009-12-22-release:1.11
	gdb_7_0-2009-10-06-release:1.11
	gdb_7_0-branch:1.11.0.4
	gdb_7_0-2009-09-16-branchpoint:1.11
	arc-sim-20090309:1.9
	msnyder-checkpoint-072509-branch:1.11.0.2
	msnyder-checkpoint-072509-branchpoint:1.11
	arc-insight_6_8-branch:1.9.0.16
	arc-insight_6_8-branchpoint:1.9
	insight_6_8-branch:1.9.0.14
	insight_6_8-branchpoint:1.9
	reverse-20081226-branch:1.9.0.12
	reverse-20081226-branchpoint:1.9
	multiprocess-20081120-branch:1.9.0.10
	multiprocess-20081120-branchpoint:1.9
	reverse-20080930-branch:1.9.0.8
	reverse-20080930-branchpoint:1.9
	reverse-20080717-branch:1.9.0.6
	reverse-20080717-branchpoint:1.9
	msnyder-reverse-20080609-branch:1.9.0.4
	msnyder-reverse-20080609-branchpoint:1.9
	drow-reverse-20070409-branch:1.7.0.2
	drow-reverse-20070409-branchpoint:1.7
	gdb_6_8-2008-03-27-release:1.9
	gdb_6_8-branch:1.9.0.2
	gdb_6_8-2008-02-26-branchpoint:1.9
	gdb_6_7_1-2007-10-29-release:1.8
	gdb_6_7-2007-10-10-release:1.8
	gdb_6_7-branch:1.8.0.2
	gdb_6_7-2007-09-07-branchpoint:1.8
	insight_6_6-20070208-release:1.6
	gdb_6_6-2006-12-18-release:1.6
	gdb_6_6-branch:1.6.0.106
	gdb_6_6-2006-11-15-branchpoint:1.6
	insight_6_5-20061003-release:1.6
	gdb-csl-symbian-6_4_50_20060226-12:1.6
	gdb-csl-sourcerygxx-3_4_4-25:1.6
	nickrob-async-20060828-mergepoint:1.6
	gdb-csl-symbian-6_4_50_20060226-11:1.6
	gdb-csl-sourcerygxx-4_1-17:1.6
	gdb-csl-20060226-branch-local-2:1.6
	gdb-csl-sourcerygxx-4_1-14:1.6
	gdb-csl-sourcerygxx-4_1-13:1.6
	gdb-csl-sourcerygxx-4_1-12:1.6
	gdb-csl-sourcerygxx-3_4_4-21:1.6
	gdb_6_5-20060621-release:1.6
	gdb-csl-sourcerygxx-4_1-9:1.6
	gdb-csl-sourcerygxx-4_1-8:1.6
	gdb-csl-sourcerygxx-4_1-7:1.6
	gdb-csl-arm-2006q1-6:1.6
	gdb-csl-sourcerygxx-4_1-6:1.6
	gdb-csl-symbian-6_4_50_20060226-10:1.6
	gdb-csl-symbian-6_4_50_20060226-9:1.6
	gdb-csl-symbian-6_4_50_20060226-8:1.6
	gdb-csl-coldfire-4_1-11:1.6
	gdb-csl-sourcerygxx-3_4_4-19:1.6
	gdb-csl-coldfire-4_1-10:1.6
	gdb_6_5-branch:1.6.0.104
	gdb_6_5-2006-05-14-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-5:1.6
	nickrob-async-20060513-branch:1.6.0.102
	nickrob-async-20060513-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-4:1.6
	msnyder-reverse-20060502-branch:1.6.0.100
	msnyder-reverse-20060502-branchpoint:1.6
	gdb-csl-morpho-4_1-4:1.6
	gdb-csl-sourcerygxx-3_4_4-17:1.6
	readline_5_1-import-branch:1.6.0.98
	readline_5_1-import-branchpoint:1.6
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.6
	gdb-csl-symbian-20060226-branch:1.6.0.96
	gdb-csl-symbian-20060226-branchpoint:1.6
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.6
	msnyder-reverse-20060331-branch:1.6.0.94
	msnyder-reverse-20060331-branchpoint:1.6
	gdb-csl-available-20060303-branch:1.6.0.92
	gdb-csl-available-20060303-branchpoint:1.6
	gdb-csl-20060226-branch:1.6.0.90
	gdb-csl-20060226-branchpoint:1.6
	gdb_6_4-20051202-release:1.6
	msnyder-fork-checkpoint-branch:1.6.0.88
	msnyder-fork-checkpoint-branchpoint:1.6
	gdb-csl-gxxpro-6_3-branch:1.6.0.86
	gdb-csl-gxxpro-6_3-branchpoint:1.6
	gdb_6_4-branch:1.6.0.84
	gdb_6_4-2005-11-01-branchpoint:1.6
	gdb-csl-arm-20051020-branch:1.6.0.82
	gdb-csl-arm-20051020-branchpoint:1.6
	msnyder-tracepoint-checkpoint-branch:1.6.0.80
	msnyder-tracepoint-checkpoint-branchpoint:1.6
	gdb-csl-arm-20050325-2005-q1b:1.6
	gdb-csl-arm-20050325-2005-q1a:1.6
	csl-arm-20050325-branch:1.6.0.78
	csl-arm-20050325-branchpoint:1.6
	gdb_6_3-20041109-release:1.6
	gdb_6_3-branch:1.6.0.74
	gdb_6_3-20041019-branchpoint:1.6
	drow_intercu-merge-20040921:1.6
	drow_intercu-merge-20040915:1.6
	jimb-gdb_6_2-e500-branch:1.6.0.76
	jimb-gdb_6_2-e500-branchpoint:1.6
	gdb_6_2-20040730-release:1.6
	gdb_6_2-branch:1.6.0.72
	gdb_6_2-2004-07-10-gmt-branchpoint:1.6
	gdb_6_1_1-20040616-release:1.6
	gdb_6_1-2004-04-05-release:1.6
	drow_intercu-merge-20040402:1.6
	drow_intercu-merge-20040327:1.6
	ezannoni_pie-20040323-branch:1.6.0.70
	ezannoni_pie-20040323-branchpoint:1.6
	cagney_tramp-20040321-mergepoint:1.6
	cagney_tramp-20040309-branch:1.6.0.68
	cagney_tramp-20040309-branchpoint:1.6
	gdb_6_1-branch:1.6.0.66
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	drow_intercu-20040221-branch:1.6.0.64
	drow_intercu-20040221-branchpoint:1.6
	cagney_bfdfile-20040213-branch:1.6.0.62
	cagney_bfdfile-20040213-branchpoint:1.6
	drow-cplus-merge-20040208:1.6
	carlton_dictionary-20040126-merge:1.6
	cagney_bigcore-20040122-branch:1.6.0.60
	cagney_bigcore-20040122-branchpoint:1.6
	drow-cplus-merge-20040113:1.6
	drow-cplus-merge-20031224:1.6
	drow-cplus-merge-20031220:1.6
	carlton_dictionary-20031215-merge:1.6
	drow-cplus-merge-20031214:1.6
	carlton-dictionary-20031111-merge:1.6
	gdb_6_0-2003-10-04-release:1.6
	kettenis_sparc-20030918-branch:1.6.0.58
	kettenis_sparc-20030918-branchpoint:1.6
	carlton_dictionary-20030917-merge:1.6
	ezannoni_pie-20030916-branchpoint:1.6
	ezannoni_pie-20030916-branch:1.6.0.56
	cagney_x86i386-20030821-branch:1.6.0.54
	cagney_x86i386-20030821-branchpoint:1.6
	carlton_dictionary-20030805-merge:1.6
	carlton_dictionary-20030627-merge:1.6
	gdb_6_0-branch:1.6.0.52
	gdb_6_0-2003-06-23-branchpoint:1.6
	jimb-ppc64-linux-20030613-branch:1.6.0.50
	jimb-ppc64-linux-20030613-branchpoint:1.6
	cagney_convert-20030606-branch:1.6.0.48
	cagney_convert-20030606-branchpoint:1.6
	cagney_writestrings-20030508-branch:1.6.0.46
	cagney_writestrings-20030508-branchpoint:1.6
	jimb-ppc64-linux-20030528-branch:1.6.0.44
	jimb-ppc64-linux-20030528-branchpoint:1.6
	carlton_dictionary-20030523-merge:1.6
	cagney_fileio-20030521-branch:1.6.0.42
	cagney_fileio-20030521-branchpoint:1.6
	kettenis_i386newframe-20030517-mergepoint:1.6
	jimb-ppc64-linux-20030509-branch:1.6.0.40
	jimb-ppc64-linux-20030509-branchpoint:1.6
	kettenis_i386newframe-20030504-mergepoint:1.6
	carlton_dictionary-20030430-merge:1.6
	kettenis_i386newframe-20030419-branch:1.6.0.38
	kettenis_i386newframe-20030419-branchpoint:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	kettenis_i386newframe-20030406-branch:1.6.0.36
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.34
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.32
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.30
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.6
	offbyone-20030313-branch:1.6.0.28
	offbyone-20030313-branchpoint:1.6
	kettenis-i386newframe-20030308-branch:1.6.0.26
	kettenis-i386newframe-20030308-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.24
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.6
	interps-20030202-branch:1.6.0.22
	interps-20030202-branchpoint:1.6
	cagney-unwind-20030108-branch:1.6.0.20
	cagney-unwind-20030108-branchpoint:1.6
	carlton_dictionary-20021223-merge:1.6
	gdb_5_3-2002-12-12-release:1.6
	carlton_dictionary-20021115-merge:1.6
	kseitz_interps-20021105-merge:1.6
	kseitz_interps-20021103-merge:1.6
	drow-cplus-merge-20021020:1.6
	drow-cplus-merge-20021025:1.6
	carlton_dictionary-20021025-merge:1.6
	carlton_dictionary-20021011-merge:1.6
	drow-cplus-branch:1.6.0.18
	drow-cplus-branchpoint:1.6
	kseitz_interps-20020930-merge:1.6
	carlton_dictionary-20020927-merge:1.6
	carlton_dictionary-branch:1.6.0.16
	carlton_dictionary-20020920-branchpoint:1.6
	gdb_5_3-branch:1.6.0.14
	gdb_5_3-2002-09-04-branchpoint:1.6
	kseitz_interps-20020829-merge:1.6
	cagney_sysregs-20020825-branch:1.6.0.12
	cagney_sysregs-20020825-branchpoint:1.6
	readline_4_3-import-branch:1.6.0.10
	readline_4_3-import-branchpoint:1.6
	gdb_5_2_1-2002-07-23-release:1.6
	kseitz_interps-20020528-branch:1.6.0.8
	kseitz_interps-20020528-branchpoint:1.6
	cagney_regbuf-20020515-branch:1.6.0.6
	cagney_regbuf-20020515-branchpoint:1.6
	jimb-macro-020506-branch:1.6.0.4
	jimb-macro-020506-branchpoint:1.6
	gdb_5_2-2002-04-29-release:1.6
	gdb_5_2-branch:1.6.0.2
	gdb_5_2-2002-03-03-branchpoint:1.6
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.4
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.2
	gdb_5_1-2001-07-29-branchpoint:1.5
	insight-precleanup-2001-01-01:1.5
	gdb-premipsmulti-2000-06-06-branch:1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.6
	gdb-2000-02-04:1.1.1.6
	gdb-2000-02-02:1.1.1.6
	gdb-2000-02-01:1.1.1.6
	gdb-2000-01-31:1.1.1.6
	gdb-2000-01-26:1.1.1.6
	gdb-2000-01-24:1.1.1.5
	gdb-2000-01-17:1.1.1.4
	gdb-2000-01-10:1.1.1.4
	gdb-2000-01-05:1.1.1.4
	gdb-1999-12-21:1.1.1.4
	gdb-1999-12-13:1.1.1.4
	gdb-1999-12-07:1.1.1.4
	gdb-1999-12-06:1.1.1.4
	gdb-1999-11-16:1.1.1.4
	gdb-1999-11-08:1.1.1.4
	gdb-1999-11-01:1.1.1.4
	gdb-1999-10-25:1.1.1.4
	gdb-1999-10-18:1.1.1.4
	gdb-1999-10-11:1.1.1.4
	gdb-1999-10-04:1.1.1.4
	gdb-1999-09-28:1.1.1.4
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.3
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.16
date	2013.01.01.06.41.33;	author brobecke;	state Exp;
branches;
next	1.15;

1.15
date	2012.01.04.08.28.04;	author brobecke;	state Exp;
branches;
next	1.14;

1.14
date	2011.01.01.15.33.55;	author brobecke;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	2010.01.22.08.23.26;	author devans;	state Exp;
branches;
next	1.12;

1.12
date	2010.01.01.10.03.27;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.07.01.13.36;	author hp;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.07.01.12.51;	author hp;	state Exp;
branches;
next	1.9;

1.9
date	2008.01.01.22.53.23;	author drow;	state Exp;
branches;
next	1.8;

1.8
date	2007.08.24.14.28.35;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.09.17.59.16;	author drow;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.31.17.55.16;	author hp;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.11.07.14.34;	author bje;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.04.04.05.45;	author bje;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.19.22.27.14;	author bje;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.13.23.51.48;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.56;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.14.4.1
date	2012.01.06.04.54.38;	author brobecke;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.56;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.31.28;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.05.17.58.42;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.09.28.21.55.20;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.01.25.02.40.41;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.01.26.21.49.14;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* Semantics ops support for CGEN-based simulators.
   Copyright (C) 1996-2013 Free Software Foundation, Inc.
   Contributed by Cygnus Solutions.

This file is part of the GNU Simulators.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

#ifndef CGEN_SEM_OPS_H
#define CGEN_SEM_OPS_H

#include <assert.h>

#if defined (__GNUC__) && ! defined (SEMOPS_DEFINE_INLINE)
#define SEMOPS_DEFINE_INLINE
#define SEMOPS_INLINE extern inline
#else
#define SEMOPS_INLINE
#endif

/* Semantic operations.
   At one point this file was machine generated.  Maybe it will be again.  */

/* TODO: Lazy encoding/decoding of fp values.  */

/* These don't really have a mode.  */
#define ANDIF(x, y) ((x) && (y))
#define ORIF(x, y) ((x) || (y))

#define SUBBI(x, y) ((x) - (y))
#define ANDBI(x, y) ((x) & (y))
#define ORBI(x, y) ((x) | (y))
#define XORBI(x, y) ((x) ^ (y))
#define NEGBI(x) (- (x))
#define NOTBI(x) (! (BI) (x))
#define INVBI(x) (~ (x))
#define EQBI(x, y) ((BI) (x) == (BI) (y))
#define NEBI(x, y) ((BI) (x) != (BI) (y))
#define LTBI(x, y) ((BI) (x) < (BI) (y))
#define LEBI(x, y) ((BI) (x) <= (BI) (y))
#define GTBI(x, y) ((BI) (x) > (BI) (y))
#define GEBI(x, y) ((BI) (x) >= (BI) (y))
#define LTUBI(x, y) ((BI) (x) < (BI) (y))
#define LEUBI(x, y) ((BI) (x) <= (BI) (y))
#define GTUBI(x, y) ((BI) (x) > (BI) (y))
#define GEUBI(x, y) ((BI) (x) >= (BI) (y))

#define ADDQI(x, y) ((QI) ((UQI) (x) + (UQI) (y)))
#define SUBQI(x, y) ((QI) ((UQI) (x) - (UQI) (y)))
#define MULQI(x, y) ((QI) ((UQI) (x) * (UQI) (y)))
#define DIVQI(x, y) ((QI) (x) / (QI) (y))
#define UDIVQI(x, y) ((UQI) (x) / (UQI) (y))
#define MODQI(x, y) ((QI) (x) % (QI) (y))
#define UMODQI(x, y) ((UQI) (x) % (UQI) (y))
#define SRAQI(x, y) ((QI) (x) >> (y))
#define SRLQI(x, y) ((UQI) (x) >> (y))
#define SLLQI(x, y) ((UQI) (x) << (y))
extern QI RORQI (QI, int);
extern QI ROLQI (QI, int);
#define ANDQI(x, y) ((x) & (y))
#define ORQI(x, y) ((x) | (y))
#define XORQI(x, y) ((x) ^ (y))
#define NEGQI(x) ((QI) (- (UQI) (x)))
#define NOTQI(x) (! (QI) (x))
#define INVQI(x) (~ (x))
#define ABSQI(x) ((QI) ((QI) (x) < 0 ? -(UQI) (x) : (UQI) (x)))
#define EQQI(x, y) ((QI) (x) == (QI) (y))
#define NEQI(x, y) ((QI) (x) != (QI) (y))
#define LTQI(x, y) ((QI) (x) < (QI) (y))
#define LEQI(x, y) ((QI) (x) <= (QI) (y))
#define GTQI(x, y) ((QI) (x) > (QI) (y))
#define GEQI(x, y) ((QI) (x) >= (QI) (y))
#define LTUQI(x, y) ((UQI) (x) < (UQI) (y))
#define LEUQI(x, y) ((UQI) (x) <= (UQI) (y))
#define GTUQI(x, y) ((UQI) (x) > (UQI) (y))
#define GEUQI(x, y) ((UQI) (x) >= (UQI) (y))

#define ADDHI(x, y) ((HI) ((UHI) (x) + (UHI) (y)))
#define SUBHI(x, y) ((HI) ((UHI) (x) - (UHI) (y)))
#define MULHI(x, y) ((HI) ((UHI) (x) * (UHI) (y)))
#define DIVHI(x, y) ((HI) (x) / (HI) (y))
#define UDIVHI(x, y) ((UHI) (x) / (UHI) (y))
#define MODHI(x, y) ((HI) (x) % (HI) (y))
#define UMODHI(x, y) ((UHI) (x) % (UHI) (y))
#define SRAHI(x, y) ((HI) (x) >> (y))
#define SRLHI(x, y) ((UHI) (x) >> (y))
#define SLLHI(x, y) ((UHI) (x) << (y))
extern HI RORHI (HI, int);
extern HI ROLHI (HI, int);
#define ANDHI(x, y) ((x) & (y))
#define ORHI(x, y) ((x) | (y))
#define XORHI(x, y) ((x) ^ (y))
#define NEGHI(x) ((HI) (- (UHI) (x)))
#define NOTHI(x) (! (HI) (x))
#define INVHI(x) (~ (x))
#define ABSHI(x) ((HI) ((HI) (x) < 0 ? -(UHI) (x) : (UHI) (x)))
#define EQHI(x, y) ((HI) (x) == (HI) (y))
#define NEHI(x, y) ((HI) (x) != (HI) (y))
#define LTHI(x, y) ((HI) (x) < (HI) (y))
#define LEHI(x, y) ((HI) (x) <= (HI) (y))
#define GTHI(x, y) ((HI) (x) > (HI) (y))
#define GEHI(x, y) ((HI) (x) >= (HI) (y))
#define LTUHI(x, y) ((UHI) (x) < (UHI) (y))
#define LEUHI(x, y) ((UHI) (x) <= (UHI) (y))
#define GTUHI(x, y) ((UHI) (x) > (UHI) (y))
#define GEUHI(x, y) ((UHI) (x) >= (UHI) (y))

#define ADDSI(x, y) ((SI) ((USI) (x) + (USI) (y)))
#define SUBSI(x, y) ((SI) ((USI) (x) - (USI) (y)))
#define MULSI(x, y) ((SI) ((USI) (x) * (USI) (y)))
#define DIVSI(x, y) ((SI) (x) / (SI) (y))
#define UDIVSI(x, y) ((USI) (x) / (USI) (y))
#define MODSI(x, y) ((SI) (x) % (SI) (y))
#define UMODSI(x, y) ((USI) (x) % (USI) (y))
#define SRASI(x, y) ((SI) (x) >> (y))
#define SRLSI(x, y) ((USI) (x) >> (y))
#define SLLSI(x, y) ((USI) (x) << (y))
extern SI RORSI (SI, int);
extern SI ROLSI (SI, int);
#define ANDSI(x, y) ((x) & (y))
#define ORSI(x, y) ((x) | (y))
#define XORSI(x, y) ((x) ^ (y))
#define NEGSI(x) ((SI) (- (USI) (x)))
#define NOTSI(x) (! (SI) (x))
#define INVSI(x) (~ (x))
#define ABSSI(x) ((SI) ((SI) (x) < 0 ? -(USI) (x) : (USI) (x)))
#define EQSI(x, y) ((SI) (x) == (SI) (y))
#define NESI(x, y) ((SI) (x) != (SI) (y))
#define LTSI(x, y) ((SI) (x) < (SI) (y))
#define LESI(x, y) ((SI) (x) <= (SI) (y))
#define GTSI(x, y) ((SI) (x) > (SI) (y))
#define GESI(x, y) ((SI) (x) >= (SI) (y))
#define LTUSI(x, y) ((USI) (x) < (USI) (y))
#define LEUSI(x, y) ((USI) (x) <= (USI) (y))
#define GTUSI(x, y) ((USI) (x) > (USI) (y))
#define GEUSI(x, y) ((USI) (x) >= (USI) (y))

#ifdef DI_FN_SUPPORT
extern DI ADDDI (DI, DI);
extern DI SUBDI (DI, DI);
extern DI MULDI (DI, DI);
extern DI DIVDI (DI, DI);
extern DI UDIVDI (DI, DI);
extern DI MODDI (DI, DI);
extern DI UMODDI (DI, DI);
extern DI SRADI (DI, int);
extern UDI SRLDI (UDI, int);
extern UDI SLLDI (UDI, int);
extern DI RORDI (DI, int);
extern DI ROLDI (DI, int);
extern DI ANDDI (DI, DI);
extern DI ORDI (DI, DI);
extern DI XORDI (DI, DI);
extern DI NEGDI (DI);
extern int NOTDI (DI);
extern DI INVDI (DI);
extern int EQDI (DI, DI);
extern int NEDI (DI, DI);
extern int LTDI (DI, DI);
extern int LEDI (DI, DI);
extern int GTDI (DI, DI);
extern int GEDI (DI, DI);
extern int LTUDI (UDI, UDI);
extern int LEUDI (UDI, UDI);
extern int GTUDI (UDI, UDI);
extern int GEUDI (UDI, UDI);
#else /* ! DI_FN_SUPPORT */
#define ADDDI(x, y) ((DI) ((UDI) (x) + (UDI) (y)))
#define SUBDI(x, y) ((DI) ((UDI) (x) - (UDI) (y)))
#define MULDI(x, y) ((DI) ((UDI) (x) * (UDI) (y)))
#define DIVDI(x, y) ((DI) (x) / (DI) (y))
#define UDIVDI(x, y) ((UDI) (x) / (UDI) (y))
#define MODDI(x, y) ((DI) (x) % (DI) (y))
#define UMODDI(x, y) ((UDI) (x) % (UDI) (y))
#define SRADI(x, y) ((DI) (x) >> (y))
#define SRLDI(x, y) ((UDI) (x) >> (y))
#define SLLDI(x, y) ((UDI) (x) << (y))
extern DI RORDI (DI, int);
extern DI ROLDI (DI, int);
#define ANDDI(x, y) ((x) & (y))
#define ORDI(x, y) ((x) | (y))
#define XORDI(x, y) ((x) ^ (y))
#define NEGDI(x) ((DI) (- (UDI) (x)))
#define NOTDI(x) (! (DI) (x))
#define INVDI(x) (~ (x))
#define ABSDI(x) ((DI) ((DI) (x) < 0 ? -(UDI) (x) : (UDI) (x)))
#define EQDI(x, y) ((DI) (x) == (DI) (y))
#define NEDI(x, y) ((DI) (x) != (DI) (y))
#define LTDI(x, y) ((DI) (x) < (DI) (y))
#define LEDI(x, y) ((DI) (x) <= (DI) (y))
#define GTDI(x, y) ((DI) (x) > (DI) (y))
#define GEDI(x, y) ((DI) (x) >= (DI) (y))
#define LTUDI(x, y) ((UDI) (x) < (UDI) (y))
#define LEUDI(x, y) ((UDI) (x) <= (UDI) (y))
#define GTUDI(x, y) ((UDI) (x) > (UDI) (y))
#define GEUDI(x, y) ((UDI) (x) >= (UDI) (y))
#endif /* DI_FN_SUPPORT */

#define EXTBIQI(x) ((QI) (BI) (x))
#define EXTBIHI(x) ((HI) (BI) (x))
#define EXTBISI(x) ((SI) (BI) (x))
#if defined (DI_FN_SUPPORT)
extern DI EXTBIDI (BI);
#else
#define EXTBIDI(x) ((DI) (BI) (x))
#endif
#define EXTQIHI(x) ((HI) (QI) (x))
#define EXTQISI(x) ((SI) (QI) (x))
#if defined (DI_FN_SUPPORT)
extern DI EXTQIDI (QI);
#else
#define EXTQIDI(x) ((DI) (QI) (x))
#endif
#define EXTHIHI(x) ((HI) (HI) (x))
#define EXTHISI(x) ((SI) (HI) (x))
#define EXTSISI(x) ((SI) (SI) (x))
#if defined (DI_FN_SUPPORT)
extern DI EXTHIDI (HI);
#else
#define EXTHIDI(x) ((DI) (HI) (x))
#endif
#if defined (DI_FN_SUPPORT)
extern DI EXTSIDI (SI);
#else
#define EXTSIDI(x) ((DI) (SI) (x))
#endif

#define ZEXTBIQI(x) ((QI) (BI) (x))
#define ZEXTBIHI(x) ((HI) (BI) (x))
#define ZEXTBISI(x) ((SI) (BI) (x))
#if defined (DI_FN_SUPPORT)
extern DI ZEXTBIDI (BI);
#else
#define ZEXTBIDI(x) ((DI) (BI) (x))
#endif
#define ZEXTQIHI(x) ((HI) (UQI) (x))
#define ZEXTQISI(x) ((SI) (UQI) (x))
#if defined (DI_FN_SUPPORT)
extern DI ZEXTQIDI (QI);
#else
#define ZEXTQIDI(x) ((DI) (UQI) (x))
#endif
#define ZEXTHISI(x) ((SI) (UHI) (x))
#define ZEXTHIHI(x) ((HI) (UHI) (x))
#define ZEXTSISI(x) ((SI) (USI) (x))
#if defined (DI_FN_SUPPORT)
extern DI ZEXTHIDI (HI);
#else
#define ZEXTHIDI(x) ((DI) (UHI) (x))
#endif
#if defined (DI_FN_SUPPORT)
extern DI ZEXTSIDI (SI);
#else
#define ZEXTSIDI(x) ((DI) (USI) (x))
#endif

#define TRUNCQIBI(x) ((BI) (QI) (x))
#define TRUNCHIBI(x) ((BI) (HI) (x))
#define TRUNCHIQI(x) ((QI) (HI) (x))
#define TRUNCSIBI(x) ((BI) (SI) (x))
#define TRUNCSIQI(x) ((QI) (SI) (x))
#define TRUNCSIHI(x) ((HI) (SI) (x))
#define TRUNCSISI(x) ((SI) (SI) (x))
#if defined (DI_FN_SUPPORT)
extern BI TRUNCDIBI (DI);
#else
#define TRUNCDIBI(x) ((BI) (DI) (x))
#endif
#if defined (DI_FN_SUPPORT)
extern QI TRUNCDIQI (DI);
#else
#define TRUNCDIQI(x) ((QI) (DI) (x))
#endif
#if defined (DI_FN_SUPPORT)
extern HI TRUNCDIHI (DI);
#else
#define TRUNCDIHI(x) ((HI) (DI) (x))
#endif
#if defined (DI_FN_SUPPORT)
extern SI TRUNCDISI (DI);
#else
#define TRUNCDISI(x) ((SI) (DI) (x))
#endif

/* Composing/decomposing the various types.
   Word ordering is endian-independent.  Words are specified most to least
   significant and word number 0 is the most significant word.
   ??? May also wish an endian-dependent version.  Later.  */

#ifdef SEMOPS_DEFINE_INLINE

SEMOPS_INLINE SF
SUBWORDSISF (SI in)
{
  union { SI in; SF out; } x;
  x.in = in;
  return x.out;
}

SEMOPS_INLINE DF
SUBWORDDIDF (DI in)
{
  union { DI in; DF out; } x;
  x.in = in;
  return x.out;
}

SEMOPS_INLINE QI
SUBWORDSIQI (SI in, int byte)
{
  assert (byte >= 0 && byte <= 3);
  return (UQI) (in >> (8 * (3 - byte))) & 0xFF;
}

SEMOPS_INLINE UQI
SUBWORDSIUQI (SI in, int byte)
{
  assert (byte >= 0 && byte <= 3);
  return (UQI) (in >> (8 * (3 - byte))) & 0xFF;
}

SEMOPS_INLINE QI
SUBWORDDIQI (DI in, int byte)
{
  assert (byte >= 0 && byte <= 7);
  return (UQI) (in >> (8 * (7 - byte))) & 0xFF;
}

SEMOPS_INLINE HI
SUBWORDDIHI (DI in, int word)
{
  assert (word >= 0 && word <= 3);
  return (UHI) (in >> (16 * (3 - word))) & 0xFFFF;
}

SEMOPS_INLINE HI
SUBWORDSIHI (SI in, int word)
{
  if (word == 0)
    return (USI) in >> 16;
  else
    return in;
}

SEMOPS_INLINE SI
SUBWORDSFSI (SF in)
{
  union { SF in; SI out; } x;
  x.in = in;
  return x.out;
}

SEMOPS_INLINE DI
SUBWORDDFDI (DF in)
{
  union { DF in; DI out; } x;
  x.in = in;
  return x.out;
}

SEMOPS_INLINE UQI
SUBWORDDIUQI (DI in, int byte)
{
  assert (byte >= 0 && byte <= 7);
  return (UQI) (in >> (8 * (7 - byte)));
}

SEMOPS_INLINE SI
SUBWORDDISI (DI in, int word)
{
  if (word == 0)
    return (UDI) in >> 32;
  else
    return in;
}

SEMOPS_INLINE SI
SUBWORDDFSI (DF in, int word)
{
  /* Note: typedef UDI DF; */
  if (word == 0)
    return (UDI) in >> 32;
  else
    return in;
}

SEMOPS_INLINE SI
SUBWORDXFSI (XF in, int word)
{
  /* Note: typedef struct { SI parts[3]; } XF; */
  union { XF in; SI out[3]; } x;
  x.in = in;
  if (CURRENT_TARGET_BYTE_ORDER == BIG_ENDIAN)
    return x.out[word];
  else
    return x.out[2 - word];
}

SEMOPS_INLINE SI
SUBWORDTFSI (TF in, int word)
{
  /* Note: typedef struct { SI parts[4]; } TF; */
  union { TF in; SI out[4]; } x;
  x.in = in;
  if (CURRENT_TARGET_BYTE_ORDER == BIG_ENDIAN)
    return x.out[word];
  else
    return x.out[3 - word];
}

SEMOPS_INLINE DI
JOINSIDI (SI x0, SI x1)
{
  return MAKEDI (x0, x1);
}

SEMOPS_INLINE DF
JOINSIDF (SI x0, SI x1)
{
  union { SI in[2]; DF out; } x;
  if (CURRENT_TARGET_BYTE_ORDER == BIG_ENDIAN)
    x.in[0] = x0, x.in[1] = x1;
  else
    x.in[1] = x0, x.in[0] = x1;
  return x.out;
}

SEMOPS_INLINE XF
JOINSIXF (SI x0, SI x1, SI x2)
{
  union { SI in[3]; XF out; } x;
  if (CURRENT_TARGET_BYTE_ORDER == BIG_ENDIAN)
    x.in[0] = x0, x.in[1] = x1, x.in[2] = x2;
  else
    x.in[2] = x0, x.in[1] = x1, x.in[0] = x2;
  return x.out;
}

SEMOPS_INLINE TF
JOINSITF (SI x0, SI x1, SI x2, SI x3)
{
  union { SI in[4]; TF out; } x;
  if (CURRENT_TARGET_BYTE_ORDER == BIG_ENDIAN)
    x.in[0] = x0, x.in[1] = x1, x.in[2] = x2, x.in[3] = x3;
  else
    x.in[3] = x0, x.in[2] = x1, x.in[1] = x2, x.in[0] = x3;
  return x.out;
}

#else

QI SUBWORDSIQI (SI);
HI SUBWORDSIHI (HI);
SI SUBWORDSFSI (SF);
SF SUBWORDSISF (SI);
DI SUBWORDDFDI (DF);
DF SUBWORDDIDF (DI);
QI SUBWORDDIQI (DI, int);
HI SUBWORDDIHI (DI, int);
SI SUBWORDDISI (DI, int);
SI SUBWORDDFSI (DF, int);
SI SUBWORDXFSI (XF, int);
SI SUBWORDTFSI (TF, int);

UQI SUBWORDSIUQI (SI);
UQI SUBWORDDIUQI (DI);

DI JOINSIDI (SI, SI);
DF JOINSIDF (SI, SI);
XF JOINSIXF (SI, SI, SI);
TF JOINSITF (SI, SI, SI, SI);

#endif /* SUBWORD,JOIN */

/* Semantic support utilities.  */

#ifdef SEMOPS_DEFINE_INLINE

SEMOPS_INLINE SI
ADDCSI (SI a, SI b, BI c)
{
  SI res = ADDSI (a, ADDSI (b, c));
  return res;
}

SEMOPS_INLINE BI
ADDCFSI (SI a, SI b, BI c)
{
  SI tmp = ADDSI (a, ADDSI (b, c));
  BI res = ((USI) tmp < (USI) a) || (c && tmp == a);
  return res;
}

SEMOPS_INLINE BI
ADDOFSI (SI a, SI b, BI c)
{
  SI tmp = ADDSI (a, ADDSI (b, c));
  BI res = (((a < 0) == (b < 0))
	    && ((a < 0) != (tmp < 0)));
  return res;
}

SEMOPS_INLINE SI
SUBCSI (SI a, SI b, BI c)
{
  SI res = SUBSI (a, ADDSI (b, c));
  return res;
}

SEMOPS_INLINE BI
SUBCFSI (SI a, SI b, BI c)
{
  BI res = ((USI) a < (USI) b) || (c && a == b);
  return res;
}

SEMOPS_INLINE BI
SUBOFSI (SI a, SI b, BI c)
{
  SI tmp = SUBSI (a, ADDSI (b, c));
  BI res = (((a < 0) != (b < 0))
	    && ((a < 0) != (tmp < 0)));
  return res;
}

SEMOPS_INLINE HI
ADDCHI (HI a, HI b, BI c)
{
  HI res = ADDHI (a, ADDHI (b, c));
  return res;
}

SEMOPS_INLINE BI
ADDCFHI (HI a, HI b, BI c)
{
  HI tmp = ADDHI (a, ADDHI (b, c));
  BI res = ((UHI) tmp < (UHI) a) || (c && tmp == a);
  return res;
}

SEMOPS_INLINE BI
ADDOFHI (HI a, HI b, BI c)
{
  HI tmp = ADDHI (a, ADDHI (b, c));
  BI res = (((a < 0) == (b < 0))
	    && ((a < 0) != (tmp < 0)));
  return res;
}

SEMOPS_INLINE HI
SUBCHI (HI a, HI b, BI c)
{
  HI res = SUBHI (a, ADDHI (b, c));
  return res;
}

SEMOPS_INLINE BI
SUBCFHI (HI a, HI b, BI c)
{
  BI res = ((UHI) a < (UHI) b) || (c && a == b);
  return res;
}

SEMOPS_INLINE BI
SUBOFHI (HI a, HI b, BI c)
{
  HI tmp = SUBHI (a, ADDHI (b, c));
  BI res = (((a < 0) != (b < 0))
	    && ((a < 0) != (tmp < 0)));
  return res;
}

SEMOPS_INLINE QI
ADDCQI (QI a, QI b, BI c)
{
  QI res = ADDQI (a, ADDQI (b, c));
  return res;
}

SEMOPS_INLINE BI
ADDCFQI (QI a, QI b, BI c)
{
  QI tmp = ADDQI (a, ADDQI (b, c));
  BI res = ((UQI) tmp < (UQI) a) || (c && tmp == a);
  return res;
}

SEMOPS_INLINE BI
ADDOFQI (QI a, QI b, BI c)
{
  QI tmp = ADDQI (a, ADDQI (b, c));
  BI res = (((a < 0) == (b < 0))
	    && ((a < 0) != (tmp < 0)));
  return res;
}

SEMOPS_INLINE QI
SUBCQI (QI a, QI b, BI c)
{
  QI res = SUBQI (a, ADDQI (b, c));
  return res;
}

SEMOPS_INLINE BI
SUBCFQI (QI a, QI b, BI c)
{
  BI res = ((UQI) a < (UQI) b) || (c && a == b);
  return res;
}

SEMOPS_INLINE BI
SUBOFQI (QI a, QI b, BI c)
{
  QI tmp = SUBQI (a, ADDQI (b, c));
  BI res = (((a < 0) != (b < 0))
	    && ((a < 0) != (tmp < 0)));
  return res;
}

#else

SI ADDCSI (SI, SI, BI);
UBI ADDCFSI (SI, SI, BI);
UBI ADDOFSI (SI, SI, BI);
SI SUBCSI (SI, SI, BI);
UBI SUBCFSI (SI, SI, BI);
UBI SUBOFSI (SI, SI, BI);
HI ADDCHI (HI, HI, BI);
UBI ADDCFHI (HI, HI, BI);
UBI ADDOFHI (HI, HI, BI);
HI SUBCHI (HI, HI, BI);
UBI SUBCFHI (HI, HI, BI);
UBI SUBOFHI (HI, HI, BI);
QI ADDCQI (QI, QI, BI);
UBI ADDCFQI (QI, QI, BI);
UBI ADDOFQI (QI, QI, BI);
QI SUBCQI (QI, QI, BI);
UBI SUBCFQI (QI, QI, BI);
UBI SUBOFQI (QI, QI, BI);

#endif

#endif /* CGEN_SEM_OPS_H */
@


1.15
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 2
   Copyright (C) 1996-1999, 2002, 2007-2012 Free Software Foundation,
   Inc.
@


1.14
log
@run copyright.sh for 2011.
@
text
@d2 2
a3 2
   Copyright (C) 1996, 1997, 1998, 1999, 2002, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.14.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 2
   Copyright (C) 1996-1999, 2002, 2007-2012 Free Software Foundation,
   Inc.
@


1.13
log
@	* cgen-ops.h (SUBWORDXFSI): Fix word ordering.
	(SUBWORDTFSI, JOINSIDI): Ditto.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 1999, 2002, 2007, 2008, 2009, 2010
@


1.12
log
@Update copyright notices to add year 2010.
@
text
@d407 4
a410 1
  return x.out[word];
d419 4
a422 1
  return x.out[word];
d428 1
a428 4
  if (CURRENT_TARGET_BYTE_ORDER == BIG_ENDIAN)
    return MAKEDI (x0, x1);
  else
    return MAKEDI (x1, x0);
@


1.11
log
@	* cgen-ops.h (ADDQI, SUBQI, MULQI, NEGQI, ABSQI, ADDHI, SUBHI)
	(MULHI, NEGHI, ABSHI, ADDSI, SUBSI, MULSI, NEGSI, ABSSI, ADDDI)
	(SUBDI, MULDI, NEGDI, ABSDI): Cast arguments to the unsigned type
	variant; UQI, UHI, USI, UDI, and cast the result to the signed
	type, QI, HI, SI, DI.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 1999, 2002, 2007, 2008, 2009
@


1.10
log
@	* cgen-ops.h (ADDQI, SUBQI, MULQI, NEGQI, ABSQI, ADDHI, SUBHI)
	(MULHI, NEGHI, ABSHI, ADDSI, SUBSI, MULSI, NEGSI, ABSSI, ADDDI)
	(SUBDI, MULDI, NEGDI, ABSDI): Cast arguments to the unsigned type
	variant; UQI, UHI, USI, UDI, and cast the result to the signed
	type, QI, HI, SI, DI.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 1999, 2002, 2007, 2008
@


1.9
log
@	Updated copyright notices for most files.
@
text
@d62 3
a64 3
#define ADDQI(x, y) ((x) + (y))
#define SUBQI(x, y) ((x) - (y))
#define MULQI(x, y) ((x) * (y))
d77 1
a77 1
#define NEGQI(x) (- (x))
d80 1
a80 1
#define ABSQI(x) ((x) < 0 ? -(x) : (x))
d92 3
a94 3
#define ADDHI(x, y) ((x) + (y))
#define SUBHI(x, y) ((x) - (y))
#define MULHI(x, y) ((x) * (y))
d107 1
a107 1
#define NEGHI(x) (- (x))
d110 1
a110 1
#define ABSHI(x) ((x) < 0 ? -(x) : (x))
d122 3
a124 3
#define ADDSI(x, y) ((x) + (y))
#define SUBSI(x, y) ((x) - (y))
#define MULSI(x, y) ((x) * (y))
d137 1
a137 1
#define NEGSI(x) (- (x))
d140 1
a140 1
#define ABSSI(x) ((x) < 0 ? -(x) : (x))
d182 3
a184 3
#define ADDDI(x, y) ((x) + (y))
#define SUBDI(x, y) ((x) - (y))
#define MULDI(x, y) ((x) * (y))
d197 1
a197 1
#define NEGDI(x) (- (x))
d200 1
a200 1
#define ABSDI(x) ((x) < 0 ? -(x) : (x))
@


1.8
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 1999, 2002, 2007
@


1.7
log
@Copyright updates for 2007.
@
text
@d10 2
a11 2
the Free Software Foundation; either version 2, or (at your option)
any later version.
d18 2
a19 3
You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@


1.6
log
@	* cgen-ops.h (ADDCQI, ADDCFQI, ADDOFQI, SUBCQI, SUBCFQI, SUBOFQI):
	New functions.
@
text
@d2 2
a3 1
   Copyright (C) 1996, 1997, 1998, 1999, 2002 Free Software Foundation, Inc.
@


1.5
log
@2000-12-11  Ben Elliston  <bje@@redhat.com>

	* cgen-ops.h (SUBWORDDFDI): New function.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
d584 47
d645 6
@


1.4
log
@2000-12-04  Ben Elliston  <bje@@redhat.com>

	* cgen-ops.h (SUBWORDSIQI): Mask off top bits.
	(SUBWORDSIUQI): Likewise.
	(SUBWORDDIHI): Likewise.
	(SUBWORDDIQI): New function.
@
text
@d367 8
d467 1
@


1.3
log
@2000-11-20  Ben Elliston  <bje@@redhat.com>

	* cgen-ops.h (SUBBI): New macro.
	(SUBWORDSIQI, SUBWORDSIHI, SUBWORDSIUQI): New functions.
	(SUBWORDDIHI, SUBWORDDIUQI, SUBWORDDIDF): Likewise.
@
text
@d326 1
a326 1
  return (UQI) (in >> (8 * (3 - byte)));
d333 8
a340 1
  return (UQI) (in >> (8 * (3 - byte)));
d347 1
a347 1
  return (UHI) (in >> (16 * (3 - word)));
d460 1
@


1.2
log
@
2000-03-13  Jeff Johnston <jjohnstn@@cygnus.com>

        * cgen-ops.h: Added TRUNCSISI.
@
text
@d26 2
d44 1
d314 38
d360 7
d448 3
d452 2
a453 1
SI SUBWORDSFSI (SF);
d458 3
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
d26 7
d36 2
d58 1
a58 1

d69 2
a70 2
extern QI RORQI PARAMS ((QI, int));
extern QI ROLQI PARAMS ((QI, int));
d77 1
d88 1
a88 1

d99 2
a100 2
extern HI RORHI PARAMS ((HI, int));
extern HI ROLHI PARAMS ((HI, int));
d107 1
d118 1
a118 1

d129 2
a130 2
extern SI RORSI PARAMS ((SI, int));
extern SI ROLSI PARAMS ((SI, int));
d137 1
d148 1
a148 1

d150 28
a177 28
extern DI ADDDI PARAMS ((DI, DI));
extern DI SUBDI PARAMS ((DI, DI));
extern DI MULDI PARAMS ((DI, DI));
extern DI DIVDI PARAMS ((DI, DI));
extern DI UDIVDI PARAMS ((DI, DI));
extern DI MODDI PARAMS ((DI, DI));
extern DI UMODDI PARAMS ((DI, DI));
extern DI SRADI PARAMS ((DI, int));
extern UDI SRLDI PARAMS ((UDI, int));
extern UDI SLLDI PARAMS ((UDI, int));
extern DI RORDI PARAMS ((DI, int));
extern DI ROLDI PARAMS ((DI, int));
extern DI ANDDI PARAMS ((DI, DI));
extern DI ORDI PARAMS ((DI, DI));
extern DI XORDI PARAMS ((DI, DI));
extern DI NEGDI PARAMS ((DI));
extern int NOTDI PARAMS ((DI));
extern DI INVDI PARAMS ((DI));
extern int EQDI PARAMS ((DI, DI));
extern int NEDI PARAMS ((DI, DI));
extern int LTDI PARAMS ((DI, DI));
extern int LEDI PARAMS ((DI, DI));
extern int GTDI PARAMS ((DI, DI));
extern int GEDI PARAMS ((DI, DI));
extern int LTUDI PARAMS ((UDI, UDI));
extern int LEUDI PARAMS ((UDI, UDI));
extern int GTUDI PARAMS ((UDI, UDI));
extern int GEUDI PARAMS ((UDI, UDI));
d189 2
a190 2
extern DI RORDI PARAMS ((DI, int));
extern DI ROLDI PARAMS ((DI, int));
d197 1
d209 1
a209 138

#ifdef SF_FN_SUPPORT
extern SF ADDSF PARAMS ((SF, SF));
extern SF SUBSF PARAMS ((SF, SF));
extern SF NEGSF PARAMS ((SF));
extern SF MULSF PARAMS ((SF, SF));
extern SF DIVSF PARAMS ((SF, SF));
extern int EQSF PARAMS ((SF, SF));
extern int NESF PARAMS ((SF, SF));
extern int LTSF PARAMS ((SF, SF));
extern int LESF PARAMS ((SF, SF));
extern int GTSF PARAMS ((SF, SF));
extern int GESF PARAMS ((SF, SF));
extern SF ABSSF PARAMS ((SF));
extern SF SQRTSF PARAMS ((SF));
extern SF COSSF PARAMS ((SF));
extern SF SINSF PARAMS ((SF));
#else /* ! SF_FN_SUPPORT */
#define ADDSF(x, y) ((x) + (y))
#define SUBSF(x, y) ((x) - (y))
#define NEGSF(x) (- (x))
#define MULSF(x, y) ((x) * (y))
#define DIVSF(x, y) ((x) / (y))
#define EQSF(x, y) ((SF) (x) == (SF) (y))
#define NESF(x, y) ((SF) (x) != (SF) (y))
#define LTSF(x, y) ((SF) (x) < (SF) (y))
#define LESF(x, y) ((SF) (x) <= (SF) (y))
#define GTSF(x, y) ((SF) (x) > (SF) (y))
#define GESF(x, y) ((SF) (x) >= (SF) (y))
extern SF ABSSF PARAMS ((SF));
extern SF SQRTSF PARAMS ((SF));
extern SF COSSF PARAMS ((SF));
extern SF SINSF PARAMS ((SF));
#endif /* SF_FN_SUPPORT */

#ifdef DF_FN_SUPPORT
extern DF ADDDF PARAMS ((DF, DF));
extern DF SUBDF PARAMS ((DF, DF));
extern DF NEGDF PARAMS ((DF));
extern DF MULDF PARAMS ((DF, DF));
extern DF DIVDF PARAMS ((DF, DF));
extern int EQDF PARAMS ((DF, DF));
extern int NEDF PARAMS ((DF, DF));
extern int LTDF PARAMS ((DF, DF));
extern int LEDF PARAMS ((DF, DF));
extern int GTDF PARAMS ((DF, DF));
extern int GEDF PARAMS ((DF, DF));
extern DF ABSDF PARAMS ((DF));
extern DF SQRTDF PARAMS ((DF));
extern DF COSDF PARAMS ((DF));
extern DF SINDF PARAMS ((DF));
#else /* ! DF_FN_SUPPORT */
#define ADDDF(x, y) ((x) + (y))
#define SUBDF(x, y) ((x) - (y))
#define NEGDF(x) (- (x))
#define MULDF(x, y) ((x) * (y))
#define DIVDF(x, y) ((x) / (y))
#define EQDF(x, y) ((DF) (x) == (DF) (y))
#define NEDF(x, y) ((DF) (x) != (DF) (y))
#define LTDF(x, y) ((DF) (x) < (DF) (y))
#define LEDF(x, y) ((DF) (x) <= (DF) (y))
#define GTDF(x, y) ((DF) (x) > (DF) (y))
#define GEDF(x, y) ((DF) (x) >= (DF) (y))
extern DF ABSDF PARAMS ((DF));
extern DF SQRTDF PARAMS ((DF));
extern DF COSDF PARAMS ((DF));
extern DF SINDF PARAMS ((DF));
#endif /* DF_FN_SUPPORT */

#ifdef XF_FN_SUPPORT
extern XF ADDXF PARAMS ((XF, XF));
extern XF SUBXF PARAMS ((XF, XF));
extern XF NEGXF PARAMS ((XF));
extern XF MULXF PARAMS ((XF, XF));
extern XF DIVXF PARAMS ((XF, XF));
extern int EQXF PARAMS ((XF, XF));
extern int NEXF PARAMS ((XF, XF));
extern int LTXF PARAMS ((XF, XF));
extern int LEXF PARAMS ((XF, XF));
extern int GTXF PARAMS ((XF, XF));
extern int GEXF PARAMS ((XF, XF));
extern XF ABSXF PARAMS ((XF));
extern XF SQRTXF PARAMS ((XF));
extern XF COSXF PARAMS ((XF));
extern XF SINXF PARAMS ((XF));
#else /* ! XF_FN_SUPPORT */
#define ADDXF(x, y) ((x) + (y))
#define SUBXF(x, y) ((x) - (y))
#define NEGXF(x) (- (x))
#define MULXF(x, y) ((x) * (y))
#define DIVXF(x, y) ((x) / (y))
#define EQXF(x, y) ((XF) (x) == (XF) (y))
#define NEXF(x, y) ((XF) (x) != (XF) (y))
#define LTXF(x, y) ((XF) (x) < (XF) (y))
#define LEXF(x, y) ((XF) (x) <= (XF) (y))
#define GTXF(x, y) ((XF) (x) > (XF) (y))
#define GEXF(x, y) ((XF) (x) >= (XF) (y))
extern XF ABSXF PARAMS ((XF));
extern XF SQRTXF PARAMS ((XF));
extern XF COSXF PARAMS ((XF));
extern XF SINXF PARAMS ((XF));
#endif /* XF_FN_SUPPORT */

#ifdef TF_FN_SUPPORT
extern TF ADDTF PARAMS ((TF, TF));
extern TF SUBTF PARAMS ((TF, TF));
extern TF NEGTF PARAMS ((TF));
extern TF MULTF PARAMS ((TF, TF));
extern TF DIVTF PARAMS ((TF, TF));
extern int EQTF PARAMS ((TF, TF));
extern int NETF PARAMS ((TF, TF));
extern int LTTF PARAMS ((TF, TF));
extern int LETF PARAMS ((TF, TF));
extern int GTTF PARAMS ((TF, TF));
extern int GETF PARAMS ((TF, TF));
extern TF ABSTF PARAMS ((TF));
extern TF SQRTTF PARAMS ((TF));
extern TF COSTF PARAMS ((TF));
extern TF SINTF PARAMS ((TF));
#else /* ! TF_FN_SUPPORT */
#define ADDTF(x, y) ((x) + (y))
#define SUBTF(x, y) ((x) - (y))
#define NEGTF(x) (- (x))
#define MULTF(x, y) ((x) * (y))
#define DIVTF(x, y) ((x) / (y))
#define EQTF(x, y) ((TF) (x) == (TF) (y))
#define NETF(x, y) ((TF) (x) != (TF) (y))
#define LTTF(x, y) ((TF) (x) < (TF) (y))
#define LETF(x, y) ((TF) (x) <= (TF) (y))
#define GTTF(x, y) ((TF) (x) > (TF) (y))
#define GETF(x, y) ((TF) (x) >= (TF) (y))
extern TF ABSTF PARAMS ((TF));
extern TF SQRTTF PARAMS ((TF));
extern TF COSTF PARAMS ((TF));
extern TF SINTF PARAMS ((TF));
#endif /* TF_FN_SUPPORT */


d214 1
a214 1
extern DI EXTBIDI PARAMS ((BI));
d221 1
a221 1
extern DI EXTQIDI PARAMS ((QI));
d225 1
d227 1
d229 1
a229 1
extern DI EXTHIDI PARAMS ((HI));
d234 1
a234 1
extern DI EXTSIDI PARAMS ((SI));
d238 1
a238 30
#if defined (SF_FN_SUPPORT) || defined (DF_FN_SUPPORT)
extern DF EXTSFDF PARAMS ((SF));
#else
#define EXTSFDF(x) ((DF) (SF) (x))
#endif
#if defined (SF_FN_SUPPORT) || defined (XF_FN_SUPPORT)
extern XF EXTSFXF PARAMS ((SF));
#else
#define EXTSFXF(x) ((XF) (SF) (x))
#endif
#if defined (SF_FN_SUPPORT) || defined (TF_FN_SUPPORT)
extern TF EXTSFTF PARAMS ((SF));
#else
#define EXTSFTF(x) ((TF) (SF) (x))
#endif
#if defined (DF_FN_SUPPORT) || defined (XF_FN_SUPPORT)
extern XF EXTDFXF PARAMS ((DF));
#else
#define EXTDFXF(x) ((XF) (DF) (x))
#endif
#if defined (DF_FN_SUPPORT) || defined (TF_FN_SUPPORT)
extern TF EXTDFTF PARAMS ((DF));
#else
#define EXTDFTF(x) ((TF) (DF) (x))
#endif
#if defined (XF_FN_SUPPORT) || defined (TF_FN_SUPPORT)
extern TF EXTXFTF PARAMS ((XF));
#else
#define EXTXFTF(x) ((TF) (XF) (x))
#endif
d243 1
a243 1
extern DI ZEXTBIDI PARAMS ((BI));
d250 1
a250 1
extern DI ZEXTQIDI PARAMS ((QI));
d255 2
d258 1
a258 1
extern DI ZEXTHIDI PARAMS ((HI));
d263 1
a263 1
extern DI ZEXTSIDI PARAMS ((SI));
d267 1
d274 1
d276 1
a276 1
extern BI TRUNCDIBI PARAMS ((DI));
d281 1
a281 1
extern QI TRUNCDIQI PARAMS ((DI));
d286 1
a286 1
extern HI TRUNCDIHI PARAMS ((DI));
d291 1
a291 1
extern SI TRUNCDISI PARAMS ((DI));
d295 103
a397 2
#if defined (DF_FN_SUPPORT) || defined (SF_FN_SUPPORT)
extern SF TRUNCDFSF PARAMS ((DF));
d399 14
a412 367
#define TRUNCDFSF(x) ((SF) (DF) (x))
#endif
#if defined (XF_FN_SUPPORT) || defined (SF_FN_SUPPORT)
extern SF TRUNCXFSF PARAMS ((XF));
#else
#define TRUNCXFSF(x) ((SF) (XF) (x))
#endif
#if defined (XF_FN_SUPPORT) || defined (DF_FN_SUPPORT)
extern DF TRUNCXFDF PARAMS ((XF));
#else
#define TRUNCXFDF(x) ((DF) (XF) (x))
#endif
#if defined (TF_FN_SUPPORT) || defined (SF_FN_SUPPORT)
extern SF TRUNCTFSF PARAMS ((TF));
#else
#define TRUNCTFSF(x) ((SF) (TF) (x))
#endif
#if defined (TF_FN_SUPPORT) || defined (DF_FN_SUPPORT)
extern DF TRUNCTFDF PARAMS ((TF));
#else
#define TRUNCTFDF(x) ((DF) (TF) (x))
#endif
#if defined (TF_FN_SUPPORT) || defined (XF_FN_SUPPORT)
extern XF TRUNCTFXF PARAMS ((TF));
#else
#define TRUNCTFXF(x) ((XF) (TF) (x))
#endif
#if defined (SF_FN_SUPPORT)
extern SF FLOATQISF PARAMS ((QI));
#else
#define FLOATQISF(x) ((SF) (QI) (x))
#endif
#if defined (DF_FN_SUPPORT)
extern DF FLOATQIDF PARAMS ((QI));
#else
#define FLOATQIDF(x) ((DF) (QI) (x))
#endif
#if defined (XF_FN_SUPPORT)
extern XF FLOATQIXF PARAMS ((QI));
#else
#define FLOATQIXF(x) ((XF) (QI) (x))
#endif
#if defined (TF_FN_SUPPORT)
extern TF FLOATQITF PARAMS ((QI));
#else
#define FLOATQITF(x) ((TF) (QI) (x))
#endif
#if defined (SF_FN_SUPPORT)
extern SF FLOATHISF PARAMS ((HI));
#else
#define FLOATHISF(x) ((SF) (HI) (x))
#endif
#if defined (DF_FN_SUPPORT)
extern DF FLOATHIDF PARAMS ((HI));
#else
#define FLOATHIDF(x) ((DF) (HI) (x))
#endif
#if defined (XF_FN_SUPPORT)
extern XF FLOATHIXF PARAMS ((HI));
#else
#define FLOATHIXF(x) ((XF) (HI) (x))
#endif
#if defined (TF_FN_SUPPORT)
extern TF FLOATHITF PARAMS ((HI));
#else
#define FLOATHITF(x) ((TF) (HI) (x))
#endif
#if defined (SF_FN_SUPPORT)
extern SF FLOATSISF PARAMS ((SI));
#else
#define FLOATSISF(x) ((SF) (SI) (x))
#endif
#if defined (DF_FN_SUPPORT)
extern DF FLOATSIDF PARAMS ((SI));
#else
#define FLOATSIDF(x) ((DF) (SI) (x))
#endif
#if defined (XF_FN_SUPPORT)
extern XF FLOATSIXF PARAMS ((SI));
#else
#define FLOATSIXF(x) ((XF) (SI) (x))
#endif
#if defined (TF_FN_SUPPORT)
extern TF FLOATSITF PARAMS ((SI));
#else
#define FLOATSITF(x) ((TF) (SI) (x))
#endif
#if defined (DI_FN_SUPPORT) || defined (SF_FN_SUPPORT)
extern SF FLOATDISF PARAMS ((DI));
#else
#define FLOATDISF(x) ((SF) (DI) (x))
#endif
#if defined (DI_FN_SUPPORT) || defined (DF_FN_SUPPORT)
extern DF FLOATDIDF PARAMS ((DI));
#else
#define FLOATDIDF(x) ((DF) (DI) (x))
#endif
#if defined (DI_FN_SUPPORT) || defined (XF_FN_SUPPORT)
extern XF FLOATDIXF PARAMS ((DI));
#else
#define FLOATDIXF(x) ((XF) (DI) (x))
#endif
#if defined (DI_FN_SUPPORT) || defined (TF_FN_SUPPORT)
extern TF FLOATDITF PARAMS ((DI));
#else
#define FLOATDITF(x) ((TF) (DI) (x))
#endif
#if defined (SF_FN_SUPPORT)
extern SF UFLOATQISF PARAMS ((QI));
#else
#define UFLOATQISF(x) ((SF) (UQI) (x))
#endif
#if defined (DF_FN_SUPPORT)
extern DF UFLOATQIDF PARAMS ((QI));
#else
#define UFLOATQIDF(x) ((DF) (UQI) (x))
#endif
#if defined (XF_FN_SUPPORT)
extern XF UFLOATQIXF PARAMS ((QI));
#else
#define UFLOATQIXF(x) ((XF) (UQI) (x))
#endif
#if defined (TF_FN_SUPPORT)
extern TF UFLOATQITF PARAMS ((QI));
#else
#define UFLOATQITF(x) ((TF) (UQI) (x))
#endif
#if defined (SF_FN_SUPPORT)
extern SF UFLOATHISF PARAMS ((HI));
#else
#define UFLOATHISF(x) ((SF) (UHI) (x))
#endif
#if defined (DF_FN_SUPPORT)
extern DF UFLOATHIDF PARAMS ((HI));
#else
#define UFLOATHIDF(x) ((DF) (UHI) (x))
#endif
#if defined (XF_FN_SUPPORT)
extern XF UFLOATHIXF PARAMS ((HI));
#else
#define UFLOATHIXF(x) ((XF) (UHI) (x))
#endif
#if defined (TF_FN_SUPPORT)
extern TF UFLOATHITF PARAMS ((HI));
#else
#define UFLOATHITF(x) ((TF) (UHI) (x))
#endif
#if defined (SF_FN_SUPPORT)
extern SF UFLOATSISF PARAMS ((SI));
#else
#define UFLOATSISF(x) ((SF) (USI) (x))
#endif
#if defined (DF_FN_SUPPORT)
extern DF UFLOATSIDF PARAMS ((SI));
#else
#define UFLOATSIDF(x) ((DF) (USI) (x))
#endif
#if defined (XF_FN_SUPPORT)
extern XF UFLOATSIXF PARAMS ((SI));
#else
#define UFLOATSIXF(x) ((XF) (USI) (x))
#endif
#if defined (TF_FN_SUPPORT)
extern TF UFLOATSITF PARAMS ((SI));
#else
#define UFLOATSITF(x) ((TF) (USI) (x))
#endif
#if defined (DI_FN_SUPPORT) || defined (SF_FN_SUPPORT)
extern SF UFLOATDISF PARAMS ((DI));
#else
#define UFLOATDISF(x) ((SF) (UDI) (x))
#endif
#if defined (DI_FN_SUPPORT) || defined (DF_FN_SUPPORT)
extern DF UFLOATDIDF PARAMS ((DI));
#else
#define UFLOATDIDF(x) ((DF) (UDI) (x))
#endif
#if defined (DI_FN_SUPPORT) || defined (XF_FN_SUPPORT)
extern XF UFLOATDIXF PARAMS ((DI));
#else
#define UFLOATDIXF(x) ((XF) (UDI) (x))
#endif
#if defined (DI_FN_SUPPORT) || defined (TF_FN_SUPPORT)
extern TF UFLOATDITF PARAMS ((DI));
#else
#define UFLOATDITF(x) ((TF) (UDI) (x))
#endif
#if defined (SF_FN_SUPPORT)
extern BI FIXSFBI PARAMS ((SF));
#else
#define FIXSFBI(x) ((BI) (SF) (x))
#endif
#if defined (SF_FN_SUPPORT)
extern QI FIXSFQI PARAMS ((SF));
#else
#define FIXSFQI(x) ((QI) (SF) (x))
#endif
#if defined (SF_FN_SUPPORT)
extern HI FIXSFHI PARAMS ((SF));
#else
#define FIXSFHI(x) ((HI) (SF) (x))
#endif
#if defined (SF_FN_SUPPORT)
extern SI FIXSFSI PARAMS ((SF));
#else
#define FIXSFSI(x) ((SI) (SF) (x))
#endif
#if defined (SF_FN_SUPPORT) || defined (DI_FN_SUPPORT)
extern DI FIXSFDI PARAMS ((SF));
#else
#define FIXSFDI(x) ((DI) (SF) (x))
#endif
#if defined (DF_FN_SUPPORT)
extern BI FIXDFBI PARAMS ((DF));
#else
#define FIXDFBI(x) ((BI) (DF) (x))
#endif
#if defined (DF_FN_SUPPORT)
extern QI FIXDFQI PARAMS ((DF));
#else
#define FIXDFQI(x) ((QI) (DF) (x))
#endif
#if defined (DF_FN_SUPPORT)
extern HI FIXDFHI PARAMS ((DF));
#else
#define FIXDFHI(x) ((HI) (DF) (x))
#endif
#if defined (DF_FN_SUPPORT)
extern SI FIXDFSI PARAMS ((DF));
#else
#define FIXDFSI(x) ((SI) (DF) (x))
#endif
#if defined (DF_FN_SUPPORT) || defined (DI_FN_SUPPORT)
extern DI FIXDFDI PARAMS ((DF));
#else
#define FIXDFDI(x) ((DI) (DF) (x))
#endif
#if defined (XF_FN_SUPPORT)
extern BI FIXXFBI PARAMS ((XF));
#else
#define FIXXFBI(x) ((BI) (XF) (x))
#endif
#if defined (XF_FN_SUPPORT)
extern QI FIXXFQI PARAMS ((XF));
#else
#define FIXXFQI(x) ((QI) (XF) (x))
#endif
#if defined (XF_FN_SUPPORT)
extern HI FIXXFHI PARAMS ((XF));
#else
#define FIXXFHI(x) ((HI) (XF) (x))
#endif
#if defined (XF_FN_SUPPORT)
extern SI FIXXFSI PARAMS ((XF));
#else
#define FIXXFSI(x) ((SI) (XF) (x))
#endif
#if defined (XF_FN_SUPPORT) || defined (DI_FN_SUPPORT)
extern DI FIXXFDI PARAMS ((XF));
#else
#define FIXXFDI(x) ((DI) (XF) (x))
#endif
#if defined (TF_FN_SUPPORT)
extern BI FIXTFBI PARAMS ((TF));
#else
#define FIXTFBI(x) ((BI) (TF) (x))
#endif
#if defined (TF_FN_SUPPORT)
extern QI FIXTFQI PARAMS ((TF));
#else
#define FIXTFQI(x) ((QI) (TF) (x))
#endif
#if defined (TF_FN_SUPPORT)
extern HI FIXTFHI PARAMS ((TF));
#else
#define FIXTFHI(x) ((HI) (TF) (x))
#endif
#if defined (TF_FN_SUPPORT)
extern SI FIXTFSI PARAMS ((TF));
#else
#define FIXTFSI(x) ((SI) (TF) (x))
#endif
#if defined (TF_FN_SUPPORT) || defined (DI_FN_SUPPORT)
extern DI FIXTFDI PARAMS ((TF));
#else
#define FIXTFDI(x) ((DI) (TF) (x))
#endif
#if defined (SF_FN_SUPPORT)
extern QI UFIXSFQI PARAMS ((SF));
#else
#define UFIXSFQI(x) ((UQI) (SF) (x))
#endif
#if defined (SF_FN_SUPPORT)
extern HI UFIXSFHI PARAMS ((SF));
#else
#define UFIXSFHI(x) ((UHI) (SF) (x))
#endif
#if defined (SF_FN_SUPPORT)
extern SI UFIXSFSI PARAMS ((SF));
#else
#define UFIXSFSI(x) ((USI) (SF) (x))
#endif
#if defined (SF_FN_SUPPORT) || defined (DI_FN_SUPPORT)
extern DI UFIXSFDI PARAMS ((SF));
#else
#define UFIXSFDI(x) ((UDI) (SF) (x))
#endif
#if defined (DF_FN_SUPPORT)
extern QI UFIXDFQI PARAMS ((DF));
#else
#define UFIXDFQI(x) ((UQI) (DF) (x))
#endif
#if defined (DF_FN_SUPPORT)
extern HI UFIXDFHI PARAMS ((DF));
#else
#define UFIXDFHI(x) ((UHI) (DF) (x))
#endif
#if defined (DF_FN_SUPPORT)
extern SI UFIXDFSI PARAMS ((DF));
#else
#define UFIXDFSI(x) ((USI) (DF) (x))
#endif
#if defined (DF_FN_SUPPORT) || defined (DI_FN_SUPPORT)
extern DI UFIXDFDI PARAMS ((DF));
#else
#define UFIXDFDI(x) ((UDI) (DF) (x))
#endif
#if defined (XF_FN_SUPPORT)
extern QI UFIXXFQI PARAMS ((XF));
#else
#define UFIXXFQI(x) ((UQI) (XF) (x))
#endif
#if defined (XF_FN_SUPPORT)
extern HI UFIXXFHI PARAMS ((XF));
#else
#define UFIXXFHI(x) ((UHI) (XF) (x))
#endif
#if defined (XF_FN_SUPPORT)
extern SI UFIXXFSI PARAMS ((XF));
#else
#define UFIXXFSI(x) ((USI) (XF) (x))
#endif
#if defined (XF_FN_SUPPORT) || defined (DI_FN_SUPPORT)
extern DI UFIXXFDI PARAMS ((XF));
#else
#define UFIXXFDI(x) ((UDI) (XF) (x))
#endif
#if defined (TF_FN_SUPPORT)
extern QI UFIXTFQI PARAMS ((TF));
#else
#define UFIXTFQI(x) ((UQI) (TF) (x))
#endif
#if defined (TF_FN_SUPPORT)
extern HI UFIXTFHI PARAMS ((TF));
#else
#define UFIXTFHI(x) ((UHI) (TF) (x))
#endif
#if defined (TF_FN_SUPPORT)
extern SI UFIXTFSI PARAMS ((TF));
#else
#define UFIXTFSI(x) ((USI) (TF) (x))
#endif
#if defined (TF_FN_SUPPORT) || defined (DI_FN_SUPPORT)
extern DI UFIXTFDI PARAMS ((TF));
#else
#define UFIXTFDI(x) ((UDI) (TF) (x))
#endif
a415 2
#ifdef __GNUC__

a416 4
#define SEMOPS_INLINE
#else
#define SEMOPS_INLINE extern inline
#endif
d465 47
d520 6
a527 16

/* DI mode support if "long long" doesn't exist.
   At one point CGEN supported K&R C compilers, and ANSI C compilers without
   "long long".  One can argue the various merits of keeping this in or
   throwing it out.  I went to the trouble of adding it so for the time being
   I'm leaving it in.  */

#ifdef DI_FN_SUPPORT

DI make_struct_di (SI, SI);
/* FIXME: needed? */
DI CONVHIDI (HI);
DI CONVSIDI (SI);
SI CONVDISI (DI);

#endif /* DI_FN_SUPPORT */
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
a25 7
#if defined (__GNUC__) && ! defined (SEMOPS_DEFINE_INLINE)
#define SEMOPS_DEFINE_INLINE
#define SEMOPS_INLINE extern inline
#else
#define SEMOPS_INLINE
#endif

a359 1

a389 1

a415 1

a441 1

a471 1

a551 1

a631 1

a731 1

d813 3
a815 1
/* Composing/decomposing the various types.  */
d818 1
a818 92

SEMOPS_INLINE SF
SUBWORDSISF (SIM_CPU *cpu, SI in)
{
  union { SI in; SF out; } x;
  x.in = in;
  return x.out;
}

SEMOPS_INLINE SI
SUBWORDSFSI (SIM_CPU *cpu, SF in)
{
  union { SF in; SI out; } x;
  x.in = in;
  return x.out;
}

SEMOPS_INLINE SI
SUBWORDDISI (SIM_CPU *cpu, DI in, int word)
{
  /* ??? endianness issues undecided */
  if (CURRENT_TARGET_BYTE_ORDER == BIG_ENDIAN)
    {
      if (word == 0)
	return (UDI) in >> 32;
      else
	return in;
    }
  else
    {
      if (word == 1)
	return (UDI) in >> 32;
      else
	return in;
    }
}

SEMOPS_INLINE SI
SUBWORDDFSI (SIM_CPU *cpu, DF in, int word)
{
  /* ??? endianness issues undecided */
  union { DF in; SI out[2]; } x;
  x.in = in;
  if (CURRENT_TARGET_BYTE_ORDER == BIG_ENDIAN)
    return x.out[word];
  else
    return x.out[!word];
}

SEMOPS_INLINE SI
SUBWORDTFSI (SIM_CPU *cpu, TF in, int word)
{
  /* ??? endianness issues undecided */
  union { TF in; SI out[4]; } x;
  x.in = in;
  if (CURRENT_TARGET_BYTE_ORDER == BIG_ENDIAN)
    return x.out[word];
  else
    return x.out[word ^ 3];
}

SEMOPS_INLINE DI
JOINSIDI (SIM_CPU *cpu, SI x0, SI x1)
{
  if (CURRENT_TARGET_BYTE_ORDER == BIG_ENDIAN)
    return MAKEDI (x0, x1);
  else
    return MAKEDI (x1, x0);
}

SEMOPS_INLINE DF
JOINSIDF (SIM_CPU *cpu, SI x0, SI x1)
{
  union { SI in[2]; DF out; } x;
  if (CURRENT_TARGET_BYTE_ORDER == BIG_ENDIAN)
    x.in[0] = x0, x.in[1] = x1;
  else
    x.in[1] = x0, x.in[0] = x1;
  return x.out;
}

SEMOPS_INLINE TF
JOINSITF (SIM_CPU *cpu, SI x0, SI x1, SI x2, SI x3)
{
  union { SI in[4]; TF out; } x;
  if (CURRENT_TARGET_BYTE_ORDER == BIG_ENDIAN)
    x.in[0] = x0, x.in[1] = x1, x.in[2] = x2, x.in[3] = x3;
  else
    x.in[3] = x0, x.in[2] = x1, x.in[1] = x2, x.in[0] = x3;
  return x.out;
}

d820 2
a821 16

SF SUBWORDSISF (SIM_CPU *, SI);
SI SUBWORDSFSI (SIM_CPU *, SF);
SI SUBWORDDISI (SIM_CPU *, DI, int);
SI SUBWORDDFSI (SIM_CPU *, DF, int);
SI SUBWORDTFSI (SIM_CPU *, TF, int);

DI JOINSIDI (SIM_CPU *, SI, SI);
DF JOINSIDF (SIM_CPU *, SI, SI);
TF JOINSITF (SIM_CPU *, SI, SI, SI, SI);

#endif /* SUBWORD,JOIN */

/* Semantic support utilities.  */

#ifdef SEMOPS_DEFINE_INLINE
d880 16
@


1.1.1.3
log
@import gdb-1999-07-05 snapshot
@
text
@a0 1

a35 2
/* TODO: Lazy encoding/decoding of fp values.  */

d56 1
a56 1

d67 2
a68 2
extern QI RORQI (QI, int);
extern QI ROLQI (QI, int);
d85 1
a85 1

d96 2
a97 2
extern HI RORHI (HI, int);
extern HI ROLHI (HI, int);
d114 1
a114 1

d125 2
a126 2
extern SI RORSI (SI, int);
extern SI ROLSI (SI, int);
d143 1
a143 1

d145 28
a172 28
extern DI ADDDI (DI, DI);
extern DI SUBDI (DI, DI);
extern DI MULDI (DI, DI);
extern DI DIVDI (DI, DI);
extern DI UDIVDI (DI, DI);
extern DI MODDI (DI, DI);
extern DI UMODDI (DI, DI);
extern DI SRADI (DI, int);
extern UDI SRLDI (UDI, int);
extern UDI SLLDI (UDI, int);
extern DI RORDI (DI, int);
extern DI ROLDI (DI, int);
extern DI ANDDI (DI, DI);
extern DI ORDI (DI, DI);
extern DI XORDI (DI, DI);
extern DI NEGDI (DI);
extern int NOTDI (DI);
extern DI INVDI (DI);
extern int EQDI (DI, DI);
extern int NEDI (DI, DI);
extern int LTDI (DI, DI);
extern int LEDI (DI, DI);
extern int GTDI (DI, DI);
extern int GEDI (DI, DI);
extern int LTUDI (UDI, UDI);
extern int LEUDI (UDI, UDI);
extern int GTUDI (UDI, UDI);
extern int GEUDI (UDI, UDI);
d184 2
a185 2
extern DI RORDI (DI, int);
extern DI ROLDI (DI, int);
d203 138
a340 1

d345 1
a345 1
extern DI EXTBIDI (BI);
d352 1
a352 1
extern DI EXTQIDI (QI);
d358 1
a358 1
extern DI EXTHIDI (HI);
d363 1
a363 1
extern DI EXTSIDI (SI);
d367 32
a398 1

d403 1
a403 1
extern DI ZEXTBIDI (BI);
d410 1
a410 1
extern DI ZEXTQIDI (QI);
d416 1
a416 1
extern DI ZEXTHIDI (HI);
d421 1
a421 1
extern DI ZEXTSIDI (SI);
d425 1
a425 1

d433 1
a433 1
extern BI TRUNCDIBI (DI);
d438 1
a438 1
extern QI TRUNCDIQI (DI);
d443 1
a443 1
extern HI TRUNCDIHI (DI);
d448 1
a448 1
extern SI TRUNCDISI (DI);
d452 375
a829 3
/* ??? endianness issues undecided */
/* ??? CURRENT_TARGET_BYTE_ORDER usage wip */

d851 1
d871 1
a880 11
SUBWORDXFSI (SIM_CPU *cpu, XF in, int word)
{
  union { XF in; SI out[3]; } x;
  x.in = in;
  if (CURRENT_TARGET_BYTE_ORDER == BIG_ENDIAN)
    return x.out[word];
  else
    return x.out[2 - word];
}

SEMOPS_INLINE SI
d883 1
d889 1
a889 1
    return x.out[3 - word];
a911 11
SEMOPS_INLINE XF
JOINSIXF (SIM_CPU *cpu, SI x0, SI x1, SI x2)
{
  union { SI in[3]; XF out; } x;
  if (CURRENT_TARGET_BYTE_ORDER == BIG_ENDIAN)
    x.in[0] = x0, x.in[1] = x1, x.in[2] = x2;
  else
    x.in[2] = x0, x.in[1] = x1, x.in[0] = x2;
  return x.out;
}

a928 1
SI SUBWORDXFSI (SIM_CPU *, XF, int);
a932 1
XF JOINSIXF (SIM_CPU *, SI, SI, SI);
@


1.1.1.4
log
@import gdb-1999-09-28 snapshot
@
text
@d1 1
d288 4
a291 4
/* Composing/decomposing the various types.
   Word ordering is endian-independent.  Words are specified most to least
   significant and word number 0 is the most significant word.
   ??? May also wish an endian-dependent version.  Later.  */
d296 1
a296 1
SUBWORDSISF (SI in)
d304 1
a304 1
SUBWORDSFSI (SF in)
d312 1
a312 1
SUBWORDDISI (DI in, int word)
d314 7
a320 2
  if (word == 0)
    return (UDI) in >> 32;
d322 6
a327 1
    return in;
d331 1
a331 1
SUBWORDDFSI (DF in, int word)
d333 4
a336 3
  /* Note: typedef UDI DF; */
  if (word == 0)
    return (UDI) in >> 32;
d338 1
a338 1
    return in;
d342 1
a342 1
SUBWORDXFSI (XF in, int word)
a343 1
  /* Note: typedef struct { SI parts[3]; } XF; */
d346 4
a349 1
  return x.out[word];
d353 1
a353 1
SUBWORDTFSI (TF in, int word)
a354 1
  /* Note: typedef struct { SI parts[4]; } TF; */
d357 4
a360 1
  return x.out[word];
d364 1
a364 1
JOINSIDI (SI x0, SI x1)
d373 1
a373 1
JOINSIDF (SI x0, SI x1)
d384 1
a384 1
JOINSIXF (SI x0, SI x1, SI x2)
d395 1
a395 1
JOINSITF (SI x0, SI x1, SI x2, SI x3)
d407 11
a417 11
SF SUBWORDSISF (SI);
SI SUBWORDSFSI (SF);
SI SUBWORDDISI (DI, int);
SI SUBWORDDFSI (DF, int);
SI SUBWORDXFSI (XF, int);
SI SUBWORDTFSI (TF, int);

DI JOINSIDI (SI, SI);
DF JOINSIDF (SI, SI);
XF JOINSIXF (SI, SI, SI);
TF JOINSITF (SI, SI, SI, SI);
@


1.1.1.5
log
@import gdb-2000-01-24 snapshot
@
text
@a76 1
#define ABSQI(x) ((x) < 0 ? -(x) : (x))
a105 1
#define ABSHI(x) ((x) < 0 ? -(x) : (x))
a134 1
#define ABSSI(x) ((x) < 0 ? -(x) : (x))
a193 1
#define ABSDI(x) ((x) < 0 ? -(x) : (x))
a221 1
#define EXTSISI(x) ((SI) (SI) (x))
a248 2
#define ZEXTHIHI(x) ((HI) (UHI) (x))
#define ZEXTSISI(x) ((SI) (USI) (x))
a455 47
SEMOPS_INLINE HI
ADDCHI (HI a, HI b, BI c)
{
  HI res = ADDHI (a, ADDHI (b, c));
  return res;
}

SEMOPS_INLINE BI
ADDCFHI (HI a, HI b, BI c)
{
  HI tmp = ADDHI (a, ADDHI (b, c));
  BI res = ((UHI) tmp < (UHI) a) || (c && tmp == a);
  return res;
}

SEMOPS_INLINE BI
ADDOFHI (HI a, HI b, BI c)
{
  HI tmp = ADDHI (a, ADDHI (b, c));
  BI res = (((a < 0) == (b < 0))
	    && ((a < 0) != (tmp < 0)));
  return res;
}

SEMOPS_INLINE HI
SUBCHI (HI a, HI b, BI c)
{
  HI res = SUBHI (a, ADDHI (b, c));
  return res;
}

SEMOPS_INLINE BI
SUBCFHI (HI a, HI b, BI c)
{
  BI res = ((UHI) a < (UHI) b) || (c && a == b);
  return res;
}

SEMOPS_INLINE BI
SUBOFHI (HI a, HI b, BI c)
{
  HI tmp = SUBHI (a, ADDHI (b, c));
  BI res = (((a < 0) != (b < 0))
	    && ((a < 0) != (tmp < 0)));
  return res;
}

a463 6
HI ADDCHI (HI, HI, BI);
UBI ADDCFHI (HI, HI, BI);
UBI ADDOFHI (HI, HI, BI);
HI SUBCHI (HI, HI, BI);
UBI SUBCFHI (HI, HI, BI);
UBI SUBOFHI (HI, HI, BI);
@


1.1.1.6
log
@import gdb-2000-01-26 snapshot
@
text
@a224 1
#define EXTHIHI(x) ((HI) (HI) (x))
@


