head	1.34;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.34
	gdb_7_6-2013-04-26-release:1.34
	gdb_7_6-branch:1.34.0.2
	gdb_7_6-2013-03-12-branchpoint:1.34
	gdb_7_5_1-2012-11-29-release:1.33
	gdb_7_5-2012-08-17-release:1.33
	gdb_7_5-branch:1.33.0.2
	gdb_7_5-2012-07-18-branchpoint:1.33
	gdb_7_4_1-2012-04-26-release:1.31.2.1
	gdb_7_4-2012-01-24-release:1.31.2.1
	gdb_7_4-branch:1.31.0.2
	gdb_7_4-2011-12-13-branchpoint:1.31
	gdb_7_3_1-2011-09-04-release:1.30
	gdb_7_3-2011-07-26-release:1.30
	gdb_7_3-branch:1.30.0.2
	gdb_7_3-2011-04-01-branchpoint:1.30
	gdb_7_2-2010-09-02-release:1.26
	gdb_7_2-branch:1.26.0.4
	gdb_7_2-2010-07-07-branchpoint:1.26
	gdb_7_1-2010-03-18-release:1.26
	gdb_7_1-branch:1.26.0.2
	gdb_7_1-2010-02-18-branchpoint:1.26
	gdb_7_0_1-2009-12-22-release:1.25
	gdb_7_0-2009-10-06-release:1.25
	gdb_7_0-branch:1.25.0.4
	gdb_7_0-2009-09-16-branchpoint:1.25
	arc-sim-20090309:1.23.16.1
	msnyder-checkpoint-072509-branch:1.25.0.2
	msnyder-checkpoint-072509-branchpoint:1.25
	arc-insight_6_8-branch:1.23.0.16
	arc-insight_6_8-branchpoint:1.23
	insight_6_8-branch:1.23.0.14
	insight_6_8-branchpoint:1.23
	reverse-20081226-branch:1.23.0.12
	reverse-20081226-branchpoint:1.23
	multiprocess-20081120-branch:1.23.0.10
	multiprocess-20081120-branchpoint:1.23
	reverse-20080930-branch:1.23.0.8
	reverse-20080930-branchpoint:1.23
	reverse-20080717-branch:1.23.0.6
	reverse-20080717-branchpoint:1.23
	msnyder-reverse-20080609-branch:1.23.0.4
	msnyder-reverse-20080609-branchpoint:1.23
	drow-reverse-20070409-branch:1.19.0.2
	drow-reverse-20070409-branchpoint:1.19
	gdb_6_8-2008-03-27-release:1.23
	gdb_6_8-branch:1.23.0.2
	gdb_6_8-2008-02-26-branchpoint:1.23
	gdb_6_7_1-2007-10-29-release:1.20
	gdb_6_7-2007-10-10-release:1.20
	gdb_6_7-branch:1.20.0.2
	gdb_6_7-2007-09-07-branchpoint:1.20
	insight_6_6-20070208-release:1.18
	gdb_6_6-2006-12-18-release:1.18
	gdb_6_6-branch:1.18.0.26
	gdb_6_6-2006-11-15-branchpoint:1.18
	insight_6_5-20061003-release:1.18
	gdb-csl-symbian-6_4_50_20060226-12:1.18
	gdb-csl-sourcerygxx-3_4_4-25:1.18
	nickrob-async-20060828-mergepoint:1.18
	gdb-csl-symbian-6_4_50_20060226-11:1.18
	gdb-csl-sourcerygxx-4_1-17:1.18
	gdb-csl-20060226-branch-local-2:1.18
	gdb-csl-sourcerygxx-4_1-14:1.18
	gdb-csl-sourcerygxx-4_1-13:1.18
	gdb-csl-sourcerygxx-4_1-12:1.18
	gdb-csl-sourcerygxx-3_4_4-21:1.18
	gdb_6_5-20060621-release:1.18
	gdb-csl-sourcerygxx-4_1-9:1.18
	gdb-csl-sourcerygxx-4_1-8:1.18
	gdb-csl-sourcerygxx-4_1-7:1.18
	gdb-csl-arm-2006q1-6:1.18
	gdb-csl-sourcerygxx-4_1-6:1.18
	gdb-csl-symbian-6_4_50_20060226-10:1.18
	gdb-csl-symbian-6_4_50_20060226-9:1.18
	gdb-csl-symbian-6_4_50_20060226-8:1.18
	gdb-csl-coldfire-4_1-11:1.18
	gdb-csl-sourcerygxx-3_4_4-19:1.18
	gdb-csl-coldfire-4_1-10:1.18
	gdb_6_5-branch:1.18.0.24
	gdb_6_5-2006-05-14-branchpoint:1.18
	gdb-csl-sourcerygxx-4_1-5:1.18
	nickrob-async-20060513-branch:1.18.0.22
	nickrob-async-20060513-branchpoint:1.18
	gdb-csl-sourcerygxx-4_1-4:1.18
	msnyder-reverse-20060502-branch:1.18.0.20
	msnyder-reverse-20060502-branchpoint:1.18
	gdb-csl-morpho-4_1-4:1.18
	gdb-csl-sourcerygxx-3_4_4-17:1.18
	readline_5_1-import-branch:1.18.0.18
	readline_5_1-import-branchpoint:1.18
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.18
	gdb-csl-symbian-20060226-branch:1.18.0.16
	gdb-csl-symbian-20060226-branchpoint:1.18
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.18
	msnyder-reverse-20060331-branch:1.18.0.14
	msnyder-reverse-20060331-branchpoint:1.18
	gdb-csl-available-20060303-branch:1.18.0.12
	gdb-csl-available-20060303-branchpoint:1.18
	gdb-csl-20060226-branch:1.18.0.10
	gdb-csl-20060226-branchpoint:1.18
	gdb_6_4-20051202-release:1.18
	msnyder-fork-checkpoint-branch:1.18.0.8
	msnyder-fork-checkpoint-branchpoint:1.18
	gdb-csl-gxxpro-6_3-branch:1.18.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.18
	gdb_6_4-branch:1.18.0.4
	gdb_6_4-2005-11-01-branchpoint:1.18
	gdb-csl-arm-20051020-branch:1.18.0.2
	gdb-csl-arm-20051020-branchpoint:1.18
	msnyder-tracepoint-checkpoint-branch:1.17.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.17
	gdb-csl-arm-20050325-2005-q1b:1.16.2.1
	gdb-csl-arm-20050325-2005-q1a:1.16
	csl-arm-20050325-branch:1.16.0.2
	csl-arm-20050325-branchpoint:1.16
	gdb_6_3-20041109-release:1.10
	gdb_6_3-branch:1.10.0.4
	gdb_6_3-20041019-branchpoint:1.10
	drow_intercu-merge-20040921:1.10
	drow_intercu-merge-20040915:1.10
	jimb-gdb_6_2-e500-branch:1.10.0.6
	jimb-gdb_6_2-e500-branchpoint:1.10
	gdb_6_2-20040730-release:1.10
	gdb_6_2-branch:1.10.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.10
	gdb_6_1_1-20040616-release:1.7
	gdb_6_1-2004-04-05-release:1.7
	drow_intercu-merge-20040402:1.7
	drow_intercu-merge-20040327:1.7
	ezannoni_pie-20040323-branch:1.7.0.12
	ezannoni_pie-20040323-branchpoint:1.7
	cagney_tramp-20040321-mergepoint:1.7
	cagney_tramp-20040309-branch:1.7.0.10
	cagney_tramp-20040309-branchpoint:1.7
	gdb_6_1-branch:1.7.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.7
	drow_intercu-20040221-branch:1.7.0.6
	drow_intercu-20040221-branchpoint:1.7
	cagney_bfdfile-20040213-branch:1.7.0.4
	cagney_bfdfile-20040213-branchpoint:1.7
	drow-cplus-merge-20040208:1.7
	carlton_dictionary-20040126-merge:1.7
	cagney_bigcore-20040122-branch:1.7.0.2
	cagney_bigcore-20040122-branchpoint:1.7
	drow-cplus-merge-20040113:1.7
	drow-cplus-merge-20031224:1.7
	drow-cplus-merge-20031220:1.7
	carlton_dictionary-20031215-merge:1.7
	drow-cplus-merge-20031214:1.7
	carlton-dictionary-20031111-merge:1.7
	gdb_6_0-2003-10-04-release:1.5
	kettenis_sparc-20030918-branch:1.5.0.50
	kettenis_sparc-20030918-branchpoint:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.48
	cagney_x86i386-20030821-branch:1.5.0.46
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.44
	gdb_6_0-2003-06-23-branchpoint:1.5
	jimb-ppc64-linux-20030613-branch:1.5.0.42
	jimb-ppc64-linux-20030613-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.40
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.38
	cagney_writestrings-20030508-branchpoint:1.5
	jimb-ppc64-linux-20030528-branch:1.5.0.36
	jimb-ppc64-linux-20030528-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.34
	cagney_fileio-20030521-branchpoint:1.5
	kettenis_i386newframe-20030517-mergepoint:1.5
	jimb-ppc64-linux-20030509-branch:1.5.0.32
	jimb-ppc64-linux-20030509-branchpoint:1.5
	kettenis_i386newframe-20030504-mergepoint:1.5
	carlton_dictionary-20030430-merge:1.5
	kettenis_i386newframe-20030419-branch:1.5.0.30
	kettenis_i386newframe-20030419-branchpoint:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	kettenis_i386newframe-20030406-branch:1.5.0.28
	kettenis_i386newframe-20030406-branchpoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.26
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.24
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.22
	cagney_lazyid-20030317-branchpoint:1.5
	kettenis-i386newframe-20030316-mergepoint:1.5
	offbyone-20030313-branch:1.5.0.20
	offbyone-20030313-branchpoint:1.5
	kettenis-i386newframe-20030308-branch:1.5.0.18
	kettenis-i386newframe-20030308-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.16
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.14
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.12
	cagney-unwind-20030108-branchpoint:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.5
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.10
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.8
	carlton_dictionary-20020920-branchpoint:1.5
	gdb_5_3-branch:1.5.0.6
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.4
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.2
	readline_4_3-import-branchpoint:1.5
	gdb_5_2_1-2002-07-23-release:1.3
	kseitz_interps-20020528-branch:1.4.0.6
	kseitz_interps-20020528-branchpoint:1.4
	cagney_regbuf-20020515-branch:1.4.0.4
	cagney_regbuf-20020515-branchpoint:1.4
	jimb-macro-020506-branch:1.4.0.2
	jimb-macro-020506-branchpoint:1.4
	gdb_5_2-2002-04-29-release:1.3
	gdb_5_2-branch:1.3.0.2
	gdb_5_2-2002-03-03-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.2
	gdb_5_1_0_1-2002-01-03-release:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.10
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.8
	gdb_s390-2001-09-26-branchpoint:1.2
	gdb_5_1-2001-07-29-branch:1.2.0.6
	gdb_5_1-2001-07-29-branchpoint:1.2
	insight-precleanup-2001-01-01:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.34
date	2013.01.01.06.41.33;	author brobecke;	state Exp;
branches;
next	1.33;

1.33
date	2012.05.19.16.46.14;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2012.01.04.08.28.04;	author brobecke;	state Exp;
branches;
next	1.31;

1.31
date	2011.05.11.20.02.42;	author vapier;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2011.03.15.03.16.16;	author vapier;	state Exp;
branches;
next	1.29;

1.29
date	2011.02.25.22.28.57;	author kevinb;	state Exp;
branches;
next	1.28;

1.28
date	2011.01.01.15.33.55;	author brobecke;	state Exp;
branches;
next	1.27;

1.27
date	2010.10.06.23.45.44;	author hp;	state Exp;
branches;
next	1.26;

1.26
date	2010.01.01.10.03.26;	author brobecke;	state Exp;
branches;
next	1.25;

1.25
date	2009.01.14.10.53.05;	author brobecke;	state Exp;
branches;
next	1.24;

1.24
date	2009.01.06.23.39.28;	author hp;	state Exp;
branches;
next	1.23;

1.23
date	2008.01.01.22.53.23;	author drow;	state Exp;
branches
	1.23.16.1;
next	1.22;

1.22
date	2007.10.11.18.44.06;	author drow;	state Exp;
branches;
next	1.21;

1.21
date	2007.10.11.18.40.29;	author drow;	state Exp;
branches;
next	1.20;

1.20
date	2007.08.24.14.28.35;	author brobecke;	state Exp;
branches;
next	1.19;

1.19
date	2007.01.09.17.59.16;	author drow;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.08.08.05.35;	author bje;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.29.14.48.02;	author pbrook;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.21.21.59.54;	author jimb;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2005.01.28.03.40.54;	author hp;	state Exp;
branches;
next	1.14;

1.14
date	2005.01.28.03.28.40;	author hp;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.13.00.38.38;	author hp;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.03.23.34.55;	author hp;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.03.19.36.53;	author hp;	state Exp;
branches;
next	1.10;

1.10
date	2004.06.27.03.14.51;	author amylaar;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.25.16.48.03;	author amylaar;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.10.16.18.03;	author drow;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.21.20.41.43;	author cagney;	state Exp;
branches
	1.7.6.1;
next	1.6;

1.6
date	2003.10.15.12.30.47;	author amylaar;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.09.15.45.45;	author cagney;	state Exp;
branches
	1.5.8.1
	1.5.10.1;
next	1.4;

1.4
date	2002.05.01.23.26.31;	author cgd;	state Exp;
branches
	1.4.4.1
	1.4.6.1;
next	1.3;

1.3
date	2002.02.10.23.11.37;	author cgd;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.08.20.54.27;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.56;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.31.2.1
date	2012.01.06.04.54.38;	author brobecke;	state Exp;
branches;
next	;

1.23.16.1
date	2009.03.09.20.36.15;	author amylaar;	state Exp;
branches;
next	1.23.16.2;

1.23.16.2
date	2009.09.11.04.45.56;	author amylaar;	state Exp;
branches;
next	;

1.16.2.1
date	2005.04.29.14.39.20;	author pbrook;	state Exp;
branches;
next	;

1.7.6.1
date	2004.09.16.17.02.03;	author drow;	state Exp;
branches;
next	;

1.5.8.1
date	2003.11.11.23.51.18;	author carlton;	state Exp;
branches;
next	;

1.5.10.1
date	2003.12.14.20.28.17;	author drow;	state Exp;
branches;
next	;

1.4.4.1
date	2002.06.15.16.43.22;	author cagney;	state Exp;
branches;
next	;

1.4.6.1
date	2002.06.20.01.38.58;	author kseitz;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.56;	author shebs;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* Remote target callback routines.
   Copyright 1995-2013 Free Software Foundation, Inc.
   Contributed by Cygnus Solutions.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* This file provides a standard way for targets to talk to the host OS
   level.  */

#ifdef HAVE_CONFIG_H
#include "cconfig.h"
#endif
#include "config.h"
#include "ansidecl.h"
#include <stdarg.h>
#include <stdio.h>
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#else
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif
#endif
#ifdef HAVE_LIMITS_H
/* For PIPE_BUF.  */
#include <limits.h>
#endif
#include <errno.h>
#include <fcntl.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "gdb/callback.h"
#include "targ-vals.h"
/* For xmalloc.  */
#include "libiberty.h"

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#ifndef PIPE_BUF
#define PIPE_BUF 512
#endif

/* ??? sim_cb_printf should be cb_printf, but until the callback support is
   broken out of the simulator directory, these are here to not require
   sim-utils.h.  */
void sim_cb_printf PARAMS ((host_callback *, const char *, ...));
void sim_cb_eprintf PARAMS ((host_callback *, const char *, ...));

extern CB_TARGET_DEFS_MAP cb_init_syscall_map[];
extern CB_TARGET_DEFS_MAP cb_init_errno_map[];
extern CB_TARGET_DEFS_MAP cb_init_open_map[];

extern int system PARAMS ((const char *));

static int os_init PARAMS ((host_callback *));
static int os_shutdown PARAMS ((host_callback *));
static int os_unlink PARAMS ((host_callback *, const char *));
static long os_time PARAMS ((host_callback *, long *));
static int os_system PARAMS ((host_callback *, const char *));
static int os_rename PARAMS ((host_callback *, const char *, const char *));
static int os_write_stdout PARAMS ((host_callback *, const char *, int));
static void os_flush_stdout PARAMS ((host_callback *));
static int os_write_stderr PARAMS ((host_callback *, const char *, int));
static void os_flush_stderr PARAMS ((host_callback *));
static int os_write PARAMS ((host_callback *, int, const char *, int));
static int os_read_stdin PARAMS ((host_callback *, char *, int));
static int os_read PARAMS ((host_callback *, int, char *, int));
static int os_open PARAMS ((host_callback *, const char *, int));
static int os_lseek PARAMS ((host_callback *, int, long, int));
static int os_isatty PARAMS ((host_callback *, int));
static int os_get_errno PARAMS ((host_callback *));
static int os_close PARAMS ((host_callback *, int));
static void os_vprintf_filtered PARAMS ((host_callback *, const char *, va_list));
static void os_evprintf_filtered PARAMS ((host_callback *, const char *, va_list));
static void os_error PARAMS ((host_callback *, const char *, ...))
#ifdef __GNUC__
  __attribute__ ((__noreturn__))
#endif
  ;
static int fdmap PARAMS ((host_callback *, int));
static int fdbad PARAMS ((host_callback *, int));
static int wrap PARAMS ((host_callback *, int));

/* Set the callback copy of errno from what we see now.  */

static int
wrap (p, val)
     host_callback *p;
     int val;
{
  p->last_errno = errno;
  return val;
}

/* Make sure the FD provided is ok.  If not, return non-zero
   and set errno. */

static int
fdbad (p, fd)
     host_callback *p;
     int fd;
{
  if (fd < 0 || fd > MAX_CALLBACK_FDS || p->fd_buddy[fd] < 0)
    {
      p->last_errno = EBADF;
      return -1;
    }
  return 0;
}

static int
fdmap (p, fd)
     host_callback *p;
     int fd;
{
  return p->fdmap[fd];
}

static int
os_close (p, fd)
     host_callback *p;
     int fd;
{
  int result;
  int i, next;

  result = fdbad (p, fd);
  if (result)
    return result;
  /* If this file descripter has one or more buddies (originals /
     duplicates from a dup), just remove it from the circular list.  */
  for (i = fd; (next = p->fd_buddy[i]) != fd; )
    i = next;
  if (fd != i)
    p->fd_buddy[i] = p->fd_buddy[fd];
  else
    {
      if (p->ispipe[fd])
	{
	  int other = p->ispipe[fd];
	  int reader, writer;

	  if (other > 0)
	    {
	      /* Closing the read side.  */
	      reader = fd;
	      writer = other;
	    }
	  else
	    {
	      /* Closing the write side.  */
	      writer = fd;
	      reader = -other;
	    }

	  /* If there was data in the buffer, make a last "now empty"
	     call, then deallocate data.  */
	  if (p->pipe_buffer[writer].buffer != NULL)
	    {
	      (*p->pipe_empty) (p, reader, writer);
	      free (p->pipe_buffer[writer].buffer);
	      p->pipe_buffer[writer].buffer = NULL;
	    }

	  /* Clear pipe data for this side.  */
	  p->pipe_buffer[fd].size = 0;
	  p->ispipe[fd] = 0;

	  /* If this was the first close, mark the other side as the
	     only remaining side.  */
	  if (fd != abs (other))
	    p->ispipe[abs (other)] = -other;
	  p->fd_buddy[fd] = -1;
	  return 0;
	}

      result = wrap (p, close (fdmap (p, fd)));
    }
  p->fd_buddy[fd] = -1;

  return result;
}


/* taken from gdb/util.c:notice_quit() - should be in a library */


#if defined(__GO32__) || defined (_MSC_VER)
static int
os_poll_quit (p)
     host_callback *p;
{
#if defined(__GO32__)
  int kbhit ();
  int getkey ();
  if (kbhit ())
    {
      int k = getkey ();
      if (k == 1)
	{
	  return 1;
	}
      else if (k == 2)
	{
	  return 1;
	}
      else
	{
	  sim_cb_eprintf (p, "CTRL-A to quit, CTRL-B to quit harder\n");
	}
    }
#endif
#if defined (_MSC_VER)
  /* NB - this will not compile! */
  int k = win32pollquit ();
  if (k == 1)
    return 1;
  else if (k == 2)
    return 1;
#endif
  return 0;
}
#else
#define os_poll_quit 0
#endif /* defined(__GO32__) || defined(_MSC_VER) */

static int
os_get_errno (p)
     host_callback *p;
{
  return cb_host_to_target_errno (p, p->last_errno);
}


static int
os_isatty (p, fd)
     host_callback *p;
     int fd;
{
  int result;

  result = fdbad (p, fd);
  if (result)
    return result;
  result = wrap (p, isatty (fdmap (p, fd)));

  return result;
}

static int
os_lseek (p, fd, off, way)
     host_callback *p;
     int fd;
     long off;
     int way;
{
  int result;

  result = fdbad (p, fd);
  if (result)
    return result;
  result = wrap (p, lseek (fdmap (p, fd), off, way));
  return result;
}

static int
os_open (p, name, flags)
     host_callback *p;
     const char *name;
     int flags;
{
  int i;
  for (i = 0; i < MAX_CALLBACK_FDS; i++)
    {
      if (p->fd_buddy[i] < 0)
	{
	  int f = open (name, cb_target_to_host_open (p, flags), 0644);
	  if (f < 0)
	    {
	      p->last_errno = errno;
	      return f;
	    }
	  p->fd_buddy[i] = i;
	  p->fdmap[i] = f;
	  return i;
	}
    }
  p->last_errno = EMFILE;
  return -1;
}

static int
os_read (p, fd, buf, len)
     host_callback *p;
     int fd;
     char *buf;
     int len;
{
  int result;

  result = fdbad (p, fd);
  if (result)
    return result;
  if (p->ispipe[fd])
    {
      int writer = p->ispipe[fd];

      /* Can't read from the write-end.  */
      if (writer < 0)
	{
	  p->last_errno = EBADF;
	  return -1;
	}

      /* Nothing to read if nothing is written.  */
      if (p->pipe_buffer[writer].size == 0)
	return 0;

      /* Truncate read request size to buffer size minus what's already
         read.  */
      if (len > p->pipe_buffer[writer].size - p->pipe_buffer[fd].size)
	len = p->pipe_buffer[writer].size - p->pipe_buffer[fd].size;

      memcpy (buf, p->pipe_buffer[writer].buffer + p->pipe_buffer[fd].size,
	      len);

      /* Account for what we just read.  */
      p->pipe_buffer[fd].size += len;

      /* If we've read everything, empty and deallocate the buffer and
	 signal buffer-empty to client.  (This isn't expected to be a
	 hot path in the simulator, so we don't hold on to the buffer.)  */
      if (p->pipe_buffer[fd].size == p->pipe_buffer[writer].size)
	{
	  free (p->pipe_buffer[writer].buffer);
	  p->pipe_buffer[writer].buffer = NULL;
	  p->pipe_buffer[fd].size = 0;
	  p->pipe_buffer[writer].size = 0;
	  (*p->pipe_empty) (p, fd, writer);
	}

      return len;
    }

  result = wrap (p, read (fdmap (p, fd), buf, len));
  return result;
}

static int
os_read_stdin (p, buf, len)
     host_callback *p;
     char *buf;
     int len;
{
  return wrap (p, read (0, buf, len));
}

static int
os_write (p, fd, buf, len)
     host_callback *p;
     int fd;
     const char *buf;
     int len;
{
  int result;
  int real_fd;

  result = fdbad (p, fd);
  if (result)
    return result;

  if (p->ispipe[fd])
    {
      int reader = -p->ispipe[fd];

      /* Can't write to the read-end.  */
      if (reader < 0)
	{
	  p->last_errno = EBADF;
	  return -1;
	}

      /* Can't write to pipe with closed read end.
	 FIXME: We should send a SIGPIPE.  */
      if (reader == fd)
	{
	  p->last_errno = EPIPE;
	  return -1;
	}

      /* As a sanity-check, we bail out it the buffered contents is much
	 larger than the size of the buffer on the host.  We don't want
	 to run out of memory in the simulator due to a target program
	 bug if we can help it.  Unfortunately, regarding the value that
	 reaches the simulated program, it's no use returning *less*
	 than the requested amount, because cb_syscall loops calling
	 this function until the whole amount is done.  */
      if (p->pipe_buffer[fd].size + len > 10 * PIPE_BUF)
	{
	  p->last_errno = EFBIG;
	  return -1;
	}

      p->pipe_buffer[fd].buffer
	= xrealloc (p->pipe_buffer[fd].buffer, p->pipe_buffer[fd].size + len);
      memcpy (p->pipe_buffer[fd].buffer + p->pipe_buffer[fd].size,
	      buf, len);
      p->pipe_buffer[fd].size += len;

      (*p->pipe_nonempty) (p, reader, fd);
      return len;
    }

  real_fd = fdmap (p, fd);
  switch (real_fd)
    {
    default:
      result = wrap (p, write (real_fd, buf, len));
      break;
    case 1:
      result = p->write_stdout (p, buf, len);
      break;
    case 2:
      result = p->write_stderr (p, buf, len);
      break;
    }
  return result;
}

static int
os_write_stdout (p, buf, len)
     host_callback *p ATTRIBUTE_UNUSED;
     const char *buf;
     int len;
{
  return fwrite (buf, 1, len, stdout);
}

static void
os_flush_stdout (p)
     host_callback *p ATTRIBUTE_UNUSED;
{
  fflush (stdout);
}

static int
os_write_stderr (p, buf, len)
     host_callback *p ATTRIBUTE_UNUSED;
     const char *buf;
     int len;
{
  return fwrite (buf, 1, len, stderr);
}

static void
os_flush_stderr (p)
     host_callback *p ATTRIBUTE_UNUSED;
{
  fflush (stderr);
}

static int
os_rename (p, f1, f2)
     host_callback *p;
     const char *f1;
     const char *f2;
{
  return wrap (p, rename (f1, f2));
}


static int
os_system (p, s)
     host_callback *p;
     const char *s;
{
  return wrap (p, system (s));
}

static long
os_time (p, t)
     host_callback *p;
     long *t;
{
  return wrap (p, time (t));
}


static int
os_unlink (p, f1)
     host_callback *p;
     const char *f1;
{
  return wrap (p, unlink (f1));
}

static int
os_stat (p, file, buf)
     host_callback *p;
     const char *file;
     struct stat *buf;
{
  /* ??? There is an issue of when to translate to the target layout.
     One could do that inside this function, or one could have the
     caller do it.  It's more flexible to let the caller do it, though
     I'm not sure the flexibility will ever be useful.  */
  return wrap (p, stat (file, buf));
}

static int
os_fstat (p, fd, buf)
     host_callback *p;
     int fd;
     struct stat *buf;
{
  if (fdbad (p, fd))
    return -1;

  if (p->ispipe[fd])
    {
#if defined (HAVE_STRUCT_STAT_ST_ATIME) || defined (HAVE_STRUCT_STAT_ST_CTIME) || defined (HAVE_STRUCT_STAT_ST_MTIME)
      time_t t = (*p->time) (p, NULL);
#endif

      /* We have to fake the struct stat contents, since the pipe is
	 made up in the simulator.  */
      memset (buf, 0, sizeof (*buf));

#ifdef HAVE_STRUCT_STAT_ST_MODE
      buf->st_mode = S_IFIFO;
#endif

      /* If more accurate tracking than current-time is needed (for
	 example, on GNU/Linux we get accurate numbers), the p->time
	 callback (which may be something other than os_time) should
	 happen for each read and write, and we'd need to keep track of
	 atime, ctime and mtime.  */
#ifdef HAVE_STRUCT_STAT_ST_ATIME
      buf->st_atime = t;
#endif
#ifdef HAVE_STRUCT_STAT_ST_CTIME
      buf->st_ctime = t;
#endif
#ifdef HAVE_STRUCT_STAT_ST_MTIME
      buf->st_mtime = t;
#endif
      return 0;
    }

  /* ??? There is an issue of when to translate to the target layout.
     One could do that inside this function, or one could have the
     caller do it.  It's more flexible to let the caller do it, though
     I'm not sure the flexibility will ever be useful.  */
  return wrap (p, fstat (fdmap (p, fd), buf));
}

static int
os_lstat (p, file, buf)
     host_callback *p;
     const char *file;
     struct stat *buf;
{
  /* NOTE: hpn/2004-12-12: Same issue here as with os_fstat.  */
#ifdef HAVE_LSTAT
  return wrap (p, lstat (file, buf));
#else
  return wrap (p, stat (file, buf));
#endif
}

static int
os_ftruncate (p, fd, len)
     host_callback *p;
     int fd;
     long len;
{
  int result;

  result = fdbad (p, fd);
  if (p->ispipe[fd])
    {
      p->last_errno = EINVAL;
      return -1;
    }
  if (result)
    return result;
#ifdef HAVE_FTRUNCATE
  result = wrap (p, ftruncate (fdmap (p, fd), len));
#else
  p->last_errno = EINVAL;
  result = -1;
#endif
  return result;
}

static int
os_truncate (p, file, len)
     host_callback *p;
     const char *file;
     long len;
{
#ifdef HAVE_TRUNCATE
  return wrap (p, truncate (file, len));
#else
  p->last_errno = EINVAL;
  return -1;
#endif
}

static int
os_pipe (p, filedes)
     host_callback *p;
     int *filedes;
{
  int i;

  /* We deliberately don't use fd 0.  It's probably stdin anyway.  */
  for (i = 1; i < MAX_CALLBACK_FDS; i++)
    {
      int j;

      if (p->fd_buddy[i] < 0)
	for (j = i + 1; j < MAX_CALLBACK_FDS; j++)
	  if (p->fd_buddy[j] < 0)
	    {
	      /* Found two free fd:s.  Set stat to allocated and mark
		 pipeness.  */
	      p->fd_buddy[i] = i;
	      p->fd_buddy[j] = j;
	      p->ispipe[i] = j;
	      p->ispipe[j] = -i;
	      filedes[0] = i;
	      filedes[1] = j;

	      /* Poison the FD map to make bugs apparent.  */
	      p->fdmap[i] = -1;
	      p->fdmap[j] = -1;
	      return 0;
	    }
    }

  p->last_errno = EMFILE;
  return -1;
}

/* Stub functions for pipe support.  They should always be overridden in
   targets using the pipe support, but that's up to the target.  */

/* Called when the simulator says that the pipe at (reader, writer) is
   now empty (so the writer should leave its waiting state).  */

static void
os_pipe_empty (p, reader, writer)
     host_callback *p;
     int reader;
     int writer;
{
}

/* Called when the simulator says the pipe at (reader, writer) is now
   non-empty (so the writer should wait).  */

static void
os_pipe_nonempty (p, reader, writer)
     host_callback *p;
     int reader;
     int writer;
{
}

static int
os_shutdown (p)
     host_callback *p;
{
  int i, next, j;
  for (i = 0; i < MAX_CALLBACK_FDS; i++)
    {
      int do_close = 1;

      /* Zero out all pipe state.  Don't call callbacks for non-empty
	 pipes; the target program has likely terminated at this point
	 or we're called at initialization time.  */
      p->ispipe[i] = 0;
      p->pipe_buffer[i].size = 0;
      p->pipe_buffer[i].buffer = NULL;

      next = p->fd_buddy[i];
      if (next < 0)
	continue;
      do
	{
	  j = next;
	  if (j == MAX_CALLBACK_FDS)
	    do_close = 0;
	  next = p->fd_buddy[j];
	  p->fd_buddy[j] = -1;
	  /* At the initial call of os_init, we got -1, 0, 0, 0, ...  */
	  if (next < 0)
	    {
	      p->fd_buddy[i] = -1;
	      do_close = 0;
	      break;
	    }
	}
      while (j != i);
      if (do_close)
	close (p->fdmap[i]);
    }
  return 1;
}

static int
os_init (p)
     host_callback *p;
{
  int i;

  os_shutdown (p);
  for (i = 0; i < 3; i++)
    {
      p->fdmap[i] = i;
      p->fd_buddy[i] = i - 1;
    }
  p->fd_buddy[0] = MAX_CALLBACK_FDS;
  p->fd_buddy[MAX_CALLBACK_FDS] = 2;

  p->syscall_map = cb_init_syscall_map;
  p->errno_map = cb_init_errno_map;
  p->open_map = cb_init_open_map;

  return 1;
}

/* DEPRECATED */

/* VARARGS */
static void
os_printf_filtered (host_callback *p ATTRIBUTE_UNUSED, const char *format, ...)
{
  va_list args;
  va_start (args, format);

  vfprintf (stdout, format, args);
  va_end (args);
}

/* VARARGS */
static void
os_vprintf_filtered (host_callback *p ATTRIBUTE_UNUSED, const char *format, va_list args)
{
  vprintf (format, args);
}

/* VARARGS */
static void
os_evprintf_filtered (host_callback *p ATTRIBUTE_UNUSED, const char *format, va_list args)
{
  vfprintf (stderr, format, args);
}

/* VARARGS */
static void
os_error (host_callback *p ATTRIBUTE_UNUSED, const char *format, ...)
{
  va_list args;
  va_start (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, "\n");

  va_end (args);
  exit (1);
}

host_callback default_callback =
{
  os_close,
  os_get_errno,
  os_isatty,
  os_lseek,
  os_open,
  os_read,
  os_read_stdin,
  os_rename,
  os_system,
  os_time,
  os_unlink,
  os_write,
  os_write_stdout,
  os_flush_stdout,
  os_write_stderr,
  os_flush_stderr,

  os_stat,
  os_fstat,
  os_lstat,

  os_ftruncate,
  os_truncate,

  os_pipe,
  os_pipe_empty,
  os_pipe_nonempty,

  os_poll_quit,

  os_shutdown,
  os_init,

  os_printf_filtered,  /* deprecated */

  os_vprintf_filtered,
  os_evprintf_filtered,
  os_error,

  0, 		/* last errno */

  { 0, },	/* fdmap */
  { -1, },	/* fd_buddy */
  { 0, },	/* ispipe */
  { { 0, 0 }, }, /* pipe_buffer */

  0, /* syscall_map */
  0, /* errno_map */
  0, /* open_map */
  0, /* signal_map */
  0, /* stat_map */

  /* Defaults expected to be overridden at initialization, where needed.  */
  BFD_ENDIAN_UNKNOWN, /* target_endian */
  4, /* target_sizeof_int */

  HOST_CALLBACK_MAGIC,
};

/* Read in a file describing the target's system call values.
   E.g. maybe someone will want to use something other than newlib.
   This assumes that the basic system call recognition and value passing/
   returning is supported.  So maybe some coding/recompilation will be
   necessary, but not as much.

   If an error occurs, the existing mapping is not changed.  */

CB_RC
cb_read_target_syscall_maps (cb, file)
     host_callback *cb;
     const char *file;
{
  CB_TARGET_DEFS_MAP *syscall_map, *errno_map, *open_map, *signal_map;
  const char *stat_map;
  FILE *f;

  if ((f = fopen (file, "r")) == NULL)
    return CB_RC_ACCESS;

  /* ... read in and parse file ... */

  fclose (f);
  return CB_RC_NO_MEM; /* FIXME:wip */

  /* Free storage allocated for any existing maps.  */
  if (cb->syscall_map)
    free (cb->syscall_map);
  if (cb->errno_map)
    free (cb->errno_map);
  if (cb->open_map)
    free (cb->open_map);
  if (cb->signal_map)
    free (cb->signal_map);
  if (cb->stat_map)
    free ((PTR) cb->stat_map);

  cb->syscall_map = syscall_map;
  cb->errno_map = errno_map;
  cb->open_map = open_map;
  cb->signal_map = signal_map;
  cb->stat_map = stat_map;

  return CB_RC_OK;
}

/* Translate the target's version of a syscall number to the host's.
   This isn't actually the host's version, rather a canonical form.
   ??? Perhaps this should be renamed to ..._canon_syscall.  */

int
cb_target_to_host_syscall (cb, target_val)
     host_callback *cb;
     int target_val;
{
  CB_TARGET_DEFS_MAP *m;

  for (m = &cb->syscall_map[0]; m->target_val != -1; ++m)
    if (m->target_val == target_val)
      return m->host_val;

  return -1;
}

/* FIXME: sort tables if large.
   Alternatively, an obvious improvement for errno conversion is
   to machine generate a function with a large switch().  */

/* Translate the host's version of errno to the target's.  */

int
cb_host_to_target_errno (cb, host_val)
     host_callback *cb;
     int host_val;
{
  CB_TARGET_DEFS_MAP *m;

  for (m = &cb->errno_map[0]; m->host_val; ++m)
    if (m->host_val == host_val)
      return m->target_val;

  /* ??? Which error to return in this case is up for grabs.
     Note that some missing values may have standard alternatives.
     For now return 0 and require caller to deal with it.  */
  return 0;
}

/* Given a set of target bitmasks for the open system call,
   return the host equivalent.
   Mapping open flag values is best done by looping so there's no need
   to machine generate this function.  */

int
cb_target_to_host_open (cb, target_val)
     host_callback *cb;
     int target_val;
{
  int host_val = 0;
  CB_TARGET_DEFS_MAP *m;

  for (m = &cb->open_map[0]; m->host_val != -1; ++m)
    {
      switch (m->target_val)
	{
	  /* O_RDONLY can be (and usually is) 0 which needs to be treated
	     specially.  */
	case TARGET_O_RDONLY :
	case TARGET_O_WRONLY :
	case TARGET_O_RDWR :
	  if ((target_val & (TARGET_O_RDONLY | TARGET_O_WRONLY | TARGET_O_RDWR))
	      == m->target_val)
	    host_val |= m->host_val;
	  /* Handle the host/target differentiating between binary and
             text mode.  Only one case is of importance */
#if ! defined (TARGET_O_BINARY) && defined (O_BINARY)
	  host_val |= O_BINARY;
#endif
	  break;
	default :
	  if ((m->target_val & target_val) == m->target_val)
	    host_val |= m->host_val;
	  break;
	}
    }

  return host_val;
}

/* Utility for e.g. cb_host_to_target_stat to store values in the target's
   stat struct.  */

void
cb_store_target_endian (cb, p, size, val)
     host_callback *cb;
     char *p;
     int size;
     long val; /* ??? must be as big as target word size */
{
  if (cb->target_endian == BFD_ENDIAN_BIG)
    {
      p += size;
      while (size-- > 0)
	{
	  *--p = val;
	  val >>= 8;
	}
    }
  else
    {
      while (size-- > 0)
	{
	  *p++ = val;
	  val >>= 8;
	}
    }
}

/* Translate a host's stat struct into a target's.
   If HS is NULL, just compute the length of the buffer required,
   TS is ignored.

   The result is the size of the target's stat struct,
   or zero if an error occurred during the translation.  */

int
cb_host_to_target_stat (cb, hs, ts)
     host_callback *cb;
     const struct stat *hs;
     PTR ts;
{
  const char *m = cb->stat_map;
  char *p;

  if (hs == NULL)
    ts = NULL;
  p = ts;

  while (m)
    {
      char *q = strchr (m, ',');
      int size;

      /* FIXME: Use sscanf? */
      if (q == NULL)
	{
	  /* FIXME: print error message */
	  return 0;
	}
      size = atoi (q + 1);
      if (size == 0)
	{
	  /* FIXME: print error message */
	  return 0;
	}

      if (hs != NULL)
	{
	  if (0)
	    ;
	  /* Defined here to avoid emacs indigestion on a lone "else".  */
#undef ST_x
#define ST_x(FLD)					\
	  else if (strncmp (m, #FLD, q - m) == 0)	\
	    cb_store_target_endian (cb, p, size, hs->FLD)

#ifdef HAVE_STRUCT_STAT_ST_DEV
	  ST_x (st_dev);
#endif
#ifdef HAVE_STRUCT_STAT_ST_INO
	  ST_x (st_ino);
#endif
#ifdef HAVE_STRUCT_STAT_ST_MODE
	  ST_x (st_mode);
#endif
#ifdef HAVE_STRUCT_STAT_ST_NLINK
	  ST_x (st_nlink);
#endif
#ifdef HAVE_STRUCT_STAT_ST_UID
	  ST_x (st_uid);
#endif
#ifdef HAVE_STRUCT_STAT_ST_GID
	  ST_x (st_gid);
#endif
#ifdef HAVE_STRUCT_STAT_ST_RDEV
	  ST_x (st_rdev);
#endif
#ifdef HAVE_STRUCT_STAT_ST_SIZE
	  ST_x (st_size);
#endif
#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE
	  ST_x (st_blksize);
#endif
#ifdef HAVE_STRUCT_STAT_ST_BLOCKS
	  ST_x (st_blocks);
#endif
#ifdef HAVE_STRUCT_STAT_ST_ATIME
	  ST_x (st_atime);
#endif
#ifdef HAVE_STRUCT_STAT_ST_MTIME
	  ST_x (st_mtime);
#endif
#ifdef HAVE_STRUCT_STAT_ST_CTIME
	  ST_x (st_ctime);
#endif
#undef ST_x
	  /* FIXME:wip */
	  else
	    /* Unsupported field, store 0.  */
	    cb_store_target_endian (cb, p, size, 0);
	}

      p += size;
      m = strchr (q, ':');
      if (m)
	++m;
    }

  return p - (char *) ts;
}

/* Cover functions to the vfprintf callbacks.

   ??? If one thinks of the callbacks as a subsystem onto itself [or part of
   a larger "remote target subsystem"] with a well defined interface, then
   one would think that the subsystem would provide these.  However, until
   one is allowed to create such a subsystem (with its own source tree
   independent of any particular user), such a critter can't exist.  Thus
   these functions are here for the time being.  */

void
sim_cb_printf (host_callback *p, const char *fmt, ...)
{
  va_list ap;

  va_start (ap, fmt);
  p->vprintf_filtered (p, fmt, ap);
  va_end (ap);
}

void
sim_cb_eprintf (host_callback *p, const char *fmt, ...)
{
  va_list ap;

  va_start (ap, fmt);
  p->evprintf_filtered (p, fmt, ap);
  va_end (ap);
}

int
cb_is_stdin (host_callback *cb, int fd)
{
  return fdbad (cb, fd) ? 0 : fdmap (cb, fd) == 0;
}

int
cb_is_stdout (host_callback *cb, int fd)
{
  return fdbad (cb, fd) ? 0 : fdmap (cb, fd) == 1;
}

int
cb_is_stderr (host_callback *cb, int fd)
{
  return fdbad (cb, fd) ? 0 : fdmap (cb, fd) == 2;
}
@


1.33
log
@	PR 14072
	* wrapper.c: Include config.h before system header files.

	* callback.c: Include config.h before system header files.
	* cgen-trace.c: Likewise.
	* cgen-utils.c: Likewise.
	* gentmap.c: Likewise.

	* sim-if.c: Include config.h before system header files.

	* compile.c: Include config.h before system header files.
	* sim-main.h: Likewise.

	* gdb-if.c: Include config.h before system header files.
	* load.c: Likewise.
	* syscalls.c: Likewise.
	* trace.c: Likewise.

	* interp.c: Include config.h before system header files.
@
text
@d2 1
a2 2
   Copyright 1995-1997, 2000, 2002-2004, 2007-2012 Free Software
   Foundation, Inc.
@


1.32
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d27 1
@


1.31
log
@sim: fix func call style (space before paren)

Committed this as obvious:
	-foo(...);
	+foo (...);

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d2 2
a3 2
   Copyright 1995, 1996, 1997, 2000, 2002, 2003, 2004, 2007, 2008, 2009, 2010,
   2011 Free Software Foundation, Inc.
@


1.31.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 2
   Copyright 1995-1997, 2000, 2002-2004, 2007-2012 Free Software
   Foundation, Inc.
@


1.30
log
@sim: common: trim trailing whitespace
@
text
@d234 1
a234 1
  int k = win32pollquit();
@


1.29
log
@	* callback.c (fdbad): Return EBADF rather than EINVAL for bad
	file descriptors.
@
text
@d105 1
a105 1
static int 
d117 1
a117 1
static int 
d130 1
a130 1
static int 
d138 1
a138 1
static int 
d226 1
a226 1
      else 
d246 1
a246 1
static int 
d254 1
a254 1
static int 
d269 1
a269 1
static int 
d285 1
a285 1
static int 
d311 1
a311 1
static int 
d368 1
a368 1
static int 
d377 1
a377 1
static int 
d449 1
a449 1
static int 
d465 1
a465 1
static int 
d481 1
a481 1
static int 
d499 1
a499 1
static long 
d508 1
a508 1
static int 
d590 1
a590 1
static int 
d847 1
a847 1
	
@


1.28
log
@run copyright.sh for 2011.
@
text
@d124 1
a124 1
      p->last_errno = EINVAL;
@


1.27
log
@	* callback.c (os_lseek): Call wrap on lseek result.
@
text
@d2 2
a3 2
   Copyright 1995, 1996, 1997, 2000, 2002, 2003, 2004, 2007, 2008, 2009, 2010
   Free Software Foundation, Inc.
@


1.26
log
@Update copyright notices to add year 2010.
@
text
@d281 1
a281 1
  result = lseek (fdmap (p, fd), off, way);
@


1.25
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 2000, 2002, 2003, 2004, 2007, 2008, 2009
@


1.24
log
@	* callback.c (os_error): Mark as being a noreturn function.
	* sim-io.h (sim_io_error): Similar for sim_io_error.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 2000, 2002, 2003, 2004, 2007, 2008
@


1.23
log
@	Updated copyright notices for most files.
@
text
@d94 5
a98 1
static void os_error PARAMS ((host_callback *, const char *, ...));
@


1.23.16.1
log
@Check in ARCompact simulator.  A valid configuration is arc-elf.
This is not quite finished and has most likely a few files that are
obsolete & not used, but it's good enough to run gcc regression tests.
@
text
@d95 2
a96 2
int fdmap PARAMS ((host_callback *, int));
int fdbad PARAMS ((host_callback *, int));
d113 1
a113 1
int 
d126 1
a126 1
int 
@


1.23.16.2
log
@gdb/insight for ARCompact (from Richard Stuckey)
@
text
@a363 3
/* Descriptors 0 / 1 / 2 might have been subject to freopen, as in
   27_io/objects/char/12048-[1-4].cc , and thus correspond to a different
   host file descriptor.  */
d370 1
a370 1
  os_read (p, 0, buf, len);
d436 1
a436 1
      result = fwrite (buf, 1, len, stdout);
d439 1
a439 1
      result = fwrite (buf, 1, len, stderr);
d451 1
a451 1
  os_write (p, 1, buf, len);
d467 1
a467 1
  os_write (p, 2, buf, len);
d1139 18
@


1.22
log
@2007-10-11  Jesper Nilsson  <jesper.nilsson@@axis.com>

	* callback.c (cb_is_stdin, cb_is_stdout, cb_is_stderr): Add functions.
	* syscall.c (cb_syscall): Test for stdin/out/err, not just fd 0/1/2.

2007-10-11  Jesper Nilsson  <jesper.nilsson@@axis.com>

	* callback.h (cb_is_stdin, cb_is_stdout, cb_is_stderr): Add prototypes.

2007-10-11  Jesper Nilsson  <jesper.nilsson@@axis.com>

	* sim/cris/c/freopen2.c: Added testcase.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 2000, 2002, 2003, 2004, 2007
@


1.21
log
@2007-10-11  Jesper Nilsson  <jesper.nilsson@@axis.com>

	* callback.c (cb_is_stdin): Add.
	* syscall.c (cb_syscall): Test for stdin, not just fd 0.

2007-10-11  Jesper Nilsson  <jesper.nilsson@@axis.com>

	* callback.h (cb_is_stdin): Add prototype.
@
text
@d1146 11
@


1.20
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d1139 7
@


1.19
log
@Copyright updates for 2007.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 2
   along with GAS; see the file COPYING.  If not, write to the Free Software
   Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.18
log
@	* callback.c: Remove ANSI_PROTOTYPES conditional code.
	* sim-load.c: Likewise.
	* syscall.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 2000, 2002, 2003, 2004
@


1.17
log
@2005-04-29  Paul Brook  <paul@@codesourcery.com>

	* common/callback.c (PIPE_BUF): Provide default refinition.
	(os_lstat): Use stat if lstat is not available on the host.
	(os_ftruncate): Return EINVAL if not available on the host.
	(os_truncate): Ditto.
	* common/configure.ac: Check for lstat, truncate and ftruncate.
	* common/configure: Regenerate.
	* common/config.in: Regenerate.
@
text
@a28 1
#ifdef ANSI_PROTOTYPES
a29 3
#else
#include <varargs.h>
#endif
a753 1
#ifdef ANSI_PROTOTYPES
a754 5
#else
os_printf_filtered (p, va_alist)
     host_callback *p;
     va_dcl
#endif
a756 1
#ifdef ANSI_PROTOTYPES
a757 6
#else
  char *format;

  va_start (args);
  format = va_arg (args, char *);
#endif
a764 1
#ifdef ANSI_PROTOTYPES
a765 6
#else
os_vprintf_filtered (p, format, args)
     host_callback *p;
     const char *format;
     va_list args;
#endif
a771 1
#ifdef ANSI_PROTOTYPES
a772 6
#else
os_evprintf_filtered (p, format, args)
     host_callback *p;
     const char *format;
     va_list args;
#endif
a778 1
#ifdef ANSI_PROTOTYPES
a779 5
#else
os_error (p, va_alist)
     host_callback *p;
     va_dcl
#endif
a781 1
#ifdef ANSI_PROTOTYPES
a782 6
#else
  char *format;

  va_start (args);
  format = va_arg (args, char *);
#endif
@


1.16
log
@* callback.c (os_fstat): Don't declare 't' unless it's used.
@
text
@d63 4
d584 1
d586 3
d607 1
d609 4
d622 1
d624 4
@


1.16.2.1
log
@2005-04-29  Paul Brook  <paul@@codesourcery.com>

	* sim/common/callback.c (PIPE_BUF): Provide default refinition.
	(os_lstat): Use stat if lstat is not available on the host.
	(os_ftruncate): Return EINVAL if not available on the host.
	(os_truncate): Ditto.
	* sim/common/configure.ac: Check for lstat, truncate and ftruncate.
	* sim/common/configure: Regenerate.
	* sim/common/config.in: Regenerate.
@
text
@a62 4
#ifndef PIPE_BUF
#define PIPE_BUF 512
#endif

a579 1
#ifdef HAVE_LSTAT
a580 3
#else
  return wrap (p, stat (file, buf));
#endif
a598 1
#ifdef HAVE_FTRUNCATE
a599 4
#else
  p->last_errno = EINVAL;
  result = -1;
#endif
a608 1
#ifdef HAVE_TRUNCATE
a609 4
#else
  p->last_errno = EINVAL;
  return -1;
#endif
@


1.15
log
@	* syscall.c (cb_syscall) <case CB_SYS_pipe>: New case.
	* callback.c [HAVE_LIMITS_H]: Include limits.h.
  	Include libiberty.h.
	(os_close, os_read, os_write, os_fstat, os_ftruncate): Support fd
	being either end of a pipe.
	(os_pipe, os_pipe_empty, os_pipe_nonempty): New functions.
	(os_shutdown): Clear pipe state.
	(default_callback): Initialize new members.
@
text
@d537 1
d539 1
@


1.14
log
@	* callback.c (default_callback): Initialize target_endian.
	(cb_store_target_endian): Renamed from store, new first parameter
	host_callback *cb, drop last parameter big_p.  Take endianness
	from cb.
	(cb_host_to_target_stat): Change to use cb_store_target_endian.
	Remove variable big_p.
	* nrun.c (main): Initialize default_callback.target_endian.
@
text
@d45 4
d56 2
d153 42
a194 1
    result = wrap (p, close (fdmap (p, fd)));
d320 41
d387 43
d534 30
d590 5
d611 61
d680 7
d841 4
d860 2
d871 1
@


1.13
log
@	* syscall.c (cb_syscall) <case CB_SYS_lstat>: New case.
	* callback.c (os_lstat): New function.
@
text
@d629 3
d763 1
a763 1
/* Utility for cb_host_to_target_stat to store values in the target's
d766 3
a768 2
static void
store (p, size, val, big_p)
a771 1
     int big_p;
d773 1
a773 1
  if (big_p)
a806 1
  int big_p = 0;
d838 1
a838 1
	    store (p, size, hs->FLD, big_p)
d882 2
a883 1
	    store (p, size, 0, big_p); /* unsupported field, store 0 */
@


1.12
log
@Bah, forgot to commit the trivial fix I pointed out myself after applying patch for previous change
@
text
@d410 10
d602 1
@


1.11
log
@	* configure.in (SIM_CHECK_MEMBERS): Call for struct stat members
	st_dev, st_ino, st_mode, st_nlink, st_uid, st_gid, st_rdev,
	st_size, st_blksize, st_blocks, st_atime, st_mtime and st_ctime.
	* aclocal.m4 (SIM_CHECK_MEMBER, SIM_CHECK_MEMBERS_1)
	(SIM_CHECK_MEMBERS): New macros.
	* callback.c (cb_host_to_target_stat): Use temporary macro ST_x
	for struct stat member test and write.  Add ST_x calls for each
	struct stat member tested in configure.in.  Wrap each ST_x call in
	#ifdef of configure macro for that member.
	* configure, config.in: Regenerate.
@
text
@d819 1
a819 1
	  if (1)
@


1.10
log
@	* callback.c (os_shutdown): Fix bug in last change: actually
	mark file descriptors as available on startup.
@
text
@d819 48
a866 4
	  if (strncmp (m, "st_dev", q - m) == 0)
	    store (p, size, hs->st_dev, big_p);
	  else if (strncmp (m, "st_ino", q - m) == 0)
	    store (p, size, hs->st_ino, big_p);
@


1.9
log
@2004-06-25  J"orn Rennecke <joern.rennecke@@superh.com>

include/gdb:
	* callback.h (host_callback_struct): Replace members fdopen and
        alwaysopen with fd_buddy.
sim/common:
	* callback.c: Changed all users.
@
text
@d456 1
@


1.8
log
@	* callback.c: Update copyright dates.
	* run.c: Likewise.
	* sim-basics.h: Likewise.
	* sim-load.c: Likewise.
	* syscall.c: Likewise.
From Maciej W. Rozycki  <macro@@ds2.pg.gda.pl>
	* callback.c: Include cconfig.h instead of config.h.
	* run.c: Likewise.
	* sim-basics.h: Likewise.
	* sim-load.c: Likewise.
	* syscall.c: Likewise.
@
text
@d113 1
a113 1
  if (fd < 0 || fd > MAX_CALLBACK_FDS || !p->fdopen[fd])
d135 1
d140 9
a148 3
  result = wrap (p, close (fdmap (p, fd)));
  if (result == 0 && !p->alwaysopen[fd])
    p->fdopen[fd] = 0;
d244 1
a244 1
      if (!p->fdopen[i])
d252 1
a252 1
	  p->fdopen[i] = 1;
d438 1
a438 1
  int i;
d441 21
a461 1
      if (p->fdopen[i] && !p->alwaysopen[i]) {
a462 2
	p->fdopen[i] = 0;
      }
d477 1
a477 2
      p->fdopen[i] = 1;
      p->alwaysopen[i] = 1;
d479 2
d609 1
a609 2
  { 0, },	/* fdopen */
  { 0, },	/* alwaysopen */
@


1.7
log
@2003-10-21  Andrew Cagney  <cagney@@redhat.com>

	* callback.c (os_truncate): Call "truncate", and not "stat".
@
text
@d2 2
a3 1
   Copyright 1995, 1996, 1997 Free Software Foundation, Inc.
d26 1
a26 1
#include "config.h"
@


1.7.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 1
a2 2
   Copyright 1995, 1996, 1997, 2000, 2002, 2003, 2004
   Free Software Foundation, Inc.
d25 1
a25 1
#include "cconfig.h"
d112 1
a112 1
  if (fd < 0 || fd > MAX_CALLBACK_FDS || p->fd_buddy[fd] < 0)
a133 1
  int i, next;
d138 3
a140 9
  /* If this file descripter has one or more buddies (originals /
     duplicates from a dup), just remove it from the circular list.  */
  for (i = fd; (next = p->fd_buddy[i]) != fd; )
    i = next;
  if (fd != i)
    p->fd_buddy[i] = p->fd_buddy[fd];
  else
    result = wrap (p, close (fdmap (p, fd)));
  p->fd_buddy[fd] = -1;
d236 1
a236 1
      if (p->fd_buddy[i] < 0)
d244 1
a244 1
	  p->fd_buddy[i] = i;
d430 1
a430 1
  int i, next, j;
d433 1
a433 22
      int do_close = 1;

      next = p->fd_buddy[i];
      if (next < 0)
	continue;
      do
	{
	  j = next;
	  if (j == MAX_CALLBACK_FDS)
	    do_close = 0;
	  next = p->fd_buddy[j];
	  p->fd_buddy[j] = -1;
	  /* At the initial call of os_init, we got -1, 0, 0, 0, ...  */
	  if (next < 0)
	    {
	      p->fd_buddy[i] = -1;
	      do_close = 0;
	      break;
	    }
	}
      while (j != i);
      if (do_close)
d435 2
d451 2
a452 1
      p->fd_buddy[i] = i - 1;
a453 2
  p->fd_buddy[0] = MAX_CALLBACK_FDS;
  p->fd_buddy[MAX_CALLBACK_FDS] = 2;
d582 2
a583 1
  { -1, },	/* fd_buddy */
@


1.6
log
@include/gdb:
        * callback.h (struct host_callback_struct): New members ftruncate
        and truncate.
gdb:
sim/common:
        * callback.c (os_ftruncate, os_truncate): New functions.
        (default_callback): Initialize ftruncate and truncate members.
sim/sh:
        * syscall.h (SYS_truncate, SYS_ftruncate): Define.
        * interp.c (trap): Add support for SYS_ftruncate and SYS_truncate.
@
text
@d423 1
a423 1
  return wrap (p, stat (file, len));
@


1.5
log
@Move include/callback.h and include/remote-sim.h to include/gdb/.
Update accordingly.
@
text
@d402 24
d564 3
@


1.5.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a401 24
static int 
os_ftruncate (p, fd, len)
     host_callback *p;
     int fd;
     long len;
{
  int result;

  result = fdbad (p, fd);
  if (result)
    return result;
  result = wrap (p, ftruncate (fdmap (p, fd), len));
  return result;
}

static int
os_truncate (p, file, len)
     host_callback *p;
     const char *file;
     long len;
{
  return wrap (p, truncate (file, len));
}

a539 3

  os_ftruncate,
  os_truncate,
@


1.5.8.1
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a401 24
static int 
os_ftruncate (p, fd, len)
     host_callback *p;
     int fd;
     long len;
{
  int result;

  result = fdbad (p, fd);
  if (result)
    return result;
  result = wrap (p, ftruncate (fdmap (p, fd), len));
  return result;
}

static int
os_truncate (p, file, len)
     host_callback *p;
     const char *file;
     long len;
{
  return wrap (p, truncate (file, len));
}

a539 3

  os_ftruncate,
  os_truncate,
@


1.4
log
@[ common/ChangeLog ]
2002-05-01  Chris Demetriou  <cgd@@broadcom.com>

        * callback.c: Use 'deprecated' rather than 'depreciated.'

[ igen/ChangeLog ]
2002-05-01  Chris Demetriou  <cgd@@broadcom.com>

        * igen.c: Use 'deprecated' rather than 'depreciated.'

[ mips/ChangeLog ]
2002-05-01  Chris Demetriou  <cgd@@broadcom.com>

        * interp.c: Use 'deprecated' rather than 'depreciated.'
        * sim-main.h: Likewise.
@
text
@d49 1
a49 1
#include "callback.h"
@


1.4.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d49 1
a49 1
#include "gdb/callback.h"
@


1.4.4.1
log
@merge from trunk
@
text
@d49 1
a49 1
#include "gdb/callback.h"
@


1.3
log
@2002-02-10  Chris Demetriou  <cgd@@broadcom.com>

        * callback.c: Fix some spelling errors.
        * hw-device.h: Likewise.
        * hw-tree.c: Likewise.
        * sim-abort.c: Likewise.
        * sim-alu.h: Likewise.
        * sim-core.h: Likewise.
        * sim-events.c: Likewise.
        * sim-events.h: Likewise.
        * sim-fpu.h: Likewise.
        * sim-profile.h: Likewise.
        * sim-utils.c: Likewise.
@
text
@d438 1
a438 1
/* DEPRECIATED */
@


1.2
log
@Fix compile time warning messages.
@
text
@d729 1
a729 1
   or zero if an error occured during the translation.  */
@


1.1
log
@Initial revision
@
text
@d309 1
a309 1
     host_callback *p;
d318 1
a318 1
     host_callback *p;
d325 1
a325 1
     host_callback *p;
d334 1
a334 1
     host_callback *p;
d443 1
a443 1
os_printf_filtered (host_callback *p, const char *format, ...)
d467 1
a467 1
os_vprintf_filtered (host_callback *p, const char *format, va_list args)
d481 1
a481 1
os_evprintf_filtered (host_callback *p, const char *format, va_list args)
d495 1
a495 1
os_error (host_callback *p, const char *format, ...)
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@

