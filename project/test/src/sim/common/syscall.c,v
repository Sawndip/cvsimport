head	1.22;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.22
	gdb_7_6-2013-04-26-release:1.22
	gdb_7_6-branch:1.22.0.2
	gdb_7_6-2013-03-12-branchpoint:1.22
	gdb_7_5_1-2012-11-29-release:1.21
	gdb_7_5-2012-08-17-release:1.21
	gdb_7_5-branch:1.21.0.2
	gdb_7_5-2012-07-18-branchpoint:1.21
	gdb_7_4_1-2012-04-26-release:1.20.2.1
	gdb_7_4-2012-01-24-release:1.20.2.1
	gdb_7_4-branch:1.20.0.2
	gdb_7_4-2011-12-13-branchpoint:1.20
	gdb_7_3_1-2011-09-04-release:1.18
	gdb_7_3-2011-07-26-release:1.18
	gdb_7_3-branch:1.18.0.2
	gdb_7_3-2011-04-01-branchpoint:1.18
	gdb_7_2-2010-09-02-release:1.16
	gdb_7_2-branch:1.16.0.4
	gdb_7_2-2010-07-07-branchpoint:1.16
	gdb_7_1-2010-03-18-release:1.16
	gdb_7_1-branch:1.16.0.2
	gdb_7_1-2010-02-18-branchpoint:1.16
	gdb_7_0_1-2009-12-22-release:1.15
	gdb_7_0-2009-10-06-release:1.15
	gdb_7_0-branch:1.15.0.4
	gdb_7_0-2009-09-16-branchpoint:1.15
	arc-sim-20090309:1.14.16.1
	msnyder-checkpoint-072509-branch:1.15.0.2
	msnyder-checkpoint-072509-branchpoint:1.15
	arc-insight_6_8-branch:1.14.0.16
	arc-insight_6_8-branchpoint:1.14
	insight_6_8-branch:1.14.0.14
	insight_6_8-branchpoint:1.14
	reverse-20081226-branch:1.14.0.12
	reverse-20081226-branchpoint:1.14
	multiprocess-20081120-branch:1.14.0.10
	multiprocess-20081120-branchpoint:1.14
	reverse-20080930-branch:1.14.0.8
	reverse-20080930-branchpoint:1.14
	reverse-20080717-branch:1.14.0.6
	reverse-20080717-branchpoint:1.14
	msnyder-reverse-20080609-branch:1.14.0.4
	msnyder-reverse-20080609-branchpoint:1.14
	drow-reverse-20070409-branch:1.10.0.2
	drow-reverse-20070409-branchpoint:1.10
	gdb_6_8-2008-03-27-release:1.14
	gdb_6_8-branch:1.14.0.2
	gdb_6_8-2008-02-26-branchpoint:1.14
	gdb_6_7_1-2007-10-29-release:1.11
	gdb_6_7-2007-10-10-release:1.11
	gdb_6_7-branch:1.11.0.2
	gdb_6_7-2007-09-07-branchpoint:1.11
	insight_6_6-20070208-release:1.9
	gdb_6_6-2006-12-18-release:1.9
	gdb_6_6-branch:1.9.0.26
	gdb_6_6-2006-11-15-branchpoint:1.9
	insight_6_5-20061003-release:1.9
	gdb-csl-symbian-6_4_50_20060226-12:1.9
	gdb-csl-sourcerygxx-3_4_4-25:1.9
	nickrob-async-20060828-mergepoint:1.9
	gdb-csl-symbian-6_4_50_20060226-11:1.9
	gdb-csl-sourcerygxx-4_1-17:1.9
	gdb-csl-20060226-branch-local-2:1.9
	gdb-csl-sourcerygxx-4_1-14:1.9
	gdb-csl-sourcerygxx-4_1-13:1.9
	gdb-csl-sourcerygxx-4_1-12:1.9
	gdb-csl-sourcerygxx-3_4_4-21:1.9
	gdb_6_5-20060621-release:1.9
	gdb-csl-sourcerygxx-4_1-9:1.9
	gdb-csl-sourcerygxx-4_1-8:1.9
	gdb-csl-sourcerygxx-4_1-7:1.9
	gdb-csl-arm-2006q1-6:1.9
	gdb-csl-sourcerygxx-4_1-6:1.9
	gdb-csl-symbian-6_4_50_20060226-10:1.9
	gdb-csl-symbian-6_4_50_20060226-9:1.9
	gdb-csl-symbian-6_4_50_20060226-8:1.9
	gdb-csl-coldfire-4_1-11:1.9
	gdb-csl-sourcerygxx-3_4_4-19:1.9
	gdb-csl-coldfire-4_1-10:1.9
	gdb_6_5-branch:1.9.0.24
	gdb_6_5-2006-05-14-branchpoint:1.9
	gdb-csl-sourcerygxx-4_1-5:1.9
	nickrob-async-20060513-branch:1.9.0.22
	nickrob-async-20060513-branchpoint:1.9
	gdb-csl-sourcerygxx-4_1-4:1.9
	msnyder-reverse-20060502-branch:1.9.0.20
	msnyder-reverse-20060502-branchpoint:1.9
	gdb-csl-morpho-4_1-4:1.9
	gdb-csl-sourcerygxx-3_4_4-17:1.9
	readline_5_1-import-branch:1.9.0.18
	readline_5_1-import-branchpoint:1.9
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.9
	gdb-csl-symbian-20060226-branch:1.9.0.16
	gdb-csl-symbian-20060226-branchpoint:1.9
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.9
	msnyder-reverse-20060331-branch:1.9.0.14
	msnyder-reverse-20060331-branchpoint:1.9
	gdb-csl-available-20060303-branch:1.9.0.12
	gdb-csl-available-20060303-branchpoint:1.9
	gdb-csl-20060226-branch:1.9.0.10
	gdb-csl-20060226-branchpoint:1.9
	gdb_6_4-20051202-release:1.9
	msnyder-fork-checkpoint-branch:1.9.0.8
	msnyder-fork-checkpoint-branchpoint:1.9
	gdb-csl-gxxpro-6_3-branch:1.9.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.9
	gdb_6_4-branch:1.9.0.4
	gdb_6_4-2005-11-01-branchpoint:1.9
	gdb-csl-arm-20051020-branch:1.9.0.2
	gdb-csl-arm-20051020-branchpoint:1.9
	msnyder-tracepoint-checkpoint-branch:1.8.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.8
	gdb-csl-arm-20050325-2005-q1b:1.8
	gdb-csl-arm-20050325-2005-q1a:1.8
	csl-arm-20050325-branch:1.8.0.2
	csl-arm-20050325-branchpoint:1.8
	gdb_6_3-20041109-release:1.3
	gdb_6_3-branch:1.3.0.4
	gdb_6_3-20041019-branchpoint:1.3
	drow_intercu-merge-20040921:1.3
	drow_intercu-merge-20040915:1.3
	jimb-gdb_6_2-e500-branch:1.3.0.6
	jimb-gdb_6_2-e500-branchpoint:1.3
	gdb_6_2-20040730-release:1.3
	gdb_6_2-branch:1.3.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.3
	gdb_6_1_1-20040616-release:1.2
	gdb_6_1-2004-04-05-release:1.2
	drow_intercu-merge-20040402:1.2
	drow_intercu-merge-20040327:1.2
	ezannoni_pie-20040323-branch:1.2.0.62
	ezannoni_pie-20040323-branchpoint:1.2
	cagney_tramp-20040321-mergepoint:1.2
	cagney_tramp-20040309-branch:1.2.0.60
	cagney_tramp-20040309-branchpoint:1.2
	gdb_6_1-branch:1.2.0.58
	gdb_6_1-2004-03-01-gmt-branchpoint:1.2
	drow_intercu-20040221-branch:1.2.0.56
	drow_intercu-20040221-branchpoint:1.2
	cagney_bfdfile-20040213-branch:1.2.0.54
	cagney_bfdfile-20040213-branchpoint:1.2
	drow-cplus-merge-20040208:1.2
	carlton_dictionary-20040126-merge:1.2
	cagney_bigcore-20040122-branch:1.2.0.52
	cagney_bigcore-20040122-branchpoint:1.2
	drow-cplus-merge-20040113:1.2
	drow-cplus-merge-20031224:1.2
	drow-cplus-merge-20031220:1.2
	carlton_dictionary-20031215-merge:1.2
	drow-cplus-merge-20031214:1.2
	carlton-dictionary-20031111-merge:1.2
	gdb_6_0-2003-10-04-release:1.2
	kettenis_sparc-20030918-branch:1.2.0.50
	kettenis_sparc-20030918-branchpoint:1.2
	carlton_dictionary-20030917-merge:1.2
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.48
	cagney_x86i386-20030821-branch:1.2.0.46
	cagney_x86i386-20030821-branchpoint:1.2
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.2.0.44
	gdb_6_0-2003-06-23-branchpoint:1.2
	jimb-ppc64-linux-20030613-branch:1.2.0.42
	jimb-ppc64-linux-20030613-branchpoint:1.2
	cagney_convert-20030606-branch:1.2.0.40
	cagney_convert-20030606-branchpoint:1.2
	cagney_writestrings-20030508-branch:1.2.0.38
	cagney_writestrings-20030508-branchpoint:1.2
	jimb-ppc64-linux-20030528-branch:1.2.0.36
	jimb-ppc64-linux-20030528-branchpoint:1.2
	carlton_dictionary-20030523-merge:1.2
	cagney_fileio-20030521-branch:1.2.0.34
	cagney_fileio-20030521-branchpoint:1.2
	kettenis_i386newframe-20030517-mergepoint:1.2
	jimb-ppc64-linux-20030509-branch:1.2.0.32
	jimb-ppc64-linux-20030509-branchpoint:1.2
	kettenis_i386newframe-20030504-mergepoint:1.2
	carlton_dictionary-20030430-merge:1.2
	kettenis_i386newframe-20030419-branch:1.2.0.30
	kettenis_i386newframe-20030419-branchpoint:1.2
	carlton_dictionary-20030416-merge:1.2
	cagney_frameaddr-20030409-mergepoint:1.2
	kettenis_i386newframe-20030406-branch:1.2.0.28
	kettenis_i386newframe-20030406-branchpoint:1.2
	cagney_frameaddr-20030403-branchpoint:1.2
	cagney_frameaddr-20030403-branch:1.2.0.26
	cagney_framebase-20030330-mergepoint:1.2
	cagney_framebase-20030326-branch:1.2.0.24
	cagney_framebase-20030326-branchpoint:1.2
	cagney_lazyid-20030317-branch:1.2.0.22
	cagney_lazyid-20030317-branchpoint:1.2
	kettenis-i386newframe-20030316-mergepoint:1.2
	offbyone-20030313-branch:1.2.0.20
	offbyone-20030313-branchpoint:1.2
	kettenis-i386newframe-20030308-branch:1.2.0.18
	kettenis-i386newframe-20030308-branchpoint:1.2
	carlton_dictionary-20030305-merge:1.2
	cagney_offbyone-20030303-branch:1.2.0.16
	cagney_offbyone-20030303-branchpoint:1.2
	carlton_dictionary-20030207-merge:1.2
	interps-20030202-branch:1.2.0.14
	interps-20030202-branchpoint:1.2
	cagney-unwind-20030108-branch:1.2.0.12
	cagney-unwind-20030108-branchpoint:1.2
	carlton_dictionary-20021223-merge:1.2
	gdb_5_3-2002-12-12-release:1.2
	carlton_dictionary-20021115-merge:1.2
	kseitz_interps-20021105-merge:1.2
	kseitz_interps-20021103-merge:1.2
	drow-cplus-merge-20021020:1.2
	drow-cplus-merge-20021025:1.2
	carlton_dictionary-20021025-merge:1.2
	carlton_dictionary-20021011-merge:1.2
	drow-cplus-branch:1.2.0.10
	drow-cplus-branchpoint:1.2
	kseitz_interps-20020930-merge:1.2
	carlton_dictionary-20020927-merge:1.2
	carlton_dictionary-branch:1.2.0.8
	carlton_dictionary-20020920-branchpoint:1.2
	gdb_5_3-branch:1.2.0.6
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.4
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.2
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.1.1.1
	kseitz_interps-20020528-branch:1.1.1.1.0.20
	kseitz_interps-20020528-branchpoint:1.1.1.1
	cagney_regbuf-20020515-branch:1.1.1.1.0.18
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	jimb-macro-020506-branch:1.1.1.1.0.16
	jimb-macro-020506-branchpoint:1.1.1.1
	gdb_5_2-2002-04-29-release:1.1.1.1
	gdb_5_2-branch:1.1.1.1.0.14
	gdb_5_2-2002-03-03-branchpoint:1.1.1.1
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.12
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.10
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.8
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.22
date	2013.01.01.06.41.33;	author brobecke;	state Exp;
branches;
next	1.21;

1.21
date	2012.01.04.08.28.06;	author brobecke;	state Exp;
branches;
next	1.20;

1.20
date	2011.12.03.18.39.43;	author vapier;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2011.05.11.20.02.42;	author vapier;	state Exp;
branches;
next	1.18;

1.18
date	2011.03.15.03.16.17;	author vapier;	state Exp;
branches;
next	1.17;

1.17
date	2011.01.01.15.33.56;	author brobecke;	state Exp;
branches;
next	1.16;

1.16
date	2010.01.01.10.03.27;	author brobecke;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.14.10.53.06;	author brobecke;	state Exp;
branches;
next	1.14;

1.14
date	2008.01.01.22.53.23;	author drow;	state Exp;
branches
	1.14.16.1;
next	1.13;

1.13
date	2007.10.11.18.44.06;	author drow;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.11.18.40.29;	author drow;	state Exp;
branches;
next	1.11;

1.11
date	2007.08.24.14.28.35;	author brobecke;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.09.17.59.16;	author drow;	state Exp;
branches;
next	1.9;

1.9
date	2005.07.08.08.05.35;	author bje;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.28.03.40.54;	author hp;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.15.01.26.40;	author hp;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.13.00.46.05;	author hp;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.13.00.38.38;	author hp;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.08.00.40.30;	author hp;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.10.16.18.03;	author drow;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.09.15.45.45;	author cagney;	state Exp;
branches
	1.2.56.1;
next	1.1;

1.1
date	99.04.16.01.34.59;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.20.2.1
date	2012.01.06.04.54.40;	author brobecke;	state Exp;
branches;
next	;

1.14.16.1
date	2009.03.09.20.36.15;	author amylaar;	state Exp;
branches;
next	1.14.16.2;

1.14.16.2
date	2009.09.11.04.45.57;	author amylaar;	state Exp;
branches;
next	;

1.2.56.1
date	2004.09.16.17.02.03;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.59;	author shebs;	state Exp;
branches
	1.1.1.1.18.1
	1.1.1.1.20.1;
next	;

1.1.1.1.18.1
date	2002.06.15.16.43.22;	author cagney;	state Exp;
branches;
next	;

1.1.1.1.20.1
date	2002.06.20.01.39.02;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* Remote target system call support.
   Copyright 1997-2013 Free Software Foundation, Inc.
   Contributed by Cygnus Solutions.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* This interface isn't intended to be specific to any particular kind
   of remote (hardware, simulator, whatever).  As such, support for it
   (e.g. sim/common/callback.c) should *not* live in the simulator source
   tree, nor should it live in the gdb source tree.  K&R C must be
   supported.  */

#ifdef HAVE_CONFIG_H
#include "cconfig.h"
#endif
#include "ansidecl.h"
#include "libiberty.h"
#include <stdarg.h>
#include <stdio.h>
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#elif defined (HAVE_STRINGS_H)
#include <strings.h>
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#include <errno.h>
#include <fcntl.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "gdb/callback.h"
#include "targ-vals.h"

#ifndef ENOSYS
#define ENOSYS EINVAL
#endif
#ifndef ENAMETOOLONG
#define ENAMETOOLONG EINVAL
#endif

/* Maximum length of a path name.  */
#ifndef MAX_PATH_LEN
#define MAX_PATH_LEN 1024
#endif

/* When doing file read/writes, do this many bytes at a time.  */
#define FILE_XFR_SIZE 4096

/* FIXME: for now, need to consider target word size.  */
#define TWORD long
#define TADDR unsigned long

/* Path to be prepended to syscalls with absolute paths, and to be
   chdir:ed at startup, if not empty.  */
char *simulator_sysroot = "";

/* Utility of cb_syscall to fetch a path name or other string from the target.
   The result is 0 for success or a host errno value.  */

int
cb_get_string (cb, sc, buf, buflen, addr)
     host_callback *cb;
     CB_SYSCALL *sc;
     char *buf;
     int buflen;
     TADDR addr;
{
  char *p, *pend;

  for (p = buf, pend = buf + buflen; p < pend; ++p, ++addr)
    {
      /* No, it isn't expected that this would cause one transaction with
	 the remote target for each byte.  The target could send the
	 path name along with the syscall request, and cache the file
	 name somewhere (or otherwise tweak this as desired).  */
      unsigned int count = (*sc->read_mem) (cb, sc, addr, p, 1);

      if (count != 1)
	return EINVAL;
      if (*p == 0)
	break;
    }
  if (p == pend)
    return ENAMETOOLONG;
  return 0;
}

/* Utility of cb_syscall to fetch a path name.
   The buffer is malloc'd and the address is stored in BUFP.
   The result is that of get_string, but prepended with
   simulator_sysroot if the string starts with '/'.
   If an error occurs, no buffer is left malloc'd.  */

static int
get_path (cb, sc, addr, bufp)
     host_callback *cb;
     CB_SYSCALL *sc;
     TADDR addr;
     char **bufp;
{
  char *buf = xmalloc (MAX_PATH_LEN);
  int result;
  int sysroot_len = strlen (simulator_sysroot);

  result = cb_get_string (cb, sc, buf, MAX_PATH_LEN - sysroot_len, addr);
  if (result == 0)
    {
      /* Prepend absolute paths with simulator_sysroot.  Relative paths
	 are supposed to be relative to a chdir within that path, but at
	 this point unknown where.  */
      if (simulator_sysroot[0] != '\0' && *buf == '/')
	{
	  /* Considering expected rareness of syscalls with absolute
	     file paths (compared to relative file paths and insn
	     execution), it does not seem worthwhile to rearrange things
	     to get rid of the string moves here; we'd need at least an
	     extra call to check the initial '/' in the path.  */
	  memmove (buf + sysroot_len, buf, sysroot_len);
	  memcpy (buf, simulator_sysroot, sysroot_len);
	}

      *bufp = buf;
    }
  else
    free (buf);
  return result;
}

/* Perform a system call on behalf of the target.  */

CB_RC
cb_syscall (cb, sc)
     host_callback *cb;
     CB_SYSCALL *sc;
{
  TWORD result = 0, errcode = 0;

  if (sc->magic != CB_SYSCALL_MAGIC)
    abort ();

  switch (cb_target_to_host_syscall (cb, sc->func))
    {
#if 0 /* FIXME: wip */
    case CB_SYS_argvlen :
      {
	/* Compute how much space is required to store the argv,envp
	   strings so that the program can allocate the space and then
	   call SYS_argv to fetch the values.  */
	int addr_size = cb->addr_size;
	int argc,envc,arglen,envlen;
	const char **argv = cb->init_argv;
	const char **envp = cb->init_envp;

	argc = arglen = 0;
	if (argv)
	  {
	    for ( ; argv[argc]; ++argc)
	      arglen += strlen (argv[argc]) + 1;
	  }
	envc = envlen = 0;
	if (envp)
	  {
	    for ( ; envp[envc]; ++envc)
	      envlen += strlen (envp[envc]) + 1;
	  }
	result = arglen + envlen;
	break;
      }

    case CB_SYS_argv :
      {
	/* Pointer to target's buffer.  */
	TADDR tbuf = sc->arg1;
	/* Buffer size.  */
	int bufsize = sc->arg2;
	/* Q is the target address of where all the strings go.  */
	TADDR q;
	int word_size = cb->word_size;
	int i,argc,envc,len;
	const char **argv = cb->init_argv;
	const char **envp = cb->init_envp;

	argc = 0;
	if (argv)
	  {
	    for ( ; argv[argc]; ++argc)
	      {
		int len = strlen (argv[argc]);
		int written = (*sc->write_mem) (cb, sc, tbuf, argv[argc], len + 1);
		if (written != len)
		  {
		    result = -1;
		    errcode = EINVAL;
		    goto FinishSyscall;
		  }
		tbuf = len + 1;
	      }
	  }
	if ((*sc->write_mem) (cb, sc, tbuf, "", 1) != 1)
	  {
	    result = -1;
	    errcode = EINVAL;
	    goto FinishSyscall;
	  }
	tbuf++;
	envc = 0;
	if (envp)
	  {
	    for ( ; envp[envc]; ++envc)
	      {
		int len = strlen (envp[envc]);
		int written = (*sc->write_mem) (cb, sc, tbuf, envp[envc], len + 1);
		if (written != len)
		  {
		    result = -1;
		    errcode = EINVAL;
		    goto FinishSyscall;
		  }
		tbuf = len + 1;
	      }
	  }
	if ((*sc->write_mem) (cb, sc, tbuf, "", 1) != 1)
	  {
	    result = -1;
	    errcode = EINVAL;
	    goto FinishSyscall;
	  }
	result = argc;
	sc->result2 = envc;
	break;
      }
#endif /* wip */

    case CB_SYS_exit :
      /* Caller must catch and handle.  */
      break;

    case CB_SYS_open :
      {
	char *path;

	errcode = get_path (cb, sc, sc->arg1, &path);
	if (errcode != 0)
	  {
	    result = -1;
	    goto FinishSyscall;
	  }
	result = (*cb->open) (cb, path, sc->arg2 /*, sc->arg3*/);
	free (path);
	if (result < 0)
	  goto ErrorFinish;
      }
      break;

    case CB_SYS_close :
      result = (*cb->close) (cb, sc->arg1);
      if (result < 0)
	goto ErrorFinish;
      break;

    case CB_SYS_read :
      {
	/* ??? Perfect handling of error conditions may require only one
	   call to cb->read.  One can't assume all the data is
	   contiguously stored in host memory so that would require
	   malloc'ing/free'ing the space.  Maybe later.  */
	char buf[FILE_XFR_SIZE];
	int fd = sc->arg1;
	TADDR addr = sc->arg2;
	size_t count = sc->arg3;
	size_t bytes_read = 0;
	int bytes_written;

	while (count > 0)
	  {
	    if (cb_is_stdin (cb, fd))
	      result = (int) (*cb->read_stdin) (cb, buf,
						(count < FILE_XFR_SIZE
						 ? count : FILE_XFR_SIZE));
	    else
	      result = (int) (*cb->read) (cb, fd, buf,
					  (count < FILE_XFR_SIZE
					   ? count : FILE_XFR_SIZE));
	    if (result == -1)
	      goto ErrorFinish;
	    if (result == 0)	/* EOF */
	      break;
	    bytes_written = (*sc->write_mem) (cb, sc, addr, buf, result);
	    if (bytes_written != result)
	      {
		result = -1;
		errcode = EINVAL;
		goto FinishSyscall;
	      }
	    bytes_read += result;
	    count -= result;
	    addr += result;
	    /* If this is a short read, don't go back for more */
	    if (result != FILE_XFR_SIZE)
	      break;
	  }
	result = bytes_read;
      }
      break;

    case CB_SYS_write :
      {
	/* ??? Perfect handling of error conditions may require only one
	   call to cb->write.  One can't assume all the data is
	   contiguously stored in host memory so that would require
	   malloc'ing/free'ing the space.  Maybe later.  */
	char buf[FILE_XFR_SIZE];
	int fd = sc->arg1;
	TADDR addr = sc->arg2;
	size_t count = sc->arg3;
	int bytes_read;
	size_t bytes_written = 0;

	while (count > 0)
	  {
	    int bytes_to_read = count < FILE_XFR_SIZE ? count : FILE_XFR_SIZE;
	    bytes_read = (*sc->read_mem) (cb, sc, addr, buf, bytes_to_read);
	    if (bytes_read != bytes_to_read)
	      {
		result = -1;
		errcode = EINVAL;
		goto FinishSyscall;
	      }
	    if (cb_is_stdout (cb, fd))
	      {
		result = (int) (*cb->write_stdout) (cb, buf, bytes_read);
		(*cb->flush_stdout) (cb);
	      }
	    else if (cb_is_stderr (cb, fd))
	      {
		result = (int) (*cb->write_stderr) (cb, buf, bytes_read);
		(*cb->flush_stderr) (cb);
	      }
	    else
	      result = (int) (*cb->write) (cb, fd, buf, bytes_read);
	    if (result == -1)
	      goto ErrorFinish;
	    bytes_written += result;
	    count -= result;
	    addr += result;
	  }
	result = bytes_written;
      }
      break;

    case CB_SYS_lseek :
      {
	int fd = sc->arg1;
	unsigned long offset = sc->arg2;
	int whence = sc->arg3;

	result = (*cb->lseek) (cb, fd, offset, whence);
	if (result < 0)
	  goto ErrorFinish;
      }
      break;

    case CB_SYS_unlink :
      {
	char *path;

	errcode = get_path (cb, sc, sc->arg1, &path);
	if (errcode != 0)
	  {
	    result = -1;
	    goto FinishSyscall;
	  }
	result = (*cb->unlink) (cb, path);
	free (path);
	if (result < 0)
	  goto ErrorFinish;
      }
      break;

    case CB_SYS_truncate :
      {
	char *path;
	long len = sc->arg2;

	errcode = get_path (cb, sc, sc->arg1, &path);
	if (errcode != 0)
	  {
	    result = -1;
	    errcode = EFAULT;
	    goto FinishSyscall;
	  }
	result = (*cb->truncate) (cb, path, len);
	free (path);
	if (result < 0)
	  goto ErrorFinish;
      }
      break;

    case CB_SYS_ftruncate :
      {
	int fd = sc->arg1;
	long len = sc->arg2;

	result = (*cb->ftruncate) (cb, fd, len);
	if (result < 0)
	  goto ErrorFinish;
      }
      break;

    case CB_SYS_rename :
      {
	char *path1, *path2;

	errcode = get_path (cb, sc, sc->arg1, &path1);
	if (errcode != 0)
	  {
	    result = -1;
	    errcode = EFAULT;
	    goto FinishSyscall;
	  }
	errcode = get_path (cb, sc, sc->arg2, &path2);
	if (errcode != 0)
	  {
	    result = -1;
	    errcode = EFAULT;
	    free (path1);
	    goto FinishSyscall;
	  }
	result = (*cb->rename) (cb, path1, path2);
	free (path1);
	free (path2);
	if (result < 0)
	  goto ErrorFinish;
      }
      break;

    case CB_SYS_stat :
      {
	char *path,*buf;
	int buflen;
	struct stat statbuf;
	TADDR addr = sc->arg2;

	errcode = get_path (cb, sc, sc->arg1, &path);
	if (errcode != 0)
	  {
	    result = -1;
	    goto FinishSyscall;
	  }
	result = (*cb->stat) (cb, path, &statbuf);
	free (path);
	if (result < 0)
	  goto ErrorFinish;
	buflen = cb_host_to_target_stat (cb, NULL, NULL);
	buf = xmalloc (buflen);
	if (cb_host_to_target_stat (cb, &statbuf, buf) != buflen)
	  {
	    /* The translation failed.  This is due to an internal
	       host program error, not the target's fault.  */
	    free (buf);
	    errcode = ENOSYS;
	    result = -1;
	    goto FinishSyscall;
	  }
	if ((*sc->write_mem) (cb, sc, addr, buf, buflen) != buflen)
	  {
	    free (buf);
	    errcode = EINVAL;
	    result = -1;
	    goto FinishSyscall;
	  }
	free (buf);
      }
      break;

    case CB_SYS_fstat :
      {
	char *buf;
	int buflen;
	struct stat statbuf;
	TADDR addr = sc->arg2;

	result = (*cb->fstat) (cb, sc->arg1, &statbuf);
	if (result < 0)
	  goto ErrorFinish;
	buflen = cb_host_to_target_stat (cb, NULL, NULL);
	buf = xmalloc (buflen);
	if (cb_host_to_target_stat (cb, &statbuf, buf) != buflen)
	  {
	    /* The translation failed.  This is due to an internal
	       host program error, not the target's fault.  */
	    free (buf);
	    errcode = ENOSYS;
	    result = -1;
	    goto FinishSyscall;
	  }
	if ((*sc->write_mem) (cb, sc, addr, buf, buflen) != buflen)
	  {
	    free (buf);
	    errcode = EINVAL;
	    result = -1;
	    goto FinishSyscall;
	  }
	free (buf);
      }
      break;

    case CB_SYS_lstat :
      {
	char *path, *buf;
	int buflen;
	struct stat statbuf;
	TADDR addr = sc->arg2;

	errcode = get_path (cb, sc, sc->arg1, &path);
	if (errcode != 0)
	  {
	    result = -1;
	    goto FinishSyscall;
	  }
	result = (*cb->lstat) (cb, path, &statbuf);
	free (path);
	if (result < 0)
	  goto ErrorFinish;

	buflen = cb_host_to_target_stat (cb, NULL, NULL);
	buf = xmalloc (buflen);
	if (cb_host_to_target_stat (cb, &statbuf, buf) != buflen)
	  {
	    /* The translation failed.  This is due to an internal
	       host program error, not the target's fault.
	       Unfortunately, it's hard to test this case, so there's no
	       test-case for this execution path.  */
	    free (buf);
	    errcode = ENOSYS;
	    result = -1;
	    goto FinishSyscall;
	  }

	if ((*sc->write_mem) (cb, sc, addr, buf, buflen) != buflen)
	  {
	    free (buf);
	    errcode = EINVAL;
	    result = -1;
	    goto FinishSyscall;
	  }

	free (buf);
      }
      break;

    case CB_SYS_pipe :
      {
	int p[2];
	char *target_p = xcalloc (1, cb->target_sizeof_int * 2);

	result = (*cb->pipe) (cb, p);
	if (result != 0)
	  goto ErrorFinish;

	cb_store_target_endian (cb, target_p, cb->target_sizeof_int, p[0]);
	cb_store_target_endian (cb, target_p + cb->target_sizeof_int,
				cb->target_sizeof_int, p[1]);
	if ((*sc->write_mem) (cb, sc, sc->arg1, target_p,
			      cb->target_sizeof_int * 2)
	    != cb->target_sizeof_int * 2)
	  {
	    /* Close the pipe fd:s.  */
	    (*cb->close) (cb, p[0]);
	    (*cb->close) (cb, p[1]);
	    errcode = EFAULT;
	    result = -1;
	  }

	free (target_p);
      }
      break;

    case CB_SYS_time :
      {
	/* FIXME: May wish to change CB_SYS_time to something else.
	   We might also want gettimeofday or times, but if system calls
	   can be built on others, we can keep the number we have to support
	   here down.  */
	time_t t = (*cb->time) (cb, (time_t *) 0);
	result = t;
	/* It is up to target code to process the argument to time().  */
      }
      break;

    case CB_SYS_chdir :
    case CB_SYS_chmod :
    case CB_SYS_utime :
      /* fall through for now */

    default :
      result = -1;
      errcode = ENOSYS;
      break;
    }

 FinishSyscall:
  sc->result = result;
  if (errcode == 0)
    sc->errcode = 0;
  else
    sc->errcode = cb_host_to_target_errno (cb, errcode);
  return CB_RC_OK;

 ErrorFinish:
  sc->result = result;
  sc->errcode = (*cb->get_errno) (cb);
  return CB_RC_OK;
}
@


1.21
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 2
   Copyright 1997-1998, 2002, 2004, 2007-2012 Free Software Foundation,
   Inc.
@


1.20
log
@sim: export cb_get_string for people to use

The common sim code provides a useful "get_string" function which reads
a C string out of the target's memory space.  So rename and export it
for other people to use.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d2 2
a3 2
   Copyright 1997, 1998, 2002, 2004, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.20.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 2
   Copyright 1997-1998, 2002, 2004, 2007-2012 Free Software Foundation,
   Inc.
@


1.19
log
@sim: fix func call style (space before paren)

Committed this as obvious:
	-foo(...);
	+foo (...);

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d79 2
a80 2
static int
get_string (cb, sc, buf, buflen, addr)
d124 1
a124 1
  result = get_string (cb, sc, buf, MAX_PATH_LEN - sysroot_len, addr);
@


1.18
log
@sim: common: trim trailing whitespace
@
text
@d348 1
a348 1
	    if (cb_is_stdout(cb, fd))
d353 1
a353 1
	    else if (cb_is_stderr(cb, fd))
@


1.17
log
@run copyright.sh for 2011.
@
text
@d96 1
a96 1
				    
@


1.16
log
@Update copyright notices to add year 2010.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 2002, 2004, 2007, 2008, 2009, 2010
@


1.15
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 2002, 2004, 2007, 2008, 2009
@


1.14
log
@	Updated copyright notices for most files.
@
text
@d2 2
a3 1
   Copyright 1997, 1998, 2002, 2004, 2007, 2008 Free Software Foundation, Inc.
@


1.14.16.1
log
@Check in ARCompact simulator.  A valid configuration is arc-elf.
This is not quite finished and has most likely a few files that are
obsolete & not used, but it's good enough to run gcc regression tests.
@
text
@d112 1
a112 1
int
@


1.14.16.2
log
@gdb/insight for ARCompact (from Richard Stuckey)
@
text
@d294 1
a294 5
	    /* ??? Actually making target descriptors 0 / 1 / 2 map directly
	       to stdin / stdout / stderr gets the semantics of freopen
	       wrong.  When using default callbacks, this is re-mapped
	       in callback.c */
	    if (fd == 0)
d347 1
a347 9
        /* Don't treat descriptors 0 / 1 / 2 specially, as their
	   meaning might have been changed by freopen, as in
           27_io/objects/char/12048-[1-4].cc .  */

	    /* ??? Actually making target descriptors 0 / 1 / 2 map directly
	       to stdin / stdout / stderr gets the semantics of freopen
	       wrong.  When using default callbacks, this is re-mapped
	       in callback.c */
	    if (fd == 1)
d352 1
a352 1
	    else if (fd == 2)
@


1.13
log
@2007-10-11  Jesper Nilsson  <jesper.nilsson@@axis.com>

	* callback.c (cb_is_stdin, cb_is_stdout, cb_is_stderr): Add functions.
	* syscall.c (cb_syscall): Test for stdin/out/err, not just fd 0/1/2.

2007-10-11  Jesper Nilsson  <jesper.nilsson@@axis.com>

	* callback.h (cb_is_stdin, cb_is_stdout, cb_is_stderr): Add prototypes.

2007-10-11  Jesper Nilsson  <jesper.nilsson@@axis.com>

	* sim/cris/c/freopen2.c: Added testcase.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 2002, 2004, 2007 Free Software Foundation, Inc.
@


1.12
log
@2007-10-11  Jesper Nilsson  <jesper.nilsson@@axis.com>

	* callback.c (cb_is_stdin): Add.
	* syscall.c (cb_syscall): Test for stdin, not just fd 0.

2007-10-11  Jesper Nilsson  <jesper.nilsson@@axis.com>

	* callback.h (cb_is_stdin): Add prototype.
@
text
@d347 1
a347 1
	    if (fd == 1)
d352 1
a352 1
	    else if (fd == 2)
@


1.11
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d294 1
a294 1
	    if (fd == 0)
@


1.10
log
@Copyright updates for 2007.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d18 1
a18 2
   along with GAS; see the file COPYING.  If not, write to the Free Software
   Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.9
log
@	* callback.c: Remove ANSI_PROTOTYPES conditional code.
	* sim-load.c: Likewise.
	* syscall.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 2002, 2004 Free Software Foundation, Inc.
@


1.8
log
@	* syscall.c (cb_syscall) <case CB_SYS_pipe>: New case.
	* callback.c [HAVE_LIMITS_H]: Include limits.h.
  	Include libiberty.h.
	(os_close, os_read, os_write, os_fstat, os_ftruncate): Support fd
	being either end of a pipe.
	(os_pipe, os_pipe_empty, os_pipe_nonempty): New functions.
	(os_shutdown): Clear pipe state.
	(default_callback): Initialize new members.
@
text
@a31 1
#ifdef ANSI_PROTOTYPES
a32 3
#else
#include <varargs.h>
#endif
@


1.7
log
@	* syscall.c (cb_syscall) <case CB_SYS_truncate>
	<case CB_SYS_ftruncate>: New cases.
@
text
@d575 27
@


1.6
log
@	* syscall.c (cb_syscall) <case CB_SYS_rename>: New case.
@
text
@d403 30
@


1.5
log
@	* syscall.c (cb_syscall) <case CB_SYS_lstat>: New case.
	* callback.c (os_lstat): New function.
@
text
@d403 27
@


1.4
log
@	* run.1: Document --sysroot=filepath.
	* sim-options.c (STANDARD_OPTIONS): New member OPTION_SYSROOT.
	(standard_options): Support --sysroot=<path>.
	(standard_option_handler): Handle OPTION_SYSROOT.
	* syscall.c (simulator_sysroot): Define, initialized empty.
	(get_path): Prepend simulator_sysroot to absolute file path.
	[HAVE_STRING_H]: Include string.h.
	[!HAVE_STRING_H && HAVE_STRINGS_H]: Include strings.h.
	* nrun.c [HAVE_UNISTD_H]: Include unistd.h.
	(main): If simulator_sysroot is not empty, chdir there.
	* sim-config.h (simulator_sysroot): Declare.
@
text
@d474 44
@


1.3
log
@	* callback.c: Update copyright dates.
	* run.c: Likewise.
	* sim-basics.h: Likewise.
	* sim-load.c: Likewise.
	* syscall.c: Likewise.
From Maciej W. Rozycki  <macro@@ds2.pg.gda.pl>
	* callback.c: Include cconfig.h instead of config.h.
	* run.c: Likewise.
	* sim-basics.h: Likewise.
	* sim-load.c: Likewise.
	* syscall.c: Likewise.
@
text
@d41 5
d76 4
d113 2
a114 1
   The result is that of get_string.
d126 1
d128 1
a128 1
  result = get_string (cb, sc, buf, MAX_PATH_LEN, addr);
d130 17
a146 1
    *bufp = buf;
@


1.2
log
@Move include/callback.h and include/remote-sim.h to include/gdb/.
Update accordingly.
@
text
@d2 1
a2 1
   Copyright 1997, 1998 Free Software Foundation, Inc.
d28 1
a28 1
#include "config.h"
@


1.2.56.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 2002, 2004 Free Software Foundation, Inc.
d28 1
a28 1
#include "cconfig.h"
@


1.1
log
@Initial revision
@
text
@d49 1
a49 1
#include "callback.h"
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.1.20.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d49 1
a49 1
#include "gdb/callback.h"
@


1.1.1.1.18.1
log
@merge from trunk
@
text
@d49 1
a49 1
#include "gdb/callback.h"
@


