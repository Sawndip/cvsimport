head	1.15;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.15
	gdb_7_6-2013-04-26-release:1.15
	gdb_7_6-branch:1.15.0.2
	gdb_7_6-2013-03-12-branchpoint:1.15
	gdb_7_5_1-2012-11-29-release:1.13
	gdb_7_5-2012-08-17-release:1.13
	gdb_7_5-branch:1.13.0.16
	gdb_7_5-2012-07-18-branchpoint:1.13
	gdb_7_4_1-2012-04-26-release:1.13
	gdb_7_4-2012-01-24-release:1.13
	gdb_7_4-branch:1.13.0.14
	gdb_7_4-2011-12-13-branchpoint:1.13
	gdb_7_3_1-2011-09-04-release:1.13
	gdb_7_3-2011-07-26-release:1.13
	gdb_7_3-branch:1.13.0.12
	gdb_7_3-2011-04-01-branchpoint:1.13
	gdb_7_2-2010-09-02-release:1.13
	gdb_7_2-branch:1.13.0.10
	gdb_7_2-2010-07-07-branchpoint:1.13
	gdb_7_1-2010-03-18-release:1.13
	gdb_7_1-branch:1.13.0.8
	gdb_7_1-2010-02-18-branchpoint:1.13
	gdb_7_0_1-2009-12-22-release:1.13
	gdb_7_0-2009-10-06-release:1.13
	gdb_7_0-branch:1.13.0.6
	gdb_7_0-2009-09-16-branchpoint:1.13
	arc-sim-20090309:1.12
	msnyder-checkpoint-072509-branch:1.13.0.4
	msnyder-checkpoint-072509-branchpoint:1.13
	arc-insight_6_8-branch:1.12.0.46
	arc-insight_6_8-branchpoint:1.12
	insight_6_8-branch:1.12.0.44
	insight_6_8-branchpoint:1.12
	reverse-20081226-branch:1.13.0.2
	reverse-20081226-branchpoint:1.13
	multiprocess-20081120-branch:1.12.0.42
	multiprocess-20081120-branchpoint:1.12
	reverse-20080930-branch:1.12.0.40
	reverse-20080930-branchpoint:1.12
	reverse-20080717-branch:1.12.0.38
	reverse-20080717-branchpoint:1.12
	msnyder-reverse-20080609-branch:1.12.0.36
	msnyder-reverse-20080609-branchpoint:1.12
	drow-reverse-20070409-branch:1.12.0.34
	drow-reverse-20070409-branchpoint:1.12
	gdb_6_8-2008-03-27-release:1.12
	gdb_6_8-branch:1.12.0.32
	gdb_6_8-2008-02-26-branchpoint:1.12
	gdb_6_7_1-2007-10-29-release:1.12
	gdb_6_7-2007-10-10-release:1.12
	gdb_6_7-branch:1.12.0.30
	gdb_6_7-2007-09-07-branchpoint:1.12
	insight_6_6-20070208-release:1.12
	gdb_6_6-2006-12-18-release:1.12
	gdb_6_6-branch:1.12.0.28
	gdb_6_6-2006-11-15-branchpoint:1.12
	insight_6_5-20061003-release:1.12
	gdb-csl-symbian-6_4_50_20060226-12:1.12
	gdb-csl-sourcerygxx-3_4_4-25:1.12
	nickrob-async-20060828-mergepoint:1.12
	gdb-csl-symbian-6_4_50_20060226-11:1.12
	gdb-csl-sourcerygxx-4_1-17:1.12
	gdb-csl-20060226-branch-local-2:1.12
	gdb-csl-sourcerygxx-4_1-14:1.12
	gdb-csl-sourcerygxx-4_1-13:1.12
	gdb-csl-sourcerygxx-4_1-12:1.12
	gdb-csl-sourcerygxx-3_4_4-21:1.12
	gdb_6_5-20060621-release:1.12
	gdb-csl-sourcerygxx-4_1-9:1.12
	gdb-csl-sourcerygxx-4_1-8:1.12
	gdb-csl-sourcerygxx-4_1-7:1.12
	gdb-csl-arm-2006q1-6:1.12
	gdb-csl-sourcerygxx-4_1-6:1.12
	gdb-csl-symbian-6_4_50_20060226-10:1.12
	gdb-csl-symbian-6_4_50_20060226-9:1.12
	gdb-csl-symbian-6_4_50_20060226-8:1.12
	gdb-csl-coldfire-4_1-11:1.12
	gdb-csl-sourcerygxx-3_4_4-19:1.12
	gdb-csl-coldfire-4_1-10:1.12
	gdb_6_5-branch:1.12.0.26
	gdb_6_5-2006-05-14-branchpoint:1.12
	gdb-csl-sourcerygxx-4_1-5:1.12
	nickrob-async-20060513-branch:1.12.0.24
	nickrob-async-20060513-branchpoint:1.12
	gdb-csl-sourcerygxx-4_1-4:1.12
	msnyder-reverse-20060502-branch:1.12.0.22
	msnyder-reverse-20060502-branchpoint:1.12
	gdb-csl-morpho-4_1-4:1.12
	gdb-csl-sourcerygxx-3_4_4-17:1.12
	readline_5_1-import-branch:1.12.0.20
	readline_5_1-import-branchpoint:1.12
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.12
	gdb-csl-symbian-20060226-branch:1.12.0.18
	gdb-csl-symbian-20060226-branchpoint:1.12
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.12
	msnyder-reverse-20060331-branch:1.12.0.16
	msnyder-reverse-20060331-branchpoint:1.12
	gdb-csl-available-20060303-branch:1.12.0.14
	gdb-csl-available-20060303-branchpoint:1.12
	gdb-csl-20060226-branch:1.12.0.12
	gdb-csl-20060226-branchpoint:1.12
	gdb_6_4-20051202-release:1.12
	msnyder-fork-checkpoint-branch:1.12.0.10
	msnyder-fork-checkpoint-branchpoint:1.12
	gdb-csl-gxxpro-6_3-branch:1.12.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.12
	gdb_6_4-branch:1.12.0.6
	gdb_6_4-2005-11-01-branchpoint:1.12
	gdb-csl-arm-20051020-branch:1.12.0.4
	gdb-csl-arm-20051020-branchpoint:1.12
	msnyder-tracepoint-checkpoint-branch:1.12.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.12
	gdb-csl-arm-20050325-2005-q1b:1.10
	gdb-csl-arm-20050325-2005-q1a:1.10
	csl-arm-20050325-branch:1.10.0.46
	csl-arm-20050325-branchpoint:1.10
	gdb_6_3-20041109-release:1.10
	gdb_6_3-branch:1.10.0.42
	gdb_6_3-20041019-branchpoint:1.10
	drow_intercu-merge-20040921:1.10
	drow_intercu-merge-20040915:1.10
	jimb-gdb_6_2-e500-branch:1.10.0.44
	jimb-gdb_6_2-e500-branchpoint:1.10
	gdb_6_2-20040730-release:1.10
	gdb_6_2-branch:1.10.0.40
	gdb_6_2-2004-07-10-gmt-branchpoint:1.10
	gdb_6_1_1-20040616-release:1.10
	gdb_6_1-2004-04-05-release:1.10
	drow_intercu-merge-20040402:1.10
	drow_intercu-merge-20040327:1.10
	ezannoni_pie-20040323-branch:1.10.0.38
	ezannoni_pie-20040323-branchpoint:1.10
	cagney_tramp-20040321-mergepoint:1.10
	cagney_tramp-20040309-branch:1.10.0.36
	cagney_tramp-20040309-branchpoint:1.10
	gdb_6_1-branch:1.10.0.34
	gdb_6_1-2004-03-01-gmt-branchpoint:1.10
	drow_intercu-20040221-branch:1.10.0.32
	drow_intercu-20040221-branchpoint:1.10
	cagney_bfdfile-20040213-branch:1.10.0.30
	cagney_bfdfile-20040213-branchpoint:1.10
	drow-cplus-merge-20040208:1.10
	carlton_dictionary-20040126-merge:1.10
	cagney_bigcore-20040122-branch:1.10.0.28
	cagney_bigcore-20040122-branchpoint:1.10
	drow-cplus-merge-20040113:1.10
	drow-cplus-merge-20031224:1.10
	drow-cplus-merge-20031220:1.10
	carlton_dictionary-20031215-merge:1.10
	drow-cplus-merge-20031214:1.10
	carlton-dictionary-20031111-merge:1.10
	gdb_6_0-2003-10-04-release:1.10
	kettenis_sparc-20030918-branch:1.10.0.26
	kettenis_sparc-20030918-branchpoint:1.10
	carlton_dictionary-20030917-merge:1.10
	ezannoni_pie-20030916-branchpoint:1.10
	ezannoni_pie-20030916-branch:1.10.0.24
	cagney_x86i386-20030821-branch:1.10.0.22
	cagney_x86i386-20030821-branchpoint:1.10
	carlton_dictionary-20030805-merge:1.10
	carlton_dictionary-20030627-merge:1.10
	gdb_6_0-branch:1.10.0.20
	gdb_6_0-2003-06-23-branchpoint:1.10
	jimb-ppc64-linux-20030613-branch:1.10.0.18
	jimb-ppc64-linux-20030613-branchpoint:1.10
	cagney_convert-20030606-branch:1.10.0.16
	cagney_convert-20030606-branchpoint:1.10
	cagney_writestrings-20030508-branch:1.10.0.14
	cagney_writestrings-20030508-branchpoint:1.10
	jimb-ppc64-linux-20030528-branch:1.10.0.12
	jimb-ppc64-linux-20030528-branchpoint:1.10
	carlton_dictionary-20030523-merge:1.10
	cagney_fileio-20030521-branch:1.10.0.10
	cagney_fileio-20030521-branchpoint:1.10
	kettenis_i386newframe-20030517-mergepoint:1.10
	jimb-ppc64-linux-20030509-branch:1.10.0.8
	jimb-ppc64-linux-20030509-branchpoint:1.10
	kettenis_i386newframe-20030504-mergepoint:1.10
	carlton_dictionary-20030430-merge:1.10
	kettenis_i386newframe-20030419-branch:1.10.0.6
	kettenis_i386newframe-20030419-branchpoint:1.10
	carlton_dictionary-20030416-merge:1.10
	cagney_frameaddr-20030409-mergepoint:1.10
	kettenis_i386newframe-20030406-branch:1.10.0.4
	kettenis_i386newframe-20030406-branchpoint:1.10
	cagney_frameaddr-20030403-branchpoint:1.10
	cagney_frameaddr-20030403-branch:1.10.0.2
	cagney_framebase-20030330-mergepoint:1.10
	cagney_framebase-20030326-branch:1.9.0.2
	cagney_framebase-20030326-branchpoint:1.9
	cagney_lazyid-20030317-branch:1.8.0.30
	cagney_lazyid-20030317-branchpoint:1.8
	kettenis-i386newframe-20030316-mergepoint:1.8
	offbyone-20030313-branch:1.8.0.28
	offbyone-20030313-branchpoint:1.8
	kettenis-i386newframe-20030308-branch:1.8.0.26
	kettenis-i386newframe-20030308-branchpoint:1.8
	carlton_dictionary-20030305-merge:1.8
	cagney_offbyone-20030303-branch:1.8.0.24
	cagney_offbyone-20030303-branchpoint:1.8
	carlton_dictionary-20030207-merge:1.8
	interps-20030202-branch:1.8.0.22
	interps-20030202-branchpoint:1.8
	cagney-unwind-20030108-branch:1.8.0.20
	cagney-unwind-20030108-branchpoint:1.8
	carlton_dictionary-20021223-merge:1.8
	gdb_5_3-2002-12-12-release:1.8
	carlton_dictionary-20021115-merge:1.8
	kseitz_interps-20021105-merge:1.8
	kseitz_interps-20021103-merge:1.8
	drow-cplus-merge-20021020:1.8
	drow-cplus-merge-20021025:1.8
	carlton_dictionary-20021025-merge:1.8
	carlton_dictionary-20021011-merge:1.8
	drow-cplus-branch:1.8.0.18
	drow-cplus-branchpoint:1.8
	kseitz_interps-20020930-merge:1.8
	carlton_dictionary-20020927-merge:1.8
	carlton_dictionary-branch:1.8.0.16
	carlton_dictionary-20020920-branchpoint:1.8
	gdb_5_3-branch:1.8.0.14
	gdb_5_3-2002-09-04-branchpoint:1.8
	kseitz_interps-20020829-merge:1.8
	cagney_sysregs-20020825-branch:1.8.0.12
	cagney_sysregs-20020825-branchpoint:1.8
	readline_4_3-import-branch:1.8.0.10
	readline_4_3-import-branchpoint:1.8
	gdb_5_2_1-2002-07-23-release:1.8
	kseitz_interps-20020528-branch:1.8.0.8
	kseitz_interps-20020528-branchpoint:1.8
	cagney_regbuf-20020515-branch:1.8.0.6
	cagney_regbuf-20020515-branchpoint:1.8
	jimb-macro-020506-branch:1.8.0.4
	jimb-macro-020506-branchpoint:1.8
	gdb_5_2-2002-04-29-release:1.8
	gdb_5_2-branch:1.8.0.2
	gdb_5_2-2002-03-03-branchpoint:1.8
	gdb_5_1_1-2002-01-24-release:1.7
	gdb_5_1_0_1-2002-01-03-release:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.7.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.7
	gdb_5_1-2001-11-21-release:1.7
	gdb_s390-2001-09-26-branch:1.7.0.4
	gdb_s390-2001-09-26-branchpoint:1.7
	gdb_5_1-2001-07-29-branch:1.7.0.2
	gdb_5_1-2001-07-29-branchpoint:1.7
	insight-precleanup-2001-01-01:1.6
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.15
date	2012.12.19.07.18.14;	author brobecke;	state Exp;
branches;
next	1.14;

1.14
date	2012.12.19.07.11.58;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.26.14.24.12;	author joel;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.12.07.36.58;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.25.07.48.59;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.27.17.13.33;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.20.12.25.07;	author nickc;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2002.01.10.11.14.57;	author nickc;	state Exp;
branches
	1.8.16.1
	1.8.18.1;
next	1.7;

1.7
date	2001.04.18.16.39.37;	author mrg;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.30.01.55.12;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.15.23.55.50;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.04.07.18.18;	author aoliva;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.04.06.52.30;	author aoliva;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.30.17.13.37;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.55;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.9.2.1
date	2003.03.30.16.35.25;	author cagney;	state Exp;
branches;
next	;

1.8.16.1
date	2003.04.16.19.57.07;	author carlton;	state Exp;
branches;
next	;

1.8.18.1
date	2003.12.14.20.28.16;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.55;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.02.05.07.30.19;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.15
log
@[sim] Update old contact info in GPL license notices

sim/ChangeLog:

        Update old contact info in GPL license notices.
@
text
@/*  arminit.c -- ARMulator initialization:  ARM6 Instruction Emulator.
    Copyright (C) 1994 Advanced RISC Machines Ltd.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, see <http://www.gnu.org/licenses/>. */

#include <string.h>

#include "armdefs.h"
#include "armemu.h"
#include "dbg_rdi.h"

/***************************************************************************\
*                 Definitions for the emulator architecture                 *
\***************************************************************************/

void ARMul_EmulateInit (void);
ARMul_State *ARMul_NewState (void);
void ARMul_Reset (ARMul_State * state);
ARMword ARMul_DoCycle (ARMul_State * state);
unsigned ARMul_DoCoPro (ARMul_State * state);
ARMword ARMul_DoProg (ARMul_State * state);
ARMword ARMul_DoInstr (ARMul_State * state);
void ARMul_Abort (ARMul_State * state, ARMword address);

unsigned ARMul_MultTable[32] =
  { 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9,
  10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 16
};
ARMword ARMul_ImmedTable[4096];	/* immediate DP LHS values */
char ARMul_BitList[256];	/* number of bits in a byte table */

/***************************************************************************\
*         Call this routine once to set up the emulator's tables.           *
\***************************************************************************/

void
ARMul_EmulateInit (void)
{
  unsigned long i, j;

  for (i = 0; i < 4096; i++)
    {				/* the values of 12 bit dp rhs's */
      ARMul_ImmedTable[i] = ROTATER (i & 0xffL, (i >> 7L) & 0x1eL);
    }

  for (i = 0; i < 256; ARMul_BitList[i++] = 0);	/* how many bits in LSM */
  for (j = 1; j < 256; j <<= 1)
    for (i = 0; i < 256; i++)
      if ((i & j) > 0)
	ARMul_BitList[i]++;

  for (i = 0; i < 256; i++)
    ARMul_BitList[i] *= 4;	/* you always need 4 times these values */

}

/***************************************************************************\
*            Returns a new instantiation of the ARMulator's state           *
\***************************************************************************/

ARMul_State *
ARMul_NewState (void)
{
  ARMul_State *state;
  unsigned i, j;

  state = (ARMul_State *) malloc (sizeof (ARMul_State));
  memset (state, 0, sizeof (ARMul_State));

  state->Emulate = RUN;
  for (i = 0; i < 16; i++)
    {
      state->Reg[i] = 0;
      for (j = 0; j < 7; j++)
	state->RegBank[j][i] = 0;
    }
  for (i = 0; i < 7; i++)
    state->Spsr[i] = 0;

  /* state->Mode = USER26MODE;  */
  state->Mode = USER32MODE;

  state->CallDebug = FALSE;
  state->Debug = FALSE;
  state->VectorCatch = 0;
  state->Aborted = FALSE;
  state->Reseted = FALSE;
  state->Inted = 3;
  state->LastInted = 3;

  state->MemDataPtr = NULL;
  state->MemInPtr = NULL;
  state->MemOutPtr = NULL;
  state->MemSparePtr = NULL;
  state->MemSize = 0;

  state->OSptr = NULL;
  state->CommandLine = NULL;

  state->CP14R0_CCD = -1;
  state->LastTime = 0;

  state->EventSet = 0;
  state->Now = 0;
  state->EventPtr = (struct EventNode **) malloc ((unsigned) EVENTLISTSIZE *
						  sizeof (struct EventNode
							  *));
  for (i = 0; i < EVENTLISTSIZE; i++)
    *(state->EventPtr + i) = NULL;

  state->prog32Sig = HIGH;
  state->data32Sig = HIGH;

  state->lateabtSig = LOW;
  state->bigendSig = LOW;

  state->is_v4 = LOW;
  state->is_v5 = LOW;
  state->is_v5e = LOW;
  state->is_XScale = LOW;
  state->is_iWMMXt = LOW;
  state->is_v6 = LOW;

  ARMul_Reset (state);

  return state;
}

/***************************************************************************\
  Call this routine to set ARMulator to model certain processor properities
\***************************************************************************/

void
ARMul_SelectProcessor (ARMul_State * state, unsigned properties)
{
  if (properties & ARM_Fix26_Prop)
    {
      state->prog32Sig = LOW;
      state->data32Sig = LOW;
    }
  else
    {
      state->prog32Sig = HIGH;
      state->data32Sig = HIGH;
    }

  state->lateabtSig = LOW;

  state->is_v4 = (properties & (ARM_v4_Prop | ARM_v5_Prop)) ? HIGH : LOW;
  state->is_v5 = (properties & ARM_v5_Prop) ? HIGH : LOW;
  state->is_v5e = (properties & ARM_v5e_Prop) ? HIGH : LOW;
  state->is_XScale = (properties & ARM_XScale_Prop) ? HIGH : LOW;
  state->is_iWMMXt = (properties & ARM_iWMMXt_Prop) ? HIGH : LOW;
  state->is_ep9312 = (properties & ARM_ep9312_Prop) ? HIGH : LOW;
  state->is_v6 = (properties & ARM_v6_Prop) ? HIGH : LOW;

  /* Only initialse the coprocessor support once we
     know what kind of chip we are dealing with.  */
  ARMul_CoProInit (state);
}

/***************************************************************************\
* Call this routine to set up the initial machine state (or perform a RESET *
\***************************************************************************/

void
ARMul_Reset (ARMul_State * state)
{
  state->NextInstr = 0;

  if (state->prog32Sig)
    {
      state->Reg[15] = 0;
      state->Cpsr = INTBITS | SVC32MODE;
      state->Mode = SVC32MODE;
    }
  else
    {
      state->Reg[15] = R15INTBITS | SVC26MODE;
      state->Cpsr = INTBITS | SVC26MODE;
      state->Mode = SVC26MODE;
    }

  ARMul_CPSRAltered (state);
  state->Bank = SVCBANK;

  FLUSHPIPE;

  state->EndCondition = 0;
  state->ErrorCode = 0;

  state->Exception = FALSE;
  state->NresetSig = HIGH;
  state->NfiqSig = HIGH;
  state->NirqSig = HIGH;
  state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
  state->abortSig = LOW;
  state->AbortAddr = 1;

  state->NumInstrs = 0;
  state->NumNcycles = 0;
  state->NumScycles = 0;
  state->NumIcycles = 0;
  state->NumCcycles = 0;
  state->NumFcycles = 0;
#ifdef ASIM
  (void) ARMul_MemoryInit ();
  ARMul_OSInit (state);
#endif
}


/***************************************************************************\
* Emulate the execution of an entire program.  Start the correct emulator   *
* (Emulate26 for a 26 bit ARM and Emulate32 for a 32 bit ARM), return the   *
* address of the last instruction that is executed.                         *
\***************************************************************************/

ARMword
ARMul_DoProg (ARMul_State * state)
{
  ARMword pc = 0;

  state->Emulate = RUN;
  while (state->Emulate != STOP)
    {
      state->Emulate = RUN;
      if (state->prog32Sig && ARMul_MODE32BIT)
	pc = ARMul_Emulate32 (state);
      else
	pc = ARMul_Emulate26 (state);
    }
  return (pc);
}

/***************************************************************************\
* Emulate the execution of one instruction.  Start the correct emulator     *
* (Emulate26 for a 26 bit ARM and Emulate32 for a 32 bit ARM), return the   *
* address of the instruction that is executed.                              *
\***************************************************************************/

ARMword
ARMul_DoInstr (ARMul_State * state)
{
  ARMword pc = 0;

  state->Emulate = ONCE;
  if (state->prog32Sig && ARMul_MODE32BIT)
    pc = ARMul_Emulate32 (state);
  else
    pc = ARMul_Emulate26 (state);

  return (pc);
}

/***************************************************************************\
* This routine causes an Abort to occur, including selecting the correct    *
* mode, register bank, and the saving of registers.  Call with the          *
* appropriate vector's memory address (0,4,8 ....)                          *
\***************************************************************************/

void
ARMul_Abort (ARMul_State * state, ARMword vector)
{
  ARMword temp;
  int isize = INSN_SIZE;
  int esize = (TFLAG ? 0 : 4);
  int e2size = (TFLAG ? -4 : 0);

  state->Aborted = FALSE;

  if (ARMul_OSException (state, vector, ARMul_GetPC (state)))
    return;

  if (state->prog32Sig)
    if (ARMul_MODE26BIT)
      temp = R15PC;
    else
      temp = state->Reg[15];
  else
    temp = R15PC | ECC | ER15INT | EMODE;

  switch (vector)
    {
    case ARMul_ResetV:		/* RESET */
      SETABORT (INTBITS, state->prog32Sig ? SVC32MODE : SVC26MODE, 0);
      break;
    case ARMul_UndefinedInstrV:	/* Undefined Instruction */
      SETABORT (IBIT, state->prog32Sig ? UNDEF32MODE : SVC26MODE, isize);
      break;
    case ARMul_SWIV:		/* Software Interrupt */
      SETABORT (IBIT, state->prog32Sig ? SVC32MODE : SVC26MODE, isize);
      break;
    case ARMul_PrefetchAbortV:	/* Prefetch Abort */
      state->AbortAddr = 1;
      SETABORT (IBIT, state->prog32Sig ? ABORT32MODE : SVC26MODE, esize);
      break;
    case ARMul_DataAbortV:	/* Data Abort */
      SETABORT (IBIT, state->prog32Sig ? ABORT32MODE : SVC26MODE, e2size);
      break;
    case ARMul_AddrExceptnV:	/* Address Exception */
      SETABORT (IBIT, SVC26MODE, isize);
      break;
    case ARMul_IRQV:		/* IRQ */
      if (   ! state->is_XScale
	  || ! state->CPRead[13] (state, 0, & temp)
	  || (temp & ARMul_CP13_R0_IRQ))
        SETABORT (IBIT, state->prog32Sig ? IRQ32MODE : IRQ26MODE, esize);
      break;
    case ARMul_FIQV:		/* FIQ */
      if (   ! state->is_XScale
	  || ! state->CPRead[13] (state, 0, & temp)
	  || (temp & ARMul_CP13_R0_FIQ))
        SETABORT (INTBITS, state->prog32Sig ? FIQ32MODE : FIQ26MODE, esize);
      break;
    }
  if (ARMul_MODE32BIT)
    ARMul_SetR15 (state, vector);
  else
    ARMul_SetR15 (state, R15CCINTMODE | vector);

  if (ARMul_ReadWord (state, ARMul_GetPC (state)) == 0)
    {
      /* No vector has been installed.  Rather than simulating whatever
	 random bits might happen to be at address 0x20 onwards we elect
	 to stop.  */
      switch (vector)
	{
	case ARMul_ResetV: state->EndCondition = RDIError_Reset; break;
	case ARMul_UndefinedInstrV: state->EndCondition = RDIError_UndefinedInstruction; break;
	case ARMul_SWIV: state->EndCondition = RDIError_SoftwareInterrupt; break;
	case ARMul_PrefetchAbortV: state->EndCondition = RDIError_PrefetchAbort; break;
	case ARMul_DataAbortV: state->EndCondition = RDIError_DataAbort; break;
	case ARMul_AddrExceptnV: state->EndCondition = RDIError_AddressException; break;
	case ARMul_IRQV: state->EndCondition = RDIError_IRQ; break;
	case ARMul_FIQV: state->EndCondition = RDIError_FIQ; break;
	default: break;
	}
      state->Emulate = FALSE;
    }
}
@


1.14
log
@Update sim copyright headers from GPLv2-or-later to GPLv3-or-later.

gdb/sim/ChangeLog:

        Update the non-FSF-copyrighted files in sim to GPLv3 or later.
@
text
@d15 1
a15 2
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA. */
@


1.13
log
@2008-11-24  Joel Sherrill <joel.sherrill@@oarcorp.com>

    * arminit.c, iwmmxt.c: Include <string.h> to
    eliminate warning.
@
text
@d6 1
a6 1
    the Free Software Foundation; either version 2 of the License, or
@


1.12
log
@Update the address of the FSF organization
@
text
@d18 2
@


1.11
log
@* armemu.c (handle_v6_insn): New function - emulate a few of the v6 instructions - the ones now generated by GCC.
  (ARMulEmulate32): Call handle_v6_insn when a possible v6 insn is found.
* armdefs.h (struct ARMul_State): Add new field: is_v6.#
  (ARM_v6_Prop): Define.
* arminit.c (ARMul_NewState): Initialise the v6 flag.
  (ARMul_SelectProcessor): Determine if the v6 flag should be set.
* wrapper.c (sim_create_inferior): For unknown architectures, default to allowing the v6 instructions.
@
text
@d16 1
a16 1
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
@


1.10
log
@Add iWMMXt support to ARM simulator
@
text
@d132 1
d165 1
@


1.9
log
@Add Cirrus Maverick support to arm simulator
@
text
@d20 1
d131 1
d162 1
d329 20
@


1.9.2.1
log
@Merge with mainline.
@
text
@a19 1
#include "dbg_rdi.h"
a129 1
  state->is_iWMMXt = LOW;
a159 1
  state->is_iWMMXt = (properties & ARM_iWMMXt_Prop) ? HIGH : LOW;
a325 20

  if (ARMul_ReadWord (state, ARMul_GetPC (state)) == 0)
    {
      /* No vector has been installed.  Rather than simulating whatever
	 random bits might happen to be at address 0x20 onwards we elect
	 to stop.  */
      switch (vector)
	{
	case ARMul_ResetV: state->EndCondition = RDIError_Reset; break;
	case ARMul_UndefinedInstrV: state->EndCondition = RDIError_UndefinedInstruction; break;
	case ARMul_SWIV: state->EndCondition = RDIError_SoftwareInterrupt; break;
	case ARMul_PrefetchAbortV: state->EndCondition = RDIError_PrefetchAbort; break;
	case ARMul_DataAbortV: state->EndCondition = RDIError_DataAbort; break;
	case ARMul_AddrExceptnV: state->EndCondition = RDIError_AddressException; break;
	case ARMul_IRQV: state->EndCondition = RDIError_IRQ; break;
	case ARMul_FIQV: state->EndCondition = RDIError_FIQ; break;
	default: break;
	}
      state->Emulate = FALSE;
    }
@


1.8
log
@Fix parameters passed to CPRead[13] and CPRead[14].
@
text
@d160 5
@


1.8.18.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a19 1
#include "dbg_rdi.h"
a129 1
  state->is_iWMMXt = LOW;
a159 6
  state->is_iWMMXt = (properties & ARM_iWMMXt_Prop) ? HIGH : LOW;
  state->is_ep9312 = (properties & ARM_ep9312_Prop) ? HIGH : LOW;

  /* Only initialse the coprocessor support once we
     know what kind of chip we are dealing with.  */
  ARMul_CoProInit (state);
a320 20

  if (ARMul_ReadWord (state, ARMul_GetPC (state)) == 0)
    {
      /* No vector has been installed.  Rather than simulating whatever
	 random bits might happen to be at address 0x20 onwards we elect
	 to stop.  */
      switch (vector)
	{
	case ARMul_ResetV: state->EndCondition = RDIError_Reset; break;
	case ARMul_UndefinedInstrV: state->EndCondition = RDIError_UndefinedInstruction; break;
	case ARMul_SWIV: state->EndCondition = RDIError_SoftwareInterrupt; break;
	case ARMul_PrefetchAbortV: state->EndCondition = RDIError_PrefetchAbort; break;
	case ARMul_DataAbortV: state->EndCondition = RDIError_DataAbort; break;
	case ARMul_AddrExceptnV: state->EndCondition = RDIError_AddressException; break;
	case ARMul_IRQV: state->EndCondition = RDIError_IRQ; break;
	case ARMul_FIQV: state->EndCondition = RDIError_FIQ; break;
	default: break;
	}
      state->Emulate = FALSE;
    }
@


1.8.16.1
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a19 1
#include "dbg_rdi.h"
a129 1
  state->is_iWMMXt = LOW;
a159 6
  state->is_iWMMXt = (properties & ARM_iWMMXt_Prop) ? HIGH : LOW;
  state->is_ep9312 = (properties & ARM_ep9312_Prop) ? HIGH : LOW;

  /* Only initialse the coprocessor support once we
     know what kind of chip we are dealing with.  */
  ARMul_CoProInit (state);
a320 20

  if (ARMul_ReadWord (state, ARMul_GetPC (state)) == 0)
    {
      /* No vector has been installed.  Rather than simulating whatever
	 random bits might happen to be at address 0x20 onwards we elect
	 to stop.  */
      switch (vector)
	{
	case ARMul_ResetV: state->EndCondition = RDIError_Reset; break;
	case ARMul_UndefinedInstrV: state->EndCondition = RDIError_UndefinedInstruction; break;
	case ARMul_SWIV: state->EndCondition = RDIError_SoftwareInterrupt; break;
	case ARMul_PrefetchAbortV: state->EndCondition = RDIError_PrefetchAbort; break;
	case ARMul_DataAbortV: state->EndCondition = RDIError_DataAbort; break;
	case ARMul_AddrExceptnV: state->EndCondition = RDIError_AddressException; break;
	case ARMul_IRQV: state->EndCondition = RDIError_IRQ; break;
	case ARMul_FIQV: state->EndCondition = RDIError_FIQ; break;
	default: break;
	}
      state->Emulate = FALSE;
    }
@


1.7
log
@* XScale coprocessor support.

2001-04-18  matthew green  <mrg@@redhat.com>

	* armcopro.c (write_cp15_reg): Set CHANGEMODE if endianness changes.
	(read_cp15_reg): Make non-static.
	(XScale_cp15_LDC): Update for write_cp15_reg() change.
	(XScale_cp15_MCR): Likewise.
	(XScale_cp15_write_reg): Likewise.
	(XScale_check_memacc): New function. Check for breakpoints being
	activated by memory accesses.  Does not support the Branch Target
	Buffer.
	(XScale_set_fsr_far): New function. Set FSR and FAR for XScale.
	(XScale_debug_moe): New function. Set the debug Method Of Entry,
	if configured.
	(write_cp14_reg): Reset count counter if requested.
	* armdefs.h (struct ARMul_State): New members `LastTime' and
	`CP14R0_CCD' used for the timer/counters.
	(ARMul_CP13_R0_FIQ, ARMul_CP13_R0_IRQ, ARMul_CP13_R8_PMUS,
	ARMul_CP14_R0_ENABLE, ARMul_CP14_R0_CLKRST, ARMul_CP14_R0_CCD,
	ARMul_CP14_R0_INTEN0, ARMul_CP14_R0_INTEN1, ARMul_CP14_R0_INTEN2,
	ARMul_CP14_R0_FLAG0, ARMul_CP14_R0_FLAG1, ARMul_CP14_R0_FLAG2,
	ARMul_CP14_R10_MOE_IB, ARMul_CP14_R10_MOE_DB, ARMul_CP14_R10_MOE_BT,
	ARMul_CP15_R1_ENDIAN, ARMul_CP15_R1_ALIGN, ARMul_CP15_R5_X,
	ARMul_CP15_R5_ST_ALIGN, ARMul_CP15_R5_IMPRE, ARMul_CP15_R5_MMU_EXCPT,
	ARMul_CP15_DBCON_M, ARMul_CP15_DBCON_E1, ARMul_CP15_DBCON_E0): New
	defines for XScale registers.
	(XScale_check_memacc, XScale_set_fsr_far, XScale_debug_moe): Prototype.
	(ARMul_Emulate32, ARMul_Emulate26): Clean up function definition.
	(ARMul_Emulate32): Handle the clock counter and hardware instruction
	breakpoints.  Call XScale_set_fsr_far() for software breakpoints and
	software interrupts.
	(LoadMult): Call XScale_set_fsr_far() for data aborts.
	(LoadSMult): Likewise.
	(StoreMult): Likewise.
	(StoreSMult): Likewise.
	* armemu.h (write_cp15_reg): Update prototype.
	* arminit.c (ARMul_NewState): Initialise CP14R0_CCD and LastTime.
	(ARMul_Abort): If XScale, check for FIQ and IRQ being enabled in CP13
	register 0.
	* armvirt.c (GetWord): Call XScale_check_memacc().
	(PutWord): Likewise.
@
text
@d305 3
a307 2
      if (!state->is_XScale
	  || (state->CPRead[13](state, 0, 0) & ARMul_CP13_R0_IRQ))
d311 3
a313 2
      if (!state->is_XScale
	  || (state->CPRead[13](state, 0, 0) & ARMul_CP13_R0_FIQ))
@


1.6
log
@Add support for ARM's v5TE architecture and Intel's XScale extenstions
@
text
@d109 3
d305 3
a307 1
      SETABORT (IBIT, state->prog32Sig ? IRQ32MODE : IRQ26MODE, esize);
d310 3
a312 1
      SETABORT (INTBITS, state->prog32Sig ? FIQ32MODE : FIQ26MODE, esize);
@


1.5
log
@Replace StrongARM property with v4 and v5 properties.
@
text
@d89 2
a90 1
  state->Mode = USER26MODE;
a116 4
#ifdef ARM61
  state->prog32Sig = LOW;
  state->data32Sig = LOW;
#else
a118 1
#endif
d125 2
d155 2
d264 2
d293 1
a293 1
      SETABORT (IBIT, state->prog32Sig ? ABORT32MODE : SVC26MODE, isize);
d296 1
a296 1
      SETABORT (IBIT, state->prog32Sig ? ABORT32MODE : SVC26MODE, isize);
d302 1
a302 1
      SETABORT (IBIT, state->prog32Sig ? IRQ32MODE : IRQ26MODE, isize);
d305 1
a305 1
      SETABORT (INTBITS, state->prog32Sig ? FIQ32MODE : FIQ26MODE, isize);
@


1.4
log
@* armdefs.h (struct ARMul_State): Add is_StrongARM.
(ARM_Strong_Prop, STRONGARM): Define.
* arminit.c (ARMul_NewState): Reset is_StrongARM.
(ARMul_SelectProcessor): Set is_StrongARM.
* wrapper.c (sim_create_inferior): Use bfd machine type to
determine processor type to emulate.
* armemu.h (BUSUSEDINCPCS, BUSUSEDINCPCN): Don't increment PC
when emulating StrongARM.
@
text
@d88 1
a88 1
  
d127 2
a128 1
  state->is_StrongARM = LOW;
d131 2
a132 1
  return (state);
d136 1
a136 1
*       Call this routine to set ARMulator to model a certain processor     *
d140 1
a140 1
ARMul_SelectProcessor (ARMul_State * state, unsigned processor)
d142 1
a142 1
  if (processor & ARM_Fix26_Prop)
d155 2
a156 1
  state->is_StrongARM = (processor & ARM_Strong_Prop) ? HIGH : LOW;
@


1.3
log
@* armemu.h (INSN_SIZE): New macro.
(SET_ABORT): Save CPSR in SPSR and set LR.
* armemu.c (ARMul_Emulate, isize): Set to INSN_SIZE.
(WriteR15, WriteSR15): Do not discard bit 1 in Thumb mode.
* arminit.c (ARMul_Abort): Use new SETABORT and INSN_SIZE.
@
text
@d127 2
d152 2
@


1.2
log
@Add support for v4 SystemMode.
@
text
@d256 1
d274 1
a274 4
      state->Spsr[SVCBANK] = CPSR;
      SETABORT (INTBITS, state->prog32Sig ? SVC32MODE : SVC26MODE);
      ARMul_CPSRAltered (state);
      state->Reg[14] = temp;
d277 1
a277 4
      state->Spsr[state->prog32Sig ? UNDEFBANK : SVCBANK] = CPSR;
      SETABORT (IBIT, state->prog32Sig ? UNDEF32MODE : SVC26MODE);
      ARMul_CPSRAltered (state);
      state->Reg[14] = temp - 4;
d280 1
a280 4
      state->Spsr[SVCBANK] = CPSR;
      SETABORT (IBIT, state->prog32Sig ? SVC32MODE : SVC26MODE);
      ARMul_CPSRAltered (state);
      state->Reg[14] = temp - 4;
d284 1
a284 4
      state->Spsr[state->prog32Sig ? ABORTBANK : SVCBANK] = CPSR;
      SETABORT (IBIT, state->prog32Sig ? ABORT32MODE : SVC26MODE);
      ARMul_CPSRAltered (state);
      state->Reg[14] = temp - 4;
d287 1
a287 4
      state->Spsr[state->prog32Sig ? ABORTBANK : SVCBANK] = CPSR;
      SETABORT (IBIT, state->prog32Sig ? ABORT32MODE : SVC26MODE);
      ARMul_CPSRAltered (state);
      state->Reg[14] = temp - 4;	/* the PC must have been incremented */
d290 1
a290 4
      state->Spsr[SVCBANK] = CPSR;
      SETABORT (IBIT, SVC26MODE);
      ARMul_CPSRAltered (state);
      state->Reg[14] = temp - 4;
d293 1
a293 4
      state->Spsr[IRQBANK] = CPSR;
      SETABORT (IBIT, state->prog32Sig ? IRQ32MODE : IRQ26MODE);
      ARMul_CPSRAltered (state);
      state->Reg[14] = temp - 4;
d296 1
a296 4
      state->Spsr[FIQBANK] = CPSR;
      SETABORT (INTBITS, state->prog32Sig ? FIQ32MODE : FIQ26MODE);
      ARMul_CPSRAltered (state);
      state->Reg[14] = temp - 4;
@


1.1
log
@Initial revision
@
text
@d25 15
a39 13
void ARMul_EmulateInit(void) ;
ARMul_State *ARMul_NewState(void) ;
void ARMul_Reset(ARMul_State *state) ;
ARMword ARMul_DoCycle(ARMul_State *state) ;
unsigned ARMul_DoCoPro(ARMul_State *state) ;
ARMword ARMul_DoProg(ARMul_State *state) ;
ARMword ARMul_DoInstr(ARMul_State *state) ;
void ARMul_Abort(ARMul_State *state, ARMword address) ;

unsigned ARMul_MultTable[32] = {1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,
                                10,10,11,11,12,12,13,13,14,14,15,15,16,16,16} ;
ARMword ARMul_ImmedTable[4096] ; /* immediate DP LHS values */
char ARMul_BitList[256] ; /* number of bits in a byte table */
d45 15
a59 2
void ARMul_EmulateInit(void)
{unsigned long i, j ;
d61 2
a62 3
 for (i = 0 ; i < 4096 ; i++) { /* the values of 12 bit dp rhs's */
    ARMul_ImmedTable[i] = ROTATER(i & 0xffL,(i >> 7L) & 0x1eL) ;
    }
a63 9
 for (i = 0 ; i < 256 ; ARMul_BitList[i++] = 0 ) ; /* how many bits in LSM */
 for (j = 1 ; j < 256 ; j <<= 1)
    for (i = 0 ; i < 256 ; i++)
       if ((i & j) > 0 )
          ARMul_BitList[i]++ ;

  for (i = 0 ; i < 256 ; i++)
    ARMul_BitList[i] *= 4 ; /* you always need 4 times these values */
    
d70 15
a84 12
ARMul_State *ARMul_NewState(void)
{ARMul_State *state ;
 unsigned i, j ;

 state = (ARMul_State *)malloc(sizeof(ARMul_State)) ;
 memset (state, 0, sizeof (ARMul_State));

 state->Emulate = RUN ;
 for (i = 0 ; i < 16 ; i++) {
    state->Reg[i] = 0 ;
    for (j = 0 ; j < 7 ; j++)
       state->RegBank[j][i] = 0 ;
d86 29
a114 27
 for (i = 0 ; i < 7 ; i++)
    state->Spsr[i] = 0 ;
 state->Mode = 0 ;

 state->CallDebug = FALSE ;
 state->Debug = FALSE ;
 state->VectorCatch = 0 ;
 state->Aborted = FALSE ;
 state->Reseted = FALSE ;
 state->Inted = 3 ;
 state->LastInted = 3 ;

 state->MemDataPtr = NULL ;
 state->MemInPtr = NULL ;
 state->MemOutPtr = NULL ;
 state->MemSparePtr = NULL ;
 state->MemSize = 0 ;

 state->OSptr = NULL ;
 state->CommandLine = NULL ;

 state->EventSet = 0 ;
 state->Now = 0 ;
 state->EventPtr = (struct EventNode **)malloc((unsigned)EVENTLISTSIZE *
                                               sizeof(struct EventNode *)) ;
 for (i = 0 ; i < EVENTLISTSIZE ; i++)
    *(state->EventPtr + i) = NULL ;
d117 2
a118 2
 state->prog32Sig = LOW ;
 state->data32Sig = LOW ;
d120 2
a121 2
 state->prog32Sig = HIGH ;
 state->data32Sig = HIGH ;
d124 2
a125 2
 state->lateabtSig = LOW ;
 state->bigendSig = LOW ;
d127 3
a129 3
 ARMul_Reset(state) ;
 return(state) ;
 }
d134 15
a148 10
 
void ARMul_SelectProcessor(ARMul_State *state, unsigned processor) {
  if (processor & ARM_Fix26_Prop) {
    state->prog32Sig = LOW;
    state->data32Sig = LOW;
  }else{
    state->prog32Sig = HIGH;
    state->data32Sig = HIGH;
  }
 
d156 10
a165 5
void ARMul_Reset(ARMul_State *state)
{state->NextInstr = 0 ;
 if (state->prog32Sig) {
    state->Reg[15] = 0 ;
    state->Cpsr = INTBITS | SVC32MODE ;
d167 5
a171 3
 else {
    state->Reg[15] = R15INTBITS | SVC26MODE ;
    state->Cpsr = INTBITS | SVC26MODE ;
d173 27
a199 25
 ARMul_CPSRAltered(state) ;
 state->Bank = SVCBANK ;
 FLUSHPIPE ;

 state->EndCondition = 0 ;
 state->ErrorCode = 0 ;

 state->Exception = FALSE ;
 state->NresetSig = HIGH ;
 state->NfiqSig = HIGH ;
 state->NirqSig = HIGH ;
 state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
 state->abortSig = LOW ;
 state->AbortAddr = 1 ;

 state->NumInstrs = 0 ;
 state->NumNcycles = 0 ;
 state->NumScycles = 0 ;
 state->NumIcycles = 0 ;
 state->NumCcycles = 0 ;
 state->NumFcycles = 0 ;
#ifdef ASIM    
  (void)ARMul_MemoryInit() ;
  ARMul_OSInit(state) ;
#endif  
d209 13
a221 10
ARMword ARMul_DoProg(ARMul_State *state)
{ARMword pc = 0 ;

 state->Emulate = RUN ;
 while (state->Emulate != STOP) {
    state->Emulate = RUN ;
    if (state->prog32Sig && ARMul_MODE32BIT)
       pc = ARMul_Emulate32(state) ;
    else
       pc = ARMul_Emulate26(state) ;
d223 2
a224 2
 return(pc) ;
 }
d232 10
a241 2
ARMword ARMul_DoInstr(ARMul_State *state)
{ARMword pc = 0 ;
d243 2
a244 8
 state->Emulate = ONCE ;
 if (state->prog32Sig && ARMul_MODE32BIT)
    pc = ARMul_Emulate32(state) ;
 else
    pc = ARMul_Emulate26(state) ;

 return(pc) ;
 }
d252 4
a255 2
void ARMul_Abort(ARMul_State *state, ARMword vector)
{ARMword temp ;
d257 1
a257 1
 state->Aborted = FALSE ;
d259 2
a260 2
 if (ARMul_OSException(state,vector,ARMul_GetPC(state)))
    return ;
d262 1
a262 1
 if (state->prog32Sig)
d264 1
a264 1
       temp = R15PC ;
d266 55
a320 54
       temp = state->Reg[15] ;
 else
    temp = R15PC | ECC | ER15INT | EMODE ;

 switch (vector) {
    case ARMul_ResetV : /* RESET */
       state->Spsr[SVCBANK] = CPSR ;
       SETABORT(INTBITS,state->prog32Sig?SVC32MODE:SVC26MODE) ;
       ARMul_CPSRAltered(state) ;
       state->Reg[14] = temp ;
       break ;
    case ARMul_UndefinedInstrV : /* Undefined Instruction */
       state->Spsr[state->prog32Sig?UNDEFBANK:SVCBANK] = CPSR ;
       SETABORT(IBIT,state->prog32Sig?UNDEF32MODE:SVC26MODE) ;
       ARMul_CPSRAltered(state) ;
       state->Reg[14] = temp - 4 ;
       break ;
    case ARMul_SWIV : /* Software Interrupt */
       state->Spsr[SVCBANK] = CPSR ;
       SETABORT(IBIT,state->prog32Sig?SVC32MODE:SVC26MODE) ;
       ARMul_CPSRAltered(state) ;
       state->Reg[14] = temp - 4 ;
       break ;
    case ARMul_PrefetchAbortV : /* Prefetch Abort */
       state->AbortAddr = 1 ;
       state->Spsr[state->prog32Sig?ABORTBANK:SVCBANK] = CPSR ;
       SETABORT(IBIT,state->prog32Sig?ABORT32MODE:SVC26MODE) ;
       ARMul_CPSRAltered(state) ;
       state->Reg[14] = temp - 4 ;
       break ;
    case ARMul_DataAbortV : /* Data Abort */
       state->Spsr[state->prog32Sig?ABORTBANK:SVCBANK] = CPSR ;
       SETABORT(IBIT,state->prog32Sig?ABORT32MODE:SVC26MODE) ;
       ARMul_CPSRAltered(state) ;
       state->Reg[14] = temp - 4 ; /* the PC must have been incremented */
       break ;
    case ARMul_AddrExceptnV : /* Address Exception */
       state->Spsr[SVCBANK] = CPSR ;
       SETABORT(IBIT,SVC26MODE) ;
       ARMul_CPSRAltered(state) ;
       state->Reg[14] = temp - 4 ;
       break ;
    case ARMul_IRQV : /* IRQ */
       state->Spsr[IRQBANK] = CPSR ;
       SETABORT(IBIT,state->prog32Sig?IRQ32MODE:IRQ26MODE) ;
       ARMul_CPSRAltered(state) ;
       state->Reg[14] = temp - 4 ;
       break ;
    case ARMul_FIQV : /* FIQ */
       state->Spsr[FIQBANK] = CPSR ;
       SETABORT(INTBITS,state->prog32Sig?FIQ32MODE:FIQ26MODE) ;
       ARMul_CPSRAltered(state) ;
       state->Reg[14] = temp - 4 ;
       break ;
d322 4
a325 4
 if (ARMul_MODE32BIT)
    ARMul_SetR15(state,vector) ;
 else
    ARMul_SetR15(state,R15CCINTMODE | vector) ;
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-2000-02-04 snapshot
@
text
@d25 13
a37 15
void ARMul_EmulateInit (void);
ARMul_State *ARMul_NewState (void);
void ARMul_Reset (ARMul_State * state);
ARMword ARMul_DoCycle (ARMul_State * state);
unsigned ARMul_DoCoPro (ARMul_State * state);
ARMword ARMul_DoProg (ARMul_State * state);
ARMword ARMul_DoInstr (ARMul_State * state);
void ARMul_Abort (ARMul_State * state, ARMword address);

unsigned ARMul_MultTable[32] =
  { 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9,
  10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 16
};
ARMword ARMul_ImmedTable[4096];	/* immediate DP LHS values */
char ARMul_BitList[256];	/* number of bits in a byte table */
d43 5
a47 8
void
ARMul_EmulateInit (void)
{
  unsigned long i, j;

  for (i = 0; i < 4096; i++)
    {				/* the values of 12 bit dp rhs's */
      ARMul_ImmedTable[i] = ROTATER (i & 0xffL, (i >> 7L) & 0x1eL);
d50 9
a58 9
  for (i = 0; i < 256; ARMul_BitList[i++] = 0);	/* how many bits in LSM */
  for (j = 1; j < 256; j <<= 1)
    for (i = 0; i < 256; i++)
      if ((i & j) > 0)
	ARMul_BitList[i]++;

  for (i = 0; i < 256; i++)
    ARMul_BitList[i] *= 4;	/* you always need 4 times these values */

d65 12
a76 15
ARMul_State *
ARMul_NewState (void)
{
  ARMul_State *state;
  unsigned i, j;

  state = (ARMul_State *) malloc (sizeof (ARMul_State));
  memset (state, 0, sizeof (ARMul_State));

  state->Emulate = RUN;
  for (i = 0; i < 16; i++)
    {
      state->Reg[i] = 0;
      for (j = 0; j < 7; j++)
	state->RegBank[j][i] = 0;
d78 27
a104 28
  for (i = 0; i < 7; i++)
    state->Spsr[i] = 0;
  state->Mode = 0;

  state->CallDebug = FALSE;
  state->Debug = FALSE;
  state->VectorCatch = 0;
  state->Aborted = FALSE;
  state->Reseted = FALSE;
  state->Inted = 3;
  state->LastInted = 3;

  state->MemDataPtr = NULL;
  state->MemInPtr = NULL;
  state->MemOutPtr = NULL;
  state->MemSparePtr = NULL;
  state->MemSize = 0;

  state->OSptr = NULL;
  state->CommandLine = NULL;

  state->EventSet = 0;
  state->Now = 0;
  state->EventPtr = (struct EventNode **) malloc ((unsigned) EVENTLISTSIZE *
						  sizeof (struct EventNode
							  *));
  for (i = 0; i < EVENTLISTSIZE; i++)
    *(state->EventPtr + i) = NULL;
d107 2
a108 2
  state->prog32Sig = LOW;
  state->data32Sig = LOW;
d110 2
a111 2
  state->prog32Sig = HIGH;
  state->data32Sig = HIGH;
d114 2
a115 2
  state->lateabtSig = LOW;
  state->bigendSig = LOW;
d117 3
a119 3
  ARMul_Reset (state);
  return (state);
}
d124 10
a133 15

void
ARMul_SelectProcessor (ARMul_State * state, unsigned processor)
{
  if (processor & ARM_Fix26_Prop)
    {
      state->prog32Sig = LOW;
      state->data32Sig = LOW;
    }
  else
    {
      state->prog32Sig = HIGH;
      state->data32Sig = HIGH;
    }

d141 5
a145 8
void
ARMul_Reset (ARMul_State * state)
{
  state->NextInstr = 0;
  if (state->prog32Sig)
    {
      state->Reg[15] = 0;
      state->Cpsr = INTBITS | SVC32MODE;
d147 3
a149 4
  else
    {
      state->Reg[15] = R15INTBITS | SVC26MODE;
      state->Cpsr = INTBITS | SVC26MODE;
d151 25
a175 25
  ARMul_CPSRAltered (state);
  state->Bank = SVCBANK;
  FLUSHPIPE;

  state->EndCondition = 0;
  state->ErrorCode = 0;

  state->Exception = FALSE;
  state->NresetSig = HIGH;
  state->NfiqSig = HIGH;
  state->NirqSig = HIGH;
  state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
  state->abortSig = LOW;
  state->AbortAddr = 1;

  state->NumInstrs = 0;
  state->NumNcycles = 0;
  state->NumScycles = 0;
  state->NumIcycles = 0;
  state->NumCcycles = 0;
  state->NumFcycles = 0;
#ifdef ASIM
  (void) ARMul_MemoryInit ();
  ARMul_OSInit (state);
#endif
d185 10
a194 13
ARMword
ARMul_DoProg (ARMul_State * state)
{
  ARMword pc = 0;

  state->Emulate = RUN;
  while (state->Emulate != STOP)
    {
      state->Emulate = RUN;
      if (state->prog32Sig && ARMul_MODE32BIT)
	pc = ARMul_Emulate32 (state);
      else
	pc = ARMul_Emulate26 (state);
d196 2
a197 2
  return (pc);
}
d205 8
a212 10
ARMword
ARMul_DoInstr (ARMul_State * state)
{
  ARMword pc = 0;

  state->Emulate = ONCE;
  if (state->prog32Sig && ARMul_MODE32BIT)
    pc = ARMul_Emulate32 (state);
  else
    pc = ARMul_Emulate26 (state);
d214 2
a215 2
  return (pc);
}
d223 2
a224 4
void
ARMul_Abort (ARMul_State * state, ARMword vector)
{
  ARMword temp;
d226 1
a226 1
  state->Aborted = FALSE;
d228 2
a229 2
  if (ARMul_OSException (state, vector, ARMul_GetPC (state)))
    return;
d231 1
a231 1
  if (state->prog32Sig)
d233 1
a233 1
      temp = R15PC;
d235 54
a288 55
      temp = state->Reg[15];
  else
    temp = R15PC | ECC | ER15INT | EMODE;

  switch (vector)
    {
    case ARMul_ResetV:		/* RESET */
      state->Spsr[SVCBANK] = CPSR;
      SETABORT (INTBITS, state->prog32Sig ? SVC32MODE : SVC26MODE);
      ARMul_CPSRAltered (state);
      state->Reg[14] = temp;
      break;
    case ARMul_UndefinedInstrV:	/* Undefined Instruction */
      state->Spsr[state->prog32Sig ? UNDEFBANK : SVCBANK] = CPSR;
      SETABORT (IBIT, state->prog32Sig ? UNDEF32MODE : SVC26MODE);
      ARMul_CPSRAltered (state);
      state->Reg[14] = temp - 4;
      break;
    case ARMul_SWIV:		/* Software Interrupt */
      state->Spsr[SVCBANK] = CPSR;
      SETABORT (IBIT, state->prog32Sig ? SVC32MODE : SVC26MODE);
      ARMul_CPSRAltered (state);
      state->Reg[14] = temp - 4;
      break;
    case ARMul_PrefetchAbortV:	/* Prefetch Abort */
      state->AbortAddr = 1;
      state->Spsr[state->prog32Sig ? ABORTBANK : SVCBANK] = CPSR;
      SETABORT (IBIT, state->prog32Sig ? ABORT32MODE : SVC26MODE);
      ARMul_CPSRAltered (state);
      state->Reg[14] = temp - 4;
      break;
    case ARMul_DataAbortV:	/* Data Abort */
      state->Spsr[state->prog32Sig ? ABORTBANK : SVCBANK] = CPSR;
      SETABORT (IBIT, state->prog32Sig ? ABORT32MODE : SVC26MODE);
      ARMul_CPSRAltered (state);
      state->Reg[14] = temp - 4;	/* the PC must have been incremented */
      break;
    case ARMul_AddrExceptnV:	/* Address Exception */
      state->Spsr[SVCBANK] = CPSR;
      SETABORT (IBIT, SVC26MODE);
      ARMul_CPSRAltered (state);
      state->Reg[14] = temp - 4;
      break;
    case ARMul_IRQV:		/* IRQ */
      state->Spsr[IRQBANK] = CPSR;
      SETABORT (IBIT, state->prog32Sig ? IRQ32MODE : IRQ26MODE);
      ARMul_CPSRAltered (state);
      state->Reg[14] = temp - 4;
      break;
    case ARMul_FIQV:		/* FIQ */
      state->Spsr[FIQBANK] = CPSR;
      SETABORT (INTBITS, state->prog32Sig ? FIQ32MODE : FIQ26MODE);
      ARMul_CPSRAltered (state);
      state->Reg[14] = temp - 4;
      break;
d290 4
a293 4
  if (ARMul_MODE32BIT)
    ARMul_SetR15 (state, vector);
  else
    ARMul_SetR15 (state, R15CCINTMODE | vector);
@


