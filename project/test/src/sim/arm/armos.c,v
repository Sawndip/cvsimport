head	1.28;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.28
	gdb_7_6-2013-04-26-release:1.28
	gdb_7_6-branch:1.28.0.2
	gdb_7_6-2013-03-12-branchpoint:1.28
	gdb_7_5_1-2012-11-29-release:1.26
	gdb_7_5-2012-08-17-release:1.26
	gdb_7_5-branch:1.26.0.34
	gdb_7_5-2012-07-18-branchpoint:1.26
	gdb_7_4_1-2012-04-26-release:1.26
	gdb_7_4-2012-01-24-release:1.26
	gdb_7_4-branch:1.26.0.32
	gdb_7_4-2011-12-13-branchpoint:1.26
	gdb_7_3_1-2011-09-04-release:1.26
	gdb_7_3-2011-07-26-release:1.26
	gdb_7_3-branch:1.26.0.30
	gdb_7_3-2011-04-01-branchpoint:1.26
	gdb_7_2-2010-09-02-release:1.26
	gdb_7_2-branch:1.26.0.28
	gdb_7_2-2010-07-07-branchpoint:1.26
	gdb_7_1-2010-03-18-release:1.26
	gdb_7_1-branch:1.26.0.26
	gdb_7_1-2010-02-18-branchpoint:1.26
	gdb_7_0_1-2009-12-22-release:1.26
	gdb_7_0-2009-10-06-release:1.26
	gdb_7_0-branch:1.26.0.24
	gdb_7_0-2009-09-16-branchpoint:1.26
	arc-sim-20090309:1.26
	msnyder-checkpoint-072509-branch:1.26.0.22
	msnyder-checkpoint-072509-branchpoint:1.26
	arc-insight_6_8-branch:1.26.0.20
	arc-insight_6_8-branchpoint:1.26
	insight_6_8-branch:1.26.0.18
	insight_6_8-branchpoint:1.26
	reverse-20081226-branch:1.26.0.16
	reverse-20081226-branchpoint:1.26
	multiprocess-20081120-branch:1.26.0.14
	multiprocess-20081120-branchpoint:1.26
	reverse-20080930-branch:1.26.0.12
	reverse-20080930-branchpoint:1.26
	reverse-20080717-branch:1.26.0.10
	reverse-20080717-branchpoint:1.26
	msnyder-reverse-20080609-branch:1.26.0.8
	msnyder-reverse-20080609-branchpoint:1.26
	drow-reverse-20070409-branch:1.26.0.6
	drow-reverse-20070409-branchpoint:1.26
	gdb_6_8-2008-03-27-release:1.26
	gdb_6_8-branch:1.26.0.4
	gdb_6_8-2008-02-26-branchpoint:1.26
	gdb_6_7_1-2007-10-29-release:1.26
	gdb_6_7-2007-10-10-release:1.26
	gdb_6_7-branch:1.26.0.2
	gdb_6_7-2007-09-07-branchpoint:1.26
	insight_6_6-20070208-release:1.25
	gdb_6_6-2006-12-18-release:1.25
	gdb_6_6-branch:1.25.0.12
	gdb_6_6-2006-11-15-branchpoint:1.25
	insight_6_5-20061003-release:1.25
	gdb-csl-symbian-6_4_50_20060226-12:1.24.2.1
	gdb-csl-sourcerygxx-3_4_4-25:1.22
	nickrob-async-20060828-mergepoint:1.25
	gdb-csl-symbian-6_4_50_20060226-11:1.24.2.1
	gdb-csl-sourcerygxx-4_1-17:1.24.2.1
	gdb-csl-20060226-branch-local-2:1.24.2.1
	gdb-csl-sourcerygxx-4_1-14:1.24.2.1
	gdb-csl-sourcerygxx-4_1-13:1.24.2.1
	gdb-csl-sourcerygxx-4_1-12:1.24.2.1
	gdb-csl-sourcerygxx-3_4_4-21:1.24.2.1
	gdb_6_5-20060621-release:1.25
	gdb-csl-sourcerygxx-4_1-9:1.24.2.1
	gdb-csl-sourcerygxx-4_1-8:1.24.2.1
	gdb-csl-sourcerygxx-4_1-7:1.24.2.1
	gdb-csl-arm-2006q1-6:1.24.2.1
	gdb-csl-sourcerygxx-4_1-6:1.24.2.1
	gdb-csl-symbian-6_4_50_20060226-10:1.24.2.1
	gdb-csl-symbian-6_4_50_20060226-9:1.24.2.1
	gdb-csl-symbian-6_4_50_20060226-8:1.24.2.1
	gdb-csl-coldfire-4_1-11:1.24.2.1
	gdb-csl-sourcerygxx-3_4_4-19:1.24.2.1
	gdb-csl-coldfire-4_1-10:1.24.2.1
	gdb_6_5-branch:1.25.0.10
	gdb_6_5-2006-05-14-branchpoint:1.25
	gdb-csl-sourcerygxx-4_1-5:1.24.2.1
	nickrob-async-20060513-branch:1.25.0.8
	nickrob-async-20060513-branchpoint:1.25
	gdb-csl-sourcerygxx-4_1-4:1.24.2.1
	msnyder-reverse-20060502-branch:1.25.0.6
	msnyder-reverse-20060502-branchpoint:1.25
	gdb-csl-morpho-4_1-4:1.24.2.1
	gdb-csl-sourcerygxx-3_4_4-17:1.24.2.1
	readline_5_1-import-branch:1.25.0.4
	readline_5_1-import-branchpoint:1.25
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.24.2.1
	gdb-csl-symbian-20060226-branch:1.24.2.1.0.2
	gdb-csl-symbian-20060226-branchpoint:1.24.2.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.24.2.1
	msnyder-reverse-20060331-branch:1.25.0.2
	msnyder-reverse-20060331-branchpoint:1.25
	gdb-csl-available-20060303-branch:1.24.0.4
	gdb-csl-available-20060303-branchpoint:1.24
	gdb-csl-20060226-branch:1.24.0.2
	gdb-csl-20060226-branchpoint:1.24
	gdb_6_4-20051202-release:1.22
	msnyder-fork-checkpoint-branch:1.23.0.2
	msnyder-fork-checkpoint-branchpoint:1.23
	gdb-csl-gxxpro-6_3-branch:1.22.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.22
	gdb_6_4-branch:1.22.0.6
	gdb_6_4-2005-11-01-branchpoint:1.22
	gdb-csl-arm-20051020-branch:1.22.0.4
	gdb-csl-arm-20051020-branchpoint:1.22
	msnyder-tracepoint-checkpoint-branch:1.22.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.22
	gdb-csl-arm-20050325-2005-q1b:1.21
	gdb-csl-arm-20050325-2005-q1a:1.21
	csl-arm-20050325-branch:1.21.0.20
	csl-arm-20050325-branchpoint:1.21
	gdb_6_3-20041109-release:1.21
	gdb_6_3-branch:1.21.0.16
	gdb_6_3-20041019-branchpoint:1.21
	drow_intercu-merge-20040921:1.21
	drow_intercu-merge-20040915:1.21
	jimb-gdb_6_2-e500-branch:1.21.0.18
	jimb-gdb_6_2-e500-branchpoint:1.21
	gdb_6_2-20040730-release:1.21
	gdb_6_2-branch:1.21.0.14
	gdb_6_2-2004-07-10-gmt-branchpoint:1.21
	gdb_6_1_1-20040616-release:1.21
	gdb_6_1-2004-04-05-release:1.21
	drow_intercu-merge-20040402:1.21
	drow_intercu-merge-20040327:1.21
	ezannoni_pie-20040323-branch:1.21.0.12
	ezannoni_pie-20040323-branchpoint:1.21
	cagney_tramp-20040321-mergepoint:1.21
	cagney_tramp-20040309-branch:1.21.0.10
	cagney_tramp-20040309-branchpoint:1.21
	gdb_6_1-branch:1.21.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.21
	drow_intercu-20040221-branch:1.21.0.6
	drow_intercu-20040221-branchpoint:1.21
	cagney_bfdfile-20040213-branch:1.21.0.4
	cagney_bfdfile-20040213-branchpoint:1.21
	drow-cplus-merge-20040208:1.21
	carlton_dictionary-20040126-merge:1.21
	cagney_bigcore-20040122-branch:1.21.0.2
	cagney_bigcore-20040122-branchpoint:1.21
	drow-cplus-merge-20040113:1.21
	drow-cplus-merge-20031224:1.20
	drow-cplus-merge-20031220:1.20
	carlton_dictionary-20031215-merge:1.20
	drow-cplus-merge-20031214:1.20
	carlton-dictionary-20031111-merge:1.20
	gdb_6_0-2003-10-04-release:1.20
	kettenis_sparc-20030918-branch:1.20.0.26
	kettenis_sparc-20030918-branchpoint:1.20
	carlton_dictionary-20030917-merge:1.20
	ezannoni_pie-20030916-branchpoint:1.20
	ezannoni_pie-20030916-branch:1.20.0.24
	cagney_x86i386-20030821-branch:1.20.0.22
	cagney_x86i386-20030821-branchpoint:1.20
	carlton_dictionary-20030805-merge:1.20
	carlton_dictionary-20030627-merge:1.20
	gdb_6_0-branch:1.20.0.20
	gdb_6_0-2003-06-23-branchpoint:1.20
	jimb-ppc64-linux-20030613-branch:1.20.0.18
	jimb-ppc64-linux-20030613-branchpoint:1.20
	cagney_convert-20030606-branch:1.20.0.16
	cagney_convert-20030606-branchpoint:1.20
	cagney_writestrings-20030508-branch:1.20.0.14
	cagney_writestrings-20030508-branchpoint:1.20
	jimb-ppc64-linux-20030528-branch:1.20.0.12
	jimb-ppc64-linux-20030528-branchpoint:1.20
	carlton_dictionary-20030523-merge:1.20
	cagney_fileio-20030521-branch:1.20.0.10
	cagney_fileio-20030521-branchpoint:1.20
	kettenis_i386newframe-20030517-mergepoint:1.20
	jimb-ppc64-linux-20030509-branch:1.20.0.8
	jimb-ppc64-linux-20030509-branchpoint:1.20
	kettenis_i386newframe-20030504-mergepoint:1.20
	carlton_dictionary-20030430-merge:1.20
	kettenis_i386newframe-20030419-branch:1.20.0.6
	kettenis_i386newframe-20030419-branchpoint:1.20
	carlton_dictionary-20030416-merge:1.20
	cagney_frameaddr-20030409-mergepoint:1.20
	kettenis_i386newframe-20030406-branch:1.20.0.4
	kettenis_i386newframe-20030406-branchpoint:1.20
	cagney_frameaddr-20030403-branchpoint:1.20
	cagney_frameaddr-20030403-branch:1.20.0.2
	cagney_framebase-20030330-mergepoint:1.20
	cagney_framebase-20030326-branch:1.19.0.10
	cagney_framebase-20030326-branchpoint:1.19
	cagney_lazyid-20030317-branch:1.19.0.8
	cagney_lazyid-20030317-branchpoint:1.19
	kettenis-i386newframe-20030316-mergepoint:1.19
	offbyone-20030313-branch:1.19.0.6
	offbyone-20030313-branchpoint:1.19
	kettenis-i386newframe-20030308-branch:1.19.0.4
	kettenis-i386newframe-20030308-branchpoint:1.19
	carlton_dictionary-20030305-merge:1.19
	cagney_offbyone-20030303-branch:1.19.0.2
	cagney_offbyone-20030303-branchpoint:1.19
	carlton_dictionary-20030207-merge:1.18
	interps-20030202-branch:1.18.0.14
	interps-20030202-branchpoint:1.18
	cagney-unwind-20030108-branch:1.18.0.12
	cagney-unwind-20030108-branchpoint:1.18
	carlton_dictionary-20021223-merge:1.18
	gdb_5_3-2002-12-12-release:1.18
	carlton_dictionary-20021115-merge:1.18
	kseitz_interps-20021105-merge:1.18
	kseitz_interps-20021103-merge:1.18
	drow-cplus-merge-20021020:1.18
	drow-cplus-merge-20021025:1.18
	carlton_dictionary-20021025-merge:1.18
	carlton_dictionary-20021011-merge:1.18
	drow-cplus-branch:1.18.0.10
	drow-cplus-branchpoint:1.18
	kseitz_interps-20020930-merge:1.18
	carlton_dictionary-20020927-merge:1.18
	carlton_dictionary-branch:1.18.0.8
	carlton_dictionary-20020920-branchpoint:1.18
	gdb_5_3-branch:1.18.0.6
	gdb_5_3-2002-09-04-branchpoint:1.18
	kseitz_interps-20020829-merge:1.18
	cagney_sysregs-20020825-branch:1.18.0.4
	cagney_sysregs-20020825-branchpoint:1.18
	readline_4_3-import-branch:1.18.0.2
	readline_4_3-import-branchpoint:1.18
	gdb_5_2_1-2002-07-23-release:1.11
	kseitz_interps-20020528-branch:1.15.0.2
	kseitz_interps-20020528-branchpoint:1.15
	cagney_regbuf-20020515-branch:1.13.0.2
	cagney_regbuf-20020515-branchpoint:1.13
	jimb-macro-020506-branch:1.11.0.4
	jimb-macro-020506-branchpoint:1.11
	gdb_5_2-2002-04-29-release:1.11
	gdb_5_2-branch:1.11.0.2
	gdb_5_2-2002-03-03-branchpoint:1.11
	gdb_5_1_1-2002-01-24-release:1.10
	gdb_5_1_0_1-2002-01-03-release:1.10
	gdb_5_1_0_1-2002-01-03-branch:1.10.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.10
	gdb_5_1-2001-11-21-release:1.10
	gdb_s390-2001-09-26-branch:1.10.0.4
	gdb_s390-2001-09-26-branchpoint:1.10
	gdb_5_1-2001-07-29-branch:1.10.0.2
	gdb_5_1-2001-07-29-branchpoint:1.10
	insight-precleanup-2001-01-01:1.6
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.5
	gdb-2000-02-04:1.1.1.5
	gdb-2000-02-02:1.1.1.4
	gdb-2000-02-01:1.1.1.4
	gdb-2000-01-31:1.1.1.4
	gdb-2000-01-26:1.1.1.4
	gdb-2000-01-24:1.1.1.4
	gdb-2000-01-17:1.1.1.4
	gdb-2000-01-10:1.1.1.4
	gdb-2000-01-05:1.1.1.4
	gdb-1999-12-21:1.1.1.4
	gdb-1999-12-13:1.1.1.4
	gdb-1999-12-07:1.1.1.4
	gdb-1999-12-06:1.1.1.4
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.28
date	2012.12.19.07.18.14;	author brobecke;	state Exp;
branches;
next	1.27;

1.27
date	2012.12.19.07.11.58;	author brobecke;	state Exp;
branches;
next	1.26;

1.26
date	2007.02.27.18.51.57;	author mmitchel;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.07.19.55.55;	author pbrook;	state Exp;
branches;
next	1.24;

1.24
date	2006.02.02.01.48.16;	author drow;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2005.11.17.04.23.03;	author drow;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.12.07.36.58;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2003.12.29.19.52.57;	author mmitchel;	state Exp;
branches;
next	1.20;

1.20
date	2003.03.27.17.13.33;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.02.10.28.29;	author nickc;	state Exp;
branches
	1.19.10.1;
next	1.18;

1.18
date	2002.08.16.09.38.09;	author nickc;	state Exp;
branches
	1.18.8.1
	1.18.10.1;
next	1.17;

1.17
date	2002.08.15.14.28.55;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.09.15.45.44;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.27.14.11.57;	author nickc;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2002.05.20.14.32.48;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.09.10.29.08;	author nickc;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2002.05.09.10.14.12;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.21.20.22.49;	author kseitz;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.28.01.04.24;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.14.03.55.57;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.14.03.50.46;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.01.00.14.40;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.11.03.08.17;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.03.23.28.46;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.30.01.55.12;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.30.17.13.37;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.08.20.54.27;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.55;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.24.2.1
date	2006.03.07.20.00.05;	author pbrook;	state Exp;
branches;
next	;

1.19.10.1
date	2003.03.30.16.35.25;	author cagney;	state Exp;
branches;
next	;

1.18.8.1
date	2003.03.06.00.56.40;	author carlton;	state Exp;
branches;
next	1.18.8.2;

1.18.8.2
date	2003.04.16.19.57.07;	author carlton;	state Exp;
branches;
next	1.18.8.3;

1.18.8.3
date	2004.01.26.19.11.53;	author carlton;	state Exp;
branches;
next	;

1.18.10.1
date	2003.12.14.20.28.16;	author drow;	state Exp;
branches;
next	1.18.10.2;

1.18.10.2
date	2004.01.13.16.12.23;	author drow;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.20.01.38.52;	author kseitz;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.08.30.22.52.57;	author kseitz;	state Exp;
branches;
next	;

1.13.2.1
date	2002.06.15.16.43.22;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.55;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.10.05.23.13.18;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.10.12.04.37.48;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.12.07.03.56.36;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.02.05.07.30.19;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.28
log
@[sim] Update old contact info in GPL license notices

sim/ChangeLog:

        Update old contact info in GPL license notices.
@
text
@/*  armos.c -- ARMulator OS interface:  ARM6 Instruction Emulator.
    Copyright (C) 1994 Advanced RISC Machines Ltd.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, see <http://www.gnu.org/licenses/>. */

/* This file contains a model of Demon, ARM Ltd's Debug Monitor,
   including all the SWI's required to support the C library. The code in
   it is not really for the faint-hearted (especially the abort handling
   code), but it is a complete example. Defining NOOS will disable all the
   fun, and definign VAILDATE will define SWI 1 to enter SVC mode, and SWI
   0x11 to halt the emulator.  */

#include "config.h"
#include "ansidecl.h"

#include <time.h>
#include <errno.h>
#include <limits.h>
#include <string.h>
#include "targ-vals.h"

#ifndef TARGET_O_BINARY
#define TARGET_O_BINARY 0
#endif

#ifdef HAVE_UNISTD_H
#include <unistd.h>		/* For SEEK_SET etc.  */
#endif

#ifdef __riscos
extern int _fisatty (FILE *);
#define isatty_(f) _fisatty(f)
#else
#ifdef __ZTC__
#include <io.h>
#define isatty_(f) isatty((f)->_file)
#else
#ifdef macintosh
#include <ioctl.h>
#define isatty_(f) (~ioctl ((f)->_file, FIOINTERACTIVE, NULL))
#else
#define isatty_(f) isatty (fileno (f))
#endif
#endif
#endif

#include "armdefs.h"
#include "armos.h"
#include "armemu.h"

#ifndef NOOS
#ifndef VALIDATE
/* #ifndef ASIM */
#include "armfpe.h"
/* #endif */
#endif
#endif

/* For RDIError_BreakpointReached.  */
#include "dbg_rdi.h"

#include "gdb/callback.h"
extern host_callback *sim_callback;

extern unsigned ARMul_OSInit       (ARMul_State *);
extern void     ARMul_OSExit       (ARMul_State *);
extern unsigned ARMul_OSHandleSWI  (ARMul_State *, ARMword);
extern unsigned ARMul_OSException  (ARMul_State *, ARMword, ARMword);
extern ARMword  ARMul_OSLastErrorP (ARMul_State *);
extern ARMword  ARMul_Debug        (ARMul_State *, ARMword, ARMword);

#define BUFFERSIZE 4096
#ifndef FOPEN_MAX
#define FOPEN_MAX 64
#endif
#define UNIQUETEMPS 256
#ifndef PATH_MAX
#define PATH_MAX 1024
#endif

/* OS private Information.  */

struct OSblock
{
  ARMword Time0;
  ARMword ErrorP;
  ARMword ErrorNo;
  FILE *FileTable[FOPEN_MAX];
  char FileFlags[FOPEN_MAX];
  char *tempnames[UNIQUETEMPS];
};

#define NOOP 0
#define BINARY 1
#define READOP 2
#define WRITEOP 4

#ifdef macintosh
#define FIXCRLF(t,c) ((t & BINARY) ? \
                      c : \
                      ((c == '\n' || c == '\r' ) ? (c ^ 7) : c) \
                     )
#else
#define FIXCRLF(t,c) c
#endif

/* Bit mask of enabled SWI implementations.  */
unsigned int swi_mask = -1;


static ARMword softvectorcode[] =
{
  /* Installed instructions:
       swi    tidyexception + event;
       mov    lr, pc;
       ldmia  fp, {fp, pc};
       swi    generateexception  + event.  */
  0xef000090, 0xe1a0e00f, 0xe89b8800, 0xef000080, /* Reset */
  0xef000091, 0xe1a0e00f, 0xe89b8800, 0xef000081, /* Undef */
  0xef000092, 0xe1a0e00f, 0xe89b8800, 0xef000082, /* SWI */
  0xef000093, 0xe1a0e00f, 0xe89b8800, 0xef000083, /* Prefetch abort */
  0xef000094, 0xe1a0e00f, 0xe89b8800, 0xef000084, /* Data abort */
  0xef000095, 0xe1a0e00f, 0xe89b8800, 0xef000085, /* Address exception */
  0xef000096, 0xe1a0e00f, 0xe89b8800, 0xef000086, /* IRQ */
  0xef000097, 0xe1a0e00f, 0xe89b8800, 0xef000087, /* FIQ */
  0xef000098, 0xe1a0e00f, 0xe89b8800, 0xef000088, /* Error */
  0xe1a0f00e			/* Default handler */
};

/* Time for the Operating System to initialise itself.  */

unsigned
ARMul_OSInit (ARMul_State * state)
{
#ifndef NOOS
#ifndef VALIDATE
  ARMword instr, i, j;
  struct OSblock *OSptr = (struct OSblock *) state->OSptr;

  if (state->OSptr == NULL)
    {
      state->OSptr = (unsigned char *) malloc (sizeof (struct OSblock));
      if (state->OSptr == NULL)
	{
	  perror ("OS Memory");
	  exit (15);
	}
    }
  
  OSptr = (struct OSblock *) state->OSptr;
  OSptr->ErrorP = 0;
  state->Reg[13] = ADDRSUPERSTACK;			/* Set up a stack for the current mode...  */
  ARMul_SetReg (state, SVC32MODE,   13, ADDRSUPERSTACK);/* ...and for supervisor mode...  */
  ARMul_SetReg (state, ABORT32MODE, 13, ADDRSUPERSTACK);/* ...and for abort 32 mode...  */
  ARMul_SetReg (state, UNDEF32MODE, 13, ADDRSUPERSTACK);/* ...and for undef 32 mode...  */
  ARMul_SetReg (state, SYSTEMMODE,  13, ADDRSUPERSTACK);/* ...and for system mode.  */
  instr = 0xe59ff000 | (ADDRSOFTVECTORS - 8);		/* Load pc from soft vector */
  
  for (i = ARMul_ResetV; i <= ARMFIQV; i += 4)
    /* Write hardware vectors.  */
    ARMul_WriteWord (state, i, instr);
  
  SWI_vector_installed = 0;

  for (i = ARMul_ResetV; i <= ARMFIQV + 4; i += 4)
    {
      ARMul_WriteWord (state, ADDRSOFTVECTORS + i, SOFTVECTORCODE + i * 4);
      ARMul_WriteWord (state, ADDRSOFHANDLERS + 2 * i + 4L,
		       SOFTVECTORCODE + sizeof (softvectorcode) - 4L);
    }

  for (i = 0; i < sizeof (softvectorcode); i += 4)
    ARMul_WriteWord (state, SOFTVECTORCODE + i, softvectorcode[i / 4]);

  for (i = 0; i < FOPEN_MAX; i++)
    OSptr->FileTable[i] = NULL;

  for (i = 0; i < UNIQUETEMPS; i++)
    OSptr->tempnames[i] = NULL;

  ARMul_ConsolePrint (state, ", Demon 1.01");

/* #ifndef ASIM */

  /* Install FPE.  */
  for (i = 0; i < fpesize; i += 4)
    /* Copy the code.  */
    ARMul_WriteWord (state, FPESTART + i, fpecode[i >> 2]);

  /* Scan backwards from the end of the code.  */
  for (i = FPESTART + fpesize;; i -= 4)
    {
      /* When we reach the marker value, break out of
	 the loop, leaving i pointing at the maker.  */
      if ((j = ARMul_ReadWord (state, i)) == 0xffffffff)
	break;

      /* If necessary, reverse the error strings.  */
      if (state->bigendSig && j < 0x80000000)
	{
	  /* It's part of the string so swap it.  */
	  j = ((j >> 0x18) & 0x000000ff) |
	    ((j >> 0x08) & 0x0000ff00) |
	    ((j << 0x08) & 0x00ff0000) | ((j << 0x18) & 0xff000000);
	  ARMul_WriteWord (state, i, j);
	}
    }

  /* Copy old illegal instr vector.  */
  ARMul_WriteWord (state, FPEOLDVECT, ARMul_ReadWord (state, ARMUndefinedInstrV));
  /* Install new vector.  */
  ARMul_WriteWord (state, ARMUndefinedInstrV, FPENEWVECT (ARMul_ReadWord (state, i - 4)));
  ARMul_ConsolePrint (state, ", FPE");

/* #endif  ASIM */
#endif /* VALIDATE */
#endif /* NOOS */

  /* Intel do not want DEMON SWI support.  */
   if (state->is_XScale)
    swi_mask = SWI_MASK_ANGEL;

   return TRUE;
}

void
ARMul_OSExit (ARMul_State * state)
{
  free ((char *) state->OSptr);
}


/* Return the last Operating System Error.  */

ARMword ARMul_OSLastErrorP (ARMul_State * state)
{
  return ((struct OSblock *) state->OSptr)->ErrorP;
}

static int translate_open_mode[] =
{
  TARGET_O_RDONLY,		/* "r"   */
  TARGET_O_RDONLY + TARGET_O_BINARY,	/* "rb"  */
  TARGET_O_RDWR,		/* "r+"  */
  TARGET_O_RDWR + TARGET_O_BINARY,		/* "r+b" */
  TARGET_O_WRONLY + TARGET_O_CREAT + TARGET_O_TRUNC,	/* "w"   */
  TARGET_O_WRONLY + TARGET_O_BINARY + TARGET_O_CREAT + TARGET_O_TRUNC,	/* "wb"  */
  TARGET_O_RDWR + TARGET_O_CREAT + TARGET_O_TRUNC,	/* "w+"  */
  TARGET_O_RDWR + TARGET_O_BINARY + TARGET_O_CREAT + TARGET_O_TRUNC,	/* "w+b" */
  TARGET_O_WRONLY + TARGET_O_APPEND + TARGET_O_CREAT,	/* "a"   */
  TARGET_O_WRONLY + TARGET_O_BINARY + TARGET_O_APPEND + TARGET_O_CREAT,	/* "ab"  */
  TARGET_O_RDWR + TARGET_O_APPEND + TARGET_O_CREAT,	/* "a+"  */
  TARGET_O_RDWR + TARGET_O_BINARY + TARGET_O_APPEND + TARGET_O_CREAT	/* "a+b" */
};

static void
SWIWrite0 (ARMul_State * state, ARMword addr)
{
  ARMword temp;
  struct OSblock *OSptr = (struct OSblock *) state->OSptr;

  while ((temp = ARMul_SafeReadByte (state, addr++)) != 0)
    {
      char buffer = temp;
      /* Note - we cannot just cast 'temp' to a (char *) here,
	 since on a big-endian host the byte value will end
	 up in the wrong place and a nul character will be printed.  */
      (void) sim_callback->write_stdout (sim_callback, & buffer, 1);
    }

  OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
}

static void
WriteCommandLineTo (ARMul_State * state, ARMword addr)
{
  ARMword temp;
  char *cptr = state->CommandLine;

  if (cptr == NULL)
    cptr = "\0";
  do
    {
      temp = (ARMword) * cptr++;
      ARMul_SafeWriteByte (state, addr++, temp);
    }
  while (temp != 0);
}

static int
ReadFileName (ARMul_State * state, char *buf, ARMword src, size_t n)
{
  struct OSblock *OSptr = (struct OSblock *) state->OSptr;
  char *p = buf;

  while (n--)
    if ((*p++ = ARMul_SafeReadByte (state, src++)) == '\0')
      return 0;
  OSptr->ErrorNo = cb_host_to_target_errno (sim_callback, ENAMETOOLONG);
  state->Reg[0] = -1;
  return -1;
}

static void
SWIopen (ARMul_State * state, ARMword name, ARMword SWIflags)
{
  struct OSblock *OSptr = (struct OSblock *) state->OSptr;
  char buf[PATH_MAX];
  int flags;

  if (ReadFileName (state, buf, name, sizeof buf) == -1)
    return;

  /* Now we need to decode the Demon open mode.  */
  flags = translate_open_mode[SWIflags];

  /* Filename ":tt" is special: it denotes stdin/out.  */
  if (strcmp (buf, ":tt") == 0)
    {
      if (flags == TARGET_O_RDONLY) /* opening tty "r" */
	state->Reg[0] = 0;	/* stdin */
      else
	state->Reg[0] = 1;	/* stdout */
    }
  else
    {
      state->Reg[0] = sim_callback->open (sim_callback, buf, flags);
      OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
    }
}

static void
SWIread (ARMul_State * state, ARMword f, ARMword ptr, ARMword len)
{
  struct OSblock *OSptr = (struct OSblock *) state->OSptr;
  int res;
  int i;
  char *local = malloc (len);

  if (local == NULL)
    {
      sim_callback->printf_filtered
	(sim_callback,
	 "sim: Unable to read 0x%ulx bytes - out of memory\n",
	 len);
      return;
    }

  res = sim_callback->read (sim_callback, f, local, len);
  if (res > 0)
    for (i = 0; i < res; i++)
      ARMul_SafeWriteByte (state, ptr + i, local[i]);

  free (local);
  state->Reg[0] = res == -1 ? -1 : len - res;
  OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
}

static void
SWIwrite (ARMul_State * state, ARMword f, ARMword ptr, ARMword len)
{
  struct OSblock *OSptr = (struct OSblock *) state->OSptr;
  int res;
  ARMword i;
  char *local = malloc (len);

  if (local == NULL)
    {
      sim_callback->printf_filtered
	(sim_callback,
	 "sim: Unable to write 0x%lx bytes - out of memory\n",
	 (long) len);
      return;
    }

  for (i = 0; i < len; i++)
    local[i] = ARMul_SafeReadByte (state, ptr + i);

  res = sim_callback->write (sim_callback, f, local, len);
  state->Reg[0] = res == -1 ? -1 : len - res;
  free (local);

  OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
}

static void
SWIflen (ARMul_State * state, ARMword fh)
{
  struct OSblock *OSptr = (struct OSblock *) state->OSptr;
  ARMword addr;

  if (fh > FOPEN_MAX)
    {
      OSptr->ErrorNo = EBADF;
      state->Reg[0] = -1L;
      return;
    }

  addr = sim_callback->lseek (sim_callback, fh, 0, SEEK_CUR);

  state->Reg[0] = sim_callback->lseek (sim_callback, fh, 0L, SEEK_END);
  (void) sim_callback->lseek (sim_callback, fh, addr, SEEK_SET);

  OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
}

static void
SWIremove (ARMul_State * state, ARMword path)
{
  char buf[PATH_MAX];

  if (ReadFileName (state, buf, path, sizeof buf) != -1)
    {
      struct OSblock *OSptr = (struct OSblock *) state->OSptr;
      state->Reg[0] = sim_callback->unlink (sim_callback, buf);
      OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
    }
}

static void
SWIrename (ARMul_State * state, ARMword old, ARMword new)
{
  char oldbuf[PATH_MAX], newbuf[PATH_MAX];

  if (ReadFileName (state, oldbuf, old, sizeof oldbuf) != -1
      && ReadFileName (state, newbuf, new, sizeof newbuf) != -1)
    {
      struct OSblock *OSptr = (struct OSblock *) state->OSptr;
      state->Reg[0] = sim_callback->rename (sim_callback, oldbuf, newbuf);
      OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
    }
}

/* The emulator calls this routine when a SWI instruction is encuntered.
   The parameter passed is the SWI number (lower 24 bits of the instruction).  */

unsigned
ARMul_OSHandleSWI (ARMul_State * state, ARMword number)
{
  struct OSblock * OSptr = (struct OSblock *) state->OSptr;
  int              unhandled = FALSE;

  switch (number)
    {
    case SWI_Read:
      if (swi_mask & SWI_MASK_DEMON)
	SWIread (state, state->Reg[0], state->Reg[1], state->Reg[2]);
      else
	unhandled = TRUE;
      break;

    case SWI_Write:
      if (swi_mask & SWI_MASK_DEMON)
	SWIwrite (state, state->Reg[0], state->Reg[1], state->Reg[2]);
      else
	unhandled = TRUE;
      break;

    case SWI_Open:
      if (swi_mask & SWI_MASK_DEMON)
	SWIopen (state, state->Reg[0], state->Reg[1]);
      else
	unhandled = TRUE;
      break;

    case SWI_Clock:
      if (swi_mask & SWI_MASK_DEMON)
	{
	  /* Return number of centi-seconds.  */
	  state->Reg[0] =
#ifdef CLOCKS_PER_SEC
	    (CLOCKS_PER_SEC >= 100)
	    ? (ARMword) (clock () / (CLOCKS_PER_SEC / 100))
	    : (ARMword) ((clock () * 100) / CLOCKS_PER_SEC);
#else
	  /* Presume unix... clock() returns microseconds.  */
	  (ARMword) (clock () / 10000);
#endif
	  OSptr->ErrorNo = errno;
	}
      else
	unhandled = TRUE;
      break;

    case SWI_Time:
      if (swi_mask & SWI_MASK_DEMON)
	{
	  state->Reg[0] = (ARMword) sim_callback->time (sim_callback, NULL);
	  OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	}
      else
	unhandled = TRUE;
      break;

    case SWI_Close:
      if (swi_mask & SWI_MASK_DEMON)
	{
	  state->Reg[0] = sim_callback->close (sim_callback, state->Reg[0]);
	  OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	}
      else
	unhandled = TRUE;
      break;

    case SWI_Flen:
      if (swi_mask & SWI_MASK_DEMON)
	SWIflen (state, state->Reg[0]);
      else
	unhandled = TRUE;
      break;

    case SWI_Exit:
      if (swi_mask & SWI_MASK_DEMON)
	state->Emulate = FALSE;
      else
	unhandled = TRUE;
      break;

    case SWI_Seek:
      if (swi_mask & SWI_MASK_DEMON)
	{
	  /* We must return non-zero for failure.  */
	  state->Reg[0] = -1 >= sim_callback->lseek (sim_callback, state->Reg[0], state->Reg[1], SEEK_SET);
	  OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	}
      else
	unhandled = TRUE;
      break;

    case SWI_WriteC:
      if (swi_mask & SWI_MASK_DEMON)
	{
	  char tmp = state->Reg[0];
	  (void) sim_callback->write_stdout (sim_callback, &tmp, 1);
	  OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	}
      else
	unhandled = TRUE;
      break;

    case SWI_Write0:
      if (swi_mask & SWI_MASK_DEMON)
	SWIWrite0 (state, state->Reg[0]);
      else
	unhandled = TRUE;
      break;

    case SWI_GetErrno:
      if (swi_mask & SWI_MASK_DEMON)
	state->Reg[0] = OSptr->ErrorNo;
      else
	unhandled = TRUE;
      break;

    case SWI_GetEnv:
      if (swi_mask & SWI_MASK_DEMON)
	{
	  state->Reg[0] = ADDRCMDLINE;
	  if (state->MemSize)
	    state->Reg[1] = state->MemSize;
	  else
	    state->Reg[1] = ADDRUSERSTACK;

	  WriteCommandLineTo (state, state->Reg[0]);
	}
      else
	unhandled = TRUE;
      break;

    case SWI_Breakpoint:
      state->EndCondition = RDIError_BreakpointReached;
      state->Emulate = FALSE;
      break;

    case SWI_Remove:
      if (swi_mask & SWI_MASK_DEMON)
	SWIremove (state, state->Reg[0]);
      else
	unhandled = TRUE;
      break;

    case SWI_Rename:
      if (swi_mask & SWI_MASK_DEMON)
	SWIrename (state, state->Reg[0], state->Reg[1]);
      else
	unhandled = TRUE;
      break;

    case SWI_IsTTY:
      if (swi_mask & SWI_MASK_DEMON)
	{
	  state->Reg[0] = sim_callback->isatty (sim_callback, state->Reg[0]);
	  OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	}
      else
	unhandled = TRUE;
      break;

      /* Handle Angel SWIs as well as Demon ones.  */
    case AngelSWI_ARM:
    case AngelSWI_Thumb:
      if (swi_mask & SWI_MASK_ANGEL)
	{
	  ARMword addr;
	  ARMword temp;

	  /* R1 is almost always a parameter block.  */
	  addr = state->Reg[1];
	  /* R0 is a reason code.  */
	  switch (state->Reg[0])
	    {
	    case -1:
	      /* This can happen when a SWI is interrupted (eg receiving a
		 ctrl-C whilst processing SWIRead()).  The SWI will complete
		 returning -1 in r0 to the caller.  If GDB is then used to
		 resume the system call the reason code will now be -1.  */
	      return TRUE;
	  
	      /* Unimplemented reason codes.  */
	    case AngelSWI_Reason_ReadC:
	    case AngelSWI_Reason_TmpNam:
	    case AngelSWI_Reason_System:
	    case AngelSWI_Reason_EnterSVC:
	    default:
	      state->Emulate = FALSE;
	      return FALSE;

	    case AngelSWI_Reason_Clock:
	      /* Return number of centi-seconds.  */
	      state->Reg[0] =
#ifdef CLOCKS_PER_SEC
		(CLOCKS_PER_SEC >= 100)
		? (ARMword) (clock () / (CLOCKS_PER_SEC / 100))
		: (ARMword) ((clock () * 100) / CLOCKS_PER_SEC);
#else
	      /* Presume unix... clock() returns microseconds.  */
	      (ARMword) (clock () / 10000);
#endif
	      OSptr->ErrorNo = errno;
	      break;

	    case AngelSWI_Reason_Time:
	      state->Reg[0] = (ARMword) sim_callback->time (sim_callback, NULL);
	      OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	      break;

	    case AngelSWI_Reason_WriteC:
	      {
		char tmp = ARMul_SafeReadByte (state, addr);
		(void) sim_callback->write_stdout (sim_callback, &tmp, 1);
		OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
		break;
	      }

	    case AngelSWI_Reason_Write0:
	      SWIWrite0 (state, addr);
	      break;

	    case AngelSWI_Reason_Close:
	      state->Reg[0] = sim_callback->close (sim_callback, ARMul_ReadWord (state, addr));
	      OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	      break;

	    case AngelSWI_Reason_Seek:
	      state->Reg[0] = -1 >= sim_callback->lseek (sim_callback, ARMul_ReadWord (state, addr),
							 ARMul_ReadWord (state, addr + 4),
							 SEEK_SET);
	      OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	      break;

	    case AngelSWI_Reason_FLen:
	      SWIflen (state, ARMul_ReadWord (state, addr));
	      break;

	    case AngelSWI_Reason_GetCmdLine:
	      WriteCommandLineTo (state, ARMul_ReadWord (state, addr));
	      break;

	    case AngelSWI_Reason_HeapInfo:
	      /* R1 is a pointer to a pointer.  */
	      addr = ARMul_ReadWord (state, addr);

	      /* Pick up the right memory limit.  */
	      if (state->MemSize)
		temp = state->MemSize;
	      else
		temp = ADDRUSERSTACK;

	      ARMul_WriteWord (state, addr, 0);		/* Heap base.  */
	      ARMul_WriteWord (state, addr + 4, temp);	/* Heap limit.  */
	      ARMul_WriteWord (state, addr + 8, temp);	/* Stack base.  */
	      ARMul_WriteWord (state, addr + 12, temp);	/* Stack limit.  */
	      break;

	    case AngelSWI_Reason_ReportException:
	      if (state->Reg[1] == ADP_Stopped_ApplicationExit)
		state->Reg[0] = 0;
	      else
		state->Reg[0] = -1;
	      state->Emulate = FALSE;
	      break;

	    case ADP_Stopped_ApplicationExit:
	      state->Reg[0] = 0;
	      state->Emulate = FALSE;
	      break;

	    case ADP_Stopped_RunTimeError:
	      state->Reg[0] = -1;
	      state->Emulate = FALSE;
	      break;

	    case AngelSWI_Reason_Errno:
	      state->Reg[0] = OSptr->ErrorNo;
	      break;

	    case AngelSWI_Reason_Open:
	      SWIopen (state,
		       ARMul_ReadWord (state, addr),
		       ARMul_ReadWord (state, addr + 4));
	      break;

	    case AngelSWI_Reason_Read:
	      SWIread (state,
		       ARMul_ReadWord (state, addr),
		       ARMul_ReadWord (state, addr + 4),
		       ARMul_ReadWord (state, addr + 8));
	      break;

	    case AngelSWI_Reason_Write:
	      SWIwrite (state,
			ARMul_ReadWord (state, addr),
			ARMul_ReadWord (state, addr + 4),
			ARMul_ReadWord (state, addr + 8));
	      break;

	    case AngelSWI_Reason_IsTTY:
	      state->Reg[0] = sim_callback->isatty (sim_callback,
						    ARMul_ReadWord (state, addr));
	      OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	      break;

	    case AngelSWI_Reason_Remove:
	      SWIremove (state,
			 ARMul_ReadWord (state, addr));

	    case AngelSWI_Reason_Rename:
	      SWIrename (state,
			 ARMul_ReadWord (state, addr),
			 ARMul_ReadWord (state, addr + 4));
	    }
	}
      else
	unhandled = TRUE;
      break;

      /* The following SWIs are generated by the softvectorcode[]
	 installed by default by the simulator.  */
    case 0x91: /* Undefined Instruction.  */
      {
	ARMword addr = state->RegBank[UNDEFBANK][14] - 4;
	
	sim_callback->printf_filtered
	  (sim_callback, "sim: exception: Unhandled Instruction '0x%08x' at 0x%08x.  Stopping.\n",
	   ARMul_ReadWord (state, addr), addr);
	state->EndCondition = RDIError_SoftwareInterrupt;
	state->Emulate = FALSE;
	return FALSE;
      }      

    case 0x90: /* Reset.  */
    case 0x92: /* SWI.  */
      /* These two can be safely ignored.  */
      break;

    case 0x93: /* Prefetch Abort.  */
    case 0x94: /* Data Abort.  */
    case 0x95: /* Address Exception.  */
    case 0x96: /* IRQ.  */
    case 0x97: /* FIQ.  */
    case 0x98: /* Error.  */
      unhandled = TRUE;
      break;

    case -1:
      /* This can happen when a SWI is interrupted (eg receiving a
	 ctrl-C whilst processing SWIRead()).  The SWI will complete
	 returning -1 in r0 to the caller.  If GDB is then used to
	 resume the system call the reason code will now be -1.  */
      return TRUE;
	  
    case 0x180001: /* RedBoot's Syscall SWI in ARM mode.  */
      if (swi_mask & SWI_MASK_REDBOOT)
	{
	  switch (state->Reg[0])
	    {
	      /* These numbers are defined in libgloss/syscall.h
		 but the simulator should not be dependend upon
		 libgloss being installed.  */
	    case 1:  /* Exit.  */
	      state->Emulate = FALSE;
	      /* Copy exit code into r0.  */
	      state->Reg[0] = state->Reg[1];
	      break;

	    case 2:  /* Open.  */
	      SWIopen (state, state->Reg[1], state->Reg[2]);
	      break;

	    case 3:  /* Close.  */
	      state->Reg[0] = sim_callback->close (sim_callback, state->Reg[1]);
	      OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	      break;

	    case 4:  /* Read.  */
	      SWIread (state, state->Reg[1], state->Reg[2], state->Reg[3]);
	      break;

	    case 5:  /* Write.  */
	      SWIwrite (state, state->Reg[1], state->Reg[2], state->Reg[3]);
	      break;

	    case 6:  /* Lseek.  */
	      state->Reg[0] = sim_callback->lseek (sim_callback,
						   state->Reg[1],
						   state->Reg[2],
						   state->Reg[3]);
	      OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	      break;

	    case 17: /* Utime.  */
	      state->Reg[0] = (ARMword) sim_callback->time (sim_callback,
							    (long *) state->Reg[1]);
	      OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	      break;

	    case 7:  /* Unlink.  */
	    case 8:  /* Getpid.  */
	    case 9:  /* Kill.  */
	    case 10: /* Fstat.  */
	    case 11: /* Sbrk.  */
	    case 12: /* Argvlen.  */
	    case 13: /* Argv.  */
	    case 14: /* ChDir.  */
	    case 15: /* Stat.  */
	    case 16: /* Chmod.  */
	    case 18: /* Time.  */
	      sim_callback->printf_filtered
		(sim_callback,
		 "sim: unhandled RedBoot syscall `%d' encountered - "
		 "returning ENOSYS\n",
		 state->Reg[0]);
	      state->Reg[0] = -1;
	      OSptr->ErrorNo = cb_host_to_target_errno
		(sim_callback, ENOSYS);
	      break;
	    case 1001: /* Meminfo. */
	      {
		ARMword totmem = state->Reg[1],
			topmem = state->Reg[2];
		ARMword stack = state->MemSize > 0
		  ? state->MemSize : ADDRUSERSTACK;
		if (totmem != 0)
		  ARMul_WriteWord (state, totmem, stack);
		if (topmem != 0)
		  ARMul_WriteWord (state, topmem, stack);
		state->Reg[0] = 0;
		break;
	      }

	    default:
	      sim_callback->printf_filtered
		(sim_callback,
		 "sim: unknown RedBoot syscall '%d' encountered - ignoring\n",
		 state->Reg[0]);
	      return FALSE;
	    }
	  break;
	}
      
    default:
      unhandled = TRUE;
    }
      
  if (unhandled)
    {
      if (SWI_vector_installed)
	{
	  ARMword cpsr;
	  ARMword i_size;

	  cpsr = ARMul_GetCPSR (state);
	  i_size = INSN_SIZE;

	  ARMul_SetSPSR (state, SVC32MODE, cpsr);

	  cpsr &= ~0xbf;
	  cpsr |= SVC32MODE | 0x80;
	  ARMul_SetCPSR (state, cpsr);

	  state->RegBank[SVCBANK][14] = state->Reg[14] = state->Reg[15] - i_size;
	  state->NextInstr            = RESUME;
	  state->Reg[15]              = state->pc = ARMSWIV;
	  FLUSHPIPE;
	}
      else
	{
	  sim_callback->printf_filtered
	    (sim_callback,
	     "sim: unknown SWI encountered - %x - ignoring\n",
	     number);
	  return FALSE;
	}
    }

  return TRUE;
}

#ifndef NOOS
#ifndef ASIM

/* The emulator calls this routine when an Exception occurs.  The second
   parameter is the address of the relevant exception vector.  Returning
   FALSE from this routine causes the trap to be taken, TRUE causes it to
   be ignored (so set state->Emulate to FALSE!).  */

unsigned
ARMul_OSException (ARMul_State * state  ATTRIBUTE_UNUSED,
		   ARMword       vector ATTRIBUTE_UNUSED,
		   ARMword       pc     ATTRIBUTE_UNUSED)
{
  return FALSE;
}

#endif
#endif /* NOOS */
@


1.27
log
@Update sim copyright headers from GPLv2-or-later to GPLv3-or-later.

gdb/sim/ChangeLog:

        Update the non-FSF-copyrighted files in sim to GPLv3 or later.
@
text
@d15 1
a15 2
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA. */
@


1.26
log
@	* armos.c (SWIflen): Do not treate file descriptor zero as
	special.
@
text
@d6 1
a6 1
    the Free Software Foundation; either version 2 of the License, or
@


1.25
log
@2006-03-07  Paul Brook  <paul@@codesourcery.com>

	* elfos.c (ARMul_OSHandleSWI): Call correct function for IsTTY.
@
text
@d404 1
a404 1
  if (fh == 0 || fh > FOPEN_MAX)
@


1.24
log
@	* armos.c (ARMul_OSHandleSWI): Handle the RedBoot system
	call meminfo. Return ENOSYS for unhandled RedBoot syscalls.
@
text
@d750 2
a751 2
	      state->Reg[0] = sim_callback->close (sim_callback,
						   ARMul_ReadWord (state, addr));
@


1.24.2.1
log
@2006-03-07  Paul Brook  <paul@@codesourcery.com>

	Backport from mainline.
	* sim/arm/elfos.c (ARMul_OSHandleSWI): Call correct function for IsTTY.
@
text
@d750 2
a751 2
	      state->Reg[0] = sim_callback->isatty (sim_callback,
						    ARMul_ReadWord (state, addr));
@


1.23
log
@2005-11-16  Shaun Jackman  <sjackman@@gmail.com>

	* sim/arm/armos.c: Include limits.h
	(unlink): Remove this macro. It is unused in this file and
	conflicts with sim_callback->unlink.
	(PATH_MAX): Define as 1024 if not already defined.
	(ReadFileName): New function.
	(SWIopen): Fix a potential buffer overflow.
	(SWIremove): New function.
	(SWIrename): Ditto.
	(ARMul_OSHandleSWI): Handle the RDP calls SWI_IsTTY,
	SWI_Remove, and SWI_Rename, as well as the RDI calls
	AngelSWI_Reason_IsTTY, AngelSWI_Reason_Remove, and
	AngelSWI_Reason_Rename.
@
text
@d862 2
a863 1
		 "sim: unhandled RedBoot syscall '%d' encountered - ignoring\n",
d865 17
a881 1
	      return FALSE;
@


1.22
log
@Update the address of the FSF organization
@
text
@d30 1
a37 4
#ifdef __STDC__
#define unlink(s) remove(s)
#endif

d89 3
d302 14
d320 1
a320 1
  char dummy[2000];
a321 1
  int i;
d323 2
a324 2
  for (i = 0; (dummy[i] = ARMul_SafeReadByte (state, name + i)); i++)
    ;
d330 1
a330 1
  if (strcmp (dummy, ":tt") == 0)
d339 1
a339 1
      state->Reg[0] = sim_callback->open (sim_callback, dummy, flags);
d419 27
d587 24
a632 1
	    case AngelSWI_Reason_IsTTY:
a633 2
	    case AngelSWI_Reason_Remove:
	    case AngelSWI_Reason_Rename:
d748 15
@


1.21
log
@	* armos.c (fcntl.h): Do not include it.
	(O_RDONLY): Do not define.
	(O_WRONLY): Likewise.
	(O_RDWR): Likewise.
	(targ-vals.h): Include it.
	(translate_open_mode): Use TARGET_O_* instead of O_*.
	(SWIopen): Likewise.
	* Makefile.in (armos.o): Depend on targ-vals.h.
@
text
@d16 1
a16 1
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
@


1.20
log
@Add iWMMXt support to ARM simulator
@
text
@d31 1
a31 1
#include <fcntl.h>
d33 2
a34 11
#ifndef O_RDONLY
#define O_RDONLY 0
#endif
#ifndef O_WRONLY
#define O_WRONLY 1
#endif
#ifndef O_RDWR
#define O_RDWR   2
#endif
#ifndef O_BINARY
#define O_BINARY 0
d254 12
a265 12
  O_RDONLY,			/* "r"   */
  O_RDONLY + O_BINARY,		/* "rb"  */
  O_RDWR,			/* "r+"  */
  O_RDWR + O_BINARY,		/* "r+b" */
  O_WRONLY + O_CREAT + O_TRUNC,	/* "w"   */
  O_WRONLY + O_BINARY + O_CREAT + O_TRUNC,	/* "wb"  */
  O_RDWR + O_CREAT + O_TRUNC,	/* "w+"  */
  O_RDWR + O_BINARY + O_CREAT + O_TRUNC,	/* "w+b" */
  O_WRONLY + O_APPEND + O_CREAT,	/* "a"   */
  O_WRONLY + O_BINARY + O_APPEND + O_CREAT,	/* "ab"  */
  O_RDWR + O_APPEND + O_CREAT,	/* "a+"  */
  O_RDWR + O_BINARY + O_APPEND + O_CREAT	/* "a+b" */
d319 1
a319 1
      if (flags == O_RDONLY)	/* opening tty "r" */
@


1.19
log
@(SWIWrite0): Catch big-endian bug when printing characters
@
text
@d134 5
a138 2
  /* Basic: swi tidyexception + event; mov pc, lr;
     ldmia r11,{r11,pc}; swi generateexception  + event.  */
d211 1
d214 2
a215 1
      /* Reverse the error strings.  */
d218 2
d231 1
a231 1
  ARMul_WriteWord (state, FPEOLDVECT, ARMul_ReadWord (state, 4));
d233 1
a233 1
  ARMul_WriteWord (state, 4, FPENEWVECT (ARMul_ReadWord (state, i - 4)));
d702 26
a727 4
    case 0x90:
    case 0x91:
    case 0x92:
      /* These are used by the FPE code.  */
d729 1
a729 1
      
@


1.19.10.1
log
@Merge with mainline.
@
text
@d134 2
a135 5
  /* Installed instructions:
       swi    tidyexception + event;
       mov    lr, pc;
       ldmia  fp, {fp, pc};
       swi    generateexception  + event.  */
a207 1
  /* Scan backwards from the end of the code.  */
d210 1
a210 2
      /* When we reach the marker value, break out of
	 the loop, leaving i pointing at the maker.  */
a212 2

      /* If necessary, reverse the error strings.  */
d224 1
a224 1
  ARMul_WriteWord (state, FPEOLDVECT, ARMul_ReadWord (state, ARMUndefinedInstrV));
d226 1
a226 1
  ARMul_WriteWord (state, ARMUndefinedInstrV, FPENEWVECT (ARMul_ReadWord (state, i - 4)));
d695 4
a698 26
      /* The following SWIs are generated by the softvectorcode[]
	 installed by default by the simulator.  */
    case 0x91: /* Undefined Instruction.  */
      {
	ARMword addr = state->RegBank[UNDEFBANK][14] - 4;
	
	sim_callback->printf_filtered
	  (sim_callback, "sim: exception: Unhandled Instruction '0x%08x' at 0x%08x.  Stopping.\n",
	   ARMul_ReadWord (state, addr), addr);
	state->EndCondition = RDIError_SoftwareInterrupt;
	state->Emulate = FALSE;
	return FALSE;
      }      

    case 0x90: /* Reset.  */
    case 0x92: /* SWI.  */
      /* These two can be safely ignored.  */
      break;

    case 0x93: /* Prefetch Abort.  */
    case 0x94: /* Data Abort.  */
    case 0x95: /* Address Exception.  */
    case 0x96: /* IRQ.  */
    case 0x97: /* FIQ.  */
    case 0x98: /* Error.  */
      unhandled = TRUE;
d700 1
a700 1

@


1.18
log
@oops - fix typo in previous delta
@
text
@d277 7
a283 1
    (void) sim_callback->write_stdout (sim_callback, (char *) &temp, 1);
@


1.18.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d134 2
a135 5
  /* Installed instructions:
       swi    tidyexception + event;
       mov    lr, pc;
       ldmia  fp, {fp, pc};
       swi    generateexception  + event.  */
a207 1
  /* Scan backwards from the end of the code.  */
d210 1
a210 2
      /* When we reach the marker value, break out of
	 the loop, leaving i pointing at the maker.  */
a212 2

      /* If necessary, reverse the error strings.  */
d224 1
a224 1
  ARMul_WriteWord (state, FPEOLDVECT, ARMul_ReadWord (state, ARMUndefinedInstrV));
d226 1
a226 1
  ARMul_WriteWord (state, ARMUndefinedInstrV, FPENEWVECT (ARMul_ReadWord (state, i - 4)));
d277 1
a277 7
    {
      char buffer = temp;
      /* Note - we cannot just cast 'temp' to a (char *) here,
	 since on a big-endian host the byte value will end
	 up in the wrong place and a nul character will be printed.  */
      (void) sim_callback->write_stdout (sim_callback, & buffer, 1);
    }
d689 4
a692 26
      /* The following SWIs are generated by the softvectorcode[]
	 installed by default by the simulator.  */
    case 0x91: /* Undefined Instruction.  */
      {
	ARMword addr = state->RegBank[UNDEFBANK][14] - 4;
	
	sim_callback->printf_filtered
	  (sim_callback, "sim: exception: Unhandled Instruction '0x%08x' at 0x%08x.  Stopping.\n",
	   ARMul_ReadWord (state, addr), addr);
	state->EndCondition = RDIError_SoftwareInterrupt;
	state->Emulate = FALSE;
	return FALSE;
      }      

    case 0x90: /* Reset.  */
    case 0x92: /* SWI.  */
      /* These two can be safely ignored.  */
      break;

    case 0x93: /* Prefetch Abort.  */
    case 0x94: /* Data Abort.  */
    case 0x95: /* Address Exception.  */
    case 0x96: /* IRQ.  */
    case 0x97: /* FIQ.  */
    case 0x98: /* Error.  */
      unhandled = TRUE;
d694 1
a694 1

@


1.18.10.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d31 1
a31 1
#include "targ-vals.h"
d33 11
a43 2
#ifndef TARGET_O_BINARY
#define TARGET_O_BINARY 0
d263 12
a274 12
  TARGET_O_RDONLY,		/* "r"   */
  TARGET_O_RDONLY + TARGET_O_BINARY,	/* "rb"  */
  TARGET_O_RDWR,		/* "r+"  */
  TARGET_O_RDWR + TARGET_O_BINARY,		/* "r+b" */
  TARGET_O_WRONLY + TARGET_O_CREAT + TARGET_O_TRUNC,	/* "w"   */
  TARGET_O_WRONLY + TARGET_O_BINARY + TARGET_O_CREAT + TARGET_O_TRUNC,	/* "wb"  */
  TARGET_O_RDWR + TARGET_O_CREAT + TARGET_O_TRUNC,	/* "w+"  */
  TARGET_O_RDWR + TARGET_O_BINARY + TARGET_O_CREAT + TARGET_O_TRUNC,	/* "w+b" */
  TARGET_O_WRONLY + TARGET_O_APPEND + TARGET_O_CREAT,	/* "a"   */
  TARGET_O_WRONLY + TARGET_O_BINARY + TARGET_O_APPEND + TARGET_O_CREAT,	/* "ab"  */
  TARGET_O_RDWR + TARGET_O_APPEND + TARGET_O_CREAT,	/* "a+"  */
  TARGET_O_RDWR + TARGET_O_BINARY + TARGET_O_APPEND + TARGET_O_CREAT	/* "a+b" */
d328 1
a328 1
      if (flags == TARGET_O_RDONLY) /* opening tty "r" */
@


1.18.8.1
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d277 1
a277 7
    {
      char buffer = temp;
      /* Note - we cannot just cast 'temp' to a (char *) here,
	 since on a big-endian host the byte value will end
	 up in the wrong place and a nul character will be printed.  */
      (void) sim_callback->write_stdout (sim_callback, & buffer, 1);
    }
@


1.18.8.2
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d134 2
a135 5
  /* Installed instructions:
       swi    tidyexception + event;
       mov    lr, pc;
       ldmia  fp, {fp, pc};
       swi    generateexception  + event.  */
a207 1
  /* Scan backwards from the end of the code.  */
d210 1
a210 2
      /* When we reach the marker value, break out of
	 the loop, leaving i pointing at the maker.  */
a212 2

      /* If necessary, reverse the error strings.  */
d224 1
a224 1
  ARMul_WriteWord (state, FPEOLDVECT, ARMul_ReadWord (state, ARMUndefinedInstrV));
d226 1
a226 1
  ARMul_WriteWord (state, ARMUndefinedInstrV, FPENEWVECT (ARMul_ReadWord (state, i - 4)));
d695 4
a698 26
      /* The following SWIs are generated by the softvectorcode[]
	 installed by default by the simulator.  */
    case 0x91: /* Undefined Instruction.  */
      {
	ARMword addr = state->RegBank[UNDEFBANK][14] - 4;
	
	sim_callback->printf_filtered
	  (sim_callback, "sim: exception: Unhandled Instruction '0x%08x' at 0x%08x.  Stopping.\n",
	   ARMul_ReadWord (state, addr), addr);
	state->EndCondition = RDIError_SoftwareInterrupt;
	state->Emulate = FALSE;
	return FALSE;
      }      

    case 0x90: /* Reset.  */
    case 0x92: /* SWI.  */
      /* These two can be safely ignored.  */
      break;

    case 0x93: /* Prefetch Abort.  */
    case 0x94: /* Data Abort.  */
    case 0x95: /* Address Exception.  */
    case 0x96: /* IRQ.  */
    case 0x97: /* FIQ.  */
    case 0x98: /* Error.  */
      unhandled = TRUE;
d700 1
a700 1

@


1.18.8.3
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d31 1
a31 1
#include "targ-vals.h"
d33 11
a43 2
#ifndef TARGET_O_BINARY
#define TARGET_O_BINARY 0
d263 12
a274 12
  TARGET_O_RDONLY,		/* "r"   */
  TARGET_O_RDONLY + TARGET_O_BINARY,	/* "rb"  */
  TARGET_O_RDWR,		/* "r+"  */
  TARGET_O_RDWR + TARGET_O_BINARY,		/* "r+b" */
  TARGET_O_WRONLY + TARGET_O_CREAT + TARGET_O_TRUNC,	/* "w"   */
  TARGET_O_WRONLY + TARGET_O_BINARY + TARGET_O_CREAT + TARGET_O_TRUNC,	/* "wb"  */
  TARGET_O_RDWR + TARGET_O_CREAT + TARGET_O_TRUNC,	/* "w+"  */
  TARGET_O_RDWR + TARGET_O_BINARY + TARGET_O_CREAT + TARGET_O_TRUNC,	/* "w+b" */
  TARGET_O_WRONLY + TARGET_O_APPEND + TARGET_O_CREAT,	/* "a"   */
  TARGET_O_WRONLY + TARGET_O_BINARY + TARGET_O_APPEND + TARGET_O_CREAT,	/* "ab"  */
  TARGET_O_RDWR + TARGET_O_APPEND + TARGET_O_CREAT,	/* "a+"  */
  TARGET_O_RDWR + TARGET_O_BINARY + TARGET_O_APPEND + TARGET_O_CREAT	/* "a+b" */
d328 1
a328 1
      if (flags == TARGET_O_RDONLY) /* opening tty "r" */
@


1.17
log
@Catch and ignore SWIs of -1, they can be caused by an interrupted system
call being resumed by GDB.
@
text
@d561 1
a561 1
	      return FALSE;
d700 1
a700 1
      return FALSE;
@


1.16
log
@Move include/callback.h and include/remote-sim.h to include/gdb/.
Update accordingly.
@
text
@d556 7
d695 7
@


1.15
log
@Only perform access checks if 'check' is set.
Report unknown machine numbers.
Formatting tidy ups.
@
text
@d86 1
a86 1
#include "callback.h"
@


1.15.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d86 1
a86 1
#include "gdb/callback.h"
@


1.15.2.2
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a555 7
	    case -1:
	      /* This can happen when a SWI is interrupted (eg receiving a
		 ctrl-C whilst processing SWIRead()).  The SWI will complete
		 returning -1 in r0 to the caller.  If GDB is then used to
		 resume the system call the reason code will now be -1.  */
	      return TRUE;
	  
a687 7
    case -1:
      /* This can happen when a SWI is interrupted (eg receiving a
	 ctrl-C whilst processing SWIRead()).  The SWI will complete
	 returning -1 in r0 to the caller.  If GDB is then used to
	 resume the system call the reason code will now be -1.  */
      return TRUE;
	  
@


1.14
log
@Add support for target specific command line switches to old-style simualtors.
Make use of this support in the ARM simulator to add a --swi-support= switch
to select whcih SWI protocols to emulate.
@
text
@d236 2
a237 2
 
  return TRUE;
@


1.13
log
@Uses sim callback interface for system calls in RedBoot SWI support.
@
text
@d128 4
d233 4
a407 3
  ARMword          addr;
  ARMword          temp;
  ARMword          saved_number = 0;
d409 2
a410 24
  
  /* Intel do not want DEMON SWI support.  */
  if (state->is_XScale)
    switch (number)
    {
    case SWI_Read:
    case SWI_Write:
    case SWI_Open:
    case SWI_Clock:
    case SWI_Time:
    case SWI_Close:
    case SWI_Flen:
    case SWI_Exit:
    case SWI_Seek:
    case SWI_WriteC:
    case SWI_Write0:
    case SWI_GetErrno:
    case SWI_GetEnv:
      saved_number = number;
      number = -1;
    default:
      break;
    }
  
d414 4
a417 1
      SWIread (state, state->Reg[0], state->Reg[1], state->Reg[2]);
d421 4
a424 1
      SWIwrite (state, state->Reg[0], state->Reg[1], state->Reg[2]);
d428 4
a431 1
      SWIopen (state, state->Reg[0], state->Reg[1]);
d435 4
a438 2
      /* Return number of centi-seconds.  */
      state->Reg[0] =
d440 3
a442 3
	(CLOCKS_PER_SEC >= 100)
	? (ARMword) (clock () / (CLOCKS_PER_SEC / 100))
	: (ARMword) ((clock () * 100) / CLOCKS_PER_SEC);
d444 2
a445 2
	/* Presume unix... clock() returns microseconds.  */
	(ARMword) (clock () / 10000);
d447 4
a450 1
      OSptr->ErrorNo = errno;
d454 7
a460 2
      state->Reg[0] = (ARMword) sim_callback->time (sim_callback, NULL);
      OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
d464 7
a470 2
      state->Reg[0] = sim_callback->close (sim_callback, state->Reg[0]);
      OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
d474 4
a477 1
      SWIflen (state, state->Reg[0]);
d481 4
a484 1
      state->Emulate = FALSE;
d488 8
a495 3
      /* We must return non-zero for failure.  */
      state->Reg[0] = -1 >= sim_callback->lseek (sim_callback, state->Reg[0], state->Reg[1], SEEK_SET);
      OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
d499 8
a506 5
      {
	char tmp = state->Reg[0];
	(void) sim_callback->write_stdout (sim_callback, &tmp, 1);
	OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
      }
d510 4
a513 1
      SWIWrite0 (state, state->Reg[0]);
d517 4
a520 1
      state->Reg[0] = OSptr->ErrorNo;
d524 10
a533 3
      state->Reg[0] = ADDRCMDLINE;
      if (state->MemSize)
	state->Reg[1] = state->MemSize;
d535 1
a535 3
	state->Reg[1] = ADDRUSERSTACK;

      WriteCommandLineTo (state, state->Reg[0]);
d546 1
a546 4
      /* R1 is almost always a parameter block.  */
      addr = state->Reg[1];
      /* R0 is a reason code.  */
      switch (state->Reg[0])
d548 2
a549 11
	  /* Unimplemented reason codes.  */
	case AngelSWI_Reason_ReadC:
	case AngelSWI_Reason_IsTTY:
	case AngelSWI_Reason_TmpNam:
	case AngelSWI_Reason_Remove:
	case AngelSWI_Reason_Rename:
	case AngelSWI_Reason_System:
	case AngelSWI_Reason_EnterSVC:
	default:
	  state->Emulate = FALSE;
	  return FALSE;
d551 20
a570 3
	case AngelSWI_Reason_Clock:
	  /* Return number of centi-seconds.  */
	  state->Reg[0] =
d572 3
a574 3
	    (CLOCKS_PER_SEC >= 100)
	    ? (ARMword) (clock () / (CLOCKS_PER_SEC / 100))
	    : (ARMword) ((clock () * 100) / CLOCKS_PER_SEC);
d576 2
a577 2
	    /* Presume unix... clock() returns microseconds.  */
	    (ARMword) (clock () / 10000);
d579 2
a580 83
	  OSptr->ErrorNo = errno;
	  break;

	case AngelSWI_Reason_Time:
	  state->Reg[0] = (ARMword) sim_callback->time (sim_callback, NULL);
	  OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	  break;

	case AngelSWI_Reason_WriteC:
	  {
	    char tmp = ARMul_SafeReadByte (state, addr);
	    (void) sim_callback->write_stdout (sim_callback, &tmp, 1);
	    OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	  }
	  /* Fall thgrough.  */

	case AngelSWI_Reason_Write0:
	  SWIWrite0 (state, addr);
	  break;

	case AngelSWI_Reason_Close:
	  state->Reg[0] = sim_callback->close (sim_callback, ARMul_ReadWord (state, addr));
	  OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	  break;

	case AngelSWI_Reason_Seek:
	  state->Reg[0] = -1 >= sim_callback->lseek (sim_callback, ARMul_ReadWord (state, addr),
				       ARMul_ReadWord (state, addr + 4),
				       SEEK_SET);
	  OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	  break;

	case AngelSWI_Reason_FLen:
	  SWIflen (state, ARMul_ReadWord (state, addr));
	  break;

	case AngelSWI_Reason_GetCmdLine:
	  WriteCommandLineTo (state, ARMul_ReadWord (state, addr));
	  break;

	case AngelSWI_Reason_HeapInfo:
	  /* R1 is a pointer to a pointer.  */
	  addr = ARMul_ReadWord (state, addr);

	  /* Pick up the right memory limit.  */
	  if (state->MemSize)
	    temp = state->MemSize;
	  else
	    temp = ADDRUSERSTACK;

	  ARMul_WriteWord (state, addr, 0);		/* Heap base.  */
	  ARMul_WriteWord (state, addr + 4, temp);	/* Heap limit.  */
	  ARMul_WriteWord (state, addr + 8, temp);	/* Stack base.  */
	  ARMul_WriteWord (state, addr + 12, temp);	/* Stack limit.  */
	  break;

	case AngelSWI_Reason_ReportException:
	  if (state->Reg[1] == ADP_Stopped_ApplicationExit)
	    state->Reg[0] = 0;
	  else
	    state->Reg[0] = -1;
	  state->Emulate = FALSE;
	  break;

	case ADP_Stopped_ApplicationExit:
	  state->Reg[0] = 0;
	  state->Emulate = FALSE;
	  break;

	case ADP_Stopped_RunTimeError:
	  state->Reg[0] = -1;
	  state->Emulate = FALSE;
	  break;

	case AngelSWI_Reason_Errno:
	  state->Reg[0] = OSptr->ErrorNo;
	  break;

	case AngelSWI_Reason_Open:
	  SWIopen (state,
		   ARMul_ReadWord (state, addr),
		   ARMul_ReadWord (state, addr + 4));
	  break;
d582 95
a676 13
	case AngelSWI_Reason_Read:
	  SWIread (state,
		   ARMul_ReadWord (state, addr),
		   ARMul_ReadWord (state, addr + 4),
		   ARMul_ReadWord (state, addr + 8));
	  break;

	case AngelSWI_Reason_Write:
	  SWIwrite (state,
		    ARMul_ReadWord (state, addr),
		    ARMul_ReadWord (state, addr + 4),
		    ARMul_ReadWord (state, addr + 8));
	  break;
d678 3
d689 1
a689 1
      switch (state->Reg[0])
d691 67
a757 61
	  /* These numbers are defined in libgloss/syscall.h
	     but the simulator should not be dependend upon
	     libgloss being installed.  */
	case 1:  /* Exit.  */
	  state->Emulate = FALSE;
	  return TRUE;

	case 2:  /* Open.  */
	  SWIopen (state, state->Reg[1], state->Reg[2]);
	  return TRUE;

	case 3:  /* Close.  */
	  state->Reg[0] = sim_callback->close (sim_callback, state->Reg[1]);
	  OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	  return TRUE;

	case 4:  /* Read.  */
	  SWIread (state, state->Reg[1], state->Reg[2], state->Reg[3]);
	  return TRUE;

	case 5:  /* Write.  */
	  SWIwrite (state, state->Reg[1], state->Reg[2], state->Reg[3]);
	  return TRUE;

	case 6:  /* Lseek.  */
	  state->Reg[0] = sim_callback->lseek (sim_callback,
					       state->Reg[1],
					       state->Reg[2],
					       state->Reg[3]);
	  OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	  return TRUE;

	case 17: /* Utime.  */
	  state->Reg[0] = (ARMword) sim_callback->time (sim_callback,
							(long *) state->Reg[1]);
	  OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	  return TRUE;

	case 7:  /* Unlink.  */
	case 8:  /* Getpid.  */
	case 9:  /* Kill.  */
	case 10: /* Fstat.  */
	case 11: /* Sbrk.  */
	case 12: /* Argvlen.  */
	case 13: /* Argv.  */
	case 14: /* ChDir.  */
	case 15: /* Stat.  */
	case 16: /* Chmod.  */
	case 18: /* Time.  */
	  sim_callback->printf_filtered
	    (sim_callback,
	     "sim: unhandled RedBoot syscall '%d' encountered - ignoring\n",
	     state->Reg[0]);
	  return FALSE;

	default:
	  sim_callback->printf_filtered
	    (sim_callback,
	     "sim: unknown RedBoot syscall '%d' encountered - ignoring\n",
	     state->Reg[0]);
	  return FALSE;
a758 1
      return TRUE;
d761 6
a766 5
      /* If there is a SWI vector installed use it.  */
      if (state->is_XScale && saved_number != -1)
	number = saved_number;
	    
      if (SWI_vector_installed && number != SWI_Breakpoint)
@


1.13.2.1
log
@merge from trunk
@
text
@d86 1
a86 1
#include "gdb/callback.h"
a127 4
/* Bit mask of enabled SWI implementations.  */
unsigned int swi_mask = -1;


d229 1
a229 5
  /* Intel do not want DEMON SWI support.  */
   if (state->is_XScale)
    swi_mask = SWI_MASK_ANGEL;

   return TRUE;
d400 3
d404 24
a427 2
  int              unhandled = FALSE;

d431 1
a431 4
      if (swi_mask & SWI_MASK_DEMON)
	SWIread (state, state->Reg[0], state->Reg[1], state->Reg[2]);
      else
	unhandled = TRUE;
d435 1
a435 4
      if (swi_mask & SWI_MASK_DEMON)
	SWIwrite (state, state->Reg[0], state->Reg[1], state->Reg[2]);
      else
	unhandled = TRUE;
d439 1
a439 4
      if (swi_mask & SWI_MASK_DEMON)
	SWIopen (state, state->Reg[0], state->Reg[1]);
      else
	unhandled = TRUE;
d443 2
a444 4
      if (swi_mask & SWI_MASK_DEMON)
	{
	  /* Return number of centi-seconds.  */
	  state->Reg[0] =
d446 3
a448 3
	    (CLOCKS_PER_SEC >= 100)
	    ? (ARMword) (clock () / (CLOCKS_PER_SEC / 100))
	    : (ARMword) ((clock () * 100) / CLOCKS_PER_SEC);
d450 2
a451 2
	  /* Presume unix... clock() returns microseconds.  */
	  (ARMword) (clock () / 10000);
d453 1
a453 4
	  OSptr->ErrorNo = errno;
	}
      else
	unhandled = TRUE;
d457 2
a458 7
      if (swi_mask & SWI_MASK_DEMON)
	{
	  state->Reg[0] = (ARMword) sim_callback->time (sim_callback, NULL);
	  OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	}
      else
	unhandled = TRUE;
d462 2
a463 7
      if (swi_mask & SWI_MASK_DEMON)
	{
	  state->Reg[0] = sim_callback->close (sim_callback, state->Reg[0]);
	  OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	}
      else
	unhandled = TRUE;
d467 1
a467 4
      if (swi_mask & SWI_MASK_DEMON)
	SWIflen (state, state->Reg[0]);
      else
	unhandled = TRUE;
d471 1
a471 4
      if (swi_mask & SWI_MASK_DEMON)
	state->Emulate = FALSE;
      else
	unhandled = TRUE;
d475 3
a477 8
      if (swi_mask & SWI_MASK_DEMON)
	{
	  /* We must return non-zero for failure.  */
	  state->Reg[0] = -1 >= sim_callback->lseek (sim_callback, state->Reg[0], state->Reg[1], SEEK_SET);
	  OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	}
      else
	unhandled = TRUE;
d481 5
a485 8
      if (swi_mask & SWI_MASK_DEMON)
	{
	  char tmp = state->Reg[0];
	  (void) sim_callback->write_stdout (sim_callback, &tmp, 1);
	  OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	}
      else
	unhandled = TRUE;
d489 1
a489 4
      if (swi_mask & SWI_MASK_DEMON)
	SWIWrite0 (state, state->Reg[0]);
      else
	unhandled = TRUE;
d493 1
a493 4
      if (swi_mask & SWI_MASK_DEMON)
	state->Reg[0] = OSptr->ErrorNo;
      else
	unhandled = TRUE;
d497 5
a501 7
      if (swi_mask & SWI_MASK_DEMON)
	{
	  state->Reg[0] = ADDRCMDLINE;
	  if (state->MemSize)
	    state->Reg[1] = state->MemSize;
	  else
	    state->Reg[1] = ADDRUSERSTACK;
d503 1
a503 4
	  WriteCommandLineTo (state, state->Reg[0]);
	}
      else
	unhandled = TRUE;
d514 4
a517 1
      if (swi_mask & SWI_MASK_ANGEL)
d519 11
a529 2
	  ARMword addr;
	  ARMword temp;
d531 3
a533 20
	  /* R1 is almost always a parameter block.  */
	  addr = state->Reg[1];
	  /* R0 is a reason code.  */
	  switch (state->Reg[0])
	    {
	      /* Unimplemented reason codes.  */
	    case AngelSWI_Reason_ReadC:
	    case AngelSWI_Reason_IsTTY:
	    case AngelSWI_Reason_TmpNam:
	    case AngelSWI_Reason_Remove:
	    case AngelSWI_Reason_Rename:
	    case AngelSWI_Reason_System:
	    case AngelSWI_Reason_EnterSVC:
	    default:
	      state->Emulate = FALSE;
	      return FALSE;

	    case AngelSWI_Reason_Clock:
	      /* Return number of centi-seconds.  */
	      state->Reg[0] =
d535 3
a537 3
		(CLOCKS_PER_SEC >= 100)
		? (ARMword) (clock () / (CLOCKS_PER_SEC / 100))
		: (ARMword) ((clock () * 100) / CLOCKS_PER_SEC);
d539 2
a540 2
	      /* Presume unix... clock() returns microseconds.  */
	      (ARMword) (clock () / 10000);
d542 83
a624 2
	      OSptr->ErrorNo = errno;
	      break;
d626 13
a638 95
	    case AngelSWI_Reason_Time:
	      state->Reg[0] = (ARMword) sim_callback->time (sim_callback, NULL);
	      OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	      break;

	    case AngelSWI_Reason_WriteC:
	      {
		char tmp = ARMul_SafeReadByte (state, addr);
		(void) sim_callback->write_stdout (sim_callback, &tmp, 1);
		OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
		break;
	      }

	    case AngelSWI_Reason_Write0:
	      SWIWrite0 (state, addr);
	      break;

	    case AngelSWI_Reason_Close:
	      state->Reg[0] = sim_callback->close (sim_callback, ARMul_ReadWord (state, addr));
	      OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	      break;

	    case AngelSWI_Reason_Seek:
	      state->Reg[0] = -1 >= sim_callback->lseek (sim_callback, ARMul_ReadWord (state, addr),
							 ARMul_ReadWord (state, addr + 4),
							 SEEK_SET);
	      OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	      break;

	    case AngelSWI_Reason_FLen:
	      SWIflen (state, ARMul_ReadWord (state, addr));
	      break;

	    case AngelSWI_Reason_GetCmdLine:
	      WriteCommandLineTo (state, ARMul_ReadWord (state, addr));
	      break;

	    case AngelSWI_Reason_HeapInfo:
	      /* R1 is a pointer to a pointer.  */
	      addr = ARMul_ReadWord (state, addr);

	      /* Pick up the right memory limit.  */
	      if (state->MemSize)
		temp = state->MemSize;
	      else
		temp = ADDRUSERSTACK;

	      ARMul_WriteWord (state, addr, 0);		/* Heap base.  */
	      ARMul_WriteWord (state, addr + 4, temp);	/* Heap limit.  */
	      ARMul_WriteWord (state, addr + 8, temp);	/* Stack base.  */
	      ARMul_WriteWord (state, addr + 12, temp);	/* Stack limit.  */
	      break;

	    case AngelSWI_Reason_ReportException:
	      if (state->Reg[1] == ADP_Stopped_ApplicationExit)
		state->Reg[0] = 0;
	      else
		state->Reg[0] = -1;
	      state->Emulate = FALSE;
	      break;

	    case ADP_Stopped_ApplicationExit:
	      state->Reg[0] = 0;
	      state->Emulate = FALSE;
	      break;

	    case ADP_Stopped_RunTimeError:
	      state->Reg[0] = -1;
	      state->Emulate = FALSE;
	      break;

	    case AngelSWI_Reason_Errno:
	      state->Reg[0] = OSptr->ErrorNo;
	      break;

	    case AngelSWI_Reason_Open:
	      SWIopen (state,
		       ARMul_ReadWord (state, addr),
		       ARMul_ReadWord (state, addr + 4));
	      break;

	    case AngelSWI_Reason_Read:
	      SWIread (state,
		       ARMul_ReadWord (state, addr),
		       ARMul_ReadWord (state, addr + 4),
		       ARMul_ReadWord (state, addr + 8));
	      break;

	    case AngelSWI_Reason_Write:
	      SWIwrite (state,
			ARMul_ReadWord (state, addr),
			ARMul_ReadWord (state, addr + 4),
			ARMul_ReadWord (state, addr + 8));
	      break;
	    }
a639 3
      else
	unhandled = TRUE;
      break;
d648 1
a648 1
      if (swi_mask & SWI_MASK_REDBOOT)
d650 61
a710 67
	  switch (state->Reg[0])
	    {
	      /* These numbers are defined in libgloss/syscall.h
		 but the simulator should not be dependend upon
		 libgloss being installed.  */
	    case 1:  /* Exit.  */
	      state->Emulate = FALSE;
	      /* Copy exit code into r0.  */
	      state->Reg[0] = state->Reg[1];
	      break;

	    case 2:  /* Open.  */
	      SWIopen (state, state->Reg[1], state->Reg[2]);
	      break;

	    case 3:  /* Close.  */
	      state->Reg[0] = sim_callback->close (sim_callback, state->Reg[1]);
	      OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	      break;

	    case 4:  /* Read.  */
	      SWIread (state, state->Reg[1], state->Reg[2], state->Reg[3]);
	      break;

	    case 5:  /* Write.  */
	      SWIwrite (state, state->Reg[1], state->Reg[2], state->Reg[3]);
	      break;

	    case 6:  /* Lseek.  */
	      state->Reg[0] = sim_callback->lseek (sim_callback,
						   state->Reg[1],
						   state->Reg[2],
						   state->Reg[3]);
	      OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	      break;

	    case 17: /* Utime.  */
	      state->Reg[0] = (ARMword) sim_callback->time (sim_callback,
							    (long *) state->Reg[1]);
	      OSptr->ErrorNo = sim_callback->get_errno (sim_callback);
	      break;

	    case 7:  /* Unlink.  */
	    case 8:  /* Getpid.  */
	    case 9:  /* Kill.  */
	    case 10: /* Fstat.  */
	    case 11: /* Sbrk.  */
	    case 12: /* Argvlen.  */
	    case 13: /* Argv.  */
	    case 14: /* ChDir.  */
	    case 15: /* Stat.  */
	    case 16: /* Chmod.  */
	    case 18: /* Time.  */
	      sim_callback->printf_filtered
		(sim_callback,
		 "sim: unhandled RedBoot syscall '%d' encountered - ignoring\n",
		 state->Reg[0]);
	      return FALSE;

	    default:
	      sim_callback->printf_filtered
		(sim_callback,
		 "sim: unknown RedBoot syscall '%d' encountered - ignoring\n",
		 state->Reg[0]);
	      return FALSE;
	    }
	  break;
d712 1
d715 5
a719 6
      unhandled = TRUE;
    }
      
  if (unhandled)
    {
      if (SWI_vector_installed)
@


1.12
log
@Support the RedBoot SWI in ARM mode and some of its system calls.
@
text
@d174 2
a175 1
    ARMul_WriteWord (state, i, instr);	/* Write hardware vectors.  */
d662 2
a663 2
	  state->Reg[0] = close (state->Reg[1]);
	  OSptr->ErrorNo = errno;
d675 5
a679 2
	  state->Reg[0] = lseek (state->Reg[1], state->Reg[2], state->Reg[3]);
	  OSptr->ErrorNo = errno;
d683 4
a686 3
	  state->Reg[0] = (ARMword) time (state->Reg[1]);
	  OSptr->ErrorNo = errno;
	  return (TRUE);
@


1.11
log
@	* armos.c (SWIWrite0): Use generic host_callback mechanism
	for supported OS functions "open", "close", "write", etc.
	(SWIopen): Likewise.
	(SWIread): Likewise.
	(SWIwrite): Likewise.
	(SWIflen): Likewise.
	(ARMul_OSHandleSWI): Likewise.
@
text
@d51 1
a51 1
#include <unistd.h>		/* For SEEK_SET etc */
d89 6
a94 7
extern unsigned ARMul_OSInit (ARMul_State * state);
extern void ARMul_OSExit (ARMul_State * state);
extern unsigned ARMul_OSHandleSWI (ARMul_State * state, ARMword number);
extern unsigned ARMul_OSException (ARMul_State * state, ARMword vector,
				   ARMword pc);
extern ARMword ARMul_OSLastErrorP (ARMul_State * state);
extern ARMword ARMul_Debug (ARMul_State * state, ARMword pc, ARMword instr);
d166 6
a171 6
  state->Reg[13] = ADDRSUPERSTACK;	/* set up a stack for the current mode */
  ARMul_SetReg (state, SVC32MODE, 13, ADDRSUPERSTACK);	/* and for supervisor mode */
  ARMul_SetReg (state, ABORT32MODE, 13, ADDRSUPERSTACK);	/* and for abort 32 mode */
  ARMul_SetReg (state, UNDEF32MODE, 13, ADDRSUPERSTACK);	/* and for undef 32 mode */
  ARMul_SetReg (state, SYSTEMMODE, 13, ADDRSUPERSTACK);	/* and for system mode */
  instr = 0xe59ff000 | (ADDRSOFTVECTORS - 8);	/* load pc from soft vector */
d174 1
a174 1
    ARMul_WriteWord (state, i, instr);	/* write hardware vectors */
d198 3
a200 2
  /* install fpe */
  for (i = 0; i < fpesize; i += 4)	/* copy the code */
d204 2
a205 1
    {				/* reverse the error strings */
d209 2
a210 1
	{			/* it's part of the string so swap it */
d218 4
a221 2
  ARMul_WriteWord (state, FPEOLDVECT, ARMul_ReadWord (state, 4));	/* copy old illegal instr vector */
  ARMul_WriteWord (state, 4, FPENEWVECT (ARMul_ReadWord (state, i - 4)));	/* install new vector */
d328 4
a331 2
      sim_callback->printf_filtered (sim_callback, "sim: Unable to read 0x%ulx bytes - out of memory\n",
	       len);
d355 4
a358 2
      sim_callback->printf_filtered (sim_callback, "sim: Unable to write 0x%lx bytes - out of memory\n",
	       (long) len);
d591 4
a594 4
	  ARMul_WriteWord (state, addr, 0);	/* Heap base */
	  ARMul_WriteWord (state, addr + 4, temp);	/* Heap limit */
	  ARMul_WriteWord (state, addr + 8, temp);	/* Stack base */
	  ARMul_WriteWord (state, addr + 12, temp);	/* Stack limit */
d646 63
d735 4
a738 1
	  sim_callback->printf_filtered (sim_callback, "sim: unknown SWI encountered - %x - ignoring\n", number);
@


1.10
log
@Add support for disabling alignment checks when performing GDB interface
calls or SWI emulaiton routines.  (Alignment checking code has not yet been
contributed).
@
text
@d86 3
d264 1
a264 1
    (void) fputc ((char) temp, stdout);
d266 1
a266 1
  OSptr->ErrorNo = errno;
d309 2
a310 2
      state->Reg[0] = (int) open (dummy, flags, 0666);
      OSptr->ErrorNo = errno;
d324 1
a324 1
      fprintf (stderr, "sim: Unable to read 0x%ulx bytes - out of memory\n",
d329 1
a329 1
  res = read (f, local, len);
d336 1
a336 1
  OSptr->ErrorNo = errno;
d349 1
a349 1
      fprintf (stderr, "sim: Unable to write 0x%lx bytes - out of memory\n",
d357 1
a357 1
  res = write (f, local, len);
d361 1
a361 1
  OSptr->ErrorNo = errno;
d377 1
a377 1
  addr = lseek (fh, 0, SEEK_CUR);
d379 2
a380 2
  state->Reg[0] = lseek (fh, 0L, SEEK_END);
  (void) lseek (fh, addr, SEEK_SET);
d382 1
a382 1
  OSptr->ErrorNo = errno;
d448 2
a449 2
      state->Reg[0] = (ARMword) time (NULL);
      OSptr->ErrorNo = errno;
d453 2
a454 2
      state->Reg[0] = close (state->Reg[0]);
      OSptr->ErrorNo = errno;
d467 2
a468 2
      state->Reg[0] = -1 >= lseek (state->Reg[0], state->Reg[1], SEEK_SET);
      OSptr->ErrorNo = errno;
d472 5
a476 2
      (void) fputc ((int) state->Reg[0], stdout);
      OSptr->ErrorNo = errno;
d537 2
a538 2
	  state->Reg[0] = (ARMword) time (NULL);
	  OSptr->ErrorNo = errno;
d542 5
a546 2
	  (void) fputc ((int) ARMul_SafeReadByte (state, addr), stdout);
	  OSptr->ErrorNo = errno;
d554 2
a555 2
	  state->Reg[0] = close (ARMul_ReadWord (state, addr));
	  OSptr->ErrorNo = errno;
d559 1
a559 1
	  state->Reg[0] = -1 >= lseek (ARMul_ReadWord (state, addr),
d562 1
a562 1
	  OSptr->ErrorNo = errno;
d664 1
a664 1
	  fprintf (stderr, "unknown SWI encountered - %x - ignoring\n", number);
@


1.9
log
@remove spurious whitespace
@
text
@a141 3
/* Set to prevent aborts when emulating SWI routines.  */
static int in_SWI_handler = 0;

d260 1
a260 1
  while ((temp = ARMul_ReadByte (state, addr++)) != 0)
d277 1
a277 1
      ARMul_WriteByte (state, addr++, temp);
d290 1
a290 1
  for (i = 0; (dummy[i] = ARMul_ReadByte (state, name + i)); i++)
d329 1
a329 1
      ARMul_WriteByte (state, ptr + i, local[i]);
d352 1
a352 1
    local[i] = ARMul_ReadByte (state, ptr + i);
a392 2
  in_SWI_handler = 1;

a513 1
	  in_SWI_handler = 0;
d536 1
a536 1
	  (void) fputc ((int) ARMul_ReadByte (state, addr), stdout);
a629 2
      in_SWI_handler = 0;

a659 1
  in_SWI_handler = 0;
d676 1
a676 5
  /* If we are inside a SWI handler routine, then ignore any exceptions.
     They could be caused by data exceptions for misaligned reads, for
     example, but for the purposes of emulating a SWI, we do not care.  */
   
  return in_SWI_handler;
@


1.8
log
@Prevent Aborts from happening whilst emulating a SWI
@
text
@a141 1

d544 1
d637 1
a637 1
      
d646 1
a646 1
	    
d649 1
a649 1
	    
d651 1
a651 1
	    
d655 1
a655 1
	    
@


1.7
log
@Detect installation of SWI vector by running program as well as loading program.
@
text
@d142 4
d392 4
a395 3
  ARMword addr, temp;
  struct OSblock *OSptr = (struct OSblock *) state->OSptr;
  ARMword saved_number = 0;
d397 2
d426 1
a426 1
      return TRUE;
d430 1
a430 1
      return TRUE;
d434 1
a434 1
      return TRUE;
d448 1
a448 1
      return TRUE;
d453 1
a453 1
      return TRUE;
d458 1
a458 1
      return TRUE;
d462 1
a462 1
      return TRUE;
d466 1
a466 1
      return TRUE;
d469 4
a472 6
      {
	/* We must return non-zero for failure.  */
	state->Reg[0] = -1 >= lseek (state->Reg[0], state->Reg[1], SEEK_SET);
	OSptr->ErrorNo = errno;
	return TRUE;
      }
d477 1
a477 1
      return TRUE;
d481 1
a481 1
      return TRUE;
d485 1
a485 1
      return TRUE;
d495 1
a495 1
      return TRUE;
d500 1
a500 1
      return TRUE;
d520 1
d535 1
a535 1
	  return TRUE;
d540 1
a540 1
	  return TRUE;
a544 1
	  return TRUE;
d548 1
a548 1
	  return TRUE;
d553 1
a553 1
	  return TRUE;
d560 1
a560 1
	  return TRUE;
d564 1
a564 1
	  return TRUE;
d568 1
a568 1
	  return TRUE;
d584 1
a584 1
	  return TRUE;
d592 1
a592 1
	  return TRUE;
d597 1
a597 1
	  return TRUE;
d602 1
a602 1
	  return TRUE;
d606 1
a606 1
	  return TRUE;
d612 1
a612 1
	  return TRUE;
d619 1
a619 1
	  return TRUE;
d626 1
a626 1
	  return TRUE;
d633 1
a633 1
      return TRUE;
d636 5
a640 4
      {
	/* If there is a SWI vector installed use it.  */
	if (state->is_XScale && saved_number != -1)
	  number = saved_number;
d642 4
a645 4
	if (SWI_vector_installed && number != SWI_Breakpoint)
	  {
	    ARMword cpsr;
	    ARMword i_size;
d647 2
a648 2
	    cpsr = ARMul_GetCPSR (state);
	    i_size = INSN_SIZE;
d650 1
a650 1
	    ARMul_SetSPSR (state, SVC32MODE, cpsr);
d652 3
a654 3
	    cpsr &= ~0xbf;
	    cpsr |= SVC32MODE | 0x80;
	    ARMul_SetCPSR (state, cpsr);
d656 7
a662 6
	    state->RegBank[SVCBANK][14] = state->Reg[14] = state->Reg[15] - i_size;
	    state->NextInstr            = RESUME;
	    state->Reg[15]              = state->pc = ARMSWIV;
	    FLUSHPIPE;
	  }
	else
d664 2
a665 2
	return TRUE;
      }
d667 3
d685 5
a689 1
  return FALSE;
@


1.6
log
@Add 0x91 as an FPE SWI.
@
text
@d174 2
a632 2
	extern int SWI_vector_installed;

@


1.5
log
@Suppress support of DEMON swi's in XScale mode.
@
text
@d623 1
@


1.4
log
@Add support for ARM's v5TE architecture and Intel's XScale extenstions
@
text
@d19 5
a23 5
including all the SWI's required to support the C library. The code in
it is not really for the faint-hearted (especially the abort handling
code), but it is a complete example. Defining NOOS will disable all the
fun, and definign VAILDATE will define SWI 1 to enter SVC mode, and SWI
0x11 to halt the emulator. */
d100 1
a100 3
/***************************************************************************\
*                          OS private Information                           *
\***************************************************************************/
d127 13
a139 12
{	/* basic: swi tidyexception + event; mov pc, lr;
	   ldmia r11,{r11,pc}; swi generateexception  + event.  */
  0xef000090, 0xe1a0e00f, 0xe89b8800, 0xef000080,	/*Reset */
  0xef000091, 0xe1a0e00f, 0xe89b8800, 0xef000081,	/*Undef */
  0xef000092, 0xe1a0e00f, 0xe89b8800, 0xef000082,	/*SWI  */
  0xef000093, 0xe1a0e00f, 0xe89b8800, 0xef000083,	/*Prefetch abort */
  0xef000094, 0xe1a0e00f, 0xe89b8800, 0xef000084,	/*Data abort */
  0xef000095, 0xe1a0e00f, 0xe89b8800, 0xef000085,	/*Address exception */
  0xef000096, 0xe1a0e00f, 0xe89b8800, 0xef000086, /*IRQ*/
  0xef000097, 0xe1a0e00f, 0xe89b8800, 0xef000087, /*FIQ*/
  0xef000098, 0xe1a0e00f, 0xe89b8800, 0xef000088,	/*Error */
  0xe1a0f00e			/* default handler */
d142 1
a142 3
/***************************************************************************\
*            Time for the Operating System to initialise itself.            *
\***************************************************************************/
d161 1
d170 1
d173 1
d180 1
d183 1
d186 1
d189 1
d197 1
d210 1
d219 1
a219 1
  return (TRUE);
d229 1
a229 3
/***************************************************************************\
*                  Return the last Operating System Error.                  *
\***************************************************************************/
d236 2
a237 1
static int translate_open_mode[] = {
d269 1
d291 1
a291 1
  /* Now we need to decode the Demon open mode */
d294 1
a294 1
  /* Filename ":tt" is special: it denotes stdin/out */
d328 1
d355 1
d380 2
a381 4
/***************************************************************************\
* The emulator calls this routine when a SWI instruction is encuntered. The *
* parameter passed is the SWI number (lower 24 bits of the instruction).    *
\***************************************************************************/
d388 25
a412 1

d428 1
a428 1
      /* return number of centi-seconds... */
d435 1
a435 1
	/* presume unix... clock() returns microseconds */
d439 1
a439 1
      return (TRUE);
d444 1
a444 1
      return (TRUE);
d453 1
a453 1
      return (TRUE);
d461 1
a461 1
	/* We must return non-zero for failure */
d470 1
a470 1
      return (TRUE);
d474 1
a474 1
      return (TRUE);
d478 1
a478 1
      return (TRUE);
d488 2
a489 2
      return (TRUE);
      
d493 1
a493 1
      return (TRUE);
d495 1
a495 1
      /* Handle Angel SWIs as well as Demon ones */
d498 1
a498 1
      /* R1 is almost always a parameter block */
d500 1
a500 1
      /* R0 is a reason code */
d503 1
a503 1
	  /* Unimplemented reason codes */
d513 1
a513 1
	  return (FALSE);
d516 1
a516 1
	  /* return number of centi-seconds... */
d523 1
a523 1
	    /* presume unix... clock() returns microseconds */
d527 1
a527 1
	  return (TRUE);
d532 1
a532 1
	  return (TRUE);
d537 1
a537 1
	  return (TRUE);
d541 1
a541 1
	  return (TRUE);
d546 1
a546 1
	  return (TRUE);
d553 1
a553 1
	  return (TRUE);
d557 1
a557 1
	  return (TRUE);
d561 1
a561 1
	  return (TRUE);
d564 1
a564 1
	  /* R1 is a pointer to a pointer */
d567 1
a567 1
	  /* Pick up the right memory limit */
d577 1
a577 1
	  return (TRUE);
d590 1
a590 1
	  return (TRUE);
d595 1
a595 1
	  return (TRUE);
d599 1
a599 1
	  return (TRUE);
d631 4
a634 1
	
d670 1
a670 2
ARMul_OSException (
		   ARMul_State * state  ATTRIBUTE_UNUSED,
@


1.3
log
@Add support for v4 SystemMode.
@
text
@d73 2
a449 5
    case SWI_Breakpoint:
      state->EndCondition = RDIError_BreakpointReached;
      state->Emulate = FALSE;
      return (TRUE);

d459 5
d592 5
d598 27
a624 2
      state->Emulate = FALSE;
      return (FALSE);
d631 4
a634 6
/***************************************************************************\
* The emulator calls this routine when an Exception occurs.  The second     *
* parameter is the address of the relevant exception vector.  Returning     *
* FALSE from this routine causes the trap to be taken, TRUE causes it to    *
* be ignored (so set state->Emulate to FALSE!).                             *
\***************************************************************************/
d637 6
a642 3
ARMul_OSException (ARMul_State * state ATTRIBUTE_UNUSED, ARMword vector ATTRIBUTE_UNUSED, ARMword pc ATTRIBUTE_UNUSED)
{				/* don't use this here */
  return (FALSE);
a645 2


@


1.2
log
@Fix compile time warning messages.
@
text
@d168 1
@


1.1
log
@Initial revision
@
text
@d26 1
d51 1
a51 1
#include <unistd.h>	/* For SEEK_SET etc */
d55 1
a55 1
extern int _fisatty(FILE *);
d84 7
a90 6
extern unsigned ARMul_OSInit(ARMul_State *state) ;
extern void ARMul_OSExit(ARMul_State *state) ;
extern unsigned ARMul_OSHandleSWI(ARMul_State *state,ARMword number) ;
extern unsigned ARMul_OSException(ARMul_State *state, ARMword vector, ARMword pc) ;
extern ARMword ARMul_OSLastErrorP(ARMul_State *state) ;
extern ARMword ARMul_Debug(ARMul_State *state, ARMword pc, ARMword instr) ;
a97 5
#ifndef NOOS
static void UnwindDataAbort(ARMul_State *state, ARMword addr);
static void getstring(ARMul_State *state, ARMword from, char *to) ;
#endif

d102 9
a110 8
struct OSblock {
   ARMword Time0 ;
   ARMword ErrorP ;
   ARMword ErrorNo ;
   FILE *FileTable[FOPEN_MAX] ;
   char FileFlags[FOPEN_MAX] ;
   char *tempnames[UNIQUETEMPS] ;
   } ;
d122 2
a123 2
#else                   
#define FIXCRLF(t,c) c 
d127 8
a134 9
{   /* basic: swi tidyexception + event; mov pc, lr;
              ldmia r11,{r11,pc}; swi generateexception + event
     */
  0xef000090, 0xe1a0e00f, 0xe89b8800, 0xef000080, /*Reset*/
  0xef000091, 0xe1a0e00f, 0xe89b8800, 0xef000081, /*Undef*/
  0xef000092, 0xe1a0e00f, 0xe89b8800, 0xef000082, /*SWI  */
  0xef000093, 0xe1a0e00f, 0xe89b8800, 0xef000083, /*Prefetch abort*/
  0xef000094, 0xe1a0e00f, 0xe89b8800, 0xef000084, /*Data abort*/
  0xef000095, 0xe1a0e00f, 0xe89b8800, 0xef000085, /*Address exception*/
d137 2
a138 2
  0xef000098, 0xe1a0e00f, 0xe89b8800, 0xef000088, /*Error*/
  0xe1a0f00e /* default handler */
d145 2
a146 2
unsigned 
ARMul_OSInit (ARMul_State *state)
d150 2
a151 2
 ARMword instr, i , j ;
 struct OSblock* OSptr = (struct OSblock*)state->OSptr;
d153 8
a160 6
 if (state->OSptr == NULL) {
    state->OSptr = (unsigned char *)malloc(sizeof(struct OSblock));
    if (state->OSptr == NULL) {
       perror("OS Memory");
       exit(15);
       }
d162 22
a183 20
 OSptr = (struct OSblock*)state->OSptr;
 OSptr->ErrorP = 0;
 state->Reg[13] = ADDRSUPERSTACK;  /* set up a stack for the current mode */
 ARMul_SetReg(state,SVC32MODE,13,ADDRSUPERSTACK); /* and for supervisor mode */
 ARMul_SetReg(state,ABORT32MODE,13,ADDRSUPERSTACK); /* and for abort 32 mode */
 ARMul_SetReg(state,UNDEF32MODE,13,ADDRSUPERSTACK); /* and for undef 32 mode */
 instr = 0xe59ff000 | (ADDRSOFTVECTORS - 8); /* load pc from soft vector */
 for (i = ARMul_ResetV ; i <= ARMFIQV ; i += 4)
    ARMul_WriteWord(state, i, instr);    /* write hardware vectors */
 for (i = ARMul_ResetV ; i <= ARMFIQV + 4 ; i += 4) {
    ARMul_WriteWord(state, ADDRSOFTVECTORS + i, SOFTVECTORCODE + i * 4);
    ARMul_WriteWord(state, ADDRSOFHANDLERS + 2*i + 4L, SOFTVECTORCODE + sizeof(softvectorcode) - 4L);
    }
 for (i = 0 ; i < sizeof(softvectorcode) ; i += 4)
    ARMul_WriteWord(state, SOFTVECTORCODE + i, softvectorcode[i/4]);
 for (i = 0 ; i < FOPEN_MAX ; i++)
    OSptr->FileTable[i] = NULL ;
 for (i = 0 ; i < UNIQUETEMPS ; i++)
    OSptr->tempnames[i] = NULL ;
 ARMul_ConsolePrint (state, ", Demon 1.01");
d187 14
a200 13
 /* install fpe */
 for (i = 0 ; i < fpesize ; i+=4) /* copy the code */
    ARMul_WriteWord(state,FPESTART + i,fpecode[i >> 2]) ;
 for (i = FPESTART + fpesize ; ; i-=4) { /* reverse the error strings */
    if ((j = ARMul_ReadWord(state,i)) == 0xffffffff)
       break ;
    if (state->bigendSig && j < 0x80000000) { /* it's part of the string so swap it */
       j = ((j >> 0x18) & 0x000000ff) |
           ((j >> 0x08) & 0x0000ff00) |
           ((j << 0x08) & 0x00ff0000) |
           ((j << 0x18) & 0xff000000) ;
       ARMul_WriteWord(state,i,j) ;
       }
d202 3
a204 3
 ARMul_WriteWord(state,FPEOLDVECT,ARMul_ReadWord(state,4)) ; /* copy old illegal instr vector */
 ARMul_WriteWord(state,4,FPENEWVECT(ARMul_ReadWord(state,i-4))) ; /* install new vector */
 ARMul_ConsolePrint (state, ", FPE") ;
d206 1
a206 1
/* #endif /* ASIM */
d210 1
a210 1
 return(TRUE) ;
d213 2
a214 2
void 
ARMul_OSExit (ARMul_State *state)
d216 1
a216 1
 free((char *)state->OSptr);
d224 1
a224 2
ARMword 
ARMul_OSLastErrorP (ARMul_State *state)
d226 1
a226 1
  return ((struct OSblock *)state->OSptr)->ErrorP;
d229 13
a241 17
#if 1  /* CYGNUS LOCAL */
/* This is the cygnus way of doing it, which makes it simple to do our tests */

static int translate_open_mode[] =
{
  O_RDONLY,                          /* "r"   */
  O_RDONLY+O_BINARY,                 /* "rb"  */
  O_RDWR,                            /* "r+"  */
  O_RDWR  +O_BINARY,                 /* "r+b" */
  O_WRONLY         +O_CREAT+O_TRUNC, /* "w"   */
  O_WRONLY+O_BINARY+O_CREAT+O_TRUNC, /* "wb"  */
  O_RDWR           +O_CREAT+O_TRUNC, /* "w+"  */
  O_RDWR  +O_BINARY+O_CREAT+O_TRUNC, /* "w+b" */
  O_WRONLY         +O_APPEND+O_CREAT,/* "a"   */
  O_WRONLY+O_BINARY+O_APPEND+O_CREAT,/* "ab"  */
  O_RDWR           +O_APPEND+O_CREAT,/* "a+"  */
  O_RDWR  +O_BINARY+O_APPEND+O_CREAT /* "a+b" */
d244 2
a245 2
static void 
SWIWrite0 (ARMul_State *state, ARMword addr)
d248 1
a248 1
  struct OSblock* OSptr = (struct OSblock*) state->OSptr;
d251 1
a251 1
    (void) fputc ((char) temp, stderr);
d256 2
a257 2
static void 
WriteCommandLineTo (ARMul_State *state, ARMword addr)
d263 6
a268 4
  do {
    temp = (ARMword) *cptr++;
    ARMul_WriteByte (state, addr++, temp);
  } while (temp != 0);
d271 2
a272 2
static void 
SWIopen (ARMul_State *state, ARMword name, ARMword SWIflags)
d274 1
a274 1
  struct OSblock* OSptr = (struct OSblock*)state->OSptr;
d279 1
a279 3
  for (i = 0; 
       dummy[i] = ARMul_ReadByte (state, name + i);
       i++)
d288 4
a291 4
      if (flags == O_RDONLY) /* opening tty "r" */
	state->Reg[0] = 0;  /* stdin */
      else 
	state->Reg[0] = 1; /* stdout */
d295 1
a295 1
      state->Reg[0] = (int) open (dummy, flags);
d300 2
a301 2
static void 
SWIread (ARMul_State *state, ARMword f, ARMword ptr, ARMword len)
d303 1
a303 1
  struct OSblock* OSptr = (struct OSblock*) state->OSptr;
d308 7
d317 1
a317 1
    for (i = 0; i < res; i++) 
d324 2
a325 2
static void 
SWIwrite (ARMul_State *state, ARMword f, ARMword ptr, ARMword len)
d327 1
a327 1
  struct OSblock* OSptr = (struct OSblock*) state->OSptr;
d329 1
a329 1
  int i;
d332 1
a332 1
  for (i = 0; i < len; i++) 
d334 3
a336 1
      local[i] = ARMul_ReadByte (state, ptr + i);
d338 4
d348 2
a349 2
static void 
SWIflen (ARMul_State *state, ARMword fh)
d351 1
a351 1
  struct OSblock* OSptr = (struct OSblock*) state->OSptr;
d362 3
a364 7
  if (addr < 0)
    state->Reg[0] = -1L;
  else
    {
      state->Reg[0] = lseek (fh, 0L, SEEK_END);
      (void) lseek (fh, addr, SEEK_SET);
    }
d374 2
a375 2
unsigned 
ARMul_OSHandleSWI (ARMul_State *state, ARMword number)
d377 2
a378 4
  ARMword addr, temp, fildes;
  char buffer[BUFFERSIZE], *cptr;
  FILE *fptr;
  struct OSblock* OSptr = (struct OSblock*)state->OSptr;
d383 2
a384 2
	SWIread (state, state->Reg[0], state->Reg[1], state->Reg[2]);
	return TRUE; 
d387 2
a388 2
	SWIwrite (state, state->Reg[0], state->Reg[1], state->Reg[2]);
	return TRUE;     
d391 2
a392 2
	SWIopen (state, state->Reg[0],state->Reg[1]);
	return TRUE;
d394 3
a396 3
    case SWI_Clock :
       /* return number of centi-seconds... */
       state->Reg[0] =
d398 3
a400 3
          (CLOCKS_PER_SEC >= 100)
             ? (ARMword) (clock() / (CLOCKS_PER_SEC / 100))
             : (ARMword) ((clock() * 100) / CLOCKS_PER_SEC) ;
d402 2
a403 2
     /* presume unix... clock() returns microseconds */
          (ARMword) (clock() / 10000) ;
d405 7
a411 2
       OSptr->ErrorNo = errno ;
       return(TRUE) ;
a412 5
    case SWI_Time :
       state->Reg[0] = (ARMword)time(NULL) ;
       OSptr->ErrorNo = errno ;
       return(TRUE) ;
   
d418 1
a418 1
    case SWI_Flen :
d420 1
a420 1
      return(TRUE) ;
d423 1
a423 1
      state->Emulate = FALSE ;
d429 1
a429 3
	state->Reg[0] = -1 >= lseek (state->Reg[0],
				    state->Reg[1],
				    SEEK_SET);
d434 4
a437 4
    case SWI_WriteC :
      (void)fputc((int)state->Reg[0],stderr) ;
      OSptr->ErrorNo = errno ;
      return(TRUE) ;
d439 1
a439 1
    case SWI_Write0 :
d441 1
a441 1
      return(TRUE) ;
d443 15
a457 15
    case SWI_GetErrno :
      state->Reg[0] = OSptr->ErrorNo ;
      return(TRUE) ;

    case SWI_Breakpoint :
      state->EndCondition = RDIError_BreakpointReached ;
      state->Emulate = FALSE ;
      return(TRUE) ;

    case SWI_GetEnv :
       state->Reg[0] = ADDRCMDLINE ;
       if (state->MemSize)
          state->Reg[1] = state->MemSize ;
       else
          state->Reg[1] = ADDRUSERSTACK ;
d459 2
a460 2
       WriteCommandLineTo (state, state->Reg[0]);
       return(TRUE) ;
d462 1
a462 1
       /* Handle Angel SWIs as well as Demon ones */
d480 1
a480 1
	  return(FALSE);
d483 1
a483 1
       /* return number of centi-seconds... */
d487 2
a488 2
	    ? (ARMword) (clock() / (CLOCKS_PER_SEC / 100))
	    : (ARMword) ((clock() * 100) / CLOCKS_PER_SEC) ;
d490 2
a491 2
	  /* presume unix... clock() returns microseconds */
          (ARMword) (clock() / 10000) ;
d502 1
a502 1
	  (void) fputc ((int) ARMul_ReadByte (state,addr), stderr);
d516 2
a517 2
	  state->Reg[0] = -1 >= lseek (ARMul_ReadWord(state,addr),
				       ARMul_ReadWord(state,addr+4),
d526 1
a526 1
     	case AngelSWI_Reason_GetCmdLine:
d540 4
a543 4
	  ARMul_WriteWord (state, addr, 0);       /* Heap base */
	  ARMul_WriteWord (state, addr+4, temp);    /* Heap limit */
	  ARMul_WriteWord (state, addr+8, temp);    /* Stack base */
	  ARMul_WriteWord (state, addr+12, temp);   /* Stack limit */
d551 2
a552 2
	  state->Emulate = FALSE ;      
	  return (TRUE);
d556 1
a556 1
	  state->Emulate = FALSE ;      
d558 1
a558 1
	  
d561 1
a561 1
	  state->Emulate = FALSE ;      
d569 3
a571 3
	  SWIopen(state,
		  ARMul_ReadWord(state, addr),
		  ARMul_ReadWord(state, addr+4));
d575 4
a578 4
	  SWIread(state,
		  ARMul_ReadWord(state, addr),
		  ARMul_ReadWord(state, addr+4),
		  ARMul_ReadWord(state, addr+8));
d582 4
a585 4
	  SWIwrite(state,
		  ARMul_ReadWord(state, addr),
		  ARMul_ReadWord(state, addr+4),
		  ARMul_ReadWord(state, addr+8));
d589 3
a591 3
    default :
      state->Emulate = FALSE ;      
      return(FALSE) ;
a594 480
#else  /* CYGNUS LOCAL: #if 1 */

unsigned 
ARMul_OSHandleSWI (ARMul_State *state, ARMword number)
{
#ifdef NOOS
 return(FALSE) ;
#else
#ifdef VALIDATE
 switch (number) {
    case 0x11 :
       state->Emulate = FALSE ;
       return(TRUE) ;
    case 0x01 :
       if (ARM32BITMODE)
          ARMul_SetCPSR(state, (ARMul_GetCPSR(state) & 0xffffffc0) | 0x13) ;
       else
          ARMul_SetCPSR(state, (ARMul_GetCPSR(state) & 0xffffffc0) | 0x3) ;
       return(TRUE) ;
    default :
       return(FALSE) ;
    }
#else
 ARMword addr, temp ;
 char buffer[BUFFERSIZE], *cptr ;
 FILE *fptr ;
 struct OSblock* OSptr = (struct OSblock*)state->OSptr ;

 switch (number) {
    case SWI_WriteC :
       (void)fputc((int)state->Reg[0],stderr) ;
       OSptr->ErrorNo = errno ;
       return(TRUE) ;

    case SWI_Write0 :
       addr = state->Reg[0] ;
       while ((temp = ARMul_ReadByte(state,addr++)) != 0)
          fputc((char)temp,stderr) ;
       OSptr->ErrorNo = errno ;
       return(TRUE) ;

    case SWI_ReadC :
       state->Reg[0] = (ARMword)fgetc(stdin) ;
       OSptr->ErrorNo = errno ;
       return(TRUE) ;

    case SWI_CLI :
       addr = state->Reg[0] ;
       getstring(state,state->Reg[0],buffer) ;
       state->Reg[0] = (ARMword)system(buffer) ;
       OSptr->ErrorNo = errno ;
       return(TRUE) ;

    case SWI_GetEnv :
       state->Reg[0] = ADDRCMDLINE ;
       if (state->MemSize)
          state->Reg[1] = state->MemSize ;
       else
          state->Reg[1] = ADDRUSERSTACK ;

       addr = state->Reg[0] ;
       cptr = state->CommandLine ;
       if (cptr == NULL)
          cptr = "\0" ;
       do {
          temp = (ARMword)*cptr++ ;
          ARMul_WriteByte(state,addr++,temp) ;
          } while (temp != 0) ;
       return(TRUE) ;

    case SWI_Exit :
#ifdef ASIM
       simkernel1_abort_run() ;
#else
       state->Emulate = FALSE ;
#endif
       return(TRUE) ;

    case SWI_EnterOS :
       if (ARM32BITMODE)
          ARMul_SetCPSR(state, (ARMul_GetCPSR(state) & 0xffffffc0) | 0x13) ;
       else
          ARMul_SetCPSR(state, (ARMul_GetCPSR(state) & 0xffffffc0) | 0x3) ;
       return(TRUE) ;

    case SWI_GetErrno :
       state->Reg[0] = OSptr->ErrorNo ;
       return(TRUE) ;

    case SWI_Clock :
       /* return muber of centi-seconds... */
       state->Reg[0] =
#ifdef CLOCKS_PER_SEC
          (CLOCKS_PER_SEC >= 100)
             ? (ARMword) (clock() / (CLOCKS_PER_SEC / 100))
             : (ARMword) ((clock() * 100) / CLOCKS_PER_SEC) ;
#else
     /* presume unix... clock() returns microseconds */
          (ARMword) (clock() / 10000) ;
#endif
       OSptr->ErrorNo = errno ;
       return(TRUE) ;

    case SWI_Time :
       state->Reg[0] = (ARMword)time(NULL) ;
       OSptr->ErrorNo = errno ;
       return(TRUE) ;

    case SWI_Remove :
       getstring(state,state->Reg[0],buffer) ;
       state->Reg[0] = unlink(buffer) ;
       OSptr->ErrorNo = errno ;
       return(TRUE) ;

    case SWI_Rename : {
       char buffer2[BUFFERSIZE] ;

       getstring(state,state->Reg[0],buffer) ;
       getstring(state,state->Reg[1],buffer2) ;
       state->Reg[0] = rename(buffer,buffer2) ;
       OSptr->ErrorNo = errno ;
       return(TRUE) ;
       }

    case SWI_Open : {
#if 0
      /* It seems to me that these are in the wrong order
	 sac@@cygnus.com, so I've redone it to use the
	 flags instead, with the functionality which was already
	 there -- ahh, perhaps the TRUNC bit is in a different
	 place on the original host ?*/
       static char* fmode[] = {"r","rb","r+","r+b",
                               "w","wb","w+","w+b",
                               "a","ab","a+","a+b",
                               "r","r","r","r"} /* last 4 are illegal */ ;
#endif

       unsigned type ;

       type = (unsigned)(state->Reg[1] & 3L) ;
       getstring(state,state->Reg[0],buffer) ;
       if (strcmp(buffer,":tt")==0 && (type == O_RDONLY )) /* opening tty "r" */
          fptr = stdin ;
       else if (strcmp(buffer,":tt")==0 && (type == O_WRONLY)) /* opening tty "w" */
          fptr = stderr ;
       else
	 {
	   switch (type) 
	     {
	     case O_RDONLY:
	       fptr = fopen(buffer,"r") ;
	       break;
	     case O_WRONLY:
	       fptr = fopen(buffer,"w") ;
	       break;
	     case O_RDWR:
	       fptr = fopen(buffer,"rw") ;
	       break;
	     }
	 }

       state->Reg[0] = 0 ;
       if (fptr != NULL) {
          for (temp = 0 ; temp < FOPEN_MAX ; temp++)
             if (OSptr->FileTable[temp] == NULL) {
                OSptr->FileTable[temp] = fptr ;
                OSptr->FileFlags[temp] = type & 1 ; /* preserve the binary bit */
                state->Reg[0] = (ARMword)(temp + 1) ;
                break ;
                }
          if (state->Reg[0] == 0)
             OSptr->ErrorNo = EMFILE ; /* too many open files */
          else
             OSptr->ErrorNo = errno ;
          }
       else
         OSptr->ErrorNo = errno ;
       return(TRUE) ;
       }

    case SWI_Close :
       temp = state->Reg[0] ;
       if (temp == 0 || temp > FOPEN_MAX || OSptr->FileTable[temp - 1] == 0) {
          OSptr->ErrorNo = EBADF ;
          state->Reg[0] = -1L ;
          return(TRUE) ;
          }
       temp-- ;
       fptr = OSptr->FileTable[temp] ;
       if (fptr == stdin || fptr == stderr)
          state->Reg[0] = 0 ;
       else
          state->Reg[0] = fclose(fptr) ;
       OSptr->FileTable[temp] = NULL ;
       OSptr->ErrorNo = errno ;
       return(TRUE) ;

    case SWI_Write : {
       unsigned size, upto, type ;
       char ch ;

       temp = state->Reg[0] ;
       if (temp == 0 || temp > FOPEN_MAX || OSptr->FileTable[temp - 1] == 0) {
          OSptr->ErrorNo = EBADF ;
          state->Reg[0] = -1L ;
          return(TRUE) ;
          }
       temp-- ;
       fptr = OSptr->FileTable[temp] ;
       type = OSptr->FileFlags[temp] ;
       addr = state->Reg[1] ;
       size = (unsigned)state->Reg[2] ;

       if (type & READOP)
          fseek(fptr,0L,SEEK_CUR) ;
       OSptr->FileFlags[temp] = (type & BINARY) | WRITEOP ; ;
       while (size > 0) {
          if (size >= BUFFERSIZE)
             upto = BUFFERSIZE ;
          else
             upto = size ;
          for (cptr = buffer ; (cptr - buffer) < upto ; cptr++) {
             ch = (char)ARMul_ReadByte(state,(ARMword)addr++) ;
             *cptr = FIXCRLF(type,ch) ;
             }
          temp = fwrite(buffer,1,upto,fptr) ;
          if (temp < upto) {
             state->Reg[0] = (ARMword)(size - temp) ;
             OSptr->ErrorNo = errno ;
             return(TRUE) ;
             }
          size -= upto ;
          }
       state->Reg[0] = 0 ;
       OSptr->ErrorNo = errno ;
       return(TRUE) ;
       }

    case SWI_Read : {
       unsigned size, upto, type ;
       char ch ;

       temp = state->Reg[0] ;
       if (temp == 0 || temp > FOPEN_MAX || OSptr->FileTable[temp - 1] == 0) {
          OSptr->ErrorNo = EBADF ;
          state->Reg[0] = -1L ;
          return(TRUE) ;
          }
       temp-- ;
       fptr = OSptr->FileTable[temp] ;
       addr = state->Reg[1] ;
       size = (unsigned)state->Reg[2] ;
       type = OSptr->FileFlags[temp] ;

       if (type & WRITEOP)
          fseek(fptr,0L,SEEK_CUR) ;
       OSptr->FileFlags[temp] = (type & BINARY) | READOP ; ;
       while (size > 0) {
          if (isatty_(fptr)) {
             upto = (size >= BUFFERSIZE)?BUFFERSIZE:size + 1 ;
             if (fgets(buffer, upto, fptr) != 0)
               temp = strlen(buffer) ;
             else
               temp = 0 ;
             upto-- ; /* 1 char used for terminating null */
             }
          else {
             upto = (size>=BUFFERSIZE)?BUFFERSIZE:size ;
             temp = fread(buffer,1,upto,fptr) ;
             }
          for (cptr = buffer ; (cptr - buffer) < temp ; cptr++) {
             ch = *cptr ;
             ARMul_WriteByte(state,(ARMword)addr++,FIXCRLF(type,ch)) ;
             }
          if (temp < upto) {
             state->Reg[0] = (ARMword)(size - temp) ;
             OSptr->ErrorNo = errno ;
             return(TRUE) ;
             }
          size -= upto ;
          }
       state->Reg[0] = 0 ;
       OSptr->ErrorNo = errno ;
       return(TRUE) ;
       }

    case SWI_Seek :
       if (state->Reg[0] == 0 || state->Reg[0] > FOPEN_MAX
           || OSptr->FileTable[state->Reg[0] - 1] == 0) {
          OSptr->ErrorNo = EBADF ;
          state->Reg[0] = -1L ;
          return(TRUE) ;
          }
       fptr = OSptr->FileTable[state->Reg[0] - 1] ;
       state->Reg[0] = fseek(fptr,(long)state->Reg[1],SEEK_SET) ;
       OSptr->ErrorNo = errno ;
       return(TRUE) ;

    case SWI_Flen :
       if (state->Reg[0] == 0 || state->Reg[0] > FOPEN_MAX
           || OSptr->FileTable[state->Reg[0] - 1] == 0) {
          OSptr->ErrorNo = EBADF ;
          state->Reg[0] = -1L ;
          return(TRUE) ;
          }
       fptr = OSptr->FileTable[state->Reg[0] - 1] ;
       addr = (ARMword)ftell(fptr) ;
       if (fseek(fptr,0L,SEEK_END) < 0)
          state->Reg[0] = -1 ;
       else {
          state->Reg[0] = (ARMword)ftell(fptr) ;
          (void)fseek(fptr,addr,SEEK_SET) ;
          }
       OSptr->ErrorNo = errno ;
       return(TRUE) ;

    case SWI_IsTTY :
       if (state->Reg[0] == 0 || state->Reg[0] > FOPEN_MAX
           || OSptr->FileTable[state->Reg[0] - 1] == 0) {
          OSptr->ErrorNo = EBADF ;
          state->Reg[0] = -1L ;
          return(TRUE) ;
          }
       fptr = OSptr->FileTable[state->Reg[0] - 1] ;
       state->Reg[0] = isatty_(fptr) ;
       OSptr->ErrorNo = errno ;
       return(TRUE) ;

    case SWI_TmpNam :{
       ARMword size ;

       addr = state->Reg[0] ;
       temp = state->Reg[1] & 0xff ;
       size = state->Reg[2] ;
       if (OSptr->tempnames[temp] == NULL) {
          if ((OSptr->tempnames[temp] = malloc(L_tmpnam)) == NULL) {
             state->Reg[0] = 0 ;
             return(TRUE) ;
             }
          (void)tmpnam(OSptr->tempnames[temp]) ;
          }
       cptr = OSptr->tempnames[temp] ;
       if (strlen(cptr) > state->Reg[2])
          state->Reg[0] = 0 ;
       else
          do {
             ARMul_WriteByte(state,addr++,*cptr) ;
             } while (*cptr++ != 0) ;
       OSptr->ErrorNo = errno ;
       return(TRUE) ;
       }

    case SWI_InstallHandler:
       {  ARMword handlerp = ADDRSOFHANDLERS + state->Reg[0] * 8;
          ARMword oldr1 = ARMul_ReadWord(state, handlerp),
                  oldr2 = ARMul_ReadWord(state, handlerp + 4);
          ARMul_WriteWord(state, handlerp, state->Reg[1]);
          ARMul_WriteWord(state, handlerp + 4, state->Reg[2]);
          state->Reg[1] = oldr1;
          state->Reg[2] = oldr2;
          return(TRUE);
       }

    case SWI_GenerateError:
       ARMul_Abort(state, ARMSWIV) ;
       if (state->Emulate)
          ARMul_SetR15(state, ARMul_ReadWord(state, ADDRSOFTVECTORS + ARMErrorV));
       return(TRUE);

/* SWI's 0x9x unwind the state of the CPU after an abort of type x */

    case 0x90: /* Branch through zero */
       {  ARMword oldpsr = ARMul_GetCPSR(state) ;
          ARMul_SetCPSR(state, (oldpsr & 0xffffffc0) | 0x13) ;
          ARMul_SetSPSR(state, SVC32MODE, oldpsr) ;
          state->Reg[14] = 0;
          goto TidyCommon;
       }

    case 0x98: /* Error */
       {  ARMword errorp = state->Reg[0],
                  regp = state->Reg[1];
          unsigned i;
          ARMword errorpsr = ARMul_ReadWord(state, regp + 16*4);
          for (i = 0; i < 15; i++)
            ARMul_SetReg(state,errorpsr,i,ARMul_ReadWord(state, regp + i*4L)) ;
          state->Reg[14] = ARMul_ReadWord(state, regp + 15*4L);
          state->Reg[10] = errorp;
          ARMul_SetSPSR(state,state->Mode,errorpsr) ;
          OSptr->ErrorP = errorp;
          goto TidyCommon;
       }

    case 0x94: /* Data abort */
       {  ARMword addr = state->Reg[14] - 8;
          ARMword cpsr = ARMul_GetCPSR(state) ;
          if (ARM26BITMODE)
             addr = addr & 0x3fffffc ;
          ARMul_SetCPSR(state,ARMul_GetSPSR(state,cpsr)) ;
          UnwindDataAbort(state, addr);
          if (addr >= FPESTART && addr < FPEEND) { /* in the FPE */
             ARMword sp, spsr ;
             unsigned i ;

             sp = state->Reg[13] ;
             state->Reg[13] += 64 ; /* fix the aborting mode sp */
             state->Reg[14] = ARMul_ReadWord(state,sp + 60) ; /* and its lr */
             spsr = ARMul_GetSPSR(state,state->Mode) ;
             state->Mode = ARMul_SwitchMode(state, state->Mode, spsr);
             for (i = 0 ; i < 15 ; i++) {
                ARMul_SetReg(state,spsr,i,ARMul_ReadWord(state,sp)) ;
                sp += 4 ;
                }
             ARMul_SetCPSR(state,cpsr) ;
             state->Reg[14] = ARMul_ReadWord(state,sp) + 4 ; /* botch it */
             ARMul_SetSPSR(state,state->Mode,spsr) ;
             }
          else
             ARMul_SetCPSR(state,cpsr) ;

          /* and fall through to correct r14 */
       }
    case 0x95: /* Address Exception */
       state->Reg[14] -= 4;
    case 0x91: /* Undefined instruction */
    case 0x92: /* SWI */
    case 0x93: /* Prefetch abort */
    case 0x96: /* IRQ */
    case 0x97: /* FIQ */
       state->Reg[14] -= 4;
    TidyCommon:
       if (state->VectorCatch & (1 << (number - 0x90))) {
          ARMul_SetR15(state, state->Reg[14] + 8) ; /* the 8 is the pipelining the the RDI will undo */
          ARMul_SetCPSR(state,ARMul_GetSPSR(state,ARMul_GetCPSR(state))) ;
          if (number == 0x90)
             state->EndCondition = 10 ; /* Branch through Zero Error */
          else
             state->EndCondition = (unsigned)number - 0x8f;
          state->Emulate = FALSE ;
          }
       else {
          ARMword sp = state->Reg[13];
          ARMul_WriteWord(state, sp - 4, state->Reg[14]);
          ARMul_WriteWord(state, sp - 8, state->Reg[12]);
          ARMul_WriteWord(state, sp - 12, state->Reg[11]);
          ARMul_WriteWord(state, sp - 16, state->Reg[10]);
          state->Reg[13] = sp - 16;
          state->Reg[11] = ADDRSOFHANDLERS + 8 * (number - 0x90);
          }
       return(TRUE);

/* SWI's 0x8x pass an abort of type x to the debugger if a handler returns */

    case 0x80: case 0x81: case 0x82: case 0x83:
    case 0x84: case 0x85: case 0x86: case 0x87: case 0x88:
       {  ARMword sp = state->Reg[13];
          state->Reg[10] = ARMul_ReadWord(state, sp);
          state->Reg[11] = ARMul_ReadWord(state, sp + 4);
          state->Reg[12] = ARMul_ReadWord(state, sp + 8);
          state->Reg[14] = ARMul_ReadWord(state, sp + 12);
          state->Reg[13] = sp + 16;
          ARMul_SetR15(state, state->Reg[14] + 8) ; /* the 8 is the pipelining the the RDI will undo */
          ARMul_SetCPSR(state,ARMul_GetSPSR(state,ARMul_GetCPSR(state))) ;
          if (number == 0x80)
             state->EndCondition = 10 ; /* Branch through Zero Error */
          else
             state->EndCondition = (unsigned)number - 0x7f;
          state->Emulate = FALSE ;
          return(TRUE);
       }

    default :
          state->Emulate = FALSE ;      
       return(FALSE) ;
    }
#endif
#endif
 }
#endif  /* CYGNUS LOCAL: #if 1 */

d605 4
a608 4
unsigned 
ARMul_OSException (ARMul_State *state, ARMword vector, ARMword pc)
{ /* don't use this here */
 return(FALSE) ;
a612 44
/***************************************************************************\
*                            Unwind a data abort                            *
\***************************************************************************/

static void 
UnwindDataAbort (ARMul_State *state, ARMword addr)
{
  ARMword instr = ARMul_ReadWord(state, addr);
  ARMword rn = BITS(16, 19);
  ARMword itype = BITS(24, 27);
  ARMword offset;
  if (rn == 15) return;
  if (itype == 8 || itype == 9) {
    /* LDM or STM */
    unsigned long regs = BITS(0, 15);
    offset = 0;
    if (!BIT(21)) return; /* no wb */
    for (; regs != 0; offset++)
      regs ^= (regs & -regs);
    if (offset == 0) offset = 16;
  } else if (itype == 12 ||              /* post-indexed CPDT */
             (itype == 13 && BIT(21))) { /* pre_indexed CPDT with WB */
    offset = BITS(0, 7);
  } else
    return;

  if (BIT(23))
    state->Reg[rn] -= offset * 4;
  else
    state->Reg[rn] += offset * 4;
}

/***************************************************************************\
*           Copy a string from the debuggee's memory to the host's          *
\***************************************************************************/

static void 
getstring (ARMul_State *state, ARMword from, char *to)
{
  do 
    {
      *to = (char) ARMul_ReadByte (state, from++);
    } while (*to++ != '\0');
}
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-10-04 snapshot
@
text
@d254 1
a254 1
    (void) fputc ((char) temp, stdout);
d433 1
a433 1
      (void)fputc((int)state->Reg[0],stdout) ;
d500 1
a500 1
	  (void) fputc ((int) ARMul_ReadByte (state,addr), stdout);
@


1.1.1.3
log
@import gdb-1999-10-11 snapshot
@
text
@d298 1
a298 1
      state->Reg[0] = (int) open (dummy, flags, 0666);
@


1.1.1.4
log
@import gdb-1999-12-06 snapshot
@
text
@a310 6
  if (local == NULL)
    {
      fprintf (stderr, "sim: Unable to read 0x%x bytes - out of memory\n", len);
      return;
    }
  
d328 1
a328 1
  if (local == NULL)
d330 1
a330 2
      fprintf (stderr, "sim: Unable to write 0x%x bytes - out of memory\n", len);
      return;
a331 4
  
  for (i = 0; i < len; i++) 
    local[i] = ARMul_ReadByte (state, ptr + i);

@


1.1.1.5
log
@import gdb-2000-02-04 snapshot
@
text
@d50 1
a50 1
#include <unistd.h>		/* For SEEK_SET etc */
d54 1
a54 1
extern int _fisatty (FILE *);
d83 6
a88 7
extern unsigned ARMul_OSInit (ARMul_State * state);
extern void ARMul_OSExit (ARMul_State * state);
extern unsigned ARMul_OSHandleSWI (ARMul_State * state, ARMword number);
extern unsigned ARMul_OSException (ARMul_State * state, ARMword vector,
				   ARMword pc);
extern ARMword ARMul_OSLastErrorP (ARMul_State * state);
extern ARMword ARMul_Debug (ARMul_State * state, ARMword pc, ARMword instr);
d97 2
a98 2
static void UnwindDataAbort (ARMul_State * state, ARMword addr);
static void getstring (ARMul_State * state, ARMword from, char *to);
d105 8
a112 9
struct OSblock
{
  ARMword Time0;
  ARMword ErrorP;
  ARMword ErrorNo;
  FILE *FileTable[FOPEN_MAX];
  char FileFlags[FOPEN_MAX];
  char *tempnames[UNIQUETEMPS];
};
d124 2
a125 2
#else
#define FIXCRLF(t,c) c
d128 10
a137 9
static ARMword softvectorcode[] = {	/* basic: swi tidyexception + event; mov pc, lr;
					   ldmia r11,{r11,pc}; swi generateexception + event
					 */
  0xef000090, 0xe1a0e00f, 0xe89b8800, 0xef000080,	/*Reset */
  0xef000091, 0xe1a0e00f, 0xe89b8800, 0xef000081,	/*Undef */
  0xef000092, 0xe1a0e00f, 0xe89b8800, 0xef000082,	/*SWI  */
  0xef000093, 0xe1a0e00f, 0xe89b8800, 0xef000083,	/*Prefetch abort */
  0xef000094, 0xe1a0e00f, 0xe89b8800, 0xef000084,	/*Data abort */
  0xef000095, 0xe1a0e00f, 0xe89b8800, 0xef000085,	/*Address exception */
d139 3
a141 3
    0xef000097, 0xe1a0e00f, 0xe89b8800, 0xef000087, /*FIQ*/
    0xef000098, 0xe1a0e00f, 0xe89b8800, 0xef000088,	/*Error */
  0xe1a0f00e			/* default handler */
d148 2
a149 2
unsigned
ARMul_OSInit (ARMul_State * state)
d153 2
a154 2
  ARMword instr, i, j;
  struct OSblock *OSptr = (struct OSblock *) state->OSptr;
d156 6
a161 8
  if (state->OSptr == NULL)
    {
      state->OSptr = (unsigned char *) malloc (sizeof (struct OSblock));
      if (state->OSptr == NULL)
	{
	  perror ("OS Memory");
	  exit (15);
	}
d163 12
a174 14
  OSptr = (struct OSblock *) state->OSptr;
  OSptr->ErrorP = 0;
  state->Reg[13] = ADDRSUPERSTACK;	/* set up a stack for the current mode */
  ARMul_SetReg (state, SVC32MODE, 13, ADDRSUPERSTACK);	/* and for supervisor mode */
  ARMul_SetReg (state, ABORT32MODE, 13, ADDRSUPERSTACK);	/* and for abort 32 mode */
  ARMul_SetReg (state, UNDEF32MODE, 13, ADDRSUPERSTACK);	/* and for undef 32 mode */
  instr = 0xe59ff000 | (ADDRSOFTVECTORS - 8);	/* load pc from soft vector */
  for (i = ARMul_ResetV; i <= ARMFIQV; i += 4)
    ARMul_WriteWord (state, i, instr);	/* write hardware vectors */
  for (i = ARMul_ResetV; i <= ARMFIQV + 4; i += 4)
    {
      ARMul_WriteWord (state, ADDRSOFTVECTORS + i, SOFTVECTORCODE + i * 4);
      ARMul_WriteWord (state, ADDRSOFHANDLERS + 2 * i + 4L,
		       SOFTVECTORCODE + sizeof (softvectorcode) - 4L);
d176 7
a182 7
  for (i = 0; i < sizeof (softvectorcode); i += 4)
    ARMul_WriteWord (state, SOFTVECTORCODE + i, softvectorcode[i / 4]);
  for (i = 0; i < FOPEN_MAX; i++)
    OSptr->FileTable[i] = NULL;
  for (i = 0; i < UNIQUETEMPS; i++)
    OSptr->tempnames[i] = NULL;
  ARMul_ConsolePrint (state, ", Demon 1.01");
d186 13
a198 14
  /* install fpe */
  for (i = 0; i < fpesize; i += 4)	/* copy the code */
    ARMul_WriteWord (state, FPESTART + i, fpecode[i >> 2]);
  for (i = FPESTART + fpesize;; i -= 4)
    {				/* reverse the error strings */
      if ((j = ARMul_ReadWord (state, i)) == 0xffffffff)
	break;
      if (state->bigendSig && j < 0x80000000)
	{			/* it's part of the string so swap it */
	  j = ((j >> 0x18) & 0x000000ff) |
	    ((j >> 0x08) & 0x0000ff00) |
	    ((j << 0x08) & 0x00ff0000) | ((j << 0x18) & 0xff000000);
	  ARMul_WriteWord (state, i, j);
	}
d200 3
a202 3
  ARMul_WriteWord (state, FPEOLDVECT, ARMul_ReadWord (state, 4));	/* copy old illegal instr vector */
  ARMul_WriteWord (state, 4, FPENEWVECT (ARMul_ReadWord (state, i - 4)));	/* install new vector */
  ARMul_ConsolePrint (state, ", FPE");
d208 1
a208 1
  return (TRUE);
d211 2
a212 2
void
ARMul_OSExit (ARMul_State * state)
d214 1
a214 1
  free ((char *) state->OSptr);
d222 2
a223 1
ARMword ARMul_OSLastErrorP (ARMul_State * state)
d225 1
a225 1
  return ((struct OSblock *) state->OSptr)->ErrorP;
d228 1
a228 1
#if 1				/* CYGNUS LOCAL */
d231 14
a244 13
static int translate_open_mode[] = {
  O_RDONLY,			/* "r"   */
  O_RDONLY + O_BINARY,		/* "rb"  */
  O_RDWR,			/* "r+"  */
  O_RDWR + O_BINARY,		/* "r+b" */
  O_WRONLY + O_CREAT + O_TRUNC,	/* "w"   */
  O_WRONLY + O_BINARY + O_CREAT + O_TRUNC,	/* "wb"  */
  O_RDWR + O_CREAT + O_TRUNC,	/* "w+"  */
  O_RDWR + O_BINARY + O_CREAT + O_TRUNC,	/* "w+b" */
  O_WRONLY + O_APPEND + O_CREAT,	/* "a"   */
  O_WRONLY + O_BINARY + O_APPEND + O_CREAT,	/* "ab"  */
  O_RDWR + O_APPEND + O_CREAT,	/* "a+"  */
  O_RDWR + O_BINARY + O_APPEND + O_CREAT	/* "a+b" */
d247 2
a248 2
static void
SWIWrite0 (ARMul_State * state, ARMword addr)
d251 1
a251 1
  struct OSblock *OSptr = (struct OSblock *) state->OSptr;
d259 2
a260 2
static void
WriteCommandLineTo (ARMul_State * state, ARMword addr)
d266 4
a269 6
  do
    {
      temp = (ARMword) * cptr++;
      ARMul_WriteByte (state, addr++, temp);
    }
  while (temp != 0);
d272 2
a273 2
static void
SWIopen (ARMul_State * state, ARMword name, ARMword SWIflags)
d275 1
a275 1
  struct OSblock *OSptr = (struct OSblock *) state->OSptr;
d280 3
a282 1
  for (i = 0; dummy[i] = ARMul_ReadByte (state, name + i); i++)
d291 4
a294 4
      if (flags == O_RDONLY)	/* opening tty "r" */
	state->Reg[0] = 0;	/* stdin */
      else
	state->Reg[0] = 1;	/* stdout */
d303 2
a304 2
static void
SWIread (ARMul_State * state, ARMword f, ARMword ptr, ARMword len)
d306 1
a306 1
  struct OSblock *OSptr = (struct OSblock *) state->OSptr;
d313 1
a313 2
      fprintf (stderr, "sim: Unable to read 0x%x bytes - out of memory\n",
	       len);
d316 1
a316 1

d319 1
a319 1
    for (i = 0; i < res; i++)
d326 2
a327 2
static void
SWIwrite (ARMul_State * state, ARMword f, ARMword ptr, ARMword len)
d329 1
a329 1
  struct OSblock *OSptr = (struct OSblock *) state->OSptr;
d336 1
a336 2
      fprintf (stderr, "sim: Unable to write 0x%x bytes - out of memory\n",
	       len);
d339 2
a340 2

  for (i = 0; i < len; i++)
d349 2
a350 2
static void
SWIflen (ARMul_State * state, ARMword fh)
d352 1
a352 1
  struct OSblock *OSptr = (struct OSblock *) state->OSptr;
d379 2
a380 2
unsigned
ARMul_OSHandleSWI (ARMul_State * state, ARMword number)
d385 1
a385 1
  struct OSblock *OSptr = (struct OSblock *) state->OSptr;
d390 2
a391 2
      SWIread (state, state->Reg[0], state->Reg[1], state->Reg[2]);
      return TRUE;
d394 2
a395 2
      SWIwrite (state, state->Reg[0], state->Reg[1], state->Reg[2]);
      return TRUE;
d398 2
a399 2
      SWIopen (state, state->Reg[0], state->Reg[1]);
      return TRUE;
d401 3
a403 3
    case SWI_Clock:
      /* return number of centi-seconds... */
      state->Reg[0] =
d405 3
a407 3
	(CLOCKS_PER_SEC >= 100)
	? (ARMword) (clock () / (CLOCKS_PER_SEC / 100))
	: (ARMword) ((clock () * 100) / CLOCKS_PER_SEC);
d409 2
a410 2
	/* presume unix... clock() returns microseconds */
	(ARMword) (clock () / 10000);
d412 2
a413 7
      OSptr->ErrorNo = errno;
      return (TRUE);

    case SWI_Time:
      state->Reg[0] = (ARMword) time (NULL);
      OSptr->ErrorNo = errno;
      return (TRUE);
d415 5
d425 1
a425 1
    case SWI_Flen:
d427 1
a427 1
      return (TRUE);
d430 1
a430 1
      state->Emulate = FALSE;
d436 3
a438 1
	state->Reg[0] = -1 >= lseek (state->Reg[0], state->Reg[1], SEEK_SET);
d443 4
a446 4
    case SWI_WriteC:
      (void) fputc ((int) state->Reg[0], stdout);
      OSptr->ErrorNo = errno;
      return (TRUE);
d448 1
a448 1
    case SWI_Write0:
d450 1
a450 1
      return (TRUE);
d452 15
a466 15
    case SWI_GetErrno:
      state->Reg[0] = OSptr->ErrorNo;
      return (TRUE);

    case SWI_Breakpoint:
      state->EndCondition = RDIError_BreakpointReached;
      state->Emulate = FALSE;
      return (TRUE);

    case SWI_GetEnv:
      state->Reg[0] = ADDRCMDLINE;
      if (state->MemSize)
	state->Reg[1] = state->MemSize;
      else
	state->Reg[1] = ADDRUSERSTACK;
d468 2
a469 2
      WriteCommandLineTo (state, state->Reg[0]);
      return (TRUE);
d471 1
a471 1
      /* Handle Angel SWIs as well as Demon ones */
d489 1
a489 1
	  return (FALSE);
d492 1
a492 1
	  /* return number of centi-seconds... */
d496 2
a497 2
	    ? (ARMword) (clock () / (CLOCKS_PER_SEC / 100))
	    : (ARMword) ((clock () * 100) / CLOCKS_PER_SEC);
d499 2
a500 2
	    /* presume unix... clock() returns microseconds */
	    (ARMword) (clock () / 10000);
d511 1
a511 1
	  (void) fputc ((int) ARMul_ReadByte (state, addr), stdout);
d525 2
a526 2
	  state->Reg[0] = -1 >= lseek (ARMul_ReadWord (state, addr),
				       ARMul_ReadWord (state, addr + 4),
d535 1
a535 1
	case AngelSWI_Reason_GetCmdLine:
d549 4
a552 4
	  ARMul_WriteWord (state, addr, 0);	/* Heap base */
	  ARMul_WriteWord (state, addr + 4, temp);	/* Heap limit */
	  ARMul_WriteWord (state, addr + 8, temp);	/* Stack base */
	  ARMul_WriteWord (state, addr + 12, temp);	/* Stack limit */
d560 1
a560 1
	  state->Emulate = FALSE;
d565 1
a565 1
	  state->Emulate = FALSE;
d567 1
a567 1

d570 1
a570 1
	  state->Emulate = FALSE;
d578 3
a580 3
	  SWIopen (state,
		   ARMul_ReadWord (state, addr),
		   ARMul_ReadWord (state, addr + 4));
d584 4
a587 4
	  SWIread (state,
		   ARMul_ReadWord (state, addr),
		   ARMul_ReadWord (state, addr + 4),
		   ARMul_ReadWord (state, addr + 8));
d591 4
a594 4
	  SWIwrite (state,
		    ARMul_ReadWord (state, addr),
		    ARMul_ReadWord (state, addr + 4),
		    ARMul_ReadWord (state, addr + 8));
d598 3
a600 3
    default:
      state->Emulate = FALSE;
      return (FALSE);
d604 1
a604 1
#else /* CYGNUS LOCAL: #if 1 */
d606 2
a607 2
unsigned
ARMul_OSHandleSWI (ARMul_State * state, ARMword number)
d610 1
a610 1
  return (FALSE);
d613 12
a624 13
  switch (number)
    {
    case 0x11:
      state->Emulate = FALSE;
      return (TRUE);
    case 0x01:
      if (ARM32BITMODE)
	ARMul_SetCPSR (state, (ARMul_GetCPSR (state) & 0xffffffc0) | 0x13);
      else
	ARMul_SetCPSR (state, (ARMul_GetCPSR (state) & 0xffffffc0) | 0x3);
      return (TRUE);
    default:
      return (FALSE);
d627 46
a672 4
  ARMword addr, temp;
  char buffer[BUFFERSIZE], *cptr;
  FILE *fptr;
  struct OSblock *OSptr = (struct OSblock *) state->OSptr;
d674 1
a674 46
  switch (number)
    {
    case SWI_WriteC:
      (void) fputc ((int) state->Reg[0], stderr);
      OSptr->ErrorNo = errno;
      return (TRUE);

    case SWI_Write0:
      addr = state->Reg[0];
      while ((temp = ARMul_ReadByte (state, addr++)) != 0)
	fputc ((char) temp, stderr);
      OSptr->ErrorNo = errno;
      return (TRUE);

    case SWI_ReadC:
      state->Reg[0] = (ARMword) fgetc (stdin);
      OSptr->ErrorNo = errno;
      return (TRUE);

    case SWI_CLI:
      addr = state->Reg[0];
      getstring (state, state->Reg[0], buffer);
      state->Reg[0] = (ARMword) system (buffer);
      OSptr->ErrorNo = errno;
      return (TRUE);

    case SWI_GetEnv:
      state->Reg[0] = ADDRCMDLINE;
      if (state->MemSize)
	state->Reg[1] = state->MemSize;
      else
	state->Reg[1] = ADDRUSERSTACK;

      addr = state->Reg[0];
      cptr = state->CommandLine;
      if (cptr == NULL)
	cptr = "\0";
      do
	{
	  temp = (ARMword) * cptr++;
	  ARMul_WriteByte (state, addr++, temp);
	}
      while (temp != 0);
      return (TRUE);

    case SWI_Exit:
d676 1
a676 1
      simkernel1_abort_run ();
d678 1
a678 1
      state->Emulate = FALSE;
d680 1
a680 1
      return (TRUE);
d682 14
a695 14
    case SWI_EnterOS:
      if (ARM32BITMODE)
	ARMul_SetCPSR (state, (ARMul_GetCPSR (state) & 0xffffffc0) | 0x13);
      else
	ARMul_SetCPSR (state, (ARMul_GetCPSR (state) & 0xffffffc0) | 0x3);
      return (TRUE);

    case SWI_GetErrno:
      state->Reg[0] = OSptr->ErrorNo;
      return (TRUE);

    case SWI_Clock:
      /* return muber of centi-seconds... */
      state->Reg[0] =
d697 3
a699 3
	(CLOCKS_PER_SEC >= 100)
	? (ARMword) (clock () / (CLOCKS_PER_SEC / 100))
	: (ARMword) ((clock () * 100) / CLOCKS_PER_SEC);
d701 2
a702 2
	/* presume unix... clock() returns microseconds */
	(ARMword) (clock () / 10000);
d704 2
a705 2
      OSptr->ErrorNo = errno;
      return (TRUE);
d707 20
a726 10
    case SWI_Time:
      state->Reg[0] = (ARMword) time (NULL);
      OSptr->ErrorNo = errno;
      return (TRUE);

    case SWI_Remove:
      getstring (state, state->Reg[0], buffer);
      state->Reg[0] = unlink (buffer);
      OSptr->ErrorNo = errno;
      return (TRUE);
d728 1
a728 13
    case SWI_Rename:
      {
	char buffer2[BUFFERSIZE];

	getstring (state, state->Reg[0], buffer);
	getstring (state, state->Reg[1], buffer2);
	state->Reg[0] = rename (buffer, buffer2);
	OSptr->ErrorNo = errno;
	return (TRUE);
      }

    case SWI_Open:
      {
d730 9
a738 10
	/* It seems to me that these are in the wrong order
	   sac@@cygnus.com, so I've redone it to use the
	   flags instead, with the functionality which was already
	   there -- ahh, perhaps the TRUNC bit is in a different
	   place on the original host ? */
	static char *fmode[] = { "r", "rb", "r+", "r+b",
	  "w", "wb", "w+", "w+b",
	  "a", "ab", "a+", "a+b",
	  "r", "r", "r", "r"
	} /* last 4 are illegal */ ;
d741 1
a741 209
	unsigned type;

	type = (unsigned) (state->Reg[1] & 3L);
	getstring (state, state->Reg[0], buffer);
	if (strcmp (buffer, ":tt") == 0 && (type == O_RDONLY))	/* opening tty "r" */
	  fptr = stdin;
	else if (strcmp (buffer, ":tt") == 0 && (type == O_WRONLY))	/* opening tty "w" */
	  fptr = stderr;
	else
	  {
	    switch (type)
	      {
	      case O_RDONLY:
		fptr = fopen (buffer, "r");
		break;
	      case O_WRONLY:
		fptr = fopen (buffer, "w");
		break;
	      case O_RDWR:
		fptr = fopen (buffer, "rw");
		break;
	      }
	  }

	state->Reg[0] = 0;
	if (fptr != NULL)
	  {
	    for (temp = 0; temp < FOPEN_MAX; temp++)
	      if (OSptr->FileTable[temp] == NULL)
		{
		  OSptr->FileTable[temp] = fptr;
		  OSptr->FileFlags[temp] = type & 1;	/* preserve the binary bit */
		  state->Reg[0] = (ARMword) (temp + 1);
		  break;
		}
	    if (state->Reg[0] == 0)
	      OSptr->ErrorNo = EMFILE;	/* too many open files */
	    else
	      OSptr->ErrorNo = errno;
	  }
	else
	  OSptr->ErrorNo = errno;
	return (TRUE);
      }

    case SWI_Close:
      temp = state->Reg[0];
      if (temp == 0 || temp > FOPEN_MAX || OSptr->FileTable[temp - 1] == 0)
	{
	  OSptr->ErrorNo = EBADF;
	  state->Reg[0] = -1L;
	  return (TRUE);
	}
      temp--;
      fptr = OSptr->FileTable[temp];
      if (fptr == stdin || fptr == stderr)
	state->Reg[0] = 0;
      else
	state->Reg[0] = fclose (fptr);
      OSptr->FileTable[temp] = NULL;
      OSptr->ErrorNo = errno;
      return (TRUE);

    case SWI_Write:
      {
	unsigned size, upto, type;
	char ch;

	temp = state->Reg[0];
	if (temp == 0 || temp > FOPEN_MAX || OSptr->FileTable[temp - 1] == 0)
	  {
	    OSptr->ErrorNo = EBADF;
	    state->Reg[0] = -1L;
	    return (TRUE);
	  }
	temp--;
	fptr = OSptr->FileTable[temp];
	type = OSptr->FileFlags[temp];
	addr = state->Reg[1];
	size = (unsigned) state->Reg[2];

	if (type & READOP)
	  fseek (fptr, 0L, SEEK_CUR);
	OSptr->FileFlags[temp] = (type & BINARY) | WRITEOP;;
	while (size > 0)
	  {
	    if (size >= BUFFERSIZE)
	      upto = BUFFERSIZE;
	    else
	      upto = size;
	    for (cptr = buffer; (cptr - buffer) < upto; cptr++)
	      {
		ch = (char) ARMul_ReadByte (state, (ARMword) addr++);
		*cptr = FIXCRLF (type, ch);
	      }
	    temp = fwrite (buffer, 1, upto, fptr);
	    if (temp < upto)
	      {
		state->Reg[0] = (ARMword) (size - temp);
		OSptr->ErrorNo = errno;
		return (TRUE);
	      }
	    size -= upto;
	  }
	state->Reg[0] = 0;
	OSptr->ErrorNo = errno;
	return (TRUE);
      }

    case SWI_Read:
      {
	unsigned size, upto, type;
	char ch;

	temp = state->Reg[0];
	if (temp == 0 || temp > FOPEN_MAX || OSptr->FileTable[temp - 1] == 0)
	  {
	    OSptr->ErrorNo = EBADF;
	    state->Reg[0] = -1L;
	    return (TRUE);
	  }
	temp--;
	fptr = OSptr->FileTable[temp];
	addr = state->Reg[1];
	size = (unsigned) state->Reg[2];
	type = OSptr->FileFlags[temp];

	if (type & WRITEOP)
	  fseek (fptr, 0L, SEEK_CUR);
	OSptr->FileFlags[temp] = (type & BINARY) | READOP;;
	while (size > 0)
	  {
	    if (isatty_ (fptr))
	      {
		upto = (size >= BUFFERSIZE) ? BUFFERSIZE : size + 1;
		if (fgets (buffer, upto, fptr) != 0)
		  temp = strlen (buffer);
		else
		  temp = 0;
		upto--;		/* 1 char used for terminating null */
	      }
	    else
	      {
		upto = (size >= BUFFERSIZE) ? BUFFERSIZE : size;
		temp = fread (buffer, 1, upto, fptr);
	      }
	    for (cptr = buffer; (cptr - buffer) < temp; cptr++)
	      {
		ch = *cptr;
		ARMul_WriteByte (state, (ARMword) addr++, FIXCRLF (type, ch));
	      }
	    if (temp < upto)
	      {
		state->Reg[0] = (ARMword) (size - temp);
		OSptr->ErrorNo = errno;
		return (TRUE);
	      }
	    size -= upto;
	  }
	state->Reg[0] = 0;
	OSptr->ErrorNo = errno;
	return (TRUE);
      }

    case SWI_Seek:
      if (state->Reg[0] == 0 || state->Reg[0] > FOPEN_MAX
	  || OSptr->FileTable[state->Reg[0] - 1] == 0)
	{
	  OSptr->ErrorNo = EBADF;
	  state->Reg[0] = -1L;
	  return (TRUE);
	}
      fptr = OSptr->FileTable[state->Reg[0] - 1];
      state->Reg[0] = fseek (fptr, (long) state->Reg[1], SEEK_SET);
      OSptr->ErrorNo = errno;
      return (TRUE);

    case SWI_Flen:
      if (state->Reg[0] == 0 || state->Reg[0] > FOPEN_MAX
	  || OSptr->FileTable[state->Reg[0] - 1] == 0)
	{
	  OSptr->ErrorNo = EBADF;
	  state->Reg[0] = -1L;
	  return (TRUE);
	}
      fptr = OSptr->FileTable[state->Reg[0] - 1];
      addr = (ARMword) ftell (fptr);
      if (fseek (fptr, 0L, SEEK_END) < 0)
	state->Reg[0] = -1;
      else
	{
	  state->Reg[0] = (ARMword) ftell (fptr);
	  (void) fseek (fptr, addr, SEEK_SET);
	}
      OSptr->ErrorNo = errno;
      return (TRUE);

    case SWI_IsTTY:
      if (state->Reg[0] == 0 || state->Reg[0] > FOPEN_MAX
	  || OSptr->FileTable[state->Reg[0] - 1] == 0)
	{
	  OSptr->ErrorNo = EBADF;
	  state->Reg[0] = -1L;
	  return (TRUE);
	}
      fptr = OSptr->FileTable[state->Reg[0] - 1];
      state->Reg[0] = isatty_ (fptr);
      OSptr->ErrorNo = errno;
      return (TRUE);
d743 212
a954 28
    case SWI_TmpNam:
      {
	ARMword size;

	addr = state->Reg[0];
	temp = state->Reg[1] & 0xff;
	size = state->Reg[2];
	if (OSptr->tempnames[temp] == NULL)
	  {
	    if ((OSptr->tempnames[temp] = malloc (L_tmpnam)) == NULL)
	      {
		state->Reg[0] = 0;
		return (TRUE);
	      }
	    (void) tmpnam (OSptr->tempnames[temp]);
	  }
	cptr = OSptr->tempnames[temp];
	if (strlen (cptr) > state->Reg[2])
	  state->Reg[0] = 0;
	else
	  do
	    {
	      ARMul_WriteByte (state, addr++, *cptr);
	    }
	  while (*cptr++ != 0);
	OSptr->ErrorNo = errno;
	return (TRUE);
      }
d957 9
a965 10
      {
	ARMword handlerp = ADDRSOFHANDLERS + state->Reg[0] * 8;
	ARMword oldr1 = ARMul_ReadWord (state, handlerp),
	  oldr2 = ARMul_ReadWord (state, handlerp + 4);
	ARMul_WriteWord (state, handlerp, state->Reg[1]);
	ARMul_WriteWord (state, handlerp + 4, state->Reg[2]);
	state->Reg[1] = oldr1;
	state->Reg[2] = oldr2;
	return (TRUE);
      }
d968 4
a971 5
      ARMul_Abort (state, ARMSWIV);
      if (state->Emulate)
	ARMul_SetR15 (state,
		      ARMul_ReadWord (state, ADDRSOFTVECTORS + ARMErrorV));
      return (TRUE);
d975 59
a1033 64
    case 0x90:			/* Branch through zero */
      {
	ARMword oldpsr = ARMul_GetCPSR (state);
	ARMul_SetCPSR (state, (oldpsr & 0xffffffc0) | 0x13);
	ARMul_SetSPSR (state, SVC32MODE, oldpsr);
	state->Reg[14] = 0;
	goto TidyCommon;
      }

    case 0x98:			/* Error */
      {
	ARMword errorp = state->Reg[0], regp = state->Reg[1];
	unsigned i;
	ARMword errorpsr = ARMul_ReadWord (state, regp + 16 * 4);
	for (i = 0; i < 15; i++)
	  ARMul_SetReg (state, errorpsr, i,
			ARMul_ReadWord (state, regp + i * 4L));
	state->Reg[14] = ARMul_ReadWord (state, regp + 15 * 4L);
	state->Reg[10] = errorp;
	ARMul_SetSPSR (state, state->Mode, errorpsr);
	OSptr->ErrorP = errorp;
	goto TidyCommon;
      }

    case 0x94:			/* Data abort */
      {
	ARMword addr = state->Reg[14] - 8;
	ARMword cpsr = ARMul_GetCPSR (state);
	if (ARM26BITMODE)
	  addr = addr & 0x3fffffc;
	ARMul_SetCPSR (state, ARMul_GetSPSR (state, cpsr));
	UnwindDataAbort (state, addr);
	if (addr >= FPESTART && addr < FPEEND)
	  {			/* in the FPE */
	    ARMword sp, spsr;
	    unsigned i;

	    sp = state->Reg[13];
	    state->Reg[13] += 64;	/* fix the aborting mode sp */
	    state->Reg[14] = ARMul_ReadWord (state, sp + 60);	/* and its lr */
	    spsr = ARMul_GetSPSR (state, state->Mode);
	    state->Mode = ARMul_SwitchMode (state, state->Mode, spsr);
	    for (i = 0; i < 15; i++)
	      {
		ARMul_SetReg (state, spsr, i, ARMul_ReadWord (state, sp));
		sp += 4;
	      }
	    ARMul_SetCPSR (state, cpsr);
	    state->Reg[14] = ARMul_ReadWord (state, sp) + 4;	/* botch it */
	    ARMul_SetSPSR (state, state->Mode, spsr);
	  }
	else
	  ARMul_SetCPSR (state, cpsr);

	/* and fall through to correct r14 */
      }
    case 0x95:			/* Address Exception */
      state->Reg[14] -= 4;
    case 0x91:			/* Undefined instruction */
    case 0x92:			/* SWI */
    case 0x93:			/* Prefetch abort */
    case 0x96:			/* IRQ */
    case 0x97:			/* FIQ */
      state->Reg[14] -= 4;
d1035 19
a1053 21
      if (state->VectorCatch & (1 << (number - 0x90)))
	{
	  ARMul_SetR15 (state, state->Reg[14] + 8);	/* the 8 is the pipelining the the RDI will undo */
	  ARMul_SetCPSR (state, ARMul_GetSPSR (state, ARMul_GetCPSR (state)));
	  if (number == 0x90)
	    state->EndCondition = 10;	/* Branch through Zero Error */
	  else
	    state->EndCondition = (unsigned) number - 0x8f;
	  state->Emulate = FALSE;
	}
      else
	{
	  ARMword sp = state->Reg[13];
	  ARMul_WriteWord (state, sp - 4, state->Reg[14]);
	  ARMul_WriteWord (state, sp - 8, state->Reg[12]);
	  ARMul_WriteWord (state, sp - 12, state->Reg[11]);
	  ARMul_WriteWord (state, sp - 16, state->Reg[10]);
	  state->Reg[13] = sp - 16;
	  state->Reg[11] = ADDRSOFHANDLERS + 8 * (number - 0x90);
	}
      return (TRUE);
d1057 21
a1077 29
    case 0x80:
    case 0x81:
    case 0x82:
    case 0x83:
    case 0x84:
    case 0x85:
    case 0x86:
    case 0x87:
    case 0x88:
      {
	ARMword sp = state->Reg[13];
	state->Reg[10] = ARMul_ReadWord (state, sp);
	state->Reg[11] = ARMul_ReadWord (state, sp + 4);
	state->Reg[12] = ARMul_ReadWord (state, sp + 8);
	state->Reg[14] = ARMul_ReadWord (state, sp + 12);
	state->Reg[13] = sp + 16;
	ARMul_SetR15 (state, state->Reg[14] + 8);	/* the 8 is the pipelining the the RDI will undo */
	ARMul_SetCPSR (state, ARMul_GetSPSR (state, ARMul_GetCPSR (state)));
	if (number == 0x80)
	  state->EndCondition = 10;	/* Branch through Zero Error */
	else
	  state->EndCondition = (unsigned) number - 0x7f;
	state->Emulate = FALSE;
	return (TRUE);
      }

    default:
      state->Emulate = FALSE;
      return (FALSE);
d1081 2
a1082 3
}

#endif /* CYGNUS LOCAL: #if 1 */
d1094 4
a1097 4
unsigned
ARMul_OSException (ARMul_State * state, ARMword vector, ARMword pc)
{				/* don't use this here */
  return (FALSE);
d1106 2
a1107 2
static void
UnwindDataAbort (ARMul_State * state, ARMword addr)
d1109 3
a1111 3
  ARMword instr = ARMul_ReadWord (state, addr);
  ARMword rn = BITS (16, 19);
  ARMword itype = BITS (24, 27);
d1113 13
a1125 20
  if (rn == 15)
    return;
  if (itype == 8 || itype == 9)
    {
      /* LDM or STM */
      unsigned long regs = BITS (0, 15);
      offset = 0;
      if (!BIT (21))
	return;			/* no wb */
      for (; regs != 0; offset++)
	regs ^= (regs & -regs);
      if (offset == 0)
	offset = 16;
    }
  else if (itype == 12 ||	/* post-indexed CPDT */
	   (itype == 13 && BIT (21)))
    {				/* pre_indexed CPDT with WB */
      offset = BITS (0, 7);
    }
  else
d1128 1
a1128 1
  if (BIT (23))
d1138 2
a1139 2
static void
getstring (ARMul_State * state, ARMword from, char *to)
d1141 1
a1141 1
  do
d1144 1
a1144 2
    }
  while (*to++ != '\0');
@


