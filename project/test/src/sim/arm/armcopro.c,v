head	1.16;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.16
	gdb_7_6-2013-04-26-release:1.16
	gdb_7_6-branch:1.16.0.2
	gdb_7_6-2013-03-12-branchpoint:1.16
	gdb_7_5_1-2012-11-29-release:1.14
	gdb_7_5-2012-08-17-release:1.14
	gdb_7_5-branch:1.14.0.62
	gdb_7_5-2012-07-18-branchpoint:1.14
	gdb_7_4_1-2012-04-26-release:1.14
	gdb_7_4-2012-01-24-release:1.14
	gdb_7_4-branch:1.14.0.60
	gdb_7_4-2011-12-13-branchpoint:1.14
	gdb_7_3_1-2011-09-04-release:1.14
	gdb_7_3-2011-07-26-release:1.14
	gdb_7_3-branch:1.14.0.58
	gdb_7_3-2011-04-01-branchpoint:1.14
	gdb_7_2-2010-09-02-release:1.14
	gdb_7_2-branch:1.14.0.56
	gdb_7_2-2010-07-07-branchpoint:1.14
	gdb_7_1-2010-03-18-release:1.14
	gdb_7_1-branch:1.14.0.54
	gdb_7_1-2010-02-18-branchpoint:1.14
	gdb_7_0_1-2009-12-22-release:1.14
	gdb_7_0-2009-10-06-release:1.14
	gdb_7_0-branch:1.14.0.52
	gdb_7_0-2009-09-16-branchpoint:1.14
	arc-sim-20090309:1.14
	msnyder-checkpoint-072509-branch:1.14.0.50
	msnyder-checkpoint-072509-branchpoint:1.14
	arc-insight_6_8-branch:1.14.0.48
	arc-insight_6_8-branchpoint:1.14
	insight_6_8-branch:1.14.0.46
	insight_6_8-branchpoint:1.14
	reverse-20081226-branch:1.14.0.44
	reverse-20081226-branchpoint:1.14
	multiprocess-20081120-branch:1.14.0.42
	multiprocess-20081120-branchpoint:1.14
	reverse-20080930-branch:1.14.0.40
	reverse-20080930-branchpoint:1.14
	reverse-20080717-branch:1.14.0.38
	reverse-20080717-branchpoint:1.14
	msnyder-reverse-20080609-branch:1.14.0.36
	msnyder-reverse-20080609-branchpoint:1.14
	drow-reverse-20070409-branch:1.14.0.34
	drow-reverse-20070409-branchpoint:1.14
	gdb_6_8-2008-03-27-release:1.14
	gdb_6_8-branch:1.14.0.32
	gdb_6_8-2008-02-26-branchpoint:1.14
	gdb_6_7_1-2007-10-29-release:1.14
	gdb_6_7-2007-10-10-release:1.14
	gdb_6_7-branch:1.14.0.30
	gdb_6_7-2007-09-07-branchpoint:1.14
	insight_6_6-20070208-release:1.14
	gdb_6_6-2006-12-18-release:1.14
	gdb_6_6-branch:1.14.0.28
	gdb_6_6-2006-11-15-branchpoint:1.14
	insight_6_5-20061003-release:1.14
	gdb-csl-symbian-6_4_50_20060226-12:1.14
	gdb-csl-sourcerygxx-3_4_4-25:1.14
	nickrob-async-20060828-mergepoint:1.14
	gdb-csl-symbian-6_4_50_20060226-11:1.14
	gdb-csl-sourcerygxx-4_1-17:1.14
	gdb-csl-20060226-branch-local-2:1.14
	gdb-csl-sourcerygxx-4_1-14:1.14
	gdb-csl-sourcerygxx-4_1-13:1.14
	gdb-csl-sourcerygxx-4_1-12:1.14
	gdb-csl-sourcerygxx-3_4_4-21:1.14
	gdb_6_5-20060621-release:1.14
	gdb-csl-sourcerygxx-4_1-9:1.14
	gdb-csl-sourcerygxx-4_1-8:1.14
	gdb-csl-sourcerygxx-4_1-7:1.14
	gdb-csl-arm-2006q1-6:1.14
	gdb-csl-sourcerygxx-4_1-6:1.14
	gdb-csl-symbian-6_4_50_20060226-10:1.14
	gdb-csl-symbian-6_4_50_20060226-9:1.14
	gdb-csl-symbian-6_4_50_20060226-8:1.14
	gdb-csl-coldfire-4_1-11:1.14
	gdb-csl-sourcerygxx-3_4_4-19:1.14
	gdb-csl-coldfire-4_1-10:1.14
	gdb_6_5-branch:1.14.0.26
	gdb_6_5-2006-05-14-branchpoint:1.14
	gdb-csl-sourcerygxx-4_1-5:1.14
	nickrob-async-20060513-branch:1.14.0.24
	nickrob-async-20060513-branchpoint:1.14
	gdb-csl-sourcerygxx-4_1-4:1.14
	msnyder-reverse-20060502-branch:1.14.0.22
	msnyder-reverse-20060502-branchpoint:1.14
	gdb-csl-morpho-4_1-4:1.14
	gdb-csl-sourcerygxx-3_4_4-17:1.14
	readline_5_1-import-branch:1.14.0.20
	readline_5_1-import-branchpoint:1.14
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.14
	gdb-csl-symbian-20060226-branch:1.14.0.18
	gdb-csl-symbian-20060226-branchpoint:1.14
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.14
	msnyder-reverse-20060331-branch:1.14.0.16
	msnyder-reverse-20060331-branchpoint:1.14
	gdb-csl-available-20060303-branch:1.14.0.14
	gdb-csl-available-20060303-branchpoint:1.14
	gdb-csl-20060226-branch:1.14.0.12
	gdb-csl-20060226-branchpoint:1.14
	gdb_6_4-20051202-release:1.14
	msnyder-fork-checkpoint-branch:1.14.0.10
	msnyder-fork-checkpoint-branchpoint:1.14
	gdb-csl-gxxpro-6_3-branch:1.14.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.14
	gdb_6_4-branch:1.14.0.6
	gdb_6_4-2005-11-01-branchpoint:1.14
	gdb-csl-arm-20051020-branch:1.14.0.4
	gdb-csl-arm-20051020-branchpoint:1.14
	msnyder-tracepoint-checkpoint-branch:1.14.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.14
	gdb-csl-arm-20050325-2005-q1b:1.13
	gdb-csl-arm-20050325-2005-q1a:1.13
	csl-arm-20050325-branch:1.13.0.46
	csl-arm-20050325-branchpoint:1.13
	gdb_6_3-20041109-release:1.13
	gdb_6_3-branch:1.13.0.42
	gdb_6_3-20041019-branchpoint:1.13
	drow_intercu-merge-20040921:1.13
	drow_intercu-merge-20040915:1.13
	jimb-gdb_6_2-e500-branch:1.13.0.44
	jimb-gdb_6_2-e500-branchpoint:1.13
	gdb_6_2-20040730-release:1.13
	gdb_6_2-branch:1.13.0.40
	gdb_6_2-2004-07-10-gmt-branchpoint:1.13
	gdb_6_1_1-20040616-release:1.13
	gdb_6_1-2004-04-05-release:1.13
	drow_intercu-merge-20040402:1.13
	drow_intercu-merge-20040327:1.13
	ezannoni_pie-20040323-branch:1.13.0.38
	ezannoni_pie-20040323-branchpoint:1.13
	cagney_tramp-20040321-mergepoint:1.13
	cagney_tramp-20040309-branch:1.13.0.36
	cagney_tramp-20040309-branchpoint:1.13
	gdb_6_1-branch:1.13.0.34
	gdb_6_1-2004-03-01-gmt-branchpoint:1.13
	drow_intercu-20040221-branch:1.13.0.32
	drow_intercu-20040221-branchpoint:1.13
	cagney_bfdfile-20040213-branch:1.13.0.30
	cagney_bfdfile-20040213-branchpoint:1.13
	drow-cplus-merge-20040208:1.13
	carlton_dictionary-20040126-merge:1.13
	cagney_bigcore-20040122-branch:1.13.0.28
	cagney_bigcore-20040122-branchpoint:1.13
	drow-cplus-merge-20040113:1.13
	drow-cplus-merge-20031224:1.13
	drow-cplus-merge-20031220:1.13
	carlton_dictionary-20031215-merge:1.13
	drow-cplus-merge-20031214:1.13
	carlton-dictionary-20031111-merge:1.13
	gdb_6_0-2003-10-04-release:1.13
	kettenis_sparc-20030918-branch:1.13.0.26
	kettenis_sparc-20030918-branchpoint:1.13
	carlton_dictionary-20030917-merge:1.13
	ezannoni_pie-20030916-branchpoint:1.13
	ezannoni_pie-20030916-branch:1.13.0.24
	cagney_x86i386-20030821-branch:1.13.0.22
	cagney_x86i386-20030821-branchpoint:1.13
	carlton_dictionary-20030805-merge:1.13
	carlton_dictionary-20030627-merge:1.13
	gdb_6_0-branch:1.13.0.20
	gdb_6_0-2003-06-23-branchpoint:1.13
	jimb-ppc64-linux-20030613-branch:1.13.0.18
	jimb-ppc64-linux-20030613-branchpoint:1.13
	cagney_convert-20030606-branch:1.13.0.16
	cagney_convert-20030606-branchpoint:1.13
	cagney_writestrings-20030508-branch:1.13.0.14
	cagney_writestrings-20030508-branchpoint:1.13
	jimb-ppc64-linux-20030528-branch:1.13.0.12
	jimb-ppc64-linux-20030528-branchpoint:1.13
	carlton_dictionary-20030523-merge:1.13
	cagney_fileio-20030521-branch:1.13.0.10
	cagney_fileio-20030521-branchpoint:1.13
	kettenis_i386newframe-20030517-mergepoint:1.13
	jimb-ppc64-linux-20030509-branch:1.13.0.8
	jimb-ppc64-linux-20030509-branchpoint:1.13
	kettenis_i386newframe-20030504-mergepoint:1.13
	carlton_dictionary-20030430-merge:1.13
	kettenis_i386newframe-20030419-branch:1.13.0.6
	kettenis_i386newframe-20030419-branchpoint:1.13
	carlton_dictionary-20030416-merge:1.13
	cagney_frameaddr-20030409-mergepoint:1.13
	kettenis_i386newframe-20030406-branch:1.13.0.4
	kettenis_i386newframe-20030406-branchpoint:1.13
	cagney_frameaddr-20030403-branchpoint:1.13
	cagney_frameaddr-20030403-branch:1.13.0.2
	cagney_framebase-20030330-mergepoint:1.13
	cagney_framebase-20030326-branch:1.11.0.2
	cagney_framebase-20030326-branchpoint:1.11
	cagney_lazyid-20030317-branch:1.10.0.22
	cagney_lazyid-20030317-branchpoint:1.10
	kettenis-i386newframe-20030316-mergepoint:1.10
	offbyone-20030313-branch:1.10.0.20
	offbyone-20030313-branchpoint:1.10
	kettenis-i386newframe-20030308-branch:1.10.0.18
	kettenis-i386newframe-20030308-branchpoint:1.10
	carlton_dictionary-20030305-merge:1.10
	cagney_offbyone-20030303-branch:1.10.0.16
	cagney_offbyone-20030303-branchpoint:1.10
	carlton_dictionary-20030207-merge:1.10
	interps-20030202-branch:1.10.0.14
	interps-20030202-branchpoint:1.10
	cagney-unwind-20030108-branch:1.10.0.12
	cagney-unwind-20030108-branchpoint:1.10
	carlton_dictionary-20021223-merge:1.10
	gdb_5_3-2002-12-12-release:1.10
	carlton_dictionary-20021115-merge:1.10
	kseitz_interps-20021105-merge:1.10
	kseitz_interps-20021103-merge:1.10
	drow-cplus-merge-20021020:1.10
	drow-cplus-merge-20021025:1.10
	carlton_dictionary-20021025-merge:1.10
	carlton_dictionary-20021011-merge:1.10
	drow-cplus-branch:1.10.0.10
	drow-cplus-branchpoint:1.10
	kseitz_interps-20020930-merge:1.10
	carlton_dictionary-20020927-merge:1.10
	carlton_dictionary-branch:1.10.0.8
	carlton_dictionary-20020920-branchpoint:1.10
	gdb_5_3-branch:1.10.0.6
	gdb_5_3-2002-09-04-branchpoint:1.10
	kseitz_interps-20020829-merge:1.10
	cagney_sysregs-20020825-branch:1.10.0.4
	cagney_sysregs-20020825-branchpoint:1.10
	readline_4_3-import-branch:1.10.0.2
	readline_4_3-import-branchpoint:1.10
	gdb_5_2_1-2002-07-23-release:1.7
	kseitz_interps-20020528-branch:1.9.0.2
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.7.0.6
	cagney_regbuf-20020515-branchpoint:1.7
	jimb-macro-020506-branch:1.7.0.4
	jimb-macro-020506-branchpoint:1.7
	gdb_5_2-2002-04-29-release:1.7
	gdb_5_2-branch:1.7.0.2
	gdb_5_2-2002-03-03-branchpoint:1.7
	gdb_5_1_1-2002-01-24-release:1.6
	gdb_5_1_0_1-2002-01-03-release:1.6
	gdb_5_1_0_1-2002-01-03-branch:1.6.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.6
	gdb_5_1-2001-11-21-release:1.6
	gdb_s390-2001-09-26-branch:1.6.0.4
	gdb_s390-2001-09-26-branchpoint:1.6
	gdb_5_1-2001-07-29-branch:1.6.0.2
	gdb_5_1-2001-07-29-branchpoint:1.6
	insight-precleanup-2001-01-01:1.4
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.16
date	2012.12.19.07.18.14;	author brobecke;	state Exp;
branches;
next	1.15;

1.15
date	2012.12.19.07.11.58;	author brobecke;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.12.07.36.58;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.30.10.39.22;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.27.17.13.33;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.20.12.25.07;	author nickc;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2002.05.29.19.01.36;	author nickc;	state Exp;
branches
	1.10.8.1
	1.10.10.1;
next	1.9;

1.9
date	2002.05.27.14.11.54;	author nickc;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2002.05.21.20.28.26;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.18.12.20.46;	author nickc;	state Exp;
branches
	1.7.6.1;
next	1.6;

1.6
date	2001.04.18.16.39.37;	author mrg;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.28.01.04.24;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.30.01.55.12;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.30.17.13.37;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.08.20.54.27;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.55;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.11.2.1
date	2003.03.30.16.35.25;	author cagney;	state Exp;
branches;
next	;

1.10.8.1
date	2003.04.16.19.57.07;	author carlton;	state Exp;
branches;
next	;

1.10.10.1
date	2003.12.14.20.28.16;	author drow;	state Exp;
branches;
next	;

1.9.2.1
date	2002.06.20.01.38.49;	author kseitz;	state Exp;
branches;
next	;

1.7.6.1
date	2002.06.15.16.43.22;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.55;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.02.05.07.30.18;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.16
log
@[sim] Update old contact info in GPL license notices

sim/ChangeLog:

        Update old contact info in GPL license notices.
@
text
@/*  armcopro.c -- co-processor interface:  ARM6 Instruction Emulator.
    Copyright (C) 1994, 2000 Advanced RISC Machines Ltd.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, see <http://www.gnu.org/licenses/>.  */

#include "armdefs.h"
#include "armos.h"
#include "armemu.h"
#include "ansidecl.h"
#include "iwmmxt.h"

/* Dummy Co-processors.  */

static unsigned
NoCoPro3R (ARMul_State * state ATTRIBUTE_UNUSED,
	   unsigned      a     ATTRIBUTE_UNUSED,
	   ARMword       b     ATTRIBUTE_UNUSED)
{
  return ARMul_CANT;
}

static unsigned
NoCoPro4R (ARMul_State * state ATTRIBUTE_UNUSED,
	   unsigned      a     ATTRIBUTE_UNUSED,
	   ARMword       b     ATTRIBUTE_UNUSED,
	   ARMword       c     ATTRIBUTE_UNUSED)
{
  return ARMul_CANT;
}

static unsigned
NoCoPro4W (ARMul_State * state ATTRIBUTE_UNUSED,
	   unsigned      a     ATTRIBUTE_UNUSED,
	   ARMword       b     ATTRIBUTE_UNUSED,
	   ARMword *     c     ATTRIBUTE_UNUSED)
{
  return ARMul_CANT;
}

/* The XScale Co-processors.  */

/* Coprocessor 15:  System Control.  */
static void     write_cp14_reg (unsigned, ARMword);
static ARMword  read_cp14_reg  (unsigned);

/* There are two sets of registers for copro 15.
   One set is available when opcode_2 is 0 and
   the other set when opcode_2 >= 1.  */
static ARMword XScale_cp15_opcode_2_is_0_Regs[16];
static ARMword XScale_cp15_opcode_2_is_not_0_Regs[16];
/* There are also a set of breakpoint registers
   which are accessed via CRm instead of opcode_2.  */
static ARMword XScale_cp15_DBR1;
static ARMword XScale_cp15_DBCON;
static ARMword XScale_cp15_IBCR0;
static ARMword XScale_cp15_IBCR1;

static unsigned
XScale_cp15_init (ARMul_State * state ATTRIBUTE_UNUSED)
{
  int i;

  for (i = 16; i--;)
    {
      XScale_cp15_opcode_2_is_0_Regs[i] = 0;
      XScale_cp15_opcode_2_is_not_0_Regs[i] = 0;
    }

  /* Initialise the processor ID.  */
  XScale_cp15_opcode_2_is_0_Regs[0] = 0x69052000;

  /* Initialise the cache type.  */
  XScale_cp15_opcode_2_is_not_0_Regs[0] = 0x0B1AA1AA;

  /* Initialise the ARM Control Register.  */
  XScale_cp15_opcode_2_is_0_Regs[1] = 0x00000078;
}

/* Check an access to a register.  */

static unsigned
check_cp15_access (ARMul_State * state,
		   unsigned      reg,
		   unsigned      CRm,
		   unsigned      opcode_1,
		   unsigned      opcode_2)
{
  /* Do not allow access to these register in USER mode.  */
  if (state->Mode == USER26MODE || state->Mode == USER32MODE)
    return ARMul_CANT;

  /* Opcode_1should be zero.  */
  if (opcode_1 != 0)
    return ARMul_CANT;

  /* Different register have different access requirements.  */
  switch (reg)
    {
    case 0:
    case 1:
      /* CRm must be 0.  Opcode_2 can be anything.  */
      if (CRm != 0)
	return ARMul_CANT;
      break;      
    case 2:
    case 3:
      /* CRm must be 0.  Opcode_2 must be zero.  */
      if ((CRm != 0) || (opcode_2 != 0))
	return ARMul_CANT;
      break;
    case 4:
      /* Access not allowed.  */
      return ARMul_CANT;
    case 5:
    case 6:
      /* Opcode_2 must be zero.  CRm must be 0.  */
      if ((CRm != 0) || (opcode_2 != 0))
	return ARMul_CANT;
      break;
    case 7:
      /* Permissable combinations:
	   Opcode_2  CRm
	      0       5
	      0       6
	      0       7
	      1       5
	      1       6
	      1      10
	      4      10
	      5       2
	      6       5  */
      switch (opcode_2)
	{
	default:               return ARMul_CANT;
	case 6: if (CRm !=  5) return ARMul_CANT; break;
	case 5: if (CRm !=  2) return ARMul_CANT; break;
	case 4: if (CRm != 10) return ARMul_CANT; break;
	case 1: if ((CRm != 5) && (CRm != 6) && (CRm != 10)) return ARMul_CANT; break;
	case 0: if ((CRm < 5) || (CRm > 7)) return ARMul_CANT; break;
	}
      break;

    case 8:
      /* Permissable combinations:
	   Opcode_2  CRm
	      0       5
	      0       6
	      0       7
	      1       5
	      1       6  */
      if (opcode_2 > 1)
	return ARMul_CANT;
      if ((CRm < 5) || (CRm > 7))
	return ARMul_CANT;
      if (opcode_2 == 1 && CRm == 7)
	return ARMul_CANT;
      break;
    case 9:
      /* Opcode_2 must be zero or one.  CRm must be 1 or 2.  */
      if (   ((CRm != 0) && (CRm != 1))
	  || ((opcode_2 != 1) && (opcode_2 != 2)))
	return ARMul_CANT;
      break;
    case 10:
      /* Opcode_2 must be zero or one.  CRm must be 4 or 8.  */
      if (   ((CRm != 0) && (CRm != 1))
	  || ((opcode_2 != 4) && (opcode_2 != 8)))
	return ARMul_CANT;
      break;
    case 11:
      /* Access not allowed.  */
      return ARMul_CANT;
    case 12:
      /* Access not allowed.  */
      return ARMul_CANT;
    case 13:
      /* Opcode_2 must be zero.  CRm must be 0.  */
      if ((CRm != 0) || (opcode_2 != 0))
	return ARMul_CANT;
      break;
    case 14:
      /* Opcode_2 must be 0.  CRm must be 0, 3, 4, 8 or 9.  */
      if (opcode_2 != 0)
	return ARMul_CANT;

      if ((CRm != 0) && (CRm != 3) && (CRm != 4) && (CRm != 8) && (CRm != 9))
	return ARMul_CANT;
      break;
    case 15:
      /* Opcode_2 must be zero.  CRm must be 1.  */
      if ((CRm != 1) || (opcode_2 != 0))
	return ARMul_CANT;
      break;
    default:
      /* Should never happen.  */
      return ARMul_CANT;
    }

  return ARMul_DONE;
}

/* Store a value into one of coprocessor 15's registers.  */

static void
write_cp15_reg (ARMul_State * state,
		unsigned reg,
		unsigned opcode_2,
		unsigned CRm,
		ARMword  value)
{
  if (opcode_2)
    {
      switch (reg)
	{
	case 0: /* Cache Type.  */
	  /* Writes are not allowed.  */
	  return;

	case 1: /* Auxillary Control.  */
	  /* Only BITS (5, 4) and BITS (1, 0) can be written.  */
	  value &= 0x33;
	  break;

	default:
	  return;
	}

      XScale_cp15_opcode_2_is_not_0_Regs [reg] = value;
    }
  else
    {
      switch (reg)
	{
	case 0: /* ID.  */
	  /* Writes are not allowed.  */
	  return;

	case 1: /* ARM Control.  */
	  /* Only BITS (13, 11), BITS (9, 7) and BITS (2, 0) can be written.
	     BITS (31, 14) and BIT (10) write as zero, BITS (6, 3) write as one.  */
	  value &= 0x00003b87;
	  value |= 0x00000078;

          /* Change the endianness if necessary.  */
          if ((value & ARMul_CP15_R1_ENDIAN) !=
	      (XScale_cp15_opcode_2_is_0_Regs [reg] & ARMul_CP15_R1_ENDIAN))
	    {
	      state->bigendSig = value & ARMul_CP15_R1_ENDIAN;
	      /* Force ARMulator to notice these now.  */
	      state->Emulate = CHANGEMODE;
	    }
	  break;

	case 2: /* Translation Table Base.  */
	  /* Only BITS (31, 14) can be written.  */
	  value &= 0xffffc000;
	  break;

	case 3: /* Domain Access Control.  */
	  /* All bits writable.  */
	  break;

	case 5: /* Fault Status Register.  */
	  /* BITS (10, 9) and BITS (7, 0) can be written.  */
	  value &= 0x000006ff;
	  break;

	case 6: /* Fault Address Register.  */
	  /* All bits writable.  */
	  break;

	case 7: /* Cache Functions.  */
	case 8: /* TLB Operations.  */
	case 10: /* TLB Lock Down.  */
	  /* Ignore writes.  */
	  return;

	case 9: /* Data Cache Lock.  */
	  /* Only BIT (0) can be written.  */
	  value &= 0x1;
	  break;

	case 13: /* Process ID.  */
	  /* Only BITS (31, 25) are writable.  */
	  value &= 0xfe000000;
	  break;

	case 14: /* DBR0, DBR1, DBCON, IBCR0, IBCR1 */
	  /* All bits can be written.  Which register is accessed is
	     dependent upon CRm.  */
	  switch (CRm)
	    {
	    case 0: /* DBR0 */
	      break;
	    case 3: /* DBR1 */
	      XScale_cp15_DBR1 = value;
	      break;
	    case 4: /* DBCON */
	      XScale_cp15_DBCON = value;
	      break;
	    case 8: /* IBCR0 */
	      XScale_cp15_IBCR0 = value;
	      break;
	    case 9: /* IBCR1 */
	      XScale_cp15_IBCR1 = value;
	      break;
	    default:
	      return;
	    }
	  break;

	case 15: /* Coprpcessor Access Register.  */
	  /* Access is only valid if CRm == 1.  */
	  if (CRm != 1)
	    return;

	  /* Only BITS (13, 0) may be written.  */
	  value &= 0x00003fff;
	  break;

	default:
	  return;
	}

      XScale_cp15_opcode_2_is_0_Regs [reg] = value;
    }

  return;
}

/* Return the value in a cp15 register.  */

ARMword
read_cp15_reg (unsigned reg, unsigned opcode_2, unsigned CRm)
{
  if (opcode_2 == 0)
    {
      if (reg == 15 && CRm != 1)
	return 0;

      if (reg == 14)
	{
	  switch (CRm)
	    {
	    case 3: return XScale_cp15_DBR1;
	    case 4: return XScale_cp15_DBCON;
	    case 8: return XScale_cp15_IBCR0;
	    case 9: return XScale_cp15_IBCR1;
	    default:
	      break;
	    }
	}

      return XScale_cp15_opcode_2_is_0_Regs [reg];
    }
  else
    return XScale_cp15_opcode_2_is_not_0_Regs [reg];

  return 0;
}

static unsigned
XScale_cp15_LDC (ARMul_State * state, unsigned type, ARMword instr, ARMword data)
{
  unsigned reg = BITS (12, 15);
  unsigned result;
  
  result = check_cp15_access (state, reg, 0, 0, 0);

  if (result == ARMul_DONE && type == ARMul_DATA)
    write_cp15_reg (state, reg, 0, 0, data);

  return result;
}

static unsigned
XScale_cp15_STC (ARMul_State * state, unsigned type, ARMword instr, ARMword * data)
{
  unsigned reg = BITS (12, 15);
  unsigned result;

  result = check_cp15_access (state, reg, 0, 0, 0);

  if (result == ARMul_DONE && type == ARMul_DATA)
    * data = read_cp15_reg (reg, 0, 0);

  return result;
}

static unsigned
XScale_cp15_MRC (ARMul_State * state,
		 unsigned      type ATTRIBUTE_UNUSED,
		 ARMword       instr,
		 ARMword *     value)
{
  unsigned opcode_2 = BITS (5, 7);
  unsigned CRm = BITS (0, 3);
  unsigned reg = BITS (16, 19);
  unsigned result;

  result = check_cp15_access (state, reg, CRm, BITS (21, 23), opcode_2);

  if (result == ARMul_DONE)
    * value = read_cp15_reg (reg, opcode_2, CRm);

  return result;
}

static unsigned
XScale_cp15_MCR (ARMul_State * state,
		 unsigned      type ATTRIBUTE_UNUSED,
		 ARMword       instr,
		 ARMword       value)
{
  unsigned opcode_2 = BITS (5, 7);
  unsigned CRm = BITS (0, 3);
  unsigned reg = BITS (16, 19);
  unsigned result;

  result = check_cp15_access (state, reg, CRm, BITS (21, 23), opcode_2);

  if (result == ARMul_DONE)
    write_cp15_reg (state, reg, opcode_2, CRm, value);

  return result;
}

static unsigned
XScale_cp15_read_reg (ARMul_State * state ATTRIBUTE_UNUSED,
		      unsigned      reg,
		      ARMword *     value)
{
  /* FIXME: Not sure what to do about the alternative register set
     here.  For now default to just accessing CRm == 0 registers.  */
  * value = read_cp15_reg (reg, 0, 0);

  return TRUE;
}

static unsigned
XScale_cp15_write_reg (ARMul_State * state ATTRIBUTE_UNUSED,
		       unsigned      reg,
		       ARMword       value)
{
  /* FIXME: Not sure what to do about the alternative register set
     here.  For now default to just accessing CRm == 0 registers.  */
  write_cp15_reg (state, reg, 0, 0, value);

  return TRUE;
}

/* Check for special XScale memory access features.  */

void
XScale_check_memacc (ARMul_State * state, ARMword * address, int store)
{
  ARMword dbcon, r0, r1;
  int e1, e0;

  if (!state->is_XScale)
    return;

  /* Check for PID-ification.
     XXX BTB access support will require this test failing.  */
  r0 = (read_cp15_reg (13, 0, 0) & 0xfe000000);
  if (r0 && (* address & 0xfe000000) == 0)
    * address |= r0;

  /* Check alignment fault enable/disable.  */
  if ((read_cp15_reg (1, 0, 0) & ARMul_CP15_R1_ALIGN) && (* address & 3))
    {
      /* Set the FSR and FAR.
	 Do not use XScale_set_fsr_far as this checks the DCSR register.  */
      write_cp15_reg (state, 5, 0, 0, ARMul_CP15_R5_MMU_EXCPT);
      write_cp15_reg (state, 6, 0, 0, * address);

      ARMul_Abort (state, ARMul_DataAbortV);
    }

  if (XScale_debug_moe (state, -1))
    return;

  /* Check the data breakpoint registers.  */
  dbcon = read_cp15_reg (14, 0, 4);
  r0 = read_cp15_reg (14, 0, 0);
  r1 = read_cp15_reg (14, 0, 3);
  e0 = dbcon & ARMul_CP15_DBCON_E0;

  if (dbcon & ARMul_CP15_DBCON_M)
    {
      /* r1 is a inverse mask.  */
      if (e0 != 0 && ((store && e0 != 3) || (!store && e0 != 1))
          && ((* address & ~r1) == (r0 & ~r1)))
	{
          XScale_debug_moe (state, ARMul_CP14_R10_MOE_DB);
          ARMul_OSHandleSWI (state, SWI_Breakpoint);
	}
    }
  else
    {
      if (e0 != 0 && ((store && e0 != 3) || (!store && e0 != 1))
              && ((* address & ~3) == (r0 & ~3)))
	{
          XScale_debug_moe (state, ARMul_CP14_R10_MOE_DB);
          ARMul_OSHandleSWI (state, SWI_Breakpoint);
	}

      e1 = (dbcon & ARMul_CP15_DBCON_E1) >> 2;
      if (e1 != 0 && ((store && e1 != 3) || (!store && e1 != 1))
              && ((* address & ~3) == (r1 & ~3)))
	{
          XScale_debug_moe (state, ARMul_CP14_R10_MOE_DB);
          ARMul_OSHandleSWI (state, SWI_Breakpoint);
	}
    }
}

/* Set the XScale FSR and FAR registers.  */

void
XScale_set_fsr_far (ARMul_State * state, ARMword fsr, ARMword far)
{
  if (!state->is_XScale || (read_cp14_reg (10) & (1UL << 31)) == 0)
    return;

  write_cp15_reg (state, 5, 0, 0, fsr);
  write_cp15_reg (state, 6, 0, 0, far);
}

/* Set the XScale debug `method of entry' if it is enabled.  */

int
XScale_debug_moe (ARMul_State * state, int moe)
{
  ARMword value;

  if (!state->is_XScale)
    return 1;

  value = read_cp14_reg (10);
  if (value & (1UL << 31))
    {
      if (moe != -1)
	{
          value &= ~0x1c;
          value |= moe;
	
          write_cp14_reg (10, value);
	}
      return 1;
    }
  return 0;
}

/* Coprocessor 13:  Interrupt Controller and Bus Controller.  */

/* There are two sets of registers for copro 13.
   One set (of three registers) is available when CRm is 0
   and the other set (of six registers) when CRm is 1.  */

static ARMword XScale_cp13_CR0_Regs[16];
static ARMword XScale_cp13_CR1_Regs[16];

static unsigned
XScale_cp13_init (ARMul_State * state ATTRIBUTE_UNUSED)
{
  int i;

  for (i = 16; i--;)
    {
      XScale_cp13_CR0_Regs[i] = 0;
      XScale_cp13_CR1_Regs[i] = 0;
    }
}

/* Check an access to a register.  */

static unsigned
check_cp13_access (ARMul_State * state,
		   unsigned      reg,
		   unsigned      CRm,
		   unsigned      opcode_1,
		   unsigned      opcode_2)
{
  /* Do not allow access to these registers in USER mode.  */
  if (state->Mode == USER26MODE || state->Mode == USER32MODE)
    return ARMul_CANT;

  /* The opcodes should be zero.  */
  if ((opcode_1 != 0) || (opcode_2 != 0))
    return ARMul_CANT;

  /* Do not allow access to these register if bit
     13 of coprocessor 15's register 15 is zero.  */
  if (! CP_ACCESS_ALLOWED (state, 13))
    return ARMul_CANT;

  /* Registers 0, 4 and 8 are defined when CRm == 0.
     Registers 0, 1, 4, 5, 6, 7, 8 are defined when CRm == 1.
     For all other CRm values undefined behaviour results.  */
  if (CRm == 0)
    {
      if (reg == 0 || reg == 4 || reg == 8)
	return ARMul_DONE;
    }
  else if (CRm == 1)
    {
      if (reg == 0 || reg == 1 || (reg >= 4 && reg <= 8))
	return ARMul_DONE;
    }

  return ARMul_CANT;
}

/* Store a value into one of coprocessor 13's registers.  */

static void
write_cp13_reg (unsigned reg, unsigned CRm, ARMword value)
{
  switch (CRm)
    {
    case 0:
      switch (reg)
	{
	case 0: /* INTCTL */
	  /* Only BITS (3:0) can be written.  */
	  value &= 0xf;
	  break;

	case 4: /* INTSRC */
	  /* No bits may be written.  */
	  return;

	case 8: /* INTSTR */
	  /* Only BITS (1:0) can be written.  */
	  value &= 0x3;
	  break;

	default:
	  /* Should not happen.  Ignore any writes to unimplemented registers.  */
	  return;
	}

      XScale_cp13_CR0_Regs [reg] = value;
      break;

    case 1:
      switch (reg)
	{
	case 0: /* BCUCTL */
	  /* Only BITS (30:28) and BITS (3:0) can be written.
	     BIT(31) is write ignored.  */
	  value &= 0x7000000f;
	  value |= XScale_cp13_CR1_Regs[0] & (1UL << 31);
	  break;

	case 1: /* BCUMOD */
	  /* Only bit 0 is accecssible.  */
	  value &= 1;
	  value |= XScale_cp13_CR1_Regs[1] & ~ 1;
	  break;

	case 4: /* ELOG0 */
	case 5: /* ELOG1 */
	case 6: /* ECAR0 */
	case 7: /* ECAR1 */
	  /* No bits can be written.  */
	  return;

	case 8: /* ECTST */
	  /* Only BITS (7:0) can be written.  */
	  value &= 0xff;
	  break;

	default:
	  /* Should not happen.  Ignore any writes to unimplemented registers.  */
	  return;
	}

      XScale_cp13_CR1_Regs [reg] = value;
      break;

    default:
      /* Should not happen.  */
      break;
    }

  return;
}

/* Return the value in a cp13 register.  */

static ARMword
read_cp13_reg (unsigned reg, unsigned CRm)
{
  if (CRm == 0)
    return XScale_cp13_CR0_Regs [reg];
  else if (CRm == 1)
    return XScale_cp13_CR1_Regs [reg];

  return 0;
}

static unsigned
XScale_cp13_LDC (ARMul_State * state, unsigned type, ARMword instr, ARMword data)
{
  unsigned reg = BITS (12, 15);
  unsigned result;

  result = check_cp13_access (state, reg, 0, 0, 0);

  if (result == ARMul_DONE && type == ARMul_DATA)
    write_cp13_reg (reg, 0, data);

  return result;
}

static unsigned
XScale_cp13_STC (ARMul_State * state, unsigned type, ARMword instr, ARMword * data)
{
  unsigned reg = BITS (12, 15);
  unsigned result;

  result = check_cp13_access (state, reg, 0, 0, 0);

  if (result == ARMul_DONE && type == ARMul_DATA)
    * data = read_cp13_reg (reg, 0);

  return result;
}

static unsigned
XScale_cp13_MRC (ARMul_State * state,
		 unsigned      type ATTRIBUTE_UNUSED,
		 ARMword       instr,
		 ARMword *     value)
{
  unsigned CRm = BITS (0, 3);
  unsigned reg = BITS (16, 19);
  unsigned result;

  result = check_cp13_access (state, reg, CRm, BITS (21, 23), BITS (5, 7));

  if (result == ARMul_DONE)
    * value = read_cp13_reg (reg, CRm);

  return result;
}

static unsigned
XScale_cp13_MCR (ARMul_State * state,
		 unsigned      type ATTRIBUTE_UNUSED,
		 ARMword       instr,
		 ARMword       value)
{
  unsigned CRm = BITS (0, 3);
  unsigned reg = BITS (16, 19);
  unsigned result;

  result = check_cp13_access (state, reg, CRm, BITS (21, 23), BITS (5, 7));

  if (result == ARMul_DONE)
    write_cp13_reg (reg, CRm, value);

  return result;
}

static unsigned
XScale_cp13_read_reg (ARMul_State * state ATTRIBUTE_UNUSED,
		      unsigned      reg,
		      ARMword *     value)
{
  /* FIXME: Not sure what to do about the alternative register set
     here.  For now default to just accessing CRm == 0 registers.  */
  * value = read_cp13_reg (reg, 0);

  return TRUE;
}

static unsigned
XScale_cp13_write_reg (ARMul_State * state ATTRIBUTE_UNUSED,
		       unsigned      reg,
		       ARMword       value)
{
  /* FIXME: Not sure what to do about the alternative register set
     here.  For now default to just accessing CRm == 0 registers.  */
  write_cp13_reg (reg, 0, value);

  return TRUE;
}

/* Coprocessor 14:  Performance Monitoring,  Clock and Power management,
   Software Debug.  */

static ARMword XScale_cp14_Regs[16];

static unsigned
XScale_cp14_init (ARMul_State * state ATTRIBUTE_UNUSED)
{
  int i;

  for (i = 16; i--;)
    XScale_cp14_Regs[i] = 0;
}

/* Check an access to a register.  */

static unsigned
check_cp14_access (ARMul_State * state,
		   unsigned      reg,
		   unsigned      CRm,
		   unsigned      opcode1,
		   unsigned      opcode2)
{
  /* Not allowed to access these register in USER mode.  */
  if (state->Mode == USER26MODE || state->Mode == USER32MODE)
    return ARMul_CANT;

  /* CRm should be zero.  */
  if (CRm != 0)
    return ARMul_CANT;

  /* OPcodes should be zero.  */
  if (opcode1 != 0 || opcode2 != 0)
    return ARMul_CANT;

  /* Accessing registers 4 or 5 has unpredicatable results.  */
  if (reg >= 4 && reg <= 5)
    return ARMul_CANT;

  return ARMul_DONE;
}

/* Store a value into one of coprocessor 14's registers.  */

static void
write_cp14_reg (unsigned reg, ARMword value)
{
  switch (reg)
    {
    case 0: /* PMNC */
      /* Only BITS (27:12), BITS (10:8) and BITS (6:0) can be written.  */
      value &= 0x0ffff77f;

      /* Reset the clock counter if necessary.  */
      if (value & ARMul_CP14_R0_CLKRST)
        XScale_cp14_Regs [1] = 0;
      break;

    case 4:
    case 5:
      /* We should not normally reach this code.  The debugger interface
	 can bypass the normal checks though, so it could happen.  */
      value = 0;
      break;

    case 6: /* CCLKCFG */
      /* Only BITS (3:0) can be written.  */
      value &= 0xf;
      break;

    case 7: /* PWRMODE */
      /* Although BITS (1:0) can be written with non-zero values, this would
	 have the side effect of putting the processor to sleep.  Thus in
	 order for the register to be read again, it would have to go into
	 ACTIVE mode, which means that any read will see these bits as zero.

	 Rather than trying to implement complex reset-to-zero-upon-read logic
	 we just override the write value with zero.  */
      value = 0;
      break;

    case 10: /* DCSR */
      /* Only BITS (31:30), BITS (23:22), BITS (20:16) and BITS (5:0) can
	 be written.  */
      value &= 0xc0df003f;
      break;

    case 11: /* TBREG */
      /* No writes are permitted.  */
      value = 0;
      break;

    case 14: /* TXRXCTRL */
      /* Only BITS (31:30) can be written.  */
      value &= 0xc0000000;
      break;

    default:
      /* All bits can be written.  */
      break;
    }

  XScale_cp14_Regs [reg] = value;
}

/* Return the value in a cp14 register.  Not a static function since
   it is used by the code to emulate the BKPT instruction in armemu.c.  */

ARMword
read_cp14_reg (unsigned reg)
{
  return XScale_cp14_Regs [reg];
}

static unsigned
XScale_cp14_LDC (ARMul_State * state, unsigned type, ARMword instr, ARMword data)
{
  unsigned reg = BITS (12, 15);
  unsigned result;

  result = check_cp14_access (state, reg, 0, 0, 0);

  if (result == ARMul_DONE && type == ARMul_DATA)
    write_cp14_reg (reg, data);

  return result;
}

static unsigned
XScale_cp14_STC (ARMul_State * state, unsigned type, ARMword instr, ARMword * data)
{
  unsigned reg = BITS (12, 15);
  unsigned result;

  result = check_cp14_access (state, reg, 0, 0, 0);

  if (result == ARMul_DONE && type == ARMul_DATA)
    * data = read_cp14_reg (reg);

  return result;
}

static unsigned
XScale_cp14_MRC
(
 ARMul_State * state,
 unsigned      type ATTRIBUTE_UNUSED,
 ARMword       instr,
 ARMword *     value
)
{
  unsigned reg = BITS (16, 19);
  unsigned result;

  result = check_cp14_access (state, reg, BITS (0, 3), BITS (21, 23), BITS (5, 7));

  if (result == ARMul_DONE)
    * value = read_cp14_reg (reg);

  return result;
}

static unsigned
XScale_cp14_MCR
(
 ARMul_State * state,
 unsigned      type ATTRIBUTE_UNUSED,
 ARMword       instr,
 ARMword       value
)
{
  unsigned reg = BITS (16, 19);
  unsigned result;

  result = check_cp14_access (state, reg, BITS (0, 3), BITS (21, 23), BITS (5, 7));

  if (result == ARMul_DONE)
    write_cp14_reg (reg, value);

  return result;
}

static unsigned
XScale_cp14_read_reg
(
 ARMul_State * state ATTRIBUTE_UNUSED,
 unsigned      reg,
 ARMword *     value
)
{
  * value = read_cp14_reg (reg);

  return TRUE;
}

static unsigned
XScale_cp14_write_reg
(
 ARMul_State * state ATTRIBUTE_UNUSED,
 unsigned      reg,
 ARMword       value
)
{
  write_cp14_reg (reg, value);

  return TRUE;
}

/* Here's ARMulator's MMU definition.  A few things to note:
   1) It has eight registers, but only two are defined.
   2) You can only access its registers with MCR and MRC.
   3) MMU Register 0 (ID) returns 0x41440110
   4) Register 1 only has 4 bits defined.  Bits 0 to 3 are unused, bit 4
      controls 32/26 bit program space, bit 5 controls 32/26 bit data space,
      bit 6 controls late abort timimg and bit 7 controls big/little endian.  */

static ARMword MMUReg[8];

static unsigned
MMUInit (ARMul_State * state)
{
  MMUReg[1] = state->prog32Sig << 4 |
    state->data32Sig << 5 | state->lateabtSig << 6 | state->bigendSig << 7;

  ARMul_ConsolePrint (state, ", MMU present");

  return TRUE;
}

static unsigned
MMUMRC (ARMul_State * state ATTRIBUTE_UNUSED,
	unsigned      type ATTRIBUTE_UNUSED,
	ARMword       instr,
	ARMword *     value)
{
  int reg = BITS (16, 19) & 7;

  if (reg == 0)
    *value = 0x41440110;
  else
    *value = MMUReg[reg];

  return ARMul_DONE;
}

static unsigned
MMUMCR (ARMul_State * state,
	unsigned      type ATTRIBUTE_UNUSED,
	ARMword       instr,
	ARMword       value)
{
  int reg = BITS (16, 19) & 7;

  MMUReg[reg] = value;

  if (reg == 1)
    {
      ARMword p,d,l,b;

      p = state->prog32Sig;
      d = state->data32Sig;
      l = state->lateabtSig;
      b = state->bigendSig;

      state->prog32Sig  = value >> 4 & 1;
      state->data32Sig  = value >> 5 & 1;
      state->lateabtSig = value >> 6 & 1;
      state->bigendSig  = value >> 7 & 1;

      if (   p != state->prog32Sig
	  || d != state->data32Sig
	  || l != state->lateabtSig
	  || b != state->bigendSig)
	/* Force ARMulator to notice these now.  */
	state->Emulate = CHANGEMODE;
    }

  return ARMul_DONE;
}

static unsigned
MMURead (ARMul_State * state ATTRIBUTE_UNUSED, unsigned reg, ARMword * value)
{
  if (reg == 0)
    *value = 0x41440110;
  else if (reg < 8)
    *value = MMUReg[reg];

  return TRUE;
}

static unsigned
MMUWrite (ARMul_State * state, unsigned reg, ARMword value)
{
  if (reg < 8)
    MMUReg[reg] = value;

  if (reg == 1)
    {
      ARMword p,d,l,b;

      p = state->prog32Sig;
      d = state->data32Sig;
      l = state->lateabtSig;
      b = state->bigendSig;

      state->prog32Sig  = value >> 4 & 1;
      state->data32Sig  = value >> 5 & 1;
      state->lateabtSig = value >> 6 & 1;
      state->bigendSig  = value >> 7 & 1;

      if (   p != state->prog32Sig
	  || d != state->data32Sig
	  || l != state->lateabtSig
	  || b != state->bigendSig)
	/* Force ARMulator to notice these now.  */	
	state->Emulate = CHANGEMODE;
    }

  return TRUE;
}


/* What follows is the Validation Suite Coprocessor.  It uses two
   co-processor numbers (4 and 5) and has the follwing functionality.
   Sixteen registers.  Both co-processor nuimbers can be used in an MCR
   and MRC to access these registers.  CP 4 can LDC and STC to and from
   the registers.  CP 4 and CP 5 CDP 0 will busy wait for the number of
   cycles specified by a CP register.  CP 5 CDP 1 issues a FIQ after a
   number of cycles (specified in a CP register), CDP 2 issues an IRQW
   in the same way, CDP 3 and 4 turn of the FIQ and IRQ source, and CDP 5
   stores a 32 bit time value in a CP register (actually it's the total
   number of N, S, I, C and F cyles).  */

static ARMword ValReg[16];

static unsigned
ValLDC (ARMul_State * state ATTRIBUTE_UNUSED,
	unsigned      type,
	ARMword       instr,
	ARMword        data)
{
  static unsigned words;

  if (type != ARMul_DATA)
    words = 0;
  else
    {
      ValReg[BITS (12, 15)] = data;

      if (BIT (22))
	/* It's a long access, get two words.  */
	if (words++ != 4)
	  return ARMul_INC;
    }

  return ARMul_DONE;
}

static unsigned
ValSTC (ARMul_State * state ATTRIBUTE_UNUSED,
	unsigned      type,
	ARMword       instr,
	ARMword *     data)
{
  static unsigned words;

  if (type != ARMul_DATA)
    words = 0;
  else
    {
      * data = ValReg[BITS (12, 15)];

      if (BIT (22))
	/* It's a long access, get two words.  */
	if (words++ != 4)
	  return ARMul_INC;
    }

  return ARMul_DONE;
}

static unsigned
ValMRC (ARMul_State * state ATTRIBUTE_UNUSED,
	unsigned      type  ATTRIBUTE_UNUSED,
	ARMword       instr,
	ARMword *     value)
{
  *value = ValReg[BITS (16, 19)];

  return ARMul_DONE;
}

static unsigned
ValMCR (ARMul_State * state ATTRIBUTE_UNUSED,
	unsigned      type  ATTRIBUTE_UNUSED,
	ARMword       instr,
	ARMword       value)
{
  ValReg[BITS (16, 19)] = value;

  return ARMul_DONE;
}

static unsigned
ValCDP (ARMul_State * state, unsigned type, ARMword instr)
{
  static unsigned long finish = 0;

  if (BITS (20, 23) != 0)
    return ARMul_CANT;

  if (type == ARMul_FIRST)
    {
      ARMword howlong;

      howlong = ValReg[BITS (0, 3)];

      /* First cycle of a busy wait.  */
      finish = ARMul_Time (state) + howlong;

      return howlong == 0 ? ARMul_DONE : ARMul_BUSY;
    }
  else if (type == ARMul_BUSY)
    {
      if (ARMul_Time (state) >= finish)
	return ARMul_DONE;
      else
	return ARMul_BUSY;
    }

  return ARMul_CANT;
}

static unsigned
DoAFIQ (ARMul_State * state)
{
  state->NfiqSig = LOW;
  state->Exception++;
  return 0;
}

static unsigned
DoAIRQ (ARMul_State * state)
{
  state->NirqSig = LOW;
  state->Exception++;
  return 0;
}

static unsigned
IntCDP (ARMul_State * state, unsigned type, ARMword instr)
{
  static unsigned long finish;
  ARMword howlong;

  howlong = ValReg[BITS (0, 3)];

  switch ((int) BITS (20, 23))
    {
    case 0:
      if (type == ARMul_FIRST)
	{
	  /* First cycle of a busy wait.  */
	  finish = ARMul_Time (state) + howlong;

	  return howlong == 0 ? ARMul_DONE : ARMul_BUSY;
	}
      else if (type == ARMul_BUSY)
	{
	  if (ARMul_Time (state) >= finish)
	    return ARMul_DONE;
	  else
	    return ARMul_BUSY;
	}
      return ARMul_DONE;

    case 1:
      if (howlong == 0)
	ARMul_Abort (state, ARMul_FIQV);
      else
	ARMul_ScheduleEvent (state, howlong, DoAFIQ);
      return ARMul_DONE;

    case 2:
      if (howlong == 0)
	ARMul_Abort (state, ARMul_IRQV);
      else
	ARMul_ScheduleEvent (state, howlong, DoAIRQ);
      return ARMul_DONE;

    case 3:
      state->NfiqSig = HIGH;
      state->Exception--;
      return ARMul_DONE;

    case 4:
      state->NirqSig = HIGH;
      state->Exception--;
      return ARMul_DONE;

    case 5:
      ValReg[BITS (0, 3)] = ARMul_Time (state);
      return ARMul_DONE;
    }

  return ARMul_CANT;
}

/* Install co-processor instruction handlers in this routine.  */

unsigned
ARMul_CoProInit (ARMul_State * state)
{
  unsigned int i;

  /* Initialise tham all first.  */
  for (i = 0; i < 16; i++)
    ARMul_CoProDetach (state, i);

  /* Install CoPro Instruction handlers here.
     The format is:
     ARMul_CoProAttach (state, CP Number, Init routine, Exit routine
                        LDC routine, STC routine, MRC routine, MCR routine,
                        CDP routine, Read Reg routine, Write Reg routine).  */
  if (state->is_ep9312)
    {
      ARMul_CoProAttach (state, 4, NULL, NULL, DSPLDC4, DSPSTC4,
			 DSPMRC4, DSPMCR4, DSPCDP4, NULL, NULL);
      ARMul_CoProAttach (state, 5, NULL, NULL, DSPLDC5, DSPSTC5,
			 DSPMRC5, DSPMCR5, DSPCDP5, NULL, NULL);
      ARMul_CoProAttach (state, 6, NULL, NULL, NULL, NULL,
			 DSPMRC6, DSPMCR6, DSPCDP6, NULL, NULL);
    }
  else
    {
      ARMul_CoProAttach (state, 4, NULL, NULL, ValLDC, ValSTC,
			 ValMRC, ValMCR, ValCDP, NULL, NULL);

      ARMul_CoProAttach (state, 5, NULL, NULL, NULL, NULL,
			 ValMRC, ValMCR, IntCDP, NULL, NULL);
    }

  if (state->is_XScale)
    {
      ARMul_CoProAttach (state, 13, XScale_cp13_init, NULL,
			 XScale_cp13_LDC, XScale_cp13_STC, XScale_cp13_MRC,
			 XScale_cp13_MCR, NULL, XScale_cp13_read_reg,
			 XScale_cp13_write_reg);

      ARMul_CoProAttach (state, 14, XScale_cp14_init, NULL,
			 XScale_cp14_LDC, XScale_cp14_STC, XScale_cp14_MRC,
			 XScale_cp14_MCR, NULL, XScale_cp14_read_reg,
			 XScale_cp14_write_reg);

      ARMul_CoProAttach (state, 15, XScale_cp15_init, NULL,
			 NULL, NULL, XScale_cp15_MRC, XScale_cp15_MCR,
			 NULL, XScale_cp15_read_reg, XScale_cp15_write_reg);
    }
  else
    {
      ARMul_CoProAttach (state, 15, MMUInit, NULL, NULL, NULL,
			 MMUMRC, MMUMCR, NULL, MMURead, MMUWrite);
    }

  if (state->is_iWMMXt)
    {
      ARMul_CoProAttach (state, 0, NULL, NULL, IwmmxtLDC, IwmmxtSTC,
			 NULL, NULL, IwmmxtCDP, NULL, NULL);

      ARMul_CoProAttach (state, 1, NULL, NULL, NULL, NULL,
			 IwmmxtMRC, IwmmxtMCR, IwmmxtCDP, NULL, NULL);
    }

  /* No handlers below here.  */

  /* Call all the initialisation routines.  */
  for (i = 0; i < 16; i++)
    if (state->CPInit[i])
      (state->CPInit[i]) (state);

  return TRUE;
}

/* Install co-processor finalisation routines in this routine.  */

void
ARMul_CoProExit (ARMul_State * state)
{
  register unsigned i;

  for (i = 0; i < 16; i++)
    if (state->CPExit[i])
      (state->CPExit[i]) (state);

  for (i = 0; i < 16; i++)	/* Detach all handlers.  */
    ARMul_CoProDetach (state, i);
}

/* Routines to hook Co-processors into ARMulator.  */

void
ARMul_CoProAttach (ARMul_State *    state,
		   unsigned         number,
		   ARMul_CPInits *  init,
		   ARMul_CPExits *  exit,
		   ARMul_LDCs *     ldc,
		   ARMul_STCs *     stc,
		   ARMul_MRCs *     mrc,
		   ARMul_MCRs *     mcr,
		   ARMul_CDPs *     cdp,
		   ARMul_CPReads *  read,
		   ARMul_CPWrites * write)
{
  if (init != NULL)
    state->CPInit[number] = init;
  if (exit != NULL)
    state->CPExit[number] = exit;
  if (ldc != NULL)
    state->LDC[number] = ldc;
  if (stc != NULL)
    state->STC[number] = stc;
  if (mrc != NULL)
    state->MRC[number] = mrc;
  if (mcr != NULL)
    state->MCR[number] = mcr;
  if (cdp != NULL)
    state->CDP[number] = cdp;
  if (read != NULL)
    state->CPRead[number] = read;
  if (write != NULL)
    state->CPWrite[number] = write;
}

void
ARMul_CoProDetach (ARMul_State * state, unsigned number)
{
  ARMul_CoProAttach (state, number, NULL, NULL,
		     NoCoPro4R, NoCoPro4W, NoCoPro4W, NoCoPro4R,
		     NoCoPro3R, NULL, NULL);

  state->CPInit[number] = NULL;
  state->CPExit[number] = NULL;
  state->CPRead[number] = NULL;
  state->CPWrite[number] = NULL;
}
@


1.15
log
@Update sim copyright headers from GPLv2-or-later to GPLv3-or-later.

gdb/sim/ChangeLog:

        Update the non-FSF-copyrighted files in sim to GPLv3 or later.
@
text
@d15 1
a15 2
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.14
log
@Update the address of the FSF organization
@
text
@d6 1
a6 1
    the Free Software Foundation; either version 2 of the License, or
@


1.13
log
@Remove use of __IWMMXT__.
@
text
@d16 1
a16 1
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.12
log
@Add iWMMXt support to ARM simulator
@
text
@a21 1
#ifdef __IWMMXT__
a22 1
#endif
a1368 1
#ifdef __IWMMXT__
d1377 1
a1377 1
#endif
@


1.11
log
@Add Cirrus Maverick support to arm simulator
@
text
@d22 3
d1371 10
@


1.11.2.1
log
@Merge with mainline.
@
text
@a21 1
#include "iwmmxt.h"
a1365 9
    }

  if (state->is_iWMMXt)
    {
      ARMul_CoProAttach (state, 0, NULL, NULL, IwmmxtLDC, IwmmxtSTC,
			 NULL, NULL, IwmmxtCDP, NULL, NULL);

      ARMul_CoProAttach (state, 1, NULL, NULL, NULL, NULL,
			 IwmmxtMRC, IwmmxtMCR, IwmmxtCDP, NULL, NULL);
@


1.10
log
@Set the FSR and FAR registers if a Data Abort is detected.
@
text
@d1325 16
a1340 8
     ARMul_CoProAttach (state, CP Number,
                        Init routine, Exit routine
                        LDC routine, STC routine,
			MRC routine, MCR routine,
                        CDP routine,
			Read Reg routine, Write Reg routine).  */
  ARMul_CoProAttach (state, 4, NULL, NULL,
		     ValLDC, ValSTC, ValMRC, ValMCR, ValCDP, NULL, NULL);
d1342 3
a1344 2
  ARMul_CoProAttach (state, 5, NULL, NULL,
		     NULL, NULL, ValMRC, ValMCR, IntCDP, NULL, NULL);
d1346 6
a1351 2
  ARMul_CoProAttach (state, 15, MMUInit, NULL,
		     NULL, NULL, MMUMRC, MMUMCR, NULL, MMURead, MMUWrite);
d1353 4
a1356 4
  ARMul_CoProAttach (state, 13, XScale_cp13_init, NULL,
		     XScale_cp13_LDC, XScale_cp13_STC, XScale_cp13_MRC,
		     XScale_cp13_MCR, NULL, XScale_cp13_read_reg,
		     XScale_cp13_write_reg);
d1358 9
a1366 8
  ARMul_CoProAttach (state, 14, XScale_cp14_init, NULL,
		     XScale_cp14_LDC, XScale_cp14_STC, XScale_cp14_MRC,
		     XScale_cp14_MCR, NULL, XScale_cp14_read_reg,
		     XScale_cp14_write_reg);

  ARMul_CoProAttach (state, 15, XScale_cp15_init, NULL,
		     NULL, NULL, XScale_cp15_MRC, XScale_cp15_MCR,
		     NULL, XScale_cp15_read_reg, XScale_cp15_write_reg);
@


1.10.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a21 1
#include "iwmmxt.h"
d1325 28
a1352 51
     ARMul_CoProAttach (state, CP Number, Init routine, Exit routine
                        LDC routine, STC routine, MRC routine, MCR routine,
                        CDP routine, Read Reg routine, Write Reg routine).  */
  if (state->is_ep9312)
    {
      ARMul_CoProAttach (state, 4, NULL, NULL, DSPLDC4, DSPSTC4,
			 DSPMRC4, DSPMCR4, DSPCDP4, NULL, NULL);
      ARMul_CoProAttach (state, 5, NULL, NULL, DSPLDC5, DSPSTC5,
			 DSPMRC5, DSPMCR5, DSPCDP5, NULL, NULL);
      ARMul_CoProAttach (state, 6, NULL, NULL, NULL, NULL,
			 DSPMRC6, DSPMCR6, DSPCDP6, NULL, NULL);
    }
  else
    {
      ARMul_CoProAttach (state, 4, NULL, NULL, ValLDC, ValSTC,
			 ValMRC, ValMCR, ValCDP, NULL, NULL);

      ARMul_CoProAttach (state, 5, NULL, NULL, NULL, NULL,
			 ValMRC, ValMCR, IntCDP, NULL, NULL);
    }

  if (state->is_XScale)
    {
      ARMul_CoProAttach (state, 13, XScale_cp13_init, NULL,
			 XScale_cp13_LDC, XScale_cp13_STC, XScale_cp13_MRC,
			 XScale_cp13_MCR, NULL, XScale_cp13_read_reg,
			 XScale_cp13_write_reg);

      ARMul_CoProAttach (state, 14, XScale_cp14_init, NULL,
			 XScale_cp14_LDC, XScale_cp14_STC, XScale_cp14_MRC,
			 XScale_cp14_MCR, NULL, XScale_cp14_read_reg,
			 XScale_cp14_write_reg);

      ARMul_CoProAttach (state, 15, XScale_cp15_init, NULL,
			 NULL, NULL, XScale_cp15_MRC, XScale_cp15_MCR,
			 NULL, XScale_cp15_read_reg, XScale_cp15_write_reg);
    }
  else
    {
      ARMul_CoProAttach (state, 15, MMUInit, NULL, NULL, NULL,
			 MMUMRC, MMUMCR, NULL, MMURead, MMUWrite);
    }

  if (state->is_iWMMXt)
    {
      ARMul_CoProAttach (state, 0, NULL, NULL, IwmmxtLDC, IwmmxtSTC,
			 NULL, NULL, IwmmxtCDP, NULL, NULL);

      ARMul_CoProAttach (state, 1, NULL, NULL, NULL, NULL,
			 IwmmxtMRC, IwmmxtMCR, IwmmxtCDP, NULL, NULL);
    }
@


1.10.8.1
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a21 1
#include "iwmmxt.h"
d1325 28
a1352 51
     ARMul_CoProAttach (state, CP Number, Init routine, Exit routine
                        LDC routine, STC routine, MRC routine, MCR routine,
                        CDP routine, Read Reg routine, Write Reg routine).  */
  if (state->is_ep9312)
    {
      ARMul_CoProAttach (state, 4, NULL, NULL, DSPLDC4, DSPSTC4,
			 DSPMRC4, DSPMCR4, DSPCDP4, NULL, NULL);
      ARMul_CoProAttach (state, 5, NULL, NULL, DSPLDC5, DSPSTC5,
			 DSPMRC5, DSPMCR5, DSPCDP5, NULL, NULL);
      ARMul_CoProAttach (state, 6, NULL, NULL, NULL, NULL,
			 DSPMRC6, DSPMCR6, DSPCDP6, NULL, NULL);
    }
  else
    {
      ARMul_CoProAttach (state, 4, NULL, NULL, ValLDC, ValSTC,
			 ValMRC, ValMCR, ValCDP, NULL, NULL);

      ARMul_CoProAttach (state, 5, NULL, NULL, NULL, NULL,
			 ValMRC, ValMCR, IntCDP, NULL, NULL);
    }

  if (state->is_XScale)
    {
      ARMul_CoProAttach (state, 13, XScale_cp13_init, NULL,
			 XScale_cp13_LDC, XScale_cp13_STC, XScale_cp13_MRC,
			 XScale_cp13_MCR, NULL, XScale_cp13_read_reg,
			 XScale_cp13_write_reg);

      ARMul_CoProAttach (state, 14, XScale_cp14_init, NULL,
			 XScale_cp14_LDC, XScale_cp14_STC, XScale_cp14_MRC,
			 XScale_cp14_MCR, NULL, XScale_cp14_read_reg,
			 XScale_cp14_write_reg);

      ARMul_CoProAttach (state, 15, XScale_cp15_init, NULL,
			 NULL, NULL, XScale_cp15_MRC, XScale_cp15_MCR,
			 NULL, XScale_cp15_read_reg, XScale_cp15_write_reg);
    }
  else
    {
      ARMul_CoProAttach (state, 15, MMUInit, NULL, NULL, NULL,
			 MMUMRC, MMUMCR, NULL, MMURead, MMUWrite);
    }

  if (state->is_iWMMXt)
    {
      ARMul_CoProAttach (state, 0, NULL, NULL, IwmmxtLDC, IwmmxtSTC,
			 NULL, NULL, IwmmxtCDP, NULL, NULL);

      ARMul_CoProAttach (state, 1, NULL, NULL, NULL, NULL,
			 IwmmxtMRC, IwmmxtMCR, IwmmxtCDP, NULL, NULL);
    }
@


1.9
log
@Only perform access checks if 'check' is set.
Report unknown machine numbers.
Formatting tidy ups.
@
text
@d482 8
a489 1
    ARMul_Abort (state, ARMul_DataAbortV);
@


1.9.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d482 1
a482 8
    {
      /* Set the FSR and FAR.
	 Do not use XScale_set_fsr_far as this checks the DCSR register.  */
      write_cp15_reg (state, 5, 0, 0, ARMul_CP15_R5_MMU_EXCPT);
      write_cp15_reg (state, 6, 0, 0, * address);

      ARMul_Abort (state, ARMul_DataAbortV);
    }
@


1.8
log
@Simulate XScale BCUMOD register
@
text
@a87 1

d255 1
a255 1
          /* Change the endianness if necessary */
d477 2
a478 2
  if (r0 && (*address & 0xfe000000) == 0)
    *address |= r0;
d481 1
a481 1
  if ((read_cp15_reg (1, 0, 0) & ARMul_CP15_R1_ALIGN) && (*address & 3))
d497 1
a497 1
          && ((*address & ~r1) == (r0 & ~r1)))
d506 1
a506 1
              && ((*address & ~3) == (r0 & ~3)))
d514 1
a514 1
              && ((*address & ~3) == (r1 & ~3)))
d522 1
a522 1
/* Check set.  */
d849 1
a849 1
      /* Reset the clock counter if necessary */
@


1.7
log
@Add support for XScale's coprocessor access check register.
Fix formatting.
@
text
@d590 1
a590 1
  /* Do not allow access to these register in USER mode.  */
d604 1
a604 1
     Registers 0, 4, 5, 6, 7, 8 are defined when CRm == 1.
d613 1
a613 1
      if (reg == 0 || (reg >= 4 && reg <= 8))
d660 6
@


1.7.6.1
log
@merge from trunk
@
text
@d88 1
d256 1
a256 1
          /* Change the endianness if necessary.  */
d478 2
a479 2
  if (r0 && (* address & 0xfe000000) == 0)
    * address |= r0;
d482 2
a483 9
  if ((read_cp15_reg (1, 0, 0) & ARMul_CP15_R1_ALIGN) && (* address & 3))
    {
      /* Set the FSR and FAR.
	 Do not use XScale_set_fsr_far as this checks the DCSR register.  */
      write_cp15_reg (state, 5, 0, 0, ARMul_CP15_R5_MMU_EXCPT);
      write_cp15_reg (state, 6, 0, 0, * address);

      ARMul_Abort (state, ARMul_DataAbortV);
    }
d498 1
a498 1
          && ((* address & ~r1) == (r0 & ~r1)))
d507 1
a507 1
              && ((* address & ~3) == (r0 & ~3)))
d515 1
a515 1
              && ((* address & ~3) == (r1 & ~3)))
d523 1
a523 1
/* Set the XScale FSR and FAR registers.  */
d590 1
a590 1
  /* Do not allow access to these registers in USER mode.  */
d604 1
a604 1
     Registers 0, 1, 4, 5, 6, 7, 8 are defined when CRm == 1.
d613 1
a613 1
      if (reg == 0 || reg == 1 || (reg >= 4 && reg <= 8))
a661 6
	case 1: /* BCUMOD */
	  /* Only bit 0 is accecssible.  */
	  value &= 1;
	  value |= XScale_cp13_CR1_Regs[1] & ~ 1;
	  break;

d844 1
a844 1
      /* Reset the clock counter if necessary.  */
@


1.6
log
@* XScale coprocessor support.

2001-04-18  matthew green  <mrg@@redhat.com>

	* armcopro.c (write_cp15_reg): Set CHANGEMODE if endianness changes.
	(read_cp15_reg): Make non-static.
	(XScale_cp15_LDC): Update for write_cp15_reg() change.
	(XScale_cp15_MCR): Likewise.
	(XScale_cp15_write_reg): Likewise.
	(XScale_check_memacc): New function. Check for breakpoints being
	activated by memory accesses.  Does not support the Branch Target
	Buffer.
	(XScale_set_fsr_far): New function. Set FSR and FAR for XScale.
	(XScale_debug_moe): New function. Set the debug Method Of Entry,
	if configured.
	(write_cp14_reg): Reset count counter if requested.
	* armdefs.h (struct ARMul_State): New members `LastTime' and
	`CP14R0_CCD' used for the timer/counters.
	(ARMul_CP13_R0_FIQ, ARMul_CP13_R0_IRQ, ARMul_CP13_R8_PMUS,
	ARMul_CP14_R0_ENABLE, ARMul_CP14_R0_CLKRST, ARMul_CP14_R0_CCD,
	ARMul_CP14_R0_INTEN0, ARMul_CP14_R0_INTEN1, ARMul_CP14_R0_INTEN2,
	ARMul_CP14_R0_FLAG0, ARMul_CP14_R0_FLAG1, ARMul_CP14_R0_FLAG2,
	ARMul_CP14_R10_MOE_IB, ARMul_CP14_R10_MOE_DB, ARMul_CP14_R10_MOE_BT,
	ARMul_CP15_R1_ENDIAN, ARMul_CP15_R1_ALIGN, ARMul_CP15_R5_X,
	ARMul_CP15_R5_ST_ALIGN, ARMul_CP15_R5_IMPRE, ARMul_CP15_R5_MMU_EXCPT,
	ARMul_CP15_DBCON_M, ARMul_CP15_DBCON_E1, ARMul_CP15_DBCON_E0): New
	defines for XScale registers.
	(XScale_check_memacc, XScale_set_fsr_far, XScale_debug_moe): Prototype.
	(ARMul_Emulate32, ARMul_Emulate26): Clean up function definition.
	(ARMul_Emulate32): Handle the clock counter and hardware instruction
	breakpoints.  Call XScale_set_fsr_far() for software breakpoints and
	software interrupts.
	(LoadMult): Call XScale_set_fsr_far() for data aborts.
	(LoadSMult): Likewise.
	(StoreMult): Likewise.
	(StoreSMult): Likewise.
	* armemu.h (write_cp15_reg): Update prototype.
	* arminit.c (ARMul_NewState): Initialise CP14R0_CCD and LastTime.
	(ARMul_Abort): If XScale, check for FIQ and IRQ being enabled in CP13
	register 0.
	* armvirt.c (GetWord): Call XScale_check_memacc().
	(PutWord): Likewise.
@
text
@d16 1
a16 1
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
d54 2
d88 1
a88 1
  
d107 1
a107 1
  
d154 1
a154 1
      
d210 1
a210 1
  
d216 6
a221 2
void
write_cp15_reg (ARMul_State * state, unsigned reg, unsigned opcode_2, unsigned CRm, ARMword value)
d235 1
a235 1
	  
d239 1
a239 1
      
d270 1
a270 1
	  
d274 1
a274 1
	  
d328 1
a328 1
	  
d332 1
a332 1
	  
d339 1
a339 1
  
d365 1
a365 1
      
d381 1
a381 1
  
d393 1
a393 1
  
d395 1
a395 1
  
d398 1
a398 1
  
d404 3
a406 3
	      unsigned      type ATTRIBUTE_UNUSED,
	      ARMword       instr,
	      ARMword *     value)
d412 1
a412 1
  
d414 1
a414 1
  
d417 1
a417 1
  
d423 3
a425 3
	      unsigned      type ATTRIBUTE_UNUSED,
	      ARMword       instr,
	      ARMword       value)
d431 1
a431 1
  
d433 1
a433 1
  
d436 1
a436 1
  
d442 2
a443 2
		   unsigned      reg,
		   ARMword *     value)
d448 1
a448 1
  
d454 2
a455 2
		    unsigned      reg,
		    ARMword       value)
d460 1
a460 1
  
d464 2
a465 3
/***************************************************************************\
*        Check for special XScale memory access features                    *
\***************************************************************************/
d523 2
a524 3
/***************************************************************************\
*        Check set 
\***************************************************************************/
d526 1
a526 1
XScale_set_fsr_far(ARMul_State * state, ARMword fsr, ARMword far)
d536 1
d597 4
a600 4
  
  /* Do not allow access to these register if bit 13 of coprocessor
     15's register 15 is zero.  */
  if ((XScale_cp15_opcode_2_is_0_Regs[15] & (1 << 13)) == 0)
d602 1
a602 1
  
d634 1
a634 1
	  
d638 1
a638 1
	  
d643 1
a643 1
	  
d648 1
a648 1
      
d661 1
a661 1
	  
d673 1
a673 1
	  
d678 1
a678 1
      
d686 1
a686 1
  
d708 1
a708 1
  
d710 1
a710 1
  
d722 1
a722 1
  
d724 1
a724 1
  
d727 1
a727 1
  
d733 3
a735 3
	      unsigned      type ATTRIBUTE_UNUSED,
	      ARMword       instr,
	      ARMword *     value)
d740 1
a740 1
  
d742 1
a742 1
  
d745 1
a745 1
  
d751 3
a753 3
	      unsigned      type ATTRIBUTE_UNUSED,
	      ARMword       instr,
	      ARMword       value)
d758 1
a758 1
  
d760 1
a760 1
  
d763 1
a763 1
  
d768 3
a770 6
XScale_cp13_read_reg
(
 ARMul_State * state ATTRIBUTE_UNUSED,
 unsigned      reg,
 ARMword *     value
)
d775 1
a775 1
  
d780 3
a782 6
XScale_cp13_write_reg
(
 ARMul_State * state ATTRIBUTE_UNUSED,
 unsigned      reg,
 ARMword       value
)
d787 1
a787 1
  
d825 1
a825 1
  
d835 1
a835 1
void
d855 1
a855 1
      
d866 1
a866 1
	 
d882 1
a882 1
      
d887 1
a887 1
      
d910 1
a910 1
  
d912 1
a912 1
  
d924 1
a924 1
  
d926 1
a926 1
  
d929 1
a929 1
  
d944 1
a944 1
  
d946 1
a946 1
  
d949 1
a949 1
  
d964 1
a964 1
  
d966 1
a966 1
  
d969 1
a969 1
  
d982 1
a982 1
  
d995 1
a995 1
  
d1054 1
a1054 1
      
d1096 1
a1096 1
      
d1101 1
a1101 1
      
d1146 1
a1146 1
  
d1206 1
a1206 1
      
d1208 1
a1208 1
      
d1211 1
a1211 1
      
d1221 1
a1221 1
  
d1267 1
a1267 1
      
d1274 1
a1274 1
      
d1281 1
a1281 1
      
d1286 1
a1286 1
      
d1291 1
a1291 1
      
d1296 1
a1296 1
  
d1300 1
a1300 3
/***************************************************************************\
*         Install co-processor instruction handlers in this routine         *
\***************************************************************************/
d1332 1
a1332 1
  
d1337 1
a1337 1
  
d1352 1
a1352 3
/***************************************************************************\
*         Install co-processor finalisation routines in this routine        *
\***************************************************************************/
d1367 1
a1367 3
/***************************************************************************\
*              Routines to hook Co-processors into ARMulator                 *
\***************************************************************************/
@


1.5
log
@Add support for disabling alignment checks when performing GDB interface
calls or SWI emulaiton routines.  (Alignment checking code has not yet been
contributed).
@
text
@d249 9
d458 97
d844 4
@


1.4
log
@Add support for ARM's v5TE architecture and Intel's XScale extenstions
@
text
@d19 1
d215 1
a215 1
write_cp15_reg (unsigned reg, unsigned opcode_2, unsigned CRm, ARMword value)
d328 1
a328 1
/* Return the value in a cp13 register.  */
d330 1
a330 1
static ARMword
d368 1
a368 1
    write_cp15_reg (reg, 0, 0, data);
d420 1
a420 1
    write_cp15_reg (reg, opcode_2, CRm, value);
d444 1
a444 1
  write_cp15_reg (reg, 0, 0, value);
@


1.3
log
@Add support for v4 SystemMode.
@
text
@d22 1
a22 9
extern unsigned ARMul_CoProInit (ARMul_State * state);
extern void ARMul_CoProExit (ARMul_State * state);
extern void ARMul_CoProAttach (ARMul_State * state, unsigned number,
			       ARMul_CPInits * init, ARMul_CPExits * exit,
			       ARMul_LDCs * ldc, ARMul_STCs * stc,
			       ARMul_MRCs * mrc, ARMul_MCRs * mcr,
			       ARMul_CDPs * cdp,
			       ARMul_CPReads * read, ARMul_CPWrites * write);
extern void ARMul_CoProDetach (ARMul_State * state, unsigned number);
d24 188
d213 649
a861 3
/***************************************************************************\
*                            Dummy Co-processors                            *
\***************************************************************************/
d863 12
a874 3
static unsigned NoCoPro3R (ARMul_State * state, unsigned, ARMword);
static unsigned NoCoPro4R (ARMul_State * state, unsigned, ARMword, ARMword);
static unsigned NoCoPro4W (ARMul_State * state, unsigned, ARMword, ARMword *);
d876 12
a887 3
/***************************************************************************\
*                Define Co-Processor instruction handlers here              *
\***************************************************************************/
d890 6
a895 7
1) it has eight registers, but only two are defined.
2) you can only access its registers with MCR and MRC.
3) MMU Register 0 (ID) returns 0x41440110
4) Register 1 only has 4 bits defined.  Bits 0 to 3 are unused, bit 4
controls 32/26 bit program space, bit 5 controls 32/26 bit data space,
bit 6 controls late abort timimg and bit 7 controls big/little endian.
*/
d904 1
d906 2
a907 1
  return (TRUE);
d911 4
a914 1
MMUMRC (ARMul_State * state ATTRIBUTE_UNUSED, unsigned type ATTRIBUTE_UNUSED, ARMword instr, ARMword * value)
d922 2
a923 1
  return (ARMul_DONE);
d927 4
a930 1
MMUMCR (ARMul_State * state, unsigned type ATTRIBUTE_UNUSED, ARMword instr, ARMword value)
d935 1
a935 1
  
d945 2
a946 2
      state->prog32Sig = value >> 4 & 1;
      state->data32Sig = value >> 5 & 1;
d948 1
a948 1
      state->bigendSig = value >> 7 & 1;
d950 1
a950 1
      if (p != state->prog32Sig
d954 2
a955 1
	state->Emulate = CHANGEMODE;	/* Force ARMulator to notice these now.  */
d957 1
a957 1
  
a960 1

d968 2
a969 1
  return (TRUE);
d977 1
a977 1
  
d987 2
a988 2
      state->prog32Sig = value >> 4 & 1;
      state->data32Sig = value >> 5 & 1;
d990 1
a990 2
      state->bigendSig = value >> 7 & 1;

d992 1
a992 1
      if (p != state->prog32Sig
d996 2
a997 1
	state->Emulate = CHANGEMODE;	/* Force ARMulator to notice these now.  */
d999 1
a999 1
  
d1005 9
a1013 9
co-processor numbers (4 and 5) and has the follwing functionality.
Sixteen registers.  Both co-processor nuimbers can be used in an MCR and
MRC to access these registers.  CP 4 can LDC and STC to and from the
registers.  CP 4 and CP 5 CDP 0 will busy wait for the number of cycles
specified by a CP register.  CP 5 CDP 1 issues a FIQ after a number of
cycles (specified in a CP register), CDP 2 issues an IRQW in the same
way, CDP 3 and 4 turn of the FIQ and IRQ source, and CDP 5 stores a 32
bit time value in a CP register (actually it's the total number of N, S,
I, C and F cyles) */
d1018 4
a1021 1
ValLDC (ARMul_State * state ATTRIBUTE_UNUSED, unsigned type, ARMword instr, ARMword data)
d1026 2
a1028 5
      words = 0;
      return (ARMul_DONE);
    }
  if (BIT (22))
    {				/* it's a long access, get two words */
d1030 5
a1034 9
      if (words++ == 4)
	return (ARMul_DONE);
      else
	return (ARMul_INC);
    }
  else
    {				/* get just one word */
      ValReg[BITS (12, 15)] = data;
      return (ARMul_DONE);
d1036 2
d1041 4
a1044 1
ValSTC (ARMul_State * state ATTRIBUTE_UNUSED, unsigned type, ARMword instr, ARMword * data)
d1049 2
d1052 6
a1057 15
      words = 0;
      return (ARMul_DONE);
    }
  if (BIT (22))
    {				/* it's a long access, get two words */
      *data = ValReg[BITS (12, 15)];
      if (words++ == 4)
	return (ARMul_DONE);
      else
	return (ARMul_INC);
    }
  else
    {				/* get just one word */
      *data = ValReg[BITS (12, 15)];
      return (ARMul_DONE);
d1059 2
d1064 4
a1067 1
ValMRC (ARMul_State * state ATTRIBUTE_UNUSED, unsigned type ATTRIBUTE_UNUSED, ARMword instr, ARMword * value)
d1070 2
a1071 1
  return (ARMul_DONE);
d1075 4
a1078 1
ValMCR (ARMul_State * state ATTRIBUTE_UNUSED, unsigned type ATTRIBUTE_UNUSED, ARMword instr, ARMword value)
d1081 2
a1082 1
  return (ARMul_DONE);
a1088 1
  ARMword howlong;
d1090 15
a1104 2
  howlong = ValReg[BITS (0, 3)];
  if (BITS (20, 23) == 0)
d1106 4
a1109 15
      if (type == ARMul_FIRST)
	{			/* First cycle of a busy wait */
	  finish = ARMul_Time (state) + howlong;
	  if (howlong == 0)
	    return (ARMul_DONE);
	  else
	    return (ARMul_BUSY);
	}
      else if (type == ARMul_BUSY)
	{
	  if (ARMul_Time (state) >= finish)
	    return (ARMul_DONE);
	  else
	    return (ARMul_BUSY);
	}
d1111 2
a1112 1
  return (ARMul_CANT);
d1120 1
a1120 1
  return (0);
d1128 1
a1128 1
  return (0);
d1138 1
d1143 2
a1144 1
	{			/* First cycle of a busy wait */
d1146 2
a1147 4
	  if (howlong == 0)
	    return (ARMul_DONE);
	  else
	    return (ARMul_BUSY);
d1152 1
a1152 1
	    return (ARMul_DONE);
d1154 1
a1154 1
	    return (ARMul_BUSY);
d1156 2
a1157 1
      return (ARMul_DONE);
d1163 2
a1164 1
      return (ARMul_DONE);
d1170 2
a1171 1
      return (ARMul_DONE);
d1175 2
a1176 1
      return (ARMul_DONE);
d1180 2
a1181 1
      return (ARMul_DONE);
d1184 1
a1184 1
      return (ARMul_DONE);
d1186 2
a1187 1
  return (ARMul_CANT);
d1197 1
a1197 1
  register unsigned i;
d1199 2
a1200 1
  for (i = 0; i < 16; i++)	/* initialise tham all first */
d1203 8
a1210 7
  /* Install CoPro Instruction handlers here
     The format is
     ARMul_CoProAttach(state, CP Number, Init routine, Exit routine
     LDC routine, STC routine, MRC routine, MCR routine,
     CDP routine, Read Reg routine, Write Reg routine) ;
   */

d1220 13
d1234 1
a1234 1
  /* No handlers below here */
d1236 2
a1237 1
  for (i = 0; i < 16; i++)	/* Call all the initialisation routines */
d1240 2
a1241 1
  return (TRUE);
d1256 2
a1257 1
  for (i = 0; i < 16; i++)	/* Detach all handlers */
d1266 11
a1276 5
ARMul_CoProAttach (ARMul_State * state, unsigned number,
		   ARMul_CPInits * init, ARMul_CPExits * exit,
		   ARMul_LDCs * ldc, ARMul_STCs * stc,
		   ARMul_MRCs * mrc, ARMul_MCRs * mcr, ARMul_CDPs * cdp,
		   ARMul_CPReads * read, ARMul_CPWrites * write)
d1304 1
a1308 32
}

/***************************************************************************\
*         There is no CoPro around, so Undefined Instruction trap           *
\***************************************************************************/

static unsigned
NoCoPro3R (ARMul_State * state ATTRIBUTE_UNUSED,
	   unsigned a ATTRIBUTE_UNUSED,
	   ARMword b ATTRIBUTE_UNUSED)
{
  return (ARMul_CANT);
}

static unsigned
NoCoPro4R (
	   ARMul_State * state ATTRIBUTE_UNUSED,
	   unsigned a ATTRIBUTE_UNUSED,
	   ARMword b ATTRIBUTE_UNUSED,
	   ARMword c ATTRIBUTE_UNUSED)
{
  return (ARMul_CANT);
}

static unsigned
NoCoPro4W (
	   ARMul_State * state ATTRIBUTE_UNUSED,
	   unsigned a ATTRIBUTE_UNUSED,
	   ARMword b ATTRIBUTE_UNUSED,
	   ARMword * c ATTRIBUTE_UNUSED)
{
  return (ARMul_CANT);
@


1.2
log
@Fix compile time warning messages.
@
text
@d19 1
d83 1
d86 7
d97 6
a102 1
      state->Emulate = TRUE;	/* force ARMulator to notice these now ! */
d104 2
a105 1
  return (ARMul_DONE);
d124 1
d127 7
d138 7
a144 1
      state->Emulate = TRUE;	/* force ARMulator to notice these now ! */
d146 2
a147 1
  return (TRUE);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
    Copyright (C) 1994 Advanced RISC Machines Ltd.
d19 1
d21 9
a29 9
extern unsigned ARMul_CoProInit(ARMul_State *state) ;
extern void ARMul_CoProExit(ARMul_State *state) ;
extern void ARMul_CoProAttach(ARMul_State *state, unsigned number,
                              ARMul_CPInits *init, ARMul_CPExits *exit,
                              ARMul_LDCs *ldc, ARMul_STCs *stc,
                              ARMul_MRCs *mrc, ARMul_MCRs *mcr,
                              ARMul_CDPs *cdp,
                              ARMul_CPReads *read, ARMul_CPWrites *write) ;
extern void ARMul_CoProDetach(ARMul_State *state, unsigned number) ;
d36 3
a38 3
static unsigned NoCoPro3R(ARMul_State *state,unsigned,ARMword) ;
static unsigned NoCoPro4R(ARMul_State *state,unsigned,ARMword,ARMword) ;
static unsigned NoCoPro4W(ARMul_State *state,unsigned,ARMword,ARMword *) ;
d53 1
a53 1
static ARMword MMUReg[8] ;
d55 34
a88 29
static unsigned MMUInit(ARMul_State *state)
{MMUReg[1] = state->prog32Sig << 4 |
             state->data32Sig << 5 |
             state->lateabtSig << 6 |
             state->bigendSig << 7 ;
 ARMul_ConsolePrint (state, ", MMU present") ;
 return(TRUE) ;
}

static unsigned MMUMRC(ARMul_State *state, unsigned type, ARMword instr,ARMword *value)
{int reg = BITS(16,19) & 7 ;

 if (reg == 0)
    *value =  0x41440110 ;
 else
    *value = MMUReg[reg] ;
 return(ARMul_DONE) ;
 }

static unsigned MMUMCR(ARMul_State *state, unsigned type, ARMword instr, ARMword value)
{int reg = BITS(16,19) & 7 ;

 MMUReg[reg] = value ;
 if (reg == 1) {
    state->prog32Sig = value >> 4 & 1 ;
    state->data32Sig = value >> 5 & 1 ;
    state->lateabtSig = value >> 6 & 1 ;
    state->bigendSig = value >> 7 & 1 ;
    state->Emulate = TRUE ; /* force ARMulator to notice these now !*/
d90 2
a91 2
 return(ARMul_DONE) ;
 }
d94 22
a115 17
static unsigned MMURead(ARMul_State *state, unsigned reg, ARMword *value)
{if (reg == 0)
    *value =  0x41440110 ;
 else if (reg < 8)
    *value = MMUReg[reg] ;
 return(TRUE) ;
 }

static unsigned MMUWrite(ARMul_State *state, unsigned reg, ARMword value)
{if (reg < 8)
    MMUReg[reg] = value ;
 if (reg == 1) {
    state->prog32Sig = value >> 4 & 1 ;
    state->data32Sig = value >> 5 & 1 ;
    state->lateabtSig = value >> 6 & 1 ;
    state->bigendSig = value >> 7 & 1 ;
    state->Emulate = TRUE ; /* force ARMulator to notice these now !*/
d117 2
a118 2
 return(TRUE) ;
 }
d132 1
a132 1
static ARMword ValReg[16] ;
d134 9
a142 7
static unsigned ValLDC(ARMul_State *state, unsigned type,
                          ARMword instr, ARMword data)
{static unsigned words ;

 if (type != ARMul_DATA) {
    words = 0 ;
    return(ARMul_DONE) ;
d144 7
a150 6
 if (BIT(22)) { /* it's a long access, get two words */
    ValReg[BITS(12,15)] = data ;
    if (words++ == 4)
       return(ARMul_DONE) ;
    else
       return(ARMul_INC) ;
d152 4
a155 3
 else { /* get just one word */
    ValReg[BITS(12,15)] = data ;
    return(ARMul_DONE) ;
d157 1
a157 1
 }
d159 17
a175 7
static unsigned ValSTC(ARMul_State *state, unsigned type,
                          ARMword instr, ARMword *data)
{static unsigned words ;

 if (type != ARMul_DATA) {
    words = 0 ;
    return(ARMul_DONE) ;
d177 4
a180 10
 if (BIT(22)) { /* it's a long access, get two words */
    *data = ValReg[BITS(12,15)] ;
    if (words++ == 4)
       return(ARMul_DONE) ;
    else
       return(ARMul_INC) ;
       }
 else { /* get just one word */
    *data = ValReg[BITS(12,15)] ;
    return(ARMul_DONE) ;
d182 1
a182 1
 }
d184 2
a185 1
static unsigned ValMRC(ARMul_State *state, unsigned type, ARMword instr,ARMword *value)
d187 35
a221 30
 *value = ValReg[BITS(16,19)] ;
 return(ARMul_DONE) ;
 }

static unsigned ValMCR(ARMul_State *state, unsigned type, ARMword instr, ARMword value)
{
 ValReg[BITS(16,19)] = value ;
 return(ARMul_DONE) ;
 }

static unsigned ValCDP(ARMul_State *state, unsigned type, ARMword instr)
{
 static unsigned long finish = 0 ;
 ARMword howlong ;

 howlong = ValReg[BITS(0,3)] ;
 if (BITS(20,23)==0) {
    if (type == ARMul_FIRST) { /* First cycle of a busy wait */
       finish = ARMul_Time(state) + howlong ;
       if (howlong == 0)
          return(ARMul_DONE) ;
       else
          return(ARMul_BUSY) ;
       }
    else if (type == ARMul_BUSY) {
       if (ARMul_Time(state) >= finish)
          return(ARMul_DONE) ;
       else
          return(ARMul_BUSY) ;
       }
d223 10
a232 2
 return(ARMul_CANT) ;
 }
d234 57
a290 50
static unsigned DoAFIQ(ARMul_State *state)
{state->NfiqSig = LOW ;
 state->Exception++ ;
 return(0) ;
}

static unsigned DoAIRQ(ARMul_State *state)
{state->NirqSig = LOW ;
 state->Exception++ ;
 return(0) ;
}

static unsigned IntCDP(ARMul_State *state, unsigned type, ARMword instr)
{static unsigned long finish ;
 ARMword howlong ;

 howlong = ValReg[BITS(0,3)] ;
 switch((int)BITS(20,23)) {
    case 0 : if (type == ARMul_FIRST) { /* First cycle of a busy wait */
                finish = ARMul_Time(state) + howlong ;
                if (howlong == 0)
                   return(ARMul_DONE) ;
                else
                   return(ARMul_BUSY) ;
                }
             else if (type == ARMul_BUSY) {
                if (ARMul_Time(state) >= finish)
                   return(ARMul_DONE) ;
                else
                   return(ARMul_BUSY) ;
                   }
             return(ARMul_DONE) ;
    case 1 : if (howlong == 0)
                ARMul_Abort(state,ARMul_FIQV) ;
             else
                ARMul_ScheduleEvent(state,howlong,DoAFIQ) ;
             return(ARMul_DONE) ;
    case 2 : if (howlong == 0)
                ARMul_Abort(state,ARMul_IRQV) ;
             else
                ARMul_ScheduleEvent(state,howlong,DoAIRQ) ;
             return(ARMul_DONE) ;
    case 3 : state->NfiqSig = HIGH ;
             state->Exception-- ;
             return(ARMul_DONE) ;
    case 4 : state->NirqSig = HIGH ;
             state->Exception-- ;
             return(ARMul_DONE) ;
    case 5 : ValReg[BITS(0,3)] = ARMul_Time(state) ;
             return(ARMul_DONE) ;
d292 2
a293 2
 return(ARMul_CANT) ;
 }
d299 4
a302 2
unsigned ARMul_CoProInit(ARMul_State *state)
{register unsigned i ;
d304 2
a305 2
 for (i = 0 ; i < 16 ; i++) /* initialise tham all first */
    ARMul_CoProDetach(state, i) ;
d307 5
a311 5
 /* Install CoPro Instruction handlers here
    The format is
    ARMul_CoProAttach(state, CP Number, Init routine, Exit routine
                      LDC routine, STC routine, MRC routine, MCR routine,
                      CDP routine, Read Reg routine, Write Reg routine) ;
d314 17
a330 20
    ARMul_CoProAttach(state, 4, NULL, NULL,
                      ValLDC, ValSTC, ValMRC, ValMCR,
                      ValCDP, NULL, NULL) ;

    ARMul_CoProAttach(state, 5, NULL, NULL,
                      NULL, NULL, ValMRC, ValMCR,
                      IntCDP, NULL, NULL) ;

    ARMul_CoProAttach(state, 15, MMUInit, NULL,
                      NULL, NULL, MMUMRC, MMUMCR,
                      NULL, MMURead, MMUWrite) ;


    /* No handlers below here */

    for (i = 0 ; i < 16 ; i++) /* Call all the initialisation routines */
       if (state->CPInit[i])
          (state->CPInit[i])(state) ;
    return(TRUE) ;
 }
d336 4
a339 2
void ARMul_CoProExit(ARMul_State *state)
{register unsigned i ;
d341 1
a341 1
 for (i = 0 ; i < 16 ; i++)
d343 4
a346 4
       (state->CPExit[i])(state) ;
 for (i = 0 ; i < 16 ; i++) /* Detach all handlers */
    ARMul_CoProDetach(state, i) ;
 }
d352 37
a388 33
void ARMul_CoProAttach(ARMul_State *state, unsigned number,
                       ARMul_CPInits *init,  ARMul_CPExits *exit,
                       ARMul_LDCs *ldc,  ARMul_STCs *stc,
                       ARMul_MRCs *mrc,  ARMul_MCRs *mcr,  ARMul_CDPs *cdp,
                       ARMul_CPReads *read, ARMul_CPWrites *write)
{if (init != NULL)
    state->CPInit[number] = init ;
 if (exit != NULL)
    state->CPExit[number] = exit ;
 if (ldc != NULL)
    state->LDC[number] = ldc ;
 if (stc != NULL)
    state->STC[number] = stc ;
 if (mrc != NULL)
    state->MRC[number] = mrc ;
 if (mcr != NULL)
    state->MCR[number] = mcr ;
 if (cdp != NULL)
    state->CDP[number] = cdp ;
 if (read != NULL)
    state->CPRead[number] = read ;
 if (write != NULL)
    state->CPWrite[number] = write ;
}

void ARMul_CoProDetach(ARMul_State *state, unsigned number)
{ARMul_CoProAttach(state, number, NULL, NULL,
                   NoCoPro4R, NoCoPro4W, NoCoPro4W, NoCoPro4R,
                   NoCoPro3R, NULL, NULL) ;
 state->CPInit[number] = NULL ;
 state->CPExit[number] = NULL ;
 state->CPRead[number] = NULL ;
 state->CPWrite[number] = NULL ;
d395 7
a401 2
static unsigned NoCoPro3R(ARMul_State *state,unsigned a,ARMword b)
{return(ARMul_CANT) ;}
d403 9
a411 2
static unsigned NoCoPro4R(ARMul_State *state, unsigned a,ARMword b,ARMword c)
{return(ARMul_CANT) ;}
d413 9
a421 2
static unsigned NoCoPro4W(ARMul_State *state, unsigned a,ARMword b,ARMword *c)
{return(ARMul_CANT) ;}
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-2000-02-04 snapshot
@
text
@d20 9
a28 9
extern unsigned ARMul_CoProInit (ARMul_State * state);
extern void ARMul_CoProExit (ARMul_State * state);
extern void ARMul_CoProAttach (ARMul_State * state, unsigned number,
			       ARMul_CPInits * init, ARMul_CPExits * exit,
			       ARMul_LDCs * ldc, ARMul_STCs * stc,
			       ARMul_MRCs * mrc, ARMul_MCRs * mcr,
			       ARMul_CDPs * cdp,
			       ARMul_CPReads * read, ARMul_CPWrites * write);
extern void ARMul_CoProDetach (ARMul_State * state, unsigned number);
d35 3
a37 3
static unsigned NoCoPro3R (ARMul_State * state, unsigned, ARMword);
static unsigned NoCoPro4R (ARMul_State * state, unsigned, ARMword, ARMword);
static unsigned NoCoPro4W (ARMul_State * state, unsigned, ARMword, ARMword *);
d52 1
a52 1
static ARMword MMUReg[8];
d54 29
a82 34
static unsigned
MMUInit (ARMul_State * state)
{
  MMUReg[1] = state->prog32Sig << 4 |
    state->data32Sig << 5 | state->lateabtSig << 6 | state->bigendSig << 7;
  ARMul_ConsolePrint (state, ", MMU present");
  return (TRUE);
}

static unsigned
MMUMRC (ARMul_State * state, unsigned type, ARMword instr, ARMword * value)
{
  int reg = BITS (16, 19) & 7;

  if (reg == 0)
    *value = 0x41440110;
  else
    *value = MMUReg[reg];
  return (ARMul_DONE);
}

static unsigned
MMUMCR (ARMul_State * state, unsigned type, ARMword instr, ARMword value)
{
  int reg = BITS (16, 19) & 7;

  MMUReg[reg] = value;
  if (reg == 1)
    {
      state->prog32Sig = value >> 4 & 1;
      state->data32Sig = value >> 5 & 1;
      state->lateabtSig = value >> 6 & 1;
      state->bigendSig = value >> 7 & 1;
      state->Emulate = TRUE;	/* force ARMulator to notice these now ! */
d84 2
a85 2
  return (ARMul_DONE);
}
d88 17
a104 22
static unsigned
MMURead (ARMul_State * state, unsigned reg, ARMword * value)
{
  if (reg == 0)
    *value = 0x41440110;
  else if (reg < 8)
    *value = MMUReg[reg];
  return (TRUE);
}

static unsigned
MMUWrite (ARMul_State * state, unsigned reg, ARMword value)
{
  if (reg < 8)
    MMUReg[reg] = value;
  if (reg == 1)
    {
      state->prog32Sig = value >> 4 & 1;
      state->data32Sig = value >> 5 & 1;
      state->lateabtSig = value >> 6 & 1;
      state->bigendSig = value >> 7 & 1;
      state->Emulate = TRUE;	/* force ARMulator to notice these now ! */
d106 2
a107 2
  return (TRUE);
}
d121 1
a121 1
static ARMword ValReg[16];
d123 7
a129 9
static unsigned
ValLDC (ARMul_State * state, unsigned type, ARMword instr, ARMword data)
{
  static unsigned words;

  if (type != ARMul_DATA)
    {
      words = 0;
      return (ARMul_DONE);
d131 6
a136 7
  if (BIT (22))
    {				/* it's a long access, get two words */
      ValReg[BITS (12, 15)] = data;
      if (words++ == 4)
	return (ARMul_DONE);
      else
	return (ARMul_INC);
d138 3
a140 4
  else
    {				/* get just one word */
      ValReg[BITS (12, 15)] = data;
      return (ARMul_DONE);
d142 1
a142 1
}
d144 7
a150 17
static unsigned
ValSTC (ARMul_State * state, unsigned type, ARMword instr, ARMword * data)
{
  static unsigned words;

  if (type != ARMul_DATA)
    {
      words = 0;
      return (ARMul_DONE);
    }
  if (BIT (22))
    {				/* it's a long access, get two words */
      *data = ValReg[BITS (12, 15)];
      if (words++ == 4)
	return (ARMul_DONE);
      else
	return (ARMul_INC);
d152 10
a161 4
  else
    {				/* get just one word */
      *data = ValReg[BITS (12, 15)];
      return (ARMul_DONE);
d163 1
a163 1
}
d165 1
a165 2
static unsigned
ValMRC (ARMul_State * state, unsigned type, ARMword instr, ARMword * value)
d167 30
a196 35
  *value = ValReg[BITS (16, 19)];
  return (ARMul_DONE);
}

static unsigned
ValMCR (ARMul_State * state, unsigned type, ARMword instr, ARMword value)
{
  ValReg[BITS (16, 19)] = value;
  return (ARMul_DONE);
}

static unsigned
ValCDP (ARMul_State * state, unsigned type, ARMword instr)
{
  static unsigned long finish = 0;
  ARMword howlong;

  howlong = ValReg[BITS (0, 3)];
  if (BITS (20, 23) == 0)
    {
      if (type == ARMul_FIRST)
	{			/* First cycle of a busy wait */
	  finish = ARMul_Time (state) + howlong;
	  if (howlong == 0)
	    return (ARMul_DONE);
	  else
	    return (ARMul_BUSY);
	}
      else if (type == ARMul_BUSY)
	{
	  if (ARMul_Time (state) >= finish)
	    return (ARMul_DONE);
	  else
	    return (ARMul_BUSY);
	}
d198 2
a199 10
  return (ARMul_CANT);
}

static unsigned
DoAFIQ (ARMul_State * state)
{
  state->NfiqSig = LOW;
  state->Exception++;
  return (0);
}
d201 50
a250 57
static unsigned
DoAIRQ (ARMul_State * state)
{
  state->NirqSig = LOW;
  state->Exception++;
  return (0);
}

static unsigned
IntCDP (ARMul_State * state, unsigned type, ARMword instr)
{
  static unsigned long finish;
  ARMword howlong;

  howlong = ValReg[BITS (0, 3)];
  switch ((int) BITS (20, 23))
    {
    case 0:
      if (type == ARMul_FIRST)
	{			/* First cycle of a busy wait */
	  finish = ARMul_Time (state) + howlong;
	  if (howlong == 0)
	    return (ARMul_DONE);
	  else
	    return (ARMul_BUSY);
	}
      else if (type == ARMul_BUSY)
	{
	  if (ARMul_Time (state) >= finish)
	    return (ARMul_DONE);
	  else
	    return (ARMul_BUSY);
	}
      return (ARMul_DONE);
    case 1:
      if (howlong == 0)
	ARMul_Abort (state, ARMul_FIQV);
      else
	ARMul_ScheduleEvent (state, howlong, DoAFIQ);
      return (ARMul_DONE);
    case 2:
      if (howlong == 0)
	ARMul_Abort (state, ARMul_IRQV);
      else
	ARMul_ScheduleEvent (state, howlong, DoAIRQ);
      return (ARMul_DONE);
    case 3:
      state->NfiqSig = HIGH;
      state->Exception--;
      return (ARMul_DONE);
    case 4:
      state->NirqSig = HIGH;
      state->Exception--;
      return (ARMul_DONE);
    case 5:
      ValReg[BITS (0, 3)] = ARMul_Time (state);
      return (ARMul_DONE);
d252 2
a253 2
  return (ARMul_CANT);
}
d259 2
a260 4
unsigned
ARMul_CoProInit (ARMul_State * state)
{
  register unsigned i;
d262 2
a263 2
  for (i = 0; i < 16; i++)	/* initialise tham all first */
    ARMul_CoProDetach (state, i);
d265 5
a269 5
  /* Install CoPro Instruction handlers here
     The format is
     ARMul_CoProAttach(state, CP Number, Init routine, Exit routine
     LDC routine, STC routine, MRC routine, MCR routine,
     CDP routine, Read Reg routine, Write Reg routine) ;
d272 20
a291 17
  ARMul_CoProAttach (state, 4, NULL, NULL,
		     ValLDC, ValSTC, ValMRC, ValMCR, ValCDP, NULL, NULL);

  ARMul_CoProAttach (state, 5, NULL, NULL,
		     NULL, NULL, ValMRC, ValMCR, IntCDP, NULL, NULL);

  ARMul_CoProAttach (state, 15, MMUInit, NULL,
		     NULL, NULL, MMUMRC, MMUMCR, NULL, MMURead, MMUWrite);


  /* No handlers below here */

  for (i = 0; i < 16; i++)	/* Call all the initialisation routines */
    if (state->CPInit[i])
      (state->CPInit[i]) (state);
  return (TRUE);
}
d297 2
a298 4
void
ARMul_CoProExit (ARMul_State * state)
{
  register unsigned i;
d300 1
a300 1
  for (i = 0; i < 16; i++)
d302 4
a305 4
      (state->CPExit[i]) (state);
  for (i = 0; i < 16; i++)	/* Detach all handlers */
    ARMul_CoProDetach (state, i);
}
d311 33
a343 37
void
ARMul_CoProAttach (ARMul_State * state, unsigned number,
		   ARMul_CPInits * init, ARMul_CPExits * exit,
		   ARMul_LDCs * ldc, ARMul_STCs * stc,
		   ARMul_MRCs * mrc, ARMul_MCRs * mcr, ARMul_CDPs * cdp,
		   ARMul_CPReads * read, ARMul_CPWrites * write)
{
  if (init != NULL)
    state->CPInit[number] = init;
  if (exit != NULL)
    state->CPExit[number] = exit;
  if (ldc != NULL)
    state->LDC[number] = ldc;
  if (stc != NULL)
    state->STC[number] = stc;
  if (mrc != NULL)
    state->MRC[number] = mrc;
  if (mcr != NULL)
    state->MCR[number] = mcr;
  if (cdp != NULL)
    state->CDP[number] = cdp;
  if (read != NULL)
    state->CPRead[number] = read;
  if (write != NULL)
    state->CPWrite[number] = write;
}

void
ARMul_CoProDetach (ARMul_State * state, unsigned number)
{
  ARMul_CoProAttach (state, number, NULL, NULL,
		     NoCoPro4R, NoCoPro4W, NoCoPro4W, NoCoPro4R,
		     NoCoPro3R, NULL, NULL);
  state->CPInit[number] = NULL;
  state->CPExit[number] = NULL;
  state->CPRead[number] = NULL;
  state->CPWrite[number] = NULL;
d350 2
a351 5
static unsigned
NoCoPro3R (ARMul_State * state, unsigned a, ARMword b)
{
  return (ARMul_CANT);
}
d353 2
a354 5
static unsigned
NoCoPro4R (ARMul_State * state, unsigned a, ARMword b, ARMword c)
{
  return (ARMul_CANT);
}
d356 2
a357 5
static unsigned
NoCoPro4W (ARMul_State * state, unsigned a, ARMword b, ARMword * c)
{
  return (ARMul_CANT);
}
@


