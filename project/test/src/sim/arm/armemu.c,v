head	1.38;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.37
	gdb_7_6-2013-04-26-release:1.37
	gdb_7_6-branch:1.37.0.2
	gdb_7_6-2013-03-12-branchpoint:1.37
	gdb_7_5_1-2012-11-29-release:1.35
	gdb_7_5-2012-08-17-release:1.35
	gdb_7_5-branch:1.35.0.34
	gdb_7_5-2012-07-18-branchpoint:1.35
	gdb_7_4_1-2012-04-26-release:1.35
	gdb_7_4-2012-01-24-release:1.35
	gdb_7_4-branch:1.35.0.32
	gdb_7_4-2011-12-13-branchpoint:1.35
	gdb_7_3_1-2011-09-04-release:1.35
	gdb_7_3-2011-07-26-release:1.35
	gdb_7_3-branch:1.35.0.30
	gdb_7_3-2011-04-01-branchpoint:1.35
	gdb_7_2-2010-09-02-release:1.35
	gdb_7_2-branch:1.35.0.28
	gdb_7_2-2010-07-07-branchpoint:1.35
	gdb_7_1-2010-03-18-release:1.35
	gdb_7_1-branch:1.35.0.26
	gdb_7_1-2010-02-18-branchpoint:1.35
	gdb_7_0_1-2009-12-22-release:1.35
	gdb_7_0-2009-10-06-release:1.35
	gdb_7_0-branch:1.35.0.24
	gdb_7_0-2009-09-16-branchpoint:1.35
	arc-sim-20090309:1.35
	msnyder-checkpoint-072509-branch:1.35.0.22
	msnyder-checkpoint-072509-branchpoint:1.35
	arc-insight_6_8-branch:1.35.0.20
	arc-insight_6_8-branchpoint:1.35
	insight_6_8-branch:1.35.0.18
	insight_6_8-branchpoint:1.35
	reverse-20081226-branch:1.35.0.16
	reverse-20081226-branchpoint:1.35
	multiprocess-20081120-branch:1.35.0.14
	multiprocess-20081120-branchpoint:1.35
	reverse-20080930-branch:1.35.0.12
	reverse-20080930-branchpoint:1.35
	reverse-20080717-branch:1.35.0.10
	reverse-20080717-branchpoint:1.35
	msnyder-reverse-20080609-branch:1.35.0.8
	msnyder-reverse-20080609-branchpoint:1.35
	drow-reverse-20070409-branch:1.35.0.6
	drow-reverse-20070409-branchpoint:1.35
	gdb_6_8-2008-03-27-release:1.35
	gdb_6_8-branch:1.35.0.4
	gdb_6_8-2008-02-26-branchpoint:1.35
	gdb_6_7_1-2007-10-29-release:1.35
	gdb_6_7-2007-10-10-release:1.35
	gdb_6_7-branch:1.35.0.2
	gdb_6_7-2007-09-07-branchpoint:1.35
	insight_6_6-20070208-release:1.34
	gdb_6_6-2006-12-18-release:1.34
	gdb_6_6-branch:1.34.0.26
	gdb_6_6-2006-11-15-branchpoint:1.34
	insight_6_5-20061003-release:1.34
	gdb-csl-symbian-6_4_50_20060226-12:1.34
	gdb-csl-sourcerygxx-3_4_4-25:1.34
	nickrob-async-20060828-mergepoint:1.34
	gdb-csl-symbian-6_4_50_20060226-11:1.34
	gdb-csl-sourcerygxx-4_1-17:1.34
	gdb-csl-20060226-branch-local-2:1.34
	gdb-csl-sourcerygxx-4_1-14:1.34
	gdb-csl-sourcerygxx-4_1-13:1.34
	gdb-csl-sourcerygxx-4_1-12:1.34
	gdb-csl-sourcerygxx-3_4_4-21:1.34
	gdb_6_5-20060621-release:1.34
	gdb-csl-sourcerygxx-4_1-9:1.34
	gdb-csl-sourcerygxx-4_1-8:1.34
	gdb-csl-sourcerygxx-4_1-7:1.34
	gdb-csl-arm-2006q1-6:1.34
	gdb-csl-sourcerygxx-4_1-6:1.34
	gdb-csl-symbian-6_4_50_20060226-10:1.34
	gdb-csl-symbian-6_4_50_20060226-9:1.34
	gdb-csl-symbian-6_4_50_20060226-8:1.34
	gdb-csl-coldfire-4_1-11:1.34
	gdb-csl-sourcerygxx-3_4_4-19:1.34
	gdb-csl-coldfire-4_1-10:1.34
	gdb_6_5-branch:1.34.0.24
	gdb_6_5-2006-05-14-branchpoint:1.34
	gdb-csl-sourcerygxx-4_1-5:1.34
	nickrob-async-20060513-branch:1.34.0.22
	nickrob-async-20060513-branchpoint:1.34
	gdb-csl-sourcerygxx-4_1-4:1.34
	msnyder-reverse-20060502-branch:1.34.0.20
	msnyder-reverse-20060502-branchpoint:1.34
	gdb-csl-morpho-4_1-4:1.34
	gdb-csl-sourcerygxx-3_4_4-17:1.34
	readline_5_1-import-branch:1.34.0.18
	readline_5_1-import-branchpoint:1.34
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.34
	gdb-csl-symbian-20060226-branch:1.34.0.16
	gdb-csl-symbian-20060226-branchpoint:1.34
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.34
	msnyder-reverse-20060331-branch:1.34.0.14
	msnyder-reverse-20060331-branchpoint:1.34
	gdb-csl-available-20060303-branch:1.34.0.12
	gdb-csl-available-20060303-branchpoint:1.34
	gdb-csl-20060226-branch:1.34.0.10
	gdb-csl-20060226-branchpoint:1.34
	gdb_6_4-20051202-release:1.34
	msnyder-fork-checkpoint-branch:1.34.0.8
	msnyder-fork-checkpoint-branchpoint:1.34
	gdb-csl-gxxpro-6_3-branch:1.34.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.34
	gdb_6_4-branch:1.34.0.4
	gdb_6_4-2005-11-01-branchpoint:1.34
	gdb-csl-arm-20051020-branch:1.34.0.2
	gdb-csl-arm-20051020-branchpoint:1.34
	msnyder-tracepoint-checkpoint-branch:1.33.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.33
	gdb-csl-arm-20050325-2005-q1b:1.31
	gdb-csl-arm-20050325-2005-q1a:1.31
	csl-arm-20050325-branch:1.31.0.8
	csl-arm-20050325-branchpoint:1.31
	gdb_6_3-20041109-release:1.31
	gdb_6_3-branch:1.31.0.4
	gdb_6_3-20041019-branchpoint:1.31
	drow_intercu-merge-20040921:1.31
	drow_intercu-merge-20040915:1.31
	jimb-gdb_6_2-e500-branch:1.31.0.6
	jimb-gdb_6_2-e500-branchpoint:1.31
	gdb_6_2-20040730-release:1.31
	gdb_6_2-branch:1.31.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.31
	gdb_6_1_1-20040616-release:1.30
	gdb_6_1-2004-04-05-release:1.30
	drow_intercu-merge-20040402:1.30
	drow_intercu-merge-20040327:1.30
	ezannoni_pie-20040323-branch:1.30.0.38
	ezannoni_pie-20040323-branchpoint:1.30
	cagney_tramp-20040321-mergepoint:1.30
	cagney_tramp-20040309-branch:1.30.0.36
	cagney_tramp-20040309-branchpoint:1.30
	gdb_6_1-branch:1.30.0.34
	gdb_6_1-2004-03-01-gmt-branchpoint:1.30
	drow_intercu-20040221-branch:1.30.0.32
	drow_intercu-20040221-branchpoint:1.30
	cagney_bfdfile-20040213-branch:1.30.0.30
	cagney_bfdfile-20040213-branchpoint:1.30
	drow-cplus-merge-20040208:1.30
	carlton_dictionary-20040126-merge:1.30
	cagney_bigcore-20040122-branch:1.30.0.28
	cagney_bigcore-20040122-branchpoint:1.30
	drow-cplus-merge-20040113:1.30
	drow-cplus-merge-20031224:1.30
	drow-cplus-merge-20031220:1.30
	carlton_dictionary-20031215-merge:1.30
	drow-cplus-merge-20031214:1.30
	carlton-dictionary-20031111-merge:1.30
	gdb_6_0-2003-10-04-release:1.30
	kettenis_sparc-20030918-branch:1.30.0.26
	kettenis_sparc-20030918-branchpoint:1.30
	carlton_dictionary-20030917-merge:1.30
	ezannoni_pie-20030916-branchpoint:1.30
	ezannoni_pie-20030916-branch:1.30.0.24
	cagney_x86i386-20030821-branch:1.30.0.22
	cagney_x86i386-20030821-branchpoint:1.30
	carlton_dictionary-20030805-merge:1.30
	carlton_dictionary-20030627-merge:1.30
	gdb_6_0-branch:1.30.0.20
	gdb_6_0-2003-06-23-branchpoint:1.30
	jimb-ppc64-linux-20030613-branch:1.30.0.18
	jimb-ppc64-linux-20030613-branchpoint:1.30
	cagney_convert-20030606-branch:1.30.0.16
	cagney_convert-20030606-branchpoint:1.30
	cagney_writestrings-20030508-branch:1.30.0.14
	cagney_writestrings-20030508-branchpoint:1.30
	jimb-ppc64-linux-20030528-branch:1.30.0.12
	jimb-ppc64-linux-20030528-branchpoint:1.30
	carlton_dictionary-20030523-merge:1.30
	cagney_fileio-20030521-branch:1.30.0.10
	cagney_fileio-20030521-branchpoint:1.30
	kettenis_i386newframe-20030517-mergepoint:1.30
	jimb-ppc64-linux-20030509-branch:1.30.0.8
	jimb-ppc64-linux-20030509-branchpoint:1.30
	kettenis_i386newframe-20030504-mergepoint:1.30
	carlton_dictionary-20030430-merge:1.30
	kettenis_i386newframe-20030419-branch:1.30.0.6
	kettenis_i386newframe-20030419-branchpoint:1.30
	carlton_dictionary-20030416-merge:1.30
	cagney_frameaddr-20030409-mergepoint:1.30
	kettenis_i386newframe-20030406-branch:1.30.0.4
	kettenis_i386newframe-20030406-branchpoint:1.30
	cagney_frameaddr-20030403-branchpoint:1.30
	cagney_frameaddr-20030403-branch:1.30.0.2
	cagney_framebase-20030330-mergepoint:1.30
	cagney_framebase-20030326-branch:1.28.0.24
	cagney_framebase-20030326-branchpoint:1.28
	cagney_lazyid-20030317-branch:1.28.0.22
	cagney_lazyid-20030317-branchpoint:1.28
	kettenis-i386newframe-20030316-mergepoint:1.28
	offbyone-20030313-branch:1.28.0.20
	offbyone-20030313-branchpoint:1.28
	kettenis-i386newframe-20030308-branch:1.28.0.18
	kettenis-i386newframe-20030308-branchpoint:1.28
	carlton_dictionary-20030305-merge:1.28
	cagney_offbyone-20030303-branch:1.28.0.16
	cagney_offbyone-20030303-branchpoint:1.28
	carlton_dictionary-20030207-merge:1.28
	interps-20030202-branch:1.28.0.14
	interps-20030202-branchpoint:1.28
	cagney-unwind-20030108-branch:1.28.0.12
	cagney-unwind-20030108-branchpoint:1.28
	carlton_dictionary-20021223-merge:1.28
	gdb_5_3-2002-12-12-release:1.28
	carlton_dictionary-20021115-merge:1.28
	kseitz_interps-20021105-merge:1.28
	kseitz_interps-20021103-merge:1.28
	drow-cplus-merge-20021020:1.28
	drow-cplus-merge-20021025:1.28
	carlton_dictionary-20021025-merge:1.28
	carlton_dictionary-20021011-merge:1.28
	drow-cplus-branch:1.28.0.10
	drow-cplus-branchpoint:1.28
	kseitz_interps-20020930-merge:1.28
	carlton_dictionary-20020927-merge:1.28
	carlton_dictionary-branch:1.28.0.8
	carlton_dictionary-20020920-branchpoint:1.28
	gdb_5_3-branch:1.28.0.6
	gdb_5_3-2002-09-04-branchpoint:1.28
	kseitz_interps-20020829-merge:1.28
	cagney_sysregs-20020825-branch:1.28.0.4
	cagney_sysregs-20020825-branchpoint:1.28
	readline_4_3-import-branch:1.28.0.2
	readline_4_3-import-branchpoint:1.28
	gdb_5_2_1-2002-07-23-release:1.26
	kseitz_interps-20020528-branch:1.27.0.2
	kseitz_interps-20020528-branchpoint:1.27
	cagney_regbuf-20020515-branch:1.26.0.6
	cagney_regbuf-20020515-branchpoint:1.26
	jimb-macro-020506-branch:1.26.0.4
	jimb-macro-020506-branchpoint:1.26
	gdb_5_2-2002-04-29-release:1.26
	gdb_5_2-branch:1.26.0.2
	gdb_5_2-2002-03-03-branchpoint:1.26
	gdb_5_1_1-2002-01-24-release:1.24
	gdb_5_1_0_1-2002-01-03-release:1.24
	gdb_5_1_0_1-2002-01-03-branch:1.24.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.24
	gdb_5_1-2001-11-21-release:1.24
	gdb_s390-2001-09-26-branch:1.24.0.4
	gdb_s390-2001-09-26-branchpoint:1.24
	gdb_5_1-2001-07-29-branch:1.24.0.2
	gdb_5_1-2001-07-29-branchpoint:1.24
	insight-precleanup-2001-01-01:1.17
	gdb-premipsmulti-2000-06-06-branch:1.4.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.4
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.5
	gdb-2000-02-04:1.1.1.5
	gdb-2000-02-02:1.1.1.4
	gdb-2000-02-01:1.1.1.4
	gdb-2000-01-31:1.1.1.4
	gdb-2000-01-26:1.1.1.4
	gdb-2000-01-24:1.1.1.4
	gdb-2000-01-17:1.1.1.4
	gdb-2000-01-10:1.1.1.4
	gdb-2000-01-05:1.1.1.4
	gdb-1999-12-21:1.1.1.4
	gdb-1999-12-13:1.1.1.4
	gdb-1999-12-07:1.1.1.4
	gdb-1999-12-06:1.1.1.4
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.38
date	2013.05.15.17.49.43;	author vapier;	state Exp;
branches;
next	1.37;

1.37
date	2012.12.19.07.18.14;	author brobecke;	state Exp;
branches;
next	1.36;

1.36
date	2012.12.19.07.11.58;	author brobecke;	state Exp;
branches;
next	1.35;

1.35
date	2007.02.15.10.32.06;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2005.09.19.14.21.07;	author pbrook;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.12.07.36.58;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2005.04.25.07.48.59;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2004.06.29.00.53.59;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2003.03.30.10.39.22;	author nickc;	state Exp;
branches
	1.30.32.1;
next	1.29;

1.29
date	2003.03.27.17.13.33;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.05.14.12.01;	author nickc;	state Exp;
branches
	1.28.8.1
	1.28.10.1
	1.28.24.1;
next	1.27;

1.27
date	2002.05.27.14.11.55;	author nickc;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2002.01.10.11.14.57;	author nickc;	state Exp;
branches
	1.26.6.1;
next	1.25;

1.25
date	2001.10.18.12.20.47;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.11.21.51.07;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2001.04.18.16.39.37;	author mrg;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.28.01.04.24;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.16.22.04.22;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2001.02.15.02.38.15;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2001.02.01.20.56.35;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2001.02.01.20.39.51;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2000.12.19.00.58.04;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2000.12.08.01.39.48;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2000.12.08.01.38.47;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.30.01.55.12;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2000.08.15.00.10.52;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.04.06.54.48;	author aoliva;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.04.06.52.30;	author aoliva;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.04.06.39.39;	author aoliva;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.04.06.35.36;	author aoliva;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.04.06.06.30;	author aoliva;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.04.05.30.43;	author aoliva;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.22.20.42.34;	author aoliva;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.22.20.03.32;	author aoliva;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.30.17.13.37;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.10.15.35.56;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.08.20.54.27;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.55;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.30.32.1
date	2004.09.16.17.02.03;	author drow;	state Exp;
branches;
next	;

1.28.8.1
date	2003.04.16.19.57.07;	author carlton;	state Exp;
branches;
next	;

1.28.10.1
date	2003.12.14.20.28.16;	author drow;	state Exp;
branches;
next	;

1.28.24.1
date	2003.03.30.16.35.25;	author cagney;	state Exp;
branches;
next	;

1.27.2.1
date	2002.07.22.21.47.22;	author kseitz;	state Exp;
branches;
next	;

1.26.6.1
date	2002.06.15.16.43.22;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.55;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.31.19;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.12.11.13.33;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.12.07.03.56.36;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.02.05.07.30.18;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.38
log
@sim: arm: add support for MOVW and MOVT instructions

From: Jayant R. Sonar <Jayant.Sonar@@kpitcummins.com>

This patch adds simulator support for handling the armv7 instructions
'movw (immediate)' and 'movt'.

Compiler frequently use these instructions to load the 32bit addresses of
global variables, string pointers etc. into the general registers.

In absence of support of these instructions:
1. GDB run simulator fails to print even simple "hello world" string
   on console.
2. Loading of global variable addresses into the registers fail causing
   arithmetic operation failures.

Patch has been regression tested for arm-none-eabi (-march=armv7-a).
@
text
@/*  armemu.c -- Main instruction emulation:  ARM7 Instruction Emulator.
    Copyright (C) 1994 Advanced RISC Machines Ltd.
    Modifications to add arch. v4 support by <jsmith@@cygnus.com>.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, see <http://www.gnu.org/licenses/>.  */

#include "armdefs.h"
#include "armemu.h"
#include "armos.h"
#include "iwmmxt.h"

static ARMword  GetDPRegRHS         (ARMul_State *, ARMword);
static ARMword  GetDPSRegRHS        (ARMul_State *, ARMword);
static void     WriteR15            (ARMul_State *, ARMword);
static void     WriteSR15           (ARMul_State *, ARMword);
static void     WriteR15Branch      (ARMul_State *, ARMword);
static ARMword  GetLSRegRHS         (ARMul_State *, ARMword);
static ARMword  GetLS7RHS           (ARMul_State *, ARMword);
static unsigned LoadWord            (ARMul_State *, ARMword, ARMword);
static unsigned LoadHalfWord        (ARMul_State *, ARMword, ARMword, int);
static unsigned LoadByte            (ARMul_State *, ARMword, ARMword, int);
static unsigned StoreWord           (ARMul_State *, ARMword, ARMword);
static unsigned StoreHalfWord       (ARMul_State *, ARMword, ARMword);
static unsigned StoreByte           (ARMul_State *, ARMword, ARMword);
static void     LoadMult            (ARMul_State *, ARMword, ARMword, ARMword);
static void     StoreMult           (ARMul_State *, ARMword, ARMword, ARMword);
static void     LoadSMult           (ARMul_State *, ARMword, ARMword, ARMword);
static void     StoreSMult          (ARMul_State *, ARMword, ARMword, ARMword);
static unsigned Multiply64          (ARMul_State *, ARMword, int, int);
static unsigned MultiplyAdd64       (ARMul_State *, ARMword, int, int);
static void     Handle_Load_Double  (ARMul_State *, ARMword);
static void     Handle_Store_Double (ARMul_State *, ARMword);

#define LUNSIGNED (0)		/* unsigned operation */
#define LSIGNED   (1)		/* signed operation */
#define LDEFAULT  (0)		/* default : do nothing */
#define LSCC      (1)		/* set condition codes on result */

#ifdef NEED_UI_LOOP_HOOK
/* How often to run the ui_loop update, when in use.  */
#define UI_LOOP_POLL_INTERVAL 0x32000

/* Counter for the ui_loop_hook update.  */
static long ui_loop_hook_counter = UI_LOOP_POLL_INTERVAL;

/* Actual hook to call to run through gdb's gui event loop.  */
extern int (*deprecated_ui_loop_hook) (int);
#endif /* NEED_UI_LOOP_HOOK */

extern int stop_simulator;

/* Short-hand macros for LDR/STR.  */

/* Store post decrement writeback.  */
#define SHDOWNWB()                                      \
  lhs = LHS ;                                           \
  if (StoreHalfWord (state, instr, lhs))                \
     LSBase = lhs - GetLS7RHS (state, instr);

/* Store post increment writeback.  */
#define SHUPWB()                                        \
  lhs = LHS ;                                           \
  if (StoreHalfWord (state, instr, lhs))                \
     LSBase = lhs + GetLS7RHS (state, instr);

/* Store pre decrement.  */
#define SHPREDOWN()                                     \
  (void)StoreHalfWord (state, instr, LHS - GetLS7RHS (state, instr));

/* Store pre decrement writeback.  */
#define SHPREDOWNWB()                                   \
  temp = LHS - GetLS7RHS (state, instr);                \
  if (StoreHalfWord (state, instr, temp))               \
     LSBase = temp;

/* Store pre increment.  */
#define SHPREUP()                                       \
  (void)StoreHalfWord (state, instr, LHS + GetLS7RHS (state, instr));

/* Store pre increment writeback.  */
#define SHPREUPWB()                                     \
  temp = LHS + GetLS7RHS (state, instr);                \
  if (StoreHalfWord (state, instr, temp))               \
     LSBase = temp;

/* Load post decrement writeback.  */
#define LHPOSTDOWN()                                    \
{                                                       \
  int done = 1;                                        	\
  lhs = LHS;						\
  temp = lhs - GetLS7RHS (state, instr);		\
  							\
  switch (BITS (5, 6))					\
    {                                  			\
    case 1: /* H */                                     \
      if (LoadHalfWord (state, instr, lhs, LUNSIGNED))  \
         LSBase = temp;        				\
      break;                                           	\
    case 2: /* SB */                                    \
      if (LoadByte (state, instr, lhs, LSIGNED))        \
         LSBase = temp;        				\
      break;                                           	\
    case 3: /* SH */                                    \
      if (LoadHalfWord (state, instr, lhs, LSIGNED))    \
         LSBase = temp;        				\
      break;                                           	\
    case 0: /* SWP handled elsewhere.  */               \
    default:                                            \
      done = 0;                                        	\
      break;                                           	\
    }                                                   \
  if (done)                                             \
     break;                                            	\
}

/* Load post increment writeback.  */
#define LHPOSTUP()                                      \
{                                                       \
  int done = 1;                                        	\
  lhs = LHS;                                           	\
  temp = lhs + GetLS7RHS (state, instr);		\
  							\
  switch (BITS (5, 6))					\
    {                                  			\
    case 1: /* H */                                     \
      if (LoadHalfWord (state, instr, lhs, LUNSIGNED))  \
         LSBase = temp;        				\
      break;                                           	\
    case 2: /* SB */                                    \
      if (LoadByte (state, instr, lhs, LSIGNED))        \
         LSBase = temp;        				\
      break;                                           	\
    case 3: /* SH */                                    \
      if (LoadHalfWord (state, instr, lhs, LSIGNED))    \
         LSBase = temp;        				\
      break;                                           	\
    case 0: /* SWP handled elsewhere.  */               \
    default:                                            \
      done = 0;                                        	\
      break;                                           	\
    }                                                   \
  if (done)                                             \
     break;                                            	\
}

/* Load pre decrement.  */
#define LHPREDOWN()                                     	\
{                                                       	\
  int done = 1;                                        		\
								\
  temp = LHS - GetLS7RHS (state, instr);                 	\
  switch (BITS (5, 6))						\
    {                                  				\
    case 1: /* H */                                     	\
      (void) LoadHalfWord (state, instr, temp, LUNSIGNED);  	\
      break;                                           		\
    case 2: /* SB */                                    	\
      (void) LoadByte (state, instr, temp, LSIGNED);        	\
      break;                                           		\
    case 3: /* SH */                                    	\
      (void) LoadHalfWord (state, instr, temp, LSIGNED);    	\
      break;                                           		\
    case 0:							\
      /* SWP handled elsewhere.  */                 		\
    default:                                            	\
      done = 0;                                        		\
      break;                                           		\
    }                                                   	\
  if (done)                                             	\
     break;                                            		\
}

/* Load pre decrement writeback.  */
#define LHPREDOWNWB()                                   	\
{                                                       	\
  int done = 1;                                        		\
								\
  temp = LHS - GetLS7RHS (state, instr);                	\
  switch (BITS (5, 6))						\
    {                                  				\
    case 1: /* H */                                     	\
      if (LoadHalfWord (state, instr, temp, LUNSIGNED))     	\
         LSBase = temp;                                		\
      break;                                           		\
    case 2: /* SB */                                    	\
      if (LoadByte (state, instr, temp, LSIGNED))           	\
         LSBase = temp;                                		\
      break;                                           		\
    case 3: /* SH */                                    	\
      if (LoadHalfWord (state, instr, temp, LSIGNED))       	\
         LSBase = temp;                                		\
      break;                                           		\
    case 0:							\
      /* SWP handled elsewhere.  */                 		\
    default:                                            	\
      done = 0;                                        		\
      break;                                           		\
    }                                                   	\
  if (done)                                             	\
     break;                                            		\
}

/* Load pre increment.  */
#define LHPREUP()                                       	\
{                                                       	\
  int done = 1;                                        		\
								\
  temp = LHS + GetLS7RHS (state, instr);                 	\
  switch (BITS (5, 6))						\
    {                                  				\
    case 1: /* H */                                     	\
      (void) LoadHalfWord (state, instr, temp, LUNSIGNED);  	\
      break;                                           		\
    case 2: /* SB */                                    	\
      (void) LoadByte (state, instr, temp, LSIGNED);        	\
      break;                                           		\
    case 3: /* SH */                                    	\
      (void) LoadHalfWord (state, instr, temp, LSIGNED);    	\
      break;                                           		\
    case 0:							\
      /* SWP handled elsewhere.  */                 		\
    default:                                            	\
      done = 0;                                        		\
      break;                                           		\
    }                                                   	\
  if (done)                                             	\
     break;                                            		\
}

/* Load pre increment writeback.  */
#define LHPREUPWB()                                     	\
{                                                       	\
  int done = 1;                                        		\
								\
  temp = LHS + GetLS7RHS (state, instr);                	\
  switch (BITS (5, 6))						\
    {                                  				\
    case 1: /* H */                                     	\
      if (LoadHalfWord (state, instr, temp, LUNSIGNED))     	\
	LSBase = temp;                                		\
      break;                                           		\
    case 2: /* SB */                                    	\
      if (LoadByte (state, instr, temp, LSIGNED))           	\
	LSBase = temp;                                		\
      break;                                           		\
    case 3: /* SH */                                    	\
      if (LoadHalfWord (state, instr, temp, LSIGNED))       	\
	LSBase = temp;                                		\
      break;                                           		\
    case 0:							\
      /* SWP handled elsewhere.  */                 		\
    default:                                            	\
      done = 0;                                        		\
      break;                                           		\
    }                                                   	\
  if (done)                                             	\
     break;                                            		\
}

/* Attempt to emulate an ARMv6 instruction.
   Returns non-zero upon success.  */

static int
handle_v6_insn (ARMul_State * state, ARMword instr)
{
  switch (BITS (20, 27))
    {
#if 0
    case 0x03: printf ("Unhandled v6 insn: ldr\n"); break;
    case 0x04: printf ("Unhandled v6 insn: umaal\n"); break;
    case 0x06: printf ("Unhandled v6 insn: mls/str\n"); break;
    case 0x16: printf ("Unhandled v6 insn: smi\n"); break;
    case 0x18: printf ("Unhandled v6 insn: strex\n"); break;
    case 0x19: printf ("Unhandled v6 insn: ldrex\n"); break;
    case 0x1a: printf ("Unhandled v6 insn: strexd\n"); break;
    case 0x1b: printf ("Unhandled v6 insn: ldrexd\n"); break;
    case 0x1c: printf ("Unhandled v6 insn: strexb\n"); break;
    case 0x1d: printf ("Unhandled v6 insn: ldrexb\n"); break;
    case 0x1e: printf ("Unhandled v6 insn: strexh\n"); break;
    case 0x1f: printf ("Unhandled v6 insn: ldrexh\n"); break;
    case 0x30: printf ("Unhandled v6 insn: movw\n"); break;
    case 0x32: printf ("Unhandled v6 insn: nop/sev/wfe/wfi/yield\n"); break;
    case 0x34: printf ("Unhandled v6 insn: movt\n"); break;
    case 0x3f: printf ("Unhandled v6 insn: rbit\n"); break;
#endif
    case 0x61: printf ("Unhandled v6 insn: sadd/ssub\n"); break;
    case 0x62: printf ("Unhandled v6 insn: qadd/qsub\n"); break;
    case 0x63: printf ("Unhandled v6 insn: shadd/shsub\n"); break;
    case 0x65: printf ("Unhandled v6 insn: uadd/usub\n"); break;
    case 0x66: printf ("Unhandled v6 insn: uqadd/uqsub\n"); break;
    case 0x67: printf ("Unhandled v6 insn: uhadd/uhsub\n"); break;
    case 0x68: printf ("Unhandled v6 insn: pkh/sxtab/selsxtb\n"); break;
    case 0x6c: printf ("Unhandled v6 insn: uxtb16/uxtab16\n"); break;
    case 0x70: printf ("Unhandled v6 insn: smuad/smusd/smlad/smlsd\n"); break;
    case 0x74: printf ("Unhandled v6 insn: smlald/smlsld\n"); break;
    case 0x75: printf ("Unhandled v6 insn: smmla/smmls/smmul\n"); break;
    case 0x78: printf ("Unhandled v6 insn: usad/usada8\n"); break;
    case 0x7a: printf ("Unhandled v6 insn: usbfx\n"); break;
    case 0x7c: printf ("Unhandled v6 insn: bfc/bfi\n"); break;

    case 0x6a:
      {
	ARMword Rm;
	int ror = -1;
	  
	switch (BITS (4, 11))
	  {
	  case 0x07: ror = 0; break;
	  case 0x47: ror = 8; break;
	  case 0x87: ror = 16; break;
	  case 0xc7: ror = 24; break;

	  case 0x01:
	  case 0xf3:
	    printf ("Unhandled v6 insn: ssat\n");
	    return 0;
	  default:
	    break;
	  }
	
	if (ror == -1)
	  {
	    if (BITS (4, 6) == 0x7)
	      {
		printf ("Unhandled v6 insn: ssat\n");
		return 0;
	      }
	    break;
	  }

	Rm = ((state->Reg[BITS (0, 3)] >> ror) & 0xFF);
	if (Rm & 0x80)
	  Rm |= 0xffffff00;

	if (BITS (16, 19) == 0xf)
	   /* SXTB */
	  state->Reg[BITS (12, 15)] = Rm;
	else
	  /* SXTAB */
	  state->Reg[BITS (12, 15)] += Rm;
      }
      return 1;

    case 0x6b:
      {
	ARMword Rm;
	int ror = -1;
	  
	switch (BITS (4, 11))
	  {
	  case 0x07: ror = 0; break;
	  case 0x47: ror = 8; break;
	  case 0x87: ror = 16; break;
	  case 0xc7: ror = 24; break;

	  case 0xfb:
	    printf ("Unhandled v6 insn: rev\n");
	    return 0;
	  default:
	    break;
	  }
	
	if (ror == -1)
	  break;

	Rm = ((state->Reg[BITS (0, 3)] >> ror) & 0xFFFF);
	if (Rm & 0x8000)
	  Rm |= 0xffff0000;

	if (BITS (16, 19) == 0xf)
	  /* SXTH */
	  state->Reg[BITS (12, 15)] = Rm;
	else
	  /* SXTAH */
	  state->Reg[BITS (12, 15)] = state->Reg[BITS (16, 19)] + Rm;
      }
      return 1;

    case 0x6e:
      {
	ARMword Rm;
	int ror = -1;
	  
	switch (BITS (4, 11))
	  {
	  case 0x07: ror = 0; break;
	  case 0x47: ror = 8; break;
	  case 0x87: ror = 16; break;
	  case 0xc7: ror = 24; break;

	  case 0x01:
	  case 0xf3:
	    printf ("Unhandled v6 insn: usat\n");
	    return 0;
	  default:
	    break;
	  }
	
	if (ror == -1)
	  {
	    if (BITS (4, 6) == 0x7)
	      {
		printf ("Unhandled v6 insn: usat\n");
		return 0;
	      }
	    break;
	  }

	Rm = ((state->Reg[BITS (0, 3)] >> ror) & 0xFF);

	if (BITS (16, 19) == 0xf)
	   /* UXTB */
	  state->Reg[BITS (12, 15)] = Rm;
	else
	  /* UXTAB */
	  state->Reg[BITS (12, 15)] = state->Reg[BITS (16, 19)] + Rm;
      }
      return 1;

    case 0x6f:
      {
	ARMword Rm;
	int ror = -1;
	  
	switch (BITS (4, 11))
	  {
	  case 0x07: ror = 0; break;
	  case 0x47: ror = 8; break;
	  case 0x87: ror = 16; break;
	  case 0xc7: ror = 24; break;

	  case 0xfb:
	    printf ("Unhandled v6 insn: revsh\n");
	    return 0;
	  default:
	    break;
	  }
	
	if (ror == -1)
	  break;

	Rm = ((state->Reg[BITS (0, 3)] >> ror) & 0xFFFF);

	if (BITS (16, 19) == 0xf)
	  /* UXT */
	  state->Reg[BITS (12, 15)] = Rm;
	else
	  {
	    /* UXTAH */
	    state->Reg[BITS (12, 15)] = state->Reg [BITS (16, 19)] + Rm;
	  }
	}
      return 1;

#if 0
    case 0x84: printf ("Unhandled v6 insn: srs\n"); break;
#endif
    default:
      break;
    }
  printf ("Unhandled v6 insn: UNKNOWN: %08x\n", instr);
  return 0;
}

/* EMULATION of ARM6.  */

/* The PC pipeline value depends on whether ARM
   or Thumb instructions are being executed.  */
ARMword isize;

ARMword
#ifdef MODE32
ARMul_Emulate32 (ARMul_State * state)
#else
ARMul_Emulate26 (ARMul_State * state)
#endif
{
  ARMword instr;	/* The current instruction.  */
  ARMword dest = 0;	/* Almost the DestBus.  */
  ARMword temp;		/* Ubiquitous third hand.  */
  ARMword pc = 0;	/* The address of the current instruction.  */
  ARMword lhs;		/* Almost the ABus and BBus.  */
  ARMword rhs;
  ARMword decoded = 0;	/* Instruction pipeline.  */
  ARMword loaded = 0;	

  /* Execute the next instruction.  */

  if (state->NextInstr < PRIMEPIPE)
    {
      decoded = state->decoded;
      loaded = state->loaded;
      pc = state->pc;
    }

  do
    {
      /* Just keep going.  */
      isize = INSN_SIZE;

      switch (state->NextInstr)
	{
	case SEQ:
	  /* Advance the pipeline, and an S cycle.  */
	  state->Reg[15] += isize;
	  pc += isize;
	  instr = decoded;
	  decoded = loaded;
	  loaded = ARMul_LoadInstrS (state, pc + (isize * 2), isize);
	  break;

	case NONSEQ:
	  /* Advance the pipeline, and an N cycle.  */
	  state->Reg[15] += isize;
	  pc += isize;
	  instr = decoded;
	  decoded = loaded;
	  loaded = ARMul_LoadInstrN (state, pc + (isize * 2), isize);
	  NORMALCYCLE;
	  break;

	case PCINCEDSEQ:
	  /* Program counter advanced, and an S cycle.  */
	  pc += isize;
	  instr = decoded;
	  decoded = loaded;
	  loaded = ARMul_LoadInstrS (state, pc + (isize * 2), isize);
	  NORMALCYCLE;
	  break;

	case PCINCEDNONSEQ:
	  /* Program counter advanced, and an N cycle.  */
	  pc += isize;
	  instr = decoded;
	  decoded = loaded;
	  loaded = ARMul_LoadInstrN (state, pc + (isize * 2), isize);
	  NORMALCYCLE;
	  break;

	case RESUME:
	  /* The program counter has been changed.  */
	  pc = state->Reg[15];
#ifndef MODE32
	  pc = pc & R15PCBITS;
#endif
	  state->Reg[15] = pc + (isize * 2);
	  state->Aborted = 0;
	  instr   = ARMul_ReLoadInstr (state, pc, isize);
	  decoded = ARMul_ReLoadInstr (state, pc + isize, isize);
	  loaded  = ARMul_ReLoadInstr (state, pc + isize * 2, isize);
	  NORMALCYCLE;
	  break;

	default:
	  /* The program counter has been changed.  */
	  pc = state->Reg[15];
#ifndef MODE32
	  pc = pc & R15PCBITS;
#endif
	  state->Reg[15] = pc + (isize * 2);
	  state->Aborted = 0;
	  instr   = ARMul_LoadInstrN (state, pc, isize);
	  decoded = ARMul_LoadInstrS (state, pc + (isize), isize);
	  loaded  = ARMul_LoadInstrS (state, pc + (isize * 2), isize);
	  NORMALCYCLE;
	  break;
	}

      if (state->EventSet)
	ARMul_EnvokeEvent (state);
#if 0 /* Enable this for a helpful bit of debugging when tracing is needed.  */
      fprintf (stderr, "pc: %x, instr: %x\n", pc & ~1, instr);
      if (instr == 0)
	abort ();
#endif
#if 0 /* Enable this code to help track down stack alignment bugs.  */
      {
	static ARMword old_sp = -1;

	if (old_sp != state->Reg[13])
	  {
	    old_sp = state->Reg[13];
	    fprintf (stderr, "pc: %08x: SP set to %08x%s\n",
		     pc & ~1, old_sp, (old_sp % 8) ? " [UNALIGNED!]" : "");
	  }
      }
#endif

      if (state->Exception)
	{
	  /* Any exceptions ?  */
	  if (state->NresetSig == LOW)
	    {
	      ARMul_Abort (state, ARMul_ResetV);
	      break;
	    }
	  else if (!state->NfiqSig && !FFLAG)
	    {
	      ARMul_Abort (state, ARMul_FIQV);
	      break;
	    }
	  else if (!state->NirqSig && !IFLAG)
	    {
	      ARMul_Abort (state, ARMul_IRQV);
	      break;
	    }
	}

      if (state->CallDebug > 0)
	{
	  instr = ARMul_Debug (state, pc, instr);
	  if (state->Emulate < ONCE)
	    {
	      state->NextInstr = RESUME;
	      break;
	    }
	  if (state->Debug)
	    {
	      fprintf (stderr, "sim: At %08lx Instr %08lx Mode %02lx\n", pc, instr,
		       state->Mode);
	      (void) fgetc (stdin);
	    }
	}
      else if (state->Emulate < ONCE)
	{
	  state->NextInstr = RESUME;
	  break;
	}

      state->NumInstrs++;

#ifdef MODET
      /* Provide Thumb instruction decoding. If the processor is in Thumb
         mode, then we can simply decode the Thumb instruction, and map it
         to the corresponding ARM instruction (by directly loading the
         instr variable, and letting the normal ARM simulator
         execute). There are some caveats to ensure that the correct
         pipelined PC value is used when executing Thumb code, and also for
         dealing with the BL instruction.  */
      if (TFLAG)
	{
	  ARMword new;

	  /* Check if in Thumb mode.  */
	  switch (ARMul_ThumbDecode (state, pc, instr, &new))
	    {
	    case t_undefined:
	      /* This is a Thumb instruction.  */
	      ARMul_UndefInstr (state, instr);
	      goto donext;

	    case t_branch:
	      /* Already processed.  */
	      goto donext;

	    case t_decoded:
	      /* ARM instruction available.  */
	      instr = new;
	      /* So continue instruction decoding.  */
	      break;
	    default:
	      break;
	    }
	}
#endif

      /* Check the condition codes.  */
      if ((temp = TOPBITS (28)) == AL)
	/* Vile deed in the need for speed.  */
	goto mainswitch;

      /* Check the condition code.  */
      switch ((int) TOPBITS (28))
	{
	case AL:
	  temp = TRUE;
	  break;
	case NV:
	  if (state->is_v5)
	    {
	      if (BITS (25, 27) == 5) /* BLX(1) */
		{
		  ARMword dest;
		  
		  state->Reg[14] = pc + 4;
		  
		  /* Force entry into Thumb mode.  */
		  dest = pc + 8 + 1;
		  if (BIT (23))
		    dest += (NEGBRANCH + (BIT (24) << 1));
		  else
		    dest += POSBRANCH + (BIT (24) << 1);

		  WriteR15Branch (state, dest);
		  goto donext;
		}
	      else if ((instr & 0xFC70F000) == 0xF450F000)
		/* The PLD instruction.  Ignored.  */
		goto donext;
	      else if (   ((instr & 0xfe500f00) == 0xfc100100)
		       || ((instr & 0xfe500f00) == 0xfc000100))
		/* wldrw and wstrw are unconditional.  */
		goto mainswitch;
	      else
		/* UNDEFINED in v5, UNPREDICTABLE in v3, v4, non executed in v1, v2.  */
		ARMul_UndefInstr (state, instr);
	    }
	  temp = FALSE;
	  break;
	case EQ:
	  temp = ZFLAG;
	  break;
	case NE:
	  temp = !ZFLAG;
	  break;
	case VS:
	  temp = VFLAG;
	  break;
	case VC:
	  temp = !VFLAG;
	  break;
	case MI:
	  temp = NFLAG;
	  break;
	case PL:
	  temp = !NFLAG;
	  break;
	case CS:
	  temp = CFLAG;
	  break;
	case CC:
	  temp = !CFLAG;
	  break;
	case HI:
	  temp = (CFLAG && !ZFLAG);
	  break;
	case LS:
	  temp = (!CFLAG || ZFLAG);
	  break;
	case GE:
	  temp = ((!NFLAG && !VFLAG) || (NFLAG && VFLAG));
	  break;
	case LT:
	  temp = ((NFLAG && !VFLAG) || (!NFLAG && VFLAG));
	  break;
	case GT:
	  temp = ((!NFLAG && !VFLAG && !ZFLAG) || (NFLAG && VFLAG && !ZFLAG));
	  break;
	case LE:
	  temp = ((NFLAG && !VFLAG) || (!NFLAG && VFLAG)) || ZFLAG;
	  break;
	}			/* cc check */

      /* Handle the Clock counter here.  */
      if (state->is_XScale)
	{
	  ARMword cp14r0;
	  int ok;

	  ok = state->CPRead[14] (state, 0, & cp14r0);

	  if (ok && (cp14r0 & ARMul_CP14_R0_ENABLE))
	    {
	      unsigned long newcycles, nowtime = ARMul_Time (state);

	      newcycles = nowtime - state->LastTime;
	      state->LastTime = nowtime;

	      if (cp14r0 & ARMul_CP14_R0_CCD)
	        {
		  if (state->CP14R0_CCD == -1)
		    state->CP14R0_CCD = newcycles;
		  else
		    state->CP14R0_CCD += newcycles;

		  if (state->CP14R0_CCD >= 64)
		    {
		      newcycles = 0;

		      while (state->CP14R0_CCD >= 64)
		        state->CP14R0_CCD -= 64, newcycles++;

		      goto check_PMUintr;
		    }
		}
	      else
		{
		  ARMword cp14r1;
		  int do_int = 0;

		  state->CP14R0_CCD = -1;
check_PMUintr:
		  cp14r0 |= ARMul_CP14_R0_FLAG2;
		  (void) state->CPWrite[14] (state, 0, cp14r0);

		  ok = state->CPRead[14] (state, 1, & cp14r1);

		  /* Coded like this for portability.  */
		  while (ok && newcycles)
		    {
		      if (cp14r1 == 0xffffffff)
			{
			  cp14r1 = 0;
			  do_int = 1;
			}
		      else
			cp14r1 ++;

		      newcycles --;
		    }

		  (void) state->CPWrite[14] (state, 1, cp14r1);

		  if (do_int && (cp14r0 & ARMul_CP14_R0_INTEN2))
		    {
		      ARMword temp;

		      if (state->CPRead[13] (state, 8, & temp)
			  && (temp & ARMul_CP13_R8_PMUS))
		        ARMul_Abort (state, ARMul_FIQV);
		      else
		        ARMul_Abort (state, ARMul_IRQV);
		    }
		}
	    }
	}

      /* Handle hardware instructions breakpoints here.  */
      if (state->is_XScale)
	{
	  if (   (pc | 3) == (read_cp15_reg (14, 0, 8) | 2)
	      || (pc | 3) == (read_cp15_reg (14, 0, 9) | 2))
	    {
	      if (XScale_debug_moe (state, ARMul_CP14_R10_MOE_IB))
	        ARMul_OSHandleSWI (state, SWI_Breakpoint);
	    }
	}

      /* Actual execution of instructions begins here.  */
      /* If the condition codes don't match, stop here.  */
      if (temp)
	{
	mainswitch:

	  if (state->is_XScale)
	    {
	      if (BIT (20) == 0 && BITS (25, 27) == 0)
		{
		  if (BITS (4, 7) == 0xD)
		    {
		      /* XScale Load Consecutive insn.  */
		      ARMword temp = GetLS7RHS (state, instr);
		      ARMword temp2 = BIT (23) ? LHS + temp : LHS - temp;
		      ARMword addr = BIT (24) ? temp2 : LHS;
		      
		      if (BIT (12))
			ARMul_UndefInstr (state, instr);
		      else if (addr & 7)
			/* Alignment violation.  */
			ARMul_Abort (state, ARMul_DataAbortV);
		      else
			{
			  int wb = BIT (21) || (! BIT (24));
			  
			  state->Reg[BITS (12, 15)] =
			    ARMul_LoadWordN (state, addr);
			  state->Reg[BITS (12, 15) + 1] =
			    ARMul_LoadWordN (state, addr + 4);
			  if (wb)
			    LSBase = temp2;
			}

		      goto donext;
		    }
		  else if (BITS (4, 7) == 0xF)
		    {
		      /* XScale Store Consecutive insn.  */
		      ARMword temp = GetLS7RHS (state, instr);
		      ARMword temp2 = BIT (23) ? LHS + temp : LHS - temp;
		      ARMword addr = BIT (24) ? temp2 : LHS;

		      if (BIT (12))
			ARMul_UndefInstr (state, instr);
		      else if (addr & 7)
			/* Alignment violation.  */
			ARMul_Abort (state, ARMul_DataAbortV);
		      else
			{
			  ARMul_StoreWordN (state, addr,
					    state->Reg[BITS (12, 15)]);
			  ARMul_StoreWordN (state, addr + 4,
					    state->Reg[BITS (12, 15) + 1]);

			  if (BIT (21)|| ! BIT (24))
			    LSBase = temp2;
			}

		      goto donext;
		    }
		}

	      if (ARMul_HandleIwmmxt (state, instr))
		goto donext;
	    }

	  switch ((int) BITS (20, 27))
	    {
	      /* Data Processing Register RHS Instructions.  */

	    case 0x00:		/* AND reg and MUL */
#ifdef MODET
	      if (BITS (4, 11) == 0xB)
		{
		  /* STRH register offset, no write-back, down, post indexed.  */
		  SHDOWNWB ();
		  break;
		}
	      if (BITS (4, 7) == 0xD)
		{
		  Handle_Load_Double (state, instr);
		  break;
		}
	      if (BITS (4, 7) == 0xF)
		{
		  Handle_Store_Double (state, instr);
		  break;
		}
#endif
	      if (BITS (4, 7) == 9)
		{
		  /* MUL */
		  rhs = state->Reg[MULRHSReg];
		  if (MULLHSReg == MULDESTReg)
		    {
		      UNDEF_MULDestEQOp1;
		      state->Reg[MULDESTReg] = 0;
		    }
		  else if (MULDESTReg != 15)
		    state->Reg[MULDESTReg] = state->Reg[MULLHSReg] * rhs;
		  else
		    UNDEF_MULPCDest;

		  for (dest = 0, temp = 0; dest < 32; dest ++)
		    if (rhs & (1L << dest))
		      temp = dest;

		  /* Mult takes this many/2 I cycles.  */
		  ARMul_Icycles (state, ARMul_MultTable[temp], 0L);
		}
	      else
		{
		  /* AND reg.  */
		  rhs = DPRegRHS;
		  dest = LHS & rhs;
		  WRITEDEST (dest);
		}
	      break;

	    case 0x01:		/* ANDS reg and MULS */
#ifdef MODET
	      if ((BITS (4, 11) & 0xF9) == 0x9)
		/* LDR register offset, no write-back, down, post indexed.  */
		LHPOSTDOWN ();
	      /* Fall through to rest of decoding.  */
#endif
	      if (BITS (4, 7) == 9)
		{
		  /* MULS */
		  rhs = state->Reg[MULRHSReg];

		  if (MULLHSReg == MULDESTReg)
		    {
		      UNDEF_MULDestEQOp1;
		      state->Reg[MULDESTReg] = 0;
		      CLEARN;
		      SETZ;
		    }
		  else if (MULDESTReg != 15)
		    {
		      dest = state->Reg[MULLHSReg] * rhs;
		      ARMul_NegZero (state, dest);
		      state->Reg[MULDESTReg] = dest;
		    }
		  else
		    UNDEF_MULPCDest;

		  for (dest = 0, temp = 0; dest < 32; dest ++)
		    if (rhs & (1L << dest))
		      temp = dest;

		  /* Mult takes this many/2 I cycles.  */
		  ARMul_Icycles (state, ARMul_MultTable[temp], 0L);
		}
	      else
		{
		  /* ANDS reg.  */
		  rhs = DPSRegRHS;
		  dest = LHS & rhs;
		  WRITESDEST (dest);
		}
	      break;

	    case 0x02:		/* EOR reg and MLA */
#ifdef MODET
	      if (BITS (4, 11) == 0xB)
		{
		  /* STRH register offset, write-back, down, post indexed.  */
		  SHDOWNWB ();
		  break;
		}
#endif
	      if (BITS (4, 7) == 9)
		{		/* MLA */
		  rhs = state->Reg[MULRHSReg];
		  if (MULLHSReg == MULDESTReg)
		    {
		      UNDEF_MULDestEQOp1;
		      state->Reg[MULDESTReg] = state->Reg[MULACCReg];
		    }
		  else if (MULDESTReg != 15)
		    state->Reg[MULDESTReg] =
		      state->Reg[MULLHSReg] * rhs + state->Reg[MULACCReg];
		  else
		    UNDEF_MULPCDest;

		  for (dest = 0, temp = 0; dest < 32; dest ++)
		    if (rhs & (1L << dest))
		      temp = dest;

		  /* Mult takes this many/2 I cycles.  */
		  ARMul_Icycles (state, ARMul_MultTable[temp], 0L);
		}
	      else
		{
		  rhs = DPRegRHS;
		  dest = LHS ^ rhs;
		  WRITEDEST (dest);
		}
	      break;

	    case 0x03:		/* EORS reg and MLAS */
#ifdef MODET
	      if ((BITS (4, 11) & 0xF9) == 0x9)
		/* LDR register offset, write-back, down, post-indexed.  */
		LHPOSTDOWN ();
	      /* Fall through to rest of the decoding.  */
#endif
	      if (BITS (4, 7) == 9)
		{
		  /* MLAS */
		  rhs = state->Reg[MULRHSReg];

		  if (MULLHSReg == MULDESTReg)
		    {
		      UNDEF_MULDestEQOp1;
		      dest = state->Reg[MULACCReg];
		      ARMul_NegZero (state, dest);
		      state->Reg[MULDESTReg] = dest;
		    }
		  else if (MULDESTReg != 15)
		    {
		      dest =
			state->Reg[MULLHSReg] * rhs + state->Reg[MULACCReg];
		      ARMul_NegZero (state, dest);
		      state->Reg[MULDESTReg] = dest;
		    }
		  else
		    UNDEF_MULPCDest;

		  for (dest = 0, temp = 0; dest < 32; dest ++)
		    if (rhs & (1L << dest))
		      temp = dest;

		  /* Mult takes this many/2 I cycles.  */
		  ARMul_Icycles (state, ARMul_MultTable[temp], 0L);
		}
	      else
		{
		  /* EORS Reg.  */
		  rhs = DPSRegRHS;
		  dest = LHS ^ rhs;
		  WRITESDEST (dest);
		}
	      break;

	    case 0x04:		/* SUB reg */
#ifdef MODET
	      if (BITS (4, 7) == 0xB)
		{
		  /* STRH immediate offset, no write-back, down, post indexed.  */
		  SHDOWNWB ();
		  break;
		}
	      if (BITS (4, 7) == 0xD)
		{
		  Handle_Load_Double (state, instr);
		  break;
		}
	      if (BITS (4, 7) == 0xF)
		{
		  Handle_Store_Double (state, instr);
		  break;
		}
#endif
	      rhs = DPRegRHS;
	      dest = LHS - rhs;
	      WRITEDEST (dest);
	      break;

	    case 0x05:		/* SUBS reg */
#ifdef MODET
	      if ((BITS (4, 7) & 0x9) == 0x9)
		/* LDR immediate offset, no write-back, down, post indexed.  */
		LHPOSTDOWN ();
	      /* Fall through to the rest of the instruction decoding.  */
#endif
	      lhs = LHS;
	      rhs = DPRegRHS;
	      dest = lhs - rhs;

	      if ((lhs >= rhs) || ((rhs | lhs) >> 31))
		{
		  ARMul_SubCarry (state, lhs, rhs, dest);
		  ARMul_SubOverflow (state, lhs, rhs, dest);
		}
	      else
		{
		  CLEARC;
		  CLEARV;
		}
	      WRITESDEST (dest);
	      break;

	    case 0x06:		/* RSB reg */
#ifdef MODET
	      if (BITS (4, 7) == 0xB)
		{
		  /* STRH immediate offset, write-back, down, post indexed.  */
		  SHDOWNWB ();
		  break;
		}
#endif
	      rhs = DPRegRHS;
	      dest = rhs - LHS;
	      WRITEDEST (dest);
	      break;

	    case 0x07:		/* RSBS reg */
#ifdef MODET
	      if ((BITS (4, 7) & 0x9) == 0x9)
		/* LDR immediate offset, write-back, down, post indexed.  */
		LHPOSTDOWN ();
	      /* Fall through to remainder of instruction decoding.  */
#endif
	      lhs = LHS;
	      rhs = DPRegRHS;
	      dest = rhs - lhs;

	      if ((rhs >= lhs) || ((rhs | lhs) >> 31))
		{
		  ARMul_SubCarry (state, rhs, lhs, dest);
		  ARMul_SubOverflow (state, rhs, lhs, dest);
		}
	      else
		{
		  CLEARC;
		  CLEARV;
		}
	      WRITESDEST (dest);
	      break;

	    case 0x08:		/* ADD reg */
#ifdef MODET
	      if (BITS (4, 11) == 0xB)
		{
		  /* STRH register offset, no write-back, up, post indexed.  */
		  SHUPWB ();
		  break;
		}
	      if (BITS (4, 7) == 0xD)
		{
		  Handle_Load_Double (state, instr);
		  break;
		}
	      if (BITS (4, 7) == 0xF)
		{
		  Handle_Store_Double (state, instr);
		  break;
		}
#endif
#ifdef MODET
	      if (BITS (4, 7) == 0x9)
		{
		  /* MULL */
		  /* 32x32 = 64 */
		  ARMul_Icycles (state,
				 Multiply64 (state, instr, LUNSIGNED,
					     LDEFAULT), 0L);
		  break;
		}
#endif
	      rhs = DPRegRHS;
	      dest = LHS + rhs;
	      WRITEDEST (dest);
	      break;

	    case 0x09:		/* ADDS reg */
#ifdef MODET
	      if ((BITS (4, 11) & 0xF9) == 0x9)
		/* LDR register offset, no write-back, up, post indexed.  */
		LHPOSTUP ();
	      /* Fall through to remaining instruction decoding.  */
#endif
#ifdef MODET
	      if (BITS (4, 7) == 0x9)
		{
		  /* MULL */
		  /* 32x32=64 */
		  ARMul_Icycles (state,
				 Multiply64 (state, instr, LUNSIGNED, LSCC),
				 0L);
		  break;
		}
#endif
	      lhs = LHS;
	      rhs = DPRegRHS;
	      dest = lhs + rhs;
	      ASSIGNZ (dest == 0);
	      if ((lhs | rhs) >> 30)
		{
		  /* Possible C,V,N to set.  */
		  ASSIGNN (NEG (dest));
		  ARMul_AddCarry (state, lhs, rhs, dest);
		  ARMul_AddOverflow (state, lhs, rhs, dest);
		}
	      else
		{
		  CLEARN;
		  CLEARC;
		  CLEARV;
		}
	      WRITESDEST (dest);
	      break;

	    case 0x0a:		/* ADC reg */
#ifdef MODET
	      if (BITS (4, 11) == 0xB)
		{
		  /* STRH register offset, write-back, up, post-indexed.  */
		  SHUPWB ();
		  break;
		}
	      if (BITS (4, 7) == 0x9)
		{
		  /* MULL */
		  /* 32x32=64 */
		  ARMul_Icycles (state,
				 MultiplyAdd64 (state, instr, LUNSIGNED,
						LDEFAULT), 0L);
		  break;
		}
#endif
	      rhs = DPRegRHS;
	      dest = LHS + rhs + CFLAG;
	      WRITEDEST (dest);
	      break;

	    case 0x0b:		/* ADCS reg */
#ifdef MODET
	      if ((BITS (4, 11) & 0xF9) == 0x9)
		/* LDR register offset, write-back, up, post indexed.  */
		LHPOSTUP ();
	      /* Fall through to remaining instruction decoding.  */
	      if (BITS (4, 7) == 0x9)
		{
		  /* MULL */
		  /* 32x32=64 */
		  ARMul_Icycles (state,
				 MultiplyAdd64 (state, instr, LUNSIGNED,
						LSCC), 0L);
		  break;
		}
#endif
	      lhs = LHS;
	      rhs = DPRegRHS;
	      dest = lhs + rhs + CFLAG;
	      ASSIGNZ (dest == 0);
	      if ((lhs | rhs) >> 30)
		{
		  /* Possible C,V,N to set.  */
		  ASSIGNN (NEG (dest));
		  ARMul_AddCarry (state, lhs, rhs, dest);
		  ARMul_AddOverflow (state, lhs, rhs, dest);
		}
	      else
		{
		  CLEARN;
		  CLEARC;
		  CLEARV;
		}
	      WRITESDEST (dest);
	      break;

	    case 0x0c:		/* SBC reg */
#ifdef MODET
	      if (BITS (4, 7) == 0xB)
		{
		  /* STRH immediate offset, no write-back, up post indexed.  */
		  SHUPWB ();
		  break;
		}
	      if (BITS (4, 7) == 0xD)
		{
		  Handle_Load_Double (state, instr);
		  break;
		}
	      if (BITS (4, 7) == 0xF)
		{
		  Handle_Store_Double (state, instr);
		  break;
		}
	      if (BITS (4, 7) == 0x9)
		{
		  /* MULL */
		  /* 32x32=64 */
		  ARMul_Icycles (state,
				 Multiply64 (state, instr, LSIGNED, LDEFAULT),
				 0L);
		  break;
		}
#endif
	      rhs = DPRegRHS;
	      dest = LHS - rhs - !CFLAG;
	      WRITEDEST (dest);
	      break;

	    case 0x0d:		/* SBCS reg */
#ifdef MODET
	      if ((BITS (4, 7) & 0x9) == 0x9)
		/* LDR immediate offset, no write-back, up, post indexed.  */
		LHPOSTUP ();

	      if (BITS (4, 7) == 0x9)
		{
		  /* MULL */
		  /* 32x32=64 */
		  ARMul_Icycles (state,
				 Multiply64 (state, instr, LSIGNED, LSCC),
				 0L);
		  break;
		}
#endif
	      lhs = LHS;
	      rhs = DPRegRHS;
	      dest = lhs - rhs - !CFLAG;
	      if ((lhs >= rhs) || ((rhs | lhs) >> 31))
		{
		  ARMul_SubCarry (state, lhs, rhs, dest);
		  ARMul_SubOverflow (state, lhs, rhs, dest);
		}
	      else
		{
		  CLEARC;
		  CLEARV;
		}
	      WRITESDEST (dest);
	      break;

	    case 0x0e:		/* RSC reg */
#ifdef MODET
	      if (BITS (4, 7) == 0xB)
		{
		  /* STRH immediate offset, write-back, up, post indexed.  */
		  SHUPWB ();
		  break;
		}

	      if (BITS (4, 7) == 0x9)
		{
		  /* MULL */
		  /* 32x32=64 */
		  ARMul_Icycles (state,
				 MultiplyAdd64 (state, instr, LSIGNED,
						LDEFAULT), 0L);
		  break;
		}
#endif
	      rhs = DPRegRHS;
	      dest = rhs - LHS - !CFLAG;
	      WRITEDEST (dest);
	      break;

	    case 0x0f:		/* RSCS reg */
#ifdef MODET
	      if ((BITS (4, 7) & 0x9) == 0x9)
		/* LDR immediate offset, write-back, up, post indexed.  */
		LHPOSTUP ();
	      /* Fall through to remaining instruction decoding.  */

	      if (BITS (4, 7) == 0x9)
		{
		  /* MULL */
		  /* 32x32=64 */
		  ARMul_Icycles (state,
				 MultiplyAdd64 (state, instr, LSIGNED, LSCC),
				 0L);
		  break;
		}
#endif
	      lhs = LHS;
	      rhs = DPRegRHS;
	      dest = rhs - lhs - !CFLAG;

	      if ((rhs >= lhs) || ((rhs | lhs) >> 31))
		{
		  ARMul_SubCarry (state, rhs, lhs, dest);
		  ARMul_SubOverflow (state, rhs, lhs, dest);
		}
	      else
		{
		  CLEARC;
		  CLEARV;
		}
	      WRITESDEST (dest);
	      break;

	    case 0x10:		/* TST reg and MRS CPSR and SWP word.  */
	      if (state->is_v5e)
		{
		  if (BIT (4) == 0 && BIT (7) == 1)
		    {
		      /* ElSegundo SMLAxy insn.  */
		      ARMword op1 = state->Reg[BITS (0, 3)];
		      ARMword op2 = state->Reg[BITS (8, 11)];
		      ARMword Rn = state->Reg[BITS (12, 15)];
		      
		      if (BIT (5))
			op1 >>= 16;
		      if (BIT (6))
			op2 >>= 16;
		      op1 &= 0xFFFF;
		      op2 &= 0xFFFF;
		      if (op1 & 0x8000)
			op1 -= 65536;
		      if (op2 & 0x8000)
			op2 -= 65536;
		      op1 *= op2;
		      
		      if (AddOverflow (op1, Rn, op1 + Rn))
			SETS;
		      state->Reg[BITS (16, 19)] = op1 + Rn;
		      break;
		    }

		  if (BITS (4, 11) == 5)
		    {
		      /* ElSegundo QADD insn.  */
		      ARMword op1 = state->Reg[BITS (0, 3)];
		      ARMword op2 = state->Reg[BITS (16, 19)];
		      ARMword result = op1 + op2;
		      if (AddOverflow (op1, op2, result))
			{
			  result = POS (result) ? 0x80000000 : 0x7fffffff;
			  SETS;
			}
		      state->Reg[BITS (12, 15)] = result;
		      break;
		    }
		}
#ifdef MODET
	      if (BITS (4, 11) == 0xB)
		{
		  /* STRH register offset, no write-back, down, pre indexed.  */
		  SHPREDOWN ();
		  break;
		}
	      if (BITS (4, 7) == 0xD)
		{
		  Handle_Load_Double (state, instr);
		  break;
		}
	      if (BITS (4, 7) == 0xF)
		{
		  Handle_Store_Double (state, instr);
		  break;
		}
#endif
	      if (BITS (4, 11) == 9)
		{
		  /* SWP */
		  UNDEF_SWPPC;
		  temp = LHS;
		  BUSUSEDINCPCS;
#ifndef MODE32
		  if (VECTORACCESS (temp) || ADDREXCEPT (temp))
		    {
		      INTERNALABORT (temp);
		      (void) ARMul_LoadWordN (state, temp);
		      (void) ARMul_LoadWordN (state, temp);
		    }
		  else
#endif
		    dest = ARMul_SwapWord (state, temp, state->Reg[RHSReg]);
		  if (temp & 3)
		    DEST = ARMul_Align (state, temp, dest);
		  else
		    DEST = dest;
		  if (state->abortSig || state->Aborted)
		    TAKEABORT;
		}
	      else if ((BITS (0, 11) == 0) && (LHSReg == 15))
		{		/* MRS CPSR */
		  UNDEF_MRSPC;
		  DEST = ECC | EINT | EMODE;
		}
	      else
		{
		  UNDEF_Test;
		}
	      break;

	    case 0x11:		/* TSTP reg */
#ifdef MODET
	      if ((BITS (4, 11) & 0xF9) == 0x9)
		/* LDR register offset, no write-back, down, pre indexed.  */
		LHPREDOWN ();
	      /* Continue with remaining instruction decode.  */
#endif
	      if (DESTReg == 15)
		{
		  /* TSTP reg */
#ifdef MODE32
		  state->Cpsr = GETSPSR (state->Bank);
		  ARMul_CPSRAltered (state);
#else
		  rhs = DPRegRHS;
		  temp = LHS & rhs;
		  SETR15PSR (temp);
#endif
		}
	      else
		{
		  /* TST reg */
		  rhs = DPSRegRHS;
		  dest = LHS & rhs;
		  ARMul_NegZero (state, dest);
		}
	      break;

	    case 0x12:		/* TEQ reg and MSR reg to CPSR (ARM6).  */
	      if (state->is_v5)
		{
		  if (BITS (4, 7) == 3)
		    {
		      /* BLX(2) */
		      ARMword temp;

		      if (TFLAG)
			temp = (pc + 2) | 1;
		      else
			temp = pc + 4;

		      WriteR15Branch (state, state->Reg[RHSReg]);
		      state->Reg[14] = temp;
		      break;
		    }
		}

	      if (state->is_v5e)
		{
		  if (BIT (4) == 0 && BIT (7) == 1
		      && (BIT (5) == 0 || BITS (12, 15) == 0))
		    {
		      /* ElSegundo SMLAWy/SMULWy insn.  */
		      ARMdword op1 = state->Reg[BITS (0, 3)];
		      ARMdword op2 = state->Reg[BITS (8, 11)];
		      ARMdword result;

		      if (BIT (6))
			op2 >>= 16;
		      if (op1 & 0x80000000)
			op1 -= 1ULL << 32;
		      op2 &= 0xFFFF;
		      if (op2 & 0x8000)
			op2 -= 65536;
		      result = (op1 * op2) >> 16;

		      if (BIT (5) == 0)
			{
			  ARMword Rn = state->Reg[BITS (12, 15)];
			  
			  if (AddOverflow (result, Rn, result + Rn))
			    SETS;
			  result += Rn;
			}
		      state->Reg[BITS (16, 19)] = result;
		      break;
		    }

		  if (BITS (4, 11) == 5)
		    {
		      /* ElSegundo QSUB insn.  */
		      ARMword op1 = state->Reg[BITS (0, 3)];
		      ARMword op2 = state->Reg[BITS (16, 19)];
		      ARMword result = op1 - op2;

		      if (SubOverflow (op1, op2, result))
			{
			  result = POS (result) ? 0x80000000 : 0x7fffffff;
			  SETS;
			}

		      state->Reg[BITS (12, 15)] = result;
		      break;
		    }
		}
#ifdef MODET
	      if (BITS (4, 11) == 0xB)
		{
		  /* STRH register offset, write-back, down, pre indexed.  */
		  SHPREDOWNWB ();
		  break;
		}
	      if (BITS (4, 27) == 0x12FFF1)
		{
		  /* BX */
		  WriteR15Branch (state, state->Reg[RHSReg]);
		  break;
		}
	      if (BITS (4, 7) == 0xD)
		{
		  Handle_Load_Double (state, instr);
		  break;
		}
	      if (BITS (4, 7) == 0xF)
		{
		  Handle_Store_Double (state, instr);
		  break;
		}
#endif
	      if (state->is_v5)
		{
		  if (BITS (4, 7) == 0x7)
		    {
		      ARMword value;
		      extern int SWI_vector_installed;

		      /* Hardware is allowed to optionally override this
			 instruction and treat it as a breakpoint.  Since
			 this is a simulator not hardware, we take the position
			 that if a SWI vector was not installed, then an Abort
			 vector was probably not installed either, and so
			 normally this instruction would be ignored, even if an
			 Abort is generated.  This is a bad thing, since GDB
			 uses this instruction for its breakpoints (at least in
			 Thumb mode it does).  So intercept the instruction here
			 and generate a breakpoint SWI instead.  */
		      if (! SWI_vector_installed)
			ARMul_OSHandleSWI (state, SWI_Breakpoint);
		      else
			{
			  /* BKPT - normally this will cause an abort, but on the
			     XScale we must check the DCSR.  */
			  XScale_set_fsr_far (state, ARMul_CP15_R5_MMU_EXCPT, pc);
	                  if (!XScale_debug_moe (state, ARMul_CP14_R10_MOE_BT))
			    break;
			}

		      /* Force the next instruction to be refetched.  */
		      state->NextInstr = RESUME;
		      break;
		    }
		}
	      if (DESTReg == 15)
		{
		  /* MSR reg to CPSR.  */
		  UNDEF_MSRPC;
		  temp = DPRegRHS;
#ifdef MODET
		  /* Don't allow TBIT to be set by MSR.  */
		  temp &= ~ TBIT;
#endif
		  ARMul_FixCPSR (state, instr, temp);
		}
	      else
		UNDEF_Test;

	      break;

	    case 0x13:		/* TEQP reg */
#ifdef MODET
	      if ((BITS (4, 11) & 0xF9) == 0x9)
		/* LDR register offset, write-back, down, pre indexed.  */
		LHPREDOWNWB ();
	      /* Continue with remaining instruction decode.  */
#endif
	      if (DESTReg == 15)
		{
		  /* TEQP reg */
#ifdef MODE32
		  state->Cpsr = GETSPSR (state->Bank);
		  ARMul_CPSRAltered (state);
#else
		  rhs = DPRegRHS;
		  temp = LHS ^ rhs;
		  SETR15PSR (temp);
#endif
		}
	      else
		{
		  /* TEQ Reg.  */
		  rhs = DPSRegRHS;
		  dest = LHS ^ rhs;
		  ARMul_NegZero (state, dest);
		}
	      break;

	    case 0x14:		/* CMP reg and MRS SPSR and SWP byte.  */
	      if (state->is_v5e)
		{
		  if (BIT (4) == 0 && BIT (7) == 1)
		    {
		      /* ElSegundo SMLALxy insn.  */
		      ARMdword op1 = state->Reg[BITS (0, 3)];
		      ARMdword op2 = state->Reg[BITS (8, 11)];
		      ARMdword dest;
		      ARMdword result;

		      if (BIT (5))
			op1 >>= 16;
		      if (BIT (6))
			op2 >>= 16;
		      op1 &= 0xFFFF;
		      if (op1 & 0x8000)
			op1 -= 65536;
		      op2 &= 0xFFFF;
		      if (op2 & 0x8000)
			op2 -= 65536;

		      dest = (ARMdword) state->Reg[BITS (16, 19)] << 32;
		      dest |= state->Reg[BITS (12, 15)];
		      dest += op1 * op2;
		      state->Reg[BITS (12, 15)] = dest;
		      state->Reg[BITS (16, 19)] = dest >> 32;
		      break;
		    }

		  if (BITS (4, 11) == 5)
		    {
		      /* ElSegundo QDADD insn.  */
		      ARMword op1 = state->Reg[BITS (0, 3)];
		      ARMword op2 = state->Reg[BITS (16, 19)];
		      ARMword op2d = op2 + op2;
		      ARMword result;

		      if (AddOverflow (op2, op2, op2d))
			{
			  SETS;
			  op2d = POS (op2d) ? 0x80000000 : 0x7fffffff;
			}

		      result = op1 + op2d;
		      if (AddOverflow (op1, op2d, result))
			{
			  SETS;
			  result = POS (result) ? 0x80000000 : 0x7fffffff;
			}

		      state->Reg[BITS (12, 15)] = result;
		      break;
		    }
		}
#ifdef MODET
	      if (BITS (4, 7) == 0xB)
		{
		  /* STRH immediate offset, no write-back, down, pre indexed.  */
		  SHPREDOWN ();
		  break;
		}
	      if (BITS (4, 7) == 0xD)
		{
		  Handle_Load_Double (state, instr);
		  break;
		}
	      if (BITS (4, 7) == 0xF)
		{
		  Handle_Store_Double (state, instr);
		  break;
		}
#endif
	      if (BITS (4, 11) == 9)
		{
		  /* SWP */
		  UNDEF_SWPPC;
		  temp = LHS;
		  BUSUSEDINCPCS;
#ifndef MODE32
		  if (VECTORACCESS (temp) || ADDREXCEPT (temp))
		    {
		      INTERNALABORT (temp);
		      (void) ARMul_LoadByte (state, temp);
		      (void) ARMul_LoadByte (state, temp);
		    }
		  else
#endif
		    DEST = ARMul_SwapByte (state, temp, state->Reg[RHSReg]);
		  if (state->abortSig || state->Aborted)
		    TAKEABORT;
		}
	      else if ((BITS (0, 11) == 0) && (LHSReg == 15))
		{
		  /* MRS SPSR */
		  UNDEF_MRSPC;
		  DEST = GETSPSR (state->Bank);
		}
	      else
		UNDEF_Test;

	      break;

	    case 0x15:		/* CMPP reg.  */
#ifdef MODET
	      if ((BITS (4, 7) & 0x9) == 0x9)
		/* LDR immediate offset, no write-back, down, pre indexed.  */
		LHPREDOWN ();
	      /* Continue with remaining instruction decode.  */
#endif
	      if (DESTReg == 15)
		{
		  /* CMPP reg.  */
#ifdef MODE32
		  state->Cpsr = GETSPSR (state->Bank);
		  ARMul_CPSRAltered (state);
#else
		  rhs = DPRegRHS;
		  temp = LHS - rhs;
		  SETR15PSR (temp);
#endif
		}
	      else
		{
		  /* CMP reg.  */
		  lhs = LHS;
		  rhs = DPRegRHS;
		  dest = lhs - rhs;
		  ARMul_NegZero (state, dest);
		  if ((lhs >= rhs) || ((rhs | lhs) >> 31))
		    {
		      ARMul_SubCarry (state, lhs, rhs, dest);
		      ARMul_SubOverflow (state, lhs, rhs, dest);
		    }
		  else
		    {
		      CLEARC;
		      CLEARV;
		    }
		}
	      break;

	    case 0x16:		/* CMN reg and MSR reg to SPSR */
	      if (state->is_v5e)
		{
		  if (BIT (4) == 0 && BIT (7) == 1 && BITS (12, 15) == 0)
		    {
		      /* ElSegundo SMULxy insn.  */
		      ARMword op1 = state->Reg[BITS (0, 3)];
		      ARMword op2 = state->Reg[BITS (8, 11)];
		      ARMword Rn = state->Reg[BITS (12, 15)];

		      if (BIT (5))
			op1 >>= 16;
		      if (BIT (6))
			op2 >>= 16;
		      op1 &= 0xFFFF;
		      op2 &= 0xFFFF;
		      if (op1 & 0x8000)
			op1 -= 65536;
		      if (op2 & 0x8000)
			op2 -= 65536;

		      state->Reg[BITS (16, 19)] = op1 * op2;
		      break;
		    }

		  if (BITS (4, 11) == 5)
		    {
		      /* ElSegundo QDSUB insn.  */
		      ARMword op1 = state->Reg[BITS (0, 3)];
		      ARMword op2 = state->Reg[BITS (16, 19)];
		      ARMword op2d = op2 + op2;
		      ARMword result;

		      if (AddOverflow (op2, op2, op2d))
			{
			  SETS;
			  op2d = POS (op2d) ? 0x80000000 : 0x7fffffff;
			}

		      result = op1 - op2d;
		      if (SubOverflow (op1, op2d, result))
			{
			  SETS;
			  result = POS (result) ? 0x80000000 : 0x7fffffff;
			}

		      state->Reg[BITS (12, 15)] = result;
		      break;
		    }
		}

	      if (state->is_v5)
		{
		  if (BITS (4, 11) == 0xF1 && BITS (16, 19) == 0xF)
		    {
		      /* ARM5 CLZ insn.  */
		      ARMword op1 = state->Reg[BITS (0, 3)];
		      int result = 32;

		      if (op1)
			for (result = 0; (op1 & 0x80000000) == 0; op1 <<= 1)
			  result++;

		      state->Reg[BITS (12, 15)] = result;
		      break;
		    }
		}
#ifdef MODET
	      if (BITS (4, 7) == 0xB)
		{
		  /* STRH immediate offset, write-back, down, pre indexed.  */
		  SHPREDOWNWB ();
		  break;
		}
	      if (BITS (4, 7) == 0xD)
		{
		  Handle_Load_Double (state, instr);
		  break;
		}
	      if (BITS (4, 7) == 0xF)
		{
		  Handle_Store_Double (state, instr);
		  break;
		}
#endif
	      if (DESTReg == 15)
		{
		  /* MSR */
		  UNDEF_MSRPC;
		  ARMul_FixSPSR (state, instr, DPRegRHS);
		}
	      else
		{
		  UNDEF_Test;
		}
	      break;

	    case 0x17:		/* CMNP reg */
#ifdef MODET
	      if ((BITS (4, 7) & 0x9) == 0x9)
		/* LDR immediate offset, write-back, down, pre indexed.  */
		LHPREDOWNWB ();
	      /* Continue with remaining instruction decoding.  */
#endif
	      if (DESTReg == 15)
		{
#ifdef MODE32
		  state->Cpsr = GETSPSR (state->Bank);
		  ARMul_CPSRAltered (state);
#else
		  rhs = DPRegRHS;
		  temp = LHS + rhs;
		  SETR15PSR (temp);
#endif
		  break;
		}
	      else
		{
		  /* CMN reg.  */
		  lhs = LHS;
		  rhs = DPRegRHS;
		  dest = lhs + rhs;
		  ASSIGNZ (dest == 0);
		  if ((lhs | rhs) >> 30)
		    {
		      /* Possible C,V,N to set.  */
		      ASSIGNN (NEG (dest));
		      ARMul_AddCarry (state, lhs, rhs, dest);
		      ARMul_AddOverflow (state, lhs, rhs, dest);
		    }
		  else
		    {
		      CLEARN;
		      CLEARC;
		      CLEARV;
		    }
		}
	      break;

	    case 0x18:		/* ORR reg */
#ifdef MODET
	      if (BITS (4, 11) == 0xB)
		{
		  /* STRH register offset, no write-back, up, pre indexed.  */
		  SHPREUP ();
		  break;
		}
	      if (BITS (4, 7) == 0xD)
		{
		  Handle_Load_Double (state, instr);
		  break;
		}
	      if (BITS (4, 7) == 0xF)
		{
		  Handle_Store_Double (state, instr);
		  break;
		}
#endif
	      rhs = DPRegRHS;
	      dest = LHS | rhs;
	      WRITEDEST (dest);
	      break;

	    case 0x19:		/* ORRS reg */
#ifdef MODET
	      if ((BITS (4, 11) & 0xF9) == 0x9)
		/* LDR register offset, no write-back, up, pre indexed.  */
		LHPREUP ();
	      /* Continue with remaining instruction decoding.  */
#endif
	      rhs = DPSRegRHS;
	      dest = LHS | rhs;
	      WRITESDEST (dest);
	      break;

	    case 0x1a:		/* MOV reg */
#ifdef MODET
	      if (BITS (4, 11) == 0xB)
		{
		  /* STRH register offset, write-back, up, pre indexed.  */
		  SHPREUPWB ();
		  break;
		}
	      if (BITS (4, 7) == 0xD)
		{
		  Handle_Load_Double (state, instr);
		  break;
		}
	      if (BITS (4, 7) == 0xF)
		{
		  Handle_Store_Double (state, instr);
		  break;
		}
#endif
	      dest = DPRegRHS;
	      WRITEDEST (dest);
	      break;

	    case 0x1b:		/* MOVS reg */
#ifdef MODET
	      if ((BITS (4, 11) & 0xF9) == 0x9)
		/* LDR register offset, write-back, up, pre indexed.  */
		LHPREUPWB ();
	      /* Continue with remaining instruction decoding.  */
#endif
	      dest = DPSRegRHS;
	      WRITESDEST (dest);
	      break;

	    case 0x1c:		/* BIC reg */
#ifdef MODET
	      if (BITS (4, 7) == 0xB)
		{
		  /* STRH immediate offset, no write-back, up, pre indexed.  */
		  SHPREUP ();
		  break;
		}
	      if (BITS (4, 7) == 0xD)
		{
		  Handle_Load_Double (state, instr);
		  break;
		}
	      else if (BITS (4, 7) == 0xF)
		{
		  Handle_Store_Double (state, instr);
		  break;
		}
#endif
	      rhs = DPRegRHS;
	      dest = LHS & ~rhs;
	      WRITEDEST (dest);
	      break;

	    case 0x1d:		/* BICS reg */
#ifdef MODET
	      if ((BITS (4, 7) & 0x9) == 0x9)
		/* LDR immediate offset, no write-back, up, pre indexed.  */
		LHPREUP ();
	      /* Continue with instruction decoding.  */
#endif
	      rhs = DPSRegRHS;
	      dest = LHS & ~rhs;
	      WRITESDEST (dest);
	      break;

	    case 0x1e:		/* MVN reg */
#ifdef MODET
	      if (BITS (4, 7) == 0xB)
		{
		  /* STRH immediate offset, write-back, up, pre indexed.  */
		  SHPREUPWB ();
		  break;
		}
	      if (BITS (4, 7) == 0xD)
		{
		  Handle_Load_Double (state, instr);
		  break;
		}
	      if (BITS (4, 7) == 0xF)
		{
		  Handle_Store_Double (state, instr);
		  break;
		}
#endif
	      dest = ~DPRegRHS;
	      WRITEDEST (dest);
	      break;

	    case 0x1f:		/* MVNS reg */
#ifdef MODET
	      if ((BITS (4, 7) & 0x9) == 0x9)
		/* LDR immediate offset, write-back, up, pre indexed.  */
		LHPREUPWB ();
	      /* Continue instruction decoding.  */
#endif
	      dest = ~DPSRegRHS;
	      WRITESDEST (dest);
	      break;


	      /* Data Processing Immediate RHS Instructions.  */

	    case 0x20:		/* AND immed */
	      dest = LHS & DPImmRHS;
	      WRITEDEST (dest);
	      break;

	    case 0x21:		/* ANDS immed */
	      DPSImmRHS;
	      dest = LHS & rhs;
	      WRITESDEST (dest);
	      break;

	    case 0x22:		/* EOR immed */
	      dest = LHS ^ DPImmRHS;
	      WRITEDEST (dest);
	      break;

	    case 0x23:		/* EORS immed */
	      DPSImmRHS;
	      dest = LHS ^ rhs;
	      WRITESDEST (dest);
	      break;

	    case 0x24:		/* SUB immed */
	      dest = LHS - DPImmRHS;
	      WRITEDEST (dest);
	      break;

	    case 0x25:		/* SUBS immed */
	      lhs = LHS;
	      rhs = DPImmRHS;
	      dest = lhs - rhs;

	      if ((lhs >= rhs) || ((rhs | lhs) >> 31))
		{
		  ARMul_SubCarry (state, lhs, rhs, dest);
		  ARMul_SubOverflow (state, lhs, rhs, dest);
		}
	      else
		{
		  CLEARC;
		  CLEARV;
		}
	      WRITESDEST (dest);
	      break;

	    case 0x26:		/* RSB immed */
	      dest = DPImmRHS - LHS;
	      WRITEDEST (dest);
	      break;

	    case 0x27:		/* RSBS immed */
	      lhs = LHS;
	      rhs = DPImmRHS;
	      dest = rhs - lhs;

	      if ((rhs >= lhs) || ((rhs | lhs) >> 31))
		{
		  ARMul_SubCarry (state, rhs, lhs, dest);
		  ARMul_SubOverflow (state, rhs, lhs, dest);
		}
	      else
		{
		  CLEARC;
		  CLEARV;
		}
	      WRITESDEST (dest);
	      break;

	    case 0x28:		/* ADD immed */
	      dest = LHS + DPImmRHS;
	      WRITEDEST (dest);
	      break;

	    case 0x29:		/* ADDS immed */
	      lhs = LHS;
	      rhs = DPImmRHS;
	      dest = lhs + rhs;
	      ASSIGNZ (dest == 0);

	      if ((lhs | rhs) >> 30)
		{
		  /* Possible C,V,N to set.  */
		  ASSIGNN (NEG (dest));
		  ARMul_AddCarry (state, lhs, rhs, dest);
		  ARMul_AddOverflow (state, lhs, rhs, dest);
		}
	      else
		{
		  CLEARN;
		  CLEARC;
		  CLEARV;
		}
	      WRITESDEST (dest);
	      break;

	    case 0x2a:		/* ADC immed */
	      dest = LHS + DPImmRHS + CFLAG;
	      WRITEDEST (dest);
	      break;

	    case 0x2b:		/* ADCS immed */
	      lhs = LHS;
	      rhs = DPImmRHS;
	      dest = lhs + rhs + CFLAG;
	      ASSIGNZ (dest == 0);
	      if ((lhs | rhs) >> 30)
		{
		  /* Possible C,V,N to set.  */
		  ASSIGNN (NEG (dest));
		  ARMul_AddCarry (state, lhs, rhs, dest);
		  ARMul_AddOverflow (state, lhs, rhs, dest);
		}
	      else
		{
		  CLEARN;
		  CLEARC;
		  CLEARV;
		}
	      WRITESDEST (dest);
	      break;

	    case 0x2c:		/* SBC immed */
	      dest = LHS - DPImmRHS - !CFLAG;
	      WRITEDEST (dest);
	      break;

	    case 0x2d:		/* SBCS immed */
	      lhs = LHS;
	      rhs = DPImmRHS;
	      dest = lhs - rhs - !CFLAG;
	      if ((lhs >= rhs) || ((rhs | lhs) >> 31))
		{
		  ARMul_SubCarry (state, lhs, rhs, dest);
		  ARMul_SubOverflow (state, lhs, rhs, dest);
		}
	      else
		{
		  CLEARC;
		  CLEARV;
		}
	      WRITESDEST (dest);
	      break;

	    case 0x2e:		/* RSC immed */
	      dest = DPImmRHS - LHS - !CFLAG;
	      WRITEDEST (dest);
	      break;

	    case 0x2f:		/* RSCS immed */
	      lhs = LHS;
	      rhs = DPImmRHS;
	      dest = rhs - lhs - !CFLAG;
	      if ((rhs >= lhs) || ((rhs | lhs) >> 31))
		{
		  ARMul_SubCarry (state, rhs, lhs, dest);
		  ARMul_SubOverflow (state, rhs, lhs, dest);
		}
	      else
		{
		  CLEARC;
		  CLEARV;
		}
	      WRITESDEST (dest);
	      break;

	    case 0x30:		/* MOVW immed */
	      dest = BITS (0, 11);
	      dest |= (BITS (16, 19) << 12);
	      WRITEDEST (dest);
	      break;

	    case 0x31:		/* TSTP immed */
	      if (DESTReg == 15)
		{
		  /* TSTP immed.  */
#ifdef MODE32
		  state->Cpsr = GETSPSR (state->Bank);
		  ARMul_CPSRAltered (state);
#else
		  temp = LHS & DPImmRHS;
		  SETR15PSR (temp);
#endif
		}
	      else
		{
		  /* TST immed.  */
		  DPSImmRHS;
		  dest = LHS & rhs;
		  ARMul_NegZero (state, dest);
		}
	      break;

	    case 0x32:		/* TEQ immed and MSR immed to CPSR */
	      if (DESTReg == 15)
		/* MSR immed to CPSR.  */
		ARMul_FixCPSR (state, instr, DPImmRHS);
	      else
		UNDEF_Test;
	      break;

	    case 0x33:		/* TEQP immed */
	      if (DESTReg == 15)
		{
		  /* TEQP immed.  */
#ifdef MODE32
		  state->Cpsr = GETSPSR (state->Bank);
		  ARMul_CPSRAltered (state);
#else
		  temp = LHS ^ DPImmRHS;
		  SETR15PSR (temp);
#endif
		}
	      else
		{
		  DPSImmRHS;	/* TEQ immed */
		  dest = LHS ^ rhs;
		  ARMul_NegZero (state, dest);
		}
	      break;

	    case 0x34:		/* MOVT immed */
	      dest  = BITS (0, 11);
	      dest |= (BITS (16, 19) << 12);
	      DEST |= (dest << 16);
	      break;

	    case 0x35:		/* CMPP immed */
	      if (DESTReg == 15)
		{
		  /* CMPP immed.  */
#ifdef MODE32
		  state->Cpsr = GETSPSR (state->Bank);
		  ARMul_CPSRAltered (state);
#else
		  temp = LHS - DPImmRHS;
		  SETR15PSR (temp);
#endif
		  break;
		}
	      else
		{
		  /* CMP immed.  */
		  lhs = LHS;
		  rhs = DPImmRHS;
		  dest = lhs - rhs;
		  ARMul_NegZero (state, dest);

		  if ((lhs >= rhs) || ((rhs | lhs) >> 31))
		    {
		      ARMul_SubCarry (state, lhs, rhs, dest);
		      ARMul_SubOverflow (state, lhs, rhs, dest);
		    }
		  else
		    {
		      CLEARC;
		      CLEARV;
		    }
		}
	      break;

	    case 0x36:		/* CMN immed and MSR immed to SPSR */
	      if (DESTReg == 15)
		ARMul_FixSPSR (state, instr, DPImmRHS);
	      else
		UNDEF_Test;
	      break;

	    case 0x37:		/* CMNP immed.  */
	      if (DESTReg == 15)
		{
		  /* CMNP immed.  */
#ifdef MODE32
		  state->Cpsr = GETSPSR (state->Bank);
		  ARMul_CPSRAltered (state);
#else
		  temp = LHS + DPImmRHS;
		  SETR15PSR (temp);
#endif
		  break;
		}
	      else
		{
		  /* CMN immed.  */
		  lhs = LHS;
		  rhs = DPImmRHS;
		  dest = lhs + rhs;
		  ASSIGNZ (dest == 0);
		  if ((lhs | rhs) >> 30)
		    {
		      /* Possible C,V,N to set.  */
		      ASSIGNN (NEG (dest));
		      ARMul_AddCarry (state, lhs, rhs, dest);
		      ARMul_AddOverflow (state, lhs, rhs, dest);
		    }
		  else
		    {
		      CLEARN;
		      CLEARC;
		      CLEARV;
		    }
		}
	      break;

	    case 0x38:		/* ORR immed.  */
	      dest = LHS | DPImmRHS;
	      WRITEDEST (dest);
	      break;

	    case 0x39:		/* ORRS immed.  */
	      DPSImmRHS;
	      dest = LHS | rhs;
	      WRITESDEST (dest);
	      break;

	    case 0x3a:		/* MOV immed.  */
	      dest = DPImmRHS;
	      WRITEDEST (dest);
	      break;

	    case 0x3b:		/* MOVS immed.  */
	      DPSImmRHS;
	      WRITESDEST (rhs);
	      break;

	    case 0x3c:		/* BIC immed.  */
	      dest = LHS & ~DPImmRHS;
	      WRITEDEST (dest);
	      break;

	    case 0x3d:		/* BICS immed.  */
	      DPSImmRHS;
	      dest = LHS & ~rhs;
	      WRITESDEST (dest);
	      break;

	    case 0x3e:		/* MVN immed.  */
	      dest = ~DPImmRHS;
	      WRITEDEST (dest);
	      break;

	    case 0x3f:		/* MVNS immed.  */
	      DPSImmRHS;
	      WRITESDEST (~rhs);
	      break;


	      /* Single Data Transfer Immediate RHS Instructions.  */

	    case 0x40:		/* Store Word, No WriteBack, Post Dec, Immed.  */
	      lhs = LHS;
	      if (StoreWord (state, instr, lhs))
		LSBase = lhs - LSImmRHS;
	      break;

	    case 0x41:		/* Load Word, No WriteBack, Post Dec, Immed.  */
	      lhs = LHS;
	      if (LoadWord (state, instr, lhs))
		LSBase = lhs - LSImmRHS;
	      break;

	    case 0x42:		/* Store Word, WriteBack, Post Dec, Immed.  */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      lhs = LHS;
	      temp = lhs - LSImmRHS;
	      state->NtransSig = LOW;
	      if (StoreWord (state, instr, lhs))
		LSBase = temp;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x43:		/* Load Word, WriteBack, Post Dec, Immed.  */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (LoadWord (state, instr, lhs))
		LSBase = lhs - LSImmRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x44:		/* Store Byte, No WriteBack, Post Dec, Immed.  */
	      lhs = LHS;
	      if (StoreByte (state, instr, lhs))
		LSBase = lhs - LSImmRHS;
	      break;

	    case 0x45:		/* Load Byte, No WriteBack, Post Dec, Immed.  */
	      lhs = LHS;
	      if (LoadByte (state, instr, lhs, LUNSIGNED))
		LSBase = lhs - LSImmRHS;
	      break;

	    case 0x46:		/* Store Byte, WriteBack, Post Dec, Immed.  */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (StoreByte (state, instr, lhs))
		LSBase = lhs - LSImmRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x47:		/* Load Byte, WriteBack, Post Dec, Immed.  */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (LoadByte (state, instr, lhs, LUNSIGNED))
		LSBase = lhs - LSImmRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x48:		/* Store Word, No WriteBack, Post Inc, Immed.  */
	      lhs = LHS;
	      if (StoreWord (state, instr, lhs))
		LSBase = lhs + LSImmRHS;
	      break;

	    case 0x49:		/* Load Word, No WriteBack, Post Inc, Immed.  */
	      lhs = LHS;
	      if (LoadWord (state, instr, lhs))
		LSBase = lhs + LSImmRHS;
	      break;

	    case 0x4a:		/* Store Word, WriteBack, Post Inc, Immed.  */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (StoreWord (state, instr, lhs))
		LSBase = lhs + LSImmRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x4b:		/* Load Word, WriteBack, Post Inc, Immed.  */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (LoadWord (state, instr, lhs))
		LSBase = lhs + LSImmRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x4c:		/* Store Byte, No WriteBack, Post Inc, Immed.  */
	      lhs = LHS;
	      if (StoreByte (state, instr, lhs))
		LSBase = lhs + LSImmRHS;
	      break;

	    case 0x4d:		/* Load Byte, No WriteBack, Post Inc, Immed.  */
	      lhs = LHS;
	      if (LoadByte (state, instr, lhs, LUNSIGNED))
		LSBase = lhs + LSImmRHS;
	      break;

	    case 0x4e:		/* Store Byte, WriteBack, Post Inc, Immed.  */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (StoreByte (state, instr, lhs))
		LSBase = lhs + LSImmRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x4f:		/* Load Byte, WriteBack, Post Inc, Immed.  */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (LoadByte (state, instr, lhs, LUNSIGNED))
		LSBase = lhs + LSImmRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;


	    case 0x50:		/* Store Word, No WriteBack, Pre Dec, Immed.  */
	      (void) StoreWord (state, instr, LHS - LSImmRHS);
	      break;

	    case 0x51:		/* Load Word, No WriteBack, Pre Dec, Immed.  */
	      (void) LoadWord (state, instr, LHS - LSImmRHS);
	      break;

	    case 0x52:		/* Store Word, WriteBack, Pre Dec, Immed.  */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      temp = LHS - LSImmRHS;
	      if (StoreWord (state, instr, temp))
		LSBase = temp;
	      break;

	    case 0x53:		/* Load Word, WriteBack, Pre Dec, Immed.  */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      temp = LHS - LSImmRHS;
	      if (LoadWord (state, instr, temp))
		LSBase = temp;
	      break;

	    case 0x54:		/* Store Byte, No WriteBack, Pre Dec, Immed.  */
	      (void) StoreByte (state, instr, LHS - LSImmRHS);
	      break;

	    case 0x55:		/* Load Byte, No WriteBack, Pre Dec, Immed.  */
	      (void) LoadByte (state, instr, LHS - LSImmRHS, LUNSIGNED);
	      break;

	    case 0x56:		/* Store Byte, WriteBack, Pre Dec, Immed.  */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      temp = LHS - LSImmRHS;
	      if (StoreByte (state, instr, temp))
		LSBase = temp;
	      break;

	    case 0x57:		/* Load Byte, WriteBack, Pre Dec, Immed.  */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      temp = LHS - LSImmRHS;
	      if (LoadByte (state, instr, temp, LUNSIGNED))
		LSBase = temp;
	      break;

	    case 0x58:		/* Store Word, No WriteBack, Pre Inc, Immed.  */
	      (void) StoreWord (state, instr, LHS + LSImmRHS);
	      break;

	    case 0x59:		/* Load Word, No WriteBack, Pre Inc, Immed.  */
	      (void) LoadWord (state, instr, LHS + LSImmRHS);
	      break;

	    case 0x5a:		/* Store Word, WriteBack, Pre Inc, Immed.  */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      temp = LHS + LSImmRHS;
	      if (StoreWord (state, instr, temp))
		LSBase = temp;
	      break;

	    case 0x5b:		/* Load Word, WriteBack, Pre Inc, Immed.  */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      temp = LHS + LSImmRHS;
	      if (LoadWord (state, instr, temp))
		LSBase = temp;
	      break;

	    case 0x5c:		/* Store Byte, No WriteBack, Pre Inc, Immed.  */
	      (void) StoreByte (state, instr, LHS + LSImmRHS);
	      break;

	    case 0x5d:		/* Load Byte, No WriteBack, Pre Inc, Immed.  */
	      (void) LoadByte (state, instr, LHS + LSImmRHS, LUNSIGNED);
	      break;

	    case 0x5e:		/* Store Byte, WriteBack, Pre Inc, Immed.  */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      temp = LHS + LSImmRHS;
	      if (StoreByte (state, instr, temp))
		LSBase = temp;
	      break;

	    case 0x5f:		/* Load Byte, WriteBack, Pre Inc, Immed.  */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      temp = LHS + LSImmRHS;
	      if (LoadByte (state, instr, temp, LUNSIGNED))
		LSBase = temp;
	      break;


	      /* Single Data Transfer Register RHS Instructions.  */

	    case 0x60:		/* Store Word, No WriteBack, Post Dec, Reg.  */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      if (StoreWord (state, instr, lhs))
		LSBase = lhs - LSRegRHS;
	      break;

	    case 0x61:		/* Load Word, No WriteBack, Post Dec, Reg.  */
	      if (BIT (4))
		{
#ifdef MODE32
		  if (state->is_v6
		      && handle_v6_insn (state, instr))
		    break;
#endif
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      temp = lhs - LSRegRHS;
	      if (LoadWord (state, instr, lhs))
		LSBase = temp;
	      break;

	    case 0x62:		/* Store Word, WriteBack, Post Dec, Reg.  */
	      if (BIT (4))
		{
#ifdef MODE32
		  if (state->is_v6
		      && handle_v6_insn (state, instr))
		    break;
#endif
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (StoreWord (state, instr, lhs))
		LSBase = lhs - LSRegRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x63:		/* Load Word, WriteBack, Post Dec, Reg.  */
	      if (BIT (4))
		{
#ifdef MODE32
		  if (state->is_v6
		      && handle_v6_insn (state, instr))
		    break;
#endif
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      temp = lhs - LSRegRHS;
	      state->NtransSig = LOW;
	      if (LoadWord (state, instr, lhs))
		LSBase = temp;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x64:		/* Store Byte, No WriteBack, Post Dec, Reg.  */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      if (StoreByte (state, instr, lhs))
		LSBase = lhs - LSRegRHS;
	      break;

	    case 0x65:		/* Load Byte, No WriteBack, Post Dec, Reg.  */
	      if (BIT (4))
		{
#ifdef MODE32
		  if (state->is_v6
		      && handle_v6_insn (state, instr))
		    break;
#endif
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      temp = lhs - LSRegRHS;
	      if (LoadByte (state, instr, lhs, LUNSIGNED))
		LSBase = temp;
	      break;

	    case 0x66:		/* Store Byte, WriteBack, Post Dec, Reg.  */
	      if (BIT (4))
		{
#ifdef MODE32
		  if (state->is_v6
		      && handle_v6_insn (state, instr))
		    break;
#endif
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (StoreByte (state, instr, lhs))
		LSBase = lhs - LSRegRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x67:		/* Load Byte, WriteBack, Post Dec, Reg.  */
	      if (BIT (4))
		{
#ifdef MODE32
		  if (state->is_v6
		      && handle_v6_insn (state, instr))
		    break;
#endif
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      temp = lhs - LSRegRHS;
	      state->NtransSig = LOW;
	      if (LoadByte (state, instr, lhs, LUNSIGNED))
		LSBase = temp;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x68:		/* Store Word, No WriteBack, Post Inc, Reg.  */
	      if (BIT (4))
		{
#ifdef MODE32
		  if (state->is_v6
		      && handle_v6_insn (state, instr))
		    break;
#endif
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      if (StoreWord (state, instr, lhs))
		LSBase = lhs + LSRegRHS;
	      break;

	    case 0x69:		/* Load Word, No WriteBack, Post Inc, Reg.  */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      temp = lhs + LSRegRHS;
	      if (LoadWord (state, instr, lhs))
		LSBase = temp;
	      break;

	    case 0x6a:		/* Store Word, WriteBack, Post Inc, Reg.  */
	      if (BIT (4))
		{
#ifdef MODE32
		  if (state->is_v6
		      && handle_v6_insn (state, instr))
		    break;
#endif
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (StoreWord (state, instr, lhs))
		LSBase = lhs + LSRegRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x6b:		/* Load Word, WriteBack, Post Inc, Reg.  */
	      if (BIT (4))
		{
#ifdef MODE32
		  if (state->is_v6
		      && handle_v6_insn (state, instr))
		    break;
#endif
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      temp = lhs + LSRegRHS;
	      state->NtransSig = LOW;
	      if (LoadWord (state, instr, lhs))
		LSBase = temp;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x6c:		/* Store Byte, No WriteBack, Post Inc, Reg.  */
	      if (BIT (4))
		{
#ifdef MODE32
		  if (state->is_v6
		      && handle_v6_insn (state, instr))
		    break;
#endif
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      if (StoreByte (state, instr, lhs))
		LSBase = lhs + LSRegRHS;
	      break;

	    case 0x6d:		/* Load Byte, No WriteBack, Post Inc, Reg.  */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      temp = lhs + LSRegRHS;
	      if (LoadByte (state, instr, lhs, LUNSIGNED))
		LSBase = temp;
	      break;

	    case 0x6e:		/* Store Byte, WriteBack, Post Inc, Reg.  */
	      if (BIT (4))
		{
#ifdef MODE32
		  if (state->is_v6
		      && handle_v6_insn (state, instr))
		    break;
#endif
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (StoreByte (state, instr, lhs))
		LSBase = lhs + LSRegRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x6f:		/* Load Byte, WriteBack, Post Inc, Reg.  */
	      if (BIT (4))
		{
#ifdef MODE32
		  if (state->is_v6
		      && handle_v6_insn (state, instr))
		    break;
#endif
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      temp = lhs + LSRegRHS;
	      state->NtransSig = LOW;
	      if (LoadByte (state, instr, lhs, LUNSIGNED))
		LSBase = temp;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;


	    case 0x70:		/* Store Word, No WriteBack, Pre Dec, Reg.  */
	      if (BIT (4))
		{
#ifdef MODE32
		  if (state->is_v6
		      && handle_v6_insn (state, instr))
		    break;
#endif
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      (void) StoreWord (state, instr, LHS - LSRegRHS);
	      break;

	    case 0x71:		/* Load Word, No WriteBack, Pre Dec, Reg.  */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      (void) LoadWord (state, instr, LHS - LSRegRHS);
	      break;

	    case 0x72:		/* Store Word, WriteBack, Pre Dec, Reg.  */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      temp = LHS - LSRegRHS;
	      if (StoreWord (state, instr, temp))
		LSBase = temp;
	      break;

	    case 0x73:		/* Load Word, WriteBack, Pre Dec, Reg.  */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      temp = LHS - LSRegRHS;
	      if (LoadWord (state, instr, temp))
		LSBase = temp;
	      break;

	    case 0x74:		/* Store Byte, No WriteBack, Pre Dec, Reg.  */
	      if (BIT (4))
		{
#ifdef MODE32
		  if (state->is_v6
		      && handle_v6_insn (state, instr))
		    break;
#endif
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      (void) StoreByte (state, instr, LHS - LSRegRHS);
	      break;

	    case 0x75:		/* Load Byte, No WriteBack, Pre Dec, Reg.  */
	      if (BIT (4))
		{
#ifdef MODE32
		  if (state->is_v6
		      && handle_v6_insn (state, instr))
		    break;
#endif
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      (void) LoadByte (state, instr, LHS - LSRegRHS, LUNSIGNED);
	      break;

	    case 0x76:		/* Store Byte, WriteBack, Pre Dec, Reg.  */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      temp = LHS - LSRegRHS;
	      if (StoreByte (state, instr, temp))
		LSBase = temp;
	      break;

	    case 0x77:		/* Load Byte, WriteBack, Pre Dec, Reg.  */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      temp = LHS - LSRegRHS;
	      if (LoadByte (state, instr, temp, LUNSIGNED))
		LSBase = temp;
	      break;

	    case 0x78:		/* Store Word, No WriteBack, Pre Inc, Reg.  */
	      if (BIT (4))
		{
#ifdef MODE32
		  if (state->is_v6
		      && handle_v6_insn (state, instr))
		    break;
#endif
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      (void) StoreWord (state, instr, LHS + LSRegRHS);
	      break;

	    case 0x79:		/* Load Word, No WriteBack, Pre Inc, Reg.  */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      (void) LoadWord (state, instr, LHS + LSRegRHS);
	      break;

	    case 0x7a:		/* Store Word, WriteBack, Pre Inc, Reg.  */
	      if (BIT (4))
		{
#ifdef MODE32
		  if (state->is_v6
		      && handle_v6_insn (state, instr))
		    break;
#endif
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      temp = LHS + LSRegRHS;
	      if (StoreWord (state, instr, temp))
		LSBase = temp;
	      break;

	    case 0x7b:		/* Load Word, WriteBack, Pre Inc, Reg.  */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      temp = LHS + LSRegRHS;
	      if (LoadWord (state, instr, temp))
		LSBase = temp;
	      break;

	    case 0x7c:		/* Store Byte, No WriteBack, Pre Inc, Reg.  */
	      if (BIT (4))
		{
#ifdef MODE32
		  if (state->is_v6
		      && handle_v6_insn (state, instr))
		    break;
#endif
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      (void) StoreByte (state, instr, LHS + LSRegRHS);
	      break;

	    case 0x7d:		/* Load Byte, No WriteBack, Pre Inc, Reg.  */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      (void) LoadByte (state, instr, LHS + LSRegRHS, LUNSIGNED);
	      break;

	    case 0x7e:		/* Store Byte, WriteBack, Pre Inc, Reg.  */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      temp = LHS + LSRegRHS;
	      if (StoreByte (state, instr, temp))
		LSBase = temp;
	      break;

	    case 0x7f:		/* Load Byte, WriteBack, Pre Inc, Reg.  */
	      if (BIT (4))
		{
		  /* Check for the special breakpoint opcode.
		     This value should correspond to the value defined
		     as ARM_BE_BREAKPOINT in gdb/arm/tm-arm.h.  */
		  if (BITS (0, 19) == 0xfdefe)
		    {
		      if (!ARMul_OSHandleSWI (state, SWI_Breakpoint))
			ARMul_Abort (state, ARMul_SWIV);
		    }
		  else
		    ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      temp = LHS + LSRegRHS;
	      if (LoadByte (state, instr, temp, LUNSIGNED))
		LSBase = temp;
	      break;


	      /* Multiple Data Transfer Instructions.  */

	    case 0x80:		/* Store, No WriteBack, Post Dec.  */
	      STOREMULT (instr, LSBase - LSMNumRegs + 4L, 0L);
	      break;

	    case 0x81:		/* Load, No WriteBack, Post Dec.  */
	      LOADMULT (instr, LSBase - LSMNumRegs + 4L, 0L);
	      break;

	    case 0x82:		/* Store, WriteBack, Post Dec.  */
	      temp = LSBase - LSMNumRegs;
	      STOREMULT (instr, temp + 4L, temp);
	      break;

	    case 0x83:		/* Load, WriteBack, Post Dec.  */
	      temp = LSBase - LSMNumRegs;
	      LOADMULT (instr, temp + 4L, temp);
	      break;

	    case 0x84:		/* Store, Flags, No WriteBack, Post Dec.  */
	      STORESMULT (instr, LSBase - LSMNumRegs + 4L, 0L);
	      break;

	    case 0x85:		/* Load, Flags, No WriteBack, Post Dec.  */
	      LOADSMULT (instr, LSBase - LSMNumRegs + 4L, 0L);
	      break;

	    case 0x86:		/* Store, Flags, WriteBack, Post Dec.  */
	      temp = LSBase - LSMNumRegs;
	      STORESMULT (instr, temp + 4L, temp);
	      break;

	    case 0x87:		/* Load, Flags, WriteBack, Post Dec.  */
	      temp = LSBase - LSMNumRegs;
	      LOADSMULT (instr, temp + 4L, temp);
	      break;

	    case 0x88:		/* Store, No WriteBack, Post Inc.  */
	      STOREMULT (instr, LSBase, 0L);
	      break;

	    case 0x89:		/* Load, No WriteBack, Post Inc.  */
	      LOADMULT (instr, LSBase, 0L);
	      break;

	    case 0x8a:		/* Store, WriteBack, Post Inc.  */
	      temp = LSBase;
	      STOREMULT (instr, temp, temp + LSMNumRegs);
	      break;

	    case 0x8b:		/* Load, WriteBack, Post Inc.  */
	      temp = LSBase;
	      LOADMULT (instr, temp, temp + LSMNumRegs);
	      break;

	    case 0x8c:		/* Store, Flags, No WriteBack, Post Inc.  */
	      STORESMULT (instr, LSBase, 0L);
	      break;

	    case 0x8d:		/* Load, Flags, No WriteBack, Post Inc.  */
	      LOADSMULT (instr, LSBase, 0L);
	      break;

	    case 0x8e:		/* Store, Flags, WriteBack, Post Inc.  */
	      temp = LSBase;
	      STORESMULT (instr, temp, temp + LSMNumRegs);
	      break;

	    case 0x8f:		/* Load, Flags, WriteBack, Post Inc.  */
	      temp = LSBase;
	      LOADSMULT (instr, temp, temp + LSMNumRegs);
	      break;

	    case 0x90:		/* Store, No WriteBack, Pre Dec.  */
	      STOREMULT (instr, LSBase - LSMNumRegs, 0L);
	      break;

	    case 0x91:		/* Load, No WriteBack, Pre Dec.  */
	      LOADMULT (instr, LSBase - LSMNumRegs, 0L);
	      break;

	    case 0x92:		/* Store, WriteBack, Pre Dec.  */
	      temp = LSBase - LSMNumRegs;
	      STOREMULT (instr, temp, temp);
	      break;

	    case 0x93:		/* Load, WriteBack, Pre Dec.  */
	      temp = LSBase - LSMNumRegs;
	      LOADMULT (instr, temp, temp);
	      break;

	    case 0x94:		/* Store, Flags, No WriteBack, Pre Dec.  */
	      STORESMULT (instr, LSBase - LSMNumRegs, 0L);
	      break;

	    case 0x95:		/* Load, Flags, No WriteBack, Pre Dec.  */
	      LOADSMULT (instr, LSBase - LSMNumRegs, 0L);
	      break;

	    case 0x96:		/* Store, Flags, WriteBack, Pre Dec.  */
	      temp = LSBase - LSMNumRegs;
	      STORESMULT (instr, temp, temp);
	      break;

	    case 0x97:		/* Load, Flags, WriteBack, Pre Dec.  */
	      temp = LSBase - LSMNumRegs;
	      LOADSMULT (instr, temp, temp);
	      break;

	    case 0x98:		/* Store, No WriteBack, Pre Inc.  */
	      STOREMULT (instr, LSBase + 4L, 0L);
	      break;

	    case 0x99:		/* Load, No WriteBack, Pre Inc.  */
	      LOADMULT (instr, LSBase + 4L, 0L);
	      break;

	    case 0x9a:		/* Store, WriteBack, Pre Inc.  */
	      temp = LSBase;
	      STOREMULT (instr, temp + 4L, temp + LSMNumRegs);
	      break;

	    case 0x9b:		/* Load, WriteBack, Pre Inc.  */
	      temp = LSBase;
	      LOADMULT (instr, temp + 4L, temp + LSMNumRegs);
	      break;

	    case 0x9c:		/* Store, Flags, No WriteBack, Pre Inc.  */
	      STORESMULT (instr, LSBase + 4L, 0L);
	      break;

	    case 0x9d:		/* Load, Flags, No WriteBack, Pre Inc.  */
	      LOADSMULT (instr, LSBase + 4L, 0L);
	      break;

	    case 0x9e:		/* Store, Flags, WriteBack, Pre Inc.  */
	      temp = LSBase;
	      STORESMULT (instr, temp + 4L, temp + LSMNumRegs);
	      break;

	    case 0x9f:		/* Load, Flags, WriteBack, Pre Inc.  */
	      temp = LSBase;
	      LOADSMULT (instr, temp + 4L, temp + LSMNumRegs);
	      break;


	      /* Branch forward.  */
	    case 0xa0:
	    case 0xa1:
	    case 0xa2:
	    case 0xa3:
	    case 0xa4:
	    case 0xa5:
	    case 0xa6:
	    case 0xa7:
	      state->Reg[15] = pc + 8 + POSBRANCH;
	      FLUSHPIPE;
	      break;


	      /* Branch backward.  */
	    case 0xa8:
	    case 0xa9:
	    case 0xaa:
	    case 0xab:
	    case 0xac:
	    case 0xad:
	    case 0xae:
	    case 0xaf:
	      state->Reg[15] = pc + 8 + NEGBRANCH;
	      FLUSHPIPE;
	      break;


	      /* Branch and Link forward.  */
	    case 0xb0:
	    case 0xb1:
	    case 0xb2:
	    case 0xb3:
	    case 0xb4:
	    case 0xb5:
	    case 0xb6:
	    case 0xb7:
	      /* Put PC into Link.  */
#ifdef MODE32
	      state->Reg[14] = pc + 4;
#else
	      state->Reg[14] = (pc + 4) | ECC | ER15INT | EMODE;
#endif
	      state->Reg[15] = pc + 8 + POSBRANCH;
	      FLUSHPIPE;
	      break;


	      /* Branch and Link backward.  */
	    case 0xb8:
	    case 0xb9:
	    case 0xba:
	    case 0xbb:
	    case 0xbc:
	    case 0xbd:
	    case 0xbe:
	    case 0xbf:
	      /* Put PC into Link.  */
#ifdef MODE32
	      state->Reg[14] = pc + 4;
#else
	      state->Reg[14] = (pc + 4) | ECC | ER15INT | EMODE;
#endif
	      state->Reg[15] = pc + 8 + NEGBRANCH;
	      FLUSHPIPE;
	      break;


	      /* Co-Processor Data Transfers.  */
	    case 0xc4:
	      if (state->is_v5)
		{
		  /* Reading from R15 is UNPREDICTABLE.  */
		  if (BITS (12, 15) == 15 || BITS (16, 19) == 15)
		    ARMul_UndefInstr (state, instr);
		  /* Is access to coprocessor 0 allowed ?  */
		  else if (! CP_ACCESS_ALLOWED (state, CPNum))
		    ARMul_UndefInstr (state, instr);
		  /* Special treatment for XScale coprocessors.  */
		  else if (state->is_XScale)
		    {
		      /* Only opcode 0 is supported.  */
		      if (BITS (4, 7) != 0x00)
			ARMul_UndefInstr (state, instr);
		      /* Only coporcessor 0 is supported.  */
		      else if (CPNum != 0x00)
			ARMul_UndefInstr (state, instr);
		      /* Only accumulator 0 is supported.  */
		      else if (BITS (0, 3) != 0x00)
			ARMul_UndefInstr (state, instr);
		      else
			{
			  /* XScale MAR insn.  Move two registers into accumulator.  */
			  state->Accumulator = state->Reg[BITS (12, 15)];
			  state->Accumulator += (ARMdword) state->Reg[BITS (16, 19)] << 32;
			}
		    }
		  else
		    /* FIXME: Not sure what to do for other v5 processors.  */
		    ARMul_UndefInstr (state, instr);		    
		  break;
		}
	      /* Drop through.  */
	      
	    case 0xc0:		/* Store , No WriteBack , Post Dec.  */
	      ARMul_STC (state, instr, LHS);
	      break;

	    case 0xc5:
	      if (state->is_v5)
		{
		  /* Writes to R15 are UNPREDICATABLE.  */
		  if (DESTReg == 15 || LHSReg == 15)
		    ARMul_UndefInstr (state, instr);
		  /* Is access to the coprocessor allowed ?  */
		  else if (! CP_ACCESS_ALLOWED (state, CPNum))
		    ARMul_UndefInstr (state, instr);
		  /* Special handling for XScale coprcoessors.  */
		  else if (state->is_XScale)
		    {
		      /* Only opcode 0 is supported.  */
		      if (BITS (4, 7) != 0x00)
			ARMul_UndefInstr (state, instr);
		      /* Only coprocessor 0 is supported.  */
		      else if (CPNum != 0x00)
			ARMul_UndefInstr (state, instr);
		      /* Only accumulator 0 is supported.  */
		      else if (BITS (0, 3) != 0x00)
			ARMul_UndefInstr (state, instr);
		      else
			{
			  /* XScale MRA insn.  Move accumulator into two registers.  */
			  ARMword t1 = (state->Accumulator >> 32) & 255;

			  if (t1 & 128)
			    t1 -= 256;

			  state->Reg[BITS (12, 15)] = state->Accumulator;
			  state->Reg[BITS (16, 19)] = t1;
			  break;
			}
		    }
		  else
		    /* FIXME: Not sure what to do for other v5 processors.  */
		    ARMul_UndefInstr (state, instr);
		  break;
		}
	      /* Drop through.  */

	    case 0xc1:		/* Load , No WriteBack , Post Dec.  */
	      ARMul_LDC (state, instr, LHS);
	      break;

	    case 0xc2:
	    case 0xc6:		/* Store , WriteBack , Post Dec.  */
	      lhs = LHS;
	      state->Base = lhs - LSCOff;
	      ARMul_STC (state, instr, lhs);
	      break;

	    case 0xc3:
	    case 0xc7:		/* Load , WriteBack , Post Dec.  */
	      lhs = LHS;
	      state->Base = lhs - LSCOff;
	      ARMul_LDC (state, instr, lhs);
	      break;

	    case 0xc8:
	    case 0xcc:		/* Store , No WriteBack , Post Inc.  */
	      ARMul_STC (state, instr, LHS);
	      break;

	    case 0xc9:
	    case 0xcd:		/* Load , No WriteBack , Post Inc.  */
	      ARMul_LDC (state, instr, LHS);
	      break;

	    case 0xca:
	    case 0xce:		/* Store , WriteBack , Post Inc.  */
	      lhs = LHS;
	      state->Base = lhs + LSCOff;
	      ARMul_STC (state, instr, LHS);
	      break;

	    case 0xcb:
	    case 0xcf:		/* Load , WriteBack , Post Inc.  */
	      lhs = LHS;
	      state->Base = lhs + LSCOff;
	      ARMul_LDC (state, instr, LHS);
	      break;

	    case 0xd0:
	    case 0xd4:		/* Store , No WriteBack , Pre Dec.  */
	      ARMul_STC (state, instr, LHS - LSCOff);
	      break;

	    case 0xd1:
	    case 0xd5:		/* Load , No WriteBack , Pre Dec.  */
	      ARMul_LDC (state, instr, LHS - LSCOff);
	      break;

	    case 0xd2:
	    case 0xd6:		/* Store , WriteBack , Pre Dec.  */
	      lhs = LHS - LSCOff;
	      state->Base = lhs;
	      ARMul_STC (state, instr, lhs);
	      break;

	    case 0xd3:
	    case 0xd7:		/* Load , WriteBack , Pre Dec.  */
	      lhs = LHS - LSCOff;
	      state->Base = lhs;
	      ARMul_LDC (state, instr, lhs);
	      break;

	    case 0xd8:
	    case 0xdc:		/* Store , No WriteBack , Pre Inc.  */
	      ARMul_STC (state, instr, LHS + LSCOff);
	      break;

	    case 0xd9:
	    case 0xdd:		/* Load , No WriteBack , Pre Inc.  */
	      ARMul_LDC (state, instr, LHS + LSCOff);
	      break;

	    case 0xda:
	    case 0xde:		/* Store , WriteBack , Pre Inc.  */
	      lhs = LHS + LSCOff;
	      state->Base = lhs;
	      ARMul_STC (state, instr, lhs);
	      break;

	    case 0xdb:
	    case 0xdf:		/* Load , WriteBack , Pre Inc.  */
	      lhs = LHS + LSCOff;
	      state->Base = lhs;
	      ARMul_LDC (state, instr, lhs);
	      break;


	      /* Co-Processor Register Transfers (MCR) and Data Ops.  */

	    case 0xe2:
	      if (! CP_ACCESS_ALLOWED (state, CPNum))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      if (state->is_XScale)
		switch (BITS (18, 19))
		  {
		  case 0x0:
		    if (BITS (4, 11) == 1 && BITS (16, 17) == 0)
		      {
			/* XScale MIA instruction.  Signed multiplication of
			   two 32 bit values and addition to 40 bit accumulator.  */
			ARMsdword Rm = state->Reg[MULLHSReg];
			ARMsdword Rs = state->Reg[MULACCReg];

			if (Rm & (1 << 31))
			  Rm -= 1ULL << 32;
			if (Rs & (1 << 31))
			  Rs -= 1ULL << 32;
			state->Accumulator += Rm * Rs;
			goto donext;
		      }
		    break;

		  case 0x2:
		    if (BITS (4, 11) == 1 && BITS (16, 17) == 0)
		      {
			/* XScale MIAPH instruction.  */
			ARMword t1 = state->Reg[MULLHSReg] >> 16;
			ARMword t2 = state->Reg[MULACCReg] >> 16;
			ARMword t3 = state->Reg[MULLHSReg] & 0xffff;
			ARMword t4 = state->Reg[MULACCReg] & 0xffff;
			ARMsdword t5;

			if (t1 & (1 << 15))
			  t1 -= 1 << 16;
			if (t2 & (1 << 15))
			  t2 -= 1 << 16;
			if (t3 & (1 << 15))
			  t3 -= 1 << 16;
			if (t4 & (1 << 15))
			  t4 -= 1 << 16;
			t1 *= t2;
			t5 = t1;
			if (t5 & (1 << 31))
			  t5 -= 1ULL << 32;
			state->Accumulator += t5;
			t3 *= t4;
			t5 = t3;
			if (t5 & (1 << 31))
			  t5 -= 1ULL << 32;
			state->Accumulator += t5;
			goto donext;
		      }
		    break;

		  case 0x3:
		    if (BITS (4, 11) == 1)
		      {
			/* XScale MIAxy instruction.  */
			ARMword t1;
			ARMword t2;
			ARMsdword t5;

			if (BIT (17))
			  t1 = state->Reg[MULLHSReg] >> 16;
			else
			  t1 = state->Reg[MULLHSReg] & 0xffff;

			if (BIT (16))
			  t2 = state->Reg[MULACCReg] >> 16;
			else
			  t2 = state->Reg[MULACCReg] & 0xffff;

			if (t1 & (1 << 15))
			  t1 -= 1 << 16;
			if (t2 & (1 << 15))
			  t2 -= 1 << 16;
			t1 *= t2;
			t5 = t1;
			if (t5 & (1 << 31))
			  t5 -= 1ULL << 32;
			state->Accumulator += t5;
			goto donext;
		      }
		    break;

		  default:
		    break;
		  }
	      /* Drop through.  */

	    case 0xe0:
	    case 0xe4:
	    case 0xe6:
	    case 0xe8:
	    case 0xea:
	    case 0xec:
	    case 0xee:
	      if (BIT (4))
		{
		  /* MCR.  */
		  if (DESTReg == 15)
		    {
		      UNDEF_MCRPC;
#ifdef MODE32
		      ARMul_MCR (state, instr, state->Reg[15] + isize);
#else
		      ARMul_MCR (state, instr, ECC | ER15INT | EMODE |
				 ((state->Reg[15] + isize) & R15PCBITS));
#endif
		    }
		  else
		    ARMul_MCR (state, instr, DEST);
		}
	      else
		/* CDP Part 1.  */
		ARMul_CDP (state, instr);
	      break;


	      /* Co-Processor Register Transfers (MRC) and Data Ops.  */
	    case 0xe1:
	    case 0xe3:
	    case 0xe5:
	    case 0xe7:
	    case 0xe9:
	    case 0xeb:
	    case 0xed:
	    case 0xef:
	      if (BIT (4))
		{
		  /* MRC */
		  temp = ARMul_MRC (state, instr);
		  if (DESTReg == 15)
		    {
		      ASSIGNN ((temp & NBIT) != 0);
		      ASSIGNZ ((temp & ZBIT) != 0);
		      ASSIGNC ((temp & CBIT) != 0);
		      ASSIGNV ((temp & VBIT) != 0);
		    }
		  else
		    DEST = temp;
		}
	      else
		/* CDP Part 2.  */
		ARMul_CDP (state, instr);
	      break;


	      /* SWI instruction.  */
	    case 0xf0:
	    case 0xf1:
	    case 0xf2:
	    case 0xf3:
	    case 0xf4:
	    case 0xf5:
	    case 0xf6:
	    case 0xf7:
	    case 0xf8:
	    case 0xf9:
	    case 0xfa:
	    case 0xfb:
	    case 0xfc:
	    case 0xfd:
	    case 0xfe:
	    case 0xff:
	      if (instr == ARMul_ABORTWORD && state->AbortAddr == pc)
		{
		  /* A prefetch abort.  */
		  XScale_set_fsr_far (state, ARMul_CP15_R5_MMU_EXCPT, pc);
		  ARMul_Abort (state, ARMul_PrefetchAbortV);
		  break;
		}

	      if (!ARMul_OSHandleSWI (state, BITS (0, 23)))
		ARMul_Abort (state, ARMul_SWIV);

	      break;
	    }
	}

#ifdef MODET
    donext:
#endif

#ifdef NEED_UI_LOOP_HOOK
      if (deprecated_ui_loop_hook != NULL && ui_loop_hook_counter-- < 0)
	{
	  ui_loop_hook_counter = UI_LOOP_POLL_INTERVAL;
	  deprecated_ui_loop_hook (0);
	}
#endif /* NEED_UI_LOOP_HOOK */

      if (state->Emulate == ONCE)
	state->Emulate = STOP;
      /* If we have changed mode, allow the PC to advance before stopping.  */
      else if (state->Emulate == CHANGEMODE)
	continue;
      else if (state->Emulate != RUN)
	break;
    }
  while (!stop_simulator);

  state->decoded = decoded;
  state->loaded = loaded;
  state->pc = pc;

  return pc;
}

/* This routine evaluates most Data Processing register RHS's with the S
   bit clear.  It is intended to be called from the macro DPRegRHS, which
   filters the common case of an unshifted register with in line code.  */

static ARMword
GetDPRegRHS (ARMul_State * state, ARMword instr)
{
  ARMword shamt, base;

  base = RHSReg;
  if (BIT (4))
    {
      /* Shift amount in a register.  */
      UNDEF_Shift;
      INCPC;
#ifndef MODE32
      if (base == 15)
	base = ECC | ER15INT | R15PC | EMODE;
      else
#endif
	base = state->Reg[base];
      ARMul_Icycles (state, 1, 0L);
      shamt = state->Reg[BITS (8, 11)] & 0xff;
      switch ((int) BITS (5, 6))
	{
	case LSL:
	  if (shamt == 0)
	    return (base);
	  else if (shamt >= 32)
	    return (0);
	  else
	    return (base << shamt);
	case LSR:
	  if (shamt == 0)
	    return (base);
	  else if (shamt >= 32)
	    return (0);
	  else
	    return (base >> shamt);
	case ASR:
	  if (shamt == 0)
	    return (base);
	  else if (shamt >= 32)
	    return ((ARMword) ((ARMsword) base >> 31L));
	  else
	    return ((ARMword) ((ARMsword) base >> (int) shamt));
	case ROR:
	  shamt &= 0x1f;
	  if (shamt == 0)
	    return (base);
	  else
	    return ((base << (32 - shamt)) | (base >> shamt));
	}
    }
  else
    {
      /* Shift amount is a constant.  */
#ifndef MODE32
      if (base == 15)
	base = ECC | ER15INT | R15PC | EMODE;
      else
#endif
	base = state->Reg[base];
      shamt = BITS (7, 11);
      switch ((int) BITS (5, 6))
	{
	case LSL:
	  return (base << shamt);
	case LSR:
	  if (shamt == 0)
	    return (0);
	  else
	    return (base >> shamt);
	case ASR:
	  if (shamt == 0)
	    return ((ARMword) ((ARMsword) base >> 31L));
	  else
	    return ((ARMword) ((ARMsword) base >> (int) shamt));
	case ROR:
	  if (shamt == 0)
	    /* It's an RRX.  */
	    return ((base >> 1) | (CFLAG << 31));
	  else
	    return ((base << (32 - shamt)) | (base >> shamt));
	}
    }

  return 0;
}

/* This routine evaluates most Logical Data Processing register RHS's
   with the S bit set.  It is intended to be called from the macro
   DPSRegRHS, which filters the common case of an unshifted register
   with in line code.  */

static ARMword
GetDPSRegRHS (ARMul_State * state, ARMword instr)
{
  ARMword shamt, base;

  base = RHSReg;
  if (BIT (4))
    {
      /* Shift amount in a register.  */
      UNDEF_Shift;
      INCPC;
#ifndef MODE32
      if (base == 15)
	base = ECC | ER15INT | R15PC | EMODE;
      else
#endif
	base = state->Reg[base];
      ARMul_Icycles (state, 1, 0L);
      shamt = state->Reg[BITS (8, 11)] & 0xff;
      switch ((int) BITS (5, 6))
	{
	case LSL:
	  if (shamt == 0)
	    return (base);
	  else if (shamt == 32)
	    {
	      ASSIGNC (base & 1);
	      return (0);
	    }
	  else if (shamt > 32)
	    {
	      CLEARC;
	      return (0);
	    }
	  else
	    {
	      ASSIGNC ((base >> (32 - shamt)) & 1);
	      return (base << shamt);
	    }
	case LSR:
	  if (shamt == 0)
	    return (base);
	  else if (shamt == 32)
	    {
	      ASSIGNC (base >> 31);
	      return (0);
	    }
	  else if (shamt > 32)
	    {
	      CLEARC;
	      return (0);
	    }
	  else
	    {
	      ASSIGNC ((base >> (shamt - 1)) & 1);
	      return (base >> shamt);
	    }
	case ASR:
	  if (shamt == 0)
	    return (base);
	  else if (shamt >= 32)
	    {
	      ASSIGNC (base >> 31L);
	      return ((ARMword) ((ARMsword) base >> 31L));
	    }
	  else
	    {
	      ASSIGNC ((ARMword) ((ARMsword) base >> (int) (shamt - 1)) & 1);
	      return ((ARMword) ((ARMsword) base >> (int) shamt));
	    }
	case ROR:
	  if (shamt == 0)
	    return (base);
	  shamt &= 0x1f;
	  if (shamt == 0)
	    {
	      ASSIGNC (base >> 31);
	      return (base);
	    }
	  else
	    {
	      ASSIGNC ((base >> (shamt - 1)) & 1);
	      return ((base << (32 - shamt)) | (base >> shamt));
	    }
	}
    }
  else
    {
      /* Shift amount is a constant.  */
#ifndef MODE32
      if (base == 15)
	base = ECC | ER15INT | R15PC | EMODE;
      else
#endif
	base = state->Reg[base];
      shamt = BITS (7, 11);

      switch ((int) BITS (5, 6))
	{
	case LSL:
	  ASSIGNC ((base >> (32 - shamt)) & 1);
	  return (base << shamt);
	case LSR:
	  if (shamt == 0)
	    {
	      ASSIGNC (base >> 31);
	      return (0);
	    }
	  else
	    {
	      ASSIGNC ((base >> (shamt - 1)) & 1);
	      return (base >> shamt);
	    }
	case ASR:
	  if (shamt == 0)
	    {
	      ASSIGNC (base >> 31L);
	      return ((ARMword) ((ARMsword) base >> 31L));
	    }
	  else
	    {
	      ASSIGNC ((ARMword) ((ARMsword) base >> (int) (shamt - 1)) & 1);
	      return ((ARMword) ((ARMsword) base >> (int) shamt));
	    }
	case ROR:
	  if (shamt == 0)
	    {
	      /* It's an RRX.  */
	      shamt = CFLAG;
	      ASSIGNC (base & 1);
	      return ((base >> 1) | (shamt << 31));
	    }
	  else
	    {
	      ASSIGNC ((base >> (shamt - 1)) & 1);
	      return ((base << (32 - shamt)) | (base >> shamt));
	    }
	}
    }

  return 0;
}

/* This routine handles writes to register 15 when the S bit is not set.  */

static void
WriteR15 (ARMul_State * state, ARMword src)
{
  /* The ARM documentation states that the two least significant bits
     are discarded when setting PC, except in the cases handled by
     WriteR15Branch() below.  It's probably an oversight: in THUMB
     mode, the second least significant bit should probably not be
     discarded.  */
#ifdef MODET
  if (TFLAG)
    src &= 0xfffffffe;
  else
#endif
    src &= 0xfffffffc;

#ifdef MODE32
  state->Reg[15] = src & PCBITS;
#else
  state->Reg[15] = (src & R15PCBITS) | ECC | ER15INT | EMODE;
  ARMul_R15Altered (state);
#endif

  FLUSHPIPE;
}

/* This routine handles writes to register 15 when the S bit is set.  */

static void
WriteSR15 (ARMul_State * state, ARMword src)
{
#ifdef MODE32
  if (state->Bank > 0)
    {
      state->Cpsr = state->Spsr[state->Bank];
      ARMul_CPSRAltered (state);
    }
#ifdef MODET
  if (TFLAG)
    src &= 0xfffffffe;
  else
#endif
    src &= 0xfffffffc;
  state->Reg[15] = src & PCBITS;
#else
#ifdef MODET
  if (TFLAG)
    /* ARMul_R15Altered would have to support it.  */
    abort ();
  else
#endif
    src &= 0xfffffffc;

  if (state->Bank == USERBANK)
    state->Reg[15] = (src & (CCBITS | R15PCBITS)) | ER15INT | EMODE;
  else
    state->Reg[15] = src;

  ARMul_R15Altered (state);
#endif
  FLUSHPIPE;
}

/* In machines capable of running in Thumb mode, BX, BLX, LDR and LDM
   will switch to Thumb mode if the least significant bit is set.  */

static void
WriteR15Branch (ARMul_State * state, ARMword src)
{
#ifdef MODET
  if (src & 1)
    {
      /* Thumb bit.  */
      SETT;
      state->Reg[15] = src & 0xfffffffe;
    }
  else
    {
      CLEART;
      state->Reg[15] = src & 0xfffffffc;
    }
  FLUSHPIPE;
#else
  WriteR15 (state, src);
#endif
}

/* This routine evaluates most Load and Store register RHS's.  It is
   intended to be called from the macro LSRegRHS, which filters the
   common case of an unshifted register with in line code.  */

static ARMword
GetLSRegRHS (ARMul_State * state, ARMword instr)
{
  ARMword shamt, base;

  base = RHSReg;
#ifndef MODE32
  if (base == 15)
    /* Now forbidden, but ...  */
    base = ECC | ER15INT | R15PC | EMODE;
  else
#endif
    base = state->Reg[base];

  shamt = BITS (7, 11);
  switch ((int) BITS (5, 6))
    {
    case LSL:
      return (base << shamt);
    case LSR:
      if (shamt == 0)
	return (0);
      else
	return (base >> shamt);
    case ASR:
      if (shamt == 0)
	return ((ARMword) ((ARMsword) base >> 31L));
      else
	return ((ARMword) ((ARMsword) base >> (int) shamt));
    case ROR:
      if (shamt == 0)
	/* It's an RRX.  */
	return ((base >> 1) | (CFLAG << 31));
      else
	return ((base << (32 - shamt)) | (base >> shamt));
    default:
      break;
    }
  return 0;
}

/* This routine evaluates the ARM7T halfword and signed transfer RHS's.  */

static ARMword
GetLS7RHS (ARMul_State * state, ARMword instr)
{
  if (BIT (22) == 0)
    {
      /* Register.  */
#ifndef MODE32
      if (RHSReg == 15)
	/* Now forbidden, but ...  */
	return ECC | ER15INT | R15PC | EMODE;
#endif
      return state->Reg[RHSReg];
    }

  /* Immediate.  */
  return BITS (0, 3) | (BITS (8, 11) << 4);
}

/* This function does the work of loading a word for a LDR instruction.  */

static unsigned
LoadWord (ARMul_State * state, ARMword instr, ARMword address)
{
  ARMword dest;

  BUSUSEDINCPCS;
#ifndef MODE32
  if (ADDREXCEPT (address))
    INTERNALABORT (address);
#endif

  dest = ARMul_LoadWordN (state, address);

  if (state->Aborted)
    {
      TAKEABORT;
      return state->lateabtSig;
    }
  if (address & 3)
    dest = ARMul_Align (state, address, dest);
  WRITEDESTB (dest);
  ARMul_Icycles (state, 1, 0L);

  return (DESTReg != LHSReg);
}

#ifdef MODET
/* This function does the work of loading a halfword.  */

static unsigned
LoadHalfWord (ARMul_State * state, ARMword instr, ARMword address,
	      int signextend)
{
  ARMword dest;

  BUSUSEDINCPCS;
#ifndef MODE32
  if (ADDREXCEPT (address))
    INTERNALABORT (address);
#endif
  dest = ARMul_LoadHalfWord (state, address);
  if (state->Aborted)
    {
      TAKEABORT;
      return state->lateabtSig;
    }
  UNDEF_LSRBPC;
  if (signextend)
    if (dest & 1 << (16 - 1))
      dest = (dest & ((1 << 16) - 1)) - (1 << 16);

  WRITEDEST (dest);
  ARMul_Icycles (state, 1, 0L);
  return (DESTReg != LHSReg);
}

#endif /* MODET */

/* This function does the work of loading a byte for a LDRB instruction.  */

static unsigned
LoadByte (ARMul_State * state, ARMword instr, ARMword address, int signextend)
{
  ARMword dest;

  BUSUSEDINCPCS;
#ifndef MODE32
  if (ADDREXCEPT (address))
    INTERNALABORT (address);
#endif
  dest = ARMul_LoadByte (state, address);
  if (state->Aborted)
    {
      TAKEABORT;
      return state->lateabtSig;
    }
  UNDEF_LSRBPC;
  if (signextend)
    if (dest & 1 << (8 - 1))
      dest = (dest & ((1 << 8) - 1)) - (1 << 8);

  WRITEDEST (dest);
  ARMul_Icycles (state, 1, 0L);

  return (DESTReg != LHSReg);
}

/* This function does the work of loading two words for a LDRD instruction.  */

static void
Handle_Load_Double (ARMul_State * state, ARMword instr)
{
  ARMword dest_reg;
  ARMword addr_reg;
  ARMword write_back  = BIT (21);
  ARMword immediate   = BIT (22);
  ARMword add_to_base = BIT (23);        
  ARMword pre_indexed = BIT (24);
  ARMword offset;
  ARMword addr;
  ARMword sum;
  ARMword base;
  ARMword value1;
  ARMword value2;
  
  BUSUSEDINCPCS;

  /* If the writeback bit is set, the pre-index bit must be clear.  */
  if (write_back && ! pre_indexed)
    {
      ARMul_UndefInstr (state, instr);
      return;
    }
  
  /* Extract the base address register.  */
  addr_reg = LHSReg;
  
  /* Extract the destination register and check it.  */
  dest_reg = DESTReg;
  
  /* Destination register must be even.  */
  if ((dest_reg & 1)
    /* Destination register cannot be LR.  */
      || (dest_reg == 14))
    {
      ARMul_UndefInstr (state, instr);
      return;
    }

  /* Compute the base address.  */
  base = state->Reg[addr_reg];

  /* Compute the offset.  */
  offset = immediate ? ((BITS (8, 11) << 4) | BITS (0, 3)) : state->Reg[RHSReg];

  /* Compute the sum of the two.  */
  if (add_to_base)
    sum = base + offset;
  else
    sum = base - offset;
  
  /* If this is a pre-indexed mode use the sum.  */
  if (pre_indexed)
    addr = sum;
  else
    addr = base;

  /* The address must be aligned on a 8 byte boundary.  */
  if (addr & 0x7)
    {
#ifdef ABORTS
      ARMul_DATAABORT (addr);
#else
      ARMul_UndefInstr (state, instr);
#endif
      return;
    }

  /* For pre indexed or post indexed addressing modes,
     check that the destination registers do not overlap
     the address registers.  */
  if ((! pre_indexed || write_back)
      && (   addr_reg == dest_reg
	  || addr_reg == dest_reg + 1))
    {
      ARMul_UndefInstr (state, instr);
      return;
    }

  /* Load the words.  */
  value1 = ARMul_LoadWordN (state, addr);
  value2 = ARMul_LoadWordN (state, addr + 4);

  /* Check for data aborts.  */
  if (state->Aborted)
    {
      TAKEABORT;
      return;
    }
  
  ARMul_Icycles (state, 2, 0L);

  /* Store the values.  */
  state->Reg[dest_reg] = value1;
  state->Reg[dest_reg + 1] = value2;
  
  /* Do the post addressing and writeback.  */
  if (! pre_indexed)
    addr = sum;
  
  if (! pre_indexed || write_back)
    state->Reg[addr_reg] = addr;
}

/* This function does the work of storing two words for a STRD instruction.  */

static void
Handle_Store_Double (ARMul_State * state, ARMword instr)
{
  ARMword src_reg;
  ARMword addr_reg;
  ARMword write_back  = BIT (21);
  ARMword immediate   = BIT (22);
  ARMword add_to_base = BIT (23);        
  ARMword pre_indexed = BIT (24);
  ARMword offset;
  ARMword addr;
  ARMword sum;
  ARMword base;

  BUSUSEDINCPCS;

  /* If the writeback bit is set, the pre-index bit must be clear.  */
  if (write_back && ! pre_indexed)
    {
      ARMul_UndefInstr (state, instr);
      return;
    }
  
  /* Extract the base address register.  */
  addr_reg = LHSReg;
  
  /* Base register cannot be PC.  */
  if (addr_reg == 15)
    {
      ARMul_UndefInstr (state, instr);
      return;
    }
  
  /* Extract the source register.  */
  src_reg = DESTReg;
  
  /* Source register must be even.  */
  if (src_reg & 1)
    {
      ARMul_UndefInstr (state, instr);
      return;
    }

  /* Compute the base address.  */
  base = state->Reg[addr_reg];

  /* Compute the offset.  */
  offset = immediate ? ((BITS (8, 11) << 4) | BITS (0, 3)) : state->Reg[RHSReg];

  /* Compute the sum of the two.  */
  if (add_to_base)
    sum = base + offset;
  else
    sum = base - offset;
  
  /* If this is a pre-indexed mode use the sum.  */
  if (pre_indexed)
    addr = sum;
  else
    addr = base;

  /* The address must be aligned on a 8 byte boundary.  */
  if (addr & 0x7)
    {
#ifdef ABORTS
      ARMul_DATAABORT (addr);
#else
      ARMul_UndefInstr (state, instr);
#endif
      return;
    }

  /* For pre indexed or post indexed addressing modes,
     check that the destination registers do not overlap
     the address registers.  */
  if ((! pre_indexed || write_back)
      && (   addr_reg == src_reg
	  || addr_reg == src_reg + 1))
    {
      ARMul_UndefInstr (state, instr);
      return;
    }

  /* Load the words.  */
  ARMul_StoreWordN (state, addr, state->Reg[src_reg]);
  ARMul_StoreWordN (state, addr + 4, state->Reg[src_reg + 1]);
  
  if (state->Aborted)
    {
      TAKEABORT;
      return;
    }
  
  /* Do the post addressing and writeback.  */
  if (! pre_indexed)
    addr = sum;
  
  if (! pre_indexed || write_back)
    state->Reg[addr_reg] = addr;
}

/* This function does the work of storing a word from a STR instruction.  */

static unsigned
StoreWord (ARMul_State * state, ARMword instr, ARMword address)
{
  BUSUSEDINCPCN;
#ifndef MODE32
  if (DESTReg == 15)
    state->Reg[15] = ECC | ER15INT | R15PC | EMODE;
#endif
#ifdef MODE32
  ARMul_StoreWordN (state, address, DEST);
#else
  if (VECTORACCESS (address) || ADDREXCEPT (address))
    {
      INTERNALABORT (address);
      (void) ARMul_LoadWordN (state, address);
    }
  else
    ARMul_StoreWordN (state, address, DEST);
#endif
  if (state->Aborted)
    {
      TAKEABORT;
      return state->lateabtSig;
    }
  return TRUE;
}

#ifdef MODET
/* This function does the work of storing a byte for a STRH instruction.  */

static unsigned
StoreHalfWord (ARMul_State * state, ARMword instr, ARMword address)
{
  BUSUSEDINCPCN;

#ifndef MODE32
  if (DESTReg == 15)
    state->Reg[15] = ECC | ER15INT | R15PC | EMODE;
#endif

#ifdef MODE32
  ARMul_StoreHalfWord (state, address, DEST);
#else
  if (VECTORACCESS (address) || ADDREXCEPT (address))
    {
      INTERNALABORT (address);
      (void) ARMul_LoadHalfWord (state, address);
    }
  else
    ARMul_StoreHalfWord (state, address, DEST);
#endif

  if (state->Aborted)
    {
      TAKEABORT;
      return state->lateabtSig;
    }
  return TRUE;
}

#endif /* MODET */

/* This function does the work of storing a byte for a STRB instruction.  */

static unsigned
StoreByte (ARMul_State * state, ARMword instr, ARMword address)
{
  BUSUSEDINCPCN;
#ifndef MODE32
  if (DESTReg == 15)
    state->Reg[15] = ECC | ER15INT | R15PC | EMODE;
#endif
#ifdef MODE32
  ARMul_StoreByte (state, address, DEST);
#else
  if (VECTORACCESS (address) || ADDREXCEPT (address))
    {
      INTERNALABORT (address);
      (void) ARMul_LoadByte (state, address);
    }
  else
    ARMul_StoreByte (state, address, DEST);
#endif
  if (state->Aborted)
    {
      TAKEABORT;
      return state->lateabtSig;
    }
  UNDEF_LSRBPC;
  return TRUE;
}

/* This function does the work of loading the registers listed in an LDM
   instruction, when the S bit is clear.  The code here is always increment
   after, it's up to the caller to get the input address correct and to
   handle base register modification.  */

static void
LoadMult (ARMul_State * state, ARMword instr, ARMword address, ARMword WBBase)
{
  ARMword dest, temp;

  UNDEF_LSMNoRegs;
  UNDEF_LSMPCBase;
  UNDEF_LSMBaseInListWb;
  BUSUSEDINCPCS;
#ifndef MODE32
  if (ADDREXCEPT (address))
    INTERNALABORT (address);
#endif
  if (BIT (21) && LHSReg != 15)
    LSBase = WBBase;

  /* N cycle first.  */
  for (temp = 0; !BIT (temp); temp++)
    ;

  dest = ARMul_LoadWordN (state, address);

  if (!state->abortSig && !state->Aborted)
    state->Reg[temp++] = dest;
  else if (!state->Aborted)
    {
      XScale_set_fsr_far (state, ARMul_CP15_R5_ST_ALIGN, address);
      state->Aborted = ARMul_DataAbortV;
    }

  /* S cycles from here on.  */
  for (; temp < 16; temp ++)
    if (BIT (temp))
      {
	/* Load this register.  */
	address += 4;
	dest = ARMul_LoadWordS (state, address);

	if (!state->abortSig && !state->Aborted)
	  state->Reg[temp] = dest;
	else if (!state->Aborted)
	  {
            XScale_set_fsr_far (state, ARMul_CP15_R5_ST_ALIGN, address);
	    state->Aborted = ARMul_DataAbortV;
	  }
      }

  if (BIT (15) && !state->Aborted)
    /* PC is in the reg list.  */
    WriteR15Branch (state, PC);

  /* To write back the final register.  */
  ARMul_Icycles (state, 1, 0L);

  if (state->Aborted)
    {
      if (BIT (21) && LHSReg != 15)
	LSBase = WBBase;
      TAKEABORT;
    }
}

/* This function does the work of loading the registers listed in an LDM
   instruction, when the S bit is set. The code here is always increment
   after, it's up to the caller to get the input address correct and to
   handle base register modification.  */

static void
LoadSMult (ARMul_State * state,
	   ARMword       instr,
	   ARMword       address,
	   ARMword       WBBase)
{
  ARMword dest, temp;

  UNDEF_LSMNoRegs;
  UNDEF_LSMPCBase;
  UNDEF_LSMBaseInListWb;

  BUSUSEDINCPCS;

#ifndef MODE32
  if (ADDREXCEPT (address))
    INTERNALABORT (address);
#endif

  if (BIT (21) && LHSReg != 15)
    LSBase = WBBase;

  if (!BIT (15) && state->Bank != USERBANK)
    {
      /* Temporary reg bank switch.  */
      (void) ARMul_SwitchMode (state, state->Mode, USER26MODE);
      UNDEF_LSMUserBankWb;
    }

  /* N cycle first.  */
  for (temp = 0; !BIT (temp); temp ++)
    ;

  dest = ARMul_LoadWordN (state, address);

  if (!state->abortSig)
    state->Reg[temp++] = dest;
  else if (!state->Aborted)
    {
      XScale_set_fsr_far (state, ARMul_CP15_R5_ST_ALIGN, address);
      state->Aborted = ARMul_DataAbortV;
    }

  /* S cycles from here on.  */
  for (; temp < 16; temp++)
    if (BIT (temp))
      {
	/* Load this register.  */
	address += 4;
	dest = ARMul_LoadWordS (state, address);

	if (!state->abortSig && !state->Aborted)
	  state->Reg[temp] = dest;
	else if (!state->Aborted)
	  {
            XScale_set_fsr_far (state, ARMul_CP15_R5_ST_ALIGN, address);
	    state->Aborted = ARMul_DataAbortV;
	  }
      }

  if (BIT (15) && !state->Aborted)
    {
      /* PC is in the reg list.  */
#ifdef MODE32
      if (state->Mode != USER26MODE && state->Mode != USER32MODE)
	{
	  state->Cpsr = GETSPSR (state->Bank);
	  ARMul_CPSRAltered (state);
	}

      WriteR15 (state, PC);
#else
      if (state->Mode == USER26MODE || state->Mode == USER32MODE)
	{
	  /* Protect bits in user mode.  */
	  ASSIGNN ((state->Reg[15] & NBIT) != 0);
	  ASSIGNZ ((state->Reg[15] & ZBIT) != 0);
	  ASSIGNC ((state->Reg[15] & CBIT) != 0);
	  ASSIGNV ((state->Reg[15] & VBIT) != 0);
	}
      else
	ARMul_R15Altered (state);

      FLUSHPIPE;
#endif
    }

  if (!BIT (15) && state->Mode != USER26MODE && state->Mode != USER32MODE)
    /* Restore the correct bank.  */
    (void) ARMul_SwitchMode (state, USER26MODE, state->Mode);

  /* To write back the final register.  */
  ARMul_Icycles (state, 1, 0L);

  if (state->Aborted)
    {
      if (BIT (21) && LHSReg != 15)
	LSBase = WBBase;

      TAKEABORT;
    }
}

/* This function does the work of storing the registers listed in an STM
   instruction, when the S bit is clear.  The code here is always increment
   after, it's up to the caller to get the input address correct and to
   handle base register modification.  */

static void
StoreMult (ARMul_State * state,
	   ARMword instr,
	   ARMword address,
	   ARMword WBBase)
{
  ARMword temp;

  UNDEF_LSMNoRegs;
  UNDEF_LSMPCBase;
  UNDEF_LSMBaseInListWb;

  if (!TFLAG)
    /* N-cycle, increment the PC and update the NextInstr state.  */
    BUSUSEDINCPCN;

#ifndef MODE32
  if (VECTORACCESS (address) || ADDREXCEPT (address))
    INTERNALABORT (address);

  if (BIT (15))
    PATCHR15;
#endif

  /* N cycle first.  */
  for (temp = 0; !BIT (temp); temp ++)
    ;

#ifdef MODE32
  ARMul_StoreWordN (state, address, state->Reg[temp++]);
#else
  if (state->Aborted)
    {
      (void) ARMul_LoadWordN (state, address);

      /* Fake the Stores as Loads.  */
      for (; temp < 16; temp++)
	if (BIT (temp))
	  {
	    /* Save this register.  */
	    address += 4;
	    (void) ARMul_LoadWordS (state, address);
	  }

      if (BIT (21) && LHSReg != 15)
	LSBase = WBBase;
      TAKEABORT;
      return;
    }
  else
    ARMul_StoreWordN (state, address, state->Reg[temp++]);
#endif

  if (state->abortSig && !state->Aborted)
    {
      XScale_set_fsr_far (state, ARMul_CP15_R5_ST_ALIGN, address);
      state->Aborted = ARMul_DataAbortV;
    }

  if (BIT (21) && LHSReg != 15)
    LSBase = WBBase;

  /* S cycles from here on.  */
  for (; temp < 16; temp ++)
    if (BIT (temp))
      {
	/* Save this register.  */
	address += 4;

	ARMul_StoreWordS (state, address, state->Reg[temp]);

	if (state->abortSig && !state->Aborted)
	  {
            XScale_set_fsr_far (state, ARMul_CP15_R5_ST_ALIGN, address);
	    state->Aborted = ARMul_DataAbortV;
	  }
      }

  if (state->Aborted)
    TAKEABORT;
}

/* This function does the work of storing the registers listed in an STM
   instruction when the S bit is set.  The code here is always increment
   after, it's up to the caller to get the input address correct and to
   handle base register modification.  */

static void
StoreSMult (ARMul_State * state,
	    ARMword       instr,
	    ARMword       address,
	    ARMword       WBBase)
{
  ARMword temp;

  UNDEF_LSMNoRegs;
  UNDEF_LSMPCBase;
  UNDEF_LSMBaseInListWb;

  BUSUSEDINCPCN;

#ifndef MODE32
  if (VECTORACCESS (address) || ADDREXCEPT (address))
    INTERNALABORT (address);

  if (BIT (15))
    PATCHR15;
#endif

  if (state->Bank != USERBANK)
    {
      /* Force User Bank.  */
      (void) ARMul_SwitchMode (state, state->Mode, USER26MODE);
      UNDEF_LSMUserBankWb;
    }

  for (temp = 0; !BIT (temp); temp++)
    ;	/* N cycle first.  */
  
#ifdef MODE32
  ARMul_StoreWordN (state, address, state->Reg[temp++]);
#else
  if (state->Aborted)
    {
      (void) ARMul_LoadWordN (state, address);

      for (; temp < 16; temp++)
	/* Fake the Stores as Loads.  */
	if (BIT (temp))
	  {
	    /* Save this register.  */
	    address += 4;

	    (void) ARMul_LoadWordS (state, address);
	  }

      if (BIT (21) && LHSReg != 15)
	LSBase = WBBase;

      TAKEABORT;
      return;
    }
  else
    ARMul_StoreWordN (state, address, state->Reg[temp++]);
#endif

  if (state->abortSig && !state->Aborted)
    {
      XScale_set_fsr_far (state, ARMul_CP15_R5_ST_ALIGN, address);
      state->Aborted = ARMul_DataAbortV;
    }

  /* S cycles from here on.  */
  for (; temp < 16; temp++)
    if (BIT (temp))
      {
	/* Save this register.  */
	address += 4;

	ARMul_StoreWordS (state, address, state->Reg[temp]);

	if (state->abortSig && !state->Aborted)
	  {
            XScale_set_fsr_far (state, ARMul_CP15_R5_ST_ALIGN, address);
	    state->Aborted = ARMul_DataAbortV;
	  }
      }

  if (state->Mode != USER26MODE && state->Mode != USER32MODE)
    /* Restore the correct bank.  */
    (void) ARMul_SwitchMode (state, USER26MODE, state->Mode);

  if (BIT (21) && LHSReg != 15)
    LSBase = WBBase;

  if (state->Aborted)
    TAKEABORT;
}

/* This function does the work of adding two 32bit values
   together, and calculating if a carry has occurred.  */

static ARMword
Add32 (ARMword a1, ARMword a2, int *carry)
{
  ARMword result = (a1 + a2);
  unsigned int uresult = (unsigned int) result;
  unsigned int ua1 = (unsigned int) a1;

  /* If (result == RdLo) and (state->Reg[nRdLo] == 0),
     or (result > RdLo) then we have no carry.  */
  if ((uresult == ua1) ? (a2 != 0) : (uresult < ua1))
    *carry = 1;
  else
    *carry = 0;

  return result;
}

/* This function does the work of multiplying
   two 32bit values to give a 64bit result.  */

static unsigned
Multiply64 (ARMul_State * state, ARMword instr, int msigned, int scc)
{
  /* Operand register numbers.  */
  int nRdHi, nRdLo, nRs, nRm;
  ARMword RdHi = 0, RdLo = 0, Rm;
  /* Cycle count.  */
  int scount;

  nRdHi = BITS (16, 19);
  nRdLo = BITS (12, 15);
  nRs = BITS (8, 11);
  nRm = BITS (0, 3);

  /* Needed to calculate the cycle count.  */
  Rm = state->Reg[nRm];

  /* Check for illegal operand combinations first.  */
  if (   nRdHi != 15
      && nRdLo != 15
      && nRs   != 15
      && nRm   != 15
      && nRdHi != nRdLo
      && nRdHi != nRm
      && nRdLo != nRm)
    {
      /* Intermediate results.  */
      ARMword lo, mid1, mid2, hi;
      int carry;
      ARMword Rs = state->Reg[nRs];
      int sign = 0;

      if (msigned)
	{
	  /* Compute sign of result and adjust operands if necessary.  */
	  sign = (Rm ^ Rs) & 0x80000000;

	  if (((ARMsword) Rm) < 0)
	    Rm = -Rm;

	  if (((ARMsword) Rs) < 0)
	    Rs = -Rs;
	}

      /* We can split the 32x32 into four 16x16 operations. This
	 ensures that we do not lose precision on 32bit only hosts.  */
      lo = ((Rs & 0xFFFF) * (Rm & 0xFFFF));
      mid1 = ((Rs & 0xFFFF) * ((Rm >> 16) & 0xFFFF));
      mid2 = (((Rs >> 16) & 0xFFFF) * (Rm & 0xFFFF));
      hi = (((Rs >> 16) & 0xFFFF) * ((Rm >> 16) & 0xFFFF));

      /* We now need to add all of these results together, taking
	 care to propogate the carries from the additions.  */
      RdLo = Add32 (lo, (mid1 << 16), &carry);
      RdHi = carry;
      RdLo = Add32 (RdLo, (mid2 << 16), &carry);
      RdHi +=
	(carry + ((mid1 >> 16) & 0xFFFF) + ((mid2 >> 16) & 0xFFFF) + hi);

      if (sign)
	{
	  /* Negate result if necessary.  */
	  RdLo = ~RdLo;
	  RdHi = ~RdHi;
	  if (RdLo == 0xFFFFFFFF)
	    {
	      RdLo = 0;
	      RdHi += 1;
	    }
	  else
	    RdLo += 1;
	}

      state->Reg[nRdLo] = RdLo;
      state->Reg[nRdHi] = RdHi;
    }
  else
    fprintf (stderr, "sim: MULTIPLY64 - INVALID ARGUMENTS\n");

  if (scc)
    /* Ensure that both RdHi and RdLo are used to compute Z,
       but don't let RdLo's sign bit make it to N.  */
    ARMul_NegZero (state, RdHi | (RdLo >> 16) | (RdLo & 0xFFFF));

  /* The cycle count depends on whether the instruction is a signed or
     unsigned multiply, and what bits are clear in the multiplier.  */
  if (msigned && (Rm & ((unsigned) 1 << 31)))
    /* Invert the bits to make the check against zero.  */
    Rm = ~Rm;			

  if ((Rm & 0xFFFFFF00) == 0)
    scount = 1;
  else if ((Rm & 0xFFFF0000) == 0)
    scount = 2;
  else if ((Rm & 0xFF000000) == 0)
    scount = 3;
  else
    scount = 4;

  return 2 + scount;
}

/* This function does the work of multiplying two 32bit
   values and adding a 64bit value to give a 64bit result.  */

static unsigned
MultiplyAdd64 (ARMul_State * state, ARMword instr, int msigned, int scc)
{
  unsigned scount;
  ARMword RdLo, RdHi;
  int nRdHi, nRdLo;
  int carry = 0;

  nRdHi = BITS (16, 19);
  nRdLo = BITS (12, 15);

  RdHi = state->Reg[nRdHi];
  RdLo = state->Reg[nRdLo];

  scount = Multiply64 (state, instr, msigned, LDEFAULT);

  RdLo = Add32 (RdLo, state->Reg[nRdLo], &carry);
  RdHi = (RdHi + state->Reg[nRdHi]) + carry;

  state->Reg[nRdLo] = RdLo;
  state->Reg[nRdHi] = RdHi;

  if (scc)
    /* Ensure that both RdHi and RdLo are used to compute Z,
       but don't let RdLo's sign bit make it to N.  */
    ARMul_NegZero (state, RdHi | (RdLo >> 16) | (RdLo & 0xFFFF));

  /* Extra cycle for addition.  */
  return scount + 1;
}
@


1.37
log
@[sim] Update old contact info in GPL license notices

sim/ChangeLog:

        Update old contact info in GPL license notices.
@
text
@d2318 4
a2321 2
	    case 0x30:		/* TST immed */
	      UNDEF_Test;
d2373 4
a2376 2
	    case 0x34:		/* CMP immed */
	      UNDEF_Test;
@


1.36
log
@Update sim copyright headers from GPLv2-or-later to GPLv3-or-later.

gdb/sim/ChangeLog:

        Update the non-FSF-copyrighted files in sim to GPLv3 or later.
@
text
@d16 1
a16 2
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.35
log
@* armemu.c (handle_v6_insn): Fix typo in sign extension test of the sext and sxtah instructions.
@
text
@d7 1
a7 1
    the Free Software Foundation; either version 2 of the License, or
@


1.34
log
@2005-09-19  Paul Brook  <paul@@codesourcery.com>

	* armdefs.h: Define ARMsword and ARMsdword. Use stdint.h when
	available.
	* armemu.c: Use them.
	* armvirt.c (ARMul_MemoryInit): Use correct type for size.
	* configure.ac: Check for stdint.h.
	* config.in: Regenerate.
	* configure: Regenerate.
@
text
@d379 1
a379 1
	if (Rm & 8000)
@


1.33
log
@Update the address of the FSF organization
@
text
@d1587 3
a1589 3
		      unsigned long long op1 = state->Reg[BITS (0, 3)];
		      unsigned long long op2 = state->Reg[BITS (8, 11)];
		      unsigned long long result;
d1736 4
a1739 4
		      unsigned long long op1 = state->Reg[BITS (0, 3)];
		      unsigned long long op2 = state->Reg[BITS (8, 11)];
		      unsigned long long dest;
		      unsigned long long result;
d1752 1
a1752 1
		      dest = (unsigned long long) state->Reg[BITS (16, 19)] << 32;
d3687 2
a3688 2
			long long Rm = state->Reg[MULLHSReg];
			long long Rs = state->Reg[MULACCReg];
d3707 1
a3707 1
			long long t5;
d3737 1
a3737 1
			long long t5;
d3929 1
a3929 1
	    return ((ARMword) ((long int) base >> 31L));
d3931 1
a3931 1
	    return ((ARMword) ((long int) base >> (int) shamt));
d3961 1
a3961 1
	    return ((ARMword) ((long int) base >> 31L));
d3963 1
a3963 1
	    return ((ARMword) ((long int) base >> (int) shamt));
d4044 1
a4044 1
	      return ((ARMword) ((long int) base >> 31L));
d4048 2
a4049 2
	      ASSIGNC ((ARMword) ((long int) base >> (int) (shamt - 1)) & 1);
	      return ((ARMword) ((long int) base >> (int) shamt));
d4098 1
a4098 1
	      return ((ARMword) ((long int) base >> 31L));
d4102 2
a4103 2
	      ASSIGNC ((ARMword) ((long int) base >> (int) (shamt - 1)) & 1);
	      return ((ARMword) ((long int) base >> (int) shamt));
d4242 1
a4242 1
	return ((ARMword) ((long int) base >> 31L));
d4244 1
a4244 1
	return ((ARMword) ((long int) base >> (int) shamt));
d5089 1
a5089 1
	  if (((signed long) Rm) < 0)
d5092 1
a5092 1
	  if (((signed long) Rs) < 0)
@


1.32
log
@* armemu.c (handle_v6_insn): New function - emulate a few of the v6 instructions - the ones now generated by GCC.
  (ARMulEmulate32): Call handle_v6_insn when a possible v6 insn is found.
* armdefs.h (struct ARMul_State): Add new field: is_v6.#
  (ARM_v6_Prop): Define.
* arminit.c (ARMul_NewState): Initialise the v6 flag.
  (ARMul_SelectProcessor): Determine if the v6 flag should be set.
* wrapper.c (sim_create_inferior): For unknown architectures, default to allowing the v6 instructions.
@
text
@d17 1
a17 1
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.31
log
@Index: mn10200/ChangeLog
2004-06-28  Andrew Cagney  <cagney@@gnu.org>

	* interp.c: Rename ui_loop_hook to deprecated_ui_loop_hook.

Index: d10v/ChangeLog
2004-06-28  Andrew Cagney  <cagney@@gnu.org>

	* interp.c (sim_resume): Rename ui_loop_hook to
	deprecated_ui_loop_hook.

Index: arm/ChangeLog
2004-06-28  Andrew Cagney  <cagney@@gnu.org>

	* armemu.c: Rename ui_loop_hook to deprecated_ui_loop_hook.

Index: common/ChangeLog
2004-06-28  Andrew Cagney  <cagney@@gnu.org>

	* run.c: Rename ui_loop_hook to deprecated_ui_loop_hook.
@
text
@d272 205
d2745 5
d2766 5
d2788 5
d2826 5
d2847 5
d2869 5
d2892 5
d2928 5
d2950 5
d2973 5
d3009 5
d3031 5
d3055 5
d3108 5
d3122 5
d3166 5
d3189 5
d3224 5
@


1.30
log
@Remove use of __IWMMXT__.
@
text
@d59 1
a59 1
extern int (*ui_loop_hook) (int);
d3567 1
a3567 1
      if (ui_loop_hook != NULL && ui_loop_hook_counter-- < 0)
d3570 1
a3570 1
	  ui_loop_hook (0);
@


1.30.32.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d59 1
a59 1
extern int (*deprecated_ui_loop_hook) (int);
d3567 1
a3567 1
      if (deprecated_ui_loop_hook != NULL && ui_loop_hook_counter-- < 0)
d3570 1
a3570 1
	  deprecated_ui_loop_hook (0);
@


1.29
log
@Add iWMMXt support to ARM simulator
@
text
@a21 1
#ifdef __IWMMXT__
a22 1
#endif
d378 1
a378 2
#if 0
      /* Enable this for a helpful bit of debugging when tracing is needed.  */
d383 1
a383 2
#ifdef __IWMMXT__
#if 0
a394 1
#endif
a506 1
#ifdef __IWMMXT__
a510 1
#endif
d708 1
a708 1
#ifdef __IWMMXT__
a710 1
#endif
@


1.28
log
@Add checks to catch invaliud XScale MIA, MIAPH and MIAxy instructions.
@
text
@d22 3
d386 14
d512 6
d715 4
@


1.28.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a21 1
#include "iwmmxt.h"
d377 2
a378 1
#if 0 /* Enable this for a helpful bit of debugging when tracing is needed.  */
a382 12
#if 0 /* Enable this code to help track down stack alignment bugs.  */
      {
	static ARMword old_sp = -1;

	if (old_sp != state->Reg[13])
	  {
	    old_sp = state->Reg[13];
	    fprintf (stderr, "pc: %08x: SP set to %08x%s\n",
		     pc & ~1, old_sp, (old_sp % 8) ? " [UNALIGNED!]" : "");
	  }
      }
#endif
a494 4
	      else if (   ((instr & 0xfe500f00) == 0xfc100100)
		       || ((instr & 0xfe500f00) == 0xfc000100))
		/* wldrw and wstrw are unconditional.  */
		goto mainswitch;
a691 3

	      if (ARMul_HandleIwmmxt (state, instr))
		goto donext;
@


1.28.8.1
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a21 1
#include "iwmmxt.h"
d377 2
a378 1
#if 0 /* Enable this for a helpful bit of debugging when tracing is needed.  */
a382 12
#if 0 /* Enable this code to help track down stack alignment bugs.  */
      {
	static ARMword old_sp = -1;

	if (old_sp != state->Reg[13])
	  {
	    old_sp = state->Reg[13];
	    fprintf (stderr, "pc: %08x: SP set to %08x%s\n",
		     pc & ~1, old_sp, (old_sp % 8) ? " [UNALIGNED!]" : "");
	  }
      }
#endif
a494 4
	      else if (   ((instr & 0xfe500f00) == 0xfc100100)
		       || ((instr & 0xfe500f00) == 0xfc000100))
		/* wldrw and wstrw are unconditional.  */
		goto mainswitch;
a691 3

	      if (ARMul_HandleIwmmxt (state, instr))
		goto donext;
@


1.28.24.1
log
@Merge with mainline.
@
text
@a21 1
#include "iwmmxt.h"
d377 2
a378 1
#if 0 /* Enable this for a helpful bit of debugging when tracing is needed.  */
a382 12
#if 0 /* Enable this code to help track down stack alignment bugs.  */
      {
	static ARMword old_sp = -1;

	if (old_sp != state->Reg[13])
	  {
	    old_sp = state->Reg[13];
	    fprintf (stderr, "pc: %08x: SP set to %08x%s\n",
		     pc & ~1, old_sp, (old_sp % 8) ? " [UNALIGNED!]" : "");
	  }
      }
#endif
a494 4
	      else if (   ((instr & 0xfe500f00) == 0xfc100100)
		       || ((instr & 0xfe500f00) == 0xfc000100))
		/* wldrw and wstrw are unconditional.  */
		goto mainswitch;
a691 3

	      if (ARMul_HandleIwmmxt (state, instr))
		goto donext;
@


1.27
log
@Only perform access checks if 'check' is set.
Report unknown machine numbers.
Formatting tidy ups.
@
text
@d3369 15
a3383 13
		    {
		      /* XScale MIA instruction.  Signed multiplication of two 32 bit
			 values and addition to 40 bit accumulator.  */
		      long long Rm = state->Reg[MULLHSReg];
		      long long Rs = state->Reg[MULACCReg];

		      if (Rm & (1 << 31))
			Rm -= 1ULL << 32;
		      if (Rs & (1 << 31))
			Rs -= 1ULL << 32;
		      state->Accumulator += Rm * Rs;
		    }
		    goto donext;
d3386 30
a3415 28
		    {
		      /* XScale MIAPH instruction.  */
		      ARMword t1 = state->Reg[MULLHSReg] >> 16;
		      ARMword t2 = state->Reg[MULACCReg] >> 16;
		      ARMword t3 = state->Reg[MULLHSReg] & 0xffff;
		      ARMword t4 = state->Reg[MULACCReg] & 0xffff;
		      long long t5;

		      if (t1 & (1 << 15))
			t1 -= 1 << 16;
		      if (t2 & (1 << 15))
			t2 -= 1 << 16;
		      if (t3 & (1 << 15))
			t3 -= 1 << 16;
		      if (t4 & (1 << 15))
			t4 -= 1 << 16;
		      t1 *= t2;
		      t5 = t1;
		      if (t5 & (1 << 31))
			t5 -= 1ULL << 32;
		      state->Accumulator += t5;
		      t3 *= t4;
		      t5 = t3;
		      if (t5 & (1 << 31))
			t5 -= 1ULL << 32;
		      state->Accumulator += t5;
		    }
		    goto donext;
d3418 29
a3446 27
		    {
		      /* XScale MIAxy instruction.  */
		      ARMword t1;
		      ARMword t2;
		      long long t5;

		      if (BIT (17))
			t1 = state->Reg[MULLHSReg] >> 16;
		      else
			t1 = state->Reg[MULLHSReg] & 0xffff;

		      if (BIT (16))
			t2 = state->Reg[MULACCReg] >> 16;
		      else
			t2 = state->Reg[MULACCReg] & 0xffff;

		      if (t1 & (1 << 15))
			t1 -= 1 << 16;
		      if (t2 & (1 << 15))
			t2 -= 1 << 16;
		      t1 *= t2;
		      t5 = t1;
		      if (t5 & (1 << 31))
			t5 -= 1ULL << 32;
		      state->Accumulator += t5;
		    }
		    goto donext;
@


1.27.2.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d3369 13
a3381 15
		    if (BITS (4, 11) == 1 && BITS (16, 17) == 0)
		      {
			/* XScale MIA instruction.  Signed multiplication of
			   two 32 bit values and addition to 40 bit accumulator.  */
			long long Rm = state->Reg[MULLHSReg];
			long long Rs = state->Reg[MULACCReg];

			if (Rm & (1 << 31))
			  Rm -= 1ULL << 32;
			if (Rs & (1 << 31))
			  Rs -= 1ULL << 32;
			state->Accumulator += Rm * Rs;
			goto donext;
		      }
		    break;
d3384 28
a3411 30
		    if (BITS (4, 11) == 1 && BITS (16, 17) == 0)
		      {
			/* XScale MIAPH instruction.  */
			ARMword t1 = state->Reg[MULLHSReg] >> 16;
			ARMword t2 = state->Reg[MULACCReg] >> 16;
			ARMword t3 = state->Reg[MULLHSReg] & 0xffff;
			ARMword t4 = state->Reg[MULACCReg] & 0xffff;
			long long t5;

			if (t1 & (1 << 15))
			  t1 -= 1 << 16;
			if (t2 & (1 << 15))
			  t2 -= 1 << 16;
			if (t3 & (1 << 15))
			  t3 -= 1 << 16;
			if (t4 & (1 << 15))
			  t4 -= 1 << 16;
			t1 *= t2;
			t5 = t1;
			if (t5 & (1 << 31))
			  t5 -= 1ULL << 32;
			state->Accumulator += t5;
			t3 *= t4;
			t5 = t3;
			if (t5 & (1 << 31))
			  t5 -= 1ULL << 32;
			state->Accumulator += t5;
			goto donext;
		      }
		    break;
d3414 27
a3440 29
		    if (BITS (4, 11) == 1)
		      {
			/* XScale MIAxy instruction.  */
			ARMword t1;
			ARMword t2;
			long long t5;

			if (BIT (17))
			  t1 = state->Reg[MULLHSReg] >> 16;
			else
			  t1 = state->Reg[MULLHSReg] & 0xffff;

			if (BIT (16))
			  t2 = state->Reg[MULACCReg] >> 16;
			else
			  t2 = state->Reg[MULACCReg] & 0xffff;

			if (t1 & (1 << 15))
			  t1 -= 1 << 16;
			if (t2 & (1 << 15))
			  t2 -= 1 << 16;
			t1 *= t2;
			t5 = t1;
			if (t5 & (1 << 31))
			  t5 -= 1ULL << 32;
			state->Accumulator += t5;
			goto donext;
		      }
		    break;
@


1.26
log
@Fix parameters passed to CPRead[13] and CPRead[14].
@
text
@d3209 1
a3209 1
			  /* XScale MAR insn.  Move two registers into accumulator.  */		      
@


1.26.6.1
log
@merge from trunk
@
text
@d3209 1
a3209 1
			  /* XScale MAR insn.  Move two registers into accumulator.  */
@


1.25
log
@Add support for XScale's coprocessor access check register.
Fix formatting.
@
text
@d482 2
a483 1
		  dest = pc + 8 + 1; /* Force entry into Thumb mode.  */
d488 1
a488 1
		  
d548 4
a551 1
	  ARMword cp14r0 = state->CPRead[14] (state, 0, 0);
d553 1
a553 1
	  if (cp14r0 && ARMul_CP14_R0_ENABLE)
d555 1
a555 1
	      unsigned long newcycles, nowtime = ARMul_Time(state);
d559 2
a560 1
	      if (cp14r0 && ARMul_CP14_R0_CCD)
d566 1
d570 1
d573 1
d587 1
a587 1
		  cp14r1 = state->CPRead[14] (state, 1, 0);
d590 1
a590 1
		  while (newcycles)
d598 3
a600 2
			cp14r1++;
			newcycles--;
d602 1
d604 1
d607 4
a610 2
		      if (state->CPRead[13] (state, 8, 0)
			&& ARMul_CP13_R8_PMUS)
d622 2
a623 2
	  if ((pc | 3) == (read_cp15_reg (14, 0, 8) | 2)
           || (pc | 3) == (read_cp15_reg (14, 0, 9) | 2))
d631 1
a631 1

a633 1
	  /* If the condition codes don't match, stop here.  */
d718 2
a719 1
		{		/* MUL */
d729 3
a731 4
		    {
		      UNDEF_MULPCDest;
		    }
		  for (dest = 0, temp = 0; dest < 32; dest++)
d733 3
a735 1
		      temp = dest;	/* mult takes this many/2 I cycles */
d739 2
a740 1
		{		/* AND reg */
d750 3
a752 5
		{
		  /* LDR register offset, no write-back, down, post indexed */
		  LHPOSTDOWN ();
		  /* fall through to rest of decoding */
		}
d755 2
a756 1
		{		/* MULS */
d758 1
d773 3
a775 4
		    {
		      UNDEF_MULPCDest;
		    }
		  for (dest = 0, temp = 0; dest < 32; dest++)
d777 3
a779 1
		      temp = dest;	/* mult takes this many/2 I cycles */
d783 2
a784 1
		{		/* ANDS reg */
d795 1
a795 1
		  /* STRH register offset, write-back, down, post indexed */
d812 3
a814 4
		    {
		      UNDEF_MULPCDest;
		    }
		  for (dest = 0, temp = 0; dest < 32; dest++)
d816 3
a818 1
		      temp = dest;	/* mult takes this many/2 I cycles */
d832 3
a834 5
		{
		  /* LDR register offset, write-back, down, post-indexed */
		  LHPOSTDOWN ();
		  /* fall through to rest of the decoding */
		}
d837 2
a838 1
		{		/* MLAS */
d840 1
d856 3
a858 4
		    {
		      UNDEF_MULPCDest;
		    }
		  for (dest = 0, temp = 0; dest < 32; dest++)
d860 3
a862 1
		      temp = dest;	/* mult takes this many/2 I cycles */
d866 2
a867 1
		{		/* EORS Reg */
d878 1
a878 1
		  /* STRH immediate offset, no write-back, down, post indexed */
d901 3
a903 5
		{
		  /* LDR immediate offset, no write-back, down, post indexed */
		  LHPOSTDOWN ();
		  /* fall through to the rest of the instruction decoding */
		}
d908 1
d926 1
a926 1
		  /* STRH immediate offset, write-back, down, post indexed */
d939 3
a941 5
		{
		  /* LDR immediate offset, write-back, down, post indexed */
		  LHPOSTDOWN ();
		  /* fall through to remainder of instruction decoding */
		}
d946 1
d964 1
a964 1
		  /* STRH register offset, no write-back, up, post indexed */
d981 2
a982 1
		{		/* MULL */
d998 3
a1000 5
		{
		  /* LDR register offset, no write-back, up, post indexed */
		  LHPOSTUP ();
		  /* fall through to remaining instruction decoding */
		}
d1004 2
a1005 1
		{		/* MULL */
d1018 2
a1019 1
		{		/* possible C,V,N to set */
d1037 1
a1037 1
		  /* STRH register offset, write-back, up, post-indexed */
a1040 2
#endif
#ifdef MODET
d1042 2
a1043 1
		{		/* MULL */
d1059 4
d1064 1
a1064 8
		  /* LDR register offset, write-back, up, post indexed */
		  LHPOSTUP ();
		  /* fall through to remaining instruction decoding */
		}
#endif
#ifdef MODET
	      if (BITS (4, 7) == 0x9)
		{		/* MULL */
d1077 2
a1078 1
		{		/* possible C,V,N to set */
d1096 1
a1096 1
		  /* STRH immediate offset, no write-back, up post indexed */
a1109 2
#endif
#ifdef MODET
d1111 2
a1112 1
		{		/* MULL */
d1128 4
d1133 1
a1133 7
		  /* LDR immediate offset, no write-back, up, post indexed */
		  LHPOSTUP ();
		}
#endif
#ifdef MODET
	      if (BITS (4, 7) == 0x9)
		{		/* MULL */
d1161 1
a1161 1
		  /* STRH immediate offset, write-back, up, post indexed */
d1165 1
a1165 2
#endif
#ifdef MODET
d1167 2
a1168 1
		{		/* MULL */
d1184 5
d1190 1
a1190 8
		  /* LDR immediate offset, write-back, up, post indexed */
		  LHPOSTUP ();
		  /* fall through to remaining instruction decoding */
		}
#endif
#ifdef MODET
	      if (BITS (4, 7) == 0x9)
		{		/* MULL */
d1201 1
d1215 1
a1215 1
	    case 0x10:		/* TST reg and MRS CPSR and SWP word */
d1261 1
a1261 1
		  /* STRH register offset, no write-back, down, pre indexed */
d1277 2
a1278 1
		{		/* SWP */
d1297 1
a1297 3
		    {
		      TAKEABORT;
		    }
d1313 3
a1315 5
		{
		  /* LDR register offset, no write-back, down, pre indexed */
		  LHPREDOWN ();
		  /* continue with remaining instruction decode */
		}
d1318 2
a1319 1
		{		/* TSTP reg */
d1330 2
a1331 1
		{		/* TST reg */
d1338 1
a1338 1
	    case 0x12:		/* TEQ reg and MSR reg to CPSR (ARM6) */
d1408 1
a1408 1
		  /* STRH register offset, write-back, down, pre indexed */
d1450 2
a1451 2
			/* BKPT - normally this will cause an abort, but on the
			   XScale we must check the DCSR.  */
d1464 1
a1464 1
		  /* MSR reg to CPSR */
d1474 2
a1475 3
		{
		  UNDEF_Test;
		}
d1481 3
a1483 5
		{
		  /* LDR register offset, write-back, down, pre indexed.  */
		  LHPREDOWNWB ();
		  /* Continue with remaining instruction decode.  */
		}
d1486 2
a1487 1
		{		/* TEQP reg */
d1498 2
a1499 1
		{		/* TEQ Reg */
d1506 1
a1506 1
	    case 0x14:		/* CMP reg and MRS SPSR and SWP byte */
d1580 2
a1581 1
		{		/* SWP */
d1596 1
a1596 3
		    {
		      TAKEABORT;
		    }
d1599 2
a1600 1
		{		/* MRS SPSR */
d1605 2
a1606 3
		{
		  UNDEF_Test;
		}
d1609 1
a1609 1
	    case 0x15:		/* CMPP reg */
d1612 3
a1614 5
		{
		  /* LDR immediate offset, no write-back, down, pre indexed */
		  LHPREDOWN ();
		  /* continue with remaining instruction decode */
		}
d1617 2
a1618 1
		{		/* CMPP reg */
d1629 2
a1630 1
		{		/* CMP reg */
d1718 1
a1718 1
		  /* STRH immediate offset, write-back, down, pre indexed */
d1734 2
a1735 1
		{		/* MSR */
d1748 3
a1750 5
		{
		  /* LDR immediate offset, write-back, down, pre indexed */
		  LHPREDOWNWB ();
		  /* continue with remaining instruction decoding */
		}
d1765 2
a1766 1
		{		/* CMN reg */
d1772 2
a1773 1
		    {		/* possible C,V,N to set */
d1791 1
a1791 1
		  /* STRH register offset, no write-back, up, pre indexed */
d1814 3
a1816 5
		{
		  /* LDR register offset, no write-back, up, pre indexed */
		  LHPREUP ();
		  /* continue with remaining instruction decoding */
		}
d1827 1
a1827 1
		  /* STRH register offset, write-back, up, pre indexed */
d1849 3
a1851 5
		{
		  /* LDR register offset, write-back, up, pre indexed */
		  LHPREUPWB ();
		  /* continue with remaining instruction decoding */
		}
d1861 1
a1861 1
		  /* STRH immediate offset, no write-back, up, pre indexed */
d1884 3
a1886 5
		{
		  /* LDR immediate offset, no write-back, up, pre indexed */
		  LHPREUP ();
		  /* continue with instruction decoding */
		}
d1897 1
a1897 1
		  /* STRH immediate offset, write-back, up, pre indexed */
d1919 3
a1921 5
		{
		  /* LDR immediate offset, write-back, up, pre indexed */
		  LHPREUPWB ();
		  /* continue instruction decoding */
		}
d1927 1
a1927 1
	      
d1961 1
d1984 1
d2008 1
d2010 2
a2011 1
		{		/* possible C,V,N to set */
d2036 2
a2037 1
		{		/* possible C,V,N to set */
d2101 2
a2102 1
		{		/* TSTP immed */
d2113 2
a2114 1
		  DPSImmRHS;	/* TST immed */
d2122 2
a2123 3
		{		/* MSR immed to CPSR */
		  ARMul_FixCPSR (state, instr, DPImmRHS);
		}
d2125 1
a2125 3
		{
		  UNDEF_Test;
		}
d2130 2
a2131 1
		{		/* TEQP immed */
d2154 2
a2155 1
		{		/* CMPP immed */
d2167 2
a2168 1
		  lhs = LHS;	/* CMP immed */
d2172 1
d2187 1
a2187 1
	      if (DESTReg == 15)	/* MSR */
d2190 1
a2190 3
		{
		  UNDEF_Test;
		}
d2193 1
a2193 1
	    case 0x37:		/* CMNP immed */
d2195 2
a2196 1
		{		/* CMNP immed */
d2208 2
a2209 1
		  lhs = LHS;	/* CMN immed */
d2214 2
a2215 1
		    {		/* possible C,V,N to set */
d2229 1
a2229 1
	    case 0x38:		/* ORR immed */
d2234 1
a2234 1
	    case 0x39:		/* ORRS immed */
d2240 1
a2240 1
	    case 0x3a:		/* MOV immed */
d2245 1
a2245 1
	    case 0x3b:		/* MOVS immed */
d2250 1
a2250 1
	    case 0x3c:		/* BIC immed */
d2255 1
a2255 1
	    case 0x3d:		/* BICS immed */
d2261 1
a2261 1
	    case 0x3e:		/* MVN immed */
d2266 1
a2266 1
	    case 0x3f:		/* MVNS immed */
d2271 1
d2274 1
a2274 1
	    case 0x40:		/* Store Word, No WriteBack, Post Dec, Immed */
d2280 1
a2280 1
	    case 0x41:		/* Load Word, No WriteBack, Post Dec, Immed */
d2286 1
a2286 1
	    case 0x42:		/* Store Word, WriteBack, Post Dec, Immed */
d2297 1
a2297 1
	    case 0x43:		/* Load Word, WriteBack, Post Dec, Immed */
d2307 1
a2307 1
	    case 0x44:		/* Store Byte, No WriteBack, Post Dec, Immed */
d2313 1
a2313 1
	    case 0x45:		/* Load Byte, No WriteBack, Post Dec, Immed */
d2319 1
a2319 1
	    case 0x46:		/* Store Byte, WriteBack, Post Dec, Immed */
d2329 1
a2329 1
	    case 0x47:		/* Load Byte, WriteBack, Post Dec, Immed */
d2339 1
a2339 1
	    case 0x48:		/* Store Word, No WriteBack, Post Inc, Immed */
d2345 1
a2345 1
	    case 0x49:		/* Load Word, No WriteBack, Post Inc, Immed */
d2351 1
a2351 1
	    case 0x4a:		/* Store Word, WriteBack, Post Inc, Immed */
d2361 1
a2361 1
	    case 0x4b:		/* Load Word, WriteBack, Post Inc, Immed */
d2371 1
a2371 1
	    case 0x4c:		/* Store Byte, No WriteBack, Post Inc, Immed */
d2377 1
a2377 1
	    case 0x4d:		/* Load Byte, No WriteBack, Post Inc, Immed */
d2383 1
a2383 1
	    case 0x4e:		/* Store Byte, WriteBack, Post Inc, Immed */
d2393 1
a2393 1
	    case 0x4f:		/* Load Byte, WriteBack, Post Inc, Immed */
d2404 1
a2404 1
	    case 0x50:		/* Store Word, No WriteBack, Pre Dec, Immed */
d2408 1
a2408 1
	    case 0x51:		/* Load Word, No WriteBack, Pre Dec, Immed */
d2412 1
a2412 1
	    case 0x52:		/* Store Word, WriteBack, Pre Dec, Immed */
d2420 1
a2420 1
	    case 0x53:		/* Load Word, WriteBack, Pre Dec, Immed */
d2428 1
a2428 1
	    case 0x54:		/* Store Byte, No WriteBack, Pre Dec, Immed */
d2432 1
a2432 1
	    case 0x55:		/* Load Byte, No WriteBack, Pre Dec, Immed */
d2436 1
a2436 1
	    case 0x56:		/* Store Byte, WriteBack, Pre Dec, Immed */
d2444 1
a2444 1
	    case 0x57:		/* Load Byte, WriteBack, Pre Dec, Immed */
d2452 1
a2452 1
	    case 0x58:		/* Store Word, No WriteBack, Pre Inc, Immed */
d2456 1
a2456 1
	    case 0x59:		/* Load Word, No WriteBack, Pre Inc, Immed */
d2460 1
a2460 1
	    case 0x5a:		/* Store Word, WriteBack, Pre Inc, Immed */
d2468 1
a2468 1
	    case 0x5b:		/* Load Word, WriteBack, Pre Inc, Immed */
d2476 1
a2476 1
	    case 0x5c:		/* Store Byte, No WriteBack, Pre Inc, Immed */
d2480 1
a2480 1
	    case 0x5d:		/* Load Byte, No WriteBack, Pre Inc, Immed */
d2484 1
a2484 1
	    case 0x5e:		/* Store Byte, WriteBack, Pre Inc, Immed */
d2492 1
a2492 1
	    case 0x5f:		/* Load Byte, WriteBack, Pre Inc, Immed */
d2503 1
a2503 1
	    case 0x60:		/* Store Word, No WriteBack, Post Dec, Reg */
d2518 1
a2518 1
	    case 0x61:		/* Load Word, No WriteBack, Post Dec, Reg */
d2534 1
a2534 1
	    case 0x62:		/* Store Word, WriteBack, Post Dec, Reg */
d2551 1
a2551 1
	    case 0x63:		/* Load Word, WriteBack, Post Dec, Reg */
d2569 1
a2569 1
	    case 0x64:		/* Store Byte, No WriteBack, Post Dec, Reg */
d2584 1
a2584 1
	    case 0x65:		/* Load Byte, No WriteBack, Post Dec, Reg */
d2600 1
a2600 1
	    case 0x66:		/* Store Byte, WriteBack, Post Dec, Reg */
d2617 1
a2617 1
	    case 0x67:		/* Load Byte, WriteBack, Post Dec, Reg */
d2635 1
a2635 1
	    case 0x68:		/* Store Word, No WriteBack, Post Inc, Reg */
d2650 1
a2650 1
	    case 0x69:		/* Load Word, No WriteBack, Post Inc, Reg */
d2666 1
a2666 1
	    case 0x6a:		/* Store Word, WriteBack, Post Inc, Reg */
d2683 1
a2683 1
	    case 0x6b:		/* Load Word, WriteBack, Post Inc, Reg */
d2701 1
a2701 1
	    case 0x6c:		/* Store Byte, No WriteBack, Post Inc, Reg */
d2716 1
a2716 1
	    case 0x6d:		/* Load Byte, No WriteBack, Post Inc, Reg */
d2732 1
a2732 1
	    case 0x6e:		/* Store Byte, WriteBack, Post Inc, Reg */
d2749 1
a2749 1
	    case 0x6f:		/* Load Byte, WriteBack, Post Inc, Reg */
d2768 1
a2768 1
	    case 0x70:		/* Store Word, No WriteBack, Pre Dec, Reg */
d2777 1
a2777 1
	    case 0x71:		/* Load Word, No WriteBack, Pre Dec, Reg */
d2786 1
a2786 1
	    case 0x72:		/* Store Word, WriteBack, Pre Dec, Reg */
d2801 1
a2801 1
	    case 0x73:		/* Load Word, WriteBack, Pre Dec, Reg */
d2816 1
a2816 1
	    case 0x74:		/* Store Byte, No WriteBack, Pre Dec, Reg */
d2825 1
a2825 1
	    case 0x75:		/* Load Byte, No WriteBack, Pre Dec, Reg */
d2834 1
a2834 1
	    case 0x76:		/* Store Byte, WriteBack, Pre Dec, Reg */
d2849 1
a2849 1
	    case 0x77:		/* Load Byte, WriteBack, Pre Dec, Reg */
d2864 1
a2864 1
	    case 0x78:		/* Store Word, No WriteBack, Pre Inc, Reg */
d2873 1
a2873 1
	    case 0x79:		/* Load Word, No WriteBack, Pre Inc, Reg */
d2882 1
a2882 1
	    case 0x7a:		/* Store Word, WriteBack, Pre Inc, Reg */
d2897 1
a2897 1
	    case 0x7b:		/* Load Word, WriteBack, Pre Inc, Reg */
d2912 1
a2912 1
	    case 0x7c:		/* Store Byte, No WriteBack, Pre Inc, Reg */
d2921 1
a2921 1
	    case 0x7d:		/* Load Byte, No WriteBack, Pre Inc, Reg */
d2930 1
a2930 1
	    case 0x7e:		/* Store Byte, WriteBack, Pre Inc, Reg */
d2945 1
a2945 1
	    case 0x7f:		/* Load Byte, WriteBack, Pre Inc, Reg */
d2972 1
a2972 1
	    case 0x80:		/* Store, No WriteBack, Post Dec */
d2976 1
a2976 1
	    case 0x81:		/* Load, No WriteBack, Post Dec */
d2980 1
a2980 1
	    case 0x82:		/* Store, WriteBack, Post Dec */
d2985 1
a2985 1
	    case 0x83:		/* Load, WriteBack, Post Dec */
d2990 1
a2990 1
	    case 0x84:		/* Store, Flags, No WriteBack, Post Dec */
d2994 1
a2994 1
	    case 0x85:		/* Load, Flags, No WriteBack, Post Dec */
d2998 1
a2998 1
	    case 0x86:		/* Store, Flags, WriteBack, Post Dec */
d3003 1
a3003 1
	    case 0x87:		/* Load, Flags, WriteBack, Post Dec */
d3008 1
a3008 1
	    case 0x88:		/* Store, No WriteBack, Post Inc */
d3012 1
a3012 1
	    case 0x89:		/* Load, No WriteBack, Post Inc */
d3016 1
a3016 1
	    case 0x8a:		/* Store, WriteBack, Post Inc */
d3021 1
a3021 1
	    case 0x8b:		/* Load, WriteBack, Post Inc */
d3026 1
a3026 1
	    case 0x8c:		/* Store, Flags, No WriteBack, Post Inc */
d3030 1
a3030 1
	    case 0x8d:		/* Load, Flags, No WriteBack, Post Inc */
d3034 1
a3034 1
	    case 0x8e:		/* Store, Flags, WriteBack, Post Inc */
d3039 1
a3039 1
	    case 0x8f:		/* Load, Flags, WriteBack, Post Inc */
d3044 1
a3044 1
	    case 0x90:		/* Store, No WriteBack, Pre Dec */
d3048 1
a3048 1
	    case 0x91:		/* Load, No WriteBack, Pre Dec */
d3052 1
a3052 1
	    case 0x92:		/* Store, WriteBack, Pre Dec */
d3057 1
a3057 1
	    case 0x93:		/* Load, WriteBack, Pre Dec */
d3062 1
a3062 1
	    case 0x94:		/* Store, Flags, No WriteBack, Pre Dec */
d3066 1
a3066 1
	    case 0x95:		/* Load, Flags, No WriteBack, Pre Dec */
d3070 1
a3070 1
	    case 0x96:		/* Store, Flags, WriteBack, Pre Dec */
d3075 1
a3075 1
	    case 0x97:		/* Load, Flags, WriteBack, Pre Dec */
d3080 1
a3080 1
	    case 0x98:		/* Store, No WriteBack, Pre Inc */
d3084 1
a3084 1
	    case 0x99:		/* Load, No WriteBack, Pre Inc */
d3088 1
a3088 1
	    case 0x9a:		/* Store, WriteBack, Pre Inc */
d3093 1
a3093 1
	    case 0x9b:		/* Load, WriteBack, Pre Inc */
d3098 1
a3098 1
	    case 0x9c:		/* Store, Flags, No WriteBack, Pre Inc */
d3102 1
a3102 1
	    case 0x9d:		/* Load, Flags, No WriteBack, Pre Inc */
d3106 1
a3106 1
	    case 0x9e:		/* Store, Flags, WriteBack, Pre Inc */
d3111 1
a3111 1
	    case 0x9f:		/* Load, Flags, WriteBack, Pre Inc */
d3184 1
d3221 1
a3221 1
	    case 0xc0:		/* Store , No WriteBack , Post Dec */
d3266 1
a3266 1
	    case 0xc1:		/* Load , No WriteBack , Post Dec */
d3271 1
a3271 1
	    case 0xc6:		/* Store , WriteBack , Post Dec */
d3278 1
a3278 1
	    case 0xc7:		/* Load , WriteBack , Post Dec */
d3285 1
a3285 1
	    case 0xcc:		/* Store , No WriteBack , Post Inc */
d3290 1
a3290 1
	    case 0xcd:		/* Load , No WriteBack , Post Inc */
d3295 1
a3295 1
	    case 0xce:		/* Store , WriteBack , Post Inc */
d3302 1
a3302 1
	    case 0xcf:		/* Load , WriteBack , Post Inc */
d3309 1
a3309 1
	    case 0xd4:		/* Store , No WriteBack , Pre Dec */
d3314 1
a3314 1
	    case 0xd5:		/* Load , No WriteBack , Pre Dec */
d3319 1
a3319 1
	    case 0xd6:		/* Store , WriteBack , Pre Dec */
d3326 1
a3326 1
	    case 0xd7:		/* Load , WriteBack , Pre Dec */
d3333 1
a3333 1
	    case 0xdc:		/* Store , No WriteBack , Pre Inc */
d3338 1
a3338 1
	    case 0xdd:		/* Load , No WriteBack , Pre Inc */
d3343 1
a3343 1
	    case 0xde:		/* Store , WriteBack , Pre Inc */
d3350 1
a3350 1
	    case 0xdf:		/* Load , WriteBack , Pre Inc */
d3358 1
d3455 2
a3456 1
		{		/* MCR */
d3470 2
a3471 1
	      else		/* CDP Part 1 */
d3486 2
a3487 1
		{		/* MRC */
d3499 2
a3500 1
	      else		/* CDP Part 2 */
d3505 1
a3505 1
	      /*  SWI instruction.  */
d3645 2
a3646 1
	  if (shamt == 0)	/* its an RRX */
d3652 1
a3652 1
  
d3757 1
d3787 2
a3788 1
	    {			/* its an RRX */
d3820 1
d3827 1
d3852 2
a3853 1
    abort (); /* ARMul_R15Altered would have to support it.  */
d3857 1
d3862 1
d3904 2
a3905 1
    base = ECC | ER15INT | R15PC | EMODE;	/* Now forbidden, but ....  */
d3926 2
a3927 1
      if (shamt == 0)		/* its an RRX */
d3947 2
a3948 1
	return ECC | ER15INT | R15PC | EMODE;	/* Now forbidden, but ...  */
d3953 1
a3953 1
  /* Otherwise an immediate.  */
d3975 1
a3975 1
      return (state->lateabtSig);
d3997 1
a3997 3
    {
      INTERNALABORT (address);
    }
d4003 1
a4003 1
      return (state->lateabtSig);
d4007 3
a4009 4
    {
      if (dest & 1 << (16 - 1))
	dest = (dest & ((1 << 16) - 1)) - (1 << 16);
    }
d4027 1
a4027 3
    {
      INTERNALABORT (address);
    }
d4033 1
a4033 1
      return (state->lateabtSig);
d4037 3
a4039 4
    {
      if (dest & 1 << (8 - 1))
	dest = (dest & ((1 << 8) - 1)) - (1 << 8);
    }
d4042 1
a4314 1

d4344 1
a4344 1
      return (state->lateabtSig);
d4353 1
a4353 1
   handle base register modification.a  */
d4371 1
d4373 1
a4373 1
    ;	/* N cycle first */
d4385 2
a4386 1
  for (; temp < 16; temp++)	/* S cycles from here on */
d4388 2
a4389 1
      {				/* load this register */
d4451 1
d4453 1
a4453 1
    ;	/* N cycle first.  */
d4461 1
a4461 1
      XScale_set_fsr_far(state, ARMul_CP15_R5_ST_ALIGN, address);
d4465 1
a4466 1
    /* S cycles from here on.  */
d4477 1
a4477 1
            XScale_set_fsr_far(state, ARMul_CP15_R5_ST_ALIGN, address);
d4531 4
a4534 2
StoreMult (ARMul_State * state, ARMword instr,
	   ARMword address, ARMword WBBase)
d4554 3
a4556 2
  for (temp = 0; !BIT (temp); temp++)
    ;	/* N cycle first.  */
d4573 1
d4585 1
a4585 1
      XScale_set_fsr_far(state, ARMul_CP15_R5_ST_ALIGN, address);
d4592 2
a4593 1
  for (; temp < 16; temp++)	/* S cycles from here on */
d4603 1
a4603 1
            XScale_set_fsr_far(state, ARMul_CP15_R5_ST_ALIGN, address);
a4669 1

d4678 1
a4678 1
      XScale_set_fsr_far(state, ARMul_CP15_R5_ST_ALIGN, address);
d4682 1
a4683 1
    /* S cycles from here on.  */
d4693 1
a4693 1
            XScale_set_fsr_far(state, ARMul_CP15_R5_ST_ALIGN, address);
d4720 1
a4720 1
     or (result > RdLo) then we have no carry: */
d4726 1
a4726 1
  return (result);
a4766 1

a4793 1

a4803 1
      /* Else undefined result.  */
d4812 3
a4814 5
    {
      /* Ensure that both RdHi and RdLo are used to compute Z,
	 but don't let RdLo's sign bit make it to N.  */
      ARMul_NegZero (state, RdHi | (RdLo >> 16) | (RdLo & 0xFFFF));
    }
@


1.24
log
@Fix handling of XScale LDRD and STRD instructions with post indexed addressing modes.
@
text
@d17 1
a17 1
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
d23 21
a43 33
static ARMword GetDPRegRHS (ARMul_State * state, ARMword instr);
static ARMword GetDPSRegRHS (ARMul_State * state, ARMword instr);
static void WriteR15 (ARMul_State * state, ARMword src);
static void WriteSR15 (ARMul_State * state, ARMword src);
static void WriteR15Branch (ARMul_State * state, ARMword src);
static ARMword GetLSRegRHS (ARMul_State * state, ARMword instr);
static ARMword GetLS7RHS (ARMul_State * state, ARMword instr);
static unsigned LoadWord (ARMul_State * state, ARMword instr,
			  ARMword address);
static unsigned LoadHalfWord (ARMul_State * state, ARMword instr,
			      ARMword address, int signextend);
static unsigned LoadByte (ARMul_State * state, ARMword instr, ARMword address,
			  int signextend);
static unsigned StoreWord (ARMul_State * state, ARMword instr,
			   ARMword address);
static unsigned StoreHalfWord (ARMul_State * state, ARMword instr,
			       ARMword address);
static unsigned StoreByte (ARMul_State * state, ARMword instr,
			   ARMword address);
static void LoadMult (ARMul_State * state, ARMword address, ARMword instr,
		      ARMword WBBase);
static void StoreMult (ARMul_State * state, ARMword address, ARMword instr,
		       ARMword WBBase);
static void LoadSMult (ARMul_State * state, ARMword address, ARMword instr,
		       ARMword WBBase);
static void StoreSMult (ARMul_State * state, ARMword address, ARMword instr,
			ARMword WBBase);
static unsigned Multiply64 (ARMul_State * state, ARMword instr,
			    int signextend, int scc);
static unsigned MultiplyAdd64 (ARMul_State * state, ARMword instr,
			       int signextend, int scc);
static void Handle_Load_Double (ARMul_State * state, ARMword instr);
static void Handle_Store_Double (ARMul_State * state, ARMword instr);
d51 1
a51 1
/* How often to run the ui_loop update, when in use */
d54 1
a54 1
/* Counter for the ui_loop_hook update */
d57 1
a57 1
/* Actual hook to call to run through gdb's gui event loop */
d63 1
a63 3
/***************************************************************************\
*               short-hand macros for LDR/STR                               *
\***************************************************************************/
d65 1
a65 1
/* store post decrement writeback */
d68 2
a69 2
  if (StoreHalfWord(state, instr, lhs))                 \
     LSBase = lhs - GetLS7RHS(state, instr) ;
d71 1
a71 1
/* store post increment writeback */
d74 2
a75 2
  if (StoreHalfWord(state, instr, lhs))                 \
     LSBase = lhs + GetLS7RHS(state, instr) ;
d77 1
a77 1
/* store pre decrement */
d79 1
a79 1
  (void)StoreHalfWord(state, instr, LHS - GetLS7RHS(state, instr)) ;
d81 1
a81 1
/* store pre decrement writeback */
d83 3
a85 3
  temp = LHS - GetLS7RHS(state, instr) ;                \
  if (StoreHalfWord(state, instr, temp))                \
     LSBase = temp ;
d87 1
a87 1
/* store pre increment */
d89 1
a89 1
  (void)StoreHalfWord(state, instr, LHS + GetLS7RHS(state, instr)) ;
d91 1
a91 1
/* store pre increment writeback */
d93 3
a95 3
  temp = LHS + GetLS7RHS(state, instr) ;                \
  if (StoreHalfWord(state, instr, temp))                \
     LSBase = temp ;
d157 25
a181 23

/* load pre decrement */
#define LHPREDOWN()                                     \
{                                                       \
  int done = 1 ;                                        \
  temp = LHS - GetLS7RHS(state,instr) ;                 \
  switch (BITS(5,6)) {                                  \
    case 1: /* H */                                     \
      (void)LoadHalfWord(state,instr,temp,LUNSIGNED) ;  \
      break ;                                           \
    case 2: /* SB */                                    \
      (void)LoadByte(state,instr,temp,LSIGNED) ;        \
      break ;                                           \
    case 3: /* SH */                                    \
      (void)LoadHalfWord(state,instr,temp,LSIGNED) ;    \
      break ;                                           \
    case 0: /* SWP handled elsewhere */                 \
    default:                                            \
      done = 0 ;                                        \
      break ;                                           \
    }                                                   \
  if (done)                                             \
     break ;                                            \
d184 28
a211 25
/* load pre decrement writeback */
#define LHPREDOWNWB()                                   \
{                                                       \
  int done = 1 ;                                        \
  temp = LHS - GetLS7RHS(state, instr) ;                \
  switch (BITS(5,6)) {                                  \
    case 1: /* H */                                     \
      if (LoadHalfWord(state,instr,temp,LUNSIGNED))     \
         LSBase = temp ;                                \
      break ;                                           \
    case 2: /* SB */                                    \
      if (LoadByte(state,instr,temp,LSIGNED))           \
         LSBase = temp ;                                \
      break ;                                           \
    case 3: /* SH */                                    \
      if (LoadHalfWord(state,instr,temp,LSIGNED))       \
         LSBase = temp ;                                \
      break ;                                           \
    case 0: /* SWP handled elsewhere */                 \
    default:                                            \
      done = 0 ;                                        \
      break ;                                           \
    }                                                   \
  if (done)                                             \
     break ;                                            \
d214 25
a238 22
/* load pre increment */
#define LHPREUP()                                       \
{                                                       \
  int done = 1 ;                                        \
  temp = LHS + GetLS7RHS(state,instr) ;                 \
  switch (BITS(5,6)) {                                  \
    case 1: /* H */                                     \
      (void)LoadHalfWord(state,instr,temp,LUNSIGNED) ;  \
      break ;                                           \
    case 2: /* SB */                                    \
      (void)LoadByte(state,instr,temp,LSIGNED) ;        \
      break ;                                           \
    case 3: /* SH */                                    \
      (void)LoadHalfWord(state,instr,temp,LSIGNED) ;    \
      break ;                                           \
    case 0: /* SWP handled elsewhere */                 \
    default:                                            \
      done = 0 ;                                        \
      break ;                                           \
    }                                                   \
  if (done)                                             \
     break ;                                            \
d241 28
a268 25
/* load pre increment writeback */
#define LHPREUPWB()                                     \
{                                                       \
  int done = 1 ;                                        \
  temp = LHS + GetLS7RHS(state, instr) ;                \
  switch (BITS(5,6)) {                                  \
    case 1: /* H */                                     \
      if (LoadHalfWord(state,instr,temp,LUNSIGNED))     \
         LSBase = temp ;                                \
      break ;                                           \
    case 2: /* SB */                                    \
      if (LoadByte(state,instr,temp,LSIGNED))           \
         LSBase = temp ;                                \
      break ;                                           \
    case 3: /* SH */                                    \
      if (LoadHalfWord(state,instr,temp,LSIGNED))       \
         LSBase = temp ;                                \
      break ;                                           \
    case 0: /* SWP handled elsewhere */                 \
    default:                                            \
      done = 0 ;                                        \
      break ;                                           \
    }                                                   \
  if (done)                                             \
     break ;                                            \
d271 1
a271 3
/***************************************************************************\
*                             EMULATION of ARM6                             *
\***************************************************************************/
d273 2
a274 2
/* The PC pipeline value depends on whether ARM or Thumb instructions
   are being executed: */
d279 1
a279 1
ARMul_Emulate32 (register ARMul_State * state)
d281 1
a281 1
ARMul_Emulate26 (register ARMul_State * state)
d284 10
a293 10
  register ARMword instr,	/* the current instruction */
    dest = 0,			/* almost the DestBus */
    temp,			/* ubiquitous third hand */
    pc = 0;			/* the address of the current instruction */
  ARMword lhs, rhs;		/* almost the ABus and BBus */
  ARMword decoded = 0, loaded = 0;	/* instruction pipeline */

/***************************************************************************\
*                        Execute the next instruction                       *
\***************************************************************************/
d303 2
a304 1
    {				/* just keep going */
d306 1
d310 2
a311 1
	  state->Reg[15] += isize;	/* Advance the pipeline, and an S cycle */
d319 2
a320 1
	  state->Reg[15] += isize;	/* Advance the pipeline, and an N cycle */
d329 2
a330 1
	  pc += isize;		/* Program counter advanced, and an S cycle */
d338 2
a339 1
	  pc += isize;		/* Program counter advanced, and an N cycle */
d346 2
a347 1
	case RESUME:		/* The program counter has been changed */
d354 1
a354 1
	  instr = ARMul_ReLoadInstr (state, pc, isize);
d356 1
a356 1
	  loaded = ARMul_ReLoadInstr (state, pc + isize * 2, isize);
d360 2
a361 1
	default:		/* The program counter has been changed */
d368 1
a368 1
	  instr = ARMul_LoadInstrN (state, pc, isize);
d370 1
a370 1
	  loaded = ARMul_LoadInstrS (state, pc + (isize * 2), isize);
d374 1
a376 1

d385 2
a386 1
	{			/* Any exceptions */
d434 1
a434 1
         dealing with the BL instruction. */
d436 1
a436 1
	{			/* check if in Thumb mode */
d438 2
d443 2
a444 1
	      ARMul_UndefInstr (state, instr);	/* This is a Thumb instruction */
d447 2
a448 1
	    case t_branch:	/* already processed */
d451 6
a456 2
	    case t_decoded:	/* ARM instruction available */
	      instr = new;	/* so continue instruction decoding */
d462 1
a462 3
/***************************************************************************\
*                       Check the condition codes                           *
\***************************************************************************/
d464 2
a465 1
	goto mainswitch;	/* vile deed in the need for speed */
d467 1
d469 1
a469 1
	{			/* check the condition code */
d581 1
a581 1
		  /* coded like this for portability */
d617 1
a617 3
/***************************************************************************\
*               Actual execution of instructions begins here                *
\***************************************************************************/
d620 2
a621 1
	{			/* if the condition codes don't match, stop here */
d684 1
a684 4

/***************************************************************************\
*                 Data Processing Register RHS Instructions                 *
\***************************************************************************/
d690 1
a690 1
		  /* STRH register offset, no write-back, down, post indexed */
d1472 1
a1472 1
		  /* LDR register offset, write-back, down, pre indexed */
d1474 1
a1474 1
		  /* continue with remaining instruction decode */
d1554 1
a1554 1
		  /* STRH immediate offset, no write-back, down, pre indexed */
d1925 2
a1926 3
/***************************************************************************\
*                Data Processing Immediate RHS Instructions                 *
\***************************************************************************/
d2260 1
a2260 3
/***************************************************************************\
*              Single Data Transfer Immediate RHS Instructions              *
\***************************************************************************/
d2488 2
a2489 3
/***************************************************************************\
*              Single Data Transfer Register RHS Instructions               *
\***************************************************************************/
d2957 2
a2958 3
/***************************************************************************\
*                   Multiple Data Transfer Instructions                     *
\***************************************************************************/
a3103 3
/***************************************************************************\
*                            Branch forward                                 *
\***************************************************************************/
d3105 1
a3117 3
/***************************************************************************\
*                           Branch backward                                 *
\***************************************************************************/
d3119 1
a3131 3
/***************************************************************************\
*                       Branch and Link forward                             *
\***************************************************************************/
d3133 1
d3142 1
d3144 1
a3144 1
	      state->Reg[14] = pc + 4;	/* put PC into Link */
d3146 1
a3146 1
	      state->Reg[14] = (pc + 4) | ECC | ER15INT | EMODE;	/* put PC into Link */
a3151 3
/***************************************************************************\
*                       Branch and Link backward                            *
\***************************************************************************/
d3153 1
d3162 1
d3164 1
a3164 1
	      state->Reg[14] = pc + 4;	/* put PC into Link */
d3166 1
a3166 1
	      state->Reg[14] = (pc + 4) | ECC | ER15INT | EMODE;	/* put PC into Link */
d3172 1
a3172 4
/***************************************************************************\
*                        Co-Processor Data Transfers                        *
\***************************************************************************/

d3174 1
a3174 1
	      if (state->is_XScale)
d3176 5
a3180 1
		  if (BITS (4, 7) != 0x00)
d3182 2
a3183 6

		  if (BITS (8, 11) != 0x00)
		    ARMul_UndefInstr (state, instr); /* Not CP0.  */

		  /* XScale MAR insn.  Move two registers into accumulator.  */
		  if (BITS (0, 3) == 0x00)
d3185 15
a3199 3
		      state->Accumulator = state->Reg[BITS (12, 15)];
		      state->Accumulator += (ARMdword) state->Reg[BITS (16, 19)] << 32;
		      break;
d3201 3
a3203 1
		  /* Access to any other acc is unpredicatable.  */
d3213 1
a3213 1
	      if (state->is_XScale)
d3215 5
a3219 1
		  if (BITS (4, 7) != 0x00)
d3221 2
a3222 6

		  if (BITS (8, 11) != 0x00)
		    ARMul_UndefInstr (state, instr); /* Not CP0.  */

		  /* XScale MRA insn.  Move accumulator into two registers.  */
		  if (BITS (0, 3) == 0x00)
d3224 13
a3236 1
		      ARMword t1 = (state->Accumulator >> 32) & 255;
d3238 2
a3239 2
		      if (t1 & 128)
			t1 -= 256;
d3241 4
a3244 3
		      state->Reg[BITS (12, 15)] = state->Accumulator;
		      state->Reg[BITS (16, 19)] = t1;
		      break;
d3246 3
a3248 1
		  /* Access to any other acc is unpredicatable.  */
a3294 1

a3342 3
/***************************************************************************\
*            Co-Processor Register Transfers (MCR) and Data Ops             *
\***************************************************************************/
d3344 1
d3346 5
a3458 3
/***************************************************************************\
*            Co-Processor Register Transfers (MRC) and Data Ops             *
\***************************************************************************/
d3460 1
a3485 3
/***************************************************************************\
*                             SWI instruction                               *
\***************************************************************************/
d3487 1
d3513 2
a3514 3
		{
		  ARMul_Abort (state, ARMul_SWIV);
		}
d3516 2
a3517 2
	    }			/* 256 way main switch */
	}			/* if temp */
d3539 1
a3539 1
  while (!stop_simulator);	/* do loop */
d3546 1
a3546 1
}				/* Emulate 26/32 in instruction based mode */
d3548 3
a3550 6

/***************************************************************************\
* This routine evaluates most Data Processing register RHS's with the S     *
* bit clear.  It is intended to be called from the macro DPRegRHS, which    *
* filters the common case of an unshifted register with in line code        *
\***************************************************************************/
d3559 2
a3560 1
    {				/* shift amount in a register */
d3603 2
a3604 1
    {				/* shift amount is a constant */
d3633 2
a3634 1
  return (0);			/* just to shut up lint */
d3637 4
a3640 6
/***************************************************************************\
* This routine evaluates most Logical Data Processing register RHS's        *
* with the S bit set.  It is intended to be called from the macro           *
* DPSRegRHS, which filters the common case of an unshifted register         *
* with in line code                                                         *
\***************************************************************************/
d3649 2
a3650 1
    {				/* shift amount in a register */
d3729 2
a3730 1
    {				/* shift amount is a constant */
d3779 2
a3780 1
  return (0);			/* just to shut up lint */
d3783 1
a3783 3
/***************************************************************************\
* This routine handles writes to register 15 when the S bit is not set.     *
\***************************************************************************/
d3808 1
a3808 3
/***************************************************************************\
* This routine handles writes to register 15 when the S bit is set.         *
\***************************************************************************/
d3843 1
a3843 1
   will switch to Thumb mode if the least significant bit is set. */
d3850 2
a3851 1
    {		/* Thumb bit */
d3866 3
a3868 5
/***************************************************************************\
* This routine evaluates most Load and Store register RHS's.  It is         *
* intended to be called from the macro LSRegRHS, which filters the          *
* common case of an unshifted register with in line code                    *
\***************************************************************************/
d3878 1
a3878 1
    base = ECC | ER15INT | R15PC | EMODE;	/* Now forbidden, but .... */
d3903 2
d3906 1
a3906 1
  return (0);			/* just to shut up lint */
d3909 1
a3909 3
/***************************************************************************\
* This routine evaluates the ARM7T halfword and signed transfer RHS's.      *
\***************************************************************************/
d3915 2
a3916 1
    {				/* register */
d3919 1
a3919 1
	return ECC | ER15INT | R15PC | EMODE;	/* Now forbidden, but ... */
d3924 1
a3924 1
  /* else immediate */
d3928 1
a3928 3
/***************************************************************************\
* This function does the work of loading a word for a LDR instruction.      *
\***************************************************************************/
d3938 1
a3938 3
    {
      INTERNALABORT (address);
    }
d3940 1
d3942 1
d3957 1
a3957 3
/***************************************************************************\
* This function does the work of loading a halfword.                        *
\***************************************************************************/
d3991 1
a3991 3
/***************************************************************************\
* This function does the work of loading a byte for a LDRB instruction.     *
\***************************************************************************/
d4022 1
a4022 3
/***************************************************************************\
* This function does the work of loading two words for a LDRD instruction. *
\***************************************************************************/
d4129 1
a4129 3
/***************************************************************************\
* This function does the work of storing two words for a STRD instruction. *
\***************************************************************************/
d4232 1
a4232 3
/***************************************************************************\
* This function does the work of storing a word from a STR instruction.     *
\***************************************************************************/
d4256 1
a4256 1
      return (state->lateabtSig);
d4258 1
a4258 1
  return (TRUE);
d4262 1
a4262 3
/***************************************************************************\
* This function does the work of storing a byte for a STRH instruction.     *
\***************************************************************************/
d4289 1
a4289 1
      return (state->lateabtSig);
d4292 1
a4292 1
  return (TRUE);
d4297 1
a4297 3
/***************************************************************************\
* This function does the work of storing a byte for a STRB instruction.     *
\***************************************************************************/
d4324 1
a4324 1
  return (TRUE);
d4327 4
a4330 6
/***************************************************************************\
* This function does the work of loading the registers listed in an LDM     *
* instruction, when the S bit is clear.  The code here is always increment  *
* after, it's up to the caller to get the input address correct and to      *
* handle base register modification.                                        *
\***************************************************************************/
d4343 1
a4343 3
    {
      INTERNALABORT (address);
    }
d4348 3
a4350 1
  for (temp = 0; !BIT (temp); temp++);	/* N cycle first */
d4352 1
d4357 1
a4357 1
      XScale_set_fsr_far(state, ARMul_CP15_R5_ST_ALIGN, address);
d4366 1
d4371 1
a4371 1
            XScale_set_fsr_far(state, ARMul_CP15_R5_ST_ALIGN, address);
d4377 2
a4378 3
    {				/* PC is in the reg list */
      WriteR15Branch(state, PC);
    }
d4380 2
a4381 1
  ARMul_Icycles (state, 1, 0L);	/* to write back the final register */
d4391 4
a4394 6
/***************************************************************************\
* This function does the work of loading the registers listed in an LDM     *
* instruction, when the S bit is set. The code here is always increment     *
* after, it's up to the caller to get the input address correct and to      *
* handle base register modification.                                        *
\***************************************************************************/
d4412 1
a4412 3
    {
      INTERNALABORT (address);
    }
d4498 4
a4501 6
/***************************************************************************\
* This function does the work of storing the registers listed in an STM     *
* instruction, when the S bit is clear.  The code here is always increment  *
* after, it's up to the caller to get the input address correct and to      *
* handle base register modification.                                        *
\***************************************************************************/
d4512 1
d4514 2
a4515 3
    {
      BUSUSEDINCPCN;		/* N-cycle, increment the PC and update the NextInstr state */
    }
d4519 2
a4520 3
    {
      INTERNALABORT (address);
    }
d4525 3
a4527 1
  for (temp = 0; !BIT (temp); temp++);	/* N cycle first */
d4534 3
a4536 1
      for (; temp < 16; temp++)	/* Fake the Stores as Loads */
d4538 2
a4539 1
	  {			/* save this register */
d4563 2
a4564 1
      {				/* save this register */
d4577 1
a4577 3
    {
      TAKEABORT;
    }
d4580 4
a4583 6
/***************************************************************************\
* This function does the work of storing the registers listed in an STM     *
* instruction when the S bit is set.  The code here is always increment     *
* after, it's up to the caller to get the input address correct and to      *
* handle base register modification.                                        *
\***************************************************************************/
d4601 1
a4601 3
    {
      INTERNALABORT (address);
    }
d4675 1
a4675 3
    {
      TAKEABORT;
    }
d4678 2
a4679 4
/***************************************************************************\
* This function does the work of adding two 32bit values together, and      *
* calculating if a carry has occurred.                                      *
\***************************************************************************/
d4698 2
a4699 4
/***************************************************************************\
* This function does the work of multiplying two 32bit values to give a     *
* 64bit result.                                                             *
\***************************************************************************/
d4704 2
a4705 1
  int nRdHi, nRdLo, nRs, nRm;	/* operand register numbers */
d4707 2
a4708 1
  int scount;			/* cycle count */
d4715 1
a4715 1
  /* Needed to calculate the cycle count: */
d4718 2
a4719 2
  /* Check for illegal operand combinations first: */
  if (nRdHi != 15
d4721 5
a4725 2
      && nRs != 15
      && nRm != 15 && nRdHi != nRdLo && nRdHi != nRm && nRdLo != nRm)
d4727 2
a4728 1
      ARMword lo, mid1, mid2, hi;	/* intermediate results */
d4746 2
a4747 2
      /* We can split the 32x32 into four 16x16 operations. This ensures
         that we do not lose precision on 32bit only hosts: */
d4753 2
a4754 2
      /* We now need to add all of these results together, taking care
         to propogate the carries from the additions: */
d4775 1
d4779 1
a4779 1
    }				/* else undefined result */
d4785 2
a4786 2
      /* Ensure that both RdHi and RdLo are used to compute Z, but
	 don't let RdLo's sign bit make it to N.  */
d4791 1
a4791 1
     unsigned multiply, and what bits are clear in the multiplier: */
d4793 2
a4794 1
    Rm = ~Rm;			/* invert the bits to make the check against zero */
d4808 2
a4809 4
/***************************************************************************\
* This function does the work of multiplying two 32bit values and adding    *
* a 64bit value to give a 64bit result.                                     *
\***************************************************************************/
d4834 3
a4836 5
    {
      /* Ensure that both RdHi and RdLo are used to compute Z, but
	 don't let RdLo's sign bit make it to N.  */
      ARMul_NegZero (state, RdHi | (RdLo >> 16) | (RdLo & 0xFFFF));
    }
d4838 2
a4839 1
  return scount + 1;		/* extra cycle for addition */
@


1.23
log
@* XScale coprocessor support.

2001-04-18  matthew green  <mrg@@redhat.com>

	* armcopro.c (write_cp15_reg): Set CHANGEMODE if endianness changes.
	(read_cp15_reg): Make non-static.
	(XScale_cp15_LDC): Update for write_cp15_reg() change.
	(XScale_cp15_MCR): Likewise.
	(XScale_cp15_write_reg): Likewise.
	(XScale_check_memacc): New function. Check for breakpoints being
	activated by memory accesses.  Does not support the Branch Target
	Buffer.
	(XScale_set_fsr_far): New function. Set FSR and FAR for XScale.
	(XScale_debug_moe): New function. Set the debug Method Of Entry,
	if configured.
	(write_cp14_reg): Reset count counter if requested.
	* armdefs.h (struct ARMul_State): New members `LastTime' and
	`CP14R0_CCD' used for the timer/counters.
	(ARMul_CP13_R0_FIQ, ARMul_CP13_R0_IRQ, ARMul_CP13_R8_PMUS,
	ARMul_CP14_R0_ENABLE, ARMul_CP14_R0_CLKRST, ARMul_CP14_R0_CCD,
	ARMul_CP14_R0_INTEN0, ARMul_CP14_R0_INTEN1, ARMul_CP14_R0_INTEN2,
	ARMul_CP14_R0_FLAG0, ARMul_CP14_R0_FLAG1, ARMul_CP14_R0_FLAG2,
	ARMul_CP14_R10_MOE_IB, ARMul_CP14_R10_MOE_DB, ARMul_CP14_R10_MOE_BT,
	ARMul_CP15_R1_ENDIAN, ARMul_CP15_R1_ALIGN, ARMul_CP15_R5_X,
	ARMul_CP15_R5_ST_ALIGN, ARMul_CP15_R5_IMPRE, ARMul_CP15_R5_MMU_EXCPT,
	ARMul_CP15_DBCON_M, ARMul_CP15_DBCON_E1, ARMul_CP15_DBCON_E0): New
	defines for XScale registers.
	(XScale_check_memacc, XScale_set_fsr_far, XScale_debug_moe): Prototype.
	(ARMul_Emulate32, ARMul_Emulate26): Clean up function definition.
	(ARMul_Emulate32): Handle the clock counter and hardware instruction
	breakpoints.  Call XScale_set_fsr_far() for software breakpoints and
	software interrupts.
	(LoadMult): Call XScale_set_fsr_far() for data aborts.
	(LoadSMult): Likewise.
	(StoreMult): Likewise.
	(StoreSMult): Likewise.
	* armemu.h (write_cp15_reg): Update prototype.
	* arminit.c (ARMul_NewState): Initialise CP14R0_CCD and LastTime.
	(ARMul_Abort): If XScale, check for FIQ and IRQ being enabled in CP13
	register 0.
	* armvirt.c (GetWord): Call XScale_check_memacc().
	(PutWord): Likewise.
@
text
@d622 1
a622 1
		      ARMword addr = BIT (24) ? temp2 : temp;
d631 1
a631 1
			  int wb = BIT (24) && BIT (21);
d638 1
a638 1
			    LSBase = addr;
d648 1
a648 1
		      ARMword addr = BIT (24) ? temp2 : temp;
d662 2
a663 2
			  if (BIT (21))
			    LSBase = addr;
@


1.22
log
@Add support for disabling alignment checks when performing GDB interface
calls or SWI emulaiton routines.  (Alignment checking code has not yet been
contributed).
@
text
@d532 73
d1431 5
a1435 20
			  /* BKPT - normally this will cause an abort, but for the
			     XScale if bit 31 in register 10 of coprocessor 14 is
			     clear, then this is treated as a no-op.  */
			  if (state->is_XScale)
			    {
			      if (read_cp14_reg (10) & (1UL << 31))
				{
				  ARMword value;
				  
				  value = read_cp14_reg (10);
				  value &= ~0x1c;
				  value |= 0xc;
				  
				  write_cp14_reg (10, value);
				  write_cp15_reg (state, 5, 0, 0, 0x200);  /* Set FSR.  */
				  write_cp15_reg (state, 6, 0, 0, pc);     /* Set FAR.  */
				}
			      else
				break;
			    }
d3486 1
d4357 1
d4370 1
d4437 1
d4453 1
d4555 1
d4571 1
d4653 1
d4668 1
@


1.21
log
@Remove Prefetch abort for breakpoints.  Instead set the state to RESUME.
@
text
@d1372 2
a1373 2
				  write_cp15_reg (5, 0, 0, 0x200);  /* Set FSR.  */
				  write_cp15_reg (6, 0, 0, pc);     /* Set FAR.  */
@


1.20
log
@Add code to preserve processor mode when a prefetch
abort is signalled after processing a breakpoint.
@
text
@a1342 1
		      int in_thumb_mode;
d1380 2
a1381 11
		      /* We must signal an abort to mark the next instruction as
			 invalid and in need of refetching.  This is because if this
			 the instruction was a breakpoint inserted by the debugger,
			 the instruction could be changed back to its original value.
			 The abort however, will automatically reset the processor into
			 ARM mode, so we have to preserve the mode flag and resort it
			 after singalling the abort.  */
		      in_thumb_mode = TFLAG;
		      ARMul_Abort (state, ARMul_PrefetchAbortV);
		      ASSIGNT (in_thumb_mode);
		      
@


1.19
log
@Add parentheses ready for future conbtribution
@
text
@d1343 1
d1381 8
d1390 2
@


1.18
log
@Update base address register after restoring register bank.
@
text
@d282 1
a283 1
ARMword
a284 1
{
a285 1
ARMword
d287 1
a288 1
#endif
d1357 22
a1378 21
		    
			/* BKPT - normally this will cause an abort, but for the
			   XScale if bit 31 in register 10 of coprocessor 14 is
			   clear, then this is treated as a no-op.  */
			if (state->is_XScale)
			  {
			    if (read_cp14_reg (10) & (1UL << 31))
			      {
				ARMword value;
				
				value = read_cp14_reg (10);
				value &= ~0x1c;
				value |= 0xc;
				
				write_cp14_reg (10, value);
				write_cp15_reg (5, 0, 0, 0x200);  /* Set FSR.  */
				write_cp15_reg (6, 0, 0, pc);     /* Set FAR.  */
			      }
			    else
			      break;
			  }
d3425 2
a3426 1
		{		/* a prefetch abort */
d4296 3
a4298 1
    state->Aborted = ARMul_DataAbortV;
d4308 3
a4310 1
	  state->Aborted = ARMul_DataAbortV;
d4336 4
a4339 2
LoadSMult (ARMul_State * state, ARMword instr,
	   ARMword address, ARMword WBBase)
d4374 3
a4376 1
    state->Aborted = ARMul_DataAbortV;
d4389 3
a4391 1
	  state->Aborted = ARMul_DataAbortV;
d4416 1
d4432 1
d4488 1
d4490 3
a4492 1
    state->Aborted = ARMul_DataAbortV;
d4501 1
d4503 1
d4505 3
a4507 1
	  state->Aborted = ARMul_DataAbortV;
d4509 1
d4524 1
a4524 2
StoreSMult (
	    ARMul_State * state,
d4570 1
d4573 1
a4573 1
      
d4586 3
a4588 1
    state->Aborted = ARMul_DataAbortV;
d4600 3
a4602 1
	  state->Aborted = ARMul_DataAbortV;
@


1.17
log
@Fix test for StoreDouble Instruction.
@
text
@a2934 1

a2970 1

a3006 1

d4340 1
d4342 1
d4350 3
d4355 2
a4356 1
      (void) ARMul_SwitchMode (state, state->Mode, USER26MODE);	/* temporary reg bank switch */
d4360 2
a4361 2
  if (BIT (21) && LHSReg != 15)
    LSBase = WBBase;
a4362 1
  for (temp = 0; !BIT (temp); temp++);	/* N cycle first */
d4364 1
d4370 2
a4371 1
  for (; temp < 16; temp++)	/* S cycles from here on */
d4373 2
a4374 1
      {				/* load this register */
d4377 1
d4385 2
a4386 1
    {				/* PC is in the reg list */
d4393 1
d4397 2
a4398 1
	{			/* protect bits in user mode */
d4411 2
a4412 1
    (void) ARMul_SwitchMode (state, USER26MODE, state->Mode);	/* restore the correct bank */
d4414 2
a4415 1
  ARMul_Icycles (state, 1, 0L);	/* to write back the final register */
a4422 1

d4504 5
a4508 2
StoreSMult (ARMul_State * state, ARMword instr,
	    ARMword address, ARMword WBBase)
d4515 1
d4517 1
d4523 1
d4530 2
a4531 1
      (void) ARMul_SwitchMode (state, state->Mode, USER26MODE);	/* Force User Bank */
d4535 3
a4537 1
  for (temp = 0; !BIT (temp); temp++);	/* N cycle first */
d4544 3
a4546 1
      for (; temp < 16; temp++)	/* Fake the Stores as Loads */
d4548 2
a4549 1
	  {			/* save this register */
d4553 1
d4556 1
d4558 1
d4564 1
d4568 2
a4569 4
  if (BIT (21) && LHSReg != 15)
    LSBase = WBBase;

  for (; temp < 16; temp++)	/* S cycles from here on */
d4571 2
a4572 1
      {				/* save this register */
d4574 1
d4576 1
d4582 5
a4586 1
    (void) ARMul_SwitchMode (state, USER26MODE, state->Mode);	/* restore the correct bank */
@


1.16
log
@oops - remove redundant prototype introduced in previous delta
@
text
@d620 1
a620 1
	      if (BITS (4, 7) == 0xE)
d788 1
a788 1
	      if (BITS (4, 7) == 0xE)
d876 1
a876 1
	      if (BITS (4, 7) == 0xE)
d1010 1
a1010 1
	      if (BITS (4, 7) == 0xE)
d1179 1
a1179 1
	      if (BITS (4, 7) == 0xE)
d1333 1
a1333 1
	      if (BITS (4, 7) == 0xE)
d1497 1
a1497 1
	      if (BITS (4, 7) == 0xE)
d1652 1
a1652 1
	      if (BITS (4, 7) == 0xE)
d1724 1
a1724 1
	      if (BITS (4, 7) == 0xE)
d1762 1
a1762 1
	      if (BITS (4, 7) == 0xE)
d1798 1
a1798 1
	      else if (BITS (4, 7) == 0xE)
d1836 1
a1836 1
	      if (BITS (4, 7) == 0xE)
@


1.15
log
@Add emulation of double word load and store instructions.
@
text
@a41 2
static unsigned StoreDoubleWord (ARMul_State * state, ARMword instr,
				 ARMword address);
@


1.14
log
@Add support for ARM's v5TE architecture and Intel's XScale extenstions
@
text
@d42 2
d56 2
d414 1
a414 1
	      fprintf (stderr, "At %08lx Instr %08lx Mode %02lx\n", pc, instr,
d617 10
a626 1
	      /* TODO: CHECK: should 0xD and 0xF generate undefined intruction aborts? */
d785 10
d873 10
d1007 10
d1176 10
d1330 10
d1494 10
d1649 10
d1721 10
d1759 10
d1795 10
d1833 10
d3957 214
d4665 1
a4665 1
    fprintf (stderr, "MULTIPLY64 - INVALID ARGUMENTS\n");
@


1.13
log
@Compute write back value for post increment loads before
performing the load in case the offset register is overwritten.
@
text
@d462 24
d540 57
d1084 42
d1198 66
a1270 2
#endif
#ifdef MODET
d1272 2
a1273 1
		{		/* BX */
d1278 46
d1325 2
a1326 1
		{		/* MSR reg to CPSR */
d1329 4
d1370 54
d1503 66
d2755 1
a2755 1
		     as ARM_BE_BREAKPOINT in gdb/arm-tdep.c.  */
d3004 20
d3029 25
d3150 82
@


1.12
log
@* armemu.c (ARMul_Emulate, t_undefined): Proceed to next insn.
@
text
@d109 1
a109 1
/* load post decrement writeback */
d112 6
a117 3
  int done = 1 ;                                        \
  lhs = LHS ;                                           \
  switch (BITS(5,6)) {                                  \
d119 3
a121 3
      if (LoadHalfWord(state,instr,lhs,LUNSIGNED))      \
         LSBase = lhs - GetLS7RHS(state,instr) ;        \
      break ;                                           \
d123 3
a125 3
      if (LoadByte(state,instr,lhs,LSIGNED))            \
         LSBase = lhs - GetLS7RHS(state,instr) ;        \
      break ;                                           \
d127 4
a130 4
      if (LoadHalfWord(state,instr,lhs,LSIGNED))        \
         LSBase = lhs - GetLS7RHS(state,instr) ;        \
      break ;                                           \
    case 0: /* SWP handled elsewhere */                 \
d132 2
a133 2
      done = 0 ;                                        \
      break ;                                           \
d136 1
a136 1
     break ;                                            \
d139 1
a139 1
/* load post increment writeback */
d142 6
a147 3
  int done = 1 ;                                        \
  lhs = LHS ;                                           \
  switch (BITS(5,6)) {                                  \
d149 3
a151 3
      if (LoadHalfWord(state,instr,lhs,LUNSIGNED))      \
         LSBase = lhs + GetLS7RHS(state,instr) ;        \
      break ;                                           \
d153 3
a155 3
      if (LoadByte(state,instr,lhs,LSIGNED))            \
         LSBase = lhs + GetLS7RHS(state,instr) ;        \
      break ;                                           \
d157 4
a160 4
      if (LoadHalfWord(state,instr,lhs,LSIGNED))        \
         LSBase = lhs + GetLS7RHS(state,instr) ;        \
      break ;                                           \
    case 0: /* SWP handled elsewhere */                 \
d162 2
a163 2
      done = 0 ;                                        \
      break ;                                           \
d166 1
a166 1
     break ;                                            \
d168 1
@


1.11
log
@* armemu.h (INSN_SIZE): New macro.
(SET_ABORT): Save CPSR in SPSR and set LR.
* armemu.c (ARMul_Emulate, isize): Set to INSN_SIZE.
(WriteR15, WriteSR15): Do not discard bit 1 in Thumb mode.
* arminit.c (ARMul_Abort): Use new SETABORT and INSN_SIZE.
@
text
@d431 1
a431 1
	      break;
@


1.10
log
@* armemu.c (LoadSMult): Use WriteR15() to discard the least
significant bits of PC.
@
text
@d302 1
a302 8
#ifdef MODET
      if (TFLAG)
	{
	  isize = 2;
	}
      else
#endif
	isize = 4;
d3100 9
a3108 2
     WriteR15Branch() below.  */
  src &= 0xfffffffc;
a3124 1
  src &= 0xfffffffc;
a3125 1
  state->Reg[15] = src & PCBITS;
d3131 7
d3139 6
@


1.9
log
@* armemu.h (WRITEDESTB): New macro.
* armemu.c (ARMul_Emulate26, bl): Use WriteR15Branch() to
modify PC.  Moved the existing logic...
(WriteR15Branch): ... here.  New function.
(WriteR15, WriteSR15): Drop the two least significant bits.
(LoadSMult): Use WriteR15Branch() to modify PC.
(LoadMult): Use WRITEDESTB() instead of WRITEDEST().
@
text
@d3547 1
a3547 1
      state->Reg[15] = PC;
d3558 1
a3559 1
      FLUSHPIPE;
@


1.8
log
@* armemu.h (PSR_FBITS, PSR_SBITS, PSR_XBITS, PSR_CBITS): New.
(SETPSR_F, SETPSR_S, SETPSR_X, SETPSR_C): New macros.
(SETPSR, SET_INTMODE, SETCC): Removed.
* armsupp.c (ARMul_FixCPSR, ARMul_FixSPSR): Do not test bit
mask.  Use SETPSR_* to modify PSR.
(ARMul_SetCPSR): Load all bits from value.
* armemu.c (ARMul_Emulate, msr): Do not test bit mask.
@
text
@d27 1
d1086 2
a1087 29
		  /* Branch to the address in RHSReg. If bit0 of
		     destination address is 1 then switch to Thumb mode: */
		  ARMword addr = state->Reg[RHSReg];

		  /* If we read the PC then the bottom bit is clear */
		  if (RHSReg == 15)
		    addr &= ~1;

		  /* Enable this for a helpful bit of debugging when
		     GDB is not yet fully working... 
		     fprintf (stderr, "BX at %x to %x (go %s)\n",
		     state->Reg[15], addr, (addr & 1) ? "thumb": "arm" ); */

		  if (addr & (1 << 0))
		    {		/* Thumb bit */
		      SETT;
		      state->Reg[15] = addr & 0xfffffffe;
		      /* NOTE: The other CPSR flag setting blocks do not
		         seem to update the state->Cpsr state, but just do
		         the explicit flag. The copy from the seperate
		         flags to the register must happen later. */
		      FLUSHPIPE;
		    }
		  else
		    {
		      CLEART;
		      state->Reg[15] = addr & 0xfffffffc;
		      FLUSHPIPE;
		    }
d3105 4
a3108 1
  /* The ARM documentation implies (but doe snot state) that the bottom bit of the PC is never set */
d3110 1
a3110 1
  state->Reg[15] = src & PCBITS & ~0x1;
d3112 1
a3112 1
  state->Reg[15] = (src & R15PCBITS & ~0x1) | ECC | ER15INT | EMODE;
d3125 1
d3143 23
d3253 1
a3253 1
  WRITEDEST (dest);
d3475 1
a3475 4
#ifdef MODE32
      state->Reg[15] = PC;
#endif
      FLUSHPIPE;
@


1.7
log
@* armemu.c (ARMul_Emulate): Compute writeback value before
loading, since the offset register may be the destination
register.
@
text
@d1116 1
a1116 1
	      if (DESTReg == 15 && BITS (17, 18) == 0)
d1244 1
a1244 1
	      if (DESTReg == 15 && BITS (17, 18) == 0)
d1593 1
a1593 1
	      if (DESTReg == 15 && BITS (17, 18) == 0)
d1658 1
a1658 1
	      if (DESTReg == 15 && BITS (17, 18) == 0)	/* MSR */
@


1.6
log
@* armemu.c (Multiply64): Fix computation of flag N.
@
text
@d2001 1
d2003 1
a2003 1
		LSBase = lhs - LSRegRHS;
d2034 1
d2037 1
a2037 1
		LSBase = lhs - LSRegRHS;
d2067 1
d2069 1
a2069 1
		LSBase = lhs - LSRegRHS;
d2100 1
d2103 1
a2103 1
		LSBase = lhs - LSRegRHS;
d2133 1
d2135 1
a2135 1
		LSBase = lhs + LSRegRHS;
d2166 1
d2169 1
a2169 1
		LSBase = lhs + LSRegRHS;
d2199 1
d2201 1
a2201 1
		LSBase = lhs + LSRegRHS;
d2232 1
d2235 1
a2235 1
		LSBase = lhs + LSRegRHS;
@


1.5
log
@* armemu.c (MultiplyAdd64): Fix computation of flag N.
@
text
@d3822 3
a3824 4
      if ((RdHi == 0) && (RdLo == 0))
	ARMul_NegZero (state, RdHi);	/* zero value */
      else
	ARMul_NegZero (state, scc);	/* non-zero value */
@


1.4
log
@Add support for v4 SystemMode.
@
text
@d3874 3
a3876 4
      if ((RdHi == 0) && (RdLo == 0))
	ARMul_NegZero (state, RdHi);	/* zero value */
      else
	ARMul_NegZero (state, scc);	/* non-zero value */
@


1.3
log
@* arm abort fix

2000-03-11  Philip Blundell  <philb@@gnu.org>

	* armemu.c (LoadSMult, LoadMult): Correct handling of aborts.
	Patch from Allan Skillman <Allan.Skillman@@arm.com>.
@
text
@d2867 3
d2878 2
a2879 1
  return (pc);
@


1.2
log
@Fix compile time warning messages.
@
text
@d3460 1
a3460 1
  if (BIT (15))
d3523 1
a3523 1
	if (!state->abortSig || state->Aborted)
d3529 1
a3529 1
  if (BIT (15))
@


1.1
log
@Initial revision
@
text
@d21 1
d23 48
a70 23
static ARMword GetDPRegRHS(ARMul_State *state, ARMword instr) ;
static ARMword GetDPSRegRHS(ARMul_State *state, ARMword instr) ;
static void WriteR15(ARMul_State *state, ARMword src) ;
static void WriteSR15(ARMul_State *state, ARMword src) ;
static ARMword GetLSRegRHS(ARMul_State *state, ARMword instr) ;
static ARMword GetLS7RHS(ARMul_State *state, ARMword instr) ;
static unsigned LoadWord(ARMul_State *state, ARMword instr, ARMword address) ;
static unsigned LoadHalfWord(ARMul_State *state, ARMword instr, ARMword address,int signextend) ;
static unsigned LoadByte(ARMul_State *state, ARMword instr, ARMword address,int signextend) ;
static unsigned StoreWord(ARMul_State *state, ARMword instr, ARMword address) ;
static unsigned StoreHalfWord(ARMul_State *state, ARMword instr, ARMword address) ;
static unsigned StoreByte(ARMul_State *state, ARMword instr, ARMword address) ;
static void LoadMult(ARMul_State *state, ARMword address, ARMword instr, ARMword WBBase) ;
static void StoreMult(ARMul_State *state, ARMword address, ARMword instr, ARMword WBBase) ;
static void LoadSMult(ARMul_State *state, ARMword address, ARMword instr, ARMword WBBase) ;
static void StoreSMult(ARMul_State *state, ARMword address, ARMword instr, ARMword WBBase) ;
static unsigned Multiply64(ARMul_State *state, ARMword instr,int signextend,int scc) ;
static unsigned MultiplyAdd64(ARMul_State *state, ARMword instr,int signextend,int scc) ;

#define LUNSIGNED (0)   /* unsigned operation */
#define LSIGNED   (1)   /* signed operation */
#define LDEFAULT  (0)   /* default : do nothing */
#define LSCC      (1)   /* set condition codes on result */
d100 1
a100 1
  (void)StoreHalfWord(state, instr, LHS + GetLS7RHS(state, instr)) ;  
d273 2
a274 1
ARMword ARMul_Emulate32(register ARMul_State *state)
d277 2
a278 1
ARMword ARMul_Emulate26(register ARMul_State *state)
d281 6
a286 6
 register ARMword instr, /* the current instruction */
                 dest, /* almost the DestBus */
                 temp, /* ubiquitous third hand */
                 pc ; /* the address of the current instruction */
 ARMword lhs, rhs ; /* almost the ABus and BBus */
 ARMword decoded, loaded ; /* instruction pipeline */
d292 6
a297 46
 if (state->NextInstr < PRIMEPIPE) {
    decoded = state->decoded ;
    loaded = state->loaded ;
    pc = state->pc ;
    }

 do { /* just keep going */
#ifdef MODET
    if (TFLAG) {
     isize = 2;
    } else
#endif
     isize = 4;
    switch (state->NextInstr) {
       case SEQ :
          state->Reg[15] += isize ; /* Advance the pipeline, and an S cycle */
          pc += isize ;
          instr = decoded ;
          decoded = loaded ;
          loaded = ARMul_LoadInstrS(state,pc+(isize * 2),isize) ;
          break ;

       case NONSEQ :
          state->Reg[15] += isize ; /* Advance the pipeline, and an N cycle */
          pc += isize ;
          instr = decoded ;
          decoded = loaded ;
          loaded = ARMul_LoadInstrN(state,pc+(isize * 2),isize) ;
          NORMALCYCLE ;
          break ;

       case PCINCEDSEQ :
          pc += isize ; /* Program counter advanced, and an S cycle */
          instr = decoded ;
          decoded = loaded ;
          loaded = ARMul_LoadInstrS(state,pc+(isize * 2),isize) ;
          NORMALCYCLE ;
          break ;

       case PCINCEDNONSEQ :
          pc += isize ; /* Program counter advanced, and an N cycle */
          instr = decoded ;
          decoded = loaded ;
          loaded = ARMul_LoadInstrN(state,pc+(isize * 2),isize) ;
          NORMALCYCLE ;
          break ;
d299 47
a345 2
       case RESUME : /* The program counter has been changed */
          pc = state->Reg[15] ;
d347 1
a347 1
          pc = pc & R15PCBITS ;
d349 7
a355 7
          state->Reg[15] = pc + (isize * 2) ;
          state->Aborted = 0 ;
          instr = ARMul_ReLoadInstr(state,pc,isize) ;
          decoded = ARMul_ReLoadInstr(state,pc + isize,isize) ;
          loaded = ARMul_ReLoadInstr(state,pc + isize * 2,isize) ;
          NORMALCYCLE ;
          break ;
d357 2
a358 2
       default : /* The program counter has been changed */
          pc = state->Reg[15] ;
d360 1
a360 1
          pc = pc & R15PCBITS ;
d362 11
a372 11
          state->Reg[15] = pc + (isize * 2) ;
          state->Aborted = 0 ;
          instr = ARMul_LoadInstrN(state,pc,isize) ;
          decoded = ARMul_LoadInstrS(state,pc + (isize),isize) ;
          loaded = ARMul_LoadInstrS(state,pc + (isize * 2),isize) ;
          NORMALCYCLE ;
          break ;
       }
    if (state->EventSet)
       ARMul_EnvokeEvent(state) ;
    
d374 73
a446 62
    /* Enable this for a helpful bit of debugging when tracing is needed.  */
    fprintf (stderr, "pc: %x, instr: %x\n", pc & ~1, instr);
    if (instr == 0) abort ();
#endif

    if (state->Exception) { /* Any exceptions */
       if (state->NresetSig == LOW) {
           ARMul_Abort(state,ARMul_ResetV) ;
           break ;
           }
       else if (!state->NfiqSig && !FFLAG) {
           ARMul_Abort(state,ARMul_FIQV) ;
           break ;
           }
       else if (!state->NirqSig && !IFLAG) {
          ARMul_Abort(state,ARMul_IRQV) ;
          break ;
          }
       }

    if (state->CallDebug > 0) {
       instr = ARMul_Debug(state,pc,instr) ;
       if (state->Emulate < ONCE) {
          state->NextInstr = RESUME ;
          break ;
          }
       if (state->Debug) {
          fprintf(stderr,"At %08lx Instr %08lx Mode %02lx\n",pc,instr,state->Mode) ;
          (void)fgetc(stdin) ;
          }
       }
    else
       if (state->Emulate < ONCE) {
          state->NextInstr = RESUME ;
          break ;
          }

    state->NumInstrs++ ;

#ifdef MODET
 /* Provide Thumb instruction decoding. If the processor is in Thumb
    mode, then we can simply decode the Thumb instruction, and map it
    to the corresponding ARM instruction (by directly loading the
    instr variable, and letting the normal ARM simulator
    execute). There are some caveats to ensure that the correct
    pipelined PC value is used when executing Thumb code, and also for
    dealing with the BL instruction. */
    if (TFLAG) { /* check if in Thumb mode */
      ARMword new;
      switch (ARMul_ThumbDecode(state,pc,instr,&new)) {
        case t_undefined:
          ARMul_UndefInstr(state,instr); /* This is a Thumb instruction */
          break;

        case t_branch: /* already processed */
          goto donext;

        case t_decoded: /* ARM instruction available */
          instr = new; /* so continue instruction decoding */
          break;
      }
    }
d452 2
a453 2
    if ((temp = TOPBITS(28)) == AL)
       goto mainswitch ; /* vile deed in the need for speed */
d455 51
a505 34
    switch ((int)TOPBITS(28)) { /* check the condition code */
       case AL : temp=TRUE ;
                 break ;
       case NV : temp=FALSE ;
                 break ;
       case EQ : temp=ZFLAG ;
                 break ;
       case NE : temp=!ZFLAG ;
                 break ;
       case VS : temp=VFLAG ;
                 break ;
       case VC : temp=!VFLAG ;
                 break ;
       case MI : temp=NFLAG ;
                 break ;
       case PL : temp=!NFLAG ;
                 break ;
       case CS : temp=CFLAG ;
                 break ;
       case CC : temp=!CFLAG ;
                 break ;
       case HI : temp=(CFLAG && !ZFLAG) ;
                 break ;
       case LS : temp=(!CFLAG || ZFLAG) ;
                 break ;
       case GE : temp=((!NFLAG && !VFLAG) || (NFLAG && VFLAG)) ;
                 break ;
       case LT : temp=((NFLAG && !VFLAG) || (!NFLAG && VFLAG)) ;
                 break ;
       case GT : temp=((!NFLAG && !VFLAG && !ZFLAG) || (NFLAG && VFLAG && !ZFLAG)) ;
                 break ;
       case LE : temp=((NFLAG && !VFLAG) || (!NFLAG && VFLAG)) || ZFLAG ;
                 break ;
       } /* cc check */
d511 3
a513 2
    if (temp) { /* if the condition codes don't match, stop here */
mainswitch:
d515 3
a517 1
       switch ((int)BITS(20,27)) {
d523 1
a523 1
          case 0x00 : /* AND reg and MUL */
d525 490
a1014 416
             if (BITS(4,11) == 0xB) {
               /* STRH register offset, no write-back, down, post indexed */
               SHDOWNWB() ;
               break ;
               }
             /* TODO: CHECK: should 0xD and 0xF generate undefined intruction aborts? */
#endif
             if (BITS(4,7) == 9) { /* MUL */
                rhs = state->Reg[MULRHSReg] ;
                if (MULLHSReg == MULDESTReg) {
                   UNDEF_MULDestEQOp1 ;
                   state->Reg[MULDESTReg] = 0 ;
                   }
                else if (MULDESTReg != 15)
                   state->Reg[MULDESTReg] = state->Reg[MULLHSReg] * rhs ;
                else {
                   UNDEF_MULPCDest ;
                   }
                for (dest = 0, temp = 0 ; dest < 32 ; dest++)
                   if (rhs & (1L << dest))
                      temp = dest ; /* mult takes this many/2 I cycles */
                ARMul_Icycles(state,ARMul_MultTable[temp],0L) ;
                }
             else { /* AND reg */
                rhs = DPRegRHS ;
                dest = LHS & rhs ;
                WRITEDEST(dest) ;
                }
             break ;

          case 0x01 : /* ANDS reg and MULS */
#ifdef MODET
             if ((BITS(4,11) & 0xF9) == 0x9) {
               /* LDR register offset, no write-back, down, post indexed */
               LHPOSTDOWN() ;
               /* fall through to rest of decoding */
               }
#endif
             if (BITS(4,7) == 9) { /* MULS */
                rhs = state->Reg[MULRHSReg] ;
                if (MULLHSReg == MULDESTReg) {
                   UNDEF_MULDestEQOp1 ;
                   state->Reg[MULDESTReg] = 0 ;
                   CLEARN ;
                   SETZ ;
                   }
                else if (MULDESTReg != 15) {
                   dest = state->Reg[MULLHSReg] * rhs ;
                   ARMul_NegZero(state,dest) ;
                   state->Reg[MULDESTReg] = dest ;
                   }
                else {
                   UNDEF_MULPCDest ;
                   }
                for (dest = 0, temp = 0 ; dest < 32 ; dest++)
                   if (rhs & (1L << dest))
                      temp = dest ; /* mult takes this many/2 I cycles */
                ARMul_Icycles(state,ARMul_MultTable[temp],0L) ;
                }
             else { /* ANDS reg */
                rhs = DPSRegRHS ;
                dest = LHS & rhs ;
                WRITESDEST(dest) ;
                }
             break ;

          case 0x02 : /* EOR reg and MLA */
#ifdef MODET
             if (BITS(4,11) == 0xB) {
               /* STRH register offset, write-back, down, post indexed */
               SHDOWNWB() ;
               break ;
               }
#endif
             if (BITS(4,7) == 9) { /* MLA */
                rhs = state->Reg[MULRHSReg] ;
                if (MULLHSReg == MULDESTReg) {
                   UNDEF_MULDestEQOp1 ;
                   state->Reg[MULDESTReg] = state->Reg[MULACCReg] ;
                   }
                else if (MULDESTReg != 15)
                   state->Reg[MULDESTReg] = state->Reg[MULLHSReg] * rhs + state->Reg[MULACCReg] ;
                else {
                   UNDEF_MULPCDest ;
                   }
                for (dest = 0, temp = 0 ; dest < 32 ; dest++)
                   if (rhs & (1L << dest))
                      temp = dest ; /* mult takes this many/2 I cycles */
                ARMul_Icycles(state,ARMul_MultTable[temp],0L) ;
                }
             else {
                rhs = DPRegRHS ;
                dest = LHS ^ rhs ;
                WRITEDEST(dest) ;
                }
             break ;

          case 0x03 : /* EORS reg and MLAS */
#ifdef MODET
             if ((BITS(4,11) & 0xF9) == 0x9) {
               /* LDR register offset, write-back, down, post-indexed */
               LHPOSTDOWN() ;
               /* fall through to rest of the decoding */
               }
#endif
             if (BITS(4,7) == 9) { /* MLAS */
                rhs = state->Reg[MULRHSReg] ;
                if (MULLHSReg == MULDESTReg) {
                   UNDEF_MULDestEQOp1 ;
                   dest = state->Reg[MULACCReg] ;
                   ARMul_NegZero(state,dest) ;
                   state->Reg[MULDESTReg] = dest ;
                   }
                else if (MULDESTReg != 15) {
                   dest = state->Reg[MULLHSReg] * rhs + state->Reg[MULACCReg] ;
                   ARMul_NegZero(state,dest) ;
                   state->Reg[MULDESTReg] = dest ;
                   }
                else {
                   UNDEF_MULPCDest ;
                   }
                for (dest = 0, temp = 0 ; dest < 32 ; dest++)
                   if (rhs & (1L << dest))
                      temp = dest ; /* mult takes this many/2 I cycles */
                ARMul_Icycles(state,ARMul_MultTable[temp],0L) ;
                }
             else { /* EORS Reg */
                rhs = DPSRegRHS ;
                dest = LHS ^ rhs ;
                WRITESDEST(dest) ;
                }
             break ;

          case 0x04 : /* SUB reg */
#ifdef MODET
             if (BITS(4,7) == 0xB) {
               /* STRH immediate offset, no write-back, down, post indexed */
               SHDOWNWB() ;
               break ;
               }
#endif
             rhs = DPRegRHS;
             dest = LHS - rhs ;
             WRITEDEST(dest) ;
             break ;

          case 0x05 : /* SUBS reg */
#ifdef MODET
             if ((BITS(4,7) & 0x9) == 0x9) {
               /* LDR immediate offset, no write-back, down, post indexed */
               LHPOSTDOWN() ;
               /* fall through to the rest of the instruction decoding */
               }
#endif
             lhs = LHS ;
             rhs = DPRegRHS ;
             dest = lhs - rhs ;
             if ((lhs >= rhs) || ((rhs | lhs) >> 31)) {
                ARMul_SubCarry(state,lhs,rhs,dest) ;
                ARMul_SubOverflow(state,lhs,rhs,dest) ;
                }
             else {
                CLEARC ;
                CLEARV ;
                }
             WRITESDEST(dest) ;
             break ;

          case 0x06 : /* RSB reg */
#ifdef MODET
             if (BITS(4,7) == 0xB) {
               /* STRH immediate offset, write-back, down, post indexed */
               SHDOWNWB() ;
               break ;
               }
#endif
             rhs = DPRegRHS ;
             dest = rhs - LHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x07 : /* RSBS reg */
#ifdef MODET
             if ((BITS(4,7) & 0x9) == 0x9) {
               /* LDR immediate offset, write-back, down, post indexed */
               LHPOSTDOWN() ;
               /* fall through to remainder of instruction decoding */
               }
#endif
             lhs = LHS ;
             rhs = DPRegRHS ;
             dest = rhs - lhs ;
             if ((rhs >= lhs) || ((rhs | lhs) >> 31)) {
                ARMul_SubCarry(state,rhs,lhs,dest) ;
                ARMul_SubOverflow(state,rhs,lhs,dest) ;
                }
             else {
                CLEARC ;
                CLEARV ;
                }
             WRITESDEST(dest) ;
             break ;

          case 0x08 : /* ADD reg */
#ifdef MODET
             if (BITS(4,11) == 0xB) {
               /* STRH register offset, no write-back, up, post indexed */
               SHUPWB() ;
               break ;
               }
#endif
#ifdef MODET
             if (BITS(4,7) == 0x9) { /* MULL */
               /* 32x32 = 64 */
               ARMul_Icycles(state,Multiply64(state,instr,LUNSIGNED,LDEFAULT),0L) ;
               break ;
               }
#endif
             rhs = DPRegRHS ;
             dest = LHS + rhs ;
             WRITEDEST(dest) ;
             break ;

          case 0x09 : /* ADDS reg */
#ifdef MODET
             if ((BITS(4,11) & 0xF9) == 0x9) {
               /* LDR register offset, no write-back, up, post indexed */
               LHPOSTUP() ;
               /* fall through to remaining instruction decoding */
               }
#endif
#ifdef MODET
             if (BITS(4,7) == 0x9) { /* MULL */
               /* 32x32=64 */
               ARMul_Icycles(state,Multiply64(state,instr,LUNSIGNED,LSCC),0L) ;
               break ;
               }
#endif
             lhs = LHS ;
             rhs = DPRegRHS ;
             dest = lhs + rhs ;
             ASSIGNZ(dest==0) ;
             if ((lhs | rhs) >> 30) { /* possible C,V,N to set */
                ASSIGNN(NEG(dest)) ;
                ARMul_AddCarry(state,lhs,rhs,dest) ;
                ARMul_AddOverflow(state,lhs,rhs,dest) ;
                }
             else {
                CLEARN ;
                CLEARC ;
                CLEARV ;
                }
             WRITESDEST(dest) ;
             break ;

          case 0x0a : /* ADC reg */
#ifdef MODET
             if (BITS(4,11) == 0xB) {
               /* STRH register offset, write-back, up, post-indexed */
               SHUPWB() ;
               break ;
               }
#endif
#ifdef MODET
             if (BITS(4,7) == 0x9) { /* MULL */
               /* 32x32=64 */
               ARMul_Icycles(state,MultiplyAdd64(state,instr,LUNSIGNED,LDEFAULT),0L) ;
               break ;
               }
#endif
             rhs = DPRegRHS ;
             dest = LHS + rhs + CFLAG ;
             WRITEDEST(dest) ;
             break ;

          case 0x0b : /* ADCS reg */
#ifdef MODET
             if ((BITS(4,11) & 0xF9) == 0x9) {
               /* LDR register offset, write-back, up, post indexed */
               LHPOSTUP() ;
               /* fall through to remaining instruction decoding */
               }
#endif
#ifdef MODET
             if (BITS(4,7) == 0x9) { /* MULL */
               /* 32x32=64 */
               ARMul_Icycles(state,MultiplyAdd64(state,instr,LUNSIGNED,LSCC),0L) ;
               break ;
               }
#endif
             lhs = LHS ;
             rhs = DPRegRHS ;
             dest = lhs + rhs + CFLAG ;
             ASSIGNZ(dest==0) ;
             if ((lhs | rhs) >> 30) { /* possible C,V,N to set */
                ASSIGNN(NEG(dest)) ;
                ARMul_AddCarry(state,lhs,rhs,dest) ;
                ARMul_AddOverflow(state,lhs,rhs,dest) ;
                }
             else {
                CLEARN ;
                CLEARC ;
                CLEARV ;
                }
             WRITESDEST(dest) ;
             break ;

          case 0x0c : /* SBC reg */
#ifdef MODET
             if (BITS(4,7) == 0xB) {
               /* STRH immediate offset, no write-back, up post indexed */
               SHUPWB() ;
               break ;
               }
#endif
#ifdef MODET
             if (BITS(4,7) == 0x9) { /* MULL */
               /* 32x32=64 */
               ARMul_Icycles(state,Multiply64(state,instr,LSIGNED,LDEFAULT),0L) ;
               break ;
               }
#endif
             rhs = DPRegRHS ;
             dest = LHS - rhs - !CFLAG ;
             WRITEDEST(dest) ;
             break ;

          case 0x0d : /* SBCS reg */
#ifdef MODET
             if ((BITS(4,7) & 0x9) == 0x9) {
               /* LDR immediate offset, no write-back, up, post indexed */
               LHPOSTUP() ;
               }
#endif
#ifdef MODET
             if (BITS(4,7) == 0x9) { /* MULL */
               /* 32x32=64 */
               ARMul_Icycles(state,Multiply64(state,instr,LSIGNED,LSCC),0L) ;
               break ;
               }
#endif
             lhs = LHS ;
             rhs = DPRegRHS ;
             dest = lhs - rhs - !CFLAG ;
             if ((lhs >= rhs) || ((rhs | lhs) >> 31)) {
                ARMul_SubCarry(state,lhs,rhs,dest) ;
                ARMul_SubOverflow(state,lhs,rhs,dest) ;
                }
             else {
                CLEARC ;
                CLEARV ;
                }
             WRITESDEST(dest) ;
             break ;

          case 0x0e : /* RSC reg */
#ifdef MODET
             if (BITS(4,7) == 0xB) {
               /* STRH immediate offset, write-back, up, post indexed */
               SHUPWB() ;
               break ;
               }
#endif
#ifdef MODET
             if (BITS(4,7) == 0x9) { /* MULL */
               /* 32x32=64 */
               ARMul_Icycles(state,MultiplyAdd64(state,instr,LSIGNED,LDEFAULT),0L) ;
               break ;
               }
#endif
             rhs = DPRegRHS ;
             dest = rhs - LHS - !CFLAG ;
             WRITEDEST(dest) ;
             break ;

          case 0x0f : /* RSCS reg */
#ifdef MODET
             if ((BITS(4,7) & 0x9) == 0x9) {
               /* LDR immediate offset, write-back, up, post indexed */
               LHPOSTUP() ;
               /* fall through to remaining instruction decoding */
               }
#endif
#ifdef MODET
             if (BITS(4,7) == 0x9) { /* MULL */
               /* 32x32=64 */
               ARMul_Icycles(state,MultiplyAdd64(state,instr,LSIGNED,LSCC),0L) ;
               break ;
               }
#endif
             lhs = LHS ;
             rhs = DPRegRHS ;
             dest = rhs - lhs - !CFLAG ;
             if ((rhs >= lhs) || ((rhs | lhs) >> 31)) {
                ARMul_SubCarry(state,rhs,lhs,dest) ;
                ARMul_SubOverflow(state,rhs,lhs,dest) ;
                }
             else {
                CLEARC ;
                CLEARV ;
                }
             WRITESDEST(dest) ;
             break ;

          case 0x10 : /* TST reg and MRS CPSR and SWP word */
#ifdef MODET
             if (BITS(4,11) == 0xB) {
               /* STRH register offset, no write-back, down, pre indexed */
               SHPREDOWN() ;
               break ;
               }
#endif
             if (BITS(4,11) == 9) { /* SWP */
                UNDEF_SWPPC ;
                temp = LHS ;
                BUSUSEDINCPCS ;
d1016 37
a1052 32
                if (VECTORACCESS(temp) || ADDREXCEPT(temp)) {
                   INTERNALABORT(temp) ;
                   (void)ARMul_LoadWordN(state,temp) ;
                   (void)ARMul_LoadWordN(state,temp) ;
                   }
                else
#endif
                dest = ARMul_SwapWord(state,temp,state->Reg[RHSReg]) ;
                if (temp & 3)
                    DEST = ARMul_Align(state,temp,dest) ;
                else
                    DEST = dest ;
                if (state->abortSig || state->Aborted) {
                   TAKEABORT ;
                   }
                }
             else if ((BITS(0,11)==0) && (LHSReg==15)) { /* MRS CPSR */
                UNDEF_MRSPC ;
                DEST = ECC | EINT | EMODE ;
                }
             else {
                UNDEF_Test ;
                }
             break ;

          case 0x11 : /* TSTP reg */
#ifdef MODET
             if ((BITS(4,11) & 0xF9) == 0x9) {
               /* LDR register offset, no write-back, down, pre indexed */
               LHPREDOWN() ;
               /* continue with remaining instruction decode */
               }
d1054 2
a1055 1
             if (DESTReg == 15) { /* TSTP reg */
d1057 2
a1058 2
                state->Cpsr = GETSPSR(state->Bank) ;
                ARMul_CPSRAltered(state) ;
d1060 76
a1135 66
                rhs = DPRegRHS ;
                temp = LHS & rhs ;
                SETR15PSR(temp) ;
#endif
                }
             else { /* TST reg */
                rhs = DPSRegRHS ;
                dest = LHS & rhs ;
                ARMul_NegZero(state,dest) ;
                }
             break ;

          case 0x12 : /* TEQ reg and MSR reg to CPSR (ARM6) */
#ifdef MODET
             if (BITS(4,11) == 0xB) {
               /* STRH register offset, write-back, down, pre indexed */
               SHPREDOWNWB() ;
               break ;
               }
#endif
#ifdef MODET
             if (BITS(4,27)==0x12FFF1) { /* BX */
               /* Branch to the address in RHSReg. If bit0 of
                  destination address is 1 then switch to Thumb mode: */
               ARMword addr = state->Reg[RHSReg];
	       
	       /* If we read the PC then the bottom bit is clear */
	       if (RHSReg == 15) addr &= ~1;
	       
	       /* Enable this for a helpful bit of debugging when
		  GDB is not yet fully working... 
	       fprintf (stderr, "BX at %x to %x (go %s)\n",
			state->Reg[15], addr, (addr & 1) ? "thumb": "arm" ); */

               if (addr & (1 << 0)) { /* Thumb bit */
                 SETT;
                 state->Reg[15] = addr & 0xfffffffe;
                 /* NOTE: The other CPSR flag setting blocks do not
                    seem to update the state->Cpsr state, but just do
                    the explicit flag. The copy from the seperate
                    flags to the register must happen later. */
                 FLUSHPIPE;
                 } else {
                 CLEART;
                 state->Reg[15] = addr & 0xfffffffc;
                 FLUSHPIPE;
                 }
               }
#endif
             if (DESTReg==15 && BITS(17,18)==0) { /* MSR reg to CPSR */
                UNDEF_MSRPC ;
                temp = DPRegRHS ;
                   ARMul_FixCPSR(state,instr,temp) ;
                }
             else {
                UNDEF_Test ;
                }
             break ;

          case 0x13 : /* TEQP reg */
#ifdef MODET
             if ((BITS(4,11) & 0xF9) == 0x9) {
               /* LDR register offset, write-back, down, pre indexed */
               LHPREDOWNWB() ;
               /* continue with remaining instruction decode */
               }
d1137 2
a1138 1
             if (DESTReg == 15) { /* TEQP reg */
d1140 2
a1141 2
                state->Cpsr = GETSPSR(state->Bank) ;
                ARMul_CPSRAltered(state) ;
d1143 27
a1169 24
                rhs = DPRegRHS ;
                temp = LHS ^ rhs ;
                SETR15PSR(temp) ;
#endif
                }
             else { /* TEQ Reg */
                rhs = DPSRegRHS ;
                dest = LHS ^ rhs ;
                ARMul_NegZero(state,dest) ;
                }
             break ;

          case 0x14 : /* CMP reg and MRS SPSR and SWP byte */
#ifdef MODET
             if (BITS(4,7) == 0xB) {
               /* STRH immediate offset, no write-back, down, pre indexed */
               SHPREDOWN() ;
               break ;
               }
#endif
             if (BITS(4,11) == 9) { /* SWP */
                UNDEF_SWPPC ;
                temp = LHS ;
                BUSUSEDINCPCS ;
d1171 33
a1203 28
                if (VECTORACCESS(temp) || ADDREXCEPT(temp)) {
                   INTERNALABORT(temp) ;
                   (void)ARMul_LoadByte(state,temp) ;
                   (void)ARMul_LoadByte(state,temp) ;
                   }
                else
#endif
                DEST = ARMul_SwapByte(state,temp,state->Reg[RHSReg]) ;
                if (state->abortSig || state->Aborted) {
                   TAKEABORT ;
                   }
                }
             else if ((BITS(0,11)==0) && (LHSReg==15)) { /* MRS SPSR */
                UNDEF_MRSPC ;
                DEST = GETSPSR(state->Bank) ;
                }
             else {
                UNDEF_Test ;
                }
             break ;

          case 0x15 : /* CMPP reg */
#ifdef MODET
             if ((BITS(4,7) & 0x9) == 0x9) {
               /* LDR immediate offset, no write-back, down, pre indexed */
               LHPREDOWN() ;
               /* continue with remaining instruction decode */
               }
d1205 2
a1206 1
             if (DESTReg == 15) { /* CMPP reg */
d1208 2
a1209 2
                state->Cpsr = GETSPSR(state->Bank) ;
                ARMul_CPSRAltered(state) ;
d1211 52
a1262 45
                rhs = DPRegRHS ;
                temp = LHS - rhs ;
                SETR15PSR(temp) ;
#endif
                }
             else { /* CMP reg */
                lhs = LHS ;
                rhs = DPRegRHS ;
                dest = lhs - rhs ;
                ARMul_NegZero(state,dest) ;
                if ((lhs >= rhs) || ((rhs | lhs) >> 31)) {
                   ARMul_SubCarry(state,lhs,rhs,dest) ;
                   ARMul_SubOverflow(state,lhs,rhs,dest) ;
                   }
                else {
                   CLEARC ;
                   CLEARV ;
                   }
                }
             break ;

          case 0x16 : /* CMN reg and MSR reg to SPSR */
#ifdef MODET
             if (BITS(4,7) == 0xB) {
               /* STRH immediate offset, write-back, down, pre indexed */
               SHPREDOWNWB() ;
               break ;
               }
#endif
             if (DESTReg==15 && BITS(17,18)==0) { /* MSR */
                UNDEF_MSRPC ;
                ARMul_FixSPSR(state,instr,DPRegRHS);
                }
             else {
                UNDEF_Test ;
                }
             break ;

          case 0x17 : /* CMNP reg */
#ifdef MODET
             if ((BITS(4,7) & 0x9) == 0x9) {
               /* LDR immediate offset, write-back, down, pre indexed */
               LHPREDOWNWB() ;
               /* continue with remaining instruction decoding */
               }
d1264 2
a1265 1
             if (DESTReg == 15) {
d1267 2
a1268 2
                state->Cpsr = GETSPSR(state->Bank) ;
                ARMul_CPSRAltered(state) ;
d1270 134
a1403 123
                rhs = DPRegRHS ;
                temp = LHS + rhs ;
                SETR15PSR(temp) ;
#endif
                break ;
                }
             else { /* CMN reg */
                lhs = LHS ;
                rhs = DPRegRHS ;
                dest = lhs + rhs ;
                ASSIGNZ(dest==0) ;
                if ((lhs | rhs) >> 30) { /* possible C,V,N to set */
                   ASSIGNN(NEG(dest)) ;
                   ARMul_AddCarry(state,lhs,rhs,dest) ;
                   ARMul_AddOverflow(state,lhs,rhs,dest) ;
                   }
                else {
                   CLEARN ;
                   CLEARC ;
                   CLEARV ;
                   }
                }
             break ;

          case 0x18 : /* ORR reg */
#ifdef MODET
             if (BITS(4,11) == 0xB) {
               /* STRH register offset, no write-back, up, pre indexed */
               SHPREUP() ;
               break ;
               }
#endif
             rhs = DPRegRHS ;
             dest = LHS | rhs ;
             WRITEDEST(dest) ;
             break ;

          case 0x19 : /* ORRS reg */
#ifdef MODET
             if ((BITS(4,11) & 0xF9) == 0x9) {
               /* LDR register offset, no write-back, up, pre indexed */
               LHPREUP() ;
               /* continue with remaining instruction decoding */
               }
#endif
             rhs = DPSRegRHS ;
             dest = LHS | rhs ;
             WRITESDEST(dest) ;
             break ;

          case 0x1a : /* MOV reg */
#ifdef MODET
             if (BITS(4,11) == 0xB) {
               /* STRH register offset, write-back, up, pre indexed */
               SHPREUPWB() ;
               break ;
               }
#endif
             dest = DPRegRHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x1b : /* MOVS reg */
#ifdef MODET
             if ((BITS(4,11) & 0xF9) == 0x9) {
               /* LDR register offset, write-back, up, pre indexed */
               LHPREUPWB() ;
               /* continue with remaining instruction decoding */
               }
#endif
             dest = DPSRegRHS ;
             WRITESDEST(dest) ;
             break ;

          case 0x1c : /* BIC reg */
#ifdef MODET
             if (BITS(4,7) == 0xB) {
               /* STRH immediate offset, no write-back, up, pre indexed */
               SHPREUP() ;
               break ;
               }
#endif
             rhs = DPRegRHS ;
             dest = LHS & ~rhs ;
             WRITEDEST(dest) ;
             break ;

          case 0x1d : /* BICS reg */
#ifdef MODET
             if ((BITS(4,7) & 0x9) == 0x9) {
               /* LDR immediate offset, no write-back, up, pre indexed */
               LHPREUP() ;
               /* continue with instruction decoding */
               }
#endif
             rhs = DPSRegRHS ;
             dest = LHS & ~rhs ;
             WRITESDEST(dest) ;
             break ;

          case 0x1e : /* MVN reg */
#ifdef MODET
             if (BITS(4,7) == 0xB) {
               /* STRH immediate offset, write-back, up, pre indexed */
               SHPREUPWB() ;
               break ;
               }
#endif
             dest = ~DPRegRHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x1f : /* MVNS reg */
#ifdef MODET
             if ((BITS(4,7) & 0x9) == 0x9) {
               /* LDR immediate offset, write-back, up, pre indexed */
               LHPREUPWB() ;
               /* continue instruction decoding */
               }
#endif
             dest = ~DPSRegRHS ;
             WRITESDEST(dest) ;
             break ;
d1409 167
a1575 154
          case 0x20 : /* AND immed */
             dest = LHS & DPImmRHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x21 : /* ANDS immed */
             DPSImmRHS ;
             dest = LHS & rhs ;
             WRITESDEST(dest) ;
             break ;

          case 0x22 : /* EOR immed */
             dest = LHS ^ DPImmRHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x23 : /* EORS immed */
             DPSImmRHS ;
             dest = LHS ^ rhs ;
             WRITESDEST(dest) ;
             break ;

          case 0x24 : /* SUB immed */
             dest = LHS - DPImmRHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x25 : /* SUBS immed */
             lhs = LHS ;
             rhs = DPImmRHS ;
             dest = lhs - rhs ;
             if ((lhs >= rhs) || ((rhs | lhs) >> 31)) {
                ARMul_SubCarry(state,lhs,rhs,dest) ;
                ARMul_SubOverflow(state,lhs,rhs,dest) ;
                }
             else {
                CLEARC ;
                CLEARV ;
                }
             WRITESDEST(dest) ;
             break ;

          case 0x26 : /* RSB immed */
             dest = DPImmRHS - LHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x27 : /* RSBS immed */
             lhs = LHS ;
             rhs = DPImmRHS ;
             dest = rhs - lhs ;
             if ((rhs >= lhs) || ((rhs | lhs) >> 31)) {
                ARMul_SubCarry(state,rhs,lhs,dest) ;
                ARMul_SubOverflow(state,rhs,lhs,dest) ;
                }
             else {
                CLEARC ;
                CLEARV ;
                }
             WRITESDEST(dest) ;
             break ;

          case 0x28 : /* ADD immed */
             dest = LHS + DPImmRHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x29 : /* ADDS immed */
             lhs = LHS ;
             rhs = DPImmRHS ;
             dest = lhs + rhs ;
             ASSIGNZ(dest==0) ;
             if ((lhs | rhs) >> 30) { /* possible C,V,N to set */
                ASSIGNN(NEG(dest)) ;
                ARMul_AddCarry(state,lhs,rhs,dest) ;
                ARMul_AddOverflow(state,lhs,rhs,dest) ;
                }
             else {
                CLEARN ;
                CLEARC ;
                CLEARV ;
                }
             WRITESDEST(dest) ;
             break ;

          case 0x2a : /* ADC immed */
             dest = LHS + DPImmRHS + CFLAG ;
             WRITEDEST(dest) ;
             break ;

          case 0x2b : /* ADCS immed */
             lhs = LHS ;
             rhs = DPImmRHS ;
             dest = lhs + rhs + CFLAG ;
             ASSIGNZ(dest==0) ;
             if ((lhs | rhs) >> 30) { /* possible C,V,N to set */
                ASSIGNN(NEG(dest)) ;
                ARMul_AddCarry(state,lhs,rhs,dest) ;
                ARMul_AddOverflow(state,lhs,rhs,dest) ;
                }
             else {
                CLEARN ;
                CLEARC ;
                CLEARV ;
                }
             WRITESDEST(dest) ;
             break ;

          case 0x2c : /* SBC immed */
             dest = LHS - DPImmRHS - !CFLAG ;
             WRITEDEST(dest) ;
             break ;

          case 0x2d : /* SBCS immed */
             lhs = LHS ;
             rhs = DPImmRHS ;
             dest = lhs - rhs - !CFLAG ;
             if ((lhs >= rhs) || ((rhs | lhs) >> 31)) {
                ARMul_SubCarry(state,lhs,rhs,dest) ;
                ARMul_SubOverflow(state,lhs,rhs,dest) ;
                }
             else {
                CLEARC ;
                CLEARV ;
                }
             WRITESDEST(dest) ;
             break ;

          case 0x2e : /* RSC immed */
             dest = DPImmRHS - LHS - !CFLAG ;
             WRITEDEST(dest) ;
             break ;

          case 0x2f : /* RSCS immed */
             lhs = LHS ;
             rhs = DPImmRHS ;
             dest = rhs - lhs - !CFLAG ;
             if ((rhs >= lhs) || ((rhs | lhs) >> 31)) {
                ARMul_SubCarry(state,rhs,lhs,dest) ;
                ARMul_SubOverflow(state,rhs,lhs,dest) ;
                }
             else {
                CLEARC ;
                CLEARV ;
                }
             WRITESDEST(dest) ;
             break ;

          case 0x30 : /* TST immed */
             UNDEF_Test ;
             break ;

          case 0x31 : /* TSTP immed */
             if (DESTReg == 15) { /* TSTP immed */
d1577 2
a1578 2
                state->Cpsr = GETSPSR(state->Bank) ;
                ARMul_CPSRAltered(state) ;
d1580 2
a1581 2
                temp = LHS & DPImmRHS ;
                SETR15PSR(temp) ;
d1583 23
a1605 19
                }
             else {
                DPSImmRHS ; /* TST immed */
                dest = LHS & rhs ;
                ARMul_NegZero(state,dest) ;
                }
             break ;

          case 0x32 : /* TEQ immed and MSR immed to CPSR */
             if (DESTReg==15 && BITS(17,18)==0) { /* MSR immed to CPSR */
                ARMul_FixCPSR(state,instr,DPImmRHS) ;
                }
             else {
                UNDEF_Test ;
                }
             break ;

          case 0x33 : /* TEQP immed */
             if (DESTReg == 15) { /* TEQP immed */
d1607 2
a1608 2
                state->Cpsr = GETSPSR(state->Bank) ;
                ARMul_CPSRAltered(state) ;
d1610 2
a1611 2
                temp = LHS ^ DPImmRHS ;
                SETR15PSR(temp) ;
d1613 16
a1628 14
                }
             else {
                DPSImmRHS ; /* TEQ immed */
                dest = LHS ^ rhs ;
                ARMul_NegZero(state,dest) ;
                }
             break ;

          case 0x34 : /* CMP immed */
             UNDEF_Test ;
             break ;

          case 0x35 : /* CMPP immed */
             if (DESTReg == 15) { /* CMPP immed */
d1630 2
a1631 2
                state->Cpsr = GETSPSR(state->Bank) ;
                ARMul_CPSRAltered(state) ;
d1633 2
a1634 2
                temp = LHS - DPImmRHS ;
                SETR15PSR(temp) ;
d1636 33
a1668 28
                break ;
                }
             else {
                lhs = LHS ; /* CMP immed */
                rhs = DPImmRHS ;
                dest = lhs - rhs ;
                ARMul_NegZero(state,dest) ;
                if ((lhs >= rhs) || ((rhs | lhs) >> 31)) {
                   ARMul_SubCarry(state,lhs,rhs,dest) ;
                   ARMul_SubOverflow(state,lhs,rhs,dest) ;
                   }
                else {
                   CLEARC ;
                   CLEARV ;
                   }
                }
             break ;

          case 0x36 : /* CMN immed and MSR immed to SPSR */
             if (DESTReg==15 && BITS(17,18)==0) /* MSR */
                ARMul_FixSPSR(state, instr, DPImmRHS) ;
             else {
                UNDEF_Test ;
                }
             break ;

          case 0x37 : /* CMNP immed */
             if (DESTReg == 15) { /* CMNP immed */
d1670 2
a1671 2
                state->Cpsr = GETSPSR(state->Bank) ;
                ARMul_CPSRAltered(state) ;
d1673 2
a1674 2
                temp = LHS + DPImmRHS ;
                SETR15PSR(temp) ;
d1676 64
a1739 61
                break ;
                }
             else {
                lhs = LHS ; /* CMN immed */
                rhs = DPImmRHS ;
                dest = lhs + rhs ;
                ASSIGNZ(dest==0) ;
                if ((lhs | rhs) >> 30) { /* possible C,V,N to set */
                   ASSIGNN(NEG(dest)) ;
                   ARMul_AddCarry(state,lhs,rhs,dest) ;
                   ARMul_AddOverflow(state,lhs,rhs,dest) ;
                   }
                else {
                   CLEARN ;
                   CLEARC ;
                   CLEARV ;
                   }
                }
             break ;

          case 0x38 : /* ORR immed */
             dest = LHS | DPImmRHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x39 : /* ORRS immed */
             DPSImmRHS ;
             dest = LHS | rhs ;
             WRITESDEST(dest) ;
             break ;

          case 0x3a : /* MOV immed */
             dest = DPImmRHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x3b : /* MOVS immed */
             DPSImmRHS ;
             WRITESDEST(rhs) ;
             break ;

          case 0x3c : /* BIC immed */
             dest = LHS & ~DPImmRHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x3d : /* BICS immed */
             DPSImmRHS ;
             dest = LHS & ~rhs ;
             WRITESDEST(dest) ;
             break ;

          case 0x3e : /* MVN immed */
             dest = ~DPImmRHS ;
             WRITEDEST(dest) ;
             break ;

          case 0x3f : /* MVNS immed */
             DPSImmRHS ;
             WRITESDEST(~rhs) ;
             break ;
d1745 225
a1969 225
          case 0x40 : /* Store Word, No WriteBack, Post Dec, Immed */
             lhs = LHS ;
             if (StoreWord(state,instr,lhs))
                LSBase = lhs - LSImmRHS ;
             break ;

          case 0x41 : /* Load Word, No WriteBack, Post Dec, Immed */
             lhs = LHS ;
             if (LoadWord(state,instr,lhs))
                LSBase = lhs - LSImmRHS ;
             break ;

          case 0x42 : /* Store Word, WriteBack, Post Dec, Immed */
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             lhs = LHS ;
             temp = lhs - LSImmRHS ;
             state->NtransSig = LOW ;
             if (StoreWord(state,instr,lhs))
                LSBase = temp ;
             state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
             break ;

          case 0x43 : /* Load Word, WriteBack, Post Dec, Immed */
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             lhs = LHS ;
             state->NtransSig = LOW ;
             if (LoadWord(state,instr,lhs))
                LSBase = lhs - LSImmRHS ;
             state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
             break ;

          case 0x44 : /* Store Byte, No WriteBack, Post Dec, Immed */
             lhs = LHS ;
             if (StoreByte(state,instr,lhs))
                LSBase = lhs - LSImmRHS ;
             break ;

          case 0x45 : /* Load Byte, No WriteBack, Post Dec, Immed */
             lhs = LHS ;
             if (LoadByte(state,instr,lhs,LUNSIGNED))
                LSBase = lhs - LSImmRHS ;
             break ;

          case 0x46 : /* Store Byte, WriteBack, Post Dec, Immed */
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             lhs = LHS ;
             state->NtransSig = LOW ;
             if (StoreByte(state,instr,lhs))
                LSBase = lhs - LSImmRHS ;
             state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
             break ;

          case 0x47 : /* Load Byte, WriteBack, Post Dec, Immed */
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             lhs = LHS ;
             state->NtransSig = LOW ;
             if (LoadByte(state,instr,lhs,LUNSIGNED))
                LSBase = lhs - LSImmRHS ;
             state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
             break ;

          case 0x48 : /* Store Word, No WriteBack, Post Inc, Immed */
             lhs = LHS ;
             if (StoreWord(state,instr,lhs))
                LSBase = lhs + LSImmRHS ;
             break ;

          case 0x49 : /* Load Word, No WriteBack, Post Inc, Immed */
             lhs = LHS ;
             if (LoadWord(state,instr,lhs))
                LSBase = lhs + LSImmRHS ;
             break ;

          case 0x4a : /* Store Word, WriteBack, Post Inc, Immed */
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             lhs = LHS ;
             state->NtransSig = LOW ;
             if (StoreWord(state,instr,lhs))
                LSBase = lhs + LSImmRHS ;
             state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
             break ;

          case 0x4b : /* Load Word, WriteBack, Post Inc, Immed */
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             lhs = LHS ;
             state->NtransSig = LOW ;
             if (LoadWord(state,instr,lhs))
                LSBase = lhs + LSImmRHS ;
             state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
             break ;

          case 0x4c : /* Store Byte, No WriteBack, Post Inc, Immed */
             lhs = LHS ;
             if (StoreByte(state,instr,lhs))
                LSBase = lhs + LSImmRHS ;
             break ;

          case 0x4d : /* Load Byte, No WriteBack, Post Inc, Immed */
             lhs = LHS ;
             if (LoadByte(state,instr,lhs,LUNSIGNED))
                LSBase = lhs + LSImmRHS ;
             break ;

          case 0x4e : /* Store Byte, WriteBack, Post Inc, Immed */
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             lhs = LHS ;
             state->NtransSig = LOW ;
             if (StoreByte(state,instr,lhs))
                LSBase = lhs + LSImmRHS ;
             state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
             break ;

          case 0x4f : /* Load Byte, WriteBack, Post Inc, Immed */
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             lhs = LHS ;
             state->NtransSig = LOW ;
             if (LoadByte(state,instr,lhs,LUNSIGNED))
                LSBase = lhs + LSImmRHS ;
             state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
             break ;


          case 0x50 : /* Store Word, No WriteBack, Pre Dec, Immed */
             (void)StoreWord(state,instr,LHS - LSImmRHS) ;
             break ;

          case 0x51 : /* Load Word, No WriteBack, Pre Dec, Immed */
             (void)LoadWord(state,instr,LHS - LSImmRHS) ;
             break ;

          case 0x52 : /* Store Word, WriteBack, Pre Dec, Immed */
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             temp = LHS - LSImmRHS ;
             if (StoreWord(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x53 : /* Load Word, WriteBack, Pre Dec, Immed */
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             temp = LHS - LSImmRHS ;
             if (LoadWord(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x54 : /* Store Byte, No WriteBack, Pre Dec, Immed */
             (void)StoreByte(state,instr,LHS - LSImmRHS) ;
             break ;

          case 0x55 : /* Load Byte, No WriteBack, Pre Dec, Immed */
             (void)LoadByte(state,instr,LHS - LSImmRHS,LUNSIGNED) ;
             break ;

          case 0x56 : /* Store Byte, WriteBack, Pre Dec, Immed */
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             temp = LHS - LSImmRHS ;
             if (StoreByte(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x57 : /* Load Byte, WriteBack, Pre Dec, Immed */
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             temp = LHS - LSImmRHS ;
             if (LoadByte(state,instr,temp,LUNSIGNED))
                LSBase = temp ;
             break ;

          case 0x58 : /* Store Word, No WriteBack, Pre Inc, Immed */
             (void)StoreWord(state,instr,LHS + LSImmRHS) ;
             break ;

          case 0x59 : /* Load Word, No WriteBack, Pre Inc, Immed */
             (void)LoadWord(state,instr,LHS + LSImmRHS) ;
             break ;

          case 0x5a : /* Store Word, WriteBack, Pre Inc, Immed */
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             temp = LHS + LSImmRHS ;
             if (StoreWord(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x5b : /* Load Word, WriteBack, Pre Inc, Immed */
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             temp = LHS + LSImmRHS ;
             if (LoadWord(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x5c : /* Store Byte, No WriteBack, Pre Inc, Immed */
             (void)StoreByte(state,instr,LHS + LSImmRHS) ;
             break ;

          case 0x5d : /* Load Byte, No WriteBack, Pre Inc, Immed */
             (void)LoadByte(state,instr,LHS + LSImmRHS,LUNSIGNED) ;
             break ;

          case 0x5e : /* Store Byte, WriteBack, Pre Inc, Immed */
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             temp = LHS + LSImmRHS ;
             if (StoreByte(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x5f : /* Load Byte, WriteBack, Pre Inc, Immed */
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             temp = LHS + LSImmRHS ;
             if (LoadByte(state,instr,temp,LUNSIGNED))
                LSBase = temp ;
             break ;
d1975 457
a2431 416
          case 0x60 : /* Store Word, No WriteBack, Post Dec, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             UNDEF_LSRBaseEQOffWb ;
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             UNDEF_LSRPCOffWb ;
             lhs = LHS ;
             if (StoreWord(state,instr,lhs))
                LSBase = lhs - LSRegRHS ;
             break ;

          case 0x61 : /* Load Word, No WriteBack, Post Dec, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             UNDEF_LSRBaseEQOffWb ;
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             UNDEF_LSRPCOffWb ;
             lhs = LHS ;
             if (LoadWord(state,instr,lhs))
                LSBase = lhs - LSRegRHS ;
             break ;

          case 0x62 : /* Store Word, WriteBack, Post Dec, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             UNDEF_LSRBaseEQOffWb ;
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             UNDEF_LSRPCOffWb ;
             lhs = LHS ;
             state->NtransSig = LOW ;
             if (StoreWord(state,instr,lhs))
                LSBase = lhs - LSRegRHS ;
             state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
             break ;

          case 0x63 : /* Load Word, WriteBack, Post Dec, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             UNDEF_LSRBaseEQOffWb ;
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             UNDEF_LSRPCOffWb ;
             lhs = LHS ;
             state->NtransSig = LOW ;
             if (LoadWord(state,instr,lhs))
                LSBase = lhs - LSRegRHS ;
             state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
             break ;

          case 0x64 : /* Store Byte, No WriteBack, Post Dec, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             UNDEF_LSRBaseEQOffWb ;
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             UNDEF_LSRPCOffWb ;
             lhs = LHS ;
             if (StoreByte(state,instr,lhs))
                LSBase = lhs - LSRegRHS ;
             break ;

          case 0x65 : /* Load Byte, No WriteBack, Post Dec, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             UNDEF_LSRBaseEQOffWb ;
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             UNDEF_LSRPCOffWb ;
             lhs = LHS ;
             if (LoadByte(state,instr,lhs,LUNSIGNED))
                LSBase = lhs - LSRegRHS ;
             break ;

          case 0x66 : /* Store Byte, WriteBack, Post Dec, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             UNDEF_LSRBaseEQOffWb ;
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             UNDEF_LSRPCOffWb ;
             lhs = LHS ;
             state->NtransSig = LOW ;
             if (StoreByte(state,instr,lhs))
                LSBase = lhs - LSRegRHS ;
             state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
             break ;

          case 0x67 : /* Load Byte, WriteBack, Post Dec, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             UNDEF_LSRBaseEQOffWb ;
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             UNDEF_LSRPCOffWb ;
             lhs = LHS ;
             state->NtransSig = LOW ;
             if (LoadByte(state,instr,lhs,LUNSIGNED))
                LSBase = lhs - LSRegRHS ;
             state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
             break ;

          case 0x68 : /* Store Word, No WriteBack, Post Inc, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             UNDEF_LSRBaseEQOffWb ;
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             UNDEF_LSRPCOffWb ;
             lhs = LHS ;
             if (StoreWord(state,instr,lhs))
                LSBase = lhs + LSRegRHS ;
             break ;

          case 0x69 : /* Load Word, No WriteBack, Post Inc, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             UNDEF_LSRBaseEQOffWb ;
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             UNDEF_LSRPCOffWb ;
             lhs = LHS ;
             if (LoadWord(state,instr,lhs))
                LSBase = lhs + LSRegRHS ;
             break ;

          case 0x6a : /* Store Word, WriteBack, Post Inc, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             UNDEF_LSRBaseEQOffWb ;
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             UNDEF_LSRPCOffWb ;
             lhs = LHS ;
             state->NtransSig = LOW ;
             if (StoreWord(state,instr,lhs))
                LSBase = lhs + LSRegRHS ;
             state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
             break ;

          case 0x6b : /* Load Word, WriteBack, Post Inc, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             UNDEF_LSRBaseEQOffWb ;
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             UNDEF_LSRPCOffWb ;
             lhs = LHS ;
             state->NtransSig = LOW ;
             if (LoadWord(state,instr,lhs))
                LSBase = lhs + LSRegRHS ;
             state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
             break ;

          case 0x6c : /* Store Byte, No WriteBack, Post Inc, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             UNDEF_LSRBaseEQOffWb ;
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             UNDEF_LSRPCOffWb ;
             lhs = LHS ;
             if (StoreByte(state,instr,lhs))
                LSBase = lhs + LSRegRHS ;
             break ;

          case 0x6d : /* Load Byte, No WriteBack, Post Inc, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             UNDEF_LSRBaseEQOffWb ;
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             UNDEF_LSRPCOffWb ;
             lhs = LHS ;
             if (LoadByte(state,instr,lhs,LUNSIGNED))
                LSBase = lhs + LSRegRHS ;
             break ;

          case 0x6e : /* Store Byte, WriteBack, Post Inc, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             UNDEF_LSRBaseEQOffWb ;
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             UNDEF_LSRPCOffWb ;
             lhs = LHS ;
             state->NtransSig = LOW ;
             if (StoreByte(state,instr,lhs))
                LSBase = lhs + LSRegRHS ;
             state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
             break ;

          case 0x6f : /* Load Byte, WriteBack, Post Inc, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             UNDEF_LSRBaseEQOffWb ;
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             UNDEF_LSRPCOffWb ;
             lhs = LHS ;
             state->NtransSig = LOW ;
             if (LoadByte(state,instr,lhs,LUNSIGNED))
                LSBase = lhs + LSRegRHS ;
             state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
             break ;


          case 0x70 : /* Store Word, No WriteBack, Pre Dec, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             (void)StoreWord(state,instr,LHS - LSRegRHS) ;
             break ;

          case 0x71 : /* Load Word, No WriteBack, Pre Dec, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             (void)LoadWord(state,instr,LHS - LSRegRHS) ;
             break ;

          case 0x72 : /* Store Word, WriteBack, Pre Dec, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             UNDEF_LSRBaseEQOffWb ;
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             UNDEF_LSRPCOffWb ;
             temp = LHS - LSRegRHS ;
             if (StoreWord(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x73 : /* Load Word, WriteBack, Pre Dec, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             UNDEF_LSRBaseEQOffWb ;
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             UNDEF_LSRPCOffWb ;
             temp = LHS - LSRegRHS ;
             if (LoadWord(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x74 : /* Store Byte, No WriteBack, Pre Dec, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             (void)StoreByte(state,instr,LHS - LSRegRHS) ;
             break ;

          case 0x75 : /* Load Byte, No WriteBack, Pre Dec, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             (void)LoadByte(state,instr,LHS - LSRegRHS,LUNSIGNED) ;
             break ;

          case 0x76 : /* Store Byte, WriteBack, Pre Dec, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             UNDEF_LSRBaseEQOffWb ;
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             UNDEF_LSRPCOffWb ;
             temp = LHS - LSRegRHS ;
             if (StoreByte(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x77 : /* Load Byte, WriteBack, Pre Dec, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             UNDEF_LSRBaseEQOffWb ;
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             UNDEF_LSRPCOffWb ;
             temp = LHS - LSRegRHS ;
             if (LoadByte(state,instr,temp,LUNSIGNED))
                LSBase = temp ;
             break ;

          case 0x78 : /* Store Word, No WriteBack, Pre Inc, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             (void)StoreWord(state,instr,LHS + LSRegRHS) ;
             break ;

          case 0x79 : /* Load Word, No WriteBack, Pre Inc, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             (void)LoadWord(state,instr,LHS + LSRegRHS) ;
             break ;

          case 0x7a : /* Store Word, WriteBack, Pre Inc, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             UNDEF_LSRBaseEQOffWb ;
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             UNDEF_LSRPCOffWb ;
             temp = LHS + LSRegRHS ;
             if (StoreWord(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x7b : /* Load Word, WriteBack, Pre Inc, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             UNDEF_LSRBaseEQOffWb ;
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             UNDEF_LSRPCOffWb ;
             temp = LHS + LSRegRHS ;
             if (LoadWord(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x7c : /* Store Byte, No WriteBack, Pre Inc, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             (void)StoreByte(state,instr,LHS + LSRegRHS) ;
             break ;

          case 0x7d : /* Load Byte, No WriteBack, Pre Inc, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             (void)LoadByte(state,instr,LHS + LSRegRHS,LUNSIGNED) ;
             break ;

          case 0x7e : /* Store Byte, WriteBack, Pre Inc, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             UNDEF_LSRBaseEQOffWb ;
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             UNDEF_LSRPCOffWb ;
             temp = LHS + LSRegRHS ;
             if (StoreByte(state,instr,temp))
                LSBase = temp ;
             break ;

          case 0x7f : /* Load Byte, WriteBack, Pre Inc, Reg */
             if (BIT(4)) {
                ARMul_UndefInstr(state,instr) ;
                break ;
                }
             UNDEF_LSRBaseEQOffWb ;
             UNDEF_LSRBaseEQDestWb ;
             UNDEF_LSRPCBaseWb ;
             UNDEF_LSRPCOffWb ;
             temp = LHS + LSRegRHS ;
             if (LoadByte(state,instr,temp,LUNSIGNED))
                LSBase = temp ;
             break ;
d2437 146
a2582 146
          case 0x80 : /* Store, No WriteBack, Post Dec */
             STOREMULT(instr,LSBase - LSMNumRegs + 4L,0L) ;
             break ;

          case 0x81 : /* Load, No WriteBack, Post Dec */
             LOADMULT(instr,LSBase - LSMNumRegs + 4L,0L) ;
             break ;

          case 0x82 : /* Store, WriteBack, Post Dec */
             temp = LSBase - LSMNumRegs ;
             STOREMULT(instr,temp + 4L,temp) ;
             break ;

          case 0x83 : /* Load, WriteBack, Post Dec */
             temp = LSBase - LSMNumRegs ;
             LOADMULT(instr,temp + 4L,temp) ;
             break ;

          case 0x84 : /* Store, Flags, No WriteBack, Post Dec */
             STORESMULT(instr,LSBase - LSMNumRegs + 4L,0L) ;
             break ;

          case 0x85 : /* Load, Flags, No WriteBack, Post Dec */
             LOADSMULT(instr,LSBase - LSMNumRegs + 4L,0L) ;
             break ;

          case 0x86 : /* Store, Flags, WriteBack, Post Dec */
             temp = LSBase - LSMNumRegs ;
             STORESMULT(instr,temp + 4L,temp) ;
             break ;

          case 0x87 : /* Load, Flags, WriteBack, Post Dec */
             temp = LSBase - LSMNumRegs ;
             LOADSMULT(instr,temp + 4L,temp) ;
             break ;


          case 0x88 : /* Store, No WriteBack, Post Inc */
             STOREMULT(instr,LSBase,0L) ;
             break ;

          case 0x89 : /* Load, No WriteBack, Post Inc */
             LOADMULT(instr,LSBase,0L) ;
             break ;

          case 0x8a : /* Store, WriteBack, Post Inc */
             temp = LSBase ;
             STOREMULT(instr,temp,temp + LSMNumRegs) ;
             break ;

          case 0x8b : /* Load, WriteBack, Post Inc */
             temp = LSBase ;
             LOADMULT(instr,temp,temp + LSMNumRegs) ;
             break ;

          case 0x8c : /* Store, Flags, No WriteBack, Post Inc */
             STORESMULT(instr,LSBase,0L) ;
             break ;

          case 0x8d : /* Load, Flags, No WriteBack, Post Inc */
             LOADSMULT(instr,LSBase,0L) ;
             break ;

          case 0x8e : /* Store, Flags, WriteBack, Post Inc */
             temp = LSBase ;
             STORESMULT(instr,temp,temp + LSMNumRegs) ;
             break ;

          case 0x8f : /* Load, Flags, WriteBack, Post Inc */
             temp = LSBase ;
             LOADSMULT(instr,temp,temp + LSMNumRegs) ;
             break ;


          case 0x90 : /* Store, No WriteBack, Pre Dec */
             STOREMULT(instr,LSBase - LSMNumRegs,0L) ;
             break ;

          case 0x91 : /* Load, No WriteBack, Pre Dec */
             LOADMULT(instr,LSBase - LSMNumRegs,0L) ;
             break ;

          case 0x92 : /* Store, WriteBack, Pre Dec */
             temp = LSBase - LSMNumRegs ;
             STOREMULT(instr,temp,temp) ;
             break ;

          case 0x93 : /* Load, WriteBack, Pre Dec */
             temp = LSBase - LSMNumRegs ;
             LOADMULT(instr,temp,temp) ;
             break ;

          case 0x94 : /* Store, Flags, No WriteBack, Pre Dec */
             STORESMULT(instr,LSBase - LSMNumRegs,0L) ;
             break ;

          case 0x95 : /* Load, Flags, No WriteBack, Pre Dec */
             LOADSMULT(instr,LSBase - LSMNumRegs,0L) ;
             break ;

          case 0x96 : /* Store, Flags, WriteBack, Pre Dec */
             temp = LSBase - LSMNumRegs ;
             STORESMULT(instr,temp,temp) ;
             break ;

          case 0x97 : /* Load, Flags, WriteBack, Pre Dec */
             temp = LSBase - LSMNumRegs ;
             LOADSMULT(instr,temp,temp) ;
             break ;


          case 0x98 : /* Store, No WriteBack, Pre Inc */
             STOREMULT(instr,LSBase + 4L,0L) ;
             break ;

          case 0x99 : /* Load, No WriteBack, Pre Inc */
             LOADMULT(instr,LSBase + 4L,0L) ;
             break ;

          case 0x9a : /* Store, WriteBack, Pre Inc */
             temp = LSBase ;
             STOREMULT(instr,temp + 4L,temp + LSMNumRegs) ;
             break ;

          case 0x9b : /* Load, WriteBack, Pre Inc */
             temp = LSBase ;
             LOADMULT(instr,temp + 4L,temp + LSMNumRegs) ;
             break ;

          case 0x9c : /* Store, Flags, No WriteBack, Pre Inc */
             STORESMULT(instr,LSBase + 4L,0L) ;
             break ;

          case 0x9d : /* Load, Flags, No WriteBack, Pre Inc */
             LOADSMULT(instr,LSBase + 4L,0L) ;
             break ;

          case 0x9e : /* Store, Flags, WriteBack, Pre Inc */
             temp = LSBase ;
             STORESMULT(instr,temp + 4L,temp + LSMNumRegs) ;
             break ;

          case 0x9f : /* Load, Flags, WriteBack, Pre Inc */
             temp = LSBase ;
             LOADSMULT(instr,temp + 4L,temp + LSMNumRegs) ;
             break ;
d2588 11
a2598 5
          case 0xa0 : case 0xa1 : case 0xa2 : case 0xa3 :
          case 0xa4 : case 0xa5 : case 0xa6 : case 0xa7 :
             state->Reg[15] = pc + 8 + POSBRANCH ;
             FLUSHPIPE ;
             break ;
d2604 11
a2614 5
          case 0xa8 : case 0xa9 : case 0xaa : case 0xab :
          case 0xac : case 0xad : case 0xae : case 0xaf :
             state->Reg[15] = pc + 8 + NEGBRANCH ;
             FLUSHPIPE ;
             break ;
d2620 8
a2627 2
          case 0xb0 : case 0xb1 : case 0xb2 : case 0xb3 :
          case 0xb4 : case 0xb5 : case 0xb6 : case 0xb7 :
d2629 1
a2629 1
             state->Reg[14] = pc + 4 ; /* put PC into Link */
d2631 1
a2631 1
             state->Reg[14] = pc + 4 | ECC | ER15INT | EMODE ; /* put PC into Link */
d2633 3
a2635 3
             state->Reg[15] = pc + 8 + POSBRANCH ;
             FLUSHPIPE ;
             break ;
d2641 8
a2648 2
          case 0xb8 : case 0xb9 : case 0xba : case 0xbb :
          case 0xbc : case 0xbd : case 0xbe : case 0xbf :
d2650 1
a2650 1
             state->Reg[14] = pc + 4 ; /* put PC into Link */
d2652 1
a2652 1
             state->Reg[14] = (pc + 4) | ECC | ER15INT | EMODE ; /* put PC into Link */
d2654 3
a2656 3
             state->Reg[15] = pc + 8 + NEGBRANCH ;
             FLUSHPIPE ;
             break ;
d2662 96
a2757 96
          case 0xc0 :
          case 0xc4 : /* Store , No WriteBack , Post Dec */
             ARMul_STC(state,instr,LHS) ;
             break ;

          case 0xc1 :
          case 0xc5 : /* Load , No WriteBack , Post Dec */
             ARMul_LDC(state,instr,LHS) ;
             break ;

          case 0xc2 :
          case 0xc6 : /* Store , WriteBack , Post Dec */
             lhs = LHS ;
             state->Base = lhs - LSCOff ;
             ARMul_STC(state,instr,lhs) ;
             break ;

          case 0xc3 :
          case 0xc7 : /* Load , WriteBack , Post Dec */
             lhs = LHS ;
             state->Base = lhs - LSCOff ;
             ARMul_LDC(state,instr,lhs) ;
             break ;

          case 0xc8 :
          case 0xcc : /* Store , No WriteBack , Post Inc */
             ARMul_STC(state,instr,LHS) ;
             break ;

          case 0xc9 :
          case 0xcd : /* Load , No WriteBack , Post Inc */
             ARMul_LDC(state,instr,LHS) ;
             break ;

          case 0xca :
          case 0xce : /* Store , WriteBack , Post Inc */
             lhs = LHS ;
             state->Base = lhs + LSCOff ;
             ARMul_STC(state,instr,LHS) ;
             break ;

          case 0xcb :
          case 0xcf : /* Load , WriteBack , Post Inc */
             lhs = LHS ;
             state->Base = lhs + LSCOff ;
             ARMul_LDC(state,instr,LHS) ;
             break ;


          case 0xd0 :
          case 0xd4 : /* Store , No WriteBack , Pre Dec */
             ARMul_STC(state,instr,LHS - LSCOff) ;
             break ;

          case 0xd1 :
          case 0xd5 : /* Load , No WriteBack , Pre Dec */
             ARMul_LDC(state,instr,LHS - LSCOff) ;
             break ;

          case 0xd2 :
          case 0xd6 : /* Store , WriteBack , Pre Dec */
             lhs = LHS - LSCOff ;
             state->Base = lhs ;
             ARMul_STC(state,instr,lhs) ;
             break ;

          case 0xd3 :
          case 0xd7 : /* Load , WriteBack , Pre Dec */
             lhs = LHS - LSCOff ;
             state->Base = lhs ;
             ARMul_LDC(state,instr,lhs) ;
             break ;

          case 0xd8 :
          case 0xdc : /* Store , No WriteBack , Pre Inc */
             ARMul_STC(state,instr,LHS + LSCOff) ;
             break ;

          case 0xd9 :
          case 0xdd : /* Load , No WriteBack , Pre Inc */
             ARMul_LDC(state,instr,LHS + LSCOff) ;
             break ;

          case 0xda :
          case 0xde : /* Store , WriteBack , Pre Inc */
             lhs = LHS + LSCOff ;
             state->Base = lhs ;
             ARMul_STC(state,instr,lhs) ;
             break ;

          case 0xdb :
          case 0xdf : /* Load , WriteBack , Pre Inc */
             lhs = LHS + LSCOff ;
             state->Base = lhs ;
             ARMul_LDC(state,instr,lhs) ;
             break ;
d2763 13
a2775 5
          case 0xe0 : case 0xe2 : case 0xe4 : case 0xe6 :
          case 0xe8 : case 0xea : case 0xec : case 0xee :
             if (BIT(4)) { /* MCR */
                if (DESTReg == 15) {
                   UNDEF_MCRPC ;
d2777 1
a2777 1
                   ARMul_MCR(state,instr,state->Reg[15] + isize) ;
d2779 2
a2780 2
                   ARMul_MCR(state,instr,ECC | ER15INT | EMODE |
                                          ((state->Reg[15] + isize) & R15PCBITS) ) ;
d2782 7
a2788 7
                   }
                else
                   ARMul_MCR(state,instr,DEST) ;
                }
             else /* CDP Part 1 */
                ARMul_CDP(state,instr) ;
             break ;
d2794 24
a2817 16
          case 0xe1 : case 0xe3 : case 0xe5 : case 0xe7 :
          case 0xe9 : case 0xeb : case 0xed : case 0xef :
             if (BIT(4)) { /* MRC */
                temp = ARMul_MRC(state,instr) ;
                if (DESTReg == 15) {
                   ASSIGNN((temp & NBIT) != 0) ;
                   ASSIGNZ((temp & ZBIT) != 0) ;
                   ASSIGNC((temp & CBIT) != 0) ;
                   ASSIGNV((temp & VBIT) != 0) ;
                   }
                else
                   DEST = temp ;
                }
             else /* CDP Part 2 */
                ARMul_CDP(state,instr) ;
             break ;
d2823 54
a2876 31
          case 0xf0 : case 0xf1 : case 0xf2 : case 0xf3 :
          case 0xf4 : case 0xf5 : case 0xf6 : case 0xf7 :
          case 0xf8 : case 0xf9 : case 0xfa : case 0xfb :
          case 0xfc : case 0xfd : case 0xfe : case 0xff :
             if (instr == ARMul_ABORTWORD && state->AbortAddr == pc) { /* a prefetch abort */
                ARMul_Abort(state,ARMul_PrefetchAbortV) ;
                break ;
                }
    
             if (!ARMul_OSHandleSWI(state,BITS(0,23))) {
                ARMul_Abort(state,ARMul_SWIV) ;
                }
             break ;
          } /* 256 way main switch */
       } /* if temp */

#ifdef MODET
donext:
#endif

    if (state->Emulate == ONCE)
        state->Emulate = STOP;
    else if (state->Emulate != RUN)
        break;
    } while (1) ; /* do loop */

 state->decoded = decoded ;
 state->loaded = loaded ;
 state->pc = pc ;
 return(pc) ;
 } /* Emulate 26/32 in instruction based mode */
d2885 4
a2888 2
static ARMword GetDPRegRHS(ARMul_State *state, ARMword instr)
{ARMword shamt , base ;
d2890 5
a2894 4
 base = RHSReg ;
 if (BIT(4)) { /* shift amount in a register */
    UNDEF_Shift ;
    INCPC ;
d2896 37
a2932 32
    if (base == 15)
       base = ECC | ER15INT | R15PC | EMODE ;
    else
#endif
       base = state->Reg[base] ;
    ARMul_Icycles(state,1,0L) ;
    shamt = state->Reg[BITS(8,11)] & 0xff ;
    switch ((int)BITS(5,6)) {
       case LSL : if (shamt == 0)
                     return(base) ;
                  else if (shamt >= 32)
                     return(0) ;
                  else
                     return(base << shamt) ;
       case LSR : if (shamt == 0)
                     return(base) ;
                  else if (shamt >= 32)
                     return(0) ;
                  else
                     return(base >> shamt) ;
       case ASR : if (shamt == 0)
                     return(base) ;
                  else if (shamt >= 32)
                     return((ARMword)((long int)base >> 31L)) ;
                  else
                     return((ARMword)((long int)base >> (int)shamt)) ;
       case ROR : shamt &= 0x1f ;
                  if (shamt == 0)
                     return(base) ;
                  else
                     return((base << (32 - shamt)) | (base >> shamt)) ;
       }
d2934 2
a2935 1
 else { /* shift amount is a constant */
d2937 26
a2962 21
    if (base == 15)
       base = ECC | ER15INT | R15PC | EMODE ;
    else
#endif
       base = state->Reg[base] ;
    shamt = BITS(7,11) ;
    switch ((int)BITS(5,6)) {
       case LSL : return(base<<shamt) ;
       case LSR : if (shamt == 0)
                     return(0) ;
                  else
                     return(base >> shamt) ;
       case ASR : if (shamt == 0)
                     return((ARMword)((long int)base >> 31L)) ;
                  else
                     return((ARMword)((long int)base >> (int)shamt)) ;
       case ROR : if (shamt==0) /* its an RRX */
                     return((base >> 1) | (CFLAG << 31)) ;
                  else
                     return((base << (32 - shamt)) | (base >> shamt)) ;
       }
d2964 3
a2966 2
 return(0) ; /* just to shut up lint */
 }
d2974 4
a2977 2
static ARMword GetDPSRegRHS(ARMul_State *state, ARMword instr)
{ARMword shamt , base ;
d2979 5
a2983 4
 base = RHSReg ;
 if (BIT(4)) { /* shift amount in a register */
    UNDEF_Shift ;
    INCPC ;
d2985 73
a3057 58
    if (base == 15)
       base = ECC | ER15INT | R15PC | EMODE ;
    else
#endif
       base = state->Reg[base] ;
    ARMul_Icycles(state,1,0L) ;
    shamt = state->Reg[BITS(8,11)] & 0xff ;
    switch ((int)BITS(5,6)) {
       case LSL : if (shamt == 0)
                     return(base) ;
                  else if (shamt == 32) {
                     ASSIGNC(base & 1) ;
                     return(0) ;
                     }
                  else if (shamt > 32) {
                     CLEARC ;
                     return(0) ;
                     }
                  else {
                     ASSIGNC((base >> (32-shamt)) & 1) ;
                     return(base << shamt) ;
                     }
       case LSR : if (shamt == 0)
                     return(base) ;
                  else if (shamt == 32) {
                     ASSIGNC(base >> 31) ;
                     return(0) ;
                     }
                  else if (shamt > 32) {
                     CLEARC ;
                     return(0) ;
                     }
                  else {
                     ASSIGNC((base >> (shamt - 1)) & 1) ;
                     return(base >> shamt) ;
                     }
       case ASR : if (shamt == 0)
                     return(base) ;
                  else if (shamt >= 32) {
                     ASSIGNC(base >> 31L) ;
                     return((ARMword)((long int)base >> 31L)) ;
                     }
                  else {
                     ASSIGNC((ARMword)((long int)base >> (int)(shamt-1)) & 1) ;
                     return((ARMword)((long int)base >> (int)shamt)) ;
                     }
       case ROR : if (shamt == 0)
                     return(base) ;
                  shamt &= 0x1f ;
                  if (shamt == 0) {
                     ASSIGNC(base >> 31) ;
                     return(base) ;
                     }
                  else {
                     ASSIGNC((base >> (shamt-1)) & 1) ;
                     return((base << (32-shamt)) | (base >> shamt)) ;
                     }
       }
d3059 2
a3060 1
 else { /* shift amount is a constant */
d3062 46
a3107 35
    if (base == 15)
       base = ECC | ER15INT | R15PC | EMODE ;
    else
#endif
       base = state->Reg[base] ;
    shamt = BITS(7,11) ;
    switch ((int)BITS(5,6)) {
       case LSL : ASSIGNC((base >> (32-shamt)) & 1) ;
                  return(base << shamt) ;
       case LSR : if (shamt == 0) {
                     ASSIGNC(base >> 31) ;
                     return(0) ;
                     }
                  else {
                     ASSIGNC((base >> (shamt - 1)) & 1) ;
                     return(base >> shamt) ;
                     }
       case ASR : if (shamt == 0) {
                     ASSIGNC(base >> 31L) ;
                     return((ARMword)((long int)base >> 31L)) ;
                     }
                  else {
                     ASSIGNC((ARMword)((long int)base >> (int)(shamt-1)) & 1) ;
                     return((ARMword)((long int)base >> (int)shamt)) ;
                     }
       case ROR : if (shamt == 0) { /* its an RRX */
                     shamt = CFLAG ;
                     ASSIGNC(base & 1) ;
                     return((base >> 1) | (shamt << 31)) ;
                     }
                  else {
                     ASSIGNC((base >> (shamt - 1)) & 1) ;
                     return((base << (32-shamt)) | (base >> shamt)) ;
                     }
       }
d3109 2
a3110 2
 return(0) ; /* just to shut up lint */
 }
d3116 2
a3117 1
static void WriteR15(ARMul_State *state, ARMword src)
d3121 1
a3121 1
 state->Reg[15] = src & PCBITS & ~ 0x1 ;
d3123 2
a3124 2
 state->Reg[15] = (src & R15PCBITS & ~ 0x1) | ECC | ER15INT | EMODE ;
 ARMul_R15Altered(state) ;
d3126 2
a3127 2
 FLUSHPIPE ;
 }
d3133 2
a3134 1
static void WriteSR15(ARMul_State *state, ARMword src)
d3137 5
a3141 4
 state->Reg[15] = src & PCBITS ;
 if (state->Bank > 0) {
    state->Cpsr = state->Spsr[state->Bank] ;
    ARMul_CPSRAltered(state) ;
d3144 5
a3148 5
 if (state->Bank == USERBANK)
    state->Reg[15] = (src & (CCBITS | R15PCBITS)) | ER15INT | EMODE ;
 else
    state->Reg[15] = src ;
 ARMul_R15Altered(state) ;
d3150 2
a3151 2
 FLUSHPIPE ;
 }
d3159 4
a3162 2
static ARMword GetLSRegRHS(ARMul_State *state, ARMword instr)
{ARMword shamt, base ;
d3164 1
a3164 1
 base = RHSReg ;
d3166 26
a3191 21
 if (base == 15)
    base = ECC | ER15INT | R15PC | EMODE ; /* Now forbidden, but .... */
 else
#endif
    base = state->Reg[base] ;

 shamt = BITS(7,11) ;
 switch ((int)BITS(5,6)) {
    case LSL : return(base << shamt) ;
    case LSR : if (shamt == 0)
                  return(0) ;
               else
                  return(base >> shamt) ;
    case ASR : if (shamt == 0)
                  return((ARMword)((long int)base >> 31L)) ;
               else
                  return((ARMword)((long int)base >> (int)shamt)) ;
    case ROR : if (shamt==0) /* its an RRX */
                  return((base >> 1) | (CFLAG << 31)) ;
               else
                  return((base << (32-shamt)) | (base >> shamt)) ;
d3193 2
a3194 2
 return(0) ; /* just to shut up lint */
 }
d3200 2
a3201 1
static ARMword GetLS7RHS(ARMul_State *state, ARMword instr)
d3203 2
a3204 1
 if (BIT(22) == 0) { /* register */
d3206 2
a3207 2
    if (RHSReg == 15)
      return ECC | ER15INT | R15PC | EMODE ; /* Now forbidden, but ... */
d3209 1
a3209 1
    return state->Reg[RHSReg] ;
d3212 3
a3214 3
 /* else immediate */
 return BITS(0,3) | (BITS(8,11) << 4) ;
 }
d3220 2
a3221 1
static unsigned LoadWord(ARMul_State *state, ARMword instr, ARMword address)
d3223 1
a3223 1
 ARMword dest ;
d3225 1
a3225 1
 BUSUSEDINCPCS ;
d3227 3
a3229 2
 if (ADDREXCEPT(address)) {
    INTERNALABORT(address) ;
d3232 5
a3236 4
 dest = ARMul_LoadWordN(state,address) ;
 if (state->Aborted) {
    TAKEABORT ;
    return(state->lateabtSig) ;
d3238 4
a3241 4
 if (address & 3)
    dest = ARMul_Align(state,address,dest) ;
 WRITEDEST(dest) ;
 ARMul_Icycles(state,1,0L) ;
d3243 1
a3243 1
 return(DESTReg != LHSReg) ;
d3251 3
a3253 1
static unsigned LoadHalfWord(ARMul_State *state, ARMword instr, ARMword address,int signextend)
d3255 1
a3255 1
 ARMword dest ;
d3257 1
a3257 1
 BUSUSEDINCPCS ;
d3259 3
a3261 2
 if (ADDREXCEPT(address)) {
    INTERNALABORT(address) ;
d3264 15
a3278 14
 dest = ARMul_LoadHalfWord(state,address) ;
 if (state->Aborted) {
    TAKEABORT ;
    return(state->lateabtSig) ;
    }
 UNDEF_LSRBPC ;
 if (signextend)
   {
     if (dest & 1 << (16 - 1))
         dest = (dest & ((1 << 16) - 1)) - (1 << 16) ;
   }
 WRITEDEST(dest) ;
 ARMul_Icycles(state,1,0L) ;
 return(DESTReg != LHSReg) ;
d3280 1
d3287 2
a3288 1
static unsigned LoadByte(ARMul_State *state, ARMword instr, ARMword address,int signextend)
d3290 1
a3290 1
 ARMword dest ;
d3292 1
a3292 1
 BUSUSEDINCPCS ;
d3294 3
a3296 2
 if (ADDREXCEPT(address)) {
    INTERNALABORT(address) ;
d3299 15
a3313 14
 dest = ARMul_LoadByte(state,address) ;
 if (state->Aborted) {
    TAKEABORT ;
    return(state->lateabtSig) ;
    }
 UNDEF_LSRBPC ;
 if (signextend)
   {
     if (dest & 1 << (8 - 1))
         dest = (dest & ((1 << 8) - 1)) - (1 << 8) ;
   }
 WRITEDEST(dest) ;
 ARMul_Icycles(state,1,0L) ;
 return(DESTReg != LHSReg) ;
d3320 4
a3323 2
static unsigned StoreWord(ARMul_State *state, ARMword instr, ARMword address)
{BUSUSEDINCPCN ;
d3325 2
a3326 2
 if (DESTReg == 15)
    state->Reg[15] = ECC | ER15INT | R15PC | EMODE ;
d3329 1
a3329 1
 ARMul_StoreWordN(state,address,DEST) ;
d3331 12
a3342 10
 if (VECTORACCESS(address) || ADDREXCEPT(address)) {
    INTERNALABORT(address) ;
    (void)ARMul_LoadWordN(state,address) ;
    }
 else
    ARMul_StoreWordN(state,address,DEST) ;
#endif
 if (state->Aborted) {
    TAKEABORT ;
    return(state->lateabtSig) ;
d3344 1
a3344 1
 return(TRUE) ;
d3352 4
a3355 2
static unsigned StoreHalfWord(ARMul_State *state, ARMword instr, ARMword address)
{BUSUSEDINCPCN ;
d3358 2
a3359 2
 if (DESTReg == 15)
    state->Reg[15] = ECC | ER15INT | R15PC | EMODE ;
d3363 1
a3363 1
 ARMul_StoreHalfWord(state,address,DEST);
d3365 4
a3368 3
 if (VECTORACCESS(address) || ADDREXCEPT(address)) {
    INTERNALABORT(address) ;
    (void)ARMul_LoadHalfWord(state,address) ;
d3370 2
a3371 2
 else
    ARMul_StoreHalfWord(state,address,DEST) ;
d3374 4
a3377 3
 if (state->Aborted) {
    TAKEABORT ;
    return(state->lateabtSig) ;
d3380 1
a3380 1
 return(TRUE) ;
d3382 1
d3389 4
a3392 2
static unsigned StoreByte(ARMul_State *state, ARMword instr, ARMword address)
{BUSUSEDINCPCN ;
d3394 2
a3395 2
 if (DESTReg == 15)
    state->Reg[15] = ECC | ER15INT | R15PC | EMODE ;
d3398 1
a3398 1
 ARMul_StoreByte(state,address,DEST) ;
d3400 4
a3403 10
 if (VECTORACCESS(address) || ADDREXCEPT(address)) {
    INTERNALABORT(address) ;
    (void)ARMul_LoadByte(state,address) ;
    }
 else
    ARMul_StoreByte(state,address,DEST) ;
#endif
 if (state->Aborted) {
    TAKEABORT ;
    return(state->lateabtSig) ;
d3405 10
a3414 2
 UNDEF_LSRBPC ;
 return(TRUE) ;
d3424 9
a3432 8
static void LoadMult(ARMul_State *state, ARMword instr,
                     ARMword address, ARMword WBBase)
{ARMword dest, temp ;

 UNDEF_LSMNoRegs ;
 UNDEF_LSMPCBase ;
 UNDEF_LSMBaseInListWb ;
 BUSUSEDINCPCS ;
d3434 3
a3436 2
 if (ADDREXCEPT(address)) {
    INTERNALABORT(address) ;
d3439 2
a3440 2
 if (BIT(21) && LHSReg != 15)
    LSBase = WBBase ;
d3442 17
a3458 18
    for (temp = 0 ; !BIT(temp) ; temp++) ; /* N cycle first */
    dest = ARMul_LoadWordN(state,address) ;
    if (!state->abortSig && !state->Aborted)
       state->Reg[temp++] = dest ;
    else
       if (!state->Aborted)
          state->Aborted = ARMul_DataAbortV ;

    for (; temp < 16 ; temp++) /* S cycles from here on */
       if (BIT(temp)) { /* load this register */
          address += 4 ;
          dest = ARMul_LoadWordS(state,address) ;
          if (!state->abortSig && !state->Aborted)
             state->Reg[temp] = dest ;
          else
             if (!state->Aborted)
                state->Aborted = ARMul_DataAbortV ;
          }
d3460 2
a3461 1
 if (BIT(15)) { /* PC is in the reg list */
d3463 1
a3463 1
    state->Reg[15] = PC ;
d3465 1
a3465 1
    FLUSHPIPE ;
d3468 1
a3468 1
 ARMul_Icycles(state,1,0L) ; /* to write back the final register */
d3470 5
a3474 4
 if (state->Aborted) {
    if (BIT(21) && LHSReg != 15)
       LSBase = WBBase ;
    TAKEABORT ;
d3476 1
a3476 1
 }
d3485 10
a3494 8
static void LoadSMult(ARMul_State *state, ARMword instr,
                      ARMword address, ARMword WBBase)
{ARMword dest, temp ;

 UNDEF_LSMNoRegs ;
 UNDEF_LSMPCBase ;
 UNDEF_LSMBaseInListWb ;
 BUSUSEDINCPCS ;
d3496 3
a3498 2
 if (ADDREXCEPT(address)) {
    INTERNALABORT(address) ;
d3502 36
a3537 34
 if (!BIT(15) && state->Bank != USERBANK) {
    (void)ARMul_SwitchMode(state,state->Mode,USER26MODE) ; /* temporary reg bank switch */
    UNDEF_LSMUserBankWb ;
    }

 if (BIT(21) && LHSReg != 15)
    LSBase = WBBase ;

    for (temp = 0 ; !BIT(temp) ; temp++) ; /* N cycle first */
    dest = ARMul_LoadWordN(state,address) ;
    if (!state->abortSig)
       state->Reg[temp++] = dest ;
    else
       if (!state->Aborted)
          state->Aborted = ARMul_DataAbortV ;

    for (; temp < 16 ; temp++) /* S cycles from here on */
       if (BIT(temp)) { /* load this register */
          address += 4 ;
          dest = ARMul_LoadWordS(state,address) ;
          if (!state->abortSig || state->Aborted)
             state->Reg[temp] = dest ;
          else
             if (!state->Aborted)
                state->Aborted = ARMul_DataAbortV ;
          }

 if (BIT(15)) { /* PC is in the reg list */
#ifdef MODE32
    if (state->Mode != USER26MODE && state->Mode != USER32MODE) {
       state->Cpsr = GETSPSR(state->Bank) ;
       ARMul_CPSRAltered(state) ;
       }
    state->Reg[15] = PC ;
d3539 23
a3561 21
    if (state->Mode == USER26MODE || state->Mode == USER32MODE) { /* protect bits in user mode */
       ASSIGNN((state->Reg[15] & NBIT) != 0) ;
       ASSIGNZ((state->Reg[15] & ZBIT) != 0) ;
       ASSIGNC((state->Reg[15] & CBIT) != 0) ;
       ASSIGNV((state->Reg[15] & VBIT) != 0) ;
       }
    else
       ARMul_R15Altered(state) ;
#endif
    FLUSHPIPE ;
    }

 if (!BIT(15) && state->Mode != USER26MODE && state->Mode != USER32MODE)
    (void)ARMul_SwitchMode(state,USER26MODE,state->Mode) ; /* restore the correct bank */

 ARMul_Icycles(state,1,0L) ; /* to write back the final register */

 if (state->Aborted) {
    if (BIT(21) && LHSReg != 15)
       LSBase = WBBase ;
    TAKEABORT ;
d3573 13
a3585 10
static void StoreMult(ARMul_State *state, ARMword instr,
                      ARMword address, ARMword WBBase)
{ARMword temp ;

 UNDEF_LSMNoRegs ;
 UNDEF_LSMPCBase ;
 UNDEF_LSMBaseInListWb ;
 if (!TFLAG) {
   BUSUSEDINCPCN ; /* N-cycle, increment the PC and update the NextInstr state */
 }
d3588 3
a3590 2
 if (VECTORACCESS(address) || ADDREXCEPT(address)) {
    INTERNALABORT(address) ;
d3592 2
a3593 2
 if (BIT(15))
    PATCHR15 ;
d3596 1
a3596 1
 for (temp = 0 ; !BIT(temp) ; temp++) ; /* N cycle first */
d3598 1
a3598 1
 ARMul_StoreWordN(state,address,state->Reg[temp++]) ;
d3600 36
a3635 32
 if (state->Aborted) {
    (void)ARMul_LoadWordN(state,address) ;
    for ( ; temp < 16 ; temp++) /* Fake the Stores as Loads */
       if (BIT(temp)) { /* save this register */
          address += 4 ;
          (void)ARMul_LoadWordS(state,address) ;
          }
    if (BIT(21) && LHSReg != 15)
       LSBase = WBBase ;
    TAKEABORT ;
    return ;
    }
 else
    ARMul_StoreWordN(state,address,state->Reg[temp++]) ;
#endif
 if (state->abortSig && !state->Aborted)
    state->Aborted = ARMul_DataAbortV ;

 if (BIT(21) && LHSReg != 15)
    LSBase = WBBase ;

 for ( ; temp < 16 ; temp++) /* S cycles from here on */
    if (BIT(temp)) { /* save this register */
       address += 4 ;
       ARMul_StoreWordS(state,address,state->Reg[temp]) ;
       if (state->abortSig && !state->Aborted)
             state->Aborted = ARMul_DataAbortV ;
       }
    if (state->Aborted) {
       TAKEABORT ;
       }
 }
d3644 10
a3653 8
static void StoreSMult(ARMul_State *state, ARMword instr,
                       ARMword address, ARMword WBBase)
{ARMword temp ;

 UNDEF_LSMNoRegs ;
 UNDEF_LSMPCBase ;
 UNDEF_LSMBaseInListWb ;
 BUSUSEDINCPCN ;
d3655 3
a3657 2
 if (VECTORACCESS(address) || ADDREXCEPT(address)) {
    INTERNALABORT(address) ;
d3659 2
a3660 2
 if (BIT(15))
    PATCHR15 ;
d3663 4
a3666 3
 if (state->Bank != USERBANK) {
    (void)ARMul_SwitchMode(state,state->Mode,USER26MODE) ; /* Force User Bank */
    UNDEF_LSMUserBankWb ;
d3669 1
a3669 1
 for (temp = 0 ; !BIT(temp) ; temp++) ; /* N cycle first */
d3671 1
a3671 1
 ARMul_StoreWordN(state,address,state->Reg[temp++]) ;
d3673 19
a3691 28
 if (state->Aborted) {
    (void)ARMul_LoadWordN(state,address) ;
    for ( ; temp < 16 ; temp++) /* Fake the Stores as Loads */
       if (BIT(temp)) { /* save this register */
          address += 4 ;
          (void)ARMul_LoadWordS(state,address) ;
          }
    if (BIT(21) && LHSReg != 15)
       LSBase = WBBase ;
    TAKEABORT ;
    return ;
    }
 else
    ARMul_StoreWordN(state,address,state->Reg[temp++]) ;
#endif
 if (state->abortSig && !state->Aborted)
    state->Aborted = ARMul_DataAbortV ;

 if (BIT(21) && LHSReg != 15)
    LSBase = WBBase ;

 for (; temp < 16 ; temp++) /* S cycles from here on */
    if (BIT(temp)) { /* save this register */
       address += 4 ;
       ARMul_StoreWordS(state,address,state->Reg[temp]) ;
       if (state->abortSig && !state->Aborted)
             state->Aborted = ARMul_DataAbortV ;
       }
d3693 2
a3694 2
 if (state->Mode != USER26MODE && state->Mode != USER32MODE)
    (void)ARMul_SwitchMode(state,USER26MODE,state->Mode) ; /* restore the correct bank */
d3696 15
a3710 2
 if (state->Aborted) {
    TAKEABORT ;
d3719 2
a3720 1
static ARMword Add32(ARMword a1,ARMword a2,int *carry)
d3723 2
a3724 2
  unsigned int uresult = (unsigned int)result;
  unsigned int ua1 = (unsigned int)a1;
d3729 1
a3729 1
   *carry = 1;
d3731 1
a3731 1
   *carry = 0;
d3733 1
a3733 1
  return(result);
d3741 2
a3742 1
static unsigned Multiply64(ARMul_State *state,ARMword instr,int msigned,int scc)
d3744 8
a3751 8
  int nRdHi, nRdLo, nRs, nRm; /* operand register numbers */
  ARMword RdHi, RdLo, Rm;
  int scount; /* cycle count */

  nRdHi = BITS(16,19);
  nRdLo = BITS(12,15);
  nRs = BITS(8,11);
  nRm = BITS(0,3);
d3757 1
a3757 1
  if (   nRdHi != 15
d3759 2
a3760 5
      && nRs   != 15
      && nRm   != 15
      && nRdHi != nRdLo
      && nRdHi != nRm
      && nRdLo != nRm)
d3762 1
a3762 1
      ARMword lo, mid1, mid2, hi; /* intermediate results */
d3764 1
a3764 1
      ARMword Rs = state->Reg[ nRs ];
d3770 1
a3770 1
	  
d3772 2
a3773 2
	  
	  if (((signed long)Rm) < 0)
d3775 2
a3776 2
	  
	  if (((signed long)Rs) < 0)
d3779 1
a3779 1
      
d3781 2
a3782 2
	 that we do not lose precision on 32bit only hosts: */
      lo =   ((Rs & 0xFFFF) * (Rm & 0xFFFF));
d3785 2
a3786 2
      hi =   (((Rs >> 16) & 0xFFFF) * ((Rm >> 16) & 0xFFFF));
      
d3788 2
a3789 2
	 to propogate the carries from the additions: */
      RdLo = Add32(lo,(mid1 << 16),&carry);
d3791 3
a3793 2
      RdLo = Add32(RdLo,(mid2 << 16),&carry);
      RdHi += (carry + ((mid1 >> 16) & 0xFFFF) + ((mid2 >> 16) & 0xFFFF) + hi);
d3798 3
a3800 3
	  
	  RdLo = ~ RdLo;
	  RdHi = ~ RdHi;
d3809 1
a3809 1
      
d3812 4
a3815 4
      
    } /* else undefined result */
  else fprintf (stderr, "MULTIPLY64 - INVALID ARGUMENTS\n");
  
d3819 1
a3819 1
	ARMul_NegZero(state,RdHi); /* zero value */
d3821 1
a3821 1
	ARMul_NegZero(state,scc); /* non-zero value */
d3823 1
a3823 1
  
d3826 3
a3828 3
  if (msigned && (Rm & ((unsigned)1 << 31)))
    Rm = ~Rm; /* invert the bits to make the check against zero */
  
d3830 1
a3830 1
    scount = 1 ;
d3832 1
a3832 1
    scount = 2 ;
d3834 1
a3834 1
    scount = 3 ;
d3836 3
a3838 3
    scount = 4 ;
  
  return 2 + scount ;
d3846 2
a3847 1
static unsigned MultiplyAdd64(ARMul_State *state,ARMword instr,int msigned,int scc)
d3854 2
a3855 2
  nRdHi = BITS(16,19);
  nRdLo = BITS(12,15);
d3857 2
a3858 2
  RdHi = state->Reg[nRdHi] ;
  RdLo = state->Reg[nRdLo] ;
d3860 1
a3860 1
  scount = Multiply64(state,instr,msigned,LDEFAULT);
d3862 1
a3862 1
  RdLo = Add32(RdLo,state->Reg[nRdLo],&carry);
d3868 7
a3874 6
  if (scc) {
    if ((RdHi == 0) && (RdLo == 0))
     ARMul_NegZero(state,RdHi); /* zero value */
    else
     ARMul_NegZero(state,scc); /* non-zero value */
  }
d3876 1
a3876 1
  return scount + 1; /* extra cycle for addition */
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a20 1
#include "armos.h"
a45 13
#ifdef NEED_UI_LOOP_HOOK
/* How often to run the ui_loop update, when in use */
#define UI_LOOP_POLL_INTERVAL 0x32000

/* Counter for the ui_loop_hook update */
static long ui_loop_hook_counter = UI_LOOP_POLL_INTERVAL;

/* Actual hook to call to run through gdb's gui event loop */
extern int (*ui_loop_hook) (int);
#endif /* NEED_UI_LOOP_HOOK */

extern int stop_simulator;

d2169 4
a2172 14
             if (BIT(4))
	       {
		 /* Check for the special breakpoint opcode.
		    This value should correspond to the value defined
		    as ARM_BE_BREAKPOINT in gdb/arm-tdep.c.  */
		 if (BITS (0,19) == 0xfdefe)
		   {
		     if (! ARMul_OSHandleSWI (state, SWI_Breakpoint))
		       ARMul_Abort (state, ARMul_SWIV);
		   }
		 else
		   ARMul_UndefInstr(state,instr) ;
		 break ;
	       }
a2551 8
#ifdef NEED_UI_LOOP_HOOK
    if (ui_loop_hook != NULL && ui_loop_hook_counter-- < 0)
      {
	ui_loop_hook_counter = UI_LOOP_POLL_INTERVAL;
	ui_loop_hook (0);
      }
#endif /* NEED_UI_LOOP_HOOK */

d2556 1
a2556 1
    } while (!stop_simulator) ; /* do loop */
@


1.1.1.3
log
@import gdb-1999-07-12 snapshot
@
text
@a466 1
      
a879 1
	 
@


1.1.1.4
log
@import gdb-1999-12-06 snapshot
@
text
@d881 1
d2413 2
a2414 2
          case 0xc4 :
          case 0xc0 : /* Store , No WriteBack , Post Dec */
d2418 2
a2419 2
          case 0xc5 :
          case 0xc1 : /* Load , No WriteBack , Post Dec */
d2514 1
a2514 2
       case 0xe2 :
          case 0xe0 : case 0xe4 : case 0xe6 :
@


1.1.1.5
log
@import gdb-2000-02-04 snapshot
@
text
@d23 23
a45 35
static ARMword GetDPRegRHS (ARMul_State * state, ARMword instr);
static ARMword GetDPSRegRHS (ARMul_State * state, ARMword instr);
static void WriteR15 (ARMul_State * state, ARMword src);
static void WriteSR15 (ARMul_State * state, ARMword src);
static ARMword GetLSRegRHS (ARMul_State * state, ARMword instr);
static ARMword GetLS7RHS (ARMul_State * state, ARMword instr);
static unsigned LoadWord (ARMul_State * state, ARMword instr,
			  ARMword address);
static unsigned LoadHalfWord (ARMul_State * state, ARMword instr,
			      ARMword address, int signextend);
static unsigned LoadByte (ARMul_State * state, ARMword instr, ARMword address,
			  int signextend);
static unsigned StoreWord (ARMul_State * state, ARMword instr,
			   ARMword address);
static unsigned StoreHalfWord (ARMul_State * state, ARMword instr,
			       ARMword address);
static unsigned StoreByte (ARMul_State * state, ARMword instr,
			   ARMword address);
static void LoadMult (ARMul_State * state, ARMword address, ARMword instr,
		      ARMword WBBase);
static void StoreMult (ARMul_State * state, ARMword address, ARMword instr,
		       ARMword WBBase);
static void LoadSMult (ARMul_State * state, ARMword address, ARMword instr,
		       ARMword WBBase);
static void StoreSMult (ARMul_State * state, ARMword address, ARMword instr,
			ARMword WBBase);
static unsigned Multiply64 (ARMul_State * state, ARMword instr,
			    int signextend, int scc);
static unsigned MultiplyAdd64 (ARMul_State * state, ARMword instr,
			       int signextend, int scc);

#define LUNSIGNED (0)		/* unsigned operation */
#define LSIGNED   (1)		/* signed operation */
#define LDEFAULT  (0)		/* default : do nothing */
#define LSCC      (1)		/* set condition codes on result */
d88 1
a88 1
  (void)StoreHalfWord(state, instr, LHS + GetLS7RHS(state, instr)) ;
d261 1
a261 2
ARMword
ARMul_Emulate32 (register ARMul_State * state)
d264 1
a264 2
ARMword
ARMul_Emulate26 (register ARMul_State * state)
d267 6
a272 6
  register ARMword instr,	/* the current instruction */
    dest,			/* almost the DestBus */
    temp,			/* ubiquitous third hand */
    pc;				/* the address of the current instruction */
  ARMword lhs, rhs;		/* almost the ABus and BBus */
  ARMword decoded, loaded;	/* instruction pipeline */
d278 46
a323 6
  if (state->NextInstr < PRIMEPIPE)
    {
      decoded = state->decoded;
      loaded = state->loaded;
      pc = state->pc;
    }
d325 2
a326 47
  do
    {				/* just keep going */
#ifdef MODET
      if (TFLAG)
	{
	  isize = 2;
	}
      else
#endif
	isize = 4;
      switch (state->NextInstr)
	{
	case SEQ:
	  state->Reg[15] += isize;	/* Advance the pipeline, and an S cycle */
	  pc += isize;
	  instr = decoded;
	  decoded = loaded;
	  loaded = ARMul_LoadInstrS (state, pc + (isize * 2), isize);
	  break;

	case NONSEQ:
	  state->Reg[15] += isize;	/* Advance the pipeline, and an N cycle */
	  pc += isize;
	  instr = decoded;
	  decoded = loaded;
	  loaded = ARMul_LoadInstrN (state, pc + (isize * 2), isize);
	  NORMALCYCLE;
	  break;

	case PCINCEDSEQ:
	  pc += isize;		/* Program counter advanced, and an S cycle */
	  instr = decoded;
	  decoded = loaded;
	  loaded = ARMul_LoadInstrS (state, pc + (isize * 2), isize);
	  NORMALCYCLE;
	  break;

	case PCINCEDNONSEQ:
	  pc += isize;		/* Program counter advanced, and an N cycle */
	  instr = decoded;
	  decoded = loaded;
	  loaded = ARMul_LoadInstrN (state, pc + (isize * 2), isize);
	  NORMALCYCLE;
	  break;

	case RESUME:		/* The program counter has been changed */
	  pc = state->Reg[15];
d328 1
a328 1
	  pc = pc & R15PCBITS;
d330 7
a336 7
	  state->Reg[15] = pc + (isize * 2);
	  state->Aborted = 0;
	  instr = ARMul_ReLoadInstr (state, pc, isize);
	  decoded = ARMul_ReLoadInstr (state, pc + isize, isize);
	  loaded = ARMul_ReLoadInstr (state, pc + isize * 2, isize);
	  NORMALCYCLE;
	  break;
d338 2
a339 2
	default:		/* The program counter has been changed */
	  pc = state->Reg[15];
d341 1
a341 1
	  pc = pc & R15PCBITS;
d343 11
a353 11
	  state->Reg[15] = pc + (isize * 2);
	  state->Aborted = 0;
	  instr = ARMul_LoadInstrN (state, pc, isize);
	  decoded = ARMul_LoadInstrS (state, pc + (isize), isize);
	  loaded = ARMul_LoadInstrS (state, pc + (isize * 2), isize);
	  NORMALCYCLE;
	  break;
	}
      if (state->EventSet)
	ARMul_EnvokeEvent (state);

d355 62
a416 73
      /* Enable this for a helpful bit of debugging when tracing is needed.  */
      fprintf (stderr, "pc: %x, instr: %x\n", pc & ~1, instr);
      if (instr == 0)
	abort ();
#endif

      if (state->Exception)
	{			/* Any exceptions */
	  if (state->NresetSig == LOW)
	    {
	      ARMul_Abort (state, ARMul_ResetV);
	      break;
	    }
	  else if (!state->NfiqSig && !FFLAG)
	    {
	      ARMul_Abort (state, ARMul_FIQV);
	      break;
	    }
	  else if (!state->NirqSig && !IFLAG)
	    {
	      ARMul_Abort (state, ARMul_IRQV);
	      break;
	    }
	}

      if (state->CallDebug > 0)
	{
	  instr = ARMul_Debug (state, pc, instr);
	  if (state->Emulate < ONCE)
	    {
	      state->NextInstr = RESUME;
	      break;
	    }
	  if (state->Debug)
	    {
	      fprintf (stderr, "At %08lx Instr %08lx Mode %02lx\n", pc, instr,
		       state->Mode);
	      (void) fgetc (stdin);
	    }
	}
      else if (state->Emulate < ONCE)
	{
	  state->NextInstr = RESUME;
	  break;
	}

      state->NumInstrs++;

#ifdef MODET
      /* Provide Thumb instruction decoding. If the processor is in Thumb
         mode, then we can simply decode the Thumb instruction, and map it
         to the corresponding ARM instruction (by directly loading the
         instr variable, and letting the normal ARM simulator
         execute). There are some caveats to ensure that the correct
         pipelined PC value is used when executing Thumb code, and also for
         dealing with the BL instruction. */
      if (TFLAG)
	{			/* check if in Thumb mode */
	  ARMword new;
	  switch (ARMul_ThumbDecode (state, pc, instr, &new))
	    {
	    case t_undefined:
	      ARMul_UndefInstr (state, instr);	/* This is a Thumb instruction */
	      break;

	    case t_branch:	/* already processed */
	      goto donext;

	    case t_decoded:	/* ARM instruction available */
	      instr = new;	/* so continue instruction decoding */
	      break;
	    }
	}
d422 2
a423 2
      if ((temp = TOPBITS (28)) == AL)
	goto mainswitch;	/* vile deed in the need for speed */
d425 34
a458 51
      switch ((int) TOPBITS (28))
	{			/* check the condition code */
	case AL:
	  temp = TRUE;
	  break;
	case NV:
	  temp = FALSE;
	  break;
	case EQ:
	  temp = ZFLAG;
	  break;
	case NE:
	  temp = !ZFLAG;
	  break;
	case VS:
	  temp = VFLAG;
	  break;
	case VC:
	  temp = !VFLAG;
	  break;
	case MI:
	  temp = NFLAG;
	  break;
	case PL:
	  temp = !NFLAG;
	  break;
	case CS:
	  temp = CFLAG;
	  break;
	case CC:
	  temp = !CFLAG;
	  break;
	case HI:
	  temp = (CFLAG && !ZFLAG);
	  break;
	case LS:
	  temp = (!CFLAG || ZFLAG);
	  break;
	case GE:
	  temp = ((!NFLAG && !VFLAG) || (NFLAG && VFLAG));
	  break;
	case LT:
	  temp = ((NFLAG && !VFLAG) || (!NFLAG && VFLAG));
	  break;
	case GT:
	  temp = ((!NFLAG && !VFLAG && !ZFLAG) || (NFLAG && VFLAG && !ZFLAG));
	  break;
	case LE:
	  temp = ((NFLAG && !VFLAG) || (!NFLAG && VFLAG)) || ZFLAG;
	  break;
	}			/* cc check */
d464 2
a465 3
      if (temp)
	{			/* if the condition codes don't match, stop here */
	mainswitch:
d467 2
a468 3

	  switch ((int) BITS (20, 27))
	    {
d474 1
a474 1
	    case 0x00:		/* AND reg and MUL */
d476 416
a891 490
	      if (BITS (4, 11) == 0xB)
		{
		  /* STRH register offset, no write-back, down, post indexed */
		  SHDOWNWB ();
		  break;
		}
	      /* TODO: CHECK: should 0xD and 0xF generate undefined intruction aborts? */
#endif
	      if (BITS (4, 7) == 9)
		{		/* MUL */
		  rhs = state->Reg[MULRHSReg];
		  if (MULLHSReg == MULDESTReg)
		    {
		      UNDEF_MULDestEQOp1;
		      state->Reg[MULDESTReg] = 0;
		    }
		  else if (MULDESTReg != 15)
		    state->Reg[MULDESTReg] = state->Reg[MULLHSReg] * rhs;
		  else
		    {
		      UNDEF_MULPCDest;
		    }
		  for (dest = 0, temp = 0; dest < 32; dest++)
		    if (rhs & (1L << dest))
		      temp = dest;	/* mult takes this many/2 I cycles */
		  ARMul_Icycles (state, ARMul_MultTable[temp], 0L);
		}
	      else
		{		/* AND reg */
		  rhs = DPRegRHS;
		  dest = LHS & rhs;
		  WRITEDEST (dest);
		}
	      break;

	    case 0x01:		/* ANDS reg and MULS */
#ifdef MODET
	      if ((BITS (4, 11) & 0xF9) == 0x9)
		{
		  /* LDR register offset, no write-back, down, post indexed */
		  LHPOSTDOWN ();
		  /* fall through to rest of decoding */
		}
#endif
	      if (BITS (4, 7) == 9)
		{		/* MULS */
		  rhs = state->Reg[MULRHSReg];
		  if (MULLHSReg == MULDESTReg)
		    {
		      UNDEF_MULDestEQOp1;
		      state->Reg[MULDESTReg] = 0;
		      CLEARN;
		      SETZ;
		    }
		  else if (MULDESTReg != 15)
		    {
		      dest = state->Reg[MULLHSReg] * rhs;
		      ARMul_NegZero (state, dest);
		      state->Reg[MULDESTReg] = dest;
		    }
		  else
		    {
		      UNDEF_MULPCDest;
		    }
		  for (dest = 0, temp = 0; dest < 32; dest++)
		    if (rhs & (1L << dest))
		      temp = dest;	/* mult takes this many/2 I cycles */
		  ARMul_Icycles (state, ARMul_MultTable[temp], 0L);
		}
	      else
		{		/* ANDS reg */
		  rhs = DPSRegRHS;
		  dest = LHS & rhs;
		  WRITESDEST (dest);
		}
	      break;

	    case 0x02:		/* EOR reg and MLA */
#ifdef MODET
	      if (BITS (4, 11) == 0xB)
		{
		  /* STRH register offset, write-back, down, post indexed */
		  SHDOWNWB ();
		  break;
		}
#endif
	      if (BITS (4, 7) == 9)
		{		/* MLA */
		  rhs = state->Reg[MULRHSReg];
		  if (MULLHSReg == MULDESTReg)
		    {
		      UNDEF_MULDestEQOp1;
		      state->Reg[MULDESTReg] = state->Reg[MULACCReg];
		    }
		  else if (MULDESTReg != 15)
		    state->Reg[MULDESTReg] =
		      state->Reg[MULLHSReg] * rhs + state->Reg[MULACCReg];
		  else
		    {
		      UNDEF_MULPCDest;
		    }
		  for (dest = 0, temp = 0; dest < 32; dest++)
		    if (rhs & (1L << dest))
		      temp = dest;	/* mult takes this many/2 I cycles */
		  ARMul_Icycles (state, ARMul_MultTable[temp], 0L);
		}
	      else
		{
		  rhs = DPRegRHS;
		  dest = LHS ^ rhs;
		  WRITEDEST (dest);
		}
	      break;

	    case 0x03:		/* EORS reg and MLAS */
#ifdef MODET
	      if ((BITS (4, 11) & 0xF9) == 0x9)
		{
		  /* LDR register offset, write-back, down, post-indexed */
		  LHPOSTDOWN ();
		  /* fall through to rest of the decoding */
		}
#endif
	      if (BITS (4, 7) == 9)
		{		/* MLAS */
		  rhs = state->Reg[MULRHSReg];
		  if (MULLHSReg == MULDESTReg)
		    {
		      UNDEF_MULDestEQOp1;
		      dest = state->Reg[MULACCReg];
		      ARMul_NegZero (state, dest);
		      state->Reg[MULDESTReg] = dest;
		    }
		  else if (MULDESTReg != 15)
		    {
		      dest =
			state->Reg[MULLHSReg] * rhs + state->Reg[MULACCReg];
		      ARMul_NegZero (state, dest);
		      state->Reg[MULDESTReg] = dest;
		    }
		  else
		    {
		      UNDEF_MULPCDest;
		    }
		  for (dest = 0, temp = 0; dest < 32; dest++)
		    if (rhs & (1L << dest))
		      temp = dest;	/* mult takes this many/2 I cycles */
		  ARMul_Icycles (state, ARMul_MultTable[temp], 0L);
		}
	      else
		{		/* EORS Reg */
		  rhs = DPSRegRHS;
		  dest = LHS ^ rhs;
		  WRITESDEST (dest);
		}
	      break;

	    case 0x04:		/* SUB reg */
#ifdef MODET
	      if (BITS (4, 7) == 0xB)
		{
		  /* STRH immediate offset, no write-back, down, post indexed */
		  SHDOWNWB ();
		  break;
		}
#endif
	      rhs = DPRegRHS;
	      dest = LHS - rhs;
	      WRITEDEST (dest);
	      break;

	    case 0x05:		/* SUBS reg */
#ifdef MODET
	      if ((BITS (4, 7) & 0x9) == 0x9)
		{
		  /* LDR immediate offset, no write-back, down, post indexed */
		  LHPOSTDOWN ();
		  /* fall through to the rest of the instruction decoding */
		}
#endif
	      lhs = LHS;
	      rhs = DPRegRHS;
	      dest = lhs - rhs;
	      if ((lhs >= rhs) || ((rhs | lhs) >> 31))
		{
		  ARMul_SubCarry (state, lhs, rhs, dest);
		  ARMul_SubOverflow (state, lhs, rhs, dest);
		}
	      else
		{
		  CLEARC;
		  CLEARV;
		}
	      WRITESDEST (dest);
	      break;

	    case 0x06:		/* RSB reg */
#ifdef MODET
	      if (BITS (4, 7) == 0xB)
		{
		  /* STRH immediate offset, write-back, down, post indexed */
		  SHDOWNWB ();
		  break;
		}
#endif
	      rhs = DPRegRHS;
	      dest = rhs - LHS;
	      WRITEDEST (dest);
	      break;

	    case 0x07:		/* RSBS reg */
#ifdef MODET
	      if ((BITS (4, 7) & 0x9) == 0x9)
		{
		  /* LDR immediate offset, write-back, down, post indexed */
		  LHPOSTDOWN ();
		  /* fall through to remainder of instruction decoding */
		}
#endif
	      lhs = LHS;
	      rhs = DPRegRHS;
	      dest = rhs - lhs;
	      if ((rhs >= lhs) || ((rhs | lhs) >> 31))
		{
		  ARMul_SubCarry (state, rhs, lhs, dest);
		  ARMul_SubOverflow (state, rhs, lhs, dest);
		}
	      else
		{
		  CLEARC;
		  CLEARV;
		}
	      WRITESDEST (dest);
	      break;

	    case 0x08:		/* ADD reg */
#ifdef MODET
	      if (BITS (4, 11) == 0xB)
		{
		  /* STRH register offset, no write-back, up, post indexed */
		  SHUPWB ();
		  break;
		}
#endif
#ifdef MODET
	      if (BITS (4, 7) == 0x9)
		{		/* MULL */
		  /* 32x32 = 64 */
		  ARMul_Icycles (state,
				 Multiply64 (state, instr, LUNSIGNED,
					     LDEFAULT), 0L);
		  break;
		}
#endif
	      rhs = DPRegRHS;
	      dest = LHS + rhs;
	      WRITEDEST (dest);
	      break;

	    case 0x09:		/* ADDS reg */
#ifdef MODET
	      if ((BITS (4, 11) & 0xF9) == 0x9)
		{
		  /* LDR register offset, no write-back, up, post indexed */
		  LHPOSTUP ();
		  /* fall through to remaining instruction decoding */
		}
#endif
#ifdef MODET
	      if (BITS (4, 7) == 0x9)
		{		/* MULL */
		  /* 32x32=64 */
		  ARMul_Icycles (state,
				 Multiply64 (state, instr, LUNSIGNED, LSCC),
				 0L);
		  break;
		}
#endif
	      lhs = LHS;
	      rhs = DPRegRHS;
	      dest = lhs + rhs;
	      ASSIGNZ (dest == 0);
	      if ((lhs | rhs) >> 30)
		{		/* possible C,V,N to set */
		  ASSIGNN (NEG (dest));
		  ARMul_AddCarry (state, lhs, rhs, dest);
		  ARMul_AddOverflow (state, lhs, rhs, dest);
		}
	      else
		{
		  CLEARN;
		  CLEARC;
		  CLEARV;
		}
	      WRITESDEST (dest);
	      break;

	    case 0x0a:		/* ADC reg */
#ifdef MODET
	      if (BITS (4, 11) == 0xB)
		{
		  /* STRH register offset, write-back, up, post-indexed */
		  SHUPWB ();
		  break;
		}
#endif
#ifdef MODET
	      if (BITS (4, 7) == 0x9)
		{		/* MULL */
		  /* 32x32=64 */
		  ARMul_Icycles (state,
				 MultiplyAdd64 (state, instr, LUNSIGNED,
						LDEFAULT), 0L);
		  break;
		}
#endif
	      rhs = DPRegRHS;
	      dest = LHS + rhs + CFLAG;
	      WRITEDEST (dest);
	      break;

	    case 0x0b:		/* ADCS reg */
#ifdef MODET
	      if ((BITS (4, 11) & 0xF9) == 0x9)
		{
		  /* LDR register offset, write-back, up, post indexed */
		  LHPOSTUP ();
		  /* fall through to remaining instruction decoding */
		}
#endif
#ifdef MODET
	      if (BITS (4, 7) == 0x9)
		{		/* MULL */
		  /* 32x32=64 */
		  ARMul_Icycles (state,
				 MultiplyAdd64 (state, instr, LUNSIGNED,
						LSCC), 0L);
		  break;
		}
#endif
	      lhs = LHS;
	      rhs = DPRegRHS;
	      dest = lhs + rhs + CFLAG;
	      ASSIGNZ (dest == 0);
	      if ((lhs | rhs) >> 30)
		{		/* possible C,V,N to set */
		  ASSIGNN (NEG (dest));
		  ARMul_AddCarry (state, lhs, rhs, dest);
		  ARMul_AddOverflow (state, lhs, rhs, dest);
		}
	      else
		{
		  CLEARN;
		  CLEARC;
		  CLEARV;
		}
	      WRITESDEST (dest);
	      break;

	    case 0x0c:		/* SBC reg */
#ifdef MODET
	      if (BITS (4, 7) == 0xB)
		{
		  /* STRH immediate offset, no write-back, up post indexed */
		  SHUPWB ();
		  break;
		}
#endif
#ifdef MODET
	      if (BITS (4, 7) == 0x9)
		{		/* MULL */
		  /* 32x32=64 */
		  ARMul_Icycles (state,
				 Multiply64 (state, instr, LSIGNED, LDEFAULT),
				 0L);
		  break;
		}
#endif
	      rhs = DPRegRHS;
	      dest = LHS - rhs - !CFLAG;
	      WRITEDEST (dest);
	      break;

	    case 0x0d:		/* SBCS reg */
#ifdef MODET
	      if ((BITS (4, 7) & 0x9) == 0x9)
		{
		  /* LDR immediate offset, no write-back, up, post indexed */
		  LHPOSTUP ();
		}
#endif
#ifdef MODET
	      if (BITS (4, 7) == 0x9)
		{		/* MULL */
		  /* 32x32=64 */
		  ARMul_Icycles (state,
				 Multiply64 (state, instr, LSIGNED, LSCC),
				 0L);
		  break;
		}
#endif
	      lhs = LHS;
	      rhs = DPRegRHS;
	      dest = lhs - rhs - !CFLAG;
	      if ((lhs >= rhs) || ((rhs | lhs) >> 31))
		{
		  ARMul_SubCarry (state, lhs, rhs, dest);
		  ARMul_SubOverflow (state, lhs, rhs, dest);
		}
	      else
		{
		  CLEARC;
		  CLEARV;
		}
	      WRITESDEST (dest);
	      break;

	    case 0x0e:		/* RSC reg */
#ifdef MODET
	      if (BITS (4, 7) == 0xB)
		{
		  /* STRH immediate offset, write-back, up, post indexed */
		  SHUPWB ();
		  break;
		}
#endif
#ifdef MODET
	      if (BITS (4, 7) == 0x9)
		{		/* MULL */
		  /* 32x32=64 */
		  ARMul_Icycles (state,
				 MultiplyAdd64 (state, instr, LSIGNED,
						LDEFAULT), 0L);
		  break;
		}
#endif
	      rhs = DPRegRHS;
	      dest = rhs - LHS - !CFLAG;
	      WRITEDEST (dest);
	      break;

	    case 0x0f:		/* RSCS reg */
#ifdef MODET
	      if ((BITS (4, 7) & 0x9) == 0x9)
		{
		  /* LDR immediate offset, write-back, up, post indexed */
		  LHPOSTUP ();
		  /* fall through to remaining instruction decoding */
		}
#endif
#ifdef MODET
	      if (BITS (4, 7) == 0x9)
		{		/* MULL */
		  /* 32x32=64 */
		  ARMul_Icycles (state,
				 MultiplyAdd64 (state, instr, LSIGNED, LSCC),
				 0L);
		  break;
		}
#endif
	      lhs = LHS;
	      rhs = DPRegRHS;
	      dest = rhs - lhs - !CFLAG;
	      if ((rhs >= lhs) || ((rhs | lhs) >> 31))
		{
		  ARMul_SubCarry (state, rhs, lhs, dest);
		  ARMul_SubOverflow (state, rhs, lhs, dest);
		}
	      else
		{
		  CLEARC;
		  CLEARV;
		}
	      WRITESDEST (dest);
	      break;

	    case 0x10:		/* TST reg and MRS CPSR and SWP word */
#ifdef MODET
	      if (BITS (4, 11) == 0xB)
		{
		  /* STRH register offset, no write-back, down, pre indexed */
		  SHPREDOWN ();
		  break;
		}
#endif
	      if (BITS (4, 11) == 9)
		{		/* SWP */
		  UNDEF_SWPPC;
		  temp = LHS;
		  BUSUSEDINCPCS;
d893 32
a924 37
		  if (VECTORACCESS (temp) || ADDREXCEPT (temp))
		    {
		      INTERNALABORT (temp);
		      (void) ARMul_LoadWordN (state, temp);
		      (void) ARMul_LoadWordN (state, temp);
		    }
		  else
#endif
		    dest = ARMul_SwapWord (state, temp, state->Reg[RHSReg]);
		  if (temp & 3)
		    DEST = ARMul_Align (state, temp, dest);
		  else
		    DEST = dest;
		  if (state->abortSig || state->Aborted)
		    {
		      TAKEABORT;
		    }
		}
	      else if ((BITS (0, 11) == 0) && (LHSReg == 15))
		{		/* MRS CPSR */
		  UNDEF_MRSPC;
		  DEST = ECC | EINT | EMODE;
		}
	      else
		{
		  UNDEF_Test;
		}
	      break;

	    case 0x11:		/* TSTP reg */
#ifdef MODET
	      if ((BITS (4, 11) & 0xF9) == 0x9)
		{
		  /* LDR register offset, no write-back, down, pre indexed */
		  LHPREDOWN ();
		  /* continue with remaining instruction decode */
		}
d926 1
a926 2
	      if (DESTReg == 15)
		{		/* TSTP reg */
d928 2
a929 2
		  state->Cpsr = GETSPSR (state->Bank);
		  ARMul_CPSRAltered (state);
d931 66
a996 76
		  rhs = DPRegRHS;
		  temp = LHS & rhs;
		  SETR15PSR (temp);
#endif
		}
	      else
		{		/* TST reg */
		  rhs = DPSRegRHS;
		  dest = LHS & rhs;
		  ARMul_NegZero (state, dest);
		}
	      break;

	    case 0x12:		/* TEQ reg and MSR reg to CPSR (ARM6) */
#ifdef MODET
	      if (BITS (4, 11) == 0xB)
		{
		  /* STRH register offset, write-back, down, pre indexed */
		  SHPREDOWNWB ();
		  break;
		}
#endif
#ifdef MODET
	      if (BITS (4, 27) == 0x12FFF1)
		{		/* BX */
		  /* Branch to the address in RHSReg. If bit0 of
		     destination address is 1 then switch to Thumb mode: */
		  ARMword addr = state->Reg[RHSReg];

		  /* If we read the PC then the bottom bit is clear */
		  if (RHSReg == 15)
		    addr &= ~1;

		  /* Enable this for a helpful bit of debugging when
		     GDB is not yet fully working... 
		     fprintf (stderr, "BX at %x to %x (go %s)\n",
		     state->Reg[15], addr, (addr & 1) ? "thumb": "arm" ); */

		  if (addr & (1 << 0))
		    {		/* Thumb bit */
		      SETT;
		      state->Reg[15] = addr & 0xfffffffe;
		      /* NOTE: The other CPSR flag setting blocks do not
		         seem to update the state->Cpsr state, but just do
		         the explicit flag. The copy from the seperate
		         flags to the register must happen later. */
		      FLUSHPIPE;
		    }
		  else
		    {
		      CLEART;
		      state->Reg[15] = addr & 0xfffffffc;
		      FLUSHPIPE;
		    }
		}
#endif
	      if (DESTReg == 15 && BITS (17, 18) == 0)
		{		/* MSR reg to CPSR */
		  UNDEF_MSRPC;
		  temp = DPRegRHS;
		  ARMul_FixCPSR (state, instr, temp);
		}
	      else
		{
		  UNDEF_Test;
		}
	      break;

	    case 0x13:		/* TEQP reg */
#ifdef MODET
	      if ((BITS (4, 11) & 0xF9) == 0x9)
		{
		  /* LDR register offset, write-back, down, pre indexed */
		  LHPREDOWNWB ();
		  /* continue with remaining instruction decode */
		}
d998 1
a998 2
	      if (DESTReg == 15)
		{		/* TEQP reg */
d1000 2
a1001 2
		  state->Cpsr = GETSPSR (state->Bank);
		  ARMul_CPSRAltered (state);
d1003 24
a1026 27
		  rhs = DPRegRHS;
		  temp = LHS ^ rhs;
		  SETR15PSR (temp);
#endif
		}
	      else
		{		/* TEQ Reg */
		  rhs = DPSRegRHS;
		  dest = LHS ^ rhs;
		  ARMul_NegZero (state, dest);
		}
	      break;

	    case 0x14:		/* CMP reg and MRS SPSR and SWP byte */
#ifdef MODET
	      if (BITS (4, 7) == 0xB)
		{
		  /* STRH immediate offset, no write-back, down, pre indexed */
		  SHPREDOWN ();
		  break;
		}
#endif
	      if (BITS (4, 11) == 9)
		{		/* SWP */
		  UNDEF_SWPPC;
		  temp = LHS;
		  BUSUSEDINCPCS;
d1028 28
a1055 33
		  if (VECTORACCESS (temp) || ADDREXCEPT (temp))
		    {
		      INTERNALABORT (temp);
		      (void) ARMul_LoadByte (state, temp);
		      (void) ARMul_LoadByte (state, temp);
		    }
		  else
#endif
		    DEST = ARMul_SwapByte (state, temp, state->Reg[RHSReg]);
		  if (state->abortSig || state->Aborted)
		    {
		      TAKEABORT;
		    }
		}
	      else if ((BITS (0, 11) == 0) && (LHSReg == 15))
		{		/* MRS SPSR */
		  UNDEF_MRSPC;
		  DEST = GETSPSR (state->Bank);
		}
	      else
		{
		  UNDEF_Test;
		}
	      break;

	    case 0x15:		/* CMPP reg */
#ifdef MODET
	      if ((BITS (4, 7) & 0x9) == 0x9)
		{
		  /* LDR immediate offset, no write-back, down, pre indexed */
		  LHPREDOWN ();
		  /* continue with remaining instruction decode */
		}
d1057 1
a1057 2
	      if (DESTReg == 15)
		{		/* CMPP reg */
d1059 2
a1060 2
		  state->Cpsr = GETSPSR (state->Bank);
		  ARMul_CPSRAltered (state);
d1062 45
a1106 52
		  rhs = DPRegRHS;
		  temp = LHS - rhs;
		  SETR15PSR (temp);
#endif
		}
	      else
		{		/* CMP reg */
		  lhs = LHS;
		  rhs = DPRegRHS;
		  dest = lhs - rhs;
		  ARMul_NegZero (state, dest);
		  if ((lhs >= rhs) || ((rhs | lhs) >> 31))
		    {
		      ARMul_SubCarry (state, lhs, rhs, dest);
		      ARMul_SubOverflow (state, lhs, rhs, dest);
		    }
		  else
		    {
		      CLEARC;
		      CLEARV;
		    }
		}
	      break;

	    case 0x16:		/* CMN reg and MSR reg to SPSR */
#ifdef MODET
	      if (BITS (4, 7) == 0xB)
		{
		  /* STRH immediate offset, write-back, down, pre indexed */
		  SHPREDOWNWB ();
		  break;
		}
#endif
	      if (DESTReg == 15 && BITS (17, 18) == 0)
		{		/* MSR */
		  UNDEF_MSRPC;
		  ARMul_FixSPSR (state, instr, DPRegRHS);
		}
	      else
		{
		  UNDEF_Test;
		}
	      break;

	    case 0x17:		/* CMNP reg */
#ifdef MODET
	      if ((BITS (4, 7) & 0x9) == 0x9)
		{
		  /* LDR immediate offset, write-back, down, pre indexed */
		  LHPREDOWNWB ();
		  /* continue with remaining instruction decoding */
		}
d1108 1
a1108 2
	      if (DESTReg == 15)
		{
d1110 2
a1111 2
		  state->Cpsr = GETSPSR (state->Bank);
		  ARMul_CPSRAltered (state);
d1113 123
a1235 134
		  rhs = DPRegRHS;
		  temp = LHS + rhs;
		  SETR15PSR (temp);
#endif
		  break;
		}
	      else
		{		/* CMN reg */
		  lhs = LHS;
		  rhs = DPRegRHS;
		  dest = lhs + rhs;
		  ASSIGNZ (dest == 0);
		  if ((lhs | rhs) >> 30)
		    {		/* possible C,V,N to set */
		      ASSIGNN (NEG (dest));
		      ARMul_AddCarry (state, lhs, rhs, dest);
		      ARMul_AddOverflow (state, lhs, rhs, dest);
		    }
		  else
		    {
		      CLEARN;
		      CLEARC;
		      CLEARV;
		    }
		}
	      break;

	    case 0x18:		/* ORR reg */
#ifdef MODET
	      if (BITS (4, 11) == 0xB)
		{
		  /* STRH register offset, no write-back, up, pre indexed */
		  SHPREUP ();
		  break;
		}
#endif
	      rhs = DPRegRHS;
	      dest = LHS | rhs;
	      WRITEDEST (dest);
	      break;

	    case 0x19:		/* ORRS reg */
#ifdef MODET
	      if ((BITS (4, 11) & 0xF9) == 0x9)
		{
		  /* LDR register offset, no write-back, up, pre indexed */
		  LHPREUP ();
		  /* continue with remaining instruction decoding */
		}
#endif
	      rhs = DPSRegRHS;
	      dest = LHS | rhs;
	      WRITESDEST (dest);
	      break;

	    case 0x1a:		/* MOV reg */
#ifdef MODET
	      if (BITS (4, 11) == 0xB)
		{
		  /* STRH register offset, write-back, up, pre indexed */
		  SHPREUPWB ();
		  break;
		}
#endif
	      dest = DPRegRHS;
	      WRITEDEST (dest);
	      break;

	    case 0x1b:		/* MOVS reg */
#ifdef MODET
	      if ((BITS (4, 11) & 0xF9) == 0x9)
		{
		  /* LDR register offset, write-back, up, pre indexed */
		  LHPREUPWB ();
		  /* continue with remaining instruction decoding */
		}
#endif
	      dest = DPSRegRHS;
	      WRITESDEST (dest);
	      break;

	    case 0x1c:		/* BIC reg */
#ifdef MODET
	      if (BITS (4, 7) == 0xB)
		{
		  /* STRH immediate offset, no write-back, up, pre indexed */
		  SHPREUP ();
		  break;
		}
#endif
	      rhs = DPRegRHS;
	      dest = LHS & ~rhs;
	      WRITEDEST (dest);
	      break;

	    case 0x1d:		/* BICS reg */
#ifdef MODET
	      if ((BITS (4, 7) & 0x9) == 0x9)
		{
		  /* LDR immediate offset, no write-back, up, pre indexed */
		  LHPREUP ();
		  /* continue with instruction decoding */
		}
#endif
	      rhs = DPSRegRHS;
	      dest = LHS & ~rhs;
	      WRITESDEST (dest);
	      break;

	    case 0x1e:		/* MVN reg */
#ifdef MODET
	      if (BITS (4, 7) == 0xB)
		{
		  /* STRH immediate offset, write-back, up, pre indexed */
		  SHPREUPWB ();
		  break;
		}
#endif
	      dest = ~DPRegRHS;
	      WRITEDEST (dest);
	      break;

	    case 0x1f:		/* MVNS reg */
#ifdef MODET
	      if ((BITS (4, 7) & 0x9) == 0x9)
		{
		  /* LDR immediate offset, write-back, up, pre indexed */
		  LHPREUPWB ();
		  /* continue instruction decoding */
		}
#endif
	      dest = ~DPSRegRHS;
	      WRITESDEST (dest);
	      break;
d1241 154
a1394 167
	    case 0x20:		/* AND immed */
	      dest = LHS & DPImmRHS;
	      WRITEDEST (dest);
	      break;

	    case 0x21:		/* ANDS immed */
	      DPSImmRHS;
	      dest = LHS & rhs;
	      WRITESDEST (dest);
	      break;

	    case 0x22:		/* EOR immed */
	      dest = LHS ^ DPImmRHS;
	      WRITEDEST (dest);
	      break;

	    case 0x23:		/* EORS immed */
	      DPSImmRHS;
	      dest = LHS ^ rhs;
	      WRITESDEST (dest);
	      break;

	    case 0x24:		/* SUB immed */
	      dest = LHS - DPImmRHS;
	      WRITEDEST (dest);
	      break;

	    case 0x25:		/* SUBS immed */
	      lhs = LHS;
	      rhs = DPImmRHS;
	      dest = lhs - rhs;
	      if ((lhs >= rhs) || ((rhs | lhs) >> 31))
		{
		  ARMul_SubCarry (state, lhs, rhs, dest);
		  ARMul_SubOverflow (state, lhs, rhs, dest);
		}
	      else
		{
		  CLEARC;
		  CLEARV;
		}
	      WRITESDEST (dest);
	      break;

	    case 0x26:		/* RSB immed */
	      dest = DPImmRHS - LHS;
	      WRITEDEST (dest);
	      break;

	    case 0x27:		/* RSBS immed */
	      lhs = LHS;
	      rhs = DPImmRHS;
	      dest = rhs - lhs;
	      if ((rhs >= lhs) || ((rhs | lhs) >> 31))
		{
		  ARMul_SubCarry (state, rhs, lhs, dest);
		  ARMul_SubOverflow (state, rhs, lhs, dest);
		}
	      else
		{
		  CLEARC;
		  CLEARV;
		}
	      WRITESDEST (dest);
	      break;

	    case 0x28:		/* ADD immed */
	      dest = LHS + DPImmRHS;
	      WRITEDEST (dest);
	      break;

	    case 0x29:		/* ADDS immed */
	      lhs = LHS;
	      rhs = DPImmRHS;
	      dest = lhs + rhs;
	      ASSIGNZ (dest == 0);
	      if ((lhs | rhs) >> 30)
		{		/* possible C,V,N to set */
		  ASSIGNN (NEG (dest));
		  ARMul_AddCarry (state, lhs, rhs, dest);
		  ARMul_AddOverflow (state, lhs, rhs, dest);
		}
	      else
		{
		  CLEARN;
		  CLEARC;
		  CLEARV;
		}
	      WRITESDEST (dest);
	      break;

	    case 0x2a:		/* ADC immed */
	      dest = LHS + DPImmRHS + CFLAG;
	      WRITEDEST (dest);
	      break;

	    case 0x2b:		/* ADCS immed */
	      lhs = LHS;
	      rhs = DPImmRHS;
	      dest = lhs + rhs + CFLAG;
	      ASSIGNZ (dest == 0);
	      if ((lhs | rhs) >> 30)
		{		/* possible C,V,N to set */
		  ASSIGNN (NEG (dest));
		  ARMul_AddCarry (state, lhs, rhs, dest);
		  ARMul_AddOverflow (state, lhs, rhs, dest);
		}
	      else
		{
		  CLEARN;
		  CLEARC;
		  CLEARV;
		}
	      WRITESDEST (dest);
	      break;

	    case 0x2c:		/* SBC immed */
	      dest = LHS - DPImmRHS - !CFLAG;
	      WRITEDEST (dest);
	      break;

	    case 0x2d:		/* SBCS immed */
	      lhs = LHS;
	      rhs = DPImmRHS;
	      dest = lhs - rhs - !CFLAG;
	      if ((lhs >= rhs) || ((rhs | lhs) >> 31))
		{
		  ARMul_SubCarry (state, lhs, rhs, dest);
		  ARMul_SubOverflow (state, lhs, rhs, dest);
		}
	      else
		{
		  CLEARC;
		  CLEARV;
		}
	      WRITESDEST (dest);
	      break;

	    case 0x2e:		/* RSC immed */
	      dest = DPImmRHS - LHS - !CFLAG;
	      WRITEDEST (dest);
	      break;

	    case 0x2f:		/* RSCS immed */
	      lhs = LHS;
	      rhs = DPImmRHS;
	      dest = rhs - lhs - !CFLAG;
	      if ((rhs >= lhs) || ((rhs | lhs) >> 31))
		{
		  ARMul_SubCarry (state, rhs, lhs, dest);
		  ARMul_SubOverflow (state, rhs, lhs, dest);
		}
	      else
		{
		  CLEARC;
		  CLEARV;
		}
	      WRITESDEST (dest);
	      break;

	    case 0x30:		/* TST immed */
	      UNDEF_Test;
	      break;

	    case 0x31:		/* TSTP immed */
	      if (DESTReg == 15)
		{		/* TSTP immed */
d1396 2
a1397 2
		  state->Cpsr = GETSPSR (state->Bank);
		  ARMul_CPSRAltered (state);
d1399 2
a1400 2
		  temp = LHS & DPImmRHS;
		  SETR15PSR (temp);
d1402 19
a1420 23
		}
	      else
		{
		  DPSImmRHS;	/* TST immed */
		  dest = LHS & rhs;
		  ARMul_NegZero (state, dest);
		}
	      break;

	    case 0x32:		/* TEQ immed and MSR immed to CPSR */
	      if (DESTReg == 15 && BITS (17, 18) == 0)
		{		/* MSR immed to CPSR */
		  ARMul_FixCPSR (state, instr, DPImmRHS);
		}
	      else
		{
		  UNDEF_Test;
		}
	      break;

	    case 0x33:		/* TEQP immed */
	      if (DESTReg == 15)
		{		/* TEQP immed */
d1422 2
a1423 2
		  state->Cpsr = GETSPSR (state->Bank);
		  ARMul_CPSRAltered (state);
d1425 2
a1426 2
		  temp = LHS ^ DPImmRHS;
		  SETR15PSR (temp);
d1428 14
a1441 16
		}
	      else
		{
		  DPSImmRHS;	/* TEQ immed */
		  dest = LHS ^ rhs;
		  ARMul_NegZero (state, dest);
		}
	      break;

	    case 0x34:		/* CMP immed */
	      UNDEF_Test;
	      break;

	    case 0x35:		/* CMPP immed */
	      if (DESTReg == 15)
		{		/* CMPP immed */
d1443 2
a1444 2
		  state->Cpsr = GETSPSR (state->Bank);
		  ARMul_CPSRAltered (state);
d1446 2
a1447 2
		  temp = LHS - DPImmRHS;
		  SETR15PSR (temp);
d1449 28
a1476 33
		  break;
		}
	      else
		{
		  lhs = LHS;	/* CMP immed */
		  rhs = DPImmRHS;
		  dest = lhs - rhs;
		  ARMul_NegZero (state, dest);
		  if ((lhs >= rhs) || ((rhs | lhs) >> 31))
		    {
		      ARMul_SubCarry (state, lhs, rhs, dest);
		      ARMul_SubOverflow (state, lhs, rhs, dest);
		    }
		  else
		    {
		      CLEARC;
		      CLEARV;
		    }
		}
	      break;

	    case 0x36:		/* CMN immed and MSR immed to SPSR */
	      if (DESTReg == 15 && BITS (17, 18) == 0)	/* MSR */
		ARMul_FixSPSR (state, instr, DPImmRHS);
	      else
		{
		  UNDEF_Test;
		}
	      break;

	    case 0x37:		/* CMNP immed */
	      if (DESTReg == 15)
		{		/* CMNP immed */
d1478 2
a1479 2
		  state->Cpsr = GETSPSR (state->Bank);
		  ARMul_CPSRAltered (state);
d1481 2
a1482 2
		  temp = LHS + DPImmRHS;
		  SETR15PSR (temp);
d1484 61
a1544 64
		  break;
		}
	      else
		{
		  lhs = LHS;	/* CMN immed */
		  rhs = DPImmRHS;
		  dest = lhs + rhs;
		  ASSIGNZ (dest == 0);
		  if ((lhs | rhs) >> 30)
		    {		/* possible C,V,N to set */
		      ASSIGNN (NEG (dest));
		      ARMul_AddCarry (state, lhs, rhs, dest);
		      ARMul_AddOverflow (state, lhs, rhs, dest);
		    }
		  else
		    {
		      CLEARN;
		      CLEARC;
		      CLEARV;
		    }
		}
	      break;

	    case 0x38:		/* ORR immed */
	      dest = LHS | DPImmRHS;
	      WRITEDEST (dest);
	      break;

	    case 0x39:		/* ORRS immed */
	      DPSImmRHS;
	      dest = LHS | rhs;
	      WRITESDEST (dest);
	      break;

	    case 0x3a:		/* MOV immed */
	      dest = DPImmRHS;
	      WRITEDEST (dest);
	      break;

	    case 0x3b:		/* MOVS immed */
	      DPSImmRHS;
	      WRITESDEST (rhs);
	      break;

	    case 0x3c:		/* BIC immed */
	      dest = LHS & ~DPImmRHS;
	      WRITEDEST (dest);
	      break;

	    case 0x3d:		/* BICS immed */
	      DPSImmRHS;
	      dest = LHS & ~rhs;
	      WRITESDEST (dest);
	      break;

	    case 0x3e:		/* MVN immed */
	      dest = ~DPImmRHS;
	      WRITEDEST (dest);
	      break;

	    case 0x3f:		/* MVNS immed */
	      DPSImmRHS;
	      WRITESDEST (~rhs);
	      break;
d1550 225
a1774 225
	    case 0x40:		/* Store Word, No WriteBack, Post Dec, Immed */
	      lhs = LHS;
	      if (StoreWord (state, instr, lhs))
		LSBase = lhs - LSImmRHS;
	      break;

	    case 0x41:		/* Load Word, No WriteBack, Post Dec, Immed */
	      lhs = LHS;
	      if (LoadWord (state, instr, lhs))
		LSBase = lhs - LSImmRHS;
	      break;

	    case 0x42:		/* Store Word, WriteBack, Post Dec, Immed */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      lhs = LHS;
	      temp = lhs - LSImmRHS;
	      state->NtransSig = LOW;
	      if (StoreWord (state, instr, lhs))
		LSBase = temp;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x43:		/* Load Word, WriteBack, Post Dec, Immed */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (LoadWord (state, instr, lhs))
		LSBase = lhs - LSImmRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x44:		/* Store Byte, No WriteBack, Post Dec, Immed */
	      lhs = LHS;
	      if (StoreByte (state, instr, lhs))
		LSBase = lhs - LSImmRHS;
	      break;

	    case 0x45:		/* Load Byte, No WriteBack, Post Dec, Immed */
	      lhs = LHS;
	      if (LoadByte (state, instr, lhs, LUNSIGNED))
		LSBase = lhs - LSImmRHS;
	      break;

	    case 0x46:		/* Store Byte, WriteBack, Post Dec, Immed */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (StoreByte (state, instr, lhs))
		LSBase = lhs - LSImmRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x47:		/* Load Byte, WriteBack, Post Dec, Immed */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (LoadByte (state, instr, lhs, LUNSIGNED))
		LSBase = lhs - LSImmRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x48:		/* Store Word, No WriteBack, Post Inc, Immed */
	      lhs = LHS;
	      if (StoreWord (state, instr, lhs))
		LSBase = lhs + LSImmRHS;
	      break;

	    case 0x49:		/* Load Word, No WriteBack, Post Inc, Immed */
	      lhs = LHS;
	      if (LoadWord (state, instr, lhs))
		LSBase = lhs + LSImmRHS;
	      break;

	    case 0x4a:		/* Store Word, WriteBack, Post Inc, Immed */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (StoreWord (state, instr, lhs))
		LSBase = lhs + LSImmRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x4b:		/* Load Word, WriteBack, Post Inc, Immed */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (LoadWord (state, instr, lhs))
		LSBase = lhs + LSImmRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x4c:		/* Store Byte, No WriteBack, Post Inc, Immed */
	      lhs = LHS;
	      if (StoreByte (state, instr, lhs))
		LSBase = lhs + LSImmRHS;
	      break;

	    case 0x4d:		/* Load Byte, No WriteBack, Post Inc, Immed */
	      lhs = LHS;
	      if (LoadByte (state, instr, lhs, LUNSIGNED))
		LSBase = lhs + LSImmRHS;
	      break;

	    case 0x4e:		/* Store Byte, WriteBack, Post Inc, Immed */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (StoreByte (state, instr, lhs))
		LSBase = lhs + LSImmRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x4f:		/* Load Byte, WriteBack, Post Inc, Immed */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (LoadByte (state, instr, lhs, LUNSIGNED))
		LSBase = lhs + LSImmRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;


	    case 0x50:		/* Store Word, No WriteBack, Pre Dec, Immed */
	      (void) StoreWord (state, instr, LHS - LSImmRHS);
	      break;

	    case 0x51:		/* Load Word, No WriteBack, Pre Dec, Immed */
	      (void) LoadWord (state, instr, LHS - LSImmRHS);
	      break;

	    case 0x52:		/* Store Word, WriteBack, Pre Dec, Immed */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      temp = LHS - LSImmRHS;
	      if (StoreWord (state, instr, temp))
		LSBase = temp;
	      break;

	    case 0x53:		/* Load Word, WriteBack, Pre Dec, Immed */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      temp = LHS - LSImmRHS;
	      if (LoadWord (state, instr, temp))
		LSBase = temp;
	      break;

	    case 0x54:		/* Store Byte, No WriteBack, Pre Dec, Immed */
	      (void) StoreByte (state, instr, LHS - LSImmRHS);
	      break;

	    case 0x55:		/* Load Byte, No WriteBack, Pre Dec, Immed */
	      (void) LoadByte (state, instr, LHS - LSImmRHS, LUNSIGNED);
	      break;

	    case 0x56:		/* Store Byte, WriteBack, Pre Dec, Immed */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      temp = LHS - LSImmRHS;
	      if (StoreByte (state, instr, temp))
		LSBase = temp;
	      break;

	    case 0x57:		/* Load Byte, WriteBack, Pre Dec, Immed */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      temp = LHS - LSImmRHS;
	      if (LoadByte (state, instr, temp, LUNSIGNED))
		LSBase = temp;
	      break;

	    case 0x58:		/* Store Word, No WriteBack, Pre Inc, Immed */
	      (void) StoreWord (state, instr, LHS + LSImmRHS);
	      break;

	    case 0x59:		/* Load Word, No WriteBack, Pre Inc, Immed */
	      (void) LoadWord (state, instr, LHS + LSImmRHS);
	      break;

	    case 0x5a:		/* Store Word, WriteBack, Pre Inc, Immed */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      temp = LHS + LSImmRHS;
	      if (StoreWord (state, instr, temp))
		LSBase = temp;
	      break;

	    case 0x5b:		/* Load Word, WriteBack, Pre Inc, Immed */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      temp = LHS + LSImmRHS;
	      if (LoadWord (state, instr, temp))
		LSBase = temp;
	      break;

	    case 0x5c:		/* Store Byte, No WriteBack, Pre Inc, Immed */
	      (void) StoreByte (state, instr, LHS + LSImmRHS);
	      break;

	    case 0x5d:		/* Load Byte, No WriteBack, Pre Inc, Immed */
	      (void) LoadByte (state, instr, LHS + LSImmRHS, LUNSIGNED);
	      break;

	    case 0x5e:		/* Store Byte, WriteBack, Pre Inc, Immed */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      temp = LHS + LSImmRHS;
	      if (StoreByte (state, instr, temp))
		LSBase = temp;
	      break;

	    case 0x5f:		/* Load Byte, WriteBack, Pre Inc, Immed */
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      temp = LHS + LSImmRHS;
	      if (LoadByte (state, instr, temp, LUNSIGNED))
		LSBase = temp;
	      break;
d1780 426
a2205 457
	    case 0x60:		/* Store Word, No WriteBack, Post Dec, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      if (StoreWord (state, instr, lhs))
		LSBase = lhs - LSRegRHS;
	      break;

	    case 0x61:		/* Load Word, No WriteBack, Post Dec, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      if (LoadWord (state, instr, lhs))
		LSBase = lhs - LSRegRHS;
	      break;

	    case 0x62:		/* Store Word, WriteBack, Post Dec, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (StoreWord (state, instr, lhs))
		LSBase = lhs - LSRegRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x63:		/* Load Word, WriteBack, Post Dec, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (LoadWord (state, instr, lhs))
		LSBase = lhs - LSRegRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x64:		/* Store Byte, No WriteBack, Post Dec, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      if (StoreByte (state, instr, lhs))
		LSBase = lhs - LSRegRHS;
	      break;

	    case 0x65:		/* Load Byte, No WriteBack, Post Dec, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      if (LoadByte (state, instr, lhs, LUNSIGNED))
		LSBase = lhs - LSRegRHS;
	      break;

	    case 0x66:		/* Store Byte, WriteBack, Post Dec, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (StoreByte (state, instr, lhs))
		LSBase = lhs - LSRegRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x67:		/* Load Byte, WriteBack, Post Dec, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (LoadByte (state, instr, lhs, LUNSIGNED))
		LSBase = lhs - LSRegRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x68:		/* Store Word, No WriteBack, Post Inc, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      if (StoreWord (state, instr, lhs))
		LSBase = lhs + LSRegRHS;
	      break;

	    case 0x69:		/* Load Word, No WriteBack, Post Inc, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      if (LoadWord (state, instr, lhs))
		LSBase = lhs + LSRegRHS;
	      break;

	    case 0x6a:		/* Store Word, WriteBack, Post Inc, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (StoreWord (state, instr, lhs))
		LSBase = lhs + LSRegRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x6b:		/* Load Word, WriteBack, Post Inc, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (LoadWord (state, instr, lhs))
		LSBase = lhs + LSRegRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x6c:		/* Store Byte, No WriteBack, Post Inc, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      if (StoreByte (state, instr, lhs))
		LSBase = lhs + LSRegRHS;
	      break;

	    case 0x6d:		/* Load Byte, No WriteBack, Post Inc, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      if (LoadByte (state, instr, lhs, LUNSIGNED))
		LSBase = lhs + LSRegRHS;
	      break;

	    case 0x6e:		/* Store Byte, WriteBack, Post Inc, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (StoreByte (state, instr, lhs))
		LSBase = lhs + LSRegRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;

	    case 0x6f:		/* Load Byte, WriteBack, Post Inc, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      lhs = LHS;
	      state->NtransSig = LOW;
	      if (LoadByte (state, instr, lhs, LUNSIGNED))
		LSBase = lhs + LSRegRHS;
	      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
	      break;


	    case 0x70:		/* Store Word, No WriteBack, Pre Dec, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      (void) StoreWord (state, instr, LHS - LSRegRHS);
	      break;

	    case 0x71:		/* Load Word, No WriteBack, Pre Dec, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      (void) LoadWord (state, instr, LHS - LSRegRHS);
	      break;

	    case 0x72:		/* Store Word, WriteBack, Pre Dec, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      temp = LHS - LSRegRHS;
	      if (StoreWord (state, instr, temp))
		LSBase = temp;
	      break;

	    case 0x73:		/* Load Word, WriteBack, Pre Dec, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      temp = LHS - LSRegRHS;
	      if (LoadWord (state, instr, temp))
		LSBase = temp;
	      break;

	    case 0x74:		/* Store Byte, No WriteBack, Pre Dec, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      (void) StoreByte (state, instr, LHS - LSRegRHS);
	      break;

	    case 0x75:		/* Load Byte, No WriteBack, Pre Dec, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      (void) LoadByte (state, instr, LHS - LSRegRHS, LUNSIGNED);
	      break;

	    case 0x76:		/* Store Byte, WriteBack, Pre Dec, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      temp = LHS - LSRegRHS;
	      if (StoreByte (state, instr, temp))
		LSBase = temp;
	      break;

	    case 0x77:		/* Load Byte, WriteBack, Pre Dec, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      temp = LHS - LSRegRHS;
	      if (LoadByte (state, instr, temp, LUNSIGNED))
		LSBase = temp;
	      break;

	    case 0x78:		/* Store Word, No WriteBack, Pre Inc, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      (void) StoreWord (state, instr, LHS + LSRegRHS);
	      break;

	    case 0x79:		/* Load Word, No WriteBack, Pre Inc, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      (void) LoadWord (state, instr, LHS + LSRegRHS);
	      break;

	    case 0x7a:		/* Store Word, WriteBack, Pre Inc, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      temp = LHS + LSRegRHS;
	      if (StoreWord (state, instr, temp))
		LSBase = temp;
	      break;

	    case 0x7b:		/* Load Word, WriteBack, Pre Inc, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      temp = LHS + LSRegRHS;
	      if (LoadWord (state, instr, temp))
		LSBase = temp;
	      break;

	    case 0x7c:		/* Store Byte, No WriteBack, Pre Inc, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      (void) StoreByte (state, instr, LHS + LSRegRHS);
	      break;

	    case 0x7d:		/* Load Byte, No WriteBack, Pre Inc, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      (void) LoadByte (state, instr, LHS + LSRegRHS, LUNSIGNED);
	      break;

	    case 0x7e:		/* Store Byte, WriteBack, Pre Inc, Reg */
	      if (BIT (4))
		{
		  ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      temp = LHS + LSRegRHS;
	      if (StoreByte (state, instr, temp))
		LSBase = temp;
	      break;

	    case 0x7f:		/* Load Byte, WriteBack, Pre Inc, Reg */
	      if (BIT (4))
		{
		  /* Check for the special breakpoint opcode.
		     This value should correspond to the value defined
		     as ARM_BE_BREAKPOINT in gdb/arm-tdep.c.  */
		  if (BITS (0, 19) == 0xfdefe)
		    {
		      if (!ARMul_OSHandleSWI (state, SWI_Breakpoint))
			ARMul_Abort (state, ARMul_SWIV);
		    }
		  else
		    ARMul_UndefInstr (state, instr);
		  break;
		}
	      UNDEF_LSRBaseEQOffWb;
	      UNDEF_LSRBaseEQDestWb;
	      UNDEF_LSRPCBaseWb;
	      UNDEF_LSRPCOffWb;
	      temp = LHS + LSRegRHS;
	      if (LoadByte (state, instr, temp, LUNSIGNED))
		LSBase = temp;
	      break;
d2211 146
a2356 146
	    case 0x80:		/* Store, No WriteBack, Post Dec */
	      STOREMULT (instr, LSBase - LSMNumRegs + 4L, 0L);
	      break;

	    case 0x81:		/* Load, No WriteBack, Post Dec */
	      LOADMULT (instr, LSBase - LSMNumRegs + 4L, 0L);
	      break;

	    case 0x82:		/* Store, WriteBack, Post Dec */
	      temp = LSBase - LSMNumRegs;
	      STOREMULT (instr, temp + 4L, temp);
	      break;

	    case 0x83:		/* Load, WriteBack, Post Dec */
	      temp = LSBase - LSMNumRegs;
	      LOADMULT (instr, temp + 4L, temp);
	      break;

	    case 0x84:		/* Store, Flags, No WriteBack, Post Dec */
	      STORESMULT (instr, LSBase - LSMNumRegs + 4L, 0L);
	      break;

	    case 0x85:		/* Load, Flags, No WriteBack, Post Dec */
	      LOADSMULT (instr, LSBase - LSMNumRegs + 4L, 0L);
	      break;

	    case 0x86:		/* Store, Flags, WriteBack, Post Dec */
	      temp = LSBase - LSMNumRegs;
	      STORESMULT (instr, temp + 4L, temp);
	      break;

	    case 0x87:		/* Load, Flags, WriteBack, Post Dec */
	      temp = LSBase - LSMNumRegs;
	      LOADSMULT (instr, temp + 4L, temp);
	      break;


	    case 0x88:		/* Store, No WriteBack, Post Inc */
	      STOREMULT (instr, LSBase, 0L);
	      break;

	    case 0x89:		/* Load, No WriteBack, Post Inc */
	      LOADMULT (instr, LSBase, 0L);
	      break;

	    case 0x8a:		/* Store, WriteBack, Post Inc */
	      temp = LSBase;
	      STOREMULT (instr, temp, temp + LSMNumRegs);
	      break;

	    case 0x8b:		/* Load, WriteBack, Post Inc */
	      temp = LSBase;
	      LOADMULT (instr, temp, temp + LSMNumRegs);
	      break;

	    case 0x8c:		/* Store, Flags, No WriteBack, Post Inc */
	      STORESMULT (instr, LSBase, 0L);
	      break;

	    case 0x8d:		/* Load, Flags, No WriteBack, Post Inc */
	      LOADSMULT (instr, LSBase, 0L);
	      break;

	    case 0x8e:		/* Store, Flags, WriteBack, Post Inc */
	      temp = LSBase;
	      STORESMULT (instr, temp, temp + LSMNumRegs);
	      break;

	    case 0x8f:		/* Load, Flags, WriteBack, Post Inc */
	      temp = LSBase;
	      LOADSMULT (instr, temp, temp + LSMNumRegs);
	      break;


	    case 0x90:		/* Store, No WriteBack, Pre Dec */
	      STOREMULT (instr, LSBase - LSMNumRegs, 0L);
	      break;

	    case 0x91:		/* Load, No WriteBack, Pre Dec */
	      LOADMULT (instr, LSBase - LSMNumRegs, 0L);
	      break;

	    case 0x92:		/* Store, WriteBack, Pre Dec */
	      temp = LSBase - LSMNumRegs;
	      STOREMULT (instr, temp, temp);
	      break;

	    case 0x93:		/* Load, WriteBack, Pre Dec */
	      temp = LSBase - LSMNumRegs;
	      LOADMULT (instr, temp, temp);
	      break;

	    case 0x94:		/* Store, Flags, No WriteBack, Pre Dec */
	      STORESMULT (instr, LSBase - LSMNumRegs, 0L);
	      break;

	    case 0x95:		/* Load, Flags, No WriteBack, Pre Dec */
	      LOADSMULT (instr, LSBase - LSMNumRegs, 0L);
	      break;

	    case 0x96:		/* Store, Flags, WriteBack, Pre Dec */
	      temp = LSBase - LSMNumRegs;
	      STORESMULT (instr, temp, temp);
	      break;

	    case 0x97:		/* Load, Flags, WriteBack, Pre Dec */
	      temp = LSBase - LSMNumRegs;
	      LOADSMULT (instr, temp, temp);
	      break;


	    case 0x98:		/* Store, No WriteBack, Pre Inc */
	      STOREMULT (instr, LSBase + 4L, 0L);
	      break;

	    case 0x99:		/* Load, No WriteBack, Pre Inc */
	      LOADMULT (instr, LSBase + 4L, 0L);
	      break;

	    case 0x9a:		/* Store, WriteBack, Pre Inc */
	      temp = LSBase;
	      STOREMULT (instr, temp + 4L, temp + LSMNumRegs);
	      break;

	    case 0x9b:		/* Load, WriteBack, Pre Inc */
	      temp = LSBase;
	      LOADMULT (instr, temp + 4L, temp + LSMNumRegs);
	      break;

	    case 0x9c:		/* Store, Flags, No WriteBack, Pre Inc */
	      STORESMULT (instr, LSBase + 4L, 0L);
	      break;

	    case 0x9d:		/* Load, Flags, No WriteBack, Pre Inc */
	      LOADSMULT (instr, LSBase + 4L, 0L);
	      break;

	    case 0x9e:		/* Store, Flags, WriteBack, Pre Inc */
	      temp = LSBase;
	      STORESMULT (instr, temp + 4L, temp + LSMNumRegs);
	      break;

	    case 0x9f:		/* Load, Flags, WriteBack, Pre Inc */
	      temp = LSBase;
	      LOADSMULT (instr, temp + 4L, temp + LSMNumRegs);
	      break;
d2362 5
a2366 11
	    case 0xa0:
	    case 0xa1:
	    case 0xa2:
	    case 0xa3:
	    case 0xa4:
	    case 0xa5:
	    case 0xa6:
	    case 0xa7:
	      state->Reg[15] = pc + 8 + POSBRANCH;
	      FLUSHPIPE;
	      break;
d2372 5
a2376 11
	    case 0xa8:
	    case 0xa9:
	    case 0xaa:
	    case 0xab:
	    case 0xac:
	    case 0xad:
	    case 0xae:
	    case 0xaf:
	      state->Reg[15] = pc + 8 + NEGBRANCH;
	      FLUSHPIPE;
	      break;
d2382 2
a2383 8
	    case 0xb0:
	    case 0xb1:
	    case 0xb2:
	    case 0xb3:
	    case 0xb4:
	    case 0xb5:
	    case 0xb6:
	    case 0xb7:
d2385 1
a2385 1
	      state->Reg[14] = pc + 4;	/* put PC into Link */
d2387 1
a2387 1
	      state->Reg[14] = pc + 4 | ECC | ER15INT | EMODE;	/* put PC into Link */
d2389 3
a2391 3
	      state->Reg[15] = pc + 8 + POSBRANCH;
	      FLUSHPIPE;
	      break;
d2397 2
a2398 8
	    case 0xb8:
	    case 0xb9:
	    case 0xba:
	    case 0xbb:
	    case 0xbc:
	    case 0xbd:
	    case 0xbe:
	    case 0xbf:
d2400 1
a2400 1
	      state->Reg[14] = pc + 4;	/* put PC into Link */
d2402 1
a2402 1
	      state->Reg[14] = (pc + 4) | ECC | ER15INT | EMODE;	/* put PC into Link */
d2404 3
a2406 3
	      state->Reg[15] = pc + 8 + NEGBRANCH;
	      FLUSHPIPE;
	      break;
d2412 96
a2507 96
	    case 0xc4:
	    case 0xc0:		/* Store , No WriteBack , Post Dec */
	      ARMul_STC (state, instr, LHS);
	      break;

	    case 0xc5:
	    case 0xc1:		/* Load , No WriteBack , Post Dec */
	      ARMul_LDC (state, instr, LHS);
	      break;

	    case 0xc2:
	    case 0xc6:		/* Store , WriteBack , Post Dec */
	      lhs = LHS;
	      state->Base = lhs - LSCOff;
	      ARMul_STC (state, instr, lhs);
	      break;

	    case 0xc3:
	    case 0xc7:		/* Load , WriteBack , Post Dec */
	      lhs = LHS;
	      state->Base = lhs - LSCOff;
	      ARMul_LDC (state, instr, lhs);
	      break;

	    case 0xc8:
	    case 0xcc:		/* Store , No WriteBack , Post Inc */
	      ARMul_STC (state, instr, LHS);
	      break;

	    case 0xc9:
	    case 0xcd:		/* Load , No WriteBack , Post Inc */
	      ARMul_LDC (state, instr, LHS);
	      break;

	    case 0xca:
	    case 0xce:		/* Store , WriteBack , Post Inc */
	      lhs = LHS;
	      state->Base = lhs + LSCOff;
	      ARMul_STC (state, instr, LHS);
	      break;

	    case 0xcb:
	    case 0xcf:		/* Load , WriteBack , Post Inc */
	      lhs = LHS;
	      state->Base = lhs + LSCOff;
	      ARMul_LDC (state, instr, LHS);
	      break;


	    case 0xd0:
	    case 0xd4:		/* Store , No WriteBack , Pre Dec */
	      ARMul_STC (state, instr, LHS - LSCOff);
	      break;

	    case 0xd1:
	    case 0xd5:		/* Load , No WriteBack , Pre Dec */
	      ARMul_LDC (state, instr, LHS - LSCOff);
	      break;

	    case 0xd2:
	    case 0xd6:		/* Store , WriteBack , Pre Dec */
	      lhs = LHS - LSCOff;
	      state->Base = lhs;
	      ARMul_STC (state, instr, lhs);
	      break;

	    case 0xd3:
	    case 0xd7:		/* Load , WriteBack , Pre Dec */
	      lhs = LHS - LSCOff;
	      state->Base = lhs;
	      ARMul_LDC (state, instr, lhs);
	      break;

	    case 0xd8:
	    case 0xdc:		/* Store , No WriteBack , Pre Inc */
	      ARMul_STC (state, instr, LHS + LSCOff);
	      break;

	    case 0xd9:
	    case 0xdd:		/* Load , No WriteBack , Pre Inc */
	      ARMul_LDC (state, instr, LHS + LSCOff);
	      break;

	    case 0xda:
	    case 0xde:		/* Store , WriteBack , Pre Inc */
	      lhs = LHS + LSCOff;
	      state->Base = lhs;
	      ARMul_STC (state, instr, lhs);
	      break;

	    case 0xdb:
	    case 0xdf:		/* Load , WriteBack , Pre Inc */
	      lhs = LHS + LSCOff;
	      state->Base = lhs;
	      ARMul_LDC (state, instr, lhs);
	      break;
d2513 6
a2518 13
	    case 0xe2:
	    case 0xe0:
	    case 0xe4:
	    case 0xe6:
	    case 0xe8:
	    case 0xea:
	    case 0xec:
	    case 0xee:
	      if (BIT (4))
		{		/* MCR */
		  if (DESTReg == 15)
		    {
		      UNDEF_MCRPC;
d2520 1
a2520 1
		      ARMul_MCR (state, instr, state->Reg[15] + isize);
d2522 2
a2523 2
		      ARMul_MCR (state, instr, ECC | ER15INT | EMODE |
				 ((state->Reg[15] + isize) & R15PCBITS));
d2525 7
a2531 7
		    }
		  else
		    ARMul_MCR (state, instr, DEST);
		}
	      else		/* CDP Part 1 */
		ARMul_CDP (state, instr);
	      break;
d2537 16
a2552 24
	    case 0xe1:
	    case 0xe3:
	    case 0xe5:
	    case 0xe7:
	    case 0xe9:
	    case 0xeb:
	    case 0xed:
	    case 0xef:
	      if (BIT (4))
		{		/* MRC */
		  temp = ARMul_MRC (state, instr);
		  if (DESTReg == 15)
		    {
		      ASSIGNN ((temp & NBIT) != 0);
		      ASSIGNZ ((temp & ZBIT) != 0);
		      ASSIGNC ((temp & CBIT) != 0);
		      ASSIGNV ((temp & VBIT) != 0);
		    }
		  else
		    DEST = temp;
		}
	      else		/* CDP Part 2 */
		ARMul_CDP (state, instr);
	      break;
d2558 15
a2572 29
	    case 0xf0:
	    case 0xf1:
	    case 0xf2:
	    case 0xf3:
	    case 0xf4:
	    case 0xf5:
	    case 0xf6:
	    case 0xf7:
	    case 0xf8:
	    case 0xf9:
	    case 0xfa:
	    case 0xfb:
	    case 0xfc:
	    case 0xfd:
	    case 0xfe:
	    case 0xff:
	      if (instr == ARMul_ABORTWORD && state->AbortAddr == pc)
		{		/* a prefetch abort */
		  ARMul_Abort (state, ARMul_PrefetchAbortV);
		  break;
		}

	      if (!ARMul_OSHandleSWI (state, BITS (0, 23)))
		{
		  ARMul_Abort (state, ARMul_SWIV);
		}
	      break;
	    }			/* 256 way main switch */
	}			/* if temp */
d2575 1
a2575 1
    donext:
d2579 5
a2583 5
      if (ui_loop_hook != NULL && ui_loop_hook_counter-- < 0)
	{
	  ui_loop_hook_counter = UI_LOOP_POLL_INTERVAL;
	  ui_loop_hook (0);
	}
d2586 11
a2596 12
      if (state->Emulate == ONCE)
	state->Emulate = STOP;
      else if (state->Emulate != RUN)
	break;
    }
  while (!stop_simulator);	/* do loop */

  state->decoded = decoded;
  state->loaded = loaded;
  state->pc = pc;
  return (pc);
}				/* Emulate 26/32 in instruction based mode */
d2605 2
a2606 4
static ARMword
GetDPRegRHS (ARMul_State * state, ARMword instr)
{
  ARMword shamt, base;
d2608 4
a2611 5
  base = RHSReg;
  if (BIT (4))
    {				/* shift amount in a register */
      UNDEF_Shift;
      INCPC;
d2613 32
a2644 37
      if (base == 15)
	base = ECC | ER15INT | R15PC | EMODE;
      else
#endif
	base = state->Reg[base];
      ARMul_Icycles (state, 1, 0L);
      shamt = state->Reg[BITS (8, 11)] & 0xff;
      switch ((int) BITS (5, 6))
	{
	case LSL:
	  if (shamt == 0)
	    return (base);
	  else if (shamt >= 32)
	    return (0);
	  else
	    return (base << shamt);
	case LSR:
	  if (shamt == 0)
	    return (base);
	  else if (shamt >= 32)
	    return (0);
	  else
	    return (base >> shamt);
	case ASR:
	  if (shamt == 0)
	    return (base);
	  else if (shamt >= 32)
	    return ((ARMword) ((long int) base >> 31L));
	  else
	    return ((ARMword) ((long int) base >> (int) shamt));
	case ROR:
	  shamt &= 0x1f;
	  if (shamt == 0)
	    return (base);
	  else
	    return ((base << (32 - shamt)) | (base >> shamt));
	}
d2646 1
a2646 2
  else
    {				/* shift amount is a constant */
d2648 21
a2668 26
      if (base == 15)
	base = ECC | ER15INT | R15PC | EMODE;
      else
#endif
	base = state->Reg[base];
      shamt = BITS (7, 11);
      switch ((int) BITS (5, 6))
	{
	case LSL:
	  return (base << shamt);
	case LSR:
	  if (shamt == 0)
	    return (0);
	  else
	    return (base >> shamt);
	case ASR:
	  if (shamt == 0)
	    return ((ARMword) ((long int) base >> 31L));
	  else
	    return ((ARMword) ((long int) base >> (int) shamt));
	case ROR:
	  if (shamt == 0)	/* its an RRX */
	    return ((base >> 1) | (CFLAG << 31));
	  else
	    return ((base << (32 - shamt)) | (base >> shamt));
	}
d2670 2
a2671 3
  return (0);			/* just to shut up lint */
}

d2679 2
a2680 4
static ARMword
GetDPSRegRHS (ARMul_State * state, ARMword instr)
{
  ARMword shamt, base;
d2682 4
a2685 5
  base = RHSReg;
  if (BIT (4))
    {				/* shift amount in a register */
      UNDEF_Shift;
      INCPC;
d2687 58
a2744 73
      if (base == 15)
	base = ECC | ER15INT | R15PC | EMODE;
      else
#endif
	base = state->Reg[base];
      ARMul_Icycles (state, 1, 0L);
      shamt = state->Reg[BITS (8, 11)] & 0xff;
      switch ((int) BITS (5, 6))
	{
	case LSL:
	  if (shamt == 0)
	    return (base);
	  else if (shamt == 32)
	    {
	      ASSIGNC (base & 1);
	      return (0);
	    }
	  else if (shamt > 32)
	    {
	      CLEARC;
	      return (0);
	    }
	  else
	    {
	      ASSIGNC ((base >> (32 - shamt)) & 1);
	      return (base << shamt);
	    }
	case LSR:
	  if (shamt == 0)
	    return (base);
	  else if (shamt == 32)
	    {
	      ASSIGNC (base >> 31);
	      return (0);
	    }
	  else if (shamt > 32)
	    {
	      CLEARC;
	      return (0);
	    }
	  else
	    {
	      ASSIGNC ((base >> (shamt - 1)) & 1);
	      return (base >> shamt);
	    }
	case ASR:
	  if (shamt == 0)
	    return (base);
	  else if (shamt >= 32)
	    {
	      ASSIGNC (base >> 31L);
	      return ((ARMword) ((long int) base >> 31L));
	    }
	  else
	    {
	      ASSIGNC ((ARMword) ((long int) base >> (int) (shamt - 1)) & 1);
	      return ((ARMword) ((long int) base >> (int) shamt));
	    }
	case ROR:
	  if (shamt == 0)
	    return (base);
	  shamt &= 0x1f;
	  if (shamt == 0)
	    {
	      ASSIGNC (base >> 31);
	      return (base);
	    }
	  else
	    {
	      ASSIGNC ((base >> (shamt - 1)) & 1);
	      return ((base << (32 - shamt)) | (base >> shamt));
	    }
	}
d2746 1
a2746 2
  else
    {				/* shift amount is a constant */
d2748 35
a2782 46
      if (base == 15)
	base = ECC | ER15INT | R15PC | EMODE;
      else
#endif
	base = state->Reg[base];
      shamt = BITS (7, 11);
      switch ((int) BITS (5, 6))
	{
	case LSL:
	  ASSIGNC ((base >> (32 - shamt)) & 1);
	  return (base << shamt);
	case LSR:
	  if (shamt == 0)
	    {
	      ASSIGNC (base >> 31);
	      return (0);
	    }
	  else
	    {
	      ASSIGNC ((base >> (shamt - 1)) & 1);
	      return (base >> shamt);
	    }
	case ASR:
	  if (shamt == 0)
	    {
	      ASSIGNC (base >> 31L);
	      return ((ARMword) ((long int) base >> 31L));
	    }
	  else
	    {
	      ASSIGNC ((ARMword) ((long int) base >> (int) (shamt - 1)) & 1);
	      return ((ARMword) ((long int) base >> (int) shamt));
	    }
	case ROR:
	  if (shamt == 0)
	    {			/* its an RRX */
	      shamt = CFLAG;
	      ASSIGNC (base & 1);
	      return ((base >> 1) | (shamt << 31));
	    }
	  else
	    {
	      ASSIGNC ((base >> (shamt - 1)) & 1);
	      return ((base << (32 - shamt)) | (base >> shamt));
	    }
	}
d2784 2
a2785 2
  return (0);			/* just to shut up lint */
}
d2791 1
a2791 2
static void
WriteR15 (ARMul_State * state, ARMword src)
d2795 1
a2795 1
  state->Reg[15] = src & PCBITS & ~0x1;
d2797 2
a2798 2
  state->Reg[15] = (src & R15PCBITS & ~0x1) | ECC | ER15INT | EMODE;
  ARMul_R15Altered (state);
d2800 2
a2801 2
  FLUSHPIPE;
}
d2807 1
a2807 2
static void
WriteSR15 (ARMul_State * state, ARMword src)
d2810 4
a2813 5
  state->Reg[15] = src & PCBITS;
  if (state->Bank > 0)
    {
      state->Cpsr = state->Spsr[state->Bank];
      ARMul_CPSRAltered (state);
d2816 5
a2820 5
  if (state->Bank == USERBANK)
    state->Reg[15] = (src & (CCBITS | R15PCBITS)) | ER15INT | EMODE;
  else
    state->Reg[15] = src;
  ARMul_R15Altered (state);
d2822 2
a2823 2
  FLUSHPIPE;
}
d2831 2
a2832 4
static ARMword
GetLSRegRHS (ARMul_State * state, ARMword instr)
{
  ARMword shamt, base;
d2834 1
a2834 1
  base = RHSReg;
d2836 21
a2856 26
  if (base == 15)
    base = ECC | ER15INT | R15PC | EMODE;	/* Now forbidden, but .... */
  else
#endif
    base = state->Reg[base];

  shamt = BITS (7, 11);
  switch ((int) BITS (5, 6))
    {
    case LSL:
      return (base << shamt);
    case LSR:
      if (shamt == 0)
	return (0);
      else
	return (base >> shamt);
    case ASR:
      if (shamt == 0)
	return ((ARMword) ((long int) base >> 31L));
      else
	return ((ARMword) ((long int) base >> (int) shamt));
    case ROR:
      if (shamt == 0)		/* its an RRX */
	return ((base >> 1) | (CFLAG << 31));
      else
	return ((base << (32 - shamt)) | (base >> shamt));
d2858 2
a2859 2
  return (0);			/* just to shut up lint */
}
d2865 1
a2865 2
static ARMword
GetLS7RHS (ARMul_State * state, ARMword instr)
d2867 1
a2867 2
  if (BIT (22) == 0)
    {				/* register */
d2869 2
a2870 2
      if (RHSReg == 15)
	return ECC | ER15INT | R15PC | EMODE;	/* Now forbidden, but ... */
d2872 1
a2872 1
      return state->Reg[RHSReg];
d2875 3
a2877 3
  /* else immediate */
  return BITS (0, 3) | (BITS (8, 11) << 4);
}
d2883 1
a2883 2
static unsigned
LoadWord (ARMul_State * state, ARMword instr, ARMword address)
d2885 1
a2885 1
  ARMword dest;
d2887 1
a2887 1
  BUSUSEDINCPCS;
d2889 2
a2890 3
  if (ADDREXCEPT (address))
    {
      INTERNALABORT (address);
d2893 4
a2896 5
  dest = ARMul_LoadWordN (state, address);
  if (state->Aborted)
    {
      TAKEABORT;
      return (state->lateabtSig);
d2898 4
a2901 4
  if (address & 3)
    dest = ARMul_Align (state, address, dest);
  WRITEDEST (dest);
  ARMul_Icycles (state, 1, 0L);
d2903 1
a2903 1
  return (DESTReg != LHSReg);
d2911 1
a2911 3
static unsigned
LoadHalfWord (ARMul_State * state, ARMword instr, ARMword address,
	      int signextend)
d2913 1
a2913 1
  ARMword dest;
d2915 1
a2915 1
  BUSUSEDINCPCS;
d2917 2
a2918 3
  if (ADDREXCEPT (address))
    {
      INTERNALABORT (address);
d2921 14
a2934 15
  dest = ARMul_LoadHalfWord (state, address);
  if (state->Aborted)
    {
      TAKEABORT;
      return (state->lateabtSig);
    }
  UNDEF_LSRBPC;
  if (signextend)
    {
      if (dest & 1 << (16 - 1))
	dest = (dest & ((1 << 16) - 1)) - (1 << 16);
    }
  WRITEDEST (dest);
  ARMul_Icycles (state, 1, 0L);
  return (DESTReg != LHSReg);
a2935 1

d2942 1
a2942 2
static unsigned
LoadByte (ARMul_State * state, ARMword instr, ARMword address, int signextend)
d2944 1
a2944 1
  ARMword dest;
d2946 1
a2946 1
  BUSUSEDINCPCS;
d2948 2
a2949 3
  if (ADDREXCEPT (address))
    {
      INTERNALABORT (address);
d2952 14
a2965 15
  dest = ARMul_LoadByte (state, address);
  if (state->Aborted)
    {
      TAKEABORT;
      return (state->lateabtSig);
    }
  UNDEF_LSRBPC;
  if (signextend)
    {
      if (dest & 1 << (8 - 1))
	dest = (dest & ((1 << 8) - 1)) - (1 << 8);
    }
  WRITEDEST (dest);
  ARMul_Icycles (state, 1, 0L);
  return (DESTReg != LHSReg);
d2972 2
a2973 4
static unsigned
StoreWord (ARMul_State * state, ARMword instr, ARMword address)
{
  BUSUSEDINCPCN;
d2975 2
a2976 2
  if (DESTReg == 15)
    state->Reg[15] = ECC | ER15INT | R15PC | EMODE;
d2979 1
a2979 1
  ARMul_StoreWordN (state, address, DEST);
d2981 10
a2990 12
  if (VECTORACCESS (address) || ADDREXCEPT (address))
    {
      INTERNALABORT (address);
      (void) ARMul_LoadWordN (state, address);
    }
  else
    ARMul_StoreWordN (state, address, DEST);
#endif
  if (state->Aborted)
    {
      TAKEABORT;
      return (state->lateabtSig);
d2992 1
a2992 1
  return (TRUE);
d3000 2
a3001 4
static unsigned
StoreHalfWord (ARMul_State * state, ARMword instr, ARMword address)
{
  BUSUSEDINCPCN;
d3004 2
a3005 2
  if (DESTReg == 15)
    state->Reg[15] = ECC | ER15INT | R15PC | EMODE;
d3009 1
a3009 1
  ARMul_StoreHalfWord (state, address, DEST);
d3011 3
a3013 4
  if (VECTORACCESS (address) || ADDREXCEPT (address))
    {
      INTERNALABORT (address);
      (void) ARMul_LoadHalfWord (state, address);
d3015 2
a3016 2
  else
    ARMul_StoreHalfWord (state, address, DEST);
d3019 3
a3021 4
  if (state->Aborted)
    {
      TAKEABORT;
      return (state->lateabtSig);
d3024 1
a3024 1
  return (TRUE);
a3025 1

d3032 2
a3033 4
static unsigned
StoreByte (ARMul_State * state, ARMword instr, ARMword address)
{
  BUSUSEDINCPCN;
d3035 2
a3036 2
  if (DESTReg == 15)
    state->Reg[15] = ECC | ER15INT | R15PC | EMODE;
d3039 1
a3039 1
  ARMul_StoreByte (state, address, DEST);
d3041 10
a3050 4
  if (VECTORACCESS (address) || ADDREXCEPT (address))
    {
      INTERNALABORT (address);
      (void) ARMul_LoadByte (state, address);
d3052 2
a3053 10
  else
    ARMul_StoreByte (state, address, DEST);
#endif
  if (state->Aborted)
    {
      TAKEABORT;
      return (state->lateabtSig);
    }
  UNDEF_LSRBPC;
  return (TRUE);
d3063 8
a3070 9
static void
LoadMult (ARMul_State * state, ARMword instr, ARMword address, ARMword WBBase)
{
  ARMword dest, temp;

  UNDEF_LSMNoRegs;
  UNDEF_LSMPCBase;
  UNDEF_LSMBaseInListWb;
  BUSUSEDINCPCS;
d3072 2
a3073 3
  if (ADDREXCEPT (address))
    {
      INTERNALABORT (address);
d3076 2
a3077 2
  if (BIT (21) && LHSReg != 15)
    LSBase = WBBase;
d3079 18
a3096 17
  for (temp = 0; !BIT (temp); temp++);	/* N cycle first */
  dest = ARMul_LoadWordN (state, address);
  if (!state->abortSig && !state->Aborted)
    state->Reg[temp++] = dest;
  else if (!state->Aborted)
    state->Aborted = ARMul_DataAbortV;

  for (; temp < 16; temp++)	/* S cycles from here on */
    if (BIT (temp))
      {				/* load this register */
	address += 4;
	dest = ARMul_LoadWordS (state, address);
	if (!state->abortSig && !state->Aborted)
	  state->Reg[temp] = dest;
	else if (!state->Aborted)
	  state->Aborted = ARMul_DataAbortV;
      }
d3098 1
a3098 2
  if (BIT (15))
    {				/* PC is in the reg list */
d3100 1
a3100 1
      state->Reg[15] = PC;
d3102 1
a3102 1
      FLUSHPIPE;
d3105 1
a3105 1
  ARMul_Icycles (state, 1, 0L);	/* to write back the final register */
d3107 4
a3110 5
  if (state->Aborted)
    {
      if (BIT (21) && LHSReg != 15)
	LSBase = WBBase;
      TAKEABORT;
d3112 1
a3112 1
}
d3121 8
a3128 10
static void
LoadSMult (ARMul_State * state, ARMword instr,
	   ARMword address, ARMword WBBase)
{
  ARMword dest, temp;

  UNDEF_LSMNoRegs;
  UNDEF_LSMPCBase;
  UNDEF_LSMBaseInListWb;
  BUSUSEDINCPCS;
d3130 2
a3131 3
  if (ADDREXCEPT (address))
    {
      INTERNALABORT (address);
d3135 34
a3168 36
  if (!BIT (15) && state->Bank != USERBANK)
    {
      (void) ARMul_SwitchMode (state, state->Mode, USER26MODE);	/* temporary reg bank switch */
      UNDEF_LSMUserBankWb;
    }

  if (BIT (21) && LHSReg != 15)
    LSBase = WBBase;

  for (temp = 0; !BIT (temp); temp++);	/* N cycle first */
  dest = ARMul_LoadWordN (state, address);
  if (!state->abortSig)
    state->Reg[temp++] = dest;
  else if (!state->Aborted)
    state->Aborted = ARMul_DataAbortV;

  for (; temp < 16; temp++)	/* S cycles from here on */
    if (BIT (temp))
      {				/* load this register */
	address += 4;
	dest = ARMul_LoadWordS (state, address);
	if (!state->abortSig || state->Aborted)
	  state->Reg[temp] = dest;
	else if (!state->Aborted)
	  state->Aborted = ARMul_DataAbortV;
      }

  if (BIT (15))
    {				/* PC is in the reg list */
#ifdef MODE32
      if (state->Mode != USER26MODE && state->Mode != USER32MODE)
	{
	  state->Cpsr = GETSPSR (state->Bank);
	  ARMul_CPSRAltered (state);
	}
      state->Reg[15] = PC;
d3170 21
a3190 23
      if (state->Mode == USER26MODE || state->Mode == USER32MODE)
	{			/* protect bits in user mode */
	  ASSIGNN ((state->Reg[15] & NBIT) != 0);
	  ASSIGNZ ((state->Reg[15] & ZBIT) != 0);
	  ASSIGNC ((state->Reg[15] & CBIT) != 0);
	  ASSIGNV ((state->Reg[15] & VBIT) != 0);
	}
      else
	ARMul_R15Altered (state);
#endif
      FLUSHPIPE;
    }

  if (!BIT (15) && state->Mode != USER26MODE && state->Mode != USER32MODE)
    (void) ARMul_SwitchMode (state, USER26MODE, state->Mode);	/* restore the correct bank */

  ARMul_Icycles (state, 1, 0L);	/* to write back the final register */

  if (state->Aborted)
    {
      if (BIT (21) && LHSReg != 15)
	LSBase = WBBase;
      TAKEABORT;
d3202 10
a3211 13
static void
StoreMult (ARMul_State * state, ARMword instr,
	   ARMword address, ARMword WBBase)
{
  ARMword temp;

  UNDEF_LSMNoRegs;
  UNDEF_LSMPCBase;
  UNDEF_LSMBaseInListWb;
  if (!TFLAG)
    {
      BUSUSEDINCPCN;		/* N-cycle, increment the PC and update the NextInstr state */
    }
d3214 2
a3215 3
  if (VECTORACCESS (address) || ADDREXCEPT (address))
    {
      INTERNALABORT (address);
d3217 2
a3218 2
  if (BIT (15))
    PATCHR15;
d3221 1
a3221 1
  for (temp = 0; !BIT (temp); temp++);	/* N cycle first */
d3223 1
a3223 1
  ARMul_StoreWordN (state, address, state->Reg[temp++]);
d3225 32
a3256 36
  if (state->Aborted)
    {
      (void) ARMul_LoadWordN (state, address);
      for (; temp < 16; temp++)	/* Fake the Stores as Loads */
	if (BIT (temp))
	  {			/* save this register */
	    address += 4;
	    (void) ARMul_LoadWordS (state, address);
	  }
      if (BIT (21) && LHSReg != 15)
	LSBase = WBBase;
      TAKEABORT;
      return;
    }
  else
    ARMul_StoreWordN (state, address, state->Reg[temp++]);
#endif
  if (state->abortSig && !state->Aborted)
    state->Aborted = ARMul_DataAbortV;

  if (BIT (21) && LHSReg != 15)
    LSBase = WBBase;

  for (; temp < 16; temp++)	/* S cycles from here on */
    if (BIT (temp))
      {				/* save this register */
	address += 4;
	ARMul_StoreWordS (state, address, state->Reg[temp]);
	if (state->abortSig && !state->Aborted)
	  state->Aborted = ARMul_DataAbortV;
      }
  if (state->Aborted)
    {
      TAKEABORT;
    }
}
d3265 8
a3272 10
static void
StoreSMult (ARMul_State * state, ARMword instr,
	    ARMword address, ARMword WBBase)
{
  ARMword temp;

  UNDEF_LSMNoRegs;
  UNDEF_LSMPCBase;
  UNDEF_LSMBaseInListWb;
  BUSUSEDINCPCN;
d3274 2
a3275 3
  if (VECTORACCESS (address) || ADDREXCEPT (address))
    {
      INTERNALABORT (address);
d3277 2
a3278 2
  if (BIT (15))
    PATCHR15;
d3281 3
a3283 4
  if (state->Bank != USERBANK)
    {
      (void) ARMul_SwitchMode (state, state->Mode, USER26MODE);	/* Force User Bank */
      UNDEF_LSMUserBankWb;
d3286 1
a3286 1
  for (temp = 0; !BIT (temp); temp++);	/* N cycle first */
d3288 1
a3288 1
  ARMul_StoreWordN (state, address, state->Reg[temp++]);
d3290 28
a3317 22
  if (state->Aborted)
    {
      (void) ARMul_LoadWordN (state, address);
      for (; temp < 16; temp++)	/* Fake the Stores as Loads */
	if (BIT (temp))
	  {			/* save this register */
	    address += 4;
	    (void) ARMul_LoadWordS (state, address);
	  }
      if (BIT (21) && LHSReg != 15)
	LSBase = WBBase;
      TAKEABORT;
      return;
    }
  else
    ARMul_StoreWordN (state, address, state->Reg[temp++]);
#endif
  if (state->abortSig && !state->Aborted)
    state->Aborted = ARMul_DataAbortV;

  if (BIT (21) && LHSReg != 15)
    LSBase = WBBase;
d3319 2
a3320 11
  for (; temp < 16; temp++)	/* S cycles from here on */
    if (BIT (temp))
      {				/* save this register */
	address += 4;
	ARMul_StoreWordS (state, address, state->Reg[temp]);
	if (state->abortSig && !state->Aborted)
	  state->Aborted = ARMul_DataAbortV;
      }

  if (state->Mode != USER26MODE && state->Mode != USER32MODE)
    (void) ARMul_SwitchMode (state, USER26MODE, state->Mode);	/* restore the correct bank */
d3322 2
a3323 3
  if (state->Aborted)
    {
      TAKEABORT;
d3332 1
a3332 2
static ARMword
Add32 (ARMword a1, ARMword a2, int *carry)
d3335 2
a3336 2
  unsigned int uresult = (unsigned int) result;
  unsigned int ua1 = (unsigned int) a1;
d3341 1
a3341 1
    *carry = 1;
d3343 1
a3343 1
    *carry = 0;
d3345 1
a3345 1
  return (result);
d3353 1
a3353 2
static unsigned
Multiply64 (ARMul_State * state, ARMword instr, int msigned, int scc)
d3355 1
a3355 1
  int nRdHi, nRdLo, nRs, nRm;	/* operand register numbers */
d3357 1
a3357 1
  int scount;			/* cycle count */
d3359 4
a3362 4
  nRdHi = BITS (16, 19);
  nRdLo = BITS (12, 15);
  nRs = BITS (8, 11);
  nRm = BITS (0, 3);
d3368 1
a3368 1
  if (nRdHi != 15
d3370 5
a3374 2
      && nRs != 15
      && nRm != 15 && nRdHi != nRdLo && nRdHi != nRm && nRdLo != nRm)
d3376 1
a3376 1
      ARMword lo, mid1, mid2, hi;	/* intermediate results */
d3378 1
a3378 1
      ARMword Rs = state->Reg[nRs];
d3384 1
a3384 1

d3386 2
a3387 2

	  if (((signed long) Rm) < 0)
d3389 2
a3390 2

	  if (((signed long) Rs) < 0)
d3393 1
a3393 1

d3395 2
a3396 2
         that we do not lose precision on 32bit only hosts: */
      lo = ((Rs & 0xFFFF) * (Rm & 0xFFFF));
d3399 2
a3400 2
      hi = (((Rs >> 16) & 0xFFFF) * ((Rm >> 16) & 0xFFFF));

d3402 2
a3403 2
         to propogate the carries from the additions: */
      RdLo = Add32 (lo, (mid1 << 16), &carry);
d3405 2
a3406 3
      RdLo = Add32 (RdLo, (mid2 << 16), &carry);
      RdHi +=
	(carry + ((mid1 >> 16) & 0xFFFF) + ((mid2 >> 16) & 0xFFFF) + hi);
d3411 3
a3413 3

	  RdLo = ~RdLo;
	  RdHi = ~RdHi;
d3422 1
a3422 1

d3425 4
a3428 5

    }				/* else undefined result */
  else
    fprintf (stderr, "MULTIPLY64 - INVALID ARGUMENTS\n");

d3432 1
a3432 1
	ARMul_NegZero (state, RdHi);	/* zero value */
d3434 1
a3434 1
	ARMul_NegZero (state, scc);	/* non-zero value */
d3436 1
a3436 1

d3439 3
a3441 3
  if (msigned && (Rm & ((unsigned) 1 << 31)))
    Rm = ~Rm;			/* invert the bits to make the check against zero */

d3443 1
a3443 1
    scount = 1;
d3445 1
a3445 1
    scount = 2;
d3447 1
a3447 1
    scount = 3;
d3449 3
a3451 3
    scount = 4;

  return 2 + scount;
d3459 1
a3459 2
static unsigned
MultiplyAdd64 (ARMul_State * state, ARMword instr, int msigned, int scc)
d3466 2
a3467 2
  nRdHi = BITS (16, 19);
  nRdLo = BITS (12, 15);
d3469 2
a3470 2
  RdHi = state->Reg[nRdHi];
  RdLo = state->Reg[nRdLo];
d3472 1
a3472 1
  scount = Multiply64 (state, instr, msigned, LDEFAULT);
d3474 1
a3474 1
  RdLo = Add32 (RdLo, state->Reg[nRdLo], &carry);
d3480 6
a3485 7
  if (scc)
    {
      if ((RdHi == 0) && (RdLo == 0))
	ARMul_NegZero (state, RdHi);	/* zero value */
      else
	ARMul_NegZero (state, scc);	/* non-zero value */
    }
d3487 1
a3487 1
  return scount + 1;		/* extra cycle for addition */
@


