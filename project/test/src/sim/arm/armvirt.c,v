head	1.13;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.13
	gdb_7_6-2013-04-26-release:1.13
	gdb_7_6-branch:1.13.0.2
	gdb_7_6-2013-03-12-branchpoint:1.13
	gdb_7_5_1-2012-11-29-release:1.11
	gdb_7_5-2012-08-17-release:1.11
	gdb_7_5-branch:1.11.0.60
	gdb_7_5-2012-07-18-branchpoint:1.11
	gdb_7_4_1-2012-04-26-release:1.11
	gdb_7_4-2012-01-24-release:1.11
	gdb_7_4-branch:1.11.0.58
	gdb_7_4-2011-12-13-branchpoint:1.11
	gdb_7_3_1-2011-09-04-release:1.11
	gdb_7_3-2011-07-26-release:1.11
	gdb_7_3-branch:1.11.0.56
	gdb_7_3-2011-04-01-branchpoint:1.11
	gdb_7_2-2010-09-02-release:1.11
	gdb_7_2-branch:1.11.0.54
	gdb_7_2-2010-07-07-branchpoint:1.11
	gdb_7_1-2010-03-18-release:1.11
	gdb_7_1-branch:1.11.0.52
	gdb_7_1-2010-02-18-branchpoint:1.11
	gdb_7_0_1-2009-12-22-release:1.11
	gdb_7_0-2009-10-06-release:1.11
	gdb_7_0-branch:1.11.0.50
	gdb_7_0-2009-09-16-branchpoint:1.11
	arc-sim-20090309:1.11
	msnyder-checkpoint-072509-branch:1.11.0.48
	msnyder-checkpoint-072509-branchpoint:1.11
	arc-insight_6_8-branch:1.11.0.46
	arc-insight_6_8-branchpoint:1.11
	insight_6_8-branch:1.11.0.44
	insight_6_8-branchpoint:1.11
	reverse-20081226-branch:1.11.0.42
	reverse-20081226-branchpoint:1.11
	multiprocess-20081120-branch:1.11.0.40
	multiprocess-20081120-branchpoint:1.11
	reverse-20080930-branch:1.11.0.38
	reverse-20080930-branchpoint:1.11
	reverse-20080717-branch:1.11.0.36
	reverse-20080717-branchpoint:1.11
	msnyder-reverse-20080609-branch:1.11.0.34
	msnyder-reverse-20080609-branchpoint:1.11
	drow-reverse-20070409-branch:1.11.0.32
	drow-reverse-20070409-branchpoint:1.11
	gdb_6_8-2008-03-27-release:1.11
	gdb_6_8-branch:1.11.0.30
	gdb_6_8-2008-02-26-branchpoint:1.11
	gdb_6_7_1-2007-10-29-release:1.11
	gdb_6_7-2007-10-10-release:1.11
	gdb_6_7-branch:1.11.0.28
	gdb_6_7-2007-09-07-branchpoint:1.11
	insight_6_6-20070208-release:1.11
	gdb_6_6-2006-12-18-release:1.11
	gdb_6_6-branch:1.11.0.26
	gdb_6_6-2006-11-15-branchpoint:1.11
	insight_6_5-20061003-release:1.11
	gdb-csl-symbian-6_4_50_20060226-12:1.11
	gdb-csl-sourcerygxx-3_4_4-25:1.11
	nickrob-async-20060828-mergepoint:1.11
	gdb-csl-symbian-6_4_50_20060226-11:1.11
	gdb-csl-sourcerygxx-4_1-17:1.11
	gdb-csl-20060226-branch-local-2:1.11
	gdb-csl-sourcerygxx-4_1-14:1.11
	gdb-csl-sourcerygxx-4_1-13:1.11
	gdb-csl-sourcerygxx-4_1-12:1.11
	gdb-csl-sourcerygxx-3_4_4-21:1.11
	gdb_6_5-20060621-release:1.11
	gdb-csl-sourcerygxx-4_1-9:1.11
	gdb-csl-sourcerygxx-4_1-8:1.11
	gdb-csl-sourcerygxx-4_1-7:1.11
	gdb-csl-arm-2006q1-6:1.11
	gdb-csl-sourcerygxx-4_1-6:1.11
	gdb-csl-symbian-6_4_50_20060226-10:1.11
	gdb-csl-symbian-6_4_50_20060226-9:1.11
	gdb-csl-symbian-6_4_50_20060226-8:1.11
	gdb-csl-coldfire-4_1-11:1.11
	gdb-csl-sourcerygxx-3_4_4-19:1.11
	gdb-csl-coldfire-4_1-10:1.11
	gdb_6_5-branch:1.11.0.24
	gdb_6_5-2006-05-14-branchpoint:1.11
	gdb-csl-sourcerygxx-4_1-5:1.11
	nickrob-async-20060513-branch:1.11.0.22
	nickrob-async-20060513-branchpoint:1.11
	gdb-csl-sourcerygxx-4_1-4:1.11
	msnyder-reverse-20060502-branch:1.11.0.20
	msnyder-reverse-20060502-branchpoint:1.11
	gdb-csl-morpho-4_1-4:1.11
	gdb-csl-sourcerygxx-3_4_4-17:1.11
	readline_5_1-import-branch:1.11.0.18
	readline_5_1-import-branchpoint:1.11
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.11
	gdb-csl-symbian-20060226-branch:1.11.0.16
	gdb-csl-symbian-20060226-branchpoint:1.11
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.11
	msnyder-reverse-20060331-branch:1.11.0.14
	msnyder-reverse-20060331-branchpoint:1.11
	gdb-csl-available-20060303-branch:1.11.0.12
	gdb-csl-available-20060303-branchpoint:1.11
	gdb-csl-20060226-branch:1.11.0.10
	gdb-csl-20060226-branchpoint:1.11
	gdb_6_4-20051202-release:1.11
	msnyder-fork-checkpoint-branch:1.11.0.8
	msnyder-fork-checkpoint-branchpoint:1.11
	gdb-csl-gxxpro-6_3-branch:1.11.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.11
	gdb_6_4-branch:1.11.0.4
	gdb_6_4-2005-11-01-branchpoint:1.11
	gdb-csl-arm-20051020-branch:1.11.0.2
	gdb-csl-arm-20051020-branchpoint:1.11
	msnyder-tracepoint-checkpoint-branch:1.10.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.10
	gdb-csl-arm-20050325-2005-q1b:1.9
	gdb-csl-arm-20050325-2005-q1a:1.9
	csl-arm-20050325-branch:1.9.0.42
	csl-arm-20050325-branchpoint:1.9
	gdb_6_3-20041109-release:1.9
	gdb_6_3-branch:1.9.0.38
	gdb_6_3-20041019-branchpoint:1.9
	drow_intercu-merge-20040921:1.9
	drow_intercu-merge-20040915:1.9
	jimb-gdb_6_2-e500-branch:1.9.0.40
	jimb-gdb_6_2-e500-branchpoint:1.9
	gdb_6_2-20040730-release:1.9
	gdb_6_2-branch:1.9.0.36
	gdb_6_2-2004-07-10-gmt-branchpoint:1.9
	gdb_6_1_1-20040616-release:1.9
	gdb_6_1-2004-04-05-release:1.9
	drow_intercu-merge-20040402:1.9
	drow_intercu-merge-20040327:1.9
	ezannoni_pie-20040323-branch:1.9.0.34
	ezannoni_pie-20040323-branchpoint:1.9
	cagney_tramp-20040321-mergepoint:1.9
	cagney_tramp-20040309-branch:1.9.0.32
	cagney_tramp-20040309-branchpoint:1.9
	gdb_6_1-branch:1.9.0.30
	gdb_6_1-2004-03-01-gmt-branchpoint:1.9
	drow_intercu-20040221-branch:1.9.0.28
	drow_intercu-20040221-branchpoint:1.9
	cagney_bfdfile-20040213-branch:1.9.0.26
	cagney_bfdfile-20040213-branchpoint:1.9
	drow-cplus-merge-20040208:1.9
	carlton_dictionary-20040126-merge:1.9
	cagney_bigcore-20040122-branch:1.9.0.24
	cagney_bigcore-20040122-branchpoint:1.9
	drow-cplus-merge-20040113:1.9
	drow-cplus-merge-20031224:1.9
	drow-cplus-merge-20031220:1.9
	carlton_dictionary-20031215-merge:1.9
	drow-cplus-merge-20031214:1.9
	carlton-dictionary-20031111-merge:1.9
	gdb_6_0-2003-10-04-release:1.9
	kettenis_sparc-20030918-branch:1.9.0.22
	kettenis_sparc-20030918-branchpoint:1.9
	carlton_dictionary-20030917-merge:1.9
	ezannoni_pie-20030916-branchpoint:1.9
	ezannoni_pie-20030916-branch:1.9.0.20
	cagney_x86i386-20030821-branch:1.9.0.18
	cagney_x86i386-20030821-branchpoint:1.9
	carlton_dictionary-20030805-merge:1.9
	carlton_dictionary-20030627-merge:1.9
	gdb_6_0-branch:1.9.0.16
	gdb_6_0-2003-06-23-branchpoint:1.9
	jimb-ppc64-linux-20030613-branch:1.9.0.14
	jimb-ppc64-linux-20030613-branchpoint:1.9
	cagney_convert-20030606-branch:1.9.0.12
	cagney_convert-20030606-branchpoint:1.9
	cagney_writestrings-20030508-branch:1.9.0.10
	cagney_writestrings-20030508-branchpoint:1.9
	jimb-ppc64-linux-20030528-branch:1.9.0.8
	jimb-ppc64-linux-20030528-branchpoint:1.9
	carlton_dictionary-20030523-merge:1.9
	cagney_fileio-20030521-branch:1.9.0.6
	cagney_fileio-20030521-branchpoint:1.9
	kettenis_i386newframe-20030517-mergepoint:1.9
	jimb-ppc64-linux-20030509-branch:1.9.0.4
	jimb-ppc64-linux-20030509-branchpoint:1.9
	kettenis_i386newframe-20030504-mergepoint:1.9
	carlton_dictionary-20030430-merge:1.9
	kettenis_i386newframe-20030419-branch:1.9.0.2
	kettenis_i386newframe-20030419-branchpoint:1.9
	carlton_dictionary-20030416-merge:1.9
	cagney_frameaddr-20030409-mergepoint:1.8
	kettenis_i386newframe-20030406-branch:1.8.0.30
	kettenis_i386newframe-20030406-branchpoint:1.8
	cagney_frameaddr-20030403-branchpoint:1.8
	cagney_frameaddr-20030403-branch:1.8.0.28
	cagney_framebase-20030330-mergepoint:1.8
	cagney_framebase-20030326-branch:1.8.0.26
	cagney_framebase-20030326-branchpoint:1.8
	cagney_lazyid-20030317-branch:1.8.0.24
	cagney_lazyid-20030317-branchpoint:1.8
	kettenis-i386newframe-20030316-mergepoint:1.8
	offbyone-20030313-branch:1.8.0.22
	offbyone-20030313-branchpoint:1.8
	kettenis-i386newframe-20030308-branch:1.8.0.20
	kettenis-i386newframe-20030308-branchpoint:1.8
	carlton_dictionary-20030305-merge:1.8
	cagney_offbyone-20030303-branch:1.8.0.18
	cagney_offbyone-20030303-branchpoint:1.8
	carlton_dictionary-20030207-merge:1.8
	interps-20030202-branch:1.8.0.16
	interps-20030202-branchpoint:1.8
	cagney-unwind-20030108-branch:1.8.0.14
	cagney-unwind-20030108-branchpoint:1.8
	carlton_dictionary-20021223-merge:1.8
	gdb_5_3-2002-12-12-release:1.8
	carlton_dictionary-20021115-merge:1.8
	kseitz_interps-20021105-merge:1.8
	kseitz_interps-20021103-merge:1.8
	drow-cplus-merge-20021020:1.8
	drow-cplus-merge-20021025:1.8
	carlton_dictionary-20021025-merge:1.8
	carlton_dictionary-20021011-merge:1.8
	drow-cplus-branch:1.8.0.12
	drow-cplus-branchpoint:1.8
	kseitz_interps-20020930-merge:1.8
	carlton_dictionary-20020927-merge:1.8
	carlton_dictionary-branch:1.8.0.10
	carlton_dictionary-20020920-branchpoint:1.8
	gdb_5_3-branch:1.8.0.8
	gdb_5_3-2002-09-04-branchpoint:1.8
	kseitz_interps-20020829-merge:1.8
	cagney_sysregs-20020825-branch:1.8.0.6
	cagney_sysregs-20020825-branchpoint:1.8
	readline_4_3-import-branch:1.8.0.4
	readline_4_3-import-branchpoint:1.8
	gdb_5_2_1-2002-07-23-release:1.7
	kseitz_interps-20020528-branch:1.8.0.2
	kseitz_interps-20020528-branchpoint:1.8
	cagney_regbuf-20020515-branch:1.7.0.12
	cagney_regbuf-20020515-branchpoint:1.7
	jimb-macro-020506-branch:1.7.0.10
	jimb-macro-020506-branchpoint:1.7
	gdb_5_2-2002-04-29-release:1.7
	gdb_5_2-branch:1.7.0.8
	gdb_5_2-2002-03-03-branchpoint:1.7
	gdb_5_1_1-2002-01-24-release:1.7
	gdb_5_1_0_1-2002-01-03-release:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.7.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.7
	gdb_5_1-2001-11-21-release:1.7
	gdb_s390-2001-09-26-branch:1.7.0.4
	gdb_s390-2001-09-26-branchpoint:1.7
	gdb_5_1-2001-07-29-branch:1.7.0.2
	gdb_5_1-2001-07-29-branchpoint:1.7
	insight-precleanup-2001-01-01:1.3
	gdb-premipsmulti-2000-06-06-branch:1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.13
date	2012.12.19.07.18.14;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2012.12.19.07.11.59;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2005.09.19.14.21.08;	author pbrook;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.12.07.36.59;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.13.08.54.06;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.27.14.12.00;	author nickc;	state Exp;
branches
	1.8.10.1
	1.8.12.1;
next	1.7;

1.7
date	2001.04.18.16.39.37;	author mrg;	state Exp;
branches
	1.7.12.1;
next	1.6;

1.6
date	2001.03.20.17.48.02;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.28.01.04.24;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.01.00.14.40;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.04.08.00.19;	author aoliva;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.08.20.54.27;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.55;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.8.10.1
date	2003.04.16.19.57.08;	author carlton;	state Exp;
branches;
next	;

1.8.12.1
date	2003.12.14.20.28.17;	author drow;	state Exp;
branches;
next	;

1.7.12.1
date	2002.06.15.16.43.22;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.55;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.02.05.07.30.19;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.13
log
@[sim] Update old contact info in GPL license notices

sim/ChangeLog:

        Update old contact info in GPL license notices.
@
text
@/*  armvirt.c -- ARMulator virtual memory interace:  ARM6 Instruction Emulator.
    Copyright (C) 1994 Advanced RISC Machines Ltd.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, see <http://www.gnu.org/licenses/>. */

/* This file contains a complete ARMulator memory model, modelling a
"virtual memory" system. A much simpler model can be found in armfast.c,
and that model goes faster too, but has a fixed amount of memory. This
model's memory has 64K pages, allocated on demand from a 64K entry page
table. The routines PutWord and GetWord implement this. Pages are never
freed as they might be needed again. A single area of memory may be
defined to generate aborts. */

#include "armopts.h"
#include "armos.h"
#include "armdefs.h"
#include "ansidecl.h"

#ifdef VALIDATE			/* for running the validate suite */
#define TUBE 48 * 1024 * 1024	/* write a char on the screen */
#define ABORTS 1
#endif

/* #define ABORTS */

#ifdef ABORTS			/* the memory system will abort */
/* For the old test suite Abort between 32 Kbytes and 32 Mbytes
   For the new test suite Abort between 8 Mbytes and 26 Mbytes */
/* #define LOWABORT 32 * 1024
#define HIGHABORT 32 * 1024 * 1024 */
#define LOWABORT 8 * 1024 * 1024
#define HIGHABORT 26 * 1024 * 1024

#endif

#define NUMPAGES 64 * 1024
#define PAGESIZE 64 * 1024
#define PAGEBITS 16
#define OFFSETBITS 0xffff

int SWI_vector_installed = FALSE;

/***************************************************************************\
*        Get a Word from Virtual Memory, maybe allocating the page          *
\***************************************************************************/

static ARMword
GetWord (ARMul_State * state, ARMword address, int check)
{
  ARMword page;
  ARMword offset;
  ARMword **pagetable;
  ARMword *pageptr;

  if (check && state->is_XScale)
    XScale_check_memacc (state, &address, 0);

  page = address >> PAGEBITS;
  offset = (address & OFFSETBITS) >> 2;
  pagetable = (ARMword **) state->MemDataPtr;
  pageptr = *(pagetable + page);

  if (pageptr == NULL)
    {
      pageptr = (ARMword *) malloc (PAGESIZE);

      if (pageptr == NULL)
	{
	  perror ("ARMulator can't allocate VM page");
	  exit (12);
	}

      *(pagetable + page) = pageptr;
    }

  return *(pageptr + offset);
}

/***************************************************************************\
*        Put a Word into Virtual Memory, maybe allocating the page          *
\***************************************************************************/

static void
PutWord (ARMul_State * state, ARMword address, ARMword data, int check)
{
  ARMword page;
  ARMword offset;
  ARMword **pagetable;
  ARMword *pageptr;

  if (check && state->is_XScale)
    XScale_check_memacc (state, &address, 1);

  page = address >> PAGEBITS;
  offset = (address & OFFSETBITS) >> 2;
  pagetable = (ARMword **) state->MemDataPtr;
  pageptr = *(pagetable + page);

  if (pageptr == NULL)
    {
      pageptr = (ARMword *) malloc (PAGESIZE);
      if (pageptr == NULL)
	{
	  perror ("ARMulator can't allocate VM page");
	  exit (13);
	}

      *(pagetable + page) = pageptr;
    }

  if (address == 0x8)
    SWI_vector_installed = TRUE;

  *(pageptr + offset) = data;
}

/***************************************************************************\
*                      Initialise the memory interface                      *
\***************************************************************************/

unsigned
ARMul_MemoryInit (ARMul_State * state, unsigned long initmemsize)
{
  ARMword **pagetable;
  unsigned page;

  if (initmemsize)
    state->MemSize = initmemsize;

  pagetable = (ARMword **) malloc (sizeof (ARMword *) * NUMPAGES);

  if (pagetable == NULL)
    return FALSE;

  for (page = 0; page < NUMPAGES; page++)
    *(pagetable + page) = NULL;

  state->MemDataPtr = (unsigned char *) pagetable;

  ARMul_ConsolePrint (state, ", 4 Gb memory");

  return TRUE;
}

/***************************************************************************\
*                         Remove the memory interface                       *
\***************************************************************************/

void
ARMul_MemoryExit (ARMul_State * state)
{
  ARMword page;
  ARMword **pagetable;
  ARMword *pageptr;

  pagetable = (ARMword **) state->MemDataPtr;
  for (page = 0; page < NUMPAGES; page++)
    {
      pageptr = *(pagetable + page);
      if (pageptr != NULL)
	free ((char *) pageptr);
    }
  free ((char *) pagetable);
  return;
}

/***************************************************************************\
*                   ReLoad Instruction                                     *
\***************************************************************************/

ARMword
ARMul_ReLoadInstr (ARMul_State * state, ARMword address, ARMword isize)
{
#ifdef ABORTS
  if (address >= LOWABORT && address < HIGHABORT)
    {
      ARMul_PREFETCHABORT (address);
      return ARMul_ABORTWORD;
    }
  else
    {
      ARMul_CLEARABORT;
    }
#endif

  if ((isize == 2) && (address & 0x2))
    {
      /* We return the next two halfwords: */
      ARMword lo = GetWord (state, address, FALSE);
      ARMword hi = GetWord (state, address + 4, FALSE);

      if (state->bigendSig == HIGH)
	return (lo << 16) | (hi >> 16);
      else
	return ((hi & 0xFFFF) << 16) | (lo >> 16);
    }

  return GetWord (state, address, TRUE);
}

/***************************************************************************\
*                   Load Instruction, Sequential Cycle                      *
\***************************************************************************/

ARMword ARMul_LoadInstrS (ARMul_State * state, ARMword address, ARMword isize)
{
  state->NumScycles++;

#ifdef HOURGLASS
  if ((state->NumScycles & HOURGLASS_RATE) == 0)
    {
      HOURGLASS;
    }
#endif

  return ARMul_ReLoadInstr (state, address, isize);
}

/***************************************************************************\
*                 Load Instruction, Non Sequential Cycle                    *
\***************************************************************************/

ARMword ARMul_LoadInstrN (ARMul_State * state, ARMword address, ARMword isize)
{
  state->NumNcycles++;

  return ARMul_ReLoadInstr (state, address, isize);
}

/***************************************************************************\
*                      Read Word (but don't tell anyone!)                   *
\***************************************************************************/

ARMword ARMul_ReadWord (ARMul_State * state, ARMword address)
{
#ifdef ABORTS
  if (address >= LOWABORT && address < HIGHABORT)
    {
      ARMul_DATAABORT (address);
      return ARMul_ABORTWORD;
    }
  else
    {
      ARMul_CLEARABORT;
    }
#endif

  return GetWord (state, address, TRUE);
}

/***************************************************************************\
*                        Load Word, Sequential Cycle                        *
\***************************************************************************/

ARMword ARMul_LoadWordS (ARMul_State * state, ARMword address)
{
  state->NumScycles++;

  return ARMul_ReadWord (state, address);
}

/***************************************************************************\
*                      Load Word, Non Sequential Cycle                      *
\***************************************************************************/

ARMword ARMul_LoadWordN (ARMul_State * state, ARMword address)
{
  state->NumNcycles++;

  return ARMul_ReadWord (state, address);
}

/***************************************************************************\
*                     Load Halfword, (Non Sequential Cycle)                 *
\***************************************************************************/

ARMword ARMul_LoadHalfWord (ARMul_State * state, ARMword address)
{
  ARMword temp, offset;

  state->NumNcycles++;

  temp = ARMul_ReadWord (state, address);
  offset = (((ARMword) state->bigendSig * 2) ^ (address & 2)) << 3;	/* bit offset into the word */

  return (temp >> offset) & 0xffff;
}

/***************************************************************************\
*                      Read Byte (but don't tell anyone!)                   *
\***************************************************************************/

ARMword ARMul_ReadByte (ARMul_State * state, ARMword address)
{
  ARMword temp, offset;

  temp = ARMul_ReadWord (state, address);
  offset = (((ARMword) state->bigendSig * 3) ^ (address & 3)) << 3;	/* bit offset into the word */

  return (temp >> offset & 0xffL);
}

/***************************************************************************\
*                     Load Byte, (Non Sequential Cycle)                     *
\***************************************************************************/

ARMword ARMul_LoadByte (ARMul_State * state, ARMword address)
{
  state->NumNcycles++;

  return ARMul_ReadByte (state, address);
}

/***************************************************************************\
*                     Write Word (but don't tell anyone!)                   *
\***************************************************************************/

void
ARMul_WriteWord (ARMul_State * state, ARMword address, ARMword data)
{
#ifdef ABORTS
  if (address >= LOWABORT && address < HIGHABORT)
    {
      ARMul_DATAABORT (address);
      return;
    }
  else
    {
      ARMul_CLEARABORT;
    }
#endif

  PutWord (state, address, data, TRUE);
}

/***************************************************************************\
*                       Store Word, Sequential Cycle                        *
\***************************************************************************/

void
ARMul_StoreWordS (ARMul_State * state, ARMword address, ARMword data)
{
  state->NumScycles++;

  ARMul_WriteWord (state, address, data);
}

/***************************************************************************\
*                       Store Word, Non Sequential Cycle                        *
\***************************************************************************/

void
ARMul_StoreWordN (ARMul_State * state, ARMword address, ARMword data)
{
  state->NumNcycles++;

  ARMul_WriteWord (state, address, data);
}

/***************************************************************************\
*                    Store HalfWord, (Non Sequential Cycle)                 *
\***************************************************************************/

void
ARMul_StoreHalfWord (ARMul_State * state, ARMword address, ARMword data)
{
  ARMword temp, offset;

  state->NumNcycles++;

#ifdef VALIDATE
  if (address == TUBE)
    {
      if (data == 4)
	state->Emulate = FALSE;
      else
	(void) putc ((char) data, stderr);	/* Write Char */
      return;
    }
#endif

  temp = ARMul_ReadWord (state, address);
  offset = (((ARMword) state->bigendSig * 2) ^ (address & 2)) << 3;	/* bit offset into the word */

  PutWord (state, address,
	   (temp & ~(0xffffL << offset)) | ((data & 0xffffL) << offset),
	   TRUE);
}

/***************************************************************************\
*                     Write Byte (but don't tell anyone!)                   *
\***************************************************************************/

void
ARMul_WriteByte (ARMul_State * state, ARMword address, ARMword data)
{
  ARMword temp, offset;

  temp = ARMul_ReadWord (state, address);
  offset = (((ARMword) state->bigendSig * 3) ^ (address & 3)) << 3;	/* bit offset into the word */

  PutWord (state, address,
	   (temp & ~(0xffL << offset)) | ((data & 0xffL) << offset),
	   TRUE);
}

/***************************************************************************\
*                    Store Byte, (Non Sequential Cycle)                     *
\***************************************************************************/

void
ARMul_StoreByte (ARMul_State * state, ARMword address, ARMword data)
{
  state->NumNcycles++;

#ifdef VALIDATE
  if (address == TUBE)
    {
      if (data == 4)
	state->Emulate = FALSE;
      else
	(void) putc ((char) data, stderr);	/* Write Char */
      return;
    }
#endif

  ARMul_WriteByte (state, address, data);
}

/***************************************************************************\
*                   Swap Word, (Two Non Sequential Cycles)                  *
\***************************************************************************/

ARMword ARMul_SwapWord (ARMul_State * state, ARMword address, ARMword data)
{
  ARMword temp;

  state->NumNcycles++;

  temp = ARMul_ReadWord (state, address);

  state->NumNcycles++;

  PutWord (state, address, data, TRUE);

  return temp;
}

/***************************************************************************\
*                   Swap Byte, (Two Non Sequential Cycles)                  *
\***************************************************************************/

ARMword ARMul_SwapByte (ARMul_State * state, ARMword address, ARMword data)
{
  ARMword temp;

  temp = ARMul_LoadByte (state, address);
  ARMul_StoreByte (state, address, data);

  return temp;
}

/***************************************************************************\
*                             Count I Cycles                                *
\***************************************************************************/

void
ARMul_Icycles (ARMul_State * state, unsigned number, ARMword address ATTRIBUTE_UNUSED)
{
  state->NumIcycles += number;
  ARMul_CLEARABORT;
}

/***************************************************************************\
*                             Count C Cycles                                *
\***************************************************************************/

void
ARMul_Ccycles (ARMul_State * state, unsigned number, ARMword address ATTRIBUTE_UNUSED)
{
  state->NumCcycles += number;
  ARMul_CLEARABORT;
}


/* Read a byte.  Do not check for alignment or access errors.  */

ARMword
ARMul_SafeReadByte (ARMul_State * state, ARMword address)
{
  ARMword temp, offset;

  temp = GetWord (state, address, FALSE);
  offset = (((ARMword) state->bigendSig * 3) ^ (address & 3)) << 3;

  return (temp >> offset & 0xffL);
}

void
ARMul_SafeWriteByte (ARMul_State * state, ARMword address, ARMword data)
{
  ARMword temp, offset;

  temp = GetWord (state, address, FALSE);
  offset = (((ARMword) state->bigendSig * 3) ^ (address & 3)) << 3;

  PutWord (state, address,
	   (temp & ~(0xffL << offset)) | ((data & 0xffL) << offset),
	   FALSE);
}
@


1.12
log
@Update sim copyright headers from GPLv2-or-later to GPLv3-or-later.

gdb/sim/ChangeLog:

        Update the non-FSF-copyrighted files in sim to GPLv3 or later.
@
text
@d15 1
a15 2
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA. */
@


1.11
log
@2005-09-19  Paul Brook  <paul@@codesourcery.com>

	* armdefs.h: Define ARMsword and ARMsdword. Use stdint.h when
	available.
	* armemu.c: Use them.
	* armvirt.c (ARMul_MemoryInit): Use correct type for size.
	* configure.ac: Check for stdint.h.
	* config.in: Regenerate.
	* configure: Regenerate.
@
text
@d6 1
a6 1
    the Free Software Foundation; either version 2 of the License, or
@


1.10
log
@Update the address of the FSF organization
@
text
@d142 1
a142 1
  pagetable = (ARMword **) malloc (sizeof (ARMword) * NUMPAGES);
@


1.9
log
@Only call XScale_check_memacc if in XScale mode.
@
text
@d16 1
a16 1
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
@


1.8
log
@Only perform access checks if 'check' is set.
Report unknown machine numbers.
Formatting tidy ups.
@
text
@d67 1
a67 1
  if (check)
d103 1
a103 1
  if (check)
@


1.8.12.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d67 1
a67 1
  if (check && state->is_XScale)
d103 1
a103 1
  if (check && state->is_XScale)
@


1.8.10.1
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d67 1
a67 1
  if (check && state->is_XScale)
d103 1
a103 1
  if (check && state->is_XScale)
@


1.7
log
@* XScale coprocessor support.

2001-04-18  matthew green  <mrg@@redhat.com>

	* armcopro.c (write_cp15_reg): Set CHANGEMODE if endianness changes.
	(read_cp15_reg): Make non-static.
	(XScale_cp15_LDC): Update for write_cp15_reg() change.
	(XScale_cp15_MCR): Likewise.
	(XScale_cp15_write_reg): Likewise.
	(XScale_check_memacc): New function. Check for breakpoints being
	activated by memory accesses.  Does not support the Branch Target
	Buffer.
	(XScale_set_fsr_far): New function. Set FSR and FAR for XScale.
	(XScale_debug_moe): New function. Set the debug Method Of Entry,
	if configured.
	(write_cp14_reg): Reset count counter if requested.
	* armdefs.h (struct ARMul_State): New members `LastTime' and
	`CP14R0_CCD' used for the timer/counters.
	(ARMul_CP13_R0_FIQ, ARMul_CP13_R0_IRQ, ARMul_CP13_R8_PMUS,
	ARMul_CP14_R0_ENABLE, ARMul_CP14_R0_CLKRST, ARMul_CP14_R0_CCD,
	ARMul_CP14_R0_INTEN0, ARMul_CP14_R0_INTEN1, ARMul_CP14_R0_INTEN2,
	ARMul_CP14_R0_FLAG0, ARMul_CP14_R0_FLAG1, ARMul_CP14_R0_FLAG2,
	ARMul_CP14_R10_MOE_IB, ARMul_CP14_R10_MOE_DB, ARMul_CP14_R10_MOE_BT,
	ARMul_CP15_R1_ENDIAN, ARMul_CP15_R1_ALIGN, ARMul_CP15_R5_X,
	ARMul_CP15_R5_ST_ALIGN, ARMul_CP15_R5_IMPRE, ARMul_CP15_R5_MMU_EXCPT,
	ARMul_CP15_DBCON_M, ARMul_CP15_DBCON_E1, ARMul_CP15_DBCON_E0): New
	defines for XScale registers.
	(XScale_check_memacc, XScale_set_fsr_far, XScale_debug_moe): Prototype.
	(ARMul_Emulate32, ARMul_Emulate26): Clean up function definition.
	(ARMul_Emulate32): Handle the clock counter and hardware instruction
	breakpoints.  Call XScale_set_fsr_far() for software breakpoints and
	software interrupts.
	(LoadMult): Call XScale_set_fsr_far() for data aborts.
	(LoadSMult): Likewise.
	(StoreMult): Likewise.
	(StoreSMult): Likewise.
	* armemu.h (write_cp15_reg): Update prototype.
	* arminit.c (ARMul_NewState): Initialise CP14R0_CCD and LastTime.
	(ARMul_Abort): If XScale, check for FIQ and IRQ being enabled in CP13
	register 0.
	* armvirt.c (GetWord): Call XScale_check_memacc().
	(PutWord): Likewise.
@
text
@d67 2
a68 1
  XScale_check_memacc (state, &address, 0);
d103 2
a104 1
  XScale_check_memacc (state, &address, 1);
@


1.7.12.1
log
@merge from trunk
@
text
@d67 1
a67 2
  if (check)
    XScale_check_memacc (state, &address, 0);
d102 1
a102 2
  if (check)
    XScale_check_memacc (state, &address, 1);
@


1.6
log
@Do not enable alignment checking when loading unaligned thumb instructions.
@
text
@d67 2
d101 2
@


1.5
log
@Add support for disabling alignment checks when performing GDB interface
calls or SWI emulaiton routines.  (Alignment checking code has not yet been
contributed).
@
text
@d195 2
a196 2
      ARMword lo = GetWord (state, address, TRUE);
      ARMword hi = GetWord (state, address + 4, TRUE);
@


1.4
log
@Detect installation of SWI vector by running program as well as loading program.
@
text
@d27 1
d60 1
a60 1
GetWord (ARMul_State * state, ARMword address)
d93 1
a93 1
PutWord (ARMul_State * state, ARMword address, ARMword data)
d195 2
a196 2
      ARMword lo = GetWord (state, address);
      ARMword hi = GetWord (state, address + 4);
d204 1
a204 1
  return GetWord (state, address);
d254 1
a254 1
  return GetWord (state, address);
d339 1
a339 1
  PutWord (state, address, data);
d392 2
a393 1
	   (temp & ~(0xffffL << offset)) | ((data & 0xffffL) << offset));
d409 2
a410 1
	   (temp & ~(0xffL << offset)) | ((data & 0xffL) << offset));
d450 1
a450 1
  PutWord (state, address, data);
d489 27
@


1.3
log
@* armvirt.c (ABORTS): Do not define.
@
text
@d52 2
d115 3
@


1.2
log
@Fix compile time warning messages.
@
text
@d35 1
a35 1
#define ABORTS
@


1.1
log
@Initial revision
@
text
@d28 1
d30 2
a31 2
#ifdef VALIDATE /* for running the validate suite */
#define TUBE 48 * 1024 * 1024 /* write a char on the screen */
d37 1
a37 1
#ifdef ABORTS /* the memory system will abort */
d59 4
a62 4
  ARMword    page;
  ARMword    offset;
  ARMword ** pagetable;
  ARMword *  pageptr;
d64 2
a65 2
  page      = address >> PAGEBITS;
  offset    = (address & OFFSETBITS) >> 2;
d67 2
a68 2
  pageptr   = *(pagetable + page);
  
d72 1
a72 1
      
d78 1
a78 1
      
d81 1
a81 1
  
d92 10
a101 10
  ARMword    page;
  ARMword    offset;
  ARMword ** pagetable;
  ARMword *  pageptr;
  
  page      = address >> PAGEBITS;
  offset    = (address & OFFSETBITS) >> 2;
  pagetable = (ARMword **)state->MemDataPtr;
  pageptr   = *(pagetable + page);
  
d108 1
a108 1
	  exit(13);
d110 1
a110 1
      
d113 1
a113 1
  
d124 2
a125 2
  ARMword ** pagetable;
  unsigned   page;
d129 1
a129 1
  
d131 1
a131 1
  
d134 2
a135 2
  
  for (page = 0 ; page < NUMPAGES ; page++)
d137 2
a138 2
  
  state->MemDataPtr = (unsigned char *)pagetable;
d141 2
a142 2
  
 return TRUE;
d152 3
a154 3
  ARMword    page;
  ARMword ** pagetable;
  ARMword *  pageptr;
d156 2
a157 2
  pagetable = (ARMword **)state->MemDataPtr;
  for (page = 0 ; page < NUMPAGES ; page++)
d161 1
a161 1
	free ((char *)pageptr);
d163 1
a163 1
  free ((char *)pagetable);
d175 1
a175 1
  if (address >= LOWABORT && address < HIGHABORT) 
d180 4
a183 4
 else
   {
     ARMul_CLEARABORT;
   }
d186 11
a196 11
 if ((isize == 2) && (address & 0x2))
   {
     /* We return the next two halfwords: */
     ARMword lo = GetWord (state, address);
     ARMword hi = GetWord (state, address + 4);

     if (state->bigendSig == HIGH)
       return (lo << 16) | (hi >> 16);
     else
       return ((hi & 0xFFFF) << 16) | (lo >> 16);
   }
d205 1
a205 2
ARMword
ARMul_LoadInstrS (ARMul_State * state, ARMword address, ARMword isize)
d207 1
a207 1
  state->NumScycles ++;
d210 1
a210 1
  if (( state->NumScycles & HOURGLASS_RATE ) == 0)
d223 1
a223 2
ARMword
ARMul_LoadInstrN (ARMul_State * state, ARMword address, ARMword isize)
d225 1
a225 1
  state->NumNcycles ++;
d234 1
a234 2
ARMword
ARMul_ReadWord (ARMul_State * state, ARMword address)
d255 1
a255 2
ARMword
ARMul_LoadWordS (ARMul_State * state, ARMword address)
d257 1
a257 1
  state->NumScycles ++;
d266 1
a266 2
ARMword
ARMul_LoadWordN (ARMul_State * state, ARMword address)
d268 2
a269 2
  state->NumNcycles ++;
  
d277 1
a277 2
ARMword
ARMul_LoadHalfWord (ARMul_State * state, ARMword address)
d281 1
a281 1
  state->NumNcycles ++;
d283 2
a284 2
  temp   = ARMul_ReadWord (state, address);
  offset = (((ARMword)state->bigendSig * 2) ^ (address & 2)) << 3; /* bit offset into the word */
d293 1
a293 2
ARMword
ARMul_ReadByte (ARMul_State * state, ARMword address)
d297 2
a298 2
 temp   = ARMul_ReadWord (state, address);
 offset = (((ARMword)state->bigendSig * 3) ^ (address & 3)) << 3; /* bit offset into the word */
d300 1
a300 1
 return (temp >> offset & 0xffL);
d307 1
a307 2
ARMword
ARMul_LoadByte (ARMul_State * state, ARMword address)
d309 1
a309 1
  state->NumNcycles ++;
d343 1
a343 1
  state->NumScycles ++;
d355 1
a355 1
  state->NumNcycles ++;
d369 2
a370 2
  state->NumNcycles ++;
 
d377 1
a377 1
	(void) putc ((char)data, stderr); /* Write Char */
d382 5
a386 4
  temp   = ARMul_ReadWord (state, address);
  offset = (((ARMword)state->bigendSig * 2) ^ (address & 2)) << 3; /* bit offset into the word */
 
  PutWord (state, address, (temp & ~(0xffffL << offset)) | ((data & 0xffffL) << offset));
d398 5
a402 4
  temp   = ARMul_ReadWord (state, address);
  offset = (((ARMword)state->bigendSig * 3) ^ (address & 3)) << 3; /* bit offset into the word */
  
  PutWord (state, address, (temp & ~(0xffL << offset)) | ((data & 0xffL) << offset));
d412 1
a412 1
  state->NumNcycles ++;
d420 1
a420 1
	(void) putc ((char)data,stderr); /* Write Char */
d432 1
a432 2
ARMword
ARMul_SwapWord (ARMul_State * state, ARMword address, ARMword data)
d436 1
a436 1
  state->NumNcycles ++;
d439 3
a441 3
  
  state->NumNcycles ++;
  
d443 1
a443 1
  
d451 1
a451 2
ARMword
ARMul_SwapByte (ARMul_State * state, ARMword address, ARMword data)
d457 1
a457 1
  
d466 1
a466 1
ARMul_Icycles (ARMul_State * state, unsigned number, ARMword address)
d477 1
a477 1
ARMul_Ccycles (ARMul_State * state, unsigned number, ARMword address)
a481 3



@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-2000-02-04 snapshot
@
text
@d29 2
a30 2
#ifdef VALIDATE			/* for running the validate suite */
#define TUBE 48 * 1024 * 1024	/* write a char on the screen */
d36 1
a36 1
#ifdef ABORTS			/* the memory system will abort */
d58 4
a61 4
  ARMword page;
  ARMword offset;
  ARMword **pagetable;
  ARMword *pageptr;
d63 2
a64 2
  page = address >> PAGEBITS;
  offset = (address & OFFSETBITS) >> 2;
d66 2
a67 2
  pageptr = *(pagetable + page);

d71 1
a71 1

d77 1
a77 1

d80 1
a80 1

d91 10
a100 10
  ARMword page;
  ARMword offset;
  ARMword **pagetable;
  ARMword *pageptr;

  page = address >> PAGEBITS;
  offset = (address & OFFSETBITS) >> 2;
  pagetable = (ARMword **) state->MemDataPtr;
  pageptr = *(pagetable + page);

d107 1
a107 1
	  exit (13);
d109 1
a109 1

d112 1
a112 1

d123 2
a124 2
  ARMword **pagetable;
  unsigned page;
d128 1
a128 1

d130 1
a130 1

d133 2
a134 2

  for (page = 0; page < NUMPAGES; page++)
d136 2
a137 2

  state->MemDataPtr = (unsigned char *) pagetable;
d140 2
a141 2

  return TRUE;
d151 3
a153 3
  ARMword page;
  ARMword **pagetable;
  ARMword *pageptr;
d155 2
a156 2
  pagetable = (ARMword **) state->MemDataPtr;
  for (page = 0; page < NUMPAGES; page++)
d160 1
a160 1
	free ((char *) pageptr);
d162 1
a162 1
  free ((char *) pagetable);
d174 1
a174 1
  if (address >= LOWABORT && address < HIGHABORT)
d179 4
a182 4
  else
    {
      ARMul_CLEARABORT;
    }
d185 11
a195 11
  if ((isize == 2) && (address & 0x2))
    {
      /* We return the next two halfwords: */
      ARMword lo = GetWord (state, address);
      ARMword hi = GetWord (state, address + 4);

      if (state->bigendSig == HIGH)
	return (lo << 16) | (hi >> 16);
      else
	return ((hi & 0xFFFF) << 16) | (lo >> 16);
    }
d204 2
a205 1
ARMword ARMul_LoadInstrS (ARMul_State * state, ARMword address, ARMword isize)
d207 1
a207 1
  state->NumScycles++;
d210 1
a210 1
  if ((state->NumScycles & HOURGLASS_RATE) == 0)
d223 2
a224 1
ARMword ARMul_LoadInstrN (ARMul_State * state, ARMword address, ARMword isize)
d226 1
a226 1
  state->NumNcycles++;
d235 2
a236 1
ARMword ARMul_ReadWord (ARMul_State * state, ARMword address)
d257 2
a258 1
ARMword ARMul_LoadWordS (ARMul_State * state, ARMword address)
d260 1
a260 1
  state->NumScycles++;
d269 2
a270 1
ARMword ARMul_LoadWordN (ARMul_State * state, ARMword address)
d272 2
a273 2
  state->NumNcycles++;

d281 2
a282 1
ARMword ARMul_LoadHalfWord (ARMul_State * state, ARMword address)
d286 1
a286 1
  state->NumNcycles++;
d288 2
a289 2
  temp = ARMul_ReadWord (state, address);
  offset = (((ARMword) state->bigendSig * 2) ^ (address & 2)) << 3;	/* bit offset into the word */
d298 2
a299 1
ARMword ARMul_ReadByte (ARMul_State * state, ARMword address)
d303 2
a304 2
  temp = ARMul_ReadWord (state, address);
  offset = (((ARMword) state->bigendSig * 3) ^ (address & 3)) << 3;	/* bit offset into the word */
d306 1
a306 1
  return (temp >> offset & 0xffL);
d313 2
a314 1
ARMword ARMul_LoadByte (ARMul_State * state, ARMword address)
d316 1
a316 1
  state->NumNcycles++;
d350 1
a350 1
  state->NumScycles++;
d362 1
a362 1
  state->NumNcycles++;
d376 2
a377 2
  state->NumNcycles++;

d384 1
a384 1
	(void) putc ((char) data, stderr);	/* Write Char */
d389 4
a392 5
  temp = ARMul_ReadWord (state, address);
  offset = (((ARMword) state->bigendSig * 2) ^ (address & 2)) << 3;	/* bit offset into the word */

  PutWord (state, address,
	   (temp & ~(0xffffL << offset)) | ((data & 0xffffL) << offset));
d404 4
a407 5
  temp = ARMul_ReadWord (state, address);
  offset = (((ARMword) state->bigendSig * 3) ^ (address & 3)) << 3;	/* bit offset into the word */

  PutWord (state, address,
	   (temp & ~(0xffL << offset)) | ((data & 0xffL) << offset));
d417 1
a417 1
  state->NumNcycles++;
d425 1
a425 1
	(void) putc ((char) data, stderr);	/* Write Char */
d437 2
a438 1
ARMword ARMul_SwapWord (ARMul_State * state, ARMword address, ARMword data)
d442 1
a442 1
  state->NumNcycles++;
d445 3
a447 3

  state->NumNcycles++;

d449 1
a449 1

d457 2
a458 1
ARMword ARMul_SwapByte (ARMul_State * state, ARMword address, ARMword data)
d464 1
a464 1

d489 3
@


