head	1.4;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.4
	gdb_7_6-2013-04-26-release:1.4
	gdb_7_6-branch:1.4.0.2
	gdb_7_6-2013-03-12-branchpoint:1.4
	gdb_7_5_1-2012-11-29-release:1.2
	gdb_7_5-2012-08-17-release:1.2
	gdb_7_5-branch:1.2.0.62
	gdb_7_5-2012-07-18-branchpoint:1.2
	gdb_7_4_1-2012-04-26-release:1.2
	gdb_7_4-2012-01-24-release:1.2
	gdb_7_4-branch:1.2.0.60
	gdb_7_4-2011-12-13-branchpoint:1.2
	gdb_7_3_1-2011-09-04-release:1.2
	gdb_7_3-2011-07-26-release:1.2
	gdb_7_3-branch:1.2.0.58
	gdb_7_3-2011-04-01-branchpoint:1.2
	gdb_7_2-2010-09-02-release:1.2
	gdb_7_2-branch:1.2.0.56
	gdb_7_2-2010-07-07-branchpoint:1.2
	gdb_7_1-2010-03-18-release:1.2
	gdb_7_1-branch:1.2.0.54
	gdb_7_1-2010-02-18-branchpoint:1.2
	gdb_7_0_1-2009-12-22-release:1.2
	gdb_7_0-2009-10-06-release:1.2
	gdb_7_0-branch:1.2.0.52
	gdb_7_0-2009-09-16-branchpoint:1.2
	arc-sim-20090309:1.2
	msnyder-checkpoint-072509-branch:1.2.0.50
	msnyder-checkpoint-072509-branchpoint:1.2
	arc-insight_6_8-branch:1.2.0.48
	arc-insight_6_8-branchpoint:1.2
	insight_6_8-branch:1.2.0.46
	insight_6_8-branchpoint:1.2
	reverse-20081226-branch:1.2.0.44
	reverse-20081226-branchpoint:1.2
	multiprocess-20081120-branch:1.2.0.42
	multiprocess-20081120-branchpoint:1.2
	reverse-20080930-branch:1.2.0.40
	reverse-20080930-branchpoint:1.2
	reverse-20080717-branch:1.2.0.38
	reverse-20080717-branchpoint:1.2
	msnyder-reverse-20080609-branch:1.2.0.36
	msnyder-reverse-20080609-branchpoint:1.2
	drow-reverse-20070409-branch:1.2.0.34
	drow-reverse-20070409-branchpoint:1.2
	gdb_6_8-2008-03-27-release:1.2
	gdb_6_8-branch:1.2.0.32
	gdb_6_8-2008-02-26-branchpoint:1.2
	gdb_6_7_1-2007-10-29-release:1.2
	gdb_6_7-2007-10-10-release:1.2
	gdb_6_7-branch:1.2.0.30
	gdb_6_7-2007-09-07-branchpoint:1.2
	insight_6_6-20070208-release:1.2
	gdb_6_6-2006-12-18-release:1.2
	gdb_6_6-branch:1.2.0.28
	gdb_6_6-2006-11-15-branchpoint:1.2
	insight_6_5-20061003-release:1.2
	gdb-csl-symbian-6_4_50_20060226-12:1.2
	gdb-csl-sourcerygxx-3_4_4-25:1.2
	nickrob-async-20060828-mergepoint:1.2
	gdb-csl-symbian-6_4_50_20060226-11:1.2
	gdb-csl-sourcerygxx-4_1-17:1.2
	gdb-csl-20060226-branch-local-2:1.2
	gdb-csl-sourcerygxx-4_1-14:1.2
	gdb-csl-sourcerygxx-4_1-13:1.2
	gdb-csl-sourcerygxx-4_1-12:1.2
	gdb-csl-sourcerygxx-3_4_4-21:1.2
	gdb_6_5-20060621-release:1.2
	gdb-csl-sourcerygxx-4_1-9:1.2
	gdb-csl-sourcerygxx-4_1-8:1.2
	gdb-csl-sourcerygxx-4_1-7:1.2
	gdb-csl-arm-2006q1-6:1.2
	gdb-csl-sourcerygxx-4_1-6:1.2
	gdb-csl-symbian-6_4_50_20060226-10:1.2
	gdb-csl-symbian-6_4_50_20060226-9:1.2
	gdb-csl-symbian-6_4_50_20060226-8:1.2
	gdb-csl-coldfire-4_1-11:1.2
	gdb-csl-sourcerygxx-3_4_4-19:1.2
	gdb-csl-coldfire-4_1-10:1.2
	gdb_6_5-branch:1.2.0.26
	gdb_6_5-2006-05-14-branchpoint:1.2
	gdb-csl-sourcerygxx-4_1-5:1.2
	nickrob-async-20060513-branch:1.2.0.24
	nickrob-async-20060513-branchpoint:1.2
	gdb-csl-sourcerygxx-4_1-4:1.2
	msnyder-reverse-20060502-branch:1.2.0.22
	msnyder-reverse-20060502-branchpoint:1.2
	gdb-csl-morpho-4_1-4:1.2
	gdb-csl-sourcerygxx-3_4_4-17:1.2
	readline_5_1-import-branch:1.2.0.20
	readline_5_1-import-branchpoint:1.2
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.2
	gdb-csl-symbian-20060226-branch:1.2.0.18
	gdb-csl-symbian-20060226-branchpoint:1.2
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.2
	msnyder-reverse-20060331-branch:1.2.0.16
	msnyder-reverse-20060331-branchpoint:1.2
	gdb-csl-available-20060303-branch:1.2.0.14
	gdb-csl-available-20060303-branchpoint:1.2
	gdb-csl-20060226-branch:1.2.0.12
	gdb-csl-20060226-branchpoint:1.2
	gdb_6_4-20051202-release:1.2
	msnyder-fork-checkpoint-branch:1.2.0.10
	msnyder-fork-checkpoint-branchpoint:1.2
	gdb-csl-gxxpro-6_3-branch:1.2.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.2
	gdb_6_4-branch:1.2.0.6
	gdb_6_4-2005-11-01-branchpoint:1.2
	gdb-csl-arm-20051020-branch:1.2.0.4
	gdb-csl-arm-20051020-branchpoint:1.2
	msnyder-tracepoint-checkpoint-branch:1.2.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.2
	gdb-csl-arm-20050325-2005-q1b:1.1.1.2
	gdb-csl-arm-20050325-2005-q1a:1.1.1.2
	csl-arm-20050325-branch:1.1.1.2.0.88
	csl-arm-20050325-branchpoint:1.1.1.2
	gdb_6_3-20041109-release:1.1.1.2
	gdb_6_3-branch:1.1.1.2.0.84
	gdb_6_3-20041019-branchpoint:1.1.1.2
	drow_intercu-merge-20040921:1.1.1.2
	drow_intercu-merge-20040915:1.1.1.2
	jimb-gdb_6_2-e500-branch:1.1.1.2.0.86
	jimb-gdb_6_2-e500-branchpoint:1.1.1.2
	gdb_6_2-20040730-release:1.1.1.2
	gdb_6_2-branch:1.1.1.2.0.82
	gdb_6_2-2004-07-10-gmt-branchpoint:1.1.1.2
	gdb_6_1_1-20040616-release:1.1.1.2
	gdb_6_1-2004-04-05-release:1.1.1.2
	drow_intercu-merge-20040402:1.1.1.2
	drow_intercu-merge-20040327:1.1.1.2
	ezannoni_pie-20040323-branch:1.1.1.2.0.80
	ezannoni_pie-20040323-branchpoint:1.1.1.2
	cagney_tramp-20040321-mergepoint:1.1.1.2
	cagney_tramp-20040309-branch:1.1.1.2.0.78
	cagney_tramp-20040309-branchpoint:1.1.1.2
	gdb_6_1-branch:1.1.1.2.0.76
	gdb_6_1-2004-03-01-gmt-branchpoint:1.1.1.2
	drow_intercu-20040221-branch:1.1.1.2.0.74
	drow_intercu-20040221-branchpoint:1.1.1.2
	cagney_bfdfile-20040213-branch:1.1.1.2.0.72
	cagney_bfdfile-20040213-branchpoint:1.1.1.2
	drow-cplus-merge-20040208:1.1.1.2
	carlton_dictionary-20040126-merge:1.1.1.2
	cagney_bigcore-20040122-branch:1.1.1.2.0.70
	cagney_bigcore-20040122-branchpoint:1.1.1.2
	drow-cplus-merge-20040113:1.1.1.2
	drow-cplus-merge-20031224:1.1.1.2
	drow-cplus-merge-20031220:1.1.1.2
	carlton_dictionary-20031215-merge:1.1.1.2
	drow-cplus-merge-20031214:1.1.1.2
	carlton-dictionary-20031111-merge:1.1.1.2
	gdb_6_0-2003-10-04-release:1.1.1.2
	kettenis_sparc-20030918-branch:1.1.1.2.0.68
	kettenis_sparc-20030918-branchpoint:1.1.1.2
	carlton_dictionary-20030917-merge:1.1.1.2
	ezannoni_pie-20030916-branchpoint:1.1.1.2
	ezannoni_pie-20030916-branch:1.1.1.2.0.66
	cagney_x86i386-20030821-branch:1.1.1.2.0.64
	cagney_x86i386-20030821-branchpoint:1.1.1.2
	carlton_dictionary-20030805-merge:1.1.1.2
	carlton_dictionary-20030627-merge:1.1.1.2
	gdb_6_0-branch:1.1.1.2.0.62
	gdb_6_0-2003-06-23-branchpoint:1.1.1.2
	jimb-ppc64-linux-20030613-branch:1.1.1.2.0.60
	jimb-ppc64-linux-20030613-branchpoint:1.1.1.2
	cagney_convert-20030606-branch:1.1.1.2.0.58
	cagney_convert-20030606-branchpoint:1.1.1.2
	cagney_writestrings-20030508-branch:1.1.1.2.0.56
	cagney_writestrings-20030508-branchpoint:1.1.1.2
	jimb-ppc64-linux-20030528-branch:1.1.1.2.0.54
	jimb-ppc64-linux-20030528-branchpoint:1.1.1.2
	carlton_dictionary-20030523-merge:1.1.1.2
	cagney_fileio-20030521-branch:1.1.1.2.0.52
	cagney_fileio-20030521-branchpoint:1.1.1.2
	kettenis_i386newframe-20030517-mergepoint:1.1.1.2
	jimb-ppc64-linux-20030509-branch:1.1.1.2.0.50
	jimb-ppc64-linux-20030509-branchpoint:1.1.1.2
	kettenis_i386newframe-20030504-mergepoint:1.1.1.2
	carlton_dictionary-20030430-merge:1.1.1.2
	kettenis_i386newframe-20030419-branch:1.1.1.2.0.48
	kettenis_i386newframe-20030419-branchpoint:1.1.1.2
	carlton_dictionary-20030416-merge:1.1.1.2
	cagney_frameaddr-20030409-mergepoint:1.1.1.2
	kettenis_i386newframe-20030406-branch:1.1.1.2.0.46
	kettenis_i386newframe-20030406-branchpoint:1.1.1.2
	cagney_frameaddr-20030403-branchpoint:1.1.1.2
	cagney_frameaddr-20030403-branch:1.1.1.2.0.44
	cagney_framebase-20030330-mergepoint:1.1.1.2
	cagney_framebase-20030326-branch:1.1.1.2.0.42
	cagney_framebase-20030326-branchpoint:1.1.1.2
	cagney_lazyid-20030317-branch:1.1.1.2.0.40
	cagney_lazyid-20030317-branchpoint:1.1.1.2
	kettenis-i386newframe-20030316-mergepoint:1.1.1.2
	offbyone-20030313-branch:1.1.1.2.0.38
	offbyone-20030313-branchpoint:1.1.1.2
	kettenis-i386newframe-20030308-branch:1.1.1.2.0.36
	kettenis-i386newframe-20030308-branchpoint:1.1.1.2
	carlton_dictionary-20030305-merge:1.1.1.2
	cagney_offbyone-20030303-branch:1.1.1.2.0.34
	cagney_offbyone-20030303-branchpoint:1.1.1.2
	carlton_dictionary-20030207-merge:1.1.1.2
	interps-20030202-branch:1.1.1.2.0.32
	interps-20030202-branchpoint:1.1.1.2
	cagney-unwind-20030108-branch:1.1.1.2.0.30
	cagney-unwind-20030108-branchpoint:1.1.1.2
	carlton_dictionary-20021223-merge:1.1.1.2
	gdb_5_3-2002-12-12-release:1.1.1.2
	carlton_dictionary-20021115-merge:1.1.1.2
	kseitz_interps-20021105-merge:1.1.1.2
	kseitz_interps-20021103-merge:1.1.1.2
	drow-cplus-merge-20021020:1.1.1.2
	drow-cplus-merge-20021025:1.1.1.2
	carlton_dictionary-20021025-merge:1.1.1.2
	carlton_dictionary-20021011-merge:1.1.1.2
	drow-cplus-branch:1.1.1.2.0.28
	drow-cplus-branchpoint:1.1.1.2
	kseitz_interps-20020930-merge:1.1.1.2
	carlton_dictionary-20020927-merge:1.1.1.2
	carlton_dictionary-branch:1.1.1.2.0.26
	carlton_dictionary-20020920-branchpoint:1.1.1.2
	gdb_5_3-branch:1.1.1.2.0.24
	gdb_5_3-2002-09-04-branchpoint:1.1.1.2
	kseitz_interps-20020829-merge:1.1.1.2
	cagney_sysregs-20020825-branch:1.1.1.2.0.22
	cagney_sysregs-20020825-branchpoint:1.1.1.2
	readline_4_3-import-branch:1.1.1.2.0.20
	readline_4_3-import-branchpoint:1.1.1.2
	gdb_5_2_1-2002-07-23-release:1.1.1.2
	kseitz_interps-20020528-branch:1.1.1.2.0.18
	kseitz_interps-20020528-branchpoint:1.1.1.2
	cagney_regbuf-20020515-branch:1.1.1.2.0.16
	cagney_regbuf-20020515-branchpoint:1.1.1.2
	jimb-macro-020506-branch:1.1.1.2.0.14
	jimb-macro-020506-branchpoint:1.1.1.2
	gdb_5_2-2002-04-29-release:1.1.1.2
	gdb_5_2-branch:1.1.1.2.0.12
	gdb_5_2-2002-03-03-branchpoint:1.1.1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.2
	gdb_5_1_0_1-2002-01-03-release:1.1.1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.2.0.10
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.2
	gdb_5_1-2001-11-21-release:1.1.1.2
	gdb_s390-2001-09-26-branch:1.1.1.2.0.8
	gdb_s390-2001-09-26-branchpoint:1.1.1.2
	gdb_5_1-2001-07-29-branch:1.1.1.2.0.6
	gdb_5_1-2001-07-29-branchpoint:1.1.1.2
	insight-precleanup-2001-01-01:1.1.1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.4
date	2012.12.19.07.18.15;	author brobecke;	state Exp;
branches;
next	1.3;

1.3
date	2012.12.19.07.11.59;	author brobecke;	state Exp;
branches;
next	1.2;

1.2
date	2005.05.12.07.36.59;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.55;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.55;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.02.05.07.30.19;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.4
log
@[sim] Update old contact info in GPL license notices

sim/ChangeLog:

        Update old contact info in GPL license notices.
@
text
@/*  kid.c -- ARMulator RDP/RDI interface:  ARM6 Instruction Emulator.
    Copyright (C) 1994 Advanced RISC Machines Ltd.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, see <http://www.gnu.org/licenses/>. */

/*****************************************************************/
/* The child process continues here...                           */
/* It waits on a pipe from the parent and translates the RDP     */
/* messages into RDI calls to the ARMulator passing RDP replies  */
/* back up a pipe to the parent.                                 */
/*****************************************************************/

#include <sys/types.h>
#include <signal.h>

#include "armdefs.h"
#include "dbg_conf.h"
#include "dbg_hif.h"
#include "dbg_rdi.h"
#include "gdbhost.h"
#include "communicate.h"

/* The pipes between the two processes */
extern int mumkid[2];
extern int kidmum[2];

/* The maximum number of file descriptors */
extern int nfds;

/* The machine name */
#define MAXHOSTNAMELENGTH 64
extern char localhost[MAXHOSTNAMELENGTH + 1];

/* The socket number */
extern unsigned int socketnumber;

/* RDI interface */
extern const struct RDIProcVec armul_rdi;

static int MYrdp_level = 0;

static int rdi_state = 0;

/**************************************************************/
/* Signal handler that terminates excecution in the ARMulator */
/**************************************************************/
void
kid_handlesignal (int sig)
{
#ifdef DEBUG
  fprintf (stderr, "Terminate ARMulator excecution\n");
#endif
  if (sig != SIGUSR1)
    {
      fprintf (stderr, "Unsupported signal.\n");
      return;
    }
  armul_rdi.info (RDISignal_Stop, (unsigned long *) 0, (unsigned long *) 0);
}

/********************************************************************/
/* Waits on a pipe from the socket demon for RDP and                */
/* acts as an RDP to RDI interpreter on the front of the ARMulator. */
/********************************************************************/
void
kid ()
{
  char *p, *q;
  int i, j, k;
  long outofthebag;
  unsigned char c, d, message;
  ARMword x, y, z;
  struct sigaction action;
  PointHandle point;
  Dbg_ConfigBlock config;
  Dbg_HostosInterface hostif;
  struct Dbg_MCState *MCState;
  char command_line[256];
  struct fd_set readfds;

  /* Setup a signal handler for SIGUSR1 */
  action.sa_handler = kid_handlesignal;
  action.sa_mask = 0;
  action.sa_flags = 0;

  sigaction (SIGUSR1, &action, (struct sigaction *) 0);

  while (1)
    {
      /* Wait for ever */
      FD_ZERO (&readfds);
      FD_SET (mumkid[0], &readfds);

      i = select (nfds, &readfds,
		  (fd_set *) 0, (fd_set *) 0, (struct timeval *) 0);

      if (i < 0)
	{
	  perror ("select");
	}

      if (read (mumkid[0], &message, 1) < 1)
	{
	  perror ("read");
	}

      switch (message)
	{
	case RDP_Start:
	  /* Open and/or Initialise */
	  BAG_newbag ();

	  MYread_char (mumkid[0], &c);	/* type */
	  MYread_word (mumkid[0], &x);	/* memorysize */
	  if (c & 0x2)
	    MYread_char (mumkid[0], &d);	/* speed */
	  config.processor = 0;
	  config.memorysize = x;
	  config.bytesex = (c & 0x4) ? RDISex_Big : RDISex_Little;
	  if (c & 0x8)
	    config.bytesex = RDISex_DontCare;

	  hostif.dbgprint = myprint;
	  hostif.dbgpause = mypause;
	  hostif.dbgarg = stdout;
	  hostif.writec = mywritec;
	  hostif.readc = myreadc;
	  hostif.write = mywrite;
	  hostif.gets = mygets;
	  hostif.reset = mypause;	/* do nothing */
	  hostif.resetarg = "Do I love resetting or what!\n";

	  if (rdi_state)
	    {
	      /* we have restarted, so kill off the existing run.  */
	      /* armul_rdi.close(); */
	    }
	  i = armul_rdi.open (c & 0x3, &config, &hostif, MCState);
	  rdi_state = 1;

	  MYwrite_char (kidmum[1], RDP_Return);
	  MYwrite_char (kidmum[1], (unsigned char) i);

	  x = ~0x4;
	  armul_rdi.info (RDIVector_Catch, &x, 0);

	  break;

	case RDP_End:
	  /* Close and Finalise */
	  i = armul_rdi.close ();
	  rdi_state = 0;
	  MYwrite_char (kidmum[1], RDP_Return);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  break;

	case RDP_Read:
	  /* Read Memory Address */
	  MYread_word (mumkid[0], &x);	/* address */
	  MYread_word (mumkid[0], &y);	/* nbytes */
	  p = (char *) malloc (y);
	  i = armul_rdi.read (x, p, (unsigned *) &y);
	  MYwrite_char (kidmum[1], RDP_Return);
	  for (k = 0; k < y; k++)
	    MYwrite_char (kidmum[1], p[k]);
	  free (p);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  if (i)
	    MYwrite_word (kidmum[1], y);	/* number of bytes sent without error */
	  break;

	case RDP_Write:
	  /* Write Memory Address */
	  MYread_word (mumkid[0], &x);	/* address */
	  MYread_word (mumkid[0], &y);	/* nbytes */
	  p = (char *) malloc (y);
	  for (k = 0; k < y; k++)
	    MYread_char (mumkid[0], &p[k]);
	  i = armul_rdi.write (p, x, (unsigned *) &y);
	  free (p);
	  MYwrite_char (kidmum[1], RDP_Return);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  if (i)
	    MYwrite_word (kidmum[1], y);	/* number of bytes sent without error */
	  break;

	case RDP_CPUread:
	  /* Read CPU State */
	  MYread_char (mumkid[0], &c);	/* mode */
	  MYread_word (mumkid[0], &x);	/* mask */
	  p = (char *) malloc (4 * RDINumCPURegs);
	  i = armul_rdi.CPUread (c, x, (ARMword *) p);
	  MYwrite_char (kidmum[1], RDP_Return);
	  for (k = 1, j = 0; k != 0x80000000; k *= 2)
	    if (k & x)
	      MYwrite_word (kidmum[1], ((ARMword *) p)[j++]);
	  free (p);
	  if (i)
	    MYwrite_char (kidmum[1], (unsigned char) j);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  break;

	case RDP_CPUwrite:
	  /* Write CPU State */
	  MYread_char (mumkid[0], &c);	/* mode */
	  MYread_word (mumkid[0], &x);	/* mask */

	  p = (char *) malloc (4 * RDINumCPURegs);
	  for (k = 1, j = 0; k != 0x80000000; k *= 2)
	    if (k & x)
	      MYread_word (mumkid[0], &(((ARMword *) p)[j++]));
	  i = armul_rdi.CPUwrite (c, x, (ARMword *) p);
	  MYwrite_char (kidmum[1], RDP_Return);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  free (p);
	  break;

	case RDP_CPread:
	  /* Read Co-Processor State */
	  MYread_char (mumkid[0], &c);	/* CPnum */
	  MYread_word (mumkid[0], &x);	/* mask */
	  p = q = (char *) malloc (16 * RDINumCPRegs);
	  i = armul_rdi.CPread (c, x, (ARMword *) p);
	  MYwrite_char (kidmum[1], RDP_Return);
	  for (k = 1, j = 0; k != 0x80000000; k *= 2, j++)
	    if (k & x)
	      {
		if ((c == 1 || c == 2) && k <= 128)
		  {
		    MYwrite_FPword (kidmum[1], q);
		    q += 16;
		  }
		else
		  {
		    MYwrite_word (kidmum[1], *q);
		    q += 4;
		  }
	      }
	  free (p);
	  if (i)
	    MYwrite_char (kidmum[1], (unsigned char) j);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  break;

	case RDP_CPwrite:
	  /* Write Co-Processor State */
	  MYread_char (mumkid[0], &c);	/* CPnum */
	  MYread_word (mumkid[0], &x);	/* mask */
	  p = q = (char *) malloc (16 * RDINumCPURegs);
	  for (k = 1, j = 0; k != 0x80000000; k *= 2, j++)
	    if (k & x)
	      {
		if ((c == 1 || c == 2) && k <= 128)
		  {
		    MYread_FPword (kidmum[1], q);
		    q += 16;
		  }
		else
		  {
		    MYread_word (mumkid[0], (ARMword *) q);
		    q += 4;
		  }
	      }
	  i = armul_rdi.CPwrite (c, x, (ARMword *) p);
	  MYwrite_char (kidmum[1], RDP_Return);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  free (p);
	  break;

	case RDP_SetBreak:
	  /* Set Breakpoint */
	  MYread_word (mumkid[0], &x);	/* address */
	  MYread_char (mumkid[0], &c);	/* type */
	  if ((c & 0xf) >= 5)
	    MYread_word (mumkid[0], &y);	/* bound */
	  i = armul_rdi.setbreak (x, c, y, &point);
	  if (!MYrdp_level)
	    BAG_putpair ((long) x, (long) point);
	  MYwrite_char (kidmum[1], RDP_Return);
	  if (MYrdp_level)
	    MYwrite_word (kidmum[1], point);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  break;

	case RDP_ClearBreak:
	  /* Clear Breakpoint */
	  MYread_word (mumkid[0], &point);	/* PointHandle */
	  if (!MYrdp_level)
	    {
	      BAG_getsecond ((long) point, &outofthebag);	/* swap pointhandle for address */
	      BAG_killpair_byfirst (outofthebag);
	      point = outofthebag;
	    }
	  i = armul_rdi.clearbreak (point);
	  MYwrite_char (kidmum[1], RDP_Return);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  break;

	case RDP_SetWatch:
	  /* Set Watchpoint */
	  MYread_word (mumkid[0], &x);	/* address */
	  MYread_char (mumkid[0], &c);	/* type */
	  MYread_char (mumkid[0], &d);	/* datatype */
	  if ((c & 0xf) >= 5)
	    MYread_word (mumkid[0], &y);	/* bound */
	  i = armul_rdi.setwatch (x, c, d, y, &point);
	  MYwrite_char (kidmum[1], RDP_Return);
	  MYwrite_word (kidmum[1], point);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  break;

	case RDP_ClearWatch:
	  /* Clear Watchpoint */
	  MYread_word (mumkid[0], &point);	/* PointHandle */
	  i = armul_rdi.clearwatch (point);
	  MYwrite_char (kidmum[1], RDP_Return);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  break;

	case RDP_Execute:
	  /* Excecute */

	  MYread_char (mumkid[0], &c);	/* return */

#ifdef DEBUG
	  fprintf (stderr, "Starting execution\n");
#endif
	  i = armul_rdi.execute (&point);
#ifdef DEBUG
	  fprintf (stderr, "Completed execution\n");
#endif
	  MYwrite_char (kidmum[1], RDP_Return);
	  if (c & 0x80)
	    MYwrite_word (kidmum[1], point);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  break;

	case RDP_Step:
	  /* Step */
	  MYread_char (mumkid[0], &c);	/* return */
	  MYread_word (mumkid[0], &x);	/* ninstr */
	  point = 0x87654321;
	  i = armul_rdi.step (x, &point);
	  MYwrite_char (kidmum[1], RDP_Return);
	  if (c & 0x80)
	    MYwrite_word (kidmum[1], point);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  break;

	case RDP_Info:
	  /* Info */
	  MYread_word (mumkid[0], &x);
	  switch (x)
	    {
	    case RDIInfo_Target:
	      i = armul_rdi.info (RDIInfo_Target, &y, &z);
	      MYwrite_char (kidmum[1], RDP_Return);
	      MYwrite_word (kidmum[1], y);	/* Loads of info... */
	      MYwrite_word (kidmum[1], z);	/* Model */
	      MYwrite_char (kidmum[1], (unsigned char) i);
	      break;

	    case RDISet_RDILevel:
	      MYread_word (mumkid[0], &x);	/* arg1, debug level */
	      i = armul_rdi.info (RDISet_RDILevel, &x, 0);
	      if (i == RDIError_NoError)
		MYrdp_level = x;
	      MYwrite_char (kidmum[1], RDP_Return);
	      MYwrite_char (kidmum[1], (unsigned char) i);
	      break;

	    case RDISet_Cmdline:
	      for (p = command_line; MYread_char (mumkid[0], p), *p; p++)
		;		/* String */
	      i = armul_rdi.info (RDISet_Cmdline,
				  (unsigned long *) command_line, 0);
	      MYwrite_char (kidmum[1], RDP_Return);
	      MYwrite_char (kidmum[1], (unsigned char) i);
	      break;

	    case RDIInfo_Step:
	      i = armul_rdi.info (RDIInfo_Step, &x, 0);
	      MYwrite_char (kidmum[1], RDP_Return);
	      MYwrite_word (kidmum[1], x);
	      MYwrite_char (kidmum[1], (unsigned char) i);
	      break;

	    case RDIVector_Catch:
	      MYread_word (mumkid[0], &x);
	      i = armul_rdi.info (RDIVector_Catch, &x, 0);
	      MYwrite_char (kidmum[1], RDP_Return);
	      MYwrite_char (kidmum[1], i);
	      break;

	    case RDIInfo_Points:
	      i = armul_rdi.info (RDIInfo_Points, &x, 0);
	      MYwrite_char (kidmum[1], RDP_Return);
	      MYwrite_word (kidmum[1], x);
	      MYwrite_char (kidmum[1], (unsigned char) i);
	      break;

	    default:
	      fprintf (stderr, "Unsupported info code %d\n", x);
	      break;
	    }
	  break;

	case RDP_OSOpReply:
	  /* OS Operation Reply */
	  MYwrite_char (kidmum[1], RDP_Fatal);
	  break;

	case RDP_Reset:
	  /* Reset */
	  for (i = 0; i < 50; i++)
	    MYwrite_char (kidmum[1], RDP_Reset);
	  p = (char *) malloc (MAXHOSTNAMELENGTH + 5 + 20);
	  sprintf (p, "Running on %s:%d\n", localhost, socketnumber);
	  MYwrite_string (kidmum[1], p);
	  free (p);

	  break;
	default:
	  fprintf (stderr, "Oh dear: Something is seriously wrong :-(\n");
	  /* Hmm.. bad RDP operation */
	  break;
	}
    }
}


/* Handles memory read operations until an OS Operation Reply Message is */
/* encounterd. It then returns the byte info value (0, 1, or 2) and fills  */
/* in 'putinr0' with the data if appropriate. */
int
wait_for_osreply (ARMword * reply)
{
  char *p, *q;
  int i, j, k;
  unsigned char c, d, message;
  ARMword x, y, z;
  struct sigaction action;
  PointHandle point;
  Dbg_ConfigBlock config;
  Dbg_HostosInterface hostif;
  struct Dbg_MCState *MCState;
  char command_line[256];
  struct fd_set readfds;

#ifdef DEBUG
  fprintf (stderr, "wait_for_osreply ().\n");
#endif

  /* Setup a signal handler for SIGUSR1 */
  action.sa_handler = kid_handlesignal;
  action.sa_mask = 0;
  action.sa_flags = 0;

  sigaction (SIGUSR1, &action, (struct sigaction *) 0);

  while (1)
    {
      /* Wait for ever */
      FD_ZERO (&readfds);
      FD_SET (mumkid[0], &readfds);

      i = select (nfds, &readfds,
		  (fd_set *) 0, (fd_set *) 0, (struct timeval *) 0);

      if (i < 0)
	{
	  perror ("select");
	}

      if (read (mumkid[0], &message, 1) < 1)
	{
	  perror ("read");
	}

      switch (message)
	{
	case RDP_Read:
	  /* Read Memory Address */
	  MYread_word (mumkid[0], &x);	/* address */
	  MYread_word (mumkid[0], &y);	/* nbytes */
	  p = (char *) malloc (y);
	  i = armul_rdi.read (x, p, (unsigned *) &y);
	  MYwrite_char (kidmum[1], RDP_Return);
	  for (k = 0; k < y; k++)
	    MYwrite_char (kidmum[1], p[k]);
	  free (p);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  if (i)
	    MYwrite_word (kidmum[1], y);	/* number of bytes sent without error */
	  break;

	case RDP_Write:
	  /* Write Memory Address */
	  MYread_word (mumkid[0], &x);	/* address */
	  MYread_word (mumkid[0], &y);	/* nbytes */
	  p = (char *) malloc (y);
	  for (k = 0; k < y; k++)
	    MYread_char (mumkid[0], &p[k]);
	  i = armul_rdi.write (p, x, (unsigned *) &y);
	  free (p);
	  MYwrite_char (kidmum[1], RDP_Return);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  if (i)
	    MYwrite_word (kidmum[1], y);	/* number of bytes sent without error */
	  break;

	case RDP_OSOpReply:
	  /* OS Operation Reply */
	  MYread_char (mumkid[0], &c);
	  if (c == 1)
	    MYread_char (mumkid[0], (char *) reply);
	  if (c == 2)
	    MYread_word (mumkid[0], reply);
	  return c;
	  break;

	default:
	  fprintf (stderr,
		   "HELP! Unaccounted-for message during OS request. \n");
	  MYwrite_char (kidmum[1], RDP_Fatal);
	}
    }
}
@


1.3
log
@Update sim copyright headers from GPLv2-or-later to GPLv3-or-later.

gdb/sim/ChangeLog:

        Update the non-FSF-copyrighted files in sim to GPLv3 or later.
@
text
@d15 1
a15 2
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA. */
@


1.2
log
@Update the address of the FSF organization
@
text
@d6 1
a6 1
    the Free Software Foundation; either version 2 of the License, or
@


1.1
log
@Initial revision
@
text
@d16 1
a16 1
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
d59 3
a61 1
void kid_handlesignal(int sig) {
d63 1
a63 1
  fprintf(stderr, "Terminate ARMulator excecution\n");
d65 6
a70 5
  if (sig != SIGUSR1) {
    fprintf(stderr, "Unsupported signal.\n");
    return;
  }
  armul_rdi.info(RDISignal_Stop, (unsigned long *) 0, (unsigned long *) 0);
d77 3
a79 1
void kid() {
d92 1
a92 1
  
d97 3
a99 3
  
  sigaction(SIGUSR1, &action, (struct sigaction *) 0);
  
d101 7
a107 17
  {
    /* Wait for ever */
    FD_ZERO(&readfds);
    FD_SET(mumkid[0], &readfds);
    
    i = select(nfds, &readfds,
	       (fd_set *) 0,
	       (fd_set *) 0,
	       (struct timeval *) 0);
    
    if (i < 0) {
      perror("select");
    }
    
    if (read(mumkid[0], &message, 1) < 1) {
      perror("read");
    }
d109 3
a111 122
    switch (message) {
    case RDP_Start :
      /* Open and/or Initialise */
      BAG_newbag();

      MYread_char(mumkid[0], &c); /* type */
      MYread_word(mumkid[0], &x); /* memorysize */
      if (c & 0x2) MYread_char(mumkid[0], &d); /* speed */
      config.processor = 0;
      config.memorysize = x;
      config.bytesex = (c & 0x4) ? RDISex_Big : RDISex_Little;
      if (c & 0x8) config.bytesex = RDISex_DontCare;

      hostif.dbgprint = myprint;
      hostif.dbgpause = mypause;
      hostif.dbgarg = stdout;
      hostif.writec = mywritec;
      hostif.readc = myreadc;
      hostif.write = mywrite;
      hostif.gets = mygets;
      hostif.reset = mypause; /* do nothing */
      hostif.resetarg = "Do I love resetting or what!\n";

      if (rdi_state)
      {
	/* we have restarted, so kill off the existing run.  */
	/* armul_rdi.close(); */
      }
      i = armul_rdi.open(c & 0x3, &config, &hostif, MCState);
      rdi_state = 1;

      MYwrite_char(kidmum[1], RDP_Return);
      MYwrite_char(kidmum[1], (unsigned char) i);

      x = ~0x4;
      armul_rdi.info(RDIVector_Catch, &x, 0);

      break;

    case RDP_End :
      /* Close and Finalise */
      i = armul_rdi.close();
      rdi_state = 0;
      MYwrite_char(kidmum[1], RDP_Return);
      MYwrite_char(kidmum[1], (unsigned char) i);
      break;

    case RDP_Read :
      /* Read Memory Address */      
      MYread_word(mumkid[0], &x); /* address */
      MYread_word(mumkid[0], &y); /* nbytes */
      p = (char *) malloc(y);
      i = armul_rdi.read(x, p, (unsigned *) &y);
      MYwrite_char(kidmum[1], RDP_Return);
      for (k = 0; k < y; k++)
	MYwrite_char(kidmum[1], p[k]);
      free(p);
      MYwrite_char(kidmum[1], (unsigned char) i);
      if (i)
	MYwrite_word(kidmum[1], y); /* number of bytes sent without error */
      break;

    case RDP_Write :
      /* Write Memory Address */
      MYread_word(mumkid[0], &x); /* address */
      MYread_word(mumkid[0], &y); /* nbytes */
      p = (char *) malloc(y);
      for (k = 0; k < y; k++)
	MYread_char(mumkid[0], &p[k]);
      i = armul_rdi.write(p, x, (unsigned *) &y);
      free(p);
      MYwrite_char(kidmum[1], RDP_Return);
      MYwrite_char(kidmum[1], (unsigned char) i);
      if (i)
	MYwrite_word(kidmum[1], y); /* number of bytes sent without error */
      break;

    case RDP_CPUread :
      /* Read CPU State */
      MYread_char(mumkid[0], &c); /* mode */
      MYread_word(mumkid[0], &x); /* mask */
      p = (char *) malloc(4 * RDINumCPURegs);
      i = armul_rdi.CPUread(c, x, (ARMword *) p);
      MYwrite_char(kidmum[1], RDP_Return);
      for (k = 1, j = 0; k != 0x80000000; k *= 2)
	if (k & x) MYwrite_word(kidmum[1], ((ARMword *) p)[j++]);
      free(p);
      if (i) MYwrite_char(kidmum[1], (unsigned char) j);
      MYwrite_char(kidmum[1], (unsigned char) i);
      break;

    case RDP_CPUwrite :
      /* Write CPU State */
      MYread_char(mumkid[0], &c); /* mode */
      MYread_word(mumkid[0], &x); /* mask */

      p = (char *) malloc(4 * RDINumCPURegs);
      for (k = 1, j = 0; k != 0x80000000; k *= 2)
	if (k & x) MYread_word(mumkid[0], &(((ARMword *) p)[j++]));
      i = armul_rdi.CPUwrite(c, x, (ARMword *) p);
      MYwrite_char(kidmum[1], RDP_Return);
      MYwrite_char(kidmum[1], (unsigned char) i);
      free(p);
      break;

    case RDP_CPread :
      /* Read Co-Processor State */
      MYread_char(mumkid[0], &c); /* CPnum */
      MYread_word(mumkid[0], &x); /* mask */
      p = q = (char *) malloc(16 * RDINumCPRegs);
      i = armul_rdi.CPread(c, x, (ARMword *) p);
      MYwrite_char(kidmum[1], RDP_Return);
      for (k = 1, j = 0; k != 0x80000000; k *= 2, j++)
	if (k & x) {
	  if ((c == 1 || c == 2) && k <= 128) {
	    MYwrite_FPword(kidmum[1], q);
	    q += 16;
	  }
	  else {
	    MYwrite_word(kidmum[1], *q);
	    q += 4;
	  }
d113 4
a116 20
      free(p);
      if (i) MYwrite_char(kidmum[1], (unsigned char) j);
      MYwrite_char(kidmum[1], (unsigned char) i);
      break;

    case RDP_CPwrite :
      /* Write Co-Processor State */
      MYread_char(mumkid[0], &c); /* CPnum */
      MYread_word(mumkid[0], &x); /* mask */
      p = q = (char *) malloc(16 * RDINumCPURegs);
      for (k = 1, j = 0; k != 0x80000000; k *= 2, j++)
	if (k & x) {
	  if ((c == 1 || c == 2) && k <= 128) {
	    MYread_FPword(kidmum[1], q);
	    q += 16;
	  }
	  else {
	    MYread_word(mumkid[0], (ARMword *) q);
	    q += 4;
	  }
a117 55
      i = armul_rdi.CPwrite(c, x, (ARMword *) p);
      MYwrite_char(kidmum[1], RDP_Return);
      MYwrite_char(kidmum[1], (unsigned char) i);
      free(p);
      break;
      
    case RDP_SetBreak :
      /* Set Breakpoint */
      MYread_word(mumkid[0], &x); /* address */
      MYread_char(mumkid[0], &c); /* type */
      if ((c & 0xf) >= 5) MYread_word(mumkid[0], &y); /* bound */
      i = armul_rdi.setbreak(x, c, y, &point);
      if (!MYrdp_level) BAG_putpair((long) x, (long) point);
      MYwrite_char(kidmum[1], RDP_Return);
      if (MYrdp_level) MYwrite_word(kidmum[1], point);
      MYwrite_char(kidmum[1], (unsigned char) i);      
      break;

    case RDP_ClearBreak :
      /* Clear Breakpoint */
      MYread_word(mumkid[0], &point); /* PointHandle */
      if (!MYrdp_level) {
	BAG_getsecond((long) point, &outofthebag); /* swap pointhandle for address */
	BAG_killpair_byfirst(outofthebag);
	point = outofthebag;
      }
      i = armul_rdi.clearbreak(point);
      MYwrite_char(kidmum[1], RDP_Return);
      MYwrite_char(kidmum[1], (unsigned char) i);
      break;

    case RDP_SetWatch :
      /* Set Watchpoint */
      MYread_word(mumkid[0], &x); /* address */
      MYread_char(mumkid[0], &c); /* type */
      MYread_char(mumkid[0], &d); /* datatype */
      if ((c & 0xf) >= 5) MYread_word(mumkid[0], &y); /* bound */
      i = armul_rdi.setwatch(x, c, d, y, &point);
      MYwrite_char(kidmum[1], RDP_Return);
      MYwrite_word(kidmum[1], point);
      MYwrite_char(kidmum[1], (unsigned char) i);
      break;

    case RDP_ClearWatch :
      /* Clear Watchpoint */
      MYread_word(mumkid[0], &point); /* PointHandle */
      i = armul_rdi.clearwatch(point);
      MYwrite_char(kidmum[1], RDP_Return);
      MYwrite_char(kidmum[1], (unsigned char) i);
      break;

    case RDP_Execute :
      /* Excecute */
      
      MYread_char(mumkid[0], &c); /* return */
d119 1
a119 27
#ifdef DEBUG
      fprintf(stderr, "Starting execution\n");
#endif
      i = armul_rdi.execute(&point);
#ifdef DEBUG
      fprintf(stderr, "Completed execution\n");
#endif
      MYwrite_char(kidmum[1], RDP_Return);
      if (c & 0x80) MYwrite_word(kidmum[1], point);
      MYwrite_char(kidmum[1], (unsigned char) i);
      break;

    case RDP_Step :
      /* Step */
      MYread_char(mumkid[0], &c); /* return */
      MYread_word(mumkid[0], &x); /* ninstr */
      point = 0x87654321;
      i = armul_rdi.step(x, &point);
      MYwrite_char(kidmum[1], RDP_Return);
      if (c & 0x80) MYwrite_word(kidmum[1], point);
      MYwrite_char(kidmum[1], (unsigned char) i);
      break;

    case RDP_Info:
      /* Info */
      MYread_word (mumkid[0], &x);
      switch (x)
d121 156
a276 2
	case RDIInfo_Target:
	  i = armul_rdi.info (RDIInfo_Target, &y, &z);
a277 2
	  MYwrite_word (kidmum[1], y); /* Loads of info... */
	  MYwrite_word (kidmum[1], z); /* Model */
d279 1
d282 9
a290 5
	case RDISet_RDILevel:
	  MYread_word (mumkid[0], &x); /* arg1, debug level */
	  i = armul_rdi.info (RDISet_RDILevel, &x, 0);
	  if (i == RDIError_NoError)
	    MYrdp_level = x;
d292 2
d297 10
a306 5
	case RDISet_Cmdline:
	  for (p = command_line; MYread_char (mumkid[0], p), *p; p++)
	    ; /* String */
	  i = armul_rdi.info (RDISet_Cmdline,
			      (unsigned long *) command_line, 0);
d311 8
a318 2
	case RDIInfo_Step:
	  i = armul_rdi.info (RDIInfo_Step, &x, 0);
d320 1
a320 1
	  MYwrite_word (kidmum[1], x);
d324 20
a343 3
	case RDIVector_Catch:
	  MYread_word (mumkid[0], &x);
	  i = armul_rdi.info (RDIVector_Catch, &x, 0);
d345 3
a347 1
	  MYwrite_char (kidmum[1], i);
d350 6
a355 2
	case RDIInfo_Points:
	  i = armul_rdi.info (RDIInfo_Points, &x, 0);
d357 2
a358 1
	  MYwrite_word (kidmum[1], x);
d362 73
d436 2
a437 1
	  fprintf (stderr, "Unsupported info code %d\n", x);
a439 21
      break;

    case RDP_OSOpReply:
      /* OS Operation Reply */
      MYwrite_char (kidmum[1], RDP_Fatal);
      break;

    case RDP_Reset:
      /* Reset */
      for (i = 0; i < 50; i++)
	MYwrite_char(kidmum[1], RDP_Reset);
      p = (char *) malloc(MAXHOSTNAMELENGTH + 5 + 20);
      sprintf(p, "Running on %s:%d\n", localhost, socketnumber);
      MYwrite_string(kidmum[1], p);
      free(p);
      
      break;
    default:
      fprintf (stderr, "Oh dear: Something is seriously wrong :-(\n");
      /* Hmm.. bad RDP operation */
      break;
a440 1
  }
d447 2
a448 1
int wait_for_osreply(ARMword *reply)
d461 1
a461 1
  
d463 1
a463 1
  fprintf(stderr, "wait_for_osreply ().\n");
d470 3
a472 3
  
  sigaction(SIGUSR1, &action, (struct sigaction *) 0);
  
d474 65
a538 60
  {
    /* Wait for ever */
    FD_ZERO(&readfds);
    FD_SET(mumkid[0], &readfds);
    
    i = select(nfds, &readfds,
	       (fd_set *) 0,
	       (fd_set *) 0,
	       (struct timeval *) 0);
    
    if (i < 0) {
      perror("select");
    }
    
    if (read(mumkid[0], &message, 1) < 1) {
      perror("read");
    }
    
    switch (message) {
    case RDP_Read :
      /* Read Memory Address */
      MYread_word(mumkid[0], &x); /* address */
      MYread_word(mumkid[0], &y); /* nbytes */
      p = (char *) malloc(y);
      i = armul_rdi.read(x, p, (unsigned *) &y);
      MYwrite_char(kidmum[1], RDP_Return);
      for (k = 0; k < y; k++)
	MYwrite_char(kidmum[1], p[k]);
      free(p);
      MYwrite_char(kidmum[1], (unsigned char) i);
      if (i)
	MYwrite_word(kidmum[1], y); /* number of bytes sent without error */
      break;

    case RDP_Write :
      /* Write Memory Address */
      MYread_word(mumkid[0], &x); /* address */
      MYread_word(mumkid[0], &y); /* nbytes */
      p = (char *) malloc(y);
      for (k = 0; k < y; k++)
	MYread_char(mumkid[0], &p[k]);
      i = armul_rdi.write(p, x, (unsigned *) &y);
      free(p);
      MYwrite_char(kidmum[1], RDP_Return);
      MYwrite_char(kidmum[1], (unsigned char) i);
      if (i)
	MYwrite_word(kidmum[1], y); /* number of bytes sent without error */
      break;
      
    case RDP_OSOpReply :
      /* OS Operation Reply */
      MYread_char(mumkid[0], &c);
      if (c == 1) MYread_char(mumkid[0], (char *) reply);
      if (c == 2) MYread_word(mumkid[0], reply);
      return c;
      break;
      
    default :
      fprintf(stderr, "HELP! Unaccounted-for message during OS request. \n");
      MYwrite_char(kidmum[1], RDP_Fatal);
a539 1
  }
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-2000-02-04 snapshot
@
text
@d59 1
a59 3
void
kid_handlesignal (int sig)
{
d61 1
a61 1
  fprintf (stderr, "Terminate ARMulator excecution\n");
d63 5
a67 6
  if (sig != SIGUSR1)
    {
      fprintf (stderr, "Unsupported signal.\n");
      return;
    }
  armul_rdi.info (RDISignal_Stop, (unsigned long *) 0, (unsigned long *) 0);
d74 1
a74 3
void
kid ()
{
d87 1
a87 1

d92 3
a94 3

  sigaction (SIGUSR1, &action, (struct sigaction *) 0);

d96 17
a112 7
    {
      /* Wait for ever */
      FD_ZERO (&readfds);
      FD_SET (mumkid[0], &readfds);

      i = select (nfds, &readfds,
		  (fd_set *) 0, (fd_set *) 0, (struct timeval *) 0);
d114 122
a235 3
      if (i < 0)
	{
	  perror ("select");
d237 20
a256 4

      if (read (mumkid[0], &message, 1) < 1)
	{
	  perror ("read");
d258 55
d314 27
a340 1
      switch (message)
d342 2
a343 32
	case RDP_Start:
	  /* Open and/or Initialise */
	  BAG_newbag ();

	  MYread_char (mumkid[0], &c);	/* type */
	  MYread_word (mumkid[0], &x);	/* memorysize */
	  if (c & 0x2)
	    MYread_char (mumkid[0], &d);	/* speed */
	  config.processor = 0;
	  config.memorysize = x;
	  config.bytesex = (c & 0x4) ? RDISex_Big : RDISex_Little;
	  if (c & 0x8)
	    config.bytesex = RDISex_DontCare;

	  hostif.dbgprint = myprint;
	  hostif.dbgpause = mypause;
	  hostif.dbgarg = stdout;
	  hostif.writec = mywritec;
	  hostif.readc = myreadc;
	  hostif.write = mywrite;
	  hostif.gets = mygets;
	  hostif.reset = mypause;	/* do nothing */
	  hostif.resetarg = "Do I love resetting or what!\n";

	  if (rdi_state)
	    {
	      /* we have restarted, so kill off the existing run.  */
	      /* armul_rdi.close(); */
	    }
	  i = armul_rdi.open (c & 0x3, &config, &hostif, MCState);
	  rdi_state = 1;

d345 2
a347 4

	  x = ~0x4;
	  armul_rdi.info (RDIVector_Catch, &x, 0);

d350 5
a354 4
	case RDP_End:
	  /* Close and Finalise */
	  i = armul_rdi.close ();
	  rdi_state = 0;
d359 5
a363 6
	case RDP_Read:
	  /* Read Memory Address */
	  MYread_word (mumkid[0], &x);	/* address */
	  MYread_word (mumkid[0], &y);	/* nbytes */
	  p = (char *) malloc (y);
	  i = armul_rdi.read (x, p, (unsigned *) &y);
a364 3
	  for (k = 0; k < y; k++)
	    MYwrite_char (kidmum[1], p[k]);
	  free (p);
a365 2
	  if (i)
	    MYwrite_word (kidmum[1], y);	/* number of bytes sent without error */
d368 2
a369 9
	case RDP_Write:
	  /* Write Memory Address */
	  MYread_word (mumkid[0], &x);	/* address */
	  MYread_word (mumkid[0], &y);	/* nbytes */
	  p = (char *) malloc (y);
	  for (k = 0; k < y; k++)
	    MYread_char (mumkid[0], &p[k]);
	  i = armul_rdi.write (p, x, (unsigned *) &y);
	  free (p);
d371 1
a372 2
	  if (i)
	    MYwrite_word (kidmum[1], y);	/* number of bytes sent without error */
d375 3
a377 6
	case RDP_CPUread:
	  /* Read CPU State */
	  MYread_char (mumkid[0], &c);	/* mode */
	  MYread_word (mumkid[0], &x);	/* mask */
	  p = (char *) malloc (4 * RDINumCPURegs);
	  i = armul_rdi.CPUread (c, x, (ARMword *) p);
d379 1
a379 7
	  for (k = 1, j = 0; k != 0x80000000; k *= 2)
	    if (k & x)
	      MYwrite_word (kidmum[1], ((ARMword *) p)[j++]);
	  free (p);
	  if (i)
	    MYwrite_char (kidmum[1], (unsigned char) j);
	  MYwrite_char (kidmum[1], (unsigned char) i);
d382 2
a383 10
	case RDP_CPUwrite:
	  /* Write CPU State */
	  MYread_char (mumkid[0], &c);	/* mode */
	  MYread_word (mumkid[0], &x);	/* mask */

	  p = (char *) malloc (4 * RDINumCPURegs);
	  for (k = 1, j = 0; k != 0x80000000; k *= 2)
	    if (k & x)
	      MYread_word (mumkid[0], &(((ARMword *) p)[j++]));
	  i = armul_rdi.CPUwrite (c, x, (ARMword *) p);
d385 1
a386 1
	  free (p);
a388 205
	case RDP_CPread:
	  /* Read Co-Processor State */
	  MYread_char (mumkid[0], &c);	/* CPnum */
	  MYread_word (mumkid[0], &x);	/* mask */
	  p = q = (char *) malloc (16 * RDINumCPRegs);
	  i = armul_rdi.CPread (c, x, (ARMword *) p);
	  MYwrite_char (kidmum[1], RDP_Return);
	  for (k = 1, j = 0; k != 0x80000000; k *= 2, j++)
	    if (k & x)
	      {
		if ((c == 1 || c == 2) && k <= 128)
		  {
		    MYwrite_FPword (kidmum[1], q);
		    q += 16;
		  }
		else
		  {
		    MYwrite_word (kidmum[1], *q);
		    q += 4;
		  }
	      }
	  free (p);
	  if (i)
	    MYwrite_char (kidmum[1], (unsigned char) j);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  break;

	case RDP_CPwrite:
	  /* Write Co-Processor State */
	  MYread_char (mumkid[0], &c);	/* CPnum */
	  MYread_word (mumkid[0], &x);	/* mask */
	  p = q = (char *) malloc (16 * RDINumCPURegs);
	  for (k = 1, j = 0; k != 0x80000000; k *= 2, j++)
	    if (k & x)
	      {
		if ((c == 1 || c == 2) && k <= 128)
		  {
		    MYread_FPword (kidmum[1], q);
		    q += 16;
		  }
		else
		  {
		    MYread_word (mumkid[0], (ARMword *) q);
		    q += 4;
		  }
	      }
	  i = armul_rdi.CPwrite (c, x, (ARMword *) p);
	  MYwrite_char (kidmum[1], RDP_Return);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  free (p);
	  break;

	case RDP_SetBreak:
	  /* Set Breakpoint */
	  MYread_word (mumkid[0], &x);	/* address */
	  MYread_char (mumkid[0], &c);	/* type */
	  if ((c & 0xf) >= 5)
	    MYread_word (mumkid[0], &y);	/* bound */
	  i = armul_rdi.setbreak (x, c, y, &point);
	  if (!MYrdp_level)
	    BAG_putpair ((long) x, (long) point);
	  MYwrite_char (kidmum[1], RDP_Return);
	  if (MYrdp_level)
	    MYwrite_word (kidmum[1], point);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  break;

	case RDP_ClearBreak:
	  /* Clear Breakpoint */
	  MYread_word (mumkid[0], &point);	/* PointHandle */
	  if (!MYrdp_level)
	    {
	      BAG_getsecond ((long) point, &outofthebag);	/* swap pointhandle for address */
	      BAG_killpair_byfirst (outofthebag);
	      point = outofthebag;
	    }
	  i = armul_rdi.clearbreak (point);
	  MYwrite_char (kidmum[1], RDP_Return);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  break;

	case RDP_SetWatch:
	  /* Set Watchpoint */
	  MYread_word (mumkid[0], &x);	/* address */
	  MYread_char (mumkid[0], &c);	/* type */
	  MYread_char (mumkid[0], &d);	/* datatype */
	  if ((c & 0xf) >= 5)
	    MYread_word (mumkid[0], &y);	/* bound */
	  i = armul_rdi.setwatch (x, c, d, y, &point);
	  MYwrite_char (kidmum[1], RDP_Return);
	  MYwrite_word (kidmum[1], point);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  break;

	case RDP_ClearWatch:
	  /* Clear Watchpoint */
	  MYread_word (mumkid[0], &point);	/* PointHandle */
	  i = armul_rdi.clearwatch (point);
	  MYwrite_char (kidmum[1], RDP_Return);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  break;

	case RDP_Execute:
	  /* Excecute */

	  MYread_char (mumkid[0], &c);	/* return */

#ifdef DEBUG
	  fprintf (stderr, "Starting execution\n");
#endif
	  i = armul_rdi.execute (&point);
#ifdef DEBUG
	  fprintf (stderr, "Completed execution\n");
#endif
	  MYwrite_char (kidmum[1], RDP_Return);
	  if (c & 0x80)
	    MYwrite_word (kidmum[1], point);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  break;

	case RDP_Step:
	  /* Step */
	  MYread_char (mumkid[0], &c);	/* return */
	  MYread_word (mumkid[0], &x);	/* ninstr */
	  point = 0x87654321;
	  i = armul_rdi.step (x, &point);
	  MYwrite_char (kidmum[1], RDP_Return);
	  if (c & 0x80)
	    MYwrite_word (kidmum[1], point);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  break;

	case RDP_Info:
	  /* Info */
	  MYread_word (mumkid[0], &x);
	  switch (x)
	    {
	    case RDIInfo_Target:
	      i = armul_rdi.info (RDIInfo_Target, &y, &z);
	      MYwrite_char (kidmum[1], RDP_Return);
	      MYwrite_word (kidmum[1], y);	/* Loads of info... */
	      MYwrite_word (kidmum[1], z);	/* Model */
	      MYwrite_char (kidmum[1], (unsigned char) i);
	      break;

	    case RDISet_RDILevel:
	      MYread_word (mumkid[0], &x);	/* arg1, debug level */
	      i = armul_rdi.info (RDISet_RDILevel, &x, 0);
	      if (i == RDIError_NoError)
		MYrdp_level = x;
	      MYwrite_char (kidmum[1], RDP_Return);
	      MYwrite_char (kidmum[1], (unsigned char) i);
	      break;

	    case RDISet_Cmdline:
	      for (p = command_line; MYread_char (mumkid[0], p), *p; p++)
		;		/* String */
	      i = armul_rdi.info (RDISet_Cmdline,
				  (unsigned long *) command_line, 0);
	      MYwrite_char (kidmum[1], RDP_Return);
	      MYwrite_char (kidmum[1], (unsigned char) i);
	      break;

	    case RDIInfo_Step:
	      i = armul_rdi.info (RDIInfo_Step, &x, 0);
	      MYwrite_char (kidmum[1], RDP_Return);
	      MYwrite_word (kidmum[1], x);
	      MYwrite_char (kidmum[1], (unsigned char) i);
	      break;

	    case RDIVector_Catch:
	      MYread_word (mumkid[0], &x);
	      i = armul_rdi.info (RDIVector_Catch, &x, 0);
	      MYwrite_char (kidmum[1], RDP_Return);
	      MYwrite_char (kidmum[1], i);
	      break;

	    case RDIInfo_Points:
	      i = armul_rdi.info (RDIInfo_Points, &x, 0);
	      MYwrite_char (kidmum[1], RDP_Return);
	      MYwrite_word (kidmum[1], x);
	      MYwrite_char (kidmum[1], (unsigned char) i);
	      break;

	    default:
	      fprintf (stderr, "Unsupported info code %d\n", x);
	      break;
	    }
	  break;

	case RDP_OSOpReply:
	  /* OS Operation Reply */
	  MYwrite_char (kidmum[1], RDP_Fatal);
	  break;

	case RDP_Reset:
	  /* Reset */
	  for (i = 0; i < 50; i++)
	    MYwrite_char (kidmum[1], RDP_Reset);
	  p = (char *) malloc (MAXHOSTNAMELENGTH + 5 + 20);
	  sprintf (p, "Running on %s:%d\n", localhost, socketnumber);
	  MYwrite_string (kidmum[1], p);
	  free (p);

	  break;
d390 1
a390 2
	  fprintf (stderr, "Oh dear: Something is seriously wrong :-(\n");
	  /* Hmm.. bad RDP operation */
d393 21
d415 1
d422 1
a422 2
int
wait_for_osreply (ARMword * reply)
d435 1
a435 1

d437 1
a437 1
  fprintf (stderr, "wait_for_osreply ().\n");
d444 3
a446 3

  sigaction (SIGUSR1, &action, (struct sigaction *) 0);

d448 60
a507 65
    {
      /* Wait for ever */
      FD_ZERO (&readfds);
      FD_SET (mumkid[0], &readfds);

      i = select (nfds, &readfds,
		  (fd_set *) 0, (fd_set *) 0, (struct timeval *) 0);

      if (i < 0)
	{
	  perror ("select");
	}

      if (read (mumkid[0], &message, 1) < 1)
	{
	  perror ("read");
	}

      switch (message)
	{
	case RDP_Read:
	  /* Read Memory Address */
	  MYread_word (mumkid[0], &x);	/* address */
	  MYread_word (mumkid[0], &y);	/* nbytes */
	  p = (char *) malloc (y);
	  i = armul_rdi.read (x, p, (unsigned *) &y);
	  MYwrite_char (kidmum[1], RDP_Return);
	  for (k = 0; k < y; k++)
	    MYwrite_char (kidmum[1], p[k]);
	  free (p);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  if (i)
	    MYwrite_word (kidmum[1], y);	/* number of bytes sent without error */
	  break;

	case RDP_Write:
	  /* Write Memory Address */
	  MYread_word (mumkid[0], &x);	/* address */
	  MYread_word (mumkid[0], &y);	/* nbytes */
	  p = (char *) malloc (y);
	  for (k = 0; k < y; k++)
	    MYread_char (mumkid[0], &p[k]);
	  i = armul_rdi.write (p, x, (unsigned *) &y);
	  free (p);
	  MYwrite_char (kidmum[1], RDP_Return);
	  MYwrite_char (kidmum[1], (unsigned char) i);
	  if (i)
	    MYwrite_word (kidmum[1], y);	/* number of bytes sent without error */
	  break;

	case RDP_OSOpReply:
	  /* OS Operation Reply */
	  MYread_char (mumkid[0], &c);
	  if (c == 1)
	    MYread_char (mumkid[0], (char *) reply);
	  if (c == 2)
	    MYread_word (mumkid[0], reply);
	  return c;
	  break;

	default:
	  fprintf (stderr,
		   "HELP! Unaccounted-for message during OS request. \n");
	  MYwrite_char (kidmum[1], RDP_Fatal);
	}
d509 1
@


