head	1.18;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.18
	gdb_7_6-2013-04-26-release:1.18
	gdb_7_6-branch:1.18.0.2
	gdb_7_6-2013-03-12-branchpoint:1.18
	gdb_7_5_1-2012-11-29-release:1.16
	gdb_7_5-2012-08-17-release:1.16
	gdb_7_5-branch:1.16.0.62
	gdb_7_5-2012-07-18-branchpoint:1.16
	gdb_7_4_1-2012-04-26-release:1.16
	gdb_7_4-2012-01-24-release:1.16
	gdb_7_4-branch:1.16.0.60
	gdb_7_4-2011-12-13-branchpoint:1.16
	gdb_7_3_1-2011-09-04-release:1.16
	gdb_7_3-2011-07-26-release:1.16
	gdb_7_3-branch:1.16.0.58
	gdb_7_3-2011-04-01-branchpoint:1.16
	gdb_7_2-2010-09-02-release:1.16
	gdb_7_2-branch:1.16.0.56
	gdb_7_2-2010-07-07-branchpoint:1.16
	gdb_7_1-2010-03-18-release:1.16
	gdb_7_1-branch:1.16.0.54
	gdb_7_1-2010-02-18-branchpoint:1.16
	gdb_7_0_1-2009-12-22-release:1.16
	gdb_7_0-2009-10-06-release:1.16
	gdb_7_0-branch:1.16.0.52
	gdb_7_0-2009-09-16-branchpoint:1.16
	arc-sim-20090309:1.16
	msnyder-checkpoint-072509-branch:1.16.0.50
	msnyder-checkpoint-072509-branchpoint:1.16
	arc-insight_6_8-branch:1.16.0.48
	arc-insight_6_8-branchpoint:1.16
	insight_6_8-branch:1.16.0.46
	insight_6_8-branchpoint:1.16
	reverse-20081226-branch:1.16.0.44
	reverse-20081226-branchpoint:1.16
	multiprocess-20081120-branch:1.16.0.42
	multiprocess-20081120-branchpoint:1.16
	reverse-20080930-branch:1.16.0.40
	reverse-20080930-branchpoint:1.16
	reverse-20080717-branch:1.16.0.38
	reverse-20080717-branchpoint:1.16
	msnyder-reverse-20080609-branch:1.16.0.36
	msnyder-reverse-20080609-branchpoint:1.16
	drow-reverse-20070409-branch:1.16.0.34
	drow-reverse-20070409-branchpoint:1.16
	gdb_6_8-2008-03-27-release:1.16
	gdb_6_8-branch:1.16.0.32
	gdb_6_8-2008-02-26-branchpoint:1.16
	gdb_6_7_1-2007-10-29-release:1.16
	gdb_6_7-2007-10-10-release:1.16
	gdb_6_7-branch:1.16.0.30
	gdb_6_7-2007-09-07-branchpoint:1.16
	insight_6_6-20070208-release:1.16
	gdb_6_6-2006-12-18-release:1.16
	gdb_6_6-branch:1.16.0.28
	gdb_6_6-2006-11-15-branchpoint:1.16
	insight_6_5-20061003-release:1.16
	gdb-csl-symbian-6_4_50_20060226-12:1.16
	gdb-csl-sourcerygxx-3_4_4-25:1.16
	nickrob-async-20060828-mergepoint:1.16
	gdb-csl-symbian-6_4_50_20060226-11:1.16
	gdb-csl-sourcerygxx-4_1-17:1.16
	gdb-csl-20060226-branch-local-2:1.16
	gdb-csl-sourcerygxx-4_1-14:1.16
	gdb-csl-sourcerygxx-4_1-13:1.16
	gdb-csl-sourcerygxx-4_1-12:1.16
	gdb-csl-sourcerygxx-3_4_4-21:1.16
	gdb_6_5-20060621-release:1.16
	gdb-csl-sourcerygxx-4_1-9:1.16
	gdb-csl-sourcerygxx-4_1-8:1.16
	gdb-csl-sourcerygxx-4_1-7:1.16
	gdb-csl-arm-2006q1-6:1.16
	gdb-csl-sourcerygxx-4_1-6:1.16
	gdb-csl-symbian-6_4_50_20060226-10:1.16
	gdb-csl-symbian-6_4_50_20060226-9:1.16
	gdb-csl-symbian-6_4_50_20060226-8:1.16
	gdb-csl-coldfire-4_1-11:1.16
	gdb-csl-sourcerygxx-3_4_4-19:1.16
	gdb-csl-coldfire-4_1-10:1.16
	gdb_6_5-branch:1.16.0.26
	gdb_6_5-2006-05-14-branchpoint:1.16
	gdb-csl-sourcerygxx-4_1-5:1.16
	nickrob-async-20060513-branch:1.16.0.24
	nickrob-async-20060513-branchpoint:1.16
	gdb-csl-sourcerygxx-4_1-4:1.16
	msnyder-reverse-20060502-branch:1.16.0.22
	msnyder-reverse-20060502-branchpoint:1.16
	gdb-csl-morpho-4_1-4:1.16
	gdb-csl-sourcerygxx-3_4_4-17:1.16
	readline_5_1-import-branch:1.16.0.20
	readline_5_1-import-branchpoint:1.16
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.16
	gdb-csl-symbian-20060226-branch:1.16.0.18
	gdb-csl-symbian-20060226-branchpoint:1.16
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.16
	msnyder-reverse-20060331-branch:1.16.0.16
	msnyder-reverse-20060331-branchpoint:1.16
	gdb-csl-available-20060303-branch:1.16.0.14
	gdb-csl-available-20060303-branchpoint:1.16
	gdb-csl-20060226-branch:1.16.0.12
	gdb-csl-20060226-branchpoint:1.16
	gdb_6_4-20051202-release:1.16
	msnyder-fork-checkpoint-branch:1.16.0.10
	msnyder-fork-checkpoint-branchpoint:1.16
	gdb-csl-gxxpro-6_3-branch:1.16.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.16
	gdb_6_4-branch:1.16.0.6
	gdb_6_4-2005-11-01-branchpoint:1.16
	gdb-csl-arm-20051020-branch:1.16.0.4
	gdb-csl-arm-20051020-branchpoint:1.16
	msnyder-tracepoint-checkpoint-branch:1.16.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.16
	gdb-csl-arm-20050325-2005-q1b:1.15
	gdb-csl-arm-20050325-2005-q1a:1.15
	csl-arm-20050325-branch:1.15.0.48
	csl-arm-20050325-branchpoint:1.15
	gdb_6_3-20041109-release:1.15
	gdb_6_3-branch:1.15.0.44
	gdb_6_3-20041019-branchpoint:1.15
	drow_intercu-merge-20040921:1.15
	drow_intercu-merge-20040915:1.15
	jimb-gdb_6_2-e500-branch:1.15.0.46
	jimb-gdb_6_2-e500-branchpoint:1.15
	gdb_6_2-20040730-release:1.15
	gdb_6_2-branch:1.15.0.42
	gdb_6_2-2004-07-10-gmt-branchpoint:1.15
	gdb_6_1_1-20040616-release:1.15
	gdb_6_1-2004-04-05-release:1.15
	drow_intercu-merge-20040402:1.15
	drow_intercu-merge-20040327:1.15
	ezannoni_pie-20040323-branch:1.15.0.40
	ezannoni_pie-20040323-branchpoint:1.15
	cagney_tramp-20040321-mergepoint:1.15
	cagney_tramp-20040309-branch:1.15.0.38
	cagney_tramp-20040309-branchpoint:1.15
	gdb_6_1-branch:1.15.0.36
	gdb_6_1-2004-03-01-gmt-branchpoint:1.15
	drow_intercu-20040221-branch:1.15.0.34
	drow_intercu-20040221-branchpoint:1.15
	cagney_bfdfile-20040213-branch:1.15.0.32
	cagney_bfdfile-20040213-branchpoint:1.15
	drow-cplus-merge-20040208:1.15
	carlton_dictionary-20040126-merge:1.15
	cagney_bigcore-20040122-branch:1.15.0.30
	cagney_bigcore-20040122-branchpoint:1.15
	drow-cplus-merge-20040113:1.15
	drow-cplus-merge-20031224:1.15
	drow-cplus-merge-20031220:1.15
	carlton_dictionary-20031215-merge:1.15
	drow-cplus-merge-20031214:1.15
	carlton-dictionary-20031111-merge:1.15
	gdb_6_0-2003-10-04-release:1.15
	kettenis_sparc-20030918-branch:1.15.0.28
	kettenis_sparc-20030918-branchpoint:1.15
	carlton_dictionary-20030917-merge:1.15
	ezannoni_pie-20030916-branchpoint:1.15
	ezannoni_pie-20030916-branch:1.15.0.26
	cagney_x86i386-20030821-branch:1.15.0.24
	cagney_x86i386-20030821-branchpoint:1.15
	carlton_dictionary-20030805-merge:1.15
	carlton_dictionary-20030627-merge:1.15
	gdb_6_0-branch:1.15.0.22
	gdb_6_0-2003-06-23-branchpoint:1.15
	jimb-ppc64-linux-20030613-branch:1.15.0.20
	jimb-ppc64-linux-20030613-branchpoint:1.15
	cagney_convert-20030606-branch:1.15.0.18
	cagney_convert-20030606-branchpoint:1.15
	cagney_writestrings-20030508-branch:1.15.0.16
	cagney_writestrings-20030508-branchpoint:1.15
	jimb-ppc64-linux-20030528-branch:1.15.0.14
	jimb-ppc64-linux-20030528-branchpoint:1.15
	carlton_dictionary-20030523-merge:1.15
	cagney_fileio-20030521-branch:1.15.0.12
	cagney_fileio-20030521-branchpoint:1.15
	kettenis_i386newframe-20030517-mergepoint:1.15
	jimb-ppc64-linux-20030509-branch:1.15.0.10
	jimb-ppc64-linux-20030509-branchpoint:1.15
	kettenis_i386newframe-20030504-mergepoint:1.15
	carlton_dictionary-20030430-merge:1.15
	kettenis_i386newframe-20030419-branch:1.15.0.8
	kettenis_i386newframe-20030419-branchpoint:1.15
	carlton_dictionary-20030416-merge:1.15
	cagney_frameaddr-20030409-mergepoint:1.15
	kettenis_i386newframe-20030406-branch:1.15.0.6
	kettenis_i386newframe-20030406-branchpoint:1.15
	cagney_frameaddr-20030403-branchpoint:1.15
	cagney_frameaddr-20030403-branch:1.15.0.4
	cagney_framebase-20030330-mergepoint:1.15
	cagney_framebase-20030326-branch:1.15.0.2
	cagney_framebase-20030326-branchpoint:1.15
	cagney_lazyid-20030317-branch:1.14.0.30
	cagney_lazyid-20030317-branchpoint:1.14
	kettenis-i386newframe-20030316-mergepoint:1.14
	offbyone-20030313-branch:1.14.0.28
	offbyone-20030313-branchpoint:1.14
	kettenis-i386newframe-20030308-branch:1.14.0.26
	kettenis-i386newframe-20030308-branchpoint:1.14
	carlton_dictionary-20030305-merge:1.14
	cagney_offbyone-20030303-branch:1.14.0.24
	cagney_offbyone-20030303-branchpoint:1.14
	carlton_dictionary-20030207-merge:1.14
	interps-20030202-branch:1.14.0.22
	interps-20030202-branchpoint:1.14
	cagney-unwind-20030108-branch:1.14.0.20
	cagney-unwind-20030108-branchpoint:1.14
	carlton_dictionary-20021223-merge:1.14
	gdb_5_3-2002-12-12-release:1.14
	carlton_dictionary-20021115-merge:1.14
	kseitz_interps-20021105-merge:1.14
	kseitz_interps-20021103-merge:1.14
	drow-cplus-merge-20021020:1.14
	drow-cplus-merge-20021025:1.14
	carlton_dictionary-20021025-merge:1.14
	carlton_dictionary-20021011-merge:1.14
	drow-cplus-branch:1.14.0.18
	drow-cplus-branchpoint:1.14
	kseitz_interps-20020930-merge:1.14
	carlton_dictionary-20020927-merge:1.14
	carlton_dictionary-branch:1.14.0.16
	carlton_dictionary-20020920-branchpoint:1.14
	gdb_5_3-branch:1.14.0.14
	gdb_5_3-2002-09-04-branchpoint:1.14
	kseitz_interps-20020829-merge:1.14
	cagney_sysregs-20020825-branch:1.14.0.12
	cagney_sysregs-20020825-branchpoint:1.14
	readline_4_3-import-branch:1.14.0.10
	readline_4_3-import-branchpoint:1.14
	gdb_5_2_1-2002-07-23-release:1.14
	kseitz_interps-20020528-branch:1.14.0.8
	kseitz_interps-20020528-branchpoint:1.14
	cagney_regbuf-20020515-branch:1.14.0.6
	cagney_regbuf-20020515-branchpoint:1.14
	jimb-macro-020506-branch:1.14.0.4
	jimb-macro-020506-branchpoint:1.14
	gdb_5_2-2002-04-29-release:1.14
	gdb_5_2-branch:1.14.0.2
	gdb_5_2-2002-03-03-branchpoint:1.14
	gdb_5_1_1-2002-01-24-release:1.12
	gdb_5_1_0_1-2002-01-03-release:1.12
	gdb_5_1_0_1-2002-01-03-branch:1.12.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.12
	gdb_5_1-2001-11-21-release:1.12
	gdb_s390-2001-09-26-branch:1.12.0.4
	gdb_s390-2001-09-26-branchpoint:1.12
	gdb_5_1-2001-07-29-branch:1.12.0.2
	gdb_5_1-2001-07-29-branchpoint:1.12
	insight-precleanup-2001-01-01:1.10
	gdb-premipsmulti-2000-06-06-branch:1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.18
date	2012.12.19.07.18.14;	author brobecke;	state Exp;
branches;
next	1.17;

1.17
date	2012.12.19.07.11.58;	author brobecke;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.12.07.36.58;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.20.12.25.07;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.10.11.14.57;	author nickc;	state Exp;
branches
	1.14.16.1
	1.14.18.1;
next	1.13;

1.13
date	2001.10.18.12.20.49;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.28.01.04.24;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.12.23.29.49;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.30.01.55.12;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.15.23.55.50;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.04.07.18.18;	author aoliva;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.04.06.52.30;	author aoliva;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.04.06.35.36;	author aoliva;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.04.06.19.29;	author aoliva;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.04.06.06.30;	author aoliva;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.20.09.36.12;	author aoliva;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.08.20.54.27;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.55;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.14.16.1
date	2003.04.16.19.57.07;	author carlton;	state Exp;
branches;
next	;

1.14.18.1
date	2003.12.14.20.28.16;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.55;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.01.26.21.49.13;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.02.05.07.30.18;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.18
log
@[sim] Update old contact info in GPL license notices

sim/ChangeLog:

        Update old contact info in GPL license notices.
@
text
@/*  armemu.h -- ARMulator emulation macros:  ARM6 Instruction Emulator.
    Copyright (C) 1994 Advanced RISC Machines Ltd.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, see <http://www.gnu.org/licenses/>. */

extern ARMword isize;

/* Condition code values.  */
#define EQ 0
#define NE 1
#define CS 2
#define CC 3
#define MI 4
#define PL 5
#define VS 6
#define VC 7
#define HI 8
#define LS 9
#define GE 10
#define LT 11
#define GT 12
#define LE 13
#define AL 14
#define NV 15

/* Shift Opcodes.  */
#define LSL 0
#define LSR 1
#define ASR 2
#define ROR 3

/* Macros to twiddle the status flags and mode.  */
#define NBIT ((unsigned)1L << 31)
#define ZBIT (1L << 30)
#define CBIT (1L << 29)
#define VBIT (1L << 28)
#define SBIT (1L << 27)
#define IBIT (1L << 7)
#define FBIT (1L << 6)
#define IFBITS (3L << 6)
#define R15IBIT (1L << 27)
#define R15FBIT (1L << 26)
#define R15IFBITS (3L << 26)

#define POS(i) ( (~(i)) >> 31 )
#define NEG(i) ( (i) >> 31 )

#ifdef MODET			/* Thumb support.  */
/* ??? This bit is actually in the low order bit of the PC in the hardware.
   It isn't clear if the simulator needs to model that or not.  */
#define TBIT (1L << 5)
#define TFLAG state->TFlag
#define SETT state->TFlag = 1
#define CLEART state->TFlag = 0
#define ASSIGNT(res) state->TFlag = res
#define INSN_SIZE (TFLAG ? 2 : 4)
#else
#define INSN_SIZE 4
#endif

#define NFLAG state->NFlag
#define SETN state->NFlag = 1
#define CLEARN state->NFlag = 0
#define ASSIGNN(res) state->NFlag = res

#define ZFLAG state->ZFlag
#define SETZ state->ZFlag = 1
#define CLEARZ state->ZFlag = 0
#define ASSIGNZ(res) state->ZFlag = res

#define CFLAG state->CFlag
#define SETC state->CFlag = 1
#define CLEARC state->CFlag = 0
#define ASSIGNC(res) state->CFlag = res

#define VFLAG state->VFlag
#define SETV state->VFlag = 1
#define CLEARV state->VFlag = 0
#define ASSIGNV(res) state->VFlag = res

#define SFLAG state->SFlag
#define SETS state->SFlag = 1
#define CLEARS state->SFlag = 0
#define ASSIGNS(res) state->SFlag = res

#define IFLAG (state->IFFlags >> 1)
#define FFLAG (state->IFFlags & 1)
#define IFFLAGS state->IFFlags
#define ASSIGNINT(res) state->IFFlags = (((res) >> 6) & 3)
#define ASSIGNR15INT(res) state->IFFlags = (((res) >> 26) & 3) ;

#define PSR_FBITS (0xff000000L)
#define PSR_SBITS (0x00ff0000L)
#define PSR_XBITS (0x0000ff00L)
#define PSR_CBITS (0x000000ffL)

#if defined MODE32 || defined MODET
#define CCBITS (0xf8000000L)
#else
#define CCBITS (0xf0000000L)
#endif

#define INTBITS (0xc0L)

#if defined MODET && defined MODE32
#define PCBITS (0xffffffffL)
#else
#define PCBITS (0xfffffffcL)
#endif

#define MODEBITS (0x1fL)
#define R15INTBITS (3L << 26)

#if defined MODET && defined MODE32
#define R15PCBITS (0x03ffffffL)
#else
#define R15PCBITS (0x03fffffcL)
#endif

#define R15PCMODEBITS (0x03ffffffL)
#define R15MODEBITS (0x3L)

#ifdef MODE32
#define PCMASK PCBITS
#define PCWRAP(pc) (pc)
#else
#define PCMASK R15PCBITS
#define PCWRAP(pc) ((pc) & R15PCBITS)
#endif

#define PC (state->Reg[15] & PCMASK)
#define R15CCINTMODE (state->Reg[15] & (CCBITS | R15INTBITS | R15MODEBITS))
#define R15INT (state->Reg[15] & R15INTBITS)
#define R15INTPC (state->Reg[15] & (R15INTBITS | R15PCBITS))
#define R15INTPCMODE (state->Reg[15] & (R15INTBITS | R15PCBITS | R15MODEBITS))
#define R15INTMODE (state->Reg[15] & (R15INTBITS | R15MODEBITS))
#define R15PC (state->Reg[15] & R15PCBITS)
#define R15PCMODE (state->Reg[15] & (R15PCBITS | R15MODEBITS))
#define R15MODE (state->Reg[15] & R15MODEBITS)

#define ECC ((NFLAG << 31) | (ZFLAG << 30) | (CFLAG << 29) | (VFLAG << 28) | (SFLAG << 27))
#define EINT (IFFLAGS << 6)
#define ER15INT (IFFLAGS << 26)
#define EMODE (state->Mode)

#ifdef MODET
#define CPSR (ECC | EINT | EMODE | (TFLAG << 5))
#else
#define CPSR (ECC | EINT | EMODE)
#endif

#ifdef MODE32
#define PATCHR15
#else
#define PATCHR15 state->Reg[15] = ECC | ER15INT | EMODE | R15PC
#endif

#define GETSPSR(bank) (ARMul_GetSPSR (state, EMODE))
#define SETPSR_F(d,s) d = ((d) & ~PSR_FBITS) | ((s) & PSR_FBITS)
#define SETPSR_S(d,s) d = ((d) & ~PSR_SBITS) | ((s) & PSR_SBITS)
#define SETPSR_X(d,s) d = ((d) & ~PSR_XBITS) | ((s) & PSR_XBITS)
#define SETPSR_C(d,s) d = ((d) & ~PSR_CBITS) | ((s) & PSR_CBITS)

#define SETR15PSR(s) 								\
  do										\
    {										\
      if (state->Mode == USER26MODE)						\
        {									\
          state->Reg[15] = ((s) & CCBITS) | R15PC | ER15INT | EMODE;		\
          ASSIGNN ((state->Reg[15] & NBIT) != 0);				\
          ASSIGNZ ((state->Reg[15] & ZBIT) != 0);				\
          ASSIGNC ((state->Reg[15] & CBIT) != 0);				\
          ASSIGNV ((state->Reg[15] & VBIT) != 0);				\
        }									\
      else									\
        {									\
          state->Reg[15] = R15PC | ((s) & (CCBITS | R15INTBITS | R15MODEBITS));	\
          ARMul_R15Altered (state);						\
       }									\
    }										\
  while (0)
     
#define SETABORT(i, m, d)						\
  do									\
    { 									\
      int SETABORT_mode = (m);						\
									\
      ARMul_SetSPSR (state, SETABORT_mode, ARMul_GetCPSR (state));	\
      ARMul_SetCPSR (state, ((ARMul_GetCPSR (state) & ~(EMODE | TBIT))	\
			     | (i) | SETABORT_mode));			\
      state->Reg[14] = temp - (d);					\
    }									\
  while (0)

#ifndef MODE32
#define VECTORS 0x20
#define LEGALADDR 0x03ffffff
#define VECTORACCESS(address) (address < VECTORS && ARMul_MODE26BIT && state->prog32Sig)
#define ADDREXCEPT(address)   (address > LEGALADDR && !state->data32Sig)
#endif

#define INTERNALABORT(address)			\
  do						\
    {						\
      if (address < VECTORS)			\
	state->Aborted = ARMul_DataAbortV;	\
      else					\
	state->Aborted = ARMul_AddrExceptnV;	\
    }						\
  while (0)

#ifdef MODE32
#define TAKEABORT ARMul_Abort (state, ARMul_DataAbortV)
#else
#define TAKEABORT 					\
  do							\
    {							\
      if (state->Aborted == ARMul_AddrExceptnV) 	\
	ARMul_Abort (state, ARMul_AddrExceptnV); 	\
      else 						\
	ARMul_Abort (state, ARMul_DataAbortV);		\
    }							\
  while (0)
#endif

#define CPTAKEABORT					\
  do							\
    {							\
      if (!state->Aborted)				\
	ARMul_Abort (state, ARMul_UndefinedInstrV); 	\
      else if (state->Aborted == ARMul_AddrExceptnV) 	\
	ARMul_Abort (state, ARMul_AddrExceptnV); 	\
      else 						\
	ARMul_Abort (state, ARMul_DataAbortV);		\
    }							\
  while (0);


/* Different ways to start the next instruction.  */
#define SEQ           0
#define NONSEQ        1
#define PCINCEDSEQ    2
#define PCINCEDNONSEQ 3
#define PRIMEPIPE     4
#define RESUME        8

#define NORMALCYCLE state->NextInstr = 0
#define BUSUSEDN    state->NextInstr |= 1  /* The next fetch will be an N cycle.  */
#define BUSUSEDINCPCS						\
  do								\
    {								\
      if (! state->is_v4)					\
        {							\
	  /* A standard PC inc and an S cycle.  */		\
	  state->Reg[15] += isize;				\
	  state->NextInstr = (state->NextInstr & 0xff) | 2;	\
	}							\
    }								\
  while (0)

#define BUSUSEDINCPCN					\
  do							\
    {							\
      if (state->is_v4)					\
	BUSUSEDN;					\
      else						\
	{						\
	  /* A standard PC inc and an N cycle.  */	\
	  state->Reg[15] += isize;			\
	  state->NextInstr |= 3;			\
	}						\
    }							\
  while (0)

#define INCPC 			\
  do				\
    {				\
      /* A standard PC inc.  */	\
      state->Reg[15] += isize;	\
      state->NextInstr |= 2;	\
    }				\
  while (0)

#define FLUSHPIPE state->NextInstr |= PRIMEPIPE

/* Cycle based emulation.  */

#define OUTPUTCP(i,a,b)
#define NCYCLE
#define SCYCLE
#define ICYCLE
#define CCYCLE
#define NEXTCYCLE(c)

/* Macros to extract parts of instructions.  */
#define DESTReg (BITS (12, 15))
#define LHSReg  (BITS (16, 19))
#define RHSReg  (BITS ( 0,  3))

#define DEST (state->Reg[DESTReg])

#ifdef MODE32
#ifdef MODET
#define LHS ((LHSReg == 15) ? (state->Reg[15] & 0xFFFFFFFC): (state->Reg[LHSReg]))
#else
#define LHS (state->Reg[LHSReg])
#endif
#else
#define LHS ((LHSReg == 15) ? R15PC : (state->Reg[LHSReg]))
#endif

#define MULDESTReg (BITS (16, 19))
#define MULLHSReg  (BITS ( 0,  3))
#define MULRHSReg  (BITS ( 8, 11))
#define MULACCReg  (BITS (12, 15))

#define DPImmRHS (ARMul_ImmedTable[BITS(0, 11)])
#define DPSImmRHS temp = BITS(0,11) ; \
                  rhs = ARMul_ImmedTable[temp] ; \
                  if (temp > 255) /* There was a shift.  */ \
                     ASSIGNC (rhs >> 31) ;

#ifdef MODE32
#define DPRegRHS  ((BITS (4,11) == 0) ? state->Reg[RHSReg] \
                                      : GetDPRegRHS (state, instr))
#define DPSRegRHS ((BITS (4,11) == 0) ? state->Reg[RHSReg] \
                                      : GetDPSRegRHS (state, instr))
#else
#define DPRegRHS  ((BITS (0, 11) < 15) ? state->Reg[RHSReg] \
                                       : GetDPRegRHS (state, instr))
#define DPSRegRHS ((BITS (0, 11) < 15) ? state->Reg[RHSReg] \
                                       : GetDPSRegRHS (state, instr))
#endif

#define LSBase state->Reg[LHSReg]
#define LSImmRHS (BITS(0,11))

#ifdef MODE32
#define LSRegRHS ((BITS (4, 11) == 0) ? state->Reg[RHSReg] \
                                      : GetLSRegRHS (state, instr))
#else
#define LSRegRHS ((BITS (0, 11) < 15) ? state->Reg[RHSReg] \
                                      : GetLSRegRHS (state, instr))
#endif

#define LSMNumRegs ((ARMword) ARMul_BitList[BITS (0, 7)] + \
                    (ARMword) ARMul_BitList[BITS (8, 15)] )
#define LSMBaseFirst ((LHSReg == 0 && BIT (0)) || \
                      (BIT (LHSReg) && BITS (0, LHSReg - 1) == 0))

#define SWAPSRC (state->Reg[RHSReg])

#define LSCOff (BITS (0, 7) << 2)
#define CPNum   BITS (8, 11)

/* Determine if access to coprocessor CP is permitted.
   The XScale has a register in CP15 which controls access to CP0 - CP13.  */
#define CP_ACCESS_ALLOWED(STATE, CP)			\
    (   ((CP) >= 14)					\
     || (! (STATE)->is_XScale)				\
     || (read_cp15_reg (15, 0, 1) & (1 << (CP))))

/* Macro to rotate n right by b bits.  */
#define ROTATER(n, b) (((n) >> (b)) | ((n) << (32 - (b))))

/* Macros to store results of instructions.  */
#define WRITEDEST(d)				\
  do						\
    {						\
      if (DESTReg == 15) 			\
	WriteR15 (state, d); 			\
      else 					\
	DEST = d;				\
    }						\
  while (0)

#define WRITESDEST(d)				\
  do						\
    {						\
      if (DESTReg == 15)			\
	WriteSR15 (state, d);			\
      else					\
	{					\
	  DEST = d;				\
	  ARMul_NegZero (state, d);		\
	}					\
    }						\
  while (0)

#define WRITEDESTB(d)				\
  do						\
    {						\
      if (DESTReg == 15)			\
	WriteR15Branch (state, d);		\
      else					\
	DEST = d;				\
    }						\
  while (0)

#define BYTETOBUS(data) ((data & 0xff) | \
                        ((data & 0xff) << 8) | \
                        ((data & 0xff) << 16) | \
                        ((data & 0xff) << 24))

#define BUSTOBYTE(address, data)				\
  do								\
    {								\
      if (state->bigendSig) 					\
	temp = (data >> (((address ^ 3) & 3) << 3)) & 0xff;	\
      else							\
	temp = (data >> ((address & 3) << 3)) & 0xff;		\
    }								\
  while (0)

#define LOADMULT(instr,   address, wb)  LoadMult   (state, instr, address, wb)
#define LOADSMULT(instr,  address, wb)  LoadSMult  (state, instr, address, wb)
#define STOREMULT(instr,  address, wb)  StoreMult  (state, instr, address, wb)
#define STORESMULT(instr, address, wb)  StoreSMult (state, instr, address, wb)

#define POSBRANCH ((instr & 0x7fffff) << 2)
#define NEGBRANCH ((0xff000000 |(instr & 0xffffff)) << 2)


/* Values for Emulate.  */
#define STOP            0	/* stop */
#define CHANGEMODE      1	/* change mode */
#define ONCE            2	/* execute just one interation */
#define RUN             3	/* continuous execution */

/* Stuff that is shared across modes.  */
extern unsigned ARMul_MultTable[];	/* Number of I cycles for a mult.  */
extern ARMword  ARMul_ImmedTable[];	/* Immediate DP LHS values.  */
extern char     ARMul_BitList[];	/* Number of bits in a byte table.  */

#define EVENTLISTSIZE 1024L

/* Thumb support.  */
typedef enum
{
  t_undefined,		/* Undefined Thumb instruction.  */
  t_decoded,		/* Instruction decoded to ARM equivalent.  */
  t_branch		/* Thumb branch (already processed).  */
}
tdstate;

/* Macros to scrutinize instructions.  */
#define UNDEF_Test
#define UNDEF_Shift
#define UNDEF_MSRPC
#define UNDEF_MRSPC
#define UNDEF_MULPCDest
#define UNDEF_MULDestEQOp1
#define UNDEF_LSRBPC
#define UNDEF_LSRBaseEQOffWb
#define UNDEF_LSRBaseEQDestWb
#define UNDEF_LSRPCBaseWb
#define UNDEF_LSRPCOffWb
#define UNDEF_LSMNoRegs
#define UNDEF_LSMPCBase
#define UNDEF_LSMUserBankWb
#define UNDEF_LSMBaseInListWb
#define UNDEF_SWPPC
#define UNDEF_CoProHS
#define UNDEF_MCRPC
#define UNDEF_LSCPCBaseWb
#define UNDEF_UndefNotBounced
#define UNDEF_ShortInt
#define UNDEF_IllegalMode
#define UNDEF_Prog32SigChange
#define UNDEF_Data32SigChange

/* Prototypes for exported functions.  */
extern unsigned ARMul_NthReg        (ARMword, unsigned);
extern int      AddOverflow         (ARMword, ARMword, ARMword);
extern int      SubOverflow         (ARMword, ARMword, ARMword);
extern ARMword  ARMul_Emulate26     (ARMul_State *);
extern ARMword  ARMul_Emulate32     (ARMul_State *);
extern unsigned IntPending          (ARMul_State *);
extern void     ARMul_CPSRAltered   (ARMul_State *);
extern void     ARMul_R15Altered    (ARMul_State *);
extern ARMword  ARMul_GetPC         (ARMul_State *);
extern ARMword  ARMul_GetNextPC     (ARMul_State *);
extern ARMword  ARMul_GetR15        (ARMul_State *);
extern ARMword  ARMul_GetCPSR       (ARMul_State *);
extern void     ARMul_EnvokeEvent   (ARMul_State *);
extern unsigned long ARMul_Time     (ARMul_State *);
extern void     ARMul_NegZero       (ARMul_State *, ARMword);
extern void     ARMul_SetPC         (ARMul_State *, ARMword);
extern void     ARMul_SetR15        (ARMul_State *, ARMword);
extern void     ARMul_SetCPSR       (ARMul_State *, ARMword);
extern ARMword  ARMul_GetSPSR       (ARMul_State *, ARMword);
extern void     ARMul_Abort26       (ARMul_State *, ARMword);
extern void     ARMul_Abort32       (ARMul_State *, ARMword);
extern ARMword  ARMul_MRC           (ARMul_State *, ARMword);
extern void     ARMul_CDP           (ARMul_State *, ARMword);
extern void     ARMul_LDC           (ARMul_State *, ARMword, ARMword);
extern void     ARMul_STC           (ARMul_State *, ARMword, ARMword);
extern void     ARMul_MCR           (ARMul_State *, ARMword, ARMword);
extern void     ARMul_SetSPSR       (ARMul_State *, ARMword, ARMword);
extern ARMword  ARMul_SwitchMode    (ARMul_State *, ARMword, ARMword);
extern ARMword  ARMul_Align         (ARMul_State *, ARMword, ARMword);
extern ARMword  ARMul_SwitchMode    (ARMul_State *, ARMword, ARMword);
extern void     ARMul_MSRCpsr       (ARMul_State *, ARMword, ARMword);
extern void     ARMul_SubOverflow   (ARMul_State *, ARMword, ARMword, ARMword);
extern void     ARMul_AddOverflow   (ARMul_State *, ARMword, ARMword, ARMword);
extern void     ARMul_SubCarry      (ARMul_State *, ARMword, ARMword, ARMword);
extern void     ARMul_AddCarry      (ARMul_State *, ARMword, ARMword, ARMword);
extern tdstate  ARMul_ThumbDecode   (ARMul_State *, ARMword, ARMword, ARMword *);
extern ARMword  ARMul_GetReg        (ARMul_State *, unsigned, unsigned);
extern void     ARMul_SetReg        (ARMul_State *, unsigned, unsigned, ARMword);
extern void     ARMul_ScheduleEvent (ARMul_State *, unsigned long, unsigned (*) (ARMul_State *));
/* Coprocessor support functions.  */
extern unsigned ARMul_CoProInit     (ARMul_State *);
extern void     ARMul_CoProExit     (ARMul_State *);
extern void     ARMul_CoProAttach   (ARMul_State *, unsigned, ARMul_CPInits *, ARMul_CPExits *,
				     ARMul_LDCs *, ARMul_STCs *, ARMul_MRCs *, ARMul_MCRs *,
				     ARMul_CDPs *, ARMul_CPReads *, ARMul_CPWrites *);
extern void     ARMul_CoProDetach   (ARMul_State *, unsigned);
extern ARMword  read_cp15_reg       (unsigned, unsigned, unsigned);

extern unsigned DSPLDC4 (ARMul_State *, unsigned, ARMword, ARMword);
extern unsigned DSPMCR4 (ARMul_State *, unsigned, ARMword, ARMword);
extern unsigned DSPMRC4 (ARMul_State *, unsigned, ARMword, ARMword *);
extern unsigned	DSPSTC4 (ARMul_State *, unsigned, ARMword, ARMword *);
extern unsigned	DSPCDP4 (ARMul_State *, unsigned, ARMword);
extern unsigned DSPMCR5 (ARMul_State *, unsigned, ARMword, ARMword);
extern unsigned DSPMRC5 (ARMul_State *, unsigned, ARMword, ARMword *);
extern unsigned DSPLDC5 (ARMul_State *, unsigned, ARMword, ARMword);
extern unsigned	DSPSTC5 (ARMul_State *, unsigned, ARMword, ARMword *);
extern unsigned	DSPCDP5 (ARMul_State *, unsigned, ARMword);
extern unsigned DSPMCR6 (ARMul_State *, unsigned, ARMword, ARMword);
extern unsigned DSPMRC6 (ARMul_State *, unsigned, ARMword, ARMword *);
extern unsigned	DSPCDP6 (ARMul_State *, unsigned, ARMword);
@


1.17
log
@Update sim copyright headers from GPLv2-or-later to GPLv3-or-later.

gdb/sim/ChangeLog:

        Update the non-FSF-copyrighted files in sim to GPLv3 or later.
@
text
@d15 1
a15 2
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA. */
@


1.16
log
@Update the address of the FSF organization
@
text
@d6 1
a6 1
    the Free Software Foundation; either version 2 of the License, or
@


1.15
log
@Add Cirrus Maverick support to arm simulator
@
text
@d16 1
a16 1
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
@


1.14
log
@Fix parameters passed to CPRead[13] and CPRead[14].
@
text
@d533 13
@


1.14.18.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a532 13
extern unsigned DSPLDC4 (ARMul_State *, unsigned, ARMword, ARMword);
extern unsigned DSPMCR4 (ARMul_State *, unsigned, ARMword, ARMword);
extern unsigned DSPMRC4 (ARMul_State *, unsigned, ARMword, ARMword *);
extern unsigned	DSPSTC4 (ARMul_State *, unsigned, ARMword, ARMword *);
extern unsigned	DSPCDP4 (ARMul_State *, unsigned, ARMword);
extern unsigned DSPMCR5 (ARMul_State *, unsigned, ARMword, ARMword);
extern unsigned DSPMRC5 (ARMul_State *, unsigned, ARMword, ARMword *);
extern unsigned DSPLDC5 (ARMul_State *, unsigned, ARMword, ARMword);
extern unsigned	DSPSTC5 (ARMul_State *, unsigned, ARMword, ARMword *);
extern unsigned	DSPCDP5 (ARMul_State *, unsigned, ARMword);
extern unsigned DSPMCR6 (ARMul_State *, unsigned, ARMword, ARMword);
extern unsigned DSPMRC6 (ARMul_State *, unsigned, ARMword, ARMword *);
extern unsigned	DSPCDP6 (ARMul_State *, unsigned, ARMword);
@


1.14.16.1
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a532 13
extern unsigned DSPLDC4 (ARMul_State *, unsigned, ARMword, ARMword);
extern unsigned DSPMCR4 (ARMul_State *, unsigned, ARMword, ARMword);
extern unsigned DSPMRC4 (ARMul_State *, unsigned, ARMword, ARMword *);
extern unsigned	DSPSTC4 (ARMul_State *, unsigned, ARMword, ARMword *);
extern unsigned	DSPCDP4 (ARMul_State *, unsigned, ARMword);
extern unsigned DSPMCR5 (ARMul_State *, unsigned, ARMword, ARMword);
extern unsigned DSPMRC5 (ARMul_State *, unsigned, ARMword, ARMword *);
extern unsigned DSPLDC5 (ARMul_State *, unsigned, ARMword, ARMword);
extern unsigned	DSPSTC5 (ARMul_State *, unsigned, ARMword, ARMword *);
extern unsigned	DSPCDP5 (ARMul_State *, unsigned, ARMword);
extern unsigned DSPMCR6 (ARMul_State *, unsigned, ARMword, ARMword);
extern unsigned DSPMRC6 (ARMul_State *, unsigned, ARMword, ARMword *);
extern unsigned	DSPCDP6 (ARMul_State *, unsigned, ARMword);
@


1.13
log
@Add support for XScale's coprocessor access check register.
Fix formatting.
@
text
@d308 3
a310 3
#define DESTReg (BITS(12,15))
#define LHSReg (BITS(16,19))
#define RHSReg (BITS(0,3))
d370 3
a372 3
#define CP_ACCESS_ALLOWED(STATE, CP)                \
    (   ((CP) >= 14) \
     || (! (STATE)->is_XScale) \
d379 32
a410 16
#define WRITEDEST(d) if (DESTReg == 15) \
                        WriteR15 (state, d) ; \
                     else \
                          DEST = d

#define WRITESDEST(d) if (DESTReg == 15) \
                         WriteSR15 (state, d) ; \
                      else { \
                         DEST = d ; \
                         ARMul_NegZero (state, d) ; \
                         }

#define WRITEDESTB(d) if (DESTReg == 15) \
                        WriteR15Branch (state, d) ; \
                     else \
                          DEST = d
d417 9
a425 5
#define BUSTOBYTE(address, data) \
           if (state->bigendSig) \
              temp = (data >> (((address ^ 3) & 3) << 3)) & 0xff ; \
           else \
              temp = (data >> ((address & 3) << 3)) & 0xff
a436 1

@


1.12
log
@Add support for disabling alignment checks when performing GDB interface
calls or SWI emulaiton routines.  (Alignment checking code has not yet been
contributed).
@
text
@d20 1
a20 4
/***************************************************************************\
*                           Condition code values                           *
\***************************************************************************/

d38 1
a38 4
/***************************************************************************\
*                               Shift Opcodes                               *
\***************************************************************************/

d44 1
a44 4
/***************************************************************************\
*               Macros to twiddle the status flags and mode                 *
\***************************************************************************/

d60 1
a60 1
#ifdef MODET			/* Thumb support */
d175 31
a205 18
#define SETR15PSR(s) if (state->Mode == USER26MODE) { \
                        state->Reg[15] = ((s) & CCBITS) | R15PC | ER15INT | EMODE ; \
                        ASSIGNN((state->Reg[15] & NBIT) != 0) ; \
                        ASSIGNZ((state->Reg[15] & ZBIT) != 0) ; \
                        ASSIGNC((state->Reg[15] & CBIT) != 0) ; \
                        ASSIGNV((state->Reg[15] & VBIT) != 0) ; \
                        } \
                     else { \
                        state->Reg[15] = R15PC | ((s) & (CCBITS | R15INTBITS | R15MODEBITS)) ; \
                        ARMul_R15Altered (state) ; \
                        }
#define SETABORT(i,m,d) do { \
  int SETABORT_mode = (m); \
  ARMul_SetSPSR (state, SETABORT_mode, ARMul_GetCPSR (state)); \
  ARMul_SetCPSR (state, ((ARMul_GetCPSR (state) & ~(EMODE | TBIT)) \
			 | (i) | SETABORT_mode)); \
  state->Reg[14] = temp - (d); \
} while (0)
d211 1
a211 1
#define ADDREXCEPT(address) (address > LEGALADDR && !state->data32Sig)
d214 9
a222 4
#define INTERNALABORT(address) if (address < VECTORS) \
                                  state->Aborted = ARMul_DataAbortV ; \
                               else \
                                  state->Aborted = ARMul_AddrExceptnV ;
d225 1
a225 1
#define TAKEABORT ARMul_Abort(state,ARMul_DataAbortV)
d227 28
a254 20
#define TAKEABORT if (state->Aborted == ARMul_AddrExceptnV) \
                     ARMul_Abort(state,ARMul_AddrExceptnV) ; \
                  else \
                     ARMul_Abort(state,ARMul_DataAbortV)
#endif
#define CPTAKEABORT if (!state->Aborted) \
                       ARMul_Abort(state,ARMul_UndefinedInstrV) ; \
                    else if (state->Aborted == ARMul_AddrExceptnV) \
                       ARMul_Abort(state,ARMul_AddrExceptnV) ; \
                    else \
                       ARMul_Abort(state,ARMul_DataAbortV)


/***************************************************************************\
*               Different ways to start the next instruction                *
\***************************************************************************/

#define SEQ 0
#define NONSEQ 1
#define PCINCEDSEQ 2
d256 2
a257 2
#define PRIMEPIPE 4
#define RESUME 8
d261 24
a284 9
#define BUSUSEDINCPCS								\
  do										\
    {										\
      if (! state->is_v4)							\
        { 									\
	  state->Reg[15] += isize ; /* A standard PC inc and an S cycle.  */ 	\
	  state->NextInstr = (state->NextInstr & 0xff) | 2; 			\
	}									\
    }										\
d286 8
a293 11
#define BUSUSEDINCPCN								\
  do										\
    {										\
      if (state->is_v4)								\
	BUSUSEDN;								\
      else									\
	{ 									\
	  state->Reg[15] += isize ; /* A standard PC inc and an N cycle.  */	\
	  state->NextInstr |= 3;						\
	}									\
    }										\
d295 1
a295 2
#define INCPC state->Reg[15] += isize ; /* a standard PC inc */ \
              state->NextInstr |= 2
d298 1
a298 3
/***************************************************************************\
*                          Cycle based emulation                            *
\***************************************************************************/
d307 1
a307 9
/***************************************************************************\
*                 States of the cycle based state machine                   *
\***************************************************************************/


/***************************************************************************\
*                 Macros to extract parts of instructions                   *
\***************************************************************************/

d321 1
a321 1
#define LHS ((LHSReg == 15) ? R15PC : (state->Reg[LHSReg]) )
d324 4
a327 4
#define MULDESTReg (BITS(16,19))
#define MULLHSReg (BITS(0,3))
#define MULRHSReg (BITS(8,11))
#define MULACCReg (BITS(12,15))
d329 1
a329 1
#define DPImmRHS (ARMul_ImmedTable[BITS(0,11)])
d332 2
a333 2
                  if (temp > 255) /* there was a shift */ \
                     ASSIGNC(rhs >> 31) ;
d336 9
a344 9
#define DPRegRHS ((BITS(4,11)==0) ? state->Reg[RHSReg] \
                                  : GetDPRegRHS(state, instr))
#define DPSRegRHS ((BITS(4,11)==0) ? state->Reg[RHSReg] \
                                   : GetDPSRegRHS(state, instr))
#else
#define DPRegRHS ((BITS(0,11)<15) ? state->Reg[RHSReg] \
                                  : GetDPRegRHS(state, instr))
#define DPSRegRHS ((BITS(0,11)<15) ? state->Reg[RHSReg] \
                                   : GetDPSRegRHS(state, instr))
d351 2
a352 2
#define LSRegRHS ((BITS(4,11)==0) ? state->Reg[RHSReg] \
                                  : GetLSRegRHS(state, instr))
d354 2
a355 2
#define LSRegRHS ((BITS(0,11)<15) ? state->Reg[RHSReg] \
                                  : GetLSRegRHS(state, instr))
d358 4
a361 4
#define LSMNumRegs ((ARMword)ARMul_BitList[BITS(0,7)] + \
                    (ARMword)ARMul_BitList[BITS(8,15)] )
#define LSMBaseFirst ((LHSReg == 0 && BIT(0)) || \
                      (BIT(LHSReg) && BITS(0,LHSReg-1) == 0))
d365 2
a366 6
#define LSCOff (BITS(0,7) << 2)
#define CPNum BITS(8,11)

/***************************************************************************\
*                    Macro to rotate n right by b bits                      *
\***************************************************************************/
d368 13
a380 8
#define ROTATER(n,b) (((n)>>(b))|((n)<<(32-(b))))

/***************************************************************************\
*                 Macros to store results of instructions                   *
\***************************************************************************/

#define WRITEDEST(d) if (DESTReg==15) \
                        WriteR15(state, d) ; \
d385 1
a385 1
                         WriteSR15(state, d) ; \
d388 1
a388 1
                         ARMul_NegZero(state, d) ; \
d392 1
a392 1
                        WriteR15Branch(state, d) ; \
d400 2
a401 1
#define BUSTOBYTE(address,data) \
d407 4
a410 4
#define LOADMULT(instr,address,wb) LoadMult(state,instr,address,wb)
#define LOADSMULT(instr,address,wb) LoadSMult(state,instr,address,wb)
#define STOREMULT(instr,address,wb) StoreMult(state,instr,address,wb)
#define STORESMULT(instr,address,wb) StoreSMult(state,instr,address,wb)
d416 1
a416 3
/***************************************************************************\
*                          Values for Emulate                               *
\***************************************************************************/
d423 5
a427 37
/***************************************************************************\
*                      Stuff that is shared across modes                    *
\***************************************************************************/

extern ARMword ARMul_Emulate26 (ARMul_State * state);
extern ARMword ARMul_Emulate32 (ARMul_State * state);
extern unsigned ARMul_MultTable[];	/* Number of I cycles for a mult */
extern ARMword ARMul_ImmedTable[];	/* immediate DP LHS values */
extern char ARMul_BitList[];	/* number of bits in a byte table */
extern void ARMul_Abort26 (ARMul_State * state, ARMword);
extern void ARMul_Abort32 (ARMul_State * state, ARMword);
extern unsigned ARMul_NthReg (ARMword instr, unsigned number);
extern void ARMul_MSRCpsr (ARMul_State * state, ARMword instr, ARMword rhs);
extern void ARMul_NegZero (ARMul_State * state, ARMword result);
extern void ARMul_AddCarry (ARMul_State * state, ARMword a, ARMword b,
			    ARMword result);
extern int AddOverflow (ARMword a, ARMword b, ARMword result);
extern int SubOverflow (ARMword a, ARMword b, ARMword result);
extern void ARMul_AddOverflow (ARMul_State * state, ARMword a, ARMword b,
			       ARMword result);
extern void ARMul_SubCarry (ARMul_State * state, ARMword a, ARMword b,
			    ARMword result);
extern void ARMul_SubOverflow (ARMul_State * state, ARMword a, ARMword b,
			       ARMword result);
extern void ARMul_CPSRAltered (ARMul_State * state);
extern void ARMul_R15Altered (ARMul_State * state);
extern ARMword ARMul_SwitchMode (ARMul_State * state, ARMword oldmode,
				 ARMword newmode);
extern unsigned ARMul_NthReg (ARMword instr, unsigned number);
extern void ARMul_LDC (ARMul_State * state, ARMword instr, ARMword address);
extern void ARMul_STC (ARMul_State * state, ARMword instr, ARMword address);
extern void ARMul_MCR (ARMul_State * state, ARMword instr, ARMword source);
extern ARMword ARMul_MRC (ARMul_State * state, ARMword instr);
extern void ARMul_CDP (ARMul_State * state, ARMword instr);
extern unsigned IntPending (ARMul_State * state);
extern ARMword ARMul_Align (ARMul_State * state, ARMword address,
			    ARMword data);
d430 1
a430 2
/* Thumb support: */

d433 3
a435 3
  t_undefined,			/* undefined Thumb instruction */
  t_decoded,			/* instruction decoded to ARM equivalent */
  t_branch			/* Thumb branch (already processed) */
d439 1
a439 8
extern tdstate ARMul_ThumbDecode (ARMul_State * state, ARMword pc,
				  ARMword tinstr, ARMword * ainstr);

/***************************************************************************\
*                      Macros to scrutinize instructions                    *
\***************************************************************************/


d465 40
d506 8
a513 9
extern unsigned ARMul_CoProInit (ARMul_State *);
extern void     ARMul_CoProExit (ARMul_State *);
extern void     ARMul_CoProAttach (ARMul_State *, unsigned, ARMul_CPInits *, ARMul_CPExits *,
				   ARMul_LDCs *, ARMul_STCs *, ARMul_MRCs *, ARMul_MCRs *,
				   ARMul_CDPs *, ARMul_CPReads *, ARMul_CPWrites *);
extern void     ARMul_CoProDetach (ARMul_State *, unsigned);
extern void     write_cp15_reg (ARMul_State *, unsigned, unsigned, unsigned, ARMword);
extern void     write_cp14_reg (unsigned, ARMword);
extern ARMword  read_cp14_reg  (unsigned);
@


1.11
log
@Fix definition of NEGBRANCH
@
text
@d494 1
a494 1
extern void     write_cp15_reg (unsigned, unsigned, unsigned, ARMword);
@


1.10
log
@Add support for ARM's v5TE architecture and Intel's XScale extenstions
@
text
@d393 2
a394 1
#define NEGBRANCH (0xfc000000 | ((instr & 0xffffff) << 2))
@


1.9
log
@Replace StrongARM property with v4 and v5 properties.
@
text
@d58 1
d102 4
d118 3
d122 2
d162 1
a162 1
#define ECC ((NFLAG << 31) | (ZFLAG << 30) | (CFLAG << 29) | (VFLAG << 28))
d485 11
@


1.8
log
@* armdefs.h (struct ARMul_State): Add is_StrongARM.
(ARM_Strong_Prop, STRONGARM): Define.
* arminit.c (ARMul_NewState): Reset is_StrongARM.
(ARMul_SelectProcessor): Set is_StrongARM.
* wrapper.c (sim_create_inferior): Use bfd machine type to
determine processor type to emulate.
* armemu.h (BUSUSEDINCPCS, BUSUSEDINCPCN): Don't increment PC
when emulating StrongARM.
@
text
@d233 23
a255 9
#define BUSUSEDN state->NextInstr |= 1	/* the next fetch will be an N cycle */
#define BUSUSEDINCPCS do { if (! state->is_StrongARM) { \
			state->Reg[15] += isize ; /* a standard PC inc and an S cycle */ \
			state->NextInstr = (state->NextInstr & 0xff) | 2; \
		      } } while (0)
#define BUSUSEDINCPCN do { if (state->is_StrongARM) BUSUSEDN; else { \
			state->Reg[15] += isize ; /* a standard PC inc and an N cycle */ \
			state->NextInstr |= 3; \
		      } } while (0)
@


1.7
log
@* armemu.h (INSN_SIZE): New macro.
(SET_ABORT): Save CPSR in SPSR and set LR.
* armemu.c (ARMul_Emulate, isize): Set to INSN_SIZE.
(WriteR15, WriteSR15): Do not discard bit 1 in Thumb mode.
* arminit.c (ARMul_Abort): Use new SETABORT and INSN_SIZE.
@
text
@d234 8
a241 4
#define BUSUSEDINCPCS state->Reg[15] += isize ; /* a standard PC inc and an S cycle */ \
                      state->NextInstr = (state->NextInstr & 0xff) | 2
#define BUSUSEDINCPCN state->Reg[15] += isize ; /* a standard PC inc and an N cycle */ \
                      state->NextInstr |= 3
@


1.6
log
@* armemu.h (WRITEDESTB): New macro.
* armemu.c (ARMul_Emulate26, bl): Use WriteR15Branch() to
modify PC.  Moved the existing logic...
(WriteR15Branch): ... here.  New function.
(WriteR15, WriteSR15): Drop the two least significant bits.
(LoadSMult): Use WriteR15Branch() to modify PC.
(LoadMult): Use WRITEDESTB() instead of WRITEDEST().
@
text
@d76 3
d185 7
a191 1
#define SETABORT(i,m) state->Cpsr = ECC | EINT | (i) | (m)
@


1.5
log
@* armemu.h (GETSPSR): Call ARMul_GetSPSR().
* armsupp.c (ARMul_CPSRAltered): Zero out bits as they're
extracted from state->Cpsr, but preserve the unused bits.
(ARMul_GetCPSR): Get bits preserved in state->Cpsr.
(ARMul_GetSPSR, ARMul_FixCPSR): Use ARMul_GetCPSR() to
get the full CPSR word.
@
text
@d335 5
@


1.4
log
@* armemu.h (PSR_FBITS, PSR_SBITS, PSR_XBITS, PSR_CBITS): New.
(SETPSR_F, SETPSR_S, SETPSR_X, SETPSR_C): New macros.
(SETPSR, SET_INTMODE, SETCC): Removed.
* armsupp.c (ARMul_FixCPSR, ARMul_FixSPSR): Do not test bit
mask.  Use SETPSR_* to modify PSR.
(ARMul_SetCPSR): Load all bits from value.
* armemu.c (ARMul_Emulate, msr): Do not test bit mask.
@
text
@d166 1
a166 1
#define GETSPSR(bank) bank>0?state->Spsr[bank]:ECC | EINT | EMODE ;
@


1.3
log
@* armemu.h (NEGBRANCH): Do not overwrite the two most significant
bits of the offset.
@
text
@d105 5
d167 4
a170 3
#define SETPSR(d,s) d = (s) & (ARMword)(CCBITS | INTBITS | MODEBITS)
#define SETINTMODE(d,s) d = ((d) & CCBITS) | ((s) & (INTBITS | MODEBITS))
#define SETCC(d,s) d = ((d) & (INTBITS | MODEBITS)) | ((s) & CCBITS)
@


1.2
log
@Fix compile time warning messages.
@
text
@d345 1
a345 1
#define NEGBRANCH (0xff000000 | ((instr & 0xffffff) << 2))
@


1.1
log
@Initial revision
@
text
@d68 1
a68 1
#ifdef MODET /* Thumb support */
d98 1
d173 2
a174 2
                        state->Reg[15] = R15PC | (s) & (CCBITS | R15INTBITS | R15MODEBITS) ; \
                        ARMul_R15Altered(state) ; \
d218 1
a218 1
#define BUSUSEDN state->NextInstr |= 1 /* the next fetch will be an N cycle */
d351 4
a354 4
#define STOP            0 /* stop */
#define CHANGEMODE      1 /* change mode */
#define ONCE            2 /* execute just one interation */
#define RUN             3 /* continuous execution */
d360 33
a392 25
extern ARMword ARMul_Emulate26(ARMul_State *state) ;
extern ARMword ARMul_Emulate32(ARMul_State *state) ;
extern unsigned ARMul_MultTable[] ; /* Number of I cycles for a mult */
extern ARMword ARMul_ImmedTable[] ; /* immediate DP LHS values */
extern char ARMul_BitList[] ; /* number of bits in a byte table */
extern void ARMul_Abort26(ARMul_State *state, ARMword) ;
extern void ARMul_Abort32(ARMul_State *state, ARMword) ;
extern unsigned ARMul_NthReg(ARMword instr,unsigned number) ;
extern void ARMul_MSRCpsr(ARMul_State *state, ARMword instr, ARMword rhs) ;
extern void ARMul_NegZero(ARMul_State *state, ARMword result) ;
extern void ARMul_AddCarry(ARMul_State *state, ARMword a, ARMword b, ARMword result) ;
extern void ARMul_AddOverflow(ARMul_State *state, ARMword a, ARMword b, ARMword result) ;
extern void ARMul_SubCarry(ARMul_State *state, ARMword a, ARMword b, ARMword result) ;
extern void ARMul_SubOverflow(ARMul_State *state, ARMword a, ARMword b, ARMword result) ;
extern void ARMul_CPSRAltered(ARMul_State *state) ;
extern void ARMul_R15Altered(ARMul_State *state) ;
extern ARMword ARMul_SwitchMode(ARMul_State *state,ARMword oldmode, ARMword newmode) ;
extern unsigned ARMul_NthReg(ARMword instr, unsigned number) ;
extern void ARMul_LDC(ARMul_State *state,ARMword instr,ARMword address) ;
extern void ARMul_STC(ARMul_State *state,ARMword instr,ARMword address) ;
extern void ARMul_MCR(ARMul_State *state,ARMword instr, ARMword source) ;
extern ARMword ARMul_MRC(ARMul_State *state,ARMword instr) ;
extern void ARMul_CDP(ARMul_State *state,ARMword instr) ;
extern unsigned IntPending(ARMul_State *state) ;
extern ARMword ARMul_Align(ARMul_State *state, ARMword address, ARMword data) ;
d397 7
a403 5
typedef enum {
  t_undefined,  /* undefined Thumb instruction */
  t_decoded,    /* instruction decoded to ARM equivalent */
  t_branch      /* Thumb branch (already processed) */
} tdstate;
d405 2
a406 1
extern tdstate ARMul_ThumbDecode(ARMul_State *state,ARMword pc,ARMword tinstr, ARMword *ainstr);
a436 1

@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-2000-01-26 snapshot
@
text
@a97 1

a369 2
extern int AddOverflow(ARMword a, ARMword b, ARMword result) ;
extern int SubOverflow(ARMword a, ARMword b, ARMword result) ;
@


1.1.1.3
log
@import gdb-2000-02-04 snapshot
@
text
@d68 1
a68 1
#ifdef MODET			/* Thumb support */
d218 1
a218 1
#define BUSUSEDN state->NextInstr |= 1	/* the next fetch will be an N cycle */
d351 4
a354 4
#define STOP            0	/* stop */
#define CHANGEMODE      1	/* change mode */
#define ONCE            2	/* execute just one interation */
#define RUN             3	/* continuous execution */
d360 27
a386 33
extern ARMword ARMul_Emulate26 (ARMul_State * state);
extern ARMword ARMul_Emulate32 (ARMul_State * state);
extern unsigned ARMul_MultTable[];	/* Number of I cycles for a mult */
extern ARMword ARMul_ImmedTable[];	/* immediate DP LHS values */
extern char ARMul_BitList[];	/* number of bits in a byte table */
extern void ARMul_Abort26 (ARMul_State * state, ARMword);
extern void ARMul_Abort32 (ARMul_State * state, ARMword);
extern unsigned ARMul_NthReg (ARMword instr, unsigned number);
extern void ARMul_MSRCpsr (ARMul_State * state, ARMword instr, ARMword rhs);
extern void ARMul_NegZero (ARMul_State * state, ARMword result);
extern void ARMul_AddCarry (ARMul_State * state, ARMword a, ARMword b,
			    ARMword result);
extern int AddOverflow (ARMword a, ARMword b, ARMword result);
extern int SubOverflow (ARMword a, ARMword b, ARMword result);
extern void ARMul_AddOverflow (ARMul_State * state, ARMword a, ARMword b,
			       ARMword result);
extern void ARMul_SubCarry (ARMul_State * state, ARMword a, ARMword b,
			    ARMword result);
extern void ARMul_SubOverflow (ARMul_State * state, ARMword a, ARMword b,
			       ARMword result);
extern void ARMul_CPSRAltered (ARMul_State * state);
extern void ARMul_R15Altered (ARMul_State * state);
extern ARMword ARMul_SwitchMode (ARMul_State * state, ARMword oldmode,
				 ARMword newmode);
extern unsigned ARMul_NthReg (ARMword instr, unsigned number);
extern void ARMul_LDC (ARMul_State * state, ARMword instr, ARMword address);
extern void ARMul_STC (ARMul_State * state, ARMword instr, ARMword address);
extern void ARMul_MCR (ARMul_State * state, ARMword instr, ARMword source);
extern ARMword ARMul_MRC (ARMul_State * state, ARMword instr);
extern void ARMul_CDP (ARMul_State * state, ARMword instr);
extern unsigned IntPending (ARMul_State * state);
extern ARMword ARMul_Align (ARMul_State * state, ARMword address,
			    ARMword data);
d391 5
a395 7
typedef enum
{
  t_undefined,			/* undefined Thumb instruction */
  t_decoded,			/* instruction decoded to ARM equivalent */
  t_branch			/* Thumb branch (already processed) */
}
tdstate;
d397 1
a397 2
extern tdstate ARMul_ThumbDecode (ARMul_State * state, ARMword pc,
				  ARMword tinstr, ARMword * ainstr);
d428 1
@


