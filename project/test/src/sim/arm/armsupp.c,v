head	1.14;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.14
	gdb_7_6-2013-04-26-release:1.14
	gdb_7_6-branch:1.14.0.2
	gdb_7_6-2013-03-12-branchpoint:1.14
	gdb_7_5_1-2012-11-29-release:1.11
	gdb_7_5-2012-08-17-release:1.11
	gdb_7_5-branch:1.11.0.62
	gdb_7_5-2012-07-18-branchpoint:1.11
	gdb_7_4_1-2012-04-26-release:1.11
	gdb_7_4-2012-01-24-release:1.11
	gdb_7_4-branch:1.11.0.60
	gdb_7_4-2011-12-13-branchpoint:1.11
	gdb_7_3_1-2011-09-04-release:1.11
	gdb_7_3-2011-07-26-release:1.11
	gdb_7_3-branch:1.11.0.58
	gdb_7_3-2011-04-01-branchpoint:1.11
	gdb_7_2-2010-09-02-release:1.11
	gdb_7_2-branch:1.11.0.56
	gdb_7_2-2010-07-07-branchpoint:1.11
	gdb_7_1-2010-03-18-release:1.11
	gdb_7_1-branch:1.11.0.54
	gdb_7_1-2010-02-18-branchpoint:1.11
	gdb_7_0_1-2009-12-22-release:1.11
	gdb_7_0-2009-10-06-release:1.11
	gdb_7_0-branch:1.11.0.52
	gdb_7_0-2009-09-16-branchpoint:1.11
	arc-sim-20090309:1.11
	msnyder-checkpoint-072509-branch:1.11.0.50
	msnyder-checkpoint-072509-branchpoint:1.11
	arc-insight_6_8-branch:1.11.0.48
	arc-insight_6_8-branchpoint:1.11
	insight_6_8-branch:1.11.0.46
	insight_6_8-branchpoint:1.11
	reverse-20081226-branch:1.11.0.44
	reverse-20081226-branchpoint:1.11
	multiprocess-20081120-branch:1.11.0.42
	multiprocess-20081120-branchpoint:1.11
	reverse-20080930-branch:1.11.0.40
	reverse-20080930-branchpoint:1.11
	reverse-20080717-branch:1.11.0.38
	reverse-20080717-branchpoint:1.11
	msnyder-reverse-20080609-branch:1.11.0.36
	msnyder-reverse-20080609-branchpoint:1.11
	drow-reverse-20070409-branch:1.11.0.34
	drow-reverse-20070409-branchpoint:1.11
	gdb_6_8-2008-03-27-release:1.11
	gdb_6_8-branch:1.11.0.32
	gdb_6_8-2008-02-26-branchpoint:1.11
	gdb_6_7_1-2007-10-29-release:1.11
	gdb_6_7-2007-10-10-release:1.11
	gdb_6_7-branch:1.11.0.30
	gdb_6_7-2007-09-07-branchpoint:1.11
	insight_6_6-20070208-release:1.11
	gdb_6_6-2006-12-18-release:1.11
	gdb_6_6-branch:1.11.0.28
	gdb_6_6-2006-11-15-branchpoint:1.11
	insight_6_5-20061003-release:1.11
	gdb-csl-symbian-6_4_50_20060226-12:1.11
	gdb-csl-sourcerygxx-3_4_4-25:1.11
	nickrob-async-20060828-mergepoint:1.11
	gdb-csl-symbian-6_4_50_20060226-11:1.11
	gdb-csl-sourcerygxx-4_1-17:1.11
	gdb-csl-20060226-branch-local-2:1.11
	gdb-csl-sourcerygxx-4_1-14:1.11
	gdb-csl-sourcerygxx-4_1-13:1.11
	gdb-csl-sourcerygxx-4_1-12:1.11
	gdb-csl-sourcerygxx-3_4_4-21:1.11
	gdb_6_5-20060621-release:1.11
	gdb-csl-sourcerygxx-4_1-9:1.11
	gdb-csl-sourcerygxx-4_1-8:1.11
	gdb-csl-sourcerygxx-4_1-7:1.11
	gdb-csl-arm-2006q1-6:1.11
	gdb-csl-sourcerygxx-4_1-6:1.11
	gdb-csl-symbian-6_4_50_20060226-10:1.11
	gdb-csl-symbian-6_4_50_20060226-9:1.11
	gdb-csl-symbian-6_4_50_20060226-8:1.11
	gdb-csl-coldfire-4_1-11:1.11
	gdb-csl-sourcerygxx-3_4_4-19:1.11
	gdb-csl-coldfire-4_1-10:1.11
	gdb_6_5-branch:1.11.0.26
	gdb_6_5-2006-05-14-branchpoint:1.11
	gdb-csl-sourcerygxx-4_1-5:1.11
	nickrob-async-20060513-branch:1.11.0.24
	nickrob-async-20060513-branchpoint:1.11
	gdb-csl-sourcerygxx-4_1-4:1.11
	msnyder-reverse-20060502-branch:1.11.0.22
	msnyder-reverse-20060502-branchpoint:1.11
	gdb-csl-morpho-4_1-4:1.11
	gdb-csl-sourcerygxx-3_4_4-17:1.11
	readline_5_1-import-branch:1.11.0.20
	readline_5_1-import-branchpoint:1.11
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.11
	gdb-csl-symbian-20060226-branch:1.11.0.18
	gdb-csl-symbian-20060226-branchpoint:1.11
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.11
	msnyder-reverse-20060331-branch:1.11.0.16
	msnyder-reverse-20060331-branchpoint:1.11
	gdb-csl-available-20060303-branch:1.11.0.14
	gdb-csl-available-20060303-branchpoint:1.11
	gdb-csl-20060226-branch:1.11.0.12
	gdb-csl-20060226-branchpoint:1.11
	gdb_6_4-20051202-release:1.11
	msnyder-fork-checkpoint-branch:1.11.0.10
	msnyder-fork-checkpoint-branchpoint:1.11
	gdb-csl-gxxpro-6_3-branch:1.11.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.11
	gdb_6_4-branch:1.11.0.6
	gdb_6_4-2005-11-01-branchpoint:1.11
	gdb-csl-arm-20051020-branch:1.11.0.4
	gdb-csl-arm-20051020-branchpoint:1.11
	msnyder-tracepoint-checkpoint-branch:1.11.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.11
	gdb-csl-arm-20050325-2005-q1b:1.10
	gdb-csl-arm-20050325-2005-q1a:1.10
	csl-arm-20050325-branch:1.10.0.72
	csl-arm-20050325-branchpoint:1.10
	gdb_6_3-20041109-release:1.10
	gdb_6_3-branch:1.10.0.68
	gdb_6_3-20041019-branchpoint:1.10
	drow_intercu-merge-20040921:1.10
	drow_intercu-merge-20040915:1.10
	jimb-gdb_6_2-e500-branch:1.10.0.70
	jimb-gdb_6_2-e500-branchpoint:1.10
	gdb_6_2-20040730-release:1.10
	gdb_6_2-branch:1.10.0.66
	gdb_6_2-2004-07-10-gmt-branchpoint:1.10
	gdb_6_1_1-20040616-release:1.10
	gdb_6_1-2004-04-05-release:1.10
	drow_intercu-merge-20040402:1.10
	drow_intercu-merge-20040327:1.10
	ezannoni_pie-20040323-branch:1.10.0.64
	ezannoni_pie-20040323-branchpoint:1.10
	cagney_tramp-20040321-mergepoint:1.10
	cagney_tramp-20040309-branch:1.10.0.62
	cagney_tramp-20040309-branchpoint:1.10
	gdb_6_1-branch:1.10.0.60
	gdb_6_1-2004-03-01-gmt-branchpoint:1.10
	drow_intercu-20040221-branch:1.10.0.58
	drow_intercu-20040221-branchpoint:1.10
	cagney_bfdfile-20040213-branch:1.10.0.56
	cagney_bfdfile-20040213-branchpoint:1.10
	drow-cplus-merge-20040208:1.10
	carlton_dictionary-20040126-merge:1.10
	cagney_bigcore-20040122-branch:1.10.0.54
	cagney_bigcore-20040122-branchpoint:1.10
	drow-cplus-merge-20040113:1.10
	drow-cplus-merge-20031224:1.10
	drow-cplus-merge-20031220:1.10
	carlton_dictionary-20031215-merge:1.10
	drow-cplus-merge-20031214:1.10
	carlton-dictionary-20031111-merge:1.10
	gdb_6_0-2003-10-04-release:1.10
	kettenis_sparc-20030918-branch:1.10.0.52
	kettenis_sparc-20030918-branchpoint:1.10
	carlton_dictionary-20030917-merge:1.10
	ezannoni_pie-20030916-branchpoint:1.10
	ezannoni_pie-20030916-branch:1.10.0.50
	cagney_x86i386-20030821-branch:1.10.0.48
	cagney_x86i386-20030821-branchpoint:1.10
	carlton_dictionary-20030805-merge:1.10
	carlton_dictionary-20030627-merge:1.10
	gdb_6_0-branch:1.10.0.46
	gdb_6_0-2003-06-23-branchpoint:1.10
	jimb-ppc64-linux-20030613-branch:1.10.0.44
	jimb-ppc64-linux-20030613-branchpoint:1.10
	cagney_convert-20030606-branch:1.10.0.42
	cagney_convert-20030606-branchpoint:1.10
	cagney_writestrings-20030508-branch:1.10.0.40
	cagney_writestrings-20030508-branchpoint:1.10
	jimb-ppc64-linux-20030528-branch:1.10.0.38
	jimb-ppc64-linux-20030528-branchpoint:1.10
	carlton_dictionary-20030523-merge:1.10
	cagney_fileio-20030521-branch:1.10.0.36
	cagney_fileio-20030521-branchpoint:1.10
	kettenis_i386newframe-20030517-mergepoint:1.10
	jimb-ppc64-linux-20030509-branch:1.10.0.34
	jimb-ppc64-linux-20030509-branchpoint:1.10
	kettenis_i386newframe-20030504-mergepoint:1.10
	carlton_dictionary-20030430-merge:1.10
	kettenis_i386newframe-20030419-branch:1.10.0.32
	kettenis_i386newframe-20030419-branchpoint:1.10
	carlton_dictionary-20030416-merge:1.10
	cagney_frameaddr-20030409-mergepoint:1.10
	kettenis_i386newframe-20030406-branch:1.10.0.30
	kettenis_i386newframe-20030406-branchpoint:1.10
	cagney_frameaddr-20030403-branchpoint:1.10
	cagney_frameaddr-20030403-branch:1.10.0.28
	cagney_framebase-20030330-mergepoint:1.10
	cagney_framebase-20030326-branch:1.10.0.26
	cagney_framebase-20030326-branchpoint:1.10
	cagney_lazyid-20030317-branch:1.10.0.24
	cagney_lazyid-20030317-branchpoint:1.10
	kettenis-i386newframe-20030316-mergepoint:1.10
	offbyone-20030313-branch:1.10.0.22
	offbyone-20030313-branchpoint:1.10
	kettenis-i386newframe-20030308-branch:1.10.0.20
	kettenis-i386newframe-20030308-branchpoint:1.10
	carlton_dictionary-20030305-merge:1.10
	cagney_offbyone-20030303-branch:1.10.0.18
	cagney_offbyone-20030303-branchpoint:1.10
	carlton_dictionary-20030207-merge:1.10
	interps-20030202-branch:1.10.0.16
	interps-20030202-branchpoint:1.10
	cagney-unwind-20030108-branch:1.10.0.14
	cagney-unwind-20030108-branchpoint:1.10
	carlton_dictionary-20021223-merge:1.10
	gdb_5_3-2002-12-12-release:1.10
	carlton_dictionary-20021115-merge:1.10
	kseitz_interps-20021105-merge:1.10
	kseitz_interps-20021103-merge:1.10
	drow-cplus-merge-20021020:1.10
	drow-cplus-merge-20021025:1.10
	carlton_dictionary-20021025-merge:1.10
	carlton_dictionary-20021011-merge:1.10
	drow-cplus-branch:1.10.0.12
	drow-cplus-branchpoint:1.10
	kseitz_interps-20020930-merge:1.10
	carlton_dictionary-20020927-merge:1.10
	carlton_dictionary-branch:1.10.0.10
	carlton_dictionary-20020920-branchpoint:1.10
	gdb_5_3-branch:1.10.0.8
	gdb_5_3-2002-09-04-branchpoint:1.10
	kseitz_interps-20020829-merge:1.10
	cagney_sysregs-20020825-branch:1.10.0.6
	cagney_sysregs-20020825-branchpoint:1.10
	readline_4_3-import-branch:1.10.0.4
	readline_4_3-import-branchpoint:1.10
	gdb_5_2_1-2002-07-23-release:1.9
	kseitz_interps-20020528-branch:1.10.0.2
	kseitz_interps-20020528-branchpoint:1.10
	cagney_regbuf-20020515-branch:1.9.0.6
	cagney_regbuf-20020515-branchpoint:1.9
	jimb-macro-020506-branch:1.9.0.4
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.9
	gdb_5_2-branch:1.9.0.2
	gdb_5_2-2002-03-03-branchpoint:1.9
	gdb_5_1_1-2002-01-24-release:1.8
	gdb_5_1_0_1-2002-01-03-release:1.8
	gdb_5_1_0_1-2002-01-03-branch:1.8.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.8
	gdb_5_1-2001-11-21-release:1.8
	gdb_s390-2001-09-26-branch:1.8.0.4
	gdb_s390-2001-09-26-branchpoint:1.8
	gdb_5_1-2001-07-29-branch:1.8.0.2
	gdb_5_1-2001-07-29-branchpoint:1.8
	insight-precleanup-2001-01-01:1.7
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.14
date	2012.12.19.07.18.14;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2012.12.19.07.11.58;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2012.09.03.10.13.11;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.12.07.36.58;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.27.14.11.59;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2001.10.18.12.20.49;	author nickc;	state Exp;
branches
	1.9.6.1;
next	1.8;

1.8
date	2001.05.08.08.28.28;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.30.01.55.12;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.04.06.19.29;	author aoliva;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.04.06.06.30;	author aoliva;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.04.05.16.20;	author aoliva;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.30.17.13.37;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.08.20.54.27;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.55;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.9.6.1
date	2002.06.15.16.43.22;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.55;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.01.26.21.49.13;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.02.05.07.30.18;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.14
log
@[sim] Update old contact info in GPL license notices

sim/ChangeLog:

        Update old contact info in GPL license notices.
@
text
@/*  armsupp.c -- ARMulator support code:  ARM6 Instruction Emulator.
    Copyright (C) 1994 Advanced RISC Machines Ltd.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, see <http://www.gnu.org/licenses/>. */

#include "armdefs.h"
#include "armemu.h"
#include "ansidecl.h"

/* Definitions for the support routines.  */

static ARMword ModeToBank (ARMword);
static void    EnvokeList (ARMul_State *, unsigned long, unsigned long);

struct EventNode
{					/* An event list node.  */
  unsigned (*func) (ARMul_State *);	/* The function to call.  */
  struct EventNode *next;
};

/* This routine returns the value of a register from a mode.  */

ARMword
ARMul_GetReg (ARMul_State * state, unsigned mode, unsigned reg)
{
  mode &= MODEBITS;
  if (mode != state->Mode)
    return (state->RegBank[ModeToBank ((ARMword) mode)][reg]);
  else
    return (state->Reg[reg]);
}

/* This routine sets the value of a register for a mode.  */

void
ARMul_SetReg (ARMul_State * state, unsigned mode, unsigned reg, ARMword value)
{
  mode &= MODEBITS;
  if (mode != state->Mode)
    state->RegBank[ModeToBank ((ARMword) mode)][reg] = value;
  else
    state->Reg[reg] = value;
}

/* This routine returns the value of the PC, mode independently.  */

ARMword
ARMul_GetPC (ARMul_State * state)
{
  if (state->Mode > SVC26MODE)
    return state->Reg[15];
  else
    return R15PC;
}

/* This routine returns the value of the PC, mode independently.  */

ARMword
ARMul_GetNextPC (ARMul_State * state)
{
  if (state->Mode > SVC26MODE)
    return state->Reg[15] + isize;
  else
    return (state->Reg[15] + isize) & R15PCBITS;
}

/* This routine sets the value of the PC.  */

void
ARMul_SetPC (ARMul_State * state, ARMword value)
{
  if (ARMul_MODE32BIT)
    state->Reg[15] = value & PCBITS;
  else
    state->Reg[15] = R15CCINTMODE | (value & R15PCBITS);
  FLUSHPIPE;
}

/* This routine returns the value of register 15, mode independently.  */

ARMword
ARMul_GetR15 (ARMul_State * state)
{
  if (state->Mode > SVC26MODE)
    return (state->Reg[15]);
  else
    return (R15PC | ECC | ER15INT | EMODE);
}

/* This routine sets the value of Register 15.  */

void
ARMul_SetR15 (ARMul_State * state, ARMword value)
{
  if (ARMul_MODE32BIT)
    state->Reg[15] = value & PCBITS;
  else
    {
      state->Reg[15] = value;
      ARMul_R15Altered (state);
    }
  FLUSHPIPE;
}

/* This routine returns the value of the CPSR.  */

ARMword
ARMul_GetCPSR (ARMul_State * state)
{
  return (CPSR | state->Cpsr);
}

/* This routine sets the value of the CPSR.  */

void
ARMul_SetCPSR (ARMul_State * state, ARMword value)
{
  state->Cpsr = value;
  ARMul_CPSRAltered (state);
}

/* This routine does all the nasty bits involved in a write to the CPSR,
   including updating the register bank, given a MSR instruction.  */

void
ARMul_FixCPSR (ARMul_State * state, ARMword instr, ARMword rhs)
{
  state->Cpsr = ARMul_GetCPSR (state);

  if (state->Mode != USER26MODE
      && state->Mode != USER32MODE)
    {
      /* In user mode, only write flags.  */
      if (BIT (16))
	SETPSR_C (state->Cpsr, rhs);
      if (BIT (17))
	SETPSR_X (state->Cpsr, rhs);
      if (BIT (18))
	SETPSR_S (state->Cpsr, rhs);
    }
  if (BIT (19))
    SETPSR_F (state->Cpsr, rhs);
  ARMul_CPSRAltered (state);
}

/* Get an SPSR from the specified mode.  */

ARMword
ARMul_GetSPSR (ARMul_State * state, ARMword mode)
{
  ARMword bank = ModeToBank (mode & MODEBITS);

  if (! BANK_CAN_ACCESS_SPSR (bank))
    return ARMul_GetCPSR (state);

  return state->Spsr[bank];
}

/* This routine does a write to an SPSR.  */

void
ARMul_SetSPSR (ARMul_State * state, ARMword mode, ARMword value)
{
  ARMword bank = ModeToBank (mode & MODEBITS);
  
  if (BANK_CAN_ACCESS_SPSR (bank))
    state->Spsr[bank] = value;
}

/* This routine does a write to the current SPSR, given an MSR instruction.  */

void
ARMul_FixSPSR (ARMul_State * state, ARMword instr, ARMword rhs)
{
  if (BANK_CAN_ACCESS_SPSR (state->Bank))
    {
      if (BIT (16))
	SETPSR_C (state->Spsr[state->Bank], rhs);
      if (BIT (17))
	SETPSR_X (state->Spsr[state->Bank], rhs);
      if (BIT (18))
	SETPSR_S (state->Spsr[state->Bank], rhs);
      if (BIT (19))
	SETPSR_F (state->Spsr[state->Bank], rhs);
    }
}

/* This routine updates the state of the emulator after the Cpsr has been
   changed.  Both the processor flags and register bank are updated.  */

void
ARMul_CPSRAltered (ARMul_State * state)
{
  ARMword oldmode;

  if (state->prog32Sig == LOW)
    state->Cpsr &= (CCBITS | INTBITS | R15MODEBITS);

  oldmode = state->Mode;
  
  if (state->Mode != (state->Cpsr & MODEBITS))
    {
      state->Mode =
	ARMul_SwitchMode (state, state->Mode, state->Cpsr & MODEBITS);
      
      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
    }
  state->Cpsr &= ~MODEBITS;

  ASSIGNINT (state->Cpsr & INTBITS);
  state->Cpsr &= ~INTBITS;
  ASSIGNN ((state->Cpsr & NBIT) != 0);
  state->Cpsr &= ~NBIT;
  ASSIGNZ ((state->Cpsr & ZBIT) != 0);
  state->Cpsr &= ~ZBIT;
  ASSIGNC ((state->Cpsr & CBIT) != 0);
  state->Cpsr &= ~CBIT;
  ASSIGNV ((state->Cpsr & VBIT) != 0);
  state->Cpsr &= ~VBIT;
  ASSIGNS ((state->Cpsr & SBIT) != 0);
  state->Cpsr &= ~SBIT;
#ifdef MODET
  ASSIGNT ((state->Cpsr & TBIT) != 0);
  state->Cpsr &= ~TBIT;
#endif

  if (oldmode > SVC26MODE)
    {
      if (state->Mode <= SVC26MODE)
	{
	  state->Emulate = CHANGEMODE;
	  state->Reg[15] = ECC | ER15INT | EMODE | R15PC;
	}
    }
  else
    {
      if (state->Mode > SVC26MODE)
	{
	  state->Emulate = CHANGEMODE;
	  state->Reg[15] = R15PC;
	}
      else
	state->Reg[15] = ECC | ER15INT | EMODE | R15PC;
    }
}

/* This routine updates the state of the emulator after register 15 has
   been changed.  Both the processor flags and register bank are updated.
   This routine should only be called from a 26 bit mode.  */

void
ARMul_R15Altered (ARMul_State * state)
{
  if (state->Mode != R15MODE)
    {
      state->Mode = ARMul_SwitchMode (state, state->Mode, R15MODE);
      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
    }

  if (state->Mode > SVC26MODE)
    state->Emulate = CHANGEMODE;

  ASSIGNR15INT (R15INT);

  ASSIGNN ((state->Reg[15] & NBIT) != 0);
  ASSIGNZ ((state->Reg[15] & ZBIT) != 0);
  ASSIGNC ((state->Reg[15] & CBIT) != 0);
  ASSIGNV ((state->Reg[15] & VBIT) != 0);
}

/* This routine controls the saving and restoring of registers across mode
   changes.  The regbank matrix is largely unused, only rows 13 and 14 are
   used across all modes, 8 to 14 are used for FIQ, all others use the USER
   column.  It's easier this way.  old and new parameter are modes numbers.
   Notice the side effect of changing the Bank variable.  */

ARMword
ARMul_SwitchMode (ARMul_State * state, ARMword oldmode, ARMword newmode)
{
  unsigned i;
  ARMword  oldbank;
  ARMword  newbank;
  
  oldbank = ModeToBank (oldmode);
  newbank = state->Bank = ModeToBank (newmode);
  
  /* Do we really need to do it?  */
  if (oldbank != newbank)
    {
      /* Save away the old registers.  */
      switch (oldbank)
	{
	case USERBANK:
	case IRQBANK:
	case SVCBANK:
	case ABORTBANK:
	case UNDEFBANK:
	  if (newbank == FIQBANK)
	    for (i = 8; i < 13; i++)
	      state->RegBank[USERBANK][i] = state->Reg[i];
	  state->RegBank[oldbank][13] = state->Reg[13];
	  state->RegBank[oldbank][14] = state->Reg[14];
	  break;
	case FIQBANK:
	  for (i = 8; i < 15; i++)
	    state->RegBank[FIQBANK][i] = state->Reg[i];
	  break;
	case DUMMYBANK:
	  for (i = 8; i < 15; i++)
	    state->RegBank[DUMMYBANK][i] = 0;
	  break;
	default:
	  abort ();
	}
      
      /* Restore the new registers.  */
      switch (newbank)
	{
	case USERBANK:
	case IRQBANK:
	case SVCBANK:
	case ABORTBANK:
	case UNDEFBANK:
	  if (oldbank == FIQBANK)
	    for (i = 8; i < 13; i++)
	      state->Reg[i] = state->RegBank[USERBANK][i];
	  state->Reg[13] = state->RegBank[newbank][13];
	  state->Reg[14] = state->RegBank[newbank][14];
	  break;
	case FIQBANK:
	  for (i = 8; i < 15; i++)
	    state->Reg[i] = state->RegBank[FIQBANK][i];
	  break;
	case DUMMYBANK:
	  for (i = 8; i < 15; i++)
	    state->Reg[i] = 0;
	  break;
	default:
	  abort ();
	}
    }
  
  return newmode;
}

/* Given a processor mode, this routine returns the
   register bank that will be accessed in that mode.  */

static ARMword
ModeToBank (ARMword mode)
{
  static ARMword bankofmode[] =
  {
    USERBANK,  FIQBANK,   IRQBANK,   SVCBANK,
    DUMMYBANK, DUMMYBANK, DUMMYBANK, DUMMYBANK,
    DUMMYBANK, DUMMYBANK, DUMMYBANK, DUMMYBANK,
    DUMMYBANK, DUMMYBANK, DUMMYBANK, DUMMYBANK,
    USERBANK,  FIQBANK,   IRQBANK,   SVCBANK,
    DUMMYBANK, DUMMYBANK, DUMMYBANK, ABORTBANK,
    DUMMYBANK, DUMMYBANK, DUMMYBANK, UNDEFBANK,
    DUMMYBANK, DUMMYBANK, DUMMYBANK, SYSTEMBANK
  };

  if (mode >= (sizeof (bankofmode) / sizeof (bankofmode[0])))
    return DUMMYBANK;

  return bankofmode[mode];
}

/* Returns the register number of the nth register in a reg list.  */

unsigned
ARMul_NthReg (ARMword instr, unsigned number)
{
  unsigned bit, upto;

  for (bit = 0, upto = 0; upto <= number; bit ++)
    if (BIT (bit))
      upto ++;

  return (bit - 1);
}

/* Assigns the N and Z flags depending on the value of result.  */

void
ARMul_NegZero (ARMul_State * state, ARMword result)
{
  if (NEG (result))
    {
      SETN;
      CLEARZ;
    }
  else if (result == 0)
    {
      CLEARN;
      SETZ;
    }
  else
    {
      CLEARN;
      CLEARZ;
    }
}

/* Compute whether an addition of A and B, giving RESULT, overflowed.  */

int
AddOverflow (ARMword a, ARMword b, ARMword result)
{
  return ((NEG (a) && NEG (b) && POS (result))
	  || (POS (a) && POS (b) && NEG (result)));
}

/* Compute whether a subtraction of A and B, giving RESULT, overflowed.  */

int
SubOverflow (ARMword a, ARMword b, ARMword result)
{
  return ((NEG (a) && POS (b) && POS (result))
	  || (POS (a) && NEG (b) && NEG (result)));
}

/* Assigns the C flag after an addition of a and b to give result.  */

void
ARMul_AddCarry (ARMul_State * state, ARMword a, ARMword b, ARMword result)
{
  ASSIGNC ((NEG (a) && NEG (b)) ||
	   (NEG (a) && POS (result)) || (NEG (b) && POS (result)));
}

/* Assigns the V flag after an addition of a and b to give result.  */

void
ARMul_AddOverflow (ARMul_State * state, ARMword a, ARMword b, ARMword result)
{
  ASSIGNV (AddOverflow (a, b, result));
}

/* Assigns the C flag after an subtraction of a and b to give result.  */

void
ARMul_SubCarry (ARMul_State * state, ARMword a, ARMword b, ARMword result)
{
  ASSIGNC ((NEG (a) && POS (b)) ||
	   (NEG (a) && POS (result)) || (POS (b) && POS (result)));
}

/* Assigns the V flag after an subtraction of a and b to give result.  */

void
ARMul_SubOverflow (ARMul_State * state, ARMword a, ARMword b, ARMword result)
{
  ASSIGNV (SubOverflow (a, b, result));
}

/* This function does the work of generating the addresses used in an
   LDC instruction.  The code here is always post-indexed, it's up to the
   caller to get the input address correct and to handle base register
   modification. It also handles the Busy-Waiting.  */

void
ARMul_LDC (ARMul_State * state, ARMword instr, ARMword address)
{
  unsigned cpab;
  ARMword data;

  UNDEF_LSCPCBaseWb;

  if (! CP_ACCESS_ALLOWED (state, CPNum))
    {
      ARMul_UndefInstr (state, instr);
      return;
    }

  if (ADDREXCEPT (address))
    INTERNALABORT (address);

  cpab = (state->LDC[CPNum]) (state, ARMul_FIRST, instr, 0);
  while (cpab == ARMul_BUSY)
    {
      ARMul_Icycles (state, 1, 0);

      if (IntPending (state))
	{
	  cpab = (state->LDC[CPNum]) (state, ARMul_INTERRUPT, instr, 0);
	  return;
	}
      else
	cpab = (state->LDC[CPNum]) (state, ARMul_BUSY, instr, 0);
    }
  if (cpab == ARMul_CANT)
    {
      CPTAKEABORT;
      return;
    }

  cpab = (state->LDC[CPNum]) (state, ARMul_TRANSFER, instr, 0);
  data = ARMul_LoadWordN (state, address);
  BUSUSEDINCPCN;

  if (BIT (21))
    LSBase = state->Base;
  cpab = (state->LDC[CPNum]) (state, ARMul_DATA, instr, data);

  while (cpab == ARMul_INC)
    {
      address += 4;
      data = ARMul_LoadWordN (state, address);
      cpab = (state->LDC[CPNum]) (state, ARMul_DATA, instr, data);
    }

  if (state->abortSig || state->Aborted)
    TAKEABORT;
}

/* This function does the work of generating the addresses used in an
   STC instruction.  The code here is always post-indexed, it's up to the
   caller to get the input address correct and to handle base register
   modification. It also handles the Busy-Waiting.  */

void
ARMul_STC (ARMul_State * state, ARMword instr, ARMword address)
{
  unsigned cpab;
  ARMword data;

  UNDEF_LSCPCBaseWb;

  if (! CP_ACCESS_ALLOWED (state, CPNum))
    {
      ARMul_UndefInstr (state, instr);
      return;
    }

  if (ADDREXCEPT (address) || VECTORACCESS (address))
    INTERNALABORT (address);

  cpab = (state->STC[CPNum]) (state, ARMul_FIRST, instr, &data);
  while (cpab == ARMul_BUSY)
    {
      ARMul_Icycles (state, 1, 0);
      if (IntPending (state))
	{
	  cpab = (state->STC[CPNum]) (state, ARMul_INTERRUPT, instr, 0);
	  return;
	}
      else
	cpab = (state->STC[CPNum]) (state, ARMul_BUSY, instr, &data);
    }

  if (cpab == ARMul_CANT)
    {
      CPTAKEABORT;
      return;
    }
#ifndef MODE32
  if (ADDREXCEPT (address) || VECTORACCESS (address))
    INTERNALABORT (address);
#endif
  BUSUSEDINCPCN;
  if (BIT (21))
    LSBase = state->Base;
  cpab = (state->STC[CPNum]) (state, ARMul_DATA, instr, &data);
  ARMul_StoreWordN (state, address, data);

  while (cpab == ARMul_INC)
    {
      address += 4;
      cpab = (state->STC[CPNum]) (state, ARMul_DATA, instr, &data);
      ARMul_StoreWordN (state, address, data);
    }

  if (state->abortSig || state->Aborted)
    TAKEABORT;
}

/* This function does the Busy-Waiting for an MCR instruction.  */

void
ARMul_MCR (ARMul_State * state, ARMword instr, ARMword source)
{
  unsigned cpab;

  if (! CP_ACCESS_ALLOWED (state, CPNum))
    {
      ARMul_UndefInstr (state, instr);
      return;
    }

  cpab = (state->MCR[CPNum]) (state, ARMul_FIRST, instr, source);

  while (cpab == ARMul_BUSY)
    {
      ARMul_Icycles (state, 1, 0);

      if (IntPending (state))
	{
	  cpab = (state->MCR[CPNum]) (state, ARMul_INTERRUPT, instr, 0);
	  return;
	}
      else
	cpab = (state->MCR[CPNum]) (state, ARMul_BUSY, instr, source);
    }

  if (cpab == ARMul_CANT)
    ARMul_Abort (state, ARMul_UndefinedInstrV);
  else
    {
      BUSUSEDINCPCN;
      ARMul_Ccycles (state, 1, 0);
    }
}

/* This function does the Busy-Waiting for an MRC instruction.  */

ARMword
ARMul_MRC (ARMul_State * state, ARMword instr)
{
  unsigned cpab;
  ARMword result = 0;

  if (! CP_ACCESS_ALLOWED (state, CPNum))
    {
      ARMul_UndefInstr (state, instr);
      return result;
    }

  cpab = (state->MRC[CPNum]) (state, ARMul_FIRST, instr, &result);
  while (cpab == ARMul_BUSY)
    {
      ARMul_Icycles (state, 1, 0);
      if (IntPending (state))
	{
	  cpab = (state->MRC[CPNum]) (state, ARMul_INTERRUPT, instr, 0);
	  return (0);
	}
      else
	cpab = (state->MRC[CPNum]) (state, ARMul_BUSY, instr, &result);
    }
  if (cpab == ARMul_CANT)
    {
      ARMul_Abort (state, ARMul_UndefinedInstrV);
      /* Parent will destroy the flags otherwise.  */
      result = ECC;
    }
  else
    {
      BUSUSEDINCPCN;
      ARMul_Ccycles (state, 1, 0);
      ARMul_Icycles (state, 1, 0);
    }

  return result;
}

/* This function does the Busy-Waiting for an CDP instruction.  */

void
ARMul_CDP (ARMul_State * state, ARMword instr)
{
  unsigned cpab;

  if (! CP_ACCESS_ALLOWED (state, CPNum))
    {
      ARMul_UndefInstr (state, instr);
      return;
    }

  cpab = (state->CDP[CPNum]) (state, ARMul_FIRST, instr);
  while (cpab == ARMul_BUSY)
    {
      ARMul_Icycles (state, 1, 0);
      if (IntPending (state))
	{
	  cpab = (state->CDP[CPNum]) (state, ARMul_INTERRUPT, instr);
	  return;
	}
      else
	cpab = (state->CDP[CPNum]) (state, ARMul_BUSY, instr);
    }
  if (cpab == ARMul_CANT)
    ARMul_Abort (state, ARMul_UndefinedInstrV);
  else
    BUSUSEDN;
}

/* This function handles Undefined instructions, as CP isntruction.  */

void
ARMul_UndefInstr (ARMul_State * state, ARMword instr ATTRIBUTE_UNUSED)
{
  ARMul_Abort (state, ARMul_UndefinedInstrV);
}

/* Return TRUE if an interrupt is pending, FALSE otherwise.  */

unsigned
IntPending (ARMul_State * state)
{
  if (state->Exception)
    {
      /* Any exceptions.  */
      if (state->NresetSig == LOW)
	{
	  ARMul_Abort (state, ARMul_ResetV);
	  return TRUE;
	}
      else if (!state->NfiqSig && !FFLAG)
	{
	  ARMul_Abort (state, ARMul_FIQV);
	  return TRUE;
	}
      else if (!state->NirqSig && !IFLAG)
	{
	  ARMul_Abort (state, ARMul_IRQV);
	  return TRUE;
	}
    }

  return FALSE;
}

/* Align a word access to a non word boundary.  */

ARMword
ARMul_Align (state, address, data)
     ARMul_State * state ATTRIBUTE_UNUSED;
     ARMword address;
     ARMword data;
{
  /* This code assumes the address is really unaligned,
     as a shift by 32 is undefined in C.  */

  address = (address & 3) << 3;	/* Get the word address.  */
  return ((data >> address) | (data << (32 - address)));	/* rot right */
}

/* This routine is used to call another routine after a certain number of
   cycles have been executed. The first parameter is the number of cycles
   delay before the function is called, the second argument is a pointer
   to the function. A delay of zero doesn't work, just call the function.  */

void
ARMul_ScheduleEvent (ARMul_State * state, unsigned long delay,
		     unsigned (*what) (ARMul_State *))
{
  unsigned long when;
  struct EventNode *event;

  if (state->EventSet++ == 0)
    state->Now = ARMul_Time (state);
  when = (state->Now + delay) % EVENTLISTSIZE;
  event = (struct EventNode *) malloc (sizeof (struct EventNode));
  event->func = what;
  event->next = *(state->EventPtr + when);
  *(state->EventPtr + when) = event;
}

/* This routine is called at the beginning of
   every cycle, to envoke scheduled events.  */

void
ARMul_EnvokeEvent (ARMul_State * state)
{
  static unsigned long then;

  then = state->Now;
  state->Now = ARMul_Time (state) % EVENTLISTSIZE;
  if (then < state->Now)
    /* Schedule events.  */
    EnvokeList (state, then, state->Now);
  else if (then > state->Now)
    {
      /* Need to wrap around the list.  */
      EnvokeList (state, then, EVENTLISTSIZE - 1L);
      EnvokeList (state, 0L, state->Now);
    }
}

/* Envokes all the entries in a range.  */

static void
EnvokeList (ARMul_State * state, unsigned long from, unsigned long to)
{
  for (; from <= to; from++)
    {
      struct EventNode *anevent;

      anevent = *(state->EventPtr + from);
      while (anevent)
	{
	  (anevent->func) (state);
	  state->EventSet--;
	  anevent = anevent->next;
	}
      *(state->EventPtr + from) = NULL;
    }
}

/* This routine is returns the number of clock ticks since the last reset.  */

unsigned long
ARMul_Time (ARMul_State * state)
{
  return (state->NumScycles + state->NumNcycles +
	  state->NumIcycles + state->NumCcycles + state->NumFcycles);
}
@


1.13
log
@Update sim copyright headers from GPLv2-or-later to GPLv3-or-later.

gdb/sim/ChangeLog:

        Update the non-FSF-copyrighted files in sim to GPLv3 or later.
@
text
@d15 1
a15 2
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA. */
@


1.12
log
@	PR sim/14540
	* armsupp.c (ARMul_MRC): Return 0 if access to the MRC instruction
	is denied.
@
text
@d6 1
a6 1
    the Free Software Foundation; either version 2 of the License, or
@


1.11
log
@Update the address of the FSF organization
@
text
@d639 1
a639 1
      return;
@


1.10
log
@Only perform access checks if 'check' is set.
Report unknown machine numbers.
Formatting tidy ups.
@
text
@d16 1
a16 1
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
@


1.9
log
@Add support for XScale's coprocessor access check register.
Fix formatting.
@
text
@d141 1
a572 1

@


1.9.6.1
log
@merge from trunk
@
text
@a140 1

d572 1
@


1.8
log
@Check Mode not Bank in order to determine rocesor mode.
@
text
@d22 4
a25 52
/***************************************************************************\
*                    Definitions for the support routines                   *
\***************************************************************************/

ARMword ARMul_GetReg (ARMul_State * state, unsigned mode, unsigned reg);
void ARMul_SetReg (ARMul_State * state, unsigned mode, unsigned reg,
		   ARMword value);
ARMword ARMul_GetPC (ARMul_State * state);
ARMword ARMul_GetNextPC (ARMul_State * state);
void ARMul_SetPC (ARMul_State * state, ARMword value);
ARMword ARMul_GetR15 (ARMul_State * state);
void ARMul_SetR15 (ARMul_State * state, ARMword value);

ARMword ARMul_GetCPSR (ARMul_State * state);
void ARMul_SetCPSR (ARMul_State * state, ARMword value);
ARMword ARMul_GetSPSR (ARMul_State * state, ARMword mode);
void ARMul_SetSPSR (ARMul_State * state, ARMword mode, ARMword value);

void ARMul_CPSRAltered (ARMul_State * state);
void ARMul_R15Altered (ARMul_State * state);

ARMword ARMul_SwitchMode (ARMul_State * state, ARMword oldmode,
			  ARMword newmode);
static ARMword ModeToBank (ARMword mode);

unsigned ARMul_NthReg (ARMword instr, unsigned number);

void ARMul_NegZero (ARMul_State * state, ARMword result);
void ARMul_AddCarry (ARMul_State * state, ARMword a, ARMword b,
		     ARMword result);
void ARMul_AddOverflow (ARMul_State * state, ARMword a, ARMword b,
			ARMword result);
void ARMul_SubCarry (ARMul_State * state, ARMword a, ARMword b,
		     ARMword result);
void ARMul_SubOverflow (ARMul_State * state, ARMword a, ARMword b,
			ARMword result);

void ARMul_LDC (ARMul_State * state, ARMword instr, ARMword address);
void ARMul_STC (ARMul_State * state, ARMword instr, ARMword address);
void ARMul_MCR (ARMul_State * state, ARMword instr, ARMword source);
ARMword ARMul_MRC (ARMul_State * state, ARMword instr);
void ARMul_CDP (ARMul_State * state, ARMword instr);
unsigned IntPending (ARMul_State * state);

ARMword ARMul_Align (ARMul_State * state, ARMword address, ARMword data);

void ARMul_ScheduleEvent (ARMul_State * state, unsigned long delay,
			  unsigned (*what) ());
void ARMul_EnvokeEvent (ARMul_State * state);
unsigned long ARMul_Time (ARMul_State * state);
static void EnvokeList (ARMul_State * state, unsigned long from,
			unsigned long to);
d28 2
a29 2
{				/* An event list node */
  unsigned (*func) ();		/* The function to call */
d33 1
a33 3
/***************************************************************************\
* This routine returns the value of a register from a mode.                 *
\***************************************************************************/
d45 1
a45 3
/***************************************************************************\
* This routine sets the value of a register for a mode.                     *
\***************************************************************************/
d57 1
a57 3
/***************************************************************************\
* This routine returns the value of the PC, mode independently.             *
\***************************************************************************/
d63 1
a63 1
    return (state->Reg[15]);
d65 1
a65 1
    return (R15PC);
d68 1
a68 3
/***************************************************************************\
* This routine returns the value of the PC, mode independently.             *
\***************************************************************************/
d74 1
a74 1
    return (state->Reg[15] + isize);
d76 1
a76 1
    return ((state->Reg[15] + isize) & R15PCBITS);
d79 1
a79 3
/***************************************************************************\
* This routine sets the value of the PC.                                    *
\***************************************************************************/
d91 1
a91 3
/***************************************************************************\
* This routine returns the value of register 15, mode independently.        *
\***************************************************************************/
d102 1
a102 3
/***************************************************************************\
* This routine sets the value of Register 15.                               *
\***************************************************************************/
d117 1
a117 3
/***************************************************************************\
* This routine returns the value of the CPSR                                *
\***************************************************************************/
d125 1
a125 3
/***************************************************************************\
* This routine sets the value of the CPSR                                   *
\***************************************************************************/
d134 2
a135 4
/***************************************************************************\
* This routine does all the nasty bits involved in a write to the CPSR,     *
* including updating the register bank, given a MSR instruction.                    *
\***************************************************************************/
d143 2
a144 1
    {				/* In user mode, only write flags */
d157 1
a157 3
/***************************************************************************\
* Get an SPSR from the specified mode                                       *
\***************************************************************************/
d170 1
a170 3
/***************************************************************************\
* This routine does a write to an SPSR                                      *
\***************************************************************************/
d181 1
a181 3
/***************************************************************************\
* This routine does a write to the current SPSR, given an MSR instruction   *
\***************************************************************************/
d199 2
a200 4
/***************************************************************************\
* This routine updates the state of the emulator after the Cpsr has been    *
* changed.  Both the processor flags and register bank are updated.         *
\***************************************************************************/
d258 3
a260 5
/***************************************************************************\
* This routine updates the state of the emulator after register 15 has      *
* been changed.  Both the processor flags and register bank are updated.    *
* This routine should only be called from a 26 bit mode.                    *
\***************************************************************************/
d270 1
d273 1
d275 1
d282 5
a286 7
/***************************************************************************\
* This routine controls the saving and restoring of registers across mode   *
* changes.  The regbank matrix is largely unused, only rows 13 and 14 are   *
* used across all modes, 8 to 14 are used for FIQ, all others use the USER  *
* column.  It's easier this way.  old and new parameter are modes numbers.  *
* Notice the side effect of changing the Bank variable.                     *
\***************************************************************************/
d298 1
d300 2
a301 1
    {				/* really need to do it */
d303 1
a303 1
	{			/* save away the old registers */
d327 1
d329 1
a329 1
	{			/* restore the new registers */
d351 2
a352 2
	}			/* switch */
    }				/* if */
d357 2
a358 4
/***************************************************************************\
* Given a processor mode, this routine returns the register bank that       *
* will be accessed in that mode.                                            *
\***************************************************************************/
d381 1
a381 3
/***************************************************************************\
* Returns the register number of the nth register in a reg list.            *
\***************************************************************************/
d388 1
a388 1
  for (bit = 0, upto = 0; upto <= number; bit++)
d390 2
a391 1
      upto++;
d395 1
a395 3
/***************************************************************************\
* Assigns the N and Z flags depending on the value of result                *
\***************************************************************************/
d414 1
a414 1
    };
d418 1
d427 1
d435 1
a435 3
/***************************************************************************\
* Assigns the C flag after an addition of a and b to give result            *
\***************************************************************************/
d444 1
a444 3
/***************************************************************************\
* Assigns the V flag after an addition of a and b to give result            *
\***************************************************************************/
d452 1
a452 3
/***************************************************************************\
* Assigns the C flag after an subtraction of a and b to give result         *
\***************************************************************************/
d461 1
a461 3
/***************************************************************************\
* Assigns the V flag after an subtraction of a and b to give result         *
\***************************************************************************/
d469 4
a472 6
/***************************************************************************\
* This function does the work of generating the addresses used in an        *
* LDC instruction.  The code here is always post-indexed, it's up to the    *
* caller to get the input address correct and to handle base register       *
* modification. It also handles the Busy-Waiting.                           *
\***************************************************************************/
d481 2
a482 1
  if (ADDREXCEPT (address))
d484 2
a485 1
      INTERNALABORT (address);
d487 4
d495 1
d509 1
d513 1
d517 1
d524 1
d526 1
a526 3
    {
      TAKEABORT;
    }
d529 4
a532 6
/***************************************************************************\
* This function does the work of generating the addresses used in an        *
* STC instruction.  The code here is always post-indexed, it's up to the    *
* caller to get the input address correct and to handle base register       *
* modification. It also handles the Busy-Waiting.                           *
\***************************************************************************/
d541 2
a542 1
  if (ADDREXCEPT (address) || VECTORACCESS (address))
d544 2
a545 1
      INTERNALABORT (address);
d547 4
d563 1
d571 2
a572 3
    {
      INTERNALABORT (address);
    }
d579 1
d586 1
d588 1
a588 3
    {
      TAKEABORT;
    }
d591 1
a591 3
/***************************************************************************\
*        This function does the Busy-Waiting for an MCR instruction.        *
\***************************************************************************/
d598 6
d628 1
a628 3
/***************************************************************************\
*        This function does the Busy-Waiting for an MRC instruction.        *
\***************************************************************************/
d636 6
d657 2
a658 1
      result = ECC;		/* Parent will destroy the flags otherwise */
d666 2
a667 1
  return (result);
d670 1
a670 3
/***************************************************************************\
*        This function does the Busy-Waiting for an CDP instruction.        *
\***************************************************************************/
d677 6
d701 1
a701 3
/***************************************************************************\
*      This function handles Undefined instructions, as CP isntruction      *
\***************************************************************************/
d709 1
a709 3
/***************************************************************************\
*           Return TRUE if an interrupt is pending, FALSE otherwise.        *
\***************************************************************************/
d715 2
a716 1
    {				/* Any exceptions */
d720 1
a720 1
	  return (TRUE);
d725 1
a725 1
	  return (TRUE);
d730 1
a730 1
	  return (TRUE);
d733 2
a734 1
  return (FALSE);
d737 1
a737 3
/***************************************************************************\
*               Align a word access to a non word boundary                  *
\***************************************************************************/
d748 1
a748 1
  address = (address & 3) << 3;	/* get the word address */
d752 4
a755 6
/***************************************************************************\
* This routine is used to call another routine after a certain number of    *
* cycles have been executed. The first parameter is the number of cycles    *
* delay before the function is called, the second argument is a pointer     *
* to the function. A delay of zero doesn't work, just call the function.    *
\***************************************************************************/
d759 1
a759 1
		     unsigned (*what) ())
d773 2
a774 4
/***************************************************************************\
* This routine is called at the beginning of every cycle, to envoke         *
* scheduled events.                                                         *
\***************************************************************************/
d783 2
a784 1
  if (then < state->Now)	/* schedule events */
d787 2
a788 1
    {				/* need to wrap around the list */
d794 2
a797 1
/* envokes all the entries in a range */
a798 2
  struct EventNode *anevent;

d801 2
d814 1
a814 3
/***************************************************************************\
* This routine is returns the number of clock ticks since the last reset.   *
\***************************************************************************/
@


1.7
log
@Add support for ARM's v5TE architecture and Intel's XScale extenstions
@
text
@d209 2
a210 1
  if (state->Bank != USERBANK)
@


1.6
log
@* armemu.h (GETSPSR): Call ARMul_GetSPSR().
* armsupp.c (ARMul_CPSRAltered): Zero out bits as they're
extracted from state->Cpsr, but preserve the unused bits.
(ARMul_GetCPSR): Get bits preserved in state->Cpsr.
(ARMul_GetSPSR, ARMul_FixCPSR): Use ARMul_GetCPSR() to
get the full CPSR word.
@
text
@d305 2
@


1.5
log
@* armemu.h (PSR_FBITS, PSR_SBITS, PSR_XBITS, PSR_CBITS): New.
(SETPSR_F, SETPSR_S, SETPSR_X, SETPSR_C): New macros.
(SETPSR, SET_INTMODE, SETCC): Removed.
* armsupp.c (ARMul_FixCPSR, ARMul_FixSPSR): Do not test bit
mask.  Use SETPSR_* to modify PSR.
(ARMul_SetCPSR): Load all bits from value.
* armemu.c (ARMul_Emulate, msr): Do not test bit mask.
@
text
@d186 1
a186 1
  return (CPSR);
d208 1
a208 1
  state->Cpsr = CPSR;
d233 1
a233 1
    return CPSR;
d293 1
d296 1
d298 1
d300 1
d302 1
d304 1
d307 1
@


1.4
log
@* armdefs.h (SYSTEMBANK): Define as USERBANK.
* armsupp.c (ARMul_SwitchMode): Remove SYSTEMBANK cases.
@
text
@d196 1
a196 2
  state->Cpsr = CPSR;
  SETPSR (state->Cpsr, value);
d209 8
a216 15
  if (state->Bank == USERBANK)
    {				/* Only write flags in user mode */
      if (BIT (19))
	{
	  SETCC (state->Cpsr, rhs);
	}
    }
  else
    {				/* Not a user mode */
      if (BITS (16, 19) == 9)
	SETPSR (state->Cpsr, rhs);
      else if (BIT (16))
	SETINTMODE (state->Cpsr, rhs);
      else if (BIT (19))
	SETCC (state->Cpsr, rhs);
d218 2
d260 8
a267 6
      if (BITS (16, 19) == 9)
	SETPSR (state->Spsr[state->Bank], rhs);
      else if (BIT (16))
	SETINTMODE (state->Spsr[state->Bank], rhs);
      else if (BIT (19))
	SETCC (state->Spsr[state->Bank], rhs);
@


1.3
log
@Add support for v4 SystemMode.
@
text
@a371 4
	case SYSTEMBANK:
	  /* The System mode uses the USER bank.  */
	  oldbank = USERBANK;
	  /* Fall through.  */
a396 3
	case SYSTEMBANK:
	  newbank = USERBANK;
	  /* Fall through.  */
@


1.2
log
@Fix compile time warning messages.
@
text
@d45 1
a45 1
static ARMword ModeToBank (ARMul_State * state, ARMword mode);
d90 1
a90 1
    return (state->RegBank[ModeToBank (state, (ARMword) mode)][reg]);
d104 1
a104 1
    state->RegBank[ModeToBank (state, (ARMword) mode)][reg] = value;
d236 6
a241 5
  ARMword bank = ModeToBank (state, mode & MODEBITS);
  if (bank == USERBANK || bank == DUMMYBANK)
    return (CPSR);
  else
    return (state->Spsr[bank]);
d251 3
a253 2
  ARMword bank = ModeToBank (state, mode & MODEBITS);
  if (bank != USERBANK && bank != DUMMYBANK)
d264 1
a264 1
  if (state->Bank != USERBANK && state->Bank != DUMMYBANK)
d287 1
d289 1
d294 1
a324 1

d362 7
a368 4

  oldmode = ModeToBank (state, oldmode);
  state->Bank = ModeToBank (state, newmode);
  if (oldmode != state->Bank)
d370 1
a370 1
      switch (oldmode)
d372 4
d381 1
a381 1
	  if (state->Bank == FIQBANK)
d384 2
a385 2
	  state->RegBank[oldmode][13] = state->Reg[13];
	  state->RegBank[oldmode][14] = state->Reg[14];
d395 2
a396 1

d398 2
a399 1
      switch (state->Bank)
d401 3
d409 1
a409 1
	  if (oldmode == FIQBANK)
d412 2
a413 2
	  state->Reg[13] = state->RegBank[state->Bank][13];
	  state->Reg[14] = state->RegBank[state->Bank][14];
d423 2
d427 2
a428 1
  return (newmode);
d437 1
a437 1
ModeToBank (ARMul_State * state ATTRIBUTE_UNUSED, ARMword mode)
d439 3
a441 1
  static ARMword bankofmode[] = { USERBANK, FIQBANK, IRQBANK, SVCBANK,
d445 1
a445 1
    USERBANK, FIQBANK, IRQBANK, SVCBANK,
d447 2
a448 1
    DUMMYBANK, DUMMYBANK, DUMMYBANK, UNDEFBANK
d451 4
a454 4
  if (mode > UNDEF32MODE)
    return (DUMMYBANK);
  else
    return (bankofmode[mode]);
d675 1
d679 1
d688 1
@


1.1
log
@Initial revision
@
text
@d20 1
d26 54
a79 49
ARMword ARMul_GetReg(ARMul_State *state, unsigned mode, unsigned reg) ;
void ARMul_SetReg(ARMul_State *state, unsigned mode, unsigned reg, ARMword value) ;
ARMword ARMul_GetPC(ARMul_State *state) ;
ARMword ARMul_GetNextPC(ARMul_State *state) ;
void ARMul_SetPC(ARMul_State *state, ARMword value) ;
ARMword ARMul_GetR15(ARMul_State *state) ;
void ARMul_SetR15(ARMul_State *state, ARMword value) ;

ARMword ARMul_GetCPSR(ARMul_State *state) ;
void ARMul_SetCPSR(ARMul_State *state, ARMword value) ;
void ARMul_FixCPSR(ARMul_State *state, ARMword instr, ARMword rhs) ;
ARMword ARMul_GetSPSR(ARMul_State *state, ARMword mode) ;
void ARMul_SetSPSR(ARMul_State *state, ARMword mode, ARMword value) ;
void ARMul_FixSPSR(ARMul_State *state, ARMword instr, ARMword rhs) ;

void ARMul_CPSRAltered(ARMul_State *state) ;
void ARMul_R15Altered(ARMul_State *state) ;

ARMword ARMul_SwitchMode(ARMul_State *state,ARMword oldmode, ARMword newmode) ;
static ARMword ModeToBank(ARMul_State *state,ARMword mode) ;

unsigned ARMul_NthReg(ARMword instr, unsigned number) ;

void ARMul_NegZero(ARMul_State *state, ARMword result) ;
void ARMul_AddCarry(ARMul_State *state, ARMword a, ARMword b, ARMword result) ;
void ARMul_AddOverflow(ARMul_State *state, ARMword a, ARMword b, ARMword result) ;
void ARMul_SubCarry(ARMul_State *state, ARMword a, ARMword b, ARMword result) ;
void ARMul_SubOverflow(ARMul_State *state, ARMword a, ARMword b, ARMword result) ;

void ARMul_LDC(ARMul_State *state,ARMword instr,ARMword address) ;
void ARMul_STC(ARMul_State *state,ARMword instr,ARMword address) ;
void ARMul_MCR(ARMul_State *state,ARMword instr, ARMword source) ;
ARMword ARMul_MRC(ARMul_State *state,ARMword instr) ;
void ARMul_CDP(ARMul_State *state,ARMword instr) ;
void ARMul_UndefInstr(ARMul_State *state,ARMword instr) ;
unsigned IntPending(ARMul_State *state) ;

ARMword ARMul_Align(ARMul_State *state, ARMword address, ARMword data) ;

void ARMul_ScheduleEvent(ARMul_State *state, unsigned long delay,
                         unsigned (*what)()) ;
void ARMul_EnvokeEvent(ARMul_State *state) ;
unsigned long ARMul_Time(ARMul_State *state) ;
static void EnvokeList(ARMul_State *state, unsigned long from, unsigned long to) ;

struct EventNode { /* An event list node */
      unsigned (*func)() ; /* The function to call */
      struct EventNode *next ;
      } ;
d85 8
a92 6
ARMword ARMul_GetReg(ARMul_State *state, unsigned mode, unsigned reg)
{mode &= MODEBITS ;
 if (mode != state->Mode)
    return(state->RegBank[ModeToBank(state,(ARMword)mode)][reg]) ;
 else
    return(state->Reg[reg]) ;
d99 8
a106 6
void ARMul_SetReg(ARMul_State *state, unsigned mode, unsigned reg, ARMword value)
{mode &= MODEBITS ;
 if (mode != state->Mode)
    state->RegBank[ModeToBank(state,(ARMword)mode)][reg] = value ;
 else
    state->Reg[reg] = value ;
d113 7
a119 5
ARMword ARMul_GetPC(ARMul_State *state)
{if (state->Mode > SVC26MODE)
    return(state->Reg[15]) ;
 else
    return(R15PC) ;
d126 7
a132 5
ARMword ARMul_GetNextPC(ARMul_State *state)
{if (state->Mode > SVC26MODE)
    return(state->Reg[15] + isize) ;
 else
    return((state->Reg[15] + isize) & R15PCBITS) ;
d139 8
a146 6
void ARMul_SetPC(ARMul_State *state, ARMword value)
{if (ARMul_MODE32BIT)
    state->Reg[15] = value & PCBITS ;
 else
    state->Reg[15] = R15CCINTMODE | (value & R15PCBITS) ;
 FLUSHPIPE ;
d153 7
a159 5
ARMword ARMul_GetR15(ARMul_State *state)
{if (state->Mode > SVC26MODE)
    return(state->Reg[15]) ;
 else
    return(R15PC | ECC | ER15INT | EMODE) ;
d166 2
a167 1
void ARMul_SetR15(ARMul_State *state, ARMword value)
d169 6
a174 5
 if (ARMul_MODE32BIT)
    state->Reg[15] = value & PCBITS ;
 else {
    state->Reg[15] = value ;
    ARMul_R15Altered(state) ;
d176 1
a176 1
 FLUSHPIPE ;
d183 2
a184 1
ARMword ARMul_GetCPSR(ARMul_State *state)
d186 2
a187 2
 return(CPSR) ;
 }
d193 7
a199 5
void ARMul_SetCPSR(ARMul_State *state, ARMword value)
{state->Cpsr = CPSR ;
 SETPSR(state->Cpsr,value) ;
 ARMul_CPSRAltered(state) ;
 }
d206 19
a224 11
void ARMul_FixCPSR(ARMul_State *state, ARMword instr, ARMword rhs)
{state->Cpsr = CPSR ;
 if (state->Bank==USERBANK) { /* Only write flags in user mode */
    if (BIT(19)) {
       SETCC(state->Cpsr,rhs) ;
       }
    }
 else { /* Not a user mode */
    if (BITS(16,19)==9) SETPSR(state->Cpsr,rhs) ;
    else if (BIT(16)) SETINTMODE(state->Cpsr,rhs) ;
    else if (BIT(19)) SETCC(state->Cpsr,rhs) ;
d226 2
a227 2
 ARMul_CPSRAltered(state) ;
 }
d233 8
a240 6
ARMword ARMul_GetSPSR(ARMul_State *state, ARMword mode)
{ARMword bank = ModeToBank(state,mode & MODEBITS) ;
 if (bank == USERBANK || bank == DUMMYBANK)
    return(CPSR) ;
 else
    return(state->Spsr[bank]) ;
d247 6
a252 4
void ARMul_SetSPSR(ARMul_State *state, ARMword mode, ARMword value)
{ARMword bank = ModeToBank(state,mode & MODEBITS) ;
 if (bank != USERBANK && bank !=DUMMYBANK)
    state->Spsr[bank] = value ;
d259 11
a269 5
void ARMul_FixSPSR(ARMul_State *state, ARMword instr, ARMword rhs)
{if (state->Bank != USERBANK && state->Bank !=DUMMYBANK) {
    if (BITS(16,19)==9) SETPSR(state->Spsr[state->Bank],rhs) ;
    else if (BIT(16)) SETINTMODE(state->Spsr[state->Bank],rhs) ;
    else if (BIT(19)) SETCC(state->Spsr[state->Bank],rhs) ;
d278 4
a281 2
void ARMul_CPSRAltered(ARMul_State *state)
{ARMword oldmode ;
d283 15
a297 13
 if (state->prog32Sig == LOW)
    state->Cpsr &= (CCBITS | INTBITS | R15MODEBITS) ;
 oldmode = state->Mode ;
 if (state->Mode != (state->Cpsr & MODEBITS)) {
    state->Mode = ARMul_SwitchMode(state,state->Mode,state->Cpsr & MODEBITS) ;
    state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
    }

 ASSIGNINT(state->Cpsr & INTBITS) ;
 ASSIGNN((state->Cpsr & NBIT) != 0) ;
 ASSIGNZ((state->Cpsr & ZBIT) != 0) ;
 ASSIGNC((state->Cpsr & CBIT) != 0) ;
 ASSIGNV((state->Cpsr & VBIT) != 0) ;
d299 1
a299 1
 ASSIGNT((state->Cpsr & TBIT) != 0);
d302 17
a318 13
 if (oldmode > SVC26MODE) {
    if (state->Mode <= SVC26MODE) {
       state->Emulate = CHANGEMODE ;
       state->Reg[15] = ECC | ER15INT | EMODE | R15PC ;
       }
    }
 else {
    if (state->Mode > SVC26MODE) {
       state->Emulate = CHANGEMODE ;
       state->Reg[15] = R15PC ;
       }
    else
       state->Reg[15] = ECC | ER15INT | EMODE | R15PC ;
d329 2
a330 1
void ARMul_R15Altered(ARMul_State *state)
d332 12
a343 11
 if (state->Mode != R15MODE) {
    state->Mode = ARMul_SwitchMode(state,state->Mode,R15MODE) ;
    state->NtransSig = (state->Mode & 3)?HIGH:LOW ;
    }
 if (state->Mode > SVC26MODE)
    state->Emulate = CHANGEMODE ;
 ASSIGNR15INT(R15INT) ;
 ASSIGNN((state->Reg[15] & NBIT) != 0) ;
 ASSIGNZ((state->Reg[15] & ZBIT) != 0) ;
 ASSIGNC((state->Reg[15] & CBIT) != 0) ;
 ASSIGNV((state->Reg[15] & VBIT) != 0) ;
d354 4
a357 2
ARMword ARMul_SwitchMode(ARMul_State *state,ARMword oldmode, ARMword newmode)
{unsigned i ;
d359 51
a409 42
 oldmode = ModeToBank(state,oldmode) ;
 state->Bank = ModeToBank(state,newmode) ;
 if (oldmode != state->Bank) { /* really need to do it */
    switch (oldmode) { /* save away the old registers */
       case USERBANK  :
       case IRQBANK   :
       case SVCBANK   :
       case ABORTBANK :
       case UNDEFBANK : if (state->Bank == FIQBANK)
                           for (i = 8 ; i < 13 ; i++)
                              state->RegBank[USERBANK][i] = state->Reg[i] ;
                        state->RegBank[oldmode][13] = state->Reg[13] ;
                        state->RegBank[oldmode][14] = state->Reg[14] ;
                        break ;
       case FIQBANK   : for (i = 8 ; i < 15 ; i++)
                           state->RegBank[FIQBANK][i] = state->Reg[i] ;
                        break ;
       case DUMMYBANK : for (i = 8 ; i < 15 ; i++)
                           state->RegBank[DUMMYBANK][i] = 0 ;
                        break ;

       }
    switch (state->Bank) { /* restore the new registers */
       case USERBANK  :
       case IRQBANK   :
       case SVCBANK   :
       case ABORTBANK :
       case UNDEFBANK : if (oldmode == FIQBANK)
                           for (i = 8 ; i < 13 ; i++)
                              state->Reg[i] = state->RegBank[USERBANK][i] ;
                        state->Reg[13] = state->RegBank[state->Bank][13] ;
                        state->Reg[14] = state->RegBank[state->Bank][14] ;
                        break ;
       case FIQBANK  : for (i = 8 ; i < 15 ; i++)
                           state->Reg[i] = state->RegBank[FIQBANK][i] ;
                        break ;
       case DUMMYBANK : for (i = 8 ; i < 15 ; i++)
                           state->Reg[i] = 0 ;
                        break ;
       } /* switch */
    } /* if */
    return(newmode) ;
d417 17
a433 15
static ARMword ModeToBank(ARMul_State *state, ARMword mode)
{static ARMword bankofmode[] = {USERBANK,  FIQBANK,   IRQBANK,   SVCBANK,
                                DUMMYBANK, DUMMYBANK, DUMMYBANK, DUMMYBANK,
                                DUMMYBANK, DUMMYBANK, DUMMYBANK, DUMMYBANK,
                                DUMMYBANK, DUMMYBANK, DUMMYBANK, DUMMYBANK,
                                USERBANK,  FIQBANK,   IRQBANK,   SVCBANK,
                                DUMMYBANK, DUMMYBANK, DUMMYBANK, ABORTBANK,
                                DUMMYBANK, DUMMYBANK, DUMMYBANK, UNDEFBANK
                                } ;

 if (mode > UNDEF32MODE)
    return(DUMMYBANK) ;
 else
    return(bankofmode[mode]) ;
 }
d439 4
a442 2
unsigned ARMul_NthReg(ARMword instr, unsigned number)
{unsigned bit, upto ;
d444 4
a447 3
 for (bit = 0, upto = 0 ; upto <= number ; bit++)
    if (BIT(bit)) upto++ ;
 return(bit - 1) ;
d454 31
a484 1
void ARMul_NegZero(ARMul_State *state, ARMword result)
d486 3
a488 4
 if (NEG(result)) { SETN ; CLEARZ ; }
 else if (result == 0) { CLEARN ; SETZ ; }
 else { CLEARN ; CLEARZ ; } ;
 }
d494 2
a495 1
void ARMul_AddCarry(ARMul_State *state, ARMword a,ARMword b,ARMword result)
d497 3
a499 4
 ASSIGNC( (NEG(a) && NEG(b)) ||
          (NEG(a) && POS(result)) ||
          (NEG(b) && POS(result)) ) ;
 }
d505 2
a506 1
void ARMul_AddOverflow(ARMul_State *state, ARMword a,ARMword b,ARMword result)
d508 2
a509 3
 ASSIGNV( (NEG(a) && NEG(b) && POS(result)) ||
          (POS(a) && POS(b) && NEG(result)) ) ;
 }
d515 2
a516 1
void ARMul_SubCarry(ARMul_State *state, ARMword a,ARMword b,ARMword result)
d518 2
a519 3
ASSIGNC( (NEG(a) && POS(b)) ||
         (NEG(a) && POS(result)) ||
         (POS(b) && POS(result)) ) ;
d526 2
a527 1
void ARMul_SubOverflow(ARMul_State *state,ARMword a,ARMword b,ARMword result)
d529 1
a529 2
ASSIGNV( (NEG(a) && POS(b) && POS(result)) ||
         (POS(a) && NEG(b) && NEG(result)) ) ;
d539 43
a581 32
void ARMul_LDC(ARMul_State *state,ARMword instr,ARMword address)
{unsigned cpab ;
 ARMword data ;

 UNDEF_LSCPCBaseWb ;
 if (ADDREXCEPT(address)) {
    INTERNALABORT(address) ;
    }
 cpab = (state->LDC[CPNum])(state,ARMul_FIRST,instr,0) ;
 while (cpab == ARMul_BUSY) {
    ARMul_Icycles(state,1,0) ;
    if (IntPending(state)) {
       cpab = (state->LDC[CPNum])(state,ARMul_INTERRUPT,instr,0) ;
       return ;
       }
    else
       cpab = (state->LDC[CPNum])(state,ARMul_BUSY,instr,0) ;
    }
 if (cpab == ARMul_CANT) {
    CPTAKEABORT ;
    return ;
    }
 cpab = (state->LDC[CPNum])(state,ARMul_TRANSFER,instr,0) ;
 data = ARMul_LoadWordN(state,address) ;
 BUSUSEDINCPCN ;
 if (BIT(21))
    LSBase = state->Base ;
 cpab = (state->LDC[CPNum])(state,ARMul_DATA,instr,data) ;
 while (cpab == ARMul_INC) {
    address += 4 ;
    data = ARMul_LoadWordN(state,address) ;
    cpab = (state->LDC[CPNum])(state,ARMul_DATA,instr,data) ;
d583 1
a583 4
 if (state->abortSig || state->Aborted) {
    TAKEABORT ;
    }
 }
d592 27
a618 21
void ARMul_STC(ARMul_State *state,ARMword instr,ARMword address)
{unsigned cpab ;
 ARMword data ;

 UNDEF_LSCPCBaseWb ;
 if (ADDREXCEPT(address) || VECTORACCESS(address)) {
    INTERNALABORT(address) ;
    }
 cpab = (state->STC[CPNum])(state,ARMul_FIRST,instr,&data) ;
 while (cpab == ARMul_BUSY) {
    ARMul_Icycles(state,1,0) ;
    if (IntPending(state)) {
       cpab = (state->STC[CPNum])(state,ARMul_INTERRUPT,instr,0) ;
       return ;
       }
    else
       cpab = (state->STC[CPNum])(state,ARMul_BUSY,instr,&data) ;
    }
 if (cpab == ARMul_CANT) {
    CPTAKEABORT ;
    return ;
d621 3
a623 2
 if (ADDREXCEPT(address) || VECTORACCESS(address)) {
    INTERNALABORT(address) ;
d626 14
a639 9
 BUSUSEDINCPCN ;
 if (BIT(21))
    LSBase = state->Base ;
 cpab = (state->STC[CPNum])(state,ARMul_DATA,instr,&data) ;
 ARMul_StoreWordN(state,address,data) ;
 while (cpab == ARMul_INC) {
    address += 4 ;
    cpab = (state->STC[CPNum])(state,ARMul_DATA,instr,&data) ;
    ARMul_StoreWordN(state,address,data) ;
d641 1
a641 4
 if (state->abortSig || state->Aborted) {
    TAKEABORT ;
    }
 }
d647 4
a650 2
void ARMul_MCR(ARMul_State *state,ARMword instr, ARMword source)
{unsigned cpab ;
d652 18
a669 15
 cpab = (state->MCR[CPNum])(state,ARMul_FIRST,instr,source) ;
 while (cpab == ARMul_BUSY) {
    ARMul_Icycles(state,1,0) ;
    if (IntPending(state)) {
       cpab = (state->MCR[CPNum])(state,ARMul_INTERRUPT,instr,0) ;
       return ;
       }
    else
       cpab = (state->MCR[CPNum])(state,ARMul_BUSY,instr,source) ;
    }
 if (cpab == ARMul_CANT)
    ARMul_Abort(state,ARMul_UndefinedInstrV) ;
 else {
    BUSUSEDINCPCN ;
    ARMul_Ccycles(state,1,0) ;
d671 1
a671 1
 }
d677 28
a704 22
ARMword ARMul_MRC(ARMul_State *state,ARMword instr)
{unsigned cpab ;
 ARMword result = 0 ;

 cpab = (state->MRC[CPNum])(state,ARMul_FIRST,instr,&result) ;
 while (cpab == ARMul_BUSY) {
    ARMul_Icycles(state,1,0) ;
    if (IntPending(state)) {
       cpab = (state->MRC[CPNum])(state,ARMul_INTERRUPT,instr,0) ;
       return(0) ;
       }
    else
       cpab = (state->MRC[CPNum])(state,ARMul_BUSY,instr,&result) ;
    }
 if (cpab == ARMul_CANT) {
    ARMul_Abort(state,ARMul_UndefinedInstrV) ;
    result = ECC ; /* Parent will destroy the flags otherwise */
    }
 else {
    BUSUSEDINCPCN ;
    ARMul_Ccycles(state,1,0) ;
    ARMul_Icycles(state,1,0) ;
d706 1
a706 1
 return(result) ;
d713 4
a716 2
void ARMul_CDP(ARMul_State *state,ARMword instr)
{unsigned cpab ;
d718 16
a733 14
 cpab = (state->CDP[CPNum])(state,ARMul_FIRST,instr) ;
 while (cpab == ARMul_BUSY) {
    ARMul_Icycles(state,1,0) ;
    if (IntPending(state)) {
       cpab = (state->CDP[CPNum])(state,ARMul_INTERRUPT,instr) ;
       return ;
       }
    else
       cpab = (state->CDP[CPNum])(state,ARMul_BUSY,instr) ;
    }
 if (cpab == ARMul_CANT)
    ARMul_Abort(state,ARMul_UndefinedInstrV) ;
 else
    BUSUSEDN ;
d740 2
a741 1
void ARMul_UndefInstr(ARMul_State *state,ARMword instr)
d743 1
a743 1
 ARMul_Abort(state,ARMul_UndefinedInstrV) ;
d750 2
a751 1
unsigned IntPending(ARMul_State *state)
d753 17
a769 13
 if (state->Exception) { /* Any exceptions */
    if (state->NresetSig == LOW) {
       ARMul_Abort(state,ARMul_ResetV) ;
       return(TRUE) ;
       }
    else if (!state->NfiqSig && !FFLAG) {
       ARMul_Abort(state,ARMul_FIQV) ;
       return(TRUE) ;
       }
    else if (!state->NirqSig && !IFLAG) {
       ARMul_Abort(state,ARMul_IRQV) ;
       return(TRUE) ;
       }
d771 2
a772 2
 return(FALSE) ;
 }
d778 8
a785 3
ARMword ARMul_Align(ARMul_State *state, ARMword address, ARMword data)
{/* this code assumes the address is really unaligned,
    as a shift by 32 is undefined in C */
d787 2
a788 2
 address = (address & 3) << 3 ; /* get the word address */
 return( ( data >> address) | (data << (32 - address)) ) ; /* rot right */
d798 14
a811 11
void ARMul_ScheduleEvent(ARMul_State *state, unsigned long delay, unsigned (*what)())
{unsigned long when ;
 struct EventNode *event ;

 if (state->EventSet++ == 0)
    state->Now = ARMul_Time(state) ;
 when = (state->Now + delay) % EVENTLISTSIZE ;
 event = (struct EventNode *)malloc(sizeof(struct EventNode)) ;
 event->func = what ;
 event->next = *(state->EventPtr + when) ;
 *(state->EventPtr + when) = event ;
d819 4
a822 2
void ARMul_EnvokeEvent(ARMul_State *state)
{static unsigned long then ;
d824 8
a831 7
 then = state->Now ;
 state->Now = ARMul_Time(state) % EVENTLISTSIZE ;
 if (then < state->Now) /* schedule events */
    EnvokeList(state,then,state->Now) ;
 else if (then > state->Now) { /* need to wrap around the list */
    EnvokeList(state,then,EVENTLISTSIZE-1L) ;
    EnvokeList(state,0L,state->Now) ;
d833 1
a833 1
 }
d835 2
a836 1
static void EnvokeList(ARMul_State *state, unsigned long from, unsigned long to)
d838 2
a839 1
{struct EventNode *anevent ;
d841 10
a850 8
 for (; from <= to ; from++) {
    anevent = *(state->EventPtr + from) ;
    while (anevent) {
       (anevent->func)(state) ;
       state->EventSet-- ;
       anevent = anevent->next ;
       }
    *(state->EventPtr + from) = NULL ;
d852 1
a852 1
 }
d858 5
a862 3
unsigned long ARMul_Time(ARMul_State *state)
{return(state->NumScycles + state->NumNcycles +
        state->NumIcycles + state->NumCcycles + state->NumFcycles) ;
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-2000-01-26 snapshot
@
text
@a393 14
/* Compute whether an addition of A and B, giving RESULT, overflowed.  */
int AddOverflow (ARMword a, ARMword b, ARMword result)
{
  return ((NEG (a) && NEG (b) && POS (result))
	  || (POS (a) && POS (b) && NEG (result)));
}

/* Compute whether a subtraction of A and B, giving RESULT, overflowed.  */
int SubOverflow (ARMword a, ARMword b, ARMword result)
{
  return ((NEG (a) && POS (b) && POS (result))
	  || (POS (a) && NEG (b) && NEG (result)));
}

d411 3
a413 2
  ASSIGNV (AddOverflow (a, b, result));
}
d432 2
a433 1
  ASSIGNV (SubOverflow (a, b, result));
@


1.1.1.3
log
@import gdb-2000-02-04 snapshot
@
text
@d25 49
a73 57
ARMword ARMul_GetReg (ARMul_State * state, unsigned mode, unsigned reg);
void ARMul_SetReg (ARMul_State * state, unsigned mode, unsigned reg,
		   ARMword value);
ARMword ARMul_GetPC (ARMul_State * state);
ARMword ARMul_GetNextPC (ARMul_State * state);
void ARMul_SetPC (ARMul_State * state, ARMword value);
ARMword ARMul_GetR15 (ARMul_State * state);
void ARMul_SetR15 (ARMul_State * state, ARMword value);

ARMword ARMul_GetCPSR (ARMul_State * state);
void ARMul_SetCPSR (ARMul_State * state, ARMword value);
void ARMul_FixCPSR (ARMul_State * state, ARMword instr, ARMword rhs);
ARMword ARMul_GetSPSR (ARMul_State * state, ARMword mode);
void ARMul_SetSPSR (ARMul_State * state, ARMword mode, ARMword value);
void ARMul_FixSPSR (ARMul_State * state, ARMword instr, ARMword rhs);

void ARMul_CPSRAltered (ARMul_State * state);
void ARMul_R15Altered (ARMul_State * state);

ARMword ARMul_SwitchMode (ARMul_State * state, ARMword oldmode,
			  ARMword newmode);
static ARMword ModeToBank (ARMul_State * state, ARMword mode);

unsigned ARMul_NthReg (ARMword instr, unsigned number);

void ARMul_NegZero (ARMul_State * state, ARMword result);
void ARMul_AddCarry (ARMul_State * state, ARMword a, ARMword b,
		     ARMword result);
void ARMul_AddOverflow (ARMul_State * state, ARMword a, ARMword b,
			ARMword result);
void ARMul_SubCarry (ARMul_State * state, ARMword a, ARMword b,
		     ARMword result);
void ARMul_SubOverflow (ARMul_State * state, ARMword a, ARMword b,
			ARMword result);

void ARMul_LDC (ARMul_State * state, ARMword instr, ARMword address);
void ARMul_STC (ARMul_State * state, ARMword instr, ARMword address);
void ARMul_MCR (ARMul_State * state, ARMword instr, ARMword source);
ARMword ARMul_MRC (ARMul_State * state, ARMword instr);
void ARMul_CDP (ARMul_State * state, ARMword instr);
void ARMul_UndefInstr (ARMul_State * state, ARMword instr);
unsigned IntPending (ARMul_State * state);

ARMword ARMul_Align (ARMul_State * state, ARMword address, ARMword data);

void ARMul_ScheduleEvent (ARMul_State * state, unsigned long delay,
			  unsigned (*what) ());
void ARMul_EnvokeEvent (ARMul_State * state);
unsigned long ARMul_Time (ARMul_State * state);
static void EnvokeList (ARMul_State * state, unsigned long from,
			unsigned long to);

struct EventNode
{				/* An event list node */
  unsigned (*func) ();		/* The function to call */
  struct EventNode *next;
};
d79 6
a84 8
ARMword
ARMul_GetReg (ARMul_State * state, unsigned mode, unsigned reg)
{
  mode &= MODEBITS;
  if (mode != state->Mode)
    return (state->RegBank[ModeToBank (state, (ARMword) mode)][reg]);
  else
    return (state->Reg[reg]);
d91 6
a96 8
void
ARMul_SetReg (ARMul_State * state, unsigned mode, unsigned reg, ARMword value)
{
  mode &= MODEBITS;
  if (mode != state->Mode)
    state->RegBank[ModeToBank (state, (ARMword) mode)][reg] = value;
  else
    state->Reg[reg] = value;
d103 5
a107 7
ARMword
ARMul_GetPC (ARMul_State * state)
{
  if (state->Mode > SVC26MODE)
    return (state->Reg[15]);
  else
    return (R15PC);
d114 5
a118 7
ARMword
ARMul_GetNextPC (ARMul_State * state)
{
  if (state->Mode > SVC26MODE)
    return (state->Reg[15] + isize);
  else
    return ((state->Reg[15] + isize) & R15PCBITS);
d125 6
a130 8
void
ARMul_SetPC (ARMul_State * state, ARMword value)
{
  if (ARMul_MODE32BIT)
    state->Reg[15] = value & PCBITS;
  else
    state->Reg[15] = R15CCINTMODE | (value & R15PCBITS);
  FLUSHPIPE;
d137 5
a141 7
ARMword
ARMul_GetR15 (ARMul_State * state)
{
  if (state->Mode > SVC26MODE)
    return (state->Reg[15]);
  else
    return (R15PC | ECC | ER15INT | EMODE);
d148 1
a148 2
void
ARMul_SetR15 (ARMul_State * state, ARMword value)
d150 5
a154 6
  if (ARMul_MODE32BIT)
    state->Reg[15] = value & PCBITS;
  else
    {
      state->Reg[15] = value;
      ARMul_R15Altered (state);
d156 1
a156 1
  FLUSHPIPE;
d163 1
a163 2
ARMword
ARMul_GetCPSR (ARMul_State * state)
d165 2
a166 2
  return (CPSR);
}
d172 5
a176 7
void
ARMul_SetCPSR (ARMul_State * state, ARMword value)
{
  state->Cpsr = CPSR;
  SETPSR (state->Cpsr, value);
  ARMul_CPSRAltered (state);
}
d183 11
a193 19
void
ARMul_FixCPSR (ARMul_State * state, ARMword instr, ARMword rhs)
{
  state->Cpsr = CPSR;
  if (state->Bank == USERBANK)
    {				/* Only write flags in user mode */
      if (BIT (19))
	{
	  SETCC (state->Cpsr, rhs);
	}
    }
  else
    {				/* Not a user mode */
      if (BITS (16, 19) == 9)
	SETPSR (state->Cpsr, rhs);
      else if (BIT (16))
	SETINTMODE (state->Cpsr, rhs);
      else if (BIT (19))
	SETCC (state->Cpsr, rhs);
d195 2
a196 2
  ARMul_CPSRAltered (state);
}
d202 6
a207 8
ARMword
ARMul_GetSPSR (ARMul_State * state, ARMword mode)
{
  ARMword bank = ModeToBank (state, mode & MODEBITS);
  if (bank == USERBANK || bank == DUMMYBANK)
    return (CPSR);
  else
    return (state->Spsr[bank]);
d214 4
a217 6
void
ARMul_SetSPSR (ARMul_State * state, ARMword mode, ARMword value)
{
  ARMword bank = ModeToBank (state, mode & MODEBITS);
  if (bank != USERBANK && bank != DUMMYBANK)
    state->Spsr[bank] = value;
d224 5
a228 11
void
ARMul_FixSPSR (ARMul_State * state, ARMword instr, ARMword rhs)
{
  if (state->Bank != USERBANK && state->Bank != DUMMYBANK)
    {
      if (BITS (16, 19) == 9)
	SETPSR (state->Spsr[state->Bank], rhs);
      else if (BIT (16))
	SETINTMODE (state->Spsr[state->Bank], rhs);
      else if (BIT (19))
	SETCC (state->Spsr[state->Bank], rhs);
d237 2
a238 4
void
ARMul_CPSRAltered (ARMul_State * state)
{
  ARMword oldmode;
d240 13
a252 15
  if (state->prog32Sig == LOW)
    state->Cpsr &= (CCBITS | INTBITS | R15MODEBITS);
  oldmode = state->Mode;
  if (state->Mode != (state->Cpsr & MODEBITS))
    {
      state->Mode =
	ARMul_SwitchMode (state, state->Mode, state->Cpsr & MODEBITS);
      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
    }

  ASSIGNINT (state->Cpsr & INTBITS);
  ASSIGNN ((state->Cpsr & NBIT) != 0);
  ASSIGNZ ((state->Cpsr & ZBIT) != 0);
  ASSIGNC ((state->Cpsr & CBIT) != 0);
  ASSIGNV ((state->Cpsr & VBIT) != 0);
d254 1
a254 1
  ASSIGNT ((state->Cpsr & TBIT) != 0);
d257 13
a269 17
  if (oldmode > SVC26MODE)
    {
      if (state->Mode <= SVC26MODE)
	{
	  state->Emulate = CHANGEMODE;
	  state->Reg[15] = ECC | ER15INT | EMODE | R15PC;
	}
    }
  else
    {
      if (state->Mode > SVC26MODE)
	{
	  state->Emulate = CHANGEMODE;
	  state->Reg[15] = R15PC;
	}
      else
	state->Reg[15] = ECC | ER15INT | EMODE | R15PC;
d280 1
a280 2
void
ARMul_R15Altered (ARMul_State * state)
d282 11
a292 12
  if (state->Mode != R15MODE)
    {
      state->Mode = ARMul_SwitchMode (state, state->Mode, R15MODE);
      state->NtransSig = (state->Mode & 3) ? HIGH : LOW;
    }
  if (state->Mode > SVC26MODE)
    state->Emulate = CHANGEMODE;
  ASSIGNR15INT (R15INT);
  ASSIGNN ((state->Reg[15] & NBIT) != 0);
  ASSIGNZ ((state->Reg[15] & ZBIT) != 0);
  ASSIGNC ((state->Reg[15] & CBIT) != 0);
  ASSIGNV ((state->Reg[15] & VBIT) != 0);
d303 2
a304 4
ARMword
ARMul_SwitchMode (ARMul_State * state, ARMword oldmode, ARMword newmode)
{
  unsigned i;
d306 42
a347 51
  oldmode = ModeToBank (state, oldmode);
  state->Bank = ModeToBank (state, newmode);
  if (oldmode != state->Bank)
    {				/* really need to do it */
      switch (oldmode)
	{			/* save away the old registers */
	case USERBANK:
	case IRQBANK:
	case SVCBANK:
	case ABORTBANK:
	case UNDEFBANK:
	  if (state->Bank == FIQBANK)
	    for (i = 8; i < 13; i++)
	      state->RegBank[USERBANK][i] = state->Reg[i];
	  state->RegBank[oldmode][13] = state->Reg[13];
	  state->RegBank[oldmode][14] = state->Reg[14];
	  break;
	case FIQBANK:
	  for (i = 8; i < 15; i++)
	    state->RegBank[FIQBANK][i] = state->Reg[i];
	  break;
	case DUMMYBANK:
	  for (i = 8; i < 15; i++)
	    state->RegBank[DUMMYBANK][i] = 0;
	  break;

	}
      switch (state->Bank)
	{			/* restore the new registers */
	case USERBANK:
	case IRQBANK:
	case SVCBANK:
	case ABORTBANK:
	case UNDEFBANK:
	  if (oldmode == FIQBANK)
	    for (i = 8; i < 13; i++)
	      state->Reg[i] = state->RegBank[USERBANK][i];
	  state->Reg[13] = state->RegBank[state->Bank][13];
	  state->Reg[14] = state->RegBank[state->Bank][14];
	  break;
	case FIQBANK:
	  for (i = 8; i < 15; i++)
	    state->Reg[i] = state->RegBank[FIQBANK][i];
	  break;
	case DUMMYBANK:
	  for (i = 8; i < 15; i++)
	    state->Reg[i] = 0;
	  break;
	}			/* switch */
    }				/* if */
  return (newmode);
d355 15
a369 17
static ARMword
ModeToBank (ARMul_State * state, ARMword mode)
{
  static ARMword bankofmode[] = { USERBANK, FIQBANK, IRQBANK, SVCBANK,
    DUMMYBANK, DUMMYBANK, DUMMYBANK, DUMMYBANK,
    DUMMYBANK, DUMMYBANK, DUMMYBANK, DUMMYBANK,
    DUMMYBANK, DUMMYBANK, DUMMYBANK, DUMMYBANK,
    USERBANK, FIQBANK, IRQBANK, SVCBANK,
    DUMMYBANK, DUMMYBANK, DUMMYBANK, ABORTBANK,
    DUMMYBANK, DUMMYBANK, DUMMYBANK, UNDEFBANK
  };

  if (mode > UNDEF32MODE)
    return (DUMMYBANK);
  else
    return (bankofmode[mode]);
}
d375 2
a376 4
unsigned
ARMul_NthReg (ARMword instr, unsigned number)
{
  unsigned bit, upto;
d378 3
a380 4
  for (bit = 0, upto = 0; upto <= number; bit++)
    if (BIT (bit))
      upto++;
  return (bit - 1);
d387 1
a387 2
void
ARMul_NegZero (ARMul_State * state, ARMword result)
d389 4
a392 16
  if (NEG (result))
    {
      SETN;
      CLEARZ;
    }
  else if (result == 0)
    {
      CLEARN;
      SETZ;
    }
  else
    {
      CLEARN;
      CLEARZ;
    };
}
d395 1
a395 2
int
AddOverflow (ARMword a, ARMword b, ARMword result)
d402 1
a402 2
int
SubOverflow (ARMword a, ARMword b, ARMword result)
d412 1
a412 2
void
ARMul_AddCarry (ARMul_State * state, ARMword a, ARMword b, ARMword result)
d414 4
a417 3
  ASSIGNC ((NEG (a) && NEG (b)) ||
	   (NEG (a) && POS (result)) || (NEG (b) && POS (result)));
}
d423 1
a423 2
void
ARMul_AddOverflow (ARMul_State * state, ARMword a, ARMword b, ARMword result)
d432 1
a432 2
void
ARMul_SubCarry (ARMul_State * state, ARMword a, ARMword b, ARMword result)
d434 3
a436 2
  ASSIGNC ((NEG (a) && POS (b)) ||
	   (NEG (a) && POS (result)) || (POS (b) && POS (result)));
d443 1
a443 2
void
ARMul_SubOverflow (ARMul_State * state, ARMword a, ARMword b, ARMword result)
d455 35
a489 43
void
ARMul_LDC (ARMul_State * state, ARMword instr, ARMword address)
{
  unsigned cpab;
  ARMword data;

  UNDEF_LSCPCBaseWb;
  if (ADDREXCEPT (address))
    {
      INTERNALABORT (address);
    }
  cpab = (state->LDC[CPNum]) (state, ARMul_FIRST, instr, 0);
  while (cpab == ARMul_BUSY)
    {
      ARMul_Icycles (state, 1, 0);
      if (IntPending (state))
	{
	  cpab = (state->LDC[CPNum]) (state, ARMul_INTERRUPT, instr, 0);
	  return;
	}
      else
	cpab = (state->LDC[CPNum]) (state, ARMul_BUSY, instr, 0);
    }
  if (cpab == ARMul_CANT)
    {
      CPTAKEABORT;
      return;
    }
  cpab = (state->LDC[CPNum]) (state, ARMul_TRANSFER, instr, 0);
  data = ARMul_LoadWordN (state, address);
  BUSUSEDINCPCN;
  if (BIT (21))
    LSBase = state->Base;
  cpab = (state->LDC[CPNum]) (state, ARMul_DATA, instr, data);
  while (cpab == ARMul_INC)
    {
      address += 4;
      data = ARMul_LoadWordN (state, address);
      cpab = (state->LDC[CPNum]) (state, ARMul_DATA, instr, data);
    }
  if (state->abortSig || state->Aborted)
    {
      TAKEABORT;
d491 1
a491 1
}
d500 21
a520 27
void
ARMul_STC (ARMul_State * state, ARMword instr, ARMword address)
{
  unsigned cpab;
  ARMword data;

  UNDEF_LSCPCBaseWb;
  if (ADDREXCEPT (address) || VECTORACCESS (address))
    {
      INTERNALABORT (address);
    }
  cpab = (state->STC[CPNum]) (state, ARMul_FIRST, instr, &data);
  while (cpab == ARMul_BUSY)
    {
      ARMul_Icycles (state, 1, 0);
      if (IntPending (state))
	{
	  cpab = (state->STC[CPNum]) (state, ARMul_INTERRUPT, instr, 0);
	  return;
	}
      else
	cpab = (state->STC[CPNum]) (state, ARMul_BUSY, instr, &data);
    }
  if (cpab == ARMul_CANT)
    {
      CPTAKEABORT;
      return;
d523 2
a524 3
  if (ADDREXCEPT (address) || VECTORACCESS (address))
    {
      INTERNALABORT (address);
d527 12
a538 14
  BUSUSEDINCPCN;
  if (BIT (21))
    LSBase = state->Base;
  cpab = (state->STC[CPNum]) (state, ARMul_DATA, instr, &data);
  ARMul_StoreWordN (state, address, data);
  while (cpab == ARMul_INC)
    {
      address += 4;
      cpab = (state->STC[CPNum]) (state, ARMul_DATA, instr, &data);
      ARMul_StoreWordN (state, address, data);
    }
  if (state->abortSig || state->Aborted)
    {
      TAKEABORT;
d540 1
a540 1
}
d546 2
a547 4
void
ARMul_MCR (ARMul_State * state, ARMword instr, ARMword source)
{
  unsigned cpab;
d549 15
a563 18
  cpab = (state->MCR[CPNum]) (state, ARMul_FIRST, instr, source);
  while (cpab == ARMul_BUSY)
    {
      ARMul_Icycles (state, 1, 0);
      if (IntPending (state))
	{
	  cpab = (state->MCR[CPNum]) (state, ARMul_INTERRUPT, instr, 0);
	  return;
	}
      else
	cpab = (state->MCR[CPNum]) (state, ARMul_BUSY, instr, source);
    }
  if (cpab == ARMul_CANT)
    ARMul_Abort (state, ARMul_UndefinedInstrV);
  else
    {
      BUSUSEDINCPCN;
      ARMul_Ccycles (state, 1, 0);
d565 1
a565 1
}
d571 22
a592 28
ARMword
ARMul_MRC (ARMul_State * state, ARMword instr)
{
  unsigned cpab;
  ARMword result = 0;

  cpab = (state->MRC[CPNum]) (state, ARMul_FIRST, instr, &result);
  while (cpab == ARMul_BUSY)
    {
      ARMul_Icycles (state, 1, 0);
      if (IntPending (state))
	{
	  cpab = (state->MRC[CPNum]) (state, ARMul_INTERRUPT, instr, 0);
	  return (0);
	}
      else
	cpab = (state->MRC[CPNum]) (state, ARMul_BUSY, instr, &result);
    }
  if (cpab == ARMul_CANT)
    {
      ARMul_Abort (state, ARMul_UndefinedInstrV);
      result = ECC;		/* Parent will destroy the flags otherwise */
    }
  else
    {
      BUSUSEDINCPCN;
      ARMul_Ccycles (state, 1, 0);
      ARMul_Icycles (state, 1, 0);
d594 1
a594 1
  return (result);
d601 2
a602 4
void
ARMul_CDP (ARMul_State * state, ARMword instr)
{
  unsigned cpab;
d604 14
a617 16
  cpab = (state->CDP[CPNum]) (state, ARMul_FIRST, instr);
  while (cpab == ARMul_BUSY)
    {
      ARMul_Icycles (state, 1, 0);
      if (IntPending (state))
	{
	  cpab = (state->CDP[CPNum]) (state, ARMul_INTERRUPT, instr);
	  return;
	}
      else
	cpab = (state->CDP[CPNum]) (state, ARMul_BUSY, instr);
    }
  if (cpab == ARMul_CANT)
    ARMul_Abort (state, ARMul_UndefinedInstrV);
  else
    BUSUSEDN;
d624 1
a624 2
void
ARMul_UndefInstr (ARMul_State * state, ARMword instr)
d626 1
a626 1
  ARMul_Abort (state, ARMul_UndefinedInstrV);
d633 1
a633 2
unsigned
IntPending (ARMul_State * state)
d635 13
a647 17
  if (state->Exception)
    {				/* Any exceptions */
      if (state->NresetSig == LOW)
	{
	  ARMul_Abort (state, ARMul_ResetV);
	  return (TRUE);
	}
      else if (!state->NfiqSig && !FFLAG)
	{
	  ARMul_Abort (state, ARMul_FIQV);
	  return (TRUE);
	}
      else if (!state->NirqSig && !IFLAG)
	{
	  ARMul_Abort (state, ARMul_IRQV);
	  return (TRUE);
	}
d649 2
a650 2
  return (FALSE);
}
d656 3
a658 4
ARMword
ARMul_Align (ARMul_State * state, ARMword address, ARMword data)
{				/* this code assumes the address is really unaligned,
				   as a shift by 32 is undefined in C */
d660 2
a661 2
  address = (address & 3) << 3;	/* get the word address */
  return ((data >> address) | (data << (32 - address)));	/* rot right */
d671 11
a681 14
void
ARMul_ScheduleEvent (ARMul_State * state, unsigned long delay,
		     unsigned (*what) ())
{
  unsigned long when;
  struct EventNode *event;

  if (state->EventSet++ == 0)
    state->Now = ARMul_Time (state);
  when = (state->Now + delay) % EVENTLISTSIZE;
  event = (struct EventNode *) malloc (sizeof (struct EventNode));
  event->func = what;
  event->next = *(state->EventPtr + when);
  *(state->EventPtr + when) = event;
d689 2
a690 4
void
ARMul_EnvokeEvent (ARMul_State * state)
{
  static unsigned long then;
d692 7
a698 8
  then = state->Now;
  state->Now = ARMul_Time (state) % EVENTLISTSIZE;
  if (then < state->Now)	/* schedule events */
    EnvokeList (state, then, state->Now);
  else if (then > state->Now)
    {				/* need to wrap around the list */
      EnvokeList (state, then, EVENTLISTSIZE - 1L);
      EnvokeList (state, 0L, state->Now);
d700 1
a700 1
}
d702 1
a702 2
static void
EnvokeList (ARMul_State * state, unsigned long from, unsigned long to)
d704 1
a704 2
{
  struct EventNode *anevent;
d706 8
a713 10
  for (; from <= to; from++)
    {
      anevent = *(state->EventPtr + from);
      while (anevent)
	{
	  (anevent->func) (state);
	  state->EventSet--;
	  anevent = anevent->next;
	}
      *(state->EventPtr + from) = NULL;
d715 1
a715 1
}
d721 3
a723 5
unsigned long
ARMul_Time (ARMul_State * state)
{
  return (state->NumScycles + state->NumNcycles +
	  state->NumIcycles + state->NumCcycles + state->NumFcycles);
@


