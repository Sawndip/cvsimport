head	1.48;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.47
	gdb_7_6-2013-04-26-release:1.47
	gdb_7_6-branch:1.47.0.2
	gdb_7_6-2013-03-12-branchpoint:1.47
	gdb_7_5_1-2012-11-29-release:1.45
	gdb_7_5-2012-08-17-release:1.45
	gdb_7_5-branch:1.45.0.2
	gdb_7_5-2012-07-18-branchpoint:1.45
	gdb_7_4_1-2012-04-26-release:1.41.2.1
	gdb_7_4-2012-01-24-release:1.41.2.1
	gdb_7_4-branch:1.41.0.2
	gdb_7_4-2011-12-13-branchpoint:1.41
	gdb_7_3_1-2011-09-04-release:1.40
	gdb_7_3-2011-07-26-release:1.40
	gdb_7_3-branch:1.40.0.2
	gdb_7_3-2011-04-01-branchpoint:1.40
	gdb_7_2-2010-09-02-release:1.39
	gdb_7_2-branch:1.39.0.2
	gdb_7_2-2010-07-07-branchpoint:1.39
	gdb_7_1-2010-03-18-release:1.38
	gdb_7_1-branch:1.38.0.2
	gdb_7_1-2010-02-18-branchpoint:1.38
	gdb_7_0_1-2009-12-22-release:1.37
	gdb_7_0-2009-10-06-release:1.37
	gdb_7_0-branch:1.37.0.4
	gdb_7_0-2009-09-16-branchpoint:1.37
	arc-sim-20090309:1.35
	msnyder-checkpoint-072509-branch:1.37.0.2
	msnyder-checkpoint-072509-branchpoint:1.37
	arc-insight_6_8-branch:1.35.0.6
	arc-insight_6_8-branchpoint:1.35
	insight_6_8-branch:1.35.0.4
	insight_6_8-branchpoint:1.35
	reverse-20081226-branch:1.36.0.10
	reverse-20081226-branchpoint:1.36
	multiprocess-20081120-branch:1.36.0.8
	multiprocess-20081120-branchpoint:1.36
	reverse-20080930-branch:1.36.0.6
	reverse-20080930-branchpoint:1.36
	reverse-20080717-branch:1.36.0.4
	reverse-20080717-branchpoint:1.36
	msnyder-reverse-20080609-branch:1.36.0.2
	msnyder-reverse-20080609-branchpoint:1.36
	drow-reverse-20070409-branch:1.33.0.2
	drow-reverse-20070409-branchpoint:1.33
	gdb_6_8-2008-03-27-release:1.35
	gdb_6_8-branch:1.35.0.2
	gdb_6_8-2008-02-26-branchpoint:1.35
	gdb_6_7_1-2007-10-29-release:1.34
	gdb_6_7-2007-10-10-release:1.34
	gdb_6_7-branch:1.34.0.2
	gdb_6_7-2007-09-07-branchpoint:1.34
	insight_6_6-20070208-release:1.31
	gdb_6_6-2006-12-18-release:1.31
	gdb_6_6-branch:1.31.0.18
	gdb_6_6-2006-11-15-branchpoint:1.31
	insight_6_5-20061003-release:1.31
	gdb-csl-symbian-6_4_50_20060226-12:1.31
	gdb-csl-sourcerygxx-3_4_4-25:1.30.8.1
	nickrob-async-20060828-mergepoint:1.31
	gdb-csl-symbian-6_4_50_20060226-11:1.31
	gdb-csl-sourcerygxx-4_1-17:1.31
	gdb-csl-20060226-branch-local-2:1.31
	gdb-csl-sourcerygxx-4_1-14:1.31
	gdb-csl-sourcerygxx-4_1-13:1.31
	gdb-csl-sourcerygxx-4_1-12:1.31
	gdb-csl-sourcerygxx-3_4_4-21:1.31
	gdb_6_5-20060621-release:1.31
	gdb-csl-sourcerygxx-4_1-9:1.31
	gdb-csl-sourcerygxx-4_1-8:1.31
	gdb-csl-sourcerygxx-4_1-7:1.31
	gdb-csl-arm-2006q1-6:1.31
	gdb-csl-sourcerygxx-4_1-6:1.31
	gdb-csl-symbian-6_4_50_20060226-10:1.31
	gdb-csl-symbian-6_4_50_20060226-9:1.31
	gdb-csl-symbian-6_4_50_20060226-8:1.31
	gdb-csl-coldfire-4_1-11:1.31
	gdb-csl-sourcerygxx-3_4_4-19:1.31
	gdb-csl-coldfire-4_1-10:1.31
	gdb_6_5-branch:1.31.0.16
	gdb_6_5-2006-05-14-branchpoint:1.31
	gdb-csl-sourcerygxx-4_1-5:1.31
	nickrob-async-20060513-branch:1.31.0.14
	nickrob-async-20060513-branchpoint:1.31
	gdb-csl-sourcerygxx-4_1-4:1.31
	msnyder-reverse-20060502-branch:1.31.0.12
	msnyder-reverse-20060502-branchpoint:1.31
	gdb-csl-morpho-4_1-4:1.31
	gdb-csl-sourcerygxx-3_4_4-17:1.31
	readline_5_1-import-branch:1.31.0.10
	readline_5_1-import-branchpoint:1.31
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.31
	gdb-csl-symbian-20060226-branch:1.31.0.8
	gdb-csl-symbian-20060226-branchpoint:1.31
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.31
	msnyder-reverse-20060331-branch:1.31.0.6
	msnyder-reverse-20060331-branchpoint:1.31
	gdb-csl-available-20060303-branch:1.31.0.4
	gdb-csl-available-20060303-branchpoint:1.31
	gdb-csl-20060226-branch:1.31.0.2
	gdb-csl-20060226-branchpoint:1.31
	gdb_6_4-20051202-release:1.30
	msnyder-fork-checkpoint-branch:1.30.0.10
	msnyder-fork-checkpoint-branchpoint:1.30
	gdb-csl-gxxpro-6_3-branch:1.30.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.30
	gdb_6_4-branch:1.30.0.6
	gdb_6_4-2005-11-01-branchpoint:1.30
	gdb-csl-arm-20051020-branch:1.30.0.4
	gdb-csl-arm-20051020-branchpoint:1.30
	msnyder-tracepoint-checkpoint-branch:1.30.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.30
	gdb-csl-arm-20050325-2005-q1b:1.27.46.1
	gdb-csl-arm-20050325-2005-q1a:1.27.46.1
	csl-arm-20050325-branch:1.27.0.46
	csl-arm-20050325-branchpoint:1.27
	gdb_6_3-20041109-release:1.27
	gdb_6_3-branch:1.27.0.42
	gdb_6_3-20041019-branchpoint:1.27
	drow_intercu-merge-20040921:1.27
	drow_intercu-merge-20040915:1.27
	jimb-gdb_6_2-e500-branch:1.27.0.44
	jimb-gdb_6_2-e500-branchpoint:1.27
	gdb_6_2-20040730-release:1.27
	gdb_6_2-branch:1.27.0.40
	gdb_6_2-2004-07-10-gmt-branchpoint:1.27
	gdb_6_1_1-20040616-release:1.27
	gdb_6_1-2004-04-05-release:1.27
	drow_intercu-merge-20040402:1.27
	drow_intercu-merge-20040327:1.27
	ezannoni_pie-20040323-branch:1.27.0.38
	ezannoni_pie-20040323-branchpoint:1.27
	cagney_tramp-20040321-mergepoint:1.27
	cagney_tramp-20040309-branch:1.27.0.36
	cagney_tramp-20040309-branchpoint:1.27
	gdb_6_1-branch:1.27.0.34
	gdb_6_1-2004-03-01-gmt-branchpoint:1.27
	drow_intercu-20040221-branch:1.27.0.32
	drow_intercu-20040221-branchpoint:1.27
	cagney_bfdfile-20040213-branch:1.27.0.30
	cagney_bfdfile-20040213-branchpoint:1.27
	drow-cplus-merge-20040208:1.27
	carlton_dictionary-20040126-merge:1.27
	cagney_bigcore-20040122-branch:1.27.0.28
	cagney_bigcore-20040122-branchpoint:1.27
	drow-cplus-merge-20040113:1.27
	drow-cplus-merge-20031224:1.27
	drow-cplus-merge-20031220:1.27
	carlton_dictionary-20031215-merge:1.27
	drow-cplus-merge-20031214:1.27
	carlton-dictionary-20031111-merge:1.27
	gdb_6_0-2003-10-04-release:1.27
	kettenis_sparc-20030918-branch:1.27.0.26
	kettenis_sparc-20030918-branchpoint:1.27
	carlton_dictionary-20030917-merge:1.27
	ezannoni_pie-20030916-branchpoint:1.27
	ezannoni_pie-20030916-branch:1.27.0.24
	cagney_x86i386-20030821-branch:1.27.0.22
	cagney_x86i386-20030821-branchpoint:1.27
	carlton_dictionary-20030805-merge:1.27
	carlton_dictionary-20030627-merge:1.27
	gdb_6_0-branch:1.27.0.20
	gdb_6_0-2003-06-23-branchpoint:1.27
	jimb-ppc64-linux-20030613-branch:1.27.0.18
	jimb-ppc64-linux-20030613-branchpoint:1.27
	cagney_convert-20030606-branch:1.27.0.16
	cagney_convert-20030606-branchpoint:1.27
	cagney_writestrings-20030508-branch:1.27.0.14
	cagney_writestrings-20030508-branchpoint:1.27
	jimb-ppc64-linux-20030528-branch:1.27.0.12
	jimb-ppc64-linux-20030528-branchpoint:1.27
	carlton_dictionary-20030523-merge:1.27
	cagney_fileio-20030521-branch:1.27.0.10
	cagney_fileio-20030521-branchpoint:1.27
	kettenis_i386newframe-20030517-mergepoint:1.27
	jimb-ppc64-linux-20030509-branch:1.27.0.8
	jimb-ppc64-linux-20030509-branchpoint:1.27
	kettenis_i386newframe-20030504-mergepoint:1.27
	carlton_dictionary-20030430-merge:1.27
	kettenis_i386newframe-20030419-branch:1.27.0.6
	kettenis_i386newframe-20030419-branchpoint:1.27
	carlton_dictionary-20030416-merge:1.27
	cagney_frameaddr-20030409-mergepoint:1.27
	kettenis_i386newframe-20030406-branch:1.27.0.4
	kettenis_i386newframe-20030406-branchpoint:1.27
	cagney_frameaddr-20030403-branchpoint:1.27
	cagney_frameaddr-20030403-branch:1.27.0.2
	cagney_framebase-20030330-mergepoint:1.27
	cagney_framebase-20030326-branch:1.25.0.2
	cagney_framebase-20030326-branchpoint:1.25
	cagney_lazyid-20030317-branch:1.24.0.8
	cagney_lazyid-20030317-branchpoint:1.24
	kettenis-i386newframe-20030316-mergepoint:1.24
	offbyone-20030313-branch:1.24.0.6
	offbyone-20030313-branchpoint:1.24
	kettenis-i386newframe-20030308-branch:1.24.0.4
	kettenis-i386newframe-20030308-branchpoint:1.24
	carlton_dictionary-20030305-merge:1.24
	cagney_offbyone-20030303-branch:1.24.0.2
	cagney_offbyone-20030303-branchpoint:1.24
	carlton_dictionary-20030207-merge:1.23
	interps-20030202-branch:1.23.0.6
	interps-20030202-branchpoint:1.23
	cagney-unwind-20030108-branch:1.23.0.4
	cagney-unwind-20030108-branchpoint:1.23
	carlton_dictionary-20021223-merge:1.23
	gdb_5_3-2002-12-12-release:1.22
	carlton_dictionary-20021115-merge:1.23
	kseitz_interps-20021105-merge:1.23
	kseitz_interps-20021103-merge:1.23
	drow-cplus-merge-20021020:1.23
	drow-cplus-merge-20021025:1.23
	carlton_dictionary-20021025-merge:1.23
	carlton_dictionary-20021011-merge:1.23
	drow-cplus-branch:1.23.0.2
	drow-cplus-branchpoint:1.23
	kseitz_interps-20020930-merge:1.23
	carlton_dictionary-20020927-merge:1.22
	carlton_dictionary-branch:1.22.0.8
	carlton_dictionary-20020920-branchpoint:1.22
	gdb_5_3-branch:1.22.0.6
	gdb_5_3-2002-09-04-branchpoint:1.22
	kseitz_interps-20020829-merge:1.22
	cagney_sysregs-20020825-branch:1.22.0.4
	cagney_sysregs-20020825-branchpoint:1.22
	readline_4_3-import-branch:1.22.0.2
	readline_4_3-import-branchpoint:1.22
	gdb_5_2_1-2002-07-23-release:1.17
	kseitz_interps-20020528-branch:1.20.0.2
	kseitz_interps-20020528-branchpoint:1.20
	cagney_regbuf-20020515-branch:1.18.0.4
	cagney_regbuf-20020515-branchpoint:1.18
	jimb-macro-020506-branch:1.18.0.2
	jimb-macro-020506-branchpoint:1.18
	gdb_5_2-2002-04-29-release:1.17
	gdb_5_2-branch:1.17.0.2
	gdb_5_2-2002-03-03-branchpoint:1.17
	gdb_5_1_1-2002-01-24-release:1.13
	gdb_5_1_0_1-2002-01-03-release:1.13
	gdb_5_1_0_1-2002-01-03-branch:1.13.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.13
	gdb_5_1-2001-11-21-release:1.13
	gdb_s390-2001-09-26-branch:1.13.0.4
	gdb_s390-2001-09-26-branchpoint:1.13
	gdb_5_1-2001-07-29-branch:1.13.0.2
	gdb_5_1-2001-07-29-branchpoint:1.13
	insight-precleanup-2001-01-01:1.10
	gdb-premipsmulti-2000-06-06-branch:1.5.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.5
	gdb_5_0-2000-05-19-release:1.3
	gdb_4_18_2-2000-05-18-release:1.3
	gdb_4_95_1-2000-05-11-snapshot:1.3
	gdb_4_95_0-2000-04-27-snapshot:1.3
	gdb_5_0-2000-04-10-branch:1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.3
	repo-unification-2000-02-06:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.48
date	2013.03.15.17.53.42;	author sje;	state Exp;
branches;
next	1.47;

1.47
date	2013.01.01.06.41.32;	author brobecke;	state Exp;
branches;
next	1.46;

1.46
date	2012.08.01.14.38.19;	author kevinb;	state Exp;
branches;
next	1.45;

1.45
date	2012.06.13.10.07.11;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2012.05.24.16.51.40;	author palves;	state Exp;
branches;
next	1.43;

1.43
date	2012.05.19.16.46.13;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2012.01.04.08.28.02;	author brobecke;	state Exp;
branches;
next	1.41;

1.41
date	2011.04.16.18.16.33;	author vapier;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2011.01.01.15.33.54;	author brobecke;	state Exp;
branches;
next	1.39;

1.39
date	2010.04.14.07.38.03;	author vapier;	state Exp;
branches;
next	1.38;

1.38
date	2010.01.01.10.03.26;	author brobecke;	state Exp;
branches;
next	1.37;

1.37
date	2009.01.14.10.53.05;	author brobecke;	state Exp;
branches;
next	1.36;

1.36
date	2008.06.07.01.31.25;	author jsm28;	state Exp;
branches;
next	1.35;

1.35
date	2008.01.01.22.53.23;	author drow;	state Exp;
branches;
next	1.34;

1.34
date	2007.08.24.14.28.34;	author brobecke;	state Exp;
branches;
next	1.33;

1.33
date	2007.02.08.16.31.57;	author drow;	state Exp;
branches;
next	1.32;

1.32
date	2007.01.09.17.59.16;	author drow;	state Exp;
branches;
next	1.31;

1.31
date	2005.11.28.18.33.03;	author mmitchel;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.12.07.36.59;	author nickc;	state Exp;
branches
	1.30.8.1;
next	1.29;

1.29
date	2005.04.25.07.48.59;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.30.16.21.33;	author pbrook;	state Exp;
branches;
next	1.27;

1.27
date	2003.03.30.10.39.22;	author nickc;	state Exp;
branches
	1.27.46.1;
next	1.26;

1.26
date	2003.03.27.17.13.33;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2003.03.20.12.25.07;	author nickc;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2003.02.27.23.26.33;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2002.09.27.23.57.50;	author cagney;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2002.06.12.21.19.43;	author cagney;	state Exp;
branches
	1.22.8.1;
next	1.21;

1.21
date	2002.06.09.15.45.44;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.27.14.12.00;	author nickc;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2002.05.20.14.32.49;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.18.21.43.15;	author green;	state Exp;
branches
	1.18.4.1;
next	1.17;

1.17
date	2002.02.05.11.22.26;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.04.16.27.22;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.09.15.08.21;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.09.14.59.22;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.28.01.04.24;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.14.22.21.20;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.01.00.14.40;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.30.01.55.12;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.15.23.55.50;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.14.21.27.15;	author fnasser;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.14.16.49.46;	author fnasser;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.04.07.18.18;	author aoliva;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.30.17.13.37;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.23.23.52.46;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.23.23.28.43;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.08.20.54.27;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.56;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.41.2.1
date	2012.01.06.04.54.37;	author brobecke;	state Exp;
branches;
next	;

1.30.8.1
date	2005.11.17.06.22.44;	author mmitchel;	state Exp;
branches;
next	;

1.27.46.1
date	2005.03.30.16.08.43;	author pbrook;	state Exp;
branches;
next	;

1.25.2.1
date	2003.03.30.16.35.25;	author cagney;	state Exp;
branches;
next	;

1.23.2.1
date	2003.12.14.20.28.17;	author drow;	state Exp;
branches;
next	;

1.22.8.1
date	2002.10.11.22.23.07;	author carlton;	state Exp;
branches;
next	1.22.8.2;

1.22.8.2
date	2003.03.06.00.56.40;	author carlton;	state Exp;
branches;
next	1.22.8.3;

1.22.8.3
date	2003.04.16.19.57.08;	author carlton;	state Exp;
branches;
next	;

1.20.2.1
date	2002.06.20.01.38.54;	author kseitz;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2002.10.01.00.46.46;	author kseitz;	state Exp;
branches;
next	;

1.18.4.1
date	2002.06.15.16.43.22;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.56;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.31.25;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.02.05.07.30.20;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.48
log
@gdb:

2013-03-15  Steve Ellcey  <sellcey@@mips.com>

	* remote-sim.c (sim_command_completer): Make char arguments const.

include:


2013-03-15  Steve Ellcey  <sellcey@@mips.com>

	* gdb/remote-sim.h (sim_command_completer): Make char arguments const.

sim:

2013-03-15  Steve Ellcey  <sellcey@@mips.com>

	* arm/wrapper.c (sim_complete_command): Make char arguments const.
	* avr/interp.c (sim_complete_command): Ditto.
	* common/sim-options.c (sim_complete_command): Ditto.
	* cr16/interp.c (sim_complete_command): Ditto.
	* erc32/interf.c (sim_complete_command): Ditto.
	* m32c/gdb-if.c (sim_complete_command): Ditto.
	* microblaze/interp.c (sim_complete_command): Ditto.
	* ppc/sim_calls.c (sim_complete_command): Ditto.
	* rl78/gdb-if.c (sim_complete_command): Ditto.
	* rx/gdb-if.c (sim_complete_command): Ditto.
	* sh/interp.c (sim_complete_command): Ditto.
@
text
@/* run front end support for arm
   Copyright (C) 1995-2013 Free Software Foundation, Inc.

   This file is part of ARM SIM.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* This file provides the interface between the simulator and
   run.c and gdb (when the simulator is linked with gdb).
   All simulator interaction should go through this file.  */

#include "config.h"
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <bfd.h>
#include <signal.h>
#include "gdb/callback.h"
#include "gdb/remote-sim.h"
#include "armdefs.h"
#include "armemu.h"
#include "dbg_rdi.h"
#include "ansidecl.h"
#include "sim-utils.h"
#include "run-sim.h"
#include "gdb/sim-arm.h"
#include "gdb/signals.h"
#include "libiberty.h"

host_callback *sim_callback;

static struct ARMul_State *state;

/* Who is using the simulator.  */
static SIM_OPEN_KIND sim_kind;

/* argv[0] */
static char *myname;

/* Memory size in bytes.  */
static int mem_size = (1 << 21);

/* Non-zero to display start up banner, and maybe other things.  */
static int verbosity;

/* Non-zero to set big endian mode.  */
static int big_endian;

int stop_simulator;

/* Cirrus DSP registers.

   We need to define these registers outside of maverick.c because
   maverick.c might not be linked in unless --target=arm9e-* in which
   case wrapper.c will not compile because it tries to access Cirrus
   registers.  This should all go away once we get the Cirrus and ARM
   Coprocessor to coexist in armcopro.c-- aldyh.  */

struct maverick_regs
{
  union
  {
    int i;
    float f;
  } upper;
  
  union
  {
    int i;
    float f;
  } lower;
};

union maverick_acc_regs
{
  long double ld;		/* Acc registers are 72-bits.  */
};

struct maverick_regs     DSPregs[16];
union maverick_acc_regs  DSPacc[4];
ARMword DSPsc;

static void
init ()
{
  static int done;

  if (!done)
    {
      ARMul_EmulateInit ();
      state = ARMul_NewState ();
      state->bigendSig = (big_endian ? HIGH : LOW);
      ARMul_MemoryInit (state, mem_size);
      ARMul_OSInit (state);
      state->verbose = verbosity;
      done = 1;
    }
}

/* Set verbosity level of simulator.
   This is not intended to produce detailed tracing or debugging information.
   Just summaries.  */
/* FIXME: common/run.c doesn't do this yet.  */

void
sim_set_verbose (v)
     int v;
{
  verbosity = v;
}

/* Set the memory size to SIZE bytes.
   Must be called before initializing simulator.  */
/* FIXME: Rename to sim_set_mem_size.  */

void
sim_size (size)
     int size;
{
  mem_size = size;
}

void
ARMul_ConsolePrint VPARAMS ((ARMul_State * state,
			     const char * format,
			     ...))
{
  va_list ap;

  if (state->verbose)
    {
      va_start (ap, format);
      vprintf (format, ap);
      va_end (ap);
    }
}

ARMword
ARMul_Debug (state, pc, instr)
     ARMul_State * state ATTRIBUTE_UNUSED;
     ARMword       pc    ATTRIBUTE_UNUSED;
     ARMword       instr ATTRIBUTE_UNUSED;
{
  return 0;
}

int
sim_write (sd, addr, buffer, size)
     SIM_DESC sd ATTRIBUTE_UNUSED;
     SIM_ADDR addr;
     const unsigned char * buffer;
     int size;
{
  int i;

  init ();

  for (i = 0; i < size; i++)
    ARMul_SafeWriteByte (state, addr + i, buffer[i]);

  return size;
}

int
sim_read (sd, addr, buffer, size)
     SIM_DESC sd ATTRIBUTE_UNUSED;
     SIM_ADDR addr;
     unsigned char * buffer;
     int size;
{
  int i;

  init ();

  for (i = 0; i < size; i++)
    buffer[i] = ARMul_SafeReadByte (state, addr + i);

  return size;
}

int
sim_trace (sd)
     SIM_DESC sd ATTRIBUTE_UNUSED;
{  
  (*sim_callback->printf_filtered)
    (sim_callback,
     "This simulator does not support tracing\n");
  return 1;
}

int
sim_stop (sd)
     SIM_DESC sd ATTRIBUTE_UNUSED;
{
  state->Emulate = STOP;
  stop_simulator = 1;
  return 1;
}

void
sim_resume (sd, step, siggnal)
     SIM_DESC sd ATTRIBUTE_UNUSED;
     int step;
     int siggnal ATTRIBUTE_UNUSED;
{
  state->EndCondition = 0;
  stop_simulator = 0;

  if (step)
    {
      state->Reg[15] = ARMul_DoInstr (state);
      if (state->EndCondition == 0)
	state->EndCondition = RDIError_BreakpointReached;
    }
  else
    {
      state->NextInstr = RESUME;	/* treat as PC change */
      state->Reg[15] = ARMul_DoProg (state);
    }

  FLUSHPIPE;
}

SIM_RC
sim_create_inferior (sd, abfd, argv, env)
     SIM_DESC sd ATTRIBUTE_UNUSED;
     struct bfd * abfd;
     char ** argv;
     char ** env;
{
  int argvlen = 0;
  int mach;
  char **arg;

  if (abfd != NULL)
    ARMul_SetPC (state, bfd_get_start_address (abfd));
  else
    ARMul_SetPC (state, 0);	/* ??? */

  mach = bfd_get_mach (abfd);

  switch (mach)
    {
    default:
      (*sim_callback->printf_filtered)
	(sim_callback,
	 "Unknown machine type '%d'; please update sim_create_inferior.\n",
	 mach);
      /* fall through */

    case 0:
      /* We wouldn't set the machine type with earlier toolchains, so we
	 explicitly select a processor capable of supporting all ARMs in
	 32bit mode.  */
      /* We choose the XScale rather than the iWMMXt, because the iWMMXt
	 removes the FPE emulator, since it conflicts with its coprocessors.
	 For the most generic ARM support, we want the FPE emulator in place.  */
    case bfd_mach_arm_XScale:
      ARMul_SelectProcessor (state, ARM_v5_Prop | ARM_v5e_Prop | ARM_XScale_Prop | ARM_v6_Prop);
      break;

    case bfd_mach_arm_iWMMXt2:
    case bfd_mach_arm_iWMMXt:
      {
	extern int SWI_vector_installed;
	ARMword i;

	if (! SWI_vector_installed)
	  {
	    /* Intialise the hardware vectors to zero.  */
	    if (! SWI_vector_installed)
	      for (i = ARMul_ResetV; i <= ARMFIQV; i += 4)
		ARMul_WriteWord (state, i, 0);

	    /* ARM_WriteWord will have detected the write to the SWI vector,
	       but we want SWI_vector_installed to remain at 0 so that thumb
	       mode breakpoints will work.  */
	    SWI_vector_installed = 0;
	  }
      }
      ARMul_SelectProcessor (state, ARM_v5_Prop | ARM_v5e_Prop | ARM_XScale_Prop | ARM_iWMMXt_Prop);
      break;

    case bfd_mach_arm_ep9312:
      ARMul_SelectProcessor (state, ARM_v4_Prop | ARM_ep9312_Prop);
      break;

    case bfd_mach_arm_5:
      if (bfd_family_coff (abfd))
	{
	  /* This is a special case in order to support COFF based ARM toolchains.
	     The COFF header does not have enough room to store all the different
	     kinds of ARM cpu, so the XScale, v5T and v5TE architectures all default
	     to v5.  (See coff_set_flags() in bdf/coffcode.h).  So if we see a v5
	     machine type here, we assume it could be any of the above architectures
	     and so select the most feature-full.  */
	  ARMul_SelectProcessor (state, ARM_v5_Prop | ARM_v5e_Prop | ARM_XScale_Prop);
	  break;
	}
      /* Otherwise drop through.  */

    case bfd_mach_arm_5T:
      ARMul_SelectProcessor (state, ARM_v5_Prop);
      break;

    case bfd_mach_arm_5TE:
      ARMul_SelectProcessor (state, ARM_v5_Prop | ARM_v5e_Prop);
      break;

    case bfd_mach_arm_4:
    case bfd_mach_arm_4T:
      ARMul_SelectProcessor (state, ARM_v4_Prop);
      break;

    case bfd_mach_arm_3:
    case bfd_mach_arm_3M:
      ARMul_SelectProcessor (state, ARM_Lock_Prop);
      break;

    case bfd_mach_arm_2:
    case bfd_mach_arm_2a:
      ARMul_SelectProcessor (state, ARM_Fix26_Prop);
      break;
    }

  if (   mach != bfd_mach_arm_3
      && mach != bfd_mach_arm_3M
      && mach != bfd_mach_arm_2
      && mach != bfd_mach_arm_2a)
    {
      /* Reset mode to ARM.  A gdb user may rerun a program that had entered
	 THUMB mode from the start and cause the ARM-mode startup code to be
	 executed in THUMB mode.  */
      ARMul_SetCPSR (state, SVC32MODE);
    }
  
  if (argv != NULL)
    {
      /* Set up the command line by laboriously stringing together
	 the environment carefully picked apart by our caller.  */

      /* Free any old stuff.  */
      if (state->CommandLine != NULL)
	{
	  free (state->CommandLine);
	  state->CommandLine = NULL;
	}

      /* See how much we need.  */
      for (arg = argv; *arg != NULL; arg++)
	argvlen += strlen (*arg) + 1;

      /* Allocate it.  */
      state->CommandLine = malloc (argvlen + 1);
      if (state->CommandLine != NULL)
	{
	  arg = argv;
	  state->CommandLine[0] = '\0';

	  for (arg = argv; *arg != NULL; arg++)
	    {
	      strcat (state->CommandLine, *arg);
	      strcat (state->CommandLine, " ");
	    }
	}
    }

  if (env != NULL)
    {
      /* Now see if there's a MEMSIZE spec in the environment.  */
      while (*env)
	{
	  if (strncmp (*env, "MEMSIZE=", sizeof ("MEMSIZE=") - 1) == 0)
	    {
	      char *end_of_num;

	      /* Set up memory limit.  */
	      state->MemSize =
		strtoul (*env + sizeof ("MEMSIZE=") - 1, &end_of_num, 0);
	    }
	  env++;
	}
    }

  return SIM_RC_OK;
}

void
sim_info (sd, verbose)
     SIM_DESC sd ATTRIBUTE_UNUSED;
     int verbose ATTRIBUTE_UNUSED;
{
}

static int
frommem (state, memory)
     struct ARMul_State *state;
     unsigned char *memory;
{
  if (state->bigendSig == HIGH)
    return (memory[0] << 24) | (memory[1] << 16)
      | (memory[2] << 8) | (memory[3] << 0);
  else
    return (memory[3] << 24) | (memory[2] << 16)
      | (memory[1] << 8) | (memory[0] << 0);
}

static void
tomem (state, memory, val)
     struct ARMul_State *state;
     unsigned char *memory;
     int val;
{
  if (state->bigendSig == HIGH)
    {
      memory[0] = val >> 24;
      memory[1] = val >> 16;
      memory[2] = val >> 8;
      memory[3] = val >> 0;
    }
  else
    {
      memory[3] = val >> 24;
      memory[2] = val >> 16;
      memory[1] = val >> 8;
      memory[0] = val >> 0;
    }
}

int
sim_store_register (sd, rn, memory, length)
     SIM_DESC sd ATTRIBUTE_UNUSED;
     int rn;
     unsigned char *memory;
     int length;
{
  init ();

  switch ((enum sim_arm_regs) rn)
    {
    case SIM_ARM_R0_REGNUM:
    case SIM_ARM_R1_REGNUM:
    case SIM_ARM_R2_REGNUM:
    case SIM_ARM_R3_REGNUM:
    case SIM_ARM_R4_REGNUM:
    case SIM_ARM_R5_REGNUM:
    case SIM_ARM_R6_REGNUM:
    case SIM_ARM_R7_REGNUM:
    case SIM_ARM_R8_REGNUM:
    case SIM_ARM_R9_REGNUM:
    case SIM_ARM_R10_REGNUM:
    case SIM_ARM_R11_REGNUM:
    case SIM_ARM_R12_REGNUM:
    case SIM_ARM_R13_REGNUM:
    case SIM_ARM_R14_REGNUM:
    case SIM_ARM_R15_REGNUM: /* PC */
    case SIM_ARM_FP0_REGNUM:
    case SIM_ARM_FP1_REGNUM:
    case SIM_ARM_FP2_REGNUM:
    case SIM_ARM_FP3_REGNUM:
    case SIM_ARM_FP4_REGNUM:
    case SIM_ARM_FP5_REGNUM:
    case SIM_ARM_FP6_REGNUM:
    case SIM_ARM_FP7_REGNUM:
    case SIM_ARM_FPS_REGNUM:
      ARMul_SetReg (state, state->Mode, rn, frommem (state, memory));
      break;

    case SIM_ARM_PS_REGNUM:
      state->Cpsr = frommem (state, memory);
      ARMul_CPSRAltered (state);
      break;

    case SIM_ARM_MAVERIC_COP0R0_REGNUM:
    case SIM_ARM_MAVERIC_COP0R1_REGNUM:
    case SIM_ARM_MAVERIC_COP0R2_REGNUM:
    case SIM_ARM_MAVERIC_COP0R3_REGNUM:
    case SIM_ARM_MAVERIC_COP0R4_REGNUM:
    case SIM_ARM_MAVERIC_COP0R5_REGNUM:
    case SIM_ARM_MAVERIC_COP0R6_REGNUM:
    case SIM_ARM_MAVERIC_COP0R7_REGNUM:
    case SIM_ARM_MAVERIC_COP0R8_REGNUM:
    case SIM_ARM_MAVERIC_COP0R9_REGNUM:
    case SIM_ARM_MAVERIC_COP0R10_REGNUM:
    case SIM_ARM_MAVERIC_COP0R11_REGNUM:
    case SIM_ARM_MAVERIC_COP0R12_REGNUM:
    case SIM_ARM_MAVERIC_COP0R13_REGNUM:
    case SIM_ARM_MAVERIC_COP0R14_REGNUM:
    case SIM_ARM_MAVERIC_COP0R15_REGNUM:
      memcpy (& DSPregs [rn - SIM_ARM_MAVERIC_COP0R0_REGNUM],
	      memory, sizeof (struct maverick_regs));
      return sizeof (struct maverick_regs);

    case SIM_ARM_MAVERIC_DSPSC_REGNUM:
      memcpy (&DSPsc, memory, sizeof DSPsc);
      return sizeof DSPsc;

    case SIM_ARM_IWMMXT_COP0R0_REGNUM:
    case SIM_ARM_IWMMXT_COP0R1_REGNUM:
    case SIM_ARM_IWMMXT_COP0R2_REGNUM:
    case SIM_ARM_IWMMXT_COP0R3_REGNUM:
    case SIM_ARM_IWMMXT_COP0R4_REGNUM:
    case SIM_ARM_IWMMXT_COP0R5_REGNUM:
    case SIM_ARM_IWMMXT_COP0R6_REGNUM:
    case SIM_ARM_IWMMXT_COP0R7_REGNUM:
    case SIM_ARM_IWMMXT_COP0R8_REGNUM:
    case SIM_ARM_IWMMXT_COP0R9_REGNUM:
    case SIM_ARM_IWMMXT_COP0R10_REGNUM:
    case SIM_ARM_IWMMXT_COP0R11_REGNUM:
    case SIM_ARM_IWMMXT_COP0R12_REGNUM:
    case SIM_ARM_IWMMXT_COP0R13_REGNUM:
    case SIM_ARM_IWMMXT_COP0R14_REGNUM:
    case SIM_ARM_IWMMXT_COP0R15_REGNUM:
    case SIM_ARM_IWMMXT_COP1R0_REGNUM:
    case SIM_ARM_IWMMXT_COP1R1_REGNUM:
    case SIM_ARM_IWMMXT_COP1R2_REGNUM:
    case SIM_ARM_IWMMXT_COP1R3_REGNUM:
    case SIM_ARM_IWMMXT_COP1R4_REGNUM:
    case SIM_ARM_IWMMXT_COP1R5_REGNUM:
    case SIM_ARM_IWMMXT_COP1R6_REGNUM:
    case SIM_ARM_IWMMXT_COP1R7_REGNUM:
    case SIM_ARM_IWMMXT_COP1R8_REGNUM:
    case SIM_ARM_IWMMXT_COP1R9_REGNUM:
    case SIM_ARM_IWMMXT_COP1R10_REGNUM:
    case SIM_ARM_IWMMXT_COP1R11_REGNUM:
    case SIM_ARM_IWMMXT_COP1R12_REGNUM:
    case SIM_ARM_IWMMXT_COP1R13_REGNUM:
    case SIM_ARM_IWMMXT_COP1R14_REGNUM:
    case SIM_ARM_IWMMXT_COP1R15_REGNUM:
      return Store_Iwmmxt_Register (rn - SIM_ARM_IWMMXT_COP0R0_REGNUM, memory);

    default:
      return 0;
    }

  return length;
}

int
sim_fetch_register (sd, rn, memory, length)
     SIM_DESC sd ATTRIBUTE_UNUSED;
     int rn;
     unsigned char *memory;
     int length;
{
  ARMword regval;
  int len = length;

  init ();

  switch ((enum sim_arm_regs) rn)
    {
    case SIM_ARM_R0_REGNUM:
    case SIM_ARM_R1_REGNUM:
    case SIM_ARM_R2_REGNUM:
    case SIM_ARM_R3_REGNUM:
    case SIM_ARM_R4_REGNUM:
    case SIM_ARM_R5_REGNUM:
    case SIM_ARM_R6_REGNUM:
    case SIM_ARM_R7_REGNUM:
    case SIM_ARM_R8_REGNUM:
    case SIM_ARM_R9_REGNUM:
    case SIM_ARM_R10_REGNUM:
    case SIM_ARM_R11_REGNUM:
    case SIM_ARM_R12_REGNUM:
    case SIM_ARM_R13_REGNUM:
    case SIM_ARM_R14_REGNUM:
    case SIM_ARM_R15_REGNUM: /* PC */
      regval = ARMul_GetReg (state, state->Mode, rn);
      break;

    case SIM_ARM_FP0_REGNUM:
    case SIM_ARM_FP1_REGNUM:
    case SIM_ARM_FP2_REGNUM:
    case SIM_ARM_FP3_REGNUM:
    case SIM_ARM_FP4_REGNUM:
    case SIM_ARM_FP5_REGNUM:
    case SIM_ARM_FP6_REGNUM:
    case SIM_ARM_FP7_REGNUM:
    case SIM_ARM_FPS_REGNUM:
      memset (memory, 0, length);
      return 0;

    case SIM_ARM_PS_REGNUM:
      regval = ARMul_GetCPSR (state);
      break;

    case SIM_ARM_MAVERIC_COP0R0_REGNUM:
    case SIM_ARM_MAVERIC_COP0R1_REGNUM:
    case SIM_ARM_MAVERIC_COP0R2_REGNUM:
    case SIM_ARM_MAVERIC_COP0R3_REGNUM:
    case SIM_ARM_MAVERIC_COP0R4_REGNUM:
    case SIM_ARM_MAVERIC_COP0R5_REGNUM:
    case SIM_ARM_MAVERIC_COP0R6_REGNUM:
    case SIM_ARM_MAVERIC_COP0R7_REGNUM:
    case SIM_ARM_MAVERIC_COP0R8_REGNUM:
    case SIM_ARM_MAVERIC_COP0R9_REGNUM:
    case SIM_ARM_MAVERIC_COP0R10_REGNUM:
    case SIM_ARM_MAVERIC_COP0R11_REGNUM:
    case SIM_ARM_MAVERIC_COP0R12_REGNUM:
    case SIM_ARM_MAVERIC_COP0R13_REGNUM:
    case SIM_ARM_MAVERIC_COP0R14_REGNUM:
    case SIM_ARM_MAVERIC_COP0R15_REGNUM:
      memcpy (memory, & DSPregs [rn - SIM_ARM_MAVERIC_COP0R0_REGNUM],
	      sizeof (struct maverick_regs));
      return sizeof (struct maverick_regs);

    case SIM_ARM_MAVERIC_DSPSC_REGNUM:
      memcpy (memory, & DSPsc, sizeof DSPsc);
      return sizeof DSPsc;

    case SIM_ARM_IWMMXT_COP0R0_REGNUM:
    case SIM_ARM_IWMMXT_COP0R1_REGNUM:
    case SIM_ARM_IWMMXT_COP0R2_REGNUM:
    case SIM_ARM_IWMMXT_COP0R3_REGNUM:
    case SIM_ARM_IWMMXT_COP0R4_REGNUM:
    case SIM_ARM_IWMMXT_COP0R5_REGNUM:
    case SIM_ARM_IWMMXT_COP0R6_REGNUM:
    case SIM_ARM_IWMMXT_COP0R7_REGNUM:
    case SIM_ARM_IWMMXT_COP0R8_REGNUM:
    case SIM_ARM_IWMMXT_COP0R9_REGNUM:
    case SIM_ARM_IWMMXT_COP0R10_REGNUM:
    case SIM_ARM_IWMMXT_COP0R11_REGNUM:
    case SIM_ARM_IWMMXT_COP0R12_REGNUM:
    case SIM_ARM_IWMMXT_COP0R13_REGNUM:
    case SIM_ARM_IWMMXT_COP0R14_REGNUM:
    case SIM_ARM_IWMMXT_COP0R15_REGNUM:
    case SIM_ARM_IWMMXT_COP1R0_REGNUM:
    case SIM_ARM_IWMMXT_COP1R1_REGNUM:
    case SIM_ARM_IWMMXT_COP1R2_REGNUM:
    case SIM_ARM_IWMMXT_COP1R3_REGNUM:
    case SIM_ARM_IWMMXT_COP1R4_REGNUM:
    case SIM_ARM_IWMMXT_COP1R5_REGNUM:
    case SIM_ARM_IWMMXT_COP1R6_REGNUM:
    case SIM_ARM_IWMMXT_COP1R7_REGNUM:
    case SIM_ARM_IWMMXT_COP1R8_REGNUM:
    case SIM_ARM_IWMMXT_COP1R9_REGNUM:
    case SIM_ARM_IWMMXT_COP1R10_REGNUM:
    case SIM_ARM_IWMMXT_COP1R11_REGNUM:
    case SIM_ARM_IWMMXT_COP1R12_REGNUM:
    case SIM_ARM_IWMMXT_COP1R13_REGNUM:
    case SIM_ARM_IWMMXT_COP1R14_REGNUM:
    case SIM_ARM_IWMMXT_COP1R15_REGNUM:
      return Fetch_Iwmmxt_Register (rn - SIM_ARM_IWMMXT_COP0R0_REGNUM, memory);

    default:
      return 0;
    }

  while (len)
    {
      tomem (state, memory, regval);

      len -= 4;
      memory += 4;
      regval = 0;
    }  

  return length;
}

#ifdef SIM_TARGET_SWITCHES

static void sim_target_parse_arg_array PARAMS ((char **));

typedef struct
{
  char * 	swi_option;
  unsigned int	swi_mask;
} swi_options;

#define SWI_SWITCH	"--swi-support"

static swi_options options[] =
  {
    { "none",    0 },
    { "demon",   SWI_MASK_DEMON },
    { "angel",   SWI_MASK_ANGEL },
    { "redboot", SWI_MASK_REDBOOT },
    { "all",     -1 },
    { "NONE",    0 },
    { "DEMON",   SWI_MASK_DEMON },
    { "ANGEL",   SWI_MASK_ANGEL },
    { "REDBOOT", SWI_MASK_REDBOOT },
    { "ALL",     -1 }
  };


int
sim_target_parse_command_line (argc, argv)
     int argc;
     char ** argv;
{
  int i;

  for (i = 1; i < argc; i++)
    {
      char * ptr = argv[i];
      int arg;

      if ((ptr == NULL) || (* ptr != '-'))
	break;

      if (strncmp (ptr, SWI_SWITCH, sizeof SWI_SWITCH - 1) != 0)
	continue;

      if (ptr[sizeof SWI_SWITCH - 1] == 0)
	{
	  /* Remove this option from the argv array.  */
	  for (arg = i; arg < argc; arg ++)
	    argv[arg] = argv[arg + 1];
	  argc --;
	  
	  ptr = argv[i];
	}
      else
	ptr += sizeof SWI_SWITCH;

      swi_mask = 0;
      
      while (* ptr)
	{
	  int i;

	  for (i = sizeof options / sizeof options[0]; i--;)
	    if (strncmp (ptr, options[i].swi_option,
			 strlen (options[i].swi_option)) == 0)
	      {
		swi_mask |= options[i].swi_mask;
		ptr += strlen (options[i].swi_option);

		if (* ptr == ',')
		  ++ ptr;

		break;
	      }

	  if (i < 0)
	    break;
	}

      if (* ptr != 0)
	fprintf (stderr, "Ignoring swi options: %s\n", ptr);
      
      /* Remove this option from the argv array.  */
      for (arg = i; arg < argc; arg ++)
	argv[arg] = argv[arg + 1];
      argc --;
      i --;
    }
  return argc;
}

static void
sim_target_parse_arg_array (argv)
     char ** argv;
{
  int i;

  for (i = 0; argv[i]; i++)
    ;

  sim_target_parse_command_line (i, argv);
}

void
sim_target_display_usage (help)
     int help;
{
  FILE *stream = help ? stdout : stderr;

  fprintf (stream, "%s=<list>  Comma seperated list of SWI protocols to supoport.\n\
                This list can contain: NONE, DEMON, ANGEL, REDBOOT and/or ALL.\n",
	   SWI_SWITCH);
}
#endif

SIM_DESC
sim_open (kind, ptr, abfd, argv)
     SIM_OPEN_KIND kind;
     host_callback *ptr;
     struct bfd *abfd;
     char **argv;
{
  sim_kind = kind;
  if (myname) free (myname);
  myname = (char *) xstrdup (argv[0]);
  sim_callback = ptr;

#ifdef SIM_TARGET_SWITCHES
  sim_target_parse_arg_array (argv);
#endif
  
  /* Decide upon the endian-ness of the processor.
     If we can, get the information from the bfd itself.
     Otherwise look to see if we have been given a command
     line switch that tells us.  Otherwise default to little endian.  */
  if (abfd != NULL)
    big_endian = bfd_big_endian (abfd);
  else if (argv[1] != NULL)
    {
      int i;

      /* Scan for endian-ness and memory-size switches.  */
      for (i = 0; (argv[i] != NULL) && (argv[i][0] != 0); i++)
	if (argv[i][0] == '-' && argv[i][1] == 'E')
	  {
	    char c;

	    if ((c = argv[i][2]) == 0)
	      {
		++i;
		c = argv[i][0];
	      }

	    switch (c)
	      {
	      case 0:
		sim_callback->printf_filtered
		  (sim_callback, "No argument to -E option provided\n");
		break;

	      case 'b':
	      case 'B':
		big_endian = 1;
		break;

	      case 'l':
	      case 'L':
		big_endian = 0;
		break;

	      default:
		sim_callback->printf_filtered
		  (sim_callback, "Unrecognised argument to -E option\n");
		break;
	      }
	  }
	else if (argv[i][0] == '-' && argv[i][1] == 'm')
	  {
	    if (argv[i][2] != '\0')
	      sim_size (atoi (&argv[i][2]));
	    else if (argv[i + 1] != NULL)
	      {
		sim_size (atoi (argv[i + 1]));
		i++;
	      }
	    else
	      {
		sim_callback->printf_filtered (sim_callback,
					       "Missing argument to -m option\n");
		return NULL;
	      }
	      
	  }
    }

  return (SIM_DESC) 1;
}

void
sim_close (sd, quitting)
     SIM_DESC sd ATTRIBUTE_UNUSED;
     int quitting ATTRIBUTE_UNUSED;
{
  if (myname)
    free (myname);
  myname = NULL;
}

SIM_RC
sim_load (sd, prog, abfd, from_tty)
     SIM_DESC sd;
     char *prog;
     bfd *abfd;
     int from_tty ATTRIBUTE_UNUSED;
{
  bfd *prog_bfd;

  prog_bfd = sim_load_file (sd, myname, sim_callback, prog, abfd,
			    sim_kind == SIM_OPEN_DEBUG, 0, sim_write);
  if (prog_bfd == NULL)
    return SIM_RC_FAIL;
  ARMul_SetPC (state, bfd_get_start_address (prog_bfd));
  if (abfd == NULL)
    bfd_close (prog_bfd);
  return SIM_RC_OK;
}

void
sim_stop_reason (sd, reason, sigrc)
     SIM_DESC sd ATTRIBUTE_UNUSED;
     enum sim_stop *reason;
     int *sigrc;
{
  if (stop_simulator)
    {
      *reason = sim_stopped;
      *sigrc = GDB_SIGNAL_INT;
    }
  else if (state->EndCondition == 0)
    {
      *reason = sim_exited;
      *sigrc = state->Reg[0] & 255;
    }
  else
    {
      *reason = sim_stopped;
      if (state->EndCondition == RDIError_BreakpointReached)
	*sigrc = GDB_SIGNAL_TRAP;
      else if (   state->EndCondition == RDIError_DataAbort
	       || state->EndCondition == RDIError_AddressException)
	*sigrc = GDB_SIGNAL_BUS;
      else
	*sigrc = 0;
    }
}

void
sim_do_command (sd, cmd)
     SIM_DESC sd ATTRIBUTE_UNUSED;
     char *cmd ATTRIBUTE_UNUSED;
{  
  (*sim_callback->printf_filtered)
    (sim_callback,
     "This simulator does not accept any commands.\n");
}

void
sim_set_callbacks (ptr)
     host_callback *ptr;
{
  sim_callback = ptr;
}

char **
sim_complete_command (SIM_DESC sd, const char *text, const char *word)
{
  return NULL;
}
@


1.47
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d948 1
a948 1
sim_complete_command (SIM_DESC sd, char *text, char *word)
@


1.46
log
@	* wrapper.c (libiberty.h): Include.
	(sim_store_register, sim_fetch_register): On success, return
	length, instead of -1.
@
text
@d2 1
a2 2
   Copyright (C) 1995-1997, 2000-2002, 2007-2012 Free Software
   Foundation, Inc.
@


1.45
log
@	* wrapper.c (sim_create_inferior): Treat WMMX2 binaries as iWMMXt
	binaries (for now).
@
text
@d40 1
d447 1
a447 1
     int length ATTRIBUTE_UNUSED;
d548 1
a548 1
  return -1;
d556 1
a556 1
     int length ATTRIBUTE_UNUSED;
d559 1
d662 1
a662 1
  while (length)
d666 1
a666 1
      length -= 4;
d671 1
a671 1
  return -1;
@


1.44
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        * gdb/signals.def: Replace TARGET_SIGNAL_ with GDB_SIGNAL_
	throughout.

sim/arm/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/avr/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/cr16/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/d10v/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/erc32/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/m32c/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/ppc/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rl78/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rx/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.
@
text
@d273 1
@


1.43
log
@	PR 14072
	* wrapper.c: Include config.h before system header files.

	* callback.c: Include config.h before system header files.
	* cgen-trace.c: Likewise.
	* cgen-utils.c: Likewise.
	* gentmap.c: Likewise.

	* sim-if.c: Include config.h before system header files.

	* compile.c: Include config.h before system header files.
	* sim-main.h: Likewise.

	* gdb-if.c: Include config.h before system header files.
	* load.c: Likewise.
	* syscalls.c: Likewise.
	* trace.c: Likewise.

	* interp.c: Include config.h before system header files.
@
text
@d908 1
a908 1
      *sigrc = TARGET_SIGNAL_INT;
d919 1
a919 1
	*sigrc = TARGET_SIGNAL_TRAP;
d922 1
a922 1
	*sigrc = TARGET_SIGNAL_BUS;
@


1.42
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d24 1
@


1.41
log
@sim: add sim_complete_command stubs for non-common-using ports

For the ports that don't use the common/ subdir, we need to add stub funcs
to them to avoid build failures with gdb and command completion.  These do
not implement the actual completion functionality ... any port that wants
that can either convert to the common/ subdir, or fill out the function on
their own time.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d2 2
a3 2
   Copyright (C) 1995, 1996, 1997, 2000, 2001, 2002, 2007, 2008, 2009, 2010,
   2011 Free Software Foundation, Inc.
@


1.41.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 2
   Copyright (C) 1995-1997, 2000-2002, 2007-2012 Free Software
   Foundation, Inc.
@


1.40
log
@run copyright.sh for 2011.
@
text
@d943 6
@


1.39
log
@sim: constify sim_write source buffer (part 2)

As pointed out by Sandra Loosemore, a bunch of targets define sim_write
themselves instead of using the common/ code.  So constify them too.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d2 2
a3 2
   Copyright (C) 1995, 1996, 1997, 2000, 2001, 2002, 2007, 2008, 2009, 2010
   Free Software Foundation, Inc.
@


1.38
log
@Update copyright notices to add year 2010.
@
text
@d161 1
a161 1
     unsigned char * buffer;
@


1.37
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d2 1
a2 1
   Copyright (C) 1995, 1996, 1997, 2000, 2001, 2002, 2007, 2008, 2009
@


1.36
log
@sim:
2008-06-06  Vladimir Prus  <vladimir@@codesourcery.com>
            Daniel Jacobowitz  <dan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* cris/configure: Regenerate.

sim/common:
2008-06-06  Vladimir Prus  <vladimir@@codesourcery.com>
            Daniel Jacobowitz  <dan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* aclocal.m4: Include ../../config/acx.m4.
	* common.m4: Use ACX_PKGVERSION and ACX_BUGURL.
	* configure, config.in: Regenerate.
	* Make-common.in (LIB_OBJS): Add version.o.
	(version.c, version.o): New rules.
	* run.c: Include version.h.
	(usage): Add help parameter. Print output either to stdout or
	stderr depending on that parameter.
	(print_version): New.
	(main): Check for --help and --version.
	* run-sim.h (sim_target_display_usage): Add help parameter.
	* version.h: New.

sim/arm:
2008-06-06  Vladimir Prus  <vladimir@@codesourcery.com>
            Daniel Jacobowitz  <dan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* configure: Regenerate.
	* wrapper.c (sim_target_display_usage): Add help parameter.

sim/cr16:
2008-06-06  Vladimir Prus  <vladimir@@codesourcery.com>
            Daniel Jacobowitz  <dan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* configure: Regenerate.

sim/d10v:
2008-06-06  Vladimir Prus  <vladimir@@codesourcery.com>
            Daniel Jacobowitz  <dan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* configure: Regenerate.

sim/erc32:
2008-06-06  Vladimir Prus  <vladimir@@codesourcery.com>
            Daniel Jacobowitz  <dan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* configure: Regenerate.

sim/frv:
2008-06-06  Vladimir Prus  <vladimir@@codesourcery.com>
            Daniel Jacobowitz  <dan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* configure: Regenerate.

sim/h8300:
2008-06-06  Vladimir Prus  <vladimir@@codesourcery.com>
            Daniel Jacobowitz  <dan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* configure: Regenerate.

sim/iq2000:
2008-06-06  Vladimir Prus  <vladimir@@codesourcery.com>
            Daniel Jacobowitz  <dan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* configure: Regenerate.

sim/m32c:
2008-06-06  Vladimir Prus  <vladimir@@codesourcery.com>
            Daniel Jacobowitz  <dan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* configure: Regenerate.

sim/m32r:
2008-06-06  Vladimir Prus  <vladimir@@codesourcery.com>
            Daniel Jacobowitz  <dan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* configure: Regenerate.

sim/m68hc11:
2008-06-06  Vladimir Prus  <vladimir@@codesourcery.com>
            Daniel Jacobowitz  <dan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* configure: Regenerate.

sim/mcore:
2008-06-06  Vladimir Prus  <vladimir@@codesourcery.com>
            Daniel Jacobowitz  <dan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* configure: Regenerate.

sim/mips:
2008-06-06  Vladimir Prus  <vladimir@@codesourcery.com>
            Daniel Jacobowitz  <dan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* configure: Regenerate.

sim/mn10300:
2008-06-06  Vladimir Prus  <vladimir@@codesourcery.com>
            Daniel Jacobowitz  <dan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* configure: Regenerate.

sim/ppc:
2008-06-06  Vladimir Prus  <vladimir@@codesourcery.com>
            Daniel Jacobowitz  <dan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.ac: Use ACX_PKGVERSION and ACX_BUGURL.
	* configure, config.in: Regenerated.
	* Makefile.in (LIB_OBJ): Add version.o.
	(version.c, version.o): New rules.
	* psim.c (psim_usage): Add help parameter.  Print the bug URL.
	Exit with code 0 for help.
	(psim_options): Update calls to psim_usage.  Handle --help and
	--version.
	* psim.h (psim_usage): Update prototype.
	* main.c (main): Update psim_usage call.

sim/sh:
2008-06-06  Vladimir Prus  <vladimir@@codesourcery.com>
            Daniel Jacobowitz  <dan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* configure: Regenerate.

sim/sh64:
2008-06-06  Vladimir Prus  <vladimir@@codesourcery.com>
            Daniel Jacobowitz  <dan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* configure: Regenerate.

sim/v850:
2008-06-06  Vladimir Prus  <vladimir@@codesourcery.com>
            Daniel Jacobowitz  <dan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* configure: Regenerate.
@
text
@d2 1
a2 1
   Copyright (C) 1995, 1996, 1997, 2000, 2001, 2002, 2007, 2008
@


1.35
log
@	Updated copyright notices for most files.
@
text
@d775 2
a776 1
sim_target_display_usage ()
d778 3
a780 1
  fprintf (stderr, "%s=<list>  Comma seperated list of SWI protocols to supoport.\n\
@


1.34
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d2 1
a2 1
   Copyright (C) 1995, 1996, 1997, 2000, 2001, 2002, 2007
@


1.33
log
@	Reported by timeless@@gmail.com:
	* gdb/target.c (target_flash_erase): Do not return void value.
	(target_flash_done): Likewise.
	* gdb/cli/cli-cmds.c (source_command): Likewise.

	Reported by timeless@@gmail.com:
	* wrapper.c (sim_target_parse_arg_array): Do not return void value.
@
text
@d7 12
a18 14
   GCC is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published
   by the Free Software Foundation; either version 2, or (at your
   option) any later version.

   GCC is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See
   the GNU General Public License for more details.

   You should have received a copy of the GNU General Public
   License along with this program; if not, write to the Free
   Software Foundation, Inc., 51 Franklin Street - Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.32
log
@Copyright updates for 2007.
@
text
@d773 1
a773 1
  return (void) sim_target_parse_command_line (i, argv);
@


1.31
log
@	* remote-sim.c (gdbsim_wait): Pass target signal numbers to
	sim_resume.  Expect target signal numbers from sim_stop_reason.

	* wrapper.c (gdb/signals.h): Include it.
	(SIGTRAP): Don't define.
	(SIGBUS): Likewise.
	(sim_stop_reason): Use TARGET_SIGNAL_* instead of SIG*.

	* sim-reason.c (sim_stop_reason): Use
	sim_signal_to_target, not sim_signal_to_host.
	* sim-signal.c (sim_signal_to_host): Fix typo.
	(sim_signal_to_target): New function.

	* interp.c (gdb/signals.h): Include it.
	(sim_stop_reason): Use TARGET_SIGNAL_*.

	* interf.c: (gdb/signals.h): Include it.
	(sim_stop_reason): Use TARGET_SIGNAL_*.

	* sim_calls.c (gdb/signals.h): Include it.
	(sim_stop_reason): Use TARGET_SIGNAL_*.
	* psim.c (cntrl_c_simulation): Use TARGET_SIGNAL_*.
@
text
@d2 1
a2 1
   Copyright (C) 1995, 1996, 1997, 2000, 2001, 2002
@


1.30
log
@Update the address of the FSF organization
@
text
@d40 1
a40 8

#ifndef SIGTRAP
#define SIGTRAP 5
#endif

#ifndef SIGBUS
#define SIGBUS SIGSEGV
#endif
d906 1
a906 1
      *sigrc = SIGINT;
d917 1
a917 1
	*sigrc = SIGTRAP;
d920 1
a920 1
	*sigrc = SIGBUS;
@


1.30.8.1
log
@	* gdb/remote-sim.c (gdbsim_wait): Don't use target_signal_to_host
	or target_signal_from_host.
	* sim/arm/wrapper.c (gdb/signals.h): Include it.
	(SIGTRAP): Don't define it.
	(SIGBUS): Likewise.
	(sim_stop_reason): Use TARGET_SIGNAL_*.
	* sim/common/sim-reason.c (sim_stop_reason): Use
	sim_signal_to_target, not sim_signal_to_host.
	* sim/common/sim-signal.c (sim_signal_to_host): Fix typo.
	(sim_signal_to_target): New function.
	* sim/common/sim-signal.h: Declare it.
	* sim/d10v/interp.c (gdb/signals.h): Include it.
	(sim_stop_reason): Use TARGET_SIGNAL_*.
	* sim/erc32/interf.c: (gdb/signals.h): Include it.
	(sim_stop_reason): Use TARGET_SIGNAL_*.
	* sim/ppc/sim_calls.c (gdb/signals.h): Include it.
	(sim_stop_reason): Use TARGET_SIGNAL_*.
@
text
@d40 8
a47 1
#include "gdb/signals.h"
d913 1
a913 1
      *sigrc = TARGET_SIGNAL_INT;
d924 1
a924 1
	*sigrc = TARGET_SIGNAL_TRAP;
d927 1
a927 1
	*sigrc = TARGET_SIGNAL_BUS;
@


1.29
log
@* armemu.c (handle_v6_insn): New function - emulate a few of the v6 instructions - the ones now generated by GCC.
  (ARMulEmulate32): Call handle_v6_insn when a possible v6 insn is found.
* armdefs.h (struct ARMul_State): Add new field: is_v6.#
  (ARM_v6_Prop): Define.
* arminit.c (ARMul_NewState): Initialise the v6 flag.
  (ARMul_SelectProcessor): Determine if the v6 flag should be set.
* wrapper.c (sim_create_inferior): For unknown architectures, default to allowing the v6 instructions.
@
text
@d19 2
a20 2
   Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.28
log
@2005-03-30  Paul Brook  <paul@@codesourcery.com>

	* arm/wrapper.c: Provide SIGTRAP and SIGBUS.
@
text
@d278 1
a278 1
      ARMul_SelectProcessor (state, ARM_v5_Prop | ARM_v5e_Prop | ARM_XScale_Prop);
@


1.27
log
@Remove use of __IWMMXT__.
@
text
@d41 8
@


1.27.46.1
log
@2005-03-30  Paul Brook  <paul@@codesourcery.com>

	* arm/wrapper.c: Provide SIGTRAP and SIGBUS.
@
text
@a40 8
#ifndef SIGTRAP
#define SIGTRAP 5
#endif

#ifndef SIGBUS
#define SIGBUS SIGSEGV
#endif

@


1.26
log
@Add iWMMXt support to ARM simulator
@
text
@a507 1
#ifdef __IWMMXT__
d541 1
a541 1
#endif
a620 1
#ifdef __IWMMXT__
d654 1
a654 1
#endif
@


1.25
log
@Add Cirrus Maverick support to arm simulator
@
text
@d266 3
d273 21
d508 35
d622 35
d919 3
@


1.25.2.1
log
@Merge with mainline.
@
text
@a265 3
      /* We choose the XScale rather than the iWMMXt, because the iWMMXt
	 removes the FPE emulator, since it conflicts with its coprocessors.
	 For the most generic ARM support, we want the FPE emulator in place.  */
a269 21
    case bfd_mach_arm_iWMMXt:
      {
	extern int SWI_vector_installed;
	ARMword i;

	if (! SWI_vector_installed)
	  {
	    /* Intialise the hardware vectors to zero.  */
	    if (! SWI_vector_installed)
	      for (i = ARMul_ResetV; i <= ARMFIQV; i += 4)
		ARMul_WriteWord (state, i, 0);

	    /* ARM_WriteWord will have detected the write to the SWI vector,
	       but we want SWI_vector_installed to remain at 0 so that thumb
	       mode breakpoints will work.  */
	    SWI_vector_installed = 0;
	  }
      }
      ARMul_SelectProcessor (state, ARM_v5_Prop | ARM_v5e_Prop | ARM_XScale_Prop | ARM_iWMMXt_Prop);
      break;

a483 34
    case SIM_ARM_IWMMXT_COP0R0_REGNUM:
    case SIM_ARM_IWMMXT_COP0R1_REGNUM:
    case SIM_ARM_IWMMXT_COP0R2_REGNUM:
    case SIM_ARM_IWMMXT_COP0R3_REGNUM:
    case SIM_ARM_IWMMXT_COP0R4_REGNUM:
    case SIM_ARM_IWMMXT_COP0R5_REGNUM:
    case SIM_ARM_IWMMXT_COP0R6_REGNUM:
    case SIM_ARM_IWMMXT_COP0R7_REGNUM:
    case SIM_ARM_IWMMXT_COP0R8_REGNUM:
    case SIM_ARM_IWMMXT_COP0R9_REGNUM:
    case SIM_ARM_IWMMXT_COP0R10_REGNUM:
    case SIM_ARM_IWMMXT_COP0R11_REGNUM:
    case SIM_ARM_IWMMXT_COP0R12_REGNUM:
    case SIM_ARM_IWMMXT_COP0R13_REGNUM:
    case SIM_ARM_IWMMXT_COP0R14_REGNUM:
    case SIM_ARM_IWMMXT_COP0R15_REGNUM:
    case SIM_ARM_IWMMXT_COP1R0_REGNUM:
    case SIM_ARM_IWMMXT_COP1R1_REGNUM:
    case SIM_ARM_IWMMXT_COP1R2_REGNUM:
    case SIM_ARM_IWMMXT_COP1R3_REGNUM:
    case SIM_ARM_IWMMXT_COP1R4_REGNUM:
    case SIM_ARM_IWMMXT_COP1R5_REGNUM:
    case SIM_ARM_IWMMXT_COP1R6_REGNUM:
    case SIM_ARM_IWMMXT_COP1R7_REGNUM:
    case SIM_ARM_IWMMXT_COP1R8_REGNUM:
    case SIM_ARM_IWMMXT_COP1R9_REGNUM:
    case SIM_ARM_IWMMXT_COP1R10_REGNUM:
    case SIM_ARM_IWMMXT_COP1R11_REGNUM:
    case SIM_ARM_IWMMXT_COP1R12_REGNUM:
    case SIM_ARM_IWMMXT_COP1R13_REGNUM:
    case SIM_ARM_IWMMXT_COP1R14_REGNUM:
    case SIM_ARM_IWMMXT_COP1R15_REGNUM:
      return Store_Iwmmxt_Register (rn - SIM_ARM_IWMMXT_COP0R0_REGNUM, memory);

a562 34
    case SIM_ARM_IWMMXT_COP0R0_REGNUM:
    case SIM_ARM_IWMMXT_COP0R1_REGNUM:
    case SIM_ARM_IWMMXT_COP0R2_REGNUM:
    case SIM_ARM_IWMMXT_COP0R3_REGNUM:
    case SIM_ARM_IWMMXT_COP0R4_REGNUM:
    case SIM_ARM_IWMMXT_COP0R5_REGNUM:
    case SIM_ARM_IWMMXT_COP0R6_REGNUM:
    case SIM_ARM_IWMMXT_COP0R7_REGNUM:
    case SIM_ARM_IWMMXT_COP0R8_REGNUM:
    case SIM_ARM_IWMMXT_COP0R9_REGNUM:
    case SIM_ARM_IWMMXT_COP0R10_REGNUM:
    case SIM_ARM_IWMMXT_COP0R11_REGNUM:
    case SIM_ARM_IWMMXT_COP0R12_REGNUM:
    case SIM_ARM_IWMMXT_COP0R13_REGNUM:
    case SIM_ARM_IWMMXT_COP0R14_REGNUM:
    case SIM_ARM_IWMMXT_COP0R15_REGNUM:
    case SIM_ARM_IWMMXT_COP1R0_REGNUM:
    case SIM_ARM_IWMMXT_COP1R1_REGNUM:
    case SIM_ARM_IWMMXT_COP1R2_REGNUM:
    case SIM_ARM_IWMMXT_COP1R3_REGNUM:
    case SIM_ARM_IWMMXT_COP1R4_REGNUM:
    case SIM_ARM_IWMMXT_COP1R5_REGNUM:
    case SIM_ARM_IWMMXT_COP1R6_REGNUM:
    case SIM_ARM_IWMMXT_COP1R7_REGNUM:
    case SIM_ARM_IWMMXT_COP1R8_REGNUM:
    case SIM_ARM_IWMMXT_COP1R9_REGNUM:
    case SIM_ARM_IWMMXT_COP1R10_REGNUM:
    case SIM_ARM_IWMMXT_COP1R11_REGNUM:
    case SIM_ARM_IWMMXT_COP1R12_REGNUM:
    case SIM_ARM_IWMMXT_COP1R13_REGNUM:
    case SIM_ARM_IWMMXT_COP1R14_REGNUM:
    case SIM_ARM_IWMMXT_COP1R15_REGNUM:
      return Fetch_Iwmmxt_Register (rn - SIM_ARM_IWMMXT_COP0R0_REGNUM, memory);

a824 3
      else if (   state->EndCondition == RDIError_DataAbort
	       || state->EndCondition == RDIError_AddressException)
	*sigrc = SIGBUS;
@


1.24
log
@Index: arm/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* wrapper.c (sim_create_inferior, sim_open): Rename _bfd to bfd.

Index: common/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim-utils.h (sim_analyze_program, sim_load_file): Rename _bfd to bfd.
	* sim-hload.c (sim_load), sim-base.h (sim_state_base): Ditto.
	* nrun.c (main): Ditto.

Index: d10v/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: erc32/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interf.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: h8300/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* compile.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: h8500/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* compile.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: i960/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim-if.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: m32r/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim-if.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: m68hc11/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_prepare_for_program, sim_open)
	(sim_create_inferior): Rename _bfd to bfd.

Index: mcore/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: mips/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open):
	(sim_create_inferior):

Index: mn10200/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: mn10300/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior, sim_open)
	(sim_create_inferior): Rename _bfd to bfd.

Index: ppc/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim_calls.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: sh/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (init_dsp, sim_open, sim_create_inferior): Rename _bfd
	to bfd.

Index: v850/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: z8k/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* iface.c (sim_open, sim_create_inferior): Rename _bfd to bfd.
@
text
@d62 32
a105 1
      ARMul_CoProInit (state);
d270 4
d460 24
d538 24
@


1.23
log
@Add support for -m option.  Fix PR gdb/433.
@
text
@d207 1
a207 1
     struct _bfd * abfd;
d613 1
a613 1
     struct _bfd *abfd;
@


1.23.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a61 32
/* Cirrus DSP registers.

   We need to define these registers outside of maverick.c because
   maverick.c might not be linked in unless --target=arm9e-* in which
   case wrapper.c will not compile because it tries to access Cirrus
   registers.  This should all go away once we get the Cirrus and ARM
   Coprocessor to coexist in armcopro.c-- aldyh.  */

struct maverick_regs
{
  union
  {
    int i;
    float f;
  } upper;
  
  union
  {
    int i;
    float f;
  } lower;
};

union maverick_acc_regs
{
  long double ld;		/* Acc registers are 72-bits.  */
};

struct maverick_regs     DSPregs[16];
union maverick_acc_regs  DSPacc[4];
ARMword DSPsc;

d74 1
d207 1
a207 1
     struct bfd * abfd;
a234 3
      /* We choose the XScale rather than the iWMMXt, because the iWMMXt
	 removes the FPE emulator, since it conflicts with its coprocessors.
	 For the most generic ARM support, we want the FPE emulator in place.  */
a238 25
    case bfd_mach_arm_iWMMXt:
      {
	extern int SWI_vector_installed;
	ARMword i;

	if (! SWI_vector_installed)
	  {
	    /* Intialise the hardware vectors to zero.  */
	    if (! SWI_vector_installed)
	      for (i = ARMul_ResetV; i <= ARMFIQV; i += 4)
		ARMul_WriteWord (state, i, 0);

	    /* ARM_WriteWord will have detected the write to the SWI vector,
	       but we want SWI_vector_installed to remain at 0 so that thumb
	       mode breakpoints will work.  */
	    SWI_vector_installed = 0;
	  }
      }
      ARMul_SelectProcessor (state, ARM_v5_Prop | ARM_v5e_Prop | ARM_XScale_Prop | ARM_iWMMXt_Prop);
      break;

    case bfd_mach_arm_ep9312:
      ARMul_SelectProcessor (state, ARM_v4_Prop | ARM_ep9312_Prop);
      break;

a424 58
    case SIM_ARM_MAVERIC_COP0R0_REGNUM:
    case SIM_ARM_MAVERIC_COP0R1_REGNUM:
    case SIM_ARM_MAVERIC_COP0R2_REGNUM:
    case SIM_ARM_MAVERIC_COP0R3_REGNUM:
    case SIM_ARM_MAVERIC_COP0R4_REGNUM:
    case SIM_ARM_MAVERIC_COP0R5_REGNUM:
    case SIM_ARM_MAVERIC_COP0R6_REGNUM:
    case SIM_ARM_MAVERIC_COP0R7_REGNUM:
    case SIM_ARM_MAVERIC_COP0R8_REGNUM:
    case SIM_ARM_MAVERIC_COP0R9_REGNUM:
    case SIM_ARM_MAVERIC_COP0R10_REGNUM:
    case SIM_ARM_MAVERIC_COP0R11_REGNUM:
    case SIM_ARM_MAVERIC_COP0R12_REGNUM:
    case SIM_ARM_MAVERIC_COP0R13_REGNUM:
    case SIM_ARM_MAVERIC_COP0R14_REGNUM:
    case SIM_ARM_MAVERIC_COP0R15_REGNUM:
      memcpy (& DSPregs [rn - SIM_ARM_MAVERIC_COP0R0_REGNUM],
	      memory, sizeof (struct maverick_regs));
      return sizeof (struct maverick_regs);

    case SIM_ARM_MAVERIC_DSPSC_REGNUM:
      memcpy (&DSPsc, memory, sizeof DSPsc);
      return sizeof DSPsc;

    case SIM_ARM_IWMMXT_COP0R0_REGNUM:
    case SIM_ARM_IWMMXT_COP0R1_REGNUM:
    case SIM_ARM_IWMMXT_COP0R2_REGNUM:
    case SIM_ARM_IWMMXT_COP0R3_REGNUM:
    case SIM_ARM_IWMMXT_COP0R4_REGNUM:
    case SIM_ARM_IWMMXT_COP0R5_REGNUM:
    case SIM_ARM_IWMMXT_COP0R6_REGNUM:
    case SIM_ARM_IWMMXT_COP0R7_REGNUM:
    case SIM_ARM_IWMMXT_COP0R8_REGNUM:
    case SIM_ARM_IWMMXT_COP0R9_REGNUM:
    case SIM_ARM_IWMMXT_COP0R10_REGNUM:
    case SIM_ARM_IWMMXT_COP0R11_REGNUM:
    case SIM_ARM_IWMMXT_COP0R12_REGNUM:
    case SIM_ARM_IWMMXT_COP0R13_REGNUM:
    case SIM_ARM_IWMMXT_COP0R14_REGNUM:
    case SIM_ARM_IWMMXT_COP0R15_REGNUM:
    case SIM_ARM_IWMMXT_COP1R0_REGNUM:
    case SIM_ARM_IWMMXT_COP1R1_REGNUM:
    case SIM_ARM_IWMMXT_COP1R2_REGNUM:
    case SIM_ARM_IWMMXT_COP1R3_REGNUM:
    case SIM_ARM_IWMMXT_COP1R4_REGNUM:
    case SIM_ARM_IWMMXT_COP1R5_REGNUM:
    case SIM_ARM_IWMMXT_COP1R6_REGNUM:
    case SIM_ARM_IWMMXT_COP1R7_REGNUM:
    case SIM_ARM_IWMMXT_COP1R8_REGNUM:
    case SIM_ARM_IWMMXT_COP1R9_REGNUM:
    case SIM_ARM_IWMMXT_COP1R10_REGNUM:
    case SIM_ARM_IWMMXT_COP1R11_REGNUM:
    case SIM_ARM_IWMMXT_COP1R12_REGNUM:
    case SIM_ARM_IWMMXT_COP1R13_REGNUM:
    case SIM_ARM_IWMMXT_COP1R14_REGNUM:
    case SIM_ARM_IWMMXT_COP1R15_REGNUM:
      return Store_Iwmmxt_Register (rn - SIM_ARM_IWMMXT_COP0R0_REGNUM, memory);

a479 58
    case SIM_ARM_MAVERIC_COP0R0_REGNUM:
    case SIM_ARM_MAVERIC_COP0R1_REGNUM:
    case SIM_ARM_MAVERIC_COP0R2_REGNUM:
    case SIM_ARM_MAVERIC_COP0R3_REGNUM:
    case SIM_ARM_MAVERIC_COP0R4_REGNUM:
    case SIM_ARM_MAVERIC_COP0R5_REGNUM:
    case SIM_ARM_MAVERIC_COP0R6_REGNUM:
    case SIM_ARM_MAVERIC_COP0R7_REGNUM:
    case SIM_ARM_MAVERIC_COP0R8_REGNUM:
    case SIM_ARM_MAVERIC_COP0R9_REGNUM:
    case SIM_ARM_MAVERIC_COP0R10_REGNUM:
    case SIM_ARM_MAVERIC_COP0R11_REGNUM:
    case SIM_ARM_MAVERIC_COP0R12_REGNUM:
    case SIM_ARM_MAVERIC_COP0R13_REGNUM:
    case SIM_ARM_MAVERIC_COP0R14_REGNUM:
    case SIM_ARM_MAVERIC_COP0R15_REGNUM:
      memcpy (memory, & DSPregs [rn - SIM_ARM_MAVERIC_COP0R0_REGNUM],
	      sizeof (struct maverick_regs));
      return sizeof (struct maverick_regs);

    case SIM_ARM_MAVERIC_DSPSC_REGNUM:
      memcpy (memory, & DSPsc, sizeof DSPsc);
      return sizeof DSPsc;

    case SIM_ARM_IWMMXT_COP0R0_REGNUM:
    case SIM_ARM_IWMMXT_COP0R1_REGNUM:
    case SIM_ARM_IWMMXT_COP0R2_REGNUM:
    case SIM_ARM_IWMMXT_COP0R3_REGNUM:
    case SIM_ARM_IWMMXT_COP0R4_REGNUM:
    case SIM_ARM_IWMMXT_COP0R5_REGNUM:
    case SIM_ARM_IWMMXT_COP0R6_REGNUM:
    case SIM_ARM_IWMMXT_COP0R7_REGNUM:
    case SIM_ARM_IWMMXT_COP0R8_REGNUM:
    case SIM_ARM_IWMMXT_COP0R9_REGNUM:
    case SIM_ARM_IWMMXT_COP0R10_REGNUM:
    case SIM_ARM_IWMMXT_COP0R11_REGNUM:
    case SIM_ARM_IWMMXT_COP0R12_REGNUM:
    case SIM_ARM_IWMMXT_COP0R13_REGNUM:
    case SIM_ARM_IWMMXT_COP0R14_REGNUM:
    case SIM_ARM_IWMMXT_COP0R15_REGNUM:
    case SIM_ARM_IWMMXT_COP1R0_REGNUM:
    case SIM_ARM_IWMMXT_COP1R1_REGNUM:
    case SIM_ARM_IWMMXT_COP1R2_REGNUM:
    case SIM_ARM_IWMMXT_COP1R3_REGNUM:
    case SIM_ARM_IWMMXT_COP1R4_REGNUM:
    case SIM_ARM_IWMMXT_COP1R5_REGNUM:
    case SIM_ARM_IWMMXT_COP1R6_REGNUM:
    case SIM_ARM_IWMMXT_COP1R7_REGNUM:
    case SIM_ARM_IWMMXT_COP1R8_REGNUM:
    case SIM_ARM_IWMMXT_COP1R9_REGNUM:
    case SIM_ARM_IWMMXT_COP1R10_REGNUM:
    case SIM_ARM_IWMMXT_COP1R11_REGNUM:
    case SIM_ARM_IWMMXT_COP1R12_REGNUM:
    case SIM_ARM_IWMMXT_COP1R13_REGNUM:
    case SIM_ARM_IWMMXT_COP1R14_REGNUM:
    case SIM_ARM_IWMMXT_COP1R15_REGNUM:
      return Fetch_Iwmmxt_Register (rn - SIM_ARM_IWMMXT_COP0R0_REGNUM, memory);

d613 1
a613 1
     struct bfd *abfd;
a741 3
      else if (   state->EndCondition == RDIError_DataAbort
	       || state->EndCondition == RDIError_AddressException)
	*sigrc = SIGBUS;
@


1.22
log
@Add the file include/gdb/sim-arm.h defining an enum that specifies the
register numbering used by the GDB<->SIM interface.
@
text
@d52 1
a52 1
static int mem_size = (1 << 23);
d635 1
a635 1
      /* Scan for endian-ness switch.  */
d669 17
@


1.22.8.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@d52 1
a52 1
static int mem_size = (1 << 21);
d635 1
a635 1
      /* Scan for endian-ness and memory-size switches.  */
a668 17
	  }
	else if (argv[i][0] == '-' && argv[i][1] == 'm')
	  {
	    if (argv[i][2] != '\0')
	      sim_size (atoi (&argv[i][2]));
	    else if (argv[i + 1] != NULL)
	      {
		sim_size (atoi (argv[i + 1]));
		i++;
	      }
	    else
	      {
		sim_callback->printf_filtered (sim_callback,
					       "Missing argument to -m option\n");
		return NULL;
	      }
	      
@


1.22.8.2
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d207 1
a207 1
     struct bfd * abfd;
d613 1
a613 1
     struct bfd *abfd;
@


1.22.8.3
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a61 32
/* Cirrus DSP registers.

   We need to define these registers outside of maverick.c because
   maverick.c might not be linked in unless --target=arm9e-* in which
   case wrapper.c will not compile because it tries to access Cirrus
   registers.  This should all go away once we get the Cirrus and ARM
   Coprocessor to coexist in armcopro.c-- aldyh.  */

struct maverick_regs
{
  union
  {
    int i;
    float f;
  } upper;
  
  union
  {
    int i;
    float f;
  } lower;
};

union maverick_acc_regs
{
  long double ld;		/* Acc registers are 72-bits.  */
};

struct maverick_regs     DSPregs[16];
union maverick_acc_regs  DSPacc[4];
ARMword DSPsc;

d74 1
a234 3
      /* We choose the XScale rather than the iWMMXt, because the iWMMXt
	 removes the FPE emulator, since it conflicts with its coprocessors.
	 For the most generic ARM support, we want the FPE emulator in place.  */
a238 25
    case bfd_mach_arm_iWMMXt:
      {
	extern int SWI_vector_installed;
	ARMword i;

	if (! SWI_vector_installed)
	  {
	    /* Intialise the hardware vectors to zero.  */
	    if (! SWI_vector_installed)
	      for (i = ARMul_ResetV; i <= ARMFIQV; i += 4)
		ARMul_WriteWord (state, i, 0);

	    /* ARM_WriteWord will have detected the write to the SWI vector,
	       but we want SWI_vector_installed to remain at 0 so that thumb
	       mode breakpoints will work.  */
	    SWI_vector_installed = 0;
	  }
      }
      ARMul_SelectProcessor (state, ARM_v5_Prop | ARM_v5e_Prop | ARM_XScale_Prop | ARM_iWMMXt_Prop);
      break;

    case bfd_mach_arm_ep9312:
      ARMul_SelectProcessor (state, ARM_v4_Prop | ARM_ep9312_Prop);
      break;

a424 58
    case SIM_ARM_MAVERIC_COP0R0_REGNUM:
    case SIM_ARM_MAVERIC_COP0R1_REGNUM:
    case SIM_ARM_MAVERIC_COP0R2_REGNUM:
    case SIM_ARM_MAVERIC_COP0R3_REGNUM:
    case SIM_ARM_MAVERIC_COP0R4_REGNUM:
    case SIM_ARM_MAVERIC_COP0R5_REGNUM:
    case SIM_ARM_MAVERIC_COP0R6_REGNUM:
    case SIM_ARM_MAVERIC_COP0R7_REGNUM:
    case SIM_ARM_MAVERIC_COP0R8_REGNUM:
    case SIM_ARM_MAVERIC_COP0R9_REGNUM:
    case SIM_ARM_MAVERIC_COP0R10_REGNUM:
    case SIM_ARM_MAVERIC_COP0R11_REGNUM:
    case SIM_ARM_MAVERIC_COP0R12_REGNUM:
    case SIM_ARM_MAVERIC_COP0R13_REGNUM:
    case SIM_ARM_MAVERIC_COP0R14_REGNUM:
    case SIM_ARM_MAVERIC_COP0R15_REGNUM:
      memcpy (& DSPregs [rn - SIM_ARM_MAVERIC_COP0R0_REGNUM],
	      memory, sizeof (struct maverick_regs));
      return sizeof (struct maverick_regs);

    case SIM_ARM_MAVERIC_DSPSC_REGNUM:
      memcpy (&DSPsc, memory, sizeof DSPsc);
      return sizeof DSPsc;

    case SIM_ARM_IWMMXT_COP0R0_REGNUM:
    case SIM_ARM_IWMMXT_COP0R1_REGNUM:
    case SIM_ARM_IWMMXT_COP0R2_REGNUM:
    case SIM_ARM_IWMMXT_COP0R3_REGNUM:
    case SIM_ARM_IWMMXT_COP0R4_REGNUM:
    case SIM_ARM_IWMMXT_COP0R5_REGNUM:
    case SIM_ARM_IWMMXT_COP0R6_REGNUM:
    case SIM_ARM_IWMMXT_COP0R7_REGNUM:
    case SIM_ARM_IWMMXT_COP0R8_REGNUM:
    case SIM_ARM_IWMMXT_COP0R9_REGNUM:
    case SIM_ARM_IWMMXT_COP0R10_REGNUM:
    case SIM_ARM_IWMMXT_COP0R11_REGNUM:
    case SIM_ARM_IWMMXT_COP0R12_REGNUM:
    case SIM_ARM_IWMMXT_COP0R13_REGNUM:
    case SIM_ARM_IWMMXT_COP0R14_REGNUM:
    case SIM_ARM_IWMMXT_COP0R15_REGNUM:
    case SIM_ARM_IWMMXT_COP1R0_REGNUM:
    case SIM_ARM_IWMMXT_COP1R1_REGNUM:
    case SIM_ARM_IWMMXT_COP1R2_REGNUM:
    case SIM_ARM_IWMMXT_COP1R3_REGNUM:
    case SIM_ARM_IWMMXT_COP1R4_REGNUM:
    case SIM_ARM_IWMMXT_COP1R5_REGNUM:
    case SIM_ARM_IWMMXT_COP1R6_REGNUM:
    case SIM_ARM_IWMMXT_COP1R7_REGNUM:
    case SIM_ARM_IWMMXT_COP1R8_REGNUM:
    case SIM_ARM_IWMMXT_COP1R9_REGNUM:
    case SIM_ARM_IWMMXT_COP1R10_REGNUM:
    case SIM_ARM_IWMMXT_COP1R11_REGNUM:
    case SIM_ARM_IWMMXT_COP1R12_REGNUM:
    case SIM_ARM_IWMMXT_COP1R13_REGNUM:
    case SIM_ARM_IWMMXT_COP1R14_REGNUM:
    case SIM_ARM_IWMMXT_COP1R15_REGNUM:
      return Store_Iwmmxt_Register (rn - SIM_ARM_IWMMXT_COP0R0_REGNUM, memory);

a479 58
    case SIM_ARM_MAVERIC_COP0R0_REGNUM:
    case SIM_ARM_MAVERIC_COP0R1_REGNUM:
    case SIM_ARM_MAVERIC_COP0R2_REGNUM:
    case SIM_ARM_MAVERIC_COP0R3_REGNUM:
    case SIM_ARM_MAVERIC_COP0R4_REGNUM:
    case SIM_ARM_MAVERIC_COP0R5_REGNUM:
    case SIM_ARM_MAVERIC_COP0R6_REGNUM:
    case SIM_ARM_MAVERIC_COP0R7_REGNUM:
    case SIM_ARM_MAVERIC_COP0R8_REGNUM:
    case SIM_ARM_MAVERIC_COP0R9_REGNUM:
    case SIM_ARM_MAVERIC_COP0R10_REGNUM:
    case SIM_ARM_MAVERIC_COP0R11_REGNUM:
    case SIM_ARM_MAVERIC_COP0R12_REGNUM:
    case SIM_ARM_MAVERIC_COP0R13_REGNUM:
    case SIM_ARM_MAVERIC_COP0R14_REGNUM:
    case SIM_ARM_MAVERIC_COP0R15_REGNUM:
      memcpy (memory, & DSPregs [rn - SIM_ARM_MAVERIC_COP0R0_REGNUM],
	      sizeof (struct maverick_regs));
      return sizeof (struct maverick_regs);

    case SIM_ARM_MAVERIC_DSPSC_REGNUM:
      memcpy (memory, & DSPsc, sizeof DSPsc);
      return sizeof DSPsc;

    case SIM_ARM_IWMMXT_COP0R0_REGNUM:
    case SIM_ARM_IWMMXT_COP0R1_REGNUM:
    case SIM_ARM_IWMMXT_COP0R2_REGNUM:
    case SIM_ARM_IWMMXT_COP0R3_REGNUM:
    case SIM_ARM_IWMMXT_COP0R4_REGNUM:
    case SIM_ARM_IWMMXT_COP0R5_REGNUM:
    case SIM_ARM_IWMMXT_COP0R6_REGNUM:
    case SIM_ARM_IWMMXT_COP0R7_REGNUM:
    case SIM_ARM_IWMMXT_COP0R8_REGNUM:
    case SIM_ARM_IWMMXT_COP0R9_REGNUM:
    case SIM_ARM_IWMMXT_COP0R10_REGNUM:
    case SIM_ARM_IWMMXT_COP0R11_REGNUM:
    case SIM_ARM_IWMMXT_COP0R12_REGNUM:
    case SIM_ARM_IWMMXT_COP0R13_REGNUM:
    case SIM_ARM_IWMMXT_COP0R14_REGNUM:
    case SIM_ARM_IWMMXT_COP0R15_REGNUM:
    case SIM_ARM_IWMMXT_COP1R0_REGNUM:
    case SIM_ARM_IWMMXT_COP1R1_REGNUM:
    case SIM_ARM_IWMMXT_COP1R2_REGNUM:
    case SIM_ARM_IWMMXT_COP1R3_REGNUM:
    case SIM_ARM_IWMMXT_COP1R4_REGNUM:
    case SIM_ARM_IWMMXT_COP1R5_REGNUM:
    case SIM_ARM_IWMMXT_COP1R6_REGNUM:
    case SIM_ARM_IWMMXT_COP1R7_REGNUM:
    case SIM_ARM_IWMMXT_COP1R8_REGNUM:
    case SIM_ARM_IWMMXT_COP1R9_REGNUM:
    case SIM_ARM_IWMMXT_COP1R10_REGNUM:
    case SIM_ARM_IWMMXT_COP1R11_REGNUM:
    case SIM_ARM_IWMMXT_COP1R12_REGNUM:
    case SIM_ARM_IWMMXT_COP1R13_REGNUM:
    case SIM_ARM_IWMMXT_COP1R14_REGNUM:
    case SIM_ARM_IWMMXT_COP1R15_REGNUM:
      return Fetch_Iwmmxt_Register (rn - SIM_ARM_IWMMXT_COP0R0_REGNUM, memory);

a741 3
      else if (   state->EndCondition == RDIError_DataAbort
	       || state->EndCondition == RDIError_AddressException)
	*sigrc = SIGBUS;
@


1.21
log
@Move include/callback.h and include/remote-sim.h to include/gdb/.
Update accordingly.
@
text
@d39 1
d390 1
a390 1
  if (rn == 25)
d392 29
d423 4
d428 1
a428 2
  else
    ARMul_SetReg (state, state->Mode, rn, frommem (state, memory));
d443 40
a482 8
  if (rn < 16)
    regval = ARMul_GetReg (state, state->Mode, rn);
  else if (rn == 25)
    /* FIXME: use PS_REGNUM from gdb/config/arm/tm-arm.h.  */
    regval = ARMul_GetCPSR (state);
  else
    /* FIXME: should report an error.  */
    regval = 0;
@


1.20
log
@Only perform access checks if 'check' is set.
Report unknown machine numbers.
Formatting tidy ups.
@
text
@d31 2
a32 2
#include "callback.h"
#include "remote-sim.h"
@


1.20.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d31 2
a32 2
#include "gdb/callback.h"
#include "gdb/remote-sim.h"
a38 1
#include "gdb/sim-arm.h"
d389 1
a389 1
  switch ((enum sim_arm_regs) rn)
a390 29
    case SIM_ARM_R0_REGNUM:
    case SIM_ARM_R1_REGNUM:
    case SIM_ARM_R2_REGNUM:
    case SIM_ARM_R3_REGNUM:
    case SIM_ARM_R4_REGNUM:
    case SIM_ARM_R5_REGNUM:
    case SIM_ARM_R6_REGNUM:
    case SIM_ARM_R7_REGNUM:
    case SIM_ARM_R8_REGNUM:
    case SIM_ARM_R9_REGNUM:
    case SIM_ARM_R10_REGNUM:
    case SIM_ARM_R11_REGNUM:
    case SIM_ARM_R12_REGNUM:
    case SIM_ARM_R13_REGNUM:
    case SIM_ARM_R14_REGNUM:
    case SIM_ARM_R15_REGNUM: /* PC */
    case SIM_ARM_FP0_REGNUM:
    case SIM_ARM_FP1_REGNUM:
    case SIM_ARM_FP2_REGNUM:
    case SIM_ARM_FP3_REGNUM:
    case SIM_ARM_FP4_REGNUM:
    case SIM_ARM_FP5_REGNUM:
    case SIM_ARM_FP6_REGNUM:
    case SIM_ARM_FP7_REGNUM:
    case SIM_ARM_FPS_REGNUM:
      ARMul_SetReg (state, state->Mode, rn, frommem (state, memory));
      break;

    case SIM_ARM_PS_REGNUM:
a392 4
      break;

    default:
      return 0;
d394 2
a395 1

d410 8
a417 40
  switch ((enum sim_arm_regs) rn)
    {
    case SIM_ARM_R0_REGNUM:
    case SIM_ARM_R1_REGNUM:
    case SIM_ARM_R2_REGNUM:
    case SIM_ARM_R3_REGNUM:
    case SIM_ARM_R4_REGNUM:
    case SIM_ARM_R5_REGNUM:
    case SIM_ARM_R6_REGNUM:
    case SIM_ARM_R7_REGNUM:
    case SIM_ARM_R8_REGNUM:
    case SIM_ARM_R9_REGNUM:
    case SIM_ARM_R10_REGNUM:
    case SIM_ARM_R11_REGNUM:
    case SIM_ARM_R12_REGNUM:
    case SIM_ARM_R13_REGNUM:
    case SIM_ARM_R14_REGNUM:
    case SIM_ARM_R15_REGNUM: /* PC */
      regval = ARMul_GetReg (state, state->Mode, rn);
      break;

    case SIM_ARM_FP0_REGNUM:
    case SIM_ARM_FP1_REGNUM:
    case SIM_ARM_FP2_REGNUM:
    case SIM_ARM_FP3_REGNUM:
    case SIM_ARM_FP4_REGNUM:
    case SIM_ARM_FP5_REGNUM:
    case SIM_ARM_FP6_REGNUM:
    case SIM_ARM_FP7_REGNUM:
    case SIM_ARM_FPS_REGNUM:
      memset (memory, 0, length);
      return 0;

    case SIM_ARM_PS_REGNUM:
      regval = ARMul_GetCPSR (state);
      break;

    default:
      return 0;
    }
@


1.20.2.2
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d52 1
a52 1
static int mem_size = (1 << 21);
d635 1
a635 1
      /* Scan for endian-ness and memory-size switches.  */
a668 17
	  }
	else if (argv[i][0] == '-' && argv[i][1] == 'm')
	  {
	    if (argv[i][2] != '\0')
	      sim_size (atoi (&argv[i][2]));
	    else if (argv[i + 1] != NULL)
	      {
		sim_size (atoi (argv[i + 1]));
		i++;
	      }
	    else
	      {
		sim_callback->printf_filtered (sim_callback,
					       "Missing argument to -m option\n");
		return NULL;
	      }
	      
@


1.19
log
@Add support for target specific command line switches to old-style simualtors.
Make use of this support in the ARM simulator to add a --swi-support= switch
to select whcih SWI protocols to emulate.
@
text
@d226 2
a227 1
	 "Unknown machine type; please update sim_create_inferior.\n");
d392 1
a392 1
      ARMul_CPSRAltered (state);	     
@


1.18
log
@Increase default memory size to 8MB.
@
text
@d38 1
d430 113
d555 4
@


1.18.4.1
log
@merge from trunk
@
text
@d31 2
a32 2
#include "gdb/callback.h"
#include "gdb/remote-sim.h"
a37 2
#include "run-sim.h"
#include "gdb/sim-arm.h"
d225 1
a225 2
	 "Unknown machine type '%d'; please update sim_create_inferior.\n",
	 mach);
d387 1
a387 1
  switch ((enum sim_arm_regs) rn)
a388 29
    case SIM_ARM_R0_REGNUM:
    case SIM_ARM_R1_REGNUM:
    case SIM_ARM_R2_REGNUM:
    case SIM_ARM_R3_REGNUM:
    case SIM_ARM_R4_REGNUM:
    case SIM_ARM_R5_REGNUM:
    case SIM_ARM_R6_REGNUM:
    case SIM_ARM_R7_REGNUM:
    case SIM_ARM_R8_REGNUM:
    case SIM_ARM_R9_REGNUM:
    case SIM_ARM_R10_REGNUM:
    case SIM_ARM_R11_REGNUM:
    case SIM_ARM_R12_REGNUM:
    case SIM_ARM_R13_REGNUM:
    case SIM_ARM_R14_REGNUM:
    case SIM_ARM_R15_REGNUM: /* PC */
    case SIM_ARM_FP0_REGNUM:
    case SIM_ARM_FP1_REGNUM:
    case SIM_ARM_FP2_REGNUM:
    case SIM_ARM_FP3_REGNUM:
    case SIM_ARM_FP4_REGNUM:
    case SIM_ARM_FP5_REGNUM:
    case SIM_ARM_FP6_REGNUM:
    case SIM_ARM_FP7_REGNUM:
    case SIM_ARM_FPS_REGNUM:
      ARMul_SetReg (state, state->Mode, rn, frommem (state, memory));
      break;

    case SIM_ARM_PS_REGNUM:
d390 1
a390 5
      ARMul_CPSRAltered (state);
      break;

    default:
      return 0;
d392 2
a393 1

d408 8
a415 40
  switch ((enum sim_arm_regs) rn)
    {
    case SIM_ARM_R0_REGNUM:
    case SIM_ARM_R1_REGNUM:
    case SIM_ARM_R2_REGNUM:
    case SIM_ARM_R3_REGNUM:
    case SIM_ARM_R4_REGNUM:
    case SIM_ARM_R5_REGNUM:
    case SIM_ARM_R6_REGNUM:
    case SIM_ARM_R7_REGNUM:
    case SIM_ARM_R8_REGNUM:
    case SIM_ARM_R9_REGNUM:
    case SIM_ARM_R10_REGNUM:
    case SIM_ARM_R11_REGNUM:
    case SIM_ARM_R12_REGNUM:
    case SIM_ARM_R13_REGNUM:
    case SIM_ARM_R14_REGNUM:
    case SIM_ARM_R15_REGNUM: /* PC */
      regval = ARMul_GetReg (state, state->Mode, rn);
      break;

    case SIM_ARM_FP0_REGNUM:
    case SIM_ARM_FP1_REGNUM:
    case SIM_ARM_FP2_REGNUM:
    case SIM_ARM_FP3_REGNUM:
    case SIM_ARM_FP4_REGNUM:
    case SIM_ARM_FP5_REGNUM:
    case SIM_ARM_FP6_REGNUM:
    case SIM_ARM_FP7_REGNUM:
    case SIM_ARM_FPS_REGNUM:
      memset (memory, 0, length);
      return 0;

    case SIM_ARM_PS_REGNUM:
      regval = ARMul_GetCPSR (state);
      break;

    default:
      return 0;
    }
a428 113
#ifdef SIM_TARGET_SWITCHES

static void sim_target_parse_arg_array PARAMS ((char **));

typedef struct
{
  char * 	swi_option;
  unsigned int	swi_mask;
} swi_options;

#define SWI_SWITCH	"--swi-support"

static swi_options options[] =
  {
    { "none",    0 },
    { "demon",   SWI_MASK_DEMON },
    { "angel",   SWI_MASK_ANGEL },
    { "redboot", SWI_MASK_REDBOOT },
    { "all",     -1 },
    { "NONE",    0 },
    { "DEMON",   SWI_MASK_DEMON },
    { "ANGEL",   SWI_MASK_ANGEL },
    { "REDBOOT", SWI_MASK_REDBOOT },
    { "ALL",     -1 }
  };


int
sim_target_parse_command_line (argc, argv)
     int argc;
     char ** argv;
{
  int i;

  for (i = 1; i < argc; i++)
    {
      char * ptr = argv[i];
      int arg;

      if ((ptr == NULL) || (* ptr != '-'))
	break;

      if (strncmp (ptr, SWI_SWITCH, sizeof SWI_SWITCH - 1) != 0)
	continue;

      if (ptr[sizeof SWI_SWITCH - 1] == 0)
	{
	  /* Remove this option from the argv array.  */
	  for (arg = i; arg < argc; arg ++)
	    argv[arg] = argv[arg + 1];
	  argc --;
	  
	  ptr = argv[i];
	}
      else
	ptr += sizeof SWI_SWITCH;

      swi_mask = 0;
      
      while (* ptr)
	{
	  int i;

	  for (i = sizeof options / sizeof options[0]; i--;)
	    if (strncmp (ptr, options[i].swi_option,
			 strlen (options[i].swi_option)) == 0)
	      {
		swi_mask |= options[i].swi_mask;
		ptr += strlen (options[i].swi_option);

		if (* ptr == ',')
		  ++ ptr;

		break;
	      }

	  if (i < 0)
	    break;
	}

      if (* ptr != 0)
	fprintf (stderr, "Ignoring swi options: %s\n", ptr);
      
      /* Remove this option from the argv array.  */
      for (arg = i; arg < argc; arg ++)
	argv[arg] = argv[arg + 1];
      argc --;
      i --;
    }
  return argc;
}

static void
sim_target_parse_arg_array (argv)
     char ** argv;
{
  int i;

  for (i = 0; argv[i]; i++)
    ;

  return (void) sim_target_parse_command_line (i, argv);
}

void
sim_target_display_usage ()
{
  fprintf (stderr, "%s=<list>  Comma seperated list of SWI protocols to supoport.\n\
                This list can contain: NONE, DEMON, ANGEL, REDBOOT and/or ALL.\n",
	   SWI_SWITCH);
}
#endif

a440 4
#ifdef SIM_TARGET_SWITCHES
  sim_target_parse_arg_array (argv);
#endif
  
@


1.17
log
@Modify previous patch so that it is only triggered for COFF format executables.
@
text
@d50 1
a50 1
static int mem_size = (1 << 21);
@


1.16
log
@If a v5 architecture is detected, assume it might be an XScale binary, since
there is no way to distinguish between    the two in the COFF file format.
@
text
@d237 12
a248 8
      /* This is a special case in order to support COFF based ARM toolchains.
	 The COFF header does not have enough room to store all the different
	 kinds of ARM cpu, so the XScale, v5T and v5TE architectures all default
	 to v5.  (See coff_set_flags() in bdf/coffcode.h).  So if we see a v5
	 machine type here, we assume it could be any of the above architectures
	 and so select the most feature-full.  */
      ARMul_SelectProcessor (state, ARM_v5_Prop | ARM_v5e_Prop | ARM_XScale_Prop);
      break;
@


1.15
log
@General format tidy ups
@
text
@d237 9
@


1.14
log
@Fix bug detected by GDB testsuite - when fetching registers more than 4
bytes wide return 0 for the other bytes.
@
text
@d2 2
a3 1
   Copyright (C) 1995, 1996, 1997, 2000, 2001 Free Software Foundation, Inc.
d5 1
a5 1
This file is part of ARM SIM.
d7 14
a20 13
GNU CC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU CC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d22 2
a23 2
/* This file provides the interface between the simulator and run.c and gdb
   (when the simulator is linked with gdb).
d37 1
d102 3
a104 1
ARMul_ConsolePrint (ARMul_State * state, const char *format, ...)
d117 4
a120 1
ARMul_Debug (ARMul_State * state ATTRIBUTE_UNUSED, ARMword pc ATTRIBUTE_UNUSED, ARMword instr ATTRIBUTE_UNUSED)
d129 1
a129 1
     unsigned char *buffer;
d146 1
a146 1
     unsigned char *buffer;
d152 1
d163 3
a165 2
  (*sim_callback->printf_filtered) (sim_callback,
				    "This simulator does not support tracing\n");
a194 1
#if 1				/* JGS */
a195 1
#endif
d205 3
a207 3
     struct _bfd *abfd;
     char **argv;
     char **env;
d223 3
a225 2
      (*sim_callback->printf_filtered) (sim_callback,
					"Unknown machine type; please update sim_create_inferior.\n");
a329 1

d336 2
a337 4
    {
      return (memory[0] << 24)
	| (memory[1] << 16) | (memory[2] << 8) | (memory[3] << 0);
    }
d339 2
a340 4
    {
      return (memory[3] << 24)
	| (memory[2] << 16) | (memory[1] << 8) | (memory[0] << 0);
    }
a342 1

d397 2
a398 1
  else if (rn == 25)		/* FIXME: use PS_REGNUM from gdb/config/arm/tm-arm.h */
d401 2
a402 1
    regval = 0;			/* FIXME: should report an error */
d483 2
a484 1
  if (myname) free (myname);
a494 1
  extern bfd *sim_load_file ();	/* ??? Don't know where this should live.  */
d538 3
a540 2
  (*sim_callback->printf_filtered) (sim_callback,
				    "This simulator does not accept any commands.\n");
a541 1

@


1.13
log
@Add support for disabling alignment checks when performing GDB interface
calls or SWI emulaiton routines.  (Alignment checking code has not yet been
contributed).
@
text
@d223 4
a235 4
    case bfd_mach_arm_XScale:
      ARMul_SelectProcessor (state, ARM_v5_Prop | ARM_v5e_Prop | ARM_XScale_Prop);
      break;

d398 10
a407 1
  tomem (state, memory, regval);
@


1.12
log
@Reset processor into ARM mode for any machine type except the early ARMs.
@
text
@d2 1
a2 1
   Copyright (C) 1995, 1996, 1997, 2000 Free Software Foundation, Inc.
d129 1
a129 1
    ARMul_WriteByte (state, addr + i, buffer[i]);
d142 1
d145 2
a146 3
    {
      buffer[i] = ARMul_ReadByte (state, addr + i);
    }
@


1.11
log
@Detect installation of SWI vector by running program as well as loading program.
@
text
@d252 4
a255 1
  if (mach > 3)
d259 2
a260 2
	 executed in THUMB mode. */
      ARMul_SetCPSR (state, USER32MODE);
d265 4
a268 5
      /*
         ** Set up the command line (by laboriously stringing together the
         ** environment carefully picked apart by our caller...)
       */
      /* Free any old stuff */
d275 1
a275 1
      /* See how much we need */
d279 1
a279 1
      /* allocate it... */
d285 1
d296 1
a296 1
      /* Now see if there's a MEMSIZE spec in the environment */
d303 1
a303 1
	      /* Set up memory limit */
@


1.10
log
@Add support for ARM's v5TE architecture and Intel's XScale extenstions
@
text
@a116 2
int SWI_vector_installed = FALSE;

a126 3

  if ((addr <= 0x8) && ((addr + size) >= 0x8))
    SWI_vector_installed = TRUE;
@


1.9
log
@Replace StrongARM property with v4 and v5 properties.
@
text
@d117 2
d130 3
d224 1
a224 1
    case 0: /* arm */
d226 14
a239 3
	 explicitly select a processor capable of supporting all ARM
	 32bit mode. */
      /* fall through */
d241 3
a243 12
    case 5: /* armv4 */
    case 6: /* armv4t */
    case 7: /* armv5 */
    case 8: /* armv5t */
      if (mach == 7 || mach == 8)
	ARMul_SelectProcessor (state, ARM_v5_Prop);
      else
	ARMul_SelectProcessor (state, ARM_v4_Prop);
      /* Reset mode to ARM.  A gdb user may rerun a program that had entered
	 THUMB mode from the start and cause the ARM-mode startup code to be
	 executed in THUMB mode. */
      ARMul_SetCPSR (state, USER32MODE);
d246 2
a247 2
    case 3: /* armv3 */
    case 4: /* armv3m */
d251 2
a252 2
    case 1: /* armv2 */
    case 2: /* armv2a */
d257 8
d372 1
d393 1
@


1.8
log
@2000-07-14  Fernando Nasser <fnasser@@cygnus.com>

        * wrapper.c (sim_create_inferior): Fix typo in the previous patch.
@
text
@d125 1
d127 1
d129 2
a130 3
    {
      ARMul_WriteByte (state, addr + i, buffer[i]);
    }
d212 38
a249 34
  switch (mach) {
  default:
    (*sim_callback->printf_filtered) (sim_callback,
				      "Unknown machine type; please update sim_create_inferior.\n");
    /* fall through */

  case 0: /* arm */
    /* We wouldn't set the machine type with earlier toolchains, so we
       explicitly select a processor capable of supporting all ARM
       32bit mode. */
    /* fall through */

  case 5: /* armv4 */
  case 6: /* armv4t */
  case 7: /* armv5 */
  case 8: /* armv5t */
    ARMul_SelectProcessor (state, STRONGARM);
    /* Reset mode to ARM.  A gdb user may rerun a program that had entered
       THUMB mode from the start and cause the ARM-mode startup code to be
       executed in THUMB mode. */
    ARMul_SetCPSR (state, USER32MODE);
    break;

  case 3: /* armv3 */
  case 4: /* armv3m */
    ARMul_SelectProcessor (state, ARM600);
    break;
    
  case 1: /* armv2 */
  case 2: /* armv2a */
    ARMul_SelectProcessor (state, ARM2);
    break;
  }
    
@


1.7
log
@2000-07-14  Fernando Nasser <fnasser@@cygnus.com>

        * wrapper.c (sim_create_inferior): Reset mode to ARM when creating a
        new inferior.
@
text
@d231 1
a231 1
    ARMul_SetCPSR (state, THUMB2MODE);
@


1.6
log
@* armdefs.h (struct ARMul_State): Add is_StrongARM.
(ARM_Strong_Prop, STRONGARM): Define.
* arminit.c (ARMul_NewState): Reset is_StrongARM.
(ARMul_SelectProcessor): Set is_StrongARM.
* wrapper.c (sim_create_inferior): Use bfd machine type to
determine processor type to emulate.
* armemu.h (BUSUSEDINCPCS, BUSUSEDINCPCN): Don't increment PC
when emulating StrongARM.
@
text
@d228 4
@


1.5
log
@Add support for v4 SystemMode.
@
text
@d2 1
a2 1
   Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.
d201 1
d209 1
a209 5
  /* We explicitly select a processor capable of supporting the ARM
     32bit mode.  JGS  */
  ARMul_SelectProcessor (state, ARM600);
  /* And then we force the simulated CPU into the 32bit User mode.  */
  ARMul_SetCPSR (state, USER32MODE);
d211 30
@


1.4
log
@Add special case handling when GDB set CPSR register
@
text
@a207 1
#if 1				/* JGS */
d209 1
a209 2
     32bit mode, and then we force the simulated CPU into the 32bit
     User mode: */
d211 1
a212 1
#endif
d360 1
a360 1
  myname = xstrdup (argv[0]);
@


1.3
log
@* memory corruption fix

Wed Mar 22 15:24:21 2000  glen mccready  <gkm@@pobox.com>

	* wrapper.c (sim_open,sim_close): Copy into myname, free myname.
@
text
@d323 7
a329 1
  ARMul_SetReg (state, state->Mode, rn, frommem (state, memory));
@


1.2
log
@Fix compile time warning messages.
@
text
@d355 2
a356 1
  myname = argv[0];
d414 2
a415 1
  /* nothing to do */
@


1.1
log
@Initial revision
@
text
@d26 1
d34 1
d55 3
a57 1
static void 
d64 1
a64 1
      ARMul_EmulateInit();
d67 3
a69 3
      ARMul_MemoryInit(state, mem_size);
      ARMul_OSInit(state);
      ARMul_CoProInit(state); 
d88 1
a88 1
   Must be called before initializing simulator.  */   
d91 1
a91 1
void 
d98 2
a99 2
void 
ARMul_ConsolePrint (ARMul_State * state, const char *format,...)
d111 2
a112 2
ARMword 
ARMul_Debug (ARMul_State * state, ARMword pc, ARMword instr)
d114 1
a114 1

d119 1
a119 1
     SIM_DESC sd;
d128 1
a128 1
      ARMul_WriteByte (state, addr+i, buffer[i]);
d135 1
a135 1
     SIM_DESC sd;
d151 4
a154 3
     SIM_DESC sd;
{
  (*sim_callback->printf_filtered) (sim_callback, "This simulator does not support tracing\n");
d160 1
a160 1
     SIM_DESC sd;
d162 3
a164 1
  return 0;
d169 3
a171 2
     SIM_DESC sd;
     int step, siggnal;
d174 1
d184 2
a185 2
#if 1 /* JGS */
      state->NextInstr = RESUME; /* treat as PC change */
d195 1
a195 1
     SIM_DESC sd;
d200 1
a200 1
  int argvlen=0;
d206 1
a206 1
    ARMul_SetPC (state, 0); /* ??? */
d208 1
a208 1
#if 1 /* JGS */
d212 2
a213 2
  ARMul_SelectProcessor(state, ARM600);
  ARMul_SetCPSR(state, USER32MODE);
d219 3
a221 3
      ** Set up the command line (by laboriously stringing together the
      ** environment carefully picked apart by our caller...)
      */
d225 1
a225 1
	  free(state->CommandLine);
d228 1
a228 1
      
d231 2
a232 2
	argvlen += strlen(*arg)+1;
      
d234 1
a234 1
      state->CommandLine = malloc(argvlen+1);
d238 1
a238 1
	  state->CommandLine[0]='\0';
d241 2
a242 2
	      strcat(state->CommandLine, *arg);
	      strcat(state->CommandLine, " ");
d252 1
a252 1
	  if (strncmp(*env, "MEMSIZE=", sizeof("MEMSIZE=")-1)==0)
a253 1
	      unsigned long top_of_memory;
d255 1
a255 1
	      
d257 2
a258 1
	      state->MemSize = strtoul(*env + sizeof("MEMSIZE=")-1, &end_of_num, 0);
d269 2
a270 2
     SIM_DESC sd;
     int verbose;
d275 1
a275 1
static int 
d283 1
a283 3
	| (memory[1] << 16)
	| (memory[2] << 8)
	| (memory[3] << 0);
d288 1
a288 3
	| (memory[2] << 16)
	| (memory[1] << 8)
	| (memory[0] << 0);
d294 1
a294 1
tomem (state, memory,  val)
d317 1
a317 1
     SIM_DESC sd;
d320 1
a320 1
     int length;
d323 1
a323 1
  ARMul_SetReg(state, state->Mode, rn, frommem (state, memory));
d329 1
a329 1
     SIM_DESC sd;
d332 1
a332 1
     int length;
d338 3
a340 3
    regval = ARMul_GetReg(state, state->Mode, rn);
  else if (rn == 25)	/* FIXME: use PS_REGNUM from gdb/config/arm/tm-arm.h */
    regval = ARMul_GetCPSR(state);
d342 1
a342 1
    regval = 0;		/* FIXME: should report an error */
d357 1
a357 1
  
d367 1
a367 1
      
d370 33
a402 33
      if (argv[i][0] == '-' && argv[i][1] == 'E')
        {
          char c;
          
          if ((c = argv[i][2]) == 0)
            {
              ++i;
              c = argv[i][0];
            }

          switch (c)
            {
            case 0:
              sim_callback->printf_filtered
                (sim_callback, "No argument to -E option provided\n");
              break;

            case 'b':
            case 'B':
              big_endian = 1;
              break;

            case 'l':
            case 'L':
              big_endian = 0;
              break;

            default:
              sim_callback->printf_filtered
                (sim_callback, "Unrecognised argument to -E option\n");
              break;
            }
        }
d410 2
a411 2
     SIM_DESC sd;
     int quitting;
d421 1
a421 1
     int from_tty;
d423 1
a423 1
  extern bfd *sim_load_file (); /* ??? Don't know where this should live.  */
d427 1
a427 2
			    sim_kind == SIM_OPEN_DEBUG,
			    0, sim_write);
d438 1
a438 1
     SIM_DESC sd;
d442 6
a447 1
  if (state->EndCondition == 0)
d464 5
a468 4
     SIM_DESC sd;
     char *cmd;
{
  (*sim_callback->printf_filtered) (sim_callback, "This simulator does not accept any commands.\n");
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a52 2
int stop_simulator;

d157 1
a157 3
  state->Emulate = STOP;
  stop_simulator = 1;
  return 1;
a165 1
  stop_simulator = 0;
d438 1
a438 6
  if (stop_simulator)
    {
      *reason = sim_stopped;
      *sigrc = SIGINT;
    }
  else if (state->EndCondition == 0)
@


1.1.1.3
log
@import gdb-2000-02-04 snapshot
@
text
@d55 1
a55 1
static void
d62 1
a62 1
      ARMul_EmulateInit ();
d65 3
a67 3
      ARMul_MemoryInit (state, mem_size);
      ARMul_OSInit (state);
      ARMul_CoProInit (state);
d86 1
a86 1
   Must be called before initializing simulator.  */
d89 1
a89 1
void
d96 2
a97 2
void
ARMul_ConsolePrint (ARMul_State * state, const char *format, ...)
d109 2
a110 1
ARMword ARMul_Debug (ARMul_State * state, ARMword pc, ARMword instr)
d126 1
a126 1
      ARMul_WriteByte (state, addr + i, buffer[i]);
d150 2
a151 3
{  
  (*sim_callback->printf_filtered) (sim_callback,
				    "This simulator does not support tracing\n");
d180 2
a181 2
#if 1				/* JGS */
      state->NextInstr = RESUME;	/* treat as PC change */
d196 1
a196 1
  int argvlen = 0;
d202 1
a202 1
    ARMul_SetPC (state, 0);	/* ??? */
d204 1
a204 1
#if 1				/* JGS */
d208 2
a209 2
  ARMul_SelectProcessor (state, ARM600);
  ARMul_SetCPSR (state, USER32MODE);
d215 3
a217 3
         ** Set up the command line (by laboriously stringing together the
         ** environment carefully picked apart by our caller...)
       */
d221 1
a221 1
	  free (state->CommandLine);
d224 1
a224 1

d227 2
a228 2
	argvlen += strlen (*arg) + 1;

d230 1
a230 1
      state->CommandLine = malloc (argvlen + 1);
d234 1
a234 1
	  state->CommandLine[0] = '\0';
d237 2
a238 2
	      strcat (state->CommandLine, *arg);
	      strcat (state->CommandLine, " ");
d248 1
a248 1
	  if (strncmp (*env, "MEMSIZE=", sizeof ("MEMSIZE=") - 1) == 0)
d252 1
a252 1

d254 1
a254 2
	      state->MemSize =
		strtoul (*env + sizeof ("MEMSIZE=") - 1, &end_of_num, 0);
d271 1
a271 1
static int
d279 3
a281 1
	| (memory[1] << 16) | (memory[2] << 8) | (memory[3] << 0);
d286 3
a288 1
	| (memory[2] << 16) | (memory[1] << 8) | (memory[0] << 0);
d294 1
a294 1
tomem (state, memory, val)
d323 1
a323 1
  ARMul_SetReg (state, state->Mode, rn, frommem (state, memory));
d338 3
a340 3
    regval = ARMul_GetReg (state, state->Mode, rn);
  else if (rn == 25)		/* FIXME: use PS_REGNUM from gdb/config/arm/tm-arm.h */
    regval = ARMul_GetCPSR (state);
d342 1
a342 1
    regval = 0;			/* FIXME: should report an error */
d357 1
a357 1

d367 1
a367 1

d370 33
a402 33
	if (argv[i][0] == '-' && argv[i][1] == 'E')
	  {
	    char c;

	    if ((c = argv[i][2]) == 0)
	      {
		++i;
		c = argv[i][0];
	      }

	    switch (c)
	      {
	      case 0:
		sim_callback->printf_filtered
		  (sim_callback, "No argument to -E option provided\n");
		break;

	      case 'b':
	      case 'B':
		big_endian = 1;
		break;

	      case 'l':
	      case 'L':
		big_endian = 0;
		break;

	      default:
		sim_callback->printf_filtered
		  (sim_callback, "Unrecognised argument to -E option\n");
		break;
	      }
	  }
d423 1
a423 1
  extern bfd *sim_load_file ();	/* ??? Don't know where this should live.  */
d427 2
a428 1
			    sim_kind == SIM_OPEN_DEBUG, 0, sim_write);
d467 2
a468 3
{  
  (*sim_callback->printf_filtered) (sim_callback,
				    "This simulator does not accept any commands.\n");
@


