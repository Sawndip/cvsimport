head	1.9;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.9
	gdb_7_6-2013-04-26-release:1.9
	gdb_7_6-branch:1.9.0.2
	gdb_7_6-2013-03-12-branchpoint:1.9
	gdb_7_5_1-2012-11-29-release:1.7
	gdb_7_5-2012-08-17-release:1.7
	gdb_7_5-branch:1.7.0.62
	gdb_7_5-2012-07-18-branchpoint:1.7
	gdb_7_4_1-2012-04-26-release:1.7
	gdb_7_4-2012-01-24-release:1.7
	gdb_7_4-branch:1.7.0.60
	gdb_7_4-2011-12-13-branchpoint:1.7
	gdb_7_3_1-2011-09-04-release:1.7
	gdb_7_3-2011-07-26-release:1.7
	gdb_7_3-branch:1.7.0.58
	gdb_7_3-2011-04-01-branchpoint:1.7
	gdb_7_2-2010-09-02-release:1.7
	gdb_7_2-branch:1.7.0.56
	gdb_7_2-2010-07-07-branchpoint:1.7
	gdb_7_1-2010-03-18-release:1.7
	gdb_7_1-branch:1.7.0.54
	gdb_7_1-2010-02-18-branchpoint:1.7
	gdb_7_0_1-2009-12-22-release:1.7
	gdb_7_0-2009-10-06-release:1.7
	gdb_7_0-branch:1.7.0.52
	gdb_7_0-2009-09-16-branchpoint:1.7
	arc-sim-20090309:1.7
	msnyder-checkpoint-072509-branch:1.7.0.50
	msnyder-checkpoint-072509-branchpoint:1.7
	arc-insight_6_8-branch:1.7.0.48
	arc-insight_6_8-branchpoint:1.7
	insight_6_8-branch:1.7.0.46
	insight_6_8-branchpoint:1.7
	reverse-20081226-branch:1.7.0.44
	reverse-20081226-branchpoint:1.7
	multiprocess-20081120-branch:1.7.0.42
	multiprocess-20081120-branchpoint:1.7
	reverse-20080930-branch:1.7.0.40
	reverse-20080930-branchpoint:1.7
	reverse-20080717-branch:1.7.0.38
	reverse-20080717-branchpoint:1.7
	msnyder-reverse-20080609-branch:1.7.0.36
	msnyder-reverse-20080609-branchpoint:1.7
	drow-reverse-20070409-branch:1.7.0.34
	drow-reverse-20070409-branchpoint:1.7
	gdb_6_8-2008-03-27-release:1.7
	gdb_6_8-branch:1.7.0.32
	gdb_6_8-2008-02-26-branchpoint:1.7
	gdb_6_7_1-2007-10-29-release:1.7
	gdb_6_7-2007-10-10-release:1.7
	gdb_6_7-branch:1.7.0.30
	gdb_6_7-2007-09-07-branchpoint:1.7
	insight_6_6-20070208-release:1.7
	gdb_6_6-2006-12-18-release:1.7
	gdb_6_6-branch:1.7.0.28
	gdb_6_6-2006-11-15-branchpoint:1.7
	insight_6_5-20061003-release:1.7
	gdb-csl-symbian-6_4_50_20060226-12:1.7
	gdb-csl-sourcerygxx-3_4_4-25:1.7
	nickrob-async-20060828-mergepoint:1.7
	gdb-csl-symbian-6_4_50_20060226-11:1.7
	gdb-csl-sourcerygxx-4_1-17:1.7
	gdb-csl-20060226-branch-local-2:1.7
	gdb-csl-sourcerygxx-4_1-14:1.7
	gdb-csl-sourcerygxx-4_1-13:1.7
	gdb-csl-sourcerygxx-4_1-12:1.7
	gdb-csl-sourcerygxx-3_4_4-21:1.7
	gdb_6_5-20060621-release:1.7
	gdb-csl-sourcerygxx-4_1-9:1.7
	gdb-csl-sourcerygxx-4_1-8:1.7
	gdb-csl-sourcerygxx-4_1-7:1.7
	gdb-csl-arm-2006q1-6:1.7
	gdb-csl-sourcerygxx-4_1-6:1.7
	gdb-csl-symbian-6_4_50_20060226-10:1.7
	gdb-csl-symbian-6_4_50_20060226-9:1.7
	gdb-csl-symbian-6_4_50_20060226-8:1.7
	gdb-csl-coldfire-4_1-11:1.7
	gdb-csl-sourcerygxx-3_4_4-19:1.7
	gdb-csl-coldfire-4_1-10:1.7
	gdb_6_5-branch:1.7.0.26
	gdb_6_5-2006-05-14-branchpoint:1.7
	gdb-csl-sourcerygxx-4_1-5:1.7
	nickrob-async-20060513-branch:1.7.0.24
	nickrob-async-20060513-branchpoint:1.7
	gdb-csl-sourcerygxx-4_1-4:1.7
	msnyder-reverse-20060502-branch:1.7.0.22
	msnyder-reverse-20060502-branchpoint:1.7
	gdb-csl-morpho-4_1-4:1.7
	gdb-csl-sourcerygxx-3_4_4-17:1.7
	readline_5_1-import-branch:1.7.0.20
	readline_5_1-import-branchpoint:1.7
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.7
	gdb-csl-symbian-20060226-branch:1.7.0.18
	gdb-csl-symbian-20060226-branchpoint:1.7
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.7
	msnyder-reverse-20060331-branch:1.7.0.16
	msnyder-reverse-20060331-branchpoint:1.7
	gdb-csl-available-20060303-branch:1.7.0.14
	gdb-csl-available-20060303-branchpoint:1.7
	gdb-csl-20060226-branch:1.7.0.12
	gdb-csl-20060226-branchpoint:1.7
	gdb_6_4-20051202-release:1.7
	msnyder-fork-checkpoint-branch:1.7.0.10
	msnyder-fork-checkpoint-branchpoint:1.7
	gdb-csl-gxxpro-6_3-branch:1.7.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.7
	gdb_6_4-branch:1.7.0.6
	gdb_6_4-2005-11-01-branchpoint:1.7
	gdb-csl-arm-20051020-branch:1.7.0.4
	gdb-csl-arm-20051020-branchpoint:1.7
	msnyder-tracepoint-checkpoint-branch:1.7.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.7
	gdb-csl-arm-20050325-2005-q1b:1.5
	gdb-csl-arm-20050325-2005-q1a:1.5
	csl-arm-20050325-branch:1.5.0.72
	csl-arm-20050325-branchpoint:1.5
	gdb_6_3-20041109-release:1.5
	gdb_6_3-branch:1.5.0.68
	gdb_6_3-20041019-branchpoint:1.5
	drow_intercu-merge-20040921:1.5
	drow_intercu-merge-20040915:1.5
	jimb-gdb_6_2-e500-branch:1.5.0.70
	jimb-gdb_6_2-e500-branchpoint:1.5
	gdb_6_2-20040730-release:1.5
	gdb_6_2-branch:1.5.0.66
	gdb_6_2-2004-07-10-gmt-branchpoint:1.5
	gdb_6_1_1-20040616-release:1.5
	gdb_6_1-2004-04-05-release:1.5
	drow_intercu-merge-20040402:1.5
	drow_intercu-merge-20040327:1.5
	ezannoni_pie-20040323-branch:1.5.0.64
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.62
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.60
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow_intercu-20040221-branch:1.5.0.58
	drow_intercu-20040221-branchpoint:1.5
	cagney_bfdfile-20040213-branch:1.5.0.56
	cagney_bfdfile-20040213-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	cagney_bigcore-20040122-branch:1.5.0.54
	cagney_bigcore-20040122-branchpoint:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	kettenis_sparc-20030918-branch:1.5.0.52
	kettenis_sparc-20030918-branchpoint:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.50
	cagney_x86i386-20030821-branch:1.5.0.48
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.46
	gdb_6_0-2003-06-23-branchpoint:1.5
	jimb-ppc64-linux-20030613-branch:1.5.0.44
	jimb-ppc64-linux-20030613-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.42
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.40
	cagney_writestrings-20030508-branchpoint:1.5
	jimb-ppc64-linux-20030528-branch:1.5.0.38
	jimb-ppc64-linux-20030528-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.36
	cagney_fileio-20030521-branchpoint:1.5
	kettenis_i386newframe-20030517-mergepoint:1.5
	jimb-ppc64-linux-20030509-branch:1.5.0.34
	jimb-ppc64-linux-20030509-branchpoint:1.5
	kettenis_i386newframe-20030504-mergepoint:1.5
	carlton_dictionary-20030430-merge:1.5
	kettenis_i386newframe-20030419-branch:1.5.0.32
	kettenis_i386newframe-20030419-branchpoint:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	kettenis_i386newframe-20030406-branch:1.5.0.30
	kettenis_i386newframe-20030406-branchpoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.28
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.26
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.24
	cagney_lazyid-20030317-branchpoint:1.5
	kettenis-i386newframe-20030316-mergepoint:1.5
	offbyone-20030313-branch:1.5.0.22
	offbyone-20030313-branchpoint:1.5
	kettenis-i386newframe-20030308-branch:1.5.0.20
	kettenis-i386newframe-20030308-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.18
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.16
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.14
	cagney-unwind-20030108-branchpoint:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.5
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.12
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.10
	carlton_dictionary-20020920-branchpoint:1.5
	gdb_5_3-branch:1.5.0.8
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.6
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.4
	readline_4_3-import-branchpoint:1.5
	gdb_5_2_1-2002-07-23-release:1.3
	kseitz_interps-20020528-branch:1.5.0.2
	kseitz_interps-20020528-branchpoint:1.5
	cagney_regbuf-20020515-branch:1.3.0.12
	cagney_regbuf-20020515-branchpoint:1.3
	jimb-macro-020506-branch:1.3.0.10
	jimb-macro-020506-branchpoint:1.3
	gdb_5_2-2002-04-29-release:1.3
	gdb_5_2-branch:1.3.0.8
	gdb_5_2-2002-03-03-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.4
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.2
	gdb_5_1-2001-07-29-branchpoint:1.3
	insight-precleanup-2001-01-01:1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.4.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.4
	gdb_5_0-2000-05-19-release:1.1.1.4
	gdb_4_18_2-2000-05-18-release:1.1.1.4
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.4
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.4
	gdb_5_0-2000-04-10-branch:1.1.1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.4
	repo-unification-2000-02-06:1.1.1.4
	gdb-2000-02-04:1.1.1.4
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.9
date	2012.12.19.07.18.15;	author brobecke;	state Exp;
branches;
next	1.8;

1.8
date	2012.12.19.07.11.59;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.24.15.30.38;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.12.07.36.59;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.27.13.30.36;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.23.12.38.31;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.06.22.33.47;	author nickc;	state Exp;
branches
	1.3.12.1;
next	1.2;

1.2
date	2000.11.30.01.55.12;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.56;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.3.12.1
date	2002.06.15.16.43.22;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.56;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.31.23;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.11.02.04.44.45;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.02.05.07.30.19;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.9
log
@[sim] Update old contact info in GPL license notices

sim/ChangeLog:

        Update old contact info in GPL license notices.
@
text
@/*  thumbemu.c -- Thumb instruction emulation.
    Copyright (C) 1996, Cygnus Software Technologies Ltd.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, see <http://www.gnu.org/licenses/>. */

/* We can provide simple Thumb simulation by decoding the Thumb
instruction into its corresponding ARM instruction, and using the
existing ARM simulator.  */

#ifndef MODET			/* required for the Thumb instruction support */
#if 1
#error "MODET needs to be defined for the Thumb world to work"
#else
#define MODET (1)
#endif
#endif

#include "armdefs.h"
#include "armemu.h"
#include "armos.h"

/* Attempt to emulate an ARMv6 instruction.
   Stores t_branch into PVALUE upon success or t_undefined otherwise.  */

static void
handle_v6_thumb_insn (ARMul_State * state,
		      ARMword       tinstr,
		      tdstate *     pvalid)
{
  ARMword Rd;
  ARMword Rm;

  if (! state->is_v6)
    {
      * pvalid = t_undefined;
      return;
    }

  switch (tinstr & 0xFFC0)
    {
    case 0xb660: /* cpsie */
    case 0xb670: /* cpsid */
    case 0x4600: /* cpy */
    case 0xba00: /* rev */
    case 0xba40: /* rev16 */
    case 0xbac0: /* revsh */
    case 0xb650: /* setend */
    default:  
      printf ("Unhandled v6 thumb insn: %04x\n", tinstr);
      * pvalid = t_undefined;
      return;

    case 0xb200: /* sxth */
      Rm = state->Reg [(tinstr & 0x38) >> 3];
      if (Rm & 0x8000)
	state->Reg [(tinstr & 0x7)] = (Rm & 0xffff) | 0xffff0000;
      else
	state->Reg [(tinstr & 0x7)] = Rm & 0xffff;
      break;
    case 0xb240: /* sxtb */
      Rm = state->Reg [(tinstr & 0x38) >> 3];
      if (Rm & 0x80)
	state->Reg [(tinstr & 0x7)] = (Rm & 0xff) | 0xffffff00;
      else
	state->Reg [(tinstr & 0x7)] = Rm & 0xff;
      break;
    case 0xb280: /* uxth */
      Rm = state->Reg [(tinstr & 0x38) >> 3];
      state->Reg [(tinstr & 0x7)] = Rm & 0xffff;
      break;
    case 0xb2c0: /* uxtb */
      Rm = state->Reg [(tinstr & 0x38) >> 3];
      state->Reg [(tinstr & 0x7)] = Rm & 0xff;
      break;
    }
  /* Indicate that the instruction has been processed.  */
  * pvalid = t_branch;
}

/* Decode a 16bit Thumb instruction.  The instruction is in the low
   16-bits of the tinstr field, with the following Thumb instruction
   held in the high 16-bits.  Passing in two Thumb instructions allows
   easier simulation of the special dual BL instruction.  */

tdstate
ARMul_ThumbDecode (ARMul_State * state,
		   ARMword       pc,
		   ARMword       tinstr,
		   ARMword *     ainstr)
{
  tdstate valid = t_decoded;	/* default assumes a valid instruction */
  ARMword next_instr;

  if (state->bigendSig)
    {
      next_instr = tinstr & 0xFFFF;
      tinstr >>= 16;
    }
  else
    {
      next_instr = tinstr >> 16;
      tinstr &= 0xFFFF;
    }

#if 1				/* debugging to catch non updates */
  *ainstr = 0xDEADC0DE;
#endif

  switch ((tinstr & 0xF800) >> 11)
    {
    case 0:			/* LSL */
    case 1:			/* LSR */
    case 2:			/* ASR */
      /* Format 1 */
      *ainstr = 0xE1B00000	/* base opcode */
	| ((tinstr & 0x1800) >> (11 - 5))	/* shift type */
	| ((tinstr & 0x07C0) << (7 - 6))	/* imm5 */
	| ((tinstr & 0x0038) >> 3)	/* Rs */
	| ((tinstr & 0x0007) << 12);	/* Rd */
      break;
    case 3:			/* ADD/SUB */
      /* Format 2 */
      {
	ARMword subset[4] = {
	  0xE0900000,		/* ADDS Rd,Rs,Rn    */
	  0xE0500000,		/* SUBS Rd,Rs,Rn    */
	  0xE2900000,		/* ADDS Rd,Rs,#imm3 */
	  0xE2500000		/* SUBS Rd,Rs,#imm3 */
	};
	/* It is quicker indexing into a table, than performing switch
	   or conditionals: */
	*ainstr = subset[(tinstr & 0x0600) >> 9]	/* base opcode */
	  | ((tinstr & 0x01C0) >> 6)	/* Rn or imm3 */
	  | ((tinstr & 0x0038) << (16 - 3))	/* Rs */
	  | ((tinstr & 0x0007) << (12 - 0));	/* Rd */
      }
      break;
    case 4:			/* MOV */
    case 5:			/* CMP */
    case 6:			/* ADD */
    case 7:			/* SUB */
      /* Format 3 */
      {
	ARMword subset[4] = {
	  0xE3B00000,		/* MOVS Rd,#imm8    */
	  0xE3500000,		/* CMP  Rd,#imm8    */
	  0xE2900000,		/* ADDS Rd,Rd,#imm8 */
	  0xE2500000,		/* SUBS Rd,Rd,#imm8 */
	};
	*ainstr = subset[(tinstr & 0x1800) >> 11]	/* base opcode */
	  | ((tinstr & 0x00FF) >> 0)	/* imm8 */
	  | ((tinstr & 0x0700) << (16 - 8))	/* Rn */
	  | ((tinstr & 0x0700) << (12 - 8));	/* Rd */
      }
      break;
    case 8:			/* Arithmetic and high register transfers */
      /* TODO: Since the subsets for both Format 4 and Format 5
         instructions are made up of different ARM encodings, we could
         save the following conditional, and just have one large
         subset. */
      if ((tinstr & (1 << 10)) == 0)
	{
	  /* Format 4 */
	  struct
	  {
	    ARMword opcode;
	    enum
	    { t_norm, t_shift, t_neg, t_mul }
	    otype;
	  }
	  subset[16] =
	  {
	    { 0xE0100000, t_norm},			/* ANDS Rd,Rd,Rs     */
	    { 0xE0300000, t_norm},			/* EORS Rd,Rd,Rs     */
	    { 0xE1B00010, t_shift},			/* MOVS Rd,Rd,LSL Rs */
	    { 0xE1B00030, t_shift},			/* MOVS Rd,Rd,LSR Rs */
	    { 0xE1B00050, t_shift},			/* MOVS Rd,Rd,ASR Rs */
	    { 0xE0B00000, t_norm},			/* ADCS Rd,Rd,Rs     */
	    { 0xE0D00000, t_norm},			/* SBCS Rd,Rd,Rs     */
	    { 0xE1B00070, t_shift},			/* MOVS Rd,Rd,ROR Rs */
	    { 0xE1100000, t_norm},			/* TST  Rd,Rs        */
	    { 0xE2700000, t_neg},			/* RSBS Rd,Rs,#0     */
	    { 0xE1500000, t_norm},			/* CMP  Rd,Rs        */
	    { 0xE1700000, t_norm},			/* CMN  Rd,Rs        */
	    { 0xE1900000, t_norm},			/* ORRS Rd,Rd,Rs     */
	    { 0xE0100090, t_mul} ,			/* MULS Rd,Rd,Rs     */
	    { 0xE1D00000, t_norm},			/* BICS Rd,Rd,Rs     */
	    { 0xE1F00000, t_norm}	/* MVNS Rd,Rs        */
	  };
	  *ainstr = subset[(tinstr & 0x03C0) >> 6].opcode;	/* base */
	  switch (subset[(tinstr & 0x03C0) >> 6].otype)
	    {
	    case t_norm:
	      *ainstr |= ((tinstr & 0x0007) << 16)	/* Rn */
		| ((tinstr & 0x0007) << 12)	/* Rd */
		| ((tinstr & 0x0038) >> 3);	/* Rs */
	      break;
	    case t_shift:
	      *ainstr |= ((tinstr & 0x0007) << 12)	/* Rd */
		| ((tinstr & 0x0007) >> 0)	/* Rm */
		| ((tinstr & 0x0038) << (8 - 3));	/* Rs */
	      break;
	    case t_neg:
	      *ainstr |= ((tinstr & 0x0007) << 12)	/* Rd */
		| ((tinstr & 0x0038) << (16 - 3));	/* Rn */
	      break;
	    case t_mul:
	      *ainstr |= ((tinstr & 0x0007) << 16)	/* Rd */
		| ((tinstr & 0x0007) << 8)	/* Rs */
		| ((tinstr & 0x0038) >> 3);	/* Rm */
	      break;
	    }
	}
      else
	{
	  /* Format 5 */
	  ARMword Rd = ((tinstr & 0x0007) >> 0);
	  ARMword Rs = ((tinstr & 0x0038) >> 3);
	  if (tinstr & (1 << 7))
	    Rd += 8;
	  if (tinstr & (1 << 6))
	    Rs += 8;
	  switch ((tinstr & 0x03C0) >> 6)
	    {
	    case 0x1:		/* ADD Rd,Rd,Hs */
	    case 0x2:		/* ADD Hd,Hd,Rs */
	    case 0x3:		/* ADD Hd,Hd,Hs */
	      *ainstr = 0xE0800000	/* base */
		| (Rd << 16)	/* Rn */
		| (Rd << 12)	/* Rd */
		| (Rs << 0);	/* Rm */
	      break;
	    case 0x5:		/* CMP Rd,Hs */
	    case 0x6:		/* CMP Hd,Rs */
	    case 0x7:		/* CMP Hd,Hs */
	      *ainstr = 0xE1500000	/* base */
		| (Rd << 16)	/* Rn */
		| (Rd << 12)	/* Rd */
		| (Rs << 0);	/* Rm */
	      break;
	    case 0x9:		/* MOV Rd,Hs */
	    case 0xA:		/* MOV Hd,Rs */
	    case 0xB:		/* MOV Hd,Hs */
	      *ainstr = 0xE1A00000	/* base */
		| (Rd << 16)	/* Rn */
		| (Rd << 12)	/* Rd */
		| (Rs << 0);	/* Rm */
	      break;
	    case 0xC:		/* BX Rs */
	    case 0xD:		/* BX Hs */
	      *ainstr = 0xE12FFF10	/* base */
		| ((tinstr & 0x0078) >> 3);	/* Rd */
	      break;
	    case 0xE:		/* UNDEFINED */
	    case 0xF:		/* UNDEFINED */
	      if (state->is_v5)
		{
		  /* BLX Rs; BLX Hs */
		  *ainstr = 0xE12FFF30	/* base */
		    | ((tinstr & 0x0078) >> 3);	/* Rd */
		  break;
		}
	      /* Drop through.  */
	    case 0x0:		/* UNDEFINED */
	    case 0x4:		/* UNDEFINED */
	    case 0x8:		/* UNDEFINED */
	      handle_v6_thumb_insn (state, tinstr, & valid);
	      break;
	    }
	}
      break;
    case 9:			/* LDR Rd,[PC,#imm8] */
      /* Format 6 */
      *ainstr = 0xE59F0000	/* base */
	| ((tinstr & 0x0700) << (12 - 8))	/* Rd */
	| ((tinstr & 0x00FF) << (2 - 0));	/* off8 */
      break;
    case 10:
    case 11:
      /* TODO: Format 7 and Format 8 perform the same ARM encoding, so
         the following could be merged into a single subset, saving on
         the following boolean: */
      if ((tinstr & (1 << 9)) == 0)
	{
	  /* Format 7 */
	  ARMword subset[4] = {
	    0xE7800000,		/* STR  Rd,[Rb,Ro] */
	    0xE7C00000,		/* STRB Rd,[Rb,Ro] */
	    0xE7900000,		/* LDR  Rd,[Rb,Ro] */
	    0xE7D00000		/* LDRB Rd,[Rb,Ro] */
	  };
	  *ainstr = subset[(tinstr & 0x0C00) >> 10]	/* base */
	    | ((tinstr & 0x0007) << (12 - 0))	/* Rd */
	    | ((tinstr & 0x0038) << (16 - 3))	/* Rb */
	    | ((tinstr & 0x01C0) >> 6);	/* Ro */
	}
      else
	{
	  /* Format 8 */
	  ARMword subset[4] = {
	    0xE18000B0,		/* STRH  Rd,[Rb,Ro] */
	    0xE19000D0,		/* LDRSB Rd,[Rb,Ro] */
	    0xE19000B0,		/* LDRH  Rd,[Rb,Ro] */
	    0xE19000F0		/* LDRSH Rd,[Rb,Ro] */
	  };
	  *ainstr = subset[(tinstr & 0x0C00) >> 10]	/* base */
	    | ((tinstr & 0x0007) << (12 - 0))	/* Rd */
	    | ((tinstr & 0x0038) << (16 - 3))	/* Rb */
	    | ((tinstr & 0x01C0) >> 6);	/* Ro */
	}
      break;
    case 12:			/* STR Rd,[Rb,#imm5] */
    case 13:			/* LDR Rd,[Rb,#imm5] */
    case 14:			/* STRB Rd,[Rb,#imm5] */
    case 15:			/* LDRB Rd,[Rb,#imm5] */
      /* Format 9 */
      {
	ARMword subset[4] = {
	  0xE5800000,		/* STR  Rd,[Rb,#imm5] */
	  0xE5900000,		/* LDR  Rd,[Rb,#imm5] */
	  0xE5C00000,		/* STRB Rd,[Rb,#imm5] */
	  0xE5D00000		/* LDRB Rd,[Rb,#imm5] */
	};
	/* The offset range defends on whether we are transferring a
	   byte or word value: */
	*ainstr = subset[(tinstr & 0x1800) >> 11]	/* base */
	  | ((tinstr & 0x0007) << (12 - 0))	/* Rd */
	  | ((tinstr & 0x0038) << (16 - 3))	/* Rb */
	  | ((tinstr & 0x07C0) >> (6 - ((tinstr & (1 << 12)) ? 0 : 2)));	/* off5 */
      }
      break;
    case 16:			/* STRH Rd,[Rb,#imm5] */
    case 17:			/* LDRH Rd,[Rb,#imm5] */
      /* Format 10 */
      *ainstr = ((tinstr & (1 << 11))	/* base */
		 ? 0xE1D000B0	/* LDRH */
		 : 0xE1C000B0)	/* STRH */
	| ((tinstr & 0x0007) << (12 - 0))	/* Rd */
	| ((tinstr & 0x0038) << (16 - 3))	/* Rb */
	| ((tinstr & 0x01C0) >> (6 - 1))	/* off5, low nibble */
	| ((tinstr & 0x0600) >> (9 - 8));	/* off5, high nibble */
      break;
    case 18:			/* STR Rd,[SP,#imm8] */
    case 19:			/* LDR Rd,[SP,#imm8] */
      /* Format 11 */
      *ainstr = ((tinstr & (1 << 11))	/* base */
		 ? 0xE59D0000	/* LDR */
		 : 0xE58D0000)	/* STR */
	| ((tinstr & 0x0700) << (12 - 8))	/* Rd */
	| ((tinstr & 0x00FF) << 2);	/* off8 */
      break;
    case 20:			/* ADD Rd,PC,#imm8 */
    case 21:			/* ADD Rd,SP,#imm8 */
      /* Format 12 */
      if ((tinstr & (1 << 11)) == 0)
	{
	  /* NOTE: The PC value used here should by word aligned */
	  /* We encode shift-left-by-2 in the rotate immediate field,
	     so no shift of off8 is needed.  */
	  *ainstr = 0xE28F0F00	/* base */
	    | ((tinstr & 0x0700) << (12 - 8))	/* Rd */
	    | (tinstr & 0x00FF);	/* off8 */
	}
      else
	{
	  /* We encode shift-left-by-2 in the rotate immediate field,
	     so no shift of off8 is needed.  */
	  *ainstr = 0xE28D0F00	/* base */
	    | ((tinstr & 0x0700) << (12 - 8))	/* Rd */
	    | (tinstr & 0x00FF);	/* off8 */
	}
      break;
    case 22:
    case 23:
      switch (tinstr & 0x0F00)
	{
	case 0x0000:
	  /* Format 13 */
	  /* NOTE: The instruction contains a shift left of 2
	     equivalent (implemented as ROR #30):  */
	  *ainstr = ((tinstr & (1 << 7))	/* base */
		     ? 0xE24DDF00	/* SUB */
		     : 0xE28DDF00)	/* ADD */
	    | (tinstr & 0x007F);	/* off7 */
	  break;
	case 0x0400:
	  /* Format 14 - Push */
	  * ainstr = 0xE92D0000 | (tinstr & 0x00FF);
	  break;
	case 0x0500:
	  /* Format 14 - Push + LR */
	  * ainstr = 0xE92D4000 | (tinstr & 0x00FF);
	  break;
	case 0x0c00:
	  /* Format 14 - Pop */
	  * ainstr = 0xE8BD0000 | (tinstr & 0x00FF);
	  break;
	case 0x0d00:
	  /* Format 14 - Pop + PC */
	  * ainstr = 0xE8BD8000 | (tinstr & 0x00FF);
	  break;
	case 0x0e00:
	  if (state->is_v5)
	    {
	      /* This is normally an undefined instruction.  The v5t architecture 
		 defines this particular pattern as a BKPT instruction, for
		 hardware assisted debugging.  We map onto the arm BKPT
		 instruction.  */
	      * ainstr = 0xE1200070 | ((tinstr & 0xf0) << 4) | (tinstr & 0xf);
	      break;
	    }
	  /* Drop through.  */
	default:
	  /* Everything else is an undefined instruction.  */
	  handle_v6_thumb_insn (state, tinstr, & valid);
	  break;
	}
      break;
    case 24:			/* STMIA */
    case 25:			/* LDMIA */
      /* Format 15 */
      *ainstr = ((tinstr & (1 << 11))	/* base */
		 ? 0xE8B00000	/* LDMIA */
		 : 0xE8A00000)	/* STMIA */
	| ((tinstr & 0x0700) << (16 - 8))	/* Rb */
	| (tinstr & 0x00FF);	/* mask8 */
      break;
    case 26:			/* Bcc */
    case 27:			/* Bcc/SWI */
      if ((tinstr & 0x0F00) == 0x0F00)
	{
	  /* Format 17 : SWI */
	  *ainstr = 0xEF000000;
	  /* Breakpoint must be handled specially.  */
	  if ((tinstr & 0x00FF) == 0x18)
	    *ainstr |= ((tinstr & 0x00FF) << 16);
	  /* New breakpoint value.  See gdb/arm-tdep.c  */
	  else if ((tinstr & 0x00FF) == 0xFE)
	    *ainstr |= SWI_Breakpoint;
	  else
	    *ainstr |= (tinstr & 0x00FF);
	}
      else if ((tinstr & 0x0F00) != 0x0E00)
	{
	  /* Format 16 */
	  int doit = FALSE;
	  /* TODO: Since we are doing a switch here, we could just add
	     the SWI and undefined instruction checks into this
	     switch to same on a couple of conditionals: */
	  switch ((tinstr & 0x0F00) >> 8)
	    {
	    case EQ:
	      doit = ZFLAG;
	      break;
	    case NE:
	      doit = !ZFLAG;
	      break;
	    case VS:
	      doit = VFLAG;
	      break;
	    case VC:
	      doit = !VFLAG;
	      break;
	    case MI:
	      doit = NFLAG;
	      break;
	    case PL:
	      doit = !NFLAG;
	      break;
	    case CS:
	      doit = CFLAG;
	      break;
	    case CC:
	      doit = !CFLAG;
	      break;
	    case HI:
	      doit = (CFLAG && !ZFLAG);
	      break;
	    case LS:
	      doit = (!CFLAG || ZFLAG);
	      break;
	    case GE:
	      doit = ((!NFLAG && !VFLAG) || (NFLAG && VFLAG));
	      break;
	    case LT:
	      doit = ((NFLAG && !VFLAG) || (!NFLAG && VFLAG));
	      break;
	    case GT:
	      doit = ((!NFLAG && !VFLAG && !ZFLAG)
		      || (NFLAG && VFLAG && !ZFLAG));
	      break;
	    case LE:
	      doit = ((NFLAG && !VFLAG) || (!NFLAG && VFLAG)) || ZFLAG;
	      break;
	    }
	  if (doit)
	    {
	      state->Reg[15] = (pc + 4
				+ (((tinstr & 0x7F) << 1)
				   | ((tinstr & (1 << 7)) ? 0xFFFFFF00 : 0)));
	      FLUSHPIPE;
	    }
	  valid = t_branch;
	}
      else
	/* UNDEFINED : cc=1110(AL) uses different format.  */
	handle_v6_thumb_insn (state, tinstr, & valid);
      break;
    case 28:			/* B */
      /* Format 18 */
      state->Reg[15] = (pc + 4
			+ (((tinstr & 0x3FF) << 1)
			   | ((tinstr & (1 << 10)) ? 0xFFFFF800 : 0)));
      FLUSHPIPE;
      valid = t_branch;
      break;
    case 29:			/* UNDEFINED */
      if (state->is_v5)
	{
	  if (tinstr & 1)
	    {
	      handle_v6_thumb_insn (state, tinstr, & valid);
	      break;
	    }
	  /* Drop through.  */
	  
	  /* Format 19 */
	  /* There is no single ARM instruction equivalent for this
	     instruction. Also, it should only ever be matched with the
	     fmt19 "BL/BLX instruction 1" instruction.  However, we do
	     allow the simulation of it on its own, with undefined results
	     if r14 is not suitably initialised.  */
	  {
	    ARMword tmp = (pc + 2);

	    state->Reg[15] = ((state->Reg[14] + ((tinstr & 0x07FF) << 1))
			      & 0xFFFFFFFC);
	    CLEART;
	    state->Reg[14] = (tmp | 1);
	    valid = t_branch;
	    FLUSHPIPE;
	    break;
	  }
	}

      handle_v6_thumb_insn (state, tinstr, & valid);
      break;

    case 30:			/* BL instruction 1 */
      /* Format 19 */
      /* There is no single ARM instruction equivalent for this Thumb
         instruction. To keep the simulation simple (from the user
         perspective) we check if the following instruction is the
         second half of this BL, and if it is we simulate it
         immediately.  */
      state->Reg[14] = state->Reg[15] \
	+ (((tinstr & 0x07FF) << 12) \
	   | ((tinstr & (1 << 10)) ? 0xFF800000 : 0));

      valid = t_branch;		/* in-case we don't have the 2nd half */
      tinstr = next_instr;	/* move the instruction down */
      pc += 2;			/* point the pc at the 2nd half */
      if (((tinstr & 0xF800) >> 11) != 31)
	{
	  if (((tinstr & 0xF800) >> 11) == 29)
	    {
	      ARMword tmp = (pc + 2);

	      state->Reg[15] = ((state->Reg[14]
				 + ((tinstr & 0x07FE) << 1))
				& 0xFFFFFFFC);
	      CLEART;
	      state->Reg[14] = (tmp | 1);
	      valid = t_branch;
	      FLUSHPIPE;
	    }
	  else
	    /* Exit, since not correct instruction. */
	    pc -= 2;
	  break;
	}
      /* else we fall through to process the second half of the BL */
      pc += 2;			/* point the pc at the 2nd half */
    case 31:			/* BL instruction 2 */
      /* Format 19 */
      /* There is no single ARM instruction equivalent for this
         instruction. Also, it should only ever be matched with the
         fmt19 "BL instruction 1" instruction. However, we do allow
         the simulation of it on its own, with undefined results if
         r14 is not suitably initialised.  */
      {
	ARMword tmp = pc;

	state->Reg[15] = (state->Reg[14] + ((tinstr & 0x07FF) << 1));
	state->Reg[14] = (tmp | 1);
	valid = t_branch;
	FLUSHPIPE;
      }
      break;
    }

  return valid;
}
@


1.8
log
@Update sim copyright headers from GPLv2-or-later to GPLv3-or-later.

gdb/sim/ChangeLog:

        Update the non-FSF-copyrighted files in sim to GPLv3 or later.
@
text
@d15 1
a15 2
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA. */
@


1.7
log
@(handle_v6_thumb_insn): New function.
(ARMul_ThumbDecode): Call handle_v6_thumb_insn() when an undefined instruction
  binary is encountered.
@
text
@d6 1
a6 1
    the Free Software Foundation; either version 2 of the License, or
@


1.6
log
@Update the address of the FSF organization
@
text
@d34 58
d97 5
a101 9
tdstate ARMul_ThumbDecode (state, pc, tinstr, ainstr)
     ARMul_State *
       state;
     ARMword
       pc;
     ARMword
       tinstr;
     ARMword *
       ainstr;
d279 1
a279 1
	      valid = t_undefined;
d427 1
a427 1
	  valid = t_undefined;
d517 3
a519 2
      else			/* UNDEFINED : cc=1110(AL) uses different format */
	valid = t_undefined;
d534 1
a534 1
	      valid = t_undefined;
d557 2
a558 1
      valid = t_undefined;
d560 1
@


1.5
log
@Thumb BL instruction: Do not set LR to pc + 2, it has already been advanced.
@
text
@d16 1
a16 1
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
@


1.4
log
@When decoding a BLX(1) instruction do not add in the second bit of the base
address - this has already been accounted for.
@
text
@d492 1
a492 1
	    
d512 3
a514 2
	+(((tinstr & 0x07FF) << 12) \
	  |((tinstr & (1 << 10)) ? 0xFF800000 : 0));
d547 2
a548 1
	ARMword tmp = (pc + 2);
@


1.3
log
@Fix BLX(1) for Thumb
@
text
@a522 3
	      /* Bit one of the destination address comes from bit one of the
		 address of the first (H == 10) half of the instruction, not
		 from the offset in the instruction.  */
d524 1
a524 2
				 + ((tinstr & 0x07FE) << 1)
				 + ((pc - 2) & 2))
d537 1
@


1.3.12.1
log
@merge from trunk
@
text
@d492 1
a492 1

d512 2
a513 3
	+ (((tinstr & 0x07FF) << 12) \
	   | ((tinstr & (1 << 10)) ? 0xFF800000 : 0));

d523 3
d527 2
a528 1
				 + ((tinstr & 0x07FE) << 1))
a540 1
      pc += 2;			/* point the pc at the 2nd half */
d549 1
a549 2
	ARMword tmp = pc;

@


1.2
log
@Add support for ARM's v5TE architecture and Intel's XScale extenstions
@
text
@a483 1
	do_blx2:			/* BLX instruction 2 */
d516 1
d521 13
a533 2
	      pc += 2;
	      goto do_blx2;
d535 4
a538 1
	  break;		/* exit, since not correct instruction */
a540 1
      pc += 2;			/* point the pc at the 2nd half */
@


1.1
log
@Initial revision
@
text
@d22 1
a22 1
#ifndef MODET /* required for the Thumb instruction support */
d32 1
d39 9
a47 6
tdstate
ARMul_ThumbDecode (state,pc,tinstr,ainstr)
     ARMul_State *state;
     ARMword pc;
     ARMword tinstr;
     ARMword *ainstr;
d49 1
a49 1
  tdstate valid = t_decoded; /* default assumes a valid instruction */
d51 1
a51 1
  
d62 2
a63 2
  
#if 1 /* debugging to catch non updates */
d69 3
a71 3
    case 0: /* LSL */
    case 1: /* LSR */
    case 2: /* ASR */
d73 5
a77 5
      *ainstr = 0xE1B00000                              /* base opcode */
                | ((tinstr & 0x1800) >> (11 - 5))       /* shift type */
                | ((tinstr & 0x07C0) << (7 - 6))        /* imm5 */
                | ((tinstr & 0x0038) >> 3)              /* Rs */
                | ((tinstr & 0x0007) << 12);            /* Rd */
d79 1
a79 1
    case 3: /* ADD/SUB */
d82 12
a93 12
        ARMword subset[4] = {
          0xE0900000,   /* ADDS Rd,Rs,Rn    */
          0xE0500000,   /* SUBS Rd,Rs,Rn    */
          0xE2900000,   /* ADDS Rd,Rs,#imm3 */
          0xE2500000    /* SUBS Rd,Rs,#imm3 */
        };
        /* It is quicker indexing into a table, than performing switch
           or conditionals: */
        *ainstr = subset[(tinstr & 0x0600) >> 9]        /* base opcode */
                  | ((tinstr & 0x01C0) >> 6)            /* Rn or imm3 */
                  | ((tinstr & 0x0038) << (16 - 3))     /* Rs */
                  | ((tinstr & 0x0007) << (12 - 0));    /* Rd */
d96 4
a99 4
    case 4: /* MOV */
    case 5: /* CMP */
    case 6: /* ADD */
    case 7: /* SUB */
d102 10
a111 10
        ARMword subset[4] = {
          0xE3B00000,   /* MOVS Rd,#imm8    */
          0xE3500000,   /* CMP  Rd,#imm8    */
          0xE2900000,   /* ADDS Rd,Rd,#imm8 */
          0xE2500000,   /* SUBS Rd,Rd,#imm8 */
        };
        *ainstr = subset[(tinstr & 0x1800) >> 11]       /* base opcode */
                  | ((tinstr & 0x00FF) >> 0)            /* imm8 */
                  | ((tinstr & 0x0700) << (16 - 8))     /* Rn */
                  | ((tinstr & 0x0700) << (12 - 8));    /* Rd */
d113 2
a114 2
      break ;
    case 8: /* Arithmetic and high register transfers */
d120 52
a171 47
        {
          /* Format 4 */
          struct {
            ARMword opcode;
            enum {t_norm,t_shift,t_neg,t_mul} otype;
          } subset[16] = {
            {0xE0100000, t_norm},  /* ANDS Rd,Rd,Rs     */
            {0xE0300000, t_norm},  /* EORS Rd,Rd,Rs     */
            {0xE1B00010, t_shift}, /* MOVS Rd,Rd,LSL Rs */
            {0xE1B00030, t_shift}, /* MOVS Rd,Rd,LSR Rs */
            {0xE1B00050, t_shift}, /* MOVS Rd,Rd,ASR Rs */
            {0xE0B00000, t_norm},  /* ADCS Rd,Rd,Rs     */
            {0xE0D00000, t_norm},  /* SBCS Rd,Rd,Rs     */
            {0xE1B00070, t_shift}, /* MOVS Rd,Rd,ROR Rs */
            {0xE1100000, t_norm},  /* TST  Rd,Rs        */
            {0xE2700000, t_neg},   /* RSBS Rd,Rs,#0     */
            {0xE1500000, t_norm},  /* CMP  Rd,Rs        */
            {0xE1700000, t_norm},  /* CMN  Rd,Rs        */
            {0xE1900000, t_norm},  /* ORRS Rd,Rd,Rs     */
            {0xE0100090, t_mul},   /* MULS Rd,Rd,Rs     */
            {0xE1D00000, t_norm},  /* BICS Rd,Rd,Rs     */
            {0xE1F00000, t_norm}   /* MVNS Rd,Rs        */
          };
          *ainstr = subset[(tinstr & 0x03C0)>>6].opcode; /* base */
          switch (subset[(tinstr & 0x03C0)>>6].otype)
            {
            case t_norm:
              *ainstr |= ((tinstr & 0x0007) << 16)      /* Rn */
                         | ((tinstr & 0x0007) << 12)    /* Rd */
                         | ((tinstr & 0x0038) >> 3);    /* Rs */
              break;
            case t_shift:
              *ainstr |= ((tinstr & 0x0007) << 12)         /* Rd */
                         | ((tinstr & 0x0007) >> 0)        /* Rm */
                         | ((tinstr & 0x0038) << (8 - 3)); /* Rs */
              break;
            case t_neg:
              *ainstr |= ((tinstr & 0x0007) << 12)          /* Rd */
                         | ((tinstr & 0x0038) << (16 - 3)); /* Rn */
              break;
            case t_mul:
              *ainstr |= ((tinstr & 0x0007) << 16)   /* Rd */
                         | ((tinstr & 0x0007) << 8)  /* Rs */
                         | ((tinstr & 0x0038) >> 3); /* Rm */
              break;
            }
        }
d173 56
a228 48
        {
          /* Format 5 */
          ARMword Rd = ((tinstr & 0x0007) >> 0);
          ARMword Rs = ((tinstr & 0x0038) >> 3);
          if (tinstr & (1 << 7))
            Rd += 8;
          if (tinstr & (1 << 6))
            Rs += 8;
          switch ((tinstr & 0x03C0) >> 6)
            {
            case 0x1: /* ADD Rd,Rd,Hs */
            case 0x2: /* ADD Hd,Hd,Rs */
            case 0x3: /* ADD Hd,Hd,Hs */
              *ainstr = 0xE0800000      /* base */
                        | (Rd << 16)    /* Rn */
                        | (Rd << 12)    /* Rd */
                        | (Rs << 0);    /* Rm */
              break;
            case 0x5: /* CMP Rd,Hs */
            case 0x6: /* CMP Hd,Rs */
            case 0x7: /* CMP Hd,Hs */
              *ainstr = 0xE1500000      /* base */
                        | (Rd << 16)    /* Rn */
                        | (Rd << 12)    /* Rd */
                        | (Rs << 0);    /* Rm */
              break;
            case 0x9: /* MOV Rd,Hs */
            case 0xA: /* MOV Hd,Rs */
            case 0xB: /* MOV Hd,Hs */
              *ainstr = 0xE1A00000      /* base */
                        | (Rd << 16)    /* Rn */
                        | (Rd << 12)    /* Rd */
                        | (Rs << 0);    /* Rm */
              break;
            case 0xC: /* BX Rs */
            case 0xD: /* BX Hs */
              *ainstr = 0xE12FFF10                      /* base */
                        | ((tinstr & 0x0078) >> 3);     /* Rd */
              break;
            case 0x0: /* UNDEFINED */
            case 0x4: /* UNDEFINED */
            case 0x8: /* UNDEFINED */
            case 0xE: /* UNDEFINED */
            case 0xF: /* UNDEFINED */
              valid = t_undefined;
              break;
            }
        }
d230 1
a230 1
    case 9: /* LDR Rd,[PC,#imm8] */
d232 3
a234 3
      *ainstr = 0xE59F0000                              /* base */
                | ((tinstr & 0x0700) << (12 - 8))       /* Rd */
                | ((tinstr & 0x00FF) << (2 - 0));       /* off8 */
d242 13
a254 13
        {
          /* Format 7 */
          ARMword subset[4] = {
            0xE7800000, /* STR  Rd,[Rb,Ro] */
            0xE7C00000, /* STRB Rd,[Rb,Ro] */
            0xE7900000, /* LDR  Rd,[Rb,Ro] */
            0xE7D00000  /* LDRB Rd,[Rb,Ro] */
          };
          *ainstr = subset[(tinstr & 0x0C00) >> 10]     /* base */
                    | ((tinstr & 0x0007) << (12 - 0))   /* Rd */
                    | ((tinstr & 0x0038) << (16 - 3))   /* Rb */
                    | ((tinstr & 0x01C0) >> 6);         /* Ro */
        }
d256 18
a273 18
        {
          /* Format 8 */
          ARMword subset[4] = {
            0xE18000B0, /* STRH  Rd,[Rb,Ro] */
            0xE19000D0, /* LDRSB Rd,[Rb,Ro] */
            0xE19000B0, /* LDRH  Rd,[Rb,Ro] */
            0xE19000F0  /* LDRSH Rd,[Rb,Ro] */
          };
          *ainstr = subset[(tinstr & 0x0C00) >> 10]     /* base */
                    | ((tinstr & 0x0007) << (12 - 0))   /* Rd */
                    | ((tinstr & 0x0038) << (16 - 3))   /* Rb */
                    | ((tinstr & 0x01C0) >> 6);         /* Ro */
        }
      break;
    case 12: /* STR Rd,[Rb,#imm5] */
    case 13: /* LDR Rd,[Rb,#imm5] */
    case 14: /* STRB Rd,[Rb,#imm5] */
    case 15: /* LDRB Rd,[Rb,#imm5] */
d276 12
a287 13
        ARMword subset[4] = {
          0xE5800000, /* STR  Rd,[Rb,#imm5] */
          0xE5900000, /* LDR  Rd,[Rb,#imm5] */
          0xE5C00000, /* STRB Rd,[Rb,#imm5] */
          0xE5D00000  /* LDRB Rd,[Rb,#imm5] */
        };
        /* The offset range defends on whether we are transferring a
           byte or word value: */
        *ainstr = subset[(tinstr & 0x1800) >> 11]       /* base */
                  | ((tinstr & 0x0007) << (12 - 0))     /* Rd */
                  | ((tinstr & 0x0038) << (16 - 3))     /* Rb */
                  | ((tinstr & 0x07C0) >>
                     (6 - ((tinstr & (1 << 12)) ? 0 : 2)));     /* off5 */
d290 2
a291 2
    case 16: /* STRH Rd,[Rb,#imm5] */
    case 17: /* LDRH Rd,[Rb,#imm5] */
d293 7
a299 7
      *ainstr = ((tinstr & (1 << 11))                   /* base */
                 ? 0xE1D000B0                           /* LDRH */
                 : 0xE1C000B0)                          /* STRH */
                | ((tinstr & 0x0007) << (12 - 0))       /* Rd */
                | ((tinstr & 0x0038) << (16 - 3))       /* Rb */
                | ((tinstr & 0x01C0) >> (6 - 1))	/* off5, low nibble */
		| ((tinstr & 0x0600) >> (9 - 8));	/* off5, high nibble */
d301 2
a302 2
    case 18: /* STR Rd,[SP,#imm8] */
    case 19: /* LDR Rd,[SP,#imm8] */
d304 5
a308 5
      *ainstr = ((tinstr & (1 << 11))                   /* base */
                 ? 0xE59D0000                           /* LDR */
                 : 0xE58D0000)                          /* STR */
                | ((tinstr & 0x0700) << (12 - 8))       /* Rd */
                | ((tinstr & 0x00FF) << 2);             /* off8 */
d310 2
a311 2
    case 20: /* ADD Rd,PC,#imm8 */
    case 21: /* ADD Rd,SP,#imm8 */
d314 2
a315 2
        {
          /* NOTE: The PC value used here should by word aligned */
d318 4
a321 4
          *ainstr = 0xE28F0F00                          /* base */
                    | ((tinstr & 0x0700) << (12 - 8))   /* Rd */
                    | (tinstr & 0x00FF);                /* off8 */
        }
d323 1
a323 1
        {
d326 4
a329 4
          *ainstr = 0xE28D0F00                          /* base */
                    | ((tinstr & 0x0700) << (12 - 8))   /* Rd */
                    | (tinstr & 0x00FF);                /* off8 */
        }
d333 43
a375 23
      if ((tinstr & 0x0F00) == 0x0000)
        {
          /* Format 13 */
          /* NOTE: The instruction contains a shift left of 2
             equivalent (implemented as ROR #30): */
          *ainstr = ((tinstr & (1 << 7))        /* base */
                     ? 0xE24DDF00               /* SUB */
                     : 0xE28DDF00)              /* ADD */
                    | (tinstr & 0x007F);        /* off7 */
        }
      else
        {
          /* Format 14 */
          ARMword subset[4] = {
            0xE92D0000, /* STMDB sp!,{rlist}    */
            0xE92D4000, /* STMDB sp!,{rlist,lr} */
            0xE8BD0000, /* LDMIA sp!,{rlist}    */
            0xE8BD8000  /* LDMIA sp!,{rlist,pc} */
          };
          *ainstr = subset[((tinstr & (1 << 11)) >> 10)
                           | ((tinstr & (1 << 8)) >> 8)]        /* base */
                    | (tinstr & 0x00FF);                        /* mask8 */
        }
d377 2
a378 2
    case 24: /* STMIA */
    case 25: /* LDMIA */
d380 5
a384 5
      *ainstr = ((tinstr & (1 << 11))                   /* base */
                 ? 0xE8B00000                           /* LDMIA */
                 : 0xE8A00000)                          /* STMIA */
                | ((tinstr & 0x0700) << (16 - 8))       /* Rb */
                | (tinstr & 0x00FF);                    /* mask8 */
d386 2
a387 2
    case 26: /* Bcc */
    case 27: /* Bcc/SWI */
d389 3
a391 3
        {
          /* Format 17 : SWI */
          *ainstr = 0xEF000000;
d395 3
d400 1
a400 1
        }
d402 63
a464 46
        {
          /* Format 16 */
          int doit = FALSE;
          /* TODO: Since we are doing a switch here, we could just add
             the SWI and undefined instruction checks into this
             switch to same on a couple of conditionals: */
          switch ((tinstr & 0x0F00) >> 8) {
            case EQ : doit=ZFLAG ;
                      break ;
            case NE : doit=!ZFLAG ;
                      break ;
            case VS : doit=VFLAG ;
                      break ;
            case VC : doit=!VFLAG ;
                      break ;
            case MI : doit=NFLAG ;
                      break ;
            case PL : doit=!NFLAG ;
                      break ;
            case CS : doit=CFLAG ;
                      break ;
            case CC : doit=!CFLAG ;
                      break ;
            case HI : doit=(CFLAG && !ZFLAG) ;
                      break ;
            case LS : doit=(!CFLAG || ZFLAG) ;
                      break ;
            case GE : doit=((!NFLAG && !VFLAG) || (NFLAG && VFLAG)) ;
                      break ;
            case LT : doit=((NFLAG && !VFLAG) || (!NFLAG && VFLAG)) ;
                      break ;
            case GT : doit=((!NFLAG && !VFLAG && !ZFLAG) || (NFLAG && VFLAG && !ZFLAG)) ;
                      break ;
            case LE : doit=((NFLAG && !VFLAG) || (!NFLAG && VFLAG)) || ZFLAG ;
                      break ;
          }
          if (doit) {
            state->Reg[15] = pc + 4
                             + (((tinstr & 0x7F) << 1)
                                | ((tinstr & (1 << 7)) ? 0xFFFFFF00 : 0));
            FLUSHPIPE;
          }
          valid = t_branch;
        }
      else /* UNDEFINED : cc=1110(AL) uses different format */
        valid = t_undefined;
d466 1
a466 1
    case 28: /* B */
d468 3
a470 3
      state->Reg[15] = pc + 4
                       + (((tinstr & 0x3FF) << 1)
                                | ((tinstr & (1 << 10)) ? 0xFFFFF800 : 0));
d474 29
a502 1
    case 29: /* UNDEFINED */
d505 1
a505 1
    case 30: /* BL instruction 1 */
d511 1
a511 1
         immediately. */
d513 4
a516 4
                       + (((tinstr & 0x07FF) << 12) \
                          | ((tinstr & (1 << 10)) ? 0xFF800000 : 0));
      valid = t_branch; /* in-case we don't have the 2nd half */
      tinstr = next_instr; /* move the instruction down */
d518 8
a525 1
	break; /* exit, since not correct instruction */
d527 2
a528 2
      pc += 2; /* point the pc at the 2nd half */
    case 31: /* BL instruction 2 */
d534 1
a534 1
         r14 is not suitably initialised.*/
d536 5
a540 5
        ARMword tmp = (pc + 2);
        state->Reg[15] = (state->Reg[14] + ((tinstr & 0x07FF) << 1));
        state->Reg[14] = (tmp | 1);
        valid = t_branch;
        FLUSHPIPE;
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a31 1
#include "armos.h"
a358 3
	  /* New breakpoint value.  See gdb/arm-tdep.c  */
	  else if ((tinstr & 0x00FF) == 0xFE)
	    * ainstr |= SWI_Breakpoint;
@


1.1.1.3
log
@import gdb-1999-11-01 snapshot
@
text
@a327 2
      else if ((tinstr & 0x0F00) == 0x0e00)
	* ainstr = 0xEF000000 | SWI_Breakpoint;
@


1.1.1.4
log
@import gdb-2000-02-04 snapshot
@
text
@d22 1
a22 1
#ifndef MODET			/* required for the Thumb instruction support */
d39 6
a44 9
tdstate ARMul_ThumbDecode (state, pc, tinstr, ainstr)
     ARMul_State *
       state;
     ARMword
       pc;
     ARMword
       tinstr;
     ARMword *
       ainstr;
d46 1
a46 1
  tdstate valid = t_decoded;	/* default assumes a valid instruction */
d48 1
a48 1

d59 2
a60 2

#if 1				/* debugging to catch non updates */
d66 3
a68 3
    case 0:			/* LSL */
    case 1:			/* LSR */
    case 2:			/* ASR */
d70 5
a74 5
      *ainstr = 0xE1B00000	/* base opcode */
	| ((tinstr & 0x1800) >> (11 - 5))	/* shift type */
	| ((tinstr & 0x07C0) << (7 - 6))	/* imm5 */
	| ((tinstr & 0x0038) >> 3)	/* Rs */
	| ((tinstr & 0x0007) << 12);	/* Rd */
d76 1
a76 1
    case 3:			/* ADD/SUB */
d79 12
a90 12
	ARMword subset[4] = {
	  0xE0900000,		/* ADDS Rd,Rs,Rn    */
	  0xE0500000,		/* SUBS Rd,Rs,Rn    */
	  0xE2900000,		/* ADDS Rd,Rs,#imm3 */
	  0xE2500000		/* SUBS Rd,Rs,#imm3 */
	};
	/* It is quicker indexing into a table, than performing switch
	   or conditionals: */
	*ainstr = subset[(tinstr & 0x0600) >> 9]	/* base opcode */
	  | ((tinstr & 0x01C0) >> 6)	/* Rn or imm3 */
	  | ((tinstr & 0x0038) << (16 - 3))	/* Rs */
	  | ((tinstr & 0x0007) << (12 - 0));	/* Rd */
d93 4
a96 4
    case 4:			/* MOV */
    case 5:			/* CMP */
    case 6:			/* ADD */
    case 7:			/* SUB */
d99 10
a108 10
	ARMword subset[4] = {
	  0xE3B00000,		/* MOVS Rd,#imm8    */
	  0xE3500000,		/* CMP  Rd,#imm8    */
	  0xE2900000,		/* ADDS Rd,Rd,#imm8 */
	  0xE2500000,		/* SUBS Rd,Rd,#imm8 */
	};
	*ainstr = subset[(tinstr & 0x1800) >> 11]	/* base opcode */
	  | ((tinstr & 0x00FF) >> 0)	/* imm8 */
	  | ((tinstr & 0x0700) << (16 - 8))	/* Rn */
	  | ((tinstr & 0x0700) << (12 - 8));	/* Rd */
d110 2
a111 2
      break;
    case 8:			/* Arithmetic and high register transfers */
d117 47
a163 52
	{
	  /* Format 4 */
	  struct
	  {
	    ARMword opcode;
	    enum
	    { t_norm, t_shift, t_neg, t_mul }
	    otype;
	  }
	  subset[16] =
	  {
	    { 0xE0100000, t_norm},			/* ANDS Rd,Rd,Rs     */
	    { 0xE0300000, t_norm},			/* EORS Rd,Rd,Rs     */
	    { 0xE1B00010, t_shift},			/* MOVS Rd,Rd,LSL Rs */
	    { 0xE1B00030, t_shift},			/* MOVS Rd,Rd,LSR Rs */
	    { 0xE1B00050, t_shift},			/* MOVS Rd,Rd,ASR Rs */
	    { 0xE0B00000, t_norm},			/* ADCS Rd,Rd,Rs     */
	    { 0xE0D00000, t_norm},			/* SBCS Rd,Rd,Rs     */
	    { 0xE1B00070, t_shift},			/* MOVS Rd,Rd,ROR Rs */
	    { 0xE1100000, t_norm},			/* TST  Rd,Rs        */
	    { 0xE2700000, t_neg},			/* RSBS Rd,Rs,#0     */
	    { 0xE1500000, t_norm},			/* CMP  Rd,Rs        */
	    { 0xE1700000, t_norm},			/* CMN  Rd,Rs        */
	    { 0xE1900000, t_norm},			/* ORRS Rd,Rd,Rs     */
	    { 0xE0100090, t_mul} ,			/* MULS Rd,Rd,Rs     */
	    { 0xE1D00000, t_norm},			/* BICS Rd,Rd,Rs     */
	    { 0xE1F00000, t_norm}	/* MVNS Rd,Rs        */
	  };
	  *ainstr = subset[(tinstr & 0x03C0) >> 6].opcode;	/* base */
	  switch (subset[(tinstr & 0x03C0) >> 6].otype)
	    {
	    case t_norm:
	      *ainstr |= ((tinstr & 0x0007) << 16)	/* Rn */
		| ((tinstr & 0x0007) << 12)	/* Rd */
		| ((tinstr & 0x0038) >> 3);	/* Rs */
	      break;
	    case t_shift:
	      *ainstr |= ((tinstr & 0x0007) << 12)	/* Rd */
		| ((tinstr & 0x0007) >> 0)	/* Rm */
		| ((tinstr & 0x0038) << (8 - 3));	/* Rs */
	      break;
	    case t_neg:
	      *ainstr |= ((tinstr & 0x0007) << 12)	/* Rd */
		| ((tinstr & 0x0038) << (16 - 3));	/* Rn */
	      break;
	    case t_mul:
	      *ainstr |= ((tinstr & 0x0007) << 16)	/* Rd */
		| ((tinstr & 0x0007) << 8)	/* Rs */
		| ((tinstr & 0x0038) >> 3);	/* Rm */
	      break;
	    }
	}
d165 48
a212 48
	{
	  /* Format 5 */
	  ARMword Rd = ((tinstr & 0x0007) >> 0);
	  ARMword Rs = ((tinstr & 0x0038) >> 3);
	  if (tinstr & (1 << 7))
	    Rd += 8;
	  if (tinstr & (1 << 6))
	    Rs += 8;
	  switch ((tinstr & 0x03C0) >> 6)
	    {
	    case 0x1:		/* ADD Rd,Rd,Hs */
	    case 0x2:		/* ADD Hd,Hd,Rs */
	    case 0x3:		/* ADD Hd,Hd,Hs */
	      *ainstr = 0xE0800000	/* base */
		| (Rd << 16)	/* Rn */
		| (Rd << 12)	/* Rd */
		| (Rs << 0);	/* Rm */
	      break;
	    case 0x5:		/* CMP Rd,Hs */
	    case 0x6:		/* CMP Hd,Rs */
	    case 0x7:		/* CMP Hd,Hs */
	      *ainstr = 0xE1500000	/* base */
		| (Rd << 16)	/* Rn */
		| (Rd << 12)	/* Rd */
		| (Rs << 0);	/* Rm */
	      break;
	    case 0x9:		/* MOV Rd,Hs */
	    case 0xA:		/* MOV Hd,Rs */
	    case 0xB:		/* MOV Hd,Hs */
	      *ainstr = 0xE1A00000	/* base */
		| (Rd << 16)	/* Rn */
		| (Rd << 12)	/* Rd */
		| (Rs << 0);	/* Rm */
	      break;
	    case 0xC:		/* BX Rs */
	    case 0xD:		/* BX Hs */
	      *ainstr = 0xE12FFF10	/* base */
		| ((tinstr & 0x0078) >> 3);	/* Rd */
	      break;
	    case 0x0:		/* UNDEFINED */
	    case 0x4:		/* UNDEFINED */
	    case 0x8:		/* UNDEFINED */
	    case 0xE:		/* UNDEFINED */
	    case 0xF:		/* UNDEFINED */
	      valid = t_undefined;
	      break;
	    }
	}
d214 1
a214 1
    case 9:			/* LDR Rd,[PC,#imm8] */
d216 3
a218 3
      *ainstr = 0xE59F0000	/* base */
	| ((tinstr & 0x0700) << (12 - 8))	/* Rd */
	| ((tinstr & 0x00FF) << (2 - 0));	/* off8 */
d226 13
a238 13
	{
	  /* Format 7 */
	  ARMword subset[4] = {
	    0xE7800000,		/* STR  Rd,[Rb,Ro] */
	    0xE7C00000,		/* STRB Rd,[Rb,Ro] */
	    0xE7900000,		/* LDR  Rd,[Rb,Ro] */
	    0xE7D00000		/* LDRB Rd,[Rb,Ro] */
	  };
	  *ainstr = subset[(tinstr & 0x0C00) >> 10]	/* base */
	    | ((tinstr & 0x0007) << (12 - 0))	/* Rd */
	    | ((tinstr & 0x0038) << (16 - 3))	/* Rb */
	    | ((tinstr & 0x01C0) >> 6);	/* Ro */
	}
d240 18
a257 18
	{
	  /* Format 8 */
	  ARMword subset[4] = {
	    0xE18000B0,		/* STRH  Rd,[Rb,Ro] */
	    0xE19000D0,		/* LDRSB Rd,[Rb,Ro] */
	    0xE19000B0,		/* LDRH  Rd,[Rb,Ro] */
	    0xE19000F0		/* LDRSH Rd,[Rb,Ro] */
	  };
	  *ainstr = subset[(tinstr & 0x0C00) >> 10]	/* base */
	    | ((tinstr & 0x0007) << (12 - 0))	/* Rd */
	    | ((tinstr & 0x0038) << (16 - 3))	/* Rb */
	    | ((tinstr & 0x01C0) >> 6);	/* Ro */
	}
      break;
    case 12:			/* STR Rd,[Rb,#imm5] */
    case 13:			/* LDR Rd,[Rb,#imm5] */
    case 14:			/* STRB Rd,[Rb,#imm5] */
    case 15:			/* LDRB Rd,[Rb,#imm5] */
d260 13
a272 12
	ARMword subset[4] = {
	  0xE5800000,		/* STR  Rd,[Rb,#imm5] */
	  0xE5900000,		/* LDR  Rd,[Rb,#imm5] */
	  0xE5C00000,		/* STRB Rd,[Rb,#imm5] */
	  0xE5D00000		/* LDRB Rd,[Rb,#imm5] */
	};
	/* The offset range defends on whether we are transferring a
	   byte or word value: */
	*ainstr = subset[(tinstr & 0x1800) >> 11]	/* base */
	  | ((tinstr & 0x0007) << (12 - 0))	/* Rd */
	  | ((tinstr & 0x0038) << (16 - 3))	/* Rb */
	  | ((tinstr & 0x07C0) >> (6 - ((tinstr & (1 << 12)) ? 0 : 2)));	/* off5 */
d275 2
a276 2
    case 16:			/* STRH Rd,[Rb,#imm5] */
    case 17:			/* LDRH Rd,[Rb,#imm5] */
d278 7
a284 7
      *ainstr = ((tinstr & (1 << 11))	/* base */
		 ? 0xE1D000B0	/* LDRH */
		 : 0xE1C000B0)	/* STRH */
	| ((tinstr & 0x0007) << (12 - 0))	/* Rd */
	| ((tinstr & 0x0038) << (16 - 3))	/* Rb */
	| ((tinstr & 0x01C0) >> (6 - 1))	/* off5, low nibble */
	| ((tinstr & 0x0600) >> (9 - 8));	/* off5, high nibble */
d286 2
a287 2
    case 18:			/* STR Rd,[SP,#imm8] */
    case 19:			/* LDR Rd,[SP,#imm8] */
d289 5
a293 5
      *ainstr = ((tinstr & (1 << 11))	/* base */
		 ? 0xE59D0000	/* LDR */
		 : 0xE58D0000)	/* STR */
	| ((tinstr & 0x0700) << (12 - 8))	/* Rd */
	| ((tinstr & 0x00FF) << 2);	/* off8 */
d295 2
a296 2
    case 20:			/* ADD Rd,PC,#imm8 */
    case 21:			/* ADD Rd,SP,#imm8 */
d299 2
a300 2
	{
	  /* NOTE: The PC value used here should by word aligned */
d303 4
a306 4
	  *ainstr = 0xE28F0F00	/* base */
	    | ((tinstr & 0x0700) << (12 - 8))	/* Rd */
	    | (tinstr & 0x00FF);	/* off8 */
	}
d308 1
a308 1
	{
d311 4
a314 4
	  *ainstr = 0xE28D0F00	/* base */
	    | ((tinstr & 0x0700) << (12 - 8))	/* Rd */
	    | (tinstr & 0x00FF);	/* off8 */
	}
d319 9
a327 9
	{
	  /* Format 13 */
	  /* NOTE: The instruction contains a shift left of 2
	     equivalent (implemented as ROR #30): */
	  *ainstr = ((tinstr & (1 << 7))	/* base */
		     ? 0xE24DDF00	/* SUB */
		     : 0xE28DDF00)	/* ADD */
	    | (tinstr & 0x007F);	/* off7 */
	}
d329 1
a329 1
	*ainstr = 0xEF000000 | SWI_Breakpoint;
d331 12
a342 12
	{
	  /* Format 14 */
	  ARMword subset[4] = {
	    0xE92D0000,		/* STMDB sp!,{rlist}    */
	    0xE92D4000,		/* STMDB sp!,{rlist,lr} */
	    0xE8BD0000,		/* LDMIA sp!,{rlist}    */
	    0xE8BD8000		/* LDMIA sp!,{rlist,pc} */
	  };
	  *ainstr = subset[((tinstr & (1 << 11)) >> 10)
			   | ((tinstr & (1 << 8)) >> 8)]	/* base */
	    | (tinstr & 0x00FF);	/* mask8 */
	}
d344 2
a345 2
    case 24:			/* STMIA */
    case 25:			/* LDMIA */
d347 5
a351 5
      *ainstr = ((tinstr & (1 << 11))	/* base */
		 ? 0xE8B00000	/* LDMIA */
		 : 0xE8A00000)	/* STMIA */
	| ((tinstr & 0x0700) << (16 - 8))	/* Rb */
	| (tinstr & 0x00FF);	/* mask8 */
d353 2
a354 2
    case 26:			/* Bcc */
    case 27:			/* Bcc/SWI */
d356 3
a358 3
	{
	  /* Format 17 : SWI */
	  *ainstr = 0xEF000000;
d364 1
a364 1
	    *ainstr |= SWI_Breakpoint;
d367 1
a367 1
	}
d369 46
a414 63
	{
	  /* Format 16 */
	  int doit = FALSE;
	  /* TODO: Since we are doing a switch here, we could just add
	     the SWI and undefined instruction checks into this
	     switch to same on a couple of conditionals: */
	  switch ((tinstr & 0x0F00) >> 8)
	    {
	    case EQ:
	      doit = ZFLAG;
	      break;
	    case NE:
	      doit = !ZFLAG;
	      break;
	    case VS:
	      doit = VFLAG;
	      break;
	    case VC:
	      doit = !VFLAG;
	      break;
	    case MI:
	      doit = NFLAG;
	      break;
	    case PL:
	      doit = !NFLAG;
	      break;
	    case CS:
	      doit = CFLAG;
	      break;
	    case CC:
	      doit = !CFLAG;
	      break;
	    case HI:
	      doit = (CFLAG && !ZFLAG);
	      break;
	    case LS:
	      doit = (!CFLAG || ZFLAG);
	      break;
	    case GE:
	      doit = ((!NFLAG && !VFLAG) || (NFLAG && VFLAG));
	      break;
	    case LT:
	      doit = ((NFLAG && !VFLAG) || (!NFLAG && VFLAG));
	      break;
	    case GT:
	      doit = ((!NFLAG && !VFLAG && !ZFLAG)
		      || (NFLAG && VFLAG && !ZFLAG));
	      break;
	    case LE:
	      doit = ((NFLAG && !VFLAG) || (!NFLAG && VFLAG)) || ZFLAG;
	      break;
	    }
	  if (doit)
	    {
	      state->Reg[15] = (pc + 4
				+ (((tinstr & 0x7F) << 1)
				   | ((tinstr & (1 << 7)) ? 0xFFFFFF00 : 0)));
	      FLUSHPIPE;
	    }
	  valid = t_branch;
	}
      else			/* UNDEFINED : cc=1110(AL) uses different format */
	valid = t_undefined;
d416 1
a416 1
    case 28:			/* B */
d418 3
a420 3
      state->Reg[15] = (pc + 4
			+ (((tinstr & 0x3FF) << 1)
			   | ((tinstr & (1 << 10)) ? 0xFFFFF800 : 0)));
d424 1
a424 1
    case 29:			/* UNDEFINED */
d427 1
a427 1
    case 30:			/* BL instruction 1 */
d433 1
a433 1
         immediately.  */
d435 4
a438 4
	+(((tinstr & 0x07FF) << 12) \
	  |((tinstr & (1 << 10)) ? 0xFF800000 : 0));
      valid = t_branch;		/* in-case we don't have the 2nd half */
      tinstr = next_instr;	/* move the instruction down */
d440 1
a440 1
	break;			/* exit, since not correct instruction */
d442 2
a443 2
      pc += 2;			/* point the pc at the 2nd half */
    case 31:			/* BL instruction 2 */
d449 1
a449 1
         r14 is not suitably initialised.  */
d451 5
a455 5
	ARMword tmp = (pc + 2);
	state->Reg[15] = (state->Reg[14] + ((tinstr & 0x07FF) << 1));
	state->Reg[14] = (tmp | 1);
	valid = t_branch;
	FLUSHPIPE;
@


