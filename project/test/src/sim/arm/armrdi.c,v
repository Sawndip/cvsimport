head	1.5;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.5
	gdb_7_6-2013-04-26-release:1.5
	gdb_7_6-branch:1.5.0.2
	gdb_7_6-2013-03-12-branchpoint:1.5
	gdb_7_5_1-2012-11-29-release:1.3
	gdb_7_5-2012-08-17-release:1.3
	gdb_7_5-branch:1.3.0.62
	gdb_7_5-2012-07-18-branchpoint:1.3
	gdb_7_4_1-2012-04-26-release:1.3
	gdb_7_4-2012-01-24-release:1.3
	gdb_7_4-branch:1.3.0.60
	gdb_7_4-2011-12-13-branchpoint:1.3
	gdb_7_3_1-2011-09-04-release:1.3
	gdb_7_3-2011-07-26-release:1.3
	gdb_7_3-branch:1.3.0.58
	gdb_7_3-2011-04-01-branchpoint:1.3
	gdb_7_2-2010-09-02-release:1.3
	gdb_7_2-branch:1.3.0.56
	gdb_7_2-2010-07-07-branchpoint:1.3
	gdb_7_1-2010-03-18-release:1.3
	gdb_7_1-branch:1.3.0.54
	gdb_7_1-2010-02-18-branchpoint:1.3
	gdb_7_0_1-2009-12-22-release:1.3
	gdb_7_0-2009-10-06-release:1.3
	gdb_7_0-branch:1.3.0.52
	gdb_7_0-2009-09-16-branchpoint:1.3
	arc-sim-20090309:1.3
	msnyder-checkpoint-072509-branch:1.3.0.50
	msnyder-checkpoint-072509-branchpoint:1.3
	arc-insight_6_8-branch:1.3.0.48
	arc-insight_6_8-branchpoint:1.3
	insight_6_8-branch:1.3.0.46
	insight_6_8-branchpoint:1.3
	reverse-20081226-branch:1.3.0.44
	reverse-20081226-branchpoint:1.3
	multiprocess-20081120-branch:1.3.0.42
	multiprocess-20081120-branchpoint:1.3
	reverse-20080930-branch:1.3.0.40
	reverse-20080930-branchpoint:1.3
	reverse-20080717-branch:1.3.0.38
	reverse-20080717-branchpoint:1.3
	msnyder-reverse-20080609-branch:1.3.0.36
	msnyder-reverse-20080609-branchpoint:1.3
	drow-reverse-20070409-branch:1.3.0.34
	drow-reverse-20070409-branchpoint:1.3
	gdb_6_8-2008-03-27-release:1.3
	gdb_6_8-branch:1.3.0.32
	gdb_6_8-2008-02-26-branchpoint:1.3
	gdb_6_7_1-2007-10-29-release:1.3
	gdb_6_7-2007-10-10-release:1.3
	gdb_6_7-branch:1.3.0.30
	gdb_6_7-2007-09-07-branchpoint:1.3
	insight_6_6-20070208-release:1.3
	gdb_6_6-2006-12-18-release:1.3
	gdb_6_6-branch:1.3.0.28
	gdb_6_6-2006-11-15-branchpoint:1.3
	insight_6_5-20061003-release:1.3
	gdb-csl-symbian-6_4_50_20060226-12:1.3
	gdb-csl-sourcerygxx-3_4_4-25:1.3
	nickrob-async-20060828-mergepoint:1.3
	gdb-csl-symbian-6_4_50_20060226-11:1.3
	gdb-csl-sourcerygxx-4_1-17:1.3
	gdb-csl-20060226-branch-local-2:1.3
	gdb-csl-sourcerygxx-4_1-14:1.3
	gdb-csl-sourcerygxx-4_1-13:1.3
	gdb-csl-sourcerygxx-4_1-12:1.3
	gdb-csl-sourcerygxx-3_4_4-21:1.3
	gdb_6_5-20060621-release:1.3
	gdb-csl-sourcerygxx-4_1-9:1.3
	gdb-csl-sourcerygxx-4_1-8:1.3
	gdb-csl-sourcerygxx-4_1-7:1.3
	gdb-csl-arm-2006q1-6:1.3
	gdb-csl-sourcerygxx-4_1-6:1.3
	gdb-csl-symbian-6_4_50_20060226-10:1.3
	gdb-csl-symbian-6_4_50_20060226-9:1.3
	gdb-csl-symbian-6_4_50_20060226-8:1.3
	gdb-csl-coldfire-4_1-11:1.3
	gdb-csl-sourcerygxx-3_4_4-19:1.3
	gdb-csl-coldfire-4_1-10:1.3
	gdb_6_5-branch:1.3.0.26
	gdb_6_5-2006-05-14-branchpoint:1.3
	gdb-csl-sourcerygxx-4_1-5:1.3
	nickrob-async-20060513-branch:1.3.0.24
	nickrob-async-20060513-branchpoint:1.3
	gdb-csl-sourcerygxx-4_1-4:1.3
	msnyder-reverse-20060502-branch:1.3.0.22
	msnyder-reverse-20060502-branchpoint:1.3
	gdb-csl-morpho-4_1-4:1.3
	gdb-csl-sourcerygxx-3_4_4-17:1.3
	readline_5_1-import-branch:1.3.0.20
	readline_5_1-import-branchpoint:1.3
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.3
	gdb-csl-symbian-20060226-branch:1.3.0.18
	gdb-csl-symbian-20060226-branchpoint:1.3
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.3
	msnyder-reverse-20060331-branch:1.3.0.16
	msnyder-reverse-20060331-branchpoint:1.3
	gdb-csl-available-20060303-branch:1.3.0.14
	gdb-csl-available-20060303-branchpoint:1.3
	gdb-csl-20060226-branch:1.3.0.12
	gdb-csl-20060226-branchpoint:1.3
	gdb_6_4-20051202-release:1.3
	msnyder-fork-checkpoint-branch:1.3.0.10
	msnyder-fork-checkpoint-branchpoint:1.3
	gdb-csl-gxxpro-6_3-branch:1.3.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.3
	gdb_6_4-branch:1.3.0.6
	gdb_6_4-2005-11-01-branchpoint:1.3
	gdb-csl-arm-20051020-branch:1.3.0.4
	gdb-csl-arm-20051020-branchpoint:1.3
	msnyder-tracepoint-checkpoint-branch:1.3.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.3
	gdb-csl-arm-20050325-2005-q1b:1.2
	gdb-csl-arm-20050325-2005-q1a:1.2
	csl-arm-20050325-branch:1.2.0.84
	csl-arm-20050325-branchpoint:1.2
	gdb_6_3-20041109-release:1.2
	gdb_6_3-branch:1.2.0.80
	gdb_6_3-20041019-branchpoint:1.2
	drow_intercu-merge-20040921:1.2
	drow_intercu-merge-20040915:1.2
	jimb-gdb_6_2-e500-branch:1.2.0.82
	jimb-gdb_6_2-e500-branchpoint:1.2
	gdb_6_2-20040730-release:1.2
	gdb_6_2-branch:1.2.0.78
	gdb_6_2-2004-07-10-gmt-branchpoint:1.2
	gdb_6_1_1-20040616-release:1.2
	gdb_6_1-2004-04-05-release:1.2
	drow_intercu-merge-20040402:1.2
	drow_intercu-merge-20040327:1.2
	ezannoni_pie-20040323-branch:1.2.0.76
	ezannoni_pie-20040323-branchpoint:1.2
	cagney_tramp-20040321-mergepoint:1.2
	cagney_tramp-20040309-branch:1.2.0.74
	cagney_tramp-20040309-branchpoint:1.2
	gdb_6_1-branch:1.2.0.72
	gdb_6_1-2004-03-01-gmt-branchpoint:1.2
	drow_intercu-20040221-branch:1.2.0.70
	drow_intercu-20040221-branchpoint:1.2
	cagney_bfdfile-20040213-branch:1.2.0.68
	cagney_bfdfile-20040213-branchpoint:1.2
	drow-cplus-merge-20040208:1.2
	carlton_dictionary-20040126-merge:1.2
	cagney_bigcore-20040122-branch:1.2.0.66
	cagney_bigcore-20040122-branchpoint:1.2
	drow-cplus-merge-20040113:1.2
	drow-cplus-merge-20031224:1.2
	drow-cplus-merge-20031220:1.2
	carlton_dictionary-20031215-merge:1.2
	drow-cplus-merge-20031214:1.2
	carlton-dictionary-20031111-merge:1.2
	gdb_6_0-2003-10-04-release:1.2
	kettenis_sparc-20030918-branch:1.2.0.64
	kettenis_sparc-20030918-branchpoint:1.2
	carlton_dictionary-20030917-merge:1.2
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.62
	cagney_x86i386-20030821-branch:1.2.0.60
	cagney_x86i386-20030821-branchpoint:1.2
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.2.0.58
	gdb_6_0-2003-06-23-branchpoint:1.2
	jimb-ppc64-linux-20030613-branch:1.2.0.56
	jimb-ppc64-linux-20030613-branchpoint:1.2
	cagney_convert-20030606-branch:1.2.0.54
	cagney_convert-20030606-branchpoint:1.2
	cagney_writestrings-20030508-branch:1.2.0.52
	cagney_writestrings-20030508-branchpoint:1.2
	jimb-ppc64-linux-20030528-branch:1.2.0.50
	jimb-ppc64-linux-20030528-branchpoint:1.2
	carlton_dictionary-20030523-merge:1.2
	cagney_fileio-20030521-branch:1.2.0.48
	cagney_fileio-20030521-branchpoint:1.2
	kettenis_i386newframe-20030517-mergepoint:1.2
	jimb-ppc64-linux-20030509-branch:1.2.0.46
	jimb-ppc64-linux-20030509-branchpoint:1.2
	kettenis_i386newframe-20030504-mergepoint:1.2
	carlton_dictionary-20030430-merge:1.2
	kettenis_i386newframe-20030419-branch:1.2.0.44
	kettenis_i386newframe-20030419-branchpoint:1.2
	carlton_dictionary-20030416-merge:1.2
	cagney_frameaddr-20030409-mergepoint:1.2
	kettenis_i386newframe-20030406-branch:1.2.0.42
	kettenis_i386newframe-20030406-branchpoint:1.2
	cagney_frameaddr-20030403-branchpoint:1.2
	cagney_frameaddr-20030403-branch:1.2.0.40
	cagney_framebase-20030330-mergepoint:1.2
	cagney_framebase-20030326-branch:1.2.0.38
	cagney_framebase-20030326-branchpoint:1.2
	cagney_lazyid-20030317-branch:1.2.0.36
	cagney_lazyid-20030317-branchpoint:1.2
	kettenis-i386newframe-20030316-mergepoint:1.2
	offbyone-20030313-branch:1.2.0.34
	offbyone-20030313-branchpoint:1.2
	kettenis-i386newframe-20030308-branch:1.2.0.32
	kettenis-i386newframe-20030308-branchpoint:1.2
	carlton_dictionary-20030305-merge:1.2
	cagney_offbyone-20030303-branch:1.2.0.30
	cagney_offbyone-20030303-branchpoint:1.2
	carlton_dictionary-20030207-merge:1.2
	interps-20030202-branch:1.2.0.28
	interps-20030202-branchpoint:1.2
	cagney-unwind-20030108-branch:1.2.0.26
	cagney-unwind-20030108-branchpoint:1.2
	carlton_dictionary-20021223-merge:1.2
	gdb_5_3-2002-12-12-release:1.2
	carlton_dictionary-20021115-merge:1.2
	kseitz_interps-20021105-merge:1.2
	kseitz_interps-20021103-merge:1.2
	drow-cplus-merge-20021020:1.2
	drow-cplus-merge-20021025:1.2
	carlton_dictionary-20021025-merge:1.2
	carlton_dictionary-20021011-merge:1.2
	drow-cplus-branch:1.2.0.24
	drow-cplus-branchpoint:1.2
	kseitz_interps-20020930-merge:1.2
	carlton_dictionary-20020927-merge:1.2
	carlton_dictionary-branch:1.2.0.22
	carlton_dictionary-20020920-branchpoint:1.2
	gdb_5_3-branch:1.2.0.20
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.18
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.16
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.14
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.12
	cagney_regbuf-20020515-branchpoint:1.2
	jimb-macro-020506-branch:1.2.0.10
	jimb-macro-020506-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.8
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.2
	gdb_5_1_0_1-2002-01-03-release:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.4
	gdb_s390-2001-09-26-branchpoint:1.2
	gdb_5_1-2001-07-29-branch:1.2.0.2
	gdb_5_1-2001-07-29-branchpoint:1.2
	insight-precleanup-2001-01-01:1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2012.12.19.07.18.14;	author brobecke;	state Exp;
branches;
next	1.4;

1.4
date	2012.12.19.07.11.58;	author brobecke;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.12.07.36.58;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.15.23.55.50;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.55;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.55;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.02.05.07.30.19;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.5
log
@[sim] Update old contact info in GPL license notices

sim/ChangeLog:

        Update old contact info in GPL license notices.
@
text
@/*  armrdi.c -- ARMulator RDI interface:  ARM6 Instruction Emulator.
    Copyright (C) 1994 Advanced RISC Machines Ltd.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, see <http://www.gnu.org/licenses/>. */

#include <string.h>
#include <ctype.h>
#include "armdefs.h"
#include "armemu.h"
#include "armos.h"
#include "dbg_cp.h"
#include "dbg_conf.h"
#include "dbg_rdi.h"
#include "dbg_hif.h"
#include "communicate.h"

/***************************************************************************\
*                               Declarations                                *
\***************************************************************************/

#define Watch_AnyRead (RDIWatch_ByteRead+RDIWatch_HalfRead+RDIWatch_WordRead)
#define Watch_AnyWrite (RDIWatch_ByteWrite+RDIWatch_HalfWrite+RDIWatch_WordWrite)

static unsigned FPRegsAddr;	/* last known address of FPE regs */
#define FPESTART 0x2000L
#define FPEEND   0x8000L

#define IGNORE(d) (d = d)
#ifdef RDI_VERBOSE
#define TracePrint(s) \
 if (rdi_log & 1) ARMul_DebugPrint s
#else
#define TracePrint(s)
#endif

static ARMul_State *state = NULL;
static unsigned BreaksSet;	/* The number of breakpoints set */

static int rdi_log = 0;		/* debugging  ? */

#define LOWEST_RDI_LEVEL 0
#define HIGHEST_RDI_LEVEL 1
static int MYrdi_level = LOWEST_RDI_LEVEL;

typedef struct BreakNode BreakNode;
typedef struct WatchNode WatchNode;

struct BreakNode
{				/* A breakpoint list node */
  BreakNode *next;
  ARMword address;		/* The address of this breakpoint */
  unsigned type;		/* The type of comparison */
  ARMword bound;		/* The other address for a range */
  ARMword inst;
};

struct WatchNode
{				/* A watchpoint list node */
  WatchNode *next;
  ARMword address;		/* The address of this watchpoint */
  unsigned type;		/* The type of comparison */
  unsigned datatype;		/* The type of access to watch for */
  ARMword bound;		/* The other address for a range */
};

BreakNode *BreakList = NULL;
WatchNode *WatchList = NULL;

void
ARMul_DebugPrint_i (const Dbg_HostosInterface * hostif, const char *format,
		    ...)
{
  va_list ap;
  va_start (ap, format);
  hostif->dbgprint (hostif->dbgarg, format, ap);
  va_end (ap);
}

void
ARMul_DebugPrint (ARMul_State * state, const char *format, ...)
{
  va_list ap;
  va_start (ap, format);
  if (!(rdi_log & 8))
    state->hostif->dbgprint (state->hostif->dbgarg, format, ap);
  va_end (ap);
}

#define CONSOLE_PRINT_MAX_LEN 128

void
ARMul_ConsolePrint (ARMul_State * state, const char *format, ...)
{
  va_list ap;
  int ch;
  char *str, buf[CONSOLE_PRINT_MAX_LEN];
  int i, j;
  ARMword junk;

  va_start (ap, format);
  vsprintf (buf, format, ap);

  for (i = 0; buf[i]; i++);	/* The string is i chars long */

  str = buf;
  while (i >= 32)
    {
      MYwrite_char (kidmum[1], RDP_OSOp);
      MYwrite_word (kidmum[1], SWI_Write0);
      MYwrite_char (kidmum[1], OS_SendString);
      MYwrite_char (kidmum[1], 32);	/* Send string 32bytes at a time */
      for (j = 0; j < 32; j++, str++)
	MYwrite_char (kidmum[1], *str);
      wait_for_osreply (&junk);
      i -= 32;
    }

  if (i > 0)
    {
      MYwrite_char (kidmum[1], RDP_OSOp);
      MYwrite_word (kidmum[1], SWI_Write0);
      MYwrite_char (kidmum[1], OS_SendString);
      MYwrite_char (kidmum[1], (unsigned char) i);	/* Send remainder of string  */
      for (j = 0; j < i; j++, str++)
	MYwrite_char (kidmum[1], *str);
      wait_for_osreply (&junk);
    }

  va_end (ap);
  return;

/*   str = buf; */
/*   while ((ch=*str++) != 0) */
/*     state->hostif->writec(state->hostif->hostosarg, ch); */
}

void
ARMul_DebugPause (ARMul_State * state)
{
  if (!(rdi_log & 8))
    state->hostif->dbgpause (state->hostif->dbgarg);
}

/***************************************************************************\
*                                 RDI_open                                  *
\***************************************************************************/

static void
InitFail (int exitcode, char const *which)
{
  ARMul_ConsolePrint (state, "%s interface failed to initialise. Exiting\n",
		      which);
  exit (exitcode);
}

static void
RDIInit (unsigned type)
{
  if (type == 0)
    {				/* cold start */
      state->CallDebug = state->MemReadDebug = state->MemWriteDebug = 0;
      BreaksSet = 0;
    }
}

#define UNKNOWNPROC 0

typedef struct
{
  char name[16];
  unsigned properties;
}
Processor;

Processor const p_arm2 =    { "ARM2",   ARM_Fix26_Prop };
Processor const p_arm2as =  { "ARM2AS", ARM_Fix26_Prop };
Processor const p_arm61 =   { "ARM61",  ARM_Fix26_Prop };
Processor const p_arm3 =    { "ARM3",   ARM_Fix26_Prop };
Processor const p_arm6 =    { "ARM6",   ARM_Lock_Prop };
Processor const p_arm60 =   {  "ARM60", ARM_Lock_Prop };
Processor const p_arm600 =  { "ARM600", ARM_Lock_Prop };
Processor const p_arm610 =  { "ARM610", ARM_Lock_Prop };
Processor const p_arm620 =  { "ARM620", ARM_Lock_Prop };
Processor const p_unknown = { "",       0 };

Processor const *const processors[] =
{
  &p_arm6,			/* default: must come first */
  &p_arm2,
  &p_arm2as,
  &p_arm61,
  &p_arm3,
  &p_arm60,
  &p_arm600,
  &p_arm610,
  &p_arm620,
  &p_unknown
};

typedef struct ProcessorConfig ProcessorConfig;
struct ProcessorConfig
{
  long id[2];
  ProcessorConfig const *self;
  long count;
  Processor const *const *processors;
};

ProcessorConfig const processorconfig = {
  {((((((long) 'x' << 8) | ' ') << 8) | 'c') << 8) | 'p',
   ((((((long) 'u' << 8) | 's') << 8) | ' ') << 8) | 'x'},
  &processorconfig,
  16,
  processors
};

static int
RDI_open (unsigned type, const Dbg_ConfigBlock * config,
	  const Dbg_HostosInterface * hostif, struct Dbg_MCState *dbg_state)
/* Initialise everything */
{
  int virgin = (state == NULL);
  IGNORE (dbg_state);

#ifdef RDI_VERBOSE
  if (rdi_log & 1)
    {
      if (virgin)
	ARMul_DebugPrint_i (hostif, "RDI_open: type = %d\n", type);
      else
	ARMul_DebugPrint (state, "RDI_open: type = %d\n", type);
    }
#endif

  if (type & 1)
    {				/* Warm start */
      ARMul_Reset (state);
      RDIInit (1);
    }
  else
    {
      if (virgin)
	{
	  ARMul_EmulateInit ();
	  state = ARMul_NewState ();
	  state->hostif = hostif;
	  {
	    int req = config->processor;
	    unsigned processor = processors[req]->val;
	    ARMul_SelectProcessor (state, processor);
	    ARMul_Reset (state);
	    ARMul_ConsolePrint (state, "ARMulator V1.50, %s",
				processors[req]->name);
	  }
	  if (ARMul_MemoryInit (state, config->memorysize) == FALSE)
	    InitFail (1, "Memory");
	  if (config->bytesex != RDISex_DontCare)
	    state->bigendSig = config->bytesex;
	  if (ARMul_CoProInit (state) == FALSE)
	    InitFail (2, "Co-Processor");
	  if (ARMul_OSInit (state) == FALSE)
	    InitFail (3, "Operating System");
	}
      ARMul_Reset (state);
      RDIInit (0);
    }
  if (type & 2)
    {				/* Reset the comms link */
      /* what comms link ? */
    }
  if (virgin && (type & 1) == 0)	/* Cold start */
    ARMul_ConsolePrint (state, ", %s endian.\n",
			state->bigendSig ? "Big" : "Little");

  if (config->bytesex == RDISex_DontCare)
    return (state->bigendSig ? RDIError_BigEndian : RDIError_LittleEndian);
  else
    return (RDIError_NoError);
}

/***************************************************************************\
*                                RDI_close                                  *
\***************************************************************************/

static int
RDI_close (void)
{
  TracePrint ((state, "RDI_close\n"));
  ARMul_OSExit (state);
  ARMul_CoProExit (state);
  ARMul_MemoryExit (state);
  return (RDIError_NoError);
}

/***************************************************************************\
*                                 RDI_read                                  *
\***************************************************************************/

static int
RDI_read (ARMword source, void *dest, unsigned *nbytes)
{
  unsigned i;
  char *memptr = (char *) dest;

  TracePrint ((state, "RDI_read: source=%.8lx dest=%p nbytes=%.8x\n",
	       source, dest, *nbytes));

  for (i = 0; i < *nbytes; i++)
    *memptr++ = (char) ARMul_ReadByte (state, source++);
  if (state->abortSig)
    {
      state->abortSig = LOW;
      return (RDIError_DataAbort);
    }
  return (RDIError_NoError);
}

/***************************************************************************\
*                                  RDI_write                                *
\***************************************************************************/

static int
RDI_write (const void *source, ARMword dest, unsigned *nbytes)
{
  unsigned i;
  char *memptr = (char *) source;

  TracePrint ((state, "RDI_write: source=%p dest=%.8lx nbytes=%.8x\n",
	       source, dest, *nbytes));

  for (i = 0; i < *nbytes; i++)
    ARMul_WriteByte (state, (ARMword) dest++, (ARMword) * memptr++);

  if (state->abortSig)
    {
      state->abortSig = LOW;
      return (RDIError_DataAbort);
    }
  return (RDIError_NoError);
}

/***************************************************************************\
*                                RDI_CPUread                                *
\***************************************************************************/

static int
RDI_CPUread (unsigned mode, unsigned long mask, ARMword buffer[])
{
  unsigned i, upto;

  if (mode == RDIMode_Curr)
    mode = (unsigned) (ARMul_GetCPSR (state) & MODEBITS);

  for (upto = 0, i = 0; i < 15; i++)
    if (mask & (1L << i))
      {
	buffer[upto++] = ARMul_GetReg (state, mode, i);
      }

  if (mask & RDIReg_R15)
    {
      buffer[upto++] = ARMul_GetR15 (state);
    }

  if (mask & RDIReg_PC)
    {
      buffer[upto++] = ARMul_GetPC (state);
    }

  if (mask & RDIReg_CPSR)
    buffer[upto++] = ARMul_GetCPSR (state);

  if (mask & RDIReg_SPSR)
    buffer[upto++] = ARMul_GetSPSR (state, mode);

  TracePrint ((state, "RDI_CPUread: mode=%.8x mask=%.8lx", mode, mask));
#ifdef RDI_VERBOSE
  if (rdi_log & 1)
    {
      for (upto = 0, i = 0; i <= 20; i++)
	if (mask & (1L << i))
	  {
	    ARMul_DebugPrint (state, "%c%.8lx", upto % 4 == 0 ? '\n' : ' ',
			      buffer[upto]);
	    upto++;
	  }
      ARMul_DebugPrint (state, "\n");
    }
#endif

  return (RDIError_NoError);
}

/***************************************************************************\
*                               RDI_CPUwrite                                *
\***************************************************************************/

static int
RDI_CPUwrite (unsigned mode, unsigned long mask, ARMword const buffer[])
{
  int i, upto;


  TracePrint ((state, "RDI_CPUwrite: mode=%.8x mask=%.8lx", mode, mask));
#ifdef RDI_VERBOSE
  if (rdi_log & 1)
    {
      for (upto = 0, i = 0; i <= 20; i++)
	if (mask & (1L << i))
	  {
	    ARMul_DebugPrint (state, "%c%.8lx", upto % 4 == 0 ? '\n' : ' ',
			      buffer[upto]);
	    upto++;
	  }
      ARMul_DebugPrint (state, "\n");
    }
#endif

  if (mode == RDIMode_Curr)
    mode = (unsigned) (ARMul_GetCPSR (state) & MODEBITS);

  for (upto = 0, i = 0; i < 15; i++)
    if (mask & (1L << i))
      ARMul_SetReg (state, mode, i, buffer[upto++]);

  if (mask & RDIReg_R15)
    ARMul_SetR15 (state, buffer[upto++]);

  if (mask & RDIReg_PC)
    {

      ARMul_SetPC (state, buffer[upto++]);
    }
  if (mask & RDIReg_CPSR)
    ARMul_SetCPSR (state, buffer[upto++]);

  if (mask & RDIReg_SPSR)
    ARMul_SetSPSR (state, mode, buffer[upto++]);

  return (RDIError_NoError);
}

/***************************************************************************\
*                                RDI_CPread                                 *
\***************************************************************************/

static int
RDI_CPread (unsigned CPnum, unsigned long mask, ARMword buffer[])
{
  ARMword fpregsaddr, word[4];

  unsigned r, w;
  unsigned upto;

  if (CPnum != 1 && CPnum != 2)
    {
      unsigned char const *rmap = state->CPRegWords[CPnum];
      if (rmap == NULL)
	return (RDIError_UnknownCoPro);
      for (upto = 0, r = 0; r < rmap[-1]; r++)
	if (mask & (1L << r))
	  {
	    (void) state->CPRead[CPnum] (state, r, &buffer[upto]);
	    upto += rmap[r];
	  }
      TracePrint ((state, "RDI_CPread: CPnum=%d mask=%.8lx", CPnum, mask));
#ifdef RDI_VERBOSE
      if (rdi_log & 1)
	{
	  w = 0;
	  for (upto = 0, r = 0; r < rmap[-1]; r++)
	    if (mask & (1L << r))
	      {
		int words = rmap[r];
		ARMul_DebugPrint (state, "%c%2d",
				  (w >= 4 ? (w = 0, '\n') : ' '), r);
		while (--words >= 0)
		  {
		    ARMul_DebugPrint (state, " %.8lx", buffer[upto++]);
		    w++;
		  }
	      }
	  ARMul_DebugPrint (state, "\n");
	}
#endif
      return RDIError_NoError;
    }

#ifdef NOFPE
  return RDIError_UnknownCoPro;

#else
  if (FPRegsAddr == 0)
    {
      fpregsaddr = ARMul_ReadWord (state, 4L);
      if ((fpregsaddr & 0xff800000) != 0xea000000)	/* Must be a forward branch */
	return RDIError_UnknownCoPro;
      fpregsaddr = ((fpregsaddr & 0xffffff) << 2) + 8;	/* address in __fp_decode - 4 */
      if ((fpregsaddr < FPESTART) || (fpregsaddr >= FPEEND))
	return RDIError_UnknownCoPro;
      fpregsaddr = ARMul_ReadWord (state, fpregsaddr);	/* pointer to fp registers */
      FPRegsAddr = fpregsaddr;
    }
  else
    fpregsaddr = FPRegsAddr;

  if (fpregsaddr == 0)
    return RDIError_UnknownCoPro;
  for (upto = 0, r = 0; r < 8; r++)
    if (mask & (1L << r))
      {
	for (w = 0; w < 4; w++)
	  word[w] =
	    ARMul_ReadWord (state,
			    fpregsaddr + (ARMword) r * 16 + (ARMword) w * 4);
	switch ((int) (word[3] >> 29))
	  {
	  case 0:
	  case 2:
	  case 4:
	  case 6:		/* its unpacked, convert to extended */
	    buffer[upto++] = 2;	/* mark as extended */
	    buffer[upto++] = (word[3] & 0x7fff) | (word[0] & 0x80000000);	/* exp and sign */
	    buffer[upto++] = word[1];	/* mantissa 1 */
	    buffer[upto++] = word[2];	/* mantissa 2 */
	    break;
	  case 1:		/* packed single */
	    buffer[upto++] = 0;	/* mark as single */
	    buffer[upto++] = word[0];	/* sign, exp and mantissa */
	    buffer[upto++] = word[1];	/* padding */
	    buffer[upto++] = word[2];	/* padding */
	    break;
	  case 3:		/* packed double */
	    buffer[upto++] = 1;	/* mark as double */
	    buffer[upto++] = word[0];	/* sign, exp and mantissa1 */
	    buffer[upto++] = word[1];	/* mantissa 2 */
	    buffer[upto++] = word[2];	/* padding */
	    break;
	  case 5:		/* packed extended */
	    buffer[upto++] = 2;	/* mark as extended */
	    buffer[upto++] = word[0];	/* sign and exp */
	    buffer[upto++] = word[1];	/* mantissa 1 */
	    buffer[upto++] = word[2];	/* mantissa 2 */
	    break;
	  case 7:		/* packed decimal */
	    buffer[upto++] = 3;	/* mark as packed decimal */
	    buffer[upto++] = word[0];	/* sign, exp and mantissa1 */
	    buffer[upto++] = word[1];	/* mantissa 2 */
	    buffer[upto++] = word[2];	/* mantissa 3 */
	    break;
	  }
      }
  if (mask & (1L << r))
    buffer[upto++] = ARMul_ReadWord (state, fpregsaddr + 128);	/* fpsr */
  if (mask & (1L << (r + 1)))
    buffer[upto++] = 0;		/* fpcr */

  TracePrint ((state, "RDI_CPread: CPnum=%d mask=%.8lx\n", CPnum, mask));
#ifdef RDI_VERBOSE
  if (rdi_log & 1)
    {
      for (upto = 0, r = 0; r < 9; r++)
	if (mask & (1L << r))
	  {
	    if (r != 8)
	      {
		ARMul_DebugPrint (state, "%08lx ", buffer[upto++]);
		ARMul_DebugPrint (state, "%08lx ", buffer[upto++]);
		ARMul_DebugPrint (state, "%08lx ", buffer[upto++]);
	      }
	    ARMul_DebugPrint (state, "%08lx\n", buffer[upto++]);
	  }
      ARMul_DebugPrint (state, "\n");
    }
#endif
  return (RDIError_NoError);
#endif /* NOFPE */
}

/***************************************************************************\
*                               RDI_CPwrite                                 *
\***************************************************************************/

static int
RDI_CPwrite (unsigned CPnum, unsigned long mask, ARMword const buffer[])
{
  unsigned r;
  unsigned upto;
  ARMword fpregsaddr;

  if (CPnum != 1 && CPnum != 2)
    {
      unsigned char const *rmap = state->CPRegWords[CPnum];
      if (rmap == NULL)
	return (RDIError_UnknownCoPro);
      TracePrint ((state, "RDI_CPwrite: CPnum=%d mask=%.8lx", CPnum, mask));
#ifdef RDI_VERBOSE
      if (rdi_log & 1)
	{
	  int w = 0;
	  for (upto = 0, r = 0; r < rmap[-1]; r++)
	    if (mask & (1L << r))
	      {
		int words = rmap[r];
		ARMul_DebugPrint (state, "%c%2d",
				  (w >= 4 ? (w = 0, '\n') : ' '), r);
		while (--words >= 0)
		  {
		    ARMul_DebugPrint (state, " %.8lx", buffer[upto++]);
		    w++;
		  }
	      }
	  ARMul_DebugPrint (state, "\n");
	}
#endif
      for (upto = 0, r = 0; r < rmap[-1]; r++)
	if (mask & (1L << r))
	  {
	    (void) state->CPWrite[CPnum] (state, r, &buffer[upto]);
	    upto += rmap[r];
	  }
      return RDIError_NoError;
    }

#ifdef NOFPE
  return RDIError_UnknownCoPro;

#else
  TracePrint ((state, "RDI_CPwrite: CPnum=%d mask=%.8lx", CPnum, mask));
#ifdef RDI_VERBOSE
  if (rdi_log & 1)
    {
      for (upto = 0, r = 0; r < 9; r++)
	if (mask & (1L << r))
	  {
	    if (r != 8)
	      {
		ARMul_DebugPrint (state, "%08lx ", buffer[upto++]);
		ARMul_DebugPrint (state, "%08lx ", buffer[upto++]);
		ARMul_DebugPrint (state, "%08lx ", buffer[upto++]);
	      }
	    ARMul_DebugPrint (state, "%08lx\n", buffer[upto++]);
	  }
      ARMul_DebugPrint (state, "\n");
    }
#endif

  if (FPRegsAddr == 0)
    {
      fpregsaddr = ARMul_ReadWord (state, 4L);
      if ((fpregsaddr & 0xff800000) != 0xea000000)	/* Must be a forward branch */
	return RDIError_UnknownCoPro;
      fpregsaddr = ((fpregsaddr & 0xffffff) << 2) + 8;	/* address in __fp_decode - 4 */
      if ((fpregsaddr < FPESTART) || (fpregsaddr >= FPEEND))
	return RDIError_UnknownCoPro;
      fpregsaddr = ARMul_ReadWord (state, fpregsaddr);	/* pointer to fp registers */
      FPRegsAddr = fpregsaddr;
    }
  else
    fpregsaddr = FPRegsAddr;

  if (fpregsaddr == 0)
    return RDIError_UnknownCoPro;
  for (upto = 0, r = 0; r < 8; r++)
    if (mask & (1L << r))
      {
	ARMul_WriteWord (state, fpregsaddr + (ARMword) r * 16,
			 buffer[upto + 1]);
	ARMul_WriteWord (state, fpregsaddr + (ARMword) r * 16 + 4,
			 buffer[upto + 2]);
	ARMul_WriteWord (state, fpregsaddr + (ARMword) r * 16 + 8,
			 buffer[upto + 3]);
	ARMul_WriteWord (state, fpregsaddr + (ARMword) r * 16 + 12,
			 (buffer[upto] * 2 + 1) << 29);	/* mark type */
	upto += 4;
      }
  if (mask & (1L << r))
    ARMul_WriteWord (state, fpregsaddr + 128, buffer[upto++]);	/* fpsr */
  return (RDIError_NoError);
#endif /* NOFPE */
}

static void
deletebreaknode (BreakNode ** prevp)
{
  BreakNode *p = *prevp;
  *prevp = p->next;
  ARMul_WriteWord (state, p->address, p->inst);
  free ((char *) p);
  BreaksSet--;
  state->CallDebug--;
}

static int
removebreak (ARMword address, unsigned type)
{
  BreakNode *p, **prevp = &BreakList;
  for (; (p = *prevp) != NULL; prevp = &p->next)
    if (p->address == address && p->type == type)
      {
	deletebreaknode (prevp);
	return TRUE;
      }
  return FALSE;
}

/* This routine installs a breakpoint into the breakpoint table */

static BreakNode *
installbreak (ARMword address, unsigned type, ARMword bound)
{
  BreakNode *p = (BreakNode *) malloc (sizeof (BreakNode));
  p->next = BreakList;
  BreakList = p;
  p->address = address;
  p->type = type;
  p->bound = bound;
  p->inst = ARMul_ReadWord (state, address);
  ARMul_WriteWord (state, address, 0xee000000L);
  return p;
}

/***************************************************************************\
*                               RDI_setbreak                                *
\***************************************************************************/

static int
RDI_setbreak (ARMword address, unsigned type, ARMword bound,
	      PointHandle * handle)
{
  BreakNode *p;
  TracePrint ((state, "RDI_setbreak: address=%.8lx type=%d bound=%.8lx\n",
	       address, type, bound));

  removebreak (address, type);
  p = installbreak (address, type, bound);
  BreaksSet++;
  state->CallDebug++;
  *handle = (PointHandle) p;
  TracePrint ((state, " returns %.8lx\n", *handle));
  return RDIError_NoError;
}

/***************************************************************************\
*                               RDI_clearbreak                              *
\***************************************************************************/

static int
RDI_clearbreak (PointHandle handle)
{
  TracePrint ((state, "RDI_clearbreak: address=%.8lx\n", handle));
  {
    BreakNode *p, **prevp = &BreakList;
    for (; (p = *prevp) != NULL; prevp = &p->next)
      if (p == (BreakNode *) handle)
	break;
    if (p == NULL)
      return RDIError_NoSuchPoint;
    deletebreaknode (prevp);
    return RDIError_NoError;
  }
}

/***************************************************************************\
*            Internal functions for breakpoint table manipulation           *
\***************************************************************************/

static void
deletewatchnode (WatchNode ** prevp)
{
  WatchNode *p = *prevp;
  if (p->datatype & Watch_AnyRead)
    state->MemReadDebug--;
  if (p->datatype & Watch_AnyWrite)
    state->MemWriteDebug--;
  *prevp = p->next;
  free ((char *) p);
}

int
removewatch (ARMword address, unsigned type)
{
  WatchNode *p, **prevp = &WatchList;
  for (; (p = *prevp) != NULL; prevp = &p->next)
    if (p->address == address && p->type == type)
      {				/* found a match */
	deletewatchnode (prevp);
	return TRUE;
      }
  return FALSE;			/* never found a match */
}

static WatchNode *
installwatch (ARMword address, unsigned type, unsigned datatype,
	      ARMword bound)
{
  WatchNode *p = (WatchNode *) malloc (sizeof (WatchNode));
  p->next = WatchList;
  WatchList = p;
  p->address = address;
  p->type = type;
  p->datatype = datatype;
  p->bound = bound;
  return p;
}

/***************************************************************************\
*                               RDI_setwatch                                *
\***************************************************************************/

static int
RDI_setwatch (ARMword address, unsigned type, unsigned datatype,
	      ARMword bound, PointHandle * handle)
{
  WatchNode *p;
  TracePrint (
	      (state,
	       "RDI_setwatch: address=%.8lx type=%d datatype=%d bound=%.8lx",
	       address, type, datatype, bound));

  if (!state->CanWatch)
    return RDIError_UnimplementedMessage;

  removewatch (address, type);
  p = installwatch (address, type, datatype, bound);
  if (datatype & Watch_AnyRead)
    state->MemReadDebug++;
  if (datatype & Watch_AnyWrite)
    state->MemWriteDebug++;
  *handle = (PointHandle) p;
  TracePrint ((state, " returns %.8lx\n", *handle));
  return RDIError_NoError;
}

/***************************************************************************\
*                               RDI_clearwatch                              *
\***************************************************************************/

static int
RDI_clearwatch (PointHandle handle)
{
  TracePrint ((state, "RDI_clearwatch: address=%.8lx\n", handle));
  {
    WatchNode *p, **prevp = &WatchList;
    for (; (p = *prevp) != NULL; prevp = &p->next)
      if (p == (WatchNode *) handle)
	break;
    if (p == NULL)
      return RDIError_NoSuchPoint;
    deletewatchnode (prevp);
    return RDIError_NoError;
  }
}

/***************************************************************************\
*                               RDI_execute                                 *
\***************************************************************************/

static int
RDI_execute (PointHandle * handle)
{
  TracePrint ((state, "RDI_execute\n"));
  if (rdi_log & 4)
    {
      state->CallDebug++;
      state->Debug = TRUE;
    }
  state->EndCondition = RDIError_NoError;
  state->StopHandle = 0;

  ARMul_DoProg (state);

  *handle = state->StopHandle;
  state->Reg[15] -= 8;		/* undo the pipeline */
  if (rdi_log & 4)
    {
      state->CallDebug--;
      state->Debug = FALSE;
    }
  return (state->EndCondition);
}

/***************************************************************************\
*                                RDI_step                                   *
\***************************************************************************/

static int
RDI_step (unsigned ninstr, PointHandle * handle)
{

  TracePrint ((state, "RDI_step\n"));
  if (ninstr != 1)
    return RDIError_UnimplementedMessage;
  if (rdi_log & 4)
    {
      state->CallDebug++;
      state->Debug = TRUE;
    }
  state->EndCondition = RDIError_NoError;
  state->StopHandle = 0;
  ARMul_DoInstr (state);
  *handle = state->StopHandle;
  state->Reg[15] -= 8;		/* undo the pipeline */
  if (rdi_log & 4)
    {
      state->CallDebug--;
      state->Debug = FALSE;
    }
  return (state->EndCondition);
}

/***************************************************************************\
*                               RDI_info                                    *
\***************************************************************************/

static int
RDI_info (unsigned type, ARMword * arg1, ARMword * arg2)
{
  switch (type)
    {
    case RDIInfo_Target:
      TracePrint ((state, "RDI_Info_Target\n"));
      /* Emulator, speed 10**5 IPS */
      *arg1 = 5 | HIGHEST_RDI_LEVEL << 5 | LOWEST_RDI_LEVEL << 8;
      *arg2 = 1298224434;
      return RDIError_NoError;

    case RDIInfo_Points:
      {
	ARMword n = RDIPointCapability_Comparison | RDIPointCapability_Range |
	  RDIPointCapability_Mask | RDIPointCapability_Status;
	TracePrint ((state, "RDI_Info_Points\n"));
	if (state->CanWatch)
	  n |= (Watch_AnyRead + Watch_AnyWrite) << 2;
	*arg1 = n;
	return RDIError_NoError;
      }

    case RDIInfo_Step:
      TracePrint ((state, "RDI_Info_Step\n"));
      *arg1 = RDIStep_Single;
      return RDIError_NoError;

    case RDIInfo_MMU:
      TracePrint ((state, "RDI_Info_MMU\n"));
      *arg1 = 1313820229;
      return RDIError_NoError;

    case RDISignal_Stop:
      TracePrint ((state, "RDISignal_Stop\n"));
      state->CallDebug++;
      state->EndCondition = RDIError_UserInterrupt;
      return RDIError_NoError;

    case RDIVector_Catch:
      TracePrint ((state, "RDIVector_Catch %.8lx\n", *arg1));
      state->VectorCatch = (unsigned) *arg1;
      return RDIError_NoError;

    case RDISet_Cmdline:
      TracePrint ((state, "RDI_Set_Cmdline %s\n", (char *) arg1));
      state->CommandLine =
	(char *) malloc ((unsigned) strlen ((char *) arg1) + 1);
      (void) strcpy (state->CommandLine, (char *) arg1);
      return RDIError_NoError;

    case RDICycles:
      TracePrint ((state, "RDI_Info_Cycles\n"));
      arg1[0] = 0;
      arg1[1] = state->NumInstrs;
      arg1[2] = 0;
      arg1[3] = state->NumScycles;
      arg1[4] = 0;
      arg1[5] = state->NumNcycles;
      arg1[6] = 0;
      arg1[7] = state->NumIcycles;
      arg1[8] = 0;
      arg1[9] = state->NumCcycles;
      arg1[10] = 0;
      arg1[11] = state->NumFcycles;
      return RDIError_NoError;

    case RDIErrorP:
      *arg1 = ARMul_OSLastErrorP (state);
      TracePrint ((state, "RDI_ErrorP returns %ld\n", *arg1));
      return RDIError_NoError;

    case RDIInfo_DescribeCoPro:
      {
	int cpnum = *(int *) arg1;
	struct Dbg_CoProDesc *cpd = (struct Dbg_CoProDesc *) arg2;
	int i;
	unsigned char const *map = state->CPRegWords[cpnum];
	if (map == NULL)
	  return RDIError_UnknownCoPro;
	for (i = 0; i < cpd->entries; i++)
	  {
	    unsigned r, w = cpd->regdesc[i].nbytes / sizeof (ARMword);
	    for (r = cpd->regdesc[i].rmin; r <= cpd->regdesc[i].rmax; r++)
	      if (map[r] != w)
		return RDIError_BadCoProState;
	  }
	return RDIError_NoError;
      }

    case RDIInfo_RequestCoProDesc:
      {
	int cpnum = *(int *) arg1;
	struct Dbg_CoProDesc *cpd = (struct Dbg_CoProDesc *) arg2;
	int i = -1, lastw = -1, r;
	unsigned char const *map;
	if ((unsigned) cpnum >= 16)
	  return RDIError_UnknownCoPro;
	map = state->CPRegWords[cpnum];
	if (map == NULL)
	  return RDIError_UnknownCoPro;
	for (r = 0; r < map[-1]; r++)
	  {
	    int words = map[r];
	    if (words == lastw)
	      cpd->regdesc[i].rmax = r;
	    else
	      {
		if (++i >= cpd->entries)
		  return RDIError_BufferFull;
		cpd->regdesc[i].rmax = cpd->regdesc[i].rmin = r;
		cpd->regdesc[i].nbytes = words * sizeof (ARMword);
		cpd->regdesc[i].access =
		  Dbg_Access_Readable + Dbg_Access_Writable;
	      }
	  }
	cpd->entries = i + 1;
	return RDIError_NoError;
      }

    case RDIInfo_Log:
      *arg1 = (ARMword) rdi_log;
      return RDIError_NoError;

    case RDIInfo_SetLog:
      rdi_log = (int) *arg1;
      return RDIError_NoError;

    case RDIInfo_CoPro:
      return RDIError_NoError;

    case RDIPointStatus_Watch:
      {
	WatchNode *p, *handle = (WatchNode *) * arg1;
	for (p = WatchList; p != NULL; p = p->next)
	  if (p == handle)
	    {
	      *arg1 = -1;
	      *arg2 = 1;
	      return RDIError_NoError;
	    }
	return RDIError_NoSuchPoint;
      }

    case RDIPointStatus_Break:
      {
	BreakNode *p, *handle = (BreakNode *) * arg1;
	for (p = BreakList; p != NULL; p = p->next)
	  if (p == handle)
	    {
	      *arg1 = -1;
	      *arg2 = 1;
	      return RDIError_NoError;
	    }
	return RDIError_NoSuchPoint;
      }

    case RDISet_RDILevel:
      if (*arg1 < LOWEST_RDI_LEVEL || *arg1 > HIGHEST_RDI_LEVEL)
	return RDIError_IncompatibleRDILevels;
      MYrdi_level = *arg1;
      return RDIError_NoError;

    default:
      return RDIError_UnimplementedMessage;

    }
}

/***************************************************************************\
* The emulator calls this routine at the beginning of every cycle when the  *
* CallDebug flag is set.  The second parameter passed is the address of the *
* currently executing instruction (i.e Program Counter - 8), the third      *
* parameter is the instruction being executed.                              *
\***************************************************************************/

ARMword
ARMul_Debug (ARMul_State * state, ARMword pc, ARMword instr)
{

  if (state->EndCondition == RDIError_UserInterrupt)
    {
      TracePrint ((state, "User interrupt at %.8lx\n", pc));
      state->CallDebug--;
      state->Emulate = STOP;
    }
  else
    {
      BreakNode *p = BreakList;
      for (; p != NULL; p = p->next)
	{
	  switch (p->type)
	    {
	    case RDIPoint_EQ:
	      if (pc == p->address)
		break;
	      continue;
	    case RDIPoint_GT:
	      if (pc > p->address)
		break;
	      continue;
	    case RDIPoint_GE:
	      if (pc >= p->address)
		break;
	      continue;
	    case RDIPoint_LT:
	      if (pc < p->address)
		break;
	      continue;
	    case RDIPoint_LE:
	      if (pc <= p->address)
		break;
	      continue;
	    case RDIPoint_IN:
	      if (p->address <= pc && pc < p->address + p->bound)
		break;
	      continue;
	    case RDIPoint_OUT:
	      if (p->address > pc || pc >= p->address + p->bound)
		break;
	      continue;
	    case RDIPoint_MASK:
	      if ((pc & p->bound) == p->address)
		break;
	      continue;
	    }
	  /* found a match */
	  TracePrint ((state, "Breakpoint reached at %.8lx\n", pc));
	  state->EndCondition = RDIError_BreakpointReached;
	  state->Emulate = STOP;
	  state->StopHandle = (ARMword) p;
	  break;
	}
    }
  return instr;
}

void
ARMul_CheckWatch (ARMul_State * state, ARMword addr, int access)
{
  WatchNode *p;
  for (p = WatchList; p != NULL; p = p->next)
    if (p->datatype & access)
      {
	switch (p->type)
	  {
	  case RDIPoint_EQ:
	    if (addr == p->address)
	      break;
	    continue;
	  case RDIPoint_GT:
	    if (addr > p->address)
	      break;
	    continue;
	  case RDIPoint_GE:
	    if (addr >= p->address)
	      break;
	    continue;
	  case RDIPoint_LT:
	    if (addr < p->address)
	      break;
	    continue;
	  case RDIPoint_LE:
	    if (addr <= p->address)
	      break;
	    continue;
	  case RDIPoint_IN:
	    if (p->address <= addr && addr < p->address + p->bound)
	      break;
	    continue;
	  case RDIPoint_OUT:
	    if (p->address > addr || addr >= p->address + p->bound)
	      break;
	    continue;
	  case RDIPoint_MASK:
	    if ((addr & p->bound) == p->address)
	      break;
	    continue;
	  }
	/* found a match */
	TracePrint ((state, "Watchpoint at %.8lx accessed\n", addr));
	state->EndCondition = RDIError_WatchpointAccessed;
	state->Emulate = STOP;
	state->StopHandle = (ARMword) p;
	return;
      }
}

static RDI_NameList const *
RDI_cpunames ()
{
  return (RDI_NameList const *) &processorconfig.count;
}

const struct RDIProcVec armul_rdi = {
  "ARMUL",
  RDI_open,
  RDI_close,
  RDI_read,
  RDI_write,
  RDI_CPUread,
  RDI_CPUwrite,
  RDI_CPread,
  RDI_CPwrite,
  RDI_setbreak,
  RDI_clearbreak,
  RDI_setwatch,
  RDI_clearwatch,
  RDI_execute,
  RDI_step,
  RDI_info,

  0,				/*pointinq */
  0,				/*addconfig */
  0,				/*loadconfigdata */
  0,				/*selectconfig */
  0,				/*drivernames */

  RDI_cpunames
};
@


1.4
log
@Update sim copyright headers from GPLv2-or-later to GPLv3-or-later.

gdb/sim/ChangeLog:

        Update the non-FSF-copyrighted files in sim to GPLv3 or later.
@
text
@d15 1
a15 2
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA. */
@


1.3
log
@Update the address of the FSF organization
@
text
@d6 1
a6 1
    the Free Software Foundation; either version 2 of the License, or
@


1.2
log
@Replace StrongARM property with v4 and v5 properties.
@
text
@d16 1
a16 1
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
@


1.1
log
@Initial revision
@
text
@d36 1
a36 1
static unsigned FPRegsAddr ; /* last known address of FPE regs */
d48 2
a49 2
static ARMul_State *state = NULL ;
static unsigned BreaksSet ; /* The number of breakpoints set */
d51 1
a51 1
static int rdi_log = 0 ; /* debugging  ? */
d60 39
a98 32
struct BreakNode { /* A breakpoint list node */
   BreakNode *next ;
   ARMword address ; /* The address of this breakpoint */
   unsigned type ; /* The type of comparison */
   ARMword bound ; /* The other address for a range */
   ARMword inst;
   };

struct WatchNode { /* A watchpoint list node */
   WatchNode *next ;
   ARMword address ; /* The address of this watchpoint */
   unsigned type ; /* The type of comparison */
   unsigned datatype ; /* The type of access to watch for */
   ARMword bound ; /* The other address for a range */
   };

BreakNode *BreakList = NULL ;
WatchNode *WatchList = NULL ;

void ARMul_DebugPrint_i(const Dbg_HostosInterface *hostif, const char *format, ...)
{ va_list ap;
  va_start(ap, format);
  hostif->dbgprint(hostif->dbgarg, format, ap);
  va_end(ap);
}

void ARMul_DebugPrint(ARMul_State *state, const char *format, ...)
{ va_list ap;
  va_start(ap, format);
  if(!(rdi_log & 8))
    state->hostif->dbgprint(state->hostif->dbgarg, format, ap);
  va_end(ap);
d103 2
a104 1
void ARMul_ConsolePrint(ARMul_State *state, const char *format, ...)
d112 4
a115 2
  va_start(ap, format);
  vsprintf(buf, format, ap);
a116 2
  for (i = 0; buf[i] ;i++);  /* The string is i chars long */
  
d118 22
a139 20
  while (i >= 32) {
    MYwrite_char(kidmum[1], RDP_OSOp); 
    MYwrite_word(kidmum[1], SWI_Write0);
    MYwrite_char(kidmum[1], OS_SendString);
    MYwrite_char(kidmum[1], 32); /* Send string 32bytes at a time */
    for (j = 0; j < 32; j++, str++)
      MYwrite_char(kidmum[1], *str);
    wait_for_osreply(&junk);
    i -= 32;
  }
  
  if (i > 0) {
    MYwrite_char(kidmum[1], RDP_OSOp);
    MYwrite_word(kidmum[1], SWI_Write0);
    MYwrite_char(kidmum[1], OS_SendString);
    MYwrite_char(kidmum[1], (unsigned char) i); /* Send remainder of string  */
    for (j = 0; j < i; j++, str++)
      MYwrite_char(kidmum[1], *str);
    wait_for_osreply(&junk);
  }
d149 2
a150 1
void ARMul_DebugPause(ARMul_State *state)
d152 2
a153 2
  if(!(rdi_log & 8))
  state->hostif->dbgpause(state->hostif->dbgarg);
d160 6
a165 4
static void InitFail(int exitcode, char const *which) {
  ARMul_ConsolePrint(state, "%s interface failed to initialise. Exiting\n",
                            which);
  exit(exitcode);
d168 7
a174 4
static void RDIInit(unsigned type)
{if (type == 0) { /* cold start */
    state->CallDebug = state->MemReadDebug = state->MemWriteDebug = 0 ;
    BreaksSet = 0 ;
d176 1
a176 1
 }
d180 6
a185 1
typedef struct { char name[16]; unsigned val; } Processor;
d187 10
a196 10
Processor const p_arm2   = {"ARM2",    ARM2};
Processor const p_arm2as = {"ARM2AS",  ARM2as};
Processor const p_arm61  = {"ARM61",   ARM61};
Processor const p_arm3   = {"ARM3",    ARM3};
Processor const p_arm6   = {"ARM6",    ARM6};
Processor const p_arm60  = {"ARM60",   ARM60};
Processor const p_arm600 = {"ARM600",  ARM600};
Processor const p_arm610 = {"ARM610",  ARM610};
Processor const p_arm620 = {"ARM620",  ARM620};
Processor const p_unknown= {"",      UNKNOWNPROC};
d198 3
a200 2
Processor const *const processors[] = {
  &p_arm6,  /* default: must come first */
d213 2
a214 1
struct ProcessorConfig {
d218 1
a218 1
  Processor const * const *processors;
d222 2
a223 3
  { ((((((long)'x' << 8) | ' ') << 8) | 'c') << 8) | 'p',
    ((((((long)'u' << 8) | 's') << 8) | ' ') << 8) | 'x'
  },
d229 3
a231 3
static int RDI_open(unsigned type, const Dbg_ConfigBlock *config,
                    const Dbg_HostosInterface *hostif,
                    struct Dbg_MCState *dbg_state)
d233 3
a235 2
{int virgin = (state == NULL);
 IGNORE(dbg_state);
d238 7
a244 6
 if (rdi_log & 1) {
    if (virgin)
       ARMul_DebugPrint_i(hostif, "RDI_open: type = %d\n",type) ;
    else
       ARMul_DebugPrint(state, "RDI_open: type = %d\n",type) ;
 }
d247 39
a285 33
 if (type & 1) { /* Warm start */
    ARMul_Reset(state) ;
    RDIInit(1) ;
    }
 else {
   if (virgin) {
     ARMul_EmulateInit();
     state = ARMul_NewState();
     state->hostif = hostif;
     { int req = config->processor;
       unsigned processor = processors[req]->val;
       ARMul_SelectProcessor(state, processor);
       ARMul_Reset(state);
       ARMul_ConsolePrint(state, "ARMulator V1.50, %s", processors[req]->name);
     }
     if (ARMul_MemoryInit(state,config->memorysize) == FALSE)
       InitFail(1, "Memory");
     if (config->bytesex != RDISex_DontCare)
       state->bigendSig = config->bytesex ;
     if (ARMul_CoProInit(state) == FALSE)
       InitFail(2, "Co-Processor");
     if (ARMul_OSInit(state) == FALSE)
       InitFail(3, "Operating System");
   }
   ARMul_Reset(state) ;
   RDIInit(0) ;
   }
  if (type & 2) { /* Reset the comms link */
    /* what comms link ? */
  }
  if (virgin && (type & 1) == 0) /* Cold start */
    ARMul_ConsolePrint(state, ", %s endian.\n",
		       state->bigendSig ? "Big" : "Little");
d288 1
a288 1
    return(state->bigendSig ? RDIError_BigEndian : RDIError_LittleEndian);
d290 1
a290 1
    return(RDIError_NoError) ;
d297 2
a298 1
static int RDI_close(void)
d300 6
a305 6
 TracePrint((state, "RDI_close\n"));
 ARMul_OSExit(state) ;
 ARMul_CoProExit(state) ;
 ARMul_MemoryExit(state) ;
 return(RDIError_NoError) ;
 }
d311 15
a325 12
static int RDI_read(ARMword source, void *dest, unsigned *nbytes)
{unsigned i ;
 char *memptr = (char *)dest ;

 TracePrint((state, "RDI_read: source=%.8lx dest=%p nbytes=%.8x\n",
             source, dest, *nbytes));

 for (i=0 ; i < *nbytes ; i++)
    *memptr++ = (char)ARMul_ReadByte(state,source++) ;
 if (state->abortSig) {
    state->abortSig = LOW ;
    return(RDIError_DataAbort) ;
d327 2
a328 2
 return(RDIError_NoError) ;
 }
d334 16
a349 13
static int RDI_write(const void *source, ARMword dest, unsigned *nbytes)
{unsigned i ;
 char *memptr = (char *)source ;

 TracePrint((state, "RDI_write: source=%p dest=%.8lx nbytes=%.8x\n",
            source, dest, *nbytes));

 for (i=0 ; i < *nbytes ; i++)
    ARMul_WriteByte(state,(ARMword)dest++,(ARMword)*memptr++) ;

 if (state->abortSig) {
    state->abortSig = LOW ;
    return(RDIError_DataAbort) ;
d351 2
a352 2
 return(RDIError_NoError) ;
 }
d358 7
a364 2
static int RDI_CPUread(unsigned mode, unsigned long mask, ARMword buffer[])
{unsigned i , upto ;
d366 5
a370 2
 if (mode == RDIMode_Curr)
    mode = (unsigned)(ARMul_GetCPSR(state) & MODEBITS) ;
d372 3
a374 3
 for (upto = 0, i = 0 ; i < 15 ; i++)
    if (mask & (1L << i)){
       buffer[upto++] = ARMul_GetReg(state,mode,i) ;
d377 4
a380 7
 if (mask & RDIReg_R15) {
    buffer[upto++] = ARMul_GetR15(state) ;
 }

 if (mask & RDIReg_PC) {
    buffer[upto++] = ARMul_GetPC(state) ;
 }
d382 2
a383 2
 if (mask & RDIReg_CPSR)
    buffer[upto++] = ARMul_GetCPSR(state) ;
d385 2
a386 2
 if (mask & RDIReg_SPSR)
    buffer[upto++] = ARMul_GetSPSR(state,mode) ;
d388 1
a388 1
 TracePrint((state, "RDI_CPUread: mode=%.8x mask=%.8lx", mode, mask));
d390 10
a399 7
 if (rdi_log & 1) {
    for (upto = 0, i = 0 ; i <= 20 ; i++)
       if (mask & (1L << i)) {
          ARMul_DebugPrint(state, "%c%.8lx",upto%4==0?'\n':' ',buffer[upto]) ;
          upto++ ;
          }
    ARMul_DebugPrint(state, "\n") ;
d403 1
a403 1
 return(RDIError_NoError) ;
d410 4
a413 2
static int RDI_CPUwrite(unsigned mode, unsigned long mask, ARMword const buffer[])
{int i, upto;
d416 1
a416 1
 TracePrint((state, "RDI_CPUwrite: mode=%.8x mask=%.8lx", mode, mask));
d418 10
a427 7
 if (rdi_log & 1) {
    for (upto = 0, i = 0 ; i <= 20 ; i++)
       if (mask & (1L << i)) {
          ARMul_DebugPrint(state, "%c%.8lx",upto%4==0?'\n':' ',buffer[upto]) ;
          upto++ ;
          }
    ARMul_DebugPrint(state, "\n") ;
d431 2
a432 2
 if (mode == RDIMode_Curr)
    mode = (unsigned)(ARMul_GetCPSR(state) & MODEBITS) ;
d434 1
a434 1
 for (upto = 0, i = 0 ; i < 15 ; i++)
d436 1
a436 1
       ARMul_SetReg(state,mode,i,buffer[upto++]) ;
d438 2
a439 2
 if (mask & RDIReg_R15)
    ARMul_SetR15(state,buffer[upto++]) ;
d441 2
a442 1
 if (mask & RDIReg_PC) {
d444 4
a447 4
   ARMul_SetPC(state,buffer[upto++]) ;
 }
 if (mask & RDIReg_CPSR)
    ARMul_SetCPSR(state,buffer[upto++]) ;
d449 2
a450 2
 if (mask & RDIReg_SPSR)
    ARMul_SetSPSR(state,mode,buffer[upto++]) ;
d452 1
a452 1
 return(RDIError_NoError) ;
d459 20
a478 16
static int RDI_CPread(unsigned CPnum, unsigned long mask, ARMword buffer[])
{ARMword fpregsaddr, word[4] ;
 
 unsigned r, w ;
 unsigned upto ;

 if (CPnum != 1 && CPnum != 2) {
    unsigned char const *rmap = state->CPRegWords[CPnum];
    if (rmap == NULL)
       return(RDIError_UnknownCoPro) ;
    for (upto = 0, r = 0 ; r < rmap[-1] ; r++)
       if (mask & (1L << r)) {
          (void)state->CPRead[CPnum](state, r, &buffer[upto]);
          upto += rmap[r];
       }
    TracePrint((state, "RDI_CPread: CPnum=%d mask=%.8lx", CPnum, mask));
d480 19
a498 12
    if (rdi_log & 1) {
       w = 0;
       for (upto = 0, r = 0; r < rmap[-1]; r++)
          if (mask & (1L << r)) {
             int words = rmap[r];
             ARMul_DebugPrint(state, "%c%2d", (w >= 4 ? (w = 0, '\n') : ' '), r);
             while (--words >= 0) {
                ARMul_DebugPrint(state, " %.8lx", buffer[upto++]);
                w++;
             }
          }
       ARMul_DebugPrint(state, "\n") ;
a499 3
#endif
    return RDIError_NoError;
 }
d502 1
a502 1
 return RDIError_UnknownCoPro;
d505 64
a568 58
 if (FPRegsAddr == 0) {
   fpregsaddr = ARMul_ReadWord(state, 4L) ;
   if ((fpregsaddr & 0xff800000) != 0xea000000) /* Must be a forward branch */
     return RDIError_UnknownCoPro;
   fpregsaddr = ((fpregsaddr & 0xffffff) << 2) + 8 ; /* address in __fp_decode - 4 */
   if ((fpregsaddr < FPESTART) || (fpregsaddr >= FPEEND))
     return RDIError_UnknownCoPro;
   fpregsaddr = ARMul_ReadWord(state, fpregsaddr) ; /* pointer to fp registers */
   FPRegsAddr = fpregsaddr ;
 }
 else
  fpregsaddr = FPRegsAddr ;

 if (fpregsaddr == 0) return RDIError_UnknownCoPro;
 for (upto = 0, r = 0 ; r < 8 ; r++)
    if (mask & (1L << r)) {
       for (w = 0 ; w < 4 ; w++)
          word[w] = ARMul_ReadWord(state,fpregsaddr + (ARMword)r * 16 + (ARMword)w * 4) ;
       switch ((int)(word[3] >> 29)) {
	 case 0 :
	 case 2 :
         case 4 :
         case 6 : /* its unpacked, convert to extended */
           buffer[upto++] = 2 ; /* mark as extended */
           buffer[upto++] = (word[3] & 0x7fff) | (word[0] & 0x80000000) ; /* exp and sign */
           buffer[upto++] = word[1] ; /* mantissa 1 */
           buffer[upto++] = word[2] ; /* mantissa 2 */
           break ;
         case 1 : /* packed single */
           buffer[upto++] = 0 ; /* mark as single */
           buffer[upto++] = word[0] ; /* sign, exp and mantissa */
           buffer[upto++] = word[1] ; /* padding */
           buffer[upto++] = word[2] ; /* padding */
           break ;
         case 3 : /* packed double */
           buffer[upto++] = 1 ; /* mark as double */
           buffer[upto++] = word[0] ; /* sign, exp and mantissa1 */
           buffer[upto++] = word[1] ; /* mantissa 2 */
           buffer[upto++] = word[2] ; /* padding */
           break ;
         case 5 : /* packed extended */
           buffer[upto++] = 2 ; /* mark as extended */
           buffer[upto++] = word[0] ; /* sign and exp */
           buffer[upto++] = word[1] ; /* mantissa 1 */
           buffer[upto++] = word[2] ; /* mantissa 2 */
           break ;
         case 7 : /* packed decimal */
           buffer[upto++] = 3 ; /* mark as packed decimal */
           buffer[upto++] = word[0] ; /* sign, exp and mantissa1 */
           buffer[upto++] = word[1] ; /* mantissa 2 */
           buffer[upto++] = word[2] ; /* mantissa 3 */
           break ;
         }
    }
 if (mask & (1L << r))
    buffer[upto++] = ARMul_ReadWord(state,fpregsaddr + 128) ; /* fpsr */
 if (mask & (1L << (r+1) ))
    buffer[upto++] = 0 ; /* fpcr */
d570 1
a570 1
 TracePrint((state, "RDI_CPread: CPnum=%d mask=%.8lx\n", CPnum, mask));
d572 14
a585 11
 if (rdi_log & 1) {
    for (upto = 0, r = 0 ; r < 9 ; r++)
       if (mask & (1L << r)) {
          if (r != 8) {
             ARMul_DebugPrint(state, "%08lx ",buffer[upto++]) ;
             ARMul_DebugPrint(state, "%08lx ",buffer[upto++]) ;
             ARMul_DebugPrint(state, "%08lx ",buffer[upto++]) ;
             }
          ARMul_DebugPrint(state, "%08lx\n",buffer[upto++]) ;
          }
    ARMul_DebugPrint(state, "\n") ;
d588 1
a588 1
 return(RDIError_NoError) ;
d590 1
a590 1
 }
d596 13
a608 10
static int RDI_CPwrite(unsigned CPnum, unsigned long mask, ARMword const buffer[])
{unsigned r ;
 unsigned upto ;
 ARMword fpregsaddr;

 if (CPnum != 1 && CPnum != 2) {
    unsigned char const *rmap = state->CPRegWords[CPnum];
    if (rmap == NULL)
       return(RDIError_UnknownCoPro) ;
    TracePrint((state, "RDI_CPwrite: CPnum=%d mask=%.8lx", CPnum, mask));
d610 25
a634 12
    if (rdi_log & 1) {
       int w = 0;
       for (upto = 0, r = 0; r < rmap[-1]; r++)
          if (mask & (1L << r)) {
             int words = rmap[r];
             ARMul_DebugPrint(state, "%c%2d", (w >= 4 ? (w = 0, '\n') : ' '), r);
             while (--words >= 0) {
                ARMul_DebugPrint(state, " %.8lx", buffer[upto++]);
                w++;
             }
          }
       ARMul_DebugPrint(state, "\n") ;
a635 8
#endif
    for (upto = 0, r = 0; r < rmap[-1]; r++)
       if (mask & (1L << r)) {
          (void)state->CPWrite[CPnum](state, r, &buffer[upto]);
          upto += rmap[r];
       }
    return RDIError_NoError;
 }
d638 1
a638 1
 return RDIError_UnknownCoPro;
d641 1
a641 1
 TracePrint((state, "RDI_CPwrite: CPnum=%d mask=%.8lx", CPnum, mask));
d643 15
a657 12
 if (rdi_log & 1) {
    for (upto = 0, r = 0 ; r < 9 ; r++)
       if (mask & (1L << r)) {
          if (r != 8) {
             ARMul_DebugPrint(state, "%08lx ",buffer[upto++]) ;
             ARMul_DebugPrint(state, "%08lx ",buffer[upto++]) ;
             ARMul_DebugPrint(state, "%08lx ",buffer[upto++]) ;
             }
          ARMul_DebugPrint(state, "%08lx\n",buffer[upto++]) ;
          }
   ARMul_DebugPrint(state, "\n") ;
   }
d660 32
a691 25
 if (FPRegsAddr == 0) {
   fpregsaddr = ARMul_ReadWord(state, 4L) ;
   if ((fpregsaddr & 0xff800000) != 0xea000000) /* Must be a forward branch */
     return RDIError_UnknownCoPro;
   fpregsaddr = ((fpregsaddr & 0xffffff) << 2) + 8 ; /* address in __fp_decode - 4 */
   if ((fpregsaddr < FPESTART) || (fpregsaddr >= FPEEND))
     return RDIError_UnknownCoPro;
   fpregsaddr = ARMul_ReadWord(state, fpregsaddr) ; /* pointer to fp registers */
   FPRegsAddr = fpregsaddr ;
 }
 else
  fpregsaddr = FPRegsAddr ;

 if (fpregsaddr == 0) return RDIError_UnknownCoPro;
 for (upto = 0, r = 0 ; r < 8 ; r++)
    if (mask & (1L << r)) {
      ARMul_WriteWord(state,fpregsaddr + (ARMword)r * 16,buffer[upto+1]) ;
      ARMul_WriteWord(state,fpregsaddr + (ARMword)r * 16 + 4,buffer[upto+2]) ;
      ARMul_WriteWord(state,fpregsaddr + (ARMword)r * 16 + 8,buffer[upto+3]) ;
      ARMul_WriteWord(state,fpregsaddr + (ARMword)r * 16 + 12,(buffer[upto] * 2 + 1) << 29) ; /* mark type */
      upto += 4 ;
    }
 if (mask & (1L << r))
    ARMul_WriteWord(state,fpregsaddr + 128,buffer[upto++]) ; /* fpsr */
 return(RDIError_NoError) ;
d695 3
a697 1
static void deletebreaknode(BreakNode **prevp) {
d700 4
a703 4
  ARMul_WriteWord(state, p->address, p->inst);
  free((char *)p);
  BreaksSet-- ;
  state->CallDebug-- ;
d706 10
a715 7
static int removebreak(ARMword address, unsigned type)
{ BreakNode *p, **prevp = &BreakList;
  for (; (p = *prevp) != NULL ; prevp = &p->next)
    if (p->address == address && p->type == type) {
      deletebreaknode(prevp);
      return TRUE;
    }
d721 4
a724 2
static BreakNode *installbreak(ARMword address, unsigned type, ARMword bound)
{ BreakNode *p = (BreakNode *)malloc(sizeof(BreakNode));
d730 2
a731 2
  p->inst = ARMul_ReadWord(state, address);
  ARMul_WriteWord(state, address, 0xee000000L);
d739 14
a752 12
static int RDI_setbreak(ARMword address, unsigned type, ARMword bound,
                        PointHandle *handle)
{ BreakNode *p;
  TracePrint((state, "RDI_setbreak: address=%.8lx type=%d bound=%.8lx\n",
             address, type, bound));

  removebreak(address, type);
  p = installbreak(address, type, bound);
  BreaksSet++ ;
  state->CallDebug++ ;
  *handle = (PointHandle)p;
  TracePrint((state, " returns %.8lx\n", *handle));
d760 6
a765 3
static int RDI_clearbreak(PointHandle handle)
{ TracePrint((state, "RDI_clearbreak: address=%.8lx\n", handle));
  { BreakNode *p, **prevp = &BreakList;
d767 5
a771 3
      if (p == (BreakNode *)handle) break;
    if (p == NULL) return RDIError_NoSuchPoint;
    deletebreaknode(prevp);
d780 8
a787 4
static void deletewatchnode(WatchNode **prevp)
{ WatchNode *p = *prevp;
  if (p->datatype & Watch_AnyRead) state->MemReadDebug--;
  if (p->datatype & Watch_AnyWrite) state->MemWriteDebug--;
d789 1
a789 1
  free((char *)p);
d792 11
a802 8
int removewatch(ARMword address, unsigned type)
{ WatchNode *p, **prevp = &WatchList;
  for (; (p = *prevp) != NULL ; prevp = &p->next)
    if (p->address == address && p->type == type) { /* found a match */
       deletewatchnode(prevp);
       return TRUE;
    }
  return FALSE; /* never found a match */
d805 5
a809 3
static WatchNode *installwatch(ARMword address, unsigned type, unsigned datatype,
                               ARMword bound)
{ WatchNode *p = (WatchNode *)malloc(sizeof(WatchNode));
d823 21
a843 14
static int RDI_setwatch(ARMword address, unsigned type, unsigned datatype,
                        ARMword bound, PointHandle *handle)
{ WatchNode *p;
  TracePrint((state, "RDI_setwatch: address=%.8lx type=%d datatype=%d bound=%.8lx",
              address, type, datatype, bound));

  if (!state->CanWatch) return RDIError_UnimplementedMessage;

  removewatch(address, type);
  p = installwatch(address, type, datatype, bound);
  if (datatype & Watch_AnyRead) state->MemReadDebug++;
  if (datatype & Watch_AnyWrite) state->MemWriteDebug++;
  *handle = (PointHandle)p;
  TracePrint((state, " returns %.8lx\n", *handle));
d851 6
a856 3
static int RDI_clearwatch(PointHandle handle)
{ TracePrint((state, "RDI_clearwatch: address=%.8lx\n", handle));
  { WatchNode *p, **prevp = &WatchList;
d858 5
a862 3
      if (p == (WatchNode *)handle) break;
    if (p == NULL) return RDIError_NoSuchPoint;
    deletewatchnode(prevp);
d871 2
a872 1
static int RDI_execute(PointHandle *handle)
d874 7
a880 6
  TracePrint((state, "RDI_execute\n"));
  if (rdi_log & 4) {
    state->CallDebug++ ;
    state->Debug = TRUE ;
  }
  state->EndCondition = RDIError_NoError ;
d883 1
a883 1
  ARMul_DoProg(state);
d886 7
a892 6
  state->Reg[15] -= 8 ; /* undo the pipeline */
  if (rdi_log & 4) {
    state->CallDebug-- ;
    state->Debug = FALSE ;
  }
  return(state->EndCondition) ;
d899 2
a900 1
static int RDI_step(unsigned ninstr, PointHandle *handle)
d903 9
a911 7
  TracePrint((state, "RDI_step\n"));
  if (ninstr != 1) return RDIError_UnimplementedMessage;
  if (rdi_log & 4) {
    state->CallDebug++ ;
    state->Debug = TRUE ;
  }
  state->EndCondition = RDIError_NoError ;
d913 1
a913 1
  ARMul_DoInstr(state) ;
d915 7
a921 6
  state->Reg[15] -= 8 ; /* undo the pipeline */
  if (rdi_log & 4) {
    state->CallDebug-- ;
    state->Debug = FALSE ;
  }
  return(state->EndCondition) ;
d928 2
a929 1
static int RDI_info(unsigned type, ARMword *arg1, ARMword *arg2)
d931 19
a949 7
  switch (type) {
  case RDIInfo_Target:
    TracePrint((state, "RDI_Info_Target\n"));
    /* Emulator, speed 10**5 IPS */
    *arg1 = 5 | HIGHEST_RDI_LEVEL << 5 | LOWEST_RDI_LEVEL << 8;
    *arg2 = 1298224434;
    return RDIError_NoError;
d951 66
a1016 8
  case RDIInfo_Points:
  { ARMword n = RDIPointCapability_Comparison | RDIPointCapability_Range |
                RDIPointCapability_Mask | RDIPointCapability_Status;
    TracePrint((state, "RDI_Info_Points\n"));
    if (state->CanWatch) n |= (Watch_AnyRead+Watch_AnyWrite) << 2;
    *arg1 = n;
    return RDIError_NoError;
  }
d1018 29
a1046 4
  case RDIInfo_Step:
    TracePrint((state, "RDI_Info_Step\n"));
    *arg1 =  RDIStep_Single;
    return RDIError_NoError;
d1048 23
a1070 10
  case RDIInfo_MMU:
    TracePrint((state, "RDI_Info_MMU\n"));
    *arg1 = 1313820229 ;
    return RDIError_NoError;

  case RDISignal_Stop:
    TracePrint((state, "RDISignal_Stop\n"));
    state->CallDebug++ ;
    state->EndCondition = RDIError_UserInterrupt ;
    return RDIError_NoError;
d1072 11
a1082 63
  case RDIVector_Catch:
    TracePrint((state, "RDIVector_Catch %.8lx\n", *arg1));
    state->VectorCatch = (unsigned)*arg1 ;
    return RDIError_NoError;

  case RDISet_Cmdline:
    TracePrint((state, "RDI_Set_Cmdline %s\n", (char *)arg1));
    state->CommandLine = (char *)malloc((unsigned)strlen((char *)arg1)+1) ;
    (void)strcpy(state->CommandLine,(char *)arg1) ;
    return RDIError_NoError;

  case RDICycles:
    TracePrint((state, "RDI_Info_Cycles\n"));
    arg1[0] = 0;
    arg1[1] = state->NumInstrs;
    arg1[2] = 0;
    arg1[3] = state->NumScycles;
    arg1[4] = 0;
    arg1[5] = state->NumNcycles;
    arg1[6] = 0;
    arg1[7] = state->NumIcycles;
    arg1[8] = 0;
    arg1[9] = state->NumCcycles;
    arg1[10] = 0;
    arg1[11] = state->NumFcycles;
    return RDIError_NoError;

  case RDIErrorP:
    *arg1 = ARMul_OSLastErrorP(state);
    TracePrint((state, "RDI_ErrorP returns %ld\n", *arg1));
    return RDIError_NoError;

  case RDIInfo_DescribeCoPro:
  { int cpnum = *(int *)arg1;
    struct Dbg_CoProDesc *cpd = (struct Dbg_CoProDesc *)arg2;
    int i;
    unsigned char const *map = state->CPRegWords[cpnum];
    if (map == NULL) return RDIError_UnknownCoPro;
    for (i = 0; i < cpd->entries; i++) {
      unsigned r, w = cpd->regdesc[i].nbytes / sizeof(ARMword);
      for (r = cpd->regdesc[i].rmin; r <= cpd->regdesc[i].rmax; r++)
        if (map[r] != w) return RDIError_BadCoProState;
    }
    return RDIError_NoError;
  }

  case RDIInfo_RequestCoProDesc:
  { int cpnum = *(int *)arg1;
    struct Dbg_CoProDesc *cpd = (struct Dbg_CoProDesc *)arg2;
    int i = -1, lastw = -1, r;
    unsigned char const *map;
    if ((unsigned)cpnum >= 16) return RDIError_UnknownCoPro;
    map = state->CPRegWords[cpnum];
    if (map == NULL) return RDIError_UnknownCoPro;
    for (r = 0; r < map[-1]; r++) {
      int words = map[r];
      if (words == lastw)
        cpd->regdesc[i].rmax = r;
      else {
        if (++i >= cpd->entries) return RDIError_BufferFull;
        cpd->regdesc[i].rmax = cpd->regdesc[i].rmin = r;
        cpd->regdesc[i].nbytes = words * sizeof(ARMword);
        cpd->regdesc[i].access = Dbg_Access_Readable+Dbg_Access_Writable;
a1083 12
    }
    cpd->entries = i+1;
    return RDIError_NoError;
  }

  case RDIInfo_Log:
    *arg1 = (ARMword)rdi_log;
    return RDIError_NoError;

  case RDIInfo_SetLog:
    rdi_log = (int)*arg1;
    return RDIError_NoError;
d1085 5
a1089 2
  case RDIInfo_CoPro:
    return RDIError_NoError;
d1091 2
a1092 10
  case RDIPointStatus_Watch:
    { WatchNode *p, *handle = (WatchNode *)*arg1;
      for (p = WatchList; p != NULL; p = p->next)
        if (p == handle) {
          *arg1 = -1;
          *arg2 = 1;
          return RDIError_NoError;
        }
      return RDIError_NoSuchPoint;
    }
a1093 9
  case RDIPointStatus_Break:
    { BreakNode *p, *handle = (BreakNode *)*arg1;
      for (p = BreakList; p != NULL; p = p->next)
        if (p == handle) {
          *arg1 = -1;
          *arg2 = 1;
          return RDIError_NoError;
        }
      return RDIError_NoSuchPoint;
a1094 11

  case RDISet_RDILevel:
    if (*arg1 < LOWEST_RDI_LEVEL || *arg1 > HIGHEST_RDI_LEVEL)
      return RDIError_IncompatibleRDILevels;
    MYrdi_level = *arg1;
    return RDIError_NoError;

  default:
    return RDIError_UnimplementedMessage;

  }
d1104 2
a1105 1
ARMword ARMul_Debug(ARMul_State *state, ARMword pc, ARMword instr)
d1108 4
a1111 22
  if (state->EndCondition == RDIError_UserInterrupt) {
    TracePrint((state, "User interrupt at %.8lx\n", pc));
    state->CallDebug--;
    state->Emulate = STOP;
  } else {
    BreakNode *p = BreakList;
    for (; p != NULL ; p = p->next) {
      switch (p->type) {
      case RDIPoint_EQ: if (pc == p->address) break; continue;
      case RDIPoint_GT: if (pc >  p->address) break; continue;
      case RDIPoint_GE: if (pc >= p->address) break; continue;
      case RDIPoint_LT: if (pc <  p->address) break; continue;
      case RDIPoint_LE: if (pc <= p->address) break; continue;
      case RDIPoint_IN: if (p->address <= pc && pc < p->address+p->bound) break;
                        continue;
      case RDIPoint_OUT:if (p->address > pc || pc >= p->address+p->bound) break;
                        continue;
      case RDIPoint_MASK:if ((pc & p->bound) == p->address) break; continue;
      }
      /* found a match */
      TracePrint((state, "Breakpoint reached at %.8lx\n", pc));
      state->EndCondition = RDIError_BreakpointReached ;
a1112 2
      state->StopHandle = (ARMword)p;
      break;
d1114 48
a1161 1
  }
d1165 4
a1168 2
void ARMul_CheckWatch(ARMul_State *state, ARMword addr, int access)
{ WatchNode *p;
d1170 44
a1213 20
    if (p->datatype & access) {
      switch (p->type) {
      case RDIPoint_EQ: if (addr == p->address) break; continue;
      case RDIPoint_GT: if (addr >  p->address) break; continue;
      case RDIPoint_GE: if (addr >= p->address) break; continue;
      case RDIPoint_LT: if (addr <  p->address) break; continue;
      case RDIPoint_LE: if (addr <= p->address) break; continue;
      case RDIPoint_IN: if (p->address <= addr && addr < p->address+p->bound) break;
                        continue;
      case RDIPoint_OUT:if (p->address > addr || addr >= p->address+p->bound) break;
                        continue;
      case RDIPoint_MASK:if ((addr & p->bound) == p->address) break; continue;
      }
      /* found a match */
      TracePrint((state, "Watchpoint at %.8lx accessed\n", addr));
      state->EndCondition = RDIError_WatchpointAccessed;
      state->Emulate = STOP;
      state->StopHandle = (ARMword)p;
      return;
   }
d1216 4
a1219 2
static RDI_NameList const *RDI_cpunames() {
  return (RDI_NameList const *)&processorconfig.count;
d1223 22
a1244 22
    "ARMUL",
    RDI_open,
    RDI_close,
    RDI_read,
    RDI_write,
    RDI_CPUread,
    RDI_CPUwrite,
    RDI_CPread,
    RDI_CPwrite,
    RDI_setbreak,
    RDI_clearbreak,
    RDI_setwatch,
    RDI_clearwatch,
    RDI_execute,
    RDI_step,
    RDI_info,

    0, /*pointinq*/
    0, /*addconfig*/
    0, /*loadconfigdata*/
    0, /*selectconfig*/
    0, /*drivernames*/
d1246 1
a1246 1
    RDI_cpunames
a1247 1

@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-2000-02-04 snapshot
@
text
@d36 1
a36 1
static unsigned FPRegsAddr;	/* last known address of FPE regs */
d48 2
a49 2
static ARMul_State *state = NULL;
static unsigned BreaksSet;	/* The number of breakpoints set */
d51 1
a51 1
static int rdi_log = 0;		/* debugging  ? */
d60 32
a91 39
struct BreakNode
{				/* A breakpoint list node */
  BreakNode *next;
  ARMword address;		/* The address of this breakpoint */
  unsigned type;		/* The type of comparison */
  ARMword bound;		/* The other address for a range */
  ARMword inst;
};

struct WatchNode
{				/* A watchpoint list node */
  WatchNode *next;
  ARMword address;		/* The address of this watchpoint */
  unsigned type;		/* The type of comparison */
  unsigned datatype;		/* The type of access to watch for */
  ARMword bound;		/* The other address for a range */
};

BreakNode *BreakList = NULL;
WatchNode *WatchList = NULL;

void
ARMul_DebugPrint_i (const Dbg_HostosInterface * hostif, const char *format,
		    ...)
{
  va_list ap;
  va_start (ap, format);
  hostif->dbgprint (hostif->dbgarg, format, ap);
  va_end (ap);
}

void
ARMul_DebugPrint (ARMul_State * state, const char *format, ...)
{
  va_list ap;
  va_start (ap, format);
  if (!(rdi_log & 8))
    state->hostif->dbgprint (state->hostif->dbgarg, format, ap);
  va_end (ap);
d96 1
a96 2
void
ARMul_ConsolePrint (ARMul_State * state, const char *format, ...)
d104 2
a105 4
  va_start (ap, format);
  vsprintf (buf, format, ap);

  for (i = 0; buf[i]; i++);	/* The string is i chars long */
d107 2
d110 20
a129 22
  while (i >= 32)
    {
      MYwrite_char (kidmum[1], RDP_OSOp);
      MYwrite_word (kidmum[1], SWI_Write0);
      MYwrite_char (kidmum[1], OS_SendString);
      MYwrite_char (kidmum[1], 32);	/* Send string 32bytes at a time */
      for (j = 0; j < 32; j++, str++)
	MYwrite_char (kidmum[1], *str);
      wait_for_osreply (&junk);
      i -= 32;
    }

  if (i > 0)
    {
      MYwrite_char (kidmum[1], RDP_OSOp);
      MYwrite_word (kidmum[1], SWI_Write0);
      MYwrite_char (kidmum[1], OS_SendString);
      MYwrite_char (kidmum[1], (unsigned char) i);	/* Send remainder of string  */
      for (j = 0; j < i; j++, str++)
	MYwrite_char (kidmum[1], *str);
      wait_for_osreply (&junk);
    }
d139 1
a139 2
void
ARMul_DebugPause (ARMul_State * state)
d141 2
a142 2
  if (!(rdi_log & 8))
    state->hostif->dbgpause (state->hostif->dbgarg);
d149 4
a152 6
static void
InitFail (int exitcode, char const *which)
{
  ARMul_ConsolePrint (state, "%s interface failed to initialise. Exiting\n",
		      which);
  exit (exitcode);
d155 4
a158 7
static void
RDIInit (unsigned type)
{
  if (type == 0)
    {				/* cold start */
      state->CallDebug = state->MemReadDebug = state->MemWriteDebug = 0;
      BreaksSet = 0;
d160 1
a160 1
}
d164 1
a164 6
typedef struct
{
  char name[16];
  unsigned val;
}
Processor;
d166 10
a175 10
Processor const p_arm2 = { "ARM2", ARM2 };
Processor const p_arm2as = { "ARM2AS", ARM2as };
Processor const p_arm61 = { "ARM61", ARM61 };
Processor const p_arm3 = { "ARM3", ARM3 };
Processor const p_arm6 = { "ARM6", ARM6 };
Processor const p_arm60 = { "ARM60", ARM60 };
Processor const p_arm600 = { "ARM600", ARM600 };
Processor const p_arm610 = { "ARM610", ARM610 };
Processor const p_arm620 = { "ARM620", ARM620 };
Processor const p_unknown = { "", UNKNOWNPROC };
d178 1
a178 1
  &p_arm6,			/* default: must come first */
d191 1
a191 2
struct ProcessorConfig
{
d195 1
a195 1
  Processor const *const *processors;
d199 3
a201 2
  {((((((long) 'x' << 8) | ' ') << 8) | 'c') << 8) | 'p',
   ((((((long) 'u' << 8) | 's') << 8) | ' ') << 8) | 'x'},
d207 3
a209 3
static int
RDI_open (unsigned type, const Dbg_ConfigBlock * config,
	  const Dbg_HostosInterface * hostif, struct Dbg_MCState *dbg_state)
d211 2
a212 3
{
  int virgin = (state == NULL);
  IGNORE (dbg_state);
d215 6
a220 7
  if (rdi_log & 1)
    {
      if (virgin)
	ARMul_DebugPrint_i (hostif, "RDI_open: type = %d\n", type);
      else
	ARMul_DebugPrint (state, "RDI_open: type = %d\n", type);
    }
d223 33
a255 39
  if (type & 1)
    {				/* Warm start */
      ARMul_Reset (state);
      RDIInit (1);
    }
  else
    {
      if (virgin)
	{
	  ARMul_EmulateInit ();
	  state = ARMul_NewState ();
	  state->hostif = hostif;
	  {
	    int req = config->processor;
	    unsigned processor = processors[req]->val;
	    ARMul_SelectProcessor (state, processor);
	    ARMul_Reset (state);
	    ARMul_ConsolePrint (state, "ARMulator V1.50, %s",
				processors[req]->name);
	  }
	  if (ARMul_MemoryInit (state, config->memorysize) == FALSE)
	    InitFail (1, "Memory");
	  if (config->bytesex != RDISex_DontCare)
	    state->bigendSig = config->bytesex;
	  if (ARMul_CoProInit (state) == FALSE)
	    InitFail (2, "Co-Processor");
	  if (ARMul_OSInit (state) == FALSE)
	    InitFail (3, "Operating System");
	}
      ARMul_Reset (state);
      RDIInit (0);
    }
  if (type & 2)
    {				/* Reset the comms link */
      /* what comms link ? */
    }
  if (virgin && (type & 1) == 0)	/* Cold start */
    ARMul_ConsolePrint (state, ", %s endian.\n",
			state->bigendSig ? "Big" : "Little");
d258 1
a258 1
    return (state->bigendSig ? RDIError_BigEndian : RDIError_LittleEndian);
d260 1
a260 1
    return (RDIError_NoError);
d267 1
a267 2
static int
RDI_close (void)
d269 6
a274 6
  TracePrint ((state, "RDI_close\n"));
  ARMul_OSExit (state);
  ARMul_CoProExit (state);
  ARMul_MemoryExit (state);
  return (RDIError_NoError);
}
d280 12
a291 15
static int
RDI_read (ARMword source, void *dest, unsigned *nbytes)
{
  unsigned i;
  char *memptr = (char *) dest;

  TracePrint ((state, "RDI_read: source=%.8lx dest=%p nbytes=%.8x\n",
	       source, dest, *nbytes));

  for (i = 0; i < *nbytes; i++)
    *memptr++ = (char) ARMul_ReadByte (state, source++);
  if (state->abortSig)
    {
      state->abortSig = LOW;
      return (RDIError_DataAbort);
d293 2
a294 2
  return (RDIError_NoError);
}
d300 13
a312 16
static int
RDI_write (const void *source, ARMword dest, unsigned *nbytes)
{
  unsigned i;
  char *memptr = (char *) source;

  TracePrint ((state, "RDI_write: source=%p dest=%.8lx nbytes=%.8x\n",
	       source, dest, *nbytes));

  for (i = 0; i < *nbytes; i++)
    ARMul_WriteByte (state, (ARMword) dest++, (ARMword) * memptr++);

  if (state->abortSig)
    {
      state->abortSig = LOW;
      return (RDIError_DataAbort);
d314 2
a315 2
  return (RDIError_NoError);
}
d321 2
a322 4
static int
RDI_CPUread (unsigned mode, unsigned long mask, ARMword buffer[])
{
  unsigned i, upto;
d324 2
a325 2
  if (mode == RDIMode_Curr)
    mode = (unsigned) (ARMul_GetCPSR (state) & MODEBITS);
d327 4
a330 5
  for (upto = 0, i = 0; i < 15; i++)
    if (mask & (1L << i))
      {
	buffer[upto++] = ARMul_GetReg (state, mode, i);
      }
d332 3
a334 4
  if (mask & RDIReg_R15)
    {
      buffer[upto++] = ARMul_GetR15 (state);
    }
d336 3
a338 4
  if (mask & RDIReg_PC)
    {
      buffer[upto++] = ARMul_GetPC (state);
    }
d340 2
a341 2
  if (mask & RDIReg_CPSR)
    buffer[upto++] = ARMul_GetCPSR (state);
d343 2
a344 2
  if (mask & RDIReg_SPSR)
    buffer[upto++] = ARMul_GetSPSR (state, mode);
d346 1
a346 1
  TracePrint ((state, "RDI_CPUread: mode=%.8x mask=%.8lx", mode, mask));
d348 7
a354 10
  if (rdi_log & 1)
    {
      for (upto = 0, i = 0; i <= 20; i++)
	if (mask & (1L << i))
	  {
	    ARMul_DebugPrint (state, "%c%.8lx", upto % 4 == 0 ? '\n' : ' ',
			      buffer[upto]);
	    upto++;
	  }
      ARMul_DebugPrint (state, "\n");
d358 1
a358 1
  return (RDIError_NoError);
d365 2
a366 4
static int
RDI_CPUwrite (unsigned mode, unsigned long mask, ARMword const buffer[])
{
  int i, upto;
d369 1
a369 1
  TracePrint ((state, "RDI_CPUwrite: mode=%.8x mask=%.8lx", mode, mask));
d371 7
a377 10
  if (rdi_log & 1)
    {
      for (upto = 0, i = 0; i <= 20; i++)
	if (mask & (1L << i))
	  {
	    ARMul_DebugPrint (state, "%c%.8lx", upto % 4 == 0 ? '\n' : ' ',
			      buffer[upto]);
	    upto++;
	  }
      ARMul_DebugPrint (state, "\n");
d381 2
a382 2
  if (mode == RDIMode_Curr)
    mode = (unsigned) (ARMul_GetCPSR (state) & MODEBITS);
d384 1
a384 1
  for (upto = 0, i = 0; i < 15; i++)
d386 1
a386 1
      ARMul_SetReg (state, mode, i, buffer[upto++]);
d388 2
a389 2
  if (mask & RDIReg_R15)
    ARMul_SetR15 (state, buffer[upto++]);
d391 1
a391 2
  if (mask & RDIReg_PC)
    {
d393 4
a396 4
      ARMul_SetPC (state, buffer[upto++]);
    }
  if (mask & RDIReg_CPSR)
    ARMul_SetCPSR (state, buffer[upto++]);
d398 2
a399 2
  if (mask & RDIReg_SPSR)
    ARMul_SetSPSR (state, mode, buffer[upto++]);
d401 1
a401 1
  return (RDIError_NoError);
d408 16
a423 20
static int
RDI_CPread (unsigned CPnum, unsigned long mask, ARMword buffer[])
{
  ARMword fpregsaddr, word[4];

  unsigned r, w;
  unsigned upto;

  if (CPnum != 1 && CPnum != 2)
    {
      unsigned char const *rmap = state->CPRegWords[CPnum];
      if (rmap == NULL)
	return (RDIError_UnknownCoPro);
      for (upto = 0, r = 0; r < rmap[-1]; r++)
	if (mask & (1L << r))
	  {
	    (void) state->CPRead[CPnum] (state, r, &buffer[upto]);
	    upto += rmap[r];
	  }
      TracePrint ((state, "RDI_CPread: CPnum=%d mask=%.8lx", CPnum, mask));
d425 13
a437 17
      if (rdi_log & 1)
	{
	  w = 0;
	  for (upto = 0, r = 0; r < rmap[-1]; r++)
	    if (mask & (1L << r))
	      {
		int words = rmap[r];
		ARMul_DebugPrint (state, "%c%2d",
				  (w >= 4 ? (w = 0, '\n') : ' '), r);
		while (--words >= 0)
		  {
		    ARMul_DebugPrint (state, " %.8lx", buffer[upto++]);
		    w++;
		  }
	      }
	  ARMul_DebugPrint (state, "\n");
	}
d439 2
a440 2
      return RDIError_NoError;
    }
d443 1
a443 1
  return RDIError_UnknownCoPro;
d446 58
a503 64
  if (FPRegsAddr == 0)
    {
      fpregsaddr = ARMul_ReadWord (state, 4L);
      if ((fpregsaddr & 0xff800000) != 0xea000000)	/* Must be a forward branch */
	return RDIError_UnknownCoPro;
      fpregsaddr = ((fpregsaddr & 0xffffff) << 2) + 8;	/* address in __fp_decode - 4 */
      if ((fpregsaddr < FPESTART) || (fpregsaddr >= FPEEND))
	return RDIError_UnknownCoPro;
      fpregsaddr = ARMul_ReadWord (state, fpregsaddr);	/* pointer to fp registers */
      FPRegsAddr = fpregsaddr;
    }
  else
    fpregsaddr = FPRegsAddr;

  if (fpregsaddr == 0)
    return RDIError_UnknownCoPro;
  for (upto = 0, r = 0; r < 8; r++)
    if (mask & (1L << r))
      {
	for (w = 0; w < 4; w++)
	  word[w] =
	    ARMul_ReadWord (state,
			    fpregsaddr + (ARMword) r * 16 + (ARMword) w * 4);
	switch ((int) (word[3] >> 29))
	  {
	  case 0:
	  case 2:
	  case 4:
	  case 6:		/* its unpacked, convert to extended */
	    buffer[upto++] = 2;	/* mark as extended */
	    buffer[upto++] = (word[3] & 0x7fff) | (word[0] & 0x80000000);	/* exp and sign */
	    buffer[upto++] = word[1];	/* mantissa 1 */
	    buffer[upto++] = word[2];	/* mantissa 2 */
	    break;
	  case 1:		/* packed single */
	    buffer[upto++] = 0;	/* mark as single */
	    buffer[upto++] = word[0];	/* sign, exp and mantissa */
	    buffer[upto++] = word[1];	/* padding */
	    buffer[upto++] = word[2];	/* padding */
	    break;
	  case 3:		/* packed double */
	    buffer[upto++] = 1;	/* mark as double */
	    buffer[upto++] = word[0];	/* sign, exp and mantissa1 */
	    buffer[upto++] = word[1];	/* mantissa 2 */
	    buffer[upto++] = word[2];	/* padding */
	    break;
	  case 5:		/* packed extended */
	    buffer[upto++] = 2;	/* mark as extended */
	    buffer[upto++] = word[0];	/* sign and exp */
	    buffer[upto++] = word[1];	/* mantissa 1 */
	    buffer[upto++] = word[2];	/* mantissa 2 */
	    break;
	  case 7:		/* packed decimal */
	    buffer[upto++] = 3;	/* mark as packed decimal */
	    buffer[upto++] = word[0];	/* sign, exp and mantissa1 */
	    buffer[upto++] = word[1];	/* mantissa 2 */
	    buffer[upto++] = word[2];	/* mantissa 3 */
	    break;
	  }
      }
  if (mask & (1L << r))
    buffer[upto++] = ARMul_ReadWord (state, fpregsaddr + 128);	/* fpsr */
  if (mask & (1L << (r + 1)))
    buffer[upto++] = 0;		/* fpcr */
d505 1
a505 1
  TracePrint ((state, "RDI_CPread: CPnum=%d mask=%.8lx\n", CPnum, mask));
d507 11
a517 14
  if (rdi_log & 1)
    {
      for (upto = 0, r = 0; r < 9; r++)
	if (mask & (1L << r))
	  {
	    if (r != 8)
	      {
		ARMul_DebugPrint (state, "%08lx ", buffer[upto++]);
		ARMul_DebugPrint (state, "%08lx ", buffer[upto++]);
		ARMul_DebugPrint (state, "%08lx ", buffer[upto++]);
	      }
	    ARMul_DebugPrint (state, "%08lx\n", buffer[upto++]);
	  }
      ARMul_DebugPrint (state, "\n");
d520 1
a520 1
  return (RDIError_NoError);
d522 1
a522 1
}
d528 10
a537 13
static int
RDI_CPwrite (unsigned CPnum, unsigned long mask, ARMword const buffer[])
{
  unsigned r;
  unsigned upto;
  ARMword fpregsaddr;

  if (CPnum != 1 && CPnum != 2)
    {
      unsigned char const *rmap = state->CPRegWords[CPnum];
      if (rmap == NULL)
	return (RDIError_UnknownCoPro);
      TracePrint ((state, "RDI_CPwrite: CPnum=%d mask=%.8lx", CPnum, mask));
d539 13
a551 17
      if (rdi_log & 1)
	{
	  int w = 0;
	  for (upto = 0, r = 0; r < rmap[-1]; r++)
	    if (mask & (1L << r))
	      {
		int words = rmap[r];
		ARMul_DebugPrint (state, "%c%2d",
				  (w >= 4 ? (w = 0, '\n') : ' '), r);
		while (--words >= 0)
		  {
		    ARMul_DebugPrint (state, " %.8lx", buffer[upto++]);
		    w++;
		  }
	      }
	  ARMul_DebugPrint (state, "\n");
	}
d553 7
a559 8
      for (upto = 0, r = 0; r < rmap[-1]; r++)
	if (mask & (1L << r))
	  {
	    (void) state->CPWrite[CPnum] (state, r, &buffer[upto]);
	    upto += rmap[r];
	  }
      return RDIError_NoError;
    }
d562 1
a562 1
  return RDIError_UnknownCoPro;
d565 1
a565 1
  TracePrint ((state, "RDI_CPwrite: CPnum=%d mask=%.8lx", CPnum, mask));
d567 12
a578 15
  if (rdi_log & 1)
    {
      for (upto = 0, r = 0; r < 9; r++)
	if (mask & (1L << r))
	  {
	    if (r != 8)
	      {
		ARMul_DebugPrint (state, "%08lx ", buffer[upto++]);
		ARMul_DebugPrint (state, "%08lx ", buffer[upto++]);
		ARMul_DebugPrint (state, "%08lx ", buffer[upto++]);
	      }
	    ARMul_DebugPrint (state, "%08lx\n", buffer[upto++]);
	  }
      ARMul_DebugPrint (state, "\n");
    }
d581 25
a605 32
  if (FPRegsAddr == 0)
    {
      fpregsaddr = ARMul_ReadWord (state, 4L);
      if ((fpregsaddr & 0xff800000) != 0xea000000)	/* Must be a forward branch */
	return RDIError_UnknownCoPro;
      fpregsaddr = ((fpregsaddr & 0xffffff) << 2) + 8;	/* address in __fp_decode - 4 */
      if ((fpregsaddr < FPESTART) || (fpregsaddr >= FPEEND))
	return RDIError_UnknownCoPro;
      fpregsaddr = ARMul_ReadWord (state, fpregsaddr);	/* pointer to fp registers */
      FPRegsAddr = fpregsaddr;
    }
  else
    fpregsaddr = FPRegsAddr;

  if (fpregsaddr == 0)
    return RDIError_UnknownCoPro;
  for (upto = 0, r = 0; r < 8; r++)
    if (mask & (1L << r))
      {
	ARMul_WriteWord (state, fpregsaddr + (ARMword) r * 16,
			 buffer[upto + 1]);
	ARMul_WriteWord (state, fpregsaddr + (ARMword) r * 16 + 4,
			 buffer[upto + 2]);
	ARMul_WriteWord (state, fpregsaddr + (ARMword) r * 16 + 8,
			 buffer[upto + 3]);
	ARMul_WriteWord (state, fpregsaddr + (ARMword) r * 16 + 12,
			 (buffer[upto] * 2 + 1) << 29);	/* mark type */
	upto += 4;
      }
  if (mask & (1L << r))
    ARMul_WriteWord (state, fpregsaddr + 128, buffer[upto++]);	/* fpsr */
  return (RDIError_NoError);
d609 1
a609 3
static void
deletebreaknode (BreakNode ** prevp)
{
d612 4
a615 4
  ARMul_WriteWord (state, p->address, p->inst);
  free ((char *) p);
  BreaksSet--;
  state->CallDebug--;
d618 7
a624 10
static int
removebreak (ARMword address, unsigned type)
{
  BreakNode *p, **prevp = &BreakList;
  for (; (p = *prevp) != NULL; prevp = &p->next)
    if (p->address == address && p->type == type)
      {
	deletebreaknode (prevp);
	return TRUE;
      }
d630 2
a631 4
static BreakNode *
installbreak (ARMword address, unsigned type, ARMword bound)
{
  BreakNode *p = (BreakNode *) malloc (sizeof (BreakNode));
d637 2
a638 2
  p->inst = ARMul_ReadWord (state, address);
  ARMul_WriteWord (state, address, 0xee000000L);
d646 12
a657 14
static int
RDI_setbreak (ARMword address, unsigned type, ARMword bound,
	      PointHandle * handle)
{
  BreakNode *p;
  TracePrint ((state, "RDI_setbreak: address=%.8lx type=%d bound=%.8lx\n",
	       address, type, bound));

  removebreak (address, type);
  p = installbreak (address, type, bound);
  BreaksSet++;
  state->CallDebug++;
  *handle = (PointHandle) p;
  TracePrint ((state, " returns %.8lx\n", *handle));
d665 3
a667 6
static int
RDI_clearbreak (PointHandle handle)
{
  TracePrint ((state, "RDI_clearbreak: address=%.8lx\n", handle));
  {
    BreakNode *p, **prevp = &BreakList;
d669 3
a671 5
      if (p == (BreakNode *) handle)
	break;
    if (p == NULL)
      return RDIError_NoSuchPoint;
    deletebreaknode (prevp);
d680 4
a683 8
static void
deletewatchnode (WatchNode ** prevp)
{
  WatchNode *p = *prevp;
  if (p->datatype & Watch_AnyRead)
    state->MemReadDebug--;
  if (p->datatype & Watch_AnyWrite)
    state->MemWriteDebug--;
d685 1
a685 1
  free ((char *) p);
d688 8
a695 11
int
removewatch (ARMword address, unsigned type)
{
  WatchNode *p, **prevp = &WatchList;
  for (; (p = *prevp) != NULL; prevp = &p->next)
    if (p->address == address && p->type == type)
      {				/* found a match */
	deletewatchnode (prevp);
	return TRUE;
      }
  return FALSE;			/* never found a match */
d698 3
a700 5
static WatchNode *
installwatch (ARMword address, unsigned type, unsigned datatype,
	      ARMword bound)
{
  WatchNode *p = (WatchNode *) malloc (sizeof (WatchNode));
d714 14
a727 21
static int
RDI_setwatch (ARMword address, unsigned type, unsigned datatype,
	      ARMword bound, PointHandle * handle)
{
  WatchNode *p;
  TracePrint (
	      (state,
	       "RDI_setwatch: address=%.8lx type=%d datatype=%d bound=%.8lx",
	       address, type, datatype, bound));

  if (!state->CanWatch)
    return RDIError_UnimplementedMessage;

  removewatch (address, type);
  p = installwatch (address, type, datatype, bound);
  if (datatype & Watch_AnyRead)
    state->MemReadDebug++;
  if (datatype & Watch_AnyWrite)
    state->MemWriteDebug++;
  *handle = (PointHandle) p;
  TracePrint ((state, " returns %.8lx\n", *handle));
d735 3
a737 6
static int
RDI_clearwatch (PointHandle handle)
{
  TracePrint ((state, "RDI_clearwatch: address=%.8lx\n", handle));
  {
    WatchNode *p, **prevp = &WatchList;
d739 3
a741 5
      if (p == (WatchNode *) handle)
	break;
    if (p == NULL)
      return RDIError_NoSuchPoint;
    deletewatchnode (prevp);
d750 1
a750 2
static int
RDI_execute (PointHandle * handle)
d752 6
a757 7
  TracePrint ((state, "RDI_execute\n"));
  if (rdi_log & 4)
    {
      state->CallDebug++;
      state->Debug = TRUE;
    }
  state->EndCondition = RDIError_NoError;
d760 1
a760 1
  ARMul_DoProg (state);
d763 6
a768 7
  state->Reg[15] -= 8;		/* undo the pipeline */
  if (rdi_log & 4)
    {
      state->CallDebug--;
      state->Debug = FALSE;
    }
  return (state->EndCondition);
d775 1
a775 2
static int
RDI_step (unsigned ninstr, PointHandle * handle)
d778 7
a784 9
  TracePrint ((state, "RDI_step\n"));
  if (ninstr != 1)
    return RDIError_UnimplementedMessage;
  if (rdi_log & 4)
    {
      state->CallDebug++;
      state->Debug = TRUE;
    }
  state->EndCondition = RDIError_NoError;
d786 1
a786 1
  ARMul_DoInstr (state);
d788 6
a793 7
  state->Reg[15] -= 8;		/* undo the pipeline */
  if (rdi_log & 4)
    {
      state->CallDebug--;
      state->Debug = FALSE;
    }
  return (state->EndCondition);
d800 1
a800 2
static int
RDI_info (unsigned type, ARMword * arg1, ARMword * arg2)
d802 64
a865 19
  switch (type)
    {
    case RDIInfo_Target:
      TracePrint ((state, "RDI_Info_Target\n"));
      /* Emulator, speed 10**5 IPS */
      *arg1 = 5 | HIGHEST_RDI_LEVEL << 5 | LOWEST_RDI_LEVEL << 8;
      *arg2 = 1298224434;
      return RDIError_NoError;

    case RDIInfo_Points:
      {
	ARMword n = RDIPointCapability_Comparison | RDIPointCapability_Range |
	  RDIPointCapability_Mask | RDIPointCapability_Status;
	TracePrint ((state, "RDI_Info_Points\n"));
	if (state->CanWatch)
	  n |= (Watch_AnyRead + Watch_AnyWrite) << 2;
	*arg1 = n;
	return RDIError_NoError;
      }
d867 13
a879 66
    case RDIInfo_Step:
      TracePrint ((state, "RDI_Info_Step\n"));
      *arg1 = RDIStep_Single;
      return RDIError_NoError;

    case RDIInfo_MMU:
      TracePrint ((state, "RDI_Info_MMU\n"));
      *arg1 = 1313820229;
      return RDIError_NoError;

    case RDISignal_Stop:
      TracePrint ((state, "RDISignal_Stop\n"));
      state->CallDebug++;
      state->EndCondition = RDIError_UserInterrupt;
      return RDIError_NoError;

    case RDIVector_Catch:
      TracePrint ((state, "RDIVector_Catch %.8lx\n", *arg1));
      state->VectorCatch = (unsigned) *arg1;
      return RDIError_NoError;

    case RDISet_Cmdline:
      TracePrint ((state, "RDI_Set_Cmdline %s\n", (char *) arg1));
      state->CommandLine =
	(char *) malloc ((unsigned) strlen ((char *) arg1) + 1);
      (void) strcpy (state->CommandLine, (char *) arg1);
      return RDIError_NoError;

    case RDICycles:
      TracePrint ((state, "RDI_Info_Cycles\n"));
      arg1[0] = 0;
      arg1[1] = state->NumInstrs;
      arg1[2] = 0;
      arg1[3] = state->NumScycles;
      arg1[4] = 0;
      arg1[5] = state->NumNcycles;
      arg1[6] = 0;
      arg1[7] = state->NumIcycles;
      arg1[8] = 0;
      arg1[9] = state->NumCcycles;
      arg1[10] = 0;
      arg1[11] = state->NumFcycles;
      return RDIError_NoError;

    case RDIErrorP:
      *arg1 = ARMul_OSLastErrorP (state);
      TracePrint ((state, "RDI_ErrorP returns %ld\n", *arg1));
      return RDIError_NoError;

    case RDIInfo_DescribeCoPro:
      {
	int cpnum = *(int *) arg1;
	struct Dbg_CoProDesc *cpd = (struct Dbg_CoProDesc *) arg2;
	int i;
	unsigned char const *map = state->CPRegWords[cpnum];
	if (map == NULL)
	  return RDIError_UnknownCoPro;
	for (i = 0; i < cpd->entries; i++)
	  {
	    unsigned r, w = cpd->regdesc[i].nbytes / sizeof (ARMword);
	    for (r = cpd->regdesc[i].rmin; r <= cpd->regdesc[i].rmax; r++)
	      if (map[r] != w)
		return RDIError_BadCoProState;
	  }
	return RDIError_NoError;
      }
d881 17
a897 28
    case RDIInfo_RequestCoProDesc:
      {
	int cpnum = *(int *) arg1;
	struct Dbg_CoProDesc *cpd = (struct Dbg_CoProDesc *) arg2;
	int i = -1, lastw = -1, r;
	unsigned char const *map;
	if ((unsigned) cpnum >= 16)
	  return RDIError_UnknownCoPro;
	map = state->CPRegWords[cpnum];
	if (map == NULL)
	  return RDIError_UnknownCoPro;
	for (r = 0; r < map[-1]; r++)
	  {
	    int words = map[r];
	    if (words == lastw)
	      cpd->regdesc[i].rmax = r;
	    else
	      {
		if (++i >= cpd->entries)
		  return RDIError_BufferFull;
		cpd->regdesc[i].rmax = cpd->regdesc[i].rmin = r;
		cpd->regdesc[i].nbytes = words * sizeof (ARMword);
		cpd->regdesc[i].access =
		  Dbg_Access_Readable + Dbg_Access_Writable;
	      }
	  }
	cpd->entries = i + 1;
	return RDIError_NoError;
d899 4
d904 3
a906 23
    case RDIInfo_Log:
      *arg1 = (ARMword) rdi_log;
      return RDIError_NoError;

    case RDIInfo_SetLog:
      rdi_log = (int) *arg1;
      return RDIError_NoError;

    case RDIInfo_CoPro:
      return RDIError_NoError;

    case RDIPointStatus_Watch:
      {
	WatchNode *p, *handle = (WatchNode *) * arg1;
	for (p = WatchList; p != NULL; p = p->next)
	  if (p == handle)
	    {
	      *arg1 = -1;
	      *arg2 = 1;
	      return RDIError_NoError;
	    }
	return RDIError_NoSuchPoint;
      }
d908 3
a910 12
    case RDIPointStatus_Break:
      {
	BreakNode *p, *handle = (BreakNode *) * arg1;
	for (p = BreakList; p != NULL; p = p->next)
	  if (p == handle)
	    {
	      *arg1 = -1;
	      *arg2 = 1;
	      return RDIError_NoError;
	    }
	return RDIError_NoSuchPoint;
      }
d912 2
a913 5
    case RDISet_RDILevel:
      if (*arg1 < LOWEST_RDI_LEVEL || *arg1 > HIGHEST_RDI_LEVEL)
	return RDIError_IncompatibleRDILevels;
      MYrdi_level = *arg1;
      return RDIError_NoError;
d915 10
a924 2
    default:
      return RDIError_UnimplementedMessage;
d926 9
d936 11
d956 1
a956 2
ARMword
ARMul_Debug (ARMul_State * state, ARMword pc, ARMword instr)
d959 22
a980 4
  if (state->EndCondition == RDIError_UserInterrupt)
    {
      TracePrint ((state, "User interrupt at %.8lx\n", pc));
      state->CallDebug--;
d982 2
d985 1
a985 48
  else
    {
      BreakNode *p = BreakList;
      for (; p != NULL; p = p->next)
	{
	  switch (p->type)
	    {
	    case RDIPoint_EQ:
	      if (pc == p->address)
		break;
	      continue;
	    case RDIPoint_GT:
	      if (pc > p->address)
		break;
	      continue;
	    case RDIPoint_GE:
	      if (pc >= p->address)
		break;
	      continue;
	    case RDIPoint_LT:
	      if (pc < p->address)
		break;
	      continue;
	    case RDIPoint_LE:
	      if (pc <= p->address)
		break;
	      continue;
	    case RDIPoint_IN:
	      if (p->address <= pc && pc < p->address + p->bound)
		break;
	      continue;
	    case RDIPoint_OUT:
	      if (p->address > pc || pc >= p->address + p->bound)
		break;
	      continue;
	    case RDIPoint_MASK:
	      if ((pc & p->bound) == p->address)
		break;
	      continue;
	    }
	  /* found a match */
	  TracePrint ((state, "Breakpoint reached at %.8lx\n", pc));
	  state->EndCondition = RDIError_BreakpointReached;
	  state->Emulate = STOP;
	  state->StopHandle = (ARMword) p;
	  break;
	}
    }
d989 2
a990 4
void
ARMul_CheckWatch (ARMul_State * state, ARMword addr, int access)
{
  WatchNode *p;
d992 20
a1011 44
    if (p->datatype & access)
      {
	switch (p->type)
	  {
	  case RDIPoint_EQ:
	    if (addr == p->address)
	      break;
	    continue;
	  case RDIPoint_GT:
	    if (addr > p->address)
	      break;
	    continue;
	  case RDIPoint_GE:
	    if (addr >= p->address)
	      break;
	    continue;
	  case RDIPoint_LT:
	    if (addr < p->address)
	      break;
	    continue;
	  case RDIPoint_LE:
	    if (addr <= p->address)
	      break;
	    continue;
	  case RDIPoint_IN:
	    if (p->address <= addr && addr < p->address + p->bound)
	      break;
	    continue;
	  case RDIPoint_OUT:
	    if (p->address > addr || addr >= p->address + p->bound)
	      break;
	    continue;
	  case RDIPoint_MASK:
	    if ((addr & p->bound) == p->address)
	      break;
	    continue;
	  }
	/* found a match */
	TracePrint ((state, "Watchpoint at %.8lx accessed\n", addr));
	state->EndCondition = RDIError_WatchpointAccessed;
	state->Emulate = STOP;
	state->StopHandle = (ARMword) p;
	return;
      }
d1014 2
a1015 4
static RDI_NameList const *
RDI_cpunames ()
{
  return (RDI_NameList const *) &processorconfig.count;
d1019 22
a1040 22
  "ARMUL",
  RDI_open,
  RDI_close,
  RDI_read,
  RDI_write,
  RDI_CPUread,
  RDI_CPUwrite,
  RDI_CPread,
  RDI_CPwrite,
  RDI_setbreak,
  RDI_clearbreak,
  RDI_setwatch,
  RDI_clearwatch,
  RDI_execute,
  RDI_step,
  RDI_info,

  0,				/*pointinq */
  0,				/*addconfig */
  0,				/*loadconfigdata */
  0,				/*selectconfig */
  0,				/*drivernames */
d1042 1
a1042 1
  RDI_cpunames
d1044 1
@


