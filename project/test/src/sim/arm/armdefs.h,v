head	1.16;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.16
	gdb_7_6-2013-04-26-release:1.16
	gdb_7_6-branch:1.16.0.2
	gdb_7_6-2013-03-12-branchpoint:1.16
	gdb_7_5_1-2012-11-29-release:1.14
	gdb_7_5-2012-08-17-release:1.14
	gdb_7_5-branch:1.14.0.60
	gdb_7_5-2012-07-18-branchpoint:1.14
	gdb_7_4_1-2012-04-26-release:1.14
	gdb_7_4-2012-01-24-release:1.14
	gdb_7_4-branch:1.14.0.58
	gdb_7_4-2011-12-13-branchpoint:1.14
	gdb_7_3_1-2011-09-04-release:1.14
	gdb_7_3-2011-07-26-release:1.14
	gdb_7_3-branch:1.14.0.56
	gdb_7_3-2011-04-01-branchpoint:1.14
	gdb_7_2-2010-09-02-release:1.14
	gdb_7_2-branch:1.14.0.54
	gdb_7_2-2010-07-07-branchpoint:1.14
	gdb_7_1-2010-03-18-release:1.14
	gdb_7_1-branch:1.14.0.52
	gdb_7_1-2010-02-18-branchpoint:1.14
	gdb_7_0_1-2009-12-22-release:1.14
	gdb_7_0-2009-10-06-release:1.14
	gdb_7_0-branch:1.14.0.50
	gdb_7_0-2009-09-16-branchpoint:1.14
	arc-sim-20090309:1.14
	msnyder-checkpoint-072509-branch:1.14.0.48
	msnyder-checkpoint-072509-branchpoint:1.14
	arc-insight_6_8-branch:1.14.0.46
	arc-insight_6_8-branchpoint:1.14
	insight_6_8-branch:1.14.0.44
	insight_6_8-branchpoint:1.14
	reverse-20081226-branch:1.14.0.42
	reverse-20081226-branchpoint:1.14
	multiprocess-20081120-branch:1.14.0.40
	multiprocess-20081120-branchpoint:1.14
	reverse-20080930-branch:1.14.0.38
	reverse-20080930-branchpoint:1.14
	reverse-20080717-branch:1.14.0.36
	reverse-20080717-branchpoint:1.14
	msnyder-reverse-20080609-branch:1.14.0.34
	msnyder-reverse-20080609-branchpoint:1.14
	drow-reverse-20070409-branch:1.14.0.32
	drow-reverse-20070409-branchpoint:1.14
	gdb_6_8-2008-03-27-release:1.14
	gdb_6_8-branch:1.14.0.30
	gdb_6_8-2008-02-26-branchpoint:1.14
	gdb_6_7_1-2007-10-29-release:1.14
	gdb_6_7-2007-10-10-release:1.14
	gdb_6_7-branch:1.14.0.28
	gdb_6_7-2007-09-07-branchpoint:1.14
	insight_6_6-20070208-release:1.14
	gdb_6_6-2006-12-18-release:1.14
	gdb_6_6-branch:1.14.0.26
	gdb_6_6-2006-11-15-branchpoint:1.14
	insight_6_5-20061003-release:1.14
	gdb-csl-symbian-6_4_50_20060226-12:1.14
	gdb-csl-sourcerygxx-3_4_4-25:1.14
	nickrob-async-20060828-mergepoint:1.14
	gdb-csl-symbian-6_4_50_20060226-11:1.14
	gdb-csl-sourcerygxx-4_1-17:1.14
	gdb-csl-20060226-branch-local-2:1.14
	gdb-csl-sourcerygxx-4_1-14:1.14
	gdb-csl-sourcerygxx-4_1-13:1.14
	gdb-csl-sourcerygxx-4_1-12:1.14
	gdb-csl-sourcerygxx-3_4_4-21:1.14
	gdb_6_5-20060621-release:1.14
	gdb-csl-sourcerygxx-4_1-9:1.14
	gdb-csl-sourcerygxx-4_1-8:1.14
	gdb-csl-sourcerygxx-4_1-7:1.14
	gdb-csl-arm-2006q1-6:1.14
	gdb-csl-sourcerygxx-4_1-6:1.14
	gdb-csl-symbian-6_4_50_20060226-10:1.14
	gdb-csl-symbian-6_4_50_20060226-9:1.14
	gdb-csl-symbian-6_4_50_20060226-8:1.14
	gdb-csl-coldfire-4_1-11:1.14
	gdb-csl-sourcerygxx-3_4_4-19:1.14
	gdb-csl-coldfire-4_1-10:1.14
	gdb_6_5-branch:1.14.0.24
	gdb_6_5-2006-05-14-branchpoint:1.14
	gdb-csl-sourcerygxx-4_1-5:1.14
	nickrob-async-20060513-branch:1.14.0.22
	nickrob-async-20060513-branchpoint:1.14
	gdb-csl-sourcerygxx-4_1-4:1.14
	msnyder-reverse-20060502-branch:1.14.0.20
	msnyder-reverse-20060502-branchpoint:1.14
	gdb-csl-morpho-4_1-4:1.14
	gdb-csl-sourcerygxx-3_4_4-17:1.14
	readline_5_1-import-branch:1.14.0.18
	readline_5_1-import-branchpoint:1.14
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.14
	gdb-csl-symbian-20060226-branch:1.14.0.16
	gdb-csl-symbian-20060226-branchpoint:1.14
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.14
	msnyder-reverse-20060331-branch:1.14.0.14
	msnyder-reverse-20060331-branchpoint:1.14
	gdb-csl-available-20060303-branch:1.14.0.12
	gdb-csl-available-20060303-branchpoint:1.14
	gdb-csl-20060226-branch:1.14.0.10
	gdb-csl-20060226-branchpoint:1.14
	gdb_6_4-20051202-release:1.14
	msnyder-fork-checkpoint-branch:1.14.0.8
	msnyder-fork-checkpoint-branchpoint:1.14
	gdb-csl-gxxpro-6_3-branch:1.14.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.14
	gdb_6_4-branch:1.14.0.4
	gdb_6_4-2005-11-01-branchpoint:1.14
	gdb-csl-arm-20051020-branch:1.14.0.2
	gdb-csl-arm-20051020-branchpoint:1.14
	msnyder-tracepoint-checkpoint-branch:1.13.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.13
	gdb-csl-arm-20050325-2005-q1b:1.11
	gdb-csl-arm-20050325-2005-q1a:1.11
	csl-arm-20050325-branch:1.11.0.46
	csl-arm-20050325-branchpoint:1.11
	gdb_6_3-20041109-release:1.11
	gdb_6_3-branch:1.11.0.42
	gdb_6_3-20041019-branchpoint:1.11
	drow_intercu-merge-20040921:1.11
	drow_intercu-merge-20040915:1.11
	jimb-gdb_6_2-e500-branch:1.11.0.44
	jimb-gdb_6_2-e500-branchpoint:1.11
	gdb_6_2-20040730-release:1.11
	gdb_6_2-branch:1.11.0.40
	gdb_6_2-2004-07-10-gmt-branchpoint:1.11
	gdb_6_1_1-20040616-release:1.11
	gdb_6_1-2004-04-05-release:1.11
	drow_intercu-merge-20040402:1.11
	drow_intercu-merge-20040327:1.11
	ezannoni_pie-20040323-branch:1.11.0.38
	ezannoni_pie-20040323-branchpoint:1.11
	cagney_tramp-20040321-mergepoint:1.11
	cagney_tramp-20040309-branch:1.11.0.36
	cagney_tramp-20040309-branchpoint:1.11
	gdb_6_1-branch:1.11.0.34
	gdb_6_1-2004-03-01-gmt-branchpoint:1.11
	drow_intercu-20040221-branch:1.11.0.32
	drow_intercu-20040221-branchpoint:1.11
	cagney_bfdfile-20040213-branch:1.11.0.30
	cagney_bfdfile-20040213-branchpoint:1.11
	drow-cplus-merge-20040208:1.11
	carlton_dictionary-20040126-merge:1.11
	cagney_bigcore-20040122-branch:1.11.0.28
	cagney_bigcore-20040122-branchpoint:1.11
	drow-cplus-merge-20040113:1.11
	drow-cplus-merge-20031224:1.11
	drow-cplus-merge-20031220:1.11
	carlton_dictionary-20031215-merge:1.11
	drow-cplus-merge-20031214:1.11
	carlton-dictionary-20031111-merge:1.11
	gdb_6_0-2003-10-04-release:1.11
	kettenis_sparc-20030918-branch:1.11.0.26
	kettenis_sparc-20030918-branchpoint:1.11
	carlton_dictionary-20030917-merge:1.11
	ezannoni_pie-20030916-branchpoint:1.11
	ezannoni_pie-20030916-branch:1.11.0.24
	cagney_x86i386-20030821-branch:1.11.0.22
	cagney_x86i386-20030821-branchpoint:1.11
	carlton_dictionary-20030805-merge:1.11
	carlton_dictionary-20030627-merge:1.11
	gdb_6_0-branch:1.11.0.20
	gdb_6_0-2003-06-23-branchpoint:1.11
	jimb-ppc64-linux-20030613-branch:1.11.0.18
	jimb-ppc64-linux-20030613-branchpoint:1.11
	cagney_convert-20030606-branch:1.11.0.16
	cagney_convert-20030606-branchpoint:1.11
	cagney_writestrings-20030508-branch:1.11.0.14
	cagney_writestrings-20030508-branchpoint:1.11
	jimb-ppc64-linux-20030528-branch:1.11.0.12
	jimb-ppc64-linux-20030528-branchpoint:1.11
	carlton_dictionary-20030523-merge:1.11
	cagney_fileio-20030521-branch:1.11.0.10
	cagney_fileio-20030521-branchpoint:1.11
	kettenis_i386newframe-20030517-mergepoint:1.11
	jimb-ppc64-linux-20030509-branch:1.11.0.8
	jimb-ppc64-linux-20030509-branchpoint:1.11
	kettenis_i386newframe-20030504-mergepoint:1.11
	carlton_dictionary-20030430-merge:1.11
	kettenis_i386newframe-20030419-branch:1.11.0.6
	kettenis_i386newframe-20030419-branchpoint:1.11
	carlton_dictionary-20030416-merge:1.11
	cagney_frameaddr-20030409-mergepoint:1.11
	kettenis_i386newframe-20030406-branch:1.11.0.4
	kettenis_i386newframe-20030406-branchpoint:1.11
	cagney_frameaddr-20030403-branchpoint:1.11
	cagney_frameaddr-20030403-branch:1.11.0.2
	cagney_framebase-20030330-mergepoint:1.11
	cagney_framebase-20030326-branch:1.10.0.2
	cagney_framebase-20030326-branchpoint:1.10
	cagney_lazyid-20030317-branch:1.9.0.36
	cagney_lazyid-20030317-branchpoint:1.9
	kettenis-i386newframe-20030316-mergepoint:1.9
	offbyone-20030313-branch:1.9.0.34
	offbyone-20030313-branchpoint:1.9
	kettenis-i386newframe-20030308-branch:1.9.0.32
	kettenis-i386newframe-20030308-branchpoint:1.9
	carlton_dictionary-20030305-merge:1.9
	cagney_offbyone-20030303-branch:1.9.0.30
	cagney_offbyone-20030303-branchpoint:1.9
	carlton_dictionary-20030207-merge:1.9
	interps-20030202-branch:1.9.0.28
	interps-20030202-branchpoint:1.9
	cagney-unwind-20030108-branch:1.9.0.26
	cagney-unwind-20030108-branchpoint:1.9
	carlton_dictionary-20021223-merge:1.9
	gdb_5_3-2002-12-12-release:1.9
	carlton_dictionary-20021115-merge:1.9
	kseitz_interps-20021105-merge:1.9
	kseitz_interps-20021103-merge:1.9
	drow-cplus-merge-20021020:1.9
	drow-cplus-merge-20021025:1.9
	carlton_dictionary-20021025-merge:1.9
	carlton_dictionary-20021011-merge:1.9
	drow-cplus-branch:1.9.0.24
	drow-cplus-branchpoint:1.9
	kseitz_interps-20020930-merge:1.9
	carlton_dictionary-20020927-merge:1.9
	carlton_dictionary-branch:1.9.0.22
	carlton_dictionary-20020920-branchpoint:1.9
	gdb_5_3-branch:1.9.0.20
	gdb_5_3-2002-09-04-branchpoint:1.9
	kseitz_interps-20020829-merge:1.9
	cagney_sysregs-20020825-branch:1.9.0.18
	cagney_sysregs-20020825-branchpoint:1.9
	readline_4_3-import-branch:1.9.0.16
	readline_4_3-import-branchpoint:1.9
	gdb_5_2_1-2002-07-23-release:1.9
	kseitz_interps-20020528-branch:1.9.0.14
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.9.0.12
	cagney_regbuf-20020515-branchpoint:1.9
	jimb-macro-020506-branch:1.9.0.10
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.9
	gdb_5_2-branch:1.9.0.8
	gdb_5_2-2002-03-03-branchpoint:1.9
	gdb_5_1_1-2002-01-24-release:1.9
	gdb_5_1_0_1-2002-01-03-release:1.9
	gdb_5_1_0_1-2002-01-03-branch:1.9.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.9
	gdb_5_1-2001-11-21-release:1.9
	gdb_s390-2001-09-26-branch:1.9.0.4
	gdb_s390-2001-09-26-branchpoint:1.9
	gdb_5_1-2001-07-29-branch:1.9.0.2
	gdb_5_1-2001-07-29-branchpoint:1.9
	insight-precleanup-2001-01-01:1.7
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.16
date	2012.12.19.07.18.14;	author brobecke;	state Exp;
branches;
next	1.15;

1.15
date	2012.12.19.07.11.58;	author brobecke;	state Exp;
branches;
next	1.14;

1.14
date	2005.09.19.14.21.07;	author pbrook;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.12.07.36.58;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.25.07.48.59;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.27.17.13.33;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.20.12.25.07;	author nickc;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.04.18.16.39.37;	author mrg;	state Exp;
branches
	1.9.22.1
	1.9.24.1;
next	1.8;

1.8
date	2001.02.28.01.04.24;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.30.01.55.12;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.15.23.55.50;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.04.07.18.18;	author aoliva;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.04.05.16.20;	author aoliva;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.30.17.13.37;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.08.20.54.27;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.55;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.10.2.1
date	2003.03.30.16.35.25;	author cagney;	state Exp;
branches;
next	;

1.9.22.1
date	2003.04.16.19.57.07;	author carlton;	state Exp;
branches;
next	;

1.9.24.1
date	2003.12.14.20.28.16;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.55;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.12.11.13.31;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.02.05.07.30.18;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.16
log
@[sim] Update old contact info in GPL license notices

sim/ChangeLog:

        Update old contact info in GPL license notices.
@
text
@/*  armdefs.h -- ARMulator common definitions:  ARM6 Instruction Emulator.
    Copyright (C) 1994 Advanced RISC Machines Ltd.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, see <http://www.gnu.org/licenses/>. */

#include "config.h"
#include <stdio.h>
#include <stdlib.h>

#define FALSE 0
#define TRUE 1
#define LOW 0
#define HIGH 1
#define LOWHIGH 1
#define HIGHLOW 2

#ifndef __STDC__
typedef char *VoidStar;
#endif

#ifdef HAVE_STDINT_H
#include <stdint.h>
typedef uint32_t ARMword;
typedef int32_t ARMsword;
typedef uint64_t ARMdword;
typedef int64_t ARMsdword;
#else
typedef unsigned int ARMword;	/* must be 32 bits wide */
typedef signed int ARMsword;
typedef unsigned long long ARMdword;	/* Must be at least 64 bits wide.  */
typedef signed long long ARMsdword;
#endif
typedef struct ARMul_State ARMul_State;

typedef unsigned ARMul_CPInits (ARMul_State * state);
typedef unsigned ARMul_CPExits (ARMul_State * state);
typedef unsigned ARMul_LDCs (ARMul_State * state, unsigned type,
			     ARMword instr, ARMword value);
typedef unsigned ARMul_STCs (ARMul_State * state, unsigned type,
			     ARMword instr, ARMword * value);
typedef unsigned ARMul_MRCs (ARMul_State * state, unsigned type,
			     ARMword instr, ARMword * value);
typedef unsigned ARMul_MCRs (ARMul_State * state, unsigned type,
			     ARMword instr, ARMword value);
typedef unsigned ARMul_CDPs (ARMul_State * state, unsigned type,
			     ARMword instr);
typedef unsigned ARMul_CPReads (ARMul_State * state, unsigned reg,
				ARMword * value);
typedef unsigned ARMul_CPWrites (ARMul_State * state, unsigned reg,
				 ARMword value);

struct ARMul_State
{
  ARMword Emulate;		/* to start and stop emulation */
  unsigned EndCondition;	/* reason for stopping */
  unsigned ErrorCode;		/* type of illegal instruction */
  ARMword Reg[16];		/* the current register file */
  ARMword RegBank[7][16];	/* all the registers */
  /* 40 bit accumulator.  We always keep this 64 bits wide,
     and move only 40 bits out of it in an MRA insn.  */
  ARMdword Accumulator;
  ARMword Cpsr;			/* the current psr */
  ARMword Spsr[7];		/* the exception psr's */
  ARMword NFlag, ZFlag, CFlag, VFlag, IFFlags;	/* dummy flags for speed */
  ARMword SFlag;
#ifdef MODET
  ARMword TFlag;		/* Thumb state */
#endif
  ARMword Bank;			/* the current register bank */
  ARMword Mode;			/* the current mode */
  ARMword instr, pc, temp;	/* saved register state */
  ARMword loaded, decoded;	/* saved pipeline state */
  unsigned long NumScycles, NumNcycles, NumIcycles, NumCcycles, NumFcycles;	/* emulated cycles used */
  unsigned long NumInstrs;	/* the number of instructions executed */
  unsigned NextInstr;
  unsigned VectorCatch;		/* caught exception mask */
  unsigned CallDebug;		/* set to call the debugger */
  unsigned CanWatch;		/* set by memory interface if its willing to suffer the
				   overhead of checking for watchpoints on each memory
				   access */
  unsigned MemReadDebug, MemWriteDebug;
  unsigned long StopHandle;

  unsigned char *MemDataPtr;	/* admin data */
  unsigned char *MemInPtr;	/* the Data In bus */
  unsigned char *MemOutPtr;	/* the Data Out bus (which you may not need */
  unsigned char *MemSparePtr;	/* extra space */
  ARMword MemSize;

  unsigned char *OSptr;		/* OS Handle */
  char *CommandLine;		/* Command Line from ARMsd */

  ARMul_CPInits *CPInit[16];	/* coprocessor initialisers */
  ARMul_CPExits *CPExit[16];	/* coprocessor finalisers */
  ARMul_LDCs *LDC[16];		/* LDC instruction */
  ARMul_STCs *STC[16];		/* STC instruction */
  ARMul_MRCs *MRC[16];		/* MRC instruction */
  ARMul_MCRs *MCR[16];		/* MCR instruction */
  ARMul_CDPs *CDP[16];		/* CDP instruction */
  ARMul_CPReads *CPRead[16];	/* Read CP register */
  ARMul_CPWrites *CPWrite[16];	/* Write CP register */
  unsigned char *CPData[16];	/* Coprocessor data */
  unsigned char const *CPRegWords[16];	/* map of coprocessor register sizes */
  unsigned long LastTime;	/* Value of last call to ARMul_Time() */
  ARMword CP14R0_CCD;		/* used to count 64 clock cycles with CP14 R0 bit
				   3 set */

  unsigned EventSet;		/* the number of events in the queue */
  unsigned long Now;		/* time to the nearest cycle */
  struct EventNode **EventPtr;	/* the event list */

  unsigned Exception;		/* enable the next four values */
  unsigned Debug;		/* show instructions as they are executed */
  unsigned NresetSig;		/* reset the processor */
  unsigned NfiqSig;
  unsigned NirqSig;

  unsigned abortSig;
  unsigned NtransSig;
  unsigned bigendSig;
  unsigned prog32Sig;
  unsigned data32Sig;
  unsigned lateabtSig;
  ARMword Vector;		/* synthesize aborts in cycle modes */
  ARMword Aborted;		/* sticky flag for aborts */
  ARMword Reseted;		/* sticky flag for Reset */
  ARMword Inted, LastInted;	/* sticky flags for interrupts */
  ARMword Base;			/* extra hand for base writeback */
  ARMword AbortAddr;		/* to keep track of Prefetch aborts */

  const struct Dbg_HostosInterface *hostif;

  unsigned is_v4;		/* Are we emulating a v4 architecture (or higher) ?  */
  unsigned is_v5;		/* Are we emulating a v5 architecture ?  */
  unsigned is_v5e;		/* Are we emulating a v5e architecture ?  */
  unsigned is_v6;		/* Are we emulating a v6 architecture ?  */
  unsigned is_XScale;		/* Are we emulating an XScale architecture ?  */
  unsigned is_iWMMXt;		/* Are we emulating an iWMMXt co-processor ?  */
  unsigned is_ep9312;		/* Are we emulating a Cirrus Maverick co-processor ?  */
  unsigned verbose;		/* Print various messages like the banner */
};

#define ResetPin NresetSig
#define FIQPin NfiqSig
#define IRQPin NirqSig
#define AbortPin abortSig
#define TransPin NtransSig
#define BigEndPin bigendSig
#define Prog32Pin prog32Sig
#define Data32Pin data32Sig
#define LateAbortPin lateabtSig

/***************************************************************************\
*                        Properties of ARM we know about                    *
\***************************************************************************/

/* The bitflags */
#define ARM_Fix26_Prop   0x01
#define ARM_Nexec_Prop   0x02
#define ARM_Debug_Prop   0x10
#define ARM_Isync_Prop   ARM_Debug_Prop
#define ARM_Lock_Prop    0x20
#define ARM_v4_Prop      0x40
#define ARM_v5_Prop      0x80
#define ARM_v5e_Prop     0x100
#define ARM_XScale_Prop  0x200
#define ARM_ep9312_Prop  0x400
#define ARM_iWMMXt_Prop  0x800
#define ARM_v6_Prop      0x1000

/***************************************************************************\
*                   Macros to extract instruction fields                    *
\***************************************************************************/

#define BIT(n) ( (ARMword)(instr>>(n))&1)	/* bit n of instruction */
#define BITS(m,n) ( (ARMword)(instr<<(31-(n))) >> ((31-(n))+(m)) )	/* bits m to n of instr */
#define TOPBITS(n) (instr >> (n))	/* bits 31 to n of instr */

/***************************************************************************\
*                      The hardware vector addresses                        *
\***************************************************************************/

#define ARMResetV 0L
#define ARMUndefinedInstrV 4L
#define ARMSWIV 8L
#define ARMPrefetchAbortV 12L
#define ARMDataAbortV 16L
#define ARMAddrExceptnV 20L
#define ARMIRQV 24L
#define ARMFIQV 28L
#define ARMErrorV 32L		/* This is an offset, not an address ! */

#define ARMul_ResetV ARMResetV
#define ARMul_UndefinedInstrV ARMUndefinedInstrV
#define ARMul_SWIV ARMSWIV
#define ARMul_PrefetchAbortV ARMPrefetchAbortV
#define ARMul_DataAbortV ARMDataAbortV
#define ARMul_AddrExceptnV ARMAddrExceptnV
#define ARMul_IRQV ARMIRQV
#define ARMul_FIQV ARMFIQV

/***************************************************************************\
*                          Mode and Bank Constants                          *
\***************************************************************************/

#define USER26MODE   0L
#define FIQ26MODE    1L
#define IRQ26MODE    2L
#define SVC26MODE    3L
#define USER32MODE  16L
#define FIQ32MODE   17L
#define IRQ32MODE   18L
#define SVC32MODE   19L
#define ABORT32MODE 23L
#define UNDEF32MODE 27L
#define SYSTEMMODE  31L

#define ARM32BITMODE (state->Mode > 3)
#define ARM26BITMODE (state->Mode <= 3)
#define ARMMODE (state->Mode)
#define ARMul_MODEBITS 0x1fL
#define ARMul_MODE32BIT ARM32BITMODE
#define ARMul_MODE26BIT ARM26BITMODE

#define USERBANK 0
#define FIQBANK 1
#define IRQBANK 2
#define SVCBANK 3
#define ABORTBANK 4
#define UNDEFBANK 5
#define DUMMYBANK 6
#define SYSTEMBANK USERBANK

#define BANK_CAN_ACCESS_SPSR(bank)  \
  ((bank) != USERBANK && (bank) != SYSTEMBANK && (bank) != DUMMYBANK)

/***************************************************************************\
*                  Definitons of things in the emulator                     *
\***************************************************************************/

extern void ARMul_EmulateInit (void);
extern ARMul_State *ARMul_NewState (void);
extern void ARMul_Reset (ARMul_State * state);
extern ARMword ARMul_DoProg (ARMul_State * state);
extern ARMword ARMul_DoInstr (ARMul_State * state);

/***************************************************************************\
*                Definitons of things for event handling                    *
\***************************************************************************/

extern void ARMul_ScheduleEvent (ARMul_State * state, unsigned long delay,
				 unsigned (*func) ());
extern void ARMul_EnvokeEvent (ARMul_State * state);
extern unsigned long ARMul_Time (ARMul_State * state);

/***************************************************************************\
*                          Useful support routines                          *
\***************************************************************************/

extern ARMword ARMul_GetReg (ARMul_State * state, unsigned mode,
			     unsigned reg);
extern void ARMul_SetReg (ARMul_State * state, unsigned mode, unsigned reg,
			  ARMword value);
extern ARMword ARMul_GetPC (ARMul_State * state);
extern ARMword ARMul_GetNextPC (ARMul_State * state);
extern void ARMul_SetPC (ARMul_State * state, ARMword value);
extern ARMword ARMul_GetR15 (ARMul_State * state);
extern void ARMul_SetR15 (ARMul_State * state, ARMword value);

extern ARMword ARMul_GetCPSR (ARMul_State * state);
extern void ARMul_SetCPSR (ARMul_State * state, ARMword value);
extern ARMword ARMul_GetSPSR (ARMul_State * state, ARMword mode);
extern void ARMul_SetSPSR (ARMul_State * state, ARMword mode, ARMword value);

/***************************************************************************\
*                  Definitons of things to handle aborts                    *
\***************************************************************************/

extern void ARMul_Abort (ARMul_State * state, ARMword address);
#define ARMul_ABORTWORD 0xefffffff	/* SWI -1 */
#define ARMul_PREFETCHABORT(address) if (state->AbortAddr == 1) \
                                        state->AbortAddr = (address & ~3L)
#define ARMul_DATAABORT(address) state->abortSig = HIGH ; \
                                 state->Aborted = ARMul_DataAbortV ;
#define ARMul_CLEARABORT state->abortSig = LOW

/***************************************************************************\
*              Definitons of things in the memory interface                 *
\***************************************************************************/

extern unsigned ARMul_MemoryInit (ARMul_State * state,
				  unsigned long initmemsize);
extern void ARMul_MemoryExit (ARMul_State * state);

extern ARMword ARMul_LoadInstrS (ARMul_State * state, ARMword address,
				 ARMword isize);
extern ARMword ARMul_LoadInstrN (ARMul_State * state, ARMword address,
				 ARMword isize);
extern ARMword ARMul_ReLoadInstr (ARMul_State * state, ARMword address,
				  ARMword isize);

extern ARMword ARMul_LoadWordS (ARMul_State * state, ARMword address);
extern ARMword ARMul_LoadWordN (ARMul_State * state, ARMword address);
extern ARMword ARMul_LoadHalfWord (ARMul_State * state, ARMword address);
extern ARMword ARMul_LoadByte (ARMul_State * state, ARMword address);

extern void ARMul_StoreWordS (ARMul_State * state, ARMword address,
			      ARMword data);
extern void ARMul_StoreWordN (ARMul_State * state, ARMword address,
			      ARMword data);
extern void ARMul_StoreHalfWord (ARMul_State * state, ARMword address,
				 ARMword data);
extern void ARMul_StoreByte (ARMul_State * state, ARMword address,
			     ARMword data);

extern ARMword ARMul_SwapWord (ARMul_State * state, ARMword address,
			       ARMword data);
extern ARMword ARMul_SwapByte (ARMul_State * state, ARMword address,
			       ARMword data);

extern void ARMul_Icycles (ARMul_State * state, unsigned number,
			   ARMword address);
extern void ARMul_Ccycles (ARMul_State * state, unsigned number,
			   ARMword address);

extern ARMword ARMul_ReadWord (ARMul_State * state, ARMword address);
extern ARMword ARMul_ReadByte (ARMul_State * state, ARMword address);
extern ARMword ARMul_SafeReadByte (ARMul_State * state, ARMword address);
extern void ARMul_WriteWord (ARMul_State * state, ARMword address,
			     ARMword data);
extern void ARMul_WriteByte (ARMul_State * state, ARMword address,
			     ARMword data);
extern void ARMul_SafeWriteByte (ARMul_State * state, ARMword address,
			     ARMword data);

extern ARMword ARMul_MemAccess (ARMul_State * state, ARMword, ARMword,
				ARMword, ARMword, ARMword, ARMword, ARMword,
				ARMword, ARMword, ARMword);

/***************************************************************************\
*            Definitons of things in the co-processor interface             *
\***************************************************************************/

#define ARMul_FIRST 0
#define ARMul_TRANSFER 1
#define ARMul_BUSY 2
#define ARMul_DATA 3
#define ARMul_INTERRUPT 4
#define ARMul_DONE 0
#define ARMul_CANT 1
#define ARMul_INC 3

#define ARMul_CP13_R0_FIQ	0x1
#define ARMul_CP13_R0_IRQ	0x2
#define ARMul_CP13_R8_PMUS	0x1

#define ARMul_CP14_R0_ENABLE	0x0001
#define ARMul_CP14_R0_CLKRST	0x0004
#define ARMul_CP14_R0_CCD	0x0008
#define ARMul_CP14_R0_INTEN0	0x0010
#define ARMul_CP14_R0_INTEN1	0x0020
#define ARMul_CP14_R0_INTEN2	0x0040
#define ARMul_CP14_R0_FLAG0	0x0100
#define ARMul_CP14_R0_FLAG1	0x0200
#define ARMul_CP14_R0_FLAG2	0x0400
#define ARMul_CP14_R10_MOE_IB	0x0004
#define ARMul_CP14_R10_MOE_DB	0x0008
#define ARMul_CP14_R10_MOE_BT	0x000c
#define ARMul_CP15_R1_ENDIAN	0x0080
#define ARMul_CP15_R1_ALIGN	0x0002
#define ARMul_CP15_R5_X		0x0400
#define ARMul_CP15_R5_ST_ALIGN	0x0001
#define ARMul_CP15_R5_IMPRE	0x0406
#define ARMul_CP15_R5_MMU_EXCPT	0x0400
#define ARMul_CP15_DBCON_M	0x0100
#define ARMul_CP15_DBCON_E1	0x000c
#define ARMul_CP15_DBCON_E0	0x0003

extern unsigned ARMul_CoProInit (ARMul_State * state);
extern void ARMul_CoProExit (ARMul_State * state);
extern void ARMul_CoProAttach (ARMul_State * state, unsigned number,
			       ARMul_CPInits * init, ARMul_CPExits * exit,
			       ARMul_LDCs * ldc, ARMul_STCs * stc,
			       ARMul_MRCs * mrc, ARMul_MCRs * mcr,
			       ARMul_CDPs * cdp,
			       ARMul_CPReads * read, ARMul_CPWrites * write);
extern void ARMul_CoProDetach (ARMul_State * state, unsigned number);
extern void XScale_check_memacc (ARMul_State * state, ARMword * address,
				 int store);
extern void XScale_set_fsr_far (ARMul_State * state, ARMword fsr, ARMword far);
extern int XScale_debug_moe (ARMul_State * state, int moe);

/***************************************************************************\
*               Definitons of things in the host environment                *
\***************************************************************************/

extern unsigned ARMul_OSInit (ARMul_State * state);
extern void ARMul_OSExit (ARMul_State * state);
extern unsigned ARMul_OSHandleSWI (ARMul_State * state, ARMword number);
extern ARMword ARMul_OSLastErrorP (ARMul_State * state);

extern ARMword ARMul_Debug (ARMul_State * state, ARMword pc, ARMword instr);
extern unsigned ARMul_OSException (ARMul_State * state, ARMword vector,
				   ARMword pc);
extern int rdi_log;

/***************************************************************************\
*                            Host-dependent stuff                           *
\***************************************************************************/

#ifdef macintosh
pascal void SpinCursor (short increment);	/* copied from CursorCtl.h */
# define HOURGLASS           SpinCursor( 1 )
# define HOURGLASS_RATE      1023	/* 2^n - 1 */
#endif

extern void ARMul_UndefInstr      (ARMul_State *, ARMword);
extern void ARMul_FixCPSR         (ARMul_State *, ARMword, ARMword);
extern void ARMul_FixSPSR         (ARMul_State *, ARMword, ARMword);
extern void ARMul_ConsolePrint    (ARMul_State *, const char *, ...);
extern void ARMul_SelectProcessor (ARMul_State *, unsigned);
@


1.15
log
@Update sim copyright headers from GPLv2-or-later to GPLv3-or-later.

gdb/sim/ChangeLog:

        Update the non-FSF-copyrighted files in sim to GPLv3 or later.
@
text
@d15 1
a15 2
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA. */
@


1.14
log
@2005-09-19  Paul Brook  <paul@@codesourcery.com>

	* armdefs.h: Define ARMsword and ARMsdword. Use stdint.h when
	available.
	* armemu.c: Use them.
	* armvirt.c (ARMul_MemoryInit): Use correct type for size.
	* configure.ac: Check for stdint.h.
	* config.in: Regenerate.
	* configure: Regenerate.
@
text
@d6 1
a6 1
    the Free Software Foundation; either version 2 of the License, or
@


1.13
log
@Update the address of the FSF organization
@
text
@d18 1
d33 9
a41 1
typedef unsigned long ARMword;	/* must be 32 bits wide */
d43 2
@


1.12
log
@* armemu.c (handle_v6_insn): New function - emulate a few of the v6 instructions - the ones now generated by GCC.
  (ARMulEmulate32): Call handle_v6_insn when a possible v6 insn is found.
* armdefs.h (struct ARMul_State): Add new field: is_v6.#
  (ARM_v6_Prop): Define.
* arminit.c (ARMul_NewState): Initialise the v6 flag.
  (ARMul_SelectProcessor): Determine if the v6 flag should be set.
* wrapper.c (sim_create_inferior): For unknown architectures, default to allowing the v6 instructions.
@
text
@d16 1
a16 1
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
@


1.11
log
@Add iWMMXt support to ARM simulator
@
text
@d137 1
d170 1
@


1.10
log
@Add Cirrus Maverick support to arm simulator
@
text
@d138 1
d168 1
@


1.10.2.1
log
@Merge with mainline.
@
text
@a137 1
  unsigned is_iWMMXt;		/* Are we emulating an iWMMXt co-processor ?  */
a166 1
#define ARM_iWMMXt_Prop  0x800
@


1.9
log
@* XScale coprocessor support.

2001-04-18  matthew green  <mrg@@redhat.com>

	* armcopro.c (write_cp15_reg): Set CHANGEMODE if endianness changes.
	(read_cp15_reg): Make non-static.
	(XScale_cp15_LDC): Update for write_cp15_reg() change.
	(XScale_cp15_MCR): Likewise.
	(XScale_cp15_write_reg): Likewise.
	(XScale_check_memacc): New function. Check for breakpoints being
	activated by memory accesses.  Does not support the Branch Target
	Buffer.
	(XScale_set_fsr_far): New function. Set FSR and FAR for XScale.
	(XScale_debug_moe): New function. Set the debug Method Of Entry,
	if configured.
	(write_cp14_reg): Reset count counter if requested.
	* armdefs.h (struct ARMul_State): New members `LastTime' and
	`CP14R0_CCD' used for the timer/counters.
	(ARMul_CP13_R0_FIQ, ARMul_CP13_R0_IRQ, ARMul_CP13_R8_PMUS,
	ARMul_CP14_R0_ENABLE, ARMul_CP14_R0_CLKRST, ARMul_CP14_R0_CCD,
	ARMul_CP14_R0_INTEN0, ARMul_CP14_R0_INTEN1, ARMul_CP14_R0_INTEN2,
	ARMul_CP14_R0_FLAG0, ARMul_CP14_R0_FLAG1, ARMul_CP14_R0_FLAG2,
	ARMul_CP14_R10_MOE_IB, ARMul_CP14_R10_MOE_DB, ARMul_CP14_R10_MOE_BT,
	ARMul_CP15_R1_ENDIAN, ARMul_CP15_R1_ALIGN, ARMul_CP15_R5_X,
	ARMul_CP15_R5_ST_ALIGN, ARMul_CP15_R5_IMPRE, ARMul_CP15_R5_MMU_EXCPT,
	ARMul_CP15_DBCON_M, ARMul_CP15_DBCON_E1, ARMul_CP15_DBCON_E0): New
	defines for XScale registers.
	(XScale_check_memacc, XScale_set_fsr_far, XScale_debug_moe): Prototype.
	(ARMul_Emulate32, ARMul_Emulate26): Clean up function definition.
	(ARMul_Emulate32): Handle the clock counter and hardware instruction
	breakpoints.  Call XScale_set_fsr_far() for software breakpoints and
	software interrupts.
	(LoadMult): Call XScale_set_fsr_far() for data aborts.
	(LoadSMult): Likewise.
	(StoreMult): Likewise.
	(StoreSMult): Likewise.
	* armemu.h (write_cp15_reg): Update prototype.
	* arminit.c (ARMul_NewState): Initialise CP14R0_CCD and LastTime.
	(ARMul_Abort): If XScale, check for FIQ and IRQ being enabled in CP13
	register 0.
	* armvirt.c (GetWord): Call XScale_check_memacc().
	(PutWord): Likewise.
@
text
@d138 1
d166 1
@


1.9.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a137 2
  unsigned is_iWMMXt;		/* Are we emulating an iWMMXt co-processor ?  */
  unsigned is_ep9312;		/* Are we emulating a Cirrus Maverick co-processor ?  */
a164 2
#define ARM_ep9312_Prop  0x400
#define ARM_iWMMXt_Prop  0x800
@


1.9.22.1
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a137 2
  unsigned is_iWMMXt;		/* Are we emulating an iWMMXt co-processor ?  */
  unsigned is_ep9312;		/* Are we emulating a Cirrus Maverick co-processor ?  */
a164 2
#define ARM_ep9312_Prop  0x400
#define ARM_iWMMXt_Prop  0x800
@


1.8
log
@Add support for disabling alignment checks when performing GDB interface
calls or SWI emulaiton routines.  (Alignment checking code has not yet been
contributed).
@
text
@d105 3
d348 26
d383 4
@


1.7
log
@Add support for ARM's v5TE architecture and Intel's XScale extenstions
@
text
@d320 1
d324 2
@


1.6
log
@Replace StrongARM property with v4 and v5 properties.
@
text
@d33 1
d60 3
d66 1
d133 2
d160 2
@


1.5
log
@* armdefs.h (struct ARMul_State): Add is_StrongARM.
(ARM_Strong_Prop, STRONGARM): Define.
* arminit.c (ARMul_NewState): Reset is_StrongARM.
(ARMul_SelectProcessor): Set is_StrongARM.
* wrapper.c (sim_create_inferior): Use bfd machine type to
determine processor type to emulate.
* armemu.h (BUSUSEDINCPCS, BUSUSEDINCPCN): Don't increment PC
when emulating StrongARM.
@
text
@d126 3
a128 3
  unsigned is_StrongARM;	/* Are we emulating a StrongARM? */

  int verbose;			/* non-zero means print various messages like the banner */
d142 1
a142 1
*                        Types of ARM we know about                         *
d151 2
a152 20
#define ARM_Strong_Prop  0x40

/* ARM2 family */
#define ARM2    (ARM_Fix26_Prop)
#define ARM2as  ARM2
#define ARM61   ARM2
#define ARM3    ARM2

#ifdef ARM60			/* previous definition in armopts.h */
#undef ARM60
#endif

/* ARM6 family */
#define ARM6    (ARM_Lock_Prop)
#define ARM60   ARM6
#define ARM600  ARM6
#define ARM610  ARM6
#define ARM620  ARM6

#define STRONGARM (ARM_Strong_Prop)
@


1.4
log
@* armdefs.h (SYSTEMBANK): Define as USERBANK.
* armsupp.c (ARMul_SwitchMode): Remove SYSTEMBANK cases.
@
text
@d126 2
d151 1
d170 1
@


1.3
log
@Add support for v4 SystemMode.
@
text
@d229 1
a229 1
#define SYSTEMBANK 7
@


1.2
log
@Fix compile time warning messages.
@
text
@d203 8
a210 8
#define USER26MODE 0L
#define FIQ26MODE 1L
#define IRQ26MODE 2L
#define SVC26MODE 3L
#define USER32MODE 16L
#define FIQ32MODE 17L
#define IRQ32MODE 18L
#define SVC32MODE 19L
d213 1
d229 4
@


1.1
log
@Initial revision
@
text
@d29 1
a29 1
typedef char * VoidStar ;
d32 2
a33 1
typedef unsigned long ARMword ; /* must be 32 bits wide */
d35 27
a61 21
typedef struct ARMul_State ARMul_State ;

typedef unsigned ARMul_CPInits(ARMul_State *state) ;
typedef unsigned ARMul_CPExits(ARMul_State *state) ;
typedef unsigned ARMul_LDCs(ARMul_State *state,unsigned type,ARMword instr,ARMword value) ;
typedef unsigned ARMul_STCs(ARMul_State *state,unsigned type,ARMword instr,ARMword *value) ;
typedef unsigned ARMul_MRCs(ARMul_State *state,unsigned type,ARMword instr,ARMword *value) ;
typedef unsigned ARMul_MCRs(ARMul_State *state,unsigned type,ARMword instr,ARMword value) ;
typedef unsigned ARMul_CDPs(ARMul_State *state,unsigned type,ARMword instr) ;
typedef unsigned ARMul_CPReads(ARMul_State *state,unsigned reg,ARMword *value) ;
typedef unsigned ARMul_CPWrites(ARMul_State *state,unsigned reg,ARMword value) ;

struct ARMul_State {
   ARMword Emulate ; /* to start and stop emulation */
   unsigned EndCondition ; /* reason for stopping */
   unsigned ErrorCode ; /* type of illegal instruction */
   ARMword Reg[16] ; /* the current register file */
   ARMword RegBank[7][16] ; /* all the registers */
   ARMword Cpsr ; /* the current psr */
   ARMword Spsr[7] ; /* the exception psr's */
   ARMword NFlag, ZFlag, CFlag, VFlag, IFFlags ; /* dummy flags for speed */
d63 1
a63 1
   ARMword TFlag ; /* Thumb state */
d65 58
a122 62
   ARMword Bank ; /* the current register bank */
   ARMword Mode ; /* the current mode */
   ARMword instr, pc, temp ; /* saved register state */
   ARMword loaded, decoded ; /* saved pipeline state */
   unsigned long NumScycles,
                 NumNcycles,
                 NumIcycles,
                 NumCcycles,
                 NumFcycles ; /* emulated cycles used */
   unsigned long NumInstrs ; /* the number of instructions executed */
   unsigned NextInstr ;
   unsigned VectorCatch ; /* caught exception mask */
   unsigned CallDebug ; /* set to call the debugger */
   unsigned CanWatch ; /* set by memory interface if its willing to suffer the
			  overhead of checking for watchpoints on each memory
			  access */
   unsigned MemReadDebug, MemWriteDebug ;
   unsigned long StopHandle ;

   unsigned char *MemDataPtr ; /* admin data */
   unsigned char *MemInPtr ; /* the Data In bus */
   unsigned char *MemOutPtr ; /* the Data Out bus (which you may not need */
   unsigned char *MemSparePtr ; /* extra space */
   ARMword MemSize ;

   unsigned char *OSptr ; /* OS Handle */
   char *CommandLine ; /* Command Line from ARMsd */

   ARMul_CPInits *CPInit[16] ; /* coprocessor initialisers */
   ARMul_CPExits *CPExit[16] ; /* coprocessor finalisers */
   ARMul_LDCs *LDC[16] ; /* LDC instruction */
   ARMul_STCs *STC[16] ; /* STC instruction */
   ARMul_MRCs *MRC[16] ; /* MRC instruction */
   ARMul_MCRs *MCR[16] ; /* MCR instruction */
   ARMul_CDPs *CDP[16] ; /* CDP instruction */
   ARMul_CPReads *CPRead[16] ; /* Read CP register */
   ARMul_CPWrites *CPWrite[16] ; /* Write CP register */
   unsigned char *CPData[16] ; /* Coprocessor data */
   unsigned char const *CPRegWords[16] ;  /* map of coprocessor register sizes */

   unsigned EventSet ; /* the number of events in the queue */
   unsigned long Now ; /* time to the nearest cycle */
   struct EventNode **EventPtr ; /* the event list */

   unsigned Exception ; /* enable the next four values */
   unsigned Debug ; /* show instructions as they are executed */
   unsigned NresetSig ; /* reset the processor */
   unsigned NfiqSig ;
   unsigned NirqSig ;

   unsigned abortSig ;
   unsigned NtransSig ;
   unsigned bigendSig ;
   unsigned prog32Sig ;
   unsigned data32Sig ;
   unsigned lateabtSig ;
   ARMword Vector ; /* synthesize aborts in cycle modes */
   ARMword Aborted ; /* sticky flag for aborts */
   ARMword Reseted ; /* sticky flag for Reset */
   ARMword Inted, LastInted ; /* sticky flags for interrupts */
   ARMword Base ; /* extra hand for base writeback */
   ARMword AbortAddr ; /* to keep track of Prefetch aborts */
d124 1
a124 1
   const struct Dbg_HostosInterface *hostif;
d126 2
a127 2
   int verbose; /* non-zero means print various messages like the banner */
 } ;
d142 1
a142 1
 
d149 1
a149 1
 
d156 1
a156 1
#ifdef ARM60	/* previous definition in armopts.h */
d166 1
a166 1
 
d172 3
a174 3
#define BIT(n) ( (ARMword)(instr>>(n))&1)   /* bit n of instruction */
#define BITS(m,n) ( (ARMword)(instr<<(31-(n))) >> ((31-(n))+(m)) ) /* bits m to n of instr */
#define TOPBITS(n) (instr >> (n)) /* bits 31 to n of instr */
d188 1
a188 1
#define ARMErrorV 32L /* This is an offset, not an address ! */
d233 5
a237 5
extern void ARMul_EmulateInit(void) ;
extern ARMul_State *ARMul_NewState(void) ;
extern void ARMul_Reset(ARMul_State *state) ;
extern ARMword ARMul_DoProg(ARMul_State *state) ;
extern ARMword ARMul_DoInstr(ARMul_State *state) ;
d243 4
a246 3
extern void ARMul_ScheduleEvent(ARMul_State *state, unsigned long delay, unsigned (*func)() ) ;
extern void ARMul_EnvokeEvent(ARMul_State *state) ;
extern unsigned long ARMul_Time(ARMul_State *state) ;
d252 14
a265 12
extern ARMword ARMul_GetReg(ARMul_State *state, unsigned mode, unsigned reg) ;
extern void ARMul_SetReg(ARMul_State *state, unsigned mode, unsigned reg, ARMword value) ;
extern ARMword ARMul_GetPC(ARMul_State *state) ;
extern ARMword ARMul_GetNextPC(ARMul_State *state) ;
extern void ARMul_SetPC(ARMul_State *state, ARMword value) ;
extern ARMword ARMul_GetR15(ARMul_State *state) ;
extern void ARMul_SetR15(ARMul_State *state, ARMword value) ;

extern ARMword ARMul_GetCPSR(ARMul_State *state) ;
extern void ARMul_SetCPSR(ARMul_State *state, ARMword value) ;
extern ARMword ARMul_GetSPSR(ARMul_State *state, ARMword mode) ;
extern void ARMul_SetSPSR(ARMul_State *state, ARMword mode, ARMword value) ;
d271 2
a272 2
extern void ARMul_Abort(ARMul_State *state, ARMword address) ;
#define ARMul_ABORTWORD 0xefffffff /* SWI -1 */
d283 45
a327 30
extern unsigned ARMul_MemoryInit(ARMul_State *state,unsigned long initmemsize) ;
extern void ARMul_MemoryExit(ARMul_State *state) ;

extern ARMword ARMul_LoadInstrS(ARMul_State *state,ARMword address,ARMword isize) ;
extern ARMword ARMul_LoadInstrN(ARMul_State *state,ARMword address,ARMword isize) ;
extern ARMword ARMul_ReLoadInstr(ARMul_State *state,ARMword address,ARMword isize) ;

extern ARMword ARMul_LoadWordS(ARMul_State *state,ARMword address) ;
extern ARMword ARMul_LoadWordN(ARMul_State *state,ARMword address) ;
extern ARMword ARMul_LoadHalfWord(ARMul_State *state,ARMword address) ;
extern ARMword ARMul_LoadByte(ARMul_State *state,ARMword address) ;

extern void ARMul_StoreWordS(ARMul_State *state,ARMword address, ARMword data) ;
extern void ARMul_StoreWordN(ARMul_State *state,ARMword address, ARMword data) ;
extern void ARMul_StoreHalfWord(ARMul_State *state,ARMword address, ARMword data) ;
extern void ARMul_StoreByte(ARMul_State *state,ARMword address, ARMword data) ;

extern ARMword ARMul_SwapWord(ARMul_State *state,ARMword address, ARMword data) ;
extern ARMword ARMul_SwapByte(ARMul_State *state,ARMword address, ARMword data) ;

extern void ARMul_Icycles(ARMul_State *state,unsigned number, ARMword address) ;
extern void ARMul_Ccycles(ARMul_State *state,unsigned number, ARMword address) ;

extern ARMword ARMul_ReadWord(ARMul_State *state,ARMword address) ;
extern ARMword ARMul_ReadByte(ARMul_State *state,ARMword address) ;
extern void ARMul_WriteWord(ARMul_State *state,ARMword address, ARMword data) ;
extern void ARMul_WriteByte(ARMul_State *state,ARMword address, ARMword data) ;

extern ARMword ARMul_MemAccess(ARMul_State *state,ARMword,ARMword,ARMword,
                  ARMword,ARMword,ARMword,ARMword,ARMword,ARMword,ARMword) ;
d342 9
a350 9
extern unsigned ARMul_CoProInit(ARMul_State *state) ;
extern void ARMul_CoProExit(ARMul_State *state) ;
extern void ARMul_CoProAttach(ARMul_State *state, unsigned number,
                              ARMul_CPInits *init, ARMul_CPExits *exit,
                              ARMul_LDCs *ldc, ARMul_STCs *stc,
                              ARMul_MRCs *mrc, ARMul_MCRs *mcr,
                              ARMul_CDPs *cdp,
                              ARMul_CPReads *read, ARMul_CPWrites *write) ;
extern void ARMul_CoProDetach(ARMul_State *state, unsigned number) ;
d356 9
a364 8
extern unsigned ARMul_OSInit(ARMul_State *state) ;
extern void ARMul_OSExit(ARMul_State *state) ;
extern unsigned ARMul_OSHandleSWI(ARMul_State *state,ARMword number) ;
extern ARMword ARMul_OSLastErrorP(ARMul_State *state) ;

extern ARMword ARMul_Debug(ARMul_State *state, ARMword pc, ARMword instr) ;
extern unsigned ARMul_OSException(ARMul_State *state, ARMword vector, ARMword pc) ;
extern int rdi_log ;
d371 1
a371 1
pascal void SpinCursor(short increment);        /* copied from CursorCtl.h */
d373 1
a373 1
# define HOURGLASS_RATE      1023   /* 2^n - 1 */
d376 5
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-12 snapshot
@
text
@d33 1
@


1.1.1.3
log
@import gdb-2000-02-04 snapshot
@
text
@d29 1
a29 1
typedef char *VoidStar;
d32 2
a33 2
typedef unsigned long ARMword;	/* must be 32 bits wide */
typedef struct ARMul_State ARMul_State;
d35 19
a53 27
typedef unsigned ARMul_CPInits (ARMul_State * state);
typedef unsigned ARMul_CPExits (ARMul_State * state);
typedef unsigned ARMul_LDCs (ARMul_State * state, unsigned type,
			     ARMword instr, ARMword value);
typedef unsigned ARMul_STCs (ARMul_State * state, unsigned type,
			     ARMword instr, ARMword * value);
typedef unsigned ARMul_MRCs (ARMul_State * state, unsigned type,
			     ARMword instr, ARMword * value);
typedef unsigned ARMul_MCRs (ARMul_State * state, unsigned type,
			     ARMword instr, ARMword value);
typedef unsigned ARMul_CDPs (ARMul_State * state, unsigned type,
			     ARMword instr);
typedef unsigned ARMul_CPReads (ARMul_State * state, unsigned reg,
				ARMword * value);
typedef unsigned ARMul_CPWrites (ARMul_State * state, unsigned reg,
				 ARMword value);

struct ARMul_State
{
  ARMword Emulate;		/* to start and stop emulation */
  unsigned EndCondition;	/* reason for stopping */
  unsigned ErrorCode;		/* type of illegal instruction */
  ARMword Reg[16];		/* the current register file */
  ARMword RegBank[7][16];	/* all the registers */
  ARMword Cpsr;			/* the current psr */
  ARMword Spsr[7];		/* the exception psr's */
  ARMword NFlag, ZFlag, CFlag, VFlag, IFFlags;	/* dummy flags for speed */
d55 1
a55 1
  ARMword TFlag;		/* Thumb state */
d57 62
a118 58
  ARMword Bank;			/* the current register bank */
  ARMword Mode;			/* the current mode */
  ARMword instr, pc, temp;	/* saved register state */
  ARMword loaded, decoded;	/* saved pipeline state */
  unsigned long NumScycles, NumNcycles, NumIcycles, NumCcycles, NumFcycles;	/* emulated cycles used */
  unsigned long NumInstrs;	/* the number of instructions executed */
  unsigned NextInstr;
  unsigned VectorCatch;		/* caught exception mask */
  unsigned CallDebug;		/* set to call the debugger */
  unsigned CanWatch;		/* set by memory interface if its willing to suffer the
				   overhead of checking for watchpoints on each memory
				   access */
  unsigned MemReadDebug, MemWriteDebug;
  unsigned long StopHandle;

  unsigned char *MemDataPtr;	/* admin data */
  unsigned char *MemInPtr;	/* the Data In bus */
  unsigned char *MemOutPtr;	/* the Data Out bus (which you may not need */
  unsigned char *MemSparePtr;	/* extra space */
  ARMword MemSize;

  unsigned char *OSptr;		/* OS Handle */
  char *CommandLine;		/* Command Line from ARMsd */

  ARMul_CPInits *CPInit[16];	/* coprocessor initialisers */
  ARMul_CPExits *CPExit[16];	/* coprocessor finalisers */
  ARMul_LDCs *LDC[16];		/* LDC instruction */
  ARMul_STCs *STC[16];		/* STC instruction */
  ARMul_MRCs *MRC[16];		/* MRC instruction */
  ARMul_MCRs *MCR[16];		/* MCR instruction */
  ARMul_CDPs *CDP[16];		/* CDP instruction */
  ARMul_CPReads *CPRead[16];	/* Read CP register */
  ARMul_CPWrites *CPWrite[16];	/* Write CP register */
  unsigned char *CPData[16];	/* Coprocessor data */
  unsigned char const *CPRegWords[16];	/* map of coprocessor register sizes */

  unsigned EventSet;		/* the number of events in the queue */
  unsigned long Now;		/* time to the nearest cycle */
  struct EventNode **EventPtr;	/* the event list */

  unsigned Exception;		/* enable the next four values */
  unsigned Debug;		/* show instructions as they are executed */
  unsigned NresetSig;		/* reset the processor */
  unsigned NfiqSig;
  unsigned NirqSig;

  unsigned abortSig;
  unsigned NtransSig;
  unsigned bigendSig;
  unsigned prog32Sig;
  unsigned data32Sig;
  unsigned lateabtSig;
  ARMword Vector;		/* synthesize aborts in cycle modes */
  ARMword Aborted;		/* sticky flag for aborts */
  ARMword Reseted;		/* sticky flag for Reset */
  ARMword Inted, LastInted;	/* sticky flags for interrupts */
  ARMword Base;			/* extra hand for base writeback */
  ARMword AbortAddr;		/* to keep track of Prefetch aborts */
d120 1
a120 1
  const struct Dbg_HostosInterface *hostif;
d122 2
a123 2
  int verbose;			/* non-zero means print various messages like the banner */
};
d138 1
a138 1

d145 1
a145 1

d152 1
a152 1
#ifdef ARM60			/* previous definition in armopts.h */
d162 1
a162 1

d168 3
a170 3
#define BIT(n) ( (ARMword)(instr>>(n))&1)	/* bit n of instruction */
#define BITS(m,n) ( (ARMword)(instr<<(31-(n))) >> ((31-(n))+(m)) )	/* bits m to n of instr */
#define TOPBITS(n) (instr >> (n))	/* bits 31 to n of instr */
d184 1
a184 1
#define ARMErrorV 32L		/* This is an offset, not an address ! */
d229 5
a233 5
extern void ARMul_EmulateInit (void);
extern ARMul_State *ARMul_NewState (void);
extern void ARMul_Reset (ARMul_State * state);
extern ARMword ARMul_DoProg (ARMul_State * state);
extern ARMword ARMul_DoInstr (ARMul_State * state);
d239 3
a241 4
extern void ARMul_ScheduleEvent (ARMul_State * state, unsigned long delay,
				 unsigned (*func) ());
extern void ARMul_EnvokeEvent (ARMul_State * state);
extern unsigned long ARMul_Time (ARMul_State * state);
d247 12
a258 14
extern ARMword ARMul_GetReg (ARMul_State * state, unsigned mode,
			     unsigned reg);
extern void ARMul_SetReg (ARMul_State * state, unsigned mode, unsigned reg,
			  ARMword value);
extern ARMword ARMul_GetPC (ARMul_State * state);
extern ARMword ARMul_GetNextPC (ARMul_State * state);
extern void ARMul_SetPC (ARMul_State * state, ARMword value);
extern ARMword ARMul_GetR15 (ARMul_State * state);
extern void ARMul_SetR15 (ARMul_State * state, ARMword value);

extern ARMword ARMul_GetCPSR (ARMul_State * state);
extern void ARMul_SetCPSR (ARMul_State * state, ARMword value);
extern ARMword ARMul_GetSPSR (ARMul_State * state, ARMword mode);
extern void ARMul_SetSPSR (ARMul_State * state, ARMword mode, ARMword value);
d264 2
a265 2
extern void ARMul_Abort (ARMul_State * state, ARMword address);
#define ARMul_ABORTWORD 0xefffffff	/* SWI -1 */
d276 30
a305 45
extern unsigned ARMul_MemoryInit (ARMul_State * state,
				  unsigned long initmemsize);
extern void ARMul_MemoryExit (ARMul_State * state);

extern ARMword ARMul_LoadInstrS (ARMul_State * state, ARMword address,
				 ARMword isize);
extern ARMword ARMul_LoadInstrN (ARMul_State * state, ARMword address,
				 ARMword isize);
extern ARMword ARMul_ReLoadInstr (ARMul_State * state, ARMword address,
				  ARMword isize);

extern ARMword ARMul_LoadWordS (ARMul_State * state, ARMword address);
extern ARMword ARMul_LoadWordN (ARMul_State * state, ARMword address);
extern ARMword ARMul_LoadHalfWord (ARMul_State * state, ARMword address);
extern ARMword ARMul_LoadByte (ARMul_State * state, ARMword address);

extern void ARMul_StoreWordS (ARMul_State * state, ARMword address,
			      ARMword data);
extern void ARMul_StoreWordN (ARMul_State * state, ARMword address,
			      ARMword data);
extern void ARMul_StoreHalfWord (ARMul_State * state, ARMword address,
				 ARMword data);
extern void ARMul_StoreByte (ARMul_State * state, ARMword address,
			     ARMword data);

extern ARMword ARMul_SwapWord (ARMul_State * state, ARMword address,
			       ARMword data);
extern ARMword ARMul_SwapByte (ARMul_State * state, ARMword address,
			       ARMword data);

extern void ARMul_Icycles (ARMul_State * state, unsigned number,
			   ARMword address);
extern void ARMul_Ccycles (ARMul_State * state, unsigned number,
			   ARMword address);

extern ARMword ARMul_ReadWord (ARMul_State * state, ARMword address);
extern ARMword ARMul_ReadByte (ARMul_State * state, ARMword address);
extern void ARMul_WriteWord (ARMul_State * state, ARMword address,
			     ARMword data);
extern void ARMul_WriteByte (ARMul_State * state, ARMword address,
			     ARMword data);

extern ARMword ARMul_MemAccess (ARMul_State * state, ARMword, ARMword,
				ARMword, ARMword, ARMword, ARMword, ARMword,
				ARMword, ARMword, ARMword);
d320 9
a328 9
extern unsigned ARMul_CoProInit (ARMul_State * state);
extern void ARMul_CoProExit (ARMul_State * state);
extern void ARMul_CoProAttach (ARMul_State * state, unsigned number,
			       ARMul_CPInits * init, ARMul_CPExits * exit,
			       ARMul_LDCs * ldc, ARMul_STCs * stc,
			       ARMul_MRCs * mrc, ARMul_MCRs * mcr,
			       ARMul_CDPs * cdp,
			       ARMul_CPReads * read, ARMul_CPWrites * write);
extern void ARMul_CoProDetach (ARMul_State * state, unsigned number);
d334 8
a341 9
extern unsigned ARMul_OSInit (ARMul_State * state);
extern void ARMul_OSExit (ARMul_State * state);
extern unsigned ARMul_OSHandleSWI (ARMul_State * state, ARMword number);
extern ARMword ARMul_OSLastErrorP (ARMul_State * state);

extern ARMword ARMul_Debug (ARMul_State * state, ARMword pc, ARMword instr);
extern unsigned ARMul_OSException (ARMul_State * state, ARMword vector,
				   ARMword pc);
extern int rdi_log;
d348 1
a348 1
pascal void SpinCursor (short increment);	/* copied from CursorCtl.h */
d350 1
a350 1
# define HOURGLASS_RATE      1023	/* 2^n - 1 */
d352 1
@


