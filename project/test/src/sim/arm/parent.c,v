head	1.4;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.4
	gdb_7_6-2013-04-26-release:1.4
	gdb_7_6-branch:1.4.0.2
	gdb_7_6-2013-03-12-branchpoint:1.4
	gdb_7_5_1-2012-11-29-release:1.2
	gdb_7_5-2012-08-17-release:1.2
	gdb_7_5-branch:1.2.0.62
	gdb_7_5-2012-07-18-branchpoint:1.2
	gdb_7_4_1-2012-04-26-release:1.2
	gdb_7_4-2012-01-24-release:1.2
	gdb_7_4-branch:1.2.0.60
	gdb_7_4-2011-12-13-branchpoint:1.2
	gdb_7_3_1-2011-09-04-release:1.2
	gdb_7_3-2011-07-26-release:1.2
	gdb_7_3-branch:1.2.0.58
	gdb_7_3-2011-04-01-branchpoint:1.2
	gdb_7_2-2010-09-02-release:1.2
	gdb_7_2-branch:1.2.0.56
	gdb_7_2-2010-07-07-branchpoint:1.2
	gdb_7_1-2010-03-18-release:1.2
	gdb_7_1-branch:1.2.0.54
	gdb_7_1-2010-02-18-branchpoint:1.2
	gdb_7_0_1-2009-12-22-release:1.2
	gdb_7_0-2009-10-06-release:1.2
	gdb_7_0-branch:1.2.0.52
	gdb_7_0-2009-09-16-branchpoint:1.2
	arc-sim-20090309:1.2
	msnyder-checkpoint-072509-branch:1.2.0.50
	msnyder-checkpoint-072509-branchpoint:1.2
	arc-insight_6_8-branch:1.2.0.48
	arc-insight_6_8-branchpoint:1.2
	insight_6_8-branch:1.2.0.46
	insight_6_8-branchpoint:1.2
	reverse-20081226-branch:1.2.0.44
	reverse-20081226-branchpoint:1.2
	multiprocess-20081120-branch:1.2.0.42
	multiprocess-20081120-branchpoint:1.2
	reverse-20080930-branch:1.2.0.40
	reverse-20080930-branchpoint:1.2
	reverse-20080717-branch:1.2.0.38
	reverse-20080717-branchpoint:1.2
	msnyder-reverse-20080609-branch:1.2.0.36
	msnyder-reverse-20080609-branchpoint:1.2
	drow-reverse-20070409-branch:1.2.0.34
	drow-reverse-20070409-branchpoint:1.2
	gdb_6_8-2008-03-27-release:1.2
	gdb_6_8-branch:1.2.0.32
	gdb_6_8-2008-02-26-branchpoint:1.2
	gdb_6_7_1-2007-10-29-release:1.2
	gdb_6_7-2007-10-10-release:1.2
	gdb_6_7-branch:1.2.0.30
	gdb_6_7-2007-09-07-branchpoint:1.2
	insight_6_6-20070208-release:1.2
	gdb_6_6-2006-12-18-release:1.2
	gdb_6_6-branch:1.2.0.28
	gdb_6_6-2006-11-15-branchpoint:1.2
	insight_6_5-20061003-release:1.2
	gdb-csl-symbian-6_4_50_20060226-12:1.2
	gdb-csl-sourcerygxx-3_4_4-25:1.2
	nickrob-async-20060828-mergepoint:1.2
	gdb-csl-symbian-6_4_50_20060226-11:1.2
	gdb-csl-sourcerygxx-4_1-17:1.2
	gdb-csl-20060226-branch-local-2:1.2
	gdb-csl-sourcerygxx-4_1-14:1.2
	gdb-csl-sourcerygxx-4_1-13:1.2
	gdb-csl-sourcerygxx-4_1-12:1.2
	gdb-csl-sourcerygxx-3_4_4-21:1.2
	gdb_6_5-20060621-release:1.2
	gdb-csl-sourcerygxx-4_1-9:1.2
	gdb-csl-sourcerygxx-4_1-8:1.2
	gdb-csl-sourcerygxx-4_1-7:1.2
	gdb-csl-arm-2006q1-6:1.2
	gdb-csl-sourcerygxx-4_1-6:1.2
	gdb-csl-symbian-6_4_50_20060226-10:1.2
	gdb-csl-symbian-6_4_50_20060226-9:1.2
	gdb-csl-symbian-6_4_50_20060226-8:1.2
	gdb-csl-coldfire-4_1-11:1.2
	gdb-csl-sourcerygxx-3_4_4-19:1.2
	gdb-csl-coldfire-4_1-10:1.2
	gdb_6_5-branch:1.2.0.26
	gdb_6_5-2006-05-14-branchpoint:1.2
	gdb-csl-sourcerygxx-4_1-5:1.2
	nickrob-async-20060513-branch:1.2.0.24
	nickrob-async-20060513-branchpoint:1.2
	gdb-csl-sourcerygxx-4_1-4:1.2
	msnyder-reverse-20060502-branch:1.2.0.22
	msnyder-reverse-20060502-branchpoint:1.2
	gdb-csl-morpho-4_1-4:1.2
	gdb-csl-sourcerygxx-3_4_4-17:1.2
	readline_5_1-import-branch:1.2.0.20
	readline_5_1-import-branchpoint:1.2
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.2
	gdb-csl-symbian-20060226-branch:1.2.0.18
	gdb-csl-symbian-20060226-branchpoint:1.2
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.2
	msnyder-reverse-20060331-branch:1.2.0.16
	msnyder-reverse-20060331-branchpoint:1.2
	gdb-csl-available-20060303-branch:1.2.0.14
	gdb-csl-available-20060303-branchpoint:1.2
	gdb-csl-20060226-branch:1.2.0.12
	gdb-csl-20060226-branchpoint:1.2
	gdb_6_4-20051202-release:1.2
	msnyder-fork-checkpoint-branch:1.2.0.10
	msnyder-fork-checkpoint-branchpoint:1.2
	gdb-csl-gxxpro-6_3-branch:1.2.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.2
	gdb_6_4-branch:1.2.0.6
	gdb_6_4-2005-11-01-branchpoint:1.2
	gdb-csl-arm-20051020-branch:1.2.0.4
	gdb-csl-arm-20051020-branchpoint:1.2
	msnyder-tracepoint-checkpoint-branch:1.2.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.2
	gdb-csl-arm-20050325-2005-q1b:1.1.1.2
	gdb-csl-arm-20050325-2005-q1a:1.1.1.2
	csl-arm-20050325-branch:1.1.1.2.0.88
	csl-arm-20050325-branchpoint:1.1.1.2
	gdb_6_3-20041109-release:1.1.1.2
	gdb_6_3-branch:1.1.1.2.0.84
	gdb_6_3-20041019-branchpoint:1.1.1.2
	drow_intercu-merge-20040921:1.1.1.2
	drow_intercu-merge-20040915:1.1.1.2
	jimb-gdb_6_2-e500-branch:1.1.1.2.0.86
	jimb-gdb_6_2-e500-branchpoint:1.1.1.2
	gdb_6_2-20040730-release:1.1.1.2
	gdb_6_2-branch:1.1.1.2.0.82
	gdb_6_2-2004-07-10-gmt-branchpoint:1.1.1.2
	gdb_6_1_1-20040616-release:1.1.1.2
	gdb_6_1-2004-04-05-release:1.1.1.2
	drow_intercu-merge-20040402:1.1.1.2
	drow_intercu-merge-20040327:1.1.1.2
	ezannoni_pie-20040323-branch:1.1.1.2.0.80
	ezannoni_pie-20040323-branchpoint:1.1.1.2
	cagney_tramp-20040321-mergepoint:1.1.1.2
	cagney_tramp-20040309-branch:1.1.1.2.0.78
	cagney_tramp-20040309-branchpoint:1.1.1.2
	gdb_6_1-branch:1.1.1.2.0.76
	gdb_6_1-2004-03-01-gmt-branchpoint:1.1.1.2
	drow_intercu-20040221-branch:1.1.1.2.0.74
	drow_intercu-20040221-branchpoint:1.1.1.2
	cagney_bfdfile-20040213-branch:1.1.1.2.0.72
	cagney_bfdfile-20040213-branchpoint:1.1.1.2
	drow-cplus-merge-20040208:1.1.1.2
	carlton_dictionary-20040126-merge:1.1.1.2
	cagney_bigcore-20040122-branch:1.1.1.2.0.70
	cagney_bigcore-20040122-branchpoint:1.1.1.2
	drow-cplus-merge-20040113:1.1.1.2
	drow-cplus-merge-20031224:1.1.1.2
	drow-cplus-merge-20031220:1.1.1.2
	carlton_dictionary-20031215-merge:1.1.1.2
	drow-cplus-merge-20031214:1.1.1.2
	carlton-dictionary-20031111-merge:1.1.1.2
	gdb_6_0-2003-10-04-release:1.1.1.2
	kettenis_sparc-20030918-branch:1.1.1.2.0.68
	kettenis_sparc-20030918-branchpoint:1.1.1.2
	carlton_dictionary-20030917-merge:1.1.1.2
	ezannoni_pie-20030916-branchpoint:1.1.1.2
	ezannoni_pie-20030916-branch:1.1.1.2.0.66
	cagney_x86i386-20030821-branch:1.1.1.2.0.64
	cagney_x86i386-20030821-branchpoint:1.1.1.2
	carlton_dictionary-20030805-merge:1.1.1.2
	carlton_dictionary-20030627-merge:1.1.1.2
	gdb_6_0-branch:1.1.1.2.0.62
	gdb_6_0-2003-06-23-branchpoint:1.1.1.2
	jimb-ppc64-linux-20030613-branch:1.1.1.2.0.60
	jimb-ppc64-linux-20030613-branchpoint:1.1.1.2
	cagney_convert-20030606-branch:1.1.1.2.0.58
	cagney_convert-20030606-branchpoint:1.1.1.2
	cagney_writestrings-20030508-branch:1.1.1.2.0.56
	cagney_writestrings-20030508-branchpoint:1.1.1.2
	jimb-ppc64-linux-20030528-branch:1.1.1.2.0.54
	jimb-ppc64-linux-20030528-branchpoint:1.1.1.2
	carlton_dictionary-20030523-merge:1.1.1.2
	cagney_fileio-20030521-branch:1.1.1.2.0.52
	cagney_fileio-20030521-branchpoint:1.1.1.2
	kettenis_i386newframe-20030517-mergepoint:1.1.1.2
	jimb-ppc64-linux-20030509-branch:1.1.1.2.0.50
	jimb-ppc64-linux-20030509-branchpoint:1.1.1.2
	kettenis_i386newframe-20030504-mergepoint:1.1.1.2
	carlton_dictionary-20030430-merge:1.1.1.2
	kettenis_i386newframe-20030419-branch:1.1.1.2.0.48
	kettenis_i386newframe-20030419-branchpoint:1.1.1.2
	carlton_dictionary-20030416-merge:1.1.1.2
	cagney_frameaddr-20030409-mergepoint:1.1.1.2
	kettenis_i386newframe-20030406-branch:1.1.1.2.0.46
	kettenis_i386newframe-20030406-branchpoint:1.1.1.2
	cagney_frameaddr-20030403-branchpoint:1.1.1.2
	cagney_frameaddr-20030403-branch:1.1.1.2.0.44
	cagney_framebase-20030330-mergepoint:1.1.1.2
	cagney_framebase-20030326-branch:1.1.1.2.0.42
	cagney_framebase-20030326-branchpoint:1.1.1.2
	cagney_lazyid-20030317-branch:1.1.1.2.0.40
	cagney_lazyid-20030317-branchpoint:1.1.1.2
	kettenis-i386newframe-20030316-mergepoint:1.1.1.2
	offbyone-20030313-branch:1.1.1.2.0.38
	offbyone-20030313-branchpoint:1.1.1.2
	kettenis-i386newframe-20030308-branch:1.1.1.2.0.36
	kettenis-i386newframe-20030308-branchpoint:1.1.1.2
	carlton_dictionary-20030305-merge:1.1.1.2
	cagney_offbyone-20030303-branch:1.1.1.2.0.34
	cagney_offbyone-20030303-branchpoint:1.1.1.2
	carlton_dictionary-20030207-merge:1.1.1.2
	interps-20030202-branch:1.1.1.2.0.32
	interps-20030202-branchpoint:1.1.1.2
	cagney-unwind-20030108-branch:1.1.1.2.0.30
	cagney-unwind-20030108-branchpoint:1.1.1.2
	carlton_dictionary-20021223-merge:1.1.1.2
	gdb_5_3-2002-12-12-release:1.1.1.2
	carlton_dictionary-20021115-merge:1.1.1.2
	kseitz_interps-20021105-merge:1.1.1.2
	kseitz_interps-20021103-merge:1.1.1.2
	drow-cplus-merge-20021020:1.1.1.2
	drow-cplus-merge-20021025:1.1.1.2
	carlton_dictionary-20021025-merge:1.1.1.2
	carlton_dictionary-20021011-merge:1.1.1.2
	drow-cplus-branch:1.1.1.2.0.28
	drow-cplus-branchpoint:1.1.1.2
	kseitz_interps-20020930-merge:1.1.1.2
	carlton_dictionary-20020927-merge:1.1.1.2
	carlton_dictionary-branch:1.1.1.2.0.26
	carlton_dictionary-20020920-branchpoint:1.1.1.2
	gdb_5_3-branch:1.1.1.2.0.24
	gdb_5_3-2002-09-04-branchpoint:1.1.1.2
	kseitz_interps-20020829-merge:1.1.1.2
	cagney_sysregs-20020825-branch:1.1.1.2.0.22
	cagney_sysregs-20020825-branchpoint:1.1.1.2
	readline_4_3-import-branch:1.1.1.2.0.20
	readline_4_3-import-branchpoint:1.1.1.2
	gdb_5_2_1-2002-07-23-release:1.1.1.2
	kseitz_interps-20020528-branch:1.1.1.2.0.18
	kseitz_interps-20020528-branchpoint:1.1.1.2
	cagney_regbuf-20020515-branch:1.1.1.2.0.16
	cagney_regbuf-20020515-branchpoint:1.1.1.2
	jimb-macro-020506-branch:1.1.1.2.0.14
	jimb-macro-020506-branchpoint:1.1.1.2
	gdb_5_2-2002-04-29-release:1.1.1.2
	gdb_5_2-branch:1.1.1.2.0.12
	gdb_5_2-2002-03-03-branchpoint:1.1.1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.2
	gdb_5_1_0_1-2002-01-03-release:1.1.1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.2.0.10
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.2
	gdb_5_1-2001-11-21-release:1.1.1.2
	gdb_s390-2001-09-26-branch:1.1.1.2.0.8
	gdb_s390-2001-09-26-branchpoint:1.1.1.2
	gdb_5_1-2001-07-29-branch:1.1.1.2.0.6
	gdb_5_1-2001-07-29-branchpoint:1.1.1.2
	insight-precleanup-2001-01-01:1.1.1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.4
date	2012.12.19.07.18.15;	author brobecke;	state Exp;
branches;
next	1.3;

1.3
date	2012.12.19.07.11.59;	author brobecke;	state Exp;
branches;
next	1.2;

1.2
date	2005.05.12.07.36.59;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.56;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.56;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.02.05.07.30.19;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.4
log
@[sim] Update old contact info in GPL license notices

sim/ChangeLog:

        Update old contact info in GPL license notices.
@
text
@/*  parent.c -- ARMulator RDP comms code:  ARM6 Instruction Emulator.
    Copyright (C) 1994 Advanced RISC Machines Ltd.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, see <http://www.gnu.org/licenses/>. */

/*****************************************************************/
/* The Parent process continues here...                          */
/* It waits on the socket and passes on RDP messages down a pipe */
/* to the ARMulator RDP to RDI interpreter.                      */
/*****************************************************************/

#include <stdio.h>
#include <sys/types.h>
#include <signal.h>
#include "time.h"
#include "armdefs.h"
#include "dbg_rdi.h"
#include "communicate.h"

/* The socket to the debugger */
extern int debugsock;

/* The pipes between the two processes */
extern int mumkid[2];
extern int kidmum[2];

/* A pipe for handling SWI return values that goes straight from the */
/* parent to the ARMulator host interface, bypassing the child's RDP */
/* to RDI interpreter */
extern int DebuggerARMul[2];

/* The maximum number of file descriptors */
extern int nfds;

/* The child process id. */
extern pid_t child;

void
parent ()
{
  int i, j, k;
  unsigned char message, CPnum, exreturn;
  ARMword mask, nbytes, messagetype;
  unsigned char c, d;
  ARMword x, y;
  int virgin = 1;
  struct fd_set readfds;

#ifdef DEBUG
  fprintf (stderr, "parent ()...\n");
#endif

panic_error:

  if (!virgin)
    {
#ifdef DEBUG
      fprintf (stderr, "Arghh! What is going on?\n");
#endif
      kill (child, SIGHUP);
      MYwrite_char (debugsock, RDP_Reset);
    }

  virgin = 0;

  while (1)
    {

      /* Wait either for the ARMulator or the debugger */

      FD_ZERO (&readfds);
      FD_SET (kidmum[0], &readfds);	/* Wait for messages from ARMulator */
      FD_SET (debugsock, &readfds);	/* Wait for messages from debugger */

#ifdef DEBUG
      fprintf (stderr, "Waiting for ARMulator or debugger... ");
#endif

      while ((i = select (nfds, &readfds, (fd_set *) 0, (fd_set *) 0, 0)) < 0)
	{
	  perror ("select");
	}

#ifdef DEBUG
      fprintf (stderr, "(%d/2)", i);
#endif

      if (FD_ISSET (debugsock, &readfds))
	{
#ifdef DEBUG
	  fprintf (stderr, "->debugger\n");
#endif

	  /* Inside this rather large if statement with simply pass on a complete 
	     message to the ARMulator.  The reason we need to pass messages on one
	     at a time is that we have to know whether the message is an OSOpReply
	     or an info(stop), so that we can take different action in those
	     cases. */

	  if (MYread_char (debugsock, &message))
	    goto panic_error;

	  switch (message)
	    {
	    case RDP_Start:
	      /* Open and/or Initialise */
#ifdef DEBUG
	      fprintf (stderr, "RDP Open\n");
#endif
	      if (MYread_char (debugsock, &c))	/* type */
		goto panic_error;

	      if (MYread_word (debugsock, &x))	/* memory size */
		goto panic_error;

	      MYwrite_char (mumkid[1], message);
	      MYwrite_char (mumkid[1], c);
	      MYwrite_word (mumkid[1], x);
	      if (c & 0x2)
		{
		  passon (debugsock, mumkid[1], 1);	/* speed */
		}
	      break;

	    case RDP_End:
	      /* Close and Finalise */
#ifdef DEBUG
	      fprintf (stderr, "RDP Close\n");
#endif
	      MYwrite_char (mumkid[1], message);
	      break;

	    case RDP_Read:
	      /* Read Memory Address */
#ifdef DEBUG
	      fprintf (stderr, "RDP Read Memory\n");
#endif
	      MYwrite_char (mumkid[1], message);
	      if (passon (debugsock, mumkid[1], 4))
		goto panic_error;	/* address */
	      if (MYread_word (debugsock, &nbytes))
		goto panic_error;	/* nbytes */
	      MYwrite_word (mumkid[1], nbytes);
	      break;

	    case RDP_Write:
	      /* Write Memory Address */
#ifdef DEBUG
	      fprintf (stderr, "RDP Write Memory\n");
#endif
	      if (MYread_word (debugsock, &x))
		goto panic_error;	/* address */

	      if (MYread_word (debugsock, &y))
		goto panic_error;	/* nbytes */

	      MYwrite_char (mumkid[1], message);
	      MYwrite_word (mumkid[1], x);
	      MYwrite_word (mumkid[1], y);
	      passon (debugsock, mumkid[1], y);	/* actual data */
	      break;

	    case RDP_CPUread:
	      /* Read CPU State */
#ifdef DEBUG
	      fprintf (stderr, "RDP Read CPU\n");
#endif
	      if (MYread_char (debugsock, &c))
		goto panic_error;	/* mode */

	      if (MYread_word (debugsock, &mask))
		goto panic_error;	/* mask */

	      MYwrite_char (mumkid[1], message);
	      MYwrite_char (mumkid[1], c);
	      MYwrite_word (mumkid[1], mask);
	      break;

	    case RDP_CPUwrite:
	      /* Write CPU State */
#ifdef DEBUG
	      fprintf (stderr, "RDP Write CPU\n");
#endif
	      if (MYread_char (debugsock, &c))
		goto panic_error;	/* mode */

	      if (MYread_word (debugsock, &x))
		goto panic_error;	/* mask */

	      MYwrite_char (mumkid[1], message);
	      MYwrite_char (mumkid[1], c);
	      MYwrite_word (mumkid[1], x);
	      for (k = 1, j = 0; k != 0x80000000; k *= 2, j++)
		if ((k & x) && passon (debugsock, mumkid[1], 4))
		  goto panic_error;
	      break;

	    case RDP_CPread:
	      /* Read Co-Processor State */
#ifdef DEBUG
	      fprintf (stderr, "RDP Read CP state\n");
#endif
	      if (MYread_char (debugsock, &CPnum))
		goto panic_error;

	      if (MYread_word (debugsock, &mask))
		goto panic_error;

	      MYwrite_char (mumkid[1], message);
	      MYwrite_char (mumkid[1], CPnum);
	      MYwrite_word (mumkid[1], mask);
	      break;

	    case RDP_CPwrite:
	      /* Write Co-Processor State */
#ifdef DEBUG
	      fprintf (stderr, "RDP Write CP state\n");
#endif
	      if (MYread_char (debugsock, &CPnum))
		goto panic_error;

	      if (MYread_word (debugsock, &mask))
		goto panic_error;

	      MYwrite_char (mumkid[1], message);
	      MYwrite_char (mumkid[1], c);
	      MYwrite_char (mumkid[1], x);
	      for (k = 1, j = 0; k != 0x80000000; k *= 2, j++)
		if (k & x)
		  {
		    if ((c == 1 || c == 2) && k <= 128)
		      {
			/* FP register = 12 bytes + 4 bytes format */
			if (passon (debugsock, mumkid[1], 16))
			  goto panic_error;
		      }
		    else
		      {
			/* Normal register = 4 bytes */
			if (passon (debugsock, mumkid[1], 4))
			  goto panic_error;
		      }
		  }
	      break;

	    case RDP_SetBreak:
	      /* Set Breakpoint */
#ifdef DEBUG
	      fprintf (stderr, "RDP Set Breakpoint\n");
#endif
	      if (MYread_word (debugsock, &x))
		goto panic_error;	/* address */

	      if (MYread_char (debugsock, &c))
		goto panic_error;	/* type */

	      MYwrite_char (mumkid[1], message);
	      MYwrite_word (mumkid[1], x);
	      MYwrite_char (mumkid[1], c);
	      if (((c & 0xf) >= 5) && passon (debugsock, mumkid[1], 4))
		goto panic_error;	/* bound */
	      break;

	    case RDP_ClearBreak:
	      /* Clear Breakpoint */
#ifdef DEBUG
	      fprintf (stderr, "RDP Clear Breakpoint\n");
#endif
	      MYwrite_char (mumkid[1], message);
	      if (passon (debugsock, mumkid[1], 4))
		goto panic_error;	/* point */
	      break;

	    case RDP_SetWatch:
	      /* Set Watchpoint */
#ifdef DEBUG
	      fprintf (stderr, "RDP Set Watchpoint\n");
#endif
	      if (MYread_word (debugsock, &x))
		goto panic_error;	/* address */

	      if (MYread_char (debugsock, &c))
		goto panic_error;	/* type */

	      if (MYread_char (debugsock, &d))
		goto panic_error;	/* datatype */

	      MYwrite_char (mumkid[1], message);
	      MYwrite_word (mumkid[1], x);
	      MYwrite_char (mumkid[1], c);
	      MYwrite_char (mumkid[1], d);
	      if (((c & 0xf) >= 5) && passon (debugsock, mumkid[1], 4))
		goto panic_error;	/* bound */
	      break;

	    case RDP_ClearWatch:
	      /* Clear Watchpoint */
#ifdef DEBUG
	      fprintf (stderr, "RDP Clear Watchpoint\n");
#endif
	      MYwrite_char (mumkid[1], message);
	      if (passon (debugsock, mumkid[1], 4))
		goto panic_error;	/* point */
	      break;

	    case RDP_Execute:
	      /* Excecute */
#ifdef DEBUG
	      fprintf (stderr, "RDP Execute\n");
#endif

	      /* LEAVE THIS ONE 'TIL LATER... */
	      /* NEED TO WORK THINGS OUT */

	      /* NO ASCYNCHROUS RUNNING */

	      if (MYread_char (debugsock, &c))
		goto panic_error;	/* return */

	      /* Remember incase bit 7 is set and we have to send back a word */
	      exreturn = c;

	      MYwrite_char (mumkid[1], message);
	      MYwrite_char (mumkid[1], c);
	      break;

	    case RDP_Step:
	      /* Step */
#ifdef DEBUG
	      fprintf (stderr, "RDP Step\n");
#endif

	      if (MYread_char (debugsock, &c))
		goto panic_error;	/* return */

	      if (MYread_word (debugsock, &x))
		goto panic_error;	/* ninstr */

	      MYwrite_char (mumkid[1], message);
	      MYwrite_char (mumkid[1], c);
	      MYwrite_word (mumkid[1], x);
	      break;

	    case RDP_Info:
	      /* Info */
#ifdef DEBUG
	      fprintf (stderr, "RDP Info\n");
#endif
	      /* INFO TARGET, SET RDI LEVEL */
	      if (MYread_word (debugsock, &messagetype))
		goto panic_error;	/* info */

	      switch (messagetype)
		{
		case RDIInfo_Target:
		  MYwrite_char (mumkid[1], message);
		  MYwrite_word (mumkid[1], messagetype);
		  break;

		case RDISet_RDILevel:
		  MYwrite_char (mumkid[1], message);
		  MYwrite_word (mumkid[1], messagetype);
		  if (passon (debugsock, mumkid[1], 1))
		    goto panic_error;	/* argument */
		  break;

		case RDISet_Cmdline:
		  /* Got to pass on a string argument */
		  MYwrite_char (mumkid[1], message);
		  MYwrite_word (mumkid[1], messagetype);
		  do
		    {
		      if (MYread_char (debugsock, &c))
			goto panic_error;

		      MYwrite_char (mumkid[1], c);
		    }
		  while (c);
		  break;

		case RDISignal_Stop:
		  kill (child, SIGUSR1);
		  MYwrite_char (debugsock, RDP_Return);
		  MYwrite_char (debugsock, RDIError_UserInterrupt);
		  break;

		case RDIVector_Catch:
		  MYread_word (debugsock, &x);
		  MYwrite_char (mumkid[1], message);
		  MYwrite_word (mumkid[1], messagetype);
		  MYwrite_word (mumkid[1], x);
		  break;

		case RDIInfo_Step:
		  MYwrite_char (mumkid[1], message);
		  MYwrite_word (mumkid[1], messagetype);
		  break;

		case RDIInfo_Points:
		  MYwrite_char (mumkid[1], message);
		  MYwrite_word (mumkid[1], messagetype);
		  break;

		default:
		  fprintf (stderr, "Unrecognized RDIInfo request %d\n",
			   messagetype);
		  goto panic_error;
		}
	      break;

	    case RDP_OSOpReply:
	      /* OS Operation Reply */
#ifdef DEBUG
	      fprintf (stderr, "RDP OS Reply\n");
#endif
	      MYwrite_char (mumkid[1], message);
	      if (MYread_char (debugsock, &message))
		goto panic_error;
	      MYwrite_char (mumkid[1], message);
	      switch (message)
		{
		case 0:	/* return value i.e. nothing else. */
		  break;

		case 1:	/* returns a byte... */
		  if (MYread_char (debugsock, &c))
		    goto panic_error;

		  MYwrite_char (mumkid[1], c);
		  break;

		case 2:	/* returns a word... */
		  if (MYread_word (debugsock, &x))
		    goto panic_error;

		  MYwrite_word (mumkid[1], x);
		  break;
		}
	      break;

	    case RDP_Reset:
	      /* Reset */
#ifdef DEBUG
	      fprintf (stderr, "RDP Reset\n");
#endif
	      MYwrite_char (mumkid[1], message);
	      break;

	    default:
	      /* Hmm.. bad RDP operation */
	      fprintf (stderr, "RDP Bad RDP request (%d)\n", message);
	      MYwrite_char (debugsock, RDP_Return);
	      MYwrite_char (debugsock, RDIError_UnimplementedMessage);
	      break;
	    }
	}

      if (FD_ISSET (kidmum[0], &readfds))
	{
#ifdef DEBUG
	  fprintf (stderr, "->ARMulator\n");
#endif
	  /* Anything we get from the ARMulator has to go to the debugger... */
	  /* It is that simple! */

	  passon (kidmum[0], debugsock, 1);
	}
    }
}
@


1.3
log
@Update sim copyright headers from GPLv2-or-later to GPLv3-or-later.

gdb/sim/ChangeLog:

        Update the non-FSF-copyrighted files in sim to GPLv3 or later.
@
text
@d15 1
a15 2
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA. */
@


1.2
log
@Update the address of the FSF organization
@
text
@d6 1
a6 1
    the Free Software Foundation; either version 2 of the License, or
@


1.1
log
@Initial revision
@
text
@d16 1
a16 1
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
d64 2
a65 2
  
 panic_error:
d70 1
a70 1
      fprintf(stderr, "Arghh! What is going on?\n");
d73 1
a73 1
      MYwrite_char(debugsock, RDP_Reset);
d75 1
a75 1
  
d80 21
a100 35
    
    /* Wait either for the ARMulator or the debugger */
    
    FD_ZERO (&readfds);
    FD_SET (kidmum[0], &readfds); /* Wait for messages from ARMulator */
    FD_SET (debugsock, &readfds); /* Wait for messages from debugger */

#ifdef DEBUG
    fprintf (stderr, "Waiting for ARMulator or debugger... ");
#endif    

    while ((i = select (nfds, &readfds, (fd_set *) 0, (fd_set *) 0, 0)) < 0)
      {
	perror ("select");
      }

#ifdef DEBUG
    fprintf(stderr, "(%d/2)", i);
#endif
    
    if (FD_ISSET (debugsock, &readfds)) {
#ifdef DEBUG
      fprintf (stderr, "->debugger\n");
#endif      
      
      /* Inside this rather large if statement with simply pass on a complete 
	 message to the ARMulator.  The reason we need to pass messages on one
	 at a time is that we have to know whether the message is an OSOpReply
	 or an info(stop), so that we can take different action in those
	 cases. */

      if (MYread_char (debugsock, &message))
	goto panic_error;
      
      switch (message)
a101 2
	case RDP_Start:
	  /* Open and/or Initialise */
d103 1
a103 1
	  fprintf (stderr, "RDP Open\n");
a104 2
	  if (MYread_char(debugsock, &c)) /* type */
	    goto panic_error;
d106 7
a112 1
	  if (MYread_word(debugsock, &x))  /* memory size */
d115 1
a115 4
	  MYwrite_char (mumkid[1], message);
	  MYwrite_char (mumkid[1], c);
	  MYwrite_word (mumkid[1], x);
	  if (c & 0x2)
d117 40
a156 77
	      passon (debugsock, mumkid[1], 1); /* speed */
	    }
	  break;
	
	case RDP_End:
	  /* Close and Finalise */
#ifdef DEBUG
	  fprintf(stderr, "RDP Close\n");
#endif
	  MYwrite_char (mumkid[1], message);
	  break;
	
	case RDP_Read:
	  /* Read Memory Address */   
#ifdef DEBUG
	  fprintf (stderr, "RDP Read Memory\n");
#endif
	  MYwrite_char (mumkid[1], message);
	  if (passon (debugsock, mumkid[1], 4))
	    goto panic_error; /* address */
	  if (MYread_word(debugsock, &nbytes))
	    goto panic_error; /* nbytes */
	  MYwrite_word (mumkid[1], nbytes);
	  break;
	
	case RDP_Write :
	  /* Write Memory Address */
#ifdef DEBUG
	  fprintf (stderr, "RDP Write Memory\n");
#endif
	  if (MYread_word (debugsock, &x))
	    goto panic_error; /* address */

	  if (MYread_word (debugsock, &y))
	    goto panic_error; /* nbytes */

	  MYwrite_char (mumkid[1], message);
	  MYwrite_word (mumkid[1], x);
	  MYwrite_word (mumkid[1], y);
	  passon (debugsock, mumkid[1], y);  /* actual data */
	  break;
	
	case RDP_CPUread:
	  /* Read CPU State */
#ifdef DEBUG
	  fprintf (stderr, "RDP Read CPU\n");
#endif
	  if (MYread_char(debugsock, &c))
	    goto panic_error; /* mode */

	  if (MYread_word (debugsock, &mask))
	    goto panic_error; /* mask */

	  MYwrite_char (mumkid[1], message);
	  MYwrite_char (mumkid[1], c);
	  MYwrite_word (mumkid[1], mask);
	  break;

	case RDP_CPUwrite :
	  /* Write CPU State */
#ifdef DEBUG
	  fprintf (stderr, "RDP Write CPU\n");
#endif
	  if (MYread_char (debugsock, &c))
	    goto panic_error; /* mode */

	  if (MYread_word (debugsock, &x))
	    goto panic_error; /* mask */

	  MYwrite_char (mumkid[1], message);
	  MYwrite_char (mumkid[1], c);
	  MYwrite_word (mumkid[1], x);
	  for (k = 1, j = 0; k != 0x80000000; k *= 2, j++)
	    if ((k & x) 
		&& passon(debugsock, mumkid[1], 4))
	      goto panic_error;
	  break;
d158 2
a159 2
	case RDP_CPread:
	  /* Read Co-Processor State */
d161 1
a161 1
	  fprintf (stderr, "RDP Read CP state\n");
d163 5
a167 2
	  if (MYread_char (debugsock, &CPnum))
	    goto panic_error;
d169 5
a173 2
	  if (MYread_word (debugsock, &mask))
	    goto panic_error;
d175 2
a176 7
	  MYwrite_char (mumkid[1], message);
	  MYwrite_char (mumkid[1], CPnum);
	  MYwrite_word (mumkid[1], mask);
	  break;
	
	case RDP_CPwrite:
	  /* Write Co-Processor State */
d178 1
a178 1
	  fprintf(stderr, "RDP Write CP state\n");
d180 10
a189 2
	  if (MYread_char (debugsock, &CPnum))
	    goto panic_error;
d191 7
a197 2
	  if (MYread_word (debugsock, &mask))
	    goto panic_error;
d199 2
a200 129
	  MYwrite_char (mumkid[1], message);
	  MYwrite_char (mumkid[1], c);
	  MYwrite_char (mumkid[1], x);
	  for (k = 1, j = 0; k != 0x80000000; k *= 2, j++)
	    if (k & x)
	      {
		if ((c == 1 || c == 2) && k <= 128)
		  {
		    /* FP register = 12 bytes + 4 bytes format */
		    if (passon(debugsock, mumkid[1], 16))
		      goto panic_error;
		  }
		else
		  {
		    /* Normal register = 4 bytes */
		    if (passon(debugsock, mumkid[1], 4))
		      goto panic_error; 
		  }
	      }
	  break;
	
	case RDP_SetBreak:
	  /* Set Breakpoint */
#ifdef DEBUG
	  fprintf (stderr, "RDP Set Breakpoint\n");
#endif
	  if (MYread_word (debugsock, &x))
	    goto panic_error; /* address */

	  if (MYread_char (debugsock, &c))
	    goto panic_error; /* type */

	  MYwrite_char (mumkid[1], message);
	  MYwrite_word (mumkid[1], x);
	  MYwrite_char (mumkid[1], c);
	  if (((c & 0xf) >= 5)
	      && passon(debugsock, mumkid[1], 4))
	    goto panic_error; /* bound */
	  break;

	case RDP_ClearBreak:
	  /* Clear Breakpoint */
#ifdef DEBUG
	  fprintf (stderr, "RDP Clear Breakpoint\n");
#endif
	  MYwrite_char (mumkid[1], message);
	  if (passon (debugsock, mumkid[1], 4))
	    goto panic_error; /* point */
	  break;
	
	case RDP_SetWatch:
	  /* Set Watchpoint */
#ifdef DEBUG
	  fprintf (stderr, "RDP Set Watchpoint\n");
#endif
	  if (MYread_word (debugsock, &x))
	    goto panic_error; /* address */

	  if (MYread_char(debugsock, &c))
	    goto panic_error; /* type */

	  if (MYread_char (debugsock, &d))
	    goto panic_error; /* datatype */

	  MYwrite_char (mumkid[1], message);
	  MYwrite_word (mumkid[1], x);
	  MYwrite_char (mumkid[1], c);
	  MYwrite_char (mumkid[1], d);
	  if (((c & 0xf) >= 5)
	      && passon(debugsock, mumkid[1], 4))
	    goto panic_error; /* bound */
	  break;
	
	case RDP_ClearWatch:
	  /* Clear Watchpoint */
#ifdef DEBUG
	  fprintf (stderr, "RDP Clear Watchpoint\n");
#endif
	  MYwrite_char (mumkid[1], message);
	  if (passon (debugsock, mumkid[1], 4))
	    goto panic_error; /* point */
	  break;

	case RDP_Execute:
	  /* Excecute */
#ifdef DEBUG
	  fprintf (stderr, "RDP Execute\n");
#endif
	
	  /* LEAVE THIS ONE 'TIL LATER... */
	  /* NEED TO WORK THINGS OUT */
	
	  /* NO ASCYNCHROUS RUNNING */
	
	  if (MYread_char(debugsock, &c))
	    goto panic_error; /* return */

	  /* Remember incase bit 7 is set and we have to send back a word */
	  exreturn = c;
	
	  MYwrite_char(mumkid[1], message);
	  MYwrite_char(mumkid[1], c);
	  break;
	
	case RDP_Step:
	  /* Step */
#ifdef DEBUG
	  fprintf (stderr, "RDP Step\n");
#endif

	  if (MYread_char(debugsock, &c))
	    goto panic_error; /* return */

	  if (MYread_word(debugsock, &x))
	    goto panic_error; /* ninstr */

	  MYwrite_char (mumkid[1], message);
	  MYwrite_char (mumkid[1], c);
	  MYwrite_word (mumkid[1], x);
	  break;
	
	case RDP_Info:
	  /* Info */
#ifdef DEBUG
	  fprintf (stderr, "RDP Info\n");
#endif
	  /* INFO TARGET, SET RDI LEVEL */
	  if (MYread_word (debugsock, &messagetype))
	    goto panic_error; /* info */
a201 3
	  switch (messagetype)
	    {
	    case RDIInfo_Target:
d203 5
a207 1
	      MYwrite_word (mumkid[1], messagetype);
d209 12
a220 2
	    
	    case RDISet_RDILevel:
d222 2
a223 3
	      MYwrite_word (mumkid[1], messagetype);
	      if (passon (debugsock, mumkid[1], 1))
		goto panic_error; /* argument */
d226 11
a236 2
	    case RDISet_Cmdline:
	      /* Got to pass on a string argument */
d238 30
a267 5
	      MYwrite_word (mumkid[1], messagetype);
	      do
		{
		  if (MYread_char (debugsock, &c))
		    goto panic_error;
d269 5
a273 2
		  MYwrite_char (mumkid[1], c);
		} while (c);
d276 8
a283 4
	    case RDISignal_Stop:
	      kill (child, SIGUSR1);
	      MYwrite_char (debugsock, RDP_Return);
	      MYwrite_char (debugsock, RDIError_UserInterrupt);
d286 14
a299 2
	    case RDIVector_Catch:
	      MYread_word (debugsock, &x);
a300 1
	      MYwrite_word (mumkid[1], messagetype);
d302 4
d308 5
a312 1
	    case RDIInfo_Step:
d314 2
a315 1
	      MYwrite_word (mumkid[1], messagetype);
d318 17
a334 1
	    case RDIInfo_Points:
d336 1
a336 1
	      MYwrite_word (mumkid[1], messagetype);
d339 19
a357 9
	    default:
	      fprintf (stderr, "Unrecognized RDIInfo request %d\n",
		       messagetype);
	      goto panic_error;
	    }
	  break;
	
	case RDP_OSOpReply:
	  /* OS Operation Reply */
d359 1
a359 1
	  fprintf (stderr, "RDP OS Reply\n");
d361 60
a420 7
	  MYwrite_char (mumkid[1], message);
	  if (MYread_char (debugsock, &message))
	    goto panic_error;
	  MYwrite_char (mumkid[1], message);
	  switch(message)
	    {
	    case 0: /* return value i.e. nothing else.*/
d423 7
a429 2
	    case 1: /* returns a byte... */
	      if (MYread_char(debugsock, &c))
d431 12
d444 8
a451 2
	      MYwrite_char (mumkid[1], c);
	      break;	  
d453 7
a459 3
	    case 2: /* returns a word... */
	      if (MYread_word(debugsock, &x))
		goto panic_error;
d461 5
a465 1
	      MYwrite_word (mumkid[1], x);
d468 11
a478 16
	  break;
	
	case RDP_Reset:
	  /* Reset */
#ifdef DEBUG
	  fprintf (stderr, "RDP Reset\n");
#endif
	  MYwrite_char (mumkid[1], message);
	  break;

	default:
	  /* Hmm.. bad RDP operation */
	  fprintf (stderr, "RDP Bad RDP request (%d)\n", message);
	  MYwrite_char (debugsock, RDP_Return);
	  MYwrite_char (debugsock, RDIError_UnimplementedMessage);
	  break;
a480 12
    
    if (FD_ISSET (kidmum[0], &readfds))
      {
#ifdef DEBUG
	fprintf (stderr, "->ARMulator\n");
#endif      
	/* Anything we get from the ARMulator has to go to the debugger... */
	/* It is that simple! */
      
	passon (kidmum[0], debugsock, 1);
      }
  }
a481 1

@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-2000-02-04 snapshot
@
text
@d64 2
a65 2

panic_error:
d70 1
a70 1
      fprintf (stderr, "Arghh! What is going on?\n");
d73 1
a73 1
      MYwrite_char (debugsock, RDP_Reset);
d75 1
a75 1

d80 35
a114 21

      /* Wait either for the ARMulator or the debugger */

      FD_ZERO (&readfds);
      FD_SET (kidmum[0], &readfds);	/* Wait for messages from ARMulator */
      FD_SET (debugsock, &readfds);	/* Wait for messages from debugger */

#ifdef DEBUG
      fprintf (stderr, "Waiting for ARMulator or debugger... ");
#endif

      while ((i = select (nfds, &readfds, (fd_set *) 0, (fd_set *) 0, 0)) < 0)
	{
	  perror ("select");
	}

#ifdef DEBUG
      fprintf (stderr, "(%d/2)", i);
#endif

      if (FD_ISSET (debugsock, &readfds))
d116 2
d119 1
a119 1
	  fprintf (stderr, "->debugger\n");
d121 2
d124 1
a124 7
	  /* Inside this rather large if statement with simply pass on a complete 
	     message to the ARMulator.  The reason we need to pass messages on one
	     at a time is that we have to know whether the message is an OSOpReply
	     or an info(stop), so that we can take different action in those
	     cases. */

	  if (MYread_char (debugsock, &message))
d127 4
a130 1
	  switch (message)
d132 80
a211 2
	    case RDP_Start:
	      /* Open and/or Initialise */
d213 1
a213 1
	      fprintf (stderr, "RDP Open\n");
d215 2
a216 2
	      if (MYread_char (debugsock, &c))	/* type */
		goto panic_error;
d218 2
a219 11
	      if (MYread_word (debugsock, &x))	/* memory size */
		goto panic_error;

	      MYwrite_char (mumkid[1], message);
	      MYwrite_char (mumkid[1], c);
	      MYwrite_word (mumkid[1], x);
	      if (c & 0x2)
		{
		  passon (debugsock, mumkid[1], 1);	/* speed */
		}
	      break;
d221 7
a227 2
	    case RDP_End:
	      /* Close and Finalise */
d229 1
a229 1
	      fprintf (stderr, "RDP Close\n");
d231 2
a232 2
	      MYwrite_char (mumkid[1], message);
	      break;
d234 2
a235 12
	    case RDP_Read:
	      /* Read Memory Address */
#ifdef DEBUG
	      fprintf (stderr, "RDP Read Memory\n");
#endif
	      MYwrite_char (mumkid[1], message);
	      if (passon (debugsock, mumkid[1], 4))
		goto panic_error;	/* address */
	      if (MYread_word (debugsock, &nbytes))
		goto panic_error;	/* nbytes */
	      MYwrite_word (mumkid[1], nbytes);
	      break;
d237 129
a365 10
	    case RDP_Write:
	      /* Write Memory Address */
#ifdef DEBUG
	      fprintf (stderr, "RDP Write Memory\n");
#endif
	      if (MYread_word (debugsock, &x))
		goto panic_error;	/* address */

	      if (MYread_word (debugsock, &y))
		goto panic_error;	/* nbytes */
d367 3
d371 1
a371 3
	      MYwrite_word (mumkid[1], x);
	      MYwrite_word (mumkid[1], y);
	      passon (debugsock, mumkid[1], y);	/* actual data */
d373 2
a374 12

	    case RDP_CPUread:
	      /* Read CPU State */
#ifdef DEBUG
	      fprintf (stderr, "RDP Read CPU\n");
#endif
	      if (MYread_char (debugsock, &c))
		goto panic_error;	/* mode */

	      if (MYread_word (debugsock, &mask))
		goto panic_error;	/* mask */

d376 3
a378 2
	      MYwrite_char (mumkid[1], c);
	      MYwrite_word (mumkid[1], mask);
d381 2
a382 11
	    case RDP_CPUwrite:
	      /* Write CPU State */
#ifdef DEBUG
	      fprintf (stderr, "RDP Write CPU\n");
#endif
	      if (MYread_char (debugsock, &c))
		goto panic_error;	/* mode */

	      if (MYread_word (debugsock, &x))
		goto panic_error;	/* mask */

d384 5
a388 6
	      MYwrite_char (mumkid[1], c);
	      MYwrite_word (mumkid[1], x);
	      for (k = 1, j = 0; k != 0x80000000; k *= 2, j++)
		if ((k & x) && passon (debugsock, mumkid[1], 4))
		  goto panic_error;
	      break;
d390 2
a391 14
	    case RDP_CPread:
	      /* Read Co-Processor State */
#ifdef DEBUG
	      fprintf (stderr, "RDP Read CP state\n");
#endif
	      if (MYread_char (debugsock, &CPnum))
		goto panic_error;

	      if (MYread_word (debugsock, &mask))
		goto panic_error;

	      MYwrite_char (mumkid[1], message);
	      MYwrite_char (mumkid[1], CPnum);
	      MYwrite_word (mumkid[1], mask);
d394 4
a397 30
	    case RDP_CPwrite:
	      /* Write Co-Processor State */
#ifdef DEBUG
	      fprintf (stderr, "RDP Write CP state\n");
#endif
	      if (MYread_char (debugsock, &CPnum))
		goto panic_error;

	      if (MYread_word (debugsock, &mask))
		goto panic_error;

	      MYwrite_char (mumkid[1], message);
	      MYwrite_char (mumkid[1], c);
	      MYwrite_char (mumkid[1], x);
	      for (k = 1, j = 0; k != 0x80000000; k *= 2, j++)
		if (k & x)
		  {
		    if ((c == 1 || c == 2) && k <= 128)
		      {
			/* FP register = 12 bytes + 4 bytes format */
			if (passon (debugsock, mumkid[1], 16))
			  goto panic_error;
		      }
		    else
		      {
			/* Normal register = 4 bytes */
			if (passon (debugsock, mumkid[1], 4))
			  goto panic_error;
		      }
		  }
d400 2
a401 11
	    case RDP_SetBreak:
	      /* Set Breakpoint */
#ifdef DEBUG
	      fprintf (stderr, "RDP Set Breakpoint\n");
#endif
	      if (MYread_word (debugsock, &x))
		goto panic_error;	/* address */

	      if (MYread_char (debugsock, &c))
		goto panic_error;	/* type */

d403 1
a404 3
	      MYwrite_char (mumkid[1], c);
	      if (((c & 0xf) >= 5) && passon (debugsock, mumkid[1], 4))
		goto panic_error;	/* bound */
d407 1
a407 5
	    case RDP_ClearBreak:
	      /* Clear Breakpoint */
#ifdef DEBUG
	      fprintf (stderr, "RDP Clear Breakpoint\n");
#endif
d409 1
a409 2
	      if (passon (debugsock, mumkid[1], 4))
		goto panic_error;	/* point */
d412 1
a412 14
	    case RDP_SetWatch:
	      /* Set Watchpoint */
#ifdef DEBUG
	      fprintf (stderr, "RDP Set Watchpoint\n");
#endif
	      if (MYread_word (debugsock, &x))
		goto panic_error;	/* address */

	      if (MYread_char (debugsock, &c))
		goto panic_error;	/* type */

	      if (MYread_char (debugsock, &d))
		goto panic_error;	/* datatype */

d414 1
a414 5
	      MYwrite_word (mumkid[1], x);
	      MYwrite_char (mumkid[1], c);
	      MYwrite_char (mumkid[1], d);
	      if (((c & 0xf) >= 5) && passon (debugsock, mumkid[1], 4))
		goto panic_error;	/* bound */
d417 9
a425 2
	    case RDP_ClearWatch:
	      /* Clear Watchpoint */
d427 1
a427 1
	      fprintf (stderr, "RDP Clear Watchpoint\n");
d429 7
a435 3
	      MYwrite_char (mumkid[1], message);
	      if (passon (debugsock, mumkid[1], 4))
		goto panic_error;	/* point */
d438 3
a440 16
	    case RDP_Execute:
	      /* Excecute */
#ifdef DEBUG
	      fprintf (stderr, "RDP Execute\n");
#endif

	      /* LEAVE THIS ONE 'TIL LATER... */
	      /* NEED TO WORK THINGS OUT */

	      /* NO ASCYNCHROUS RUNNING */

	      if (MYread_char (debugsock, &c))
		goto panic_error;	/* return */

	      /* Remember incase bit 7 is set and we have to send back a word */
	      exreturn = c;
a441 1
	      MYwrite_char (mumkid[1], message);
d443 1
a443 1
	      break;
d445 3
a447 5
	    case RDP_Step:
	      /* Step */
#ifdef DEBUG
	      fprintf (stderr, "RDP Step\n");
#endif
a448 8
	      if (MYread_char (debugsock, &c))
		goto panic_error;	/* return */

	      if (MYread_word (debugsock, &x))
		goto panic_error;	/* ninstr */

	      MYwrite_char (mumkid[1], message);
	      MYwrite_char (mumkid[1], c);
a450 112

	    case RDP_Info:
	      /* Info */
#ifdef DEBUG
	      fprintf (stderr, "RDP Info\n");
#endif
	      /* INFO TARGET, SET RDI LEVEL */
	      if (MYread_word (debugsock, &messagetype))
		goto panic_error;	/* info */

	      switch (messagetype)
		{
		case RDIInfo_Target:
		  MYwrite_char (mumkid[1], message);
		  MYwrite_word (mumkid[1], messagetype);
		  break;

		case RDISet_RDILevel:
		  MYwrite_char (mumkid[1], message);
		  MYwrite_word (mumkid[1], messagetype);
		  if (passon (debugsock, mumkid[1], 1))
		    goto panic_error;	/* argument */
		  break;

		case RDISet_Cmdline:
		  /* Got to pass on a string argument */
		  MYwrite_char (mumkid[1], message);
		  MYwrite_word (mumkid[1], messagetype);
		  do
		    {
		      if (MYread_char (debugsock, &c))
			goto panic_error;

		      MYwrite_char (mumkid[1], c);
		    }
		  while (c);
		  break;

		case RDISignal_Stop:
		  kill (child, SIGUSR1);
		  MYwrite_char (debugsock, RDP_Return);
		  MYwrite_char (debugsock, RDIError_UserInterrupt);
		  break;

		case RDIVector_Catch:
		  MYread_word (debugsock, &x);
		  MYwrite_char (mumkid[1], message);
		  MYwrite_word (mumkid[1], messagetype);
		  MYwrite_word (mumkid[1], x);
		  break;

		case RDIInfo_Step:
		  MYwrite_char (mumkid[1], message);
		  MYwrite_word (mumkid[1], messagetype);
		  break;

		case RDIInfo_Points:
		  MYwrite_char (mumkid[1], message);
		  MYwrite_word (mumkid[1], messagetype);
		  break;

		default:
		  fprintf (stderr, "Unrecognized RDIInfo request %d\n",
			   messagetype);
		  goto panic_error;
		}
	      break;

	    case RDP_OSOpReply:
	      /* OS Operation Reply */
#ifdef DEBUG
	      fprintf (stderr, "RDP OS Reply\n");
#endif
	      MYwrite_char (mumkid[1], message);
	      if (MYread_char (debugsock, &message))
		goto panic_error;
	      MYwrite_char (mumkid[1], message);
	      switch (message)
		{
		case 0:	/* return value i.e. nothing else. */
		  break;

		case 1:	/* returns a byte... */
		  if (MYread_char (debugsock, &c))
		    goto panic_error;

		  MYwrite_char (mumkid[1], c);
		  break;

		case 2:	/* returns a word... */
		  if (MYread_word (debugsock, &x))
		    goto panic_error;

		  MYwrite_word (mumkid[1], x);
		  break;
		}
	      break;

	    case RDP_Reset:
	      /* Reset */
#ifdef DEBUG
	      fprintf (stderr, "RDP Reset\n");
#endif
	      MYwrite_char (mumkid[1], message);
	      break;

	    default:
	      /* Hmm.. bad RDP operation */
	      fprintf (stderr, "RDP Bad RDP request (%d)\n", message);
	      MYwrite_char (debugsock, RDP_Return);
	      MYwrite_char (debugsock, RDIError_UnimplementedMessage);
	      break;
d452 16
a467 11
	}

      if (FD_ISSET (kidmum[0], &readfds))
	{
#ifdef DEBUG
	  fprintf (stderr, "->ARMulator\n");
#endif
	  /* Anything we get from the ARMulator has to go to the debugger... */
	  /* It is that simple! */

	  passon (kidmum[0], debugsock, 1);
d470 12
d483 1
@


