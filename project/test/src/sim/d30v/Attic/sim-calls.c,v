head	1.3;
access;
symbols
	gdb_6_3-20041109-release:1.2
	gdb_6_3-branch:1.2.0.66
	gdb_6_3-20041019-branchpoint:1.2
	drow_intercu-merge-20040921:1.2
	drow_intercu-merge-20040915:1.2
	jimb-gdb_6_2-e500-branch:1.2.0.68
	jimb-gdb_6_2-e500-branchpoint:1.2
	gdb_6_2-20040730-release:1.2
	gdb_6_2-branch:1.2.0.64
	gdb_6_2-2004-07-10-gmt-branchpoint:1.2
	gdb_6_1_1-20040616-release:1.2
	gdb_6_1-2004-04-05-release:1.2
	drow_intercu-merge-20040402:1.2
	drow_intercu-merge-20040327:1.2
	ezannoni_pie-20040323-branch:1.2.0.62
	ezannoni_pie-20040323-branchpoint:1.2
	cagney_tramp-20040321-mergepoint:1.2
	cagney_tramp-20040309-branch:1.2.0.60
	cagney_tramp-20040309-branchpoint:1.2
	gdb_6_1-branch:1.2.0.58
	gdb_6_1-2004-03-01-gmt-branchpoint:1.2
	drow_intercu-20040221-branch:1.2.0.56
	drow_intercu-20040221-branchpoint:1.2
	cagney_bfdfile-20040213-branch:1.2.0.54
	cagney_bfdfile-20040213-branchpoint:1.2
	drow-cplus-merge-20040208:1.2
	carlton_dictionary-20040126-merge:1.2
	cagney_bigcore-20040122-branch:1.2.0.52
	cagney_bigcore-20040122-branchpoint:1.2
	drow-cplus-merge-20040113:1.2
	drow-cplus-merge-20031224:1.2
	drow-cplus-merge-20031220:1.2
	carlton_dictionary-20031215-merge:1.2
	drow-cplus-merge-20031214:1.2
	carlton-dictionary-20031111-merge:1.2
	gdb_6_0-2003-10-04-release:1.2
	kettenis_sparc-20030918-branch:1.2.0.50
	kettenis_sparc-20030918-branchpoint:1.2
	carlton_dictionary-20030917-merge:1.2
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.48
	cagney_x86i386-20030821-branch:1.2.0.46
	cagney_x86i386-20030821-branchpoint:1.2
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.2.0.44
	gdb_6_0-2003-06-23-branchpoint:1.2
	jimb-ppc64-linux-20030613-branch:1.2.0.42
	jimb-ppc64-linux-20030613-branchpoint:1.2
	cagney_convert-20030606-branch:1.2.0.40
	cagney_convert-20030606-branchpoint:1.2
	cagney_writestrings-20030508-branch:1.2.0.38
	cagney_writestrings-20030508-branchpoint:1.2
	jimb-ppc64-linux-20030528-branch:1.2.0.36
	jimb-ppc64-linux-20030528-branchpoint:1.2
	carlton_dictionary-20030523-merge:1.2
	cagney_fileio-20030521-branch:1.2.0.34
	cagney_fileio-20030521-branchpoint:1.2
	kettenis_i386newframe-20030517-mergepoint:1.2
	jimb-ppc64-linux-20030509-branch:1.2.0.32
	jimb-ppc64-linux-20030509-branchpoint:1.2
	kettenis_i386newframe-20030504-mergepoint:1.2
	carlton_dictionary-20030430-merge:1.2
	kettenis_i386newframe-20030419-branch:1.2.0.30
	kettenis_i386newframe-20030419-branchpoint:1.2
	carlton_dictionary-20030416-merge:1.2
	cagney_frameaddr-20030409-mergepoint:1.2
	kettenis_i386newframe-20030406-branch:1.2.0.28
	kettenis_i386newframe-20030406-branchpoint:1.2
	cagney_frameaddr-20030403-branchpoint:1.2
	cagney_frameaddr-20030403-branch:1.2.0.26
	cagney_framebase-20030330-mergepoint:1.2
	cagney_framebase-20030326-branch:1.2.0.24
	cagney_framebase-20030326-branchpoint:1.2
	cagney_lazyid-20030317-branch:1.2.0.22
	cagney_lazyid-20030317-branchpoint:1.2
	kettenis-i386newframe-20030316-mergepoint:1.2
	offbyone-20030313-branch:1.2.0.20
	offbyone-20030313-branchpoint:1.2
	kettenis-i386newframe-20030308-branch:1.2.0.18
	kettenis-i386newframe-20030308-branchpoint:1.2
	carlton_dictionary-20030305-merge:1.2
	cagney_offbyone-20030303-branch:1.2.0.16
	cagney_offbyone-20030303-branchpoint:1.2
	carlton_dictionary-20030207-merge:1.2
	interps-20030202-branch:1.2.0.14
	interps-20030202-branchpoint:1.2
	cagney-unwind-20030108-branch:1.2.0.12
	cagney-unwind-20030108-branchpoint:1.2
	carlton_dictionary-20021223-merge:1.2
	gdb_5_3-2002-12-12-release:1.2
	carlton_dictionary-20021115-merge:1.2
	kseitz_interps-20021105-merge:1.2
	kseitz_interps-20021103-merge:1.2
	drow-cplus-merge-20021020:1.2
	drow-cplus-merge-20021025:1.2
	carlton_dictionary-20021025-merge:1.2
	carlton_dictionary-20021011-merge:1.2
	drow-cplus-branch:1.2.0.10
	drow-cplus-branchpoint:1.2
	kseitz_interps-20020930-merge:1.2
	carlton_dictionary-20020927-merge:1.2
	carlton_dictionary-branch:1.2.0.8
	carlton_dictionary-20020920-branchpoint:1.2
	gdb_5_3-branch:1.2.0.6
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.4
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.2
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.1.1.1
	kseitz_interps-20020528-branch:1.1.1.1.0.20
	kseitz_interps-20020528-branchpoint:1.1.1.1
	cagney_regbuf-20020515-branch:1.1.1.1.0.18
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	jimb-macro-020506-branch:1.1.1.1.0.16
	jimb-macro-020506-branchpoint:1.1.1.1
	gdb_5_2-2002-04-29-release:1.1.1.1
	gdb_5_2-branch:1.1.1.1.0.14
	gdb_5_2-2002-03-03-branchpoint:1.1.1.1
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.12
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.10
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.8
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.3
date	2004.11.12.16.45.20;	author cagney;	state dead;
branches;
next	1.2;

1.2
date	2002.07.14.00.15.20;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.00;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.35.00;	author shebs;	state Exp;
branches
	1.1.1.1.20.1;
next	;

1.1.1.1.20.1
date	2002.07.22.21.47.24;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.3
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* d30v, fr30, mn10200, z8k: Delete directory.
@
text
@/* OBSOLETE /*  This file is part of the program psim. */
/* OBSOLETE  */
/* OBSOLETE     Copyright (C) 1994-1996, Andrew Cagney <cagney@@highland.com.au> */
/* OBSOLETE     Copyright (C) 1997, Free Software Foundation */
/* OBSOLETE  */
/* OBSOLETE     This program is free software; you can redistribute it and/or modify */
/* OBSOLETE     it under the terms of the GNU General Public License as published by */
/* OBSOLETE     the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE     (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE     This program is distributed in the hope that it will be useful, */
/* OBSOLETE     but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE     GNU General Public License for more details. */
/* OBSOLETE   */
/* OBSOLETE     You should have received a copy of the GNU General Public License */
/* OBSOLETE     along with this program; if not, write to the Free Software */
/* OBSOLETE     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
/* OBSOLETE   */
/* OBSOLETE     */ */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE #include <stdarg.h> */
/* OBSOLETE #include <ctype.h> */
/* OBSOLETE  */
/* OBSOLETE #include "sim-main.h" */
/* OBSOLETE #include "sim-options.h" */
/* OBSOLETE  */
/* OBSOLETE #include "bfd.h" */
/* OBSOLETE #include "sim-utils.h" */
/* OBSOLETE  */
/* OBSOLETE #ifdef HAVE_STDLIB_H */
/* OBSOLETE #include <stdlib.h> */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE static unsigned long extmem_size = 1024*1024*8;	/* 8 meg is the maximum listed in the arch. manual */ */
/* OBSOLETE  */
/* OBSOLETE static const char * get_insn_name (sim_cpu *, int); */
/* OBSOLETE  */
/* OBSOLETE #define SIM_ADDR unsigned */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE #define OPTION_TRACE_CALL	200 */
/* OBSOLETE #define OPTION_TRACE_TRAPDUMP	201 */
/* OBSOLETE #define OPTION_EXTMEM_SIZE	202 */
/* OBSOLETE  */
/* OBSOLETE static SIM_RC */
/* OBSOLETE d30v_option_handler (SIM_DESC sd, */
/* OBSOLETE 		     sim_cpu *cpu, */
/* OBSOLETE 		     int opt, */
/* OBSOLETE 		     char *arg, */
/* OBSOLETE 		     int command_p) */
/* OBSOLETE { */
/* OBSOLETE   char *suffix; */
/* OBSOLETE  */
/* OBSOLETE   switch (opt) */
/* OBSOLETE     { */
/* OBSOLETE     default: */
/* OBSOLETE       break; */
/* OBSOLETE  */
/* OBSOLETE     case OPTION_TRACE_CALL: */
/* OBSOLETE       if (arg == NULL || strcmp (arg, "yes") == 0 || strcmp (arg, "on") == 0) */
/* OBSOLETE 	TRACE_CALL_P = 1; */
/* OBSOLETE       else if (strcmp (arg, "no") == 0 || strcmp (arg, "off") == 0) */
/* OBSOLETE 	TRACE_CALL_P = 0; */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  sim_io_eprintf (sd, "Unreconized --trace-call option `%s'\n", arg); */
/* OBSOLETE 	  return SIM_RC_FAIL; */
/* OBSOLETE 	} */
/* OBSOLETE       return SIM_RC_OK; */
/* OBSOLETE  */
/* OBSOLETE     case OPTION_TRACE_TRAPDUMP: */
/* OBSOLETE       if (arg == NULL || strcmp (arg, "yes") == 0 || strcmp (arg, "on") == 0) */
/* OBSOLETE 	TRACE_TRAP_P = 1; */
/* OBSOLETE       else if (strcmp (arg, "no") == 0 || strcmp (arg, "off") == 0) */
/* OBSOLETE 	TRACE_TRAP_P = 0; */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  sim_io_eprintf (sd, "Unreconized --trace-call option `%s'\n", arg); */
/* OBSOLETE 	  return SIM_RC_FAIL; */
/* OBSOLETE 	} */
/* OBSOLETE       return SIM_RC_OK; */
/* OBSOLETE  */
/* OBSOLETE     case OPTION_EXTMEM_SIZE: */
/* OBSOLETE       if (arg == NULL || !isdigit (*arg)) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  sim_io_eprintf (sd, "Invalid memory size `%s'", arg); */
/* OBSOLETE 	  return SIM_RC_FAIL; */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       suffix = arg; */
/* OBSOLETE       extmem_size = strtol (arg, &suffix, 0); */
/* OBSOLETE       if (*suffix == 'm' || *suffix == 'M') */
/* OBSOLETE 	extmem_size <<= 20; */
/* OBSOLETE       else if (*suffix == 'k' || *suffix == 'K') */
/* OBSOLETE 	extmem_size <<= 10; */
/* OBSOLETE       sim_do_commandf (sd, "memory delete 0x80000000"); */
/* OBSOLETE       sim_do_commandf (sd, "memory region 0x80000000,0x%lx", extmem_size); */
/* OBSOLETE  */
/* OBSOLETE       return SIM_RC_OK; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   sim_io_eprintf (sd, "Unknown option (%d)\n", opt); */
/* OBSOLETE   return SIM_RC_FAIL; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static const OPTION d30v_options[] = */
/* OBSOLETE { */
/* OBSOLETE   { {"trace-call", optional_argument, NULL, OPTION_TRACE_CALL}, */
/* OBSOLETE       '\0', "on|off", "Enable tracing of calls and returns, checking saved registers", */
/* OBSOLETE       d30v_option_handler }, */
/* OBSOLETE   { {"trace-trapdump", optional_argument, NULL, OPTION_TRACE_TRAPDUMP}, */
/* OBSOLETE       '\0', "on|off", */
/* OBSOLETE #if TRAPDUMP */
/* OBSOLETE     "Traps 0..30 dump out all of the registers (defaults on)", */
/* OBSOLETE #else */
/* OBSOLETE     "Traps 0..30 dump out all of the registers", */
/* OBSOLETE #endif */
/* OBSOLETE       d30v_option_handler }, */
/* OBSOLETE   { {"extmem-size", required_argument, NULL, OPTION_EXTMEM_SIZE}, */
/* OBSOLETE     '\0', "size", "Change size of external memory, default 8 meg", */
/* OBSOLETE     d30v_option_handler }, */
/* OBSOLETE   { {NULL, no_argument, NULL, 0}, '\0', NULL, NULL, NULL } */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE /* Return name of an insn, used by insn profiling.  */ */
/* OBSOLETE  */
/* OBSOLETE static const char * */
/* OBSOLETE get_insn_name (sim_cpu *cpu, int i) */
/* OBSOLETE { */
/* OBSOLETE   return itable[i].name; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Structures used by the simulator, for gdb just have static structures */ */
/* OBSOLETE  */
/* OBSOLETE SIM_DESC */
/* OBSOLETE sim_open (SIM_OPEN_KIND kind, */
/* OBSOLETE 	  host_callback *callback, */
/* OBSOLETE 	  struct _bfd *abfd, */
/* OBSOLETE 	  char **argv) */
/* OBSOLETE { */
/* OBSOLETE   SIM_DESC sd = sim_state_alloc (kind, callback); */
/* OBSOLETE  */
/* OBSOLETE   /* FIXME: watchpoints code shouldn't need this */ */
/* OBSOLETE   STATE_WATCHPOINTS (sd)->pc = &(PC); */
/* OBSOLETE   STATE_WATCHPOINTS (sd)->sizeof_pc = sizeof (PC); */
/* OBSOLETE   STATE_WATCHPOINTS (sd)->interrupt_handler = d30v_interrupt_event; */
/* OBSOLETE  */
/* OBSOLETE   /* Initialize the mechanism for doing insn profiling.  */ */
/* OBSOLETE   CPU_INSN_NAME (STATE_CPU (sd, 0)) = get_insn_name; */
/* OBSOLETE   CPU_MAX_INSNS (STATE_CPU (sd, 0)) = nr_itable_entries; */
/* OBSOLETE  */
/* OBSOLETE #ifdef TRAPDUMP */
/* OBSOLETE   TRACE_TRAP_P = TRAPDUMP; */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE   if (sim_pre_argv_init (sd, argv[0]) != SIM_RC_OK) */
/* OBSOLETE     return 0; */
/* OBSOLETE   sim_add_option_table (sd, NULL, d30v_options); */
/* OBSOLETE  */
/* OBSOLETE   /* Memory and EEPROM */ */
/* OBSOLETE   /* internal instruction RAM - fixed */ */
/* OBSOLETE   sim_do_commandf (sd, "memory region 0,0x10000"); */
/* OBSOLETE   /* internal data RAM - fixed */ */
/* OBSOLETE   sim_do_commandf (sd, "memory region 0x20000000,0x8000"); */
/* OBSOLETE   /* control register dummy area */ */
/* OBSOLETE   sim_do_commandf (sd, "memory region 0x40000000,0x10000"); */
/* OBSOLETE   /* external RAM */ */
/* OBSOLETE   sim_do_commandf (sd, "memory region 0x80000000,0x%lx", extmem_size); */
/* OBSOLETE   /* EIT RAM */ */
/* OBSOLETE   sim_do_commandf (sd, "memory region 0xfffff000,0x1000"); */
/* OBSOLETE  */
/* OBSOLETE   /* getopt will print the error message so we just have to exit if this fails. */
/* OBSOLETE      FIXME: Hmmm...  in the case of gdb we need getopt to call */
/* OBSOLETE      print_filtered.  */ */
/* OBSOLETE   if (sim_parse_args (sd, argv) != SIM_RC_OK) */
/* OBSOLETE     { */
/* OBSOLETE       /* Uninstall the modules to avoid memory leaks, */
/* OBSOLETE 	 file descriptor leaks, etc.  */ */
/* OBSOLETE       sim_module_uninstall (sd); */
/* OBSOLETE       return 0; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* check for/establish the a reference program image */ */
/* OBSOLETE   if (sim_analyze_program (sd, */
/* OBSOLETE 			   (STATE_PROG_ARGV (sd) != NULL */
/* OBSOLETE 			    ? *STATE_PROG_ARGV (sd) */
/* OBSOLETE 			    : NULL), */
/* OBSOLETE 			   abfd) != SIM_RC_OK) */
/* OBSOLETE     { */
/* OBSOLETE       sim_module_uninstall (sd); */
/* OBSOLETE       return 0; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* establish any remaining configuration options */ */
/* OBSOLETE   if (sim_config (sd) != SIM_RC_OK) */
/* OBSOLETE     { */
/* OBSOLETE       sim_module_uninstall (sd); */
/* OBSOLETE       return 0; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   if (sim_post_argv_init (sd) != SIM_RC_OK) */
/* OBSOLETE     { */
/* OBSOLETE       /* Uninstall the modules to avoid memory leaks, */
/* OBSOLETE 	 file descriptor leaks, etc.  */ */
/* OBSOLETE       sim_module_uninstall (sd); */
/* OBSOLETE       return 0; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   return sd; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE sim_close (SIM_DESC sd, int quitting) */
/* OBSOLETE { */
/* OBSOLETE   /* Uninstall the modules to avoid memory leaks, */
/* OBSOLETE      file descriptor leaks, etc.  */ */
/* OBSOLETE   sim_module_uninstall (sd); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE SIM_RC */
/* OBSOLETE sim_create_inferior (SIM_DESC sd, */
/* OBSOLETE 		     struct _bfd *abfd, */
/* OBSOLETE 		     char **argv, */
/* OBSOLETE 		     char **envp) */
/* OBSOLETE { */
/* OBSOLETE   /* clear all registers */ */
/* OBSOLETE   memset (&STATE_CPU (sd, 0)->regs, 0, sizeof (STATE_CPU (sd, 0)->regs)); */
/* OBSOLETE   EIT_VB = EIT_VB_DEFAULT; */
/* OBSOLETE   STATE_CPU (sd, 0)->unit = any_unit; */
/* OBSOLETE   sim_module_init (sd); */
/* OBSOLETE   if (abfd != NULL) */
/* OBSOLETE     PC = bfd_get_start_address (abfd); */
/* OBSOLETE   else */
/* OBSOLETE     PC = 0xfffff000; /* reset value */ */
/* OBSOLETE   return SIM_RC_OK; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE sim_do_command (SIM_DESC sd, char *cmd) */
/* OBSOLETE { */
/* OBSOLETE   if (sim_args_command (sd, cmd) != SIM_RC_OK) */
/* OBSOLETE     sim_io_printf (sd, "Unknown command `%s'\n", cmd); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* The following register definitions were ripped off from */
/* OBSOLETE    gdb/config/tm-d30v.h.  If any of those defs changes, this table needs to */
/* OBSOLETE    be updated.  */ */
/* OBSOLETE  */
/* OBSOLETE #define NUM_REGS 86 */
/* OBSOLETE  */
/* OBSOLETE #define R0_REGNUM	0 */
/* OBSOLETE #define FP_REGNUM	11 */
/* OBSOLETE #define LR_REGNUM 	62 */
/* OBSOLETE #define SP_REGNUM 	63 */
/* OBSOLETE #define SPI_REGNUM	64	/* Interrupt stack pointer */ */
/* OBSOLETE #define SPU_REGNUM	65	/* User stack pointer */ */
/* OBSOLETE #define CREGS_START	66 */
/* OBSOLETE  */
/* OBSOLETE #define PSW_REGNUM 	(CREGS_START + 0) /* psw, bpsw, or dpsw??? */ */
/* OBSOLETE #define    PSW_SM 0x80000000	/* Stack mode: 0 == interrupt (SPI), */
/* OBSOLETE 					       1 == user (SPU) */ */
/* OBSOLETE #define BPSW_REGNUM	(CREGS_START + 1) /* Backup PSW (on interrupt) */ */
/* OBSOLETE #define PC_REGNUM 	(CREGS_START + 2) /* pc, bpc, or dpc??? */ */
/* OBSOLETE #define BPC_REGNUM 	(CREGS_START + 3) /* Backup PC (on interrupt) */ */
/* OBSOLETE #define DPSW_REGNUM	(CREGS_START + 4) /* Backup PSW (on debug trap) */ */
/* OBSOLETE #define DPC_REGNUM 	(CREGS_START + 5) /* Backup PC (on debug trap) */ */
/* OBSOLETE #define RPT_C_REGNUM	(CREGS_START + 7) /* Loop count */ */
/* OBSOLETE #define RPT_S_REGNUM	(CREGS_START + 8) /* Loop start address*/ */
/* OBSOLETE #define RPT_E_REGNUM	(CREGS_START + 9) /* Loop end address */ */
/* OBSOLETE #define MOD_S_REGNUM	(CREGS_START + 10) */
/* OBSOLETE #define MOD_E_REGNUM	(CREGS_START + 11) */
/* OBSOLETE #define IBA_REGNUM	(CREGS_START + 14) /* Instruction break address */ */
/* OBSOLETE #define EIT_VB_REGNUM	(CREGS_START + 15) /* Vector base address */ */
/* OBSOLETE #define INT_S_REGNUM	(CREGS_START + 16) /* Interrupt status */ */
/* OBSOLETE #define INT_M_REGNUM	(CREGS_START + 17) /* Interrupt mask */ */
/* OBSOLETE #define A0_REGNUM 	84 */
/* OBSOLETE #define A1_REGNUM 	85 */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE sim_fetch_register (sd, regno, buf, length) */
/* OBSOLETE      SIM_DESC sd; */
/* OBSOLETE      int regno; */
/* OBSOLETE      unsigned char *buf; */
/* OBSOLETE      int length; */
/* OBSOLETE { */
/* OBSOLETE   if (regno < A0_REGNUM) */
/* OBSOLETE     { */
/* OBSOLETE       unsigned32 reg; */
/* OBSOLETE  */
/* OBSOLETE       if (regno <= R0_REGNUM + 63) */
/* OBSOLETE 	reg = sd->cpu[0].regs.general_purpose[regno]; */
/* OBSOLETE       else if (regno <= SPU_REGNUM) */
/* OBSOLETE 	reg = sd->cpu[0].regs.sp[regno - SPI_REGNUM]; */
/* OBSOLETE       else */
/* OBSOLETE 	reg = sd->cpu[0].regs.control[regno - CREGS_START]; */
/* OBSOLETE  */
/* OBSOLETE       buf[0] = reg >> 24; */
/* OBSOLETE       buf[1] = reg >> 16; */
/* OBSOLETE       buf[2] = reg >> 8; */
/* OBSOLETE       buf[3] = reg; */
/* OBSOLETE     } */
/* OBSOLETE   else if (regno < NUM_REGS) */
/* OBSOLETE     { */
/* OBSOLETE       unsigned32 reg; */
/* OBSOLETE  */
/* OBSOLETE       reg = sd->cpu[0].regs.accumulator[regno - A0_REGNUM] >> 32; */
/* OBSOLETE  */
/* OBSOLETE       buf[0] = reg >> 24; */
/* OBSOLETE       buf[1] = reg >> 16; */
/* OBSOLETE       buf[2] = reg >> 8; */
/* OBSOLETE       buf[3] = reg; */
/* OBSOLETE  */
/* OBSOLETE       reg = sd->cpu[0].regs.accumulator[regno - A0_REGNUM]; */
/* OBSOLETE  */
/* OBSOLETE       buf[4] = reg >> 24; */
/* OBSOLETE       buf[5] = reg >> 16; */
/* OBSOLETE       buf[6] = reg >> 8; */
/* OBSOLETE       buf[7] = reg; */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     abort (); */
/* OBSOLETE   return -1; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE sim_store_register (sd, regno, buf, length) */
/* OBSOLETE      SIM_DESC sd; */
/* OBSOLETE      int regno; */
/* OBSOLETE      unsigned char *buf; */
/* OBSOLETE      int length; */
/* OBSOLETE { */
/* OBSOLETE   if (regno < A0_REGNUM) */
/* OBSOLETE     { */
/* OBSOLETE       unsigned32 reg; */
/* OBSOLETE  */
/* OBSOLETE       reg = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3]; */
/* OBSOLETE  */
/* OBSOLETE       if (regno <= R0_REGNUM + 63) */
/* OBSOLETE 	sd->cpu[0].regs.general_purpose[regno] = reg; */
/* OBSOLETE       else if (regno <= SPU_REGNUM) */
/* OBSOLETE 	sd->cpu[0].regs.sp[regno - SPI_REGNUM] = reg; */
/* OBSOLETE       else */
/* OBSOLETE 	sd->cpu[0].regs.control[regno - CREGS_START] = reg; */
/* OBSOLETE     } */
/* OBSOLETE   else if (regno < NUM_REGS) */
/* OBSOLETE     { */
/* OBSOLETE       unsigned32 reg; */
/* OBSOLETE  */
/* OBSOLETE       reg = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3]; */
/* OBSOLETE  */
/* OBSOLETE       sd->cpu[0].regs.accumulator[regno - A0_REGNUM] = (unsigned64)reg << 32; */
/* OBSOLETE  */
/* OBSOLETE       reg = (buf[4] << 24) | (buf[5] << 16) | (buf[6] << 8) | buf[7]; */
/* OBSOLETE  */
/* OBSOLETE       sd->cpu[0].regs.accumulator[regno - A0_REGNUM] |= reg; */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     abort (); */
/* OBSOLETE   return -1; */
/* OBSOLETE } */
@


1.2
log
@Obsolete the d30v.
@
text
@@


1.1
log
@Initial revision
@
text
@d1 364
a364 364
/*  This file is part of the program psim.

    Copyright (C) 1994-1996, Andrew Cagney <cagney@@highland.com.au>
    Copyright (C) 1997, Free Software Foundation

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
    */


#include <stdarg.h>
#include <ctype.h>

#include "sim-main.h"
#include "sim-options.h"

#include "bfd.h"
#include "sim-utils.h"

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

static unsigned long extmem_size = 1024*1024*8;	/* 8 meg is the maximum listed in the arch. manual */

static const char * get_insn_name (sim_cpu *, int);

#define SIM_ADDR unsigned


#define OPTION_TRACE_CALL	200
#define OPTION_TRACE_TRAPDUMP	201
#define OPTION_EXTMEM_SIZE	202

static SIM_RC
d30v_option_handler (SIM_DESC sd,
		     sim_cpu *cpu,
		     int opt,
		     char *arg,
		     int command_p)
{
  char *suffix;

  switch (opt)
    {
    default:
      break;

    case OPTION_TRACE_CALL:
      if (arg == NULL || strcmp (arg, "yes") == 0 || strcmp (arg, "on") == 0)
	TRACE_CALL_P = 1;
      else if (strcmp (arg, "no") == 0 || strcmp (arg, "off") == 0)
	TRACE_CALL_P = 0;
      else
	{
	  sim_io_eprintf (sd, "Unreconized --trace-call option `%s'\n", arg);
	  return SIM_RC_FAIL;
	}
      return SIM_RC_OK;

    case OPTION_TRACE_TRAPDUMP:
      if (arg == NULL || strcmp (arg, "yes") == 0 || strcmp (arg, "on") == 0)
	TRACE_TRAP_P = 1;
      else if (strcmp (arg, "no") == 0 || strcmp (arg, "off") == 0)
	TRACE_TRAP_P = 0;
      else
	{
	  sim_io_eprintf (sd, "Unreconized --trace-call option `%s'\n", arg);
	  return SIM_RC_FAIL;
	}
      return SIM_RC_OK;

    case OPTION_EXTMEM_SIZE:
      if (arg == NULL || !isdigit (*arg))
	{
	  sim_io_eprintf (sd, "Invalid memory size `%s'", arg);
	  return SIM_RC_FAIL;
	}

      suffix = arg;
      extmem_size = strtol (arg, &suffix, 0);
      if (*suffix == 'm' || *suffix == 'M')
	extmem_size <<= 20;
      else if (*suffix == 'k' || *suffix == 'K')
	extmem_size <<= 10;
      sim_do_commandf (sd, "memory delete 0x80000000");
      sim_do_commandf (sd, "memory region 0x80000000,0x%lx", extmem_size);

      return SIM_RC_OK;
    }

  sim_io_eprintf (sd, "Unknown option (%d)\n", opt);
  return SIM_RC_FAIL;
}

static const OPTION d30v_options[] =
{
  { {"trace-call", optional_argument, NULL, OPTION_TRACE_CALL},
      '\0', "on|off", "Enable tracing of calls and returns, checking saved registers",
      d30v_option_handler },
  { {"trace-trapdump", optional_argument, NULL, OPTION_TRACE_TRAPDUMP},
      '\0', "on|off",
#if TRAPDUMP
    "Traps 0..30 dump out all of the registers (defaults on)",
#else
    "Traps 0..30 dump out all of the registers",
#endif
      d30v_option_handler },
  { {"extmem-size", required_argument, NULL, OPTION_EXTMEM_SIZE},
    '\0', "size", "Change size of external memory, default 8 meg",
    d30v_option_handler },
  { {NULL, no_argument, NULL, 0}, '\0', NULL, NULL, NULL }
};

/* Return name of an insn, used by insn profiling.  */

static const char *
get_insn_name (sim_cpu *cpu, int i)
{
  return itable[i].name;
}

/* Structures used by the simulator, for gdb just have static structures */

SIM_DESC
sim_open (SIM_OPEN_KIND kind,
	  host_callback *callback,
	  struct _bfd *abfd,
	  char **argv)
{
  SIM_DESC sd = sim_state_alloc (kind, callback);

  /* FIXME: watchpoints code shouldn't need this */
  STATE_WATCHPOINTS (sd)->pc = &(PC);
  STATE_WATCHPOINTS (sd)->sizeof_pc = sizeof (PC);
  STATE_WATCHPOINTS (sd)->interrupt_handler = d30v_interrupt_event;

  /* Initialize the mechanism for doing insn profiling.  */
  CPU_INSN_NAME (STATE_CPU (sd, 0)) = get_insn_name;
  CPU_MAX_INSNS (STATE_CPU (sd, 0)) = nr_itable_entries;

#ifdef TRAPDUMP
  TRACE_TRAP_P = TRAPDUMP;
#endif

  if (sim_pre_argv_init (sd, argv[0]) != SIM_RC_OK)
    return 0;
  sim_add_option_table (sd, NULL, d30v_options);

  /* Memory and EEPROM */
  /* internal instruction RAM - fixed */
  sim_do_commandf (sd, "memory region 0,0x10000");
  /* internal data RAM - fixed */
  sim_do_commandf (sd, "memory region 0x20000000,0x8000");
  /* control register dummy area */
  sim_do_commandf (sd, "memory region 0x40000000,0x10000");
  /* external RAM */
  sim_do_commandf (sd, "memory region 0x80000000,0x%lx", extmem_size);
  /* EIT RAM */
  sim_do_commandf (sd, "memory region 0xfffff000,0x1000");

  /* getopt will print the error message so we just have to exit if this fails.
     FIXME: Hmmm...  in the case of gdb we need getopt to call
     print_filtered.  */
  if (sim_parse_args (sd, argv) != SIM_RC_OK)
    {
      /* Uninstall the modules to avoid memory leaks,
	 file descriptor leaks, etc.  */
      sim_module_uninstall (sd);
      return 0;
    }

  /* check for/establish the a reference program image */
  if (sim_analyze_program (sd,
			   (STATE_PROG_ARGV (sd) != NULL
			    ? *STATE_PROG_ARGV (sd)
			    : NULL),
			   abfd) != SIM_RC_OK)
    {
      sim_module_uninstall (sd);
      return 0;
    }

  /* establish any remaining configuration options */
  if (sim_config (sd) != SIM_RC_OK)
    {
      sim_module_uninstall (sd);
      return 0;
    }

  if (sim_post_argv_init (sd) != SIM_RC_OK)
    {
      /* Uninstall the modules to avoid memory leaks,
	 file descriptor leaks, etc.  */
      sim_module_uninstall (sd);
      return 0;
    }

  return sd;
}


void
sim_close (SIM_DESC sd, int quitting)
{
  /* Uninstall the modules to avoid memory leaks,
     file descriptor leaks, etc.  */
  sim_module_uninstall (sd);
}


SIM_RC
sim_create_inferior (SIM_DESC sd,
		     struct _bfd *abfd,
		     char **argv,
		     char **envp)
{
  /* clear all registers */
  memset (&STATE_CPU (sd, 0)->regs, 0, sizeof (STATE_CPU (sd, 0)->regs));
  EIT_VB = EIT_VB_DEFAULT;
  STATE_CPU (sd, 0)->unit = any_unit;
  sim_module_init (sd);
  if (abfd != NULL)
    PC = bfd_get_start_address (abfd);
  else
    PC = 0xfffff000; /* reset value */
  return SIM_RC_OK;
}

void
sim_do_command (SIM_DESC sd, char *cmd)
{
  if (sim_args_command (sd, cmd) != SIM_RC_OK)
    sim_io_printf (sd, "Unknown command `%s'\n", cmd);
}

/* The following register definitions were ripped off from
   gdb/config/tm-d30v.h.  If any of those defs changes, this table needs to
   be updated.  */

#define NUM_REGS 86

#define R0_REGNUM	0
#define FP_REGNUM	11
#define LR_REGNUM 	62
#define SP_REGNUM 	63
#define SPI_REGNUM	64	/* Interrupt stack pointer */
#define SPU_REGNUM	65	/* User stack pointer */
#define CREGS_START	66

#define PSW_REGNUM 	(CREGS_START + 0) /* psw, bpsw, or dpsw??? */
#define    PSW_SM 0x80000000	/* Stack mode: 0 == interrupt (SPI),
					       1 == user (SPU) */
#define BPSW_REGNUM	(CREGS_START + 1) /* Backup PSW (on interrupt) */
#define PC_REGNUM 	(CREGS_START + 2) /* pc, bpc, or dpc??? */
#define BPC_REGNUM 	(CREGS_START + 3) /* Backup PC (on interrupt) */
#define DPSW_REGNUM	(CREGS_START + 4) /* Backup PSW (on debug trap) */
#define DPC_REGNUM 	(CREGS_START + 5) /* Backup PC (on debug trap) */
#define RPT_C_REGNUM	(CREGS_START + 7) /* Loop count */
#define RPT_S_REGNUM	(CREGS_START + 8) /* Loop start address*/
#define RPT_E_REGNUM	(CREGS_START + 9) /* Loop end address */
#define MOD_S_REGNUM	(CREGS_START + 10)
#define MOD_E_REGNUM	(CREGS_START + 11)
#define IBA_REGNUM	(CREGS_START + 14) /* Instruction break address */
#define EIT_VB_REGNUM	(CREGS_START + 15) /* Vector base address */
#define INT_S_REGNUM	(CREGS_START + 16) /* Interrupt status */
#define INT_M_REGNUM	(CREGS_START + 17) /* Interrupt mask */
#define A0_REGNUM 	84
#define A1_REGNUM 	85

int
sim_fetch_register (sd, regno, buf, length)
     SIM_DESC sd;
     int regno;
     unsigned char *buf;
     int length;
{
  if (regno < A0_REGNUM)
    {
      unsigned32 reg;

      if (regno <= R0_REGNUM + 63)
	reg = sd->cpu[0].regs.general_purpose[regno];
      else if (regno <= SPU_REGNUM)
	reg = sd->cpu[0].regs.sp[regno - SPI_REGNUM];
      else
	reg = sd->cpu[0].regs.control[regno - CREGS_START];

      buf[0] = reg >> 24;
      buf[1] = reg >> 16;
      buf[2] = reg >> 8;
      buf[3] = reg;
    }
  else if (regno < NUM_REGS)
    {
      unsigned32 reg;

      reg = sd->cpu[0].regs.accumulator[regno - A0_REGNUM] >> 32;

      buf[0] = reg >> 24;
      buf[1] = reg >> 16;
      buf[2] = reg >> 8;
      buf[3] = reg;

      reg = sd->cpu[0].regs.accumulator[regno - A0_REGNUM];

      buf[4] = reg >> 24;
      buf[5] = reg >> 16;
      buf[6] = reg >> 8;
      buf[7] = reg;
    }
  else
    abort ();
  return -1;
}

int
sim_store_register (sd, regno, buf, length)
     SIM_DESC sd;
     int regno;
     unsigned char *buf;
     int length;
{
  if (regno < A0_REGNUM)
    {
      unsigned32 reg;

      reg = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];

      if (regno <= R0_REGNUM + 63)
	sd->cpu[0].regs.general_purpose[regno] = reg;
      else if (regno <= SPU_REGNUM)
	sd->cpu[0].regs.sp[regno - SPI_REGNUM] = reg;
      else
	sd->cpu[0].regs.control[regno - CREGS_START] = reg;
    }
  else if (regno < NUM_REGS)
    {
      unsigned32 reg;

      reg = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];

      sd->cpu[0].regs.accumulator[regno - A0_REGNUM] = (unsigned64)reg << 32;

      reg = (buf[4] << 24) | (buf[5] << 16) | (buf[6] << 8) | buf[7];

      sd->cpu[0].regs.accumulator[regno - A0_REGNUM] |= reg;
    }
  else
    abort ();
  return -1;
}
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.1.20.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d1 364
a364 364
/* OBSOLETE /*  This file is part of the program psim. */
/* OBSOLETE  */
/* OBSOLETE     Copyright (C) 1994-1996, Andrew Cagney <cagney@@highland.com.au> */
/* OBSOLETE     Copyright (C) 1997, Free Software Foundation */
/* OBSOLETE  */
/* OBSOLETE     This program is free software; you can redistribute it and/or modify */
/* OBSOLETE     it under the terms of the GNU General Public License as published by */
/* OBSOLETE     the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE     (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE     This program is distributed in the hope that it will be useful, */
/* OBSOLETE     but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE     GNU General Public License for more details. */
/* OBSOLETE   */
/* OBSOLETE     You should have received a copy of the GNU General Public License */
/* OBSOLETE     along with this program; if not, write to the Free Software */
/* OBSOLETE     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
/* OBSOLETE   */
/* OBSOLETE     */ */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE #include <stdarg.h> */
/* OBSOLETE #include <ctype.h> */
/* OBSOLETE  */
/* OBSOLETE #include "sim-main.h" */
/* OBSOLETE #include "sim-options.h" */
/* OBSOLETE  */
/* OBSOLETE #include "bfd.h" */
/* OBSOLETE #include "sim-utils.h" */
/* OBSOLETE  */
/* OBSOLETE #ifdef HAVE_STDLIB_H */
/* OBSOLETE #include <stdlib.h> */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE static unsigned long extmem_size = 1024*1024*8;	/* 8 meg is the maximum listed in the arch. manual */ */
/* OBSOLETE  */
/* OBSOLETE static const char * get_insn_name (sim_cpu *, int); */
/* OBSOLETE  */
/* OBSOLETE #define SIM_ADDR unsigned */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE #define OPTION_TRACE_CALL	200 */
/* OBSOLETE #define OPTION_TRACE_TRAPDUMP	201 */
/* OBSOLETE #define OPTION_EXTMEM_SIZE	202 */
/* OBSOLETE  */
/* OBSOLETE static SIM_RC */
/* OBSOLETE d30v_option_handler (SIM_DESC sd, */
/* OBSOLETE 		     sim_cpu *cpu, */
/* OBSOLETE 		     int opt, */
/* OBSOLETE 		     char *arg, */
/* OBSOLETE 		     int command_p) */
/* OBSOLETE { */
/* OBSOLETE   char *suffix; */
/* OBSOLETE  */
/* OBSOLETE   switch (opt) */
/* OBSOLETE     { */
/* OBSOLETE     default: */
/* OBSOLETE       break; */
/* OBSOLETE  */
/* OBSOLETE     case OPTION_TRACE_CALL: */
/* OBSOLETE       if (arg == NULL || strcmp (arg, "yes") == 0 || strcmp (arg, "on") == 0) */
/* OBSOLETE 	TRACE_CALL_P = 1; */
/* OBSOLETE       else if (strcmp (arg, "no") == 0 || strcmp (arg, "off") == 0) */
/* OBSOLETE 	TRACE_CALL_P = 0; */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  sim_io_eprintf (sd, "Unreconized --trace-call option `%s'\n", arg); */
/* OBSOLETE 	  return SIM_RC_FAIL; */
/* OBSOLETE 	} */
/* OBSOLETE       return SIM_RC_OK; */
/* OBSOLETE  */
/* OBSOLETE     case OPTION_TRACE_TRAPDUMP: */
/* OBSOLETE       if (arg == NULL || strcmp (arg, "yes") == 0 || strcmp (arg, "on") == 0) */
/* OBSOLETE 	TRACE_TRAP_P = 1; */
/* OBSOLETE       else if (strcmp (arg, "no") == 0 || strcmp (arg, "off") == 0) */
/* OBSOLETE 	TRACE_TRAP_P = 0; */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  sim_io_eprintf (sd, "Unreconized --trace-call option `%s'\n", arg); */
/* OBSOLETE 	  return SIM_RC_FAIL; */
/* OBSOLETE 	} */
/* OBSOLETE       return SIM_RC_OK; */
/* OBSOLETE  */
/* OBSOLETE     case OPTION_EXTMEM_SIZE: */
/* OBSOLETE       if (arg == NULL || !isdigit (*arg)) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  sim_io_eprintf (sd, "Invalid memory size `%s'", arg); */
/* OBSOLETE 	  return SIM_RC_FAIL; */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       suffix = arg; */
/* OBSOLETE       extmem_size = strtol (arg, &suffix, 0); */
/* OBSOLETE       if (*suffix == 'm' || *suffix == 'M') */
/* OBSOLETE 	extmem_size <<= 20; */
/* OBSOLETE       else if (*suffix == 'k' || *suffix == 'K') */
/* OBSOLETE 	extmem_size <<= 10; */
/* OBSOLETE       sim_do_commandf (sd, "memory delete 0x80000000"); */
/* OBSOLETE       sim_do_commandf (sd, "memory region 0x80000000,0x%lx", extmem_size); */
/* OBSOLETE  */
/* OBSOLETE       return SIM_RC_OK; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   sim_io_eprintf (sd, "Unknown option (%d)\n", opt); */
/* OBSOLETE   return SIM_RC_FAIL; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static const OPTION d30v_options[] = */
/* OBSOLETE { */
/* OBSOLETE   { {"trace-call", optional_argument, NULL, OPTION_TRACE_CALL}, */
/* OBSOLETE       '\0', "on|off", "Enable tracing of calls and returns, checking saved registers", */
/* OBSOLETE       d30v_option_handler }, */
/* OBSOLETE   { {"trace-trapdump", optional_argument, NULL, OPTION_TRACE_TRAPDUMP}, */
/* OBSOLETE       '\0', "on|off", */
/* OBSOLETE #if TRAPDUMP */
/* OBSOLETE     "Traps 0..30 dump out all of the registers (defaults on)", */
/* OBSOLETE #else */
/* OBSOLETE     "Traps 0..30 dump out all of the registers", */
/* OBSOLETE #endif */
/* OBSOLETE       d30v_option_handler }, */
/* OBSOLETE   { {"extmem-size", required_argument, NULL, OPTION_EXTMEM_SIZE}, */
/* OBSOLETE     '\0', "size", "Change size of external memory, default 8 meg", */
/* OBSOLETE     d30v_option_handler }, */
/* OBSOLETE   { {NULL, no_argument, NULL, 0}, '\0', NULL, NULL, NULL } */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE /* Return name of an insn, used by insn profiling.  */ */
/* OBSOLETE  */
/* OBSOLETE static const char * */
/* OBSOLETE get_insn_name (sim_cpu *cpu, int i) */
/* OBSOLETE { */
/* OBSOLETE   return itable[i].name; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Structures used by the simulator, for gdb just have static structures */ */
/* OBSOLETE  */
/* OBSOLETE SIM_DESC */
/* OBSOLETE sim_open (SIM_OPEN_KIND kind, */
/* OBSOLETE 	  host_callback *callback, */
/* OBSOLETE 	  struct _bfd *abfd, */
/* OBSOLETE 	  char **argv) */
/* OBSOLETE { */
/* OBSOLETE   SIM_DESC sd = sim_state_alloc (kind, callback); */
/* OBSOLETE  */
/* OBSOLETE   /* FIXME: watchpoints code shouldn't need this */ */
/* OBSOLETE   STATE_WATCHPOINTS (sd)->pc = &(PC); */
/* OBSOLETE   STATE_WATCHPOINTS (sd)->sizeof_pc = sizeof (PC); */
/* OBSOLETE   STATE_WATCHPOINTS (sd)->interrupt_handler = d30v_interrupt_event; */
/* OBSOLETE  */
/* OBSOLETE   /* Initialize the mechanism for doing insn profiling.  */ */
/* OBSOLETE   CPU_INSN_NAME (STATE_CPU (sd, 0)) = get_insn_name; */
/* OBSOLETE   CPU_MAX_INSNS (STATE_CPU (sd, 0)) = nr_itable_entries; */
/* OBSOLETE  */
/* OBSOLETE #ifdef TRAPDUMP */
/* OBSOLETE   TRACE_TRAP_P = TRAPDUMP; */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE   if (sim_pre_argv_init (sd, argv[0]) != SIM_RC_OK) */
/* OBSOLETE     return 0; */
/* OBSOLETE   sim_add_option_table (sd, NULL, d30v_options); */
/* OBSOLETE  */
/* OBSOLETE   /* Memory and EEPROM */ */
/* OBSOLETE   /* internal instruction RAM - fixed */ */
/* OBSOLETE   sim_do_commandf (sd, "memory region 0,0x10000"); */
/* OBSOLETE   /* internal data RAM - fixed */ */
/* OBSOLETE   sim_do_commandf (sd, "memory region 0x20000000,0x8000"); */
/* OBSOLETE   /* control register dummy area */ */
/* OBSOLETE   sim_do_commandf (sd, "memory region 0x40000000,0x10000"); */
/* OBSOLETE   /* external RAM */ */
/* OBSOLETE   sim_do_commandf (sd, "memory region 0x80000000,0x%lx", extmem_size); */
/* OBSOLETE   /* EIT RAM */ */
/* OBSOLETE   sim_do_commandf (sd, "memory region 0xfffff000,0x1000"); */
/* OBSOLETE  */
/* OBSOLETE   /* getopt will print the error message so we just have to exit if this fails. */
/* OBSOLETE      FIXME: Hmmm...  in the case of gdb we need getopt to call */
/* OBSOLETE      print_filtered.  */ */
/* OBSOLETE   if (sim_parse_args (sd, argv) != SIM_RC_OK) */
/* OBSOLETE     { */
/* OBSOLETE       /* Uninstall the modules to avoid memory leaks, */
/* OBSOLETE 	 file descriptor leaks, etc.  */ */
/* OBSOLETE       sim_module_uninstall (sd); */
/* OBSOLETE       return 0; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* check for/establish the a reference program image */ */
/* OBSOLETE   if (sim_analyze_program (sd, */
/* OBSOLETE 			   (STATE_PROG_ARGV (sd) != NULL */
/* OBSOLETE 			    ? *STATE_PROG_ARGV (sd) */
/* OBSOLETE 			    : NULL), */
/* OBSOLETE 			   abfd) != SIM_RC_OK) */
/* OBSOLETE     { */
/* OBSOLETE       sim_module_uninstall (sd); */
/* OBSOLETE       return 0; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   /* establish any remaining configuration options */ */
/* OBSOLETE   if (sim_config (sd) != SIM_RC_OK) */
/* OBSOLETE     { */
/* OBSOLETE       sim_module_uninstall (sd); */
/* OBSOLETE       return 0; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   if (sim_post_argv_init (sd) != SIM_RC_OK) */
/* OBSOLETE     { */
/* OBSOLETE       /* Uninstall the modules to avoid memory leaks, */
/* OBSOLETE 	 file descriptor leaks, etc.  */ */
/* OBSOLETE       sim_module_uninstall (sd); */
/* OBSOLETE       return 0; */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   return sd; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE sim_close (SIM_DESC sd, int quitting) */
/* OBSOLETE { */
/* OBSOLETE   /* Uninstall the modules to avoid memory leaks, */
/* OBSOLETE      file descriptor leaks, etc.  */ */
/* OBSOLETE   sim_module_uninstall (sd); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE SIM_RC */
/* OBSOLETE sim_create_inferior (SIM_DESC sd, */
/* OBSOLETE 		     struct _bfd *abfd, */
/* OBSOLETE 		     char **argv, */
/* OBSOLETE 		     char **envp) */
/* OBSOLETE { */
/* OBSOLETE   /* clear all registers */ */
/* OBSOLETE   memset (&STATE_CPU (sd, 0)->regs, 0, sizeof (STATE_CPU (sd, 0)->regs)); */
/* OBSOLETE   EIT_VB = EIT_VB_DEFAULT; */
/* OBSOLETE   STATE_CPU (sd, 0)->unit = any_unit; */
/* OBSOLETE   sim_module_init (sd); */
/* OBSOLETE   if (abfd != NULL) */
/* OBSOLETE     PC = bfd_get_start_address (abfd); */
/* OBSOLETE   else */
/* OBSOLETE     PC = 0xfffff000; /* reset value */ */
/* OBSOLETE   return SIM_RC_OK; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE sim_do_command (SIM_DESC sd, char *cmd) */
/* OBSOLETE { */
/* OBSOLETE   if (sim_args_command (sd, cmd) != SIM_RC_OK) */
/* OBSOLETE     sim_io_printf (sd, "Unknown command `%s'\n", cmd); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* The following register definitions were ripped off from */
/* OBSOLETE    gdb/config/tm-d30v.h.  If any of those defs changes, this table needs to */
/* OBSOLETE    be updated.  */ */
/* OBSOLETE  */
/* OBSOLETE #define NUM_REGS 86 */
/* OBSOLETE  */
/* OBSOLETE #define R0_REGNUM	0 */
/* OBSOLETE #define FP_REGNUM	11 */
/* OBSOLETE #define LR_REGNUM 	62 */
/* OBSOLETE #define SP_REGNUM 	63 */
/* OBSOLETE #define SPI_REGNUM	64	/* Interrupt stack pointer */ */
/* OBSOLETE #define SPU_REGNUM	65	/* User stack pointer */ */
/* OBSOLETE #define CREGS_START	66 */
/* OBSOLETE  */
/* OBSOLETE #define PSW_REGNUM 	(CREGS_START + 0) /* psw, bpsw, or dpsw??? */ */
/* OBSOLETE #define    PSW_SM 0x80000000	/* Stack mode: 0 == interrupt (SPI), */
/* OBSOLETE 					       1 == user (SPU) */ */
/* OBSOLETE #define BPSW_REGNUM	(CREGS_START + 1) /* Backup PSW (on interrupt) */ */
/* OBSOLETE #define PC_REGNUM 	(CREGS_START + 2) /* pc, bpc, or dpc??? */ */
/* OBSOLETE #define BPC_REGNUM 	(CREGS_START + 3) /* Backup PC (on interrupt) */ */
/* OBSOLETE #define DPSW_REGNUM	(CREGS_START + 4) /* Backup PSW (on debug trap) */ */
/* OBSOLETE #define DPC_REGNUM 	(CREGS_START + 5) /* Backup PC (on debug trap) */ */
/* OBSOLETE #define RPT_C_REGNUM	(CREGS_START + 7) /* Loop count */ */
/* OBSOLETE #define RPT_S_REGNUM	(CREGS_START + 8) /* Loop start address*/ */
/* OBSOLETE #define RPT_E_REGNUM	(CREGS_START + 9) /* Loop end address */ */
/* OBSOLETE #define MOD_S_REGNUM	(CREGS_START + 10) */
/* OBSOLETE #define MOD_E_REGNUM	(CREGS_START + 11) */
/* OBSOLETE #define IBA_REGNUM	(CREGS_START + 14) /* Instruction break address */ */
/* OBSOLETE #define EIT_VB_REGNUM	(CREGS_START + 15) /* Vector base address */ */
/* OBSOLETE #define INT_S_REGNUM	(CREGS_START + 16) /* Interrupt status */ */
/* OBSOLETE #define INT_M_REGNUM	(CREGS_START + 17) /* Interrupt mask */ */
/* OBSOLETE #define A0_REGNUM 	84 */
/* OBSOLETE #define A1_REGNUM 	85 */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE sim_fetch_register (sd, regno, buf, length) */
/* OBSOLETE      SIM_DESC sd; */
/* OBSOLETE      int regno; */
/* OBSOLETE      unsigned char *buf; */
/* OBSOLETE      int length; */
/* OBSOLETE { */
/* OBSOLETE   if (regno < A0_REGNUM) */
/* OBSOLETE     { */
/* OBSOLETE       unsigned32 reg; */
/* OBSOLETE  */
/* OBSOLETE       if (regno <= R0_REGNUM + 63) */
/* OBSOLETE 	reg = sd->cpu[0].regs.general_purpose[regno]; */
/* OBSOLETE       else if (regno <= SPU_REGNUM) */
/* OBSOLETE 	reg = sd->cpu[0].regs.sp[regno - SPI_REGNUM]; */
/* OBSOLETE       else */
/* OBSOLETE 	reg = sd->cpu[0].regs.control[regno - CREGS_START]; */
/* OBSOLETE  */
/* OBSOLETE       buf[0] = reg >> 24; */
/* OBSOLETE       buf[1] = reg >> 16; */
/* OBSOLETE       buf[2] = reg >> 8; */
/* OBSOLETE       buf[3] = reg; */
/* OBSOLETE     } */
/* OBSOLETE   else if (regno < NUM_REGS) */
/* OBSOLETE     { */
/* OBSOLETE       unsigned32 reg; */
/* OBSOLETE  */
/* OBSOLETE       reg = sd->cpu[0].regs.accumulator[regno - A0_REGNUM] >> 32; */
/* OBSOLETE  */
/* OBSOLETE       buf[0] = reg >> 24; */
/* OBSOLETE       buf[1] = reg >> 16; */
/* OBSOLETE       buf[2] = reg >> 8; */
/* OBSOLETE       buf[3] = reg; */
/* OBSOLETE  */
/* OBSOLETE       reg = sd->cpu[0].regs.accumulator[regno - A0_REGNUM]; */
/* OBSOLETE  */
/* OBSOLETE       buf[4] = reg >> 24; */
/* OBSOLETE       buf[5] = reg >> 16; */
/* OBSOLETE       buf[6] = reg >> 8; */
/* OBSOLETE       buf[7] = reg; */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     abort (); */
/* OBSOLETE   return -1; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE sim_store_register (sd, regno, buf, length) */
/* OBSOLETE      SIM_DESC sd; */
/* OBSOLETE      int regno; */
/* OBSOLETE      unsigned char *buf; */
/* OBSOLETE      int length; */
/* OBSOLETE { */
/* OBSOLETE   if (regno < A0_REGNUM) */
/* OBSOLETE     { */
/* OBSOLETE       unsigned32 reg; */
/* OBSOLETE  */
/* OBSOLETE       reg = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3]; */
/* OBSOLETE  */
/* OBSOLETE       if (regno <= R0_REGNUM + 63) */
/* OBSOLETE 	sd->cpu[0].regs.general_purpose[regno] = reg; */
/* OBSOLETE       else if (regno <= SPU_REGNUM) */
/* OBSOLETE 	sd->cpu[0].regs.sp[regno - SPI_REGNUM] = reg; */
/* OBSOLETE       else */
/* OBSOLETE 	sd->cpu[0].regs.control[regno - CREGS_START] = reg; */
/* OBSOLETE     } */
/* OBSOLETE   else if (regno < NUM_REGS) */
/* OBSOLETE     { */
/* OBSOLETE       unsigned32 reg; */
/* OBSOLETE  */
/* OBSOLETE       reg = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3]; */
/* OBSOLETE  */
/* OBSOLETE       sd->cpu[0].regs.accumulator[regno - A0_REGNUM] = (unsigned64)reg << 32; */
/* OBSOLETE  */
/* OBSOLETE       reg = (buf[4] << 24) | (buf[5] << 16) | (buf[6] << 8) | buf[7]; */
/* OBSOLETE  */
/* OBSOLETE       sd->cpu[0].regs.accumulator[regno - A0_REGNUM] |= reg; */
/* OBSOLETE     } */
/* OBSOLETE   else */
/* OBSOLETE     abort (); */
/* OBSOLETE   return -1; */
/* OBSOLETE } */
@


