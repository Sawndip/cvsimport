head	1.3;
access;
symbols
	gdb_6_3-20041109-release:1.2
	gdb_6_3-branch:1.2.0.66
	gdb_6_3-20041019-branchpoint:1.2
	drow_intercu-merge-20040921:1.2
	drow_intercu-merge-20040915:1.2
	jimb-gdb_6_2-e500-branch:1.2.0.68
	jimb-gdb_6_2-e500-branchpoint:1.2
	gdb_6_2-20040730-release:1.2
	gdb_6_2-branch:1.2.0.64
	gdb_6_2-2004-07-10-gmt-branchpoint:1.2
	gdb_6_1_1-20040616-release:1.2
	gdb_6_1-2004-04-05-release:1.2
	drow_intercu-merge-20040402:1.2
	drow_intercu-merge-20040327:1.2
	ezannoni_pie-20040323-branch:1.2.0.62
	ezannoni_pie-20040323-branchpoint:1.2
	cagney_tramp-20040321-mergepoint:1.2
	cagney_tramp-20040309-branch:1.2.0.60
	cagney_tramp-20040309-branchpoint:1.2
	gdb_6_1-branch:1.2.0.58
	gdb_6_1-2004-03-01-gmt-branchpoint:1.2
	drow_intercu-20040221-branch:1.2.0.56
	drow_intercu-20040221-branchpoint:1.2
	cagney_bfdfile-20040213-branch:1.2.0.54
	cagney_bfdfile-20040213-branchpoint:1.2
	drow-cplus-merge-20040208:1.2
	carlton_dictionary-20040126-merge:1.2
	cagney_bigcore-20040122-branch:1.2.0.52
	cagney_bigcore-20040122-branchpoint:1.2
	drow-cplus-merge-20040113:1.2
	drow-cplus-merge-20031224:1.2
	drow-cplus-merge-20031220:1.2
	carlton_dictionary-20031215-merge:1.2
	drow-cplus-merge-20031214:1.2
	carlton-dictionary-20031111-merge:1.2
	gdb_6_0-2003-10-04-release:1.2
	kettenis_sparc-20030918-branch:1.2.0.50
	kettenis_sparc-20030918-branchpoint:1.2
	carlton_dictionary-20030917-merge:1.2
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.48
	cagney_x86i386-20030821-branch:1.2.0.46
	cagney_x86i386-20030821-branchpoint:1.2
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.2.0.44
	gdb_6_0-2003-06-23-branchpoint:1.2
	jimb-ppc64-linux-20030613-branch:1.2.0.42
	jimb-ppc64-linux-20030613-branchpoint:1.2
	cagney_convert-20030606-branch:1.2.0.40
	cagney_convert-20030606-branchpoint:1.2
	cagney_writestrings-20030508-branch:1.2.0.38
	cagney_writestrings-20030508-branchpoint:1.2
	jimb-ppc64-linux-20030528-branch:1.2.0.36
	jimb-ppc64-linux-20030528-branchpoint:1.2
	carlton_dictionary-20030523-merge:1.2
	cagney_fileio-20030521-branch:1.2.0.34
	cagney_fileio-20030521-branchpoint:1.2
	kettenis_i386newframe-20030517-mergepoint:1.2
	jimb-ppc64-linux-20030509-branch:1.2.0.32
	jimb-ppc64-linux-20030509-branchpoint:1.2
	kettenis_i386newframe-20030504-mergepoint:1.2
	carlton_dictionary-20030430-merge:1.2
	kettenis_i386newframe-20030419-branch:1.2.0.30
	kettenis_i386newframe-20030419-branchpoint:1.2
	carlton_dictionary-20030416-merge:1.2
	cagney_frameaddr-20030409-mergepoint:1.2
	kettenis_i386newframe-20030406-branch:1.2.0.28
	kettenis_i386newframe-20030406-branchpoint:1.2
	cagney_frameaddr-20030403-branchpoint:1.2
	cagney_frameaddr-20030403-branch:1.2.0.26
	cagney_framebase-20030330-mergepoint:1.2
	cagney_framebase-20030326-branch:1.2.0.24
	cagney_framebase-20030326-branchpoint:1.2
	cagney_lazyid-20030317-branch:1.2.0.22
	cagney_lazyid-20030317-branchpoint:1.2
	kettenis-i386newframe-20030316-mergepoint:1.2
	offbyone-20030313-branch:1.2.0.20
	offbyone-20030313-branchpoint:1.2
	kettenis-i386newframe-20030308-branch:1.2.0.18
	kettenis-i386newframe-20030308-branchpoint:1.2
	carlton_dictionary-20030305-merge:1.2
	cagney_offbyone-20030303-branch:1.2.0.16
	cagney_offbyone-20030303-branchpoint:1.2
	carlton_dictionary-20030207-merge:1.2
	interps-20030202-branch:1.2.0.14
	interps-20030202-branchpoint:1.2
	cagney-unwind-20030108-branch:1.2.0.12
	cagney-unwind-20030108-branchpoint:1.2
	carlton_dictionary-20021223-merge:1.2
	gdb_5_3-2002-12-12-release:1.2
	carlton_dictionary-20021115-merge:1.2
	kseitz_interps-20021105-merge:1.2
	kseitz_interps-20021103-merge:1.2
	drow-cplus-merge-20021020:1.2
	drow-cplus-merge-20021025:1.2
	carlton_dictionary-20021025-merge:1.2
	carlton_dictionary-20021011-merge:1.2
	drow-cplus-branch:1.2.0.10
	drow-cplus-branchpoint:1.2
	kseitz_interps-20020930-merge:1.2
	carlton_dictionary-20020927-merge:1.2
	carlton_dictionary-branch:1.2.0.8
	carlton_dictionary-20020920-branchpoint:1.2
	gdb_5_3-branch:1.2.0.6
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.4
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.2
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.1.1.1
	kseitz_interps-20020528-branch:1.1.1.1.0.20
	kseitz_interps-20020528-branchpoint:1.1.1.1
	cagney_regbuf-20020515-branch:1.1.1.1.0.18
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	jimb-macro-020506-branch:1.1.1.1.0.16
	jimb-macro-020506-branchpoint:1.1.1.1
	gdb_5_2-2002-04-29-release:1.1.1.1
	gdb_5_2-branch:1.1.1.1.0.14
	gdb_5_2-2002-03-03-branchpoint:1.1.1.1
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.12
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.10
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.8
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.3
date	2004.11.12.16.45.18;	author cagney;	state dead;
branches;
next	1.2;

1.2
date	2002.07.14.00.15.20;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.00;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.35.00;	author shebs;	state Exp;
branches
	1.1.1.1.20.1;
next	;

1.1.1.1.20.1
date	2002.07.22.21.47.24;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.3
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* d30v, fr30, mn10200, z8k: Delete directory.
@
text
@/* OBSOLETE /* Mitsubishi Electric Corp. D30V Simulator. */
/* OBSOLETE    Copyright (C) 1997, Free Software Foundation, Inc. */
/* OBSOLETE    Contributed by Cygnus Support. */
/* OBSOLETE  */
/* OBSOLETE This file is part of GDB, the GNU debugger. */
/* OBSOLETE  */
/* OBSOLETE This program is free software; you can redistribute it and/or modify */
/* OBSOLETE it under the terms of the GNU General Public License as published by */
/* OBSOLETE the Free Software Foundation; either version 2, or (at your option) */
/* OBSOLETE any later version. */
/* OBSOLETE  */
/* OBSOLETE This program is distributed in the hope that it will be useful, */
/* OBSOLETE but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE You should have received a copy of the GNU General Public License along */
/* OBSOLETE with this program; if not, write to the Free Software Foundation, Inc., */
/* OBSOLETE 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */ */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE #ifndef _CPU_C_ */
/* OBSOLETE #define _CPU_C_ */
/* OBSOLETE  */
/* OBSOLETE #include "sim-main.h" */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE is_wrong_slot (SIM_DESC sd, */
/* OBSOLETE 	       address_word cia, */
/* OBSOLETE 	       itable_index index) */
/* OBSOLETE { */
/* OBSOLETE   switch (STATE_CPU (sd, 0)->unit) */
/* OBSOLETE     { */
/* OBSOLETE     case memory_unit: */
/* OBSOLETE       return !itable[index].option[itable_option_mu]; */
/* OBSOLETE     case integer_unit: */
/* OBSOLETE       return !itable[index].option[itable_option_iu]; */
/* OBSOLETE     case any_unit: */
/* OBSOLETE       return 0; */
/* OBSOLETE     default: */
/* OBSOLETE       sim_engine_abort (sd, STATE_CPU (sd, 0), cia, */
/* OBSOLETE 			"internal error - is_wrong_slot - bad switch"); */
/* OBSOLETE       return -1; */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE is_condition_ok (SIM_DESC sd, */
/* OBSOLETE 		 address_word cia, */
/* OBSOLETE 		 int cond) */
/* OBSOLETE { */
/* OBSOLETE   switch (cond) */
/* OBSOLETE     { */
/* OBSOLETE     case 0x0: */
/* OBSOLETE       return 1; */
/* OBSOLETE     case 0x1: */
/* OBSOLETE       return PSW_VAL(PSW_F0); */
/* OBSOLETE     case 0x2: */
/* OBSOLETE       return !PSW_VAL(PSW_F0); */
/* OBSOLETE     case 0x3: */
/* OBSOLETE       return PSW_VAL(PSW_F1); */
/* OBSOLETE     case 0x4: */
/* OBSOLETE       return !PSW_VAL(PSW_F1); */
/* OBSOLETE     case 0x5: */
/* OBSOLETE       return PSW_VAL(PSW_F0) && PSW_VAL(PSW_F1); */
/* OBSOLETE     case 0x6: */
/* OBSOLETE       return PSW_VAL(PSW_F0) && !PSW_VAL(PSW_F1); */
/* OBSOLETE     case 0x7: */
/* OBSOLETE       sim_engine_abort (sd, STATE_CPU (sd, 0), cia, */
/* OBSOLETE 			"is_condition_ok - bad instruction condition bits"); */
/* OBSOLETE       return 0; */
/* OBSOLETE     default: */
/* OBSOLETE       sim_engine_abort (sd, STATE_CPU (sd, 0), cia, */
/* OBSOLETE 			"internal error - is_condition_ok - bad switch"); */
/* OBSOLETE       return -1; */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* If --trace-call, trace calls, remembering the current state of */
/* OBSOLETE    registers.  */ */
/* OBSOLETE  */
/* OBSOLETE typedef struct _call_stack { */
/* OBSOLETE   struct _call_stack *prev; */
/* OBSOLETE   registers regs; */
/* OBSOLETE } call_stack; */
/* OBSOLETE  */
/* OBSOLETE static call_stack *call_stack_head = (call_stack *)0; */
/* OBSOLETE static int call_depth = 0; */
/* OBSOLETE  */
/* OBSOLETE void call_occurred (SIM_DESC sd, */
/* OBSOLETE 		    sim_cpu *cpu, */
/* OBSOLETE 		    address_word cia, */
/* OBSOLETE 		    address_word nia) */
/* OBSOLETE { */
/* OBSOLETE   call_stack *ptr = ZALLOC (call_stack); */
/* OBSOLETE   ptr->regs = cpu->regs; */
/* OBSOLETE   ptr->prev = call_stack_head; */
/* OBSOLETE   call_stack_head = ptr; */
/* OBSOLETE  */
/* OBSOLETE   trace_one_insn (sd, cpu, nia, 1, "", 0, "call", */
/* OBSOLETE 		  "Depth %3d, Return 0x%.8lx, Args 0x%.8lx 0x%.8lx", */
/* OBSOLETE 		  ++call_depth, (unsigned long)cia+8, (unsigned long)GPR[2], */
/* OBSOLETE 		  (unsigned long)GPR[3]); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* If --trace-call, trace returns, checking if any saved register was changed.  */ */
/* OBSOLETE  */
/* OBSOLETE void return_occurred (SIM_DESC sd, */
/* OBSOLETE 		      sim_cpu *cpu, */
/* OBSOLETE 		      address_word cia, */
/* OBSOLETE 		      address_word nia) */
/* OBSOLETE { */
/* OBSOLETE   char buffer[1024]; */
/* OBSOLETE   char *buf_ptr = buffer; */
/* OBSOLETE   call_stack *ptr = call_stack_head; */
/* OBSOLETE   int regno; */
/* OBSOLETE   char *prefix = ", Registers that differ: "; */
/* OBSOLETE  */
/* OBSOLETE   *buf_ptr = '\0'; */
/* OBSOLETE   for (regno = 34; regno <= 63; regno++) { */
/* OBSOLETE     if (cpu->regs.general_purpose[regno] != ptr->regs.general_purpose[regno]) { */
/* OBSOLETE       sprintf (buf_ptr, "%sr%d", prefix, regno); */
/* OBSOLETE       buf_ptr += strlen (buf_ptr); */
/* OBSOLETE       prefix = " "; */
/* OBSOLETE     } */
/* OBSOLETE   } */
/* OBSOLETE  */
/* OBSOLETE   if (cpu->regs.accumulator[1] != ptr->regs.accumulator[1]) { */
/* OBSOLETE     sprintf (buf_ptr, "%sa1", prefix); */
/* OBSOLETE     buf_ptr += strlen (buf_ptr); */
/* OBSOLETE     prefix = " "; */
/* OBSOLETE   } */
/* OBSOLETE  */
/* OBSOLETE   trace_one_insn (sd, cpu, cia, 1, "", 0, "return", */
/* OBSOLETE 		  "Depth %3d, Return 0x%.8lx, Ret. 0x%.8lx 0x%.8lx%s", */
/* OBSOLETE 		  call_depth--, (unsigned long)nia, (unsigned long)GPR[2], */
/* OBSOLETE 		  (unsigned long)GPR[3], buffer); */
/* OBSOLETE  */
/* OBSOLETE   call_stack_head = ptr->prev; */
/* OBSOLETE   zfree (ptr); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* Read/write functions for system call interface.  */ */
/* OBSOLETE int */
/* OBSOLETE d30v_read_mem (host_callback *cb, */
/* OBSOLETE 	       struct cb_syscall *sc, */
/* OBSOLETE 	       unsigned long taddr, */
/* OBSOLETE 	       char *buf, */
/* OBSOLETE 	       int bytes) */
/* OBSOLETE { */
/* OBSOLETE   SIM_DESC sd = (SIM_DESC) sc->p1; */
/* OBSOLETE   sim_cpu *cpu = STATE_CPU (sd, 0); */
/* OBSOLETE  */
/* OBSOLETE   return sim_core_read_buffer (sd, cpu, read_map, buf, taddr, bytes); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE d30v_write_mem (host_callback *cb, */
/* OBSOLETE 		struct cb_syscall *sc, */
/* OBSOLETE 		unsigned long taddr, */
/* OBSOLETE 		const char *buf, */
/* OBSOLETE 		int bytes) */
/* OBSOLETE { */
/* OBSOLETE   SIM_DESC sd = (SIM_DESC) sc->p1; */
/* OBSOLETE   sim_cpu *cpu = STATE_CPU (sd, 0); */
/* OBSOLETE  */
/* OBSOLETE   return sim_core_write_buffer (sd, cpu, write_map, buf, taddr, bytes); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE #endif /* _CPU_C_ */ */
@


1.2
log
@Obsolete the d30v.
@
text
@@


1.1
log
@Initial revision
@
text
@d1 172
a172 172
/* Mitsubishi Electric Corp. D30V Simulator.
   Copyright (C) 1997, Free Software Foundation, Inc.
   Contributed by Cygnus Support.

This file is part of GDB, the GNU debugger.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */


#ifndef _CPU_C_
#define _CPU_C_

#include "sim-main.h"


int
is_wrong_slot (SIM_DESC sd,
	       address_word cia,
	       itable_index index)
{
  switch (STATE_CPU (sd, 0)->unit)
    {
    case memory_unit:
      return !itable[index].option[itable_option_mu];
    case integer_unit:
      return !itable[index].option[itable_option_iu];
    case any_unit:
      return 0;
    default:
      sim_engine_abort (sd, STATE_CPU (sd, 0), cia,
			"internal error - is_wrong_slot - bad switch");
      return -1;
    }
}

int
is_condition_ok (SIM_DESC sd,
		 address_word cia,
		 int cond)
{
  switch (cond)
    {
    case 0x0:
      return 1;
    case 0x1:
      return PSW_VAL(PSW_F0);
    case 0x2:
      return !PSW_VAL(PSW_F0);
    case 0x3:
      return PSW_VAL(PSW_F1);
    case 0x4:
      return !PSW_VAL(PSW_F1);
    case 0x5:
      return PSW_VAL(PSW_F0) && PSW_VAL(PSW_F1);
    case 0x6:
      return PSW_VAL(PSW_F0) && !PSW_VAL(PSW_F1);
    case 0x7:
      sim_engine_abort (sd, STATE_CPU (sd, 0), cia,
			"is_condition_ok - bad instruction condition bits");
      return 0;
    default:
      sim_engine_abort (sd, STATE_CPU (sd, 0), cia,
			"internal error - is_condition_ok - bad switch");
      return -1;
    }
}

/* If --trace-call, trace calls, remembering the current state of
   registers.  */

typedef struct _call_stack {
  struct _call_stack *prev;
  registers regs;
} call_stack;

static call_stack *call_stack_head = (call_stack *)0;
static int call_depth = 0;

void call_occurred (SIM_DESC sd,
		    sim_cpu *cpu,
		    address_word cia,
		    address_word nia)
{
  call_stack *ptr = ZALLOC (call_stack);
  ptr->regs = cpu->regs;
  ptr->prev = call_stack_head;
  call_stack_head = ptr;

  trace_one_insn (sd, cpu, nia, 1, "", 0, "call",
		  "Depth %3d, Return 0x%.8lx, Args 0x%.8lx 0x%.8lx",
		  ++call_depth, (unsigned long)cia+8, (unsigned long)GPR[2],
		  (unsigned long)GPR[3]);
}

/* If --trace-call, trace returns, checking if any saved register was changed.  */

void return_occurred (SIM_DESC sd,
		      sim_cpu *cpu,
		      address_word cia,
		      address_word nia)
{
  char buffer[1024];
  char *buf_ptr = buffer;
  call_stack *ptr = call_stack_head;
  int regno;
  char *prefix = ", Registers that differ: ";

  *buf_ptr = '\0';
  for (regno = 34; regno <= 63; regno++) {
    if (cpu->regs.general_purpose[regno] != ptr->regs.general_purpose[regno]) {
      sprintf (buf_ptr, "%sr%d", prefix, regno);
      buf_ptr += strlen (buf_ptr);
      prefix = " ";
    }
  }

  if (cpu->regs.accumulator[1] != ptr->regs.accumulator[1]) {
    sprintf (buf_ptr, "%sa1", prefix);
    buf_ptr += strlen (buf_ptr);
    prefix = " ";
  }

  trace_one_insn (sd, cpu, cia, 1, "", 0, "return",
		  "Depth %3d, Return 0x%.8lx, Ret. 0x%.8lx 0x%.8lx%s",
		  call_depth--, (unsigned long)nia, (unsigned long)GPR[2],
		  (unsigned long)GPR[3], buffer);

  call_stack_head = ptr->prev;
  zfree (ptr);
}


/* Read/write functions for system call interface.  */
int
d30v_read_mem (host_callback *cb,
	       struct cb_syscall *sc,
	       unsigned long taddr,
	       char *buf,
	       int bytes)
{
  SIM_DESC sd = (SIM_DESC) sc->p1;
  sim_cpu *cpu = STATE_CPU (sd, 0);

  return sim_core_read_buffer (sd, cpu, read_map, buf, taddr, bytes);
}

int
d30v_write_mem (host_callback *cb,
		struct cb_syscall *sc,
		unsigned long taddr,
		const char *buf,
		int bytes)
{
  SIM_DESC sd = (SIM_DESC) sc->p1;
  sim_cpu *cpu = STATE_CPU (sd, 0);

  return sim_core_write_buffer (sd, cpu, write_map, buf, taddr, bytes);
}

#endif /* _CPU_C_ */
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.1.20.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d1 172
a172 172
/* OBSOLETE /* Mitsubishi Electric Corp. D30V Simulator. */
/* OBSOLETE    Copyright (C) 1997, Free Software Foundation, Inc. */
/* OBSOLETE    Contributed by Cygnus Support. */
/* OBSOLETE  */
/* OBSOLETE This file is part of GDB, the GNU debugger. */
/* OBSOLETE  */
/* OBSOLETE This program is free software; you can redistribute it and/or modify */
/* OBSOLETE it under the terms of the GNU General Public License as published by */
/* OBSOLETE the Free Software Foundation; either version 2, or (at your option) */
/* OBSOLETE any later version. */
/* OBSOLETE  */
/* OBSOLETE This program is distributed in the hope that it will be useful, */
/* OBSOLETE but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE You should have received a copy of the GNU General Public License along */
/* OBSOLETE with this program; if not, write to the Free Software Foundation, Inc., */
/* OBSOLETE 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */ */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE #ifndef _CPU_C_ */
/* OBSOLETE #define _CPU_C_ */
/* OBSOLETE  */
/* OBSOLETE #include "sim-main.h" */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE is_wrong_slot (SIM_DESC sd, */
/* OBSOLETE 	       address_word cia, */
/* OBSOLETE 	       itable_index index) */
/* OBSOLETE { */
/* OBSOLETE   switch (STATE_CPU (sd, 0)->unit) */
/* OBSOLETE     { */
/* OBSOLETE     case memory_unit: */
/* OBSOLETE       return !itable[index].option[itable_option_mu]; */
/* OBSOLETE     case integer_unit: */
/* OBSOLETE       return !itable[index].option[itable_option_iu]; */
/* OBSOLETE     case any_unit: */
/* OBSOLETE       return 0; */
/* OBSOLETE     default: */
/* OBSOLETE       sim_engine_abort (sd, STATE_CPU (sd, 0), cia, */
/* OBSOLETE 			"internal error - is_wrong_slot - bad switch"); */
/* OBSOLETE       return -1; */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE is_condition_ok (SIM_DESC sd, */
/* OBSOLETE 		 address_word cia, */
/* OBSOLETE 		 int cond) */
/* OBSOLETE { */
/* OBSOLETE   switch (cond) */
/* OBSOLETE     { */
/* OBSOLETE     case 0x0: */
/* OBSOLETE       return 1; */
/* OBSOLETE     case 0x1: */
/* OBSOLETE       return PSW_VAL(PSW_F0); */
/* OBSOLETE     case 0x2: */
/* OBSOLETE       return !PSW_VAL(PSW_F0); */
/* OBSOLETE     case 0x3: */
/* OBSOLETE       return PSW_VAL(PSW_F1); */
/* OBSOLETE     case 0x4: */
/* OBSOLETE       return !PSW_VAL(PSW_F1); */
/* OBSOLETE     case 0x5: */
/* OBSOLETE       return PSW_VAL(PSW_F0) && PSW_VAL(PSW_F1); */
/* OBSOLETE     case 0x6: */
/* OBSOLETE       return PSW_VAL(PSW_F0) && !PSW_VAL(PSW_F1); */
/* OBSOLETE     case 0x7: */
/* OBSOLETE       sim_engine_abort (sd, STATE_CPU (sd, 0), cia, */
/* OBSOLETE 			"is_condition_ok - bad instruction condition bits"); */
/* OBSOLETE       return 0; */
/* OBSOLETE     default: */
/* OBSOLETE       sim_engine_abort (sd, STATE_CPU (sd, 0), cia, */
/* OBSOLETE 			"internal error - is_condition_ok - bad switch"); */
/* OBSOLETE       return -1; */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* If --trace-call, trace calls, remembering the current state of */
/* OBSOLETE    registers.  */ */
/* OBSOLETE  */
/* OBSOLETE typedef struct _call_stack { */
/* OBSOLETE   struct _call_stack *prev; */
/* OBSOLETE   registers regs; */
/* OBSOLETE } call_stack; */
/* OBSOLETE  */
/* OBSOLETE static call_stack *call_stack_head = (call_stack *)0; */
/* OBSOLETE static int call_depth = 0; */
/* OBSOLETE  */
/* OBSOLETE void call_occurred (SIM_DESC sd, */
/* OBSOLETE 		    sim_cpu *cpu, */
/* OBSOLETE 		    address_word cia, */
/* OBSOLETE 		    address_word nia) */
/* OBSOLETE { */
/* OBSOLETE   call_stack *ptr = ZALLOC (call_stack); */
/* OBSOLETE   ptr->regs = cpu->regs; */
/* OBSOLETE   ptr->prev = call_stack_head; */
/* OBSOLETE   call_stack_head = ptr; */
/* OBSOLETE  */
/* OBSOLETE   trace_one_insn (sd, cpu, nia, 1, "", 0, "call", */
/* OBSOLETE 		  "Depth %3d, Return 0x%.8lx, Args 0x%.8lx 0x%.8lx", */
/* OBSOLETE 		  ++call_depth, (unsigned long)cia+8, (unsigned long)GPR[2], */
/* OBSOLETE 		  (unsigned long)GPR[3]); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* If --trace-call, trace returns, checking if any saved register was changed.  */ */
/* OBSOLETE  */
/* OBSOLETE void return_occurred (SIM_DESC sd, */
/* OBSOLETE 		      sim_cpu *cpu, */
/* OBSOLETE 		      address_word cia, */
/* OBSOLETE 		      address_word nia) */
/* OBSOLETE { */
/* OBSOLETE   char buffer[1024]; */
/* OBSOLETE   char *buf_ptr = buffer; */
/* OBSOLETE   call_stack *ptr = call_stack_head; */
/* OBSOLETE   int regno; */
/* OBSOLETE   char *prefix = ", Registers that differ: "; */
/* OBSOLETE  */
/* OBSOLETE   *buf_ptr = '\0'; */
/* OBSOLETE   for (regno = 34; regno <= 63; regno++) { */
/* OBSOLETE     if (cpu->regs.general_purpose[regno] != ptr->regs.general_purpose[regno]) { */
/* OBSOLETE       sprintf (buf_ptr, "%sr%d", prefix, regno); */
/* OBSOLETE       buf_ptr += strlen (buf_ptr); */
/* OBSOLETE       prefix = " "; */
/* OBSOLETE     } */
/* OBSOLETE   } */
/* OBSOLETE  */
/* OBSOLETE   if (cpu->regs.accumulator[1] != ptr->regs.accumulator[1]) { */
/* OBSOLETE     sprintf (buf_ptr, "%sa1", prefix); */
/* OBSOLETE     buf_ptr += strlen (buf_ptr); */
/* OBSOLETE     prefix = " "; */
/* OBSOLETE   } */
/* OBSOLETE  */
/* OBSOLETE   trace_one_insn (sd, cpu, cia, 1, "", 0, "return", */
/* OBSOLETE 		  "Depth %3d, Return 0x%.8lx, Ret. 0x%.8lx 0x%.8lx%s", */
/* OBSOLETE 		  call_depth--, (unsigned long)nia, (unsigned long)GPR[2], */
/* OBSOLETE 		  (unsigned long)GPR[3], buffer); */
/* OBSOLETE  */
/* OBSOLETE   call_stack_head = ptr->prev; */
/* OBSOLETE   zfree (ptr); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* Read/write functions for system call interface.  */ */
/* OBSOLETE int */
/* OBSOLETE d30v_read_mem (host_callback *cb, */
/* OBSOLETE 	       struct cb_syscall *sc, */
/* OBSOLETE 	       unsigned long taddr, */
/* OBSOLETE 	       char *buf, */
/* OBSOLETE 	       int bytes) */
/* OBSOLETE { */
/* OBSOLETE   SIM_DESC sd = (SIM_DESC) sc->p1; */
/* OBSOLETE   sim_cpu *cpu = STATE_CPU (sd, 0); */
/* OBSOLETE  */
/* OBSOLETE   return sim_core_read_buffer (sd, cpu, read_map, buf, taddr, bytes); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE int */
/* OBSOLETE d30v_write_mem (host_callback *cb, */
/* OBSOLETE 		struct cb_syscall *sc, */
/* OBSOLETE 		unsigned long taddr, */
/* OBSOLETE 		const char *buf, */
/* OBSOLETE 		int bytes) */
/* OBSOLETE { */
/* OBSOLETE   SIM_DESC sd = (SIM_DESC) sc->p1; */
/* OBSOLETE   sim_cpu *cpu = STATE_CPU (sd, 0); */
/* OBSOLETE  */
/* OBSOLETE   return sim_core_write_buffer (sd, cpu, write_map, buf, taddr, bytes); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE #endif /* _CPU_C_ */ */
@


