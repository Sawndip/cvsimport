head	1.4;
access;
symbols
	gdb_6_3-20041109-release:1.3
	gdb_6_3-branch:1.3.0.66
	gdb_6_3-20041019-branchpoint:1.3
	drow_intercu-merge-20040921:1.3
	drow_intercu-merge-20040915:1.3
	jimb-gdb_6_2-e500-branch:1.3.0.68
	jimb-gdb_6_2-e500-branchpoint:1.3
	gdb_6_2-20040730-release:1.3
	gdb_6_2-branch:1.3.0.64
	gdb_6_2-2004-07-10-gmt-branchpoint:1.3
	gdb_6_1_1-20040616-release:1.3
	gdb_6_1-2004-04-05-release:1.3
	drow_intercu-merge-20040402:1.3
	drow_intercu-merge-20040327:1.3
	ezannoni_pie-20040323-branch:1.3.0.62
	ezannoni_pie-20040323-branchpoint:1.3
	cagney_tramp-20040321-mergepoint:1.3
	cagney_tramp-20040309-branch:1.3.0.60
	cagney_tramp-20040309-branchpoint:1.3
	gdb_6_1-branch:1.3.0.58
	gdb_6_1-2004-03-01-gmt-branchpoint:1.3
	drow_intercu-20040221-branch:1.3.0.56
	drow_intercu-20040221-branchpoint:1.3
	cagney_bfdfile-20040213-branch:1.3.0.54
	cagney_bfdfile-20040213-branchpoint:1.3
	drow-cplus-merge-20040208:1.3
	carlton_dictionary-20040126-merge:1.3
	cagney_bigcore-20040122-branch:1.3.0.52
	cagney_bigcore-20040122-branchpoint:1.3
	drow-cplus-merge-20040113:1.3
	drow-cplus-merge-20031224:1.3
	drow-cplus-merge-20031220:1.3
	carlton_dictionary-20031215-merge:1.3
	drow-cplus-merge-20031214:1.3
	carlton-dictionary-20031111-merge:1.3
	gdb_6_0-2003-10-04-release:1.3
	kettenis_sparc-20030918-branch:1.3.0.50
	kettenis_sparc-20030918-branchpoint:1.3
	carlton_dictionary-20030917-merge:1.3
	ezannoni_pie-20030916-branchpoint:1.3
	ezannoni_pie-20030916-branch:1.3.0.48
	cagney_x86i386-20030821-branch:1.3.0.46
	cagney_x86i386-20030821-branchpoint:1.3
	carlton_dictionary-20030805-merge:1.3
	carlton_dictionary-20030627-merge:1.3
	gdb_6_0-branch:1.3.0.44
	gdb_6_0-2003-06-23-branchpoint:1.3
	jimb-ppc64-linux-20030613-branch:1.3.0.42
	jimb-ppc64-linux-20030613-branchpoint:1.3
	cagney_convert-20030606-branch:1.3.0.40
	cagney_convert-20030606-branchpoint:1.3
	cagney_writestrings-20030508-branch:1.3.0.38
	cagney_writestrings-20030508-branchpoint:1.3
	jimb-ppc64-linux-20030528-branch:1.3.0.36
	jimb-ppc64-linux-20030528-branchpoint:1.3
	carlton_dictionary-20030523-merge:1.3
	cagney_fileio-20030521-branch:1.3.0.34
	cagney_fileio-20030521-branchpoint:1.3
	kettenis_i386newframe-20030517-mergepoint:1.3
	jimb-ppc64-linux-20030509-branch:1.3.0.32
	jimb-ppc64-linux-20030509-branchpoint:1.3
	kettenis_i386newframe-20030504-mergepoint:1.3
	carlton_dictionary-20030430-merge:1.3
	kettenis_i386newframe-20030419-branch:1.3.0.30
	kettenis_i386newframe-20030419-branchpoint:1.3
	carlton_dictionary-20030416-merge:1.3
	cagney_frameaddr-20030409-mergepoint:1.3
	kettenis_i386newframe-20030406-branch:1.3.0.28
	kettenis_i386newframe-20030406-branchpoint:1.3
	cagney_frameaddr-20030403-branchpoint:1.3
	cagney_frameaddr-20030403-branch:1.3.0.26
	cagney_framebase-20030330-mergepoint:1.3
	cagney_framebase-20030326-branch:1.3.0.24
	cagney_framebase-20030326-branchpoint:1.3
	cagney_lazyid-20030317-branch:1.3.0.22
	cagney_lazyid-20030317-branchpoint:1.3
	kettenis-i386newframe-20030316-mergepoint:1.3
	offbyone-20030313-branch:1.3.0.20
	offbyone-20030313-branchpoint:1.3
	kettenis-i386newframe-20030308-branch:1.3.0.18
	kettenis-i386newframe-20030308-branchpoint:1.3
	carlton_dictionary-20030305-merge:1.3
	cagney_offbyone-20030303-branch:1.3.0.16
	cagney_offbyone-20030303-branchpoint:1.3
	carlton_dictionary-20030207-merge:1.3
	interps-20030202-branch:1.3.0.14
	interps-20030202-branchpoint:1.3
	cagney-unwind-20030108-branch:1.3.0.12
	cagney-unwind-20030108-branchpoint:1.3
	carlton_dictionary-20021223-merge:1.3
	gdb_5_3-2002-12-12-release:1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.10
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	carlton_dictionary-branch:1.3.0.8
	carlton_dictionary-20020920-branchpoint:1.3
	gdb_5_3-branch:1.3.0.6
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.4
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.2
	readline_4_3-import-branchpoint:1.3
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.16
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.14
	cagney_regbuf-20020515-branchpoint:1.2
	jimb-macro-020506-branch:1.2.0.12
	jimb-macro-020506-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.10
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.2
	gdb_5_1_0_1-2002-01-03-release:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.6
	gdb_s390-2001-09-26-branchpoint:1.2
	gdb_5_1-2001-07-29-branch:1.2.0.4
	gdb_5_1-2001-07-29-branchpoint:1.2
	insight-precleanup-2001-01-01:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.4
date	2004.11.12.16.45.18;	author cagney;	state dead;
branches;
next	1.3;

1.3
date	2002.07.14.00.15.20;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.29.19.26.48;	author nickc;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.04.16.01.35.00;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.35.00;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.31.52;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.09.09.00.01.44;	author shebs;	state Exp;
branches;
next	;

1.2.16.1
date	2002.07.22.21.47.24;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.4
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* d30v, fr30, mn10200, z8k: Delete directory.
@
text
@/* OBSOLETE /* Mitsubishi Electric Corp. D30V Simulator. */
/* OBSOLETE    Copyright (C) 1997, Free Software Foundation, Inc. */
/* OBSOLETE    Contributed by Cygnus Support. */
/* OBSOLETE  */
/* OBSOLETE This file is part of GDB, the GNU debugger. */
/* OBSOLETE  */
/* OBSOLETE This program is free software; you can redistribute it and/or modify */
/* OBSOLETE it under the terms of the GNU General Public License as published by */
/* OBSOLETE the Free Software Foundation; either version 2, or (at your option) */
/* OBSOLETE any later version. */
/* OBSOLETE  */
/* OBSOLETE This program is distributed in the hope that it will be useful, */
/* OBSOLETE but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE You should have received a copy of the GNU General Public License along */
/* OBSOLETE with this program; if not, write to the Free Software Foundation, Inc., */
/* OBSOLETE 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */ */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE #ifndef _CPU_H_ */
/* OBSOLETE #define _CPU_H_ */
/* OBSOLETE  */
/* OBSOLETE enum { */
/* OBSOLETE   NR_GENERAL_PURPOSE_REGISTERS = 64, */
/* OBSOLETE   NR_CONTROL_REGISTERS = 64, */
/* OBSOLETE   NR_ACCUMULATORS = 2, */
/* OBSOLETE   STACK_POINTER_GPR = 63, */
/* OBSOLETE   NR_STACK_POINTERS = 2, */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE enum { */
/* OBSOLETE   processor_status_word_cr = 0, */
/* OBSOLETE   backup_processor_status_word_cr = 1, */
/* OBSOLETE   program_counter_cr = 2, */
/* OBSOLETE   backup_program_counter_cr = 3, */
/* OBSOLETE   debug_backup_processor_status_word_cr = 4, */
/* OBSOLETE   debug_backup_program_counter_cr = 5, */
/* OBSOLETE   reserved_6_cr = 6, */
/* OBSOLETE   repeat_count_cr = 7, */
/* OBSOLETE   repeat_start_address_cr = 8, */
/* OBSOLETE   repeat_end_address_cr = 9, */
/* OBSOLETE   modulo_start_address_cr = 10, */
/* OBSOLETE   modulo_end_address_cr = 11, */
/* OBSOLETE   instruction_break_address_cr = 14, */
/* OBSOLETE   eit_vector_base_cr = 15, */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE enum { */
/* OBSOLETE   PSW_SM = 0, */
/* OBSOLETE   PSW_EA = 2, */
/* OBSOLETE   PSW_DB = 3, */
/* OBSOLETE   PSW_DS = 4, */
/* OBSOLETE   PSW_IE = 5, */
/* OBSOLETE   PSW_RP = 6, */
/* OBSOLETE   PSW_MD = 7, */
/* OBSOLETE   PSW_F0 = 17, */
/* OBSOLETE   PSW_F1 = 19, */
/* OBSOLETE   PSW_F2 = 21, */
/* OBSOLETE   PSW_F3 = 23, */
/* OBSOLETE   PSW_S = 25, */
/* OBSOLETE   PSW_V = 27, */
/* OBSOLETE   PSW_VA = 29, */
/* OBSOLETE   PSW_C = 31, */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE /* aliases for PSW flag numbers (F0..F7) */ */
/* OBSOLETE enum */
/* OBSOLETE { */
/* OBSOLETE   PSW_S_FLAG = 4, */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE typedef struct _registers { */
/* OBSOLETE   unsigned32 general_purpose[NR_GENERAL_PURPOSE_REGISTERS]; */
/* OBSOLETE   /* keep track of the stack pointer */ */
/* OBSOLETE   unsigned32 sp[NR_STACK_POINTERS]; /* swap with SP */ */
/* OBSOLETE   unsigned32 current_sp; */
/* OBSOLETE   unsigned32 control[NR_CONTROL_REGISTERS]; */
/* OBSOLETE   unsigned64 accumulator[NR_ACCUMULATORS]; */
/* OBSOLETE } registers; */
/* OBSOLETE  */
/* OBSOLETE typedef enum _cpu_units { */
/* OBSOLETE   memory_unit, */
/* OBSOLETE   integer_unit, */
/* OBSOLETE   any_unit, */
/* OBSOLETE } cpu_units; */
/* OBSOLETE  */
/* OBSOLETE /* In order to support parallel instructions, which one instruction can be */
/* OBSOLETE    writing to a register that is used as input to another, queue up the */
/* OBSOLETE    writes to the end of the instruction boundaries.  */ */
/* OBSOLETE  */
/* OBSOLETE #define MAX_WRITE32	16 */
/* OBSOLETE #define MAX_WRITE64	2 */
/* OBSOLETE  */
/* OBSOLETE struct _write32 { */
/* OBSOLETE   int num;				/* # of 32-bit writes queued up */ */
/* OBSOLETE   unsigned32 value[MAX_WRITE32];	/* value to write */ */
/* OBSOLETE   unsigned32 mask[MAX_WRITE32];		/* mask to use */ */
/* OBSOLETE   unsigned32 *ptr[MAX_WRITE32];		/* address to write to */ */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE struct _write64 { */
/* OBSOLETE   int num;				/* # of 64-bit writes queued up */ */
/* OBSOLETE   unsigned64 value[MAX_WRITE64];	/* value to write */ */
/* OBSOLETE   unsigned64 *ptr[MAX_WRITE64];		/* address to write to */ */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE struct _sim_cpu { */
/* OBSOLETE   cpu_units unit; */
/* OBSOLETE   registers regs; */
/* OBSOLETE   sim_cpu_base base; */
/* OBSOLETE   int trace_call_p;			/* Whether to do call tracing.  */ */
/* OBSOLETE   int trace_trap_p;			/* If unknown traps dump out the regs */ */
/* OBSOLETE   int trace_action;			/* trace bits at end of instructions */ */
/* OBSOLETE   int left_kills_right_p;               /* left insn kills insn in right slot of -> */ */
/* OBSOLETE   int mvtsys_left_p;			/* left insn was mvtsys */ */
/* OBSOLETE   int did_trap;				/* we did a trap & need to finish it */ */
/* OBSOLETE   struct _write32 write32;		/* queued up 32-bit writes */ */
/* OBSOLETE   struct _write64 write64;		/* queued up 64-bit writes */ */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE #define PC	(STATE_CPU (sd, 0)->regs.control[program_counter_cr]) */
/* OBSOLETE #define PSW 	(STATE_CPU (sd, 0)->regs.control[processor_status_word_cr]) */
/* OBSOLETE #define PSWL    (*AL2_4(&PSW)) */
/* OBSOLETE #define PSWH    (*AH2_4(&PSW)) */
/* OBSOLETE #define DPSW 	(STATE_CPU (sd, 0)->regs.control[debug_backup_processor_status_word_cr]) */
/* OBSOLETE #define DPC 	(STATE_CPU (sd, 0)->regs.control[debug_backup_program_counter_cr]) */
/* OBSOLETE #define bPC 	(STATE_CPU (sd, 0)->regs.control[backup_program_counter_cr]) */
/* OBSOLETE #define bPSW 	(STATE_CPU (sd, 0)->regs.control[backup_processor_status_word_cr]) */
/* OBSOLETE #define RPT_C 	(STATE_CPU (sd, 0)->regs.control[repeat_count_cr]) */
/* OBSOLETE #define RPT_S 	(STATE_CPU (sd, 0)->regs.control[repeat_start_address_cr]) */
/* OBSOLETE #define RPT_E 	(STATE_CPU (sd, 0)->regs.control[repeat_end_address_cr]) */
/* OBSOLETE #define MOD_S 	(STATE_CPU (sd, 0)->regs.control[modulo_start_address_cr]) */
/* OBSOLETE #define MOD_E 	(STATE_CPU (sd, 0)->regs.control[modulo_end_address_cr]) */
/* OBSOLETE #define IBA 	(STATE_CPU (sd, 0)->regs.control[instruction_break_address_cr]) */
/* OBSOLETE #define EIT_VB	(STATE_CPU (sd, 0)->regs.control[eit_vector_base_cr]) */
/* OBSOLETE #define GPR	(STATE_CPU (sd, 0)->regs.general_purpose) */
/* OBSOLETE #define GPR_CLEAR(N) (GPR[(N)] = 0) */
/* OBSOLETE #define ACC	(STATE_CPU (sd, 0)->regs.accumulator) */
/* OBSOLETE #define CREG	(STATE_CPU (sd, 0)->regs.control) */
/* OBSOLETE #define SP      (GPR[STACK_POINTER_GPR]) */
/* OBSOLETE #define TRACE_CALL_P (STATE_CPU (sd, 0)->trace_call_p) */
/* OBSOLETE #define TRACE_TRAP_P (STATE_CPU (sd, 0)->trace_trap_p) */
/* OBSOLETE #define TRACE_ACTION (STATE_CPU (sd, 0)->trace_action) */
/* OBSOLETE #define     TRACE_ACTION_CALL	0x00000001	/* call occurred */ */
/* OBSOLETE #define     TRACE_ACTION_RETURN	0x00000002	/* return occurred */ */
/* OBSOLETE  */
/* OBSOLETE #define WRITE32 (STATE_CPU (sd, 0)->write32) */
/* OBSOLETE #define WRITE32_NUM	 (WRITE32.num) */
/* OBSOLETE #define WRITE32_PTR(N)	 (WRITE32.ptr[N]) */
/* OBSOLETE #define WRITE32_MASK(N)	 (WRITE32.mask[N]) */
/* OBSOLETE #define WRITE32_VALUE(N) (WRITE32.value[N]) */
/* OBSOLETE #define WRITE32_QUEUE(PTR, VALUE) WRITE32_QUEUE_MASK (PTR, VALUE, 0xffffffff) */
/* OBSOLETE  */
/* OBSOLETE #define WRITE32_QUEUE_MASK(PTR, VALUE, MASK)				\ */
/* OBSOLETE do {									\ */
/* OBSOLETE   int _num = WRITE32_NUM;						\ */
/* OBSOLETE   if (_num >= MAX_WRITE32)						\ */
/* OBSOLETE     sim_engine_abort (sd, STATE_CPU (sd, 0), cia,			\ */
/* OBSOLETE 		      "Too many queued 32-bit writes");			\ */
/* OBSOLETE   WRITE32_PTR(_num) = PTR;						\ */
/* OBSOLETE   WRITE32_VALUE(_num) = VALUE;						\ */
/* OBSOLETE   WRITE32_MASK(_num) = MASK;						\ */
/* OBSOLETE   WRITE32_NUM = _num+1;							\ */
/* OBSOLETE } while (0) */
/* OBSOLETE  */
/* OBSOLETE #define DID_TRAP	(STATE_CPU (sd, 0)->did_trap) */
/* OBSOLETE  */
/* OBSOLETE #define WRITE64 (STATE_CPU (sd, 0)->write64) */
/* OBSOLETE #define WRITE64_NUM	 (WRITE64.num) */
/* OBSOLETE #define WRITE64_PTR(N)	 (WRITE64.ptr[N]) */
/* OBSOLETE #define WRITE64_VALUE(N) (WRITE64.value[N]) */
/* OBSOLETE #define WRITE64_QUEUE(PTR, VALUE)					\ */
/* OBSOLETE do {									\ */
/* OBSOLETE   int _num = WRITE64_NUM;						\ */
/* OBSOLETE   if (_num >= MAX_WRITE64)						\ */
/* OBSOLETE     sim_engine_abort (sd, STATE_CPU (sd, 0), cia,			\ */
/* OBSOLETE 		      "Too many queued 64-bit writes");			\ */
/* OBSOLETE   WRITE64_PTR(_num) = PTR;						\ */
/* OBSOLETE   WRITE64_VALUE(_num) = VALUE;						\ */
/* OBSOLETE   WRITE64_NUM = _num+1;							\ */
/* OBSOLETE } while (0) */
/* OBSOLETE  */
/* OBSOLETE #define DPSW_VALID	0xbf005555 */
/* OBSOLETE #define PSW_VALID	0xb7005555 */
/* OBSOLETE #define EIT_VALID	0xfffff000	/* From page 7-4 of D30V/MPEG arch. manual  */ */
/* OBSOLETE #define EIT_VB_DEFAULT	0xfffff000	/* Value of the EIT_VB register after reset */ */
/* OBSOLETE  */
/* OBSOLETE /* Verify that the instruction is in the correct slot */ */
/* OBSOLETE  */
/* OBSOLETE #define IS_WRONG_SLOT is_wrong_slot(sd, cia, MY_INDEX) */
/* OBSOLETE extern int is_wrong_slot */
/* OBSOLETE (SIM_DESC sd, */
/* OBSOLETE  address_word cia, */
/* OBSOLETE  itable_index index); */
/* OBSOLETE  */
/* OBSOLETE #define IS_CONDITION_OK is_condition_ok(sd, cia, CCC) */
/* OBSOLETE extern int is_condition_ok */
/* OBSOLETE (SIM_DESC sd, */
/* OBSOLETE  address_word cia, */
/* OBSOLETE  int cond); */
/* OBSOLETE  */
/* OBSOLETE #define SIM_HAVE_BREAKPOINTS	/* Turn on internal breakpoint module */ */
/* OBSOLETE  */
/* OBSOLETE /* Internal breakpoint instruction is syscall 5 */ */
/* OBSOLETE #define SIM_BREAKPOINT {0x0e, 0x00, 0x00, 0x05} */
/* OBSOLETE #define SIM_BREAKPOINT_SIZE (4) */
/* OBSOLETE  */
/* OBSOLETE /* Call occurred */ */
/* OBSOLETE extern void call_occurred */
/* OBSOLETE (SIM_DESC sd, */
/* OBSOLETE  sim_cpu *cpu, */
/* OBSOLETE  address_word cia, */
/* OBSOLETE  address_word nia); */
/* OBSOLETE  */
/* OBSOLETE /* Return occurred */ */
/* OBSOLETE extern void return_occurred */
/* OBSOLETE (SIM_DESC sd, */
/* OBSOLETE  sim_cpu *cpu, */
/* OBSOLETE  address_word cia, */
/* OBSOLETE  address_word nia); */
/* OBSOLETE  */
/* OBSOLETE /* Whether to do call tracing.  */ */
/* OBSOLETE extern int d30v_call_trace_p; */
/* OBSOLETE  */
/* OBSOLETE /* Read/write functions for system call interface.  */ */
/* OBSOLETE extern int d30v_read_mem */
/* OBSOLETE (host_callback *cb, */
/* OBSOLETE  struct cb_syscall *sc, */
/* OBSOLETE  unsigned long taddr, */
/* OBSOLETE  char *buf, */
/* OBSOLETE  int bytes); */
/* OBSOLETE  */
/* OBSOLETE extern int d30v_write_mem */
/* OBSOLETE (host_callback *cb, */
/* OBSOLETE  struct cb_syscall *sc, */
/* OBSOLETE  unsigned long taddr, */
/* OBSOLETE  const char *buf, */
/* OBSOLETE  int bytes); */
/* OBSOLETE  */
/* OBSOLETE /* Process all of the queued up writes in order now */ */
/* OBSOLETE void unqueue_writes */
/* OBSOLETE (SIM_DESC sd, */
/* OBSOLETE  sim_cpu *cpu, */
/* OBSOLETE  address_word cia); */
/* OBSOLETE  */
/* OBSOLETE #endif /* _CPU_H_ */ */
@


1.3
log
@Obsolete the d30v.
@
text
@@


1.2
log
@replace GPR_SET with GPR_CLEAR
@
text
@d1 249
a249 249
/* Mitsubishi Electric Corp. D30V Simulator.
   Copyright (C) 1997, Free Software Foundation, Inc.
   Contributed by Cygnus Support.

This file is part of GDB, the GNU debugger.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */


#ifndef _CPU_H_
#define _CPU_H_

enum {
  NR_GENERAL_PURPOSE_REGISTERS = 64,
  NR_CONTROL_REGISTERS = 64,
  NR_ACCUMULATORS = 2,
  STACK_POINTER_GPR = 63,
  NR_STACK_POINTERS = 2,
};

enum {
  processor_status_word_cr = 0,
  backup_processor_status_word_cr = 1,
  program_counter_cr = 2,
  backup_program_counter_cr = 3,
  debug_backup_processor_status_word_cr = 4,
  debug_backup_program_counter_cr = 5,
  reserved_6_cr = 6,
  repeat_count_cr = 7,
  repeat_start_address_cr = 8,
  repeat_end_address_cr = 9,
  modulo_start_address_cr = 10,
  modulo_end_address_cr = 11,
  instruction_break_address_cr = 14,
  eit_vector_base_cr = 15,
};


enum {
  PSW_SM = 0,
  PSW_EA = 2,
  PSW_DB = 3,
  PSW_DS = 4,
  PSW_IE = 5,
  PSW_RP = 6,
  PSW_MD = 7,
  PSW_F0 = 17,
  PSW_F1 = 19,
  PSW_F2 = 21,
  PSW_F3 = 23,
  PSW_S = 25,
  PSW_V = 27,
  PSW_VA = 29,
  PSW_C = 31,
};

/* aliases for PSW flag numbers (F0..F7) */
enum
{
  PSW_S_FLAG = 4,
};

typedef struct _registers {
  unsigned32 general_purpose[NR_GENERAL_PURPOSE_REGISTERS];
  /* keep track of the stack pointer */
  unsigned32 sp[NR_STACK_POINTERS]; /* swap with SP */
  unsigned32 current_sp;
  unsigned32 control[NR_CONTROL_REGISTERS];
  unsigned64 accumulator[NR_ACCUMULATORS];
} registers;

typedef enum _cpu_units {
  memory_unit,
  integer_unit,
  any_unit,
} cpu_units;

/* In order to support parallel instructions, which one instruction can be
   writing to a register that is used as input to another, queue up the
   writes to the end of the instruction boundaries.  */

#define MAX_WRITE32	16
#define MAX_WRITE64	2

struct _write32 {
  int num;				/* # of 32-bit writes queued up */
  unsigned32 value[MAX_WRITE32];	/* value to write */
  unsigned32 mask[MAX_WRITE32];		/* mask to use */
  unsigned32 *ptr[MAX_WRITE32];		/* address to write to */
};

struct _write64 {
  int num;				/* # of 64-bit writes queued up */
  unsigned64 value[MAX_WRITE64];	/* value to write */
  unsigned64 *ptr[MAX_WRITE64];		/* address to write to */
};

struct _sim_cpu {
  cpu_units unit;
  registers regs;
  sim_cpu_base base;
  int trace_call_p;			/* Whether to do call tracing.  */
  int trace_trap_p;			/* If unknown traps dump out the regs */
  int trace_action;			/* trace bits at end of instructions */
  int left_kills_right_p;               /* left insn kills insn in right slot of -> */
  int mvtsys_left_p;			/* left insn was mvtsys */
  int did_trap;				/* we did a trap & need to finish it */
  struct _write32 write32;		/* queued up 32-bit writes */
  struct _write64 write64;		/* queued up 64-bit writes */
};

#define PC	(STATE_CPU (sd, 0)->regs.control[program_counter_cr])
#define PSW 	(STATE_CPU (sd, 0)->regs.control[processor_status_word_cr])
#define PSWL    (*AL2_4(&PSW))
#define PSWH    (*AH2_4(&PSW))
#define DPSW 	(STATE_CPU (sd, 0)->regs.control[debug_backup_processor_status_word_cr])
#define DPC 	(STATE_CPU (sd, 0)->regs.control[debug_backup_program_counter_cr])
#define bPC 	(STATE_CPU (sd, 0)->regs.control[backup_program_counter_cr])
#define bPSW 	(STATE_CPU (sd, 0)->regs.control[backup_processor_status_word_cr])
#define RPT_C 	(STATE_CPU (sd, 0)->regs.control[repeat_count_cr])
#define RPT_S 	(STATE_CPU (sd, 0)->regs.control[repeat_start_address_cr])
#define RPT_E 	(STATE_CPU (sd, 0)->regs.control[repeat_end_address_cr])
#define MOD_S 	(STATE_CPU (sd, 0)->regs.control[modulo_start_address_cr])
#define MOD_E 	(STATE_CPU (sd, 0)->regs.control[modulo_end_address_cr])
#define IBA 	(STATE_CPU (sd, 0)->regs.control[instruction_break_address_cr])
#define EIT_VB	(STATE_CPU (sd, 0)->regs.control[eit_vector_base_cr])
#define GPR	(STATE_CPU (sd, 0)->regs.general_purpose)
#define GPR_CLEAR(N) (GPR[(N)] = 0)
#define ACC	(STATE_CPU (sd, 0)->regs.accumulator)
#define CREG	(STATE_CPU (sd, 0)->regs.control)
#define SP      (GPR[STACK_POINTER_GPR])
#define TRACE_CALL_P (STATE_CPU (sd, 0)->trace_call_p)
#define TRACE_TRAP_P (STATE_CPU (sd, 0)->trace_trap_p)
#define TRACE_ACTION (STATE_CPU (sd, 0)->trace_action)
#define     TRACE_ACTION_CALL	0x00000001	/* call occurred */
#define     TRACE_ACTION_RETURN	0x00000002	/* return occurred */

#define WRITE32 (STATE_CPU (sd, 0)->write32)
#define WRITE32_NUM	 (WRITE32.num)
#define WRITE32_PTR(N)	 (WRITE32.ptr[N])
#define WRITE32_MASK(N)	 (WRITE32.mask[N])
#define WRITE32_VALUE(N) (WRITE32.value[N])
#define WRITE32_QUEUE(PTR, VALUE) WRITE32_QUEUE_MASK (PTR, VALUE, 0xffffffff)

#define WRITE32_QUEUE_MASK(PTR, VALUE, MASK)				\
do {									\
  int _num = WRITE32_NUM;						\
  if (_num >= MAX_WRITE32)						\
    sim_engine_abort (sd, STATE_CPU (sd, 0), cia,			\
		      "Too many queued 32-bit writes");			\
  WRITE32_PTR(_num) = PTR;						\
  WRITE32_VALUE(_num) = VALUE;						\
  WRITE32_MASK(_num) = MASK;						\
  WRITE32_NUM = _num+1;							\
} while (0)

#define DID_TRAP	(STATE_CPU (sd, 0)->did_trap)

#define WRITE64 (STATE_CPU (sd, 0)->write64)
#define WRITE64_NUM	 (WRITE64.num)
#define WRITE64_PTR(N)	 (WRITE64.ptr[N])
#define WRITE64_VALUE(N) (WRITE64.value[N])
#define WRITE64_QUEUE(PTR, VALUE)					\
do {									\
  int _num = WRITE64_NUM;						\
  if (_num >= MAX_WRITE64)						\
    sim_engine_abort (sd, STATE_CPU (sd, 0), cia,			\
		      "Too many queued 64-bit writes");			\
  WRITE64_PTR(_num) = PTR;						\
  WRITE64_VALUE(_num) = VALUE;						\
  WRITE64_NUM = _num+1;							\
} while (0)

#define DPSW_VALID	0xbf005555
#define PSW_VALID	0xb7005555
#define EIT_VALID	0xfffff000	/* From page 7-4 of D30V/MPEG arch. manual  */
#define EIT_VB_DEFAULT	0xfffff000	/* Value of the EIT_VB register after reset */

/* Verify that the instruction is in the correct slot */

#define IS_WRONG_SLOT is_wrong_slot(sd, cia, MY_INDEX)
extern int is_wrong_slot
(SIM_DESC sd,
 address_word cia,
 itable_index index);

#define IS_CONDITION_OK is_condition_ok(sd, cia, CCC)
extern int is_condition_ok
(SIM_DESC sd,
 address_word cia,
 int cond);

#define SIM_HAVE_BREAKPOINTS	/* Turn on internal breakpoint module */

/* Internal breakpoint instruction is syscall 5 */
#define SIM_BREAKPOINT {0x0e, 0x00, 0x00, 0x05}
#define SIM_BREAKPOINT_SIZE (4)

/* Call occurred */
extern void call_occurred
(SIM_DESC sd,
 sim_cpu *cpu,
 address_word cia,
 address_word nia);

/* Return occurred */
extern void return_occurred
(SIM_DESC sd,
 sim_cpu *cpu,
 address_word cia,
 address_word nia);

/* Whether to do call tracing.  */
extern int d30v_call_trace_p;

/* Read/write functions for system call interface.  */
extern int d30v_read_mem
(host_callback *cb,
 struct cb_syscall *sc,
 unsigned long taddr,
 char *buf,
 int bytes);

extern int d30v_write_mem
(host_callback *cb,
 struct cb_syscall *sc,
 unsigned long taddr,
 const char *buf,
 int bytes);

/* Process all of the queued up writes in order now */
void unqueue_writes
(SIM_DESC sd,
 sim_cpu *cpu,
 address_word cia);

#endif /* _CPU_H_ */
@


1.2.16.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d1 249
a249 249
/* OBSOLETE /* Mitsubishi Electric Corp. D30V Simulator. */
/* OBSOLETE    Copyright (C) 1997, Free Software Foundation, Inc. */
/* OBSOLETE    Contributed by Cygnus Support. */
/* OBSOLETE  */
/* OBSOLETE This file is part of GDB, the GNU debugger. */
/* OBSOLETE  */
/* OBSOLETE This program is free software; you can redistribute it and/or modify */
/* OBSOLETE it under the terms of the GNU General Public License as published by */
/* OBSOLETE the Free Software Foundation; either version 2, or (at your option) */
/* OBSOLETE any later version. */
/* OBSOLETE  */
/* OBSOLETE This program is distributed in the hope that it will be useful, */
/* OBSOLETE but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE GNU General Public License for more details. */
/* OBSOLETE  */
/* OBSOLETE You should have received a copy of the GNU General Public License along */
/* OBSOLETE with this program; if not, write to the Free Software Foundation, Inc., */
/* OBSOLETE 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */ */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE #ifndef _CPU_H_ */
/* OBSOLETE #define _CPU_H_ */
/* OBSOLETE  */
/* OBSOLETE enum { */
/* OBSOLETE   NR_GENERAL_PURPOSE_REGISTERS = 64, */
/* OBSOLETE   NR_CONTROL_REGISTERS = 64, */
/* OBSOLETE   NR_ACCUMULATORS = 2, */
/* OBSOLETE   STACK_POINTER_GPR = 63, */
/* OBSOLETE   NR_STACK_POINTERS = 2, */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE enum { */
/* OBSOLETE   processor_status_word_cr = 0, */
/* OBSOLETE   backup_processor_status_word_cr = 1, */
/* OBSOLETE   program_counter_cr = 2, */
/* OBSOLETE   backup_program_counter_cr = 3, */
/* OBSOLETE   debug_backup_processor_status_word_cr = 4, */
/* OBSOLETE   debug_backup_program_counter_cr = 5, */
/* OBSOLETE   reserved_6_cr = 6, */
/* OBSOLETE   repeat_count_cr = 7, */
/* OBSOLETE   repeat_start_address_cr = 8, */
/* OBSOLETE   repeat_end_address_cr = 9, */
/* OBSOLETE   modulo_start_address_cr = 10, */
/* OBSOLETE   modulo_end_address_cr = 11, */
/* OBSOLETE   instruction_break_address_cr = 14, */
/* OBSOLETE   eit_vector_base_cr = 15, */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE enum { */
/* OBSOLETE   PSW_SM = 0, */
/* OBSOLETE   PSW_EA = 2, */
/* OBSOLETE   PSW_DB = 3, */
/* OBSOLETE   PSW_DS = 4, */
/* OBSOLETE   PSW_IE = 5, */
/* OBSOLETE   PSW_RP = 6, */
/* OBSOLETE   PSW_MD = 7, */
/* OBSOLETE   PSW_F0 = 17, */
/* OBSOLETE   PSW_F1 = 19, */
/* OBSOLETE   PSW_F2 = 21, */
/* OBSOLETE   PSW_F3 = 23, */
/* OBSOLETE   PSW_S = 25, */
/* OBSOLETE   PSW_V = 27, */
/* OBSOLETE   PSW_VA = 29, */
/* OBSOLETE   PSW_C = 31, */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE /* aliases for PSW flag numbers (F0..F7) */ */
/* OBSOLETE enum */
/* OBSOLETE { */
/* OBSOLETE   PSW_S_FLAG = 4, */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE typedef struct _registers { */
/* OBSOLETE   unsigned32 general_purpose[NR_GENERAL_PURPOSE_REGISTERS]; */
/* OBSOLETE   /* keep track of the stack pointer */ */
/* OBSOLETE   unsigned32 sp[NR_STACK_POINTERS]; /* swap with SP */ */
/* OBSOLETE   unsigned32 current_sp; */
/* OBSOLETE   unsigned32 control[NR_CONTROL_REGISTERS]; */
/* OBSOLETE   unsigned64 accumulator[NR_ACCUMULATORS]; */
/* OBSOLETE } registers; */
/* OBSOLETE  */
/* OBSOLETE typedef enum _cpu_units { */
/* OBSOLETE   memory_unit, */
/* OBSOLETE   integer_unit, */
/* OBSOLETE   any_unit, */
/* OBSOLETE } cpu_units; */
/* OBSOLETE  */
/* OBSOLETE /* In order to support parallel instructions, which one instruction can be */
/* OBSOLETE    writing to a register that is used as input to another, queue up the */
/* OBSOLETE    writes to the end of the instruction boundaries.  */ */
/* OBSOLETE  */
/* OBSOLETE #define MAX_WRITE32	16 */
/* OBSOLETE #define MAX_WRITE64	2 */
/* OBSOLETE  */
/* OBSOLETE struct _write32 { */
/* OBSOLETE   int num;				/* # of 32-bit writes queued up */ */
/* OBSOLETE   unsigned32 value[MAX_WRITE32];	/* value to write */ */
/* OBSOLETE   unsigned32 mask[MAX_WRITE32];		/* mask to use */ */
/* OBSOLETE   unsigned32 *ptr[MAX_WRITE32];		/* address to write to */ */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE struct _write64 { */
/* OBSOLETE   int num;				/* # of 64-bit writes queued up */ */
/* OBSOLETE   unsigned64 value[MAX_WRITE64];	/* value to write */ */
/* OBSOLETE   unsigned64 *ptr[MAX_WRITE64];		/* address to write to */ */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE struct _sim_cpu { */
/* OBSOLETE   cpu_units unit; */
/* OBSOLETE   registers regs; */
/* OBSOLETE   sim_cpu_base base; */
/* OBSOLETE   int trace_call_p;			/* Whether to do call tracing.  */ */
/* OBSOLETE   int trace_trap_p;			/* If unknown traps dump out the regs */ */
/* OBSOLETE   int trace_action;			/* trace bits at end of instructions */ */
/* OBSOLETE   int left_kills_right_p;               /* left insn kills insn in right slot of -> */ */
/* OBSOLETE   int mvtsys_left_p;			/* left insn was mvtsys */ */
/* OBSOLETE   int did_trap;				/* we did a trap & need to finish it */ */
/* OBSOLETE   struct _write32 write32;		/* queued up 32-bit writes */ */
/* OBSOLETE   struct _write64 write64;		/* queued up 64-bit writes */ */
/* OBSOLETE }; */
/* OBSOLETE  */
/* OBSOLETE #define PC	(STATE_CPU (sd, 0)->regs.control[program_counter_cr]) */
/* OBSOLETE #define PSW 	(STATE_CPU (sd, 0)->regs.control[processor_status_word_cr]) */
/* OBSOLETE #define PSWL    (*AL2_4(&PSW)) */
/* OBSOLETE #define PSWH    (*AH2_4(&PSW)) */
/* OBSOLETE #define DPSW 	(STATE_CPU (sd, 0)->regs.control[debug_backup_processor_status_word_cr]) */
/* OBSOLETE #define DPC 	(STATE_CPU (sd, 0)->regs.control[debug_backup_program_counter_cr]) */
/* OBSOLETE #define bPC 	(STATE_CPU (sd, 0)->regs.control[backup_program_counter_cr]) */
/* OBSOLETE #define bPSW 	(STATE_CPU (sd, 0)->regs.control[backup_processor_status_word_cr]) */
/* OBSOLETE #define RPT_C 	(STATE_CPU (sd, 0)->regs.control[repeat_count_cr]) */
/* OBSOLETE #define RPT_S 	(STATE_CPU (sd, 0)->regs.control[repeat_start_address_cr]) */
/* OBSOLETE #define RPT_E 	(STATE_CPU (sd, 0)->regs.control[repeat_end_address_cr]) */
/* OBSOLETE #define MOD_S 	(STATE_CPU (sd, 0)->regs.control[modulo_start_address_cr]) */
/* OBSOLETE #define MOD_E 	(STATE_CPU (sd, 0)->regs.control[modulo_end_address_cr]) */
/* OBSOLETE #define IBA 	(STATE_CPU (sd, 0)->regs.control[instruction_break_address_cr]) */
/* OBSOLETE #define EIT_VB	(STATE_CPU (sd, 0)->regs.control[eit_vector_base_cr]) */
/* OBSOLETE #define GPR	(STATE_CPU (sd, 0)->regs.general_purpose) */
/* OBSOLETE #define GPR_CLEAR(N) (GPR[(N)] = 0) */
/* OBSOLETE #define ACC	(STATE_CPU (sd, 0)->regs.accumulator) */
/* OBSOLETE #define CREG	(STATE_CPU (sd, 0)->regs.control) */
/* OBSOLETE #define SP      (GPR[STACK_POINTER_GPR]) */
/* OBSOLETE #define TRACE_CALL_P (STATE_CPU (sd, 0)->trace_call_p) */
/* OBSOLETE #define TRACE_TRAP_P (STATE_CPU (sd, 0)->trace_trap_p) */
/* OBSOLETE #define TRACE_ACTION (STATE_CPU (sd, 0)->trace_action) */
/* OBSOLETE #define     TRACE_ACTION_CALL	0x00000001	/* call occurred */ */
/* OBSOLETE #define     TRACE_ACTION_RETURN	0x00000002	/* return occurred */ */
/* OBSOLETE  */
/* OBSOLETE #define WRITE32 (STATE_CPU (sd, 0)->write32) */
/* OBSOLETE #define WRITE32_NUM	 (WRITE32.num) */
/* OBSOLETE #define WRITE32_PTR(N)	 (WRITE32.ptr[N]) */
/* OBSOLETE #define WRITE32_MASK(N)	 (WRITE32.mask[N]) */
/* OBSOLETE #define WRITE32_VALUE(N) (WRITE32.value[N]) */
/* OBSOLETE #define WRITE32_QUEUE(PTR, VALUE) WRITE32_QUEUE_MASK (PTR, VALUE, 0xffffffff) */
/* OBSOLETE  */
/* OBSOLETE #define WRITE32_QUEUE_MASK(PTR, VALUE, MASK)				\ */
/* OBSOLETE do {									\ */
/* OBSOLETE   int _num = WRITE32_NUM;						\ */
/* OBSOLETE   if (_num >= MAX_WRITE32)						\ */
/* OBSOLETE     sim_engine_abort (sd, STATE_CPU (sd, 0), cia,			\ */
/* OBSOLETE 		      "Too many queued 32-bit writes");			\ */
/* OBSOLETE   WRITE32_PTR(_num) = PTR;						\ */
/* OBSOLETE   WRITE32_VALUE(_num) = VALUE;						\ */
/* OBSOLETE   WRITE32_MASK(_num) = MASK;						\ */
/* OBSOLETE   WRITE32_NUM = _num+1;							\ */
/* OBSOLETE } while (0) */
/* OBSOLETE  */
/* OBSOLETE #define DID_TRAP	(STATE_CPU (sd, 0)->did_trap) */
/* OBSOLETE  */
/* OBSOLETE #define WRITE64 (STATE_CPU (sd, 0)->write64) */
/* OBSOLETE #define WRITE64_NUM	 (WRITE64.num) */
/* OBSOLETE #define WRITE64_PTR(N)	 (WRITE64.ptr[N]) */
/* OBSOLETE #define WRITE64_VALUE(N) (WRITE64.value[N]) */
/* OBSOLETE #define WRITE64_QUEUE(PTR, VALUE)					\ */
/* OBSOLETE do {									\ */
/* OBSOLETE   int _num = WRITE64_NUM;						\ */
/* OBSOLETE   if (_num >= MAX_WRITE64)						\ */
/* OBSOLETE     sim_engine_abort (sd, STATE_CPU (sd, 0), cia,			\ */
/* OBSOLETE 		      "Too many queued 64-bit writes");			\ */
/* OBSOLETE   WRITE64_PTR(_num) = PTR;						\ */
/* OBSOLETE   WRITE64_VALUE(_num) = VALUE;						\ */
/* OBSOLETE   WRITE64_NUM = _num+1;							\ */
/* OBSOLETE } while (0) */
/* OBSOLETE  */
/* OBSOLETE #define DPSW_VALID	0xbf005555 */
/* OBSOLETE #define PSW_VALID	0xb7005555 */
/* OBSOLETE #define EIT_VALID	0xfffff000	/* From page 7-4 of D30V/MPEG arch. manual  */ */
/* OBSOLETE #define EIT_VB_DEFAULT	0xfffff000	/* Value of the EIT_VB register after reset */ */
/* OBSOLETE  */
/* OBSOLETE /* Verify that the instruction is in the correct slot */ */
/* OBSOLETE  */
/* OBSOLETE #define IS_WRONG_SLOT is_wrong_slot(sd, cia, MY_INDEX) */
/* OBSOLETE extern int is_wrong_slot */
/* OBSOLETE (SIM_DESC sd, */
/* OBSOLETE  address_word cia, */
/* OBSOLETE  itable_index index); */
/* OBSOLETE  */
/* OBSOLETE #define IS_CONDITION_OK is_condition_ok(sd, cia, CCC) */
/* OBSOLETE extern int is_condition_ok */
/* OBSOLETE (SIM_DESC sd, */
/* OBSOLETE  address_word cia, */
/* OBSOLETE  int cond); */
/* OBSOLETE  */
/* OBSOLETE #define SIM_HAVE_BREAKPOINTS	/* Turn on internal breakpoint module */ */
/* OBSOLETE  */
/* OBSOLETE /* Internal breakpoint instruction is syscall 5 */ */
/* OBSOLETE #define SIM_BREAKPOINT {0x0e, 0x00, 0x00, 0x05} */
/* OBSOLETE #define SIM_BREAKPOINT_SIZE (4) */
/* OBSOLETE  */
/* OBSOLETE /* Call occurred */ */
/* OBSOLETE extern void call_occurred */
/* OBSOLETE (SIM_DESC sd, */
/* OBSOLETE  sim_cpu *cpu, */
/* OBSOLETE  address_word cia, */
/* OBSOLETE  address_word nia); */
/* OBSOLETE  */
/* OBSOLETE /* Return occurred */ */
/* OBSOLETE extern void return_occurred */
/* OBSOLETE (SIM_DESC sd, */
/* OBSOLETE  sim_cpu *cpu, */
/* OBSOLETE  address_word cia, */
/* OBSOLETE  address_word nia); */
/* OBSOLETE  */
/* OBSOLETE /* Whether to do call tracing.  */ */
/* OBSOLETE extern int d30v_call_trace_p; */
/* OBSOLETE  */
/* OBSOLETE /* Read/write functions for system call interface.  */ */
/* OBSOLETE extern int d30v_read_mem */
/* OBSOLETE (host_callback *cb, */
/* OBSOLETE  struct cb_syscall *sc, */
/* OBSOLETE  unsigned long taddr, */
/* OBSOLETE  char *buf, */
/* OBSOLETE  int bytes); */
/* OBSOLETE  */
/* OBSOLETE extern int d30v_write_mem */
/* OBSOLETE (host_callback *cb, */
/* OBSOLETE  struct cb_syscall *sc, */
/* OBSOLETE  unsigned long taddr, */
/* OBSOLETE  const char *buf, */
/* OBSOLETE  int bytes); */
/* OBSOLETE  */
/* OBSOLETE /* Process all of the queued up writes in order now */ */
/* OBSOLETE void unqueue_writes */
/* OBSOLETE (SIM_DESC sd, */
/* OBSOLETE  sim_cpu *cpu, */
/* OBSOLETE  address_word cia); */
/* OBSOLETE  */
/* OBSOLETE #endif /* _CPU_H_ */ */
@


1.1
log
@Initial revision
@
text
@d118 1
d140 1
a140 1
#define GPR_SET(N,VAL) (GPR[(N)] = (VAL))
d242 6
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a117 1
  int mvtsys_left_p;			/* left insn was mvtsys */
@


1.1.1.3
log
@import gdb-1999-09-08 snapshot
@
text
@a242 6
/* Process all of the queued up writes in order now */
void unqueue_writes
(SIM_DESC sd,
 sim_cpu *cpu,
 address_word cia);

@


