head	1.4;
access;
symbols
	gdb_6_3-20041109-release:1.3
	gdb_6_3-branch:1.3.0.66
	gdb_6_3-20041019-branchpoint:1.3
	drow_intercu-merge-20040921:1.3
	drow_intercu-merge-20040915:1.3
	jimb-gdb_6_2-e500-branch:1.3.0.68
	jimb-gdb_6_2-e500-branchpoint:1.3
	gdb_6_2-20040730-release:1.3
	gdb_6_2-branch:1.3.0.64
	gdb_6_2-2004-07-10-gmt-branchpoint:1.3
	gdb_6_1_1-20040616-release:1.3
	gdb_6_1-2004-04-05-release:1.3
	drow_intercu-merge-20040402:1.3
	drow_intercu-merge-20040327:1.3
	ezannoni_pie-20040323-branch:1.3.0.62
	ezannoni_pie-20040323-branchpoint:1.3
	cagney_tramp-20040321-mergepoint:1.3
	cagney_tramp-20040309-branch:1.3.0.60
	cagney_tramp-20040309-branchpoint:1.3
	gdb_6_1-branch:1.3.0.58
	gdb_6_1-2004-03-01-gmt-branchpoint:1.3
	drow_intercu-20040221-branch:1.3.0.56
	drow_intercu-20040221-branchpoint:1.3
	cagney_bfdfile-20040213-branch:1.3.0.54
	cagney_bfdfile-20040213-branchpoint:1.3
	drow-cplus-merge-20040208:1.3
	carlton_dictionary-20040126-merge:1.3
	cagney_bigcore-20040122-branch:1.3.0.52
	cagney_bigcore-20040122-branchpoint:1.3
	drow-cplus-merge-20040113:1.3
	drow-cplus-merge-20031224:1.3
	drow-cplus-merge-20031220:1.3
	carlton_dictionary-20031215-merge:1.3
	drow-cplus-merge-20031214:1.3
	carlton-dictionary-20031111-merge:1.3
	gdb_6_0-2003-10-04-release:1.3
	kettenis_sparc-20030918-branch:1.3.0.50
	kettenis_sparc-20030918-branchpoint:1.3
	carlton_dictionary-20030917-merge:1.3
	ezannoni_pie-20030916-branchpoint:1.3
	ezannoni_pie-20030916-branch:1.3.0.48
	cagney_x86i386-20030821-branch:1.3.0.46
	cagney_x86i386-20030821-branchpoint:1.3
	carlton_dictionary-20030805-merge:1.3
	carlton_dictionary-20030627-merge:1.3
	gdb_6_0-branch:1.3.0.44
	gdb_6_0-2003-06-23-branchpoint:1.3
	jimb-ppc64-linux-20030613-branch:1.3.0.42
	jimb-ppc64-linux-20030613-branchpoint:1.3
	cagney_convert-20030606-branch:1.3.0.40
	cagney_convert-20030606-branchpoint:1.3
	cagney_writestrings-20030508-branch:1.3.0.38
	cagney_writestrings-20030508-branchpoint:1.3
	jimb-ppc64-linux-20030528-branch:1.3.0.36
	jimb-ppc64-linux-20030528-branchpoint:1.3
	carlton_dictionary-20030523-merge:1.3
	cagney_fileio-20030521-branch:1.3.0.34
	cagney_fileio-20030521-branchpoint:1.3
	kettenis_i386newframe-20030517-mergepoint:1.3
	jimb-ppc64-linux-20030509-branch:1.3.0.32
	jimb-ppc64-linux-20030509-branchpoint:1.3
	kettenis_i386newframe-20030504-mergepoint:1.3
	carlton_dictionary-20030430-merge:1.3
	kettenis_i386newframe-20030419-branch:1.3.0.30
	kettenis_i386newframe-20030419-branchpoint:1.3
	carlton_dictionary-20030416-merge:1.3
	cagney_frameaddr-20030409-mergepoint:1.3
	kettenis_i386newframe-20030406-branch:1.3.0.28
	kettenis_i386newframe-20030406-branchpoint:1.3
	cagney_frameaddr-20030403-branchpoint:1.3
	cagney_frameaddr-20030403-branch:1.3.0.26
	cagney_framebase-20030330-mergepoint:1.3
	cagney_framebase-20030326-branch:1.3.0.24
	cagney_framebase-20030326-branchpoint:1.3
	cagney_lazyid-20030317-branch:1.3.0.22
	cagney_lazyid-20030317-branchpoint:1.3
	kettenis-i386newframe-20030316-mergepoint:1.3
	offbyone-20030313-branch:1.3.0.20
	offbyone-20030313-branchpoint:1.3
	kettenis-i386newframe-20030308-branch:1.3.0.18
	kettenis-i386newframe-20030308-branchpoint:1.3
	carlton_dictionary-20030305-merge:1.3
	cagney_offbyone-20030303-branch:1.3.0.16
	cagney_offbyone-20030303-branchpoint:1.3
	carlton_dictionary-20030207-merge:1.3
	interps-20030202-branch:1.3.0.14
	interps-20030202-branchpoint:1.3
	cagney-unwind-20030108-branch:1.3.0.12
	cagney-unwind-20030108-branchpoint:1.3
	carlton_dictionary-20021223-merge:1.3
	gdb_5_3-2002-12-12-release:1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.10
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	carlton_dictionary-branch:1.3.0.8
	carlton_dictionary-20020920-branchpoint:1.3
	gdb_5_3-branch:1.3.0.6
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.4
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.2
	readline_4_3-import-branchpoint:1.3
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.14
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.12
	cagney_regbuf-20020515-branchpoint:1.2
	jimb-macro-020506-branch:1.2.0.10
	jimb-macro-020506-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.8
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.2
	gdb_5_1_0_1-2002-01-03-release:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.4
	gdb_s390-2001-09-26-branchpoint:1.2
	gdb_5_1-2001-07-29-branch:1.2.0.2
	gdb_5_1-2001-07-29-branchpoint:1.2
	insight-precleanup-2001-01-01:1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.4.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.4
	gdb_5_0-2000-05-19-release:1.1.1.4
	gdb_4_18_2-2000-05-18-release:1.1.1.4
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.4
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.4
	gdb_5_0-2000-04-10-branch:1.1.1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.4
	repo-unification-2000-02-06:1.1.1.4
	gdb-2000-02-04:1.1.1.4
	gdb-2000-02-02:1.1.1.4
	gdb-2000-02-01:1.1.1.4
	gdb-2000-01-31:1.1.1.4
	gdb-2000-01-26:1.1.1.4
	gdb-2000-01-24:1.1.1.4
	gdb-2000-01-17:1.1.1.4
	gdb-2000-01-10:1.1.1.4
	gdb-2000-01-05:1.1.1.4
	gdb-1999-12-21:1.1.1.4
	gdb-1999-12-13:1.1.1.4
	gdb-1999-12-07:1.1.1.4
	gdb-1999-12-06:1.1.1.4
	gdb-1999-11-16:1.1.1.4
	gdb-1999-11-08:1.1.1.4
	gdb-1999-11-01:1.1.1.4
	gdb-1999-10-25:1.1.1.4
	gdb-1999-10-18:1.1.1.4
	gdb-1999-10-11:1.1.1.4
	gdb-1999-10-04:1.1.1.4
	gdb-1999-09-28:1.1.1.4
	gdb-1999-09-21:1.1.1.4
	gdb-1999-09-13:1.1.1.4
	gdb-1999-09-08:1.1.1.4
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.3
	gdb-1999-06-28:1.1.1.3
	gdb-1999-06-21:1.1.1.3
	gdb-1999-06-14:1.1.1.3
	gdb-1999-06-07:1.1.1.3
	gdb-1999-06-01:1.1.1.3
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.4
date	2004.11.12.16.45.19;	author cagney;	state dead;
branches;
next	1.3;

1.3
date	2002.07.14.00.15.20;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.05.21.40.11;	author nickc;	state Exp;
branches
	1.2.14.1;
next	1.1;

1.1
date	99.04.16.01.35.00;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.35.00;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.31.53;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.06.01.15.44.41;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.09.09.00.01.44;	author shebs;	state Exp;
branches;
next	;

1.2.14.1
date	2002.07.22.21.47.24;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.4
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* d30v, fr30, mn10200, z8k: Delete directory.
@
text
@# OBSOLETE //  -*- C -*-
# OBSOLETE //  Mitsubishi Electric Corp. D30V Simulator.
# OBSOLETE //  Copyright (C) 1997, Free Software Foundation, Inc.
# OBSOLETE //  Contributed by Cygnus Solutions Inc.
# OBSOLETE //
# OBSOLETE //  This file is part of GDB, the GNU debugger.
# OBSOLETE //
# OBSOLETE //  This program is free software; you can redistribute it and/or modify
# OBSOLETE //  it under the terms of the GNU General Public License as published by
# OBSOLETE //  the Free Software Foundation; either version 2 of the License, or
# OBSOLETE //  (at your option) any later version.
# OBSOLETE //
# OBSOLETE //  This program is distributed in the hope that it will be useful,
# OBSOLETE //  but WITHOUT ANY WARRANTY; without even the implied warranty of
# OBSOLETE //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# OBSOLETE //  GNU General Public License for more details.
# OBSOLETE //
# OBSOLETE //  You should have received a copy of the GNU General Public License
# OBSOLETE //  along with this program; if not, write to the Free Software
# OBSOLETE //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# OBSOLETE //
# OBSOLETE 
# OBSOLETE 
# OBSOLETE define( _BRA,  `1.*,CCC,000')
# OBSOLETE define( _LOGIC, `1.*,CCC,001')
# OBSOLETE define( _IMEM, `1.*,CCC,010')
# OBSOLETE define( _IALU1, `1.*,CCC,100')
# OBSOLETE define(_IALU2, `1.*,CCC,101')
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE define(_IMM6, `6.IMM_6S')
# OBSOLETE define(_IMM12, `12.IMM_12S')
# OBSOLETE define(_IMM18, `18.IMM_18S')
# OBSOLETE define(_IMM32, `6.IMM_6L,*,000,8.IMM_8L,00,18.IMM_18L')
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // The following is called when ever an illegal instruction is
# OBSOLETE // encountered
# OBSOLETE ::internal::illegal
# OBSOLETE 	sim_io_eprintf (sd, "illegal instruction at 0x%lx\n", (long) cia);
# OBSOLETE 	sim_engine_halt (SD, CPU, NULL, cia, sim_signalled, SIM_SIGILL);
# OBSOLETE 
# OBSOLETE // The following is called when ever an instruction in the wrong
# OBSOLETE // slot is encountered.
# OBSOLETE ::internal::wrong_slot
# OBSOLETE 	sim_io_eprintf (sd, "wrong slot at 0x%lx\n", (long) cia);
# OBSOLETE 	sim_engine_halt (SD, CPU, NULL, cia, sim_signalled, SIM_SIGILL);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // Something illegal that can be used to contact the simulator emul
# OBSOLETE // library.
# OBSOLETE define(_EMUL, `1.*,CCC,111')
# OBSOLETE 
# OBSOLETE void::function::do_emul:int imm
# OBSOLETE 	/* temp hack - later replace with real interface */
# OBSOLETE 	enum {
# OBSOLETE 	  param1 = 2, param2, param3, param4
# OBSOLETE 	};
# OBSOLETE 	switch (imm) {
# OBSOLETE 	case 0:
# OBSOLETE 	  {
# OBSOLETE 	    sim_engine_abort (SD, CPU, cia, "UNIX call emulation unsupported");
# OBSOLETE 	    break;
# OBSOLETE 	  }
# OBSOLETE 	case 1:
# OBSOLETE 	  /* Trap 1 - prints a string */
# OBSOLETE 	  {
# OBSOLETE 	    address_word str = GPR[param1];
# OBSOLETE 	    char chr;
# OBSOLETE 	    while (1) {
# OBSOLETE 	      chr = MEM (unsigned, str, 1);
# OBSOLETE 	    if (chr == '\0') break;
# OBSOLETE 	      sim_io_write_stdout (sd, &chr, sizeof chr);
# OBSOLETE 	      str++;
# OBSOLETE 	    }
# OBSOLETE 	    break;
# OBSOLETE 	  }
# OBSOLETE 	case 3:
# OBSOLETE 	  /* Trap 3 - writes a character */
# OBSOLETE 	  {
# OBSOLETE 	    char chr = GPR[param1];
# OBSOLETE 	    sim_io_write_stdout (sd, &chr, sizeof chr);
# OBSOLETE 	    break;
# OBSOLETE 	  }
# OBSOLETE 	case 4:
# OBSOLETE 	  /* Trap 4 exits with status in [param1] */
# OBSOLETE 	  {
# OBSOLETE 	    sim_engine_halt (SD, CPU, NULL, cia, sim_exited, GPR[param1]);
# OBSOLETE 	    break;
# OBSOLETE 	  }
# OBSOLETE 	case 5:
# OBSOLETE 	  /* Trap 5 breakpoints.  If the breakpoint system knows about this, it
# OBSOLETE 	     won't return.  Otherwise, we fall through to treat this as an
# OBSOLETE 	     unknown instruction.  */
# OBSOLETE 	  {
# OBSOLETE 	    sim_handle_breakpoint (SD, CPU, cia);
# OBSOLETE 	  /* Fall through to default case.*/
# OBSOLETE 	  }
# OBSOLETE 	default:
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "Unknown monitor call %d", imm);
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _EMUL,00000,00,6.*,6.*,IMM_6S:EMUL:short,emul:iu,mu:EMUL
# OBSOLETE "syscall <imm>"
# OBSOLETE 	do_emul (_SD, imm);
# OBSOLETE _BRA,00000,00,6.**,6.**,_IMM32:BRA:long:iu,mu:EMUL long
# OBSOLETE "syscall <imm>"
# OBSOLETE 	do_emul (_SD, imm);
# OBSOLETE 
# OBSOLETE // ABS
# OBSOLETE 
# OBSOLETE _IALU1,01000,00,6.RA,6.RB,6.**:IALU1:short:iu,mu:ABS
# OBSOLETE "abs r<RA>, r<RB>"
# OBSOLETE 	WRITE32_QUEUE (Ra, abs(Rb));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ADD
# OBSOLETE 
# OBSOLETE void::function::do_add:unsigned32 *ra, unsigned32 rb, unsigned32 imm
# OBSOLETE 	ALU_BEGIN(rb);
# OBSOLETE 	ALU_ADDC(imm);
# OBSOLETE 	ALU_END(ra);
# OBSOLETE 
# OBSOLETE _IALU1,00000,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:ADD
# OBSOLETE "add r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_add (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,00000,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:ADD imm
# OBSOLETE "add r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_add (_SD, Ra, Rb, imm);
# OBSOLETE _IALU1,00000,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:ADD imm long
# OBSOLETE "add r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_add (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ADD2H
# OBSOLETE 
# OBSOLETE void::function::do_add2h:signed32 *ra, signed32 rb, signed32 imm
# OBSOLETE 	unsigned16 ah2 = VH2_4(rb) + VH2_4(imm);
# OBSOLETE 	unsigned16 al2 = VL2_4(rb) + VL2_4(imm);
# OBSOLETE 	WRITE32_QUEUE (ra, (ah2 << 16) | al2);
# OBSOLETE 
# OBSOLETE _IALU1,00001,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:ADD2H
# OBSOLETE "add2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_add2h (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,00001,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:ADD2H imm
# OBSOLETE "add2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_add2h (_SD, Ra, Rb, immHL);
# OBSOLETE _IALU1,00001,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:ADD2H imm long
# OBSOLETE "add2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_add2h (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ADDC
# OBSOLETE 
# OBSOLETE void::function::do_addc:unsigned32 *ra, unsigned32 rb, unsigned32 imm
# OBSOLETE 	ALU_BEGIN(rb);
# OBSOLETE 	ALU_ADDC_C(imm, ALU_CARRY);
# OBSOLETE 	ALU_END(ra);
# OBSOLETE 
# OBSOLETE _IALU1,00100,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:ADDC
# OBSOLETE "addc r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_addc (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,00100,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:ADDC imm
# OBSOLETE "addc r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_addc (_SD, Ra, Rb, imm);
# OBSOLETE _IALU1,00100,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:ADDC imm long
# OBSOLETE "addc r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_addc (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ADDHppp
# OBSOLETE 
# OBSOLETE void::function::do_addh_ppp:int ppp, unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	switch (ppp) {
# OBSOLETE 	case 0x0: /* LLL */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VL2_4(rb));
# OBSOLETE 	  ALU16_ADDC(VL2_4(src));
# OBSOLETE 	  ALU16_END(ra, 0);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x1: /* LLH */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VL2_4(rb));
# OBSOLETE 	  ALU16_ADDC(VH2_4(src));
# OBSOLETE 	  ALU16_END(ra, 0);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x2: /* LHL */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VH2_4(rb));
# OBSOLETE 	  ALU16_ADDC(VL2_4(src));
# OBSOLETE 	  ALU16_END(ra, 0);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x3: /* LHH */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VH2_4(rb));
# OBSOLETE 	  ALU16_ADDC(VH2_4(src));
# OBSOLETE 	  ALU16_END(ra, 0);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x4: /* HLL */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VL2_4(rb));
# OBSOLETE 	  ALU16_ADDC(VL2_4(src));
# OBSOLETE 	  ALU16_END(ra, 1);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x5: /* HLH */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VL2_4(rb));
# OBSOLETE 	  ALU16_ADDC(VH2_4(src));
# OBSOLETE 	  ALU16_END(ra, 1);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x6: /* HHL */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VH2_4(rb));
# OBSOLETE 	  ALU16_ADDC(VL2_4(src));
# OBSOLETE 	  ALU16_END(ra, 1);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x7: /* HHH */
# OBSOLETE 	  {	
# OBSOLETE 	  ALU16_BEGIN(VH2_4(rb));
# OBSOLETE 	  ALU16_ADDC(VH2_4(src));
# OBSOLETE 	  ALU16_END(ra, 1);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	default:
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "do_addh_ppp - internal error - bad switch");
# OBSOLETE 	}
# OBSOLETE ::%s::ppp:int ppp
# OBSOLETE 	switch (ppp)
# OBSOLETE 	  {
# OBSOLETE 	  case 0x0: return "lll";
# OBSOLETE 	  case 0x1: return "llh";
# OBSOLETE 	  case 0x2: return "lhl";
# OBSOLETE 	  case 0x3: return "lhh";
# OBSOLETE 	  case 0x4: return "hll";
# OBSOLETE 	  case 0x5: return "hlh";
# OBSOLETE 	  case 0x6: return "hhl";
# OBSOLETE 	  case 0x7: return "hhh";
# OBSOLETE 	  default: return "?";
# OBSOLETE 	  }
# OBSOLETE 
# OBSOLETE _IALU1,10,ppp,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:ADDHppp
# OBSOLETE "addh%s<ppp> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_addh_ppp(_SD, ppp, Ra, Rb, Rc);
# OBSOLETE _IALU1,10,ppp,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:ADDHppp imm
# OBSOLETE "addh%s<ppp> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_addh_ppp(_SD, ppp, Ra, Rb, immHL);
# OBSOLETE _IALU1,10,ppp,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:ADDHppp imm long
# OBSOLETE "addh%s<ppp> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_addh_ppp(_SD, ppp, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ADDS
# OBSOLETE 
# OBSOLETE void::function::do_adds:unsigned32 *ra, unsigned32 rb, unsigned32 imm
# OBSOLETE 	ALU_BEGIN(rb);
# OBSOLETE 	ALU_ADDC(EXTRACTED32(imm, 0, 0));
# OBSOLETE 	ALU_END(ra);
# OBSOLETE 
# OBSOLETE _IALU1,00110,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:ADDS
# OBSOLETE "adds r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_adds (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,00110,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:ADDS imm
# OBSOLETE "adds r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_adds (_SD, Ra, Rb, imm);
# OBSOLETE _IALU1,00110,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:ADDS imm long
# OBSOLETE "adds r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_adds (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ADDS2H
# OBSOLETE 
# OBSOLETE void::function::do_adds2h:unsigned32 *ra, unsigned32 rb, unsigned32 immHL
# OBSOLETE 	unsigned16 high = VH2_4(rb) + EXTRACTED32(immHL, 0, 0);
# OBSOLETE 	unsigned16 low = VL2_4(rb) + EXTRACTED32(immHL, 16, 16);
# OBSOLETE 	WRITE32_QUEUE (ra, (high << 16) | low);
# OBSOLETE 
# OBSOLETE _IALU1,00111,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:ADDS2H
# OBSOLETE "adds2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_adds2h (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,00111,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:ADDS2H imm
# OBSOLETE "adds2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_adds2h (_SD, Ra, Rb, immHL);
# OBSOLETE _IALU1,00111,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:ADDS2H imm long
# OBSOLETE "adds2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_adds2h (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // AND
# OBSOLETE 
# OBSOLETE _LOGIC,11000,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:AND
# OBSOLETE "and r<RA>, r<RB>, r<RC>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb & Rc);
# OBSOLETE _LOGIC,11000,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:AND imm
# OBSOLETE "and r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb & imm);
# OBSOLETE _LOGIC,11000,10,6.RA,6.RB,_IMM32:LOGIC:long:iu,mu:AND imm long
# OBSOLETE "and r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb & imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ANDFG
# OBSOLETE 
# OBSOLETE _LOGIC,01000,00,***,3.FA,***,3.FB,***,3.FC:LOGIC:short:iu,mu:Logical AND Flags
# OBSOLETE "andfg f<FA>, f<FB>, f<FC>"
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, PSW_FLAG_VAL(FB) & PSW_FLAG_VAL(FC));
# OBSOLETE _LOGIC,01000,10,***,3.FA,***,3.FB,_IMM6:LOGIC:short:iu,mu:Logical AND Flags imm
# OBSOLETE "andfg f<FA>, f<FB>, <imm_6>"
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, PSW_FLAG_VAL(FB) & (imm_6 & 1));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // AVG
# OBSOLETE 
# OBSOLETE void::function::do_avg:unsigned32 *ra, unsigned32 rb, unsigned32 imm
# OBSOLETE 	WRITE32_QUEUE (ra, ((signed64)(signed32)rb + (signed64)(signed32)imm + 1) >> 1);
# OBSOLETE 
# OBSOLETE _IALU1,01010,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:AVG
# OBSOLETE "avg r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_avg (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,01010,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:AVG imm
# OBSOLETE "avg r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_avg (_SD, Ra, Rb, imm);
# OBSOLETE _IALU1,01010,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:AVG imm long
# OBSOLETE "avg r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_avg (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // AVG2H
# OBSOLETE 
# OBSOLETE void::function::do_avg2h:unsigned32 *ra, unsigned32 rb, unsigned32 imm
# OBSOLETE 	unsigned16 high = ((signed32)(signed16)VH2_4(rb) + (signed32)(signed16)VH2_4(imm) + 1) >> 1;
# OBSOLETE 	unsigned16 low  = ((signed32)(signed16)VL2_4(rb) + (signed32)(signed16)VL2_4(imm) + 1) >> 1;
# OBSOLETE 	WRITE32_QUEUE (ra, (high << 16) | low);
# OBSOLETE 
# OBSOLETE _IALU1,01011,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:AVG2H
# OBSOLETE "avg2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_avg2h (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,01011,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:AVG2H imm
# OBSOLETE "avg2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_avg2h (_SD, Ra, Rb, immHL);
# OBSOLETE _IALU1,01011,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:AVG2H imm long
# OBSOLETE "avg2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_avg2h (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BCLR
# OBSOLETE 
# OBSOLETE _LOGIC,00011,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:BCLR
# OBSOLETE "bclr r<RA>, r<RB>, r<RC>"
# OBSOLETE 	WRITE32_QUEUE(Ra, Rb & ~BIT32((Rc) % 32));
# OBSOLETE _LOGIC,00011,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:BCLR imm
# OBSOLETE "bclr r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE(Ra, Rb & ~BIT32((imm) % 32));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BNOT
# OBSOLETE 
# OBSOLETE _LOGIC,00001,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:BNOT
# OBSOLETE "bnot r<RA>, r<RB>, r<RC>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb ^ BIT32((Rc) % 32));
# OBSOLETE _LOGIC,00001,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:BNOT imm
# OBSOLETE "bnot r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb ^ BIT32((imm) % 32));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BRA
# OBSOLETE 
# OBSOLETE _BRA,00000,00,6.**,6.**,6.RC:BRA:short:mu:BRA
# OBSOLETE "bra r<RC>"
# OBSOLETE 	nia = cia + pcdisp;
# OBSOLETE _BRA,00000,10,_IMM18:BRA:short:mu:BRA imm
# OBSOLETE "bra <pcdisp>"
# OBSOLETE 	nia = cia + pcdisp;
# OBSOLETE _BRA,00000,10,6.**,6.**,_IMM32:BRA:long:mu:BRA imm long
# OBSOLETE "bra <pcdisp>"
# OBSOLETE 	nia = cia + pcdisp;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BRATNZ
# OBSOLETE 
# OBSOLETE _BRA,00100,01,6.RA,6.**,6.RC:BRA:short:mu:BRATNZ
# OBSOLETE "bratnz r<RC>"
# OBSOLETE 	if (*Ra != 0)
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE _BRA,00100,11,6.RA,_IMM12:BRA:short:mu:BRATNZ imm
# OBSOLETE "bratnz <pcdisp>"
# OBSOLETE 	if (*Ra != 0)
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE _BRA,00100,11,6.RA,6.**,_IMM32:BRA:long:mu:BRATNZ imm long
# OBSOLETE "bratnz <pcdisp>"
# OBSOLETE 	if (*Ra != 0)
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BRATZR
# OBSOLETE 
# OBSOLETE _BRA,00100,00,6.RA,6.**,6.RC:BRA:short:mu:BRATZR
# OBSOLETE "bratzr r<RC>"
# OBSOLETE 	if (val_Ra == 0)
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE _BRA,00100,10,6.RA,_IMM12:BRA:short:mu:BRATZR imm
# OBSOLETE "bratzr <pcdisp>"
# OBSOLETE 	if (val_Ra == 0)
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE _BRA,00100,10,6.RA,6.**,_IMM32:BRA:long:mu:BRATZR imm long
# OBSOLETE "bratzr <pcdisp>"
# OBSOLETE 	if (val_Ra == 0)
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BSET
# OBSOLETE 
# OBSOLETE _LOGIC,00010,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:BSET
# OBSOLETE "bset r<RA>, r<RB>, r<RC>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb | BIT32((Rc) % 32));
# OBSOLETE _LOGIC,00010,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:BSET imm
# OBSOLETE "bset r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb | BIT32((imm) % 32));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BSR
# OBSOLETE 
# OBSOLETE _BRA,00010,00,6.**,6.**,6.RC:BRA:short:mu:BSR
# OBSOLETE "bsr r<RC>"
# OBSOLETE 	if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	nia = cia + pcdisp;
# OBSOLETE 	if (TRACE_CALL_P)
# OBSOLETE 	  TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE _BRA,00010,10,_IMM18:BRA:short:mu:BSR imm
# OBSOLETE "bsr <pcdisp>"
# OBSOLETE 	if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	nia = cia + pcdisp;
# OBSOLETE 	if (TRACE_CALL_P)
# OBSOLETE 	  TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE _BRA,00010,10,6.**,6.**,_IMM32:BRA:long:mu:BSR imm long
# OBSOLETE "bsr <pcdisp>"
# OBSOLETE 	if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	nia = cia + pcdisp;
# OBSOLETE 	if (TRACE_CALL_P)
# OBSOLETE 	  TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BSRTNZ
# OBSOLETE 
# OBSOLETE _BRA,00110,01,6.RA,6.**,6.RC:BRA:short:mu:BSRTNZ
# OBSOLETE "bsrtnz r<RC>"
# OBSOLETE 	if (val_Ra != 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _BRA,00110,11,6.RA,_IMM12:BRA:short:mu:BSRTNZ imm
# OBSOLETE "bsrtnz <pcdisp>"
# OBSOLETE 	if (val_Ra != 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _BRA,00110,11,6.RA,6.**,_IMM32:BRA:long:mu:BSRTNZ imm long
# OBSOLETE "bsrtnz <pcdisp>"
# OBSOLETE 	if (val_Ra != 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BSRTZR
# OBSOLETE 
# OBSOLETE _BRA,00110,00,6.RA,6.**,6.RC:BRA:short:mu:BSRTZR
# OBSOLETE "bsrtzr r<RC>"
# OBSOLETE 	if (val_Ra == 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _BRA,00110,10,6.RA,_IMM12:BRA:short:mu:BSRTZR imm
# OBSOLETE "bsrtzr <pcdisp>"
# OBSOLETE 	if (val_Ra == 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _BRA,00110,10,6.RA,6.**,_IMM32:BRA:long:mu:BSRTZR imm long
# OBSOLETE "bsrtzr <pcdisp>"
# OBSOLETE 	if (val_Ra == 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BTST
# OBSOLETE 
# OBSOLETE _LOGIC,00000,00,***,3.FA,6.RB,6.RC:LOGIC:short:iu,mu:BTST
# OBSOLETE "btst f<FA>, r<RB>, r<RC>"
# OBSOLETE 	int bit = (Rc) % 32;
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, MASKED32(Rb, bit, bit));
# OBSOLETE _LOGIC,00000,10,***,3.FA,6.RB,_IMM6:LOGIC:short:iu,mu:BTST imm
# OBSOLETE "btst f<FA>, r<RB>, <imm>"
# OBSOLETE 	int bit = imm % 32;
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, MASKED32(Rb, bit, bit));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // CMPcc
# OBSOLETE 
# OBSOLETE void::function::do_cmp_cc:int cc, int fa, signed32 rb, signed32 rc
# OBSOLETE 	int value = 0;
# OBSOLETE 	switch (cc) {
# OBSOLETE 	case 0: /* EQ */
# OBSOLETE 	  value = (rb == rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 1: /* NE */
# OBSOLETE 	  value = (rb != rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 2: /* GT */
# OBSOLETE 	  value = (rb > rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 3: /* GE */
# OBSOLETE 	  value = (rb >= rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 4: /* LT */
# OBSOLETE 	  value = (rb < rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 5: /* LE */
# OBSOLETE 	  value = (rb <= rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 6: /* PS */
# OBSOLETE 	  value = ((rb >= 0) && (rc >= 0));
# OBSOLETE 	  break;
# OBSOLETE 	case 7: /* NG */
# OBSOLETE 	  value = ((rb < 0) && (rc < 0));
# OBSOLETE 	  break;
# OBSOLETE 	default:
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "do_cmp_cc - internal error - bad switch (%d)", cc);
# OBSOLETE 	}
# OBSOLETE 	PSW_FLAG_SET_QUEUE(fa, value);
# OBSOLETE 
# OBSOLETE ::%s::ccc:int ccc
# OBSOLETE 	switch (ccc)
# OBSOLETE 	  {
# OBSOLETE 	  case 0: return "eq";
# OBSOLETE 	  case 1: return "ne";
# OBSOLETE 	  case 2: return "gt";
# OBSOLETE 	  case 3: return "ge";
# OBSOLETE 	  case 4: return "lt";
# OBSOLETE 	  case 5: return "le";
# OBSOLETE 	  case 6: return "ps";
# OBSOLETE 	  case 7: return "ng";
# OBSOLETE 	  default: return "?";
# OBSOLETE 	  }
# OBSOLETE 
# OBSOLETE _LOGIC,01100,00,ccc,3.FA,6.RB,6.RC:LOGIC:short:iu,mu:CMPcc
# OBSOLETE "cmp%s<ccc> f<FA>, r<RB>, r<RC>"
# OBSOLETE 	do_cmp_cc(_SD, ccc, FA, Rb, Rc);
# OBSOLETE _LOGIC,01100,10,ccc,3.FA,6.RB,_IMM6:LOGIC:short:iu,mu:CMPcc imm
# OBSOLETE "cmp%s<ccc> f<FA>, r<RB>, <imm>"
# OBSOLETE 	do_cmp_cc(_SD, ccc, FA, Rb, imm);
# OBSOLETE _LOGIC,01100,10,ccc,3.FA,6.RB,_IMM32:LOGIC:long:iu,mu:CMPcc imm long
# OBSOLETE "cmp%s<ccc> f<FA>, r<RB>, <imm>"
# OBSOLETE 	do_cmp_cc(_SD, ccc, FA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // CMPUcc
# OBSOLETE 
# OBSOLETE void::function::do_cmpu_cc:int cc, int fa, unsigned32 rb, unsigned32 rc
# OBSOLETE 	int value = 0;
# OBSOLETE 	switch (cc) {
# OBSOLETE 	case 2: /* GT */
# OBSOLETE 	  value = (rb > rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 3: /* GE */
# OBSOLETE 	  value = (rb >= rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 4: /* LT */
# OBSOLETE 	  value = (rb < rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 5: /* LE */
# OBSOLETE 	  value = (rb <= rc);
# OBSOLETE 	  break;
# OBSOLETE 	default:
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "do_cmpu_cc - internal error - bad switch (%d)", cc);
# OBSOLETE 	}
# OBSOLETE 	PSW_FLAG_SET_QUEUE(fa, value);
# OBSOLETE 
# OBSOLETE _LOGIC,01101,00,ccc,3.FA,6.RB,6.RC:LOGIC:short:iu,mu:CMPUcc
# OBSOLETE "cmpu%s<ccc> f<FA>, r<RB>, r<RC>"
# OBSOLETE 	do_cmpu_cc(_SD, ccc, FA, Rb, Rc);
# OBSOLETE _LOGIC,01101,10,ccc,3.FA,6.RB,_IMM6:LOGIC:short:iu,mu:CMPUcc imm
# OBSOLETE "cmpu%s<ccc> f<FA>, r<RB>, <imm>"
# OBSOLETE 	do_cmpu_cc(_SD, ccc, FA, Rb, imm_6u);
# OBSOLETE _LOGIC,01101,10,ccc,3.FA,6.RB,_IMM32:LOGIC:long:iu,mu:CMPUcc imm long
# OBSOLETE "cmpu%s<ccc> f<FA>, r<RB>, <imm>"
# OBSOLETE 	do_cmpu_cc(_SD, ccc, FA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // DBRA
# OBSOLETE 
# OBSOLETE void::function::do_dbra:address_word pcdisp, unsigned32 ra
# OBSOLETE 	PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, cia + pcdisp);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, cia + (ra & ~0x7));
# OBSOLETE 
# OBSOLETE _BRA,10000,00,6.RA,6.**,6.RC:BRA:short:mu:DBRA
# OBSOLETE "dbra r<RA>, r<RC>"
# OBSOLETE 	do_dbra(_SD, pcdisp, val_Ra);
# OBSOLETE _BRA,10000,10,6.RA,_IMM12:BRA:short:mu:DBRA imm
# OBSOLETE "dbra r<RA>, <pcdisp>"
# OBSOLETE 	do_dbra(_SD, pcdisp, val_Ra);
# OBSOLETE _BRA,10000,10,6.RA,6.**,_IMM32:BRA:long:mu:DBRA imm long
# OBSOLETE "dbra r<RA>, <pcdisp>"
# OBSOLETE 	do_dbra(_SD, pcdisp, val_Ra);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // DBRAI
# OBSOLETE 
# OBSOLETE void::function::do_dbrai:address_word pcdisp, unsigned32 imm
# OBSOLETE 	PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, cia + pcdisp);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, cia + (imm << 3));
# OBSOLETE 
# OBSOLETE _BRA,10100,00,6.IMM_6,6.**,6.RC:BRA:short:mu:DBRAI
# OBSOLETE "dbrai <IMM_6>, r<RC>"
# OBSOLETE 	do_dbrai(_SD, pcdisp, IMM_6);
# OBSOLETE _BRA,10100,10,6.IMM_6,_IMM12:BRA:short:mu:DBRAI imm
# OBSOLETE "dbrai <IMM_6>, <pcdisp>"
# OBSOLETE 	do_dbrai(_SD, pcdisp, IMM_6);
# OBSOLETE _BRA,10100,10,6.IMM_6,6.**,_IMM32:BRA:long:mu:DBRAI imm long
# OBSOLETE "dbrai <IMM_6>, <pcdisp>"
# OBSOLETE 	do_dbrai(_SD, pcdisp, IMM_6);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // DBSR
# OBSOLETE 
# OBSOLETE void::function::do_dbsr:address_word pcdisp, unsigned32 ra
# OBSOLETE 	PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, cia + pcdisp);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, cia + ra);
# OBSOLETE 	WRITE32_QUEUE (&GPR[62], cia + ra + 8);
# OBSOLETE 
# OBSOLETE _BRA,10010,00,6.RA,6.**,6.RC:BRA:short:mu:DBSR
# OBSOLETE "dbsr r<RA>, r<RC>"
# OBSOLETE 	do_dbsr(_SD, pcdisp, val_Ra);
# OBSOLETE _BRA,10010,10,6.RA,_IMM12:BRA:short:mu:DBSR imm
# OBSOLETE "dbsr r<RA>, <pcdisp>"
# OBSOLETE 	do_dbsr(_SD, pcdisp, val_Ra);
# OBSOLETE _BRA,10010,10,6.RA,6.**,_IMM32:BRA:long:mu:DBSR imm long
# OBSOLETE "dbsr r<RA>, <pcdisp>"
# OBSOLETE 	do_dbsr(_SD, pcdisp, val_Ra);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // DBSRI
# OBSOLETE 
# OBSOLETE void::function::do_dbsri:address_word pcdisp, unsigned32 imm
# OBSOLETE 	PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, cia + pcdisp);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, cia + (imm << 3));
# OBSOLETE 	WRITE32_QUEUE (&GPR[62], cia + (imm << 3) + 8);
# OBSOLETE 
# OBSOLETE _BRA,10110,00,6.IMM_6,6.**,6.RC:BRA:short:mu:DBSRI
# OBSOLETE "dbsri <IMM_6>, r<RC>"
# OBSOLETE 	do_dbsri(_SD, pcdisp, IMM_6);
# OBSOLETE _BRA,10110,10,6.IMM_6,_IMM12:BRA:short:mu:DBSRI imm
# OBSOLETE "dbsri <IMM_6>, <pcdisp>"
# OBSOLETE 	do_dbsri(_SD, pcdisp, IMM_6);
# OBSOLETE _BRA,10110,10,6.IMM_6,6.**,_IMM32:BRA:long:mu:DBSRI imm long
# OBSOLETE "dbsri <IMM_6>, <pcdisp>"
# OBSOLETE 	do_dbsri(_SD, pcdisp, IMM_6);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // DBT
# OBSOLETE 
# OBSOLETE 
# OBSOLETE _BRA,01011,00,6.**,6.**,6.**:BRA:short:mu:DBT
# OBSOLETE "dbt"
# OBSOLETE 	if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	  {
# OBSOLETE 	    WRITE32_QUEUE (&DPC, RPT_S);
# OBSOLETE 	    if (RPT_C == 0)
# OBSOLETE 	      PSW_SET (PSW_RP, 0);
# OBSOLETE 	  }
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE (&DPC, cia + 8);
# OBSOLETE 	DID_TRAP = 2;
# OBSOLETE 	nia = 0xfffff120; /* debug_trap_address */
# OBSOLETE 
# OBSOLETE // DJMP
# OBSOLETE 
# OBSOLETE void::function::do_djmp:address_word pcdisp, unsigned32 ra
# OBSOLETE 	PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, pcdisp);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, cia + (ra & ~0x7));
# OBSOLETE 
# OBSOLETE _BRA,10001,00,6.RA,6.**,6.RC:BRA:short:mu:DJMP
# OBSOLETE "djmp r<RA>, r<RC>"
# OBSOLETE 	do_djmp(_SD, pcdisp, val_Ra);
# OBSOLETE _BRA,10001,10,6.RA,_IMM12:BRA:short:mu:DJMP imm
# OBSOLETE "djmp r<RA>, <pcdisp>"
# OBSOLETE 	do_djmp(_SD, pcdisp, val_Ra);
# OBSOLETE _BRA,10001,10,6.RA,6.**,_IMM32:BRA:long:mu:DJMP imm long
# OBSOLETE "djmp r<RA>, <pcdisp>"
# OBSOLETE 	do_djmp(_SD, pcdisp, val_Ra);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // DJMPI
# OBSOLETE 
# OBSOLETE void::function::do_djmpi:address_word pcdisp, unsigned32 imm
# OBSOLETE 	PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, pcdisp);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, cia + (imm << 3));
# OBSOLETE 
# OBSOLETE _BRA,10101,00,6.IMM_6,6.**,6.RC:BRA:short:mu:DJMPI
# OBSOLETE "djmpi <IMM_6>, r<RC>"
# OBSOLETE 	do_djmpi(_SD, pcdisp, IMM_6);
# OBSOLETE _BRA,10101,10,6.IMM_6,_IMM12:BRA:short:mu:DJMPI imm
# OBSOLETE "djmpi <IMM_6>, <pcdisp>"
# OBSOLETE 	do_djmpi(_SD, pcdisp, IMM_6);
# OBSOLETE _BRA,10101,10,6.IMM_6,6.**,_IMM32:BRA:long:mu:DJMPI imm long
# OBSOLETE "djmpi <IMM_6>, <pcdisp>"
# OBSOLETE 	do_djmpi(_SD, pcdisp, IMM_6);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // DJSR
# OBSOLETE 
# OBSOLETE void::function::do_djsr:address_word pcdisp, unsigned32 ra
# OBSOLETE 	PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, pcdisp);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, cia + (ra & ~0x7));
# OBSOLETE 	WRITE32_QUEUE (&GPR[62], cia + (ra & ~0x7) + 8);
# OBSOLETE 
# OBSOLETE _BRA,10011,00,6.RA,6.**,6.RC:BRA:short:mu:DJSR
# OBSOLETE "djsr r<RA>, r<RC>"
# OBSOLETE 	do_djsr(_SD, pcdisp, val_Ra);
# OBSOLETE _BRA,10011,10,6.RA,_IMM12:BRA:short:mu:DJSR imm
# OBSOLETE "djsr r<RA>, <pcdisp>"
# OBSOLETE 	do_djsr(_SD, pcdisp, val_Ra);
# OBSOLETE _BRA,10011,10,6.RA,6.**,_IMM32:BRA:long:mu:DJSR imm long
# OBSOLETE "djsr r<RA>, <pcdisp>"
# OBSOLETE 	do_djsr(_SD, pcdisp, val_Ra);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // DJSRI
# OBSOLETE 
# OBSOLETE void::function::do_djsri:address_word pcdisp, unsigned32 imm
# OBSOLETE 	PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, pcdisp);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, cia + (imm << 3));
# OBSOLETE 	WRITE32_QUEUE (&GPR[62], cia + (imm << 3) + 8);
# OBSOLETE 
# OBSOLETE _BRA,10111,00,6.IMM_6,6.**,6.RC:BRA:short:mu:DJSRI
# OBSOLETE "djsri <IMM_6>, r<RC>"
# OBSOLETE 	do_djsri(_SD, pcdisp, IMM_6);
# OBSOLETE _BRA,10111,10,6.IMM_6,_IMM12:BRA:short:mu:DJSRI imm
# OBSOLETE "djsri <IMM_6>, <pcdisp>"
# OBSOLETE 	do_djsri(_SD, pcdisp, IMM_6);
# OBSOLETE _BRA,10111,10,6.IMM_6,6.**,_IMM32:BRA:long:mu:DJSRI imm long
# OBSOLETE "djsri <IMM_6>, <pcdisp>"
# OBSOLETE 	do_djsri(_SD, pcdisp, IMM_6);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // JMP
# OBSOLETE 
# OBSOLETE _BRA,00001,00,6.**,6.**,6.RC:BRA:short:mu:JMP
# OBSOLETE "jmp r<RC>"
# OBSOLETE 	nia = pcaddr;
# OBSOLETE 	if (RC == 62 && TRACE_CALL_P)
# OBSOLETE 	  TRACE_ACTION |= TRACE_ACTION_RETURN;
# OBSOLETE _BRA,00001,10,_IMM18:BRA:short:mu:JMP imm
# OBSOLETE "jmp <pcdisp>"
# OBSOLETE 	nia = pcaddr;
# OBSOLETE _BRA,00001,10,6.**,6.**,_IMM32:BRA:long:mu:JMP imm long
# OBSOLETE "jmp <pcdisp>"
# OBSOLETE 	nia = pcaddr;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // JMPTNZ
# OBSOLETE 
# OBSOLETE _BRA,00101,01,6.RA,6.**,6.RC:BRA:short:mu:JMPTNZ
# OBSOLETE "jmptnz r<RC>"
# OBSOLETE 	if (val_Ra != 0)
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE _BRA,00101,11,6.RA,_IMM12:BRA:short:mu:JMPTNZ imm
# OBSOLETE "jmptnz <pcdisp>"
# OBSOLETE 	if (val_Ra != 0)
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE _BRA,00101,11,6.RA,6.**,_IMM32:BRA:long:mu:JMPTNZ imm long
# OBSOLETE "jmptnz <pcdisp>"
# OBSOLETE 	if (val_Ra != 0)
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // JMPTZR
# OBSOLETE 
# OBSOLETE _BRA,00101,00,6.RA,6.**,6.RC:BRA:short:mu:JMPTZR
# OBSOLETE "jmptzr r<RC>"
# OBSOLETE 	if (val_Ra == 0)
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE _BRA,00101,10,6.RA,_IMM12:BRA:short:mu:JMPTZR imm
# OBSOLETE "jmptzr <pcdisp>"
# OBSOLETE 	if (val_Ra == 0)
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE _BRA,00101,10,6.RA,6.**,_IMM32:BRA:long:mu:JMPTZR imm long
# OBSOLETE "jmptzr <pcdisp>"
# OBSOLETE 	if (val_Ra == 0)
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // JOINpp 
# OBSOLETE 
# OBSOLETE void::function::do_join_pp:int pp, unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	switch (pp) {
# OBSOLETE 	case 0x0: /* LL */
# OBSOLETE 	  WRITE32_QUEUE (ra, ((unsigned32)VL2_4(rb) << 16) | VL2_4(src));
# OBSOLETE 	  break;
# OBSOLETE 	case 0x1: /* LH */
# OBSOLETE 	  WRITE32_QUEUE (ra, ((unsigned32)VL2_4(rb) << 16) | VH2_4(src));
# OBSOLETE 	  break;
# OBSOLETE 	case 0x2: /* HL */
# OBSOLETE 	  WRITE32_QUEUE (ra, ((unsigned32)VH2_4(rb) << 16) | VL2_4(src));
# OBSOLETE 	  break;
# OBSOLETE 	case 0x3: /* HH */
# OBSOLETE 	  WRITE32_QUEUE (ra, ((unsigned32)VH2_4(rb) << 16) | VH2_4(src));
# OBSOLETE 	  break;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE ::%s::pp:int pp
# OBSOLETE 	switch (pp)
# OBSOLETE 	  {
# OBSOLETE 	  case 0x0: return "ll";
# OBSOLETE 	  case 0x1: return "lh";
# OBSOLETE 	  case 0x2: return "hl";
# OBSOLETE 	  case 0x3: return "hh";
# OBSOLETE 	  default: return "?";
# OBSOLETE 	  }
# OBSOLETE 
# OBSOLETE _IALU1,011,pp,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:JOINpp
# OBSOLETE "join%s<pp> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_join_pp(_SD, pp, Ra, Rb, Rc);
# OBSOLETE _IALU1,011,pp,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:JOINpp imm
# OBSOLETE "join%s<pp> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_join_pp(_SD, pp, Ra, Rb, immHL);
# OBSOLETE _IALU1,011,pp,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:JOINpp imm long
# OBSOLETE "join%s<pp> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_join_pp(_SD, pp, Ra, Rb, immHL);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // JSR
# OBSOLETE 
# OBSOLETE _BRA,00011,00,6.**,6.**,6.RC:BRA:short:mu:JSR
# OBSOLETE "jsr r<RC>"
# OBSOLETE 	if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	if (TRACE_CALL_P)
# OBSOLETE 	  TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	return pcaddr;
# OBSOLETE _BRA,00011,10,_IMM18:BRA:short:mu:JSR imm
# OBSOLETE "jsr <pcdisp>"
# OBSOLETE 	if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	if (TRACE_CALL_P)
# OBSOLETE 	  TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	return pcaddr;
# OBSOLETE _BRA,00011,10,6.**,6.**,_IMM32:BRA:long:mu:JSR imm long
# OBSOLETE "jsr <pcdisp>"
# OBSOLETE 	if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	if (TRACE_CALL_P)
# OBSOLETE 	  TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	return pcaddr;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // JSRTNZ
# OBSOLETE 
# OBSOLETE _BRA,00111,01,6.RA,6.**,6.RC:BRA:short:mu:JSRTNZ
# OBSOLETE "jsrtnz r<RC>"
# OBSOLETE 	if (val_Ra != 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE _BRA,00111,11,6.RA,_IMM12:BRA:short:mu:JSRTNZ imm
# OBSOLETE "jsrtnz <pcdisp>"
# OBSOLETE 	if (val_Ra != 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE _BRA,00111,11,6.RA,6.**,_IMM32:BRA:long:mu:JSRTNZ imm long
# OBSOLETE "jsrtnz <pcdisp>"
# OBSOLETE 	if (val_Ra != 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // JSRTZR
# OBSOLETE 
# OBSOLETE _BRA,00111,00,6.RA,6.**,6.RC:BRA:short:mu:JSRTZR
# OBSOLETE "jsrtzr r<RC>"
# OBSOLETE 	if (val_Ra == 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE _BRA,00111,10,6.RA,_IMM12:BRA:short:mu:JSRTZR imm
# OBSOLETE "jsrtzr <pcdisp>"
# OBSOLETE 	if (val_Ra == 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE _BRA,00111,10,6.RA,6.**,_IMM32:BRA:long:mu:JSRTZR imm long
# OBSOLETE "jsrtzr <pcdisp>"
# OBSOLETE 	if (val_Ra == 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // Post increment
# OBSOLETE 
# OBSOLETE void::function::do_incr:int x, unsigned32 *rb, int delta
# OBSOLETE 	unsigned32 next_rb;
# OBSOLETE 	if (x == 1)
# OBSOLETE 	  next_rb = *rb + delta;
# OBSOLETE 	else if (x == 3)
# OBSOLETE 	  next_rb = *rb - delta;
# OBSOLETE 	else
# OBSOLETE 	  next_rb = *rb; /* value not used */
# OBSOLETE 	/* HW erratum: check value after incrementing */
# OBSOLETE 	if (next_rb == MOD_E
# OBSOLETE 	    && (x == 1 || x == 3)
# OBSOLETE 	    && (PSW_VAL(PSW_MD))) {
# OBSOLETE 	  WRITE32_QUEUE (rb, MOD_S);
# OBSOLETE 	}
# OBSOLETE 	else if (x == 1 || x == 3)
# OBSOLETE 	  WRITE32_QUEUE (rb, next_rb);
# OBSOLETE 
# OBSOLETE // LD2H
# OBSOLETE 
# OBSOLETE int::function::make_even_reg:int reg, const char *name
# OBSOLETE 	if (reg & 1)
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia,
# OBSOLETE 			    "0x%lx:%s odd register (r%d) used in multi-word load/mulx2h",
# OBSOLETE 			    (long) cia, name, reg);
# OBSOLETE 	return reg;
# OBSOLETE 
# OBSOLETE void::function::do_ld2h:int ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	signed32 mem;
# OBSOLETE 	ra = make_even_reg(_SD, ra, "LD2H");
# OBSOLETE 	mem = MEM(signed, rb + src, 4);
# OBSOLETE 	if (ra != 0)
# OBSOLETE 	{
# OBSOLETE 	  WRITE32_QUEUE (&GPR[ra + 0], SEXT32(EXTRACTED32(mem, 0, 15), 16));
# OBSOLETE 	  WRITE32_QUEUE (&GPR[ra + 1], SEXT32(EXTRACTED32(mem, 16, 31), 16));
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE ::%s::XX:int XX
# OBSOLETE 	switch (XX)
# OBSOLETE 	  {
# OBSOLETE 	  case 0: return "";
# OBSOLETE 	  case 1: return "+";
# OBSOLETE 	  case 3: return "-";
# OBSOLETE 	  default: return "?";
# OBSOLETE 	  }
# OBSOLETE 
# OBSOLETE _IMEM,00011,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LD2H
# OBSOLETE "ld2h r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ld2h r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ld2h(_SD, RA, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 4);
# OBSOLETE _IMEM,00011,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LD2H long
# OBSOLETE "ld2h r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_ld2h(_SD, RA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LD2W
# OBSOLETE 
# OBSOLETE void::function::do_ld2w:int ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	unsigned64 mem;
# OBSOLETE 	ra = make_even_reg(_SD, ra, "LD2W");
# OBSOLETE 	mem = MEM(unsigned, rb + src, 8);
# OBSOLETE 	if (ra != 0)
# OBSOLETE 	{
# OBSOLETE 	  WRITE32_QUEUE (&GPR[ra + 0], EXTRACTED64 (mem, 0, 31));
# OBSOLETE 	  WRITE32_QUEUE (&GPR[ra + 1], EXTRACTED64 (mem, 32, 63));
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _IMEM,00110,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:L2W
# OBSOLETE "ld2w r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ld2w r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ld2w(_SD, RA, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 8);
# OBSOLETE _IMEM,00110,10,6.RA,6.RB,_IMM32:IMEM:long:mu:L2W long
# OBSOLETE "ld2w r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_ld2w(_SD, RA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LD4BH
# OBSOLETE 
# OBSOLETE void::function::do_ld4bh:unsigned32 ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	unsigned16 l1, l2, h1, h2;
# OBSOLETE 	unsigned32 mem;
# OBSOLETE 	ra = make_even_reg(_SD, ra, "LD4BH");
# OBSOLETE 	mem = MEM(unsigned, rb + src, 4);
# OBSOLETE 	h1 = SEXT16(EXTRACTED32(mem, 0, 7), 8);
# OBSOLETE 	l1 = SEXT16(EXTRACTED32(mem, 8, 15), 8);
# OBSOLETE 	h2 = SEXT16(EXTRACTED32(mem, 16, 23), 8);
# OBSOLETE 	l2 = SEXT16(EXTRACTED32(mem, 24, 31), 8);
# OBSOLETE 	if (ra != 0)
# OBSOLETE 	{
# OBSOLETE 	  WRITE32_QUEUE (&GPR[ra + 0], (h1 << 16) | l1);
# OBSOLETE 	  WRITE32_QUEUE (&GPR[ra + 1], (h2 << 16) | l2);
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _IMEM,00101,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LD4BH
# OBSOLETE "ld4bh r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ld4bh r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ld4bh(_SD, RA, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 4);
# OBSOLETE _IMEM,00101,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LD4BH long
# OBSOLETE "ld4bh r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_ld4bh(_SD, RA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LD4BHU
# OBSOLETE 
# OBSOLETE void::function::do_ld4bhu:unsigned32 ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	unsigned16 l1, l2, h1, h2;
# OBSOLETE 	unsigned32 mem;
# OBSOLETE 	ra = make_even_reg(_SD, ra, "LD4BH");
# OBSOLETE 	mem = MEM(signed, rb + src, 4);
# OBSOLETE 	h1 = EXTRACTED32(mem, 0, 7);
# OBSOLETE 	l1 = EXTRACTED32(mem, 8, 15);
# OBSOLETE 	h2 = EXTRACTED32(mem, 16, 23);
# OBSOLETE 	l2 = EXTRACTED32(mem, 24, 31);
# OBSOLETE 	if (ra != 0)
# OBSOLETE 	{
# OBSOLETE 	  WRITE32_QUEUE (&GPR[ra + 0], (h1 << 16) | l1);
# OBSOLETE 	  WRITE32_QUEUE (&GPR[ra + 1], (h2 << 16) | l2);
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _IMEM,01101,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LD4BHU
# OBSOLETE "ld4hbu r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ld4hbu r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ld4bhu(_SD, RA, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 4);
# OBSOLETE _IMEM,01101,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LD4BHU long
# OBSOLETE "ld4hbu r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_ld4bhu(_SD, RA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LDB
# OBSOLETE 
# OBSOLETE void::function::do_ldb:unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	WRITE32_QUEUE (ra, MEM(signed, rb + src, 1));
# OBSOLETE 
# OBSOLETE _IMEM,00000,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LDB
# OBSOLETE "ldb r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ldb r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ldb(_SD, Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 1);
# OBSOLETE _IMEM,00000,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LDB long
# OBSOLETE "ldb r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_ldb(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LDBU
# OBSOLETE 
# OBSOLETE void::function::do_ldbu:unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	WRITE32_QUEUE (ra, MEM(unsigned, rb + src, 1));
# OBSOLETE 
# OBSOLETE _IMEM,01001,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LDBU
# OBSOLETE "ldbu r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ldbu r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ldbu(_SD, Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 1);
# OBSOLETE _IMEM,01001,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LDBU long
# OBSOLETE "ldbu r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_ldbu(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LDH
# OBSOLETE 
# OBSOLETE void::function::do_ldh:unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	WRITE32_QUEUE (ra, MEM(signed, rb + src, 2));
# OBSOLETE 
# OBSOLETE _IMEM,00010,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LDH
# OBSOLETE "ldh r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ldh r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ldh(_SD, Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 2);
# OBSOLETE _IMEM,00010,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LDH long
# OBSOLETE "ldh r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_ldh(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LDHH
# OBSOLETE 
# OBSOLETE void::function::do_ldhh:unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	WRITE32_QUEUE (ra, MEM(signed, rb + src, 2) << 16);
# OBSOLETE 
# OBSOLETE _IMEM,00001,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LDHH
# OBSOLETE "ldhh r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ldhh r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ldhh(_SD, Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 2);
# OBSOLETE _IMEM,00001,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LDHH long
# OBSOLETE "ldhh r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_ldhh(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LDHU
# OBSOLETE 
# OBSOLETE void::function::do_ldhu:unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	WRITE32_QUEUE (ra, MEM(unsigned, rb + src, 2));
# OBSOLETE 
# OBSOLETE _IMEM,01010,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LDHU
# OBSOLETE "ldhu r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ldhu r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ldhu(_SD, Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 2);
# OBSOLETE _IMEM,01010,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LDHU long
# OBSOLETE "ldhu r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_ldhu(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LDW
# OBSOLETE 
# OBSOLETE void::function::do_ldw:unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	WRITE32_QUEUE (ra, MEM(signed, rb + src, 4));
# OBSOLETE 
# OBSOLETE _IMEM,00100,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LDW
# OBSOLETE "ldw r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ldw r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ldw(_SD, Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 4);
# OBSOLETE _IMEM,00100,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LDW long
# OBSOLETE "ldw r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_ldw(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MACa
# OBSOLETE 
# OBSOLETE void::function::do_mac:unsigned64 *aa, unsigned32 *ra, signed32 rb, signed32 src
# OBSOLETE 	unsigned64 accum = *aa;
# OBSOLETE 	accum += (signed64) (rb) * (signed64) (src);
# OBSOLETE 	WRITE64_QUEUE (aa, accum);
# OBSOLETE 	WRITE32_QUEUE (ra, EXTRACTED64(accum, 32, 63));
# OBSOLETE 
# OBSOLETE _IALU2,10100,0,1.AA,6.RA,6.RB,6.RC:IALU2:short:iu:MACa
# OBSOLETE "mac<AA> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_mac(_SD, Aa, Ra, Rb, Rc);	
# OBSOLETE _IALU2,10100,1,1.AA,6.RA,6.RB,_IMM6:IALU2:short:iu:MACa imm
# OBSOLETE "mac<AA> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_mac(_SD, Aa, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MACSa
# OBSOLETE 
# OBSOLETE void::function::do_macs:unsigned64 *aa, unsigned32 *ra, signed32 rb, signed32 src
# OBSOLETE 	unsigned64 accum = *aa;
# OBSOLETE 	accum += ((signed64) (rb) * (signed64) (src)) << 1;
# OBSOLETE 	WRITE64_QUEUE (aa, accum);
# OBSOLETE 	WRITE32_QUEUE (ra, EXTRACTED64(accum, 0, 31));
# OBSOLETE 
# OBSOLETE _IALU2,10101,0,1.AA,6.RA,6.RB,6.RC:IALU2:short:iu:MACSa
# OBSOLETE "macs<AA> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_macs(_SD, Aa, Ra, Rb, Rc);	
# OBSOLETE _IALU2,10101,1,1.AA,6.RA,6.RB,_IMM6:IALU2:short:iu:MACSa imm
# OBSOLETE "macs<AA> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_macs(_SD, Aa, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MODDEC | MODINC
# OBSOLETE 
# OBSOLETE _IMEM,00111,11,6.**,6.RB,_IMM6:IMEM:short:mu:MODDEC
# OBSOLETE "moddec r<RB>, <imm>"
# OBSOLETE 	do_incr(_SD, 3/*0b11*/, &GPR[RB], imm_5);	
# OBSOLETE _IMEM,00111,01,6.**,6.RB,_IMM6:IMEM:short:mu:MODINC
# OBSOLETE "modinc r<RB>, <imm>"
# OBSOLETE 	do_incr(_SD, 1/*0b01*/, &GPR[RB], imm_5);	
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MSUBa
# OBSOLETE 
# OBSOLETE void::function::do_msub:unsigned64 *aa, unsigned32 *ra, signed32 rb, signed32 src
# OBSOLETE 	unsigned64 accum = *aa;
# OBSOLETE 	accum -= (signed64) (rb) * (signed64) (src);
# OBSOLETE 	WRITE64_QUEUE (aa, accum);
# OBSOLETE 	WRITE32_QUEUE (ra, EXTRACTED64(accum, 32, 63));
# OBSOLETE 
# OBSOLETE _IALU2,10110,0,1.AA,6.RA,6.RB,6.RC:IALU2:short:iu:MSUBa
# OBSOLETE "msub<AA> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_msub(_SD, Aa, Ra, Rb, Rc);	
# OBSOLETE _IALU2,10110,1,1.AA,6.RA,6.RB,_IMM6:IALU2:short:iu:MSUBa imm
# OBSOLETE "msub<AA> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_msub(_SD, Aa, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MSUBSa
# OBSOLETE 
# OBSOLETE void::function::do_msubs:unsigned64 *aa, unsigned32 *ra, signed32 rb, signed32 src
# OBSOLETE 	unsigned64 accum = *aa;
# OBSOLETE 	accum -= ((signed64) (rb) * (signed64) (src)) << 1;
# OBSOLETE 	WRITE64_QUEUE (aa, accum);
# OBSOLETE 	WRITE32_QUEUE (ra, EXTRACTED64(accum, 0, 31));
# OBSOLETE 
# OBSOLETE _IALU2,10111,0,1.AA,6.RA,6.RB,6.RC:IALU2:short:iu:MSUBSa
# OBSOLETE "msubs<AA> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_msubs(_SD, Aa, Ra, Rb, Rc);	
# OBSOLETE _IALU2,10111,1,1.AA,6.RA,6.RB,_IMM6:IALU2:short:iu:MSUBSa imm
# OBSOLETE "msubs<AA> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_msubs(_SD, Aa, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MUL
# OBSOLETE 
# OBSOLETE void::function::do_mul:unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	WRITE32_QUEUE (ra, rb * src);
# OBSOLETE 
# OBSOLETE _IALU2,10000,00,6.RA,6.RB,6.RC:IALU2:short:iu:MUL
# OBSOLETE "mul r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_mul(_SD, Ra, Rb, Rc);	
# OBSOLETE _IALU2,10000,10,6.RA,6.RB,_IMM6:IALU2:short:iu:MUL imm
# OBSOLETE "mul r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_mul(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MUL2H
# OBSOLETE 
# OBSOLETE void::function::do_mul2h:unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	unsigned16 high = VH2_4(rb) * VH2_4(src);
# OBSOLETE 	unsigned16 low  = VL2_4(rb) * VL2_4(src);
# OBSOLETE 	WRITE32_QUEUE (ra, (high << 16) | low);
# OBSOLETE 
# OBSOLETE _IALU2,00000,00,6.RA,6.RB,6.RC:IALU2:short:iu:MUL2H
# OBSOLETE "mul2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_mul2h(_SD, Ra, Rb, Rc);	
# OBSOLETE _IALU2,00000,10,6.RA,6.RB,_IMM6:IALU2:short:iu:MUL2H imm
# OBSOLETE "mul2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_mul2h(_SD, Ra, Rb, immHL);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MULX
# OBSOLETE 
# OBSOLETE void::function::do_mulx:unsigned64 *aa, signed32 rb, signed32 src
# OBSOLETE 	WRITE64_QUEUE (aa, (signed64) (rb) * (signed64) (src));
# OBSOLETE 
# OBSOLETE _IALU2,11000,00,5.*,1.AA,6.RB,6.RC:IALU2:short:iu:MULX
# OBSOLETE "mulx a<AA>, r<RB>, r<RC>"
# OBSOLETE 	do_mulx(_SD, Aa, Rb, Rc);	
# OBSOLETE _IALU2,11000,10,5.*,1.AA,6.RB,_IMM6:IALU2:short:iu:MULX imm
# OBSOLETE "mulx a<AA>, r<RB>, <imm>"
# OBSOLETE 	do_mulx(_SD, Aa, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MULX2H
# OBSOLETE 
# OBSOLETE void::function::do_mulx2h:int ra, signed32 rb, signed32 src, int high
# OBSOLETE 	signed32 result = rb * src;
# OBSOLETE 	if (!high)
# OBSOLETE 	  {
# OBSOLETE 	    ra = make_even_reg(_SD, ra, "MULX2H");
# OBSOLETE 	    if (ra != 0)
# OBSOLETE 	      WRITE32_QUEUE (&GPR[ra+1], result);
# OBSOLETE 	  }
# OBSOLETE 	else if (ra != 0)
# OBSOLETE 	  {
# OBSOLETE 	      WRITE32_QUEUE (&GPR[ra+0], result);
# OBSOLETE 	  }
# OBSOLETE 
# OBSOLETE _IALU2,00001,00,6.RA,6.RB,6.RC:IALU2:short:iu:MULX2H
# OBSOLETE "mul2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_mulx2h(_SD, RA, RbH, RcH, 1);
# OBSOLETE 	do_mulx2h(_SD, RA, RbL, RcL, 0);
# OBSOLETE _IALU2,00001,10,6.RA,6.RB,_IMM6:IALU2:short:iu:MULX2H imm
# OBSOLETE "mul2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_mulx2h(_SD, RA, RbH, imm, 1);
# OBSOLETE 	do_mulx2h(_SD, RA, RbL, imm, 0);
# OBSOLETE 
# OBSOLETE // MULHXpp
# OBSOLETE 
# OBSOLETE void::function::do_mulhx:int pp, unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	signed32 value = 0;
# OBSOLETE 	switch (pp) {
# OBSOLETE 	case 0: /* LL */
# OBSOLETE 	  value = SEXT32(VL2_4(rb), 16) * SEXT32(VL2_4(src), 16);
# OBSOLETE 	  break;
# OBSOLETE 	case 1: /* LH */
# OBSOLETE 	  value = SEXT32(VL2_4(rb), 16) * SEXT32(VH2_4(src), 16);
# OBSOLETE 	  break;
# OBSOLETE 	case 2: /* HL */
# OBSOLETE 	  value = SEXT32(VH2_4(rb), 16) * SEXT32(VL2_4(src), 16);
# OBSOLETE 	  break;
# OBSOLETE 	case 3: /* HH */
# OBSOLETE 	  value = SEXT32(VH2_4(rb), 16) * SEXT32(VH2_4(src), 16);
# OBSOLETE 	  break;
# OBSOLETE 	default:
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "do_mulhx - internal error - bad switch");
# OBSOLETE 	}
# OBSOLETE 	WRITE32_QUEUE (ra, value);
# OBSOLETE 
# OBSOLETE _IALU2,001,pp,00,6.RA,6.RB,6.RC:IALU2:short:iu:MULHXpp
# OBSOLETE "mulhx%s<pp> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_mulhx(_SD, pp, Ra, Rb, Rc);	
# OBSOLETE _IALU2,001,pp,10,6.RA,6.RB,_IMM6:IALU2:short:iu:MULHXpp imm
# OBSOLETE "mulhx%s<pp> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_mulhx(_SD, pp, Ra, Rb, immHL);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MULXS
# OBSOLETE 
# OBSOLETE void::function::do_mulxs:unsigned64 *aa, signed32 rb, signed32 src
# OBSOLETE 	WRITE64_QUEUE (aa, ((signed64) (rb) * (signed64) (src)) << 1);
# OBSOLETE 
# OBSOLETE _IALU2,11001,00,5.*,1.AA,6.RB,6.RC:IALU2:short:iu:MULXS
# OBSOLETE "mulxs a<AA>, r<RB>, r<RC>"
# OBSOLETE 	do_mulxs(_SD, Aa, Rb, Rc);	
# OBSOLETE _IALU2,11001,10,5.*,1.AA,6.RB,_IMM6:IALU2:short:iu:MULXS imm
# OBSOLETE "mulxs a<AA>, r<RB>, <imm>"
# OBSOLETE 	do_mulxs(_SD, Aa, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MVFACC
# OBSOLETE 
# OBSOLETE void::function::do_mvfacc:unsigned32 *ra, unsigned64 ab, unsigned32 src
# OBSOLETE 	while (src > 63) src -= 64;
# OBSOLETE 	WRITE32_QUEUE (ra, ((signed64)ab) >> src);
# OBSOLETE 
# OBSOLETE _IALU2,11111,00,6.RA,5.*,1.AB,6.RC:IALU2:short:iu:MVFACC
# OBSOLETE "mvfacc r<RA>, a<AB>, r<RC>"
# OBSOLETE 	do_mvfacc(_SD, Ra, *Ab, Rc);	
# OBSOLETE _IALU2,11111,10,6.RA,5.*,1.AB,_IMM6:IALU2:short:iu:MVFACC imm
# OBSOLETE "mvfacc r<RA>, a<AB>, <imm>"
# OBSOLETE 	do_mvfacc(_SD, Ra, *Ab, imm_6u);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MVFSYS
# OBSOLETE 
# OBSOLETE _BRA,11110,00,6.RA,6.CR,6.ID:BRA:short:mu:MVFSYS
# OBSOLETE "mvfsys r<RA>, cr<CR>"
# OBSOLETE 	switch (ID) {
# OBSOLETE 	case 0:
# OBSOLETE 	  if (CR >= NR_CONTROL_REGISTERS)
# OBSOLETE 	    sim_engine_abort (SD, CPU, cia, "FIXME - illegal CR");
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (Ra, (CPU)->regs.control[CR]);
# OBSOLETE 	  break;
# OBSOLETE 	case 1:
# OBSOLETE 	  WRITE32_QUEUE (Ra, PSWL);
# OBSOLETE 	  break;
# OBSOLETE 	case 2:
# OBSOLETE 	  WRITE32_QUEUE (Ra, EXTRACTED32(PSWH, 16, 31));
# OBSOLETE 	  break;
# OBSOLETE 	case 3:
# OBSOLETE 	  WRITE32_QUEUE (Ra, PSW_FLAG_VAL(CR));
# OBSOLETE 	  break;
# OBSOLETE 	default:
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "FIXME - illegal ID");
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MVTACC
# OBSOLETE 
# OBSOLETE _IALU2,01111,00,5.*,1.AA,6.RB,6.RC:IALU2:short:iu:MVTACC
# OBSOLETE "mvtacc a<AA>, r<RB>, r<RC>"
# OBSOLETE 	WRITE64_QUEUE (Aa, INSERTED64(RbU, 0, 31) | (RcU));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MVTSYS
# OBSOLETE 
# OBSOLETE _BRA,01110,00,6.CR,6.RB,6.ID:BRA:short:mu:MVTSYS
# OBSOLETE "mvtsys cr<CR>, r<RB>"
# OBSOLETE 	switch (ID) {
# OBSOLETE 	case 0:			/* control register */
# OBSOLETE 	  if (CR >= NR_CONTROL_REGISTERS)
# OBSOLETE 	    sim_engine_abort (SD, CPU, cia, "FIXME - illegal CR");
# OBSOLETE 	  else
# OBSOLETE 	    {
# OBSOLETE 	      unsigned32 value = Rb;
# OBSOLETE 	      CPU->mvtsys_left_p = 1;
# OBSOLETE 	      if (CR == processor_status_word_cr)
# OBSOLETE 		{
# OBSOLETE 		  unsigned32 ds = PSW & BIT32 (PSW_DS);	/* preserve ds */
# OBSOLETE 		  value = ds | (value & PSW_VALID);
# OBSOLETE 		}
# OBSOLETE 	      else if (CR == backup_processor_status_word_cr
# OBSOLETE 		       || CR == debug_backup_processor_status_word_cr)
# OBSOLETE 		value &= DPSW_VALID;
# OBSOLETE 	      else if (CR == eit_vector_base_cr)
# OBSOLETE 		value &= EIT_VALID;
# OBSOLETE 	      WRITE32_QUEUE (&(CPU)->regs.control[CR], value);
# OBSOLETE 	    }
# OBSOLETE 	  break;
# OBSOLETE 	case 1:			/* PSWL */
# OBSOLETE 	  WRITE32_QUEUE_MASK (&PSW, EXTRACTED32(Rb, 16, 31),
# OBSOLETE 			      PSW_VALID & 0x0000ffff);
# OBSOLETE 	  break;
# OBSOLETE 	case 2:			/* PSWH */
# OBSOLETE 	  {
# OBSOLETE 	    unsigned32 ds = PSW & BIT32 (PSW_DS);	/* preserve ds */
# OBSOLETE 	    WRITE32_QUEUE_MASK (&PSW, (EXTRACTED32(Rb, 16, 31) << 16) | ds,
# OBSOLETE 				(PSW_VALID | ds) & 0xffff0000);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 3:			/* FLAG */
# OBSOLETE 	  PSW_FLAG_SET_QUEUE(CR, Rb & 1);
# OBSOLETE 	  break;
# OBSOLETE 	default:
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "FIXME - illegal ID");
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // NOP
# OBSOLETE 
# OBSOLETE _BRA,01111,00,6.**,6.**,6.**:BRA:short:iu,mu:NOP
# OBSOLETE "nop"
# OBSOLETE 	/* NOP */;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // NOT
# OBSOLETE 
# OBSOLETE _LOGIC,11001,00,6.RA,6.RB,6.*:LOGIC:short:iu,mu:NOT
# OBSOLETE "not r<RA>, r<RB>"
# OBSOLETE 	WRITE32_QUEUE (Ra, ~Rb);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // NOTFG
# OBSOLETE 
# OBSOLETE _LOGIC,01001,00,***,3.FA,***,3.FB,***,3.FC:LOGIC:short:iu,mu:NOTFG
# OBSOLETE "notfg f<FA>, f<FB>"
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, !PSW_FLAG_VAL(FB));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // OR
# OBSOLETE 
# OBSOLETE _LOGIC,11010,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:OR
# OBSOLETE "or r<RA>, r<RB>, r<RC>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb | Rc);
# OBSOLETE _LOGIC,11010,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:OR imm
# OBSOLETE "or r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb | imm);
# OBSOLETE _LOGIC,11010,10,6.RA,6.RB,_IMM32:LOGIC:long:iu,mu:OR imm long
# OBSOLETE "or r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb | imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ORFG
# OBSOLETE 
# OBSOLETE _LOGIC,01010,00,***,3.FA,***,3.FB,***,3.FC:LOGIC:short:iu,mu:ORFG
# OBSOLETE "orfg f<FA>, f<FB>, f<FC>"
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, PSW_FLAG_VAL(FB) | PSW_FLAG_VAL(FC));
# OBSOLETE _LOGIC,01010,10,***,3.FA,***,3.FB,_IMM6:LOGIC:short:iu,mu:ORFG imm
# OBSOLETE "orfg f<FA>, f<FB>, <imm>"
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, PSW_FLAG_VAL(FB) | (imm_6 & 1));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // REIT
# OBSOLETE 
# OBSOLETE _BRA,01000,00,6.**,6.**,6.**:BRA:short:mu:REIT
# OBSOLETE "reit"
# OBSOLETE 	WRITE32_QUEUE (&PSW, bPSW);
# OBSOLETE 	nia = bPC;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // REPEAT
# OBSOLETE 
# OBSOLETE void::function::do_repeat:unsigned32 count, address_word pcaddr
# OBSOLETE 	address_word rpt_s = cia + 8;
# OBSOLETE 	address_word rpt_e = cia + pcaddr;
# OBSOLETE 
# OBSOLETE 	if (count == 0)
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "REPEAT with ra=0 and REPEATI with imm = 0 is forbidden.");
# OBSOLETE 	if (count > 1)
# OBSOLETE 	  PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	if (rpt_e  < rpt_s + 0x10)
# OBSOLETE 	  sim_io_eprintf (sd, "warning: 0x%lx: REPEAT or REPEATI loop is too small\n", (long) cia);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, count - 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, rpt_s);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, rpt_e);
# OBSOLETE 
# OBSOLETE _BRA,11000,00,6.RA,6.**,6.RC:BRA:short:mu:REPEAT
# OBSOLETE "repeat r<RA>, r<RC>"
# OBSOLETE 	do_repeat(_SD, val_Ra, pcaddr);
# OBSOLETE _BRA,11000,10,6.RA,_IMM12:BRA:short:mu:REPEAT imm
# OBSOLETE "repeat r<RA>, <pcaddr>"
# OBSOLETE 	do_repeat(_SD, val_Ra, pcaddr);
# OBSOLETE _BRA,11000,10,6.RA,6.**,_IMM32:BRA:long:mu:REPEAT imm long
# OBSOLETE "repeat r<RA>, <pcaddr>"
# OBSOLETE 	do_repeat(_SD, val_Ra, pcaddr);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // REPEATI
# OBSOLETE 
# OBSOLETE _BRA,11010,00,6.IMM_6,6.**,6.RC:BRA:short:mu:REPEATI
# OBSOLETE "repeati <IMM_6>, r<RC>"
# OBSOLETE 	do_repeat(_SD, IMM_6, pcaddr);
# OBSOLETE _BRA,11010,10,6.IMM_6,_IMM12:BRA:short:mu:REPEATI imm
# OBSOLETE "repeati <IMM_6>, <pcaddr>"
# OBSOLETE 	do_repeat(_SD, IMM_6, pcaddr);
# OBSOLETE _BRA,11010,10,6.IMM_6,6.**,_IMM32:BRA:long:mu:REPEATI imm long
# OBSOLETE "repeati <IMM_6>, <pcaddr>"
# OBSOLETE 	do_repeat(_SD, IMM_6, pcaddr);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // RTD
# OBSOLETE 
# OBSOLETE _BRA,01010,00,6.*,6.*,6.*:BRA:short:mu:RTD
# OBSOLETE "rtd"
# OBSOLETE 	WRITE32_QUEUE (&PSW, DPSW);
# OBSOLETE 	nia = DPC;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ROT
# OBSOLETE 
# OBSOLETE _LOGIC,10100,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:ROT
# OBSOLETE "rot r<RA>, r<RB>, r<RC>"
# OBSOLETE 	WRITE32_QUEUE (Ra, ROT32(Rb, Rc & 0x1f));
# OBSOLETE _LOGIC,10100,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:ROT imm
# OBSOLETE "rot r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, ROT32(Rb, imm & 0x1f));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ROT2H
# OBSOLETE 
# OBSOLETE void::function::do_rot2h:unsigned32 *ra, unsigned32 rb, signed32 src
# OBSOLETE 	unsigned16 high = ROTR16(VH2_4(rb), VH2_4(src) & 0xf);
# OBSOLETE 	unsigned16 low  = ROTR16(VL2_4(rb), VL2_4(src) & 0xf);
# OBSOLETE 	WRITE32_QUEUE (ra, (high << 16) | low);
# OBSOLETE 
# OBSOLETE _LOGIC,10101,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:ROT2H
# OBSOLETE "rot2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_rot2h(_SD, Ra, Rb, Rc);
# OBSOLETE _LOGIC,10101,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:ROT2H imm
# OBSOLETE "rot2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_rot2h(_SD, Ra, Rb, immHL);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SAT
# OBSOLETE 
# OBSOLETE void::function::do_sat:signed32 *ra, signed32 rb, signed32 src
# OBSOLETE 	int bits = LSMASKED32(src, 4, 0); /* 5 */
# OBSOLETE 	signed32 sat = LSMASK32(bits, 0) >> 2;
# OBSOLETE 	signed32 nsat = ~sat;
# OBSOLETE 	signed32 value;
# OBSOLETE 	if (bits != src)
# OBSOLETE 	  sim_io_eprintf (sd, "warning: 0x%lx:SAT bit overflow\n", (long) cia);
# OBSOLETE 	if (bits == 0)
# OBSOLETE 	  value = rb;
# OBSOLETE 	else if (rb >= sat)
# OBSOLETE 	  value = sat;
# OBSOLETE 	else if (rb <= nsat)
# OBSOLETE 	  value = nsat;
# OBSOLETE 	else
# OBSOLETE 	  value = rb;
# OBSOLETE 	WRITE32_QUEUE (ra, value);
# OBSOLETE 
# OBSOLETE _IALU2,01000,00,6.RA,6.RB,6.RC:IALU2:short:iu:SAT
# OBSOLETE "sat r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_sat(_SD, Ra, Rb, Rc);
# OBSOLETE _IALU2,01000,10,6.RA,6.RB,_IMM6:IALU2:short:iu:SAT imm
# OBSOLETE "sat r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_sat(_SD, Ra, Rb, imm_5);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SAT2H
# OBSOLETE 
# OBSOLETE void::function::do_sath:signed32 *ra, signed32 rb, signed32 src, int high, int updates_f4
# OBSOLETE 	int bits = LSMASKED32(src, 4, 0); /* 5 */
# OBSOLETE 	signed32 sat = LSMASK32(bits, 0) >> 2;
# OBSOLETE 	signed32 nsat = ~sat;
# OBSOLETE 	signed32 value;
# OBSOLETE 	if (bits != src)
# OBSOLETE 	  sim_io_eprintf (sd, "warning: 0x%lx:SAT bit overflow\n", (long) cia);
# OBSOLETE 	if (bits == 0)
# OBSOLETE 	  value = rb;
# OBSOLETE 	else if (rb >= sat)
# OBSOLETE 	  value = sat;
# OBSOLETE 	else if (rb <= nsat)
# OBSOLETE 	  value = nsat;
# OBSOLETE 	else
# OBSOLETE 	  value = rb;
# OBSOLETE 	if (high)
# OBSOLETE 	  WRITE32_QUEUE_MASK (ra, value << 16, 0xffff0000);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE_MASK (ra, value, 0x0000ffff);
# OBSOLETE 	if (updates_f4)
# OBSOLETE 	  {
# OBSOLETE 	    /* if MU instruction was a MVTSYS (lkr), unqueue register writes now */
# OBSOLETE 	    if(STATE_CPU (sd, 0)->mvtsys_left_p)
# OBSOLETE 	      unqueue_writes (sd, STATE_CPU (sd, 0), cia);
# OBSOLETE 	    PSW_FLAG_SET_QUEUE(PSW_S_FLAG, PSW_FLAG_VAL(PSW_S_FLAG) ^ (value & 1));
# OBSOLETE 	  }
# OBSOLETE 
# OBSOLETE _IALU2,01001,00,6.RA,6.RB,6.RC:IALU2:short:iu:SAT2H
# OBSOLETE "sat2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_sath(_SD, Ra, RbH, RcH, 1, 0);
# OBSOLETE 	do_sath(_SD, Ra, RbL, RcL, 0, 0);
# OBSOLETE _IALU2,01001,10,6.RA,6.RB,_IMM6:IALU2:short:iu:SAT2H imm
# OBSOLETE "sat2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_sath(_SD, Ra, RbH, imm_5, 1, 0);
# OBSOLETE 	do_sath(_SD, Ra, RbL, imm_5, 0, 0);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SATHp
# OBSOLETE 
# OBSOLETE ::%s::p:int p
# OBSOLETE 	switch (p)
# OBSOLETE 	  {
# OBSOLETE 	  case 0: return "l";
# OBSOLETE 	  case 1: return "h";
# OBSOLETE 	  default: return "?";
# OBSOLETE 	  }
# OBSOLETE 
# OBSOLETE _IALU2,1110,p,00,6.RA,6.RB,6.RC:IALU2:short:iu:SATHP
# OBSOLETE "sath%s<p> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_sath(_SD, Ra, Rb, Rc, p, 1);
# OBSOLETE _IALU2,1110,p,10,6.RA,6.RB,_IMM6:IALU2:short:iu:SATHP imm
# OBSOLETE "sath%s<p> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_sath(_SD, Ra, Rb, imm_5, p, 1);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SATZ
# OBSOLETE 
# OBSOLETE void::function::do_satz:signed32 *ra, signed32 rb, signed32 src
# OBSOLETE 	if (rb < 0)
# OBSOLETE 	  WRITE32_QUEUE (ra, 0);
# OBSOLETE 	else
# OBSOLETE 	  do_sat (_SD, ra, rb, src);
# OBSOLETE 
# OBSOLETE _IALU2,01010,00,6.RA,6.RB,6.RC:IALU2:short:iu:SATZ
# OBSOLETE "satz r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_satz(_SD, Ra, Rb, Rc);
# OBSOLETE _IALU2,01010,10,6.RA,6.RB,_IMM6:IALU2:short:iu:SATZ imm
# OBSOLETE "satz r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_satz(_SD, Ra, Rb, imm_5);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SATZ2H
# OBSOLETE 
# OBSOLETE void::function::do_satzh:signed32 *ra, signed16 rb, signed32 src, int high
# OBSOLETE 	int bits = LSMASKED32(src, 3, 0); /*4*/
# OBSOLETE 	signed16 sat = LSMASK16(bits, 0) >> 2;
# OBSOLETE 	signed16 nsat = 0;
# OBSOLETE 	signed16 value;
# OBSOLETE 	if (bits != src)
# OBSOLETE 	  sim_io_eprintf (sd, "warning: 0x%lx:SATZ2H bit overflow\n", (long) cia);
# OBSOLETE 	if (bits == 0 && rb > sat)
# OBSOLETE 	  value = rb;
# OBSOLETE 	else if (rb > sat)
# OBSOLETE 	  value = sat;
# OBSOLETE 	else if (rb < nsat)
# OBSOLETE 	  value = nsat;
# OBSOLETE 	else
# OBSOLETE 	  value = rb;
# OBSOLETE 	if (high)
# OBSOLETE 	  WRITE32_QUEUE_MASK (ra, value << 16, 0xffff0000);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE_MASK (ra, value, 0x0000ffff);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE _IALU2,01011,00,6.RA,6.RB,6.RC:IALU2:short:iu:SATZ2H
# OBSOLETE "satz2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_satzh(_SD, Ra, RbH, RcH, 1);
# OBSOLETE 	do_satzh(_SD, Ra, RbL, RcL, 0);
# OBSOLETE _IALU2,01011,10,6.RA,6.RB,_IMM6:IALU2:short:iu:SATZ2H imm
# OBSOLETE "satz2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_satzh(_SD, Ra, RbH, imm, 1);
# OBSOLETE 	do_satzh(_SD, Ra, RbL, imm, 0);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SRA
# OBSOLETE 
# OBSOLETE void::function::do_sra:unsigned32 *ra, unsigned32 rb, signed32 src
# OBSOLETE 	unsigned32 value;
# OBSOLETE 	while (src > 31) src -= 32;
# OBSOLETE 	while (src < -32) src += 32;
# OBSOLETE 	if (src >= 0)
# OBSOLETE 	  value = (signed32)rb >> src;
# OBSOLETE 	else if (src == -32)
# OBSOLETE 	  value = 0;
# OBSOLETE 	else
# OBSOLETE 	  value = rb << -src;
# OBSOLETE 	WRITE32_QUEUE (ra, value);
# OBSOLETE 
# OBSOLETE _LOGIC,10000,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRA
# OBSOLETE "sra r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_sra(_SD, Ra, Rb, Rc);
# OBSOLETE _LOGIC,10000,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRA imm
# OBSOLETE "sra r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_sra(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SRAHp
# OBSOLETE 
# OBSOLETE void::function::do_srah:unsigned32 *ra, unsigned32 rb, int src, int high
# OBSOLETE 	unsigned32 value;
# OBSOLETE 	while (src > 31) src -= 32;
# OBSOLETE 	while (src < -32) src += 32;
# OBSOLETE 	if (src >= 0)
# OBSOLETE 	  value = (signed32)rb >> src;
# OBSOLETE 	else if (src == -32)
# OBSOLETE 	  value = 0;
# OBSOLETE 	else
# OBSOLETE 	  value = rb << -src;
# OBSOLETE 	if (high)
# OBSOLETE 	  WRITE32_QUEUE_MASK (ra, value << 16, 0xffff0000);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE_MASK (ra, value, 0x0000ffff);
# OBSOLETE 
# OBSOLETE _LOGIC,0010,p,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRAHP
# OBSOLETE "srah%s<p> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_srah(_SD, Ra, Rb, Rc, p);
# OBSOLETE _LOGIC,0010,p,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRAHP imm
# OBSOLETE "srah%s<p> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_srah(_SD, Ra, Rb, imm, p);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SRA2H
# OBSOLETE 
# OBSOLETE _LOGIC,10001,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRA2H
# OBSOLETE "sra2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	signed32 srcH = RcH;
# OBSOLETE 	signed32 srcL = RcL;
# OBSOLETE 	while (srcH > 15) srcH -= 16;
# OBSOLETE 	while (srcH < -16) srcH += 16;
# OBSOLETE 	while (srcL > 15) srcL -= 16;
# OBSOLETE 	while (srcL < -16) srcL += 16;
# OBSOLETE 	do_srah(_SD, Ra, RbH, srcH, 1);
# OBSOLETE 	do_srah(_SD, Ra, RbL, srcL, 0);
# OBSOLETE _LOGIC,10001,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRA2H imm
# OBSOLETE "sra2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	signed32 src = imm;
# OBSOLETE 	while (src > 15) src -= 16;
# OBSOLETE 	while (src < -16) src += 16;
# OBSOLETE 	do_srah(_SD, Ra, RbH, src, 1);
# OBSOLETE 	do_srah(_SD, Ra, RbL, src, 0);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SRC
# OBSOLETE 
# OBSOLETE void::function::do_src:unsigned32 *ra, unsigned32 rb, int src
# OBSOLETE 	unsigned32 value;
# OBSOLETE 	unsigned64 operand;
# OBSOLETE 	unsigned64 shifted;
# OBSOLETE 	while (src > 31) src -= 32;
# OBSOLETE 	while (src < -32) src += 32;
# OBSOLETE 	if (src >= 0)
# OBSOLETE 	  {
# OBSOLETE 	    operand = (INSERTED64(rb, 0, 31) | INSERTED64(*ra, 32, 63));
# OBSOLETE 	    shifted = operand >> src;
# OBSOLETE 	    value = EXTRACTED64(shifted, 32, 63);
# OBSOLETE 	  }
# OBSOLETE 	else
# OBSOLETE 	  {
# OBSOLETE 	    operand = (INSERTED64(*ra, 0, 31) | INSERTED64(rb, 32, 63));
# OBSOLETE 	    shifted = operand << -src;
# OBSOLETE 	    value = EXTRACTED64(shifted, 0, 31);
# OBSOLETE 	  }
# OBSOLETE 	WRITE32_QUEUE (ra, value);
# OBSOLETE 
# OBSOLETE _LOGIC,10110,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRC
# OBSOLETE "src r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_src(_SD, Ra, Rb, Rc);
# OBSOLETE _LOGIC,10110,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRC imm
# OBSOLETE "src r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_src(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SRL
# OBSOLETE 
# OBSOLETE void::function::do_srl:unsigned32 *ra, unsigned32 rb, int src
# OBSOLETE 	unsigned32 value;
# OBSOLETE 	while (src > 31) src -= 32;
# OBSOLETE 	while (src < -32) src += 32;
# OBSOLETE 	if (src >= 0)
# OBSOLETE 	  value = (unsigned32)rb >> src;
# OBSOLETE 	else if (src == -32)
# OBSOLETE 	  value = 0;
# OBSOLETE 	else
# OBSOLETE 	  value = (unsigned32)rb << -src;
# OBSOLETE 	WRITE32_QUEUE (ra, value);
# OBSOLETE 
# OBSOLETE _LOGIC,10010,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRL
# OBSOLETE "srl r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_srl(_SD, Ra, Rb, Rc);
# OBSOLETE _LOGIC,10010,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRL imm
# OBSOLETE "srl r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_srl(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SRLHp
# OBSOLETE 
# OBSOLETE void::function::do_srlh:unsigned32 *ra, unsigned32 rb, int src, int high
# OBSOLETE 	unsigned32 value;
# OBSOLETE 	while (src > 31) src -= 32;
# OBSOLETE 	while (src < -32) src += 32;
# OBSOLETE 	if (src >= 0)
# OBSOLETE 	  value = rb >> src;
# OBSOLETE 	else if (src == -32)
# OBSOLETE 	  value = 0;
# OBSOLETE 	else
# OBSOLETE 	  value = rb << -src;
# OBSOLETE 	if (high)
# OBSOLETE 	  WRITE32_QUEUE_MASK (ra, value << 16, 0xffff0000);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE_MASK (ra, value, 0x0000ffff);
# OBSOLETE 
# OBSOLETE _LOGIC,0011,p,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRLHP
# OBSOLETE "srlh%s<p> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_srlh(_SD, Ra, Rb, Rc, p);
# OBSOLETE _LOGIC,0011,p,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRLHP imm
# OBSOLETE "srlh%s<p> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_srlh(_SD, Ra, Rb, imm, p);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SRL2H
# OBSOLETE 
# OBSOLETE _LOGIC,10011,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRL2H
# OBSOLETE "srl2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	signed32 srcH = RcH;
# OBSOLETE 	signed32 srcL = RcL;
# OBSOLETE 	while (srcH > 15) srcH -= 16;
# OBSOLETE 	while (srcH < -16) srcH += 16;
# OBSOLETE 	while (srcL > 15) srcL -= 16;
# OBSOLETE 	while (srcL < -16) srcL += 16;
# OBSOLETE 	do_srlh(_SD, Ra, RbHU, srcH, 1);
# OBSOLETE 	do_srlh(_SD, Ra, RbLU, srcL, 0);
# OBSOLETE _LOGIC,10011,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRL2H imm
# OBSOLETE "srl2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	signed32 src = imm;
# OBSOLETE 	while (src > 15) src -= 16;
# OBSOLETE 	while (src < -16) src += 16;
# OBSOLETE 	do_srlh(_SD, Ra, RbHU, src, 1);
# OBSOLETE 	do_srlh(_SD, Ra, RbLU, src, 0);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ST2H
# OBSOLETE 
# OBSOLETE void::function::get_even_reg:int *reg, unsigned32 *r0, const char *name
# OBSOLETE 	if (*reg & 1)
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia,
# OBSOLETE 			    "0x%lx:%s odd register (r%d) used in multi-word store",
# OBSOLETE 			    (long) cia, name, *reg);
# OBSOLETE 	if (*reg == 0)
# OBSOLETE 	  *r0 = 0;
# OBSOLETE 	else
# OBSOLETE 	  *r0 = GPR[*reg];
# OBSOLETE 
# OBSOLETE void::function::do_st2h:int ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	unsigned32 val_ra;
# OBSOLETE 	unsigned32 mem;
# OBSOLETE 	get_even_reg(_SD, &ra, &val_ra, "ST2H");
# OBSOLETE 	mem = INSERTED32(val_ra, 0, 15) |
# OBSOLETE 	      INSERTED32(GPR[ra + 1], 16, 31);
# OBSOLETE 	STORE(rb + src, 4, mem);
# OBSOLETE 
# OBSOLETE _IMEM,10011,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:ST2H
# OBSOLETE "st2h r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "st2h r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_st2h(_SD, RA, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 4);
# OBSOLETE _IMEM,10011,10,6.RA,6.RB,_IMM32:IMEM:long:mu:ST2H long
# OBSOLETE "st2h r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_st2h(_SD, RA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ST2W
# OBSOLETE 
# OBSOLETE void::function::do_st2w:int ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	unsigned32 val_ra;
# OBSOLETE 	unsigned64 mem;
# OBSOLETE 	get_even_reg(_SD, &ra, &val_ra, "ST2W");
# OBSOLETE 	mem = INSERTED64(val_ra, 0, 31) | INSERTED64(GPR[ra + 1], 32, 63);
# OBSOLETE 	STORE(rb + src, 8, mem);
# OBSOLETE 
# OBSOLETE _IMEM,10110,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:ST2W
# OBSOLETE "st2w r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "st2w r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_st2w(_SD, RA, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 8);
# OBSOLETE _IMEM,10110,10,6.RA,6.RB,_IMM32:IMEM:long:mu:ST2W long
# OBSOLETE "st2w r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_st2w(_SD, RA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ST4HB
# OBSOLETE 
# OBSOLETE void::function::do_st4hb:int ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	unsigned32 val_ra;
# OBSOLETE 	unsigned32 mem;
# OBSOLETE 	get_even_reg(_SD, &ra, &val_ra, "ST4HB");
# OBSOLETE 	mem = INSERTED32(EXTRACTED32(val_ra, 8, 15), 0, 7) |
# OBSOLETE 	      INSERTED32(EXTRACTED32(val_ra, 24, 31), 8, 15) |
# OBSOLETE 	      INSERTED32(EXTRACTED32(GPR[ra + 1], 8, 15), 16, 23) |
# OBSOLETE 	      INSERTED32(EXTRACTED32(GPR[ra + 1], 24, 31), 24, 31);
# OBSOLETE 	STORE(rb + src, 4, mem);
# OBSOLETE 
# OBSOLETE _IMEM,10101,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:ST4HB
# OBSOLETE "st4hb r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "st4hb r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_st4hb(_SD, RA, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 4);
# OBSOLETE _IMEM,10101,10,6.RA,6.RB,_IMM32:IMEM:long:mu:ST4HB long
# OBSOLETE "st4hb r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_st4hb(_SD, RA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // STB
# OBSOLETE 
# OBSOLETE void::function::do_stb:unsigned32 ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	STORE(rb + src, 1, EXTRACTED32(ra, 24, 31));
# OBSOLETE 
# OBSOLETE _IMEM,10000,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:STB
# OBSOLETE "stb r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "stb r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_stb(_SD, val_Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 1);
# OBSOLETE _IMEM,10000,10,6.RA,6.RB,_IMM32:IMEM:long:mu:STB long
# OBSOLETE "stb r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_stb(_SD, val_Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // STH
# OBSOLETE 
# OBSOLETE void::function::do_sth:unsigned32 ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	STORE(rb + src, 2, EXTRACTED32(ra, 16, 31));
# OBSOLETE 
# OBSOLETE _IMEM,10010,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:STH
# OBSOLETE "sth r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "sth r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_sth(_SD, val_Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 2);
# OBSOLETE _IMEM,10010,10,6.RA,6.RB,_IMM32:IMEM:long:mu:STH long
# OBSOLETE "sth r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_sth(_SD, val_Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // STHH
# OBSOLETE 
# OBSOLETE void::function::do_sthh:unsigned32 ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	STORE(rb + src, 2, EXTRACTED32(ra, 0, 15));
# OBSOLETE 
# OBSOLETE _IMEM,10001,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:STHH
# OBSOLETE "sthh r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "sthh r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_sthh(_SD, val_Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 2);
# OBSOLETE _IMEM,10001,10,6.RA,6.RB,_IMM32:IMEM:long:mu:STHH long
# OBSOLETE "sthh r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_sthh(_SD, val_Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // STW
# OBSOLETE 
# OBSOLETE void::function::do_stw:unsigned32 ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	STORE(rb + src, 4, ra);
# OBSOLETE 
# OBSOLETE _IMEM,10100,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:STW
# OBSOLETE "stw r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "stw r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_stw(_SD, val_Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 4);
# OBSOLETE _IMEM,10100,10,6.RA,6.RB,_IMM32:IMEM:long:mu:STW long
# OBSOLETE "stw r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_stw(_SD, val_Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SUB
# OBSOLETE 
# OBSOLETE void::function::do_sub:unsigned32 *ra, unsigned32 rb, unsigned32 imm
# OBSOLETE 	ALU_BEGIN(rb);
# OBSOLETE 	ALU_SUBB(imm);
# OBSOLETE 	ALU_END(ra);
# OBSOLETE 
# OBSOLETE _IALU1,00010,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:SUB
# OBSOLETE "sub r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_sub (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,00010,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:SUB imm
# OBSOLETE "sub r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_sub (_SD, Ra, Rb, imm);
# OBSOLETE _IALU1,00010,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:SUB imm long
# OBSOLETE "sub r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_sub (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SUB2H
# OBSOLETE 
# OBSOLETE void::function::do_sub2h:unsigned32 *ra, unsigned32 rb, unsigned32 imm
# OBSOLETE 	unsigned16 high = VH2_4(rb) - VH2_4(imm);
# OBSOLETE 	unsigned16 low  = VL2_4(rb) - VL2_4(imm);
# OBSOLETE 	WRITE32_QUEUE (ra, (high << 16) | low);
# OBSOLETE 
# OBSOLETE _IALU1,00011,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:SUB2H
# OBSOLETE "sub2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_sub2h (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,00011,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:SUB2H imm
# OBSOLETE "sub2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_sub2h (_SD, Ra, Rb, immHL);
# OBSOLETE _IALU1,00011,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:SUB2H imm long
# OBSOLETE "sub2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_sub2h (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SUBB
# OBSOLETE 
# OBSOLETE void::function::do_subb:unsigned32 *ra, unsigned32 rb, unsigned32 imm
# OBSOLETE 	ALU_BEGIN(rb);
# OBSOLETE 	ALU_SUBB_B(imm, ALU_CARRY);
# OBSOLETE 	ALU_END(ra);
# OBSOLETE 	
# OBSOLETE _IALU1,00101,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:SUBB
# OBSOLETE "subb r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_subb (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,00101,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:SUBB imm
# OBSOLETE "subb r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_subb (_SD, Ra, Rb, imm);
# OBSOLETE _IALU1,00101,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:SUBB imm long
# OBSOLETE "subb r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_subb (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SUBHppp
# OBSOLETE 
# OBSOLETE void::function::do_subh_ppp:int ppp, unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	switch (ppp) {
# OBSOLETE 	case 0x0: /* LLL */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VL2_4(rb));
# OBSOLETE 	  ALU16_SUBB(VL2_4(src));
# OBSOLETE 	  ALU16_END(ra, 0);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x1: /* LLH */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VL2_4(rb));
# OBSOLETE 	  ALU16_SUBB(VH2_4(src));
# OBSOLETE 	  ALU16_END(ra, 0);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x2: /* LHL */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VH2_4(rb));
# OBSOLETE 	  ALU16_SUBB(VL2_4(src));
# OBSOLETE 	  ALU16_END(ra, 0);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x3: /* LHH */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VH2_4(rb));
# OBSOLETE 	  ALU16_SUBB(VH2_4(src));
# OBSOLETE 	  ALU16_END(ra, 0);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x4: /* HLL */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VL2_4(rb));
# OBSOLETE 	  ALU16_SUBB(VL2_4(src));
# OBSOLETE 	  ALU16_END(ra, 1);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x5: /* HLH */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VL2_4(rb));
# OBSOLETE 	  ALU16_SUBB(VH2_4(src));
# OBSOLETE 	  ALU16_END(ra, 1);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x6: /* HHL */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VH2_4(rb));
# OBSOLETE 	  ALU16_SUBB(VL2_4(src));
# OBSOLETE 	  ALU16_END(ra, 1);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x7: /* HHH */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VH2_4(rb));
# OBSOLETE 	  ALU16_SUBB(VH2_4(src));
# OBSOLETE 	  ALU16_END(ra, 1);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	default:
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "do_subh_ppp - internal error - bad switch");
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _IALU1,11,ppp,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:SUBHppp
# OBSOLETE "subh%s<ppp> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_subh_ppp(_SD, ppp, Ra, Rb, Rc);
# OBSOLETE _IALU1,11,ppp,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:SUBHppp imm
# OBSOLETE "subh%s<ppp> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_subh_ppp(_SD, ppp, Ra, Rb, immHL);
# OBSOLETE _IALU1,11,ppp,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:SUBHppp imm long
# OBSOLETE "subh%s<ppp> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_subh_ppp(_SD, ppp, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // TRAP
# OBSOLETE 
# OBSOLETE address_word::function::do_trap:address_word trap_vector, address_word nia
# OBSOLETE 	/* Steal trap 31 for doing system calls */
# OBSOLETE 	/* System calls are defined in libgloss/d30v/syscall.h.  */
# OBSOLETE 	if (trap_vector == EIT_VB + 0x20 + (31 << 3))
# OBSOLETE 	  {
# OBSOLETE 	    enum { PARM1 = 2, PARM2, PARM3, PARM4, FUNC };
# OBSOLETE 	    if (GPR[FUNC] == 1)		/* exit */
# OBSOLETE 	      {
# OBSOLETE 	        sim_engine_halt (sd, STATE_CPU (sd, 0), NULL, cia, sim_exited,
# OBSOLETE 		  	         GPR[PARM1]);
# OBSOLETE 	        return -1; /* dummy */
# OBSOLETE 	      }
# OBSOLETE 	    else
# OBSOLETE 	      {
# OBSOLETE 		CB_SYSCALL syscall;
# OBSOLETE 
# OBSOLETE 		CB_SYSCALL_INIT (&syscall);
# OBSOLETE 		syscall.arg1 = GPR[PARM1];
# OBSOLETE 		syscall.arg2 = GPR[PARM2];
# OBSOLETE 		syscall.arg3 = GPR[PARM3];
# OBSOLETE 		syscall.arg4 = GPR[PARM4];
# OBSOLETE 		syscall.func = GPR[FUNC];
# OBSOLETE 		syscall.p1 = (PTR) SD;
# OBSOLETE 		syscall.read_mem = d30v_read_mem;
# OBSOLETE 		syscall.write_mem = d30v_write_mem;
# OBSOLETE 
# OBSOLETE 		WRITE32_QUEUE (&GPR[PARM1],
# OBSOLETE 			       ((cb_syscall (STATE_CALLBACK (SD), &syscall)
# OBSOLETE 				 == CB_RC_OK)
# OBSOLETE 				? syscall.result
# OBSOLETE 				: -syscall.errcode));
# OBSOLETE 		return nia;
# OBSOLETE 	      }
# OBSOLETE 	  }
# OBSOLETE 	else if (TRACE_TRAP_P)
# OBSOLETE 	  {
# OBSOLETE 	    int reg, i;
# OBSOLETE 	    sim_io_eprintf (sd, "\nTrap %ld:\n", (long) ((trap_vector - (EIT_VB + 0x20)) >> 3));
# OBSOLETE 	    for (reg = 0; reg < NR_GENERAL_PURPOSE_REGISTERS; reg += 8)
# OBSOLETE 	      {
# OBSOLETE 		sim_io_eprintf (sd, "r%.2d  - r%.2d: ", reg, reg+7);
# OBSOLETE 		for (i = 0; i < 8; i++)
# OBSOLETE 		  sim_io_eprintf (sd, " 0x%.8lx", (long) GPR[reg+i]);
# OBSOLETE 		sim_io_eprintf (sd, "\n");
# OBSOLETE 	      }
# OBSOLETE 
# OBSOLETE 	    for (reg = 0; reg < 16; reg += 8)
# OBSOLETE 	      {
# OBSOLETE 		sim_io_eprintf (sd, "cr%.2d - cr%.2d:", reg, reg+7);
# OBSOLETE 		for (i = 0; i < 8; i++)
# OBSOLETE 		  sim_io_eprintf (sd, " 0x%.8lx", (long) CREG[reg+i]);
# OBSOLETE 		sim_io_eprintf (sd, "\n");
# OBSOLETE 	      }
# OBSOLETE 
# OBSOLETE 	    sim_io_eprintf (sd, "a0   - a1:  ");
# OBSOLETE 	    for (reg = 0; reg < NR_ACCUMULATORS; reg++)
# OBSOLETE 	      sim_io_eprintf (sd, " 0x%.8lx 0x%.8lx",
# OBSOLETE 			      (long)EXTRACTED64(ACC[reg], 0, 31),
# OBSOLETE 			      (long)EXTRACTED64(ACC[reg], 32, 63));
# OBSOLETE 	    sim_io_eprintf (sd, "\n");
# OBSOLETE 
# OBSOLETE 	    sim_io_eprintf (sd, "f0   - f7:  ");
# OBSOLETE 	    sim_io_eprintf (sd, "     (f0) %d", (int) PSW_VAL(PSW_F0));
# OBSOLETE 	    sim_io_eprintf (sd, "     (f1) %d", (int) PSW_VAL(PSW_F1));
# OBSOLETE 	    sim_io_eprintf (sd, "     (f2) %d", (int) PSW_VAL(PSW_F2));
# OBSOLETE 	    sim_io_eprintf (sd, "     (f3) %d", (int) PSW_VAL(PSW_F3));
# OBSOLETE 	    sim_io_eprintf (sd, "      (s) %d", (int) PSW_VAL(PSW_S));
# OBSOLETE 	    sim_io_eprintf (sd, "      (v) %d", (int) PSW_VAL(PSW_V));
# OBSOLETE 	    sim_io_eprintf (sd, "     (va) %d", (int) PSW_VAL(PSW_VA));
# OBSOLETE 	    sim_io_eprintf (sd, "      (c) %d\n", (int) PSW_VAL(PSW_C));
# OBSOLETE 
# OBSOLETE 	    sim_io_eprintf (sd, "pswh:       ");
# OBSOLETE 	    sim_io_eprintf (sd, "     (sm) %d", (int) PSW_VAL(PSW_SM));
# OBSOLETE 	    sim_io_eprintf (sd, "     (ea) %d", (int) PSW_VAL(PSW_EA));
# OBSOLETE 	    sim_io_eprintf (sd, "     (ie) %d", (int) PSW_VAL(PSW_IE));
# OBSOLETE 	    sim_io_eprintf (sd, "     (rp) %d", (int) PSW_VAL(PSW_RP));
# OBSOLETE 	    sim_io_eprintf (sd, "     (md) %d", (int) PSW_VAL(PSW_MD));
# OBSOLETE 
# OBSOLETE 	    if (PSW_VAL(PSW_DB))
# OBSOLETE 	      sim_io_eprintf (sd, "     (db) %d", (int) PSW_VAL(PSW_DB));
# OBSOLETE 
# OBSOLETE 	    if (PSW_VAL(PSW_DS))
# OBSOLETE 	      sim_io_eprintf (sd, "     (ds) %d", (int) PSW_VAL(PSW_DS));
# OBSOLETE 
# OBSOLETE 	    sim_io_eprintf (sd, "\n");
# OBSOLETE 	    return nia;
# OBSOLETE 	  }
# OBSOLETE 	else
# OBSOLETE 	  {
# OBSOLETE 	    if(PSW_VAL(PSW_RP) && RPT_E == cia)
# OBSOLETE 	      {
# OBSOLETE 		WRITE32_QUEUE (&bPC, RPT_S);
# OBSOLETE 		if (RPT_C == 0)
# OBSOLETE 		  PSW_SET (PSW_RP, 0);
# OBSOLETE 	      }
# OBSOLETE 	    else
# OBSOLETE 	      WRITE32_QUEUE (&bPC, cia + 8);
# OBSOLETE 	    DID_TRAP = 1;
# OBSOLETE 	    return trap_vector;
# OBSOLETE 	  }
# OBSOLETE 
# OBSOLETE _BRA,01001,00,6.**,6.**,6.RC:BRA:short:mu:TRAP
# OBSOLETE "trap r<RC>"
# OBSOLETE 	nia = do_trap (_SD, EIT_VB + 0x20 + MASKED32(Rc, 24, 28), nia);
# OBSOLETE _BRA,01001,10,6.**,6.**,_IMM6:BRA:short:mu:TRAP imm
# OBSOLETE "trap <imm>"
# OBSOLETE 	nia = do_trap (_SD, EIT_VB + 0x20 + (imm_5 << 3), nia);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // XOR
# OBSOLETE 
# OBSOLETE _LOGIC,11011,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:XOR
# OBSOLETE "xor r<RA>, r<RB>, r<RC>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb ^ Rc);
# OBSOLETE _LOGIC,11011,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:XOR imm
# OBSOLETE "xor r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb ^ imm);
# OBSOLETE _LOGIC,11011,10,6.RA,6.RB,_IMM32:LOGIC:long:iu,mu:XOR imm long
# OBSOLETE "xor r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb ^ imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // XORFG
# OBSOLETE 
# OBSOLETE _LOGIC,01011,00,***,3.FA,***,3.FB,***,3.FC:LOGIC:short:iu,mu:XORFG
# OBSOLETE "xorfg f<FA>, f<FB>, f<FC>"
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, PSW_FLAG_VAL(FB) ^ PSW_FLAG_VAL(FC));
# OBSOLETE _LOGIC,01011,10,***,3.FA,***,3.FB,_IMM6:LOGIC:short:iu,mu:XORFG imm
# OBSOLETE "xorfg f<FA>, f<FB>, <imm_6>"
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, PSW_FLAG_VAL(FB) ^ (imm_6 & 1));
@


1.3
log
@Obsolete the d30v.
@
text
@@


1.2
log
@Change minimum loop size limit to 0x10 (103792)
@
text
@d1 2421
a2421 2424
//  -*- C -*-
//  Mitsubishi Electric Corp. D30V Simulator.
//  Copyright (C) 1997, Free Software Foundation, Inc.
//  Contributed by Cygnus Solutions Inc.
//
//  This file is part of GDB, the GNU debugger.
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//


define( _BRA,  `1.*,CCC,000')
define( _LOGIC, `1.*,CCC,001')
define( _IMEM, `1.*,CCC,010')
define( _IALU1, `1.*,CCC,100')
define(_IALU2, `1.*,CCC,101')



define(_IMM6, `6.IMM_6S')
define(_IMM12, `12.IMM_12S')
define(_IMM18, `18.IMM_18S')
define(_IMM32, `6.IMM_6L,*,000,8.IMM_8L,00,18.IMM_18L')



// The following is called when ever an illegal instruction is
// encountered
::internal::illegal
	sim_io_eprintf (sd, "illegal instruction at 0x%lx\n", (long) cia);
	sim_engine_halt (SD, CPU, NULL, cia, sim_signalled, SIM_SIGILL);

// The following is called when ever an instruction in the wrong
// slot is encountered.
::internal::wrong_slot
	sim_io_eprintf (sd, "wrong slot at 0x%lx\n", (long) cia);
	sim_engine_halt (SD, CPU, NULL, cia, sim_signalled, SIM_SIGILL);



// Something illegal that can be used to contact the simulator emul
// library.
define(_EMUL, `1.*,CCC,111')

void::function::do_emul:int imm
	/* temp hack - later replace with real interface */
	enum {
	  param1 = 2, param2, param3, param4
	};
	switch (imm) {
	case 0:
	  {
	    sim_engine_abort (SD, CPU, cia, "UNIX call emulation unsupported");
	    break;
	  }
	case 1:
	  /* Trap 1 - prints a string */
	  {
	    address_word str = GPR[param1];
	    char chr;
	    while (1) {
	      chr = MEM (unsigned, str, 1);
	    if (chr == '\0') break;
	      sim_io_write_stdout (sd, &chr, sizeof chr);
	      str++;
	    }
	    break;
	  }
	case 3:
	  /* Trap 3 - writes a character */
	  {
	    char chr = GPR[param1];
	    sim_io_write_stdout (sd, &chr, sizeof chr);
	    break;
	  }
	case 4:
	  /* Trap 4 exits with status in [param1] */
	  {
	    sim_engine_halt (SD, CPU, NULL, cia, sim_exited, GPR[param1]);
	    break;
	  }
	case 5:
	  /* Trap 5 breakpoints.  If the breakpoint system knows about this, it
	     won't return.  Otherwise, we fall through to treat this as an
	     unknown instruction.  */
	  {
	    sim_handle_breakpoint (SD, CPU, cia);
	  /* Fall through to default case.*/
	  }
	default:
	  sim_engine_abort (SD, CPU, cia, "Unknown monitor call %d", imm);
	}

_EMUL,00000,00,6.*,6.*,IMM_6S:EMUL:short,emul:iu,mu:EMUL
"syscall <imm>"
	do_emul (_SD, imm);
_BRA,00000,00,6.**,6.**,_IMM32:BRA:long:iu,mu:EMUL long
"syscall <imm>"
	do_emul (_SD, imm);

// ABS

_IALU1,01000,00,6.RA,6.RB,6.**:IALU1:short:iu,mu:ABS
"abs r<RA>, r<RB>"
	WRITE32_QUEUE (Ra, abs(Rb));



// ADD

void::function::do_add:unsigned32 *ra, unsigned32 rb, unsigned32 imm
	ALU_BEGIN(rb);
	ALU_ADDC(imm);
	ALU_END(ra);

_IALU1,00000,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:ADD
"add r<RA>, r<RB>, r<RC>"
	do_add (_SD, Ra, Rb, Rc);
_IALU1,00000,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:ADD imm
"add r<RA>, r<RB>, <imm>"
	do_add (_SD, Ra, Rb, imm);
_IALU1,00000,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:ADD imm long
"add r<RA>, r<RB>, <imm>"
	do_add (_SD, Ra, Rb, imm);



// ADD2H

void::function::do_add2h:signed32 *ra, signed32 rb, signed32 imm
	unsigned16 ah2 = VH2_4(rb) + VH2_4(imm);
	unsigned16 al2 = VL2_4(rb) + VL2_4(imm);
	WRITE32_QUEUE (ra, (ah2 << 16) | al2);

_IALU1,00001,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:ADD2H
"add2h r<RA>, r<RB>, r<RC>"
	do_add2h (_SD, Ra, Rb, Rc);
_IALU1,00001,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:ADD2H imm
"add2h r<RA>, r<RB>, <imm>"
	do_add2h (_SD, Ra, Rb, immHL);
_IALU1,00001,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:ADD2H imm long
"add2h r<RA>, r<RB>, <imm>"
	do_add2h (_SD, Ra, Rb, imm);



// ADDC

void::function::do_addc:unsigned32 *ra, unsigned32 rb, unsigned32 imm
	ALU_BEGIN(rb);
	ALU_ADDC_C(imm, ALU_CARRY);
	ALU_END(ra);

_IALU1,00100,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:ADDC
"addc r<RA>, r<RB>, r<RC>"
	do_addc (_SD, Ra, Rb, Rc);
_IALU1,00100,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:ADDC imm
"addc r<RA>, r<RB>, <imm>"
	do_addc (_SD, Ra, Rb, imm);
_IALU1,00100,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:ADDC imm long
"addc r<RA>, r<RB>, <imm>"
	do_addc (_SD, Ra, Rb, imm);



// ADDHppp

void::function::do_addh_ppp:int ppp, unsigned32 *ra, unsigned32 rb, unsigned32 src
	switch (ppp) {
	case 0x0: /* LLL */
	  {
	  ALU16_BEGIN(VL2_4(rb));
	  ALU16_ADDC(VL2_4(src));
	  ALU16_END(ra, 0);
	  }
	  break;
	case 0x1: /* LLH */
	  {
	  ALU16_BEGIN(VL2_4(rb));
	  ALU16_ADDC(VH2_4(src));
	  ALU16_END(ra, 0);
	  }
	  break;
	case 0x2: /* LHL */
	  {
	  ALU16_BEGIN(VH2_4(rb));
	  ALU16_ADDC(VL2_4(src));
	  ALU16_END(ra, 0);
	  }
	  break;
	case 0x3: /* LHH */
	  {
	  ALU16_BEGIN(VH2_4(rb));
	  ALU16_ADDC(VH2_4(src));
	  ALU16_END(ra, 0);
	  }
	  break;
	case 0x4: /* HLL */
	  {
	  ALU16_BEGIN(VL2_4(rb));
	  ALU16_ADDC(VL2_4(src));
	  ALU16_END(ra, 1);
	  }
	  break;
	case 0x5: /* HLH */
	  {
	  ALU16_BEGIN(VL2_4(rb));
	  ALU16_ADDC(VH2_4(src));
	  ALU16_END(ra, 1);
	  }
	  break;
	case 0x6: /* HHL */
	  {
	  ALU16_BEGIN(VH2_4(rb));
	  ALU16_ADDC(VL2_4(src));
	  ALU16_END(ra, 1);
	  }
	  break;
	case 0x7: /* HHH */
	  {	
	  ALU16_BEGIN(VH2_4(rb));
	  ALU16_ADDC(VH2_4(src));
	  ALU16_END(ra, 1);
	  }
	  break;
	default:
	  sim_engine_abort (SD, CPU, cia, "do_addh_ppp - internal error - bad switch");
	}
::%s::ppp:int ppp
	switch (ppp)
	  {
	  case 0x0: return "lll";
	  case 0x1: return "llh";
	  case 0x2: return "lhl";
	  case 0x3: return "lhh";
	  case 0x4: return "hll";
	  case 0x5: return "hlh";
	  case 0x6: return "hhl";
	  case 0x7: return "hhh";
	  default: return "?";
	  }

_IALU1,10,ppp,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:ADDHppp
"addh%s<ppp> r<RA>, r<RB>, r<RC>"
	do_addh_ppp(_SD, ppp, Ra, Rb, Rc);
_IALU1,10,ppp,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:ADDHppp imm
"addh%s<ppp> r<RA>, r<RB>, <imm>"
	do_addh_ppp(_SD, ppp, Ra, Rb, immHL);
_IALU1,10,ppp,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:ADDHppp imm long
"addh%s<ppp> r<RA>, r<RB>, <imm>"
	do_addh_ppp(_SD, ppp, Ra, Rb, imm);



// ADDS

void::function::do_adds:unsigned32 *ra, unsigned32 rb, unsigned32 imm
	ALU_BEGIN(rb);
	ALU_ADDC(EXTRACTED32(imm, 0, 0));
	ALU_END(ra);

_IALU1,00110,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:ADDS
"adds r<RA>, r<RB>, r<RC>"
	do_adds (_SD, Ra, Rb, Rc);
_IALU1,00110,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:ADDS imm
"adds r<RA>, r<RB>, <imm>"
	do_adds (_SD, Ra, Rb, imm);
_IALU1,00110,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:ADDS imm long
"adds r<RA>, r<RB>, <imm>"
	do_adds (_SD, Ra, Rb, imm);



// ADDS2H

void::function::do_adds2h:unsigned32 *ra, unsigned32 rb, unsigned32 immHL
	unsigned16 high = VH2_4(rb) + EXTRACTED32(immHL, 0, 0);
	unsigned16 low = VL2_4(rb) + EXTRACTED32(immHL, 16, 16);
	WRITE32_QUEUE (ra, (high << 16) | low);

_IALU1,00111,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:ADDS2H
"adds2h r<RA>, r<RB>, r<RC>"
	do_adds2h (_SD, Ra, Rb, Rc);
_IALU1,00111,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:ADDS2H imm
"adds2h r<RA>, r<RB>, <imm>"
	do_adds2h (_SD, Ra, Rb, immHL);
_IALU1,00111,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:ADDS2H imm long
"adds2h r<RA>, r<RB>, <imm>"
	do_adds2h (_SD, Ra, Rb, imm);



// AND

_LOGIC,11000,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:AND
"and r<RA>, r<RB>, r<RC>"
	WRITE32_QUEUE (Ra, Rb & Rc);
_LOGIC,11000,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:AND imm
"and r<RA>, r<RB>, <imm>"
	WRITE32_QUEUE (Ra, Rb & imm);
_LOGIC,11000,10,6.RA,6.RB,_IMM32:LOGIC:long:iu,mu:AND imm long
"and r<RA>, r<RB>, <imm>"
	WRITE32_QUEUE (Ra, Rb & imm);


// ANDFG

_LOGIC,01000,00,***,3.FA,***,3.FB,***,3.FC:LOGIC:short:iu,mu:Logical AND Flags
"andfg f<FA>, f<FB>, f<FC>"
	PSW_FLAG_SET_QUEUE(FA, PSW_FLAG_VAL(FB) & PSW_FLAG_VAL(FC));
_LOGIC,01000,10,***,3.FA,***,3.FB,_IMM6:LOGIC:short:iu,mu:Logical AND Flags imm
"andfg f<FA>, f<FB>, <imm_6>"
	PSW_FLAG_SET_QUEUE(FA, PSW_FLAG_VAL(FB) & (imm_6 & 1));



// AVG

void::function::do_avg:unsigned32 *ra, unsigned32 rb, unsigned32 imm
	WRITE32_QUEUE (ra, ((signed64)(signed32)rb + (signed64)(signed32)imm + 1) >> 1);

_IALU1,01010,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:AVG
"avg r<RA>, r<RB>, r<RC>"
	do_avg (_SD, Ra, Rb, Rc);
_IALU1,01010,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:AVG imm
"avg r<RA>, r<RB>, <imm>"
	do_avg (_SD, Ra, Rb, imm);
_IALU1,01010,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:AVG imm long
"avg r<RA>, r<RB>, <imm>"
	do_avg (_SD, Ra, Rb, imm);



// AVG2H

void::function::do_avg2h:unsigned32 *ra, unsigned32 rb, unsigned32 imm
	unsigned16 high = ((signed32)(signed16)VH2_4(rb) + (signed32)(signed16)VH2_4(imm) + 1) >> 1;
	unsigned16 low  = ((signed32)(signed16)VL2_4(rb) + (signed32)(signed16)VL2_4(imm) + 1) >> 1;
	WRITE32_QUEUE (ra, (high << 16) | low);

_IALU1,01011,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:AVG2H
"avg2h r<RA>, r<RB>, r<RC>"
	do_avg2h (_SD, Ra, Rb, Rc);
_IALU1,01011,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:AVG2H imm
"avg2h r<RA>, r<RB>, <imm>"
	do_avg2h (_SD, Ra, Rb, immHL);
_IALU1,01011,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:AVG2H imm long
"avg2h r<RA>, r<RB>, <imm>"
	do_avg2h (_SD, Ra, Rb, imm);



// BCLR

_LOGIC,00011,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:BCLR
"bclr r<RA>, r<RB>, r<RC>"
	WRITE32_QUEUE(Ra, Rb & ~BIT32((Rc) % 32));
_LOGIC,00011,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:BCLR imm
"bclr r<RA>, r<RB>, <imm>"
	WRITE32_QUEUE(Ra, Rb & ~BIT32((imm) % 32));



// BNOT

_LOGIC,00001,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:BNOT
"bnot r<RA>, r<RB>, r<RC>"
	WRITE32_QUEUE (Ra, Rb ^ BIT32((Rc) % 32));
_LOGIC,00001,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:BNOT imm
"bnot r<RA>, r<RB>, <imm>"
	WRITE32_QUEUE (Ra, Rb ^ BIT32((imm) % 32));



// BRA

_BRA,00000,00,6.**,6.**,6.RC:BRA:short:mu:BRA
"bra r<RC>"
	nia = cia + pcdisp;
_BRA,00000,10,_IMM18:BRA:short:mu:BRA imm
"bra <pcdisp>"
	nia = cia + pcdisp;
_BRA,00000,10,6.**,6.**,_IMM32:BRA:long:mu:BRA imm long
"bra <pcdisp>"
	nia = cia + pcdisp;



// BRATNZ

_BRA,00100,01,6.RA,6.**,6.RC:BRA:short:mu:BRATNZ
"bratnz r<RC>"
	if (*Ra != 0)
	  nia = cia + pcdisp;
_BRA,00100,11,6.RA,_IMM12:BRA:short:mu:BRATNZ imm
"bratnz <pcdisp>"
	if (*Ra != 0)
	  nia = cia + pcdisp;
_BRA,00100,11,6.RA,6.**,_IMM32:BRA:long:mu:BRATNZ imm long
"bratnz <pcdisp>"
	if (*Ra != 0)
	  nia = cia + pcdisp;



// BRATZR

_BRA,00100,00,6.RA,6.**,6.RC:BRA:short:mu:BRATZR
"bratzr r<RC>"
	if (val_Ra == 0)
	  nia = cia + pcdisp;
_BRA,00100,10,6.RA,_IMM12:BRA:short:mu:BRATZR imm
"bratzr <pcdisp>"
	if (val_Ra == 0)
	  nia = cia + pcdisp;
_BRA,00100,10,6.RA,6.**,_IMM32:BRA:long:mu:BRATZR imm long
"bratzr <pcdisp>"
	if (val_Ra == 0)
	  nia = cia + pcdisp;



// BSET

_LOGIC,00010,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:BSET
"bset r<RA>, r<RB>, r<RC>"
	WRITE32_QUEUE (Ra, Rb | BIT32((Rc) % 32));
_LOGIC,00010,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:BSET imm
"bset r<RA>, r<RB>, <imm>"
	WRITE32_QUEUE (Ra, Rb | BIT32((imm) % 32));



// BSR

_BRA,00010,00,6.**,6.**,6.RC:BRA:short:mu:BSR
"bsr r<RC>"
	if (cia == RPT_E && PSW_VAL (PSW_RP))
	  WRITE32_QUEUE (&GPR[62], RPT_S);
	else
	  WRITE32_QUEUE (&GPR[62], cia + 8);
	nia = cia + pcdisp;
	if (TRACE_CALL_P)
	  TRACE_ACTION |= TRACE_ACTION_CALL;
_BRA,00010,10,_IMM18:BRA:short:mu:BSR imm
"bsr <pcdisp>"
	if (cia == RPT_E && PSW_VAL (PSW_RP))
	  WRITE32_QUEUE (&GPR[62], RPT_S);
	else
	  WRITE32_QUEUE (&GPR[62], cia + 8);
	nia = cia + pcdisp;
	if (TRACE_CALL_P)
	  TRACE_ACTION |= TRACE_ACTION_CALL;
_BRA,00010,10,6.**,6.**,_IMM32:BRA:long:mu:BSR imm long
"bsr <pcdisp>"
	if (cia == RPT_E && PSW_VAL (PSW_RP))
	  WRITE32_QUEUE (&GPR[62], RPT_S);
	else
	  WRITE32_QUEUE (&GPR[62], cia + 8);
	nia = cia + pcdisp;
	if (TRACE_CALL_P)
	  TRACE_ACTION |= TRACE_ACTION_CALL;


// BSRTNZ

_BRA,00110,01,6.RA,6.**,6.RC:BRA:short:mu:BSRTNZ
"bsrtnz r<RC>"
	if (val_Ra != 0) {
	  if (cia == RPT_E && PSW_VAL (PSW_RP))
	    WRITE32_QUEUE (&GPR[62], RPT_S);
	  else
	    WRITE32_QUEUE (&GPR[62], cia + 8);
	  nia = cia + pcdisp;
	  if (TRACE_CALL_P)
	    TRACE_ACTION |= TRACE_ACTION_CALL;
	}

_BRA,00110,11,6.RA,_IMM12:BRA:short:mu:BSRTNZ imm
"bsrtnz <pcdisp>"
	if (val_Ra != 0) {
	  if (cia == RPT_E && PSW_VAL (PSW_RP))
	    WRITE32_QUEUE (&GPR[62], RPT_S);
	  else
	    WRITE32_QUEUE (&GPR[62], cia + 8);
	  nia = cia + pcdisp;
	  if (TRACE_CALL_P)
	    TRACE_ACTION |= TRACE_ACTION_CALL;
	}

_BRA,00110,11,6.RA,6.**,_IMM32:BRA:long:mu:BSRTNZ imm long
"bsrtnz <pcdisp>"
	if (val_Ra != 0) {
	  if (cia == RPT_E && PSW_VAL (PSW_RP))
	    WRITE32_QUEUE (&GPR[62], RPT_S);
	  else
	    WRITE32_QUEUE (&GPR[62], cia + 8);
	  nia = cia + pcdisp;
	  if (TRACE_CALL_P)
	    TRACE_ACTION |= TRACE_ACTION_CALL;
	}


// BSRTZR

_BRA,00110,00,6.RA,6.**,6.RC:BRA:short:mu:BSRTZR
"bsrtzr r<RC>"
	if (val_Ra == 0) {
	  if (cia == RPT_E && PSW_VAL (PSW_RP))
	    WRITE32_QUEUE (&GPR[62], RPT_S);
	  else
	    WRITE32_QUEUE (&GPR[62], cia + 8);
	  nia = cia + pcdisp;
	  if (TRACE_CALL_P)
	    TRACE_ACTION |= TRACE_ACTION_CALL;
	}

_BRA,00110,10,6.RA,_IMM12:BRA:short:mu:BSRTZR imm
"bsrtzr <pcdisp>"
	if (val_Ra == 0) {
	  if (cia == RPT_E && PSW_VAL (PSW_RP))
	    WRITE32_QUEUE (&GPR[62], RPT_S);
	  else
	    WRITE32_QUEUE (&GPR[62], cia + 8);
	  nia = cia + pcdisp;
	  if (TRACE_CALL_P)
	    TRACE_ACTION |= TRACE_ACTION_CALL;
	}

_BRA,00110,10,6.RA,6.**,_IMM32:BRA:long:mu:BSRTZR imm long
"bsrtzr <pcdisp>"
	if (val_Ra == 0) {
	  if (cia == RPT_E && PSW_VAL (PSW_RP))
	    WRITE32_QUEUE (&GPR[62], RPT_S);
	  else
	    WRITE32_QUEUE (&GPR[62], cia + 8);
	  nia = cia + pcdisp;
	  if (TRACE_CALL_P)
	    TRACE_ACTION |= TRACE_ACTION_CALL;
	}


// BTST

_LOGIC,00000,00,***,3.FA,6.RB,6.RC:LOGIC:short:iu,mu:BTST
"btst f<FA>, r<RB>, r<RC>"
	int bit = (Rc) % 32;
	PSW_FLAG_SET_QUEUE(FA, MASKED32(Rb, bit, bit));
_LOGIC,00000,10,***,3.FA,6.RB,_IMM6:LOGIC:short:iu,mu:BTST imm
"btst f<FA>, r<RB>, <imm>"
	int bit = imm % 32;
	PSW_FLAG_SET_QUEUE(FA, MASKED32(Rb, bit, bit));



// CMPcc

void::function::do_cmp_cc:int cc, int fa, signed32 rb, signed32 rc
	int value = 0;
	switch (cc) {
	case 0: /* EQ */
	  value = (rb == rc);
	  break;
	case 1: /* NE */
	  value = (rb != rc);
	  break;
	case 2: /* GT */
	  value = (rb > rc);
	  break;
	case 3: /* GE */
	  value = (rb >= rc);
	  break;
	case 4: /* LT */
	  value = (rb < rc);
	  break;
	case 5: /* LE */
	  value = (rb <= rc);
	  break;
	case 6: /* PS */
	  value = ((rb >= 0) && (rc >= 0));
	  break;
	case 7: /* NG */
	  value = ((rb < 0) && (rc < 0));
	  break;
	default:
	  sim_engine_abort (SD, CPU, cia, "do_cmp_cc - internal error - bad switch (%d)", cc);
	}
	PSW_FLAG_SET_QUEUE(fa, value);

::%s::ccc:int ccc
	switch (ccc)
	  {
	  case 0: return "eq";
	  case 1: return "ne";
	  case 2: return "gt";
	  case 3: return "ge";
	  case 4: return "lt";
	  case 5: return "le";
	  case 6: return "ps";
	  case 7: return "ng";
	  default: return "?";
	  }

_LOGIC,01100,00,ccc,3.FA,6.RB,6.RC:LOGIC:short:iu,mu:CMPcc
"cmp%s<ccc> f<FA>, r<RB>, r<RC>"
	do_cmp_cc(_SD, ccc, FA, Rb, Rc);
_LOGIC,01100,10,ccc,3.FA,6.RB,_IMM6:LOGIC:short:iu,mu:CMPcc imm
"cmp%s<ccc> f<FA>, r<RB>, <imm>"
	do_cmp_cc(_SD, ccc, FA, Rb, imm);
_LOGIC,01100,10,ccc,3.FA,6.RB,_IMM32:LOGIC:long:iu,mu:CMPcc imm long
"cmp%s<ccc> f<FA>, r<RB>, <imm>"
	do_cmp_cc(_SD, ccc, FA, Rb, imm);



// CMPUcc

void::function::do_cmpu_cc:int cc, int fa, unsigned32 rb, unsigned32 rc
	int value = 0;
	switch (cc) {
	case 2: /* GT */
	  value = (rb > rc);
	  break;
	case 3: /* GE */
	  value = (rb >= rc);
	  break;
	case 4: /* LT */
	  value = (rb < rc);
	  break;
	case 5: /* LE */
	  value = (rb <= rc);
	  break;
	default:
	  sim_engine_abort (SD, CPU, cia, "do_cmpu_cc - internal error - bad switch (%d)", cc);
	}
	PSW_FLAG_SET_QUEUE(fa, value);

_LOGIC,01101,00,ccc,3.FA,6.RB,6.RC:LOGIC:short:iu,mu:CMPUcc
"cmpu%s<ccc> f<FA>, r<RB>, r<RC>"
	do_cmpu_cc(_SD, ccc, FA, Rb, Rc);
_LOGIC,01101,10,ccc,3.FA,6.RB,_IMM6:LOGIC:short:iu,mu:CMPUcc imm
"cmpu%s<ccc> f<FA>, r<RB>, <imm>"
	do_cmpu_cc(_SD, ccc, FA, Rb, imm_6u);
_LOGIC,01101,10,ccc,3.FA,6.RB,_IMM32:LOGIC:long:iu,mu:CMPUcc imm long
"cmpu%s<ccc> f<FA>, r<RB>, <imm>"
	do_cmpu_cc(_SD, ccc, FA, Rb, imm);



// DBRA

void::function::do_dbra:address_word pcdisp, unsigned32 ra
	PSW_SET_QUEUE (PSW_RP, 1);
	WRITE32_QUEUE (&RPT_C, 1);
	WRITE32_QUEUE (&RPT_S, cia + pcdisp);
	WRITE32_QUEUE (&RPT_E, cia + (ra & ~0x7));

_BRA,10000,00,6.RA,6.**,6.RC:BRA:short:mu:DBRA
"dbra r<RA>, r<RC>"
	do_dbra(_SD, pcdisp, val_Ra);
_BRA,10000,10,6.RA,_IMM12:BRA:short:mu:DBRA imm
"dbra r<RA>, <pcdisp>"
	do_dbra(_SD, pcdisp, val_Ra);
_BRA,10000,10,6.RA,6.**,_IMM32:BRA:long:mu:DBRA imm long
"dbra r<RA>, <pcdisp>"
	do_dbra(_SD, pcdisp, val_Ra);



// DBRAI

void::function::do_dbrai:address_word pcdisp, unsigned32 imm
	PSW_SET_QUEUE (PSW_RP, 1);
	WRITE32_QUEUE (&RPT_C, 1);
	WRITE32_QUEUE (&RPT_S, cia + pcdisp);
	WRITE32_QUEUE (&RPT_E, cia + (imm << 3));

_BRA,10100,00,6.IMM_6,6.**,6.RC:BRA:short:mu:DBRAI
"dbrai <IMM_6>, r<RC>"
	do_dbrai(_SD, pcdisp, IMM_6);
_BRA,10100,10,6.IMM_6,_IMM12:BRA:short:mu:DBRAI imm
"dbrai <IMM_6>, <pcdisp>"
	do_dbrai(_SD, pcdisp, IMM_6);
_BRA,10100,10,6.IMM_6,6.**,_IMM32:BRA:long:mu:DBRAI imm long
"dbrai <IMM_6>, <pcdisp>"
	do_dbrai(_SD, pcdisp, IMM_6);



// DBSR

void::function::do_dbsr:address_word pcdisp, unsigned32 ra
	PSW_SET_QUEUE (PSW_RP, 1);
	WRITE32_QUEUE (&RPT_C, 1);
	WRITE32_QUEUE (&RPT_S, cia + pcdisp);
	WRITE32_QUEUE (&RPT_E, cia + ra);
	WRITE32_QUEUE (&GPR[62], cia + ra + 8);

_BRA,10010,00,6.RA,6.**,6.RC:BRA:short:mu:DBSR
"dbsr r<RA>, r<RC>"
	do_dbsr(_SD, pcdisp, val_Ra);
_BRA,10010,10,6.RA,_IMM12:BRA:short:mu:DBSR imm
"dbsr r<RA>, <pcdisp>"
	do_dbsr(_SD, pcdisp, val_Ra);
_BRA,10010,10,6.RA,6.**,_IMM32:BRA:long:mu:DBSR imm long
"dbsr r<RA>, <pcdisp>"
	do_dbsr(_SD, pcdisp, val_Ra);



// DBSRI

void::function::do_dbsri:address_word pcdisp, unsigned32 imm
	PSW_SET_QUEUE (PSW_RP, 1);
	WRITE32_QUEUE (&RPT_C, 1);
	WRITE32_QUEUE (&RPT_S, cia + pcdisp);
	WRITE32_QUEUE (&RPT_E, cia + (imm << 3));
	WRITE32_QUEUE (&GPR[62], cia + (imm << 3) + 8);

_BRA,10110,00,6.IMM_6,6.**,6.RC:BRA:short:mu:DBSRI
"dbsri <IMM_6>, r<RC>"
	do_dbsri(_SD, pcdisp, IMM_6);
_BRA,10110,10,6.IMM_6,_IMM12:BRA:short:mu:DBSRI imm
"dbsri <IMM_6>, <pcdisp>"
	do_dbsri(_SD, pcdisp, IMM_6);
_BRA,10110,10,6.IMM_6,6.**,_IMM32:BRA:long:mu:DBSRI imm long
"dbsri <IMM_6>, <pcdisp>"
	do_dbsri(_SD, pcdisp, IMM_6);



// DBT


_BRA,01011,00,6.**,6.**,6.**:BRA:short:mu:DBT
"dbt"
	if (cia == RPT_E && PSW_VAL (PSW_RP))
	  {
	    WRITE32_QUEUE (&DPC, RPT_S);
	    if (RPT_C == 0)
	      PSW_SET (PSW_RP, 0);
	  }
	else
	  WRITE32_QUEUE (&DPC, cia + 8);
	DID_TRAP = 2;
	nia = 0xfffff120; /* debug_trap_address */

// DJMP

void::function::do_djmp:address_word pcdisp, unsigned32 ra
	PSW_SET_QUEUE (PSW_RP, 1);
	WRITE32_QUEUE (&RPT_C, 1);
	WRITE32_QUEUE (&RPT_S, pcdisp);
	WRITE32_QUEUE (&RPT_E, cia + (ra & ~0x7));

_BRA,10001,00,6.RA,6.**,6.RC:BRA:short:mu:DJMP
"djmp r<RA>, r<RC>"
	do_djmp(_SD, pcdisp, val_Ra);
_BRA,10001,10,6.RA,_IMM12:BRA:short:mu:DJMP imm
"djmp r<RA>, <pcdisp>"
	do_djmp(_SD, pcdisp, val_Ra);
_BRA,10001,10,6.RA,6.**,_IMM32:BRA:long:mu:DJMP imm long
"djmp r<RA>, <pcdisp>"
	do_djmp(_SD, pcdisp, val_Ra);



// DJMPI

void::function::do_djmpi:address_word pcdisp, unsigned32 imm
	PSW_SET_QUEUE (PSW_RP, 1);
	WRITE32_QUEUE (&RPT_C, 1);
	WRITE32_QUEUE (&RPT_S, pcdisp);
	WRITE32_QUEUE (&RPT_E, cia + (imm << 3));

_BRA,10101,00,6.IMM_6,6.**,6.RC:BRA:short:mu:DJMPI
"djmpi <IMM_6>, r<RC>"
	do_djmpi(_SD, pcdisp, IMM_6);
_BRA,10101,10,6.IMM_6,_IMM12:BRA:short:mu:DJMPI imm
"djmpi <IMM_6>, <pcdisp>"
	do_djmpi(_SD, pcdisp, IMM_6);
_BRA,10101,10,6.IMM_6,6.**,_IMM32:BRA:long:mu:DJMPI imm long
"djmpi <IMM_6>, <pcdisp>"
	do_djmpi(_SD, pcdisp, IMM_6);



// DJSR

void::function::do_djsr:address_word pcdisp, unsigned32 ra
	PSW_SET_QUEUE (PSW_RP, 1);
	WRITE32_QUEUE (&RPT_C, 1);
	WRITE32_QUEUE (&RPT_S, pcdisp);
	WRITE32_QUEUE (&RPT_E, cia + (ra & ~0x7));
	WRITE32_QUEUE (&GPR[62], cia + (ra & ~0x7) + 8);

_BRA,10011,00,6.RA,6.**,6.RC:BRA:short:mu:DJSR
"djsr r<RA>, r<RC>"
	do_djsr(_SD, pcdisp, val_Ra);
_BRA,10011,10,6.RA,_IMM12:BRA:short:mu:DJSR imm
"djsr r<RA>, <pcdisp>"
	do_djsr(_SD, pcdisp, val_Ra);
_BRA,10011,10,6.RA,6.**,_IMM32:BRA:long:mu:DJSR imm long
"djsr r<RA>, <pcdisp>"
	do_djsr(_SD, pcdisp, val_Ra);



// DJSRI

void::function::do_djsri:address_word pcdisp, unsigned32 imm
	PSW_SET_QUEUE (PSW_RP, 1);
	WRITE32_QUEUE (&RPT_C, 1);
	WRITE32_QUEUE (&RPT_S, pcdisp);
	WRITE32_QUEUE (&RPT_E, cia + (imm << 3));
	WRITE32_QUEUE (&GPR[62], cia + (imm << 3) + 8);

_BRA,10111,00,6.IMM_6,6.**,6.RC:BRA:short:mu:DJSRI
"djsri <IMM_6>, r<RC>"
	do_djsri(_SD, pcdisp, IMM_6);
_BRA,10111,10,6.IMM_6,_IMM12:BRA:short:mu:DJSRI imm
"djsri <IMM_6>, <pcdisp>"
	do_djsri(_SD, pcdisp, IMM_6);
_BRA,10111,10,6.IMM_6,6.**,_IMM32:BRA:long:mu:DJSRI imm long
"djsri <IMM_6>, <pcdisp>"
	do_djsri(_SD, pcdisp, IMM_6);



// JMP

_BRA,00001,00,6.**,6.**,6.RC:BRA:short:mu:JMP
"jmp r<RC>"
	nia = pcaddr;
	if (RC == 62 && TRACE_CALL_P)
	  TRACE_ACTION |= TRACE_ACTION_RETURN;
_BRA,00001,10,_IMM18:BRA:short:mu:JMP imm
"jmp <pcdisp>"
	nia = pcaddr;
_BRA,00001,10,6.**,6.**,_IMM32:BRA:long:mu:JMP imm long
"jmp <pcdisp>"
	nia = pcaddr;



// JMPTNZ

_BRA,00101,01,6.RA,6.**,6.RC:BRA:short:mu:JMPTNZ
"jmptnz r<RC>"
	if (val_Ra != 0)
	  nia = pcaddr;
_BRA,00101,11,6.RA,_IMM12:BRA:short:mu:JMPTNZ imm
"jmptnz <pcdisp>"
	if (val_Ra != 0)
	  nia = pcaddr;
_BRA,00101,11,6.RA,6.**,_IMM32:BRA:long:mu:JMPTNZ imm long
"jmptnz <pcdisp>"
	if (val_Ra != 0)
	  nia = pcaddr;



// JMPTZR

_BRA,00101,00,6.RA,6.**,6.RC:BRA:short:mu:JMPTZR
"jmptzr r<RC>"
	if (val_Ra == 0)
	  nia = pcaddr;
_BRA,00101,10,6.RA,_IMM12:BRA:short:mu:JMPTZR imm
"jmptzr <pcdisp>"
	if (val_Ra == 0)
	  nia = pcaddr;
_BRA,00101,10,6.RA,6.**,_IMM32:BRA:long:mu:JMPTZR imm long
"jmptzr <pcdisp>"
	if (val_Ra == 0)
	  nia = pcaddr;



// JOINpp 

void::function::do_join_pp:int pp, unsigned32 *ra, unsigned32 rb, unsigned32 src
	switch (pp) {
	case 0x0: /* LL */
	  WRITE32_QUEUE (ra, ((unsigned32)VL2_4(rb) << 16) | VL2_4(src));
	  break;
	case 0x1: /* LH */
	  WRITE32_QUEUE (ra, ((unsigned32)VL2_4(rb) << 16) | VH2_4(src));
	  break;
	case 0x2: /* HL */
	  WRITE32_QUEUE (ra, ((unsigned32)VH2_4(rb) << 16) | VL2_4(src));
	  break;
	case 0x3: /* HH */
	  WRITE32_QUEUE (ra, ((unsigned32)VH2_4(rb) << 16) | VH2_4(src));
	  break;
	}

::%s::pp:int pp
	switch (pp)
	  {
	  case 0x0: return "ll";
	  case 0x1: return "lh";
	  case 0x2: return "hl";
	  case 0x3: return "hh";
	  default: return "?";
	  }

_IALU1,011,pp,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:JOINpp
"join%s<pp> r<RA>, r<RB>, r<RC>"
	do_join_pp(_SD, pp, Ra, Rb, Rc);
_IALU1,011,pp,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:JOINpp imm
"join%s<pp> r<RA>, r<RB>, <imm>"
	do_join_pp(_SD, pp, Ra, Rb, immHL);
_IALU1,011,pp,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:JOINpp imm long
"join%s<pp> r<RA>, r<RB>, <imm>"
	do_join_pp(_SD, pp, Ra, Rb, immHL);



// JSR

_BRA,00011,00,6.**,6.**,6.RC:BRA:short:mu:JSR
"jsr r<RC>"
	if (cia == RPT_E && PSW_VAL (PSW_RP))
	  WRITE32_QUEUE (&GPR[62], RPT_S);
	else
	  WRITE32_QUEUE (&GPR[62], cia + 8);
	if (TRACE_CALL_P)
	  TRACE_ACTION |= TRACE_ACTION_CALL;
	return pcaddr;
_BRA,00011,10,_IMM18:BRA:short:mu:JSR imm
"jsr <pcdisp>"
	if (cia == RPT_E && PSW_VAL (PSW_RP))
	  WRITE32_QUEUE (&GPR[62], RPT_S);
	else
	  WRITE32_QUEUE (&GPR[62], cia + 8);
	if (TRACE_CALL_P)
	  TRACE_ACTION |= TRACE_ACTION_CALL;
	return pcaddr;
_BRA,00011,10,6.**,6.**,_IMM32:BRA:long:mu:JSR imm long
"jsr <pcdisp>"
	if (cia == RPT_E && PSW_VAL (PSW_RP))
	  WRITE32_QUEUE (&GPR[62], RPT_S);
	else
	  WRITE32_QUEUE (&GPR[62], cia + 8);
	if (TRACE_CALL_P)
	  TRACE_ACTION |= TRACE_ACTION_CALL;
	return pcaddr;


// JSRTNZ

_BRA,00111,01,6.RA,6.**,6.RC:BRA:short:mu:JSRTNZ
"jsrtnz r<RC>"
	if (val_Ra != 0) {
	  if (cia == RPT_E && PSW_VAL (PSW_RP))
	    WRITE32_QUEUE (&GPR[62], RPT_S);
	  else
	    WRITE32_QUEUE (&GPR[62], cia + 8);
	  nia = pcaddr;
	  if (TRACE_CALL_P)
	    TRACE_ACTION |= TRACE_ACTION_CALL;
	}
_BRA,00111,11,6.RA,_IMM12:BRA:short:mu:JSRTNZ imm
"jsrtnz <pcdisp>"
	if (val_Ra != 0) {
	  if (cia == RPT_E && PSW_VAL (PSW_RP))
	    WRITE32_QUEUE (&GPR[62], RPT_S);
	  else
	    WRITE32_QUEUE (&GPR[62], cia + 8);
	  nia = pcaddr;
	  if (TRACE_CALL_P)
	    TRACE_ACTION |= TRACE_ACTION_CALL;
	}
_BRA,00111,11,6.RA,6.**,_IMM32:BRA:long:mu:JSRTNZ imm long
"jsrtnz <pcdisp>"
	if (val_Ra != 0) {
	  if (cia == RPT_E && PSW_VAL (PSW_RP))
	    WRITE32_QUEUE (&GPR[62], RPT_S);
	  else
	    WRITE32_QUEUE (&GPR[62], cia + 8);
	  nia = pcaddr;
	  if (TRACE_CALL_P)
	    TRACE_ACTION |= TRACE_ACTION_CALL;
	}



// JSRTZR

_BRA,00111,00,6.RA,6.**,6.RC:BRA:short:mu:JSRTZR
"jsrtzr r<RC>"
	if (val_Ra == 0) {
	  if (cia == RPT_E && PSW_VAL (PSW_RP))
	    WRITE32_QUEUE (&GPR[62], RPT_S);
	  else
	    WRITE32_QUEUE (&GPR[62], cia + 8);
	  nia = pcaddr;
	  if (TRACE_CALL_P)
	    TRACE_ACTION |= TRACE_ACTION_CALL;
	}
_BRA,00111,10,6.RA,_IMM12:BRA:short:mu:JSRTZR imm
"jsrtzr <pcdisp>"
	if (val_Ra == 0) {
	  if (cia == RPT_E && PSW_VAL (PSW_RP))
	    WRITE32_QUEUE (&GPR[62], RPT_S);
	  else
	    WRITE32_QUEUE (&GPR[62], cia + 8);
	  nia = pcaddr;
	  if (TRACE_CALL_P)
	    TRACE_ACTION |= TRACE_ACTION_CALL;
	}
_BRA,00111,10,6.RA,6.**,_IMM32:BRA:long:mu:JSRTZR imm long
"jsrtzr <pcdisp>"
	if (val_Ra == 0) {
	  if (cia == RPT_E && PSW_VAL (PSW_RP))
	    WRITE32_QUEUE (&GPR[62], RPT_S);
	  else
	    WRITE32_QUEUE (&GPR[62], cia + 8);
	  nia = pcaddr;
	  if (TRACE_CALL_P)
	    TRACE_ACTION |= TRACE_ACTION_CALL;
	}



// Post increment

void::function::do_incr:int x, unsigned32 *rb, int delta
	unsigned32 next_rb;
	if (x == 1)
	  next_rb = *rb + delta;
	else if (x == 3)
	  next_rb = *rb - delta;
	else
	  next_rb = *rb; /* value not used */
	/* HW erratum: check value after incrementing */
	if (next_rb == MOD_E
	    && (x == 1 || x == 3)
	    && (PSW_VAL(PSW_MD))) {
	  WRITE32_QUEUE (rb, MOD_S);
	}
	else if (x == 1 || x == 3)
	  WRITE32_QUEUE (rb, next_rb);

// LD2H

int::function::make_even_reg:int reg, const char *name
	if (reg & 1)
	  sim_engine_abort (SD, CPU, cia,
			    "0x%lx:%s odd register (r%d) used in multi-word load/mulx2h",
			    (long) cia, name, reg);
	return reg;

void::function::do_ld2h:int ra, unsigned32 rb, unsigned32 src
	signed32 mem;
	ra = make_even_reg(_SD, ra, "LD2H");
	mem = MEM(signed, rb + src, 4);
	if (ra != 0)
	{
	  WRITE32_QUEUE (&GPR[ra + 0], SEXT32(EXTRACTED32(mem, 0, 15), 16));
	  WRITE32_QUEUE (&GPR[ra + 1], SEXT32(EXTRACTED32(mem, 16, 31), 16));
	}

::%s::XX:int XX
	switch (XX)
	  {
	  case 0: return "";
	  case 1: return "+";
	  case 3: return "-";
	  default: return "?";
	  }

_IMEM,00011,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LD2H
"ld2h r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
"ld2h r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
	do_ld2h(_SD, RA, Rb, src);
	do_incr(_SD, XX, &GPR[RB], 4);
_IMEM,00011,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LD2H long
"ld2h r<RA>, @@(r<RB>, <imm>)"
	do_ld2h(_SD, RA, Rb, imm);



// LD2W

void::function::do_ld2w:int ra, unsigned32 rb, unsigned32 src
	unsigned64 mem;
	ra = make_even_reg(_SD, ra, "LD2W");
	mem = MEM(unsigned, rb + src, 8);
	if (ra != 0)
	{
	  WRITE32_QUEUE (&GPR[ra + 0], EXTRACTED64 (mem, 0, 31));
	  WRITE32_QUEUE (&GPR[ra + 1], EXTRACTED64 (mem, 32, 63));
	}

_IMEM,00110,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:L2W
"ld2w r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
"ld2w r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
	do_ld2w(_SD, RA, Rb, src);
	do_incr(_SD, XX, &GPR[RB], 8);
_IMEM,00110,10,6.RA,6.RB,_IMM32:IMEM:long:mu:L2W long
"ld2w r<RA>, @@(r<RB>, <imm>)"
	do_ld2w(_SD, RA, Rb, imm);



// LD4BH

void::function::do_ld4bh:unsigned32 ra, unsigned32 rb, unsigned32 src
	unsigned16 l1, l2, h1, h2;
	unsigned32 mem;
	ra = make_even_reg(_SD, ra, "LD4BH");
	mem = MEM(unsigned, rb + src, 4);
	h1 = SEXT16(EXTRACTED32(mem, 0, 7), 8);
	l1 = SEXT16(EXTRACTED32(mem, 8, 15), 8);
	h2 = SEXT16(EXTRACTED32(mem, 16, 23), 8);
	l2 = SEXT16(EXTRACTED32(mem, 24, 31), 8);
	if (ra != 0)
	{
	  WRITE32_QUEUE (&GPR[ra + 0], (h1 << 16) | l1);
	  WRITE32_QUEUE (&GPR[ra + 1], (h2 << 16) | l2);
	}

_IMEM,00101,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LD4BH
"ld4bh r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
"ld4bh r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
	do_ld4bh(_SD, RA, Rb, src);
	do_incr(_SD, XX, &GPR[RB], 4);
_IMEM,00101,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LD4BH long
"ld4bh r<RA>, @@(r<RB>, <imm>)"
	do_ld4bh(_SD, RA, Rb, imm);



// LD4BHU

void::function::do_ld4bhu:unsigned32 ra, unsigned32 rb, unsigned32 src
	unsigned16 l1, l2, h1, h2;
	unsigned32 mem;
	ra = make_even_reg(_SD, ra, "LD4BH");
	mem = MEM(signed, rb + src, 4);
	h1 = EXTRACTED32(mem, 0, 7);
	l1 = EXTRACTED32(mem, 8, 15);
	h2 = EXTRACTED32(mem, 16, 23);
	l2 = EXTRACTED32(mem, 24, 31);
	if (ra != 0)
	{
	  WRITE32_QUEUE (&GPR[ra + 0], (h1 << 16) | l1);
	  WRITE32_QUEUE (&GPR[ra + 1], (h2 << 16) | l2);
	}

_IMEM,01101,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LD4BHU
"ld4hbu r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
"ld4hbu r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
	do_ld4bhu(_SD, RA, Rb, src);
	do_incr(_SD, XX, &GPR[RB], 4);
_IMEM,01101,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LD4BHU long
"ld4hbu r<RA>, @@(r<RB>, <imm>)"
	do_ld4bhu(_SD, RA, Rb, imm);



// LDB

void::function::do_ldb:unsigned32 *ra, unsigned32 rb, unsigned32 src
	WRITE32_QUEUE (ra, MEM(signed, rb + src, 1));

_IMEM,00000,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LDB
"ldb r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
"ldb r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
	do_ldb(_SD, Ra, Rb, src);
	do_incr(_SD, XX, &GPR[RB], 1);
_IMEM,00000,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LDB long
"ldb r<RA>, @@(r<RB>, <imm>)"
	do_ldb(_SD, Ra, Rb, imm);



// LDBU

void::function::do_ldbu:unsigned32 *ra, unsigned32 rb, unsigned32 src
	WRITE32_QUEUE (ra, MEM(unsigned, rb + src, 1));

_IMEM,01001,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LDBU
"ldbu r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
"ldbu r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
	do_ldbu(_SD, Ra, Rb, src);
	do_incr(_SD, XX, &GPR[RB], 1);
_IMEM,01001,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LDBU long
"ldbu r<RA>, @@(r<RB>, <imm>)"
	do_ldbu(_SD, Ra, Rb, imm);



// LDH

void::function::do_ldh:unsigned32 *ra, unsigned32 rb, unsigned32 src
	WRITE32_QUEUE (ra, MEM(signed, rb + src, 2));

_IMEM,00010,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LDH
"ldh r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
"ldh r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
	do_ldh(_SD, Ra, Rb, src);
	do_incr(_SD, XX, &GPR[RB], 2);
_IMEM,00010,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LDH long
"ldh r<RA>, @@(r<RB>, <imm>)"
	do_ldh(_SD, Ra, Rb, imm);



// LDHH

void::function::do_ldhh:unsigned32 *ra, unsigned32 rb, unsigned32 src
	WRITE32_QUEUE (ra, MEM(signed, rb + src, 2) << 16);

_IMEM,00001,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LDHH
"ldhh r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
"ldhh r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
	do_ldhh(_SD, Ra, Rb, src);
	do_incr(_SD, XX, &GPR[RB], 2);
_IMEM,00001,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LDHH long
"ldhh r<RA>, @@(r<RB>, <imm>)"
	do_ldhh(_SD, Ra, Rb, imm);



// LDHU

void::function::do_ldhu:unsigned32 *ra, unsigned32 rb, unsigned32 src
	WRITE32_QUEUE (ra, MEM(unsigned, rb + src, 2));

_IMEM,01010,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LDHU
"ldhu r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
"ldhu r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
	do_ldhu(_SD, Ra, Rb, src);
	do_incr(_SD, XX, &GPR[RB], 2);
_IMEM,01010,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LDHU long
"ldhu r<RA>, @@(r<RB>, <imm>)"
	do_ldhu(_SD, Ra, Rb, imm);



// LDW

void::function::do_ldw:unsigned32 *ra, unsigned32 rb, unsigned32 src
	WRITE32_QUEUE (ra, MEM(signed, rb + src, 4));

_IMEM,00100,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LDW
"ldw r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
"ldw r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
	do_ldw(_SD, Ra, Rb, src);
	do_incr(_SD, XX, &GPR[RB], 4);
_IMEM,00100,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LDW long
"ldw r<RA>, @@(r<RB>, <imm>)"
	do_ldw(_SD, Ra, Rb, imm);



// MACa

void::function::do_mac:unsigned64 *aa, unsigned32 *ra, signed32 rb, signed32 src
	unsigned64 accum = *aa;
	accum += (signed64) (rb) * (signed64) (src);
	WRITE64_QUEUE (aa, accum);
	WRITE32_QUEUE (ra, EXTRACTED64(accum, 32, 63));

_IALU2,10100,0,1.AA,6.RA,6.RB,6.RC:IALU2:short:iu:MACa
"mac<AA> r<RA>, r<RB>, r<RC>"
	do_mac(_SD, Aa, Ra, Rb, Rc);	
_IALU2,10100,1,1.AA,6.RA,6.RB,_IMM6:IALU2:short:iu:MACa imm
"mac<AA> r<RA>, r<RB>, <imm>"
	do_mac(_SD, Aa, Ra, Rb, imm);



// MACSa

void::function::do_macs:unsigned64 *aa, unsigned32 *ra, signed32 rb, signed32 src
	unsigned64 accum = *aa;
	accum += ((signed64) (rb) * (signed64) (src)) << 1;
	WRITE64_QUEUE (aa, accum);
	WRITE32_QUEUE (ra, EXTRACTED64(accum, 0, 31));

_IALU2,10101,0,1.AA,6.RA,6.RB,6.RC:IALU2:short:iu:MACSa
"macs<AA> r<RA>, r<RB>, r<RC>"
	do_macs(_SD, Aa, Ra, Rb, Rc);	
_IALU2,10101,1,1.AA,6.RA,6.RB,_IMM6:IALU2:short:iu:MACSa imm
"macs<AA> r<RA>, r<RB>, <imm>"
	do_macs(_SD, Aa, Ra, Rb, imm);



// MODDEC | MODINC

_IMEM,00111,11,6.**,6.RB,_IMM6:IMEM:short:mu:MODDEC
"moddec r<RB>, <imm>"
	do_incr(_SD, 3/*0b11*/, &GPR[RB], imm_5);	
_IMEM,00111,01,6.**,6.RB,_IMM6:IMEM:short:mu:MODINC
"modinc r<RB>, <imm>"
	do_incr(_SD, 1/*0b01*/, &GPR[RB], imm_5);	



// MSUBa

void::function::do_msub:unsigned64 *aa, unsigned32 *ra, signed32 rb, signed32 src
	unsigned64 accum = *aa;
	accum -= (signed64) (rb) * (signed64) (src);
	WRITE64_QUEUE (aa, accum);
	WRITE32_QUEUE (ra, EXTRACTED64(accum, 32, 63));

_IALU2,10110,0,1.AA,6.RA,6.RB,6.RC:IALU2:short:iu:MSUBa
"msub<AA> r<RA>, r<RB>, r<RC>"
	do_msub(_SD, Aa, Ra, Rb, Rc);	
_IALU2,10110,1,1.AA,6.RA,6.RB,_IMM6:IALU2:short:iu:MSUBa imm
"msub<AA> r<RA>, r<RB>, <imm>"
	do_msub(_SD, Aa, Ra, Rb, imm);



// MSUBSa

void::function::do_msubs:unsigned64 *aa, unsigned32 *ra, signed32 rb, signed32 src
	unsigned64 accum = *aa;
	accum -= ((signed64) (rb) * (signed64) (src)) << 1;
	WRITE64_QUEUE (aa, accum);
	WRITE32_QUEUE (ra, EXTRACTED64(accum, 0, 31));

_IALU2,10111,0,1.AA,6.RA,6.RB,6.RC:IALU2:short:iu:MSUBSa
"msubs<AA> r<RA>, r<RB>, r<RC>"
	do_msubs(_SD, Aa, Ra, Rb, Rc);	
_IALU2,10111,1,1.AA,6.RA,6.RB,_IMM6:IALU2:short:iu:MSUBSa imm
"msubs<AA> r<RA>, r<RB>, <imm>"
	do_msubs(_SD, Aa, Ra, Rb, imm);



// MUL

void::function::do_mul:unsigned32 *ra, unsigned32 rb, unsigned32 src
	WRITE32_QUEUE (ra, rb * src);

_IALU2,10000,00,6.RA,6.RB,6.RC:IALU2:short:iu:MUL
"mul r<RA>, r<RB>, r<RC>"
	do_mul(_SD, Ra, Rb, Rc);	
_IALU2,10000,10,6.RA,6.RB,_IMM6:IALU2:short:iu:MUL imm
"mul r<RA>, r<RB>, <imm>"
	do_mul(_SD, Ra, Rb, imm);



// MUL2H

void::function::do_mul2h:unsigned32 *ra, unsigned32 rb, unsigned32 src
	unsigned16 high = VH2_4(rb) * VH2_4(src);
	unsigned16 low  = VL2_4(rb) * VL2_4(src);
	WRITE32_QUEUE (ra, (high << 16) | low);

_IALU2,00000,00,6.RA,6.RB,6.RC:IALU2:short:iu:MUL2H
"mul2h r<RA>, r<RB>, r<RC>"
	do_mul2h(_SD, Ra, Rb, Rc);	
_IALU2,00000,10,6.RA,6.RB,_IMM6:IALU2:short:iu:MUL2H imm
"mul2h r<RA>, r<RB>, <imm>"
	do_mul2h(_SD, Ra, Rb, immHL);



// MULX

void::function::do_mulx:unsigned64 *aa, signed32 rb, signed32 src
	WRITE64_QUEUE (aa, (signed64) (rb) * (signed64) (src));

_IALU2,11000,00,5.*,1.AA,6.RB,6.RC:IALU2:short:iu:MULX
"mulx a<AA>, r<RB>, r<RC>"
	do_mulx(_SD, Aa, Rb, Rc);	
_IALU2,11000,10,5.*,1.AA,6.RB,_IMM6:IALU2:short:iu:MULX imm
"mulx a<AA>, r<RB>, <imm>"
	do_mulx(_SD, Aa, Rb, imm);


// MULX2H

void::function::do_mulx2h:int ra, signed32 rb, signed32 src, int high
	signed32 result = rb * src;
	if (!high)
	  {
	    ra = make_even_reg(_SD, ra, "MULX2H");
	    if (ra != 0)
	      WRITE32_QUEUE (&GPR[ra+1], result);
	  }
	else if (ra != 0)
	  {
	      WRITE32_QUEUE (&GPR[ra+0], result);
	  }

_IALU2,00001,00,6.RA,6.RB,6.RC:IALU2:short:iu:MULX2H
"mul2h r<RA>, r<RB>, r<RC>"
	do_mulx2h(_SD, RA, RbH, RcH, 1);
	do_mulx2h(_SD, RA, RbL, RcL, 0);
_IALU2,00001,10,6.RA,6.RB,_IMM6:IALU2:short:iu:MULX2H imm
"mul2h r<RA>, r<RB>, <imm>"
	do_mulx2h(_SD, RA, RbH, imm, 1);
	do_mulx2h(_SD, RA, RbL, imm, 0);

// MULHXpp

void::function::do_mulhx:int pp, unsigned32 *ra, unsigned32 rb, unsigned32 src
	signed32 value = 0;
	switch (pp) {
	case 0: /* LL */
	  value = SEXT32(VL2_4(rb), 16) * SEXT32(VL2_4(src), 16);
	  break;
	case 1: /* LH */
	  value = SEXT32(VL2_4(rb), 16) * SEXT32(VH2_4(src), 16);
	  break;
	case 2: /* HL */
	  value = SEXT32(VH2_4(rb), 16) * SEXT32(VL2_4(src), 16);
	  break;
	case 3: /* HH */
	  value = SEXT32(VH2_4(rb), 16) * SEXT32(VH2_4(src), 16);
	  break;
	default:
	  sim_engine_abort (SD, CPU, cia, "do_mulhx - internal error - bad switch");
	}
	WRITE32_QUEUE (ra, value);

_IALU2,001,pp,00,6.RA,6.RB,6.RC:IALU2:short:iu:MULHXpp
"mulhx%s<pp> r<RA>, r<RB>, r<RC>"
	do_mulhx(_SD, pp, Ra, Rb, Rc);	
_IALU2,001,pp,10,6.RA,6.RB,_IMM6:IALU2:short:iu:MULHXpp imm
"mulhx%s<pp> r<RA>, r<RB>, <imm>"
	do_mulhx(_SD, pp, Ra, Rb, immHL);



// MULXS

void::function::do_mulxs:unsigned64 *aa, signed32 rb, signed32 src
	WRITE64_QUEUE (aa, ((signed64) (rb) * (signed64) (src)) << 1);

_IALU2,11001,00,5.*,1.AA,6.RB,6.RC:IALU2:short:iu:MULXS
"mulxs a<AA>, r<RB>, r<RC>"
	do_mulxs(_SD, Aa, Rb, Rc);	
_IALU2,11001,10,5.*,1.AA,6.RB,_IMM6:IALU2:short:iu:MULXS imm
"mulxs a<AA>, r<RB>, <imm>"
	do_mulxs(_SD, Aa, Rb, imm);



// MVFACC

void::function::do_mvfacc:unsigned32 *ra, unsigned64 ab, unsigned32 src
	while (src > 63) src -= 64;
	WRITE32_QUEUE (ra, ((signed64)ab) >> src);

_IALU2,11111,00,6.RA,5.*,1.AB,6.RC:IALU2:short:iu:MVFACC
"mvfacc r<RA>, a<AB>, r<RC>"
	do_mvfacc(_SD, Ra, *Ab, Rc);	
_IALU2,11111,10,6.RA,5.*,1.AB,_IMM6:IALU2:short:iu:MVFACC imm
"mvfacc r<RA>, a<AB>, <imm>"
	do_mvfacc(_SD, Ra, *Ab, imm_6u);



// MVFSYS

_BRA,11110,00,6.RA,6.CR,6.ID:BRA:short:mu:MVFSYS
"mvfsys r<RA>, cr<CR>"
	switch (ID) {
	case 0:
	  if (CR >= NR_CONTROL_REGISTERS)
	    sim_engine_abort (SD, CPU, cia, "FIXME - illegal CR");
	  else
	    WRITE32_QUEUE (Ra, (CPU)->regs.control[CR]);
	  break;
	case 1:
	  WRITE32_QUEUE (Ra, PSWL);
	  break;
	case 2:
	  WRITE32_QUEUE (Ra, EXTRACTED32(PSWH, 16, 31));
	  break;
	case 3:
	  WRITE32_QUEUE (Ra, PSW_FLAG_VAL(CR));
	  break;
	default:
	  sim_engine_abort (SD, CPU, cia, "FIXME - illegal ID");
	}



// MVTACC

_IALU2,01111,00,5.*,1.AA,6.RB,6.RC:IALU2:short:iu:MVTACC
"mvtacc a<AA>, r<RB>, r<RC>"
	WRITE64_QUEUE (Aa, INSERTED64(RbU, 0, 31) | (RcU));



// MVTSYS

_BRA,01110,00,6.CR,6.RB,6.ID:BRA:short:mu:MVTSYS
"mvtsys cr<CR>, r<RB>"
	switch (ID) {
	case 0:			/* control register */
	  if (CR >= NR_CONTROL_REGISTERS)
	    sim_engine_abort (SD, CPU, cia, "FIXME - illegal CR");
	  else
	    {
	      unsigned32 value = Rb;
	      CPU->mvtsys_left_p = 1;
	      if (CR == processor_status_word_cr)
		{
		  unsigned32 ds = PSW & BIT32 (PSW_DS);	/* preserve ds */
		  value = ds | (value & PSW_VALID);
		}
	      else if (CR == backup_processor_status_word_cr
		       || CR == debug_backup_processor_status_word_cr)
		value &= DPSW_VALID;
	      else if (CR == eit_vector_base_cr)
		value &= EIT_VALID;
	      WRITE32_QUEUE (&(CPU)->regs.control[CR], value);
	    }
	  break;
	case 1:			/* PSWL */
	  WRITE32_QUEUE_MASK (&PSW, EXTRACTED32(Rb, 16, 31),
			      PSW_VALID & 0x0000ffff);
	  break;
	case 2:			/* PSWH */
	  {
	    unsigned32 ds = PSW & BIT32 (PSW_DS);	/* preserve ds */
	    WRITE32_QUEUE_MASK (&PSW, (EXTRACTED32(Rb, 16, 31) << 16) | ds,
				(PSW_VALID | ds) & 0xffff0000);
	  }
	  break;
	case 3:			/* FLAG */
	  PSW_FLAG_SET_QUEUE(CR, Rb & 1);
	  break;
	default:
	  sim_engine_abort (SD, CPU, cia, "FIXME - illegal ID");
	}



// NOP

_BRA,01111,00,6.**,6.**,6.**:BRA:short:iu,mu:NOP
"nop"
	/* NOP */;


// NOT

_LOGIC,11001,00,6.RA,6.RB,6.*:LOGIC:short:iu,mu:NOT
"not r<RA>, r<RB>"
	WRITE32_QUEUE (Ra, ~Rb);



// NOTFG

_LOGIC,01001,00,***,3.FA,***,3.FB,***,3.FC:LOGIC:short:iu,mu:NOTFG
"notfg f<FA>, f<FB>"
	PSW_FLAG_SET_QUEUE(FA, !PSW_FLAG_VAL(FB));


// OR

_LOGIC,11010,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:OR
"or r<RA>, r<RB>, r<RC>"
	WRITE32_QUEUE (Ra, Rb | Rc);
_LOGIC,11010,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:OR imm
"or r<RA>, r<RB>, <imm>"
	WRITE32_QUEUE (Ra, Rb | imm);
_LOGIC,11010,10,6.RA,6.RB,_IMM32:LOGIC:long:iu,mu:OR imm long
"or r<RA>, r<RB>, <imm>"
	WRITE32_QUEUE (Ra, Rb | imm);



// ORFG

_LOGIC,01010,00,***,3.FA,***,3.FB,***,3.FC:LOGIC:short:iu,mu:ORFG
"orfg f<FA>, f<FB>, f<FC>"
	PSW_FLAG_SET_QUEUE(FA, PSW_FLAG_VAL(FB) | PSW_FLAG_VAL(FC));
_LOGIC,01010,10,***,3.FA,***,3.FB,_IMM6:LOGIC:short:iu,mu:ORFG imm
"orfg f<FA>, f<FB>, <imm>"
	PSW_FLAG_SET_QUEUE(FA, PSW_FLAG_VAL(FB) | (imm_6 & 1));



// REIT

_BRA,01000,00,6.**,6.**,6.**:BRA:short:mu:REIT
"reit"
	WRITE32_QUEUE (&PSW, bPSW);
	nia = bPC;




// REPEAT

void::function::do_repeat:unsigned32 count, address_word pcaddr
	address_word rpt_s = cia + 8;
	address_word rpt_e = cia + pcaddr;

	if (count == 0)
	  sim_engine_abort (SD, CPU, cia, "REPEAT with ra=0 and REPEATI with imm = 0 is forbidden.");
	if (count > 1)
	  PSW_SET_QUEUE (PSW_RP, 1);
	if (rpt_e  < rpt_s + 0x10)
	  sim_io_eprintf (sd, "warning: 0x%lx: REPEAT or REPEATI loop is too small\n", (long) cia);
	WRITE32_QUEUE (&RPT_C, count - 1);
	WRITE32_QUEUE (&RPT_S, rpt_s);
	WRITE32_QUEUE (&RPT_E, rpt_e);

_BRA,11000,00,6.RA,6.**,6.RC:BRA:short:mu:REPEAT
"repeat r<RA>, r<RC>"
	do_repeat(_SD, val_Ra, pcaddr);
_BRA,11000,10,6.RA,_IMM12:BRA:short:mu:REPEAT imm
"repeat r<RA>, <pcaddr>"
	do_repeat(_SD, val_Ra, pcaddr);
_BRA,11000,10,6.RA,6.**,_IMM32:BRA:long:mu:REPEAT imm long
"repeat r<RA>, <pcaddr>"
	do_repeat(_SD, val_Ra, pcaddr);




// REPEATI

_BRA,11010,00,6.IMM_6,6.**,6.RC:BRA:short:mu:REPEATI
"repeati <IMM_6>, r<RC>"
	do_repeat(_SD, IMM_6, pcaddr);
_BRA,11010,10,6.IMM_6,_IMM12:BRA:short:mu:REPEATI imm
"repeati <IMM_6>, <pcaddr>"
	do_repeat(_SD, IMM_6, pcaddr);
_BRA,11010,10,6.IMM_6,6.**,_IMM32:BRA:long:mu:REPEATI imm long
"repeati <IMM_6>, <pcaddr>"
	do_repeat(_SD, IMM_6, pcaddr);




// RTD

_BRA,01010,00,6.*,6.*,6.*:BRA:short:mu:RTD
"rtd"
	WRITE32_QUEUE (&PSW, DPSW);
	nia = DPC;




// ROT

_LOGIC,10100,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:ROT
"rot r<RA>, r<RB>, r<RC>"
	WRITE32_QUEUE (Ra, ROT32(Rb, Rc & 0x1f));
_LOGIC,10100,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:ROT imm
"rot r<RA>, r<RB>, <imm>"
	WRITE32_QUEUE (Ra, ROT32(Rb, imm & 0x1f));




// ROT2H

void::function::do_rot2h:unsigned32 *ra, unsigned32 rb, signed32 src
	unsigned16 high = ROTR16(VH2_4(rb), VH2_4(src) & 0xf);
	unsigned16 low  = ROTR16(VL2_4(rb), VL2_4(src) & 0xf);
	WRITE32_QUEUE (ra, (high << 16) | low);

_LOGIC,10101,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:ROT2H
"rot2h r<RA>, r<RB>, r<RC>"
	do_rot2h(_SD, Ra, Rb, Rc);
_LOGIC,10101,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:ROT2H imm
"rot2h r<RA>, r<RB>, <imm>"
	do_rot2h(_SD, Ra, Rb, immHL);




// SAT

void::function::do_sat:signed32 *ra, signed32 rb, signed32 src
	int bits = LSMASKED32(src, 4, 0); /* 5 */
	signed32 sat = LSMASK32(bits, 0) >> 2;
	signed32 nsat = ~sat;
	signed32 value;
	if (bits != src)
	  sim_io_eprintf (sd, "warning: 0x%lx:SAT bit overflow\n", (long) cia);
	if (bits == 0)
	  value = rb;
	else if (rb >= sat)
	  value = sat;
	else if (rb <= nsat)
	  value = nsat;
	else
	  value = rb;
	WRITE32_QUEUE (ra, value);

_IALU2,01000,00,6.RA,6.RB,6.RC:IALU2:short:iu:SAT
"sat r<RA>, r<RB>, r<RC>"
	do_sat(_SD, Ra, Rb, Rc);
_IALU2,01000,10,6.RA,6.RB,_IMM6:IALU2:short:iu:SAT imm
"sat r<RA>, r<RB>, <imm>"
	do_sat(_SD, Ra, Rb, imm_5);




// SAT2H

void::function::do_sath:signed32 *ra, signed32 rb, signed32 src, int high, int updates_f4
	int bits = LSMASKED32(src, 4, 0); /* 5 */
	signed32 sat = LSMASK32(bits, 0) >> 2;
	signed32 nsat = ~sat;
	signed32 value;
	if (bits != src)
	  sim_io_eprintf (sd, "warning: 0x%lx:SAT bit overflow\n", (long) cia);
	if (bits == 0)
	  value = rb;
	else if (rb >= sat)
	  value = sat;
	else if (rb <= nsat)
	  value = nsat;
	else
	  value = rb;
	if (high)
	  WRITE32_QUEUE_MASK (ra, value << 16, 0xffff0000);
	else
	  WRITE32_QUEUE_MASK (ra, value, 0x0000ffff);
	if (updates_f4)
	  {
	    /* if MU instruction was a MVTSYS (lkr), unqueue register writes now */
	    if(STATE_CPU (sd, 0)->mvtsys_left_p)
	      unqueue_writes (sd, STATE_CPU (sd, 0), cia);
	    PSW_FLAG_SET_QUEUE(PSW_S_FLAG, PSW_FLAG_VAL(PSW_S_FLAG) ^ (value & 1));
	  }

_IALU2,01001,00,6.RA,6.RB,6.RC:IALU2:short:iu:SAT2H
"sat2h r<RA>, r<RB>, r<RC>"
	do_sath(_SD, Ra, RbH, RcH, 1, 0);
	do_sath(_SD, Ra, RbL, RcL, 0, 0);
_IALU2,01001,10,6.RA,6.RB,_IMM6:IALU2:short:iu:SAT2H imm
"sat2h r<RA>, r<RB>, <imm>"
	do_sath(_SD, Ra, RbH, imm_5, 1, 0);
	do_sath(_SD, Ra, RbL, imm_5, 0, 0);




// SATHp

::%s::p:int p
	switch (p)
	  {
	  case 0: return "l";
	  case 1: return "h";
	  default: return "?";
	  }

_IALU2,1110,p,00,6.RA,6.RB,6.RC:IALU2:short:iu:SATHP
"sath%s<p> r<RA>, r<RB>, r<RC>"
	do_sath(_SD, Ra, Rb, Rc, p, 1);
_IALU2,1110,p,10,6.RA,6.RB,_IMM6:IALU2:short:iu:SATHP imm
"sath%s<p> r<RA>, r<RB>, <imm>"
	do_sath(_SD, Ra, Rb, imm_5, p, 1);



// SATZ

void::function::do_satz:signed32 *ra, signed32 rb, signed32 src
	if (rb < 0)
	  WRITE32_QUEUE (ra, 0);
	else
	  do_sat (_SD, ra, rb, src);

_IALU2,01010,00,6.RA,6.RB,6.RC:IALU2:short:iu:SATZ
"satz r<RA>, r<RB>, r<RC>"
	do_satz(_SD, Ra, Rb, Rc);
_IALU2,01010,10,6.RA,6.RB,_IMM6:IALU2:short:iu:SATZ imm
"satz r<RA>, r<RB>, <imm>"
	do_satz(_SD, Ra, Rb, imm_5);




// SATZ2H

void::function::do_satzh:signed32 *ra, signed16 rb, signed32 src, int high
	int bits = LSMASKED32(src, 3, 0); /*4*/
	signed16 sat = LSMASK16(bits, 0) >> 2;
	signed16 nsat = 0;
	signed16 value;
	if (bits != src)
	  sim_io_eprintf (sd, "warning: 0x%lx:SATZ2H bit overflow\n", (long) cia);
	if (bits == 0 && rb > sat)
	  value = rb;
	else if (rb > sat)
	  value = sat;
	else if (rb < nsat)
	  value = nsat;
	else
	  value = rb;
	if (high)
	  WRITE32_QUEUE_MASK (ra, value << 16, 0xffff0000);
	else
	  WRITE32_QUEUE_MASK (ra, value, 0x0000ffff);


_IALU2,01011,00,6.RA,6.RB,6.RC:IALU2:short:iu:SATZ2H
"satz2h r<RA>, r<RB>, r<RC>"
	do_satzh(_SD, Ra, RbH, RcH, 1);
	do_satzh(_SD, Ra, RbL, RcL, 0);
_IALU2,01011,10,6.RA,6.RB,_IMM6:IALU2:short:iu:SATZ2H imm
"satz2h r<RA>, r<RB>, <imm>"
	do_satzh(_SD, Ra, RbH, imm, 1);
	do_satzh(_SD, Ra, RbL, imm, 0);




// SRA

void::function::do_sra:unsigned32 *ra, unsigned32 rb, signed32 src
	unsigned32 value;
	while (src > 31) src -= 32;
	while (src < -32) src += 32;
	if (src >= 0)
	  value = (signed32)rb >> src;
	else if (src == -32)
	  value = 0;
	else
	  value = rb << -src;
	WRITE32_QUEUE (ra, value);

_LOGIC,10000,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRA
"sra r<RA>, r<RB>, r<RC>"
	do_sra(_SD, Ra, Rb, Rc);
_LOGIC,10000,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRA imm
"sra r<RA>, r<RB>, <imm>"
	do_sra(_SD, Ra, Rb, imm);




// SRAHp

void::function::do_srah:unsigned32 *ra, unsigned32 rb, int src, int high
	unsigned32 value;
	while (src > 31) src -= 32;
	while (src < -32) src += 32;
	if (src >= 0)
	  value = (signed32)rb >> src;
	else if (src == -32)
	  value = 0;
	else
	  value = rb << -src;
	if (high)
	  WRITE32_QUEUE_MASK (ra, value << 16, 0xffff0000);
	else
	  WRITE32_QUEUE_MASK (ra, value, 0x0000ffff);

_LOGIC,0010,p,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRAHP
"srah%s<p> r<RA>, r<RB>, r<RC>"
	do_srah(_SD, Ra, Rb, Rc, p);
_LOGIC,0010,p,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRAHP imm
"srah%s<p> r<RA>, r<RB>, <imm>"
	do_srah(_SD, Ra, Rb, imm, p);




// SRA2H

_LOGIC,10001,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRA2H
"sra2h r<RA>, r<RB>, r<RC>"
	signed32 srcH = RcH;
	signed32 srcL = RcL;
	while (srcH > 15) srcH -= 16;
	while (srcH < -16) srcH += 16;
	while (srcL > 15) srcL -= 16;
	while (srcL < -16) srcL += 16;
	do_srah(_SD, Ra, RbH, srcH, 1);
	do_srah(_SD, Ra, RbL, srcL, 0);
_LOGIC,10001,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRA2H imm
"sra2h r<RA>, r<RB>, <imm>"
	signed32 src = imm;
	while (src > 15) src -= 16;
	while (src < -16) src += 16;
	do_srah(_SD, Ra, RbH, src, 1);
	do_srah(_SD, Ra, RbL, src, 0);




// SRC

void::function::do_src:unsigned32 *ra, unsigned32 rb, int src
	unsigned32 value;
	unsigned64 operand;
	unsigned64 shifted;
	while (src > 31) src -= 32;
	while (src < -32) src += 32;
	if (src >= 0)
	  {
	    operand = (INSERTED64(rb, 0, 31) | INSERTED64(*ra, 32, 63));
	    shifted = operand >> src;
	    value = EXTRACTED64(shifted, 32, 63);
	  }
	else
	  {
	    operand = (INSERTED64(*ra, 0, 31) | INSERTED64(rb, 32, 63));
	    shifted = operand << -src;
	    value = EXTRACTED64(shifted, 0, 31);
	  }
	WRITE32_QUEUE (ra, value);

_LOGIC,10110,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRC
"src r<RA>, r<RB>, r<RC>"
	do_src(_SD, Ra, Rb, Rc);
_LOGIC,10110,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRC imm
"src r<RA>, r<RB>, <imm>"
	do_src(_SD, Ra, Rb, imm);




// SRL

void::function::do_srl:unsigned32 *ra, unsigned32 rb, int src
	unsigned32 value;
	while (src > 31) src -= 32;
	while (src < -32) src += 32;
	if (src >= 0)
	  value = (unsigned32)rb >> src;
	else if (src == -32)
	  value = 0;
	else
	  value = (unsigned32)rb << -src;
	WRITE32_QUEUE (ra, value);

_LOGIC,10010,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRL
"srl r<RA>, r<RB>, r<RC>"
	do_srl(_SD, Ra, Rb, Rc);
_LOGIC,10010,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRL imm
"srl r<RA>, r<RB>, <imm>"
	do_srl(_SD, Ra, Rb, imm);




// SRLHp

void::function::do_srlh:unsigned32 *ra, unsigned32 rb, int src, int high
	unsigned32 value;
	while (src > 31) src -= 32;
	while (src < -32) src += 32;
	if (src >= 0)
	  value = rb >> src;
	else if (src == -32)
	  value = 0;
	else
	  value = rb << -src;
	if (high)
	  WRITE32_QUEUE_MASK (ra, value << 16, 0xffff0000);
	else
	  WRITE32_QUEUE_MASK (ra, value, 0x0000ffff);

_LOGIC,0011,p,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRLHP
"srlh%s<p> r<RA>, r<RB>, r<RC>"
	do_srlh(_SD, Ra, Rb, Rc, p);
_LOGIC,0011,p,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRLHP imm
"srlh%s<p> r<RA>, r<RB>, <imm>"
	do_srlh(_SD, Ra, Rb, imm, p);


// SRL2H

_LOGIC,10011,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRL2H
"srl2h r<RA>, r<RB>, r<RC>"
	signed32 srcH = RcH;
	signed32 srcL = RcL;
	while (srcH > 15) srcH -= 16;
	while (srcH < -16) srcH += 16;
	while (srcL > 15) srcL -= 16;
	while (srcL < -16) srcL += 16;
	do_srlh(_SD, Ra, RbHU, srcH, 1);
	do_srlh(_SD, Ra, RbLU, srcL, 0);
_LOGIC,10011,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRL2H imm
"srl2h r<RA>, r<RB>, <imm>"
	signed32 src = imm;
	while (src > 15) src -= 16;
	while (src < -16) src += 16;
	do_srlh(_SD, Ra, RbHU, src, 1);
	do_srlh(_SD, Ra, RbLU, src, 0);




// ST2H

void::function::get_even_reg:int *reg, unsigned32 *r0, const char *name
	if (*reg & 1)
	  sim_engine_abort (SD, CPU, cia,
			    "0x%lx:%s odd register (r%d) used in multi-word store",
			    (long) cia, name, *reg);
	if (*reg == 0)
	  *r0 = 0;
	else
	  *r0 = GPR[*reg];

void::function::do_st2h:int ra, unsigned32 rb, unsigned32 src
	unsigned32 val_ra;
	unsigned32 mem;
	get_even_reg(_SD, &ra, &val_ra, "ST2H");
	mem = INSERTED32(val_ra, 0, 15) |
	      INSERTED32(GPR[ra + 1], 16, 31);
	STORE(rb + src, 4, mem);

_IMEM,10011,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:ST2H
"st2h r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
"st2h r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
	do_st2h(_SD, RA, Rb, src);
	do_incr(_SD, XX, &GPR[RB], 4);
_IMEM,10011,10,6.RA,6.RB,_IMM32:IMEM:long:mu:ST2H long
"st2h r<RA>, @@(r<RB>, <imm>)"
	do_st2h(_SD, RA, Rb, imm);



// ST2W

void::function::do_st2w:int ra, unsigned32 rb, unsigned32 src
	unsigned32 val_ra;
	unsigned64 mem;
	get_even_reg(_SD, &ra, &val_ra, "ST2W");
	mem = INSERTED64(val_ra, 0, 31) | INSERTED64(GPR[ra + 1], 32, 63);
	STORE(rb + src, 8, mem);

_IMEM,10110,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:ST2W
"st2w r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
"st2w r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
	do_st2w(_SD, RA, Rb, src);
	do_incr(_SD, XX, &GPR[RB], 8);
_IMEM,10110,10,6.RA,6.RB,_IMM32:IMEM:long:mu:ST2W long
"st2w r<RA>, @@(r<RB>, <imm>)"
	do_st2w(_SD, RA, Rb, imm);



// ST4HB

void::function::do_st4hb:int ra, unsigned32 rb, unsigned32 src
	unsigned32 val_ra;
	unsigned32 mem;
	get_even_reg(_SD, &ra, &val_ra, "ST4HB");
	mem = INSERTED32(EXTRACTED32(val_ra, 8, 15), 0, 7) |
	      INSERTED32(EXTRACTED32(val_ra, 24, 31), 8, 15) |
	      INSERTED32(EXTRACTED32(GPR[ra + 1], 8, 15), 16, 23) |
	      INSERTED32(EXTRACTED32(GPR[ra + 1], 24, 31), 24, 31);
	STORE(rb + src, 4, mem);

_IMEM,10101,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:ST4HB
"st4hb r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
"st4hb r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
	do_st4hb(_SD, RA, Rb, src);
	do_incr(_SD, XX, &GPR[RB], 4);
_IMEM,10101,10,6.RA,6.RB,_IMM32:IMEM:long:mu:ST4HB long
"st4hb r<RA>, @@(r<RB>, <imm>)"
	do_st4hb(_SD, RA, Rb, imm);



// STB

void::function::do_stb:unsigned32 ra, unsigned32 rb, unsigned32 src
	STORE(rb + src, 1, EXTRACTED32(ra, 24, 31));

_IMEM,10000,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:STB
"stb r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
"stb r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
	do_stb(_SD, val_Ra, Rb, src);
	do_incr(_SD, XX, &GPR[RB], 1);
_IMEM,10000,10,6.RA,6.RB,_IMM32:IMEM:long:mu:STB long
"stb r<RA>, @@(r<RB>, <imm>)"
	do_stb(_SD, val_Ra, Rb, imm);



// STH

void::function::do_sth:unsigned32 ra, unsigned32 rb, unsigned32 src
	STORE(rb + src, 2, EXTRACTED32(ra, 16, 31));

_IMEM,10010,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:STH
"sth r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
"sth r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
	do_sth(_SD, val_Ra, Rb, src);
	do_incr(_SD, XX, &GPR[RB], 2);
_IMEM,10010,10,6.RA,6.RB,_IMM32:IMEM:long:mu:STH long
"sth r<RA>, @@(r<RB>, <imm>)"
	do_sth(_SD, val_Ra, Rb, imm);



// STHH

void::function::do_sthh:unsigned32 ra, unsigned32 rb, unsigned32 src
	STORE(rb + src, 2, EXTRACTED32(ra, 0, 15));

_IMEM,10001,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:STHH
"sthh r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
"sthh r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
	do_sthh(_SD, val_Ra, Rb, src);
	do_incr(_SD, XX, &GPR[RB], 2);
_IMEM,10001,10,6.RA,6.RB,_IMM32:IMEM:long:mu:STHH long
"sthh r<RA>, @@(r<RB>, <imm>)"
	do_sthh(_SD, val_Ra, Rb, imm);



// STW

void::function::do_stw:unsigned32 ra, unsigned32 rb, unsigned32 src
	STORE(rb + src, 4, ra);

_IMEM,10100,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:STW
"stw r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
"stw r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
	do_stw(_SD, val_Ra, Rb, src);
	do_incr(_SD, XX, &GPR[RB], 4);
_IMEM,10100,10,6.RA,6.RB,_IMM32:IMEM:long:mu:STW long
"stw r<RA>, @@(r<RB>, <imm>)"
	do_stw(_SD, val_Ra, Rb, imm);



// SUB

void::function::do_sub:unsigned32 *ra, unsigned32 rb, unsigned32 imm
	ALU_BEGIN(rb);
	ALU_SUBB(imm);
	ALU_END(ra);

_IALU1,00010,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:SUB
"sub r<RA>, r<RB>, r<RC>"
	do_sub (_SD, Ra, Rb, Rc);
_IALU1,00010,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:SUB imm
"sub r<RA>, r<RB>, <imm>"
	do_sub (_SD, Ra, Rb, imm);
_IALU1,00010,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:SUB imm long
"sub r<RA>, r<RB>, <imm>"
	do_sub (_SD, Ra, Rb, imm);



// SUB2H

void::function::do_sub2h:unsigned32 *ra, unsigned32 rb, unsigned32 imm
	unsigned16 high = VH2_4(rb) - VH2_4(imm);
	unsigned16 low  = VL2_4(rb) - VL2_4(imm);
	WRITE32_QUEUE (ra, (high << 16) | low);

_IALU1,00011,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:SUB2H
"sub2h r<RA>, r<RB>, r<RC>"
	do_sub2h (_SD, Ra, Rb, Rc);
_IALU1,00011,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:SUB2H imm
"sub2h r<RA>, r<RB>, <imm>"
	do_sub2h (_SD, Ra, Rb, immHL);
_IALU1,00011,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:SUB2H imm long
"sub2h r<RA>, r<RB>, <imm>"
	do_sub2h (_SD, Ra, Rb, imm);



// SUBB

void::function::do_subb:unsigned32 *ra, unsigned32 rb, unsigned32 imm
	ALU_BEGIN(rb);
	ALU_SUBB_B(imm, ALU_CARRY);
	ALU_END(ra);
	
_IALU1,00101,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:SUBB
"subb r<RA>, r<RB>, r<RC>"
	do_subb (_SD, Ra, Rb, Rc);
_IALU1,00101,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:SUBB imm
"subb r<RA>, r<RB>, <imm>"
	do_subb (_SD, Ra, Rb, imm);
_IALU1,00101,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:SUBB imm long
"subb r<RA>, r<RB>, <imm>"
	do_subb (_SD, Ra, Rb, imm);



// SUBHppp

void::function::do_subh_ppp:int ppp, unsigned32 *ra, unsigned32 rb, unsigned32 src
	switch (ppp) {
	case 0x0: /* LLL */
	  {
	  ALU16_BEGIN(VL2_4(rb));
	  ALU16_SUBB(VL2_4(src));
	  ALU16_END(ra, 0);
	  }
	  break;
	case 0x1: /* LLH */
	  {
	  ALU16_BEGIN(VL2_4(rb));
	  ALU16_SUBB(VH2_4(src));
	  ALU16_END(ra, 0);
	  }
	  break;
	case 0x2: /* LHL */
	  {
	  ALU16_BEGIN(VH2_4(rb));
	  ALU16_SUBB(VL2_4(src));
	  ALU16_END(ra, 0);
	  }
	  break;
	case 0x3: /* LHH */
	  {
	  ALU16_BEGIN(VH2_4(rb));
	  ALU16_SUBB(VH2_4(src));
	  ALU16_END(ra, 0);
	  }
	  break;
	case 0x4: /* HLL */
	  {
	  ALU16_BEGIN(VL2_4(rb));
	  ALU16_SUBB(VL2_4(src));
	  ALU16_END(ra, 1);
	  }
	  break;
	case 0x5: /* HLH */
	  {
	  ALU16_BEGIN(VL2_4(rb));
	  ALU16_SUBB(VH2_4(src));
	  ALU16_END(ra, 1);
	  }
	  break;
	case 0x6: /* HHL */
	  {
	  ALU16_BEGIN(VH2_4(rb));
	  ALU16_SUBB(VL2_4(src));
	  ALU16_END(ra, 1);
	  }
	  break;
	case 0x7: /* HHH */
	  {
	  ALU16_BEGIN(VH2_4(rb));
	  ALU16_SUBB(VH2_4(src));
	  ALU16_END(ra, 1);
	  }
	  break;
	default:
	  sim_engine_abort (SD, CPU, cia, "do_subh_ppp - internal error - bad switch");
	}

_IALU1,11,ppp,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:SUBHppp
"subh%s<ppp> r<RA>, r<RB>, r<RC>"
	do_subh_ppp(_SD, ppp, Ra, Rb, Rc);
_IALU1,11,ppp,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:SUBHppp imm
"subh%s<ppp> r<RA>, r<RB>, <imm>"
	do_subh_ppp(_SD, ppp, Ra, Rb, immHL);
_IALU1,11,ppp,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:SUBHppp imm long
"subh%s<ppp> r<RA>, r<RB>, <imm>"
	do_subh_ppp(_SD, ppp, Ra, Rb, imm);



// TRAP

address_word::function::do_trap:address_word trap_vector, address_word nia
	/* Steal trap 31 for doing system calls */
	/* System calls are defined in libgloss/d30v/syscall.h.  */
	if (trap_vector == EIT_VB + 0x20 + (31 << 3))
	  {
	    enum { PARM1 = 2, PARM2, PARM3, PARM4, FUNC };
	    if (GPR[FUNC] == 1)		/* exit */
	      {
	        sim_engine_halt (sd, STATE_CPU (sd, 0), NULL, cia, sim_exited,
		  	         GPR[PARM1]);
	        return -1; /* dummy */
	      }
	    else
	      {
		CB_SYSCALL syscall;

		CB_SYSCALL_INIT (&syscall);
		syscall.arg1 = GPR[PARM1];
		syscall.arg2 = GPR[PARM2];
		syscall.arg3 = GPR[PARM3];
		syscall.arg4 = GPR[PARM4];
		syscall.func = GPR[FUNC];
		syscall.p1 = (PTR) SD;
		syscall.read_mem = d30v_read_mem;
		syscall.write_mem = d30v_write_mem;

		WRITE32_QUEUE (&GPR[PARM1],
			       ((cb_syscall (STATE_CALLBACK (SD), &syscall)
				 == CB_RC_OK)
				? syscall.result
				: -syscall.errcode));
		return nia;
	      }
	  }
	else if (TRACE_TRAP_P)
	  {
	    int reg, i;
	    sim_io_eprintf (sd, "\nTrap %ld:\n", (long) ((trap_vector - (EIT_VB + 0x20)) >> 3));
	    for (reg = 0; reg < NR_GENERAL_PURPOSE_REGISTERS; reg += 8)
	      {
		sim_io_eprintf (sd, "r%.2d  - r%.2d: ", reg, reg+7);
		for (i = 0; i < 8; i++)
		  sim_io_eprintf (sd, " 0x%.8lx", (long) GPR[reg+i]);
		sim_io_eprintf (sd, "\n");
	      }

	    for (reg = 0; reg < 16; reg += 8)
	      {
		sim_io_eprintf (sd, "cr%.2d - cr%.2d:", reg, reg+7);
		for (i = 0; i < 8; i++)
		  sim_io_eprintf (sd, " 0x%.8lx", (long) CREG[reg+i]);
		sim_io_eprintf (sd, "\n");
	      }

	    sim_io_eprintf (sd, "a0   - a1:  ");
	    for (reg = 0; reg < NR_ACCUMULATORS; reg++)
	      sim_io_eprintf (sd, " 0x%.8lx 0x%.8lx",
			      (long)EXTRACTED64(ACC[reg], 0, 31),
			      (long)EXTRACTED64(ACC[reg], 32, 63));
	    sim_io_eprintf (sd, "\n");

	    sim_io_eprintf (sd, "f0   - f7:  ");
	    sim_io_eprintf (sd, "     (f0) %d", (int) PSW_VAL(PSW_F0));
	    sim_io_eprintf (sd, "     (f1) %d", (int) PSW_VAL(PSW_F1));
	    sim_io_eprintf (sd, "     (f2) %d", (int) PSW_VAL(PSW_F2));
	    sim_io_eprintf (sd, "     (f3) %d", (int) PSW_VAL(PSW_F3));
	    sim_io_eprintf (sd, "      (s) %d", (int) PSW_VAL(PSW_S));
	    sim_io_eprintf (sd, "      (v) %d", (int) PSW_VAL(PSW_V));
	    sim_io_eprintf (sd, "     (va) %d", (int) PSW_VAL(PSW_VA));
	    sim_io_eprintf (sd, "      (c) %d\n", (int) PSW_VAL(PSW_C));

	    sim_io_eprintf (sd, "pswh:       ");
	    sim_io_eprintf (sd, "     (sm) %d", (int) PSW_VAL(PSW_SM));
	    sim_io_eprintf (sd, "     (ea) %d", (int) PSW_VAL(PSW_EA));
	    sim_io_eprintf (sd, "     (ie) %d", (int) PSW_VAL(PSW_IE));
	    sim_io_eprintf (sd, "     (rp) %d", (int) PSW_VAL(PSW_RP));
	    sim_io_eprintf (sd, "     (md) %d", (int) PSW_VAL(PSW_MD));

	    if (PSW_VAL(PSW_DB))
	      sim_io_eprintf (sd, "     (db) %d", (int) PSW_VAL(PSW_DB));

	    if (PSW_VAL(PSW_DS))
	      sim_io_eprintf (sd, "     (ds) %d", (int) PSW_VAL(PSW_DS));

	    sim_io_eprintf (sd, "\n");
	    return nia;
	  }
	else
	  {
	    if(PSW_VAL(PSW_RP) && RPT_E == cia)
	      {
		WRITE32_QUEUE (&bPC, RPT_S);
		if (RPT_C == 0)
		  PSW_SET (PSW_RP, 0);
	      }
	    else
	      WRITE32_QUEUE (&bPC, cia + 8);
	    DID_TRAP = 1;
	    return trap_vector;
	  }

_BRA,01001,00,6.**,6.**,6.RC:BRA:short:mu:TRAP
"trap r<RC>"
	nia = do_trap (_SD, EIT_VB + 0x20 + MASKED32(Rc, 24, 28), nia);
_BRA,01001,10,6.**,6.**,_IMM6:BRA:short:mu:TRAP imm
"trap <imm>"
	nia = do_trap (_SD, EIT_VB + 0x20 + (imm_5 << 3), nia);



// XOR

_LOGIC,11011,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:XOR
"xor r<RA>, r<RB>, r<RC>"
	WRITE32_QUEUE (Ra, Rb ^ Rc);
_LOGIC,11011,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:XOR imm
"xor r<RA>, r<RB>, <imm>"
	WRITE32_QUEUE (Ra, Rb ^ imm);
_LOGIC,11011,10,6.RA,6.RB,_IMM32:LOGIC:long:iu,mu:XOR imm long
"xor r<RA>, r<RB>, <imm>"
	WRITE32_QUEUE (Ra, Rb ^ imm);



// XORFG

_LOGIC,01011,00,***,3.FA,***,3.FB,***,3.FC:LOGIC:short:iu,mu:XORFG
"xorfg f<FA>, f<FB>, f<FC>"
	PSW_FLAG_SET_QUEUE(FA, PSW_FLAG_VAL(FB) ^ PSW_FLAG_VAL(FC));
_LOGIC,01011,10,***,3.FA,***,3.FB,_IMM6:LOGIC:short:iu,mu:XORFG imm
"xorfg f<FA>, f<FB>, <imm_6>"
	PSW_FLAG_SET_QUEUE(FA, PSW_FLAG_VAL(FB) ^ (imm_6 & 1));



@


1.2.14.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d1 2424
a2424 2421
# OBSOLETE //  -*- C -*-
# OBSOLETE //  Mitsubishi Electric Corp. D30V Simulator.
# OBSOLETE //  Copyright (C) 1997, Free Software Foundation, Inc.
# OBSOLETE //  Contributed by Cygnus Solutions Inc.
# OBSOLETE //
# OBSOLETE //  This file is part of GDB, the GNU debugger.
# OBSOLETE //
# OBSOLETE //  This program is free software; you can redistribute it and/or modify
# OBSOLETE //  it under the terms of the GNU General Public License as published by
# OBSOLETE //  the Free Software Foundation; either version 2 of the License, or
# OBSOLETE //  (at your option) any later version.
# OBSOLETE //
# OBSOLETE //  This program is distributed in the hope that it will be useful,
# OBSOLETE //  but WITHOUT ANY WARRANTY; without even the implied warranty of
# OBSOLETE //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# OBSOLETE //  GNU General Public License for more details.
# OBSOLETE //
# OBSOLETE //  You should have received a copy of the GNU General Public License
# OBSOLETE //  along with this program; if not, write to the Free Software
# OBSOLETE //  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# OBSOLETE //
# OBSOLETE 
# OBSOLETE 
# OBSOLETE define( _BRA,  `1.*,CCC,000')
# OBSOLETE define( _LOGIC, `1.*,CCC,001')
# OBSOLETE define( _IMEM, `1.*,CCC,010')
# OBSOLETE define( _IALU1, `1.*,CCC,100')
# OBSOLETE define(_IALU2, `1.*,CCC,101')
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE define(_IMM6, `6.IMM_6S')
# OBSOLETE define(_IMM12, `12.IMM_12S')
# OBSOLETE define(_IMM18, `18.IMM_18S')
# OBSOLETE define(_IMM32, `6.IMM_6L,*,000,8.IMM_8L,00,18.IMM_18L')
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // The following is called when ever an illegal instruction is
# OBSOLETE // encountered
# OBSOLETE ::internal::illegal
# OBSOLETE 	sim_io_eprintf (sd, "illegal instruction at 0x%lx\n", (long) cia);
# OBSOLETE 	sim_engine_halt (SD, CPU, NULL, cia, sim_signalled, SIM_SIGILL);
# OBSOLETE 
# OBSOLETE // The following is called when ever an instruction in the wrong
# OBSOLETE // slot is encountered.
# OBSOLETE ::internal::wrong_slot
# OBSOLETE 	sim_io_eprintf (sd, "wrong slot at 0x%lx\n", (long) cia);
# OBSOLETE 	sim_engine_halt (SD, CPU, NULL, cia, sim_signalled, SIM_SIGILL);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // Something illegal that can be used to contact the simulator emul
# OBSOLETE // library.
# OBSOLETE define(_EMUL, `1.*,CCC,111')
# OBSOLETE 
# OBSOLETE void::function::do_emul:int imm
# OBSOLETE 	/* temp hack - later replace with real interface */
# OBSOLETE 	enum {
# OBSOLETE 	  param1 = 2, param2, param3, param4
# OBSOLETE 	};
# OBSOLETE 	switch (imm) {
# OBSOLETE 	case 0:
# OBSOLETE 	  {
# OBSOLETE 	    sim_engine_abort (SD, CPU, cia, "UNIX call emulation unsupported");
# OBSOLETE 	    break;
# OBSOLETE 	  }
# OBSOLETE 	case 1:
# OBSOLETE 	  /* Trap 1 - prints a string */
# OBSOLETE 	  {
# OBSOLETE 	    address_word str = GPR[param1];
# OBSOLETE 	    char chr;
# OBSOLETE 	    while (1) {
# OBSOLETE 	      chr = MEM (unsigned, str, 1);
# OBSOLETE 	    if (chr == '\0') break;
# OBSOLETE 	      sim_io_write_stdout (sd, &chr, sizeof chr);
# OBSOLETE 	      str++;
# OBSOLETE 	    }
# OBSOLETE 	    break;
# OBSOLETE 	  }
# OBSOLETE 	case 3:
# OBSOLETE 	  /* Trap 3 - writes a character */
# OBSOLETE 	  {
# OBSOLETE 	    char chr = GPR[param1];
# OBSOLETE 	    sim_io_write_stdout (sd, &chr, sizeof chr);
# OBSOLETE 	    break;
# OBSOLETE 	  }
# OBSOLETE 	case 4:
# OBSOLETE 	  /* Trap 4 exits with status in [param1] */
# OBSOLETE 	  {
# OBSOLETE 	    sim_engine_halt (SD, CPU, NULL, cia, sim_exited, GPR[param1]);
# OBSOLETE 	    break;
# OBSOLETE 	  }
# OBSOLETE 	case 5:
# OBSOLETE 	  /* Trap 5 breakpoints.  If the breakpoint system knows about this, it
# OBSOLETE 	     won't return.  Otherwise, we fall through to treat this as an
# OBSOLETE 	     unknown instruction.  */
# OBSOLETE 	  {
# OBSOLETE 	    sim_handle_breakpoint (SD, CPU, cia);
# OBSOLETE 	  /* Fall through to default case.*/
# OBSOLETE 	  }
# OBSOLETE 	default:
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "Unknown monitor call %d", imm);
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _EMUL,00000,00,6.*,6.*,IMM_6S:EMUL:short,emul:iu,mu:EMUL
# OBSOLETE "syscall <imm>"
# OBSOLETE 	do_emul (_SD, imm);
# OBSOLETE _BRA,00000,00,6.**,6.**,_IMM32:BRA:long:iu,mu:EMUL long
# OBSOLETE "syscall <imm>"
# OBSOLETE 	do_emul (_SD, imm);
# OBSOLETE 
# OBSOLETE // ABS
# OBSOLETE 
# OBSOLETE _IALU1,01000,00,6.RA,6.RB,6.**:IALU1:short:iu,mu:ABS
# OBSOLETE "abs r<RA>, r<RB>"
# OBSOLETE 	WRITE32_QUEUE (Ra, abs(Rb));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ADD
# OBSOLETE 
# OBSOLETE void::function::do_add:unsigned32 *ra, unsigned32 rb, unsigned32 imm
# OBSOLETE 	ALU_BEGIN(rb);
# OBSOLETE 	ALU_ADDC(imm);
# OBSOLETE 	ALU_END(ra);
# OBSOLETE 
# OBSOLETE _IALU1,00000,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:ADD
# OBSOLETE "add r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_add (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,00000,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:ADD imm
# OBSOLETE "add r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_add (_SD, Ra, Rb, imm);
# OBSOLETE _IALU1,00000,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:ADD imm long
# OBSOLETE "add r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_add (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ADD2H
# OBSOLETE 
# OBSOLETE void::function::do_add2h:signed32 *ra, signed32 rb, signed32 imm
# OBSOLETE 	unsigned16 ah2 = VH2_4(rb) + VH2_4(imm);
# OBSOLETE 	unsigned16 al2 = VL2_4(rb) + VL2_4(imm);
# OBSOLETE 	WRITE32_QUEUE (ra, (ah2 << 16) | al2);
# OBSOLETE 
# OBSOLETE _IALU1,00001,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:ADD2H
# OBSOLETE "add2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_add2h (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,00001,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:ADD2H imm
# OBSOLETE "add2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_add2h (_SD, Ra, Rb, immHL);
# OBSOLETE _IALU1,00001,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:ADD2H imm long
# OBSOLETE "add2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_add2h (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ADDC
# OBSOLETE 
# OBSOLETE void::function::do_addc:unsigned32 *ra, unsigned32 rb, unsigned32 imm
# OBSOLETE 	ALU_BEGIN(rb);
# OBSOLETE 	ALU_ADDC_C(imm, ALU_CARRY);
# OBSOLETE 	ALU_END(ra);
# OBSOLETE 
# OBSOLETE _IALU1,00100,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:ADDC
# OBSOLETE "addc r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_addc (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,00100,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:ADDC imm
# OBSOLETE "addc r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_addc (_SD, Ra, Rb, imm);
# OBSOLETE _IALU1,00100,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:ADDC imm long
# OBSOLETE "addc r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_addc (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ADDHppp
# OBSOLETE 
# OBSOLETE void::function::do_addh_ppp:int ppp, unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	switch (ppp) {
# OBSOLETE 	case 0x0: /* LLL */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VL2_4(rb));
# OBSOLETE 	  ALU16_ADDC(VL2_4(src));
# OBSOLETE 	  ALU16_END(ra, 0);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x1: /* LLH */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VL2_4(rb));
# OBSOLETE 	  ALU16_ADDC(VH2_4(src));
# OBSOLETE 	  ALU16_END(ra, 0);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x2: /* LHL */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VH2_4(rb));
# OBSOLETE 	  ALU16_ADDC(VL2_4(src));
# OBSOLETE 	  ALU16_END(ra, 0);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x3: /* LHH */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VH2_4(rb));
# OBSOLETE 	  ALU16_ADDC(VH2_4(src));
# OBSOLETE 	  ALU16_END(ra, 0);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x4: /* HLL */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VL2_4(rb));
# OBSOLETE 	  ALU16_ADDC(VL2_4(src));
# OBSOLETE 	  ALU16_END(ra, 1);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x5: /* HLH */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VL2_4(rb));
# OBSOLETE 	  ALU16_ADDC(VH2_4(src));
# OBSOLETE 	  ALU16_END(ra, 1);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x6: /* HHL */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VH2_4(rb));
# OBSOLETE 	  ALU16_ADDC(VL2_4(src));
# OBSOLETE 	  ALU16_END(ra, 1);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x7: /* HHH */
# OBSOLETE 	  {	
# OBSOLETE 	  ALU16_BEGIN(VH2_4(rb));
# OBSOLETE 	  ALU16_ADDC(VH2_4(src));
# OBSOLETE 	  ALU16_END(ra, 1);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	default:
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "do_addh_ppp - internal error - bad switch");
# OBSOLETE 	}
# OBSOLETE ::%s::ppp:int ppp
# OBSOLETE 	switch (ppp)
# OBSOLETE 	  {
# OBSOLETE 	  case 0x0: return "lll";
# OBSOLETE 	  case 0x1: return "llh";
# OBSOLETE 	  case 0x2: return "lhl";
# OBSOLETE 	  case 0x3: return "lhh";
# OBSOLETE 	  case 0x4: return "hll";
# OBSOLETE 	  case 0x5: return "hlh";
# OBSOLETE 	  case 0x6: return "hhl";
# OBSOLETE 	  case 0x7: return "hhh";
# OBSOLETE 	  default: return "?";
# OBSOLETE 	  }
# OBSOLETE 
# OBSOLETE _IALU1,10,ppp,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:ADDHppp
# OBSOLETE "addh%s<ppp> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_addh_ppp(_SD, ppp, Ra, Rb, Rc);
# OBSOLETE _IALU1,10,ppp,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:ADDHppp imm
# OBSOLETE "addh%s<ppp> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_addh_ppp(_SD, ppp, Ra, Rb, immHL);
# OBSOLETE _IALU1,10,ppp,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:ADDHppp imm long
# OBSOLETE "addh%s<ppp> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_addh_ppp(_SD, ppp, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ADDS
# OBSOLETE 
# OBSOLETE void::function::do_adds:unsigned32 *ra, unsigned32 rb, unsigned32 imm
# OBSOLETE 	ALU_BEGIN(rb);
# OBSOLETE 	ALU_ADDC(EXTRACTED32(imm, 0, 0));
# OBSOLETE 	ALU_END(ra);
# OBSOLETE 
# OBSOLETE _IALU1,00110,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:ADDS
# OBSOLETE "adds r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_adds (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,00110,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:ADDS imm
# OBSOLETE "adds r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_adds (_SD, Ra, Rb, imm);
# OBSOLETE _IALU1,00110,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:ADDS imm long
# OBSOLETE "adds r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_adds (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ADDS2H
# OBSOLETE 
# OBSOLETE void::function::do_adds2h:unsigned32 *ra, unsigned32 rb, unsigned32 immHL
# OBSOLETE 	unsigned16 high = VH2_4(rb) + EXTRACTED32(immHL, 0, 0);
# OBSOLETE 	unsigned16 low = VL2_4(rb) + EXTRACTED32(immHL, 16, 16);
# OBSOLETE 	WRITE32_QUEUE (ra, (high << 16) | low);
# OBSOLETE 
# OBSOLETE _IALU1,00111,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:ADDS2H
# OBSOLETE "adds2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_adds2h (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,00111,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:ADDS2H imm
# OBSOLETE "adds2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_adds2h (_SD, Ra, Rb, immHL);
# OBSOLETE _IALU1,00111,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:ADDS2H imm long
# OBSOLETE "adds2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_adds2h (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // AND
# OBSOLETE 
# OBSOLETE _LOGIC,11000,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:AND
# OBSOLETE "and r<RA>, r<RB>, r<RC>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb & Rc);
# OBSOLETE _LOGIC,11000,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:AND imm
# OBSOLETE "and r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb & imm);
# OBSOLETE _LOGIC,11000,10,6.RA,6.RB,_IMM32:LOGIC:long:iu,mu:AND imm long
# OBSOLETE "and r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb & imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ANDFG
# OBSOLETE 
# OBSOLETE _LOGIC,01000,00,***,3.FA,***,3.FB,***,3.FC:LOGIC:short:iu,mu:Logical AND Flags
# OBSOLETE "andfg f<FA>, f<FB>, f<FC>"
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, PSW_FLAG_VAL(FB) & PSW_FLAG_VAL(FC));
# OBSOLETE _LOGIC,01000,10,***,3.FA,***,3.FB,_IMM6:LOGIC:short:iu,mu:Logical AND Flags imm
# OBSOLETE "andfg f<FA>, f<FB>, <imm_6>"
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, PSW_FLAG_VAL(FB) & (imm_6 & 1));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // AVG
# OBSOLETE 
# OBSOLETE void::function::do_avg:unsigned32 *ra, unsigned32 rb, unsigned32 imm
# OBSOLETE 	WRITE32_QUEUE (ra, ((signed64)(signed32)rb + (signed64)(signed32)imm + 1) >> 1);
# OBSOLETE 
# OBSOLETE _IALU1,01010,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:AVG
# OBSOLETE "avg r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_avg (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,01010,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:AVG imm
# OBSOLETE "avg r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_avg (_SD, Ra, Rb, imm);
# OBSOLETE _IALU1,01010,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:AVG imm long
# OBSOLETE "avg r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_avg (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // AVG2H
# OBSOLETE 
# OBSOLETE void::function::do_avg2h:unsigned32 *ra, unsigned32 rb, unsigned32 imm
# OBSOLETE 	unsigned16 high = ((signed32)(signed16)VH2_4(rb) + (signed32)(signed16)VH2_4(imm) + 1) >> 1;
# OBSOLETE 	unsigned16 low  = ((signed32)(signed16)VL2_4(rb) + (signed32)(signed16)VL2_4(imm) + 1) >> 1;
# OBSOLETE 	WRITE32_QUEUE (ra, (high << 16) | low);
# OBSOLETE 
# OBSOLETE _IALU1,01011,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:AVG2H
# OBSOLETE "avg2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_avg2h (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,01011,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:AVG2H imm
# OBSOLETE "avg2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_avg2h (_SD, Ra, Rb, immHL);
# OBSOLETE _IALU1,01011,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:AVG2H imm long
# OBSOLETE "avg2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_avg2h (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BCLR
# OBSOLETE 
# OBSOLETE _LOGIC,00011,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:BCLR
# OBSOLETE "bclr r<RA>, r<RB>, r<RC>"
# OBSOLETE 	WRITE32_QUEUE(Ra, Rb & ~BIT32((Rc) % 32));
# OBSOLETE _LOGIC,00011,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:BCLR imm
# OBSOLETE "bclr r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE(Ra, Rb & ~BIT32((imm) % 32));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BNOT
# OBSOLETE 
# OBSOLETE _LOGIC,00001,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:BNOT
# OBSOLETE "bnot r<RA>, r<RB>, r<RC>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb ^ BIT32((Rc) % 32));
# OBSOLETE _LOGIC,00001,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:BNOT imm
# OBSOLETE "bnot r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb ^ BIT32((imm) % 32));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BRA
# OBSOLETE 
# OBSOLETE _BRA,00000,00,6.**,6.**,6.RC:BRA:short:mu:BRA
# OBSOLETE "bra r<RC>"
# OBSOLETE 	nia = cia + pcdisp;
# OBSOLETE _BRA,00000,10,_IMM18:BRA:short:mu:BRA imm
# OBSOLETE "bra <pcdisp>"
# OBSOLETE 	nia = cia + pcdisp;
# OBSOLETE _BRA,00000,10,6.**,6.**,_IMM32:BRA:long:mu:BRA imm long
# OBSOLETE "bra <pcdisp>"
# OBSOLETE 	nia = cia + pcdisp;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BRATNZ
# OBSOLETE 
# OBSOLETE _BRA,00100,01,6.RA,6.**,6.RC:BRA:short:mu:BRATNZ
# OBSOLETE "bratnz r<RC>"
# OBSOLETE 	if (*Ra != 0)
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE _BRA,00100,11,6.RA,_IMM12:BRA:short:mu:BRATNZ imm
# OBSOLETE "bratnz <pcdisp>"
# OBSOLETE 	if (*Ra != 0)
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE _BRA,00100,11,6.RA,6.**,_IMM32:BRA:long:mu:BRATNZ imm long
# OBSOLETE "bratnz <pcdisp>"
# OBSOLETE 	if (*Ra != 0)
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BRATZR
# OBSOLETE 
# OBSOLETE _BRA,00100,00,6.RA,6.**,6.RC:BRA:short:mu:BRATZR
# OBSOLETE "bratzr r<RC>"
# OBSOLETE 	if (val_Ra == 0)
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE _BRA,00100,10,6.RA,_IMM12:BRA:short:mu:BRATZR imm
# OBSOLETE "bratzr <pcdisp>"
# OBSOLETE 	if (val_Ra == 0)
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE _BRA,00100,10,6.RA,6.**,_IMM32:BRA:long:mu:BRATZR imm long
# OBSOLETE "bratzr <pcdisp>"
# OBSOLETE 	if (val_Ra == 0)
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BSET
# OBSOLETE 
# OBSOLETE _LOGIC,00010,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:BSET
# OBSOLETE "bset r<RA>, r<RB>, r<RC>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb | BIT32((Rc) % 32));
# OBSOLETE _LOGIC,00010,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:BSET imm
# OBSOLETE "bset r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb | BIT32((imm) % 32));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BSR
# OBSOLETE 
# OBSOLETE _BRA,00010,00,6.**,6.**,6.RC:BRA:short:mu:BSR
# OBSOLETE "bsr r<RC>"
# OBSOLETE 	if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	nia = cia + pcdisp;
# OBSOLETE 	if (TRACE_CALL_P)
# OBSOLETE 	  TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE _BRA,00010,10,_IMM18:BRA:short:mu:BSR imm
# OBSOLETE "bsr <pcdisp>"
# OBSOLETE 	if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	nia = cia + pcdisp;
# OBSOLETE 	if (TRACE_CALL_P)
# OBSOLETE 	  TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE _BRA,00010,10,6.**,6.**,_IMM32:BRA:long:mu:BSR imm long
# OBSOLETE "bsr <pcdisp>"
# OBSOLETE 	if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	nia = cia + pcdisp;
# OBSOLETE 	if (TRACE_CALL_P)
# OBSOLETE 	  TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BSRTNZ
# OBSOLETE 
# OBSOLETE _BRA,00110,01,6.RA,6.**,6.RC:BRA:short:mu:BSRTNZ
# OBSOLETE "bsrtnz r<RC>"
# OBSOLETE 	if (val_Ra != 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _BRA,00110,11,6.RA,_IMM12:BRA:short:mu:BSRTNZ imm
# OBSOLETE "bsrtnz <pcdisp>"
# OBSOLETE 	if (val_Ra != 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _BRA,00110,11,6.RA,6.**,_IMM32:BRA:long:mu:BSRTNZ imm long
# OBSOLETE "bsrtnz <pcdisp>"
# OBSOLETE 	if (val_Ra != 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BSRTZR
# OBSOLETE 
# OBSOLETE _BRA,00110,00,6.RA,6.**,6.RC:BRA:short:mu:BSRTZR
# OBSOLETE "bsrtzr r<RC>"
# OBSOLETE 	if (val_Ra == 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _BRA,00110,10,6.RA,_IMM12:BRA:short:mu:BSRTZR imm
# OBSOLETE "bsrtzr <pcdisp>"
# OBSOLETE 	if (val_Ra == 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _BRA,00110,10,6.RA,6.**,_IMM32:BRA:long:mu:BSRTZR imm long
# OBSOLETE "bsrtzr <pcdisp>"
# OBSOLETE 	if (val_Ra == 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = cia + pcdisp;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // BTST
# OBSOLETE 
# OBSOLETE _LOGIC,00000,00,***,3.FA,6.RB,6.RC:LOGIC:short:iu,mu:BTST
# OBSOLETE "btst f<FA>, r<RB>, r<RC>"
# OBSOLETE 	int bit = (Rc) % 32;
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, MASKED32(Rb, bit, bit));
# OBSOLETE _LOGIC,00000,10,***,3.FA,6.RB,_IMM6:LOGIC:short:iu,mu:BTST imm
# OBSOLETE "btst f<FA>, r<RB>, <imm>"
# OBSOLETE 	int bit = imm % 32;
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, MASKED32(Rb, bit, bit));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // CMPcc
# OBSOLETE 
# OBSOLETE void::function::do_cmp_cc:int cc, int fa, signed32 rb, signed32 rc
# OBSOLETE 	int value = 0;
# OBSOLETE 	switch (cc) {
# OBSOLETE 	case 0: /* EQ */
# OBSOLETE 	  value = (rb == rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 1: /* NE */
# OBSOLETE 	  value = (rb != rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 2: /* GT */
# OBSOLETE 	  value = (rb > rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 3: /* GE */
# OBSOLETE 	  value = (rb >= rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 4: /* LT */
# OBSOLETE 	  value = (rb < rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 5: /* LE */
# OBSOLETE 	  value = (rb <= rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 6: /* PS */
# OBSOLETE 	  value = ((rb >= 0) && (rc >= 0));
# OBSOLETE 	  break;
# OBSOLETE 	case 7: /* NG */
# OBSOLETE 	  value = ((rb < 0) && (rc < 0));
# OBSOLETE 	  break;
# OBSOLETE 	default:
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "do_cmp_cc - internal error - bad switch (%d)", cc);
# OBSOLETE 	}
# OBSOLETE 	PSW_FLAG_SET_QUEUE(fa, value);
# OBSOLETE 
# OBSOLETE ::%s::ccc:int ccc
# OBSOLETE 	switch (ccc)
# OBSOLETE 	  {
# OBSOLETE 	  case 0: return "eq";
# OBSOLETE 	  case 1: return "ne";
# OBSOLETE 	  case 2: return "gt";
# OBSOLETE 	  case 3: return "ge";
# OBSOLETE 	  case 4: return "lt";
# OBSOLETE 	  case 5: return "le";
# OBSOLETE 	  case 6: return "ps";
# OBSOLETE 	  case 7: return "ng";
# OBSOLETE 	  default: return "?";
# OBSOLETE 	  }
# OBSOLETE 
# OBSOLETE _LOGIC,01100,00,ccc,3.FA,6.RB,6.RC:LOGIC:short:iu,mu:CMPcc
# OBSOLETE "cmp%s<ccc> f<FA>, r<RB>, r<RC>"
# OBSOLETE 	do_cmp_cc(_SD, ccc, FA, Rb, Rc);
# OBSOLETE _LOGIC,01100,10,ccc,3.FA,6.RB,_IMM6:LOGIC:short:iu,mu:CMPcc imm
# OBSOLETE "cmp%s<ccc> f<FA>, r<RB>, <imm>"
# OBSOLETE 	do_cmp_cc(_SD, ccc, FA, Rb, imm);
# OBSOLETE _LOGIC,01100,10,ccc,3.FA,6.RB,_IMM32:LOGIC:long:iu,mu:CMPcc imm long
# OBSOLETE "cmp%s<ccc> f<FA>, r<RB>, <imm>"
# OBSOLETE 	do_cmp_cc(_SD, ccc, FA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // CMPUcc
# OBSOLETE 
# OBSOLETE void::function::do_cmpu_cc:int cc, int fa, unsigned32 rb, unsigned32 rc
# OBSOLETE 	int value = 0;
# OBSOLETE 	switch (cc) {
# OBSOLETE 	case 2: /* GT */
# OBSOLETE 	  value = (rb > rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 3: /* GE */
# OBSOLETE 	  value = (rb >= rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 4: /* LT */
# OBSOLETE 	  value = (rb < rc);
# OBSOLETE 	  break;
# OBSOLETE 	case 5: /* LE */
# OBSOLETE 	  value = (rb <= rc);
# OBSOLETE 	  break;
# OBSOLETE 	default:
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "do_cmpu_cc - internal error - bad switch (%d)", cc);
# OBSOLETE 	}
# OBSOLETE 	PSW_FLAG_SET_QUEUE(fa, value);
# OBSOLETE 
# OBSOLETE _LOGIC,01101,00,ccc,3.FA,6.RB,6.RC:LOGIC:short:iu,mu:CMPUcc
# OBSOLETE "cmpu%s<ccc> f<FA>, r<RB>, r<RC>"
# OBSOLETE 	do_cmpu_cc(_SD, ccc, FA, Rb, Rc);
# OBSOLETE _LOGIC,01101,10,ccc,3.FA,6.RB,_IMM6:LOGIC:short:iu,mu:CMPUcc imm
# OBSOLETE "cmpu%s<ccc> f<FA>, r<RB>, <imm>"
# OBSOLETE 	do_cmpu_cc(_SD, ccc, FA, Rb, imm_6u);
# OBSOLETE _LOGIC,01101,10,ccc,3.FA,6.RB,_IMM32:LOGIC:long:iu,mu:CMPUcc imm long
# OBSOLETE "cmpu%s<ccc> f<FA>, r<RB>, <imm>"
# OBSOLETE 	do_cmpu_cc(_SD, ccc, FA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // DBRA
# OBSOLETE 
# OBSOLETE void::function::do_dbra:address_word pcdisp, unsigned32 ra
# OBSOLETE 	PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, cia + pcdisp);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, cia + (ra & ~0x7));
# OBSOLETE 
# OBSOLETE _BRA,10000,00,6.RA,6.**,6.RC:BRA:short:mu:DBRA
# OBSOLETE "dbra r<RA>, r<RC>"
# OBSOLETE 	do_dbra(_SD, pcdisp, val_Ra);
# OBSOLETE _BRA,10000,10,6.RA,_IMM12:BRA:short:mu:DBRA imm
# OBSOLETE "dbra r<RA>, <pcdisp>"
# OBSOLETE 	do_dbra(_SD, pcdisp, val_Ra);
# OBSOLETE _BRA,10000,10,6.RA,6.**,_IMM32:BRA:long:mu:DBRA imm long
# OBSOLETE "dbra r<RA>, <pcdisp>"
# OBSOLETE 	do_dbra(_SD, pcdisp, val_Ra);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // DBRAI
# OBSOLETE 
# OBSOLETE void::function::do_dbrai:address_word pcdisp, unsigned32 imm
# OBSOLETE 	PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, cia + pcdisp);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, cia + (imm << 3));
# OBSOLETE 
# OBSOLETE _BRA,10100,00,6.IMM_6,6.**,6.RC:BRA:short:mu:DBRAI
# OBSOLETE "dbrai <IMM_6>, r<RC>"
# OBSOLETE 	do_dbrai(_SD, pcdisp, IMM_6);
# OBSOLETE _BRA,10100,10,6.IMM_6,_IMM12:BRA:short:mu:DBRAI imm
# OBSOLETE "dbrai <IMM_6>, <pcdisp>"
# OBSOLETE 	do_dbrai(_SD, pcdisp, IMM_6);
# OBSOLETE _BRA,10100,10,6.IMM_6,6.**,_IMM32:BRA:long:mu:DBRAI imm long
# OBSOLETE "dbrai <IMM_6>, <pcdisp>"
# OBSOLETE 	do_dbrai(_SD, pcdisp, IMM_6);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // DBSR
# OBSOLETE 
# OBSOLETE void::function::do_dbsr:address_word pcdisp, unsigned32 ra
# OBSOLETE 	PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, cia + pcdisp);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, cia + ra);
# OBSOLETE 	WRITE32_QUEUE (&GPR[62], cia + ra + 8);
# OBSOLETE 
# OBSOLETE _BRA,10010,00,6.RA,6.**,6.RC:BRA:short:mu:DBSR
# OBSOLETE "dbsr r<RA>, r<RC>"
# OBSOLETE 	do_dbsr(_SD, pcdisp, val_Ra);
# OBSOLETE _BRA,10010,10,6.RA,_IMM12:BRA:short:mu:DBSR imm
# OBSOLETE "dbsr r<RA>, <pcdisp>"
# OBSOLETE 	do_dbsr(_SD, pcdisp, val_Ra);
# OBSOLETE _BRA,10010,10,6.RA,6.**,_IMM32:BRA:long:mu:DBSR imm long
# OBSOLETE "dbsr r<RA>, <pcdisp>"
# OBSOLETE 	do_dbsr(_SD, pcdisp, val_Ra);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // DBSRI
# OBSOLETE 
# OBSOLETE void::function::do_dbsri:address_word pcdisp, unsigned32 imm
# OBSOLETE 	PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, cia + pcdisp);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, cia + (imm << 3));
# OBSOLETE 	WRITE32_QUEUE (&GPR[62], cia + (imm << 3) + 8);
# OBSOLETE 
# OBSOLETE _BRA,10110,00,6.IMM_6,6.**,6.RC:BRA:short:mu:DBSRI
# OBSOLETE "dbsri <IMM_6>, r<RC>"
# OBSOLETE 	do_dbsri(_SD, pcdisp, IMM_6);
# OBSOLETE _BRA,10110,10,6.IMM_6,_IMM12:BRA:short:mu:DBSRI imm
# OBSOLETE "dbsri <IMM_6>, <pcdisp>"
# OBSOLETE 	do_dbsri(_SD, pcdisp, IMM_6);
# OBSOLETE _BRA,10110,10,6.IMM_6,6.**,_IMM32:BRA:long:mu:DBSRI imm long
# OBSOLETE "dbsri <IMM_6>, <pcdisp>"
# OBSOLETE 	do_dbsri(_SD, pcdisp, IMM_6);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // DBT
# OBSOLETE 
# OBSOLETE 
# OBSOLETE _BRA,01011,00,6.**,6.**,6.**:BRA:short:mu:DBT
# OBSOLETE "dbt"
# OBSOLETE 	if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	  {
# OBSOLETE 	    WRITE32_QUEUE (&DPC, RPT_S);
# OBSOLETE 	    if (RPT_C == 0)
# OBSOLETE 	      PSW_SET (PSW_RP, 0);
# OBSOLETE 	  }
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE (&DPC, cia + 8);
# OBSOLETE 	DID_TRAP = 2;
# OBSOLETE 	nia = 0xfffff120; /* debug_trap_address */
# OBSOLETE 
# OBSOLETE // DJMP
# OBSOLETE 
# OBSOLETE void::function::do_djmp:address_word pcdisp, unsigned32 ra
# OBSOLETE 	PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, pcdisp);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, cia + (ra & ~0x7));
# OBSOLETE 
# OBSOLETE _BRA,10001,00,6.RA,6.**,6.RC:BRA:short:mu:DJMP
# OBSOLETE "djmp r<RA>, r<RC>"
# OBSOLETE 	do_djmp(_SD, pcdisp, val_Ra);
# OBSOLETE _BRA,10001,10,6.RA,_IMM12:BRA:short:mu:DJMP imm
# OBSOLETE "djmp r<RA>, <pcdisp>"
# OBSOLETE 	do_djmp(_SD, pcdisp, val_Ra);
# OBSOLETE _BRA,10001,10,6.RA,6.**,_IMM32:BRA:long:mu:DJMP imm long
# OBSOLETE "djmp r<RA>, <pcdisp>"
# OBSOLETE 	do_djmp(_SD, pcdisp, val_Ra);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // DJMPI
# OBSOLETE 
# OBSOLETE void::function::do_djmpi:address_word pcdisp, unsigned32 imm
# OBSOLETE 	PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, pcdisp);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, cia + (imm << 3));
# OBSOLETE 
# OBSOLETE _BRA,10101,00,6.IMM_6,6.**,6.RC:BRA:short:mu:DJMPI
# OBSOLETE "djmpi <IMM_6>, r<RC>"
# OBSOLETE 	do_djmpi(_SD, pcdisp, IMM_6);
# OBSOLETE _BRA,10101,10,6.IMM_6,_IMM12:BRA:short:mu:DJMPI imm
# OBSOLETE "djmpi <IMM_6>, <pcdisp>"
# OBSOLETE 	do_djmpi(_SD, pcdisp, IMM_6);
# OBSOLETE _BRA,10101,10,6.IMM_6,6.**,_IMM32:BRA:long:mu:DJMPI imm long
# OBSOLETE "djmpi <IMM_6>, <pcdisp>"
# OBSOLETE 	do_djmpi(_SD, pcdisp, IMM_6);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // DJSR
# OBSOLETE 
# OBSOLETE void::function::do_djsr:address_word pcdisp, unsigned32 ra
# OBSOLETE 	PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, pcdisp);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, cia + (ra & ~0x7));
# OBSOLETE 	WRITE32_QUEUE (&GPR[62], cia + (ra & ~0x7) + 8);
# OBSOLETE 
# OBSOLETE _BRA,10011,00,6.RA,6.**,6.RC:BRA:short:mu:DJSR
# OBSOLETE "djsr r<RA>, r<RC>"
# OBSOLETE 	do_djsr(_SD, pcdisp, val_Ra);
# OBSOLETE _BRA,10011,10,6.RA,_IMM12:BRA:short:mu:DJSR imm
# OBSOLETE "djsr r<RA>, <pcdisp>"
# OBSOLETE 	do_djsr(_SD, pcdisp, val_Ra);
# OBSOLETE _BRA,10011,10,6.RA,6.**,_IMM32:BRA:long:mu:DJSR imm long
# OBSOLETE "djsr r<RA>, <pcdisp>"
# OBSOLETE 	do_djsr(_SD, pcdisp, val_Ra);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // DJSRI
# OBSOLETE 
# OBSOLETE void::function::do_djsri:address_word pcdisp, unsigned32 imm
# OBSOLETE 	PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, pcdisp);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, cia + (imm << 3));
# OBSOLETE 	WRITE32_QUEUE (&GPR[62], cia + (imm << 3) + 8);
# OBSOLETE 
# OBSOLETE _BRA,10111,00,6.IMM_6,6.**,6.RC:BRA:short:mu:DJSRI
# OBSOLETE "djsri <IMM_6>, r<RC>"
# OBSOLETE 	do_djsri(_SD, pcdisp, IMM_6);
# OBSOLETE _BRA,10111,10,6.IMM_6,_IMM12:BRA:short:mu:DJSRI imm
# OBSOLETE "djsri <IMM_6>, <pcdisp>"
# OBSOLETE 	do_djsri(_SD, pcdisp, IMM_6);
# OBSOLETE _BRA,10111,10,6.IMM_6,6.**,_IMM32:BRA:long:mu:DJSRI imm long
# OBSOLETE "djsri <IMM_6>, <pcdisp>"
# OBSOLETE 	do_djsri(_SD, pcdisp, IMM_6);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // JMP
# OBSOLETE 
# OBSOLETE _BRA,00001,00,6.**,6.**,6.RC:BRA:short:mu:JMP
# OBSOLETE "jmp r<RC>"
# OBSOLETE 	nia = pcaddr;
# OBSOLETE 	if (RC == 62 && TRACE_CALL_P)
# OBSOLETE 	  TRACE_ACTION |= TRACE_ACTION_RETURN;
# OBSOLETE _BRA,00001,10,_IMM18:BRA:short:mu:JMP imm
# OBSOLETE "jmp <pcdisp>"
# OBSOLETE 	nia = pcaddr;
# OBSOLETE _BRA,00001,10,6.**,6.**,_IMM32:BRA:long:mu:JMP imm long
# OBSOLETE "jmp <pcdisp>"
# OBSOLETE 	nia = pcaddr;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // JMPTNZ
# OBSOLETE 
# OBSOLETE _BRA,00101,01,6.RA,6.**,6.RC:BRA:short:mu:JMPTNZ
# OBSOLETE "jmptnz r<RC>"
# OBSOLETE 	if (val_Ra != 0)
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE _BRA,00101,11,6.RA,_IMM12:BRA:short:mu:JMPTNZ imm
# OBSOLETE "jmptnz <pcdisp>"
# OBSOLETE 	if (val_Ra != 0)
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE _BRA,00101,11,6.RA,6.**,_IMM32:BRA:long:mu:JMPTNZ imm long
# OBSOLETE "jmptnz <pcdisp>"
# OBSOLETE 	if (val_Ra != 0)
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // JMPTZR
# OBSOLETE 
# OBSOLETE _BRA,00101,00,6.RA,6.**,6.RC:BRA:short:mu:JMPTZR
# OBSOLETE "jmptzr r<RC>"
# OBSOLETE 	if (val_Ra == 0)
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE _BRA,00101,10,6.RA,_IMM12:BRA:short:mu:JMPTZR imm
# OBSOLETE "jmptzr <pcdisp>"
# OBSOLETE 	if (val_Ra == 0)
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE _BRA,00101,10,6.RA,6.**,_IMM32:BRA:long:mu:JMPTZR imm long
# OBSOLETE "jmptzr <pcdisp>"
# OBSOLETE 	if (val_Ra == 0)
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // JOINpp 
# OBSOLETE 
# OBSOLETE void::function::do_join_pp:int pp, unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	switch (pp) {
# OBSOLETE 	case 0x0: /* LL */
# OBSOLETE 	  WRITE32_QUEUE (ra, ((unsigned32)VL2_4(rb) << 16) | VL2_4(src));
# OBSOLETE 	  break;
# OBSOLETE 	case 0x1: /* LH */
# OBSOLETE 	  WRITE32_QUEUE (ra, ((unsigned32)VL2_4(rb) << 16) | VH2_4(src));
# OBSOLETE 	  break;
# OBSOLETE 	case 0x2: /* HL */
# OBSOLETE 	  WRITE32_QUEUE (ra, ((unsigned32)VH2_4(rb) << 16) | VL2_4(src));
# OBSOLETE 	  break;
# OBSOLETE 	case 0x3: /* HH */
# OBSOLETE 	  WRITE32_QUEUE (ra, ((unsigned32)VH2_4(rb) << 16) | VH2_4(src));
# OBSOLETE 	  break;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE ::%s::pp:int pp
# OBSOLETE 	switch (pp)
# OBSOLETE 	  {
# OBSOLETE 	  case 0x0: return "ll";
# OBSOLETE 	  case 0x1: return "lh";
# OBSOLETE 	  case 0x2: return "hl";
# OBSOLETE 	  case 0x3: return "hh";
# OBSOLETE 	  default: return "?";
# OBSOLETE 	  }
# OBSOLETE 
# OBSOLETE _IALU1,011,pp,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:JOINpp
# OBSOLETE "join%s<pp> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_join_pp(_SD, pp, Ra, Rb, Rc);
# OBSOLETE _IALU1,011,pp,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:JOINpp imm
# OBSOLETE "join%s<pp> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_join_pp(_SD, pp, Ra, Rb, immHL);
# OBSOLETE _IALU1,011,pp,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:JOINpp imm long
# OBSOLETE "join%s<pp> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_join_pp(_SD, pp, Ra, Rb, immHL);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // JSR
# OBSOLETE 
# OBSOLETE _BRA,00011,00,6.**,6.**,6.RC:BRA:short:mu:JSR
# OBSOLETE "jsr r<RC>"
# OBSOLETE 	if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	if (TRACE_CALL_P)
# OBSOLETE 	  TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	return pcaddr;
# OBSOLETE _BRA,00011,10,_IMM18:BRA:short:mu:JSR imm
# OBSOLETE "jsr <pcdisp>"
# OBSOLETE 	if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	if (TRACE_CALL_P)
# OBSOLETE 	  TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	return pcaddr;
# OBSOLETE _BRA,00011,10,6.**,6.**,_IMM32:BRA:long:mu:JSR imm long
# OBSOLETE "jsr <pcdisp>"
# OBSOLETE 	if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	if (TRACE_CALL_P)
# OBSOLETE 	  TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	return pcaddr;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // JSRTNZ
# OBSOLETE 
# OBSOLETE _BRA,00111,01,6.RA,6.**,6.RC:BRA:short:mu:JSRTNZ
# OBSOLETE "jsrtnz r<RC>"
# OBSOLETE 	if (val_Ra != 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE _BRA,00111,11,6.RA,_IMM12:BRA:short:mu:JSRTNZ imm
# OBSOLETE "jsrtnz <pcdisp>"
# OBSOLETE 	if (val_Ra != 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE _BRA,00111,11,6.RA,6.**,_IMM32:BRA:long:mu:JSRTNZ imm long
# OBSOLETE "jsrtnz <pcdisp>"
# OBSOLETE 	if (val_Ra != 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // JSRTZR
# OBSOLETE 
# OBSOLETE _BRA,00111,00,6.RA,6.**,6.RC:BRA:short:mu:JSRTZR
# OBSOLETE "jsrtzr r<RC>"
# OBSOLETE 	if (val_Ra == 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE _BRA,00111,10,6.RA,_IMM12:BRA:short:mu:JSRTZR imm
# OBSOLETE "jsrtzr <pcdisp>"
# OBSOLETE 	if (val_Ra == 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE _BRA,00111,10,6.RA,6.**,_IMM32:BRA:long:mu:JSRTZR imm long
# OBSOLETE "jsrtzr <pcdisp>"
# OBSOLETE 	if (val_Ra == 0) {
# OBSOLETE 	  if (cia == RPT_E && PSW_VAL (PSW_RP))
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], RPT_S);
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (&GPR[62], cia + 8);
# OBSOLETE 	  nia = pcaddr;
# OBSOLETE 	  if (TRACE_CALL_P)
# OBSOLETE 	    TRACE_ACTION |= TRACE_ACTION_CALL;
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // Post increment
# OBSOLETE 
# OBSOLETE void::function::do_incr:int x, unsigned32 *rb, int delta
# OBSOLETE 	unsigned32 next_rb;
# OBSOLETE 	if (x == 1)
# OBSOLETE 	  next_rb = *rb + delta;
# OBSOLETE 	else if (x == 3)
# OBSOLETE 	  next_rb = *rb - delta;
# OBSOLETE 	else
# OBSOLETE 	  next_rb = *rb; /* value not used */
# OBSOLETE 	/* HW erratum: check value after incrementing */
# OBSOLETE 	if (next_rb == MOD_E
# OBSOLETE 	    && (x == 1 || x == 3)
# OBSOLETE 	    && (PSW_VAL(PSW_MD))) {
# OBSOLETE 	  WRITE32_QUEUE (rb, MOD_S);
# OBSOLETE 	}
# OBSOLETE 	else if (x == 1 || x == 3)
# OBSOLETE 	  WRITE32_QUEUE (rb, next_rb);
# OBSOLETE 
# OBSOLETE // LD2H
# OBSOLETE 
# OBSOLETE int::function::make_even_reg:int reg, const char *name
# OBSOLETE 	if (reg & 1)
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia,
# OBSOLETE 			    "0x%lx:%s odd register (r%d) used in multi-word load/mulx2h",
# OBSOLETE 			    (long) cia, name, reg);
# OBSOLETE 	return reg;
# OBSOLETE 
# OBSOLETE void::function::do_ld2h:int ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	signed32 mem;
# OBSOLETE 	ra = make_even_reg(_SD, ra, "LD2H");
# OBSOLETE 	mem = MEM(signed, rb + src, 4);
# OBSOLETE 	if (ra != 0)
# OBSOLETE 	{
# OBSOLETE 	  WRITE32_QUEUE (&GPR[ra + 0], SEXT32(EXTRACTED32(mem, 0, 15), 16));
# OBSOLETE 	  WRITE32_QUEUE (&GPR[ra + 1], SEXT32(EXTRACTED32(mem, 16, 31), 16));
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE ::%s::XX:int XX
# OBSOLETE 	switch (XX)
# OBSOLETE 	  {
# OBSOLETE 	  case 0: return "";
# OBSOLETE 	  case 1: return "+";
# OBSOLETE 	  case 3: return "-";
# OBSOLETE 	  default: return "?";
# OBSOLETE 	  }
# OBSOLETE 
# OBSOLETE _IMEM,00011,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LD2H
# OBSOLETE "ld2h r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ld2h r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ld2h(_SD, RA, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 4);
# OBSOLETE _IMEM,00011,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LD2H long
# OBSOLETE "ld2h r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_ld2h(_SD, RA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LD2W
# OBSOLETE 
# OBSOLETE void::function::do_ld2w:int ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	unsigned64 mem;
# OBSOLETE 	ra = make_even_reg(_SD, ra, "LD2W");
# OBSOLETE 	mem = MEM(unsigned, rb + src, 8);
# OBSOLETE 	if (ra != 0)
# OBSOLETE 	{
# OBSOLETE 	  WRITE32_QUEUE (&GPR[ra + 0], EXTRACTED64 (mem, 0, 31));
# OBSOLETE 	  WRITE32_QUEUE (&GPR[ra + 1], EXTRACTED64 (mem, 32, 63));
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _IMEM,00110,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:L2W
# OBSOLETE "ld2w r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ld2w r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ld2w(_SD, RA, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 8);
# OBSOLETE _IMEM,00110,10,6.RA,6.RB,_IMM32:IMEM:long:mu:L2W long
# OBSOLETE "ld2w r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_ld2w(_SD, RA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LD4BH
# OBSOLETE 
# OBSOLETE void::function::do_ld4bh:unsigned32 ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	unsigned16 l1, l2, h1, h2;
# OBSOLETE 	unsigned32 mem;
# OBSOLETE 	ra = make_even_reg(_SD, ra, "LD4BH");
# OBSOLETE 	mem = MEM(unsigned, rb + src, 4);
# OBSOLETE 	h1 = SEXT16(EXTRACTED32(mem, 0, 7), 8);
# OBSOLETE 	l1 = SEXT16(EXTRACTED32(mem, 8, 15), 8);
# OBSOLETE 	h2 = SEXT16(EXTRACTED32(mem, 16, 23), 8);
# OBSOLETE 	l2 = SEXT16(EXTRACTED32(mem, 24, 31), 8);
# OBSOLETE 	if (ra != 0)
# OBSOLETE 	{
# OBSOLETE 	  WRITE32_QUEUE (&GPR[ra + 0], (h1 << 16) | l1);
# OBSOLETE 	  WRITE32_QUEUE (&GPR[ra + 1], (h2 << 16) | l2);
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _IMEM,00101,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LD4BH
# OBSOLETE "ld4bh r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ld4bh r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ld4bh(_SD, RA, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 4);
# OBSOLETE _IMEM,00101,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LD4BH long
# OBSOLETE "ld4bh r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_ld4bh(_SD, RA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LD4BHU
# OBSOLETE 
# OBSOLETE void::function::do_ld4bhu:unsigned32 ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	unsigned16 l1, l2, h1, h2;
# OBSOLETE 	unsigned32 mem;
# OBSOLETE 	ra = make_even_reg(_SD, ra, "LD4BH");
# OBSOLETE 	mem = MEM(signed, rb + src, 4);
# OBSOLETE 	h1 = EXTRACTED32(mem, 0, 7);
# OBSOLETE 	l1 = EXTRACTED32(mem, 8, 15);
# OBSOLETE 	h2 = EXTRACTED32(mem, 16, 23);
# OBSOLETE 	l2 = EXTRACTED32(mem, 24, 31);
# OBSOLETE 	if (ra != 0)
# OBSOLETE 	{
# OBSOLETE 	  WRITE32_QUEUE (&GPR[ra + 0], (h1 << 16) | l1);
# OBSOLETE 	  WRITE32_QUEUE (&GPR[ra + 1], (h2 << 16) | l2);
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _IMEM,01101,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LD4BHU
# OBSOLETE "ld4hbu r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ld4hbu r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ld4bhu(_SD, RA, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 4);
# OBSOLETE _IMEM,01101,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LD4BHU long
# OBSOLETE "ld4hbu r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_ld4bhu(_SD, RA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LDB
# OBSOLETE 
# OBSOLETE void::function::do_ldb:unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	WRITE32_QUEUE (ra, MEM(signed, rb + src, 1));
# OBSOLETE 
# OBSOLETE _IMEM,00000,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LDB
# OBSOLETE "ldb r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ldb r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ldb(_SD, Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 1);
# OBSOLETE _IMEM,00000,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LDB long
# OBSOLETE "ldb r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_ldb(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LDBU
# OBSOLETE 
# OBSOLETE void::function::do_ldbu:unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	WRITE32_QUEUE (ra, MEM(unsigned, rb + src, 1));
# OBSOLETE 
# OBSOLETE _IMEM,01001,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LDBU
# OBSOLETE "ldbu r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ldbu r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ldbu(_SD, Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 1);
# OBSOLETE _IMEM,01001,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LDBU long
# OBSOLETE "ldbu r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_ldbu(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LDH
# OBSOLETE 
# OBSOLETE void::function::do_ldh:unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	WRITE32_QUEUE (ra, MEM(signed, rb + src, 2));
# OBSOLETE 
# OBSOLETE _IMEM,00010,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LDH
# OBSOLETE "ldh r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ldh r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ldh(_SD, Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 2);
# OBSOLETE _IMEM,00010,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LDH long
# OBSOLETE "ldh r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_ldh(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LDHH
# OBSOLETE 
# OBSOLETE void::function::do_ldhh:unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	WRITE32_QUEUE (ra, MEM(signed, rb + src, 2) << 16);
# OBSOLETE 
# OBSOLETE _IMEM,00001,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LDHH
# OBSOLETE "ldhh r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ldhh r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ldhh(_SD, Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 2);
# OBSOLETE _IMEM,00001,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LDHH long
# OBSOLETE "ldhh r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_ldhh(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LDHU
# OBSOLETE 
# OBSOLETE void::function::do_ldhu:unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	WRITE32_QUEUE (ra, MEM(unsigned, rb + src, 2));
# OBSOLETE 
# OBSOLETE _IMEM,01010,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LDHU
# OBSOLETE "ldhu r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ldhu r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ldhu(_SD, Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 2);
# OBSOLETE _IMEM,01010,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LDHU long
# OBSOLETE "ldhu r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_ldhu(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // LDW
# OBSOLETE 
# OBSOLETE void::function::do_ldw:unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	WRITE32_QUEUE (ra, MEM(signed, rb + src, 4));
# OBSOLETE 
# OBSOLETE _IMEM,00100,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:LDW
# OBSOLETE "ldw r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "ldw r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_ldw(_SD, Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 4);
# OBSOLETE _IMEM,00100,10,6.RA,6.RB,_IMM32:IMEM:long:mu:LDW long
# OBSOLETE "ldw r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_ldw(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MACa
# OBSOLETE 
# OBSOLETE void::function::do_mac:unsigned64 *aa, unsigned32 *ra, signed32 rb, signed32 src
# OBSOLETE 	unsigned64 accum = *aa;
# OBSOLETE 	accum += (signed64) (rb) * (signed64) (src);
# OBSOLETE 	WRITE64_QUEUE (aa, accum);
# OBSOLETE 	WRITE32_QUEUE (ra, EXTRACTED64(accum, 32, 63));
# OBSOLETE 
# OBSOLETE _IALU2,10100,0,1.AA,6.RA,6.RB,6.RC:IALU2:short:iu:MACa
# OBSOLETE "mac<AA> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_mac(_SD, Aa, Ra, Rb, Rc);	
# OBSOLETE _IALU2,10100,1,1.AA,6.RA,6.RB,_IMM6:IALU2:short:iu:MACa imm
# OBSOLETE "mac<AA> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_mac(_SD, Aa, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MACSa
# OBSOLETE 
# OBSOLETE void::function::do_macs:unsigned64 *aa, unsigned32 *ra, signed32 rb, signed32 src
# OBSOLETE 	unsigned64 accum = *aa;
# OBSOLETE 	accum += ((signed64) (rb) * (signed64) (src)) << 1;
# OBSOLETE 	WRITE64_QUEUE (aa, accum);
# OBSOLETE 	WRITE32_QUEUE (ra, EXTRACTED64(accum, 0, 31));
# OBSOLETE 
# OBSOLETE _IALU2,10101,0,1.AA,6.RA,6.RB,6.RC:IALU2:short:iu:MACSa
# OBSOLETE "macs<AA> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_macs(_SD, Aa, Ra, Rb, Rc);	
# OBSOLETE _IALU2,10101,1,1.AA,6.RA,6.RB,_IMM6:IALU2:short:iu:MACSa imm
# OBSOLETE "macs<AA> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_macs(_SD, Aa, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MODDEC | MODINC
# OBSOLETE 
# OBSOLETE _IMEM,00111,11,6.**,6.RB,_IMM6:IMEM:short:mu:MODDEC
# OBSOLETE "moddec r<RB>, <imm>"
# OBSOLETE 	do_incr(_SD, 3/*0b11*/, &GPR[RB], imm_5);	
# OBSOLETE _IMEM,00111,01,6.**,6.RB,_IMM6:IMEM:short:mu:MODINC
# OBSOLETE "modinc r<RB>, <imm>"
# OBSOLETE 	do_incr(_SD, 1/*0b01*/, &GPR[RB], imm_5);	
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MSUBa
# OBSOLETE 
# OBSOLETE void::function::do_msub:unsigned64 *aa, unsigned32 *ra, signed32 rb, signed32 src
# OBSOLETE 	unsigned64 accum = *aa;
# OBSOLETE 	accum -= (signed64) (rb) * (signed64) (src);
# OBSOLETE 	WRITE64_QUEUE (aa, accum);
# OBSOLETE 	WRITE32_QUEUE (ra, EXTRACTED64(accum, 32, 63));
# OBSOLETE 
# OBSOLETE _IALU2,10110,0,1.AA,6.RA,6.RB,6.RC:IALU2:short:iu:MSUBa
# OBSOLETE "msub<AA> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_msub(_SD, Aa, Ra, Rb, Rc);	
# OBSOLETE _IALU2,10110,1,1.AA,6.RA,6.RB,_IMM6:IALU2:short:iu:MSUBa imm
# OBSOLETE "msub<AA> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_msub(_SD, Aa, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MSUBSa
# OBSOLETE 
# OBSOLETE void::function::do_msubs:unsigned64 *aa, unsigned32 *ra, signed32 rb, signed32 src
# OBSOLETE 	unsigned64 accum = *aa;
# OBSOLETE 	accum -= ((signed64) (rb) * (signed64) (src)) << 1;
# OBSOLETE 	WRITE64_QUEUE (aa, accum);
# OBSOLETE 	WRITE32_QUEUE (ra, EXTRACTED64(accum, 0, 31));
# OBSOLETE 
# OBSOLETE _IALU2,10111,0,1.AA,6.RA,6.RB,6.RC:IALU2:short:iu:MSUBSa
# OBSOLETE "msubs<AA> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_msubs(_SD, Aa, Ra, Rb, Rc);	
# OBSOLETE _IALU2,10111,1,1.AA,6.RA,6.RB,_IMM6:IALU2:short:iu:MSUBSa imm
# OBSOLETE "msubs<AA> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_msubs(_SD, Aa, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MUL
# OBSOLETE 
# OBSOLETE void::function::do_mul:unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	WRITE32_QUEUE (ra, rb * src);
# OBSOLETE 
# OBSOLETE _IALU2,10000,00,6.RA,6.RB,6.RC:IALU2:short:iu:MUL
# OBSOLETE "mul r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_mul(_SD, Ra, Rb, Rc);	
# OBSOLETE _IALU2,10000,10,6.RA,6.RB,_IMM6:IALU2:short:iu:MUL imm
# OBSOLETE "mul r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_mul(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MUL2H
# OBSOLETE 
# OBSOLETE void::function::do_mul2h:unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	unsigned16 high = VH2_4(rb) * VH2_4(src);
# OBSOLETE 	unsigned16 low  = VL2_4(rb) * VL2_4(src);
# OBSOLETE 	WRITE32_QUEUE (ra, (high << 16) | low);
# OBSOLETE 
# OBSOLETE _IALU2,00000,00,6.RA,6.RB,6.RC:IALU2:short:iu:MUL2H
# OBSOLETE "mul2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_mul2h(_SD, Ra, Rb, Rc);	
# OBSOLETE _IALU2,00000,10,6.RA,6.RB,_IMM6:IALU2:short:iu:MUL2H imm
# OBSOLETE "mul2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_mul2h(_SD, Ra, Rb, immHL);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MULX
# OBSOLETE 
# OBSOLETE void::function::do_mulx:unsigned64 *aa, signed32 rb, signed32 src
# OBSOLETE 	WRITE64_QUEUE (aa, (signed64) (rb) * (signed64) (src));
# OBSOLETE 
# OBSOLETE _IALU2,11000,00,5.*,1.AA,6.RB,6.RC:IALU2:short:iu:MULX
# OBSOLETE "mulx a<AA>, r<RB>, r<RC>"
# OBSOLETE 	do_mulx(_SD, Aa, Rb, Rc);	
# OBSOLETE _IALU2,11000,10,5.*,1.AA,6.RB,_IMM6:IALU2:short:iu:MULX imm
# OBSOLETE "mulx a<AA>, r<RB>, <imm>"
# OBSOLETE 	do_mulx(_SD, Aa, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MULX2H
# OBSOLETE 
# OBSOLETE void::function::do_mulx2h:int ra, signed32 rb, signed32 src, int high
# OBSOLETE 	signed32 result = rb * src;
# OBSOLETE 	if (!high)
# OBSOLETE 	  {
# OBSOLETE 	    ra = make_even_reg(_SD, ra, "MULX2H");
# OBSOLETE 	    if (ra != 0)
# OBSOLETE 	      WRITE32_QUEUE (&GPR[ra+1], result);
# OBSOLETE 	  }
# OBSOLETE 	else if (ra != 0)
# OBSOLETE 	  {
# OBSOLETE 	      WRITE32_QUEUE (&GPR[ra+0], result);
# OBSOLETE 	  }
# OBSOLETE 
# OBSOLETE _IALU2,00001,00,6.RA,6.RB,6.RC:IALU2:short:iu:MULX2H
# OBSOLETE "mul2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_mulx2h(_SD, RA, RbH, RcH, 1);
# OBSOLETE 	do_mulx2h(_SD, RA, RbL, RcL, 0);
# OBSOLETE _IALU2,00001,10,6.RA,6.RB,_IMM6:IALU2:short:iu:MULX2H imm
# OBSOLETE "mul2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_mulx2h(_SD, RA, RbH, imm, 1);
# OBSOLETE 	do_mulx2h(_SD, RA, RbL, imm, 0);
# OBSOLETE 
# OBSOLETE // MULHXpp
# OBSOLETE 
# OBSOLETE void::function::do_mulhx:int pp, unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	signed32 value = 0;
# OBSOLETE 	switch (pp) {
# OBSOLETE 	case 0: /* LL */
# OBSOLETE 	  value = SEXT32(VL2_4(rb), 16) * SEXT32(VL2_4(src), 16);
# OBSOLETE 	  break;
# OBSOLETE 	case 1: /* LH */
# OBSOLETE 	  value = SEXT32(VL2_4(rb), 16) * SEXT32(VH2_4(src), 16);
# OBSOLETE 	  break;
# OBSOLETE 	case 2: /* HL */
# OBSOLETE 	  value = SEXT32(VH2_4(rb), 16) * SEXT32(VL2_4(src), 16);
# OBSOLETE 	  break;
# OBSOLETE 	case 3: /* HH */
# OBSOLETE 	  value = SEXT32(VH2_4(rb), 16) * SEXT32(VH2_4(src), 16);
# OBSOLETE 	  break;
# OBSOLETE 	default:
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "do_mulhx - internal error - bad switch");
# OBSOLETE 	}
# OBSOLETE 	WRITE32_QUEUE (ra, value);
# OBSOLETE 
# OBSOLETE _IALU2,001,pp,00,6.RA,6.RB,6.RC:IALU2:short:iu:MULHXpp
# OBSOLETE "mulhx%s<pp> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_mulhx(_SD, pp, Ra, Rb, Rc);	
# OBSOLETE _IALU2,001,pp,10,6.RA,6.RB,_IMM6:IALU2:short:iu:MULHXpp imm
# OBSOLETE "mulhx%s<pp> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_mulhx(_SD, pp, Ra, Rb, immHL);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MULXS
# OBSOLETE 
# OBSOLETE void::function::do_mulxs:unsigned64 *aa, signed32 rb, signed32 src
# OBSOLETE 	WRITE64_QUEUE (aa, ((signed64) (rb) * (signed64) (src)) << 1);
# OBSOLETE 
# OBSOLETE _IALU2,11001,00,5.*,1.AA,6.RB,6.RC:IALU2:short:iu:MULXS
# OBSOLETE "mulxs a<AA>, r<RB>, r<RC>"
# OBSOLETE 	do_mulxs(_SD, Aa, Rb, Rc);	
# OBSOLETE _IALU2,11001,10,5.*,1.AA,6.RB,_IMM6:IALU2:short:iu:MULXS imm
# OBSOLETE "mulxs a<AA>, r<RB>, <imm>"
# OBSOLETE 	do_mulxs(_SD, Aa, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MVFACC
# OBSOLETE 
# OBSOLETE void::function::do_mvfacc:unsigned32 *ra, unsigned64 ab, unsigned32 src
# OBSOLETE 	while (src > 63) src -= 64;
# OBSOLETE 	WRITE32_QUEUE (ra, ((signed64)ab) >> src);
# OBSOLETE 
# OBSOLETE _IALU2,11111,00,6.RA,5.*,1.AB,6.RC:IALU2:short:iu:MVFACC
# OBSOLETE "mvfacc r<RA>, a<AB>, r<RC>"
# OBSOLETE 	do_mvfacc(_SD, Ra, *Ab, Rc);	
# OBSOLETE _IALU2,11111,10,6.RA,5.*,1.AB,_IMM6:IALU2:short:iu:MVFACC imm
# OBSOLETE "mvfacc r<RA>, a<AB>, <imm>"
# OBSOLETE 	do_mvfacc(_SD, Ra, *Ab, imm_6u);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MVFSYS
# OBSOLETE 
# OBSOLETE _BRA,11110,00,6.RA,6.CR,6.ID:BRA:short:mu:MVFSYS
# OBSOLETE "mvfsys r<RA>, cr<CR>"
# OBSOLETE 	switch (ID) {
# OBSOLETE 	case 0:
# OBSOLETE 	  if (CR >= NR_CONTROL_REGISTERS)
# OBSOLETE 	    sim_engine_abort (SD, CPU, cia, "FIXME - illegal CR");
# OBSOLETE 	  else
# OBSOLETE 	    WRITE32_QUEUE (Ra, (CPU)->regs.control[CR]);
# OBSOLETE 	  break;
# OBSOLETE 	case 1:
# OBSOLETE 	  WRITE32_QUEUE (Ra, PSWL);
# OBSOLETE 	  break;
# OBSOLETE 	case 2:
# OBSOLETE 	  WRITE32_QUEUE (Ra, EXTRACTED32(PSWH, 16, 31));
# OBSOLETE 	  break;
# OBSOLETE 	case 3:
# OBSOLETE 	  WRITE32_QUEUE (Ra, PSW_FLAG_VAL(CR));
# OBSOLETE 	  break;
# OBSOLETE 	default:
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "FIXME - illegal ID");
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MVTACC
# OBSOLETE 
# OBSOLETE _IALU2,01111,00,5.*,1.AA,6.RB,6.RC:IALU2:short:iu:MVTACC
# OBSOLETE "mvtacc a<AA>, r<RB>, r<RC>"
# OBSOLETE 	WRITE64_QUEUE (Aa, INSERTED64(RbU, 0, 31) | (RcU));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // MVTSYS
# OBSOLETE 
# OBSOLETE _BRA,01110,00,6.CR,6.RB,6.ID:BRA:short:mu:MVTSYS
# OBSOLETE "mvtsys cr<CR>, r<RB>"
# OBSOLETE 	switch (ID) {
# OBSOLETE 	case 0:			/* control register */
# OBSOLETE 	  if (CR >= NR_CONTROL_REGISTERS)
# OBSOLETE 	    sim_engine_abort (SD, CPU, cia, "FIXME - illegal CR");
# OBSOLETE 	  else
# OBSOLETE 	    {
# OBSOLETE 	      unsigned32 value = Rb;
# OBSOLETE 	      CPU->mvtsys_left_p = 1;
# OBSOLETE 	      if (CR == processor_status_word_cr)
# OBSOLETE 		{
# OBSOLETE 		  unsigned32 ds = PSW & BIT32 (PSW_DS);	/* preserve ds */
# OBSOLETE 		  value = ds | (value & PSW_VALID);
# OBSOLETE 		}
# OBSOLETE 	      else if (CR == backup_processor_status_word_cr
# OBSOLETE 		       || CR == debug_backup_processor_status_word_cr)
# OBSOLETE 		value &= DPSW_VALID;
# OBSOLETE 	      else if (CR == eit_vector_base_cr)
# OBSOLETE 		value &= EIT_VALID;
# OBSOLETE 	      WRITE32_QUEUE (&(CPU)->regs.control[CR], value);
# OBSOLETE 	    }
# OBSOLETE 	  break;
# OBSOLETE 	case 1:			/* PSWL */
# OBSOLETE 	  WRITE32_QUEUE_MASK (&PSW, EXTRACTED32(Rb, 16, 31),
# OBSOLETE 			      PSW_VALID & 0x0000ffff);
# OBSOLETE 	  break;
# OBSOLETE 	case 2:			/* PSWH */
# OBSOLETE 	  {
# OBSOLETE 	    unsigned32 ds = PSW & BIT32 (PSW_DS);	/* preserve ds */
# OBSOLETE 	    WRITE32_QUEUE_MASK (&PSW, (EXTRACTED32(Rb, 16, 31) << 16) | ds,
# OBSOLETE 				(PSW_VALID | ds) & 0xffff0000);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 3:			/* FLAG */
# OBSOLETE 	  PSW_FLAG_SET_QUEUE(CR, Rb & 1);
# OBSOLETE 	  break;
# OBSOLETE 	default:
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "FIXME - illegal ID");
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // NOP
# OBSOLETE 
# OBSOLETE _BRA,01111,00,6.**,6.**,6.**:BRA:short:iu,mu:NOP
# OBSOLETE "nop"
# OBSOLETE 	/* NOP */;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // NOT
# OBSOLETE 
# OBSOLETE _LOGIC,11001,00,6.RA,6.RB,6.*:LOGIC:short:iu,mu:NOT
# OBSOLETE "not r<RA>, r<RB>"
# OBSOLETE 	WRITE32_QUEUE (Ra, ~Rb);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // NOTFG
# OBSOLETE 
# OBSOLETE _LOGIC,01001,00,***,3.FA,***,3.FB,***,3.FC:LOGIC:short:iu,mu:NOTFG
# OBSOLETE "notfg f<FA>, f<FB>"
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, !PSW_FLAG_VAL(FB));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // OR
# OBSOLETE 
# OBSOLETE _LOGIC,11010,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:OR
# OBSOLETE "or r<RA>, r<RB>, r<RC>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb | Rc);
# OBSOLETE _LOGIC,11010,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:OR imm
# OBSOLETE "or r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb | imm);
# OBSOLETE _LOGIC,11010,10,6.RA,6.RB,_IMM32:LOGIC:long:iu,mu:OR imm long
# OBSOLETE "or r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb | imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ORFG
# OBSOLETE 
# OBSOLETE _LOGIC,01010,00,***,3.FA,***,3.FB,***,3.FC:LOGIC:short:iu,mu:ORFG
# OBSOLETE "orfg f<FA>, f<FB>, f<FC>"
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, PSW_FLAG_VAL(FB) | PSW_FLAG_VAL(FC));
# OBSOLETE _LOGIC,01010,10,***,3.FA,***,3.FB,_IMM6:LOGIC:short:iu,mu:ORFG imm
# OBSOLETE "orfg f<FA>, f<FB>, <imm>"
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, PSW_FLAG_VAL(FB) | (imm_6 & 1));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // REIT
# OBSOLETE 
# OBSOLETE _BRA,01000,00,6.**,6.**,6.**:BRA:short:mu:REIT
# OBSOLETE "reit"
# OBSOLETE 	WRITE32_QUEUE (&PSW, bPSW);
# OBSOLETE 	nia = bPC;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // REPEAT
# OBSOLETE 
# OBSOLETE void::function::do_repeat:unsigned32 count, address_word pcaddr
# OBSOLETE 	address_word rpt_s = cia + 8;
# OBSOLETE 	address_word rpt_e = cia + pcaddr;
# OBSOLETE 
# OBSOLETE 	if (count == 0)
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "REPEAT with ra=0 and REPEATI with imm = 0 is forbidden.");
# OBSOLETE 	if (count > 1)
# OBSOLETE 	  PSW_SET_QUEUE (PSW_RP, 1);
# OBSOLETE 	if (rpt_e  < rpt_s + 0x10)
# OBSOLETE 	  sim_io_eprintf (sd, "warning: 0x%lx: REPEAT or REPEATI loop is too small\n", (long) cia);
# OBSOLETE 	WRITE32_QUEUE (&RPT_C, count - 1);
# OBSOLETE 	WRITE32_QUEUE (&RPT_S, rpt_s);
# OBSOLETE 	WRITE32_QUEUE (&RPT_E, rpt_e);
# OBSOLETE 
# OBSOLETE _BRA,11000,00,6.RA,6.**,6.RC:BRA:short:mu:REPEAT
# OBSOLETE "repeat r<RA>, r<RC>"
# OBSOLETE 	do_repeat(_SD, val_Ra, pcaddr);
# OBSOLETE _BRA,11000,10,6.RA,_IMM12:BRA:short:mu:REPEAT imm
# OBSOLETE "repeat r<RA>, <pcaddr>"
# OBSOLETE 	do_repeat(_SD, val_Ra, pcaddr);
# OBSOLETE _BRA,11000,10,6.RA,6.**,_IMM32:BRA:long:mu:REPEAT imm long
# OBSOLETE "repeat r<RA>, <pcaddr>"
# OBSOLETE 	do_repeat(_SD, val_Ra, pcaddr);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // REPEATI
# OBSOLETE 
# OBSOLETE _BRA,11010,00,6.IMM_6,6.**,6.RC:BRA:short:mu:REPEATI
# OBSOLETE "repeati <IMM_6>, r<RC>"
# OBSOLETE 	do_repeat(_SD, IMM_6, pcaddr);
# OBSOLETE _BRA,11010,10,6.IMM_6,_IMM12:BRA:short:mu:REPEATI imm
# OBSOLETE "repeati <IMM_6>, <pcaddr>"
# OBSOLETE 	do_repeat(_SD, IMM_6, pcaddr);
# OBSOLETE _BRA,11010,10,6.IMM_6,6.**,_IMM32:BRA:long:mu:REPEATI imm long
# OBSOLETE "repeati <IMM_6>, <pcaddr>"
# OBSOLETE 	do_repeat(_SD, IMM_6, pcaddr);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // RTD
# OBSOLETE 
# OBSOLETE _BRA,01010,00,6.*,6.*,6.*:BRA:short:mu:RTD
# OBSOLETE "rtd"
# OBSOLETE 	WRITE32_QUEUE (&PSW, DPSW);
# OBSOLETE 	nia = DPC;
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ROT
# OBSOLETE 
# OBSOLETE _LOGIC,10100,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:ROT
# OBSOLETE "rot r<RA>, r<RB>, r<RC>"
# OBSOLETE 	WRITE32_QUEUE (Ra, ROT32(Rb, Rc & 0x1f));
# OBSOLETE _LOGIC,10100,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:ROT imm
# OBSOLETE "rot r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, ROT32(Rb, imm & 0x1f));
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ROT2H
# OBSOLETE 
# OBSOLETE void::function::do_rot2h:unsigned32 *ra, unsigned32 rb, signed32 src
# OBSOLETE 	unsigned16 high = ROTR16(VH2_4(rb), VH2_4(src) & 0xf);
# OBSOLETE 	unsigned16 low  = ROTR16(VL2_4(rb), VL2_4(src) & 0xf);
# OBSOLETE 	WRITE32_QUEUE (ra, (high << 16) | low);
# OBSOLETE 
# OBSOLETE _LOGIC,10101,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:ROT2H
# OBSOLETE "rot2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_rot2h(_SD, Ra, Rb, Rc);
# OBSOLETE _LOGIC,10101,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:ROT2H imm
# OBSOLETE "rot2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_rot2h(_SD, Ra, Rb, immHL);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SAT
# OBSOLETE 
# OBSOLETE void::function::do_sat:signed32 *ra, signed32 rb, signed32 src
# OBSOLETE 	int bits = LSMASKED32(src, 4, 0); /* 5 */
# OBSOLETE 	signed32 sat = LSMASK32(bits, 0) >> 2;
# OBSOLETE 	signed32 nsat = ~sat;
# OBSOLETE 	signed32 value;
# OBSOLETE 	if (bits != src)
# OBSOLETE 	  sim_io_eprintf (sd, "warning: 0x%lx:SAT bit overflow\n", (long) cia);
# OBSOLETE 	if (bits == 0)
# OBSOLETE 	  value = rb;
# OBSOLETE 	else if (rb >= sat)
# OBSOLETE 	  value = sat;
# OBSOLETE 	else if (rb <= nsat)
# OBSOLETE 	  value = nsat;
# OBSOLETE 	else
# OBSOLETE 	  value = rb;
# OBSOLETE 	WRITE32_QUEUE (ra, value);
# OBSOLETE 
# OBSOLETE _IALU2,01000,00,6.RA,6.RB,6.RC:IALU2:short:iu:SAT
# OBSOLETE "sat r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_sat(_SD, Ra, Rb, Rc);
# OBSOLETE _IALU2,01000,10,6.RA,6.RB,_IMM6:IALU2:short:iu:SAT imm
# OBSOLETE "sat r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_sat(_SD, Ra, Rb, imm_5);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SAT2H
# OBSOLETE 
# OBSOLETE void::function::do_sath:signed32 *ra, signed32 rb, signed32 src, int high, int updates_f4
# OBSOLETE 	int bits = LSMASKED32(src, 4, 0); /* 5 */
# OBSOLETE 	signed32 sat = LSMASK32(bits, 0) >> 2;
# OBSOLETE 	signed32 nsat = ~sat;
# OBSOLETE 	signed32 value;
# OBSOLETE 	if (bits != src)
# OBSOLETE 	  sim_io_eprintf (sd, "warning: 0x%lx:SAT bit overflow\n", (long) cia);
# OBSOLETE 	if (bits == 0)
# OBSOLETE 	  value = rb;
# OBSOLETE 	else if (rb >= sat)
# OBSOLETE 	  value = sat;
# OBSOLETE 	else if (rb <= nsat)
# OBSOLETE 	  value = nsat;
# OBSOLETE 	else
# OBSOLETE 	  value = rb;
# OBSOLETE 	if (high)
# OBSOLETE 	  WRITE32_QUEUE_MASK (ra, value << 16, 0xffff0000);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE_MASK (ra, value, 0x0000ffff);
# OBSOLETE 	if (updates_f4)
# OBSOLETE 	  {
# OBSOLETE 	    /* if MU instruction was a MVTSYS (lkr), unqueue register writes now */
# OBSOLETE 	    if(STATE_CPU (sd, 0)->mvtsys_left_p)
# OBSOLETE 	      unqueue_writes (sd, STATE_CPU (sd, 0), cia);
# OBSOLETE 	    PSW_FLAG_SET_QUEUE(PSW_S_FLAG, PSW_FLAG_VAL(PSW_S_FLAG) ^ (value & 1));
# OBSOLETE 	  }
# OBSOLETE 
# OBSOLETE _IALU2,01001,00,6.RA,6.RB,6.RC:IALU2:short:iu:SAT2H
# OBSOLETE "sat2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_sath(_SD, Ra, RbH, RcH, 1, 0);
# OBSOLETE 	do_sath(_SD, Ra, RbL, RcL, 0, 0);
# OBSOLETE _IALU2,01001,10,6.RA,6.RB,_IMM6:IALU2:short:iu:SAT2H imm
# OBSOLETE "sat2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_sath(_SD, Ra, RbH, imm_5, 1, 0);
# OBSOLETE 	do_sath(_SD, Ra, RbL, imm_5, 0, 0);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SATHp
# OBSOLETE 
# OBSOLETE ::%s::p:int p
# OBSOLETE 	switch (p)
# OBSOLETE 	  {
# OBSOLETE 	  case 0: return "l";
# OBSOLETE 	  case 1: return "h";
# OBSOLETE 	  default: return "?";
# OBSOLETE 	  }
# OBSOLETE 
# OBSOLETE _IALU2,1110,p,00,6.RA,6.RB,6.RC:IALU2:short:iu:SATHP
# OBSOLETE "sath%s<p> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_sath(_SD, Ra, Rb, Rc, p, 1);
# OBSOLETE _IALU2,1110,p,10,6.RA,6.RB,_IMM6:IALU2:short:iu:SATHP imm
# OBSOLETE "sath%s<p> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_sath(_SD, Ra, Rb, imm_5, p, 1);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SATZ
# OBSOLETE 
# OBSOLETE void::function::do_satz:signed32 *ra, signed32 rb, signed32 src
# OBSOLETE 	if (rb < 0)
# OBSOLETE 	  WRITE32_QUEUE (ra, 0);
# OBSOLETE 	else
# OBSOLETE 	  do_sat (_SD, ra, rb, src);
# OBSOLETE 
# OBSOLETE _IALU2,01010,00,6.RA,6.RB,6.RC:IALU2:short:iu:SATZ
# OBSOLETE "satz r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_satz(_SD, Ra, Rb, Rc);
# OBSOLETE _IALU2,01010,10,6.RA,6.RB,_IMM6:IALU2:short:iu:SATZ imm
# OBSOLETE "satz r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_satz(_SD, Ra, Rb, imm_5);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SATZ2H
# OBSOLETE 
# OBSOLETE void::function::do_satzh:signed32 *ra, signed16 rb, signed32 src, int high
# OBSOLETE 	int bits = LSMASKED32(src, 3, 0); /*4*/
# OBSOLETE 	signed16 sat = LSMASK16(bits, 0) >> 2;
# OBSOLETE 	signed16 nsat = 0;
# OBSOLETE 	signed16 value;
# OBSOLETE 	if (bits != src)
# OBSOLETE 	  sim_io_eprintf (sd, "warning: 0x%lx:SATZ2H bit overflow\n", (long) cia);
# OBSOLETE 	if (bits == 0 && rb > sat)
# OBSOLETE 	  value = rb;
# OBSOLETE 	else if (rb > sat)
# OBSOLETE 	  value = sat;
# OBSOLETE 	else if (rb < nsat)
# OBSOLETE 	  value = nsat;
# OBSOLETE 	else
# OBSOLETE 	  value = rb;
# OBSOLETE 	if (high)
# OBSOLETE 	  WRITE32_QUEUE_MASK (ra, value << 16, 0xffff0000);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE_MASK (ra, value, 0x0000ffff);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE _IALU2,01011,00,6.RA,6.RB,6.RC:IALU2:short:iu:SATZ2H
# OBSOLETE "satz2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_satzh(_SD, Ra, RbH, RcH, 1);
# OBSOLETE 	do_satzh(_SD, Ra, RbL, RcL, 0);
# OBSOLETE _IALU2,01011,10,6.RA,6.RB,_IMM6:IALU2:short:iu:SATZ2H imm
# OBSOLETE "satz2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_satzh(_SD, Ra, RbH, imm, 1);
# OBSOLETE 	do_satzh(_SD, Ra, RbL, imm, 0);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SRA
# OBSOLETE 
# OBSOLETE void::function::do_sra:unsigned32 *ra, unsigned32 rb, signed32 src
# OBSOLETE 	unsigned32 value;
# OBSOLETE 	while (src > 31) src -= 32;
# OBSOLETE 	while (src < -32) src += 32;
# OBSOLETE 	if (src >= 0)
# OBSOLETE 	  value = (signed32)rb >> src;
# OBSOLETE 	else if (src == -32)
# OBSOLETE 	  value = 0;
# OBSOLETE 	else
# OBSOLETE 	  value = rb << -src;
# OBSOLETE 	WRITE32_QUEUE (ra, value);
# OBSOLETE 
# OBSOLETE _LOGIC,10000,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRA
# OBSOLETE "sra r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_sra(_SD, Ra, Rb, Rc);
# OBSOLETE _LOGIC,10000,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRA imm
# OBSOLETE "sra r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_sra(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SRAHp
# OBSOLETE 
# OBSOLETE void::function::do_srah:unsigned32 *ra, unsigned32 rb, int src, int high
# OBSOLETE 	unsigned32 value;
# OBSOLETE 	while (src > 31) src -= 32;
# OBSOLETE 	while (src < -32) src += 32;
# OBSOLETE 	if (src >= 0)
# OBSOLETE 	  value = (signed32)rb >> src;
# OBSOLETE 	else if (src == -32)
# OBSOLETE 	  value = 0;
# OBSOLETE 	else
# OBSOLETE 	  value = rb << -src;
# OBSOLETE 	if (high)
# OBSOLETE 	  WRITE32_QUEUE_MASK (ra, value << 16, 0xffff0000);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE_MASK (ra, value, 0x0000ffff);
# OBSOLETE 
# OBSOLETE _LOGIC,0010,p,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRAHP
# OBSOLETE "srah%s<p> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_srah(_SD, Ra, Rb, Rc, p);
# OBSOLETE _LOGIC,0010,p,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRAHP imm
# OBSOLETE "srah%s<p> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_srah(_SD, Ra, Rb, imm, p);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SRA2H
# OBSOLETE 
# OBSOLETE _LOGIC,10001,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRA2H
# OBSOLETE "sra2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	signed32 srcH = RcH;
# OBSOLETE 	signed32 srcL = RcL;
# OBSOLETE 	while (srcH > 15) srcH -= 16;
# OBSOLETE 	while (srcH < -16) srcH += 16;
# OBSOLETE 	while (srcL > 15) srcL -= 16;
# OBSOLETE 	while (srcL < -16) srcL += 16;
# OBSOLETE 	do_srah(_SD, Ra, RbH, srcH, 1);
# OBSOLETE 	do_srah(_SD, Ra, RbL, srcL, 0);
# OBSOLETE _LOGIC,10001,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRA2H imm
# OBSOLETE "sra2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	signed32 src = imm;
# OBSOLETE 	while (src > 15) src -= 16;
# OBSOLETE 	while (src < -16) src += 16;
# OBSOLETE 	do_srah(_SD, Ra, RbH, src, 1);
# OBSOLETE 	do_srah(_SD, Ra, RbL, src, 0);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SRC
# OBSOLETE 
# OBSOLETE void::function::do_src:unsigned32 *ra, unsigned32 rb, int src
# OBSOLETE 	unsigned32 value;
# OBSOLETE 	unsigned64 operand;
# OBSOLETE 	unsigned64 shifted;
# OBSOLETE 	while (src > 31) src -= 32;
# OBSOLETE 	while (src < -32) src += 32;
# OBSOLETE 	if (src >= 0)
# OBSOLETE 	  {
# OBSOLETE 	    operand = (INSERTED64(rb, 0, 31) | INSERTED64(*ra, 32, 63));
# OBSOLETE 	    shifted = operand >> src;
# OBSOLETE 	    value = EXTRACTED64(shifted, 32, 63);
# OBSOLETE 	  }
# OBSOLETE 	else
# OBSOLETE 	  {
# OBSOLETE 	    operand = (INSERTED64(*ra, 0, 31) | INSERTED64(rb, 32, 63));
# OBSOLETE 	    shifted = operand << -src;
# OBSOLETE 	    value = EXTRACTED64(shifted, 0, 31);
# OBSOLETE 	  }
# OBSOLETE 	WRITE32_QUEUE (ra, value);
# OBSOLETE 
# OBSOLETE _LOGIC,10110,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRC
# OBSOLETE "src r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_src(_SD, Ra, Rb, Rc);
# OBSOLETE _LOGIC,10110,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRC imm
# OBSOLETE "src r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_src(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SRL
# OBSOLETE 
# OBSOLETE void::function::do_srl:unsigned32 *ra, unsigned32 rb, int src
# OBSOLETE 	unsigned32 value;
# OBSOLETE 	while (src > 31) src -= 32;
# OBSOLETE 	while (src < -32) src += 32;
# OBSOLETE 	if (src >= 0)
# OBSOLETE 	  value = (unsigned32)rb >> src;
# OBSOLETE 	else if (src == -32)
# OBSOLETE 	  value = 0;
# OBSOLETE 	else
# OBSOLETE 	  value = (unsigned32)rb << -src;
# OBSOLETE 	WRITE32_QUEUE (ra, value);
# OBSOLETE 
# OBSOLETE _LOGIC,10010,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRL
# OBSOLETE "srl r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_srl(_SD, Ra, Rb, Rc);
# OBSOLETE _LOGIC,10010,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRL imm
# OBSOLETE "srl r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_srl(_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SRLHp
# OBSOLETE 
# OBSOLETE void::function::do_srlh:unsigned32 *ra, unsigned32 rb, int src, int high
# OBSOLETE 	unsigned32 value;
# OBSOLETE 	while (src > 31) src -= 32;
# OBSOLETE 	while (src < -32) src += 32;
# OBSOLETE 	if (src >= 0)
# OBSOLETE 	  value = rb >> src;
# OBSOLETE 	else if (src == -32)
# OBSOLETE 	  value = 0;
# OBSOLETE 	else
# OBSOLETE 	  value = rb << -src;
# OBSOLETE 	if (high)
# OBSOLETE 	  WRITE32_QUEUE_MASK (ra, value << 16, 0xffff0000);
# OBSOLETE 	else
# OBSOLETE 	  WRITE32_QUEUE_MASK (ra, value, 0x0000ffff);
# OBSOLETE 
# OBSOLETE _LOGIC,0011,p,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRLHP
# OBSOLETE "srlh%s<p> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_srlh(_SD, Ra, Rb, Rc, p);
# OBSOLETE _LOGIC,0011,p,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRLHP imm
# OBSOLETE "srlh%s<p> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_srlh(_SD, Ra, Rb, imm, p);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SRL2H
# OBSOLETE 
# OBSOLETE _LOGIC,10011,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:SRL2H
# OBSOLETE "srl2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	signed32 srcH = RcH;
# OBSOLETE 	signed32 srcL = RcL;
# OBSOLETE 	while (srcH > 15) srcH -= 16;
# OBSOLETE 	while (srcH < -16) srcH += 16;
# OBSOLETE 	while (srcL > 15) srcL -= 16;
# OBSOLETE 	while (srcL < -16) srcL += 16;
# OBSOLETE 	do_srlh(_SD, Ra, RbHU, srcH, 1);
# OBSOLETE 	do_srlh(_SD, Ra, RbLU, srcL, 0);
# OBSOLETE _LOGIC,10011,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:SRL2H imm
# OBSOLETE "srl2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	signed32 src = imm;
# OBSOLETE 	while (src > 15) src -= 16;
# OBSOLETE 	while (src < -16) src += 16;
# OBSOLETE 	do_srlh(_SD, Ra, RbHU, src, 1);
# OBSOLETE 	do_srlh(_SD, Ra, RbLU, src, 0);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ST2H
# OBSOLETE 
# OBSOLETE void::function::get_even_reg:int *reg, unsigned32 *r0, const char *name
# OBSOLETE 	if (*reg & 1)
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia,
# OBSOLETE 			    "0x%lx:%s odd register (r%d) used in multi-word store",
# OBSOLETE 			    (long) cia, name, *reg);
# OBSOLETE 	if (*reg == 0)
# OBSOLETE 	  *r0 = 0;
# OBSOLETE 	else
# OBSOLETE 	  *r0 = GPR[*reg];
# OBSOLETE 
# OBSOLETE void::function::do_st2h:int ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	unsigned32 val_ra;
# OBSOLETE 	unsigned32 mem;
# OBSOLETE 	get_even_reg(_SD, &ra, &val_ra, "ST2H");
# OBSOLETE 	mem = INSERTED32(val_ra, 0, 15) |
# OBSOLETE 	      INSERTED32(GPR[ra + 1], 16, 31);
# OBSOLETE 	STORE(rb + src, 4, mem);
# OBSOLETE 
# OBSOLETE _IMEM,10011,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:ST2H
# OBSOLETE "st2h r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "st2h r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_st2h(_SD, RA, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 4);
# OBSOLETE _IMEM,10011,10,6.RA,6.RB,_IMM32:IMEM:long:mu:ST2H long
# OBSOLETE "st2h r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_st2h(_SD, RA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ST2W
# OBSOLETE 
# OBSOLETE void::function::do_st2w:int ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	unsigned32 val_ra;
# OBSOLETE 	unsigned64 mem;
# OBSOLETE 	get_even_reg(_SD, &ra, &val_ra, "ST2W");
# OBSOLETE 	mem = INSERTED64(val_ra, 0, 31) | INSERTED64(GPR[ra + 1], 32, 63);
# OBSOLETE 	STORE(rb + src, 8, mem);
# OBSOLETE 
# OBSOLETE _IMEM,10110,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:ST2W
# OBSOLETE "st2w r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "st2w r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_st2w(_SD, RA, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 8);
# OBSOLETE _IMEM,10110,10,6.RA,6.RB,_IMM32:IMEM:long:mu:ST2W long
# OBSOLETE "st2w r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_st2w(_SD, RA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // ST4HB
# OBSOLETE 
# OBSOLETE void::function::do_st4hb:int ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	unsigned32 val_ra;
# OBSOLETE 	unsigned32 mem;
# OBSOLETE 	get_even_reg(_SD, &ra, &val_ra, "ST4HB");
# OBSOLETE 	mem = INSERTED32(EXTRACTED32(val_ra, 8, 15), 0, 7) |
# OBSOLETE 	      INSERTED32(EXTRACTED32(val_ra, 24, 31), 8, 15) |
# OBSOLETE 	      INSERTED32(EXTRACTED32(GPR[ra + 1], 8, 15), 16, 23) |
# OBSOLETE 	      INSERTED32(EXTRACTED32(GPR[ra + 1], 24, 31), 24, 31);
# OBSOLETE 	STORE(rb + src, 4, mem);
# OBSOLETE 
# OBSOLETE _IMEM,10101,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:ST4HB
# OBSOLETE "st4hb r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "st4hb r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_st4hb(_SD, RA, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 4);
# OBSOLETE _IMEM,10101,10,6.RA,6.RB,_IMM32:IMEM:long:mu:ST4HB long
# OBSOLETE "st4hb r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_st4hb(_SD, RA, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // STB
# OBSOLETE 
# OBSOLETE void::function::do_stb:unsigned32 ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	STORE(rb + src, 1, EXTRACTED32(ra, 24, 31));
# OBSOLETE 
# OBSOLETE _IMEM,10000,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:STB
# OBSOLETE "stb r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "stb r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_stb(_SD, val_Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 1);
# OBSOLETE _IMEM,10000,10,6.RA,6.RB,_IMM32:IMEM:long:mu:STB long
# OBSOLETE "stb r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_stb(_SD, val_Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // STH
# OBSOLETE 
# OBSOLETE void::function::do_sth:unsigned32 ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	STORE(rb + src, 2, EXTRACTED32(ra, 16, 31));
# OBSOLETE 
# OBSOLETE _IMEM,10010,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:STH
# OBSOLETE "sth r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "sth r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_sth(_SD, val_Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 2);
# OBSOLETE _IMEM,10010,10,6.RA,6.RB,_IMM32:IMEM:long:mu:STH long
# OBSOLETE "sth r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_sth(_SD, val_Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // STHH
# OBSOLETE 
# OBSOLETE void::function::do_sthh:unsigned32 ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	STORE(rb + src, 2, EXTRACTED32(ra, 0, 15));
# OBSOLETE 
# OBSOLETE _IMEM,10001,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:STHH
# OBSOLETE "sthh r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "sthh r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_sthh(_SD, val_Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 2);
# OBSOLETE _IMEM,10001,10,6.RA,6.RB,_IMM32:IMEM:long:mu:STHH long
# OBSOLETE "sthh r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_sthh(_SD, val_Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // STW
# OBSOLETE 
# OBSOLETE void::function::do_stw:unsigned32 ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	STORE(rb + src, 4, ra);
# OBSOLETE 
# OBSOLETE _IMEM,10100,XX,6.RA,6.RB,6.SRC_6:IMEM:short:mu:STW
# OBSOLETE "stw r<RA>, @@(r<RB>, <SRC_6>)":XX == 0
# OBSOLETE "stw r<RA>, @@(r<RB>%s<XX>, r<SRC_6>)"
# OBSOLETE 	do_stw(_SD, val_Ra, Rb, src);
# OBSOLETE 	do_incr(_SD, XX, &GPR[RB], 4);
# OBSOLETE _IMEM,10100,10,6.RA,6.RB,_IMM32:IMEM:long:mu:STW long
# OBSOLETE "stw r<RA>, @@(r<RB>, <imm>)"
# OBSOLETE 	do_stw(_SD, val_Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SUB
# OBSOLETE 
# OBSOLETE void::function::do_sub:unsigned32 *ra, unsigned32 rb, unsigned32 imm
# OBSOLETE 	ALU_BEGIN(rb);
# OBSOLETE 	ALU_SUBB(imm);
# OBSOLETE 	ALU_END(ra);
# OBSOLETE 
# OBSOLETE _IALU1,00010,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:SUB
# OBSOLETE "sub r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_sub (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,00010,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:SUB imm
# OBSOLETE "sub r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_sub (_SD, Ra, Rb, imm);
# OBSOLETE _IALU1,00010,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:SUB imm long
# OBSOLETE "sub r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_sub (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SUB2H
# OBSOLETE 
# OBSOLETE void::function::do_sub2h:unsigned32 *ra, unsigned32 rb, unsigned32 imm
# OBSOLETE 	unsigned16 high = VH2_4(rb) - VH2_4(imm);
# OBSOLETE 	unsigned16 low  = VL2_4(rb) - VL2_4(imm);
# OBSOLETE 	WRITE32_QUEUE (ra, (high << 16) | low);
# OBSOLETE 
# OBSOLETE _IALU1,00011,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:SUB2H
# OBSOLETE "sub2h r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_sub2h (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,00011,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:SUB2H imm
# OBSOLETE "sub2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_sub2h (_SD, Ra, Rb, immHL);
# OBSOLETE _IALU1,00011,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:SUB2H imm long
# OBSOLETE "sub2h r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_sub2h (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SUBB
# OBSOLETE 
# OBSOLETE void::function::do_subb:unsigned32 *ra, unsigned32 rb, unsigned32 imm
# OBSOLETE 	ALU_BEGIN(rb);
# OBSOLETE 	ALU_SUBB_B(imm, ALU_CARRY);
# OBSOLETE 	ALU_END(ra);
# OBSOLETE 	
# OBSOLETE _IALU1,00101,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:SUBB
# OBSOLETE "subb r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_subb (_SD, Ra, Rb, Rc);
# OBSOLETE _IALU1,00101,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:SUBB imm
# OBSOLETE "subb r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_subb (_SD, Ra, Rb, imm);
# OBSOLETE _IALU1,00101,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:SUBB imm long
# OBSOLETE "subb r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_subb (_SD, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // SUBHppp
# OBSOLETE 
# OBSOLETE void::function::do_subh_ppp:int ppp, unsigned32 *ra, unsigned32 rb, unsigned32 src
# OBSOLETE 	switch (ppp) {
# OBSOLETE 	case 0x0: /* LLL */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VL2_4(rb));
# OBSOLETE 	  ALU16_SUBB(VL2_4(src));
# OBSOLETE 	  ALU16_END(ra, 0);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x1: /* LLH */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VL2_4(rb));
# OBSOLETE 	  ALU16_SUBB(VH2_4(src));
# OBSOLETE 	  ALU16_END(ra, 0);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x2: /* LHL */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VH2_4(rb));
# OBSOLETE 	  ALU16_SUBB(VL2_4(src));
# OBSOLETE 	  ALU16_END(ra, 0);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x3: /* LHH */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VH2_4(rb));
# OBSOLETE 	  ALU16_SUBB(VH2_4(src));
# OBSOLETE 	  ALU16_END(ra, 0);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x4: /* HLL */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VL2_4(rb));
# OBSOLETE 	  ALU16_SUBB(VL2_4(src));
# OBSOLETE 	  ALU16_END(ra, 1);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x5: /* HLH */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VL2_4(rb));
# OBSOLETE 	  ALU16_SUBB(VH2_4(src));
# OBSOLETE 	  ALU16_END(ra, 1);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x6: /* HHL */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VH2_4(rb));
# OBSOLETE 	  ALU16_SUBB(VL2_4(src));
# OBSOLETE 	  ALU16_END(ra, 1);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	case 0x7: /* HHH */
# OBSOLETE 	  {
# OBSOLETE 	  ALU16_BEGIN(VH2_4(rb));
# OBSOLETE 	  ALU16_SUBB(VH2_4(src));
# OBSOLETE 	  ALU16_END(ra, 1);
# OBSOLETE 	  }
# OBSOLETE 	  break;
# OBSOLETE 	default:
# OBSOLETE 	  sim_engine_abort (SD, CPU, cia, "do_subh_ppp - internal error - bad switch");
# OBSOLETE 	}
# OBSOLETE 
# OBSOLETE _IALU1,11,ppp,00,6.RA,6.RB,6.RC:IALU1:short:iu,mu:SUBHppp
# OBSOLETE "subh%s<ppp> r<RA>, r<RB>, r<RC>"
# OBSOLETE 	do_subh_ppp(_SD, ppp, Ra, Rb, Rc);
# OBSOLETE _IALU1,11,ppp,10,6.RA,6.RB,_IMM6:IALU1:short:iu,mu:SUBHppp imm
# OBSOLETE "subh%s<ppp> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_subh_ppp(_SD, ppp, Ra, Rb, immHL);
# OBSOLETE _IALU1,11,ppp,10,6.RA,6.RB,_IMM32:IALU1:long:iu,mu:SUBHppp imm long
# OBSOLETE "subh%s<ppp> r<RA>, r<RB>, <imm>"
# OBSOLETE 	do_subh_ppp(_SD, ppp, Ra, Rb, imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // TRAP
# OBSOLETE 
# OBSOLETE address_word::function::do_trap:address_word trap_vector, address_word nia
# OBSOLETE 	/* Steal trap 31 for doing system calls */
# OBSOLETE 	/* System calls are defined in libgloss/d30v/syscall.h.  */
# OBSOLETE 	if (trap_vector == EIT_VB + 0x20 + (31 << 3))
# OBSOLETE 	  {
# OBSOLETE 	    enum { PARM1 = 2, PARM2, PARM3, PARM4, FUNC };
# OBSOLETE 	    if (GPR[FUNC] == 1)		/* exit */
# OBSOLETE 	      {
# OBSOLETE 	        sim_engine_halt (sd, STATE_CPU (sd, 0), NULL, cia, sim_exited,
# OBSOLETE 		  	         GPR[PARM1]);
# OBSOLETE 	        return -1; /* dummy */
# OBSOLETE 	      }
# OBSOLETE 	    else
# OBSOLETE 	      {
# OBSOLETE 		CB_SYSCALL syscall;
# OBSOLETE 
# OBSOLETE 		CB_SYSCALL_INIT (&syscall);
# OBSOLETE 		syscall.arg1 = GPR[PARM1];
# OBSOLETE 		syscall.arg2 = GPR[PARM2];
# OBSOLETE 		syscall.arg3 = GPR[PARM3];
# OBSOLETE 		syscall.arg4 = GPR[PARM4];
# OBSOLETE 		syscall.func = GPR[FUNC];
# OBSOLETE 		syscall.p1 = (PTR) SD;
# OBSOLETE 		syscall.read_mem = d30v_read_mem;
# OBSOLETE 		syscall.write_mem = d30v_write_mem;
# OBSOLETE 
# OBSOLETE 		WRITE32_QUEUE (&GPR[PARM1],
# OBSOLETE 			       ((cb_syscall (STATE_CALLBACK (SD), &syscall)
# OBSOLETE 				 == CB_RC_OK)
# OBSOLETE 				? syscall.result
# OBSOLETE 				: -syscall.errcode));
# OBSOLETE 		return nia;
# OBSOLETE 	      }
# OBSOLETE 	  }
# OBSOLETE 	else if (TRACE_TRAP_P)
# OBSOLETE 	  {
# OBSOLETE 	    int reg, i;
# OBSOLETE 	    sim_io_eprintf (sd, "\nTrap %ld:\n", (long) ((trap_vector - (EIT_VB + 0x20)) >> 3));
# OBSOLETE 	    for (reg = 0; reg < NR_GENERAL_PURPOSE_REGISTERS; reg += 8)
# OBSOLETE 	      {
# OBSOLETE 		sim_io_eprintf (sd, "r%.2d  - r%.2d: ", reg, reg+7);
# OBSOLETE 		for (i = 0; i < 8; i++)
# OBSOLETE 		  sim_io_eprintf (sd, " 0x%.8lx", (long) GPR[reg+i]);
# OBSOLETE 		sim_io_eprintf (sd, "\n");
# OBSOLETE 	      }
# OBSOLETE 
# OBSOLETE 	    for (reg = 0; reg < 16; reg += 8)
# OBSOLETE 	      {
# OBSOLETE 		sim_io_eprintf (sd, "cr%.2d - cr%.2d:", reg, reg+7);
# OBSOLETE 		for (i = 0; i < 8; i++)
# OBSOLETE 		  sim_io_eprintf (sd, " 0x%.8lx", (long) CREG[reg+i]);
# OBSOLETE 		sim_io_eprintf (sd, "\n");
# OBSOLETE 	      }
# OBSOLETE 
# OBSOLETE 	    sim_io_eprintf (sd, "a0   - a1:  ");
# OBSOLETE 	    for (reg = 0; reg < NR_ACCUMULATORS; reg++)
# OBSOLETE 	      sim_io_eprintf (sd, " 0x%.8lx 0x%.8lx",
# OBSOLETE 			      (long)EXTRACTED64(ACC[reg], 0, 31),
# OBSOLETE 			      (long)EXTRACTED64(ACC[reg], 32, 63));
# OBSOLETE 	    sim_io_eprintf (sd, "\n");
# OBSOLETE 
# OBSOLETE 	    sim_io_eprintf (sd, "f0   - f7:  ");
# OBSOLETE 	    sim_io_eprintf (sd, "     (f0) %d", (int) PSW_VAL(PSW_F0));
# OBSOLETE 	    sim_io_eprintf (sd, "     (f1) %d", (int) PSW_VAL(PSW_F1));
# OBSOLETE 	    sim_io_eprintf (sd, "     (f2) %d", (int) PSW_VAL(PSW_F2));
# OBSOLETE 	    sim_io_eprintf (sd, "     (f3) %d", (int) PSW_VAL(PSW_F3));
# OBSOLETE 	    sim_io_eprintf (sd, "      (s) %d", (int) PSW_VAL(PSW_S));
# OBSOLETE 	    sim_io_eprintf (sd, "      (v) %d", (int) PSW_VAL(PSW_V));
# OBSOLETE 	    sim_io_eprintf (sd, "     (va) %d", (int) PSW_VAL(PSW_VA));
# OBSOLETE 	    sim_io_eprintf (sd, "      (c) %d\n", (int) PSW_VAL(PSW_C));
# OBSOLETE 
# OBSOLETE 	    sim_io_eprintf (sd, "pswh:       ");
# OBSOLETE 	    sim_io_eprintf (sd, "     (sm) %d", (int) PSW_VAL(PSW_SM));
# OBSOLETE 	    sim_io_eprintf (sd, "     (ea) %d", (int) PSW_VAL(PSW_EA));
# OBSOLETE 	    sim_io_eprintf (sd, "     (ie) %d", (int) PSW_VAL(PSW_IE));
# OBSOLETE 	    sim_io_eprintf (sd, "     (rp) %d", (int) PSW_VAL(PSW_RP));
# OBSOLETE 	    sim_io_eprintf (sd, "     (md) %d", (int) PSW_VAL(PSW_MD));
# OBSOLETE 
# OBSOLETE 	    if (PSW_VAL(PSW_DB))
# OBSOLETE 	      sim_io_eprintf (sd, "     (db) %d", (int) PSW_VAL(PSW_DB));
# OBSOLETE 
# OBSOLETE 	    if (PSW_VAL(PSW_DS))
# OBSOLETE 	      sim_io_eprintf (sd, "     (ds) %d", (int) PSW_VAL(PSW_DS));
# OBSOLETE 
# OBSOLETE 	    sim_io_eprintf (sd, "\n");
# OBSOLETE 	    return nia;
# OBSOLETE 	  }
# OBSOLETE 	else
# OBSOLETE 	  {
# OBSOLETE 	    if(PSW_VAL(PSW_RP) && RPT_E == cia)
# OBSOLETE 	      {
# OBSOLETE 		WRITE32_QUEUE (&bPC, RPT_S);
# OBSOLETE 		if (RPT_C == 0)
# OBSOLETE 		  PSW_SET (PSW_RP, 0);
# OBSOLETE 	      }
# OBSOLETE 	    else
# OBSOLETE 	      WRITE32_QUEUE (&bPC, cia + 8);
# OBSOLETE 	    DID_TRAP = 1;
# OBSOLETE 	    return trap_vector;
# OBSOLETE 	  }
# OBSOLETE 
# OBSOLETE _BRA,01001,00,6.**,6.**,6.RC:BRA:short:mu:TRAP
# OBSOLETE "trap r<RC>"
# OBSOLETE 	nia = do_trap (_SD, EIT_VB + 0x20 + MASKED32(Rc, 24, 28), nia);
# OBSOLETE _BRA,01001,10,6.**,6.**,_IMM6:BRA:short:mu:TRAP imm
# OBSOLETE "trap <imm>"
# OBSOLETE 	nia = do_trap (_SD, EIT_VB + 0x20 + (imm_5 << 3), nia);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // XOR
# OBSOLETE 
# OBSOLETE _LOGIC,11011,00,6.RA,6.RB,6.RC:LOGIC:short:iu,mu:XOR
# OBSOLETE "xor r<RA>, r<RB>, r<RC>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb ^ Rc);
# OBSOLETE _LOGIC,11011,10,6.RA,6.RB,_IMM6:LOGIC:short:iu,mu:XOR imm
# OBSOLETE "xor r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb ^ imm);
# OBSOLETE _LOGIC,11011,10,6.RA,6.RB,_IMM32:LOGIC:long:iu,mu:XOR imm long
# OBSOLETE "xor r<RA>, r<RB>, <imm>"
# OBSOLETE 	WRITE32_QUEUE (Ra, Rb ^ imm);
# OBSOLETE 
# OBSOLETE 
# OBSOLETE 
# OBSOLETE // XORFG
# OBSOLETE 
# OBSOLETE _LOGIC,01011,00,***,3.FA,***,3.FB,***,3.FC:LOGIC:short:iu,mu:XORFG
# OBSOLETE "xorfg f<FA>, f<FB>, f<FC>"
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, PSW_FLAG_VAL(FB) ^ PSW_FLAG_VAL(FC));
# OBSOLETE _LOGIC,01011,10,***,3.FA,***,3.FB,_IMM6:LOGIC:short:iu,mu:XORFG imm
# OBSOLETE "xorfg f<FA>, f<FB>, <imm_6>"
# OBSOLETE 	PSW_FLAG_SET_QUEUE(FA, PSW_FLAG_VAL(FB) ^ (imm_6 & 1));
@


1.1
log
@Initial revision
@
text
@d42 1
a42 1
	sim_io_eprintf (sd, "illegal instruction at 0x%lx\n", cia);
d48 1
a48 1
	sim_io_eprintf (sd, "wrong slot at 0x%lx\n", cia);
d1064 1
a1064 1
			    cia, name, reg);
d1523 1
a1527 1
		  CPU->left_kills_right_p = 1;
a1539 1
	  CPU->left_kills_right_p = 1;
a1545 1
	    CPU->left_kills_right_p = 1;
a1549 1
	  CPU->left_kills_right_p = 1;
d1617 3
d1624 2
d1627 2
a1628 2
	WRITE32_QUEUE (&RPT_S, cia + 8);
	WRITE32_QUEUE (&RPT_E, cia + pcaddr);
d1705 1
a1705 1
	  sim_io_eprintf (sd, "warning: 0x%lx:SAT bit overflow\n", cia);
d1734 1
a1734 1
	  sim_io_eprintf (sd, "warning: 0x%lx:SAT bit overflow\n", cia);
d1750 1
a1750 1
	    if(STATE_CPU (sd, 0)->left_kills_right_p)
d1812 1
a1812 1
	  sim_io_eprintf (sd, "warning: 0x%lx:SATZ2H bit overflow\n", cia);
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a1522 1
	      CPU->mvtsys_left_p = 1;
d1527 1
d1540 1
d1547 1
d1552 1
d1748 1
a1748 1
	    if(STATE_CPU (sd, 0)->mvtsys_left_p)
@


1.1.1.3
log
@import gdb-1999-06-01 snapshot
@
text
@a1616 3
	address_word rpt_s = cia + 8;
	address_word rpt_e = cia + pcaddr;

a1620 2
	if (rpt_e  < rpt_s + 0x18)
	  sim_io_eprintf (sd, "warning: 0x%lx: REPEAT or REPEATI loop is too small\n", cia);
d1622 2
a1623 2
	WRITE32_QUEUE (&RPT_S, rpt_s);
	WRITE32_QUEUE (&RPT_E, rpt_e);
@


1.1.1.4
log
@import gdb-1999-09-08 snapshot
@
text
@d42 1
a42 1
	sim_io_eprintf (sd, "illegal instruction at 0x%lx\n", (long) cia);
d48 1
a48 1
	sim_io_eprintf (sd, "wrong slot at 0x%lx\n", (long) cia);
d1064 1
a1064 1
			    (long) cia, name, reg);
d1625 1
a1625 1
	  sim_io_eprintf (sd, "warning: 0x%lx: REPEAT or REPEATI loop is too small\n", (long) cia);
d1705 1
a1705 1
	  sim_io_eprintf (sd, "warning: 0x%lx:SAT bit overflow\n", (long) cia);
d1734 1
a1734 1
	  sim_io_eprintf (sd, "warning: 0x%lx:SAT bit overflow\n", (long) cia);
d1812 1
a1812 1
	  sim_io_eprintf (sd, "warning: 0x%lx:SATZ2H bit overflow\n", (long) cia);
@


