head	1.3;
access;
symbols
	gdb_6_3-20041109-release:1.2
	gdb_6_3-branch:1.2.0.66
	gdb_6_3-20041019-branchpoint:1.2
	drow_intercu-merge-20040921:1.2
	drow_intercu-merge-20040915:1.2
	jimb-gdb_6_2-e500-branch:1.2.0.68
	jimb-gdb_6_2-e500-branchpoint:1.2
	gdb_6_2-20040730-release:1.2
	gdb_6_2-branch:1.2.0.64
	gdb_6_2-2004-07-10-gmt-branchpoint:1.2
	gdb_6_1_1-20040616-release:1.2
	gdb_6_1-2004-04-05-release:1.2
	drow_intercu-merge-20040402:1.2
	drow_intercu-merge-20040327:1.2
	ezannoni_pie-20040323-branch:1.2.0.62
	ezannoni_pie-20040323-branchpoint:1.2
	cagney_tramp-20040321-mergepoint:1.2
	cagney_tramp-20040309-branch:1.2.0.60
	cagney_tramp-20040309-branchpoint:1.2
	gdb_6_1-branch:1.2.0.58
	gdb_6_1-2004-03-01-gmt-branchpoint:1.2
	drow_intercu-20040221-branch:1.2.0.56
	drow_intercu-20040221-branchpoint:1.2
	cagney_bfdfile-20040213-branch:1.2.0.54
	cagney_bfdfile-20040213-branchpoint:1.2
	drow-cplus-merge-20040208:1.2
	carlton_dictionary-20040126-merge:1.2
	cagney_bigcore-20040122-branch:1.2.0.52
	cagney_bigcore-20040122-branchpoint:1.2
	drow-cplus-merge-20040113:1.2
	drow-cplus-merge-20031224:1.2
	drow-cplus-merge-20031220:1.2
	carlton_dictionary-20031215-merge:1.2
	drow-cplus-merge-20031214:1.2
	carlton-dictionary-20031111-merge:1.2
	gdb_6_0-2003-10-04-release:1.2
	kettenis_sparc-20030918-branch:1.2.0.50
	kettenis_sparc-20030918-branchpoint:1.2
	carlton_dictionary-20030917-merge:1.2
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.48
	cagney_x86i386-20030821-branch:1.2.0.46
	cagney_x86i386-20030821-branchpoint:1.2
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.2.0.44
	gdb_6_0-2003-06-23-branchpoint:1.2
	jimb-ppc64-linux-20030613-branch:1.2.0.42
	jimb-ppc64-linux-20030613-branchpoint:1.2
	cagney_convert-20030606-branch:1.2.0.40
	cagney_convert-20030606-branchpoint:1.2
	cagney_writestrings-20030508-branch:1.2.0.38
	cagney_writestrings-20030508-branchpoint:1.2
	jimb-ppc64-linux-20030528-branch:1.2.0.36
	jimb-ppc64-linux-20030528-branchpoint:1.2
	carlton_dictionary-20030523-merge:1.2
	cagney_fileio-20030521-branch:1.2.0.34
	cagney_fileio-20030521-branchpoint:1.2
	kettenis_i386newframe-20030517-mergepoint:1.2
	jimb-ppc64-linux-20030509-branch:1.2.0.32
	jimb-ppc64-linux-20030509-branchpoint:1.2
	kettenis_i386newframe-20030504-mergepoint:1.2
	carlton_dictionary-20030430-merge:1.2
	kettenis_i386newframe-20030419-branch:1.2.0.30
	kettenis_i386newframe-20030419-branchpoint:1.2
	carlton_dictionary-20030416-merge:1.2
	cagney_frameaddr-20030409-mergepoint:1.2
	kettenis_i386newframe-20030406-branch:1.2.0.28
	kettenis_i386newframe-20030406-branchpoint:1.2
	cagney_frameaddr-20030403-branchpoint:1.2
	cagney_frameaddr-20030403-branch:1.2.0.26
	cagney_framebase-20030330-mergepoint:1.2
	cagney_framebase-20030326-branch:1.2.0.24
	cagney_framebase-20030326-branchpoint:1.2
	cagney_lazyid-20030317-branch:1.2.0.22
	cagney_lazyid-20030317-branchpoint:1.2
	kettenis-i386newframe-20030316-mergepoint:1.2
	offbyone-20030313-branch:1.2.0.20
	offbyone-20030313-branchpoint:1.2
	kettenis-i386newframe-20030308-branch:1.2.0.18
	kettenis-i386newframe-20030308-branchpoint:1.2
	carlton_dictionary-20030305-merge:1.2
	cagney_offbyone-20030303-branch:1.2.0.16
	cagney_offbyone-20030303-branchpoint:1.2
	carlton_dictionary-20030207-merge:1.2
	interps-20030202-branch:1.2.0.14
	interps-20030202-branchpoint:1.2
	cagney-unwind-20030108-branch:1.2.0.12
	cagney-unwind-20030108-branchpoint:1.2
	carlton_dictionary-20021223-merge:1.2
	gdb_5_3-2002-12-12-release:1.2
	carlton_dictionary-20021115-merge:1.2
	kseitz_interps-20021105-merge:1.2
	kseitz_interps-20021103-merge:1.2
	drow-cplus-merge-20021020:1.2
	drow-cplus-merge-20021025:1.2
	carlton_dictionary-20021025-merge:1.2
	carlton_dictionary-20021011-merge:1.2
	drow-cplus-branch:1.2.0.10
	drow-cplus-branchpoint:1.2
	kseitz_interps-20020930-merge:1.2
	carlton_dictionary-20020927-merge:1.2
	carlton_dictionary-branch:1.2.0.8
	carlton_dictionary-20020920-branchpoint:1.2
	gdb_5_3-branch:1.2.0.6
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.4
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.2
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.1.1.2
	kseitz_interps-20020528-branch:1.1.1.2.0.18
	kseitz_interps-20020528-branchpoint:1.1.1.2
	cagney_regbuf-20020515-branch:1.1.1.2.0.16
	cagney_regbuf-20020515-branchpoint:1.1.1.2
	jimb-macro-020506-branch:1.1.1.2.0.14
	jimb-macro-020506-branchpoint:1.1.1.2
	gdb_5_2-2002-04-29-release:1.1.1.2
	gdb_5_2-branch:1.1.1.2.0.12
	gdb_5_2-2002-03-03-branchpoint:1.1.1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.2
	gdb_5_1_0_1-2002-01-03-release:1.1.1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.2.0.10
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.2
	gdb_5_1-2001-11-21-release:1.1.1.2
	gdb_s390-2001-09-26-branch:1.1.1.2.0.8
	gdb_s390-2001-09-26-branchpoint:1.1.1.2
	gdb_5_1-2001-07-29-branch:1.1.1.2.0.6
	gdb_5_1-2001-07-29-branchpoint:1.1.1.2
	insight-precleanup-2001-01-01:1.1.1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.3
date	2004.11.12.16.45.20;	author cagney;	state dead;
branches;
next	1.2;

1.2
date	2002.07.14.00.15.20;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.00;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.35.00;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.31.54;	author shebs;	state Exp;
branches
	1.1.1.2.18.1;
next	;

1.1.1.2.18.1
date	2002.07.22.21.47.24;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.3
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* d30v, fr30, mn10200, z8k: Delete directory.
@
text
@/* OBSOLETE /*  This file is part of the program psim. */
/* OBSOLETE  */
/* OBSOLETE     Copyright (C) 1994-1997, Andrew Cagney <cagney@@highland.com.au> */
/* OBSOLETE     Copyright (C) 1996, 1997, Free Software Foundation */
/* OBSOLETE  */
/* OBSOLETE     This program is free software; you can redistribute it and/or modify */
/* OBSOLETE     it under the terms of the GNU General Public License as published by */
/* OBSOLETE     the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE     (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE     This program is distributed in the hope that it will be useful, */
/* OBSOLETE     but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE     GNU General Public License for more details. */
/* OBSOLETE   */
/* OBSOLETE     You should have received a copy of the GNU General Public License */
/* OBSOLETE     along with this program; if not, write to the Free Software */
/* OBSOLETE     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
/* OBSOLETE   */
/* OBSOLETE     */ */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE #ifndef ENGINE_C */
/* OBSOLETE #define ENGINE_C */
/* OBSOLETE  */
/* OBSOLETE #include "sim-main.h" */
/* OBSOLETE  */
/* OBSOLETE #include <stdio.h> */
/* OBSOLETE #include <ctype.h> */
/* OBSOLETE  */
/* OBSOLETE #ifdef HAVE_STDLIB_H */
/* OBSOLETE #include <stdlib.h> */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE #ifdef HAVE_STRING_H */
/* OBSOLETE #include <string.h> */
/* OBSOLETE #else */
/* OBSOLETE #ifdef HAVE_STRINGS_H */
/* OBSOLETE #include <strings.h> */
/* OBSOLETE #endif */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE do_stack_swap (SIM_DESC sd) */
/* OBSOLETE { */
/* OBSOLETE   sim_cpu *cpu = STATE_CPU (sd, 0); */
/* OBSOLETE   unsigned new_sp = (PSW_VAL(PSW_SM) != 0); */
/* OBSOLETE   if (cpu->regs.current_sp != new_sp) */
/* OBSOLETE     { */
/* OBSOLETE       cpu->regs.sp[cpu->regs.current_sp] = SP; */
/* OBSOLETE       cpu->regs.current_sp = new_sp; */
/* OBSOLETE       SP = cpu->regs.sp[cpu->regs.current_sp]; */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE #if WITH_TRACE */
/* OBSOLETE /* Implement ALU tracing of 32-bit registers.  */ */
/* OBSOLETE static void */
/* OBSOLETE trace_alu32 (SIM_DESC sd, */
/* OBSOLETE 	     sim_cpu *cpu, */
/* OBSOLETE 	     address_word cia, */
/* OBSOLETE 	     unsigned32 *ptr) */
/* OBSOLETE { */
/* OBSOLETE   unsigned32 value = *ptr; */
/* OBSOLETE  */
/* OBSOLETE   if (ptr >= &GPR[0] && ptr <= &GPR[NR_GENERAL_PURPOSE_REGISTERS]) */
/* OBSOLETE     trace_one_insn (sd, cpu, cia, 1, "engine.c", __LINE__, "alu", */
/* OBSOLETE 		    "Set register r%-2d = 0x%.8lx (%ld)", */
/* OBSOLETE 		    ptr - &GPR[0], (long)value, (long)value); */
/* OBSOLETE  */
/* OBSOLETE   else if (ptr == &PSW || ptr == &bPSW || ptr == &DPSW) */
/* OBSOLETE     trace_one_insn (sd, cpu, cia, 1, "engine.c", __LINE__, "alu", */
/* OBSOLETE 		    "Set register %s = 0x%.8lx%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s", */
/* OBSOLETE 		    (ptr == &PSW) ? "psw" : ((ptr == &bPSW) ? "bpsw" : "dpsw"), */
/* OBSOLETE 		    (long)value, */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_SM)) ? ", sm" : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_EA)) ? ", ea" : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_DB)) ? ", db" : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_DS)) ? ", ds" : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_IE)) ? ", ie" : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_RP)) ? ", rp" : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_MD)) ? ", md" : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_F0)) ? ", f0" : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_F1)) ? ", f1" : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_F2)) ? ", f2" : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_F3)) ? ", f3" : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_S))  ? ", s"  : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_V))  ? ", v"  : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_VA)) ? ", va" : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_C))  ? ", c"  : ""); */
/* OBSOLETE  */
/* OBSOLETE   else if (ptr >= &CREG[0] && ptr <= &CREG[NR_CONTROL_REGISTERS]) */
/* OBSOLETE     trace_one_insn (sd, cpu, cia, 1, "engine.c", __LINE__, "alu", */
/* OBSOLETE 		    "Set register cr%d = 0x%.8lx (%ld)", */
/* OBSOLETE 		    ptr - &CREG[0], (long)value, (long)value); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Implement ALU tracing of 32-bit registers.  */ */
/* OBSOLETE static void */
/* OBSOLETE trace_alu64 (SIM_DESC sd, */
/* OBSOLETE 	     sim_cpu *cpu, */
/* OBSOLETE 	     address_word cia, */
/* OBSOLETE 	     unsigned64 *ptr) */
/* OBSOLETE { */
/* OBSOLETE   unsigned64 value = *ptr; */
/* OBSOLETE  */
/* OBSOLETE   if (ptr >= &ACC[0] && ptr <= &ACC[NR_ACCUMULATORS]) */
/* OBSOLETE     trace_one_insn (sd, cpu, cia, 1, "engine.c", __LINE__, "alu", */
/* OBSOLETE 		    "Set register a%-2d = 0x%.8lx 0x%.8lx", */
/* OBSOLETE 		    ptr - &ACC[0], */
/* OBSOLETE 		    (unsigned long)(unsigned32)(value >> 32), */
/* OBSOLETE 		    (unsigned long)(unsigned32)value); */
/* OBSOLETE  */
/* OBSOLETE } */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE /* Process all of the queued up writes in order now */ */
/* OBSOLETE void */
/* OBSOLETE unqueue_writes (SIM_DESC sd, */
/* OBSOLETE 		sim_cpu *cpu, */
/* OBSOLETE 		address_word cia) */
/* OBSOLETE { */
/* OBSOLETE   int i, num; */
/* OBSOLETE   int did_psw = 0; */
/* OBSOLETE   unsigned32 *psw_addr = &PSW; */
/* OBSOLETE  */
/* OBSOLETE   num = WRITE32_NUM; */
/* OBSOLETE   for (i = 0; i < num; i++) */
/* OBSOLETE     { */
/* OBSOLETE       unsigned32 mask = WRITE32_MASK (i); */
/* OBSOLETE       unsigned32 *ptr = WRITE32_PTR (i); */
/* OBSOLETE       unsigned32 value = (*ptr & ~mask) | (WRITE32_VALUE (i) & mask); */
/* OBSOLETE       int j; */
/* OBSOLETE  */
/* OBSOLETE       if (ptr == psw_addr) */
/* OBSOLETE        { */
/* OBSOLETE 	 /* If MU instruction was not a MVTSYS, resolve PSW */
/* OBSOLETE              contention in favour of IU. */ */
/* OBSOLETE 	  if(! STATE_CPU (sd, 0)->mvtsys_left_p) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      /* Detect contention in parallel writes to the same PSW flags. */
/* OBSOLETE 		 The hardware allows the updates from IU to prevail over */
/* OBSOLETE 		 those from MU. */ */
/* OBSOLETE 	       */
/* OBSOLETE 	      unsigned32 flag_bits = */
/* OBSOLETE 		BIT32 (PSW_F0) | BIT32 (PSW_F1) | */
/* OBSOLETE 		BIT32 (PSW_F2) | BIT32 (PSW_F3) | */
/* OBSOLETE 		BIT32 (PSW_S) | BIT32 (PSW_V) | */
/* OBSOLETE 		BIT32 (PSW_VA) | BIT32 (PSW_C); */
/* OBSOLETE 	      unsigned32 my_flag_bits = mask & flag_bits; */
/* OBSOLETE 	       */
/* OBSOLETE 	      for (j = i + 1; j < num; j++) */
/* OBSOLETE 		if (WRITE32_PTR (j) == psw_addr && /* write to PSW */ */
/* OBSOLETE 		    WRITE32_MASK (j) & my_flag_bits)  /* some of the same flags */ */
/* OBSOLETE 		  { */
/* OBSOLETE 		    /* Recompute local mask & value, to suppress this */
/* OBSOLETE 		       earlier write to the same flag bits. */ */
/* OBSOLETE 		     */
/* OBSOLETE 		    unsigned32 new_mask = mask & ~(WRITE32_MASK (j) & my_flag_bits); */
/* OBSOLETE 		     */
/* OBSOLETE 		    /* There is a special case for the VA (accumulated */
/* OBSOLETE 		       overflow) flag, in that it is only included in the */
/* OBSOLETE 		       second instruction's mask if the overflow */
/* OBSOLETE 		       occurred.  Yet the hardware still suppresses the */
/* OBSOLETE 		       first instruction's update to VA.  So we kludge */
/* OBSOLETE 		       this by inferring PSW_V -> PSW_VA for the second */
/* OBSOLETE 		       instruction. */ */
/* OBSOLETE 		     */
/* OBSOLETE 		    if (WRITE32_MASK (j) & BIT32 (PSW_V)) */
/* OBSOLETE 		      { */
/* OBSOLETE 			new_mask &= ~BIT32 (PSW_VA); */
/* OBSOLETE 		      } */
/* OBSOLETE 		     */
/* OBSOLETE 		    value = (*ptr & ~new_mask) | (WRITE32_VALUE (i) & new_mask); */
/* OBSOLETE 		  } */
/* OBSOLETE 	    } */
/* OBSOLETE 	   */
/* OBSOLETE          did_psw = 1; */
/* OBSOLETE        } */
/* OBSOLETE  */
/* OBSOLETE       *ptr = value; */
/* OBSOLETE  */
/* OBSOLETE #if WITH_TRACE */
/* OBSOLETE       if (TRACE_ALU_P (cpu)) */
/* OBSOLETE 	trace_alu32 (sd, cpu, cia, ptr); */
/* OBSOLETE #endif */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   num = WRITE64_NUM; */
/* OBSOLETE   for (i = 0; i < num; i++) */
/* OBSOLETE     { */
/* OBSOLETE       unsigned64 *ptr = WRITE64_PTR (i); */
/* OBSOLETE       *ptr = WRITE64_VALUE (i); */
/* OBSOLETE  */
/* OBSOLETE #if WITH_TRACE */
/* OBSOLETE       if (TRACE_ALU_P (cpu)) */
/* OBSOLETE 	trace_alu64 (sd, cpu, cia, ptr); */
/* OBSOLETE #endif */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   WRITE32_NUM = 0; */
/* OBSOLETE   WRITE64_NUM = 0; */
/* OBSOLETE  */
/* OBSOLETE   if (DID_TRAP == 1) /* ordinary trap */ */
/* OBSOLETE     { */
/* OBSOLETE       bPSW = PSW; */
/* OBSOLETE       PSW &= (BIT32 (PSW_DB) | BIT32 (PSW_SM)); */
/* OBSOLETE       did_psw = 1; */
/* OBSOLETE     } */
/* OBSOLETE   else if (DID_TRAP == 2) /* debug trap */ */
/* OBSOLETE     { */
/* OBSOLETE       DPSW = PSW; */
/* OBSOLETE       PSW &= BIT32 (PSW_DS); */
/* OBSOLETE       PSW |= BIT32 (PSW_DS); */
/* OBSOLETE       did_psw = 1; */
/* OBSOLETE     } */
/* OBSOLETE   DID_TRAP = 0; */
/* OBSOLETE  */
/* OBSOLETE   if (did_psw) */
/* OBSOLETE     do_stack_swap (sd); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* SIMULATE INSTRUCTIONS, various different ways of achieving the same */
/* OBSOLETE    thing */ */
/* OBSOLETE  */
/* OBSOLETE static address_word */
/* OBSOLETE do_long (SIM_DESC sd, */
/* OBSOLETE 	 l_instruction_word instruction, */
/* OBSOLETE 	 address_word cia) */
/* OBSOLETE { */
/* OBSOLETE   address_word nia = l_idecode_issue(sd, */
/* OBSOLETE 				     instruction, */
/* OBSOLETE 				     cia); */
/* OBSOLETE  */
/* OBSOLETE   unqueue_writes (sd, STATE_CPU (sd, 0), cia); */
/* OBSOLETE   return nia; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static address_word */
/* OBSOLETE do_2_short (SIM_DESC sd, */
/* OBSOLETE 	    s_instruction_word insn1, */
/* OBSOLETE 	    s_instruction_word insn2, */
/* OBSOLETE 	    cpu_units unit, */
/* OBSOLETE 	    address_word cia) */
/* OBSOLETE { */
/* OBSOLETE   address_word nia; */
/* OBSOLETE  */
/* OBSOLETE   /* run the first instruction */ */
/* OBSOLETE   STATE_CPU (sd, 0)->unit = unit; */
/* OBSOLETE   STATE_CPU (sd, 0)->left_kills_right_p = 0; */
/* OBSOLETE   STATE_CPU (sd, 0)->mvtsys_left_p = 0; */
/* OBSOLETE   nia = s_idecode_issue(sd, */
/* OBSOLETE 			insn1, */
/* OBSOLETE 			cia); */
/* OBSOLETE  */
/* OBSOLETE   unqueue_writes (sd, STATE_CPU (sd, 0), cia); */
/* OBSOLETE  */
/* OBSOLETE   /* Only do the second instruction if the PC has not changed */ */
/* OBSOLETE   if ((nia == INVALID_INSTRUCTION_ADDRESS) && */
/* OBSOLETE       (! STATE_CPU (sd, 0)->left_kills_right_p)) { */
/* OBSOLETE     STATE_CPU (sd, 0)->unit = any_unit; */
/* OBSOLETE     nia = s_idecode_issue (sd, */
/* OBSOLETE 			   insn2, */
/* OBSOLETE 			   cia); */
/* OBSOLETE  */
/* OBSOLETE     unqueue_writes (sd, STATE_CPU (sd, 0), cia); */
/* OBSOLETE   } */
/* OBSOLETE  */
/* OBSOLETE   STATE_CPU (sd, 0)->left_kills_right_p = 0; */
/* OBSOLETE   STATE_CPU (sd, 0)->mvtsys_left_p = 0; */
/* OBSOLETE   return nia; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static address_word */
/* OBSOLETE do_parallel (SIM_DESC sd, */
/* OBSOLETE 	     s_instruction_word left_insn, */
/* OBSOLETE 	     s_instruction_word right_insn, */
/* OBSOLETE 	     address_word cia) */
/* OBSOLETE { */
/* OBSOLETE   address_word nia_left; */
/* OBSOLETE   address_word nia_right; */
/* OBSOLETE   address_word nia; */
/* OBSOLETE  */
/* OBSOLETE   /* run the first instruction */ */
/* OBSOLETE   STATE_CPU (sd, 0)->unit = memory_unit; */
/* OBSOLETE   STATE_CPU (sd, 0)->left_kills_right_p = 0; */
/* OBSOLETE   STATE_CPU (sd, 0)->mvtsys_left_p = 0; */
/* OBSOLETE   nia_left = s_idecode_issue(sd, */
/* OBSOLETE 			     left_insn, */
/* OBSOLETE 			     cia); */
/* OBSOLETE  */
/* OBSOLETE   /* run the second instruction */ */
/* OBSOLETE   STATE_CPU (sd, 0)->unit = integer_unit; */
/* OBSOLETE   nia_right = s_idecode_issue(sd, */
/* OBSOLETE 			      right_insn, */
/* OBSOLETE 			      cia); */
/* OBSOLETE  */
/* OBSOLETE   /* merge the PC's */ */
/* OBSOLETE   if (nia_left == INVALID_INSTRUCTION_ADDRESS) { */
/* OBSOLETE     if (nia_right == INVALID_INSTRUCTION_ADDRESS) */
/* OBSOLETE       nia = INVALID_INSTRUCTION_ADDRESS; */
/* OBSOLETE     else */
/* OBSOLETE       nia = nia_right; */
/* OBSOLETE   } */
/* OBSOLETE   else { */
/* OBSOLETE     if (nia_right == INVALID_INSTRUCTION_ADDRESS) */
/* OBSOLETE       nia = nia_left; */
/* OBSOLETE     else { */
/* OBSOLETE       sim_engine_abort (sd, STATE_CPU (sd, 0), cia, "parallel jumps"); */
/* OBSOLETE       nia = INVALID_INSTRUCTION_ADDRESS; */
/* OBSOLETE     } */
/* OBSOLETE   } */
/* OBSOLETE  */
/* OBSOLETE   unqueue_writes (sd, STATE_CPU (sd, 0), cia); */
/* OBSOLETE   return nia; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE typedef enum { */
/* OBSOLETE   p_insn = 0, */
/* OBSOLETE   long_insn = 3, */
/* OBSOLETE   l_r_insn = 1, */
/* OBSOLETE   r_l_insn = 2, */
/* OBSOLETE } instruction_types; */
/* OBSOLETE  */
/* OBSOLETE STATIC_INLINE instruction_types */
/* OBSOLETE instruction_type(l_instruction_word insn) */
/* OBSOLETE { */
/* OBSOLETE   int fm0 = MASKED64(insn, 0, 0) != 0; */
/* OBSOLETE   int fm1 = MASKED64(insn, 32, 32) != 0; */
/* OBSOLETE   return ((fm0 << 1) | fm1); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE sim_engine_run (SIM_DESC sd, */
/* OBSOLETE 		int last_cpu_nr, */
/* OBSOLETE 		int nr_cpus, */
/* OBSOLETE 		int siggnal) */
/* OBSOLETE { */
/* OBSOLETE   while (1) */
/* OBSOLETE     { */
/* OBSOLETE       address_word cia = PC; */
/* OBSOLETE       address_word nia; */
/* OBSOLETE       l_instruction_word insn = IMEM(cia); */
/* OBSOLETE       int rp_was_set; */
/* OBSOLETE       int rpt_c_was_nonzero; */
/* OBSOLETE  */
/* OBSOLETE       /* Before executing the instruction, we need to test whether or */
/* OBSOLETE 	 not RPT_C is greater than zero, and save that state for use */
/* OBSOLETE 	 after executing the instruction.  In particular, we need to */
/* OBSOLETE 	 not care whether the instruction changes RPT_C itself. */ */
/* OBSOLETE  */
/* OBSOLETE       rpt_c_was_nonzero = (RPT_C > 0); */
/* OBSOLETE  */
/* OBSOLETE       /* Before executing the instruction, we need to check to see if */
/* OBSOLETE 	 we have to decrement RPT_C, the repeat count register.  Do this */
/* OBSOLETE 	 if PC == RPT_E, but only if we are in an active repeat block. */ */
/* OBSOLETE  */
/* OBSOLETE       if (PC == RPT_E && */
/* OBSOLETE 	  (RPT_C > 0 || PSW_VAL (PSW_RP) != 0)) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  RPT_C --; */
/* OBSOLETE 	} */
/* OBSOLETE        */
/* OBSOLETE       /* Now execute the instruction at PC */ */
/* OBSOLETE  */
/* OBSOLETE       switch (instruction_type (insn)) */
/* OBSOLETE 	{ */
/* OBSOLETE 	case long_insn: */
/* OBSOLETE 	  nia = do_long (sd, insn, cia); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case r_l_insn: */
/* OBSOLETE 	  /* L <- R */ */
/* OBSOLETE 	  nia = do_2_short (sd, insn, insn >> 32, integer_unit, cia); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case l_r_insn: */
/* OBSOLETE 	  /* L -> R */ */
/* OBSOLETE 	  nia = do_2_short (sd, insn >> 32, insn, memory_unit, cia); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case p_insn: */
/* OBSOLETE 	  nia = do_parallel (sd, insn >> 32, insn, cia); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	default: */
/* OBSOLETE 	  sim_engine_abort (sd, STATE_CPU (sd, 0), cia, */
/* OBSOLETE 			    "internal error - engine_run_until_stop - bad switch"); */
/* OBSOLETE 	  nia = -1; */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       if (TRACE_ACTION) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  if (TRACE_ACTION & TRACE_ACTION_CALL) */
/* OBSOLETE 	    call_occurred (sd, STATE_CPU (sd, 0), cia, nia); */
/* OBSOLETE  */
/* OBSOLETE 	  if (TRACE_ACTION & TRACE_ACTION_RETURN) */
/* OBSOLETE 	    return_occurred (sd, STATE_CPU (sd, 0), cia, nia); */
/* OBSOLETE  */
/* OBSOLETE 	  TRACE_ACTION = 0; */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       /* Check now to see if we need to reset the RP bit in the PSW. */
/* OBSOLETE 	 There are three conditions for this, the RP bit is already */
/* OBSOLETE 	 set (just a speed optimization), the instruction we just */
/* OBSOLETE 	 executed is the last instruction in the loop, and the repeat */
/* OBSOLETE 	 count is currently zero. */ */
/* OBSOLETE  */
/* OBSOLETE       rp_was_set = PSW_VAL (PSW_RP); */
/* OBSOLETE       if (rp_was_set && (PC == RPT_E) && RPT_C == 0) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  PSW_SET (PSW_RP, 0); */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       /* Now update the PC.  If we just executed a jump instruction, */
/* OBSOLETE 	 that takes precedence over everything else.  Next comes */
/* OBSOLETE 	 branching back to RPT_S as a result of a loop.  Finally, the */
/* OBSOLETE 	 default is to simply advance to the next inline */
/* OBSOLETE 	 instruction. */ */
/* OBSOLETE  */
/* OBSOLETE       if (nia != INVALID_INSTRUCTION_ADDRESS) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  PC = nia; */
/* OBSOLETE 	} */
/* OBSOLETE       else if (rp_was_set && rpt_c_was_nonzero && (PC == RPT_E)) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  PC = RPT_S; */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  PC = cia + 8; */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       /* Check for DDBT (debugger debug trap) condition.  Do this after */
/* OBSOLETE 	 the repeat block checks so the excursion to the trap handler does */
/* OBSOLETE 	 not alter looping state. */ */
/* OBSOLETE  */
/* OBSOLETE       if (cia == IBA && PSW_VAL (PSW_DB)) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  DPC = PC; */
/* OBSOLETE 	  PSW_SET (PSW_EA, 1); */
/* OBSOLETE 	  DPSW = PSW; */
/* OBSOLETE 	  /* clear all bits in PSW except SM */ */
/* OBSOLETE 	  PSW &= BIT32 (PSW_SM); */
/* OBSOLETE 	  /* add DS bit */ */
/* OBSOLETE 	  PSW |= BIT32 (PSW_DS); */
/* OBSOLETE 	  /* dispatch to DDBT handler */ */
/* OBSOLETE 	  PC = 0xfffff128; /* debugger_debug_trap_address */ */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       /* process any events */ */
/* OBSOLETE       /* FIXME - should L->R or L<-R insns count as two cycles? */ */
/* OBSOLETE       if (sim_events_tick (sd)) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  sim_events_process (sd); */
/* OBSOLETE 	} */
/* OBSOLETE     }   */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* d30v external interrupt handler. */
/* OBSOLETE  */
/* OBSOLETE    Note: This should be replaced by a proper interrupt delivery */
/* OBSOLETE    mechanism.  This interrupt mechanism discards later interrupts if */
/* OBSOLETE    an earlier interrupt hasn't been delivered. */
/* OBSOLETE  */
/* OBSOLETE    Note: This interrupt mechanism does not reset its self when the */
/* OBSOLETE    simulator is re-opened. */ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE d30v_interrupt_event (SIM_DESC sd, */
/* OBSOLETE 		      void *data) */
/* OBSOLETE { */
/* OBSOLETE   if (PSW_VAL (PSW_IE)) */
/* OBSOLETE     /* interrupts not masked */ */
/* OBSOLETE     { */
/* OBSOLETE       /* scrub any pending interrupt */ */
/* OBSOLETE       if (sd->pending_interrupt != NULL) */
/* OBSOLETE 	sim_events_deschedule (sd, sd->pending_interrupt); */
/* OBSOLETE       /* deliver */ */
/* OBSOLETE       bPSW = PSW; */
/* OBSOLETE       bPC = PC; */
/* OBSOLETE       PSW = 0; */
/* OBSOLETE       PC = 0xfffff138; /* external interrupt */ */
/* OBSOLETE       do_stack_swap (sd); */
/* OBSOLETE     } */
/* OBSOLETE   else if (sd->pending_interrupt == NULL) */
/* OBSOLETE     /* interrupts masked and no interrupt pending */ */
/* OBSOLETE     { */
/* OBSOLETE       sd->pending_interrupt = sim_events_schedule (sd, 1, */
/* OBSOLETE 						   d30v_interrupt_event, */
/* OBSOLETE 						   data); */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE #endif */
@


1.2
log
@Obsolete the d30v.
@
text
@@


1.1
log
@Initial revision
@
text
@d1 496
a496 493
/*  This file is part of the program psim.

    Copyright (C) 1994-1997, Andrew Cagney <cagney@@highland.com.au>
    Copyright (C) 1996, 1997, Free Software Foundation

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
    */


#ifndef ENGINE_C
#define ENGINE_C

#include "sim-main.h"

#include <stdio.h>
#include <ctype.h>

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#ifdef HAVE_STRING_H
#include <string.h>
#else
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif
#endif

static void
do_stack_swap (SIM_DESC sd)
{
  sim_cpu *cpu = STATE_CPU (sd, 0);
  unsigned new_sp = (PSW_VAL(PSW_SM) != 0);
  if (cpu->regs.current_sp != new_sp)
    {
      cpu->regs.sp[cpu->regs.current_sp] = SP;
      cpu->regs.current_sp = new_sp;
      SP = cpu->regs.sp[cpu->regs.current_sp];
    }
}

#if WITH_TRACE
/* Implement ALU tracing of 32-bit registers.  */
static void
trace_alu32 (SIM_DESC sd,
	     sim_cpu *cpu,
	     address_word cia,
	     unsigned32 *ptr)
{
  unsigned32 value = *ptr;

  if (ptr >= &GPR[0] && ptr <= &GPR[NR_GENERAL_PURPOSE_REGISTERS])
    trace_one_insn (sd, cpu, cia, 1, "engine.c", __LINE__, "alu",
		    "Set register r%-2d = 0x%.8lx (%ld)",
		    ptr - &GPR[0], (long)value, (long)value);

  else if (ptr == &PSW || ptr == &bPSW || ptr == &DPSW)
    trace_one_insn (sd, cpu, cia, 1, "engine.c", __LINE__, "alu",
		    "Set register %s = 0x%.8lx%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
		    (ptr == &PSW) ? "psw" : ((ptr == &bPSW) ? "bpsw" : "dpsw"),
		    (long)value,
		    (value & (0x80000000 >> PSW_SM)) ? ", sm" : "",
		    (value & (0x80000000 >> PSW_EA)) ? ", ea" : "",
		    (value & (0x80000000 >> PSW_DB)) ? ", db" : "",
		    (value & (0x80000000 >> PSW_DS)) ? ", ds" : "",
		    (value & (0x80000000 >> PSW_IE)) ? ", ie" : "",
		    (value & (0x80000000 >> PSW_RP)) ? ", rp" : "",
		    (value & (0x80000000 >> PSW_MD)) ? ", md" : "",
		    (value & (0x80000000 >> PSW_F0)) ? ", f0" : "",
		    (value & (0x80000000 >> PSW_F1)) ? ", f1" : "",
		    (value & (0x80000000 >> PSW_F2)) ? ", f2" : "",
		    (value & (0x80000000 >> PSW_F3)) ? ", f3" : "",
		    (value & (0x80000000 >> PSW_S))  ? ", s"  : "",
		    (value & (0x80000000 >> PSW_V))  ? ", v"  : "",
		    (value & (0x80000000 >> PSW_VA)) ? ", va" : "",
		    (value & (0x80000000 >> PSW_C))  ? ", c"  : "");

  else if (ptr >= &CREG[0] && ptr <= &CREG[NR_CONTROL_REGISTERS])
    trace_one_insn (sd, cpu, cia, 1, "engine.c", __LINE__, "alu",
		    "Set register cr%d = 0x%.8lx (%ld)",
		    ptr - &CREG[0], (long)value, (long)value);
}

/* Implement ALU tracing of 32-bit registers.  */
static void
trace_alu64 (SIM_DESC sd,
	     sim_cpu *cpu,
	     address_word cia,
	     unsigned64 *ptr)
{
  unsigned64 value = *ptr;

  if (ptr >= &ACC[0] && ptr <= &ACC[NR_ACCUMULATORS])
    trace_one_insn (sd, cpu, cia, 1, "engine.c", __LINE__, "alu",
		    "Set register a%-2d = 0x%.8lx 0x%.8lx",
		    ptr - &ACC[0],
		    (unsigned long)(unsigned32)(value >> 32),
		    (unsigned long)(unsigned32)value);

}
#endif

/* Process all of the queued up writes in order now */
void
unqueue_writes (SIM_DESC sd,
		sim_cpu *cpu,
		address_word cia)
{
  int i, num;
  int did_psw = 0;
  unsigned32 *psw_addr = &PSW;

  num = WRITE32_NUM;
  for (i = 0; i < num; i++)
    {
      unsigned32 mask = WRITE32_MASK (i);
      unsigned32 *ptr = WRITE32_PTR (i);
      unsigned32 value = (*ptr & ~mask) | (WRITE32_VALUE (i) & mask);
      int j;

      if (ptr == psw_addr)
       {
	  /* If MU instruction was not a MVTSYS (lkr), resolve PSW
             contention in favour of IU. */
	  if(! STATE_CPU (sd, 0)->left_kills_right_p)
	    {
	      /* Detect contention in parallel writes to the same PSW flags.
		 The hardware allows the updates from IU to prevail over
		 those from MU. */
	      
	      unsigned32 flag_bits =
		BIT32 (PSW_F0) | BIT32 (PSW_F1) |
		BIT32 (PSW_F2) | BIT32 (PSW_F3) |
		BIT32 (PSW_S) | BIT32 (PSW_V) |
		BIT32 (PSW_VA) | BIT32 (PSW_C);
	      unsigned32 my_flag_bits = mask & flag_bits;
	      
	      for (j = i + 1; j < num; j++)
		if (WRITE32_PTR (j) == psw_addr && /* write to PSW */
		    WRITE32_MASK (j) & my_flag_bits)  /* some of the same flags */
		  {
		    /* Recompute local mask & value, to suppress this
		       earlier write to the same flag bits. */
		    
		    unsigned32 new_mask = mask & ~(WRITE32_MASK (j) & my_flag_bits);
		    
		    /* There is a special case for the VA (accumulated
		       overflow) flag, in that it is only included in the
		       second instruction's mask if the overflow
		       occurred.  Yet the hardware still suppresses the
		       first instruction's update to VA.  So we kludge
		       this by inferring PSW_V -> PSW_VA for the second
		       instruction. */
		    
		    if (WRITE32_MASK (j) & BIT32 (PSW_V))
		      {
			new_mask &= ~BIT32 (PSW_VA);
		      }
		    
		    value = (*ptr & ~new_mask) | (WRITE32_VALUE (i) & new_mask);
		  }
	    }
	  
         did_psw = 1;
       }

      *ptr = value;

#if WITH_TRACE
      if (TRACE_ALU_P (cpu))
	trace_alu32 (sd, cpu, cia, ptr);
#endif
    }

  num = WRITE64_NUM;
  for (i = 0; i < num; i++)
    {
      unsigned64 *ptr = WRITE64_PTR (i);
      *ptr = WRITE64_VALUE (i);

#if WITH_TRACE
      if (TRACE_ALU_P (cpu))
	trace_alu64 (sd, cpu, cia, ptr);
#endif
    }

  WRITE32_NUM = 0;
  WRITE64_NUM = 0;

  if (DID_TRAP == 1) /* ordinary trap */
    {
      bPSW = PSW;
      PSW &= (BIT32 (PSW_DB) | BIT32 (PSW_SM));
      did_psw = 1;
    }
  else if (DID_TRAP == 2) /* debug trap */
    {
      DPSW = PSW;
      PSW &= BIT32 (PSW_DS);
      PSW |= BIT32 (PSW_DS);
      did_psw = 1;
    }
  DID_TRAP = 0;

  if (did_psw)
    do_stack_swap (sd);
}


/* SIMULATE INSTRUCTIONS, various different ways of achieving the same
   thing */

static address_word
do_long (SIM_DESC sd,
	 l_instruction_word instruction,
	 address_word cia)
{
  address_word nia = l_idecode_issue(sd,
				     instruction,
				     cia);

  unqueue_writes (sd, STATE_CPU (sd, 0), cia);
  return nia;
}

static address_word
do_2_short (SIM_DESC sd,
	    s_instruction_word insn1,
	    s_instruction_word insn2,
	    cpu_units unit,
	    address_word cia)
{
  address_word nia;

  /* run the first instruction */
  STATE_CPU (sd, 0)->unit = unit;
  STATE_CPU (sd, 0)->left_kills_right_p = 0;
  nia = s_idecode_issue(sd,
			insn1,
			cia);

  unqueue_writes (sd, STATE_CPU (sd, 0), cia);

  /* Only do the second instruction if the PC has not changed */
  if ((nia == INVALID_INSTRUCTION_ADDRESS) &&
      (! STATE_CPU (sd, 0)->left_kills_right_p)) {
    STATE_CPU (sd, 0)->unit = any_unit;
    nia = s_idecode_issue (sd,
			   insn2,
			   cia);

    unqueue_writes (sd, STATE_CPU (sd, 0), cia);
  }

  STATE_CPU (sd, 0)->left_kills_right_p = 0;
  return nia;
}

static address_word
do_parallel (SIM_DESC sd,
	     s_instruction_word left_insn,
	     s_instruction_word right_insn,
	     address_word cia)
{
  address_word nia_left;
  address_word nia_right;
  address_word nia;

  /* run the first instruction */
  STATE_CPU (sd, 0)->unit = memory_unit;
  STATE_CPU (sd, 0)->left_kills_right_p = 0;
  nia_left = s_idecode_issue(sd,
			     left_insn,
			     cia);

  /* run the second instruction */
  STATE_CPU (sd, 0)->unit = integer_unit;
  nia_right = s_idecode_issue(sd,
			      right_insn,
			      cia);

  /* merge the PC's */
  if (nia_left == INVALID_INSTRUCTION_ADDRESS) {
    if (nia_right == INVALID_INSTRUCTION_ADDRESS)
      nia = INVALID_INSTRUCTION_ADDRESS;
    else
      nia = nia_right;
  }
  else {
    if (nia_right == INVALID_INSTRUCTION_ADDRESS)
      nia = nia_left;
    else {
      sim_engine_abort (sd, STATE_CPU (sd, 0), cia, "parallel jumps");
      nia = INVALID_INSTRUCTION_ADDRESS;
    }
  }

  unqueue_writes (sd, STATE_CPU (sd, 0), cia);
  return nia;
}


typedef enum {
  p_insn = 0,
  long_insn = 3,
  l_r_insn = 1,
  r_l_insn = 2,
} instruction_types;

STATIC_INLINE instruction_types
instruction_type(l_instruction_word insn)
{
  int fm0 = MASKED64(insn, 0, 0) != 0;
  int fm1 = MASKED64(insn, 32, 32) != 0;
  return ((fm0 << 1) | fm1);
}



void
sim_engine_run (SIM_DESC sd,
		int last_cpu_nr,
		int nr_cpus,
		int siggnal)
{
  while (1)
    {
      address_word cia = PC;
      address_word nia;
      l_instruction_word insn = IMEM(cia);
      int rp_was_set;
      int rpt_c_was_nonzero;

      /* Before executing the instruction, we need to test whether or
	 not RPT_C is greater than zero, and save that state for use
	 after executing the instruction.  In particular, we need to
	 not care whether the instruction changes RPT_C itself. */

      rpt_c_was_nonzero = (RPT_C > 0);

      /* Before executing the instruction, we need to check to see if
	 we have to decrement RPT_C, the repeat count register.  Do this
	 if PC == RPT_E, but only if we are in an active repeat block. */

      if (PC == RPT_E &&
	  (RPT_C > 0 || PSW_VAL (PSW_RP) != 0))
	{
	  RPT_C --;
	}
      
      /* Now execute the instruction at PC */

      switch (instruction_type (insn))
	{
	case long_insn:
	  nia = do_long (sd, insn, cia);
	  break;
	case r_l_insn:
	  /* L <- R */
	  nia = do_2_short (sd, insn, insn >> 32, integer_unit, cia);
	  break;
	case l_r_insn:
	  /* L -> R */
	  nia = do_2_short (sd, insn >> 32, insn, memory_unit, cia);
	  break;
	case p_insn:
	  nia = do_parallel (sd, insn >> 32, insn, cia);
	  break;
	default:
	  sim_engine_abort (sd, STATE_CPU (sd, 0), cia,
			    "internal error - engine_run_until_stop - bad switch");
	  nia = -1;
	}

      if (TRACE_ACTION)
	{
	  if (TRACE_ACTION & TRACE_ACTION_CALL)
	    call_occurred (sd, STATE_CPU (sd, 0), cia, nia);

	  if (TRACE_ACTION & TRACE_ACTION_RETURN)
	    return_occurred (sd, STATE_CPU (sd, 0), cia, nia);

	  TRACE_ACTION = 0;
	}

      /* Check now to see if we need to reset the RP bit in the PSW.
	 There are three conditions for this, the RP bit is already
	 set (just a speed optimization), the instruction we just
	 executed is the last instruction in the loop, and the repeat
	 count is currently zero. */

      rp_was_set = PSW_VAL (PSW_RP);
      if (rp_was_set && (PC == RPT_E) && RPT_C == 0)
	{
	  PSW_SET (PSW_RP, 0);
	}

      /* Now update the PC.  If we just executed a jump instruction,
	 that takes precedence over everything else.  Next comes
	 branching back to RPT_S as a result of a loop.  Finally, the
	 default is to simply advance to the next inline
	 instruction. */

      if (nia != INVALID_INSTRUCTION_ADDRESS)
	{
	  PC = nia;
	}
      else if (rp_was_set && rpt_c_was_nonzero && (PC == RPT_E))
	{
	  PC = RPT_S;
	}
      else
	{
	  PC = cia + 8;
	}

      /* Check for DDBT (debugger debug trap) condition.  Do this after
	 the repeat block checks so the excursion to the trap handler does
	 not alter looping state. */

      if (cia == IBA && PSW_VAL (PSW_DB))
	{
	  DPC = PC;
	  PSW_SET (PSW_EA, 1);
	  DPSW = PSW;
	  /* clear all bits in PSW except SM */
	  PSW &= BIT32 (PSW_SM);
	  /* add DS bit */
	  PSW |= BIT32 (PSW_DS);
	  /* dispatch to DDBT handler */
	  PC = 0xfffff128; /* debugger_debug_trap_address */
	}

      /* process any events */
      /* FIXME - should L->R or L<-R insns count as two cycles? */
      if (sim_events_tick (sd))
	{
	  sim_events_process (sd);
	}
    }  
}


/* d30v external interrupt handler.

   Note: This should be replaced by a proper interrupt delivery
   mechanism.  This interrupt mechanism discards later interrupts if
   an earlier interrupt hasn't been delivered.

   Note: This interrupt mechanism does not reset its self when the
   simulator is re-opened. */

void
d30v_interrupt_event (SIM_DESC sd,
		      void *data)
{
  if (PSW_VAL (PSW_IE))
    /* interrupts not masked */
    {
      /* scrub any pending interrupt */
      if (sd->pending_interrupt != NULL)
	sim_events_deschedule (sd, sd->pending_interrupt);
      /* deliver */
      bPSW = PSW;
      bPC = PC;
      PSW = 0;
      PC = 0xfffff138; /* external interrupt */
      do_stack_swap (sd);
    }
  else if (sd->pending_interrupt == NULL)
    /* interrupts masked and no interrupt pending */
    {
      sd->pending_interrupt = sim_events_schedule (sd, 1,
						   d30v_interrupt_event,
						   data);
    }
}

#endif
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d137 1
a137 1
	 /* If MU instruction was not a MVTSYS, resolve PSW
d139 1
a139 1
	  if(! STATE_CPU (sd, 0)->mvtsys_left_p)
a251 1
  STATE_CPU (sd, 0)->mvtsys_left_p = 0;
a269 1
  STATE_CPU (sd, 0)->mvtsys_left_p = 0;
a285 1
  STATE_CPU (sd, 0)->mvtsys_left_p = 0;
@


1.1.1.2.18.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d1 496
a496 496
/* OBSOLETE /*  This file is part of the program psim. */
/* OBSOLETE  */
/* OBSOLETE     Copyright (C) 1994-1997, Andrew Cagney <cagney@@highland.com.au> */
/* OBSOLETE     Copyright (C) 1996, 1997, Free Software Foundation */
/* OBSOLETE  */
/* OBSOLETE     This program is free software; you can redistribute it and/or modify */
/* OBSOLETE     it under the terms of the GNU General Public License as published by */
/* OBSOLETE     the Free Software Foundation; either version 2 of the License, or */
/* OBSOLETE     (at your option) any later version. */
/* OBSOLETE  */
/* OBSOLETE     This program is distributed in the hope that it will be useful, */
/* OBSOLETE     but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* OBSOLETE     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* OBSOLETE     GNU General Public License for more details. */
/* OBSOLETE   */
/* OBSOLETE     You should have received a copy of the GNU General Public License */
/* OBSOLETE     along with this program; if not, write to the Free Software */
/* OBSOLETE     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
/* OBSOLETE   */
/* OBSOLETE     */ */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE #ifndef ENGINE_C */
/* OBSOLETE #define ENGINE_C */
/* OBSOLETE  */
/* OBSOLETE #include "sim-main.h" */
/* OBSOLETE  */
/* OBSOLETE #include <stdio.h> */
/* OBSOLETE #include <ctype.h> */
/* OBSOLETE  */
/* OBSOLETE #ifdef HAVE_STDLIB_H */
/* OBSOLETE #include <stdlib.h> */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE #ifdef HAVE_STRING_H */
/* OBSOLETE #include <string.h> */
/* OBSOLETE #else */
/* OBSOLETE #ifdef HAVE_STRINGS_H */
/* OBSOLETE #include <strings.h> */
/* OBSOLETE #endif */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE static void */
/* OBSOLETE do_stack_swap (SIM_DESC sd) */
/* OBSOLETE { */
/* OBSOLETE   sim_cpu *cpu = STATE_CPU (sd, 0); */
/* OBSOLETE   unsigned new_sp = (PSW_VAL(PSW_SM) != 0); */
/* OBSOLETE   if (cpu->regs.current_sp != new_sp) */
/* OBSOLETE     { */
/* OBSOLETE       cpu->regs.sp[cpu->regs.current_sp] = SP; */
/* OBSOLETE       cpu->regs.current_sp = new_sp; */
/* OBSOLETE       SP = cpu->regs.sp[cpu->regs.current_sp]; */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE #if WITH_TRACE */
/* OBSOLETE /* Implement ALU tracing of 32-bit registers.  */ */
/* OBSOLETE static void */
/* OBSOLETE trace_alu32 (SIM_DESC sd, */
/* OBSOLETE 	     sim_cpu *cpu, */
/* OBSOLETE 	     address_word cia, */
/* OBSOLETE 	     unsigned32 *ptr) */
/* OBSOLETE { */
/* OBSOLETE   unsigned32 value = *ptr; */
/* OBSOLETE  */
/* OBSOLETE   if (ptr >= &GPR[0] && ptr <= &GPR[NR_GENERAL_PURPOSE_REGISTERS]) */
/* OBSOLETE     trace_one_insn (sd, cpu, cia, 1, "engine.c", __LINE__, "alu", */
/* OBSOLETE 		    "Set register r%-2d = 0x%.8lx (%ld)", */
/* OBSOLETE 		    ptr - &GPR[0], (long)value, (long)value); */
/* OBSOLETE  */
/* OBSOLETE   else if (ptr == &PSW || ptr == &bPSW || ptr == &DPSW) */
/* OBSOLETE     trace_one_insn (sd, cpu, cia, 1, "engine.c", __LINE__, "alu", */
/* OBSOLETE 		    "Set register %s = 0x%.8lx%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s", */
/* OBSOLETE 		    (ptr == &PSW) ? "psw" : ((ptr == &bPSW) ? "bpsw" : "dpsw"), */
/* OBSOLETE 		    (long)value, */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_SM)) ? ", sm" : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_EA)) ? ", ea" : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_DB)) ? ", db" : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_DS)) ? ", ds" : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_IE)) ? ", ie" : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_RP)) ? ", rp" : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_MD)) ? ", md" : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_F0)) ? ", f0" : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_F1)) ? ", f1" : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_F2)) ? ", f2" : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_F3)) ? ", f3" : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_S))  ? ", s"  : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_V))  ? ", v"  : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_VA)) ? ", va" : "", */
/* OBSOLETE 		    (value & (0x80000000 >> PSW_C))  ? ", c"  : ""); */
/* OBSOLETE  */
/* OBSOLETE   else if (ptr >= &CREG[0] && ptr <= &CREG[NR_CONTROL_REGISTERS]) */
/* OBSOLETE     trace_one_insn (sd, cpu, cia, 1, "engine.c", __LINE__, "alu", */
/* OBSOLETE 		    "Set register cr%d = 0x%.8lx (%ld)", */
/* OBSOLETE 		    ptr - &CREG[0], (long)value, (long)value); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE /* Implement ALU tracing of 32-bit registers.  */ */
/* OBSOLETE static void */
/* OBSOLETE trace_alu64 (SIM_DESC sd, */
/* OBSOLETE 	     sim_cpu *cpu, */
/* OBSOLETE 	     address_word cia, */
/* OBSOLETE 	     unsigned64 *ptr) */
/* OBSOLETE { */
/* OBSOLETE   unsigned64 value = *ptr; */
/* OBSOLETE  */
/* OBSOLETE   if (ptr >= &ACC[0] && ptr <= &ACC[NR_ACCUMULATORS]) */
/* OBSOLETE     trace_one_insn (sd, cpu, cia, 1, "engine.c", __LINE__, "alu", */
/* OBSOLETE 		    "Set register a%-2d = 0x%.8lx 0x%.8lx", */
/* OBSOLETE 		    ptr - &ACC[0], */
/* OBSOLETE 		    (unsigned long)(unsigned32)(value >> 32), */
/* OBSOLETE 		    (unsigned long)(unsigned32)value); */
/* OBSOLETE  */
/* OBSOLETE } */
/* OBSOLETE #endif */
/* OBSOLETE  */
/* OBSOLETE /* Process all of the queued up writes in order now */ */
/* OBSOLETE void */
/* OBSOLETE unqueue_writes (SIM_DESC sd, */
/* OBSOLETE 		sim_cpu *cpu, */
/* OBSOLETE 		address_word cia) */
/* OBSOLETE { */
/* OBSOLETE   int i, num; */
/* OBSOLETE   int did_psw = 0; */
/* OBSOLETE   unsigned32 *psw_addr = &PSW; */
/* OBSOLETE  */
/* OBSOLETE   num = WRITE32_NUM; */
/* OBSOLETE   for (i = 0; i < num; i++) */
/* OBSOLETE     { */
/* OBSOLETE       unsigned32 mask = WRITE32_MASK (i); */
/* OBSOLETE       unsigned32 *ptr = WRITE32_PTR (i); */
/* OBSOLETE       unsigned32 value = (*ptr & ~mask) | (WRITE32_VALUE (i) & mask); */
/* OBSOLETE       int j; */
/* OBSOLETE  */
/* OBSOLETE       if (ptr == psw_addr) */
/* OBSOLETE        { */
/* OBSOLETE 	 /* If MU instruction was not a MVTSYS, resolve PSW */
/* OBSOLETE              contention in favour of IU. */ */
/* OBSOLETE 	  if(! STATE_CPU (sd, 0)->mvtsys_left_p) */
/* OBSOLETE 	    { */
/* OBSOLETE 	      /* Detect contention in parallel writes to the same PSW flags. */
/* OBSOLETE 		 The hardware allows the updates from IU to prevail over */
/* OBSOLETE 		 those from MU. */ */
/* OBSOLETE 	       */
/* OBSOLETE 	      unsigned32 flag_bits = */
/* OBSOLETE 		BIT32 (PSW_F0) | BIT32 (PSW_F1) | */
/* OBSOLETE 		BIT32 (PSW_F2) | BIT32 (PSW_F3) | */
/* OBSOLETE 		BIT32 (PSW_S) | BIT32 (PSW_V) | */
/* OBSOLETE 		BIT32 (PSW_VA) | BIT32 (PSW_C); */
/* OBSOLETE 	      unsigned32 my_flag_bits = mask & flag_bits; */
/* OBSOLETE 	       */
/* OBSOLETE 	      for (j = i + 1; j < num; j++) */
/* OBSOLETE 		if (WRITE32_PTR (j) == psw_addr && /* write to PSW */ */
/* OBSOLETE 		    WRITE32_MASK (j) & my_flag_bits)  /* some of the same flags */ */
/* OBSOLETE 		  { */
/* OBSOLETE 		    /* Recompute local mask & value, to suppress this */
/* OBSOLETE 		       earlier write to the same flag bits. */ */
/* OBSOLETE 		     */
/* OBSOLETE 		    unsigned32 new_mask = mask & ~(WRITE32_MASK (j) & my_flag_bits); */
/* OBSOLETE 		     */
/* OBSOLETE 		    /* There is a special case for the VA (accumulated */
/* OBSOLETE 		       overflow) flag, in that it is only included in the */
/* OBSOLETE 		       second instruction's mask if the overflow */
/* OBSOLETE 		       occurred.  Yet the hardware still suppresses the */
/* OBSOLETE 		       first instruction's update to VA.  So we kludge */
/* OBSOLETE 		       this by inferring PSW_V -> PSW_VA for the second */
/* OBSOLETE 		       instruction. */ */
/* OBSOLETE 		     */
/* OBSOLETE 		    if (WRITE32_MASK (j) & BIT32 (PSW_V)) */
/* OBSOLETE 		      { */
/* OBSOLETE 			new_mask &= ~BIT32 (PSW_VA); */
/* OBSOLETE 		      } */
/* OBSOLETE 		     */
/* OBSOLETE 		    value = (*ptr & ~new_mask) | (WRITE32_VALUE (i) & new_mask); */
/* OBSOLETE 		  } */
/* OBSOLETE 	    } */
/* OBSOLETE 	   */
/* OBSOLETE          did_psw = 1; */
/* OBSOLETE        } */
/* OBSOLETE  */
/* OBSOLETE       *ptr = value; */
/* OBSOLETE  */
/* OBSOLETE #if WITH_TRACE */
/* OBSOLETE       if (TRACE_ALU_P (cpu)) */
/* OBSOLETE 	trace_alu32 (sd, cpu, cia, ptr); */
/* OBSOLETE #endif */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   num = WRITE64_NUM; */
/* OBSOLETE   for (i = 0; i < num; i++) */
/* OBSOLETE     { */
/* OBSOLETE       unsigned64 *ptr = WRITE64_PTR (i); */
/* OBSOLETE       *ptr = WRITE64_VALUE (i); */
/* OBSOLETE  */
/* OBSOLETE #if WITH_TRACE */
/* OBSOLETE       if (TRACE_ALU_P (cpu)) */
/* OBSOLETE 	trace_alu64 (sd, cpu, cia, ptr); */
/* OBSOLETE #endif */
/* OBSOLETE     } */
/* OBSOLETE  */
/* OBSOLETE   WRITE32_NUM = 0; */
/* OBSOLETE   WRITE64_NUM = 0; */
/* OBSOLETE  */
/* OBSOLETE   if (DID_TRAP == 1) /* ordinary trap */ */
/* OBSOLETE     { */
/* OBSOLETE       bPSW = PSW; */
/* OBSOLETE       PSW &= (BIT32 (PSW_DB) | BIT32 (PSW_SM)); */
/* OBSOLETE       did_psw = 1; */
/* OBSOLETE     } */
/* OBSOLETE   else if (DID_TRAP == 2) /* debug trap */ */
/* OBSOLETE     { */
/* OBSOLETE       DPSW = PSW; */
/* OBSOLETE       PSW &= BIT32 (PSW_DS); */
/* OBSOLETE       PSW |= BIT32 (PSW_DS); */
/* OBSOLETE       did_psw = 1; */
/* OBSOLETE     } */
/* OBSOLETE   DID_TRAP = 0; */
/* OBSOLETE  */
/* OBSOLETE   if (did_psw) */
/* OBSOLETE     do_stack_swap (sd); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* SIMULATE INSTRUCTIONS, various different ways of achieving the same */
/* OBSOLETE    thing */ */
/* OBSOLETE  */
/* OBSOLETE static address_word */
/* OBSOLETE do_long (SIM_DESC sd, */
/* OBSOLETE 	 l_instruction_word instruction, */
/* OBSOLETE 	 address_word cia) */
/* OBSOLETE { */
/* OBSOLETE   address_word nia = l_idecode_issue(sd, */
/* OBSOLETE 				     instruction, */
/* OBSOLETE 				     cia); */
/* OBSOLETE  */
/* OBSOLETE   unqueue_writes (sd, STATE_CPU (sd, 0), cia); */
/* OBSOLETE   return nia; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static address_word */
/* OBSOLETE do_2_short (SIM_DESC sd, */
/* OBSOLETE 	    s_instruction_word insn1, */
/* OBSOLETE 	    s_instruction_word insn2, */
/* OBSOLETE 	    cpu_units unit, */
/* OBSOLETE 	    address_word cia) */
/* OBSOLETE { */
/* OBSOLETE   address_word nia; */
/* OBSOLETE  */
/* OBSOLETE   /* run the first instruction */ */
/* OBSOLETE   STATE_CPU (sd, 0)->unit = unit; */
/* OBSOLETE   STATE_CPU (sd, 0)->left_kills_right_p = 0; */
/* OBSOLETE   STATE_CPU (sd, 0)->mvtsys_left_p = 0; */
/* OBSOLETE   nia = s_idecode_issue(sd, */
/* OBSOLETE 			insn1, */
/* OBSOLETE 			cia); */
/* OBSOLETE  */
/* OBSOLETE   unqueue_writes (sd, STATE_CPU (sd, 0), cia); */
/* OBSOLETE  */
/* OBSOLETE   /* Only do the second instruction if the PC has not changed */ */
/* OBSOLETE   if ((nia == INVALID_INSTRUCTION_ADDRESS) && */
/* OBSOLETE       (! STATE_CPU (sd, 0)->left_kills_right_p)) { */
/* OBSOLETE     STATE_CPU (sd, 0)->unit = any_unit; */
/* OBSOLETE     nia = s_idecode_issue (sd, */
/* OBSOLETE 			   insn2, */
/* OBSOLETE 			   cia); */
/* OBSOLETE  */
/* OBSOLETE     unqueue_writes (sd, STATE_CPU (sd, 0), cia); */
/* OBSOLETE   } */
/* OBSOLETE  */
/* OBSOLETE   STATE_CPU (sd, 0)->left_kills_right_p = 0; */
/* OBSOLETE   STATE_CPU (sd, 0)->mvtsys_left_p = 0; */
/* OBSOLETE   return nia; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE static address_word */
/* OBSOLETE do_parallel (SIM_DESC sd, */
/* OBSOLETE 	     s_instruction_word left_insn, */
/* OBSOLETE 	     s_instruction_word right_insn, */
/* OBSOLETE 	     address_word cia) */
/* OBSOLETE { */
/* OBSOLETE   address_word nia_left; */
/* OBSOLETE   address_word nia_right; */
/* OBSOLETE   address_word nia; */
/* OBSOLETE  */
/* OBSOLETE   /* run the first instruction */ */
/* OBSOLETE   STATE_CPU (sd, 0)->unit = memory_unit; */
/* OBSOLETE   STATE_CPU (sd, 0)->left_kills_right_p = 0; */
/* OBSOLETE   STATE_CPU (sd, 0)->mvtsys_left_p = 0; */
/* OBSOLETE   nia_left = s_idecode_issue(sd, */
/* OBSOLETE 			     left_insn, */
/* OBSOLETE 			     cia); */
/* OBSOLETE  */
/* OBSOLETE   /* run the second instruction */ */
/* OBSOLETE   STATE_CPU (sd, 0)->unit = integer_unit; */
/* OBSOLETE   nia_right = s_idecode_issue(sd, */
/* OBSOLETE 			      right_insn, */
/* OBSOLETE 			      cia); */
/* OBSOLETE  */
/* OBSOLETE   /* merge the PC's */ */
/* OBSOLETE   if (nia_left == INVALID_INSTRUCTION_ADDRESS) { */
/* OBSOLETE     if (nia_right == INVALID_INSTRUCTION_ADDRESS) */
/* OBSOLETE       nia = INVALID_INSTRUCTION_ADDRESS; */
/* OBSOLETE     else */
/* OBSOLETE       nia = nia_right; */
/* OBSOLETE   } */
/* OBSOLETE   else { */
/* OBSOLETE     if (nia_right == INVALID_INSTRUCTION_ADDRESS) */
/* OBSOLETE       nia = nia_left; */
/* OBSOLETE     else { */
/* OBSOLETE       sim_engine_abort (sd, STATE_CPU (sd, 0), cia, "parallel jumps"); */
/* OBSOLETE       nia = INVALID_INSTRUCTION_ADDRESS; */
/* OBSOLETE     } */
/* OBSOLETE   } */
/* OBSOLETE  */
/* OBSOLETE   unqueue_writes (sd, STATE_CPU (sd, 0), cia); */
/* OBSOLETE   return nia; */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE typedef enum { */
/* OBSOLETE   p_insn = 0, */
/* OBSOLETE   long_insn = 3, */
/* OBSOLETE   l_r_insn = 1, */
/* OBSOLETE   r_l_insn = 2, */
/* OBSOLETE } instruction_types; */
/* OBSOLETE  */
/* OBSOLETE STATIC_INLINE instruction_types */
/* OBSOLETE instruction_type(l_instruction_word insn) */
/* OBSOLETE { */
/* OBSOLETE   int fm0 = MASKED64(insn, 0, 0) != 0; */
/* OBSOLETE   int fm1 = MASKED64(insn, 32, 32) != 0; */
/* OBSOLETE   return ((fm0 << 1) | fm1); */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE sim_engine_run (SIM_DESC sd, */
/* OBSOLETE 		int last_cpu_nr, */
/* OBSOLETE 		int nr_cpus, */
/* OBSOLETE 		int siggnal) */
/* OBSOLETE { */
/* OBSOLETE   while (1) */
/* OBSOLETE     { */
/* OBSOLETE       address_word cia = PC; */
/* OBSOLETE       address_word nia; */
/* OBSOLETE       l_instruction_word insn = IMEM(cia); */
/* OBSOLETE       int rp_was_set; */
/* OBSOLETE       int rpt_c_was_nonzero; */
/* OBSOLETE  */
/* OBSOLETE       /* Before executing the instruction, we need to test whether or */
/* OBSOLETE 	 not RPT_C is greater than zero, and save that state for use */
/* OBSOLETE 	 after executing the instruction.  In particular, we need to */
/* OBSOLETE 	 not care whether the instruction changes RPT_C itself. */ */
/* OBSOLETE  */
/* OBSOLETE       rpt_c_was_nonzero = (RPT_C > 0); */
/* OBSOLETE  */
/* OBSOLETE       /* Before executing the instruction, we need to check to see if */
/* OBSOLETE 	 we have to decrement RPT_C, the repeat count register.  Do this */
/* OBSOLETE 	 if PC == RPT_E, but only if we are in an active repeat block. */ */
/* OBSOLETE  */
/* OBSOLETE       if (PC == RPT_E && */
/* OBSOLETE 	  (RPT_C > 0 || PSW_VAL (PSW_RP) != 0)) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  RPT_C --; */
/* OBSOLETE 	} */
/* OBSOLETE        */
/* OBSOLETE       /* Now execute the instruction at PC */ */
/* OBSOLETE  */
/* OBSOLETE       switch (instruction_type (insn)) */
/* OBSOLETE 	{ */
/* OBSOLETE 	case long_insn: */
/* OBSOLETE 	  nia = do_long (sd, insn, cia); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case r_l_insn: */
/* OBSOLETE 	  /* L <- R */ */
/* OBSOLETE 	  nia = do_2_short (sd, insn, insn >> 32, integer_unit, cia); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case l_r_insn: */
/* OBSOLETE 	  /* L -> R */ */
/* OBSOLETE 	  nia = do_2_short (sd, insn >> 32, insn, memory_unit, cia); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	case p_insn: */
/* OBSOLETE 	  nia = do_parallel (sd, insn >> 32, insn, cia); */
/* OBSOLETE 	  break; */
/* OBSOLETE 	default: */
/* OBSOLETE 	  sim_engine_abort (sd, STATE_CPU (sd, 0), cia, */
/* OBSOLETE 			    "internal error - engine_run_until_stop - bad switch"); */
/* OBSOLETE 	  nia = -1; */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       if (TRACE_ACTION) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  if (TRACE_ACTION & TRACE_ACTION_CALL) */
/* OBSOLETE 	    call_occurred (sd, STATE_CPU (sd, 0), cia, nia); */
/* OBSOLETE  */
/* OBSOLETE 	  if (TRACE_ACTION & TRACE_ACTION_RETURN) */
/* OBSOLETE 	    return_occurred (sd, STATE_CPU (sd, 0), cia, nia); */
/* OBSOLETE  */
/* OBSOLETE 	  TRACE_ACTION = 0; */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       /* Check now to see if we need to reset the RP bit in the PSW. */
/* OBSOLETE 	 There are three conditions for this, the RP bit is already */
/* OBSOLETE 	 set (just a speed optimization), the instruction we just */
/* OBSOLETE 	 executed is the last instruction in the loop, and the repeat */
/* OBSOLETE 	 count is currently zero. */ */
/* OBSOLETE  */
/* OBSOLETE       rp_was_set = PSW_VAL (PSW_RP); */
/* OBSOLETE       if (rp_was_set && (PC == RPT_E) && RPT_C == 0) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  PSW_SET (PSW_RP, 0); */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       /* Now update the PC.  If we just executed a jump instruction, */
/* OBSOLETE 	 that takes precedence over everything else.  Next comes */
/* OBSOLETE 	 branching back to RPT_S as a result of a loop.  Finally, the */
/* OBSOLETE 	 default is to simply advance to the next inline */
/* OBSOLETE 	 instruction. */ */
/* OBSOLETE  */
/* OBSOLETE       if (nia != INVALID_INSTRUCTION_ADDRESS) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  PC = nia; */
/* OBSOLETE 	} */
/* OBSOLETE       else if (rp_was_set && rpt_c_was_nonzero && (PC == RPT_E)) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  PC = RPT_S; */
/* OBSOLETE 	} */
/* OBSOLETE       else */
/* OBSOLETE 	{ */
/* OBSOLETE 	  PC = cia + 8; */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       /* Check for DDBT (debugger debug trap) condition.  Do this after */
/* OBSOLETE 	 the repeat block checks so the excursion to the trap handler does */
/* OBSOLETE 	 not alter looping state. */ */
/* OBSOLETE  */
/* OBSOLETE       if (cia == IBA && PSW_VAL (PSW_DB)) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  DPC = PC; */
/* OBSOLETE 	  PSW_SET (PSW_EA, 1); */
/* OBSOLETE 	  DPSW = PSW; */
/* OBSOLETE 	  /* clear all bits in PSW except SM */ */
/* OBSOLETE 	  PSW &= BIT32 (PSW_SM); */
/* OBSOLETE 	  /* add DS bit */ */
/* OBSOLETE 	  PSW |= BIT32 (PSW_DS); */
/* OBSOLETE 	  /* dispatch to DDBT handler */ */
/* OBSOLETE 	  PC = 0xfffff128; /* debugger_debug_trap_address */ */
/* OBSOLETE 	} */
/* OBSOLETE  */
/* OBSOLETE       /* process any events */ */
/* OBSOLETE       /* FIXME - should L->R or L<-R insns count as two cycles? */ */
/* OBSOLETE       if (sim_events_tick (sd)) */
/* OBSOLETE 	{ */
/* OBSOLETE 	  sim_events_process (sd); */
/* OBSOLETE 	} */
/* OBSOLETE     }   */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE  */
/* OBSOLETE /* d30v external interrupt handler. */
/* OBSOLETE  */
/* OBSOLETE    Note: This should be replaced by a proper interrupt delivery */
/* OBSOLETE    mechanism.  This interrupt mechanism discards later interrupts if */
/* OBSOLETE    an earlier interrupt hasn't been delivered. */
/* OBSOLETE  */
/* OBSOLETE    Note: This interrupt mechanism does not reset its self when the */
/* OBSOLETE    simulator is re-opened. */ */
/* OBSOLETE  */
/* OBSOLETE void */
/* OBSOLETE d30v_interrupt_event (SIM_DESC sd, */
/* OBSOLETE 		      void *data) */
/* OBSOLETE { */
/* OBSOLETE   if (PSW_VAL (PSW_IE)) */
/* OBSOLETE     /* interrupts not masked */ */
/* OBSOLETE     { */
/* OBSOLETE       /* scrub any pending interrupt */ */
/* OBSOLETE       if (sd->pending_interrupt != NULL) */
/* OBSOLETE 	sim_events_deschedule (sd, sd->pending_interrupt); */
/* OBSOLETE       /* deliver */ */
/* OBSOLETE       bPSW = PSW; */
/* OBSOLETE       bPC = PC; */
/* OBSOLETE       PSW = 0; */
/* OBSOLETE       PC = 0xfffff138; /* external interrupt */ */
/* OBSOLETE       do_stack_swap (sd); */
/* OBSOLETE     } */
/* OBSOLETE   else if (sd->pending_interrupt == NULL) */
/* OBSOLETE     /* interrupts masked and no interrupt pending */ */
/* OBSOLETE     { */
/* OBSOLETE       sd->pending_interrupt = sim_events_schedule (sd, 1, */
/* OBSOLETE 						   d30v_interrupt_event, */
/* OBSOLETE 						   data); */
/* OBSOLETE     } */
/* OBSOLETE } */
/* OBSOLETE  */
/* OBSOLETE #endif */
@


