head	1.26;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.26
	gdb_7_6-2013-04-26-release:1.26
	gdb_7_6-branch:1.26.0.2
	gdb_7_6-2013-03-12-branchpoint:1.26
	gdb_7_5_1-2012-11-29-release:1.25
	gdb_7_5-2012-08-17-release:1.25
	gdb_7_5-branch:1.25.0.2
	gdb_7_5-2012-07-18-branchpoint:1.25
	gdb_7_4_1-2012-04-26-release:1.24.2.1
	gdb_7_4-2012-01-24-release:1.24.2.1
	gdb_7_4-branch:1.24.0.2
	gdb_7_4-2011-12-13-branchpoint:1.24
	gdb_7_3_1-2011-09-04-release:1.23
	gdb_7_3-2011-07-26-release:1.23
	gdb_7_3-branch:1.23.0.2
	gdb_7_3-2011-04-01-branchpoint:1.23
	gdb_7_2-2010-09-02-release:1.22
	gdb_7_2-branch:1.22.0.4
	gdb_7_2-2010-07-07-branchpoint:1.22
	gdb_7_1-2010-03-18-release:1.22
	gdb_7_1-branch:1.22.0.2
	gdb_7_1-2010-02-18-branchpoint:1.22
	gdb_7_0_1-2009-12-22-release:1.21
	gdb_7_0-2009-10-06-release:1.21
	gdb_7_0-branch:1.21.0.4
	gdb_7_0-2009-09-16-branchpoint:1.21
	arc-sim-20090309:1.20
	msnyder-checkpoint-072509-branch:1.21.0.2
	msnyder-checkpoint-072509-branchpoint:1.21
	arc-insight_6_8-branch:1.20.0.16
	arc-insight_6_8-branchpoint:1.20
	insight_6_8-branch:1.20.0.14
	insight_6_8-branchpoint:1.20
	reverse-20081226-branch:1.20.0.12
	reverse-20081226-branchpoint:1.20
	multiprocess-20081120-branch:1.20.0.10
	multiprocess-20081120-branchpoint:1.20
	reverse-20080930-branch:1.20.0.8
	reverse-20080930-branchpoint:1.20
	reverse-20080717-branch:1.20.0.6
	reverse-20080717-branchpoint:1.20
	msnyder-reverse-20080609-branch:1.20.0.4
	msnyder-reverse-20080609-branchpoint:1.20
	drow-reverse-20070409-branch:1.18.0.2
	drow-reverse-20070409-branchpoint:1.18
	gdb_6_8-2008-03-27-release:1.20
	gdb_6_8-branch:1.20.0.2
	gdb_6_8-2008-02-26-branchpoint:1.20
	gdb_6_7_1-2007-10-29-release:1.19
	gdb_6_7-2007-10-10-release:1.19
	gdb_6_7-branch:1.19.0.2
	gdb_6_7-2007-09-07-branchpoint:1.19
	insight_6_6-20070208-release:1.17
	gdb_6_6-2006-12-18-release:1.17
	gdb_6_6-branch:1.17.0.36
	gdb_6_6-2006-11-15-branchpoint:1.17
	insight_6_5-20061003-release:1.17
	gdb-csl-symbian-6_4_50_20060226-12:1.17
	gdb-csl-sourcerygxx-3_4_4-25:1.17
	nickrob-async-20060828-mergepoint:1.17
	gdb-csl-symbian-6_4_50_20060226-11:1.17
	gdb-csl-sourcerygxx-4_1-17:1.17
	gdb-csl-20060226-branch-local-2:1.17
	gdb-csl-sourcerygxx-4_1-14:1.17
	gdb-csl-sourcerygxx-4_1-13:1.17
	gdb-csl-sourcerygxx-4_1-12:1.17
	gdb-csl-sourcerygxx-3_4_4-21:1.17
	gdb_6_5-20060621-release:1.17
	gdb-csl-sourcerygxx-4_1-9:1.17
	gdb-csl-sourcerygxx-4_1-8:1.17
	gdb-csl-sourcerygxx-4_1-7:1.17
	gdb-csl-arm-2006q1-6:1.17
	gdb-csl-sourcerygxx-4_1-6:1.17
	gdb-csl-symbian-6_4_50_20060226-10:1.17
	gdb-csl-symbian-6_4_50_20060226-9:1.17
	gdb-csl-symbian-6_4_50_20060226-8:1.17
	gdb-csl-coldfire-4_1-11:1.17
	gdb-csl-sourcerygxx-3_4_4-19:1.17
	gdb-csl-coldfire-4_1-10:1.17
	gdb_6_5-branch:1.17.0.34
	gdb_6_5-2006-05-14-branchpoint:1.17
	gdb-csl-sourcerygxx-4_1-5:1.17
	nickrob-async-20060513-branch:1.17.0.32
	nickrob-async-20060513-branchpoint:1.17
	gdb-csl-sourcerygxx-4_1-4:1.17
	msnyder-reverse-20060502-branch:1.17.0.30
	msnyder-reverse-20060502-branchpoint:1.17
	gdb-csl-morpho-4_1-4:1.17
	gdb-csl-sourcerygxx-3_4_4-17:1.17
	readline_5_1-import-branch:1.17.0.28
	readline_5_1-import-branchpoint:1.17
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.17
	gdb-csl-symbian-20060226-branch:1.17.0.26
	gdb-csl-symbian-20060226-branchpoint:1.17
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.17
	msnyder-reverse-20060331-branch:1.17.0.24
	msnyder-reverse-20060331-branchpoint:1.17
	gdb-csl-available-20060303-branch:1.17.0.22
	gdb-csl-available-20060303-branchpoint:1.17
	gdb-csl-20060226-branch:1.17.0.20
	gdb-csl-20060226-branchpoint:1.17
	gdb_6_4-20051202-release:1.17
	msnyder-fork-checkpoint-branch:1.17.0.18
	msnyder-fork-checkpoint-branchpoint:1.17
	gdb-csl-gxxpro-6_3-branch:1.17.0.16
	gdb-csl-gxxpro-6_3-branchpoint:1.17
	gdb_6_4-branch:1.17.0.14
	gdb_6_4-2005-11-01-branchpoint:1.17
	gdb-csl-arm-20051020-branch:1.17.0.12
	gdb-csl-arm-20051020-branchpoint:1.17
	msnyder-tracepoint-checkpoint-branch:1.17.0.10
	msnyder-tracepoint-checkpoint-branchpoint:1.17
	gdb-csl-arm-20050325-2005-q1b:1.17
	gdb-csl-arm-20050325-2005-q1a:1.17
	csl-arm-20050325-branch:1.17.0.8
	csl-arm-20050325-branchpoint:1.17
	gdb_6_3-20041109-release:1.17
	gdb_6_3-branch:1.17.0.4
	gdb_6_3-20041019-branchpoint:1.17
	drow_intercu-merge-20040921:1.17
	drow_intercu-merge-20040915:1.17
	jimb-gdb_6_2-e500-branch:1.17.0.6
	jimb-gdb_6_2-e500-branchpoint:1.17
	gdb_6_2-20040730-release:1.17
	gdb_6_2-branch:1.17.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.17
	gdb_6_1_1-20040616-release:1.16
	gdb_6_1-2004-04-05-release:1.16
	drow_intercu-merge-20040402:1.16
	drow_intercu-merge-20040327:1.16
	ezannoni_pie-20040323-branch:1.16.0.18
	ezannoni_pie-20040323-branchpoint:1.16
	cagney_tramp-20040321-mergepoint:1.16
	cagney_tramp-20040309-branch:1.16.0.16
	cagney_tramp-20040309-branchpoint:1.16
	gdb_6_1-branch:1.16.0.14
	gdb_6_1-2004-03-01-gmt-branchpoint:1.16
	drow_intercu-20040221-branch:1.16.0.12
	drow_intercu-20040221-branchpoint:1.16
	cagney_bfdfile-20040213-branch:1.16.0.10
	cagney_bfdfile-20040213-branchpoint:1.16
	drow-cplus-merge-20040208:1.16
	carlton_dictionary-20040126-merge:1.16
	cagney_bigcore-20040122-branch:1.16.0.8
	cagney_bigcore-20040122-branchpoint:1.16
	drow-cplus-merge-20040113:1.16
	drow-cplus-merge-20031224:1.16
	drow-cplus-merge-20031220:1.16
	carlton_dictionary-20031215-merge:1.16
	drow-cplus-merge-20031214:1.16
	carlton-dictionary-20031111-merge:1.16
	gdb_6_0-2003-10-04-release:1.15.30.1
	kettenis_sparc-20030918-branch:1.16.0.6
	kettenis_sparc-20030918-branchpoint:1.16
	carlton_dictionary-20030917-merge:1.16
	ezannoni_pie-20030916-branchpoint:1.16
	ezannoni_pie-20030916-branch:1.16.0.4
	cagney_x86i386-20030821-branch:1.16.0.2
	cagney_x86i386-20030821-branchpoint:1.16
	carlton_dictionary-20030805-merge:1.15
	carlton_dictionary-20030627-merge:1.15
	gdb_6_0-branch:1.15.0.30
	gdb_6_0-2003-06-23-branchpoint:1.15
	jimb-ppc64-linux-20030613-branch:1.15.0.28
	jimb-ppc64-linux-20030613-branchpoint:1.15
	cagney_convert-20030606-branch:1.15.0.26
	cagney_convert-20030606-branchpoint:1.15
	cagney_writestrings-20030508-branch:1.15.0.24
	cagney_writestrings-20030508-branchpoint:1.15
	jimb-ppc64-linux-20030528-branch:1.15.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.15
	carlton_dictionary-20030523-merge:1.15
	cagney_fileio-20030521-branch:1.15.0.20
	cagney_fileio-20030521-branchpoint:1.15
	kettenis_i386newframe-20030517-mergepoint:1.15
	jimb-ppc64-linux-20030509-branch:1.15.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.15
	kettenis_i386newframe-20030504-mergepoint:1.15
	carlton_dictionary-20030430-merge:1.15
	kettenis_i386newframe-20030419-branch:1.15.0.16
	kettenis_i386newframe-20030419-branchpoint:1.15
	carlton_dictionary-20030416-merge:1.15
	cagney_frameaddr-20030409-mergepoint:1.15
	kettenis_i386newframe-20030406-branch:1.15.0.14
	kettenis_i386newframe-20030406-branchpoint:1.15
	cagney_frameaddr-20030403-branchpoint:1.15
	cagney_frameaddr-20030403-branch:1.15.0.12
	cagney_framebase-20030330-mergepoint:1.15
	cagney_framebase-20030326-branch:1.15.0.10
	cagney_framebase-20030326-branchpoint:1.15
	cagney_lazyid-20030317-branch:1.15.0.8
	cagney_lazyid-20030317-branchpoint:1.15
	kettenis-i386newframe-20030316-mergepoint:1.15
	offbyone-20030313-branch:1.15.0.6
	offbyone-20030313-branchpoint:1.15
	kettenis-i386newframe-20030308-branch:1.15.0.4
	kettenis-i386newframe-20030308-branchpoint:1.15
	carlton_dictionary-20030305-merge:1.15
	cagney_offbyone-20030303-branch:1.15.0.2
	cagney_offbyone-20030303-branchpoint:1.15
	carlton_dictionary-20030207-merge:1.13
	interps-20030202-branch:1.13.0.14
	interps-20030202-branchpoint:1.13
	cagney-unwind-20030108-branch:1.13.0.12
	cagney-unwind-20030108-branchpoint:1.13
	carlton_dictionary-20021223-merge:1.13
	gdb_5_3-2002-12-12-release:1.13
	carlton_dictionary-20021115-merge:1.13
	kseitz_interps-20021105-merge:1.13
	kseitz_interps-20021103-merge:1.13
	drow-cplus-merge-20021020:1.13
	drow-cplus-merge-20021025:1.13
	carlton_dictionary-20021025-merge:1.13
	carlton_dictionary-20021011-merge:1.13
	drow-cplus-branch:1.13.0.10
	drow-cplus-branchpoint:1.13
	kseitz_interps-20020930-merge:1.13
	carlton_dictionary-20020927-merge:1.13
	carlton_dictionary-branch:1.13.0.8
	carlton_dictionary-20020920-branchpoint:1.13
	gdb_5_3-branch:1.13.0.6
	gdb_5_3-2002-09-04-branchpoint:1.13
	kseitz_interps-20020829-merge:1.13
	cagney_sysregs-20020825-branch:1.13.0.4
	cagney_sysregs-20020825-branchpoint:1.13
	readline_4_3-import-branch:1.13.0.2
	readline_4_3-import-branchpoint:1.13
	gdb_5_2_1-2002-07-23-release:1.5.8.3
	kseitz_interps-20020528-branch:1.8.0.6
	kseitz_interps-20020528-branchpoint:1.8
	cagney_regbuf-20020515-branch:1.8.0.4
	cagney_regbuf-20020515-branchpoint:1.8
	jimb-macro-020506-branch:1.8.0.2
	jimb-macro-020506-branchpoint:1.8
	gdb_5_2-2002-04-29-release:1.5.8.3
	gdb_5_2-branch:1.5.0.8
	gdb_5_2-2002-03-03-branchpoint:1.5
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.4
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.2
	gdb_5_1-2001-07-29-branchpoint:1.5
	insight-precleanup-2001-01-01:1.3;
locks; strict;
comment	@ * @;


1.26
date	2013.01.01.06.41.38;	author brobecke;	state Exp;
branches;
next	1.25;

1.25
date	2012.01.04.08.28.14;	author brobecke;	state Exp;
branches;
next	1.24;

1.24
date	2011.07.05.19.06.37;	author vapier;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2011.01.01.15.34.02;	author brobecke;	state Exp;
branches;
next	1.22;

1.22
date	2010.01.01.10.03.31;	author brobecke;	state Exp;
branches;
next	1.21;

1.21
date	2009.01.14.10.53.08;	author brobecke;	state Exp;
branches;
next	1.20;

1.20
date	2008.01.01.22.53.25;	author drow;	state Exp;
branches;
next	1.19;

1.19
date	2007.08.24.14.28.37;	author brobecke;	state Exp;
branches;
next	1.18;

1.18
date	2007.01.09.17.59.18;	author drow;	state Exp;
branches;
next	1.17;

1.17
date	2004.06.15.01.08.34;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.08.20.42.21;	author ciceron;	state Exp;
branches
	1.16.12.1;
next	1.15;

1.15
date	2003.03.01.16.00.09;	author ciceron;	state Exp;
branches
	1.15.30.1;
next	1.14;

1.14
date	2003.02.27.23.26.34;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2002.08.13.08.52.02;	author ciceron;	state Exp;
branches
	1.13.8.1
	1.13.10.1;
next	1.12;

1.12
date	2002.08.13.08.47.18;	author ciceron;	state Exp;
branches;
next	1.11;

1.11
date	2002.08.13.08.38.09;	author ciceron;	state Exp;
branches;
next	1.10;

1.10
date	2002.08.13.08.10.45;	author ciceron;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.13.07.46.09;	author ciceron;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.07.19.17.04;	author ciceron;	state Exp;
branches
	1.8.6.1;
next	1.7;

1.7
date	2002.03.07.19.12.44;	author ciceron;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.07.19.06.34;	author ciceron;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.22.12.33.58;	author ciceron;	state Exp;
branches
	1.5.8.1;
next	1.4;

1.4
date	2001.05.20.15.40.27;	author ciceron;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.10.14.05.29;	author ciceron;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.11.18.44.59;	author ciceron;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.27.11.23.39;	author cagney;	state Exp;
branches;
next	;

1.24.2.1
date	2012.01.06.04.54.53;	author brobecke;	state Exp;
branches;
next	;

1.16.12.1
date	2004.09.16.17.02.11;	author drow;	state Exp;
branches;
next	;

1.15.30.1
date	2003.08.08.20.45.31;	author ciceron;	state Exp;
branches;
next	;

1.13.8.1
date	2003.03.06.00.56.41;	author carlton;	state Exp;
branches;
next	1.13.8.2;

1.13.8.2
date	2003.09.17.21.29.03;	author carlton;	state Exp;
branches;
next	;

1.13.10.1
date	2003.12.14.20.28.27;	author drow;	state Exp;
branches;
next	;

1.8.6.1
date	2002.08.30.22.52.58;	author kseitz;	state Exp;
branches;
next	;

1.5.8.1
date	2002.03.07.19.07.13;	author ciceron;	state Exp;
branches;
next	1.5.8.2;

1.5.8.2
date	2002.03.07.19.14.07;	author ciceron;	state Exp;
branches;
next	1.5.8.3;

1.5.8.3
date	2002.03.07.19.18.40;	author ciceron;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* interp.c -- Simulator for Motorola 68HC11/68HC12
   Copyright (C) 1999-2013 Free Software Foundation, Inc.
   Written by Stephane Carrez (stcarrez@@nerim.fr)

This file is part of GDB, the GNU debugger.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "sim-main.h"
#include "sim-assert.h"
#include "sim-hw.h"
#include "sim-options.h"
#include "hw-tree.h"
#include "hw-device.h"
#include "hw-ports.h"
#include "elf32-m68hc1x.h"

#ifndef MONITOR_BASE
# define MONITOR_BASE (0x0C000)
# define MONITOR_SIZE (0x04000)
#endif

static void sim_get_info (SIM_DESC sd, char *cmd);


char *interrupt_names[] = {
  "reset",
  "nmi",
  "int",
  NULL
};

#ifndef INLINE
#if defined(__GNUC__) && defined(__OPTIMIZE__)
#define INLINE __inline__
#else
#define INLINE
#endif
#endif

struct sim_info_list
{
  const char *name;
  const char *device;
};

struct sim_info_list dev_list_68hc11[] = {
  {"cpu", "/m68hc11"},
  {"timer", "/m68hc11/m68hc11tim"},
  {"sio", "/m68hc11/m68hc11sio"},
  {"spi", "/m68hc11/m68hc11spi"},
  {"eeprom", "/m68hc11/m68hc11eepr"},
  {0, 0}
};

struct sim_info_list dev_list_68hc12[] = {
  {"cpu", "/m68hc12"},
  {"timer", "/m68hc12/m68hc12tim"},
  {"sio", "/m68hc12/m68hc12sio"},
  {"spi", "/m68hc12/m68hc12spi"},
  {"eeprom", "/m68hc12/m68hc12eepr"},
  {0, 0}
};

/* Cover function of sim_state_free to free the cpu buffers as well.  */

static void
free_state (SIM_DESC sd)
{
  if (STATE_MODULES (sd) != NULL)
    sim_module_uninstall (sd);

  sim_state_free (sd);
}

/* Give some information about the simulator.  */
static void
sim_get_info (SIM_DESC sd, char *cmd)
{
  sim_cpu *cpu;

  cpu = STATE_CPU (sd, 0);
  if (cmd != 0 && (cmd[0] == ' ' || cmd[0] == '-'))
    {
      int i;
      struct hw *hw_dev;
      struct sim_info_list *dev_list;
      const struct bfd_arch_info *arch;

      arch = STATE_ARCHITECTURE (sd);
      cmd++;

      if (arch->arch == bfd_arch_m68hc11)
        dev_list = dev_list_68hc11;
      else
        dev_list = dev_list_68hc12;

      for (i = 0; dev_list[i].name; i++)
	if (strcmp (cmd, dev_list[i].name) == 0)
	  break;

      if (dev_list[i].name == 0)
	{
	  sim_io_eprintf (sd, "Device '%s' not found.\n", cmd);
	  sim_io_eprintf (sd, "Valid devices: cpu timer sio eeprom\n");
	  return;
	}
      hw_dev = sim_hw_parse (sd, dev_list[i].device);
      if (hw_dev == 0)
	{
	  sim_io_eprintf (sd, "Device '%s' not found\n", dev_list[i].device);
	  return;
	}
      hw_ioctl (hw_dev, 23, 0);
      return;
    }

  cpu_info (sd, cpu);
  interrupts_info (sd, &cpu->cpu_interrupts);
}


void
sim_board_reset (SIM_DESC sd)
{
  struct hw *hw_cpu;
  sim_cpu *cpu;
  const struct bfd_arch_info *arch;
  const char *cpu_type;

  cpu = STATE_CPU (sd, 0);
  arch = STATE_ARCHITECTURE (sd);

  /*  hw_cpu = sim_hw_parse (sd, "/"); */
  if (arch->arch == bfd_arch_m68hc11)
    {
      cpu->cpu_type = CPU_M6811;
      cpu_type = "/m68hc11";
    }
  else
    {
      cpu->cpu_type = CPU_M6812;
      cpu_type = "/m68hc12";
    }
  
  hw_cpu = sim_hw_parse (sd, cpu_type);
  if (hw_cpu == 0)
    {
      sim_io_eprintf (sd, "%s cpu not found in device tree.", cpu_type);
      return;
    }

  cpu_reset (cpu);
  hw_port_event (hw_cpu, 3, 0);
  cpu_restart (cpu);
}

static int
sim_hw_configure (SIM_DESC sd)
{
  const struct bfd_arch_info *arch;
  struct hw *device_tree;
  sim_cpu *cpu;
  
  arch = STATE_ARCHITECTURE (sd);
  if (arch == 0)
    return 0;

  cpu = STATE_CPU (sd, 0);
  cpu->cpu_configured_arch = arch;
  device_tree = sim_hw_parse (sd, "/");
  if (arch->arch == bfd_arch_m68hc11)
    {
      cpu->cpu_interpretor = cpu_interp_m6811;
      if (hw_tree_find_property (device_tree, "/m68hc11/reg") == 0)
	{
	  /* Allocate core managed memory */

	  /* the monitor  */
	  sim_do_commandf (sd, "memory region 0x%lx@@%d,0x%lx",
			   /* MONITOR_BASE, MONITOR_SIZE */
			   0x8000, M6811_RAM_LEVEL, 0x8000);
	  sim_do_commandf (sd, "memory region 0x000@@%d,0x8000",
			   M6811_RAM_LEVEL);
	  sim_hw_parse (sd, "/m68hc11/reg 0x1000 0x03F");
          if (cpu->bank_start < cpu->bank_end)
            {
              sim_do_commandf (sd, "memory region 0x%lx@@%d,0x100000",
                               cpu->bank_virtual, M6811_RAM_LEVEL);
              sim_hw_parse (sd, "/m68hc11/use_bank 1");
            }
	}
      if (cpu->cpu_start_mode)
        {
          sim_hw_parse (sd, "/m68hc11/mode %s", cpu->cpu_start_mode);
        }
      if (hw_tree_find_property (device_tree, "/m68hc11/m68hc11sio/reg") == 0)
	{
	  sim_hw_parse (sd, "/m68hc11/m68hc11sio/reg 0x2b 0x5");
	  sim_hw_parse (sd, "/m68hc11/m68hc11sio/backend stdio");
	  sim_hw_parse (sd, "/m68hc11 > cpu-reset reset /m68hc11/m68hc11sio");
	}
      if (hw_tree_find_property (device_tree, "/m68hc11/m68hc11tim/reg") == 0)
	{
	  /* M68hc11 Timer configuration. */
	  sim_hw_parse (sd, "/m68hc11/m68hc11tim/reg 0x1b 0x5");
	  sim_hw_parse (sd, "/m68hc11 > cpu-reset reset /m68hc11/m68hc11tim");
          sim_hw_parse (sd, "/m68hc11 > capture capture /m68hc11/m68hc11tim");
	}

      /* Create the SPI device.  */
      if (hw_tree_find_property (device_tree, "/m68hc11/m68hc11spi/reg") == 0)
	{
	  sim_hw_parse (sd, "/m68hc11/m68hc11spi/reg 0x28 0x3");
	  sim_hw_parse (sd, "/m68hc11 > cpu-reset reset /m68hc11/m68hc11spi");
	}
      if (hw_tree_find_property (device_tree, "/m68hc11/nvram/reg") == 0)
	{
	  /* M68hc11 persistent ram configuration. */
	  sim_hw_parse (sd, "/m68hc11/nvram/reg 0x0 256");
	  sim_hw_parse (sd, "/m68hc11/nvram/file m68hc11.ram");
	  sim_hw_parse (sd, "/m68hc11/nvram/mode save-modified");
	  /*sim_hw_parse (sd, "/m68hc11 > cpu-reset reset /m68hc11/pram"); */
	}
      if (hw_tree_find_property (device_tree, "/m68hc11/m68hc11eepr/reg") == 0)
	{
	  sim_hw_parse (sd, "/m68hc11/m68hc11eepr/reg 0xb000 512");
	  sim_hw_parse (sd, "/m68hc11 > cpu-reset reset /m68hc11/m68hc11eepr");
	}
      sim_hw_parse (sd, "/m68hc11 > port-a cpu-write-port /m68hc11");
      sim_hw_parse (sd, "/m68hc11 > port-b cpu-write-port /m68hc11");
      sim_hw_parse (sd, "/m68hc11 > port-c cpu-write-port /m68hc11");
      sim_hw_parse (sd, "/m68hc11 > port-d cpu-write-port /m68hc11");
      cpu->hw_cpu = sim_hw_parse (sd, "/m68hc11");
    }
  else
    {
      cpu->cpu_interpretor = cpu_interp_m6812;
      if (hw_tree_find_property (device_tree, "/m68hc12/reg") == 0)
	{
	  /* Allocate core external memory.  */
	  sim_do_commandf (sd, "memory region 0x%lx@@%d,0x%lx",
			   0x8000, M6811_RAM_LEVEL, 0x8000);
	  sim_do_commandf (sd, "memory region 0x000@@%d,0x8000",
			   M6811_RAM_LEVEL);
          if (cpu->bank_start < cpu->bank_end)
            {
              sim_do_commandf (sd, "memory region 0x%lx@@%d,0x100000",
                               cpu->bank_virtual, M6811_RAM_LEVEL);
              sim_hw_parse (sd, "/m68hc12/use_bank 1");
            }
	  sim_hw_parse (sd, "/m68hc12/reg 0x0 0x3FF");
	}

      if (!hw_tree_find_property (device_tree, "/m68hc12/m68hc12sio@@1/reg"))
	{
	  sim_hw_parse (sd, "/m68hc12/m68hc12sio@@1/reg 0xC0 0x8");
	  sim_hw_parse (sd, "/m68hc12/m68hc12sio@@1/backend stdio");
	  sim_hw_parse (sd, "/m68hc12 > cpu-reset reset /m68hc12/m68hc12sio@@1");
	}
      if (hw_tree_find_property (device_tree, "/m68hc12/m68hc12tim/reg") == 0)
	{
	  /* M68hc11 Timer configuration. */
	  sim_hw_parse (sd, "/m68hc12/m68hc12tim/reg 0x1b 0x5");
	  sim_hw_parse (sd, "/m68hc12 > cpu-reset reset /m68hc12/m68hc12tim");
          sim_hw_parse (sd, "/m68hc12 > capture capture /m68hc12/m68hc12tim");
	}

      /* Create the SPI device.  */
      if (hw_tree_find_property (device_tree, "/m68hc12/m68hc12spi/reg") == 0)
	{
	  sim_hw_parse (sd, "/m68hc12/m68hc12spi/reg 0x28 0x3");
	  sim_hw_parse (sd, "/m68hc12 > cpu-reset reset /m68hc12/m68hc12spi");
	}
      if (hw_tree_find_property (device_tree, "/m68hc12/nvram/reg") == 0)
	{
	  /* M68hc11 persistent ram configuration. */
	  sim_hw_parse (sd, "/m68hc12/nvram/reg 0x2000 8192");
	  sim_hw_parse (sd, "/m68hc12/nvram/file m68hc12.ram");
	  sim_hw_parse (sd, "/m68hc12/nvram/mode save-modified");
	}
      if (hw_tree_find_property (device_tree, "/m68hc12/m68hc12eepr/reg") == 0)
	{
	  sim_hw_parse (sd, "/m68hc12/m68hc12eepr/reg 0x0800 2048");
	  sim_hw_parse (sd, "/m68hc12 > cpu-reset reset /m68hc12/m68hc12eepr");
	}

      sim_hw_parse (sd, "/m68hc12 > port-a cpu-write-port /m68hc12");
      sim_hw_parse (sd, "/m68hc12 > port-b cpu-write-port /m68hc12");
      sim_hw_parse (sd, "/m68hc12 > port-c cpu-write-port /m68hc12");
      sim_hw_parse (sd, "/m68hc12 > port-d cpu-write-port /m68hc12");
      cpu->hw_cpu = sim_hw_parse (sd, "/m68hc12");
    }
  return 1;
}

/* Get the memory bank parameters by looking at the global symbols
   defined by the linker.  */
static int
sim_get_bank_parameters (SIM_DESC sd, bfd* abfd)
{
  sim_cpu *cpu;
  long symsize;
  long symbol_count, i;
  unsigned size;
  asymbol** asymbols;
  asymbol** current;

  cpu = STATE_CPU (sd, 0);

  symsize = bfd_get_symtab_upper_bound (abfd);
  if (symsize < 0)
    {
      sim_io_eprintf (sd, "Cannot read symbols of program");
      return 0;
    }
  asymbols = (asymbol **) xmalloc (symsize);
  symbol_count = bfd_canonicalize_symtab (abfd, asymbols);
  if (symbol_count < 0)
    {
      sim_io_eprintf (sd, "Cannot read symbols of program");
      return 0;
    }

  size = 0;
  for (i = 0, current = asymbols; i < symbol_count; i++, current++)
    {
      const char* name = bfd_asymbol_name (*current);

      if (strcmp (name, BFD_M68HC11_BANK_START_NAME) == 0)
        {
          cpu->bank_start = bfd_asymbol_value (*current);
        }
      else if (strcmp (name, BFD_M68HC11_BANK_SIZE_NAME) == 0)
        {
          size = bfd_asymbol_value (*current);
        }
      else if (strcmp (name, BFD_M68HC11_BANK_VIRTUAL_NAME) == 0)
        {
          cpu->bank_virtual = bfd_asymbol_value (*current);
        }
    }
  free (asymbols);

  cpu->bank_end = cpu->bank_start + size;
  cpu->bank_shift = 0;
  for (; size > 1; size >>= 1)
    cpu->bank_shift++;

  return 0;
}

static int
sim_prepare_for_program (SIM_DESC sd, bfd* abfd)
{
  sim_cpu *cpu;
  int elf_flags = 0;

  cpu = STATE_CPU (sd, 0);

  if (abfd != NULL)
    {
      asection *s;

      if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
        elf_flags = elf_elfheader (abfd)->e_flags;

      cpu->cpu_elf_start = bfd_get_start_address (abfd);
      /* See if any section sets the reset address */
      cpu->cpu_use_elf_start = 1;
      for (s = abfd->sections; s && cpu->cpu_use_elf_start; s = s->next) 
        {
          if (s->flags & SEC_LOAD)
            {
              bfd_size_type size;

              size = bfd_get_section_size (s);
              if (size > 0)
                {
                  bfd_vma lma;

                  if (STATE_LOAD_AT_LMA_P (sd))
                    lma = bfd_section_lma (abfd, s);
                  else
                    lma = bfd_section_vma (abfd, s);

                  if (lma <= 0xFFFE && lma+size >= 0x10000)
                    cpu->cpu_use_elf_start = 0;
                }
            }
        }

      if (elf_flags & E_M68HC12_BANKS)
        {
          if (sim_get_bank_parameters (sd, abfd) != 0)
            sim_io_eprintf (sd, "Memory bank parameters are not initialized\n");
        }
    }

  if (!sim_hw_configure (sd))
    return SIM_RC_FAIL;

  /* reset all state information */
  sim_board_reset (sd);

  return SIM_RC_OK;
}

SIM_DESC
sim_open (SIM_OPEN_KIND kind, host_callback *callback,
          bfd *abfd, char **argv)
{
  SIM_DESC sd;
  sim_cpu *cpu;

  sd = sim_state_alloc (kind, callback);
  cpu = STATE_CPU (sd, 0);

  SIM_ASSERT (STATE_MAGIC (sd) == SIM_MAGIC_NUMBER);

  /* for compatibility */
  current_alignment = NONSTRICT_ALIGNMENT;
  current_target_byte_order = BIG_ENDIAN;

  cpu_initialize (sd, cpu);

  if (sim_pre_argv_init (sd, argv[0]) != SIM_RC_OK)
    {
      free_state (sd);
      return 0;
    }

  /* getopt will print the error message so we just have to exit if this fails.
     FIXME: Hmmm...  in the case of gdb we need getopt to call
     print_filtered.  */
  if (sim_parse_args (sd, argv) != SIM_RC_OK)
    {
      /* Uninstall the modules to avoid memory leaks,
         file descriptor leaks, etc.  */
      free_state (sd);
      return 0;
    }

  /* Check for/establish the a reference program image.  */
  if (sim_analyze_program (sd,
			   (STATE_PROG_ARGV (sd) != NULL
			    ? *STATE_PROG_ARGV (sd)
			    : NULL), abfd) != SIM_RC_OK)
    {
      free_state (sd);
      return 0;
    }

  /* Establish any remaining configuration options.  */
  if (sim_config (sd) != SIM_RC_OK)
    {
      free_state (sd);
      return 0;
    }

  if (sim_post_argv_init (sd) != SIM_RC_OK)
    {
      /* Uninstall the modules to avoid memory leaks,
         file descriptor leaks, etc.  */
      free_state (sd);
      return 0;
    }
  if (sim_prepare_for_program (sd, abfd) != SIM_RC_OK)
    {
      free_state (sd);
      return 0;
    }      

  /* Fudge our descriptor.  */
  return sd;
}


void
sim_close (SIM_DESC sd, int quitting)
{
  /* shut down modules */
  sim_module_uninstall (sd);

  /* Ensure that any resources allocated through the callback
     mechanism are released: */
  sim_io_shutdown (sd);

  /* FIXME - free SD */
  sim_state_free (sd);
  return;
}

void
sim_set_profile (int n)
{
}

void
sim_set_profile_size (int n)
{
}

/* Generic implementation of sim_engine_run that works within the
   sim_engine setjmp/longjmp framework. */

void
sim_engine_run (SIM_DESC sd,
                int next_cpu_nr,	/* ignore */
		int nr_cpus,	/* ignore */
		int siggnal)	/* ignore */
{
  sim_cpu *cpu;

  SIM_ASSERT (STATE_MAGIC (sd) == SIM_MAGIC_NUMBER);
  cpu = STATE_CPU (sd, 0);
  while (1)
    {
      cpu_single_step (cpu);

      /* process any events */
      if (sim_events_tickn (sd, cpu->cpu_current_cycle))
	{
	  sim_events_process (sd);
	}
    }
}

int
sim_trace (SIM_DESC sd)
{
  sim_resume (sd, 0, 0);
  return 1;
}

void
sim_info (SIM_DESC sd, int verbose)
{
  const char *cpu_type;
  const struct bfd_arch_info *arch;

  /* Nothing to do if there is no verbose flag set.  */
  if (verbose == 0 && STATE_VERBOSE_P (sd) == 0)
    return;

  arch = STATE_ARCHITECTURE (sd);
  if (arch->arch == bfd_arch_m68hc11)
    cpu_type = "68HC11";
  else
    cpu_type = "68HC12";

  sim_io_eprintf (sd, "Simulator info:\n");
  sim_io_eprintf (sd, "  CPU Motorola %s\n", cpu_type);
  sim_get_info (sd, 0);
  sim_module_info (sd, verbose || STATE_VERBOSE_P (sd));
}

SIM_RC
sim_create_inferior (SIM_DESC sd, struct bfd *abfd,
                     char **argv, char **env)
{
  return sim_prepare_for_program (sd, abfd);
}


void
sim_set_callbacks (host_callback *p)
{
  /*  m6811_callback = p; */
}


int
sim_fetch_register (SIM_DESC sd, int rn, unsigned char *memory, int length)
{
  sim_cpu *cpu;
  uint16 val;
  int size = 2;

  cpu = STATE_CPU (sd, 0);
  switch (rn)
    {
    case A_REGNUM:
      val = cpu_get_a (cpu);
      size = 1;
      break;

    case B_REGNUM:
      val = cpu_get_b (cpu);
      size = 1;
      break;

    case D_REGNUM:
      val = cpu_get_d (cpu);
      break;

    case X_REGNUM:
      val = cpu_get_x (cpu);
      break;

    case Y_REGNUM:
      val = cpu_get_y (cpu);
      break;

    case SP_REGNUM:
      val = cpu_get_sp (cpu);
      break;

    case PC_REGNUM:
      val = cpu_get_pc (cpu);
      break;

    case PSW_REGNUM:
      val = cpu_get_ccr (cpu);
      size = 1;
      break;

    case PAGE_REGNUM:
      val = cpu_get_page (cpu);
      size = 1;
      break;

    default:
      val = 0;
      break;
    }
  if (size == 1)
    {
      memory[0] = val;
    }
  else
    {
      memory[0] = val >> 8;
      memory[1] = val & 0x0FF;
    }
  return size;
}

int
sim_store_register (SIM_DESC sd, int rn, unsigned char *memory, int length)
{
  uint16 val;
  sim_cpu *cpu;

  cpu = STATE_CPU (sd, 0);

  val = *memory++;
  if (length == 2)
    val = (val << 8) | *memory;

  switch (rn)
    {
    case D_REGNUM:
      cpu_set_d (cpu, val);
      break;

    case A_REGNUM:
      cpu_set_a (cpu, val);
      return 1;

    case B_REGNUM:
      cpu_set_b (cpu, val);
      return 1;

    case X_REGNUM:
      cpu_set_x (cpu, val);
      break;

    case Y_REGNUM:
      cpu_set_y (cpu, val);
      break;

    case SP_REGNUM:
      cpu_set_sp (cpu, val);
      break;

    case PC_REGNUM:
      cpu_set_pc (cpu, val);
      break;

    case PSW_REGNUM:
      cpu_set_ccr (cpu, val);
      return 1;

    case PAGE_REGNUM:
      cpu_set_page (cpu, val);
      return 1;

    default:
      break;
    }

  return 2;
}

void
sim_size (int s)
{
  ;
}

/* Halt the simulator after just one instruction */

static void
has_stepped (SIM_DESC sd,
	     void *data)
{
  ASSERT (STATE_MAGIC (sd) == SIM_MAGIC_NUMBER);
  sim_engine_halt (sd, NULL, NULL, NULL_CIA, sim_stopped, SIM_SIGTRAP);
}


/* Generic resume - assumes the existance of sim_engine_run */

void
sim_resume (SIM_DESC sd,
	    int step,
	    int siggnal)
{
  sim_engine *engine = STATE_ENGINE (sd);
  jmp_buf buf;
  int jmpval;

  ASSERT (STATE_MAGIC (sd) == SIM_MAGIC_NUMBER);

  /* we only want to be single stepping the simulator once */
  if (engine->stepper != NULL)
    {
      sim_events_deschedule (sd, engine->stepper);
      engine->stepper = NULL;
    }
  sim_module_resume (sd);

  /* run/resume the simulator */
  engine->jmpbuf = &buf;
  jmpval = setjmp (buf);
  if (jmpval == sim_engine_start_jmpval
      || jmpval == sim_engine_restart_jmpval)
    {
      int last_cpu_nr = sim_engine_last_cpu_nr (sd);
      int next_cpu_nr = sim_engine_next_cpu_nr (sd);
      int nr_cpus = sim_engine_nr_cpus (sd);

      sim_events_preprocess (sd, last_cpu_nr >= nr_cpus, next_cpu_nr >= nr_cpus);
      if (next_cpu_nr >= nr_cpus)
	next_cpu_nr = 0;

      /* Only deliver the siggnal ]sic] the first time through - don't
         re-deliver any siggnal during a restart. */
      if (jmpval == sim_engine_restart_jmpval)
	siggnal = 0;

      /* Install the stepping event after having processed some
         pending events.  This is necessary for HC11/HC12 simulator
         because the tick counter is incremented by the number of cycles
         the instruction took.  Some pending ticks to process can still
         be recorded internally by the simulator and sim_events_preprocess
         will handle them.  If the stepping event is inserted before,
         these pending ticks will raise the event and the simulator will
         stop without having executed any instruction.  */
      if (step)
        engine->stepper = sim_events_schedule (sd, 0, has_stepped, sd);

#ifdef SIM_CPU_EXCEPTION_RESUME
      {
	sim_cpu* cpu = STATE_CPU (sd, next_cpu_nr);
	SIM_CPU_EXCEPTION_RESUME(sd, cpu, siggnal);
      }
#endif

      sim_engine_run (sd, next_cpu_nr, nr_cpus, siggnal);
    }
  engine->jmpbuf = NULL;

  sim_module_suspend (sd);
}
@


1.25
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 1
   Copyright (C) 1999-2004, 2007-2012 Free Software Foundation, Inc.
@


1.24
log
@sim: start a unified sim_do_command

Since sim_do_command for many people simply calls sim_args_command, start
a unified version of it.  For people who handle their own options, they
could switch to this by using sim_add_option_table instead.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d2 1
a2 2
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008, 2009, 2010,
   2011 Free Software Foundation, Inc.
@


1.24.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 1
   Copyright (C) 1999-2004, 2007-2012 Free Software Foundation, Inc.
@


1.23
log
@run copyright.sh for 2011.
@
text
@a713 27
void
sim_do_command (SIM_DESC sd, char *cmd)
{
  char *mm_cmd = "memory-map";
  char *int_cmd = "interrupt";
  sim_cpu *cpu;

  cpu = STATE_CPU (sd, 0);
  /* Commands available from GDB:   */
  if (sim_args_command (sd, cmd) != SIM_RC_OK)
    {
      if (strncmp (cmd, "info", sizeof ("info") - 1) == 0)
	sim_get_info (sd, &cmd[4]);
      else if (strncmp (cmd, mm_cmd, strlen (mm_cmd) == 0))
	sim_io_eprintf (sd,
			"`memory-map' command replaced by `sim memory'\n");
      else if (strncmp (cmd, int_cmd, strlen (int_cmd)) == 0)
	sim_io_eprintf (sd, "`interrupt' command replaced by `sim watch'\n");
      else
	sim_io_eprintf (sd, "Unknown command `%s'\n", cmd);
    }

  /* If the architecture changed, re-configure.  */
  if (STATE_ARCHITECTURE (sd) != cpu->cpu_configured_arch)
    sim_hw_configure (sd);
}

@


1.22
log
@Update copyright notices to add year 2010.
@
text
@d2 2
a3 2
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008, 2009, 2010
   Free Software Foundation, Inc.
@


1.21
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008, 2009
@


1.20
log
@	Updated copyright notices for most files.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008
@


1.19
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2007
@


1.18
log
@Copyright updates for 2007.
@
text
@d10 2
a11 2
the Free Software Foundation; either version 2, or (at your option)
any later version.
d18 2
a19 3
You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.17
log
@	* interp.c (sim_prepare_for_program): Use bfd_get_section_size
	instead of bfd_get_section_size_before_reloc.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004
@


1.16
log
@	* sim-main.h (phys_to_virt): Use memory bank parameters to translate
	the physical address in virtual address.
	(struct _sim_cpu): Add memory bank members.
	* m68hc11_sim.c (cpu_initialize): Clear memory bank parameters.
	* interp.c (sim_hw_configure): Create memory bank according to memory
	bank parameters.
	(sim_get_bank_parameters): New function to obtain memory bank config
	from the symbol table.
	(sim_prepare_for_program): Call it to obtain the memory bank parameters.
	(sim_open): Call sim_prepare_for_program.
	* dv-m68hc11.c (m68hc11cpu_io_write_buffer): Use memory bank parameters
	to check if address is within bank window.
	(m68hc11cpu_io_read_buffer): Likewise.
	(attach_m68hc11_regs): Map the memory bank according to memory bank
	parameters.
@
text
@d2 2
a3 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d390 1
a390 1
              size = bfd_get_section_size_before_reloc (s);
@


1.16.12.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 1
a2 2
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d389 1
a389 1
              size = bfd_get_section_size (s);
@


1.15
log
@	* interp.c (sim_fetch_register): Only store a single byte for
	1 byte registers.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d28 1
d198 6
d205 4
a208 1

d255 1
a255 1
			   0xC000, M6811_RAM_LEVEL, 0x4000);
d258 6
a263 3
	  sim_do_commandf (sd, "memory region 0x01000000@@%d,0x100000",
			   M6811_RAM_LEVEL);

a264 1
	  sim_hw_parse (sd, "/m68hc12/use_bank 1");
d309 2
d312 1
a312 1
sim_prepare_for_program (SIM_DESC sd, struct bfd* abfd)
d315 5
d323 49
a371 2
  if (!sim_hw_configure (sd))
    return SIM_RC_FAIL;
d376 4
d404 6
d412 3
d423 1
a423 1
          struct bfd *abfd, char **argv)
d480 5
a484 2

  sim_hw_configure (sd);
@


1.15.30.1
log
@	* sim-main.h (phys_to_virt): Use memory bank parameters to translate
	the physical address in virtual address.
	(struct _sim_cpu): Add memory bank members.
	* m68hc11_sim.c (cpu_initialize): Clear memory bank parameters.
	* interp.c (sim_hw_configure): Create memory bank according to memory
	bank parameters.
	(sim_get_bank_parameters): New function to obtain memory bank config
	from the symbol table.
	(sim_prepare_for_program): Call it to obtain the memory bank parameters.
	(sim_open): Call sim_prepare_for_program.
	* dv-m68hc11.c (m68hc11cpu_io_write_buffer): Use memory bank parameters
	to check if address is within bank window.
	(m68hc11cpu_io_read_buffer): Likewise.
	(attach_m68hc11_regs): Map the memory bank according to memory bank
	parameters.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a27 1
#include "elf32-m68hc1x.h"
a196 6
          if (cpu->bank_start < cpu->bank_end)
            {
              sim_do_commandf (sd, "memory region 0x%lx@@%d,0x100000",
                               cpu->bank_virtual, M6811_RAM_LEVEL);
              sim_hw_parse (sd, "/m68hc11/use_bank 1");
            }
d198 1
a198 4
      if (cpu->cpu_start_mode)
        {
          sim_hw_parse (sd, "/m68hc11/mode %s", cpu->cpu_start_mode);
        }
d245 1
a245 1
			   0x8000, M6811_RAM_LEVEL, 0x8000);
d248 3
a250 6
          if (cpu->bank_start < cpu->bank_end)
            {
              sim_do_commandf (sd, "memory region 0x%lx@@%d,0x100000",
                               cpu->bank_virtual, M6811_RAM_LEVEL);
              sim_hw_parse (sd, "/m68hc12/use_bank 1");
            }
d252 1
a296 2
/* Get the memory bank parameters by looking at the global symbols
   defined by the linker.  */
d298 1
a298 1
sim_get_bank_parameters (SIM_DESC sd, bfd* abfd)
a300 5
  long symsize;
  long symbol_count, i;
  unsigned size;
  asymbol** asymbols;
  asymbol** current;
d304 2
a305 49
  symsize = bfd_get_symtab_upper_bound (abfd);
  if (symsize < 0)
    {
      sim_io_eprintf (sd, "Cannot read symbols of program");
      return 0;
    }
  asymbols = (asymbol **) xmalloc (symsize);
  symbol_count = bfd_canonicalize_symtab (abfd, asymbols);
  if (symbol_count < 0)
    {
      sim_io_eprintf (sd, "Cannot read symbols of program");
      return 0;
    }

  size = 0;
  for (i = 0, current = asymbols; i < symbol_count; i++, current++)
    {
      const char* name = bfd_asymbol_name (*current);

      if (strcmp (name, BFD_M68HC11_BANK_START_NAME) == 0)
        {
          cpu->bank_start = bfd_asymbol_value (*current);
        }
      else if (strcmp (name, BFD_M68HC11_BANK_SIZE_NAME) == 0)
        {
          size = bfd_asymbol_value (*current);
        }
      else if (strcmp (name, BFD_M68HC11_BANK_VIRTUAL_NAME) == 0)
        {
          cpu->bank_virtual = bfd_asymbol_value (*current);
        }
    }
  free (asymbols);

  cpu->bank_end = cpu->bank_start + size;
  cpu->bank_shift = 0;
  for (; size > 1; size >>= 1)
    cpu->bank_shift++;

  return 0;
}

static int
sim_prepare_for_program (SIM_DESC sd, bfd* abfd)
{
  sim_cpu *cpu;
  int elf_flags = 0;

  cpu = STATE_CPU (sd, 0);
a309 4

      if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
        elf_flags = elf_elfheader (abfd)->e_flags;

a333 6

      if (elf_flags & E_M68HC12_BANKS)
        {
          if (sim_get_bank_parameters (sd, abfd) != 0)
            sim_io_eprintf (sd, "Memory bank parameters are not initialized\n");
        }
a335 3
  if (!sim_hw_configure (sd))
    return SIM_RC_FAIL;

d344 1
a344 1
          bfd *abfd, char **argv)
d401 2
a402 5
  if (sim_prepare_for_program (sd, abfd) != SIM_RC_OK)
    {
      free_state (sd);
      return 0;
    }      
@


1.14
log
@Index: arm/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* wrapper.c (sim_create_inferior, sim_open): Rename _bfd to bfd.

Index: common/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim-utils.h (sim_analyze_program, sim_load_file): Rename _bfd to bfd.
	* sim-hload.c (sim_load), sim-base.h (sim_state_base): Ditto.
	* nrun.c (main): Ditto.

Index: d10v/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: erc32/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interf.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: h8300/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* compile.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: h8500/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* compile.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: i960/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim-if.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: m32r/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim-if.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: m68hc11/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_prepare_for_program, sim_open)
	(sim_create_inferior): Rename _bfd to bfd.

Index: mcore/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: mips/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open):
	(sim_create_inferior):

Index: mn10200/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: mn10300/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior, sim_open)
	(sim_create_inferior): Rename _bfd to bfd.

Index: ppc/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim_calls.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: sh/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (init_dsp, sim_open, sim_create_inferior): Rename _bfd
	to bfd.

Index: v850/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: z8k/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* iface.c (sim_open, sim_create_inferior): Rename _bfd to bfd.
@
text
@d557 9
a565 2
  memory[0] = val >> 8;
  memory[1] = val & 0x0FF;
@


1.13
log
@	* interp.c (sim_prepare_for_program): Look up the image for the
	reset vector and set cpu_use_elf_start to 1 if not found.
	(sim_open): Do not set cpu_use_elf_start.
@
text
@d298 1
a298 1
sim_prepare_for_program (SIM_DESC sd, struct _bfd* abfd)
d344 1
a344 1
          struct _bfd *abfd, char **argv)
d489 1
a489 1
sim_create_inferior (SIM_DESC sd, struct _bfd *abfd,
@


1.13.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a27 1
#include "elf32-m68hc1x.h"
a196 6
          if (cpu->bank_start < cpu->bank_end)
            {
              sim_do_commandf (sd, "memory region 0x%lx@@%d,0x100000",
                               cpu->bank_virtual, M6811_RAM_LEVEL);
              sim_hw_parse (sd, "/m68hc11/use_bank 1");
            }
d198 1
a198 4
      if (cpu->cpu_start_mode)
        {
          sim_hw_parse (sd, "/m68hc11/mode %s", cpu->cpu_start_mode);
        }
d245 1
a245 1
			   0x8000, M6811_RAM_LEVEL, 0x8000);
d248 3
a250 6
          if (cpu->bank_start < cpu->bank_end)
            {
              sim_do_commandf (sd, "memory region 0x%lx@@%d,0x100000",
                               cpu->bank_virtual, M6811_RAM_LEVEL);
              sim_hw_parse (sd, "/m68hc12/use_bank 1");
            }
d252 1
a296 2
/* Get the memory bank parameters by looking at the global symbols
   defined by the linker.  */
d298 1
a298 1
sim_get_bank_parameters (SIM_DESC sd, bfd* abfd)
a300 5
  long symsize;
  long symbol_count, i;
  unsigned size;
  asymbol** asymbols;
  asymbol** current;
d304 2
a305 49
  symsize = bfd_get_symtab_upper_bound (abfd);
  if (symsize < 0)
    {
      sim_io_eprintf (sd, "Cannot read symbols of program");
      return 0;
    }
  asymbols = (asymbol **) xmalloc (symsize);
  symbol_count = bfd_canonicalize_symtab (abfd, asymbols);
  if (symbol_count < 0)
    {
      sim_io_eprintf (sd, "Cannot read symbols of program");
      return 0;
    }

  size = 0;
  for (i = 0, current = asymbols; i < symbol_count; i++, current++)
    {
      const char* name = bfd_asymbol_name (*current);

      if (strcmp (name, BFD_M68HC11_BANK_START_NAME) == 0)
        {
          cpu->bank_start = bfd_asymbol_value (*current);
        }
      else if (strcmp (name, BFD_M68HC11_BANK_SIZE_NAME) == 0)
        {
          size = bfd_asymbol_value (*current);
        }
      else if (strcmp (name, BFD_M68HC11_BANK_VIRTUAL_NAME) == 0)
        {
          cpu->bank_virtual = bfd_asymbol_value (*current);
        }
    }
  free (asymbols);

  cpu->bank_end = cpu->bank_start + size;
  cpu->bank_shift = 0;
  for (; size > 1; size >>= 1)
    cpu->bank_shift++;

  return 0;
}

static int
sim_prepare_for_program (SIM_DESC sd, bfd* abfd)
{
  sim_cpu *cpu;
  int elf_flags = 0;

  cpu = STATE_CPU (sd, 0);
a309 4

      if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
        elf_flags = elf_elfheader (abfd)->e_flags;

a333 6

      if (elf_flags & E_M68HC12_BANKS)
        {
          if (sim_get_bank_parameters (sd, abfd) != 0)
            sim_io_eprintf (sd, "Memory bank parameters are not initialized\n");
        }
a335 3
  if (!sim_hw_configure (sd))
    return SIM_RC_FAIL;

d344 1
a344 1
          bfd *abfd, char **argv)
d401 2
a402 5
  if (sim_prepare_for_program (sd, abfd) != SIM_RC_OK)
    {
      free_state (sd);
      return 0;
    }      
d489 1
a489 1
sim_create_inferior (SIM_DESC sd, struct bfd *abfd,
d557 2
a558 9
  if (size == 1)
    {
      memory[0] = val;
    }
  else
    {
      memory[0] = val >> 8;
      memory[1] = val & 0x0FF;
    }
@


1.13.8.1
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d298 1
a298 1
sim_prepare_for_program (SIM_DESC sd, struct bfd* abfd)
d344 1
a344 1
          struct bfd *abfd, char **argv)
d489 1
a489 1
sim_create_inferior (SIM_DESC sd, struct bfd *abfd,
d557 2
a558 9
  if (size == 1)
    {
      memory[0] = val;
    }
  else
    {
      memory[0] = val >> 8;
      memory[1] = val & 0x0FF;
    }
@


1.13.8.2
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a27 1
#include "elf32-m68hc1x.h"
a196 6
          if (cpu->bank_start < cpu->bank_end)
            {
              sim_do_commandf (sd, "memory region 0x%lx@@%d,0x100000",
                               cpu->bank_virtual, M6811_RAM_LEVEL);
              sim_hw_parse (sd, "/m68hc11/use_bank 1");
            }
d198 1
a198 4
      if (cpu->cpu_start_mode)
        {
          sim_hw_parse (sd, "/m68hc11/mode %s", cpu->cpu_start_mode);
        }
d245 1
a245 1
			   0x8000, M6811_RAM_LEVEL, 0x8000);
d248 3
a250 6
          if (cpu->bank_start < cpu->bank_end)
            {
              sim_do_commandf (sd, "memory region 0x%lx@@%d,0x100000",
                               cpu->bank_virtual, M6811_RAM_LEVEL);
              sim_hw_parse (sd, "/m68hc12/use_bank 1");
            }
d252 1
a296 2
/* Get the memory bank parameters by looking at the global symbols
   defined by the linker.  */
d298 1
a298 1
sim_get_bank_parameters (SIM_DESC sd, bfd* abfd)
a300 5
  long symsize;
  long symbol_count, i;
  unsigned size;
  asymbol** asymbols;
  asymbol** current;
d304 2
a305 49
  symsize = bfd_get_symtab_upper_bound (abfd);
  if (symsize < 0)
    {
      sim_io_eprintf (sd, "Cannot read symbols of program");
      return 0;
    }
  asymbols = (asymbol **) xmalloc (symsize);
  symbol_count = bfd_canonicalize_symtab (abfd, asymbols);
  if (symbol_count < 0)
    {
      sim_io_eprintf (sd, "Cannot read symbols of program");
      return 0;
    }

  size = 0;
  for (i = 0, current = asymbols; i < symbol_count; i++, current++)
    {
      const char* name = bfd_asymbol_name (*current);

      if (strcmp (name, BFD_M68HC11_BANK_START_NAME) == 0)
        {
          cpu->bank_start = bfd_asymbol_value (*current);
        }
      else if (strcmp (name, BFD_M68HC11_BANK_SIZE_NAME) == 0)
        {
          size = bfd_asymbol_value (*current);
        }
      else if (strcmp (name, BFD_M68HC11_BANK_VIRTUAL_NAME) == 0)
        {
          cpu->bank_virtual = bfd_asymbol_value (*current);
        }
    }
  free (asymbols);

  cpu->bank_end = cpu->bank_start + size;
  cpu->bank_shift = 0;
  for (; size > 1; size >>= 1)
    cpu->bank_shift++;

  return 0;
}

static int
sim_prepare_for_program (SIM_DESC sd, bfd* abfd)
{
  sim_cpu *cpu;
  int elf_flags = 0;

  cpu = STATE_CPU (sd, 0);
a309 4

      if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
        elf_flags = elf_elfheader (abfd)->e_flags;

a333 6

      if (elf_flags & E_M68HC12_BANKS)
        {
          if (sim_get_bank_parameters (sd, abfd) != 0)
            sim_io_eprintf (sd, "Memory bank parameters are not initialized\n");
        }
a335 3
  if (!sim_hw_configure (sd))
    return SIM_RC_FAIL;

d344 1
a344 1
          bfd *abfd, char **argv)
d401 2
a402 5
  if (sim_prepare_for_program (sd, abfd) != SIM_RC_OK)
    {
      free_state (sd);
      return 0;
    }      
@


1.12
log
@	* interp.c (sim_hw_configure): Return 1 for success.
	(sim_prepare_for_program): Use the sim_hw_configure exit code to
	return SIM_RC_FAIL.
@
text
@d309 1
d311 23
a359 1
  cpu->cpu_use_elf_start = 1;
@


1.11
log
@	* dv-m68hc11.c (m68hc11cpu_io_read_buffer): Translate memory
	bank window to some virtual address to read from extended memory.
	(m68hc11cpu_io_write_buffer): Likewise for writing.
	(attach_m68hc11_regs): When use_bank property is defined, attached
	to the 68HC12 16K memory bank window.
	* interp.c (sim_hw_configure): Create memory region for banked
	memory.
@
text
@d169 1
a169 1
int
d294 1
a294 1
  return 0;
d304 3
a306 1
  sim_hw_configure (sd);
@


1.10
log
@	* interp.c (sim_hw_configure): Connect port-X to cpu-write-port.
	* dv-m68hc11.c (m68hc11cpu_ports): Add cpu-write-port input.
	(m68hc11cpu_port_event): Handle CPU_WRITE_PORT event.
@
text
@d245 1
a245 1
			   0x8000, M6811_RAM_LEVEL, 0x8000);
d248 2
d252 1
@


1.9
log
@	* m68hc11_sim.c (cpu_special): Handle call and rtc instructions.
	* sim-main.h (M6812_CALL_INDIRECT): Add to enum.
	(m6811_regs): Add page register.
	(cpu_set_page, cpu_get_page): New macros.
	(phys_to_virt): New function.
	(cpu_get_indexed_operand_addr, cpu_return): Declare.
	* gencode.c: Identify indirect addressing mode for call and fix daa.
	(gen_function_entry): New param to tell if src8/dst8 locals are
	necessary.
	(gen_interpreter): Use it to avoid generation of unused variables.
	* interp.c (sim_fetch_register): Allow to read page register; page
	register, A, B and CCR are only 1 byte wide.
	(sim_store_register): Likewise for writing.
@
text
@d232 4
d263 1
d285 4
@


1.8
log
@	* m68hc11_sim.c (cpu_move8): Call sim_engine_abort in default case.
	(cpu_move16): Likewise.
	(sim_memory_error): Use sim_io_printf.
	(cpu_option_handler): Fix compilation warning.
	* interp.c (sim_hw_configure): Fix compilation warning;
	remove m68hc12sio@@2 device.
	(sim_open): Likewise.
	* dv-m68hc11tim.c (m68hc11tim_port_event): Fix clear of TFLG2
	flags when reset.
	(cycle_to_string): Improve convertion of cpu cycle number.
	(m68hc11tim_info): Print info about PACNT.
	(m68hc11tim_io_write_buffer): Fix clearing of TFLG2; handle
	TCTL1 and TCTL2 registers.
	* dv-m68hc11.c (m68hc11_info): Print 6811 current running mode.
@
text
@d3 1
a3 1
   Written by Stephane Carrez (stcarrez@@worldnet.fr)
d471 1
d478 1
d483 1
d508 6
d522 1
a522 1
  return 2;
d545 1
a545 1
      break;
d549 1
a549 1
      break;
d569 5
a573 1
      break;
@


1.8.6.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d3 1
a3 1
   Written by Stephane Carrez (stcarrez@@nerim.fr)
d169 1
a169 1
static int
a231 4
      sim_hw_parse (sd, "/m68hc11 > port-a cpu-write-port /m68hc11");
      sim_hw_parse (sd, "/m68hc11 > port-b cpu-write-port /m68hc11");
      sim_hw_parse (sd, "/m68hc11 > port-c cpu-write-port /m68hc11");
      sim_hw_parse (sd, "/m68hc11 > port-d cpu-write-port /m68hc11");
d241 1
a241 1
			   0xC000, M6811_RAM_LEVEL, 0x4000);
a243 2
	  sim_do_commandf (sd, "memory region 0x01000000@@%d,0x100000",
			   M6811_RAM_LEVEL);
a245 1
	  sim_hw_parse (sd, "/m68hc12/use_bank 1");
a258 1
          sim_hw_parse (sd, "/m68hc12 > capture capture /m68hc12/m68hc12tim");
a279 4
      sim_hw_parse (sd, "/m68hc12 > port-a cpu-write-port /m68hc12");
      sim_hw_parse (sd, "/m68hc12 > port-b cpu-write-port /m68hc12");
      sim_hw_parse (sd, "/m68hc12 > port-c cpu-write-port /m68hc12");
      sim_hw_parse (sd, "/m68hc12 > port-d cpu-write-port /m68hc12");
d282 1
a282 1
  return 1;
d292 1
a292 3
  if (!sim_hw_configure (sd))
    return SIM_RC_FAIL;

a294 1
      asection *s;
a295 23
      /* See if any section sets the reset address */
      cpu->cpu_use_elf_start = 1;
      for (s = abfd->sections; s && cpu->cpu_use_elf_start; s = s->next) 
        {
          if (s->flags & SEC_LOAD)
            {
              bfd_size_type size;

              size = bfd_get_section_size_before_reloc (s);
              if (size > 0)
                {
                  bfd_vma lma;

                  if (STATE_LOAD_AT_LMA_P (sd))
                    lma = bfd_section_lma (abfd, s);
                  else
                    lma = bfd_section_vma (abfd, s);

                  if (lma <= 0xFFFE && lma+size >= 0x10000)
                    cpu->cpu_use_elf_start = 0;
                }
            }
        }
d322 1
a470 1
  int size = 2;
a476 1
      size = 1;
a480 1
      size = 1;
a504 6
      size = 1;
      break;

    case PAGE_REGNUM:
      val = cpu_get_page (cpu);
      size = 1;
d513 1
a513 1
  return size;
d536 1
a536 1
      return 1;
d540 1
a540 1
      return 1;
d560 1
a560 5
      return 1;

    case PAGE_REGNUM:
      cpu_set_page (cpu, val);
      return 1;
@


1.7
log
@	* interp.c (sim_hw_configure): Save the HW cpu pointer in the
	cpu struct.
	(sim_hw_configure): Connect the capture input/output events.
	* sim-main.h (_sim_cpu): New member hw_cpu.
	(m68hc11cpu_set_oscillator): Declare.
	(m68hc11cpu_clear_oscillator): Declare.
	(m68hc11cpu_set_port): Declare.
	* dv-m68hc11.c (m68hc11_options): New for oscillator commands.
	(m68hc11cpu_ports): New input ports and output ports to reflect
	the HC11 IOs.
	(m68hc11_delete): Cleanup any running oscillator.
	(attach_m68hc11_regs): Create the input oscillators.
	(make_oscillator): New function.
	(find_oscillator): New function.
	(oscillator_handler): New function.
	(reset_oscillators): New function.
	(m68hc11cpu_port_event): Handle the new input ports.
	(m68hc11cpu_set_oscillator): New function.
	(m68hc11cpu_clear_oscillator): New function.
	(get_frequency): New function.
	(m68hc11_option_handler): New function.
	(m68hc11cpu_set_port): New function.
	(m68hc11cpu_io_write): Post the port output events.
	* dv-m68hc11spi.c (set_bit_port): Use m68hc11cpu_set_port to set
	the output port value.
	* dv-m68hc11tim.c (m68hc11tim_port_event): Handle CAPTURE event
	by latching the TCNT value in the register.
@
text
@a173 1
  int m6811_mode;
a253 6
      if (!hw_tree_find_property (device_tree, "/m68hc12/m68hc12sio@@2/reg"))
	{
	  sim_hw_parse (sd, "/m68hc12/m68hc12sio@@2/reg 0xC8 0x8");
	  sim_hw_parse (sd, "/m68hc12/m68hc12sio@@2/backend tcp");
	  sim_hw_parse (sd, "/m68hc12 > cpu-reset reset /m68hc12/m68hc12sio@@2");
	}
a307 1
  char **p;
a309 1
  struct hw *device_tree;
@


1.6
log
@	* sim-main.h (cpu_frame, cpu_frame_list): Remove.
	(cpu_frame_reg, cpu_print_frame): Remove.
	(cpu_m68hc11_push_uint8, cpu_m68hc11_pop_uint8): Cleanup.
	(cpu_m68hc11_push_uint16, cpu_m68hc11_pop_uint16): Likewise.
	(cpu_m68hc12_push_uint8, cpu_m68hc12_push_uint16): Likewise.
	(cpu_m68hc12_pop_uint8, cpu_m68hc12_pop_uint16): Likewise.
	* m68hc11_sim.c (cpu_find_frame): Remove.
	(cpu_create_frame_list): Remove.
	(cpu_remove_frame_list, cpu_create_frame, cpu_free_frame): Remove.
	(cpu_frame_reg, cpu_print_frame, cpu_update_frame): Remove.
	(cpu_call): Cleanup to remove #if HAVE_FRAME and calls to the above.
	(cpu_update_frame): Likewise.
	(cpu_return): Likewise.
	(cpu_reset): Likewise.
	(cpu_initialize): Likewise.
	* interp.c (sim_do_command): Remove call to cpu_print_frame.
@
text
@d211 1
d233 1
d286 2
@


1.5
log
@	* Makefile.in (SIM_OBJS): Remove sim-resume.o
	* interp.c (sim_resume): New function from sim-resume.c, install
	the stepping event after having processed the pending ticks.
	(has_stepped): Likewise.
	(sim_info): Produce an output only if verbose or STATE_VERBOSE_P.
@
text
@d1 2
a2 2
/* interp.c -- Simulator for Motorola 68HC11
   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
a592 2
      else if (strncmp (cmd, "frame", sizeof ("frame") - 1) == 0)
	cpu_print_frame (sd, STATE_CPU (sd, 0));
@


1.5.8.1
log
@	* sim-main.h (cpu_frame, cpu_frame_list): Remove.
	(cpu_frame_reg, cpu_print_frame): Remove.
	(cpu_m68hc11_push_uint8, cpu_m68hc11_pop_uint8): Cleanup.
	(cpu_m68hc11_push_uint16, cpu_m68hc11_pop_uint16): Likewise.
	(cpu_m68hc12_push_uint8, cpu_m68hc12_push_uint16): Likewise.
	(cpu_m68hc12_pop_uint8, cpu_m68hc12_pop_uint16): Likewise.
	* m68hc11_sim.c (cpu_find_frame): Remove.
	(cpu_create_frame_list): Remove.
	(cpu_remove_frame_list, cpu_create_frame, cpu_free_frame): Remove.
	(cpu_frame_reg, cpu_print_frame, cpu_update_frame): Remove.
	(cpu_call): Cleanup to remove #if HAVE_FRAME and calls to the above.
	(cpu_update_frame): Likewise.
	(cpu_return): Likewise.
	(cpu_reset): Likewise.
	(cpu_initialize): Likewise.
	* interp.c (sim_do_command): Remove call to cpu_print_frame.
@
text
@d1 2
a2 2
/* interp.c -- Simulator for Motorola 68HC11/68HC12
   Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d593 2
@


1.5.8.2
log
@	* interp.c (sim_hw_configure): Save the HW cpu pointer in the
	cpu struct.
	(sim_hw_configure): Connect the capture input/output events.
	* sim-main.h (_sim_cpu): New member hw_cpu.
	(m68hc11cpu_set_oscillator): Declare.
	(m68hc11cpu_clear_oscillator): Declare.
	(m68hc11cpu_set_port): Declare.
	* dv-m68hc11.c (m68hc11_options): New for oscillator commands.
	(m68hc11cpu_ports): New input ports and output ports to reflect
	the HC11 IOs.
	(m68hc11_delete): Cleanup any running oscillator.
	(attach_m68hc11_regs): Create the input oscillators.
	(make_oscillator): New function.
	(find_oscillator): New function.
	(oscillator_handler): New function.
	(reset_oscillators): New function.
	(m68hc11cpu_port_event): Handle the new input ports.
	(m68hc11cpu_set_oscillator): New function.
	(m68hc11cpu_clear_oscillator): New function.
	(get_frequency): New function.
	(m68hc11_option_handler): New function.
	(m68hc11cpu_set_port): New function.
	(m68hc11cpu_io_write): Post the port output events.
	* dv-m68hc11spi.c (set_bit_port): Use m68hc11cpu_set_port to set
	the output port value.
	* dv-m68hc11tim.c (m68hc11tim_port_event): Handle CAPTURE event
	by latching the TCNT value in the register.
@
text
@a210 1
          sim_hw_parse (sd, "/m68hc11 > capture capture /m68hc11/m68hc11tim");
a231 1
      cpu->hw_cpu = sim_hw_parse (sd, "/m68hc11");
a283 2

      cpu->hw_cpu = sim_hw_parse (sd, "/m68hc12");
@


1.5.8.3
log
@	* m68hc11_sim.c (cpu_move8): Call sim_engine_abort in default case.
	(cpu_move16): Likewise.
	(sim_memory_error): Use sim_io_printf.
	(cpu_option_handler): Fix compilation warning.
	* interp.c (sim_hw_configure): Fix compilation warning;
	remove m68hc12sio@@2 device.
	(sim_open): Likewise.
	* dv-m68hc11tim.c (m68hc11tim_port_event): Fix clear of TFLG2
	flags when reset.
	(cycle_to_string): Improve convertion of cpu cycle number.
	(m68hc11tim_info): Print info about PACNT.
	(m68hc11tim_io_write_buffer): Fix clearing of TFLG2; handle
	TCTL1 and TCTL2 registers.
	* dv-m68hc11.c (m68hc11_info): Print 6811 current running mode.
@
text
@d174 1
d255 6
d315 1
d318 1
@


1.4
log
@Improve HC11 simulator to support HC12
@
text
@d440 4
d607 76
@


1.3
log
@Remove soft reg hack in the 68hc11 simulator
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
d58 1
a58 1
struct sim_info_list dev_list[] = {
d67 20
d93 1
d98 4
d104 5
a128 1
  cpu = STATE_CPU (sd, 0);
d139 2
d143 2
d146 12
a157 1
  hw_cpu = sim_hw_parse (sd, "/m68hc11");
d160 1
a160 1
      sim_io_eprintf (sd, "m68hc11 cpu not found in device tree.");
d169 138
d329 4
a332 1
    return 0;
d341 1
a341 1
      sim_module_uninstall (sd);
a344 48
  device_tree = sim_hw_parse (sd, "/");
  if (hw_tree_find_property (device_tree, "/m68hc11/reg") == 0)
    {
      /* Allocate core managed memory */

      /* the monitor  */
      sim_do_commandf (sd, "memory region 0x%lx@@%d,0x%lx",
		       /* MONITOR_BASE, MONITOR_SIZE */
		       0x8000, M6811_RAM_LEVEL, 0x8000);
      sim_do_commandf (sd, "memory region 0x000@@%d,0x8000",
                       M6811_RAM_LEVEL);
      sim_hw_parse (sd, "/m68hc11/reg 0x1000 0x03F");
    }

  if (hw_tree_find_property (device_tree, "/m68hc11/m68hc11sio/reg") == 0)
    {
      sim_hw_parse (sd, "/m68hc11/m68hc11sio/reg 0x2b 0x5");
      sim_hw_parse (sd, "/m68hc11/m68hc11sio/backend stdio");
      sim_hw_parse (sd, "/m68hc11 > cpu-reset reset /m68hc11/m68hc11sio");
    }
  if (hw_tree_find_property (device_tree, "/m68hc11/m68hc11tim/reg") == 0)
    {
      /* M68hc11 Timer configuration. */
      sim_hw_parse (sd, "/m68hc11/m68hc11tim/reg 0x1b 0x5");
      sim_hw_parse (sd, "/m68hc11 > cpu-reset reset /m68hc11/m68hc11tim");
    }

  /* Create the SPI device.  */
  if (hw_tree_find_property (device_tree, "/m68hc11/m68hc11spi/reg") == 0)
    {
      sim_hw_parse (sd, "/m68hc11/m68hc11spi/reg 0x28 0x3");
      sim_hw_parse (sd, "/m68hc11 > cpu-reset reset /m68hc11/m68hc11spi");
    }
  if (hw_tree_find_property (device_tree, "/m68hc11/pram/reg") == 0)
    {
      /* M68hc11 persistent ram configuration. */
      sim_hw_parse (sd, "/m68hc11/nvram/reg 0x0 256");
      sim_hw_parse (sd, "/m68hc11/nvram/file m68hc11.ram");
      sim_hw_parse (sd, "/m68hc11/nvram/mode save-modified");
      /*sim_hw_parse (sd, "/m68hc11 > cpu-reset reset /m68hc11/pram"); */
    }
  if (hw_tree_find_property (device_tree, "/m68hc11/m68hc11eepr/reg") == 0)
    {
      sim_hw_parse (sd, "/m68hc11/m68hc11eepr/reg 0xb000 512");
      /* Connect the CPU reset to all devices. */
      sim_hw_parse (sd, "/m68hc11 > cpu-reset reset /m68hc11/m68hc11eepr");
    }

d351 1
a351 1
      sim_module_uninstall (sd);
d358 1
a358 1
      sim_module_uninstall (sd);
d366 1
a366 1
      sim_module_uninstall (sd);
d370 1
a370 6
  if (abfd != NULL)
    {
      cpu->cpu_elf_start = bfd_get_start_address (abfd);
    }

  sim_board_reset (sd);
d388 1
a388 1

d437 9
d447 1
a447 1
  sim_io_eprintf (sd, "  CPU Motorola 68HC11\n");
d456 1
a456 14
  sim_cpu *cpu;
  int i;

  cpu = STATE_CPU (sd, 0);

  if (abfd != NULL)
    {
      cpu->cpu_elf_start = bfd_get_start_address (abfd);
    }

  /* reset all state information */
  sim_board_reset (sd);

  return SIM_RC_OK;
d581 1
d583 1
d599 4
@


1.2
log
@Use address mapping levels for 68hc11 simulator (kill overlap hack)
@
text
@a327 26
  /* Get information about the number of pseudo registers.  */
  for (i = FIRST_SOFT_REGNUM; i <= ZD32_REGNUM; i++)
    {
      switch (i)
	{
	case TMP_REGNUM:
	  cpu->cpu_page0_reg[i - FIRST_SOFT_REGNUM] = 0;
	  break;
	case Z_REGNUM:
	case ZS_REGNUM:
	  cpu->cpu_page0_reg[i - FIRST_SOFT_REGNUM] = 2;
	  break;
	case XY_REGNUM:
	  cpu->cpu_page0_reg[i - FIRST_SOFT_REGNUM] = 4;
	  break;
	case FP_REGNUM:
	  cpu->cpu_page0_reg[i - FIRST_SOFT_REGNUM] = 6;
	  break;
	default:
	  cpu->cpu_page0_reg[i - FIRST_SOFT_REGNUM]
	    = ((i - FIRST_SOFT_REGNUM) * 2) - 2;
	  break;
	}
    }
  cpu->cpu_nb_pseudo_regs = 8;

a379 3

      /* Read a pseudo register. Pseudo registers are located at
         beginning of page 0.  Each of them is 2 bytes.  */
d381 1
a381 11
      if (rn < FIRST_SOFT_REGNUM || rn >= ZD32_REGNUM)
	{
	  val = 0;
	}
      else
	{
	  uint16 addr;

	  addr = cpu->cpu_page0_reg[rn - FIRST_SOFT_REGNUM];
	  val = memory_read16 (cpu, addr);
	}
a434 2
      /* Write a pseudo register.  Pseudo registers are located at
         beginning of page 0.  Each of them is 2 bytes.  */
a435 7
      if (rn >= FIRST_SOFT_REGNUM && rn <= ZD32_REGNUM)
	{
	  uint16 addr;

	  addr = cpu->cpu_page0_reg[rn - FIRST_SOFT_REGNUM];
	  memory_write16 (cpu, addr, val);
	}
@


1.1
log
@New simulator.
@
text
@d166 1
a166 1
      sim_do_commandf (sd, "memory region 0x%lx,0x%lx",
d168 3
a170 2
		       0x8000, 0x8000);
      sim_do_command (sd, " memory region 0x000,0x8000");
a198 1
      sim_hw_parse (sd, "/m68hc11/nvram/overlap? true");
@

