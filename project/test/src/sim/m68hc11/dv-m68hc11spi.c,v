head	1.15;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.15
	gdb_7_6-2013-04-26-release:1.15
	gdb_7_6-branch:1.15.0.2
	gdb_7_6-2013-03-12-branchpoint:1.15
	gdb_7_5_1-2012-11-29-release:1.14
	gdb_7_5-2012-08-17-release:1.14
	gdb_7_5-branch:1.14.0.2
	gdb_7_5-2012-07-18-branchpoint:1.14
	gdb_7_4_1-2012-04-26-release:1.13.4.1
	gdb_7_4-2012-01-24-release:1.13.4.1
	gdb_7_4-branch:1.13.0.4
	gdb_7_4-2011-12-13-branchpoint:1.13
	gdb_7_3_1-2011-09-04-release:1.13
	gdb_7_3-2011-07-26-release:1.13
	gdb_7_3-branch:1.13.0.2
	gdb_7_3-2011-04-01-branchpoint:1.13
	gdb_7_2-2010-09-02-release:1.12
	gdb_7_2-branch:1.12.0.4
	gdb_7_2-2010-07-07-branchpoint:1.12
	gdb_7_1-2010-03-18-release:1.12
	gdb_7_1-branch:1.12.0.2
	gdb_7_1-2010-02-18-branchpoint:1.12
	gdb_7_0_1-2009-12-22-release:1.11
	gdb_7_0-2009-10-06-release:1.11
	gdb_7_0-branch:1.11.0.4
	gdb_7_0-2009-09-16-branchpoint:1.11
	arc-sim-20090309:1.10
	msnyder-checkpoint-072509-branch:1.11.0.2
	msnyder-checkpoint-072509-branchpoint:1.11
	arc-insight_6_8-branch:1.10.0.16
	arc-insight_6_8-branchpoint:1.10
	insight_6_8-branch:1.10.0.14
	insight_6_8-branchpoint:1.10
	reverse-20081226-branch:1.10.0.12
	reverse-20081226-branchpoint:1.10
	multiprocess-20081120-branch:1.10.0.10
	multiprocess-20081120-branchpoint:1.10
	reverse-20080930-branch:1.10.0.8
	reverse-20080930-branchpoint:1.10
	reverse-20080717-branch:1.10.0.6
	reverse-20080717-branchpoint:1.10
	msnyder-reverse-20080609-branch:1.10.0.4
	msnyder-reverse-20080609-branchpoint:1.10
	drow-reverse-20070409-branch:1.8.0.2
	drow-reverse-20070409-branchpoint:1.8
	gdb_6_8-2008-03-27-release:1.10
	gdb_6_8-branch:1.10.0.2
	gdb_6_8-2008-02-26-branchpoint:1.10
	gdb_6_7_1-2007-10-29-release:1.9
	gdb_6_7-2007-10-10-release:1.9
	gdb_6_7-branch:1.9.0.2
	gdb_6_7-2007-09-07-branchpoint:1.9
	insight_6_6-20070208-release:1.7
	gdb_6_6-2006-12-18-release:1.7
	gdb_6_6-branch:1.7.0.54
	gdb_6_6-2006-11-15-branchpoint:1.7
	insight_6_5-20061003-release:1.7
	gdb-csl-symbian-6_4_50_20060226-12:1.7
	gdb-csl-sourcerygxx-3_4_4-25:1.7
	nickrob-async-20060828-mergepoint:1.7
	gdb-csl-symbian-6_4_50_20060226-11:1.7
	gdb-csl-sourcerygxx-4_1-17:1.7
	gdb-csl-20060226-branch-local-2:1.7
	gdb-csl-sourcerygxx-4_1-14:1.7
	gdb-csl-sourcerygxx-4_1-13:1.7
	gdb-csl-sourcerygxx-4_1-12:1.7
	gdb-csl-sourcerygxx-3_4_4-21:1.7
	gdb_6_5-20060621-release:1.7
	gdb-csl-sourcerygxx-4_1-9:1.7
	gdb-csl-sourcerygxx-4_1-8:1.7
	gdb-csl-sourcerygxx-4_1-7:1.7
	gdb-csl-arm-2006q1-6:1.7
	gdb-csl-sourcerygxx-4_1-6:1.7
	gdb-csl-symbian-6_4_50_20060226-10:1.7
	gdb-csl-symbian-6_4_50_20060226-9:1.7
	gdb-csl-symbian-6_4_50_20060226-8:1.7
	gdb-csl-coldfire-4_1-11:1.7
	gdb-csl-sourcerygxx-3_4_4-19:1.7
	gdb-csl-coldfire-4_1-10:1.7
	gdb_6_5-branch:1.7.0.52
	gdb_6_5-2006-05-14-branchpoint:1.7
	gdb-csl-sourcerygxx-4_1-5:1.7
	nickrob-async-20060513-branch:1.7.0.50
	nickrob-async-20060513-branchpoint:1.7
	gdb-csl-sourcerygxx-4_1-4:1.7
	msnyder-reverse-20060502-branch:1.7.0.48
	msnyder-reverse-20060502-branchpoint:1.7
	gdb-csl-morpho-4_1-4:1.7
	gdb-csl-sourcerygxx-3_4_4-17:1.7
	readline_5_1-import-branch:1.7.0.46
	readline_5_1-import-branchpoint:1.7
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.7
	gdb-csl-symbian-20060226-branch:1.7.0.44
	gdb-csl-symbian-20060226-branchpoint:1.7
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.7
	msnyder-reverse-20060331-branch:1.7.0.42
	msnyder-reverse-20060331-branchpoint:1.7
	gdb-csl-available-20060303-branch:1.7.0.40
	gdb-csl-available-20060303-branchpoint:1.7
	gdb-csl-20060226-branch:1.7.0.38
	gdb-csl-20060226-branchpoint:1.7
	gdb_6_4-20051202-release:1.7
	msnyder-fork-checkpoint-branch:1.7.0.36
	msnyder-fork-checkpoint-branchpoint:1.7
	gdb-csl-gxxpro-6_3-branch:1.7.0.34
	gdb-csl-gxxpro-6_3-branchpoint:1.7
	gdb_6_4-branch:1.7.0.32
	gdb_6_4-2005-11-01-branchpoint:1.7
	gdb-csl-arm-20051020-branch:1.7.0.30
	gdb-csl-arm-20051020-branchpoint:1.7
	msnyder-tracepoint-checkpoint-branch:1.7.0.28
	msnyder-tracepoint-checkpoint-branchpoint:1.7
	gdb-csl-arm-20050325-2005-q1b:1.7
	gdb-csl-arm-20050325-2005-q1a:1.7
	csl-arm-20050325-branch:1.7.0.26
	csl-arm-20050325-branchpoint:1.7
	gdb_6_3-20041109-release:1.7
	gdb_6_3-branch:1.7.0.22
	gdb_6_3-20041019-branchpoint:1.7
	drow_intercu-merge-20040921:1.7
	drow_intercu-merge-20040915:1.7
	jimb-gdb_6_2-e500-branch:1.7.0.24
	jimb-gdb_6_2-e500-branchpoint:1.7
	gdb_6_2-20040730-release:1.7
	gdb_6_2-branch:1.7.0.20
	gdb_6_2-2004-07-10-gmt-branchpoint:1.7
	gdb_6_1_1-20040616-release:1.7
	gdb_6_1-2004-04-05-release:1.7
	drow_intercu-merge-20040402:1.7
	drow_intercu-merge-20040327:1.7
	ezannoni_pie-20040323-branch:1.7.0.18
	ezannoni_pie-20040323-branchpoint:1.7
	cagney_tramp-20040321-mergepoint:1.7
	cagney_tramp-20040309-branch:1.7.0.16
	cagney_tramp-20040309-branchpoint:1.7
	gdb_6_1-branch:1.7.0.14
	gdb_6_1-2004-03-01-gmt-branchpoint:1.7
	drow_intercu-20040221-branch:1.7.0.12
	drow_intercu-20040221-branchpoint:1.7
	cagney_bfdfile-20040213-branch:1.7.0.10
	cagney_bfdfile-20040213-branchpoint:1.7
	drow-cplus-merge-20040208:1.7
	carlton_dictionary-20040126-merge:1.7
	cagney_bigcore-20040122-branch:1.7.0.8
	cagney_bigcore-20040122-branchpoint:1.7
	drow-cplus-merge-20040113:1.7
	drow-cplus-merge-20031224:1.7
	drow-cplus-merge-20031220:1.7
	carlton_dictionary-20031215-merge:1.7
	drow-cplus-merge-20031214:1.7
	carlton-dictionary-20031111-merge:1.7
	gdb_6_0-2003-10-04-release:1.6.50.1
	kettenis_sparc-20030918-branch:1.7.0.6
	kettenis_sparc-20030918-branchpoint:1.7
	carlton_dictionary-20030917-merge:1.7
	ezannoni_pie-20030916-branchpoint:1.7
	ezannoni_pie-20030916-branch:1.7.0.4
	cagney_x86i386-20030821-branch:1.7.0.2
	cagney_x86i386-20030821-branchpoint:1.7
	carlton_dictionary-20030805-merge:1.6
	carlton_dictionary-20030627-merge:1.6
	gdb_6_0-branch:1.6.0.50
	gdb_6_0-2003-06-23-branchpoint:1.6
	jimb-ppc64-linux-20030613-branch:1.6.0.48
	jimb-ppc64-linux-20030613-branchpoint:1.6
	cagney_convert-20030606-branch:1.6.0.46
	cagney_convert-20030606-branchpoint:1.6
	cagney_writestrings-20030508-branch:1.6.0.44
	cagney_writestrings-20030508-branchpoint:1.6
	jimb-ppc64-linux-20030528-branch:1.6.0.42
	jimb-ppc64-linux-20030528-branchpoint:1.6
	carlton_dictionary-20030523-merge:1.6
	cagney_fileio-20030521-branch:1.6.0.40
	cagney_fileio-20030521-branchpoint:1.6
	kettenis_i386newframe-20030517-mergepoint:1.6
	jimb-ppc64-linux-20030509-branch:1.6.0.38
	jimb-ppc64-linux-20030509-branchpoint:1.6
	kettenis_i386newframe-20030504-mergepoint:1.6
	carlton_dictionary-20030430-merge:1.6
	kettenis_i386newframe-20030419-branch:1.6.0.36
	kettenis_i386newframe-20030419-branchpoint:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	kettenis_i386newframe-20030406-branch:1.6.0.34
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.32
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.30
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.28
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.6
	offbyone-20030313-branch:1.6.0.26
	offbyone-20030313-branchpoint:1.6
	kettenis-i386newframe-20030308-branch:1.6.0.24
	kettenis-i386newframe-20030308-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.22
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.6
	interps-20030202-branch:1.6.0.20
	interps-20030202-branchpoint:1.6
	cagney-unwind-20030108-branch:1.6.0.18
	cagney-unwind-20030108-branchpoint:1.6
	carlton_dictionary-20021223-merge:1.6
	gdb_5_3-2002-12-12-release:1.6
	carlton_dictionary-20021115-merge:1.6
	kseitz_interps-20021105-merge:1.6
	kseitz_interps-20021103-merge:1.6
	drow-cplus-merge-20021020:1.6
	drow-cplus-merge-20021025:1.6
	carlton_dictionary-20021025-merge:1.6
	carlton_dictionary-20021011-merge:1.6
	drow-cplus-branch:1.6.0.16
	drow-cplus-branchpoint:1.6
	kseitz_interps-20020930-merge:1.6
	carlton_dictionary-20020927-merge:1.6
	carlton_dictionary-branch:1.6.0.14
	carlton_dictionary-20020920-branchpoint:1.6
	gdb_5_3-branch:1.6.0.12
	gdb_5_3-2002-09-04-branchpoint:1.6
	kseitz_interps-20020829-merge:1.6
	cagney_sysregs-20020825-branch:1.6.0.10
	cagney_sysregs-20020825-branchpoint:1.6
	readline_4_3-import-branch:1.6.0.8
	readline_4_3-import-branchpoint:1.6
	gdb_5_2_1-2002-07-23-release:1.5.8.1
	kseitz_interps-20020528-branch:1.6.0.6
	kseitz_interps-20020528-branchpoint:1.6
	cagney_regbuf-20020515-branch:1.6.0.4
	cagney_regbuf-20020515-branchpoint:1.6
	jimb-macro-020506-branch:1.6.0.2
	jimb-macro-020506-branchpoint:1.6
	gdb_5_2-2002-04-29-release:1.5.8.1
	gdb_5_2-branch:1.5.0.8
	gdb_5_2-2002-03-03-branchpoint:1.5
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.4
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.2
	gdb_5_1-2001-07-29-branchpoint:1.5
	insight-precleanup-2001-01-01:1.5;
locks; strict;
comment	@ * @;


1.15
date	2013.01.01.06.41.38;	author brobecke;	state Exp;
branches;
next	1.14;

1.14
date	2012.01.04.08.28.13;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2011.01.01.15.34.02;	author brobecke;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2010.01.01.10.03.31;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.14.10.53.08;	author brobecke;	state Exp;
branches;
next	1.10;

1.10
date	2008.01.01.22.53.25;	author drow;	state Exp;
branches;
next	1.9;

1.9
date	2007.08.24.14.28.37;	author brobecke;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.09.17.59.18;	author drow;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.08.21.02.24;	author ciceron;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.07.19.12.44;	author ciceron;	state Exp;
branches
	1.6.14.1
	1.6.16.1
	1.6.50.1;
next	1.5;

1.5
date	2000.11.26.21.41.31;	author ciceron;	state Exp;
branches
	1.5.8.1;
next	1.4;

1.4
date	2000.09.09.21.00.39;	author ciceron;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.05.20.49.46;	author ciceron;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.11.18.44.59;	author ciceron;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.27.11.23.39;	author cagney;	state Exp;
branches;
next	;

1.13.4.1
date	2012.01.06.04.54.53;	author brobecke;	state Exp;
branches;
next	;

1.6.14.1
date	2003.09.17.21.29.03;	author carlton;	state Exp;
branches;
next	;

1.6.16.1
date	2003.12.14.20.28.27;	author drow;	state Exp;
branches;
next	;

1.6.50.1
date	2003.08.08.21.04.44;	author ciceron;	state Exp;
branches;
next	;

1.5.8.1
date	2002.03.07.19.14.07;	author ciceron;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/*  dv-m68hc11spi.c -- Simulation of the 68HC11 SPI
    Copyright (C) 2000-2013 Free Software Foundation, Inc.
    Written by Stephane Carrez (stcarrez@@nerim.fr)
    (From a driver model Contributed by Cygnus Solutions.)

    This file is part of the program GDB, the GNU debugger.
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    
    */


#include "sim-main.h"
#include "hw-main.h"
#include "dv-sockser.h"
#include "sim-assert.h"


/* DEVICE

        m68hc11spi - m68hc11 SPI interface

   
   DESCRIPTION

        Implements the m68hc11 Synchronous Serial Peripheral Interface
        described in the m68hc11 user guide (Chapter 8 in pink book).
        The SPI I/O controller is directly connected to the CPU
        interrupt.  The simulator implements:

            - SPI clock emulation
            - Data transfer
            - Write collision detection
    

   PROPERTIES

        None

   
   PORTS

   reset (input)

        Reset port. This port is only used to simulate a reset of the SPI
        I/O controller. It should be connected to the RESET output of the cpu.

   */



/* port ID's */

enum
{
  RESET_PORT
};


static const struct hw_port_descriptor m68hc11spi_ports[] = 
{
  { "reset", RESET_PORT, 0, input_port, },
  { NULL, },
};


/* SPI */
struct m68hc11spi 
{
  /* Information about next character to be transmited.  */
  unsigned char tx_char;
  int           tx_bit;
  unsigned char mode;
  
  unsigned char rx_char;
  unsigned char rx_clear_scsr;
  unsigned char clk_pin;
  
  /* SPI clock rate (twice the real clock).  */
  unsigned int clock;
  
  /* Periodic SPI event.  */
  struct hw_event* spi_event;
};



/* Finish off the partially created hw device.  Attach our local
   callbacks.  Wire up our port names etc */

static hw_io_read_buffer_method m68hc11spi_io_read_buffer;
static hw_io_write_buffer_method m68hc11spi_io_write_buffer;
static hw_port_event_method m68hc11spi_port_event;
static hw_ioctl_method m68hc11spi_ioctl;

#define M6811_SPI_FIRST_REG (M6811_SPCR)
#define M6811_SPI_LAST_REG  (M6811_SPDR)


static void
attach_m68hc11spi_regs (struct hw *me,
                        struct m68hc11spi *controller)
{
  hw_attach_address (hw_parent (me), M6811_IO_LEVEL, io_map,
                     M6811_SPI_FIRST_REG,
                     M6811_SPI_LAST_REG - M6811_SPI_FIRST_REG + 1,
		     me);
}

static void
m68hc11spi_finish (struct hw *me)
{
  struct m68hc11spi *controller;

  controller = HW_ZALLOC (me, struct m68hc11spi);
  set_hw_data (me, controller);
  set_hw_io_read_buffer (me, m68hc11spi_io_read_buffer);
  set_hw_io_write_buffer (me, m68hc11spi_io_write_buffer);
  set_hw_ports (me, m68hc11spi_ports);
  set_hw_port_event (me, m68hc11spi_port_event);
#ifdef set_hw_ioctl
  set_hw_ioctl (me, m68hc11spi_ioctl);
#else
  me->to_ioctl = m68hc11spi_ioctl;
#endif

  /* Attach ourself to our parent bus.  */
  attach_m68hc11spi_regs (me, controller);

  /* Initialize to reset state.  */
  controller->spi_event = NULL;
  controller->rx_clear_scsr = 0;
}



/* An event arrives on an interrupt port */

static void
m68hc11spi_port_event (struct hw *me,
                       int my_port,
                       struct hw *source,
                       int source_port,
                       int level)
{
  SIM_DESC sd;
  struct m68hc11spi *controller;
  sim_cpu* cpu;
  unsigned8 val;
  
  controller = hw_data (me);
  sd         = hw_system (me);
  cpu        = STATE_CPU (sd, 0);  
  switch (my_port)
    {
    case RESET_PORT:
      {
	HW_TRACE ((me, "SPI reset"));

        /* Reset the state of SPI registers.  */
        controller->rx_clear_scsr = 0;
        if (controller->spi_event)
          {
            hw_event_queue_deschedule (me, controller->spi_event);
            controller->spi_event = 0;
          }

        val = 0;
        m68hc11spi_io_write_buffer (me, &val, io_map,
                                    (unsigned_word) M6811_SPCR, 1);
        break;
      }

    default:
      hw_abort (me, "Event on unknown port %d", my_port);
      break;
    }
}

static void
set_bit_port (struct hw *me, sim_cpu *cpu, int port, int mask, int value)
{
  uint8 val;
  
  if (value)
    val = cpu->ios[port] | mask;
  else
    val = cpu->ios[port] & ~mask;

  /* Set the new value and post an event to inform other devices
     that pin 'port' changed.  */
  m68hc11cpu_set_port (me, cpu, port, val);
}


/* When a character is sent/received by the SPI, the PD2..PD5 line
   are driven by the following signals:

	      B7	B6
      -----+---------+--------+---/-+-------
 MOSI      |    |    |   |    |     |
 MISO	   +---------+--------+---/-+
		____      ___
 CLK	_______/    \____/   \__		CPOL=0, CPHA=0
	_______	     ____     __
	       \____/    \___/			CPOL=1, CPHA=0
	   ____	     ____     __
	__/    \____/    \___/			CPOL=0, CPHA=1
	__	____      ___
	  \____/    \____/   \__		CPOL=1, CPHA=1

 SS ___                                 ____
       \__________________________//___/

 MISO = PD2
 MOSI = PD3
 SCK  = PD4
 SS   = PD5

*/

#define SPI_START_BYTE 0
#define SPI_START_BIT  1
#define SPI_MIDDLE_BIT 2

void
m68hc11spi_clock (struct hw *me, void *data)
{
  SIM_DESC sd;
  struct m68hc11spi* controller;
  sim_cpu *cpu;
  int check_interrupt = 0;
  
  controller = hw_data (me);
  sd         = hw_system (me);
  cpu        = STATE_CPU (sd, 0);

  /* Cleanup current event.  */
  if (controller->spi_event)
    {
      hw_event_queue_deschedule (me, controller->spi_event);
      controller->spi_event = 0;
    }

  /* Change a bit of data at each two SPI event.  */
  if (controller->mode == SPI_START_BIT)
    {
      /* Reflect the bit value on bit 2 of port D.  */
      set_bit_port (me, cpu, M6811_PORTD, (1 << 2),
                    (controller->tx_char & (1 << controller->tx_bit)));
      controller->tx_bit--;
      controller->mode = SPI_MIDDLE_BIT;
    }
  else if (controller->mode == SPI_MIDDLE_BIT)
    {
      controller->mode = SPI_START_BIT;
    }

  if (controller->mode == SPI_START_BYTE)
    {
      /* Start a new SPI transfer.  */
      
      /* TBD: clear SS output.  */
      controller->mode = SPI_START_BIT;
      controller->tx_bit = 7;
      set_bit_port (me, cpu, M6811_PORTD, (1 << 4), ~controller->clk_pin);
    }
  else
    {
      /* Change the SPI clock at each event on bit 4 of port D.  */
      controller->clk_pin = ~controller->clk_pin;
      set_bit_port (me, cpu, M6811_PORTD, (1 << 4), controller->clk_pin);
    }
  
  /* Transmit is now complete for this byte.  */
  if (controller->mode == SPI_START_BIT && controller->tx_bit < 0)
    {
      controller->rx_clear_scsr = 0;
      cpu->ios[M6811_SPSR] |= M6811_SPIF;
      if (cpu->ios[M6811_SPCR] & M6811_SPIE)
        check_interrupt = 1;
    }
  else
    {
      controller->spi_event = hw_event_queue_schedule (me, controller->clock,
                                                       m68hc11spi_clock,
                                                       NULL);
    }

  if (check_interrupt)
    interrupts_update_pending (&cpu->cpu_interrupts);
}

/* Flags of the SPCR register.  */
io_reg_desc spcr_desc[] = {
  { M6811_SPIE, "SPIE ", "Serial Peripheral Interrupt Enable" },
  { M6811_SPE,  "SPE  ",  "Serial Peripheral System Enable" },
  { M6811_DWOM, "DWOM ", "Port D Wire-OR mode option" },
  { M6811_MSTR, "MSTR ", "Master Mode Select" },
  { M6811_CPOL, "CPOL ", "Clock Polarity" },
  { M6811_CPHA, "CPHA ", "Clock Phase" },
  { M6811_SPR1, "SPR1 ", "SPI Clock Rate Select" },
  { M6811_SPR0, "SPR0 ", "SPI Clock Rate Select" },
  { 0,  0, 0 }
};


/* Flags of the SPSR register.  */
io_reg_desc spsr_desc[] = {
  { M6811_SPIF,	"SPIF ", "SPI Transfer Complete flag" },
  { M6811_WCOL, "WCOL ", "Write Collision" },
  { M6811_MODF, "MODF ", "Mode Fault" },
  { 0,  0, 0 }
};

static void
m68hc11spi_info (struct hw *me)
{
  SIM_DESC sd;
  uint16 base = 0;
  sim_cpu *cpu;
  struct m68hc11spi *controller;
  uint8 val;
  
  sd = hw_system (me);
  cpu = STATE_CPU (sd, 0);
  controller = hw_data (me);
  
  sim_io_printf (sd, "M68HC11 SPI:\n");

  base = cpu_get_io_base (cpu);

  val = cpu->ios[M6811_SPCR];
  print_io_byte (sd, "SPCR", spcr_desc, val, base + M6811_SPCR);
  sim_io_printf (sd, "\n");

  val = cpu->ios[M6811_SPSR];
  print_io_byte (sd, "SPSR", spsr_desc, val, base + M6811_SPSR);
  sim_io_printf (sd, "\n");

  if (controller->spi_event)
    {
      signed64 t;

      sim_io_printf (sd, "  SPI has %d bits to send\n",
                     controller->tx_bit + 1);
      t = hw_event_remain_time (me, controller->spi_event);
      sim_io_printf (sd, "  SPI current bit-cycle finished in %s\n",
		     cycle_to_string (cpu, t, PRINT_TIME | PRINT_CYCLE));

      t += (controller->tx_bit + 1) * 2 * controller->clock;
      sim_io_printf (sd, "  SPI operation finished in %s\n",
		     cycle_to_string (cpu, t, PRINT_TIME | PRINT_CYCLE));
    }
}

static int
m68hc11spi_ioctl (struct hw *me,
                  hw_ioctl_request request,
                  va_list ap)
{
  m68hc11spi_info (me);
  return 0;
}

/* generic read/write */

static unsigned
m68hc11spi_io_read_buffer (struct hw *me,
                           void *dest,
                           int space,
                           unsigned_word base,
                           unsigned nr_bytes)
{
  SIM_DESC sd;
  struct m68hc11spi *controller;
  sim_cpu *cpu;
  unsigned8 val;
  
  HW_TRACE ((me, "read 0x%08lx %d", (long) base, (int) nr_bytes));

  sd  = hw_system (me);
  cpu = STATE_CPU (sd, 0);
  controller = hw_data (me);

  switch (base)
    {
    case M6811_SPSR:
      controller->rx_clear_scsr = cpu->ios[M6811_SCSR]
        & (M6811_SPIF | M6811_WCOL | M6811_MODF);
      
    case M6811_SPCR:
      val = cpu->ios[base];
      break;
      
    case M6811_SPDR:
      if (controller->rx_clear_scsr)
        {
          cpu->ios[M6811_SPSR] &= ~controller->rx_clear_scsr;
          controller->rx_clear_scsr = 0;
          interrupts_update_pending (&cpu->cpu_interrupts);
        }
      val = controller->rx_char;
      break;
      
    default:
      return 0;
    }
  *((unsigned8*) dest) = val;
  return 1;
}

static unsigned
m68hc11spi_io_write_buffer (struct hw *me,
                            const void *source,
                            int space,
                            unsigned_word base,
                            unsigned nr_bytes)
{
  SIM_DESC sd;
  struct m68hc11spi *controller;
  sim_cpu *cpu;
  unsigned8 val;

  HW_TRACE ((me, "write 0x%08lx %d", (long) base, (int) nr_bytes));

  sd  = hw_system (me);
  cpu = STATE_CPU (sd, 0);
  controller = hw_data (me);
  
  val = *((const unsigned8*) source);
  switch (base)
    {
    case M6811_SPCR:
      cpu->ios[M6811_SPCR] = val;

      /* The SPI clock rate is 2, 4, 16, 32 of the internal CPU clock.
         We have to drive the clock pin and need a 2x faster clock.  */
      switch (val & (M6811_SPR1 | M6811_SPR0))
        {
        case 0:
          controller->clock = 1;
          break;

        case 1:
          controller->clock = 2;
          break;

        case 2:
          controller->clock = 8;
          break;

        default:
          controller->clock = 16;
          break;
        }

      /* Set the clock pin.  */
      if ((val & M6811_CPOL)
          && (controller->spi_event == 0
              || ((val & M6811_CPHA) && controller->mode == 1)))
        controller->clk_pin = 1;
      else
        controller->clk_pin = 0;

      set_bit_port (me, cpu, M6811_PORTD, (1 << 4), controller->clk_pin);
      break;
      
      /* Can't write to SPSR.  */
    case M6811_SPSR:
      break;
      
    case M6811_SPDR:
      if (!(cpu->ios[M6811_SPCR] & M6811_SPE))
        {
          return 0;
        }

      if (controller->rx_clear_scsr)
        {
          cpu->ios[M6811_SPSR] &= ~controller->rx_clear_scsr;
          controller->rx_clear_scsr = 0;
          interrupts_update_pending (&cpu->cpu_interrupts);
        }

      /* If transfer is taking place, a write to SPDR
         generates a collision.  */
      if (controller->spi_event)
        {
          cpu->ios[M6811_SPSR] |= M6811_WCOL;
          break;
        }

      /* Refuse the write if there was no read of SPSR.  */
      /* ???? TBD. */

      /* Prepare to send a byte.  */
      controller->tx_char = val;
      controller->mode   = SPI_START_BYTE;

      /* Toggle clock pin internal value when CPHA is 0 so that
         it will really change in the middle of a bit.  */
      if (!(cpu->ios[M6811_SPCR] & M6811_CPHA))
        controller->clk_pin = ~controller->clk_pin;

      cpu->ios[M6811_SPDR] = val;

      /* Activate transmission.  */
      m68hc11spi_clock (me, NULL);
      break;

    default:
      return 0;
    }
  return nr_bytes;
}     


const struct hw_descriptor dv_m68hc11spi_descriptor[] = {
  { "m68hc11spi", m68hc11spi_finish },
  { "m68hc12spi", m68hc11spi_finish },
  { NULL },
};

@


1.14
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 2
    Copyright (C) 2000, 2002-2003, 2007-2012 Free Software Foundation,
    Inc.
@


1.13
log
@run copyright.sh for 2011.
@
text
@d2 2
a3 2
    Copyright (C) 2000, 2002, 2003, 2007, 2008, 2009, 2010, 2011
    Free Software Foundation, Inc.
@


1.13.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 2
    Copyright (C) 2000, 2002-2003, 2007-2012 Free Software Foundation,
    Inc.
@


1.12
log
@Update copyright notices to add year 2010.
@
text
@d2 1
a2 1
    Copyright (C) 2000, 2002, 2003, 2007, 2008, 2009, 2010
@


1.11
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d2 1
a2 1
    Copyright (C) 2000, 2002, 2003, 2007, 2008, 2009
@


1.10
log
@	Updated copyright notices for most files.
@
text
@d2 2
a3 1
    Copyright (C) 2000, 2002, 2003, 2007, 2008 Free Software Foundation, Inc.
@


1.9
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d2 1
a2 1
    Copyright (C) 2000, 2002, 2003, 2007 Free Software Foundation, Inc.
@


1.8
log
@Copyright updates for 2007.
@
text
@d10 1
a10 1
    the Free Software Foundation; either version 2 of the License, or
d12 1
a12 1
    
d17 1
a17 1
    
d19 1
a19 2
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@


1.7
log
@	* dv-m68hc11tim.c (cycle_to_string): Add flags parameter to better
	control the translation.
	(m68hc11tim_print_timer): Update cycle_to_string conversion.
	(m68hc11tim_timer_event): Fix handling of output
	compare register with its interrupts.
	(m68hc11tim_io_write_buffer): Check output compare
	after setting M6811_TMSK1.
	(m68hc11tim_io_read_buffer): Fix compilation warning.
	* dv-m68hc11.c (m68hc11_option_handler): Likewise.
	* dv-m68hc11spi.c (m68hc11spi_info): Likewise.
	* dv-m68hc11sio.c (m68hc11sio_info): Likewise.
	* interrupts.c (interrupts_info): Likewise.
	(interrupts_reset): Recognize bootstrap mode.
	* sim-main.h (PRINT_CYCLE, PRINT_TIME): New defines.
	(_sim_cpu): Add cpu_start_mode.
	(cycle_to_string): Add flags member.
	* m68hc11_sim.c (OPTION_CPU_BOOTSTRAP): New option.
	(cpu_options): Declare new option bootstrap.
	(cpu_option_handler): Handle it.
	(cpu_info): Update call to cycle_to_string.
@
text
@d2 1
a2 1
    Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.
@


1.6
log
@	* interp.c (sim_hw_configure): Save the HW cpu pointer in the
	cpu struct.
	(sim_hw_configure): Connect the capture input/output events.
	* sim-main.h (_sim_cpu): New member hw_cpu.
	(m68hc11cpu_set_oscillator): Declare.
	(m68hc11cpu_clear_oscillator): Declare.
	(m68hc11cpu_set_port): Declare.
	* dv-m68hc11.c (m68hc11_options): New for oscillator commands.
	(m68hc11cpu_ports): New input ports and output ports to reflect
	the HC11 IOs.
	(m68hc11_delete): Cleanup any running oscillator.
	(attach_m68hc11_regs): Create the input oscillators.
	(make_oscillator): New function.
	(find_oscillator): New function.
	(oscillator_handler): New function.
	(reset_oscillators): New function.
	(m68hc11cpu_port_event): Handle the new input ports.
	(m68hc11cpu_set_oscillator): New function.
	(m68hc11cpu_clear_oscillator): New function.
	(get_frequency): New function.
	(m68hc11_option_handler): New function.
	(m68hc11cpu_set_port): New function.
	(m68hc11cpu_io_write): Post the port output events.
	* dv-m68hc11spi.c (set_bit_port): Use m68hc11cpu_set_port to set
	the output port value.
	* dv-m68hc11tim.c (m68hc11tim_port_event): Handle CAPTURE event
	by latching the TCNT value in the register.
@
text
@d2 2
a3 2
    Copyright (C) 2000, 2002 Free Software Foundation, Inc.
    Written by Stephane Carrez (stcarrez@@worldnet.fr)
d361 1
a361 1
		     cycle_to_string (cpu, t));
d365 1
a365 1
		     cycle_to_string (cpu, t));
@


1.6.16.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 2
a3 2
    Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.
    Written by Stephane Carrez (stcarrez@@nerim.fr)
d361 1
a361 1
		     cycle_to_string (cpu, t, PRINT_TIME | PRINT_CYCLE));
d365 1
a365 1
		     cycle_to_string (cpu, t, PRINT_TIME | PRINT_CYCLE));
@


1.6.14.1
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d2 2
a3 2
    Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.
    Written by Stephane Carrez (stcarrez@@nerim.fr)
d361 1
a361 1
		     cycle_to_string (cpu, t, PRINT_TIME | PRINT_CYCLE));
d365 1
a365 1
		     cycle_to_string (cpu, t, PRINT_TIME | PRINT_CYCLE));
@


1.6.50.1
log
@	* dv-m68hc11tim.c (cycle_to_string): Add flags parameter to better
	control the translation.
	(m68hc11tim_print_timer): Update cycle_to_string conversion.
	(m68hc11tim_timer_event): Fix handling of output
	compare register with its interrupts.
	(m68hc11tim_io_write_buffer): Check output compare
	after setting M6811_TMSK1.
	(m68hc11tim_io_read_buffer): Fix compilation warning.
	* dv-m68hc11.c (m68hc11_option_handler): Likewise.
	* dv-m68hc11spi.c (m68hc11spi_info): Likewise.
	* dv-m68hc11sio.c (m68hc11sio_info): Likewise.
	* interrupts.c (interrupts_info): Likewise.
	(interrupts_reset): Recognize bootstrap mode.
	* sim-main.h (PRINT_CYCLE, PRINT_TIME): New defines.
	(_sim_cpu): Add cpu_start_mode.
	(cycle_to_string): Add flags member.
	* m68hc11_sim.c (OPTION_CPU_BOOTSTRAP): New option.
	(cpu_options): Declare new option bootstrap.
	(cpu_option_handler): Handle it.
	(cpu_info): Update call to cycle_to_string.
@
text
@d2 2
a3 2
    Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.
    Written by Stephane Carrez (stcarrez@@nerim.fr)
d361 1
a361 1
		     cycle_to_string (cpu, t, PRINT_TIME | PRINT_CYCLE));
d365 1
a365 1
		     cycle_to_string (cpu, t, PRINT_TIME | PRINT_CYCLE));
@


1.5
log
@Preliminary support for 68HC12
@
text
@d2 1
a2 1
    Copyright (C) 2000 Free Software Foundation, Inc.
d195 2
a196 4
  /* TODO: Post an event to inform other devices that pin 'port' changes.
     This has only a sense if we provide some device that is logically
     connected to these pin ports (SCLK and MOSI) and that handles
     the SPI protocol.  */
d198 1
a198 1
    cpu->ios[port] |= mask;
d200 5
a204 1
    cpu->ios[port] &= ~mask;
@


1.5.8.1
log
@	* interp.c (sim_hw_configure): Save the HW cpu pointer in the
	cpu struct.
	(sim_hw_configure): Connect the capture input/output events.
	* sim-main.h (_sim_cpu): New member hw_cpu.
	(m68hc11cpu_set_oscillator): Declare.
	(m68hc11cpu_clear_oscillator): Declare.
	(m68hc11cpu_set_port): Declare.
	* dv-m68hc11.c (m68hc11_options): New for oscillator commands.
	(m68hc11cpu_ports): New input ports and output ports to reflect
	the HC11 IOs.
	(m68hc11_delete): Cleanup any running oscillator.
	(attach_m68hc11_regs): Create the input oscillators.
	(make_oscillator): New function.
	(find_oscillator): New function.
	(oscillator_handler): New function.
	(reset_oscillators): New function.
	(m68hc11cpu_port_event): Handle the new input ports.
	(m68hc11cpu_set_oscillator): New function.
	(m68hc11cpu_clear_oscillator): New function.
	(get_frequency): New function.
	(m68hc11_option_handler): New function.
	(m68hc11cpu_set_port): New function.
	(m68hc11cpu_io_write): Post the port output events.
	* dv-m68hc11spi.c (set_bit_port): Use m68hc11cpu_set_port to set
	the output port value.
	* dv-m68hc11tim.c (m68hc11tim_port_event): Handle CAPTURE event
	by latching the TCNT value in the register.
@
text
@d2 1
a2 1
    Copyright (C) 2000, 2002 Free Software Foundation, Inc.
d195 4
a198 2
  uint8 val;
  
d200 1
a200 1
    val = cpu->ios[port] | mask;
d202 1
a202 5
    val = cpu->ios[port] & ~mask;

  /* Set the new value and post an event to inform other devices
     that pin 'port' changed.  */
  m68hc11cpu_set_port (me, cpu, port, val);
@


1.4
log
@	* sim-main.h: Define cycle_to_string.
	* dv-m68hc11tim.c (cycle_to_string): New function to translate
	the cpu cycle into some formatted time string.
	(m68hc11tim_print_timer): Use it.
	* dv-m68hc11sio.c (m68hc11sio_info): Use cycle_to_string.
	* dv-m68hc11spi.c (m68hc11spi_info): Likewise.
	* interrupts.c (interrupts_info): Likewise.
	* m68hc11_sim.c (cpu_info): Likewise.
@
text
@d530 2
a531 1
  { "m68hc11spi", m68hc11spi_finish, },
@


1.3
log
@Fix 68HC11 SPI simulator
@
text
@d358 6
a363 2
      sim_io_printf (sd, "  SPI operation finished in %ld cycles\n",
		     (long) t);
@


1.2
log
@Use address mapping levels for 68hc11 simulator (kill overlap hack)
@
text
@d232 3
a234 2
#define SPI_START_BIT  0
#define SPI_MIDDLE_BIT 1
d264 1
a264 1
  else
d269 3
a271 3
  /* Change the SPI clock at each event on bit 4 of port D.  */
  controller->clk_pin = ~controller->clk_pin;
  set_bit_port (me, cpu, M6811_PORTD, (1 << 4), controller->clk_pin);
d273 12
d355 2
d407 1
d485 7
d505 1
a505 2
      controller->tx_bit = 7;
      controller->mode   = 0;
@


1.1
log
@New simulator.
@
text
@d116 1
a116 1
  hw_attach_address (hw_parent (me), 0, io_map,
a127 1
  me->overlap_mode_hw = 1;
@

