head	1.21;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.21
	gdb_7_6-2013-04-26-release:1.21
	gdb_7_6-branch:1.21.0.2
	gdb_7_6-2013-03-12-branchpoint:1.21
	gdb_7_5_1-2012-11-29-release:1.20
	gdb_7_5-2012-08-17-release:1.20
	gdb_7_5-branch:1.20.0.2
	gdb_7_5-2012-07-18-branchpoint:1.20
	gdb_7_4_1-2012-04-26-release:1.19.4.1
	gdb_7_4-2012-01-24-release:1.19.4.1
	gdb_7_4-branch:1.19.0.4
	gdb_7_4-2011-12-13-branchpoint:1.19
	gdb_7_3_1-2011-09-04-release:1.19
	gdb_7_3-2011-07-26-release:1.19
	gdb_7_3-branch:1.19.0.2
	gdb_7_3-2011-04-01-branchpoint:1.19
	gdb_7_2-2010-09-02-release:1.18
	gdb_7_2-branch:1.18.0.4
	gdb_7_2-2010-07-07-branchpoint:1.18
	gdb_7_1-2010-03-18-release:1.18
	gdb_7_1-branch:1.18.0.2
	gdb_7_1-2010-02-18-branchpoint:1.18
	gdb_7_0_1-2009-12-22-release:1.17
	gdb_7_0-2009-10-06-release:1.17
	gdb_7_0-branch:1.17.0.4
	gdb_7_0-2009-09-16-branchpoint:1.17
	arc-sim-20090309:1.16
	msnyder-checkpoint-072509-branch:1.17.0.2
	msnyder-checkpoint-072509-branchpoint:1.17
	arc-insight_6_8-branch:1.16.0.16
	arc-insight_6_8-branchpoint:1.16
	insight_6_8-branch:1.16.0.14
	insight_6_8-branchpoint:1.16
	reverse-20081226-branch:1.16.0.12
	reverse-20081226-branchpoint:1.16
	multiprocess-20081120-branch:1.16.0.10
	multiprocess-20081120-branchpoint:1.16
	reverse-20080930-branch:1.16.0.8
	reverse-20080930-branchpoint:1.16
	reverse-20080717-branch:1.16.0.6
	reverse-20080717-branchpoint:1.16
	msnyder-reverse-20080609-branch:1.16.0.4
	msnyder-reverse-20080609-branchpoint:1.16
	drow-reverse-20070409-branch:1.14.0.2
	drow-reverse-20070409-branchpoint:1.14
	gdb_6_8-2008-03-27-release:1.16
	gdb_6_8-branch:1.16.0.2
	gdb_6_8-2008-02-26-branchpoint:1.16
	gdb_6_7_1-2007-10-29-release:1.15
	gdb_6_7-2007-10-10-release:1.15
	gdb_6_7-branch:1.15.0.2
	gdb_6_7-2007-09-07-branchpoint:1.15
	insight_6_6-20070208-release:1.13
	gdb_6_6-2006-12-18-release:1.13
	gdb_6_6-branch:1.13.0.54
	gdb_6_6-2006-11-15-branchpoint:1.13
	insight_6_5-20061003-release:1.13
	gdb-csl-symbian-6_4_50_20060226-12:1.13
	gdb-csl-sourcerygxx-3_4_4-25:1.13
	nickrob-async-20060828-mergepoint:1.13
	gdb-csl-symbian-6_4_50_20060226-11:1.13
	gdb-csl-sourcerygxx-4_1-17:1.13
	gdb-csl-20060226-branch-local-2:1.13
	gdb-csl-sourcerygxx-4_1-14:1.13
	gdb-csl-sourcerygxx-4_1-13:1.13
	gdb-csl-sourcerygxx-4_1-12:1.13
	gdb-csl-sourcerygxx-3_4_4-21:1.13
	gdb_6_5-20060621-release:1.13
	gdb-csl-sourcerygxx-4_1-9:1.13
	gdb-csl-sourcerygxx-4_1-8:1.13
	gdb-csl-sourcerygxx-4_1-7:1.13
	gdb-csl-arm-2006q1-6:1.13
	gdb-csl-sourcerygxx-4_1-6:1.13
	gdb-csl-symbian-6_4_50_20060226-10:1.13
	gdb-csl-symbian-6_4_50_20060226-9:1.13
	gdb-csl-symbian-6_4_50_20060226-8:1.13
	gdb-csl-coldfire-4_1-11:1.13
	gdb-csl-sourcerygxx-3_4_4-19:1.13
	gdb-csl-coldfire-4_1-10:1.13
	gdb_6_5-branch:1.13.0.52
	gdb_6_5-2006-05-14-branchpoint:1.13
	gdb-csl-sourcerygxx-4_1-5:1.13
	nickrob-async-20060513-branch:1.13.0.50
	nickrob-async-20060513-branchpoint:1.13
	gdb-csl-sourcerygxx-4_1-4:1.13
	msnyder-reverse-20060502-branch:1.13.0.48
	msnyder-reverse-20060502-branchpoint:1.13
	gdb-csl-morpho-4_1-4:1.13
	gdb-csl-sourcerygxx-3_4_4-17:1.13
	readline_5_1-import-branch:1.13.0.46
	readline_5_1-import-branchpoint:1.13
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.13
	gdb-csl-symbian-20060226-branch:1.13.0.44
	gdb-csl-symbian-20060226-branchpoint:1.13
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.13
	msnyder-reverse-20060331-branch:1.13.0.42
	msnyder-reverse-20060331-branchpoint:1.13
	gdb-csl-available-20060303-branch:1.13.0.40
	gdb-csl-available-20060303-branchpoint:1.13
	gdb-csl-20060226-branch:1.13.0.38
	gdb-csl-20060226-branchpoint:1.13
	gdb_6_4-20051202-release:1.13
	msnyder-fork-checkpoint-branch:1.13.0.36
	msnyder-fork-checkpoint-branchpoint:1.13
	gdb-csl-gxxpro-6_3-branch:1.13.0.34
	gdb-csl-gxxpro-6_3-branchpoint:1.13
	gdb_6_4-branch:1.13.0.32
	gdb_6_4-2005-11-01-branchpoint:1.13
	gdb-csl-arm-20051020-branch:1.13.0.30
	gdb-csl-arm-20051020-branchpoint:1.13
	msnyder-tracepoint-checkpoint-branch:1.13.0.28
	msnyder-tracepoint-checkpoint-branchpoint:1.13
	gdb-csl-arm-20050325-2005-q1b:1.13
	gdb-csl-arm-20050325-2005-q1a:1.13
	csl-arm-20050325-branch:1.13.0.26
	csl-arm-20050325-branchpoint:1.13
	gdb_6_3-20041109-release:1.13
	gdb_6_3-branch:1.13.0.22
	gdb_6_3-20041019-branchpoint:1.13
	drow_intercu-merge-20040921:1.13
	drow_intercu-merge-20040915:1.13
	jimb-gdb_6_2-e500-branch:1.13.0.24
	jimb-gdb_6_2-e500-branchpoint:1.13
	gdb_6_2-20040730-release:1.13
	gdb_6_2-branch:1.13.0.20
	gdb_6_2-2004-07-10-gmt-branchpoint:1.13
	gdb_6_1_1-20040616-release:1.13
	gdb_6_1-2004-04-05-release:1.13
	drow_intercu-merge-20040402:1.13
	drow_intercu-merge-20040327:1.13
	ezannoni_pie-20040323-branch:1.13.0.18
	ezannoni_pie-20040323-branchpoint:1.13
	cagney_tramp-20040321-mergepoint:1.13
	cagney_tramp-20040309-branch:1.13.0.16
	cagney_tramp-20040309-branchpoint:1.13
	gdb_6_1-branch:1.13.0.14
	gdb_6_1-2004-03-01-gmt-branchpoint:1.13
	drow_intercu-20040221-branch:1.13.0.12
	drow_intercu-20040221-branchpoint:1.13
	cagney_bfdfile-20040213-branch:1.13.0.10
	cagney_bfdfile-20040213-branchpoint:1.13
	drow-cplus-merge-20040208:1.13
	carlton_dictionary-20040126-merge:1.13
	cagney_bigcore-20040122-branch:1.13.0.8
	cagney_bigcore-20040122-branchpoint:1.13
	drow-cplus-merge-20040113:1.13
	drow-cplus-merge-20031224:1.13
	drow-cplus-merge-20031220:1.13
	carlton_dictionary-20031215-merge:1.13
	drow-cplus-merge-20031214:1.13
	carlton-dictionary-20031111-merge:1.13
	gdb_6_0-2003-10-04-release:1.9.44.4
	kettenis_sparc-20030918-branch:1.13.0.6
	kettenis_sparc-20030918-branchpoint:1.13
	carlton_dictionary-20030917-merge:1.13
	ezannoni_pie-20030916-branchpoint:1.13
	ezannoni_pie-20030916-branch:1.13.0.4
	cagney_x86i386-20030821-branch:1.13.0.2
	cagney_x86i386-20030821-branchpoint:1.13
	carlton_dictionary-20030805-merge:1.9
	carlton_dictionary-20030627-merge:1.9
	gdb_6_0-branch:1.9.0.44
	gdb_6_0-2003-06-23-branchpoint:1.9
	jimb-ppc64-linux-20030613-branch:1.9.0.42
	jimb-ppc64-linux-20030613-branchpoint:1.9
	cagney_convert-20030606-branch:1.9.0.40
	cagney_convert-20030606-branchpoint:1.9
	cagney_writestrings-20030508-branch:1.9.0.38
	cagney_writestrings-20030508-branchpoint:1.9
	jimb-ppc64-linux-20030528-branch:1.9.0.36
	jimb-ppc64-linux-20030528-branchpoint:1.9
	carlton_dictionary-20030523-merge:1.9
	cagney_fileio-20030521-branch:1.9.0.34
	cagney_fileio-20030521-branchpoint:1.9
	kettenis_i386newframe-20030517-mergepoint:1.9
	jimb-ppc64-linux-20030509-branch:1.9.0.32
	jimb-ppc64-linux-20030509-branchpoint:1.9
	kettenis_i386newframe-20030504-mergepoint:1.9
	carlton_dictionary-20030430-merge:1.9
	kettenis_i386newframe-20030419-branch:1.9.0.30
	kettenis_i386newframe-20030419-branchpoint:1.9
	carlton_dictionary-20030416-merge:1.9
	cagney_frameaddr-20030409-mergepoint:1.9
	kettenis_i386newframe-20030406-branch:1.9.0.28
	kettenis_i386newframe-20030406-branchpoint:1.9
	cagney_frameaddr-20030403-branchpoint:1.9
	cagney_frameaddr-20030403-branch:1.9.0.26
	cagney_framebase-20030330-mergepoint:1.9
	cagney_framebase-20030326-branch:1.9.0.24
	cagney_framebase-20030326-branchpoint:1.9
	cagney_lazyid-20030317-branch:1.9.0.22
	cagney_lazyid-20030317-branchpoint:1.9
	kettenis-i386newframe-20030316-mergepoint:1.9
	offbyone-20030313-branch:1.9.0.20
	offbyone-20030313-branchpoint:1.9
	kettenis-i386newframe-20030308-branch:1.9.0.18
	kettenis-i386newframe-20030308-branchpoint:1.9
	carlton_dictionary-20030305-merge:1.9
	cagney_offbyone-20030303-branch:1.9.0.16
	cagney_offbyone-20030303-branchpoint:1.9
	carlton_dictionary-20030207-merge:1.9
	interps-20030202-branch:1.9.0.14
	interps-20030202-branchpoint:1.9
	cagney-unwind-20030108-branch:1.9.0.12
	cagney-unwind-20030108-branchpoint:1.9
	carlton_dictionary-20021223-merge:1.9
	gdb_5_3-2002-12-12-release:1.9
	carlton_dictionary-20021115-merge:1.9
	kseitz_interps-20021105-merge:1.9
	kseitz_interps-20021103-merge:1.9
	drow-cplus-merge-20021020:1.9
	drow-cplus-merge-20021025:1.9
	carlton_dictionary-20021025-merge:1.9
	carlton_dictionary-20021011-merge:1.9
	drow-cplus-branch:1.9.0.10
	drow-cplus-branchpoint:1.9
	kseitz_interps-20020930-merge:1.9
	carlton_dictionary-20020927-merge:1.9
	carlton_dictionary-branch:1.9.0.8
	carlton_dictionary-20020920-branchpoint:1.9
	gdb_5_3-branch:1.9.0.6
	gdb_5_3-2002-09-04-branchpoint:1.9
	kseitz_interps-20020829-merge:1.9
	cagney_sysregs-20020825-branch:1.9.0.4
	cagney_sysregs-20020825-branchpoint:1.9
	readline_4_3-import-branch:1.9.0.2
	readline_4_3-import-branchpoint:1.9
	gdb_5_2_1-2002-07-23-release:1.5.8.2
	kseitz_interps-20020528-branch:1.7.0.6
	kseitz_interps-20020528-branchpoint:1.7
	cagney_regbuf-20020515-branch:1.7.0.4
	cagney_regbuf-20020515-branchpoint:1.7
	jimb-macro-020506-branch:1.7.0.2
	jimb-macro-020506-branchpoint:1.7
	gdb_5_2-2002-04-29-release:1.5.8.2
	gdb_5_2-branch:1.5.0.8
	gdb_5_2-2002-03-03-branchpoint:1.5
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.4
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.2
	gdb_5_1-2001-07-29-branchpoint:1.5
	insight-precleanup-2001-01-01:1.4;
locks; strict;
comment	@ * @;


1.21
date	2013.01.01.06.41.38;	author brobecke;	state Exp;
branches;
next	1.20;

1.20
date	2012.01.04.08.28.14;	author brobecke;	state Exp;
branches;
next	1.19;

1.19
date	2011.01.01.15.34.02;	author brobecke;	state Exp;
branches
	1.19.4.1;
next	1.18;

1.18
date	2010.01.01.10.03.31;	author brobecke;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.14.10.53.08;	author brobecke;	state Exp;
branches;
next	1.16;

1.16
date	2008.01.01.22.53.25;	author drow;	state Exp;
branches;
next	1.15;

1.15
date	2007.08.24.14.28.37;	author brobecke;	state Exp;
branches;
next	1.14;

1.14
date	2007.01.09.17.59.18;	author drow;	state Exp;
branches;
next	1.13;

1.13
date	2003.08.08.21.00.55;	author ciceron;	state Exp;
branches;
next	1.12;

1.12
date	2003.08.08.20.42.21;	author ciceron;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.08.20.31.10;	author ciceron;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.08.20.25.50;	author ciceron;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.13.07.46.09;	author ciceron;	state Exp;
branches
	1.9.8.1
	1.9.10.1
	1.9.44.1;
next	1.8;

1.8
date	2002.06.09.15.45.48;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.07.19.12.44;	author ciceron;	state Exp;
branches
	1.7.4.1
	1.7.6.1;
next	1.6;

1.6
date	2002.03.07.19.06.34;	author ciceron;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.20.15.40.27;	author ciceron;	state Exp;
branches
	1.5.8.1;
next	1.4;

1.4
date	2000.09.10.14.05.29;	author ciceron;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.09.21.00.39;	author ciceron;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.11.18.44.59;	author ciceron;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.27.11.23.39;	author cagney;	state Exp;
branches;
next	;

1.19.4.1
date	2012.01.06.04.54.53;	author brobecke;	state Exp;
branches;
next	;

1.9.8.1
date	2003.09.17.21.29.03;	author carlton;	state Exp;
branches;
next	;

1.9.10.1
date	2003.12.14.20.28.27;	author drow;	state Exp;
branches;
next	;

1.9.44.1
date	2003.08.08.20.26.28;	author ciceron;	state Exp;
branches;
next	1.9.44.2;

1.9.44.2
date	2003.08.08.20.34.15;	author ciceron;	state Exp;
branches;
next	1.9.44.3;

1.9.44.3
date	2003.08.08.20.45.31;	author ciceron;	state Exp;
branches;
next	1.9.44.4;

1.9.44.4
date	2003.08.08.21.04.44;	author ciceron;	state Exp;
branches;
next	;

1.7.4.1
date	2002.06.15.16.43.26;	author cagney;	state Exp;
branches;
next	;

1.7.6.1
date	2002.06.20.01.40.01;	author kseitz;	state Exp;
branches;
next	1.7.6.2;

1.7.6.2
date	2002.08.30.22.52.58;	author kseitz;	state Exp;
branches;
next	;

1.5.8.1
date	2002.03.07.19.07.13;	author ciceron;	state Exp;
branches;
next	1.5.8.2;

1.5.8.2
date	2002.03.07.19.14.07;	author ciceron;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* sim-main.h -- Simulator for Motorola 68HC11 & 68HC12
   Copyright (C) 1999-2013 Free Software Foundation, Inc.
   Written by Stephane Carrez (stcarrez@@nerim.fr)

This file is part of GDB, the GNU debugger.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#ifndef _SIM_MAIN_H
#define _SIM_MAIN_H

#define WITH_MODULO_MEMORY 1
#define WITH_WATCHPOINTS 1
#define SIM_HANDLES_LMA 1

#include "sim-basics.h"

typedef address_word sim_cia;

#include "sim-signal.h"
#include "sim-base.h"

#include "bfd.h"

#include "opcode/m68hc11.h"

#include "gdb/callback.h"
#include "gdb/remote-sim.h"
#include "opcode/m68hc11.h"
#include "sim-types.h"

typedef unsigned8 uint8;
typedef unsigned16 uint16;
typedef signed16 int16;
typedef unsigned32 uint32;
typedef signed32 int32;
typedef unsigned64 uint64;
typedef signed64 int64;

struct _sim_cpu;

#include "interrupts.h"
#include <setjmp.h>

/* Specifies the level of mapping for the IO, EEprom, nvram and external
   RAM.  IO registers are mapped over everything and the external RAM
   is last (ie, it can be hidden by everything above it in the list).  */
enum m68hc11_map_level
{
  M6811_IO_LEVEL,
  M6811_EEPROM_LEVEL,
  M6811_NVRAM_LEVEL,
  M6811_RAM_LEVEL
};

enum cpu_type
{
  CPU_M6811,
  CPU_M6812
};

#define X_REGNUM 	0
#define D_REGNUM	1
#define Y_REGNUM        2
#define SP_REGNUM 	3
#define PC_REGNUM 	4
#define A_REGNUM        5
#define B_REGNUM        6
#define PSW_REGNUM 	7
#define PAGE_REGNUM     8
#define Z_REGNUM        9

typedef struct m6811_regs {
    unsigned short      d;
    unsigned short      ix;
    unsigned short      iy;
    unsigned short      sp;
    unsigned short      pc;
    unsigned char       ccr;
  unsigned short      page;
} m6811_regs;


/* Description of 68HC11 IO registers.  Such description is only provided
   for the info command to display the current setting of IO registers
   from GDB.  */
struct io_reg_desc
{
  int        mask;
  const char *short_name;
  const char *long_name;
};
typedef struct io_reg_desc io_reg_desc;

extern void print_io_reg_desc (SIM_DESC sd, io_reg_desc *desc, int val,
			       int mode);
extern void print_io_byte (SIM_DESC sd, const char *name,
			   io_reg_desc *desc, uint8 val, uint16 addr);
extern void print_io_word (SIM_DESC sd, const char *name,
			   io_reg_desc *desc, uint16 val, uint16 addr);


/* List of special 68HC11&68HC12 instructions that are not handled by the
   'gencode.c' generator.  These complex instructions are implemented
   by 'cpu_special'.  */
enum M6811_Special
{
  /* 68HC11 instructions.  */
  M6811_DAA,
  M6811_EMUL_SYSCALL,
  M6811_ILLEGAL,
  M6811_RTI,
  M6811_STOP,
  M6811_SWI,
  M6811_TEST,
  M6811_WAI,

  /* 68HC12 instructions.  */
  M6812_BGND,
  M6812_CALL,
  M6812_CALL_INDIRECT,
  M6812_IDIVS,
  M6812_EDIV,
  M6812_EDIVS,
  M6812_EMACS,
  M6812_EMUL,
  M6812_EMULS,
  M6812_ETBL,
  M6812_MEM,
  M6812_REV,
  M6812_REVW,
  M6812_RTC,
  M6812_RTI,
  M6812_WAV
};

#define M6811_MAX_PORTS (0x03f+1)
#define M6812_MAX_PORTS (0x3ff+1)
#define MAX_PORTS       (M6812_MAX_PORTS)

struct _sim_cpu;

typedef void (* cpu_interp) (struct _sim_cpu*);

struct _sim_cpu {
  /* CPU registers.  */
  struct m6811_regs     cpu_regs;

  /* CPU interrupts.  */
  struct interrupts     cpu_interrupts;

  /* Pointer to the interpretor routine.  */
  cpu_interp            cpu_interpretor;

  /* Pointer to the architecture currently configured in the simulator.  */
  const struct bfd_arch_info  *cpu_configured_arch;
  
  /* CPU absolute cycle time.  The cycle time is updated after
     each instruction, by the number of cycles taken by the instruction.
     It is cleared only when reset occurs.  */
  signed64              cpu_absolute_cycle;

  /* Number of cycles to increment after the current instruction.
     This is also the number of ticks for the generic event scheduler.  */
  uint8                 cpu_current_cycle;
  int                   cpu_emul_syscall;
  int                   cpu_is_initialized;
  int                   cpu_running;
  int                   cpu_check_memory;
  int                   cpu_stop_on_interrupt;

  /* When this is set, start execution of program at address specified
     in the ELF header.  This is used for testing some programs that do not
     have an interrupt table linked with them.  Programs created during the
     GCC validation are like this. A normal 68HC11 does not behave like
     this (unless there is some OS or downloadable feature).  */
  int                   cpu_use_elf_start;

  /* The starting address specified in ELF header.  */
  int                   cpu_elf_start;
  
  uint16                cpu_insn_pc;

  /* CPU frequency.  This is the quartz frequency.  It is divided by 4 to
     get the cycle time.  This is used for the timer rate and for the baud
     rate generation.  */
  unsigned long         cpu_frequency;

  /* The mode in which the CPU is configured (MODA and MODB pins).  */
  unsigned int          cpu_mode;
  const char*           cpu_start_mode;

  /* The cpu being configured.  */
  enum cpu_type         cpu_type;
  
  /* Initial value of the CONFIG register.  */
  uint8                 cpu_config;
  uint8                 cpu_use_local_config;
  
  uint8                 ios[MAX_PORTS];

  /* Memory bank parameters which describe how the memory bank window
     is mapped in memory and how to convert it in virtual address.  */
  uint16                bank_start;
  uint16                bank_end;
  address_word          bank_virtual;
  unsigned              bank_shift;
  

  struct hw            *hw_cpu;

  /* ... base type ... */
  sim_cpu_base base;
};

/* Returns the cpu absolute cycle time (A virtual counter incremented
   at each 68HC11 E clock).  */
#define cpu_current_cycle(PROC) ((PROC)->cpu_absolute_cycle)
#define cpu_add_cycles(PROC,T)  ((PROC)->cpu_current_cycle += (signed64) (T))
#define cpu_is_running(PROC)    ((PROC)->cpu_running)

/* Get the IO/RAM base addresses depending on the M6811_INIT register.  */
#define cpu_get_io_base(PROC) \
        (((uint16)(((PROC)->ios[M6811_INIT]) & 0x0F))<<12)
#define cpu_get_reg_base(PROC) \
        (((uint16)(((PROC)->ios[M6811_INIT]) & 0xF0))<<8)

/* Returns the different CPU registers.  */
#define cpu_get_ccr(PROC)          ((PROC)->cpu_regs.ccr)
#define cpu_get_pc(PROC)           ((PROC)->cpu_regs.pc)
#define cpu_get_d(PROC)            ((PROC)->cpu_regs.d)
#define cpu_get_x(PROC)            ((PROC)->cpu_regs.ix)
#define cpu_get_y(PROC)            ((PROC)->cpu_regs.iy)
#define cpu_get_sp(PROC)           ((PROC)->cpu_regs.sp)
#define cpu_get_a(PROC)            ((PROC->cpu_regs.d >> 8) & 0x0FF)
#define cpu_get_b(PROC)            ((PROC->cpu_regs.d) & 0x0FF)
#define cpu_get_page(PROC)         ((PROC)->cpu_regs.page)

/* 68HC12 specific and Motorola internal registers.  */
#define cpu_get_tmp3(PROC)         (0)
#define cpu_get_tmp2(PROC)         (0)

#define cpu_set_d(PROC,VAL)        (((PROC)->cpu_regs.d) = (VAL))
#define cpu_set_x(PROC,VAL)        (((PROC)->cpu_regs.ix) = (VAL))
#define cpu_set_y(PROC,VAL)        (((PROC)->cpu_regs.iy) = (VAL))
#define cpu_set_page(PROC,VAL)     (((PROC)->cpu_regs.page) = (VAL))

/* 68HC12 specific and Motorola internal registers.  */
#define cpu_set_tmp3(PROC,VAL)     (0)
#define cpu_set_tmp2(PROC,VAL)     (void) (0)

#if 0
/* This is a function in m68hc11_sim.c to keep track of the frame.  */
#define cpu_set_sp(PROC,VAL)       (((PROC)->cpu_regs.sp) = (VAL))
#endif

#define cpu_set_pc(PROC,VAL)       (((PROC)->cpu_regs.pc) = (VAL))

#define cpu_set_a(PROC,VAL)  \
      cpu_set_d(PROC,((VAL) << 8) | cpu_get_b(PROC))
#define cpu_set_b(PROC,VAL)  \
      cpu_set_d(PROC,((cpu_get_a(PROC)) << 8)|(VAL & 0x0FF))

#define cpu_set_ccr(PROC,VAL)      ((PROC)->cpu_regs.ccr = (VAL))
#define cpu_get_ccr_H(PROC)        ((cpu_get_ccr(PROC) & M6811_H_BIT) ? 1: 0)
#define cpu_get_ccr_X(PROC)        ((cpu_get_ccr(PROC) & M6811_X_BIT) ? 1: 0)
#define cpu_get_ccr_S(PROC)        ((cpu_get_ccr(PROC) & M6811_S_BIT) ? 1: 0)
#define cpu_get_ccr_N(PROC)        ((cpu_get_ccr(PROC) & M6811_N_BIT) ? 1: 0)
#define cpu_get_ccr_V(PROC)        ((cpu_get_ccr(PROC) & M6811_V_BIT) ? 1: 0)
#define cpu_get_ccr_C(PROC)        ((cpu_get_ccr(PROC) & M6811_C_BIT) ? 1: 0)
#define cpu_get_ccr_Z(PROC)        ((cpu_get_ccr(PROC) & M6811_Z_BIT) ? 1: 0)
#define cpu_get_ccr_I(PROC)        ((cpu_get_ccr(PROC) & M6811_I_BIT) ? 1: 0)

#define cpu_set_ccr_flag(S,B,V) \
cpu_set_ccr(S,(cpu_get_ccr(S) & ~(B)) | ((V) ? B : 0))

#define cpu_set_ccr_H(PROC,VAL)    cpu_set_ccr_flag(PROC, M6811_H_BIT, VAL)
#define cpu_set_ccr_X(PROC,VAL)    cpu_set_ccr_flag(PROC, M6811_X_BIT, VAL)
#define cpu_set_ccr_S(PROC,VAL)    cpu_set_ccr_flag(PROC, M6811_S_BIT, VAL)
#define cpu_set_ccr_N(PROC,VAL)    cpu_set_ccr_flag(PROC, M6811_N_BIT, VAL)
#define cpu_set_ccr_V(PROC,VAL)    cpu_set_ccr_flag(PROC, M6811_V_BIT, VAL)
#define cpu_set_ccr_C(PROC,VAL)    cpu_set_ccr_flag(PROC, M6811_C_BIT, VAL)
#define cpu_set_ccr_Z(PROC,VAL)    cpu_set_ccr_flag(PROC, M6811_Z_BIT, VAL)
#define cpu_set_ccr_I(PROC,VAL)    cpu_set_ccr_flag(PROC, M6811_I_BIT, VAL)

#undef inline
#define inline static __inline__

extern void cpu_memory_exception (struct _sim_cpu *proc,
                                  SIM_SIGNAL excep,
                                  uint16 addr,
                                  const char *message);

inline address_word
phys_to_virt (sim_cpu *cpu, address_word addr)
{
  if (addr >= cpu->bank_start && addr < cpu->bank_end)
    return ((address_word) (addr - cpu->bank_start)
            + (((address_word) cpu->cpu_regs.page) << cpu->bank_shift)
            + cpu->bank_virtual);
  else
    return (address_word) (addr);
}

inline uint8
memory_read8 (sim_cpu *cpu, uint16 addr)
{
  uint8 val;

  if (sim_core_read_buffer (CPU_STATE (cpu), cpu, 0, &val, addr, 1) != 1)
    {
      cpu_memory_exception (cpu, SIM_SIGSEGV, addr,
                            "Read error");
    }
  return val;
}

inline void
memory_write8 (sim_cpu *cpu, uint16 addr, uint8 val)
{
  if (sim_core_write_buffer (CPU_STATE (cpu), cpu, 0, &val, addr, 1) != 1)
    {
      cpu_memory_exception (cpu, SIM_SIGSEGV, addr,
                            "Write error");
    }
}

inline uint16
memory_read16 (sim_cpu *cpu, uint16 addr)
{
  uint8 b[2];

  if (sim_core_read_buffer (CPU_STATE (cpu), cpu, 0, b, addr, 2) != 2)
    {
      cpu_memory_exception (cpu, SIM_SIGSEGV, addr,
                            "Read error");
    }
  return (((uint16) (b[0])) << 8) | ((uint16) b[1]);
}

inline void
memory_write16 (sim_cpu *cpu, uint16 addr, uint16 val)
{
  uint8 b[2];

  b[0] = val >> 8;
  b[1] = val;
  if (sim_core_write_buffer (CPU_STATE (cpu), cpu, 0, b, addr, 2) != 2)
    {
      cpu_memory_exception (cpu, SIM_SIGSEGV, addr,
                            "Write error");
    }
}
extern void
cpu_ccr_update_tst8 (sim_cpu *proc, uint8 val);

     inline void
cpu_ccr_update_tst16 (sim_cpu *proc, uint16 val)
{
  cpu_set_ccr_V (proc, 0);
  cpu_set_ccr_N (proc, val & 0x8000 ? 1 : 0);
  cpu_set_ccr_Z (proc, val == 0 ? 1 : 0);
}

     inline void
cpu_ccr_update_shift8 (sim_cpu *proc, uint8 val)
{
  cpu_set_ccr_N (proc, val & 0x80 ? 1 : 0);
  cpu_set_ccr_Z (proc, val == 0 ? 1 : 0);
  cpu_set_ccr_V (proc, cpu_get_ccr_N (proc) ^ cpu_get_ccr_C (proc));
}

     inline void
cpu_ccr_update_shift16 (sim_cpu *proc, uint16 val)
{
  cpu_set_ccr_N (proc, val & 0x8000 ? 1 : 0);
  cpu_set_ccr_Z (proc, val == 0 ? 1 : 0);
  cpu_set_ccr_V (proc, cpu_get_ccr_N (proc) ^ cpu_get_ccr_C (proc));
}

inline void
cpu_ccr_update_add8 (sim_cpu *proc, uint8 r, uint8 a, uint8 b)
{
  cpu_set_ccr_C (proc, ((a & b) | (b & ~r) | (a & ~r)) & 0x80 ? 1 : 0);
  cpu_set_ccr_V (proc, ((a & b & ~r) | (~a & ~b & r)) & 0x80 ? 1 : 0);
  cpu_set_ccr_Z (proc, r == 0);
  cpu_set_ccr_N (proc, r & 0x80 ? 1 : 0);
}


inline void
cpu_ccr_update_sub8 (sim_cpu *proc, uint8 r, uint8 a, uint8 b)
{
  cpu_set_ccr_C (proc, ((~a & b) | (b & r) | (~a & r)) & 0x80 ? 1 : 0);
  cpu_set_ccr_V (proc, ((a & ~b & ~r) | (~a & b & r)) & 0x80 ? 1 : 0);
  cpu_set_ccr_Z (proc, r == 0);
  cpu_set_ccr_N (proc, r & 0x80 ? 1 : 0);
}

inline void
cpu_ccr_update_add16 (sim_cpu *proc, uint16 r, uint16 a, uint16 b)
{
  cpu_set_ccr_C (proc, ((a & b) | (b & ~r) | (a & ~r)) & 0x8000 ? 1 : 0);
  cpu_set_ccr_V (proc, ((a & b & ~r) | (~a & ~b & r)) & 0x8000 ? 1 : 0);
  cpu_set_ccr_Z (proc, r == 0);
  cpu_set_ccr_N (proc, r & 0x8000 ? 1 : 0);
}

inline void
cpu_ccr_update_sub16 (sim_cpu *proc, uint16 r, uint16 a, uint16 b)
{
  cpu_set_ccr_C (proc, ((~a & b) | (b & r) | (~a & r)) & 0x8000 ? 1 : 0);
  cpu_set_ccr_V (proc, ((a & ~b & ~r) | (~a & b & r)) & 0x8000 ? 1 : 0);
  cpu_set_ccr_Z (proc, r == 0);
  cpu_set_ccr_N (proc, r & 0x8000 ? 1 : 0);
}

/* Push and pop instructions for 68HC11 (next-available stack mode).  */
inline void
cpu_m68hc11_push_uint8 (sim_cpu *proc, uint8 val)
{
  uint16 addr = proc->cpu_regs.sp;

  memory_write8 (proc, addr, val);
  proc->cpu_regs.sp = addr - 1;
}

inline void
cpu_m68hc11_push_uint16 (sim_cpu *proc, uint16 val)
{
  uint16 addr = proc->cpu_regs.sp - 1;

  memory_write16 (proc, addr, val);
  proc->cpu_regs.sp = addr - 1;
}

inline uint8
cpu_m68hc11_pop_uint8 (sim_cpu *proc)
{
  uint16 addr = proc->cpu_regs.sp;
  uint8 val;
  
  val = memory_read8 (proc, addr + 1);
  proc->cpu_regs.sp = addr + 1;
  return val;
}

inline uint16
cpu_m68hc11_pop_uint16 (sim_cpu *proc)
{
  uint16 addr = proc->cpu_regs.sp;
  uint16 val;
  
  val = memory_read16 (proc, addr + 1);
  proc->cpu_regs.sp = addr + 2;
  return val;
}

/* Push and pop instructions for 68HC12 (last-used stack mode).  */
inline void
cpu_m68hc12_push_uint8 (sim_cpu *proc, uint8 val)
{
  uint16 addr = proc->cpu_regs.sp;

  addr --;
  memory_write8 (proc, addr, val);
  proc->cpu_regs.sp = addr;
}

inline void
cpu_m68hc12_push_uint16 (sim_cpu *proc, uint16 val)
{
  uint16 addr = proc->cpu_regs.sp;

  addr -= 2;
  memory_write16 (proc, addr, val);
  proc->cpu_regs.sp = addr;
}

inline uint8
cpu_m68hc12_pop_uint8 (sim_cpu *proc)
{
  uint16 addr = proc->cpu_regs.sp;
  uint8 val;
  
  val = memory_read8 (proc, addr);
  proc->cpu_regs.sp = addr + 1;
  return val;
}

inline uint16
cpu_m68hc12_pop_uint16 (sim_cpu *proc)
{
  uint16 addr = proc->cpu_regs.sp;
  uint16 val;
  
  val = memory_read16 (proc, addr);
  proc->cpu_regs.sp = addr + 2;
  return val;
}

/* Fetch a 8/16 bit value and update the PC.  */
inline uint8
cpu_fetch8 (sim_cpu *proc)
{
  uint16 addr = proc->cpu_regs.pc;
  uint8 val;
  
  val = memory_read8 (proc, addr);
  proc->cpu_regs.pc = addr + 1;
  return val;
}

inline uint16
cpu_fetch16 (sim_cpu *proc)
{
  uint16 addr = proc->cpu_regs.pc;
  uint16 val;
  
  val = memory_read16 (proc, addr);
  proc->cpu_regs.pc = addr + 2;
  return val;
}

extern void cpu_call (sim_cpu* proc, uint16 addr);
extern void cpu_exg (sim_cpu* proc, uint8 code);
extern void cpu_dbcc (sim_cpu* proc);
extern void cpu_special (sim_cpu *proc, enum M6811_Special special);
extern void cpu_move8 (sim_cpu *proc, uint8 op);
extern void cpu_move16 (sim_cpu *proc, uint8 op);

extern uint16 cpu_fetch_relbranch (sim_cpu *proc);
extern uint16 cpu_fetch_relbranch16 (sim_cpu *proc);
extern void cpu_push_all (sim_cpu *proc);
extern void cpu_single_step (sim_cpu *proc);

extern void cpu_info (SIM_DESC sd, sim_cpu *proc);

extern int cpu_initialize (SIM_DESC sd, sim_cpu *cpu);

/* Returns the address of a 68HC12 indexed operand.
   Pre and post modifications are handled on the source register.  */
extern uint16 cpu_get_indexed_operand_addr (sim_cpu* cpu, int restrict);

extern void cpu_return (sim_cpu *cpu);
extern void cpu_set_sp (sim_cpu *cpu, uint16 val);
extern int cpu_reset (sim_cpu *cpu);
extern int cpu_restart (sim_cpu *cpu);
extern void sim_memory_error (sim_cpu *cpu, SIM_SIGNAL excep,
                              uint16 addr, const char *message, ...);
extern void emul_os (int op, sim_cpu *cpu);
extern void cpu_interp_m6811 (sim_cpu *cpu);
extern void cpu_interp_m6812 (sim_cpu *cpu);

extern int m68hc11cpu_set_oscillator (SIM_DESC sd, const char *port,
				      double ton, double toff,
				      signed64 repeat);
extern int m68hc11cpu_clear_oscillator (SIM_DESC sd, const char *port);
extern void m68hc11cpu_set_port (struct hw *me, sim_cpu *cpu,
				 unsigned addr, uint8 val);

/* The current state of the processor; registers, memory, etc.  */

#define CIA_GET(CPU)      (cpu_get_pc (CPU))
#define CIA_SET(CPU,VAL)  (cpu_set_pc ((CPU), (VAL)))

#if (WITH_SMP)
#define STATE_CPU(sd,n) (&(sd)->cpu[n])
#else
#define STATE_CPU(sd,n) (&(sd)->cpu[0])
#endif

struct sim_state {
  sim_cpu        cpu[MAX_NR_PROCESSORS];
  device         *devices;
  sim_state_base base;
};

extern void sim_set_profile (int n);
extern void sim_set_profile_size (int n);
extern void sim_board_reset (SIM_DESC sd);

#define PRINT_TIME  0x01
#define PRINT_CYCLE 0x02
extern const char *cycle_to_string (sim_cpu *cpu, signed64 t, int flags);

#endif


@


1.20
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 1
   Copyright (C) 1999-2003, 2007-2012 Free Software Foundation, Inc.
@


1.19
log
@run copyright.sh for 2011.
@
text
@d2 1
a2 2
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.19.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 1
   Copyright (C) 1999-2003, 2007-2012 Free Software Foundation, Inc.
@


1.18
log
@Update copyright notices to add year 2010.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2007, 2008, 2009, 2010
@


1.17
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2007, 2008, 2009
@


1.16
log
@	Updated copyright notices for most files.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2007, 2008
@


1.15
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2007
@


1.14
log
@Copyright updates for 2007.
@
text
@d10 2
a11 2
the Free Software Foundation; either version 2, or (at your option)
any later version.
d18 2
a19 3
You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.13
log
@	* dv-m68hc11tim.c (cycle_to_string): Add flags parameter to better
	control the translation.
	(m68hc11tim_print_timer): Update cycle_to_string conversion.
	(m68hc11tim_timer_event): Fix handling of output
	compare register with its interrupts.
	(m68hc11tim_io_write_buffer): Check output compare
	after setting M6811_TMSK1.
	(m68hc11tim_io_read_buffer): Fix compilation warning.
	* dv-m68hc11.c (m68hc11_option_handler): Likewise.
	* dv-m68hc11spi.c (m68hc11spi_info): Likewise.
	* dv-m68hc11sio.c (m68hc11sio_info): Likewise.
	* interrupts.c (interrupts_info): Likewise.
	(interrupts_reset): Recognize bootstrap mode.
	* sim-main.h (PRINT_CYCLE, PRINT_TIME): New defines.
	(_sim_cpu): Add cpu_start_mode.
	(cycle_to_string): Add flags member.
	* m68hc11_sim.c (OPTION_CPU_BOOTSTRAP): New option.
	(cpu_options): Declare new option bootstrap.
	(cpu_option_handler): Handle it.
	(cpu_info): Update call to cycle_to_string.
@
text
@d2 2
a3 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
@


1.12
log
@	* sim-main.h (phys_to_virt): Use memory bank parameters to translate
	the physical address in virtual address.
	(struct _sim_cpu): Add memory bank members.
	* m68hc11_sim.c (cpu_initialize): Clear memory bank parameters.
	* interp.c (sim_hw_configure): Create memory bank according to memory
	bank parameters.
	(sim_get_bank_parameters): New function to obtain memory bank config
	from the symbol table.
	(sim_prepare_for_program): Call it to obtain the memory bank parameters.
	(sim_open): Call sim_prepare_for_program.
	* dv-m68hc11.c (m68hc11cpu_io_write_buffer): Use memory bank parameters
	to check if address is within bank window.
	(m68hc11cpu_io_read_buffer): Likewise.
	(attach_m68hc11_regs): Map the memory bank according to memory bank
	parameters.
@
text
@d203 1
d595 3
a597 1
extern const char *cycle_to_string (sim_cpu *cpu, signed64 t);
@


1.11
log
@	* sim-main.h (PAGE_REGNUM, Z_REGNUM): Use same numbering as gdb.
@
text
@d213 8
d248 1
a248 1
#define cpu_get_page(PROC)         (PROC->cpu_regs.page)
d257 1
a257 1
#define cpu_set_page(PROC,VAL)     ((PROC->cpu_regs.page) = (VAL))
d308 4
a311 3
  if (addr >= 0x8000 && addr < 0xc000)
    return ((address_word) (addr) - 0x8000)
      + (((address_word) cpu->cpu_regs.page) << 14) + 0x01000000;
@


1.10
log
@	* m68hc11_sim.c (print_io_word): New function to print 16-bit value.
	* sim-main.h (print_io_word): Declare.
	* dv-m68hc11tim.c (tmsk1_desc): New description table for TMSK1.
	(tflg1_desc): Likewise for TFLG1.
	(m68hc11tim_info): Print input and output compare registers
@
text
@d82 2
a83 2
#define Z_REGNUM        8
#define PAGE_REGNUM     9
@


1.9
log
@	* m68hc11_sim.c (cpu_special): Handle call and rtc instructions.
	* sim-main.h (M6812_CALL_INDIRECT): Add to enum.
	(m6811_regs): Add page register.
	(cpu_set_page, cpu_get_page): New macros.
	(phys_to_virt): New function.
	(cpu_get_indexed_operand_addr, cpu_return): Declare.
	* gencode.c: Identify indirect addressing mode for call and fix daa.
	(gen_function_entry): New param to tell if src8/dst8 locals are
	necessary.
	(gen_interpreter): Use it to avoid generation of unused variables.
	* interp.c (sim_fetch_register): Allow to read page register; page
	register, A, B and CCR are only 1 byte wide.
	(sim_store_register): Likewise for writing.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d111 2
@


1.9.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d82 2
a83 2
#define PAGE_REGNUM     8
#define Z_REGNUM        9
a110 2
extern void print_io_word (SIM_DESC sd, const char *name,
			   io_reg_desc *desc, uint16 val, uint16 addr);
a200 1
  const char*           cpu_start_mode;
a210 8
  /* Memory bank parameters which describe how the memory bank window
     is mapped in memory and how to convert it in virtual address.  */
  uint16                bank_start;
  uint16                bank_end;
  address_word          bank_virtual;
  unsigned              bank_shift;
  

d238 1
a238 1
#define cpu_get_page(PROC)         ((PROC)->cpu_regs.page)
d247 1
a247 1
#define cpu_set_page(PROC,VAL)     (((PROC)->cpu_regs.page) = (VAL))
d298 3
a300 4
  if (addr >= cpu->bank_start && addr < cpu->bank_end)
    return ((address_word) (addr - cpu->bank_start)
            + (((address_word) cpu->cpu_regs.page) << cpu->bank_shift)
            + cpu->bank_virtual);
d583 1
a583 3
#define PRINT_TIME  0x01
#define PRINT_CYCLE 0x02
extern const char *cycle_to_string (sim_cpu *cpu, signed64 t, int flags);
@


1.9.8.1
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d82 2
a83 2
#define PAGE_REGNUM     8
#define Z_REGNUM        9
a110 2
extern void print_io_word (SIM_DESC sd, const char *name,
			   io_reg_desc *desc, uint16 val, uint16 addr);
a200 1
  const char*           cpu_start_mode;
a210 8
  /* Memory bank parameters which describe how the memory bank window
     is mapped in memory and how to convert it in virtual address.  */
  uint16                bank_start;
  uint16                bank_end;
  address_word          bank_virtual;
  unsigned              bank_shift;
  

d238 1
a238 1
#define cpu_get_page(PROC)         ((PROC)->cpu_regs.page)
d247 1
a247 1
#define cpu_set_page(PROC,VAL)     (((PROC)->cpu_regs.page) = (VAL))
d298 3
a300 4
  if (addr >= cpu->bank_start && addr < cpu->bank_end)
    return ((address_word) (addr - cpu->bank_start)
            + (((address_word) cpu->cpu_regs.page) << cpu->bank_shift)
            + cpu->bank_virtual);
d583 1
a583 3
#define PRINT_TIME  0x01
#define PRINT_CYCLE 0x02
extern const char *cycle_to_string (sim_cpu *cpu, signed64 t, int flags);
@


1.9.44.1
log
@	* m68hc11_sim.c (print_io_word): New function to print 16-bit value.
	* sim-main.h (print_io_word): Declare.
	* dv-m68hc11tim.c (tmsk1_desc): New description table for TMSK1.
	(tflg1_desc): Likewise for TFLG1.
	(m68hc11tim_info): Print input and output compare registers
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a110 2
extern void print_io_word (SIM_DESC sd, const char *name,
			   io_reg_desc *desc, uint16 val, uint16 addr);
@


1.9.44.2
log
@	* sim-main.h (PAGE_REGNUM, Z_REGNUM): Use same numbering as gdb.
@
text
@d82 2
a83 2
#define PAGE_REGNUM     8
#define Z_REGNUM        9
@


1.9.44.3
log
@	* sim-main.h (phys_to_virt): Use memory bank parameters to translate
	the physical address in virtual address.
	(struct _sim_cpu): Add memory bank members.
	* m68hc11_sim.c (cpu_initialize): Clear memory bank parameters.
	* interp.c (sim_hw_configure): Create memory bank according to memory
	bank parameters.
	(sim_get_bank_parameters): New function to obtain memory bank config
	from the symbol table.
	(sim_prepare_for_program): Call it to obtain the memory bank parameters.
	(sim_open): Call sim_prepare_for_program.
	* dv-m68hc11.c (m68hc11cpu_io_write_buffer): Use memory bank parameters
	to check if address is within bank window.
	(m68hc11cpu_io_read_buffer): Likewise.
	(attach_m68hc11_regs): Map the memory bank according to memory bank
	parameters.
@
text
@a212 8
  /* Memory bank parameters which describe how the memory bank window
     is mapped in memory and how to convert it in virtual address.  */
  uint16                bank_start;
  uint16                bank_end;
  address_word          bank_virtual;
  unsigned              bank_shift;
  

d240 1
a240 1
#define cpu_get_page(PROC)         ((PROC)->cpu_regs.page)
d249 1
a249 1
#define cpu_set_page(PROC,VAL)     (((PROC)->cpu_regs.page) = (VAL))
d300 3
a302 4
  if (addr >= cpu->bank_start && addr < cpu->bank_end)
    return ((address_word) (addr - cpu->bank_start)
            + (((address_word) cpu->cpu_regs.page) << cpu->bank_shift)
            + cpu->bank_virtual);
@


1.9.44.4
log
@	* dv-m68hc11tim.c (cycle_to_string): Add flags parameter to better
	control the translation.
	(m68hc11tim_print_timer): Update cycle_to_string conversion.
	(m68hc11tim_timer_event): Fix handling of output
	compare register with its interrupts.
	(m68hc11tim_io_write_buffer): Check output compare
	after setting M6811_TMSK1.
	(m68hc11tim_io_read_buffer): Fix compilation warning.
	* dv-m68hc11.c (m68hc11_option_handler): Likewise.
	* dv-m68hc11spi.c (m68hc11spi_info): Likewise.
	* dv-m68hc11sio.c (m68hc11sio_info): Likewise.
	* interrupts.c (interrupts_info): Likewise.
	(interrupts_reset): Recognize bootstrap mode.
	* sim-main.h (PRINT_CYCLE, PRINT_TIME): New defines.
	(_sim_cpu): Add cpu_start_mode.
	(cycle_to_string): Add flags member.
	* m68hc11_sim.c (OPTION_CPU_BOOTSTRAP): New option.
	(cpu_options): Declare new option bootstrap.
	(cpu_option_handler): Handle it.
	(cpu_info): Update call to cycle_to_string.
@
text
@a202 1
  const char*           cpu_start_mode;
d594 1
a594 3
#define PRINT_TIME  0x01
#define PRINT_CYCLE 0x02
extern const char *cycle_to_string (sim_cpu *cpu, signed64 t, int flags);
@


1.8
log
@Move include/callback.h and include/remote-sim.h to include/gdb/.
Update accordingly.
@
text
@d3 1
a3 1
   Written by Stephane Carrez (stcarrez@@worldnet.fr)
d83 1
d92 1
d131 1
d238 1
d247 1
d251 1
a251 1
#define cpu_set_tmp2(PROC,VAL)     (0)
d295 10
d309 1
a309 1
  
d332 1
a332 1
  
d541 5
@


1.7
log
@	* interp.c (sim_hw_configure): Save the HW cpu pointer in the
	cpu struct.
	(sim_hw_configure): Connect the capture input/output events.
	* sim-main.h (_sim_cpu): New member hw_cpu.
	(m68hc11cpu_set_oscillator): Declare.
	(m68hc11cpu_clear_oscillator): Declare.
	(m68hc11cpu_set_port): Declare.
	* dv-m68hc11.c (m68hc11_options): New for oscillator commands.
	(m68hc11cpu_ports): New input ports and output ports to reflect
	the HC11 IOs.
	(m68hc11_delete): Cleanup any running oscillator.
	(attach_m68hc11_regs): Create the input oscillators.
	(make_oscillator): New function.
	(find_oscillator): New function.
	(oscillator_handler): New function.
	(reset_oscillators): New function.
	(m68hc11cpu_port_event): Handle the new input ports.
	(m68hc11cpu_set_oscillator): New function.
	(m68hc11cpu_clear_oscillator): New function.
	(get_frequency): New function.
	(m68hc11_option_handler): New function.
	(m68hc11cpu_set_port): New function.
	(m68hc11cpu_io_write): Post the port output events.
	* dv-m68hc11spi.c (set_bit_port): Use m68hc11cpu_set_port to set
	the output port value.
	* dv-m68hc11tim.c (m68hc11tim_port_event): Handle CAPTURE event
	by latching the TCNT value in the register.
@
text
@d39 2
a40 2
#include "callback.h"
#include "remote-sim.h"
@


1.7.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d39 2
a40 2
#include "gdb/callback.h"
#include "gdb/remote-sim.h"
@


1.7.6.2
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d3 1
a3 1
   Written by Stephane Carrez (stcarrez@@nerim.fr)
a82 1
#define PAGE_REGNUM     9
a90 1
  unsigned short      page;
a128 1
  M6812_CALL_INDIRECT,
a234 1
#define cpu_get_page(PROC)         (PROC->cpu_regs.page)
a242 1
#define cpu_set_page(PROC,VAL)     ((PROC->cpu_regs.page) = (VAL))
d246 1
a246 1
#define cpu_set_tmp2(PROC,VAL)     (void) (0)
a289 10
inline address_word
phys_to_virt (sim_cpu *cpu, address_word addr)
{
  if (addr >= 0x8000 && addr < 0xc000)
    return ((address_word) (addr) - 0x8000)
      + (((address_word) cpu->cpu_regs.page) << 14) + 0x01000000;
  else
    return (address_word) (addr);
}

d294 1
a294 1

d317 1
a317 1

a525 5
/* Returns the address of a 68HC12 indexed operand.
   Pre and post modifications are handled on the source register.  */
extern uint16 cpu_get_indexed_operand_addr (sim_cpu* cpu, int restrict);

extern void cpu_return (sim_cpu *cpu);
@


1.7.4.1
log
@merge from trunk
@
text
@d39 2
a40 2
#include "gdb/callback.h"
#include "gdb/remote-sim.h"
@


1.6
log
@	* sim-main.h (cpu_frame, cpu_frame_list): Remove.
	(cpu_frame_reg, cpu_print_frame): Remove.
	(cpu_m68hc11_push_uint8, cpu_m68hc11_pop_uint8): Cleanup.
	(cpu_m68hc11_push_uint16, cpu_m68hc11_pop_uint16): Likewise.
	(cpu_m68hc12_push_uint8, cpu_m68hc12_push_uint16): Likewise.
	(cpu_m68hc12_pop_uint8, cpu_m68hc12_pop_uint16): Likewise.
	* m68hc11_sim.c (cpu_find_frame): Remove.
	(cpu_create_frame_list): Remove.
	(cpu_remove_frame_list, cpu_create_frame, cpu_free_frame): Remove.
	(cpu_frame_reg, cpu_print_frame, cpu_update_frame): Remove.
	(cpu_call): Cleanup to remove #if HAVE_FRAME and calls to the above.
	(cpu_update_frame): Likewise.
	(cpu_return): Likewise.
	(cpu_reset): Likewise.
	(cpu_initialize): Likewise.
	* interp.c (sim_do_command): Remove call to cpu_print_frame.
@
text
@d207 3
a209 1
  
d534 7
@


1.5
log
@Improve HC11 simulator to support HC12
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
a143 3
#define CPU_POP 1
#define CPU_PUSH 2

a147 20
/* Tentative to keep track of the stack frame.
   The frame is updated each time a call or a return are made.
   We also have to take into account changes of stack pointer
   (either thread switch or longjmp).  */
struct cpu_frame 
{
  struct cpu_frame *up;
  uint16 pc;
  uint16 sp_low;
  uint16 sp_high;
};

/* Represents a list of frames (or a thread).  */
struct cpu_frame_list
{
  struct cpu_frame_list *next;
  struct cpu_frame_list *prev;
  struct cpu_frame      *frame;
};

a158 4
  struct cpu_frame_list *cpu_frames;
  struct cpu_frame_list *cpu_current_frame;
  int                   cpu_need_update_frame;

a408 1
  proc->cpu_need_update_frame |= CPU_PUSH;
a417 1
  proc->cpu_need_update_frame |= CPU_PUSH;
a427 1
  proc->cpu_need_update_frame |= CPU_POP;
a438 1
  proc->cpu_need_update_frame |= CPU_POP;
a450 1
  proc->cpu_need_update_frame |= CPU_PUSH;
a460 1
  proc->cpu_need_update_frame |= CPU_PUSH;
a470 1
  proc->cpu_need_update_frame |= CPU_POP;
a481 1
  proc->cpu_need_update_frame |= CPU_POP;
a523 1
extern void cpu_print_frame (SIM_DESC sd, sim_cpu *cpu);
a524 1
extern uint16 cpu_frame_reg (sim_cpu *cpu, uint16 rn);
@


1.5.8.1
log
@	* sim-main.h (cpu_frame, cpu_frame_list): Remove.
	(cpu_frame_reg, cpu_print_frame): Remove.
	(cpu_m68hc11_push_uint8, cpu_m68hc11_pop_uint8): Cleanup.
	(cpu_m68hc11_push_uint16, cpu_m68hc11_pop_uint16): Likewise.
	(cpu_m68hc12_push_uint8, cpu_m68hc12_push_uint16): Likewise.
	(cpu_m68hc12_pop_uint8, cpu_m68hc12_pop_uint16): Likewise.
	* m68hc11_sim.c (cpu_find_frame): Remove.
	(cpu_create_frame_list): Remove.
	(cpu_remove_frame_list, cpu_create_frame, cpu_free_frame): Remove.
	(cpu_frame_reg, cpu_print_frame, cpu_update_frame): Remove.
	(cpu_call): Cleanup to remove #if HAVE_FRAME and calls to the above.
	(cpu_update_frame): Likewise.
	(cpu_return): Likewise.
	(cpu_reset): Likewise.
	(cpu_initialize): Likewise.
	* interp.c (sim_do_command): Remove call to cpu_print_frame.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d144 3
d151 20
d182 4
d436 1
d446 1
d457 1
d469 1
d482 1
d493 1
d504 1
d516 1
d559 1
d561 1
@


1.5.8.2
log
@	* interp.c (sim_hw_configure): Save the HW cpu pointer in the
	cpu struct.
	(sim_hw_configure): Connect the capture input/output events.
	* sim-main.h (_sim_cpu): New member hw_cpu.
	(m68hc11cpu_set_oscillator): Declare.
	(m68hc11cpu_clear_oscillator): Declare.
	(m68hc11cpu_set_port): Declare.
	* dv-m68hc11.c (m68hc11_options): New for oscillator commands.
	(m68hc11cpu_ports): New input ports and output ports to reflect
	the HC11 IOs.
	(m68hc11_delete): Cleanup any running oscillator.
	(attach_m68hc11_regs): Create the input oscillators.
	(make_oscillator): New function.
	(find_oscillator): New function.
	(oscillator_handler): New function.
	(reset_oscillators): New function.
	(m68hc11cpu_port_event): Handle the new input ports.
	(m68hc11cpu_set_oscillator): New function.
	(m68hc11cpu_clear_oscillator): New function.
	(get_frequency): New function.
	(m68hc11_option_handler): New function.
	(m68hc11cpu_set_port): New function.
	(m68hc11cpu_io_write): Post the port output events.
	* dv-m68hc11spi.c (set_bit_port): Use m68hc11cpu_set_port to set
	the output port value.
	* dv-m68hc11tim.c (m68hc11tim_port_event): Handle CAPTURE event
	by latching the TCNT value in the register.
@
text
@d207 1
a207 3

  struct hw            *hw_cpu;

a531 7

extern int m68hc11cpu_set_oscillator (SIM_DESC sd, const char *port,
				      double ton, double toff,
				      signed64 repeat);
extern int m68hc11cpu_clear_oscillator (SIM_DESC sd, const char *port);
extern void m68hc11cpu_set_port (struct hw *me, sim_cpu *cpu,
				 unsigned addr, uint8 val);
@


1.4
log
@Remove soft reg hack in the 68hc11 simulator
@
text
@d1 2
a2 2
/* sim-main.h -- Simulator for Motorola 68HC11
   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
d68 5
d111 1
a111 1
/* List of special 68HC11 instructions that are not handled by the
d116 4
d121 1
a121 1
  M6811_WAI,
d124 18
a141 2
  M6811_ILLEGAL,
  M6811_EMUL_SYSCALL
d147 3
a149 1
#define MAX_PORTS 0x40
d171 4
d186 6
d226 3
d233 1
a233 1
  uint8 ios[0x3F];
d261 4
d269 4
d428 1
a428 1

d430 1
a430 1
cpu_push_uint8 (sim_cpu *proc, uint8 val)
d440 1
a440 1
cpu_push_uint16 (sim_cpu *proc, uint16 val)
d450 1
a450 1
cpu_pop_uint8 (sim_cpu *proc)
d462 1
a462 1
cpu_pop_uint16 (sim_cpu *proc)
d473 48
d544 2
d547 2
d551 1
d567 2
a568 1
extern void cpu_interp (sim_cpu *cpu);
@


1.3
log
@	* sim-main.h: Define cycle_to_string.
	* dv-m68hc11tim.c (cycle_to_string): New function to translate
	the cpu cycle into some formatted time string.
	(m68hc11tim_print_timer): Use it.
	* dv-m68hc11sio.c (m68hc11sio_info): Use cycle_to_string.
	* dv-m68hc11spi.c (m68hc11spi_info): Likewise.
	* interrupts.c (interrupts_info): Likewise.
	* m68hc11_sim.c (cpu_info): Likewise.
@
text
@a77 9
#define FP_REGNUM       9
#define TMP_REGNUM     10
#define ZS_REGNUM      11
#define XY_REGNUM      12
#define ZD1_REGNUM     13
#define ZD32_REGNUM    (ZD1_REGNUM+31)

#define FIRST_SOFT_REGNUM (Z_REGNUM)
#define MAX_SOFT_REG      (ZD32_REGNUM - Z_REGNUM + 1)
a179 2
  unsigned short	cpu_nb_pseudo_regs;
  uint16                cpu_page0_reg[MAX_SOFT_REG];
@


1.2
log
@Use address mapping levels for 68hc11 simulator (kill overlap hack)
@
text
@d500 2
@


1.1
log
@New simulator.
@
text
@d57 12
@

