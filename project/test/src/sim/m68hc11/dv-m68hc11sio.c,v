head	1.14;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.14
	gdb_7_6-2013-04-26-release:1.14
	gdb_7_6-branch:1.14.0.2
	gdb_7_6-2013-03-12-branchpoint:1.14
	gdb_7_5_1-2012-11-29-release:1.13
	gdb_7_5-2012-08-17-release:1.13
	gdb_7_5-branch:1.13.0.2
	gdb_7_5-2012-07-18-branchpoint:1.13
	gdb_7_4_1-2012-04-26-release:1.12.4.1
	gdb_7_4-2012-01-24-release:1.12.4.1
	gdb_7_4-branch:1.12.0.4
	gdb_7_4-2011-12-13-branchpoint:1.12
	gdb_7_3_1-2011-09-04-release:1.12
	gdb_7_3-2011-07-26-release:1.12
	gdb_7_3-branch:1.12.0.2
	gdb_7_3-2011-04-01-branchpoint:1.12
	gdb_7_2-2010-09-02-release:1.11
	gdb_7_2-branch:1.11.0.4
	gdb_7_2-2010-07-07-branchpoint:1.11
	gdb_7_1-2010-03-18-release:1.11
	gdb_7_1-branch:1.11.0.2
	gdb_7_1-2010-02-18-branchpoint:1.11
	gdb_7_0_1-2009-12-22-release:1.10
	gdb_7_0-2009-10-06-release:1.10
	gdb_7_0-branch:1.10.0.4
	gdb_7_0-2009-09-16-branchpoint:1.10
	arc-sim-20090309:1.9
	msnyder-checkpoint-072509-branch:1.10.0.2
	msnyder-checkpoint-072509-branchpoint:1.10
	arc-insight_6_8-branch:1.9.0.16
	arc-insight_6_8-branchpoint:1.9
	insight_6_8-branch:1.9.0.14
	insight_6_8-branchpoint:1.9
	reverse-20081226-branch:1.9.0.12
	reverse-20081226-branchpoint:1.9
	multiprocess-20081120-branch:1.9.0.10
	multiprocess-20081120-branchpoint:1.9
	reverse-20080930-branch:1.9.0.8
	reverse-20080930-branchpoint:1.9
	reverse-20080717-branch:1.9.0.6
	reverse-20080717-branchpoint:1.9
	msnyder-reverse-20080609-branch:1.9.0.4
	msnyder-reverse-20080609-branchpoint:1.9
	drow-reverse-20070409-branch:1.7.0.2
	drow-reverse-20070409-branchpoint:1.7
	gdb_6_8-2008-03-27-release:1.9
	gdb_6_8-branch:1.9.0.2
	gdb_6_8-2008-02-26-branchpoint:1.9
	gdb_6_7_1-2007-10-29-release:1.8
	gdb_6_7-2007-10-10-release:1.8
	gdb_6_7-branch:1.8.0.2
	gdb_6_7-2007-09-07-branchpoint:1.8
	insight_6_6-20070208-release:1.6
	gdb_6_6-2006-12-18-release:1.6
	gdb_6_6-branch:1.6.0.54
	gdb_6_6-2006-11-15-branchpoint:1.6
	insight_6_5-20061003-release:1.6
	gdb-csl-symbian-6_4_50_20060226-12:1.6
	gdb-csl-sourcerygxx-3_4_4-25:1.6
	nickrob-async-20060828-mergepoint:1.6
	gdb-csl-symbian-6_4_50_20060226-11:1.6
	gdb-csl-sourcerygxx-4_1-17:1.6
	gdb-csl-20060226-branch-local-2:1.6
	gdb-csl-sourcerygxx-4_1-14:1.6
	gdb-csl-sourcerygxx-4_1-13:1.6
	gdb-csl-sourcerygxx-4_1-12:1.6
	gdb-csl-sourcerygxx-3_4_4-21:1.6
	gdb_6_5-20060621-release:1.6
	gdb-csl-sourcerygxx-4_1-9:1.6
	gdb-csl-sourcerygxx-4_1-8:1.6
	gdb-csl-sourcerygxx-4_1-7:1.6
	gdb-csl-arm-2006q1-6:1.6
	gdb-csl-sourcerygxx-4_1-6:1.6
	gdb-csl-symbian-6_4_50_20060226-10:1.6
	gdb-csl-symbian-6_4_50_20060226-9:1.6
	gdb-csl-symbian-6_4_50_20060226-8:1.6
	gdb-csl-coldfire-4_1-11:1.6
	gdb-csl-sourcerygxx-3_4_4-19:1.6
	gdb-csl-coldfire-4_1-10:1.6
	gdb_6_5-branch:1.6.0.52
	gdb_6_5-2006-05-14-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-5:1.6
	nickrob-async-20060513-branch:1.6.0.50
	nickrob-async-20060513-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-4:1.6
	msnyder-reverse-20060502-branch:1.6.0.48
	msnyder-reverse-20060502-branchpoint:1.6
	gdb-csl-morpho-4_1-4:1.6
	gdb-csl-sourcerygxx-3_4_4-17:1.6
	readline_5_1-import-branch:1.6.0.46
	readline_5_1-import-branchpoint:1.6
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.6
	gdb-csl-symbian-20060226-branch:1.6.0.44
	gdb-csl-symbian-20060226-branchpoint:1.6
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.6
	msnyder-reverse-20060331-branch:1.6.0.42
	msnyder-reverse-20060331-branchpoint:1.6
	gdb-csl-available-20060303-branch:1.6.0.40
	gdb-csl-available-20060303-branchpoint:1.6
	gdb-csl-20060226-branch:1.6.0.38
	gdb-csl-20060226-branchpoint:1.6
	gdb_6_4-20051202-release:1.6
	msnyder-fork-checkpoint-branch:1.6.0.36
	msnyder-fork-checkpoint-branchpoint:1.6
	gdb-csl-gxxpro-6_3-branch:1.6.0.34
	gdb-csl-gxxpro-6_3-branchpoint:1.6
	gdb_6_4-branch:1.6.0.32
	gdb_6_4-2005-11-01-branchpoint:1.6
	gdb-csl-arm-20051020-branch:1.6.0.30
	gdb-csl-arm-20051020-branchpoint:1.6
	msnyder-tracepoint-checkpoint-branch:1.6.0.28
	msnyder-tracepoint-checkpoint-branchpoint:1.6
	gdb-csl-arm-20050325-2005-q1b:1.6
	gdb-csl-arm-20050325-2005-q1a:1.6
	csl-arm-20050325-branch:1.6.0.26
	csl-arm-20050325-branchpoint:1.6
	gdb_6_3-20041109-release:1.6
	gdb_6_3-branch:1.6.0.22
	gdb_6_3-20041019-branchpoint:1.6
	drow_intercu-merge-20040921:1.6
	drow_intercu-merge-20040915:1.6
	jimb-gdb_6_2-e500-branch:1.6.0.24
	jimb-gdb_6_2-e500-branchpoint:1.6
	gdb_6_2-20040730-release:1.6
	gdb_6_2-branch:1.6.0.20
	gdb_6_2-2004-07-10-gmt-branchpoint:1.6
	gdb_6_1_1-20040616-release:1.6
	gdb_6_1-2004-04-05-release:1.6
	drow_intercu-merge-20040402:1.6
	drow_intercu-merge-20040327:1.6
	ezannoni_pie-20040323-branch:1.6.0.18
	ezannoni_pie-20040323-branchpoint:1.6
	cagney_tramp-20040321-mergepoint:1.6
	cagney_tramp-20040309-branch:1.6.0.16
	cagney_tramp-20040309-branchpoint:1.6
	gdb_6_1-branch:1.6.0.14
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	drow_intercu-20040221-branch:1.6.0.12
	drow_intercu-20040221-branchpoint:1.6
	cagney_bfdfile-20040213-branch:1.6.0.10
	cagney_bfdfile-20040213-branchpoint:1.6
	drow-cplus-merge-20040208:1.6
	carlton_dictionary-20040126-merge:1.6
	cagney_bigcore-20040122-branch:1.6.0.8
	cagney_bigcore-20040122-branchpoint:1.6
	drow-cplus-merge-20040113:1.6
	drow-cplus-merge-20031224:1.6
	drow-cplus-merge-20031220:1.6
	carlton_dictionary-20031215-merge:1.6
	drow-cplus-merge-20031214:1.6
	carlton-dictionary-20031111-merge:1.6
	gdb_6_0-2003-10-04-release:1.5.58.1
	kettenis_sparc-20030918-branch:1.6.0.6
	kettenis_sparc-20030918-branchpoint:1.6
	carlton_dictionary-20030917-merge:1.6
	ezannoni_pie-20030916-branchpoint:1.6
	ezannoni_pie-20030916-branch:1.6.0.4
	cagney_x86i386-20030821-branch:1.6.0.2
	cagney_x86i386-20030821-branchpoint:1.6
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.58
	gdb_6_0-2003-06-23-branchpoint:1.5
	jimb-ppc64-linux-20030613-branch:1.5.0.56
	jimb-ppc64-linux-20030613-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.54
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.52
	cagney_writestrings-20030508-branchpoint:1.5
	jimb-ppc64-linux-20030528-branch:1.5.0.50
	jimb-ppc64-linux-20030528-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.48
	cagney_fileio-20030521-branchpoint:1.5
	kettenis_i386newframe-20030517-mergepoint:1.5
	jimb-ppc64-linux-20030509-branch:1.5.0.46
	jimb-ppc64-linux-20030509-branchpoint:1.5
	kettenis_i386newframe-20030504-mergepoint:1.5
	carlton_dictionary-20030430-merge:1.5
	kettenis_i386newframe-20030419-branch:1.5.0.44
	kettenis_i386newframe-20030419-branchpoint:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	kettenis_i386newframe-20030406-branch:1.5.0.42
	kettenis_i386newframe-20030406-branchpoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.40
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.38
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.36
	cagney_lazyid-20030317-branchpoint:1.5
	kettenis-i386newframe-20030316-mergepoint:1.5
	offbyone-20030313-branch:1.5.0.34
	offbyone-20030313-branchpoint:1.5
	kettenis-i386newframe-20030308-branch:1.5.0.32
	kettenis-i386newframe-20030308-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.30
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.28
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.26
	cagney-unwind-20030108-branchpoint:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.5
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.24
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.22
	carlton_dictionary-20020920-branchpoint:1.5
	gdb_5_3-branch:1.5.0.20
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.18
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.16
	readline_4_3-import-branchpoint:1.5
	gdb_5_2_1-2002-07-23-release:1.5
	kseitz_interps-20020528-branch:1.5.0.14
	kseitz_interps-20020528-branchpoint:1.5
	cagney_regbuf-20020515-branch:1.5.0.12
	cagney_regbuf-20020515-branchpoint:1.5
	jimb-macro-020506-branch:1.5.0.10
	jimb-macro-020506-branchpoint:1.5
	gdb_5_2-2002-04-29-release:1.5
	gdb_5_2-branch:1.5.0.8
	gdb_5_2-2002-03-03-branchpoint:1.5
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.4
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.2
	gdb_5_1-2001-07-29-branchpoint:1.5
	insight-precleanup-2001-01-01:1.4;
locks; strict;
comment	@ * @;


1.14
date	2013.01.01.06.41.38;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2012.01.04.08.28.13;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2011.01.01.15.34.02;	author brobecke;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2010.01.01.10.03.31;	author brobecke;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.14.10.53.08;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2008.01.01.22.53.25;	author drow;	state Exp;
branches;
next	1.8;

1.8
date	2007.08.24.14.28.37;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.09.17.59.18;	author drow;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.08.21.02.24;	author ciceron;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.20.15.36.29;	author ciceron;	state Exp;
branches
	1.5.22.1
	1.5.24.1
	1.5.58.1;
next	1.4;

1.4
date	2000.11.26.21.41.31;	author ciceron;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.09.21.00.39;	author ciceron;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.11.18.44.59;	author ciceron;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.27.11.23.39;	author cagney;	state Exp;
branches;
next	;

1.12.4.1
date	2012.01.06.04.54.53;	author brobecke;	state Exp;
branches;
next	;

1.5.22.1
date	2003.09.17.21.29.03;	author carlton;	state Exp;
branches;
next	;

1.5.24.1
date	2003.12.14.20.28.27;	author drow;	state Exp;
branches;
next	;

1.5.58.1
date	2003.08.08.21.04.44;	author ciceron;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/*  dv-m68hc11sio.c -- Simulation of the 68HC11 serial device.
    Copyright (C) 1999-2013 Free Software Foundation, Inc.
    Written by Stephane Carrez (stcarrez@@worldnet.fr)
    (From a driver model Contributed by Cygnus Solutions.)

    This file is part of the program GDB, the GNU debugger.
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    
    */


#include "sim-main.h"
#include "hw-main.h"
#include "dv-sockser.h"
#include "sim-assert.h"


/* DEVICE

        m68hc11sio - m68hc11 serial I/O

   
   DESCRIPTION

        Implements the m68hc11 serial I/O controller described in the m68hc11
        user guide. The serial I/O controller is directly connected to the CPU
        interrupt. The simulator implements:

            - baud rate emulation
            - 8-bits transfers
    
   PROPERTIES

   backend {tcp | stdio}

        Use dv-sockser TCP-port backend or stdio for backend.  Default: stdio.

   
   PORTS

   reset (input)

        Reset port. This port is only used to simulate a reset of the serial
        I/O controller. It should be connected to the RESET output of the cpu.

   */



/* port ID's */

enum
{
  RESET_PORT
};


static const struct hw_port_descriptor m68hc11sio_ports[] = 
{
  { "reset", RESET_PORT, 0, input_port, },
  { NULL, },
};


/* Serial Controller information.  */
struct m68hc11sio 
{
  enum {sio_tcp, sio_stdio} backend; /* backend */

  /* Number of cpu cycles to send a bit on the wire.  */
  unsigned long baud_cycle;

  /* Length in bits of characters sent, this includes the
     start/stop and parity bits.  Together with baud_cycle, this
     is used to find the number of cpu cycles to send/receive a data.  */
  unsigned int  data_length;

  /* Information about next character to be transmited.  */
  unsigned char tx_has_char;
  unsigned char tx_char;

  unsigned char rx_char;
  unsigned char rx_clear_scsr;
  
  /* Periodic I/O polling.  */
  struct hw_event* tx_poll_event;
  struct hw_event* rx_poll_event;
};



/* Finish off the partially created hw device.  Attach our local
   callbacks.  Wire up our port names etc.  */

static hw_io_read_buffer_method m68hc11sio_io_read_buffer;
static hw_io_write_buffer_method m68hc11sio_io_write_buffer;
static hw_port_event_method m68hc11sio_port_event;
static hw_ioctl_method m68hc11sio_ioctl;

#define M6811_SCI_FIRST_REG (M6811_BAUD)
#define M6811_SCI_LAST_REG  (M6811_SCDR)


static void
attach_m68hc11sio_regs (struct hw *me,
                        struct m68hc11sio *controller)
{
  hw_attach_address (hw_parent (me), M6811_IO_LEVEL, io_map,
                     M6811_SCI_FIRST_REG,
                     M6811_SCI_LAST_REG - M6811_SCI_FIRST_REG + 1,
		     me);

  if (hw_find_property(me, "backend") != NULL)
    {
      const char *value = hw_find_string_property(me, "backend");
      if(! strcmp(value, "tcp"))
	controller->backend = sio_tcp;
      else if(! strcmp(value, "stdio"))
	controller->backend = sio_stdio;
      else
	hw_abort (me, "illegal value for backend parameter `%s':"
                  "use tcp or stdio", value);
    }
}


static void
m68hc11sio_finish (struct hw *me)
{
  struct m68hc11sio *controller;

  controller = HW_ZALLOC (me, struct m68hc11sio);
  set_hw_data (me, controller);
  set_hw_io_read_buffer (me, m68hc11sio_io_read_buffer);
  set_hw_io_write_buffer (me, m68hc11sio_io_write_buffer);
  set_hw_ports (me, m68hc11sio_ports);
  set_hw_port_event (me, m68hc11sio_port_event);
#ifdef set_hw_ioctl
  set_hw_ioctl (me, m68hc11sio_ioctl);
#else
  me->to_ioctl = m68hc11sio_ioctl;
#endif

  /* Preset defaults.  */
  controller->backend = sio_stdio;

  /* Attach ourself to our parent bus.  */
  attach_m68hc11sio_regs (me, controller);

  /* Initialize to reset state.  */
  controller->tx_poll_event = NULL;
  controller->rx_poll_event = NULL;
  controller->tx_char       = 0;
  controller->tx_has_char   = 0;
  controller->rx_clear_scsr = 0;
  controller->rx_char       = 0;
}



/* An event arrives on an interrupt port.  */

static void
m68hc11sio_port_event (struct hw *me,
                       int my_port,
                       struct hw *source,
                       int source_port,
                       int level)
{
  SIM_DESC sd;
  struct m68hc11sio *controller;
  sim_cpu *cpu;
  unsigned8 val;
  
  controller = hw_data (me);
  sd         = hw_system (me);
  cpu        = STATE_CPU (sd, 0);  
  switch (my_port)
    {
    case RESET_PORT:
      {
	HW_TRACE ((me, "SCI reset"));

        /* Reset the state of SCI registers.  */
        val = 0;
        m68hc11sio_io_write_buffer (me, &val, io_map,
                                    (unsigned_word) M6811_BAUD, 1);
        m68hc11sio_io_write_buffer (me, &val, io_map,
                                    (unsigned_word) M6811_SCCR1, 1);
        m68hc11sio_io_write_buffer (me, &val, io_map,
                                    (unsigned_word) M6811_SCCR2, 1);
        
        cpu->ios[M6811_SCSR]    = M6811_TC | M6811_TDRE;
        controller->rx_char     = 0;
        controller->tx_char     = 0;
        controller->tx_has_char = 0;
        controller->rx_clear_scsr = 0;
        if (controller->rx_poll_event)
          {
            hw_event_queue_deschedule (me, controller->rx_poll_event);
            controller->rx_poll_event = 0;
          }
        if (controller->tx_poll_event)
          {
            hw_event_queue_deschedule (me, controller->tx_poll_event);
            controller->tx_poll_event = 0;
          }

        /* In bootstrap mode, initialize the SCI to 1200 bauds to
           simulate some initial setup by the internal rom.  */
        if (((cpu->ios[M6811_HPRIO]) & (M6811_SMOD | M6811_MDA)) == M6811_SMOD)
          {
            unsigned char val = 0x33;
            
            m68hc11sio_io_write_buffer (me, &val, io_map,
                                        (unsigned_word) M6811_BAUD, 1);
            val = 0x12;
            m68hc11sio_io_write_buffer (me, &val, io_map,
                                        (unsigned_word) M6811_SCCR2, 1);
          }
        break;
      }

    default:
      hw_abort (me, "Event on unknown port %d", my_port);
      break;
    }
}


void
m68hc11sio_rx_poll (struct hw *me, void *data)
{
  SIM_DESC sd;
  struct m68hc11sio *controller;
  sim_cpu *cpu;
  char cc;
  int cnt;
  int check_interrupt = 0;
  
  controller = hw_data (me);
  sd         = hw_system (me);
  cpu        = STATE_CPU (sd, 0);
  switch (controller->backend)
    {
    case sio_tcp:
      cnt = dv_sockser_read (sd);
      if (cnt != -1)
        {
          cc = (char) cnt;
          cnt = 1;
        }
      break;

    case sio_stdio:
      cnt = sim_io_poll_read (sd, 0 /* stdin */, &cc, 1);
      break;

    default:
      cnt = 0;
      break;
    }

  if (cnt == 1)
    {
      /* Raise the overrun flag if the previous character was not read.  */
      if (cpu->ios[M6811_SCSR] & M6811_RDRF)
        cpu->ios[M6811_SCSR] |= M6811_OR;

      cpu->ios[M6811_SCSR]     |= M6811_RDRF;
      controller->rx_char       = cc;
      controller->rx_clear_scsr = 0;
      check_interrupt = 1;
    }
  else
    {
      /* handle idle line detect here.  */
      ;
    }

  if (controller->rx_poll_event)
    {
      hw_event_queue_deschedule (me, controller->rx_poll_event);
      controller->rx_poll_event = 0;
    }

  if (cpu->ios[M6811_SCCR2] & M6811_RE)
    {
      unsigned long clock_cycle;

      /* Compute CPU clock cycles to wait for the next character.  */
      clock_cycle = controller->data_length * controller->baud_cycle;

      controller->rx_poll_event = hw_event_queue_schedule (me, clock_cycle,
                                                           m68hc11sio_rx_poll,
                                                           NULL);
    }

  if (check_interrupt)
      interrupts_update_pending (&cpu->cpu_interrupts);
}


void
m68hc11sio_tx_poll (struct hw *me, void *data)
{
  SIM_DESC sd;
  struct m68hc11sio *controller;
  sim_cpu *cpu;
  
  controller = hw_data (me);
  sd         = hw_system (me);
  cpu        = STATE_CPU (sd, 0);

  cpu->ios[M6811_SCSR] |= M6811_TDRE;
  cpu->ios[M6811_SCSR] |= M6811_TC;
  
  /* Transmitter is enabled and we have something to send.  */
  if ((cpu->ios[M6811_SCCR2] & M6811_TE) && controller->tx_has_char)
    {
      cpu->ios[M6811_SCSR] &= ~M6811_TDRE;
      cpu->ios[M6811_SCSR] &= ~M6811_TC;
      controller->tx_has_char = 0;
      switch (controller->backend)
        {
        case sio_tcp:
          dv_sockser_write (sd, controller->tx_char);
          break;

        case sio_stdio:
          sim_io_write_stdout (sd, &controller->tx_char, 1);
          sim_io_flush_stdout (sd);
          break;

        default:
          break;
        }
    }

  if (controller->tx_poll_event)
    {
      hw_event_queue_deschedule (me, controller->tx_poll_event);
      controller->tx_poll_event = 0;
    }
  
  if ((cpu->ios[M6811_SCCR2] & M6811_TE)
      && ((cpu->ios[M6811_SCSR] & M6811_TC) == 0))
    {
      unsigned long clock_cycle;
      
      /* Compute CPU clock cycles to wait for the next character.  */
      clock_cycle = controller->data_length * controller->baud_cycle;

      controller->tx_poll_event = hw_event_queue_schedule (me, clock_cycle,
                                                           m68hc11sio_tx_poll,
                                                           NULL);
    }

  interrupts_update_pending (&cpu->cpu_interrupts);
}

/* Descriptions of the SIO I/O ports.  These descriptions are only used to
   give information of the SIO device under GDB.  */
io_reg_desc sccr2_desc[] = {
  { M6811_TIE,   "TIE  ", "Transmit Interrupt Enable" },
  { M6811_TCIE,  "TCIE ", "Transmit Complete Interrupt Enable" },
  { M6811_RIE,   "RIE  ", "Receive Interrupt Enable" },
  { M6811_ILIE,  "ILIE ", "Idle Line Interrupt Enable" },
  { M6811_TE,    "TE   ", "Transmit Enable" },
  { M6811_RE,    "RE   ", "Receive Enable" },
  { M6811_RWU,   "RWU  ", "Receiver Wake Up" },
  { M6811_SBK,   "SBRK ", "Send Break" },
  { 0,  0, 0 }
};

io_reg_desc sccr1_desc[] = {
  { M6811_R8,    "R8   ", "Receive Data bit 8" },
  { M6811_T8,    "T8   ", "Transmit Data bit 8" },
  { M6811_M,     "M    ", "SCI Character length (0=8-bits, 1=9-bits)" },
  { M6811_WAKE,  "WAKE ", "Wake up method select (0=idle, 1=addr mark" },
  { 0,  0, 0 }
};

io_reg_desc scsr_desc[] = {
  { M6811_TDRE,  "TDRE ", "Transmit Data Register Empty" },
  { M6811_TC,    "TC   ", "Transmit Complete" },
  { M6811_RDRF,  "RDRF ", "Receive Data Register Full" },
  { M6811_IDLE,  "IDLE ", "Idle Line Detect" },
  { M6811_OR,    "OR   ", "Overrun Error" },
  { M6811_NF,    "NF   ", "Noise Flag" },
  { M6811_FE,    "FE   ", "Framing Error" },
  { 0,  0, 0 }
};

io_reg_desc baud_desc[] = {
  { M6811_TCLR,  "TCLR ", "Clear baud rate (test mode)" },
  { M6811_SCP1,  "SCP1 ", "SCI baud rate prescaler select (SCP1)" },
  { M6811_SCP0,  "SCP0 ", "SCI baud rate prescaler select (SCP0)" },
  { M6811_RCKB,  "RCKB ", "Baur Rate Clock Check (test mode)" },
  { M6811_SCR2,  "SCR2 ", "SCI Baud rate select (SCR2)" },
  { M6811_SCR1,  "SCR1 ", "SCI Baud rate select (SCR1)" },
  { M6811_SCR0,  "SCR0 ", "SCI Baud rate select (SCR0)" },
  { 0,  0, 0 }
};

static void
m68hc11sio_info (struct hw *me)
{
  SIM_DESC sd;
  uint16 base = 0;
  sim_cpu *cpu;
  struct m68hc11sio *controller;
  uint8 val;
  long clock_cycle;
  
  sd = hw_system (me);
  cpu = STATE_CPU (sd, 0);
  controller = hw_data (me);
  
  sim_io_printf (sd, "M68HC11 SIO:\n");

  base = cpu_get_io_base (cpu);

  val  = cpu->ios[M6811_BAUD];
  print_io_byte (sd, "BAUD ", baud_desc, val, base + M6811_BAUD);
  sim_io_printf (sd, " (%ld baud)\n",
                 (cpu->cpu_frequency / 4) / controller->baud_cycle);

  val = cpu->ios[M6811_SCCR1];
  print_io_byte (sd, "SCCR1", sccr1_desc, val, base + M6811_SCCR1);
  sim_io_printf (sd, "  (%d bits) (%dN1)\n",
                 controller->data_length, controller->data_length - 2);

  val = cpu->ios[M6811_SCCR2];
  print_io_byte (sd, "SCCR2", sccr2_desc, val, base + M6811_SCCR2);
  sim_io_printf (sd, "\n");

  val = cpu->ios[M6811_SCSR];
  print_io_byte (sd, "SCSR ", scsr_desc, val, base + M6811_SCSR);
  sim_io_printf (sd, "\n");

  clock_cycle = controller->data_length * controller->baud_cycle;
  
  if (controller->tx_poll_event)
    {
      signed64 t;
      int n;

      t = hw_event_remain_time (me, controller->tx_poll_event);
      n = (clock_cycle - t) / controller->baud_cycle;
      n = controller->data_length - n;
      sim_io_printf (sd, "  Transmit finished in %s (%d bit%s)\n",
		     cycle_to_string (cpu, t, PRINT_TIME | PRINT_CYCLE),
                     n, (n > 1 ? "s" : ""));
    }
  if (controller->rx_poll_event)
    {
      signed64 t;

      t = hw_event_remain_time (me, controller->rx_poll_event);
      sim_io_printf (sd, "  Receive finished in %s\n",
		     cycle_to_string (cpu, t, PRINT_TIME | PRINT_CYCLE));
    }
  
}

static int
m68hc11sio_ioctl (struct hw *me,
                  hw_ioctl_request request,
                  va_list ap)
{
  m68hc11sio_info (me);
  return 0;
}

/* generic read/write */

static unsigned
m68hc11sio_io_read_buffer (struct hw *me,
                           void *dest,
                           int space,
                           unsigned_word base,
                           unsigned nr_bytes)
{
  SIM_DESC sd;
  struct m68hc11sio *controller;
  sim_cpu *cpu;
  unsigned8 val;
  
  HW_TRACE ((me, "read 0x%08lx %d", (long) base, (int) nr_bytes));

  sd  = hw_system (me);
  cpu = STATE_CPU (sd, 0);
  controller = hw_data (me);

  switch (base)
    {
    case M6811_SCSR:
      controller->rx_clear_scsr = cpu->ios[M6811_SCSR]
        & (M6811_RDRF | M6811_IDLE | M6811_OR | M6811_NF | M6811_FE);
      
    case M6811_BAUD:
    case M6811_SCCR1:
    case M6811_SCCR2:
      val = cpu->ios[base];
      break;
      
    case M6811_SCDR:
      if (controller->rx_clear_scsr)
        {
          cpu->ios[M6811_SCSR] &= ~controller->rx_clear_scsr;
        }
      val = controller->rx_char;
      break;
      
    default:
      return 0;
    }
  *((unsigned8*) dest) = val;
  return 1;
}

static unsigned
m68hc11sio_io_write_buffer (struct hw *me,
                            const void *source,
                            int space,
                            unsigned_word base,
                            unsigned nr_bytes)
{
  SIM_DESC sd;
  struct m68hc11sio *controller;
  sim_cpu *cpu;
  unsigned8 val;

  HW_TRACE ((me, "write 0x%08lx %d", (long) base, (int) nr_bytes));

  sd  = hw_system (me);
  cpu = STATE_CPU (sd, 0);
  controller = hw_data (me);
  
  val = *((const unsigned8*) source);
  switch (base)
    {
    case M6811_BAUD:
      {
        long divisor;
        long baud;

        cpu->ios[M6811_BAUD] = val;        
        switch (val & (M6811_SCP1|M6811_SCP0))
          {
          case M6811_BAUD_DIV_1:
            divisor = 1 * 16;
            break;

          case M6811_BAUD_DIV_3:
            divisor = 3 * 16;
            break;

          case M6811_BAUD_DIV_4:
            divisor = 4 * 16;
            break;

          default:
          case M6811_BAUD_DIV_13:
            divisor = 13 * 16;
            break;
          }
        val &= (M6811_SCR2|M6811_SCR1|M6811_SCR0);
        divisor *= (1 << val);

        baud = (cpu->cpu_frequency / 4) / divisor;

        HW_TRACE ((me, "divide rate %ld, baud rate %ld",
                   divisor, baud));

        controller->baud_cycle = divisor;
      }
      break;
      
    case M6811_SCCR1:
      {
        if (val & M6811_M)
          controller->data_length = 11;
        else
          controller->data_length = 10;

        cpu->ios[M6811_SCCR1] = val;
      }
      break;
      
    case M6811_SCCR2:
      if ((val & M6811_RE) == 0)
        {
          val &= ~(M6811_RDRF|M6811_IDLE|M6811_OR|M6811_NF|M6811_NF);
          val |= (cpu->ios[M6811_SCCR2]
                  & (M6811_RDRF|M6811_IDLE|M6811_OR|M6811_NF|M6811_NF));
          cpu->ios[M6811_SCCR2] = val;
          break;
        }

      /* Activate reception.  */
      if (controller->rx_poll_event == 0)
        {
          long clock_cycle;
          
          /* Compute CPU clock cycles to wait for the next character.  */
          clock_cycle = controller->data_length * controller->baud_cycle;

          controller->rx_poll_event = hw_event_queue_schedule (me, clock_cycle,
                                                               m68hc11sio_rx_poll,
                                                               NULL);
        }      
      cpu->ios[M6811_SCCR2] = val;
      interrupts_update_pending (&cpu->cpu_interrupts);
      break;

      /* No effect.  */
    case M6811_SCSR:
      return 1;
      
    case M6811_SCDR:
      if (!(cpu->ios[M6811_SCSR] & M6811_TDRE))
        {
          return 0;
        }

      controller->tx_char     = val;
      controller->tx_has_char = 1;
      if ((cpu->ios[M6811_SCCR2] & M6811_TE)
          && controller->tx_poll_event == 0)
        {
          m68hc11sio_tx_poll (me, NULL);
        }
      return 1;
      
    default:
      return 0;
    }
  return nr_bytes;
}     


const struct hw_descriptor dv_m68hc11sio_descriptor[] = {
  { "m68hc11sio", m68hc11sio_finish },
  { "m68hc12sio", m68hc11sio_finish },
  { NULL },
};

@


1.13
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 1
    Copyright (C) 1999-2001, 2007-2012 Free Software Foundation, Inc.
@


1.12
log
@run copyright.sh for 2011.
@
text
@d2 1
a2 2
    Copyright (C) 1999, 2000, 2001, 2007, 2008, 2009, 2010, 2011
    Free Software Foundation, Inc.
@


1.12.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 1
    Copyright (C) 1999-2001, 2007-2012 Free Software Foundation, Inc.
@


1.11
log
@Update copyright notices to add year 2010.
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000, 2001, 2007, 2008, 2009, 2010
@


1.10
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000, 2001, 2007, 2008, 2009
@


1.9
log
@	Updated copyright notices for most files.
@
text
@d2 2
a3 1
    Copyright (C) 1999, 2000, 2001, 2007, 2008 Free Software Foundation, Inc.
@


1.8
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000, 2001, 2007 Free Software Foundation, Inc.
@


1.7
log
@Copyright updates for 2007.
@
text
@d10 1
a10 1
    the Free Software Foundation; either version 2 of the License, or
d12 1
a12 1
    
d17 1
a17 1
    
d19 1
a19 2
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@


1.6
log
@	* dv-m68hc11tim.c (cycle_to_string): Add flags parameter to better
	control the translation.
	(m68hc11tim_print_timer): Update cycle_to_string conversion.
	(m68hc11tim_timer_event): Fix handling of output
	compare register with its interrupts.
	(m68hc11tim_io_write_buffer): Check output compare
	after setting M6811_TMSK1.
	(m68hc11tim_io_read_buffer): Fix compilation warning.
	* dv-m68hc11.c (m68hc11_option_handler): Likewise.
	* dv-m68hc11spi.c (m68hc11spi_info): Likewise.
	* dv-m68hc11sio.c (m68hc11sio_info): Likewise.
	* interrupts.c (interrupts_info): Likewise.
	(interrupts_reset): Recognize bootstrap mode.
	* sim-main.h (PRINT_CYCLE, PRINT_TIME): New defines.
	(_sim_cpu): Add cpu_start_mode.
	(cycle_to_string): Add flags member.
	* m68hc11_sim.c (OPTION_CPU_BOOTSTRAP): New option.
	(cpu_options): Declare new option bootstrap.
	(cpu_option_handler): Handle it.
	(cpu_info): Update call to cycle_to_string.
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.5
log
@	* dv-m68hc11sio.c (m68hc11sio_tx_poll): Always check for
	pending interrupts.
	* interrupts.c (interrupts_process): Keep track of the last number
	of masked insn cycles.
	(interrupts_initialize): Clear last number of masked insn cycles.
	(interrupts_info): Report them.
	(interrupts_update_pending): Compute clear and set masks of
	interrupts and clear the interrupt bits before setting them
	(due to SCI interrupt sharing).
	* interrupts.h (struct interrupts): New members last_mask_cycles
	and xirq_last_mask_cycles.
@
text
@d466 2
a467 1
		     cycle_to_string (cpu, t), n, (n > 1 ? "s" : ""));
d475 1
a475 1
		     cycle_to_string (cpu, t));
@


1.5.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d466 1
a466 2
		     cycle_to_string (cpu, t, PRINT_TIME | PRINT_CYCLE),
                     n, (n > 1 ? "s" : ""));
d474 1
a474 1
		     cycle_to_string (cpu, t, PRINT_TIME | PRINT_CYCLE));
@


1.5.22.1
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d466 1
a466 2
		     cycle_to_string (cpu, t, PRINT_TIME | PRINT_CYCLE),
                     n, (n > 1 ? "s" : ""));
d474 1
a474 1
		     cycle_to_string (cpu, t, PRINT_TIME | PRINT_CYCLE));
@


1.5.58.1
log
@	* dv-m68hc11tim.c (cycle_to_string): Add flags parameter to better
	control the translation.
	(m68hc11tim_print_timer): Update cycle_to_string conversion.
	(m68hc11tim_timer_event): Fix handling of output
	compare register with its interrupts.
	(m68hc11tim_io_write_buffer): Check output compare
	after setting M6811_TMSK1.
	(m68hc11tim_io_read_buffer): Fix compilation warning.
	* dv-m68hc11.c (m68hc11_option_handler): Likewise.
	* dv-m68hc11spi.c (m68hc11spi_info): Likewise.
	* dv-m68hc11sio.c (m68hc11sio_info): Likewise.
	* interrupts.c (interrupts_info): Likewise.
	(interrupts_reset): Recognize bootstrap mode.
	* sim-main.h (PRINT_CYCLE, PRINT_TIME): New defines.
	(_sim_cpu): Add cpu_start_mode.
	(cycle_to_string): Add flags member.
	* m68hc11_sim.c (OPTION_CPU_BOOTSTRAP): New option.
	(cpu_options): Declare new option bootstrap.
	(cpu_option_handler): Handle it.
	(cpu_info): Update call to cycle_to_string.
@
text
@d466 1
a466 2
		     cycle_to_string (cpu, t, PRINT_TIME | PRINT_CYCLE),
                     n, (n > 1 ? "s" : ""));
d474 1
a474 1
		     cycle_to_string (cpu, t, PRINT_TIME | PRINT_CYCLE));
@


1.4
log
@Preliminary support for 68HC12
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000 Free Software Foundation, Inc.
a322 1
  int check_interrupt = 0;
d331 1
a331 1
  /* Transmitter is enabled and we have something to sent.  */
a336 1
      check_interrupt = 1;
d372 1
a372 2
  if (check_interrupt)
      interrupts_update_pending (&cpu->cpu_interrupts);
@


1.3
log
@	* sim-main.h: Define cycle_to_string.
	* dv-m68hc11tim.c (cycle_to_string): New function to translate
	the cpu cycle into some formatted time string.
	(m68hc11tim_print_timer): Use it.
	* dv-m68hc11sio.c (m68hc11sio_info): Use cycle_to_string.
	* dv-m68hc11spi.c (m68hc11spi_info): Likewise.
	* interrupts.c (interrupts_info): Likewise.
	* m68hc11_sim.c (cpu_info): Likewise.
@
text
@d660 2
a661 1
  { "m68hc11sio", m68hc11sio_finish, },
@


1.2
log
@Use address mapping levels for 68hc11 simulator (kill overlap hack)
@
text
@d468 2
a469 2
      sim_io_printf (sd, "  Transmit finished in %ld cycles (%d bit%s)\n",
		     (long) t, n, (n > 1 ? "s" : ""));
d476 2
a477 2
      sim_io_printf (sd, "  Receive finished in %ld cycles\n",
		     (long) t);
@


1.1
log
@New simulator.
@
text
@d121 1
a121 1
  hw_attach_address (hw_parent (me), 0, io_map,
a145 1
  me->overlap_mode_hw = 1;
@

