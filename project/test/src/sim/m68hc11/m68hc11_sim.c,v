head	1.18;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.18
	gdb_7_6-2013-04-26-release:1.18
	gdb_7_6-branch:1.18.0.2
	gdb_7_6-2013-03-12-branchpoint:1.18
	gdb_7_5_1-2012-11-29-release:1.17
	gdb_7_5-2012-08-17-release:1.17
	gdb_7_5-branch:1.17.0.2
	gdb_7_5-2012-07-18-branchpoint:1.17
	gdb_7_4_1-2012-04-26-release:1.16.4.1
	gdb_7_4-2012-01-24-release:1.16.4.1
	gdb_7_4-branch:1.16.0.4
	gdb_7_4-2011-12-13-branchpoint:1.16
	gdb_7_3_1-2011-09-04-release:1.16
	gdb_7_3-2011-07-26-release:1.16
	gdb_7_3-branch:1.16.0.2
	gdb_7_3-2011-04-01-branchpoint:1.16
	gdb_7_2-2010-09-02-release:1.15
	gdb_7_2-branch:1.15.0.4
	gdb_7_2-2010-07-07-branchpoint:1.15
	gdb_7_1-2010-03-18-release:1.15
	gdb_7_1-branch:1.15.0.2
	gdb_7_1-2010-02-18-branchpoint:1.15
	gdb_7_0_1-2009-12-22-release:1.14
	gdb_7_0-2009-10-06-release:1.14
	gdb_7_0-branch:1.14.0.4
	gdb_7_0-2009-09-16-branchpoint:1.14
	arc-sim-20090309:1.13
	msnyder-checkpoint-072509-branch:1.14.0.2
	msnyder-checkpoint-072509-branchpoint:1.14
	arc-insight_6_8-branch:1.13.0.16
	arc-insight_6_8-branchpoint:1.13
	insight_6_8-branch:1.13.0.14
	insight_6_8-branchpoint:1.13
	reverse-20081226-branch:1.13.0.12
	reverse-20081226-branchpoint:1.13
	multiprocess-20081120-branch:1.13.0.10
	multiprocess-20081120-branchpoint:1.13
	reverse-20080930-branch:1.13.0.8
	reverse-20080930-branchpoint:1.13
	reverse-20080717-branch:1.13.0.6
	reverse-20080717-branchpoint:1.13
	msnyder-reverse-20080609-branch:1.13.0.4
	msnyder-reverse-20080609-branchpoint:1.13
	drow-reverse-20070409-branch:1.11.0.2
	drow-reverse-20070409-branchpoint:1.11
	gdb_6_8-2008-03-27-release:1.13
	gdb_6_8-branch:1.13.0.2
	gdb_6_8-2008-02-26-branchpoint:1.13
	gdb_6_7_1-2007-10-29-release:1.12
	gdb_6_7-2007-10-10-release:1.12
	gdb_6_7-branch:1.12.0.2
	gdb_6_7-2007-09-07-branchpoint:1.12
	insight_6_6-20070208-release:1.10
	gdb_6_6-2006-12-18-release:1.10
	gdb_6_6-branch:1.10.0.54
	gdb_6_6-2006-11-15-branchpoint:1.10
	insight_6_5-20061003-release:1.10
	gdb-csl-symbian-6_4_50_20060226-12:1.10
	gdb-csl-sourcerygxx-3_4_4-25:1.10
	nickrob-async-20060828-mergepoint:1.10
	gdb-csl-symbian-6_4_50_20060226-11:1.10
	gdb-csl-sourcerygxx-4_1-17:1.10
	gdb-csl-20060226-branch-local-2:1.10
	gdb-csl-sourcerygxx-4_1-14:1.10
	gdb-csl-sourcerygxx-4_1-13:1.10
	gdb-csl-sourcerygxx-4_1-12:1.10
	gdb-csl-sourcerygxx-3_4_4-21:1.10
	gdb_6_5-20060621-release:1.10
	gdb-csl-sourcerygxx-4_1-9:1.10
	gdb-csl-sourcerygxx-4_1-8:1.10
	gdb-csl-sourcerygxx-4_1-7:1.10
	gdb-csl-arm-2006q1-6:1.10
	gdb-csl-sourcerygxx-4_1-6:1.10
	gdb-csl-symbian-6_4_50_20060226-10:1.10
	gdb-csl-symbian-6_4_50_20060226-9:1.10
	gdb-csl-symbian-6_4_50_20060226-8:1.10
	gdb-csl-coldfire-4_1-11:1.10
	gdb-csl-sourcerygxx-3_4_4-19:1.10
	gdb-csl-coldfire-4_1-10:1.10
	gdb_6_5-branch:1.10.0.52
	gdb_6_5-2006-05-14-branchpoint:1.10
	gdb-csl-sourcerygxx-4_1-5:1.10
	nickrob-async-20060513-branch:1.10.0.50
	nickrob-async-20060513-branchpoint:1.10
	gdb-csl-sourcerygxx-4_1-4:1.10
	msnyder-reverse-20060502-branch:1.10.0.48
	msnyder-reverse-20060502-branchpoint:1.10
	gdb-csl-morpho-4_1-4:1.10
	gdb-csl-sourcerygxx-3_4_4-17:1.10
	readline_5_1-import-branch:1.10.0.46
	readline_5_1-import-branchpoint:1.10
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.10
	gdb-csl-symbian-20060226-branch:1.10.0.44
	gdb-csl-symbian-20060226-branchpoint:1.10
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.10
	msnyder-reverse-20060331-branch:1.10.0.42
	msnyder-reverse-20060331-branchpoint:1.10
	gdb-csl-available-20060303-branch:1.10.0.40
	gdb-csl-available-20060303-branchpoint:1.10
	gdb-csl-20060226-branch:1.10.0.38
	gdb-csl-20060226-branchpoint:1.10
	gdb_6_4-20051202-release:1.10
	msnyder-fork-checkpoint-branch:1.10.0.36
	msnyder-fork-checkpoint-branchpoint:1.10
	gdb-csl-gxxpro-6_3-branch:1.10.0.34
	gdb-csl-gxxpro-6_3-branchpoint:1.10
	gdb_6_4-branch:1.10.0.32
	gdb_6_4-2005-11-01-branchpoint:1.10
	gdb-csl-arm-20051020-branch:1.10.0.30
	gdb-csl-arm-20051020-branchpoint:1.10
	msnyder-tracepoint-checkpoint-branch:1.10.0.28
	msnyder-tracepoint-checkpoint-branchpoint:1.10
	gdb-csl-arm-20050325-2005-q1b:1.10
	gdb-csl-arm-20050325-2005-q1a:1.10
	csl-arm-20050325-branch:1.10.0.26
	csl-arm-20050325-branchpoint:1.10
	gdb_6_3-20041109-release:1.10
	gdb_6_3-branch:1.10.0.22
	gdb_6_3-20041019-branchpoint:1.10
	drow_intercu-merge-20040921:1.10
	drow_intercu-merge-20040915:1.10
	jimb-gdb_6_2-e500-branch:1.10.0.24
	jimb-gdb_6_2-e500-branchpoint:1.10
	gdb_6_2-20040730-release:1.10
	gdb_6_2-branch:1.10.0.20
	gdb_6_2-2004-07-10-gmt-branchpoint:1.10
	gdb_6_1_1-20040616-release:1.10
	gdb_6_1-2004-04-05-release:1.10
	drow_intercu-merge-20040402:1.10
	drow_intercu-merge-20040327:1.10
	ezannoni_pie-20040323-branch:1.10.0.18
	ezannoni_pie-20040323-branchpoint:1.10
	cagney_tramp-20040321-mergepoint:1.10
	cagney_tramp-20040309-branch:1.10.0.16
	cagney_tramp-20040309-branchpoint:1.10
	gdb_6_1-branch:1.10.0.14
	gdb_6_1-2004-03-01-gmt-branchpoint:1.10
	drow_intercu-20040221-branch:1.10.0.12
	drow_intercu-20040221-branchpoint:1.10
	cagney_bfdfile-20040213-branch:1.10.0.10
	cagney_bfdfile-20040213-branchpoint:1.10
	drow-cplus-merge-20040208:1.10
	carlton_dictionary-20040126-merge:1.10
	cagney_bigcore-20040122-branch:1.10.0.8
	cagney_bigcore-20040122-branchpoint:1.10
	drow-cplus-merge-20040113:1.10
	drow-cplus-merge-20031224:1.10
	drow-cplus-merge-20031220:1.10
	carlton_dictionary-20031215-merge:1.10
	drow-cplus-merge-20031214:1.10
	carlton-dictionary-20031111-merge:1.10
	gdb_6_0-2003-10-04-release:1.7.44.3
	kettenis_sparc-20030918-branch:1.10.0.6
	kettenis_sparc-20030918-branchpoint:1.10
	carlton_dictionary-20030917-merge:1.10
	ezannoni_pie-20030916-branchpoint:1.10
	ezannoni_pie-20030916-branch:1.10.0.4
	cagney_x86i386-20030821-branch:1.10.0.2
	cagney_x86i386-20030821-branchpoint:1.10
	carlton_dictionary-20030805-merge:1.7
	carlton_dictionary-20030627-merge:1.7
	gdb_6_0-branch:1.7.0.44
	gdb_6_0-2003-06-23-branchpoint:1.7
	jimb-ppc64-linux-20030613-branch:1.7.0.42
	jimb-ppc64-linux-20030613-branchpoint:1.7
	cagney_convert-20030606-branch:1.7.0.40
	cagney_convert-20030606-branchpoint:1.7
	cagney_writestrings-20030508-branch:1.7.0.38
	cagney_writestrings-20030508-branchpoint:1.7
	jimb-ppc64-linux-20030528-branch:1.7.0.36
	jimb-ppc64-linux-20030528-branchpoint:1.7
	carlton_dictionary-20030523-merge:1.7
	cagney_fileio-20030521-branch:1.7.0.34
	cagney_fileio-20030521-branchpoint:1.7
	kettenis_i386newframe-20030517-mergepoint:1.7
	jimb-ppc64-linux-20030509-branch:1.7.0.32
	jimb-ppc64-linux-20030509-branchpoint:1.7
	kettenis_i386newframe-20030504-mergepoint:1.7
	carlton_dictionary-20030430-merge:1.7
	kettenis_i386newframe-20030419-branch:1.7.0.30
	kettenis_i386newframe-20030419-branchpoint:1.7
	carlton_dictionary-20030416-merge:1.7
	cagney_frameaddr-20030409-mergepoint:1.7
	kettenis_i386newframe-20030406-branch:1.7.0.28
	kettenis_i386newframe-20030406-branchpoint:1.7
	cagney_frameaddr-20030403-branchpoint:1.7
	cagney_frameaddr-20030403-branch:1.7.0.26
	cagney_framebase-20030330-mergepoint:1.7
	cagney_framebase-20030326-branch:1.7.0.24
	cagney_framebase-20030326-branchpoint:1.7
	cagney_lazyid-20030317-branch:1.7.0.22
	cagney_lazyid-20030317-branchpoint:1.7
	kettenis-i386newframe-20030316-mergepoint:1.7
	offbyone-20030313-branch:1.7.0.20
	offbyone-20030313-branchpoint:1.7
	kettenis-i386newframe-20030308-branch:1.7.0.18
	kettenis-i386newframe-20030308-branchpoint:1.7
	carlton_dictionary-20030305-merge:1.7
	cagney_offbyone-20030303-branch:1.7.0.16
	cagney_offbyone-20030303-branchpoint:1.7
	carlton_dictionary-20030207-merge:1.7
	interps-20030202-branch:1.7.0.14
	interps-20030202-branchpoint:1.7
	cagney-unwind-20030108-branch:1.7.0.12
	cagney-unwind-20030108-branchpoint:1.7
	carlton_dictionary-20021223-merge:1.7
	gdb_5_3-2002-12-12-release:1.7
	carlton_dictionary-20021115-merge:1.7
	kseitz_interps-20021105-merge:1.7
	kseitz_interps-20021103-merge:1.7
	drow-cplus-merge-20021020:1.7
	drow-cplus-merge-20021025:1.7
	carlton_dictionary-20021025-merge:1.7
	carlton_dictionary-20021011-merge:1.7
	drow-cplus-branch:1.7.0.10
	drow-cplus-branchpoint:1.7
	kseitz_interps-20020930-merge:1.7
	carlton_dictionary-20020927-merge:1.7
	carlton_dictionary-branch:1.7.0.8
	carlton_dictionary-20020920-branchpoint:1.7
	gdb_5_3-branch:1.7.0.6
	gdb_5_3-2002-09-04-branchpoint:1.7
	kseitz_interps-20020829-merge:1.7
	cagney_sysregs-20020825-branch:1.7.0.4
	cagney_sysregs-20020825-branchpoint:1.7
	readline_4_3-import-branch:1.7.0.2
	readline_4_3-import-branchpoint:1.7
	gdb_5_2_1-2002-07-23-release:1.3.8.3
	kseitz_interps-20020528-branch:1.6.0.6
	kseitz_interps-20020528-branchpoint:1.6
	cagney_regbuf-20020515-branch:1.6.0.4
	cagney_regbuf-20020515-branchpoint:1.6
	jimb-macro-020506-branch:1.6.0.2
	jimb-macro-020506-branchpoint:1.6
	gdb_5_2-2002-04-29-release:1.3.8.3
	gdb_5_2-branch:1.3.0.8
	gdb_5_2-2002-03-03-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.4
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.2
	gdb_5_1-2001-07-29-branchpoint:1.3
	insight-precleanup-2001-01-01:1.2;
locks; strict;
comment	@ * @;


1.18
date	2013.01.01.06.41.38;	author brobecke;	state Exp;
branches;
next	1.17;

1.17
date	2012.01.04.08.28.14;	author brobecke;	state Exp;
branches;
next	1.16;

1.16
date	2011.01.01.15.34.02;	author brobecke;	state Exp;
branches
	1.16.4.1;
next	1.15;

1.15
date	2010.01.01.10.03.31;	author brobecke;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.14.10.53.08;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2008.01.01.22.53.25;	author drow;	state Exp;
branches;
next	1.12;

1.12
date	2007.08.24.14.28.37;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2007.01.09.17.59.18;	author drow;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.08.21.00.55;	author ciceron;	state Exp;
branches;
next	1.9;

1.9
date	2003.08.08.20.42.21;	author ciceron;	state Exp;
branches;
next	1.8;

1.8
date	2003.08.08.20.25.49;	author ciceron;	state Exp;
branches;
next	1.7;

1.7
date	2002.08.13.07.46.09;	author ciceron;	state Exp;
branches
	1.7.8.1
	1.7.10.1
	1.7.44.1;
next	1.6;

1.6
date	2002.03.07.19.17.04;	author ciceron;	state Exp;
branches
	1.6.6.1;
next	1.5;

1.5
date	2002.03.07.19.06.34;	author ciceron;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.07.18.59.38;	author ciceron;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.20.15.40.27;	author ciceron;	state Exp;
branches
	1.3.8.1;
next	1.2;

1.2
date	2000.09.09.21.00.39;	author ciceron;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.27.11.23.39;	author cagney;	state Exp;
branches;
next	;

1.16.4.1
date	2012.01.06.04.54.53;	author brobecke;	state Exp;
branches;
next	;

1.7.8.1
date	2003.09.17.21.29.03;	author carlton;	state Exp;
branches;
next	;

1.7.10.1
date	2003.12.14.20.28.27;	author drow;	state Exp;
branches;
next	;

1.7.44.1
date	2003.08.08.20.26.28;	author ciceron;	state Exp;
branches;
next	1.7.44.2;

1.7.44.2
date	2003.08.08.20.45.31;	author ciceron;	state Exp;
branches;
next	1.7.44.3;

1.7.44.3
date	2003.08.08.21.04.44;	author ciceron;	state Exp;
branches;
next	;

1.6.6.1
date	2002.08.30.22.52.58;	author kseitz;	state Exp;
branches;
next	;

1.3.8.1
date	2002.03.07.19.02.18;	author ciceron;	state Exp;
branches;
next	1.3.8.2;

1.3.8.2
date	2002.03.07.19.07.13;	author ciceron;	state Exp;
branches;
next	1.3.8.3;

1.3.8.3
date	2002.03.07.19.18.40;	author ciceron;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* m6811_cpu.c -- 68HC11&68HC12 CPU Emulation
   Copyright 1999-2013 Free Software Foundation, Inc.
   Written by Stephane Carrez (stcarrez@@nerim.fr)

This file is part of GDB, GAS, and the GNU binutils.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "sim-main.h"
#include "sim-assert.h"
#include "sim-module.h"
#include "sim-options.h"

enum {
  OPTION_CPU_RESET = OPTION_START,
  OPTION_EMUL_OS,
  OPTION_CPU_CONFIG,
  OPTION_CPU_BOOTSTRAP,
  OPTION_CPU_MODE
};

static DECLARE_OPTION_HANDLER (cpu_option_handler);

static const OPTION cpu_options[] =
{
  { {"cpu-reset", no_argument, NULL, OPTION_CPU_RESET },
      '\0', NULL, "Reset the CPU",
      cpu_option_handler },

  { {"emulos",    no_argument, NULL, OPTION_EMUL_OS },
      '\0', NULL, "Emulate some OS system calls (read, write, ...)",
      cpu_option_handler },

  { {"cpu-config", required_argument, NULL, OPTION_CPU_CONFIG },
      '\0', NULL, "Specify the initial CPU configuration register",
      cpu_option_handler },

  { {"bootstrap", no_argument, NULL, OPTION_CPU_BOOTSTRAP },
      '\0', NULL, "Start the processing in bootstrap mode",
      cpu_option_handler },

  { {NULL, no_argument, NULL, 0}, '\0', NULL, NULL, NULL }
};


static SIM_RC
cpu_option_handler (SIM_DESC sd, sim_cpu *cpu,
                    int opt, char *arg, int is_command)
{
  int val;
  
  cpu = STATE_CPU (sd, 0);
  switch (opt)
    {
    case OPTION_CPU_RESET:
      sim_board_reset (sd);
      break;

    case OPTION_EMUL_OS:
      cpu->cpu_emul_syscall = 1;
      break;

    case OPTION_CPU_CONFIG:
      if (sscanf(arg, "0x%x", &val) == 1
          || sscanf(arg, "%d", &val) == 1)
        {
          cpu->cpu_config = val;
          cpu->cpu_use_local_config = 1;
        }
      else
        cpu->cpu_use_local_config = 0;
      break;

    case OPTION_CPU_BOOTSTRAP:
       cpu->cpu_start_mode = "bootstrap";
       break;

    case OPTION_CPU_MODE:
      break;
    }

  return SIM_RC_OK;
}

    
void
cpu_call (sim_cpu *cpu, uint16 addr)
{

  cpu_set_pc (cpu, addr);
}

void
cpu_return (sim_cpu *cpu)
{
}

/* Set the stack pointer and re-compute the current frame.  */
void
cpu_set_sp (sim_cpu *cpu, uint16 val)
{
  cpu->cpu_regs.sp = val;
}

uint16
cpu_get_reg (sim_cpu* cpu, uint8 reg)
{
  switch (reg)
    {
    case 0:
      return cpu_get_x (cpu);

    case 1:
      return cpu_get_y (cpu);

    case 2:
      return cpu_get_sp (cpu);

    case 3:
      return cpu_get_pc (cpu);

    default:
      return 0;
    }
}

uint16
cpu_get_src_reg (sim_cpu* cpu, uint8 reg)
{
  switch (reg)
    {
    case 0:
      return cpu_get_a (cpu);

    case 1:
      return cpu_get_b (cpu);

    case 2:
      return cpu_get_ccr (cpu);

    case 3:
      return cpu_get_tmp3 (cpu);

    case 4:
      return cpu_get_d (cpu);

    case 5:
      return cpu_get_x (cpu);

    case 6:
      return cpu_get_y (cpu);

    case 7:
      return cpu_get_sp (cpu);

    default:
      return 0;
    }
}

void
cpu_set_dst_reg (sim_cpu* cpu, uint8 reg, uint16 val)
{
  switch (reg)
    {
    case 0:
      cpu_set_a (cpu, val);
      break;

    case 1:
      cpu_set_b (cpu, val);
      break;

    case 2:
      cpu_set_ccr (cpu, val);
      break;

    case 3:
      cpu_set_tmp2 (cpu, val);
      break;

    case 4:
      cpu_set_d (cpu, val);
      break;

    case 5:
      cpu_set_x (cpu, val);
      break;

    case 6:
      cpu_set_y (cpu, val);
      break;

    case 7:
      cpu_set_sp (cpu, val);
      break;

    default:
      break;
    }
}

void
cpu_set_reg (sim_cpu* cpu, uint8 reg, uint16 val)
{
  switch (reg)
    {
    case 0:
      cpu_set_x (cpu, val);
      break;
      
    case 1:
      cpu_set_y (cpu, val);
      break;
      
    case 2:
      cpu_set_sp (cpu, val);
      break;
      
    case 3:
      cpu_set_pc (cpu, val);
      break;
      
    default:
      break;
    }
}

/* Returns the address of a 68HC12 indexed operand.
   Pre and post modifications are handled on the source register.  */
uint16
cpu_get_indexed_operand_addr (sim_cpu* cpu, int restrict)
{
  uint8 reg;
  uint16 sval;
  uint16 addr;
  uint8 code;

  code = cpu_fetch8 (cpu);

  /* n,r with 5-bit signed constant.  */
  if ((code & 0x20) == 0)
    {
      reg = (code >> 6) & 3;
      sval = (code & 0x1f);
      if (code & 0x10)
	sval |= 0xfff0;

      addr = cpu_get_reg (cpu, reg);
      addr += sval;
    }

  /* Auto pre/post increment/decrement.  */
  else if ((code & 0xc0) != 0xc0)
    {
      reg = (code >> 6) & 3;
      sval = (code & 0x0f);
      if (sval & 0x8)
	{
	  sval |= 0xfff0;
	}
      else
	{
	  sval = sval + 1;
	}
      addr = cpu_get_reg (cpu, reg);
      cpu_set_reg (cpu, reg, addr + sval);
      if ((code & 0x10) == 0)
	{
	  addr += sval;
	}
    }

  /* [n,r] 16-bits offset indexed indirect.  */
  else if ((code & 0x07) == 3)
    {
      if (restrict)
	{
	  return 0;
	}
      reg = (code >> 3) & 0x03;
      addr = cpu_get_reg (cpu, reg);
      addr += cpu_fetch16 (cpu);
      addr = memory_read16 (cpu, addr);
      cpu_add_cycles (cpu, 1);
    }
  else if ((code & 0x4) == 0)
    {
      if (restrict)
	{
	  return 0;
	}
      reg = (code >> 3) & 0x03;
      addr = cpu_get_reg (cpu, reg);
      if (code & 0x2)
	{
	  sval = cpu_fetch16 (cpu);
	  cpu_add_cycles (cpu, 1);
	}
      else
	{
	  sval = cpu_fetch8 (cpu);
	  if (code & 0x1)
	    sval |= 0xff00;
	  cpu_add_cycles (cpu, 1);
	}
      addr += sval;
    }
  else
    {
      reg = (code >> 3) & 0x03;
      addr = cpu_get_reg (cpu, reg);
      switch (code & 3)
	{
	case 0:
	  addr += cpu_get_a (cpu);
	  break;
	case 1:
	  addr += cpu_get_b (cpu);
	  break;
	case 2:
	  addr += cpu_get_d (cpu);
	  break;
	case 3:
	default:
	  addr += cpu_get_d (cpu);
	  addr = memory_read16 (cpu, addr);
	  cpu_add_cycles (cpu, 1);
	  break;
	}
    }

  return addr;
}

uint8
cpu_get_indexed_operand8 (sim_cpu* cpu, int restrict)
{
  uint16 addr;

  addr = cpu_get_indexed_operand_addr (cpu, restrict);
  return memory_read8 (cpu, addr);
}

uint16
cpu_get_indexed_operand16 (sim_cpu* cpu, int restrict)
{
  uint16 addr;

  addr = cpu_get_indexed_operand_addr (cpu, restrict);
  return memory_read16 (cpu, addr);
}

void
cpu_move8 (sim_cpu *cpu, uint8 code)
{
  uint8 src;
  uint16 addr;

  switch (code)
    {
    case 0x0b:
      src = cpu_fetch8 (cpu);
      addr = cpu_fetch16 (cpu);
      break;

    case 0x08:
      addr = cpu_get_indexed_operand_addr (cpu, 1);
      src = cpu_fetch8 (cpu);
      break;

    case 0x0c:
      addr = cpu_fetch16 (cpu);
      src = memory_read8 (cpu, addr);
      addr = cpu_fetch16 (cpu);
      break;

    case 0x09:
      addr = cpu_get_indexed_operand_addr (cpu, 1);
      src = memory_read8 (cpu, cpu_fetch16 (cpu));
      break;

    case 0x0d:
      src = cpu_get_indexed_operand8 (cpu, 1);
      addr = cpu_fetch16 (cpu);
      break;

    case 0x0a:
      src = cpu_get_indexed_operand8 (cpu, 1);
      addr = cpu_get_indexed_operand_addr (cpu, 1);
      break;

    default:
      sim_engine_abort (CPU_STATE (cpu), cpu, 0,
			"Invalid code 0x%0x -- internal error?", code);
      return;
    }
  memory_write8 (cpu, addr, src);
}

void
cpu_move16 (sim_cpu *cpu, uint8 code)
{
  uint16 src;
  uint16 addr;

  switch (code)
    {
    case 0x03:
      src = cpu_fetch16 (cpu);
      addr = cpu_fetch16 (cpu);
      break;

    case 0x00:
      addr = cpu_get_indexed_operand_addr (cpu, 1);
      src = cpu_fetch16 (cpu);
      break;

    case 0x04:
      addr = cpu_fetch16 (cpu);
      src = memory_read16 (cpu, addr);
      addr = cpu_fetch16 (cpu);
      break;

    case 0x01:
      addr = cpu_get_indexed_operand_addr (cpu, 1);
      src = memory_read16 (cpu, cpu_fetch16 (cpu));
      break;

    case 0x05:
      src = cpu_get_indexed_operand16 (cpu, 1);
      addr = cpu_fetch16 (cpu);
      break;

    case 0x02:
      src = cpu_get_indexed_operand16 (cpu, 1);
      addr = cpu_get_indexed_operand_addr (cpu, 1);
      break;

    default:
      sim_engine_abort (CPU_STATE (cpu), cpu, 0,
			"Invalid code 0x%0x -- internal error?", code);
      return;
    }
  memory_write16 (cpu, addr, src);
}

int
cpu_initialize (SIM_DESC sd, sim_cpu *cpu)
{
  sim_add_option_table (sd, 0, cpu_options);

  memset (&cpu->cpu_regs, 0, sizeof(cpu->cpu_regs));

  cpu->cpu_absolute_cycle = 0;
  cpu->cpu_current_cycle  = 0;
  cpu->cpu_emul_syscall   = 1;
  cpu->cpu_running        = 1;
  cpu->cpu_stop_on_interrupt = 0;
  cpu->cpu_frequency = 8 * 1000 * 1000;
  cpu->cpu_use_elf_start = 0;
  cpu->cpu_elf_start     = 0;
  cpu->cpu_use_local_config = 0;
  cpu->bank_start = 0;
  cpu->bank_end   = 0;
  cpu->bank_shift = 0;
  cpu->cpu_config        = M6811_NOSEC | M6811_NOCOP | M6811_ROMON |
    M6811_EEON;
  interrupts_initialize (sd, cpu);

  cpu->cpu_is_initialized = 1;
  return 0;
}


/* Reinitialize the processor after a reset.  */
int
cpu_reset (sim_cpu *cpu)
{
  /* Initialize the config register.
     It is only initialized at reset time.  */
  memset (cpu->ios, 0, sizeof (cpu->ios));
  if (cpu->cpu_configured_arch->arch == bfd_arch_m68hc11)
    cpu->ios[M6811_INIT] = 0x1;
  else
    cpu->ios[M6811_INIT] = 0;

  /* Output compare registers set to 0xFFFF.  */
  cpu->ios[M6811_TOC1_H] = 0xFF;
  cpu->ios[M6811_TOC1_L] = 0xFF;
  cpu->ios[M6811_TOC2_H] = 0xFF;
  cpu->ios[M6811_TOC2_L] = 0xFF;
  cpu->ios[M6811_TOC3_H] = 0xFF;
  cpu->ios[M6811_TOC4_L] = 0xFF;
  cpu->ios[M6811_TOC5_H] = 0xFF;
  cpu->ios[M6811_TOC5_L] = 0xFF;

  /* Setup the processor registers.  */
  memset (&cpu->cpu_regs, 0, sizeof(cpu->cpu_regs));
  cpu->cpu_absolute_cycle = 0;
  cpu->cpu_current_cycle  = 0;
  cpu->cpu_is_initialized = 0;

  /* Reset interrupts.  */
  interrupts_reset (&cpu->cpu_interrupts);

  /* Reinitialize the CPU operating mode.  */
  cpu->ios[M6811_HPRIO] = cpu->cpu_mode;
  return 0;
}

/* Reinitialize the processor after a reset.  */
int
cpu_restart (sim_cpu *cpu)
{
  uint16 addr;

  /* Get CPU starting address depending on the CPU mode.  */
  if (cpu->cpu_use_elf_start == 0)
    {
      switch ((cpu->ios[M6811_HPRIO]) & (M6811_SMOD | M6811_MDA))
        {
          /* Single Chip  */
        default:
        case 0 :
          addr = memory_read16 (cpu, 0xFFFE);
          break;

          /* Expanded Multiplexed  */
        case M6811_MDA:
          addr = memory_read16 (cpu, 0xFFFE);
          break;

          /* Special Bootstrap  */
        case M6811_SMOD:
          addr = 0;
          break;

          /* Factory Test  */
        case M6811_MDA | M6811_SMOD:
          addr = memory_read16 (cpu, 0xFFFE);
          break;
        }
    }
  else
    {
      addr = cpu->cpu_elf_start;
    }
  
  /* Setup the processor registers.  */
  cpu->cpu_insn_pc  = addr;
  cpu->cpu_regs.pc  = addr;
  cpu->cpu_regs.ccr = M6811_X_BIT | M6811_I_BIT | M6811_S_BIT;
  cpu->cpu_absolute_cycle = 0;
  cpu->cpu_is_initialized = 1;
  cpu->cpu_current_cycle  = 0;

  cpu_call (cpu, addr);
  
  return 0;
}

void
print_io_reg_desc (SIM_DESC sd, io_reg_desc *desc, int val, int mode)
{
  while (desc->mask)
    {
      if (val & desc->mask)
	sim_io_printf (sd, "%s",
		       mode == 0 ? desc->short_name : desc->long_name);
      desc++;
    }
}

void
print_io_byte (SIM_DESC sd, const char *name, io_reg_desc *desc,
	       uint8 val, uint16 addr)
{
  sim_io_printf (sd, "  %-9.9s @@ 0x%04x 0x%02x ", name, addr, val);
  if (desc)
    print_io_reg_desc (sd, desc, val, 0);
}

void
print_io_word (SIM_DESC sd, const char *name, io_reg_desc *desc,
	       uint16 val, uint16 addr)
{
  sim_io_printf (sd, "  %-9.9s @@ 0x%04x 0x%04x ", name, addr, val);
  if (desc)
    print_io_reg_desc (sd, desc, val, 0);
}

void
cpu_ccr_update_tst8 (sim_cpu *proc, uint8 val)
{
  cpu_set_ccr_V (proc, 0);
  cpu_set_ccr_N (proc, val & 0x80 ? 1 : 0);
  cpu_set_ccr_Z (proc, val == 0 ? 1 : 0);
}


uint16
cpu_fetch_relbranch (sim_cpu *cpu)
{
  uint16 addr = (uint16) cpu_fetch8 (cpu);

  if (addr & 0x0080)
    {
      addr |= 0xFF00;
    }
  addr += cpu->cpu_regs.pc;
  return addr;
}

uint16
cpu_fetch_relbranch16 (sim_cpu *cpu)
{
  uint16 addr = cpu_fetch16 (cpu);

  addr += cpu->cpu_regs.pc;
  return addr;
}

/* Push all the CPU registers (when an interruption occurs).  */
void
cpu_push_all (sim_cpu *cpu)
{
  if (cpu->cpu_configured_arch->arch == bfd_arch_m68hc11)
    {
      cpu_m68hc11_push_uint16 (cpu, cpu->cpu_regs.pc);
      cpu_m68hc11_push_uint16 (cpu, cpu->cpu_regs.iy);
      cpu_m68hc11_push_uint16 (cpu, cpu->cpu_regs.ix);
      cpu_m68hc11_push_uint16 (cpu, cpu->cpu_regs.d);
      cpu_m68hc11_push_uint8 (cpu, cpu->cpu_regs.ccr);
    }
  else
    {
      cpu_m68hc12_push_uint16 (cpu, cpu->cpu_regs.pc);
      cpu_m68hc12_push_uint16 (cpu, cpu->cpu_regs.iy);
      cpu_m68hc12_push_uint16 (cpu, cpu->cpu_regs.ix);
      cpu_m68hc12_push_uint16 (cpu, cpu->cpu_regs.d);
      cpu_m68hc12_push_uint8 (cpu, cpu->cpu_regs.ccr);
    }
}

/* Simulation of the dbcc/ibcc/tbcc 68HC12 conditional branch operations.  */
void
cpu_dbcc (sim_cpu* cpu)
{
  uint8 code;
  uint16 addr;
  uint16 inc;
  uint16 reg;
  
  code = cpu_fetch8 (cpu);
  switch (code & 0xc0)
    {
    case 0x80: /* ibcc */
      inc = 1;
      break;
    case 0x40: /* tbcc */
      inc = 0;
      break;
    case 0:    /* dbcc */
      inc = -1;
      break;
    default:
      abort ();
      break;
    }

  addr = cpu_fetch8 (cpu);
  if (code & 0x10)
    addr |= 0xff00;

  addr += cpu_get_pc (cpu);
  reg = cpu_get_src_reg (cpu, code & 0x07);
  reg += inc;

  /* Branch according to register value.  */
  if ((reg != 0 && (code & 0x20)) || (reg == 0 && !(code & 0x20)))
    {
      cpu_set_pc (cpu, addr);
    }
  cpu_set_dst_reg (cpu, code & 0x07, reg);
}

void
cpu_exg (sim_cpu* cpu, uint8 code)
{
  uint8 r1, r2;
  uint16 src1;
  uint16 src2;

  r1 = (code >> 4) & 0x07;
  r2 = code & 0x07;
  if (code & 0x80)
    {
      src1 = cpu_get_src_reg (cpu, r1);
      src2 = cpu_get_src_reg (cpu, r2);
      if (r2 == 1 || r2 == 2)
        src2 |= 0xff00;
      
      cpu_set_dst_reg (cpu, r2, src1);
      cpu_set_dst_reg (cpu, r1, src2);
    }
  else
    {
      src1 = cpu_get_src_reg (cpu, r1);

      /* Sign extend the 8-bit registers (A, B, CCR).  */
      if ((r1 == 0 || r1 == 1 || r1 == 2) && (src1 & 0x80))
        src1 |= 0xff00;

      cpu_set_dst_reg (cpu, r2, src1);
    }
}

/* Handle special instructions.  */
void
cpu_special (sim_cpu *cpu, enum M6811_Special special)
{
  switch (special)
    {
    case M6811_RTI:
      {
        uint8 ccr;

        ccr = cpu_m68hc11_pop_uint8 (cpu);
        cpu_set_ccr (cpu, ccr);
        cpu_set_d (cpu, cpu_m68hc11_pop_uint16 (cpu));
        cpu_set_x (cpu, cpu_m68hc11_pop_uint16 (cpu));
        cpu_set_y (cpu, cpu_m68hc11_pop_uint16 (cpu));
        cpu_set_pc (cpu, cpu_m68hc11_pop_uint16 (cpu));
	cpu_return (cpu);
        break;
      }

    case M6812_RTI:
      {
        uint8 ccr;

        ccr = cpu_m68hc12_pop_uint8 (cpu);
        cpu_set_ccr (cpu, ccr);
        cpu_set_d (cpu, cpu_m68hc12_pop_uint16 (cpu));
        cpu_set_x (cpu, cpu_m68hc12_pop_uint16 (cpu));
        cpu_set_y (cpu, cpu_m68hc12_pop_uint16 (cpu));
        cpu_set_pc (cpu, cpu_m68hc12_pop_uint16 (cpu));
	cpu_return (cpu);
        break;
      }
      
    case M6811_WAI:
      /* In the ELF-start mode, we are in a special mode where
	 the WAI corresponds to an exit.  */
      if (cpu->cpu_use_elf_start)
        {
          cpu_set_pc (cpu, cpu->cpu_insn_pc);
          sim_engine_halt (CPU_STATE (cpu), cpu,
                           NULL, NULL_CIA, sim_exited,
                           cpu_get_d (cpu));
          return;
        }
      /* SCz: not correct... */
      cpu_push_all (cpu);
      break;
      
    case M6811_SWI:
      interrupts_raise (&cpu->cpu_interrupts, M6811_INT_SWI);
      interrupts_process (&cpu->cpu_interrupts);
      break;
      
    case M6811_EMUL_SYSCALL:
    case M6811_ILLEGAL:
      if (cpu->cpu_emul_syscall)
        {
          uint8 op = memory_read8 (cpu,
                                   cpu_get_pc (cpu) - 1);
          if (op == 0x41)
            {
	      cpu_set_pc (cpu, cpu->cpu_insn_pc);
	      sim_engine_halt (CPU_STATE (cpu), cpu,
			       NULL, NULL_CIA, sim_exited,
			       cpu_get_d (cpu));
	      return;
            }
          else
            {
              emul_os (op, cpu);
            }
          return;
        }
      
      interrupts_raise (&cpu->cpu_interrupts, M6811_INT_ILLEGAL);
      interrupts_process (&cpu->cpu_interrupts);
      break;

    case M6811_TEST:
    case M6812_BGND:
      {
        SIM_DESC sd;

        sd = CPU_STATE (cpu);

        /* Breakpoint instruction if we are under gdb.  */
        if (STATE_OPEN_KIND (sd) == SIM_OPEN_DEBUG)
          {
            cpu->cpu_regs.pc --;
            sim_engine_halt (CPU_STATE (cpu), cpu,
                             0, cpu_get_pc (cpu), sim_stopped,
                             SIM_SIGTRAP);
          }
        /* else this is a nop but not in test factory mode.  */
        break;
      }

    case M6812_IDIVS:
      {
        int32 src1 = (int16) cpu_get_d (cpu);
        int32 src2 = (int16) cpu_get_x (cpu);

        if (src2 == 0)
          {
            cpu_set_ccr_C (cpu, 1);
          }
        else
          {
            cpu_set_d (cpu, src1 % src2);
            src1 = src1 / src2;
            cpu_set_x (cpu, src1);
            cpu_set_ccr_C (cpu, 0);
            cpu_set_ccr_Z (cpu, src1 == 0);
            cpu_set_ccr_N (cpu, src1 & 0x8000);
            cpu_set_ccr_V (cpu, src1 >= 32768 || src1 < -32768);
          }
      }
      break;
      
    case M6812_EDIV:
      {
        uint32 src1 = (uint32) cpu_get_x (cpu);
        uint32 src2 = (uint32) (cpu_get_y (cpu) << 16)
          | (uint32) (cpu_get_d (cpu));

        if (src1 == 0)
          {
            cpu_set_ccr_C (cpu, 1);
          }
        else
          {
            cpu_set_ccr_C (cpu, 0);
            cpu_set_d (cpu, src2 % src1);
            src2 = src2 / src1;
            cpu_set_y (cpu, src2);
            cpu_set_ccr_Z (cpu, src2 == 0);
            cpu_set_ccr_N (cpu, (src2 & 0x8000) != 0);
            cpu_set_ccr_V (cpu, (src2 & 0xffff0000) != 0);
          }
      }
      break;
      
    case M6812_EDIVS:
      {
        int32 src1 = (int16) cpu_get_x (cpu);
        int32 src2 = (uint32) (cpu_get_y (cpu) << 16)
          | (uint32) (cpu_get_d (cpu));

        if (src1 == 0)
          {
            cpu_set_ccr_C (cpu, 1);
          }
        else
          {
            cpu_set_ccr_C (cpu, 0);
            cpu_set_d (cpu, src2 % src1);
            src2 = src2 / src1;
            cpu_set_y (cpu, src2);
            cpu_set_ccr_Z (cpu, src2 == 0);
            cpu_set_ccr_N (cpu, (src2 & 0x8000) != 0);
            cpu_set_ccr_V (cpu, src2 > 32767 || src2 < -32768);
          }
      }
      break;      

    case M6812_EMULS:
      {
        int32 src1, src2;

        src1 = (int16) cpu_get_d (cpu);
        src2 = (int16) cpu_get_y (cpu);
        src1 = src1 * src2;
        cpu_set_d (cpu, src1 & 0x0ffff);
        cpu_set_y (cpu, src1 >> 16);
        cpu_set_ccr_Z (cpu, src1 == 0);
        cpu_set_ccr_N (cpu, (src1 & 0x80000000) != 0);
        cpu_set_ccr_C (cpu, (src1 & 0x00008000) != 0);
      }
      break;
      
    case M6812_EMACS:
      {
        int32 src1, src2;
        uint16 addr;
        
        addr = cpu_fetch16 (cpu);
        src1 = (int16) memory_read16 (cpu, cpu_get_x (cpu));
        src2 = (int16) memory_read16 (cpu, cpu_get_y (cpu));
        src1 = src1 * src2;
        src2 = (((uint32) memory_read16 (cpu, addr)) << 16)
          | (uint32) memory_read16 (cpu, addr + 2);

        memory_write16 (cpu, addr, (src1 + src2) >> 16);
        memory_write16 (cpu, addr + 2, (src1 + src2));

        
      }
      break;

    case M6812_CALL:
      {
        uint8 page;
        uint16 addr;

        addr = cpu_fetch16 (cpu);
        page = cpu_fetch8 (cpu);

        cpu_m68hc12_push_uint16 (cpu, cpu_get_pc (cpu));
        cpu_m68hc12_push_uint8 (cpu, cpu_get_page (cpu));

        cpu_set_page (cpu, page);
        cpu_set_pc (cpu, addr);
      }
      break;

    case M6812_CALL_INDIRECT:
      {
        uint8 code;
        uint16 addr;
        uint8 page;

        code = memory_read8 (cpu, cpu_get_pc (cpu));
        /* Indirect addressing call has the page specified in the
           memory location pointed to by the address.  */
        if ((code & 0xE3) == 0xE3)
          {
            addr = cpu_get_indexed_operand_addr (cpu, 0);
            page = memory_read8 (cpu, addr + 2);
            addr = memory_read16 (cpu, addr);
          }
        else
          {
            /* Otherwise, page is in the opcode.  */
            addr = cpu_get_indexed_operand16 (cpu, 0);
            page = cpu_fetch8 (cpu);
          }
        cpu_m68hc12_push_uint16 (cpu, cpu_get_pc (cpu));
        cpu_m68hc12_push_uint8 (cpu, cpu_get_page (cpu));
        cpu_set_page (cpu, page);
        cpu_set_pc (cpu, addr);
      }
      break;

    case M6812_RTC:
      {
        uint8 page = cpu_m68hc12_pop_uint8 (cpu);
        uint16 addr = cpu_m68hc12_pop_uint16 (cpu);

        cpu_set_page (cpu, page);
        cpu_set_pc (cpu, addr);
      }
      break;
      
    case M6812_ETBL:
    default:
      sim_engine_halt (CPU_STATE (cpu), cpu, NULL,
                       cpu_get_pc (cpu), sim_stopped,
                       SIM_SIGILL);
      break;
    }
}


void
cpu_single_step (sim_cpu *cpu)
{
  cpu->cpu_current_cycle = 0;
  cpu->cpu_insn_pc = cpu_get_pc (cpu);

  /* Handle the pending interrupts.  If an interrupt is handled,
     treat this as an single step.  */
  if (interrupts_process (&cpu->cpu_interrupts))
    {
      cpu->cpu_absolute_cycle += cpu->cpu_current_cycle;
      return;
    }
  
  /*  printf("PC = 0x%04x\n", cpu_get_pc (cpu));*/
  cpu->cpu_interpretor (cpu);
  cpu->cpu_absolute_cycle += cpu->cpu_current_cycle;
}

/* VARARGS */
void
sim_memory_error (sim_cpu *cpu, SIM_SIGNAL excep,
		  uint16 addr, const char *message, ...)
{
  char buf[1024];
  va_list args;

  va_start (args, message);
  vsprintf (buf, message, args);
  va_end (args);

  sim_io_printf (CPU_STATE (cpu), "%s\n", buf);
  cpu_memory_exception (cpu, excep, addr, buf);
}


void
cpu_memory_exception (sim_cpu *cpu, SIM_SIGNAL excep,
                      uint16 addr, const char *message)
{
  if (cpu->cpu_running == 0)
    return;

  cpu_set_pc (cpu, cpu->cpu_insn_pc);
  sim_engine_halt (CPU_STATE (cpu), cpu, NULL,
                   cpu_get_pc (cpu), sim_stopped, excep);
  
#if 0
  cpu->mem_exception = excep;
  cpu->fault_addr    = addr;
  cpu->fault_msg     = strdup (message);

  if (cpu->cpu_use_handler)
    {
      longjmp (&cpu->cpu_exception_handler, 1);
    }
  (* cpu->callback->printf_filtered)
    (cpu->callback, "Fault at 0x%04x: %s\n", addr, message);
#endif
}

void
cpu_info (SIM_DESC sd, sim_cpu *cpu)
{
  sim_io_printf (sd, "CPU info:\n");
  sim_io_printf (sd, "  Absolute cycle: %s\n",
                 cycle_to_string (cpu, cpu->cpu_absolute_cycle,
                                  PRINT_TIME | PRINT_CYCLE));
  
  sim_io_printf (sd, "  Syscall emulation: %s\n",
                 cpu->cpu_emul_syscall ? "yes, via 0xcd <n>" : "no");
  sim_io_printf (sd, "  Memory errors detection: %s\n",
                 cpu->cpu_check_memory ? "yes" : "no");
  sim_io_printf (sd, "  Stop on interrupt: %s\n",
                 cpu->cpu_stop_on_interrupt ? "yes" : "no");
}

@


1.17
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 1
   Copyright 1999-2003, 2007-2012 Free Software Foundation, Inc.
@


1.16
log
@run copyright.sh for 2011.
@
text
@d2 1
a2 2
   Copyright 1999, 2000, 2001, 2002, 2003, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.16.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 1
   Copyright 1999-2003, 2007-2012 Free Software Foundation, Inc.
@


1.15
log
@Update copyright notices to add year 2010.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2007, 2008, 2009, 2010
@


1.14
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2007, 2008, 2009
@


1.13
log
@	Updated copyright notices for most files.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2007, 2008
@


1.12
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d2 2
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2007 Free Software Foundation, Inc.
@


1.11
log
@Copyright updates for 2007.
@
text
@d7 9
a15 9
GDB, GAS, and the GNU binutils are free software; you can redistribute
them and/or modify them under the terms of the GNU General Public
License as published by the Free Software Foundation; either version
1, or (at your option) any later version.

GDB, GAS, and the GNU binutils are distributed in the hope that they
will be useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
the GNU General Public License for more details.
d18 1
a18 2
along with this file; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.10
log
@	* dv-m68hc11tim.c (cycle_to_string): Add flags parameter to better
	control the translation.
	(m68hc11tim_print_timer): Update cycle_to_string conversion.
	(m68hc11tim_timer_event): Fix handling of output
	compare register with its interrupts.
	(m68hc11tim_io_write_buffer): Check output compare
	after setting M6811_TMSK1.
	(m68hc11tim_io_read_buffer): Fix compilation warning.
	* dv-m68hc11.c (m68hc11_option_handler): Likewise.
	* dv-m68hc11spi.c (m68hc11spi_info): Likewise.
	* dv-m68hc11sio.c (m68hc11sio_info): Likewise.
	* interrupts.c (interrupts_info): Likewise.
	(interrupts_reset): Recognize bootstrap mode.
	* sim-main.h (PRINT_CYCLE, PRINT_TIME): New defines.
	(_sim_cpu): Add cpu_start_mode.
	(cycle_to_string): Add flags member.
	* m68hc11_sim.c (OPTION_CPU_BOOTSTRAP): New option.
	(cpu_options): Declare new option bootstrap.
	(cpu_option_handler): Handle it.
	(cpu_info): Update call to cycle_to_string.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
@


1.9
log
@	* sim-main.h (phys_to_virt): Use memory bank parameters to translate
	the physical address in virtual address.
	(struct _sim_cpu): Add memory bank members.
	* m68hc11_sim.c (cpu_initialize): Clear memory bank parameters.
	* interp.c (sim_hw_configure): Create memory bank according to memory
	bank parameters.
	(sim_get_bank_parameters): New function to obtain memory bank config
	from the symbol table.
	(sim_prepare_for_program): Call it to obtain the memory bank parameters.
	(sim_open): Call sim_prepare_for_program.
	* dv-m68hc11.c (m68hc11cpu_io_write_buffer): Use memory bank parameters
	to check if address is within bank window.
	(m68hc11cpu_io_read_buffer): Likewise.
	(attach_m68hc11_regs): Map the memory bank according to memory bank
	parameters.
@
text
@d30 1
d50 4
d85 5
a89 1
      
d1061 2
a1062 1
                 cycle_to_string (cpu, cpu->cpu_absolute_cycle));
@


1.8
log
@	* m68hc11_sim.c (print_io_word): New function to print 16-bit value.
	* sim-main.h (print_io_word): Declare.
	* dv-m68hc11tim.c (tmsk1_desc): New description table for TMSK1.
	(tflg1_desc): Likewise for TFLG1.
	(m68hc11tim_info): Print input and output compare registers
@
text
@d467 3
@


1.7
log
@	* m68hc11_sim.c (cpu_special): Handle call and rtc instructions.
	* sim-main.h (M6812_CALL_INDIRECT): Add to enum.
	(m6811_regs): Add page register.
	(cpu_set_page, cpu_get_page): New macros.
	(phys_to_virt): New function.
	(cpu_get_indexed_operand_addr, cpu_return): Declare.
	* gencode.c: Identify indirect addressing mode for call and fix daa.
	(gen_function_entry): New param to tell if src8/dst8 locals are
	necessary.
	(gen_interpreter): Use it to avoid generation of unused variables.
	* interp.c (sim_fetch_register): Allow to read page register; page
	register, A, B and CCR are only 1 byte wide.
	(sim_store_register): Likewise for writing.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d580 9
@


1.7.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a29 1
  OPTION_CPU_BOOTSTRAP,
a48 4
  { {"bootstrap", no_argument, NULL, OPTION_CPU_BOOTSTRAP },
      '\0', NULL, "Start the processing in bootstrap mode",
      cpu_option_handler },

d80 1
a80 5

    case OPTION_CPU_BOOTSTRAP:
       cpu->cpu_start_mode = "bootstrap";
       break;

a466 3
  cpu->bank_start = 0;
  cpu->bank_end   = 0;
  cpu->bank_shift = 0;
a584 9
print_io_word (SIM_DESC sd, const char *name, io_reg_desc *desc,
	       uint16 val, uint16 addr)
{
  sim_io_printf (sd, "  %-9.9s @@ 0x%04x 0x%04x ", name, addr, val);
  if (desc)
    print_io_reg_desc (sd, desc, val, 0);
}

void
d1040 1
a1040 2
                 cycle_to_string (cpu, cpu->cpu_absolute_cycle,
                                  PRINT_TIME | PRINT_CYCLE));
@


1.7.8.1
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a29 1
  OPTION_CPU_BOOTSTRAP,
a48 4
  { {"bootstrap", no_argument, NULL, OPTION_CPU_BOOTSTRAP },
      '\0', NULL, "Start the processing in bootstrap mode",
      cpu_option_handler },

d80 1
a80 5

    case OPTION_CPU_BOOTSTRAP:
       cpu->cpu_start_mode = "bootstrap";
       break;

a466 3
  cpu->bank_start = 0;
  cpu->bank_end   = 0;
  cpu->bank_shift = 0;
a584 9
print_io_word (SIM_DESC sd, const char *name, io_reg_desc *desc,
	       uint16 val, uint16 addr)
{
  sim_io_printf (sd, "  %-9.9s @@ 0x%04x 0x%04x ", name, addr, val);
  if (desc)
    print_io_reg_desc (sd, desc, val, 0);
}

void
d1040 1
a1040 2
                 cycle_to_string (cpu, cpu->cpu_absolute_cycle,
                                  PRINT_TIME | PRINT_CYCLE));
@


1.7.44.1
log
@	* m68hc11_sim.c (print_io_word): New function to print 16-bit value.
	* sim-main.h (print_io_word): Declare.
	* dv-m68hc11tim.c (tmsk1_desc): New description table for TMSK1.
	(tflg1_desc): Likewise for TFLG1.
	(m68hc11tim_info): Print input and output compare registers
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a579 9
  if (desc)
    print_io_reg_desc (sd, desc, val, 0);
}

void
print_io_word (SIM_DESC sd, const char *name, io_reg_desc *desc,
	       uint16 val, uint16 addr)
{
  sim_io_printf (sd, "  %-9.9s @@ 0x%04x 0x%04x ", name, addr, val);
@


1.7.44.2
log
@	* sim-main.h (phys_to_virt): Use memory bank parameters to translate
	the physical address in virtual address.
	(struct _sim_cpu): Add memory bank members.
	* m68hc11_sim.c (cpu_initialize): Clear memory bank parameters.
	* interp.c (sim_hw_configure): Create memory bank according to memory
	bank parameters.
	(sim_get_bank_parameters): New function to obtain memory bank config
	from the symbol table.
	(sim_prepare_for_program): Call it to obtain the memory bank parameters.
	(sim_open): Call sim_prepare_for_program.
	* dv-m68hc11.c (m68hc11cpu_io_write_buffer): Use memory bank parameters
	to check if address is within bank window.
	(m68hc11cpu_io_read_buffer): Likewise.
	(attach_m68hc11_regs): Map the memory bank according to memory bank
	parameters.
@
text
@a466 3
  cpu->bank_start = 0;
  cpu->bank_end   = 0;
  cpu->bank_shift = 0;
@


1.7.44.3
log
@	* dv-m68hc11tim.c (cycle_to_string): Add flags parameter to better
	control the translation.
	(m68hc11tim_print_timer): Update cycle_to_string conversion.
	(m68hc11tim_timer_event): Fix handling of output
	compare register with its interrupts.
	(m68hc11tim_io_write_buffer): Check output compare
	after setting M6811_TMSK1.
	(m68hc11tim_io_read_buffer): Fix compilation warning.
	* dv-m68hc11.c (m68hc11_option_handler): Likewise.
	* dv-m68hc11spi.c (m68hc11spi_info): Likewise.
	* dv-m68hc11sio.c (m68hc11sio_info): Likewise.
	* interrupts.c (interrupts_info): Likewise.
	(interrupts_reset): Recognize bootstrap mode.
	* sim-main.h (PRINT_CYCLE, PRINT_TIME): New defines.
	(_sim_cpu): Add cpu_start_mode.
	(cycle_to_string): Add flags member.
	* m68hc11_sim.c (OPTION_CPU_BOOTSTRAP): New option.
	(cpu_options): Declare new option bootstrap.
	(cpu_option_handler): Handle it.
	(cpu_info): Update call to cycle_to_string.
@
text
@a29 1
  OPTION_CPU_BOOTSTRAP,
a48 4
  { {"bootstrap", no_argument, NULL, OPTION_CPU_BOOTSTRAP },
      '\0', NULL, "Start the processing in bootstrap mode",
      cpu_option_handler },

d80 1
a80 5

    case OPTION_CPU_BOOTSTRAP:
       cpu->cpu_start_mode = "bootstrap";
       break;

d1052 1
a1052 2
                 cycle_to_string (cpu, cpu->cpu_absolute_cycle,
                                  PRINT_TIME | PRINT_CYCLE));
@


1.6
log
@	* m68hc11_sim.c (cpu_move8): Call sim_engine_abort in default case.
	(cpu_move16): Likewise.
	(sim_memory_error): Use sim_io_printf.
	(cpu_option_handler): Fix compilation warning.
	* interp.c (sim_hw_configure): Fix compilation warning;
	remove m68hc12sio@@2 device.
	(sim_open): Likewise.
	* dv-m68hc11tim.c (m68hc11tim_port_event): Fix clear of TFLG2
	flags when reset.
	(cycle_to_string): Improve convertion of cpu cycle number.
	(m68hc11tim_info): Print info about PACNT.
	(m68hc11tim_io_write_buffer): Fix clearing of TFLG2; handle
	TCTL1 and TCTL2 registers.
	* dv-m68hc11.c (m68hc11_info): Print 6811 current running mode.
@
text
@d3 1
a3 1
   Written by Stephane Carrez (stcarrez@@worldnet.fr)
d910 54
@


1.6.6.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d3 1
a3 1
   Written by Stephane Carrez (stcarrez@@nerim.fr)
a909 54
    case M6812_CALL:
      {
        uint8 page;
        uint16 addr;

        addr = cpu_fetch16 (cpu);
        page = cpu_fetch8 (cpu);

        cpu_m68hc12_push_uint16 (cpu, cpu_get_pc (cpu));
        cpu_m68hc12_push_uint8 (cpu, cpu_get_page (cpu));

        cpu_set_page (cpu, page);
        cpu_set_pc (cpu, addr);
      }
      break;

    case M6812_CALL_INDIRECT:
      {
        uint8 code;
        uint16 addr;
        uint8 page;

        code = memory_read8 (cpu, cpu_get_pc (cpu));
        /* Indirect addressing call has the page specified in the
           memory location pointed to by the address.  */
        if ((code & 0xE3) == 0xE3)
          {
            addr = cpu_get_indexed_operand_addr (cpu, 0);
            page = memory_read8 (cpu, addr + 2);
            addr = memory_read16 (cpu, addr);
          }
        else
          {
            /* Otherwise, page is in the opcode.  */
            addr = cpu_get_indexed_operand16 (cpu, 0);
            page = cpu_fetch8 (cpu);
          }
        cpu_m68hc12_push_uint16 (cpu, cpu_get_pc (cpu));
        cpu_m68hc12_push_uint8 (cpu, cpu_get_page (cpu));
        cpu_set_page (cpu, page);
        cpu_set_pc (cpu, addr);
      }
      break;

    case M6812_RTC:
      {
        uint8 page = cpu_m68hc12_pop_uint8 (cpu);
        uint16 addr = cpu_m68hc12_pop_uint16 (cpu);

        cpu_set_page (cpu, page);
        cpu_set_pc (cpu, addr);
      }
      break;
      
@


1.5
log
@	* sim-main.h (cpu_frame, cpu_frame_list): Remove.
	(cpu_frame_reg, cpu_print_frame): Remove.
	(cpu_m68hc11_push_uint8, cpu_m68hc11_pop_uint8): Cleanup.
	(cpu_m68hc11_push_uint16, cpu_m68hc11_pop_uint16): Likewise.
	(cpu_m68hc12_push_uint8, cpu_m68hc12_push_uint16): Likewise.
	(cpu_m68hc12_pop_uint8, cpu_m68hc12_pop_uint16): Likewise.
	* m68hc11_sim.c (cpu_find_frame): Remove.
	(cpu_create_frame_list): Remove.
	(cpu_remove_frame_list, cpu_create_frame, cpu_free_frame): Remove.
	(cpu_frame_reg, cpu_print_frame, cpu_update_frame): Remove.
	(cpu_call): Cleanup to remove #if HAVE_FRAME and calls to the above.
	(cpu_update_frame): Likewise.
	(cpu_return): Likewise.
	(cpu_reset): Likewise.
	(cpu_initialize): Likewise.
	* interp.c (sim_do_command): Remove call to cpu_print_frame.
@
text
@a56 1
  sim_cpu *cpu;
d395 5
a399 1
      
d442 5
a446 1
      
d951 1
a951 1
  printf("%s\n", buf);
@


1.4
log
@	* interrupts.c (interrupts_reset): New function, setup interrupt
	vector address according to cpu mode.
	(interrupts_initialize): Move reset portion to the above.
	(interrupt_names): New table to give a name to interrupts.
	(idefs): Handle pulse accumulator interrupts.
	(interrupts_info): Print the interrupt history.
	(interrupt_option_handler): New function.
	(interrupt_options): New table of options.
	(interrupts_update_pending): Keep track of when interrupts are
	raised and implement breakpoint-on-raise-interrupt.
	(interrupts_process): Keep track of when interrupts are taken
	and implement breakpoint-on-interrupt.
	* interrupts.h (struct interrupt_history): Define.
	(struct interrupt): Keep track of the interrupt history.
	(interrupts_reset): Declare.
	(interrupts_initialize): Update prototype.
	* m68hc11_sim.c (cpu_reset): Reset interrupts.
	(cpu_initialize): Cleanup.
@
text
@a25 2
void cpu_free_frame (sim_cpu* cpu, struct cpu_frame *frame);

a88 65
/* Tentative to keep track of the cpu frame.  */
struct cpu_frame*
cpu_find_frame (sim_cpu *cpu, uint16 sp)
{
  struct cpu_frame_list *flist;

  flist = cpu->cpu_frames;
  while (flist)
    {
      struct cpu_frame *frame;

      frame = flist->frame;
      while (frame)
	{
	  if (frame->sp_low <= sp && frame->sp_high >= sp)
	    {
	      cpu->cpu_current_frame = flist;
	      return frame;
	    }

	  frame = frame->up;
	}
      flist = flist->next;
    }
  return 0;
}

struct cpu_frame_list*
cpu_create_frame_list (sim_cpu *cpu)
{
  struct cpu_frame_list *flist;

  flist = (struct cpu_frame_list*) malloc (sizeof (struct cpu_frame_list));
  flist->frame = 0;
  flist->next  = cpu->cpu_frames;
  flist->prev  = 0;
  if (flist->next)
    flist->next->prev = flist;
  cpu->cpu_frames = flist;
  cpu->cpu_current_frame = flist;
  return flist;
}

void
cpu_remove_frame_list (sim_cpu *cpu, struct cpu_frame_list *flist)
{
  struct cpu_frame *frame;
  
  if (flist->prev == 0)
    cpu->cpu_frames = flist->next;
  else
    flist->prev->next = flist->next;
  if (flist->next)
    flist->next->prev = flist->prev;

  frame = flist->frame;
  while (frame)
    {
      struct cpu_frame* up = frame->up;
      cpu_free_frame (cpu, frame);
      frame = up;
    }
  free (flist);
}
  
a89 38
struct cpu_frame*
cpu_create_frame (sim_cpu *cpu, uint16 pc, uint16 sp)
{
  struct cpu_frame *frame;

  frame = (struct cpu_frame*) malloc (sizeof(struct cpu_frame));
  frame->up = 0;
  frame->pc = pc;
  frame->sp_low  = sp;
  frame->sp_high = sp;
  return frame;
}

void
cpu_free_frame (sim_cpu *cpu, struct cpu_frame *frame)
{
  free (frame);
}

uint16
cpu_frame_reg (sim_cpu *cpu, uint16 rn)
{
  struct cpu_frame *frame;

  if (cpu->cpu_current_frame == 0)
    return 0;
  
  frame = cpu->cpu_current_frame->frame;
  while (frame)
    {
      if (rn == 0)
	return frame->sp_high;
      frame = frame->up;
      rn--;
    }
  return 0;
}
  
a92 7
#if HAVE_FRAME
  uint16 pc = cpu->cpu_insn_pc;
  uint16 sp;
  struct cpu_frame_list *flist;
  struct cpu_frame* frame;
  struct cpu_frame* new_frame;
#endif
a94 45
#if HAVE_FRAME
  sp = cpu_get_sp (cpu);

  cpu->cpu_need_update_frame = 0;
  flist = cpu->cpu_current_frame;
  if (flist == 0)
    flist = cpu_create_frame_list (cpu);

  frame = flist->frame;
  if (frame && frame->sp_low > sp)
    frame->sp_low = sp;

  new_frame = cpu_create_frame (cpu, pc, sp);
  new_frame->up = frame;
  flist->frame = new_frame;
#endif
}

void
cpu_update_frame (sim_cpu *cpu, int do_create)
{
#if HAVE_FRAME
  struct cpu_frame *frame;

  frame = cpu_find_frame (cpu, cpu_get_sp (cpu));
  if (frame)
    {
      while (frame != cpu->cpu_current_frame->frame)
	{
	  struct cpu_frame* up;
	  
	  up = cpu->cpu_current_frame->frame->up;
	  cpu_free_frame (cpu, cpu->cpu_current_frame->frame);
	  cpu->cpu_current_frame->frame = up;
	}
      return;
    }

  if (do_create)
    {
      cpu_create_frame_list (cpu);
      frame = cpu_create_frame (cpu, cpu_get_pc (cpu), cpu_get_sp (cpu));
      cpu->cpu_current_frame->frame = frame;
    }
#endif
a99 41
#if HAVE_FRAME
  uint16 sp = cpu_get_sp (cpu);
  struct cpu_frame *frame;
  struct cpu_frame_list *flist;

  cpu->cpu_need_update_frame = 0;
  flist = cpu->cpu_current_frame;
  if (flist && flist->frame && flist->frame->up)
    {
      frame = flist->frame->up;
      if (frame->sp_low <= sp && frame->sp_high >= sp)
	{
	  cpu_free_frame (cpu, flist->frame);
	  flist->frame = frame;
	  return;
	}
    }
  cpu_update_frame (cpu, 1);
#endif
}

void
cpu_print_frame (SIM_DESC sd, sim_cpu *cpu)
{
  struct cpu_frame* frame;
  int level = 0;
  
  if (cpu->cpu_current_frame == 0 || cpu->cpu_current_frame->frame == 0)
    {
      sim_io_printf (sd, "No frame.\n");
      return;
    }
  sim_io_printf (sd, " #   PC   SP-L  SP-H\n");
  frame = cpu->cpu_current_frame->frame;
  while (frame)
    {
      sim_io_printf (sd, "%3d 0x%04x 0x%04x 0x%04x\n",
		     level, frame->pc, frame->sp_low, frame->sp_high);
      frame = frame->up;
      level++;
    }
a106 1
  cpu_update_frame (cpu, 0);
a456 2
  cpu->cpu_frames = 0;
  cpu->cpu_current_frame = 0;
a472 5
  cpu->cpu_need_update_frame = 0;
  cpu->cpu_current_frame = 0;
  while (cpu->cpu_frames)
    cpu_remove_frame_list (cpu, cpu->cpu_frames);

@


1.3
log
@Improve HC11 simulator to support HC12
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
a645 2
  int result;
  
d663 1
a663 1
  result = interrupts_initialize (cpu);
d666 1
a666 1
  return result;
d702 3
@


1.3.8.1
log
@	* interrupts.c (interrupts_reset): New function, setup interrupt
	vector address according to cpu mode.
	(interrupts_initialize): Move reset portion to the above.
	(interrupt_names): New table to give a name to interrupts.
	(idefs): Handle pulse accumulator interrupts.
	(interrupts_info): Print the interrupt history.
	(interrupt_option_handler): New function.
	(interrupt_options): New table of options.
	(interrupts_update_pending): Keep track of when interrupts are
	raised and implement breakpoint-on-raise-interrupt.
	(interrupts_process): Keep track of when interrupts are taken
	and implement breakpoint-on-interrupt.
	* interrupts.h (struct interrupt_history): Define.
	(struct interrupt): Keep track of the interrupt history.
	(interrupts_reset): Declare.
	(interrupts_initialize): Update prototype.
	* m68hc11_sim.c (cpu_reset): Reset interrupts.
	(cpu_initialize): Cleanup.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d646 2
d665 1
a665 1
  interrupts_initialize (sd, cpu);
d668 1
a668 1
  return 0;
a703 3

  /* Reset interrupts.  */
  interrupts_reset (&cpu->cpu_interrupts);
@


1.3.8.2
log
@	* sim-main.h (cpu_frame, cpu_frame_list): Remove.
	(cpu_frame_reg, cpu_print_frame): Remove.
	(cpu_m68hc11_push_uint8, cpu_m68hc11_pop_uint8): Cleanup.
	(cpu_m68hc11_push_uint16, cpu_m68hc11_pop_uint16): Likewise.
	(cpu_m68hc12_push_uint8, cpu_m68hc12_push_uint16): Likewise.
	(cpu_m68hc12_pop_uint8, cpu_m68hc12_pop_uint16): Likewise.
	* m68hc11_sim.c (cpu_find_frame): Remove.
	(cpu_create_frame_list): Remove.
	(cpu_remove_frame_list, cpu_create_frame, cpu_free_frame): Remove.
	(cpu_frame_reg, cpu_print_frame, cpu_update_frame): Remove.
	(cpu_call): Cleanup to remove #if HAVE_FRAME and calls to the above.
	(cpu_update_frame): Likewise.
	(cpu_return): Likewise.
	(cpu_reset): Likewise.
	(cpu_initialize): Likewise.
	* interp.c (sim_do_command): Remove call to cpu_print_frame.
@
text
@d26 2
d91 65
d157 38
d198 7
d207 45
d257 41
d305 1
d656 2
d674 5
@


1.3.8.3
log
@	* m68hc11_sim.c (cpu_move8): Call sim_engine_abort in default case.
	(cpu_move16): Likewise.
	(sim_memory_error): Use sim_io_printf.
	(cpu_option_handler): Fix compilation warning.
	* interp.c (sim_hw_configure): Fix compilation warning;
	remove m68hc12sio@@2 device.
	(sim_open): Likewise.
	* dv-m68hc11tim.c (m68hc11tim_port_event): Fix clear of TFLG2
	flags when reset.
	(cycle_to_string): Improve convertion of cpu cycle number.
	(m68hc11tim_info): Print info about PACNT.
	(m68hc11tim_io_write_buffer): Fix clearing of TFLG2; handle
	TCTL1 and TCTL2 registers.
	* dv-m68hc11.c (m68hc11_info): Print 6811 current running mode.
@
text
@d57 1
d396 1
a396 5

    default:
      sim_engine_abort (CPU_STATE (cpu), cpu, 0,
			"Invalid code 0x%0x -- internal error?", code);
      return;
d439 1
a439 5

    default:
      sim_engine_abort (CPU_STATE (cpu), cpu, 0,
			"Invalid code 0x%0x -- internal error?", code);
      return;
d944 1
a944 1
  sim_io_printf (CPU_STATE (cpu), "%s\n", buf);
@


1.2
log
@	* sim-main.h: Define cycle_to_string.
	* dv-m68hc11tim.c (cycle_to_string): New function to translate
	the cpu cycle into some formatted time string.
	(m68hc11tim_print_timer): Use it.
	* dv-m68hc11sio.c (m68hc11sio_info): Use cycle_to_string.
	* dv-m68hc11spi.c (m68hc11spi_info): Likewise.
	* interrupts.c (interrupts_info): Likewise.
	* m68hc11_sim.c (cpu_info): Likewise.
@
text
@d1 2
a2 2
/* m6811_cpu.c -- 68HC11 CPU Emulation
   Copyright 1999, 2000 Free Software Foundation, Inc.
d308 335
d684 4
a687 1
  cpu->ios[M6811_INIT] = 0x1;
d804 8
d817 58
a874 5
  cpu_push_uint16 (cpu, cpu->cpu_regs.pc);
  cpu_push_uint16 (cpu, cpu->cpu_regs.iy);
  cpu_push_uint16 (cpu, cpu->cpu_regs.ix);
  cpu_push_uint16 (cpu, cpu->cpu_regs.d);
  cpu_push_uint8 (cpu, cpu->cpu_regs.ccr);
d877 30
d918 15
a932 1
        ccr = cpu_pop_uint8 (cpu);
d934 4
a937 4
        cpu_set_d (cpu, cpu_pop_uint16 (cpu));
        cpu_set_x (cpu, cpu_pop_uint16 (cpu));
        cpu_set_y (cpu, cpu_pop_uint16 (cpu));
        cpu_set_pc (cpu, cpu_pop_uint16 (cpu));
d988 1
d1005 109
d1133 1
a1133 1
  cpu_interp (cpu);
@


1.1
log
@New simulator.
@
text
@d630 3
a632 2
  sim_io_printf (sd, "  Absolute cycle: %llu\n",
                 cpu->cpu_absolute_cycle);
@

