head	1.17;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.17
	gdb_7_6-2013-04-26-release:1.17
	gdb_7_6-branch:1.17.0.2
	gdb_7_6-2013-03-12-branchpoint:1.17
	gdb_7_5_1-2012-11-29-release:1.16
	gdb_7_5-2012-08-17-release:1.16
	gdb_7_5-branch:1.16.0.2
	gdb_7_5-2012-07-18-branchpoint:1.16
	gdb_7_4_1-2012-04-26-release:1.15.4.1
	gdb_7_4-2012-01-24-release:1.15.4.1
	gdb_7_4-branch:1.15.0.4
	gdb_7_4-2011-12-13-branchpoint:1.15
	gdb_7_3_1-2011-09-04-release:1.15
	gdb_7_3-2011-07-26-release:1.15
	gdb_7_3-branch:1.15.0.2
	gdb_7_3-2011-04-01-branchpoint:1.15
	gdb_7_2-2010-09-02-release:1.14
	gdb_7_2-branch:1.14.0.4
	gdb_7_2-2010-07-07-branchpoint:1.14
	gdb_7_1-2010-03-18-release:1.14
	gdb_7_1-branch:1.14.0.2
	gdb_7_1-2010-02-18-branchpoint:1.14
	gdb_7_0_1-2009-12-22-release:1.13
	gdb_7_0-2009-10-06-release:1.13
	gdb_7_0-branch:1.13.0.4
	gdb_7_0-2009-09-16-branchpoint:1.13
	arc-sim-20090309:1.12
	msnyder-checkpoint-072509-branch:1.13.0.2
	msnyder-checkpoint-072509-branchpoint:1.13
	arc-insight_6_8-branch:1.12.0.16
	arc-insight_6_8-branchpoint:1.12
	insight_6_8-branch:1.12.0.14
	insight_6_8-branchpoint:1.12
	reverse-20081226-branch:1.12.0.12
	reverse-20081226-branchpoint:1.12
	multiprocess-20081120-branch:1.12.0.10
	multiprocess-20081120-branchpoint:1.12
	reverse-20080930-branch:1.12.0.8
	reverse-20080930-branchpoint:1.12
	reverse-20080717-branch:1.12.0.6
	reverse-20080717-branchpoint:1.12
	msnyder-reverse-20080609-branch:1.12.0.4
	msnyder-reverse-20080609-branchpoint:1.12
	drow-reverse-20070409-branch:1.10.0.2
	drow-reverse-20070409-branchpoint:1.10
	gdb_6_8-2008-03-27-release:1.12
	gdb_6_8-branch:1.12.0.2
	gdb_6_8-2008-02-26-branchpoint:1.12
	gdb_6_7_1-2007-10-29-release:1.11
	gdb_6_7-2007-10-10-release:1.11
	gdb_6_7-branch:1.11.0.2
	gdb_6_7-2007-09-07-branchpoint:1.11
	insight_6_6-20070208-release:1.9
	gdb_6_6-2006-12-18-release:1.9
	gdb_6_6-branch:1.9.0.54
	gdb_6_6-2006-11-15-branchpoint:1.9
	insight_6_5-20061003-release:1.9
	gdb-csl-symbian-6_4_50_20060226-12:1.9
	gdb-csl-sourcerygxx-3_4_4-25:1.9
	nickrob-async-20060828-mergepoint:1.9
	gdb-csl-symbian-6_4_50_20060226-11:1.9
	gdb-csl-sourcerygxx-4_1-17:1.9
	gdb-csl-20060226-branch-local-2:1.9
	gdb-csl-sourcerygxx-4_1-14:1.9
	gdb-csl-sourcerygxx-4_1-13:1.9
	gdb-csl-sourcerygxx-4_1-12:1.9
	gdb-csl-sourcerygxx-3_4_4-21:1.9
	gdb_6_5-20060621-release:1.9
	gdb-csl-sourcerygxx-4_1-9:1.9
	gdb-csl-sourcerygxx-4_1-8:1.9
	gdb-csl-sourcerygxx-4_1-7:1.9
	gdb-csl-arm-2006q1-6:1.9
	gdb-csl-sourcerygxx-4_1-6:1.9
	gdb-csl-symbian-6_4_50_20060226-10:1.9
	gdb-csl-symbian-6_4_50_20060226-9:1.9
	gdb-csl-symbian-6_4_50_20060226-8:1.9
	gdb-csl-coldfire-4_1-11:1.9
	gdb-csl-sourcerygxx-3_4_4-19:1.9
	gdb-csl-coldfire-4_1-10:1.9
	gdb_6_5-branch:1.9.0.52
	gdb_6_5-2006-05-14-branchpoint:1.9
	gdb-csl-sourcerygxx-4_1-5:1.9
	nickrob-async-20060513-branch:1.9.0.50
	nickrob-async-20060513-branchpoint:1.9
	gdb-csl-sourcerygxx-4_1-4:1.9
	msnyder-reverse-20060502-branch:1.9.0.48
	msnyder-reverse-20060502-branchpoint:1.9
	gdb-csl-morpho-4_1-4:1.9
	gdb-csl-sourcerygxx-3_4_4-17:1.9
	readline_5_1-import-branch:1.9.0.46
	readline_5_1-import-branchpoint:1.9
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.9
	gdb-csl-symbian-20060226-branch:1.9.0.44
	gdb-csl-symbian-20060226-branchpoint:1.9
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.9
	msnyder-reverse-20060331-branch:1.9.0.42
	msnyder-reverse-20060331-branchpoint:1.9
	gdb-csl-available-20060303-branch:1.9.0.40
	gdb-csl-available-20060303-branchpoint:1.9
	gdb-csl-20060226-branch:1.9.0.38
	gdb-csl-20060226-branchpoint:1.9
	gdb_6_4-20051202-release:1.9
	msnyder-fork-checkpoint-branch:1.9.0.36
	msnyder-fork-checkpoint-branchpoint:1.9
	gdb-csl-gxxpro-6_3-branch:1.9.0.34
	gdb-csl-gxxpro-6_3-branchpoint:1.9
	gdb_6_4-branch:1.9.0.32
	gdb_6_4-2005-11-01-branchpoint:1.9
	gdb-csl-arm-20051020-branch:1.9.0.30
	gdb-csl-arm-20051020-branchpoint:1.9
	msnyder-tracepoint-checkpoint-branch:1.9.0.28
	msnyder-tracepoint-checkpoint-branchpoint:1.9
	gdb-csl-arm-20050325-2005-q1b:1.9
	gdb-csl-arm-20050325-2005-q1a:1.9
	csl-arm-20050325-branch:1.9.0.26
	csl-arm-20050325-branchpoint:1.9
	gdb_6_3-20041109-release:1.9
	gdb_6_3-branch:1.9.0.22
	gdb_6_3-20041019-branchpoint:1.9
	drow_intercu-merge-20040921:1.9
	drow_intercu-merge-20040915:1.9
	jimb-gdb_6_2-e500-branch:1.9.0.24
	jimb-gdb_6_2-e500-branchpoint:1.9
	gdb_6_2-20040730-release:1.9
	gdb_6_2-branch:1.9.0.20
	gdb_6_2-2004-07-10-gmt-branchpoint:1.9
	gdb_6_1_1-20040616-release:1.9
	gdb_6_1-2004-04-05-release:1.9
	drow_intercu-merge-20040402:1.9
	drow_intercu-merge-20040327:1.9
	ezannoni_pie-20040323-branch:1.9.0.18
	ezannoni_pie-20040323-branchpoint:1.9
	cagney_tramp-20040321-mergepoint:1.9
	cagney_tramp-20040309-branch:1.9.0.16
	cagney_tramp-20040309-branchpoint:1.9
	gdb_6_1-branch:1.9.0.14
	gdb_6_1-2004-03-01-gmt-branchpoint:1.9
	drow_intercu-20040221-branch:1.9.0.12
	drow_intercu-20040221-branchpoint:1.9
	cagney_bfdfile-20040213-branch:1.9.0.10
	cagney_bfdfile-20040213-branchpoint:1.9
	drow-cplus-merge-20040208:1.9
	carlton_dictionary-20040126-merge:1.9
	cagney_bigcore-20040122-branch:1.9.0.8
	cagney_bigcore-20040122-branchpoint:1.9
	drow-cplus-merge-20040113:1.9
	drow-cplus-merge-20031224:1.9
	drow-cplus-merge-20031220:1.9
	carlton_dictionary-20031215-merge:1.9
	drow-cplus-merge-20031214:1.9
	carlton-dictionary-20031111-merge:1.9
	gdb_6_0-2003-10-04-release:1.7.50.2
	kettenis_sparc-20030918-branch:1.9.0.6
	kettenis_sparc-20030918-branchpoint:1.9
	carlton_dictionary-20030917-merge:1.9
	ezannoni_pie-20030916-branchpoint:1.9
	ezannoni_pie-20030916-branch:1.9.0.4
	cagney_x86i386-20030821-branch:1.9.0.2
	cagney_x86i386-20030821-branchpoint:1.9
	carlton_dictionary-20030805-merge:1.7
	carlton_dictionary-20030627-merge:1.7
	gdb_6_0-branch:1.7.0.50
	gdb_6_0-2003-06-23-branchpoint:1.7
	jimb-ppc64-linux-20030613-branch:1.7.0.48
	jimb-ppc64-linux-20030613-branchpoint:1.7
	cagney_convert-20030606-branch:1.7.0.46
	cagney_convert-20030606-branchpoint:1.7
	cagney_writestrings-20030508-branch:1.7.0.44
	cagney_writestrings-20030508-branchpoint:1.7
	jimb-ppc64-linux-20030528-branch:1.7.0.42
	jimb-ppc64-linux-20030528-branchpoint:1.7
	carlton_dictionary-20030523-merge:1.7
	cagney_fileio-20030521-branch:1.7.0.40
	cagney_fileio-20030521-branchpoint:1.7
	kettenis_i386newframe-20030517-mergepoint:1.7
	jimb-ppc64-linux-20030509-branch:1.7.0.38
	jimb-ppc64-linux-20030509-branchpoint:1.7
	kettenis_i386newframe-20030504-mergepoint:1.7
	carlton_dictionary-20030430-merge:1.7
	kettenis_i386newframe-20030419-branch:1.7.0.36
	kettenis_i386newframe-20030419-branchpoint:1.7
	carlton_dictionary-20030416-merge:1.7
	cagney_frameaddr-20030409-mergepoint:1.7
	kettenis_i386newframe-20030406-branch:1.7.0.34
	kettenis_i386newframe-20030406-branchpoint:1.7
	cagney_frameaddr-20030403-branchpoint:1.7
	cagney_frameaddr-20030403-branch:1.7.0.32
	cagney_framebase-20030330-mergepoint:1.7
	cagney_framebase-20030326-branch:1.7.0.30
	cagney_framebase-20030326-branchpoint:1.7
	cagney_lazyid-20030317-branch:1.7.0.28
	cagney_lazyid-20030317-branchpoint:1.7
	kettenis-i386newframe-20030316-mergepoint:1.7
	offbyone-20030313-branch:1.7.0.26
	offbyone-20030313-branchpoint:1.7
	kettenis-i386newframe-20030308-branch:1.7.0.24
	kettenis-i386newframe-20030308-branchpoint:1.7
	carlton_dictionary-20030305-merge:1.7
	cagney_offbyone-20030303-branch:1.7.0.22
	cagney_offbyone-20030303-branchpoint:1.7
	carlton_dictionary-20030207-merge:1.7
	interps-20030202-branch:1.7.0.20
	interps-20030202-branchpoint:1.7
	cagney-unwind-20030108-branch:1.7.0.18
	cagney-unwind-20030108-branchpoint:1.7
	carlton_dictionary-20021223-merge:1.7
	gdb_5_3-2002-12-12-release:1.7
	carlton_dictionary-20021115-merge:1.7
	kseitz_interps-20021105-merge:1.7
	kseitz_interps-20021103-merge:1.7
	drow-cplus-merge-20021020:1.7
	drow-cplus-merge-20021025:1.7
	carlton_dictionary-20021025-merge:1.7
	carlton_dictionary-20021011-merge:1.7
	drow-cplus-branch:1.7.0.16
	drow-cplus-branchpoint:1.7
	kseitz_interps-20020930-merge:1.7
	carlton_dictionary-20020927-merge:1.7
	carlton_dictionary-branch:1.7.0.14
	carlton_dictionary-20020920-branchpoint:1.7
	gdb_5_3-branch:1.7.0.12
	gdb_5_3-2002-09-04-branchpoint:1.7
	kseitz_interps-20020829-merge:1.7
	cagney_sysregs-20020825-branch:1.7.0.10
	cagney_sysregs-20020825-branchpoint:1.7
	readline_4_3-import-branch:1.7.0.8
	readline_4_3-import-branchpoint:1.7
	gdb_5_2_1-2002-07-23-release:1.5.8.2
	kseitz_interps-20020528-branch:1.7.0.6
	kseitz_interps-20020528-branchpoint:1.7
	cagney_regbuf-20020515-branch:1.7.0.4
	cagney_regbuf-20020515-branchpoint:1.7
	jimb-macro-020506-branch:1.7.0.2
	jimb-macro-020506-branchpoint:1.7
	gdb_5_2-2002-04-29-release:1.5.8.2
	gdb_5_2-branch:1.5.0.8
	gdb_5_2-2002-03-03-branchpoint:1.5
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.4
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.2
	gdb_5_1-2001-07-29-branchpoint:1.5
	insight-precleanup-2001-01-01:1.5;
locks; strict;
comment	@ * @;


1.17
date	2013.01.01.06.41.38;	author brobecke;	state Exp;
branches;
next	1.16;

1.16
date	2012.01.04.08.28.13;	author brobecke;	state Exp;
branches;
next	1.15;

1.15
date	2011.01.01.15.34.02;	author brobecke;	state Exp;
branches
	1.15.4.1;
next	1.14;

1.14
date	2010.01.01.10.03.31;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.14.10.53.08;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2008.01.01.22.53.25;	author drow;	state Exp;
branches;
next	1.11;

1.11
date	2007.08.24.14.28.37;	author brobecke;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.09.17.59.18;	author drow;	state Exp;
branches;
next	1.9;

1.9
date	2003.08.08.21.02.24;	author ciceron;	state Exp;
branches;
next	1.8;

1.8
date	2003.08.08.20.25.50;	author ciceron;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.07.19.17.04;	author ciceron;	state Exp;
branches
	1.7.14.1
	1.7.16.1
	1.7.50.1;
next	1.6;

1.6
date	2002.03.07.19.12.44;	author ciceron;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.26.21.41.31;	author ciceron;	state Exp;
branches
	1.5.8.1;
next	1.4;

1.4
date	2000.09.09.21.00.39;	author ciceron;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.06.19.33.12;	author ciceron;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.11.18.44.59;	author ciceron;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.27.11.23.39;	author cagney;	state Exp;
branches;
next	;

1.15.4.1
date	2012.01.06.04.54.53;	author brobecke;	state Exp;
branches;
next	;

1.7.14.1
date	2003.09.17.21.29.03;	author carlton;	state Exp;
branches;
next	;

1.7.16.1
date	2003.12.14.20.28.27;	author drow;	state Exp;
branches;
next	;

1.7.50.1
date	2003.08.08.20.26.28;	author ciceron;	state Exp;
branches;
next	1.7.50.2;

1.7.50.2
date	2003.08.08.21.04.44;	author ciceron;	state Exp;
branches;
next	;

1.5.8.1
date	2002.03.07.19.14.07;	author ciceron;	state Exp;
branches;
next	1.5.8.2;

1.5.8.2
date	2002.03.07.19.18.40;	author ciceron;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/*  dv-m68hc11tim.c -- Simulation of the 68HC11 timer devices.
    Copyright (C) 1999-2013 Free Software Foundation, Inc.
    Written by Stephane Carrez (stcarrez@@nerim.fr)
    (From a driver model Contributed by Cygnus Solutions.)

    This file is part of the program GDB, the GNU debugger.
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    
    */


#include "sim-main.h"
#include "hw-main.h"
#include "sim-assert.h"
#include <limits.h>

/* DEVICE

        m68hc11tim - m68hc11 timer devices

   
   DESCRIPTION
   
        Implements the m68hc11 timer as described in Chapter 10
        of the pink book.

   
   PROPERTIES

        none

   
   PORTS

   reset (input)

        Reset the timer device.  This port must be connected to
        the cpu-reset output port.

   capture (input)

        Input capture.  This port must be connected to the input
        captures.  It latches the current TCNT free running counter
        into one of the three input capture registers.

   */



/* port ID's */

enum
{
  RESET_PORT,
  CAPTURE
};


static const struct hw_port_descriptor m68hc11tim_ports[] = 
{
  { "reset",   RESET_PORT, 0, input_port, },
  { "capture", CAPTURE,    0, input_port, },
  { NULL, },
};


/* Timer Controller information.  */
struct m68hc11tim 
{
  unsigned long cop_delay;
  unsigned long rti_delay;
  unsigned long ovf_delay;
  signed64      clock_prescaler;
  signed64      tcnt_adjust;
  signed64      cop_prev_interrupt;
  signed64      rti_prev_interrupt;

  /* Periodic timers.  */
  struct hw_event *rti_timer_event;
  struct hw_event *cop_timer_event;
  struct hw_event *tof_timer_event;
  struct hw_event *cmp_timer_event;
};



/* Finish off the partially created hw device.  Attach our local
   callbacks.  Wire up our port names etc.  */

static hw_io_read_buffer_method m68hc11tim_io_read_buffer;
static hw_io_write_buffer_method m68hc11tim_io_write_buffer;
static hw_port_event_method m68hc11tim_port_event;
static hw_ioctl_method m68hc11tim_ioctl;

#define M6811_TIMER_FIRST_REG (M6811_TCTN)
#define M6811_TIMER_LAST_REG  (M6811_PACNT)


static void
attach_m68hc11tim_regs (struct hw *me,
                        struct m68hc11tim *controller)
{
  hw_attach_address (hw_parent (me), M6811_IO_LEVEL, io_map,
                     M6811_TIMER_FIRST_REG,
                     M6811_TIMER_LAST_REG - M6811_TIMER_FIRST_REG + 1,
		     me);
}

static void
m68hc11tim_finish (struct hw *me)
{
  struct m68hc11tim *controller;

  controller = HW_ZALLOC (me, struct m68hc11tim);
  set_hw_data (me, controller);
  set_hw_io_read_buffer (me, m68hc11tim_io_read_buffer);
  set_hw_io_write_buffer (me, m68hc11tim_io_write_buffer);
  set_hw_ports (me, m68hc11tim_ports);
  set_hw_port_event (me, m68hc11tim_port_event);
#ifdef set_hw_ioctl
  set_hw_ioctl (me, m68hc11tim_ioctl);
#else
  me->to_ioctl = m68hc11tim_ioctl;
#endif
  
  /* Preset defaults.  */
  controller->clock_prescaler = 1;
  controller->tcnt_adjust = 0;
  
  /* Attach ourself to our parent bus.  */
  attach_m68hc11tim_regs (me, controller);
}


/* An event arrives on an interrupt port.  */

static void
m68hc11tim_port_event (struct hw *me,
                       int my_port,
                       struct hw *source,
                       int source_port,
                       int level)
{
  SIM_DESC sd;
  struct m68hc11tim *controller;
  sim_cpu *cpu;
  unsigned8 val;
  unsigned16 tcnt;

  controller = hw_data (me);
  sd         = hw_system (me);
  cpu        = STATE_CPU (sd, 0);
  switch (my_port)
    {
    case RESET_PORT:
      {
	HW_TRACE ((me, "Timer reset"));

        /* Cancel all timer events.  */
        if (controller->rti_timer_event)
          {
            hw_event_queue_deschedule (me, controller->rti_timer_event);
            controller->rti_timer_event = 0;
            controller->rti_prev_interrupt = 0;
          }
        if (controller->cop_timer_event)
          {
            hw_event_queue_deschedule (me, controller->cop_timer_event);
            controller->cop_timer_event = 0;
            controller->cop_prev_interrupt = 0;
          }
        if (controller->tof_timer_event)
          {
            hw_event_queue_deschedule (me, controller->tof_timer_event);
            controller->tof_timer_event = 0;
          }
        if (controller->cmp_timer_event)
          {
            hw_event_queue_deschedule (me, controller->cmp_timer_event);
            controller->cmp_timer_event = 0;
          }

        /* Reset the state of Timer registers.  This also restarts
           the timer events (overflow and RTI clock).  The pending
           flags (TFLG2) must be cleared explicitly here.  */
        val = 0;
        cpu->ios[M6811_TFLG2] = 0;
        m68hc11tim_io_write_buffer (me, &val, io_map,
                                    (unsigned_word) M6811_TMSK2, 1);
        m68hc11tim_io_write_buffer (me, &val, io_map,
                                    (unsigned_word) M6811_PACTL, 1);
        break;
      }

    case CAPTURE:
      tcnt = (uint16) ((cpu->cpu_absolute_cycle - controller->tcnt_adjust)
                       / controller->clock_prescaler);
      switch (level)
        {
        case M6811_TIC1:
        case M6811_TIC2:
        case M6811_TIC3:
          cpu->ios[level] = tcnt >> 8;
          cpu->ios[level + 1] = tcnt;
          break;

        default:
          hw_abort (me, "Invalid event parameter %d", level);
          break;
        }
      break;

    default:
      hw_abort (me, "Event on unknown port %d", my_port);
      break;
    }
}

enum event_type
{
  COP_EVENT,
  RTI_EVENT,
  OVERFLOW_EVENT,
  COMPARE_EVENT
};

void
m68hc11tim_timer_event (struct hw *me, void *data)
{
  SIM_DESC sd;
  struct m68hc11tim *controller;
  sim_cpu *cpu;
  enum event_type type;
  unsigned long delay;
  struct hw_event **eventp;
  int check_interrupt = 0;
  unsigned mask;
  unsigned flags;
  unsigned long tcnt_internal;
  unsigned long tcnt, tcnt_prev;
  signed64 tcnt_insn_end;
  signed64 tcnt_insn_start;
  int i;
  sim_events *events;
  
  controller = hw_data (me);
  sd         = hw_system (me);
  cpu        = STATE_CPU (sd, 0);
  type       = (enum event_type) ((long) data) & 0x0FF;
  events     = STATE_EVENTS (sd);

  delay = 0;
  switch (type)
    {
    case COP_EVENT:
      eventp = &controller->cop_timer_event;
      delay  = controller->cop_delay;
      delay  = controller->cop_prev_interrupt + controller->cop_delay;
      controller->cop_prev_interrupt = delay;
      delay  = delay - cpu->cpu_absolute_cycle;
      check_interrupt = 1;
      delay += events->nr_ticks_to_process;
      break;

    case RTI_EVENT:
      eventp = &controller->rti_timer_event;
      delay  = controller->rti_prev_interrupt + controller->rti_delay;
      
      if (((long) (data) & 0x0100) == 0)
        {
          cpu->ios[M6811_TFLG2] |= M6811_RTIF;
          check_interrupt = 1;
          controller->rti_prev_interrupt = delay;
          delay += controller->rti_delay;
        }
      delay = delay - cpu->cpu_absolute_cycle;
      delay += events->nr_ticks_to_process;
      break;

    case OVERFLOW_EVENT:
      /* Compute the 68HC11 internal free running counter.  */
      tcnt_internal = (cpu->cpu_absolute_cycle - controller->tcnt_adjust);

      /* We must take into account the prescaler that comes
         before the counter (it's a power of 2).  */
      tcnt_internal &= 0x0ffff * controller->clock_prescaler;

      /* Compute the time when the overflow will occur.  It occurs when
         the counter increments from 0x0ffff to 0x10000 (and thus resets).  */
      delay = (0x10000 * controller->clock_prescaler) - tcnt_internal;

      /* The 'nr_ticks_to_process' will be subtracted when the event
         is scheduled.  */
      delay += events->nr_ticks_to_process;

      eventp = &controller->tof_timer_event;
      if (((long) (data) & 0x100) == 0)
        {
          cpu->ios[M6811_TFLG2] |= M6811_TOF;
          check_interrupt = 1;
        }
      break;

    case COMPARE_EVENT:
      /* Compute value of TCNT register (64-bit precision) at beginning
         and end of instruction.  */
      tcnt_insn_end = (cpu->cpu_absolute_cycle - controller->tcnt_adjust);
      tcnt_insn_start = (tcnt_insn_end - cpu->cpu_current_cycle);

      /* TCNT value at beginning of current instruction.  */
      tcnt_prev = (tcnt_insn_start / controller->clock_prescaler) & 0x0ffff;

      /* TCNT value at end of current instruction.  */
      tcnt = (tcnt_insn_end / controller->clock_prescaler) & 0x0ffff;

      /* We must take into account the prescaler that comes
         before the counter (it's a power of 2).  */
      tcnt_internal = tcnt_insn_end;
      tcnt_internal &= 0x0ffff * controller->clock_prescaler;

      flags = cpu->ios[M6811_TMSK1];
      mask  = 0x80;
      delay = 65536 * controller->clock_prescaler;

      /* Scan each output compare register to see if one matches
         the free running counter.  Set the corresponding OCi flag
         if the output compare is enabled.  */
      for (i = M6811_TOC1; i <= M6811_TOC5; i += 2, mask >>= 1)
        {
          unsigned long compare;

          compare = (cpu->ios[i] << 8) + cpu->ios[i + 1];

          /* See if compare is reached; handle wrap arround.  */
          if ((compare >= tcnt_prev && compare <= tcnt && tcnt_prev < tcnt)
              || (compare >= tcnt_prev && tcnt_prev > tcnt)
              || (compare < tcnt && tcnt_prev > tcnt))
            {
              unsigned dt;

              if (compare > tcnt)
                dt = 0x10000 - compare - tcnt;
              else
                dt = tcnt - compare;

              cpu->ios[M6811_TFLG1] |= mask;

              /* Raise interrupt now at the correct CPU cycle so that
                 we can find the interrupt latency.  */
              cpu->cpu_absolute_cycle -= dt;
              interrupts_update_pending (&cpu->cpu_interrupts);
              cpu->cpu_absolute_cycle += dt;
            }

          /* Compute how many times for the next match.
             Use the internal counter value to take into account the
             prescaler accurately.  */
          compare = compare * controller->clock_prescaler;
          if (compare > tcnt_internal)
            compare = compare - tcnt_internal;
          else
            compare = compare - tcnt_internal
              + 65536 * controller->clock_prescaler;

          if (compare < delay)
            delay = compare;
        }

      /* Deactivate the compare timer if no output compare is enabled.  */
      if ((flags & 0xF8) == 0)
        delay = 0;
      else
        delay += events->nr_ticks_to_process;

      eventp = &controller->cmp_timer_event;
      break;

    default:
      eventp = 0;
      break;
    }

  if (*eventp)
    {
      hw_event_queue_deschedule (me, *eventp);
      *eventp = 0;
    }

  if (delay != 0)
    {
      *eventp = hw_event_queue_schedule (me, delay,
                                         m68hc11tim_timer_event,
                                         (void*) type);
    }

  if (check_interrupt)
    interrupts_update_pending (&cpu->cpu_interrupts);
}


/* Descriptions of the Timer I/O ports.  These descriptions are only used to
   give information of the Timer device under GDB.  */
io_reg_desc tmsk1_desc[] = {
  { M6811_OC1I,  "OC1I ", "Timer Output Compare 1 Interrupt Enable" },
  { M6811_OC2I,  "OC2I ", "Timer Output Compare 2 Interrupt Enable" },
  { M6811_OC3I,  "OC3I ", "Timer Output Compare 3 Interrupt Enable" },
  { M6811_OC4I,  "OC4I ", "Timer Output Compare 4 Interrupt Enable" },
  { M6811_OC5I,  "OC5I ", "Timer Input Capture 4 / Output Compare 5 Enable" },
  { M6811_IC1I,  "IC1I ", "Timer Input Capture 1 Interrupt Enable" },
  { M6811_IC2I,  "IC2I ", "Timer Input Capture 2 Interrupt Enable" },
  { M6811_IC3I,  "IC3I ", "Timer Input Capture 3 Interrupt Enable" },
  { 0, 0, 0 }
};

io_reg_desc tflg1_desc[] = {
  { M6811_OC1F,  "OC1F ", "Timer Output Compare 1 Interrupt Flag" },
  { M6811_OC2F,  "OC2F ", "Timer Output Compare 2 Interrupt Flag" },
  { M6811_OC3F,  "OC3F ", "Timer Output Compare 3 Interrupt Flag" },
  { M6811_OC4F,  "OC4F ", "Timer Output Compare 4 Interrupt Flag" },
  { M6811_OC5F,  "OC5F ", "Timer Input Capture 4 / Output Compare 5 Flag" },
  { M6811_IC1F,  "IC1F ", "Timer Input Capture 1 Interrupt Flag" },
  { M6811_IC2F,  "IC2F ", "Timer Input Capture 2 Interrupt Flag" },
  { M6811_IC3F,  "IC3F ", "Timer Input Capture 3 Interrupt Flag" },
  { 0, 0, 0 }
};

io_reg_desc tmsk2_desc[] = {
  { M6811_TOI,    "TOI   ", "Timer Overflow Interrupt Enable" },
  { M6811_RTII,   "RTII  ", "RTI Interrupt Enable" },
  { M6811_PAOVI,  "PAOVI ", "Pulse Accumulator Overflow Interrupt Enable" },
  { M6811_PAII,   "PAII  ", "Pulse Accumulator Interrupt Enable" },
  { M6811_PR1,    "PR1   ", "Timer prescaler (PR1)" },
  { M6811_PR0,    "PR0   ", "Timer prescaler (PR0)" },
  { M6811_TPR_1,  "TPR_1 ", "Timer prescaler div 1" },
  { M6811_TPR_4,  "TPR_4 ", "Timer prescaler div 4" },
  { M6811_TPR_8,  "TPR_8 ", "Timer prescaler div 8" },
  { M6811_TPR_16, "TPR_16", "Timer prescaler div 16" },
  { 0,  0, 0 }
};

io_reg_desc tflg2_desc[] = {
  { M6811_TOF,   "TOF   ", "Timer Overflow Bit" },
  { M6811_RTIF,  "RTIF  ", "Read Time Interrupt Flag" },
  { M6811_PAOVF, "PAOVF ", "Pulse Accumulator Overflow Interrupt Flag" },
  { M6811_PAIF,  "PAIF  ", "Pulse Accumulator Input Edge" },
  { 0,  0, 0 }
};

io_reg_desc pactl_desc[] = {
  { M6811_DDRA7,  "DDRA7 ", "Data Direction for Port A bit-7" },
  { M6811_PAEN,   "PAEN  ", "Pulse Accumulator System Enable" },
  { M6811_PAMOD,  "PAMOD ", "Pulse Accumulator Mode" },
  { M6811_PEDGE,  "PEDGE ", "Pulse Accumulator Edge Control" },
  { M6811_RTR1,   "RTR1  ", "RTI Interrupt rate select (RTR1)" },
  { M6811_RTR0,   "RTR0  ", "RTI Interrupt rate select (RTR0)" },
  { 0,  0, 0 }
};

static double
to_realtime (sim_cpu *cpu, signed64 t)
{
  return (double) (t) / (double) (cpu->cpu_frequency / 4);
}

const char*
cycle_to_string (sim_cpu *cpu, signed64 t, int flags)
{
  char time_buf[32];
  char cycle_buf[32];
  static char buf[64];

  time_buf[0] = 0;
  cycle_buf[0] = 0;
  if (flags & PRINT_TIME)
    {
      double dt;

      dt = to_realtime (cpu, t);
      if (dt < 0.001)
        sprintf (time_buf, " (%3.1f us)", dt * 1000000.0);
      else if (dt < 1.0)
        sprintf (time_buf, " (%3.1f ms)", dt * 1000.0);
      else
        sprintf (time_buf, " (%3.1f s)", dt);
    }

  if (flags & PRINT_CYCLE)
    sprintf (cycle_buf, " cycle%s",
             (t > 1 ? "s" : ""));

  if (t < LONG_MAX)
    sprintf (buf, "%9lu%s%s", (unsigned long) t, cycle_buf, time_buf);
  else
    sprintf (buf, "%llu%s%s", t, cycle_buf, time_buf);
  return buf;
}

static void
m68hc11tim_print_timer (struct hw *me, const char *name,
                        struct hw_event *event)
{
  SIM_DESC sd;
  
  sd = hw_system (me);
  if (event == 0)
    {
      sim_io_printf (sd, "  No %s interrupt will be raised.\n", name);
    }
  else
    {
      signed64 t;
      sim_cpu* cpu;

      cpu = STATE_CPU (sd, 0);

      t  = hw_event_remain_time (me, event);
      sim_io_printf (sd, "  Next %s interrupt in %s\n",
                     name, cycle_to_string (cpu, t, PRINT_TIME | PRINT_CYCLE));
    }
}

static void
m68hc11tim_info (struct hw *me)
{
  SIM_DESC sd;
  uint16 base = 0;
  sim_cpu *cpu;
  struct m68hc11tim *controller;
  uint8 val;
  uint16 val16;
  
  sd = hw_system (me);
  cpu = STATE_CPU (sd, 0);
  controller = hw_data (me);
  
  sim_io_printf (sd, "M68HC11 Timer:\n");

  base = cpu_get_io_base (cpu);

  /* Info for TIC1 */
  val16  = (cpu->ios[M6811_TIC1_H] << 8) + cpu->ios[M6811_TIC1_L];
  print_io_word (sd, "TIC1 ", 0, val16, base + M6811_TIC1);
  sim_io_printf (sd, "\n");

  /* Info for TIC2 */
  val16  = (cpu->ios[M6811_TIC2_H] << 8) + cpu->ios[M6811_TIC2_L];
  print_io_word (sd, "TIC2 ", 0, val16, base + M6811_TIC2);
  sim_io_printf (sd, "\n");

  /* Info for TIC3 */
  val16  = (cpu->ios[M6811_TIC3_H] << 8) + cpu->ios[M6811_TIC3_L];
  print_io_word (sd, "TIC3 ", 0, val16, base + M6811_TIC3);
  sim_io_printf (sd, "\n");

  /* Info for TOC1 */
  val16  = (cpu->ios[M6811_TOC1_H] << 8) + cpu->ios[M6811_TOC1_L];
  print_io_word (sd, "TOC1 ", 0, val16, base + M6811_TOC1);
  sim_io_printf (sd, "\n");

  /* Info for TOC2 */
  val16  = (cpu->ios[M6811_TOC2_H] << 8) + cpu->ios[M6811_TOC2_L];
  print_io_word (sd, "TOC2 ", 0, val16, base + M6811_TOC2);
  sim_io_printf (sd, "\n");

  /* Info for TOC3 */
  val16  = (cpu->ios[M6811_TOC3_H] << 8) + cpu->ios[M6811_TOC3_L];
  print_io_word (sd, "TOC3 ", 0, val16, base + M6811_TOC3);
  sim_io_printf (sd, "\n");

  /* Info for TOC4 */
  val16  = (cpu->ios[M6811_TOC4_H] << 8) + cpu->ios[M6811_TOC4_L];
  print_io_word (sd, "TOC4 ", 0, val16, base + M6811_TOC4);
  sim_io_printf (sd, "\n");

  /* Info for TOC5 */
  val16  = (cpu->ios[M6811_TOC5_H] << 8) + cpu->ios[M6811_TOC5_L];
  print_io_word (sd, "TOC5 ", 0, val16, base + M6811_TOC5);
  sim_io_printf (sd, "\n");

  /* Info for TMSK1 */
  val  = cpu->ios[M6811_TMSK1];
  print_io_byte (sd, "TMSK1 ", tmsk1_desc, val, base + M6811_TMSK1);
  sim_io_printf (sd, "\n");

  /* Info for TFLG1 */
  val = cpu->ios[M6811_TFLG1];
  print_io_byte (sd, "TFLG1", tflg1_desc, val, base + M6811_TFLG1);
  sim_io_printf (sd, "\n");

  val  = cpu->ios[M6811_TMSK2];
  print_io_byte (sd, "TMSK2 ", tmsk2_desc, val, base + M6811_TMSK2);
  sim_io_printf (sd, "\n");

  val = cpu->ios[M6811_TFLG2];
  print_io_byte (sd, "TFLG2", tflg2_desc, val, base + M6811_TFLG2);
  sim_io_printf (sd, "\n");

  val = cpu->ios[M6811_PACTL];
  print_io_byte (sd, "PACTL", pactl_desc, val, base + M6811_PACTL);
  sim_io_printf (sd, "\n");

  val = cpu->ios[M6811_PACNT];
  print_io_byte (sd, "PACNT", 0, val, base + M6811_PACNT);
  sim_io_printf (sd, "\n");

  /* Give info about the next timer interrupts.  */
  m68hc11tim_print_timer (me, "RTI", controller->rti_timer_event);
  m68hc11tim_print_timer (me, "COP", controller->cop_timer_event);
  m68hc11tim_print_timer (me, "OVERFLOW", controller->tof_timer_event);
  m68hc11tim_print_timer (me, "COMPARE", controller->cmp_timer_event);
}

static int
m68hc11tim_ioctl (struct hw *me,
                  hw_ioctl_request request,
                  va_list ap)
{
  m68hc11tim_info (me);
  return 0;
}

/* generic read/write */

static unsigned
m68hc11tim_io_read_buffer (struct hw *me,
                           void *dest,
                           int space,
                           unsigned_word base,
                           unsigned nr_bytes)
{
  SIM_DESC sd;
  struct m68hc11tim *controller;
  sim_cpu *cpu;
  unsigned8 val;
  unsigned cnt = 0;
  
  HW_TRACE ((me, "read 0x%08lx %d", (long) base, (int) nr_bytes));

  sd  = hw_system (me);
  cpu = STATE_CPU (sd, 0);
  controller = hw_data (me);

  while (nr_bytes)
    {
      switch (base)
        {
          /* The cpu_absolute_cycle is updated after each instruction.
             Reading in a 16-bit register will be split in two accesses
             but this will be atomic within the simulator.  */
        case M6811_TCTN_H:
          val = (uint8) ((cpu->cpu_absolute_cycle - controller->tcnt_adjust)
                         / (controller->clock_prescaler * 256));
          break;

        case M6811_TCTN_L:
          val = (uint8) ((cpu->cpu_absolute_cycle - controller->tcnt_adjust)
                         / controller->clock_prescaler);
          break;

        default:
          val = cpu->ios[base];
          break;
        }
      *((unsigned8*) dest) = val;
      dest = (char*) dest + 1;
      base++;
      nr_bytes--;
      cnt++;
    }
  return cnt;
}

static unsigned
m68hc11tim_io_write_buffer (struct hw *me,
                            const void *source,
                            int space,
                            unsigned_word base,
                            unsigned nr_bytes)
{
  SIM_DESC sd;
  struct m68hc11tim *controller;
  sim_cpu *cpu;
  unsigned8 val, n;
  signed64 adj;
  int reset_compare = 0;
  int reset_overflow = 0;
  int cnt = 0;
  
  HW_TRACE ((me, "write 0x%08lx %d", (long) base, (int) nr_bytes));

  sd  = hw_system (me);
  cpu = STATE_CPU (sd, 0);
  controller = hw_data (me);

  while (nr_bytes)
    {
      val = *((const unsigned8*) source);
      switch (base)
        {
          /* Set the timer counter low part, trying to preserve the low part.
             We compute the absolute cycle adjustment that we have to apply
             to obtain the timer current value.  Computation must be made
             in 64-bit to avoid overflow problems.  */
        case M6811_TCTN_L:
          adj = ((cpu->cpu_absolute_cycle - controller->tcnt_adjust)
                 / (controller->clock_prescaler * (signed64) 256)) & 0x0FF;
          adj = cpu->cpu_absolute_cycle
            - (adj * controller->clock_prescaler * (signed64) 256)
            - ((signed64) adj * controller->clock_prescaler);
          controller->tcnt_adjust = adj;
          reset_compare = 1;
          reset_overflow = 1;
          break;

        case M6811_TCTN_H:
          adj = ((cpu->cpu_absolute_cycle - controller->tcnt_adjust)
                 / controller->clock_prescaler) & 0x0ff;
          adj = cpu->cpu_absolute_cycle
            - ((signed64) val * controller->clock_prescaler * (signed64) 256)
            - (adj * controller->clock_prescaler);
          controller->tcnt_adjust = adj;
          reset_compare = 1;
          reset_overflow = 1;
          break;

        case M6811_TMSK2:

          /* Timer prescaler cannot be changed after 64 bus cycles.  */
          if (cpu->cpu_absolute_cycle >= 64)
            {
              val &= ~(M6811_PR1 | M6811_PR0);
              val |= cpu->ios[M6811_TMSK2] & (M6811_PR1 | M6811_PR0);
            }
          switch (val & (M6811_PR1 | M6811_PR0))
            {
            case 0:
              n = 1;
              break;
            case M6811_PR0:
              n = 4;
              break;
            case M6811_PR1:
              n = 8;
              break;
            default:
            case M6811_PR1 | M6811_PR0:
              n = 16;
              break;
            }
          if (cpu->cpu_absolute_cycle < 64)
            {
              reset_overflow = 1;
              controller->clock_prescaler = n;
            }
          cpu->ios[base] = val;
          interrupts_update_pending (&cpu->cpu_interrupts);
          break;

        case M6811_PACTL:
          n = (1 << ((val & (M6811_RTR1 | M6811_RTR0))));
          cpu->ios[base] = val;

          controller->rti_delay = (long) (n) * 8192;
          m68hc11tim_timer_event (me, (void*) (RTI_EVENT| 0x100));
          break;
      
        case M6811_TFLG2:
          val &= cpu->ios[M6811_TFLG2];
          cpu->ios[M6811_TFLG2] &= ~val;
          interrupts_update_pending (&cpu->cpu_interrupts);
          break;

        case M6811_TMSK1:
          cpu->ios[M6811_TMSK1] = val;
          interrupts_update_pending (&cpu->cpu_interrupts);
          reset_compare = 1;
          break;

        case M6811_TFLG1:
          val &= cpu->ios[M6811_TFLG1];
          cpu->ios[M6811_TFLG1] &= ~val;
          interrupts_update_pending (&cpu->cpu_interrupts);          
          break;

        case M6811_TOC1:
        case M6811_TOC2:
        case M6811_TOC3:
        case M6811_TOC4:
        case M6811_TOC5:
          cpu->ios[base] = val;
          reset_compare = 1;
          break;

        case M6811_TCTL1:
        case M6811_TCTL2:
          cpu->ios[base] = val;
          break;

        default:
          cpu->ios[base] = val;
          break;
        }

      base++;
      nr_bytes--;
      cnt++;
      source = (char*) source + 1;
    }

  /* Re-compute the next timer compare event.  */
  if (reset_compare)
    {
      m68hc11tim_timer_event (me, (void*) (COMPARE_EVENT));
    }
  if (reset_overflow)
    {
      m68hc11tim_timer_event (me, (void*) (OVERFLOW_EVENT| 0x100));
    }
  return cnt;
}     


const struct hw_descriptor dv_m68hc11tim_descriptor[] = {
  { "m68hc11tim", m68hc11tim_finish },
  { "m68hc12tim", m68hc11tim_finish },
  { NULL },
};

@


1.16
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 2
    Copyright (C) 1999-2000, 2002-2003, 2007-2012 Free Software
    Foundation, Inc.
@


1.15
log
@run copyright.sh for 2011.
@
text
@d2 2
a3 2
    Copyright (C) 1999, 2000, 2002, 2003, 2007, 2008, 2009, 2010, 2011
    Free Software Foundation, Inc.
@


1.15.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 2
    Copyright (C) 1999-2000, 2002-2003, 2007-2012 Free Software
    Foundation, Inc.
@


1.14
log
@Update copyright notices to add year 2010.
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000, 2002, 2003, 2007, 2008, 2009, 2010
@


1.13
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000, 2002, 2003, 2007, 2008, 2009
@


1.12
log
@	Updated copyright notices for most files.
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000, 2002, 2003, 2007, 2008
@


1.11
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d2 2
a3 1
    Copyright (C) 1999, 2000, 2002, 2003, 2007 Free Software Foundation, Inc.
@


1.10
log
@Copyright updates for 2007.
@
text
@d10 3
a12 3
    the Free Software Foundation; either vertimn 2 of the License, or
    (at your option) any later vertimn.
    
d17 1
a17 1
    
d19 1
a19 2
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@


1.9
log
@	* dv-m68hc11tim.c (cycle_to_string): Add flags parameter to better
	control the translation.
	(m68hc11tim_print_timer): Update cycle_to_string conversion.
	(m68hc11tim_timer_event): Fix handling of output
	compare register with its interrupts.
	(m68hc11tim_io_write_buffer): Check output compare
	after setting M6811_TMSK1.
	(m68hc11tim_io_read_buffer): Fix compilation warning.
	* dv-m68hc11.c (m68hc11_option_handler): Likewise.
	* dv-m68hc11spi.c (m68hc11spi_info): Likewise.
	* dv-m68hc11sio.c (m68hc11sio_info): Likewise.
	* interrupts.c (interrupts_info): Likewise.
	(interrupts_reset): Recognize bootstrap mode.
	* sim-main.h (PRINT_CYCLE, PRINT_TIME): New defines.
	(_sim_cpu): Add cpu_start_mode.
	(cycle_to_string): Add flags member.
	* m68hc11_sim.c (OPTION_CPU_BOOTSTRAP): New option.
	(cpu_options): Declare new option bootstrap.
	(cpu_option_handler): Handle it.
	(cpu_info): Update call to cycle_to_string.
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000, 2002, 2003 Free Software Foundation, Inc.
@


1.8
log
@	* m68hc11_sim.c (print_io_word): New function to print 16-bit value.
	* sim-main.h (print_io_word): Declare.
	* dv-m68hc11tim.c (tmsk1_desc): New description table for TMSK1.
	(tflg1_desc): Likewise for TFLG1.
	(m68hc11tim_info): Print input and output compare registers
@
text
@d28 1
a28 1

d253 3
a255 1
  unsigned long tcnt;
d294 2
a295 5
      /* Compute the 68HC11 internal free running counter.
         There may be 'nr_ticks_to_process' pending cycles that are
         not (yet) taken into account by 'sim_events_time'.  */
      tcnt_internal = sim_events_time (sd) - controller->tcnt_adjust;
      tcnt_internal += events->nr_ticks_to_process;
d318 7
a324 1
      eventp = &controller->cmp_timer_event;
d326 2
a327 6
      /* Compute the 68HC11 internal free running counter.
         There may be 'nr_ticks_to_process' pending cycles that are
         not (yet) taken into account by 'sim_events_time'.  */
      events = STATE_EVENTS (sd);
      tcnt_internal = sim_events_time (sd) - controller->tcnt_adjust;
      tcnt_internal += events->nr_ticks_to_process;
d331 1
a333 3
      /* Get current visible TCNT register value.  */
      tcnt = tcnt_internal / controller->clock_prescaler;
      
d344 7
a350 3
          
          compare = (cpu->ios[i] << 8) + cpu->ios[i+1];
          if (compare == tcnt && (flags & mask))
d352 7
d360 6
a365 1
              check_interrupt++;
d377 1
a377 1
          
d383 1
a383 1
      if ((flags & 0xF0) == 0)
d385 4
d479 1
a479 1
cycle_to_string (sim_cpu *cpu, signed64 t)
d481 2
a482 2
  double dt;
  char tbuf[32];
d485 21
a505 5
  dt = to_realtime (cpu, t);
  if (dt < 0.001)
    sprintf (tbuf, "(%3.1f us)", dt * 1000000.0);
  else if (dt < 1.0)
    sprintf (tbuf, "(%3.1f ms)", dt * 1000.0);
d507 1
a507 4
    sprintf (tbuf, "(%3.1f s)", dt);

  sprintf (buf, "%llu cycle%s %10.10s", t,
             (t > 1 ? "s" : ""), tbuf);
d531 1
a531 1
                     name, cycle_to_string (cpu, t));
d678 1
a678 1
      dest++;
d789 1
d806 1
a806 1
      
d820 1
a820 1
      source++;
@


1.7
log
@	* m68hc11_sim.c (cpu_move8): Call sim_engine_abort in default case.
	(cpu_move16): Likewise.
	(sim_memory_error): Use sim_io_printf.
	(cpu_option_handler): Fix compilation warning.
	* interp.c (sim_hw_configure): Fix compilation warning;
	remove m68hc12sio@@2 device.
	(sim_open): Likewise.
	* dv-m68hc11tim.c (m68hc11tim_port_event): Fix clear of TFLG2
	flags when reset.
	(cycle_to_string): Improve convertion of cpu cycle number.
	(m68hc11tim_info): Print info about PACNT.
	(m68hc11tim_io_write_buffer): Fix clearing of TFLG2; handle
	TCTL1 and TCTL2 registers.
	* dv-m68hc11.c (m68hc11_info): Print 6811 current running mode.
@
text
@d2 2
a3 2
    Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.
    Written by Stephane Carrez (stcarrez@@worldnet.fr)
d397 24
d511 1
d520 50
@


1.7.16.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 2
a3 2
    Copyright (C) 1999, 2000, 2002, 2003 Free Software Foundation, Inc.
    Written by Stephane Carrez (stcarrez@@nerim.fr)
d28 1
a28 1
#include <limits.h>
d253 1
a253 3
  unsigned long tcnt, tcnt_prev;
  signed64 tcnt_insn_end;
  signed64 tcnt_insn_start;
d292 5
a296 2
      /* Compute the 68HC11 internal free running counter.  */
      tcnt_internal = (cpu->cpu_absolute_cycle - controller->tcnt_adjust);
d319 1
a319 7
      /* Compute value of TCNT register (64-bit precision) at beginning
         and end of instruction.  */
      tcnt_insn_end = (cpu->cpu_absolute_cycle - controller->tcnt_adjust);
      tcnt_insn_start = (tcnt_insn_end - cpu->cpu_current_cycle);

      /* TCNT value at beginning of current instruction.  */
      tcnt_prev = (tcnt_insn_start / controller->clock_prescaler) & 0x0ffff;
d321 6
a326 2
      /* TCNT value at end of current instruction.  */
      tcnt = (tcnt_insn_end / controller->clock_prescaler) & 0x0ffff;
a329 1
      tcnt_internal = tcnt_insn_end;
d332 3
d345 3
a347 7

          compare = (cpu->ios[i] << 8) + cpu->ios[i + 1];

          /* See if compare is reached; handle wrap arround.  */
          if ((compare >= tcnt_prev && compare <= tcnt && tcnt_prev < tcnt)
              || (compare >= tcnt_prev && tcnt_prev > tcnt)
              || (compare < tcnt && tcnt_prev > tcnt))
a348 7
              unsigned dt;

              if (compare > tcnt)
                dt = 0x10000 - compare - tcnt;
              else
                dt = tcnt - compare;

d350 1
a350 6

              /* Raise interrupt now at the correct CPU cycle so that
                 we can find the interrupt latency.  */
              cpu->cpu_absolute_cycle -= dt;
              interrupts_update_pending (&cpu->cpu_interrupts);
              cpu->cpu_absolute_cycle += dt;
d362 1
a362 1

d368 1
a368 1
      if ((flags & 0xF8) == 0)
a369 4
      else
        delay += events->nr_ticks_to_process;

      eventp = &controller->cmp_timer_event;
a396 24
io_reg_desc tmsk1_desc[] = {
  { M6811_OC1I,  "OC1I ", "Timer Output Compare 1 Interrupt Enable" },
  { M6811_OC2I,  "OC2I ", "Timer Output Compare 2 Interrupt Enable" },
  { M6811_OC3I,  "OC3I ", "Timer Output Compare 3 Interrupt Enable" },
  { M6811_OC4I,  "OC4I ", "Timer Output Compare 4 Interrupt Enable" },
  { M6811_OC5I,  "OC5I ", "Timer Input Capture 4 / Output Compare 5 Enable" },
  { M6811_IC1I,  "IC1I ", "Timer Input Capture 1 Interrupt Enable" },
  { M6811_IC2I,  "IC2I ", "Timer Input Capture 2 Interrupt Enable" },
  { M6811_IC3I,  "IC3I ", "Timer Input Capture 3 Interrupt Enable" },
  { 0, 0, 0 }
};

io_reg_desc tflg1_desc[] = {
  { M6811_OC1F,  "OC1F ", "Timer Output Compare 1 Interrupt Flag" },
  { M6811_OC2F,  "OC2F ", "Timer Output Compare 2 Interrupt Flag" },
  { M6811_OC3F,  "OC3F ", "Timer Output Compare 3 Interrupt Flag" },
  { M6811_OC4F,  "OC4F ", "Timer Output Compare 4 Interrupt Flag" },
  { M6811_OC5F,  "OC5F ", "Timer Input Capture 4 / Output Compare 5 Flag" },
  { M6811_IC1F,  "IC1F ", "Timer Input Capture 1 Interrupt Flag" },
  { M6811_IC2F,  "IC2F ", "Timer Input Capture 2 Interrupt Flag" },
  { M6811_IC3F,  "IC3F ", "Timer Input Capture 3 Interrupt Flag" },
  { 0, 0, 0 }
};

d436 1
a436 1
cycle_to_string (sim_cpu *cpu, signed64 t, int flags)
d438 2
a439 2
  char time_buf[32];
  char cycle_buf[32];
d442 7
a448 5
  time_buf[0] = 0;
  cycle_buf[0] = 0;
  if (flags & PRINT_TIME)
    {
      double dt;
d450 2
a451 17
      dt = to_realtime (cpu, t);
      if (dt < 0.001)
        sprintf (time_buf, " (%3.1f us)", dt * 1000000.0);
      else if (dt < 1.0)
        sprintf (time_buf, " (%3.1f ms)", dt * 1000.0);
      else
        sprintf (time_buf, " (%3.1f s)", dt);
    }

  if (flags & PRINT_CYCLE)
    sprintf (cycle_buf, " cycle%s",
             (t > 1 ? "s" : ""));

  if (t < LONG_MAX)
    sprintf (buf, "%9lu%s%s", (unsigned long) t, cycle_buf, time_buf);
  else
    sprintf (buf, "%llu%s%s", t, cycle_buf, time_buf);
d475 1
a475 1
                     name, cycle_to_string (cpu, t, PRINT_TIME | PRINT_CYCLE));
a486 1
  uint16 val16;
a495 50
  /* Info for TIC1 */
  val16  = (cpu->ios[M6811_TIC1_H] << 8) + cpu->ios[M6811_TIC1_L];
  print_io_word (sd, "TIC1 ", 0, val16, base + M6811_TIC1);
  sim_io_printf (sd, "\n");

  /* Info for TIC2 */
  val16  = (cpu->ios[M6811_TIC2_H] << 8) + cpu->ios[M6811_TIC2_L];
  print_io_word (sd, "TIC2 ", 0, val16, base + M6811_TIC2);
  sim_io_printf (sd, "\n");

  /* Info for TIC3 */
  val16  = (cpu->ios[M6811_TIC3_H] << 8) + cpu->ios[M6811_TIC3_L];
  print_io_word (sd, "TIC3 ", 0, val16, base + M6811_TIC3);
  sim_io_printf (sd, "\n");

  /* Info for TOC1 */
  val16  = (cpu->ios[M6811_TOC1_H] << 8) + cpu->ios[M6811_TOC1_L];
  print_io_word (sd, "TOC1 ", 0, val16, base + M6811_TOC1);
  sim_io_printf (sd, "\n");

  /* Info for TOC2 */
  val16  = (cpu->ios[M6811_TOC2_H] << 8) + cpu->ios[M6811_TOC2_L];
  print_io_word (sd, "TOC2 ", 0, val16, base + M6811_TOC2);
  sim_io_printf (sd, "\n");

  /* Info for TOC3 */
  val16  = (cpu->ios[M6811_TOC3_H] << 8) + cpu->ios[M6811_TOC3_L];
  print_io_word (sd, "TOC3 ", 0, val16, base + M6811_TOC3);
  sim_io_printf (sd, "\n");

  /* Info for TOC4 */
  val16  = (cpu->ios[M6811_TOC4_H] << 8) + cpu->ios[M6811_TOC4_L];
  print_io_word (sd, "TOC4 ", 0, val16, base + M6811_TOC4);
  sim_io_printf (sd, "\n");

  /* Info for TOC5 */
  val16  = (cpu->ios[M6811_TOC5_H] << 8) + cpu->ios[M6811_TOC5_L];
  print_io_word (sd, "TOC5 ", 0, val16, base + M6811_TOC5);
  sim_io_printf (sd, "\n");

  /* Info for TMSK1 */
  val  = cpu->ios[M6811_TMSK1];
  print_io_byte (sd, "TMSK1 ", tmsk1_desc, val, base + M6811_TMSK1);
  sim_io_printf (sd, "\n");

  /* Info for TFLG1 */
  val = cpu->ios[M6811_TFLG1];
  print_io_byte (sd, "TFLG1", tflg1_desc, val, base + M6811_TFLG1);
  sim_io_printf (sd, "\n");

d571 1
a571 1
      dest = (char*) dest + 1;
a681 1
          reset_compare = 1;
d698 1
a698 1

d712 1
a712 1
      source = (char*) source + 1;
@


1.7.14.1
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d2 2
a3 2
    Copyright (C) 1999, 2000, 2002, 2003 Free Software Foundation, Inc.
    Written by Stephane Carrez (stcarrez@@nerim.fr)
d28 1
a28 1
#include <limits.h>
d253 1
a253 3
  unsigned long tcnt, tcnt_prev;
  signed64 tcnt_insn_end;
  signed64 tcnt_insn_start;
d292 5
a296 2
      /* Compute the 68HC11 internal free running counter.  */
      tcnt_internal = (cpu->cpu_absolute_cycle - controller->tcnt_adjust);
d319 1
a319 7
      /* Compute value of TCNT register (64-bit precision) at beginning
         and end of instruction.  */
      tcnt_insn_end = (cpu->cpu_absolute_cycle - controller->tcnt_adjust);
      tcnt_insn_start = (tcnt_insn_end - cpu->cpu_current_cycle);

      /* TCNT value at beginning of current instruction.  */
      tcnt_prev = (tcnt_insn_start / controller->clock_prescaler) & 0x0ffff;
d321 6
a326 2
      /* TCNT value at end of current instruction.  */
      tcnt = (tcnt_insn_end / controller->clock_prescaler) & 0x0ffff;
a329 1
      tcnt_internal = tcnt_insn_end;
d332 3
d345 3
a347 7

          compare = (cpu->ios[i] << 8) + cpu->ios[i + 1];

          /* See if compare is reached; handle wrap arround.  */
          if ((compare >= tcnt_prev && compare <= tcnt && tcnt_prev < tcnt)
              || (compare >= tcnt_prev && tcnt_prev > tcnt)
              || (compare < tcnt && tcnt_prev > tcnt))
a348 7
              unsigned dt;

              if (compare > tcnt)
                dt = 0x10000 - compare - tcnt;
              else
                dt = tcnt - compare;

d350 1
a350 6

              /* Raise interrupt now at the correct CPU cycle so that
                 we can find the interrupt latency.  */
              cpu->cpu_absolute_cycle -= dt;
              interrupts_update_pending (&cpu->cpu_interrupts);
              cpu->cpu_absolute_cycle += dt;
d362 1
a362 1

d368 1
a368 1
      if ((flags & 0xF8) == 0)
a369 4
      else
        delay += events->nr_ticks_to_process;

      eventp = &controller->cmp_timer_event;
a396 24
io_reg_desc tmsk1_desc[] = {
  { M6811_OC1I,  "OC1I ", "Timer Output Compare 1 Interrupt Enable" },
  { M6811_OC2I,  "OC2I ", "Timer Output Compare 2 Interrupt Enable" },
  { M6811_OC3I,  "OC3I ", "Timer Output Compare 3 Interrupt Enable" },
  { M6811_OC4I,  "OC4I ", "Timer Output Compare 4 Interrupt Enable" },
  { M6811_OC5I,  "OC5I ", "Timer Input Capture 4 / Output Compare 5 Enable" },
  { M6811_IC1I,  "IC1I ", "Timer Input Capture 1 Interrupt Enable" },
  { M6811_IC2I,  "IC2I ", "Timer Input Capture 2 Interrupt Enable" },
  { M6811_IC3I,  "IC3I ", "Timer Input Capture 3 Interrupt Enable" },
  { 0, 0, 0 }
};

io_reg_desc tflg1_desc[] = {
  { M6811_OC1F,  "OC1F ", "Timer Output Compare 1 Interrupt Flag" },
  { M6811_OC2F,  "OC2F ", "Timer Output Compare 2 Interrupt Flag" },
  { M6811_OC3F,  "OC3F ", "Timer Output Compare 3 Interrupt Flag" },
  { M6811_OC4F,  "OC4F ", "Timer Output Compare 4 Interrupt Flag" },
  { M6811_OC5F,  "OC5F ", "Timer Input Capture 4 / Output Compare 5 Flag" },
  { M6811_IC1F,  "IC1F ", "Timer Input Capture 1 Interrupt Flag" },
  { M6811_IC2F,  "IC2F ", "Timer Input Capture 2 Interrupt Flag" },
  { M6811_IC3F,  "IC3F ", "Timer Input Capture 3 Interrupt Flag" },
  { 0, 0, 0 }
};

d436 1
a436 1
cycle_to_string (sim_cpu *cpu, signed64 t, int flags)
d438 2
a439 2
  char time_buf[32];
  char cycle_buf[32];
d442 7
a448 5
  time_buf[0] = 0;
  cycle_buf[0] = 0;
  if (flags & PRINT_TIME)
    {
      double dt;
d450 2
a451 17
      dt = to_realtime (cpu, t);
      if (dt < 0.001)
        sprintf (time_buf, " (%3.1f us)", dt * 1000000.0);
      else if (dt < 1.0)
        sprintf (time_buf, " (%3.1f ms)", dt * 1000.0);
      else
        sprintf (time_buf, " (%3.1f s)", dt);
    }

  if (flags & PRINT_CYCLE)
    sprintf (cycle_buf, " cycle%s",
             (t > 1 ? "s" : ""));

  if (t < LONG_MAX)
    sprintf (buf, "%9lu%s%s", (unsigned long) t, cycle_buf, time_buf);
  else
    sprintf (buf, "%llu%s%s", t, cycle_buf, time_buf);
d475 1
a475 1
                     name, cycle_to_string (cpu, t, PRINT_TIME | PRINT_CYCLE));
a486 1
  uint16 val16;
a495 50
  /* Info for TIC1 */
  val16  = (cpu->ios[M6811_TIC1_H] << 8) + cpu->ios[M6811_TIC1_L];
  print_io_word (sd, "TIC1 ", 0, val16, base + M6811_TIC1);
  sim_io_printf (sd, "\n");

  /* Info for TIC2 */
  val16  = (cpu->ios[M6811_TIC2_H] << 8) + cpu->ios[M6811_TIC2_L];
  print_io_word (sd, "TIC2 ", 0, val16, base + M6811_TIC2);
  sim_io_printf (sd, "\n");

  /* Info for TIC3 */
  val16  = (cpu->ios[M6811_TIC3_H] << 8) + cpu->ios[M6811_TIC3_L];
  print_io_word (sd, "TIC3 ", 0, val16, base + M6811_TIC3);
  sim_io_printf (sd, "\n");

  /* Info for TOC1 */
  val16  = (cpu->ios[M6811_TOC1_H] << 8) + cpu->ios[M6811_TOC1_L];
  print_io_word (sd, "TOC1 ", 0, val16, base + M6811_TOC1);
  sim_io_printf (sd, "\n");

  /* Info for TOC2 */
  val16  = (cpu->ios[M6811_TOC2_H] << 8) + cpu->ios[M6811_TOC2_L];
  print_io_word (sd, "TOC2 ", 0, val16, base + M6811_TOC2);
  sim_io_printf (sd, "\n");

  /* Info for TOC3 */
  val16  = (cpu->ios[M6811_TOC3_H] << 8) + cpu->ios[M6811_TOC3_L];
  print_io_word (sd, "TOC3 ", 0, val16, base + M6811_TOC3);
  sim_io_printf (sd, "\n");

  /* Info for TOC4 */
  val16  = (cpu->ios[M6811_TOC4_H] << 8) + cpu->ios[M6811_TOC4_L];
  print_io_word (sd, "TOC4 ", 0, val16, base + M6811_TOC4);
  sim_io_printf (sd, "\n");

  /* Info for TOC5 */
  val16  = (cpu->ios[M6811_TOC5_H] << 8) + cpu->ios[M6811_TOC5_L];
  print_io_word (sd, "TOC5 ", 0, val16, base + M6811_TOC5);
  sim_io_printf (sd, "\n");

  /* Info for TMSK1 */
  val  = cpu->ios[M6811_TMSK1];
  print_io_byte (sd, "TMSK1 ", tmsk1_desc, val, base + M6811_TMSK1);
  sim_io_printf (sd, "\n");

  /* Info for TFLG1 */
  val = cpu->ios[M6811_TFLG1];
  print_io_byte (sd, "TFLG1", tflg1_desc, val, base + M6811_TFLG1);
  sim_io_printf (sd, "\n");

d571 1
a571 1
      dest = (char*) dest + 1;
a681 1
          reset_compare = 1;
d698 1
a698 1

d712 1
a712 1
      source = (char*) source + 1;
@


1.7.50.1
log
@	* m68hc11_sim.c (print_io_word): New function to print 16-bit value.
	* sim-main.h (print_io_word): Declare.
	* dv-m68hc11tim.c (tmsk1_desc): New description table for TMSK1.
	(tflg1_desc): Likewise for TFLG1.
	(m68hc11tim_info): Print input and output compare registers
@
text
@d2 2
a3 2
    Copyright (C) 1999, 2000, 2002, 2003 Free Software Foundation, Inc.
    Written by Stephane Carrez (stcarrez@@nerim.fr)
a396 24
io_reg_desc tmsk1_desc[] = {
  { M6811_OC1I,  "OC1I ", "Timer Output Compare 1 Interrupt Enable" },
  { M6811_OC2I,  "OC2I ", "Timer Output Compare 2 Interrupt Enable" },
  { M6811_OC3I,  "OC3I ", "Timer Output Compare 3 Interrupt Enable" },
  { M6811_OC4I,  "OC4I ", "Timer Output Compare 4 Interrupt Enable" },
  { M6811_OC5I,  "OC5I ", "Timer Input Capture 4 / Output Compare 5 Enable" },
  { M6811_IC1I,  "IC1I ", "Timer Input Capture 1 Interrupt Enable" },
  { M6811_IC2I,  "IC2I ", "Timer Input Capture 2 Interrupt Enable" },
  { M6811_IC3I,  "IC3I ", "Timer Input Capture 3 Interrupt Enable" },
  { 0, 0, 0 }
};

io_reg_desc tflg1_desc[] = {
  { M6811_OC1F,  "OC1F ", "Timer Output Compare 1 Interrupt Flag" },
  { M6811_OC2F,  "OC2F ", "Timer Output Compare 2 Interrupt Flag" },
  { M6811_OC3F,  "OC3F ", "Timer Output Compare 3 Interrupt Flag" },
  { M6811_OC4F,  "OC4F ", "Timer Output Compare 4 Interrupt Flag" },
  { M6811_OC5F,  "OC5F ", "Timer Input Capture 4 / Output Compare 5 Flag" },
  { M6811_IC1F,  "IC1F ", "Timer Input Capture 1 Interrupt Flag" },
  { M6811_IC2F,  "IC2F ", "Timer Input Capture 2 Interrupt Flag" },
  { M6811_IC3F,  "IC3F ", "Timer Input Capture 3 Interrupt Flag" },
  { 0, 0, 0 }
};

a486 1
  uint16 val16;
a494 50

  /* Info for TIC1 */
  val16  = (cpu->ios[M6811_TIC1_H] << 8) + cpu->ios[M6811_TIC1_L];
  print_io_word (sd, "TIC1 ", 0, val16, base + M6811_TIC1);
  sim_io_printf (sd, "\n");

  /* Info for TIC2 */
  val16  = (cpu->ios[M6811_TIC2_H] << 8) + cpu->ios[M6811_TIC2_L];
  print_io_word (sd, "TIC2 ", 0, val16, base + M6811_TIC2);
  sim_io_printf (sd, "\n");

  /* Info for TIC3 */
  val16  = (cpu->ios[M6811_TIC3_H] << 8) + cpu->ios[M6811_TIC3_L];
  print_io_word (sd, "TIC3 ", 0, val16, base + M6811_TIC3);
  sim_io_printf (sd, "\n");

  /* Info for TOC1 */
  val16  = (cpu->ios[M6811_TOC1_H] << 8) + cpu->ios[M6811_TOC1_L];
  print_io_word (sd, "TOC1 ", 0, val16, base + M6811_TOC1);
  sim_io_printf (sd, "\n");

  /* Info for TOC2 */
  val16  = (cpu->ios[M6811_TOC2_H] << 8) + cpu->ios[M6811_TOC2_L];
  print_io_word (sd, "TOC2 ", 0, val16, base + M6811_TOC2);
  sim_io_printf (sd, "\n");

  /* Info for TOC3 */
  val16  = (cpu->ios[M6811_TOC3_H] << 8) + cpu->ios[M6811_TOC3_L];
  print_io_word (sd, "TOC3 ", 0, val16, base + M6811_TOC3);
  sim_io_printf (sd, "\n");

  /* Info for TOC4 */
  val16  = (cpu->ios[M6811_TOC4_H] << 8) + cpu->ios[M6811_TOC4_L];
  print_io_word (sd, "TOC4 ", 0, val16, base + M6811_TOC4);
  sim_io_printf (sd, "\n");

  /* Info for TOC5 */
  val16  = (cpu->ios[M6811_TOC5_H] << 8) + cpu->ios[M6811_TOC5_L];
  print_io_word (sd, "TOC5 ", 0, val16, base + M6811_TOC5);
  sim_io_printf (sd, "\n");

  /* Info for TMSK1 */
  val  = cpu->ios[M6811_TMSK1];
  print_io_byte (sd, "TMSK1 ", tmsk1_desc, val, base + M6811_TMSK1);
  sim_io_printf (sd, "\n");

  /* Info for TFLG1 */
  val = cpu->ios[M6811_TFLG1];
  print_io_byte (sd, "TFLG1", tflg1_desc, val, base + M6811_TFLG1);
  sim_io_printf (sd, "\n");
@


1.7.50.2
log
@	* dv-m68hc11tim.c (cycle_to_string): Add flags parameter to better
	control the translation.
	(m68hc11tim_print_timer): Update cycle_to_string conversion.
	(m68hc11tim_timer_event): Fix handling of output
	compare register with its interrupts.
	(m68hc11tim_io_write_buffer): Check output compare
	after setting M6811_TMSK1.
	(m68hc11tim_io_read_buffer): Fix compilation warning.
	* dv-m68hc11.c (m68hc11_option_handler): Likewise.
	* dv-m68hc11spi.c (m68hc11spi_info): Likewise.
	* dv-m68hc11sio.c (m68hc11sio_info): Likewise.
	* interrupts.c (interrupts_info): Likewise.
	(interrupts_reset): Recognize bootstrap mode.
	* sim-main.h (PRINT_CYCLE, PRINT_TIME): New defines.
	(_sim_cpu): Add cpu_start_mode.
	(cycle_to_string): Add flags member.
	* m68hc11_sim.c (OPTION_CPU_BOOTSTRAP): New option.
	(cpu_options): Declare new option bootstrap.
	(cpu_option_handler): Handle it.
	(cpu_info): Update call to cycle_to_string.
@
text
@d28 1
a28 1
#include <limits.h>
d253 1
a253 3
  unsigned long tcnt, tcnt_prev;
  signed64 tcnt_insn_end;
  signed64 tcnt_insn_start;
d292 5
a296 2
      /* Compute the 68HC11 internal free running counter.  */
      tcnt_internal = (cpu->cpu_absolute_cycle - controller->tcnt_adjust);
d319 1
a319 7
      /* Compute value of TCNT register (64-bit precision) at beginning
         and end of instruction.  */
      tcnt_insn_end = (cpu->cpu_absolute_cycle - controller->tcnt_adjust);
      tcnt_insn_start = (tcnt_insn_end - cpu->cpu_current_cycle);

      /* TCNT value at beginning of current instruction.  */
      tcnt_prev = (tcnt_insn_start / controller->clock_prescaler) & 0x0ffff;
d321 6
a326 2
      /* TCNT value at end of current instruction.  */
      tcnt = (tcnt_insn_end / controller->clock_prescaler) & 0x0ffff;
a329 1
      tcnt_internal = tcnt_insn_end;
d332 3
d345 3
a347 7

          compare = (cpu->ios[i] << 8) + cpu->ios[i + 1];

          /* See if compare is reached; handle wrap arround.  */
          if ((compare >= tcnt_prev && compare <= tcnt && tcnt_prev < tcnt)
              || (compare >= tcnt_prev && tcnt_prev > tcnt)
              || (compare < tcnt && tcnt_prev > tcnt))
a348 7
              unsigned dt;

              if (compare > tcnt)
                dt = 0x10000 - compare - tcnt;
              else
                dt = tcnt - compare;

d350 1
a350 6

              /* Raise interrupt now at the correct CPU cycle so that
                 we can find the interrupt latency.  */
              cpu->cpu_absolute_cycle -= dt;
              interrupts_update_pending (&cpu->cpu_interrupts);
              cpu->cpu_absolute_cycle += dt;
d362 1
a362 1

d368 1
a368 1
      if ((flags & 0xF8) == 0)
a369 4
      else
        delay += events->nr_ticks_to_process;

      eventp = &controller->cmp_timer_event;
d460 1
a460 1
cycle_to_string (sim_cpu *cpu, signed64 t, int flags)
d462 2
a463 2
  char time_buf[32];
  char cycle_buf[32];
d466 7
a472 14
  time_buf[0] = 0;
  cycle_buf[0] = 0;
  if (flags & PRINT_TIME)
    {
      double dt;

      dt = to_realtime (cpu, t);
      if (dt < 0.001)
        sprintf (time_buf, " (%3.1f us)", dt * 1000000.0);
      else if (dt < 1.0)
        sprintf (time_buf, " (%3.1f ms)", dt * 1000.0);
      else
        sprintf (time_buf, " (%3.1f s)", dt);
    }
d474 2
a475 8
  if (flags & PRINT_CYCLE)
    sprintf (cycle_buf, " cycle%s",
             (t > 1 ? "s" : ""));

  if (t < LONG_MAX)
    sprintf (buf, "%9lu%s%s", (unsigned long) t, cycle_buf, time_buf);
  else
    sprintf (buf, "%llu%s%s", t, cycle_buf, time_buf);
d499 1
a499 1
                     name, cycle_to_string (cpu, t, PRINT_TIME | PRINT_CYCLE));
d646 1
a646 1
      dest = (char*) dest + 1;
a756 1
          reset_compare = 1;
d773 1
a773 1

d787 1
a787 1
      source = (char*) source + 1;
@


1.6
log
@	* interp.c (sim_hw_configure): Save the HW cpu pointer in the
	cpu struct.
	(sim_hw_configure): Connect the capture input/output events.
	* sim-main.h (_sim_cpu): New member hw_cpu.
	(m68hc11cpu_set_oscillator): Declare.
	(m68hc11cpu_clear_oscillator): Declare.
	(m68hc11cpu_set_port): Declare.
	* dv-m68hc11.c (m68hc11_options): New for oscillator commands.
	(m68hc11cpu_ports): New input ports and output ports to reflect
	the HC11 IOs.
	(m68hc11_delete): Cleanup any running oscillator.
	(attach_m68hc11_regs): Create the input oscillators.
	(make_oscillator): New function.
	(find_oscillator): New function.
	(oscillator_handler): New function.
	(reset_oscillators): New function.
	(m68hc11cpu_port_event): Handle the new input ports.
	(m68hc11cpu_set_oscillator): New function.
	(m68hc11cpu_clear_oscillator): New function.
	(get_frequency): New function.
	(m68hc11_option_handler): New function.
	(m68hc11cpu_set_port): New function.
	(m68hc11cpu_io_write): Post the port output events.
	* dv-m68hc11spi.c (set_bit_port): Use m68hc11cpu_set_port to set
	the output port value.
	* dv-m68hc11tim.c (m68hc11tim_port_event): Handle CAPTURE event
	by latching the TCNT value in the register.
@
text
@d197 2
a198 1
           the timer events (overflow and RTI clock).  */
d200 1
a203 2
                                    (unsigned_word) M6811_TFLG2, 1);
        m68hc11tim_io_write_buffer (me, &val, io_map,
d439 1
d441 1
a441 1
  
d444 1
a444 2
    sprintf (buf, "%llu cycle%s (%3.1f us)", t,
             (t > 1 ? "s" : ""), dt * 1000000.0);
d446 1
a446 1
    sprintf (buf, "%llu cycles (%3.1f ms)", t, dt * 1000.0);
d448 1
a448 1
    sprintf (buf, "%llu cycles (%3.1f s)", t, dt);
d450 2
d508 4
d634 1
a634 1
      /* Timer prescaler cannot be changed after 64 bus cycles.  */
d674 4
a677 4
          if (val & M6811_TOF)
            val &= ~M6811_TOF;
          else
            val |= cpu->ios[M6811_TFLG2] & M6811_TOF;
d679 2
a680 7
      /* Clear the Real Time interrupt flag. */
          if (val & M6811_RTIF)
            val &= ~M6811_RTIF;
          else
            val |= cpu->ios[M6811_TFLG2] & M6811_RTIF;
      
          cpu->ios[base] = val;
d684 6
d699 5
d705 1
@


1.5
log
@Preliminary support for 68HC12
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000 Free Software Foundation, Inc.
d53 6
d67 2
a68 1
  RESET_PORT
d74 2
a75 1
  { "reset", RESET_PORT, 0, input_port, },
a147 1

d161 2
a162 1
  
d207 18
@


1.5.8.1
log
@	* interp.c (sim_hw_configure): Save the HW cpu pointer in the
	cpu struct.
	(sim_hw_configure): Connect the capture input/output events.
	* sim-main.h (_sim_cpu): New member hw_cpu.
	(m68hc11cpu_set_oscillator): Declare.
	(m68hc11cpu_clear_oscillator): Declare.
	(m68hc11cpu_set_port): Declare.
	* dv-m68hc11.c (m68hc11_options): New for oscillator commands.
	(m68hc11cpu_ports): New input ports and output ports to reflect
	the HC11 IOs.
	(m68hc11_delete): Cleanup any running oscillator.
	(attach_m68hc11_regs): Create the input oscillators.
	(make_oscillator): New function.
	(find_oscillator): New function.
	(oscillator_handler): New function.
	(reset_oscillators): New function.
	(m68hc11cpu_port_event): Handle the new input ports.
	(m68hc11cpu_set_oscillator): New function.
	(m68hc11cpu_clear_oscillator): New function.
	(get_frequency): New function.
	(m68hc11_option_handler): New function.
	(m68hc11cpu_set_port): New function.
	(m68hc11cpu_io_write): Post the port output events.
	* dv-m68hc11spi.c (set_bit_port): Use m68hc11cpu_set_port to set
	the output port value.
	* dv-m68hc11tim.c (m68hc11tim_port_event): Handle CAPTURE event
	by latching the TCNT value in the register.
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.
a52 6
   capture (input)

        Input capture.  This port must be connected to the input
        captures.  It latches the current TCNT free running counter
        into one of the three input capture registers.

d61 1
a61 2
  RESET_PORT,
  CAPTURE
d67 1
a67 2
  { "reset",   RESET_PORT, 0, input_port, },
  { "capture", CAPTURE,    0, input_port, },
d140 1
d154 1
a154 2
  unsigned16 tcnt;

a198 18

    case CAPTURE:
      tcnt = (uint16) ((cpu->cpu_absolute_cycle - controller->tcnt_adjust)
                       / controller->clock_prescaler);
      switch (level)
        {
        case M6811_TIC1:
        case M6811_TIC2:
        case M6811_TIC3:
          cpu->ios[level] = tcnt >> 8;
          cpu->ios[level + 1] = tcnt;
          break;

        default:
          hw_abort (me, "Invalid event parameter %d", level);
          break;
        }
      break;
@


1.5.8.2
log
@	* m68hc11_sim.c (cpu_move8): Call sim_engine_abort in default case.
	(cpu_move16): Likewise.
	(sim_memory_error): Use sim_io_printf.
	(cpu_option_handler): Fix compilation warning.
	* interp.c (sim_hw_configure): Fix compilation warning;
	remove m68hc12sio@@2 device.
	(sim_open): Likewise.
	* dv-m68hc11tim.c (m68hc11tim_port_event): Fix clear of TFLG2
	flags when reset.
	(cycle_to_string): Improve convertion of cpu cycle number.
	(m68hc11tim_info): Print info about PACNT.
	(m68hc11tim_io_write_buffer): Fix clearing of TFLG2; handle
	TCTL1 and TCTL2 registers.
	* dv-m68hc11.c (m68hc11_info): Print 6811 current running mode.
@
text
@d197 1
a197 2
           the timer events (overflow and RTI clock).  The pending
           flags (TFLG2) must be cleared explicitly here.  */
a198 1
        cpu->ios[M6811_TFLG2] = 0;
d202 2
a438 1
  char tbuf[32];
d440 1
a440 1

d443 2
a444 1
    sprintf (tbuf, "(%3.1f us)", dt * 1000000.0);
d446 1
a446 1
    sprintf (tbuf, "(%3.1f ms)", dt * 1000.0);
d448 1
a448 1
    sprintf (tbuf, "(%3.1f s)", dt);
a449 2
  sprintf (buf, "%llu cycle%s %10.10s", t,
             (t > 1 ? "s" : ""), tbuf);
a505 4
  val = cpu->ios[M6811_PACNT];
  print_io_byte (sd, "PACNT", 0, val, base + M6811_PACNT);
  sim_io_printf (sd, "\n");

d628 1
a628 1
          /* Timer prescaler cannot be changed after 64 bus cycles.  */
d668 4
a671 4
          val &= cpu->ios[M6811_TFLG2];
          cpu->ios[M6811_TFLG2] &= ~val;
          interrupts_update_pending (&cpu->cpu_interrupts);
          break;
d673 7
a679 2
        case M6811_TMSK1:
          cpu->ios[M6811_TMSK1] = val;
a682 6
        case M6811_TFLG1:
          val &= cpu->ios[M6811_TFLG1];
          cpu->ios[M6811_TFLG1] &= ~val;
          interrupts_update_pending (&cpu->cpu_interrupts);          
          break;

a691 5
        case M6811_TCTL1:
        case M6811_TCTL2:
          cpu->ios[base] = val;
          break;

a692 1
          cpu->ios[base] = val;
@


1.4
log
@	* sim-main.h: Define cycle_to_string.
	* dv-m68hc11tim.c (cycle_to_string): New function to translate
	the cpu cycle into some formatted time string.
	(m68hc11tim_print_timer): Use it.
	* dv-m68hc11sio.c (m68hc11sio_info): Use cycle_to_string.
	* dv-m68hc11spi.c (m68hc11spi_info): Likewise.
	* interrupts.c (interrupts_info): Likewise.
	* m68hc11_sim.c (cpu_info): Likewise.
@
text
@a113 1

d130 1
a130 1

d690 2
a691 1
  { "m68hc11tim", m68hc11tim_finish, },
@


1.3
log
@Fix 68hc11 timer device (accuracy, io, timer overflow)
@
text
@d410 18
a441 1
      double dt;
d447 2
a448 3
      dt = to_realtime (cpu, t) * 1000.0;
      sim_io_printf (sd, "  Next %s interrupt in %ld cycles (%3.3f ms)\n",
                     name, (long) t, dt);
@


1.2
log
@Use address mapping levels for 68hc11 simulator (kill overlap hack)
@
text
@d80 2
d170 1
d176 1
d227 1
d230 1
d236 1
d244 3
d248 1
d253 2
a254 1
      delay  = controller->rti_delay;
d259 2
d262 2
d267 18
d286 5
a290 2
      delay  = controller->ovf_delay;
      cpu->ios[M6811_TFLG2] |= M6811_TOF;
d296 13
a308 4
      /* Get current free running counter.  */
      tcnt = ((cpu->cpu_absolute_cycle - controller->tcnt_adjust)
              / controller->clock_prescaler);
      tcnt &= 0x0ffffL;
d312 1
a312 1
      delay = 65536;
d319 1
a319 1
          unsigned short compare;
d328 6
a333 3
          /* Compute how many times for the next match.  */
          if (compare > tcnt)
            compare = compare - tcnt;
d335 2
a336 1
            compare = compare - tcnt + 65536;
a340 1
      delay = delay * controller->clock_prescaler;
d494 1
d502 1
a502 1
  switch (base)
d504 9
a512 7
      /* The cpu_absolute_cycle is updated after each instruction.
         Reading in a 16-bit register will be split in two accesses
         but this will be atomic within the simulator.  */
    case M6811_TCTN_H:
      val = (uint8) ((cpu->cpu_absolute_cycle - controller->tcnt_adjust)
                     / (controller->clock_prescaler * 256));
      break;
d514 4
a517 4
    case M6811_TCTN_L:
      val = (uint8) ((cpu->cpu_absolute_cycle - controller->tcnt_adjust)
                     / controller->clock_prescaler);
      break;
d519 9
a527 3
    default:
      val = cpu->ios[base];
      break;
d529 1
a529 2
  *((unsigned8*) dest) = val;
  return 1;
d545 2
d553 2
a554 3
  
  val = *((const unsigned8*) source);
  switch (base)
d556 17
a572 13
      /* Set the timer counter low part, trying to preserve the low part.
         We compute the absolute cycle adjustment that we have to apply
         to obtain the timer current value.  Computation must be made
         in 64-bit to avoid overflow problems.  */
    case M6811_TCTN_L:
      adj = ((cpu->cpu_absolute_cycle - controller->tcnt_adjust)
             / (controller->clock_prescaler * (signed64) 256)) & 0x0FF;
      adj = cpu->cpu_absolute_cycle
        - (adj * controller->clock_prescaler * (signed64) 256)
        - ((signed64) adj * controller->clock_prescaler);
      controller->tcnt_adjust = adj;
      reset_compare = 1;
      break;
d574 10
a583 9
    case M6811_TCTN_H:
      adj = ((cpu->cpu_absolute_cycle - controller->tcnt_adjust)
             / controller->clock_prescaler) & 0x0ff;
      adj = cpu->cpu_absolute_cycle
        - ((signed64) val * controller->clock_prescaler * (signed64) 256)
        - (adj * controller->clock_prescaler);
      controller->tcnt_adjust = adj;
      reset_compare = 1;
      break;
d585 1
a585 1
    case M6811_TMSK2:
d588 28
a615 19
      if (cpu->cpu_absolute_cycle >= 64)
        {
          val &= ~(M6811_PR1 | M6811_PR0);
          val |= cpu->ios[M6811_TMSK2] & (M6811_PR1 | M6811_PR0);
        }
      switch (val & (M6811_PR1 | M6811_PR0))
        {
        case 0:
          n = 1;
          break;
        case M6811_PR0:
          n = 4;
          break;
        case M6811_PR1:
          n = 8;
          break;
        default:
        case M6811_PR1 | M6811_PR0:
          n = 16;
a616 10
        }
      if (controller->clock_prescaler != n)
        {
          controller->clock_prescaler = n;
          controller->ovf_delay = n * 65536;
          m68hc11tim_timer_event (me, (void*) (OVERFLOW_EVENT| 0x100));
        }
      cpu->ios[base] = val;
      interrupts_update_pending (&cpu->cpu_interrupts);
      break;
d618 3
a620 3
    case M6811_PACTL:
      n = (1 << ((val & (M6811_RTR1 | M6811_RTR0))));
      cpu->ios[base] = val;
d622 3
a624 3
      controller->rti_delay = (long) (n) * 8192;
      m68hc11tim_timer_event (me, (void*) (RTI_EVENT| 0x100));
      break;
d626 5
a630 5
    case M6811_TFLG2:
      if (val & M6811_TOF)
        val &= ~M6811_TOF;
      else
        val |= cpu->ios[M6811_TFLG2] & M6811_TOF;
d633 4
a636 4
      if (val & M6811_RTIF)
        val &= ~M6811_RTIF;
      else
        val |= cpu->ios[M6811_TFLG2] & M6811_RTIF;
d638 3
a640 3
      cpu->ios[base] = val;
      interrupts_update_pending (&cpu->cpu_interrupts);
      break;
d642 8
a649 8
    case M6811_TOC1:
    case M6811_TOC2:
    case M6811_TOC3:
    case M6811_TOC4:
    case M6811_TOC5:
      cpu->ios[base] = val;
      reset_compare = 1;
      break;
d651 8
a658 2
    default:
      return 0;
d666 5
a670 1
  return nr_bytes;
@


1.1
log
@New simulator.
@
text
@d106 1
a106 1
  hw_attach_address (hw_parent (me), 0, io_map,
a118 1
  me->overlap_mode_hw = 1;
@

