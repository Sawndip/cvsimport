head	1.11;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.11
	gdb_7_6-2013-04-26-release:1.11
	gdb_7_6-branch:1.11.0.2
	gdb_7_6-2013-03-12-branchpoint:1.11
	gdb_7_5_1-2012-11-29-release:1.10
	gdb_7_5-2012-08-17-release:1.10
	gdb_7_5-branch:1.10.0.2
	gdb_7_5-2012-07-18-branchpoint:1.10
	gdb_7_4_1-2012-04-26-release:1.9.4.1
	gdb_7_4-2012-01-24-release:1.9.4.1
	gdb_7_4-branch:1.9.0.4
	gdb_7_4-2011-12-13-branchpoint:1.9
	gdb_7_3_1-2011-09-04-release:1.9
	gdb_7_3-2011-07-26-release:1.9
	gdb_7_3-branch:1.9.0.2
	gdb_7_3-2011-04-01-branchpoint:1.9
	gdb_7_2-2010-09-02-release:1.8
	gdb_7_2-branch:1.8.0.4
	gdb_7_2-2010-07-07-branchpoint:1.8
	gdb_7_1-2010-03-18-release:1.8
	gdb_7_1-branch:1.8.0.2
	gdb_7_1-2010-02-18-branchpoint:1.8
	gdb_7_0_1-2009-12-22-release:1.7
	gdb_7_0-2009-10-06-release:1.7
	gdb_7_0-branch:1.7.0.4
	gdb_7_0-2009-09-16-branchpoint:1.7
	arc-sim-20090309:1.6
	msnyder-checkpoint-072509-branch:1.7.0.2
	msnyder-checkpoint-072509-branchpoint:1.7
	arc-insight_6_8-branch:1.6.0.16
	arc-insight_6_8-branchpoint:1.6
	insight_6_8-branch:1.6.0.14
	insight_6_8-branchpoint:1.6
	reverse-20081226-branch:1.6.0.12
	reverse-20081226-branchpoint:1.6
	multiprocess-20081120-branch:1.6.0.10
	multiprocess-20081120-branchpoint:1.6
	reverse-20080930-branch:1.6.0.8
	reverse-20080930-branchpoint:1.6
	reverse-20080717-branch:1.6.0.6
	reverse-20080717-branchpoint:1.6
	msnyder-reverse-20080609-branch:1.6.0.4
	msnyder-reverse-20080609-branchpoint:1.6
	drow-reverse-20070409-branch:1.4.0.2
	drow-reverse-20070409-branchpoint:1.4
	gdb_6_8-2008-03-27-release:1.6
	gdb_6_8-branch:1.6.0.2
	gdb_6_8-2008-02-26-branchpoint:1.6
	gdb_6_7_1-2007-10-29-release:1.5
	gdb_6_7-2007-10-10-release:1.5
	gdb_6_7-branch:1.5.0.2
	gdb_6_7-2007-09-07-branchpoint:1.5
	insight_6_6-20070208-release:1.3
	gdb_6_6-2006-12-18-release:1.3
	gdb_6_6-branch:1.3.0.112
	gdb_6_6-2006-11-15-branchpoint:1.3
	insight_6_5-20061003-release:1.3
	gdb-csl-symbian-6_4_50_20060226-12:1.3
	gdb-csl-sourcerygxx-3_4_4-25:1.3
	nickrob-async-20060828-mergepoint:1.3
	gdb-csl-symbian-6_4_50_20060226-11:1.3
	gdb-csl-sourcerygxx-4_1-17:1.3
	gdb-csl-20060226-branch-local-2:1.3
	gdb-csl-sourcerygxx-4_1-14:1.3
	gdb-csl-sourcerygxx-4_1-13:1.3
	gdb-csl-sourcerygxx-4_1-12:1.3
	gdb-csl-sourcerygxx-3_4_4-21:1.3
	gdb_6_5-20060621-release:1.3
	gdb-csl-sourcerygxx-4_1-9:1.3
	gdb-csl-sourcerygxx-4_1-8:1.3
	gdb-csl-sourcerygxx-4_1-7:1.3
	gdb-csl-arm-2006q1-6:1.3
	gdb-csl-sourcerygxx-4_1-6:1.3
	gdb-csl-symbian-6_4_50_20060226-10:1.3
	gdb-csl-symbian-6_4_50_20060226-9:1.3
	gdb-csl-symbian-6_4_50_20060226-8:1.3
	gdb-csl-coldfire-4_1-11:1.3
	gdb-csl-sourcerygxx-3_4_4-19:1.3
	gdb-csl-coldfire-4_1-10:1.3
	gdb_6_5-branch:1.3.0.110
	gdb_6_5-2006-05-14-branchpoint:1.3
	gdb-csl-sourcerygxx-4_1-5:1.3
	nickrob-async-20060513-branch:1.3.0.108
	nickrob-async-20060513-branchpoint:1.3
	gdb-csl-sourcerygxx-4_1-4:1.3
	msnyder-reverse-20060502-branch:1.3.0.106
	msnyder-reverse-20060502-branchpoint:1.3
	gdb-csl-morpho-4_1-4:1.3
	gdb-csl-sourcerygxx-3_4_4-17:1.3
	readline_5_1-import-branch:1.3.0.104
	readline_5_1-import-branchpoint:1.3
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.3
	gdb-csl-symbian-20060226-branch:1.3.0.102
	gdb-csl-symbian-20060226-branchpoint:1.3
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.3
	msnyder-reverse-20060331-branch:1.3.0.100
	msnyder-reverse-20060331-branchpoint:1.3
	gdb-csl-available-20060303-branch:1.3.0.98
	gdb-csl-available-20060303-branchpoint:1.3
	gdb-csl-20060226-branch:1.3.0.96
	gdb-csl-20060226-branchpoint:1.3
	gdb_6_4-20051202-release:1.3
	msnyder-fork-checkpoint-branch:1.3.0.94
	msnyder-fork-checkpoint-branchpoint:1.3
	gdb-csl-gxxpro-6_3-branch:1.3.0.92
	gdb-csl-gxxpro-6_3-branchpoint:1.3
	gdb_6_4-branch:1.3.0.90
	gdb_6_4-2005-11-01-branchpoint:1.3
	gdb-csl-arm-20051020-branch:1.3.0.88
	gdb-csl-arm-20051020-branchpoint:1.3
	msnyder-tracepoint-checkpoint-branch:1.3.0.86
	msnyder-tracepoint-checkpoint-branchpoint:1.3
	gdb-csl-arm-20050325-2005-q1b:1.3
	gdb-csl-arm-20050325-2005-q1a:1.3
	csl-arm-20050325-branch:1.3.0.84
	csl-arm-20050325-branchpoint:1.3
	gdb_6_3-20041109-release:1.3
	gdb_6_3-branch:1.3.0.80
	gdb_6_3-20041019-branchpoint:1.3
	drow_intercu-merge-20040921:1.3
	drow_intercu-merge-20040915:1.3
	jimb-gdb_6_2-e500-branch:1.3.0.82
	jimb-gdb_6_2-e500-branchpoint:1.3
	gdb_6_2-20040730-release:1.3
	gdb_6_2-branch:1.3.0.78
	gdb_6_2-2004-07-10-gmt-branchpoint:1.3
	gdb_6_1_1-20040616-release:1.3
	gdb_6_1-2004-04-05-release:1.3
	drow_intercu-merge-20040402:1.3
	drow_intercu-merge-20040327:1.3
	ezannoni_pie-20040323-branch:1.3.0.76
	ezannoni_pie-20040323-branchpoint:1.3
	cagney_tramp-20040321-mergepoint:1.3
	cagney_tramp-20040309-branch:1.3.0.74
	cagney_tramp-20040309-branchpoint:1.3
	gdb_6_1-branch:1.3.0.72
	gdb_6_1-2004-03-01-gmt-branchpoint:1.3
	drow_intercu-20040221-branch:1.3.0.70
	drow_intercu-20040221-branchpoint:1.3
	cagney_bfdfile-20040213-branch:1.3.0.68
	cagney_bfdfile-20040213-branchpoint:1.3
	drow-cplus-merge-20040208:1.3
	carlton_dictionary-20040126-merge:1.3
	cagney_bigcore-20040122-branch:1.3.0.66
	cagney_bigcore-20040122-branchpoint:1.3
	drow-cplus-merge-20040113:1.3
	drow-cplus-merge-20031224:1.3
	drow-cplus-merge-20031220:1.3
	carlton_dictionary-20031215-merge:1.3
	drow-cplus-merge-20031214:1.3
	carlton-dictionary-20031111-merge:1.3
	gdb_6_0-2003-10-04-release:1.3
	kettenis_sparc-20030918-branch:1.3.0.64
	kettenis_sparc-20030918-branchpoint:1.3
	carlton_dictionary-20030917-merge:1.3
	ezannoni_pie-20030916-branchpoint:1.3
	ezannoni_pie-20030916-branch:1.3.0.62
	cagney_x86i386-20030821-branch:1.3.0.60
	cagney_x86i386-20030821-branchpoint:1.3
	carlton_dictionary-20030805-merge:1.3
	carlton_dictionary-20030627-merge:1.3
	gdb_6_0-branch:1.3.0.58
	gdb_6_0-2003-06-23-branchpoint:1.3
	jimb-ppc64-linux-20030613-branch:1.3.0.56
	jimb-ppc64-linux-20030613-branchpoint:1.3
	cagney_convert-20030606-branch:1.3.0.54
	cagney_convert-20030606-branchpoint:1.3
	cagney_writestrings-20030508-branch:1.3.0.52
	cagney_writestrings-20030508-branchpoint:1.3
	jimb-ppc64-linux-20030528-branch:1.3.0.50
	jimb-ppc64-linux-20030528-branchpoint:1.3
	carlton_dictionary-20030523-merge:1.3
	cagney_fileio-20030521-branch:1.3.0.48
	cagney_fileio-20030521-branchpoint:1.3
	kettenis_i386newframe-20030517-mergepoint:1.3
	jimb-ppc64-linux-20030509-branch:1.3.0.46
	jimb-ppc64-linux-20030509-branchpoint:1.3
	kettenis_i386newframe-20030504-mergepoint:1.3
	carlton_dictionary-20030430-merge:1.3
	kettenis_i386newframe-20030419-branch:1.3.0.44
	kettenis_i386newframe-20030419-branchpoint:1.3
	carlton_dictionary-20030416-merge:1.3
	cagney_frameaddr-20030409-mergepoint:1.3
	kettenis_i386newframe-20030406-branch:1.3.0.42
	kettenis_i386newframe-20030406-branchpoint:1.3
	cagney_frameaddr-20030403-branchpoint:1.3
	cagney_frameaddr-20030403-branch:1.3.0.40
	cagney_framebase-20030330-mergepoint:1.3
	cagney_framebase-20030326-branch:1.3.0.38
	cagney_framebase-20030326-branchpoint:1.3
	cagney_lazyid-20030317-branch:1.3.0.36
	cagney_lazyid-20030317-branchpoint:1.3
	kettenis-i386newframe-20030316-mergepoint:1.3
	offbyone-20030313-branch:1.3.0.34
	offbyone-20030313-branchpoint:1.3
	kettenis-i386newframe-20030308-branch:1.3.0.32
	kettenis-i386newframe-20030308-branchpoint:1.3
	carlton_dictionary-20030305-merge:1.3
	cagney_offbyone-20030303-branch:1.3.0.30
	cagney_offbyone-20030303-branchpoint:1.3
	carlton_dictionary-20030207-merge:1.3
	interps-20030202-branch:1.3.0.28
	interps-20030202-branchpoint:1.3
	cagney-unwind-20030108-branch:1.3.0.26
	cagney-unwind-20030108-branchpoint:1.3
	carlton_dictionary-20021223-merge:1.3
	gdb_5_3-2002-12-12-release:1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.24
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	carlton_dictionary-branch:1.3.0.22
	carlton_dictionary-20020920-branchpoint:1.3
	gdb_5_3-branch:1.3.0.20
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.18
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.16
	readline_4_3-import-branchpoint:1.3
	gdb_5_2_1-2002-07-23-release:1.3
	kseitz_interps-20020528-branch:1.3.0.14
	kseitz_interps-20020528-branchpoint:1.3
	cagney_regbuf-20020515-branch:1.3.0.12
	cagney_regbuf-20020515-branchpoint:1.3
	jimb-macro-020506-branch:1.3.0.10
	jimb-macro-020506-branchpoint:1.3
	gdb_5_2-2002-04-29-release:1.3
	gdb_5_2-branch:1.3.0.8
	gdb_5_2-2002-03-03-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.4
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.2
	gdb_5_1-2001-07-29-branchpoint:1.3
	insight-precleanup-2001-01-01:1.3;
locks; strict;
comment	@ * @;


1.11
date	2013.01.01.06.41.38;	author brobecke;	state Exp;
branches;
next	1.10;

1.10
date	2012.01.04.08.28.14;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2011.01.01.15.34.02;	author brobecke;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2010.01.01.10.03.31;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.14.10.53.08;	author brobecke;	state Exp;
branches;
next	1.6;

1.6
date	2008.01.01.22.53.25;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2007.08.24.14.28.37;	author brobecke;	state Exp;
branches;
next	1.4;

1.4
date	2007.01.09.17.59.18;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.24.20.53.35;	author ciceron;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.11.18.44.59;	author ciceron;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.27.11.23.39;	author cagney;	state Exp;
branches;
next	;

1.9.4.1
date	2012.01.06.04.54.53;	author brobecke;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/*  dv-nvram.c -- Generic driver for a non volatile ram (battery saved)
    Copyright (C) 1999-2013 Free Software Foundation, Inc.
    Written by Stephane Carrez (stcarrez@@worldnet.fr)
    (From a driver model Contributed by Cygnus Solutions.)
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    
    */


#include "sim-main.h"
#include "hw-main.h"
#include "sim-assert.h"

#include <unistd.h>
#include <fcntl.h>
#include <errno.h>


/* DEVICE

        nvram - Non Volatile Ram

   
   DESCRIPTION

        Implements a generic battery saved CMOS ram. This ram device does
        not contain any realtime clock and does not generate any interrupt.
        The ram content is loaded from a file and saved when it is changed.
        It is intended to be generic.

   
   PROPERTIES

   reg <base> <length>

        Base and size of the non-volatile ram bank.

   file <path>

        Path where the memory must be saved or loaded when we start.

   mode {map | save-modified | save-all}

        Controls how to load and save the memory content.

           map            The file is mapped in memory
           save-modified  The simulator keeps an open file descriptor to
                          the file and saves portion of memory which are
                          modified. 
           save-all       The simulator saves the complete memory each time
                          it's modified (it does not keep an open file
                          descriptor).


   PORTS

        None.


   NOTES

        This device is independent of the Motorola 68hc11.

   */



/* static functions */

/* Control of how to access the ram and save its content.  */

enum nvram_mode
{
  /* Save the complete ram block each time it's changed.
     We don't keep an open file descriptor.  This should be
     ok for small memory banks.  */
  NVRAM_SAVE_ALL,

  /* Save only the memory bytes which are modified.
     This mode means that we have to keep an open file
     descriptor (O_RDWR).  It's good for middle sized memory banks.  */
  NVRAM_SAVE_MODIFIED,

  /* Map file in memory (not yet implemented).
     This mode is suitable for large memory banks.  We don't allocate
     a buffer to represent the ram, instead it's mapped in memory
     with mmap.  */
  NVRAM_MAP_FILE
};

struct nvram 
{
  address_word    base_address; /* Base address of ram.  */
  unsigned        size;         /* Size of ram.  */
  unsigned8       *data;        /* Pointer to ram memory.  */
  const char      *file_name;   /* Path of ram file.  */
  int             fd;           /* File description of opened ram file.  */
  enum nvram_mode mode;         /* How load/save ram file.  */
};



/* Finish off the partially created hw device.  Attach our local
   callbacks.  Wire up our port names etc.  */

static hw_io_read_buffer_method  nvram_io_read_buffer;
static hw_io_write_buffer_method nvram_io_write_buffer;



static void
attach_nvram_regs (struct hw *me, struct nvram *controller)
{
  unsigned_word attach_address;
  int attach_space;
  unsigned attach_size;
  reg_property_spec reg;
  int result, oerrno;

  /* Get ram bank description (base and size).  */
  if (hw_find_property (me, "reg") == NULL)
    hw_abort (me, "Missing \"reg\" property");

  if (!hw_find_reg_array_property (me, "reg", 0, &reg))
    hw_abort (me, "\"reg\" property must contain one addr/size entry");

  hw_unit_address_to_attach_address (hw_parent (me),
				     &reg.address,
				     &attach_space,
				     &attach_address,
				     me);
  hw_unit_size_to_attach_size (hw_parent (me),
			       &reg.size,
			       &attach_size, me);

  hw_attach_address (hw_parent (me), 0,
		     attach_space, attach_address, attach_size,
		     me);

  controller->mode         = NVRAM_SAVE_ALL;
  controller->base_address = attach_address;
  controller->size         = attach_size;
  controller->fd           = -1;
  
  /* Get the file where the ram content must be loaded/saved.  */
  if(hw_find_property (me, "file") == NULL)
    hw_abort (me, "Missing \"file\" property");
  
  controller->file_name = hw_find_string_property (me, "file");

  /* Get the mode which defines how to save the memory.  */
  if(hw_find_property (me, "mode") != NULL)
    {
      const char *value = hw_find_string_property (me, "mode");

      if (strcmp (value, "map") == 0)
        controller->mode = NVRAM_MAP_FILE;
      else if (strcmp (value, "save-modified") == 0)
        controller->mode = NVRAM_SAVE_MODIFIED;
      else if (strcmp (value, "save-all") == 0)
        controller->mode = NVRAM_SAVE_ALL;
      else
	hw_abort (me, "illegal value for mode parameter `%s': "
                  "use map, save-modified or save-all", value);
    }

  /* Initialize the ram by loading/mapping the file in memory.
     If the file does not exist, create and give it some content.  */
  switch (controller->mode)
    {
    case NVRAM_MAP_FILE:
      hw_abort (me, "'map' mode is not yet implemented, use 'save-modified'");
      break;

    case NVRAM_SAVE_MODIFIED:
    case NVRAM_SAVE_ALL:
      controller->data = (char*) hw_malloc (me, attach_size);
      if (controller->data == 0)
        hw_abort (me, "Not enough memory, try to use the mode 'map'");

      memset (controller->data, 0, attach_size);
      controller->fd = open (controller->file_name, O_RDWR);
      if (controller->fd < 0)
        {
          controller->fd = open (controller->file_name,
                                 O_RDWR | O_CREAT, 0644);
          if (controller->fd < 0)
            hw_abort (me, "Cannot open or create file '%s'",
                      controller->file_name);
          result = write (controller->fd, controller->data, attach_size);
          if (result != attach_size)
            {
              oerrno = errno;
              hw_free (me, controller->data);
              close (controller->fd);
              errno = oerrno;
              hw_abort (me, "Failed to save the ram content");
            }
        }
      else
        {
          result = read (controller->fd, controller->data, attach_size);
          if (result != attach_size)
            {
              oerrno = errno;
              hw_free (me, controller->data);
              close (controller->fd);
              errno = oerrno;
              hw_abort (me, "Failed to load the ram content");
            }
        }
      if (controller->mode == NVRAM_SAVE_ALL)
        {
          close (controller->fd);
          controller->fd = -1;
        }
      break;

    default:
      break;
    }
}


static void
nvram_finish (struct hw *me)
{
  struct nvram *controller;

  controller = HW_ZALLOC (me, struct nvram);

  set_hw_data (me, controller);
  set_hw_io_read_buffer (me, nvram_io_read_buffer);
  set_hw_io_write_buffer (me, nvram_io_write_buffer);

  /* Attach ourself to our parent bus.  */
  attach_nvram_regs (me, controller);
}



/* generic read/write */

static unsigned
nvram_io_read_buffer (struct hw *me,
                      void *dest,
                      int space,
                      unsigned_word base,
                      unsigned nr_bytes)
{
  struct nvram *controller = hw_data (me);
  
  HW_TRACE ((me, "read 0x%08lx %d [%ld]",
             (long) base, (int) nr_bytes,
             (long) (base - controller->base_address)));

  base -= controller->base_address;
  if (base + nr_bytes > controller->size)
    nr_bytes = controller->size - base;
  
  memcpy (dest, &controller->data[base], nr_bytes);
  return nr_bytes;
}



static unsigned
nvram_io_write_buffer (struct hw *me,
                       const void *source,
                       int space,
                       unsigned_word base,
                       unsigned nr_bytes)
{
  struct nvram *controller = hw_data (me);

  HW_TRACE ((me, "write 0x%08lx %d [%ld]",
             (long) base, (int) nr_bytes,
             (long) (base - controller->base_address)));

  base -= controller->base_address;
  if (base + nr_bytes > controller->size)
    nr_bytes = controller->size - base;
  
  switch (controller->mode)
    {
    case NVRAM_SAVE_ALL:
      {
        int fd, result, oerrno;
        
        fd = open (controller->file_name, O_WRONLY, 0644);
        if (fd < 0)
          {
            return 0;
          }

        memcpy (&controller->data[base], source, nr_bytes);
        result = write (fd, controller->data, controller->size);
        oerrno = errno;
        close (fd);
        errno = oerrno;
  
        if (result != controller->size)
          {
            return 0;
          }
        return nr_bytes;
      }
      
    case NVRAM_SAVE_MODIFIED:
      {
        off_t pos;
        int result;

        pos = lseek (controller->fd, (off_t) base, SEEK_SET);
        if (pos != (off_t) base)
          return 0;

        result = write (controller->fd, source, nr_bytes);
        if (result < 0)
          return 0;

        nr_bytes = result;
        break;
      }

    default:
      break;
    }
  memcpy (&controller->data[base], source, nr_bytes);
  return nr_bytes;
}


const struct hw_descriptor dv_nvram_descriptor[] = {
  { "nvram", nvram_finish, },
  { NULL },
};

@


1.10
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 1
    Copyright (C) 1999-2000, 2007-2012 Free Software Foundation, Inc.
@


1.9
log
@run copyright.sh for 2011.
@
text
@d2 1
a2 2
    Copyright (C) 1999, 2000, 2007, 2008, 2009, 2010, 2011
    Free Software Foundation, Inc.
@


1.9.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 1
    Copyright (C) 1999-2000, 2007-2012 Free Software Foundation, Inc.
@


1.8
log
@Update copyright notices to add year 2010.
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000, 2007, 2008, 2009, 2010
@


1.7
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d2 2
a3 1
    Copyright (C) 1999, 2000, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.6
log
@	Updated copyright notices for most files.
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000, 2007, 2008 Free Software Foundation, Inc.
@


1.5
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000, 2007 Free Software Foundation, Inc.
@


1.4
log
@Copyright updates for 2007.
@
text
@d8 1
a8 1
    the Free Software Foundation; either version 2 of the License, or
d10 1
a10 1
    
d15 1
a15 1
    
d17 1
a17 2
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@


1.3
log
@Fix device memory allocation in 68hc11 simulator
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000 Free Software Foundation, Inc.
@


1.2
log
@Use address mapping levels for 68hc11 simulator (kill overlap hack)
@
text
@d190 1
a190 1
      controller->data = (char*) malloc (attach_size);
d207 1
a207 1
              free (controller->data);
d219 1
a219 1
              free (controller->data);
@


1.1
log
@New simulator.
@
text
@a46 5
   overlap? <bool>

        Boolean property which indicates whether the device can overlap
        another device.  By default, overlapping is not allowed.

a131 5

  /* Get the flag that controls overlapping of ram bank to another device.  */
  if (hw_find_property (me, "overlap?") != NULL
      && hw_find_boolean_property (me, "overlap?"))
    me->overlap_mode_hw = 1;
@

