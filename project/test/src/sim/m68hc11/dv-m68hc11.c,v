head	1.19;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.19
	gdb_7_6-2013-04-26-release:1.19
	gdb_7_6-branch:1.19.0.2
	gdb_7_6-2013-03-12-branchpoint:1.19
	gdb_7_5_1-2012-11-29-release:1.18
	gdb_7_5-2012-08-17-release:1.18
	gdb_7_5-branch:1.18.0.2
	gdb_7_5-2012-07-18-branchpoint:1.18
	gdb_7_4_1-2012-04-26-release:1.17.4.1
	gdb_7_4-2012-01-24-release:1.17.4.1
	gdb_7_4-branch:1.17.0.4
	gdb_7_4-2011-12-13-branchpoint:1.17
	gdb_7_3_1-2011-09-04-release:1.17
	gdb_7_3-2011-07-26-release:1.17
	gdb_7_3-branch:1.17.0.2
	gdb_7_3-2011-04-01-branchpoint:1.17
	gdb_7_2-2010-09-02-release:1.16
	gdb_7_2-branch:1.16.0.4
	gdb_7_2-2010-07-07-branchpoint:1.16
	gdb_7_1-2010-03-18-release:1.16
	gdb_7_1-branch:1.16.0.2
	gdb_7_1-2010-02-18-branchpoint:1.16
	gdb_7_0_1-2009-12-22-release:1.15
	gdb_7_0-2009-10-06-release:1.15
	gdb_7_0-branch:1.15.0.4
	gdb_7_0-2009-09-16-branchpoint:1.15
	arc-sim-20090309:1.14
	msnyder-checkpoint-072509-branch:1.15.0.2
	msnyder-checkpoint-072509-branchpoint:1.15
	arc-insight_6_8-branch:1.14.0.16
	arc-insight_6_8-branchpoint:1.14
	insight_6_8-branch:1.14.0.14
	insight_6_8-branchpoint:1.14
	reverse-20081226-branch:1.14.0.12
	reverse-20081226-branchpoint:1.14
	multiprocess-20081120-branch:1.14.0.10
	multiprocess-20081120-branchpoint:1.14
	reverse-20080930-branch:1.14.0.8
	reverse-20080930-branchpoint:1.14
	reverse-20080717-branch:1.14.0.6
	reverse-20080717-branchpoint:1.14
	msnyder-reverse-20080609-branch:1.14.0.4
	msnyder-reverse-20080609-branchpoint:1.14
	drow-reverse-20070409-branch:1.12.0.2
	drow-reverse-20070409-branchpoint:1.12
	gdb_6_8-2008-03-27-release:1.14
	gdb_6_8-branch:1.14.0.2
	gdb_6_8-2008-02-26-branchpoint:1.14
	gdb_6_7_1-2007-10-29-release:1.13
	gdb_6_7-2007-10-10-release:1.13
	gdb_6_7-branch:1.13.0.2
	gdb_6_7-2007-09-07-branchpoint:1.13
	insight_6_6-20070208-release:1.11
	gdb_6_6-2006-12-18-release:1.11
	gdb_6_6-branch:1.11.0.54
	gdb_6_6-2006-11-15-branchpoint:1.11
	insight_6_5-20061003-release:1.11
	gdb-csl-symbian-6_4_50_20060226-12:1.11
	gdb-csl-sourcerygxx-3_4_4-25:1.11
	nickrob-async-20060828-mergepoint:1.11
	gdb-csl-symbian-6_4_50_20060226-11:1.11
	gdb-csl-sourcerygxx-4_1-17:1.11
	gdb-csl-20060226-branch-local-2:1.11
	gdb-csl-sourcerygxx-4_1-14:1.11
	gdb-csl-sourcerygxx-4_1-13:1.11
	gdb-csl-sourcerygxx-4_1-12:1.11
	gdb-csl-sourcerygxx-3_4_4-21:1.11
	gdb_6_5-20060621-release:1.11
	gdb-csl-sourcerygxx-4_1-9:1.11
	gdb-csl-sourcerygxx-4_1-8:1.11
	gdb-csl-sourcerygxx-4_1-7:1.11
	gdb-csl-arm-2006q1-6:1.11
	gdb-csl-sourcerygxx-4_1-6:1.11
	gdb-csl-symbian-6_4_50_20060226-10:1.11
	gdb-csl-symbian-6_4_50_20060226-9:1.11
	gdb-csl-symbian-6_4_50_20060226-8:1.11
	gdb-csl-coldfire-4_1-11:1.11
	gdb-csl-sourcerygxx-3_4_4-19:1.11
	gdb-csl-coldfire-4_1-10:1.11
	gdb_6_5-branch:1.11.0.52
	gdb_6_5-2006-05-14-branchpoint:1.11
	gdb-csl-sourcerygxx-4_1-5:1.11
	nickrob-async-20060513-branch:1.11.0.50
	nickrob-async-20060513-branchpoint:1.11
	gdb-csl-sourcerygxx-4_1-4:1.11
	msnyder-reverse-20060502-branch:1.11.0.48
	msnyder-reverse-20060502-branchpoint:1.11
	gdb-csl-morpho-4_1-4:1.11
	gdb-csl-sourcerygxx-3_4_4-17:1.11
	readline_5_1-import-branch:1.11.0.46
	readline_5_1-import-branchpoint:1.11
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.11
	gdb-csl-symbian-20060226-branch:1.11.0.44
	gdb-csl-symbian-20060226-branchpoint:1.11
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.11
	msnyder-reverse-20060331-branch:1.11.0.42
	msnyder-reverse-20060331-branchpoint:1.11
	gdb-csl-available-20060303-branch:1.11.0.40
	gdb-csl-available-20060303-branchpoint:1.11
	gdb-csl-20060226-branch:1.11.0.38
	gdb-csl-20060226-branchpoint:1.11
	gdb_6_4-20051202-release:1.11
	msnyder-fork-checkpoint-branch:1.11.0.36
	msnyder-fork-checkpoint-branchpoint:1.11
	gdb-csl-gxxpro-6_3-branch:1.11.0.34
	gdb-csl-gxxpro-6_3-branchpoint:1.11
	gdb_6_4-branch:1.11.0.32
	gdb_6_4-2005-11-01-branchpoint:1.11
	gdb-csl-arm-20051020-branch:1.11.0.30
	gdb-csl-arm-20051020-branchpoint:1.11
	msnyder-tracepoint-checkpoint-branch:1.11.0.28
	msnyder-tracepoint-checkpoint-branchpoint:1.11
	gdb-csl-arm-20050325-2005-q1b:1.11
	gdb-csl-arm-20050325-2005-q1a:1.11
	csl-arm-20050325-branch:1.11.0.26
	csl-arm-20050325-branchpoint:1.11
	gdb_6_3-20041109-release:1.11
	gdb_6_3-branch:1.11.0.22
	gdb_6_3-20041019-branchpoint:1.11
	drow_intercu-merge-20040921:1.11
	drow_intercu-merge-20040915:1.11
	jimb-gdb_6_2-e500-branch:1.11.0.24
	jimb-gdb_6_2-e500-branchpoint:1.11
	gdb_6_2-20040730-release:1.11
	gdb_6_2-branch:1.11.0.20
	gdb_6_2-2004-07-10-gmt-branchpoint:1.11
	gdb_6_1_1-20040616-release:1.11
	gdb_6_1-2004-04-05-release:1.11
	drow_intercu-merge-20040402:1.11
	drow_intercu-merge-20040327:1.11
	ezannoni_pie-20040323-branch:1.11.0.18
	ezannoni_pie-20040323-branchpoint:1.11
	cagney_tramp-20040321-mergepoint:1.11
	cagney_tramp-20040309-branch:1.11.0.16
	cagney_tramp-20040309-branchpoint:1.11
	gdb_6_1-branch:1.11.0.14
	gdb_6_1-2004-03-01-gmt-branchpoint:1.11
	drow_intercu-20040221-branch:1.11.0.12
	drow_intercu-20040221-branchpoint:1.11
	cagney_bfdfile-20040213-branch:1.11.0.10
	cagney_bfdfile-20040213-branchpoint:1.11
	drow-cplus-merge-20040208:1.11
	carlton_dictionary-20040126-merge:1.11
	cagney_bigcore-20040122-branch:1.11.0.8
	cagney_bigcore-20040122-branchpoint:1.11
	drow-cplus-merge-20040113:1.11
	drow-cplus-merge-20031224:1.11
	drow-cplus-merge-20031220:1.11
	carlton_dictionary-20031215-merge:1.11
	drow-cplus-merge-20031214:1.11
	carlton-dictionary-20031111-merge:1.11
	gdb_6_0-2003-10-04-release:1.9.44.2
	kettenis_sparc-20030918-branch:1.11.0.6
	kettenis_sparc-20030918-branchpoint:1.11
	carlton_dictionary-20030917-merge:1.11
	ezannoni_pie-20030916-branchpoint:1.11
	ezannoni_pie-20030916-branch:1.11.0.4
	cagney_x86i386-20030821-branch:1.11.0.2
	cagney_x86i386-20030821-branchpoint:1.11
	carlton_dictionary-20030805-merge:1.9
	carlton_dictionary-20030627-merge:1.9
	gdb_6_0-branch:1.9.0.44
	gdb_6_0-2003-06-23-branchpoint:1.9
	jimb-ppc64-linux-20030613-branch:1.9.0.42
	jimb-ppc64-linux-20030613-branchpoint:1.9
	cagney_convert-20030606-branch:1.9.0.40
	cagney_convert-20030606-branchpoint:1.9
	cagney_writestrings-20030508-branch:1.9.0.38
	cagney_writestrings-20030508-branchpoint:1.9
	jimb-ppc64-linux-20030528-branch:1.9.0.36
	jimb-ppc64-linux-20030528-branchpoint:1.9
	carlton_dictionary-20030523-merge:1.9
	cagney_fileio-20030521-branch:1.9.0.34
	cagney_fileio-20030521-branchpoint:1.9
	kettenis_i386newframe-20030517-mergepoint:1.9
	jimb-ppc64-linux-20030509-branch:1.9.0.32
	jimb-ppc64-linux-20030509-branchpoint:1.9
	kettenis_i386newframe-20030504-mergepoint:1.9
	carlton_dictionary-20030430-merge:1.9
	kettenis_i386newframe-20030419-branch:1.9.0.30
	kettenis_i386newframe-20030419-branchpoint:1.9
	carlton_dictionary-20030416-merge:1.9
	cagney_frameaddr-20030409-mergepoint:1.9
	kettenis_i386newframe-20030406-branch:1.9.0.28
	kettenis_i386newframe-20030406-branchpoint:1.9
	cagney_frameaddr-20030403-branchpoint:1.9
	cagney_frameaddr-20030403-branch:1.9.0.26
	cagney_framebase-20030330-mergepoint:1.9
	cagney_framebase-20030326-branch:1.9.0.24
	cagney_framebase-20030326-branchpoint:1.9
	cagney_lazyid-20030317-branch:1.9.0.22
	cagney_lazyid-20030317-branchpoint:1.9
	kettenis-i386newframe-20030316-mergepoint:1.9
	offbyone-20030313-branch:1.9.0.20
	offbyone-20030313-branchpoint:1.9
	kettenis-i386newframe-20030308-branch:1.9.0.18
	kettenis-i386newframe-20030308-branchpoint:1.9
	carlton_dictionary-20030305-merge:1.9
	cagney_offbyone-20030303-branch:1.9.0.16
	cagney_offbyone-20030303-branchpoint:1.9
	carlton_dictionary-20030207-merge:1.9
	interps-20030202-branch:1.9.0.14
	interps-20030202-branchpoint:1.9
	cagney-unwind-20030108-branch:1.9.0.12
	cagney-unwind-20030108-branchpoint:1.9
	carlton_dictionary-20021223-merge:1.9
	gdb_5_3-2002-12-12-release:1.9
	carlton_dictionary-20021115-merge:1.9
	kseitz_interps-20021105-merge:1.9
	kseitz_interps-20021103-merge:1.9
	drow-cplus-merge-20021020:1.9
	drow-cplus-merge-20021025:1.9
	carlton_dictionary-20021025-merge:1.9
	carlton_dictionary-20021011-merge:1.9
	drow-cplus-branch:1.9.0.10
	drow-cplus-branchpoint:1.9
	kseitz_interps-20020930-merge:1.9
	carlton_dictionary-20020927-merge:1.9
	carlton_dictionary-branch:1.9.0.8
	carlton_dictionary-20020920-branchpoint:1.9
	gdb_5_3-branch:1.9.0.6
	gdb_5_3-2002-09-04-branchpoint:1.9
	kseitz_interps-20020829-merge:1.9
	cagney_sysregs-20020825-branch:1.9.0.4
	cagney_sysregs-20020825-branchpoint:1.9
	readline_4_3-import-branch:1.9.0.2
	readline_4_3-import-branchpoint:1.9
	gdb_5_2_1-2002-07-23-release:1.4.8.2
	kseitz_interps-20020528-branch:1.6.0.6
	kseitz_interps-20020528-branchpoint:1.6
	cagney_regbuf-20020515-branch:1.6.0.4
	cagney_regbuf-20020515-branchpoint:1.6
	jimb-macro-020506-branch:1.6.0.2
	jimb-macro-020506-branchpoint:1.6
	gdb_5_2-2002-04-29-release:1.4.8.2
	gdb_5_2-branch:1.4.0.8
	gdb_5_2-2002-03-03-branchpoint:1.4
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	insight-precleanup-2001-01-01:1.4;
locks; strict;
comment	@ * @;


1.19
date	2013.01.01.06.41.38;	author brobecke;	state Exp;
branches;
next	1.18;

1.18
date	2012.01.04.08.28.13;	author brobecke;	state Exp;
branches;
next	1.17;

1.17
date	2011.01.01.15.34.02;	author brobecke;	state Exp;
branches
	1.17.4.1;
next	1.16;

1.16
date	2010.01.01.10.03.31;	author brobecke;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.14.10.53.08;	author brobecke;	state Exp;
branches;
next	1.14;

1.14
date	2008.01.01.22.53.25;	author drow;	state Exp;
branches;
next	1.13;

1.13
date	2007.08.24.14.28.37;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.09.17.59.18;	author drow;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.08.21.00.55;	author ciceron;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.08.20.42.21;	author ciceron;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.13.08.38.09;	author ciceron;	state Exp;
branches
	1.9.8.1
	1.9.10.1
	1.9.44.1;
next	1.8;

1.8
date	2002.08.13.08.10.45;	author ciceron;	state Exp;
branches;
next	1.7;

1.7
date	2002.08.13.07.57.18;	author ciceron;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.07.19.17.04;	author ciceron;	state Exp;
branches
	1.6.6.1;
next	1.5;

1.5
date	2002.03.07.19.12.44;	author ciceron;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.26.21.41.30;	author ciceron;	state Exp;
branches
	1.4.8.1;
next	1.3;

1.3
date	2000.11.26.20.53.11;	author ciceron;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.11.18.44.59;	author ciceron;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.27.11.23.39;	author cagney;	state Exp;
branches;
next	;

1.17.4.1
date	2012.01.06.04.54.53;	author brobecke;	state Exp;
branches;
next	;

1.9.8.1
date	2003.09.17.21.29.03;	author carlton;	state Exp;
branches;
next	;

1.9.10.1
date	2003.12.14.20.28.26;	author drow;	state Exp;
branches;
next	;

1.9.44.1
date	2003.08.08.20.45.31;	author ciceron;	state Exp;
branches;
next	1.9.44.2;

1.9.44.2
date	2003.08.08.21.04.44;	author ciceron;	state Exp;
branches;
next	;

1.6.6.1
date	2002.08.30.22.52.58;	author kseitz;	state Exp;
branches;
next	;

1.4.8.1
date	2002.03.07.19.14.07;	author ciceron;	state Exp;
branches;
next	1.4.8.2;

1.4.8.2
date	2002.03.07.19.18.40;	author ciceron;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/*  dv-m68hc11.c -- CPU 68HC11&68HC12 as a device.
    Copyright (C) 1999-2013 Free Software Foundation, Inc.
    Written by Stephane Carrez (stcarrez@@nerim.fr)
    (From a driver model Contributed by Cygnus Solutions.)
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    
    */


#include "sim-main.h"
#include "sim-hw.h"
#include "hw-main.h"
#include "sim-options.h"
#include "hw-base.h"
#include <limits.h>

/* DEVICE

        m68hc11cpu - m68hc11 cpu virtual device
        m68hc12cpu - m68hc12 cpu virtual device
   
   DESCRIPTION

        Implements the external m68hc11/68hc12 functionality.  This includes
        the delivery of of interrupts generated from other devices and the
        handling of device specific registers.


   PROPERTIES

   reg <base> <size>

        Register base (should be 0x1000 0x03f for C11, 0x0000 0x3ff for HC12).

   clock <hz>

        Frequency of the quartz used by the processor.

   mode [single | expanded | bootstrap | test]

        Cpu operating mode (the MODA and MODB external pins).


   PORTS

   reset (input)

        Reset the cpu and generates a cpu-reset event (used to reset
        other devices).

   nmi (input)

        Deliver a non-maskable interrupt to the processor.


   set-port-a (input)
   set-port-c (input)
   set-pord-d (input)

        Allow an external device to set the value of port A, C or D inputs.


   cpu-reset (output)

        Event generated after the CPU performs a reset.


   port-a (output)
   port-b (output)
   port-c (output)
   port-d (output)

        Event generated when the value of the output port A, B, C or D
	changes.


   BUGS

        When delivering an interrupt, this code assumes that there is only
        one processor (number 0).

   */

enum
{
  OPTION_OSC_SET = OPTION_START,
  OPTION_OSC_CLEAR,
  OPTION_OSC_INFO
};

static DECLARE_OPTION_HANDLER (m68hc11_option_handler);

static const OPTION m68hc11_options[] =
{
  { {"osc-set", required_argument, NULL, OPTION_OSC_SET },
      '\0', "BIT,FREQ", "Set the oscillator on input port BIT",
      m68hc11_option_handler },
  { {"osc-clear", required_argument, NULL, OPTION_OSC_CLEAR },
      '\0', "BIT", "Clear oscillator on input port BIT",
      m68hc11_option_handler },
  { {"osc-info", no_argument, NULL, OPTION_OSC_INFO },
      '\0', NULL, "Print information about current input oscillators",
      m68hc11_option_handler },
  
  { {NULL, no_argument, NULL, 0}, '\0', NULL, NULL, NULL }
};

struct input_osc
{
  signed64         on_time;
  signed64         off_time;
  signed64         repeat;
  struct hw_event *event;
  const char      *name;
  uint8            mask;
  uint8            value;
  uint16           addr;
};

#define NR_PORT_A_OSC (4)
#define NR_PORT_B_OSC (0)
#define NR_PORT_C_OSC (8)
#define NR_PORT_D_OSC (6)
#define NR_OSC (NR_PORT_A_OSC + NR_PORT_B_OSC + NR_PORT_C_OSC + NR_PORT_D_OSC)
struct m68hc11cpu {
  /* Pending interrupts for delivery by event handler.  */
  int              pending_reset;
  int              pending_nmi;
  int              pending_level;
  struct hw_event  *event;
  unsigned_word    attach_address;
  int              attach_size;
  int              attach_space;
  int              last_oscillator;
  struct input_osc oscillators[NR_OSC];
};



/* input port ID's */ 

enum {
  RESET_PORT,
  NMI_PORT,
  IRQ_PORT,
  CPU_RESET_PORT,
  SET_PORT_A,
  SET_PORT_C,
  SET_PORT_D,
  CPU_WRITE_PORT,
  PORT_A,
  PORT_B,
  PORT_C,
  PORT_D,
  CAPTURE
};


static const struct hw_port_descriptor m68hc11cpu_ports[] = {

  /* Interrupt inputs.  */
  { "reset",     RESET_PORT,     0, input_port, },
  { "nmi",       NMI_PORT,       0, input_port, },
  { "irq",       IRQ_PORT,       0, input_port, },

  { "set-port-a", SET_PORT_A,    0, input_port, },
  { "set-port-c", SET_PORT_C,    0, input_port, },
  { "set-port-d", SET_PORT_D,    0, input_port, },

  { "cpu-write-port", CPU_WRITE_PORT,    0, input_port, },

  /* Events generated for connection to other devices.  */
  { "cpu-reset", CPU_RESET_PORT, 0, output_port, },

  /* Events generated when the corresponding port is
     changed by the program.  */
  { "port-a",    PORT_A,         0, output_port, },
  { "port-b",    PORT_B,         0, output_port, },
  { "port-c",    PORT_C,         0, output_port, },
  { "port-d",    PORT_D,         0, output_port, },

  { "capture",   CAPTURE,        0, output_port, },

  { NULL, },
};

static hw_io_read_buffer_method m68hc11cpu_io_read_buffer;
static hw_io_write_buffer_method m68hc11cpu_io_write_buffer;
static hw_ioctl_method m68hc11_ioctl;

/* Finish off the partially created hw device.  Attach our local
   callbacks.  Wire up our port names etc.  */

static hw_port_event_method m68hc11cpu_port_event;

static void make_oscillator (struct m68hc11cpu *controller,
                             const char *id, uint16 addr, uint8 mask);
static struct input_osc *find_oscillator (struct m68hc11cpu *controller,
                                          const char *id);
static void reset_oscillators (struct hw *me);

static void
dv_m6811_attach_address_callback (struct hw *me,
                                  int level,
                                  int space,
                                  address_word addr,
                                  address_word nr_bytes,
                                  struct hw *client)
{
  HW_TRACE ((me, "attach - level=%d, space=%d, addr=0x%lx, sz=%ld, client=%s",
	     level, space, (unsigned long) addr, (unsigned long) nr_bytes,
             hw_path (client)));

  if (space != io_map)
    {
      sim_core_attach (hw_system (me),
		       NULL, /*cpu*/
		       level,
		       access_read_write_exec,
		       space, addr,
		       nr_bytes,
		       0, /* modulo */
		       client,
		       NULL);
    }
  else
    {
      /*printf("Attach from sub device: %d\n", (long) addr);*/
      sim_core_attach (hw_system (me),
		       NULL, /*cpu*/
		       level,
		       access_io,
		       space, addr,
		       nr_bytes,
		       0, /* modulo */
		       client,
		       NULL);
    }
}

static void
dv_m6811_detach_address_callback (struct hw *me,
                                  int level,
                                  int space,
                                  address_word addr,
                                  address_word nr_bytes,
                                  struct hw *client)
{
  sim_core_detach (hw_system (me), NULL, /*cpu*/
                   level, space, addr);
}

static void
m68hc11_delete (struct hw* me)
{
  struct m68hc11cpu *controller;
  
  controller = hw_data (me);

  reset_oscillators (me);
  hw_detach_address (me, M6811_IO_LEVEL,
		     controller->attach_space,
		     controller->attach_address,
		     controller->attach_size, me);
}


static void
attach_m68hc11_regs (struct hw *me,
		     struct m68hc11cpu *controller)
{
  SIM_DESC sd;
  sim_cpu *cpu;
  reg_property_spec reg;
  const char *cpu_mode;
  
  if (hw_find_property (me, "reg") == NULL)
    hw_abort (me, "Missing \"reg\" property");

  if (!hw_find_reg_array_property (me, "reg", 0, &reg))
    hw_abort (me, "\"reg\" property must contain one addr/size entry");

  hw_unit_address_to_attach_address (hw_parent (me),
				     &reg.address,
				     &controller->attach_space,
				     &controller->attach_address,
				     me);
  hw_unit_size_to_attach_size (hw_parent (me),
			       &reg.size,
			       &controller->attach_size, me);

  hw_attach_address (hw_parent (me), M6811_IO_LEVEL,
		     controller->attach_space,
                     controller->attach_address,
                     controller->attach_size,
		     me);
  set_hw_delete (me, m68hc11_delete);

  /* Get cpu frequency.  */
  sd = hw_system (me);
  cpu = STATE_CPU (sd, 0);
  if (hw_find_property (me, "clock") != NULL)
    {
      cpu->cpu_frequency = hw_find_integer_property (me, "clock");
    }
  else
    {
      cpu->cpu_frequency = 8*1000*1000;
    }

  if (hw_find_property (me, "use_bank") != NULL)
    hw_attach_address (hw_parent (me), 0,
                       exec_map,
                       cpu->bank_start,
                       cpu->bank_end - cpu->bank_start,
                       me);

  cpu_mode = "expanded";
  if (hw_find_property (me, "mode") != NULL)
    cpu_mode = hw_find_string_property (me, "mode");

  if (strcmp (cpu_mode, "test") == 0)
    cpu->cpu_mode = M6811_MDA | M6811_SMOD;
  else if (strcmp (cpu_mode, "bootstrap") == 0)
    cpu->cpu_mode = M6811_SMOD;
  else if (strcmp (cpu_mode, "single") == 0)
    cpu->cpu_mode = 0;
  else
    cpu->cpu_mode = M6811_MDA;

  controller->last_oscillator = 0;

  /* Create oscillators for input port A.  */
  make_oscillator (controller, "A7", M6811_PORTA, 0x80);
  make_oscillator (controller, "A2", M6811_PORTA, 0x04);
  make_oscillator (controller, "A1", M6811_PORTA, 0x02);
  make_oscillator (controller, "A0", M6811_PORTA, 0x01);

  /* port B is output only.  */

  /* Create oscillators for input port C.  */
  make_oscillator (controller, "C0", M6811_PORTC, 0x01);
  make_oscillator (controller, "C1", M6811_PORTC, 0x02);
  make_oscillator (controller, "C2", M6811_PORTC, 0x04);
  make_oscillator (controller, "C3", M6811_PORTC, 0x08);
  make_oscillator (controller, "C4", M6811_PORTC, 0x10);
  make_oscillator (controller, "C5", M6811_PORTC, 0x20);
  make_oscillator (controller, "C6", M6811_PORTC, 0x40);
  make_oscillator (controller, "C7", M6811_PORTC, 0x80);

  /* Create oscillators for input port D.  */
  make_oscillator (controller, "D0", M6811_PORTD, 0x01);
  make_oscillator (controller, "D1", M6811_PORTD, 0x02);
  make_oscillator (controller, "D2", M6811_PORTD, 0x04);
  make_oscillator (controller, "D3", M6811_PORTD, 0x08);
  make_oscillator (controller, "D4", M6811_PORTD, 0x10);
  make_oscillator (controller, "D5", M6811_PORTD, 0x20);

  /* Add oscillator commands.  */
  sim_add_option_table (sd, 0, m68hc11_options);
}

static void
m68hc11cpu_finish (struct hw *me)
{
  struct m68hc11cpu *controller;

  controller = HW_ZALLOC (me, struct m68hc11cpu);
  set_hw_data (me, controller);
  set_hw_io_read_buffer (me, m68hc11cpu_io_read_buffer);
  set_hw_io_write_buffer (me, m68hc11cpu_io_write_buffer);
  set_hw_ports (me, m68hc11cpu_ports);
  set_hw_port_event (me, m68hc11cpu_port_event);
  set_hw_attach_address (me, dv_m6811_attach_address_callback);
  set_hw_detach_address (me, dv_m6811_detach_address_callback);
#ifdef set_hw_ioctl
  set_hw_ioctl (me, m68hc11_ioctl);
#else
  me->to_ioctl = m68hc11_ioctl;
#endif

  /* Initialize the pending interrupt flags.  */
  controller->pending_level = 0;
  controller->pending_reset = 0;
  controller->pending_nmi = 0;
  controller->event = NULL;

  attach_m68hc11_regs (me, controller);
}

/* An event arrives on an interrupt port.  */

static void
deliver_m68hc11cpu_interrupt (struct hw *me, void *data)
{
}

static void
make_oscillator (struct m68hc11cpu *controller, const char *name,
                 uint16 addr, uint8 mask)
{
  struct input_osc *osc;

  if (controller->last_oscillator >= NR_OSC)
    hw_abort (0, "Too many oscillators");

  osc = &controller->oscillators[controller->last_oscillator];
  osc->name = name;
  osc->addr = addr;
  osc->mask = mask;
  controller->last_oscillator++;
}

/* Find the oscillator given the input port name.  */
static struct input_osc *
find_oscillator (struct m68hc11cpu *controller, const char *name)
{
  int i;

  for (i = 0; i < controller->last_oscillator; i++)
    if (strcasecmp (controller->oscillators[i].name, name) == 0)
      return &controller->oscillators[i];

  return 0;
}

static void
oscillator_handler (struct hw *me, void *data)
{
  struct input_osc *osc = (struct input_osc*) data;
  SIM_DESC sd;
  sim_cpu *cpu;
  signed64 dt;
  uint8 val;

  sd = hw_system (me);
  cpu = STATE_CPU (sd, 0);

  /* Change the input bit.  */
  osc->value ^= osc->mask;
  val = cpu->ios[osc->addr] & ~osc->mask;
  val |= osc->value;
  m68hc11cpu_set_port (me, cpu, osc->addr, val);

  /* Setup event to toggle the bit.  */
  if (osc->value)
    dt = osc->on_time;
  else
    dt = osc->off_time;

  if (dt && --osc->repeat >= 0)
    {
      sim_events *events = STATE_EVENTS (sd);

      dt += events->nr_ticks_to_process;
      osc->event = hw_event_queue_schedule (me, dt, oscillator_handler, osc);
    }
  else
    osc->event = 0;
}

static void
reset_oscillators (struct hw *me)
{
  struct m68hc11cpu *controller = hw_data (me);
  int i;

  for (i = 0; i < controller->last_oscillator; i++)
    {
      if (controller->oscillators[i].event)
        {
          hw_event_queue_deschedule (me, controller->oscillators[i].event);
          controller->oscillators[i].event = 0;
        }
    }
}
      
static void
m68hc11cpu_port_event (struct hw *me,
                       int my_port,
                       struct hw *source,
                       int source_port,
                       int level)
{
  struct m68hc11cpu *controller = hw_data (me);
  SIM_DESC sd;
  sim_cpu* cpu;
  
  sd  = hw_system (me);
  cpu = STATE_CPU (sd, 0);
  switch (my_port)
    {
    case RESET_PORT:
      HW_TRACE ((me, "port-in reset"));

      /* The reset is made in 3 steps:
         - First, cleanup the current sim_cpu struct.
         - Reset the devices.
         - Restart the cpu for the reset (get the CPU mode from the
           CONFIG register that gets initialized by EEPROM device).  */
      cpu_reset (cpu);
      reset_oscillators (me);
      hw_port_event (me, CPU_RESET_PORT, 1);
      cpu_restart (cpu);
      break;
      
    case NMI_PORT:
      controller->pending_nmi = 1;
      HW_TRACE ((me, "port-in nmi"));
      break;
      
    case IRQ_PORT:
      /* level == 0 means that the interrupt was cleared.  */
      if(level == 0)
	controller->pending_level = -1; /* signal end of interrupt */
      else
	controller->pending_level = level;
      HW_TRACE ((me, "port-in level=%d", level));
      break;

    case SET_PORT_A:
      m68hc11cpu_set_port (me, cpu, M6811_PORTA, level);
      break;
      
    case SET_PORT_C:
      m68hc11cpu_set_port (me, cpu, M6811_PORTC, level);
      break;

    case SET_PORT_D:
      m68hc11cpu_set_port (me, cpu, M6811_PORTD, level);
      break;

    case CPU_WRITE_PORT:
      break;

    default:
      hw_abort (me, "bad switch");
      break;
    }

  /* Schedule an event to be delivered immediately after current
     instruction.  */
  if(controller->event != NULL)
    hw_event_queue_deschedule(me, controller->event);
  controller->event =
    hw_event_queue_schedule (me, 0, deliver_m68hc11cpu_interrupt, NULL);
}


io_reg_desc config_desc[] = {
  { M6811_NOSEC, "NOSEC ", "Security Mode Disable" },
  { M6811_NOCOP, "NOCOP ", "COP System Disable" },
  { M6811_ROMON, "ROMON ", "Enable On-chip Rom" },
  { M6811_EEON,  "EEON  ", "Enable On-chip EEprom" },
  { 0,  0, 0 }
};

io_reg_desc hprio_desc[] = {
  { M6811_RBOOT, "RBOOT ", "Read Bootstrap ROM" },
  { M6811_SMOD,  "SMOD  ", "Special Mode" },
  { M6811_MDA,   "MDA   ", "Mode Select A" },
  { M6811_IRV,   "IRV   ", "Internal Read Visibility" },
  { 0,  0, 0 }
};

io_reg_desc option_desc[] = {
  { M6811_ADPU,  "ADPU  ", "A/D Powerup" },
  { M6811_CSEL,  "CSEL  ", "A/D/EE Charge pump clock source select" },
  { M6811_IRQE,  "IRQE  ", "IRQ Edge/Level sensitive" },
  { M6811_DLY,   "DLY   ", "Stop exit turn on delay" },
  { M6811_CME,   "CME   ", "Clock Monitor Enable" },
  { M6811_CR1,   "CR1   ", "COP timer rate select (CR1)" },
  { M6811_CR0,   "CR0   ", "COP timer rate select (CR0)" },
  { 0,  0, 0 }
};

static void
m68hc11_info (struct hw *me)
{
  SIM_DESC sd;
  uint16 base = 0;
  sim_cpu *cpu;
  struct m68hc11sio *controller;
  uint8 val;
  
  sd = hw_system (me);
  cpu = STATE_CPU (sd, 0);
  controller = hw_data (me);

  base = cpu_get_io_base (cpu);
  sim_io_printf (sd, "M68HC11:\n");

  val = cpu->ios[M6811_HPRIO];
  print_io_byte (sd, "HPRIO ", hprio_desc, val, base + M6811_HPRIO);
  switch (cpu->cpu_mode)
    {
    case M6811_MDA | M6811_SMOD:
      sim_io_printf (sd, "[test]\n");
      break;
    case M6811_SMOD:
      sim_io_printf (sd, "[bootstrap]\n");
      break;
    case M6811_MDA:
      sim_io_printf (sd, "[extended]\n");
      break;
    default:
      sim_io_printf (sd, "[single]\n");
      break;
    }

  val = cpu->ios[M6811_CONFIG];
  print_io_byte (sd, "CONFIG", config_desc, val, base + M6811_CONFIG);
  sim_io_printf (sd, "\n");

  val = cpu->ios[M6811_OPTION];
  print_io_byte (sd, "OPTION", option_desc, val, base + M6811_OPTION);
  sim_io_printf (sd, "\n");

  val = cpu->ios[M6811_INIT];
  print_io_byte (sd, "INIT  ", 0, val, base + M6811_INIT);
  sim_io_printf (sd, "Ram = 0x%04x IO = 0x%04x\n",
		 (((uint16) (val & 0xF0)) << 8),
		 (((uint16) (val & 0x0F)) << 12));


  cpu_info (sd, cpu);
  interrupts_info (sd, &cpu->cpu_interrupts);
}

static int
m68hc11_ioctl (struct hw *me,
	       hw_ioctl_request request,
	       va_list ap)
{
  m68hc11_info (me);
  return 0;
}

/* Setup an oscillator on an input port.

   TON represents the time in seconds that the input port should be set to 1.
   TOFF is the time in seconds for the input port to be set to 0.

   The oscillator frequency is therefore 1 / (ton + toff).

   REPEAT indicates the number of 1 <-> 0 transitions until the oscillator
   stops.  */
int
m68hc11cpu_set_oscillator (SIM_DESC sd, const char *port,
                           double ton, double toff, signed64 repeat)
{
  sim_cpu *cpu;
  struct input_osc *osc;
  double f;

  cpu = STATE_CPU (sd, 0);

  /* Find oscillator that corresponds to the input port.  */
  osc = find_oscillator (hw_data (cpu->hw_cpu), port);
  if (osc == 0)
    return -1;

  /* Compute the ON time in cpu cycles.  */
  f = (double) (cpu->cpu_frequency) * ton;
  osc->on_time = (signed64) (f / 4.0);
  if (osc->on_time < 1)
    osc->on_time = 1;

  /* Compute the OFF time in cpu cycles.  */
  f = (double) (cpu->cpu_frequency) * toff;
  osc->off_time = (signed64) (f / 4.0);
  if (osc->off_time < 1)
    osc->off_time = 1;

  osc->repeat = repeat;
  if (osc->event)
    hw_event_queue_deschedule (cpu->hw_cpu, osc->event);

  osc->event = hw_event_queue_schedule (cpu->hw_cpu,
                                        osc->value ? osc->on_time
                                        : osc->off_time,
                                        oscillator_handler, osc);
  return 0;
}

/* Clear the oscillator.  */
int
m68hc11cpu_clear_oscillator (SIM_DESC sd, const char *port)
{
  sim_cpu *cpu;
  struct input_osc *osc;

  cpu = STATE_CPU (sd, 0);
  osc = find_oscillator (hw_data (cpu->hw_cpu), port);
  if (osc == 0)
    return -1;

  if (osc->event)
    hw_event_queue_deschedule (cpu->hw_cpu, osc->event);
  osc->event = 0;
  osc->repeat = 0;
  return 0;
}

static int
get_frequency (const char *s, double *f)
{
  char *p;
  
  *f = strtod (s, &p);
  if (s == p)
    return -1;

  if (*p)
    {
      if (strcasecmp (p, "khz") == 0)
        *f = *f * 1000.0;
      else if (strcasecmp (p, "mhz") == 0)
        *f = *f  * 1000000.0;
      else if (strcasecmp (p, "hz") != 0)
        return -1;
    }
  return 0;
}

static SIM_RC
m68hc11_option_handler (SIM_DESC sd, sim_cpu *cpu,
                        int opt, char *arg, int is_command)
{
  struct m68hc11cpu *controller;
  double f;
  char *p;
  int i;
  int title_printed = 0;
  
  if (cpu == 0)
    cpu = STATE_CPU (sd, 0);

  controller = hw_data (cpu->hw_cpu);
  switch (opt)
    {
    case OPTION_OSC_SET:
      p = strchr (arg, ',');
      if (p)
        *p++ = 0;

      if (p == 0)
        sim_io_eprintf (sd, "No frequency specified\n");
      else if (get_frequency (p, &f) < 0 || f < 1.0e-8)
        sim_io_eprintf (sd, "Invalid frequency: '%s'\n", p);
      else if (m68hc11cpu_set_oscillator (sd, arg,
                                          1.0 / (f * 2.0),
                                          1.0 / (f * 2.0), LONG_MAX))
        sim_io_eprintf (sd, "Invalid input port: '%s'\n", arg);
      break;

    case OPTION_OSC_CLEAR:
      if (m68hc11cpu_clear_oscillator (sd, arg) != 0)
        sim_io_eprintf (sd, "Invalid input port: '%s'\n", arg);
      break;

    case OPTION_OSC_INFO:
      for (i = 0; i < controller->last_oscillator; i++)
        {
          signed64 t;
          struct input_osc *osc;

          osc = &controller->oscillators[i];
          if (osc->event)
            {
              double f;
              int cur_value;
              int next_value;
              char freq[32];

              if (title_printed == 0)
                {
                  title_printed = 1;
                  sim_io_printf (sd, " PORT  Frequency   Current"
                                 "    Next    Transition time\n");
                }

              f = (double) (osc->on_time + osc->off_time);
              f = (double) (cpu->cpu_frequency / 4) / f;
              t = hw_event_remain_time (cpu->hw_cpu, osc->event);

              if (f > 10000.0)
                sprintf (freq, "%6.2f", f / 1000.0);
              else
                sprintf (freq, "%6.2f", f);
              cur_value = osc->value ? 1 : 0;
              next_value = osc->value ? 0 : 1;
              if (f > 10000.0)
                sim_io_printf (sd, " %4.4s  %8.8s khz"
                               "      %d       %d    %35.35s\n",
                               osc->name, freq,
                               cur_value, next_value,
                               cycle_to_string (cpu, t,
                                                PRINT_TIME | PRINT_CYCLE));
              else
                sim_io_printf (sd, " %4.4s  %8.8s hz "
                               "      %d       %d    %35.35s\n",
                               osc->name, freq,
                               cur_value, next_value,
                               cycle_to_string (cpu, t,
                                                PRINT_TIME | PRINT_CYCLE));
            }
        }
      break;      
    }

  return SIM_RC_OK;
}

/* generic read/write */

static unsigned
m68hc11cpu_io_read_buffer (struct hw *me,
			   void *dest,
			   int space,
			   unsigned_word base,
			   unsigned nr_bytes)
{
  SIM_DESC sd;
  struct m68hc11cpu *controller = hw_data (me);
  sim_cpu *cpu;
  unsigned byte = 0;
  int result;
  
  HW_TRACE ((me, "read 0x%08lx %d", (long) base, (int) nr_bytes));

  sd  = hw_system (me);
  cpu = STATE_CPU (sd, 0);

  if (base >= cpu->bank_start && base < cpu->bank_end)
    {
      address_word virt_addr = phys_to_virt (cpu, base);
      if (virt_addr != base)
        return sim_core_read_buffer (sd, cpu, space, dest,
                                     virt_addr, nr_bytes);
    }

  /* Handle reads for the sub-devices.  */
  base -= controller->attach_address;
  result = sim_core_read_buffer (sd, cpu,
				 io_map, dest, base, nr_bytes);
  if (result > 0)
    return result;
  
  while (nr_bytes)
    {
      if (base >= controller->attach_size)
	break;

      memcpy (dest, &cpu->ios[base], 1);
      dest = (char*) dest + 1;
      base++;
      byte++;
      nr_bytes--;
    }
  return byte;
}     

void
m68hc11cpu_set_port (struct hw *me, sim_cpu *cpu,
                     unsigned addr, uint8 val)
{
  uint8 mask;
  uint8 delta;
  int check_interrupts = 0;
  int i;
  
  switch (addr)
    {
    case M6811_PORTA:
      if (cpu->ios[M6811_PACTL] & M6811_DDRA7)
        mask = 3;
      else
        mask = 0x83;

      val = val & mask;
      val |= cpu->ios[M6811_PORTA] & ~mask;
      delta = val ^ cpu->ios[M6811_PORTA];
      cpu->ios[M6811_PORTA] = val;
      if (delta & 0x80)
        {
          /* Pulse accumulator is enabled.  */
          if ((cpu->ios[M6811_PACTL] & M6811_PAEN)
              && !(cpu->ios[M6811_PACTL] & M6811_PAMOD))
            {
              int inc;

              /* Increment event counter according to rising/falling edge.  */
              if (cpu->ios[M6811_PACTL] & M6811_PEDGE)
                inc = (val & 0x80) ? 1 : 0;
              else
                inc = (val & 0x80) ? 0 : 1;

              cpu->ios[M6811_PACNT] += inc;

              /* Event counter overflowed.  */
              if (inc && cpu->ios[M6811_PACNT] == 0)
                {
                  cpu->ios[M6811_TFLG2] |= M6811_PAOVI;
                  check_interrupts = 1;
                }
            }
        }

      /* Scan IC3, IC2 and IC1.  Bit number is 3 - i.  */
      for (i = 0; i < 3; i++)
        {
          uint8 mask = (1 << i);
          
          if (delta & mask)
            {
              uint8 edge;
              int captured;

              edge = cpu->ios[M6811_TCTL2];
              edge = (edge >> (2 * i)) & 0x3;
              switch (edge)
                {
                case 0:
                  captured = 0;
                  break;
                case 1:
                  captured = (val & mask) != 0;
                  break;
                case 2:
                  captured = (val & mask) == 0;
                  break;
                default:
                  captured = 1;
                  break;
                }
              if (captured)
                {
                  cpu->ios[M6811_TFLG1] |= (1 << i);
                  hw_port_event (me, CAPTURE, M6811_TIC1 + 3 - i);
                  check_interrupts = 1;
                }
            }
        }
      break;

    case M6811_PORTC:
      mask = cpu->ios[M6811_DDRC];
      val = val & mask;
      val |= cpu->ios[M6811_PORTC] & ~mask;
      cpu->ios[M6811_PORTC] = val;
      break;

    case M6811_PORTD:
      mask = cpu->ios[M6811_DDRD];
      val = val & mask;
      val |= cpu->ios[M6811_PORTD] & ~mask;
      cpu->ios[M6811_PORTD] = val;
      break;

    default:
      break;
    }

  if (check_interrupts)
    interrupts_update_pending (&cpu->cpu_interrupts);
}

static void
m68hc11cpu_io_write (struct hw *me, sim_cpu *cpu,
                     unsigned_word addr, uint8 val)
{
  switch (addr)
    {
    case M6811_PORTA:
      hw_port_event (me, PORT_A, val);
      break;

    case M6811_PIOC:
      break;

    case M6811_PORTC:
      hw_port_event (me, PORT_C, val);
      break;

    case M6811_PORTB:
      hw_port_event (me, PORT_B, val);
      break;

    case M6811_PORTCL:
      break;

    case M6811_DDRC:
      break;

    case M6811_PORTD:
      hw_port_event (me, PORT_D, val);
      break;

    case M6811_DDRD:
      break;

    case M6811_TMSK2:
      
      break;
      
      /* Change the RAM and I/O mapping.  */
    case M6811_INIT:
      {
	uint8 old_bank = cpu->ios[M6811_INIT];
	
	cpu->ios[M6811_INIT] = val;

	/* Update IO mapping.  Detach from the old address
	   and attach to the new one.  */
	if ((old_bank & 0x0F) != (val & 0x0F))
	  {
            struct m68hc11cpu *controller = hw_data (me);

            hw_detach_address (hw_parent (me), M6811_IO_LEVEL,
                               controller->attach_space,
                               controller->attach_address,
                               controller->attach_size,
                               me);
            controller->attach_address = (val & 0x0F0) << 12;
            hw_attach_address (hw_parent (me), M6811_IO_LEVEL,
                               controller->attach_space,
                               controller->attach_address,
                               controller->attach_size,
                               me);
	  }
	if ((old_bank & 0xF0) != (val & 0xF0))
	  {
	    ;
	  }
	return;
      }

    /* Writing the config is similar to programing the eeprom.
       The config register value is the last byte of the EEPROM.
       This last byte is not mapped in memory (that's why we have
       to add '1' to 'end_addr').  */
    case M6811_CONFIG:
      {
        return;
      }
      

      /* COP reset.  */
    case M6811_COPRST:
      if (val == 0xAA && cpu->ios[addr] == 0x55)
	{
          val = 0;
          /* COP reset here.  */
	}
      break;
      
    default:
      break;

    }
  cpu->ios[addr] = val;
}

static unsigned
m68hc11cpu_io_write_buffer (struct hw *me,
			    const void *source,
			    int space,
			    unsigned_word base,
			    unsigned nr_bytes)
{
  SIM_DESC sd;
  struct m68hc11cpu *controller = hw_data (me);
  unsigned byte;
  sim_cpu *cpu;
  int result;

  HW_TRACE ((me, "write 0x%08lx %d", (long) base, (int) nr_bytes));

  sd = hw_system (me); 
  cpu = STATE_CPU (sd, 0);  

  if (base >= cpu->bank_start && base < cpu->bank_end)
    {
      address_word virt_addr = phys_to_virt (cpu, base);
      if (virt_addr != base)
        return sim_core_write_buffer (sd, cpu, space, source,
                                      virt_addr, nr_bytes);
    }
  base -= controller->attach_address;
  result = sim_core_write_buffer (sd, cpu,
				  io_map, source, base, nr_bytes);
  if (result > 0)
    return result;

  byte = 0;
  while (nr_bytes)
    {
      uint8 val;
      if (base >= controller->attach_size)
	break;

      val = *((uint8*) source);
      m68hc11cpu_io_write (me, cpu, base, val);
      source = (char*) source + 1;
      base++;
      byte++;
      nr_bytes--;
    }
  return byte;
}

const struct hw_descriptor dv_m68hc11_descriptor[] = {
  { "m68hc11", m68hc11cpu_finish },
  { "m68hc12", m68hc11cpu_finish },
  { NULL },
};

@


1.18
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 1
    Copyright (C) 1999-2003, 2007-2012 Free Software Foundation, Inc.
@


1.17
log
@run copyright.sh for 2011.
@
text
@d2 1
a2 2
    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2007, 2008, 2009, 2010, 2011
    Free Software Foundation, Inc.
@


1.17.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 1
    Copyright (C) 1999-2003, 2007-2012 Free Software Foundation, Inc.
@


1.16
log
@Update copyright notices to add year 2010.
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2007, 2008, 2009, 2010
@


1.15
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2007, 2008, 2009
@


1.14
log
@	Updated copyright notices for most files.
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2007, 2008
@


1.13
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2007
@


1.12
log
@Copyright updates for 2007.
@
text
@d9 1
a9 1
    the Free Software Foundation; either version 2 of the License, or
d11 1
a11 1
    
d16 1
a16 1
    
d18 1
a18 2
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@


1.11
log
@	* dv-m68hc11tim.c (cycle_to_string): Add flags parameter to better
	control the translation.
	(m68hc11tim_print_timer): Update cycle_to_string conversion.
	(m68hc11tim_timer_event): Fix handling of output
	compare register with its interrupts.
	(m68hc11tim_io_write_buffer): Check output compare
	after setting M6811_TMSK1.
	(m68hc11tim_io_read_buffer): Fix compilation warning.
	* dv-m68hc11.c (m68hc11_option_handler): Likewise.
	* dv-m68hc11spi.c (m68hc11spi_info): Likewise.
	* dv-m68hc11sio.c (m68hc11sio_info): Likewise.
	* interrupts.c (interrupts_info): Likewise.
	(interrupts_reset): Recognize bootstrap mode.
	* sim-main.h (PRINT_CYCLE, PRINT_TIME): New defines.
	(_sim_cpu): Add cpu_start_mode.
	(cycle_to_string): Add flags member.
	* m68hc11_sim.c (OPTION_CPU_BOOTSTRAP): New option.
	(cpu_options): Declare new option bootstrap.
	(cpu_option_handler): Handle it.
	(cpu_info): Update call to cycle_to_string.
@
text
@d2 2
a3 1
    Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
@


1.10
log
@	* sim-main.h (phys_to_virt): Use memory bank parameters to translate
	the physical address in virtual address.
	(struct _sim_cpu): Add memory bank members.
	* m68hc11_sim.c (cpu_initialize): Clear memory bank parameters.
	* interp.c (sim_hw_configure): Create memory bank according to memory
	bank parameters.
	(sim_get_bank_parameters): New function to obtain memory bank config
	from the symbol table.
	(sim_prepare_for_program): Call it to obtain the memory bank parameters.
	(sim_open): Call sim_prepare_for_program.
	* dv-m68hc11.c (m68hc11cpu_io_write_buffer): Use memory bank parameters
	to check if address is within bank window.
	(m68hc11cpu_io_read_buffer): Likewise.
	(attach_m68hc11_regs): Map the memory bank according to memory bank
	parameters.
@
text
@d811 2
a812 1
                               cycle_to_string (cpu, t));
d818 2
a819 1
                               cycle_to_string (cpu, t));
@


1.9
log
@	* dv-m68hc11.c (m68hc11cpu_io_read_buffer): Translate memory
	bank window to some virtual address to read from extended memory.
	(m68hc11cpu_io_write_buffer): Likewise for writing.
	(attach_m68hc11_regs): When use_bank property is defined, attached
	to the 68HC12 16K memory bank window.
	* interp.c (sim_hw_configure): Create memory region for banked
	memory.
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d327 2
a328 2
                       0x08000,
                       0x04000,
d846 1
a846 1
  if (base >= 0x8000 && base < 0xc000)
d867 1
a867 1
      dest++;
d1094 1
a1094 1
  if (base >= 0x8000 && base < 0xc000)
d1116 1
a1116 1
      source++;
@


1.9.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d327 2
a328 2
                       cpu->bank_start,
                       cpu->bank_end - cpu->bank_start,
d811 1
a811 2
                               cycle_to_string (cpu, t,
                                                PRINT_TIME | PRINT_CYCLE));
d817 1
a817 2
                               cycle_to_string (cpu, t,
                                                PRINT_TIME | PRINT_CYCLE));
d846 1
a846 1
  if (base >= cpu->bank_start && base < cpu->bank_end)
d867 1
a867 1
      dest = (char*) dest + 1;
d1094 1
a1094 1
  if (base >= cpu->bank_start && base < cpu->bank_end)
d1116 1
a1116 1
      source = (char*) source + 1;
@


1.9.8.1
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d327 2
a328 2
                       cpu->bank_start,
                       cpu->bank_end - cpu->bank_start,
d811 1
a811 2
                               cycle_to_string (cpu, t,
                                                PRINT_TIME | PRINT_CYCLE));
d817 1
a817 2
                               cycle_to_string (cpu, t,
                                                PRINT_TIME | PRINT_CYCLE));
d846 1
a846 1
  if (base >= cpu->bank_start && base < cpu->bank_end)
d867 1
a867 1
      dest = (char*) dest + 1;
d1094 1
a1094 1
  if (base >= cpu->bank_start && base < cpu->bank_end)
d1116 1
a1116 1
      source = (char*) source + 1;
@


1.9.44.1
log
@	* sim-main.h (phys_to_virt): Use memory bank parameters to translate
	the physical address in virtual address.
	(struct _sim_cpu): Add memory bank members.
	* m68hc11_sim.c (cpu_initialize): Clear memory bank parameters.
	* interp.c (sim_hw_configure): Create memory bank according to memory
	bank parameters.
	(sim_get_bank_parameters): New function to obtain memory bank config
	from the symbol table.
	(sim_prepare_for_program): Call it to obtain the memory bank parameters.
	(sim_open): Call sim_prepare_for_program.
	* dv-m68hc11.c (m68hc11cpu_io_write_buffer): Use memory bank parameters
	to check if address is within bank window.
	(m68hc11cpu_io_read_buffer): Likewise.
	(attach_m68hc11_regs): Map the memory bank according to memory bank
	parameters.
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d327 2
a328 2
                       cpu->bank_start,
                       cpu->bank_end - cpu->bank_start,
d846 1
a846 1
  if (base >= cpu->bank_start && base < cpu->bank_end)
d867 1
a867 1
      dest = (char*) dest + 1;
d1094 1
a1094 1
  if (base >= cpu->bank_start && base < cpu->bank_end)
d1116 1
a1116 1
      source = (char*) source + 1;
@


1.9.44.2
log
@	* dv-m68hc11tim.c (cycle_to_string): Add flags parameter to better
	control the translation.
	(m68hc11tim_print_timer): Update cycle_to_string conversion.
	(m68hc11tim_timer_event): Fix handling of output
	compare register with its interrupts.
	(m68hc11tim_io_write_buffer): Check output compare
	after setting M6811_TMSK1.
	(m68hc11tim_io_read_buffer): Fix compilation warning.
	* dv-m68hc11.c (m68hc11_option_handler): Likewise.
	* dv-m68hc11spi.c (m68hc11spi_info): Likewise.
	* dv-m68hc11sio.c (m68hc11sio_info): Likewise.
	* interrupts.c (interrupts_info): Likewise.
	(interrupts_reset): Recognize bootstrap mode.
	* sim-main.h (PRINT_CYCLE, PRINT_TIME): New defines.
	(_sim_cpu): Add cpu_start_mode.
	(cycle_to_string): Add flags member.
	* m68hc11_sim.c (OPTION_CPU_BOOTSTRAP): New option.
	(cpu_options): Declare new option bootstrap.
	(cpu_option_handler): Handle it.
	(cpu_info): Update call to cycle_to_string.
@
text
@d811 1
a811 2
                               cycle_to_string (cpu, t,
                                                PRINT_TIME | PRINT_CYCLE));
d817 1
a817 2
                               cycle_to_string (cpu, t,
                                                PRINT_TIME | PRINT_CYCLE));
@


1.8
log
@	* interp.c (sim_hw_configure): Connect port-X to cpu-write-port.
	* dv-m68hc11.c (m68hc11cpu_ports): Add cpu-write-port input.
	(m68hc11cpu_port_event): Handle CPU_WRITE_PORT event.
@
text
@d324 7
d846 8
d1093 8
@


1.7
log
@	* dv-m68hc11.c (m68hc11cpu_io_write): Fix to update IO mapping
	when IO mapping changed, not when internal RAM mapping is changed.
@
text
@d3 1
a3 1
    Written by Stephane Carrez (stcarrez@@worldnet.fr)
d27 1
d163 1
d183 2
d537 3
@


1.6
log
@	* m68hc11_sim.c (cpu_move8): Call sim_engine_abort in default case.
	(cpu_move16): Likewise.
	(sim_memory_error): Use sim_io_printf.
	(cpu_option_handler): Fix compilation warning.
	* interp.c (sim_hw_configure): Fix compilation warning;
	remove m68hc12sio@@2 device.
	(sim_open): Likewise.
	* dv-m68hc11tim.c (m68hc11tim_port_event): Fix clear of TFLG2
	flags when reset.
	(cycle_to_string): Improve convertion of cpu cycle number.
	(m68hc11tim_info): Print info about PACNT.
	(m68hc11tim_io_write_buffer): Fix clearing of TFLG2; handle
	TCTL1 and TCTL2 registers.
	* dv-m68hc11.c (m68hc11_info): Print 6811 current running mode.
@
text
@d1005 1
a1005 1
	if ((old_bank & 0xF0) != (val & 0xF0))
d1021 1
a1021 1
	if ((old_bank & 0x0F) != (val & 0x0F))
@


1.6.6.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d3 1
a3 1
    Written by Stephane Carrez (stcarrez@@nerim.fr)
a26 1
#include "hw-base.h"
a161 1
  CPU_WRITE_PORT,
a180 2
  { "cpu-write-port", CPU_WRITE_PORT,    0, input_port, },

a319 7
  if (hw_find_property (me, "use_bank") != NULL)
    hw_attach_address (hw_parent (me), 0,
                       exec_map,
                       0x08000,
                       0x04000,
                       me);

a534 3
    case CPU_WRITE_PORT:
      break;

a831 8
  if (base >= 0x8000 && base < 0xc000)
    {
      address_word virt_addr = phys_to_virt (cpu, base);
      if (virt_addr != base)
        return sim_core_read_buffer (sd, cpu, space, dest,
                                     virt_addr, nr_bytes);
    }

d1005 1
a1005 1
	if ((old_bank & 0x0F) != (val & 0x0F))
d1021 1
a1021 1
	if ((old_bank & 0xF0) != (val & 0xF0))
a1070 8

  if (base >= 0x8000 && base < 0xc000)
    {
      address_word virt_addr = phys_to_virt (cpu, base);
      if (virt_addr != base)
        return sim_core_write_buffer (sd, cpu, space, source,
                                      virt_addr, nr_bytes);
    }
@


1.5
log
@	* interp.c (sim_hw_configure): Save the HW cpu pointer in the
	cpu struct.
	(sim_hw_configure): Connect the capture input/output events.
	* sim-main.h (_sim_cpu): New member hw_cpu.
	(m68hc11cpu_set_oscillator): Declare.
	(m68hc11cpu_clear_oscillator): Declare.
	(m68hc11cpu_set_port): Declare.
	* dv-m68hc11.c (m68hc11_options): New for oscillator commands.
	(m68hc11cpu_ports): New input ports and output ports to reflect
	the HC11 IOs.
	(m68hc11_delete): Cleanup any running oscillator.
	(attach_m68hc11_regs): Create the input oscillators.
	(make_oscillator): New function.
	(find_oscillator): New function.
	(oscillator_handler): New function.
	(reset_oscillators): New function.
	(m68hc11cpu_port_event): Handle the new input ports.
	(m68hc11cpu_set_oscillator): New function.
	(m68hc11cpu_clear_oscillator): New function.
	(get_frequency): New function.
	(m68hc11_option_handler): New function.
	(m68hc11cpu_set_port): New function.
	(m68hc11cpu_io_write): Post the port output events.
	* dv-m68hc11spi.c (set_bit_port): Use m68hc11cpu_set_port to set
	the output port value.
	* dv-m68hc11tim.c (m68hc11tim_port_event): Handle CAPTURE event
	by latching the TCNT value in the register.
@
text
@d594 15
a608 1
  sim_io_printf (sd, "\n");
@


1.4
log
@Preliminary support for 68HC12
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000 Free Software Foundation, Inc.
d24 1
d26 2
d68 7
d80 9
d96 23
d120 11
d132 5
d146 2
d158 9
a166 1
  CPU_RESET_PORT
d177 4
d184 9
d205 5
d269 1
d332 31
d400 28
d430 51
d504 1
d522 4
d527 8
d624 174
d815 1
a815 1
  sd  = hw_system (me); 
d839 104
d951 1
d958 1
d962 1
d972 1
@


1.4.8.1
log
@	* interp.c (sim_hw_configure): Save the HW cpu pointer in the
	cpu struct.
	(sim_hw_configure): Connect the capture input/output events.
	* sim-main.h (_sim_cpu): New member hw_cpu.
	(m68hc11cpu_set_oscillator): Declare.
	(m68hc11cpu_clear_oscillator): Declare.
	(m68hc11cpu_set_port): Declare.
	* dv-m68hc11.c (m68hc11_options): New for oscillator commands.
	(m68hc11cpu_ports): New input ports and output ports to reflect
	the HC11 IOs.
	(m68hc11_delete): Cleanup any running oscillator.
	(attach_m68hc11_regs): Create the input oscillators.
	(make_oscillator): New function.
	(find_oscillator): New function.
	(oscillator_handler): New function.
	(reset_oscillators): New function.
	(m68hc11cpu_port_event): Handle the new input ports.
	(m68hc11cpu_set_oscillator): New function.
	(m68hc11cpu_clear_oscillator): New function.
	(get_frequency): New function.
	(m68hc11_option_handler): New function.
	(m68hc11cpu_set_port): New function.
	(m68hc11cpu_io_write): Post the port output events.
	* dv-m68hc11spi.c (set_bit_port): Use m68hc11cpu_set_port to set
	the output port value.
	* dv-m68hc11tim.c (m68hc11tim_port_event): Handle CAPTURE event
	by latching the TCNT value in the register.
@
text
@d2 1
a2 1
    Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
a23 1
#include "sim-hw.h"
a24 2
#include "sim-options.h"
#include <limits.h>
a64 7
   set-port-a (input)
   set-port-c (input)
   set-pord-d (input)

        Allow an external device to set the value of port A, C or D inputs.


a69 9
   port-a (output)
   port-b (output)
   port-c (output)
   port-d (output)

        Event generated when the value of the output port A, B, C or D
	changes.


a76 23
enum
{
  OPTION_OSC_SET = OPTION_START,
  OPTION_OSC_CLEAR,
  OPTION_OSC_INFO
};

static DECLARE_OPTION_HANDLER (m68hc11_option_handler);

static const OPTION m68hc11_options[] =
{
  { {"osc-set", required_argument, NULL, OPTION_OSC_SET },
      '\0', "BIT,FREQ", "Set the oscillator on input port BIT",
      m68hc11_option_handler },
  { {"osc-clear", required_argument, NULL, OPTION_OSC_CLEAR },
      '\0', "BIT", "Clear oscillator on input port BIT",
      m68hc11_option_handler },
  { {"osc-info", no_argument, NULL, OPTION_OSC_INFO },
      '\0', NULL, "Print information about current input oscillators",
      m68hc11_option_handler },
  
  { {NULL, no_argument, NULL, 0}, '\0', NULL, NULL, NULL }
};
a77 11
struct input_osc
{
  signed64         on_time;
  signed64         off_time;
  signed64         repeat;
  struct hw_event *event;
  const char      *name;
  uint8            mask;
  uint8            value;
  uint16           addr;
};
a78 5
#define NR_PORT_A_OSC (4)
#define NR_PORT_B_OSC (0)
#define NR_PORT_C_OSC (8)
#define NR_PORT_D_OSC (6)
#define NR_OSC (NR_PORT_A_OSC + NR_PORT_B_OSC + NR_PORT_C_OSC + NR_PORT_D_OSC)
a87 2
  int              last_oscillator;
  struct input_osc oscillators[NR_OSC];
d98 1
a98 9
  CPU_RESET_PORT,
  SET_PORT_A,
  SET_PORT_C,
  SET_PORT_D,
  PORT_A,
  PORT_B,
  PORT_C,
  PORT_D,
  CAPTURE
a108 4
  { "set-port-a", SET_PORT_A,    0, input_port, },
  { "set-port-c", SET_PORT_C,    0, input_port, },
  { "set-port-d", SET_PORT_D,    0, input_port, },

a111 9
  /* Events generated when the corresponding port is
     changed by the program.  */
  { "port-a",    PORT_A,         0, output_port, },
  { "port-b",    PORT_B,         0, output_port, },
  { "port-c",    PORT_C,         0, output_port, },
  { "port-d",    PORT_D,         0, output_port, },

  { "capture",   CAPTURE,        0, output_port, },

a123 5
static void make_oscillator (struct m68hc11cpu *controller,
                             const char *id, uint16 addr, uint8 mask);
static struct input_osc *find_oscillator (struct m68hc11cpu *controller,
                                          const char *id);
static void reset_oscillators (struct hw *me);
a182 1
  reset_oscillators (me);
a244 31

  controller->last_oscillator = 0;

  /* Create oscillators for input port A.  */
  make_oscillator (controller, "A7", M6811_PORTA, 0x80);
  make_oscillator (controller, "A2", M6811_PORTA, 0x04);
  make_oscillator (controller, "A1", M6811_PORTA, 0x02);
  make_oscillator (controller, "A0", M6811_PORTA, 0x01);

  /* port B is output only.  */

  /* Create oscillators for input port C.  */
  make_oscillator (controller, "C0", M6811_PORTC, 0x01);
  make_oscillator (controller, "C1", M6811_PORTC, 0x02);
  make_oscillator (controller, "C2", M6811_PORTC, 0x04);
  make_oscillator (controller, "C3", M6811_PORTC, 0x08);
  make_oscillator (controller, "C4", M6811_PORTC, 0x10);
  make_oscillator (controller, "C5", M6811_PORTC, 0x20);
  make_oscillator (controller, "C6", M6811_PORTC, 0x40);
  make_oscillator (controller, "C7", M6811_PORTC, 0x80);

  /* Create oscillators for input port D.  */
  make_oscillator (controller, "D0", M6811_PORTD, 0x01);
  make_oscillator (controller, "D1", M6811_PORTD, 0x02);
  make_oscillator (controller, "D2", M6811_PORTD, 0x04);
  make_oscillator (controller, "D3", M6811_PORTD, 0x08);
  make_oscillator (controller, "D4", M6811_PORTD, 0x10);
  make_oscillator (controller, "D5", M6811_PORTD, 0x20);

  /* Add oscillator commands.  */
  sim_add_option_table (sd, 0, m68hc11_options);
a281 28
static void
make_oscillator (struct m68hc11cpu *controller, const char *name,
                 uint16 addr, uint8 mask)
{
  struct input_osc *osc;

  if (controller->last_oscillator >= NR_OSC)
    hw_abort (0, "Too many oscillators");

  osc = &controller->oscillators[controller->last_oscillator];
  osc->name = name;
  osc->addr = addr;
  osc->mask = mask;
  controller->last_oscillator++;
}

/* Find the oscillator given the input port name.  */
static struct input_osc *
find_oscillator (struct m68hc11cpu *controller, const char *name)
{
  int i;

  for (i = 0; i < controller->last_oscillator; i++)
    if (strcasecmp (controller->oscillators[i].name, name) == 0)
      return &controller->oscillators[i];

  return 0;
}
a283 51
oscillator_handler (struct hw *me, void *data)
{
  struct input_osc *osc = (struct input_osc*) data;
  SIM_DESC sd;
  sim_cpu *cpu;
  signed64 dt;
  uint8 val;

  sd = hw_system (me);
  cpu = STATE_CPU (sd, 0);

  /* Change the input bit.  */
  osc->value ^= osc->mask;
  val = cpu->ios[osc->addr] & ~osc->mask;
  val |= osc->value;
  m68hc11cpu_set_port (me, cpu, osc->addr, val);

  /* Setup event to toggle the bit.  */
  if (osc->value)
    dt = osc->on_time;
  else
    dt = osc->off_time;

  if (dt && --osc->repeat >= 0)
    {
      sim_events *events = STATE_EVENTS (sd);

      dt += events->nr_ticks_to_process;
      osc->event = hw_event_queue_schedule (me, dt, oscillator_handler, osc);
    }
  else
    osc->event = 0;
}

static void
reset_oscillators (struct hw *me)
{
  struct m68hc11cpu *controller = hw_data (me);
  int i;

  for (i = 0; i < controller->last_oscillator; i++)
    {
      if (controller->oscillators[i].event)
        {
          hw_event_queue_deschedule (me, controller->oscillators[i].event);
          controller->oscillators[i].event = 0;
        }
    }
}
      
static void
a306 1
      reset_oscillators (me);
a323 4

    case SET_PORT_A:
      m68hc11cpu_set_port (me, cpu, M6811_PORTA, level);
      break;
a324 8
    case SET_PORT_C:
      m68hc11cpu_set_port (me, cpu, M6811_PORTC, level);
      break;

    case SET_PORT_D:
      m68hc11cpu_set_port (me, cpu, M6811_PORTD, level);
      break;

a413 174
/* Setup an oscillator on an input port.

   TON represents the time in seconds that the input port should be set to 1.
   TOFF is the time in seconds for the input port to be set to 0.

   The oscillator frequency is therefore 1 / (ton + toff).

   REPEAT indicates the number of 1 <-> 0 transitions until the oscillator
   stops.  */
int
m68hc11cpu_set_oscillator (SIM_DESC sd, const char *port,
                           double ton, double toff, signed64 repeat)
{
  sim_cpu *cpu;
  struct input_osc *osc;
  double f;

  cpu = STATE_CPU (sd, 0);

  /* Find oscillator that corresponds to the input port.  */
  osc = find_oscillator (hw_data (cpu->hw_cpu), port);
  if (osc == 0)
    return -1;

  /* Compute the ON time in cpu cycles.  */
  f = (double) (cpu->cpu_frequency) * ton;
  osc->on_time = (signed64) (f / 4.0);
  if (osc->on_time < 1)
    osc->on_time = 1;

  /* Compute the OFF time in cpu cycles.  */
  f = (double) (cpu->cpu_frequency) * toff;
  osc->off_time = (signed64) (f / 4.0);
  if (osc->off_time < 1)
    osc->off_time = 1;

  osc->repeat = repeat;
  if (osc->event)
    hw_event_queue_deschedule (cpu->hw_cpu, osc->event);

  osc->event = hw_event_queue_schedule (cpu->hw_cpu,
                                        osc->value ? osc->on_time
                                        : osc->off_time,
                                        oscillator_handler, osc);
  return 0;
}

/* Clear the oscillator.  */
int
m68hc11cpu_clear_oscillator (SIM_DESC sd, const char *port)
{
  sim_cpu *cpu;
  struct input_osc *osc;

  cpu = STATE_CPU (sd, 0);
  osc = find_oscillator (hw_data (cpu->hw_cpu), port);
  if (osc == 0)
    return -1;

  if (osc->event)
    hw_event_queue_deschedule (cpu->hw_cpu, osc->event);
  osc->event = 0;
  osc->repeat = 0;
  return 0;
}

static int
get_frequency (const char *s, double *f)
{
  char *p;
  
  *f = strtod (s, &p);
  if (s == p)
    return -1;

  if (*p)
    {
      if (strcasecmp (p, "khz") == 0)
        *f = *f * 1000.0;
      else if (strcasecmp (p, "mhz") == 0)
        *f = *f  * 1000000.0;
      else if (strcasecmp (p, "hz") != 0)
        return -1;
    }
  return 0;
}

static SIM_RC
m68hc11_option_handler (SIM_DESC sd, sim_cpu *cpu,
                        int opt, char *arg, int is_command)
{
  struct m68hc11cpu *controller;
  double f;
  char *p;
  int i;
  int title_printed = 0;
  
  if (cpu == 0)
    cpu = STATE_CPU (sd, 0);

  controller = hw_data (cpu->hw_cpu);
  switch (opt)
    {
    case OPTION_OSC_SET:
      p = strchr (arg, ',');
      if (p)
        *p++ = 0;

      if (p == 0)
        sim_io_eprintf (sd, "No frequency specified\n");
      else if (get_frequency (p, &f) < 0 || f < 1.0e-8)
        sim_io_eprintf (sd, "Invalid frequency: '%s'\n", p);
      else if (m68hc11cpu_set_oscillator (sd, arg,
                                          1.0 / (f * 2.0),
                                          1.0 / (f * 2.0), LONG_MAX))
        sim_io_eprintf (sd, "Invalid input port: '%s'\n", arg);
      break;

    case OPTION_OSC_CLEAR:
      if (m68hc11cpu_clear_oscillator (sd, arg) != 0)
        sim_io_eprintf (sd, "Invalid input port: '%s'\n", arg);
      break;

    case OPTION_OSC_INFO:
      for (i = 0; i < controller->last_oscillator; i++)
        {
          signed64 t;
          struct input_osc *osc;

          osc = &controller->oscillators[i];
          if (osc->event)
            {
              double f;
              int cur_value;
              int next_value;
              char freq[32];

              if (title_printed == 0)
                {
                  title_printed = 1;
                  sim_io_printf (sd, " PORT  Frequency   Current"
                                 "    Next    Transition time\n");
                }

              f = (double) (osc->on_time + osc->off_time);
              f = (double) (cpu->cpu_frequency / 4) / f;
              t = hw_event_remain_time (cpu->hw_cpu, osc->event);

              if (f > 10000.0)
                sprintf (freq, "%6.2f", f / 1000.0);
              else
                sprintf (freq, "%6.2f", f);
              cur_value = osc->value ? 1 : 0;
              next_value = osc->value ? 0 : 1;
              if (f > 10000.0)
                sim_io_printf (sd, " %4.4s  %8.8s khz"
                               "      %d       %d    %35.35s\n",
                               osc->name, freq,
                               cur_value, next_value,
                               cycle_to_string (cpu, t));
              else
                sim_io_printf (sd, " %4.4s  %8.8s hz "
                               "      %d       %d    %35.35s\n",
                               osc->name, freq,
                               cur_value, next_value,
                               cycle_to_string (cpu, t));
            }
        }
      break;      
    }

  return SIM_RC_OK;
}

d431 1
a431 1
  sd  = hw_system (me);
a454 104
void
m68hc11cpu_set_port (struct hw *me, sim_cpu *cpu,
                     unsigned addr, uint8 val)
{
  uint8 mask;
  uint8 delta;
  int check_interrupts = 0;
  int i;
  
  switch (addr)
    {
    case M6811_PORTA:
      if (cpu->ios[M6811_PACTL] & M6811_DDRA7)
        mask = 3;
      else
        mask = 0x83;

      val = val & mask;
      val |= cpu->ios[M6811_PORTA] & ~mask;
      delta = val ^ cpu->ios[M6811_PORTA];
      cpu->ios[M6811_PORTA] = val;
      if (delta & 0x80)
        {
          /* Pulse accumulator is enabled.  */
          if ((cpu->ios[M6811_PACTL] & M6811_PAEN)
              && !(cpu->ios[M6811_PACTL] & M6811_PAMOD))
            {
              int inc;

              /* Increment event counter according to rising/falling edge.  */
              if (cpu->ios[M6811_PACTL] & M6811_PEDGE)
                inc = (val & 0x80) ? 1 : 0;
              else
                inc = (val & 0x80) ? 0 : 1;

              cpu->ios[M6811_PACNT] += inc;

              /* Event counter overflowed.  */
              if (inc && cpu->ios[M6811_PACNT] == 0)
                {
                  cpu->ios[M6811_TFLG2] |= M6811_PAOVI;
                  check_interrupts = 1;
                }
            }
        }

      /* Scan IC3, IC2 and IC1.  Bit number is 3 - i.  */
      for (i = 0; i < 3; i++)
        {
          uint8 mask = (1 << i);
          
          if (delta & mask)
            {
              uint8 edge;
              int captured;

              edge = cpu->ios[M6811_TCTL2];
              edge = (edge >> (2 * i)) & 0x3;
              switch (edge)
                {
                case 0:
                  captured = 0;
                  break;
                case 1:
                  captured = (val & mask) != 0;
                  break;
                case 2:
                  captured = (val & mask) == 0;
                  break;
                default:
                  captured = 1;
                  break;
                }
              if (captured)
                {
                  cpu->ios[M6811_TFLG1] |= (1 << i);
                  hw_port_event (me, CAPTURE, M6811_TIC1 + 3 - i);
                  check_interrupts = 1;
                }
            }
        }
      break;

    case M6811_PORTC:
      mask = cpu->ios[M6811_DDRC];
      val = val & mask;
      val |= cpu->ios[M6811_PORTC] & ~mask;
      cpu->ios[M6811_PORTC] = val;
      break;

    case M6811_PORTD:
      mask = cpu->ios[M6811_DDRD];
      val = val & mask;
      val |= cpu->ios[M6811_PORTD] & ~mask;
      cpu->ios[M6811_PORTD] = val;
      break;

    default:
      break;
    }

  if (check_interrupts)
    interrupts_update_pending (&cpu->cpu_interrupts);
}
a462 1
      hw_port_event (me, PORT_A, val);
a468 1
      hw_port_event (me, PORT_C, val);
a471 1
      hw_port_event (me, PORT_B, val);
a480 1
      hw_port_event (me, PORT_D, val);
@


1.4.8.2
log
@	* m68hc11_sim.c (cpu_move8): Call sim_engine_abort in default case.
	(cpu_move16): Likewise.
	(sim_memory_error): Use sim_io_printf.
	(cpu_option_handler): Fix compilation warning.
	* interp.c (sim_hw_configure): Fix compilation warning;
	remove m68hc12sio@@2 device.
	(sim_open): Likewise.
	* dv-m68hc11tim.c (m68hc11tim_port_event): Fix clear of TFLG2
	flags when reset.
	(cycle_to_string): Improve convertion of cpu cycle number.
	(m68hc11tim_info): Print info about PACNT.
	(m68hc11tim_io_write_buffer): Fix clearing of TFLG2; handle
	TCTL1 and TCTL2 registers.
	* dv-m68hc11.c (m68hc11_info): Print 6811 current running mode.
@
text
@d594 1
a594 15
  switch (cpu->cpu_mode)
    {
    case M6811_MDA | M6811_SMOD:
      sim_io_printf (sd, "[test]\n");
      break;
    case M6811_SMOD:
      sim_io_printf (sd, "[bootstrap]\n");
      break;
    case M6811_MDA:
      sim_io_printf (sd, "[extended]\n");
      break;
    default:
      sim_io_printf (sd, "[single]\n");
      break;
    }
@


1.3
log
@Register a delete handler for 68HC11 core device node
@
text
@d1 1
a1 1
/*  dv-m68hc11.c -- CPU 68HC11 as a device.
d29 1
a29 1

d33 2
a34 2
        Implements the external m68hc11 functionality.  This includes the
        delivery of of interrupts generated from other devices and the
d42 1
a42 1
        Register base (should be 0x1000 0x03f).
a274 2


d443 1
a443 1
      if (base >= 0x3F)
d575 1
a575 1
      if (base >= 0x3F)
d589 2
a590 1
  { "m68hc11", m68hc11cpu_finish, },
@


1.2
log
@Use address mapping levels for 68hc11 simulator (kill overlap hack)
@
text
@d176 13
d219 1
a219 1

@


1.1
log
@New simulator.
@
text
@d201 1
a201 1
  hw_attach_address (hw_parent (me), 0,
a239 1
  me->overlap_mode_hw = 1;
d492 1
a492 1
            hw_detach_address (hw_parent (me), 0,
d498 1
a498 1
            hw_attach_address (hw_parent (me), 0,
@

