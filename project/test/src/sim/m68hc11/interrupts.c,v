head	1.14;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.14
	gdb_7_6-2013-04-26-release:1.14
	gdb_7_6-branch:1.14.0.2
	gdb_7_6-2013-03-12-branchpoint:1.14
	gdb_7_5_1-2012-11-29-release:1.13
	gdb_7_5-2012-08-17-release:1.13
	gdb_7_5-branch:1.13.0.2
	gdb_7_5-2012-07-18-branchpoint:1.13
	gdb_7_4_1-2012-04-26-release:1.12.4.1
	gdb_7_4-2012-01-24-release:1.12.4.1
	gdb_7_4-branch:1.12.0.4
	gdb_7_4-2011-12-13-branchpoint:1.12
	gdb_7_3_1-2011-09-04-release:1.12
	gdb_7_3-2011-07-26-release:1.12
	gdb_7_3-branch:1.12.0.2
	gdb_7_3-2011-04-01-branchpoint:1.12
	gdb_7_2-2010-09-02-release:1.11
	gdb_7_2-branch:1.11.0.4
	gdb_7_2-2010-07-07-branchpoint:1.11
	gdb_7_1-2010-03-18-release:1.11
	gdb_7_1-branch:1.11.0.2
	gdb_7_1-2010-02-18-branchpoint:1.11
	gdb_7_0_1-2009-12-22-release:1.10
	gdb_7_0-2009-10-06-release:1.10
	gdb_7_0-branch:1.10.0.4
	gdb_7_0-2009-09-16-branchpoint:1.10
	arc-sim-20090309:1.9
	msnyder-checkpoint-072509-branch:1.10.0.2
	msnyder-checkpoint-072509-branchpoint:1.10
	arc-insight_6_8-branch:1.9.0.16
	arc-insight_6_8-branchpoint:1.9
	insight_6_8-branch:1.9.0.14
	insight_6_8-branchpoint:1.9
	reverse-20081226-branch:1.9.0.12
	reverse-20081226-branchpoint:1.9
	multiprocess-20081120-branch:1.9.0.10
	multiprocess-20081120-branchpoint:1.9
	reverse-20080930-branch:1.9.0.8
	reverse-20080930-branchpoint:1.9
	reverse-20080717-branch:1.9.0.6
	reverse-20080717-branchpoint:1.9
	msnyder-reverse-20080609-branch:1.9.0.4
	msnyder-reverse-20080609-branchpoint:1.9
	drow-reverse-20070409-branch:1.7.0.2
	drow-reverse-20070409-branchpoint:1.7
	gdb_6_8-2008-03-27-release:1.9
	gdb_6_8-branch:1.9.0.2
	gdb_6_8-2008-02-26-branchpoint:1.9
	gdb_6_7_1-2007-10-29-release:1.8
	gdb_6_7-2007-10-10-release:1.8
	gdb_6_7-branch:1.8.0.2
	gdb_6_7-2007-09-07-branchpoint:1.8
	insight_6_6-20070208-release:1.6
	gdb_6_6-2006-12-18-release:1.6
	gdb_6_6-branch:1.6.0.54
	gdb_6_6-2006-11-15-branchpoint:1.6
	insight_6_5-20061003-release:1.6
	gdb-csl-symbian-6_4_50_20060226-12:1.6
	gdb-csl-sourcerygxx-3_4_4-25:1.6
	nickrob-async-20060828-mergepoint:1.6
	gdb-csl-symbian-6_4_50_20060226-11:1.6
	gdb-csl-sourcerygxx-4_1-17:1.6
	gdb-csl-20060226-branch-local-2:1.6
	gdb-csl-sourcerygxx-4_1-14:1.6
	gdb-csl-sourcerygxx-4_1-13:1.6
	gdb-csl-sourcerygxx-4_1-12:1.6
	gdb-csl-sourcerygxx-3_4_4-21:1.6
	gdb_6_5-20060621-release:1.6
	gdb-csl-sourcerygxx-4_1-9:1.6
	gdb-csl-sourcerygxx-4_1-8:1.6
	gdb-csl-sourcerygxx-4_1-7:1.6
	gdb-csl-arm-2006q1-6:1.6
	gdb-csl-sourcerygxx-4_1-6:1.6
	gdb-csl-symbian-6_4_50_20060226-10:1.6
	gdb-csl-symbian-6_4_50_20060226-9:1.6
	gdb-csl-symbian-6_4_50_20060226-8:1.6
	gdb-csl-coldfire-4_1-11:1.6
	gdb-csl-sourcerygxx-3_4_4-19:1.6
	gdb-csl-coldfire-4_1-10:1.6
	gdb_6_5-branch:1.6.0.52
	gdb_6_5-2006-05-14-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-5:1.6
	nickrob-async-20060513-branch:1.6.0.50
	nickrob-async-20060513-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-4:1.6
	msnyder-reverse-20060502-branch:1.6.0.48
	msnyder-reverse-20060502-branchpoint:1.6
	gdb-csl-morpho-4_1-4:1.6
	gdb-csl-sourcerygxx-3_4_4-17:1.6
	readline_5_1-import-branch:1.6.0.46
	readline_5_1-import-branchpoint:1.6
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.6
	gdb-csl-symbian-20060226-branch:1.6.0.44
	gdb-csl-symbian-20060226-branchpoint:1.6
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.6
	msnyder-reverse-20060331-branch:1.6.0.42
	msnyder-reverse-20060331-branchpoint:1.6
	gdb-csl-available-20060303-branch:1.6.0.40
	gdb-csl-available-20060303-branchpoint:1.6
	gdb-csl-20060226-branch:1.6.0.38
	gdb-csl-20060226-branchpoint:1.6
	gdb_6_4-20051202-release:1.6
	msnyder-fork-checkpoint-branch:1.6.0.36
	msnyder-fork-checkpoint-branchpoint:1.6
	gdb-csl-gxxpro-6_3-branch:1.6.0.34
	gdb-csl-gxxpro-6_3-branchpoint:1.6
	gdb_6_4-branch:1.6.0.32
	gdb_6_4-2005-11-01-branchpoint:1.6
	gdb-csl-arm-20051020-branch:1.6.0.30
	gdb-csl-arm-20051020-branchpoint:1.6
	msnyder-tracepoint-checkpoint-branch:1.6.0.28
	msnyder-tracepoint-checkpoint-branchpoint:1.6
	gdb-csl-arm-20050325-2005-q1b:1.6
	gdb-csl-arm-20050325-2005-q1a:1.6
	csl-arm-20050325-branch:1.6.0.26
	csl-arm-20050325-branchpoint:1.6
	gdb_6_3-20041109-release:1.6
	gdb_6_3-branch:1.6.0.22
	gdb_6_3-20041019-branchpoint:1.6
	drow_intercu-merge-20040921:1.6
	drow_intercu-merge-20040915:1.6
	jimb-gdb_6_2-e500-branch:1.6.0.24
	jimb-gdb_6_2-e500-branchpoint:1.6
	gdb_6_2-20040730-release:1.6
	gdb_6_2-branch:1.6.0.20
	gdb_6_2-2004-07-10-gmt-branchpoint:1.6
	gdb_6_1_1-20040616-release:1.6
	gdb_6_1-2004-04-05-release:1.6
	drow_intercu-merge-20040402:1.6
	drow_intercu-merge-20040327:1.6
	ezannoni_pie-20040323-branch:1.6.0.18
	ezannoni_pie-20040323-branchpoint:1.6
	cagney_tramp-20040321-mergepoint:1.6
	cagney_tramp-20040309-branch:1.6.0.16
	cagney_tramp-20040309-branchpoint:1.6
	gdb_6_1-branch:1.6.0.14
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	drow_intercu-20040221-branch:1.6.0.12
	drow_intercu-20040221-branchpoint:1.6
	cagney_bfdfile-20040213-branch:1.6.0.10
	cagney_bfdfile-20040213-branchpoint:1.6
	drow-cplus-merge-20040208:1.6
	carlton_dictionary-20040126-merge:1.6
	cagney_bigcore-20040122-branch:1.6.0.8
	cagney_bigcore-20040122-branchpoint:1.6
	drow-cplus-merge-20040113:1.6
	drow-cplus-merge-20031224:1.6
	drow-cplus-merge-20031220:1.6
	carlton_dictionary-20031215-merge:1.6
	drow-cplus-merge-20031214:1.6
	carlton-dictionary-20031111-merge:1.6
	gdb_6_0-2003-10-04-release:1.5.50.1
	kettenis_sparc-20030918-branch:1.6.0.6
	kettenis_sparc-20030918-branchpoint:1.6
	carlton_dictionary-20030917-merge:1.6
	ezannoni_pie-20030916-branchpoint:1.6
	ezannoni_pie-20030916-branch:1.6.0.4
	cagney_x86i386-20030821-branch:1.6.0.2
	cagney_x86i386-20030821-branchpoint:1.6
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.50
	gdb_6_0-2003-06-23-branchpoint:1.5
	jimb-ppc64-linux-20030613-branch:1.5.0.48
	jimb-ppc64-linux-20030613-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.46
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.44
	cagney_writestrings-20030508-branchpoint:1.5
	jimb-ppc64-linux-20030528-branch:1.5.0.42
	jimb-ppc64-linux-20030528-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.40
	cagney_fileio-20030521-branchpoint:1.5
	kettenis_i386newframe-20030517-mergepoint:1.5
	jimb-ppc64-linux-20030509-branch:1.5.0.38
	jimb-ppc64-linux-20030509-branchpoint:1.5
	kettenis_i386newframe-20030504-mergepoint:1.5
	carlton_dictionary-20030430-merge:1.5
	kettenis_i386newframe-20030419-branch:1.5.0.36
	kettenis_i386newframe-20030419-branchpoint:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	kettenis_i386newframe-20030406-branch:1.5.0.34
	kettenis_i386newframe-20030406-branchpoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.32
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.30
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.28
	cagney_lazyid-20030317-branchpoint:1.5
	kettenis-i386newframe-20030316-mergepoint:1.5
	offbyone-20030313-branch:1.5.0.26
	offbyone-20030313-branchpoint:1.5
	kettenis-i386newframe-20030308-branch:1.5.0.24
	kettenis-i386newframe-20030308-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.22
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.20
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.18
	cagney-unwind-20030108-branchpoint:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.5
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.16
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.14
	carlton_dictionary-20020920-branchpoint:1.5
	gdb_5_3-branch:1.5.0.12
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.10
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.8
	readline_4_3-import-branchpoint:1.5
	gdb_5_2_1-2002-07-23-release:1.4.8.1
	kseitz_interps-20020528-branch:1.5.0.6
	kseitz_interps-20020528-branchpoint:1.5
	cagney_regbuf-20020515-branch:1.5.0.4
	cagney_regbuf-20020515-branchpoint:1.5
	jimb-macro-020506-branch:1.5.0.2
	jimb-macro-020506-branchpoint:1.5
	gdb_5_2-2002-04-29-release:1.4.8.1
	gdb_5_2-branch:1.4.0.8
	gdb_5_2-2002-03-03-branchpoint:1.4
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	insight-precleanup-2001-01-01:1.3;
locks; strict;
comment	@ * @;


1.14
date	2013.01.01.06.41.38;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2012.01.04.08.28.14;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2011.01.01.15.34.02;	author brobecke;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2010.01.01.10.03.31;	author brobecke;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.14.10.53.08;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2008.01.01.22.53.25;	author drow;	state Exp;
branches;
next	1.8;

1.8
date	2007.08.24.14.28.37;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.09.17.59.18;	author drow;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.08.21.02.24;	author ciceron;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.07.18.59.38;	author ciceron;	state Exp;
branches
	1.5.14.1
	1.5.16.1
	1.5.50.1;
next	1.4;

1.4
date	2001.05.20.15.36.29;	author ciceron;	state Exp;
branches
	1.4.8.1;
next	1.3;

1.3
date	2000.09.10.12.58.53;	author ciceron;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.09.21.00.39;	author ciceron;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.27.11.23.39;	author cagney;	state Exp;
branches;
next	;

1.12.4.1
date	2012.01.06.04.54.53;	author brobecke;	state Exp;
branches;
next	;

1.5.14.1
date	2003.09.17.21.29.03;	author carlton;	state Exp;
branches;
next	;

1.5.16.1
date	2003.12.14.20.28.27;	author drow;	state Exp;
branches;
next	;

1.5.50.1
date	2003.08.08.21.04.44;	author ciceron;	state Exp;
branches;
next	;

1.4.8.1
date	2002.03.07.19.02.18;	author ciceron;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* interrupts.c -- 68HC11 Interrupts Emulation
   Copyright 1999-2013 Free Software Foundation, Inc.
   Written by Stephane Carrez (stcarrez@@nerim.fr)

This file is part of GDB, GAS, and the GNU binutils.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "sim-main.h"
#include "sim-options.h"

static const char *interrupt_names[] = {
  "R1",
  "R2",
  "R3",
  "R4",
  "R5",
  "R6",
  "R7",
  "R8",
  "R9",
  "R10",
  "R11",

  "SCI",
  "SPI",
  "AINPUT",
  "AOVERFLOW",
  "TOVERFLOW",
  "OUT5",
  "OUT4",
  "OUT3",
  "OUT2",
  "OUT1",
  "INC3",
  "INC2",
  "INC1",
  "RT",
  "IRQ",
  "XIRQ",
  "SWI",
  "ILL",
  "COPRESET",
  "COPFAIL",
  "RESET"
};

struct interrupt_def idefs[] = {
  /* Serial interrupts.  */
  { M6811_INT_SCI,      M6811_SCSR,   M6811_TDRE,  M6811_SCCR2,  M6811_TIE },
  { M6811_INT_SCI,      M6811_SCSR,   M6811_TC,    M6811_SCCR2,  M6811_TCIE },
  { M6811_INT_SCI,      M6811_SCSR,   M6811_RDRF,  M6811_SCCR2,  M6811_RIE },
  { M6811_INT_SCI,      M6811_SCSR,   M6811_IDLE,  M6811_SCCR2,  M6811_ILIE },

  /* SPI interrupts.  */
  { M6811_INT_SPI,      M6811_SPSR,   M6811_SPIF,  M6811_SPCR,   M6811_SPIE },

  /* Realtime interrupts.  */
  { M6811_INT_TCTN,     M6811_TFLG2,  M6811_TOF,   M6811_TMSK2,  M6811_TOI },
  { M6811_INT_RT,       M6811_TFLG2,  M6811_RTIF,  M6811_TMSK2,  M6811_RTII },

  /* Output compare interrupts.  */
  { M6811_INT_OUTCMP1,  M6811_TFLG1,  M6811_OC1F,  M6811_TMSK1,  M6811_OC1I },
  { M6811_INT_OUTCMP2,  M6811_TFLG1,  M6811_OC2F,  M6811_TMSK1,  M6811_OC2I },
  { M6811_INT_OUTCMP3,  M6811_TFLG1,  M6811_OC3F,  M6811_TMSK1,  M6811_OC3I },
  { M6811_INT_OUTCMP4,  M6811_TFLG1,  M6811_OC4F,  M6811_TMSK1,  M6811_OC4I },
  { M6811_INT_OUTCMP5,  M6811_TFLG1,  M6811_OC5F,  M6811_TMSK1,  M6811_OC5I },

  /* Input compare interrupts.  */
  { M6811_INT_INCMP1,   M6811_TFLG1,  M6811_IC1F,  M6811_TMSK1,  M6811_IC1I },
  { M6811_INT_INCMP2,   M6811_TFLG1,  M6811_IC2F,  M6811_TMSK1,  M6811_IC2I },
  { M6811_INT_INCMP3,   M6811_TFLG1,  M6811_IC3F,  M6811_TMSK1,  M6811_IC3I },

  /* Pulse accumulator.  */
  { M6811_INT_AINPUT,   M6811_TFLG2,  M6811_PAIF,  M6811_TMSK2,  M6811_PAII },
  { M6811_INT_AOVERFLOW,M6811_TFLG2,  M6811_PAOVF, M6811_TMSK2,  M6811_PAOVI},
#if 0
  { M6811_INT_COPRESET, M6811_CONFIG, M6811_NOCOP, 0,            0 },
  { M6811_INT_COPFAIL,  M6811_CONFIG, M6811_NOCOP, 0,            0 }
#endif
};

#define TableSize(X) (sizeof X / sizeof(X[0]))
#define CYCLES_MAX ((((signed64) 1) << 62) - 1)

enum
{
  OPTION_INTERRUPT_INFO = OPTION_START,
  OPTION_INTERRUPT_CATCH,
  OPTION_INTERRUPT_CLEAR
};

static DECLARE_OPTION_HANDLER (interrupt_option_handler);

static const OPTION interrupt_options[] =
{
  { {"interrupt-info", no_argument, NULL, OPTION_INTERRUPT_INFO },
      '\0', NULL, "Print information about interrupts",
      interrupt_option_handler },
  { {"interrupt-catch", required_argument, NULL, OPTION_INTERRUPT_CATCH },
      '\0', "NAME[,MODE]",
    "Catch interrupts when they are raised or taken\n"
    "NAME   Name of the interrupt\n"
    "MODE   Optional mode (`taken' or `raised')",
      interrupt_option_handler },
  { {"interrupt-clear", required_argument, NULL, OPTION_INTERRUPT_CLEAR },
      '\0', "NAME", "No longer catch the interrupt",
      interrupt_option_handler },
  
  { {NULL, no_argument, NULL, 0}, '\0', NULL, NULL, NULL }
};

/* Initialize the interrupts module.  */
void
interrupts_initialize (SIM_DESC sd, struct _sim_cpu *proc)
{
  struct interrupts *interrupts = &proc->cpu_interrupts;
  
  interrupts->cpu          = proc;

  sim_add_option_table (sd, 0, interrupt_options);
}

/* Initialize the interrupts of the processor.  */
void
interrupts_reset (struct interrupts *interrupts)
{
  int i;
  
  interrupts->pending_mask = 0;
  if (interrupts->cpu->cpu_mode & M6811_SMOD)
    interrupts->vectors_addr = 0xbfc0;
  else
    interrupts->vectors_addr = 0xffc0;
  interrupts->nb_interrupts_raised = 0;
  interrupts->min_mask_cycles = CYCLES_MAX;
  interrupts->max_mask_cycles = 0;
  interrupts->last_mask_cycles = 0;
  interrupts->start_mask_cycle = -1;
  interrupts->xirq_start_mask_cycle = -1;
  interrupts->xirq_max_mask_cycles = 0;
  interrupts->xirq_min_mask_cycles = CYCLES_MAX;
  interrupts->xirq_last_mask_cycles = 0;
  
  for (i = 0; i < M6811_INT_NUMBER; i++)
    {
      interrupts->interrupt_order[i] = i;
    }

  /* Clear the interrupt history table.  */
  interrupts->history_index = 0;
  memset (interrupts->interrupts_history, 0,
          sizeof (interrupts->interrupts_history));

  memset (interrupts->interrupts, 0,
          sizeof (interrupts->interrupts));

  /* In bootstrap mode, initialize the vector table to point
     to the RAM location.  */
  if (interrupts->cpu->cpu_mode == M6811_SMOD)
    {
      bfd_vma addr = interrupts->vectors_addr;
      uint16 vector = 0x0100 - 3 * (M6811_INT_NUMBER - 1);
      for (i = 0; i < M6811_INT_NUMBER; i++)
        {
          memory_write16 (interrupts->cpu, addr, vector);
          addr += 2;
          vector += 3;
        }
    }
}

static int
find_interrupt (const char *name)
{
  int i;

  if (name)
    for (i = 0; i < M6811_INT_NUMBER; i++)
      if (strcasecmp (name, interrupt_names[i]) == 0)
        return i;

  return -1;
}

static SIM_RC
interrupt_option_handler (SIM_DESC sd, sim_cpu *cpu,
                          int opt, char *arg, int is_command)
{
  char *p;
  int mode;
  int id;
  struct interrupts *interrupts;

  if (cpu == 0)
    cpu = STATE_CPU (sd, 0);

  interrupts = &cpu->cpu_interrupts;
  switch (opt)
    {
    case OPTION_INTERRUPT_INFO:
      for (id = 0; id < M6811_INT_NUMBER; id++)
        {
          sim_io_eprintf (sd, "%-10.10s ", interrupt_names[id]);
          switch (interrupts->interrupts[id].stop_mode)
            {
            case SIM_STOP_WHEN_RAISED:
              sim_io_eprintf (sd, "catch raised ");
              break;

            case SIM_STOP_WHEN_TAKEN:
              sim_io_eprintf (sd, "catch taken  ");
              break;

            case SIM_STOP_WHEN_RAISED | SIM_STOP_WHEN_TAKEN:
              sim_io_eprintf (sd, "catch all    ");
              break;

            default:
              sim_io_eprintf (sd, "             ");
              break;
            }
          sim_io_eprintf (sd, "%ld\n",
                          interrupts->interrupts[id].raised_count);
        }
      break;

    case OPTION_INTERRUPT_CATCH:
      p = strchr (arg, ',');
      if (p)
        *p++ = 0;

      mode = SIM_STOP_WHEN_RAISED;
      id = find_interrupt (arg);
      if (id < 0)
        sim_io_eprintf (sd, "Interrupt name not recognized: %s\n", arg);

      if (p && strcasecmp (p, "raised") == 0)
        mode = SIM_STOP_WHEN_RAISED;
      else if (p && strcasecmp (p, "taken") == 0)
        mode = SIM_STOP_WHEN_TAKEN;
      else if (p && strcasecmp (p, "all") == 0)
        mode = SIM_STOP_WHEN_RAISED | SIM_STOP_WHEN_TAKEN;
      else if (p)
        {
          sim_io_eprintf (sd, "Invalid argument: %s\n", p);
          break;
        }
      if (id >= 0)
        interrupts->interrupts[id].stop_mode = mode;
      break;

    case OPTION_INTERRUPT_CLEAR:
      mode = SIM_STOP_WHEN_RAISED;
      id = find_interrupt (arg);
      if (id < 0)
        sim_io_eprintf (sd, "Interrupt name not recognized: %s\n", arg);
      else
        interrupts->interrupts[id].stop_mode = 0;      
      break;      
    }

  return SIM_RC_OK;
}

/* Update the mask of pending interrupts.  This operation must be called
   when the state of some 68HC11 IO register changes.  It looks the
   different registers that indicate a pending interrupt (timer, SCI, SPI,
   ...) and records the interrupt if it's there and enabled.  */
void
interrupts_update_pending (struct interrupts *interrupts)
{
  int i;
  uint8 *ioregs;
  unsigned long clear_mask;
  unsigned long set_mask;

  clear_mask = 0;
  set_mask = 0;
  ioregs = &interrupts->cpu->ios[0];
  
  for (i = 0; i < TableSize(idefs); i++)
    {
      struct interrupt_def *idef = &idefs[i];
      uint8 data;
      
      /* Look if the interrupt is enabled.  */
      if (idef->enable_paddr)
	{
	  data = ioregs[idef->enable_paddr];
	  if (!(data & idef->enabled_mask))
            {
              /* Disable it.  */
              clear_mask |= (1 << idef->int_number);
              continue;
            }
	}

      /* Interrupt is enabled, see if it's there.  */
      data = ioregs[idef->int_paddr];
      if (!(data & idef->int_mask))
        {
          /* Disable it.  */
          clear_mask |= (1 << idef->int_number);
          continue;
        }

      /* Ok, raise it.  */
      set_mask |= (1 << idef->int_number);
    }

  /* Some interrupts are shared (M6811_INT_SCI) so clear
     the interrupts before setting the new ones.  */
  interrupts->pending_mask &= ~clear_mask;
  interrupts->pending_mask |= set_mask;

  /* Keep track of when the interrupt is raised by the device.
     Also implements the breakpoint-on-interrupt.  */
  if (set_mask)
    {
      signed64 cycle = cpu_current_cycle (interrupts->cpu);
      int must_stop = 0;
      
      for (i = 0; i < M6811_INT_NUMBER; i++)
        {
          if (!(set_mask & (1 << i)))
            continue;

          interrupts->interrupts[i].cpu_cycle = cycle;
          if (interrupts->interrupts[i].stop_mode & SIM_STOP_WHEN_RAISED)
            {
              must_stop = 1;
              sim_io_printf (CPU_STATE (interrupts->cpu),
                             "Interrupt %s raised\n",
                             interrupt_names[i]);
            }
        }
      if (must_stop)
        sim_engine_halt (CPU_STATE (interrupts->cpu),
                         interrupts->cpu,
                         0, cpu_get_pc (interrupts->cpu),
                         sim_stopped,
                         SIM_SIGTRAP);
    }
}


/* Finds the current active and non-masked interrupt.
   Returns the interrupt number (index in the vector table) or -1
   if no interrupt can be serviced.  */
int
interrupts_get_current (struct interrupts *interrupts)
{
  int i;
  
  if (interrupts->pending_mask == 0)
    return -1;

  /* SWI and illegal instructions are simulated by an interrupt.
     They are not maskable.  */
  if (interrupts->pending_mask & (1 << M6811_INT_SWI))
    {
      interrupts->pending_mask &= ~(1 << M6811_INT_SWI);
      return M6811_INT_SWI;
    }
  if (interrupts->pending_mask & (1 << M6811_INT_ILLEGAL))
    {
      interrupts->pending_mask &= ~(1 << M6811_INT_ILLEGAL);
      return M6811_INT_ILLEGAL;
    }
  
  /* If there is a non maskable interrupt, go for it (unless we are masked
     by the X-bit.  */
  if (interrupts->pending_mask & (1 << M6811_INT_XIRQ))
    {
      if (cpu_get_ccr_X (interrupts->cpu) == 0)
	{
	  interrupts->pending_mask &= ~(1 << M6811_INT_XIRQ);
	  return M6811_INT_XIRQ;
	}
      return -1;
    }

  /* Interrupts are masked, do nothing.  */
  if (cpu_get_ccr_I (interrupts->cpu) == 1)
    {
      return -1;
    }

  /* Returns the first interrupt number which is pending.
     The interrupt priority is specified by the table `interrupt_order'.
     For these interrupts, the pending mask is cleared when the program
     performs some actions on the corresponding device.  If the device
     is not reset, the interrupt remains and will be re-raised when
     we return from the interrupt (see 68HC11 pink book).  */
  for (i = 0; i < M6811_INT_NUMBER; i++)
    {
      enum M6811_INT int_number = interrupts->interrupt_order[i];

      if (interrupts->pending_mask & (1 << int_number))
	{
	  return int_number;
	}
    }
  return -1;
}


/* Process the current interrupt if there is one.  This operation must
   be called after each instruction to handle the interrupts.  If interrupts
   are masked, it does nothing.  */
int
interrupts_process (struct interrupts *interrupts)
{
  int id;
  uint8 ccr;

  /* See if interrupts are enabled/disabled and keep track of the
     number of cycles the interrupts are masked.  Such information is
     then reported by the info command.  */
  ccr = cpu_get_ccr (interrupts->cpu);
  if (ccr & M6811_I_BIT)
    {
      if (interrupts->start_mask_cycle < 0)
        interrupts->start_mask_cycle = cpu_current_cycle (interrupts->cpu);
    }
  else if (interrupts->start_mask_cycle >= 0
           && (ccr & M6811_I_BIT) == 0)
    {
      signed64 t = cpu_current_cycle (interrupts->cpu);

      t -= interrupts->start_mask_cycle;
      if (t < interrupts->min_mask_cycles)
        interrupts->min_mask_cycles = t;
      if (t > interrupts->max_mask_cycles)
        interrupts->max_mask_cycles = t;
      interrupts->start_mask_cycle = -1;
      interrupts->last_mask_cycles = t;
    }
  if (ccr & M6811_X_BIT)
    {
      if (interrupts->xirq_start_mask_cycle < 0)
        interrupts->xirq_start_mask_cycle
	  = cpu_current_cycle (interrupts->cpu);
    }
  else if (interrupts->xirq_start_mask_cycle >= 0
           && (ccr & M6811_X_BIT) == 0)
    {
      signed64 t = cpu_current_cycle (interrupts->cpu);

      t -= interrupts->xirq_start_mask_cycle;
      if (t < interrupts->xirq_min_mask_cycles)
        interrupts->xirq_min_mask_cycles = t;
      if (t > interrupts->xirq_max_mask_cycles)
        interrupts->xirq_max_mask_cycles = t;
      interrupts->xirq_start_mask_cycle = -1;
      interrupts->xirq_last_mask_cycles = t;
    }

  id = interrupts_get_current (interrupts);
  if (id >= 0)
    {
      uint16 addr;
      struct interrupt_history *h;

      /* Implement the breakpoint-on-interrupt.  */
      if (interrupts->interrupts[id].stop_mode & SIM_STOP_WHEN_TAKEN)
        {
          sim_io_printf (CPU_STATE (interrupts->cpu),
                         "Interrupt %s will be handled\n",
                         interrupt_names[id]);
          sim_engine_halt (CPU_STATE (interrupts->cpu),
                           interrupts->cpu,
                           0, cpu_get_pc (interrupts->cpu),
                           sim_stopped,
                           SIM_SIGTRAP);
        }

      cpu_push_all (interrupts->cpu);
      addr = memory_read16 (interrupts->cpu,
                            interrupts->vectors_addr + id * 2);
      cpu_call (interrupts->cpu, addr);

      /* Now, protect from nested interrupts.  */
      if (id == M6811_INT_XIRQ)
	{
	  cpu_set_ccr_X (interrupts->cpu, 1);
	}
      else
	{
	  cpu_set_ccr_I (interrupts->cpu, 1);
	}

      /* Update the interrupt history table.  */
      h = &interrupts->interrupts_history[interrupts->history_index];
      h->type = id;
      h->taken_cycle = cpu_current_cycle (interrupts->cpu);
      h->raised_cycle = interrupts->interrupts[id].cpu_cycle;
      
      if (interrupts->history_index >= MAX_INT_HISTORY-1)
        interrupts->history_index = 0;
      else
        interrupts->history_index++;

      interrupts->nb_interrupts_raised++;
      cpu_add_cycles (interrupts->cpu, 14);
      return 1;
    }
  return 0;
}

void
interrupts_raise (struct interrupts *interrupts, enum M6811_INT number)
{
  interrupts->pending_mask |= (1 << number);
  interrupts->nb_interrupts_raised ++;
}

void
interrupts_info (SIM_DESC sd, struct interrupts *interrupts)
{
  signed64 t, prev_interrupt;
  int i;
  
  sim_io_printf (sd, "Interrupts Info:\n");
  sim_io_printf (sd, "  Interrupts raised: %lu\n",
                 interrupts->nb_interrupts_raised);

  if (interrupts->start_mask_cycle >= 0)
    {
      t = cpu_current_cycle (interrupts->cpu);

      t -= interrupts->start_mask_cycle;
      if (t > interrupts->max_mask_cycles)
        interrupts->max_mask_cycles = t;

      sim_io_printf (sd, "  Current interrupts masked sequence:   %s\n",
                     cycle_to_string (interrupts->cpu, t,
                                      PRINT_TIME | PRINT_CYCLE));
    }
  t = interrupts->min_mask_cycles == CYCLES_MAX ?
    interrupts->max_mask_cycles :
    interrupts->min_mask_cycles;
  sim_io_printf (sd, "  Shortest interrupts masked sequence:  %s\n",
                 cycle_to_string (interrupts->cpu, t,
                                  PRINT_TIME | PRINT_CYCLE));

  t = interrupts->max_mask_cycles;
  sim_io_printf (sd, "  Longest interrupts masked sequence:   %s\n",
                 cycle_to_string (interrupts->cpu, t,
                                  PRINT_TIME | PRINT_CYCLE));

  t = interrupts->last_mask_cycles;
  sim_io_printf (sd, "  Last interrupts masked sequence:      %s\n",
                 cycle_to_string (interrupts->cpu, t,
                                  PRINT_TIME | PRINT_CYCLE));
  
  if (interrupts->xirq_start_mask_cycle >= 0)
    {
      t = cpu_current_cycle (interrupts->cpu);

      t -= interrupts->xirq_start_mask_cycle;
      if (t > interrupts->xirq_max_mask_cycles)
        interrupts->xirq_max_mask_cycles = t;

      sim_io_printf (sd, "  XIRQ Current interrupts masked sequence: %s\n",
                     cycle_to_string (interrupts->cpu, t,
                                      PRINT_TIME | PRINT_CYCLE));
    }

  t = interrupts->xirq_min_mask_cycles == CYCLES_MAX ?
    interrupts->xirq_max_mask_cycles :
    interrupts->xirq_min_mask_cycles;
  sim_io_printf (sd, "  XIRQ Min interrupts masked sequence:  %s\n",
                 cycle_to_string (interrupts->cpu, t,
                                  PRINT_TIME | PRINT_CYCLE));

  t = interrupts->xirq_max_mask_cycles;
  sim_io_printf (sd, "  XIRQ Max interrupts masked sequence:  %s\n",
                 cycle_to_string (interrupts->cpu, t,
                                  PRINT_TIME | PRINT_CYCLE));

  t = interrupts->xirq_last_mask_cycles;
  sim_io_printf (sd, "  XIRQ Last interrupts masked sequence: %s\n",
                 cycle_to_string (interrupts->cpu, t,
                                  PRINT_TIME | PRINT_CYCLE));

  if (interrupts->pending_mask)
    {
      sim_io_printf (sd, "  Pending interrupts : ");
      for (i = 0; i < M6811_INT_NUMBER; i++)
        {
          enum M6811_INT int_number = interrupts->interrupt_order[i];
          
          if (interrupts->pending_mask & (1 << int_number))
            {
              sim_io_printf (sd, "%s ", interrupt_names[int_number]);
            }
        }
      sim_io_printf (sd, "\n");
    }

  prev_interrupt = 0;
  sim_io_printf (sd, "N  Interrupt     Cycle Taken         Latency"
                 "   Delta between interrupts\n");
  for (i = 0; i < MAX_INT_HISTORY; i++)
    {
      int which;
      struct interrupt_history *h;
      signed64 dt;

      which = interrupts->history_index - i - 1;
      if (which < 0)
        which += MAX_INT_HISTORY;
      h = &interrupts->interrupts_history[which];
      if (h->taken_cycle == 0)
        break;

      dt = h->taken_cycle - h->raised_cycle;
      sim_io_printf (sd, "%2d %-9.9s %15.15s ", i,
                     interrupt_names[h->type],
                     cycle_to_string (interrupts->cpu, h->taken_cycle, 0));
      sim_io_printf (sd, "%15.15s",
                     cycle_to_string (interrupts->cpu, dt, 0));
      if (prev_interrupt)
        {
          dt = prev_interrupt - h->taken_cycle;
          sim_io_printf (sd, " %s",
                         cycle_to_string (interrupts->cpu, dt, PRINT_TIME));
        }
      sim_io_printf (sd, "\n");
      prev_interrupt = h->taken_cycle;
    }
}
@


1.13
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 1
   Copyright 1999-2003, 2007-2012 Free Software Foundation, Inc.
@


1.12
log
@run copyright.sh for 2011.
@
text
@d2 1
a2 2
   Copyright 1999, 2000, 2001, 2002, 2003, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.12.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 1
   Copyright 1999-2003, 2007-2012 Free Software Foundation, Inc.
@


1.11
log
@Update copyright notices to add year 2010.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2007, 2008, 2009, 2010
@


1.10
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2007, 2008, 2009
@


1.9
log
@	Updated copyright notices for most files.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2007, 2008
@


1.8
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d2 2
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2007 Free Software Foundation, Inc.
@


1.7
log
@Copyright updates for 2007.
@
text
@d7 9
a15 9
GDB, GAS, and the GNU binutils are free software; you can redistribute
them and/or modify them under the terms of the GNU General Public
License as published by the Free Software Foundation; either version
1, or (at your option) any later version.

GDB, GAS, and the GNU binutils are distributed in the hope that they
will be useful, but WITHOUT ANY WARRANTY; without even the implied
warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
the GNU General Public License for more details.
d18 1
a18 2
along with this file; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.6
log
@	* dv-m68hc11tim.c (cycle_to_string): Add flags parameter to better
	control the translation.
	(m68hc11tim_print_timer): Update cycle_to_string conversion.
	(m68hc11tim_timer_event): Fix handling of output
	compare register with its interrupts.
	(m68hc11tim_io_write_buffer): Check output compare
	after setting M6811_TMSK1.
	(m68hc11tim_io_read_buffer): Fix compilation warning.
	* dv-m68hc11.c (m68hc11_option_handler): Likewise.
	* dv-m68hc11spi.c (m68hc11spi_info): Likewise.
	* dv-m68hc11sio.c (m68hc11sio_info): Likewise.
	* interrupts.c (interrupts_info): Likewise.
	(interrupts_reset): Recognize bootstrap mode.
	* sim-main.h (PRINT_CYCLE, PRINT_TIME): New defines.
	(_sim_cpu): Add cpu_start_mode.
	(cycle_to_string): Add flags member.
	* m68hc11_sim.c (OPTION_CPU_BOOTSTRAP): New option.
	(cpu_options): Declare new option bootstrap.
	(cpu_option_handler): Handle it.
	(cpu_info): Update call to cycle_to_string.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
@


1.5
log
@	* interrupts.c (interrupts_reset): New function, setup interrupt
	vector address according to cpu mode.
	(interrupts_initialize): Move reset portion to the above.
	(interrupt_names): New table to give a name to interrupts.
	(idefs): Handle pulse accumulator interrupts.
	(interrupts_info): Print the interrupt history.
	(interrupt_option_handler): New function.
	(interrupt_options): New table of options.
	(interrupts_update_pending): Keep track of when interrupts are
	raised and implement breakpoint-on-raise-interrupt.
	(interrupts_process): Keep track of when interrupts are taken
	and implement breakpoint-on-interrupt.
	* interrupts.h (struct interrupt_history): Define.
	(struct interrupt): Keep track of the interrupt history.
	(interrupts_reset): Declare.
	(interrupts_initialize): Update prototype.
	* m68hc11_sim.c (cpu_reset): Reset interrupts.
	(cpu_initialize): Cleanup.
@
text
@d2 2
a3 2
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
   Written by Stephane Carrez (stcarrez@@worldnet.fr)
d169 14
d534 1
a534 1
  signed64 t;
d550 2
a551 1
                     cycle_to_string (interrupts->cpu, t));
d557 2
a558 1
                 cycle_to_string (interrupts->cpu, t));
d562 2
a563 1
                 cycle_to_string (interrupts->cpu, t));
d567 2
a568 1
                 cycle_to_string (interrupts->cpu, t));
d579 2
a580 1
                     cycle_to_string (interrupts->cpu, t));
d587 2
a588 1
                 cycle_to_string (interrupts->cpu, t));
d592 2
a593 1
                 cycle_to_string (interrupts->cpu, t));
d597 2
a598 1
                 cycle_to_string (interrupts->cpu, t));
d615 3
d632 1
a632 1
      sim_io_printf (sd, "%2d %-10.10s %30.30s ", i,
d634 11
a644 3
                     cycle_to_string (interrupts->cpu, h->taken_cycle));
      sim_io_printf (sd, "%s\n",
                     cycle_to_string (interrupts->cpu, dt));
@


1.5.16.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 2
a3 2
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
   Written by Stephane Carrez (stcarrez@@nerim.fr)
a168 14

  /* In bootstrap mode, initialize the vector table to point
     to the RAM location.  */
  if (interrupts->cpu->cpu_mode == M6811_SMOD)
    {
      bfd_vma addr = interrupts->vectors_addr;
      uint16 vector = 0x0100 - 3 * (M6811_INT_NUMBER - 1);
      for (i = 0; i < M6811_INT_NUMBER; i++)
        {
          memory_write16 (interrupts->cpu, addr, vector);
          addr += 2;
          vector += 3;
        }
    }
d520 1
a520 1
  signed64 t, prev_interrupt;
d536 1
a536 2
                     cycle_to_string (interrupts->cpu, t,
                                      PRINT_TIME | PRINT_CYCLE));
d542 1
a542 2
                 cycle_to_string (interrupts->cpu, t,
                                  PRINT_TIME | PRINT_CYCLE));
d546 1
a546 2
                 cycle_to_string (interrupts->cpu, t,
                                  PRINT_TIME | PRINT_CYCLE));
d550 1
a550 2
                 cycle_to_string (interrupts->cpu, t,
                                  PRINT_TIME | PRINT_CYCLE));
d561 1
a561 2
                     cycle_to_string (interrupts->cpu, t,
                                      PRINT_TIME | PRINT_CYCLE));
d568 1
a568 2
                 cycle_to_string (interrupts->cpu, t,
                                  PRINT_TIME | PRINT_CYCLE));
d572 1
a572 2
                 cycle_to_string (interrupts->cpu, t,
                                  PRINT_TIME | PRINT_CYCLE));
d576 1
a576 2
                 cycle_to_string (interrupts->cpu, t,
                                  PRINT_TIME | PRINT_CYCLE));
a592 3
  prev_interrupt = 0;
  sim_io_printf (sd, "N  Interrupt     Cycle Taken         Latency"
                 "   Delta between interrupts\n");
d607 1
a607 1
      sim_io_printf (sd, "%2d %-9.9s %15.15s ", i,
d609 3
a611 11
                     cycle_to_string (interrupts->cpu, h->taken_cycle, 0));
      sim_io_printf (sd, "%15.15s",
                     cycle_to_string (interrupts->cpu, dt, 0));
      if (prev_interrupt)
        {
          dt = prev_interrupt - h->taken_cycle;
          sim_io_printf (sd, " %s",
                         cycle_to_string (interrupts->cpu, dt, PRINT_TIME));
        }
      sim_io_printf (sd, "\n");
      prev_interrupt = h->taken_cycle;
@


1.5.14.1
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d2 2
a3 2
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
   Written by Stephane Carrez (stcarrez@@nerim.fr)
a168 14

  /* In bootstrap mode, initialize the vector table to point
     to the RAM location.  */
  if (interrupts->cpu->cpu_mode == M6811_SMOD)
    {
      bfd_vma addr = interrupts->vectors_addr;
      uint16 vector = 0x0100 - 3 * (M6811_INT_NUMBER - 1);
      for (i = 0; i < M6811_INT_NUMBER; i++)
        {
          memory_write16 (interrupts->cpu, addr, vector);
          addr += 2;
          vector += 3;
        }
    }
d520 1
a520 1
  signed64 t, prev_interrupt;
d536 1
a536 2
                     cycle_to_string (interrupts->cpu, t,
                                      PRINT_TIME | PRINT_CYCLE));
d542 1
a542 2
                 cycle_to_string (interrupts->cpu, t,
                                  PRINT_TIME | PRINT_CYCLE));
d546 1
a546 2
                 cycle_to_string (interrupts->cpu, t,
                                  PRINT_TIME | PRINT_CYCLE));
d550 1
a550 2
                 cycle_to_string (interrupts->cpu, t,
                                  PRINT_TIME | PRINT_CYCLE));
d561 1
a561 2
                     cycle_to_string (interrupts->cpu, t,
                                      PRINT_TIME | PRINT_CYCLE));
d568 1
a568 2
                 cycle_to_string (interrupts->cpu, t,
                                  PRINT_TIME | PRINT_CYCLE));
d572 1
a572 2
                 cycle_to_string (interrupts->cpu, t,
                                  PRINT_TIME | PRINT_CYCLE));
d576 1
a576 2
                 cycle_to_string (interrupts->cpu, t,
                                  PRINT_TIME | PRINT_CYCLE));
a592 3
  prev_interrupt = 0;
  sim_io_printf (sd, "N  Interrupt     Cycle Taken         Latency"
                 "   Delta between interrupts\n");
d607 1
a607 1
      sim_io_printf (sd, "%2d %-9.9s %15.15s ", i,
d609 3
a611 11
                     cycle_to_string (interrupts->cpu, h->taken_cycle, 0));
      sim_io_printf (sd, "%15.15s",
                     cycle_to_string (interrupts->cpu, dt, 0));
      if (prev_interrupt)
        {
          dt = prev_interrupt - h->taken_cycle;
          sim_io_printf (sd, " %s",
                         cycle_to_string (interrupts->cpu, dt, PRINT_TIME));
        }
      sim_io_printf (sd, "\n");
      prev_interrupt = h->taken_cycle;
@


1.5.50.1
log
@	* dv-m68hc11tim.c (cycle_to_string): Add flags parameter to better
	control the translation.
	(m68hc11tim_print_timer): Update cycle_to_string conversion.
	(m68hc11tim_timer_event): Fix handling of output
	compare register with its interrupts.
	(m68hc11tim_io_write_buffer): Check output compare
	after setting M6811_TMSK1.
	(m68hc11tim_io_read_buffer): Fix compilation warning.
	* dv-m68hc11.c (m68hc11_option_handler): Likewise.
	* dv-m68hc11spi.c (m68hc11spi_info): Likewise.
	* dv-m68hc11sio.c (m68hc11sio_info): Likewise.
	* interrupts.c (interrupts_info): Likewise.
	(interrupts_reset): Recognize bootstrap mode.
	* sim-main.h (PRINT_CYCLE, PRINT_TIME): New defines.
	(_sim_cpu): Add cpu_start_mode.
	(cycle_to_string): Add flags member.
	* m68hc11_sim.c (OPTION_CPU_BOOTSTRAP): New option.
	(cpu_options): Declare new option bootstrap.
	(cpu_option_handler): Handle it.
	(cpu_info): Update call to cycle_to_string.
@
text
@d2 2
a3 2
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
   Written by Stephane Carrez (stcarrez@@nerim.fr)
a168 14

  /* In bootstrap mode, initialize the vector table to point
     to the RAM location.  */
  if (interrupts->cpu->cpu_mode == M6811_SMOD)
    {
      bfd_vma addr = interrupts->vectors_addr;
      uint16 vector = 0x0100 - 3 * (M6811_INT_NUMBER - 1);
      for (i = 0; i < M6811_INT_NUMBER; i++)
        {
          memory_write16 (interrupts->cpu, addr, vector);
          addr += 2;
          vector += 3;
        }
    }
d520 1
a520 1
  signed64 t, prev_interrupt;
d536 1
a536 2
                     cycle_to_string (interrupts->cpu, t,
                                      PRINT_TIME | PRINT_CYCLE));
d542 1
a542 2
                 cycle_to_string (interrupts->cpu, t,
                                  PRINT_TIME | PRINT_CYCLE));
d546 1
a546 2
                 cycle_to_string (interrupts->cpu, t,
                                  PRINT_TIME | PRINT_CYCLE));
d550 1
a550 2
                 cycle_to_string (interrupts->cpu, t,
                                  PRINT_TIME | PRINT_CYCLE));
d561 1
a561 2
                     cycle_to_string (interrupts->cpu, t,
                                      PRINT_TIME | PRINT_CYCLE));
d568 1
a568 2
                 cycle_to_string (interrupts->cpu, t,
                                  PRINT_TIME | PRINT_CYCLE));
d572 1
a572 2
                 cycle_to_string (interrupts->cpu, t,
                                  PRINT_TIME | PRINT_CYCLE));
d576 1
a576 2
                 cycle_to_string (interrupts->cpu, t,
                                  PRINT_TIME | PRINT_CYCLE));
a592 3
  prev_interrupt = 0;
  sim_io_printf (sd, "N  Interrupt     Cycle Taken         Latency"
                 "   Delta between interrupts\n");
d607 1
a607 1
      sim_io_printf (sd, "%2d %-9.9s %15.15s ", i,
d609 3
a611 11
                     cycle_to_string (interrupts->cpu, h->taken_cycle, 0));
      sim_io_printf (sd, "%15.15s",
                     cycle_to_string (interrupts->cpu, dt, 0));
      if (prev_interrupt)
        {
          dt = prev_interrupt - h->taken_cycle;
          sim_io_printf (sd, " %s",
                         cycle_to_string (interrupts->cpu, dt, PRINT_TIME));
        }
      sim_io_printf (sd, "\n");
      prev_interrupt = h->taken_cycle;
@


1.4
log
@	* dv-m68hc11sio.c (m68hc11sio_tx_poll): Always check for
	pending interrupts.
	* interrupts.c (interrupts_process): Keep track of the last number
	of masked insn cycles.
	(interrupts_initialize): Clear last number of masked insn cycles.
	(interrupts_info): Report them.
	(interrupts_update_pending): Compute clear and set masks of
	interrupts and clear the interrupt bits before setting them
	(due to SCI interrupt sharing).
	* interrupts.h (struct interrupts): New members last_mask_cycles
	and xirq_last_mask_cycles.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
d22 37
d85 4
d98 38
d137 2
a138 2
int
interrupts_initialize (struct _sim_cpu *proc)
a139 1
  struct interrupts *interrupts = &proc->cpu_interrupts;
a141 1
  interrupts->cpu          = proc;
d143 4
a146 1
  interrupts->vectors_addr = 0xffc0;
d161 21
a181 1
  return 0;
d184 79
d265 1
a265 1
   when the state of some 68HC11 IO registers changes.  It looks the
d314 29
d462 15
a476 1
      
d492 11
a516 2


d521 1
d535 1
a535 1
      sim_io_printf (sd, "  Current interrupts masked sequence: %s\n",
d541 1
a541 1
  sim_io_printf (sd, "  Shortest interrupts masked sequence: %s\n",
d545 1
a545 1
  sim_io_printf (sd, "  Longest interrupts masked sequence: %s\n",
d549 1
a549 1
  sim_io_printf (sd, "  Last interrupts masked sequence: %s\n",
d567 1
a567 1
  sim_io_printf (sd, "  XIRQ Min interrupts masked sequence: %s\n",
d571 1
a571 1
  sim_io_printf (sd, "  XIRQ Max interrupts masked sequence: %s\n",
d577 36
@


1.4.8.1
log
@	* interrupts.c (interrupts_reset): New function, setup interrupt
	vector address according to cpu mode.
	(interrupts_initialize): Move reset portion to the above.
	(interrupt_names): New table to give a name to interrupts.
	(idefs): Handle pulse accumulator interrupts.
	(interrupts_info): Print the interrupt history.
	(interrupt_option_handler): New function.
	(interrupt_options): New table of options.
	(interrupts_update_pending): Keep track of when interrupts are
	raised and implement breakpoint-on-raise-interrupt.
	(interrupts_process): Keep track of when interrupts are taken
	and implement breakpoint-on-interrupt.
	* interrupts.h (struct interrupt_history): Define.
	(struct interrupt): Keep track of the interrupt history.
	(interrupts_reset): Declare.
	(interrupts_initialize): Update prototype.
	* m68hc11_sim.c (cpu_reset): Reset interrupts.
	(cpu_initialize): Cleanup.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
a21 37
#include "sim-options.h"

static const char *interrupt_names[] = {
  "R1",
  "R2",
  "R3",
  "R4",
  "R5",
  "R6",
  "R7",
  "R8",
  "R9",
  "R10",
  "R11",

  "SCI",
  "SPI",
  "AINPUT",
  "AOVERFLOW",
  "TOVERFLOW",
  "OUT5",
  "OUT4",
  "OUT3",
  "OUT2",
  "OUT1",
  "INC3",
  "INC2",
  "INC1",
  "RT",
  "IRQ",
  "XIRQ",
  "SWI",
  "ILL",
  "COPRESET",
  "COPFAIL",
  "RESET"
};
a47 4

  /* Pulse accumulator.  */
  { M6811_INT_AINPUT,   M6811_TFLG2,  M6811_PAIF,  M6811_TMSK2,  M6811_PAII },
  { M6811_INT_AOVERFLOW,M6811_TFLG2,  M6811_PAOVF, M6811_TMSK2,  M6811_PAOVI},
d57 3
a59 30
enum
{
  OPTION_INTERRUPT_INFO = OPTION_START,
  OPTION_INTERRUPT_CATCH,
  OPTION_INTERRUPT_CLEAR
};

static DECLARE_OPTION_HANDLER (interrupt_option_handler);

static const OPTION interrupt_options[] =
{
  { {"interrupt-info", no_argument, NULL, OPTION_INTERRUPT_INFO },
      '\0', NULL, "Print information about interrupts",
      interrupt_option_handler },
  { {"interrupt-catch", required_argument, NULL, OPTION_INTERRUPT_CATCH },
      '\0', "NAME[,MODE]",
    "Catch interrupts when they are raised or taken\n"
    "NAME   Name of the interrupt\n"
    "MODE   Optional mode (`taken' or `raised')",
      interrupt_option_handler },
  { {"interrupt-clear", required_argument, NULL, OPTION_INTERRUPT_CLEAR },
      '\0', "NAME", "No longer catch the interrupt",
      interrupt_option_handler },
  
  { {NULL, no_argument, NULL, 0}, '\0', NULL, NULL, NULL }
};

/* Initialize the interrupts module.  */
void
interrupts_initialize (SIM_DESC sd, struct _sim_cpu *proc)
d62 1
a64 10

  sim_add_option_table (sd, 0, interrupt_options);
}

/* Initialize the interrupts of the processor.  */
void
interrupts_reset (struct interrupts *interrupts)
{
  int i;
  
d66 1
a66 4
  if (interrupts->cpu->cpu_mode & M6811_SMOD)
    interrupts->vectors_addr = 0xbfc0;
  else
    interrupts->vectors_addr = 0xffc0;
d81 1
a81 21

  /* Clear the interrupt history table.  */
  interrupts->history_index = 0;
  memset (interrupts->interrupts_history, 0,
          sizeof (interrupts->interrupts_history));

  memset (interrupts->interrupts, 0,
          sizeof (interrupts->interrupts));
}

static int
find_interrupt (const char *name)
{
  int i;

  if (name)
    for (i = 0; i < M6811_INT_NUMBER; i++)
      if (strcasecmp (name, interrupt_names[i]) == 0)
        return i;

  return -1;
a83 79
static SIM_RC
interrupt_option_handler (SIM_DESC sd, sim_cpu *cpu,
                          int opt, char *arg, int is_command)
{
  char *p;
  int mode;
  int id;
  struct interrupts *interrupts;

  if (cpu == 0)
    cpu = STATE_CPU (sd, 0);

  interrupts = &cpu->cpu_interrupts;
  switch (opt)
    {
    case OPTION_INTERRUPT_INFO:
      for (id = 0; id < M6811_INT_NUMBER; id++)
        {
          sim_io_eprintf (sd, "%-10.10s ", interrupt_names[id]);
          switch (interrupts->interrupts[id].stop_mode)
            {
            case SIM_STOP_WHEN_RAISED:
              sim_io_eprintf (sd, "catch raised ");
              break;

            case SIM_STOP_WHEN_TAKEN:
              sim_io_eprintf (sd, "catch taken  ");
              break;

            case SIM_STOP_WHEN_RAISED | SIM_STOP_WHEN_TAKEN:
              sim_io_eprintf (sd, "catch all    ");
              break;

            default:
              sim_io_eprintf (sd, "             ");
              break;
            }
          sim_io_eprintf (sd, "%ld\n",
                          interrupts->interrupts[id].raised_count);
        }
      break;

    case OPTION_INTERRUPT_CATCH:
      p = strchr (arg, ',');
      if (p)
        *p++ = 0;

      mode = SIM_STOP_WHEN_RAISED;
      id = find_interrupt (arg);
      if (id < 0)
        sim_io_eprintf (sd, "Interrupt name not recognized: %s\n", arg);

      if (p && strcasecmp (p, "raised") == 0)
        mode = SIM_STOP_WHEN_RAISED;
      else if (p && strcasecmp (p, "taken") == 0)
        mode = SIM_STOP_WHEN_TAKEN;
      else if (p && strcasecmp (p, "all") == 0)
        mode = SIM_STOP_WHEN_RAISED | SIM_STOP_WHEN_TAKEN;
      else if (p)
        {
          sim_io_eprintf (sd, "Invalid argument: %s\n", p);
          break;
        }
      if (id >= 0)
        interrupts->interrupts[id].stop_mode = mode;
      break;

    case OPTION_INTERRUPT_CLEAR:
      mode = SIM_STOP_WHEN_RAISED;
      id = find_interrupt (arg);
      if (id < 0)
        sim_io_eprintf (sd, "Interrupt name not recognized: %s\n", arg);
      else
        interrupts->interrupts[id].stop_mode = 0;      
      break;      
    }

  return SIM_RC_OK;
}
d86 1
a86 1
   when the state of some 68HC11 IO register changes.  It looks the
a134 29

  /* Keep track of when the interrupt is raised by the device.
     Also implements the breakpoint-on-interrupt.  */
  if (set_mask)
    {
      signed64 cycle = cpu_current_cycle (interrupts->cpu);
      int must_stop = 0;
      
      for (i = 0; i < M6811_INT_NUMBER; i++)
        {
          if (!(set_mask & (1 << i)))
            continue;

          interrupts->interrupts[i].cpu_cycle = cycle;
          if (interrupts->interrupts[i].stop_mode & SIM_STOP_WHEN_RAISED)
            {
              must_stop = 1;
              sim_io_printf (CPU_STATE (interrupts->cpu),
                             "Interrupt %s raised\n",
                             interrupt_names[i]);
            }
        }
      if (must_stop)
        sim_engine_halt (CPU_STATE (interrupts->cpu),
                         interrupts->cpu,
                         0, cpu_get_pc (interrupts->cpu),
                         sim_stopped,
                         SIM_SIGTRAP);
    }
d254 1
a254 15
      struct interrupt_history *h;

      /* Implement the breakpoint-on-interrupt.  */
      if (interrupts->interrupts[id].stop_mode & SIM_STOP_WHEN_TAKEN)
        {
          sim_io_printf (CPU_STATE (interrupts->cpu),
                         "Interrupt %s will be handled\n",
                         interrupt_names[id]);
          sim_engine_halt (CPU_STATE (interrupts->cpu),
                           interrupts->cpu,
                           0, cpu_get_pc (interrupts->cpu),
                           sim_stopped,
                           SIM_SIGTRAP);
        }

a269 11
      /* Update the interrupt history table.  */
      h = &interrupts->interrupts_history[interrupts->history_index];
      h->type = id;
      h->taken_cycle = cpu_current_cycle (interrupts->cpu);
      h->raised_cycle = interrupts->interrupts[id].cpu_cycle;
      
      if (interrupts->history_index >= MAX_INT_HISTORY-1)
        interrupts->history_index = 0;
      else
        interrupts->history_index++;

d284 2
a289 1
  int i;
d303 1
a303 1
      sim_io_printf (sd, "  Current interrupts masked sequence:   %s\n",
d309 1
a309 1
  sim_io_printf (sd, "  Shortest interrupts masked sequence:  %s\n",
d313 1
a313 1
  sim_io_printf (sd, "  Longest interrupts masked sequence:   %s\n",
d317 1
a317 1
  sim_io_printf (sd, "  Last interrupts masked sequence:      %s\n",
d335 1
a335 1
  sim_io_printf (sd, "  XIRQ Min interrupts masked sequence:  %s\n",
d339 1
a339 1
  sim_io_printf (sd, "  XIRQ Max interrupts masked sequence:  %s\n",
a344 36

  if (interrupts->pending_mask)
    {
      sim_io_printf (sd, "  Pending interrupts : ");
      for (i = 0; i < M6811_INT_NUMBER; i++)
        {
          enum M6811_INT int_number = interrupts->interrupt_order[i];
          
          if (interrupts->pending_mask & (1 << int_number))
            {
              sim_io_printf (sd, "%s ", interrupt_names[int_number]);
            }
        }
      sim_io_printf (sd, "\n");
    }

  for (i = 0; i < MAX_INT_HISTORY; i++)
    {
      int which;
      struct interrupt_history *h;
      signed64 dt;

      which = interrupts->history_index - i - 1;
      if (which < 0)
        which += MAX_INT_HISTORY;
      h = &interrupts->interrupts_history[which];
      if (h->taken_cycle == 0)
        break;

      dt = h->taken_cycle - h->raised_cycle;
      sim_io_printf (sd, "%2d %-10.10s %30.30s ", i,
                     interrupt_names[h->type],
                     cycle_to_string (interrupts->cpu, h->taken_cycle));
      sim_io_printf (sd, "%s\n",
                     cycle_to_string (interrupts->cpu, dt));
    }
@


1.3
log
@Fix clearing of interrupts in 68hc11 simulator
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
d70 1
d75 1
d94 2
d97 2
d113 1
a113 1
              interrupts->pending_mask &= ~(1 << idef->int_number);
d123 1
a123 1
          interrupts->pending_mask &= ~(1 << idef->int_number);
d128 1
a128 1
      interrupts->pending_mask |= (1 << idef->int_number);
d130 5
d228 1
d247 1
d291 4
a301 4
    }
  if (interrupts->xirq_start_mask_cycle >= 0)
    {
      t = cpu_current_cycle (interrupts->cpu);
d303 2
a304 3
      t -= interrupts->xirq_start_mask_cycle;
      if (t > interrupts->xirq_max_mask_cycles)
        interrupts->xirq_max_mask_cycles = t;
a305 5

  sim_io_printf (sd, "Interrupts Info:\n");
  sim_io_printf (sd, "  Interrupts raised: %lu\n",
                 interrupts->nb_interrupts_raised);

d316 16
d340 4
@


1.2
log
@	* sim-main.h: Define cycle_to_string.
	* dv-m68hc11tim.c (cycle_to_string): New function to translate
	the cpu cycle into some formatted time string.
	(m68hc11tim_print_timer): Use it.
	* dv-m68hc11sio.c (m68hc11sio_info): Use cycle_to_string.
	* dv-m68hc11spi.c (m68hc11spi_info): Likewise.
	* interrupts.c (interrupts_info): Likewise.
	* m68hc11_sim.c (cpu_info): Likewise.
@
text
@d105 5
a109 1
	    continue;
d115 5
a119 1
	continue;
d170 5
a174 1
     The interrupt priority is specified by the table `interrupt_order'.  */
a180 1
	  interrupts->pending_mask &= ~(1 << int_number);
@


1.1
log
@New simulator.
@
text
@d265 2
d269 1
a269 1
      signed64 t = cpu_current_cycle (interrupts->cpu);
d277 1
a277 1
      signed64 t = cpu_current_cycle (interrupts->cpu);
d287 20
a306 12
  sim_io_printf (sd, "  Min interrupts masked sequence: %llu cycles\n",
                 interrupts->min_mask_cycles == CYCLES_MAX ?
                 interrupts->max_mask_cycles :
                 interrupts->min_mask_cycles);
  sim_io_printf (sd, "  Max interrupts masked sequence: %llu cycles\n",
                 interrupts->max_mask_cycles);
  sim_io_printf (sd, "  XIRQ Min interrupts masked sequence: %llu cycles\n",
                 interrupts->xirq_min_mask_cycles == CYCLES_MAX ?
                 interrupts->xirq_max_mask_cycles :
                 interrupts->xirq_min_mask_cycles);
  sim_io_printf (sd, "  XIRQ Max interrupts masked sequence: %llu cycles\n",
                 interrupts->xirq_max_mask_cycles);
@

