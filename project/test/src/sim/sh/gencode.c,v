head	1.34;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.34
	gdb_7_6-2013-04-26-release:1.34
	gdb_7_6-branch:1.34.0.32
	gdb_7_6-2013-03-12-branchpoint:1.34
	gdb_7_5_1-2012-11-29-release:1.34
	gdb_7_5-2012-08-17-release:1.34
	gdb_7_5-branch:1.34.0.30
	gdb_7_5-2012-07-18-branchpoint:1.34
	gdb_7_4_1-2012-04-26-release:1.34
	gdb_7_4-2012-01-24-release:1.34
	gdb_7_4-branch:1.34.0.28
	gdb_7_4-2011-12-13-branchpoint:1.34
	gdb_7_3_1-2011-09-04-release:1.34
	gdb_7_3-2011-07-26-release:1.34
	gdb_7_3-branch:1.34.0.26
	gdb_7_3-2011-04-01-branchpoint:1.34
	gdb_7_2-2010-09-02-release:1.34
	gdb_7_2-branch:1.34.0.24
	gdb_7_2-2010-07-07-branchpoint:1.34
	gdb_7_1-2010-03-18-release:1.34
	gdb_7_1-branch:1.34.0.22
	gdb_7_1-2010-02-18-branchpoint:1.34
	gdb_7_0_1-2009-12-22-release:1.34
	gdb_7_0-2009-10-06-release:1.34
	gdb_7_0-branch:1.34.0.20
	gdb_7_0-2009-09-16-branchpoint:1.34
	arc-sim-20090309:1.34
	msnyder-checkpoint-072509-branch:1.34.0.18
	msnyder-checkpoint-072509-branchpoint:1.34
	arc-insight_6_8-branch:1.34.0.16
	arc-insight_6_8-branchpoint:1.34
	insight_6_8-branch:1.34.0.14
	insight_6_8-branchpoint:1.34
	reverse-20081226-branch:1.34.0.12
	reverse-20081226-branchpoint:1.34
	multiprocess-20081120-branch:1.34.0.10
	multiprocess-20081120-branchpoint:1.34
	reverse-20080930-branch:1.34.0.8
	reverse-20080930-branchpoint:1.34
	reverse-20080717-branch:1.34.0.6
	reverse-20080717-branchpoint:1.34
	msnyder-reverse-20080609-branch:1.34.0.4
	msnyder-reverse-20080609-branchpoint:1.34
	drow-reverse-20070409-branch:1.33.0.4
	drow-reverse-20070409-branchpoint:1.33
	gdb_6_8-2008-03-27-release:1.34
	gdb_6_8-branch:1.34.0.2
	gdb_6_8-2008-02-26-branchpoint:1.34
	gdb_6_7_1-2007-10-29-release:1.33
	gdb_6_7-2007-10-10-release:1.33
	gdb_6_7-branch:1.33.0.2
	gdb_6_7-2007-09-07-branchpoint:1.33
	insight_6_6-20070208-release:1.32
	gdb_6_6-2006-12-18-release:1.32
	gdb_6_6-branch:1.32.0.26
	gdb_6_6-2006-11-15-branchpoint:1.32
	insight_6_5-20061003-release:1.32
	gdb-csl-symbian-6_4_50_20060226-12:1.32
	gdb-csl-sourcerygxx-3_4_4-25:1.32
	nickrob-async-20060828-mergepoint:1.32
	gdb-csl-symbian-6_4_50_20060226-11:1.32
	gdb-csl-sourcerygxx-4_1-17:1.32
	gdb-csl-20060226-branch-local-2:1.32
	gdb-csl-sourcerygxx-4_1-14:1.32
	gdb-csl-sourcerygxx-4_1-13:1.32
	gdb-csl-sourcerygxx-4_1-12:1.32
	gdb-csl-sourcerygxx-3_4_4-21:1.32
	gdb_6_5-20060621-release:1.32
	gdb-csl-sourcerygxx-4_1-9:1.32
	gdb-csl-sourcerygxx-4_1-8:1.32
	gdb-csl-sourcerygxx-4_1-7:1.32
	gdb-csl-arm-2006q1-6:1.32
	gdb-csl-sourcerygxx-4_1-6:1.32
	gdb-csl-symbian-6_4_50_20060226-10:1.32
	gdb-csl-symbian-6_4_50_20060226-9:1.32
	gdb-csl-symbian-6_4_50_20060226-8:1.32
	gdb-csl-coldfire-4_1-11:1.32
	gdb-csl-sourcerygxx-3_4_4-19:1.32
	gdb-csl-coldfire-4_1-10:1.32
	gdb_6_5-branch:1.32.0.24
	gdb_6_5-2006-05-14-branchpoint:1.32
	gdb-csl-sourcerygxx-4_1-5:1.32
	nickrob-async-20060513-branch:1.32.0.22
	nickrob-async-20060513-branchpoint:1.32
	gdb-csl-sourcerygxx-4_1-4:1.32
	msnyder-reverse-20060502-branch:1.32.0.20
	msnyder-reverse-20060502-branchpoint:1.32
	gdb-csl-morpho-4_1-4:1.32
	gdb-csl-sourcerygxx-3_4_4-17:1.32
	readline_5_1-import-branch:1.32.0.18
	readline_5_1-import-branchpoint:1.32
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.32
	gdb-csl-symbian-20060226-branch:1.32.0.16
	gdb-csl-symbian-20060226-branchpoint:1.32
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.32
	msnyder-reverse-20060331-branch:1.32.0.14
	msnyder-reverse-20060331-branchpoint:1.32
	gdb-csl-available-20060303-branch:1.32.0.12
	gdb-csl-available-20060303-branchpoint:1.32
	gdb-csl-20060226-branch:1.32.0.10
	gdb-csl-20060226-branchpoint:1.32
	gdb_6_4-20051202-release:1.32
	msnyder-fork-checkpoint-branch:1.32.0.8
	msnyder-fork-checkpoint-branchpoint:1.32
	gdb-csl-gxxpro-6_3-branch:1.32.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.32
	gdb_6_4-branch:1.32.0.4
	gdb_6_4-2005-11-01-branchpoint:1.32
	gdb-csl-arm-20051020-branch:1.32.0.2
	gdb-csl-arm-20051020-branchpoint:1.32
	msnyder-tracepoint-checkpoint-branch:1.31.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.31
	gdb-csl-arm-20050325-2005-q1b:1.30
	gdb-csl-arm-20050325-2005-q1a:1.30
	csl-arm-20050325-branch:1.30.0.4
	csl-arm-20050325-branchpoint:1.30
	gdb_6_3-20041109-release:1.30
	gdb_6_3-branch:1.30.0.2
	gdb_6_3-20041019-branchpoint:1.30
	drow_intercu-merge-20040921:1.30
	drow_intercu-merge-20040915:1.30
	jimb-gdb_6_2-e500-branch:1.28.0.16
	jimb-gdb_6_2-e500-branchpoint:1.28
	gdb_6_2-20040730-release:1.28
	gdb_6_2-branch:1.28.0.12
	gdb_6_2-2004-07-10-gmt-branchpoint:1.28
	gdb_6_1_1-20040616-release:1.28
	gdb_6_1-2004-04-05-release:1.28
	drow_intercu-merge-20040402:1.28
	drow_intercu-merge-20040327:1.28
	ezannoni_pie-20040323-branch:1.28.0.10
	ezannoni_pie-20040323-branchpoint:1.28
	cagney_tramp-20040321-mergepoint:1.28
	cagney_tramp-20040309-branch:1.28.0.8
	cagney_tramp-20040309-branchpoint:1.28
	gdb_6_1-branch:1.28.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.28
	drow_intercu-20040221-branch:1.28.0.4
	drow_intercu-20040221-branchpoint:1.28
	cagney_bfdfile-20040213-branch:1.28.0.2
	cagney_bfdfile-20040213-branchpoint:1.28
	drow-cplus-merge-20040208:1.26
	carlton_dictionary-20040126-merge:1.24
	cagney_bigcore-20040122-branch:1.24.0.2
	cagney_bigcore-20040122-branchpoint:1.24
	drow-cplus-merge-20040113:1.24
	drow-cplus-merge-20031224:1.21
	drow-cplus-merge-20031220:1.21
	carlton_dictionary-20031215-merge:1.21
	drow-cplus-merge-20031214:1.21
	carlton-dictionary-20031111-merge:1.21
	gdb_6_0-2003-10-04-release:1.5
	kettenis_sparc-20030918-branch:1.20.0.6
	kettenis_sparc-20030918-branchpoint:1.20
	carlton_dictionary-20030917-merge:1.20
	ezannoni_pie-20030916-branchpoint:1.20
	ezannoni_pie-20030916-branch:1.20.0.4
	cagney_x86i386-20030821-branch:1.20.0.2
	cagney_x86i386-20030821-branchpoint:1.20
	carlton_dictionary-20030805-merge:1.18
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.30
	gdb_6_0-2003-06-23-branchpoint:1.5
	jimb-ppc64-linux-20030613-branch:1.5.0.28
	jimb-ppc64-linux-20030613-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.26
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.24
	cagney_writestrings-20030508-branchpoint:1.5
	jimb-ppc64-linux-20030528-branch:1.5.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.20
	cagney_fileio-20030521-branchpoint:1.5
	kettenis_i386newframe-20030517-mergepoint:1.5
	jimb-ppc64-linux-20030509-branch:1.5.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.5
	kettenis_i386newframe-20030504-mergepoint:1.5
	carlton_dictionary-20030430-merge:1.5
	kettenis_i386newframe-20030419-branch:1.5.0.16
	kettenis_i386newframe-20030419-branchpoint:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	kettenis_i386newframe-20030406-branch:1.5.0.14
	kettenis_i386newframe-20030406-branchpoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	kettenis-i386newframe-20030316-mergepoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	kettenis-i386newframe-20030308-branch:1.5.0.4
	kettenis-i386newframe-20030308-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.2
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.4.0.4
	interps-20030202-branchpoint:1.4
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.3
	carlton_dictionary-20021115-merge:1.4
	kseitz_interps-20021105-merge:1.4
	kseitz_interps-20021103-merge:1.4
	drow-cplus-merge-20021020:1.4
	drow-cplus-merge-20021025:1.4
	carlton_dictionary-20021025-merge:1.4
	carlton_dictionary-20021011-merge:1.4
	drow-cplus-branch:1.3.0.24
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	carlton_dictionary-branch:1.3.0.22
	carlton_dictionary-20020920-branchpoint:1.3
	gdb_5_3-branch:1.3.0.20
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.18
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.16
	readline_4_3-import-branchpoint:1.3
	gdb_5_2_1-2002-07-23-release:1.3
	kseitz_interps-20020528-branch:1.3.0.14
	kseitz_interps-20020528-branchpoint:1.3
	cagney_regbuf-20020515-branch:1.3.0.12
	cagney_regbuf-20020515-branchpoint:1.3
	jimb-macro-020506-branch:1.3.0.10
	jimb-macro-020506-branchpoint:1.3
	gdb_5_2-2002-04-29-release:1.3
	gdb_5_2-branch:1.3.0.8
	gdb_5_2-2002-03-03-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	cygnus_cvs_20020108_pre:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.4
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.2
	gdb_5_1-2001-07-29-branchpoint:1.3
	insight-precleanup-2001-01-01:1.3
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.34
date	2007.10.08.11.51.31;	author denis;	state Exp;
branches;
next	1.33;

1.33
date	2007.03.02.12.15.01;	author drow;	state Exp;
branches;
next	1.32;

1.32
date	2005.06.17.03.13.07;	author drow;	state Exp;
branches;
next	1.31;

1.31
date	2005.04.14.20.16.06;	author jlarmour;	state Exp;
branches;
next	1.30;

1.30
date	2004.09.08.09.11.50;	author corinna;	state Exp;
branches;
next	1.29;

1.29
date	2004.08.18.11.47.15;	author amylaar;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.13.00.01.19;	author msnyder;	state Exp;
branches
	1.28.4.1;
next	1.27;

1.27
date	2004.02.12.19.32.12;	author msnyder;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.27.23.30.01;	author msnyder;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.27.23.23.57;	author msnyder;	state Exp;
branches;
next	1.24;

1.24
date	2004.01.10.00.43.28;	author msnyder;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.09.19.44.50;	author msnyder;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.06.01.05.02;	author msnyder;	state Exp;
branches;
next	1.21;

1.21
date	2003.11.03.14.14.15;	author amylaar;	state Exp;
branches;
next	1.20;

1.20
date	2003.08.11.19.28.05;	author msnyder;	state Exp;
branches;
next	1.19;

1.19
date	2003.08.07.21.36.43;	author msnyder;	state Exp;
branches;
next	1.18;

1.18
date	2003.07.25.23.52.43;	author msnyder;	state Exp;
branches;
next	1.17;

1.17
date	2003.07.25.00.59.36;	author msnyder;	state Exp;
branches;
next	1.16;

1.16
date	2003.07.24.00.38.07;	author msnyder;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.23.21.47.28;	author msnyder;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.23.21.43.50;	author msnyder;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.23.21.28.06;	author msnyder;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.23.21.25.41;	author msnyder;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.23.21.23.32;	author msnyder;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.23.21.17.33;	author msnyder;	state Exp;
branches;
next	1.9;

1.9
date	2003.07.23.21.14.54;	author msnyder;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.04.00.03.52;	author msnyder;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.28.01.34.47;	author msnyder;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.27.21.18.42;	author msnyder;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.06.10.42.33;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.11.15.31.28;	author amylaar;	state Exp;
branches;
next	1.3;

1.3
date	2000.10.24.01.02.53;	author bje;	state Exp;
branches
	1.3.14.1
	1.3.22.1
	1.3.24.1;
next	1.2;

1.2
date	2000.05.15.21.12.42;	author amylaar;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.12;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.28.4.1
date	2004.09.16.17.02.13;	author drow;	state Exp;
branches;
next	;

1.3.14.1
date	2002.11.03.21.49.48;	author ezannoni;	state Exp;
branches;
next	;

1.3.22.1
date	2002.10.11.22.23.08;	author carlton;	state Exp;
branches;
next	1.3.22.2;

1.3.22.2
date	2003.02.07.19.18.06;	author carlton;	state Exp;
branches;
next	1.3.22.3;

1.3.22.3
date	2003.08.05.17.13.34;	author carlton;	state Exp;
branches;
next	1.3.22.4;

1.3.22.4
date	2003.09.17.21.29.04;	author carlton;	state Exp;
branches;
next	1.3.22.5;

1.3.22.5
date	2003.11.11.23.51.21;	author carlton;	state Exp;
branches;
next	1.3.22.6;

1.3.22.6
date	2004.01.26.19.11.54;	author carlton;	state Exp;
branches;
next	;

1.3.24.1
date	2002.10.26.17.12.33;	author drow;	state Exp;
branches;
next	1.3.24.2;

1.3.24.2
date	2003.12.14.20.28.29;	author drow;	state Exp;
branches;
next	1.3.24.3;

1.3.24.3
date	2004.01.13.16.12.24;	author drow;	state Exp;
branches;
next	1.3.24.4;

1.3.24.4
date	2004.02.09.19.44.04;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.35.12;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.33.42;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.08.31.01.14.02;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.34
log
@2007-09-24  Andrew Stubbs  <andrew.stubbs@@st.com>

	* gencode.c (tab): Add RAISE_EXCEPTION_IF_IN_DELAY_SLOT to the
	definition of PC relative 'mov.l'/'mov.w' and also 'mova'.
@
text
@/* Simulator/Opcode generator for the Renesas
   (formerly Hitachi) / SuperH Inc. Super-H architecture.

   Written by Steve Chamberlain of Cygnus Support.
   sac@@cygnus.com

   This file is part of SH sim.


		THIS SOFTWARE IS NOT COPYRIGHTED

   Cygnus offers the following for use in the public domain.  Cygnus
   makes no warranty with regard to the software or it's performance
   and the user accepts the software "AS IS" with all faults.

   CYGNUS DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD TO
   THIS SOFTWARE INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

*/

/* This program generates the opcode table for the assembler and
   the simulator code.

   -t		prints a pretty table for the assembler manual
   -s		generates the simulator code jump table
   -d		generates a define table
   -x		generates the simulator code switch statement
   default 	used to generate the opcode tables

*/

#include <stdio.h>

#define MAX_NR_STUFF 42

typedef struct
{
  char *defs;
  char *refs;
  char *name;
  char *code;
  char *stuff[MAX_NR_STUFF];
  int index;
} op;


op tab[] =
{

  { "n", "", "add #<imm>,<REG_N>", "0111nnnni8*1....",
    "R[n] += SEXT (i);",
    "if (i == 0) {",
    "  UNDEF(n); /* see #ifdef PARANOID */",
    "  break;",
    "}",
  },
  { "n", "mn", "add <REG_M>,<REG_N>", "0011nnnnmmmm1100",
    "R[n] += R[m];",
  },

  { "n", "mn", "addc <REG_M>,<REG_N>", "0011nnnnmmmm1110",
    "ult = R[n] + T;",
    "SET_SR_T (ult < R[n]);",
    "R[n] = ult + R[m];",
    "SET_SR_T (T || (R[n] < ult));",
  },

  { "n", "mn", "addv <REG_M>,<REG_N>", "0011nnnnmmmm1111",
    "ult = R[n] + R[m];",
    "SET_SR_T ((~(R[n] ^ R[m]) & (ult ^ R[n])) >> 31);",
    "R[n] = ult;",
  },

  { "0", "0", "and #<imm>,R0", "11001001i8*1....",
    "R0 &= i;",
  },
  { "n", "nm", "and <REG_M>,<REG_N>", "0010nnnnmmmm1001",
    "R[n] &= R[m];",
  },
  { "", "0", "and.b #<imm>,@@(R0,GBR)", "11001101i8*1....",
    "MA (1);",
    "WBAT (GBR + R0, RBAT (GBR + R0) & i);",
  },

  { "", "", "bf <bdisp8>", "10001011i8p1....",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "if (!T) {",
    "  SET_NIP (PC + 4 + (SEXT (i) * 2));",
    "  cycles += 2;",
    "}",
  },

  { "", "", "bf.s <bdisp8>", "10001111i8p1....",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "if (!T) {",
    "  SET_NIP (PC + 4 + (SEXT (i) * 2));",
    "  cycles += 2;",
    "  Delay_Slot (PC + 2);",
    "}",
  },

  { "", "n", "bit32 #imm3,@@(disp12,<REG_N>)", "0011nnnni8*11001",
    "/* 32-bit logical bit-manipulation instructions.  */",
    "int word2 = RIAT (nip);",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "i >>= 4;	/* BOGUS: Using only three bits of 'i'.  */",
    "/* MSB of 'i' must be zero.  */",
    "if (i > 7)",
    "  RAISE_EXCEPTION (SIGILL);",
    "MA (1);",
    "do_blog_insn (1 << i, (word2 & 0xfff) + R[n], ",
    "              (word2 >> 12) & 0xf, memory, maskb);",
    "SET_NIP (nip + 2);	/* Consume 2 more bytes.  */",
  },
  { "", "", "bra <bdisp12>", "1010i12.........",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "SET_NIP (PC + 4 + (SEXT12 (i) * 2));",
    "cycles += 2;",
    "Delay_Slot (PC + 2);",
  },

  { "", "n", "braf <REG_N>", "0000nnnn00100011",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "SET_NIP (PC + 4 + R[n]);",
    "cycles += 2;",
    "Delay_Slot (PC + 2);",
  },

  { "", "", "bsr <bdisp12>", "1011i12.........",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "PR = PH2T (PC + 4);",
    "SET_NIP (PC + 4 + (SEXT12 (i) * 2));",
    "cycles += 2;",
    "Delay_Slot (PC + 2);",
  },

  { "", "n", "bsrf <REG_N>", "0000nnnn00000011",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "PR = PH2T (PC) + 4;",
    "SET_NIP (PC + 4 + R[n]);",
    "cycles += 2;",
    "Delay_Slot (PC + 2);",
  },

  { "", "", "bt <bdisp8>", "10001001i8p1....",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "if (T) {",
    "  SET_NIP (PC + 4 + (SEXT (i) * 2));",
    "  cycles += 2;",
    "}",
  },
  
  { "", "m", "bld/st #<imm>, <REG_M>", "10000111mmmmi4*1",
    "/* MSB of 'i' is true for load, false for store.  */",
    "if (i <= 7)",
    "  if (T)",
    "    R[m] |= (1 << i);",
    "  else",
    "    R[m] &= ~(1 << i);",
    "else",
    "  SET_SR_T ((R[m] & (1 << (i - 8))) != 0);",
  },
  { "m", "m", "bset/clr #<imm>, <REG_M>", "10000110mmmmi4*1",
    "/* MSB of 'i' is true for set, false for clear.  */",
    "if (i <= 7)",
    "  R[m] &= ~(1 << i);",
    "else",
    "  R[m] |= (1 << (i - 8));",
  },
  { "n", "n", "clips.b <REG_N>", "0100nnnn10010001",
    "if (R[n] < -128 || R[n] > 127) {",
    "  L (n);",
    "  SET_SR_CS (1);",
    "  if (R[n] > 127)",
    "    R[n] = 127;",
    "  else if (R[n] < -128)",
    "    R[n] = -128;",
    "}",
  },
  { "n", "n", "clips.w <REG_N>", "0100nnnn10010101",
    "if (R[n] < -32768 || R[n] > 32767) {",
    "  L (n);",
    "  SET_SR_CS (1);",
    "  if (R[n] > 32767)",
    "    R[n] = 32767;",
    "  else if (R[n] < -32768)",
    "    R[n] = -32768;",
    "}",
  },
  { "n", "n", "clipu.b <REG_N>", "0100nnnn10000001",
    "if (R[n] < -256 || R[n] > 255) {",
    "  L (n);",
    "  SET_SR_CS (1);",
    "  R[n] = 255;",
    "}",
  },
  { "n", "n", "clipu.w <REG_N>", "0100nnnn10000101",
    "if (R[n] < -65536 || R[n] > 65535) {",
    "  L (n);",
    "  SET_SR_CS (1);",
    "  R[n] = 65535;",
    "}",
  },
  { "n", "0n", "divs R0,<REG_N>", "0100nnnn10010100",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "if (R0 == 0)",
    "  R[n] = 0x7fffffff;",
    "else if (R0 == -1 && R[n] == 0x80000000)",
    "  R[n] = 0x7fffffff;",
    "else R[n] /= R0;",
    "L (n);",
  },
  { "n", "0n", "divu R0,<REG_N>", "0100nnnn10000100",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "if (R0 == 0)",
    "  R[n] = 0xffffffff;",
    "/* FIXME: The result may be implementation-defined if it is outside */",
    "/* the range of signed int (i.e. if R[n] was negative and R0 == 1).  */",
    "else R[n] = R[n] / (unsigned int) R0;",
    "L (n);",
  },
  { "n", "0n", "mulr R0,<REG_N>", "0100nnnn10000000",
    "R[n] = (R[n] * R0) & 0xffffffff;",
    "L (n);",
  },
  { "0", "n", "ldbank @@<REG_N>,R0", "0100nnnn11100101",
    "int regn = (R[n] >> 2) & 0x1f;",
    "int bankn = (R[n] >> 7) & 0x1ff;",
    "if (regn > 19)",
    "  regn = 19;	/* FIXME what should happen? */",
    "R0 = saved_state.asregs.regstack[bankn].regs[regn];",
    "L (0);",
  },
  { "", "0n", "stbank R0,@@<REG_N>", "0100nnnn11100001",
    "int regn = (R[n] >> 2) & 0x1f;",
    "int bankn = (R[n] >> 7) & 0x1ff;",
    "if (regn > 19)",
    "  regn = 19;	/* FIXME what should happen? */",
    "saved_state.asregs.regstack[bankn].regs[regn] = R0;",
  },
  { "", "", "resbank", "0000000001011011",
    "int i;",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    /* FIXME: cdef all */
    "if (BO) {	/* Bank Overflow */",
    /* FIXME: how do we know when to reset BO?  */
    "  for (i = 0; i <= 14; i++) {",
    "    R[i] = RLAT (R[15]);",
    "    MA (1);",
    "    R[15] += 4;",
    "  }",
    "  PR = RLAT (R[15]);",
    "  R[15] += 4;",
    "  MA (1);",
    "  GBR = RLAT (R[15]);",
    "  R[15] += 4;",
    "  MA (1);",
    "  MACH = RLAT (R[15]);",
    "  R[15] += 4;",
    "  MA (1);",
    "  MACL = RLAT (R[15]);",
    "  R[15] += 4;",
    "  MA (1);",
    "}",
    "else if (BANKN == 0)	/* Bank Underflow */",
    "  RAISE_EXCEPTION (SIGILL);",	/* FIXME: what exception? */
    "else {",
    "  SET_BANKN (BANKN - 1);",
    "  for (i = 0; i <= 14; i++)",
    "    R[i] = saved_state.asregs.regstack[BANKN].regs[i];",
    "  MACH = saved_state.asregs.regstack[BANKN].regs[15];",
    "  PR   = saved_state.asregs.regstack[BANKN].regs[17];",
    "  GBR  = saved_state.asregs.regstack[BANKN].regs[18];",
    "  MACL = saved_state.asregs.regstack[BANKN].regs[19];",
    "}",
  },
  { "f", "f-", "movml.l <REG_N>,@@-R15", "0100nnnn11110001",
    "/* Push Rn...R0 (if n==15, push pr and R14...R0).  */",
    "do {",
    "  MA (1);",
    "  R[15] -= 4;",
    "  if (n == 15)",
    "    WLAT (R[15], PR);",
    "  else",
    "    WLAT (R[15], R[n]);",
    "} while (n-- > 0);",    
  },
  { "f", "f+", "movml.l @@R15+,<REG_N>", "0100nnnn11110101",
    "/* Pop R0...Rn (if n==15, pop R0...R14 and pr).  */",
    "int i = 0;\n",
    "do {",
    "  MA (1);",
    "  if (i == 15)",
    "    PR = RLAT (R[15]);",
    "  else",
    "    R[i] = RLAT (R[15]);",
    "  R[15] += 4;",
    "} while (i++ < n);",    
  },
  { "f", "f-", "movmu.l <REG_N>,@@-R15", "0100nnnn11110000",
    "/* Push pr, R14...Rn (if n==15, push pr).  */",	/* FIXME */
    "int i = 15;\n",
    "do {",
    "  MA (1);",
    "  R[15] -= 4;",
    "  if (i == 15)",
    "    WLAT (R[15], PR);",
    "  else",
    "    WLAT (R[15], R[i]);",
    "} while (i-- > n);",    
  },
  { "f", "f+", "movmu.l @@R15+,<REG_N>", "0100nnnn11110100",
    "/* Pop Rn...R14, pr (if n==15, pop pr).  */",	/* FIXME */
    "do {",
    "  MA (1);",
    "  if (n == 15)",
    "    PR = RLAT (R[15]);",
    "  else",
    "    R[n] = RLAT (R[15]);",
    "  R[15] += 4;",
    "} while (n++ < 15);",    
  },
  { "", "", "nott", "0000000001101000",
    "SET_SR_T (T == 0);",	
  },

  { "", "", "bt.s <bdisp8>", "10001101i8p1....",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "if (T) {",
    "  SET_NIP (PC + 4 + (SEXT (i) * 2));",
    "  cycles += 2;",
    "  Delay_Slot (PC + 2);",
    "}",
  },

  { "", "", "clrmac", "0000000000101000",
    "MACH = 0;",
    "MACL = 0;",
  },

  { "", "", "clrs", "0000000001001000",
    "SET_SR_S (0);",
  },

  { "", "", "clrt", "0000000000001000",
    "SET_SR_T (0);",
  },

  /* sh4a */
  { "", "", "clrdmxy", "0000000010001000",
    "saved_state.asregs.cregs.named.sr &= ~(SR_MASK_DMX | SR_MASK_DMY);"
  },

  { "", "0", "cmp/eq #<imm>,R0", "10001000i8*1....",
    "SET_SR_T (R0 == SEXT (i));",
  },
  { "", "mn", "cmp/eq <REG_M>,<REG_N>", "0011nnnnmmmm0000",
    "SET_SR_T (R[n] == R[m]);",
  },
  { "", "mn", "cmp/ge <REG_M>,<REG_N>", "0011nnnnmmmm0011",
    "SET_SR_T (R[n] >= R[m]);",
  },
  { "", "mn", "cmp/gt <REG_M>,<REG_N>", "0011nnnnmmmm0111",
    "SET_SR_T (R[n] > R[m]);",
  },
  { "", "mn", "cmp/hi <REG_M>,<REG_N>", "0011nnnnmmmm0110",
    "SET_SR_T (UR[n] > UR[m]);",
  },
  { "", "mn", "cmp/hs <REG_M>,<REG_N>", "0011nnnnmmmm0010",
    "SET_SR_T (UR[n] >= UR[m]);",
  },
  { "", "n", "cmp/pl <REG_N>", "0100nnnn00010101",
    "SET_SR_T (R[n] > 0);",
  },
  { "", "n", "cmp/pz <REG_N>", "0100nnnn00010001",
    "SET_SR_T (R[n] >= 0);",
  },
  { "", "mn", "cmp/str <REG_M>,<REG_N>", "0010nnnnmmmm1100",
    "ult = R[n] ^ R[m];",
    "SET_SR_T (((ult & 0xff000000) == 0)",
    "          | ((ult & 0xff0000) == 0)",
    "          | ((ult & 0xff00) == 0)",
    "          | ((ult & 0xff) == 0));",
  },

  { "", "mn", "div0s <REG_M>,<REG_N>", "0010nnnnmmmm0111",
    "SET_SR_Q ((R[n] & sbit) != 0);",
    "SET_SR_M ((R[m] & sbit) != 0);",
    "SET_SR_T (M != Q);",
  },

  { "", "", "div0u", "0000000000011001",
    "SET_SR_M (0);",
    "SET_SR_Q (0);",
    "SET_SR_T (0);",
  },

  { "n", "nm", "div1 <REG_M>,<REG_N>", "0011nnnnmmmm0100",
    "div1 (&R0, m, n/*, T*/);",
  },

  { "", "nm", "dmuls.l <REG_M>,<REG_N>", "0011nnnnmmmm1101",
    "dmul (1/*signed*/, R[n], R[m]);",
  },

  { "", "nm", "dmulu.l <REG_M>,<REG_N>", "0011nnnnmmmm0101",
    "dmul (0/*unsigned*/, R[n], R[m]);",
  },

  { "n", "n", "dt <REG_N>", "0100nnnn00010000",
    "R[n]--;",
    "SET_SR_T (R[n] == 0);",
  },

  { "n", "m", "exts.b <REG_M>,<REG_N>", "0110nnnnmmmm1110",
    "R[n] = SEXT (R[m]);",
  },
  { "n", "m", "exts.w <REG_M>,<REG_N>", "0110nnnnmmmm1111",
    "R[n] = SEXTW (R[m]);",
  },

  { "n", "m", "extu.b <REG_M>,<REG_N>", "0110nnnnmmmm1100",
    "R[n] = (R[m] & 0xff);",
  },
  { "n", "m", "extu.w <REG_M>,<REG_N>", "0110nnnnmmmm1101",
    "R[n] = (R[m] & 0xffff);",
  },

  /* sh2e */
  { "", "", "fabs <FREG_N>", "1111nnnn01011101",
    "FP_UNARY (n, fabs);",
    "/* FIXME: FR (n) &= 0x7fffffff; */",
  },

  /* sh2e */
  { "", "", "fadd <FREG_M>,<FREG_N>", "1111nnnnmmmm0000",
    "FP_OP (n, +, m);",
  },

  /* sh2e */
  { "", "", "fcmp/eq <FREG_M>,<FREG_N>", "1111nnnnmmmm0100",
    "FP_CMP (n, ==, m);",
  },
  /* sh2e */
  { "", "", "fcmp/gt <FREG_M>,<FREG_N>", "1111nnnnmmmm0101",
    "FP_CMP (n, >, m);",
  },

  /* sh4 */
  { "", "", "fcnvds <DR_N>,FPUL", "1111nnnn10111101",
    "if (! FPSCR_PR || n & 1)",
    "  RAISE_EXCEPTION (SIGILL);",
    "else",
    "{",
    "  union",
    "  {",
    "    int i;",
    "    float f;",
    "  } u;",
    "  u.f = DR (n);",
    "  FPUL = u.i;",
    "}",
  },

  /* sh4 */
  { "", "", "fcnvsd FPUL,<DR_N>", "1111nnnn10101101",
    "if (! FPSCR_PR || n & 1)",
    "  RAISE_EXCEPTION (SIGILL);",
    "else",
    "{",
    "  union",
    "  {",
    "    int i;",
    "    float f;",
    "  } u;",
    "  u.i = FPUL;",
    "  SET_DR (n, u.f);",
    "}",
  },

  /* sh2e */
  { "", "", "fdiv <FREG_M>,<FREG_N>", "1111nnnnmmmm0011",
    "FP_OP (n, /, m);",
    "/* FIXME: check for DP and (n & 1) == 0?  */",
  },

  /* sh4 */
  { "", "", "fipr <FV_M>,<FV_N>", "1111vvVV11101101",
    "if (FPSCR_PR)", 
    "  RAISE_EXCEPTION (SIGILL);",
    "else",
    "{",
    "  double fsum = 0;",
    "  if (saved_state.asregs.bfd_mach == bfd_mach_sh2a)",
    "    RAISE_EXCEPTION (SIGILL);",
    "  /* FIXME: check for nans and infinities.  */",
    "  fsum += FR (v1+0) * FR (v2+0);",
    "  fsum += FR (v1+1) * FR (v2+1);",
    "  fsum += FR (v1+2) * FR (v2+2);",
    "  fsum += FR (v1+3) * FR (v2+3);",
    "  SET_FR (v1+3, fsum);",
    "}",
  },

  /* sh2e */
  { "", "", "fldi0 <FREG_N>", "1111nnnn10001101",
    "SET_FR (n, (float) 0.0);",
    "/* FIXME: check for DP and (n & 1) == 0?  */",
  },

  /* sh2e */
  { "", "", "fldi1 <FREG_N>", "1111nnnn10011101",
    "SET_FR (n, (float) 1.0);",
    "/* FIXME: check for DP and (n & 1) == 0?  */",
  },

  /* sh2e */
  { "", "", "flds <FREG_N>,FPUL", "1111nnnn00011101",
    "  union",
    "  {",
    "    int i;",
    "    float f;",
    "  } u;",
    "  u.f = FR (n);",
    "  FPUL = u.i;",
  },

  /* sh2e */
  { "", "", "float FPUL,<FREG_N>", "1111nnnn00101101",
    /* sh4 */
    "if (FPSCR_PR)",
    "  SET_DR (n, (double) FPUL);",
    "else",
    "{",
    "  SET_FR (n, (float) FPUL);",
    "}",
  },

  /* sh2e */
  { "", "", "fmac <FREG_0>,<FREG_M>,<FREG_N>", "1111nnnnmmmm1110",
    "SET_FR (n, FR (m) * FR (0) + FR (n));",
    "/* FIXME: check for DP and (n & 1) == 0? */",
  },

  /* sh2e */
  { "", "", "fmov <FREG_M>,<FREG_N>", "1111nnnnmmmm1100",
    /* sh4 */
    "if (FPSCR_SZ) {",
    "  int ni = XD_TO_XF (n);",
    "  int mi = XD_TO_XF (m);",
    "  SET_XF (ni + 0, XF (mi + 0));",
    "  SET_XF (ni + 1, XF (mi + 1));",
    "}",
    "else",
    "{",
    "  SET_FR (n, FR (m));",
    "}",
  },
  /* sh2e */
  { "", "n", "fmov.s <FREG_M>,@@<REG_N>", "1111nnnnmmmm1010",
    /* sh4 */
    "if (FPSCR_SZ) {",
    "  MA (2);",
    "  WDAT (R[n], m);",
    "}",
    "else",
    "{",
    "  MA (1);",
    "  WLAT (R[n], FI (m));",
    "}",
  },
  /* sh2e */
  { "", "m", "fmov.s @@<REG_M>,<FREG_N>", "1111nnnnmmmm1000",
    /* sh4 */
    "if (FPSCR_SZ) {",
    "  MA (2);",
    "  RDAT (R[m], n);",
    "}",
    "else",
    "{",
    "  MA (1);",
    "  SET_FI (n, RLAT (R[m]));",
    "}",
  },
  /* sh2a */
  { "", "n", "fmov.s @@(disp12,<REG_N>), <FREG_M>", "0011nnnnmmmm0001",
    "/* and fmov.s <FREG_N>, @@(disp12,<FREG_M>)",
    "   and mov.bwl <REG_N>, @@(disp12,<REG_M>)",
    "   and mov.bwl @@(disp12,<REG_N>),<REG_M>",
    "   and movu.bw @@(disp12,<REG_N>),<REG_M>.  */",
    "int word2 = RIAT (nip);",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "SET_NIP (nip + 2);	/* Consume 2 more bytes.  */",
    "MA (1);",
    "do_long_move_insn (word2 & 0xf000, word2 & 0x0fff, m, n, &thislock);",
  },
  /* sh2e */
  { "m", "m", "fmov.s @@<REG_M>+,<FREG_N>", "1111nnnnmmmm1001",
    /* sh4 */
    "if (FPSCR_SZ) {",
    "  MA (2);",
    "  RDAT (R[m], n);",
    "  R[m] += 8;",
    "}",
    "else",
    "{",
    "  MA (1);",
    "  SET_FI (n, RLAT (R[m]));",
    "  R[m] += 4;",
    "}",
  },
  /* sh2e */
  { "n", "n", "fmov.s <FREG_M>,@@-<REG_N>", "1111nnnnmmmm1011",
    /* sh4 */
    "if (FPSCR_SZ) {",
    "  MA (2);",
    "  R[n] -= 8;",
    "  WDAT (R[n], m);",
    "}",
    "else",
    "{",
    "  MA (1);",
    "  R[n] -= 4;",
    "  WLAT (R[n], FI (m));",
    "}",
  },
  /* sh2e */
  { "", "0m", "fmov.s @@(R0,<REG_M>),<FREG_N>", "1111nnnnmmmm0110",
    /* sh4 */
    "if (FPSCR_SZ) {",
    "  MA (2);",
    "  RDAT (R[0]+R[m], n);",
    "}",
    "else",
    "{",
    "  MA (1);",
    "  SET_FI (n, RLAT (R[0] + R[m]));",
    "}",
  },
  /* sh2e */
  { "", "0n", "fmov.s <FREG_M>,@@(R0,<REG_N>)", "1111nnnnmmmm0111",
    /* sh4 */
    "if (FPSCR_SZ) {",
    "  MA (2);",
    "  WDAT (R[0]+R[n], m);",
    "}",
    "else",
    "{",
    "  MA (1);",
    "  WLAT ((R[0]+R[n]), FI (m));",
    "}",
  },

  /* sh4: 
     See fmov instructions above for move to/from extended fp registers.  */

  /* sh2e */
  { "", "", "fmul <FREG_M>,<FREG_N>", "1111nnnnmmmm0010",
    "FP_OP (n, *, m);",
  },

  /* sh2e */
  { "", "", "fneg <FREG_N>", "1111nnnn01001101",
    "FP_UNARY (n, -);",
  },

  /* sh4a */
  { "", "", "fpchg", "1111011111111101",
    "SET_FPSCR (GET_FPSCR () ^ FPSCR_MASK_PR);",
  },

  /* sh4 */
  { "", "", "frchg", "1111101111111101",
    "if (FPSCR_PR)",
    "  RAISE_EXCEPTION (SIGILL);",
    "else if (saved_state.asregs.bfd_mach == bfd_mach_sh2a)",
    "  RAISE_EXCEPTION (SIGILL);",
    "else",
    "  SET_FPSCR (GET_FPSCR () ^ FPSCR_MASK_FR);",
  },

  /* sh4 */
  { "", "", "fsca", "1111eeee11111101",
    "if (FPSCR_PR)",
    "  RAISE_EXCEPTION (SIGILL);",
    "else if (saved_state.asregs.bfd_mach == bfd_mach_sh2a)",
    "  RAISE_EXCEPTION (SIGILL);",
    "else",
    "  {",
    "    SET_FR (n, fsca_s (FPUL, &sin));",
    "    SET_FR (n+1, fsca_s (FPUL, &cos));",
    "  }",
  },

  /* sh4 */
  { "", "", "fschg", "1111001111111101",
    "SET_FPSCR (GET_FPSCR () ^ FPSCR_MASK_SZ);",
  },

  /* sh3e */
  { "", "", "fsqrt <FREG_N>", "1111nnnn01101101",
    "FP_UNARY (n, sqrt);",
  },

  /* sh4 */
  { "", "", "fsrra <FREG_N>", "1111nnnn01111101",
    "if (FPSCR_PR)",
    "  RAISE_EXCEPTION (SIGILL);",
    "else if (saved_state.asregs.bfd_mach == bfd_mach_sh2a)",
    "  RAISE_EXCEPTION (SIGILL);",
    "else",
    "  SET_FR (n, fsrra_s (FR (n)));",
  },

  /* sh2e */
  { "", "", "fsub <FREG_M>,<FREG_N>", "1111nnnnmmmm0001",
    "FP_OP (n, -, m);",
  },

  /* sh2e */
  { "", "", "ftrc <FREG_N>, FPUL", "1111nnnn00111101",
    /* sh4 */
    "if (FPSCR_PR) {",
    "  if (DR (n) != DR (n)) /* NaN */",
    "    FPUL = 0x80000000;",
    "  else",
    "    FPUL =  (int) DR (n);",
    "}",
    "else",
    "if (FR (n) != FR (n)) /* NaN */",
    "  FPUL = 0x80000000;",
    "else",
    "  FPUL = (int) FR (n);",
  },

  /* sh4 */
  { "", "", "ftrv <FV_N>", "1111vv0111111101",
    "if (FPSCR_PR)",
    "  RAISE_EXCEPTION (SIGILL);",
    "else",
    "{", 
    "  if (saved_state.asregs.bfd_mach == bfd_mach_sh2a)",
    "    RAISE_EXCEPTION (SIGILL);",
    "  /* FIXME not implemented.  */",
    "  printf (\"ftrv xmtrx, FV%d\\n\", v1);",
    "}", 
  },

  /* sh2e */
  { "", "", "fsts FPUL,<FREG_N>", "1111nnnn00001101",
    "  union",
    "  {",
    "    int i;",
    "    float f;",
    "  } u;",
    "  u.i = FPUL;",
    "  SET_FR (n, u.f);",
  },

  { "", "n", "jmp @@<REG_N>", "0100nnnn00101011",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "SET_NIP (PT2H (R[n]));",
    "cycles += 2;",
    "Delay_Slot (PC + 2);",
  },

  { "", "n", "jsr @@<REG_N>", "0100nnnn00001011",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "PR = PH2T (PC + 4);",
    "if (~doprofile)",
    "  gotcall (PR, R[n]);",
    "SET_NIP (PT2H (R[n]));",
    "cycles += 2;",
    "Delay_Slot (PC + 2);",
  },
  { "", "n", "jsr/n @@<REG_N>", "0100nnnn01001011",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "PR = PH2T (PC + 2);",
    "if (~doprofile)",
    "  gotcall (PR, R[n]);",
    "SET_NIP (PT2H (R[n]));",
  },
  { "", "", "jsr/n @@@@(<disp>,TBR)", "10000011i8p4....",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "PR = PH2T (PC + 2);",
    "if (~doprofile)",
    "  gotcall (PR, i + TBR);",
    "SET_NIP (PT2H (i + TBR));",
  },

  { "", "n", "ldc <REG_N>,<CREG_M>", "0100nnnnmmmm1110",
    "CREG (m) = R[n];",
    "/* FIXME: user mode */",
  },
  { "", "n", "ldc <REG_N>,SR", "0100nnnn00001110",
    "SET_SR (R[n]);",
    "/* FIXME: user mode */",
  },
  { "", "n", "ldc <REG_N>,MOD", "0100nnnn01011110",
    "SET_MOD (R[n]);",
  },
  { "", "n", "ldc <REG_N>,DBR", "0100nnnn11111010",
    "if (SR_MD)",
    "  DBR = R[n]; /* priv mode */",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
  },
  { "", "n", "ldc <REG_N>,SGR", "0100nnnn00111010",
    "if (SR_MD)",
    "  SGR = R[n]; /* priv mode */",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
  },
  { "", "n", "ldc <REG_N>,TBR", "0100nnnn01001010",
    "if (SR_MD)",	/* FIXME? */
    "  TBR = R[n]; /* priv mode */",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
  },
  { "n", "n", "ldc.l @@<REG_N>+,<CREG_M>", "0100nnnnmmmm0111",
    "MA (1);",
    "CREG (m) = RLAT (R[n]);",
    "R[n] += 4;",
    "/* FIXME: user mode */",
  },
  { "n", "n", "ldc.l @@<REG_N>+,SR", "0100nnnn00000111",
    "MA (1);",
    "SET_SR (RLAT (R[n]));",
    "R[n] += 4;",
    "/* FIXME: user mode */",
  },
  { "n", "n", "ldc.l @@<REG_N>+,MOD", "0100nnnn01010111",
    "MA (1);",
    "SET_MOD (RLAT (R[n]));",
    "R[n] += 4;",
  },
  { "n", "n", "ldc.l @@<REG_N>+,DBR", "0100nnnn11110110",
    "if (SR_MD)",
    "{ /* priv mode */",
    "  MA (1);",
    "  DBR = RLAT (R[n]);",
    "  R[n] += 4;",
    "}",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
  },
  { "n", "n", "ldc.l @@<REG_N>+,SGR", "0100nnnn00110110",
    "if (SR_MD)",
    "{ /* priv mode */",
    "  MA (1);",
    "  SGR = RLAT (R[n]);",
    "  R[n] += 4;",
    "}",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
  },

  /* sh-dsp */
  { "", "", "ldre @@(<disp>,PC)", "10001110i8p1....",
    "RE = SEXT (i) * 2 + 4 + PH2T (PC);",
  },
  { "", "", "ldrs @@(<disp>,PC)", "10001100i8p1....",
    "RS = SEXT (i) * 2 + 4 + PH2T (PC);",
  },

  /* sh4a */
  { "", "n", "ldrc <REG_N>", "0100nnnn00110100",
    "SET_RC (R[n]);",
    "loop = get_loop_bounds_ext (RS, RE, memory, mem_end, maskw, endianw);",
    "CHECK_INSN_PTR (insn_ptr);",
    "RE |= 1;",
  },
  { "", "", "ldrc #<imm>", "10001010i8*1....",
    "SET_RC (i);",
    "loop = get_loop_bounds_ext (RS, RE, memory, mem_end, maskw, endianw);",
    "CHECK_INSN_PTR (insn_ptr);",
    "RE |= 1;",
  },

  { "", "n", "lds <REG_N>,<SREG_M>", "0100nnnnssss1010",
    "SREG (m) = R[n];",
  },
  { "n", "n", "lds.l @@<REG_N>+,<SREG_M>", "0100nnnnssss0110",
    "MA (1);",
    "SREG (m) = RLAT (R[n]);",
    "R[n] += 4;",
  },
  /* sh2e / sh-dsp (lds <REG_N>,DSR) */
  { "", "n", "lds <REG_N>,FPSCR", "0100nnnn01101010",
    "SET_FPSCR (R[n]);",
  },
  /* sh2e / sh-dsp (lds.l @@<REG_N>+,DSR) */
  { "n", "n", "lds.l @@<REG_N>+,FPSCR", "0100nnnn01100110",
    "MA (1);",
    "SET_FPSCR (RLAT (R[n]));",
    "R[n] += 4;",
  },

  { "", "", "ldtlb", "0000000000111000",
    "/* We don't implement cache or tlb, so this is a noop.  */",
  },

  { "nm", "nm", "mac.l @@<REG_M>+,@@<REG_N>+", "0000nnnnmmmm1111",
    "macl (&R0, memory, n, m);",
  },

  { "nm", "nm", "mac.w @@<REG_M>+,@@<REG_N>+", "0100nnnnmmmm1111",
    "macw (&R0, memory, n, m, endianw);",
  },

  { "n", "", "mov #<imm>,<REG_N>", "1110nnnni8*1....",
    "R[n] = SEXT (i);",
  },
  { "n", "", "movi20 #<imm20>,<REG_N>", "0000nnnni8*10000",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "R[n] = ((i << 24) >> 12) | RIAT (nip);",
    "SET_NIP (nip + 2);	/* Consume 2 more bytes.  */",
  },
  { "n", "", "movi20s #<imm20>,<REG_N>", "0000nnnni8*10001",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "R[n] = ((((i & 0xf0) << 24) >> 12) | RIAT (nip)) << 8;",
    "SET_NIP (nip + 2);	/* Consume 2 more bytes.  */",
  },
  { "n", "m", "mov <REG_M>,<REG_N>", "0110nnnnmmmm0011",
    "R[n] = R[m];",
  },

  { "0", "", "mov.b @@(<disp>,GBR),R0", "11000100i8*1....",
    "MA (1);",
    "R0 = RSBAT (i + GBR);",
    "L (0);",
  },
  { "0", "m", "mov.b @@(<disp>,<REG_M>),R0", "10000100mmmmi4*1",
    "MA (1);",
    "R0 = RSBAT (i + R[m]);",
    "L (0);",
  },
  { "n", "0m", "mov.b @@(R0,<REG_M>),<REG_N>", "0000nnnnmmmm1100",
    "MA (1);",
    "R[n] = RSBAT (R0 + R[m]);",
    "L (n);",
  },
  { "nm", "m", "mov.b @@<REG_M>+,<REG_N>", "0110nnnnmmmm0100",
    "MA (1);",
    "R[n] = RSBAT (R[m]);",
    "R[m] += 1;",
    "L (n);",
  },
  { "0n", "n", "mov.b @@-<REG_N>,R0", "0100nnnn11001011",
    "MA (1);",
    "R[n] -= 1;",
    "R0 = RSBAT (R[n]);",
    "L (0);",
  },
  { "", "mn", "mov.b <REG_M>,@@<REG_N>", "0010nnnnmmmm0000",
    "MA (1);",
    "WBAT (R[n], R[m]);",
  },
  { "", "0", "mov.b R0,@@(<disp>,GBR)", "11000000i8*1....",
    "MA (1);",
    "WBAT (i + GBR, R0);",
  },
  { "", "m0", "mov.b R0,@@(<disp>,<REG_M>)", "10000000mmmmi4*1",
    "MA (1);",
    "WBAT (i + R[m], R0);",
  },
  { "", "mn0", "mov.b <REG_M>,@@(R0,<REG_N>)", "0000nnnnmmmm0100",
    "MA (1);",
    "WBAT (R[n] + R0, R[m]);",
  },
  { "n", "nm", "mov.b <REG_M>,@@-<REG_N>", "0010nnnnmmmm0100",
    /* Allow for the case where m == n.  */
    "int t = R[m];",
    "MA (1);",
    "R[n] -= 1;",
    "WBAT (R[n], t);",
  },
  { "n", "n0", "mov.b R0,@@<REG_N>+", "0100nnnn10001011",
    "MA (1);",
    "WBAT (R[n], R0);",
    "R[n] += 1;",
  },
  { "n", "m", "mov.b @@<REG_M>,<REG_N>", "0110nnnnmmmm0000",
    "MA (1);",
    "R[n] = RSBAT (R[m]);",
    "L (n);",
  },

  { "0", "", "mov.l @@(<disp>,GBR),R0", "11000110i8*4....",
    "MA (1);",
    "R0 = RLAT (i + GBR);",
    "L (0);",
  },
  { "n", "", "mov.l @@(<disp>,PC),<REG_N>", "1101nnnni8p4....",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "MA (1);",
    "R[n] = RLAT ((PH2T (PC) & ~3) + 4 + i);",
    "L (n);",
  },
  { "n", "m", "mov.l @@(<disp>,<REG_M>),<REG_N>", "0101nnnnmmmmi4*4",
    "MA (1);",
    "R[n] = RLAT (i + R[m]);",
    "L (n);",
  },
  { "n", "m0", "mov.l @@(R0,<REG_M>),<REG_N>", "0000nnnnmmmm1110",
    "MA (1);",
    "R[n] = RLAT (R0 + R[m]);",
    "L (n);",
  },
  { "nm", "m", "mov.l @@<REG_M>+,<REG_N>", "0110nnnnmmmm0110",
    "MA (1);",
    "R[n] = RLAT (R[m]);",
    "R[m] += 4;",
    "L (n);",
  },
  { "0n", "n", "mov.l @@-<REG_N>,R0", "0100nnnn11101011",
    "MA (1);",
    "R[n] -= 4;",
    "R0 = RLAT (R[n]);",
    "L (0);",
  },
  { "n", "m", "mov.l @@<REG_M>,<REG_N>", "0110nnnnmmmm0010",
    "MA (1);",
    "R[n] = RLAT (R[m]);",
    "L (n);",
  },
  { "", "0", "mov.l R0,@@(<disp>,GBR)", "11000010i8*4....",
    "MA (1);",
    "WLAT (i + GBR, R0);",
  },
  { "", "nm", "mov.l <REG_M>,@@(<disp>,<REG_N>)", "0001nnnnmmmmi4*4",
    "MA (1);",
    "WLAT (i + R[n], R[m]);",
  },
  { "", "nm0", "mov.l <REG_M>,@@(R0,<REG_N>)", "0000nnnnmmmm0110",
    "MA (1);",
    "WLAT (R0 + R[n], R[m]);",
  },
  { "n", "nm", "mov.l <REG_M>,@@-<REG_N>", "0010nnnnmmmm0110",
    /* Allow for the case where m == n.  */
    "int t = R[m];",
    "MA (1) ;",
    "R[n] -= 4;",
    "WLAT (R[n], t);",
  },
  { "n", "n0", "mov.l R0,@@<REG_N>+", "0100nnnn10101011",
    "MA (1) ;",
    "WLAT (R[n], R0);",
    "R[n] += 4;",
  },
  { "", "nm", "mov.l <REG_M>,@@<REG_N>", "0010nnnnmmmm0010",
    "MA (1);",
    "WLAT (R[n], R[m]);",
  },

  { "0", "", "mov.w @@(<disp>,GBR),R0", "11000101i8*2....",
    "MA (1);",
    "R0 = RSWAT (i + GBR);",
    "L (0);",
  },
  { "n", "", "mov.w @@(<disp>,PC),<REG_N>", "1001nnnni8p2....",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "MA (1);",
    "R[n] = RSWAT (PH2T (PC + 4 + i));",
    "L (n);",
  },
  { "0", "m", "mov.w @@(<disp>,<REG_M>),R0", "10000101mmmmi4*2",
    "MA (1);",
    "R0 = RSWAT (i + R[m]);",
    "L (0);",
  },
  { "n", "m0", "mov.w @@(R0,<REG_M>),<REG_N>", "0000nnnnmmmm1101",
    "MA (1);",
    "R[n] = RSWAT (R0 + R[m]);",
    "L (n);",
  },
  { "nm", "n", "mov.w @@<REG_M>+,<REG_N>", "0110nnnnmmmm0101",
    "MA (1);",
    "R[n] = RSWAT (R[m]);",
    "R[m] += 2;",
    "L (n);",
  },
  { "0n", "n", "mov.w @@-<REG_N>,R0", "0100nnnn11011011",
    "MA (1);",
    "R[n] -= 2;",
    "R0 = RSWAT (R[n]);",
    "L (0);",
  },
  { "n", "m", "mov.w @@<REG_M>,<REG_N>", "0110nnnnmmmm0001",
    "MA (1);",
    "R[n] = RSWAT (R[m]);",
    "L (n);",
  },
  { "", "0", "mov.w R0,@@(<disp>,GBR)", "11000001i8*2....",
    "MA (1);",
    "WWAT (i + GBR, R0);",
  },
  { "", "0m", "mov.w R0,@@(<disp>,<REG_M>)", "10000001mmmmi4*2",
    "MA (1);",
    "WWAT (i + R[m], R0);",
  },
  { "", "m0n", "mov.w <REG_M>,@@(R0,<REG_N>)", "0000nnnnmmmm0101",
    "MA (1);",
    "WWAT (R0 + R[n], R[m]);",
  },
  { "n", "mn", "mov.w <REG_M>,@@-<REG_N>", "0010nnnnmmmm0101",
    /* Allow for the case where m == n.  */
    "int t = R[m];",
    "MA (1);",
    "R[n] -= 2;",
    "WWAT (R[n], t);",
  },
  { "n", "0n", "mov.w R0,@@<REG_N>+", "0100nnnn10011011",
    "MA (1);",
    "WWAT (R[n], R0);",
    "R[n] += 2;",
  },
  { "", "nm", "mov.w <REG_M>,@@<REG_N>", "0010nnnnmmmm0001",
    "MA (1);",
    "WWAT (R[n], R[m]);",
  },

  { "0", "", "mova @@(<disp>,PC),R0", "11000111i8p4....",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "R0 = ((i + 4 + PH2T (PC)) & ~0x3);",
  },

  { "", "n0", "movca.l R0, @@<REG_N>", "0000nnnn11000011",
    "/* We don't simulate cache, so this insn is identical to mov.  */",
    "MA (1);",
    "WLAT (R[n], R[0]);",
  },

  { "", "n0", "movco.l R0, @@<REG_N>", "0000nnnn01110011", 
    "/* LDST -> T */",
    "SET_SR_T (LDST);",
    "/* if (T) R0 -> (Rn) */",
    "if (T)",
    "  WLAT (R[n], R[0]);",
    "/* 0 -> LDST */",
    "SET_LDST (0);",
  },

  { "0", "n", "movli.l @@<REG_N>, R0", "0000nnnn01100011", 
    "/* 1 -> LDST */",
    "SET_LDST (1);",
    "/* (Rn) -> R0 */",
    "R[0] = RLAT (R[n]);",
    "/* if (interrupt/exception) 0 -> LDST */",
    "/* (we don't simulate asynchronous interrupts/exceptions) */",
  },

  { "n", "", "movt <REG_N>", "0000nnnn00101001",
    "R[n] = T;",
  },
  { "", "", "movrt <REG_N>", "0000nnnn00111001",
    "R[n] = (T == 0);",	
  },
  { "0", "n", "movua.l @@<REG_N>,R0", "0100nnnn10101001",
    "int regn = R[n];",
    "int e = target_little_endian ? 3 : 0;",
    "MA (1);",
    "R[0] = (RBAT (regn + (0^e)) << 24) + (RBAT (regn + (1^e)) << 16) + ",
    "  (RBAT (regn + (2^e)) << 8) + RBAT (regn + (3^e));",
    "L (0);",
  },
  { "0n", "n", "movua.l @@<REG_N>+,R0", "0100nnnn11101001",
    "int regn = R[n];",
    "int e = target_little_endian ? 3 : 0;",
    "MA (1);",
    "R[0] = (RBAT (regn + (0^e)) << 24) + (RBAT (regn + (1^e)) << 16) + ",
    "  (RBAT (regn + (2^e)) << 8) + RBAT (regn + (3^e));",
    "R[n] += 4;",
    "L (0);",
  },
  { "", "mn", "mul.l <REG_M>,<REG_N>", "0000nnnnmmmm0111",
    "MACL = ((int) R[n]) * ((int) R[m]);",
  },
#if 0  /* FIXME: The above cast to int is not really portable.
	  It should be replaced by a SEXT32 macro.  */
  { "", "nm", "mul.l <REG_M>,<REG_N>", "0000nnnnmmmm0111",
    "MACL = R[n] * R[m];",
  },
#endif

  /* muls.w - see muls */
  { "", "mn", "muls <REG_M>,<REG_N>", "0010nnnnmmmm1111",
    "MACL = ((int) (short) R[n]) * ((int) (short) R[m]);",
  },

  /* mulu.w - see mulu */
  { "", "mn", "mulu <REG_M>,<REG_N>", "0010nnnnmmmm1110",
    "MACL = (((unsigned int) (unsigned short) R[n])",
    "        * ((unsigned int) (unsigned short) R[m]));",
  },

  { "n", "m", "neg <REG_M>,<REG_N>", "0110nnnnmmmm1011",
    "R[n] = - R[m];",
  },

  { "n", "m", "negc <REG_M>,<REG_N>", "0110nnnnmmmm1010",
    "ult = -T;",
    "SET_SR_T (ult > 0);",
    "R[n] = ult - R[m];",
    "SET_SR_T (T || (R[n] > ult));",
  },

  { "", "", "nop", "0000000000001001",
    "/* nop */",
  },

  { "n", "m", "not <REG_M>,<REG_N>", "0110nnnnmmmm0111",
    "R[n] = ~R[m];",
  },

  /* sh4a */
  { "", "n", "icbi @@<REG_N>", "0000nnnn11100011",
    "/* Except for the effect on the cache - which is not simulated -",
    "   this is like a nop.  */",
  },

  { "", "n", "ocbi @@<REG_N>", "0000nnnn10010011",
    "RSBAT (R[n]); /* Take exceptions like byte load, otherwise noop.  */",
    "/* FIXME: Cache not implemented */",
  },

  { "", "n", "ocbp @@<REG_N>", "0000nnnn10100011",
    "RSBAT (R[n]); /* Take exceptions like byte load, otherwise noop.  */",
    "/* FIXME: Cache not implemented */",
  },

  { "", "n", "ocbwb @@<REG_N>", "0000nnnn10110011",
    "RSBAT (R[n]); /* Take exceptions like byte load, otherwise noop.  */",
    "/* FIXME: Cache not implemented */",
  },

  { "0", "", "or #<imm>,R0", "11001011i8*1....",
    "R0 |= i;",
  },
  { "n", "m", "or <REG_M>,<REG_N>", "0010nnnnmmmm1011",
    "R[n] |= R[m];",
  },
  { "", "0", "or.b #<imm>,@@(R0,GBR)", "11001111i8*1....",
    "MA (1);",
    "WBAT (R0 + GBR, (RBAT (R0 + GBR) | i));",
  },

  { "", "n", "pref @@<REG_N>", "0000nnnn10000011",
    "/* Except for the effect on the cache - which is not simulated -",
    "   this is like a nop.  */",
  },

  /* sh4a */
  { "", "n", "prefi @@<REG_N>", "0000nnnn11010011",
    "/* Except for the effect on the cache - which is not simulated -",
    "   this is like a nop.  */",
  },

  /* sh4a */
  { "", "", "synco", "0000000010101011", 
    "/* Except for the effect on the pipeline - which is not simulated -", 
    "   this is like a nop.  */",
  },

  { "n", "n", "rotcl <REG_N>", "0100nnnn00100100",
    "ult = R[n] < 0;",
    "R[n] = (R[n] << 1) | T;",
    "SET_SR_T (ult);",
  },

  { "n", "n", "rotcr <REG_N>", "0100nnnn00100101",
    "ult = R[n] & 1;",
    "R[n] = (UR[n] >> 1) | (T << 31);",
    "SET_SR_T (ult);",
  },

  { "n", "n", "rotl <REG_N>", "0100nnnn00000100",
    "SET_SR_T (R[n] < 0);",
    "R[n] <<= 1;",
    "R[n] |= T;",
  },

  { "n", "n", "rotr <REG_N>", "0100nnnn00000101",
    "SET_SR_T (R[n] & 1);",
    "R[n] = UR[n] >> 1;",
    "R[n] |= (T << 31);",
  },

  { "", "", "rte", "0000000000101011", 
#if 0
    /* SH-[12] */
    "int tmp = PC;",
    "SET_NIP (PT2H (RLAT (R[15]) + 2));",
    "R[15] += 4;",
    "SET_SR (RLAT (R[15]) & 0x3f3);",
    "R[15] += 4;",
    "Delay_Slot (PC + 2);",
#else
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "SET_SR (SSR);",
    "SET_NIP (PT2H (SPC));",
    "cycles += 2;",
    "Delay_Slot (PC + 2);",
#endif
  },

  { "", "", "rts", "0000000000001011",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "SET_NIP (PT2H (PR));",
    "cycles += 2;",
    "Delay_Slot (PC + 2);",
  },
  { "", "", "rts/n", "0000000001101011",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "SET_NIP (PT2H (PR));",
  },
  { "0", "n", "rtv/n <REG_N>", "0000nnnn01111011",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "R0 = R[n];",
    "L (0);",
    "SET_NIP (PT2H (PR));",
  },

  /* sh4a */
  { "", "", "setdmx", "0000000010011000",
    "saved_state.asregs.cregs.named.sr |=  SR_MASK_DMX;"
    "saved_state.asregs.cregs.named.sr &= ~SR_MASK_DMY;"
  },

  /* sh4a */
  { "", "", "setdmy", "0000000011001000",
    "saved_state.asregs.cregs.named.sr |=  SR_MASK_DMY;"
    "saved_state.asregs.cregs.named.sr &= ~SR_MASK_DMX;"
  },

  /* sh-dsp */
  { "", "n", "setrc <REG_N>", "0100nnnn00010100",
    "SET_RC (R[n]);",
  },
  { "", "", "setrc #<imm>", "10000010i8*1....",
    /* It would be more realistic to let loop_start point to some static
       memory that contains an illegal opcode and then give a bus error when
       the loop is eventually encountered, but it seems not only simpler,
       but also more debugging-friendly to just catch the failure here.  */
    "if (BUSERROR (RS | RE, maskw))",
    "  RAISE_EXCEPTION (SIGILL);",
    "else {",
    "  SET_RC (i);",
    "  loop = get_loop_bounds (RS, RE, memory, mem_end, maskw, endianw);",
    "  CHECK_INSN_PTR (insn_ptr);",
    "}",
  },

  { "", "", "sets", "0000000001011000",
    "SET_SR_S (1);",
  },

  { "", "", "sett", "0000000000011000",
    "SET_SR_T (1);",
  },

  { "n", "mn", "shad <REG_M>,<REG_N>", "0100nnnnmmmm1100",
    "R[n] = (R[m] < 0) ? (R[m]&0x1f ? R[n] >> ((-R[m])&0x1f) : R[n] >> 31) : (R[n] << (R[m] & 0x1f));",
  },

  { "n", "n", "shal <REG_N>", "0100nnnn00100000",
    "SET_SR_T (R[n] < 0);",
    "R[n] <<= 1;",
  },

  { "n", "n", "shar <REG_N>", "0100nnnn00100001",
    "SET_SR_T (R[n] & 1);",
    "R[n] = R[n] >> 1;",
  },

  { "n", "mn", "shld <REG_M>,<REG_N>", "0100nnnnmmmm1101",
    "R[n] = (R[m] < 0) ? (R[m]&0x1f ? UR[n] >> ((-R[m])&0x1f) : 0): (R[n] << (R[m] & 0x1f));",
  },

  { "n", "n", "shll <REG_N>", "0100nnnn00000000",
    "SET_SR_T (R[n] < 0);",
    "R[n] <<= 1;",
  },

  { "n", "n", "shll2 <REG_N>", "0100nnnn00001000",
    "R[n] <<= 2;",
  },
  { "n", "n", "shll8 <REG_N>", "0100nnnn00011000",
    "R[n] <<= 8;",
  },
  { "n", "n", "shll16 <REG_N>", "0100nnnn00101000",
    "R[n] <<= 16;",
  },

  { "n", "n", "shlr <REG_N>", "0100nnnn00000001",
    "SET_SR_T (R[n] & 1);",
    "R[n] = UR[n] >> 1;",
  },

  { "n", "n", "shlr2 <REG_N>", "0100nnnn00001001",
    "R[n] = UR[n] >> 2;",
  },
  { "n", "n", "shlr8 <REG_N>", "0100nnnn00011001",
    "R[n] = UR[n] >> 8;",
  },
  { "n", "n", "shlr16 <REG_N>", "0100nnnn00101001",
    "R[n] = UR[n] >> 16;",
  },

  { "", "", "sleep", "0000000000011011",
    "nip += trap (0xc3, &R0, PC, memory, maskl, maskw, endianw);",
  },

  { "n", "", "stc <CREG_M>,<REG_N>", "0000nnnnmmmm0010",
    "R[n] = CREG (m);",
  },

  { "n", "", "stc SGR,<REG_N>", "0000nnnn00111010",
    "if (SR_MD)",
    "  R[n] = SGR; /* priv mode */",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
  },
  { "n", "", "stc DBR,<REG_N>", "0000nnnn11111010",
    "if (SR_MD)",
    "  R[n] = DBR; /* priv mode */",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
  },
  { "n", "", "stc TBR,<REG_N>", "0000nnnn01001010",
    "if (SR_MD)",	/* FIXME? */
    "  R[n] = TBR; /* priv mode */",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
  },
  { "n", "n", "stc.l <CREG_M>,@@-<REG_N>", "0100nnnnmmmm0011",
    "MA (1);",
    "R[n] -= 4;",
    "WLAT (R[n], CREG (m));",
  },
  { "n", "n", "stc.l SGR,@@-<REG_N>", "0100nnnn00110010",
    "if (SR_MD)",
    "{ /* priv mode */",
    "  MA (1);",
    "  R[n] -= 4;",
    "  WLAT (R[n], SGR);",
    "}",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
  },
  { "n", "n", "stc.l DBR,@@-<REG_N>", "0100nnnn11110010",
    "if (SR_MD)",
    "{ /* priv mode */",
    "  MA (1);",
    "  R[n] -= 4;",
    "  WLAT (R[n], DBR);",
    "}",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
  },

  { "n", "", "sts <SREG_M>,<REG_N>", "0000nnnnssss1010",
    "R[n] = SREG (m);",
  },
  { "n", "n", "sts.l <SREG_M>,@@-<REG_N>", "0100nnnnssss0010",
    "MA (1);",
    "R[n] -= 4;",
    "WLAT (R[n], SREG (m));",
  },

  { "n", "nm", "sub <REG_M>,<REG_N>", "0011nnnnmmmm1000",
    "R[n] -= R[m];",
  },

  { "n", "nm", "subc <REG_M>,<REG_N>", "0011nnnnmmmm1010",
    "ult = R[n] - T;",
    "SET_SR_T (ult > R[n]);",
    "R[n] = ult - R[m];",
    "SET_SR_T (T || (R[n] > ult));",
  },

  { "n", "nm", "subv <REG_M>,<REG_N>", "0011nnnnmmmm1011",
    "ult = R[n] - R[m];",
    "SET_SR_T (((R[n] ^ R[m]) & (ult ^ R[n])) >> 31);",
    "R[n] = ult;",
  },

  { "n", "nm", "swap.b <REG_M>,<REG_N>", "0110nnnnmmmm1000",
    "R[n] = ((R[m] & 0xffff0000)",
    "        | ((R[m] << 8) & 0xff00)",
    "        | ((R[m] >> 8) & 0x00ff));",
  },
  { "n", "nm", "swap.w <REG_M>,<REG_N>", "0110nnnnmmmm1001",
    "R[n] = (((R[m] << 16) & 0xffff0000)",
    "        | ((R[m] >> 16) & 0x00ffff));",
  },

  { "", "n", "tas.b @@<REG_N>", "0100nnnn00011011",
    "MA (1);",
    "ult = RBAT (R[n]);",
    "SET_SR_T (ult == 0);",
    "WBAT (R[n],ult|0x80);",
  },

  { "0", "", "trapa #<imm>", "11000011i8*1....", 
    "long imm = 0xff & i;",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "if (i < 20 || i == 33 || i == 34 || i == 0xc3)",
    "  nip += trap (i, &R0, PC, memory, maskl, maskw, endianw);",
#if 0
    "else {",
    /* SH-[12] */
    "  R[15] -= 4;",
    "  WLAT (R[15], GET_SR ());",
    "  R[15] -= 4;",
    "  WLAT (R[15], PH2T (PC + 2));",
#else
    "else if (!SR_BL) {",
    "  SSR = GET_SR ();",
    "  SPC = PH2T (PC + 2);",
    "  SET_SR (GET_SR () | SR_MASK_MD | SR_MASK_BL | SR_MASK_RB);",
    "  /* FIXME: EXPEVT = 0x00000160; */",
#endif
    "  SET_NIP (PT2H (RLAT (VBR + (imm<<2))));",
    "}",
  },

  { "", "mn", "tst <REG_M>,<REG_N>", "0010nnnnmmmm1000",
    "SET_SR_T ((R[n] & R[m]) == 0);",
  },
  { "", "0", "tst #<imm>,R0", "11001000i8*1....",
    "SET_SR_T ((R0 & i) == 0);",
  },
  { "", "0", "tst.b #<imm>,@@(R0,GBR)", "11001100i8*1....",
    "MA (1);",
    "SET_SR_T ((RBAT (GBR+R0) & i) == 0);",
  },

  { "", "0", "xor #<imm>,R0", "11001010i8*1....",
    "R0 ^= i;",
  },
  { "n", "mn", "xor <REG_M>,<REG_N>", "0010nnnnmmmm1010",
    "R[n] ^= R[m];",
  },
  { "", "0", "xor.b #<imm>,@@(R0,GBR)", "11001110i8*1....",
    "MA (1);",
    "ult = RBAT (GBR+R0);",
    "ult ^= i;",
    "WBAT (GBR + R0, ult);",
  },

  { "n", "nm", "xtrct <REG_M>,<REG_N>", "0010nnnnmmmm1101",
    "R[n] = (((R[n] >> 16) & 0xffff)",
    "        | ((R[m] << 16) & 0xffff0000));",
  },

#if 0
  { "divs.l <REG_M>,<REG_N>", "0100nnnnmmmm1110",
    "divl (0, R[n], R[m]);",
  },
  { "divu.l <REG_M>,<REG_N>", "0100nnnnmmmm1101",
    "divl (0, R[n], R[m]);",
  },
#endif

  {0, 0}};

op movsxy_tab[] =
{
/* If this is disabled, the simulator speeds up by about 12% on a
   450 MHz PIII - 9% with ACE_FAST.
   Maybe we should have separate simulator loops?  */
#if 1
  { "n", "n", "movs.w @@-<REG_N>,<DSP_REG_M>", "111101NNMMMM0000",
    "MA (1);",
    "R[n] -= 2;",
    "DSP_R (m) = RSWAT (R[n]) << 16;",
    "DSP_GRD (m) = SIGN32 (DSP_R (m));",
  },
  { "", "n",  "movs.w @@<REG_N>,<DSP_REG_M>",  "111101NNMMMM0100",
    "MA (1);",
    "DSP_R (m) = RSWAT (R[n]) << 16;",
    "DSP_GRD (m) = SIGN32 (DSP_R (m));",
  },
  { "n", "n", "movs.w @@<REG_N>+,<DSP_REG_M>", "111101NNMMMM1000",
    "MA (1);",
    "DSP_R (m) = RSWAT (R[n]) << 16;",
    "DSP_GRD (m) = SIGN32 (DSP_R (m));",
    "R[n] += 2;",
  },
  { "n", "n8","movs.w @@<REG_N>+REG_8,<DSP_REG_M>", "111101NNMMMM1100",
    "MA (1);",
    "DSP_R (m) = RSWAT (R[n]) << 16;",
    "DSP_GRD (m) = SIGN32 (DSP_R (m));",
    "R[n] += R[8];",
  },
  { "n", "n", "movs.w @@-<REG_N>,<DSP_GRD_M>", "111101NNGGGG0000",
    "MA (1);",
    "R[n] -= 2;",
    "DSP_R (m) = RSWAT (R[n]);",
  },
  { "", "n",  "movs.w @@<REG_N>,<DSP_GRD_M>",  "111101NNGGGG0100",
    "MA (1);",
    "DSP_R (m) = RSWAT (R[n]);",
  },
  { "n", "n", "movs.w @@<REG_N>+,<DSP_GRD_M>", "111101NNGGGG1000",
    "MA (1);",
    "DSP_R (m) = RSWAT (R[n]);",
    "R[n] += 2;",
  },
  { "n", "n8","movs.w @@<REG_N>+REG_8,<DSP_GRD_M>", "111101NNGGGG1100",
    "MA (1);",
    "DSP_R (m) = RSWAT (R[n]);",
    "R[n] += R[8];",
  },
  { "n", "n", "movs.w <DSP_REG_M>,@@-<REG_N>", "111101NNMMMM0001",
    "MA (1);",
    "R[n] -= 2;",
    "WWAT (R[n], DSP_R (m) >> 16);",
  },
  { "", "n",  "movs.w <DSP_REG_M>,@@<REG_N>",  "111101NNMMMM0101",
    "MA (1);",
    "WWAT (R[n], DSP_R (m) >> 16);",
  },
  { "n", "n", "movs.w <DSP_REG_M>,@@<REG_N>+", "111101NNMMMM1001",
    "MA (1);",
    "WWAT (R[n], DSP_R (m) >> 16);",
    "R[n] += 2;",
  },
  { "n", "n8","movs.w <DSP_REG_M>,@@<REG_N>+REG_8", "111101NNMMMM1101",
    "MA (1);",
    "WWAT (R[n], DSP_R (m) >> 16);",
    "R[n] += R[8];",
  },
  { "n", "n", "movs.w <DSP_GRD_M>,@@-<REG_N>", "111101NNGGGG0001",
    "MA (1);",
    "R[n] -= 2;",
    "WWAT (R[n], SEXT (DSP_R (m)));",
  },
  { "", "n",  "movs.w <DSP_GRD_M>,@@<REG_N>",  "111101NNGGGG0101",
    "MA (1);",
    "WWAT (R[n], SEXT (DSP_R (m)));",
  },
  { "n", "n", "movs.w <DSP_GRD_M>,@@<REG_N>+", "111101NNGGGG1001",
    "MA (1);",
    "WWAT (R[n], SEXT (DSP_R (m)));",
    "R[n] += 2;",
  },
  { "n", "n8","movs.w <DSP_GRD_M>,@@<REG_N>+REG_8", "111101NNGGGG1101",
    "MA (1);",
    "WWAT (R[n], SEXT (DSP_R (m)));",
    "R[n] += R[8];",
  },
  { "n", "n", "movs.l @@-<REG_N>,<DSP_REG_M>", "111101NNMMMM0010",
    "MA (1);",
    "R[n] -= 4;",
    "DSP_R (m) = RLAT (R[n]);",
    "DSP_GRD (m) = SIGN32 (DSP_R (m));",
  },
  { "", "n",  "movs.l @@<REG_N>,<DSP_REG_M>",  "111101NNMMMM0110",
    "MA (1);",
    "DSP_R (m) = RLAT (R[n]);",
    "DSP_GRD (m) = SIGN32 (DSP_R (m));",
  },
  { "n", "n", "movs.l @@<REG_N>+,<DSP_REG_M>", "111101NNMMMM1010",
    "MA (1);",
    "DSP_R (m) = RLAT (R[n]);",
    "DSP_GRD (m) = SIGN32 (DSP_R (m));",
    "R[n] += 4;",
  },
  { "n", "n8","movs.l @@<REG_N>+REG_8,<DSP_REG_M>", "111101NNMMMM1110",
    "MA (1);",
    "DSP_R (m) = RLAT (R[n]);",
    "DSP_GRD (m) = SIGN32 (DSP_R (m));",
    "R[n] += R[8];",
  },
  { "n", "n", "movs.l <DSP_REG_M>,@@-<REG_N>", "111101NNMMMM0011",
    "MA (1);",
    "R[n] -= 4;",
    "WLAT (R[n], DSP_R (m));",
  },
  { "", "n",  "movs.l <DSP_REG_M>,@@<REG_N>",  "111101NNMMMM0111",
    "MA (1);",
    "WLAT (R[n], DSP_R (m));",
  },
  { "n", "n", "movs.l <DSP_REG_M>,@@<REG_N>+", "111101NNMMMM1011",
    "MA (1);",
    "WLAT (R[n], DSP_R (m));",
    "R[n] += 4;",
  },
  { "n", "n8","movs.l <DSP_REG_M>,@@<REG_N>+REG_8", "111101NNMMMM1111",
    "MA (1);",
    "WLAT (R[n], DSP_R (m));",
    "R[n] += R[8];",
  },
  { "n", "n", "movs.l <DSP_GRD_M>,@@-<REG_N>", "111101NNGGGG0011",
    "MA (1);",
    "R[n] -= 4;",
    "WLAT (R[n], SEXT (DSP_R (m)));",
  },
  { "", "n",  "movs.l <DSP_GRD_M>,@@<REG_N>",  "111101NNGGGG0111",
    "MA (1);",
    "WLAT (R[n], SEXT (DSP_R (m)));",
  },
  { "n", "n", "movs.l <DSP_GRD_M>,@@<REG_N>+", "111101NNGGGG1011",
    "MA (1);",
    "WLAT (R[n], SEXT (DSP_R (m)));",
    "R[n] += 4;",
  },
  { "n", "n8","movs.l <DSP_GRD_M>,@@<REG_N>+REG_8", "111101NNGGGG1111",
    "MA (1);",
    "WLAT (R[n], SEXT (DSP_R (m)));",
    "R[n] += R[8];",
  },
  { "", "n", "movx.w @@<REG_xy>,<DSP_XY>",   "111100xyXY0001??",
    "DSP_R (m) = RSWAT (R[n]) << 16;",
    "if (iword & 3)",
    "  {",
    "    iword &= 0xfd53; goto top;",
    "  }",
  },
  { "", "n", "movx.l @@<REG_xy>,<DSP_XY>",   "111100xyXY010100",
    "DSP_R (m) = RLAT (R[n]);",
  },
  { "n", "n", "movx.w @@<REG_xy>+,<DSP_XY>", "111100xyXY0010??",
    "DSP_R (m) = RSWAT (R[n]) << 16;",
    "R[n] += ((R[n] & 0xffff) == MOD_ME) ? MOD_DELTA : 2;",
    "if (iword & 3)",
    "  {",
    "    iword &= 0xfd53; goto top;",
    "  }",
  },
  { "n", "n", "movx.l @@<REG_xy>+,<DSP_XY>", "111100xyXY011000",
    "DSP_R (m) = RLAT (R[n]);",
    "R[n] += ((R[n] & 0xffff) == MOD_ME) ? MOD_DELTA : 4;",
  },
  { "n", "n8","movx.w @@<REG_xy>+REG_8,<DSP_XY>", "111100xyXY0011??",
    "DSP_R (m) = RSWAT (R[n]) << 16;",
    "R[n] += ((R[n] & 0xffff) == MOD_ME) ? MOD_DELTA : R[8];",
    "if (iword & 3)",
    "  {",
    "    iword &= 0xfd53; goto top;",
    "  }",
  },
  { "n", "n8","movx.l @@<REG_xy>+REG_8,<DSP_XY>", "111100xyXY011100",
    "DSP_R (m) = RLAT (R[n]);",
    "R[n] += ((R[n] & 0xffff) == MOD_ME) ? MOD_DELTA : R[8];",
  },
  { "", "n", "movx.w <DSP_Ax>,@@<REG_xy>",   "111100xyax1001??",
    "WWAT (R[n], DSP_R (m) >> 16);",
    "if (iword & 3)",
    "  {",
    "    iword &= 0xfd53; goto top;",
    "  }",
  },
  { "", "n", "movx.l <DSP_Ax>,@@<REG_xy>",   "111100xyax110100",
    "WLAT (R[n], DSP_R (m));",
  },
  { "n", "n", "movx.w <DSP_Ax>,@@<REG_xy>+", "111100xyax1010??",
    "WWAT (R[n], DSP_R (m) >> 16);",
    "R[n] += ((R[n] & 0xffff) == MOD_ME) ? MOD_DELTA : 2;",
    "if (iword & 3)",
    "  {",
    "    iword &= 0xfd53; goto top;",
    "  }",
  },
  { "n", "n", "movx.l <DSP_Ax>,@@<REG_xy>+", "111100xyax111000",
    "WLAT (R[n], DSP_R (m));",
    "R[n] += ((R[n] & 0xffff) == MOD_ME) ? MOD_DELTA : 4;",
  },
  { "n", "n8","movx.w <DSP_Ax>,@@<REG_xy>+REG_8","111100xyax1011??",
    "WWAT (R[n], DSP_R (m) >> 16);",
    "R[n] += ((R[n] & 0xffff) == MOD_ME) ? MOD_DELTA : R[8];",
    "if (iword & 3)",
    "  {",
    "    iword &= 0xfd53; goto top;",
    "  }",
  },
  { "n", "n8","movx.l <DSP_Ax>,@@<REG_xy>+REG_8","111100xyax111100",
    "WLAT (R[n], DSP_R (m));",
    "R[n] += ((R[n] & 0xffff) == MOD_ME) ? MOD_DELTA : R[8];",
  },
  { "", "n", "movy.w @@<REG_yx>,<DSP_YX>",   "111100yxYX000001",
    "DSP_R (m) = RSWAT (R[n]) << 16;",
  },
  { "n", "n", "movy.w @@<REG_yx>+,<DSP_YX>", "111100yxYX000010",
    "DSP_R (m) = RSWAT (R[n]) << 16;",
    "R[n] += ((R[n] | ~0xffff) == MOD_ME) ? MOD_DELTA : 2;",
  },
  { "n", "n9","movy.w @@<REG_yx>+REG_9,<DSP_YX>", "111100yxYX000011",
    "DSP_R (m) = RSWAT (R[n]) << 16;",
    "R[n] += ((R[n] | ~0xffff) == MOD_ME) ? MOD_DELTA : R[9];",
  },
  { "", "n", "movy.w <DSP_Ay>,@@<REG_yx>",   "111100yxAY010001",
    "WWAT (R[n], DSP_R (m) >> 16);",
  },
  { "n", "n", "movy.w <DSP_Ay>,@@<REG_yx>+", "111100yxAY010010",
    "WWAT (R[n], DSP_R (m) >> 16);",
    "R[n] += ((R[n] | ~0xffff) == MOD_ME) ? MOD_DELTA : 2;",
  },
  { "n", "n9", "movy.w <DSP_Ay>,@@<REG_yx>+REG_9", "111100yxAY010011",
    "WWAT (R[n], DSP_R (m) >> 16);",
    "R[n] += ((R[n] | ~0xffff) == MOD_ME) ? MOD_DELTA : R[9];",
  },
  { "", "n", "movy.l @@<REG_yx>,<DSP_YX>",   "111100yxYX100001",
    "DSP_R (m) = RLAT (R[n]);",
  },
  { "n", "n", "movy.l @@<REG_yx>+,<DSP_YX>", "111100yxYX100010",
    "DSP_R (m) = RLAT (R[n]);",
    "R[n] += ((R[n] | ~0xffff) == MOD_ME) ? MOD_DELTA : 4;",
  },
  { "n", "n9","movy.l @@<REG_yx>+REG_9,<DSP_YX>", "111100yxYX100011",
    "DSP_R (m) = RLAT (R[n]);",
    "R[n] += ((R[n] | ~0xffff) == MOD_ME) ? MOD_DELTA : R[9];",
  },
  { "", "n", "movy.l <DSP_Ay>,@@<REG_yx>",   "111100yxAY110001",
    "WLAT (R[n], DSP_R (m));",
  },
  { "n", "n", "movy.l <DSP_Ay>,@@<REG_yx>+", "111100yxAY110010",
    "WLAT (R[n], DSP_R (m));",
    "R[n] += ((R[n] | ~0xffff) == MOD_ME) ? MOD_DELTA : 4;",
  },
  { "n", "n9", "movy.l <DSP_Ay>,@@<REG_yx>+REG_9", "111100yxAY110011",
    "WLAT (R[n], DSP_R (m));",
    "R[n] += ((R[n] | ~0xffff) == MOD_ME) ? MOD_DELTA : R[9];",
  },
  { "", "", "nopx nopy", "1111000000000000",
    "/* nop */",
  },
  { "", "", "ppi", "1111100000000000",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "ppi_insn (RIAT (nip));",
    "SET_NIP (nip + 2);",
    "iword &= 0xf7ff; goto top;",
  },
#endif
  {0, 0}};

op ppi_tab[] =
{
  { "","", "pshl #<imm>,dz",	"00000iiim16.zzzz",
    "int Sz = DSP_R (z) & 0xffff0000;",
    "",
    "if (i <= 16)",
    "  res = Sz << i;",
    "else if (i >= 128 - 16)",
    "  res = (unsigned) Sz >> 128 - i;	/* no sign extension */",
    "else",
    "  {",
    "    RAISE_EXCEPTION (SIGILL);",
    "    return;",
    "  }",
    "res &= 0xffff0000;",
    "res_grd = 0;",
    "goto logical;",
  },
  { "","", "psha #<imm>,dz",	"00010iiim32.zzzz",
    "int Sz = DSP_R (z);",
    "int Sz_grd = GET_DSP_GRD (z);",
    "",
    "if (i <= 32)",
    "  {",
    "    if (i == 32)",
    "      {",
    "        res = 0;",
    "        res_grd = Sz;",
    "      }",
    "    else",
    "      {",
    "        res = Sz << i;",
    "        res_grd = Sz_grd << i | (unsigned) Sz >> 32 - i;",
    "      }",
    "    res_grd = SEXT (res_grd);",
    "    carry = res_grd & 1;",
    "  }",
    "else if (i >= 96)",
    "  {",
    "    i = 128 - i;",
    "    if (i == 32)",
    "      {",
    "        res_grd = SIGN32 (Sz_grd);",
    "        res = Sz_grd;",
    "      }",
    "    else",
    "      {",
    "        res = Sz >> i | Sz_grd << 32 - i;",
    "        res_grd = Sz_grd >> i;",
    "      }",
    "    carry = Sz >> (i - 1) & 1;",
    "  }",
    "else",
    "  {",
    "    RAISE_EXCEPTION (SIGILL);",
    "    return;",
    "  }",
    "COMPUTE_OVERFLOW;",
    "greater_equal = 0;",
  },
  { "","", "pmuls Se,Sf,Dg",	"0100eeffxxyygguu",
    "res = (DSP_R (e) >> 16) * (DSP_R (f) >> 16) * 2;",
    "if (res == 0x80000000)",
    "  res = 0x7fffffff;",
    "DSP_R (g) = res;",
    "DSP_GRD (g) = SIGN32 (res);",
    "return;",
  },
  { "","", "psub Sx,Sy,Du pmuls Se,Sf,Dg",	"0110eeffxxyygguu",
    "int Sx = DSP_R (x);",
    "int Sx_grd = GET_DSP_GRD (x);",
    "int Sy = DSP_R (y);",
    "int Sy_grd = SIGN32 (Sy);",
    "",
    "res = (DSP_R (e) >> 16) * (DSP_R (f) >> 16) * 2;",
    "if (res == 0x80000000)",
    "  res = 0x7fffffff;",
    "DSP_R (g) = res;",
    "DSP_GRD (g) = SIGN32 (res);",
    "",
    "z = u;",
    "res = Sx - Sy;",
    "carry = (unsigned) res > (unsigned) Sx;",
    "res_grd = Sx_grd - Sy_grd - carry;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
  },
  { "","", "padd Sx,Sy,Du pmuls Se,Sf,Dg",	"0111eeffxxyygguu",
    "int Sx = DSP_R (x);",
    "int Sx_grd = GET_DSP_GRD (x);",
    "int Sy = DSP_R (y);",
    "int Sy_grd = SIGN32 (Sy);",
    "",
    "res = (DSP_R (e) >> 16) * (DSP_R (f) >> 16) * 2;",
    "if (res == 0x80000000)",
    "  res = 0x7fffffff;",
    "DSP_R (g) = res;",
    "DSP_GRD (g) = SIGN32 (res);",
    "",
    "z = u;",
    "res = Sx + Sy;",
    "carry = (unsigned) res < (unsigned) Sx;",
    "res_grd = Sx_grd + Sy_grd + carry;",
    "COMPUTE_OVERFLOW;",
  },
  { "","", "psubc Sx,Sy,Dz",		"10100000xxyyzzzz",
    "int Sx = DSP_R (x);",
    "int Sx_grd = GET_DSP_GRD (x);",
    "int Sy = DSP_R (y);",
    "int Sy_grd = SIGN32 (Sy);",
    "",
    "res = Sx - Sy - (DSR & 1);",
    "carry = (unsigned) res > (unsigned) Sx || (res == Sx && Sy);",
    "res_grd = Sx_grd + Sy_grd + carry;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
    "DSR &= ~0xf1;\n",
    "if (res || res_grd)\n",
    "  DSR |= greater_equal | res_grd >> 2 & DSR_MASK_N | overflow;\n",
    "else\n",
    "  DSR |= DSR_MASK_Z | overflow;\n",
    "DSR |= carry;\n",
    "goto assign_z;\n",
  },
  { "","", "paddc Sx,Sy,Dz",	"10110000xxyyzzzz",
    "int Sx = DSP_R (x);",
    "int Sx_grd = GET_DSP_GRD (x);",
    "int Sy = DSP_R (y);",
    "int Sy_grd = SIGN32 (Sy);",
    "",
    "res = Sx + Sy + (DSR & 1);",
    "carry = (unsigned) res < (unsigned) Sx || (res == Sx && Sy);",
    "res_grd = Sx_grd + Sy_grd + carry;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
    "DSR &= ~0xf1;\n",
    "if (res || res_grd)\n",
    "  DSR |= greater_equal | res_grd >> 2 & DSR_MASK_N | overflow;\n",
    "else\n",
    "  DSR |= DSR_MASK_Z | overflow;\n",
    "DSR |= carry;\n",
    "goto assign_z;\n",
  },
  { "","", "pcmp Sx,Sy",	"10000100xxyyzzzz",
    "int Sx = DSP_R (x);",
    "int Sx_grd = GET_DSP_GRD (x);",
    "int Sy = DSP_R (y);",
    "int Sy_grd = SIGN32 (Sy);",
    "",
    "z = 17; /* Ignore result.  */",
    "res = Sx - Sy;",
    "carry = (unsigned) res > (unsigned) Sx;",
    "res_grd = Sx_grd - Sy_grd - carry;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
  },
  { "","", "pwsb Sx,Sy,Dz",	"10100100xxyyzzzz",
  },
  { "","", "pwad Sx,Sy,Dz",	"10110100xxyyzzzz",
  },
  { "","", "(if cc) pabs Sx,Dz",	"100010ccxx01zzzz",
    "/* FIXME: duplicate code pabs.  */",
    "res = DSP_R (x);",
    "res_grd = GET_DSP_GRD (x);",
    "if (res >= 0)",
    "  carry = 0;",
    "else",
    "  {",
    "    res = -res;",
    "    carry = (res != 0); /* The manual has a bug here.  */", 
    "    res_grd = -res_grd - carry;", 
    "  }",
    "COMPUTE_OVERFLOW;",
    "/* ??? The re-computing of overflow after",
    "   saturation processing is specific to pabs.  */",
    "overflow = res_grd != SIGN32 (res) ? DSR_MASK_V : 0;",
    "ADD_SUB_GE;",
  },
  { "","", "pabs Sx,Dz",	"10001000xx..zzzz",
    "res = DSP_R (x);",
    "res_grd = GET_DSP_GRD (x);",
    "if (res >= 0)",
    "  carry = 0;",
    "else",
    "  {",
    "    res = -res;",
    "    carry = (res != 0); /* The manual has a bug here.  */", 
    "    res_grd = -res_grd - carry;", 
    "  }",
    "COMPUTE_OVERFLOW;",
    "/* ??? The re-computing of overflow after",
    "   saturation processing is specific to pabs.  */",
    "overflow = res_grd != SIGN32 (res) ? DSR_MASK_V : 0;",
    "ADD_SUB_GE;",
  },

  { "","", "(if cc) prnd Sx,Dz",	"100110ccxx01zzzz",
    "/* FIXME: duplicate code prnd.  */",
    "int Sx = DSP_R (x);",
    "int Sx_grd = GET_DSP_GRD (x);",
    "",
    "res = (Sx + 0x8000) & 0xffff0000;",
    "carry = (unsigned) res < (unsigned) Sx;",
    "res_grd = Sx_grd + carry;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
  },
  { "","", "prnd Sx,Dz",	"10011000xx..zzzz",
    "int Sx = DSP_R (x);",
    "int Sx_grd = GET_DSP_GRD (x);",
    "",
    "res = (Sx + 0x8000) & 0xffff0000;",
    "carry = (unsigned) res < (unsigned) Sx;",
    "res_grd = Sx_grd + carry;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
  },

  { "","", "(if cc) pabs Sy,Dz",	"101010cc01yyzzzz",
    "/* FIXME: duplicate code pabs.  */",
    "res = DSP_R (y);",
    "res_grd = 0;",
    "overflow = 0;",
    "greater_equal = DSR_MASK_G;",
    "if (res >= 0)",
    "  carry = 0;",
    "else",
    "  {",
    "    res = -res;",
    "    carry = 1;",
    "    if (res < 0)",
    "      {",
    "        if (S)",
    "          res = 0x7fffffff;",
    "        else",
    "          {",
    "            overflow = DSR_MASK_V;",
    "            greater_equal = 0;",
    "          }",
    "      }",
    "  }",
  },
  { "","", "pabs Sy,Dz",	"10101000..yyzzzz",
    "res = DSP_R (y);",
    "res_grd = 0;",
    "overflow = 0;",
    "greater_equal = DSR_MASK_G;",
    "if (res >= 0)",
    "  carry = 0;",
    "else",
    "  {",
    "    res = -res;",
    "    carry = 1;",
    "    if (res < 0)",
    "      {",
    "        if (S)",
    "          res = 0x7fffffff;",
    "        else",
    "          {",
    "            overflow = DSR_MASK_V;",
    "            greater_equal = 0;",
    "          }",
    "      }",
    "  }",
  },
  { "","", "(if cc) prnd Sy,Dz",	"101110cc01yyzzzz",
    "/* FIXME: duplicate code prnd.  */",
    "int Sy = DSP_R (y);",
    "int Sy_grd = SIGN32 (Sy);",
    "",
    "res = (Sy + 0x8000) & 0xffff0000;",
    "carry = (unsigned) res < (unsigned) Sy;",
    "res_grd = Sy_grd + carry;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
  },
  { "","", "prnd Sy,Dz",	"10111000..yyzzzz",
    "int Sy = DSP_R (y);",
    "int Sy_grd = SIGN32 (Sy);",
    "",
    "res = (Sy + 0x8000) & 0xffff0000;",
    "carry = (unsigned) res < (unsigned) Sy;",
    "res_grd = Sy_grd + carry;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
  },
  { "","", "(if cc) pshl Sx,Sy,Dz",	"100000ccxxyyzzzz",
    "int Sx = DSP_R (x) & 0xffff0000;",
    "int Sy = DSP_R (y) >> 16 & 0x7f;",
    "",
    "if (Sy <= 16)",
    "  res = Sx << Sy;",
    "else if (Sy >= 128 - 16)",
    "  res = (unsigned) Sx >> 128 - Sy;	/* no sign extension */",
    "else",
    "  {",
    "    RAISE_EXCEPTION (SIGILL);",
    "    return;",
    "  }",
    "goto cond_logical;",
  },
  { "","", "(if cc) psha Sx,Sy,Dz",	"100100ccxxyyzzzz",
    "int Sx = DSP_R (x);",
    "int Sx_grd = GET_DSP_GRD (x);",
    "int Sy = DSP_R (y) >> 16 & 0x7f;",
    "",
    "if (Sy <= 32)",
    "  {",
    "    if (Sy == 32)",
    "      {",
    "        res = 0;",
    "        res_grd = Sx;",
    "      }",
    "    else",
    "      {",
    "        res = Sx << Sy;",
    "        res_grd = Sx_grd << Sy | (unsigned) Sx >> 32 - Sy;",
    "      }",
    "    res_grd = SEXT (res_grd);",
    "    carry = res_grd & 1;",
    "  }",
    "else if (Sy >= 96)",
    "  {",
    "    Sy = 128 - Sy;",
    "    if (Sy == 32)",
    "      {",
    "        res_grd = SIGN32 (Sx_grd);",
    "        res = Sx_grd;",
    "      }",
    "    else",
    "      {",
    "        res = Sx >> Sy | Sx_grd << 32 - Sy;",
    "        res_grd = Sx_grd >> Sy;",
    "      }",
    "    carry = Sx >> (Sy - 1) & 1;",
    "  }",
    "else",
    "  {",
    "    RAISE_EXCEPTION (SIGILL);",
    "    return;",
    "  }",
    "COMPUTE_OVERFLOW;",
    "greater_equal = 0;",
  },
  { "","", "(if cc) psub Sx,Sy,Dz",	"101000ccxxyyzzzz",
    "int Sx = DSP_R (x);",
    "int Sx_grd = GET_DSP_GRD (x);",
    "int Sy = DSP_R (y);",
    "int Sy_grd = SIGN32 (Sy);",
    "",
    "res = Sx - Sy;",
    "carry = (unsigned) res > (unsigned) Sx;",
    "res_grd = Sx_grd - Sy_grd - carry;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
  },
  { "","", "(if cc) psub Sy,Sx,Dz",	"100001ccxxyyzzzz",
    "int Sx = DSP_R (x);",
    "int Sx_grd = GET_DSP_GRD (x);",
    "int Sy = DSP_R (y);",
    "int Sy_grd = SIGN32 (Sy);",
    "",
    "res = Sy - Sx;",
    "carry = (unsigned) res > (unsigned) Sy;",
    "res_grd = Sy_grd - Sx_grd - carry;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
  },
  { "","", "(if cc) padd Sx,Sy,Dz",	"101100ccxxyyzzzz",
    "int Sx = DSP_R (x);",
    "int Sx_grd = GET_DSP_GRD (x);",
    "int Sy = DSP_R (y);",
    "int Sy_grd = SIGN32 (Sy);",
    "",
    "res = Sx + Sy;",
    "carry = (unsigned) res < (unsigned) Sx;",
    "res_grd = Sx_grd + Sy_grd + carry;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
  },
  { "","", "(if cc) pand Sx,Sy,Dz",	"100101ccxxyyzzzz",
    "res = DSP_R (x) & DSP_R (y);",
  "cond_logical:",
    "res &= 0xffff0000;",
    "res_grd = 0;",
    "if (iword & 0x200)\n",
    "  goto assign_z;\n",
  "logical:",
    "carry = 0;",
    "overflow = 0;",
    "greater_equal = 0;",
    "DSR &= ~0xf1;\n",
    "if (res)\n",
    "  DSR |= res >> 26 & DSR_MASK_N;\n",
    "else\n",
    "  DSR |= DSR_MASK_Z;\n",
    "goto assign_dc;\n",
  },
  { "","", "(if cc) pxor Sx,Sy,Dz",	"101001ccxxyyzzzz",
    "res = DSP_R (x) ^ DSP_R (y);",
    "goto cond_logical;",
  },
  { "","", "(if cc) por Sx,Sy,Dz",	"101101ccxxyyzzzz",
    "res = DSP_R (x) | DSP_R (y);",
    "goto cond_logical;",
  },
  { "","", "(if cc) pdec Sx,Dz",	"100010ccxx..zzzz",
    "int Sx = DSP_R (x);",
    "int Sx_grd = GET_DSP_GRD (x);",
    "",
    "res = Sx - 0x10000;",
    "carry = res > Sx;",
    "res_grd = Sx_grd - carry;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
    "res &= 0xffff0000;",
  },
  { "","", "(if cc) pinc Sx,Dz",	"100110ccxx..zzzz",
    "int Sx = DSP_R (x);",
    "int Sx_grd = GET_DSP_GRD (x);",
    "",
    "res = Sx + 0x10000;",
    "carry = res < Sx;",
    "res_grd = Sx_grd + carry;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
    "res &= 0xffff0000;",
  },
  { "","", "(if cc) pdec Sy,Dz",	"101010cc..yyzzzz",
    "int Sy = DSP_R (y);",
    "int Sy_grd = SIGN32 (Sy);",
    "",
    "res = Sy - 0x10000;",
    "carry = res > Sy;",
    "res_grd = Sy_grd - carry;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
    "res &= 0xffff0000;",
  },
  { "","", "(if cc) pinc Sy,Dz",	"101110cc..yyzzzz",
    "int Sy = DSP_R (y);",
    "int Sy_grd = SIGN32 (Sy);",
    "",
    "res = Sy + 0x10000;",
    "carry = res < Sy;",
    "res_grd = Sy_grd + carry;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
    "res &= 0xffff0000;",
  },
  { "","", "(if cc) pclr Dz",		"100011cc....zzzz",
    "res = 0;",
    "res_grd = 0;",
    "carry = 0;",
    "overflow = 0;",
    "greater_equal = 1;",
  },
  { "","", "pclr Du pmuls Se,Sf,Dg",	"0100eeff0001gguu",
    "/* Do multiply.  */",
    "res = (DSP_R (e) >> 16) * (DSP_R (f) >> 16) * 2;",
    "if (res == 0x80000000)",
    "  res = 0x7fffffff;",
    "DSP_R (g) = res;",
    "DSP_GRD (g) = SIGN32 (res);",
    "/* FIXME: update DSR based on results of multiply!  */",
    "",
    "/* Do clr.  */",
    "z = u;",
    "res = 0;",
    "res_grd = 0;",
    "goto assign_z;",
  },
  { "","", "(if cc) pdmsb Sx,Dz",	"100111ccxx..zzzz",
    "unsigned Sx = DSP_R (x);",
    "int Sx_grd = GET_DSP_GRD (x);",
    "int i = 16;",
    "",
    "if (Sx_grd < 0)",
    "  {",
    "    Sx_grd = ~Sx_grd;",
    "    Sx = ~Sx;",
    "  }",
    "if (Sx_grd)",
    "  {",
    "    Sx = Sx_grd;",
    "    res = -2;",
    "  }",
    "else if (Sx)",
    "  res = 30;",
    "else",
    "  res = 31;",
    "do",
    "  {",
    "    if (Sx & ~0 << i)",
    "      {",
    "        res -= i;",
    "        Sx >>= i;",
    "      }",
    "  }",
    "while (i >>= 1);",
    "res <<= 16;",
    "res_grd = SIGN32 (res);",
    "carry = 0;",
    "overflow = 0;",
    "ADD_SUB_GE;",
  },
  { "","", "(if cc) pdmsb Sy,Dz",	"101111cc..yyzzzz",
    "unsigned Sy = DSP_R (y);",
    "int i;",
    "",
    "if (Sy < 0)",
    "  Sy = ~Sy;",
    "Sy <<= 1;",
    "res = 31;",
    "do",
    "  {",
    "    if (Sy & ~0 << i)",
    "      {",
    "        res -= i;",
    "        Sy >>= i;",
    "      }",
    "  }",
    "while (i >>= 1);",
    "res <<= 16;",
    "res_grd = SIGN32 (res);",
    "carry = 0;",
    "overflow = 0;",
    "ADD_SUB_GE;",
  },
  { "","", "(if cc) pneg Sx,Dz",	"110010ccxx..zzzz",
    "int Sx = DSP_R (x);",
    "int Sx_grd = GET_DSP_GRD (x);",
    "",
    "res = 0 - Sx;",
    "carry = res != 0;",
    "res_grd = 0 - Sx_grd - carry;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
  },
  { "","", "(if cc) pcopy Sx,Dz",	"110110ccxx..zzzz",
    "res = DSP_R (x);",
    "res_grd = GET_DSP_GRD (x);",
    "carry = 0;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
  },
  { "","", "(if cc) pneg Sy,Dz",	"111010cc..yyzzzz",
    "int Sy = DSP_R (y);",
    "int Sy_grd = SIGN32 (Sy);",
    "",
    "res = 0 - Sy;",
    "carry = res != 0;",
    "res_grd = 0 - Sy_grd - carry;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
  },
  { "","", "(if cc) pcopy Sy,Dz",	"111110cc..yyzzzz",
    "res = DSP_R (y);",
    "res_grd = SIGN32 (res);",
    "carry = 0;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
  },
  { "","", "(if cc) psts MACH,Dz",	"110011cc....zzzz",
    "res = MACH;",
    "res_grd = SIGN32 (res);",
    "goto assign_z;",
  },
  { "","", "(if cc) psts MACL,Dz",	"110111cc....zzzz",
    "res = MACL;",
    "res_grd = SIGN32 (res);",
    "goto assign_z;",
  },
  { "","", "(if cc) plds Dz,MACH",	"111011cc....zzzz",
    "if (0xa05f >> z & 1)",
    "  RAISE_EXCEPTION (SIGILL);",
    "else",
    "  MACH = DSP_R (z);",
    "return;",
  },
  { "","", "(if cc) plds Dz,MACL",	"111111cc....zzzz",
    "if (0xa05f >> z & 1)",
    "  RAISE_EXCEPTION (SIGILL);",
    "else",
    "  MACL = DSP_R (z) = res;",
    "return;",
  },
  /* sh4a */
  { "","", "(if cc) pswap Sx,Dz",	"100111ccxx01zzzz",
    "int Sx = DSP_R (x);",
    "",
    "res = ((Sx & 0xffff) * 65536) + ((Sx >> 16) & 0xffff);",
    "res_grd = GET_DSP_GRD (x);",
    "carry = 0;",
    "overflow = 0;",
    "greater_equal = res & 0x80000000 ? 0 : DSR_MASK_G;",
  },
  /* sh4a */
  { "","", "(if cc) pswap Sy,Dz",	"101111cc01yyzzzz",
    "int Sy = DSP_R (y);",
    "",
    "res = ((Sy & 0xffff) * 65536) + ((Sy >> 16) & 0xffff);",
    "res_grd = SIGN32 (Sy);",
    "carry = 0;",
    "overflow = 0;",
    "greater_equal = res & 0x80000000 ? 0 : DSR_MASK_G;",
  },

  {0, 0}
};

/* Tables of things to put into enums for sh-opc.h */
static char *nibble_type_list[] =
{
  "HEX_0",
  "HEX_1",
  "HEX_2",
  "HEX_3",
  "HEX_4",
  "HEX_5",
  "HEX_6",
  "HEX_7",
  "HEX_8",
  "HEX_9",
  "HEX_A",
  "HEX_B",
  "HEX_C",
  "HEX_D",
  "HEX_E",
  "HEX_F",
  "REG_N",
  "REG_M",
  "BRANCH_12",
  "BRANCH_8",
  "DISP_8",
  "DISP_4",
  "IMM_4",
  "IMM_4BY2",
  "IMM_4BY4",
  "PCRELIMM_8BY2",
  "PCRELIMM_8BY4",
  "IMM_8",
  "IMM_8BY2",
  "IMM_8BY4",
  0
};
static
char *arg_type_list[] =
{
  "A_END",
  "A_BDISP12",
  "A_BDISP8",
  "A_DEC_M",
  "A_DEC_N",
  "A_DISP_GBR",
  "A_DISP_PC",
  "A_DISP_REG_M",
  "A_DISP_REG_N",
  "A_GBR",
  "A_IMM",
  "A_INC_M",
  "A_INC_N",
  "A_IND_M",
  "A_IND_N",
  "A_IND_R0_REG_M",
  "A_IND_R0_REG_N",
  "A_MACH",
  "A_MACL",
  "A_PR",
  "A_R0",
  "A_R0_GBR",
  "A_REG_M",
  "A_REG_N",
  "A_SR",
  "A_VBR",
  "A_SSR",
  "A_SPC",
  0,
};

static void
make_enum_list (name, s)
     char *name;
     char **s;
{
  int i = 1;
  printf ("typedef enum {\n");
  while (*s)
    {
      printf ("\t%s,\n", *s);
      s++;
      i++;
    }
  printf ("} %s;\n", name);
}

static int
qfunc (a, b)
     op *a;
     op *b;
{
  char bufa[9];
  char bufb[9];
  int diff;

  memcpy (bufa, a->code, 4);
  memcpy (bufa + 4, a->code + 12, 4);
  bufa[8] = 0;

  memcpy (bufb, b->code, 4);
  memcpy (bufb + 4, b->code + 12, 4);
  bufb[8] = 0;
  diff = strcmp (bufa, bufb);
  /* Stabilize the sort, so that later entries can override more general
     preceding entries.  */
  return diff ? diff : a - b;
}

static void
sorttab ()
{
  op *p = tab;
  int len = 0;

  while (p->name)
    {
      p++;
      len++;
    }
  qsort (tab, len, sizeof (*p), qfunc);
}

static void
gengastab ()
{
  op *p;
  sorttab ();
  for (p = tab; p->name; p++)
    {
      printf ("%s %-30s\n", p->code, p->name);
    }
}

static unsigned short table[1 << 16];

static int warn_conflicts = 0;

static void
conflict_warn (val, i)
     int val;
     int i;
{
  int ix, key;
  int j = table[val];

  fprintf (stderr, "Warning: opcode table conflict: 0x%04x (idx %d && %d)\n",
	   val, i, table[val]);

  for (ix = sizeof (tab) / sizeof (tab[0]); ix >= 0; ix--)
    if (tab[ix].index == i || tab[ix].index == j)
      {
	key = ((tab[ix].code[0] - '0') << 3) + 
	  ((tab[ix].code[1] - '0') << 2) + 
	  ((tab[ix].code[2] - '0') << 1) + 
	  ((tab[ix].code[3] - '0'));

	if (val >> 12 == key)
	  fprintf (stderr, "  %s -- %s\n", tab[ix].code, tab[ix].name);
      }

  for (ix = sizeof (movsxy_tab) / sizeof (movsxy_tab[0]); ix >= 0; ix--)
    if (movsxy_tab[ix].index == i || movsxy_tab[ix].index == j)
      {
	key = ((movsxy_tab[ix].code[0] - '0') << 3) + 
	  ((movsxy_tab[ix].code[1] - '0') << 2) + 
	  ((movsxy_tab[ix].code[2] - '0') << 1) + 
	  ((movsxy_tab[ix].code[3] - '0'));

	if (val >> 12 == key)
	  fprintf (stderr, "  %s -- %s\n", 
		   movsxy_tab[ix].code, movsxy_tab[ix].name);
      }

  for (ix = sizeof (ppi_tab) / sizeof (ppi_tab[0]); ix >= 0; ix--)
    if (ppi_tab[ix].index == i || ppi_tab[ix].index == j)
      {
	key = ((ppi_tab[ix].code[0] - '0') << 3) + 
	  ((ppi_tab[ix].code[1] - '0') << 2) + 
	  ((ppi_tab[ix].code[2] - '0') << 1) + 
	  ((ppi_tab[ix].code[3] - '0'));

	if (val >> 12 == key)
	  fprintf (stderr, "  %s -- %s\n", 
		   ppi_tab[ix].code, ppi_tab[ix].name);
      }
}

/* Take an opcode, expand all varying fields in it out and fill all the
   right entries in 'table' with the opcode index.  */

static void
expand_opcode (val, i, s)
     int val;
     int i;
     char *s;
{
  if (*s == 0)
    {
      if (warn_conflicts && table[val] != 0)
	conflict_warn (val, i);
      table[val] = i;
    }
  else
    {
      int j = 0, m = 0;

      switch (s[0])
	{
	default:
	  fprintf (stderr, "expand_opcode: illegal char '%c'\n", s[0]);
	  exit (1);
	case '0':
	case '1':
	  /* Consume an arbitrary number of ones and zeros.  */
	  do {
	    j = (j << 1) + (s[m++] - '0');
	  } while (s[m] == '0' || s[m] == '1');
	  expand_opcode ((val << m) | j, i, s + m);
	  break;
	case 'N':	/* NN -- four-way fork */
	  for (j = 0; j < 4; j++)
	    expand_opcode ((val << 2) | j, i, s + 2);
	  break;
	case 'x':	/* xx or xy -- two-way or four-way fork */
	  for (j = 0; j < 4; j += (s[1] == 'x' ? 2 : 1))
	    expand_opcode ((val << 2) | j, i, s + 2);
	  break;
	case 'y':	/* yy or yx -- two-way or four-way fork */
	  for (j = 0; j < (s[1] == 'x' ? 4 : 2); j++)
	    expand_opcode ((val << 2) | j, i, s + 2);
	  break;
	case '?':	/* Seven-way "wildcard" fork for movxy */
	  expand_opcode ((val << 2), i, s + 2);
	  for (j = 1; j < 4; j++)
	    {
	      expand_opcode ((val << 2) | j, i, s + 2);
	      expand_opcode ((val << 2) | (j + 16), i, s + 2);
	    }
	  break;
	case 'i':	/* eg. "i8*1" */
	case '.':	/* "...." is a wildcard */
	case 'n':
	case 'm':
	  /* nnnn, mmmm, i#*#, .... -- 16-way fork.  */
	  for (j = 0; j < 16; j++)
	    expand_opcode ((val << 4) | j, i, s + 4);
	  break;
	case 'e':
	  /* eeee -- even numbered register:
	     8 way fork.  */
	  for (j = 0; j < 15; j += 2)
	    expand_opcode ((val << 4) | j, i, s + 4);
	  break;
	case 'M':
	  /* A0, A1, X0, X1, Y0, Y1, M0, M1, A0G, A1G:
	     MMMM -- 10-way fork */
	  expand_opcode ((val << 4) | 5, i, s + 4);
	  for (j = 7; j < 16; j++)
	    expand_opcode ((val << 4) | j, i, s + 4);
	  break;
	case 'G':
	  /* A1G, A0G: 
	     GGGG -- two-way fork */
	  for (j = 13; j <= 15; j +=2)
	    expand_opcode ((val << 4) | j, i, s + 4);
	  break;
	case 's':
	  /* ssss -- 10-way fork */
	  /* System registers mach, macl, pr: */
	  for (j = 0; j < 3; j++)
	    expand_opcode ((val << 4) | j, i, s + 4);
	  /* System registers fpul, fpscr/dsr, a0, x0, x1, y0, y1: */
	  for (j = 5; j < 12; j++)
	    expand_opcode ((val << 4) | j, i, s + 4);
	  break;
	case 'X':
	  /* XX/XY -- 2/4 way fork.  */
	  for (j = 0; j < 4; j += (s[1] == 'X' ? 2 : 1))
	    expand_opcode ((val << 2) | j, i, s + 2);
	  break;
	case 'a':
	  /* aa/ax -- 2/4 way fork.  */
	  for (j = 0; j < 4; j += (s[1] == 'a' ? 2 : 1))
	    expand_opcode ((val << 2) | j, i, s + 2);
	  break;
	case 'Y':
	  /* YY/YX -- 2/4 way fork.  */
	  for (j = 0; j < (s[1] == 'Y' ? 2 : 4); j += 1)
	    expand_opcode ((val << 2) | j, i, s + 2);
	  break;
	case 'A':
	  /* AA/AY: 2/4 way fork.  */
	  for (j = 0; j < (s[1] == 'A' ? 2 : 4); j += 1)
	    expand_opcode ((val << 2) | j, i, s + 2);
	  break;
	case 'v':
	  /* vv(VV) -- 4(16) way fork.  */
	  /* Vector register fv0/4/8/12.  */
	  if (s[2] == 'V')
	    {
	      /* 2 vector registers.  */
	      for (j = 0; j < 15; j++)
		expand_opcode ((val << 4) | j, i, s + 4);
	    }
	  else
	    {
	      /* 1 vector register.  */
	      for (j = 0; j < 4; j += 1)
		expand_opcode ((val << 2) | j, i, s + 2);
	    }
	  break;
	}
    }
}

/* Print the jump table used to index an opcode into a switch
   statement entry.  */

static void
dumptable (name, size, start)
     char *name;
     int size;
     int start;
{
  int lump = 256;
  int online = 16;

  int i = start;

  printf ("unsigned short %s[%d]={\n", name, size);
  while (i < start + size)
    {
      int j = 0;

      printf ("/* 0x%x */\n", i);

      while (j < lump)
	{
	  int k = 0;
	  while (k < online)
	    {
	      printf ("%2d", table[i + j + k]);
	      if (j + k < lump)
		printf (",");

	      k++;
	    }
	  j += k;
	  printf ("\n");
	}
      i += j;
    }
  printf ("};\n");
}


static void
filltable (p)
     op *p;
{
  static int index = 1;

  sorttab ();
  for (; p->name; p++)
    {
      p->index = index++;
      expand_opcode (0, p->index, p->code);
    }
}

/* Table already contains all the switch case tags for 16-bit opcode double
   data transfer (ddt) insns, and the switch case tag for processing parallel
   processing insns (ppi) for code 0xf800 (ppi nopx nopy).  Copy the
   latter tag to represent all combinations of ppi with ddt.  */
static void
expand_ppi_movxy ()
{
  int i;

  for (i = 0xf000; i < 0xf400; i++)
    if (table[i])
      table[i + 0x800] = table[0xf800];
}

static void
gensim_caselist (p)
     op *p;
{
  for (; p->name; p++)
    {
      int j;
      int sextbit = -1;
      int needm = 0;
      int needn = 0;
      
      char *s = p->code;

      printf ("  /* %s %s */\n", p->name, p->code);
      printf ("  case %d:      \n", p->index);

      printf ("    {\n");
      while (*s)
	{
	  switch (*s)
	    {
	    default:
	      fprintf (stderr, "gencode/gensim_caselist: illegal char '%c'\n",
		       *s);
	      exit (1);
	      break;
	    case '?':
	      /* Wildcard expansion, nothing to do here.  */
	      s += 2;
	      break;
	    case 'v':
	      printf ("      int v1 = ((iword >> 10) & 3) * 4;\n");
	      s += 2;
	      break;
	    case 'V':
	      printf ("      int v2 = ((iword >> 8)  & 3) * 4;\n");
	      s += 2;
	      break;
	    case '0':
	    case '1':
	      s += 2;
	      break;
	    case '.':
	      s += 4;
	      break;
	    case 'n':
	    case 'e':
	      printf ("      int n = (iword >> 8) & 0xf;\n");
	      needn = 1;
	      s += 4;
	      break;
	    case 'N':
	      printf ("      int n = (((iword >> 8) - 2) & 0x3) + 2;\n");
	      s += 2;
	      break;
	    case 'x':
	      if (s[1] == 'y')	/* xy */
		{
		  printf ("      int n = (iword & 3) ? \n");
		  printf ("              ((iword >> 9) & 1) + 4 : \n");
		  printf ("              REG_xy ((iword >> 8) & 3);\n");
		}
	      else
		printf ("      int n = ((iword >> 9) & 1) + 4;\n");
	      needn = 1;
	      s += 2;
	      break;
	    case 'y':
	      if (s[1] == 'x')	/* yx */
		{
		  printf ("      int n = (iword & 0xc) ? \n");
		  printf ("              ((iword >> 8) & 1) + 6 : \n");
		  printf ("              REG_yx ((iword >> 8) & 3);\n");
		}
	      else
		printf ("      int n = ((iword >> 8) & 1) + 6;\n");
	      needn = 1;
	      s += 2;
	      break;
	    case 'm':
	      needm = 1;
	    case 's':
	    case 'M':
	    case 'G':
	      printf ("      int m = (iword >> 4) & 0xf;\n");
	      s += 4;
	      break;
	    case 'X':
	      if (s[1] == 'Y')	/* XY */
		{
		  printf ("      int m = (iword & 3) ? \n");
		  printf ("              ((iword >> 7) & 1) + 8 : \n");
		  printf ("              DSP_xy ((iword >> 6) & 3);\n");
		}
	      else
		printf ("      int m = ((iword >> 7) & 1) + 8;\n");
	      s += 2;
	      break;
	    case 'a':
	      if (s[1] == 'x')	/* ax */
		{
		  printf ("      int m = (iword & 3) ? \n");
		  printf ("              7 - ((iword >> 6) & 2) : \n");
		  printf ("              DSP_ax ((iword >> 6) & 3);\n");
		}
	      else
		printf ("      int m = 7 - ((iword >> 6) & 2);\n");
	      s += 2;
	      break;
	    case 'Y':
	      if (s[1] == 'X')	/* YX */
		{
		  printf ("      int m = (iword & 0xc) ? \n");
		  printf ("              ((iword >> 6) & 1) + 10 : \n");
		  printf ("              DSP_yx ((iword >> 6) & 3);\n");
		}
	      else
		printf ("      int m = ((iword >> 6) & 1) + 10;\n");
	      s += 2;
	      break;
	    case 'A':
	      if (s[1] == 'Y')	/* AY */
		{
		  printf ("      int m = (iword & 0xc) ? \n");
		  printf ("              7 - ((iword >> 5) & 2) : \n");
		  printf ("              DSP_ay ((iword >> 6) & 3);\n");
		}
	      else
		printf ("      int m = 7 - ((iword >> 5) & 2);\n");
	      s += 2;
	      break;

	    case 'i':
	      printf ("      int i = (iword & 0x");

	      switch (s[1])
		{
		default:
		  fprintf (stderr, 
			   "gensim_caselist: Unknown char '%c' in %s\n",
			   s[1], s);
		  exit (1);
		  break;
		case '4':
		  printf ("f");
		  break;
		case '8':
		  printf ("ff");
		  break;
		case '1':
		  sextbit = 12;
		  printf ("fff");
		  break;
		}
	      printf (")");

	      switch (s[3])
		{
		default:
		  fprintf (stderr, 
			   "gensim_caselist: Unknown char '%c' in %s\n",
			   s[3], s);
		  exit (1);
		  break;
		case '.':	/* eg. "i12." */
		  break;
		case '1':
		  break;
		case '2':
		  printf (" << 1");
		  break;
		case '4':
		  printf (" << 2");
		  break;
		}
	      printf (";\n");
	      s += 4;
	    }
	}
      if (sextbit > 0)
	{
	  printf ("      i = (i ^ (1 << %d)) - (1 << %d);\n",
		  sextbit - 1, sextbit - 1);
	}

      if (needm && needn)
	printf ("      TB (m,n);\n");  
      else if (needm)
	printf ("      TL (m);\n");
      else if (needn)
	printf ("      TL (n);\n");

      {
	/* Do the refs.  */
	char *r;
	for (r = p->refs; *r; r++)
	  {
	    if (*r == 'f') printf ("      CREF (15);\n");
	    if (*r == '-') 
	      {
		printf ("      {\n");
		printf ("        int i = n;\n");
		printf ("        do {\n");
		printf ("          CREF (i);\n");
		printf ("        } while (i-- > 0);\n");
		printf ("      }\n");
	      }
	    if (*r == '+') 
	      {
		printf ("      {\n");
		printf ("        int i = n;\n");
		printf ("        do {\n");
		printf ("          CREF (i);\n");
		printf ("        } while (i++ < 14);\n");
		printf ("      }\n");
	      }
	    if (*r == '0') printf ("      CREF (0);\n"); 
	    if (*r == '8') printf ("      CREF (8);\n"); 
	    if (*r == '9') printf ("      CREF (9);\n"); 
	    if (*r == 'n') printf ("      CREF (n);\n"); 
	    if (*r == 'm') printf ("      CREF (m);\n"); 
	  }
      }

      printf ("      {\n");
      for (j = 0; j < MAX_NR_STUFF; j++)
	{
	  if (p->stuff[j])
	    {
	      printf ("        %s\n", p->stuff[j]);
	    }
	}
      printf ("      }\n");

      {
	/* Do the defs.  */
	char *r;
	for (r = p->defs; *r; r++) 
	  {
	    if (*r == 'f') printf ("      CDEF (15);\n");
	    if (*r == '-') 
	      {
		printf ("      {\n");
		printf ("        int i = n;\n");
		printf ("        do {\n");
		printf ("          CDEF (i);\n");
		printf ("        } while (i-- > 0);\n");
		printf ("      }\n");
	      }
	    if (*r == '+') 
	      {
		printf ("      {\n");
		printf ("        int i = n;\n");
		printf ("        do {\n");
		printf ("          CDEF (i);\n");
		printf ("        } while (i++ < 14);\n");
		printf ("      }\n");
	      }
	    if (*r == '0') printf ("      CDEF (0);\n"); 
	    if (*r == 'n') printf ("      CDEF (n);\n"); 
	    if (*r == 'm') printf ("      CDEF (m);\n"); 
	  }
      }

      printf ("      break;\n");
      printf ("    }\n");
    }
}

static void
gensim ()
{
  printf ("{\n");
  printf ("/* REG_xy = [r4, r5, r0, r1].  */\n");
  printf ("#define REG_xy(R) ((R)==0 ? 4 : (R)==2 ? 5 : (R)==1 ?  0 :  1)\n");
  printf ("/* REG_yx = [r6, r7, r2, r3].  */\n");
  printf ("#define REG_yx(R) ((R)==0 ? 6 : (R)==1 ? 7 : (R)==2 ?  2 :  3)\n");
  printf ("/* DSP_ax = [a0, a1, x0, x1].  */\n");
  printf ("#define DSP_ax(R) ((R)==0 ? 7 : (R)==2 ? 5 : (R)==1 ?  8 :  9)\n");
  printf ("/* DSP_ay = [a0, a1, y0, y1].  */\n");
  printf ("#define DSP_ay(R) ((R)==0 ? 7 : (R)==1 ? 5 : (R)==2 ? 10 : 11)\n");
  printf ("/* DSP_xy = [x0, x1, y0, y1].  */\n");
  printf ("#define DSP_xy(R) ((R)==0 ? 8 : (R)==2 ? 9 : (R)==1 ? 10 : 11)\n");
  printf ("/* DSP_yx = [y0, y1, x0, x1].  */\n");
  printf ("#define DSP_yx(R) ((R)==0 ? 10 : (R)==1 ? 11 : (R)==2 ? 8 : 9)\n");
  printf ("  switch (jump_table[iword]) {\n");

  gensim_caselist (tab);
  gensim_caselist (movsxy_tab);

  printf ("  default:\n");
  printf ("    {\n");
  printf ("      RAISE_EXCEPTION (SIGILL);\n");
  printf ("    }\n");
  printf ("  }\n");
  printf ("}\n");
}

static void
gendefines ()
{
  op *p;
  filltable (tab);
  for (p = tab; p->name; p++)
    {
      char *s = p->name;
      printf ("#define OPC_");
      while (*s) {
	if (isupper (*s)) 
	  *s = tolower (*s);
	if (isalpha (*s))
	  printf ("%c", *s);
	if (*s == ' ')
	  printf ("_");
	if (*s == '@@')
	  printf ("ind_");
	if (*s == ',')
	  printf ("_");
	s++;
      }
      printf (" %d\n",p->index);
    }
}

static int ppi_index;

/* Take a ppi code, expand all varying fields in it and fill all the
   right entries in 'table' with the opcode index.
   NOTE: tail recursion optimization removed for simplicity.  */

static void
expand_ppi_code (val, i, s)
     int val;
     int i;
     char *s;
{
  int j;

  switch (s[0])
    {
    default:
      fprintf (stderr, "gencode/expand_ppi_code: Illegal char '%c'\n", s[0]);
      exit (2);
      break;
    case 'g':
    case 'z':
      if (warn_conflicts && table[val] != 0)
	conflict_warn (val, i);

      /* The last four bits are disregarded for the switch table.  */
      table[val] = i;
      return;
    case 'm':
      /* Four-bit expansion.  */
      for (j = 0; j < 16; j++)
	expand_ppi_code ((val << 4) + j, i, s + 4);
      break;
    case '.':
    case '0':
      expand_ppi_code ((val << 1), i, s + 1);
      break;
    case '1':
      expand_ppi_code ((val << 1) + 1, i, s + 1);
      break;
    case 'i':
    case 'e': case 'f':
    case 'x': case 'y':
      expand_ppi_code ((val << 1), i, s + 1);
      expand_ppi_code ((val << 1) + 1, i, s + 1);
      break;
    case 'c':
      expand_ppi_code ((val << 2) + 1, ppi_index++, s + 2);
      expand_ppi_code ((val << 2) + 2, i, s + 2);
      expand_ppi_code ((val << 2) + 3, i, s + 2);
      break;
    }
}

static void
ppi_filltable ()
{
  op *p;
  ppi_index = 1;

  for (p = ppi_tab; p->name; p++)
    {
      p->index = ppi_index++;
      expand_ppi_code (0, p->index, p->code);
    }
}

static void
ppi_gensim ()
{
  op *p = ppi_tab;

  printf ("#define DSR_MASK_G 0x80\n");
  printf ("#define DSR_MASK_Z 0x40\n");
  printf ("#define DSR_MASK_N 0x20\n");
  printf ("#define DSR_MASK_V 0x10\n");
  printf ("\n");
  printf ("#define COMPUTE_OVERFLOW do {\\\n");
  printf ("  overflow = res_grd != SIGN32 (res) ? DSR_MASK_V : 0; \\\n");
  printf ("  if (overflow && S) \\\n");
  printf ("    { \\\n");
  printf ("      if (res_grd & 0x80) \\\n");
  printf ("        { \\\n");
  printf ("          res = 0x80000000; \\\n");
  printf ("          res_grd |=  0xff; \\\n");
  printf ("        } \\\n");
  printf ("      else \\\n");
  printf ("        { \\\n");
  printf ("          res = 0x7fffffff; \\\n");
  printf ("          res_grd &= ~0xff; \\\n");
  printf ("        } \\\n");
  printf ("      overflow = 0; \\\n");
  printf ("    } \\\n");
  printf ("} while (0)\n");
  printf ("\n");
  printf ("#define ADD_SUB_GE \\\n");
  printf ("  (greater_equal = ~(overflow << 3 & res_grd) & DSR_MASK_G)\n");
  printf ("\n");
  printf ("static void\n");
  printf ("ppi_insn (iword)\n");
  printf ("     int iword;\n");
  printf ("{\n");
  printf ("  /* 'ee' = [x0, x1, y0, a1] */\n");
  printf ("  static char e_tab[] = { 8,  9, 10,  5};\n");
  printf ("  /* 'ff' = [y0, y1, x0, a1] */\n");
  printf ("  static char f_tab[] = {10, 11,  8,  5};\n");
  printf ("  /* 'xx' = [x0, x1, a0, a1]  */\n");
  printf ("  static char x_tab[] = { 8,  9,  7,  5};\n");
  printf ("  /* 'yy' = [y0, y1, m0, m1]  */\n");
  printf ("  static char y_tab[] = {10, 11, 12, 14};\n");
  printf ("  /* 'gg' = [m0, m1, a0, a1]  */\n");
  printf ("  static char g_tab[] = {12, 14,  7,  5};\n");
  printf ("  /* 'uu' = [x0, y0, a0, a1]  */\n");
  printf ("  static char u_tab[] = { 8, 10,  7,  5};\n");
  printf ("\n");
  printf ("  int z;\n");
  printf ("  int res, res_grd;\n");
  printf ("  int carry, overflow, greater_equal;\n");
  printf ("\n");
  printf ("  switch (ppi_table[iword >> 4]) {\n");

  for (; p->name; p++)
    {
      int shift, j;
      int cond = 0;
      int havedecl = 0;
      
      char *s = p->code;

      printf ("  /* %s %s */\n", p->name, p->code);
      printf ("  case %d:      \n", p->index);

      printf ("    {\n");
      for (shift = 16; *s; )
	{
	  switch (*s)
	    {
	    case 'i':
	      printf ("      int i = (iword >> 4) & 0x7f;\n");
	      s += 6;
	      break;
	    case 'e':
	    case 'f':
	    case 'x':
	    case 'y':
	    case 'g':
	    case 'u':
	      shift -= 2;
	      printf ("      int %c = %c_tab[(iword >> %d) & 3];\n",
		      *s, *s, shift);
	      havedecl = 1;
	      s += 2;
	      break;
	    case 'c':
	      printf ("      if ((((iword >> 8) ^ DSR) & 1) == 0)\n");
	      printf ("\treturn;\n");
	      printf ("    }\n");
	      printf ("  case %d:      \n", p->index + 1);
	      printf ("    {\n");
	      cond = 1;
	    case '0':
	    case '1':
	    case '.':
	      shift -= 2;
	      s += 2;
	      break;
	    case 'z':
	      if (havedecl)
		printf ("\n");
	      printf ("      z = iword & 0xf;\n");
	      havedecl = 2;
	      s += 4;
	      break;
	    }
	}
      if (havedecl == 1)
	printf ("\n");
      else if (havedecl == 2)
	printf ("      {\n");
      for (j = 0; j < MAX_NR_STUFF; j++)
	{
	  if (p->stuff[j])
	    {
	      printf ("      %s%s\n",
		      (havedecl == 2 ? "  " : ""),
		      p->stuff[j]);
	    }
	}
      if (havedecl == 2)
	printf ("      }\n");
      if (cond)
	{
	  printf ("      if (iword & 0x200)\n");
	  printf ("        goto assign_z;\n");
	}
      printf ("      break;\n");
      printf ("    }\n");
    }

  printf ("  default:\n");
  printf ("    {\n");
  printf ("      RAISE_EXCEPTION (SIGILL);\n");
  printf ("      return;\n");
  printf ("    }\n");
  printf ("  }\n");
  printf ("  DSR &= ~0xf1;\n");
  printf ("  if (res || res_grd)\n");
  printf ("    DSR |= greater_equal | res_grd >> 2 & DSR_MASK_N | overflow;\n");
  printf ("  else\n");
  printf ("    DSR |= DSR_MASK_Z | overflow;\n");
  printf (" assign_dc:\n");
  printf ("  switch (DSR >> 1 & 7)\n");
  printf ("    {\n");
  printf ("    case 0: /* Carry Mode */\n");
  printf ("      DSR |= carry;\n");
  printf ("    case 1: /* Negative Value Mode */\n");
  printf ("      DSR |= res_grd >> 7 & 1;\n");
  printf ("    case 2: /* Zero Value Mode */\n");
  printf ("      DSR |= DSR >> 6 & 1;\n");
  printf ("    case 3: /* Overflow mode\n");
  printf ("      DSR |= overflow >> 4;\n");
  printf ("    case 4: /* Signed Greater Than Mode */\n");
  printf ("      DSR |= DSR >> 7 & 1;\n");
  printf ("    case 4: /* Signed Greater Than Or Equal Mode */\n");
  printf ("      DSR |= greater_equal >> 7;\n");
  printf ("    }\n");
  printf (" assign_z:\n");
  printf ("  if (0xa05f >> z & 1)\n");
  printf ("    {\n");
  printf ("      RAISE_EXCEPTION (SIGILL);\n");
  printf ("      return;\n");
  printf ("    }\n");
  printf ("  DSP_R (z) = res;\n");
  printf ("  DSP_GRD (z) = res_grd;\n");
  printf ("}\n");
}

int
main (ac, av)
     int ac;
     char **av;
{
  /* Verify the table before anything else.  */
  {
    op *p;
    for (p = tab; p->name; p++)
      {
	/* Check that the code field contains 16 bits.  */
	if (strlen (p->code) != 16)
	  {
	    fprintf (stderr, "Code `%s' length wrong (%d) for `%s'\n",
		     p->code, strlen (p->code), p->name);
	    abort ();
	  }
      }
  }

  /* Now generate the requested data.  */
  if (ac > 1)
    {
      if (ac > 2 && strcmp (av[2], "-w") == 0)
	{
	  warn_conflicts = 1;
	}
      if (strcmp (av[1], "-t") == 0)
	{
	  gengastab ();
	}
      else if (strcmp (av[1], "-d") == 0)
	{
	  gendefines ();
	}
      else if (strcmp (av[1], "-s") == 0)
	{
	  filltable (tab);
	  dumptable ("sh_jump_table", 1 << 16, 0);

	  memset (table, 0, sizeof table);
	  filltable (movsxy_tab);
	  expand_ppi_movxy ();
	  dumptable ("sh_dsp_table", 1 << 12, 0xf000);

	  memset (table, 0, sizeof table);
	  ppi_filltable ();
	  dumptable ("ppi_table", 1 << 12, 0);
	}
      else if (strcmp (av[1], "-x") == 0)
	{
	  filltable (tab);
	  filltable (movsxy_tab);
	  gensim ();
	}
      else if (strcmp (av[1], "-p") == 0)
	{
	  ppi_filltable ();
	  ppi_gensim ();
	}
    }
  else
    fprintf (stderr, "Opcode table generation no longer supported.\n");
  return 0;
}
@


1.33
log
@2007-03-02  Andrew Stubbs  <andrew.stubbs@@st.com>

	* gencode.c (tab): Correct pre-decrement instructions when m == n.
@
text
@d996 1
d1063 1
d1125 1
@


1.32
log
@	* gencode.c (tab): Avoid lvalue casts.  Suggested by
	Ralf Corsepius <ralf.corsepius@@rtems.org>.
@
text
@d973 2
d977 1
a977 1
    "WBAT (R[n], R[m]);",
d1040 2
d1044 1
a1044 1
    "WLAT (R[n], R[m]);",
d1106 2
d1110 1
a1110 1
    "WWAT (R[n], R[m]);",
@


1.31
log
@
* gencode.c (tab): Avoid inserting code before variables all declared.
@
text
@d218 3
a220 1
    "else (unsigned int) R[n] = (unsigned int) R[n] / (unsigned int) R0;",
@


1.30
log
@	* gencode.c (movua.l): Compensate for endianness.

	* interp.c (RAISE_EXCEPTION_IF_IN_DELAY_SLOT): New macro.
	(in_delay_slot): New flag variable.
	(Delay_Slot): Set in_delay_slot.
	(sim_resume): Reset in_delay_slot after leaving code switch.
	* gencode.c (op tab): Call RAISE_EXCEPTION_IF_IN_DELAY_SLOT for all
	instructions not allowed in delay slots.

	Commited by Corinna Vinschen <vinschen@@redhat.com>
	Introduce SH2a support.
	* interp.c: Change type of jump table to short.  Add various macros.
	(sim_load): Save the bfd machine code.
	(sim_create_inferior): Ditto.
	(union saved_state_type): Add tbr, ibnr and ibcr registers.
	Move bfd_mach to end of struct.  Add regstack pointer.
	(init_dsp): Don't swap contents of sh_dsp_table any more.  Instead
	use it directly in its own switch statement.  Allocate space for 512
	register banks.
	(do_long_move_insn): New function.
	(do_blog_insn): Ditto.
	(trap): Use trap #13 and trap #14 to set ibnr and ibcr.
	* gencode.c: Move movx/movy insns into separate switch statement.
	(op tab): Add sh2a insns.  Reject instructions that are disabled
	on that chip.
	(gensim_caselist): Generate default case here instead of in caller.
	(gensim): Generate two separate switch statements.  Call
	gensim_caselist once for each (for movsxy_tab and for tab).
	Add tokens for r15 and multiple regs.
	(conflict_warn, warn_conflicts): Add for debugging.
@
text
@d105 1
a106 1
    "int word2 = RIAT (nip);",
d241 1
a243 1
    "int i;",
d590 1
a591 1
    "int word2 = RIAT (nip);",
d1496 1
a1497 1
    "long imm = 0xff & i;",
@


1.29
log
@	* gencode.c (tab): For shad snd shld, fix result for
	(op1 < 0 && shift_amount == 0).
@
text
@d87 1
d95 1
d103 13
d117 1
d124 1
d131 1
d139 1
d147 1
d153 172
d327 1
d493 2
d584 12
d675 2
d685 2
d708 2
d741 2
d760 1
d767 1
d775 14
d813 6
d913 10
d948 6
d975 5
d1012 6
d1040 5
d1076 6
d1104 5
d1146 3
a1148 1

d1151 1
d1153 2
a1154 2
    "R[0] = (RBAT (regn) << 24) + (RBAT (regn + 1) << 16) + ",
    "  (RBAT (regn + 2) << 8) + RBAT (regn + 3);",
d1159 1
d1161 2
a1162 2
    "R[0] = (RBAT (regn) << 24) + (RBAT (regn + 1) << 16) + ",
    "  (RBAT (regn + 2) << 8) + RBAT (regn + 3);",
d1289 1
d1298 1
d1303 10
d1420 6
d1496 1
d1821 1
d1823 1
a1823 1
    "nip += 2;",
d2574 52
d2637 2
d2960 6
a2973 1

d2981 8
d3020 19
d3062 22
a3083 3
	    if (*r == '0') printf("      CDEF (0);\n"); 
	    if (*r == 'n') printf("      CDEF (n);\n"); 
	    if (*r == 'm') printf("      CDEF (m);\n"); 
d3169 3
d3407 4
@


1.28
log
@2004-02-02  Michael Snyder  <msnyder@@redhat.com>

	* gencode.c (movua.l): Set thislock to 0, not n.
@
text
@d1057 1
a1057 1
    "R[n] = (R[m] < 0) ? (R[n] >> ((-R[m])&0x1f)) : (R[n] << (R[m] & 0x1f));",
d1071 1
a1071 1
    "R[n] = (R[m] < 0) ? (UR[n] >> ((-R[m])&0x1f)): (R[n] << (R[m] & 0x1f));",
@


1.28.4.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a86 1
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
a93 1
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
a100 13
  { "", "n", "bit32 #imm3,@@(disp12,<REG_N>)", "0011nnnni8*11001",
    "/* 32-bit logical bit-manipulation instructions.  */",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "int word2 = RIAT (nip);",
    "i >>= 4;	/* BOGUS: Using only three bits of 'i'.  */",
    "/* MSB of 'i' must be zero.  */",
    "if (i > 7)",
    "  RAISE_EXCEPTION (SIGILL);",
    "MA (1);",
    "do_blog_insn (1 << i, (word2 & 0xfff) + R[n], ",
    "              (word2 >> 12) & 0xf, memory, maskb);",
    "SET_NIP (nip + 2);	/* Consume 2 more bytes.  */",
  },
a101 1
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
a107 1
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
a113 1
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
a120 1
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
a127 1
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
a132 172
  
  { "", "m", "bld/st #<imm>, <REG_M>", "10000111mmmmi4*1",
    "/* MSB of 'i' is true for load, false for store.  */",
    "if (i <= 7)",
    "  if (T)",
    "    R[m] |= (1 << i);",
    "  else",
    "    R[m] &= ~(1 << i);",
    "else",
    "  SET_SR_T ((R[m] & (1 << (i - 8))) != 0);",
  },
  { "m", "m", "bset/clr #<imm>, <REG_M>", "10000110mmmmi4*1",
    "/* MSB of 'i' is true for set, false for clear.  */",
    "if (i <= 7)",
    "  R[m] &= ~(1 << i);",
    "else",
    "  R[m] |= (1 << (i - 8));",
  },
  { "n", "n", "clips.b <REG_N>", "0100nnnn10010001",
    "if (R[n] < -128 || R[n] > 127) {",
    "  L (n);",
    "  SET_SR_CS (1);",
    "  if (R[n] > 127)",
    "    R[n] = 127;",
    "  else if (R[n] < -128)",
    "    R[n] = -128;",
    "}",
  },
  { "n", "n", "clips.w <REG_N>", "0100nnnn10010101",
    "if (R[n] < -32768 || R[n] > 32767) {",
    "  L (n);",
    "  SET_SR_CS (1);",
    "  if (R[n] > 32767)",
    "    R[n] = 32767;",
    "  else if (R[n] < -32768)",
    "    R[n] = -32768;",
    "}",
  },
  { "n", "n", "clipu.b <REG_N>", "0100nnnn10000001",
    "if (R[n] < -256 || R[n] > 255) {",
    "  L (n);",
    "  SET_SR_CS (1);",
    "  R[n] = 255;",
    "}",
  },
  { "n", "n", "clipu.w <REG_N>", "0100nnnn10000101",
    "if (R[n] < -65536 || R[n] > 65535) {",
    "  L (n);",
    "  SET_SR_CS (1);",
    "  R[n] = 65535;",
    "}",
  },
  { "n", "0n", "divs R0,<REG_N>", "0100nnnn10010100",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "if (R0 == 0)",
    "  R[n] = 0x7fffffff;",
    "else if (R0 == -1 && R[n] == 0x80000000)",
    "  R[n] = 0x7fffffff;",
    "else R[n] /= R0;",
    "L (n);",
  },
  { "n", "0n", "divu R0,<REG_N>", "0100nnnn10000100",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "if (R0 == 0)",
    "  R[n] = 0xffffffff;",
    "else (unsigned int) R[n] = (unsigned int) R[n] / (unsigned int) R0;",
    "L (n);",
  },
  { "n", "0n", "mulr R0,<REG_N>", "0100nnnn10000000",
    "R[n] = (R[n] * R0) & 0xffffffff;",
    "L (n);",
  },
  { "0", "n", "ldbank @@<REG_N>,R0", "0100nnnn11100101",
    "int regn = (R[n] >> 2) & 0x1f;",
    "int bankn = (R[n] >> 7) & 0x1ff;",
    "if (regn > 19)",
    "  regn = 19;	/* FIXME what should happen? */",
    "R0 = saved_state.asregs.regstack[bankn].regs[regn];",
    "L (0);",
  },
  { "", "0n", "stbank R0,@@<REG_N>", "0100nnnn11100001",
    "int regn = (R[n] >> 2) & 0x1f;",
    "int bankn = (R[n] >> 7) & 0x1ff;",
    "if (regn > 19)",
    "  regn = 19;	/* FIXME what should happen? */",
    "saved_state.asregs.regstack[bankn].regs[regn] = R0;",
  },
  { "", "", "resbank", "0000000001011011",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    /* FIXME: cdef all */
    "int i;",
    "if (BO) {	/* Bank Overflow */",
    /* FIXME: how do we know when to reset BO?  */
    "  for (i = 0; i <= 14; i++) {",
    "    R[i] = RLAT (R[15]);",
    "    MA (1);",
    "    R[15] += 4;",
    "  }",
    "  PR = RLAT (R[15]);",
    "  R[15] += 4;",
    "  MA (1);",
    "  GBR = RLAT (R[15]);",
    "  R[15] += 4;",
    "  MA (1);",
    "  MACH = RLAT (R[15]);",
    "  R[15] += 4;",
    "  MA (1);",
    "  MACL = RLAT (R[15]);",
    "  R[15] += 4;",
    "  MA (1);",
    "}",
    "else if (BANKN == 0)	/* Bank Underflow */",
    "  RAISE_EXCEPTION (SIGILL);",	/* FIXME: what exception? */
    "else {",
    "  SET_BANKN (BANKN - 1);",
    "  for (i = 0; i <= 14; i++)",
    "    R[i] = saved_state.asregs.regstack[BANKN].regs[i];",
    "  MACH = saved_state.asregs.regstack[BANKN].regs[15];",
    "  PR   = saved_state.asregs.regstack[BANKN].regs[17];",
    "  GBR  = saved_state.asregs.regstack[BANKN].regs[18];",
    "  MACL = saved_state.asregs.regstack[BANKN].regs[19];",
    "}",
  },
  { "f", "f-", "movml.l <REG_N>,@@-R15", "0100nnnn11110001",
    "/* Push Rn...R0 (if n==15, push pr and R14...R0).  */",
    "do {",
    "  MA (1);",
    "  R[15] -= 4;",
    "  if (n == 15)",
    "    WLAT (R[15], PR);",
    "  else",
    "    WLAT (R[15], R[n]);",
    "} while (n-- > 0);",    
  },
  { "f", "f+", "movml.l @@R15+,<REG_N>", "0100nnnn11110101",
    "/* Pop R0...Rn (if n==15, pop R0...R14 and pr).  */",
    "int i = 0;\n",
    "do {",
    "  MA (1);",
    "  if (i == 15)",
    "    PR = RLAT (R[15]);",
    "  else",
    "    R[i] = RLAT (R[15]);",
    "  R[15] += 4;",
    "} while (i++ < n);",    
  },
  { "f", "f-", "movmu.l <REG_N>,@@-R15", "0100nnnn11110000",
    "/* Push pr, R14...Rn (if n==15, push pr).  */",	/* FIXME */
    "int i = 15;\n",
    "do {",
    "  MA (1);",
    "  R[15] -= 4;",
    "  if (i == 15)",
    "    WLAT (R[15], PR);",
    "  else",
    "    WLAT (R[15], R[i]);",
    "} while (i-- > n);",    
  },
  { "f", "f+", "movmu.l @@R15+,<REG_N>", "0100nnnn11110100",
    "/* Pop Rn...R14, pr (if n==15, pop pr).  */",	/* FIXME */
    "do {",
    "  MA (1);",
    "  if (n == 15)",
    "    PR = RLAT (R[15]);",
    "  else",
    "    R[n] = RLAT (R[15]);",
    "  R[15] += 4;",
    "} while (n++ < 15);",    
  },
  { "", "", "nott", "0000000001101000",
    "SET_SR_T (T == 0);",	
  },
a134 1
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
a299 2
    "  if (saved_state.asregs.bfd_mach == bfd_mach_sh2a)",
    "    RAISE_EXCEPTION (SIGILL);",
a388 12
  /* sh2a */
  { "", "n", "fmov.s @@(disp12,<REG_N>), <FREG_M>", "0011nnnnmmmm0001",
    "/* and fmov.s <FREG_N>, @@(disp12,<FREG_M>)",
    "   and mov.bwl <REG_N>, @@(disp12,<REG_M>)",
    "   and mov.bwl @@(disp12,<REG_N>),<REG_M>",
    "   and movu.bw @@(disp12,<REG_N>),<REG_M>.  */",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "int word2 = RIAT (nip);",
    "SET_NIP (nip + 2);	/* Consume 2 more bytes.  */",
    "MA (1);",
    "do_long_move_insn (word2 & 0xf000, word2 & 0x0fff, m, n, &thislock);",
  },
a467 2
    "else if (saved_state.asregs.bfd_mach == bfd_mach_sh2a)",
    "  RAISE_EXCEPTION (SIGILL);",
a475 2
    "else if (saved_state.asregs.bfd_mach == bfd_mach_sh2a)",
    "  RAISE_EXCEPTION (SIGILL);",
a496 2
    "else if (saved_state.asregs.bfd_mach == bfd_mach_sh2a)",
    "  RAISE_EXCEPTION (SIGILL);",
a527 2
    "  if (saved_state.asregs.bfd_mach == bfd_mach_sh2a)",
    "    RAISE_EXCEPTION (SIGILL);",
a544 1
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
a550 1
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
a557 14
  { "", "n", "jsr/n @@<REG_N>", "0100nnnn01001011",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "PR = PH2T (PC + 2);",
    "if (~doprofile)",
    "  gotcall (PR, R[n]);",
    "SET_NIP (PT2H (R[n]));",
  },
  { "", "", "jsr/n @@@@(<disp>,TBR)", "10000011i8p4....",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "PR = PH2T (PC + 2);",
    "if (~doprofile)",
    "  gotcall (PR, i + TBR);",
    "SET_NIP (PT2H (i + TBR));",
  },
a581 6
  { "", "n", "ldc <REG_N>,TBR", "0100nnnn01001010",
    "if (SR_MD)",	/* FIXME? */
    "  TBR = R[n]; /* priv mode */",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
  },
a675 10
  { "n", "", "movi20 #<imm20>,<REG_N>", "0000nnnni8*10000",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "R[n] = ((i << 24) >> 12) | RIAT (nip);",
    "SET_NIP (nip + 2);	/* Consume 2 more bytes.  */",
  },
  { "n", "", "movi20s #<imm20>,<REG_N>", "0000nnnni8*10001",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "R[n] = ((((i & 0xf0) << 24) >> 12) | RIAT (nip)) << 8;",
    "SET_NIP (nip + 2);	/* Consume 2 more bytes.  */",
  },
a700 6
  { "0n", "n", "mov.b @@-<REG_N>,R0", "0100nnnn11001011",
    "MA (1);",
    "R[n] -= 1;",
    "R0 = RSBAT (R[n]);",
    "L (0);",
  },
a721 5
  { "n", "n0", "mov.b R0,@@<REG_N>+", "0100nnnn10001011",
    "MA (1);",
    "WBAT (R[n], R0);",
    "R[n] += 1;",
  },
a753 6
  { "0n", "n", "mov.l @@-<REG_N>,R0", "0100nnnn11101011",
    "MA (1);",
    "R[n] -= 4;",
    "R0 = RLAT (R[n]);",
    "L (0);",
  },
a775 5
  { "n", "n0", "mov.l R0,@@<REG_N>+", "0100nnnn10101011",
    "MA (1) ;",
    "WLAT (R[n], R0);",
    "R[n] += 4;",
  },
a806 6
  { "0n", "n", "mov.w @@-<REG_N>,R0", "0100nnnn11011011",
    "MA (1);",
    "R[n] -= 2;",
    "R0 = RSWAT (R[n]);",
    "L (0);",
  },
a828 5
  { "n", "0n", "mov.w R0,@@<REG_N>+", "0100nnnn10011011",
    "MA (1);",
    "WWAT (R[n], R0);",
    "R[n] += 2;",
  },
d866 1
a866 3
  { "", "", "movrt <REG_N>", "0000nnnn00111001",
    "R[n] = (T == 0);",	
  },
a868 1
    "int e = target_little_endian ? 3 : 0;",
d870 2
a871 2
    "R[0] = (RBAT (regn + (0^e)) << 24) + (RBAT (regn + (1^e)) << 16) + ",
    "  (RBAT (regn + (2^e)) << 8) + RBAT (regn + (3^e));",
a875 1
    "int e = target_little_endian ? 3 : 0;",
d877 2
a878 2
    "R[0] = (RBAT (regn + (0^e)) << 24) + (RBAT (regn + (1^e)) << 16) + ",
    "  (RBAT (regn + (2^e)) << 8) + RBAT (regn + (3^e));",
a1004 1
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
a1012 1
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
a1016 10
  { "", "", "rts/n", "0000000001101011",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "SET_NIP (PT2H (PR));",
  },
  { "0", "n", "rtv/n <REG_N>", "0000nnnn01111011",
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
    "R0 = R[n];",
    "L (0);",
    "SET_NIP (PT2H (PR));",
  },
d1057 1
a1057 1
    "R[n] = (R[m] < 0) ? (R[m]&0x1f ? R[n] >> ((-R[m])&0x1f) : R[n] >> 31) : (R[n] << (R[m] & 0x1f));",
d1071 1
a1071 1
    "R[n] = (R[m] < 0) ? (R[m]&0x1f ? UR[n] >> ((-R[m])&0x1f) : 0): (R[n] << (R[m] & 0x1f));",
a1123 6
  { "n", "", "stc TBR,<REG_N>", "0000nnnn01001010",
    "if (SR_MD)",	/* FIXME? */
    "  R[n] = TBR; /* priv mode */",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
  },
a1193 1
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
a1517 1
    "RAISE_EXCEPTION_IF_IN_DELAY_SLOT ();",
d1519 1
a1519 1
    "SET_NIP (nip + 2);",
a2269 52
static int warn_conflicts = 0;

static void
conflict_warn (val, i)
     int val;
     int i;
{
  int ix, key;
  int j = table[val];

  fprintf (stderr, "Warning: opcode table conflict: 0x%04x (idx %d && %d)\n",
	   val, i, table[val]);

  for (ix = sizeof (tab) / sizeof (tab[0]); ix >= 0; ix--)
    if (tab[ix].index == i || tab[ix].index == j)
      {
	key = ((tab[ix].code[0] - '0') << 3) + 
	  ((tab[ix].code[1] - '0') << 2) + 
	  ((tab[ix].code[2] - '0') << 1) + 
	  ((tab[ix].code[3] - '0'));

	if (val >> 12 == key)
	  fprintf (stderr, "  %s -- %s\n", tab[ix].code, tab[ix].name);
      }

  for (ix = sizeof (movsxy_tab) / sizeof (movsxy_tab[0]); ix >= 0; ix--)
    if (movsxy_tab[ix].index == i || movsxy_tab[ix].index == j)
      {
	key = ((movsxy_tab[ix].code[0] - '0') << 3) + 
	  ((movsxy_tab[ix].code[1] - '0') << 2) + 
	  ((movsxy_tab[ix].code[2] - '0') << 1) + 
	  ((movsxy_tab[ix].code[3] - '0'));

	if (val >> 12 == key)
	  fprintf (stderr, "  %s -- %s\n", 
		   movsxy_tab[ix].code, movsxy_tab[ix].name);
      }

  for (ix = sizeof (ppi_tab) / sizeof (ppi_tab[0]); ix >= 0; ix--)
    if (ppi_tab[ix].index == i || ppi_tab[ix].index == j)
      {
	key = ((ppi_tab[ix].code[0] - '0') << 3) + 
	  ((ppi_tab[ix].code[1] - '0') << 2) + 
	  ((ppi_tab[ix].code[2] - '0') << 1) + 
	  ((ppi_tab[ix].code[3] - '0'));

	if (val >> 12 == key)
	  fprintf (stderr, "  %s -- %s\n", 
		   ppi_tab[ix].code, ppi_tab[ix].name);
      }
}

a2280 2
      if (warn_conflicts && table[val] != 0)
	conflict_warn (val, i);
a2601 6
		default:
		  fprintf (stderr, 
			   "gensim_caselist: Unknown char '%c' in %s\n",
			   s[1], s);
		  exit (1);
		  break;
d2610 1
a2617 8
		default:
		  fprintf (stderr, 
			   "gensim_caselist: Unknown char '%c' in %s\n",
			   s[3], s);
		  exit (1);
		  break;
		case '.':	/* eg. "i12." */
		  break;
a2648 19
	    if (*r == 'f') printf ("      CREF (15);\n");
	    if (*r == '-') 
	      {
		printf ("      {\n");
		printf ("        int i = n;\n");
		printf ("        do {\n");
		printf ("          CREF (i);\n");
		printf ("        } while (i-- > 0);\n");
		printf ("      }\n");
	      }
	    if (*r == '+') 
	      {
		printf ("      {\n");
		printf ("        int i = n;\n");
		printf ("        do {\n");
		printf ("          CREF (i);\n");
		printf ("        } while (i++ < 14);\n");
		printf ("      }\n");
	      }
d2672 3
a2674 22
	    if (*r == 'f') printf ("      CDEF (15);\n");
	    if (*r == '-') 
	      {
		printf ("      {\n");
		printf ("        int i = n;\n");
		printf ("        do {\n");
		printf ("          CDEF (i);\n");
		printf ("        } while (i-- > 0);\n");
		printf ("      }\n");
	      }
	    if (*r == '+') 
	      {
		printf ("      {\n");
		printf ("        int i = n;\n");
		printf ("        do {\n");
		printf ("          CDEF (i);\n");
		printf ("        } while (i++ < 14);\n");
		printf ("      }\n");
	      }
	    if (*r == '0') printf ("      CDEF (0);\n"); 
	    if (*r == 'n') printf ("      CDEF (n);\n"); 
	    if (*r == 'm') printf ("      CDEF (m);\n"); 
a2759 3
      if (warn_conflicts && table[val] != 0)
	conflict_warn (val, i);

a2994 4
      if (ac > 2 && strcmp (av[2], "-w") == 0)
	{
	  warn_conflicts = 1;
	}
@


1.27
log
@2004-02-12  Michael Snyder  <msnyder@@redhat.com>

	* gencode.c (table): Change from char to short.
	(dumptable): Change generated table from char to short.
	* interp.c (sh_jump_table, sh_dsp_table, ppi_table): char to short.
	(init_dsp): Compute size of sh_dsp_table.
	(sim_resume): Change jump_table from char to short.
@
text
@d872 1
a872 1
    "L (n);",
d880 1
a880 1
    "L (n);",
@


1.26
log
@2004-01-27  Michael Snyder  <msnyder@@redhat.com>

	* gencode.c: (op tab): Some refs and defs fixes.
	"fsrra" -> "fsrra <FREG_N>".
        "sleep": replace array ref with array addr.
        "trapa": ditto.
@
text
@d2268 1
a2268 1
static unsigned char table[1 << 16];
d2410 1
a2410 1
  printf ("unsigned char %s[%d]={\n", name, size);
@


1.25
log
@2004-01-27  Michael Snyder  <msnyder@@redhat.com>

        * gencode.c: Comment and whitespace clean-ups.
@
text
@d75 1
a75 1
  { "0", "", "and #<imm>,R0", "11001001i8*1....",
d204 2
a205 2
  { "", "nm", "div1 <REG_M>,<REG_N>", "0011nnnnmmmm0100",
    "div1 (R, m, n/*, T*/);",
d494 1
a494 1
  { "", "", "fsrra", "1111nnnn01111101",
d844 1
a844 1
  { "n", "0", "movco.l R0, @@<REG_N>", "0000nnnn01110011", 
d1105 1
a1105 1
    "nip += trap (0xc3, R0, PC, memory, maskl, maskw, endianw);",
d1196 1
a1196 1
    "  nip += trap (i, R, PC, memory, maskl, maskw, endianw);",
@


1.24
log
@2004-01-07  Michael Snyder  <msnyder@@redhat.com>

        * gencode.c: Whitespace	cleanup.
        * interp.c: Ditto.
@
text
@d7 1
a7 1
   This file is part of SH sim
d23 1
a23 1
   the simulator code
d290 1
a290 1
    "/* FIXME: check for DP and (n & 1) == 0? */",
d312 1
a312 1
    "/* FIXME: check for DP and (n & 1) == 0? */",
d318 1
a318 1
    "/* FIXME: check for DP and (n & 1) == 0? */",
d446 2
a447 1
  /* sh4: See fmov instructions above for move to/from extended fp registers */
d666 1
a666 1
    "macl (&R0,memory,n,m);",
d670 1
a670 1
    "macw (&R0,memory,n,m,endianw);",
d1196 1
a1196 1
    "  nip += trap (i, R, PC, memory, maskl, maskw,endianw);",
d1246 1
a1246 1
    "divl (0,R[n],R[m]);",
d1249 1
a1249 1
    "divl (0,R[n],R[m]);",
a2265 2


d2397 1
a2397 1
   statement entry. */
d2645 1
a2645 1
	/* Do the refs */
d2668 1
a2668 1
	/* Do the defs */
d2977 1
a2977 1
  /* verify the table before anything else */
d2982 1
a2982 1
	/* check that the code field contains 16 bits */
d2992 1
a2992 1
  /* now generate the requested data */
@


1.23
log
@2004-01-07  Michael Snyder  <msnyder@@redhat.com>

        * gencode.c: Replace 'Hitachi' with 'Renesas'.
        (op tab): Add new instructions for sh4a, DBR, SBR.
        (expand_opcode): Add handling for new movxy combinations.
        (gensym_caselist): Ditto.
        (expand_ppi_movxy): Remove movx/movy expansions,
        now handled in expand_opcode.
        (gensym): Add some helpful macros.
        (expand_ppi_code): Flatten loop for simplicity, tweak for 12-bit
        instead of 8-bit table (some insns are ambiguous to 8 bits).
	(ppi_gensim, main): Generate 12-bit instead of 8-bit ppi table.

	* interp.c: Replace 'Hitachi' with 'Renesas'.
        (union saved_state_type): Add dbr, sgr, ldst.
        (get_loop_bounds_ext): New function.
        (init_dsp): Add bfd_mach_sh4al_dsp.
	(sim_resume): Handle extended loop bounds.
@
text
@d52 1
a52 1
    "R[n] += SEXT(i);",
d88 1
a88 1
    "  SET_NIP (PC + 4 + (SEXT(i) * 2));",
d238 1
a238 1
    "/* FIXME: FR(n) &= 0x7fffffff; */",
d266 1
a266 1
    "  u.f = DR(n);",
d283 1
a283 1
    "  SET_DR(n, u.f);",
d311 1
a311 1
    "SET_FR (n, (float)0.0);",
d317 1
a317 1
    "SET_FR (n, (float)1.0);",
d328 1
a328 1
    "  u.f = FR(n);",
d336 1
a336 1
    "  SET_DR (n, (double)FPUL);",
d339 1
a339 1
    "  SET_FR (n, (float)FPUL);",
d345 1
a345 1
    "SET_FR (n, FR(m) * FR(0) + FR(n));",
d373 1
a373 1
    "  WLAT (R[n], FI(m));",
d386 1
a386 1
    "  SET_FI(n, RLAT(R[m]));",
d416 1
a416 1
    "  WLAT (R[n], FI(m));",
d429 1
a429 1
    "  SET_FI(n, RLAT(R[0] + R[m]));",
d442 1
a442 1
    "  WLAT((R[0]+R[n]), FI(m));",
d450 1
a450 1
    "FP_OP(n, *, m);",
d455 1
a455 1
    "FP_UNARY(n, -);",
d460 1
a460 1
    "SET_FPSCR (GET_FPSCR() ^ FPSCR_MASK_PR);",
d468 1
a468 1
    "  SET_FPSCR (GET_FPSCR() ^ FPSCR_MASK_FR);",
d484 1
a484 1
    "SET_FPSCR (GET_FPSCR() ^ FPSCR_MASK_SZ);",
d489 1
a489 1
    "FP_UNARY(n, sqrt);",
d502 1
a502 1
    "FP_OP(n, -, m);",
d509 1
a509 1
    "  if (DR(n) != DR(n)) /* NaN */",
d512 1
a512 1
    "    FPUL =  (int)DR(n);",
d515 1
a515 1
    "if (FR(n) != FR(n)) /* NaN */",
d518 1
a518 1
    "  FPUL = (int)FR(n);",
d646 1
a646 1
    "SREG (m) = RLAT(R[n]);",
d651 1
a651 1
    "SET_FPSCR(R[n]);",
d656 1
a656 1
    "SET_FPSCR (RLAT(R[n]));",
d665 1
a665 1
    "macl(&R0,memory,n,m);",
d669 1
a669 1
    "macw(&R0,memory,n,m,endianw);",
d673 1
a673 1
    "R[n] = SEXT(i);",
d893 1
a893 1
    "MACL = ((int)(short)R[n]) * ((int)(short)R[m]);",
d898 2
a899 2
    "MACL = (((unsigned int)(unsigned short)R[n])",
    "        * ((unsigned int)(unsigned short)R[m]));",
d1187 1
a1187 1
    "ult = RBAT(R[n]);",
d1189 1
a1189 1
    "WBAT(R[n],ult|0x80);",
d1199 3
a1201 3
    "  R[15]-=4;",
    "  WLAT (R[15], GET_SR());",
    "  R[15]-=4;",
d1205 1
a1205 1
    "  SSR = GET_SR();",
d1207 1
a1207 1
    "  SET_SR (GET_SR() | SR_MASK_MD | SR_MASK_BL | SR_MASK_RB);",
d1245 1
a1245 1
    "divl(0,R[n],R[m]);",
d1248 1
a1248 1
    "divl(0,R[n],R[m]);",
d2622 1
a2622 1
		  printf ("<<1");
d2625 1
a2625 1
		  printf ("<<2");
d2634 1
a2634 1
	  printf ("      i = (i ^ (1<<%d))-(1<<%d);\n",
d2639 1
a2639 1
	printf ("      TB(m,n);\n");  
d2641 1
a2641 1
	printf ("      TL(m);\n");
d2643 1
a2643 1
	printf ("      TL(n);\n");
d2650 5
a2654 5
	    if (*r == '0') printf("      CREF(0);\n"); 
	    if (*r == '8') printf("      CREF(8);\n"); 
	    if (*r == '9') printf("      CREF(9);\n"); 
	    if (*r == 'n') printf("      CREF(n);\n"); 
	    if (*r == 'm') printf("      CREF(m);\n"); 
d2673 3
a2675 3
	    if (*r == '0') printf("      CDEF(0);\n"); 
	    if (*r == 'n') printf("      CDEF(n);\n"); 
	    if (*r == 'm') printf("      CDEF(m);\n"); 
d2723 10
a2732 6
	if (isupper(*s)) 
	  *s = tolower(*s);
	if (isalpha(*s)) printf("%c", *s);
	if (*s == ' ') printf("_");
	if (*s == '@@') printf("ind_");
	if (*s == ',') printf("_");
d2735 1
a2735 1
      printf(" %d\n",p->index);
d2742 1
a2742 1
   right entries in 'table' with the opcode index.  
@


1.22
log
@2003-12-18  Michael Snyder  <msnyder@@redhat.com>

        * gencode.c (expand_opcode): Simplify and reorganize.
        Eliminate "shift" parameter.  Eliminate "4 bits at a time"
        assumption.  Flatten switch statement to a single level.
        Add "eeee" token for even-numbered registers.
        (bton): Delete.
        (fsca): Use "eeee" token.
        (ppi_moves): Rename to "expand_ppi_movxy".  Do the ddt
        [movx/movy] expansion here, as well as the ppi expansion.
        (gensim_caselist): Accept 'eeee' along with 'nnnn'.
@
text
@d1 2
a2 1
/* Simulator/Opcode generator for the Hitachi Super-H architecture.
d155 5
d204 1
a204 1
  { "", "nm", "div1 <REG_M>,<REG_N>", "0011nnnnmmmm0100", /* ? MVS */
d294 13
a306 4
  { "", "", "fipr <FV_M>,<FV_N>", "1111nnmm11101101",
    "/* FIXME: not implemented */",
    "RAISE_EXCEPTION (SIGILL);",
    "/* FIXME: check for DP and (n & 1) == 0? */",
d458 5
d521 11
a568 1
#if 0
d570 10
a579 2
    "DBR = R[n];",
    "/* FIXME: user mode */",
a580 1
#endif
a597 1
#if 0
d599 18
a616 4
    "MA (1);",
    "DBR = RLAT (R[n]);",
    "R[n] += 4;",
    "/* FIXME: user mode */",
a617 1
#endif
d627 14
d843 19
d866 15
d882 1
a882 1
    "MACL = ((int)R[n]) * ((int)R[m]);",
d884 2
a885 1
#if 0
d921 6
d958 12
d1017 12
a1110 1
#if 0
d1112 4
a1115 1
    "R[n] = SGR;",
d1118 4
a1121 1
    "R[n] = DBR;",
a1122 1
#endif
a1127 1
#if 0
d1129 8
a1136 3
    "MA (1);",
    "R[n] -= 4;",
    "WLAT (R[n], SGR);",
d1139 8
a1146 3
    "MA (1);",
    "R[n] -= 4;",
    "WLAT (R[n], DBR);",
a1147 1
#endif
d1401 1
a1401 1
  { "", "n", "movx.w @@<REG_x>,<DSP_XX>",   "111100xxXX000100",
d1403 7
a1409 1
    "iword &= 0xfd53; goto top;",
d1411 1
a1411 1
  { "n", "n", "movx.w @@<REG_x>+,<DSP_XX>", "111100xxXX001000",
d1414 8
a1421 1
    "iword &= 0xfd53; goto top;",
d1423 1
a1423 1
  { "n", "n8","movx.w @@<REG_x>+REG_8,<DSP_XX>", "111100xxXX001100",
d1426 8
a1433 1
    "iword &= 0xfd53; goto top;",
d1435 1
a1435 1
  { "", "n", "movx.w <DSP_Aa>,@@<REG_x>",   "111100xxaa100100",
d1437 7
a1443 1
    "iword &= 0xfd53; goto top;",
d1445 1
a1445 1
  { "n", "n", "movx.w <DSP_Aa>,@@<REG_x>+", "111100xxaa101000",
d1448 4
a1451 1
    "iword &= 0xfd53; goto top;",
d1453 5
a1457 1
  { "n", "n8","movx.w <DSP_Aa>,@@<REG_x>+REG_8","111100xxaa101100",
d1460 8
a1467 1
    "iword &= 0xfd53; goto top;",
d1469 1
a1469 1
  { "", "n", "movy.w @@<REG_y>,<DSP_YY>",   "111100yyYY000001",
d1472 1
a1472 1
  { "n", "n", "movy.w @@<REG_y>+,<DSP_YY>", "111100yyYY000010",
d1476 1
a1476 1
  { "n", "n9","movy.w @@<REG_y>+REG_9,<DSP_YY>", "111100yyYY000011",
d1480 1
a1480 1
  { "", "n", "movy.w <DSP_Aa>,@@<REG_y>",   "111100yyAA010001",
d1483 1
a1483 1
  { "n", "n", "movy.w <DSP_Aa>,@@<REG_y>+", "111100yyAA010010",
d1487 1
a1487 1
  { "n", "n9", "movy.w <DSP_Aa>,@@<REG_y>+REG_9", "111100yyAA010011",
d1491 22
d1667 1
a1667 1
  { "","", "pcmp Sx,Sy",	"10000100xxyy....",
d1684 18
d1719 12
d1741 25
d1789 11
d1880 12
d1981 15
d2111 21
d2295 6
a2300 7
	    /* Consume an arbitrary number of ones and zeros.  */
	    do {
	      j = (j << 1) + (s[m++] - '0');
	    } while (s[m] == '0' || s[m] == '1');
	    expand_opcode ((val << m) | j, i, s + m);
	    break;

d2305 2
a2306 3
	case 'x':	/* xx -- 2-way fork */
	  /* Cross-breeding with movy moved to separate function.  */
	  for (j = 0; j < 4; j += 2)
d2309 2
a2310 2
	case 'y':	/* yy -- two-way fork */
	  for (j = 0; j < 2; j++)
d2313 8
d2358 4
d2363 2
a2364 2
	  /* XX, aa -- two-way fork */
	  for (j = 0; j < 4; j += 2)
d2368 4
d2373 2
a2374 2
	  /* YY, AA -- two-way fork */
	  for (j = 0; j < 2; j++)
d2377 16
a2461 18
    if ((i & 3) == 0 && (i & 12) != 0 && table[i] != 0)
      {
	/* A movx insn, which needs to be filled out with the 
	   corresponding movy insns.  This used to be done in
	   expand_opcode.  */
	int m, mv;

	for (m = 0; m < 32; m++)
	  {
	    /* Ignore illegal nopy */
	    if ((m & 7) == 0 && m != 0)
	      continue;
	    mv = m & 3 | (m & 4) << 2 | (m & 8) << 3 | (m & 16) << 4;
	    table [i | mv] = table [i];
	  }
      }

  for (i = 0xf000; i < 0xf400; i++)
d2492 12
d2522 8
a2529 1
	      printf ("      int n = ((iword >> 9) & 1) + 4;\n");
d2534 8
a2541 1
	      printf ("      int n = ((iword >> 8) & 1) + 6;\n");
d2554 8
a2561 1
	      printf ("      int m = ((iword >> 7) & 1) + 8;\n");
d2565 8
a2572 1
	      printf ("      int m = 7 - ((iword >> 6) & 2);\n");
d2576 8
a2583 1
	      printf ("      int m = ((iword >> 6) & 1) + 10;\n");
d2587 8
a2594 1
	      printf ("      int m = 7 - ((iword >> 5) & 2);\n");
d2688 12
d2738 2
a2739 1
   right entries in 'table' with the opcode index.  */
d2749 1
a2749 1
  for (;;)
d2751 32
a2782 38
      switch (s[0])
	{
	default:
	  fprintf (stderr, "gencode/expand_ppi_code: Illegal char '%c'\n",
		   s[0]);
	  exit (2);
	  break;
	/* The last eight bits are disregarded for the switch table.  */
	case 'm':
	case 'x':
	case '.':
	  table[val] = i;
	  return;
	case '0':
	  val += val;
	  s++;
	  break;
	case '1':
	  val += val + 1;
	  s++;
	  break;
	case 'i':
	case 'e': case 'f':
	  val += val;
	  s++;
	  expand_ppi_code (val, i, s);
	  val++;
	  break;
	case 'c':
	  val <<= 2;
	  s += 2;
	  val++;
	  expand_ppi_code (val, ppi_index++, s);
	  val++;
	  expand_ppi_code (val, i, s);
	  val++;
	  break;
	}
d2834 1
d2836 1
d2838 1
d2840 1
d2842 1
d2844 1
d2851 1
a2851 1
  printf ("  switch (ppi_table[iword >> 8]) {\n");
d3012 1
a3012 1
	  dumptable ("ppi_table", 1 << 8, 0);
@


1.21
log
@	* interp.c (fsca_s, fsrra_s): New functions.
	* gencode.c (tab): Add entries for fsca and fsrra.
	(expand_opcode): Allow variable length n / m fields.
@
text
@d452 1
a452 1
  { "", "", "fsca", "1111nnn011111101",
a1952 20
/* Convert a string of 4 binary digits into an int */

static
int
bton (s)
     char *s;

{
  int n = 0;
  int v = 8;
  while (v)
    {
      if (*s == '1')
	n |= v;
      v >>= 1;
      s++;
    }
  return n;
}

d1955 2
a1956 2
/* Take an opcode expand all varying fields in it out and fill all the
  right entries in 'table' with the opcode index*/
d1959 1
a1959 2
expand_opcode (shift, val, i, s)
     int shift;
a1963 2
  int j;

d1970 2
d1974 3
a1976 1

d1979 6
a1984 2
	  {
	    int m, mv;
d1986 15
a2000 24
	    if (s[1] - '0' > 1U || !s[2] || ! s[3])
	      expand_opcode (shift - 1, val + s[0] - '0', i, s + 1);
	    val |= bton (s) << shift;
	    if (s[2] == '0' || s[2] == '1')
	      expand_opcode (shift - 4, val, i, s + 4);
	    else if (s[2] == 'N')
	      for (j = 0; j < 4; j++)
		expand_opcode (shift - 4, val | (j << shift), i, s + 4);
	    else if (s[2] == 'x')
	      for (j = 0; j < 4; j += 2)
		for (m = 0; m < 32; m++)
		  {
		    /* Ignore illegal nopy */
		    if ((m & 7) == 0 && m != 0)
		      continue;
		    mv = m & 3 | (m & 4) << 2 | (m & 8) << 3 | (m & 16) << 4;
		    expand_opcode (shift - 4, val | mv | (j << shift), i,
				   s + 4);
		  }
	    else if (s[2] == 'y')
	      for (j = 0; j < 2; j++)
		expand_opcode (shift - 4, val | (j << shift), i, s + 4);
	    break;
	  }
d2003 10
a2012 11
	  {
	    int digits = 1;
	    while (s[digits] == s[0])
	      digits++;
	    for (j = 0; j < (1 << digits); j++)
	      {
		expand_opcode (shift - digits, val | (j << shift), i,
			       s + digits);
	      }
	    break;
	  }
d2014 5
a2018 4
	  /* A1, A0,X0,X1,Y0,Y1,M0,A1G,M1,M1G */
	  for (j = 5; j < 16; j++)
	    if (j != 6)
	      expand_opcode (shift - 4, val | (j << shift), i, s + 4);
d2021 2
a2022 1
	  /* A1G, A0G: */
d2024 1
a2024 1
	    expand_opcode (shift - 4, val | (j << shift), i, s + 4);
d2027 1
d2030 1
a2030 1
	    expand_opcode (shift - 4, val | (j << shift), i, s + 4);
d2033 1
a2033 1
	    expand_opcode (shift - 4, val | (j << shift), i, s + 4);
d2037 3
a2039 3
	  val |= bton (s) << shift;
	  for (j = 0; j < 16; j += 8)
	    expand_opcode (shift - 4, val | (j << shift), i, s + 4);
d2043 3
a2045 3
	  val |= bton (s) << shift;
	  for (j = 0; j < 8; j += 4)
	    expand_opcode (shift - 4, val | (j << shift), i, s + 4);
a2046 6

	default:
	  for (j = 0; j < (1 << (shift + 4)); j++)
	    {
	      table[val | j] = i;
	    }
d2102 1
a2102 1
      expand_opcode (12, 0, p->index, p->code);
d2111 1
a2111 1
ppi_moves ()
d2116 18
d2172 2
a2173 1
	      printf ("      int n = (iword >>8) & 0xf;\n");
d2196 1
a2196 1
	      printf ("      int m = (iword >>4) & 0xf;\n");
d2612 1
a2612 1
	  ppi_moves ();
@


1.20
log
@2003-08-11  Shrinivas Atre  <shrinivasa@@KPITCummins.com>
	* sim/sh/gencode.c ( tab[] ): Addition of MAC.L handler and
        correction for MAC.W handler
        * sim/sh/interp.c ( macl ): New Function. Implementation of
        MAC.L handler.
@
text
@d452 11
d472 8
d2001 2
d2027 11
a2037 6
	  for (j = 0; j < 16; j++)
	    {
	      expand_opcode (shift - 4, val | (j << shift), i, s + 4);

	    }
	  break;
@


1.19
log
@2003-08-07  Michael Snyder  <msnyder@@redhat.com>

        * gencode.c (expand_ppi_code): Comment spelling fix.
@
text
@d583 1
a583 2
    "trap (255, R0, PC, memory, maskl, maskw, endianw);",
    "/* FIXME: mac.l support */",
d587 1
a587 1
    "macw(R0,memory,n,m,endianw);",
@


1.18
log
@2003-07-25  Michael Snyder  <msnyder@@redhat.com>

        * gencode.c (pshl): Change < to <= (shift by 16 is allowed).
        Cast argument of >> to unsigned to prevent sign extension.
        (psha): Change < to <= (shift by 32 is allowed).
@
text
@d2327 1
a2327 1
/* Take an ppi code, expand all varying fields in it and fill all the
@


1.17
log
@2003-07-24  Michael Snyder  <msnyder@@redhat.com>

        * gencode.c: Fix typo in comment.
@
text
@d1309 1
a1309 1
    "if (i < 16)",
d1312 1
a1312 1
    "  res = Sz >> 128 - i;",
d1326 1
a1326 1
    "if (i < 32)",
d1528 1
a1528 1
    "if (Sy < 16)",
d1531 1
a1531 1
    "  res = Sx >> 128 - Sy;",
d1544 1
a1544 1
    "if (Sy < 32)",
@


1.16
log
@2003-07-23  Michael Snyder  <msnyder@@redhat.com>

        * gencode.c: A few more fix-ups of refs and defs.
        (frchg): Raise SIGILL if in double-precision mode.
        (ldtlb): We don't simulate cache, so this is a no-op.
        (movsxy_tab): Correct a few bit pattern errors.
@
text
@d2109 1
a2109 1
/* Table already contais all the switch case tags for 16-bit opcode double
@


1.15
log
@2003-07-09  Michael Snyder  <msnyder@@redhat.com>

        * gencode.c (prnd): Clear LSW of result to zeros.
@
text
@d375 1
a375 1
  { "", "m", "fmov.s @@<REG_M>+,<FREG_N>", "1111nnnnmmmm1001",
d445 4
a448 1
    "SET_FPSCR (GET_FPSCR() ^ FPSCR_MASK_FR);",
d579 1
a579 1
    "/* FIXME: XXX*/ abort();",
d806 1
a806 1
    "RSBAT (R[n]); /* Take exceptions like byte load.  */",
d811 1
a811 1
    "RSBAT (R[n]); /* Take exceptions like byte load.  */",
d816 1
a816 1
    "RSBAT (R[n]); /* Take exceptions like byte load.  */",
d1252 1
a1252 1
  { "n", "n8","movx.w @@<REG_x>+REG_8,<DSP_XX>", "111100xxXX001000",
d1278 1
a1278 1
  { "n", "n9","movy.w @@<REG_y>+REG_9,<DSP_YY>", "111100yyYY000010",
d1289 1
a1289 1
  { "n", "n9", "movy.w <DSP_Aa>,@@<REG_y>+REG_9", "111100yyAA010010",
d2144 5
a2148 4
              fprintf (stderr, "gencode/gensim_caselist: illegal char '%c'\n",
                       *s);
              exit (1);
              break;
d2342 4
a2345 4
        default:
          fprintf (stderr, "gencode/expand_ppi_code: Illegal char '%c'\n",
                   s[0]);
          exit (2);
@


1.14
log
@2003-07-09  Michael Snyder  <msnyder@@redhat.com>

        * gencode.c (pmuls): Expression is mis-parenthesized.
@
text
@d1482 1
a1482 1
    "res = Sx + 0x8000;",
d1515 1
a1515 1
    "res = Sy + 0x8000;",
@


1.13
log
@2003-07-09  Michael Snyder  <msnyder@@redhat.com>

        * gencode.c (ppi_gensim): For a conditional ppi insn, if the
        condition is false, we want to return (not break).  A break
        will take us to the end of the function where registers will
	be updated, whereas the desired outcome is for nothing to change.
@
text
@d1362 1
a1362 1
    "res = (DSP_R (e)) >> 16 * (DSP_R (f) >> 16) * 2;",
d1375 1
a1375 1
    "res = (DSP_R (e)) >> 16 * (DSP_R (f) >> 16) * 2;",
d1394 1
a1394 1
    "res = (DSP_R (e)) >> 16 * (DSP_R (f) >> 16) * 2;",
@


1.12
log
@2003-06-27  Michael Snyder  <msnyder@@redhat.com>

        * gencode.c (op tab): Some fix-ups of refs and defs.
        (ocbi, ocbp): Cache not simulated, but may cause memory fault.
        (gensym_caselist): Add default case to switch statement.
        (expand_ppi_code): Add default case to switch statement.
@
text
@d2472 1
a2472 1
	      printf ("\tbreak;\n");
@


1.11
log
@2003-06-27  Michael Snyder  <msnyder@@redhat.com>

        * gencode.c (op tab): Implement movca.l.
@
text
@d198 1
a198 1
  { "", "", "div1 <REG_M>,<REG_N>", "0011nnnnmmmm0100",
d349 1
a349 1
  { "", "", "fmov.s <FREG_M>,@@<REG_N>", "1111nnnnmmmm1010",
d362 1
a362 1
  { "", "", "fmov.s @@<REG_M>,<FREG_N>", "1111nnnnmmmm1000",
d375 1
a375 1
  { "", "", "fmov.s @@<REG_M>+,<FREG_N>", "1111nnnnmmmm1001",
d390 1
a390 1
  { "", "", "fmov.s <FREG_M>,@@-<REG_N>", "1111nnnnmmmm1011",
d405 1
a405 1
  { "", "", "fmov.s @@(R0,<REG_M>),<FREG_N>", "1111nnnnmmmm0110",
d418 1
a418 1
  { "", "", "fmov.s <FREG_M>,@@(R0,<REG_N>)", "1111nnnnmmmm0111",
d522 1
a522 1
  { "", "n", "ldc.l @@<REG_N>+,<CREG_M>", "0100nnnnmmmm0111",
d528 1
a528 1
  { "", "n", "ldc.l @@<REG_N>+,SR", "0100nnnn00000111",
d534 1
a534 1
  { "", "n", "ldc.l @@<REG_N>+,MOD", "0100nnnn01010111",
d540 1
a540 1
  { "", "n", "ldc.l @@<REG_N>+,DBR", "0100nnnn11110110",
d559 1
a559 1
  { "", "n", "lds.l @@<REG_N>+,<SREG_M>", "0100nnnnssss0110",
d569 1
a569 1
  { "", "n", "lds.l @@<REG_N>+,FPSCR", "0100nnnn01100110",
d579 1
a579 1
  { "", "nm", "mac.l @@<REG_M>+,@@<REG_N>+", "0000nnnnmmmm1111",
d584 1
a584 1
  { "", "nm", "mac.w @@<REG_M>+,@@<REG_N>+", "0100nnnnmmmm1111",
d610 1
a610 1
  { "n", "m", "mov.b @@<REG_M>+,<REG_N>", "0110nnnnmmmm0100",
d632 1
a632 1
  { "", "nm", "mov.b <REG_M>,@@-<REG_N>", "0010nnnnmmmm0100",
d686 1
a686 1
  { "", "nm", "mov.l <REG_M>,@@-<REG_N>", "0010nnnnmmmm0110",
d802 3
a804 3
  { "0", "", "ocbi @@<REG_N>", "0000nnnn10010011",
    "/* FIXME: Not implemented */",
    "RAISE_EXCEPTION (SIGILL);",
d807 3
a809 3
  { "0", "", "ocbp @@<REG_N>", "0000nnnn10100011",
    "/* FIXME: Not implemented */",
    "RAISE_EXCEPTION (SIGILL);",
d884 1
a884 1
  { "", "n", "setrc #<imm>", "10000010i8*1....",
d2141 4
d2338 5
@


1.10
log
@2003-06-27  Michael Snyder  <msnyder@@redhat.com>

        * gencode.c (op movsxy_tab): Fix an error in the bit pattern.
@
text
@d753 4
a756 3
  { "0", "", "movca.l @@R0, <REG_N>", "0000nnnn11000011",
    "/* FIXME: Not implemented */",
    "RAISE_EXCEPTION (SIGILL);",
@


1.9
log
@2003-06-27  Michael Snyder  <msnyder@@redhat.com>

        * gencode.c (gensim_caselist): The movy instructions use
        registers R6 and R7 (not R4 and R5 like the movx insns).
@
text
@d1262 1
a1262 1
  { "n", "n8","movx.w <DSP_Aa>,@@<REG_x>+REG_8","111100xxaa101000",
@


1.8
log
@2003-07-03  Michael Snyder  <msnyder@@redhat.com>

	* gencode.c (movs): Fix a couple of text transpositions.
@
text
@d2162 1
a2162 1
	      printf ("      int n = ((iword >> 8) & 1) + 4;\n");
@


1.7
log
@2003-06-27  Michael Snyder  <msnyder@@redhat.com>

        * gencode.c (op movsxy_tab): Fix up some copy/paste errors
        in name: s/REG_x/REG_y/.
@
text
@d1140 1
a1140 1
  { "n", "n", "<DSP_REG_M>,movs.w @@-<REG_N>", "111101NNMMMM0001",
d1201 1
a1201 1
  { "n", "n", "<DSP_REG_M>,movs.l @@-<REG_N>", "111101NNMMMM0011",
d1220 1
a1220 1
  { "n", "n", "<DSP_GRD_M>,movs.l @@-<REG_N>", "111101NNGGGG0011",
@


1.6
log
@2003-06-27  Michael Snyder  <msnyder@@redhat.com>

	* gencode.c (op tab): Move misplaced semicolon.
@
text
@d1270 1
a1270 1
  { "n", "n", "movy.w @@<REG_x>+,<DSP_YY>", "111100yyYY000010",
d1274 1
a1274 1
  { "n", "n9","movy.w @@<REG_x>+REG_9,<DSP_YY>", "111100yyYY000010",
d1278 1
a1278 1
  { "", "n", "movy.w <DSP_Aa>,@@<REG_x>",   "111100yyAA010001",
d1281 1
a1281 1
  { "n", "n", "movy.w <DSP_Aa>,@@<REG_x>+", "111100yyAA010010",
d1285 1
a1285 1
  { "n", "n9", "movy.w <DSP_Aa>,@@<REG_x>+REG_9", "111100yyAA010010",
@


1.5
log
@Commit Sh2E addition
@
text
@d697 2
a698 2
    "MA (1)",
    ";R0 = RSWAT (i + GBR);",
@


1.4
log
@gcc uses trap 33 for profiling, but the simulator didn't support it.
This patch fixes the gcc.dg/nest.c failures for sh-elf.

Fri Oct 11 16:22:28 2002  J"orn Rennecke <joern.rennecke@@superh.com>

	* interp.c (trap): Return int.  Take extra parameter for address
	of the trap instruction.  Changed all callers.
	Add case 33 for profiling.
	* gencode.c (trapa): Handle trap 33 using the trap function.
	Add read of vector for generic traps.
@
text
@d229 1
a229 1
  /* sh3e */
d235 1
a235 1
  /* sh3e */
d240 1
a240 1
  /* sh3e */
d244 1
a244 1
  /* sh3e */
d281 1
a281 1
  /* sh3e */
d294 1
a294 1
  /* sh3e */
d300 1
a300 1
  /* sh3e */
d306 1
a306 1
  /* sh3e */
d317 1
a317 1
  /* sh3e */
d328 1
a328 1
  /* sh3e */
d334 1
a334 1
  /* sh3e */
d348 1
a348 1
  /* sh3e */
d361 1
a361 1
  /* sh3e */
d374 1
a374 1
  /* sh3e */
d389 1
a389 1
  /* sh3e */
d404 1
a404 1
  /* sh3e */
d417 1
a417 1
  /* sh3e */
d433 1
a433 1
  /* sh3e */
d438 1
a438 1
  /* sh3e */
d458 1
a458 1
  /* sh3e */
d463 1
a463 1
  /* sh3e */
d479 1
a479 1
  /* sh3e */
d564 1
a564 1
  /* sh3e / sh-dsp (lds <REG_N>,DSR) */
d568 1
a568 1
  /* sh3e / sh-dsp (lds.l @@<REG_N>+,DSR) */
@


1.3
log
@* pendanticism

2000-10-24  Ben Elliston  <bje@@redhat.com>

	* gencode.c (tab): Delimit strings with commas where applicable.
@
text
@d580 1
a580 1
    "trap (255,R0,memory,maskl,maskw, endianw);",
d954 1
a954 2
    "nip = PC;",
    "trap (0xc3, R0, memory, maskl, maskw, endianw);",
d1031 3
d1035 1
a1036 6
    "long imm = 0xff & i;",
    "if (i==0xc3)",
    "  PC-=2;",
    "if (i<20||i==34||i==0xc3)",
    "  trap(i,R,memory,maskl,maskw,endianw);",
    "else {",
d1038 1
a1038 1
    "  WLAT(R[15],GET_SR());",
d1040 1
a1040 3
    "  WLAT(R[15],PC+2);",
    "  PC=RLAT(VBR+(imm<<2))-2;",
    "}",
a1041 7
    "if (i == 0xc3)",
    "  {",
    "    nip = PC;",
    "    trap (i, R, memory, maskl, maskw,endianw);",
    "  }",
    "else if (i < 20 || i==34 || i==0xc3)",
    "  trap (i, R, memory, maskl, maskw,endianw);",
a1042 1
    "  /* FIXME: TRA = (imm << 2); */",
d1047 2
a1048 1
    "  SET_NIP (PT2H (VBR + 0x00000100));",
a1049 1
#endif
@


1.3.14.1
log
@merge from mainline
@
text
@d580 1
a580 1
    "trap (255, R0, PC, memory, maskl, maskw, endianw);",
d954 2
a955 1
    "nip += trap (0xc3, R0, PC, memory, maskl, maskw, endianw);",
d1032 2
d1035 4
a1038 3
    "if (i < 20 || i == 33 || i == 34 || i == 0xc3)",
    "  nip += trap (i, R, PC, memory, maskl, maskw,endianw);",
#if 0
a1039 1
    /* SH-[12] */
d1041 1
a1041 1
    "  WLAT (R[15], GET_SR());",
d1043 3
a1045 1
    "  WLAT (R[15], PH2T (PC + 2));",
d1047 7
d1055 1
d1060 2
a1062 2
    "  SET_NIP (PT2H (RLAT (VBR + (imm<<2))));",
    "}",
@


1.3.24.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d580 1
a580 1
    "trap (255, R0, PC, memory, maskl, maskw, endianw);",
d954 2
a955 1
    "nip += trap (0xc3, R0, PC, memory, maskl, maskw, endianw);",
d1032 2
d1035 4
a1038 3
    "if (i < 20 || i == 33 || i == 34 || i == 0xc3)",
    "  nip += trap (i, R, PC, memory, maskl, maskw,endianw);",
#if 0
a1039 1
    /* SH-[12] */
d1041 1
a1041 1
    "  WLAT (R[15], GET_SR());",
d1043 3
a1045 1
    "  WLAT (R[15], PH2T (PC + 2));",
d1047 7
d1055 1
d1060 2
a1062 2
    "  SET_NIP (PT2H (RLAT (VBR + (imm<<2))));",
    "}",
@


1.3.24.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d198 1
a198 1
  { "", "nm", "div1 <REG_M>,<REG_N>", "0011nnnnmmmm0100", /* ? MVS */
d229 1
a229 1
  /* sh2e */
d235 1
a235 1
  /* sh2e */
d240 1
a240 1
  /* sh2e */
d244 1
a244 1
  /* sh2e */
d281 1
a281 1
  /* sh2e */
d294 1
a294 1
  /* sh2e */
d300 1
a300 1
  /* sh2e */
d306 1
a306 1
  /* sh2e */
d317 1
a317 1
  /* sh2e */
d328 1
a328 1
  /* sh2e */
d334 1
a334 1
  /* sh2e */
d348 2
a349 2
  /* sh2e */
  { "", "n", "fmov.s <FREG_M>,@@<REG_N>", "1111nnnnmmmm1010",
d361 2
a362 2
  /* sh2e */
  { "", "m", "fmov.s @@<REG_M>,<FREG_N>", "1111nnnnmmmm1000",
d374 2
a375 2
  /* sh2e */
  { "m", "m", "fmov.s @@<REG_M>+,<FREG_N>", "1111nnnnmmmm1001",
d389 2
a390 2
  /* sh2e */
  { "n", "n", "fmov.s <FREG_M>,@@-<REG_N>", "1111nnnnmmmm1011",
d404 2
a405 2
  /* sh2e */
  { "", "0m", "fmov.s @@(R0,<REG_M>),<FREG_N>", "1111nnnnmmmm0110",
d417 2
a418 2
  /* sh2e */
  { "", "0n", "fmov.s <FREG_M>,@@(R0,<REG_N>)", "1111nnnnmmmm0111",
d433 1
a433 1
  /* sh2e */
d438 1
a438 1
  /* sh2e */
d445 1
a445 15
    "if (FPSCR_PR)",
    "  RAISE_EXCEPTION (SIGILL);",
    "else",
    "  SET_FPSCR (GET_FPSCR() ^ FPSCR_MASK_FR);",
  },

  /* sh4 */
  { "", "", "fsca", "1111nnn011111101",
    "if (FPSCR_PR)",
    "  RAISE_EXCEPTION (SIGILL);",
    "else",
    "  {",
    "    SET_FR (n, fsca_s (FPUL, &sin));",
    "    SET_FR (n+1, fsca_s (FPUL, &cos));",
    "  }",
d458 1
a458 9
  /* sh4 */
  { "", "", "fsrra", "1111nnnn01111101",
    "if (FPSCR_PR)",
    "  RAISE_EXCEPTION (SIGILL);",
    "else",
    "  SET_FR (n, fsrra_s (FR (n)));",
  },

  /* sh2e */
d463 1
a463 1
  /* sh2e */
d479 1
a479 1
  /* sh2e */
d522 1
a522 1
  { "n", "n", "ldc.l @@<REG_N>+,<CREG_M>", "0100nnnnmmmm0111",
d528 1
a528 1
  { "n", "n", "ldc.l @@<REG_N>+,SR", "0100nnnn00000111",
d534 1
a534 1
  { "n", "n", "ldc.l @@<REG_N>+,MOD", "0100nnnn01010111",
d540 1
a540 1
  { "n", "n", "ldc.l @@<REG_N>+,DBR", "0100nnnn11110110",
d559 1
a559 1
  { "n", "n", "lds.l @@<REG_N>+,<SREG_M>", "0100nnnnssss0110",
d564 1
a564 1
  /* sh2e / sh-dsp (lds <REG_N>,DSR) */
d568 2
a569 2
  /* sh2e / sh-dsp (lds.l @@<REG_N>+,DSR) */
  { "n", "n", "lds.l @@<REG_N>+,FPSCR", "0100nnnn01100110",
d576 1
a576 1
    "/* We don't implement cache or tlb, so this is a noop.  */",
d579 3
a581 2
  { "nm", "nm", "mac.l @@<REG_M>+,@@<REG_N>+", "0000nnnnmmmm1111",
    "macl(&R0,memory,n,m);",
d584 2
a585 2
  { "nm", "nm", "mac.w @@<REG_M>+,@@<REG_N>+", "0100nnnnmmmm1111",
    "macw(&R0,memory,n,m,endianw);",
d610 1
a610 1
  { "nm", "m", "mov.b @@<REG_M>+,<REG_N>", "0110nnnnmmmm0100",
d632 1
a632 1
  { "n", "nm", "mov.b <REG_M>,@@-<REG_N>", "0010nnnnmmmm0100",
d686 1
a686 1
  { "n", "nm", "mov.l <REG_M>,@@-<REG_N>", "0010nnnnmmmm0110",
d697 2
a698 2
    "MA (1);",
    "R0 = RSWAT (i + GBR);",
d753 3
a755 4
  { "", "n0", "movca.l R0, @@<REG_N>", "0000nnnn11000011",
    "/* We don't simulate cache, so this insn is identical to mov.  */",
    "MA (1);",
    "WLAT (R[n], R[0]);",
d801 3
a803 3
  { "", "n", "ocbi @@<REG_N>", "0000nnnn10010011",
    "RSBAT (R[n]); /* Take exceptions like byte load, otherwise noop.  */",
    "/* FIXME: Cache not implemented */",
d806 3
a808 3
  { "", "n", "ocbp @@<REG_N>", "0000nnnn10100011",
    "RSBAT (R[n]); /* Take exceptions like byte load, otherwise noop.  */",
    "/* FIXME: Cache not implemented */",
d812 1
a812 1
    "RSBAT (R[n]); /* Take exceptions like byte load, otherwise noop.  */",
d883 1
a883 1
  { "", "", "setrc #<imm>", "10000010i8*1....",
d1140 1
a1140 1
  { "n", "n", "movs.w <DSP_REG_M>,@@-<REG_N>", "111101NNMMMM0001",
d1201 1
a1201 1
  { "n", "n", "movs.l <DSP_REG_M>,@@-<REG_N>", "111101NNMMMM0011",
d1220 1
a1220 1
  { "n", "n", "movs.l <DSP_GRD_M>,@@-<REG_N>", "111101NNGGGG0011",
d1248 1
a1248 1
  { "n", "n8","movx.w @@<REG_x>+REG_8,<DSP_XX>", "111100xxXX001100",
d1262 1
a1262 1
  { "n", "n8","movx.w <DSP_Aa>,@@<REG_x>+REG_8","111100xxaa101100",
d1270 1
a1270 1
  { "n", "n", "movy.w @@<REG_y>+,<DSP_YY>", "111100yyYY000010",
d1274 1
a1274 1
  { "n", "n9","movy.w @@<REG_y>+REG_9,<DSP_YY>", "111100yyYY000011",
d1278 1
a1278 1
  { "", "n", "movy.w <DSP_Aa>,@@<REG_y>",   "111100yyAA010001",
d1281 1
a1281 1
  { "n", "n", "movy.w <DSP_Aa>,@@<REG_y>+", "111100yyAA010010",
d1285 1
a1285 1
  { "n", "n9", "movy.w <DSP_Aa>,@@<REG_y>+REG_9", "111100yyAA010011",
d1305 1
a1305 1
    "if (i <= 16)",
d1308 1
a1308 1
    "  res = (unsigned) Sz >> 128 - i;	/* no sign extension */",
d1322 1
a1322 1
    "if (i <= 32)",
d1361 1
a1361 1
    "res = (DSP_R (e) >> 16) * (DSP_R (f) >> 16) * 2;",
d1374 1
a1374 1
    "res = (DSP_R (e) >> 16) * (DSP_R (f) >> 16) * 2;",
d1393 1
a1393 1
    "res = (DSP_R (e) >> 16) * (DSP_R (f) >> 16) * 2;",
d1481 1
a1481 1
    "res = (Sx + 0x8000) & 0xffff0000;",
d1514 1
a1514 1
    "res = (Sy + 0x8000) & 0xffff0000;",
d1524 1
a1524 1
    "if (Sy <= 16)",
d1527 1
a1527 1
    "  res = (unsigned) Sx >> 128 - Sy;	/* no sign extension */",
d1540 1
a1540 1
    "if (Sy <= 32)",
a1978 2
	    if (s[1] - '0' > 1U || !s[2] || ! s[3])
	      expand_opcode (shift - 1, val + s[0] - '0', i, s + 1);
d2003 6
a2008 11
	  {
	    int digits = 1;
	    while (s[digits] == s[0])
	      digits++;
	    for (j = 0; j < (1 << digits); j++)
	      {
		expand_opcode (shift - digits, val | (j << shift), i,
			       s + digits);
	      }
	    break;
	  }
d2105 1
a2105 1
/* Table already contains all the switch case tags for 16-bit opcode double
a2139 5
	    default:
	      fprintf (stderr, "gencode/gensim_caselist: illegal char '%c'\n",
		       *s);
	      exit (1);
	      break;
d2162 1
a2162 1
	      printf ("      int n = ((iword >> 8) & 1) + 6;\n");
d2318 1
a2318 1
/* Take a ppi code, expand all varying fields in it and fill all the
a2332 5
	default:
	  fprintf (stderr, "gencode/expand_ppi_code: Illegal char '%c'\n",
		   s[0]);
	  exit (2);
	  break;
d2462 1
a2462 1
	      printf ("\treturn;\n");
@


1.3.24.3
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d1 1
a1 2
/* Simulator/Opcode generator for the Renesas
   (formerly Hitachi) / SuperH Inc. Super-H architecture.
d51 1
a51 1
    "R[n] += SEXT (i);",
d87 1
a87 1
    "  SET_NIP (PC + 4 + (SEXT (i) * 2));",
a153 5
  /* sh4a */
  { "", "", "clrdmxy", "0000000010001000",
    "saved_state.asregs.cregs.named.sr &= ~(SR_MASK_DMX | SR_MASK_DMY);"
  },

d198 1
a198 1
  { "", "nm", "div1 <REG_M>,<REG_N>", "0011nnnnmmmm0100",
d232 1
a232 1
    "/* FIXME: FR (n) &= 0x7fffffff; */",
d260 1
a260 1
    "  u.f = DR (n);",
d277 1
a277 1
    "  SET_DR (n, u.f);",
d288 4
a291 13
  { "", "", "fipr <FV_M>,<FV_N>", "1111vvVV11101101",
    "if (FPSCR_PR)", 
    "  RAISE_EXCEPTION (SIGILL);",
    "else",
    "{",
    "  double fsum = 0;",
    "  /* FIXME: check for nans and infinities.  */",
    "  fsum += FR (v1+0) * FR (v2+0);",
    "  fsum += FR (v1+1) * FR (v2+1);",
    "  fsum += FR (v1+2) * FR (v2+2);",
    "  fsum += FR (v1+3) * FR (v2+3);",
    "  SET_FR (v1+3, fsum);",
    "}",
d296 1
a296 1
    "SET_FR (n, (float) 0.0);",
d302 1
a302 1
    "SET_FR (n, (float) 1.0);",
d313 1
a313 1
    "  u.f = FR (n);",
d321 1
a321 1
    "  SET_DR (n, (double) FPUL);",
d324 1
a324 1
    "  SET_FR (n, (float) FPUL);",
d330 1
a330 1
    "SET_FR (n, FR (m) * FR (0) + FR (n));",
d358 1
a358 1
    "  WLAT (R[n], FI (m));",
d371 1
a371 1
    "  SET_FI (n, RLAT (R[m]));",
d401 1
a401 1
    "  WLAT (R[n], FI (m));",
d414 1
a414 1
    "  SET_FI (n, RLAT (R[0] + R[m]));",
d427 1
a427 1
    "  WLAT ((R[0]+R[n]), FI (m));",
d435 1
a435 1
    "FP_OP (n, *, m);",
d440 1
a440 6
    "FP_UNARY (n, -);",
  },

  /* sh4a */
  { "", "", "fpchg", "1111011111111101",
    "SET_FPSCR (GET_FPSCR () ^ FPSCR_MASK_PR);",
d448 1
a448 1
    "  SET_FPSCR (GET_FPSCR () ^ FPSCR_MASK_FR);",
d452 1
a452 1
  { "", "", "fsca", "1111eeee11111101",
d464 1
a464 1
    "SET_FPSCR (GET_FPSCR () ^ FPSCR_MASK_SZ);",
d469 1
a469 1
    "FP_UNARY (n, sqrt);",
d482 1
a482 1
    "FP_OP (n, -, m);",
d489 1
a489 1
    "  if (DR (n) != DR (n)) /* NaN */",
d492 1
a492 1
    "    FPUL =  (int) DR (n);",
d495 1
a495 1
    "if (FR (n) != FR (n)) /* NaN */",
d498 1
a498 12
    "  FPUL = (int) FR (n);",
  },

  /* sh4 */
  { "", "", "ftrv <FV_N>", "1111vv0111111101",
    "if (FPSCR_PR)",
    "  RAISE_EXCEPTION (SIGILL);",
    "else",
    "{", 
    "  /* FIXME not implemented.  */",
    "  printf (\"ftrv xmtrx, FV%d\\n\", v1);",
    "}", 
d538 1
d540 2
a541 10
    "if (SR_MD)",
    "  DBR = R[n]; /* priv mode */",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
  },
  { "", "n", "ldc <REG_N>,SGR", "0100nnnn00111010",
    "if (SR_MD)",
    "  SGR = R[n]; /* priv mode */",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
d543 1
d561 1
d563 4
a566 18
    "if (SR_MD)",
    "{ /* priv mode */",
    "  MA (1);",
    "  DBR = RLAT (R[n]);",
    "  R[n] += 4;",
    "}",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
  },
  { "n", "n", "ldc.l @@<REG_N>+,SGR", "0100nnnn00110110",
    "if (SR_MD)",
    "{ /* priv mode */",
    "  MA (1);",
    "  SGR = RLAT (R[n]);",
    "  R[n] += 4;",
    "}",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
d568 1
a577 14
  /* sh4a */
  { "", "n", "ldrc <REG_N>", "0100nnnn00110100",
    "SET_RC (R[n]);",
    "loop = get_loop_bounds_ext (RS, RE, memory, mem_end, maskw, endianw);",
    "CHECK_INSN_PTR (insn_ptr);",
    "RE |= 1;",
  },
  { "", "", "ldrc #<imm>", "10001010i8*1....",
    "SET_RC (i);",
    "loop = get_loop_bounds_ext (RS, RE, memory, mem_end, maskw, endianw);",
    "CHECK_INSN_PTR (insn_ptr);",
    "RE |= 1;",
  },

d583 1
a583 1
    "SREG (m) = RLAT (R[n]);",
d588 1
a588 1
    "SET_FPSCR (R[n]);",
d593 1
a593 1
    "SET_FPSCR (RLAT (R[n]));",
d602 1
a602 1
    "macl (&R0,memory,n,m);",
d606 1
a606 1
    "macw (&R0,memory,n,m,endianw);",
d610 1
a610 1
    "R[n] = SEXT (i);",
a779 19
  { "n", "0", "movco.l R0, @@<REG_N>", "0000nnnn01110011", 
    "/* LDST -> T */",
    "SET_SR_T (LDST);",
    "/* if (T) R0 -> (Rn) */",
    "if (T)",
    "  WLAT (R[n], R[0]);",
    "/* 0 -> LDST */",
    "SET_LDST (0);",
  },

  { "0", "n", "movli.l @@<REG_N>, R0", "0000nnnn01100011", 
    "/* 1 -> LDST */",
    "SET_LDST (1);",
    "/* (Rn) -> R0 */",
    "R[0] = RLAT (R[n]);",
    "/* if (interrupt/exception) 0 -> LDST */",
    "/* (we don't simulate asynchronous interrupts/exceptions) */",
  },

a783 15
  { "0", "n", "movua.l @@<REG_N>,R0", "0100nnnn10101001",
    "int regn = R[n];",
    "MA (1);",
    "R[0] = (RBAT (regn) << 24) + (RBAT (regn + 1) << 16) + ",
    "  (RBAT (regn + 2) << 8) + RBAT (regn + 3);",
    "L (n);",
  },
  { "0n", "n", "movua.l @@<REG_N>+,R0", "0100nnnn11101001",
    "int regn = R[n];",
    "MA (1);",
    "R[0] = (RBAT (regn) << 24) + (RBAT (regn + 1) << 16) + ",
    "  (RBAT (regn + 2) << 8) + RBAT (regn + 3);",
    "R[n] += 4;",
    "L (n);",
  },
d785 1
a785 1
    "MACL = ((int) R[n]) * ((int) R[m]);",
d787 1
a787 2
#if 0  /* FIXME: The above cast to int is not really portable.
	  It should be replaced by a SEXT32 macro.  */
d795 1
a795 1
    "MACL = ((int) (short) R[n]) * ((int) (short) R[m]);",
d800 2
a801 2
    "MACL = (((unsigned int) (unsigned short) R[n])",
    "        * ((unsigned int) (unsigned short) R[m]));",
a822 6
  /* sh4a */
  { "", "n", "icbi @@<REG_N>", "0000nnnn11100011",
    "/* Except for the effect on the cache - which is not simulated -",
    "   this is like a nop.  */",
  },

a853 12
  /* sh4a */
  { "", "n", "prefi @@<REG_N>", "0000nnnn11010011",
    "/* Except for the effect on the cache - which is not simulated -",
    "   this is like a nop.  */",
  },

  /* sh4a */
  { "", "", "synco", "0000000010101011", 
    "/* Except for the effect on the pipeline - which is not simulated -", 
    "   this is like a nop.  */",
  },

a900 12
  /* sh4a */
  { "", "", "setdmx", "0000000010011000",
    "saved_state.asregs.cregs.named.sr |=  SR_MASK_DMX;"
    "saved_state.asregs.cregs.named.sr &= ~SR_MASK_DMY;"
  },

  /* sh4a */
  { "", "", "setdmy", "0000000011001000",
    "saved_state.asregs.cregs.named.sr |=  SR_MASK_DMY;"
    "saved_state.asregs.cregs.named.sr &= ~SR_MASK_DMX;"
  },

d983 1
d985 1
a985 4
    "if (SR_MD)",
    "  R[n] = SGR; /* priv mode */",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
d988 1
a988 4
    "if (SR_MD)",
    "  R[n] = DBR; /* priv mode */",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
d990 1
d996 1
d998 3
a1000 8
    "if (SR_MD)",
    "{ /* priv mode */",
    "  MA (1);",
    "  R[n] -= 4;",
    "  WLAT (R[n], SGR);",
    "}",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
d1003 3
a1005 8
    "if (SR_MD)",
    "{ /* priv mode */",
    "  MA (1);",
    "  R[n] -= 4;",
    "  WLAT (R[n], DBR);",
    "}",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
d1007 1
d1047 1
a1047 1
    "ult = RBAT (R[n]);",
d1049 1
a1049 1
    "WBAT (R[n],ult|0x80);",
d1059 3
a1061 3
    "  R[15] -= 4;",
    "  WLAT (R[15], GET_SR ());",
    "  R[15] -= 4;",
d1065 1
a1065 1
    "  SSR = GET_SR ();",
d1067 1
a1067 1
    "  SET_SR (GET_SR () | SR_MASK_MD | SR_MASK_BL | SR_MASK_RB);",
d1105 1
a1105 1
    "divl (0,R[n],R[m]);",
d1108 1
a1108 1
    "divl (0,R[n],R[m]);",
d1261 1
a1261 1
  { "", "n", "movx.w @@<REG_xy>,<DSP_XY>",   "111100xyXY0001??",
d1263 1
a1263 7
    "if (iword & 3)",
    "  {",
    "    iword &= 0xfd53; goto top;",
    "  }",
  },
  { "", "n", "movx.l @@<REG_xy>,<DSP_XY>",   "111100xyXY010100",
    "DSP_R (m) = RLAT (R[n]);",
d1265 1
a1265 1
  { "n", "n", "movx.w @@<REG_xy>+,<DSP_XY>", "111100xyXY0010??",
d1268 1
a1268 8
    "if (iword & 3)",
    "  {",
    "    iword &= 0xfd53; goto top;",
    "  }",
  },
  { "n", "n", "movx.l @@<REG_xy>+,<DSP_XY>", "111100xyXY011000",
    "DSP_R (m) = RLAT (R[n]);",
    "R[n] += ((R[n] & 0xffff) == MOD_ME) ? MOD_DELTA : 4;",
d1270 1
a1270 1
  { "n", "n8","movx.w @@<REG_xy>+REG_8,<DSP_XY>", "111100xyXY0011??",
d1273 1
a1273 8
    "if (iword & 3)",
    "  {",
    "    iword &= 0xfd53; goto top;",
    "  }",
  },
  { "n", "n8","movx.l @@<REG_xy>+REG_8,<DSP_XY>", "111100xyXY011100",
    "DSP_R (m) = RLAT (R[n]);",
    "R[n] += ((R[n] & 0xffff) == MOD_ME) ? MOD_DELTA : R[8];",
d1275 1
a1275 1
  { "", "n", "movx.w <DSP_Ax>,@@<REG_xy>",   "111100xyax1001??",
d1277 1
a1277 7
    "if (iword & 3)",
    "  {",
    "    iword &= 0xfd53; goto top;",
    "  }",
  },
  { "", "n", "movx.l <DSP_Ax>,@@<REG_xy>",   "111100xyax110100",
    "WLAT (R[n], DSP_R (m));",
d1279 1
a1279 1
  { "n", "n", "movx.w <DSP_Ax>,@@<REG_xy>+", "111100xyax1010??",
d1282 1
a1282 8
    "if (iword & 3)",
    "  {",
    "    iword &= 0xfd53; goto top;",
    "  }",
  },
  { "n", "n", "movx.l <DSP_Ax>,@@<REG_xy>+", "111100xyax111000",
    "WLAT (R[n], DSP_R (m));",
    "R[n] += ((R[n] & 0xffff) == MOD_ME) ? MOD_DELTA : 4;",
d1284 1
a1284 1
  { "n", "n8","movx.w <DSP_Ax>,@@<REG_xy>+REG_8","111100xyax1011??",
d1287 1
a1287 8
    "if (iword & 3)",
    "  {",
    "    iword &= 0xfd53; goto top;",
    "  }",
  },
  { "n", "n8","movx.l <DSP_Ax>,@@<REG_xy>+REG_8","111100xyax111100",
    "WLAT (R[n], DSP_R (m));",
    "R[n] += ((R[n] & 0xffff) == MOD_ME) ? MOD_DELTA : R[8];",
d1289 1
a1289 1
  { "", "n", "movy.w @@<REG_yx>,<DSP_YX>",   "111100yxYX000001",
d1292 1
a1292 1
  { "n", "n", "movy.w @@<REG_yx>+,<DSP_YX>", "111100yxYX000010",
d1296 1
a1296 1
  { "n", "n9","movy.w @@<REG_yx>+REG_9,<DSP_YX>", "111100yxYX000011",
d1300 1
a1300 1
  { "", "n", "movy.w <DSP_Ay>,@@<REG_yx>",   "111100yxAY010001",
d1303 1
a1303 1
  { "n", "n", "movy.w <DSP_Ay>,@@<REG_yx>+", "111100yxAY010010",
d1307 1
a1307 1
  { "n", "n9", "movy.w <DSP_Ay>,@@<REG_yx>+REG_9", "111100yxAY010011",
a1310 22
  { "", "n", "movy.l @@<REG_yx>,<DSP_YX>",   "111100yxYX100001",
    "DSP_R (m) = RLAT (R[n]);",
  },
  { "n", "n", "movy.l @@<REG_yx>+,<DSP_YX>", "111100yxYX100010",
    "DSP_R (m) = RLAT (R[n]);",
    "R[n] += ((R[n] | ~0xffff) == MOD_ME) ? MOD_DELTA : 4;",
  },
  { "n", "n9","movy.l @@<REG_yx>+REG_9,<DSP_YX>", "111100yxYX100011",
    "DSP_R (m) = RLAT (R[n]);",
    "R[n] += ((R[n] | ~0xffff) == MOD_ME) ? MOD_DELTA : R[9];",
  },
  { "", "n", "movy.l <DSP_Ay>,@@<REG_yx>",   "111100yxAY110001",
    "WLAT (R[n], DSP_R (m));",
  },
  { "n", "n", "movy.l <DSP_Ay>,@@<REG_yx>+", "111100yxAY110010",
    "WLAT (R[n], DSP_R (m));",
    "R[n] += ((R[n] | ~0xffff) == MOD_ME) ? MOD_DELTA : 4;",
  },
  { "n", "n9", "movy.l <DSP_Ay>,@@<REG_yx>+REG_9", "111100yxAY110011",
    "WLAT (R[n], DSP_R (m));",
    "R[n] += ((R[n] | ~0xffff) == MOD_ME) ? MOD_DELTA : R[9];",
  },
d1465 1
a1465 1
  { "","", "pcmp Sx,Sy",	"10000100xxyyzzzz",
a1481 18
  { "","", "(if cc) pabs Sx,Dz",	"100010ccxx01zzzz",
    "/* FIXME: duplicate code pabs.  */",
    "res = DSP_R (x);",
    "res_grd = GET_DSP_GRD (x);",
    "if (res >= 0)",
    "  carry = 0;",
    "else",
    "  {",
    "    res = -res;",
    "    carry = (res != 0); /* The manual has a bug here.  */", 
    "    res_grd = -res_grd - carry;", 
    "  }",
    "COMPUTE_OVERFLOW;",
    "/* ??? The re-computing of overflow after",
    "   saturation processing is specific to pabs.  */",
    "overflow = res_grd != SIGN32 (res) ? DSR_MASK_V : 0;",
    "ADD_SUB_GE;",
  },
a1498 12

  { "","", "(if cc) prnd Sx,Dz",	"100110ccxx01zzzz",
    "/* FIXME: duplicate code prnd.  */",
    "int Sx = DSP_R (x);",
    "int Sx_grd = GET_DSP_GRD (x);",
    "",
    "res = (Sx + 0x8000) & 0xffff0000;",
    "carry = (unsigned) res < (unsigned) Sx;",
    "res_grd = Sx_grd + carry;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
  },
a1508 25

  { "","", "(if cc) pabs Sy,Dz",	"101010cc01yyzzzz",
    "/* FIXME: duplicate code pabs.  */",
    "res = DSP_R (y);",
    "res_grd = 0;",
    "overflow = 0;",
    "greater_equal = DSR_MASK_G;",
    "if (res >= 0)",
    "  carry = 0;",
    "else",
    "  {",
    "    res = -res;",
    "    carry = 1;",
    "    if (res < 0)",
    "      {",
    "        if (S)",
    "          res = 0x7fffffff;",
    "        else",
    "          {",
    "            overflow = DSR_MASK_V;",
    "            greater_equal = 0;",
    "          }",
    "      }",
    "  }",
  },
a1531 11
  { "","", "(if cc) prnd Sy,Dz",	"101110cc01yyzzzz",
    "/* FIXME: duplicate code prnd.  */",
    "int Sy = DSP_R (y);",
    "int Sy_grd = SIGN32 (Sy);",
    "",
    "res = (Sy + 0x8000) & 0xffff0000;",
    "carry = (unsigned) res < (unsigned) Sy;",
    "res_grd = Sy_grd + carry;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
  },
a1611 12
  { "","", "(if cc) psub Sy,Sx,Dz",	"100001ccxxyyzzzz",
    "int Sx = DSP_R (x);",
    "int Sx_grd = GET_DSP_GRD (x);",
    "int Sy = DSP_R (y);",
    "int Sy_grd = SIGN32 (Sy);",
    "",
    "res = Sy - Sx;",
    "carry = (unsigned) res > (unsigned) Sy;",
    "res_grd = Sy_grd - Sx_grd - carry;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
  },
a1700 15
  { "","", "pclr Du pmuls Se,Sf,Dg",	"0100eeff0001gguu",
    "/* Do multiply.  */",
    "res = (DSP_R (e) >> 16) * (DSP_R (f) >> 16) * 2;",
    "if (res == 0x80000000)",
    "  res = 0x7fffffff;",
    "DSP_R (g) = res;",
    "DSP_GRD (g) = SIGN32 (res);",
    "/* FIXME: update DSR based on results of multiply!  */",
    "",
    "/* Do clr.  */",
    "z = u;",
    "res = 0;",
    "res_grd = 0;",
    "goto assign_z;",
  },
a1815 21
  /* sh4a */
  { "","", "(if cc) pswap Sx,Dz",	"100111ccxx01zzzz",
    "int Sx = DSP_R (x);",
    "",
    "res = ((Sx & 0xffff) * 65536) + ((Sx >> 16) & 0xffff);",
    "res_grd = GET_DSP_GRD (x);",
    "carry = 0;",
    "overflow = 0;",
    "greater_equal = res & 0x80000000 ? 0 : DSR_MASK_G;",
  },
  /* sh4a */
  { "","", "(if cc) pswap Sy,Dz",	"101111cc01yyzzzz",
    "int Sy = DSP_R (y);",
    "",
    "res = ((Sy & 0xffff) * 65536) + ((Sy >> 16) & 0xffff);",
    "res_grd = SIGN32 (Sy);",
    "carry = 0;",
    "overflow = 0;",
    "greater_equal = res & 0x80000000 ? 0 : DSR_MASK_G;",
  },

d1953 20
d1975 2
a1976 2
/* Take an opcode, expand all varying fields in it out and fill all the
   right entries in 'table' with the opcode index.  */
d1979 2
a1980 1
expand_opcode (val, i, s)
d1985 2
a1992 2
      int j = 0, m = 0;

d1995 1
a1995 3
	default:
	  fprintf (stderr, "expand_opcode: illegal char '%c'\n", s[0]);
	  exit (1);
d1998 27
a2024 28
	  /* Consume an arbitrary number of ones and zeros.  */
	  do {
	    j = (j << 1) + (s[m++] - '0');
	  } while (s[m] == '0' || s[m] == '1');
	  expand_opcode ((val << m) | j, i, s + m);
	  break;
	case 'N':	/* NN -- four-way fork */
	  for (j = 0; j < 4; j++)
	    expand_opcode ((val << 2) | j, i, s + 2);
	  break;
	case 'x':	/* xx or xy -- two-way or four-way fork */
	  for (j = 0; j < 4; j += (s[1] == 'x' ? 2 : 1))
	    expand_opcode ((val << 2) | j, i, s + 2);
	  break;
	case 'y':	/* yy or yx -- two-way or four-way fork */
	  for (j = 0; j < (s[1] == 'x' ? 4 : 2); j++)
	    expand_opcode ((val << 2) | j, i, s + 2);
	  break;
	case '?':	/* Seven-way "wildcard" fork for movxy */
	  expand_opcode ((val << 2), i, s + 2);
	  for (j = 1; j < 4; j++)
	    {
	      expand_opcode ((val << 2) | j, i, s + 2);
	      expand_opcode ((val << 2) | (j + 16), i, s + 2);
	    }
	  break;
	case 'i':	/* eg. "i8*1" */
	case '.':	/* "...." is a wildcard */
d2027 11
a2037 10
	  /* nnnn, mmmm, i#*#, .... -- 16-way fork.  */
	  for (j = 0; j < 16; j++)
	    expand_opcode ((val << 4) | j, i, s + 4);
	  break;
	case 'e':
	  /* eeee -- even numbered register:
	     8 way fork.  */
	  for (j = 0; j < 15; j += 2)
	    expand_opcode ((val << 4) | j, i, s + 4);
	  break;
d2039 4
a2042 5
	  /* A0, A1, X0, X1, Y0, Y1, M0, M1, A0G, A1G:
	     MMMM -- 10-way fork */
	  expand_opcode ((val << 4) | 5, i, s + 4);
	  for (j = 7; j < 16; j++)
	    expand_opcode ((val << 4) | j, i, s + 4);
d2045 1
a2045 2
	  /* A1G, A0G: 
	     GGGG -- two-way fork */
d2047 1
a2047 1
	    expand_opcode ((val << 4) | j, i, s + 4);
a2049 1
	  /* ssss -- 10-way fork */
d2052 1
a2052 1
	    expand_opcode ((val << 4) | j, i, s + 4);
d2055 1
a2055 1
	    expand_opcode ((val << 4) | j, i, s + 4);
a2057 4
	  /* XX/XY -- 2/4 way fork.  */
	  for (j = 0; j < 4; j += (s[1] == 'X' ? 2 : 1))
	    expand_opcode ((val << 2) | j, i, s + 2);
	  break;
d2059 3
a2061 3
	  /* aa/ax -- 2/4 way fork.  */
	  for (j = 0; j < 4; j += (s[1] == 'a' ? 2 : 1))
	    expand_opcode ((val << 2) | j, i, s + 2);
a2063 4
	  /* YY/YX -- 2/4 way fork.  */
	  for (j = 0; j < (s[1] == 'Y' ? 2 : 4); j += 1)
	    expand_opcode ((val << 2) | j, i, s + 2);
	  break;
d2065 3
a2067 3
	  /* AA/AY: 2/4 way fork.  */
	  for (j = 0; j < (s[1] == 'A' ? 2 : 4); j += 1)
	    expand_opcode ((val << 2) | j, i, s + 2);
d2069 3
a2071 10
	case 'v':
	  /* vv(VV) -- 4(16) way fork.  */
	  /* Vector register fv0/4/8/12.  */
	  if (s[2] == 'V')
	    {
	      /* 2 vector registers.  */
	      for (j = 0; j < 15; j++)
		expand_opcode ((val << 4) | j, i, s + 4);
	    }
	  else
d2073 1
a2073 3
	      /* 1 vector register.  */
	      for (j = 0; j < 4; j += 1)
		expand_opcode ((val << 2) | j, i, s + 2);
a2074 1
	  break;
d2130 1
a2130 1
      expand_opcode (0, p->index, p->code);
d2139 1
a2139 1
expand_ppi_movxy ()
a2173 12
	    case '?':
	      /* Wildcard expansion, nothing to do here.  */
	      s += 2;
	      break;
	    case 'v':
	      printf ("      int v1 = ((iword >> 10) & 3) * 4;\n");
	      s += 2;
	      break;
	    case 'V':
	      printf ("      int v2 = ((iword >> 8)  & 3) * 4;\n");
	      s += 2;
	      break;
d2182 1
a2182 2
	    case 'e':
	      printf ("      int n = (iword >> 8) & 0xf;\n");
d2191 1
a2191 8
	      if (s[1] == 'y')	/* xy */
		{
		  printf ("      int n = (iword & 3) ? \n");
		  printf ("              ((iword >> 9) & 1) + 4 : \n");
		  printf ("              REG_xy ((iword >> 8) & 3);\n");
		}
	      else
		printf ("      int n = ((iword >> 9) & 1) + 4;\n");
d2196 1
a2196 8
	      if (s[1] == 'x')	/* yx */
		{
		  printf ("      int n = (iword & 0xc) ? \n");
		  printf ("              ((iword >> 8) & 1) + 6 : \n");
		  printf ("              REG_yx ((iword >> 8) & 3);\n");
		}
	      else
		printf ("      int n = ((iword >> 8) & 1) + 6;\n");
d2205 1
a2205 1
	      printf ("      int m = (iword >> 4) & 0xf;\n");
d2209 1
a2209 8
	      if (s[1] == 'Y')	/* XY */
		{
		  printf ("      int m = (iword & 3) ? \n");
		  printf ("              ((iword >> 7) & 1) + 8 : \n");
		  printf ("              DSP_xy ((iword >> 6) & 3);\n");
		}
	      else
		printf ("      int m = ((iword >> 7) & 1) + 8;\n");
d2213 1
a2213 8
	      if (s[1] == 'x')	/* ax */
		{
		  printf ("      int m = (iword & 3) ? \n");
		  printf ("              7 - ((iword >> 6) & 2) : \n");
		  printf ("              DSP_ax ((iword >> 6) & 3);\n");
		}
	      else
		printf ("      int m = 7 - ((iword >> 6) & 2);\n");
d2217 1
a2217 8
	      if (s[1] == 'X')	/* YX */
		{
		  printf ("      int m = (iword & 0xc) ? \n");
		  printf ("              ((iword >> 6) & 1) + 10 : \n");
		  printf ("              DSP_yx ((iword >> 6) & 3);\n");
		}
	      else
		printf ("      int m = ((iword >> 6) & 1) + 10;\n");
d2221 1
a2221 8
	      if (s[1] == 'Y')	/* AY */
		{
		  printf ("      int m = (iword & 0xc) ? \n");
		  printf ("              7 - ((iword >> 5) & 2) : \n");
		  printf ("              DSP_ay ((iword >> 6) & 3);\n");
		}
	      else
		printf ("      int m = 7 - ((iword >> 5) & 2);\n");
d2249 1
a2249 1
		  printf (" << 1");
d2252 1
a2252 1
		  printf (" << 2");
d2261 1
a2261 1
	  printf ("      i = (i ^ (1 << %d)) - (1 << %d);\n",
d2266 1
a2266 1
	printf ("      TB (m,n);\n");  
d2268 1
a2268 1
	printf ("      TL (m);\n");
d2270 1
a2270 1
	printf ("      TL (n);\n");
d2277 5
a2281 5
	    if (*r == '0') printf ("      CREF (0);\n"); 
	    if (*r == '8') printf ("      CREF (8);\n"); 
	    if (*r == '9') printf ("      CREF (9);\n"); 
	    if (*r == 'n') printf ("      CREF (n);\n"); 
	    if (*r == 'm') printf ("      CREF (m);\n"); 
d2300 3
a2302 3
	    if (*r == '0') printf("      CDEF (0);\n"); 
	    if (*r == 'n') printf("      CDEF (n);\n"); 
	    if (*r == 'm') printf("      CDEF (m);\n"); 
a2314 12
  printf ("/* REG_xy = [r4, r5, r0, r1].  */\n");
  printf ("#define REG_xy(R) ((R)==0 ? 4 : (R)==2 ? 5 : (R)==1 ?  0 :  1)\n");
  printf ("/* REG_yx = [r6, r7, r2, r3].  */\n");
  printf ("#define REG_yx(R) ((R)==0 ? 6 : (R)==1 ? 7 : (R)==2 ?  2 :  3)\n");
  printf ("/* DSP_ax = [a0, a1, x0, x1].  */\n");
  printf ("#define DSP_ax(R) ((R)==0 ? 7 : (R)==2 ? 5 : (R)==1 ?  8 :  9)\n");
  printf ("/* DSP_ay = [a0, a1, y0, y1].  */\n");
  printf ("#define DSP_ay(R) ((R)==0 ? 7 : (R)==1 ? 5 : (R)==2 ? 10 : 11)\n");
  printf ("/* DSP_xy = [x0, x1, y0, y1].  */\n");
  printf ("#define DSP_xy(R) ((R)==0 ? 8 : (R)==2 ? 9 : (R)==1 ? 10 : 11)\n");
  printf ("/* DSP_yx = [y0, y1, x0, x1].  */\n");
  printf ("#define DSP_yx(R) ((R)==0 ? 10 : (R)==1 ? 11 : (R)==2 ? 8 : 9)\n");
d2338 6
a2343 10
	if (isupper (*s)) 
	  *s = tolower (*s);
	if (isalpha (*s))
	  printf ("%c", *s);
	if (*s == ' ')
	  printf ("_");
	if (*s == '@@')
	  printf ("ind_");
	if (*s == ',')
	  printf ("_");
d2346 1
a2346 1
      printf (" %d\n",p->index);
d2353 1
a2353 2
   right entries in 'table' with the opcode index.
   NOTE: tail recursion optimization removed for simplicity.  */
d2363 1
a2363 1
  switch (s[0])
d2365 38
a2402 32
    default:
      fprintf (stderr, "gencode/expand_ppi_code: Illegal char '%c'\n", s[0]);
      exit (2);
      break;
    case 'g':
    case 'z':
      /* The last four bits are disregarded for the switch table.  */
      table[val] = i;
      return;
    case 'm':
      /* Four-bit expansion.  */
      for (j = 0; j < 16; j++)
	expand_ppi_code ((val << 4) + j, i, s + 4);
      break;
    case '.':
    case '0':
      expand_ppi_code ((val << 1), i, s + 1);
      break;
    case '1':
      expand_ppi_code ((val << 1) + 1, i, s + 1);
      break;
    case 'i':
    case 'e': case 'f':
    case 'x': case 'y':
      expand_ppi_code ((val << 1), i, s + 1);
      expand_ppi_code ((val << 1) + 1, i, s + 1);
      break;
    case 'c':
      expand_ppi_code ((val << 2) + 1, ppi_index++, s + 2);
      expand_ppi_code ((val << 2) + 2, i, s + 2);
      expand_ppi_code ((val << 2) + 3, i, s + 2);
      break;
a2453 1
  printf ("  /* 'ee' = [x0, x1, y0, a1] */\n");
a2454 1
  printf ("  /* 'ff' = [y0, y1, x0, a1] */\n");
a2455 1
  printf ("  /* 'xx' = [x0, x1, a0, a1]  */\n");
a2456 1
  printf ("  /* 'yy' = [y0, y1, m0, m1]  */\n");
a2457 1
  printf ("  /* 'gg' = [m0, m1, a0, a1]  */\n");
a2458 1
  printf ("  /* 'uu' = [x0, y0, a0, a1]  */\n");
d2465 1
a2465 1
  printf ("  switch (ppi_table[iword >> 4]) {\n");
d2621 1
a2621 1
	  expand_ppi_movxy ();
d2626 1
a2626 1
	  dumptable ("ppi_table", 1 << 12, 0);
@


1.3.24.4
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d7 1
a7 1
   This file is part of SH sim.
d23 1
a23 1
   the simulator code.
d75 1
a75 1
  { "0", "0", "and #<imm>,R0", "11001001i8*1....",
d204 2
a205 2
  { "n", "nm", "div1 <REG_M>,<REG_N>", "0011nnnnmmmm0100",
    "div1 (&R0, m, n/*, T*/);",
d290 1
a290 1
    "/* FIXME: check for DP and (n & 1) == 0?  */",
d312 1
a312 1
    "/* FIXME: check for DP and (n & 1) == 0?  */",
d318 1
a318 1
    "/* FIXME: check for DP and (n & 1) == 0?  */",
d446 1
a446 2
  /* sh4: 
     See fmov instructions above for move to/from extended fp registers.  */
d493 1
a493 1
  { "", "", "fsrra <FREG_N>", "1111nnnn01111101",
d665 1
a665 1
    "macl (&R0, memory, n, m);",
d669 1
a669 1
    "macw (&R0, memory, n, m, endianw);",
d843 1
a843 1
  { "", "n0", "movco.l R0, @@<REG_N>", "0000nnnn01110011", 
d1104 1
a1104 1
    "nip += trap (0xc3, &R0, PC, memory, maskl, maskw, endianw);",
d1195 1
a1195 1
    "  nip += trap (i, &R0, PC, memory, maskl, maskw, endianw);",
d1245 1
a1245 1
    "divl (0, R[n], R[m]);",
d1248 1
a1248 1
    "divl (0, R[n], R[m]);",
d2265 2
d2398 1
a2398 1
   statement entry.  */
d2646 1
a2646 1
	/* Do the refs.  */
d2669 1
a2669 1
	/* Do the defs.  */
d2978 1
a2978 1
  /* Verify the table before anything else.  */
d2983 1
a2983 1
	/* Check that the code field contains 16 bits.  */
d2993 1
a2993 1
  /* Now generate the requested data.  */
@


1.3.22.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@d580 1
a580 1
    "trap (255, R0, PC, memory, maskl, maskw, endianw);",
d954 2
a955 1
    "nip += trap (0xc3, R0, PC, memory, maskl, maskw, endianw);",
d1032 2
d1035 4
a1038 3
    "if (i < 20 || i == 33 || i == 34 || i == 0xc3)",
    "  nip += trap (i, R, PC, memory, maskl, maskw,endianw);",
#if 0
a1039 1
    /* SH-[12] */
d1041 1
a1041 1
    "  WLAT (R[15], GET_SR());",
d1043 3
a1045 1
    "  WLAT (R[15], PH2T (PC + 2));",
d1047 7
d1055 1
d1060 2
a1062 2
    "  SET_NIP (PT2H (RLAT (VBR + (imm<<2))));",
    "}",
@


1.3.22.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d229 1
a229 1
  /* sh2e */
d235 1
a235 1
  /* sh2e */
d240 1
a240 1
  /* sh2e */
d244 1
a244 1
  /* sh2e */
d281 1
a281 1
  /* sh2e */
d294 1
a294 1
  /* sh2e */
d300 1
a300 1
  /* sh2e */
d306 1
a306 1
  /* sh2e */
d317 1
a317 1
  /* sh2e */
d328 1
a328 1
  /* sh2e */
d334 1
a334 1
  /* sh2e */
d348 1
a348 1
  /* sh2e */
d361 1
a361 1
  /* sh2e */
d374 1
a374 1
  /* sh2e */
d389 1
a389 1
  /* sh2e */
d404 1
a404 1
  /* sh2e */
d417 1
a417 1
  /* sh2e */
d433 1
a433 1
  /* sh2e */
d438 1
a438 1
  /* sh2e */
d458 1
a458 1
  /* sh2e */
d463 1
a463 1
  /* sh2e */
d479 1
a479 1
  /* sh2e */
d564 1
a564 1
  /* sh2e / sh-dsp (lds <REG_N>,DSR) */
d568 1
a568 1
  /* sh2e / sh-dsp (lds.l @@<REG_N>+,DSR) */
@


1.3.22.3
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d198 1
a198 1
  { "", "nm", "div1 <REG_M>,<REG_N>", "0011nnnnmmmm0100", /* ? MVS */
d349 1
a349 1
  { "", "n", "fmov.s <FREG_M>,@@<REG_N>", "1111nnnnmmmm1010",
d362 1
a362 1
  { "", "m", "fmov.s @@<REG_M>,<FREG_N>", "1111nnnnmmmm1000",
d375 1
a375 1
  { "m", "m", "fmov.s @@<REG_M>+,<FREG_N>", "1111nnnnmmmm1001",
d390 1
a390 1
  { "n", "n", "fmov.s <FREG_M>,@@-<REG_N>", "1111nnnnmmmm1011",
d405 1
a405 1
  { "", "0m", "fmov.s @@(R0,<REG_M>),<FREG_N>", "1111nnnnmmmm0110",
d418 1
a418 1
  { "", "0n", "fmov.s <FREG_M>,@@(R0,<REG_N>)", "1111nnnnmmmm0111",
d445 1
a445 4
    "if (FPSCR_PR)",
    "  RAISE_EXCEPTION (SIGILL);",
    "else",
    "  SET_FPSCR (GET_FPSCR() ^ FPSCR_MASK_FR);",
d522 1
a522 1
  { "n", "n", "ldc.l @@<REG_N>+,<CREG_M>", "0100nnnnmmmm0111",
d528 1
a528 1
  { "n", "n", "ldc.l @@<REG_N>+,SR", "0100nnnn00000111",
d534 1
a534 1
  { "n", "n", "ldc.l @@<REG_N>+,MOD", "0100nnnn01010111",
d540 1
a540 1
  { "n", "n", "ldc.l @@<REG_N>+,DBR", "0100nnnn11110110",
d559 1
a559 1
  { "n", "n", "lds.l @@<REG_N>+,<SREG_M>", "0100nnnnssss0110",
d569 1
a569 1
  { "n", "n", "lds.l @@<REG_N>+,FPSCR", "0100nnnn01100110",
d576 1
a576 1
    "/* We don't implement cache or tlb, so this is a noop.  */",
d579 1
a579 1
  { "nm", "nm", "mac.l @@<REG_M>+,@@<REG_N>+", "0000nnnnmmmm1111",
d584 1
a584 1
  { "nm", "nm", "mac.w @@<REG_M>+,@@<REG_N>+", "0100nnnnmmmm1111",
d610 1
a610 1
  { "nm", "m", "mov.b @@<REG_M>+,<REG_N>", "0110nnnnmmmm0100",
d632 1
a632 1
  { "n", "nm", "mov.b <REG_M>,@@-<REG_N>", "0010nnnnmmmm0100",
d686 1
a686 1
  { "n", "nm", "mov.l <REG_M>,@@-<REG_N>", "0010nnnnmmmm0110",
d697 2
a698 2
    "MA (1);",
    "R0 = RSWAT (i + GBR);",
d753 3
a755 4
  { "", "n0", "movca.l R0, @@<REG_N>", "0000nnnn11000011",
    "/* We don't simulate cache, so this insn is identical to mov.  */",
    "MA (1);",
    "WLAT (R[n], R[0]);",
d801 3
a803 3
  { "", "n", "ocbi @@<REG_N>", "0000nnnn10010011",
    "RSBAT (R[n]); /* Take exceptions like byte load, otherwise noop.  */",
    "/* FIXME: Cache not implemented */",
d806 3
a808 3
  { "", "n", "ocbp @@<REG_N>", "0000nnnn10100011",
    "RSBAT (R[n]); /* Take exceptions like byte load, otherwise noop.  */",
    "/* FIXME: Cache not implemented */",
d812 1
a812 1
    "RSBAT (R[n]); /* Take exceptions like byte load, otherwise noop.  */",
d883 1
a883 1
  { "", "", "setrc #<imm>", "10000010i8*1....",
d1140 1
a1140 1
  { "n", "n", "movs.w <DSP_REG_M>,@@-<REG_N>", "111101NNMMMM0001",
d1201 1
a1201 1
  { "n", "n", "movs.l <DSP_REG_M>,@@-<REG_N>", "111101NNMMMM0011",
d1220 1
a1220 1
  { "n", "n", "movs.l <DSP_GRD_M>,@@-<REG_N>", "111101NNGGGG0011",
d1248 1
a1248 1
  { "n", "n8","movx.w @@<REG_x>+REG_8,<DSP_XX>", "111100xxXX001100",
d1262 1
a1262 1
  { "n", "n8","movx.w <DSP_Aa>,@@<REG_x>+REG_8","111100xxaa101100",
d1270 1
a1270 1
  { "n", "n", "movy.w @@<REG_y>+,<DSP_YY>", "111100yyYY000010",
d1274 1
a1274 1
  { "n", "n9","movy.w @@<REG_y>+REG_9,<DSP_YY>", "111100yyYY000011",
d1278 1
a1278 1
  { "", "n", "movy.w <DSP_Aa>,@@<REG_y>",   "111100yyAA010001",
d1281 1
a1281 1
  { "n", "n", "movy.w <DSP_Aa>,@@<REG_y>+", "111100yyAA010010",
d1285 1
a1285 1
  { "n", "n9", "movy.w <DSP_Aa>,@@<REG_y>+REG_9", "111100yyAA010011",
d1305 1
a1305 1
    "if (i <= 16)",
d1308 1
a1308 1
    "  res = (unsigned) Sz >> 128 - i;	/* no sign extension */",
d1322 1
a1322 1
    "if (i <= 32)",
d1361 1
a1361 1
    "res = (DSP_R (e) >> 16) * (DSP_R (f) >> 16) * 2;",
d1374 1
a1374 1
    "res = (DSP_R (e) >> 16) * (DSP_R (f) >> 16) * 2;",
d1393 1
a1393 1
    "res = (DSP_R (e) >> 16) * (DSP_R (f) >> 16) * 2;",
d1481 1
a1481 1
    "res = (Sx + 0x8000) & 0xffff0000;",
d1514 1
a1514 1
    "res = (Sy + 0x8000) & 0xffff0000;",
d1524 1
a1524 1
    "if (Sy <= 16)",
d1527 1
a1527 1
    "  res = (unsigned) Sx >> 128 - Sy;	/* no sign extension */",
d1540 1
a1540 1
    "if (Sy <= 32)",
d2105 1
a2105 1
/* Table already contains all the switch case tags for 16-bit opcode double
a2139 5
	    default:
	      fprintf (stderr, "gencode/gensim_caselist: illegal char '%c'\n",
		       *s);
	      exit (1);
	      break;
d2162 1
a2162 1
	      printf ("      int n = ((iword >> 8) & 1) + 6;\n");
a2332 5
	default:
	  fprintf (stderr, "gencode/expand_ppi_code: Illegal char '%c'\n",
		   s[0]);
	  exit (2);
	  break;
d2462 1
a2462 1
	      printf ("\treturn;\n");
@


1.3.22.4
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d583 2
a584 1
    "macl(&R0,memory,n,m);",
d588 1
a588 1
    "macw(&R0,memory,n,m,endianw);",
d2327 1
a2327 1
/* Take a ppi code, expand all varying fields in it and fill all the
@


1.3.22.5
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a451 11
  { "", "", "fsca", "1111nnn011111101",
    "if (FPSCR_PR)",
    "  RAISE_EXCEPTION (SIGILL);",
    "else",
    "  {",
    "    SET_FR (n, fsca_s (FPUL, &sin));",
    "    SET_FR (n+1, fsca_s (FPUL, &cos));",
    "  }",
  },

  /* sh4 */
a460 8
  /* sh4 */
  { "", "", "fsrra", "1111nnnn01111101",
    "if (FPSCR_PR)",
    "  RAISE_EXCEPTION (SIGILL);",
    "else",
    "  SET_FR (n, fsrra_s (FR (n)));",
  },

a1981 2
	    if (s[1] - '0' > 1U || !s[2] || ! s[3])
	      expand_opcode (shift - 1, val + s[0] - '0', i, s + 1);
d2006 6
a2011 11
	  {
	    int digits = 1;
	    while (s[digits] == s[0])
	      digits++;
	    for (j = 0; j < (1 << digits); j++)
	      {
		expand_opcode (shift - digits, val | (j << shift), i,
			       s + digits);
	      }
	    break;
	  }
@


1.3.22.6
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d1 1
a1 2
/* Simulator/Opcode generator for the Renesas
   (formerly Hitachi) / SuperH Inc. Super-H architecture.
d51 1
a51 1
    "R[n] += SEXT (i);",
d87 1
a87 1
    "  SET_NIP (PC + 4 + (SEXT (i) * 2));",
a153 5
  /* sh4a */
  { "", "", "clrdmxy", "0000000010001000",
    "saved_state.asregs.cregs.named.sr &= ~(SR_MASK_DMX | SR_MASK_DMY);"
  },

d198 1
a198 1
  { "", "nm", "div1 <REG_M>,<REG_N>", "0011nnnnmmmm0100",
d232 1
a232 1
    "/* FIXME: FR (n) &= 0x7fffffff; */",
d260 1
a260 1
    "  u.f = DR (n);",
d277 1
a277 1
    "  SET_DR (n, u.f);",
d288 4
a291 13
  { "", "", "fipr <FV_M>,<FV_N>", "1111vvVV11101101",
    "if (FPSCR_PR)", 
    "  RAISE_EXCEPTION (SIGILL);",
    "else",
    "{",
    "  double fsum = 0;",
    "  /* FIXME: check for nans and infinities.  */",
    "  fsum += FR (v1+0) * FR (v2+0);",
    "  fsum += FR (v1+1) * FR (v2+1);",
    "  fsum += FR (v1+2) * FR (v2+2);",
    "  fsum += FR (v1+3) * FR (v2+3);",
    "  SET_FR (v1+3, fsum);",
    "}",
d296 1
a296 1
    "SET_FR (n, (float) 0.0);",
d302 1
a302 1
    "SET_FR (n, (float) 1.0);",
d313 1
a313 1
    "  u.f = FR (n);",
d321 1
a321 1
    "  SET_DR (n, (double) FPUL);",
d324 1
a324 1
    "  SET_FR (n, (float) FPUL);",
d330 1
a330 1
    "SET_FR (n, FR (m) * FR (0) + FR (n));",
d358 1
a358 1
    "  WLAT (R[n], FI (m));",
d371 1
a371 1
    "  SET_FI (n, RLAT (R[m]));",
d401 1
a401 1
    "  WLAT (R[n], FI (m));",
d414 1
a414 1
    "  SET_FI (n, RLAT (R[0] + R[m]));",
d427 1
a427 1
    "  WLAT ((R[0]+R[n]), FI (m));",
d435 1
a435 1
    "FP_OP (n, *, m);",
d440 1
a440 6
    "FP_UNARY (n, -);",
  },

  /* sh4a */
  { "", "", "fpchg", "1111011111111101",
    "SET_FPSCR (GET_FPSCR () ^ FPSCR_MASK_PR);",
d448 1
a448 1
    "  SET_FPSCR (GET_FPSCR () ^ FPSCR_MASK_FR);",
d452 1
a452 1
  { "", "", "fsca", "1111eeee11111101",
d464 1
a464 1
    "SET_FPSCR (GET_FPSCR () ^ FPSCR_MASK_SZ);",
d469 1
a469 1
    "FP_UNARY (n, sqrt);",
d482 1
a482 1
    "FP_OP (n, -, m);",
d489 1
a489 1
    "  if (DR (n) != DR (n)) /* NaN */",
d492 1
a492 1
    "    FPUL =  (int) DR (n);",
d495 1
a495 1
    "if (FR (n) != FR (n)) /* NaN */",
d498 1
a498 12
    "  FPUL = (int) FR (n);",
  },

  /* sh4 */
  { "", "", "ftrv <FV_N>", "1111vv0111111101",
    "if (FPSCR_PR)",
    "  RAISE_EXCEPTION (SIGILL);",
    "else",
    "{", 
    "  /* FIXME not implemented.  */",
    "  printf (\"ftrv xmtrx, FV%d\\n\", v1);",
    "}", 
d538 1
d540 2
a541 10
    "if (SR_MD)",
    "  DBR = R[n]; /* priv mode */",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
  },
  { "", "n", "ldc <REG_N>,SGR", "0100nnnn00111010",
    "if (SR_MD)",
    "  SGR = R[n]; /* priv mode */",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
d543 1
d561 1
d563 4
a566 18
    "if (SR_MD)",
    "{ /* priv mode */",
    "  MA (1);",
    "  DBR = RLAT (R[n]);",
    "  R[n] += 4;",
    "}",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
  },
  { "n", "n", "ldc.l @@<REG_N>+,SGR", "0100nnnn00110110",
    "if (SR_MD)",
    "{ /* priv mode */",
    "  MA (1);",
    "  SGR = RLAT (R[n]);",
    "  R[n] += 4;",
    "}",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
d568 1
a577 14
  /* sh4a */
  { "", "n", "ldrc <REG_N>", "0100nnnn00110100",
    "SET_RC (R[n]);",
    "loop = get_loop_bounds_ext (RS, RE, memory, mem_end, maskw, endianw);",
    "CHECK_INSN_PTR (insn_ptr);",
    "RE |= 1;",
  },
  { "", "", "ldrc #<imm>", "10001010i8*1....",
    "SET_RC (i);",
    "loop = get_loop_bounds_ext (RS, RE, memory, mem_end, maskw, endianw);",
    "CHECK_INSN_PTR (insn_ptr);",
    "RE |= 1;",
  },

d583 1
a583 1
    "SREG (m) = RLAT (R[n]);",
d588 1
a588 1
    "SET_FPSCR (R[n]);",
d593 1
a593 1
    "SET_FPSCR (RLAT (R[n]));",
d602 1
a602 1
    "macl (&R0,memory,n,m);",
d606 1
a606 1
    "macw (&R0,memory,n,m,endianw);",
d610 1
a610 1
    "R[n] = SEXT (i);",
a779 19
  { "n", "0", "movco.l R0, @@<REG_N>", "0000nnnn01110011", 
    "/* LDST -> T */",
    "SET_SR_T (LDST);",
    "/* if (T) R0 -> (Rn) */",
    "if (T)",
    "  WLAT (R[n], R[0]);",
    "/* 0 -> LDST */",
    "SET_LDST (0);",
  },

  { "0", "n", "movli.l @@<REG_N>, R0", "0000nnnn01100011", 
    "/* 1 -> LDST */",
    "SET_LDST (1);",
    "/* (Rn) -> R0 */",
    "R[0] = RLAT (R[n]);",
    "/* if (interrupt/exception) 0 -> LDST */",
    "/* (we don't simulate asynchronous interrupts/exceptions) */",
  },

a783 15
  { "0", "n", "movua.l @@<REG_N>,R0", "0100nnnn10101001",
    "int regn = R[n];",
    "MA (1);",
    "R[0] = (RBAT (regn) << 24) + (RBAT (regn + 1) << 16) + ",
    "  (RBAT (regn + 2) << 8) + RBAT (regn + 3);",
    "L (n);",
  },
  { "0n", "n", "movua.l @@<REG_N>+,R0", "0100nnnn11101001",
    "int regn = R[n];",
    "MA (1);",
    "R[0] = (RBAT (regn) << 24) + (RBAT (regn + 1) << 16) + ",
    "  (RBAT (regn + 2) << 8) + RBAT (regn + 3);",
    "R[n] += 4;",
    "L (n);",
  },
d785 1
a785 1
    "MACL = ((int) R[n]) * ((int) R[m]);",
d787 1
a787 2
#if 0  /* FIXME: The above cast to int is not really portable.
	  It should be replaced by a SEXT32 macro.  */
d795 1
a795 1
    "MACL = ((int) (short) R[n]) * ((int) (short) R[m]);",
d800 2
a801 2
    "MACL = (((unsigned int) (unsigned short) R[n])",
    "        * ((unsigned int) (unsigned short) R[m]));",
a822 6
  /* sh4a */
  { "", "n", "icbi @@<REG_N>", "0000nnnn11100011",
    "/* Except for the effect on the cache - which is not simulated -",
    "   this is like a nop.  */",
  },

a853 12
  /* sh4a */
  { "", "n", "prefi @@<REG_N>", "0000nnnn11010011",
    "/* Except for the effect on the cache - which is not simulated -",
    "   this is like a nop.  */",
  },

  /* sh4a */
  { "", "", "synco", "0000000010101011", 
    "/* Except for the effect on the pipeline - which is not simulated -", 
    "   this is like a nop.  */",
  },

a900 12
  /* sh4a */
  { "", "", "setdmx", "0000000010011000",
    "saved_state.asregs.cregs.named.sr |=  SR_MASK_DMX;"
    "saved_state.asregs.cregs.named.sr &= ~SR_MASK_DMY;"
  },

  /* sh4a */
  { "", "", "setdmy", "0000000011001000",
    "saved_state.asregs.cregs.named.sr |=  SR_MASK_DMY;"
    "saved_state.asregs.cregs.named.sr &= ~SR_MASK_DMX;"
  },

d983 1
d985 1
a985 4
    "if (SR_MD)",
    "  R[n] = SGR; /* priv mode */",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
d988 1
a988 4
    "if (SR_MD)",
    "  R[n] = DBR; /* priv mode */",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
d990 1
d996 1
d998 3
a1000 8
    "if (SR_MD)",
    "{ /* priv mode */",
    "  MA (1);",
    "  R[n] -= 4;",
    "  WLAT (R[n], SGR);",
    "}",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
d1003 3
a1005 8
    "if (SR_MD)",
    "{ /* priv mode */",
    "  MA (1);",
    "  R[n] -= 4;",
    "  WLAT (R[n], DBR);",
    "}",
    "else",
    "  RAISE_EXCEPTION (SIGILL); /* user mode */",
d1007 1
d1047 1
a1047 1
    "ult = RBAT (R[n]);",
d1049 1
a1049 1
    "WBAT (R[n],ult|0x80);",
d1059 3
a1061 3
    "  R[15] -= 4;",
    "  WLAT (R[15], GET_SR ());",
    "  R[15] -= 4;",
d1065 1
a1065 1
    "  SSR = GET_SR ();",
d1067 1
a1067 1
    "  SET_SR (GET_SR () | SR_MASK_MD | SR_MASK_BL | SR_MASK_RB);",
d1105 1
a1105 1
    "divl (0,R[n],R[m]);",
d1108 1
a1108 1
    "divl (0,R[n],R[m]);",
d1261 1
a1261 1
  { "", "n", "movx.w @@<REG_xy>,<DSP_XY>",   "111100xyXY0001??",
d1263 1
a1263 7
    "if (iword & 3)",
    "  {",
    "    iword &= 0xfd53; goto top;",
    "  }",
  },
  { "", "n", "movx.l @@<REG_xy>,<DSP_XY>",   "111100xyXY010100",
    "DSP_R (m) = RLAT (R[n]);",
d1265 1
a1265 1
  { "n", "n", "movx.w @@<REG_xy>+,<DSP_XY>", "111100xyXY0010??",
d1268 1
a1268 8
    "if (iword & 3)",
    "  {",
    "    iword &= 0xfd53; goto top;",
    "  }",
  },
  { "n", "n", "movx.l @@<REG_xy>+,<DSP_XY>", "111100xyXY011000",
    "DSP_R (m) = RLAT (R[n]);",
    "R[n] += ((R[n] & 0xffff) == MOD_ME) ? MOD_DELTA : 4;",
d1270 1
a1270 1
  { "n", "n8","movx.w @@<REG_xy>+REG_8,<DSP_XY>", "111100xyXY0011??",
d1273 1
a1273 8
    "if (iword & 3)",
    "  {",
    "    iword &= 0xfd53; goto top;",
    "  }",
  },
  { "n", "n8","movx.l @@<REG_xy>+REG_8,<DSP_XY>", "111100xyXY011100",
    "DSP_R (m) = RLAT (R[n]);",
    "R[n] += ((R[n] & 0xffff) == MOD_ME) ? MOD_DELTA : R[8];",
d1275 1
a1275 1
  { "", "n", "movx.w <DSP_Ax>,@@<REG_xy>",   "111100xyax1001??",
d1277 1
a1277 7
    "if (iword & 3)",
    "  {",
    "    iword &= 0xfd53; goto top;",
    "  }",
  },
  { "", "n", "movx.l <DSP_Ax>,@@<REG_xy>",   "111100xyax110100",
    "WLAT (R[n], DSP_R (m));",
d1279 1
a1279 1
  { "n", "n", "movx.w <DSP_Ax>,@@<REG_xy>+", "111100xyax1010??",
d1282 1
a1282 8
    "if (iword & 3)",
    "  {",
    "    iword &= 0xfd53; goto top;",
    "  }",
  },
  { "n", "n", "movx.l <DSP_Ax>,@@<REG_xy>+", "111100xyax111000",
    "WLAT (R[n], DSP_R (m));",
    "R[n] += ((R[n] & 0xffff) == MOD_ME) ? MOD_DELTA : 4;",
d1284 1
a1284 1
  { "n", "n8","movx.w <DSP_Ax>,@@<REG_xy>+REG_8","111100xyax1011??",
d1287 1
a1287 8
    "if (iword & 3)",
    "  {",
    "    iword &= 0xfd53; goto top;",
    "  }",
  },
  { "n", "n8","movx.l <DSP_Ax>,@@<REG_xy>+REG_8","111100xyax111100",
    "WLAT (R[n], DSP_R (m));",
    "R[n] += ((R[n] & 0xffff) == MOD_ME) ? MOD_DELTA : R[8];",
d1289 1
a1289 1
  { "", "n", "movy.w @@<REG_yx>,<DSP_YX>",   "111100yxYX000001",
d1292 1
a1292 1
  { "n", "n", "movy.w @@<REG_yx>+,<DSP_YX>", "111100yxYX000010",
d1296 1
a1296 1
  { "n", "n9","movy.w @@<REG_yx>+REG_9,<DSP_YX>", "111100yxYX000011",
d1300 1
a1300 1
  { "", "n", "movy.w <DSP_Ay>,@@<REG_yx>",   "111100yxAY010001",
d1303 1
a1303 1
  { "n", "n", "movy.w <DSP_Ay>,@@<REG_yx>+", "111100yxAY010010",
d1307 1
a1307 1
  { "n", "n9", "movy.w <DSP_Ay>,@@<REG_yx>+REG_9", "111100yxAY010011",
a1310 22
  { "", "n", "movy.l @@<REG_yx>,<DSP_YX>",   "111100yxYX100001",
    "DSP_R (m) = RLAT (R[n]);",
  },
  { "n", "n", "movy.l @@<REG_yx>+,<DSP_YX>", "111100yxYX100010",
    "DSP_R (m) = RLAT (R[n]);",
    "R[n] += ((R[n] | ~0xffff) == MOD_ME) ? MOD_DELTA : 4;",
  },
  { "n", "n9","movy.l @@<REG_yx>+REG_9,<DSP_YX>", "111100yxYX100011",
    "DSP_R (m) = RLAT (R[n]);",
    "R[n] += ((R[n] | ~0xffff) == MOD_ME) ? MOD_DELTA : R[9];",
  },
  { "", "n", "movy.l <DSP_Ay>,@@<REG_yx>",   "111100yxAY110001",
    "WLAT (R[n], DSP_R (m));",
  },
  { "n", "n", "movy.l <DSP_Ay>,@@<REG_yx>+", "111100yxAY110010",
    "WLAT (R[n], DSP_R (m));",
    "R[n] += ((R[n] | ~0xffff) == MOD_ME) ? MOD_DELTA : 4;",
  },
  { "n", "n9", "movy.l <DSP_Ay>,@@<REG_yx>+REG_9", "111100yxAY110011",
    "WLAT (R[n], DSP_R (m));",
    "R[n] += ((R[n] | ~0xffff) == MOD_ME) ? MOD_DELTA : R[9];",
  },
d1465 1
a1465 1
  { "","", "pcmp Sx,Sy",	"10000100xxyyzzzz",
a1481 18
  { "","", "(if cc) pabs Sx,Dz",	"100010ccxx01zzzz",
    "/* FIXME: duplicate code pabs.  */",
    "res = DSP_R (x);",
    "res_grd = GET_DSP_GRD (x);",
    "if (res >= 0)",
    "  carry = 0;",
    "else",
    "  {",
    "    res = -res;",
    "    carry = (res != 0); /* The manual has a bug here.  */", 
    "    res_grd = -res_grd - carry;", 
    "  }",
    "COMPUTE_OVERFLOW;",
    "/* ??? The re-computing of overflow after",
    "   saturation processing is specific to pabs.  */",
    "overflow = res_grd != SIGN32 (res) ? DSR_MASK_V : 0;",
    "ADD_SUB_GE;",
  },
a1498 12

  { "","", "(if cc) prnd Sx,Dz",	"100110ccxx01zzzz",
    "/* FIXME: duplicate code prnd.  */",
    "int Sx = DSP_R (x);",
    "int Sx_grd = GET_DSP_GRD (x);",
    "",
    "res = (Sx + 0x8000) & 0xffff0000;",
    "carry = (unsigned) res < (unsigned) Sx;",
    "res_grd = Sx_grd + carry;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
  },
a1508 25

  { "","", "(if cc) pabs Sy,Dz",	"101010cc01yyzzzz",
    "/* FIXME: duplicate code pabs.  */",
    "res = DSP_R (y);",
    "res_grd = 0;",
    "overflow = 0;",
    "greater_equal = DSR_MASK_G;",
    "if (res >= 0)",
    "  carry = 0;",
    "else",
    "  {",
    "    res = -res;",
    "    carry = 1;",
    "    if (res < 0)",
    "      {",
    "        if (S)",
    "          res = 0x7fffffff;",
    "        else",
    "          {",
    "            overflow = DSR_MASK_V;",
    "            greater_equal = 0;",
    "          }",
    "      }",
    "  }",
  },
a1531 11
  { "","", "(if cc) prnd Sy,Dz",	"101110cc01yyzzzz",
    "/* FIXME: duplicate code prnd.  */",
    "int Sy = DSP_R (y);",
    "int Sy_grd = SIGN32 (Sy);",
    "",
    "res = (Sy + 0x8000) & 0xffff0000;",
    "carry = (unsigned) res < (unsigned) Sy;",
    "res_grd = Sy_grd + carry;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
  },
a1611 12
  { "","", "(if cc) psub Sy,Sx,Dz",	"100001ccxxyyzzzz",
    "int Sx = DSP_R (x);",
    "int Sx_grd = GET_DSP_GRD (x);",
    "int Sy = DSP_R (y);",
    "int Sy_grd = SIGN32 (Sy);",
    "",
    "res = Sy - Sx;",
    "carry = (unsigned) res > (unsigned) Sy;",
    "res_grd = Sy_grd - Sx_grd - carry;",
    "COMPUTE_OVERFLOW;",
    "ADD_SUB_GE;",
  },
a1700 15
  { "","", "pclr Du pmuls Se,Sf,Dg",	"0100eeff0001gguu",
    "/* Do multiply.  */",
    "res = (DSP_R (e) >> 16) * (DSP_R (f) >> 16) * 2;",
    "if (res == 0x80000000)",
    "  res = 0x7fffffff;",
    "DSP_R (g) = res;",
    "DSP_GRD (g) = SIGN32 (res);",
    "/* FIXME: update DSR based on results of multiply!  */",
    "",
    "/* Do clr.  */",
    "z = u;",
    "res = 0;",
    "res_grd = 0;",
    "goto assign_z;",
  },
a1815 21
  /* sh4a */
  { "","", "(if cc) pswap Sx,Dz",	"100111ccxx01zzzz",
    "int Sx = DSP_R (x);",
    "",
    "res = ((Sx & 0xffff) * 65536) + ((Sx >> 16) & 0xffff);",
    "res_grd = GET_DSP_GRD (x);",
    "carry = 0;",
    "overflow = 0;",
    "greater_equal = res & 0x80000000 ? 0 : DSR_MASK_G;",
  },
  /* sh4a */
  { "","", "(if cc) pswap Sy,Dz",	"101111cc01yyzzzz",
    "int Sy = DSP_R (y);",
    "",
    "res = ((Sy & 0xffff) * 65536) + ((Sy >> 16) & 0xffff);",
    "res_grd = SIGN32 (Sy);",
    "carry = 0;",
    "overflow = 0;",
    "greater_equal = res & 0x80000000 ? 0 : DSR_MASK_G;",
  },

d1953 20
d1975 2
a1976 2
/* Take an opcode, expand all varying fields in it out and fill all the
   right entries in 'table' with the opcode index.  */
d1979 2
a1980 1
expand_opcode (val, i, s)
d1985 2
a1992 2
      int j = 0, m = 0;

d1995 1
a1995 3
	default:
	  fprintf (stderr, "expand_opcode: illegal char '%c'\n", s[0]);
	  exit (1);
d1998 27
a2024 28
	  /* Consume an arbitrary number of ones and zeros.  */
	  do {
	    j = (j << 1) + (s[m++] - '0');
	  } while (s[m] == '0' || s[m] == '1');
	  expand_opcode ((val << m) | j, i, s + m);
	  break;
	case 'N':	/* NN -- four-way fork */
	  for (j = 0; j < 4; j++)
	    expand_opcode ((val << 2) | j, i, s + 2);
	  break;
	case 'x':	/* xx or xy -- two-way or four-way fork */
	  for (j = 0; j < 4; j += (s[1] == 'x' ? 2 : 1))
	    expand_opcode ((val << 2) | j, i, s + 2);
	  break;
	case 'y':	/* yy or yx -- two-way or four-way fork */
	  for (j = 0; j < (s[1] == 'x' ? 4 : 2); j++)
	    expand_opcode ((val << 2) | j, i, s + 2);
	  break;
	case '?':	/* Seven-way "wildcard" fork for movxy */
	  expand_opcode ((val << 2), i, s + 2);
	  for (j = 1; j < 4; j++)
	    {
	      expand_opcode ((val << 2) | j, i, s + 2);
	      expand_opcode ((val << 2) | (j + 16), i, s + 2);
	    }
	  break;
	case 'i':	/* eg. "i8*1" */
	case '.':	/* "...." is a wildcard */
d2027 11
a2037 10
	  /* nnnn, mmmm, i#*#, .... -- 16-way fork.  */
	  for (j = 0; j < 16; j++)
	    expand_opcode ((val << 4) | j, i, s + 4);
	  break;
	case 'e':
	  /* eeee -- even numbered register:
	     8 way fork.  */
	  for (j = 0; j < 15; j += 2)
	    expand_opcode ((val << 4) | j, i, s + 4);
	  break;
d2039 4
a2042 5
	  /* A0, A1, X0, X1, Y0, Y1, M0, M1, A0G, A1G:
	     MMMM -- 10-way fork */
	  expand_opcode ((val << 4) | 5, i, s + 4);
	  for (j = 7; j < 16; j++)
	    expand_opcode ((val << 4) | j, i, s + 4);
d2045 1
a2045 2
	  /* A1G, A0G: 
	     GGGG -- two-way fork */
d2047 1
a2047 1
	    expand_opcode ((val << 4) | j, i, s + 4);
a2049 1
	  /* ssss -- 10-way fork */
d2052 1
a2052 1
	    expand_opcode ((val << 4) | j, i, s + 4);
d2055 1
a2055 1
	    expand_opcode ((val << 4) | j, i, s + 4);
a2057 4
	  /* XX/XY -- 2/4 way fork.  */
	  for (j = 0; j < 4; j += (s[1] == 'X' ? 2 : 1))
	    expand_opcode ((val << 2) | j, i, s + 2);
	  break;
d2059 3
a2061 3
	  /* aa/ax -- 2/4 way fork.  */
	  for (j = 0; j < 4; j += (s[1] == 'a' ? 2 : 1))
	    expand_opcode ((val << 2) | j, i, s + 2);
a2063 4
	  /* YY/YX -- 2/4 way fork.  */
	  for (j = 0; j < (s[1] == 'Y' ? 2 : 4); j += 1)
	    expand_opcode ((val << 2) | j, i, s + 2);
	  break;
d2065 3
a2067 3
	  /* AA/AY: 2/4 way fork.  */
	  for (j = 0; j < (s[1] == 'A' ? 2 : 4); j += 1)
	    expand_opcode ((val << 2) | j, i, s + 2);
d2069 3
a2071 10
	case 'v':
	  /* vv(VV) -- 4(16) way fork.  */
	  /* Vector register fv0/4/8/12.  */
	  if (s[2] == 'V')
	    {
	      /* 2 vector registers.  */
	      for (j = 0; j < 15; j++)
		expand_opcode ((val << 4) | j, i, s + 4);
	    }
	  else
d2073 1
a2073 3
	      /* 1 vector register.  */
	      for (j = 0; j < 4; j += 1)
		expand_opcode ((val << 2) | j, i, s + 2);
a2074 1
	  break;
d2130 1
a2130 1
      expand_opcode (0, p->index, p->code);
d2139 1
a2139 1
expand_ppi_movxy ()
a2173 12
	    case '?':
	      /* Wildcard expansion, nothing to do here.  */
	      s += 2;
	      break;
	    case 'v':
	      printf ("      int v1 = ((iword >> 10) & 3) * 4;\n");
	      s += 2;
	      break;
	    case 'V':
	      printf ("      int v2 = ((iword >> 8)  & 3) * 4;\n");
	      s += 2;
	      break;
d2182 1
a2182 2
	    case 'e':
	      printf ("      int n = (iword >> 8) & 0xf;\n");
d2191 1
a2191 8
	      if (s[1] == 'y')	/* xy */
		{
		  printf ("      int n = (iword & 3) ? \n");
		  printf ("              ((iword >> 9) & 1) + 4 : \n");
		  printf ("              REG_xy ((iword >> 8) & 3);\n");
		}
	      else
		printf ("      int n = ((iword >> 9) & 1) + 4;\n");
d2196 1
a2196 8
	      if (s[1] == 'x')	/* yx */
		{
		  printf ("      int n = (iword & 0xc) ? \n");
		  printf ("              ((iword >> 8) & 1) + 6 : \n");
		  printf ("              REG_yx ((iword >> 8) & 3);\n");
		}
	      else
		printf ("      int n = ((iword >> 8) & 1) + 6;\n");
d2205 1
a2205 1
	      printf ("      int m = (iword >> 4) & 0xf;\n");
d2209 1
a2209 8
	      if (s[1] == 'Y')	/* XY */
		{
		  printf ("      int m = (iword & 3) ? \n");
		  printf ("              ((iword >> 7) & 1) + 8 : \n");
		  printf ("              DSP_xy ((iword >> 6) & 3);\n");
		}
	      else
		printf ("      int m = ((iword >> 7) & 1) + 8;\n");
d2213 1
a2213 8
	      if (s[1] == 'x')	/* ax */
		{
		  printf ("      int m = (iword & 3) ? \n");
		  printf ("              7 - ((iword >> 6) & 2) : \n");
		  printf ("              DSP_ax ((iword >> 6) & 3);\n");
		}
	      else
		printf ("      int m = 7 - ((iword >> 6) & 2);\n");
d2217 1
a2217 8
	      if (s[1] == 'X')	/* YX */
		{
		  printf ("      int m = (iword & 0xc) ? \n");
		  printf ("              ((iword >> 6) & 1) + 10 : \n");
		  printf ("              DSP_yx ((iword >> 6) & 3);\n");
		}
	      else
		printf ("      int m = ((iword >> 6) & 1) + 10;\n");
d2221 1
a2221 8
	      if (s[1] == 'Y')	/* AY */
		{
		  printf ("      int m = (iword & 0xc) ? \n");
		  printf ("              7 - ((iword >> 5) & 2) : \n");
		  printf ("              DSP_ay ((iword >> 6) & 3);\n");
		}
	      else
		printf ("      int m = 7 - ((iword >> 5) & 2);\n");
d2249 1
a2249 1
		  printf (" << 1");
d2252 1
a2252 1
		  printf (" << 2");
d2261 1
a2261 1
	  printf ("      i = (i ^ (1 << %d)) - (1 << %d);\n",
d2266 1
a2266 1
	printf ("      TB (m,n);\n");  
d2268 1
a2268 1
	printf ("      TL (m);\n");
d2270 1
a2270 1
	printf ("      TL (n);\n");
d2277 5
a2281 5
	    if (*r == '0') printf ("      CREF (0);\n"); 
	    if (*r == '8') printf ("      CREF (8);\n"); 
	    if (*r == '9') printf ("      CREF (9);\n"); 
	    if (*r == 'n') printf ("      CREF (n);\n"); 
	    if (*r == 'm') printf ("      CREF (m);\n"); 
d2300 3
a2302 3
	    if (*r == '0') printf("      CDEF (0);\n"); 
	    if (*r == 'n') printf("      CDEF (n);\n"); 
	    if (*r == 'm') printf("      CDEF (m);\n"); 
a2314 12
  printf ("/* REG_xy = [r4, r5, r0, r1].  */\n");
  printf ("#define REG_xy(R) ((R)==0 ? 4 : (R)==2 ? 5 : (R)==1 ?  0 :  1)\n");
  printf ("/* REG_yx = [r6, r7, r2, r3].  */\n");
  printf ("#define REG_yx(R) ((R)==0 ? 6 : (R)==1 ? 7 : (R)==2 ?  2 :  3)\n");
  printf ("/* DSP_ax = [a0, a1, x0, x1].  */\n");
  printf ("#define DSP_ax(R) ((R)==0 ? 7 : (R)==2 ? 5 : (R)==1 ?  8 :  9)\n");
  printf ("/* DSP_ay = [a0, a1, y0, y1].  */\n");
  printf ("#define DSP_ay(R) ((R)==0 ? 7 : (R)==1 ? 5 : (R)==2 ? 10 : 11)\n");
  printf ("/* DSP_xy = [x0, x1, y0, y1].  */\n");
  printf ("#define DSP_xy(R) ((R)==0 ? 8 : (R)==2 ? 9 : (R)==1 ? 10 : 11)\n");
  printf ("/* DSP_yx = [y0, y1, x0, x1].  */\n");
  printf ("#define DSP_yx(R) ((R)==0 ? 10 : (R)==1 ? 11 : (R)==2 ? 8 : 9)\n");
d2338 6
a2343 10
	if (isupper (*s)) 
	  *s = tolower (*s);
	if (isalpha (*s))
	  printf ("%c", *s);
	if (*s == ' ')
	  printf ("_");
	if (*s == '@@')
	  printf ("ind_");
	if (*s == ',')
	  printf ("_");
d2346 1
a2346 1
      printf (" %d\n",p->index);
d2353 1
a2353 2
   right entries in 'table' with the opcode index.
   NOTE: tail recursion optimization removed for simplicity.  */
d2363 1
a2363 1
  switch (s[0])
d2365 38
a2402 32
    default:
      fprintf (stderr, "gencode/expand_ppi_code: Illegal char '%c'\n", s[0]);
      exit (2);
      break;
    case 'g':
    case 'z':
      /* The last four bits are disregarded for the switch table.  */
      table[val] = i;
      return;
    case 'm':
      /* Four-bit expansion.  */
      for (j = 0; j < 16; j++)
	expand_ppi_code ((val << 4) + j, i, s + 4);
      break;
    case '.':
    case '0':
      expand_ppi_code ((val << 1), i, s + 1);
      break;
    case '1':
      expand_ppi_code ((val << 1) + 1, i, s + 1);
      break;
    case 'i':
    case 'e': case 'f':
    case 'x': case 'y':
      expand_ppi_code ((val << 1), i, s + 1);
      expand_ppi_code ((val << 1) + 1, i, s + 1);
      break;
    case 'c':
      expand_ppi_code ((val << 2) + 1, ppi_index++, s + 2);
      expand_ppi_code ((val << 2) + 2, i, s + 2);
      expand_ppi_code ((val << 2) + 3, i, s + 2);
      break;
a2453 1
  printf ("  /* 'ee' = [x0, x1, y0, a1] */\n");
a2454 1
  printf ("  /* 'ff' = [y0, y1, x0, a1] */\n");
a2455 1
  printf ("  /* 'xx' = [x0, x1, a0, a1]  */\n");
a2456 1
  printf ("  /* 'yy' = [y0, y1, m0, m1]  */\n");
a2457 1
  printf ("  /* 'gg' = [m0, m1, a0, a1]  */\n");
a2458 1
  printf ("  /* 'uu' = [x0, y0, a0, a1]  */\n");
d2465 1
a2465 1
  printf ("  switch (ppi_table[iword >> 4]) {\n");
d2621 1
a2621 1
	  expand_ppi_movxy ();
d2626 1
a2626 1
	  dumptable ("ppi_table", 1 << 12, 0);
@


1.2
log
@sh-dsp support, simulator speedup by using host byte order:

sim:
	* Makefile.in (interp.o): Depends on ppi.c .
	(ppi.c): New rule.
	* gencode.c (printonmatch, think, genopc): Deleted.
	(MAX_NR_STUFF): Now 42.
	(tab): Add SH-DSP CPU instructions.
	Amalgamate ldc / stc / lds / sts instructions with similar
	bit patterns.  Fix opcodes of stc Rm_BANK,@@-<REG_N>.
	Fix semantics of lds.l @@<REG_N>+,MACH (no sign extend).
	(movsxy_tab): New array.
	For movs, change MMMM field to GGGG, and mmmm field to MMMM.
	Added entries for movx, movy and parallel processing insns.
	(ppi_tab): New array.
	(qfunc): Stabilize sort.
	(expand_opcode): Handle [01][01]NN, [01][01]xx and [01][01]yy.
	Handle 'M', 'G' 's' 'X', 'a', 'Y' and 'A'.
	(dumptable): Now takes three arguments.  Changed all callers.
	Emit just one contigous jump table.
	(filltable): Now takes an argument.  Changed all callers.
	Make index static.
	(ppi_moves, expand_ppi_code, ppi_filltable, ppi_gensim): New functions.
	(gensim_caselist): New function, broken out of gensim.
	Handle opcode fields 'x', 'y', 's', 'M', 'G', 'X', 'a', and 'Y'.
	Handle ref '9'.
	(gensim): Handle 'N' in code field and '8' in refs field.
	Call gensim_caselist - twice.
	(ppi_index): New static variable.
	(main): Unsupport default action.
	Add dsp support for -x / -s option.  Add -p option.
	* interp.c (sh_jump_table, sh_dsp_table, ppi_table): Declare.
	(saved_state_type): Rearrange to allow amalgamated ldc / stc /
	lds / sts to work efficiently.
	(target_dsp): New static variable.
	(GBR, VBR, SSR, SPC, MACH, MACL): Reflect saved_state_type change.
	(FPUL, Rn_BANK, SET_Rn_BANK, M, Q, S, T, SR_BL, SR_RB): Likewise.
	(SR_MD, SR_RC, SET_SR_BIT, GET_SR, SET_RC, GET_FPSCR): Likewise.
	(RS, RE, MOD, MOD_ME, DSP_R): Likewise.
	(set_fpscr1): Likewise.  Use target_dsp to check for dsp.
	(MOD_MSi, SIG_BUS_FETCH): Deleted.
	(CREG, SREG, PR, SR_MASK_DMY, SR_MASK_DMX, SR_DMY): New macros.
	(SR_DMX, DSR, MOD_DELTA, GET_DSP_GRD): Likewise.
	(SET_MOD): Reflect saved_state_type change.  Set MOD_DELTA instead
	of MOD_MS, and encode SR_DMY / SR_DMX into high word of MOD_ME.
	(set_sr): Reflect saved_state_type change.  Fix SR_RB handling.
	Use SET_MOD.
	(MA, L, TL, TB): Now controlled by ACE_FAST.
	(SEXT32): Just cast to int.
	(SIGN32): Fixed to only shift by 31.
	(CHECK_INSN_PTR): SIGBUS at insn fetch now represented by insn_end 0.
	(ppi_insn): Declare.
	(ppi.c): Include.
	(init_dsp): Set target_dsp.  When it changes, switch end of
	sh_jump_table with sh_dsp_table.
	(sim_resume) Don't declare sh_jump_table0.  Use sh_jump_table instead.
	Don't Declare PR if it's #defined.
	Fix single-stepping (Was broken in Mar  6 16:59:10 patch).
	(sim_store_register, sim_read_register): Translate accesses to
	reflect saved_state_type change.

	* interp.c (set_sr): Set sr.
	(SET_RC, MOD, MOD_MS, MOD_ME, SET_MOD, MOD_MS, MOD_ME): New macros.
	(set_fpscr1): Don't bank-switch fpu registers when simulating sh-dsp.
	(DSP_R): Fix definition.
	(sim_resume): Remove outdated SET_SR use.

	* interp.c (saved_state): New members for struct member asregs:
	rs, re, insn_end, xram_start, yram_start.
	(struct loop_bounds): New struct.
	(SKIP_INSN): New macro.
	(get_loop_bounds): New function.
	(endianw): Renamed to global_endianw.
	(maskw): negated bits.
	(PC): Now insn_ptr.
	(SR_MASK_RC, SR_RC_INCREMENT, SR_RC, RAISE_EXCEPTION): New macros.
	(RS, RE, DSP_R, DSP_GRD, A1, A0, X0, X1, Y0, Y1, M0, A1G): Likewise.
	(M1, A0G, RIAT, PT2H, PH2T, SET_NIP, CHECK_INSN_PTR): Likewise.
	(SIG_BUS_FETCH): Likewise
	(raise_exception, riat_fast): New functions.
	(raise_buserror, sim_stop): Use raise_exception.
	(PROCESS_SPECIAL_ADDRESS): Use xram_start / yram_start.
	(BUSERROR, WRITE_BUSERROR, READ_BUSERROR):
	Reverse sense of mask argument.
	(FP_OP, set_dr): Use RAISE_EXCEPTION.
	(wlat_fast, wwat_fast, wbat_fast, rlat_fast, rwat_fast, rbat_fast):
	Declare.  Remove redundant masking.
	(wwat_fast, rwat_fast): Add argument endianw.  Changed callers.
	(MA): Updated for change pc -> PC.
	(Delay_Slot): Use RIAT.
	(empty): Deleted.
	(trap): Remove argument little_endian.  Add argument endianw.
	Changed all callers.  Use raise_exception.
	(macw): Add argument endainw.  Changed all callers.
	(init_dsp): New function, extended after broken out of init_pointers.
	(sim_resume): Replace pc with insn_ptr.  Replace little_endian with
	endianw.  Replace nia with nip.  Reverse sense of maskb / maskw /
	maskl.  Implement logic for zero-overhead loops.  Don't try to
	interpret garbage when getting a SIGBUS at insn fetch.
	(sim_open): Call init_dsp.
	* gencode.c (tab): Use SET_NIP instead of nia = .  Use PH2T / PT2H /
	RAISE_EXCEPTION where appropriate.
	Add extra cycles for brai, braf , bsr, bsrf, jmp, jsr.

	* interp.c (sim_store_register, sim_fetch_register):
	Do proper endianness switch.

	* interp.c (saved_state_type): New members for struct member asregs:
	xymem_select, xmem, ymem, xmem_offset, ymem_offset.
	(special_address): Delete.
	(BUSERROR): Now a two-argument predicate.
	(PROCESS_SPECIAL_ADDRESS, WRITE_BUSERROR, READ_BUSERROR): New macros.
	(wlat_little, wwat_little, wbat_any, wlat_big, wwat_big): Delete.
	(process_wlat_addr, process_wwat_addr): New functions.
	(process_wbat_addr, process_rlat_addr, process_rwat_addr): Likewise.
	(process_rbat_addr): Likewise.
	(wlat_fast, wwat_fast, wbat_fast): Use WRITE_BUSERROR.
	(rlat_little, rwat_little, rbat_any, rlat_big, rwat_big): Delete.
	(rlat_fast, rwat_fast, rbat_fast): Use READ_BUSERROR.
	(RWAT, RLAT, RBAT, WWAT, WLAT, WBAT): Delete SLOW versions.
	(do_rdat, trap): Delete SLOW code.
	(SEXT32, SIGN32): New macros.
	(swap, swap16): Now integer in - integer out.  Changed all callers.
	(strswaplen, strnswap): Delete SLOW versions.
	(init_pointers): Initialize dsp memory selection (preliminary).
	(sim_store_register, sim_fetch_register): Use swap instead of
	big / little endian read / write functions.

	* interp.c (maskl): Deleted.
	(endianw, endianb): New variables.
	(special_address): Now inline.
	(bp_holder): Put raising of buserror there, rename to:
	(raise_buserror).
	(BUSERROR): Now yields a value.  Changed all users.
	(wbat_big): Delete.
	(wlat_fast, wwat_fast, wbat_fast): New functions.
	(rlat_fast, rwat_fast, rbat_fast): Likewise.
	(RWAT, RLAT, RBAT, WWAT, WLAT, WBAT): Use new functions.
	(do_rdat, do_wdat): Likewise.  Take maskl argument instead of
	little_endian one.  Changed caller macros.
	(swap, swap16): Use w[rw]lat_big / w[rw]lat_little directly.
	(strswaplen, strnswap): New functions.
	(trap): Use them to fix up endian mismatches;
	disable SYS_execve and SYS_execv; fix double address translation for
	SYS_pipe and SYS_stat.
	(sym_write, sym_read): Add endianness translation.
	(sym_store_register, sym_fetch_register): Add maskl local variable.
	(sim_open): Set endianw and endianb.

gdb:

	* sh-tdep.c (sh_dsp_reg_names, sh3_dsp_reg_names): New arrays.
	(sh_processor_type_table): Add entries for bfd_mach_sh_dsp and
	 bfd_mach_sh3_dsp.
	(sh_show_regs): Floating point registers are called fr0-fr15.
	For sh4, display fpul, fpscr and fr0-fr15 / dr0-dr14 as appropriate.
	Handle sh-dsp and sh3-dsp.
	config/sh/tm-sh.h (REGISTER_VIRTUAL_TYPE): sh-dsp / sh3-dsp
	don't have floating point registers.
	(DSR_REGNUM, A0G_REGNUM, A0_REGNUM, A1G_REGNUM, A1_REGNUM): Define.
	(M0_REGNUM, M1_REGNUM, X0_REGNUM, X1_REGNUM, Y0_REGNUM): Likewise.
	(Y1_REGNUM, MOD_REGNUM, RS_REGNUM, RE_REGNUM, R0B_REGNUM): Likewise.
@
text
@d44 1
a44 3
}

op;
d1322 1
a1322 1
    "else"
d1337 1
a1337 1
    "    if (i == 32)"
d1353 1
a1353 1
    "    if (i == 32)"
d1365 1
a1365 1
    "else"
d1541 1
a1541 1
    "else"
d1555 1
a1555 1
    "    if (Sy == 32)"
d1571 1
a1571 1
    "    if (Sy == 32)"
d1583 1
a1583 1
    "else"
d1695 1
a1695 1
    "int i = 16;"
d1711 1
a1711 1
    "do"
d1728 1
a1728 1
    "int i;"
d1734 1
a1734 1
    "do"
@


1.1
log
@Initial revision
@
text
@d28 1
a28 1
   default 	generates the opcode tables
d34 1
a34 1
#define MAX_NR_STUFF 20
d89 1
a89 1
    "  nia = PC + 4 + (SEXT(i) * 2);",
d96 1
a96 1
    "  nia = PC + 4 + (SEXT (i) * 2);",
d103 2
a104 1
    "nia = PC + 4 + (SEXT12 (i) * 2);",
d109 2
a110 1
    "nia = PC + 4 + R[n];",
d115 3
a117 2
    "PR = PC + 4;",
    "nia = PC + 4 + (SEXT12 (i) * 2);",
d122 3
a124 2
    "PR = PC + 4;",
    "nia = PC + 4 + R[n];",
d130 1
a130 1
    "  nia = PC + 4 + (SEXT (i) * 2);",
d137 1
a137 1
    "  nia = PC + 4 + (SEXT (i) * 2);",
d251 32
d289 7
d310 7
a316 3
    "char buf[4];",
    "*(float *)buf = FR(n);",
    "FPUL = *(int *)buf;",
d321 4
d338 8
d352 6
d365 6
d378 7
d393 7
d408 6
d421 6
d433 2
d445 10
d467 8
a481 4
  { "", "", "ftst/nan <FREG_N>", "1111nnnn01111101",
    "SET_SR_T (isnan (FR(n)));",
  },
  /* sh3e */
d483 7
a489 3
    "char buf[4];",
    "*(int *)buf = FPUL;",
    "SET_FR (n, *(float *)buf);",
d493 2
a494 1
    "nia = R[n];",
d499 1
a499 2
    "PR = PC + 4;",
    "nia = R[n];",
d501 3
a503 1
    "  gotcall (PR, nia);",
d507 2
a508 2
  { "", "n", "ldc <REG_N>,GBR", "0100nnnn00011110",
    "GBR = R[n];",
d515 2
a516 3
  { "", "n", "ldc <REG_N>,VBR", "0100nnnn00101110",
    "VBR = R[n];",
    "/* FIXME: user mode */",
d518 3
a520 2
  { "", "n", "ldc <REG_N>,SSR", "0100nnnn00111110",
    "SSR = R[n];",
d523 2
a524 37
  { "", "n", "ldc <REG_N>,SPC", "0100nnnn01001110",
    "SPC = R[n];",
    "/* FIXME: user mode */",
  },
  { "", "n", "ldc <REG_N>,R0_BANK", "0100nnnn10001110",
    "SET_Rn_BANK (0, R[n]);",
    "/* FIXME: user mode */",
  },
  { "", "n", "ldc <REG_N>,R1_BANK", "0100nnnn10011110",
    "SET_Rn_BANK (1, R[n]);",
    "/* FIXME: user mode */",
  },
  { "", "n", "ldc <REG_N>,R2_BANK", "0100nnnn10101110",
    "SET_Rn_BANK (2, R[n]);",
    "/* FIXME: user mode */",
  },
  { "", "n", "ldc <REG_N>,R3_BANK", "0100nnnn10111110",
    "SET_Rn_BANK (3, R[n]);",
    "/* FIXME: user mode */",
  },
  { "", "n", "ldc <REG_N>,R4_BANK", "0100nnnn11001110",
    "SET_Rn_BANK (4, R[n]);",
    "/* FIXME: user mode */",
  },
  { "", "n", "ldc <REG_N>,R5_BANK", "0100nnnn11011110",
    "SET_Rn_BANK (5, R[n]);",
    "/* FIXME: user mode */",
  },
  { "", "n", "ldc <REG_N>,R6_BANK", "0100nnnn11101110",
    "SET_Rn_BANK (6, R[n]);",
    "/* FIXME: user mode */",
  },
  { "", "n", "ldc <REG_N>,R7_BANK", "0100nnnn11111110",
    "SET_Rn_BANK (7, R[n]);",
    "/* FIXME: user mode */",
  },
  { "", "n", "ldc.l @@<REG_N>+,GBR", "0100nnnn00010111",
d526 1
a526 1
    "GBR = RLAT (R[n]);",
d536 1
a536 1
  { "", "n", "ldc.l @@<REG_N>+,VBR", "0100nnnn00100111",
d538 1
a538 1
    "VBR = RLAT (R[n]);",
a539 1
    "/* FIXME: user mode */",
d541 2
a542 1
  { "", "n", "ldc.l @@<REG_N>+,SSR", "0100nnnn00110111",
d544 1
a544 1
    "SSR = RLAT (R[n]);",
d548 5
a552 41
  { "", "n", "ldc.l @@<REG_N>+,SPC", "0100nnnn01000111",
    "MA (1);",
    "SPC = RLAT (R[n]);",
    "R[n] += 4;",
    "/* FIXME: user mode */",
  },
  { "", "n", "ldc.l @@<REG_N>+,R0_BANK", "0100nnnn10000111",
    "MA (1);",
    "SET_Rn_BANK (0, RLAT (R[n]));",
    "R[n] += 4;",
    "/* FIXME: user mode */",
  },
  { "", "n", "ldc.l @@<REG_N>+,R1_BANK", "0100nnnn10010111",
    "MA (1);",
    "SET_Rn_BANK (1, RLAT (R[n]));",
    "R[n] += 4;",
    "/* FIXME: user mode */",
  },
  { "", "n", "ldc.l @@<REG_N>+,R2_BANK", "0100nnnn10100111",
    "MA (1);",
    "SET_Rn_BANK (2, RLAT (R[n]));",
    "R[n] += 4;",
    "/* FIXME: user mode */",
  },
  { "", "n", "ldc.l @@<REG_N>+,R3_BANK", "0100nnnn10110111",
    "MA (1);",
    "SET_Rn_BANK (3, RLAT (R[n]));",
    "R[n] += 4;",
    "/* FIXME: user mode */",
  },
  { "", "n", "ldc.l @@<REG_N>+,R4_BANK", "0100nnnn11000111",
    "MA (1);",
    "SET_Rn_BANK (4, RLAT (R[n]));",
    "R[n] += 4;",
    "/* FIXME: user mode */",
  },
  { "", "n", "ldc.l @@<REG_N>+,R5_BANK", "0100nnnn11010111",
    "MA (1);",
    "SET_Rn_BANK (5, RLAT (R[n]));",
    "R[n] += 4;",
    "/* FIXME: user mode */",
d554 2
a555 11
  { "", "n", "ldc.l @@<REG_N>+,R6_BANK", "0100nnnn11100111",
    "MA (1);",
    "SET_Rn_BANK (6, RLAT (R[n]));",
    "R[n] += 4;",
    "/* FIXME: user mode */",
  },
  { "", "n", "ldc.l @@<REG_N>+,R7_BANK", "0100nnnn11110111",
    "MA (1);",
    "SET_Rn_BANK (7, RLAT (R[n]));",
    "R[n] += 4;",
    "/* FIXME: user mode */",
d558 2
a559 3
  /* sh3e */
  { "", "", "lds <REG_N>,FPUL", "0100nnnn01011010",
    "FPUL = R[n];",
d561 1
a561 2
  /* sh3e */
  { "", "", "lds.l @@<REG_N>+,FPUL", "0100nnnn01010110",
d563 1
a563 1
    "FPUL = RLAT(R[n]);",
d566 2
a567 2
  /* sh3e */
  { "", "", "lds <REG_N>,FPSCR", "0100nnnn01101010",
d570 2
a571 2
  /* sh3e */
  { "", "", "lds.l @@<REG_N>+,FPSCR", "0100nnnn01100110",
a576 25
  { "", "n", "lds <REG_N>,MACH", "0100nnnn00001010",
    "MACH = R[n];",
  },
  { "", "n", "lds <REG_N>,MACL", "0100nnnn00011010",
    "MACL= R[n];",
  },
  { "", "n", "lds <REG_N>,PR", "0100nnnn00101010",
    "PR = R[n];",
  },
  { "", "n", "lds.l @@<REG_N>+,MACH", "0100nnnn00000110",
    "MA (1);",
    "MACH = SEXT(RLAT(R[n]));",
    "R[n]+=4;",
  },
  { "", "n", "lds.l @@<REG_N>+,MACL", "0100nnnn00010110",
    "MA (1);",
    "MACL = RLAT(R[n]);",
    "R[n]+=4;",
  },
  { "", "n", "lds.l @@<REG_N>+,PR", "0100nnnn00100110",
    "MA (1);",
    "PR = RLAT(R[n]);",
    "R[n]+=4;;",
  },

d582 1
a582 1
    "trap (255,R0,memory,maskl,maskw,little_endian);",
d587 1
a587 1
    "macw(R0,memory,n,m);",
d652 1
a652 1
    "R[n] = RLAT((PC & ~3) + 4 + i);",
d705 1
a705 1
    "R[n] = RSWAT (PC + 4 + i);",
d752 6
a757 1
    "R0 = ((i + 4 + PC) & ~0x3);",
d803 15
d862 1
a862 1
    "nia = RLAT (R[15]) + 2;",
a867 1
    "nia = SPC;",
d869 2
d876 2
a877 1
    "nia = PR;",
d881 18
d956 2
a957 2
    "trap (0xc3, R0, memory, maskl, maskw, little_endian);",
    "nia = PC;",
d960 2
a961 2
  { "n", "", "stc GBR,<REG_N>", "0000nnnn00010010",
    "R[n] = GBR;",
d963 4
a966 2
  { "n", "", "stc SR,<REG_N>",  "0000nnnn00000010",
    "R[n] = GET_SR ();",
d968 2
a969 2
  { "n", "", "stc VBR,<REG_N>", "0000nnnn00100010",
    "R[n] = VBR;",
d971 2
a972 31
  { "n", "", "stc SSR,<REG_N>", "0000nnnn00110010",
    "R[n] = SSR;",
  },
  { "n", "", "stc SPC,<REG_N>", "0000nnnn01000010",
    "R[n] = SPC;",
  },
  { "n", "", "stc R0_BANK,<REG_N>", "0000nnnn10000010",
    "R[n] = Rn_BANK (0);",
  },
  { "n", "", "stc R1_BANK,<REG_N>", "0000nnnn10010010",
    "R[n] = Rn_BANK (1);",
  },
  { "n", "", "stc R2_BANK,<REG_N>", "0000nnnn10100010",
    "R[n] = Rn_BANK (2);",
  },
  { "n", "", "stc R3_BANK,<REG_N>", "0000nnnn10110010",
    "R[n] = Rn_BANK (3);",
  },
  { "n", "", "stc R4_BANK,<REG_N>", "0000nnnn11000010",
    "R[n] = Rn_BANK (4);",
  },
  { "n", "", "stc R5_BANK,<REG_N>", "0000nnnn11010010",
    "R[n] = Rn_BANK (5);",
  },
  { "n", "", "stc R6_BANK,<REG_N>", "0000nnnn11100010",
    "R[n] = Rn_BANK (6);",
  },
  { "n", "", "stc R7_BANK,<REG_N>", "0000nnnn11110010",
    "R[n] = Rn_BANK (7);",
  },
  { "n", "n", "stc.l GBR,@@-<REG_N>", "0100nnnn00010011",
d975 1
a975 1
    "WLAT (R[n], GBR);;",
d977 2
a978 1
  { "n", "n", "stc.l SR,@@-<REG_N>",  "0100nnnn00000011",
d981 1
a981 1
    "WLAT (R[n], GET_SR());",
d983 1
a983 1
  { "n", "n", "stc.l VBR,@@-<REG_N>", "0100nnnn00100011",
d986 1
a986 51
    "WLAT (R[n], VBR);",
  },
  { "n", "n", "stc.l SSR,@@-<REG_N>", "0100nnnn00110011",
    "MA (1);",
    "R[n] -= 4;",
    "WLAT (R[n], SSR);",
  },
  { "n", "n", "stc.l SPC,@@-<REG_N>", "0100nnnn01000011",
    "MA (1);",
    "R[n] -= 4;",
    "WLAT (R[n], SPC);",
  },
  { "n", "", "stc R0_BANK,@@-<REG_N>", "0100nnnn10000010",
    "MA (1);",
    "R[n] -= 4;",
    "WLAT (R[n], Rn_BANK (0));",
  },
  { "n", "", "stc R1_BANK,@@-<REG_N>", "0100nnnn10010010",
    "MA (1);",
    "R[n] -= 4;",
    "WLAT (R[n], Rn_BANK (1));",
  },
  { "n", "", "stc R2_BANK,@@-<REG_N>", "0100nnnn10100010",
    "MA (1);",
    "R[n] -= 4;",
    "WLAT (R[n], Rn_BANK (2));",
  },
  { "n", "", "stc R3_BANK,@@-<REG_N>", "0100nnnn10110010",
    "MA (1);",
    "R[n] -= 4;",
    "WLAT (R[n], Rn_BANK (3));",
  },
  { "n", "", "stc R4_BANK,@@-<REG_N>", "0100nnnn11000010",
    "MA (1);",
    "R[n] -= 4;",
    "WLAT (R[n], Rn_BANK (4));",
  },
  { "n", "", "stc R5_BANK,@@-<REG_N>", "0100nnnn11010010",
    "MA (1);",
    "R[n] -= 4;",
    "WLAT (R[n], Rn_BANK (5));",
  },
  { "n", "", "stc R6_BANK,@@-<REG_N>", "0100nnnn11100010",
    "MA (1);",
    "R[n] -= 4;",
    "WLAT (R[n], Rn_BANK (6));",
  },
  { "n", "", "stc R7_BANK,@@-<REG_N>", "0100nnnn11110010",
    "MA (1);",
    "R[n] -= 4;",
    "WLAT (R[n], Rn_BANK (7));",
d988 1
d990 2
a991 3
  /* sh3e */
  { "", "", "sts FPUL,<REG_N>", "0000nnnn01011010",
    "R[n] = FPUL;",
d993 1
a993 2
  /* sh3e */
  { "", "", "sts.l FPUL,@@-<REG_N>", "0100nnnn01010010",
d996 1
a996 36
    "WLAT (R[n], FPUL);",
  },
  /* sh3e */
  { "", "", "sts FPSCR,<REG_N>", "0000nnnn01101010",
    "R[n] = GET_FPSCR ();",
  },
  /* sh3e */
  { "", "", "sts.l FPSCR,@@-<REG_N>", "0100nnnn01100010",
    "MA (1);",
    "R[n] -= 4;",
    "WLAT (R[n], GET_FPSCR ());",
  },

  { "n", "", "sts MACH,<REG_N>", "0000nnnn00001010",
    "R[n] = MACH;",
  },
  { "n", "", "sts MACL,<REG_N>", "0000nnnn00011010",
    "R[n] = MACL;",
  },
  { "n", "", "sts PR,<REG_N>", "0000nnnn00101010",
    "R[n] = PR;",
  },
  { "n", "n", "sts.l MACH,@@-<REG_N>", "0100nnnn00000010",
    "MA (1);",
    "R[n] -= 4;",
    "WLAT (R[n], MACH);",
  },
  { "n", "n", "sts.l MACL,@@-<REG_N>", "0100nnnn00010010",
    "MA (1);",
    "R[n] -= 4;",
    "WLAT (R[n], MACL);",
  },
  { "n", "n", "sts.l PR,@@-<REG_N>", "0100nnnn00100010",
    "MA (1);",
    "R[n] -= 4;",
    "WLAT (R[n], PR);",
d1040 1
a1040 1
    "  trap(i,R,memory,maskl,maskw,little_endian);",
d1051 2
a1052 2
    "    nia = PC;",
    "    trap (i, R, memory, maskl, maskw, little_endian);",
d1055 1
a1055 1
    "  trap (i, R, memory, maskl, maskw, little_endian);",
d1059 1
a1059 1
    "  SPC = PC + 2;",
d1062 1
a1062 1
    "  nia = VBR + 0x00000100;",
d1096 217
d1315 497
d1904 2
d1913 4
a1916 1
  return (strcmp (bufa, bufb));
a1933 112
printonmatch (ptr, a, rep)
     char **ptr;
     char *a;
     char *rep;
{
  int l = strlen (a);
  if (strncmp (*ptr, a, l) == 0)
    {
      printf ("%s", rep);
      *ptr += l;
      if (**ptr)
	printf (",");
    }
}


static 
void
think (o)
     op *o;
{
  char *n;
  char *p;

  printf ("{\"");
  n = o->name;
  while (*n && *n != ' ')
    {
      printf ("%c", *n);
      n++;
    }
  printf ("\",{");

  p = n;

  if (!*p)
    {
      printf ("0");
    }
  while (*p)
    {
      while (*p == ',' || *p == ' ')
	p++;
      printonmatch (&p, "#<imm>", "A_IMM");
      printonmatch (&p, "R0", "A_R0");
      printonmatch (&p, "<REG_N>", "A_REG_N");
      printonmatch (&p, "@@<REG_N>+", "A_INC_N");
      printonmatch (&p, "@@<REG_N>", "A_IND_N");
      printonmatch (&p, "@@-<REG_N>", "A_DEC_N");
      printonmatch (&p, "<REG_M>", " A_REG_M");
      printonmatch (&p, "@@<REG_M>+", "A_INC_M");
      printonmatch (&p, "@@<REG_M>", "A_IND_M");
      printonmatch (&p, "@@-<REG_M>", "A_DEC_M");
      printonmatch (&p, "@@(<disp>,PC)", "A_DISP_PC");
      printonmatch (&p, "@@(<disp>,<REG_M>)", "A_DISP_REG_M");
      printonmatch (&p, "@@(<disp>,<REG_N>)", "A_DISP_REG_N");
      printonmatch (&p, "@@(R0,<REG_N>)", "A_IND_R0_REG_N");
      printonmatch (&p, "@@(R0,<REG_M>)", "A_IND_R0_REG_M");
      printonmatch (&p, "@@(<disp>,GBR)", "A_DISP_GBR");
      printonmatch (&p, "@@(R0,GBR)", "A_R0_GBR");
      printonmatch (&p, "<bdisp8>", "A_BDISP8");
      printonmatch (&p, "<bdisp12>", "A_BDISP12");
      printonmatch (&p, "SR", "A_SR");
      printonmatch (&p, "GBR", "A_GBR");
      printonmatch (&p, "VBR", "A_VBR");
      printonmatch (&p, "SSR", "A_SSR");
      printonmatch (&p, "SPC", "A_SPC");
      printonmatch (&p, "MACH", "A_MACH");
      printonmatch (&p, "MACL", "A_MACL");
      printonmatch (&p, "PR", "A_PR");

    }
  printf ("},{");

  p = o->code;
  while (*p)
    {
      printonmatch (&p, "0000", "HEX_0");
      printonmatch (&p, "0001", "HEX_1");
      printonmatch (&p, "0010", "HEX_2");
      printonmatch (&p, "0011", "HEX_3");
      printonmatch (&p, "0100", "HEX_4");
      printonmatch (&p, "0101", "HEX_5");
      printonmatch (&p, "0110", "HEX_6");
      printonmatch (&p, "0111", "HEX_7");

      printonmatch (&p, "1000", "HEX_8");
      printonmatch (&p, "1001", "HEX_9");
      printonmatch (&p, "1010", "HEX_A");
      printonmatch (&p, "1011", "HEX_B");
      printonmatch (&p, "1100", "HEX_C");
      printonmatch (&p, "1101", "HEX_D");
      printonmatch (&p, "1110", "HEX_E");
      printonmatch (&p, "1111", "HEX_F");
      printonmatch (&p, "i8*1....", "IMM_8");
      printonmatch (&p, "i4*1", "IMM_4");
      printonmatch (&p, "i8p4....", "PCRELIMM_8BY4");
      printonmatch (&p, "i8p2....", "PCRELIMM_8BY2");
      printonmatch (&p, "i8*2....", "IMM_8BY2");
      printonmatch (&p, "i4*2", "IMM_4BY2");
      printonmatch (&p, "i8*4....", "IMM_8BY4");
      printonmatch (&p, "i4*4", "IMM_4BY4");
      printonmatch (&p, "i12.........", "BRANCH_12");
      printonmatch (&p, "i8p1....", "BRANCH_8");
      printonmatch (&p, "nnnn", "REG_N");
      printonmatch (&p, "mmmm", "REG_M");

    }
  printf ("}},\n");
}

static void
a1945 29

static void
genopc ()
{
  op *p;
  make_enum_list ("sh_nibble_type", nibble_type_list);
  make_enum_list ("sh_arg_type", arg_type_list);

  printf ("typedef struct {\n");
  printf ("char *name;\n");
  printf ("sh_arg_type arg[3];\n");
  printf ("sh_nibble_type nibbles[4];\n");
  printf ("} sh_opcode_info;\n");
  printf ("#ifdef DEFINE_TABLE\n");
  printf ("sh_opcode_info sh_table[]={\n");
  for (p = tab; p->name; p++)
    {
      printf ("\n/* %s %-20s*/", p->code, p->name);
      think (p);
    }
  printf ("0};\n");
  printf ("#endif\n");
}






d1992 1
d1994 20
a2013 5
	    int n = bton (s);
	    if (n >= 0)
	      {
		expand_opcode (shift - 4, val | (n << shift), i, s + 4);
	      }
d2024 31
d2069 4
a2072 1
dumptable ()
d2077 1
a2077 1
  int i = 0;
d2079 2
a2080 1
  while (i < 1 << 16)
d2084 1
a2084 1
      printf ("unsigned char sh_jump_table%x[%d]={\n", i, lump);
a2100 1
      printf ("};\n");
d2102 1
a2102 1

d2107 2
a2108 1
filltable ()
d2110 1
a2110 2
  op *p;
  int index = 1;
d2113 1
a2113 1
  for (p = tab; p->name; p++)
d2120 4
d2125 1
a2125 1
gensim ()
d2127 1
a2127 2
  op *p;
  int j;
d2129 4
a2132 2
  printf ("{\n");
  printf ("  switch (jump_table[iword]) {\n");
d2134 5
a2138 1
  for (p = tab; p->name; p++)
d2140 1
d2157 2
d2167 14
d2182 4
a2186 1
	      needm = 1;
d2188 16
a2203 1

d2259 2
d2290 11
d2303 1
a2303 1
  printf ("      saved_state.asregs.exception = SIGILL;\n");
a2308 1

d2313 1
a2313 1
  filltable();
d2331 228
d2592 2
a2593 2
	  filltable ();
	  dumptable ();
d2595 8
d2606 2
a2607 1
	  filltable ();
d2610 5
d2617 1
a2617 3
    {
      genopc ();
    }
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a246 24
  /* sh4 */
  { "", "", "fcnvds <DR_N>,FPUL", "1111nnnn10111101",
    "if (! FPSCR_PR || n & 1)",
    "  saved_state.asregs.exception = SIGILL;",
    "else",
    "{",
    "  char buf[4];",
    "  *(float *)buf = DR(n);",
    "  FPUL = *(int *)buf;",
    "}",
  },

  /* sh4 */
  { "", "", "fcnvsd FPUL,<DR_N>", "1111nnnn10101101",
    "if (! FPSCR_PR || n & 1)",
    "  saved_state.asregs.exception = SIGILL;",
    "else",
    "{",
    "  char buf[4];",
    "  *(int *)buf = FPUL;",
    "  SET_DR(n, *(float *)buf);",
    "}",
  },

a252 7
  /* sh4 */
  { "", "", "fipr <FV_M>,<FV_N>", "1111nnmm11101101",
    "/* FIXME: not implemented */",
    "saved_state.asregs.exception = SIGILL;",
    "/* FIXME: check for DP and (n & 1) == 0? */",
  },

a273 4
    /* sh4 */
    "if (FPSCR_PR)",
    "  SET_DR (n, (double)FPUL);",
    "else",
a286 8
    /* sh4 */
    "if (FPSCR_SZ) {",
    "  int ni = XD_TO_XF (n);",
    "  int mi = XD_TO_XF (m);",
    "  SET_XF (ni + 0, XF (mi + 0));",
    "  SET_XF (ni + 1, XF (mi + 1));",
    "}",
    "else",
a292 6
    /* sh4 */
    "if (FPSCR_SZ) {",
    "  MA (2);",
    "  WDAT (R[n], m);",
    "}",
    "else",
a299 6
    /* sh4 */
    "if (FPSCR_SZ) {",
    "  MA (2);",
    "  RDAT (R[m], n);",
    "}",
    "else",
a306 7
    /* sh4 */
    "if (FPSCR_SZ) {",
    "  MA (2);",
    "  RDAT (R[m], n);",
    "  R[m] += 8;",
    "}",
    "else",
a314 7
    /* sh4 */
    "if (FPSCR_SZ) {",
    "  MA (2);",
    "  R[n] -= 8;",
    "  WDAT (R[n], m);",
    "}",
    "else",
a322 6
    /* sh4 */
    "if (FPSCR_SZ) {",
    "  MA (2);",
    "  RDAT (R[0]+R[m], n);",
    "}",
    "else",
a329 6
    /* sh4 */
    "if (FPSCR_SZ) {",
    "  MA (2);",
    "  WDAT (R[0]+R[n], m);",
    "}",
    "else",
a335 2
  /* sh4: See fmov instructions above for move to/from extended fp registers */

a345 10
  /* sh4 */
  { "", "", "frchg", "1111101111111101",
    "SET_FPSCR (GET_FPSCR() ^ FPSCR_MASK_FR);",
  },

  /* sh4 */
  { "", "", "fschg", "1111001111111101",
    "SET_FPSCR (GET_FPSCR() ^ FPSCR_MASK_SZ);",
  },

a357 8
    /* sh4 */
    "if (FPSCR_PR) {",
    "  if (DR(n) != DR(n)) /* NaN */",
    "    FPUL = 0x80000000;",
    "  else",
    "    FPUL =  (int)DR(n);",
    "}",
    "else",
d365 4
a407 6
#if 0
  { "", "n", "ldc <REG_N>,DBR", "0100nnnn11111010",
    "DBR = R[n];",
    "/* FIXME: user mode */",
  },
#endif
a469 8
#if 0
  { "", "n", "ldc.l @@<REG_N>+,DBR", "0100nnnn11110110",
    "MA (1);",
    "DBR = RLAT (R[n]);",
    "R[n] += 4;",
    "/* FIXME: user mode */",
  },
#endif
a742 5
  { "0", "", "movca.l @@R0, <REG_N>", "0000nnnn11000011",
    "/* FIXME: Not implemented */",
    "saved_state.asregs.exception = SIGILL;",
  },

a785 15
  { "0", "", "ocbi @@<REG_N>", "0000nnnn10010011",
    "/* FIXME: Not implemented */",
    "saved_state.asregs.exception = SIGILL;",
  },

  { "0", "", "ocbp @@<REG_N>", "0000nnnn10100011",
    "/* FIXME: Not implemented */",
    "saved_state.asregs.exception = SIGILL;",
  },

  { "", "n", "ocbwb @@<REG_N>", "0000nnnn10110011",
    "RSBAT (R[n]); /* Take exceptions like byte load.  */",
    "/* FIXME: Cache not implemented */",
  },

a922 8
#if 0
  { "n", "", "stc SGR,<REG_N>", "0000nnnn00111010",
    "R[n] = SGR;",
  },
  { "n", "", "stc DBR,<REG_N>", "0000nnnn11111010",
    "R[n] = DBR;",
  },
#endif
a971 12
#if 0
  { "n", "n", "stc.l SGR,@@-<REG_N>", "0100nnnn00110010",
    "MA (1);",
    "R[n] -= 4;",
    "WLAT (R[n], SGR);",
  },
  { "n", "n", "stc.l DBR,@@-<REG_N>", "0100nnnn11110010",
    "MA (1);",
    "R[n] -= 4;",
    "WLAT (R[n], DBR);",
  },
#endif
a1154 9

#if 0
  { "divs.l <REG_M>,<REG_N>", "0100nnnnmmmm1110",
    "divl(0,R[n],R[m]);",
  },
  { "divu.l <REG_M>,<REG_N>", "0100nnnnmmmm1101",
    "divl(0,R[n],R[m]);",
  },
#endif
@


1.1.1.3
log
@import gdb-1999-08-30 snapshot
@
text
@d253 3
a255 7
    "  union",
    "  {",
    "    int i;",
    "    float f;",
    "  } u;",
    "  u.f = DR(n);",
    "  FPUL = u.i;",
d265 3
a267 7
    "  union",
    "  {",
    "    int i;",
    "    float f;",
    "  } u;",
    "  u.i = FPUL;",
    "  SET_DR(n, u.f);",
d298 3
a300 7
    "  union",
    "  {",
    "    int i;",
    "    float f;",
    "  } u;",
    "  u.f = FR(n);",
    "  FPUL = u.i;",
d467 3
a469 7
    "  union",
    "  {",
    "    int i;",
    "    float f;",
    "  } u;",
    "  u.i = FPUL;",
    "  SET_FR (n, u.f);",
@


