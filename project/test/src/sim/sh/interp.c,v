head	1.25;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.24
	gdb_7_6-2013-04-26-release:1.24
	gdb_7_6-branch:1.24.0.4
	gdb_7_6-2013-03-12-branchpoint:1.24
	gdb_7_5_1-2012-11-29-release:1.24
	gdb_7_5-2012-08-17-release:1.24
	gdb_7_5-branch:1.24.0.2
	gdb_7_5-2012-07-18-branchpoint:1.24
	gdb_7_4_1-2012-04-26-release:1.23
	gdb_7_4-2012-01-24-release:1.23
	gdb_7_4-branch:1.23.0.2
	gdb_7_4-2011-12-13-branchpoint:1.23
	gdb_7_3_1-2011-09-04-release:1.22
	gdb_7_3-2011-07-26-release:1.22
	gdb_7_3-branch:1.22.0.4
	gdb_7_3-2011-04-01-branchpoint:1.22
	gdb_7_2-2010-09-02-release:1.22
	gdb_7_2-branch:1.22.0.2
	gdb_7_2-2010-07-07-branchpoint:1.22
	gdb_7_1-2010-03-18-release:1.21
	gdb_7_1-branch:1.21.0.2
	gdb_7_1-2010-02-18-branchpoint:1.21
	gdb_7_0_1-2009-12-22-release:1.20
	gdb_7_0-2009-10-06-release:1.20
	gdb_7_0-branch:1.20.0.20
	gdb_7_0-2009-09-16-branchpoint:1.20
	arc-sim-20090309:1.20
	msnyder-checkpoint-072509-branch:1.20.0.18
	msnyder-checkpoint-072509-branchpoint:1.20
	arc-insight_6_8-branch:1.20.0.16
	arc-insight_6_8-branchpoint:1.20
	insight_6_8-branch:1.20.0.14
	insight_6_8-branchpoint:1.20
	reverse-20081226-branch:1.20.0.12
	reverse-20081226-branchpoint:1.20
	multiprocess-20081120-branch:1.20.0.10
	multiprocess-20081120-branchpoint:1.20
	reverse-20080930-branch:1.20.0.8
	reverse-20080930-branchpoint:1.20
	reverse-20080717-branch:1.20.0.6
	reverse-20080717-branchpoint:1.20
	msnyder-reverse-20080609-branch:1.20.0.4
	msnyder-reverse-20080609-branchpoint:1.20
	drow-reverse-20070409-branch:1.19.0.26
	drow-reverse-20070409-branchpoint:1.19
	gdb_6_8-2008-03-27-release:1.20
	gdb_6_8-branch:1.20.0.2
	gdb_6_8-2008-02-26-branchpoint:1.20
	gdb_6_7_1-2007-10-29-release:1.19
	gdb_6_7-2007-10-10-release:1.19
	gdb_6_7-branch:1.19.0.24
	gdb_6_7-2007-09-07-branchpoint:1.19
	insight_6_6-20070208-release:1.19
	gdb_6_6-2006-12-18-release:1.19
	gdb_6_6-branch:1.19.0.22
	gdb_6_6-2006-11-15-branchpoint:1.19
	insight_6_5-20061003-release:1.19
	gdb-csl-symbian-6_4_50_20060226-12:1.19
	gdb-csl-sourcerygxx-3_4_4-25:1.19
	nickrob-async-20060828-mergepoint:1.19
	gdb-csl-symbian-6_4_50_20060226-11:1.19
	gdb-csl-sourcerygxx-4_1-17:1.19
	gdb-csl-20060226-branch-local-2:1.19
	gdb-csl-sourcerygxx-4_1-14:1.19
	gdb-csl-sourcerygxx-4_1-13:1.19
	gdb-csl-sourcerygxx-4_1-12:1.19
	gdb-csl-sourcerygxx-3_4_4-21:1.19
	gdb_6_5-20060621-release:1.19
	gdb-csl-sourcerygxx-4_1-9:1.19
	gdb-csl-sourcerygxx-4_1-8:1.19
	gdb-csl-sourcerygxx-4_1-7:1.19
	gdb-csl-arm-2006q1-6:1.19
	gdb-csl-sourcerygxx-4_1-6:1.19
	gdb-csl-symbian-6_4_50_20060226-10:1.19
	gdb-csl-symbian-6_4_50_20060226-9:1.19
	gdb-csl-symbian-6_4_50_20060226-8:1.19
	gdb-csl-coldfire-4_1-11:1.19
	gdb-csl-sourcerygxx-3_4_4-19:1.19
	gdb-csl-coldfire-4_1-10:1.19
	gdb_6_5-branch:1.19.0.20
	gdb_6_5-2006-05-14-branchpoint:1.19
	gdb-csl-sourcerygxx-4_1-5:1.19
	nickrob-async-20060513-branch:1.19.0.18
	nickrob-async-20060513-branchpoint:1.19
	gdb-csl-sourcerygxx-4_1-4:1.19
	msnyder-reverse-20060502-branch:1.19.0.16
	msnyder-reverse-20060502-branchpoint:1.19
	gdb-csl-morpho-4_1-4:1.19
	gdb-csl-sourcerygxx-3_4_4-17:1.19
	readline_5_1-import-branch:1.19.0.14
	readline_5_1-import-branchpoint:1.19
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.19
	gdb-csl-symbian-20060226-branch:1.19.0.12
	gdb-csl-symbian-20060226-branchpoint:1.19
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.19
	msnyder-reverse-20060331-branch:1.19.0.10
	msnyder-reverse-20060331-branchpoint:1.19
	gdb-csl-available-20060303-branch:1.19.0.8
	gdb-csl-available-20060303-branchpoint:1.19
	gdb-csl-20060226-branch:1.19.0.6
	gdb-csl-20060226-branchpoint:1.19
	gdb_6_4-20051202-release:1.18
	msnyder-fork-checkpoint-branch:1.19.0.4
	msnyder-fork-checkpoint-branchpoint:1.19
	gdb-csl-gxxpro-6_3-branch:1.19.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.19
	gdb_6_4-branch:1.18.0.4
	gdb_6_4-2005-11-01-branchpoint:1.18
	gdb-csl-arm-20051020-branch:1.18.0.2
	gdb-csl-arm-20051020-branchpoint:1.18
	msnyder-tracepoint-checkpoint-branch:1.16.0.6
	msnyder-tracepoint-checkpoint-branchpoint:1.16
	gdb-csl-arm-20050325-2005-q1b:1.16
	gdb-csl-arm-20050325-2005-q1a:1.16
	csl-arm-20050325-branch:1.16.0.4
	csl-arm-20050325-branchpoint:1.16
	gdb_6_3-20041109-release:1.16
	gdb_6_3-branch:1.16.0.2
	gdb_6_3-20041019-branchpoint:1.16
	drow_intercu-merge-20040921:1.16
	drow_intercu-merge-20040915:1.16
	jimb-gdb_6_2-e500-branch:1.15.0.16
	jimb-gdb_6_2-e500-branchpoint:1.15
	gdb_6_2-20040730-release:1.15
	gdb_6_2-branch:1.15.0.12
	gdb_6_2-2004-07-10-gmt-branchpoint:1.15
	gdb_6_1_1-20040616-release:1.15
	gdb_6_1-2004-04-05-release:1.15
	drow_intercu-merge-20040402:1.15
	drow_intercu-merge-20040327:1.15
	ezannoni_pie-20040323-branch:1.15.0.10
	ezannoni_pie-20040323-branchpoint:1.15
	cagney_tramp-20040321-mergepoint:1.15
	cagney_tramp-20040309-branch:1.15.0.8
	cagney_tramp-20040309-branchpoint:1.15
	gdb_6_1-branch:1.15.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.15
	drow_intercu-20040221-branch:1.15.0.4
	drow_intercu-20040221-branchpoint:1.15
	cagney_bfdfile-20040213-branch:1.15.0.2
	cagney_bfdfile-20040213-branchpoint:1.15
	drow-cplus-merge-20040208:1.14
	carlton_dictionary-20040126-merge:1.14
	cagney_bigcore-20040122-branch:1.14.0.2
	cagney_bigcore-20040122-branchpoint:1.14
	drow-cplus-merge-20040113:1.14
	drow-cplus-merge-20031224:1.12
	drow-cplus-merge-20031220:1.12
	carlton_dictionary-20031215-merge:1.12
	drow-cplus-merge-20031214:1.12
	carlton-dictionary-20031111-merge:1.12
	gdb_6_0-2003-10-04-release:1.9
	kettenis_sparc-20030918-branch:1.10.0.6
	kettenis_sparc-20030918-branchpoint:1.10
	carlton_dictionary-20030917-merge:1.10
	ezannoni_pie-20030916-branchpoint:1.10
	ezannoni_pie-20030916-branch:1.10.0.4
	cagney_x86i386-20030821-branch:1.10.0.2
	cagney_x86i386-20030821-branchpoint:1.10
	carlton_dictionary-20030805-merge:1.9
	carlton_dictionary-20030627-merge:1.9
	gdb_6_0-branch:1.9.0.30
	gdb_6_0-2003-06-23-branchpoint:1.9
	jimb-ppc64-linux-20030613-branch:1.9.0.28
	jimb-ppc64-linux-20030613-branchpoint:1.9
	cagney_convert-20030606-branch:1.9.0.26
	cagney_convert-20030606-branchpoint:1.9
	cagney_writestrings-20030508-branch:1.9.0.24
	cagney_writestrings-20030508-branchpoint:1.9
	jimb-ppc64-linux-20030528-branch:1.9.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.9
	carlton_dictionary-20030523-merge:1.9
	cagney_fileio-20030521-branch:1.9.0.20
	cagney_fileio-20030521-branchpoint:1.9
	kettenis_i386newframe-20030517-mergepoint:1.9
	jimb-ppc64-linux-20030509-branch:1.9.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.9
	kettenis_i386newframe-20030504-mergepoint:1.9
	carlton_dictionary-20030430-merge:1.9
	kettenis_i386newframe-20030419-branch:1.9.0.16
	kettenis_i386newframe-20030419-branchpoint:1.9
	carlton_dictionary-20030416-merge:1.9
	cagney_frameaddr-20030409-mergepoint:1.9
	kettenis_i386newframe-20030406-branch:1.9.0.14
	kettenis_i386newframe-20030406-branchpoint:1.9
	cagney_frameaddr-20030403-branchpoint:1.9
	cagney_frameaddr-20030403-branch:1.9.0.12
	cagney_framebase-20030330-mergepoint:1.9
	cagney_framebase-20030326-branch:1.9.0.10
	cagney_framebase-20030326-branchpoint:1.9
	cagney_lazyid-20030317-branch:1.9.0.8
	cagney_lazyid-20030317-branchpoint:1.9
	kettenis-i386newframe-20030316-mergepoint:1.9
	offbyone-20030313-branch:1.9.0.6
	offbyone-20030313-branchpoint:1.9
	kettenis-i386newframe-20030308-branch:1.9.0.4
	kettenis-i386newframe-20030308-branchpoint:1.9
	carlton_dictionary-20030305-merge:1.9
	cagney_offbyone-20030303-branch:1.9.0.2
	cagney_offbyone-20030303-branchpoint:1.9
	carlton_dictionary-20030207-merge:1.8
	interps-20030202-branch:1.8.0.4
	interps-20030202-branchpoint:1.8
	cagney-unwind-20030108-branch:1.8.0.2
	cagney-unwind-20030108-branchpoint:1.8
	carlton_dictionary-20021223-merge:1.8
	gdb_5_3-2002-12-12-release:1.7
	carlton_dictionary-20021115-merge:1.8
	kseitz_interps-20021105-merge:1.8
	kseitz_interps-20021103-merge:1.8
	drow-cplus-merge-20021020:1.8
	drow-cplus-merge-20021025:1.8
	carlton_dictionary-20021025-merge:1.8
	carlton_dictionary-20021011-merge:1.8
	drow-cplus-branch:1.7.0.10
	drow-cplus-branchpoint:1.7
	kseitz_interps-20020930-merge:1.7
	carlton_dictionary-20020927-merge:1.7
	carlton_dictionary-branch:1.7.0.8
	carlton_dictionary-20020920-branchpoint:1.7
	gdb_5_3-branch:1.7.0.6
	gdb_5_3-2002-09-04-branchpoint:1.7
	kseitz_interps-20020829-merge:1.7
	cagney_sysregs-20020825-branch:1.7.0.4
	cagney_sysregs-20020825-branchpoint:1.7
	readline_4_3-import-branch:1.7.0.2
	readline_4_3-import-branchpoint:1.7
	gdb_5_2_1-2002-07-23-release:1.4
	kseitz_interps-20020528-branch:1.4.0.14
	kseitz_interps-20020528-branchpoint:1.4
	cagney_regbuf-20020515-branch:1.4.0.12
	cagney_regbuf-20020515-branchpoint:1.4
	jimb-macro-020506-branch:1.4.0.10
	jimb-macro-020506-branchpoint:1.4
	gdb_5_2-2002-04-29-release:1.4
	gdb_5_2-branch:1.4.0.8
	gdb_5_2-2002-03-03-branchpoint:1.4
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	insight-precleanup-2001-01-01:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	gdb-2000-02-04:1.1.1.2
	gdb-2000-02-02:1.1.1.2
	gdb-2000-02-01:1.1.1.2
	gdb-2000-01-31:1.1.1.2
	gdb-2000-01-26:1.1.1.2
	gdb-2000-01-24:1.1.1.2
	gdb-2000-01-17:1.1.1.2
	gdb-2000-01-10:1.1.1.2
	gdb-2000-01-05:1.1.1.2
	gdb-1999-12-21:1.1.1.2
	gdb-1999-12-13:1.1.1.2
	gdb-1999-12-07:1.1.1.2
	gdb-1999-12-06:1.1.1.2
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.25
date	2013.03.15.17.53.44;	author sje;	state Exp;
branches;
next	1.24;

1.24
date	2012.02.16.23.17.27;	author kevinb;	state Exp;
branches;
next	1.23;

1.23
date	2011.04.16.18.16.36;	author vapier;	state Exp;
branches;
next	1.22;

1.22
date	2010.04.14.07.38.06;	author vapier;	state Exp;
branches;
next	1.21;

1.21
date	2010.02.14.07.15.57;	author monaka;	state Exp;
branches;
next	1.20;

1.20
date	2008.02.04.17.26.07;	author ams;	state Exp;
branches;
next	1.19;

1.19
date	2005.11.10.11.05.31;	author ams;	state Exp;
branches;
next	1.18;

1.18
date	2005.09.19.11.29.30;	author amylaar;	state Exp;
branches;
next	1.17;

1.17
date	2005.08.02.16.17.59;	author amylaar;	state Exp;
branches;
next	1.16;

1.16
date	2004.09.08.09.11.50;	author corinna;	state Exp;
branches;
next	1.15;

1.15
date	2004.02.12.19.32.12;	author msnyder;	state Exp;
branches
	1.15.4.1;
next	1.14;

1.14
date	2004.01.10.00.43.28;	author msnyder;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.09.19.44.49;	author msnyder;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.03.14.14.15;	author amylaar;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.15.12.30.47;	author amylaar;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.11.19.28.05;	author msnyder;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.27.23.26.34;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2002.10.11.15.31.28;	author amylaar;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.17.18.43.27;	author amylaar;	state Exp;
branches
	1.7.8.1
	1.7.10.1;
next	1.6;

1.6
date	2002.06.18.15.54.44;	author amylaar;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.09.15.45.52;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.30.23.03.56;	author aoliva;	state Exp;
branches
	1.4.12.1
	1.4.14.1;
next	1.3;

1.3
date	2001.01.24.13.17.01;	author aoliva;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.15.21.12.42;	author amylaar;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.12;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.15.4.1
date	2004.09.16.17.02.13;	author drow;	state Exp;
branches;
next	;

1.7.8.1
date	2002.10.11.22.23.08;	author carlton;	state Exp;
branches;
next	1.7.8.2;

1.7.8.2
date	2003.03.06.00.56.42;	author carlton;	state Exp;
branches;
next	1.7.8.3;

1.7.8.3
date	2003.09.17.21.29.04;	author carlton;	state Exp;
branches;
next	1.7.8.4;

1.7.8.4
date	2003.11.11.23.51.21;	author carlton;	state Exp;
branches;
next	1.7.8.5;

1.7.8.5
date	2004.01.26.19.11.54;	author carlton;	state Exp;
branches;
next	;

1.7.10.1
date	2002.10.26.17.12.33;	author drow;	state Exp;
branches;
next	1.7.10.2;

1.7.10.2
date	2003.12.14.20.28.29;	author drow;	state Exp;
branches;
next	1.7.10.3;

1.7.10.3
date	2004.01.13.16.12.25;	author drow;	state Exp;
branches;
next	;

1.4.12.1
date	2002.06.15.16.43.32;	author cagney;	state Exp;
branches;
next	1.4.12.2;

1.4.12.2
date	2002.06.21.15.49.12;	author cagney;	state Exp;
branches;
next	;

1.4.14.1
date	2002.06.20.01.41.00;	author kseitz;	state Exp;
branches;
next	1.4.14.2;

1.4.14.2
date	2002.07.22.21.47.27;	author kseitz;	state Exp;
branches;
next	1.4.14.3;

1.4.14.3
date	2002.11.03.21.49.48;	author ezannoni;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.35.12;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.33.43;	author shebs;	state Exp;
branches;
next	;


desc
@@


1.25
log
@gdb:

2013-03-15  Steve Ellcey  <sellcey@@mips.com>

	* remote-sim.c (sim_command_completer): Make char arguments const.

include:


2013-03-15  Steve Ellcey  <sellcey@@mips.com>

	* gdb/remote-sim.h (sim_command_completer): Make char arguments const.

sim:

2013-03-15  Steve Ellcey  <sellcey@@mips.com>

	* arm/wrapper.c (sim_complete_command): Make char arguments const.
	* avr/interp.c (sim_complete_command): Ditto.
	* common/sim-options.c (sim_complete_command): Ditto.
	* cr16/interp.c (sim_complete_command): Ditto.
	* erc32/interf.c (sim_complete_command): Ditto.
	* m32c/gdb-if.c (sim_complete_command): Ditto.
	* microblaze/interp.c (sim_complete_command): Ditto.
	* ppc/sim_calls.c (sim_complete_command): Ditto.
	* rl78/gdb-if.c (sim_complete_command): Ditto.
	* rx/gdb-if.c (sim_complete_command): Ditto.
	* sh/interp.c (sim_complete_command): Ditto.
@
text
@/* Simulator for the Renesas (formerly Hitachi) / SuperH Inc. SH architecture.

   Written by Steve Chamberlain of Cygnus Support.
   sac@@cygnus.com

   This file is part of SH sim


		THIS SOFTWARE IS NOT COPYRIGHTED

   Cygnus offers the following for use in the public domain.  Cygnus
   makes no warranty with regard to the software or it's performance
   and the user accepts the software "AS IS" with all faults.

   CYGNUS DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD TO
   THIS SOFTWARE INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

*/

#include "config.h"

#include <stdio.h>
#include <errno.h>
#include <signal.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef HAVE_MMAP
#include <sys/mman.h>
# ifndef MAP_FAILED
#  define MAP_FAILED -1
# endif
# if !defined (MAP_ANONYMOUS) && defined (MAP_ANON)
#  define MAP_ANONYMOUS MAP_ANON
# endif
#endif

#ifdef HAVE_STRING_H
#include <string.h>
#else
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif
#endif

#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#ifdef HAVE_SYS_STAT_H
#include <sys/stat.h>
#endif

#include "bfd.h"
#include "gdb/callback.h"
#include "gdb/remote-sim.h"
#include "gdb/sim-sh.h"

/* This file is local - if newlib changes, then so should this.  */
#include "syscall.h"

#include <math.h>

#ifdef _WIN32
#include <float.h>		/* Needed for _isnan() */
#define isnan _isnan
#endif

#ifndef SIGBUS
#define SIGBUS SIGSEGV
#endif

#ifndef SIGQUIT
#define SIGQUIT SIGTERM
#endif

#ifndef SIGTRAP
#define SIGTRAP 5
#endif

extern unsigned short sh_jump_table[], sh_dsp_table[0x1000], ppi_table[];

int sim_write (SIM_DESC sd, SIM_ADDR addr, const unsigned char *buffer, int size);

#define O_RECOMPILE 85
#define DEFINE_TABLE
#define DISASSEMBLER_TABLE

/* Define the rate at which the simulator should poll the host
   for a quit. */
#define POLL_QUIT_INTERVAL 0x60000

typedef struct
{
  int regs[20];
} regstacktype;

typedef union
{

  struct
  {
    int regs[16];
    int pc;

    /* System registers.  For sh-dsp this also includes A0 / X0 / X1 / Y0 / Y1
       which are located in fregs, i.e. strictly speaking, these are
       out-of-bounds accesses of sregs.i .  This wart of the code could be
       fixed by making fregs part of sregs, and including pc too - to avoid
       alignment repercussions - but this would cause very onerous union /
       structure nesting, which would only be managable with anonymous
       unions and structs.  */
    union
      {
	struct
	  {
	    int mach;
	    int macl;
	    int pr;
	    int dummy3, dummy4;
	    int fpul; /* A1 for sh-dsp -  but only for movs etc.  */
	    int fpscr; /* dsr for sh-dsp */
	  } named;
	int i[7];
      } sregs;

    /* sh3e / sh-dsp */
    union fregs_u
      {
	float f[16];
	double d[8];
	int i[16];
      }
    fregs[2];

    /* Control registers; on the SH4, ldc / stc is privileged, except when
       accessing gbr.  */
    union
      {
	struct
	  {
	    int sr;
	    int gbr;
	    int vbr;
	    int ssr;
	    int spc;
	    int mod;
	    /* sh-dsp */
	    int rs;
	    int re;
	    /* sh3 */
	    int bank[8];
	    int dbr;		/* debug base register */
	    int sgr;		/* saved gr15 */
	    int ldst;		/* load/store flag (boolean) */
	    int tbr;
	    int ibcr;		/* sh2a bank control register */
	    int ibnr;		/* sh2a bank number register */
	  } named;
	int i[16];
      } cregs;

    unsigned char *insn_end;

    int ticks;
    int stalls;
    int memstalls;
    int cycles;
    int insts;

    int prevlock;
    int thislock;
    int exception;

    int end_of_registers;

    int msize;
#define PROFILE_FREQ 1
#define PROFILE_SHIFT 2
    int profile;
    unsigned short *profile_hist;
    unsigned char *memory;
    int xyram_select, xram_start, yram_start;
    unsigned char *xmem;
    unsigned char *ymem;
    unsigned char *xmem_offset;
    unsigned char *ymem_offset;
    unsigned long bfd_mach;
    regstacktype *regstack;
  }
  asregs;
  int asints[40];
} saved_state_type;

saved_state_type saved_state;

struct loop_bounds { unsigned char *start, *end; };

/* These variables are at file scope so that functions other than
   sim_resume can use the fetch/store macros */

static int target_little_endian;
static int global_endianw, endianb;
static int target_dsp;
static int host_little_endian;
static char **prog_argv;

static int maskw = 0;
static int maskl = 0;

static SIM_OPEN_KIND sim_kind;
static char *myname;
static int   tracing = 0;


/* Short hand definitions of the registers */

#define SBIT(x) ((x)&sbit)
#define R0 	saved_state.asregs.regs[0]
#define Rn 	saved_state.asregs.regs[n]
#define Rm 	saved_state.asregs.regs[m]
#define UR0 	(unsigned int) (saved_state.asregs.regs[0])
#define UR 	(unsigned int) R
#define UR 	(unsigned int) R
#define SR0 	saved_state.asregs.regs[0]
#define CREG(n)	(saved_state.asregs.cregs.i[(n)])
#define GBR 	saved_state.asregs.cregs.named.gbr
#define VBR 	saved_state.asregs.cregs.named.vbr
#define DBR 	saved_state.asregs.cregs.named.dbr
#define TBR 	saved_state.asregs.cregs.named.tbr
#define IBCR	saved_state.asregs.cregs.named.ibcr
#define IBNR	saved_state.asregs.cregs.named.ibnr
#define BANKN	(saved_state.asregs.cregs.named.ibnr & 0x1ff)
#define ME	((saved_state.asregs.cregs.named.ibnr >> 14) & 0x3)
#define SSR	saved_state.asregs.cregs.named.ssr
#define SPC	saved_state.asregs.cregs.named.spc
#define SGR 	saved_state.asregs.cregs.named.sgr
#define SREG(n)	(saved_state.asregs.sregs.i[(n)])
#define MACH 	saved_state.asregs.sregs.named.mach
#define MACL 	saved_state.asregs.sregs.named.macl
#define PR	saved_state.asregs.sregs.named.pr
#define FPUL	saved_state.asregs.sregs.named.fpul

#define PC insn_ptr



/* Alternate bank of registers r0-r7 */

/* Note: code controling SR handles flips between BANK0 and BANK1 */
#define Rn_BANK(n) (saved_state.asregs.cregs.named.bank[(n)])
#define SET_Rn_BANK(n, EXP) do { saved_state.asregs.cregs.named.bank[(n)] = (EXP); } while (0)


/* Manipulate SR */

#define SR_MASK_BO  (1 << 14)
#define SR_MASK_CS  (1 << 13)
#define SR_MASK_DMY (1 << 11)
#define SR_MASK_DMX (1 << 10)
#define SR_MASK_M (1 << 9)
#define SR_MASK_Q (1 << 8)
#define SR_MASK_I (0xf << 4)
#define SR_MASK_S (1 << 1)
#define SR_MASK_T (1 << 0)

#define SR_MASK_BL (1 << 28)
#define SR_MASK_RB (1 << 29)
#define SR_MASK_MD (1 << 30)
#define SR_MASK_RC 0x0fff0000
#define SR_RC_INCREMENT -0x00010000

#define BO	((saved_state.asregs.cregs.named.sr & SR_MASK_BO) != 0)
#define CS	((saved_state.asregs.cregs.named.sr & SR_MASK_CS) != 0)
#define M 	((saved_state.asregs.cregs.named.sr & SR_MASK_M) != 0)
#define Q 	((saved_state.asregs.cregs.named.sr & SR_MASK_Q) != 0)
#define S 	((saved_state.asregs.cregs.named.sr & SR_MASK_S) != 0)
#define T 	((saved_state.asregs.cregs.named.sr & SR_MASK_T) != 0)
#define LDST	((saved_state.asregs.cregs.named.ldst) != 0)

#define SR_BL ((saved_state.asregs.cregs.named.sr & SR_MASK_BL) != 0)
#define SR_RB ((saved_state.asregs.cregs.named.sr & SR_MASK_RB) != 0)
#define SR_MD ((saved_state.asregs.cregs.named.sr & SR_MASK_MD) != 0)
#define SR_DMY ((saved_state.asregs.cregs.named.sr & SR_MASK_DMY) != 0)
#define SR_DMX ((saved_state.asregs.cregs.named.sr & SR_MASK_DMX) != 0)
#define SR_RC ((saved_state.asregs.cregs.named.sr & SR_MASK_RC))

/* Note: don't use this for privileged bits */
#define SET_SR_BIT(EXP, BIT) \
do { \
  if ((EXP) & 1) \
    saved_state.asregs.cregs.named.sr |= (BIT); \
  else \
    saved_state.asregs.cregs.named.sr &= ~(BIT); \
} while (0)

#define SET_SR_BO(EXP) SET_SR_BIT ((EXP), SR_MASK_BO)
#define SET_SR_CS(EXP) SET_SR_BIT ((EXP), SR_MASK_CS)
#define SET_BANKN(EXP) \
do { \
  IBNR = (IBNR & 0xfe00) | (EXP & 0x1f); \
} while (0)
#define SET_ME(EXP) \
do { \
  IBNR = (IBNR & 0x3fff) | ((EXP & 0x3) << 14); \
} while (0)
#define SET_SR_M(EXP) SET_SR_BIT ((EXP), SR_MASK_M)
#define SET_SR_Q(EXP) SET_SR_BIT ((EXP), SR_MASK_Q)
#define SET_SR_S(EXP) SET_SR_BIT ((EXP), SR_MASK_S)
#define SET_SR_T(EXP) SET_SR_BIT ((EXP), SR_MASK_T)
#define SET_LDST(EXP) (saved_state.asregs.cregs.named.ldst = ((EXP) != 0))

/* stc currently relies on being able to read SR without modifications.  */
#define GET_SR() (saved_state.asregs.cregs.named.sr - 0)

#define SET_SR(x) set_sr (x)

#define SET_RC(x) \
  (saved_state.asregs.cregs.named.sr \
   = saved_state.asregs.cregs.named.sr & 0xf000ffff | ((x) & 0xfff) << 16)

/* Manipulate FPSCR */

#define FPSCR_MASK_FR (1 << 21)
#define FPSCR_MASK_SZ (1 << 20)
#define FPSCR_MASK_PR (1 << 19)

#define FPSCR_FR  ((GET_FPSCR () & FPSCR_MASK_FR) != 0)
#define FPSCR_SZ  ((GET_FPSCR () & FPSCR_MASK_SZ) != 0)
#define FPSCR_PR  ((GET_FPSCR () & FPSCR_MASK_PR) != 0)

/* Count the number of arguments in an argv.  */
static int
count_argc (char **argv)
{
  int i;

  if (! argv)
    return -1;

  for (i = 0; argv[i] != NULL; ++i)
    continue;
  return i;
}

static void
set_fpscr1 (x)
	int x;
{
  int old = saved_state.asregs.sregs.named.fpscr;
  saved_state.asregs.sregs.named.fpscr = (x);
  /* swap the floating point register banks */
  if ((saved_state.asregs.sregs.named.fpscr ^ old) & FPSCR_MASK_FR
      /* Ignore bit change if simulating sh-dsp.  */
      && ! target_dsp)
    {
      union fregs_u tmpf = saved_state.asregs.fregs[0];
      saved_state.asregs.fregs[0] = saved_state.asregs.fregs[1];
      saved_state.asregs.fregs[1] = tmpf;
    }
}

/* sts relies on being able to read fpscr directly.  */
#define GET_FPSCR()  (saved_state.asregs.sregs.named.fpscr)
#define SET_FPSCR(x) \
do { \
  set_fpscr1 (x); \
} while (0)

#define DSR  (saved_state.asregs.sregs.named.fpscr)

int 
fail ()
{
  abort ();
}

#define RAISE_EXCEPTION(x) \
  (saved_state.asregs.exception = x, saved_state.asregs.insn_end = 0)

#define RAISE_EXCEPTION_IF_IN_DELAY_SLOT() \
  if (in_delay_slot) RAISE_EXCEPTION (SIGILL)

/* This function exists mainly for the purpose of setting a breakpoint to
   catch simulated bus errors when running the simulator under GDB.  */

void
raise_exception (x)
     int x;
{
  RAISE_EXCEPTION (x);
}

void
raise_buserror ()
{
  raise_exception (SIGBUS);
}

#define PROCESS_SPECIAL_ADDRESS(addr, endian, ptr, bits_written, \
				forbidden_addr_bits, data, retval) \
do { \
  if (addr & forbidden_addr_bits) \
    { \
      raise_buserror (); \
      return retval; \
    } \
  else if ((addr & saved_state.asregs.xyram_select) \
	   == saved_state.asregs.xram_start) \
    ptr = (void *) &saved_state.asregs.xmem_offset[addr ^ endian]; \
  else if ((addr & saved_state.asregs.xyram_select) \
	   == saved_state.asregs.yram_start) \
    ptr = (void *) &saved_state.asregs.ymem_offset[addr ^ endian]; \
  else if ((unsigned) addr >> 24 == 0xf0 \
	   && bits_written == 32 && (data & 1) == 0) \
    /* This invalidates (if not associative) or might invalidate \
       (if associative) an instruction cache line.  This is used for \
       trampolines.  Since we don't simulate the cache, this is a no-op \
       as far as the simulator is concerned.  */ \
    return retval; \
  else \
    { \
      if (bits_written == 8 && addr > 0x5000000) \
	IOMEM (addr, 1, data); \
      /* We can't do anything useful with the other stuff, so fail.  */ \
      raise_buserror (); \
      return retval; \
    } \
} while (0)

/* FIXME: sim_resume should be renamed to sim_engine_run.  sim_resume
   being implemented by ../common/sim_resume.c and the below should
   make a call to sim_engine_halt */

#define BUSERROR(addr, mask) ((addr) & (mask))

#define WRITE_BUSERROR(addr, mask, data, addr_func) \
  do \
    { \
      if (addr & mask) \
	{ \
	  addr_func (addr, data); \
	  return; \
	} \
    } \
  while (0)

#define READ_BUSERROR(addr, mask, addr_func) \
  do \
    { \
      if (addr & mask) \
	return addr_func (addr); \
    } \
  while (0)

/* Define this to enable register lifetime checking.
   The compiler generates "add #0,rn" insns to mark registers as invalid,
   the simulator uses this info to call fail if it finds a ref to an invalid
   register before a def

   #define PARANOID
*/

#ifdef PARANOID
int valid[16];
#define CREF(x)  if (!valid[x]) fail ();
#define CDEF(x)  valid[x] = 1;
#define UNDEF(x) valid[x] = 0;
#else
#define CREF(x)
#define CDEF(x)
#define UNDEF(x)
#endif

static void parse_and_set_memory_size PARAMS ((char *str));
static int IOMEM PARAMS ((int addr, int write, int value));
static struct loop_bounds get_loop_bounds PARAMS ((int, int, unsigned char *,
						   unsigned char *, int, int));
static void process_wlat_addr PARAMS ((int, int));
static void process_wwat_addr PARAMS ((int, int));
static void process_wbat_addr PARAMS ((int, int));
static int process_rlat_addr PARAMS ((int));
static int process_rwat_addr PARAMS ((int));
static int process_rbat_addr PARAMS ((int));
static void INLINE wlat_fast PARAMS ((unsigned char *, int, int, int));
static void INLINE wwat_fast PARAMS ((unsigned char *, int, int, int, int));
static void INLINE wbat_fast PARAMS ((unsigned char *, int, int, int));
static int INLINE rlat_fast PARAMS ((unsigned char *, int, int));
static int INLINE rwat_fast PARAMS ((unsigned char *, int, int, int));
static int INLINE rbat_fast PARAMS ((unsigned char *, int, int));

static host_callback *callback;



/* Floating point registers */

#define DR(n) (get_dr (n))
static double
get_dr (n)
     int n;
{
  n = (n & ~1);
  if (host_little_endian)
    {
      union
      {
	int i[2];
	double d;
      } dr;
      dr.i[1] = saved_state.asregs.fregs[0].i[n + 0];
      dr.i[0] = saved_state.asregs.fregs[0].i[n + 1];
      return dr.d;
    }
  else
    return (saved_state.asregs.fregs[0].d[n >> 1]);
}

#define SET_DR(n, EXP) set_dr ((n), (EXP))
static void
set_dr (n, exp)
     int n;
     double exp;
{
  n = (n & ~1);
  if (host_little_endian)
    {
      union
      {
	int i[2];
	double d;
      } dr;
      dr.d = exp;
      saved_state.asregs.fregs[0].i[n + 0] = dr.i[1];
      saved_state.asregs.fregs[0].i[n + 1] = dr.i[0];
    }
  else
    saved_state.asregs.fregs[0].d[n >> 1] = exp;
}

#define SET_FI(n,EXP) (saved_state.asregs.fregs[0].i[(n)] = (EXP))
#define FI(n) (saved_state.asregs.fregs[0].i[(n)])

#define FR(n) (saved_state.asregs.fregs[0].f[(n)])
#define SET_FR(n,EXP) (saved_state.asregs.fregs[0].f[(n)] = (EXP))

#define XD_TO_XF(n) ((((n) & 1) << 5) | ((n) & 0x1e))
#define XF(n) (saved_state.asregs.fregs[(n) >> 5].i[(n) & 0x1f])
#define SET_XF(n,EXP) (saved_state.asregs.fregs[(n) >> 5].i[(n) & 0x1f] = (EXP))

#define RS saved_state.asregs.cregs.named.rs
#define RE saved_state.asregs.cregs.named.re
#define MOD (saved_state.asregs.cregs.named.mod)
#define SET_MOD(i) \
(MOD = (i), \
 MOD_ME = (unsigned) MOD >> 16 | (SR_DMY ? ~0xffff : (SR_DMX ? 0 : 0x10000)), \
 MOD_DELTA = (MOD & 0xffff) - ((unsigned) MOD >> 16))

#define DSP_R(n) saved_state.asregs.sregs.i[(n)]
#define DSP_GRD(n) DSP_R ((n) + 8)
#define GET_DSP_GRD(n) ((n | 2) == 7 ? SEXT (DSP_GRD (n)) : SIGN32 (DSP_R (n)))
#define A1 DSP_R (5)
#define A0 DSP_R (7)
#define X0 DSP_R (8)
#define X1 DSP_R (9)
#define Y0 DSP_R (10)
#define Y1 DSP_R (11)
#define M0 DSP_R (12)
#define A1G DSP_R (13)
#define M1 DSP_R (14)
#define A0G DSP_R (15)
/* DSP_R (16) / DSP_GRD (16) are used as a fake destination for pcmp.  */
#define MOD_ME DSP_GRD (17)
#define MOD_DELTA DSP_GRD (18)

#define FP_OP(n, OP, m) \
{ \
  if (FPSCR_PR) \
    { \
      if (((n) & 1) || ((m) & 1)) \
	RAISE_EXCEPTION (SIGILL); \
      else \
	SET_DR (n, (DR (n) OP DR (m))); \
    } \
  else \
    SET_FR (n, (FR (n) OP FR (m))); \
} while (0)

#define FP_UNARY(n, OP) \
{ \
  if (FPSCR_PR) \
    { \
      if ((n) & 1) \
	RAISE_EXCEPTION (SIGILL); \
      else \
	SET_DR (n, (OP (DR (n)))); \
    } \
  else \
    SET_FR (n, (OP (FR (n)))); \
} while (0)

#define FP_CMP(n, OP, m) \
{ \
  if (FPSCR_PR) \
    { \
      if (((n) & 1) || ((m) & 1)) \
	RAISE_EXCEPTION (SIGILL); \
      else \
	SET_SR_T (DR (n) OP DR (m)); \
    } \
  else \
    SET_SR_T (FR (n) OP FR (m)); \
} while (0)

static void
set_sr (new_sr)
     int new_sr;
{
  /* do we need to swap banks */
  int old_gpr = SR_MD && SR_RB;
  int new_gpr = (new_sr & SR_MASK_MD) && (new_sr & SR_MASK_RB);
  if (old_gpr != new_gpr)
    {
      int i, tmp;
      for (i = 0; i < 8; i++)
	{
	  tmp = saved_state.asregs.cregs.named.bank[i];
	  saved_state.asregs.cregs.named.bank[i] = saved_state.asregs.regs[i];
	  saved_state.asregs.regs[i] = tmp;
	}
    }
  saved_state.asregs.cregs.named.sr = new_sr;
  SET_MOD (MOD);
}

static void INLINE 
wlat_fast (memory, x, value, maskl)
     unsigned char *memory;
{
  int v = value;
  unsigned int *p = (unsigned int *) (memory + x);
  WRITE_BUSERROR (x, maskl, v, process_wlat_addr);
  *p = v;
}

static void INLINE 
wwat_fast (memory, x, value, maskw, endianw)
     unsigned char *memory;
{
  int v = value;
  unsigned short *p = (unsigned short *) (memory + (x ^ endianw));
  WRITE_BUSERROR (x, maskw, v, process_wwat_addr);
  *p = v;
}

static void INLINE 
wbat_fast (memory, x, value, maskb)
     unsigned char *memory;
{
  unsigned char *p = memory + (x ^ endianb);
  WRITE_BUSERROR (x, maskb, value, process_wbat_addr);

  p[0] = value;
}

/* Read functions */

static int INLINE 
rlat_fast (memory, x, maskl)
     unsigned char *memory;
{
  unsigned int *p = (unsigned int *) (memory + x);
  READ_BUSERROR (x, maskl, process_rlat_addr);

  return *p;
}

static int INLINE 
rwat_fast (memory, x, maskw, endianw)
     unsigned char *memory;
     int x, maskw, endianw;
{
  unsigned short *p = (unsigned short *) (memory + (x ^ endianw));
  READ_BUSERROR (x, maskw, process_rwat_addr);

  return *p;
}

static int INLINE 
riat_fast (insn_ptr, endianw)
     unsigned char *insn_ptr;
{
  unsigned short *p = (unsigned short *) ((size_t) insn_ptr ^ endianw);

  return *p;
}

static int INLINE 
rbat_fast (memory, x, maskb)
     unsigned char *memory;
{
  unsigned char *p = memory + (x ^ endianb);
  READ_BUSERROR (x, maskb, process_rbat_addr);

  return *p;
}

#define RWAT(x) 	(rwat_fast (memory, x, maskw, endianw))
#define RLAT(x) 	(rlat_fast (memory, x, maskl))
#define RBAT(x)         (rbat_fast (memory, x, maskb))
#define RIAT(p)		(riat_fast ((p), endianw))
#define WWAT(x,v) 	(wwat_fast (memory, x, v, maskw, endianw))
#define WLAT(x,v) 	(wlat_fast (memory, x, v, maskl))
#define WBAT(x,v)       (wbat_fast (memory, x, v, maskb))

#define RUWAT(x)  (RWAT (x) & 0xffff)
#define RSWAT(x)  ((short) (RWAT (x)))
#define RSLAT(x)  ((long) (RLAT (x)))
#define RSBAT(x)  (SEXT (RBAT (x)))

#define RDAT(x, n) (do_rdat (memory, (x), (n), (maskl)))
static int
do_rdat (memory, x, n, maskl)
     char *memory;
     int x;
     int n;
     int maskl;
{
  int f0;
  int f1;
  int i = (n & 1);
  int j = (n & ~1);
  f0 = rlat_fast (memory, x + 0, maskl);
  f1 = rlat_fast (memory, x + 4, maskl);
  saved_state.asregs.fregs[i].i[(j + 0)] = f0;
  saved_state.asregs.fregs[i].i[(j + 1)] = f1;
  return 0;
}

#define WDAT(x, n) (do_wdat (memory, (x), (n), (maskl)))
static int
do_wdat (memory, x, n, maskl)
     char *memory;
     int x;
     int n;
     int maskl;
{
  int f0;
  int f1;
  int i = (n & 1);
  int j = (n & ~1);
  f0 = saved_state.asregs.fregs[i].i[(j + 0)];
  f1 = saved_state.asregs.fregs[i].i[(j + 1)];
  wlat_fast (memory, (x + 0), f0, maskl);
  wlat_fast (memory, (x + 4), f1, maskl);
  return 0;
}

static void
process_wlat_addr (addr, value)
     int addr;
     int value;
{
  unsigned int *ptr;

  PROCESS_SPECIAL_ADDRESS (addr, endianb, ptr, 32, 3, value, );
  *ptr = value;
}

static void
process_wwat_addr (addr, value)
     int addr;
     int value;
{
  unsigned short *ptr;

  PROCESS_SPECIAL_ADDRESS (addr, endianb, ptr, 16, 1, value, );
  *ptr = value;
}

static void
process_wbat_addr (addr, value)
     int addr;
     int value;
{
  unsigned char *ptr;

  PROCESS_SPECIAL_ADDRESS (addr, endianb, ptr, 8, 0, value, );
  *ptr = value;
}

static int
process_rlat_addr (addr)
     int addr;
{
  unsigned char *ptr;

  PROCESS_SPECIAL_ADDRESS (addr, endianb, ptr, -32, 3, -1, 0);
  return *ptr;
}

static int
process_rwat_addr (addr)
     int addr;
{
  unsigned char *ptr;

  PROCESS_SPECIAL_ADDRESS (addr, endianb, ptr, -16, 1, -1, 0);
  return *ptr;
}

static int
process_rbat_addr (addr)
     int addr;
{
  unsigned char *ptr;

  PROCESS_SPECIAL_ADDRESS (addr, endianb, ptr, -8, 0, -1, 0);
  return *ptr;
}

#define SEXT(x)     	(((x &  0xff) ^ (~0x7f))+0x80)
#define SEXT12(x)	(((x & 0xfff) ^ 0x800) - 0x800)
#define SEXTW(y)    	((int) ((short) y))
#if 0
#define SEXT32(x)	((int) ((x & 0xffffffff) ^ 0x80000000U) - 0x7fffffff - 1)
#else
#define SEXT32(x)	((int) (x))
#endif
#define SIGN32(x)	(SEXT32 (x) >> 31)

/* convert pointer from target to host value.  */
#define PT2H(x) ((x) + memory)
/* convert pointer from host to target value.  */
#define PH2T(x) ((x) - memory)

#define SKIP_INSN(p) ((p) += ((RIAT (p) & 0xfc00) == 0xf800 ? 4 : 2))

#define SET_NIP(x) nip = (x); CHECK_INSN_PTR (nip);

static int in_delay_slot = 0;
#define Delay_Slot(TEMPPC)  	iword = RIAT (TEMPPC); in_delay_slot = 1; goto top;

#define CHECK_INSN_PTR(p) \
do { \
  if (saved_state.asregs.exception || PH2T (p) & maskw) \
    saved_state.asregs.insn_end = 0; \
  else if (p < loop.end) \
    saved_state.asregs.insn_end = loop.end; \
  else \
    saved_state.asregs.insn_end = mem_end; \
} while (0)

#ifdef ACE_FAST

#define MA(n)
#define L(x)
#define TL(x)
#define TB(x)

#else

#define MA(n) \
  do { memstalls += ((((long) PC & 3) != 0) ? (n) : ((n) - 1)); } while (0)

#define L(x)   thislock = x;
#define TL(x)  if ((x) == prevlock) stalls++;
#define TB(x,y)  if ((x) == prevlock || (y) == prevlock) stalls++;

#endif

#if defined(__GO32__)
int sim_memory_size = 19;
#else
int sim_memory_size = 24;
#endif

static int sim_profile_size = 17;
static int nsamples;

#undef TB
#define TB(x,y)

#define SMR1 (0x05FFFEC8)	/* Channel 1  serial mode register */
#define BRR1 (0x05FFFEC9)	/* Channel 1  bit rate register */
#define SCR1 (0x05FFFECA)	/* Channel 1  serial control register */
#define TDR1 (0x05FFFECB)	/* Channel 1  transmit data register */
#define SSR1 (0x05FFFECC)	/* Channel 1  serial status register */
#define RDR1 (0x05FFFECD)	/* Channel 1  receive data register */

#define SCI_RDRF  	 0x40	/* Recieve data register full */
#define SCI_TDRE	0x80	/* Transmit data register empty */

static int
IOMEM (addr, write, value)
     int addr;
     int write;
     int value;
{
  if (write)
    {
      switch (addr)
	{
	case TDR1:
	  if (value != '\r')
	    {
	      putchar (value);
	      fflush (stdout);
	    }
	  break;
	}
    }
  else
    {
      switch (addr)
	{
	case RDR1:
	  return getchar ();
	}
    }
  return 0;
}

static int
get_now ()
{
  return time ((long *) 0);
}

static int
now_persec ()
{
  return 1;
}

static FILE *profile_file;

static unsigned INLINE
swap (n)
     unsigned n;
{
  if (endianb)
    n = (n << 24 | (n & 0xff00) << 8
	 | (n & 0xff0000) >> 8 | (n & 0xff000000) >> 24);
  return n;
}

static unsigned short INLINE
swap16 (n)
     unsigned short n;
{
  if (endianb)
    n = n << 8 | (n & 0xff00) >> 8;
  return n;
}

static void
swapout (n)
     int n;
{
  if (profile_file)
    {
      union { char b[4]; int n; } u;
      u.n = swap (n);
      fwrite (u.b, 4, 1, profile_file);
    }
}

static void
swapout16 (n)
     int n;
{
  union { char b[4]; int n; } u;
  u.n = swap16 (n);
  fwrite (u.b, 2, 1, profile_file);
}

/* Turn a pointer in a register into a pointer into real memory. */

static char *
ptr (x)
     int x;
{
  return (char *) (x + saved_state.asregs.memory);
}

/* STR points to a zero-terminated string in target byte order.  Return
   the number of bytes that need to be converted to host byte order in order
   to use this string as a zero-terminated string on the host.
   (Not counting the rounding up needed to operate on entire words.)  */
static int
strswaplen (str)
     int str;
{
  unsigned char *memory = saved_state.asregs.memory;
  int start, end;
  int endian = endianb;

  if (! endian)
    return 0;
  end = str;
  for (end = str; memory[end ^ endian]; end++) ;
  return end - str + 1;
}

static void
strnswap (str, len)
     int str;
     int len;
{
  int *start, *end;

  if (! endianb || ! len)
    return;
  start = (int *) ptr (str & ~3);
  end = (int *) ptr (str + len);
  do
    {
      int old = *start;
      *start = (old << 24 | (old & 0xff00) << 8
		| (old & 0xff0000) >> 8 | (old & 0xff000000) >> 24);
      start++;
    }
  while (start < end);
}

/* Simulate a monitor trap, put the result into r0 and errno into r1
   return offset by which to adjust pc.  */

static int
trap (i, regs, insn_ptr, memory, maskl, maskw, endianw)
     int i;
     int *regs;
     unsigned char *insn_ptr;
     unsigned char *memory;
{
  switch (i)
    {
    case 1:
      printf ("%c", regs[0]);
      break;
    case 2:
      raise_exception (SIGQUIT);
      break;
    case 3:			/* FIXME: for backwards compat, should be removed */
    case 33:
      {
	unsigned int countp = * (unsigned int *) (insn_ptr + 4);

	WLAT (countp, RLAT (countp) + 1);
	return 6;
      }
    case 34:
      {
	extern int errno;
	int perrno = errno;
	errno = 0;

	switch (regs[4])
	  {

#if !defined(__GO32__) && !defined(_WIN32)
	  case SYS_fork:
	    regs[0] = fork ();
	    break;
/* This would work only if endianness matched between host and target.
   Besides, it's quite dangerous.  */
#if 0
	  case SYS_execve:
	    regs[0] = execve (ptr (regs[5]), (char **) ptr (regs[6]), 
			      (char **) ptr (regs[7]));
	    break;
	  case SYS_execv:
	    regs[0] = execve (ptr (regs[5]), (char **) ptr (regs[6]), 0);
	    break;
#endif
	  case SYS_pipe:
	    {
	      regs[0] = (BUSERROR (regs[5], maskl)
			 ? -EINVAL
			 : pipe ((int *) ptr (regs[5])));
	    }
	    break;

	  case SYS_wait:
	    regs[0] = wait (ptr (regs[5]));
	    break;
#endif /* !defined(__GO32__) && !defined(_WIN32) */

	  case SYS_read:
	    strnswap (regs[6], regs[7]);
	    regs[0]
	      = callback->read (callback, regs[5], ptr (regs[6]), regs[7]);
	    strnswap (regs[6], regs[7]);
	    break;
	  case SYS_write:
	    strnswap (regs[6], regs[7]);
	    if (regs[5] == 1)
	      regs[0] = (int) callback->write_stdout (callback, 
						      ptr (regs[6]), regs[7]);
	    else
	      regs[0] = (int) callback->write (callback, regs[5], 
					       ptr (regs[6]), regs[7]);
	    strnswap (regs[6], regs[7]);
	    break;
	  case SYS_lseek:
	    regs[0] = callback->lseek (callback,regs[5], regs[6], regs[7]);
	    break;
	  case SYS_close:
	    regs[0] = callback->close (callback,regs[5]);
	    break;
	  case SYS_open:
	    {
	      int len = strswaplen (regs[5]);
	      strnswap (regs[5], len);
	      regs[0] = callback->open (callback, ptr (regs[5]), regs[6]);
	      strnswap (regs[5], len);
	      break;
	    }
	  case SYS_exit:
	    /* EXIT - caller can look in r5 to work out the reason */
	    raise_exception (SIGQUIT);
	    regs[0] = regs[5];
	    break;

	  case SYS_stat:	/* added at hmsi */
	    /* stat system call */
	    {
	      struct stat host_stat;
	      int buf;
	      int len = strswaplen (regs[5]);

	      strnswap (regs[5], len);
	      regs[0] = stat (ptr (regs[5]), &host_stat);
	      strnswap (regs[5], len);

	      buf = regs[6];

	      WWAT (buf, host_stat.st_dev);
	      buf += 2;
	      WWAT (buf, host_stat.st_ino);
	      buf += 2;
	      WLAT (buf, host_stat.st_mode);
	      buf += 4;
	      WWAT (buf, host_stat.st_nlink);
	      buf += 2;
	      WWAT (buf, host_stat.st_uid);
	      buf += 2;
	      WWAT (buf, host_stat.st_gid);
	      buf += 2;
	      WWAT (buf, host_stat.st_rdev);
	      buf += 2;
	      WLAT (buf, host_stat.st_size);
	      buf += 4;
	      WLAT (buf, host_stat.st_atime);
	      buf += 4;
	      WLAT (buf, 0);
	      buf += 4;
	      WLAT (buf, host_stat.st_mtime);
	      buf += 4;
	      WLAT (buf, 0);
	      buf += 4;
	      WLAT (buf, host_stat.st_ctime);
	      buf += 4;
	      WLAT (buf, 0);
	      buf += 4;
	      WLAT (buf, 0);
	      buf += 4;
	      WLAT (buf, 0);
	      buf += 4;
	    }
	    break;

#ifndef _WIN32
	  case SYS_chown:
	    {
	      int len = strswaplen (regs[5]);

	      strnswap (regs[5], len);
	      regs[0] = chown (ptr (regs[5]), regs[6], regs[7]);
	      strnswap (regs[5], len);
	      break;
	    }
#endif /* _WIN32 */
	  case SYS_chmod:
	    {
	      int len = strswaplen (regs[5]);

	      strnswap (regs[5], len);
	      regs[0] = chmod (ptr (regs[5]), regs[6]);
	      strnswap (regs[5], len);
	      break;
	    }
	  case SYS_utime:
	    {
	      /* Cast the second argument to void *, to avoid type mismatch
		 if a prototype is present.  */
	      int len = strswaplen (regs[5]);

	      strnswap (regs[5], len);
	      regs[0] = utime (ptr (regs[5]), (void *) ptr (regs[6]));
	      strnswap (regs[5], len);
	      break;
	    }
	  case SYS_argc:
	    regs[0] = count_argc (prog_argv);
	    break;
	  case SYS_argnlen:
	    if (regs[5] < count_argc (prog_argv))
	      regs[0] = strlen (prog_argv[regs[5]]);
	    else
	      regs[0] = -1;
	    break;
	  case SYS_argn:
	    if (regs[5] < count_argc (prog_argv))
	      {
		/* Include the termination byte.  */
		int i = strlen (prog_argv[regs[5]]) + 1;
		regs[0] = sim_write (0, regs[6], prog_argv[regs[5]], i);
	      }
	    else
	      regs[0] = -1;
	    break;
	  case SYS_time:
	    regs[0] = get_now ();
	    break;
	  case SYS_ftruncate:
	    regs[0] = callback->ftruncate (callback, regs[5], regs[6]);
	    break;
	  case SYS_truncate:
	    {
	      int len = strswaplen (regs[5]);
	      strnswap (regs[5], len);
	      regs[0] = callback->truncate (callback, ptr (regs[5]), regs[6]);
	      strnswap (regs[5], len);
	      break;
	    }
	  default:
	    regs[0] = -1;
	    break;
	  }
	regs[1] = callback->get_errno (callback);
	errno = perrno;
      }
      break;

    case 13:	/* Set IBNR */
      IBNR = regs[0] & 0xffff;
      break;
    case 14:	/* Set IBCR */
      IBCR = regs[0] & 0xffff;
      break;
    case 0xc3:
    case 255:
      raise_exception (SIGTRAP);
      if (i == 0xc3)
	return -2;
      break;
    }
  return 0;
}

void
control_c (sig, code, scp, addr)
     int sig;
     int code;
     char *scp;
     char *addr;
{
  raise_exception (SIGINT);
}

static int
div1 (R, iRn2, iRn1/*, T*/)
     int *R;
     int iRn1;
     int iRn2;
     /* int T;*/
{
  unsigned long tmp0;
  unsigned char old_q, tmp1;

  old_q = Q;
  SET_SR_Q ((unsigned char) ((0x80000000 & R[iRn1]) != 0));
  R[iRn1] <<= 1;
  R[iRn1] |= (unsigned long) T;

  switch (old_q)
    {
    case 0:
      switch (M)
	{
	case 0:
	  tmp0 = R[iRn1];
	  R[iRn1] -= R[iRn2];
	  tmp1 = (R[iRn1] > tmp0);
	  switch (Q)
	    {
	    case 0:
	      SET_SR_Q (tmp1);
	      break;
	    case 1:
	      SET_SR_Q ((unsigned char) (tmp1 == 0));
	      break;
	    }
	  break;
	case 1:
	  tmp0 = R[iRn1];
	  R[iRn1] += R[iRn2];
	  tmp1 = (R[iRn1] < tmp0);
	  switch (Q)
	    {
	    case 0:
	      SET_SR_Q ((unsigned char) (tmp1 == 0));
	      break;
	    case 1:
	      SET_SR_Q (tmp1);
	      break;
	    }
	  break;
	}
      break;
    case 1:
      switch (M)
	{
	case 0:
	  tmp0 = R[iRn1];
	  R[iRn1] += R[iRn2];
	  tmp1 = (R[iRn1] < tmp0);
	  switch (Q)
	    {
	    case 0:
	      SET_SR_Q (tmp1);
	      break;
	    case 1:
	      SET_SR_Q ((unsigned char) (tmp1 == 0));
	      break;
	    }
	  break;
	case 1:
	  tmp0 = R[iRn1];
	  R[iRn1] -= R[iRn2];
	  tmp1 = (R[iRn1] > tmp0);
	  switch (Q)
	    {
	    case 0:
	      SET_SR_Q ((unsigned char) (tmp1 == 0));
	      break;
	    case 1:
	      SET_SR_Q (tmp1);
	      break;
	    }
	  break;
	}
      break;
    }
  /*T = (Q == M);*/
  SET_SR_T (Q == M);
  /*return T;*/
}

static void
dmul (sign, rm, rn)
     int sign;
     unsigned int rm;
     unsigned int rn;
{
  unsigned long RnL, RnH;
  unsigned long RmL, RmH;
  unsigned long temp0, temp1, temp2, temp3;
  unsigned long Res2, Res1, Res0;

  RnL = rn & 0xffff;
  RnH = (rn >> 16) & 0xffff;
  RmL = rm & 0xffff;
  RmH = (rm >> 16) & 0xffff;
  temp0 = RmL * RnL;
  temp1 = RmH * RnL;
  temp2 = RmL * RnH;
  temp3 = RmH * RnH;
  Res2 = 0;
  Res1 = temp1 + temp2;
  if (Res1 < temp1)
    Res2 += 0x00010000;
  temp1 = (Res1 << 16) & 0xffff0000;
  Res0 = temp0 + temp1;
  if (Res0 < temp0)
    Res2 += 1;
  Res2 += ((Res1 >> 16) & 0xffff) + temp3;
  
  if (sign)
    {
      if (rn & 0x80000000)
	Res2 -= rm;
      if (rm & 0x80000000)
	Res2 -= rn;
    }

  MACH = Res2;
  MACL = Res0;
}

static void
macw (regs, memory, n, m, endianw)
     int *regs;
     unsigned char *memory;
     int m, n;
     int endianw;
{
  long tempm, tempn;
  long prod, macl, sum;

  tempm=RSWAT (regs[m]); regs[m]+=2;
  tempn=RSWAT (regs[n]); regs[n]+=2;

  macl = MACL;
  prod = (long) (short) tempm * (long) (short) tempn;
  sum = prod + macl;
  if (S)
    {
      if ((~(prod ^ macl) & (sum ^ prod)) < 0)
	{
	  /* MACH's lsb is a sticky overflow bit.  */
	  MACH |= 1;
	  /* Store the smallest negative number in MACL if prod is
	     negative, and the largest positive number otherwise.  */
	  sum = 0x7fffffff + (prod < 0);
	}
    }
  else
    {
      long mach;
      /* Add to MACH the sign extended product, and carry from low sum.  */
      mach = MACH + (-(prod < 0)) + ((unsigned long) sum < prod);
      /* Sign extend at 10:th bit in MACH.  */
      MACH = (mach & 0x1ff) | -(mach & 0x200);
    }
  MACL = sum;
}

static void
macl (regs, memory, n, m)
     int *regs;
     unsigned char *memory;
     int m, n;
{
  long tempm, tempn;
  long macl, mach;
  long long ans;
  long long mac64;

  tempm = RSLAT (regs[m]);
  regs[m] += 4;

  tempn = RSLAT (regs[n]);
  regs[n] += 4;

  mach = MACH;
  macl = MACL;

  mac64 = ((long long) macl & 0xffffffff) |
          ((long long) mach & 0xffffffff) << 32;

  ans = (long long) tempm * (long long) tempn; /* Multiply 32bit * 32bit */

  mac64 += ans; /* Accumulate 64bit + 64 bit */

  macl = (long) (mac64 & 0xffffffff);
  mach = (long) ((mac64 >> 32) & 0xffffffff);

  if (S)  /* Store only 48 bits of the result */
    {
      if (mach < 0) /* Result is negative */
        {
          mach = mach & 0x0000ffff; /* Mask higher 16 bits */
          mach |= 0xffff8000; /* Sign extend higher 16 bits */
        }
      else
        mach = mach & 0x00007fff; /* Postive Result */
    }

  MACL = macl;
  MACH = mach;
}

enum {
  B_BCLR = 0,
  B_BSET = 1,
  B_BST  = 2,
  B_BLD  = 3,
  B_BAND = 4,
  B_BOR  = 5,
  B_BXOR = 6,
  B_BLDNOT = 11,
  B_BANDNOT = 12,
  B_BORNOT = 13,
  
  MOVB_RM = 0x0000,
  MOVW_RM = 0x1000,
  MOVL_RM = 0x2000,
  FMOV_RM = 0x3000,
  MOVB_MR = 0x4000,
  MOVW_MR = 0x5000,
  MOVL_MR = 0x6000,
  FMOV_MR = 0x7000,
  MOVU_BMR = 0x8000,
  MOVU_WMR = 0x9000,
};

/* Do extended displacement move instructions.  */
void
do_long_move_insn (int op, int disp12, int m, int n, int *thatlock)
{
  int memstalls = 0;
  int thislock = *thatlock;
  int endianw = global_endianw;
  int *R = &(saved_state.asregs.regs[0]);
  unsigned char *memory = saved_state.asregs.memory;
  int maskb = ~((saved_state.asregs.msize - 1) & ~0);
  unsigned char *insn_ptr = PT2H (saved_state.asregs.pc);

  switch (op) {
  case MOVB_RM:		/* signed */
    WBAT (disp12 * 1 + R[n], R[m]); 
    break;
  case MOVW_RM:
    WWAT (disp12 * 2 + R[n], R[m]); 
    break;
  case MOVL_RM:
    WLAT (disp12 * 4 + R[n], R[m]); 
    break;
  case FMOV_RM:		/* floating point */
    if (FPSCR_SZ) 
      {
        MA (1);
        WDAT (R[n] + 8 * disp12, m);
      }
    else 
      WLAT (R[n] + 4 * disp12, FI (m));
    break;
  case MOVB_MR:
    R[n] = RSBAT (disp12 * 1 + R[m]);
    L (n); 
    break;
  case MOVW_MR:
    R[n] = RSWAT (disp12 * 2 + R[m]);
    L (n); 
    break;
  case MOVL_MR:
    R[n] = RLAT (disp12 * 4 + R[m]);
    L (n); 
    break;
  case FMOV_MR:
    if (FPSCR_SZ) {
      MA (1);
      RDAT (R[m] + 8 * disp12, n);
    }
    else 
      SET_FI (n, RLAT (R[m] + 4 * disp12));
    break;
  case MOVU_BMR:	/* unsigned */
    R[n] = RBAT (disp12 * 1 + R[m]);
    L (n);
    break;
  case MOVU_WMR:
    R[n] = RWAT (disp12 * 2 + R[m]);
    L (n);
    break;
  default:
    RAISE_EXCEPTION (SIGINT);
    exit (1);
  }
  saved_state.asregs.memstalls += memstalls;
  *thatlock = thislock;
}

/* Do binary logical bit-manipulation insns.  */
void
do_blog_insn (int imm, int addr, int binop, 
	      unsigned char *memory, int maskb)
{
  int oldval = RBAT (addr);

  switch (binop) {
  case B_BCLR:	/* bclr.b */
    WBAT (addr, oldval & ~imm);
    break;
  case B_BSET:	/* bset.b */
    WBAT (addr, oldval | imm);
    break;
  case B_BST:	/* bst.b */
    if (T)
      WBAT (addr, oldval | imm);
    else
      WBAT (addr, oldval & ~imm);
    break;
  case B_BLD:	/* bld.b */
    SET_SR_T ((oldval & imm) != 0);
    break;
  case B_BAND:	/* band.b */
    SET_SR_T (T && ((oldval & imm) != 0));
    break;
  case B_BOR:	/* bor.b */
    SET_SR_T (T || ((oldval & imm) != 0));
    break;
  case B_BXOR:	/* bxor.b */
    SET_SR_T (T ^ ((oldval & imm) != 0));
    break;
  case B_BLDNOT:	/* bldnot.b */
    SET_SR_T ((oldval & imm) == 0);
    break;
  case B_BANDNOT:	/* bandnot.b */
    SET_SR_T (T && ((oldval & imm) == 0));
    break;
  case B_BORNOT:	/* bornot.b */
    SET_SR_T (T || ((oldval & imm) == 0));
    break;
  }
}
float
fsca_s (int in, double (*f) (double))
{
  double rad = ldexp ((in & 0xffff), -15) * 3.141592653589793238462643383;
  double result = (*f) (rad);
  double error, upper, lower, frac;
  int exp;

  /* Search the value with the maximum error that is still within the
     architectural spec.  */
  error = ldexp (1., -21);
  /* compensate for calculation inaccuracy by reducing error.  */
  error = error - ldexp (1., -50);
  upper = result + error;
  frac = frexp (upper, &exp);
  upper = ldexp (floor (ldexp (frac, 24)), exp - 24);
  lower = result - error;
  frac = frexp (lower, &exp);
  lower = ldexp (ceil (ldexp (frac, 24)), exp - 24);
  return abs (upper - result) >= abs (lower - result) ? upper : lower;
}

float
fsrra_s (float in)
{
  double result = 1. / sqrt (in);
  int exp;
  double frac, upper, lower, error, eps;

  /* refine result */
  result = result - (result * result * in - 1) * 0.5 * result;
  /* Search the value with the maximum error that is still within the
     architectural spec.  */
  frac = frexp (result, &exp);
  frac = ldexp (frac, 24);
  error = 4.0; /* 1 << 24-1-21 */
  /* use eps to compensate for possible 1 ulp error in our 'exact' result.  */
  eps = ldexp (1., -29);
  upper = floor (frac + error - eps);
  if (upper > 16777216.)
    upper = floor ((frac + error - eps) * 0.5) * 2.;
  lower = ceil ((frac - error + eps) * 2) * .5;
  if (lower > 8388608.)
    lower = ceil (frac - error + eps);
  upper = ldexp (upper, exp - 24);
  lower = ldexp (lower, exp - 24);
  return upper - result >= result - lower ? upper : lower;
}


/* GET_LOOP_BOUNDS {EXTENDED}
   These two functions compute the actual starting and ending point
   of the repeat loop, based on the RS and RE registers (repeat start, 
   repeat stop).  The extended version is called for LDRC, and the
   regular version is called for SETRC.  The difference is that for
   LDRC, the loop start and end instructions are literally the ones
   pointed to by RS and RE -- for SETRC, they're not (see docs).  */

static struct loop_bounds
get_loop_bounds_ext (rs, re, memory, mem_end, maskw, endianw)
     int rs, re;
     unsigned char *memory, *mem_end;
     int maskw, endianw;
{
  struct loop_bounds loop;

  /* FIXME: should I verify RS < RE?  */
  loop.start = PT2H (RS);	/* FIXME not using the params?  */
  loop.end   = PT2H (RE & ~1);	/* Ignore bit 0 of RE.  */
  SKIP_INSN (loop.end);
  if (loop.end >= mem_end)
    loop.end = PT2H (0);
  return loop;
}

static struct loop_bounds
get_loop_bounds (rs, re, memory, mem_end, maskw, endianw)
     int rs, re;
     unsigned char *memory, *mem_end;
     int maskw, endianw;
{
  struct loop_bounds loop;

  if (SR_RC)
    {
      if (RS >= RE)
	{
	  loop.start = PT2H (RE - 4);
	  SKIP_INSN (loop.start);
	  loop.end = loop.start;
	  if (RS - RE == 0)
	    SKIP_INSN (loop.end);
	  if (RS - RE <= 2)
	    SKIP_INSN (loop.end);
	  SKIP_INSN (loop.end);
	}
      else
	{
	  loop.start = PT2H (RS);
	  loop.end = PT2H (RE - 4);
	  SKIP_INSN (loop.end);
	  SKIP_INSN (loop.end);
	  SKIP_INSN (loop.end);
	  SKIP_INSN (loop.end);
	}
      if (loop.end >= mem_end)
	loop.end = PT2H (0);
    }
  else
    loop.end = PT2H (0);

  return loop;
}

static void ppi_insn ();

#include "ppi.c"

/* Provide calloc / free versions that use an anonymous mmap.  This can
   significantly cut the start-up time when a large simulator memory is
   required, because pages are only zeroed on demand.  */
#ifdef MAP_ANONYMOUS
void *
mcalloc (size_t nmemb, size_t size)
{
  void *page;

  if (nmemb != 1)
    size *= nmemb;
  return mmap (0, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS,
	       -1, 0);
}

#define mfree(start,length) munmap ((start), (length))
#else
#define mcalloc calloc
#define mfree(start,length) free(start)
#endif

/* Set the memory size to the power of two provided. */

void
sim_size (power)
     int power;

{
  sim_memory_size = power;

  if (saved_state.asregs.memory)
    {
      mfree (saved_state.asregs.memory, saved_state.asregs.msize);
    }

  saved_state.asregs.msize = 1 << power;

  saved_state.asregs.memory =
    (unsigned char *) mcalloc (1, saved_state.asregs.msize);

  if (!saved_state.asregs.memory)
    {
      fprintf (stderr,
	       "Not enough VM for simulation of %d bytes of RAM\n",
	       saved_state.asregs.msize);

      saved_state.asregs.msize = 1;
      saved_state.asregs.memory = (unsigned char *) mcalloc (1, 1);
    }
}

static void
init_dsp (abfd)
     struct bfd *abfd;
{
  int was_dsp = target_dsp;
  unsigned long mach = bfd_get_mach (abfd);

  if (mach == bfd_mach_sh_dsp  || 
      mach == bfd_mach_sh4al_dsp ||
      mach == bfd_mach_sh3_dsp)
    {
      int ram_area_size, xram_start, yram_start;
      int new_select;

      target_dsp = 1;
      if (mach == bfd_mach_sh_dsp)
	{
	  /* SH7410 (orig. sh-sdp):
	     4KB each for X & Y memory;
	     On-chip X RAM 0x0800f000-0x0800ffff
	     On-chip Y RAM 0x0801f000-0x0801ffff  */
	  xram_start = 0x0800f000;
	  ram_area_size = 0x1000;
	}
      if (mach == bfd_mach_sh3_dsp || mach == bfd_mach_sh4al_dsp)
	{
	  /* SH7612:
	     8KB each for X & Y memory;
	     On-chip X RAM 0x1000e000-0x1000ffff
	     On-chip Y RAM 0x1001e000-0x1001ffff  */
	  xram_start = 0x1000e000;
	  ram_area_size = 0x2000;
	}
      yram_start = xram_start + 0x10000;
      new_select = ~(ram_area_size - 1);
      if (saved_state.asregs.xyram_select != new_select)
	{
	  saved_state.asregs.xyram_select = new_select;
	  free (saved_state.asregs.xmem);
	  free (saved_state.asregs.ymem);
	  saved_state.asregs.xmem = 
	    (unsigned char *) calloc (1, ram_area_size);
	  saved_state.asregs.ymem = 
	    (unsigned char *) calloc (1, ram_area_size);

	  /* Disable use of X / Y mmeory if not allocated.  */
	  if (! saved_state.asregs.xmem || ! saved_state.asregs.ymem)
	    {
	      saved_state.asregs.xyram_select = 0;
	      if (saved_state.asregs.xmem)
		free (saved_state.asregs.xmem);
	      if (saved_state.asregs.ymem)
		free (saved_state.asregs.ymem);
	    }
	}
      saved_state.asregs.xram_start = xram_start;
      saved_state.asregs.yram_start = yram_start;
      saved_state.asregs.xmem_offset = saved_state.asregs.xmem - xram_start;
      saved_state.asregs.ymem_offset = saved_state.asregs.ymem - yram_start;
    }
  else
    {
      target_dsp = 0;
      if (saved_state.asregs.xyram_select)
	{
	  saved_state.asregs.xyram_select = 0;
	  free (saved_state.asregs.xmem);
	  free (saved_state.asregs.ymem);
	}
    }

  if (! saved_state.asregs.xyram_select)
    {
      saved_state.asregs.xram_start = 1;
      saved_state.asregs.yram_start = 1;
    }

  if (saved_state.asregs.regstack == NULL)
    saved_state.asregs.regstack = 
      calloc (512, sizeof *saved_state.asregs.regstack);

  if (target_dsp != was_dsp)
    {
      int i, tmp;

      for (i = (sizeof sh_dsp_table / sizeof sh_dsp_table[0]) - 1; i >= 0; i--)
	{
	  tmp = sh_jump_table[0xf000 + i];
	  sh_jump_table[0xf000 + i] = sh_dsp_table[i];
	  sh_dsp_table[i] = tmp;
	}
    }
}

static void
init_pointers ()
{
  host_little_endian = 0;
  * (char*) &host_little_endian = 1;
  host_little_endian &= 1;

  if (saved_state.asregs.msize != 1 << sim_memory_size)
    {
      sim_size (sim_memory_size);
    }

  if (saved_state.asregs.profile && !profile_file)
    {
      profile_file = fopen ("gmon.out", "wb");
      /* Seek to where to put the call arc data */
      nsamples = (1 << sim_profile_size);

      fseek (profile_file, nsamples * 2 + 12, 0);

      if (!profile_file)
	{
	  fprintf (stderr, "Can't open gmon.out\n");
	}
      else
	{
	  saved_state.asregs.profile_hist =
	    (unsigned short *) calloc (64, (nsamples * sizeof (short) / 64));
	}
    }
}

static void
dump_profile ()
{
  unsigned int minpc;
  unsigned int maxpc;
  unsigned short *p;
  int i;

  p = saved_state.asregs.profile_hist;
  minpc = 0;
  maxpc = (1 << sim_profile_size);

  fseek (profile_file, 0L, 0);
  swapout (minpc << PROFILE_SHIFT);
  swapout (maxpc << PROFILE_SHIFT);
  swapout (nsamples * 2 + 12);
  for (i = 0; i < nsamples; i++)
    swapout16 (saved_state.asregs.profile_hist[i]);

}

static void
gotcall (from, to)
     int from;
     int to;
{
  swapout (from);
  swapout (to);
  swapout (1);
}

#define MMASKB ((saved_state.asregs.msize -1) & ~0)

int
sim_stop (sd)
     SIM_DESC sd;
{
  raise_exception (SIGINT);
  return 1;
}

void
sim_resume (sd, step, siggnal)
     SIM_DESC sd;
     int step, siggnal;
{
  register unsigned char *insn_ptr;
  unsigned char *mem_end;
  struct loop_bounds loop;
  register int cycles = 0;
  register int stalls = 0;
  register int memstalls = 0;
  register int insts = 0;
  register int prevlock;
#if 1
  int thislock;
#else
  register int thislock;
#endif
  register unsigned int doprofile;
  register int pollcount = 0;
  /* endianw is used for every insn fetch, hence it makes sense to cache it.
     endianb is used less often.  */
  register int endianw = global_endianw;

  int tick_start = get_now ();
  void (*prev) ();
  void (*prev_fpe) ();

  register unsigned short *jump_table = sh_jump_table;

  register int *R = &(saved_state.asregs.regs[0]);
  /*register int T;*/
#ifndef PR
  register int PR;
#endif

  register int maskb = ~((saved_state.asregs.msize - 1) & ~0);
  register int maskw = ~((saved_state.asregs.msize - 1) & ~1);
  register int maskl = ~((saved_state.asregs.msize - 1) & ~3);
  register unsigned char *memory;
  register unsigned int sbit = ((unsigned int) 1 << 31);

  prev = signal (SIGINT, control_c);
  prev_fpe = signal (SIGFPE, SIG_IGN);

  init_pointers ();
  saved_state.asregs.exception = 0;

  memory = saved_state.asregs.memory;
  mem_end = memory + saved_state.asregs.msize;

  if (RE & 1)
    loop = get_loop_bounds_ext (RS, RE, memory, mem_end, maskw, endianw);
  else
    loop = get_loop_bounds     (RS, RE, memory, mem_end, maskw, endianw);

  insn_ptr = PT2H (saved_state.asregs.pc);
  CHECK_INSN_PTR (insn_ptr);

#ifndef PR
  PR = saved_state.asregs.sregs.named.pr;
#endif
  /*T = GET_SR () & SR_MASK_T;*/
  prevlock = saved_state.asregs.prevlock;
  thislock = saved_state.asregs.thislock;
  doprofile = saved_state.asregs.profile;

  /* If profiling not enabled, disable it by asking for
     profiles infrequently. */
  if (doprofile == 0)
    doprofile = ~0;

 loop:
  if (step && insn_ptr < saved_state.asregs.insn_end)
    {
      if (saved_state.asregs.exception)
	/* This can happen if we've already been single-stepping and
	   encountered a loop end.  */
	saved_state.asregs.insn_end = insn_ptr;
      else
	{
	  saved_state.asregs.exception = SIGTRAP;
	  saved_state.asregs.insn_end = insn_ptr + 2;
	}
    }

  while (insn_ptr < saved_state.asregs.insn_end)
    {
      register unsigned int iword = RIAT (insn_ptr);
      register unsigned int ult;
      register unsigned char *nip = insn_ptr + 2;

#ifndef ACE_FAST
      insts++;
#endif
    top:
      if (tracing)
	fprintf (stderr, "PC: %08x, insn: %04x\n", PH2T (insn_ptr), iword);

#include "code.c"


      in_delay_slot = 0;
      insn_ptr = nip;

      if (--pollcount < 0)
	{
	  pollcount = POLL_QUIT_INTERVAL;
	  if ((*callback->poll_quit) != NULL
	      && (*callback->poll_quit) (callback))
	    {
	      sim_stop (sd);
	    }	    
	}

#ifndef ACE_FAST
      prevlock = thislock;
      thislock = 30;
      cycles++;

      if (cycles >= doprofile)
	{

	  saved_state.asregs.cycles += doprofile;
	  cycles -= doprofile;
	  if (saved_state.asregs.profile_hist)
	    {
	      int n = PH2T (insn_ptr) >> PROFILE_SHIFT;
	      if (n < nsamples)
		{
		  int i = saved_state.asregs.profile_hist[n];
		  if (i < 65000)
		    saved_state.asregs.profile_hist[n] = i + 1;
		}

	    }
	}
#endif
    }
  if (saved_state.asregs.insn_end == loop.end)
    {
      saved_state.asregs.cregs.named.sr += SR_RC_INCREMENT;
      if (SR_RC)
	insn_ptr = loop.start;
      else
	{
	  saved_state.asregs.insn_end = mem_end;
	  loop.end = PT2H (0);
	}
      goto loop;
    }

  if (saved_state.asregs.exception == SIGILL
      || saved_state.asregs.exception == SIGBUS)
    {
      insn_ptr -= 2;
    }
  /* Check for SIGBUS due to insn fetch.  */
  else if (! saved_state.asregs.exception)
    saved_state.asregs.exception = SIGBUS;

  saved_state.asregs.ticks += get_now () - tick_start;
  saved_state.asregs.cycles += cycles;
  saved_state.asregs.stalls += stalls;
  saved_state.asregs.memstalls += memstalls;
  saved_state.asregs.insts += insts;
  saved_state.asregs.pc = PH2T (insn_ptr);
#ifndef PR
  saved_state.asregs.sregs.named.pr = PR;
#endif

  saved_state.asregs.prevlock = prevlock;
  saved_state.asregs.thislock = thislock;

  if (profile_file)
    {
      dump_profile ();
    }

  signal (SIGFPE, prev_fpe);
  signal (SIGINT, prev);
}

int
sim_write (sd, addr, buffer, size)
     SIM_DESC sd;
     SIM_ADDR addr;
     const unsigned char *buffer;
     int size;
{
  int i;

  init_pointers ();

  for (i = 0; i < size; i++)
    {
      saved_state.asregs.memory[(MMASKB & (addr + i)) ^ endianb] = buffer[i];
    }
  return size;
}

int
sim_read (sd, addr, buffer, size)
     SIM_DESC sd;
     SIM_ADDR addr;
     unsigned char *buffer;
     int size;
{
  int i;

  init_pointers ();

  for (i = 0; i < size; i++)
    {
      buffer[i] = saved_state.asregs.memory[(MMASKB & (addr + i)) ^ endianb];
    }
  return size;
}

static int gdb_bank_number;
enum {
  REGBANK_MACH = 15,
  REGBANK_IVN  = 16,
  REGBANK_PR   = 17,
  REGBANK_GBR  = 18,
  REGBANK_MACL = 19
};

int
sim_store_register (sd, rn, memory, length)
     SIM_DESC sd;
     int rn;
     unsigned char *memory;
     int length;
{
  unsigned val;

  init_pointers ();
  val = swap (* (int *) memory);
  switch (rn)
    {
    case SIM_SH_R0_REGNUM: case SIM_SH_R1_REGNUM: case SIM_SH_R2_REGNUM:
    case SIM_SH_R3_REGNUM: case SIM_SH_R4_REGNUM: case SIM_SH_R5_REGNUM:
    case SIM_SH_R6_REGNUM: case SIM_SH_R7_REGNUM: case SIM_SH_R8_REGNUM:
    case SIM_SH_R9_REGNUM: case SIM_SH_R10_REGNUM: case SIM_SH_R11_REGNUM:
    case SIM_SH_R12_REGNUM: case SIM_SH_R13_REGNUM: case SIM_SH_R14_REGNUM:
    case SIM_SH_R15_REGNUM:
      saved_state.asregs.regs[rn] = val;
      break;
    case SIM_SH_PC_REGNUM:
      saved_state.asregs.pc = val;
      break;
    case SIM_SH_PR_REGNUM:
      PR = val;
      break;
    case SIM_SH_GBR_REGNUM:
      GBR = val;
      break;
    case SIM_SH_VBR_REGNUM:
      VBR = val;
      break;
    case SIM_SH_MACH_REGNUM:
      MACH = val;
      break;
    case SIM_SH_MACL_REGNUM:
      MACL = val;
      break;
    case SIM_SH_SR_REGNUM:
      SET_SR (val);
      break;
    case SIM_SH_FPUL_REGNUM:
      FPUL = val;
      break;
    case SIM_SH_FPSCR_REGNUM:
      SET_FPSCR (val);
      break;
    case SIM_SH_FR0_REGNUM: case SIM_SH_FR1_REGNUM: case SIM_SH_FR2_REGNUM:
    case SIM_SH_FR3_REGNUM: case SIM_SH_FR4_REGNUM: case SIM_SH_FR5_REGNUM:
    case SIM_SH_FR6_REGNUM: case SIM_SH_FR7_REGNUM: case SIM_SH_FR8_REGNUM:
    case SIM_SH_FR9_REGNUM: case SIM_SH_FR10_REGNUM: case SIM_SH_FR11_REGNUM:
    case SIM_SH_FR12_REGNUM: case SIM_SH_FR13_REGNUM: case SIM_SH_FR14_REGNUM:
    case SIM_SH_FR15_REGNUM:
      SET_FI (rn - SIM_SH_FR0_REGNUM, val);
      break;
    case SIM_SH_DSR_REGNUM:
      DSR = val;
      break;
    case SIM_SH_A0G_REGNUM:
      A0G = val;
      break;
    case SIM_SH_A0_REGNUM:
      A0 = val;
      break;
    case SIM_SH_A1G_REGNUM:
      A1G = val;
      break;
    case SIM_SH_A1_REGNUM:
      A1 = val;
      break;
    case SIM_SH_M0_REGNUM:
      M0 = val;
      break;
    case SIM_SH_M1_REGNUM:
      M1 = val;
      break;
    case SIM_SH_X0_REGNUM:
      X0 = val;
      break;
    case SIM_SH_X1_REGNUM:
      X1 = val;
      break;
    case SIM_SH_Y0_REGNUM:
      Y0 = val;
      break;
    case SIM_SH_Y1_REGNUM:
      Y1 = val;
      break;
    case SIM_SH_MOD_REGNUM:
      SET_MOD (val);
      break;
    case SIM_SH_RS_REGNUM:
      RS = val;
      break;
    case SIM_SH_RE_REGNUM:
      RE = val;
      break;
    case SIM_SH_SSR_REGNUM:
      SSR = val;
      break;
    case SIM_SH_SPC_REGNUM:
      SPC = val;
      break;
    /* The rn_bank idiosyncracies are not due to hardware differences, but to
       a weird aliasing naming scheme for sh3 / sh3e / sh4.  */
    case SIM_SH_R0_BANK0_REGNUM: case SIM_SH_R1_BANK0_REGNUM:
    case SIM_SH_R2_BANK0_REGNUM: case SIM_SH_R3_BANK0_REGNUM:
    case SIM_SH_R4_BANK0_REGNUM: case SIM_SH_R5_BANK0_REGNUM:
    case SIM_SH_R6_BANK0_REGNUM: case SIM_SH_R7_BANK0_REGNUM:
      if (saved_state.asregs.bfd_mach == bfd_mach_sh2a)
	{
	  rn -= SIM_SH_R0_BANK0_REGNUM;
	  saved_state.asregs.regstack[gdb_bank_number].regs[rn] = val;
	}
      else
      if (SR_MD && SR_RB)
	Rn_BANK (rn - SIM_SH_R0_BANK0_REGNUM) = val;
      else
	saved_state.asregs.regs[rn - SIM_SH_R0_BANK0_REGNUM] = val;
      break;
    case SIM_SH_R0_BANK1_REGNUM: case SIM_SH_R1_BANK1_REGNUM:
    case SIM_SH_R2_BANK1_REGNUM: case SIM_SH_R3_BANK1_REGNUM:
    case SIM_SH_R4_BANK1_REGNUM: case SIM_SH_R5_BANK1_REGNUM:
    case SIM_SH_R6_BANK1_REGNUM: case SIM_SH_R7_BANK1_REGNUM:
      if (saved_state.asregs.bfd_mach == bfd_mach_sh2a)
	{
	  rn -= SIM_SH_R0_BANK1_REGNUM;
	  saved_state.asregs.regstack[gdb_bank_number].regs[rn + 8] = val;
	}
      else
      if (SR_MD && SR_RB)
	saved_state.asregs.regs[rn - SIM_SH_R0_BANK1_REGNUM] = val;
      else
	Rn_BANK (rn - SIM_SH_R0_BANK1_REGNUM) = val;
      break;
    case SIM_SH_R0_BANK_REGNUM: case SIM_SH_R1_BANK_REGNUM:
    case SIM_SH_R2_BANK_REGNUM: case SIM_SH_R3_BANK_REGNUM:
    case SIM_SH_R4_BANK_REGNUM: case SIM_SH_R5_BANK_REGNUM:
    case SIM_SH_R6_BANK_REGNUM: case SIM_SH_R7_BANK_REGNUM:
      SET_Rn_BANK (rn - SIM_SH_R0_BANK_REGNUM, val);
      break;
    case SIM_SH_TBR_REGNUM:
      TBR = val;
      break;
    case SIM_SH_IBNR_REGNUM:
      IBNR = val;
      break;
    case SIM_SH_IBCR_REGNUM:
      IBCR = val;
      break;
    case SIM_SH_BANK_REGNUM:
      /* This is a pseudo-register maintained just for gdb.
	 It tells us what register bank gdb would like to read/write.  */
      gdb_bank_number = val;
      break;
    case SIM_SH_BANK_MACL_REGNUM:
      saved_state.asregs.regstack[gdb_bank_number].regs[REGBANK_MACL] = val;
      break;
    case SIM_SH_BANK_GBR_REGNUM:
      saved_state.asregs.regstack[gdb_bank_number].regs[REGBANK_GBR] = val;
      break;
    case SIM_SH_BANK_PR_REGNUM:
      saved_state.asregs.regstack[gdb_bank_number].regs[REGBANK_PR] = val;
      break;
    case SIM_SH_BANK_IVN_REGNUM:
      saved_state.asregs.regstack[gdb_bank_number].regs[REGBANK_IVN] = val;
      break;
    case SIM_SH_BANK_MACH_REGNUM:
      saved_state.asregs.regstack[gdb_bank_number].regs[REGBANK_MACH] = val;
      break;
    default:
      return 0;
    }
  return length;
}

int
sim_fetch_register (sd, rn, memory, length)
     SIM_DESC sd;
     int rn;
     unsigned char *memory;
     int length;
{
  int val;

  init_pointers ();
  switch (rn)
    {
    case SIM_SH_R0_REGNUM: case SIM_SH_R1_REGNUM: case SIM_SH_R2_REGNUM:
    case SIM_SH_R3_REGNUM: case SIM_SH_R4_REGNUM: case SIM_SH_R5_REGNUM:
    case SIM_SH_R6_REGNUM: case SIM_SH_R7_REGNUM: case SIM_SH_R8_REGNUM:
    case SIM_SH_R9_REGNUM: case SIM_SH_R10_REGNUM: case SIM_SH_R11_REGNUM:
    case SIM_SH_R12_REGNUM: case SIM_SH_R13_REGNUM: case SIM_SH_R14_REGNUM:
    case SIM_SH_R15_REGNUM:
      val = saved_state.asregs.regs[rn];
      break;
    case SIM_SH_PC_REGNUM:
      val = saved_state.asregs.pc;
      break;
    case SIM_SH_PR_REGNUM:
      val = PR;
      break;
    case SIM_SH_GBR_REGNUM:
      val = GBR;
      break;
    case SIM_SH_VBR_REGNUM:
      val = VBR;
      break;
    case SIM_SH_MACH_REGNUM:
      val = MACH;
      break;
    case SIM_SH_MACL_REGNUM:
      val = MACL;
      break;
    case SIM_SH_SR_REGNUM:
      val = GET_SR ();
      break;
    case SIM_SH_FPUL_REGNUM:
      val = FPUL;
      break;
    case SIM_SH_FPSCR_REGNUM:
      val = GET_FPSCR ();
      break;
    case SIM_SH_FR0_REGNUM: case SIM_SH_FR1_REGNUM: case SIM_SH_FR2_REGNUM:
    case SIM_SH_FR3_REGNUM: case SIM_SH_FR4_REGNUM: case SIM_SH_FR5_REGNUM:
    case SIM_SH_FR6_REGNUM: case SIM_SH_FR7_REGNUM: case SIM_SH_FR8_REGNUM:
    case SIM_SH_FR9_REGNUM: case SIM_SH_FR10_REGNUM: case SIM_SH_FR11_REGNUM:
    case SIM_SH_FR12_REGNUM: case SIM_SH_FR13_REGNUM: case SIM_SH_FR14_REGNUM:
    case SIM_SH_FR15_REGNUM:
      val = FI (rn - SIM_SH_FR0_REGNUM);
      break;
    case SIM_SH_DSR_REGNUM:
      val = DSR;
      break;
    case SIM_SH_A0G_REGNUM:
      val = SEXT (A0G);
      break;
    case SIM_SH_A0_REGNUM:
      val = A0;
      break;
    case SIM_SH_A1G_REGNUM:
      val = SEXT (A1G);
      break;
    case SIM_SH_A1_REGNUM:
      val = A1;
      break;
    case SIM_SH_M0_REGNUM:
      val = M0;
      break;
    case SIM_SH_M1_REGNUM:
      val = M1;
      break;
    case SIM_SH_X0_REGNUM:
      val = X0;
      break;
    case SIM_SH_X1_REGNUM:
      val = X1;
      break;
    case SIM_SH_Y0_REGNUM:
      val = Y0;
      break;
    case SIM_SH_Y1_REGNUM:
      val = Y1;
      break;
    case SIM_SH_MOD_REGNUM:
      val = MOD;
      break;
    case SIM_SH_RS_REGNUM:
      val = RS;
      break;
    case SIM_SH_RE_REGNUM:
      val = RE;
      break;
    case SIM_SH_SSR_REGNUM:
      val = SSR;
      break;
    case SIM_SH_SPC_REGNUM:
      val = SPC;
      break;
    /* The rn_bank idiosyncracies are not due to hardware differences, but to
       a weird aliasing naming scheme for sh3 / sh3e / sh4.  */
    case SIM_SH_R0_BANK0_REGNUM: case SIM_SH_R1_BANK0_REGNUM:
    case SIM_SH_R2_BANK0_REGNUM: case SIM_SH_R3_BANK0_REGNUM:
    case SIM_SH_R4_BANK0_REGNUM: case SIM_SH_R5_BANK0_REGNUM:
    case SIM_SH_R6_BANK0_REGNUM: case SIM_SH_R7_BANK0_REGNUM:
      if (saved_state.asregs.bfd_mach == bfd_mach_sh2a)
	{
	  rn -= SIM_SH_R0_BANK0_REGNUM;
	  val = saved_state.asregs.regstack[gdb_bank_number].regs[rn];
	}
      else
      val = (SR_MD && SR_RB
	     ? Rn_BANK (rn - SIM_SH_R0_BANK0_REGNUM)
	     : saved_state.asregs.regs[rn - SIM_SH_R0_BANK0_REGNUM]);
      break;
    case SIM_SH_R0_BANK1_REGNUM: case SIM_SH_R1_BANK1_REGNUM:
    case SIM_SH_R2_BANK1_REGNUM: case SIM_SH_R3_BANK1_REGNUM:
    case SIM_SH_R4_BANK1_REGNUM: case SIM_SH_R5_BANK1_REGNUM:
    case SIM_SH_R6_BANK1_REGNUM: case SIM_SH_R7_BANK1_REGNUM:
      if (saved_state.asregs.bfd_mach == bfd_mach_sh2a)
	{
	  rn -= SIM_SH_R0_BANK1_REGNUM;
	  val = saved_state.asregs.regstack[gdb_bank_number].regs[rn + 8];
	}
      else
      val = (! SR_MD || ! SR_RB
	     ? Rn_BANK (rn - SIM_SH_R0_BANK1_REGNUM)
	     : saved_state.asregs.regs[rn - SIM_SH_R0_BANK1_REGNUM]);
      break;
    case SIM_SH_R0_BANK_REGNUM: case SIM_SH_R1_BANK_REGNUM:
    case SIM_SH_R2_BANK_REGNUM: case SIM_SH_R3_BANK_REGNUM:
    case SIM_SH_R4_BANK_REGNUM: case SIM_SH_R5_BANK_REGNUM:
    case SIM_SH_R6_BANK_REGNUM: case SIM_SH_R7_BANK_REGNUM:
      val = Rn_BANK (rn - SIM_SH_R0_BANK_REGNUM);
      break;
    case SIM_SH_TBR_REGNUM:
      val = TBR;
      break;
    case SIM_SH_IBNR_REGNUM:
      val = IBNR;
      break;
    case SIM_SH_IBCR_REGNUM:
      val = IBCR;
      break;
    case SIM_SH_BANK_REGNUM:
      /* This is a pseudo-register maintained just for gdb.
	 It tells us what register bank gdb would like to read/write.  */
      val = gdb_bank_number;
      break;
    case SIM_SH_BANK_MACL_REGNUM:
      val = saved_state.asregs.regstack[gdb_bank_number].regs[REGBANK_MACL];
      break;
    case SIM_SH_BANK_GBR_REGNUM:
      val = saved_state.asregs.regstack[gdb_bank_number].regs[REGBANK_GBR];
      break;
    case SIM_SH_BANK_PR_REGNUM:
      val = saved_state.asregs.regstack[gdb_bank_number].regs[REGBANK_PR];
      break;
    case SIM_SH_BANK_IVN_REGNUM:
      val = saved_state.asregs.regstack[gdb_bank_number].regs[REGBANK_IVN];
      break;
    case SIM_SH_BANK_MACH_REGNUM:
      val = saved_state.asregs.regstack[gdb_bank_number].regs[REGBANK_MACH];
      break;
    default:
      return 0;
    }
  * (int *) memory = swap (val);
  return length;
}

int
sim_trace (sd)
     SIM_DESC sd;
{
  tracing = 1;
  sim_resume (sd, 0, 0);
  tracing = 0;
  return 1;
}

void
sim_stop_reason (sd, reason, sigrc)
     SIM_DESC sd;
     enum sim_stop *reason;
     int *sigrc;
{
  /* The SH simulator uses SIGQUIT to indicate that the program has
     exited, so we must check for it here and translate it to exit.  */
  if (saved_state.asregs.exception == SIGQUIT)
    {
      *reason = sim_exited;
      *sigrc = saved_state.asregs.regs[5];
    }
  else
    {
      *reason = sim_stopped;
      *sigrc = saved_state.asregs.exception;
    }
}

void
sim_info (sd, verbose)
     SIM_DESC sd;
     int verbose;
{
  double timetaken = 
    (double) saved_state.asregs.ticks / (double) now_persec ();
  double virttime = saved_state.asregs.cycles / 36.0e6;

  callback->printf_filtered (callback, "\n\n# instructions executed  %10d\n", 
			     saved_state.asregs.insts);
  callback->printf_filtered (callback, "# cycles                 %10d\n",
			     saved_state.asregs.cycles);
  callback->printf_filtered (callback, "# pipeline stalls        %10d\n",
			     saved_state.asregs.stalls);
  callback->printf_filtered (callback, "# misaligned load/store  %10d\n",
			     saved_state.asregs.memstalls);
  callback->printf_filtered (callback, "# real time taken        %10.4f\n",
			     timetaken);
  callback->printf_filtered (callback, "# virtual time taken     %10.4f\n",
			     virttime);
  callback->printf_filtered (callback, "# profiling size         %10d\n",
			     sim_profile_size);
  callback->printf_filtered (callback, "# profiling frequency    %10d\n",
			     saved_state.asregs.profile);
  callback->printf_filtered (callback, "# profile maxpc          %10x\n",
			     (1 << sim_profile_size) << PROFILE_SHIFT);

  if (timetaken != 0)
    {
      callback->printf_filtered (callback, "# cycles/second          %10d\n", 
				 (int) (saved_state.asregs.cycles / timetaken));
      callback->printf_filtered (callback, "# simulation ratio       %10.4f\n", 
				 virttime / timetaken);
    }
}

void
sim_set_profile (n)
     int n;
{
  saved_state.asregs.profile = n;
}

void
sim_set_profile_size (n)
     int n;
{
  sim_profile_size = n;
}

SIM_DESC
sim_open (kind, cb, abfd, argv)
     SIM_OPEN_KIND kind;
     host_callback *cb;
     struct bfd *abfd;
     char **argv;
{
  char **p;
  int endian_set = 0;
  int i;
  union
    {
      int i;
      short s[2];
      char c[4];
    }
  mem_word;

  sim_kind = kind;
  myname = argv[0];
  callback = cb;

  for (p = argv + 1; *p != NULL; ++p)
    {
      if (strcmp (*p, "-E") == 0)
	{
	  ++p;
	  if (*p == NULL)
	    {
	      /* FIXME: This doesn't use stderr, but then the rest of the
		 file doesn't either.  */
	      callback->printf_filtered (callback, "Missing argument to `-E'.\n");
	      return 0;
	    }
	  target_little_endian = strcmp (*p, "big") != 0;
          endian_set = 1;
	}
      else if (isdigit (**p))
	parse_and_set_memory_size (*p);
    }

  if (abfd != NULL && ! endian_set)
      target_little_endian = ! bfd_big_endian (abfd);

  if (abfd)
    init_dsp (abfd);

  for (i = 4; (i -= 2) >= 0; )
    mem_word.s[i >> 1] = i;
  global_endianw = mem_word.i >> (target_little_endian ? 0 : 16) & 0xffff;

  for (i = 4; --i >= 0; )
    mem_word.c[i] = i;
  endianb = mem_word.i >> (target_little_endian ? 0 : 24) & 0xff;

  /* fudge our descriptor for now */
  return (SIM_DESC) 1;
}

static void
parse_and_set_memory_size (str)
     char *str;
{
  int n;

  n = strtol (str, NULL, 10);
  if (n > 0 && n <= 24)
    sim_memory_size = n;
  else
    callback->printf_filtered (callback, "Bad memory size %d; must be 1 to 24, inclusive\n", n);
}

void
sim_close (sd, quitting)
     SIM_DESC sd;
     int quitting;
{
  /* nothing to do */
}

SIM_RC
sim_load (sd, prog, abfd, from_tty)
     SIM_DESC sd;
     char *prog;
     bfd *abfd;
     int from_tty;
{
  extern bfd *sim_load_file (); /* ??? Don't know where this should live.  */
  bfd *prog_bfd;

  prog_bfd = sim_load_file (sd, myname, callback, prog, abfd,
			    sim_kind == SIM_OPEN_DEBUG,
			    0, sim_write);

  /* Set the bfd machine type.  */
  if (prog_bfd)
    saved_state.asregs.bfd_mach = bfd_get_mach (prog_bfd);
  else if (abfd)
    saved_state.asregs.bfd_mach = bfd_get_mach (abfd);
  else
    saved_state.asregs.bfd_mach = 0;

  if (prog_bfd == NULL)
    return SIM_RC_FAIL;
  if (abfd == NULL)
    bfd_close (prog_bfd);
  return SIM_RC_OK;
}

SIM_RC
sim_create_inferior (sd, prog_bfd, argv, env)
     SIM_DESC sd;
     struct bfd *prog_bfd;
     char **argv;
     char **env;
{
  /* Clear the registers. */
  memset (&saved_state, 0,
	  (char*) &saved_state.asregs.end_of_registers - (char*) &saved_state);

  /* Set the PC.  */
  if (prog_bfd != NULL)
    saved_state.asregs.pc = bfd_get_start_address (prog_bfd);

  /* Set the bfd machine type.  */
  if (prog_bfd != NULL)
    saved_state.asregs.bfd_mach = bfd_get_mach (prog_bfd);

  /* Record the program's arguments. */
  prog_argv = argv;

  return SIM_RC_OK;
}

void
sim_do_command (sd, cmd)
     SIM_DESC sd;
     char *cmd;
{
  char *sms_cmd = "set-memory-size";
  int cmdsize;

  if (cmd == NULL || *cmd == '\0')
    {
      cmd = "help";
    }

  cmdsize = strlen (sms_cmd);
  if (strncmp (cmd, sms_cmd, cmdsize) == 0 
      && strchr (" \t", cmd[cmdsize]) != NULL)
    {
      parse_and_set_memory_size (cmd + cmdsize + 1);
    }
  else if (strcmp (cmd, "help") == 0)
    {
      (callback->printf_filtered) (callback, 
				   "List of SH simulator commands:\n\n");
      (callback->printf_filtered) (callback, "set-memory-size <n> -- Set the number of address bits to use\n");
      (callback->printf_filtered) (callback, "\n");
    }
  else
    {
      (callback->printf_filtered) (callback, "Error: \"%s\" is not a valid SH simulator command.\n", cmd);
    }
}

void
sim_set_callbacks (p)
     host_callback *p;
{
  callback = p;
}

char **
sim_complete_command (SIM_DESC sd, const char *text, const char *word)
{
  return NULL;
}
@


1.24
log
@Update sim_fetch_register, sim_store_register for sh and mn10300.
Fix compile warnings for sh built on 64-bit hosts.
@
text
@d2792 1
a2792 1
sim_complete_command (SIM_DESC sd, char *text, char *word)
@


1.23
log
@sim: add sim_complete_command stubs for non-common-using ports

For the ports that don't use the common/ subdir, we need to add stub funcs
to them to avoid build failures with gdb and command completion.  These do
not implement the actual completion functionality ... any port that wants
that can either convert to the common/ subdir, or fill out the function on
their own time.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d865 1
a865 1
  do { memstalls += ((((int) PC & 3) != 0) ? (n) : ((n) - 1)); } while (0)
d2359 1
a2359 1
  return -1;
d2534 1
a2534 1
  return -1;
@


1.22
log
@sim: constify sim_write source buffer (part 2)

As pointed out by Sandra Loosemore, a bunch of targets define sim_write
themselves instead of using the common/ code.  So constify them too.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d2790 6
@


1.21
log
@ 	* interp.c: Don't include sysdep.h.
 	Include stdio.h and errno.h.
 	Include string.h strings.h stdlib.h sys/stat.h if present.
@
text
@d84 1
a84 1
int sim_write (SIM_DESC sd, SIM_ADDR addr, unsigned char *buffer, int size);
d2144 1
a2144 1
     unsigned char *buffer;
@


1.20
log
@2008-02-04  Antony King  <antony.king@@st.com>

	* interp.c (macl): Fix non-portable implementation.
@
text
@d23 2
d39 16
a54 1
#include "sysdep.h"
@


1.19
log
@2005-11-10  Andrew Stubbs  <andrew.stubbs@@st.com>

	* interp.c (sim_memory_size): Use same amount of memory on Windows as
	elsewhere.
@
text
@d1432 3
a1434 8
  long prod, macl, mach, sum;
  long long ans,ansl,ansh,t;
  unsigned long long high,low,combine;
  union mac64
  {
    long m[2]; /* mach and macl*/
    long long m64; /* 64 bit MAC */
  }mac64;
d1445 2
a1446 2
  mac64.m[0] = macl;
  mac64.m[1] = mach;
d1450 1
a1450 1
  mac64.m64 += ans; /* Accumulate   64bit + 64 bit */
d1452 2
a1453 2
  macl = mac64.m[0];
  mach = mac64.m[1];
@


1.18
log
@	* interp.c (<sys/mman.h>): Include.
	(mcalloc): New function / macro.
	(mfree): New macro.
	(sim_size): Use mcalloc and mfree.
@
text
@d856 1
a856 1
#if defined(__GO32__) || defined(_WIN32)
@


1.17
log
@	* interp.c (strswaplen): Add one for '\0' delimiter.
@
text
@d27 9
d1727 21
a1754 2
  saved_state.asregs.msize = 1 << power;

d1759 1
a1759 1
      free (saved_state.asregs.memory);
d1762 2
d1765 1
a1765 1
    (unsigned char *) calloc (64, saved_state.asregs.msize / 64);
d1774 1
a1774 1
      saved_state.asregs.memory = (unsigned char *) calloc (1, 1);
@


1.16
log
@	* gencode.c (movua.l): Compensate for endianness.

	* interp.c (RAISE_EXCEPTION_IF_IN_DELAY_SLOT): New macro.
	(in_delay_slot): New flag variable.
	(Delay_Slot): Set in_delay_slot.
	(sim_resume): Reset in_delay_slot after leaving code switch.
	* gencode.c (op tab): Call RAISE_EXCEPTION_IF_IN_DELAY_SLOT for all
	instructions not allowed in delay slots.

	Commited by Corinna Vinschen <vinschen@@redhat.com>
	Introduce SH2a support.
	* interp.c: Change type of jump table to short.  Add various macros.
	(sim_load): Save the bfd machine code.
	(sim_create_inferior): Ditto.
	(union saved_state_type): Add tbr, ibnr and ibcr registers.
	Move bfd_mach to end of struct.  Add regstack pointer.
	(init_dsp): Don't swap contents of sh_dsp_table any more.  Instead
	use it directly in its own switch statement.  Allocate space for 512
	register banks.
	(do_long_move_insn): New function.
	(do_blog_insn): Ditto.
	(trap): Use trap #13 and trap #14 to set ibnr and ibcr.
	* gencode.c: Move movx/movy insns into separate switch statement.
	(op tab): Add sh2a insns.  Reject instructions that are disabled
	on that chip.
	(gensim_caselist): Generate default case here instead of in caller.
	(gensim): Generate two separate switch statements.  Call
	gensim_caselist once for each (for movsxy_tab and for tab).
	Add tokens for r15 and multiple regs.
	(conflict_warn, warn_conflicts): Add for debugging.
@
text
@d962 4
d978 1
a978 1
  return end - str;
@


1.15
log
@2004-02-12  Michael Snyder  <msnyder@@redhat.com>

	* gencode.c (table): Change from char to short.
	(dumptable): Change generated table from char to short.
	* interp.c (sh_jump_table, sh_dsp_table, ppi_table): char to short.
	(init_dsp): Compute size of sh_dsp_table.
	(sim_resume): Change jump_table from char to short.
@
text
@d68 5
d131 3
d163 2
d188 1
d205 5
d232 2
d248 2
d272 10
d356 3
d816 2
a817 1
#define Delay_Slot(TEMPPC)  	iword = RIAT (TEMPPC); goto top;
d1218 6
d1462 35
d1498 54
a1551 7
/* GET_LOOP_BOUNDS {EXTENDED}
   These two functions compute the actual starting and ending point
   of the repeat loop, based on the RS and RE registers (repeat start, 
   repeat stop).  The extended version is called for LDRC, and the
   regular version is called for SETRC.  The difference is that for
   LDRC, the loop start and end instructions are literally the ones
   pointed to by RS and RE -- for SETRC, they're not (see docs).  */
d1553 4
a1556 5
static struct loop_bounds
get_loop_bounds_ext (rs, re, memory, mem_end, maskw, endianw)
     int rs, re;
     unsigned char *memory, *mem_end;
     int maskw, endianw;
d1558 1
a1558 1
  struct loop_bounds loop;
d1560 35
a1594 7
  /* FIXME: should I verify RS < RE?  */
  loop.start = PT2H (RS);	/* FIXME not using the params?  */
  loop.end   = PT2H (RE & ~1);	/* Ignore bit 0 of RE.  */
  SKIP_INSN (loop.end);
  if (loop.end >= mem_end)
    loop.end = PT2H (0);
  return loop;
a1595 1

d1645 26
d1784 4
a1787 2
	  saved_state.asregs.xmem = (unsigned char *) calloc (1, ram_area_size);
	  saved_state.asregs.ymem = (unsigned char *) calloc (1, ram_area_size);
d1821 4
d1924 3
d1928 1
d2007 2
d2013 1
d2130 9
d2249 6
d2264 6
d2281 29
d2425 6
d2439 6
d2455 29
d2495 4
a2498 1
  return 0;
d2665 9
d2696 4
@


1.15.4.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a67 5
typedef struct
{
  int regs[20];
} regstacktype;

a125 3
	    int tbr;
	    int ibcr;		/* sh2a bank control register */
	    int ibnr;		/* sh2a bank number register */
a154 2
    unsigned long bfd_mach;
    regstacktype *regstack;
a177 1
static int   tracing = 0;
a193 5
#define TBR 	saved_state.asregs.cregs.named.tbr
#define IBCR	saved_state.asregs.cregs.named.ibcr
#define IBNR	saved_state.asregs.cregs.named.ibnr
#define BANKN	(saved_state.asregs.cregs.named.ibnr & 0x1ff)
#define ME	((saved_state.asregs.cregs.named.ibnr >> 14) & 0x3)
a215 2
#define SR_MASK_BO  (1 << 14)
#define SR_MASK_CS  (1 << 13)
a229 2
#define BO	((saved_state.asregs.cregs.named.sr & SR_MASK_BO) != 0)
#define CS	((saved_state.asregs.cregs.named.sr & SR_MASK_CS) != 0)
a251 10
#define SET_SR_BO(EXP) SET_SR_BIT ((EXP), SR_MASK_BO)
#define SET_SR_CS(EXP) SET_SR_BIT ((EXP), SR_MASK_CS)
#define SET_BANKN(EXP) \
do { \
  IBNR = (IBNR & 0xfe00) | (EXP & 0x1f); \
} while (0)
#define SET_ME(EXP) \
do { \
  IBNR = (IBNR & 0x3fff) | ((EXP & 0x3) << 14); \
} while (0)
a325 3
#define RAISE_EXCEPTION_IF_IN_DELAY_SLOT() \
  if (in_delay_slot) RAISE_EXCEPTION (SIGILL)

d783 1
a783 2
static int in_delay_slot = 0;
#define Delay_Slot(TEMPPC)  	iword = RIAT (TEMPPC); in_delay_slot = 1; goto top;
a1183 6
    case 13:	/* Set IBNR */
      IBNR = regs[0] & 0xffff;
      break;
    case 14:	/* Set IBCR */
      IBCR = regs[0] & 0xffff;
      break;
a1421 23
enum {
  B_BCLR = 0,
  B_BSET = 1,
  B_BST  = 2,
  B_BLD  = 3,
  B_BAND = 4,
  B_BOR  = 5,
  B_BXOR = 6,
  B_BLDNOT = 11,
  B_BANDNOT = 12,
  B_BORNOT = 13,
  
  MOVB_RM = 0x0000,
  MOVW_RM = 0x1000,
  MOVL_RM = 0x2000,
  FMOV_RM = 0x3000,
  MOVB_MR = 0x4000,
  MOVW_MR = 0x5000,
  MOVL_MR = 0x6000,
  FMOV_MR = 0x7000,
  MOVU_BMR = 0x8000,
  MOVU_WMR = 0x9000,
};
d1423 13
a1435 3
/* Do extended displacement move instructions.  */
void
do_long_move_insn (int op, int disp12, int m, int n, int *thatlock)
d1437 1
a1437 7
  int memstalls = 0;
  int thislock = *thatlock;
  int endianw = global_endianw;
  int *R = &(saved_state.asregs.regs[0]);
  unsigned char *memory = saved_state.asregs.memory;
  int maskb = ~((saved_state.asregs.msize - 1) & ~0);
  unsigned char *insn_ptr = PT2H (saved_state.asregs.pc);
d1439 7
a1445 53
  switch (op) {
  case MOVB_RM:		/* signed */
    WBAT (disp12 * 1 + R[n], R[m]); 
    break;
  case MOVW_RM:
    WWAT (disp12 * 2 + R[n], R[m]); 
    break;
  case MOVL_RM:
    WLAT (disp12 * 4 + R[n], R[m]); 
    break;
  case FMOV_RM:		/* floating point */
    if (FPSCR_SZ) 
      {
        MA (1);
        WDAT (R[n] + 8 * disp12, m);
      }
    else 
      WLAT (R[n] + 4 * disp12, FI (m));
    break;
  case MOVB_MR:
    R[n] = RSBAT (disp12 * 1 + R[m]);
    L (n); 
    break;
  case MOVW_MR:
    R[n] = RSWAT (disp12 * 2 + R[m]);
    L (n); 
    break;
  case MOVL_MR:
    R[n] = RLAT (disp12 * 4 + R[m]);
    L (n); 
    break;
  case FMOV_MR:
    if (FPSCR_SZ) {
      MA (1);
      RDAT (R[m] + 8 * disp12, n);
    }
    else 
      SET_FI (n, RLAT (R[m] + 4 * disp12));
    break;
  case MOVU_BMR:	/* unsigned */
    R[n] = RBAT (disp12 * 1 + R[m]);
    L (n);
    break;
  case MOVU_WMR:
    R[n] = RWAT (disp12 * 2 + R[m]);
    L (n);
    break;
  default:
    RAISE_EXCEPTION (SIGINT);
    exit (1);
  }
  saved_state.asregs.memstalls += memstalls;
  *thatlock = thislock;
a1447 43
/* Do binary logical bit-manipulation insns.  */
void
do_blog_insn (int imm, int addr, int binop, 
	      unsigned char *memory, int maskb)
{
  int oldval = RBAT (addr);

  switch (binop) {
  case B_BCLR:	/* bclr.b */
    WBAT (addr, oldval & ~imm);
    break;
  case B_BSET:	/* bset.b */
    WBAT (addr, oldval | imm);
    break;
  case B_BST:	/* bst.b */
    if (T)
      WBAT (addr, oldval | imm);
    else
      WBAT (addr, oldval & ~imm);
    break;
  case B_BLD:	/* bld.b */
    SET_SR_T ((oldval & imm) != 0);
    break;
  case B_BAND:	/* band.b */
    SET_SR_T (T && ((oldval & imm) != 0));
    break;
  case B_BOR:	/* bor.b */
    SET_SR_T (T || ((oldval & imm) != 0));
    break;
  case B_BXOR:	/* bxor.b */
    SET_SR_T (T ^ ((oldval & imm) != 0));
    break;
  case B_BLDNOT:	/* bldnot.b */
    SET_SR_T ((oldval & imm) == 0);
    break;
  case B_BANDNOT:	/* bandnot.b */
    SET_SR_T (T && ((oldval & imm) == 0));
    break;
  case B_BORNOT:	/* bornot.b */
    SET_SR_T (T || ((oldval & imm) == 0));
    break;
  }
}
a1496 26

/* GET_LOOP_BOUNDS {EXTENDED}
   These two functions compute the actual starting and ending point
   of the repeat loop, based on the RS and RE registers (repeat start, 
   repeat stop).  The extended version is called for LDRC, and the
   regular version is called for SETRC.  The difference is that for
   LDRC, the loop start and end instructions are literally the ones
   pointed to by RS and RE -- for SETRC, they're not (see docs).  */

static struct loop_bounds
get_loop_bounds_ext (rs, re, memory, mem_end, maskw, endianw)
     int rs, re;
     unsigned char *memory, *mem_end;
     int maskw, endianw;
{
  struct loop_bounds loop;

  /* FIXME: should I verify RS < RE?  */
  loop.start = PT2H (RS);	/* FIXME not using the params?  */
  loop.end   = PT2H (RE & ~1);	/* Ignore bit 0 of RE.  */
  SKIP_INSN (loop.end);
  if (loop.end >= mem_end)
    loop.end = PT2H (0);
  return loop;
}

d1610 2
a1611 4
	  saved_state.asregs.xmem = 
	    (unsigned char *) calloc (1, ram_area_size);
	  saved_state.asregs.ymem = 
	    (unsigned char *) calloc (1, ram_area_size);
a1644 4
  if (saved_state.asregs.regstack == NULL)
    saved_state.asregs.regstack = 
      calloc (512, sizeof *saved_state.asregs.regstack);

a1743 3
#if 1
  int thislock;
#else
a1744 1
#endif
a1822 2
      if (tracing)
	fprintf (stderr, "PC: %08x, insn: %04x\n", PH2T (insn_ptr), iword);
a1826 1
      in_delay_slot = 0;
a1942 9
static int gdb_bank_number;
enum {
  REGBANK_MACH = 15,
  REGBANK_IVN  = 16,
  REGBANK_PR   = 17,
  REGBANK_GBR  = 18,
  REGBANK_MACL = 19
};

a2052 6
      if (saved_state.asregs.bfd_mach == bfd_mach_sh2a)
	{
	  rn -= SIM_SH_R0_BANK0_REGNUM;
	  saved_state.asregs.regstack[gdb_bank_number].regs[rn] = val;
	}
      else
a2061 6
      if (saved_state.asregs.bfd_mach == bfd_mach_sh2a)
	{
	  rn -= SIM_SH_R0_BANK1_REGNUM;
	  saved_state.asregs.regstack[gdb_bank_number].regs[rn + 8] = val;
	}
      else
a2072 29
    case SIM_SH_TBR_REGNUM:
      TBR = val;
      break;
    case SIM_SH_IBNR_REGNUM:
      IBNR = val;
      break;
    case SIM_SH_IBCR_REGNUM:
      IBCR = val;
      break;
    case SIM_SH_BANK_REGNUM:
      /* This is a pseudo-register maintained just for gdb.
	 It tells us what register bank gdb would like to read/write.  */
      gdb_bank_number = val;
      break;
    case SIM_SH_BANK_MACL_REGNUM:
      saved_state.asregs.regstack[gdb_bank_number].regs[REGBANK_MACL] = val;
      break;
    case SIM_SH_BANK_GBR_REGNUM:
      saved_state.asregs.regstack[gdb_bank_number].regs[REGBANK_GBR] = val;
      break;
    case SIM_SH_BANK_PR_REGNUM:
      saved_state.asregs.regstack[gdb_bank_number].regs[REGBANK_PR] = val;
      break;
    case SIM_SH_BANK_IVN_REGNUM:
      saved_state.asregs.regstack[gdb_bank_number].regs[REGBANK_IVN] = val;
      break;
    case SIM_SH_BANK_MACH_REGNUM:
      saved_state.asregs.regstack[gdb_bank_number].regs[REGBANK_MACH] = val;
      break;
a2187 6
      if (saved_state.asregs.bfd_mach == bfd_mach_sh2a)
	{
	  rn -= SIM_SH_R0_BANK0_REGNUM;
	  val = saved_state.asregs.regstack[gdb_bank_number].regs[rn];
	}
      else
a2195 6
      if (saved_state.asregs.bfd_mach == bfd_mach_sh2a)
	{
	  rn -= SIM_SH_R0_BANK1_REGNUM;
	  val = saved_state.asregs.regstack[gdb_bank_number].regs[rn + 8];
	}
      else
a2205 29
    case SIM_SH_TBR_REGNUM:
      val = TBR;
      break;
    case SIM_SH_IBNR_REGNUM:
      val = IBNR;
      break;
    case SIM_SH_IBCR_REGNUM:
      val = IBCR;
      break;
    case SIM_SH_BANK_REGNUM:
      /* This is a pseudo-register maintained just for gdb.
	 It tells us what register bank gdb would like to read/write.  */
      val = gdb_bank_number;
      break;
    case SIM_SH_BANK_MACL_REGNUM:
      val = saved_state.asregs.regstack[gdb_bank_number].regs[REGBANK_MACL];
      break;
    case SIM_SH_BANK_GBR_REGNUM:
      val = saved_state.asregs.regstack[gdb_bank_number].regs[REGBANK_GBR];
      break;
    case SIM_SH_BANK_PR_REGNUM:
      val = saved_state.asregs.regstack[gdb_bank_number].regs[REGBANK_PR];
      break;
    case SIM_SH_BANK_IVN_REGNUM:
      val = saved_state.asregs.regstack[gdb_bank_number].regs[REGBANK_IVN];
      break;
    case SIM_SH_BANK_MACH_REGNUM:
      val = saved_state.asregs.regstack[gdb_bank_number].regs[REGBANK_MACH];
      break;
d2217 1
a2217 4
  tracing = 1;
  sim_resume (sd, 0, 0);
  tracing = 0;
  return 1;
a2383 9

  /* Set the bfd machine type.  */
  if (prog_bfd)
    saved_state.asregs.bfd_mach = bfd_get_mach (prog_bfd);
  else if (abfd)
    saved_state.asregs.bfd_mach = bfd_get_mach (abfd);
  else
    saved_state.asregs.bfd_mach = 0;

a2405 4
  /* Set the bfd machine type.  */
  if (prog_bfd != NULL)
    saved_state.asregs.bfd_mach = bfd_get_mach (prog_bfd);

@


1.14
log
@2004-01-07  Michael Snyder  <msnyder@@redhat.com>

        * gencode.c: Whitespace	cleanup.
        * interp.c: Ditto.
@
text
@d56 1
a56 1
extern unsigned char sh_jump_table[], sh_dsp_table[0x1000], ppi_table[];
d1649 1
a1649 1
      for (i = sizeof sh_dsp_table - 1; i >= 0; i--)
d1755 1
a1755 1
  register unsigned char *jump_table = sh_jump_table;
@


1.13
log
@2004-01-07  Michael Snyder  <msnyder@@redhat.com>

        * gencode.c: Replace 'Hitachi' with 'Renesas'.
        (op tab): Add new instructions for sh4a, DBR, SBR.
        (expand_opcode): Add handling for new movxy combinations.
        (gensym_caselist): Ditto.
        (expand_ppi_movxy): Remove movx/movy expansions,
        now handled in expand_opcode.
        (gensym): Add some helpful macros.
        (expand_ppi_code): Flatten loop for simplicity, tweak for 12-bit
        instead of 8-bit table (some insns are ambiguous to 8 bits).
	(ppi_gensim, main): Generate 12-bit instead of 8-bit ppi table.

	* interp.c: Replace 'Hitachi' with 'Renesas'.
        (union saved_state_type): Add dbr, sgr, ldst.
        (get_loop_bounds_ext): New function.
        (init_dsp): Add bfd_mach_sh4al_dsp.
	(sim_resume): Handle extended loop bounds.
@
text
@d186 3
a188 3
#define UR0 	(unsigned int)(saved_state.asregs.regs[0])
#define UR 	(unsigned int)R
#define UR 	(unsigned int)R
d273 3
a275 3
#define FPSCR_FR  ((GET_FPSCR() & FPSCR_MASK_FR) != 0)
#define FPSCR_SZ  ((GET_FPSCR() & FPSCR_MASK_SZ) != 0)
#define FPSCR_PR  ((GET_FPSCR() & FPSCR_MASK_PR) != 0)
d333 1
a333 1
  RAISE_EXCEPTION(x);
d408 1
a408 1
#define CREF(x)  if(!valid[x]) fail();
d419 8
a426 8
static struct loop_bounds get_loop_bounds PARAMS((int, int, unsigned char *,
						  unsigned char *, int, int));
static void process_wlat_addr PARAMS((int, int));
static void process_wwat_addr PARAMS((int, int));
static void process_wbat_addr PARAMS((int, int));
static int process_rlat_addr PARAMS((int));
static int process_rwat_addr PARAMS((int));
static int process_rbat_addr PARAMS((int));
d525 1
a525 1
	SET_DR(n, (DR(n) OP DR(m))); \
d528 1
a528 1
    SET_FR(n, (FR(n) OP FR(m))); \
d538 1
a538 1
	SET_DR(n, (OP (DR(n)))); \
d541 1
a541 1
    SET_FR(n, (OP (FR(n)))); \
d551 1
a551 1
	SET_SR_T (DR(n) OP DR(m)); \
d554 1
a554 1
    SET_SR_T (FR(n) OP FR(m)); \
d583 1
a583 1
  unsigned int *p = (unsigned int *)(memory + x);
d593 1
a593 1
  unsigned short *p = (unsigned short *)(memory + (x ^ endianw));
d614 1
a614 1
  unsigned int *p = (unsigned int *)(memory + x);
d625 1
a625 1
  unsigned short *p = (unsigned short *)(memory + (x ^ endianw));
d635 1
a635 1
  unsigned short *p = (unsigned short *)((size_t) insn_ptr ^ endianw);
d658 4
a661 4
#define RUWAT(x)  (RWAT(x) & 0xffff)
#define RSWAT(x)  ((short)(RWAT(x)))
#define RSLAT(x)  ((long)(RLAT(x)))
#define RSBAT(x)  (SEXT(RBAT(x)))
d766 1
a766 1
#define SEXTW(y)    	((int)((short)y))
d768 1
a768 1
#define SEXT32(x)	((int)((x & 0xffffffff) ^ 0x80000000U) - 0x7fffffff - 1)
d770 1
a770 1
#define SEXT32(x)	((int)(x))
d809 1
a809 1
#define TB(x,y)  if ((x) == prevlock || (y)==prevlock) stalls++;
d1007 2
a1008 1
	    regs[0] = execve (ptr (regs[5]), (char **)ptr (regs[6]), (char **)ptr (regs[7]));
d1011 1
a1011 1
	    regs[0] = execve (ptr (regs[5]),(char **) ptr (regs[6]), 0);
d1036 2
a1037 1
	      regs[0] = (int)callback->write_stdout (callback, ptr(regs[6]), regs[7]);
d1039 2
a1040 1
	      regs[0] = (int)callback->write (callback, regs[5], ptr (regs[6]), regs[7]);
d1053 1
a1053 1
	      regs[0] = callback->open (callback,ptr (regs[5]), regs[6]);
d1344 2
a1345 2
  tempm=RSWAT(regs[m]); regs[m]+=2;
  tempn=RSWAT(regs[n]); regs[n]+=2;
d1348 1
a1348 1
  prod = (long)(short) tempm * (long)(short) tempn;
d1388 1
a1388 1
  tempm = RSLAT(regs[m]);
d1391 1
a1391 1
  tempn = RSLAT(regs[n]);
d1400 1
a1400 1
  ans = (long long)tempm * (long long)tempn; /* Multiply 32bit * 32bit */
d1483 1
a1483 1
  error = 4.; /* 1 << 24-1-21 */
d1536 1
a1536 2
static void
ppi_insn();
d1662 1
a1662 1
  *(char*)&host_little_endian = 1;
d1953 1
a1953 1
  val = swap (* (int *)memory);
d2245 2
a2246 1
  double timetaken = (double) saved_state.asregs.ticks / (double) now_persec ();
d2400 1
a2400 1
	  (char*)&saved_state.asregs.end_of_registers - (char*)&saved_state);
d2426 2
a2427 1
  if (strncmp (cmd, sms_cmd, cmdsize) == 0 && strchr (" \t", cmd[cmdsize]) != NULL)
d2433 2
a2434 1
      (callback->printf_filtered) (callback, "List of SH simulator commands:\n\n");
@


1.12
log
@	* interp.c (fsca_s, fsrra_s): New functions.
	* gencode.c (tab): Add entries for fsca and fsrra.
	(expand_opcode): Allow variable length n / m fields.
@
text
@d1 1
a1 1
/* Simulator for the Hitachi SH architecture.
d123 3
a172 1
#if 1
a174 1
#endif
d193 1
d196 1
d234 1
d256 1
d1419 26
d1575 3
a1577 1
  if (mach == bfd_mach_sh_dsp || mach == bfd_mach_sh3_dsp)
d1592 1
a1592 1
      if (mach == bfd_mach_sh3_dsp)
d1776 5
a1780 1
  loop = get_loop_bounds (RS, RE, memory, mem_end, maskw, endianw);
@


1.11
log
@include/gdb:
        * callback.h (struct host_callback_struct): New members ftruncate
        and truncate.
gdb:
sim/common:
        * callback.c (os_ftruncate, os_truncate): New functions.
        (default_callback): Initialize ftruncate and truncate members.
sim/sh:
        * syscall.h (SYS_truncate, SYS_ftruncate): Define.
        * interp.c (trap): Add support for SYS_ftruncate and SYS_truncate.
@
text
@d1414 49
@


1.10
log
@2003-08-11  Shrinivas Atre  <shrinivasa@@KPITCummins.com>
	* sim/sh/gencode.c ( tab[] ): Addition of MAC.L handler and
        correction for MAC.W handler
        * sim/sh/interp.c ( macl ): New Function. Implementation of
        MAC.L handler.
@
text
@d1156 11
@


1.9
log
@Index: arm/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* wrapper.c (sim_create_inferior, sim_open): Rename _bfd to bfd.

Index: common/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim-utils.h (sim_analyze_program, sim_load_file): Rename _bfd to bfd.
	* sim-hload.c (sim_load), sim-base.h (sim_state_base): Ditto.
	* nrun.c (main): Ditto.

Index: d10v/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: erc32/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interf.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: h8300/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* compile.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: h8500/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* compile.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: i960/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim-if.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: m32r/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim-if.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: m68hc11/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_prepare_for_program, sim_open)
	(sim_create_inferior): Rename _bfd to bfd.

Index: mcore/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: mips/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open):
	(sim_create_inferior):

Index: mn10200/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: mn10300/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior, sim_open)
	(sim_create_inferior): Rename _bfd to bfd.

Index: ppc/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim_calls.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: sh/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (init_dsp, sim_open, sim_create_inferior): Rename _bfd
	to bfd.

Index: v850/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: z8k/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* iface.c (sim_open, sim_create_inferior): Rename _bfd to bfd.
@
text
@d172 1
d655 1
d1351 50
@


1.8
log
@gcc uses trap 33 for profiling, but the simulator didn't support it.
This patch fixes the gcc.dg/nest.c failures for sh-elf.

Fri Oct 11 16:22:28 2002  J"orn Rennecke <joern.rennecke@@superh.com>

	* interp.c (trap): Return int.  Take extra parameter for address
	of the trap instruction.  Changed all callers.
	Add case 33 for profiling.
	* gencode.c (trapa): Handle trap 33 using the trap function.
	Add read of vector for generic traps.
@
text
@d1427 1
a1427 1
     struct _bfd *abfd;
d2143 1
a2143 1
     struct _bfd *abfd;
d2242 1
a2242 1
     struct _bfd *prog_bfd;
@


1.7
log
@include/gdb:
	* sim-sh.h: Add enum constants for sh[1-4], sh3e, sh3?-dsp,
	renumbering the sh-dsp registers to use distinct numbers.
sim/sh:
	* Makefile.in (interp.o): Depend on $(srcroot)/include/gdb/sim-sh.h.
	* interp.c: Include "gdb/sim-sh.h".
	(sim_store_register, sim_fetch_register): Use constants defined there.
gdb:
	* sh-tdep.c (sh_dsp_register_sim_regno): New function.
	(sh_gdbarch_init): Use it for sh-dsp.
@
text
@d957 2
a958 1
/* Simulate a monitor trap, put the result into r0 and errno into r1 */
d960 2
a961 2
static void
trap (i, regs, memory, maskl, maskw, endianw)
d964 1
d976 7
d1166 2
d1170 1
a1170 1

@


1.7.10.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d957 1
a957 2
/* Simulate a monitor trap, put the result into r0 and errno into r1
   return offset by which to adjust pc.  */
d959 2
a960 2
static int
trap (i, regs, insn_ptr, memory, maskl, maskw, endianw)
a962 1
     unsigned char *insn_ptr;
a973 7
    case 33:
      {
	unsigned int countp = * (unsigned int *) (insn_ptr + 4);

	WLAT (countp, RLAT (countp) + 1);
	return 6;
      }
a1156 2
      if (i == 0xc3)
	return -2;
d1159 1
a1159 1
  return 0;
@


1.7.10.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a171 1
static int maskl = 0;
a653 1
#define RSLAT(x)  ((long)(RLAT(x)))
a1153 11
	  case SYS_ftruncate:
	    regs[0] = callback->ftruncate (callback, regs[5], regs[6]);
	    break;
	  case SYS_truncate:
	    {
	      int len = strswaplen (regs[5]);
	      strnswap (regs[5], len);
	      regs[0] = callback->truncate (callback, ptr (regs[5]), regs[6]);
	      strnswap (regs[5], len);
	      break;
	    }
a1350 99
static void
macl (regs, memory, n, m)
     int *regs;
     unsigned char *memory;
     int m, n;
{
  long tempm, tempn;
  long prod, macl, mach, sum;
  long long ans,ansl,ansh,t;
  unsigned long long high,low,combine;
  union mac64
  {
    long m[2]; /* mach and macl*/
    long long m64; /* 64 bit MAC */
  }mac64;

  tempm = RSLAT(regs[m]);
  regs[m] += 4;

  tempn = RSLAT(regs[n]);
  regs[n] += 4;

  mach = MACH;
  macl = MACL;

  mac64.m[0] = macl;
  mac64.m[1] = mach;

  ans = (long long)tempm * (long long)tempn; /* Multiply 32bit * 32bit */

  mac64.m64 += ans; /* Accumulate   64bit + 64 bit */

  macl = mac64.m[0];
  mach = mac64.m[1];

  if (S)  /* Store only 48 bits of the result */
    {
      if (mach < 0) /* Result is negative */
        {
          mach = mach & 0x0000ffff; /* Mask higher 16 bits */
          mach |= 0xffff8000; /* Sign extend higher 16 bits */
        }
      else
        mach = mach & 0x00007fff; /* Postive Result */
    }

  MACL = macl;
  MACH = mach;
}

float
fsca_s (int in, double (*f) (double))
{
  double rad = ldexp ((in & 0xffff), -15) * 3.141592653589793238462643383;
  double result = (*f) (rad);
  double error, upper, lower, frac;
  int exp;

  /* Search the value with the maximum error that is still within the
     architectural spec.  */
  error = ldexp (1., -21);
  /* compensate for calculation inaccuracy by reducing error.  */
  error = error - ldexp (1., -50);
  upper = result + error;
  frac = frexp (upper, &exp);
  upper = ldexp (floor (ldexp (frac, 24)), exp - 24);
  lower = result - error;
  frac = frexp (lower, &exp);
  lower = ldexp (ceil (ldexp (frac, 24)), exp - 24);
  return abs (upper - result) >= abs (lower - result) ? upper : lower;
}

float
fsrra_s (float in)
{
  double result = 1. / sqrt (in);
  int exp;
  double frac, upper, lower, error, eps;

  /* refine result */
  result = result - (result * result * in - 1) * 0.5 * result;
  /* Search the value with the maximum error that is still within the
     architectural spec.  */
  frac = frexp (result, &exp);
  frac = ldexp (frac, 24);
  error = 4.; /* 1 << 24-1-21 */
  /* use eps to compensate for possible 1 ulp error in our 'exact' result.  */
  eps = ldexp (1., -29);
  upper = floor (frac + error - eps);
  if (upper > 16777216.)
    upper = floor ((frac + error - eps) * 0.5) * 2.;
  lower = ceil ((frac - error + eps) * 2) * .5;
  if (lower > 8388608.)
    lower = ceil (frac - error + eps);
  upper = ldexp (upper, exp - 24);
  lower = ldexp (lower, exp - 24);
  return upper - result >= result - lower ? upper : lower;
}

d1427 1
a1427 1
     struct bfd *abfd;
d2143 1
a2143 1
     struct bfd *abfd;
d2242 1
a2242 1
     struct bfd *prog_bfd;
@


1.7.10.3
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d1 1
a1 1
/* Simulator for the Renesas (formerly Hitachi) / SuperH Inc. SH architecture.
a122 3
	    int dbr;		/* debug base register */
	    int sgr;		/* saved gr15 */
	    int ldst;		/* load/store flag (boolean) */
d170 1
d173 1
d185 3
a187 3
#define UR0 	(unsigned int) (saved_state.asregs.regs[0])
#define UR 	(unsigned int) R
#define UR 	(unsigned int) R
a191 1
#define DBR 	saved_state.asregs.cregs.named.dbr
a193 1
#define SGR 	saved_state.asregs.cregs.named.sgr
a230 1
#define LDST	((saved_state.asregs.cregs.named.ldst) != 0)
a251 1
#define SET_LDST(EXP) (saved_state.asregs.cregs.named.ldst = ((EXP) != 0))
d268 3
a270 3
#define FPSCR_FR  ((GET_FPSCR () & FPSCR_MASK_FR) != 0)
#define FPSCR_SZ  ((GET_FPSCR () & FPSCR_MASK_SZ) != 0)
#define FPSCR_PR  ((GET_FPSCR () & FPSCR_MASK_PR) != 0)
d328 1
a328 1
  RAISE_EXCEPTION (x);
d403 1
a403 1
#define CREF(x)  if (!valid[x]) fail ();
d414 8
a421 8
static struct loop_bounds get_loop_bounds PARAMS ((int, int, unsigned char *,
						   unsigned char *, int, int));
static void process_wlat_addr PARAMS ((int, int));
static void process_wwat_addr PARAMS ((int, int));
static void process_wbat_addr PARAMS ((int, int));
static int process_rlat_addr PARAMS ((int));
static int process_rwat_addr PARAMS ((int));
static int process_rbat_addr PARAMS ((int));
d520 1
a520 1
	SET_DR (n, (DR (n) OP DR (m))); \
d523 1
a523 1
    SET_FR (n, (FR (n) OP FR (m))); \
d533 1
a533 1
	SET_DR (n, (OP (DR (n)))); \
d536 1
a536 1
    SET_FR (n, (OP (FR (n)))); \
d546 1
a546 1
	SET_SR_T (DR (n) OP DR (m)); \
d549 1
a549 1
    SET_SR_T (FR (n) OP FR (m)); \
d578 1
a578 1
  unsigned int *p = (unsigned int *) (memory + x);
d588 1
a588 1
  unsigned short *p = (unsigned short *) (memory + (x ^ endianw));
d609 1
a609 1
  unsigned int *p = (unsigned int *) (memory + x);
d620 1
a620 1
  unsigned short *p = (unsigned short *) (memory + (x ^ endianw));
d630 1
a630 1
  unsigned short *p = (unsigned short *) ((size_t) insn_ptr ^ endianw);
d653 4
a656 4
#define RUWAT(x)  (RWAT (x) & 0xffff)
#define RSWAT(x)  ((short) (RWAT (x)))
#define RSLAT(x)  ((long) (RLAT (x)))
#define RSBAT(x)  (SEXT (RBAT (x)))
d761 1
a761 1
#define SEXTW(y)    	((int) ((short) y))
d763 1
a763 1
#define SEXT32(x)	((int) ((x & 0xffffffff) ^ 0x80000000U) - 0x7fffffff - 1)
d765 1
a765 1
#define SEXT32(x)	((int) (x))
d804 1
a804 1
#define TB(x,y)  if ((x) == prevlock || (y) == prevlock) stalls++;
d1002 1
a1002 2
	    regs[0] = execve (ptr (regs[5]), (char **) ptr (regs[6]), 
			      (char **) ptr (regs[7]));
d1005 1
a1005 1
	    regs[0] = execve (ptr (regs[5]), (char **) ptr (regs[6]), 0);
d1030 1
a1030 2
	      regs[0] = (int) callback->write_stdout (callback, 
						      ptr (regs[6]), regs[7]);
d1032 1
a1032 2
	      regs[0] = (int) callback->write (callback, regs[5], 
					       ptr (regs[6]), regs[7]);
d1045 1
a1045 1
	      regs[0] = callback->open (callback, ptr (regs[5]), regs[6]);
d1336 2
a1337 2
  tempm=RSWAT (regs[m]); regs[m]+=2;
  tempn=RSWAT (regs[n]); regs[n]+=2;
d1340 1
a1340 1
  prod = (long) (short) tempm * (long) (short) tempn;
d1380 1
a1380 1
  tempm = RSLAT (regs[m]);
d1383 1
a1383 1
  tempn = RSLAT (regs[n]);
d1392 1
a1392 1
  ans = (long long) tempm * (long long) tempn; /* Multiply 32bit * 32bit */
a1413 26

/* GET_LOOP_BOUNDS {EXTENDED}
   These two functions compute the actual starting and ending point
   of the repeat loop, based on the RS and RE registers (repeat start, 
   repeat stop).  The extended version is called for LDRC, and the
   regular version is called for SETRC.  The difference is that for
   LDRC, the loop start and end instructions are literally the ones
   pointed to by RS and RE -- for SETRC, they're not (see docs).  */

static struct loop_bounds
get_loop_bounds_ext (rs, re, memory, mem_end, maskw, endianw)
     int rs, re;
     unsigned char *memory, *mem_end;
     int maskw, endianw;
{
  struct loop_bounds loop;

  /* FIXME: should I verify RS < RE?  */
  loop.start = PT2H (RS);	/* FIXME not using the params?  */
  loop.end   = PT2H (RE & ~1);	/* Ignore bit 0 of RE.  */
  SKIP_INSN (loop.end);
  if (loop.end >= mem_end)
    loop.end = PT2H (0);
  return loop;
}

d1449 1
a1449 1
  error = 4.0; /* 1 << 24-1-21 */
d1502 2
a1503 1
static void ppi_insn ();
d1544 1
a1544 3
  if (mach == bfd_mach_sh_dsp  || 
      mach == bfd_mach_sh4al_dsp ||
      mach == bfd_mach_sh3_dsp)
d1559 1
a1559 1
      if (mach == bfd_mach_sh3_dsp || mach == bfd_mach_sh4al_dsp)
d1627 1
a1627 1
  * (char*) &host_little_endian = 1;
d1743 1
a1743 5
  if (RE & 1)
    loop = get_loop_bounds_ext (RS, RE, memory, mem_end, maskw, endianw);
  else
    loop = get_loop_bounds     (RS, RE, memory, mem_end, maskw, endianw);

d1914 1
a1914 1
  val = swap (* (int *) memory);
d2206 1
a2206 2
  double timetaken = 
    (double) saved_state.asregs.ticks / (double) now_persec ();
d2360 1
a2360 1
	  (char*) &saved_state.asregs.end_of_registers - (char*) &saved_state);
d2386 1
a2386 2
  if (strncmp (cmd, sms_cmd, cmdsize) == 0 
      && strchr (" \t", cmd[cmdsize]) != NULL)
d2392 1
a2392 2
      (callback->printf_filtered) (callback, 
				   "List of SH simulator commands:\n\n");
@


1.7.8.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@d957 1
a957 2
/* Simulate a monitor trap, put the result into r0 and errno into r1
   return offset by which to adjust pc.  */
d959 2
a960 2
static int
trap (i, regs, insn_ptr, memory, maskl, maskw, endianw)
a962 1
     unsigned char *insn_ptr;
a973 7
    case 33:
      {
	unsigned int countp = * (unsigned int *) (insn_ptr + 4);

	WLAT (countp, RLAT (countp) + 1);
	return 6;
      }
a1156 2
      if (i == 0xc3)
	return -2;
d1159 1
a1159 1
  return 0;
@


1.7.8.2
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d1427 1
a1427 1
     struct bfd *abfd;
d2143 1
a2143 1
     struct bfd *abfd;
d2242 1
a2242 1
     struct bfd *prog_bfd;
@


1.7.8.3
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a171 1
static int maskl = 0;
a653 1
#define RSLAT(x)  ((long)(RLAT(x)))
a1348 50
}

static void
macl (regs, memory, n, m)
     int *regs;
     unsigned char *memory;
     int m, n;
{
  long tempm, tempn;
  long prod, macl, mach, sum;
  long long ans,ansl,ansh,t;
  unsigned long long high,low,combine;
  union mac64
  {
    long m[2]; /* mach and macl*/
    long long m64; /* 64 bit MAC */
  }mac64;

  tempm = RSLAT(regs[m]);
  regs[m] += 4;

  tempn = RSLAT(regs[n]);
  regs[n] += 4;

  mach = MACH;
  macl = MACL;

  mac64.m[0] = macl;
  mac64.m[1] = mach;

  ans = (long long)tempm * (long long)tempn; /* Multiply 32bit * 32bit */

  mac64.m64 += ans; /* Accumulate   64bit + 64 bit */

  macl = mac64.m[0];
  mach = mac64.m[1];

  if (S)  /* Store only 48 bits of the result */
    {
      if (mach < 0) /* Result is negative */
        {
          mach = mach & 0x0000ffff; /* Mask higher 16 bits */
          mach |= 0xffff8000; /* Sign extend higher 16 bits */
        }
      else
        mach = mach & 0x00007fff; /* Postive Result */
    }

  MACL = macl;
  MACH = mach;
@


1.7.8.4
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a1155 11
	  case SYS_ftruncate:
	    regs[0] = callback->ftruncate (callback, regs[5], regs[6]);
	    break;
	  case SYS_truncate:
	    {
	      int len = strswaplen (regs[5]);
	      strnswap (regs[5], len);
	      regs[0] = callback->truncate (callback, ptr (regs[5]), regs[6]);
	      strnswap (regs[5], len);
	      break;
	    }
a1400 49
}

float
fsca_s (int in, double (*f) (double))
{
  double rad = ldexp ((in & 0xffff), -15) * 3.141592653589793238462643383;
  double result = (*f) (rad);
  double error, upper, lower, frac;
  int exp;

  /* Search the value with the maximum error that is still within the
     architectural spec.  */
  error = ldexp (1., -21);
  /* compensate for calculation inaccuracy by reducing error.  */
  error = error - ldexp (1., -50);
  upper = result + error;
  frac = frexp (upper, &exp);
  upper = ldexp (floor (ldexp (frac, 24)), exp - 24);
  lower = result - error;
  frac = frexp (lower, &exp);
  lower = ldexp (ceil (ldexp (frac, 24)), exp - 24);
  return abs (upper - result) >= abs (lower - result) ? upper : lower;
}

float
fsrra_s (float in)
{
  double result = 1. / sqrt (in);
  int exp;
  double frac, upper, lower, error, eps;

  /* refine result */
  result = result - (result * result * in - 1) * 0.5 * result;
  /* Search the value with the maximum error that is still within the
     architectural spec.  */
  frac = frexp (result, &exp);
  frac = ldexp (frac, 24);
  error = 4.; /* 1 << 24-1-21 */
  /* use eps to compensate for possible 1 ulp error in our 'exact' result.  */
  eps = ldexp (1., -29);
  upper = floor (frac + error - eps);
  if (upper > 16777216.)
    upper = floor ((frac + error - eps) * 0.5) * 2.;
  lower = ceil ((frac - error + eps) * 2) * .5;
  if (lower > 8388608.)
    lower = ceil (frac - error + eps);
  upper = ldexp (upper, exp - 24);
  lower = ldexp (lower, exp - 24);
  return upper - result >= result - lower ? upper : lower;
@


1.7.8.5
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d1 1
a1 1
/* Simulator for the Renesas (formerly Hitachi) / SuperH Inc. SH architecture.
a122 3
	    int dbr;		/* debug base register */
	    int sgr;		/* saved gr15 */
	    int ldst;		/* load/store flag (boolean) */
d170 1
d173 1
d185 3
a187 3
#define UR0 	(unsigned int) (saved_state.asregs.regs[0])
#define UR 	(unsigned int) R
#define UR 	(unsigned int) R
a191 1
#define DBR 	saved_state.asregs.cregs.named.dbr
a193 1
#define SGR 	saved_state.asregs.cregs.named.sgr
a230 1
#define LDST	((saved_state.asregs.cregs.named.ldst) != 0)
a251 1
#define SET_LDST(EXP) (saved_state.asregs.cregs.named.ldst = ((EXP) != 0))
d268 3
a270 3
#define FPSCR_FR  ((GET_FPSCR () & FPSCR_MASK_FR) != 0)
#define FPSCR_SZ  ((GET_FPSCR () & FPSCR_MASK_SZ) != 0)
#define FPSCR_PR  ((GET_FPSCR () & FPSCR_MASK_PR) != 0)
d328 1
a328 1
  RAISE_EXCEPTION (x);
d403 1
a403 1
#define CREF(x)  if (!valid[x]) fail ();
d414 8
a421 8
static struct loop_bounds get_loop_bounds PARAMS ((int, int, unsigned char *,
						   unsigned char *, int, int));
static void process_wlat_addr PARAMS ((int, int));
static void process_wwat_addr PARAMS ((int, int));
static void process_wbat_addr PARAMS ((int, int));
static int process_rlat_addr PARAMS ((int));
static int process_rwat_addr PARAMS ((int));
static int process_rbat_addr PARAMS ((int));
d520 1
a520 1
	SET_DR (n, (DR (n) OP DR (m))); \
d523 1
a523 1
    SET_FR (n, (FR (n) OP FR (m))); \
d533 1
a533 1
	SET_DR (n, (OP (DR (n)))); \
d536 1
a536 1
    SET_FR (n, (OP (FR (n)))); \
d546 1
a546 1
	SET_SR_T (DR (n) OP DR (m)); \
d549 1
a549 1
    SET_SR_T (FR (n) OP FR (m)); \
d578 1
a578 1
  unsigned int *p = (unsigned int *) (memory + x);
d588 1
a588 1
  unsigned short *p = (unsigned short *) (memory + (x ^ endianw));
d609 1
a609 1
  unsigned int *p = (unsigned int *) (memory + x);
d620 1
a620 1
  unsigned short *p = (unsigned short *) (memory + (x ^ endianw));
d630 1
a630 1
  unsigned short *p = (unsigned short *) ((size_t) insn_ptr ^ endianw);
d653 4
a656 4
#define RUWAT(x)  (RWAT (x) & 0xffff)
#define RSWAT(x)  ((short) (RWAT (x)))
#define RSLAT(x)  ((long) (RLAT (x)))
#define RSBAT(x)  (SEXT (RBAT (x)))
d761 1
a761 1
#define SEXTW(y)    	((int) ((short) y))
d763 1
a763 1
#define SEXT32(x)	((int) ((x & 0xffffffff) ^ 0x80000000U) - 0x7fffffff - 1)
d765 1
a765 1
#define SEXT32(x)	((int) (x))
d804 1
a804 1
#define TB(x,y)  if ((x) == prevlock || (y) == prevlock) stalls++;
d1002 1
a1002 2
	    regs[0] = execve (ptr (regs[5]), (char **) ptr (regs[6]), 
			      (char **) ptr (regs[7]));
d1005 1
a1005 1
	    regs[0] = execve (ptr (regs[5]), (char **) ptr (regs[6]), 0);
d1030 1
a1030 2
	      regs[0] = (int) callback->write_stdout (callback, 
						      ptr (regs[6]), regs[7]);
d1032 1
a1032 2
	      regs[0] = (int) callback->write (callback, regs[5], 
					       ptr (regs[6]), regs[7]);
d1045 1
a1045 1
	      regs[0] = callback->open (callback, ptr (regs[5]), regs[6]);
d1336 2
a1337 2
  tempm=RSWAT (regs[m]); regs[m]+=2;
  tempn=RSWAT (regs[n]); regs[n]+=2;
d1340 1
a1340 1
  prod = (long) (short) tempm * (long) (short) tempn;
d1380 1
a1380 1
  tempm = RSLAT (regs[m]);
d1383 1
a1383 1
  tempn = RSLAT (regs[n]);
d1392 1
a1392 1
  ans = (long long) tempm * (long long) tempn; /* Multiply 32bit * 32bit */
a1413 26

/* GET_LOOP_BOUNDS {EXTENDED}
   These two functions compute the actual starting and ending point
   of the repeat loop, based on the RS and RE registers (repeat start, 
   repeat stop).  The extended version is called for LDRC, and the
   regular version is called for SETRC.  The difference is that for
   LDRC, the loop start and end instructions are literally the ones
   pointed to by RS and RE -- for SETRC, they're not (see docs).  */

static struct loop_bounds
get_loop_bounds_ext (rs, re, memory, mem_end, maskw, endianw)
     int rs, re;
     unsigned char *memory, *mem_end;
     int maskw, endianw;
{
  struct loop_bounds loop;

  /* FIXME: should I verify RS < RE?  */
  loop.start = PT2H (RS);	/* FIXME not using the params?  */
  loop.end   = PT2H (RE & ~1);	/* Ignore bit 0 of RE.  */
  SKIP_INSN (loop.end);
  if (loop.end >= mem_end)
    loop.end = PT2H (0);
  return loop;
}

d1449 1
a1449 1
  error = 4.0; /* 1 << 24-1-21 */
d1502 2
a1503 1
static void ppi_insn ();
d1544 1
a1544 3
  if (mach == bfd_mach_sh_dsp  || 
      mach == bfd_mach_sh4al_dsp ||
      mach == bfd_mach_sh3_dsp)
d1559 1
a1559 1
      if (mach == bfd_mach_sh3_dsp || mach == bfd_mach_sh4al_dsp)
d1627 1
a1627 1
  * (char*) &host_little_endian = 1;
d1743 1
a1743 5
  if (RE & 1)
    loop = get_loop_bounds_ext (RS, RE, memory, mem_end, maskw, endianw);
  else
    loop = get_loop_bounds     (RS, RE, memory, mem_end, maskw, endianw);

d1914 1
a1914 1
  val = swap (* (int *) memory);
d2206 1
a2206 2
  double timetaken = 
    (double) saved_state.asregs.ticks / (double) now_persec ();
d2360 1
a2360 1
	  (char*) &saved_state.asregs.end_of_registers - (char*) &saved_state);
d2386 1
a2386 2
  if (strncmp (cmd, sms_cmd, cmdsize) == 0 
      && strchr (" \t", cmd[cmdsize]) != NULL)
d2392 1
a2392 2
      (callback->printf_filtered) (callback, 
				   "List of SH simulator commands:\n\n");
@


1.6
log
@	* interp.c (sim_resume): Fix setting of bus error for
	instruction fetch.
@
text
@d32 1
d1794 6
a1799 2
    case  0: case  1: case  2: case  3: case  4: case  5: case  6: case  7:
    case  8: case  9: case 10: case 11: case 12: case 13: case 14: case 15:
d1802 1
a1802 1
    case 16:
d1805 1
a1805 1
    case 17:
d1808 1
a1808 1
    case 18:
d1811 1
a1811 1
    case 19:
d1814 1
a1814 1
    case 20:
d1817 1
a1817 1
    case 21:
d1820 1
a1820 1
    case 22:
d1823 1
a1823 1
    case 23:
d1826 1
a1826 1
    case 24:
d1829 7
a1835 35
    case 25:
      if (target_dsp)
	A0G = val;
    else case 26:
      if (target_dsp)
	A0 = val;
    else case 27:
      if (target_dsp)
	A1G = val;
    else case 28:
      if (target_dsp)
	A1 = val;
    else case 29:
      if (target_dsp)
	M0 = val;
    else case 30:
      if (target_dsp)
	M1 = val;
    else case 31:
      if (target_dsp)
	X0 = val;
    else case 32:
      if (target_dsp)
	X1 = val;
    else case 33:
      if (target_dsp)
	Y0 = val;
    else case 34:
      if (target_dsp)
	Y1 = val;
    else case 40:
      if (target_dsp)
	SET_MOD (val);
    else case 35: case 36: case 37: case 38: case 39:
	SET_FI (rn - 25, val);
d1837 43
a1879 1
    case 41:
d1882 1
a1882 1
    case 42:
d1887 4
a1890 7
    case 43:
      if (target_dsp)
	RS = val;
    else case 44:
      if (target_dsp)
	RE = val;
    else case 45: case 46: case 47: case 48: case 49: case 50:
d1892 1
a1892 1
	Rn_BANK (rn - 43) = val;
d1894 1
a1894 1
	saved_state.asregs.regs[rn - 43] = val;
d1896 6
a1901 3
    case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58:
      if (target_dsp || ! SR_MD || ! SR_RB)
	SET_Rn_BANK (rn - 51, val);
d1903 7
a1909 1
	saved_state.asregs.regs[rn - 51] = val;
d1929 6
a1934 2
    case  0: case  1: case  2: case  3: case  4: case  5: case  6: case  7:
    case  8: case  9: case 10: case 11: case 12: case 13: case 14: case 15:
d1937 1
a1937 1
    case 16:
d1940 1
a1940 1
    case 17:
d1943 1
a1943 1
    case 18:
d1946 1
a1946 1
    case 19:
d1949 1
a1949 1
    case 20:
d1952 1
a1952 1
    case 21:
d1955 1
a1955 1
    case 22:
d1958 1
a1958 1
    case 23:
d1961 1
a1961 1
    case 24:
d1964 13
a1976 2
    case 25:
      val = target_dsp ? SEXT (A0G) : FI (0);
d1978 2
a1979 2
    case 26:
      val = target_dsp ? A0 : FI (1);
d1981 2
a1982 2
    case 27:
      val = target_dsp ? SEXT (A1G) : FI (2);
d1984 2
a1985 2
    case 28:
      val = target_dsp ? A1 : FI (3);
d1987 2
a1988 2
    case 29:
      val = target_dsp ? M0 : FI (4);
d1990 2
a1991 2
    case 30:
      val = target_dsp ? M1 : FI (5);
d1993 2
a1994 2
    case 31:
      val = target_dsp ? X0 : FI (6);
d1996 2
a1997 2
    case 32:
      val = target_dsp ? X1 : FI (7);
d1999 2
a2000 2
    case 33:
      val = target_dsp ? Y0 : FI (8);
d2002 5
a2006 2
    case 34:
      val = target_dsp ? Y1 : FI (9);
d2008 2
a2009 2
    case 35: case 36: case 37: case 38: case 39:
      val = FI (rn - 25);
d2011 2
a2012 2
    case 40:
      val = target_dsp ? MOD : FI (15);
d2014 1
a2014 1
    case 41:
d2017 1
a2017 1
    case 42:
d2022 21
a2042 15
    case 43:
      if (target_dsp)
	val = RS;
    else case 44:
      if (target_dsp)
	val = RE;
    else case 45: case 46: case 47: case 48: case 49: case 50:
	val = (SR_MD && SR_RB
	       ? Rn_BANK (rn - 43)
	       : saved_state.asregs.regs[rn - 43]);
      break;
    case 51: case 52: case 53: case 54: case 55: case 56: case 57: case 58:
      val = (target_dsp || ! SR_MD || ! SR_RB
	     ? Rn_BANK (rn - 51)
	     : saved_state.asregs.regs[rn - 51]);
@


1.5
log
@Move include/callback.h and include/remote-sim.h to include/gdb/.
Update accordingly.
@
text
@d1720 1
a1720 1
    saved_state.asregs.exception == SIGBUS;
@


1.4
log
@* interp.c (sim_create_inferior): Record program arguments for
later inspection by the trap handler.
(count_argc): New function.
(prog_argv): Declare static.
(sim_write): Declare.
(trap): Implement argc, argnlen and argn system calls. Do not
abort on unknown system calls--simply return -1.
* syscall.h (SYS_argc, SYS_argnlen, SYS_argn): Define.
@
text
@d30 2
a31 2
#include "callback.h"
#include "remote-sim.h"
@


1.4.14.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d30 2
a31 2
#include "gdb/callback.h"
#include "gdb/remote-sim.h"
d1720 1
a1720 1
    saved_state.asregs.exception = SIGBUS;
@


1.4.14.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@a31 1
#include "gdb/sim-sh.h"
d1793 2
a1794 6
    case SIM_SH_R0_REGNUM: case SIM_SH_R1_REGNUM: case SIM_SH_R2_REGNUM:
    case SIM_SH_R3_REGNUM: case SIM_SH_R4_REGNUM: case SIM_SH_R5_REGNUM:
    case SIM_SH_R6_REGNUM: case SIM_SH_R7_REGNUM: case SIM_SH_R8_REGNUM:
    case SIM_SH_R9_REGNUM: case SIM_SH_R10_REGNUM: case SIM_SH_R11_REGNUM:
    case SIM_SH_R12_REGNUM: case SIM_SH_R13_REGNUM: case SIM_SH_R14_REGNUM:
    case SIM_SH_R15_REGNUM:
d1797 1
a1797 1
    case SIM_SH_PC_REGNUM:
d1800 1
a1800 1
    case SIM_SH_PR_REGNUM:
d1803 1
a1803 1
    case SIM_SH_GBR_REGNUM:
d1806 1
a1806 1
    case SIM_SH_VBR_REGNUM:
d1809 1
a1809 1
    case SIM_SH_MACH_REGNUM:
d1812 1
a1812 1
    case SIM_SH_MACL_REGNUM:
d1815 1
a1815 1
    case SIM_SH_SR_REGNUM:
d1818 1
a1818 1
    case SIM_SH_FPUL_REGNUM:
d1821 1
a1821 1
    case SIM_SH_FPSCR_REGNUM:
d1824 35
a1858 7
    case SIM_SH_FR0_REGNUM: case SIM_SH_FR1_REGNUM: case SIM_SH_FR2_REGNUM:
    case SIM_SH_FR3_REGNUM: case SIM_SH_FR4_REGNUM: case SIM_SH_FR5_REGNUM:
    case SIM_SH_FR6_REGNUM: case SIM_SH_FR7_REGNUM: case SIM_SH_FR8_REGNUM:
    case SIM_SH_FR9_REGNUM: case SIM_SH_FR10_REGNUM: case SIM_SH_FR11_REGNUM:
    case SIM_SH_FR12_REGNUM: case SIM_SH_FR13_REGNUM: case SIM_SH_FR14_REGNUM:
    case SIM_SH_FR15_REGNUM:
      SET_FI (rn - SIM_SH_FR0_REGNUM, val);
d1860 1
a1860 43
    case SIM_SH_DSR_REGNUM:
      DSR = val;
      break;
    case SIM_SH_A0G_REGNUM:
      A0G = val;
      break;
    case SIM_SH_A0_REGNUM:
      A0 = val;
      break;
    case SIM_SH_A1G_REGNUM:
      A1G = val;
      break;
    case SIM_SH_A1_REGNUM:
      A1 = val;
      break;
    case SIM_SH_M0_REGNUM:
      M0 = val;
      break;
    case SIM_SH_M1_REGNUM:
      M1 = val;
      break;
    case SIM_SH_X0_REGNUM:
      X0 = val;
      break;
    case SIM_SH_X1_REGNUM:
      X1 = val;
      break;
    case SIM_SH_Y0_REGNUM:
      Y0 = val;
      break;
    case SIM_SH_Y1_REGNUM:
      Y1 = val;
      break;
    case SIM_SH_MOD_REGNUM:
      SET_MOD (val);
      break;
    case SIM_SH_RS_REGNUM:
      RS = val;
      break;
    case SIM_SH_RE_REGNUM:
      RE = val;
      break;
    case SIM_SH_SSR_REGNUM:
d1863 1
a1863 1
    case SIM_SH_SPC_REGNUM:
d1868 7
a1874 4
    case SIM_SH_R0_BANK0_REGNUM: case SIM_SH_R1_BANK0_REGNUM:
    case SIM_SH_R2_BANK0_REGNUM: case SIM_SH_R3_BANK0_REGNUM:
    case SIM_SH_R4_BANK0_REGNUM: case SIM_SH_R5_BANK0_REGNUM:
    case SIM_SH_R6_BANK0_REGNUM: case SIM_SH_R7_BANK0_REGNUM:
d1876 1
a1876 1
	Rn_BANK (rn - SIM_SH_R0_BANK0_REGNUM) = val;
d1878 1
a1878 1
	saved_state.asregs.regs[rn - SIM_SH_R0_BANK0_REGNUM] = val;
d1880 3
a1882 6
    case SIM_SH_R0_BANK1_REGNUM: case SIM_SH_R1_BANK1_REGNUM:
    case SIM_SH_R2_BANK1_REGNUM: case SIM_SH_R3_BANK1_REGNUM:
    case SIM_SH_R4_BANK1_REGNUM: case SIM_SH_R5_BANK1_REGNUM:
    case SIM_SH_R6_BANK1_REGNUM: case SIM_SH_R7_BANK1_REGNUM:
      if (SR_MD && SR_RB)
	saved_state.asregs.regs[rn - SIM_SH_R0_BANK1_REGNUM] = val;
d1884 1
a1884 7
	Rn_BANK (rn - SIM_SH_R0_BANK1_REGNUM) = val;
      break;
    case SIM_SH_R0_BANK_REGNUM: case SIM_SH_R1_BANK_REGNUM:
    case SIM_SH_R2_BANK_REGNUM: case SIM_SH_R3_BANK_REGNUM:
    case SIM_SH_R4_BANK_REGNUM: case SIM_SH_R5_BANK_REGNUM:
    case SIM_SH_R6_BANK_REGNUM: case SIM_SH_R7_BANK_REGNUM:
      SET_Rn_BANK (rn - SIM_SH_R0_BANK_REGNUM, val);
d1904 2
a1905 6
    case SIM_SH_R0_REGNUM: case SIM_SH_R1_REGNUM: case SIM_SH_R2_REGNUM:
    case SIM_SH_R3_REGNUM: case SIM_SH_R4_REGNUM: case SIM_SH_R5_REGNUM:
    case SIM_SH_R6_REGNUM: case SIM_SH_R7_REGNUM: case SIM_SH_R8_REGNUM:
    case SIM_SH_R9_REGNUM: case SIM_SH_R10_REGNUM: case SIM_SH_R11_REGNUM:
    case SIM_SH_R12_REGNUM: case SIM_SH_R13_REGNUM: case SIM_SH_R14_REGNUM:
    case SIM_SH_R15_REGNUM:
d1908 1
a1908 1
    case SIM_SH_PC_REGNUM:
d1911 1
a1911 1
    case SIM_SH_PR_REGNUM:
d1914 1
a1914 1
    case SIM_SH_GBR_REGNUM:
d1917 1
a1917 1
    case SIM_SH_VBR_REGNUM:
d1920 1
a1920 1
    case SIM_SH_MACH_REGNUM:
d1923 1
a1923 1
    case SIM_SH_MACL_REGNUM:
d1926 1
a1926 1
    case SIM_SH_SR_REGNUM:
d1929 1
a1929 1
    case SIM_SH_FPUL_REGNUM:
d1932 1
a1932 1
    case SIM_SH_FPSCR_REGNUM:
d1935 2
a1936 7
    case SIM_SH_FR0_REGNUM: case SIM_SH_FR1_REGNUM: case SIM_SH_FR2_REGNUM:
    case SIM_SH_FR3_REGNUM: case SIM_SH_FR4_REGNUM: case SIM_SH_FR5_REGNUM:
    case SIM_SH_FR6_REGNUM: case SIM_SH_FR7_REGNUM: case SIM_SH_FR8_REGNUM:
    case SIM_SH_FR9_REGNUM: case SIM_SH_FR10_REGNUM: case SIM_SH_FR11_REGNUM:
    case SIM_SH_FR12_REGNUM: case SIM_SH_FR13_REGNUM: case SIM_SH_FR14_REGNUM:
    case SIM_SH_FR15_REGNUM:
      val = FI (rn - SIM_SH_FR0_REGNUM);
d1938 2
a1939 2
    case SIM_SH_DSR_REGNUM:
      val = DSR;
d1941 2
a1942 2
    case SIM_SH_A0G_REGNUM:
      val = SEXT (A0G);
d1944 2
a1945 2
    case SIM_SH_A0_REGNUM:
      val = A0;
d1947 2
a1948 2
    case SIM_SH_A1G_REGNUM:
      val = SEXT (A1G);
d1950 2
a1951 2
    case SIM_SH_A1_REGNUM:
      val = A1;
d1953 2
a1954 2
    case SIM_SH_M0_REGNUM:
      val = M0;
d1956 2
a1957 2
    case SIM_SH_M1_REGNUM:
      val = M1;
d1959 2
a1960 2
    case SIM_SH_X0_REGNUM:
      val = X0;
d1962 2
a1963 11
    case SIM_SH_X1_REGNUM:
      val = X1;
      break;
    case SIM_SH_Y0_REGNUM:
      val = Y0;
      break;
    case SIM_SH_Y1_REGNUM:
      val = Y1;
      break;
    case SIM_SH_MOD_REGNUM:
      val = MOD;
d1965 2
a1966 2
    case SIM_SH_RS_REGNUM:
      val = RS;
d1968 2
a1969 2
    case SIM_SH_RE_REGNUM:
      val = RE;
d1971 1
a1971 1
    case SIM_SH_SSR_REGNUM:
d1974 1
a1974 1
    case SIM_SH_SPC_REGNUM:
d1979 15
a1993 21
    case SIM_SH_R0_BANK0_REGNUM: case SIM_SH_R1_BANK0_REGNUM:
    case SIM_SH_R2_BANK0_REGNUM: case SIM_SH_R3_BANK0_REGNUM:
    case SIM_SH_R4_BANK0_REGNUM: case SIM_SH_R5_BANK0_REGNUM:
    case SIM_SH_R6_BANK0_REGNUM: case SIM_SH_R7_BANK0_REGNUM:
      val = (SR_MD && SR_RB
	     ? Rn_BANK (rn - SIM_SH_R0_BANK0_REGNUM)
	     : saved_state.asregs.regs[rn - SIM_SH_R0_BANK0_REGNUM]);
      break;
    case SIM_SH_R0_BANK1_REGNUM: case SIM_SH_R1_BANK1_REGNUM:
    case SIM_SH_R2_BANK1_REGNUM: case SIM_SH_R3_BANK1_REGNUM:
    case SIM_SH_R4_BANK1_REGNUM: case SIM_SH_R5_BANK1_REGNUM:
    case SIM_SH_R6_BANK1_REGNUM: case SIM_SH_R7_BANK1_REGNUM:
      val = (! SR_MD || ! SR_RB
	     ? Rn_BANK (rn - SIM_SH_R0_BANK1_REGNUM)
	     : saved_state.asregs.regs[rn - SIM_SH_R0_BANK1_REGNUM]);
      break;
    case SIM_SH_R0_BANK_REGNUM: case SIM_SH_R1_BANK_REGNUM:
    case SIM_SH_R2_BANK_REGNUM: case SIM_SH_R3_BANK_REGNUM:
    case SIM_SH_R4_BANK_REGNUM: case SIM_SH_R5_BANK_REGNUM:
    case SIM_SH_R6_BANK_REGNUM: case SIM_SH_R7_BANK_REGNUM:
      val = Rn_BANK (rn - SIM_SH_R0_BANK_REGNUM);
@


1.4.14.3
log
@merge from mainline
@
text
@d957 1
a957 2
/* Simulate a monitor trap, put the result into r0 and errno into r1
   return offset by which to adjust pc.  */
d959 2
a960 2
static int
trap (i, regs, insn_ptr, memory, maskl, maskw, endianw)
a962 1
     unsigned char *insn_ptr;
a973 7
    case 33:
      {
	unsigned int countp = * (unsigned int *) (insn_ptr + 4);

	WLAT (countp, RLAT (countp) + 1);
	return 6;
      }
a1156 2
      if (i == 0xc3)
	return -2;
d1159 1
a1159 1
  return 0;
@


1.4.12.1
log
@merge from trunk
@
text
@d30 2
a31 2
#include "gdb/callback.h"
#include "gdb/remote-sim.h"
@


1.4.12.2
log
@merge with trunk
@
text
@d1720 1
a1720 1
    saved_state.asregs.exception = SIGBUS;
@


1.3
log
@* interp.c (trap): Implement time.
@
text
@d57 2
d167 1
d270 14
d1122 19
d1145 2
a1146 1
	    abort ();
d2186 1
a2186 1
  /* clear the registers */
d2189 2
a2190 1
  /* set the PC */
d2193 4
@


1.2
log
@sh-dsp support, simulator speedup by using host byte order:

sim:
	* Makefile.in (interp.o): Depends on ppi.c .
	(ppi.c): New rule.
	* gencode.c (printonmatch, think, genopc): Deleted.
	(MAX_NR_STUFF): Now 42.
	(tab): Add SH-DSP CPU instructions.
	Amalgamate ldc / stc / lds / sts instructions with similar
	bit patterns.  Fix opcodes of stc Rm_BANK,@@-<REG_N>.
	Fix semantics of lds.l @@<REG_N>+,MACH (no sign extend).
	(movsxy_tab): New array.
	For movs, change MMMM field to GGGG, and mmmm field to MMMM.
	Added entries for movx, movy and parallel processing insns.
	(ppi_tab): New array.
	(qfunc): Stabilize sort.
	(expand_opcode): Handle [01][01]NN, [01][01]xx and [01][01]yy.
	Handle 'M', 'G' 's' 'X', 'a', 'Y' and 'A'.
	(dumptable): Now takes three arguments.  Changed all callers.
	Emit just one contigous jump table.
	(filltable): Now takes an argument.  Changed all callers.
	Make index static.
	(ppi_moves, expand_ppi_code, ppi_filltable, ppi_gensim): New functions.
	(gensim_caselist): New function, broken out of gensim.
	Handle opcode fields 'x', 'y', 's', 'M', 'G', 'X', 'a', and 'Y'.
	Handle ref '9'.
	(gensim): Handle 'N' in code field and '8' in refs field.
	Call gensim_caselist - twice.
	(ppi_index): New static variable.
	(main): Unsupport default action.
	Add dsp support for -x / -s option.  Add -p option.
	* interp.c (sh_jump_table, sh_dsp_table, ppi_table): Declare.
	(saved_state_type): Rearrange to allow amalgamated ldc / stc /
	lds / sts to work efficiently.
	(target_dsp): New static variable.
	(GBR, VBR, SSR, SPC, MACH, MACL): Reflect saved_state_type change.
	(FPUL, Rn_BANK, SET_Rn_BANK, M, Q, S, T, SR_BL, SR_RB): Likewise.
	(SR_MD, SR_RC, SET_SR_BIT, GET_SR, SET_RC, GET_FPSCR): Likewise.
	(RS, RE, MOD, MOD_ME, DSP_R): Likewise.
	(set_fpscr1): Likewise.  Use target_dsp to check for dsp.
	(MOD_MSi, SIG_BUS_FETCH): Deleted.
	(CREG, SREG, PR, SR_MASK_DMY, SR_MASK_DMX, SR_DMY): New macros.
	(SR_DMX, DSR, MOD_DELTA, GET_DSP_GRD): Likewise.
	(SET_MOD): Reflect saved_state_type change.  Set MOD_DELTA instead
	of MOD_MS, and encode SR_DMY / SR_DMX into high word of MOD_ME.
	(set_sr): Reflect saved_state_type change.  Fix SR_RB handling.
	Use SET_MOD.
	(MA, L, TL, TB): Now controlled by ACE_FAST.
	(SEXT32): Just cast to int.
	(SIGN32): Fixed to only shift by 31.
	(CHECK_INSN_PTR): SIGBUS at insn fetch now represented by insn_end 0.
	(ppi_insn): Declare.
	(ppi.c): Include.
	(init_dsp): Set target_dsp.  When it changes, switch end of
	sh_jump_table with sh_dsp_table.
	(sim_resume) Don't declare sh_jump_table0.  Use sh_jump_table instead.
	Don't Declare PR if it's #defined.
	Fix single-stepping (Was broken in Mar  6 16:59:10 patch).
	(sim_store_register, sim_read_register): Translate accesses to
	reflect saved_state_type change.

	* interp.c (set_sr): Set sr.
	(SET_RC, MOD, MOD_MS, MOD_ME, SET_MOD, MOD_MS, MOD_ME): New macros.
	(set_fpscr1): Don't bank-switch fpu registers when simulating sh-dsp.
	(DSP_R): Fix definition.
	(sim_resume): Remove outdated SET_SR use.

	* interp.c (saved_state): New members for struct member asregs:
	rs, re, insn_end, xram_start, yram_start.
	(struct loop_bounds): New struct.
	(SKIP_INSN): New macro.
	(get_loop_bounds): New function.
	(endianw): Renamed to global_endianw.
	(maskw): negated bits.
	(PC): Now insn_ptr.
	(SR_MASK_RC, SR_RC_INCREMENT, SR_RC, RAISE_EXCEPTION): New macros.
	(RS, RE, DSP_R, DSP_GRD, A1, A0, X0, X1, Y0, Y1, M0, A1G): Likewise.
	(M1, A0G, RIAT, PT2H, PH2T, SET_NIP, CHECK_INSN_PTR): Likewise.
	(SIG_BUS_FETCH): Likewise
	(raise_exception, riat_fast): New functions.
	(raise_buserror, sim_stop): Use raise_exception.
	(PROCESS_SPECIAL_ADDRESS): Use xram_start / yram_start.
	(BUSERROR, WRITE_BUSERROR, READ_BUSERROR):
	Reverse sense of mask argument.
	(FP_OP, set_dr): Use RAISE_EXCEPTION.
	(wlat_fast, wwat_fast, wbat_fast, rlat_fast, rwat_fast, rbat_fast):
	Declare.  Remove redundant masking.
	(wwat_fast, rwat_fast): Add argument endianw.  Changed callers.
	(MA): Updated for change pc -> PC.
	(Delay_Slot): Use RIAT.
	(empty): Deleted.
	(trap): Remove argument little_endian.  Add argument endianw.
	Changed all callers.  Use raise_exception.
	(macw): Add argument endainw.  Changed all callers.
	(init_dsp): New function, extended after broken out of init_pointers.
	(sim_resume): Replace pc with insn_ptr.  Replace little_endian with
	endianw.  Replace nia with nip.  Reverse sense of maskb / maskw /
	maskl.  Implement logic for zero-overhead loops.  Don't try to
	interpret garbage when getting a SIGBUS at insn fetch.
	(sim_open): Call init_dsp.
	* gencode.c (tab): Use SET_NIP instead of nia = .  Use PH2T / PT2H /
	RAISE_EXCEPTION where appropriate.
	Add extra cycles for brai, braf , bsr, bsrf, jmp, jsr.

	* interp.c (sim_store_register, sim_fetch_register):
	Do proper endianness switch.

	* interp.c (saved_state_type): New members for struct member asregs:
	xymem_select, xmem, ymem, xmem_offset, ymem_offset.
	(special_address): Delete.
	(BUSERROR): Now a two-argument predicate.
	(PROCESS_SPECIAL_ADDRESS, WRITE_BUSERROR, READ_BUSERROR): New macros.
	(wlat_little, wwat_little, wbat_any, wlat_big, wwat_big): Delete.
	(process_wlat_addr, process_wwat_addr): New functions.
	(process_wbat_addr, process_rlat_addr, process_rwat_addr): Likewise.
	(process_rbat_addr): Likewise.
	(wlat_fast, wwat_fast, wbat_fast): Use WRITE_BUSERROR.
	(rlat_little, rwat_little, rbat_any, rlat_big, rwat_big): Delete.
	(rlat_fast, rwat_fast, rbat_fast): Use READ_BUSERROR.
	(RWAT, RLAT, RBAT, WWAT, WLAT, WBAT): Delete SLOW versions.
	(do_rdat, trap): Delete SLOW code.
	(SEXT32, SIGN32): New macros.
	(swap, swap16): Now integer in - integer out.  Changed all callers.
	(strswaplen, strnswap): Delete SLOW versions.
	(init_pointers): Initialize dsp memory selection (preliminary).
	(sim_store_register, sim_fetch_register): Use swap instead of
	big / little endian read / write functions.

	* interp.c (maskl): Deleted.
	(endianw, endianb): New variables.
	(special_address): Now inline.
	(bp_holder): Put raising of buserror there, rename to:
	(raise_buserror).
	(BUSERROR): Now yields a value.  Changed all users.
	(wbat_big): Delete.
	(wlat_fast, wwat_fast, wbat_fast): New functions.
	(rlat_fast, rwat_fast, rbat_fast): Likewise.
	(RWAT, RLAT, RBAT, WWAT, WLAT, WBAT): Use new functions.
	(do_rdat, do_wdat): Likewise.  Take maskl argument instead of
	little_endian one.  Changed caller macros.
	(swap, swap16): Use w[rw]lat_big / w[rw]lat_little directly.
	(strswaplen, strnswap): New functions.
	(trap): Use them to fix up endian mismatches;
	disable SYS_execve and SYS_execv; fix double address translation for
	SYS_pipe and SYS_stat.
	(sym_write, sym_read): Add endianness translation.
	(sym_store_register, sym_fetch_register): Add maskl local variable.
	(sim_open): Set endianw and endianb.

gdb:

	* sh-tdep.c (sh_dsp_reg_names, sh3_dsp_reg_names): New arrays.
	(sh_processor_type_table): Add entries for bfd_mach_sh_dsp and
	 bfd_mach_sh3_dsp.
	(sh_show_regs): Floating point registers are called fr0-fr15.
	For sh4, display fpul, fpscr and fr0-fr15 / dr0-dr14 as appropriate.
	Handle sh-dsp and sh3-dsp.
	config/sh/tm-sh.h (REGISTER_VIRTUAL_TYPE): sh-dsp / sh3-dsp
	don't have floating point registers.
	(DSR_REGNUM, A0G_REGNUM, A0_REGNUM, A1G_REGNUM, A1_REGNUM): Define.
	(M0_REGNUM, M1_REGNUM, X0_REGNUM, X1_REGNUM, Y0_REGNUM): Likewise.
	(Y1_REGNUM, MOD_REGNUM, RS_REGNUM, RE_REGNUM, R0B_REGNUM): Likewise.
@
text
@d1105 3
@


1.1
log
@Initial revision
@
text
@d55 2
d61 4
a69 1
    int pad_dummy;
a71 1
    int pr;
d73 20
a92 8
    int gbr;
    int vbr;
    int mach;
    int macl;

    int sr;

    int fpul;
d94 1
a94 3
    int fpscr;

    /* sh3e */
d101 22
a122 1
    fregs;
d124 1
a124 4
    int ssr;
    int spc;
    /* sh3 */
    int bank[2][8];
d144 5
d156 1
d162 2
d167 1
a167 2
static int maskl = ~0;
static int maskw = ~0;
d184 10
a193 7
#define GBR 	saved_state.asregs.gbr
#define VBR 	saved_state.asregs.vbr
#define SSR	saved_state.asregs.ssr
#define SPC	saved_state.asregs.spc
#define MACH 	saved_state.asregs.mach
#define MACL 	saved_state.asregs.macl
#define FPUL	saved_state.asregs.fpul
d195 1
a195 1
#define PC pc
d199 1
a199 1
/* Alternate bank of registers r0-r6 */
d202 2
a203 2
#define Rn_BANK(n) (saved_state.asregs.bank[!SR_RB][(n)])
#define SET_Rn_BANK(n, EXP) do { saved_state.asregs.bank[!SR_RB][(n)] = (EXP); } while (0)
d208 2
d219 2
d222 11
a232 8
#define M 	((saved_state.asregs.sr & SR_MASK_M) != 0)
#define Q 	((saved_state.asregs.sr & SR_MASK_Q) != 0)
#define S 	((saved_state.asregs.sr & SR_MASK_S) != 0)
#define T 	((saved_state.asregs.sr & SR_MASK_T) != 0)

#define SR_BL ((saved_state.asregs.sr & SR_MASK_BL) != 0)
#define SR_RB ((saved_state.asregs.sr & SR_MASK_RB) != 0)
#define SR_MD ((saved_state.asregs.sr & SR_MASK_MD) != 0)
d238 1
a238 1
    saved_state.asregs.sr |= (BIT); \
d240 1
a240 1
    saved_state.asregs.sr &= ~(BIT); \
d248 3
a250 1
#define GET_SR() (saved_state.asregs.sr - 0)
d252 15
d268 2
a269 2
set_sr (new_sr)
     int new_sr;
d271 6
a276 6
  /* do we need to swap banks */
  int old_gpr = (SR_MD ? !SR_RB : 0);
  int new_gpr = ((new_sr & SR_MASK_MD)
		 ? (new_sr & SR_MASK_RB) == 0
		 : 0);
  if (old_gpr != new_gpr)
d278 3
a280 6
      int i;
      for (i = 0; i < 8; i++)
	{
	  saved_state.asregs.bank[old_gpr][i] = saved_state.asregs.regs[i];
	  saved_state.asregs.regs[i] = saved_state.asregs.bank[new_gpr][i];
	}
d284 6
d291 1
a291 6
/* Manipulate FPSCR */

#define set_fpscr1(x)
#define SET_FPSCR(x) (saved_state.asregs.fpscr = (x))
#define GET_FPSCR()  (saved_state.asregs.fpscr)

d299 4
a302 1
/* This function exists solely for the purpose of setting a breakpoint to
d306 8
a313 1
bp_holder ()
d315 1
d318 31
d353 20
a372 2
#define BUSERROR(addr, mask) \
  if (addr & ~mask) { saved_state.asregs.exception = SIGBUS;  bp_holder (); }
a393 1

d395 14
d416 20
a435 2
#define FI(n) (saved_state.asregs.fregs.i[(n)])
#define FR(n) (saved_state.asregs.fregs.f[(n)])
d437 21
a457 2
#define SET_FI(n,EXP) (saved_state.asregs.fregs.i[(n)] = (EXP))
#define SET_FR(n,EXP) (saved_state.asregs.fregs.f[(n)] = (EXP))
d459 2
a460 3
#define FP_OP(n, OP, m) (SET_FR(n, (FR(n) OP FR(m))))
#define FP_UNARY(n, OP) (SET_FR(n, (OP (FR(n)))))
#define FP_CMP(n, OP, m) SET_SR_T(FR(n) OP FR(m))
d462 2
d465 88
d555 1
a555 1
wlat_little (memory, x, value, maskl)
d559 3
a561 6
  unsigned char *p = memory + ((x) & maskl);
  BUSERROR(x, maskl);
  p[3] = v >> 24;
  p[2] = v >> 16;
  p[1] = v >> 8;
  p[0] = v;
d565 1
a565 1
wwat_little (memory, x, value, maskw)
d569 3
a571 5
  unsigned char *p = memory + ((x) & maskw);
  BUSERROR(x, maskw);

  p[1] = v >> 8;
  p[0] = v;
d575 1
a575 1
wbat_any (memory, x, value, maskb)
d578 2
a579 4
  unsigned char *p = memory + (x & maskb);
  if (x > 0x5000000)
    IOMEM (x, 1, value);
  BUSERROR(x, maskb);
d584 4
a587 2
static void INLINE 
wlat_big (memory, x, value, maskl)
d590 2
a591 3
  int v = value;
  unsigned char *p = memory + ((x) & maskl);
  BUSERROR(x, maskl);
d593 1
a593 4
  p[0] = v >> 24;
  p[1] = v >> 16;
  p[2] = v >> 8;
  p[3] = v;
d596 2
a597 2
static void INLINE 
wwat_big (memory, x, value, maskw)
d599 1
d601 2
a602 3
  int v = value;
  unsigned char *p = memory + ((x) & maskw);
  BUSERROR(x, maskw);
d604 1
a604 2
  p[0] = v >> 8;
  p[1] = v;
d607 3
a609 3
static void INLINE 
wbat_big (memory, x, value, maskb)
     unsigned char *memory;
d611 1
a611 2
  unsigned char *p = memory + (x & maskb);
  BUSERROR(x, maskb);
d613 1
a613 3
  if (x > 0x5000000)
    IOMEM (x, 1, value);
  p[0] = value;
a615 2
/* Read functions */

d617 1
a617 1
rlat_little (memory, x, maskl)
d620 2
a621 2
  unsigned char *p = memory + ((x) & maskl);
  BUSERROR(x, maskl);
d623 1
a623 1
  return (p[3] << 24) | (p[2] << 16) | (p[1] << 8) | p[0];
d626 19
a644 3
static int INLINE 
rwat_little (memory, x, maskw)
     unsigned char *memory;
d646 10
a655 2
  unsigned char *p = memory + ((x) & maskw);
  BUSERROR(x, maskw);
d657 17
a673 1
  return (p[1] << 8) | p[0];
d676 4
a679 3
static int INLINE 
rbat_any (memory, x, maskb)
     unsigned char *memory;
d681 1
a681 2
  unsigned char *p = memory + ((x) & maskb);
  BUSERROR(x, maskb);
d683 2
a684 1
  return p[0];
d687 4
a690 3
static int INLINE 
rlat_big (memory, x, maskl)
     unsigned char *memory;
d692 1
a692 2
  unsigned char *p = memory + ((x) & maskl);
  BUSERROR(x, maskl);
d694 2
a695 1
  return (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
d698 4
a701 3
static int INLINE 
rwat_big (memory, x, maskw)
     unsigned char *memory;
d703 1
a703 2
  unsigned char *p = memory + ((x) & maskw);
  BUSERROR(x, maskw);
d705 2
a706 1
  return (p[0] << 8) | p[1];
d709 5
a713 6
#define RWAT(x) 	(little_endian ? rwat_little(memory, x, maskw): rwat_big(memory, x, maskw))
#define RLAT(x) 	(little_endian ? rlat_little(memory, x, maskl): rlat_big(memory, x, maskl))
#define RBAT(x)         (rbat_any (memory, x, maskb))
#define WWAT(x,v) 	(little_endian ? wwat_little(memory, x, v, maskw): wwat_big(memory, x, v, maskw))
#define WLAT(x,v) 	(little_endian ? wlat_little(memory, x, v, maskl): wlat_big(memory, x, v, maskl))
#define WBAT(x,v)       (wbat_any (memory, x, v, maskb))
d715 3
a717 3
#define RUWAT(x)  (RWAT(x) & 0xffff)
#define RSWAT(x)  ((short)(RWAT(x)))
#define RSBAT(x)  (SEXT(RBAT(x)))
d719 5
d725 3
d729 5
d735 3
a737 1
#define MA(n) do { memstalls += (((pc & 3) != 0) ? (n) : ((n) - 1)); } while (0)
d742 11
d754 1
a754 1
#define Delay_Slot(TEMPPC)  	iword = RUWAT(TEMPPC); goto top;
d756 25
a780 1
int empty[16];
d786 2
d854 17
a870 16
static void
swap (memory, n)
     unsigned char *memory;
     int n;
{
  int little_endian = target_little_endian;
  WLAT (0, n);
}

static void
swap16 (memory, n)
     unsigned char *memory;
     int n;
{
  int little_endian = target_little_endian;
  WWAT (0, n);
d879 3
a881 3
      char b[4];
      swap (b, n);
      fwrite (b, 4, 1, profile_file);
d889 3
a891 3
  char b[4];
  swap16 (b, n);
  fwrite (b, 2, 1, profile_file);
d903 36
d942 1
a942 1
trap (i, regs, memory, maskl, maskw, little_endian)
d953 1
a953 1
      saved_state.asregs.exception = SIGQUIT;
d969 3
d978 1
d981 3
a983 10
	      char *buf;
	      int host_fd[2];

	      buf = ptr (regs[5]);

	      regs[0] = pipe (host_fd);

	      WLAT (buf, host_fd[0]);
	      buf += 4;
	      WLAT (buf, host_fd[1]);
d990 1
a990 1
#endif
d993 4
a996 1
	    regs[0] = callback->read (callback, regs[5], ptr (regs[6]), regs[7]);
d999 1
d1004 1
d1013 7
a1019 2
	    regs[0] = callback->open (callback,ptr (regs[5]), regs[6]);
	    break;
d1022 1
a1022 1
	    saved_state.asregs.exception = SIGQUIT;
d1030 2
a1031 1
	      char *buf;
d1033 1
d1035 1
d1037 1
a1037 1
	      buf = ptr (regs[6]);
d1076 8
a1083 2
	    regs[0] = chown (ptr (regs[5]), regs[6], regs[7]);
	    break;
d1086 8
a1093 2
	    regs[0] = chmod (ptr (regs[5]), regs[6]);
	    break;
d1095 10
a1104 4
	    /* Cast the second argument to void *, to avoid type mismatch
	       if a prototype is present.  */
	    regs[0] = utime (ptr (regs[5]), (void *) ptr (regs[6]));
	    break;
d1115 1
a1115 1
      saved_state.asregs.exception = SIGTRAP;
d1128 1
a1128 1
  saved_state.asregs.exception = SIGINT;
d1262 1
a1262 1
macw (regs, memory, n, m)
d1266 1
a1267 1
  int little_endian = target_little_endian;
d1299 44
d1374 86
d1528 1
a1528 1
  saved_state.asregs.exception = SIGINT;
d1537 3
a1539 1
  register unsigned int pc;
d1548 3
a1550 1
  register int little_endian = target_little_endian;
a1554 1
  extern unsigned char sh_jump_table0[];
d1556 1
a1556 1
  register unsigned char *jump_table = sh_jump_table0;
d1560 1
d1562 1
d1564 3
a1566 3
  register int maskb = ((saved_state.asregs.msize - 1) & ~0);
  register int maskw = ((saved_state.asregs.msize - 1) & ~1);
  register int maskl = ((saved_state.asregs.msize - 1) & ~3);
d1574 1
d1577 1
d1579 3
a1581 8
  if (step)
    {
      saved_state.asregs.exception = SIGTRAP;
    }
  else
    {
      saved_state.asregs.exception = 0;
    }
d1583 3
a1585 2
  pc = saved_state.asregs.pc;
  PR = saved_state.asregs.pr;
d1596 15
a1610 1
  do
d1612 1
a1612 1
      register unsigned int iword = RUWAT (pc);
d1614 2
a1615 1
      register unsigned int nia = pc + 2;
d1624 1
a1624 1
      pc = nia;
d1628 1
a1628 1
	  pollcount = 1000;
d1648 1
a1648 1
	      int n = pc >> PROFILE_SHIFT;
d1660 12
a1671 1
  while (!saved_state.asregs.exception);
d1676 1
a1676 1
      pc -= 2;
d1678 3
d1687 4
a1690 4
  saved_state.asregs.pc = pc;
  /* restore the T and other cached SR bits */
  SET_SR (GET_SR());
  saved_state.asregs.pr = PR;
d1717 1
a1717 1
      saved_state.asregs.memory[MMASKB & (addr + i)] = buffer[i];
d1735 1
a1735 1
      buffer[i] = saved_state.asregs.memory[MMASKB & (addr + i)];
a1739 2
/* We have to add one to RN as an index into asints because of the padding
   added at the start of asregs.  */
d1747 2
a1748 1
  int little_endian;
d1750 99
a1848 6
  little_endian = target_little_endian;
  if (&saved_state.asints[rn+1]
      == &saved_state.asregs.fpscr)
    set_fpscr1 (RLAT(0));
  else
    saved_state.asints[rn+1] = RLAT(0);
d1859 2
a1860 1
  int little_endian;
d1862 97
a1958 2
  little_endian = target_little_endian;
  WLAT (0, saved_state.asints[rn+1]);
d2048 8
d2082 11
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a58 4
/* Define the rate at which the simulator should poll the host
   for a quit. */
#define POLL_QUIT_INTERVAL 0x60000

a63 4
    /* On targets like sparc-sun-solaris, fregs will be aligned on a 64 bit
       boundary (because of the d member).  To avoid padding between
       registers - which whould make the job of sim_fetch_register harder,
       we add padding at the start.  */
d87 1
a87 1
    fregs[2];
d224 2
a225 23
#define FPSCR_MASK_FR (1 << 21)
#define FPSCR_MASK_SZ (1 << 20)
#define FPSCR_MASK_PR (1 << 19)

#define FPSCR_FR  ((GET_FPSCR() & FPSCR_MASK_FR) != 0)
#define FPSCR_SZ  ((GET_FPSCR() & FPSCR_MASK_SZ) != 0)
#define FPSCR_PR  ((GET_FPSCR() & FPSCR_MASK_PR) != 0)

static void
set_fpscr1 (x)
	int x;
{
  int old = saved_state.asregs.fpscr;
  saved_state.asregs.fpscr = (x);
  /* swap the floating point register banks */
  if ((saved_state.asregs.fpscr ^ old) & FPSCR_MASK_FR)
    {
      union fregs_u tmpf = saved_state.asregs.fregs[0];
      saved_state.asregs.fregs[0] = saved_state.asregs.fregs[1];
      saved_state.asregs.fregs[1] = tmpf;
    }
}

a226 4
#define SET_FPSCR(x) \
do { \
  set_fpscr1 (x); \
} while (0)
a234 15
int
special_address (addr, bits_written, data)
     void *addr;
     int bits_written, data;
{
  if ((unsigned) addr >> 24 == 0xf0 && bits_written == 32 && (data & 1) == 0)
    /* This invalidates (if not associative) or might invalidate
       (if associative) an instruction cache line.  This is used for
       trampolines.  Since we don't simulate the cache, this is a no-op
       as far as the simulator is concerned.  */
    return 1;
  /* We can't do anything useful with the other stuff, so fail.  */
  return 0;
}

d247 2
a248 8
#define BUSERROR(addr, mask, bits_written, data) \
  if (addr & ~mask) \
    { \
      if (special_address (addr, bits_written, data)) \
	return; \
      saved_state.asregs.exception = SIGBUS; \
      bp_holder (); \
    }
d279 2
a280 45
#define DR(n) (get_dr (n))
static double
get_dr (n)
     int n;
{
  n = (n & ~1);
  if (host_little_endian)
    {
      union
      {
	int i[2];
	double d;
      } dr;
      dr.i[1] = saved_state.asregs.fregs[0].i[n + 0];
      dr.i[0] = saved_state.asregs.fregs[0].i[n + 1];
      return dr.d;
    }
  else
    return (saved_state.asregs.fregs[0].d[n >> 1]);
}

#define SET_DR(n, EXP) set_dr ((n), (EXP))
static void
set_dr (n, exp)
     int n;
     double exp;
{
  n = (n & ~1);
  if (host_little_endian)
    {
      union
      {
	int i[2];
	double d;
      } dr;
      dr.d = exp;
      saved_state.asregs.fregs[0].i[n + 0] = dr.i[1];
      saved_state.asregs.fregs[0].i[n + 1] = dr.i[0];
    }
  else
    saved_state.asregs.fregs[0].d[n >> 1] = exp;
}

#define SET_FI(n,EXP) (saved_state.asregs.fregs[0].i[(n)] = (EXP))
#define FI(n) (saved_state.asregs.fregs[0].i[(n)])
d282 2
a283 2
#define FR(n) (saved_state.asregs.fregs[0].f[(n)])
#define SET_FR(n,EXP) (saved_state.asregs.fregs[0].f[(n)] = (EXP))
d285 3
a287 43
#define XD_TO_XF(n) ((((n) & 1) << 5) | ((n) & 0x1e))
#define XF(n) (saved_state.asregs.fregs[(n) >> 5].i[(n) & 0x1f])
#define SET_XF(n,EXP) (saved_state.asregs.fregs[(n) >> 5].i[(n) & 0x1f] = (EXP))


#define FP_OP(n, OP, m) \
{ \
  if (FPSCR_PR) \
    { \
      if (((n) & 1) || ((m) & 1)) \
	saved_state.asregs.exception = SIGILL; \
      else \
	SET_DR(n, (DR(n) OP DR(m))); \
    } \
  else \
    SET_FR(n, (FR(n) OP FR(m))); \
} while (0)

#define FP_UNARY(n, OP) \
{ \
  if (FPSCR_PR) \
    { \
      if ((n) & 1) \
	saved_state.asregs.exception = SIGILL; \
      else \
	SET_DR(n, (OP (DR(n)))); \
    } \
  else \
    SET_FR(n, (OP (FR(n)))); \
} while (0)

#define FP_CMP(n, OP, m) \
{ \
  if (FPSCR_PR) \
    { \
      if (((n) & 1) || ((m) & 1)) \
	saved_state.asregs.exception = SIGILL; \
      else \
	SET_SR_T (DR(n) OP DR(m)); \
    } \
  else \
    SET_SR_T (FR(n) OP FR(m)); \
} while (0)
d297 1
a297 1
  BUSERROR(x, maskl, 32, v);
d310 1
a310 1
  BUSERROR(x, maskw, 16, v);
d323 1
a323 1
  BUSERROR(x, maskb, 8, value);
d334 1
a334 1
  BUSERROR(x, maskl, 32, v);
d348 1
a348 1
  BUSERROR(x, maskw, 16, v);
d359 1
a359 1
  BUSERROR(x, maskb, 8, value);
d373 1
a373 1
  BUSERROR(x, maskl, -32, -1);
d383 1
a383 1
  BUSERROR(x, maskw, -16, -1);
d393 1
a393 1
  BUSERROR(x, maskb, -8, -1);
d403 1
a403 1
  BUSERROR(x, maskl, -32, -1);
d413 1
a413 1
  BUSERROR(x, maskw, -16, -1);
a428 26
#define RDAT(x, n) (do_rdat (memory, (x), (n), (little_endian)))
static int
do_rdat (memory, x, n, little_endian)
     char *memory;
     int x;
     int n;
     int little_endian;
{
  int f0;
  int f1;
  int i = (n & 1);
  int j = (n & ~1);
  if (little_endian)
    {
      f0 = rlat_little (memory, x + 0, maskl);
      f1 = rlat_little (memory, x + 4, maskl);
    }
  else
    {
      f0 = rlat_big (memory, x + 0, maskl);
      f1 = rlat_big (memory, x + 4, maskl);
    }
  saved_state.asregs.fregs[i].i[(j + 0)] = f0;
  saved_state.asregs.fregs[i].i[(j + 1)] = f1;
  return 0;
}
a429 26
#define WDAT(x, n) (do_wdat (memory, (x), (n), (little_endian)))
static int
do_wdat (memory, x, n, little_endian)
     char *memory;
     int x;
     int n;
     int little_endian;
{
  int f0;
  int f1;
  int i = (n & 1);
  int j = (n & ~1);
  f0 = saved_state.asregs.fregs[i].i[(j + 0)];
  f1 = saved_state.asregs.fregs[i].i[(j + 1)];
  if (little_endian)
    {
      wlat_little (memory, (x + 0), f0, maskl);
      wlat_little (memory, (x + 4), f1, maskl);
    }
  else
    {
      wlat_big (memory, (x + 0), f0, maskl);
      wlat_big (memory, (x + 4), f1, maskl);
    }
  return 0;
}
d1073 1
a1073 1
	  pollcount = POLL_QUIT_INTERVAL;
@

