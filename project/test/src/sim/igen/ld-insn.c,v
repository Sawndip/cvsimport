head	1.13;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.13
	gdb_7_6-2013-04-26-release:1.13
	gdb_7_6-branch:1.13.0.2
	gdb_7_6-2013-03-12-branchpoint:1.13
	gdb_7_5_1-2012-11-29-release:1.12
	gdb_7_5-2012-08-17-release:1.12
	gdb_7_5-branch:1.12.0.2
	gdb_7_5-2012-07-18-branchpoint:1.12
	gdb_7_4_1-2012-04-26-release:1.11.2.1
	gdb_7_4-2012-01-24-release:1.11.2.1
	gdb_7_4-branch:1.11.0.2
	gdb_7_4-2011-12-13-branchpoint:1.11
	gdb_7_3_1-2011-09-04-release:1.9
	gdb_7_3-2011-07-26-release:1.9
	gdb_7_3-branch:1.9.0.2
	gdb_7_3-2011-04-01-branchpoint:1.9
	gdb_7_2-2010-09-02-release:1.8
	gdb_7_2-branch:1.8.0.4
	gdb_7_2-2010-07-07-branchpoint:1.8
	gdb_7_1-2010-03-18-release:1.8
	gdb_7_1-branch:1.8.0.2
	gdb_7_1-2010-02-18-branchpoint:1.8
	gdb_7_0_1-2009-12-22-release:1.7
	gdb_7_0-2009-10-06-release:1.7
	gdb_7_0-branch:1.7.0.4
	gdb_7_0-2009-09-16-branchpoint:1.7
	arc-sim-20090309:1.6
	msnyder-checkpoint-072509-branch:1.7.0.2
	msnyder-checkpoint-072509-branchpoint:1.7
	arc-insight_6_8-branch:1.6.0.16
	arc-insight_6_8-branchpoint:1.6
	insight_6_8-branch:1.6.0.14
	insight_6_8-branchpoint:1.6
	reverse-20081226-branch:1.6.0.12
	reverse-20081226-branchpoint:1.6
	multiprocess-20081120-branch:1.6.0.10
	multiprocess-20081120-branchpoint:1.6
	reverse-20080930-branch:1.6.0.8
	reverse-20080930-branchpoint:1.6
	reverse-20080717-branch:1.6.0.6
	reverse-20080717-branchpoint:1.6
	msnyder-reverse-20080609-branch:1.6.0.4
	msnyder-reverse-20080609-branchpoint:1.6
	drow-reverse-20070409-branch:1.4.0.2
	drow-reverse-20070409-branchpoint:1.4
	gdb_6_8-2008-03-27-release:1.6
	gdb_6_8-branch:1.6.0.2
	gdb_6_8-2008-02-26-branchpoint:1.6
	gdb_6_7_1-2007-10-29-release:1.5
	gdb_6_7-2007-10-10-release:1.5
	gdb_6_7-branch:1.5.0.2
	gdb_6_7-2007-09-07-branchpoint:1.5
	insight_6_6-20070208-release:1.3
	gdb_6_6-2006-12-18-release:1.3
	gdb_6_6-branch:1.3.0.88
	gdb_6_6-2006-11-15-branchpoint:1.3
	insight_6_5-20061003-release:1.3
	gdb-csl-symbian-6_4_50_20060226-12:1.3
	gdb-csl-sourcerygxx-3_4_4-25:1.3
	nickrob-async-20060828-mergepoint:1.3
	gdb-csl-symbian-6_4_50_20060226-11:1.3
	gdb-csl-sourcerygxx-4_1-17:1.3
	gdb-csl-20060226-branch-local-2:1.3
	gdb-csl-sourcerygxx-4_1-14:1.3
	gdb-csl-sourcerygxx-4_1-13:1.3
	gdb-csl-sourcerygxx-4_1-12:1.3
	gdb-csl-sourcerygxx-3_4_4-21:1.3
	gdb_6_5-20060621-release:1.3
	gdb-csl-sourcerygxx-4_1-9:1.3
	gdb-csl-sourcerygxx-4_1-8:1.3
	gdb-csl-sourcerygxx-4_1-7:1.3
	gdb-csl-arm-2006q1-6:1.3
	gdb-csl-sourcerygxx-4_1-6:1.3
	gdb-csl-symbian-6_4_50_20060226-10:1.3
	gdb-csl-symbian-6_4_50_20060226-9:1.3
	gdb-csl-symbian-6_4_50_20060226-8:1.3
	gdb-csl-coldfire-4_1-11:1.3
	gdb-csl-sourcerygxx-3_4_4-19:1.3
	gdb-csl-coldfire-4_1-10:1.3
	gdb_6_5-branch:1.3.0.86
	gdb_6_5-2006-05-14-branchpoint:1.3
	gdb-csl-sourcerygxx-4_1-5:1.3
	nickrob-async-20060513-branch:1.3.0.84
	nickrob-async-20060513-branchpoint:1.3
	gdb-csl-sourcerygxx-4_1-4:1.3
	msnyder-reverse-20060502-branch:1.3.0.82
	msnyder-reverse-20060502-branchpoint:1.3
	gdb-csl-morpho-4_1-4:1.3
	gdb-csl-sourcerygxx-3_4_4-17:1.3
	readline_5_1-import-branch:1.3.0.80
	readline_5_1-import-branchpoint:1.3
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.3
	gdb-csl-symbian-20060226-branch:1.3.0.78
	gdb-csl-symbian-20060226-branchpoint:1.3
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.3
	msnyder-reverse-20060331-branch:1.3.0.76
	msnyder-reverse-20060331-branchpoint:1.3
	gdb-csl-available-20060303-branch:1.3.0.74
	gdb-csl-available-20060303-branchpoint:1.3
	gdb-csl-20060226-branch:1.3.0.72
	gdb-csl-20060226-branchpoint:1.3
	gdb_6_4-20051202-release:1.3
	msnyder-fork-checkpoint-branch:1.3.0.70
	msnyder-fork-checkpoint-branchpoint:1.3
	gdb-csl-gxxpro-6_3-branch:1.3.0.68
	gdb-csl-gxxpro-6_3-branchpoint:1.3
	gdb_6_4-branch:1.3.0.66
	gdb_6_4-2005-11-01-branchpoint:1.3
	gdb-csl-arm-20051020-branch:1.3.0.64
	gdb-csl-arm-20051020-branchpoint:1.3
	msnyder-tracepoint-checkpoint-branch:1.3.0.62
	msnyder-tracepoint-checkpoint-branchpoint:1.3
	gdb-csl-arm-20050325-2005-q1b:1.3
	gdb-csl-arm-20050325-2005-q1a:1.3
	csl-arm-20050325-branch:1.3.0.60
	csl-arm-20050325-branchpoint:1.3
	gdb_6_3-20041109-release:1.3
	gdb_6_3-branch:1.3.0.56
	gdb_6_3-20041019-branchpoint:1.3
	drow_intercu-merge-20040921:1.3
	drow_intercu-merge-20040915:1.3
	jimb-gdb_6_2-e500-branch:1.3.0.58
	jimb-gdb_6_2-e500-branchpoint:1.3
	gdb_6_2-20040730-release:1.3
	gdb_6_2-branch:1.3.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.3
	gdb_6_1_1-20040616-release:1.3
	gdb_6_1-2004-04-05-release:1.3
	drow_intercu-merge-20040402:1.3
	drow_intercu-merge-20040327:1.3
	ezannoni_pie-20040323-branch:1.3.0.52
	ezannoni_pie-20040323-branchpoint:1.3
	cagney_tramp-20040321-mergepoint:1.3
	cagney_tramp-20040309-branch:1.3.0.50
	cagney_tramp-20040309-branchpoint:1.3
	gdb_6_1-branch:1.3.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.3
	drow_intercu-20040221-branch:1.3.0.46
	drow_intercu-20040221-branchpoint:1.3
	cagney_bfdfile-20040213-branch:1.3.0.44
	cagney_bfdfile-20040213-branchpoint:1.3
	drow-cplus-merge-20040208:1.3
	carlton_dictionary-20040126-merge:1.3
	cagney_bigcore-20040122-branch:1.3.0.42
	cagney_bigcore-20040122-branchpoint:1.3
	drow-cplus-merge-20040113:1.3
	drow-cplus-merge-20031224:1.3
	drow-cplus-merge-20031220:1.3
	carlton_dictionary-20031215-merge:1.3
	drow-cplus-merge-20031214:1.3
	carlton-dictionary-20031111-merge:1.3
	gdb_6_0-2003-10-04-release:1.3
	kettenis_sparc-20030918-branch:1.3.0.40
	kettenis_sparc-20030918-branchpoint:1.3
	carlton_dictionary-20030917-merge:1.3
	ezannoni_pie-20030916-branchpoint:1.3
	ezannoni_pie-20030916-branch:1.3.0.38
	cagney_x86i386-20030821-branch:1.3.0.36
	cagney_x86i386-20030821-branchpoint:1.3
	carlton_dictionary-20030805-merge:1.3
	carlton_dictionary-20030627-merge:1.3
	gdb_6_0-branch:1.3.0.34
	gdb_6_0-2003-06-23-branchpoint:1.3
	jimb-ppc64-linux-20030613-branch:1.3.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.3
	cagney_convert-20030606-branch:1.3.0.30
	cagney_convert-20030606-branchpoint:1.3
	cagney_writestrings-20030508-branch:1.3.0.28
	cagney_writestrings-20030508-branchpoint:1.3
	jimb-ppc64-linux-20030528-branch:1.3.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.3
	carlton_dictionary-20030523-merge:1.3
	cagney_fileio-20030521-branch:1.3.0.24
	cagney_fileio-20030521-branchpoint:1.3
	kettenis_i386newframe-20030517-mergepoint:1.3
	jimb-ppc64-linux-20030509-branch:1.3.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.3
	kettenis_i386newframe-20030504-mergepoint:1.3
	carlton_dictionary-20030430-merge:1.3
	kettenis_i386newframe-20030419-branch:1.3.0.20
	kettenis_i386newframe-20030419-branchpoint:1.3
	carlton_dictionary-20030416-merge:1.3
	cagney_frameaddr-20030409-mergepoint:1.3
	kettenis_i386newframe-20030406-branch:1.3.0.18
	kettenis_i386newframe-20030406-branchpoint:1.3
	cagney_frameaddr-20030403-branchpoint:1.3
	cagney_frameaddr-20030403-branch:1.3.0.16
	cagney_framebase-20030330-mergepoint:1.3
	cagney_framebase-20030326-branch:1.3.0.14
	cagney_framebase-20030326-branchpoint:1.3
	cagney_lazyid-20030317-branch:1.3.0.12
	cagney_lazyid-20030317-branchpoint:1.3
	kettenis-i386newframe-20030316-mergepoint:1.3
	offbyone-20030313-branch:1.3.0.10
	offbyone-20030313-branchpoint:1.3
	kettenis-i386newframe-20030308-branch:1.3.0.8
	kettenis-i386newframe-20030308-branchpoint:1.3
	carlton_dictionary-20030305-merge:1.3
	cagney_offbyone-20030303-branch:1.3.0.6
	cagney_offbyone-20030303-branchpoint:1.3
	carlton_dictionary-20030207-merge:1.3
	interps-20030202-branch:1.3.0.4
	interps-20030202-branchpoint:1.3
	cagney-unwind-20030108-branch:1.3.0.2
	cagney-unwind-20030108-branchpoint:1.3
	carlton_dictionary-20021223-merge:1.3
	gdb_5_3-2002-12-12-release:1.1.1.1.26.1
	carlton_dictionary-20021115-merge:1.1.1.1
	kseitz_interps-20021105-merge:1.1.1.1
	kseitz_interps-20021103-merge:1.1.1.1
	drow-cplus-merge-20021020:1.1.1.1
	drow-cplus-merge-20021025:1.1.1.1
	carlton_dictionary-20021025-merge:1.1.1.1
	carlton_dictionary-20021011-merge:1.1.1.1
	drow-cplus-branch:1.1.1.1.0.30
	drow-cplus-branchpoint:1.1.1.1
	kseitz_interps-20020930-merge:1.1.1.1
	carlton_dictionary-20020927-merge:1.1.1.1
	carlton_dictionary-branch:1.1.1.1.0.28
	carlton_dictionary-20020920-branchpoint:1.1.1.1
	gdb_5_3-branch:1.1.1.1.0.26
	gdb_5_3-2002-09-04-branchpoint:1.1.1.1
	kseitz_interps-20020829-merge:1.1.1.1
	cagney_sysregs-20020825-branch:1.1.1.1.0.24
	cagney_sysregs-20020825-branchpoint:1.1.1.1
	readline_4_3-import-branch:1.1.1.1.0.22
	readline_4_3-import-branchpoint:1.1.1.1
	gdb_5_2_1-2002-07-23-release:1.1.1.1
	kseitz_interps-20020528-branch:1.1.1.1.0.20
	kseitz_interps-20020528-branchpoint:1.1.1.1
	cagney_regbuf-20020515-branch:1.1.1.1.0.18
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	jimb-macro-020506-branch:1.1.1.1.0.16
	jimb-macro-020506-branchpoint:1.1.1.1
	gdb_5_2-2002-04-29-release:1.1.1.1
	gdb_5_2-branch:1.1.1.1.0.14
	gdb_5_2-2002-03-03-branchpoint:1.1.1.1
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.12
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.10
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.8
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.13
date	2013.01.01.06.41.37;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2012.01.04.08.28.11;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2011.07.08.08.37.27;	author hp;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2011.07.08.02.27.18;	author hp;	state Exp;
branches;
next	1.9;

1.9
date	2011.01.01.15.34.00;	author brobecke;	state Exp;
branches;
next	1.8;

1.8
date	2010.01.01.10.03.30;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.14.10.53.07;	author brobecke;	state Exp;
branches;
next	1.6;

1.6
date	2008.01.01.22.53.24;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2007.08.24.14.28.36;	author brobecke;	state Exp;
branches;
next	1.4;

1.4
date	2007.01.09.17.59.18;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.22.04.20.49;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2002.11.22.04.09.40;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.05;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.11.2.1
date	2012.01.06.04.54.49;	author brobecke;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.35.05;	author shebs;	state Exp;
branches
	1.1.1.1.26.1
	1.1.1.1.28.1
	1.1.1.1.30.1;
next	;

1.1.1.1.26.1
date	2002.11.22.04.26.42;	author cagney;	state Exp;
branches;
next	;

1.1.1.1.28.1
date	2002.12.23.19.39.55;	author carlton;	state Exp;
branches;
next	;

1.1.1.1.30.1
date	2003.12.14.20.28.24;	author drow;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* The IGEN simulator generator for GDB, the GNU Debugger.

   Copyright 2002-2013 Free Software Foundation, Inc.

   Contributed by Andrew Cagney.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */


#include "misc.h"
#include "lf.h"
#include "table.h"
#include "filter.h"
#include "igen.h"
#include "ld-insn.h"

static insn_word_entry *
parse_insn_word (line_ref *line, char *string, int word_nr)
{
  char *chp;
  insn_word_entry *word = ZALLOC (insn_word_entry);

  /* create a leading sentinal */
  word->first = ZALLOC (insn_field_entry);
  word->first->first = -1;
  word->first->last = -1;
  word->first->width = 0;

  /* and a trailing sentinal */
  word->last = ZALLOC (insn_field_entry);
  word->last->first = options.insn_bit_size;
  word->last->last = options.insn_bit_size;
  word->last->width = 0;

  /* link them together */
  word->first->next = word->last;
  word->last->prev = word->first;

  /* now work through the formats */
  chp = skip_spaces (string);

  while (*chp != '\0')
    {
      char *start_pos;
      int strlen_pos;
      char *start_val;
      int strlen_val;
      insn_field_entry *new_field;

      /* create / link in the new field */
      new_field = ZALLOC (insn_field_entry);
      new_field->next = word->last;
      new_field->prev = word->last->prev;
      new_field->next->prev = new_field;
      new_field->prev->next = new_field;
      new_field->word_nr = word_nr;

      /* break out the first field (if present) */
      start_pos = chp;
      chp = skip_to_separator (chp, ".,!");
      strlen_pos = back_spaces (start_pos, chp) - start_pos;

      /* break out the second field (if present) */
      if (*chp != '.')
	{
	  /* assume what was specified was the value (and not the start
	     position).  Assume the value length implicitly specifies
	     the number of bits */
	  start_val = start_pos;
	  strlen_val = strlen_pos;
	  start_pos = "";
	  strlen_pos = 0;
	}
      else
	{
	  chp++;		/* skip `.' */
	  chp = skip_spaces (chp);
	  start_val = chp;
	  if (*chp == '/' || *chp == '*')
	    {
	      do
		{
		  chp++;
		}
	      while (*chp == '/' || *chp == '*');
	    }
	  else if (isalpha (*start_val))
	    {
	      do
		{
		  chp++;
		}
	      while (isalnum (*chp) || *chp == '_');
	    }
	  else if (isdigit (*start_val))
	    {
	      do
		{
		  chp++;
		}
	      while (isalnum (*chp));
	    }
	  strlen_val = chp - start_val;
	  chp = skip_spaces (chp);
	}
      if (strlen_val == 0)
	error (line, "Empty value field\n");

      /* break out any conditional fields - { [ "!" | "=" [ <value> | <field-name> } */
      while (*chp == '!' || *chp == '=')
	{
	  char *start;
	  char *end;
	  int len;
	  insn_field_cond *new_cond = ZALLOC (insn_field_cond);

	  /* determine the conditional test */
	  switch (*chp)
	    {
	    case '=':
	      new_cond->test = insn_field_cond_eq;
	      break;
	    case '!':
	      new_cond->test = insn_field_cond_ne;
	      break;
	    default:
	      ASSERT (0);
	    }

	  /* save the value */
	  chp++;
	  chp = skip_spaces (chp);
	  start = chp;
	  chp = skip_to_separator (chp, "+,:!=");
	  end = back_spaces (start, chp);
	  len = end - start;
	  if (len == 0)
	    error (line, "Missing or invalid conditional value\n");
	  new_cond->string = NZALLOC (char, len + 1);
	  strncpy (new_cond->string, start, len);

	  /* determine the conditional type */
	  if (isdigit (*start))
	    {
	      /* [ "!" | "=" ] <value> */
	      new_cond->type = insn_field_cond_value;
	      new_cond->value = a2i (new_cond->string);
	    }
	  else
	    {
	      /* [ "!" | "=" ] <field>  - check field valid */
	      new_cond->type = insn_field_cond_field;
	      /* new_cond->field is determined in later */
	    }

	  /* Only a single `=' is permitted. */
	  if ((new_cond->test == insn_field_cond_eq
	       && new_field->conditions != NULL)
	      || (new_field->conditions != NULL
		  && new_field->conditions->test == insn_field_cond_eq))
	    error (line, "Only single conditional when `=' allowed\n");

	  /* insert it */
	  {
	    insn_field_cond **last = &new_field->conditions;
	    while (*last != NULL)
	      last = &(*last)->next;
	    *last = new_cond;
	  }
	}

      /* NOW verify that the field was finished */
      if (*chp == ',')
	{
	  chp = skip_spaces (chp + 1);
	  if (*chp == '\0')
	    error (line, "empty field\n");
	}
      else if (*chp != '\0')
	{
	  error (line, "Missing field separator\n");
	}

      /* copy the value */
      new_field->val_string = NZALLOC (char, strlen_val + 1);
      strncpy (new_field->val_string, start_val, strlen_val);
      if (isdigit (new_field->val_string[0]))
	{
	  if (strlen_pos == 0)
	    {
	      /* when the length/pos field is omited, an integer field
	         is always binary */
	      unsigned64 val = 0;
	      int i;
	      for (i = 0; i < strlen_val; i++)
		{
		  if (new_field->val_string[i] != '0'
		      && new_field->val_string[i] != '1')
		    error (line, "invalid binary field %s\n",
			   new_field->val_string);
		  val = (val << 1) + (new_field->val_string[i] == '1');
		}
	      new_field->val_int = val;
	      new_field->type = insn_field_int;
	    }
	  else
	    {
	      new_field->val_int = a2i (new_field->val_string);
	      new_field->type = insn_field_int;
	    }
	}
      else if (new_field->val_string[0] == '/')
	{
	  new_field->type = insn_field_reserved;
	}
      else if (new_field->val_string[0] == '*')
	{
	  new_field->type = insn_field_wild;
	}
      else
	{
	  new_field->type = insn_field_string;
	  if (filter_is_member (word->field_names, new_field->val_string))
	    error (line, "Field name %s is duplicated\n",
		   new_field->val_string);
	  filter_parse (&word->field_names, new_field->val_string);
	}
      if (new_field->type != insn_field_string
	  && new_field->conditions != NULL)
	error (line, "Conditionals can only be applied to named fields\n");

      /* the copy the position */
      new_field->pos_string = NZALLOC (char, strlen_pos + 1);
      strncpy (new_field->pos_string, start_pos, strlen_pos);
      if (strlen_pos == 0)
	{
	  new_field->first = new_field->prev->last + 1;
	  if (new_field->first == 0	/* first field */
	      && *chp == '\0'	/* no further fields */
	      && new_field->type == insn_field_string)
	    {
	      /* A single string without any position, assume that it
	         represents the entire instruction word */
	      new_field->width = options.insn_bit_size;
	    }
	  else
	    {
	      /* No explicit width/position, assume value implicitly
	         supplies the width */
	      new_field->width = strlen_val;
	    }
	  new_field->last = new_field->first + new_field->width - 1;
	  if (new_field->last >= options.insn_bit_size)
	    error (line, "Bit position %d exceed instruction bit size (%d)\n",
		   new_field->last, options.insn_bit_size);
	}
      else if (options.insn_specifying_widths)
	{
	  new_field->first = new_field->prev->last + 1;
	  new_field->width = a2i (new_field->pos_string);
	  new_field->last = new_field->first + new_field->width - 1;
	  if (new_field->last >= options.insn_bit_size)
	    error (line, "Bit position %d exceed instruction bit size (%d)\n",
		   new_field->last, options.insn_bit_size);
	}
      else
	{
	  new_field->first = target_a2i (options.hi_bit_nr,
					 new_field->pos_string);
	  new_field->last = new_field->next->first - 1;	/* guess */
	  new_field->width = new_field->last - new_field->first + 1;	/* guess */
	  new_field->prev->last = new_field->first - 1;	/*fix */
	  new_field->prev->width = new_field->first - new_field->prev->first;	/*fix */
	}
    }

  /* fiddle first/last so that the sentinals disapear */
  ASSERT (word->first->last < 0);
  ASSERT (word->last->first >= options.insn_bit_size);
  word->first = word->first->next;
  word->last = word->last->prev;

  /* check that the last field goes all the way to the last bit */
  if (word->last->last != options.insn_bit_size - 1)
    {
      if (options.warn.width)
	options.warning (line, "Instruction format is not %d bits wide\n",
			 options.insn_bit_size);
      word->last->last = options.insn_bit_size - 1;
    }

  /* now go over this again, pointing each bit position at a field
     record */
  {
    insn_field_entry *field;
    for (field = word->first;
	 field->last < options.insn_bit_size; field = field->next)
      {
	int i;
	for (i = field->first; i <= field->last; i++)
	  {
	    word->bit[i] = ZALLOC (insn_bit_entry);
	    word->bit[i]->field = field;
	    switch (field->type)
	      {
	      case insn_field_invalid:
		ASSERT (0);
		break;
	      case insn_field_int:
		word->bit[i]->mask = 1;
		word->bit[i]->value = ((field->val_int
					& ((insn_uint) 1 <<
					   (field->last - i))) != 0);
	      case insn_field_reserved:
	      case insn_field_wild:
	      case insn_field_string:
		/* if we encounter a constant conditional, encode
		   their bit value. */
		if (field->conditions != NULL
		    && field->conditions->test == insn_field_cond_eq
		    && field->conditions->type == insn_field_cond_value)
		  {
		    word->bit[i]->mask = 1;
		    word->bit[i]->value = ((field->conditions->value
					    & ((insn_uint) 1 <<
					       (field->last - i))) != 0);
		  }
		break;
	      }
	  }
      }
  }

  return word;
}


static void
parse_insn_words (insn_entry * insn, char *formats)
{
  insn_word_entry **last_word = &insn->words;
  char *chp;

  /* now work through the formats */
  insn->nr_words = 0;
  chp = formats;

  while (1)
    {
      char *start_pos;
      char *end_pos;
      int strlen_pos;
      char *format;
      insn_word_entry *new_word;

      /* skip leading spaces */
      chp = skip_spaces (chp);

      /* break out the format */
      start_pos = chp;
      chp = skip_to_separator (chp, "+");
      end_pos = back_spaces (start_pos, chp);
      strlen_pos = end_pos - start_pos;

      /* check that something was there */
      if (strlen_pos == 0)
	error (insn->line, "missing or empty instruction format\n");

      /* parse the field */
      format = NZALLOC (char, strlen_pos + 1);
      strncpy (format, start_pos, strlen_pos);
      new_word = parse_insn_word (insn->line, format, insn->nr_words);
      insn->nr_words++;
      if (filter_is_common (insn->field_names, new_word->field_names))
	error (insn->line, "Field name duplicated between two words\n");
      filter_add (&insn->field_names, new_word->field_names);

      /* insert it */
      *last_word = new_word;
      last_word = &new_word->next;

      /* last format? */
      if (*chp == '\0')
	break;
      ASSERT (*chp == '+');
      chp++;
    }

  /* create a quick access array (indexed by word) of the same structure */
  {
    int i;
    insn_word_entry *word;
    insn->word = NZALLOC (insn_word_entry *, insn->nr_words + 1);
    for (i = 0, word = insn->words;
	 i < insn->nr_words; i++, word = word->next)
      insn->word[i] = word;
  }

  /* Go over all fields that have conditionals refering to other
     fields.  Link the fields up.  Verify that the two fields have the
     same size. Verify that the two fields are different */
  {
    int i;
    for (i = 0; i < insn->nr_words; i++)
      {
	insn_word_entry *word = insn->word[i];
	insn_field_entry *f;
	for (f = word->first; f->last < options.insn_bit_size; f = f->next)
	  {
	    insn_field_cond *cond;
	    for (cond = f->conditions; cond != NULL; cond = cond->next)
	      {
		if (cond->type == insn_field_cond_field)
		  {
		    int j;
		    if (strcmp (cond->string, f->val_string) == 0)
		      error (insn->line,
			     "Conditional `%s' of field `%s' refers to its self\n",
			     cond->string, f->val_string);
		    for (j = 0; j <= i && cond->field == NULL; j++)
		      {
			insn_word_entry *refered_word = insn->word[j];
			insn_field_entry *refered_field;
			for (refered_field = refered_word->first;
			     refered_field != NULL && cond->field == NULL;
			     refered_field = refered_field->next)
			  {
			    if (refered_field->type == insn_field_string
				&& strcmp (refered_field->val_string,
					   cond->string) == 0)
			      {
				/* found field being refered to by conditonal */
				cond->field = refered_field;
				/* check refered to and this field are
				   the same size */
				if (f->width != refered_field->width)
				  error (insn->line,
					 "Conditional `%s' of field `%s' should be of size %s\n",
					 cond->string, f->val_string,
					 refered_field->width);
			      }
			  }
		      }
		    if (cond->field == NULL)
		      error (insn->line,
			     "Conditional `%s' of field `%s' not yet defined\n",
			     cond->string, f->val_string);
		  }
	      }
	  }
      }
  }

}

typedef enum
{
  unknown_record = 0,
  insn_record,			/* default */
  code_record,
  cache_record,
  compute_record,
  scratch_record,
  option_record,
  string_function_record,
  function_record,
  internal_record,
  define_record,
  include_record,
  model_processor_record,
  model_macro_record,
  model_data_record,
  model_static_record,
  model_function_record,
  model_internal_record,
}
insn_record_type;

static const name_map insn_type_map[] = {
  {"option", option_record},
  {"cache", cache_record},
  {"compute", compute_record},
  {"scratch", scratch_record},
  {"define", define_record},
  {"include", include_record},
  {"%s", string_function_record},
  {"function", function_record},
  {"internal", internal_record},
  {"model", model_processor_record},
  {"model-macro", model_macro_record},
  {"model-data", model_data_record},
  {"model-static", model_static_record},
  {"model-internal", model_internal_record},
  {"model-function", model_function_record},
  {NULL, insn_record},
};


static int
record_is_old (table_entry *entry)
{
  if (entry->nr_fields > record_type_field
      && strlen (entry->field[record_type_field]) == 0)
    return 1;
  return 0;
}

static insn_record_type
record_type (table_entry *entry)
{
  switch (entry->type)
    {
    case table_code_entry:
      return code_record;

    case table_colon_entry:
      if (record_is_old (entry))
	{
	  /* old-format? */
	  if (entry->nr_fields > old_record_type_field)
	    {
	      int i = name2i (entry->field[old_record_type_field],
			      insn_type_map);
	      return i;
	    }
	  else
	    {
	      return unknown_record;
	    }
	}
      else if (entry->nr_fields > record_type_field
	       && entry->field[0][0] == '\0')
	{
	  /* new-format? */
	  int i = name2i (entry->field[record_type_field],
			  insn_type_map);
	  return i;
	}
      else
	return insn_record;	/* default */
    }
  return unknown_record;
}

static int
record_prefix_is (table_entry *entry, char ch, int nr_fields)
{
  if (entry->type != table_colon_entry)
    return 0;
  if (entry->nr_fields < nr_fields)
    return 0;
  if (entry->field[0][0] != ch && ch != '\0')
    return 0;
  return 1;
}

static table_entry *
parse_model_data_record (insn_table *isa,
			 table *file,
			 table_entry *record,
			 int nr_fields, model_data **list)
{
  table_entry *model_record = record;
  table_entry *code_record = NULL;
  model_data *new_data;
  if (record->nr_fields < nr_fields)
    error (record->line, "Incorrect number of fields\n");
  record = table_read (file);
  if (record->type == table_code_entry)
    {
      code_record = record;
      record = table_read (file);
    }
  /* create the new data record */
  new_data = ZALLOC (model_data);
  new_data->line = model_record->line;
  filter_parse (&new_data->flags,
		model_record->field[record_filter_flags_field]);
  new_data->entry = model_record;
  new_data->code = code_record;
  /* append it if not filtered out */
  if (!is_filtered_out (options.flags_filter,
			model_record->field[record_filter_flags_field])
      && !is_filtered_out (options.model_filter,
			   model_record->field[record_filter_models_field]))
    {
      while (*list != NULL)
	list = &(*list)->next;
      *list = new_data;
    }
  return record;
}


typedef enum
{
  insn_bit_size_option = 1,
  insn_specifying_widths_option,
  hi_bit_nr_option,
  flags_filter_option,
  model_filter_option,
  multi_sim_option,
  format_names_option,
  gen_delayed_branch,
  unknown_option,
}
option_names;

static const name_map option_map[] = {
  {"insn-bit-size", insn_bit_size_option},
  {"insn-specifying-widths", insn_specifying_widths_option},
  {"hi-bit-nr", hi_bit_nr_option},
  {"flags-filter", flags_filter_option},
  {"model-filter", model_filter_option},
  {"multi-sim", multi_sim_option},
  {"format-names", format_names_option},
  {"gen-delayed-branch", gen_delayed_branch},
  {NULL, unknown_option},
};

static table_entry *
parse_include_record (table *file, table_entry *record)
{
  /* parse the include record */
  if (record->nr_fields < nr_include_fields)
    error (record->line, "Incorrect nr fields for include record\n");
  /* process it */
  if (!is_filtered_out (options.flags_filter,
			record->field[record_filter_flags_field])
      && !is_filtered_out (options.model_filter,
			   record->field[record_filter_models_field]))
    {
      table_push (file, record->line, options.include,
		  record->field[include_filename_field]);
    }
  /* nb: can't read next record until after the file has been pushed */
  record = table_read (file);
  return record;
}


static table_entry *
parse_option_record (table *file, table_entry *record)
{
  table_entry *option_record;
  /* parse the option record */
  option_record = record;
  if (record->nr_fields < nr_option_fields)
    error (record->line, "Incorrect nr of fields for option record\n");
  record = table_read (file);
  /* process it */
  if (!is_filtered_out (options.flags_filter,
			option_record->field[record_filter_flags_field])
      && !is_filtered_out (options.model_filter,
			   option_record->field[record_filter_models_field]))
    {
      char *name = option_record->field[option_name_field];
      option_names option = name2i (name, option_map);
      char *value = option_record->field[option_value_field];
      switch (option)
	{
	case insn_bit_size_option:
	  {
	    options.insn_bit_size = a2i (value);
	    if (options.insn_bit_size < 0
		|| options.insn_bit_size > max_insn_bit_size)
	      error (option_record->line,
		     "Instruction bit size out of range\n");
	    if (options.hi_bit_nr != options.insn_bit_size - 1
		&& options.hi_bit_nr != 0)
	      error (option_record->line,
		     "insn-bit-size / hi-bit-nr conflict\n");
	    break;
	  }
	case insn_specifying_widths_option:
	  {
	    options.insn_specifying_widths = a2i (value);
	    break;
	  }
	case hi_bit_nr_option:
	  {
	    options.hi_bit_nr = a2i (value);
	    if (options.hi_bit_nr != 0
		&& options.hi_bit_nr != options.insn_bit_size - 1)
	      error (option_record->line,
		     "hi-bit-nr / insn-bit-size conflict\n");
	    break;
	  }
	case flags_filter_option:
	  {
	    filter_parse (&options.flags_filter, value);
	    break;
	  }
	case model_filter_option:
	  {
	    filter_parse (&options.model_filter, value);
	    break;
	  }
	case multi_sim_option:
	  {
	    options.gen.multi_sim = a2i (value);
	    break;
	  }
	case format_names_option:
	  {
	    filter_parse (&options.format_name_filter, value);
	    break;
	  }
	case gen_delayed_branch:
	  {
	    options.gen.delayed_branch = a2i (value);
	    break;
	  }
	case unknown_option:
	  {
	    error (option_record->line, "Unknown option - %s\n", name);
	    break;
	  }
	}
    }
  return record;
}


static table_entry *
parse_function_record (table *file,
		       table_entry *record,
		       function_entry ** list,
		       function_entry ** list_entry,
		       int is_internal, model_table *model)
{
  function_entry *new_function;
  new_function = ZALLOC (function_entry);
  new_function->line = record->line;
  new_function->is_internal = is_internal;
  /* parse the function header */
  if (record_is_old (record))
    {
      if (record->nr_fields < nr_old_function_fields)
	error (record->line, "Missing fields from (old) function record\n");
      new_function->type = record->field[old_function_typedef_field];
      new_function->type = record->field[old_function_typedef_field];
      if (record->nr_fields > old_function_param_field)
	new_function->param = record->field[old_function_param_field];
      new_function->name = record->field[old_function_name_field];
    }
  else
    {
      if (record->nr_fields < nr_function_fields)
	error (record->line, "Missing fields from function record\n");
      filter_parse (&new_function->flags,
		    record->field[record_filter_flags_field]);
      filter_parse (&new_function->models,
		    record->field[record_filter_models_field]);
      new_function->type = record->field[function_typedef_field];
      new_function->param = record->field[function_param_field];
      new_function->name = record->field[function_name_field];
    }
  record = table_read (file);
  /* parse any function-model records */
  while (record != NULL
	 && record_prefix_is (record, '*', nr_function_model_fields))
    {
      char *model_name = record->field[function_model_name_field] + 1;	/*skip `*' */
      filter_parse (&new_function->models, model_name);
      if (!filter_is_subset (model->processors, new_function->models))
	{
	  error (record->line, "machine model `%s' undefined\n", model_name);
	}
      record = table_read (file);
    }
  /* parse the function body */
  if (record->type == table_code_entry)
    {
      new_function->code = record;
      record = table_read (file);
    }
  /* insert it */
  if (!filter_is_subset (options.flags_filter, new_function->flags))
    {
      if (options.warn.discard)
	notify (new_function->line, "Discarding function %s - filter flags\n",
		new_function->name);
    }
  else if (new_function->models != NULL
	   && !filter_is_common (options.model_filter, new_function->models))
    {
      if (options.warn.discard)
	notify (new_function->line,
		"Discarding function %s - filter models\n",
		new_function->name);
    }
  else
    {
      while (*list != NULL)
	list = &(*list)->next;
      *list = new_function;
      if (list_entry != NULL)
	*list_entry = new_function;
    }
  /* done */
  return record;
}

static void
parse_insn_model_record (table *file,
			 table_entry *record,
			 insn_entry * insn, model_table *model)
{
  insn_model_entry **last_insn_model;
  insn_model_entry *new_insn_model = ZALLOC (insn_model_entry);
  /* parse it */
  new_insn_model->line = record->line;
  if (record->nr_fields > insn_model_unit_data_field)
    new_insn_model->unit_data = record->field[insn_model_unit_data_field];
  new_insn_model->insn = insn;
  /* parse the model names, verify that all were defined */
  new_insn_model->names = NULL;
  filter_parse (&new_insn_model->names,
		record->field[insn_model_name_field] + 1 /*skip `*' */ );
  if (new_insn_model->names == NULL)
    {
      /* No processor names - a generic model entry, enter it into all
         the non-empty fields */
      int index;
      for (index = 0; index < model->nr_models; index++)
	if (insn->model[index] == 0)
	  {
	    insn->model[index] = new_insn_model;
	  }
      /* also add the complete processor set to this processor's set */
      filter_add (&insn->processors, model->processors);
    }
  else
    {
      /* Find the corresponding master model record for each name so
         that they can be linked in. */
      int index;
      char *name = "";
      while (1)
	{
	  name = filter_next (new_insn_model->names, name);
	  if (name == NULL)
	    break;
	  index = filter_is_member (model->processors, name) - 1;
	  if (index < 0)
	    {
	      error (new_insn_model->line,
		     "machine model `%s' undefined\n", name);
	    }
	  /* store it in the corresponding model array entry */
	  if (insn->model[index] != NULL && insn->model[index]->names != NULL)
	    {
	      warning (new_insn_model->line,
		       "machine model `%s' previously defined\n", name);
	      error (insn->model[index]->line, "earlier definition\n");
	    }
	  insn->model[index] = new_insn_model;
	  /* also add the name to the instructions processor set as an
	     alternative lookup mechanism */
	  filter_parse (&insn->processors, name);
	}
    }
  /* link it in */
  last_insn_model = &insn->models;
  while ((*last_insn_model) != NULL)
    last_insn_model = &(*last_insn_model)->next;
  *last_insn_model = new_insn_model;
}


static void
parse_insn_mnemonic_record (table *file,
			    table_entry *record, insn_entry * insn)
{
  insn_mnemonic_entry **last_insn_mnemonic;
  insn_mnemonic_entry *new_insn_mnemonic = ZALLOC (insn_mnemonic_entry);
  /* parse it */
  new_insn_mnemonic->line = record->line;
  ASSERT (record->nr_fields > insn_mnemonic_format_field);
  new_insn_mnemonic->format = record->field[insn_mnemonic_format_field];
  ASSERT (new_insn_mnemonic->format[0] == '"');
  if (new_insn_mnemonic->format[strlen (new_insn_mnemonic->format) - 1] !=
      '"')
    error (new_insn_mnemonic->line,
	   "Missing closing double quote in mnemonic field\n");
  if (record->nr_fields > insn_mnemonic_condition_field)
    new_insn_mnemonic->condition =
      record->field[insn_mnemonic_condition_field];
  new_insn_mnemonic->insn = insn;
  /* insert it */
  last_insn_mnemonic = &insn->mnemonics;
  while ((*last_insn_mnemonic) != NULL)
    last_insn_mnemonic = &(*last_insn_mnemonic)->next;
  insn->nr_mnemonics++;
  *last_insn_mnemonic = new_insn_mnemonic;
}


static table_entry *
parse_macro_record (table *file, table_entry *record)
{
#if 1
  error (record->line, "Macros are not implemented");
#else
  /* parse the define record */
  if (record->nr_fields < nr_define_fields)
    error (record->line, "Incorrect nr fields for define record\n");
  /* process it */
  if (!is_filtered_out (options.flags_filter,
			record->field[record_filter_flags_field])
      && !is_filtered_out (options.model_filter,
			   record->field[record_filter_models_field]))
    {
      table_define (file,
		    record->line,
		    record->field[macro_name_field],
		    record->field[macro_args_field],
		    record->field[macro_expr_field]);
    }
  record = table_read (file);
#endif
  return record;
}


insn_table *
load_insn_table (char *file_name, cache_entry *cache)
{
  table *file = table_open (file_name);
  table_entry *record = table_read (file);

  insn_table *isa = ZALLOC (insn_table);
  model_table *model = ZALLOC (model_table);

  isa->model = model;
  isa->caches = cache;

  while (record != NULL)
    {

      switch (record_type (record))
	{

	case include_record:
	  {
	    record = parse_include_record (file, record);
	    break;
	  }

	case option_record:
	  {
	    if (isa->insns != NULL)
	      error (record->line, "Option after first instruction\n");
	    record = parse_option_record (file, record);
	    break;
	  }

	case string_function_record:
	  {
	    function_entry *function = NULL;
	    record = parse_function_record (file, record,
					    &isa->functions,
					    &function, 0 /*is-internal */ ,
					    model);
	    /* convert a string function record into an internal function */
	    if (function != NULL)
	      {
		char *name = NZALLOC (char,
				      (strlen ("str_")
				       + strlen (function->name) + 1));
		strcat (name, "str_");
		strcat (name, function->name);
		function->name = name;
		function->type = "const char *";
	      }
	    break;
	  }

	case function_record:	/* function record */
	  {
	    record = parse_function_record (file, record,
					    &isa->functions,
					    NULL, 0 /*is-internal */ ,
					    model);
	    break;
	  }

	case internal_record:
	  {
	    /* only insert it into the function list if it is unknown */
	    function_entry *function = NULL;
	    record = parse_function_record (file, record,
					    &isa->functions,
					    &function, 1 /*is-internal */ ,
					    model);
	    /* check what was inserted to see if a pseudo-instruction
	       entry also needs to be created */
	    if (function != NULL)
	      {
		insn_entry **insn = NULL;
		if (strcmp (function->name, "illegal") == 0)
		  {
		    /* illegal function save it away */
		    if (isa->illegal_insn != NULL)
		      {
			warning (function->line,
				 "Multiple illegal instruction definitions\n");
			error (isa->illegal_insn->line,
			       "Location of first illegal instruction\n");
		      }
		    else
		      insn = &isa->illegal_insn;
		  }
		if (insn != NULL)
		  {
		    *insn = ZALLOC (insn_entry);
		    (*insn)->line = function->line;
		    (*insn)->name = function->name;
		    (*insn)->code = function->code;
		  }
	      }
	    break;
	  }

	case scratch_record:	/* cache macro records */
	case cache_record:
	case compute_record:
	  {
	    cache_entry *new_cache;
	    /* parse the cache record */
	    if (record->nr_fields < nr_cache_fields)
	      error (record->line,
		     "Incorrect nr of fields for scratch/cache/compute record\n");
	    /* create it */
	    new_cache = ZALLOC (cache_entry);
	    new_cache->line = record->line;
	    filter_parse (&new_cache->flags,
			  record->field[record_filter_flags_field]);
	    filter_parse (&new_cache->models,
			  record->field[record_filter_models_field]);
	    new_cache->type = record->field[cache_typedef_field];
	    new_cache->name = record->field[cache_name_field];
	    filter_parse (&new_cache->original_fields,
			  record->field[cache_original_fields_field]);
	    new_cache->expression = record->field[cache_expression_field];
	    /* insert it but only if not filtered out */
	    if (!filter_is_subset (options.flags_filter, new_cache->flags))
	      {
		notify (new_cache->line,
			"Discarding cache entry %s - filter flags\n",
			new_cache->name);
	      }
	    else if (is_filtered_out (options.model_filter,
				      record->
				      field[record_filter_models_field]))
	      {
		notify (new_cache->line,
			"Discarding cache entry %s - filter models\n",
			new_cache->name);
	      }
	    else
	      {
		cache_entry **last;
		last = &isa->caches;
		while (*last != NULL)
		  last = &(*last)->next;
		*last = new_cache;
	      }
	    /* advance things */
	    record = table_read (file);
	    break;
	  }

	  /* model records */
	case model_processor_record:
	  {
	    model_entry *new_model;
	    /* parse the model */
	    if (record->nr_fields < nr_model_processor_fields)
	      error (record->line,
		     "Incorrect nr of fields for model record\n");
	    if (isa->insns != NULL)
	      error (record->line, "Model appears after first instruction\n");
	    new_model = ZALLOC (model_entry);
	    filter_parse (&new_model->flags,
			  record->field[record_filter_flags_field]);
	    new_model->line = record->line;
	    new_model->name = record->field[model_name_field];
	    new_model->full_name = record->field[model_full_name_field];
	    new_model->unit_data = record->field[model_unit_data_field];
	    /* only insert it if not filtered out */
	    if (!filter_is_subset (options.flags_filter, new_model->flags))
	      {
		notify (new_model->line,
			"Discarding processor model %s - filter flags\n",
			new_model->name);
	      }
	    else if (is_filtered_out (options.model_filter,
				      record->
				      field[record_filter_models_field]))
	      {
		notify (new_model->line,
			"Discarding processor model %s - filter models\n",
			new_model->name);
	      }
	    else if (filter_is_member (model->processors, new_model->name))
	      {
		error (new_model->line, "Duplicate processor model %s\n",
		       new_model->name);
	      }
	    else
	      {
		model_entry **last;
		last = &model->models;
		while (*last != NULL)
		  last = &(*last)->next;
		*last = new_model;
		/* count it */
		model->nr_models++;
		filter_parse (&model->processors, new_model->name);
	      }
	    /* advance things */
	    record = table_read (file);
	  }
	  break;

	case model_macro_record:
	  record = parse_model_data_record (isa, file, record,
					    nr_model_macro_fields,
					    &model->macros);
	  break;

	case model_data_record:
	  record = parse_model_data_record (isa, file, record,
					    nr_model_data_fields,
					    &model->data);
	  break;

	case model_static_record:
	  record = parse_function_record (file, record,
					  &model->statics,
					  NULL, 0 /*is internal */ ,
					  model);
	  break;

	case model_internal_record:
	  record = parse_function_record (file, record,
					  &model->internals,
					  NULL, 1 /*is internal */ ,
					  model);
	  break;

	case model_function_record:
	  record = parse_function_record (file, record,
					  &model->functions,
					  NULL, 0 /*is internal */ ,
					  model);
	  break;

	case insn_record:	/* instruction records */
	  {
	    insn_entry *new_insn;
	    char *format;
	    /* parse the instruction */
	    if (record->nr_fields < nr_insn_fields)
	      error (record->line,
		     "Incorrect nr of fields for insn record\n");
	    new_insn = ZALLOC (insn_entry);
	    new_insn->line = record->line;
	    filter_parse (&new_insn->flags,
			  record->field[record_filter_flags_field]);
	    /* save the format field.  Can't parse it until after the
	       filter-out checks.  Could be filtered out because the
	       format is invalid */
	    format = record->field[insn_word_field];
	    new_insn->format_name = record->field[insn_format_name_field];
	    if (options.format_name_filter != NULL
		&& !filter_is_member (options.format_name_filter,
				      new_insn->format_name))
	      error (new_insn->line,
		     "Unreconized instruction format name `%s'\n",
		     new_insn->format_name);
	    filter_parse (&new_insn->options,
			  record->field[insn_options_field]);
	    new_insn->name = record->field[insn_name_field];
	    record = table_read (file);
	    /* Parse any model/assember records */
	    new_insn->nr_models = model->nr_models;
	    new_insn->model =
	      NZALLOC (insn_model_entry *, model->nr_models + 1);
	    while (record != NULL)
	      {
		if (record_prefix_is (record, '*', nr_insn_model_fields))
		  parse_insn_model_record (file, record, new_insn, model);
		else
		  if (record_prefix_is (record, '"', nr_insn_mnemonic_fields))
		  parse_insn_mnemonic_record (file, record, new_insn);
		else
		  break;
		/* advance */
		record = table_read (file);
	      }
	    /* Parse the code record */
	    if (record != NULL && record->type == table_code_entry)
	      {
		new_insn->code = record;
		record = table_read (file);
	      }
	    else if (options.warn.unimplemented)
	      notify (new_insn->line, "unimplemented\n");
	    /* insert it */
	    if (!filter_is_subset (options.flags_filter, new_insn->flags))
	      {
		if (options.warn.discard)
		  notify (new_insn->line,
			  "Discarding instruction %s (flags-filter)\n",
			  new_insn->name);
	      }
	    else if (new_insn->processors != NULL
		     && options.model_filter != NULL
		     && !filter_is_common (options.model_filter,
					   new_insn->processors))
	      {
		/* only discard an instruction based in the processor
		   model when both the instruction and the options are
		   nonempty */
		if (options.warn.discard)
		  notify (new_insn->line,
			  "Discarding instruction %s (processor-model)\n",
			  new_insn->name);
	      }
	    else
	      {
		insn_entry **last;
		/* finish the parsing */
		parse_insn_words (new_insn, format);
		/* append it */
		last = &isa->insns;
		while (*last)
		  last = &(*last)->next;
		*last = new_insn;
		/* update global isa counters */
		isa->nr_insns++;
		if (isa->max_nr_words < new_insn->nr_words)
		  isa->max_nr_words = new_insn->nr_words;
		filter_add (&isa->flags, new_insn->flags);
		filter_add (&isa->options, new_insn->options);
	      }
	    break;
	  }

	case define_record:
	  record = parse_macro_record (file, record);
	  break;

	case unknown_record:
	case code_record:
	  error (record->line, "Unknown or unexpected entry\n");


	}
    }
  return isa;
}


void
print_insn_words (lf *file, insn_entry * insn)
{
  insn_word_entry *word = insn->words;
  if (word != NULL)
    {
      while (1)
	{
	  insn_field_entry *field = word->first;
	  while (1)
	    {
	      insn_field_cond *cond;

	      if (options.insn_specifying_widths)
		lf_printf (file, "%d.", field->width);
	      else
		lf_printf (file, "%d.",
			   i2target (options.hi_bit_nr, field->first));
	      switch (field->type)
		{
		case insn_field_invalid:
		  ASSERT (0);
		  break;
		case insn_field_int:
		  lf_printf (file, "0x%lx", (long) field->val_int);
		  break;
		case insn_field_reserved:
		  lf_printf (file, "/");
		  break;
		case insn_field_wild:
		  lf_printf (file, "*");
		  break;
		case insn_field_string:
		  lf_printf (file, "%s", field->val_string);

		  if (field->conditions == NULL)
		    break;

		  if (field->conditions->test == insn_field_cond_eq)
		    {
		      if (field->conditions->type == insn_field_cond_value)
			lf_printf (file, "=%ld",
				   (long) field->conditions->value);
		      else
			lf_printf (file, "=%s", field->conditions->string);

		      /* There can be only one equality condition.  */
		      ASSERT (field->conditions->next == NULL);
		      break;
		    }

		  for (cond = field->conditions;
		       cond != NULL;
		       cond = cond->next)
		    {
		      ASSERT (cond->test == insn_field_cond_ne);

		      if (cond->type == insn_field_cond_value)
			lf_printf (file, "!%ld", (long) cond->value);
		      else
			lf_printf (file, "!%s", cond->string);
		    }
		  break;
		}
	      if (field == word->last)
		break;
	      field = field->next;
	      lf_printf (file, ",");
	    }
	  word = word->next;
	  if (word == NULL)
	    break;
	  lf_printf (file, "+");
	}
    }
}



void
function_entry_traverse (lf *file,
			 function_entry * functions,
			 function_entry_handler * handler, void *data)
{
  function_entry *function;
  for (function = functions; function != NULL; function = function->next)
    {
      handler (file, function, data);
    }
}

void
insn_table_traverse_insn (lf *file,
			  insn_table *isa,
			  insn_entry_handler * handler, void *data)
{
  insn_entry *insn;
  for (insn = isa->insns; insn != NULL; insn = insn->next)
    {
      handler (file, isa, insn, data);
    }
}


static void
dump_function_entry (lf *file,
		     char *prefix, function_entry * entry, char *suffix)
{
  lf_printf (file, "%s(function_entry *) 0x%lx", prefix, (long) entry);
  if (entry != NULL)
    {
      dump_line_ref (file, "\n(line ", entry->line, ")");
      dump_filter (file, "\n(flags ", entry->flags, ")");
      lf_printf (file, "\n(type \"%s\")", entry->type);
      lf_printf (file, "\n(name \"%s\")", entry->name);
      lf_printf (file, "\n(param \"%s\")", entry->param);
      dump_table_entry (file, "\n(code ", entry->code, ")");
      lf_printf (file, "\n(is_internal %d)", entry->is_internal);
      lf_printf (file, "\n(next 0x%lx)", (long) entry->next);
    }
  lf_printf (file, "%s", suffix);
}

static void
dump_function_entries (lf *file,
		       char *prefix, function_entry * entry, char *suffix)
{
  lf_printf (file, "%s", prefix);
  lf_indent (file, +1);
  while (entry != NULL)
    {
      dump_function_entry (file, "\n(", entry, ")");
      entry = entry->next;
    }
  lf_indent (file, -1);
  lf_printf (file, "%s", suffix);
}

static char *
cache_entry_type_to_str (cache_entry_type type)
{
  switch (type)
    {
    case scratch_value:
      return "scratch";
    case cache_value:
      return "cache";
    case compute_value:
      return "compute";
    }
  ERROR ("Bad switch");
  return 0;
}

static void
dump_cache_entry (lf *file, char *prefix, cache_entry *entry, char *suffix)
{
  lf_printf (file, "%s(cache_entry *) 0x%lx", prefix, (long) entry);
  if (entry != NULL)
    {
      dump_line_ref (file, "\n(line ", entry->line, ")");
      dump_filter (file, "\n(flags ", entry->flags, ")");
      lf_printf (file, "\n(entry_type \"%s\")",
		 cache_entry_type_to_str (entry->entry_type));
      lf_printf (file, "\n(name \"%s\")", entry->name);
      dump_filter (file, "\n(original_fields ", entry->original_fields, ")");
      lf_printf (file, "\n(type \"%s\")", entry->type);
      lf_printf (file, "\n(expression \"%s\")", entry->expression);
      lf_printf (file, "\n(next 0x%lx)", (long) entry->next);
    }
  lf_printf (file, "%s", suffix);
}

void
dump_cache_entries (lf *file, char *prefix, cache_entry *entry, char *suffix)
{
  lf_printf (file, "%s", prefix);
  lf_indent (file, +1);
  while (entry != NULL)
    {
      dump_cache_entry (file, "\n(", entry, ")");
      entry = entry->next;
    }
  lf_indent (file, -1);
  lf_printf (file, "%s", suffix);
}

static void
dump_model_data (lf *file, char *prefix, model_data *entry, char *suffix)
{
  lf_printf (file, "%s(model_data *) 0x%lx", prefix, (long) entry);
  if (entry != NULL)
    {
      lf_indent (file, +1);
      dump_line_ref (file, "\n(line ", entry->line, ")");
      dump_filter (file, "\n(flags ", entry->flags, ")");
      dump_table_entry (file, "\n(entry ", entry->entry, ")");
      dump_table_entry (file, "\n(code ", entry->code, ")");
      lf_printf (file, "\n(next 0x%lx)", (long) entry->next);
      lf_indent (file, -1);
    }
  lf_printf (file, "%s", prefix);
}

static void
dump_model_datas (lf *file, char *prefix, model_data *entry, char *suffix)
{
  lf_printf (file, "%s", prefix);
  lf_indent (file, +1);
  while (entry != NULL)
    {
      dump_model_data (file, "\n(", entry, ")");
      entry = entry->next;
    }
  lf_indent (file, -1);
  lf_printf (file, "%s", suffix);
}

static void
dump_model_entry (lf *file, char *prefix, model_entry *entry, char *suffix)
{
  lf_printf (file, "%s(model_entry *) 0x%lx", prefix, (long) entry);
  if (entry != NULL)
    {
      lf_indent (file, +1);
      dump_line_ref (file, "\n(line ", entry->line, ")");
      dump_filter (file, "\n(flags ", entry->flags, ")");
      lf_printf (file, "\n(name \"%s\")", entry->name);
      lf_printf (file, "\n(full_name \"%s\")", entry->full_name);
      lf_printf (file, "\n(unit_data \"%s\")", entry->unit_data);
      lf_printf (file, "\n(next 0x%lx)", (long) entry->next);
      lf_indent (file, -1);
    }
  lf_printf (file, "%s", prefix);
}

static void
dump_model_entries (lf *file, char *prefix, model_entry *entry, char *suffix)
{
  lf_printf (file, "%s", prefix);
  lf_indent (file, +1);
  while (entry != NULL)
    {
      dump_model_entry (file, "\n(", entry, ")");
      entry = entry->next;
    }
  lf_indent (file, -1);
  lf_printf (file, "%s", suffix);
}


static void
dump_model_table (lf *file, char *prefix, model_table *entry, char *suffix)
{
  lf_printf (file, "%s(model_table *) 0x%lx", prefix, (long) entry);
  if (entry != NULL)
    {
      lf_indent (file, +1);
      dump_filter (file, "\n(processors ", entry->processors, ")");
      lf_printf (file, "\n(nr_models %d)", entry->nr_models);
      dump_model_entries (file, "\n(models ", entry->models, ")");
      dump_model_datas (file, "\n(macros ", entry->macros, ")");
      dump_model_datas (file, "\n(data ", entry->data, ")");
      dump_function_entries (file, "\n(statics ", entry->statics, ")");
      dump_function_entries (file, "\n(internals ", entry->functions, ")");
      dump_function_entries (file, "\n(functions ", entry->functions, ")");
      lf_indent (file, -1);
    }
  lf_printf (file, "%s", suffix);
}


static char *
insn_field_type_to_str (insn_field_type type)
{
  switch (type)
    {
    case insn_field_invalid:
      ASSERT (0);
      return "(invalid)";
    case insn_field_int:
      return "int";
    case insn_field_reserved:
      return "reserved";
    case insn_field_wild:
      return "wild";
    case insn_field_string:
      return "string";
    }
  ERROR ("bad switch");
  return 0;
}

void
dump_insn_field (lf *file,
		 char *prefix, insn_field_entry *field, char *suffix)
{
  char *sep = " ";
  lf_printf (file, "%s(insn_field_entry *) 0x%lx", prefix, (long) field);
  if (field != NULL)
    {
      lf_indent (file, +1);
      lf_printf (file, "%s(first %d)", sep, field->first);
      lf_printf (file, "%s(last %d)", sep, field->last);
      lf_printf (file, "%s(width %d)", sep, field->width);
      lf_printf (file, "%s(type %s)", sep,
		 insn_field_type_to_str (field->type));
      switch (field->type)
	{
	case insn_field_invalid:
	  ASSERT (0);
	  break;
	case insn_field_int:
	  lf_printf (file, "%s(val 0x%lx)", sep, (long) field->val_int);
	  break;
	case insn_field_reserved:
	  /* nothing output */
	  break;
	case insn_field_wild:
	  /* nothing output */
	  break;
	case insn_field_string:
	  lf_printf (file, "%s(val \"%s\")", sep, field->val_string);
	  break;
	}
      lf_printf (file, "%s(next 0x%lx)", sep, (long) field->next);
      lf_printf (file, "%s(prev 0x%lx)", sep, (long) field->prev);
      lf_indent (file, -1);
    }
  lf_printf (file, "%s", suffix);
}

void
dump_insn_word_entry (lf *file,
		      char *prefix, insn_word_entry *word, char *suffix)
{
  lf_printf (file, "%s(insn_word_entry *) 0x%lx", prefix, (long) word);
  if (word != NULL)
    {
      int i;
      insn_field_entry *field;
      lf_indent (file, +1);
      lf_printf (file, "\n(first 0x%lx)", (long) word->first);
      lf_printf (file, "\n(last 0x%lx)", (long) word->last);
      lf_printf (file, "\n(bit");
      for (i = 0; i < options.insn_bit_size; i++)
	lf_printf (file, "\n ((value %d) (mask %d) (field 0x%lx))",
		   word->bit[i]->value, word->bit[i]->mask,
		   (long) word->bit[i]->field);
      lf_printf (file, ")");
      for (field = word->first; field != NULL; field = field->next)
	dump_insn_field (file, "\n(", field, ")");
      dump_filter (file, "\n(field_names ", word->field_names, ")");
      lf_printf (file, "\n(next 0x%lx)", (long) word->next);
      lf_indent (file, -1);
    }
  lf_printf (file, "%s", suffix);
}

static void
dump_insn_word_entries (lf *file,
			char *prefix, insn_word_entry *word, char *suffix)
{
  lf_printf (file, "%s", prefix);
  while (word != NULL)
    {
      dump_insn_word_entry (file, "\n(", word, ")");
      word = word->next;
    }
  lf_printf (file, "%s", suffix);
}

static void
dump_insn_model_entry (lf *file,
		       char *prefix, insn_model_entry *model, char *suffix)
{
  lf_printf (file, "%s(insn_model_entry *) 0x%lx", prefix, (long) model);
  if (model != NULL)
    {
      lf_indent (file, +1);
      dump_line_ref (file, "\n(line ", model->line, ")");
      dump_filter (file, "\n(names ", model->names, ")");
      lf_printf (file, "\n(full_name \"%s\")", model->full_name);
      lf_printf (file, "\n(unit_data \"%s\")", model->unit_data);
      lf_printf (file, "\n(insn (insn_entry *) 0x%lx)", (long) model->insn);
      lf_printf (file, "\n(next (insn_model_entry *) 0x%lx)",
		 (long) model->next);
      lf_indent (file, -1);
    }
  lf_printf (file, "%s", suffix);
}

static void
dump_insn_model_entries (lf *file,
			 char *prefix, insn_model_entry *model, char *suffix)
{
  lf_printf (file, "%s", prefix);
  while (model != NULL)
    {
      dump_insn_model_entry (file, "\n", model, "");
      model = model->next;
    }
  lf_printf (file, "%s", suffix);
}


static void
dump_insn_mnemonic_entry (lf *file,
			  char *prefix,
			  insn_mnemonic_entry *mnemonic, char *suffix)
{
  lf_printf (file, "%s(insn_mnemonic_entry *) 0x%lx", prefix,
	     (long) mnemonic);
  if (mnemonic != NULL)
    {
      lf_indent (file, +1);
      dump_line_ref (file, "\n(line ", mnemonic->line, ")");
      lf_printf (file, "\n(format \"%s\")", mnemonic->format);
      lf_printf (file, "\n(condition \"%s\")", mnemonic->condition);
      lf_printf (file, "\n(insn (insn_entry *) 0x%lx)",
		 (long) mnemonic->insn);
      lf_printf (file, "\n(next (insn_mnemonic_entry *) 0x%lx)",
		 (long) mnemonic->next);
      lf_indent (file, -1);
    }
  lf_printf (file, "%s", suffix);
}

static void
dump_insn_mnemonic_entries (lf *file,
			    char *prefix,
			    insn_mnemonic_entry *mnemonic, char *suffix)
{
  lf_printf (file, "%s", prefix);
  while (mnemonic != NULL)
    {
      dump_insn_mnemonic_entry (file, "\n", mnemonic, "");
      mnemonic = mnemonic->next;
    }
  lf_printf (file, "%s", suffix);
}

void
dump_insn_entry (lf *file, char *prefix, insn_entry * entry, char *suffix)
{
  lf_printf (file, "%s(insn_entry *) 0x%lx", prefix, (long) entry);
  if (entry != NULL)
    {
      int i;
      lf_indent (file, +1);
      dump_line_ref (file, "\n(line ", entry->line, ")");
      dump_filter (file, "\n(flags ", entry->flags, ")");
      lf_printf (file, "\n(nr_words %d)", entry->nr_words);
      dump_insn_word_entries (file, "\n(words ", entry->words, ")");
      lf_printf (file, "\n(word");
      for (i = 0; i < entry->nr_models; i++)
	lf_printf (file, " 0x%lx", (long) entry->word[i]);
      lf_printf (file, ")");
      dump_filter (file, "\n(field_names ", entry->field_names, ")");
      lf_printf (file, "\n(format_name \"%s\")", entry->format_name);
      dump_filter (file, "\n(options ", entry->options, ")");
      lf_printf (file, "\n(name \"%s\")", entry->name);
      lf_printf (file, "\n(nr_models %d)", entry->nr_models);
      dump_insn_model_entries (file, "\n(models ", entry->models, ")");
      lf_printf (file, "\n(model");
      for (i = 0; i < entry->nr_models; i++)
	lf_printf (file, " 0x%lx", (long) entry->model[i]);
      lf_printf (file, ")");
      dump_filter (file, "\n(processors ", entry->processors, ")");
      dump_insn_mnemonic_entries (file, "\n(mnemonics ", entry->mnemonics,
				  ")");
      dump_table_entry (file, "\n(code ", entry->code, ")");
      lf_printf (file, "\n(next 0x%lx)", (long) entry->next);
      lf_indent (file, -1);
    }
  lf_printf (file, "%s", suffix);
}

static void
dump_insn_entries (lf *file, char *prefix, insn_entry * entry, char *suffix)
{
  lf_printf (file, "%s", prefix);
  lf_indent (file, +1);
  while (entry != NULL)
    {
      dump_insn_entry (file, "\n(", entry, ")");
      entry = entry->next;
    }
  lf_indent (file, -1);
  lf_printf (file, "%s", suffix);
}



void
dump_insn_table (lf *file, char *prefix, insn_table *isa, char *suffix)
{
  lf_printf (file, "%s(insn_table *) 0x%lx", prefix, (long) isa);
  if (isa != NULL)
    {
      lf_indent (file, +1);
      dump_cache_entries (file, "\n(caches ", isa->caches, ")");
      lf_printf (file, "\n(nr_insns %d)", isa->nr_insns);
      lf_printf (file, "\n(max_nr_words %d)", isa->max_nr_words);
      dump_insn_entries (file, "\n(insns ", isa->insns, ")");
      dump_function_entries (file, "\n(functions ", isa->functions, ")");
      dump_insn_entry (file, "\n(illegal_insn ", isa->illegal_insn, ")");
      dump_model_table (file, "\n(model ", isa->model, ")");
      dump_filter (file, "\n(flags ", isa->flags, ")");
      dump_filter (file, "\n(options ", isa->options, ")");
      lf_indent (file, -1);
    }
  lf_printf (file, "%s", suffix);
}

#ifdef MAIN

igen_options options;

int
main (int argc, char **argv)
{
  insn_table *isa;
  lf *l;

  INIT_OPTIONS (options);

  if (argc == 3)
    filter_parse (&options.flags_filter, argv[2]);
  else if (argc != 2)
    error (NULL, "Usage: insn <insn-table> [ <filter-in> ]\n");

  isa = load_insn_table (argv[1], NULL);
  l = lf_open ("-", "stdout", lf_omit_references, lf_is_text, "tmp-ld-insn");
  dump_insn_table (l, "(isa ", isa, ")\n");

  return 0;
}

#endif
@


1.12
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright 2002, 2007-2012 Free Software Foundation, Inc.
@


1.11
log
@	* ld-insn.c (print_insn_words): For fields, print conditionals.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.11.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright 2002, 2007-2012 Free Software Foundation, Inc.
@


1.10
log
@	Remove all #if 0'd code.
	* filter.c: Remove #if 0'd function it_is.
	(main): Remove #if 0'd code.
	* gen-engine.c: Remove #if 0'd functions print_jump,
	print_jump_insn, print_jump_definition,
	print_jump_internal_function, print_jump_body.
	(gen_engine_c): Remove #if 0'd code.
	* gen-idecode.c: Remove #if 0'd functions print_jump print_jump,
	print_jump_insn, print_jump_definition,
	print_jump_internal_function, print_jump_until_stop_body.
	* gen-model.c: Remove #if 0'd functions model_c_or_h_data,
	model_c_or_h_function, gen_model_h, model_c_insn,
	model_c_function, gen_model_c and types model_c_passed_data
	and struct _model_c_passed_data.
	* gen.c: Remove #if 0'd type constant_field_types and function
	insn_field_is_constant.
	(gen_entry_find_opcode_field): Remove #if 0'd code.
	* ld-insn.c (parse_insn_model_record): Remove #if 0'd code.
	* misc.h (STRDUP, STRNDUP): Remove #if 0'd macros.
@
text
@d1292 2
d1315 28
@


1.9
log
@run copyright.sh for 2011.
@
text
@a876 7
#if 0
  /* for some reason record the max length of any
     function unit field */
  int len = strlen (insn_model_ptr->field[insn_model_fields]);
  if (model->max_model_fields_len < len)
    model->max_model_fields_len = len;
#endif
@


1.8
log
@Update copyright notices to add year 2010.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.7
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.6
log
@	Updated copyright notices for most files.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008 Free Software Foundation, Inc.
@


1.5
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d3 1
a3 1
   Copyright 2002, 2007 Free Software Foundation, Inc.
@


1.4
log
@Copyright updates for 2007.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.3
log
@2002-11-21  Andrew Cagney  <ac131313@@redhat.com>

	* filter.c: Re-indent.
	* filter.h, filter_host.h, gen-engine.c, gen-engine.h: Ditto.
	* gen-icache.c, gen-icache.h, gen-idecode.c: Ditto.
	* gen-idecode.h, gen-itable.c, gen-itable.h: Ditto.
	* gen-model.c, gen-model.h, gen-semantics.c: Ditto.
	* gen-semantics.h, gen-support.c, gen-support.h: Ditto.
	* gen.c, gen.h, igen.c, igen.h, ld-cache.c, ld-cache.h: Ditto.
	* ld-decode.c, ld-decode.h, ld-insn.c, ld-insn.h, lf.c: Ditto.
	* lf.h, misc.c, misc.h, table.c, table.h: Ditto.
@
text
@d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
@


1.2
log
@2002-11-21  Andrew Cagney  <ac131313@@redhat.com>

        * Makefile.in: Update copyright.  IGEN contributed to the FSF.
        * filter.c, filter.h, filter_host.c, filter_host.h: Ditto.
        * gen-engine.c, gen-engine.h, gen-icache.c, gen-icache.h: Ditto.
        * gen-idecode.c, gen-idecode.h, gen-itable.c: Ditto.
        * gen-itable.h, gen-model.c, gen-model.h, gen-semantics.c: Ditto.
        * gen-semantics.h, gen-support.c, gen-support.h, gen.c: Ditto.
        * gen.h, igen.c, igen.h, ld-cache.c, ld-cache.h: Ditto.
        * ld-decode.c, ld-decode.h, ld-insn.c, ld-insn.h, lf.c: Ditto.
        * lf.h, misc.c, misc.h, table.c, table.h: Ditto.
@
text
@d33 1
a33 3
parse_insn_word (line_ref *line,
		 char *string,
		 int word_nr)
d57 99
a155 19
  while (*chp != '\0') {
    char *start_pos;
    int strlen_pos;
    char *start_val;
    int strlen_val;
    insn_field_entry *new_field;

    /* create / link in the new field */
    new_field = ZALLOC (insn_field_entry);
    new_field->next = word->last;
    new_field->prev = word->last->prev;
    new_field->next->prev = new_field;
    new_field->prev->next = new_field;
    new_field->word_nr = word_nr;

    /* break out the first field (if present) */
    start_pos = chp;
    chp = skip_to_separator (chp, ".,!");
    strlen_pos = back_spaces (start_pos, chp) - start_pos;
d157 12
a168 36
    /* break out the second field (if present) */
    if (*chp != '.')
      {
	/* assume what was specified was the value (and not the start
           position).  Assume the value length implicitly specifies
           the number of bits */
	start_val = start_pos;
	strlen_val = strlen_pos;
	start_pos = "";
	strlen_pos = 0;
      }
    else
      {
	chp++; /* skip `.' */
	chp = skip_spaces (chp);
	start_val = chp;
	if (*chp == '/' || *chp == '*')
	  {
	    do
	      {
		chp++;
	      }
	    while (*chp == '/' || *chp == '*');
	  }
	else if (isalpha(*start_val))
	  {
	    do
	      {
		chp++;
	      }
	    while (isalnum(*chp) || *chp == '_');
	  }
	else if (isdigit(*start_val))
	  {
	    do {
	      chp++;
d170 14
a183 1
	    while (isalnum(*chp));
d185 1
a185 59
	strlen_val = chp - start_val;
	chp = skip_spaces (chp);
      }
    if (strlen_val == 0)
      error (line, "Empty value field\n");
    
    /* break out any conditional fields - { [ "!" | "=" [ <value> | <field-name> } */
    while (*chp == '!' || *chp == '=')
      {
	char *start;
	char *end;
	int len;
	insn_field_cond *new_cond = ZALLOC (insn_field_cond);
	
	/* determine the conditional test */
	switch (*chp)
	  {
	  case '=':
	    new_cond->test = insn_field_cond_eq;
	    break;
	  case '!':
	    new_cond->test = insn_field_cond_ne;
	    break;
	  default:
	    ASSERT (0);
	  }
	  
	/* save the value */
	chp++; 
	chp = skip_spaces (chp);
	start = chp;
	chp = skip_to_separator (chp, "+,:!=");
	end = back_spaces (start, chp);
	len = end - start;
	if (len == 0)
	  error (line, "Missing or invalid conditional value\n");
	new_cond->string = NZALLOC (char, len + 1);
	strncpy (new_cond->string, start, len);

	/* determine the conditional type */
	if (isdigit (*start))
	  {
	    /* [ "!" | "=" ] <value> */
	    new_cond->type = insn_field_cond_value;
	    new_cond->value = a2i (new_cond->string);
	  }
	else
	  {
	    /* [ "!" | "=" ] <field>  - check field valid */
	    new_cond->type = insn_field_cond_field;
	    /* new_cond->field is determined in later */
	  }
	  
	/* Only a single `=' is permitted. */
	if ((new_cond->test == insn_field_cond_eq
	     && new_field->conditions != NULL)
	    || (new_field->conditions != NULL
		&& new_field->conditions->test == insn_field_cond_eq))
	  error (line, "Only single conditional when `=' allowed\n");
d187 2
a188 1
	/* insert it */
d190 7
a196 4
	  insn_field_cond **last = &new_field->conditions;
	  while (*last != NULL)
	    last = &(*last)->next;
	  *last = new_cond;
a197 1
      }
d199 92
a290 103
    /* NOW verify that the field was finished */
    if (*chp == ',')
      {
	chp = skip_spaces (chp + 1);
	if (*chp == '\0')
	  error (line, "empty field\n");
      }
    else if (*chp != '\0')
      {
	error (line, "Missing field separator\n");
      }

    /* copy the value */
    new_field->val_string = NZALLOC (char, strlen_val+1);
    strncpy (new_field->val_string, start_val, strlen_val);
    if (isdigit (new_field->val_string[0]))
      {
	if (strlen_pos == 0)
	  {
	    /* when the length/pos field is omited, an integer field
               is always binary */
	    unsigned64 val = 0;
	    int i;
	    for (i = 0; i < strlen_val; i++)
	      {
		if (new_field->val_string[i] != '0'
		    && new_field->val_string[i] != '1')
		  error (line, "invalid binary field %s\n",
			 new_field->val_string);
		val = (val << 1) + (new_field->val_string[i] == '1');
	      }
	    new_field->val_int = val;
	    new_field->type = insn_field_int;
	  }
	else
	  {
	    new_field->val_int = a2i (new_field->val_string);
	    new_field->type = insn_field_int;
	  }
      }
    else if (new_field->val_string[0] == '/')
      {
	new_field->type = insn_field_reserved;
      }
    else if (new_field->val_string[0] == '*')
      {
	new_field->type = insn_field_wild;
      }
    else
      {
	new_field->type = insn_field_string;
	if (filter_is_member (word->field_names, new_field->val_string))
	  error (line, "Field name %s is duplicated\n", new_field->val_string);
	filter_parse (&word->field_names, new_field->val_string);
      }
    if (new_field->type != insn_field_string
	&& new_field->conditions != NULL)
      error (line, "Conditionals can only be applied to named fields\n");

    /* the copy the position */
    new_field->pos_string = NZALLOC (char, strlen_pos + 1);
    strncpy (new_field->pos_string, start_pos, strlen_pos);
    if (strlen_pos == 0)
      {
	new_field->first = new_field->prev->last + 1;
	if (new_field->first == 0 /* first field */
	    && *chp == '\0' /* no further fields */
	    && new_field->type == insn_field_string)
	  {
	    /* A single string without any position, assume that it
               represents the entire instruction word */
	    new_field->width = options.insn_bit_size;
	  }
	else
	  {
	    /* No explicit width/position, assume value implicitly
	       supplies the width */
	    new_field->width = strlen_val;
	  }
	new_field->last = new_field->first + new_field->width - 1;
	if (new_field->last >= options.insn_bit_size)
	  error (line, "Bit position %d exceed instruction bit size (%d)\n",
		 new_field->last, options.insn_bit_size);
      }
    else if (options.insn_specifying_widths)
      {
	new_field->first = new_field->prev->last + 1;
	new_field->width = a2i(new_field->pos_string);
	new_field->last = new_field->first + new_field->width - 1;
	if (new_field->last >= options.insn_bit_size)
	  error (line, "Bit position %d exceed instruction bit size (%d)\n",
		 new_field->last, options.insn_bit_size);
      }
    else
      {
	new_field->first = target_a2i(options.hi_bit_nr,
				      new_field->pos_string);
	new_field->last = new_field->next->first - 1; /* guess */
	new_field->width = new_field->last - new_field->first + 1; /* guess */
	new_field->prev->last = new_field->first - 1; /*fix*/
	new_field->prev->width = new_field->first - new_field->prev->first; /*fix*/
      }
  }
d293 2
a294 2
  ASSERT(word->first->last < 0);
  ASSERT(word->last->first >= options.insn_bit_size);
d312 1
a312 2
	 field->last < options.insn_bit_size;
	 field = field->next)
d327 2
a328 2
					& ((insn_uint)1 << (field->last - i)))
				       != 0);
d333 1
a333 1
                   their bit value. */
d340 2
a341 2
					    & ((insn_uint)1 << (field->last - i)))
					   != 0);
d354 1
a354 2
parse_insn_words (insn_entry *insn,
		  char *formats)
d410 1
a410 2
	 i < insn->nr_words;
	 i++, word = word->next)
d423 1
a423 3
	for (f = word->first;
	     f->last < options.insn_bit_size;
	     f = f->next)
d426 1
a426 3
	    for (cond = f->conditions;
		 cond != NULL;
		 cond = cond->next)
d444 2
a445 1
				&& strcmp (refered_field->val_string, cond->string) == 0)
d454 2
a455 1
					 cond->string, f->val_string, refered_field->width);
d468 1
a468 1
  
d471 2
a472 1
typedef enum {
d474 1
a474 1
  insn_record, /* default */
d491 2
a492 1
} insn_record_type;
d495 16
a510 16
  { "option", option_record },
  { "cache", cache_record },
  { "compute", compute_record },
  { "scratch", scratch_record },
  { "define", define_record },
  { "include", include_record },
  { "%s", string_function_record },
  { "function", function_record },
  { "internal", internal_record },
  { "model", model_processor_record },
  { "model-macro", model_macro_record },
  { "model-data", model_data_record },
  { "model-static", model_static_record },
  { "model-internal", model_internal_record },
  { "model-function", model_function_record },
  { NULL, insn_record },
d555 1
a555 1
	return insn_record; /* default */
d561 1
a561 3
record_prefix_is (table_entry *entry,
		  char ch,
		  int nr_fields)
d576 1
a576 2
			 int nr_fields,
			 model_data **list)
d610 2
a611 1
typedef enum {
d621 2
a622 1
} option_names;
d625 9
a633 9
  { "insn-bit-size", insn_bit_size_option },
  { "insn-specifying-widths", insn_specifying_widths_option },
  { "hi-bit-nr", hi_bit_nr_option },
  { "flags-filter", flags_filter_option },
  { "model-filter", model_filter_option },
  { "multi-sim", multi_sim_option },
  { "format-names", format_names_option },
  { "gen-delayed-branch", gen_delayed_branch },
  { NULL, unknown_option },
d637 1
a637 2
parse_include_record (table *file,
		      table_entry *record)
d650 1
a650 1
    }  
d658 1
a658 2
parse_option_record (table *file,
		     table_entry *record)
d682 2
a683 1
	      error (option_record->line, "Instruction bit size out of range\n");
d686 2
a687 1
	      error (option_record->line, "insn-bit-size / hi-bit-nr conflict\n");
d700 2
a701 1
	      error (option_record->line, "hi-bit-nr / insn-bit-size conflict\n");
d735 1
a735 1
    }  
d743 3
a745 4
		       function_entry **list,
		       function_entry **list_entry,
		       int is_internal,
		       model_table *model)
d779 1
a779 1
      char *model_name = record->field[function_model_name_field] + 1; /*skip `*'*/
d804 2
a805 1
	notify (new_function->line, "Discarding function %s - filter models\n",
d823 1
a823 2
			 insn_entry *insn,
			 model_table *model)
d835 1
a835 1
		record->field[insn_model_name_field] + 1 /*skip `*'*/);
d839 1
a839 1
	 the non-empty fields */
d858 2
a859 1
	  if (name == NULL) break;
d867 1
a867 2
	  if (insn->model[index] != NULL
	      && insn->model[index]->names != NULL)
d896 1
a896 2
			    table_entry *record,
			    insn_entry *insn)
d905 4
a908 2
  if (new_insn_mnemonic->format[strlen (new_insn_mnemonic->format) - 1] != '"')
    error (new_insn_mnemonic->line, "Missing closing double quote in mnemonic field\n");
d910 2
a911 1
    new_insn_mnemonic->condition = record->field[insn_mnemonic_condition_field];
d923 1
a923 2
parse_macro_record (table *file,
		    table_entry *record)
d942 1
a942 1
    }  
d950 1
a950 2
load_insn_table (char *file_name,
		 cache_entry *cache)
d957 1
a957 1
  
d980 1
a980 1
	
d986 1
a986 2
					    &function,
					    0/*is-internal*/,
d993 1
a993 2
				       + strlen (function->name)
				       + 1));
d1001 2
a1002 2
	
	case function_record: /* function record */
d1006 1
a1006 2
					    NULL,
					    0/*is-internal*/,
d1017 1
a1017 2
					    &function,
					    1/*is-internal*/,
d1020 1
a1020 1
               entry also needs to be created */
d1047 2
a1048 2
	  
	case scratch_record: /* cache macro records */
d1072 2
a1073 1
		notify (new_cache->line, "Discarding cache entry %s - filter flags\n",
d1077 2
a1078 1
				      record->field[record_filter_models_field]))
d1080 2
a1081 1
		notify (new_cache->line, "Discarding cache entry %s - filter models\n",
d1096 2
a1097 2
	
	/* model records */
d1103 2
a1104 1
	      error (record->line, "Incorrect nr of fields for model record\n");
d1117 2
a1118 1
		notify (new_model->line, "Discarding processor model %s - filter flags\n",
d1122 2
a1123 1
				      record->field[record_filter_models_field]))
d1125 2
a1126 1
		notify (new_model->line, "Discarding processor model %s - filter models\n",
d1142 1
a1142 1
		model->nr_models ++;
d1149 1
a1149 1
	  
d1155 1
a1155 1
	  
d1161 1
a1161 1
	  
d1165 1
a1165 2
					  NULL,
					  0/*is internal*/,
d1168 1
a1168 1
	  
d1172 1
a1172 2
					  NULL,
					  1/*is internal*/,
d1175 1
a1175 1
	  
d1179 1
a1179 2
					  NULL,
					  0/*is internal*/,
d1182 2
a1183 2
	  
	case insn_record: /* instruction records */
d1189 2
a1190 1
	      error (record->line, "Incorrect nr of fields for insn record\n");
d1196 2
a1197 2
               filter-out checks.  Could be filtered out because the
               format is invalid */
d1203 2
a1204 1
	      error (new_insn->line, "Unreconized instruction format name `%s'\n",
d1212 2
a1213 1
	    new_insn->model = NZALLOC (insn_model_entry*, model->nr_models + 1);
d1218 2
a1219 1
		else if (record_prefix_is (record, '"', nr_insn_mnemonic_fields))
d1248 2
a1249 2
                   model when both the instruction and the options are
                   nonempty */
d1266 1
a1266 1
		isa->nr_insns ++;
d1274 1
a1274 1
      
d1291 1
a1291 2
print_insn_words (lf *file,
		  insn_entry *insn)
d1304 2
a1305 1
		lf_printf (file, "%d.", i2target (options.hi_bit_nr, field->first));
d1336 1
a1338 1

d1341 2
a1342 3
			 function_entry *functions,
			 function_entry_handler *handler,
			 void *data)
d1354 1
a1354 2
			  insn_entry_handler *handler,
			  void *data)
d1362 1
a1363 1

d1366 1
a1366 3
		     char *prefix,
		     function_entry *entry,
		     char *suffix)
d1385 1
a1385 3
		       char *prefix,
		       function_entry *entry,
		       char *suffix)
d1403 6
a1408 3
    case scratch_value: return "scratch";
    case cache_value: return "cache";
    case compute_value: return "compute";
d1415 1
a1415 4
dump_cache_entry (lf *file,
		  char *prefix,
		  cache_entry *entry,
		  char *suffix)
d1422 2
a1423 1
      lf_printf (file, "\n(entry_type \"%s\")", cache_entry_type_to_str (entry->entry_type));
d1434 1
a1434 4
dump_cache_entries (lf *file,
		    char *prefix,
		    cache_entry *entry,
		    char *suffix)
d1448 1
a1448 4
dump_model_data (lf *file,
		 char *prefix,
		 model_data *entry,
		 char *suffix)
d1465 1
a1465 4
dump_model_datas (lf *file,
		  char *prefix,
		  model_data *entry,
		  char *suffix)
d1479 1
a1479 4
dump_model_entry (lf *file,
		  char *prefix,
		  model_entry *entry,
		  char *suffix)
d1497 1
a1497 4
dump_model_entries (lf *file,
		    char *prefix,
		    model_entry *entry,
		    char *suffix)
d1512 1
a1512 4
dump_model_table (lf *file,
		  char *prefix,
		  model_table *entry,
		  char *suffix)
d1537 11
a1547 5
    case insn_field_invalid: ASSERT (0); return "(invalid)";
    case insn_field_int: return "int";
    case insn_field_reserved: return "reserved";
    case insn_field_wild: return "wild";
    case insn_field_string: return "string";
d1555 1
a1555 3
		 char *prefix,
		 insn_field_entry *field,
		 char *suffix)
d1565 2
a1566 1
      lf_printf (file, "%s(type %s)", sep, insn_field_type_to_str (field->type));
d1594 1
a1594 3
		      char *prefix,
		      insn_word_entry *word,
		      char *suffix)
d1607 2
a1608 1
		   word->bit[i]->value, word->bit[i]->mask, (long) word->bit[i]->field);
d1621 1
a1621 3
			char *prefix,
			insn_word_entry *word,
			char *suffix)
d1634 1
a1634 3
		       char *prefix,
		       insn_model_entry *model,
		       char *suffix)
d1654 1
a1654 3
			 char *prefix,
			 insn_model_entry *model,
			 char *suffix)
d1669 1
a1669 2
			  insn_mnemonic_entry *mnemonic,
			  char *suffix)
d1671 2
a1672 1
  lf_printf (file, "%s(insn_mnemonic_entry *) 0x%lx", prefix, (long) mnemonic);
d1691 1
a1691 2
			    insn_mnemonic_entry *mnemonic,
			    char *suffix)
d1703 1
a1703 4
dump_insn_entry (lf *file,
		 char *prefix,
		 insn_entry *entry,
		 char *suffix)
d1729 2
a1730 1
      dump_insn_mnemonic_entries (file, "\n(mnemonics ", entry->mnemonics, ")");
d1734 1
a1734 1
  }
d1739 1
a1739 4
dump_insn_entries (lf *file,
		   char *prefix,
		   insn_entry *entry,
		   char *suffix)
d1755 1
a1755 4
dump_insn_table (lf *file,
		 char *prefix,
		 insn_table *isa,
		 char *suffix)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*  This file is part of the program psim.
d3 1
a3 1
    Copyright (C) 1994-1998, Andrew Cagney <cagney@@highland.com.au>
d5 18
a22 15
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
    */
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.1.30.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1 1
a1 1
/* The IGEN simulator generator for GDB, the GNU Debugger.
d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d5 15
a19 18
   Contributed by Andrew Cagney.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d30 3
a32 1
parse_insn_word (line_ref *line, char *string, int word_nr)
d56 19
a74 15
  while (*chp != '\0')
    {
      char *start_pos;
      int strlen_pos;
      char *start_val;
      int strlen_val;
      insn_field_entry *new_field;

      /* create / link in the new field */
      new_field = ZALLOC (insn_field_entry);
      new_field->next = word->last;
      new_field->prev = word->last->prev;
      new_field->next->prev = new_field;
      new_field->prev->next = new_field;
      new_field->word_nr = word_nr;
d76 98
a173 4
      /* break out the first field (if present) */
      start_pos = chp;
      chp = skip_to_separator (chp, ".,!");
      strlen_pos = back_spaces (start_pos, chp) - start_pos;
d175 1
a175 2
      /* break out the second field (if present) */
      if (*chp != '.')
d177 4
a180 7
	  /* assume what was specified was the value (and not the start
	     position).  Assume the value length implicitly specifies
	     the number of bits */
	  start_val = start_pos;
	  strlen_val = strlen_pos;
	  start_pos = "";
	  strlen_pos = 0;
d182 1
a182 34
      else
	{
	  chp++;		/* skip `.' */
	  chp = skip_spaces (chp);
	  start_val = chp;
	  if (*chp == '/' || *chp == '*')
	    {
	      do
		{
		  chp++;
		}
	      while (*chp == '/' || *chp == '*');
	    }
	  else if (isalpha (*start_val))
	    {
	      do
		{
		  chp++;
		}
	      while (isalnum (*chp) || *chp == '_');
	    }
	  else if (isdigit (*start_val))
	    {
	      do
		{
		  chp++;
		}
	      while (isalnum (*chp));
	    }
	  strlen_val = chp - start_val;
	  chp = skip_spaces (chp);
	}
      if (strlen_val == 0)
	error (line, "Empty value field\n");
d184 11
a194 7
      /* break out any conditional fields - { [ "!" | "=" [ <value> | <field-name> } */
      while (*chp == '!' || *chp == '=')
	{
	  char *start;
	  char *end;
	  int len;
	  insn_field_cond *new_cond = ZALLOC (insn_field_cond);
d196 26
a221 52
	  /* determine the conditional test */
	  switch (*chp)
	    {
	    case '=':
	      new_cond->test = insn_field_cond_eq;
	      break;
	    case '!':
	      new_cond->test = insn_field_cond_ne;
	      break;
	    default:
	      ASSERT (0);
	    }

	  /* save the value */
	  chp++;
	  chp = skip_spaces (chp);
	  start = chp;
	  chp = skip_to_separator (chp, "+,:!=");
	  end = back_spaces (start, chp);
	  len = end - start;
	  if (len == 0)
	    error (line, "Missing or invalid conditional value\n");
	  new_cond->string = NZALLOC (char, len + 1);
	  strncpy (new_cond->string, start, len);

	  /* determine the conditional type */
	  if (isdigit (*start))
	    {
	      /* [ "!" | "=" ] <value> */
	      new_cond->type = insn_field_cond_value;
	      new_cond->value = a2i (new_cond->string);
	    }
	  else
	    {
	      /* [ "!" | "=" ] <field>  - check field valid */
	      new_cond->type = insn_field_cond_field;
	      /* new_cond->field is determined in later */
	    }

	  /* Only a single `=' is permitted. */
	  if ((new_cond->test == insn_field_cond_eq
	       && new_field->conditions != NULL)
	      || (new_field->conditions != NULL
		  && new_field->conditions->test == insn_field_cond_eq))
	    error (line, "Only single conditional when `=' allowed\n");

	  /* insert it */
	  {
	    insn_field_cond **last = &new_field->conditions;
	    while (*last != NULL)
	      last = &(*last)->next;
	    *last = new_cond;
d223 64
a286 106
	}

      /* NOW verify that the field was finished */
      if (*chp == ',')
	{
	  chp = skip_spaces (chp + 1);
	  if (*chp == '\0')
	    error (line, "empty field\n");
	}
      else if (*chp != '\0')
	{
	  error (line, "Missing field separator\n");
	}

      /* copy the value */
      new_field->val_string = NZALLOC (char, strlen_val + 1);
      strncpy (new_field->val_string, start_val, strlen_val);
      if (isdigit (new_field->val_string[0]))
	{
	  if (strlen_pos == 0)
	    {
	      /* when the length/pos field is omited, an integer field
	         is always binary */
	      unsigned64 val = 0;
	      int i;
	      for (i = 0; i < strlen_val; i++)
		{
		  if (new_field->val_string[i] != '0'
		      && new_field->val_string[i] != '1')
		    error (line, "invalid binary field %s\n",
			   new_field->val_string);
		  val = (val << 1) + (new_field->val_string[i] == '1');
		}
	      new_field->val_int = val;
	      new_field->type = insn_field_int;
	    }
	  else
	    {
	      new_field->val_int = a2i (new_field->val_string);
	      new_field->type = insn_field_int;
	    }
	}
      else if (new_field->val_string[0] == '/')
	{
	  new_field->type = insn_field_reserved;
	}
      else if (new_field->val_string[0] == '*')
	{
	  new_field->type = insn_field_wild;
	}
      else
	{
	  new_field->type = insn_field_string;
	  if (filter_is_member (word->field_names, new_field->val_string))
	    error (line, "Field name %s is duplicated\n",
		   new_field->val_string);
	  filter_parse (&word->field_names, new_field->val_string);
	}
      if (new_field->type != insn_field_string
	  && new_field->conditions != NULL)
	error (line, "Conditionals can only be applied to named fields\n");

      /* the copy the position */
      new_field->pos_string = NZALLOC (char, strlen_pos + 1);
      strncpy (new_field->pos_string, start_pos, strlen_pos);
      if (strlen_pos == 0)
	{
	  new_field->first = new_field->prev->last + 1;
	  if (new_field->first == 0	/* first field */
	      && *chp == '\0'	/* no further fields */
	      && new_field->type == insn_field_string)
	    {
	      /* A single string without any position, assume that it
	         represents the entire instruction word */
	      new_field->width = options.insn_bit_size;
	    }
	  else
	    {
	      /* No explicit width/position, assume value implicitly
	         supplies the width */
	      new_field->width = strlen_val;
	    }
	  new_field->last = new_field->first + new_field->width - 1;
	  if (new_field->last >= options.insn_bit_size)
	    error (line, "Bit position %d exceed instruction bit size (%d)\n",
		   new_field->last, options.insn_bit_size);
	}
      else if (options.insn_specifying_widths)
	{
	  new_field->first = new_field->prev->last + 1;
	  new_field->width = a2i (new_field->pos_string);
	  new_field->last = new_field->first + new_field->width - 1;
	  if (new_field->last >= options.insn_bit_size)
	    error (line, "Bit position %d exceed instruction bit size (%d)\n",
		   new_field->last, options.insn_bit_size);
	}
      else
	{
	  new_field->first = target_a2i (options.hi_bit_nr,
					 new_field->pos_string);
	  new_field->last = new_field->next->first - 1;	/* guess */
	  new_field->width = new_field->last - new_field->first + 1;	/* guess */
	  new_field->prev->last = new_field->first - 1;	/*fix */
	  new_field->prev->width = new_field->first - new_field->prev->first;	/*fix */
	}
    }
d289 2
a290 2
  ASSERT (word->first->last < 0);
  ASSERT (word->last->first >= options.insn_bit_size);
d308 2
a309 1
	 field->last < options.insn_bit_size; field = field->next)
d324 2
a325 2
					& ((insn_uint) 1 <<
					   (field->last - i))) != 0);
d330 1
a330 1
		   their bit value. */
d337 2
a338 2
					    & ((insn_uint) 1 <<
					       (field->last - i))) != 0);
d351 2
a352 1
parse_insn_words (insn_entry * insn, char *formats)
d408 2
a409 1
	 i < insn->nr_words; i++, word = word->next)
d422 3
a424 1
	for (f = word->first; f->last < options.insn_bit_size; f = f->next)
d427 3
a429 1
	    for (cond = f->conditions; cond != NULL; cond = cond->next)
d447 1
a447 2
				&& strcmp (refered_field->val_string,
					   cond->string) == 0)
d456 1
a456 2
					 cond->string, f->val_string,
					 refered_field->width);
d469 1
a469 1

d472 1
a472 2
typedef enum
{
d474 1
a474 1
  insn_record,			/* default */
d491 1
a491 2
}
insn_record_type;
d494 16
a509 16
  {"option", option_record},
  {"cache", cache_record},
  {"compute", compute_record},
  {"scratch", scratch_record},
  {"define", define_record},
  {"include", include_record},
  {"%s", string_function_record},
  {"function", function_record},
  {"internal", internal_record},
  {"model", model_processor_record},
  {"model-macro", model_macro_record},
  {"model-data", model_data_record},
  {"model-static", model_static_record},
  {"model-internal", model_internal_record},
  {"model-function", model_function_record},
  {NULL, insn_record},
d554 1
a554 1
	return insn_record;	/* default */
d560 3
a562 1
record_prefix_is (table_entry *entry, char ch, int nr_fields)
d577 2
a578 1
			 int nr_fields, model_data **list)
d612 1
a612 2
typedef enum
{
d622 1
a622 2
}
option_names;
d625 9
a633 9
  {"insn-bit-size", insn_bit_size_option},
  {"insn-specifying-widths", insn_specifying_widths_option},
  {"hi-bit-nr", hi_bit_nr_option},
  {"flags-filter", flags_filter_option},
  {"model-filter", model_filter_option},
  {"multi-sim", multi_sim_option},
  {"format-names", format_names_option},
  {"gen-delayed-branch", gen_delayed_branch},
  {NULL, unknown_option},
d637 2
a638 1
parse_include_record (table *file, table_entry *record)
d651 1
a651 1
    }
d659 2
a660 1
parse_option_record (table *file, table_entry *record)
d684 1
a684 2
	      error (option_record->line,
		     "Instruction bit size out of range\n");
d687 1
a687 2
	      error (option_record->line,
		     "insn-bit-size / hi-bit-nr conflict\n");
d700 1
a700 2
	      error (option_record->line,
		     "hi-bit-nr / insn-bit-size conflict\n");
d734 1
a734 1
    }
d742 4
a745 3
		       function_entry ** list,
		       function_entry ** list_entry,
		       int is_internal, model_table *model)
d779 1
a779 1
      char *model_name = record->field[function_model_name_field] + 1;	/*skip `*' */
d804 1
a804 2
	notify (new_function->line,
		"Discarding function %s - filter models\n",
d822 2
a823 1
			 insn_entry * insn, model_table *model)
d835 1
a835 1
		record->field[insn_model_name_field] + 1 /*skip `*' */ );
d839 1
a839 1
         the non-empty fields */
d858 1
a858 2
	  if (name == NULL)
	    break;
d866 2
a867 1
	  if (insn->model[index] != NULL && insn->model[index]->names != NULL)
d896 2
a897 1
			    table_entry *record, insn_entry * insn)
d906 2
a907 4
  if (new_insn_mnemonic->format[strlen (new_insn_mnemonic->format) - 1] !=
      '"')
    error (new_insn_mnemonic->line,
	   "Missing closing double quote in mnemonic field\n");
d909 1
a909 2
    new_insn_mnemonic->condition =
      record->field[insn_mnemonic_condition_field];
d921 2
a922 1
parse_macro_record (table *file, table_entry *record)
d941 1
a941 1
    }
d949 2
a950 1
load_insn_table (char *file_name, cache_entry *cache)
d957 1
a957 1

d980 1
a980 1

d986 2
a987 1
					    &function, 0 /*is-internal */ ,
d994 2
a995 1
				       + strlen (function->name) + 1));
d1003 2
a1004 2

	case function_record:	/* function record */
d1008 2
a1009 1
					    NULL, 0 /*is-internal */ ,
d1020 2
a1021 1
					    &function, 1 /*is-internal */ ,
d1024 1
a1024 1
	       entry also needs to be created */
d1051 2
a1052 2

	case scratch_record:	/* cache macro records */
d1076 1
a1076 2
		notify (new_cache->line,
			"Discarding cache entry %s - filter flags\n",
d1080 1
a1080 2
				      record->
				      field[record_filter_models_field]))
d1082 1
a1082 2
		notify (new_cache->line,
			"Discarding cache entry %s - filter models\n",
d1097 2
a1098 2

	  /* model records */
d1104 1
a1104 2
	      error (record->line,
		     "Incorrect nr of fields for model record\n");
d1117 1
a1117 2
		notify (new_model->line,
			"Discarding processor model %s - filter flags\n",
d1121 1
a1121 2
				      record->
				      field[record_filter_models_field]))
d1123 1
a1123 2
		notify (new_model->line,
			"Discarding processor model %s - filter models\n",
d1139 1
a1139 1
		model->nr_models++;
d1146 1
a1146 1

d1152 1
a1152 1

d1158 1
a1158 1

d1162 2
a1163 1
					  NULL, 0 /*is internal */ ,
d1166 1
a1166 1

d1170 2
a1171 1
					  NULL, 1 /*is internal */ ,
d1174 1
a1174 1

d1178 2
a1179 1
					  NULL, 0 /*is internal */ ,
d1182 2
a1183 2

	case insn_record:	/* instruction records */
d1189 1
a1189 2
	      error (record->line,
		     "Incorrect nr of fields for insn record\n");
d1195 2
a1196 2
	       filter-out checks.  Could be filtered out because the
	       format is invalid */
d1202 1
a1202 2
	      error (new_insn->line,
		     "Unreconized instruction format name `%s'\n",
d1210 1
a1210 2
	    new_insn->model =
	      NZALLOC (insn_model_entry *, model->nr_models + 1);
d1215 1
a1215 2
		else
		  if (record_prefix_is (record, '"', nr_insn_mnemonic_fields))
d1244 2
a1245 2
		   model when both the instruction and the options are
		   nonempty */
d1262 1
a1262 1
		isa->nr_insns++;
d1270 1
a1270 1

d1287 2
a1288 1
print_insn_words (lf *file, insn_entry * insn)
d1301 1
a1301 2
		lf_printf (file, "%d.",
			   i2target (options.hi_bit_nr, field->first));
a1331 1

d1334 1
d1337 3
a1339 2
			 function_entry * functions,
			 function_entry_handler * handler, void *data)
d1351 2
a1352 1
			  insn_entry_handler * handler, void *data)
d1360 1
a1361 1

d1364 3
a1366 1
		     char *prefix, function_entry * entry, char *suffix)
d1385 3
a1387 1
		       char *prefix, function_entry * entry, char *suffix)
d1405 3
a1407 6
    case scratch_value:
      return "scratch";
    case cache_value:
      return "cache";
    case compute_value:
      return "compute";
d1414 4
a1417 1
dump_cache_entry (lf *file, char *prefix, cache_entry *entry, char *suffix)
d1424 1
a1424 2
      lf_printf (file, "\n(entry_type \"%s\")",
		 cache_entry_type_to_str (entry->entry_type));
d1435 4
a1438 1
dump_cache_entries (lf *file, char *prefix, cache_entry *entry, char *suffix)
d1452 4
a1455 1
dump_model_data (lf *file, char *prefix, model_data *entry, char *suffix)
d1472 4
a1475 1
dump_model_datas (lf *file, char *prefix, model_data *entry, char *suffix)
d1489 4
a1492 1
dump_model_entry (lf *file, char *prefix, model_entry *entry, char *suffix)
d1510 4
a1513 1
dump_model_entries (lf *file, char *prefix, model_entry *entry, char *suffix)
d1528 4
a1531 1
dump_model_table (lf *file, char *prefix, model_table *entry, char *suffix)
d1556 5
a1560 11
    case insn_field_invalid:
      ASSERT (0);
      return "(invalid)";
    case insn_field_int:
      return "int";
    case insn_field_reserved:
      return "reserved";
    case insn_field_wild:
      return "wild";
    case insn_field_string:
      return "string";
d1568 3
a1570 1
		 char *prefix, insn_field_entry *field, char *suffix)
d1580 1
a1580 2
      lf_printf (file, "%s(type %s)", sep,
		 insn_field_type_to_str (field->type));
d1608 3
a1610 1
		      char *prefix, insn_word_entry *word, char *suffix)
d1623 1
a1623 2
		   word->bit[i]->value, word->bit[i]->mask,
		   (long) word->bit[i]->field);
d1636 3
a1638 1
			char *prefix, insn_word_entry *word, char *suffix)
d1651 3
a1653 1
		       char *prefix, insn_model_entry *model, char *suffix)
d1673 3
a1675 1
			 char *prefix, insn_model_entry *model, char *suffix)
d1690 2
a1691 1
			  insn_mnemonic_entry *mnemonic, char *suffix)
d1693 1
a1693 2
  lf_printf (file, "%s(insn_mnemonic_entry *) 0x%lx", prefix,
	     (long) mnemonic);
d1712 2
a1713 1
			    insn_mnemonic_entry *mnemonic, char *suffix)
d1725 4
a1728 1
dump_insn_entry (lf *file, char *prefix, insn_entry * entry, char *suffix)
d1754 1
a1754 2
      dump_insn_mnemonic_entries (file, "\n(mnemonics ", entry->mnemonics,
				  ")");
d1758 1
a1758 1
    }
d1763 4
a1766 1
dump_insn_entries (lf *file, char *prefix, insn_entry * entry, char *suffix)
d1782 4
a1785 1
dump_insn_table (lf *file, char *prefix, insn_table *isa, char *suffix)
@


1.1.1.1.28.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d1 1
a1 1
/* The IGEN simulator generator for GDB, the GNU Debugger.
d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d5 15
a19 18
   Contributed by Andrew Cagney.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d30 3
a32 1
parse_insn_word (line_ref *line, char *string, int word_nr)
d56 19
a74 15
  while (*chp != '\0')
    {
      char *start_pos;
      int strlen_pos;
      char *start_val;
      int strlen_val;
      insn_field_entry *new_field;

      /* create / link in the new field */
      new_field = ZALLOC (insn_field_entry);
      new_field->next = word->last;
      new_field->prev = word->last->prev;
      new_field->next->prev = new_field;
      new_field->prev->next = new_field;
      new_field->word_nr = word_nr;
d76 98
a173 4
      /* break out the first field (if present) */
      start_pos = chp;
      chp = skip_to_separator (chp, ".,!");
      strlen_pos = back_spaces (start_pos, chp) - start_pos;
d175 1
a175 2
      /* break out the second field (if present) */
      if (*chp != '.')
d177 4
a180 7
	  /* assume what was specified was the value (and not the start
	     position).  Assume the value length implicitly specifies
	     the number of bits */
	  start_val = start_pos;
	  strlen_val = strlen_pos;
	  start_pos = "";
	  strlen_pos = 0;
d182 1
a182 34
      else
	{
	  chp++;		/* skip `.' */
	  chp = skip_spaces (chp);
	  start_val = chp;
	  if (*chp == '/' || *chp == '*')
	    {
	      do
		{
		  chp++;
		}
	      while (*chp == '/' || *chp == '*');
	    }
	  else if (isalpha (*start_val))
	    {
	      do
		{
		  chp++;
		}
	      while (isalnum (*chp) || *chp == '_');
	    }
	  else if (isdigit (*start_val))
	    {
	      do
		{
		  chp++;
		}
	      while (isalnum (*chp));
	    }
	  strlen_val = chp - start_val;
	  chp = skip_spaces (chp);
	}
      if (strlen_val == 0)
	error (line, "Empty value field\n");
d184 11
a194 7
      /* break out any conditional fields - { [ "!" | "=" [ <value> | <field-name> } */
      while (*chp == '!' || *chp == '=')
	{
	  char *start;
	  char *end;
	  int len;
	  insn_field_cond *new_cond = ZALLOC (insn_field_cond);
d196 26
a221 52
	  /* determine the conditional test */
	  switch (*chp)
	    {
	    case '=':
	      new_cond->test = insn_field_cond_eq;
	      break;
	    case '!':
	      new_cond->test = insn_field_cond_ne;
	      break;
	    default:
	      ASSERT (0);
	    }

	  /* save the value */
	  chp++;
	  chp = skip_spaces (chp);
	  start = chp;
	  chp = skip_to_separator (chp, "+,:!=");
	  end = back_spaces (start, chp);
	  len = end - start;
	  if (len == 0)
	    error (line, "Missing or invalid conditional value\n");
	  new_cond->string = NZALLOC (char, len + 1);
	  strncpy (new_cond->string, start, len);

	  /* determine the conditional type */
	  if (isdigit (*start))
	    {
	      /* [ "!" | "=" ] <value> */
	      new_cond->type = insn_field_cond_value;
	      new_cond->value = a2i (new_cond->string);
	    }
	  else
	    {
	      /* [ "!" | "=" ] <field>  - check field valid */
	      new_cond->type = insn_field_cond_field;
	      /* new_cond->field is determined in later */
	    }

	  /* Only a single `=' is permitted. */
	  if ((new_cond->test == insn_field_cond_eq
	       && new_field->conditions != NULL)
	      || (new_field->conditions != NULL
		  && new_field->conditions->test == insn_field_cond_eq))
	    error (line, "Only single conditional when `=' allowed\n");

	  /* insert it */
	  {
	    insn_field_cond **last = &new_field->conditions;
	    while (*last != NULL)
	      last = &(*last)->next;
	    *last = new_cond;
d223 64
a286 106
	}

      /* NOW verify that the field was finished */
      if (*chp == ',')
	{
	  chp = skip_spaces (chp + 1);
	  if (*chp == '\0')
	    error (line, "empty field\n");
	}
      else if (*chp != '\0')
	{
	  error (line, "Missing field separator\n");
	}

      /* copy the value */
      new_field->val_string = NZALLOC (char, strlen_val + 1);
      strncpy (new_field->val_string, start_val, strlen_val);
      if (isdigit (new_field->val_string[0]))
	{
	  if (strlen_pos == 0)
	    {
	      /* when the length/pos field is omited, an integer field
	         is always binary */
	      unsigned64 val = 0;
	      int i;
	      for (i = 0; i < strlen_val; i++)
		{
		  if (new_field->val_string[i] != '0'
		      && new_field->val_string[i] != '1')
		    error (line, "invalid binary field %s\n",
			   new_field->val_string);
		  val = (val << 1) + (new_field->val_string[i] == '1');
		}
	      new_field->val_int = val;
	      new_field->type = insn_field_int;
	    }
	  else
	    {
	      new_field->val_int = a2i (new_field->val_string);
	      new_field->type = insn_field_int;
	    }
	}
      else if (new_field->val_string[0] == '/')
	{
	  new_field->type = insn_field_reserved;
	}
      else if (new_field->val_string[0] == '*')
	{
	  new_field->type = insn_field_wild;
	}
      else
	{
	  new_field->type = insn_field_string;
	  if (filter_is_member (word->field_names, new_field->val_string))
	    error (line, "Field name %s is duplicated\n",
		   new_field->val_string);
	  filter_parse (&word->field_names, new_field->val_string);
	}
      if (new_field->type != insn_field_string
	  && new_field->conditions != NULL)
	error (line, "Conditionals can only be applied to named fields\n");

      /* the copy the position */
      new_field->pos_string = NZALLOC (char, strlen_pos + 1);
      strncpy (new_field->pos_string, start_pos, strlen_pos);
      if (strlen_pos == 0)
	{
	  new_field->first = new_field->prev->last + 1;
	  if (new_field->first == 0	/* first field */
	      && *chp == '\0'	/* no further fields */
	      && new_field->type == insn_field_string)
	    {
	      /* A single string without any position, assume that it
	         represents the entire instruction word */
	      new_field->width = options.insn_bit_size;
	    }
	  else
	    {
	      /* No explicit width/position, assume value implicitly
	         supplies the width */
	      new_field->width = strlen_val;
	    }
	  new_field->last = new_field->first + new_field->width - 1;
	  if (new_field->last >= options.insn_bit_size)
	    error (line, "Bit position %d exceed instruction bit size (%d)\n",
		   new_field->last, options.insn_bit_size);
	}
      else if (options.insn_specifying_widths)
	{
	  new_field->first = new_field->prev->last + 1;
	  new_field->width = a2i (new_field->pos_string);
	  new_field->last = new_field->first + new_field->width - 1;
	  if (new_field->last >= options.insn_bit_size)
	    error (line, "Bit position %d exceed instruction bit size (%d)\n",
		   new_field->last, options.insn_bit_size);
	}
      else
	{
	  new_field->first = target_a2i (options.hi_bit_nr,
					 new_field->pos_string);
	  new_field->last = new_field->next->first - 1;	/* guess */
	  new_field->width = new_field->last - new_field->first + 1;	/* guess */
	  new_field->prev->last = new_field->first - 1;	/*fix */
	  new_field->prev->width = new_field->first - new_field->prev->first;	/*fix */
	}
    }
d289 2
a290 2
  ASSERT (word->first->last < 0);
  ASSERT (word->last->first >= options.insn_bit_size);
d308 2
a309 1
	 field->last < options.insn_bit_size; field = field->next)
d324 2
a325 2
					& ((insn_uint) 1 <<
					   (field->last - i))) != 0);
d330 1
a330 1
		   their bit value. */
d337 2
a338 2
					    & ((insn_uint) 1 <<
					       (field->last - i))) != 0);
d351 2
a352 1
parse_insn_words (insn_entry * insn, char *formats)
d408 2
a409 1
	 i < insn->nr_words; i++, word = word->next)
d422 3
a424 1
	for (f = word->first; f->last < options.insn_bit_size; f = f->next)
d427 3
a429 1
	    for (cond = f->conditions; cond != NULL; cond = cond->next)
d447 1
a447 2
				&& strcmp (refered_field->val_string,
					   cond->string) == 0)
d456 1
a456 2
					 cond->string, f->val_string,
					 refered_field->width);
d469 1
a469 1

d472 1
a472 2
typedef enum
{
d474 1
a474 1
  insn_record,			/* default */
d491 1
a491 2
}
insn_record_type;
d494 16
a509 16
  {"option", option_record},
  {"cache", cache_record},
  {"compute", compute_record},
  {"scratch", scratch_record},
  {"define", define_record},
  {"include", include_record},
  {"%s", string_function_record},
  {"function", function_record},
  {"internal", internal_record},
  {"model", model_processor_record},
  {"model-macro", model_macro_record},
  {"model-data", model_data_record},
  {"model-static", model_static_record},
  {"model-internal", model_internal_record},
  {"model-function", model_function_record},
  {NULL, insn_record},
d554 1
a554 1
	return insn_record;	/* default */
d560 3
a562 1
record_prefix_is (table_entry *entry, char ch, int nr_fields)
d577 2
a578 1
			 int nr_fields, model_data **list)
d612 1
a612 2
typedef enum
{
d622 1
a622 2
}
option_names;
d625 9
a633 9
  {"insn-bit-size", insn_bit_size_option},
  {"insn-specifying-widths", insn_specifying_widths_option},
  {"hi-bit-nr", hi_bit_nr_option},
  {"flags-filter", flags_filter_option},
  {"model-filter", model_filter_option},
  {"multi-sim", multi_sim_option},
  {"format-names", format_names_option},
  {"gen-delayed-branch", gen_delayed_branch},
  {NULL, unknown_option},
d637 2
a638 1
parse_include_record (table *file, table_entry *record)
d651 1
a651 1
    }
d659 2
a660 1
parse_option_record (table *file, table_entry *record)
d684 1
a684 2
	      error (option_record->line,
		     "Instruction bit size out of range\n");
d687 1
a687 2
	      error (option_record->line,
		     "insn-bit-size / hi-bit-nr conflict\n");
d700 1
a700 2
	      error (option_record->line,
		     "hi-bit-nr / insn-bit-size conflict\n");
d734 1
a734 1
    }
d742 4
a745 3
		       function_entry ** list,
		       function_entry ** list_entry,
		       int is_internal, model_table *model)
d779 1
a779 1
      char *model_name = record->field[function_model_name_field] + 1;	/*skip `*' */
d804 1
a804 2
	notify (new_function->line,
		"Discarding function %s - filter models\n",
d822 2
a823 1
			 insn_entry * insn, model_table *model)
d835 1
a835 1
		record->field[insn_model_name_field] + 1 /*skip `*' */ );
d839 1
a839 1
         the non-empty fields */
d858 1
a858 2
	  if (name == NULL)
	    break;
d866 2
a867 1
	  if (insn->model[index] != NULL && insn->model[index]->names != NULL)
d896 2
a897 1
			    table_entry *record, insn_entry * insn)
d906 2
a907 4
  if (new_insn_mnemonic->format[strlen (new_insn_mnemonic->format) - 1] !=
      '"')
    error (new_insn_mnemonic->line,
	   "Missing closing double quote in mnemonic field\n");
d909 1
a909 2
    new_insn_mnemonic->condition =
      record->field[insn_mnemonic_condition_field];
d921 2
a922 1
parse_macro_record (table *file, table_entry *record)
d941 1
a941 1
    }
d949 2
a950 1
load_insn_table (char *file_name, cache_entry *cache)
d957 1
a957 1

d980 1
a980 1

d986 2
a987 1
					    &function, 0 /*is-internal */ ,
d994 2
a995 1
				       + strlen (function->name) + 1));
d1003 2
a1004 2

	case function_record:	/* function record */
d1008 2
a1009 1
					    NULL, 0 /*is-internal */ ,
d1020 2
a1021 1
					    &function, 1 /*is-internal */ ,
d1024 1
a1024 1
	       entry also needs to be created */
d1051 2
a1052 2

	case scratch_record:	/* cache macro records */
d1076 1
a1076 2
		notify (new_cache->line,
			"Discarding cache entry %s - filter flags\n",
d1080 1
a1080 2
				      record->
				      field[record_filter_models_field]))
d1082 1
a1082 2
		notify (new_cache->line,
			"Discarding cache entry %s - filter models\n",
d1097 2
a1098 2

	  /* model records */
d1104 1
a1104 2
	      error (record->line,
		     "Incorrect nr of fields for model record\n");
d1117 1
a1117 2
		notify (new_model->line,
			"Discarding processor model %s - filter flags\n",
d1121 1
a1121 2
				      record->
				      field[record_filter_models_field]))
d1123 1
a1123 2
		notify (new_model->line,
			"Discarding processor model %s - filter models\n",
d1139 1
a1139 1
		model->nr_models++;
d1146 1
a1146 1

d1152 1
a1152 1

d1158 1
a1158 1

d1162 2
a1163 1
					  NULL, 0 /*is internal */ ,
d1166 1
a1166 1

d1170 2
a1171 1
					  NULL, 1 /*is internal */ ,
d1174 1
a1174 1

d1178 2
a1179 1
					  NULL, 0 /*is internal */ ,
d1182 2
a1183 2

	case insn_record:	/* instruction records */
d1189 1
a1189 2
	      error (record->line,
		     "Incorrect nr of fields for insn record\n");
d1195 2
a1196 2
	       filter-out checks.  Could be filtered out because the
	       format is invalid */
d1202 1
a1202 2
	      error (new_insn->line,
		     "Unreconized instruction format name `%s'\n",
d1210 1
a1210 2
	    new_insn->model =
	      NZALLOC (insn_model_entry *, model->nr_models + 1);
d1215 1
a1215 2
		else
		  if (record_prefix_is (record, '"', nr_insn_mnemonic_fields))
d1244 2
a1245 2
		   model when both the instruction and the options are
		   nonempty */
d1262 1
a1262 1
		isa->nr_insns++;
d1270 1
a1270 1

d1287 2
a1288 1
print_insn_words (lf *file, insn_entry * insn)
d1301 1
a1301 2
		lf_printf (file, "%d.",
			   i2target (options.hi_bit_nr, field->first));
a1331 1

d1334 1
d1337 3
a1339 2
			 function_entry * functions,
			 function_entry_handler * handler, void *data)
d1351 2
a1352 1
			  insn_entry_handler * handler, void *data)
d1360 1
a1361 1

d1364 3
a1366 1
		     char *prefix, function_entry * entry, char *suffix)
d1385 3
a1387 1
		       char *prefix, function_entry * entry, char *suffix)
d1405 3
a1407 6
    case scratch_value:
      return "scratch";
    case cache_value:
      return "cache";
    case compute_value:
      return "compute";
d1414 4
a1417 1
dump_cache_entry (lf *file, char *prefix, cache_entry *entry, char *suffix)
d1424 1
a1424 2
      lf_printf (file, "\n(entry_type \"%s\")",
		 cache_entry_type_to_str (entry->entry_type));
d1435 4
a1438 1
dump_cache_entries (lf *file, char *prefix, cache_entry *entry, char *suffix)
d1452 4
a1455 1
dump_model_data (lf *file, char *prefix, model_data *entry, char *suffix)
d1472 4
a1475 1
dump_model_datas (lf *file, char *prefix, model_data *entry, char *suffix)
d1489 4
a1492 1
dump_model_entry (lf *file, char *prefix, model_entry *entry, char *suffix)
d1510 4
a1513 1
dump_model_entries (lf *file, char *prefix, model_entry *entry, char *suffix)
d1528 4
a1531 1
dump_model_table (lf *file, char *prefix, model_table *entry, char *suffix)
d1556 5
a1560 11
    case insn_field_invalid:
      ASSERT (0);
      return "(invalid)";
    case insn_field_int:
      return "int";
    case insn_field_reserved:
      return "reserved";
    case insn_field_wild:
      return "wild";
    case insn_field_string:
      return "string";
d1568 3
a1570 1
		 char *prefix, insn_field_entry *field, char *suffix)
d1580 1
a1580 2
      lf_printf (file, "%s(type %s)", sep,
		 insn_field_type_to_str (field->type));
d1608 3
a1610 1
		      char *prefix, insn_word_entry *word, char *suffix)
d1623 1
a1623 2
		   word->bit[i]->value, word->bit[i]->mask,
		   (long) word->bit[i]->field);
d1636 3
a1638 1
			char *prefix, insn_word_entry *word, char *suffix)
d1651 3
a1653 1
		       char *prefix, insn_model_entry *model, char *suffix)
d1673 3
a1675 1
			 char *prefix, insn_model_entry *model, char *suffix)
d1690 2
a1691 1
			  insn_mnemonic_entry *mnemonic, char *suffix)
d1693 1
a1693 2
  lf_printf (file, "%s(insn_mnemonic_entry *) 0x%lx", prefix,
	     (long) mnemonic);
d1712 2
a1713 1
			    insn_mnemonic_entry *mnemonic, char *suffix)
d1725 4
a1728 1
dump_insn_entry (lf *file, char *prefix, insn_entry * entry, char *suffix)
d1754 1
a1754 2
      dump_insn_mnemonic_entries (file, "\n(mnemonics ", entry->mnemonics,
				  ")");
d1758 1
a1758 1
    }
d1763 4
a1766 1
dump_insn_entries (lf *file, char *prefix, insn_entry * entry, char *suffix)
d1782 4
a1785 1
dump_insn_table (lf *file, char *prefix, insn_table *isa, char *suffix)
@


1.1.1.1.26.1
log
@Import all the copyright and indent changes from the mainline (also
richards's tweak).
@
text
@d1 1
a1 1
/* The IGEN simulator generator for GDB, the GNU Debugger.
d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d5 15
a19 18
   Contributed by Andrew Cagney.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d30 3
a32 1
parse_insn_word (line_ref *line, char *string, int word_nr)
d56 19
a74 15
  while (*chp != '\0')
    {
      char *start_pos;
      int strlen_pos;
      char *start_val;
      int strlen_val;
      insn_field_entry *new_field;

      /* create / link in the new field */
      new_field = ZALLOC (insn_field_entry);
      new_field->next = word->last;
      new_field->prev = word->last->prev;
      new_field->next->prev = new_field;
      new_field->prev->next = new_field;
      new_field->word_nr = word_nr;
d76 98
a173 4
      /* break out the first field (if present) */
      start_pos = chp;
      chp = skip_to_separator (chp, ".,!");
      strlen_pos = back_spaces (start_pos, chp) - start_pos;
d175 1
a175 2
      /* break out the second field (if present) */
      if (*chp != '.')
d177 4
a180 7
	  /* assume what was specified was the value (and not the start
	     position).  Assume the value length implicitly specifies
	     the number of bits */
	  start_val = start_pos;
	  strlen_val = strlen_pos;
	  start_pos = "";
	  strlen_pos = 0;
d182 1
a182 34
      else
	{
	  chp++;		/* skip `.' */
	  chp = skip_spaces (chp);
	  start_val = chp;
	  if (*chp == '/' || *chp == '*')
	    {
	      do
		{
		  chp++;
		}
	      while (*chp == '/' || *chp == '*');
	    }
	  else if (isalpha (*start_val))
	    {
	      do
		{
		  chp++;
		}
	      while (isalnum (*chp) || *chp == '_');
	    }
	  else if (isdigit (*start_val))
	    {
	      do
		{
		  chp++;
		}
	      while (isalnum (*chp));
	    }
	  strlen_val = chp - start_val;
	  chp = skip_spaces (chp);
	}
      if (strlen_val == 0)
	error (line, "Empty value field\n");
d184 11
a194 7
      /* break out any conditional fields - { [ "!" | "=" [ <value> | <field-name> } */
      while (*chp == '!' || *chp == '=')
	{
	  char *start;
	  char *end;
	  int len;
	  insn_field_cond *new_cond = ZALLOC (insn_field_cond);
d196 26
a221 52
	  /* determine the conditional test */
	  switch (*chp)
	    {
	    case '=':
	      new_cond->test = insn_field_cond_eq;
	      break;
	    case '!':
	      new_cond->test = insn_field_cond_ne;
	      break;
	    default:
	      ASSERT (0);
	    }

	  /* save the value */
	  chp++;
	  chp = skip_spaces (chp);
	  start = chp;
	  chp = skip_to_separator (chp, "+,:!=");
	  end = back_spaces (start, chp);
	  len = end - start;
	  if (len == 0)
	    error (line, "Missing or invalid conditional value\n");
	  new_cond->string = NZALLOC (char, len + 1);
	  strncpy (new_cond->string, start, len);

	  /* determine the conditional type */
	  if (isdigit (*start))
	    {
	      /* [ "!" | "=" ] <value> */
	      new_cond->type = insn_field_cond_value;
	      new_cond->value = a2i (new_cond->string);
	    }
	  else
	    {
	      /* [ "!" | "=" ] <field>  - check field valid */
	      new_cond->type = insn_field_cond_field;
	      /* new_cond->field is determined in later */
	    }

	  /* Only a single `=' is permitted. */
	  if ((new_cond->test == insn_field_cond_eq
	       && new_field->conditions != NULL)
	      || (new_field->conditions != NULL
		  && new_field->conditions->test == insn_field_cond_eq))
	    error (line, "Only single conditional when `=' allowed\n");

	  /* insert it */
	  {
	    insn_field_cond **last = &new_field->conditions;
	    while (*last != NULL)
	      last = &(*last)->next;
	    *last = new_cond;
d223 64
a286 106
	}

      /* NOW verify that the field was finished */
      if (*chp == ',')
	{
	  chp = skip_spaces (chp + 1);
	  if (*chp == '\0')
	    error (line, "empty field\n");
	}
      else if (*chp != '\0')
	{
	  error (line, "Missing field separator\n");
	}

      /* copy the value */
      new_field->val_string = NZALLOC (char, strlen_val + 1);
      strncpy (new_field->val_string, start_val, strlen_val);
      if (isdigit (new_field->val_string[0]))
	{
	  if (strlen_pos == 0)
	    {
	      /* when the length/pos field is omited, an integer field
	         is always binary */
	      unsigned64 val = 0;
	      int i;
	      for (i = 0; i < strlen_val; i++)
		{
		  if (new_field->val_string[i] != '0'
		      && new_field->val_string[i] != '1')
		    error (line, "invalid binary field %s\n",
			   new_field->val_string);
		  val = (val << 1) + (new_field->val_string[i] == '1');
		}
	      new_field->val_int = val;
	      new_field->type = insn_field_int;
	    }
	  else
	    {
	      new_field->val_int = a2i (new_field->val_string);
	      new_field->type = insn_field_int;
	    }
	}
      else if (new_field->val_string[0] == '/')
	{
	  new_field->type = insn_field_reserved;
	}
      else if (new_field->val_string[0] == '*')
	{
	  new_field->type = insn_field_wild;
	}
      else
	{
	  new_field->type = insn_field_string;
	  if (filter_is_member (word->field_names, new_field->val_string))
	    error (line, "Field name %s is duplicated\n",
		   new_field->val_string);
	  filter_parse (&word->field_names, new_field->val_string);
	}
      if (new_field->type != insn_field_string
	  && new_field->conditions != NULL)
	error (line, "Conditionals can only be applied to named fields\n");

      /* the copy the position */
      new_field->pos_string = NZALLOC (char, strlen_pos + 1);
      strncpy (new_field->pos_string, start_pos, strlen_pos);
      if (strlen_pos == 0)
	{
	  new_field->first = new_field->prev->last + 1;
	  if (new_field->first == 0	/* first field */
	      && *chp == '\0'	/* no further fields */
	      && new_field->type == insn_field_string)
	    {
	      /* A single string without any position, assume that it
	         represents the entire instruction word */
	      new_field->width = options.insn_bit_size;
	    }
	  else
	    {
	      /* No explicit width/position, assume value implicitly
	         supplies the width */
	      new_field->width = strlen_val;
	    }
	  new_field->last = new_field->first + new_field->width - 1;
	  if (new_field->last >= options.insn_bit_size)
	    error (line, "Bit position %d exceed instruction bit size (%d)\n",
		   new_field->last, options.insn_bit_size);
	}
      else if (options.insn_specifying_widths)
	{
	  new_field->first = new_field->prev->last + 1;
	  new_field->width = a2i (new_field->pos_string);
	  new_field->last = new_field->first + new_field->width - 1;
	  if (new_field->last >= options.insn_bit_size)
	    error (line, "Bit position %d exceed instruction bit size (%d)\n",
		   new_field->last, options.insn_bit_size);
	}
      else
	{
	  new_field->first = target_a2i (options.hi_bit_nr,
					 new_field->pos_string);
	  new_field->last = new_field->next->first - 1;	/* guess */
	  new_field->width = new_field->last - new_field->first + 1;	/* guess */
	  new_field->prev->last = new_field->first - 1;	/*fix */
	  new_field->prev->width = new_field->first - new_field->prev->first;	/*fix */
	}
    }
d289 2
a290 2
  ASSERT (word->first->last < 0);
  ASSERT (word->last->first >= options.insn_bit_size);
d308 2
a309 1
	 field->last < options.insn_bit_size; field = field->next)
d324 2
a325 2
					& ((insn_uint) 1 <<
					   (field->last - i))) != 0);
d330 1
a330 1
		   their bit value. */
d337 2
a338 2
					    & ((insn_uint) 1 <<
					       (field->last - i))) != 0);
d351 2
a352 1
parse_insn_words (insn_entry * insn, char *formats)
d408 2
a409 1
	 i < insn->nr_words; i++, word = word->next)
d422 3
a424 1
	for (f = word->first; f->last < options.insn_bit_size; f = f->next)
d427 3
a429 1
	    for (cond = f->conditions; cond != NULL; cond = cond->next)
d447 1
a447 2
				&& strcmp (refered_field->val_string,
					   cond->string) == 0)
d456 1
a456 2
					 cond->string, f->val_string,
					 refered_field->width);
d469 1
a469 1

d472 1
a472 2
typedef enum
{
d474 1
a474 1
  insn_record,			/* default */
d491 1
a491 2
}
insn_record_type;
d494 16
a509 16
  {"option", option_record},
  {"cache", cache_record},
  {"compute", compute_record},
  {"scratch", scratch_record},
  {"define", define_record},
  {"include", include_record},
  {"%s", string_function_record},
  {"function", function_record},
  {"internal", internal_record},
  {"model", model_processor_record},
  {"model-macro", model_macro_record},
  {"model-data", model_data_record},
  {"model-static", model_static_record},
  {"model-internal", model_internal_record},
  {"model-function", model_function_record},
  {NULL, insn_record},
d554 1
a554 1
	return insn_record;	/* default */
d560 3
a562 1
record_prefix_is (table_entry *entry, char ch, int nr_fields)
d577 2
a578 1
			 int nr_fields, model_data **list)
d612 1
a612 2
typedef enum
{
d622 1
a622 2
}
option_names;
d625 9
a633 9
  {"insn-bit-size", insn_bit_size_option},
  {"insn-specifying-widths", insn_specifying_widths_option},
  {"hi-bit-nr", hi_bit_nr_option},
  {"flags-filter", flags_filter_option},
  {"model-filter", model_filter_option},
  {"multi-sim", multi_sim_option},
  {"format-names", format_names_option},
  {"gen-delayed-branch", gen_delayed_branch},
  {NULL, unknown_option},
d637 2
a638 1
parse_include_record (table *file, table_entry *record)
d651 1
a651 1
    }
d659 2
a660 1
parse_option_record (table *file, table_entry *record)
d684 1
a684 2
	      error (option_record->line,
		     "Instruction bit size out of range\n");
d687 1
a687 2
	      error (option_record->line,
		     "insn-bit-size / hi-bit-nr conflict\n");
d700 1
a700 2
	      error (option_record->line,
		     "hi-bit-nr / insn-bit-size conflict\n");
d734 1
a734 1
    }
d742 4
a745 3
		       function_entry ** list,
		       function_entry ** list_entry,
		       int is_internal, model_table *model)
d779 1
a779 1
      char *model_name = record->field[function_model_name_field] + 1;	/*skip `*' */
d804 1
a804 2
	notify (new_function->line,
		"Discarding function %s - filter models\n",
d822 2
a823 1
			 insn_entry * insn, model_table *model)
d835 1
a835 1
		record->field[insn_model_name_field] + 1 /*skip `*' */ );
d839 1
a839 1
         the non-empty fields */
d858 1
a858 2
	  if (name == NULL)
	    break;
d866 2
a867 1
	  if (insn->model[index] != NULL && insn->model[index]->names != NULL)
d896 2
a897 1
			    table_entry *record, insn_entry * insn)
d906 2
a907 4
  if (new_insn_mnemonic->format[strlen (new_insn_mnemonic->format) - 1] !=
      '"')
    error (new_insn_mnemonic->line,
	   "Missing closing double quote in mnemonic field\n");
d909 1
a909 2
    new_insn_mnemonic->condition =
      record->field[insn_mnemonic_condition_field];
d921 2
a922 1
parse_macro_record (table *file, table_entry *record)
d941 1
a941 1
    }
d949 2
a950 1
load_insn_table (char *file_name, cache_entry *cache)
d957 1
a957 1

d980 1
a980 1

d986 2
a987 1
					    &function, 0 /*is-internal */ ,
d994 2
a995 1
				       + strlen (function->name) + 1));
d1003 2
a1004 2

	case function_record:	/* function record */
d1008 2
a1009 1
					    NULL, 0 /*is-internal */ ,
d1020 2
a1021 1
					    &function, 1 /*is-internal */ ,
d1024 1
a1024 1
	       entry also needs to be created */
d1051 2
a1052 2

	case scratch_record:	/* cache macro records */
d1076 1
a1076 2
		notify (new_cache->line,
			"Discarding cache entry %s - filter flags\n",
d1080 1
a1080 2
				      record->
				      field[record_filter_models_field]))
d1082 1
a1082 2
		notify (new_cache->line,
			"Discarding cache entry %s - filter models\n",
d1097 2
a1098 2

	  /* model records */
d1104 1
a1104 2
	      error (record->line,
		     "Incorrect nr of fields for model record\n");
d1117 1
a1117 2
		notify (new_model->line,
			"Discarding processor model %s - filter flags\n",
d1121 1
a1121 2
				      record->
				      field[record_filter_models_field]))
d1123 1
a1123 2
		notify (new_model->line,
			"Discarding processor model %s - filter models\n",
d1139 1
a1139 1
		model->nr_models++;
d1146 1
a1146 1

d1152 1
a1152 1

d1158 1
a1158 1

d1162 2
a1163 1
					  NULL, 0 /*is internal */ ,
d1166 1
a1166 1

d1170 2
a1171 1
					  NULL, 1 /*is internal */ ,
d1174 1
a1174 1

d1178 2
a1179 1
					  NULL, 0 /*is internal */ ,
d1182 2
a1183 2

	case insn_record:	/* instruction records */
d1189 1
a1189 2
	      error (record->line,
		     "Incorrect nr of fields for insn record\n");
d1195 2
a1196 2
	       filter-out checks.  Could be filtered out because the
	       format is invalid */
d1202 1
a1202 2
	      error (new_insn->line,
		     "Unreconized instruction format name `%s'\n",
d1210 1
a1210 2
	    new_insn->model =
	      NZALLOC (insn_model_entry *, model->nr_models + 1);
d1215 1
a1215 2
		else
		  if (record_prefix_is (record, '"', nr_insn_mnemonic_fields))
d1244 2
a1245 2
		   model when both the instruction and the options are
		   nonempty */
d1262 1
a1262 1
		isa->nr_insns++;
d1270 1
a1270 1

d1287 2
a1288 1
print_insn_words (lf *file, insn_entry * insn)
d1301 1
a1301 2
		lf_printf (file, "%d.",
			   i2target (options.hi_bit_nr, field->first));
a1331 1

d1334 1
d1337 3
a1339 2
			 function_entry * functions,
			 function_entry_handler * handler, void *data)
d1351 2
a1352 1
			  insn_entry_handler * handler, void *data)
d1360 1
a1361 1

d1364 3
a1366 1
		     char *prefix, function_entry * entry, char *suffix)
d1385 3
a1387 1
		       char *prefix, function_entry * entry, char *suffix)
d1405 3
a1407 6
    case scratch_value:
      return "scratch";
    case cache_value:
      return "cache";
    case compute_value:
      return "compute";
d1414 4
a1417 1
dump_cache_entry (lf *file, char *prefix, cache_entry *entry, char *suffix)
d1424 1
a1424 2
      lf_printf (file, "\n(entry_type \"%s\")",
		 cache_entry_type_to_str (entry->entry_type));
d1435 4
a1438 1
dump_cache_entries (lf *file, char *prefix, cache_entry *entry, char *suffix)
d1452 4
a1455 1
dump_model_data (lf *file, char *prefix, model_data *entry, char *suffix)
d1472 4
a1475 1
dump_model_datas (lf *file, char *prefix, model_data *entry, char *suffix)
d1489 4
a1492 1
dump_model_entry (lf *file, char *prefix, model_entry *entry, char *suffix)
d1510 4
a1513 1
dump_model_entries (lf *file, char *prefix, model_entry *entry, char *suffix)
d1528 4
a1531 1
dump_model_table (lf *file, char *prefix, model_table *entry, char *suffix)
d1556 5
a1560 11
    case insn_field_invalid:
      ASSERT (0);
      return "(invalid)";
    case insn_field_int:
      return "int";
    case insn_field_reserved:
      return "reserved";
    case insn_field_wild:
      return "wild";
    case insn_field_string:
      return "string";
d1568 3
a1570 1
		 char *prefix, insn_field_entry *field, char *suffix)
d1580 1
a1580 2
      lf_printf (file, "%s(type %s)", sep,
		 insn_field_type_to_str (field->type));
d1608 3
a1610 1
		      char *prefix, insn_word_entry *word, char *suffix)
d1623 1
a1623 2
		   word->bit[i]->value, word->bit[i]->mask,
		   (long) word->bit[i]->field);
d1636 3
a1638 1
			char *prefix, insn_word_entry *word, char *suffix)
d1651 3
a1653 1
		       char *prefix, insn_model_entry *model, char *suffix)
d1673 3
a1675 1
			 char *prefix, insn_model_entry *model, char *suffix)
d1690 2
a1691 1
			  insn_mnemonic_entry *mnemonic, char *suffix)
d1693 1
a1693 2
  lf_printf (file, "%s(insn_mnemonic_entry *) 0x%lx", prefix,
	     (long) mnemonic);
d1712 2
a1713 1
			    insn_mnemonic_entry *mnemonic, char *suffix)
d1725 4
a1728 1
dump_insn_entry (lf *file, char *prefix, insn_entry * entry, char *suffix)
d1754 1
a1754 2
      dump_insn_mnemonic_entries (file, "\n(mnemonics ", entry->mnemonics,
				  ")");
d1758 1
a1758 1
    }
d1763 4
a1766 1
dump_insn_entries (lf *file, char *prefix, insn_entry * entry, char *suffix)
d1782 4
a1785 1
dump_insn_table (lf *file, char *prefix, insn_table *isa, char *suffix)
@


