head	1.13;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.13
	gdb_7_6-2013-04-26-release:1.13
	gdb_7_6-branch:1.13.0.2
	gdb_7_6-2013-03-12-branchpoint:1.13
	gdb_7_5_1-2012-11-29-release:1.12
	gdb_7_5-2012-08-17-release:1.12
	gdb_7_5-branch:1.12.0.2
	gdb_7_5-2012-07-18-branchpoint:1.12
	gdb_7_4_1-2012-04-26-release:1.11.2.1
	gdb_7_4-2012-01-24-release:1.11.2.1
	gdb_7_4-branch:1.11.0.2
	gdb_7_4-2011-12-13-branchpoint:1.11
	gdb_7_3_1-2011-09-04-release:1.9
	gdb_7_3-2011-07-26-release:1.9
	gdb_7_3-branch:1.9.0.2
	gdb_7_3-2011-04-01-branchpoint:1.9
	gdb_7_2-2010-09-02-release:1.8
	gdb_7_2-branch:1.8.0.4
	gdb_7_2-2010-07-07-branchpoint:1.8
	gdb_7_1-2010-03-18-release:1.8
	gdb_7_1-branch:1.8.0.2
	gdb_7_1-2010-02-18-branchpoint:1.8
	gdb_7_0_1-2009-12-22-release:1.7
	gdb_7_0-2009-10-06-release:1.7
	gdb_7_0-branch:1.7.0.4
	gdb_7_0-2009-09-16-branchpoint:1.7
	arc-sim-20090309:1.6
	msnyder-checkpoint-072509-branch:1.7.0.2
	msnyder-checkpoint-072509-branchpoint:1.7
	arc-insight_6_8-branch:1.6.0.16
	arc-insight_6_8-branchpoint:1.6
	insight_6_8-branch:1.6.0.14
	insight_6_8-branchpoint:1.6
	reverse-20081226-branch:1.6.0.12
	reverse-20081226-branchpoint:1.6
	multiprocess-20081120-branch:1.6.0.10
	multiprocess-20081120-branchpoint:1.6
	reverse-20080930-branch:1.6.0.8
	reverse-20080930-branchpoint:1.6
	reverse-20080717-branch:1.6.0.6
	reverse-20080717-branchpoint:1.6
	msnyder-reverse-20080609-branch:1.6.0.4
	msnyder-reverse-20080609-branchpoint:1.6
	drow-reverse-20070409-branch:1.4.0.2
	drow-reverse-20070409-branchpoint:1.4
	gdb_6_8-2008-03-27-release:1.6
	gdb_6_8-branch:1.6.0.2
	gdb_6_8-2008-02-26-branchpoint:1.6
	gdb_6_7_1-2007-10-29-release:1.5
	gdb_6_7-2007-10-10-release:1.5
	gdb_6_7-branch:1.5.0.2
	gdb_6_7-2007-09-07-branchpoint:1.5
	insight_6_6-20070208-release:1.3
	gdb_6_6-2006-12-18-release:1.3
	gdb_6_6-branch:1.3.0.88
	gdb_6_6-2006-11-15-branchpoint:1.3
	insight_6_5-20061003-release:1.3
	gdb-csl-symbian-6_4_50_20060226-12:1.3
	gdb-csl-sourcerygxx-3_4_4-25:1.3
	nickrob-async-20060828-mergepoint:1.3
	gdb-csl-symbian-6_4_50_20060226-11:1.3
	gdb-csl-sourcerygxx-4_1-17:1.3
	gdb-csl-20060226-branch-local-2:1.3
	gdb-csl-sourcerygxx-4_1-14:1.3
	gdb-csl-sourcerygxx-4_1-13:1.3
	gdb-csl-sourcerygxx-4_1-12:1.3
	gdb-csl-sourcerygxx-3_4_4-21:1.3
	gdb_6_5-20060621-release:1.3
	gdb-csl-sourcerygxx-4_1-9:1.3
	gdb-csl-sourcerygxx-4_1-8:1.3
	gdb-csl-sourcerygxx-4_1-7:1.3
	gdb-csl-arm-2006q1-6:1.3
	gdb-csl-sourcerygxx-4_1-6:1.3
	gdb-csl-symbian-6_4_50_20060226-10:1.3
	gdb-csl-symbian-6_4_50_20060226-9:1.3
	gdb-csl-symbian-6_4_50_20060226-8:1.3
	gdb-csl-coldfire-4_1-11:1.3
	gdb-csl-sourcerygxx-3_4_4-19:1.3
	gdb-csl-coldfire-4_1-10:1.3
	gdb_6_5-branch:1.3.0.86
	gdb_6_5-2006-05-14-branchpoint:1.3
	gdb-csl-sourcerygxx-4_1-5:1.3
	nickrob-async-20060513-branch:1.3.0.84
	nickrob-async-20060513-branchpoint:1.3
	gdb-csl-sourcerygxx-4_1-4:1.3
	msnyder-reverse-20060502-branch:1.3.0.82
	msnyder-reverse-20060502-branchpoint:1.3
	gdb-csl-morpho-4_1-4:1.3
	gdb-csl-sourcerygxx-3_4_4-17:1.3
	readline_5_1-import-branch:1.3.0.80
	readline_5_1-import-branchpoint:1.3
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.3
	gdb-csl-symbian-20060226-branch:1.3.0.78
	gdb-csl-symbian-20060226-branchpoint:1.3
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.3
	msnyder-reverse-20060331-branch:1.3.0.76
	msnyder-reverse-20060331-branchpoint:1.3
	gdb-csl-available-20060303-branch:1.3.0.74
	gdb-csl-available-20060303-branchpoint:1.3
	gdb-csl-20060226-branch:1.3.0.72
	gdb-csl-20060226-branchpoint:1.3
	gdb_6_4-20051202-release:1.3
	msnyder-fork-checkpoint-branch:1.3.0.70
	msnyder-fork-checkpoint-branchpoint:1.3
	gdb-csl-gxxpro-6_3-branch:1.3.0.68
	gdb-csl-gxxpro-6_3-branchpoint:1.3
	gdb_6_4-branch:1.3.0.66
	gdb_6_4-2005-11-01-branchpoint:1.3
	gdb-csl-arm-20051020-branch:1.3.0.64
	gdb-csl-arm-20051020-branchpoint:1.3
	msnyder-tracepoint-checkpoint-branch:1.3.0.62
	msnyder-tracepoint-checkpoint-branchpoint:1.3
	gdb-csl-arm-20050325-2005-q1b:1.3
	gdb-csl-arm-20050325-2005-q1a:1.3
	csl-arm-20050325-branch:1.3.0.60
	csl-arm-20050325-branchpoint:1.3
	gdb_6_3-20041109-release:1.3
	gdb_6_3-branch:1.3.0.56
	gdb_6_3-20041019-branchpoint:1.3
	drow_intercu-merge-20040921:1.3
	drow_intercu-merge-20040915:1.3
	jimb-gdb_6_2-e500-branch:1.3.0.58
	jimb-gdb_6_2-e500-branchpoint:1.3
	gdb_6_2-20040730-release:1.3
	gdb_6_2-branch:1.3.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.3
	gdb_6_1_1-20040616-release:1.3
	gdb_6_1-2004-04-05-release:1.3
	drow_intercu-merge-20040402:1.3
	drow_intercu-merge-20040327:1.3
	ezannoni_pie-20040323-branch:1.3.0.52
	ezannoni_pie-20040323-branchpoint:1.3
	cagney_tramp-20040321-mergepoint:1.3
	cagney_tramp-20040309-branch:1.3.0.50
	cagney_tramp-20040309-branchpoint:1.3
	gdb_6_1-branch:1.3.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.3
	drow_intercu-20040221-branch:1.3.0.46
	drow_intercu-20040221-branchpoint:1.3
	cagney_bfdfile-20040213-branch:1.3.0.44
	cagney_bfdfile-20040213-branchpoint:1.3
	drow-cplus-merge-20040208:1.3
	carlton_dictionary-20040126-merge:1.3
	cagney_bigcore-20040122-branch:1.3.0.42
	cagney_bigcore-20040122-branchpoint:1.3
	drow-cplus-merge-20040113:1.3
	drow-cplus-merge-20031224:1.3
	drow-cplus-merge-20031220:1.3
	carlton_dictionary-20031215-merge:1.3
	drow-cplus-merge-20031214:1.3
	carlton-dictionary-20031111-merge:1.3
	gdb_6_0-2003-10-04-release:1.3
	kettenis_sparc-20030918-branch:1.3.0.40
	kettenis_sparc-20030918-branchpoint:1.3
	carlton_dictionary-20030917-merge:1.3
	ezannoni_pie-20030916-branchpoint:1.3
	ezannoni_pie-20030916-branch:1.3.0.38
	cagney_x86i386-20030821-branch:1.3.0.36
	cagney_x86i386-20030821-branchpoint:1.3
	carlton_dictionary-20030805-merge:1.3
	carlton_dictionary-20030627-merge:1.3
	gdb_6_0-branch:1.3.0.34
	gdb_6_0-2003-06-23-branchpoint:1.3
	jimb-ppc64-linux-20030613-branch:1.3.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.3
	cagney_convert-20030606-branch:1.3.0.30
	cagney_convert-20030606-branchpoint:1.3
	cagney_writestrings-20030508-branch:1.3.0.28
	cagney_writestrings-20030508-branchpoint:1.3
	jimb-ppc64-linux-20030528-branch:1.3.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.3
	carlton_dictionary-20030523-merge:1.3
	cagney_fileio-20030521-branch:1.3.0.24
	cagney_fileio-20030521-branchpoint:1.3
	kettenis_i386newframe-20030517-mergepoint:1.3
	jimb-ppc64-linux-20030509-branch:1.3.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.3
	kettenis_i386newframe-20030504-mergepoint:1.3
	carlton_dictionary-20030430-merge:1.3
	kettenis_i386newframe-20030419-branch:1.3.0.20
	kettenis_i386newframe-20030419-branchpoint:1.3
	carlton_dictionary-20030416-merge:1.3
	cagney_frameaddr-20030409-mergepoint:1.3
	kettenis_i386newframe-20030406-branch:1.3.0.18
	kettenis_i386newframe-20030406-branchpoint:1.3
	cagney_frameaddr-20030403-branchpoint:1.3
	cagney_frameaddr-20030403-branch:1.3.0.16
	cagney_framebase-20030330-mergepoint:1.3
	cagney_framebase-20030326-branch:1.3.0.14
	cagney_framebase-20030326-branchpoint:1.3
	cagney_lazyid-20030317-branch:1.3.0.12
	cagney_lazyid-20030317-branchpoint:1.3
	kettenis-i386newframe-20030316-mergepoint:1.3
	offbyone-20030313-branch:1.3.0.10
	offbyone-20030313-branchpoint:1.3
	kettenis-i386newframe-20030308-branch:1.3.0.8
	kettenis-i386newframe-20030308-branchpoint:1.3
	carlton_dictionary-20030305-merge:1.3
	cagney_offbyone-20030303-branch:1.3.0.6
	cagney_offbyone-20030303-branchpoint:1.3
	carlton_dictionary-20030207-merge:1.3
	interps-20030202-branch:1.3.0.4
	interps-20030202-branchpoint:1.3
	cagney-unwind-20030108-branch:1.3.0.2
	cagney-unwind-20030108-branchpoint:1.3
	carlton_dictionary-20021223-merge:1.3
	gdb_5_3-2002-12-12-release:1.1.1.1.26.1
	carlton_dictionary-20021115-merge:1.1.1.1
	kseitz_interps-20021105-merge:1.1.1.1
	kseitz_interps-20021103-merge:1.1.1.1
	drow-cplus-merge-20021020:1.1.1.1
	drow-cplus-merge-20021025:1.1.1.1
	carlton_dictionary-20021025-merge:1.1.1.1
	carlton_dictionary-20021011-merge:1.1.1.1
	drow-cplus-branch:1.1.1.1.0.30
	drow-cplus-branchpoint:1.1.1.1
	kseitz_interps-20020930-merge:1.1.1.1
	carlton_dictionary-20020927-merge:1.1.1.1
	carlton_dictionary-branch:1.1.1.1.0.28
	carlton_dictionary-20020920-branchpoint:1.1.1.1
	gdb_5_3-branch:1.1.1.1.0.26
	gdb_5_3-2002-09-04-branchpoint:1.1.1.1
	kseitz_interps-20020829-merge:1.1.1.1
	cagney_sysregs-20020825-branch:1.1.1.1.0.24
	cagney_sysregs-20020825-branchpoint:1.1.1.1
	readline_4_3-import-branch:1.1.1.1.0.22
	readline_4_3-import-branchpoint:1.1.1.1
	gdb_5_2_1-2002-07-23-release:1.1.1.1
	kseitz_interps-20020528-branch:1.1.1.1.0.20
	kseitz_interps-20020528-branchpoint:1.1.1.1
	cagney_regbuf-20020515-branch:1.1.1.1.0.18
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	jimb-macro-020506-branch:1.1.1.1.0.16
	jimb-macro-020506-branchpoint:1.1.1.1
	gdb_5_2-2002-04-29-release:1.1.1.1
	gdb_5_2-branch:1.1.1.1.0.14
	gdb_5_2-2002-03-03-branchpoint:1.1.1.1
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.12
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.10
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.8
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.13
date	2013.01.01.06.41.37;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2012.01.04.08.28.11;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2011.07.08.06.24.11;	author hp;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2011.07.08.02.27.18;	author hp;	state Exp;
branches;
next	1.9;

1.9
date	2011.01.01.15.34.00;	author brobecke;	state Exp;
branches;
next	1.8;

1.8
date	2010.01.01.10.03.30;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.14.10.53.07;	author brobecke;	state Exp;
branches;
next	1.6;

1.6
date	2008.01.01.22.53.24;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2007.08.24.14.28.36;	author brobecke;	state Exp;
branches;
next	1.4;

1.4
date	2007.01.09.17.59.18;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.22.04.20.49;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2002.11.22.04.09.40;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.04;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.11.2.1
date	2012.01.06.04.54.49;	author brobecke;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.35.04;	author shebs;	state Exp;
branches
	1.1.1.1.26.1
	1.1.1.1.28.1
	1.1.1.1.30.1;
next	;

1.1.1.1.26.1
date	2002.11.22.04.26.42;	author cagney;	state Exp;
branches;
next	;

1.1.1.1.28.1
date	2002.12.23.19.39.54;	author carlton;	state Exp;
branches;
next	;

1.1.1.1.30.1
date	2003.12.14.20.28.24;	author drow;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* The IGEN simulator generator for GDB, the GNU Debugger.

   Copyright 2002-2013 Free Software Foundation, Inc.

   Contributed by Andrew Cagney.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */


#include "misc.h"
#include "lf.h"
#include "table.h"
#include "filter.h"
#include "igen.h"

#include "ld-insn.h"
#include "ld-decode.h"

#include "gen.h"

#include "gen-idecode.h"
#include "gen-icache.h"
#include "gen-semantics.h"



static void
lf_print_opcodes (lf *file, gen_entry *table)
{
  if (table !=NULL)
    {
      while (1)
	{
	  ASSERT (table->opcode != NULL);
	  lf_printf (file, "_%d_%d",
		     table->opcode->first, table->opcode->last);
	  if (table->parent == NULL)
	    break;
	  lf_printf (file, "__%d", table->opcode_nr);
	  table = table->parent;
	}
    }
}




static void
print_idecode_ifetch (lf *file,
		      int previous_nr_prefetched_words,
		      int current_nr_prefetched_words)
{
  int word_nr;
  for (word_nr = previous_nr_prefetched_words;
       word_nr < current_nr_prefetched_words; word_nr++)
    {
      lf_printf (file,
		 "instruction_word instruction_%d = IMEM%d_IMMED (cia, %d);\n",
		 word_nr, options.insn_bit_size, word_nr);

    }
}



/****************************************************************/


static void
lf_print_table_name (lf *file, gen_entry *table)
{
  lf_printf (file, "idecode_table");
  lf_print_opcodes (file, table);
}



static void
print_idecode_table (lf *file, gen_entry *entry, const char *result)
{
  lf_printf (file, "/* prime the search */\n");
  lf_printf (file, "idecode_table_entry *table = ");
  lf_print_table_name (file, entry);
  lf_printf (file, ";\n");
  lf_printf (file, "int opcode = EXTRACTED%d (instruction, %d, %d);\n",
	     options.insn_bit_size,
	     i2target (options.hi_bit_nr, entry->opcode->first),
	     i2target (options.hi_bit_nr, entry->opcode->last));
  lf_printf (file, "idecode_table_entry *table_entry = table + opcode;\n");

  lf_printf (file, "\n");
  lf_printf (file, "/* iterate until a leaf */\n");
  lf_printf (file, "while (1) {\n");
  lf_printf (file, "  signed shift = table_entry->shift;\n");
  lf_printf (file, "if (shift == function_entry) break;\n");
  lf_printf (file, "  if (shift >= 0) {\n");
  lf_printf (file, "    table = ((idecode_table_entry*)\n");
  lf_printf (file, "             table_entry->function_or_table);\n");
  lf_printf (file, "    opcode = ((instruction & table_entry->mask)\n");
  lf_printf (file, "              >> shift);\n");
  lf_printf (file, "    table_entry = table + opcode;\n");
  lf_printf (file, "  }\n");
  lf_printf (file, "  else {\n");
  lf_printf (file, "    /* must be a boolean */\n");
  lf_printf (file, "    ASSERT(table_entry->shift == boolean_entry);\n");
  lf_printf (file, "    opcode = ((instruction & table_entry->mask)\n");
  lf_printf (file, "              != table_entry->value);\n");
  lf_printf (file, "    table = ((idecode_table_entry*)\n");
  lf_printf (file, "             table_entry->function_or_table);\n");
  lf_printf (file, "    table_entry = table + opcode;\n");
  lf_printf (file, "  }\n");
  lf_printf (file, "}\n");

  lf_printf (file, "\n");
  lf_printf (file, "/* call the leaf code */\n");
  if (options.gen.code == generate_jumps)
    {
      lf_printf (file, "goto *table_entry->function_or_table;\n");
    }
  else
    {
      lf_printf (file, "%s ", result);
      if (options.gen.icache)
	{
	  lf_printf (file,
		     "(((idecode_icache*)table_entry->function_or_table)\n");
	  lf_printf (file, "  (");
	  print_icache_function_actual (file, 1);
	  lf_printf (file, "));\n");
	}
      else
	{
	  lf_printf (file,
		     "((idecode_semantic*)table_entry->function_or_table)\n");
	  lf_printf (file, "  (");
	  print_semantic_function_actual (file, 1);
	  lf_printf (file, ");\n");
	}
    }
}


static void
print_idecode_table_start (lf *file, gen_entry *table, int depth, void *data)
{
  ASSERT (depth == 0);
  /* start of the table */
  if (table->opcode_rule->gen == array_gen)
    {
      lf_printf (file, "\n");
      lf_printf (file, "static idecode_table_entry ");
      lf_print_table_name (file, table);
      lf_printf (file, "[] = {\n");
    }
}

static void
print_idecode_table_leaf (lf *file, gen_entry *entry, int depth, void *data)
{
  gen_entry *master_entry;
  ASSERT (entry->parent != NULL);
  ASSERT (depth == 0);
  if (entry->combined_parent == NULL)
    master_entry = entry;
  else
    master_entry = entry->combined_parent;

  /* add an entry to the table */
  if (entry->parent->opcode_rule->gen == array_gen)
    {
      lf_printf (file, "  /*%d*/ { ", entry->opcode_nr);
      if (entry->opcode == NULL)
	{
	  ASSERT (entry->nr_insns == 1);
	  /* table leaf entry */
	  lf_printf (file, "function_entry, 0, 0, ");
	  if (options.gen.code == generate_jumps)
	    {
	      lf_printf (file, "&&");
	    }
	  print_function_name (file,
			       entry->insns->insn->name,
			       entry->insns->insn->format_name,
			       NULL,
			       master_entry->expanded_bits,
			       (options.gen.icache
				? function_name_prefix_icache
				: function_name_prefix_semantics));
	}
      else if (entry->opcode_rule->gen == switch_gen
	       || entry->opcode_rule->gen == goto_switch_gen
	       || entry->opcode_rule->gen == padded_switch_gen)
	{
	  /* table calling switch statement */
	  lf_printf (file, "function_entry, 0, 0, ");
	  if (options.gen.code == generate_jumps)
	    {
	      lf_printf (file, "&&");
	    }
	  lf_print_table_name (file, entry);
	}
      else if (entry->opcode->is_boolean)
	{
	  /* table `calling' boolean table */
	  lf_printf (file, "boolean_entry, ");
	  lf_printf (file, "MASK32(%d, %d), ",
		     i2target (options.hi_bit_nr, entry->opcode->first),
		     i2target (options.hi_bit_nr, entry->opcode->last));
	  lf_printf (file, "INSERTED32(%d, %d, %d), ",
		     entry->opcode->boolean_constant,
		     i2target (options.hi_bit_nr, entry->opcode->first),
		     i2target (options.hi_bit_nr, entry->opcode->last));
	  lf_print_table_name (file, entry);
	}
      else
	{
	  /* table `calling' another table */
	  lf_printf (file, "%d, ",
		     options.insn_bit_size - entry->opcode->last - 1);
	  lf_printf (file, "MASK%d(%d,%d), ", options.insn_bit_size,
		     i2target (options.hi_bit_nr, entry->opcode->first),
		     i2target (options.hi_bit_nr, entry->opcode->last));
	  lf_printf (file, "0, ");
	  lf_print_table_name (file, entry);
	}
      lf_printf (file, " },\n");
    }
}

static void
print_idecode_table_end (lf *file, gen_entry *table, int depth, void *data)
{
  ASSERT (depth == 0);
  if (table->opcode_rule->gen == array_gen)
    {
      lf_printf (file, "};\n");
    }
}

/****************************************************************/


static void
print_goto_switch_name (lf *file, gen_entry *entry)
{
  lf_printf (file, "case_");
  if (entry->opcode == NULL)
    {
      print_function_name (file,
			   entry->insns->insn->name,
			   entry->insns->insn->format_name,
			   NULL,
			   entry->expanded_bits,
			   (options.gen.icache
			    ? function_name_prefix_icache
			    : function_name_prefix_semantics));
    }
  else
    {
      lf_print_table_name (file, entry);
    }
}

static void
print_goto_switch_table_leaf (lf *file,
			      gen_entry *entry, int depth, void *data)
{
  ASSERT (entry->parent != NULL);
  ASSERT (depth == 0);
  ASSERT (entry->parent->opcode_rule->gen == goto_switch_gen);
  ASSERT (entry->parent->opcode);

  lf_printf (file, "/* %d */ &&", entry->opcode_nr);
  if (entry->combined_parent != NULL)
    print_goto_switch_name (file, entry->combined_parent);
  else
    print_goto_switch_name (file, entry);
  lf_printf (file, ",\n");
}

static void
print_goto_switch_break (lf *file, gen_entry *entry)
{
  lf_printf (file, "goto break_");
  lf_print_table_name (file, entry->parent);
  lf_printf (file, ";\n");
}


static void
print_goto_switch_table (lf *file, gen_entry *table)
{
  lf_printf (file, "const static void *");
  lf_print_table_name (file, table);
  lf_printf (file, "[] = {\n");
  lf_indent (file, +2);
  gen_entry_traverse_tree (file, table, 0, NULL /*start */ ,
			   print_goto_switch_table_leaf, NULL /*end */ ,
			   NULL /*data */ );
  lf_indent (file, -2);
  lf_printf (file, "};\n");
}


void print_idecode_switch (lf *file, gen_entry *table, const char *result);

static void
print_idecode_switch_start (lf *file, gen_entry *table, int depth, void *data)
{
  /* const char *result = data; */
  ASSERT (depth == 0);
  ASSERT (table->opcode_rule->gen == switch_gen
	  || table->opcode_rule->gen == goto_switch_gen
	  || table->opcode_rule->gen == padded_switch_gen);

  if (table->opcode->is_boolean
      || table->opcode_rule->gen == switch_gen
      || table->opcode_rule->gen == padded_switch_gen)
    {
      lf_printf (file, "switch (EXTRACTED%d (instruction_%d, %d, %d))\n",
		 options.insn_bit_size,
		 table->opcode_rule->word_nr,
		 i2target (options.hi_bit_nr, table->opcode->first),
		 i2target (options.hi_bit_nr, table->opcode->last));
      lf_indent (file, +2);
      lf_printf (file, "{\n");
    }
  else if (table->opcode_rule->gen == goto_switch_gen)
    {
      if (table->parent != NULL
	  && (table->parent->opcode_rule->gen == switch_gen
	      || table->parent->opcode_rule->gen == goto_switch_gen
	      || table->parent->opcode_rule->gen == padded_switch_gen))
	{
	  lf_printf (file, "{\n");
	  lf_indent (file, +2);
	}
      print_goto_switch_table (file, table);
      lf_printf (file, "ASSERT (EXTRACTED%d (instruction_%d, %d, %d)\n",
		 options.insn_bit_size,
		 table->opcode->word_nr,
		 i2target (options.hi_bit_nr, table->opcode->first),
		 i2target (options.hi_bit_nr, table->opcode->last));
      lf_printf (file, "        < (sizeof (");
      lf_print_table_name (file, table);
      lf_printf (file, ") / sizeof(void*)));\n");
      lf_printf (file, "goto *");
      lf_print_table_name (file, table);
      lf_printf (file, "[EXTRACTED%d (instruction_%d, %d, %d)];\n",
		 options.insn_bit_size,
		 table->opcode->word_nr,
		 i2target (options.hi_bit_nr, table->opcode->first),
		 i2target (options.hi_bit_nr, table->opcode->last));
    }
  else
    {
      ASSERT ("bad switch" == NULL);
    }
}


static void
print_idecode_switch_leaf (lf *file, gen_entry *entry, int depth, void *data)
{
  const char *result = data;
  ASSERT (entry->parent != NULL);
  ASSERT (depth == 0);
  ASSERT (entry->parent->opcode_rule->gen == switch_gen
	  || entry->parent->opcode_rule->gen == goto_switch_gen
	  || entry->parent->opcode_rule->gen == padded_switch_gen);
  ASSERT (entry->parent->opcode);

  /* skip over any instructions combined into another entry */
  if (entry->combined_parent != NULL)
    return;

  if (entry->parent->opcode->is_boolean && entry->opcode_nr == 0)
    {
      /* case: boolean false target */
      lf_printf (file, "case %d:\n", entry->parent->opcode->boolean_constant);
    }
  else if (entry->parent->opcode->is_boolean && entry->opcode_nr != 0)
    {
      /* case: boolean true case */
      lf_printf (file, "default:\n");
    }
  else if (entry->parent->opcode_rule->gen == switch_gen
	   || entry->parent->opcode_rule->gen == padded_switch_gen)
    {
      /* case: <opcode-nr> - switch */
      gen_entry *cob;
      for (cob = entry; cob != NULL; cob = cob->combined_next)
	lf_printf (file, "case %d:\n", cob->opcode_nr);
    }
  else if (entry->parent->opcode_rule->gen == goto_switch_gen)
    {
      /* case: <opcode-nr> - goto-switch */
      print_goto_switch_name (file, entry);
      lf_printf (file, ":\n");
    }
  else
    {
      ERROR ("bad switch");
    }
  lf_printf (file, "  {\n");
  lf_indent (file, +4);
  {
    if (entry->opcode == NULL)
      {
	/* switch calling leaf */
	ASSERT (entry->nr_insns == 1);
	print_idecode_ifetch (file, entry->nr_prefetched_words,
			      entry->insns->semantic->nr_prefetched_words);
	switch (options.gen.code)
	  {
	  case generate_jumps:
	    lf_printf (file, "goto ");
	    break;
	  case generate_calls:
	    lf_printf (file, "%s", result);
	    break;
	  }
	print_function_name (file,
			     entry->insns->insn->name,
			     entry->insns->insn->format_name,
			     NULL,
			     entry->expanded_bits,
			     (options.gen.icache
			      ? function_name_prefix_icache
			      : function_name_prefix_semantics));
	if (options.gen.code == generate_calls)
	  {
	    lf_printf (file, " (");
	    print_semantic_function_actual (file,
					    entry->insns->semantic->
					    nr_prefetched_words);
	    lf_printf (file, ")");
	  }
	lf_printf (file, ";\n");
      }
    else if (entry->opcode_rule->gen == switch_gen
	     || entry->opcode_rule->gen == goto_switch_gen
	     || entry->opcode_rule->gen == padded_switch_gen)
      {
	/* switch calling switch */
	lf_printf (file, "{\n");
	lf_indent (file, +2);
	print_idecode_ifetch (file, entry->parent->nr_prefetched_words,
			      entry->nr_prefetched_words);
	print_idecode_switch (file, entry, result);
	lf_indent (file, -2);
	lf_printf (file, "}\n");
      }
    else
      {
	/* switch looking up a table */
	lf_printf (file, "{\n");
	lf_indent (file, +2);
	print_idecode_ifetch (file, entry->parent->nr_prefetched_words,
			      entry->nr_prefetched_words);
	print_idecode_table (file, entry, result);
	lf_indent (file, -2);
	lf_printf (file, "}\n");
      }
    if (entry->parent->opcode->is_boolean
	|| entry->parent->opcode_rule->gen == switch_gen
	|| entry->parent->opcode_rule->gen == padded_switch_gen)
      {
	lf_printf (file, "break;\n");
      }
    else if (entry->parent->opcode_rule->gen == goto_switch_gen)
      {
	print_goto_switch_break (file, entry);
      }
    else
      {
	ERROR ("bad switch");
      }
  }
  lf_indent (file, -4);
  lf_printf (file, "  }\n");
}


static void
print_idecode_switch_illegal (lf *file, const char *result)
{
  lf_indent (file, +2);
  print_idecode_invalid (file, result, invalid_illegal);
  lf_printf (file, "break;\n");
  lf_indent (file, -2);
}

static void
print_idecode_switch_end (lf *file, gen_entry *table, int depth, void *data)
{
  const char *result = data;
  ASSERT (depth == 0);
  ASSERT (table->opcode_rule->gen == switch_gen
	  || table->opcode_rule->gen == goto_switch_gen
	  || table->opcode_rule->gen == padded_switch_gen);
  ASSERT (table->opcode);

  if (table->opcode->is_boolean)
    {
      lf_printf (file, "}\n");
      lf_indent (file, -2);
    }
  else if (table->opcode_rule->gen == switch_gen
	   || table->opcode_rule->gen == padded_switch_gen)
    {
      lf_printf (file, "default:\n");
      lf_indent (file, +2);
      if (table->nr_entries == table->opcode->nr_opcodes)
	{
	  print_sim_engine_abort (file,
				  "Internal error - bad switch generated");
	  lf_printf (file, "%sNULL_CIA;\n", result);
	  lf_printf (file, "break;\n");
	}
      else
	{
	  print_idecode_switch_illegal (file, result);
	}
      lf_indent (file, -2);
      lf_printf (file, "}\n");
      lf_indent (file, -2);
    }
  else if (table->opcode_rule->gen == goto_switch_gen)
    {
      lf_printf (file, "illegal_");
      lf_print_table_name (file, table);
      lf_printf (file, ":\n");
      print_idecode_invalid (file, result, invalid_illegal);
      lf_printf (file, "break_");
      lf_print_table_name (file, table);
      lf_printf (file, ":;\n");
      if (table->parent != NULL
	  && (table->parent->opcode_rule->gen == switch_gen
	      || table->parent->opcode_rule->gen == goto_switch_gen
	      || table->parent->opcode_rule->gen == padded_switch_gen))
	{
	  lf_indent (file, -2);
	  lf_printf (file, "}\n");
	}
    }
  else
    {
      ERROR ("bad switch");
    }
}


void
print_idecode_switch (lf *file, gen_entry *table, const char *result)
{
  gen_entry_traverse_tree (file, table,
			   0,
			   print_idecode_switch_start,
			   print_idecode_switch_leaf,
			   print_idecode_switch_end, (void *) result);
}


static void
print_idecode_switch_function_header (lf *file,
				      gen_entry *table,
				      int is_function_definition,
				      int nr_prefetched_words)
{
  lf_printf (file, "\n");
  if (options.gen.code == generate_calls)
    {
      lf_printf (file, "static ");
      if (options.gen.icache)
	{
	  lf_printf (file, "idecode_semantic *");
	}
      else
	{
	  lf_printf (file, "unsigned_word");
	}
      if (is_function_definition)
	{
	  lf_printf (file, "\n");
	}
      else
	{
	  lf_printf (file, " ");
	}
      lf_print_table_name (file, table);
      lf_printf (file, "\n(");
      print_icache_function_formal (file, nr_prefetched_words);
      lf_printf (file, ")");
      if (!is_function_definition)
	{
	  lf_printf (file, ";");
	}
      lf_printf (file, "\n");
    }
  if (options.gen.code == generate_jumps && is_function_definition)
    {
      lf_indent (file, -1);
      lf_print_table_name (file, table);
      lf_printf (file, ":\n");
      lf_indent (file, +1);
    }
}


static void
idecode_declare_if_switch (lf *file, gen_entry *table, int depth, void *data)
{
  if ((table->opcode_rule->gen == switch_gen || table->opcode_rule->gen == goto_switch_gen || table->opcode_rule->gen == padded_switch_gen) &&table->parent != NULL	/* don't declare the top one yet */
      && table->parent->opcode_rule->gen == array_gen)
    {
      print_idecode_switch_function_header (file,
					    table,
					    0 /*isnt function definition */ ,
					    0);
    }
}


static void
idecode_expand_if_switch (lf *file, gen_entry *table, int depth, void *data)
{
  if ((table->opcode_rule->gen == switch_gen || table->opcode_rule->gen == goto_switch_gen || table->opcode_rule->gen == padded_switch_gen) &&table->parent != NULL	/* don't expand the top one yet */
      && table->parent->opcode_rule->gen == array_gen)
    {
      print_idecode_switch_function_header (file,
					    table,
					    1 /*is function definition */ ,
					    0);
      if (options.gen.code == generate_calls)
	{
	  lf_printf (file, "{\n");
	  lf_indent (file, +2);
	}
      print_idecode_switch (file, table, "return");
      if (options.gen.code == generate_calls)
	{
	  lf_indent (file, -2);
	  lf_printf (file, "}\n");
	}
    }
}


/****************************************************************/


void
print_idecode_lookups (lf *file, gen_entry *table, cache_entry *cache_rules)
{
  int depth;

  /* output switch function declarations where needed by tables */
  gen_entry_traverse_tree (file, table, 1, idecode_declare_if_switch,	/* START */
			   NULL, NULL, NULL);

  /* output tables where needed */
  for (depth = gen_entry_depth (table); depth > 0; depth--)
    {
      gen_entry_traverse_tree (file, table,
			       1 - depth,
			       print_idecode_table_start,
			       print_idecode_table_leaf,
			       print_idecode_table_end, NULL);
    }

  /* output switch functions where needed */
  gen_entry_traverse_tree (file, table, 1, idecode_expand_if_switch,	/* START */
			   NULL, NULL, NULL);
}


void
print_idecode_body (lf *file, gen_entry *table, const char *result)
{
  if (table->opcode_rule->gen == switch_gen
      || table->opcode_rule->gen == goto_switch_gen
      || table->opcode_rule->gen == padded_switch_gen)
    {
      print_idecode_switch (file, table, result);
    }
  else
    {
      print_idecode_table (file, table, result);
    }
}


/****************************************************************/

/* Output code to do any final checks on the decoded instruction.
   This includes things like verifying any on decoded fields have the
   correct value and checking that (for floating point) floating point
   hardware isn't disabled */

void
print_idecode_validate (lf *file,
			insn_entry * instruction, insn_opcodes *opcode_paths)
{
  /* Validate: unchecked instruction fields

     If any constant fields in the instruction were not checked by the
     idecode tables, output code to check that they have the correct
     value here */
  {
    int nr_checks = 0;
    int word_nr;
    lf_printf (file, "\n");
    lf_indent_suppress (file);
    lf_printf (file, "#if defined (WITH_RESERVED_BITS)\n");
    lf_printf (file, "/* validate: ");
    print_insn_words (file, instruction);
    lf_printf (file, " */\n");
    for (word_nr = 0; word_nr < instruction->nr_words; word_nr++)
      {
	insn_uint check_mask = 0;
	insn_uint check_val = 0;
	insn_word_entry *word = instruction->word[word_nr];
	int bit_nr;

	/* form check_mask/check_val containing what needs to be checked
	   in the instruction */
	for (bit_nr = 0; bit_nr < options.insn_bit_size; bit_nr++)
	  {
	    insn_bit_entry *bit = word->bit[bit_nr];
	    insn_field_entry *field = bit->field;

	    /* Make space for the next bit */
	    check_mask <<= 1;
	    check_val <<= 1;

	    /* Only need to validate constant (and reserved)
	       bits. Skip any others */
	    if (field->type != insn_field_int
		&& field->type != insn_field_reserved
		/* Consider a named field equal to a value to be just as
		   constant as an integer field.  */
		&& (field->type != insn_field_string
		    || field->conditions == NULL
		    || field->conditions->test != insn_field_cond_eq
		    || field->conditions->type != insn_field_cond_value))
	      continue;

	    /* Look through the list of opcode paths that lead to this
	       instruction.  See if any have failed to check the
	       relevant bit */
	    if (opcode_paths != NULL)
	      {
		insn_opcodes *entry;
		for (entry = opcode_paths; entry != NULL; entry = entry->next)
		  {
		    opcode_field *opcode;
		    for (opcode = entry->opcode;
			 opcode != NULL; opcode = opcode->parent)
		      {
			if (opcode->word_nr == word_nr
			    && opcode->first <= bit_nr
			    && opcode->last >= bit_nr)
			  /* we've decoded on this bit */
			  break;
		      }
		    if (opcode == NULL)
		      /* the bit wasn't decoded on */
		      break;
		  }
		if (entry == NULL)
		  /* all the opcode paths decoded on BIT_NR, no need
		     to check it */
		  continue;
	      }

	    check_mask |= 1;
	    check_val |= bit->value;
	  }

	/* if any bits not checked by opcode tables, output code to check them */
	if (check_mask)
	  {
	    if (nr_checks == 0)
	      {
		lf_printf (file, "if (WITH_RESERVED_BITS)\n");
		lf_printf (file, "  {\n");
		lf_indent (file, +4);
	      }
	    nr_checks++;
	    if (options.insn_bit_size > 32)
	      {
		lf_printf (file, "if ((instruction_%d\n", word_nr);
		lf_printf (file, "     & UNSIGNED64 (0x%08lx%08lx))\n",
			   (unsigned long) (check_mask >> 32),
			   (unsigned long) (check_mask));
		lf_printf (file, "    != UNSIGNED64 (0x%08lx%08lx))\n",
			   (unsigned long) (check_val >> 32),
			   (unsigned long) (check_val));
	      }
	    else
	      {
		lf_printf (file,
			   "if ((instruction_%d & 0x%08lx) != 0x%08lx)\n",
			   word_nr, (unsigned long) (check_mask),
			   (unsigned long) (check_val));
	      }
	    lf_indent (file, +2);
	    print_idecode_invalid (file, "return", invalid_illegal);
	    lf_indent (file, -2);
	  }
      }
    if (nr_checks > 0)
      {
	lf_indent (file, -4);
	lf_printf (file, "  }\n");
      }
    lf_indent_suppress (file);
    lf_printf (file, "#endif\n");
  }

  /* Validate: Floating Point hardware

     If the simulator is being built with out floating point hardware
     (different to it being disabled in the MSR) then floating point
     instructions are invalid */
  {
    if (filter_is_member (instruction->flags, "f"))
      {
	lf_printf (file, "\n");
	lf_indent_suppress (file);
	lf_printf (file, "#if defined(CURRENT_FLOATING_POINT)\n");
	lf_printf (file, "/* Validate: FP hardware exists */\n");
	lf_printf (file,
		   "if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {\n");
	lf_indent (file, +2);
	print_idecode_invalid (file, "return", invalid_illegal);
	lf_indent (file, -2);
	lf_printf (file, "}\n");
	lf_indent_suppress (file);
	lf_printf (file, "#endif\n");
      }
  }

  /* Validate: Floating Point available

     If floating point is not available, we enter a floating point
     unavailable interrupt into the cache instead of the instruction
     proper.

     The PowerPC spec requires a CSI after MSR[FP] is changed and when
     ever a CSI occures we flush the instruction cache. */

  {
    if (filter_is_member (instruction->flags, "f"))
      {
	lf_printf (file, "\n");
	lf_indent_suppress (file);
	lf_printf (file, "#if defined(IS_FP_AVAILABLE)\n");
	lf_printf (file, "/* Validate: FP available according to cpu */\n");
	lf_printf (file, "if (!IS_FP_AVAILABLE) {\n");
	lf_indent (file, +2);
	print_idecode_invalid (file, "return", invalid_fp_unavailable);
	lf_indent (file, -2);
	lf_printf (file, "}\n");
	lf_indent_suppress (file);
	lf_printf (file, "#endif\n");
      }
  }

  /* Validate: Validate Instruction in correct slot

     Some architectures place restrictions on the slot that an
     instruction can be issued in */

  {
    if (filter_is_member (instruction->options, "s")
	|| options.gen.slot_verification)
      {
	lf_printf (file, "\n");
	lf_indent_suppress (file);
	lf_printf (file, "#if defined(IS_WRONG_SLOT)\n");
	lf_printf (file,
		   "/* Validate: Instruction issued in correct slot */\n");
	lf_printf (file, "if (IS_WRONG_SLOT) {\n");
	lf_indent (file, +2);
	print_idecode_invalid (file, "return", invalid_wrong_slot);
	lf_indent (file, -2);
	lf_printf (file, "}\n");
	lf_indent_suppress (file);
	lf_printf (file, "#endif\n");
      }
  }

}


/****************************************************************/


void
print_idecode_issue_function_header (lf *file,
				     const char *processor,
				     function_decl_type decl_type,
				     int nr_prefetched_words)
{
  int indent;
  lf_printf (file, "\n");
  switch (decl_type)
    {
    case is_function_declaration:
      lf_print__function_type_function (file, print_semantic_function_type,
					"INLINE_IDECODE", " ");
      break;
    case is_function_definition:
      lf_print__function_type_function (file, print_semantic_function_type,
					"INLINE_IDECODE", "\n");
      break;
    case is_function_variable:
      print_semantic_function_type (file);
      lf_printf (file, " (*");
      break;
    }
  indent = print_function_name (file,
				"issue",
				NULL,
				processor,
				NULL, function_name_prefix_idecode);
  switch (decl_type)
    {
    case is_function_definition:
      indent += lf_printf (file, " (");
      break;
    case is_function_declaration:
      lf_putstr (file, "\n(");
      indent = 1;
      break;
    case is_function_variable:
      lf_putstr (file, ")\n(");
      indent = 1;
      break;
    }
  lf_indent (file, +indent);
  print_semantic_function_formal (file, nr_prefetched_words);
  lf_putstr (file, ")");
  lf_indent (file, -indent);
  switch (decl_type)
    {
    case is_function_definition:
      lf_printf (file, "\n");
      break;
    case is_function_declaration:
    case is_function_variable:
      lf_putstr (file, ";\n");
      break;
    }
}



void
print_idecode_globals (lf *file)
{
  lf_printf (file, "enum {\n");
  lf_printf (file, "  /* greater or equal to zero => table */\n");
  lf_printf (file, "  function_entry = -1,\n");
  lf_printf (file, "  boolean_entry = -2,\n");
  lf_printf (file, "};\n");
  lf_printf (file, "\n");
  lf_printf (file, "typedef struct _idecode_table_entry {\n");
  lf_printf (file, "  int shift;\n");
  lf_printf (file, "  unsigned%d mask;\n", options.insn_bit_size);
  lf_printf (file, "  unsigned%d value;\n", options.insn_bit_size);
  lf_printf (file, "  void *function_or_table;\n");
  lf_printf (file, "} idecode_table_entry;\n");
}
@


1.12
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright 2002, 2007-2012 Free Software Foundation, Inc.
@


1.11
log
@	Correct handling of constant fields.
	* gen.c (insn_field_cmp): Tweak comment about neither field
	being an insn_field_string with a cond_eq-to-value condition.
	(insns_bit_useless) <case insn_field_string, case
	decode_find_mixed>: Handle cond_eq-to-value fields as
	insn_field_int.
	* gen-idecode.c (print_idecode_validate): Handle
	insn_field_string cond-equal-to-value fields as insn_field_int.
	* gen-icache.c (print_icache_body): Add comment why constant
	string fields are handled.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.11.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright 2002, 2007-2012 Free Software Foundation, Inc.
@


1.10
log
@	Remove all #if 0'd code.
	* filter.c: Remove #if 0'd function it_is.
	(main): Remove #if 0'd code.
	* gen-engine.c: Remove #if 0'd functions print_jump,
	print_jump_insn, print_jump_definition,
	print_jump_internal_function, print_jump_body.
	(gen_engine_c): Remove #if 0'd code.
	* gen-idecode.c: Remove #if 0'd functions print_jump print_jump,
	print_jump_insn, print_jump_definition,
	print_jump_internal_function, print_jump_until_stop_body.
	* gen-model.c: Remove #if 0'd functions model_c_or_h_data,
	model_c_or_h_function, gen_model_h, model_c_insn,
	model_c_function, gen_model_c and types model_c_passed_data
	and struct _model_c_passed_data.
	* gen.c: Remove #if 0'd type constant_field_types and function
	insn_field_is_constant.
	(gen_entry_find_opcode_field): Remove #if 0'd code.
	* ld-insn.c (parse_insn_model_record): Remove #if 0'd code.
	* misc.h (STRDUP, STRNDUP): Remove #if 0'd macros.
@
text
@d753 7
a759 1
		&& field->type != insn_field_reserved)
@


1.9
log
@run copyright.sh for 2011.
@
text
@a708 321
#if 0
static void
print_jump (lf *file, int is_tail)
{
  if (is_tail)
    {
      lf_putstr (file, "if (keep_running != NULL && !*keep_running)\n");
      lf_putstr (file, "  cpu_halt(cpu, nia, was_continuing, 0/*na*/);\n");
    }

  if (!options.generate_smp)
    {
      lf_putstr (file, "if (WITH_EVENTS) {\n");
      lf_putstr (file, "  if (event_queue_tick(events)) {\n");
      lf_putstr (file, "    cpu_set_program_counter(cpu, nia);\n");
      lf_putstr (file, "    event_queue_process(events);\n");
      lf_putstr (file, "    nia = cpu_get_program_counter(cpu);\n");
      lf_putstr (file, "  }\n");
      lf_putstr (file, "}\n");
    }

  if (options.generate_smp)
    {
      if (is_tail)
	{
	  lf_putstr (file, "cpu_set_program_counter(cpu, nia);\n");
	}
      lf_putstr (file, "if (WITH_EVENTS) {\n");
      lf_putstr (file, "  current_cpu += 1;\n");
      lf_putstr (file, "  if (current_cpu >= nr_cpus) {\n");
      lf_putstr (file, "    if (event_queue_tick(events)) {\n");
      lf_putstr (file, "      event_queue_process(events);\n");
      lf_putstr (file, "    }\n");
      lf_putstr (file, "    current_cpu = 0;\n");
      lf_putstr (file, "  }\n");
      lf_putstr (file, "}\n");
      lf_putstr (file, "else {\n");
      lf_putstr (file, "  current_cpu = (current_cpu + 1) % nr_cpus;\n");
      lf_putstr (file, "}\n");
      lf_putstr (file, "cpu = cpus[current_cpu];\n");
      lf_putstr (file, "nia = cpu_get_program_counter(cpu);\n");
    }

  if (options.gen.icache)
    {
      lf_putstr (file, "cache_entry = cpu_icache_entry(cpu, nia);\n");
      lf_putstr (file, "if (cache_entry->address == nia) {\n");
      lf_putstr (file, "  /* cache hit */\n");
      lf_putstr (file, "  goto *cache_entry->semantic;\n");
      lf_putstr (file, "}\n");
      if (is_tail)
	{
	  lf_putstr (file, "goto cache_miss;\n");
	}
    }

  if (!options.gen.icache && is_tail)
    {
      lf_printf (file, "goto idecode;\n");
    }

}
#endif



#if 0
static void
print_jump_insn (lf *file,
		 insn_entry * instruction,
		 insn_bits * expanded_bits,
		 opcode_field *opcodes, cache_entry *cache_rules)
{

  /* what we are for the moment */
  lf_printf (file, "\n");
  print_my_defines (file, expanded_bits, instruction->name);

  /* output the icache entry */
  if (options.gen.icache)
    {
      lf_printf (file, "\n");
      lf_indent (file, -1);
      print_function_name (file,
			   instruction->name,
			   expanded_bits, function_name_prefix_icache);
      lf_printf (file, ":\n");
      lf_indent (file, +1);
      lf_printf (file, "{\n");
      lf_indent (file, +2);
      lf_putstr (file, "const unsigned_word cia = nia;\n");
      print_itrace (file, instruction, 1 /*putting-value-in-cache */ );
      print_idecode_validate (file, instruction, opcodes);
      lf_printf (file, "\n");
      lf_printf (file, "{\n");
      lf_indent (file, +2);
      print_icache_body (file, instruction, expanded_bits, cache_rules, 0,	/*use_defines */
			 put_values_in_icache);
      lf_printf (file, "cache_entry->address = nia;\n");
      lf_printf (file, "cache_entry->semantic = &&");
      print_function_name (file,
			   instruction->name,
			   expanded_bits, function_name_prefix_semantics);
      lf_printf (file, ";\n");
      if (options.gen.semantic_icache)
	{
	  print_semantic_body (file, instruction, expanded_bits, opcodes);
	  print_jump (file, 1 /*is-tail */ );
	}
      else
	{
	  lf_printf (file, "/* goto ");
	  print_function_name (file,
			       instruction->name,
			       expanded_bits, function_name_prefix_semantics);
	  lf_printf (file, "; */\n");
	}
      lf_indent (file, -2);
      lf_putstr (file, "}\n");
      lf_indent (file, -2);
      lf_printf (file, "}\n");
    }

  /* print the semantics */
  lf_printf (file, "\n");
  lf_indent (file, -1);
  print_function_name (file,
		       instruction->name,
		       expanded_bits, function_name_prefix_semantics);
  lf_printf (file, ":\n");
  lf_indent (file, +1);
  lf_printf (file, "{\n");
  lf_indent (file, +2);
  lf_putstr (file, "const unsigned_word cia = nia;\n");
  print_icache_body (file,
		     instruction,
		     expanded_bits,
		     cache_rules,
		     (options.gen.direct_access
		      ? define_variables
		      : declare_variables),
		     (options.gen.icache
		      ? get_values_from_icache : do_not_use_icache));
  print_semantic_body (file, instruction, expanded_bits, opcodes);
  if (options.gen.direct_access)
    print_icache_body (file,
		       instruction,
		       expanded_bits,
		       cache_rules,
		       undef_variables,
		       (options.gen.icache
			? get_values_from_icache : do_not_use_icache));
  print_jump (file, 1 /*is tail */ );
  lf_indent (file, -2);
  lf_printf (file, "}\n");
}
#endif


#if 0
static void
print_jump_definition (lf *file,
		       gen_entry *entry,
		       insn_entry * insn, int depth, void *data)
{
  cache_entry *cache_rules = (cache_entry *) data;
  if (options.generate_expanded_instructions)
    {
      ASSERT (entry->nr_insns == 1
	      && entry->opcode == NULL
	      && entry->parent != NULL && entry->parent->opcode != NULL);
      ASSERT (entry->nr_insns == 1
	      && entry->opcode == NULL
	      && entry->parent != NULL
	      && entry->parent->opcode != NULL
	      && entry->parent->opcode_rule != NULL);
      print_jump_insn (file,
		       entry->insns->words[0]->insn,
		       entry->expanded_bits, entry->opcode, cache_rules);
    }
  else
    {
      print_jump_insn (file,
		       instruction->words[0]->insn, NULL, NULL, cache_rules);
    }
}
#endif

#if 0
static void
print_jump_internal_function (lf *file,
			      gen_entry *table,
			      function_entry * function, void *data)
{
  if (function->is_internal)
    {
      lf_printf (file, "\n");
      lf_print__line_ref (file, function->line);
      lf_indent (file, -1);
      print_function_name (file,
			   function->name,
			   NULL,
			   (options.gen.icache
			    ? function_name_prefix_icache
			    : function_name_prefix_semantics));
      lf_printf (file, ":\n");
      lf_indent (file, +1);
      lf_printf (file, "{\n");
      lf_indent (file, +2);
      lf_printf (file, "const unsigned_word cia = nia;\n");
      table_print_code (file, function->code);
      lf_print__internal_ref (file);
      print_sim_engine_abort (file, "Internal function must longjump");
      lf_indent (file, -2);
      lf_printf (file, "}\n");
    }
}
#endif



#if 0
static void
print_jump_until_stop_body (lf *file,
			    insn_table *table, cache_table * cache_rules)
{
  lf_printf (file, "{\n");
  lf_indent (file, +2);
  lf_putstr (file, "jmp_buf halt;\n");
  lf_putstr (file, "jmp_buf restart;\n");
  lf_putstr (file, "sim_cpu *cpu = NULL;\n");
  lf_putstr (file, "unsigned_word nia = -1;\n");
  lf_putstr (file, "instruction_word instruction = 0;\n");
  if ((code & generate_with_icache))
    {
      lf_putstr (file, "idecode_cache *cache_entry = NULL;\n");
    }
  if (generate_smp)
    {
      lf_putstr (file, "int current_cpu = -1;\n");
    }

  /* all the switches and tables - they know about jumping */
  print_idecode_lookups (file, table, cache_rules);

  /* start the simulation up */
  if ((code & generate_with_icache))
    {
      lf_putstr (file, "\n");
      lf_putstr (file, "{\n");
      lf_putstr (file, "  int cpu_nr;\n");
      lf_putstr (file, "  for (cpu_nr = 0; cpu_nr < nr_cpus; cpu_nr++)\n");
      lf_putstr (file, "    cpu_flush_icache(cpus[cpu_nr]);\n");
      lf_putstr (file, "}\n");
    }

  lf_putstr (file, "\n");
  lf_putstr (file, "psim_set_halt_and_restart(system, &halt, &restart);\n");

  lf_putstr (file, "\n");
  lf_putstr (file, "if (setjmp(halt))\n");
  lf_putstr (file, "  return;\n");

  lf_putstr (file, "\n");
  lf_putstr (file, "setjmp(restart);\n");

  lf_putstr (file, "\n");
  if (!generate_smp)
    {
      lf_putstr (file, "cpu = cpus[0];\n");
      lf_putstr (file, "nia = cpu_get_program_counter(cpu);\n");
    }
  else
    {
      lf_putstr (file, "current_cpu = psim_last_cpu(system);\n");
    }

  if (!(code & generate_with_icache))
    {
      lf_printf (file, "\n");
      lf_indent (file, -1);
      lf_printf (file, "idecode:\n");
      lf_indent (file, +1);
    }

  print_jump (file, 0 /*is_tail */ );

  if ((code & generate_with_icache))
    {
      lf_indent (file, -1);
      lf_printf (file, "cache_miss:\n");
      lf_indent (file, +1);
    }

  lf_putstr (file, "instruction\n");
  lf_putstr (file, "  = vm_instruction_map_read(cpu_instruction_map(cpu),\n");
  lf_putstr (file, "                            cpu, nia);\n");
  print_idecode_body (file, table, "/*IGORE*/");

  /* print out a table of all the internals functions */
  insn_table_traverse_function (table,
				file, NULL, print_jump_internal_function);

  /* print out a table of all the instructions */
  if (generate_expanded_instructions)
    insn_table_traverse_tree (table, file, cache_rules, 1, NULL,	/* start */
			      print_jump_definition,	/* leaf */
			      NULL,	/* end */
			      NULL);	/* padding */
  else
    insn_table_traverse_insn (table,
			      file, cache_rules, print_jump_definition);
  lf_indent (file, -2);
  lf_printf (file, "}\n");
}
#endif

/****************************************************************/



@


1.8
log
@Update copyright notices to add year 2010.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.7
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.6
log
@	Updated copyright notices for most files.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008 Free Software Foundation, Inc.
@


1.5
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d3 1
a3 1
   Copyright 2002, 2007 Free Software Foundation, Inc.
@


1.4
log
@Copyright updates for 2007.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.3
log
@2002-11-21  Andrew Cagney  <ac131313@@redhat.com>

	* filter.c: Re-indent.
	* filter.h, filter_host.h, gen-engine.c, gen-engine.h: Ditto.
	* gen-icache.c, gen-icache.h, gen-idecode.c: Ditto.
	* gen-idecode.h, gen-itable.c, gen-itable.h: Ditto.
	* gen-model.c, gen-model.h, gen-semantics.c: Ditto.
	* gen-semantics.h, gen-support.c, gen-support.h: Ditto.
	* gen.c, gen.h, igen.c, igen.h, ld-cache.c, ld-cache.h: Ditto.
	* ld-decode.c, ld-decode.h, ld-insn.c, ld-insn.h, lf.c: Ditto.
	* lf.h, misc.c, misc.h, table.c, table.h: Ditto.
@
text
@d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
@


1.2
log
@2002-11-21  Andrew Cagney  <ac131313@@redhat.com>

        * Makefile.in: Update copyright.  IGEN contributed to the FSF.
        * filter.c, filter.h, filter_host.c, filter_host.h: Ditto.
        * gen-engine.c, gen-engine.h, gen-icache.c, gen-icache.h: Ditto.
        * gen-idecode.c, gen-idecode.h, gen-itable.c: Ditto.
        * gen-itable.h, gen-model.c, gen-model.h, gen-semantics.c: Ditto.
        * gen-semantics.h, gen-support.c, gen-support.h, gen.c: Ditto.
        * gen.h, igen.c, igen.h, ld-cache.c, ld-cache.h: Ditto.
        * ld-decode.c, ld-decode.h, ld-insn.c, ld-insn.h, lf.c: Ditto.
        * lf.h, misc.c, misc.h, table.c, table.h: Ditto.
@
text
@d43 1
a43 2
lf_print_opcodes (lf *file,
		  gen_entry *table)
d45 1
a45 1
  if (table != NULL)
d51 3
a53 3
		     table->opcode->first,
		     table->opcode->last);
	  if (table->parent == NULL) break;
d70 1
a70 2
       word_nr < current_nr_prefetched_words;
       word_nr ++)
d72 2
a73 1
      lf_printf (file, "instruction_word instruction_%d = IMEM%d_IMMED (cia, %d);\n",
d75 1
a75 1
      
d85 1
a85 2
lf_print_table_name (lf *file,
		     gen_entry *table)
d94 1
a94 3
print_idecode_table (lf *file,
		     gen_entry *entry,
		     const char *result)
d105 1
a105 1
  
d128 1
a128 1
  
d140 2
a141 1
	  lf_printf (file, "(((idecode_icache*)table_entry->function_or_table)\n");
d148 2
a149 1
	  lf_printf (file, "((idecode_semantic*)table_entry->function_or_table)\n");
d159 1
a159 4
print_idecode_table_start (lf *file,
			   gen_entry *table,
			   int depth,
			   void *data)
d173 1
a173 4
print_idecode_table_leaf (lf *file,
			  gen_entry *entry,
			  int depth,
			  void *data)
d233 3
a235 3
	  lf_printf (file, "%d, ", options.insn_bit_size - entry->opcode->last - 1);
	  lf_printf (file, "MASK%d(%d,%d), ",
		     options.insn_bit_size,
d246 1
a246 4
print_idecode_table_end (lf *file,
			 gen_entry *table,
			 int depth,
			 void *data)
d249 4
a252 3
  if (table->opcode_rule->gen == array_gen) {
    lf_printf (file, "};\n");
  }
d259 1
a259 2
print_goto_switch_name (lf *file,
			gen_entry *entry)
d275 1
a275 1
      lf_print_table_name(file, entry);
d281 1
a281 3
			      gen_entry *entry,
			      int depth,
			      void *data)
d287 1
a287 1
  
d297 1
a297 2
print_goto_switch_break (lf *file,
			 gen_entry *entry)
d306 1
a306 2
print_goto_switch_table (lf *file,
			 gen_entry *table)
d312 3
a314 6
  gen_entry_traverse_tree (file, table,
			   0,
			   NULL/*start*/,
			   print_goto_switch_table_leaf,
			   NULL/*end*/,
			   NULL/*data*/);
d320 1
a320 4
void print_idecode_switch
(lf *file, 
 gen_entry *table,
 const char *result);
d323 1
a323 4
print_idecode_switch_start (lf *file,
			    gen_entry *table,
			    int depth,
			    void *data)
d330 1
a330 1
  
d372 1
a372 1
      ASSERT("bad switch" == NULL);
d378 1
a378 4
print_idecode_switch_leaf (lf *file,
			   gen_entry *entry,
			   int depth,
			   void *data)
d387 1
a387 1
  
d392 1
a392 2
  if (entry->parent->opcode->is_boolean
	   && entry->opcode_nr == 0)
d397 1
a397 2
  else if (entry->parent->opcode->is_boolean
	   && entry->opcode_nr != 0)
d449 3
a451 1
	    print_semantic_function_actual (file, entry->insns->semantic->nr_prefetched_words);
d488 1
a488 1
	print_goto_switch_break(file, entry);
d501 1
a501 2
print_idecode_switch_illegal (lf *file,
			      const char *result)
d510 1
a510 4
print_idecode_switch_end (lf *file,
			  gen_entry *table,
			  int depth,
			  void *data)
d518 1
a518 1
  
d531 2
a532 1
	  print_sim_engine_abort (file, "Internal error - bad switch generated");
d551 1
a551 1
      lf_print_table_name(file, table);
d570 1
a570 3
print_idecode_switch (lf *file, 
		      gen_entry *table,
		      const char *result)
d576 1
a576 2
			   print_idecode_switch_end,
			   (void*)result);
d627 3
a629 9
idecode_declare_if_switch (lf *file,
			   gen_entry *table,
			   int depth,
			   void *data)
{
  if ((table->opcode_rule->gen == switch_gen
       || table->opcode_rule->gen == goto_switch_gen
       || table->opcode_rule->gen == padded_switch_gen)
      && table->parent != NULL /* don't declare the top one yet */
d634 1
a634 1
					    0/*isnt function definition*/,
d641 3
a643 9
idecode_expand_if_switch (lf *file,
			  gen_entry *table,
			  int depth,
			  void *data)
{
  if ((table->opcode_rule->gen == switch_gen
       || table->opcode_rule->gen == goto_switch_gen
       || table->opcode_rule->gen == padded_switch_gen)
      && table->parent != NULL /* don't expand the top one yet */
d646 4
a649 4
      print_idecode_switch_function_header(file,
					   table,
					   1/*is function definition*/,
					   0);
d655 1
a655 1
      print_idecode_switch(file, table, "return");
d669 1
a669 3
print_idecode_lookups (lf *file,
		       gen_entry *table,
		       cache_entry *cache_rules)
d672 1
a672 1
  
d674 3
a676 6
  gen_entry_traverse_tree (file, table,
			   1,
			   idecode_declare_if_switch, /* START */
			   NULL, NULL,
			   NULL);
  
d678 1
a678 3
  for (depth = gen_entry_depth (table);
       depth > 0;
       depth--)
d681 1
a681 1
			       1-depth,
d684 1
a684 2
			       print_idecode_table_end,
			       NULL);
d686 1
a686 1
  
d688 2
a689 5
  gen_entry_traverse_tree (file, table,
			    1,
			    idecode_expand_if_switch, /* START */
			    NULL, NULL,
			    NULL);
d694 1
a694 3
print_idecode_body (lf *file,
		    gen_entry *table,
		    const char *result)
d713 1
a713 2
print_jump (lf *file,
	    int is_tail)
d720 1
a720 1
  
d731 1
a731 1
  
d753 1
a753 1
  
d771 1
a771 1
  
d780 3
a782 4
		 insn_entry *instruction,
		 insn_bits *expanded_bits,
		 opcode_field *opcodes,
		 cache_entry *cache_rules)
d784 1
a784 1
  
d788 1
a788 1
  
d796 1
a796 2
			   expanded_bits,
			   function_name_prefix_icache);
d802 1
a802 1
      print_itrace (file, instruction, 1/*putting-value-in-cache*/);
d807 1
a807 5
      print_icache_body (file,
			 instruction,
			 expanded_bits,
			 cache_rules,
			 0, /*use_defines*/
d813 1
a813 2
			   expanded_bits,
			   function_name_prefix_semantics);
d817 2
a818 5
	  print_semantic_body (file,
			       instruction,
			       expanded_bits,
			       opcodes);
	  print_jump (file, 1/*is-tail*/);
d825 1
a825 2
			       expanded_bits,
			       function_name_prefix_semantics);
d833 1
a833 1
  
d839 1
a839 2
		       expanded_bits,
		       function_name_prefix_semantics);
d853 2
a854 6
		      ? get_values_from_icache
		      : do_not_use_icache));
  print_semantic_body (file,
		       instruction,
		       expanded_bits,
		       opcodes);
d862 2
a863 3
			? get_values_from_icache
			: do_not_use_icache));
  print_jump (file, 1/*is tail*/);
d874 1
a874 3
		       insn_entry *insn,
		       int depth,
		       void *data)
d876 1
a876 1
  cache_entry *cache_rules = (cache_entry*)data;
d881 1
a881 2
	      && entry->parent != NULL
	      && entry->parent->opcode != NULL);
d889 1
a889 3
		       entry->expanded_bits,
		       entry->opcode,
		       cache_rules);
d894 1
a894 4
		       instruction->words[0]->insn,
		       NULL,
		       NULL,
		       cache_rules);
d903 1
a903 2
			      function_entry *function,
			      void *data)
d934 2
a935 3
print_jump_until_stop_body(lf *file,
			   insn_table *table,
			   cache_table *cache_rules)
d944 8
a951 6
  if ((code & generate_with_icache)) {
    lf_putstr (file, "idecode_cache *cache_entry = NULL;\n");
  }
  if (generate_smp) {
    lf_putstr (file, "int current_cpu = -1;\n");
  }
d954 2
a955 2
  print_idecode_lookups(file, table, cache_rules);
 
d957 9
a965 8
  if ((code & generate_with_icache)) {
    lf_putstr (file, "\n");
    lf_putstr (file, "{\n");
    lf_putstr (file, "  int cpu_nr;\n");
    lf_putstr (file, "  for (cpu_nr = 0; cpu_nr < nr_cpus; cpu_nr++)\n");
    lf_putstr (file, "    cpu_flush_icache(cpus[cpu_nr]);\n");
    lf_putstr (file, "}\n");
  }
d978 9
a986 7
  if (!generate_smp) {
    lf_putstr (file, "cpu = cpus[0];\n");
    lf_putstr (file, "nia = cpu_get_program_counter(cpu);\n");
  }
  else {
    lf_putstr (file, "current_cpu = psim_last_cpu(system);\n");
  }
d988 7
a994 6
  if (!(code & generate_with_icache)) {
    lf_printf (file, "\n");
    lf_indent (file, -1);
    lf_printf (file, "idecode:\n");
    lf_indent (file, +1);
  }
d996 1
a996 1
  print_jump(file, 0/*is_tail*/);
d998 6
a1003 5
  if ((code & generate_with_icache)) {
    lf_indent (file, -1);
    lf_printf (file, "cache_miss:\n");
    lf_indent (file, +1);
  }
d1008 1
a1008 1
  print_idecode_body(file, table, "/*IGORE*/");
d1011 2
a1012 3
  insn_table_traverse_function(table,
			       file, NULL,
			       print_jump_internal_function);
d1014 1
a1014 1
 /* print out a table of all the instructions */
d1016 4
a1019 7
    insn_table_traverse_tree(table,
			     file, cache_rules,
			     1,
			     NULL, /* start */
			     print_jump_definition, /* leaf */
			     NULL, /* end */
			     NULL); /* padding */
d1021 2
a1022 3
    insn_table_traverse_insn(table,
			     file, cache_rules,
			     print_jump_definition);
d1039 1
a1039 2
			insn_entry *instruction,
			insn_opcodes *opcode_paths)
d1072 1
a1072 1
	    
d1074 1
a1074 1
               bits. Skip any others */
d1080 2
a1081 2
               instruction.  See if any have failed to check the
               relevant bit */
d1085 1
a1085 3
		for (entry = opcode_paths;
		     entry != NULL;
		     entry = entry->next)
d1089 1
a1089 2
			 opcode != NULL;
			 opcode = opcode->parent)
d1103 1
a1103 1
                     to check it */
d1106 1
a1106 1
	    
d1110 1
a1110 1
	
d1120 1
a1120 1
	    nr_checks ++;
d1123 1
a1123 1
		lf_printf (file, "if ((instruction_%d\n", word_nr); 
d1125 2
a1126 2
			   (unsigned long)(check_mask >> 32),
			   (unsigned long)(check_mask));
d1128 2
a1129 2
			   (unsigned long)(check_val >> 32),
			   (unsigned long)(check_val));
d1133 4
a1136 4
		lf_printf (file, "if ((instruction_%d & 0x%08lx) != 0x%08lx)\n",
			   word_nr,
			   (unsigned long)(check_mask),
			   (unsigned long)(check_val));
d1148 1
a1148 1
    lf_indent_suppress(file);
d1153 1
a1153 1
     
d1164 2
a1165 1
	lf_printf (file, "if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {\n");
d1193 1
a1193 1
	print_idecode_invalid (file, "return",  invalid_fp_unavailable);
d1200 1
a1200 1
  
d1213 2
a1214 1
	lf_printf (file, "/* Validate: Instruction issued in correct slot */\n");
d1224 1
a1224 1
  
d1243 1
a1243 2
					"INLINE_IDECODE",
					" ");
d1247 1
a1247 2
					"INLINE_IDECODE",
					"\n");
d1258 1
a1258 2
				NULL,
				function_name_prefix_idecode);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*  This file is part of the program psim.
d3 20
a22 1
    Copyright (C) 1994-1998, Andrew Cagney <cagney@@highland.com.au>
a23 15
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
    */
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.1.30.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1 1
a1 1
/* The IGEN simulator generator for GDB, the GNU Debugger.
d3 1
a3 20
   Copyright 2002 Free Software Foundation, Inc.

   Contributed by Andrew Cagney.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d5 15
d39 2
a40 1
lf_print_opcodes (lf *file, gen_entry *table)
d42 1
a42 1
  if (table !=NULL)
d48 3
a50 3
		     table->opcode->first, table->opcode->last);
	  if (table->parent == NULL)
	    break;
d67 2
a68 1
       word_nr < current_nr_prefetched_words; word_nr++)
d70 1
a70 2
      lf_printf (file,
		 "instruction_word instruction_%d = IMEM%d_IMMED (cia, %d);\n",
d72 1
a72 1

d82 2
a83 1
lf_print_table_name (lf *file, gen_entry *table)
d92 3
a94 1
print_idecode_table (lf *file, gen_entry *entry, const char *result)
d105 1
a105 1

d128 1
a128 1

d140 1
a140 2
	  lf_printf (file,
		     "(((idecode_icache*)table_entry->function_or_table)\n");
d147 1
a147 2
	  lf_printf (file,
		     "((idecode_semantic*)table_entry->function_or_table)\n");
d157 4
a160 1
print_idecode_table_start (lf *file, gen_entry *table, int depth, void *data)
d174 4
a177 1
print_idecode_table_leaf (lf *file, gen_entry *entry, int depth, void *data)
d237 3
a239 3
	  lf_printf (file, "%d, ",
		     options.insn_bit_size - entry->opcode->last - 1);
	  lf_printf (file, "MASK%d(%d,%d), ", options.insn_bit_size,
d250 4
a253 1
print_idecode_table_end (lf *file, gen_entry *table, int depth, void *data)
d256 3
a258 4
  if (table->opcode_rule->gen == array_gen)
    {
      lf_printf (file, "};\n");
    }
d265 2
a266 1
print_goto_switch_name (lf *file, gen_entry *entry)
d282 1
a282 1
      lf_print_table_name (file, entry);
d288 3
a290 1
			      gen_entry *entry, int depth, void *data)
d296 1
a296 1

d306 2
a307 1
print_goto_switch_break (lf *file, gen_entry *entry)
d316 2
a317 1
print_goto_switch_table (lf *file, gen_entry *table)
d323 6
a328 3
  gen_entry_traverse_tree (file, table, 0, NULL /*start */ ,
			   print_goto_switch_table_leaf, NULL /*end */ ,
			   NULL /*data */ );
d334 4
a337 1
void print_idecode_switch (lf *file, gen_entry *table, const char *result);
d340 4
a343 1
print_idecode_switch_start (lf *file, gen_entry *table, int depth, void *data)
d350 1
a350 1

d392 1
a392 1
      ASSERT ("bad switch" == NULL);
d398 4
a401 1
print_idecode_switch_leaf (lf *file, gen_entry *entry, int depth, void *data)
d410 1
a410 1

d415 2
a416 1
  if (entry->parent->opcode->is_boolean && entry->opcode_nr == 0)
d421 2
a422 1
  else if (entry->parent->opcode->is_boolean && entry->opcode_nr != 0)
d474 1
a474 3
	    print_semantic_function_actual (file,
					    entry->insns->semantic->
					    nr_prefetched_words);
d511 1
a511 1
	print_goto_switch_break (file, entry);
d524 2
a525 1
print_idecode_switch_illegal (lf *file, const char *result)
d534 4
a537 1
print_idecode_switch_end (lf *file, gen_entry *table, int depth, void *data)
d545 1
a545 1

d558 1
a558 2
	  print_sim_engine_abort (file,
				  "Internal error - bad switch generated");
d577 1
a577 1
      lf_print_table_name (file, table);
d596 3
a598 1
print_idecode_switch (lf *file, gen_entry *table, const char *result)
d604 2
a605 1
			   print_idecode_switch_end, (void *) result);
d656 9
a664 3
idecode_declare_if_switch (lf *file, gen_entry *table, int depth, void *data)
{
  if ((table->opcode_rule->gen == switch_gen || table->opcode_rule->gen == goto_switch_gen || table->opcode_rule->gen == padded_switch_gen) &&table->parent != NULL	/* don't declare the top one yet */
d669 1
a669 1
					    0 /*isnt function definition */ ,
d676 9
a684 3
idecode_expand_if_switch (lf *file, gen_entry *table, int depth, void *data)
{
  if ((table->opcode_rule->gen == switch_gen || table->opcode_rule->gen == goto_switch_gen || table->opcode_rule->gen == padded_switch_gen) &&table->parent != NULL	/* don't expand the top one yet */
d687 4
a690 4
      print_idecode_switch_function_header (file,
					    table,
					    1 /*is function definition */ ,
					    0);
d696 1
a696 1
      print_idecode_switch (file, table, "return");
d710 3
a712 1
print_idecode_lookups (lf *file, gen_entry *table, cache_entry *cache_rules)
d715 1
a715 1

d717 6
a722 3
  gen_entry_traverse_tree (file, table, 1, idecode_declare_if_switch,	/* START */
			   NULL, NULL, NULL);

d724 3
a726 1
  for (depth = gen_entry_depth (table); depth > 0; depth--)
d729 1
a729 1
			       1 - depth,
d732 2
a733 1
			       print_idecode_table_end, NULL);
d735 1
a735 1

d737 5
a741 2
  gen_entry_traverse_tree (file, table, 1, idecode_expand_if_switch,	/* START */
			   NULL, NULL, NULL);
d746 3
a748 1
print_idecode_body (lf *file, gen_entry *table, const char *result)
d767 2
a768 1
print_jump (lf *file, int is_tail)
d775 1
a775 1

d786 1
a786 1

d808 1
a808 1

d826 1
a826 1

d835 4
a838 3
		 insn_entry * instruction,
		 insn_bits * expanded_bits,
		 opcode_field *opcodes, cache_entry *cache_rules)
d840 1
a840 1

d844 1
a844 1

d852 2
a853 1
			   expanded_bits, function_name_prefix_icache);
d859 1
a859 1
      print_itrace (file, instruction, 1 /*putting-value-in-cache */ );
d864 5
a868 1
      print_icache_body (file, instruction, expanded_bits, cache_rules, 0,	/*use_defines */
d874 2
a875 1
			   expanded_bits, function_name_prefix_semantics);
d879 5
a883 2
	  print_semantic_body (file, instruction, expanded_bits, opcodes);
	  print_jump (file, 1 /*is-tail */ );
d890 2
a891 1
			       expanded_bits, function_name_prefix_semantics);
d899 1
a899 1

d905 2
a906 1
		       expanded_bits, function_name_prefix_semantics);
d920 6
a925 2
		      ? get_values_from_icache : do_not_use_icache));
  print_semantic_body (file, instruction, expanded_bits, opcodes);
d933 3
a935 2
			? get_values_from_icache : do_not_use_icache));
  print_jump (file, 1 /*is tail */ );
d946 3
a948 1
		       insn_entry * insn, int depth, void *data)
d950 1
a950 1
  cache_entry *cache_rules = (cache_entry *) data;
d955 2
a956 1
	      && entry->parent != NULL && entry->parent->opcode != NULL);
d964 3
a966 1
		       entry->expanded_bits, entry->opcode, cache_rules);
d971 4
a974 1
		       instruction->words[0]->insn, NULL, NULL, cache_rules);
d983 2
a984 1
			      function_entry * function, void *data)
d1015 3
a1017 2
print_jump_until_stop_body (lf *file,
			    insn_table *table, cache_table * cache_rules)
d1026 6
a1031 8
  if ((code & generate_with_icache))
    {
      lf_putstr (file, "idecode_cache *cache_entry = NULL;\n");
    }
  if (generate_smp)
    {
      lf_putstr (file, "int current_cpu = -1;\n");
    }
d1034 2
a1035 2
  print_idecode_lookups (file, table, cache_rules);

d1037 8
a1044 9
  if ((code & generate_with_icache))
    {
      lf_putstr (file, "\n");
      lf_putstr (file, "{\n");
      lf_putstr (file, "  int cpu_nr;\n");
      lf_putstr (file, "  for (cpu_nr = 0; cpu_nr < nr_cpus; cpu_nr++)\n");
      lf_putstr (file, "    cpu_flush_icache(cpus[cpu_nr]);\n");
      lf_putstr (file, "}\n");
    }
d1057 7
a1063 9
  if (!generate_smp)
    {
      lf_putstr (file, "cpu = cpus[0];\n");
      lf_putstr (file, "nia = cpu_get_program_counter(cpu);\n");
    }
  else
    {
      lf_putstr (file, "current_cpu = psim_last_cpu(system);\n");
    }
d1065 6
a1070 7
  if (!(code & generate_with_icache))
    {
      lf_printf (file, "\n");
      lf_indent (file, -1);
      lf_printf (file, "idecode:\n");
      lf_indent (file, +1);
    }
d1072 1
a1072 1
  print_jump (file, 0 /*is_tail */ );
d1074 5
a1078 6
  if ((code & generate_with_icache))
    {
      lf_indent (file, -1);
      lf_printf (file, "cache_miss:\n");
      lf_indent (file, +1);
    }
d1083 1
a1083 1
  print_idecode_body (file, table, "/*IGORE*/");
d1086 3
a1088 2
  insn_table_traverse_function (table,
				file, NULL, print_jump_internal_function);
d1090 1
a1090 1
  /* print out a table of all the instructions */
d1092 7
a1098 4
    insn_table_traverse_tree (table, file, cache_rules, 1, NULL,	/* start */
			      print_jump_definition,	/* leaf */
			      NULL,	/* end */
			      NULL);	/* padding */
d1100 3
a1102 2
    insn_table_traverse_insn (table,
			      file, cache_rules, print_jump_definition);
d1119 2
a1120 1
			insn_entry * instruction, insn_opcodes *opcode_paths)
d1153 1
a1153 1

d1155 1
a1155 1
	       bits. Skip any others */
d1161 2
a1162 2
	       instruction.  See if any have failed to check the
	       relevant bit */
d1166 3
a1168 1
		for (entry = opcode_paths; entry != NULL; entry = entry->next)
d1172 2
a1173 1
			 opcode != NULL; opcode = opcode->parent)
d1187 1
a1187 1
		     to check it */
d1190 1
a1190 1

d1194 1
a1194 1

d1204 1
a1204 1
	    nr_checks++;
d1207 1
a1207 1
		lf_printf (file, "if ((instruction_%d\n", word_nr);
d1209 2
a1210 2
			   (unsigned long) (check_mask >> 32),
			   (unsigned long) (check_mask));
d1212 2
a1213 2
			   (unsigned long) (check_val >> 32),
			   (unsigned long) (check_val));
d1217 4
a1220 4
		lf_printf (file,
			   "if ((instruction_%d & 0x%08lx) != 0x%08lx)\n",
			   word_nr, (unsigned long) (check_mask),
			   (unsigned long) (check_val));
d1232 1
a1232 1
    lf_indent_suppress (file);
d1237 1
a1237 1

d1248 1
a1248 2
	lf_printf (file,
		   "if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {\n");
d1276 1
a1276 1
	print_idecode_invalid (file, "return", invalid_fp_unavailable);
d1283 1
a1283 1

d1296 1
a1296 2
	lf_printf (file,
		   "/* Validate: Instruction issued in correct slot */\n");
d1306 1
a1306 1

d1325 2
a1326 1
					"INLINE_IDECODE", " ");
d1330 2
a1331 1
					"INLINE_IDECODE", "\n");
d1342 2
a1343 1
				NULL, function_name_prefix_idecode);
@


1.1.1.1.28.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d1 1
a1 1
/* The IGEN simulator generator for GDB, the GNU Debugger.
d3 1
a3 20
   Copyright 2002 Free Software Foundation, Inc.

   Contributed by Andrew Cagney.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d5 15
d39 2
a40 1
lf_print_opcodes (lf *file, gen_entry *table)
d42 1
a42 1
  if (table !=NULL)
d48 3
a50 3
		     table->opcode->first, table->opcode->last);
	  if (table->parent == NULL)
	    break;
d67 2
a68 1
       word_nr < current_nr_prefetched_words; word_nr++)
d70 1
a70 2
      lf_printf (file,
		 "instruction_word instruction_%d = IMEM%d_IMMED (cia, %d);\n",
d72 1
a72 1

d82 2
a83 1
lf_print_table_name (lf *file, gen_entry *table)
d92 3
a94 1
print_idecode_table (lf *file, gen_entry *entry, const char *result)
d105 1
a105 1

d128 1
a128 1

d140 1
a140 2
	  lf_printf (file,
		     "(((idecode_icache*)table_entry->function_or_table)\n");
d147 1
a147 2
	  lf_printf (file,
		     "((idecode_semantic*)table_entry->function_or_table)\n");
d157 4
a160 1
print_idecode_table_start (lf *file, gen_entry *table, int depth, void *data)
d174 4
a177 1
print_idecode_table_leaf (lf *file, gen_entry *entry, int depth, void *data)
d237 3
a239 3
	  lf_printf (file, "%d, ",
		     options.insn_bit_size - entry->opcode->last - 1);
	  lf_printf (file, "MASK%d(%d,%d), ", options.insn_bit_size,
d250 4
a253 1
print_idecode_table_end (lf *file, gen_entry *table, int depth, void *data)
d256 3
a258 4
  if (table->opcode_rule->gen == array_gen)
    {
      lf_printf (file, "};\n");
    }
d265 2
a266 1
print_goto_switch_name (lf *file, gen_entry *entry)
d282 1
a282 1
      lf_print_table_name (file, entry);
d288 3
a290 1
			      gen_entry *entry, int depth, void *data)
d296 1
a296 1

d306 2
a307 1
print_goto_switch_break (lf *file, gen_entry *entry)
d316 2
a317 1
print_goto_switch_table (lf *file, gen_entry *table)
d323 6
a328 3
  gen_entry_traverse_tree (file, table, 0, NULL /*start */ ,
			   print_goto_switch_table_leaf, NULL /*end */ ,
			   NULL /*data */ );
d334 4
a337 1
void print_idecode_switch (lf *file, gen_entry *table, const char *result);
d340 4
a343 1
print_idecode_switch_start (lf *file, gen_entry *table, int depth, void *data)
d350 1
a350 1

d392 1
a392 1
      ASSERT ("bad switch" == NULL);
d398 4
a401 1
print_idecode_switch_leaf (lf *file, gen_entry *entry, int depth, void *data)
d410 1
a410 1

d415 2
a416 1
  if (entry->parent->opcode->is_boolean && entry->opcode_nr == 0)
d421 2
a422 1
  else if (entry->parent->opcode->is_boolean && entry->opcode_nr != 0)
d474 1
a474 3
	    print_semantic_function_actual (file,
					    entry->insns->semantic->
					    nr_prefetched_words);
d511 1
a511 1
	print_goto_switch_break (file, entry);
d524 2
a525 1
print_idecode_switch_illegal (lf *file, const char *result)
d534 4
a537 1
print_idecode_switch_end (lf *file, gen_entry *table, int depth, void *data)
d545 1
a545 1

d558 1
a558 2
	  print_sim_engine_abort (file,
				  "Internal error - bad switch generated");
d577 1
a577 1
      lf_print_table_name (file, table);
d596 3
a598 1
print_idecode_switch (lf *file, gen_entry *table, const char *result)
d604 2
a605 1
			   print_idecode_switch_end, (void *) result);
d656 9
a664 3
idecode_declare_if_switch (lf *file, gen_entry *table, int depth, void *data)
{
  if ((table->opcode_rule->gen == switch_gen || table->opcode_rule->gen == goto_switch_gen || table->opcode_rule->gen == padded_switch_gen) &&table->parent != NULL	/* don't declare the top one yet */
d669 1
a669 1
					    0 /*isnt function definition */ ,
d676 9
a684 3
idecode_expand_if_switch (lf *file, gen_entry *table, int depth, void *data)
{
  if ((table->opcode_rule->gen == switch_gen || table->opcode_rule->gen == goto_switch_gen || table->opcode_rule->gen == padded_switch_gen) &&table->parent != NULL	/* don't expand the top one yet */
d687 4
a690 4
      print_idecode_switch_function_header (file,
					    table,
					    1 /*is function definition */ ,
					    0);
d696 1
a696 1
      print_idecode_switch (file, table, "return");
d710 3
a712 1
print_idecode_lookups (lf *file, gen_entry *table, cache_entry *cache_rules)
d715 1
a715 1

d717 6
a722 3
  gen_entry_traverse_tree (file, table, 1, idecode_declare_if_switch,	/* START */
			   NULL, NULL, NULL);

d724 3
a726 1
  for (depth = gen_entry_depth (table); depth > 0; depth--)
d729 1
a729 1
			       1 - depth,
d732 2
a733 1
			       print_idecode_table_end, NULL);
d735 1
a735 1

d737 5
a741 2
  gen_entry_traverse_tree (file, table, 1, idecode_expand_if_switch,	/* START */
			   NULL, NULL, NULL);
d746 3
a748 1
print_idecode_body (lf *file, gen_entry *table, const char *result)
d767 2
a768 1
print_jump (lf *file, int is_tail)
d775 1
a775 1

d786 1
a786 1

d808 1
a808 1

d826 1
a826 1

d835 4
a838 3
		 insn_entry * instruction,
		 insn_bits * expanded_bits,
		 opcode_field *opcodes, cache_entry *cache_rules)
d840 1
a840 1

d844 1
a844 1

d852 2
a853 1
			   expanded_bits, function_name_prefix_icache);
d859 1
a859 1
      print_itrace (file, instruction, 1 /*putting-value-in-cache */ );
d864 5
a868 1
      print_icache_body (file, instruction, expanded_bits, cache_rules, 0,	/*use_defines */
d874 2
a875 1
			   expanded_bits, function_name_prefix_semantics);
d879 5
a883 2
	  print_semantic_body (file, instruction, expanded_bits, opcodes);
	  print_jump (file, 1 /*is-tail */ );
d890 2
a891 1
			       expanded_bits, function_name_prefix_semantics);
d899 1
a899 1

d905 2
a906 1
		       expanded_bits, function_name_prefix_semantics);
d920 6
a925 2
		      ? get_values_from_icache : do_not_use_icache));
  print_semantic_body (file, instruction, expanded_bits, opcodes);
d933 3
a935 2
			? get_values_from_icache : do_not_use_icache));
  print_jump (file, 1 /*is tail */ );
d946 3
a948 1
		       insn_entry * insn, int depth, void *data)
d950 1
a950 1
  cache_entry *cache_rules = (cache_entry *) data;
d955 2
a956 1
	      && entry->parent != NULL && entry->parent->opcode != NULL);
d964 3
a966 1
		       entry->expanded_bits, entry->opcode, cache_rules);
d971 4
a974 1
		       instruction->words[0]->insn, NULL, NULL, cache_rules);
d983 2
a984 1
			      function_entry * function, void *data)
d1015 3
a1017 2
print_jump_until_stop_body (lf *file,
			    insn_table *table, cache_table * cache_rules)
d1026 6
a1031 8
  if ((code & generate_with_icache))
    {
      lf_putstr (file, "idecode_cache *cache_entry = NULL;\n");
    }
  if (generate_smp)
    {
      lf_putstr (file, "int current_cpu = -1;\n");
    }
d1034 2
a1035 2
  print_idecode_lookups (file, table, cache_rules);

d1037 8
a1044 9
  if ((code & generate_with_icache))
    {
      lf_putstr (file, "\n");
      lf_putstr (file, "{\n");
      lf_putstr (file, "  int cpu_nr;\n");
      lf_putstr (file, "  for (cpu_nr = 0; cpu_nr < nr_cpus; cpu_nr++)\n");
      lf_putstr (file, "    cpu_flush_icache(cpus[cpu_nr]);\n");
      lf_putstr (file, "}\n");
    }
d1057 7
a1063 9
  if (!generate_smp)
    {
      lf_putstr (file, "cpu = cpus[0];\n");
      lf_putstr (file, "nia = cpu_get_program_counter(cpu);\n");
    }
  else
    {
      lf_putstr (file, "current_cpu = psim_last_cpu(system);\n");
    }
d1065 6
a1070 7
  if (!(code & generate_with_icache))
    {
      lf_printf (file, "\n");
      lf_indent (file, -1);
      lf_printf (file, "idecode:\n");
      lf_indent (file, +1);
    }
d1072 1
a1072 1
  print_jump (file, 0 /*is_tail */ );
d1074 5
a1078 6
  if ((code & generate_with_icache))
    {
      lf_indent (file, -1);
      lf_printf (file, "cache_miss:\n");
      lf_indent (file, +1);
    }
d1083 1
a1083 1
  print_idecode_body (file, table, "/*IGORE*/");
d1086 3
a1088 2
  insn_table_traverse_function (table,
				file, NULL, print_jump_internal_function);
d1090 1
a1090 1
  /* print out a table of all the instructions */
d1092 7
a1098 4
    insn_table_traverse_tree (table, file, cache_rules, 1, NULL,	/* start */
			      print_jump_definition,	/* leaf */
			      NULL,	/* end */
			      NULL);	/* padding */
d1100 3
a1102 2
    insn_table_traverse_insn (table,
			      file, cache_rules, print_jump_definition);
d1119 2
a1120 1
			insn_entry * instruction, insn_opcodes *opcode_paths)
d1153 1
a1153 1

d1155 1
a1155 1
	       bits. Skip any others */
d1161 2
a1162 2
	       instruction.  See if any have failed to check the
	       relevant bit */
d1166 3
a1168 1
		for (entry = opcode_paths; entry != NULL; entry = entry->next)
d1172 2
a1173 1
			 opcode != NULL; opcode = opcode->parent)
d1187 1
a1187 1
		     to check it */
d1190 1
a1190 1

d1194 1
a1194 1

d1204 1
a1204 1
	    nr_checks++;
d1207 1
a1207 1
		lf_printf (file, "if ((instruction_%d\n", word_nr);
d1209 2
a1210 2
			   (unsigned long) (check_mask >> 32),
			   (unsigned long) (check_mask));
d1212 2
a1213 2
			   (unsigned long) (check_val >> 32),
			   (unsigned long) (check_val));
d1217 4
a1220 4
		lf_printf (file,
			   "if ((instruction_%d & 0x%08lx) != 0x%08lx)\n",
			   word_nr, (unsigned long) (check_mask),
			   (unsigned long) (check_val));
d1232 1
a1232 1
    lf_indent_suppress (file);
d1237 1
a1237 1

d1248 1
a1248 2
	lf_printf (file,
		   "if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {\n");
d1276 1
a1276 1
	print_idecode_invalid (file, "return", invalid_fp_unavailable);
d1283 1
a1283 1

d1296 1
a1296 2
	lf_printf (file,
		   "/* Validate: Instruction issued in correct slot */\n");
d1306 1
a1306 1

d1325 2
a1326 1
					"INLINE_IDECODE", " ");
d1330 2
a1331 1
					"INLINE_IDECODE", "\n");
d1342 2
a1343 1
				NULL, function_name_prefix_idecode);
@


1.1.1.1.26.1
log
@Import all the copyright and indent changes from the mainline (also
richards's tweak).
@
text
@d1 1
a1 1
/* The IGEN simulator generator for GDB, the GNU Debugger.
d3 1
a3 20
   Copyright 2002 Free Software Foundation, Inc.

   Contributed by Andrew Cagney.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d5 15
d39 2
a40 1
lf_print_opcodes (lf *file, gen_entry *table)
d42 1
a42 1
  if (table !=NULL)
d48 3
a50 3
		     table->opcode->first, table->opcode->last);
	  if (table->parent == NULL)
	    break;
d67 2
a68 1
       word_nr < current_nr_prefetched_words; word_nr++)
d70 1
a70 2
      lf_printf (file,
		 "instruction_word instruction_%d = IMEM%d_IMMED (cia, %d);\n",
d72 1
a72 1

d82 2
a83 1
lf_print_table_name (lf *file, gen_entry *table)
d92 3
a94 1
print_idecode_table (lf *file, gen_entry *entry, const char *result)
d105 1
a105 1

d128 1
a128 1

d140 1
a140 2
	  lf_printf (file,
		     "(((idecode_icache*)table_entry->function_or_table)\n");
d147 1
a147 2
	  lf_printf (file,
		     "((idecode_semantic*)table_entry->function_or_table)\n");
d157 4
a160 1
print_idecode_table_start (lf *file, gen_entry *table, int depth, void *data)
d174 4
a177 1
print_idecode_table_leaf (lf *file, gen_entry *entry, int depth, void *data)
d237 3
a239 3
	  lf_printf (file, "%d, ",
		     options.insn_bit_size - entry->opcode->last - 1);
	  lf_printf (file, "MASK%d(%d,%d), ", options.insn_bit_size,
d250 4
a253 1
print_idecode_table_end (lf *file, gen_entry *table, int depth, void *data)
d256 3
a258 4
  if (table->opcode_rule->gen == array_gen)
    {
      lf_printf (file, "};\n");
    }
d265 2
a266 1
print_goto_switch_name (lf *file, gen_entry *entry)
d282 1
a282 1
      lf_print_table_name (file, entry);
d288 3
a290 1
			      gen_entry *entry, int depth, void *data)
d296 1
a296 1

d306 2
a307 1
print_goto_switch_break (lf *file, gen_entry *entry)
d316 2
a317 1
print_goto_switch_table (lf *file, gen_entry *table)
d323 6
a328 3
  gen_entry_traverse_tree (file, table, 0, NULL /*start */ ,
			   print_goto_switch_table_leaf, NULL /*end */ ,
			   NULL /*data */ );
d334 4
a337 1
void print_idecode_switch (lf *file, gen_entry *table, const char *result);
d340 4
a343 1
print_idecode_switch_start (lf *file, gen_entry *table, int depth, void *data)
d350 1
a350 1

d392 1
a392 1
      ASSERT ("bad switch" == NULL);
d398 4
a401 1
print_idecode_switch_leaf (lf *file, gen_entry *entry, int depth, void *data)
d410 1
a410 1

d415 2
a416 1
  if (entry->parent->opcode->is_boolean && entry->opcode_nr == 0)
d421 2
a422 1
  else if (entry->parent->opcode->is_boolean && entry->opcode_nr != 0)
d474 1
a474 3
	    print_semantic_function_actual (file,
					    entry->insns->semantic->
					    nr_prefetched_words);
d511 1
a511 1
	print_goto_switch_break (file, entry);
d524 2
a525 1
print_idecode_switch_illegal (lf *file, const char *result)
d534 4
a537 1
print_idecode_switch_end (lf *file, gen_entry *table, int depth, void *data)
d545 1
a545 1

d558 1
a558 2
	  print_sim_engine_abort (file,
				  "Internal error - bad switch generated");
d577 1
a577 1
      lf_print_table_name (file, table);
d596 3
a598 1
print_idecode_switch (lf *file, gen_entry *table, const char *result)
d604 2
a605 1
			   print_idecode_switch_end, (void *) result);
d656 9
a664 3
idecode_declare_if_switch (lf *file, gen_entry *table, int depth, void *data)
{
  if ((table->opcode_rule->gen == switch_gen || table->opcode_rule->gen == goto_switch_gen || table->opcode_rule->gen == padded_switch_gen) &&table->parent != NULL	/* don't declare the top one yet */
d669 1
a669 1
					    0 /*isnt function definition */ ,
d676 9
a684 3
idecode_expand_if_switch (lf *file, gen_entry *table, int depth, void *data)
{
  if ((table->opcode_rule->gen == switch_gen || table->opcode_rule->gen == goto_switch_gen || table->opcode_rule->gen == padded_switch_gen) &&table->parent != NULL	/* don't expand the top one yet */
d687 4
a690 4
      print_idecode_switch_function_header (file,
					    table,
					    1 /*is function definition */ ,
					    0);
d696 1
a696 1
      print_idecode_switch (file, table, "return");
d710 3
a712 1
print_idecode_lookups (lf *file, gen_entry *table, cache_entry *cache_rules)
d715 1
a715 1

d717 6
a722 3
  gen_entry_traverse_tree (file, table, 1, idecode_declare_if_switch,	/* START */
			   NULL, NULL, NULL);

d724 3
a726 1
  for (depth = gen_entry_depth (table); depth > 0; depth--)
d729 1
a729 1
			       1 - depth,
d732 2
a733 1
			       print_idecode_table_end, NULL);
d735 1
a735 1

d737 5
a741 2
  gen_entry_traverse_tree (file, table, 1, idecode_expand_if_switch,	/* START */
			   NULL, NULL, NULL);
d746 3
a748 1
print_idecode_body (lf *file, gen_entry *table, const char *result)
d767 2
a768 1
print_jump (lf *file, int is_tail)
d775 1
a775 1

d786 1
a786 1

d808 1
a808 1

d826 1
a826 1

d835 4
a838 3
		 insn_entry * instruction,
		 insn_bits * expanded_bits,
		 opcode_field *opcodes, cache_entry *cache_rules)
d840 1
a840 1

d844 1
a844 1

d852 2
a853 1
			   expanded_bits, function_name_prefix_icache);
d859 1
a859 1
      print_itrace (file, instruction, 1 /*putting-value-in-cache */ );
d864 5
a868 1
      print_icache_body (file, instruction, expanded_bits, cache_rules, 0,	/*use_defines */
d874 2
a875 1
			   expanded_bits, function_name_prefix_semantics);
d879 5
a883 2
	  print_semantic_body (file, instruction, expanded_bits, opcodes);
	  print_jump (file, 1 /*is-tail */ );
d890 2
a891 1
			       expanded_bits, function_name_prefix_semantics);
d899 1
a899 1

d905 2
a906 1
		       expanded_bits, function_name_prefix_semantics);
d920 6
a925 2
		      ? get_values_from_icache : do_not_use_icache));
  print_semantic_body (file, instruction, expanded_bits, opcodes);
d933 3
a935 2
			? get_values_from_icache : do_not_use_icache));
  print_jump (file, 1 /*is tail */ );
d946 3
a948 1
		       insn_entry * insn, int depth, void *data)
d950 1
a950 1
  cache_entry *cache_rules = (cache_entry *) data;
d955 2
a956 1
	      && entry->parent != NULL && entry->parent->opcode != NULL);
d964 3
a966 1
		       entry->expanded_bits, entry->opcode, cache_rules);
d971 4
a974 1
		       instruction->words[0]->insn, NULL, NULL, cache_rules);
d983 2
a984 1
			      function_entry * function, void *data)
d1015 3
a1017 2
print_jump_until_stop_body (lf *file,
			    insn_table *table, cache_table * cache_rules)
d1026 6
a1031 8
  if ((code & generate_with_icache))
    {
      lf_putstr (file, "idecode_cache *cache_entry = NULL;\n");
    }
  if (generate_smp)
    {
      lf_putstr (file, "int current_cpu = -1;\n");
    }
d1034 2
a1035 2
  print_idecode_lookups (file, table, cache_rules);

d1037 8
a1044 9
  if ((code & generate_with_icache))
    {
      lf_putstr (file, "\n");
      lf_putstr (file, "{\n");
      lf_putstr (file, "  int cpu_nr;\n");
      lf_putstr (file, "  for (cpu_nr = 0; cpu_nr < nr_cpus; cpu_nr++)\n");
      lf_putstr (file, "    cpu_flush_icache(cpus[cpu_nr]);\n");
      lf_putstr (file, "}\n");
    }
d1057 7
a1063 9
  if (!generate_smp)
    {
      lf_putstr (file, "cpu = cpus[0];\n");
      lf_putstr (file, "nia = cpu_get_program_counter(cpu);\n");
    }
  else
    {
      lf_putstr (file, "current_cpu = psim_last_cpu(system);\n");
    }
d1065 6
a1070 7
  if (!(code & generate_with_icache))
    {
      lf_printf (file, "\n");
      lf_indent (file, -1);
      lf_printf (file, "idecode:\n");
      lf_indent (file, +1);
    }
d1072 1
a1072 1
  print_jump (file, 0 /*is_tail */ );
d1074 5
a1078 6
  if ((code & generate_with_icache))
    {
      lf_indent (file, -1);
      lf_printf (file, "cache_miss:\n");
      lf_indent (file, +1);
    }
d1083 1
a1083 1
  print_idecode_body (file, table, "/*IGORE*/");
d1086 3
a1088 2
  insn_table_traverse_function (table,
				file, NULL, print_jump_internal_function);
d1090 1
a1090 1
  /* print out a table of all the instructions */
d1092 7
a1098 4
    insn_table_traverse_tree (table, file, cache_rules, 1, NULL,	/* start */
			      print_jump_definition,	/* leaf */
			      NULL,	/* end */
			      NULL);	/* padding */
d1100 3
a1102 2
    insn_table_traverse_insn (table,
			      file, cache_rules, print_jump_definition);
d1119 2
a1120 1
			insn_entry * instruction, insn_opcodes *opcode_paths)
d1153 1
a1153 1

d1155 1
a1155 1
	       bits. Skip any others */
d1161 2
a1162 2
	       instruction.  See if any have failed to check the
	       relevant bit */
d1166 3
a1168 1
		for (entry = opcode_paths; entry != NULL; entry = entry->next)
d1172 2
a1173 1
			 opcode != NULL; opcode = opcode->parent)
d1187 1
a1187 1
		     to check it */
d1190 1
a1190 1

d1194 1
a1194 1

d1204 1
a1204 1
	    nr_checks++;
d1207 1
a1207 1
		lf_printf (file, "if ((instruction_%d\n", word_nr);
d1209 2
a1210 2
			   (unsigned long) (check_mask >> 32),
			   (unsigned long) (check_mask));
d1212 2
a1213 2
			   (unsigned long) (check_val >> 32),
			   (unsigned long) (check_val));
d1217 4
a1220 4
		lf_printf (file,
			   "if ((instruction_%d & 0x%08lx) != 0x%08lx)\n",
			   word_nr, (unsigned long) (check_mask),
			   (unsigned long) (check_val));
d1232 1
a1232 1
    lf_indent_suppress (file);
d1237 1
a1237 1

d1248 1
a1248 2
	lf_printf (file,
		   "if (CURRENT_FLOATING_POINT != HARD_FLOATING_POINT) {\n");
d1276 1
a1276 1
	print_idecode_invalid (file, "return", invalid_fp_unavailable);
d1283 1
a1283 1

d1296 1
a1296 2
	lf_printf (file,
		   "/* Validate: Instruction issued in correct slot */\n");
d1306 1
a1306 1

d1325 2
a1326 1
					"INLINE_IDECODE", " ");
d1330 2
a1331 1
					"INLINE_IDECODE", "\n");
d1342 2
a1343 1
				NULL, function_name_prefix_idecode);
@


