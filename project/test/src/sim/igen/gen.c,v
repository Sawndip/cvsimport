head	1.16;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.16
	gdb_7_6-2013-04-26-release:1.16
	gdb_7_6-branch:1.16.0.2
	gdb_7_6-2013-03-12-branchpoint:1.16
	gdb_7_5_1-2012-11-29-release:1.15
	gdb_7_5-2012-08-17-release:1.15
	gdb_7_5-branch:1.15.0.2
	gdb_7_5-2012-07-18-branchpoint:1.15
	gdb_7_4_1-2012-04-26-release:1.14.2.1
	gdb_7_4-2012-01-24-release:1.14.2.1
	gdb_7_4-branch:1.14.0.2
	gdb_7_4-2011-12-13-branchpoint:1.14
	gdb_7_3_1-2011-09-04-release:1.12
	gdb_7_3-2011-07-26-release:1.12
	gdb_7_3-branch:1.12.0.2
	gdb_7_3-2011-04-01-branchpoint:1.12
	gdb_7_2-2010-09-02-release:1.11
	gdb_7_2-branch:1.11.0.4
	gdb_7_2-2010-07-07-branchpoint:1.11
	gdb_7_1-2010-03-18-release:1.11
	gdb_7_1-branch:1.11.0.2
	gdb_7_1-2010-02-18-branchpoint:1.11
	gdb_7_0_1-2009-12-22-release:1.10
	gdb_7_0-2009-10-06-release:1.10
	gdb_7_0-branch:1.10.0.4
	gdb_7_0-2009-09-16-branchpoint:1.10
	arc-sim-20090309:1.9
	msnyder-checkpoint-072509-branch:1.10.0.2
	msnyder-checkpoint-072509-branchpoint:1.10
	arc-insight_6_8-branch:1.9.0.16
	arc-insight_6_8-branchpoint:1.9
	insight_6_8-branch:1.9.0.14
	insight_6_8-branchpoint:1.9
	reverse-20081226-branch:1.9.0.12
	reverse-20081226-branchpoint:1.9
	multiprocess-20081120-branch:1.9.0.10
	multiprocess-20081120-branchpoint:1.9
	reverse-20080930-branch:1.9.0.8
	reverse-20080930-branchpoint:1.9
	reverse-20080717-branch:1.9.0.6
	reverse-20080717-branchpoint:1.9
	msnyder-reverse-20080609-branch:1.9.0.4
	msnyder-reverse-20080609-branchpoint:1.9
	drow-reverse-20070409-branch:1.7.0.2
	drow-reverse-20070409-branchpoint:1.7
	gdb_6_8-2008-03-27-release:1.9
	gdb_6_8-branch:1.9.0.2
	gdb_6_8-2008-02-26-branchpoint:1.9
	gdb_6_7_1-2007-10-29-release:1.8
	gdb_6_7-2007-10-10-release:1.8
	gdb_6_7-branch:1.8.0.2
	gdb_6_7-2007-09-07-branchpoint:1.8
	insight_6_6-20070208-release:1.6
	gdb_6_6-2006-12-18-release:1.6
	gdb_6_6-branch:1.6.0.88
	gdb_6_6-2006-11-15-branchpoint:1.6
	insight_6_5-20061003-release:1.6
	gdb-csl-symbian-6_4_50_20060226-12:1.6
	gdb-csl-sourcerygxx-3_4_4-25:1.6
	nickrob-async-20060828-mergepoint:1.6
	gdb-csl-symbian-6_4_50_20060226-11:1.6
	gdb-csl-sourcerygxx-4_1-17:1.6
	gdb-csl-20060226-branch-local-2:1.6
	gdb-csl-sourcerygxx-4_1-14:1.6
	gdb-csl-sourcerygxx-4_1-13:1.6
	gdb-csl-sourcerygxx-4_1-12:1.6
	gdb-csl-sourcerygxx-3_4_4-21:1.6
	gdb_6_5-20060621-release:1.6
	gdb-csl-sourcerygxx-4_1-9:1.6
	gdb-csl-sourcerygxx-4_1-8:1.6
	gdb-csl-sourcerygxx-4_1-7:1.6
	gdb-csl-arm-2006q1-6:1.6
	gdb-csl-sourcerygxx-4_1-6:1.6
	gdb-csl-symbian-6_4_50_20060226-10:1.6
	gdb-csl-symbian-6_4_50_20060226-9:1.6
	gdb-csl-symbian-6_4_50_20060226-8:1.6
	gdb-csl-coldfire-4_1-11:1.6
	gdb-csl-sourcerygxx-3_4_4-19:1.6
	gdb-csl-coldfire-4_1-10:1.6
	gdb_6_5-branch:1.6.0.86
	gdb_6_5-2006-05-14-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-5:1.6
	nickrob-async-20060513-branch:1.6.0.84
	nickrob-async-20060513-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-4:1.6
	msnyder-reverse-20060502-branch:1.6.0.82
	msnyder-reverse-20060502-branchpoint:1.6
	gdb-csl-morpho-4_1-4:1.6
	gdb-csl-sourcerygxx-3_4_4-17:1.6
	readline_5_1-import-branch:1.6.0.80
	readline_5_1-import-branchpoint:1.6
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.6
	gdb-csl-symbian-20060226-branch:1.6.0.78
	gdb-csl-symbian-20060226-branchpoint:1.6
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.6
	msnyder-reverse-20060331-branch:1.6.0.76
	msnyder-reverse-20060331-branchpoint:1.6
	gdb-csl-available-20060303-branch:1.6.0.74
	gdb-csl-available-20060303-branchpoint:1.6
	gdb-csl-20060226-branch:1.6.0.72
	gdb-csl-20060226-branchpoint:1.6
	gdb_6_4-20051202-release:1.6
	msnyder-fork-checkpoint-branch:1.6.0.70
	msnyder-fork-checkpoint-branchpoint:1.6
	gdb-csl-gxxpro-6_3-branch:1.6.0.68
	gdb-csl-gxxpro-6_3-branchpoint:1.6
	gdb_6_4-branch:1.6.0.66
	gdb_6_4-2005-11-01-branchpoint:1.6
	gdb-csl-arm-20051020-branch:1.6.0.64
	gdb-csl-arm-20051020-branchpoint:1.6
	msnyder-tracepoint-checkpoint-branch:1.6.0.62
	msnyder-tracepoint-checkpoint-branchpoint:1.6
	gdb-csl-arm-20050325-2005-q1b:1.6
	gdb-csl-arm-20050325-2005-q1a:1.6
	csl-arm-20050325-branch:1.6.0.60
	csl-arm-20050325-branchpoint:1.6
	gdb_6_3-20041109-release:1.6
	gdb_6_3-branch:1.6.0.56
	gdb_6_3-20041019-branchpoint:1.6
	drow_intercu-merge-20040921:1.6
	drow_intercu-merge-20040915:1.6
	jimb-gdb_6_2-e500-branch:1.6.0.58
	jimb-gdb_6_2-e500-branchpoint:1.6
	gdb_6_2-20040730-release:1.6
	gdb_6_2-branch:1.6.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.6
	gdb_6_1_1-20040616-release:1.6
	gdb_6_1-2004-04-05-release:1.6
	drow_intercu-merge-20040402:1.6
	drow_intercu-merge-20040327:1.6
	ezannoni_pie-20040323-branch:1.6.0.52
	ezannoni_pie-20040323-branchpoint:1.6
	cagney_tramp-20040321-mergepoint:1.6
	cagney_tramp-20040309-branch:1.6.0.50
	cagney_tramp-20040309-branchpoint:1.6
	gdb_6_1-branch:1.6.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	drow_intercu-20040221-branch:1.6.0.46
	drow_intercu-20040221-branchpoint:1.6
	cagney_bfdfile-20040213-branch:1.6.0.44
	cagney_bfdfile-20040213-branchpoint:1.6
	drow-cplus-merge-20040208:1.6
	carlton_dictionary-20040126-merge:1.6
	cagney_bigcore-20040122-branch:1.6.0.42
	cagney_bigcore-20040122-branchpoint:1.6
	drow-cplus-merge-20040113:1.6
	drow-cplus-merge-20031224:1.6
	drow-cplus-merge-20031220:1.6
	carlton_dictionary-20031215-merge:1.6
	drow-cplus-merge-20031214:1.6
	carlton-dictionary-20031111-merge:1.6
	gdb_6_0-2003-10-04-release:1.6
	kettenis_sparc-20030918-branch:1.6.0.40
	kettenis_sparc-20030918-branchpoint:1.6
	carlton_dictionary-20030917-merge:1.6
	ezannoni_pie-20030916-branchpoint:1.6
	ezannoni_pie-20030916-branch:1.6.0.38
	cagney_x86i386-20030821-branch:1.6.0.36
	cagney_x86i386-20030821-branchpoint:1.6
	carlton_dictionary-20030805-merge:1.6
	carlton_dictionary-20030627-merge:1.6
	gdb_6_0-branch:1.6.0.34
	gdb_6_0-2003-06-23-branchpoint:1.6
	jimb-ppc64-linux-20030613-branch:1.6.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.6
	cagney_convert-20030606-branch:1.6.0.30
	cagney_convert-20030606-branchpoint:1.6
	cagney_writestrings-20030508-branch:1.6.0.28
	cagney_writestrings-20030508-branchpoint:1.6
	jimb-ppc64-linux-20030528-branch:1.6.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.6
	carlton_dictionary-20030523-merge:1.6
	cagney_fileio-20030521-branch:1.6.0.24
	cagney_fileio-20030521-branchpoint:1.6
	kettenis_i386newframe-20030517-mergepoint:1.6
	jimb-ppc64-linux-20030509-branch:1.6.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.6
	kettenis_i386newframe-20030504-mergepoint:1.6
	carlton_dictionary-20030430-merge:1.6
	kettenis_i386newframe-20030419-branch:1.6.0.20
	kettenis_i386newframe-20030419-branchpoint:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	kettenis_i386newframe-20030406-branch:1.6.0.18
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.16
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.14
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.12
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.6
	offbyone-20030313-branch:1.6.0.10
	offbyone-20030313-branchpoint:1.6
	kettenis-i386newframe-20030308-branch:1.6.0.8
	kettenis-i386newframe-20030308-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.6
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.6
	interps-20030202-branch:1.6.0.4
	interps-20030202-branchpoint:1.6
	cagney-unwind-20030108-branch:1.6.0.2
	cagney-unwind-20030108-branchpoint:1.6
	carlton_dictionary-20021223-merge:1.6
	gdb_5_3-2002-12-12-release:1.3.6.1
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.10
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	carlton_dictionary-branch:1.3.0.8
	carlton_dictionary-20020920-branchpoint:1.3
	gdb_5_3-branch:1.3.0.6
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.4
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.2
	readline_4_3-import-branchpoint:1.3
	gdb_5_2_1-2002-07-23-release:1.1.1.1
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	jimb-macro-020506-branch:1.2.0.2
	jimb-macro-020506-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.1.1.1
	gdb_5_2-branch:1.1.1.1.0.14
	gdb_5_2-2002-03-03-branchpoint:1.1.1.1
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.12
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.10
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.8
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.16
date	2013.01.01.06.41.37;	author brobecke;	state Exp;
branches;
next	1.15;

1.15
date	2012.01.04.08.28.11;	author brobecke;	state Exp;
branches;
next	1.14;

1.14
date	2011.07.08.06.24.11;	author hp;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2011.07.08.02.27.18;	author hp;	state Exp;
branches;
next	1.12;

1.12
date	2011.01.01.15.34.00;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2010.01.01.10.03.30;	author brobecke;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.14.10.53.07;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2008.01.01.22.53.24;	author drow;	state Exp;
branches;
next	1.8;

1.8
date	2007.08.24.14.28.36;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.09.17.59.18;	author drow;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.22.23.20.46;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2002.11.22.04.20.49;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.22.04.09.40;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.17.21.44.06;	author cagney;	state Exp;
branches
	1.3.6.1
	1.3.8.1
	1.3.10.1;
next	1.2;

1.2
date	2002.03.24.00.43.28;	author cagney;	state Exp;
branches
	1.2.4.1
	1.2.6.1;
next	1.1;

1.1
date	99.04.16.01.35.04;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.14.2.1
date	2012.01.06.04.54.49;	author brobecke;	state Exp;
branches;
next	;

1.3.6.1
date	2002.11.22.04.26.42;	author cagney;	state Exp;
branches;
next	;

1.3.8.1
date	2002.12.23.19.39.54;	author carlton;	state Exp;
branches;
next	;

1.3.10.1
date	2003.12.14.20.28.24;	author drow;	state Exp;
branches;
next	;

1.2.4.1
date	2002.06.21.15.48.51;	author cagney;	state Exp;
branches;
next	;

1.2.6.1
date	2002.06.20.01.39.55;	author kseitz;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.35.04;	author shebs;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* The IGEN simulator generator for GDB, the GNU Debugger.

   Copyright 2002-2013 Free Software Foundation, Inc.

   Contributed by Andrew Cagney.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */


#include "misc.h"
#include "lf.h"
#include "table.h"
#include "filter.h"

#include "igen.h"
#include "ld-insn.h"
#include "ld-decode.h"
#include "gen.h"

static insn_uint
sub_val (insn_uint val, int val_last_pos, int first_pos, int last_pos)
{
  return ((val >> (val_last_pos - last_pos))
	  & (((insn_uint) 1 << (last_pos - first_pos + 1)) - 1));
}

static void
update_depth (lf *file, gen_entry *entry, int depth, void *data)
{
  int *max_depth = (int *) data;
  if (*max_depth < depth)
    *max_depth = depth;
}


int
gen_entry_depth (gen_entry *table)
{
  int depth = 0;
  gen_entry_traverse_tree (NULL, table, 1, NULL,	/*start */
			   update_depth, NULL,	/*end */
			   &depth);	/* data */
  return depth;
}


static void
print_gen_entry_path (line_ref *line, gen_entry *table, error_func *print)
{
  if (table->parent == NULL)
    {
      if (table->top->model != NULL)
	print (line, "%s", table->top->model->name);
      else
	print (line, "");
    }
  else
    {
      print_gen_entry_path (line, table->parent, print);
      print (NULL, ".%d", table->opcode_nr);
    }
}

static void
print_gen_entry_insns (gen_entry *table,
		       error_func *print,
		       char *first_message, char *next_message)
{
  insn_list *i;
  char *message;
  message = first_message;
  for (i = table->insns; i != NULL; i = i->next)
    {
      insn_entry *insn = i->insn;
      print_gen_entry_path (insn->line, table, print);
      print (NULL, ": %s.%s %s\n", insn->format_name, insn->name, message);
      if (next_message != NULL)
	message = next_message;
    }
}

/* same as strcmp */
static int
insn_field_cmp (insn_word_entry *l, insn_word_entry *r)
{
  while (1)
    {
      int bit_nr;
      if (l == NULL && r == NULL)
	return 0;		/* all previous fields the same */
      if (l == NULL)
	return -1;		/* left shorter than right */
      if (r == NULL)
	return +1;		/* left longer than right */
      for (bit_nr = 0; bit_nr < options.insn_bit_size; bit_nr++)
	{
	  if (l->bit[bit_nr]->field->type != insn_field_string)
	    continue;
	  if (r->bit[bit_nr]->field->type != insn_field_string)
	    continue;
	  if (l->bit[bit_nr]->field->conditions == NULL)
	    continue;
	  if (r->bit[bit_nr]->field->conditions == NULL)
	    continue;
	  if (0)
	    printf ("%s%s%s VS %s%s%s\n",
		    l->bit[bit_nr]->field->val_string,
		    l->bit[bit_nr]->field->conditions->test ==
		    insn_field_cond_eq ? "=" : "!",
		    l->bit[bit_nr]->field->conditions->string,
		    r->bit[bit_nr]->field->val_string,
		    r->bit[bit_nr]->field->conditions->test ==
		    insn_field_cond_eq ? "=" : "!",
		    r->bit[bit_nr]->field->conditions->string);
	  if (l->bit[bit_nr]->field->conditions->test == insn_field_cond_eq
	      && r->bit[bit_nr]->field->conditions->test ==
	      insn_field_cond_eq)
	    {
	      if (l->bit[bit_nr]->field->conditions->type ==
		  insn_field_cond_field
		  && r->bit[bit_nr]->field->conditions->type ==
		  insn_field_cond_field)
		/* somewhat arbitrary */
		{
		  int cmp = strcmp (l->bit[bit_nr]->field->conditions->string,
				    r->bit[bit_nr]->field->conditions->
				    string);
		  if (cmp != 0)
		    return cmp;
		  else
		    continue;
		}
	      if (l->bit[bit_nr]->field->conditions->type ==
		  insn_field_cond_field)
		return +1;
	      if (r->bit[bit_nr]->field->conditions->type ==
		  insn_field_cond_field)
		return -1;
	      /* The case of both fields having constant values should have
	         already have been handled because such fields are converted
	         into normal constant fields, but we must not make this
		 an assert, as we wouldn't gracefully handle an (invalid)
		 duplicate insn description.  */
	      continue;
	    }
	  if (l->bit[bit_nr]->field->conditions->test == insn_field_cond_eq)
	    return +1;		/* left = only */
	  if (r->bit[bit_nr]->field->conditions->test == insn_field_cond_eq)
	    return -1;		/* right = only */
	  /* FIXME: Need to some what arbitrarily order conditional lists */
	  continue;
	}
      l = l->next;
      r = r->next;
    }
}

/* same as strcmp */
static int
insn_word_cmp (insn_word_entry *l, insn_word_entry *r)
{
  while (1)
    {
      int bit_nr;
      if (l == NULL && r == NULL)
	return 0;		/* all previous fields the same */
      if (l == NULL)
	return -1;		/* left shorter than right */
      if (r == NULL)
	return +1;		/* left longer than right */
      for (bit_nr = 0; bit_nr < options.insn_bit_size; bit_nr++)
	{
	  if (l->bit[bit_nr]->mask < r->bit[bit_nr]->mask)
	    return -1;
	  if (l->bit[bit_nr]->mask > r->bit[bit_nr]->mask)
	    return 1;
	  if (l->bit[bit_nr]->value < r->bit[bit_nr]->value)
	    return -1;
	  if (l->bit[bit_nr]->value > r->bit[bit_nr]->value)
	    return 1;
	}
      l = l->next;
      r = r->next;
    }
}

/* same as strcmp */
static int
opcode_bit_cmp (opcode_bits *l, opcode_bits *r)
{
  if (l == NULL && r == NULL)
    return 0;			/* all previous bits the same */
  if (l == NULL)
    return -1;			/* left shorter than right */
  if (r == NULL)
    return +1;			/* left longer than right */
  /* most significant word */
  if (l->field->word_nr < r->field->word_nr)
    return +1;			/* left has more significant word */
  if (l->field->word_nr > r->field->word_nr)
    return -1;			/* right has more significant word */
  /* most significant bit? */
  if (l->first < r->first)
    return +1;			/* left as more significant bit */
  if (l->first > r->first)
    return -1;			/* right as more significant bit */
  /* nr bits? */
  if (l->last < r->last)
    return +1;			/* left as less bits */
  if (l->last > r->last)
    return -1;			/* right as less bits */
  /* value? */
  if (l->value < r->value)
    return -1;
  if (l->value > r->value)
    return 1;
  return 0;
}


/* same as strcmp */
static int
opcode_bits_cmp (opcode_bits *l, opcode_bits *r)
{
  while (1)
    {
      int cmp;
      if (l == NULL && r == NULL)
	return 0;		/* all previous bits the same */
      cmp = opcode_bit_cmp (l, r);
      if (cmp != 0)
	return cmp;
      l = l->next;
      r = r->next;
    }
}

/* same as strcmp */
static opcode_bits *
new_opcode_bits (opcode_bits *old_bits,
		 int value,
		 int first,
		 int last, insn_field_entry *field, opcode_field *opcode)
{
  opcode_bits *new_bits = ZALLOC (opcode_bits);
  new_bits->field = field;
  new_bits->value = value;
  new_bits->first = first;
  new_bits->last = last;
  new_bits->opcode = opcode;

  if (old_bits != NULL)
    {
      opcode_bits *new_list;
      opcode_bits **last = &new_list;
      new_list = new_opcode_bits (old_bits->next,
				  old_bits->value,
				  old_bits->first,
				  old_bits->last,
				  old_bits->field, old_bits->opcode);
      while (*last != NULL)
	{
	  int cmp = opcode_bit_cmp (new_bits, *last);
	  if (cmp < 0)		/* new < new_list */
	    {
	      break;
	    }
	  if (cmp == 0)
	    {
	      ERROR ("Duplicated insn bits in list");
	    }
	  last = &(*last)->next;
	}
      new_bits->next = *last;
      *last = new_bits;
      return new_list;
    }
  else
    {
      return new_bits;
    }
}

/* Same as strcmp().  */
static int
name_cmp (const char *l, const char *r)
{
  if (l == NULL && r == NULL)
    return 0;
  if (l != NULL && r == NULL)
    return -1;
  if (l == NULL && r != NULL)
    return +1;
  return strcmp (l, r);
}


typedef enum
{
  merge_duplicate_insns,
  report_duplicate_insns,
}
duplicate_insn_actions;

static insn_list *
insn_list_insert (insn_list **cur_insn_ptr,
		  int *nr_insns,
		  insn_entry * insn,
		  opcode_bits *expanded_bits,
		  opcode_field *opcodes,
		  int nr_prefetched_words,
		  duplicate_insn_actions duplicate_action)
{
  /* insert it according to the order of the fields & bits */
  for (; (*cur_insn_ptr) != NULL; cur_insn_ptr = &(*cur_insn_ptr)->next)
    {
      int cmp;

      /* key#1 sort according to the constant fields of each instruction */
      cmp = insn_word_cmp (insn->words, (*cur_insn_ptr)->insn->words);
      if (cmp < 0)
	break;
      else if (cmp > 0)
	continue;

      /* key#2 sort according to the expanded bits of each instruction */
      cmp = opcode_bits_cmp (expanded_bits, (*cur_insn_ptr)->expanded_bits);
      if (cmp < 0)
	break;
      else if (cmp > 0)
	continue;

      /* key#3 sort according to the non-constant fields of each instruction */
      cmp = insn_field_cmp (insn->words, (*cur_insn_ptr)->insn->words);
      if (cmp < 0)
	break;
      else if (cmp > 0)
	continue;

      if (duplicate_action == merge_duplicate_insns)
	{
	  /* key#4: If we're going to merge duplicates, also sort
	     according to the format_name.  Two instructions with
	     identical decode patterns, but different names, are
	     considered different when merging.  Duplicates are only
	     important when creating a decode table (implied by
	     report_duplicate_insns) as such a table only has the
	     instruction's bit code as a way of differentiating
	     between instructions.  */
	  int cmp = name_cmp (insn->format_name,
			      (*cur_insn_ptr)->insn->format_name);
	  if (cmp < 0)
	    break;
	  else if (cmp > 0)
	    continue;
	}

      if (duplicate_action == merge_duplicate_insns)
	{
	  /* key#5: If we're going to merge duplicates, also sort
	     according to the name.  See comment above for
	     format_name.  */
	  int cmp = name_cmp (insn->name, (*cur_insn_ptr)->insn->name);
	  if (cmp < 0)
	    break;
	  else if (cmp > 0)
	    continue;
	}

      /* duplicate keys, report problem */
      switch (duplicate_action)
	{
	case report_duplicate_insns:
	  /* It would appear that we have two instructions with the
	     same constant field values across all words and bits.
	     This error can also occure when insn_field_cmp() is
	     failing to differentiate between two instructions that
	     differ only in their conditional fields. */
	  warning (insn->line,
		   "Two instructions with identical constant fields\n");
	  error ((*cur_insn_ptr)->insn->line,
		 "Location of duplicate instruction\n");
	case merge_duplicate_insns:
	  /* Add the opcode path to the instructions list */
	  if (options.trace.insn_insertion)
	    {
	      notify ((*cur_insn_ptr)->insn->line,
		      "%s.%s: insert merge %s.%s\n",
		      (*cur_insn_ptr)->insn->format_name,
		      (*cur_insn_ptr)->insn->name,
		      insn->format_name,
		      insn->name);
	    }
	  if (opcodes != NULL)
	    {
	      insn_opcodes **last = &(*cur_insn_ptr)->opcodes;
	      while (*last != NULL)
		{
		  last = &(*last)->next;
		}
	      (*last) = ZALLOC (insn_opcodes);
	      (*last)->opcode = opcodes;
	    }
	  /* Use the larger nr_prefetched_words */
	  if ((*cur_insn_ptr)->nr_prefetched_words < nr_prefetched_words)
	    (*cur_insn_ptr)->nr_prefetched_words = nr_prefetched_words;
	  return (*cur_insn_ptr);
	}

    }

  /* create a new list entry and insert it */
  {
    insn_list *new_insn = ZALLOC (insn_list);
    if (options.trace.insn_insertion)
      {
	notify (insn->line,
		"%s.%s: insert new\n",
		insn->format_name,
		insn->name);
      }
    new_insn->insn = insn;
    new_insn->expanded_bits = expanded_bits;
    new_insn->next = (*cur_insn_ptr);
    new_insn->nr_prefetched_words = nr_prefetched_words;
    if (opcodes != NULL)
      {
	new_insn->opcodes = ZALLOC (insn_opcodes);
	new_insn->opcodes->opcode = opcodes;
      }
    (*cur_insn_ptr) = new_insn;
  }

  *nr_insns += 1;

  return (*cur_insn_ptr);
}


extern void
gen_entry_traverse_tree (lf *file,
			 gen_entry *table,
			 int depth,
			 gen_entry_handler * start,
			 gen_entry_handler * leaf,
			 gen_entry_handler * end, void *data)
{
  gen_entry *entry;

  ASSERT (table !=NULL);
  ASSERT (table->opcode != NULL);
  ASSERT (table->nr_entries > 0);
  ASSERT (table->entries != 0);

  /* prefix */
  if (start != NULL && depth >= 0)
    {
      start (file, table, depth, data);
    }
  /* infix leaves */
  for (entry = table->entries; entry != NULL; entry = entry->sibling)
    {
      if (entry->entries != NULL && depth != 0)
	{
	  gen_entry_traverse_tree (file, entry, depth + 1,
				   start, leaf, end, data);
	}
      else if (depth >= 0)
	{
	  if (leaf != NULL)
	    {
	      leaf (file, entry, depth, data);
	    }
	}
    }
  /* postfix */
  if (end != NULL && depth >= 0)
    {
      end (file, table, depth, data);
    }
}



/* create a list element containing a single gen_table entry */

static gen_list *
make_table (insn_table *isa, decode_table *rules, model_entry *model)
{
  insn_entry *insn;
  gen_list *entry = ZALLOC (gen_list);
  entry->table = ZALLOC (gen_entry);
  entry->table->top = entry;
  entry->model = model;
  entry->isa = isa;
  for (insn = isa->insns; insn != NULL; insn = insn->next)
    {
      if (model == NULL
	  || insn->processors == NULL
	  || filter_is_member (insn->processors, model->name))
	{
	  insn_list_insert (&entry->table->insns, &entry->table->nr_insns, insn, NULL,	/* expanded_bits - none yet */
			    NULL,	/* opcodes - none yet */
			    0,	/* nr_prefetched_words - none yet */
			    report_duplicate_insns);
	}
    }
  entry->table->opcode_rule = rules;
  return entry;
}


gen_table *
make_gen_tables (insn_table *isa, decode_table *rules)
{
  gen_table *gen = ZALLOC (gen_table);
  gen->isa = isa;
  gen->rules = rules;
  if (options.gen.multi_sim)
    {
      gen_list **last = &gen->tables;
      model_entry *model;
      filter *processors;
      if (options.model_filter != NULL)
	processors = options.model_filter;
      else
	processors = isa->model->processors;
      for (model = isa->model->models; model != NULL; model = model->next)
	{
	  if (filter_is_member (processors, model->name))
	    {
	      *last = make_table (isa, rules, model);
	      last = &(*last)->next;
	    }
	}
    }
  else
    {
      gen->tables = make_table (isa, rules, NULL);
    }
  return gen;
}


/****************************************************************/

/* Is the bit, according to the decode rule, identical across all the
   instructions? */
static int
insns_bit_useless (insn_list *insns, decode_table *rule, int bit_nr)
{
  insn_list *entry;
  int value = -1;
  int is_useless = 1;		/* cleared if something actually found */

  /* check the instructions for some constant value in at least one of
     the bit fields */
  for (entry = insns; entry != NULL; entry = entry->next)
    {
      insn_word_entry *word = entry->insn->word[rule->word_nr];
      insn_bit_entry *bit = word->bit[bit_nr];
      switch (bit->field->type)
	{
	case insn_field_invalid:
	  ASSERT (0);
	  break;
	case insn_field_wild:
	case insn_field_reserved:
	  /* neither useless or useful - ignore */
	  break;
	case insn_field_int:
	  switch (rule->search)
	    {
	    case decode_find_strings:
	      /* an integer isn't a string */
	      return 1;
	    case decode_find_constants:
	    case decode_find_mixed:
	      /* an integer is useful if its value isn't the same
	         between all instructions.  The first time through the
	         value is saved, the second time through (if the
	         values differ) it is marked as useful. */
	      if (value < 0)
		value = bit->value;
	      else if (value != bit->value)
		is_useless = 0;
	      break;
	    }
	  break;
	case insn_field_string:
	  switch (rule->search)
	    {
	    case decode_find_strings:
	      /* at least one string, keep checking */
	      is_useless = 0;
	      break;
	    case decode_find_constants:
	    case decode_find_mixed:
	      if (filter_is_member (rule->constant_field_names,
				    bit->field->val_string))
		/* a string field forced to constant? */
		is_useless = 0;
	      else if (bit->field->conditions != NULL
		       && bit->field->conditions->test == insn_field_cond_eq
		       && bit->field->conditions->type == insn_field_cond_value)
		{
		  int shift = bit->field->last - bit_nr;
		  int bitvalue = (bit->field->conditions->value >> shift) & 1;

		  if (value < 0)
		    value = bitvalue;
		  else if (value != bitvalue)
		    is_useless = 0;
		}
	      else if (rule->search == decode_find_constants)
		/* the string field isn't constant */
		return 1;
	      break;
	    }
	}
    }

  /* Given only one constant value has been found, check through all
     the instructions to see if at least one conditional makes it
     usefull */
  if (value >= 0 && is_useless)
    {
      for (entry = insns; entry != NULL; entry = entry->next)
	{
	  insn_word_entry *word = entry->insn->word[rule->word_nr];
	  insn_bit_entry *bit = word->bit[bit_nr];
	  switch (bit->field->type)
	    {
	    case insn_field_invalid:
	      ASSERT (0);
	      break;
	    case insn_field_wild:
	    case insn_field_reserved:
	    case insn_field_int:
	      /* already processed */
	      break;
	    case insn_field_string:
	      switch (rule->search)
		{
		case decode_find_strings:
		case decode_find_constants:
		  /* already processed */
		  break;
		case decode_find_mixed:
		  /* string field with conditions.  If this condition
		     eliminates the value then the compare is useful */
		  if (bit->field->conditions != NULL)
		    {
		      insn_field_cond *condition;
		      int shift = bit->field->last - bit_nr;
		      for (condition = bit->field->conditions;
			   condition != NULL; condition = condition->next)
			{
			  switch (condition->type)
			    {
			    case insn_field_cond_value:
			      switch (condition->test)
				{
				case insn_field_cond_ne:
				  if (((condition->value >> shift) & 1)
				      == (unsigned) value)
				    /* conditional field excludes the
				       current value */
				    is_useless = 0;
				  break;
				case insn_field_cond_eq:
				  if (((condition->value >> shift) & 1)
				      != (unsigned) value)
				    /* conditional field requires the
				       current value */
				    is_useless = 0;
				  break;
				}
			      break;
			    case insn_field_cond_field:
			      /* are these handled separatly? */
			      break;
			    }
			}
		    }
		}
	    }
	}
    }

  return is_useless;
}


/* go through a gen-table's list of instruction formats looking for a
   range of bits that meet the decode table RULEs requirements */

static opcode_field *
gen_entry_find_opcode_field (insn_list *insns,
			     decode_table *rule, int string_only)
{
  opcode_field curr_opcode;
  ASSERT (rule != NULL);

  memset (&curr_opcode, 0, sizeof (curr_opcode));
  curr_opcode.word_nr = rule->word_nr;
  curr_opcode.first = rule->first;
  curr_opcode.last = rule->last;

  /* Try to reduce the size of first..last in accordance with the
     decode rules */

  while (curr_opcode.first <= rule->last)
    {
      if (insns_bit_useless (insns, rule, curr_opcode.first))
	curr_opcode.first++;
      else
	break;
    }
  while (curr_opcode.last >= rule->first)
    {
      if (insns_bit_useless (insns, rule, curr_opcode.last))
	curr_opcode.last--;
      else
	break;
    }

  /* did the final opcode field end up being empty? */
  if (curr_opcode.first > curr_opcode.last)
    {
      return NULL;
    }
  ASSERT (curr_opcode.last >= rule->first);
  ASSERT (curr_opcode.first <= rule->last);
  ASSERT (curr_opcode.first <= curr_opcode.last);

  /* Ensure that, for the non string only case, the opcode includes
     the range forced_first .. forced_last */
  if (!string_only && curr_opcode.first > rule->force_first)
    {
      curr_opcode.first = rule->force_first;
    }
  if (!string_only && curr_opcode.last < rule->force_last)
    {
      curr_opcode.last = rule->force_last;
    }

  /* For the string only case, force just the lower bound (so that the
     shift can be eliminated) */
  if (string_only && rule->force_last == options.insn_bit_size - 1)
    {
      curr_opcode.last = options.insn_bit_size - 1;
    }

  /* handle any special cases */
  switch (rule->type)
    {
    case normal_decode_rule:
      /* let the above apply */
      curr_opcode.nr_opcodes =
	(1 << (curr_opcode.last - curr_opcode.first + 1));
      break;
    case boolean_rule:
      curr_opcode.is_boolean = 1;
      curr_opcode.boolean_constant = rule->constant;
      curr_opcode.nr_opcodes = 2;
      break;
    }

  {
    opcode_field *new_field = ZALLOC (opcode_field);
    memcpy (new_field, &curr_opcode, sizeof (opcode_field));
    return new_field;
  }
}


static void
gen_entry_insert_insn (gen_entry *table,
		       insn_entry * old_insn,
		       int new_word_nr,
		       int new_nr_prefetched_words,
		       int new_opcode_nr, opcode_bits *new_bits)
{
  gen_entry **entry = &table->entries;

  /* find the new table for this entry */
  while ((*entry) != NULL && (*entry)->opcode_nr < new_opcode_nr)
    {
      entry = &(*entry)->sibling;
    }

  if ((*entry) == NULL || (*entry)->opcode_nr != new_opcode_nr)
    {
      /* insert the missing entry */
      gen_entry *new_entry = ZALLOC (gen_entry);
      new_entry->sibling = (*entry);
      (*entry) = new_entry;
      table->nr_entries++;
      /* fill it in */
      new_entry->top = table->top;
      new_entry->opcode_nr = new_opcode_nr;
      new_entry->word_nr = new_word_nr;
      new_entry->expanded_bits = new_bits;
      new_entry->opcode_rule = table->opcode_rule->next;
      new_entry->parent = table;
      new_entry->nr_prefetched_words = new_nr_prefetched_words;
    }
  /* ASSERT new_bits == cur_entry bits */
  ASSERT ((*entry) != NULL && (*entry)->opcode_nr == new_opcode_nr);
  insn_list_insert (&(*entry)->insns, &(*entry)->nr_insns, old_insn, NULL,	/* expanded_bits - only in final list */
		    NULL,	/* opcodes - only in final list */
		    new_nr_prefetched_words,	/* for this table */
		    report_duplicate_insns);
}


static void
gen_entry_expand_opcode (gen_entry *table,
			 insn_entry * instruction,
			 int bit_nr, int opcode_nr, opcode_bits *bits)
{
  if (bit_nr > table->opcode->last)
    {
      /* Only include the hardwired bit information with an entry IF
         that entry (and hence its functions) are being duplicated.  */
      if (options.trace.insn_expansion)
	{
	  print_gen_entry_path (table->opcode_rule->line, table, notify);
	  notify (NULL, ": insert %d - %s.%s%s\n",
		  opcode_nr,
		  instruction->format_name,
		  instruction->name,
		  (table->opcode_rule->
		   with_duplicates ? " (duplicated)" : ""));
	}
      if (table->opcode_rule->with_duplicates)
	{
	  gen_entry_insert_insn (table, instruction,
				 table->opcode->word_nr,
				 table->nr_prefetched_words, opcode_nr, bits);
	}
      else
	{
	  gen_entry_insert_insn (table, instruction,
				 table->opcode->word_nr,
				 table->nr_prefetched_words, opcode_nr, NULL);
	}
    }
  else
    {
      insn_word_entry *word = instruction->word[table->opcode->word_nr];
      insn_field_entry *field = word->bit[bit_nr]->field;
      int last_pos = ((field->last < table->opcode->last)
		      ? field->last : table->opcode->last);
      int first_pos = ((field->first > table->opcode->first)
		       ? field->first : table->opcode->first);
      int width = last_pos - first_pos + 1;
      switch (field->type)
	{
	case insn_field_int:
	  {
	    int val;
	    val = sub_val (field->val_int, field->last, first_pos, last_pos);
	    gen_entry_expand_opcode (table, instruction,
				     last_pos + 1,
				     ((opcode_nr << width) | val), bits);
	    break;
	  }
	default:
	  {
	    if (field->type == insn_field_reserved)
	      gen_entry_expand_opcode (table, instruction,
				       last_pos + 1,
				       ((opcode_nr << width)), bits);
	    else
	      {
		int val;
		int last_val = (table->opcode->is_boolean ? 2 : (1 << width));
		for (val = 0; val < last_val; val++)
		  {
		    /* check to see if the value has been precluded
		       (by a conditional) in some way */
		    int is_precluded;
		    insn_field_cond *condition;
		    for (condition = field->conditions, is_precluded = 0;
			 condition != NULL && !is_precluded;
			 condition = condition->next)
		      {
			switch (condition->type)
			  {
			  case insn_field_cond_value:
			    {
			      int value =
				sub_val (condition->value, field->last,
					 first_pos, last_pos);
			      switch (condition->test)
				{
				case insn_field_cond_ne:
				  if (value == val)
				    is_precluded = 1;
				  break;
				case insn_field_cond_eq:
				  if (value != val)
				    is_precluded = 1;
				  break;
				}
			      break;
			    }
			  case insn_field_cond_field:
			    {
			      int value = -1;
			      opcode_bits *bit;
			      gen_entry *t = NULL;
			      /* Try to find a value for the
			         conditional by looking back through
			         the previously defined bits for one
			         that covers the designated
			         conditional field */
			      for (bit = bits; bit != NULL; bit = bit->next)
				{
				  if (bit->field->word_nr ==
				      condition->field->word_nr
				      && bit->first <= condition->field->first
				      && bit->last >= condition->field->last)
				    {
				      /* the bit field fully specified
				         the conditional field's value */
				      value = sub_val (bit->value, bit->last,
						       condition->field->
						       first,
						       condition->field->
						       last);
				    }
				}
			      /* Try to find a value by looking
			         through this and previous tables */
			      if (bit == NULL)
				{
				  for (t = table;
				       t->parent != NULL; t = t->parent)
				    {
				      if (t->parent->opcode->word_nr ==
					  condition->field->word_nr
					  && t->parent->opcode->first <=
					  condition->field->first
					  && t->parent->opcode->last >=
					  condition->field->last)
					{
					  /* the table entry fully
					     specified the condition
					     field's value */
					  /* extract the field's value
					     from the opcode */
					  value =
					    sub_val (t->opcode_nr,
						     t->parent->opcode->last,
						     condition->field->first,
						     condition->field->last);
					  /* this is a requirement of
					     a conditonal field
					     refering to another field */
					  ASSERT ((condition->field->first -
						   condition->field->last) ==
						  (first_pos - last_pos));
					  printf
					    ("value=%d, opcode_nr=%d, last=%d, [%d..%d]\n",
					     value, t->opcode_nr,
					     t->parent->opcode->last,
					     condition->field->first,
					     condition->field->last);
					}
				    }
				}
			      if (bit == NULL && t == NULL)
				error (instruction->line,
				       "Conditional `%s' of field `%s' isn't expanded",
				       condition->string, field->val_string);
			      switch (condition->test)
				{
				case insn_field_cond_ne:
				  if (value == val)
				    is_precluded = 1;
				  break;
				case insn_field_cond_eq:
				  if (value != val)
				    is_precluded = 1;
				  break;
				}
			      break;
			    }
			  }
		      }
		    if (!is_precluded)
		      {
			/* Only add additional hardwired bit
			   information if the entry is not going to
			   later be combined */
			if (table->opcode_rule->with_combine)
			  {
			    gen_entry_expand_opcode (table, instruction,
						     last_pos + 1,
						     ((opcode_nr << width) |
						      val), bits);
			  }
			else
			  {
			    opcode_bits *new_bits =
			      new_opcode_bits (bits, val,
					       first_pos, last_pos,
					       field,
					       table->opcode);
			    gen_entry_expand_opcode (table, instruction,
						     last_pos + 1,
						     ((opcode_nr << width) |
						      val), new_bits);
			  }
		      }
		  }
	      }
	  }
	}
    }
}

static void
gen_entry_insert_expanding (gen_entry *table, insn_entry * instruction)
{
  gen_entry_expand_opcode (table,
			   instruction,
			   table->opcode->first, 0, table->expanded_bits);
}


static int
insns_match_format_names (insn_list *insns, filter *format_names)
{
  if (format_names != NULL)
    {
      insn_list *i;
      for (i = insns; i != NULL; i = i->next)
	{
	  if (i->insn->format_name != NULL
	      && !filter_is_member (format_names, i->insn->format_name))
	    return 0;
	}
    }
  return 1;
}

static int
table_matches_path (gen_entry *table, decode_path_list *paths)
{
  if (paths == NULL)
    return 1;
  while (paths != NULL)
    {
      gen_entry *entry = table;
      decode_path *path = paths->path;
      while (1)
	{
	  if (entry == NULL && path == NULL)
	    return 1;
	  if (entry == NULL || path == NULL)
	    break;
	  if (entry->opcode_nr != path->opcode_nr)
	    break;
	  entry = entry->parent;
	  path = path->parent;
	}
      paths = paths->next;
    }
  return 0;
}


static int
insns_match_conditions (insn_list *insns, decode_cond *conditions)
{
  if (conditions != NULL)
    {
      insn_list *i;
      for (i = insns; i != NULL; i = i->next)
	{
	  decode_cond *cond;
	  for (cond = conditions; cond != NULL; cond = cond->next)
	    {
	      int bit_nr;
	      if (i->insn->nr_words <= cond->word_nr)
		return 0;
	      for (bit_nr = 0; bit_nr < options.insn_bit_size; bit_nr++)
		{
		  if (!cond->mask[bit_nr])
		    continue;
		  if (!i->insn->word[cond->word_nr]->bit[bit_nr]->mask)
		    return 0;
		  if ((i->insn->word[cond->word_nr]->bit[bit_nr]->value
		       == cond->value[bit_nr]) == !cond->is_equal)
		    return 0;
		}
	    }
	}
    }
  return 1;
}

static int
insns_match_nr_words (insn_list *insns, int nr_words)
{
  insn_list *i;
  for (i = insns; i != NULL; i = i->next)
    {
      if (i->insn->nr_words < nr_words)
	return 0;
    }
  return 1;
}

static int
insn_list_cmp (insn_list *l, insn_list *r)
{
  while (1)
    {
      insn_entry *insn;
      if (l == NULL && r == NULL)
	return 0;
      if (l == NULL)
	return -1;
      if (r == NULL)
	return 1;
      if (l->insn != r->insn)
	return -1;		/* somewhat arbitrary at present */
      /* skip this insn */
      insn = l->insn;
      while (l != NULL && l->insn == insn)
	l = l->next;
      while (r != NULL && r->insn == insn)
	r = r->next;
    }
}



static void
gen_entry_expand_insns (gen_entry *table)
{
  decode_table *opcode_rule;

  ASSERT (table->nr_insns >= 1);

  /* determine a valid opcode */
  for (opcode_rule = table->opcode_rule;
       opcode_rule != NULL; opcode_rule = opcode_rule->next)
    {
      char *discard_reason;
      if (table->top->model != NULL
	  && opcode_rule->model_names != NULL
	  && !filter_is_member (opcode_rule->model_names,
				table->top->model->name))
	{
	  /* the rule isn't applicable to this processor */
	  discard_reason = "wrong model";
	}
      else if (table->nr_insns == 1 && opcode_rule->conditions == NULL)
	{
	  /* for safety, require a pre-codition when attempting to
	     apply a rule to a single instruction */
	  discard_reason = "need pre-condition when nr-insn == 1";
	}
      else if (table->nr_insns == 1 && !opcode_rule->with_duplicates)
	{
	  /* Little point in expanding a single instruction when we're
	     not duplicating the semantic functions that this table
	     calls */
	  discard_reason = "need duplication with nr-insns == 1";
	}
      else
	if (!insns_match_format_names
	    (table->insns, opcode_rule->format_names))
	{
	  discard_reason = "wrong format name";
	}
      else if (!insns_match_nr_words (table->insns, opcode_rule->word_nr + 1))
	{
	  discard_reason = "wrong nr words";
	}
      else if (!table_matches_path (table, opcode_rule->paths))
	{
	  discard_reason = "path failed";
	}
      else
	if (!insns_match_conditions (table->insns, opcode_rule->conditions))
	{
	  discard_reason = "condition failed";
	}
      else
	{
	  discard_reason = "no opcode field";
	  table->opcode = gen_entry_find_opcode_field (table->insns,
						       opcode_rule,
						       table->nr_insns == 1	/*string-only */
	    );
	  if (table->opcode != NULL)
	    {
	      table->opcode_rule = opcode_rule;
	      break;
	    }
	}

      if (options.trace.rule_rejection)
	{
	  print_gen_entry_path (opcode_rule->line, table, notify);
	  notify (NULL, ": rule discarded - %s\n", discard_reason);
	}
    }

  /* did we find anything */
  if (opcode_rule == NULL)
    {
      /* the decode table failed, this set of instructions haven't
         been uniquely identified */
      if (table->nr_insns > 1)
	{
	  print_gen_entry_insns (table, warning,
				 "was not uniquely decoded",
				 "decodes to the same entry");
	  error (NULL, "");
	}
      return;
    }

  /* Determine the number of words that must have been prefetched for
     this table to function */
  if (table->parent == NULL)
    table->nr_prefetched_words = table->opcode_rule->word_nr + 1;
  else if (table->opcode_rule->word_nr + 1 >
	   table->parent->nr_prefetched_words)
    table->nr_prefetched_words = table->opcode_rule->word_nr + 1;
  else
    table->nr_prefetched_words = table->parent->nr_prefetched_words;

  /* back link what we found to its parent */
  if (table->parent != NULL)
    {
      ASSERT (table->parent->opcode != NULL);
      table->opcode->parent = table->parent->opcode;
    }

  /* report the rule being used to expand the instructions */
  if (options.trace.rule_selection)
    {
      print_gen_entry_path (table->opcode_rule->line, table, notify);
      notify (NULL,
	      ": decode - word %d, bits [%d..%d] in [%d..%d], opcodes %d, entries %d\n",
	      table->opcode->word_nr,
	      i2target (options.hi_bit_nr, table->opcode->first),
	      i2target (options.hi_bit_nr, table->opcode->last),
	      i2target (options.hi_bit_nr, table->opcode_rule->first),
	      i2target (options.hi_bit_nr, table->opcode_rule->last),
	      table->opcode->nr_opcodes, table->nr_entries);
    }

  /* expand the raw instructions according to the opcode */
  {
    insn_list *entry;
    for (entry = table->insns; entry != NULL; entry = entry->next)
      {
	if (options.trace.insn_expansion)
	  {
	    print_gen_entry_path (table->opcode_rule->line, table, notify);
	    notify (NULL, ": expand - %s.%s\n",
		    entry->insn->format_name, entry->insn->name);
	  }
	gen_entry_insert_expanding (table, entry->insn);
      }
  }

  /* dump the results */
  if (options.trace.entries)
    {
      gen_entry *entry;
      for (entry = table->entries; entry != NULL; entry = entry->sibling)
	{
	  insn_list *l;
	  print_gen_entry_path (table->opcode_rule->line, entry, notify);
	  notify (NULL, ": %d - entries %d -",
		  entry->opcode_nr, entry->nr_insns);
	  for (l = entry->insns; l != NULL; l = l->next)
	    notify (NULL, " %s.%s", l->insn->format_name, l->insn->name);
	  notify (NULL, "\n");
	}
    }

  /* perform a combine pass if needed */
  if (table->opcode_rule->with_combine)
    {
      gen_entry *entry;
      for (entry = table->entries; entry != NULL; entry = entry->sibling)
	{
	  if (entry->combined_parent == NULL)
	    {
	      gen_entry **last = &entry->combined_next;
	      gen_entry *alt;
	      for (alt = entry->sibling; alt != NULL; alt = alt->sibling)
		{
		  if (alt->combined_parent == NULL
		      && insn_list_cmp (entry->insns, alt->insns) == 0)
		    {
		      alt->combined_parent = entry;
		      *last = alt;
		      last = &alt->combined_next;
		    }
		}
	    }
	}
      if (options.trace.combine)
	{
	  int nr_unique = 0;
	  gen_entry *entry;
	  for (entry = table->entries; entry != NULL; entry = entry->sibling)
	    {
	      if (entry->combined_parent == NULL)
		{
		  insn_list *l;
		  gen_entry *duplicate;
		  nr_unique++;
		  print_gen_entry_path (table->opcode_rule->line, entry,
					notify);
		  for (duplicate = entry->combined_next; duplicate != NULL;
		       duplicate = duplicate->combined_next)
		    {
		      notify (NULL, "+%d", duplicate->opcode_nr);
		    }
		  notify (NULL, ": entries %d -", entry->nr_insns);
		  for (l = entry->insns; l != NULL; l = l->next)
		    {
		      notify (NULL, " %s.%s",
			      l->insn->format_name, l->insn->name);
		    }
		  notify (NULL, "\n");
		}
	    }
	  print_gen_entry_path (table->opcode_rule->line, table, notify);
	  notify (NULL,
		  ": combine - word %d, bits [%d..%d] in [%d..%d], opcodes %d, entries %d, unique %d\n",
		  table->opcode->word_nr, i2target (options.hi_bit_nr,
						    table->opcode->first),
		  i2target (options.hi_bit_nr, table->opcode->last),
		  i2target (options.hi_bit_nr, table->opcode_rule->first),
		  i2target (options.hi_bit_nr, table->opcode_rule->last),
		  table->opcode->nr_opcodes, table->nr_entries, nr_unique);
	}
    }

  /* Check that the rule did more than re-arange the order of the
     instructions */
  {
    gen_entry *entry;
    for (entry = table->entries; entry != NULL; entry = entry->sibling)
      {
	if (entry->combined_parent == NULL)
	  {
	    if (insn_list_cmp (table->insns, entry->insns) == 0)
	      {
		print_gen_entry_path (table->opcode_rule->line, table,
				      warning);
		warning (NULL,
			 ": Applying rule just copied all instructions\n");
		print_gen_entry_insns (entry, warning, "Copied", NULL);
		error (NULL, "");
	      }
	  }
      }
  }

  /* if some form of expanded table, fill in the missing dots */
  switch (table->opcode_rule->gen)
    {
    case padded_switch_gen:
    case array_gen:
    case goto_switch_gen:
      if (!table->opcode->is_boolean)
	{
	  gen_entry **entry = &table->entries;
	  gen_entry *illegals = NULL;
	  gen_entry **last_illegal = &illegals;
	  int opcode_nr = 0;
	  while (opcode_nr < table->opcode->nr_opcodes)
	    {
	      if ((*entry) == NULL || (*entry)->opcode_nr != opcode_nr)
		{
		  /* missing - insert it under our feet at *entry */
		  gen_entry_insert_insn (table, table->top->isa->illegal_insn, table->opcode->word_nr, 0,	/* nr_prefetched_words == 0 for invalid */
					 opcode_nr, NULL);
		  ASSERT ((*entry) != NULL);
		  ASSERT ((*entry)->opcode_nr == opcode_nr);
		  (*last_illegal) = *entry;
		  (*last_illegal)->combined_parent = illegals;
		  last_illegal = &(*last_illegal)->combined_next;
		}
	      entry = &(*entry)->sibling;
	      opcode_nr++;
	    }
	  /* oops, will have pointed the first illegal insn back to
	     its self.  Fix this */
	  if (illegals != NULL)
	    illegals->combined_parent = NULL;
	}
      break;
    case switch_gen:
    case invalid_gen:
      /* ignore */
      break;
    }

  /* and do the same for the newly created sub entries but *only*
     expand entries that haven't been combined. */
  {
    gen_entry *entry;
    for (entry = table->entries; entry != NULL; entry = entry->sibling)
      {
	if (entry->combined_parent == NULL)
	  {
	    gen_entry_expand_insns (entry);
	  }
      }
  }
}

void
gen_tables_expand_insns (gen_table *gen)
{
  gen_list *entry;
  for (entry = gen->tables; entry != NULL; entry = entry->next)
    {
      gen_entry_expand_insns (entry->table);
    }
}


/* create a list of all the semantic functions that need to be
   generated.  Eliminate any duplicates. Verify that the decode stage
   worked. */

static void
make_gen_semantics_list (lf *file, gen_entry *entry, int depth, void *data)
{
  gen_table *gen = (gen_table *) data;
  insn_list *insn;
  /* Not interested in an entrie that have been combined into some
     other entry at the same level */
  if (entry->combined_parent != NULL)
    return;

  /* a leaf should contain exactly one instruction. If not the decode
     stage failed. */
  ASSERT (entry->nr_insns == 1);

  /* Enter this instruction into the list of semantic functions. */
  insn = insn_list_insert (&gen->semantics, &gen->nr_semantics,
			   entry->insns->insn,
			   entry->expanded_bits,
			   entry->parent->opcode,
			   entry->insns->nr_prefetched_words,
			   merge_duplicate_insns);
  /* point the table entry at the real semantic function */
  ASSERT (insn != NULL);
  entry->insns->semantic = insn;
}


void
gen_tables_expand_semantics (gen_table *gen)
{
  gen_list *entry;
  for (entry = gen->tables; entry != NULL; entry = entry->next)
    {
      gen_entry_traverse_tree (NULL, entry->table, 1,	/* depth */
			       NULL,	/* start-handler */
			       make_gen_semantics_list,	/* leaf-handler */
			       NULL,	/* end-handler */
			       gen);	/* data */
    }
}



#ifdef MAIN


static void
dump_opcode_field (lf *file,
		   char *prefix,
		   opcode_field *field, char *suffix, int levels)
{
  lf_printf (file, "%s(opcode_field *) 0x%lx", prefix, (long) field);
  if (levels && field != NULL)
    {
      lf_indent (file, +1);
      lf_printf (file, "\n(first %d)", field->first);
      lf_printf (file, "\n(last %d)", field->last);
      lf_printf (file, "\n(nr_opcodes %d)", field->nr_opcodes);
      lf_printf (file, "\n(is_boolean %d)", field->is_boolean);
      lf_printf (file, "\n(boolean_constant %d)", field->boolean_constant);
      dump_opcode_field (file, "\n(parent ", field->parent, ")", levels - 1);
      lf_indent (file, -1);
    }
  lf_printf (file, "%s", suffix);
}


static void
dump_opcode_bits (lf *file,
		  char *prefix, opcode_bits *bits, char *suffix, int levels)
{
  lf_printf (file, "%s(opcode_bits *) 0x%lx", prefix, (long) bits);

  if (levels && bits != NULL)
    {
      lf_indent (file, +1);
      lf_printf (file, "\n(value %d)", bits->value);
      dump_opcode_field (file, "\n(opcode ", bits->opcode, ")", 0);
      dump_insn_field (file, "\n(field ", bits->field, ")");
      dump_opcode_bits (file, "\n(next ", bits->next, ")", levels - 1);
      lf_indent (file, -1);
    }
  lf_printf (file, "%s", suffix);
}



static void
dump_insn_list (lf *file, char *prefix, insn_list *entry, char *suffix)
{
  lf_printf (file, "%s(insn_list *) 0x%lx", prefix, (long) entry);

  if (entry != NULL)
    {
      lf_indent (file, +1);
      dump_insn_entry (file, "\n(insn ", entry->insn, ")");
      lf_printf (file, "\n(next 0x%lx)", (long) entry->next);
      lf_indent (file, -1);
    }
  lf_printf (file, "%s", suffix);
}


static void
dump_insn_word_entry_list_entries (lf *file,
				   char *prefix,
				   insn_list *entry, char *suffix)
{
  lf_printf (file, "%s", prefix);
  while (entry != NULL)
    {
      dump_insn_list (file, "\n(", entry, ")");
      entry = entry->next;
    }
  lf_printf (file, "%s", suffix);
}


static void
dump_gen_entry (lf *file,
		char *prefix, gen_entry *table, char *suffix, int levels)
{

  lf_printf (file, "%s(gen_entry *) 0x%lx", prefix, (long) table);

  if (levels && table !=NULL)
    {

      lf_indent (file, +1);
      lf_printf (file, "\n(opcode_nr %d)", table->opcode_nr);
      lf_printf (file, "\n(word_nr %d)", table->word_nr);
      dump_opcode_bits (file, "\n(expanded_bits ", table->expanded_bits, ")",
			-1);
      lf_printf (file, "\n(nr_insns %d)", table->nr_insns);
      dump_insn_word_entry_list_entries (file, "\n(insns ", table->insns,
					 ")");
      dump_decode_rule (file, "\n(opcode_rule ", table->opcode_rule, ")");
      dump_opcode_field (file, "\n(opcode ", table->opcode, ")", 0);
      lf_printf (file, "\n(nr_entries %d)", table->nr_entries);
      dump_gen_entry (file, "\n(entries ", table->entries, ")",
		      table->nr_entries);
      dump_gen_entry (file, "\n(sibling ", table->sibling, ")", levels - 1);
      dump_gen_entry (file, "\n(parent ", table->parent, ")", 0);
      lf_indent (file, -1);
    }
  lf_printf (file, "%s", suffix);
}

static void
dump_gen_list (lf *file,
	       char *prefix, gen_list *entry, char *suffix, int levels)
{
  while (entry != NULL)
    {
      lf_printf (file, "%s(gen_list *) 0x%lx", prefix, (long) entry);
      dump_gen_entry (file, "\n(", entry->table, ")", levels);
      lf_printf (file, "\n(next (gen_list *) 0x%lx)", (long) entry->next);
      lf_printf (file, "%s", suffix);
    }
}


static void
dump_gen_table (lf *file,
		char *prefix, gen_table *gen, char *suffix, int levels)
{
  lf_printf (file, "%s(gen_table *) 0x%lx", prefix, (long) gen);
  lf_printf (file, "\n(isa (insn_table *) 0x%lx)", (long) gen->isa);
  lf_printf (file, "\n(rules (decode_table *) 0x%lx)", (long) gen->rules);
  dump_gen_list (file, "\n(", gen->tables, ")", levels);
  lf_printf (file, "%s", suffix);
}


igen_options options;

int
main (int argc, char **argv)
{
  decode_table *decode_rules;
  insn_table *instructions;
  gen_table *gen;
  lf *l;

  if (argc != 7)
    error (NULL,
	   "Usage: insn <filter-in> <hi-bit-nr> <insn-bit-size> <widths> <decode-table> <insn-table>\n");

  INIT_OPTIONS (options);

  filter_parse (&options.flags_filter, argv[1]);

  options.hi_bit_nr = a2i (argv[2]);
  options.insn_bit_size = a2i (argv[3]);
  options.insn_specifying_widths = a2i (argv[4]);
  ASSERT (options.hi_bit_nr < options.insn_bit_size);

  instructions = load_insn_table (argv[6], NULL);
  decode_rules = load_decode_table (argv[5]);
  gen = make_gen_tables (instructions, decode_rules);

  gen_tables_expand_insns (gen);

  l = lf_open ("-", "stdout", lf_omit_references, lf_is_text, "tmp-ld-insn");

  dump_gen_table (l, "(", gen, ")\n", -1);
  return 0;
}

#endif
@


1.15
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright 2002, 2007-2012 Free Software Foundation, Inc.
@


1.14
log
@	Correct handling of constant fields.
	* gen.c (insn_field_cmp): Tweak comment about neither field
	being an insn_field_string with a cond_eq-to-value condition.
	(insns_bit_useless) <case insn_field_string, case
	decode_find_mixed>: Handle cond_eq-to-value fields as
	insn_field_int.
	* gen-idecode.c (print_idecode_validate): Handle
	insn_field_string cond-equal-to-value fields as insn_field_int.
	* gen-icache.c (print_icache_body): Add comment why constant
	string fields are handled.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.14.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright 2002, 2007-2012 Free Software Foundation, Inc.
@


1.13
log
@	Remove all #if 0'd code.
	* filter.c: Remove #if 0'd function it_is.
	(main): Remove #if 0'd code.
	* gen-engine.c: Remove #if 0'd functions print_jump,
	print_jump_insn, print_jump_definition,
	print_jump_internal_function, print_jump_body.
	(gen_engine_c): Remove #if 0'd code.
	* gen-idecode.c: Remove #if 0'd functions print_jump print_jump,
	print_jump_insn, print_jump_definition,
	print_jump_internal_function, print_jump_until_stop_body.
	* gen-model.c: Remove #if 0'd functions model_c_or_h_data,
	model_c_or_h_function, gen_model_h, model_c_insn,
	model_c_function, gen_model_c and types model_c_passed_data
	and struct _model_c_passed_data.
	* gen.c: Remove #if 0'd type constant_field_types and function
	insn_field_is_constant.
	(gen_entry_find_opcode_field): Remove #if 0'd code.
	* ld-insn.c (parse_insn_model_record): Remove #if 0'd code.
	* misc.h (STRDUP, STRNDUP): Remove #if 0'd macros.
@
text
@d154 3
a156 1
	         into normal constant fields. */
d616 12
@


1.12
log
@run copyright.sh for 2011.
@
text
@a557 42
#if 0
typedef enum
{
  field_is_not_constant = 0,
  field_constant_int = 1,
  field_constant_reserved = 2,
  field_constant_string = 3
}
constant_field_types;

static constant_field_types
insn_field_is_constant (insn_field * field, decode_table *rule)
{
  switch (field->type)
    {
    case insn_field_int:
      /* field is an integer */
      return field_constant_int;
    case insn_field_reserved:
      /* field is `/' and treating that as a constant */
      if (rule->with_zero_reserved)
	return field_constant_reserved;
      else
	return field_is_not_constant;
    case insn_field_wild:
      return field_is_not_constant;	/* never constant */
    case insn_field_string:
      /* field, though variable, is on the list of forced constants */
      if (filter_is_member (rule->constant_field_names, field->val_string))
	return field_constant_string;
      else
	return field_is_not_constant;
    }
  ERROR ("Internal error");
  return field_is_not_constant;
}
#endif


/****************************************************************/


a726 69

#if 0
  for (entry = insns; entry != NULL; entry = entry->next)
    {
      insn_word_entry *fields = entry->insn->word[rule->word_nr];
      opcode_field new_opcode;

      ASSERT (fields != NULL);

      /* find a start point for the opcode field */
      new_opcode.first = rule->first;
      while (new_opcode.first <= rule->last
	     && (!string_only
		 ||
		 (insn_field_is_constant (fields->bit[new_opcode.first], rule)
		  != field_constant_string)) && (string_only
						 ||
						 (insn_field_is_constant
						  (fields->
						   bit[new_opcode.first],
						   rule) ==
						  field_is_not_constant)))
	{
	  int new_first = fields->bit[new_opcode.first]->last + 1;
	  ASSERT (new_first > new_opcode.first);
	  new_opcode.first = new_first;
	}
      ASSERT (new_opcode.first > rule->last
	      || (string_only
		  && insn_field_is_constant (fields->bit[new_opcode.first],
					     rule) == field_constant_string)
	      || (!string_only
		  && insn_field_is_constant (fields->bit[new_opcode.first],
					     rule)));

      /* find the end point for the opcode field */
      new_opcode.last = rule->last;
      while (new_opcode.last >= rule->first
	     && (!string_only
		 || insn_field_is_constant (fields->bit[new_opcode.last],
					    rule) != field_constant_string)
	     && (string_only
		 || !insn_field_is_constant (fields->bit[new_opcode.last],
					     rule)))
	{
	  int new_last = fields->bit[new_opcode.last]->first - 1;
	  ASSERT (new_last < new_opcode.last);
	  new_opcode.last = new_last;
	}
      ASSERT (new_opcode.last < rule->first
	      || (string_only
		  && insn_field_is_constant (fields->bit[new_opcode.last],
					     rule) == field_constant_string)
	      || (!string_only
		  && insn_field_is_constant (fields->bit[new_opcode.last],
					     rule)));

      /* now see if our current opcode needs expanding to include the
         interesting fields within this instruction */
      if (new_opcode.first <= rule->last
	  && curr_opcode.first > new_opcode.first)
	curr_opcode.first = new_opcode.first;
      if (new_opcode.last >= rule->first
	  && curr_opcode.last < new_opcode.last)
	curr_opcode.last = new_opcode.last;

    }
#endif

@


1.11
log
@Update copyright notices to add year 2010.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.10
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.9
log
@	Updated copyright notices for most files.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008 Free Software Foundation, Inc.
@


1.8
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d3 1
a3 1
   Copyright 2002, 2007 Free Software Foundation, Inc.
@


1.7
log
@Copyright updates for 2007.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.6
log
@2002-11-22  Andrew Cagney  <cagney@@redhat.com>

	* gen.c (name_cmp): Rename format_name_cmp.
	(insn_list_insert): When a merge, compare the format name and
	instruction name.  Add trace messages.
@
text
@d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
@


1.5
log
@2002-11-21  Andrew Cagney  <ac131313@@redhat.com>

	* filter.c: Re-indent.
	* filter.h, filter_host.h, gen-engine.c, gen-engine.h: Ditto.
	* gen-icache.c, gen-icache.h, gen-idecode.c: Ditto.
	* gen-idecode.h, gen-itable.c, gen-itable.h: Ditto.
	* gen-model.c, gen-model.h, gen-semantics.c: Ditto.
	* gen-semantics.h, gen-support.c, gen-support.h: Ditto.
	* gen.c, gen.h, igen.c, igen.h, ld-cache.c, ld-cache.h: Ditto.
	* ld-decode.c, ld-decode.h, ld-insn.c, ld-insn.h, lf.c: Ditto.
	* lf.h, misc.c, misc.h, table.c, table.h: Ditto.
@
text
@d299 1
a299 1
format_name_cmp (const char *l, const char *r)
d353 29
a381 13
      /* key#4 sort according to the format-name.  If two apparently
         identical instructions have unique format-names, then the
         instructions are different.  This is because the
         format-name's use is overloaded, it not only indicates the
         format name but also provides a unique semantic name for the
         function.  */
      cmp =
	format_name_cmp (insn->format_name,
			 (*cur_insn_ptr)->insn->format_name);
      if (cmp < 0)
	break;
      else if (cmp > 0)
	continue;
d398 9
d428 7
@


1.4
log
@2002-11-21  Andrew Cagney  <ac131313@@redhat.com>

        * Makefile.in: Update copyright.  IGEN contributed to the FSF.
        * filter.c, filter.h, filter_host.c, filter_host.h: Ditto.
        * gen-engine.c, gen-engine.h, gen-icache.c, gen-icache.h: Ditto.
        * gen-idecode.c, gen-idecode.h, gen-itable.c: Ditto.
        * gen-itable.h, gen-model.c, gen-model.h, gen-semantics.c: Ditto.
        * gen-semantics.h, gen-support.c, gen-support.h, gen.c: Ditto.
        * gen.h, igen.c, igen.h, ld-cache.c, ld-cache.h: Ditto.
        * ld-decode.c, ld-decode.h, ld-insn.c, ld-insn.h, lf.c: Ditto.
        * lf.h, misc.c, misc.h, table.c, table.h: Ditto.
@
text
@d36 1
a36 4
sub_val (insn_uint val,
	 int val_last_pos,
	 int first_pos,
	 int last_pos)
d39 1
a39 1
	  & (((insn_uint)1 << (last_pos - first_pos + 1)) - 1));
d43 1
a43 4
update_depth (lf *file,
	      gen_entry *entry,
	      int depth,
	      void *data)
d45 1
a45 1
  int *max_depth = (int*)data;
d55 3
a57 7
  gen_entry_traverse_tree (NULL,
			   table,
			   1,
			   NULL, /*start*/
			   update_depth,
			   NULL, /*end*/
			   &depth); /* data */
d63 1
a63 3
print_gen_entry_path (line_ref *line,
		      gen_entry *table,
		      error_func *print)
d82 1
a82 2
		       char *first_message,
		       char *next_message)
d91 1
a91 4
      print (NULL, ": %s.%s %s\n",
	     insn->format_name,
	     insn->name,
	     message);
d105 1
a105 1
	return 0; /* all previous fields the same */
d107 1
a107 1
	return -1; /* left shorter than right */
d109 2
a110 4
	return +1; /* left longer than right */
      for (bit_nr = 0;
	   bit_nr < options.insn_bit_size;
	   bit_nr++)
d123 3
a125 2
		    l->bit[bit_nr]->field->conditions->test == insn_field_cond_eq ? "=" : "!",
		    l->bit[bit_nr]->field->conditions->string,	
d127 2
a128 1
		    r->bit[bit_nr]->field->conditions->test == insn_field_cond_eq ? "=" : "!",
d131 2
a132 1
	      && r->bit[bit_nr]->field->conditions->test == insn_field_cond_eq)
d134 4
a137 2
	      if (l->bit[bit_nr]->field->conditions->type == insn_field_cond_field
		  && r->bit[bit_nr]->field->conditions->type == insn_field_cond_field)
d141 2
a142 1
				    r->bit[bit_nr]->field->conditions->string);
d148 2
a149 1
	      if (l->bit[bit_nr]->field->conditions->type == insn_field_cond_field)
d151 2
a152 1
	      if (r->bit[bit_nr]->field->conditions->type == insn_field_cond_field)
d155 2
a156 2
		 already have been handled because such fields are converted
		 into normal constant fields. */
d160 1
a160 1
	    return +1; /* left = only */
d162 1
a162 1
	    return -1; /* right = only */
d179 1
a179 1
	return 0; /* all previous fields the same */
d181 1
a181 1
	return -1; /* left shorter than right */
d183 2
a184 4
	return +1; /* left longer than right */
      for (bit_nr = 0;
	   bit_nr < options.insn_bit_size;
	   bit_nr++)
d202 1
a202 2
opcode_bit_cmp (opcode_bits *l,
		opcode_bits *r)
d205 1
a205 1
    return 0; /* all previous bits the same */
d207 1
a207 1
    return -1; /* left shorter than right */
d209 1
a209 1
    return +1; /* left longer than right */
d212 1
a212 1
    return +1; /* left has more significant word */
d214 1
a214 1
    return -1; /* right has more significant word */
d217 1
a217 1
    return +1; /* left as more significant bit */
d219 1
a219 1
    return -1; /* right as more significant bit */
d222 1
a222 1
    return +1; /* left as less bits */
d224 1
a224 1
    return -1; /* right as less bits */
d236 1
a236 2
opcode_bits_cmp (opcode_bits *l,
		 opcode_bits *r)
d242 1
a242 1
	return 0; /* all previous bits the same */
d256 1
a256 3
		 int last,
		 insn_field_entry *field,
		 opcode_field *opcode)
d264 1
a264 1
  
d273 1
a273 2
				  old_bits->field,
				  old_bits->opcode);
d277 1
a277 1
	  if (cmp < 0) /* new < new_list */
d311 2
a312 1
typedef enum {
d315 2
a316 1
} duplicate_insn_actions;
d321 1
a321 1
		  insn_entry *insn,
d354 8
a361 6
	 identical instructions have unique format-names, then the
	 instructions are different.  This is because the
	 format-name's use is overloaded, it not only indicates the
	 format name but also provides a unique semantic name for the
	 function.  */
      cmp = format_name_cmp (insn->format_name, (*cur_insn_ptr)->insn->format_name);
d399 1
a399 1
  
d414 1
a414 1
  
d425 3
a427 4
			 gen_entry_handler *start,
			 gen_entry_handler *leaf,
			 gen_entry_handler *end,
			 void *data)
d430 2
a431 2
  
  ASSERT (table != NULL);
d435 1
a435 1
  
d442 1
a442 3
  for (entry = table->entries;
       entry != NULL;
       entry = entry->sibling)
d469 1
a469 3
make_table (insn_table *isa,
	    decode_table *rules,
	    model_entry *model)
d483 3
a485 6
	  insn_list_insert (&entry->table->insns,
			    &entry->table->nr_insns,
			    insn,
			    NULL, /* expanded_bits - none yet */
			    NULL, /* opcodes - none yet */
			    0, /* nr_prefetched_words - none yet */
d495 1
a495 2
make_gen_tables (insn_table *isa,
		 decode_table *rules)
d509 1
a509 3
      for (model = isa->model->models;
	   model != NULL;
	   model = model->next)
d524 2
a525 2
  
  
d529 2
a530 1
typedef enum {
d535 2
a536 1
} constant_field_types;
d539 1
a539 2
insn_field_is_constant (insn_field *field,
		        decode_table *rule)
d553 1
a553 1
      return field_is_not_constant; /* never constant */
d573 1
a573 3
insns_bit_useless (insn_list *insns,
		   decode_table *rule,
		   int bit_nr)
d577 1
a577 1
  int is_useless = 1; /* cleared if something actually found */
d603 3
a605 3
                 between all instructions.  The first time through the
                 value is saved, the second time through (if the
                 values differ) it is marked as useful. */
d662 1
a662 1
                     eliminates the value then the compare is useful */
d668 1
a668 2
			   condition != NULL;
			   condition = condition->next)
d679 1
a679 1
                                       current value */
d686 1
a686 1
                                       current value */
d711 1
a711 2
			     decode_table *rule,
			     int string_only)
d727 1
a727 1
	curr_opcode.first ++;
d734 1
a734 1
	curr_opcode.last --;
d745 1
a745 1
      
d747 1
a747 1
      
d752 9
a760 5
		 || (insn_field_is_constant(fields->bit[new_opcode.first], rule)
		     != field_constant_string))
	     && (string_only
		 || (insn_field_is_constant(fields->bit[new_opcode.first], rule)
		     == field_is_not_constant)))
d766 8
a773 8
      ASSERT(new_opcode.first > rule->last
	     || (string_only
		 && insn_field_is_constant(fields->bit[new_opcode.first],
					   rule) == field_constant_string)
	     || (!string_only
		 && insn_field_is_constant(fields->bit[new_opcode.first],
					   rule)));
      
d778 2
a779 2
		 || insn_field_is_constant(fields->bit[new_opcode.last],
					   rule) != field_constant_string)
d781 2
a782 2
		 || !insn_field_is_constant(fields->bit[new_opcode.last],
					    rule)))
d788 8
a795 8
      ASSERT(new_opcode.last < rule->first
	     || (string_only
		 && insn_field_is_constant(fields->bit[new_opcode.last],
					   rule) == field_constant_string)
	     || (!string_only
		 && insn_field_is_constant(fields->bit[new_opcode.last],
					   rule)));
      
d797 1
a797 1
	 interesting fields within this instruction */
d804 1
a804 1
      
d819 1
a819 2
  if (!string_only
      && curr_opcode.first > rule->force_first)
d823 1
a823 2
  if (!string_only
      && curr_opcode.last < rule->force_last)
d830 1
a830 2
  if (string_only
      && rule->force_last == options.insn_bit_size - 1)
d860 1
a860 1
		       insn_entry *old_insn,
d863 1
a863 2
		       int new_opcode_nr,
		       opcode_bits *new_bits)
d866 1
a866 1
  
d872 1
a872 1
  
d891 3
a893 6
  insn_list_insert (&(*entry)->insns,
		    &(*entry)->nr_insns,
		    old_insn,
		    NULL, /* expanded_bits - only in final list */
		    NULL, /* opcodes - only in final list */
		    new_nr_prefetched_words, /* for this table */
d900 2
a901 4
			 insn_entry *instruction,
			 int bit_nr,
			 int opcode_nr,
			 opcode_bits *bits)
d914 2
a915 1
		  (table->opcode_rule->with_duplicates ? " (duplicated)" : ""));
d921 1
a921 2
				 table->nr_prefetched_words,
				 opcode_nr, bits);
d927 1
a927 2
				 table->nr_prefetched_words,
				 opcode_nr, NULL);
d935 1
a935 2
		      ? field->last
		      : table->opcode->last);
d937 1
a937 2
		       ? field->first
		       : table->opcode->first);
d944 1
a944 2
	    val = sub_val (field->val_int, field->last,
			   first_pos, last_pos);
d947 1
a947 2
				     ((opcode_nr << width) | val),
				     bits);
d955 1
a955 2
				       ((opcode_nr << width)),
				       bits);
d959 1
a959 3
		int last_val = (table->opcode->is_boolean
				? 2
				: (1 << width));
d963 1
a963 1
                       (by a conditional) in some way */
d974 3
a976 2
			      int value = sub_val (condition->value, field->last,
						   first_pos, last_pos);
d996 5
a1000 7
                                 conditional by looking back through
                                 the previously defined bits for one
                                 that covers the designated
                                 conditional field */
			      for (bit = bits;
				   bit != NULL;
				   bit = bit->next)
d1002 2
a1003 1
				  if (bit->field->word_nr == condition->field->word_nr
d1008 1
a1008 1
					 the conditional field's value */
d1010 4
a1013 2
						       condition->field->first,
						       condition->field->last);
d1017 1
a1017 1
                                 through this and previous tables */
d1021 1
a1021 2
				       t->parent != NULL;
				       t = t->parent)
d1023 6
a1028 3
				      if (t->parent->opcode->word_nr == condition->field->word_nr
					  && t->parent->opcode->first <= condition->field->first
					  && t->parent->opcode->last >= condition->field->last)
d1031 2
a1032 2
                                             specified the condition
                                             field's value */
d1034 6
a1039 3
                                             from the opcode */
					  value = sub_val (t->opcode_nr, t->parent->opcode->last,
							   condition->field->first, condition->field->last);
d1041 11
a1051 6
                                             a conditonal field
                                             refering to another field */
					  ASSERT ((condition->field->first - condition->field->last)
						  == (first_pos - last_pos));
printf ("value=%d, opcode_nr=%d, last=%d, [%d..%d]\n",
	value, t->opcode_nr, t->parent->opcode->last, condition->field->first, condition->field->last);
d1077 2
a1078 2
                           information if the entry is not going to
                           later be combined */
d1083 2
a1084 2
						     ((opcode_nr << width) | val),
						     bits);
d1088 5
a1092 4
			    opcode_bits *new_bits = new_opcode_bits (bits, val,
								     first_pos, last_pos,
								     field,
								     table->opcode);
d1095 2
a1096 2
						     ((opcode_nr << width) | val),
						     new_bits);
d1107 1
a1107 2
gen_entry_insert_expanding (gen_entry *table,
			    insn_entry *instruction)
d1111 1
a1111 3
			   table->opcode->first,
			   0,
			   table->expanded_bits);
d1116 1
a1116 2
insns_match_format_names (insn_list *insns,
			  filter *format_names)
d1123 2
a1124 2
	  if ( i->insn->format_name != NULL
	       && !filter_is_member (format_names, i->insn->format_name))
d1132 1
a1132 2
table_matches_path (gen_entry *table,
		    decode_path_list *paths)
d1158 1
a1158 2
insns_match_conditions (insn_list *insns,
			decode_cond *conditions)
d1178 1
a1178 2
		       == cond->value[bit_nr])
		      == !cond->is_equal)
d1188 1
a1188 2
insns_match_nr_words (insn_list *insns,
		      int nr_words)
d1200 1
a1200 2
insn_list_cmp (insn_list *l,
	       insn_list *r)
d1212 1
a1212 1
	return -1; /* somewhat arbitrary at present */
d1229 2
a1230 2
  ASSERT(table->nr_insns >= 1);
  
d1233 1
a1233 2
       opcode_rule != NULL;
       opcode_rule = opcode_rule->next)
d1247 1
a1247 1
             apply a rule to a single instruction */
d1253 2
a1254 2
             not duplicating the semantic functions that this table
             calls */
d1257 3
a1259 1
      else if (!insns_match_format_names (table->insns, opcode_rule->format_names))
d1271 2
a1272 1
      else if (!insns_match_conditions (table->insns, opcode_rule->conditions))
d1279 4
a1282 5
	  table->opcode =
	    gen_entry_find_opcode_field (table->insns,
					 opcode_rule,
					 table->nr_insns == 1/*string-only*/
					 );
d1296 1
a1296 1
  
d1316 2
a1317 1
  else if (table->opcode_rule->word_nr + 1 > table->parent->nr_prefetched_words)
d1325 1
a1325 1
      ASSERT(table->parent->opcode != NULL);
d1340 1
a1340 2
	      table->opcode->nr_opcodes,
	      table->nr_entries);
d1352 1
a1352 2
		    entry->insn->format_name,
		    entry->insn->name);
d1367 1
a1367 2
		  entry->opcode_nr,
		  entry->nr_insns);
d1373 1
a1373 1
	
d1407 3
a1409 3
		  print_gen_entry_path (table->opcode_rule->line, entry, notify);
		  for (duplicate = entry->combined_next;
		       duplicate != NULL;
d1418 1
a1418 2
			      l->insn->format_name,
			      l->insn->name);
d1424 4
a1427 3
	  notify (NULL, ": combine - word %d, bits [%d..%d] in [%d..%d], opcodes %d, entries %d, unique %d\n",
		  table->opcode->word_nr,
		  i2target (options.hi_bit_nr, table->opcode->first),
d1431 1
a1431 3
		  table->opcode->nr_opcodes,
		  table->nr_entries,
		  nr_unique);
d1434 1
a1434 1
	
d1438 16
a1453 14
      gen_entry *entry;
      for (entry = table->entries; entry != NULL; entry = entry->sibling)
	{
	  if (entry->combined_parent == NULL)
	    {
	      if (insn_list_cmp (table->insns, entry->insns) == 0)
		{
		  print_gen_entry_path (table->opcode_rule->line, table, warning);
		  warning (NULL, ": Applying rule just copied all instructions\n");
		  print_gen_entry_insns (entry, warning, "Copied", NULL);
		  error (NULL, "");
		}
	    }
	}    
d1473 1
a1473 4
		  gen_entry_insert_insn (table,
					 table->top->isa->illegal_insn,
					 table->opcode->word_nr,
					 0, /* nr_prefetched_words == 0 for invalid */
d1485 1
a1485 1
             its self.  Fix this */
d1500 1
a1500 1
    for (entry = table->entries; entry != NULL; entry =  entry->sibling)
d1526 1
a1526 4
make_gen_semantics_list (lf *file,
			 gen_entry *entry,
			 int depth,
			 void *data)
d1528 1
a1528 1
  gen_table *gen = (gen_table*) data;
d1558 6
a1563 8
      gen_entry_traverse_tree (NULL,
			       entry->table,
			       1, /* depth */
			       NULL, /* start-handler */
			       make_gen_semantics_list, /* leaf-handler */
			       NULL, /* end-handler */
			       gen); /* data */
  }
d1574 1
a1574 3
		   opcode_field *field,
		   char *suffix,
		   int levels)
d1577 11
a1587 10
  if (levels && field != NULL) {
    lf_indent (file, +1);
    lf_printf (file, "\n(first %d)", field->first);
    lf_printf (file, "\n(last %d)", field->last);
    lf_printf (file, "\n(nr_opcodes %d)", field->nr_opcodes);
    lf_printf (file, "\n(is_boolean %d)", field->is_boolean);
    lf_printf (file, "\n(boolean_constant %d)", field->boolean_constant);
    dump_opcode_field(file, "\n(parent ", field->parent, ")", levels - 1);
    lf_indent (file, -1);
  }
d1594 1
a1594 4
		  char *prefix,
		  opcode_bits *bits,
		  char *suffix,
		  int levels)
d1597 1
a1597 1
  
d1613 1
a1613 4
dump_insn_list (lf *file,
		char *prefix,
		insn_list *entry,
		char *suffix)
d1617 7
a1623 6
  if (entry != NULL) {
    lf_indent (file, +1);
    dump_insn_entry (file, "\n(insn ", entry->insn, ")");
    lf_printf (file, "\n(next 0x%lx)", (long) entry->next);
    lf_indent (file, -1);
  }
d1630 2
a1631 3
			       char *prefix,
			       insn_list *entry,
			       char *suffix)
d1645 1
a1645 4
		char *prefix,
		gen_entry *table,
		char *suffix,
		int levels)
d1650 2
a1651 1
  if (levels && table != NULL) {
d1653 17
a1669 14
    lf_indent (file, +1);
    lf_printf (file, "\n(opcode_nr %d)", table->opcode_nr);
    lf_printf (file, "\n(word_nr %d)", table->word_nr);
    dump_opcode_bits (file, "\n(expanded_bits ", table->expanded_bits, ")", -1);
    lf_printf (file, "\n(nr_insns %d)", table->nr_insns);
    dump_insn_word_entry_list_entries (file, "\n(insns ", table->insns, ")");
    dump_decode_rule (file, "\n(opcode_rule ", table->opcode_rule, ")");
    dump_opcode_field (file, "\n(opcode ", table->opcode, ")", 0);
    lf_printf (file, "\n(nr_entries %d)", table->nr_entries);
    dump_gen_entry (file, "\n(entries ", table->entries, ")", table->nr_entries);
    dump_gen_entry (file, "\n(sibling ", table->sibling, ")", levels - 1);
    dump_gen_entry (file, "\n(parent ", table->parent, ")", 0);
    lf_indent (file, -1);
  }
d1675 1
a1675 4
	       char *prefix,
	       gen_list *entry,
	       char *suffix,
	       int levels)
d1689 1
a1689 4
		char *prefix,
		gen_table *gen,
		char *suffix,
		int levels)
d1702 1
a1702 2
main (int argc,
      char **argv)
d1710 2
a1711 1
    error (NULL, "Usage: insn <filter-in> <hi-bit-nr> <insn-bit-size> <widths> <decode-table> <insn-table>\n");
d1717 4
a1720 4
  options.hi_bit_nr = a2i(argv[2]);
  options.insn_bit_size = a2i(argv[3]);
  options.insn_specifying_widths = a2i(argv[4]);
  ASSERT(options.hi_bit_nr < options.insn_bit_size);
@


1.3
log
@* gen.c (gen_entry_expand_opcode): Initialize ``value'' to -1 and
``t'' to NULL.
* igen.c (main): Add default case to switch.
* gen-icache.c (print_icache_extraction): Ditto.
@
text
@d1 1
a1 1
/*  This file is part of the program psim.
d3 1
a3 1
    Copyright (C) 1994-1997, Andrew Cagney <cagney@@highland.com.au>
d5 18
a22 15
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
    */
@


1.3.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1 1
a1 1
/* The IGEN simulator generator for GDB, the GNU Debugger.
d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d5 15
a19 18
   Contributed by Andrew Cagney.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d33 4
a36 1
sub_val (insn_uint val, int val_last_pos, int first_pos, int last_pos)
d39 1
a39 1
	  & (((insn_uint) 1 << (last_pos - first_pos + 1)) - 1));
d43 4
a46 1
update_depth (lf *file, gen_entry *entry, int depth, void *data)
d48 1
a48 1
  int *max_depth = (int *) data;
d58 7
a64 3
  gen_entry_traverse_tree (NULL, table, 1, NULL,	/*start */
			   update_depth, NULL,	/*end */
			   &depth);	/* data */
d70 3
a72 1
print_gen_entry_path (line_ref *line, gen_entry *table, error_func *print)
d91 2
a92 1
		       char *first_message, char *next_message)
d101 4
a104 1
      print (NULL, ": %s.%s %s\n", insn->format_name, insn->name, message);
d118 1
a118 1
	return 0;		/* all previous fields the same */
d120 1
a120 1
	return -1;		/* left shorter than right */
d122 4
a125 2
	return +1;		/* left longer than right */
      for (bit_nr = 0; bit_nr < options.insn_bit_size; bit_nr++)
d138 2
a139 3
		    l->bit[bit_nr]->field->conditions->test ==
		    insn_field_cond_eq ? "=" : "!",
		    l->bit[bit_nr]->field->conditions->string,
d141 1
a141 2
		    r->bit[bit_nr]->field->conditions->test ==
		    insn_field_cond_eq ? "=" : "!",
d144 1
a144 2
	      && r->bit[bit_nr]->field->conditions->test ==
	      insn_field_cond_eq)
d146 2
a147 4
	      if (l->bit[bit_nr]->field->conditions->type ==
		  insn_field_cond_field
		  && r->bit[bit_nr]->field->conditions->type ==
		  insn_field_cond_field)
d151 1
a151 2
				    r->bit[bit_nr]->field->conditions->
				    string);
d157 1
a157 2
	      if (l->bit[bit_nr]->field->conditions->type ==
		  insn_field_cond_field)
d159 1
a159 2
	      if (r->bit[bit_nr]->field->conditions->type ==
		  insn_field_cond_field)
d162 2
a163 2
	         already have been handled because such fields are converted
	         into normal constant fields. */
d167 1
a167 1
	    return +1;		/* left = only */
d169 1
a169 1
	    return -1;		/* right = only */
d186 1
a186 1
	return 0;		/* all previous fields the same */
d188 1
a188 1
	return -1;		/* left shorter than right */
d190 4
a193 2
	return +1;		/* left longer than right */
      for (bit_nr = 0; bit_nr < options.insn_bit_size; bit_nr++)
d211 2
a212 1
opcode_bit_cmp (opcode_bits *l, opcode_bits *r)
d215 1
a215 1
    return 0;			/* all previous bits the same */
d217 1
a217 1
    return -1;			/* left shorter than right */
d219 1
a219 1
    return +1;			/* left longer than right */
d222 1
a222 1
    return +1;			/* left has more significant word */
d224 1
a224 1
    return -1;			/* right has more significant word */
d227 1
a227 1
    return +1;			/* left as more significant bit */
d229 1
a229 1
    return -1;			/* right as more significant bit */
d232 1
a232 1
    return +1;			/* left as less bits */
d234 1
a234 1
    return -1;			/* right as less bits */
d246 2
a247 1
opcode_bits_cmp (opcode_bits *l, opcode_bits *r)
d253 1
a253 1
	return 0;		/* all previous bits the same */
d267 3
a269 1
		 int last, insn_field_entry *field, opcode_field *opcode)
d277 1
a277 1

d286 2
a287 1
				  old_bits->field, old_bits->opcode);
d291 1
a291 1
	  if (cmp < 0)		/* new < new_list */
d313 1
a313 1
name_cmp (const char *l, const char *r)
d325 1
a325 2
typedef enum
{
d328 1
a328 2
}
duplicate_insn_actions;
d333 1
a333 1
		  insn_entry * insn,
d365 11
a375 29
      if (duplicate_action == merge_duplicate_insns)
	{
	  /* key#4: If we're going to merge duplicates, also sort
	     according to the format_name.  Two instructions with
	     identical decode patterns, but different names, are
	     considered different when merging.  Duplicates are only
	     important when creating a decode table (implied by
	     report_duplicate_insns) as such a table only has the
	     instruction's bit code as a way of differentiating
	     between instructions.  */
	  int cmp = name_cmp (insn->format_name,
			      (*cur_insn_ptr)->insn->format_name);
	  if (cmp < 0)
	    break;
	  else if (cmp > 0)
	    continue;
	}

      if (duplicate_action == merge_duplicate_insns)
	{
	  /* key#5: If we're going to merge duplicates, also sort
	     according to the name.  See comment above for
	     format_name.  */
	  int cmp = name_cmp (insn->name, (*cur_insn_ptr)->insn->name);
	  if (cmp < 0)
	    break;
	  else if (cmp > 0)
	    continue;
	}
a391 9
	  if (options.trace.insn_insertion)
	    {
	      notify ((*cur_insn_ptr)->insn->line,
		      "%s.%s: insert merge %s.%s\n",
		      (*cur_insn_ptr)->insn->format_name,
		      (*cur_insn_ptr)->insn->name,
		      insn->format_name,
		      insn->name);
	    }
d409 1
a409 1

a412 7
    if (options.trace.insn_insertion)
      {
	notify (insn->line,
		"%s.%s: insert new\n",
		insn->format_name,
		insn->name);
      }
d424 1
a424 1

d435 4
a438 3
			 gen_entry_handler * start,
			 gen_entry_handler * leaf,
			 gen_entry_handler * end, void *data)
d441 2
a442 2

  ASSERT (table !=NULL);
d446 1
a446 1

d453 3
a455 1
  for (entry = table->entries; entry != NULL; entry = entry->sibling)
d482 3
a484 1
make_table (insn_table *isa, decode_table *rules, model_entry *model)
d498 6
a503 3
	  insn_list_insert (&entry->table->insns, &entry->table->nr_insns, insn, NULL,	/* expanded_bits - none yet */
			    NULL,	/* opcodes - none yet */
			    0,	/* nr_prefetched_words - none yet */
d513 2
a514 1
make_gen_tables (insn_table *isa, decode_table *rules)
d528 3
a530 1
      for (model = isa->model->models; model != NULL; model = model->next)
d545 2
a546 2


d550 1
a550 2
typedef enum
{
d555 1
a555 2
}
constant_field_types;
d558 2
a559 1
insn_field_is_constant (insn_field * field, decode_table *rule)
d573 1
a573 1
      return field_is_not_constant;	/* never constant */
d593 3
a595 1
insns_bit_useless (insn_list *insns, decode_table *rule, int bit_nr)
d599 1
a599 1
  int is_useless = 1;		/* cleared if something actually found */
d625 3
a627 3
	         between all instructions.  The first time through the
	         value is saved, the second time through (if the
	         values differ) it is marked as useful. */
d684 1
a684 1
		     eliminates the value then the compare is useful */
d690 2
a691 1
			   condition != NULL; condition = condition->next)
d702 1
a702 1
				       current value */
d709 1
a709 1
				       current value */
d734 2
a735 1
			     decode_table *rule, int string_only)
d751 1
a751 1
	curr_opcode.first++;
d758 1
a758 1
	curr_opcode.last--;
d769 1
a769 1

d771 1
a771 1

d776 5
a780 9
		 ||
		 (insn_field_is_constant (fields->bit[new_opcode.first], rule)
		  != field_constant_string)) && (string_only
						 ||
						 (insn_field_is_constant
						  (fields->
						   bit[new_opcode.first],
						   rule) ==
						  field_is_not_constant)))
d786 8
a793 8
      ASSERT (new_opcode.first > rule->last
	      || (string_only
		  && insn_field_is_constant (fields->bit[new_opcode.first],
					     rule) == field_constant_string)
	      || (!string_only
		  && insn_field_is_constant (fields->bit[new_opcode.first],
					     rule)));

d798 2
a799 2
		 || insn_field_is_constant (fields->bit[new_opcode.last],
					    rule) != field_constant_string)
d801 2
a802 2
		 || !insn_field_is_constant (fields->bit[new_opcode.last],
					     rule)))
d808 8
a815 8
      ASSERT (new_opcode.last < rule->first
	      || (string_only
		  && insn_field_is_constant (fields->bit[new_opcode.last],
					     rule) == field_constant_string)
	      || (!string_only
		  && insn_field_is_constant (fields->bit[new_opcode.last],
					     rule)));

d817 1
a817 1
         interesting fields within this instruction */
d824 1
a824 1

d839 2
a840 1
  if (!string_only && curr_opcode.first > rule->force_first)
d844 2
a845 1
  if (!string_only && curr_opcode.last < rule->force_last)
d852 2
a853 1
  if (string_only && rule->force_last == options.insn_bit_size - 1)
d883 1
a883 1
		       insn_entry * old_insn,
d886 2
a887 1
		       int new_opcode_nr, opcode_bits *new_bits)
d890 1
a890 1

d896 1
a896 1

d915 6
a920 3
  insn_list_insert (&(*entry)->insns, &(*entry)->nr_insns, old_insn, NULL,	/* expanded_bits - only in final list */
		    NULL,	/* opcodes - only in final list */
		    new_nr_prefetched_words,	/* for this table */
d927 4
a930 2
			 insn_entry * instruction,
			 int bit_nr, int opcode_nr, opcode_bits *bits)
d943 1
a943 2
		  (table->opcode_rule->
		   with_duplicates ? " (duplicated)" : ""));
d949 2
a950 1
				 table->nr_prefetched_words, opcode_nr, bits);
d956 2
a957 1
				 table->nr_prefetched_words, opcode_nr, NULL);
d965 2
a966 1
		      ? field->last : table->opcode->last);
d968 2
a969 1
		       ? field->first : table->opcode->first);
d976 2
a977 1
	    val = sub_val (field->val_int, field->last, first_pos, last_pos);
d980 2
a981 1
				     ((opcode_nr << width) | val), bits);
d989 2
a990 1
				       ((opcode_nr << width)), bits);
d994 3
a996 1
		int last_val = (table->opcode->is_boolean ? 2 : (1 << width));
d1000 1
a1000 1
		       (by a conditional) in some way */
d1011 2
a1012 3
			      int value =
				sub_val (condition->value, field->last,
					 first_pos, last_pos);
d1032 7
a1038 5
			         conditional by looking back through
			         the previously defined bits for one
			         that covers the designated
			         conditional field */
			      for (bit = bits; bit != NULL; bit = bit->next)
d1040 1
a1040 2
				  if (bit->field->word_nr ==
				      condition->field->word_nr
d1045 1
a1045 1
				         the conditional field's value */
d1047 2
a1048 4
						       condition->field->
						       first,
						       condition->field->
						       last);
d1052 1
a1052 1
			         through this and previous tables */
d1056 2
a1057 1
				       t->parent != NULL; t = t->parent)
d1059 3
a1061 6
				      if (t->parent->opcode->word_nr ==
					  condition->field->word_nr
					  && t->parent->opcode->first <=
					  condition->field->first
					  && t->parent->opcode->last >=
					  condition->field->last)
d1064 2
a1065 2
					     specified the condition
					     field's value */
d1067 3
a1069 6
					     from the opcode */
					  value =
					    sub_val (t->opcode_nr,
						     t->parent->opcode->last,
						     condition->field->first,
						     condition->field->last);
d1071 6
a1076 11
					     a conditonal field
					     refering to another field */
					  ASSERT ((condition->field->first -
						   condition->field->last) ==
						  (first_pos - last_pos));
					  printf
					    ("value=%d, opcode_nr=%d, last=%d, [%d..%d]\n",
					     value, t->opcode_nr,
					     t->parent->opcode->last,
					     condition->field->first,
					     condition->field->last);
d1102 2
a1103 2
			   information if the entry is not going to
			   later be combined */
d1108 2
a1109 2
						     ((opcode_nr << width) |
						      val), bits);
d1113 4
a1116 5
			    opcode_bits *new_bits =
			      new_opcode_bits (bits, val,
					       first_pos, last_pos,
					       field,
					       table->opcode);
d1119 2
a1120 2
						     ((opcode_nr << width) |
						      val), new_bits);
d1131 2
a1132 1
gen_entry_insert_expanding (gen_entry *table, insn_entry * instruction)
d1136 3
a1138 1
			   table->opcode->first, 0, table->expanded_bits);
d1143 2
a1144 1
insns_match_format_names (insn_list *insns, filter *format_names)
d1151 2
a1152 2
	  if (i->insn->format_name != NULL
	      && !filter_is_member (format_names, i->insn->format_name))
d1160 2
a1161 1
table_matches_path (gen_entry *table, decode_path_list *paths)
d1187 2
a1188 1
insns_match_conditions (insn_list *insns, decode_cond *conditions)
d1208 2
a1209 1
		       == cond->value[bit_nr]) == !cond->is_equal)
d1219 2
a1220 1
insns_match_nr_words (insn_list *insns, int nr_words)
d1232 2
a1233 1
insn_list_cmp (insn_list *l, insn_list *r)
d1245 1
a1245 1
	return -1;		/* somewhat arbitrary at present */
d1262 2
a1263 2
  ASSERT (table->nr_insns >= 1);

d1266 2
a1267 1
       opcode_rule != NULL; opcode_rule = opcode_rule->next)
d1281 1
a1281 1
	     apply a rule to a single instruction */
d1287 2
a1288 2
	     not duplicating the semantic functions that this table
	     calls */
d1291 1
a1291 3
      else
	if (!insns_match_format_names
	    (table->insns, opcode_rule->format_names))
d1303 1
a1303 2
      else
	if (!insns_match_conditions (table->insns, opcode_rule->conditions))
d1310 5
a1314 4
	  table->opcode = gen_entry_find_opcode_field (table->insns,
						       opcode_rule,
						       table->nr_insns == 1	/*string-only */
	    );
d1328 1
a1328 1

d1348 1
a1348 2
  else if (table->opcode_rule->word_nr + 1 >
	   table->parent->nr_prefetched_words)
d1356 1
a1356 1
      ASSERT (table->parent->opcode != NULL);
d1371 2
a1372 1
	      table->opcode->nr_opcodes, table->nr_entries);
d1384 2
a1385 1
		    entry->insn->format_name, entry->insn->name);
d1400 2
a1401 1
		  entry->opcode_nr, entry->nr_insns);
d1407 1
a1407 1

d1441 3
a1443 3
		  print_gen_entry_path (table->opcode_rule->line, entry,
					notify);
		  for (duplicate = entry->combined_next; duplicate != NULL;
d1452 2
a1453 1
			      l->insn->format_name, l->insn->name);
d1459 3
a1461 4
	  notify (NULL,
		  ": combine - word %d, bits [%d..%d] in [%d..%d], opcodes %d, entries %d, unique %d\n",
		  table->opcode->word_nr, i2target (options.hi_bit_nr,
						    table->opcode->first),
d1465 3
a1467 1
		  table->opcode->nr_opcodes, table->nr_entries, nr_unique);
d1470 1
a1470 1

d1474 14
a1487 16
    gen_entry *entry;
    for (entry = table->entries; entry != NULL; entry = entry->sibling)
      {
	if (entry->combined_parent == NULL)
	  {
	    if (insn_list_cmp (table->insns, entry->insns) == 0)
	      {
		print_gen_entry_path (table->opcode_rule->line, table,
				      warning);
		warning (NULL,
			 ": Applying rule just copied all instructions\n");
		print_gen_entry_insns (entry, warning, "Copied", NULL);
		error (NULL, "");
	      }
	  }
      }
d1507 4
a1510 1
		  gen_entry_insert_insn (table, table->top->isa->illegal_insn, table->opcode->word_nr, 0,	/* nr_prefetched_words == 0 for invalid */
d1522 1
a1522 1
	     its self.  Fix this */
d1537 1
a1537 1
    for (entry = table->entries; entry != NULL; entry = entry->sibling)
d1563 4
a1566 1
make_gen_semantics_list (lf *file, gen_entry *entry, int depth, void *data)
d1568 1
a1568 1
  gen_table *gen = (gen_table *) data;
d1598 8
a1605 6
      gen_entry_traverse_tree (NULL, entry->table, 1,	/* depth */
			       NULL,	/* start-handler */
			       make_gen_semantics_list,	/* leaf-handler */
			       NULL,	/* end-handler */
			       gen);	/* data */
    }
d1616 3
a1618 1
		   opcode_field *field, char *suffix, int levels)
d1621 10
a1630 11
  if (levels && field != NULL)
    {
      lf_indent (file, +1);
      lf_printf (file, "\n(first %d)", field->first);
      lf_printf (file, "\n(last %d)", field->last);
      lf_printf (file, "\n(nr_opcodes %d)", field->nr_opcodes);
      lf_printf (file, "\n(is_boolean %d)", field->is_boolean);
      lf_printf (file, "\n(boolean_constant %d)", field->boolean_constant);
      dump_opcode_field (file, "\n(parent ", field->parent, ")", levels - 1);
      lf_indent (file, -1);
    }
d1637 4
a1640 1
		  char *prefix, opcode_bits *bits, char *suffix, int levels)
d1643 1
a1643 1

d1659 4
a1662 1
dump_insn_list (lf *file, char *prefix, insn_list *entry, char *suffix)
d1666 6
a1671 7
  if (entry != NULL)
    {
      lf_indent (file, +1);
      dump_insn_entry (file, "\n(insn ", entry->insn, ")");
      lf_printf (file, "\n(next 0x%lx)", (long) entry->next);
      lf_indent (file, -1);
    }
d1678 3
a1680 2
				   char *prefix,
				   insn_list *entry, char *suffix)
d1694 4
a1697 1
		char *prefix, gen_entry *table, char *suffix, int levels)
d1702 1
a1702 2
  if (levels && table !=NULL)
    {
d1704 14
a1717 17
      lf_indent (file, +1);
      lf_printf (file, "\n(opcode_nr %d)", table->opcode_nr);
      lf_printf (file, "\n(word_nr %d)", table->word_nr);
      dump_opcode_bits (file, "\n(expanded_bits ", table->expanded_bits, ")",
			-1);
      lf_printf (file, "\n(nr_insns %d)", table->nr_insns);
      dump_insn_word_entry_list_entries (file, "\n(insns ", table->insns,
					 ")");
      dump_decode_rule (file, "\n(opcode_rule ", table->opcode_rule, ")");
      dump_opcode_field (file, "\n(opcode ", table->opcode, ")", 0);
      lf_printf (file, "\n(nr_entries %d)", table->nr_entries);
      dump_gen_entry (file, "\n(entries ", table->entries, ")",
		      table->nr_entries);
      dump_gen_entry (file, "\n(sibling ", table->sibling, ")", levels - 1);
      dump_gen_entry (file, "\n(parent ", table->parent, ")", 0);
      lf_indent (file, -1);
    }
d1723 4
a1726 1
	       char *prefix, gen_list *entry, char *suffix, int levels)
d1740 4
a1743 1
		char *prefix, gen_table *gen, char *suffix, int levels)
d1756 2
a1757 1
main (int argc, char **argv)
d1765 1
a1765 2
    error (NULL,
	   "Usage: insn <filter-in> <hi-bit-nr> <insn-bit-size> <widths> <decode-table> <insn-table>\n");
d1771 4
a1774 4
  options.hi_bit_nr = a2i (argv[2]);
  options.insn_bit_size = a2i (argv[3]);
  options.insn_specifying_widths = a2i (argv[4]);
  ASSERT (options.hi_bit_nr < options.insn_bit_size);
@


1.3.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d1 1
a1 1
/* The IGEN simulator generator for GDB, the GNU Debugger.
d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d5 15
a19 18
   Contributed by Andrew Cagney.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d33 4
a36 1
sub_val (insn_uint val, int val_last_pos, int first_pos, int last_pos)
d39 1
a39 1
	  & (((insn_uint) 1 << (last_pos - first_pos + 1)) - 1));
d43 4
a46 1
update_depth (lf *file, gen_entry *entry, int depth, void *data)
d48 1
a48 1
  int *max_depth = (int *) data;
d58 7
a64 3
  gen_entry_traverse_tree (NULL, table, 1, NULL,	/*start */
			   update_depth, NULL,	/*end */
			   &depth);	/* data */
d70 3
a72 1
print_gen_entry_path (line_ref *line, gen_entry *table, error_func *print)
d91 2
a92 1
		       char *first_message, char *next_message)
d101 4
a104 1
      print (NULL, ": %s.%s %s\n", insn->format_name, insn->name, message);
d118 1
a118 1
	return 0;		/* all previous fields the same */
d120 1
a120 1
	return -1;		/* left shorter than right */
d122 4
a125 2
	return +1;		/* left longer than right */
      for (bit_nr = 0; bit_nr < options.insn_bit_size; bit_nr++)
d138 2
a139 3
		    l->bit[bit_nr]->field->conditions->test ==
		    insn_field_cond_eq ? "=" : "!",
		    l->bit[bit_nr]->field->conditions->string,
d141 1
a141 2
		    r->bit[bit_nr]->field->conditions->test ==
		    insn_field_cond_eq ? "=" : "!",
d144 1
a144 2
	      && r->bit[bit_nr]->field->conditions->test ==
	      insn_field_cond_eq)
d146 2
a147 4
	      if (l->bit[bit_nr]->field->conditions->type ==
		  insn_field_cond_field
		  && r->bit[bit_nr]->field->conditions->type ==
		  insn_field_cond_field)
d151 1
a151 2
				    r->bit[bit_nr]->field->conditions->
				    string);
d157 1
a157 2
	      if (l->bit[bit_nr]->field->conditions->type ==
		  insn_field_cond_field)
d159 1
a159 2
	      if (r->bit[bit_nr]->field->conditions->type ==
		  insn_field_cond_field)
d162 2
a163 2
	         already have been handled because such fields are converted
	         into normal constant fields. */
d167 1
a167 1
	    return +1;		/* left = only */
d169 1
a169 1
	    return -1;		/* right = only */
d186 1
a186 1
	return 0;		/* all previous fields the same */
d188 1
a188 1
	return -1;		/* left shorter than right */
d190 4
a193 2
	return +1;		/* left longer than right */
      for (bit_nr = 0; bit_nr < options.insn_bit_size; bit_nr++)
d211 2
a212 1
opcode_bit_cmp (opcode_bits *l, opcode_bits *r)
d215 1
a215 1
    return 0;			/* all previous bits the same */
d217 1
a217 1
    return -1;			/* left shorter than right */
d219 1
a219 1
    return +1;			/* left longer than right */
d222 1
a222 1
    return +1;			/* left has more significant word */
d224 1
a224 1
    return -1;			/* right has more significant word */
d227 1
a227 1
    return +1;			/* left as more significant bit */
d229 1
a229 1
    return -1;			/* right as more significant bit */
d232 1
a232 1
    return +1;			/* left as less bits */
d234 1
a234 1
    return -1;			/* right as less bits */
d246 2
a247 1
opcode_bits_cmp (opcode_bits *l, opcode_bits *r)
d253 1
a253 1
	return 0;		/* all previous bits the same */
d267 3
a269 1
		 int last, insn_field_entry *field, opcode_field *opcode)
d277 1
a277 1

d286 2
a287 1
				  old_bits->field, old_bits->opcode);
d291 1
a291 1
	  if (cmp < 0)		/* new < new_list */
d313 1
a313 1
name_cmp (const char *l, const char *r)
d325 1
a325 2
typedef enum
{
d328 1
a328 2
}
duplicate_insn_actions;
d333 1
a333 1
		  insn_entry * insn,
d365 11
a375 29
      if (duplicate_action == merge_duplicate_insns)
	{
	  /* key#4: If we're going to merge duplicates, also sort
	     according to the format_name.  Two instructions with
	     identical decode patterns, but different names, are
	     considered different when merging.  Duplicates are only
	     important when creating a decode table (implied by
	     report_duplicate_insns) as such a table only has the
	     instruction's bit code as a way of differentiating
	     between instructions.  */
	  int cmp = name_cmp (insn->format_name,
			      (*cur_insn_ptr)->insn->format_name);
	  if (cmp < 0)
	    break;
	  else if (cmp > 0)
	    continue;
	}

      if (duplicate_action == merge_duplicate_insns)
	{
	  /* key#5: If we're going to merge duplicates, also sort
	     according to the name.  See comment above for
	     format_name.  */
	  int cmp = name_cmp (insn->name, (*cur_insn_ptr)->insn->name);
	  if (cmp < 0)
	    break;
	  else if (cmp > 0)
	    continue;
	}
a391 9
	  if (options.trace.insn_insertion)
	    {
	      notify ((*cur_insn_ptr)->insn->line,
		      "%s.%s: insert merge %s.%s\n",
		      (*cur_insn_ptr)->insn->format_name,
		      (*cur_insn_ptr)->insn->name,
		      insn->format_name,
		      insn->name);
	    }
d409 1
a409 1

a412 7
    if (options.trace.insn_insertion)
      {
	notify (insn->line,
		"%s.%s: insert new\n",
		insn->format_name,
		insn->name);
      }
d424 1
a424 1

d435 4
a438 3
			 gen_entry_handler * start,
			 gen_entry_handler * leaf,
			 gen_entry_handler * end, void *data)
d441 2
a442 2

  ASSERT (table !=NULL);
d446 1
a446 1

d453 3
a455 1
  for (entry = table->entries; entry != NULL; entry = entry->sibling)
d482 3
a484 1
make_table (insn_table *isa, decode_table *rules, model_entry *model)
d498 6
a503 3
	  insn_list_insert (&entry->table->insns, &entry->table->nr_insns, insn, NULL,	/* expanded_bits - none yet */
			    NULL,	/* opcodes - none yet */
			    0,	/* nr_prefetched_words - none yet */
d513 2
a514 1
make_gen_tables (insn_table *isa, decode_table *rules)
d528 3
a530 1
      for (model = isa->model->models; model != NULL; model = model->next)
d545 2
a546 2


d550 1
a550 2
typedef enum
{
d555 1
a555 2
}
constant_field_types;
d558 2
a559 1
insn_field_is_constant (insn_field * field, decode_table *rule)
d573 1
a573 1
      return field_is_not_constant;	/* never constant */
d593 3
a595 1
insns_bit_useless (insn_list *insns, decode_table *rule, int bit_nr)
d599 1
a599 1
  int is_useless = 1;		/* cleared if something actually found */
d625 3
a627 3
	         between all instructions.  The first time through the
	         value is saved, the second time through (if the
	         values differ) it is marked as useful. */
d684 1
a684 1
		     eliminates the value then the compare is useful */
d690 2
a691 1
			   condition != NULL; condition = condition->next)
d702 1
a702 1
				       current value */
d709 1
a709 1
				       current value */
d734 2
a735 1
			     decode_table *rule, int string_only)
d751 1
a751 1
	curr_opcode.first++;
d758 1
a758 1
	curr_opcode.last--;
d769 1
a769 1

d771 1
a771 1

d776 5
a780 9
		 ||
		 (insn_field_is_constant (fields->bit[new_opcode.first], rule)
		  != field_constant_string)) && (string_only
						 ||
						 (insn_field_is_constant
						  (fields->
						   bit[new_opcode.first],
						   rule) ==
						  field_is_not_constant)))
d786 8
a793 8
      ASSERT (new_opcode.first > rule->last
	      || (string_only
		  && insn_field_is_constant (fields->bit[new_opcode.first],
					     rule) == field_constant_string)
	      || (!string_only
		  && insn_field_is_constant (fields->bit[new_opcode.first],
					     rule)));

d798 2
a799 2
		 || insn_field_is_constant (fields->bit[new_opcode.last],
					    rule) != field_constant_string)
d801 2
a802 2
		 || !insn_field_is_constant (fields->bit[new_opcode.last],
					     rule)))
d808 8
a815 8
      ASSERT (new_opcode.last < rule->first
	      || (string_only
		  && insn_field_is_constant (fields->bit[new_opcode.last],
					     rule) == field_constant_string)
	      || (!string_only
		  && insn_field_is_constant (fields->bit[new_opcode.last],
					     rule)));

d817 1
a817 1
         interesting fields within this instruction */
d824 1
a824 1

d839 2
a840 1
  if (!string_only && curr_opcode.first > rule->force_first)
d844 2
a845 1
  if (!string_only && curr_opcode.last < rule->force_last)
d852 2
a853 1
  if (string_only && rule->force_last == options.insn_bit_size - 1)
d883 1
a883 1
		       insn_entry * old_insn,
d886 2
a887 1
		       int new_opcode_nr, opcode_bits *new_bits)
d890 1
a890 1

d896 1
a896 1

d915 6
a920 3
  insn_list_insert (&(*entry)->insns, &(*entry)->nr_insns, old_insn, NULL,	/* expanded_bits - only in final list */
		    NULL,	/* opcodes - only in final list */
		    new_nr_prefetched_words,	/* for this table */
d927 4
a930 2
			 insn_entry * instruction,
			 int bit_nr, int opcode_nr, opcode_bits *bits)
d943 1
a943 2
		  (table->opcode_rule->
		   with_duplicates ? " (duplicated)" : ""));
d949 2
a950 1
				 table->nr_prefetched_words, opcode_nr, bits);
d956 2
a957 1
				 table->nr_prefetched_words, opcode_nr, NULL);
d965 2
a966 1
		      ? field->last : table->opcode->last);
d968 2
a969 1
		       ? field->first : table->opcode->first);
d976 2
a977 1
	    val = sub_val (field->val_int, field->last, first_pos, last_pos);
d980 2
a981 1
				     ((opcode_nr << width) | val), bits);
d989 2
a990 1
				       ((opcode_nr << width)), bits);
d994 3
a996 1
		int last_val = (table->opcode->is_boolean ? 2 : (1 << width));
d1000 1
a1000 1
		       (by a conditional) in some way */
d1011 2
a1012 3
			      int value =
				sub_val (condition->value, field->last,
					 first_pos, last_pos);
d1032 7
a1038 5
			         conditional by looking back through
			         the previously defined bits for one
			         that covers the designated
			         conditional field */
			      for (bit = bits; bit != NULL; bit = bit->next)
d1040 1
a1040 2
				  if (bit->field->word_nr ==
				      condition->field->word_nr
d1045 1
a1045 1
				         the conditional field's value */
d1047 2
a1048 4
						       condition->field->
						       first,
						       condition->field->
						       last);
d1052 1
a1052 1
			         through this and previous tables */
d1056 2
a1057 1
				       t->parent != NULL; t = t->parent)
d1059 3
a1061 6
				      if (t->parent->opcode->word_nr ==
					  condition->field->word_nr
					  && t->parent->opcode->first <=
					  condition->field->first
					  && t->parent->opcode->last >=
					  condition->field->last)
d1064 2
a1065 2
					     specified the condition
					     field's value */
d1067 3
a1069 6
					     from the opcode */
					  value =
					    sub_val (t->opcode_nr,
						     t->parent->opcode->last,
						     condition->field->first,
						     condition->field->last);
d1071 6
a1076 11
					     a conditonal field
					     refering to another field */
					  ASSERT ((condition->field->first -
						   condition->field->last) ==
						  (first_pos - last_pos));
					  printf
					    ("value=%d, opcode_nr=%d, last=%d, [%d..%d]\n",
					     value, t->opcode_nr,
					     t->parent->opcode->last,
					     condition->field->first,
					     condition->field->last);
d1102 2
a1103 2
			   information if the entry is not going to
			   later be combined */
d1108 2
a1109 2
						     ((opcode_nr << width) |
						      val), bits);
d1113 4
a1116 5
			    opcode_bits *new_bits =
			      new_opcode_bits (bits, val,
					       first_pos, last_pos,
					       field,
					       table->opcode);
d1119 2
a1120 2
						     ((opcode_nr << width) |
						      val), new_bits);
d1131 2
a1132 1
gen_entry_insert_expanding (gen_entry *table, insn_entry * instruction)
d1136 3
a1138 1
			   table->opcode->first, 0, table->expanded_bits);
d1143 2
a1144 1
insns_match_format_names (insn_list *insns, filter *format_names)
d1151 2
a1152 2
	  if (i->insn->format_name != NULL
	      && !filter_is_member (format_names, i->insn->format_name))
d1160 2
a1161 1
table_matches_path (gen_entry *table, decode_path_list *paths)
d1187 2
a1188 1
insns_match_conditions (insn_list *insns, decode_cond *conditions)
d1208 2
a1209 1
		       == cond->value[bit_nr]) == !cond->is_equal)
d1219 2
a1220 1
insns_match_nr_words (insn_list *insns, int nr_words)
d1232 2
a1233 1
insn_list_cmp (insn_list *l, insn_list *r)
d1245 1
a1245 1
	return -1;		/* somewhat arbitrary at present */
d1262 2
a1263 2
  ASSERT (table->nr_insns >= 1);

d1266 2
a1267 1
       opcode_rule != NULL; opcode_rule = opcode_rule->next)
d1281 1
a1281 1
	     apply a rule to a single instruction */
d1287 2
a1288 2
	     not duplicating the semantic functions that this table
	     calls */
d1291 1
a1291 3
      else
	if (!insns_match_format_names
	    (table->insns, opcode_rule->format_names))
d1303 1
a1303 2
      else
	if (!insns_match_conditions (table->insns, opcode_rule->conditions))
d1310 5
a1314 4
	  table->opcode = gen_entry_find_opcode_field (table->insns,
						       opcode_rule,
						       table->nr_insns == 1	/*string-only */
	    );
d1328 1
a1328 1

d1348 1
a1348 2
  else if (table->opcode_rule->word_nr + 1 >
	   table->parent->nr_prefetched_words)
d1356 1
a1356 1
      ASSERT (table->parent->opcode != NULL);
d1371 2
a1372 1
	      table->opcode->nr_opcodes, table->nr_entries);
d1384 2
a1385 1
		    entry->insn->format_name, entry->insn->name);
d1400 2
a1401 1
		  entry->opcode_nr, entry->nr_insns);
d1407 1
a1407 1

d1441 3
a1443 3
		  print_gen_entry_path (table->opcode_rule->line, entry,
					notify);
		  for (duplicate = entry->combined_next; duplicate != NULL;
d1452 2
a1453 1
			      l->insn->format_name, l->insn->name);
d1459 3
a1461 4
	  notify (NULL,
		  ": combine - word %d, bits [%d..%d] in [%d..%d], opcodes %d, entries %d, unique %d\n",
		  table->opcode->word_nr, i2target (options.hi_bit_nr,
						    table->opcode->first),
d1465 3
a1467 1
		  table->opcode->nr_opcodes, table->nr_entries, nr_unique);
d1470 1
a1470 1

d1474 14
a1487 16
    gen_entry *entry;
    for (entry = table->entries; entry != NULL; entry = entry->sibling)
      {
	if (entry->combined_parent == NULL)
	  {
	    if (insn_list_cmp (table->insns, entry->insns) == 0)
	      {
		print_gen_entry_path (table->opcode_rule->line, table,
				      warning);
		warning (NULL,
			 ": Applying rule just copied all instructions\n");
		print_gen_entry_insns (entry, warning, "Copied", NULL);
		error (NULL, "");
	      }
	  }
      }
d1507 4
a1510 1
		  gen_entry_insert_insn (table, table->top->isa->illegal_insn, table->opcode->word_nr, 0,	/* nr_prefetched_words == 0 for invalid */
d1522 1
a1522 1
	     its self.  Fix this */
d1537 1
a1537 1
    for (entry = table->entries; entry != NULL; entry = entry->sibling)
d1563 4
a1566 1
make_gen_semantics_list (lf *file, gen_entry *entry, int depth, void *data)
d1568 1
a1568 1
  gen_table *gen = (gen_table *) data;
d1598 8
a1605 6
      gen_entry_traverse_tree (NULL, entry->table, 1,	/* depth */
			       NULL,	/* start-handler */
			       make_gen_semantics_list,	/* leaf-handler */
			       NULL,	/* end-handler */
			       gen);	/* data */
    }
d1616 3
a1618 1
		   opcode_field *field, char *suffix, int levels)
d1621 10
a1630 11
  if (levels && field != NULL)
    {
      lf_indent (file, +1);
      lf_printf (file, "\n(first %d)", field->first);
      lf_printf (file, "\n(last %d)", field->last);
      lf_printf (file, "\n(nr_opcodes %d)", field->nr_opcodes);
      lf_printf (file, "\n(is_boolean %d)", field->is_boolean);
      lf_printf (file, "\n(boolean_constant %d)", field->boolean_constant);
      dump_opcode_field (file, "\n(parent ", field->parent, ")", levels - 1);
      lf_indent (file, -1);
    }
d1637 4
a1640 1
		  char *prefix, opcode_bits *bits, char *suffix, int levels)
d1643 1
a1643 1

d1659 4
a1662 1
dump_insn_list (lf *file, char *prefix, insn_list *entry, char *suffix)
d1666 6
a1671 7
  if (entry != NULL)
    {
      lf_indent (file, +1);
      dump_insn_entry (file, "\n(insn ", entry->insn, ")");
      lf_printf (file, "\n(next 0x%lx)", (long) entry->next);
      lf_indent (file, -1);
    }
d1678 3
a1680 2
				   char *prefix,
				   insn_list *entry, char *suffix)
d1694 4
a1697 1
		char *prefix, gen_entry *table, char *suffix, int levels)
d1702 1
a1702 2
  if (levels && table !=NULL)
    {
d1704 14
a1717 17
      lf_indent (file, +1);
      lf_printf (file, "\n(opcode_nr %d)", table->opcode_nr);
      lf_printf (file, "\n(word_nr %d)", table->word_nr);
      dump_opcode_bits (file, "\n(expanded_bits ", table->expanded_bits, ")",
			-1);
      lf_printf (file, "\n(nr_insns %d)", table->nr_insns);
      dump_insn_word_entry_list_entries (file, "\n(insns ", table->insns,
					 ")");
      dump_decode_rule (file, "\n(opcode_rule ", table->opcode_rule, ")");
      dump_opcode_field (file, "\n(opcode ", table->opcode, ")", 0);
      lf_printf (file, "\n(nr_entries %d)", table->nr_entries);
      dump_gen_entry (file, "\n(entries ", table->entries, ")",
		      table->nr_entries);
      dump_gen_entry (file, "\n(sibling ", table->sibling, ")", levels - 1);
      dump_gen_entry (file, "\n(parent ", table->parent, ")", 0);
      lf_indent (file, -1);
    }
d1723 4
a1726 1
	       char *prefix, gen_list *entry, char *suffix, int levels)
d1740 4
a1743 1
		char *prefix, gen_table *gen, char *suffix, int levels)
d1756 2
a1757 1
main (int argc, char **argv)
d1765 1
a1765 2
    error (NULL,
	   "Usage: insn <filter-in> <hi-bit-nr> <insn-bit-size> <widths> <decode-table> <insn-table>\n");
d1771 4
a1774 4
  options.hi_bit_nr = a2i (argv[2]);
  options.insn_bit_size = a2i (argv[3]);
  options.insn_specifying_widths = a2i (argv[4]);
  ASSERT (options.hi_bit_nr < options.insn_bit_size);
@


1.3.6.1
log
@Import all the copyright and indent changes from the mainline (also
richards's tweak).
@
text
@d1 1
a1 1
/* The IGEN simulator generator for GDB, the GNU Debugger.
d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d5 15
a19 18
   Contributed by Andrew Cagney.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d33 4
a36 1
sub_val (insn_uint val, int val_last_pos, int first_pos, int last_pos)
d39 1
a39 1
	  & (((insn_uint) 1 << (last_pos - first_pos + 1)) - 1));
d43 4
a46 1
update_depth (lf *file, gen_entry *entry, int depth, void *data)
d48 1
a48 1
  int *max_depth = (int *) data;
d58 7
a64 3
  gen_entry_traverse_tree (NULL, table, 1, NULL,	/*start */
			   update_depth, NULL,	/*end */
			   &depth);	/* data */
d70 3
a72 1
print_gen_entry_path (line_ref *line, gen_entry *table, error_func *print)
d91 2
a92 1
		       char *first_message, char *next_message)
d101 4
a104 1
      print (NULL, ": %s.%s %s\n", insn->format_name, insn->name, message);
d118 1
a118 1
	return 0;		/* all previous fields the same */
d120 1
a120 1
	return -1;		/* left shorter than right */
d122 4
a125 2
	return +1;		/* left longer than right */
      for (bit_nr = 0; bit_nr < options.insn_bit_size; bit_nr++)
d138 2
a139 3
		    l->bit[bit_nr]->field->conditions->test ==
		    insn_field_cond_eq ? "=" : "!",
		    l->bit[bit_nr]->field->conditions->string,
d141 1
a141 2
		    r->bit[bit_nr]->field->conditions->test ==
		    insn_field_cond_eq ? "=" : "!",
d144 1
a144 2
	      && r->bit[bit_nr]->field->conditions->test ==
	      insn_field_cond_eq)
d146 2
a147 4
	      if (l->bit[bit_nr]->field->conditions->type ==
		  insn_field_cond_field
		  && r->bit[bit_nr]->field->conditions->type ==
		  insn_field_cond_field)
d151 1
a151 2
				    r->bit[bit_nr]->field->conditions->
				    string);
d157 1
a157 2
	      if (l->bit[bit_nr]->field->conditions->type ==
		  insn_field_cond_field)
d159 1
a159 2
	      if (r->bit[bit_nr]->field->conditions->type ==
		  insn_field_cond_field)
d162 2
a163 2
	         already have been handled because such fields are converted
	         into normal constant fields. */
d167 1
a167 1
	    return +1;		/* left = only */
d169 1
a169 1
	    return -1;		/* right = only */
d186 1
a186 1
	return 0;		/* all previous fields the same */
d188 1
a188 1
	return -1;		/* left shorter than right */
d190 4
a193 2
	return +1;		/* left longer than right */
      for (bit_nr = 0; bit_nr < options.insn_bit_size; bit_nr++)
d211 2
a212 1
opcode_bit_cmp (opcode_bits *l, opcode_bits *r)
d215 1
a215 1
    return 0;			/* all previous bits the same */
d217 1
a217 1
    return -1;			/* left shorter than right */
d219 1
a219 1
    return +1;			/* left longer than right */
d222 1
a222 1
    return +1;			/* left has more significant word */
d224 1
a224 1
    return -1;			/* right has more significant word */
d227 1
a227 1
    return +1;			/* left as more significant bit */
d229 1
a229 1
    return -1;			/* right as more significant bit */
d232 1
a232 1
    return +1;			/* left as less bits */
d234 1
a234 1
    return -1;			/* right as less bits */
d246 2
a247 1
opcode_bits_cmp (opcode_bits *l, opcode_bits *r)
d253 1
a253 1
	return 0;		/* all previous bits the same */
d267 3
a269 1
		 int last, insn_field_entry *field, opcode_field *opcode)
d277 1
a277 1

d286 2
a287 1
				  old_bits->field, old_bits->opcode);
d291 1
a291 1
	  if (cmp < 0)		/* new < new_list */
d325 1
a325 2
typedef enum
{
d328 1
a328 2
}
duplicate_insn_actions;
d333 1
a333 1
		  insn_entry * insn,
d366 6
a371 8
         identical instructions have unique format-names, then the
         instructions are different.  This is because the
         format-name's use is overloaded, it not only indicates the
         format name but also provides a unique semantic name for the
         function.  */
      cmp =
	format_name_cmp (insn->format_name,
			 (*cur_insn_ptr)->insn->format_name);
d409 1
a409 1

d424 1
a424 1

d435 4
a438 3
			 gen_entry_handler * start,
			 gen_entry_handler * leaf,
			 gen_entry_handler * end, void *data)
d441 2
a442 2

  ASSERT (table !=NULL);
d446 1
a446 1

d453 3
a455 1
  for (entry = table->entries; entry != NULL; entry = entry->sibling)
d482 3
a484 1
make_table (insn_table *isa, decode_table *rules, model_entry *model)
d498 6
a503 3
	  insn_list_insert (&entry->table->insns, &entry->table->nr_insns, insn, NULL,	/* expanded_bits - none yet */
			    NULL,	/* opcodes - none yet */
			    0,	/* nr_prefetched_words - none yet */
d513 2
a514 1
make_gen_tables (insn_table *isa, decode_table *rules)
d528 3
a530 1
      for (model = isa->model->models; model != NULL; model = model->next)
d545 2
a546 2


d550 1
a550 2
typedef enum
{
d555 1
a555 2
}
constant_field_types;
d558 2
a559 1
insn_field_is_constant (insn_field * field, decode_table *rule)
d573 1
a573 1
      return field_is_not_constant;	/* never constant */
d593 3
a595 1
insns_bit_useless (insn_list *insns, decode_table *rule, int bit_nr)
d599 1
a599 1
  int is_useless = 1;		/* cleared if something actually found */
d625 3
a627 3
	         between all instructions.  The first time through the
	         value is saved, the second time through (if the
	         values differ) it is marked as useful. */
d684 1
a684 1
		     eliminates the value then the compare is useful */
d690 2
a691 1
			   condition != NULL; condition = condition->next)
d702 1
a702 1
				       current value */
d709 1
a709 1
				       current value */
d734 2
a735 1
			     decode_table *rule, int string_only)
d751 1
a751 1
	curr_opcode.first++;
d758 1
a758 1
	curr_opcode.last--;
d769 1
a769 1

d771 1
a771 1

d776 5
a780 9
		 ||
		 (insn_field_is_constant (fields->bit[new_opcode.first], rule)
		  != field_constant_string)) && (string_only
						 ||
						 (insn_field_is_constant
						  (fields->
						   bit[new_opcode.first],
						   rule) ==
						  field_is_not_constant)))
d786 8
a793 8
      ASSERT (new_opcode.first > rule->last
	      || (string_only
		  && insn_field_is_constant (fields->bit[new_opcode.first],
					     rule) == field_constant_string)
	      || (!string_only
		  && insn_field_is_constant (fields->bit[new_opcode.first],
					     rule)));

d798 2
a799 2
		 || insn_field_is_constant (fields->bit[new_opcode.last],
					    rule) != field_constant_string)
d801 2
a802 2
		 || !insn_field_is_constant (fields->bit[new_opcode.last],
					     rule)))
d808 8
a815 8
      ASSERT (new_opcode.last < rule->first
	      || (string_only
		  && insn_field_is_constant (fields->bit[new_opcode.last],
					     rule) == field_constant_string)
	      || (!string_only
		  && insn_field_is_constant (fields->bit[new_opcode.last],
					     rule)));

d817 1
a817 1
         interesting fields within this instruction */
d824 1
a824 1

d839 2
a840 1
  if (!string_only && curr_opcode.first > rule->force_first)
d844 2
a845 1
  if (!string_only && curr_opcode.last < rule->force_last)
d852 2
a853 1
  if (string_only && rule->force_last == options.insn_bit_size - 1)
d883 1
a883 1
		       insn_entry * old_insn,
d886 2
a887 1
		       int new_opcode_nr, opcode_bits *new_bits)
d890 1
a890 1

d896 1
a896 1

d915 6
a920 3
  insn_list_insert (&(*entry)->insns, &(*entry)->nr_insns, old_insn, NULL,	/* expanded_bits - only in final list */
		    NULL,	/* opcodes - only in final list */
		    new_nr_prefetched_words,	/* for this table */
d927 4
a930 2
			 insn_entry * instruction,
			 int bit_nr, int opcode_nr, opcode_bits *bits)
d943 1
a943 2
		  (table->opcode_rule->
		   with_duplicates ? " (duplicated)" : ""));
d949 2
a950 1
				 table->nr_prefetched_words, opcode_nr, bits);
d956 2
a957 1
				 table->nr_prefetched_words, opcode_nr, NULL);
d965 2
a966 1
		      ? field->last : table->opcode->last);
d968 2
a969 1
		       ? field->first : table->opcode->first);
d976 2
a977 1
	    val = sub_val (field->val_int, field->last, first_pos, last_pos);
d980 2
a981 1
				     ((opcode_nr << width) | val), bits);
d989 2
a990 1
				       ((opcode_nr << width)), bits);
d994 3
a996 1
		int last_val = (table->opcode->is_boolean ? 2 : (1 << width));
d1000 1
a1000 1
		       (by a conditional) in some way */
d1011 2
a1012 3
			      int value =
				sub_val (condition->value, field->last,
					 first_pos, last_pos);
d1032 7
a1038 5
			         conditional by looking back through
			         the previously defined bits for one
			         that covers the designated
			         conditional field */
			      for (bit = bits; bit != NULL; bit = bit->next)
d1040 1
a1040 2
				  if (bit->field->word_nr ==
				      condition->field->word_nr
d1045 1
a1045 1
				         the conditional field's value */
d1047 2
a1048 4
						       condition->field->
						       first,
						       condition->field->
						       last);
d1052 1
a1052 1
			         through this and previous tables */
d1056 2
a1057 1
				       t->parent != NULL; t = t->parent)
d1059 3
a1061 6
				      if (t->parent->opcode->word_nr ==
					  condition->field->word_nr
					  && t->parent->opcode->first <=
					  condition->field->first
					  && t->parent->opcode->last >=
					  condition->field->last)
d1064 2
a1065 2
					     specified the condition
					     field's value */
d1067 3
a1069 6
					     from the opcode */
					  value =
					    sub_val (t->opcode_nr,
						     t->parent->opcode->last,
						     condition->field->first,
						     condition->field->last);
d1071 6
a1076 11
					     a conditonal field
					     refering to another field */
					  ASSERT ((condition->field->first -
						   condition->field->last) ==
						  (first_pos - last_pos));
					  printf
					    ("value=%d, opcode_nr=%d, last=%d, [%d..%d]\n",
					     value, t->opcode_nr,
					     t->parent->opcode->last,
					     condition->field->first,
					     condition->field->last);
d1102 2
a1103 2
			   information if the entry is not going to
			   later be combined */
d1108 2
a1109 2
						     ((opcode_nr << width) |
						      val), bits);
d1113 4
a1116 5
			    opcode_bits *new_bits =
			      new_opcode_bits (bits, val,
					       first_pos, last_pos,
					       field,
					       table->opcode);
d1119 2
a1120 2
						     ((opcode_nr << width) |
						      val), new_bits);
d1131 2
a1132 1
gen_entry_insert_expanding (gen_entry *table, insn_entry * instruction)
d1136 3
a1138 1
			   table->opcode->first, 0, table->expanded_bits);
d1143 2
a1144 1
insns_match_format_names (insn_list *insns, filter *format_names)
d1151 2
a1152 2
	  if (i->insn->format_name != NULL
	      && !filter_is_member (format_names, i->insn->format_name))
d1160 2
a1161 1
table_matches_path (gen_entry *table, decode_path_list *paths)
d1187 2
a1188 1
insns_match_conditions (insn_list *insns, decode_cond *conditions)
d1208 2
a1209 1
		       == cond->value[bit_nr]) == !cond->is_equal)
d1219 2
a1220 1
insns_match_nr_words (insn_list *insns, int nr_words)
d1232 2
a1233 1
insn_list_cmp (insn_list *l, insn_list *r)
d1245 1
a1245 1
	return -1;		/* somewhat arbitrary at present */
d1262 2
a1263 2
  ASSERT (table->nr_insns >= 1);

d1266 2
a1267 1
       opcode_rule != NULL; opcode_rule = opcode_rule->next)
d1281 1
a1281 1
	     apply a rule to a single instruction */
d1287 2
a1288 2
	     not duplicating the semantic functions that this table
	     calls */
d1291 1
a1291 3
      else
	if (!insns_match_format_names
	    (table->insns, opcode_rule->format_names))
d1303 1
a1303 2
      else
	if (!insns_match_conditions (table->insns, opcode_rule->conditions))
d1310 5
a1314 4
	  table->opcode = gen_entry_find_opcode_field (table->insns,
						       opcode_rule,
						       table->nr_insns == 1	/*string-only */
	    );
d1328 1
a1328 1

d1348 1
a1348 2
  else if (table->opcode_rule->word_nr + 1 >
	   table->parent->nr_prefetched_words)
d1356 1
a1356 1
      ASSERT (table->parent->opcode != NULL);
d1371 2
a1372 1
	      table->opcode->nr_opcodes, table->nr_entries);
d1384 2
a1385 1
		    entry->insn->format_name, entry->insn->name);
d1400 2
a1401 1
		  entry->opcode_nr, entry->nr_insns);
d1407 1
a1407 1

d1441 3
a1443 3
		  print_gen_entry_path (table->opcode_rule->line, entry,
					notify);
		  for (duplicate = entry->combined_next; duplicate != NULL;
d1452 2
a1453 1
			      l->insn->format_name, l->insn->name);
d1459 3
a1461 4
	  notify (NULL,
		  ": combine - word %d, bits [%d..%d] in [%d..%d], opcodes %d, entries %d, unique %d\n",
		  table->opcode->word_nr, i2target (options.hi_bit_nr,
						    table->opcode->first),
d1465 3
a1467 1
		  table->opcode->nr_opcodes, table->nr_entries, nr_unique);
d1470 1
a1470 1

d1474 14
a1487 16
    gen_entry *entry;
    for (entry = table->entries; entry != NULL; entry = entry->sibling)
      {
	if (entry->combined_parent == NULL)
	  {
	    if (insn_list_cmp (table->insns, entry->insns) == 0)
	      {
		print_gen_entry_path (table->opcode_rule->line, table,
				      warning);
		warning (NULL,
			 ": Applying rule just copied all instructions\n");
		print_gen_entry_insns (entry, warning, "Copied", NULL);
		error (NULL, "");
	      }
	  }
      }
d1507 4
a1510 1
		  gen_entry_insert_insn (table, table->top->isa->illegal_insn, table->opcode->word_nr, 0,	/* nr_prefetched_words == 0 for invalid */
d1522 1
a1522 1
	     its self.  Fix this */
d1537 1
a1537 1
    for (entry = table->entries; entry != NULL; entry = entry->sibling)
d1563 4
a1566 1
make_gen_semantics_list (lf *file, gen_entry *entry, int depth, void *data)
d1568 1
a1568 1
  gen_table *gen = (gen_table *) data;
d1598 8
a1605 6
      gen_entry_traverse_tree (NULL, entry->table, 1,	/* depth */
			       NULL,	/* start-handler */
			       make_gen_semantics_list,	/* leaf-handler */
			       NULL,	/* end-handler */
			       gen);	/* data */
    }
d1616 3
a1618 1
		   opcode_field *field, char *suffix, int levels)
d1621 10
a1630 11
  if (levels && field != NULL)
    {
      lf_indent (file, +1);
      lf_printf (file, "\n(first %d)", field->first);
      lf_printf (file, "\n(last %d)", field->last);
      lf_printf (file, "\n(nr_opcodes %d)", field->nr_opcodes);
      lf_printf (file, "\n(is_boolean %d)", field->is_boolean);
      lf_printf (file, "\n(boolean_constant %d)", field->boolean_constant);
      dump_opcode_field (file, "\n(parent ", field->parent, ")", levels - 1);
      lf_indent (file, -1);
    }
d1637 4
a1640 1
		  char *prefix, opcode_bits *bits, char *suffix, int levels)
d1643 1
a1643 1

d1659 4
a1662 1
dump_insn_list (lf *file, char *prefix, insn_list *entry, char *suffix)
d1666 6
a1671 7
  if (entry != NULL)
    {
      lf_indent (file, +1);
      dump_insn_entry (file, "\n(insn ", entry->insn, ")");
      lf_printf (file, "\n(next 0x%lx)", (long) entry->next);
      lf_indent (file, -1);
    }
d1678 3
a1680 2
				   char *prefix,
				   insn_list *entry, char *suffix)
d1694 4
a1697 1
		char *prefix, gen_entry *table, char *suffix, int levels)
d1702 1
a1702 2
  if (levels && table !=NULL)
    {
d1704 14
a1717 17
      lf_indent (file, +1);
      lf_printf (file, "\n(opcode_nr %d)", table->opcode_nr);
      lf_printf (file, "\n(word_nr %d)", table->word_nr);
      dump_opcode_bits (file, "\n(expanded_bits ", table->expanded_bits, ")",
			-1);
      lf_printf (file, "\n(nr_insns %d)", table->nr_insns);
      dump_insn_word_entry_list_entries (file, "\n(insns ", table->insns,
					 ")");
      dump_decode_rule (file, "\n(opcode_rule ", table->opcode_rule, ")");
      dump_opcode_field (file, "\n(opcode ", table->opcode, ")", 0);
      lf_printf (file, "\n(nr_entries %d)", table->nr_entries);
      dump_gen_entry (file, "\n(entries ", table->entries, ")",
		      table->nr_entries);
      dump_gen_entry (file, "\n(sibling ", table->sibling, ")", levels - 1);
      dump_gen_entry (file, "\n(parent ", table->parent, ")", 0);
      lf_indent (file, -1);
    }
d1723 4
a1726 1
	       char *prefix, gen_list *entry, char *suffix, int levels)
d1740 4
a1743 1
		char *prefix, gen_table *gen, char *suffix, int levels)
d1756 2
a1757 1
main (int argc, char **argv)
d1765 1
a1765 2
    error (NULL,
	   "Usage: insn <filter-in> <hi-bit-nr> <insn-bit-size> <widths> <decode-table> <insn-table>\n");
d1771 4
a1774 4
  options.hi_bit_nr = a2i (argv[2]);
  options.insn_bit_size = a2i (argv[3]);
  options.insn_specifying_widths = a2i (argv[4]);
  ASSERT (options.hi_bit_nr < options.insn_bit_size);
@


1.2
log
@* gen.c (format_name_cmp): New function.
(insn_list_insert): Use the instruction field name as an
additional key.  Different field names indicate different
semantics.
@
text
@d1028 1
a1028 1
			      int value;
d1030 1
a1030 1
			      gen_entry *t;
@


1.2.4.1
log
@merge with trunk
@
text
@d1028 1
a1028 1
			      int value = -1;
d1030 1
a1030 1
			      gen_entry *t = NULL;
@


1.2.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d1028 1
a1028 1
			      int value = -1;
d1030 1
a1030 1
			      gen_entry *t = NULL;
@


1.1
log
@Initial revision
@
text
@d311 12
a322 1

d360 12
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@

