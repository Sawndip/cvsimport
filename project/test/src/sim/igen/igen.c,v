head	1.14;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.14
	gdb_7_6-2013-04-26-release:1.14
	gdb_7_6-branch:1.14.0.2
	gdb_7_6-2013-03-12-branchpoint:1.14
	gdb_7_5_1-2012-11-29-release:1.13
	gdb_7_5-2012-08-17-release:1.13
	gdb_7_5-branch:1.13.0.2
	gdb_7_5-2012-07-18-branchpoint:1.13
	gdb_7_4_1-2012-04-26-release:1.12.4.1
	gdb_7_4-2012-01-24-release:1.12.4.1
	gdb_7_4-branch:1.12.0.4
	gdb_7_4-2011-12-13-branchpoint:1.12
	gdb_7_3_1-2011-09-04-release:1.12
	gdb_7_3-2011-07-26-release:1.12
	gdb_7_3-branch:1.12.0.2
	gdb_7_3-2011-04-01-branchpoint:1.12
	gdb_7_2-2010-09-02-release:1.11
	gdb_7_2-branch:1.11.0.4
	gdb_7_2-2010-07-07-branchpoint:1.11
	gdb_7_1-2010-03-18-release:1.11
	gdb_7_1-branch:1.11.0.2
	gdb_7_1-2010-02-18-branchpoint:1.11
	gdb_7_0_1-2009-12-22-release:1.10
	gdb_7_0-2009-10-06-release:1.10
	gdb_7_0-branch:1.10.0.4
	gdb_7_0-2009-09-16-branchpoint:1.10
	arc-sim-20090309:1.9
	msnyder-checkpoint-072509-branch:1.10.0.2
	msnyder-checkpoint-072509-branchpoint:1.10
	arc-insight_6_8-branch:1.9.0.16
	arc-insight_6_8-branchpoint:1.9
	insight_6_8-branch:1.9.0.14
	insight_6_8-branchpoint:1.9
	reverse-20081226-branch:1.9.0.12
	reverse-20081226-branchpoint:1.9
	multiprocess-20081120-branch:1.9.0.10
	multiprocess-20081120-branchpoint:1.9
	reverse-20080930-branch:1.9.0.8
	reverse-20080930-branchpoint:1.9
	reverse-20080717-branch:1.9.0.6
	reverse-20080717-branchpoint:1.9
	msnyder-reverse-20080609-branch:1.9.0.4
	msnyder-reverse-20080609-branchpoint:1.9
	drow-reverse-20070409-branch:1.7.0.2
	drow-reverse-20070409-branchpoint:1.7
	gdb_6_8-2008-03-27-release:1.9
	gdb_6_8-branch:1.9.0.2
	gdb_6_8-2008-02-26-branchpoint:1.9
	gdb_6_7_1-2007-10-29-release:1.8
	gdb_6_7-2007-10-10-release:1.8
	gdb_6_7-branch:1.8.0.2
	gdb_6_7-2007-09-07-branchpoint:1.8
	insight_6_6-20070208-release:1.6
	gdb_6_6-2006-12-18-release:1.6
	gdb_6_6-branch:1.6.0.88
	gdb_6_6-2006-11-15-branchpoint:1.6
	insight_6_5-20061003-release:1.6
	gdb-csl-symbian-6_4_50_20060226-12:1.6
	gdb-csl-sourcerygxx-3_4_4-25:1.6
	nickrob-async-20060828-mergepoint:1.6
	gdb-csl-symbian-6_4_50_20060226-11:1.6
	gdb-csl-sourcerygxx-4_1-17:1.6
	gdb-csl-20060226-branch-local-2:1.6
	gdb-csl-sourcerygxx-4_1-14:1.6
	gdb-csl-sourcerygxx-4_1-13:1.6
	gdb-csl-sourcerygxx-4_1-12:1.6
	gdb-csl-sourcerygxx-3_4_4-21:1.6
	gdb_6_5-20060621-release:1.6
	gdb-csl-sourcerygxx-4_1-9:1.6
	gdb-csl-sourcerygxx-4_1-8:1.6
	gdb-csl-sourcerygxx-4_1-7:1.6
	gdb-csl-arm-2006q1-6:1.6
	gdb-csl-sourcerygxx-4_1-6:1.6
	gdb-csl-symbian-6_4_50_20060226-10:1.6
	gdb-csl-symbian-6_4_50_20060226-9:1.6
	gdb-csl-symbian-6_4_50_20060226-8:1.6
	gdb-csl-coldfire-4_1-11:1.6
	gdb-csl-sourcerygxx-3_4_4-19:1.6
	gdb-csl-coldfire-4_1-10:1.6
	gdb_6_5-branch:1.6.0.86
	gdb_6_5-2006-05-14-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-5:1.6
	nickrob-async-20060513-branch:1.6.0.84
	nickrob-async-20060513-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-4:1.6
	msnyder-reverse-20060502-branch:1.6.0.82
	msnyder-reverse-20060502-branchpoint:1.6
	gdb-csl-morpho-4_1-4:1.6
	gdb-csl-sourcerygxx-3_4_4-17:1.6
	readline_5_1-import-branch:1.6.0.80
	readline_5_1-import-branchpoint:1.6
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.6
	gdb-csl-symbian-20060226-branch:1.6.0.78
	gdb-csl-symbian-20060226-branchpoint:1.6
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.6
	msnyder-reverse-20060331-branch:1.6.0.76
	msnyder-reverse-20060331-branchpoint:1.6
	gdb-csl-available-20060303-branch:1.6.0.74
	gdb-csl-available-20060303-branchpoint:1.6
	gdb-csl-20060226-branch:1.6.0.72
	gdb-csl-20060226-branchpoint:1.6
	gdb_6_4-20051202-release:1.6
	msnyder-fork-checkpoint-branch:1.6.0.70
	msnyder-fork-checkpoint-branchpoint:1.6
	gdb-csl-gxxpro-6_3-branch:1.6.0.68
	gdb-csl-gxxpro-6_3-branchpoint:1.6
	gdb_6_4-branch:1.6.0.66
	gdb_6_4-2005-11-01-branchpoint:1.6
	gdb-csl-arm-20051020-branch:1.6.0.64
	gdb-csl-arm-20051020-branchpoint:1.6
	msnyder-tracepoint-checkpoint-branch:1.6.0.62
	msnyder-tracepoint-checkpoint-branchpoint:1.6
	gdb-csl-arm-20050325-2005-q1b:1.6
	gdb-csl-arm-20050325-2005-q1a:1.6
	csl-arm-20050325-branch:1.6.0.60
	csl-arm-20050325-branchpoint:1.6
	gdb_6_3-20041109-release:1.6
	gdb_6_3-branch:1.6.0.56
	gdb_6_3-20041019-branchpoint:1.6
	drow_intercu-merge-20040921:1.6
	drow_intercu-merge-20040915:1.6
	jimb-gdb_6_2-e500-branch:1.6.0.58
	jimb-gdb_6_2-e500-branchpoint:1.6
	gdb_6_2-20040730-release:1.6
	gdb_6_2-branch:1.6.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.6
	gdb_6_1_1-20040616-release:1.6
	gdb_6_1-2004-04-05-release:1.6
	drow_intercu-merge-20040402:1.6
	drow_intercu-merge-20040327:1.6
	ezannoni_pie-20040323-branch:1.6.0.52
	ezannoni_pie-20040323-branchpoint:1.6
	cagney_tramp-20040321-mergepoint:1.6
	cagney_tramp-20040309-branch:1.6.0.50
	cagney_tramp-20040309-branchpoint:1.6
	gdb_6_1-branch:1.6.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	drow_intercu-20040221-branch:1.6.0.46
	drow_intercu-20040221-branchpoint:1.6
	cagney_bfdfile-20040213-branch:1.6.0.44
	cagney_bfdfile-20040213-branchpoint:1.6
	drow-cplus-merge-20040208:1.6
	carlton_dictionary-20040126-merge:1.6
	cagney_bigcore-20040122-branch:1.6.0.42
	cagney_bigcore-20040122-branchpoint:1.6
	drow-cplus-merge-20040113:1.6
	drow-cplus-merge-20031224:1.6
	drow-cplus-merge-20031220:1.6
	carlton_dictionary-20031215-merge:1.6
	drow-cplus-merge-20031214:1.6
	carlton-dictionary-20031111-merge:1.6
	gdb_6_0-2003-10-04-release:1.6
	kettenis_sparc-20030918-branch:1.6.0.40
	kettenis_sparc-20030918-branchpoint:1.6
	carlton_dictionary-20030917-merge:1.6
	ezannoni_pie-20030916-branchpoint:1.6
	ezannoni_pie-20030916-branch:1.6.0.38
	cagney_x86i386-20030821-branch:1.6.0.36
	cagney_x86i386-20030821-branchpoint:1.6
	carlton_dictionary-20030805-merge:1.6
	carlton_dictionary-20030627-merge:1.6
	gdb_6_0-branch:1.6.0.34
	gdb_6_0-2003-06-23-branchpoint:1.6
	jimb-ppc64-linux-20030613-branch:1.6.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.6
	cagney_convert-20030606-branch:1.6.0.30
	cagney_convert-20030606-branchpoint:1.6
	cagney_writestrings-20030508-branch:1.6.0.28
	cagney_writestrings-20030508-branchpoint:1.6
	jimb-ppc64-linux-20030528-branch:1.6.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.6
	carlton_dictionary-20030523-merge:1.6
	cagney_fileio-20030521-branch:1.6.0.24
	cagney_fileio-20030521-branchpoint:1.6
	kettenis_i386newframe-20030517-mergepoint:1.6
	jimb-ppc64-linux-20030509-branch:1.6.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.6
	kettenis_i386newframe-20030504-mergepoint:1.6
	carlton_dictionary-20030430-merge:1.6
	kettenis_i386newframe-20030419-branch:1.6.0.20
	kettenis_i386newframe-20030419-branchpoint:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	kettenis_i386newframe-20030406-branch:1.6.0.18
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.16
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.14
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.12
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.6
	offbyone-20030313-branch:1.6.0.10
	offbyone-20030313-branchpoint:1.6
	kettenis-i386newframe-20030308-branch:1.6.0.8
	kettenis-i386newframe-20030308-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.6
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.6
	interps-20030202-branch:1.6.0.4
	interps-20030202-branchpoint:1.6
	cagney-unwind-20030108-branch:1.6.0.2
	cagney-unwind-20030108-branchpoint:1.6
	carlton_dictionary-20021223-merge:1.6
	gdb_5_3-2002-12-12-release:1.4.6.1
	carlton_dictionary-20021115-merge:1.4
	kseitz_interps-20021105-merge:1.4
	kseitz_interps-20021103-merge:1.4
	drow-cplus-merge-20021020:1.4
	drow-cplus-merge-20021025:1.4
	carlton_dictionary-20021025-merge:1.4
	carlton_dictionary-20021011-merge:1.4
	drow-cplus-branch:1.4.0.10
	drow-cplus-branchpoint:1.4
	kseitz_interps-20020930-merge:1.4
	carlton_dictionary-20020927-merge:1.4
	carlton_dictionary-branch:1.4.0.8
	carlton_dictionary-20020920-branchpoint:1.4
	gdb_5_3-branch:1.4.0.6
	gdb_5_3-2002-09-04-branchpoint:1.4
	kseitz_interps-20020829-merge:1.4
	cagney_sysregs-20020825-branch:1.4.0.4
	cagney_sysregs-20020825-branchpoint:1.4
	readline_4_3-import-branch:1.4.0.2
	readline_4_3-import-branchpoint:1.4
	gdb_5_2_1-2002-07-23-release:1.1.1.1
	kseitz_interps-20020528-branch:1.3.0.6
	kseitz_interps-20020528-branchpoint:1.3
	cagney_regbuf-20020515-branch:1.3.0.4
	cagney_regbuf-20020515-branchpoint:1.3
	jimb-macro-020506-branch:1.3.0.2
	jimb-macro-020506-branchpoint:1.3
	gdb_5_2-2002-04-29-release:1.1.1.1
	gdb_5_2-branch:1.1.1.1.0.14
	gdb_5_2-2002-03-03-branchpoint:1.1.1.1
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.12
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.10
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.8
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.14
date	2013.01.01.06.41.37;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2012.01.04.08.28.11;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2011.01.01.15.34.00;	author brobecke;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2010.01.01.10.03.30;	author brobecke;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.14.10.53.07;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2008.01.01.22.53.24;	author drow;	state Exp;
branches;
next	1.8;

1.8
date	2007.08.24.14.28.36;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.09.17.59.18;	author drow;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.22.04.20.49;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2002.11.22.04.09.40;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.17.21.44.06;	author cagney;	state Exp;
branches
	1.4.6.1
	1.4.8.1
	1.4.10.1;
next	1.3;

1.3
date	2002.05.01.23.26.31;	author cgd;	state Exp;
branches
	1.3.4.1
	1.3.6.1;
next	1.2;

1.2
date	2002.03.08.00.36.32;	author cgd;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.04;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.12.4.1
date	2012.01.06.04.54.49;	author brobecke;	state Exp;
branches;
next	;

1.4.6.1
date	2002.11.22.04.26.42;	author cagney;	state Exp;
branches;
next	;

1.4.8.1
date	2002.12.23.19.39.55;	author carlton;	state Exp;
branches;
next	;

1.4.10.1
date	2003.12.14.20.28.24;	author drow;	state Exp;
branches;
next	;

1.3.4.1
date	2002.06.21.15.48.51;	author cagney;	state Exp;
branches;
next	;

1.3.6.1
date	2002.06.20.01.39.55;	author kseitz;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.35.04;	author shebs;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* The IGEN simulator generator for GDB, the GNU Debugger.

   Copyright 2002-2013 Free Software Foundation, Inc.

   Contributed by Andrew Cagney.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */



#include <getopt.h>

#include "misc.h"
#include "lf.h"
#include "table.h"
#include "config.h"
#include "filter.h"

#include "igen.h"

#include "ld-insn.h"
#include "ld-decode.h"
#include "ld-cache.h"

#include "gen.h"

#include "gen-model.h"
#include "gen-icache.h"
#include "gen-itable.h"
#include "gen-idecode.h"
#include "gen-semantics.h"
#include "gen-engine.h"
#include "gen-support.h"
#include "gen-engine.h"


/****************************************************************/


/* Semantic functions */

int
print_semantic_function_formal (lf *file, int nr_prefetched_words)
{
  int nr = 0;
  int word_nr;
  if (options.gen.icache || nr_prefetched_words < 0)
    {
      nr += lf_printf (file, "SIM_DESC sd,\n");
      nr += lf_printf (file, "%sidecode_cache *cache_entry,\n",
		       options.module.global.prefix.l);
      nr += lf_printf (file, "%sinstruction_address cia",
		       options.module.global.prefix.l);
    }
  else if (options.gen.smp)
    {
      nr += lf_printf (file, "sim_cpu *cpu,\n");
      for (word_nr = 0; word_nr < nr_prefetched_words; word_nr++)
	{
	  nr += lf_printf (file, "%sinstruction_word instruction_%d,\n",
			   options.module.global.prefix.l, word_nr);
	}
      nr += lf_printf (file, "%sinstruction_address cia",
		       options.module.global.prefix.l);
    }
  else
    {
      nr += lf_printf (file, "SIM_DESC sd,\n");
      for (word_nr = 0; word_nr < nr_prefetched_words; word_nr++)
	{
	  nr += lf_printf (file, "%sinstruction_word instruction_%d,\n",
			   options.module.global.prefix.l, word_nr);
	}
      nr += lf_printf (file, "%sinstruction_address cia",
		       options.module.global.prefix.l);
    }
  return nr;
}

int
print_semantic_function_actual (lf *file, int nr_prefetched_words)
{
  int nr = 0;
  int word_nr;
  if (options.gen.icache || nr_prefetched_words < 0)
    {
      nr += lf_printf (file, "sd, cache_entry, cia");
    }
  else
    {
      if (options.gen.smp)
	nr += lf_printf (file, "cpu");
      else
	nr += lf_printf (file, "sd");
      for (word_nr = 0; word_nr < nr_prefetched_words; word_nr++)
	nr += lf_printf (file, ", instruction_%d", word_nr);
      nr += lf_printf (file, ", cia");
    }
  return nr;
}

int
print_semantic_function_type (lf *file)
{
  int nr = 0;
  nr += lf_printf (file, "%sinstruction_address",
		   options.module.global.prefix.l);
  return nr;
}


/* Idecode functions */

int
print_icache_function_formal (lf *file, int nr_prefetched_words)
{
  int nr = 0;
  int word_nr;
  if (options.gen.smp)
    nr += lf_printf (file, "sim_cpu *cpu,\n");
  else
    nr += lf_printf (file, "SIM_DESC sd,\n");
  for (word_nr = 0; word_nr < nr_prefetched_words; word_nr++)
    nr += lf_printf (file, " %sinstruction_word instruction_%d,\n",
		     options.module.global.prefix.l, word_nr);
  nr += lf_printf (file, " %sinstruction_address cia,\n",
		   options.module.global.prefix.l);
  nr += lf_printf (file, " %sidecode_cache *cache_entry",
		   options.module.global.prefix.l);
  return nr;
}

int
print_icache_function_actual (lf *file, int nr_prefetched_words)
{
  int nr = 0;
  int word_nr;
  if (options.gen.smp)
    nr += lf_printf (file, "cpu");
  else
    nr += lf_printf (file, "sd");
  for (word_nr = 0; word_nr < nr_prefetched_words; word_nr++)
    nr += lf_printf (file, ", instruction_%d", word_nr);
  nr += lf_printf (file, ", cia, cache_entry");
  return nr;
}

int
print_icache_function_type (lf *file)
{
  int nr;
  if (options.gen.semantic_icache)
    {
      nr = print_semantic_function_type (file);
    }
  else
    {
      nr = lf_printf (file, "%sidecode_semantic *",
		      options.module.global.prefix.l);
    }
  return nr;
}


/* Function names */

static int
print_opcode_bits (lf *file, opcode_bits *bits)
{
  int nr = 0;
  if (bits == NULL)
    return nr;
  nr += lf_putchr (file, '_');
  nr += lf_putstr (file, bits->field->val_string);
  if (bits->opcode->is_boolean && bits->value == 0)
    nr += lf_putint (file, bits->opcode->boolean_constant);
  else if (!bits->opcode->is_boolean)
    {
      if (bits->opcode->last < bits->field->last)
	nr +=
	  lf_putint (file,
		     bits->value << (bits->field->last - bits->opcode->last));
      else
	nr += lf_putint (file, bits->value);
    }
  nr += print_opcode_bits (file, bits->next);
  return nr;
}

static int
print_c_name (lf *file, const char *name)
{
  int nr = 0;
  const char *pos;
  for (pos = name; *pos != '\0'; pos++)
    {
      switch (*pos)
	{
	case '/':
	case '-':
	  break;
	case ' ':
	case '.':
	  nr += lf_putchr (file, '_');
	  break;
	default:
	  nr += lf_putchr (file, *pos);
	  break;
	}
    }
  return nr;
}

extern int
print_function_name (lf *file,
		     const char *basename,
		     const char *format_name,
		     const char *model_name,
		     opcode_bits *expanded_bits,
		     lf_function_name_prefixes prefix)
{
  int nr = 0;
  /* the prefix */
  switch (prefix)
    {
    case function_name_prefix_semantics:
      nr += lf_printf (file, "%s", options.module.semantics.prefix.l);
      nr += lf_printf (file, "semantic_");
      break;
    case function_name_prefix_idecode:
      nr += lf_printf (file, "%s", options.module.idecode.prefix.l);
      nr += lf_printf (file, "idecode_");
      break;
    case function_name_prefix_itable:
      nr += lf_printf (file, "%sitable_", options.module.itable.prefix.l);
      break;
    case function_name_prefix_icache:
      nr += lf_printf (file, "%s", options.module.icache.prefix.l);
      nr += lf_printf (file, "icache_");
      break;
    case function_name_prefix_engine:
      nr += lf_printf (file, "%s", options.module.engine.prefix.l);
      nr += lf_printf (file, "engine_");
    default:
      break;
    }

  if (model_name != NULL)
    {
      nr += print_c_name (file, model_name);
      nr += lf_printf (file, "_");
    }

  /* the function name */
  nr += print_c_name (file, basename);

  /* the format name if available */
  if (format_name != NULL)
    {
      nr += lf_printf (file, "_");
      nr += print_c_name (file, format_name);
    }

  /* the suffix */
  nr += print_opcode_bits (file, expanded_bits);

  return nr;
}


void
print_my_defines (lf *file,
		  const char *basename,
		  const char *format_name, opcode_bits *expanded_bits)
{
  /* #define MY_INDEX xxxxx */
  lf_indent_suppress (file);
  lf_printf (file, "#undef MY_INDEX\n");
  lf_indent_suppress (file);
  lf_printf (file, "#define MY_INDEX ");
  print_function_name (file,
		       basename, format_name, NULL,
		       NULL, function_name_prefix_itable);
  lf_printf (file, "\n");
  /* #define MY_PREFIX xxxxxx */
  lf_indent_suppress (file);
  lf_printf (file, "#undef ");
  print_function_name (file,
		       basename, format_name, NULL,
		       expanded_bits, function_name_prefix_none);
  lf_printf (file, "\n");
  lf_indent_suppress (file);
  lf_printf (file, "#undef MY_PREFIX\n");
  lf_indent_suppress (file);
  lf_printf (file, "#define MY_PREFIX ");
  print_function_name (file,
		       basename, format_name, NULL,
		       expanded_bits, function_name_prefix_none);
  lf_printf (file, "\n");
  /* #define MY_NAME xxxxxx */
  lf_indent_suppress (file);
  lf_indent_suppress (file);
  lf_printf (file, "#undef MY_NAME\n");
  lf_indent_suppress (file);
  lf_printf (file, "#define MY_NAME \"");
  print_function_name (file,
		       basename, format_name, NULL,
		       expanded_bits, function_name_prefix_none);
  lf_printf (file, "\"\n");
}


static int
print_itrace_prefix (lf *file)
{
  const char *prefix = "trace_prefix (";
  int indent = strlen (prefix);
  lf_printf (file, "%sSD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \\\n",
	     prefix);
  lf_indent (file, +indent);
  lf_printf (file, "%sitable[MY_INDEX].file, \\\n",
	     options.module.itable.prefix.l);
  lf_printf (file, "%sitable[MY_INDEX].line_nr, \\\n",
	     options.module.itable.prefix.l);
  lf_printf (file, "\"");
  return indent;
}


static void
print_itrace_format (lf *file, insn_mnemonic_entry *assembler)
{
  /* pass=1 is fmt string; pass=2 is arguments */
  int pass;
  /* print the format string */
  for (pass = 1; pass <= 2; pass++)
    {
      const char *chp = assembler->format;
      chp++;			/* skip the leading quote */
      /* write out the format/args */
      while (*chp != '\0')
	{
	  if (chp[0] == '\\' && (chp[1] == '<' || chp[1] == '>'))
	    {
	      if (pass == 1)
		lf_putchr (file, chp[1]);
	      chp += 2;
	    }
	  else if (chp[0] == '<' || chp[0] == '%')
	    {
	      /* parse [ "%" ... ] "<" [ func "#" ] param ">" */
	      const char *fmt;
	      const char *func;
	      int strlen_func;
	      const char *param;
	      int strlen_param;
	      /* the "%" ... "<" format */
	      fmt = chp;
	      while (chp[0] != '<' && chp[0] != '\0')
		chp++;
	      if (chp[0] != '<')
		error (assembler->line, "Missing `<' after `%%'\n");
	      chp++;
	      /* [ "func" # ] OR "param" */
	      func = chp;
	      param = chp;
	      while (chp[0] != '>' && chp[0] != '#' && chp[0] != '\0')
		chp++;
	      strlen_func = chp - func;
	      if (chp[0] == '#')
		{
		  chp++;
		  param = chp;
		  while (chp[0] != '>' && chp[0] != '\0')
		    chp++;
		}
	      strlen_param = chp - param;
	      if (chp[0] != '>')
		error (assembler->line,
		       "Missing closing `>' in assembler string\n");
	      chp++;
	      /* now process it */
	      if (pass == 2)
		lf_printf (file, ", \\\n");
	      if (strncmp (fmt, "<", 1) == 0)
		/* implicit long int format */
		{
		  if (pass == 1)
		    lf_printf (file, "%%ld");
		  else
		    {
		      lf_printf (file, "(long) ");
		      lf_write (file, param, strlen_param);
		    }
		}
	      else if (strncmp (fmt, "%<", 2) == 0)
		/* explicit format */
		{
		  if (pass == 1)
		    lf_printf (file, "%%");
		  else
		    lf_write (file, param, strlen_param);
		}
	      else if (strncmp (fmt, "%s<", 3) == 0)
		/* string format */
		{
		  if (pass == 1)
		    lf_printf (file, "%%s");
		  else
		    {
		      lf_printf (file, "%sstr_",
				 options.module.global.prefix.l);
		      lf_write (file, func, strlen_func);
		      lf_printf (file, " (SD_, ");
		      lf_write (file, param, strlen_param);
		      lf_printf (file, ")");
		    }
		}
	      else if (strncmp (fmt, "%lx<", 4) == 0)
		/* simple hex */
		{
		  if (pass == 1)
		    lf_printf (file, "%%lx");
		  else
		    {
		      lf_printf (file, "(unsigned long) ");
		      lf_write (file, param, strlen_param);
		    }
		}
	      else if (strncmp (fmt, "%#lx<", 5) == 0)
		/* simple hex with 0x prefix */
		{
		  if (pass == 1)
		    lf_printf (file, "%%#lx");
		  else
		    {
		      lf_printf (file, "(unsigned long) ");
		      lf_write (file, param, strlen_param);
		    }
		}
	      else if (strncmp (fmt, "%08lx<", 6) == 0)
		/* simple hex */
		{
		  if (pass == 1)
		    lf_printf (file, "%%08lx");
		  else
		    {
		      lf_printf (file, "(unsigned long) ");
		      lf_write (file, param, strlen_param);
		    }
		}
	      else
		error (assembler->line, "Unknown assembler string format\n");
	    }
	  else
	    {
	      if (pass == 1)
		lf_putchr (file, chp[0]);
	      chp += 1;
	    }
	}
    }
  lf_printf (file, ");\n");
}


void
print_itrace (lf *file, insn_entry * insn, int idecode)
{
  /* NB: Here we escape each EOLN. This is so that the the compiler
     treats a trace function call as a single line.  Consequently any
     errors in the line are refered back to the same igen assembler
     source line */
  const char *phase = (idecode) ? "DECODE" : "INSN";
  lf_printf (file, "\n");
  lf_indent_suppress (file);
  lf_printf (file, "#if defined (WITH_TRACE)\n");
  lf_printf (file, "/* generate a trace prefix if any tracing enabled */\n");
  lf_printf (file, "if (TRACE_ANY_P (CPU))\n");
  lf_printf (file, "  {\n");
  lf_indent (file, +4);
  {
    if (insn->mnemonics != NULL)
      {
	insn_mnemonic_entry *assembler = insn->mnemonics;
	int is_first = 1;
	do
	  {
	    if (assembler->condition != NULL)
	      {
		int indent;
		lf_printf (file, "%sif (%s)\n",
			   is_first ? "" : "else ", assembler->condition);
		lf_indent (file, +2);
		lf_print__line_ref (file, assembler->line);
		indent = print_itrace_prefix (file);
		print_itrace_format (file, assembler);
		lf_print__internal_ref (file);
		lf_indent (file, -indent);
		lf_indent (file, -2);
		if (assembler->next == NULL)
		  error (assembler->line,
			 "Missing final unconditional assembler\n");
	      }
	    else
	      {
		int indent;
		if (!is_first)
		  {
		    lf_printf (file, "else\n");
		    lf_indent (file, +2);
		  }
		lf_print__line_ref (file, assembler->line);
		indent = print_itrace_prefix (file);
		print_itrace_format (file, assembler);
		lf_print__internal_ref (file);
		lf_indent (file, -indent);
		if (!is_first)
		  lf_indent (file, -2);
		if (assembler->next != NULL)
		  error (assembler->line,
			 "Unconditional assembler is not last\n");
	      }
	    is_first = 0;
	    assembler = assembler->next;
	  }
	while (assembler != NULL);
      }
    else
      {
	int indent;
	lf_indent (file, +2);
	lf_print__line_ref (file, insn->line);
	indent = print_itrace_prefix (file);
	lf_printf (file, "%%s\", \\\n");
	lf_printf (file, "itable[MY_INDEX].name);\n");
	lf_print__internal_ref (file);
	lf_indent (file, -indent);
	lf_indent (file, -2);
      }
    lf_printf (file, "/* trace the instruction execution if enabled */\n");
    lf_printf (file, "if (TRACE_%s_P (CPU))\n", phase);
    lf_printf (file,
	       "  trace_generic (SD, CPU, TRACE_%s_IDX, \" %%s\", itable[MY_INDEX].name);\n",
	       phase);
  }
  lf_indent (file, -4);
  lf_printf (file, "  }\n");
  lf_indent_suppress (file);
  lf_printf (file, "#endif\n");
}


void
print_sim_engine_abort (lf *file, const char *message)
{
  lf_printf (file, "sim_engine_abort (SD, CPU, cia, ");
  lf_printf (file, "\"%s\"", message);
  lf_printf (file, ");\n");
}


void
print_include (lf *file, igen_module module)
{
  lf_printf (file, "#include \"%s%s.h\"\n", module.prefix.l, module.suffix.l);
}

void
print_include_inline (lf *file, igen_module module)
{
  lf_printf (file, "#if C_REVEALS_MODULE_P (%s_INLINE)\n", module.suffix.u);
  lf_printf (file, "#include \"%s%s.c\"\n", module.prefix.l, module.suffix.l);
  lf_printf (file, "#else\n");
  print_include (file, module);
  lf_printf (file, "#endif\n");
  lf_printf (file, "\n");
}

void
print_includes (lf *file)
{
  lf_printf (file, "\n");
  lf_printf (file, "#include \"sim-inline.c\"\n");
  lf_printf (file, "\n");
  print_include_inline (file, options.module.itable);
  print_include_inline (file, options.module.idecode);
  print_include_inline (file, options.module.support);
}


/****************************************************************/


static void
gen_semantics_h (lf *file, insn_list *semantics, int max_nr_words)
{
  int word_nr;
  insn_list *semantic;
  for (word_nr = -1; word_nr <= max_nr_words; word_nr++)
    {
      lf_printf (file, "typedef ");
      print_semantic_function_type (file);
      lf_printf (file, " %sidecode_semantic", options.module.global.prefix.l);
      if (word_nr >= 0)
	lf_printf (file, "_%d", word_nr);
      lf_printf (file, "\n(");
      lf_indent (file, +1);
      print_semantic_function_formal (file, word_nr);
      lf_indent (file, -1);
      lf_printf (file, ");\n");
      lf_printf (file, "\n");
    }
  switch (options.gen.code)
    {
    case generate_calls:
      for (semantic = semantics; semantic != NULL; semantic = semantic->next)
	{
	  /* Ignore any special/internal instructions */
	  if (semantic->insn->nr_words == 0)
	    continue;
	  print_semantic_declaration (file,
				      semantic->insn,
				      semantic->expanded_bits,
				      semantic->opcodes,
				      semantic->nr_prefetched_words);
	}
      break;
    case generate_jumps:
      lf_print__this_file_is_empty (file, "generating jumps");
      break;
    }
}


static void
gen_semantics_c (lf *file, insn_list *semantics, cache_entry *cache_rules)
{
  if (options.gen.code == generate_calls)
    {
      insn_list *semantic;
      print_includes (file);
      print_include (file, options.module.semantics);
      lf_printf (file, "\n");

      for (semantic = semantics; semantic != NULL; semantic = semantic->next)
	{
	  /* Ignore any special/internal instructions */
	  if (semantic->insn->nr_words == 0)
	    continue;
	  print_semantic_definition (file,
				     semantic->insn,
				     semantic->expanded_bits,
				     semantic->opcodes,
				     cache_rules,
				     semantic->nr_prefetched_words);
	}
    }
  else
    {
      lf_print__this_file_is_empty (file, "generating jump engine");
    }
}


/****************************************************************/


static void
gen_icache_h (lf *file,
	      insn_list *semantic,
	      function_entry * functions, int max_nr_words)
{
  int word_nr;
  for (word_nr = 0; word_nr <= max_nr_words; word_nr++)
    {
      lf_printf (file, "typedef ");
      print_icache_function_type (file);
      lf_printf (file, " %sidecode_icache_%d\n(",
		 options.module.global.prefix.l, word_nr);
      print_icache_function_formal (file, word_nr);
      lf_printf (file, ");\n");
      lf_printf (file, "\n");
    }
  if (options.gen.code == generate_calls && options.gen.icache)
    {
      function_entry_traverse (file, functions,
			       print_icache_internal_function_declaration,
			       NULL);
      while (semantic != NULL)
	{
	  print_icache_declaration (file,
				    semantic->insn,
				    semantic->expanded_bits,
				    semantic->opcodes,
				    semantic->nr_prefetched_words);
	  semantic = semantic->next;
	}
    }
  else
    {
      lf_print__this_file_is_empty (file, "generating jump engine");
    }
}

static void
gen_icache_c (lf *file,
	      insn_list *semantic,
	      function_entry * functions, cache_entry *cache_rules)
{
  /* output `internal' invalid/floating-point unavailable functions
     where needed */
  if (options.gen.code == generate_calls && options.gen.icache)
    {
      lf_printf (file, "\n");
      lf_printf (file, "#include \"cpu.h\"\n");
      lf_printf (file, "#include \"idecode.h\"\n");
      lf_printf (file, "#include \"semantics.h\"\n");
      lf_printf (file, "#include \"icache.h\"\n");
      lf_printf (file, "#include \"support.h\"\n");
      lf_printf (file, "\n");
      function_entry_traverse (file, functions,
			       print_icache_internal_function_definition,
			       NULL);
      lf_printf (file, "\n");
      while (semantic != NULL)
	{
	  print_icache_definition (file,
				   semantic->insn,
				   semantic->expanded_bits,
				   semantic->opcodes,
				   cache_rules,
				   semantic->nr_prefetched_words);
	  semantic = semantic->next;
	}
    }
  else
    {
      lf_print__this_file_is_empty (file, "generating jump engine");
    }
}


/****************************************************************/


static void
gen_idecode_h (lf *file,
	       gen_table *gen, insn_table *insns, cache_entry *cache_rules)
{
  lf_printf (file, "typedef unsigned%d %sinstruction_word;\n",
	     options.insn_bit_size, options.module.global.prefix.l);
  if (options.gen.delayed_branch)
    {
      lf_printf (file, "typedef struct _%sinstruction_address {\n",
		 options.module.global.prefix.l);
      lf_printf (file, "  address_word ip; /* instruction pointer */\n");
      lf_printf (file, "  address_word dp; /* delayed-slot pointer */\n");
      lf_printf (file, "} %sinstruction_address;\n",
		 options.module.global.prefix.l);
    }
  else
    {
      lf_printf (file, "typedef address_word %sinstruction_address;\n",
		 options.module.global.prefix.l);

    }
  if (options.gen.nia == nia_is_invalid
      && strlen (options.module.global.prefix.u) > 0)
    {
      lf_indent_suppress (file);
      lf_printf (file, "#define %sINVALID_INSTRUCTION_ADDRESS ",
		 options.module.global.prefix.u);
      lf_printf (file, "INVALID_INSTRUCTION_ADDRESS\n");
    }
  lf_printf (file, "\n");
  print_icache_struct (file, insns, cache_rules);
  lf_printf (file, "\n");
  if (options.gen.icache)
    {
      ERROR ("FIXME - idecode with icache suffering from bit-rot");
    }
  else
    {
      gen_list *entry;
      for (entry = gen->tables; entry != NULL; entry = entry->next)
	{
	  print_idecode_issue_function_header (file,
					       (options.gen.multi_sim
						? entry->model->name
						: NULL),
					       is_function_declaration,
					       1 /*ALWAYS ONE WORD */ );
	}
      if (options.gen.multi_sim)
	{
	  print_idecode_issue_function_header (file,
					       NULL,
					       is_function_variable,
					       1 /*ALWAYS ONE WORD */ );
	}
    }
}


static void
gen_idecode_c (lf *file,
	       gen_table *gen, insn_table *isa, cache_entry *cache_rules)
{
  /* the intro */
  print_includes (file);
  print_include_inline (file, options.module.semantics);
  lf_printf (file, "\n");

  print_idecode_globals (file);
  lf_printf (file, "\n");

  switch (options.gen.code)
    {
    case generate_calls:
      {
	gen_list *entry;
	for (entry = gen->tables; entry != NULL; entry = entry->next)
	  {
	    print_idecode_lookups (file, entry->table, cache_rules);

	    /* output the main idecode routine */
	    if (!options.gen.icache)
	      {
		print_idecode_issue_function_header (file,
						     (options.gen.multi_sim
						      ? entry->model->name
						      : NULL),
						     1 /*is definition */ ,
						     1 /*ALWAYS ONE WORD */ );
		lf_printf (file, "{\n");
		lf_indent (file, +2);
		lf_printf (file, "%sinstruction_address nia;\n",
			   options.module.global.prefix.l);
		print_idecode_body (file, entry->table, "nia =");
		lf_printf (file, "return nia;");
		lf_indent (file, -2);
		lf_printf (file, "}\n");
	      }
	  }
	break;
      }
    case generate_jumps:
      {
	lf_print__this_file_is_empty (file, "generating a jump engine");
	break;
      }
    }
}


/****************************************************************/


static void
gen_run_c (lf *file, gen_table *gen)
{
  gen_list *entry;
  lf_printf (file, "#include \"sim-main.h\"\n");
  lf_printf (file, "#include \"engine.h\"\n");
  lf_printf (file, "#include \"idecode.h\"\n");
  lf_printf (file, "#include \"bfd.h\"\n");
  lf_printf (file, "\n");

  if (options.gen.multi_sim)
    {
      print_idecode_issue_function_header (file, NULL, is_function_variable,
					   1);
      lf_printf (file, "\n");
      print_engine_run_function_header (file, NULL, is_function_variable);
      lf_printf (file, "\n");
    }

  lf_printf (file, "void\n");
  lf_printf (file, "sim_engine_run (SIM_DESC sd,\n");
  lf_printf (file, "                int next_cpu_nr,\n");
  lf_printf (file, "                int nr_cpus,\n");
  lf_printf (file, "                int siggnal)\n");
  lf_printf (file, "{\n");
  lf_indent (file, +2);
  if (options.gen.multi_sim)
    {
      lf_printf (file, "int mach;\n");
      lf_printf (file, "if (STATE_ARCHITECTURE (sd) == NULL)\n");
      lf_printf (file, "  mach = 0;\n");
      lf_printf (file, "else\n");
      lf_printf (file, "  mach = STATE_ARCHITECTURE (sd)->mach;\n");
      lf_printf (file, "switch (mach)\n");
      lf_printf (file, "  {\n");
      lf_indent (file, +2);
      for (entry = gen->tables; entry != NULL; entry = entry->next)
	{
	  if (options.gen.default_model != NULL
	      && (strcmp (entry->model->name, options.gen.default_model) == 0
		  || strcmp (entry->model->full_name,
			     options.gen.default_model) == 0))
	    lf_printf (file, "default:\n");
	  lf_printf (file, "case bfd_mach_%s:\n", entry->model->full_name);
	  lf_indent (file, +2);
	  print_function_name (file, "issue", NULL,	/* format name */
			       NULL,	/* NO processor */
			       NULL,	/* expanded bits */
			       function_name_prefix_idecode);
	  lf_printf (file, " = ");
	  print_function_name (file, "issue", NULL,	/* format name */
			       entry->model->name, NULL,	/* expanded bits */
			       function_name_prefix_idecode);
	  lf_printf (file, ";\n");
	  print_function_name (file, "run", NULL,	/* format name */
			       NULL,	/* NO processor */
			       NULL,	/* expanded bits */
			       function_name_prefix_engine);
	  lf_printf (file, " = ");
	  print_function_name (file, "run", NULL,	/* format name */
			       entry->model->name, NULL,	/* expanded bits */
			       function_name_prefix_engine);
	  lf_printf (file, ";\n");
	  lf_printf (file, "break;\n");
	  lf_indent (file, -2);
	}
      if (options.gen.default_model == NULL)
	{
	  lf_printf (file, "default:\n");
	  lf_indent (file, +2);
	  lf_printf (file, "sim_engine_abort (sd, NULL, NULL_CIA,\n");
	  lf_printf (file,
		     "                  \"sim_engine_run - unknown machine\");\n");
	  lf_printf (file, "break;\n");
	  lf_indent (file, -2);
	}
      lf_indent (file, -2);
      lf_printf (file, "  }\n");
    }
  print_function_name (file, "run", NULL,	/* format name */
		       NULL,	/* NO processor */
		       NULL,	/* expanded bits */
		       function_name_prefix_engine);
  lf_printf (file, " (sd, next_cpu_nr, nr_cpus, siggnal);\n");
  lf_indent (file, -2);
  lf_printf (file, "}\n");
}

/****************************************************************/

static gen_table *
do_gen (insn_table *isa, decode_table *decode_rules)
{
  gen_table *gen;
  if (decode_rules == NULL)
    error (NULL, "Must specify a decode table\n");
  if (isa == NULL)
    error (NULL, "Must specify an instruction table\n");
  if (decode_table_max_word_nr (decode_rules) > 0)
    options.gen.multi_word = decode_table_max_word_nr (decode_rules);
  gen = make_gen_tables (isa, decode_rules);
  gen_tables_expand_insns (gen);
  gen_tables_expand_semantics (gen);
  return gen;
}

/****************************************************************/

igen_options options;

int
main (int argc, char **argv, char **envp)
{
  cache_entry *cache_rules = NULL;
  lf_file_references file_references = lf_include_references;
  decode_table *decode_rules = NULL;
  insn_table *isa = NULL;
  gen_table *gen = NULL;
  char *real_file_name = NULL;
  int is_header = 0;
  int ch;
  lf *standard_out =
    lf_open ("-", "stdout", lf_omit_references, lf_is_text, "igen");

  INIT_OPTIONS ();

  if (argc == 1)
    {
      printf ("Usage:\n");
      printf ("\n");
      printf ("  igen <config-opts> ... <input-opts>... <output-opts>...\n");
      printf ("\n");
      printf ("Config options:\n");
      printf ("\n");
      printf ("  -B <bit-size>\n");
      printf ("\t Set the number of bits in an instruction (deprecated).\n");
      printf
	("\t This option can now be set directly in the instruction table.\n");
      printf ("\n");
      printf ("  -D <data-structure>\n");
      printf
	("\t Dump the specified data structure to stdout. Valid structures include:\n");
      printf
	("\t processor-names - list the names of all the processors (models)\n");
      printf ("\n");
      printf ("  -F <filter-list>\n");
      printf
	("\t Filter out any instructions with a non-empty flags field that contains\n");
      printf ("\t a flag not listed in the <filter-list>.\n");
      printf ("\n");
      printf ("  -H <high-bit>\n");
      printf
	("\t Set the number of the high (most significant) instruction bit (deprecated).\n");
      printf
	("\t This option can now be set directly in the instruction table.\n");
      printf ("\n");
      printf ("  -I <directory>\n");
      printf
	("\t Add <directory> to the list of directories searched when opening a file\n");
      printf ("\n");
      printf ("  -M <model-list>\n");
      printf
	("\t Filter out any instructions that do not support at least one of the listed\n");
      printf
	("\t models (An instructions with no model information is considered to support\n");
      printf ("\t all models.).\n");
      printf ("\n");
      printf ("  -N <nr-cpus>\n");
      printf ("\t Generate a simulator supporting <nr-cpus>\n");
      printf
	("\t Specify `-N 0' to disable generation of the SMP. Specifying `-N 1' will\n");
      printf
	("\t still generate an SMP enabled simulator but will only support one CPU.\n");
      printf ("\n");
      printf ("  -T <mechanism>\n");
      printf
	("\t Override the decode mechanism specified by the decode rules\n");
      printf ("\n");
      printf ("  -P <prefix>\n");
      printf
	("\t Prepend global names (except itable) with the string <prefix>.\n");
      printf
	("\t Specify -P <module>=<prefix> to set a specific <module>'s prefix.\n");
      printf ("\n");
      printf ("  -S <suffix>\n");
      printf
	("\t Replace a global name (suffix) (except itable) with the string <suffix>.\n");
      printf
	("\t Specify -S <module>=<suffix> to change a specific <module>'s name (suffix).\n");
      printf ("\n");
      printf ("  -Werror\n");
      printf ("\t Make warnings errors\n");
      printf ("  -Wnodiscard\n");
      printf
	("\t Suppress warnings about discarded functions and instructions\n");
      printf ("  -Wnowidth\n");
      printf
	("\t Suppress warnings about instructions with invalid widths\n");
      printf ("  -Wnounimplemented\n");
      printf ("\t Suppress warnings about unimplemented instructions\n");
      printf ("\n");
      printf ("  -G [!]<gen-option>\n");
      printf ("\t Any of the following options:\n");
      printf ("\n");
      printf
	("\t decode-duplicate       - Override the decode rules, forcing the duplication of\n");
      printf ("\t                          semantic functions\n");
      printf
	("\t decode-combine         - Combine any duplicated entries within a table\n");
      printf
	("\t decode-zero-reserved   - Override the decode rules, forcing reserved bits to be\n");
      printf ("\t                          treated as zero.\n");
      printf
	("\t decode-switch-is-goto  - Overfide the padded-switch code type as a goto-switch\n");
      printf ("\n");
      printf
	("\t gen-conditional-issue  - conditionally issue each instruction\n");
      printf
	("\t gen-delayed-branch     - need both cia and nia passed around\n");
      printf
	("\t gen-direct-access      - use #defines to directly access values\n");
      printf
	("\t gen-zero-r<N>          - arch assumes GPR(<N>) == 0, keep it that way\n");
      printf
	("\t gen-icache[=<N>        - generate an instruction cracking cache of size <N>\n");
      printf ("\t                          Default size is %d\n",
	      options.gen.icache_size);
      printf
	("\t gen-insn-in-icache     - save original instruction when cracking\n");
      printf
	("\t gen-multi-sim[=MODEL]  - generate multiple simulators - one per model\n");
      printf
	("\t                          If specified MODEL is made the default architecture.\n");
      printf
	("\t                          By default, a single simulator that will\n");
      printf
	("\t                          execute any instruction is generated\n");
      printf
	("\t gen-multi-word         - generate code allowing for multi-word insns\n");
      printf
	("\t gen-semantic-icache    - include semantic code in cracking functions\n");
      printf
	("\t gen-slot-verification  - perform slot verification as part of decode\n");
      printf ("\t gen-nia-invalid        - NIA defaults to nia_invalid\n");
      printf ("\t gen-nia-void           - do not compute/return NIA\n");
      printf ("\n");
      printf
	("\t trace-combine          - report combined entries a rule application\n");
      printf
	("\t trace-entries          - report entries after a rules application\n");
      printf ("\t trace-rule-rejection   - report each rule as rejected\n");
      printf ("\t trace-rule-selection   - report each rule as selected\n");
      printf
	("\t trace-insn-insertion   - report each instruction as it is inserted into a decode table\n");
      printf
	("\t trace-rule-expansion   - report each instruction as it is expanded (before insertion into a decode table)\n");
      printf ("\t trace-all              - enable all trace options\n");
      printf ("\n");
      printf
	("\t field-widths           - instruction formats specify widths (deprecated)\n");
      printf
	("\t                          By default, an instruction format specifies bit\n");
      printf ("\t                          positions\n");
      printf
	("\t                          This option can now be set directly in the\n");
      printf ("\t                          instruction table\n");
      printf
	("\t jumps                  - use jumps instead of function calls\n");
      printf
	("\t omit-line-numbers      - do not include line number information in the output\n");
      printf ("\n");
      printf ("Input options:\n");
      printf ("\n");
      printf ("  -k <cache-rules> (deprecated)\n");
      printf ("  -o <decode-rules>\n");
      printf ("  -i <instruction-table>\n");
      printf ("\n");
      printf ("Output options:\n");
      printf ("\n");
      printf ("  -x                    Perform expansion (required)\n");
      printf
	("  -n <real-name>        Specify the real name of the next output file\n");
      printf
	("  -h 		       Generate the header (.h) file rather than the body (.c)\n");
      printf ("  -c <output-file>      output icache\n");
      printf ("  -d <output-file>      output idecode\n");
      printf ("  -e <output-file>      output engine\n");
      printf ("  -f <output-file>      output support functions\n");
      printf ("  -m <output-file>      output model\n");
      printf ("  -r <output-file>      output multi-sim run\n");
      printf ("  -s <output-file>      output schematic\n");
      printf ("  -t <output-file>      output itable\n");
    }

  while ((ch = getopt (argc, argv,
		       "B:D:F:G:H:I:M:N:P:T:W:o:k:i:n:hc:d:e:m:r:s:t:f:x"))
	 != -1)
    {
      fprintf (stderr, "  -%c ", ch);
      if (optarg)
	fprintf (stderr, "%s ", optarg);
      fprintf (stderr, "\\\n");

      switch (ch)
	{

	case 'M':
	  filter_parse (&options.model_filter, optarg);
	  break;

	case 'D':
	  if (strcmp (optarg, "processor-names"))
	    {
	      char *processor;
	      for (processor = filter_next (options.model_filter, "");
		   processor != NULL;
		   processor = filter_next (options.model_filter, processor))
		lf_printf (standard_out, "%s\n", processor);
	    }
	  else
	    error (NULL, "Unknown data structure %s, not dumped\n", optarg);
	  break;

	case 'F':
	  filter_parse (&options.flags_filter, optarg);
	  break;

	case 'I':
	  {
	    table_include **dir = &options.include;
	    while ((*dir) != NULL)
	      dir = &(*dir)->next;
	    (*dir) = ZALLOC (table_include);
	    (*dir)->dir = strdup (optarg);
	  }
	  break;

	case 'B':
	  options.insn_bit_size = a2i (optarg);
	  if (options.insn_bit_size <= 0
	      || options.insn_bit_size > max_insn_bit_size)
	    {
	      error (NULL, "Instruction bitsize must be in range 1..%d\n",
		     max_insn_bit_size);
	    }
	  if (options.hi_bit_nr != options.insn_bit_size - 1
	      && options.hi_bit_nr != 0)
	    {
	      error (NULL, "Conflict betweem hi-bit-nr and insn-bit-size\n");
	    }
	  break;

	case 'H':
	  options.hi_bit_nr = a2i (optarg);
	  if (options.hi_bit_nr != options.insn_bit_size - 1
	      && options.hi_bit_nr != 0)
	    {
	      error (NULL, "Conflict between hi-bit-nr and insn-bit-size\n");
	    }
	  break;

	case 'N':
	  options.gen.smp = a2i (optarg);
	  break;

	case 'P':
	case 'S':
	  {
	    igen_module *names;
	    igen_name *name;
	    char *chp;
	    chp = strchr (optarg, '=');
	    if (chp == NULL)
	      {
		names = &options.module.global;
		chp = optarg;
	      }
	    else
	      {
		chp = chp + 1;	/* skip `=' */
		names = NULL;
		if (strncmp (optarg, "global=", chp - optarg) == 0)
		  {
		    names = &options.module.global;
		  }
		if (strncmp (optarg, "engine=", chp - optarg) == 0)
		  {
		    names = &options.module.engine;
		  }
		if (strncmp (optarg, "icache=", chp - optarg) == 0)
		  {
		    names = &options.module.icache;
		  }
		if (strncmp (optarg, "idecode=", chp - optarg) == 0)
		  {
		    names = &options.module.idecode;
		  }
		if (strncmp (optarg, "itable=", chp - optarg) == 0)
		  {
		    names = &options.module.itable;
		  }
		if (strncmp (optarg, "semantics=", chp - optarg) == 0)
		  {
		    names = &options.module.semantics;
		  }
		if (strncmp (optarg, "support=", chp - optarg) == 0)
		  {
		    names = &options.module.support;
		  }
		if (names == NULL)
		  {
		    error (NULL, "Prefix `%s' unreconized\n", optarg);
		  }
	      }
	    switch (ch)
	      {
	      case 'P':
		name = &names->prefix;
		break;
	      case 'S':
		name = &names->suffix;
		break;
	      default:
		abort ();	/* Bad switch.  */
	      }
	    name->u = strdup (chp);
	    name->l = strdup (chp);
	    chp = name->u;
	    while (*chp)
	      {
		if (islower (*chp))
		  *chp = toupper (*chp);
		chp++;
	      }
	    if (name == &options.module.global.prefix)
	      {
		options.module.engine.prefix = options.module.global.prefix;
		options.module.icache.prefix = options.module.global.prefix;
		options.module.idecode.prefix = options.module.global.prefix;
		/* options.module.itable.prefix = options.module.global.prefix; */
		options.module.semantics.prefix =
		  options.module.global.prefix;
		options.module.support.prefix = options.module.global.prefix;
	      }
	    if (name == &options.module.global.suffix)
	      {
		options.module.engine.suffix = options.module.global.suffix;
		options.module.icache.suffix = options.module.global.suffix;
		options.module.idecode.suffix = options.module.global.suffix;
		/* options.module.itable.suffix = options.module.global.suffix; */
		options.module.semantics.suffix =
		  options.module.global.suffix;
		options.module.support.suffix = options.module.global.suffix;
	      }
	    break;
	  }

	case 'W':
	  {
	    if (strcmp (optarg, "error") == 0)
	      options.warning = error;
	    else if (strcmp (optarg, "nodiscard") == 0)
	      options.warn.discard = 0;
	    else if (strcmp (optarg, "discard") == 0)
	      options.warn.discard = 1;
	    else if (strcmp (optarg, "nowidth") == 0)
	      options.warn.width = 0;
	    else if (strcmp (optarg, "width") == 0)
	      options.warn.width = 1;
	    else if (strcmp (optarg, "nounimplemented") == 0)
	      options.warn.unimplemented = 0;
	    else if (strcmp (optarg, "unimplemented") == 0)
	      options.warn.unimplemented = 1;
	    else
	      error (NULL, "Unknown -W argument `%s'\n", optarg);
	    break;
	  }


	case 'G':
	  {
	    int enable_p;
	    char *argp;
	    if (strncmp (optarg, "no-", strlen ("no-")) == 0)
	      {
		argp = optarg + strlen ("no-");
		enable_p = 0;
	      }
	    else if (strncmp (optarg, "!", strlen ("!")) == 0)
	      {
		argp = optarg + strlen ("no-");
		enable_p = 0;
	      }
	    else
	      {
		argp = optarg;
		enable_p = 1;
	      }
	    if (strcmp (argp, "decode-duplicate") == 0)
	      {
		options.decode.duplicate = enable_p;
	      }
	    else if (strcmp (argp, "decode-combine") == 0)
	      {
		options.decode.combine = enable_p;
	      }
	    else if (strcmp (argp, "decode-zero-reserved") == 0)
	      {
		options.decode.zero_reserved = enable_p;
	      }

	    else if (strcmp (argp, "gen-conditional-issue") == 0)
	      {
		options.gen.conditional_issue = enable_p;
	      }
	    else if (strcmp (argp, "conditional-issue") == 0)
	      {
		options.gen.conditional_issue = enable_p;
		options.warning (NULL,
				 "Option conditional-issue replaced by gen-conditional-issue\n");
	      }
	    else if (strcmp (argp, "gen-delayed-branch") == 0)
	      {
		options.gen.delayed_branch = enable_p;
	      }
	    else if (strcmp (argp, "delayed-branch") == 0)
	      {
		options.gen.delayed_branch = enable_p;
		options.warning (NULL,
				 "Option delayed-branch replaced by gen-delayed-branch\n");
	      }
	    else if (strcmp (argp, "gen-direct-access") == 0)
	      {
		options.gen.direct_access = enable_p;
	      }
	    else if (strcmp (argp, "direct-access") == 0)
	      {
		options.gen.direct_access = enable_p;
		options.warning (NULL,
				 "Option direct-access replaced by gen-direct-access\n");
	      }
	    else if (strncmp (argp, "gen-zero-r", strlen ("gen-zero-r")) == 0)
	      {
		options.gen.zero_reg = enable_p;
		options.gen.zero_reg_nr = atoi (argp + strlen ("gen-zero-r"));
	      }
	    else if (strncmp (argp, "zero-r", strlen ("zero-r")) == 0)
	      {
		options.gen.zero_reg = enable_p;
		options.gen.zero_reg_nr = atoi (argp + strlen ("zero-r"));
		options.warning (NULL,
				 "Option zero-r<N> replaced by gen-zero-r<N>\n");
	      }
	    else if (strncmp (argp, "gen-icache", strlen ("gen-icache")) == 0)
	      {
		switch (argp[strlen ("gen-icache")])
		  {
		  case '=':
		    options.gen.icache_size =
		      atoi (argp + strlen ("gen-icache") + 1);
		    options.gen.icache = enable_p;
		    break;
		  case '\0':
		    options.gen.icache = enable_p;
		    break;
		  default:
		    error (NULL,
			   "Expecting -Ggen-icache or -Ggen-icache=<N>\n");
		  }
	      }
	    else if (strcmp (argp, "gen-insn-in-icache") == 0)
	      {
		options.gen.insn_in_icache = enable_p;
	      }
	    else if (strncmp (argp, "gen-multi-sim", strlen ("gen-multi-sim"))
		     == 0)
	      {
		char *arg = &argp[strlen ("gen-multi-sim")];
		switch (arg[0])
		  {
		  case '=':
		    options.gen.multi_sim = enable_p;
		    options.gen.default_model = arg + 1;
		    if (!filter_is_member
			(options.model_filter, options.gen.default_model))
		      error (NULL, "multi-sim model %s unknown\n",
			     options.gen.default_model);
		    break;
		  case '\0':
		    options.gen.multi_sim = enable_p;
		    options.gen.default_model = NULL;
		    break;
		  default:
		    error (NULL,
			   "Expecting -Ggen-multi-sim or -Ggen-multi-sim=<MODEL>\n");
		    break;
		  }
	      }
	    else if (strcmp (argp, "gen-multi-word") == 0)
	      {
		options.gen.multi_word = enable_p;
	      }
	    else if (strcmp (argp, "gen-semantic-icache") == 0)
	      {
		options.gen.semantic_icache = enable_p;
	      }
	    else if (strcmp (argp, "gen-slot-verification") == 0)
	      {
		options.gen.slot_verification = enable_p;
	      }
	    else if (strcmp (argp, "verify-slot") == 0)
	      {
		options.gen.slot_verification = enable_p;
		options.warning (NULL,
				 "Option verify-slot replaced by gen-slot-verification\n");
	      }
	    else if (strcmp (argp, "gen-nia-invalid") == 0)
	      {
		options.gen.nia = nia_is_invalid;
	      }
	    else if (strcmp (argp, "default-nia-minus-one") == 0)
	      {
		options.gen.nia = nia_is_invalid;
		options.warning (NULL,
				 "Option default-nia-minus-one replaced by gen-nia-invalid\n");
	      }
	    else if (strcmp (argp, "gen-nia-void") == 0)
	      {
		options.gen.nia = nia_is_void;
	      }
	    else if (strcmp (argp, "trace-all") == 0)
	      {
		memset (&options.trace, enable_p, sizeof (options.trace));
	      }
	    else if (strcmp (argp, "trace-combine") == 0)
	      {
		options.trace.combine = enable_p;
	      }
	    else if (strcmp (argp, "trace-entries") == 0)
	      {
		options.trace.entries = enable_p;
	      }
	    else if (strcmp (argp, "trace-rule-rejection") == 0)
	      {
		options.trace.rule_rejection = enable_p;
	      }
	    else if (strcmp (argp, "trace-rule-selection") == 0)
	      {
		options.trace.rule_selection = enable_p;
	      }
	    else if (strcmp (argp, "trace-insn-insertion") == 0)
	      {
		options.trace.insn_insertion = enable_p;
	      }
	    else if (strcmp (argp, "trace-insn-expansion") == 0)
	      {
		options.trace.insn_expansion = enable_p;
	      }
	    else if (strcmp (argp, "jumps") == 0)
	      {
		options.gen.code = generate_jumps;
	      }
	    else if (strcmp (argp, "field-widths") == 0)
	      {
		options.insn_specifying_widths = enable_p;
	      }
	    else if (strcmp (argp, "omit-line-numbers") == 0)
	      {
		file_references = lf_omit_references;
	      }
	    else
	      {
		error (NULL, "Unknown option %s\n", optarg);
	      }
	    break;
	  }

	case 'i':
	  isa = load_insn_table (optarg, cache_rules);
	  if (isa->illegal_insn == NULL)
	    error (NULL, "illegal-instruction missing from insn table\n");
	  break;

	case 'x':
	  gen = do_gen (isa, decode_rules);
	  break;

	case 'o':
	  decode_rules = load_decode_table (optarg);
	  break;

	case 'k':
	  if (isa != NULL)
	    error (NULL, "Cache file must appear before the insn file\n");
	  cache_rules = load_cache_table (optarg);
	  break;

	case 'n':
	  real_file_name = strdup (optarg);
	  break;

	case 'h':
	  is_header = 1;
	  break;

	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'm':
	case 'r':
	case 's':
	case 't':
	  {
	    lf *file = lf_open (optarg, real_file_name, file_references,
				(is_header ? lf_is_h : lf_is_c),
				argv[0]);
	    if (gen == NULL && ch != 't' && ch != 'm' && ch != 'f')
	      {
		options.warning (NULL,
				 "Explicitly generate tables with -x option\n");
		gen = do_gen (isa, decode_rules);
	      }
	    lf_print__file_start (file);
	    switch (ch)
	      {
	      case 'm':
		if (is_header)
		  gen_model_h (file, isa);
		else
		  gen_model_c (file, isa);
		break;
	      case 't':
		if (is_header)
		  gen_itable_h (file, isa);
		else
		  gen_itable_c (file, isa);
		break;
	      case 'f':
		if (is_header)
		  gen_support_h (file, isa);
		else
		  gen_support_c (file, isa);
		break;
	      case 'r':
		if (is_header)
		  options.warning (NULL, "-hr option ignored\n");
		else
		  gen_run_c (file, gen);
		break;
	      case 's':
		if (is_header)
		  gen_semantics_h (file, gen->semantics, isa->max_nr_words);
		else
		  gen_semantics_c (file, gen->semantics, isa->caches);
		break;
	      case 'd':
		if (is_header)
		  gen_idecode_h (file, gen, isa, cache_rules);
		else
		  gen_idecode_c (file, gen, isa, cache_rules);
		break;
	      case 'e':
		if (is_header)
		  gen_engine_h (file, gen, isa, cache_rules);
		else
		  gen_engine_c (file, gen, isa, cache_rules);
		break;
	      case 'c':
		if (is_header)
		  gen_icache_h (file,
				gen->semantics,
				isa->functions, isa->max_nr_words);
		else
		  gen_icache_c (file,
				gen->semantics, isa->functions, cache_rules);
		break;
	      }
	    lf_print__file_finish (file);
	    lf_close (file);
	    is_header = 0;
	  }
	  real_file_name = NULL;
	  break;
	default:
	  ERROR ("Bad switch");
	}
    }
  return (0);
}
@


1.13
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright 2002, 2007-2012 Free Software Foundation, Inc.
@


1.12
log
@run copyright.sh for 2011.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.12.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright 2002, 2007-2012 Free Software Foundation, Inc.
@


1.11
log
@Update copyright notices to add year 2010.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.10
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.9
log
@	Updated copyright notices for most files.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008 Free Software Foundation, Inc.
@


1.8
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d3 1
a3 1
   Copyright 2002, 2007 Free Software Foundation, Inc.
@


1.7
log
@Copyright updates for 2007.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.6
log
@2002-11-21  Andrew Cagney  <ac131313@@redhat.com>

	* filter.c: Re-indent.
	* filter.h, filter_host.h, gen-engine.c, gen-engine.h: Ditto.
	* gen-icache.c, gen-icache.h, gen-idecode.c: Ditto.
	* gen-idecode.h, gen-itable.c, gen-itable.h: Ditto.
	* gen-model.c, gen-model.h, gen-semantics.c: Ditto.
	* gen-semantics.h, gen-support.c, gen-support.h: Ditto.
	* gen.c, gen.h, igen.c, igen.h, ld-cache.c, ld-cache.h: Ditto.
	* ld-decode.c, ld-decode.h, ld-insn.c, ld-insn.h, lf.c: Ditto.
	* lf.h, misc.c, misc.h, table.c, table.h: Ditto.
@
text
@d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
@


1.5
log
@2002-11-21  Andrew Cagney  <ac131313@@redhat.com>

        * Makefile.in: Update copyright.  IGEN contributed to the FSF.
        * filter.c, filter.h, filter_host.c, filter_host.h: Ditto.
        * gen-engine.c, gen-engine.h, gen-icache.c, gen-icache.h: Ditto.
        * gen-idecode.c, gen-idecode.h, gen-itable.c: Ditto.
        * gen-itable.h, gen-model.c, gen-model.h, gen-semantics.c: Ditto.
        * gen-semantics.h, gen-support.c, gen-support.h, gen.c: Ditto.
        * gen.h, igen.c, igen.h, ld-cache.c, ld-cache.h: Ditto.
        * ld-decode.c, ld-decode.h, ld-insn.c, ld-insn.h, lf.c: Ditto.
        * lf.h, misc.c, misc.h, table.c, table.h: Ditto.
@
text
@d58 1
a58 2
print_semantic_function_formal (lf *file,
				int nr_prefetched_words)
d76 1
a76 2
			   options.module.global.prefix.l,
			   word_nr);
d87 1
a87 2
			   options.module.global.prefix.l,
			   word_nr);
d96 1
a96 2
print_semantic_function_actual (lf *file,
				int nr_prefetched_words)
d130 1
a130 2
print_icache_function_formal (lf *file,
			      int nr_prefetched_words)
d135 1
a135 1
      nr += lf_printf (file, "sim_cpu *cpu,\n");
d137 1
a137 1
      nr += lf_printf (file, "SIM_DESC sd,\n");
d149 1
a149 2
print_icache_function_actual (lf *file,
			      int nr_prefetched_words)
d183 1
a183 2
print_opcode_bits (lf *file,
		   opcode_bits *bits)
d192 9
a200 6
  else if (!bits->opcode->is_boolean) {
    if (bits->opcode->last < bits->field->last)
      nr += lf_putint (file, bits->value << (bits->field->last - bits->opcode->last));
    else
      nr += lf_putint (file, bits->value);
  }
d206 1
a206 2
print_c_name (lf *file,
	      const char *name)
d262 1
a262 1
  
d271 1
a271 1
  
d289 1
a289 2
		  const char *format_name,
		  opcode_bits *expanded_bits)
d298 1
a298 2
		       NULL,
		       function_name_prefix_itable);
d305 1
a305 2
		       expanded_bits,
		       function_name_prefix_none);
d313 1
a313 2
		       expanded_bits,
		       function_name_prefix_none);
d323 1
a323 2
		       expanded_bits,
		       function_name_prefix_none);
d333 2
a334 1
  lf_printf (file, "%sSD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \\\n", prefix);
d336 4
a339 2
  lf_printf (file, "%sitable[MY_INDEX].file, \\\n", options.module.itable.prefix.l);
  lf_printf (file, "%sitable[MY_INDEX].line_nr, \\\n", options.module.itable.prefix.l);
d346 1
a346 2
print_itrace_format (lf *file,
		     insn_mnemonic_entry *assembler)
d354 1
a354 1
      chp++; /* skip the leading quote */
d394 2
a395 1
		error (assembler->line, "Missing closing `>' in assembler string\n");
d426 2
a427 1
		      lf_printf (file, "%sstr_", options.module.global.prefix.l);
d446 1
a446 1
		/* simple hex with 0x prefix*/
d483 1
a483 3
print_itrace (lf *file,
	      insn_entry *insn,
	      int idecode)
d508 1
a508 2
			   is_first ? "" : "else ",
			   assembler->condition);
d517 2
a518 1
		  error (assembler->line, "Missing final unconditional assembler\n");
d536 2
a537 1
		  error (assembler->line, "Unconditional assembler is not last\n");
d558 3
a560 1
    lf_printf (file, "  trace_generic (SD, CPU, TRACE_%s_IDX, \" %%s\", itable[MY_INDEX].name);\n", phase);
d570 1
a570 2
print_sim_engine_abort (lf *file,
			const char *message)
d579 1
a579 2
print_include (lf *file,
	       igen_module module)
d585 1
a585 2
print_include_inline (lf *file,
		      igen_module module)
d611 1
a611 3
gen_semantics_h (lf *file,
		 insn_list *semantics,
		 int max_nr_words)
d619 1
a619 2
      lf_printf (file, " %sidecode_semantic",
		 options.module.global.prefix.l);
d652 1
a652 3
gen_semantics_c (lf *file,
		 insn_list *semantics,
		 cache_entry *cache_rules)
d687 1
a687 2
	      function_entry *functions,
	      int max_nr_words)
d693 1
a693 1
      print_icache_function_type(file);
d695 2
a696 3
		 options.module.global.prefix.l,
		 word_nr);
      print_icache_function_formal(file, word_nr);
d700 1
a700 2
  if (options.gen.code == generate_calls
      && options.gen.icache)
d724 1
a724 2
	      function_entry *functions,
	      cache_entry *cache_rules)
d728 1
a728 2
  if (options.gen.code == generate_calls
      && options.gen.icache)
d764 1
a764 3
	       gen_table *gen,
	       insn_table *insns,
	       cache_entry *cache_rules)
d774 2
a775 1
      lf_printf (file, "} %sinstruction_address;\n", options.module.global.prefix.l);
d781 1
a781 1
      
d808 1
a808 1
					       1/*ALWAYS ONE WORD*/);
d815 1
a815 1
					       1/*ALWAYS ONE WORD*/);
d823 1
a823 3
	       gen_table *gen,
	       insn_table *isa,
	       cache_entry *cache_rules)
d832 1
a832 1
  
d841 1
a841 1
	
d849 2
a850 2
						     1/*is definition*/,
						     1/*ALWAYS ONE WORD*/);
d876 1
a876 2
gen_run_c (lf *file,
	   gen_table *gen)
d887 2
a888 1
      print_idecode_issue_function_header (file, NULL, is_function_variable, 1);
d893 1
a893 1
  
d915 2
a916 1
		  || strcmp (entry->model->full_name, options.gen.default_model) == 0))
d920 3
a922 5
	  print_function_name (file,
			       "issue",
			       NULL, /* format name */
			       NULL, /* NO processor */
			       NULL, /* expanded bits */
d925 2
a926 5
	  print_function_name (file,
			       "issue",
			       NULL, /* format name */
			       entry->model->name,
			       NULL, /* expanded bits */
d929 3
a931 5
	  print_function_name (file,
			       "run",
			       NULL, /* format name */
			       NULL, /* NO processor */
			       NULL, /* expanded bits */
d934 2
a935 5
	  print_function_name (file,
			       "run",
			       NULL, /* format name */
			       entry->model->name,
			       NULL, /* expanded bits */
d946 2
a947 1
	  lf_printf (file, "                  \"sim_engine_run - unknown machine\");\n");
d954 3
a956 5
  print_function_name (file,
		       "run",
		       NULL, /* format name */
		       NULL, /* NO processor */
		       NULL, /* expanded bits */
d966 1
a966 2
do_gen (insn_table *isa,
	decode_table *decode_rules)
d986 1
a986 3
main (int argc,
      char **argv,
      char **envp)
d996 2
a997 1
  lf *standard_out = lf_open ("-", "stdout", lf_omit_references, lf_is_text, "igen");
d1011 2
a1012 1
      printf ("\t This option can now be set directly in the instruction table.\n");
d1015 4
a1018 2
      printf ("\t Dump the specified data structure to stdout. Valid structures include:\n");
      printf ("\t processor-names - list the names of all the processors (models)\n");
d1021 2
a1022 1
      printf ("\t Filter out any instructions with a non-empty flags field that contains\n");
d1026 4
a1029 2
      printf ("\t Set the number of the high (most significant) instruction bit (deprecated).\n");
      printf ("\t This option can now be set directly in the instruction table.\n");
d1032 2
a1033 1
      printf ("\t Add <directory> to the list of directories searched when opening a file\n");
d1036 4
a1039 2
      printf ("\t Filter out any instructions that do not support at least one of the listed\n");
      printf ("\t models (An instructions with no model information is considered to support\n");
d1044 4
a1047 2
      printf ("\t Specify `-N 0' to disable generation of the SMP. Specifying `-N 1' will\n");
      printf ("\t still generate an SMP enabled simulator but will only support one CPU.\n");
d1050 2
a1051 1
      printf ("\t Override the decode mechanism specified by the decode rules\n");
d1054 4
a1057 2
      printf ("\t Prepend global names (except itable) with the string <prefix>.\n");
      printf ("\t Specify -P <module>=<prefix> to set a specific <module>'s prefix.\n");
d1060 4
a1063 2
      printf ("\t Replace a global name (suffix) (except itable) with the string <suffix>.\n");
      printf ("\t Specify -S <module>=<suffix> to change a specific <module>'s name (suffix).\n");
d1068 2
a1069 1
      printf ("\t Suppress warnings about discarded functions and instructions\n");
d1071 2
a1072 1
      printf ("\t Suppress warnings about instructions with invalid widths\n");
d1079 2
a1080 1
      printf ("\t decode-duplicate       - Override the decode rules, forcing the duplication of\n");
d1082 4
a1085 2
      printf ("\t decode-combine         - Combine any duplicated entries within a table\n");
      printf ("\t decode-zero-reserved   - Override the decode rules, forcing reserved bits to be\n");
d1087 2
a1088 1
      printf ("\t decode-switch-is-goto  - Overfide the padded-switch code type as a goto-switch\n");
d1090 28
a1117 14
      printf ("\t gen-conditional-issue  - conditionally issue each instruction\n");
      printf ("\t gen-delayed-branch     - need both cia and nia passed around\n");
      printf ("\t gen-direct-access      - use #defines to directly access values\n");
      printf ("\t gen-zero-r<N>          - arch assumes GPR(<N>) == 0, keep it that way\n");
      printf ("\t gen-icache[=<N>        - generate an instruction cracking cache of size <N>\n");
      printf ("\t                          Default size is %d\n", options.gen.icache_size);
      printf ("\t gen-insn-in-icache     - save original instruction when cracking\n");
      printf ("\t gen-multi-sim[=MODEL]  - generate multiple simulators - one per model\n");
      printf ("\t                          If specified MODEL is made the default architecture.\n");
      printf ("\t                          By default, a single simulator that will\n");
      printf ("\t                          execute any instruction is generated\n");
      printf ("\t gen-multi-word         - generate code allowing for multi-word insns\n");
      printf ("\t gen-semantic-icache    - include semantic code in cracking functions\n");
      printf ("\t gen-slot-verification  - perform slot verification as part of decode\n");
d1121 4
a1124 2
      printf ("\t trace-combine          - report combined entries a rule application\n");
      printf ("\t trace-entries          - report entries after a rules application\n");
d1127 4
a1130 2
      printf ("\t trace-insn-insertion   - report each instruction as it is inserted into a decode table\n");
      printf ("\t trace-rule-expansion   - report each instruction as it is expanded (before insertion into a decode table)\n");
d1133 4
a1136 2
      printf ("\t field-widths           - instruction formats specify widths (deprecated)\n");
      printf ("\t                          By default, an instruction format specifies bit\n");
d1138 2
a1139 1
      printf ("\t                          This option can now be set directly in the\n");
d1141 4
a1144 2
      printf ("\t jumps                  - use jumps instead of function calls\n");
      printf ("\t omit-line-numbers      - do not include line number information in the output\n");
d1155 4
a1158 2
      printf ("  -n <real-name>        Specify the real name of the next output file\n"); 
      printf ("  -h 		       Generate the header (.h) file rather than the body (.c)\n");
d1168 3
a1170 3
  
  while ((ch = getopt(argc, argv,
		      "B:D:F:G:H:I:M:N:P:T:W:o:k:i:n:hc:d:e:m:r:s:t:f:x"))
d1177 2
a1178 2
      
      switch(ch)
d1180 1
a1180 1
	  
d1201 1
a1201 1
	  
d1211 1
a1211 1
	  
d1226 1
a1226 1
	  
d1235 1
a1235 1
	  
d1239 1
a1239 1
	  
d1254 1
a1254 1
		chp = chp + 1; /* skip `=' */
d1298 1
a1298 1
		abort (); /* Bad switch.  */
d1303 6
a1308 5
	    while (*chp) {
	      if (islower(*chp))
		*chp = toupper(*chp);
	      chp++;
	    }
d1315 2
a1316 1
		options.module.semantics.prefix = options.module.global.prefix;
d1325 2
a1326 1
		options.module.semantics.suffix = options.module.global.suffix;
d1331 1
a1331 1
	
d1385 1
a1385 1
	    
d1393 2
a1394 1
		options.warning (NULL, "Option conditional-issue replaced by gen-conditional-issue\n");
d1403 2
a1404 1
		options.warning (NULL, "Option delayed-branch replaced by gen-delayed-branch\n");
d1413 2
a1414 1
		options.warning (NULL, "Option direct-access replaced by gen-direct-access\n");
d1425 2
a1426 1
		options.warning (NULL, "Option zero-r<N> replaced by gen-zero-r<N>\n");
d1433 2
a1434 1
		    options.gen.icache_size = atoi (argp + strlen ("gen-icache") + 1);
d1441 2
a1442 1
		    error (NULL, "Expecting -Ggen-icache or -Ggen-icache=<N>\n");
d1449 2
a1450 1
	    else if (strncmp (argp, "gen-multi-sim", strlen ("gen-multi-sim")) == 0)
d1458 4
a1461 2
		    if (! filter_is_member (options.model_filter, options.gen.default_model))
		      error (NULL, "multi-sim model %s unknown\n", options.gen.default_model);
d1468 2
a1469 1
		    error (NULL, "Expecting -Ggen-multi-sim or -Ggen-multi-sim=<MODEL>\n");
d1488 2
a1489 1
		options.warning (NULL, "Option verify-slot replaced by gen-slot-verification\n");
d1498 2
a1499 1
		options.warning (NULL, "Option default-nia-minus-one replaced by gen-nia-invalid\n");
d1551 1
a1551 1
	
d1573 1
a1573 1
	  real_file_name = strdup(optarg);
d1579 1
a1579 1
	  
d1589 3
a1591 3
	    lf *file = lf_open(optarg, real_file_name, file_references,
			       (is_header ? lf_is_h : lf_is_c),
			       argv[0]);
d1594 2
a1595 1
		options.warning (NULL, "Explicitly generate tables with -x option\n");
d1598 1
a1598 1
	    lf_print__file_start(file);
d1626 1
a1626 1
		if(is_header)
d1647 1
a1647 2
				isa->functions,
				isa->max_nr_words);
d1650 1
a1650 3
				gen->semantics,
				isa->functions,
				cache_rules);
d1653 2
a1654 2
	    lf_print__file_finish(file);
	    lf_close(file);
d1657 2
a1658 2
	real_file_name = NULL;
	break;
@


1.4
log
@* gen.c (gen_entry_expand_opcode): Initialize ``value'' to -1 and
``t'' to NULL.
* igen.c (main): Add default case to switch.
* gen-icache.c (print_icache_extraction): Ditto.
@
text
@d1 1
a1 1
/*  This file is part of the program psim.
d3 1
a3 1
    Copyright (C) 1994-1998, Andrew Cagney <cagney@@highland.com.au>
d5 18
a22 15
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
    */
@


1.4.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1 1
a1 1
/* The IGEN simulator generator for GDB, the GNU Debugger.
d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d5 15
a19 18
   Contributed by Andrew Cagney.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d55 2
a56 1
print_semantic_function_formal (lf *file, int nr_prefetched_words)
d74 2
a75 1
			   options.module.global.prefix.l, word_nr);
d86 2
a87 1
			   options.module.global.prefix.l, word_nr);
d96 2
a97 1
print_semantic_function_actual (lf *file, int nr_prefetched_words)
d131 2
a132 1
print_icache_function_formal (lf *file, int nr_prefetched_words)
d137 1
a137 1
    nr += lf_printf (file, "sim_cpu *cpu,\n");
d139 1
a139 1
    nr += lf_printf (file, "SIM_DESC sd,\n");
d151 2
a152 1
print_icache_function_actual (lf *file, int nr_prefetched_words)
d186 2
a187 1
print_opcode_bits (lf *file, opcode_bits *bits)
d196 6
a201 9
  else if (!bits->opcode->is_boolean)
    {
      if (bits->opcode->last < bits->field->last)
	nr +=
	  lf_putint (file,
		     bits->value << (bits->field->last - bits->opcode->last));
      else
	nr += lf_putint (file, bits->value);
    }
d207 2
a208 1
print_c_name (lf *file, const char *name)
d264 1
a264 1

d273 1
a273 1

d291 2
a292 1
		  const char *format_name, opcode_bits *expanded_bits)
d301 2
a302 1
		       NULL, function_name_prefix_itable);
d309 2
a310 1
		       expanded_bits, function_name_prefix_none);
d318 2
a319 1
		       expanded_bits, function_name_prefix_none);
d329 2
a330 1
		       expanded_bits, function_name_prefix_none);
d340 1
a340 2
  lf_printf (file, "%sSD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \\\n",
	     prefix);
d342 2
a343 4
  lf_printf (file, "%sitable[MY_INDEX].file, \\\n",
	     options.module.itable.prefix.l);
  lf_printf (file, "%sitable[MY_INDEX].line_nr, \\\n",
	     options.module.itable.prefix.l);
d350 2
a351 1
print_itrace_format (lf *file, insn_mnemonic_entry *assembler)
d359 1
a359 1
      chp++;			/* skip the leading quote */
d399 1
a399 2
		error (assembler->line,
		       "Missing closing `>' in assembler string\n");
d430 1
a430 2
		      lf_printf (file, "%sstr_",
				 options.module.global.prefix.l);
d449 1
a449 1
		/* simple hex with 0x prefix */
d486 3
a488 1
print_itrace (lf *file, insn_entry * insn, int idecode)
d513 2
a514 1
			   is_first ? "" : "else ", assembler->condition);
d523 1
a523 2
		  error (assembler->line,
			 "Missing final unconditional assembler\n");
d541 1
a541 2
		  error (assembler->line,
			 "Unconditional assembler is not last\n");
d562 1
a562 3
    lf_printf (file,
	       "  trace_generic (SD, CPU, TRACE_%s_IDX, \" %%s\", itable[MY_INDEX].name);\n",
	       phase);
d572 2
a573 1
print_sim_engine_abort (lf *file, const char *message)
d582 2
a583 1
print_include (lf *file, igen_module module)
d589 2
a590 1
print_include_inline (lf *file, igen_module module)
d616 3
a618 1
gen_semantics_h (lf *file, insn_list *semantics, int max_nr_words)
d626 2
a627 1
      lf_printf (file, " %sidecode_semantic", options.module.global.prefix.l);
d660 3
a662 1
gen_semantics_c (lf *file, insn_list *semantics, cache_entry *cache_rules)
d697 2
a698 1
	      function_entry * functions, int max_nr_words)
d704 1
a704 1
      print_icache_function_type (file);
d706 3
a708 2
		 options.module.global.prefix.l, word_nr);
      print_icache_function_formal (file, word_nr);
d712 2
a713 1
  if (options.gen.code == generate_calls && options.gen.icache)
d737 2
a738 1
	      function_entry * functions, cache_entry *cache_rules)
d742 2
a743 1
  if (options.gen.code == generate_calls && options.gen.icache)
d779 3
a781 1
	       gen_table *gen, insn_table *insns, cache_entry *cache_rules)
d791 1
a791 2
      lf_printf (file, "} %sinstruction_address;\n",
		 options.module.global.prefix.l);
d797 1
a797 1

d824 1
a824 1
					       1 /*ALWAYS ONE WORD */ );
d831 1
a831 1
					       1 /*ALWAYS ONE WORD */ );
d839 3
a841 1
	       gen_table *gen, insn_table *isa, cache_entry *cache_rules)
d850 1
a850 1

d859 1
a859 1

d867 2
a868 2
						     1 /*is definition */ ,
						     1 /*ALWAYS ONE WORD */ );
d894 2
a895 1
gen_run_c (lf *file, gen_table *gen)
d906 1
a906 2
      print_idecode_issue_function_header (file, NULL, is_function_variable,
					   1);
d911 1
a911 1

d933 1
a933 2
		  || strcmp (entry->model->full_name,
			     options.gen.default_model) == 0))
d937 5
a941 3
	  print_function_name (file, "issue", NULL,	/* format name */
			       NULL,	/* NO processor */
			       NULL,	/* expanded bits */
d944 5
a948 2
	  print_function_name (file, "issue", NULL,	/* format name */
			       entry->model->name, NULL,	/* expanded bits */
d951 5
a955 3
	  print_function_name (file, "run", NULL,	/* format name */
			       NULL,	/* NO processor */
			       NULL,	/* expanded bits */
d958 5
a962 2
	  print_function_name (file, "run", NULL,	/* format name */
			       entry->model->name, NULL,	/* expanded bits */
d973 1
a973 2
	  lf_printf (file,
		     "                  \"sim_engine_run - unknown machine\");\n");
d980 5
a984 3
  print_function_name (file, "run", NULL,	/* format name */
		       NULL,	/* NO processor */
		       NULL,	/* expanded bits */
d994 2
a995 1
do_gen (insn_table *isa, decode_table *decode_rules)
d1015 3
a1017 1
main (int argc, char **argv, char **envp)
d1027 1
a1027 2
  lf *standard_out =
    lf_open ("-", "stdout", lf_omit_references, lf_is_text, "igen");
d1041 1
a1041 2
      printf
	("\t This option can now be set directly in the instruction table.\n");
d1044 2
a1045 4
      printf
	("\t Dump the specified data structure to stdout. Valid structures include:\n");
      printf
	("\t processor-names - list the names of all the processors (models)\n");
d1048 1
a1048 2
      printf
	("\t Filter out any instructions with a non-empty flags field that contains\n");
d1052 2
a1053 4
      printf
	("\t Set the number of the high (most significant) instruction bit (deprecated).\n");
      printf
	("\t This option can now be set directly in the instruction table.\n");
d1056 1
a1056 2
      printf
	("\t Add <directory> to the list of directories searched when opening a file\n");
d1059 2
a1060 4
      printf
	("\t Filter out any instructions that do not support at least one of the listed\n");
      printf
	("\t models (An instructions with no model information is considered to support\n");
d1065 2
a1066 4
      printf
	("\t Specify `-N 0' to disable generation of the SMP. Specifying `-N 1' will\n");
      printf
	("\t still generate an SMP enabled simulator but will only support one CPU.\n");
d1069 1
a1069 2
      printf
	("\t Override the decode mechanism specified by the decode rules\n");
d1072 2
a1073 4
      printf
	("\t Prepend global names (except itable) with the string <prefix>.\n");
      printf
	("\t Specify -P <module>=<prefix> to set a specific <module>'s prefix.\n");
d1076 2
a1077 4
      printf
	("\t Replace a global name (suffix) (except itable) with the string <suffix>.\n");
      printf
	("\t Specify -S <module>=<suffix> to change a specific <module>'s name (suffix).\n");
d1082 1
a1082 2
      printf
	("\t Suppress warnings about discarded functions and instructions\n");
d1084 1
a1084 2
      printf
	("\t Suppress warnings about instructions with invalid widths\n");
d1091 1
a1091 2
      printf
	("\t decode-duplicate       - Override the decode rules, forcing the duplication of\n");
d1093 2
a1094 4
      printf
	("\t decode-combine         - Combine any duplicated entries within a table\n");
      printf
	("\t decode-zero-reserved   - Override the decode rules, forcing reserved bits to be\n");
d1096 1
a1096 2
      printf
	("\t decode-switch-is-goto  - Overfide the padded-switch code type as a goto-switch\n");
d1098 14
a1111 28
      printf
	("\t gen-conditional-issue  - conditionally issue each instruction\n");
      printf
	("\t gen-delayed-branch     - need both cia and nia passed around\n");
      printf
	("\t gen-direct-access      - use #defines to directly access values\n");
      printf
	("\t gen-zero-r<N>          - arch assumes GPR(<N>) == 0, keep it that way\n");
      printf
	("\t gen-icache[=<N>        - generate an instruction cracking cache of size <N>\n");
      printf ("\t                          Default size is %d\n",
	      options.gen.icache_size);
      printf
	("\t gen-insn-in-icache     - save original instruction when cracking\n");
      printf
	("\t gen-multi-sim[=MODEL]  - generate multiple simulators - one per model\n");
      printf
	("\t                          If specified MODEL is made the default architecture.\n");
      printf
	("\t                          By default, a single simulator that will\n");
      printf
	("\t                          execute any instruction is generated\n");
      printf
	("\t gen-multi-word         - generate code allowing for multi-word insns\n");
      printf
	("\t gen-semantic-icache    - include semantic code in cracking functions\n");
      printf
	("\t gen-slot-verification  - perform slot verification as part of decode\n");
d1115 2
a1116 4
      printf
	("\t trace-combine          - report combined entries a rule application\n");
      printf
	("\t trace-entries          - report entries after a rules application\n");
d1119 2
a1120 4
      printf
	("\t trace-insn-insertion   - report each instruction as it is inserted into a decode table\n");
      printf
	("\t trace-rule-expansion   - report each instruction as it is expanded (before insertion into a decode table)\n");
d1123 2
a1124 4
      printf
	("\t field-widths           - instruction formats specify widths (deprecated)\n");
      printf
	("\t                          By default, an instruction format specifies bit\n");
d1126 1
a1126 2
      printf
	("\t                          This option can now be set directly in the\n");
d1128 2
a1129 4
      printf
	("\t jumps                  - use jumps instead of function calls\n");
      printf
	("\t omit-line-numbers      - do not include line number information in the output\n");
d1140 2
a1141 4
      printf
	("  -n <real-name>        Specify the real name of the next output file\n");
      printf
	("  -h 		       Generate the header (.h) file rather than the body (.c)\n");
d1151 3
a1153 3

  while ((ch = getopt (argc, argv,
		       "B:D:F:G:H:I:M:N:P:T:W:o:k:i:n:hc:d:e:m:r:s:t:f:x"))
d1160 2
a1161 2

      switch (ch)
d1163 1
a1163 1

d1184 1
a1184 1

d1194 1
a1194 1

d1209 1
a1209 1

d1218 1
a1218 1

d1222 1
a1222 1

d1237 1
a1237 1
		chp = chp + 1;	/* skip `=' */
d1281 1
a1281 1
		abort ();	/* Bad switch.  */
d1286 5
a1290 6
	    while (*chp)
	      {
		if (islower (*chp))
		  *chp = toupper (*chp);
		chp++;
	      }
d1297 1
a1297 2
		options.module.semantics.prefix =
		  options.module.global.prefix;
d1306 1
a1306 2
		options.module.semantics.suffix =
		  options.module.global.suffix;
d1311 1
a1311 1

d1365 1
a1365 1

d1373 1
a1373 2
		options.warning (NULL,
				 "Option conditional-issue replaced by gen-conditional-issue\n");
d1382 1
a1382 2
		options.warning (NULL,
				 "Option delayed-branch replaced by gen-delayed-branch\n");
d1391 1
a1391 2
		options.warning (NULL,
				 "Option direct-access replaced by gen-direct-access\n");
d1402 1
a1402 2
		options.warning (NULL,
				 "Option zero-r<N> replaced by gen-zero-r<N>\n");
d1409 1
a1409 2
		    options.gen.icache_size =
		      atoi (argp + strlen ("gen-icache") + 1);
d1416 1
a1416 2
		    error (NULL,
			   "Expecting -Ggen-icache or -Ggen-icache=<N>\n");
d1423 1
a1423 2
	    else if (strncmp (argp, "gen-multi-sim", strlen ("gen-multi-sim"))
		     == 0)
d1431 2
a1432 4
		    if (!filter_is_member
			(options.model_filter, options.gen.default_model))
		      error (NULL, "multi-sim model %s unknown\n",
			     options.gen.default_model);
d1439 1
a1439 2
		    error (NULL,
			   "Expecting -Ggen-multi-sim or -Ggen-multi-sim=<MODEL>\n");
d1458 1
a1458 2
		options.warning (NULL,
				 "Option verify-slot replaced by gen-slot-verification\n");
d1467 1
a1467 2
		options.warning (NULL,
				 "Option default-nia-minus-one replaced by gen-nia-invalid\n");
d1519 1
a1519 1

d1541 1
a1541 1
	  real_file_name = strdup (optarg);
d1547 1
a1547 1

d1557 3
a1559 3
	    lf *file = lf_open (optarg, real_file_name, file_references,
				(is_header ? lf_is_h : lf_is_c),
				argv[0]);
d1562 1
a1562 2
		options.warning (NULL,
				 "Explicitly generate tables with -x option\n");
d1565 1
a1565 1
	    lf_print__file_start (file);
d1593 1
a1593 1
		if (is_header)
d1614 2
a1615 1
				isa->functions, isa->max_nr_words);
d1618 3
a1620 1
				gen->semantics, isa->functions, cache_rules);
d1623 2
a1624 2
	    lf_print__file_finish (file);
	    lf_close (file);
d1627 2
a1628 2
	  real_file_name = NULL;
	  break;
@


1.4.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d1 1
a1 1
/* The IGEN simulator generator for GDB, the GNU Debugger.
d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d5 15
a19 18
   Contributed by Andrew Cagney.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d55 2
a56 1
print_semantic_function_formal (lf *file, int nr_prefetched_words)
d74 2
a75 1
			   options.module.global.prefix.l, word_nr);
d86 2
a87 1
			   options.module.global.prefix.l, word_nr);
d96 2
a97 1
print_semantic_function_actual (lf *file, int nr_prefetched_words)
d131 2
a132 1
print_icache_function_formal (lf *file, int nr_prefetched_words)
d137 1
a137 1
    nr += lf_printf (file, "sim_cpu *cpu,\n");
d139 1
a139 1
    nr += lf_printf (file, "SIM_DESC sd,\n");
d151 2
a152 1
print_icache_function_actual (lf *file, int nr_prefetched_words)
d186 2
a187 1
print_opcode_bits (lf *file, opcode_bits *bits)
d196 6
a201 9
  else if (!bits->opcode->is_boolean)
    {
      if (bits->opcode->last < bits->field->last)
	nr +=
	  lf_putint (file,
		     bits->value << (bits->field->last - bits->opcode->last));
      else
	nr += lf_putint (file, bits->value);
    }
d207 2
a208 1
print_c_name (lf *file, const char *name)
d264 1
a264 1

d273 1
a273 1

d291 2
a292 1
		  const char *format_name, opcode_bits *expanded_bits)
d301 2
a302 1
		       NULL, function_name_prefix_itable);
d309 2
a310 1
		       expanded_bits, function_name_prefix_none);
d318 2
a319 1
		       expanded_bits, function_name_prefix_none);
d329 2
a330 1
		       expanded_bits, function_name_prefix_none);
d340 1
a340 2
  lf_printf (file, "%sSD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \\\n",
	     prefix);
d342 2
a343 4
  lf_printf (file, "%sitable[MY_INDEX].file, \\\n",
	     options.module.itable.prefix.l);
  lf_printf (file, "%sitable[MY_INDEX].line_nr, \\\n",
	     options.module.itable.prefix.l);
d350 2
a351 1
print_itrace_format (lf *file, insn_mnemonic_entry *assembler)
d359 1
a359 1
      chp++;			/* skip the leading quote */
d399 1
a399 2
		error (assembler->line,
		       "Missing closing `>' in assembler string\n");
d430 1
a430 2
		      lf_printf (file, "%sstr_",
				 options.module.global.prefix.l);
d449 1
a449 1
		/* simple hex with 0x prefix */
d486 3
a488 1
print_itrace (lf *file, insn_entry * insn, int idecode)
d513 2
a514 1
			   is_first ? "" : "else ", assembler->condition);
d523 1
a523 2
		  error (assembler->line,
			 "Missing final unconditional assembler\n");
d541 1
a541 2
		  error (assembler->line,
			 "Unconditional assembler is not last\n");
d562 1
a562 3
    lf_printf (file,
	       "  trace_generic (SD, CPU, TRACE_%s_IDX, \" %%s\", itable[MY_INDEX].name);\n",
	       phase);
d572 2
a573 1
print_sim_engine_abort (lf *file, const char *message)
d582 2
a583 1
print_include (lf *file, igen_module module)
d589 2
a590 1
print_include_inline (lf *file, igen_module module)
d616 3
a618 1
gen_semantics_h (lf *file, insn_list *semantics, int max_nr_words)
d626 2
a627 1
      lf_printf (file, " %sidecode_semantic", options.module.global.prefix.l);
d660 3
a662 1
gen_semantics_c (lf *file, insn_list *semantics, cache_entry *cache_rules)
d697 2
a698 1
	      function_entry * functions, int max_nr_words)
d704 1
a704 1
      print_icache_function_type (file);
d706 3
a708 2
		 options.module.global.prefix.l, word_nr);
      print_icache_function_formal (file, word_nr);
d712 2
a713 1
  if (options.gen.code == generate_calls && options.gen.icache)
d737 2
a738 1
	      function_entry * functions, cache_entry *cache_rules)
d742 2
a743 1
  if (options.gen.code == generate_calls && options.gen.icache)
d779 3
a781 1
	       gen_table *gen, insn_table *insns, cache_entry *cache_rules)
d791 1
a791 2
      lf_printf (file, "} %sinstruction_address;\n",
		 options.module.global.prefix.l);
d797 1
a797 1

d824 1
a824 1
					       1 /*ALWAYS ONE WORD */ );
d831 1
a831 1
					       1 /*ALWAYS ONE WORD */ );
d839 3
a841 1
	       gen_table *gen, insn_table *isa, cache_entry *cache_rules)
d850 1
a850 1

d859 1
a859 1

d867 2
a868 2
						     1 /*is definition */ ,
						     1 /*ALWAYS ONE WORD */ );
d894 2
a895 1
gen_run_c (lf *file, gen_table *gen)
d906 1
a906 2
      print_idecode_issue_function_header (file, NULL, is_function_variable,
					   1);
d911 1
a911 1

d933 1
a933 2
		  || strcmp (entry->model->full_name,
			     options.gen.default_model) == 0))
d937 5
a941 3
	  print_function_name (file, "issue", NULL,	/* format name */
			       NULL,	/* NO processor */
			       NULL,	/* expanded bits */
d944 5
a948 2
	  print_function_name (file, "issue", NULL,	/* format name */
			       entry->model->name, NULL,	/* expanded bits */
d951 5
a955 3
	  print_function_name (file, "run", NULL,	/* format name */
			       NULL,	/* NO processor */
			       NULL,	/* expanded bits */
d958 5
a962 2
	  print_function_name (file, "run", NULL,	/* format name */
			       entry->model->name, NULL,	/* expanded bits */
d973 1
a973 2
	  lf_printf (file,
		     "                  \"sim_engine_run - unknown machine\");\n");
d980 5
a984 3
  print_function_name (file, "run", NULL,	/* format name */
		       NULL,	/* NO processor */
		       NULL,	/* expanded bits */
d994 2
a995 1
do_gen (insn_table *isa, decode_table *decode_rules)
d1015 3
a1017 1
main (int argc, char **argv, char **envp)
d1027 1
a1027 2
  lf *standard_out =
    lf_open ("-", "stdout", lf_omit_references, lf_is_text, "igen");
d1041 1
a1041 2
      printf
	("\t This option can now be set directly in the instruction table.\n");
d1044 2
a1045 4
      printf
	("\t Dump the specified data structure to stdout. Valid structures include:\n");
      printf
	("\t processor-names - list the names of all the processors (models)\n");
d1048 1
a1048 2
      printf
	("\t Filter out any instructions with a non-empty flags field that contains\n");
d1052 2
a1053 4
      printf
	("\t Set the number of the high (most significant) instruction bit (deprecated).\n");
      printf
	("\t This option can now be set directly in the instruction table.\n");
d1056 1
a1056 2
      printf
	("\t Add <directory> to the list of directories searched when opening a file\n");
d1059 2
a1060 4
      printf
	("\t Filter out any instructions that do not support at least one of the listed\n");
      printf
	("\t models (An instructions with no model information is considered to support\n");
d1065 2
a1066 4
      printf
	("\t Specify `-N 0' to disable generation of the SMP. Specifying `-N 1' will\n");
      printf
	("\t still generate an SMP enabled simulator but will only support one CPU.\n");
d1069 1
a1069 2
      printf
	("\t Override the decode mechanism specified by the decode rules\n");
d1072 2
a1073 4
      printf
	("\t Prepend global names (except itable) with the string <prefix>.\n");
      printf
	("\t Specify -P <module>=<prefix> to set a specific <module>'s prefix.\n");
d1076 2
a1077 4
      printf
	("\t Replace a global name (suffix) (except itable) with the string <suffix>.\n");
      printf
	("\t Specify -S <module>=<suffix> to change a specific <module>'s name (suffix).\n");
d1082 1
a1082 2
      printf
	("\t Suppress warnings about discarded functions and instructions\n");
d1084 1
a1084 2
      printf
	("\t Suppress warnings about instructions with invalid widths\n");
d1091 1
a1091 2
      printf
	("\t decode-duplicate       - Override the decode rules, forcing the duplication of\n");
d1093 2
a1094 4
      printf
	("\t decode-combine         - Combine any duplicated entries within a table\n");
      printf
	("\t decode-zero-reserved   - Override the decode rules, forcing reserved bits to be\n");
d1096 1
a1096 2
      printf
	("\t decode-switch-is-goto  - Overfide the padded-switch code type as a goto-switch\n");
d1098 14
a1111 28
      printf
	("\t gen-conditional-issue  - conditionally issue each instruction\n");
      printf
	("\t gen-delayed-branch     - need both cia and nia passed around\n");
      printf
	("\t gen-direct-access      - use #defines to directly access values\n");
      printf
	("\t gen-zero-r<N>          - arch assumes GPR(<N>) == 0, keep it that way\n");
      printf
	("\t gen-icache[=<N>        - generate an instruction cracking cache of size <N>\n");
      printf ("\t                          Default size is %d\n",
	      options.gen.icache_size);
      printf
	("\t gen-insn-in-icache     - save original instruction when cracking\n");
      printf
	("\t gen-multi-sim[=MODEL]  - generate multiple simulators - one per model\n");
      printf
	("\t                          If specified MODEL is made the default architecture.\n");
      printf
	("\t                          By default, a single simulator that will\n");
      printf
	("\t                          execute any instruction is generated\n");
      printf
	("\t gen-multi-word         - generate code allowing for multi-word insns\n");
      printf
	("\t gen-semantic-icache    - include semantic code in cracking functions\n");
      printf
	("\t gen-slot-verification  - perform slot verification as part of decode\n");
d1115 2
a1116 4
      printf
	("\t trace-combine          - report combined entries a rule application\n");
      printf
	("\t trace-entries          - report entries after a rules application\n");
d1119 2
a1120 4
      printf
	("\t trace-insn-insertion   - report each instruction as it is inserted into a decode table\n");
      printf
	("\t trace-rule-expansion   - report each instruction as it is expanded (before insertion into a decode table)\n");
d1123 2
a1124 4
      printf
	("\t field-widths           - instruction formats specify widths (deprecated)\n");
      printf
	("\t                          By default, an instruction format specifies bit\n");
d1126 1
a1126 2
      printf
	("\t                          This option can now be set directly in the\n");
d1128 2
a1129 4
      printf
	("\t jumps                  - use jumps instead of function calls\n");
      printf
	("\t omit-line-numbers      - do not include line number information in the output\n");
d1140 2
a1141 4
      printf
	("  -n <real-name>        Specify the real name of the next output file\n");
      printf
	("  -h 		       Generate the header (.h) file rather than the body (.c)\n");
d1151 3
a1153 3

  while ((ch = getopt (argc, argv,
		       "B:D:F:G:H:I:M:N:P:T:W:o:k:i:n:hc:d:e:m:r:s:t:f:x"))
d1160 2
a1161 2

      switch (ch)
d1163 1
a1163 1

d1184 1
a1184 1

d1194 1
a1194 1

d1209 1
a1209 1

d1218 1
a1218 1

d1222 1
a1222 1

d1237 1
a1237 1
		chp = chp + 1;	/* skip `=' */
d1281 1
a1281 1
		abort ();	/* Bad switch.  */
d1286 5
a1290 6
	    while (*chp)
	      {
		if (islower (*chp))
		  *chp = toupper (*chp);
		chp++;
	      }
d1297 1
a1297 2
		options.module.semantics.prefix =
		  options.module.global.prefix;
d1306 1
a1306 2
		options.module.semantics.suffix =
		  options.module.global.suffix;
d1311 1
a1311 1

d1365 1
a1365 1

d1373 1
a1373 2
		options.warning (NULL,
				 "Option conditional-issue replaced by gen-conditional-issue\n");
d1382 1
a1382 2
		options.warning (NULL,
				 "Option delayed-branch replaced by gen-delayed-branch\n");
d1391 1
a1391 2
		options.warning (NULL,
				 "Option direct-access replaced by gen-direct-access\n");
d1402 1
a1402 2
		options.warning (NULL,
				 "Option zero-r<N> replaced by gen-zero-r<N>\n");
d1409 1
a1409 2
		    options.gen.icache_size =
		      atoi (argp + strlen ("gen-icache") + 1);
d1416 1
a1416 2
		    error (NULL,
			   "Expecting -Ggen-icache or -Ggen-icache=<N>\n");
d1423 1
a1423 2
	    else if (strncmp (argp, "gen-multi-sim", strlen ("gen-multi-sim"))
		     == 0)
d1431 2
a1432 4
		    if (!filter_is_member
			(options.model_filter, options.gen.default_model))
		      error (NULL, "multi-sim model %s unknown\n",
			     options.gen.default_model);
d1439 1
a1439 2
		    error (NULL,
			   "Expecting -Ggen-multi-sim or -Ggen-multi-sim=<MODEL>\n");
d1458 1
a1458 2
		options.warning (NULL,
				 "Option verify-slot replaced by gen-slot-verification\n");
d1467 1
a1467 2
		options.warning (NULL,
				 "Option default-nia-minus-one replaced by gen-nia-invalid\n");
d1519 1
a1519 1

d1541 1
a1541 1
	  real_file_name = strdup (optarg);
d1547 1
a1547 1

d1557 3
a1559 3
	    lf *file = lf_open (optarg, real_file_name, file_references,
				(is_header ? lf_is_h : lf_is_c),
				argv[0]);
d1562 1
a1562 2
		options.warning (NULL,
				 "Explicitly generate tables with -x option\n");
d1565 1
a1565 1
	    lf_print__file_start (file);
d1593 1
a1593 1
		if (is_header)
d1614 2
a1615 1
				isa->functions, isa->max_nr_words);
d1618 3
a1620 1
				gen->semantics, isa->functions, cache_rules);
d1623 2
a1624 2
	    lf_print__file_finish (file);
	    lf_close (file);
d1627 2
a1628 2
	  real_file_name = NULL;
	  break;
@


1.4.6.1
log
@Import all the copyright and indent changes from the mainline (also
richards's tweak).
@
text
@d1 1
a1 1
/* The IGEN simulator generator for GDB, the GNU Debugger.
d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d5 15
a19 18
   Contributed by Andrew Cagney.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d55 2
a56 1
print_semantic_function_formal (lf *file, int nr_prefetched_words)
d74 2
a75 1
			   options.module.global.prefix.l, word_nr);
d86 2
a87 1
			   options.module.global.prefix.l, word_nr);
d96 2
a97 1
print_semantic_function_actual (lf *file, int nr_prefetched_words)
d131 2
a132 1
print_icache_function_formal (lf *file, int nr_prefetched_words)
d137 1
a137 1
    nr += lf_printf (file, "sim_cpu *cpu,\n");
d139 1
a139 1
    nr += lf_printf (file, "SIM_DESC sd,\n");
d151 2
a152 1
print_icache_function_actual (lf *file, int nr_prefetched_words)
d186 2
a187 1
print_opcode_bits (lf *file, opcode_bits *bits)
d196 6
a201 9
  else if (!bits->opcode->is_boolean)
    {
      if (bits->opcode->last < bits->field->last)
	nr +=
	  lf_putint (file,
		     bits->value << (bits->field->last - bits->opcode->last));
      else
	nr += lf_putint (file, bits->value);
    }
d207 2
a208 1
print_c_name (lf *file, const char *name)
d264 1
a264 1

d273 1
a273 1

d291 2
a292 1
		  const char *format_name, opcode_bits *expanded_bits)
d301 2
a302 1
		       NULL, function_name_prefix_itable);
d309 2
a310 1
		       expanded_bits, function_name_prefix_none);
d318 2
a319 1
		       expanded_bits, function_name_prefix_none);
d329 2
a330 1
		       expanded_bits, function_name_prefix_none);
d340 1
a340 2
  lf_printf (file, "%sSD, CPU, cia, CIA, TRACE_LINENUM_P (CPU), \\\n",
	     prefix);
d342 2
a343 4
  lf_printf (file, "%sitable[MY_INDEX].file, \\\n",
	     options.module.itable.prefix.l);
  lf_printf (file, "%sitable[MY_INDEX].line_nr, \\\n",
	     options.module.itable.prefix.l);
d350 2
a351 1
print_itrace_format (lf *file, insn_mnemonic_entry *assembler)
d359 1
a359 1
      chp++;			/* skip the leading quote */
d399 1
a399 2
		error (assembler->line,
		       "Missing closing `>' in assembler string\n");
d430 1
a430 2
		      lf_printf (file, "%sstr_",
				 options.module.global.prefix.l);
d449 1
a449 1
		/* simple hex with 0x prefix */
d486 3
a488 1
print_itrace (lf *file, insn_entry * insn, int idecode)
d513 2
a514 1
			   is_first ? "" : "else ", assembler->condition);
d523 1
a523 2
		  error (assembler->line,
			 "Missing final unconditional assembler\n");
d541 1
a541 2
		  error (assembler->line,
			 "Unconditional assembler is not last\n");
d562 1
a562 3
    lf_printf (file,
	       "  trace_generic (SD, CPU, TRACE_%s_IDX, \" %%s\", itable[MY_INDEX].name);\n",
	       phase);
d572 2
a573 1
print_sim_engine_abort (lf *file, const char *message)
d582 2
a583 1
print_include (lf *file, igen_module module)
d589 2
a590 1
print_include_inline (lf *file, igen_module module)
d616 3
a618 1
gen_semantics_h (lf *file, insn_list *semantics, int max_nr_words)
d626 2
a627 1
      lf_printf (file, " %sidecode_semantic", options.module.global.prefix.l);
d660 3
a662 1
gen_semantics_c (lf *file, insn_list *semantics, cache_entry *cache_rules)
d697 2
a698 1
	      function_entry * functions, int max_nr_words)
d704 1
a704 1
      print_icache_function_type (file);
d706 3
a708 2
		 options.module.global.prefix.l, word_nr);
      print_icache_function_formal (file, word_nr);
d712 2
a713 1
  if (options.gen.code == generate_calls && options.gen.icache)
d737 2
a738 1
	      function_entry * functions, cache_entry *cache_rules)
d742 2
a743 1
  if (options.gen.code == generate_calls && options.gen.icache)
d779 3
a781 1
	       gen_table *gen, insn_table *insns, cache_entry *cache_rules)
d791 1
a791 2
      lf_printf (file, "} %sinstruction_address;\n",
		 options.module.global.prefix.l);
d797 1
a797 1

d824 1
a824 1
					       1 /*ALWAYS ONE WORD */ );
d831 1
a831 1
					       1 /*ALWAYS ONE WORD */ );
d839 3
a841 1
	       gen_table *gen, insn_table *isa, cache_entry *cache_rules)
d850 1
a850 1

d859 1
a859 1

d867 2
a868 2
						     1 /*is definition */ ,
						     1 /*ALWAYS ONE WORD */ );
d894 2
a895 1
gen_run_c (lf *file, gen_table *gen)
d906 1
a906 2
      print_idecode_issue_function_header (file, NULL, is_function_variable,
					   1);
d911 1
a911 1

d933 1
a933 2
		  || strcmp (entry->model->full_name,
			     options.gen.default_model) == 0))
d937 5
a941 3
	  print_function_name (file, "issue", NULL,	/* format name */
			       NULL,	/* NO processor */
			       NULL,	/* expanded bits */
d944 5
a948 2
	  print_function_name (file, "issue", NULL,	/* format name */
			       entry->model->name, NULL,	/* expanded bits */
d951 5
a955 3
	  print_function_name (file, "run", NULL,	/* format name */
			       NULL,	/* NO processor */
			       NULL,	/* expanded bits */
d958 5
a962 2
	  print_function_name (file, "run", NULL,	/* format name */
			       entry->model->name, NULL,	/* expanded bits */
d973 1
a973 2
	  lf_printf (file,
		     "                  \"sim_engine_run - unknown machine\");\n");
d980 5
a984 3
  print_function_name (file, "run", NULL,	/* format name */
		       NULL,	/* NO processor */
		       NULL,	/* expanded bits */
d994 2
a995 1
do_gen (insn_table *isa, decode_table *decode_rules)
d1015 3
a1017 1
main (int argc, char **argv, char **envp)
d1027 1
a1027 2
  lf *standard_out =
    lf_open ("-", "stdout", lf_omit_references, lf_is_text, "igen");
d1041 1
a1041 2
      printf
	("\t This option can now be set directly in the instruction table.\n");
d1044 2
a1045 4
      printf
	("\t Dump the specified data structure to stdout. Valid structures include:\n");
      printf
	("\t processor-names - list the names of all the processors (models)\n");
d1048 1
a1048 2
      printf
	("\t Filter out any instructions with a non-empty flags field that contains\n");
d1052 2
a1053 4
      printf
	("\t Set the number of the high (most significant) instruction bit (deprecated).\n");
      printf
	("\t This option can now be set directly in the instruction table.\n");
d1056 1
a1056 2
      printf
	("\t Add <directory> to the list of directories searched when opening a file\n");
d1059 2
a1060 4
      printf
	("\t Filter out any instructions that do not support at least one of the listed\n");
      printf
	("\t models (An instructions with no model information is considered to support\n");
d1065 2
a1066 4
      printf
	("\t Specify `-N 0' to disable generation of the SMP. Specifying `-N 1' will\n");
      printf
	("\t still generate an SMP enabled simulator but will only support one CPU.\n");
d1069 1
a1069 2
      printf
	("\t Override the decode mechanism specified by the decode rules\n");
d1072 2
a1073 4
      printf
	("\t Prepend global names (except itable) with the string <prefix>.\n");
      printf
	("\t Specify -P <module>=<prefix> to set a specific <module>'s prefix.\n");
d1076 2
a1077 4
      printf
	("\t Replace a global name (suffix) (except itable) with the string <suffix>.\n");
      printf
	("\t Specify -S <module>=<suffix> to change a specific <module>'s name (suffix).\n");
d1082 1
a1082 2
      printf
	("\t Suppress warnings about discarded functions and instructions\n");
d1084 1
a1084 2
      printf
	("\t Suppress warnings about instructions with invalid widths\n");
d1091 1
a1091 2
      printf
	("\t decode-duplicate       - Override the decode rules, forcing the duplication of\n");
d1093 2
a1094 4
      printf
	("\t decode-combine         - Combine any duplicated entries within a table\n");
      printf
	("\t decode-zero-reserved   - Override the decode rules, forcing reserved bits to be\n");
d1096 1
a1096 2
      printf
	("\t decode-switch-is-goto  - Overfide the padded-switch code type as a goto-switch\n");
d1098 14
a1111 28
      printf
	("\t gen-conditional-issue  - conditionally issue each instruction\n");
      printf
	("\t gen-delayed-branch     - need both cia and nia passed around\n");
      printf
	("\t gen-direct-access      - use #defines to directly access values\n");
      printf
	("\t gen-zero-r<N>          - arch assumes GPR(<N>) == 0, keep it that way\n");
      printf
	("\t gen-icache[=<N>        - generate an instruction cracking cache of size <N>\n");
      printf ("\t                          Default size is %d\n",
	      options.gen.icache_size);
      printf
	("\t gen-insn-in-icache     - save original instruction when cracking\n");
      printf
	("\t gen-multi-sim[=MODEL]  - generate multiple simulators - one per model\n");
      printf
	("\t                          If specified MODEL is made the default architecture.\n");
      printf
	("\t                          By default, a single simulator that will\n");
      printf
	("\t                          execute any instruction is generated\n");
      printf
	("\t gen-multi-word         - generate code allowing for multi-word insns\n");
      printf
	("\t gen-semantic-icache    - include semantic code in cracking functions\n");
      printf
	("\t gen-slot-verification  - perform slot verification as part of decode\n");
d1115 2
a1116 4
      printf
	("\t trace-combine          - report combined entries a rule application\n");
      printf
	("\t trace-entries          - report entries after a rules application\n");
d1119 2
a1120 4
      printf
	("\t trace-insn-insertion   - report each instruction as it is inserted into a decode table\n");
      printf
	("\t trace-rule-expansion   - report each instruction as it is expanded (before insertion into a decode table)\n");
d1123 2
a1124 4
      printf
	("\t field-widths           - instruction formats specify widths (deprecated)\n");
      printf
	("\t                          By default, an instruction format specifies bit\n");
d1126 1
a1126 2
      printf
	("\t                          This option can now be set directly in the\n");
d1128 2
a1129 4
      printf
	("\t jumps                  - use jumps instead of function calls\n");
      printf
	("\t omit-line-numbers      - do not include line number information in the output\n");
d1140 2
a1141 4
      printf
	("  -n <real-name>        Specify the real name of the next output file\n");
      printf
	("  -h 		       Generate the header (.h) file rather than the body (.c)\n");
d1151 3
a1153 3

  while ((ch = getopt (argc, argv,
		       "B:D:F:G:H:I:M:N:P:T:W:o:k:i:n:hc:d:e:m:r:s:t:f:x"))
d1160 2
a1161 2

      switch (ch)
d1163 1
a1163 1

d1184 1
a1184 1

d1194 1
a1194 1

d1209 1
a1209 1

d1218 1
a1218 1

d1222 1
a1222 1

d1237 1
a1237 1
		chp = chp + 1;	/* skip `=' */
d1281 1
a1281 1
		abort ();	/* Bad switch.  */
d1286 5
a1290 6
	    while (*chp)
	      {
		if (islower (*chp))
		  *chp = toupper (*chp);
		chp++;
	      }
d1297 1
a1297 2
		options.module.semantics.prefix =
		  options.module.global.prefix;
d1306 1
a1306 2
		options.module.semantics.suffix =
		  options.module.global.suffix;
d1311 1
a1311 1

d1365 1
a1365 1

d1373 1
a1373 2
		options.warning (NULL,
				 "Option conditional-issue replaced by gen-conditional-issue\n");
d1382 1
a1382 2
		options.warning (NULL,
				 "Option delayed-branch replaced by gen-delayed-branch\n");
d1391 1
a1391 2
		options.warning (NULL,
				 "Option direct-access replaced by gen-direct-access\n");
d1402 1
a1402 2
		options.warning (NULL,
				 "Option zero-r<N> replaced by gen-zero-r<N>\n");
d1409 1
a1409 2
		    options.gen.icache_size =
		      atoi (argp + strlen ("gen-icache") + 1);
d1416 1
a1416 2
		    error (NULL,
			   "Expecting -Ggen-icache or -Ggen-icache=<N>\n");
d1423 1
a1423 2
	    else if (strncmp (argp, "gen-multi-sim", strlen ("gen-multi-sim"))
		     == 0)
d1431 2
a1432 4
		    if (!filter_is_member
			(options.model_filter, options.gen.default_model))
		      error (NULL, "multi-sim model %s unknown\n",
			     options.gen.default_model);
d1439 1
a1439 2
		    error (NULL,
			   "Expecting -Ggen-multi-sim or -Ggen-multi-sim=<MODEL>\n");
d1458 1
a1458 2
		options.warning (NULL,
				 "Option verify-slot replaced by gen-slot-verification\n");
d1467 1
a1467 2
		options.warning (NULL,
				 "Option default-nia-minus-one replaced by gen-nia-invalid\n");
d1519 1
a1519 1

d1541 1
a1541 1
	  real_file_name = strdup (optarg);
d1547 1
a1547 1

d1557 3
a1559 3
	    lf *file = lf_open (optarg, real_file_name, file_references,
				(is_header ? lf_is_h : lf_is_c),
				argv[0]);
d1562 1
a1562 2
		options.warning (NULL,
				 "Explicitly generate tables with -x option\n");
d1565 1
a1565 1
	    lf_print__file_start (file);
d1593 1
a1593 1
		if (is_header)
d1614 2
a1615 1
				isa->functions, isa->max_nr_words);
d1618 3
a1620 1
				gen->semantics, isa->functions, cache_rules);
d1623 2
a1624 2
	    lf_print__file_finish (file);
	    lf_close (file);
d1627 2
a1628 2
	  real_file_name = NULL;
	  break;
@


1.3
log
@[ common/ChangeLog ]
2002-05-01  Chris Demetriou  <cgd@@broadcom.com>

        * callback.c: Use 'deprecated' rather than 'depreciated.'

[ igen/ChangeLog ]
2002-05-01  Chris Demetriou  <cgd@@broadcom.com>

        * igen.c: Use 'deprecated' rather than 'depreciated.'

[ mips/ChangeLog ]
2002-05-01  Chris Demetriou  <cgd@@broadcom.com>

        * interp.c: Use 'deprecated' rather than 'depreciated.'
        * sim-main.h: Likewise.
@
text
@d1280 2
@


1.3.4.1
log
@merge with trunk
@
text
@a1279 2
	      default:
		abort (); /* Bad switch.  */
@


1.3.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@a1279 2
	      default:
		abort (); /* Bad switch.  */
@


1.2
log
@2002-03-07  Chris Demetriou  <cgd@@broadcom.com>

        * igen.c (print_itrace_format): Add support for a new "%#lx" format.
@
text
@d1040 1
a1040 1
      printf ("\t Set the number of bits in an instruction (depreciated).\n");
d1052 1
a1052 1
      printf ("\t Set the number of the high (most significant) instruction bit (depreciated).\n");
d1123 1
a1123 1
      printf ("\t field-widths           - instruction formats specify widths (depreciated)\n");
d1133 1
a1133 1
      printf ("  -k <cache-rules> (depreciated)\n");
@


1.1
log
@Initial revision
@
text
@d448 11
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@

