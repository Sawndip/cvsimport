head	1.14;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.14
	gdb_7_6-2013-04-26-release:1.14
	gdb_7_6-branch:1.14.0.2
	gdb_7_6-2013-03-12-branchpoint:1.14
	gdb_7_5_1-2012-11-29-release:1.13
	gdb_7_5-2012-08-17-release:1.13
	gdb_7_5-branch:1.13.0.2
	gdb_7_5-2012-07-18-branchpoint:1.13
	gdb_7_4_1-2012-04-26-release:1.12.2.1
	gdb_7_4-2012-01-24-release:1.12.2.1
	gdb_7_4-branch:1.12.0.2
	gdb_7_4-2011-12-13-branchpoint:1.12
	gdb_7_3_1-2011-09-04-release:1.11
	gdb_7_3-2011-07-26-release:1.11
	gdb_7_3-branch:1.11.0.2
	gdb_7_3-2011-04-01-branchpoint:1.11
	gdb_7_2-2010-09-02-release:1.10
	gdb_7_2-branch:1.10.0.4
	gdb_7_2-2010-07-07-branchpoint:1.10
	gdb_7_1-2010-03-18-release:1.10
	gdb_7_1-branch:1.10.0.2
	gdb_7_1-2010-02-18-branchpoint:1.10
	gdb_7_0_1-2009-12-22-release:1.9
	gdb_7_0-2009-10-06-release:1.9
	gdb_7_0-branch:1.9.0.4
	gdb_7_0-2009-09-16-branchpoint:1.9
	arc-sim-20090309:1.8
	msnyder-checkpoint-072509-branch:1.9.0.2
	msnyder-checkpoint-072509-branchpoint:1.9
	arc-insight_6_8-branch:1.8.0.16
	arc-insight_6_8-branchpoint:1.8
	insight_6_8-branch:1.8.0.14
	insight_6_8-branchpoint:1.8
	reverse-20081226-branch:1.8.0.12
	reverse-20081226-branchpoint:1.8
	multiprocess-20081120-branch:1.8.0.10
	multiprocess-20081120-branchpoint:1.8
	reverse-20080930-branch:1.8.0.8
	reverse-20080930-branchpoint:1.8
	reverse-20080717-branch:1.8.0.6
	reverse-20080717-branchpoint:1.8
	msnyder-reverse-20080609-branch:1.8.0.4
	msnyder-reverse-20080609-branchpoint:1.8
	drow-reverse-20070409-branch:1.6.0.2
	drow-reverse-20070409-branchpoint:1.6
	gdb_6_8-2008-03-27-release:1.8
	gdb_6_8-branch:1.8.0.2
	gdb_6_8-2008-02-26-branchpoint:1.8
	gdb_6_7_1-2007-10-29-release:1.7
	gdb_6_7-2007-10-10-release:1.7
	gdb_6_7-branch:1.7.0.2
	gdb_6_7-2007-09-07-branchpoint:1.7
	insight_6_6-20070208-release:1.5
	gdb_6_6-2006-12-18-release:1.5
	gdb_6_6-branch:1.5.0.88
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb-csl-symbian-6_4_50_20060226-12:1.5
	gdb-csl-sourcerygxx-3_4_4-25:1.5
	nickrob-async-20060828-mergepoint:1.5
	gdb-csl-symbian-6_4_50_20060226-11:1.5
	gdb-csl-sourcerygxx-4_1-17:1.5
	gdb-csl-20060226-branch-local-2:1.5
	gdb-csl-sourcerygxx-4_1-14:1.5
	gdb-csl-sourcerygxx-4_1-13:1.5
	gdb-csl-sourcerygxx-4_1-12:1.5
	gdb-csl-sourcerygxx-3_4_4-21:1.5
	gdb_6_5-20060621-release:1.5
	gdb-csl-sourcerygxx-4_1-9:1.5
	gdb-csl-sourcerygxx-4_1-8:1.5
	gdb-csl-sourcerygxx-4_1-7:1.5
	gdb-csl-arm-2006q1-6:1.5
	gdb-csl-sourcerygxx-4_1-6:1.5
	gdb-csl-symbian-6_4_50_20060226-10:1.5
	gdb-csl-symbian-6_4_50_20060226-9:1.5
	gdb-csl-symbian-6_4_50_20060226-8:1.5
	gdb-csl-coldfire-4_1-11:1.5
	gdb-csl-sourcerygxx-3_4_4-19:1.5
	gdb-csl-coldfire-4_1-10:1.5
	gdb_6_5-branch:1.5.0.86
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb-csl-sourcerygxx-4_1-5:1.5
	nickrob-async-20060513-branch:1.5.0.84
	nickrob-async-20060513-branchpoint:1.5
	gdb-csl-sourcerygxx-4_1-4:1.5
	msnyder-reverse-20060502-branch:1.5.0.82
	msnyder-reverse-20060502-branchpoint:1.5
	gdb-csl-morpho-4_1-4:1.5
	gdb-csl-sourcerygxx-3_4_4-17:1.5
	readline_5_1-import-branch:1.5.0.80
	readline_5_1-import-branchpoint:1.5
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.5
	gdb-csl-symbian-20060226-branch:1.5.0.78
	gdb-csl-symbian-20060226-branchpoint:1.5
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.5
	msnyder-reverse-20060331-branch:1.5.0.76
	msnyder-reverse-20060331-branchpoint:1.5
	gdb-csl-available-20060303-branch:1.5.0.74
	gdb-csl-available-20060303-branchpoint:1.5
	gdb-csl-20060226-branch:1.5.0.72
	gdb-csl-20060226-branchpoint:1.5
	gdb_6_4-20051202-release:1.5
	msnyder-fork-checkpoint-branch:1.5.0.70
	msnyder-fork-checkpoint-branchpoint:1.5
	gdb-csl-gxxpro-6_3-branch:1.5.0.68
	gdb-csl-gxxpro-6_3-branchpoint:1.5
	gdb_6_4-branch:1.5.0.66
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb-csl-arm-20051020-branch:1.5.0.64
	gdb-csl-arm-20051020-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.62
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb-csl-arm-20050325-2005-q1b:1.5
	gdb-csl-arm-20050325-2005-q1a:1.5
	csl-arm-20050325-branch:1.5.0.60
	csl-arm-20050325-branchpoint:1.5
	gdb_6_3-20041109-release:1.5
	gdb_6_3-branch:1.5.0.56
	gdb_6_3-20041019-branchpoint:1.5
	drow_intercu-merge-20040921:1.5
	drow_intercu-merge-20040915:1.5
	jimb-gdb_6_2-e500-branch:1.5.0.58
	jimb-gdb_6_2-e500-branchpoint:1.5
	gdb_6_2-20040730-release:1.5
	gdb_6_2-branch:1.5.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.5
	gdb_6_1_1-20040616-release:1.5
	gdb_6_1-2004-04-05-release:1.5
	drow_intercu-merge-20040402:1.5
	drow_intercu-merge-20040327:1.5
	ezannoni_pie-20040323-branch:1.5.0.52
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.50
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow_intercu-20040221-branch:1.5.0.46
	drow_intercu-20040221-branchpoint:1.5
	cagney_bfdfile-20040213-branch:1.5.0.44
	cagney_bfdfile-20040213-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	cagney_bigcore-20040122-branch:1.5.0.42
	cagney_bigcore-20040122-branchpoint:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	kettenis_sparc-20030918-branch:1.5.0.40
	kettenis_sparc-20030918-branchpoint:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.38
	cagney_x86i386-20030821-branch:1.5.0.36
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.34
	gdb_6_0-2003-06-23-branchpoint:1.5
	jimb-ppc64-linux-20030613-branch:1.5.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.30
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.28
	cagney_writestrings-20030508-branchpoint:1.5
	jimb-ppc64-linux-20030528-branch:1.5.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.24
	cagney_fileio-20030521-branchpoint:1.5
	kettenis_i386newframe-20030517-mergepoint:1.5
	jimb-ppc64-linux-20030509-branch:1.5.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.5
	kettenis_i386newframe-20030504-mergepoint:1.5
	carlton_dictionary-20030430-merge:1.5
	kettenis_i386newframe-20030419-branch:1.5.0.20
	kettenis_i386newframe-20030419-branchpoint:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	kettenis_i386newframe-20030406-branch:1.5.0.18
	kettenis_i386newframe-20030406-branchpoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.16
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.14
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.12
	cagney_lazyid-20030317-branchpoint:1.5
	kettenis-i386newframe-20030316-mergepoint:1.5
	offbyone-20030313-branch:1.5.0.10
	offbyone-20030313-branchpoint:1.5
	kettenis-i386newframe-20030308-branch:1.5.0.8
	kettenis-i386newframe-20030308-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.6
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.4
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.2
	cagney-unwind-20030108-branchpoint:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.2.6.1
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.2
	kseitz_interps-20021103-merge:1.2
	drow-cplus-merge-20021020:1.2
	drow-cplus-merge-20021025:1.2
	carlton_dictionary-20021025-merge:1.2
	carlton_dictionary-20021011-merge:1.2
	drow-cplus-branch:1.2.0.10
	drow-cplus-branchpoint:1.2
	kseitz_interps-20020930-merge:1.2
	carlton_dictionary-20020927-merge:1.2
	carlton_dictionary-branch:1.2.0.8
	carlton_dictionary-20020920-branchpoint:1.2
	gdb_5_3-branch:1.2.0.6
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.4
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.2
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.1.1.1
	kseitz_interps-20020528-branch:1.1.1.1.0.20
	kseitz_interps-20020528-branchpoint:1.1.1.1
	cagney_regbuf-20020515-branch:1.1.1.1.0.18
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	jimb-macro-020506-branch:1.1.1.1.0.16
	jimb-macro-020506-branchpoint:1.1.1.1
	gdb_5_2-2002-04-29-release:1.1.1.1
	gdb_5_2-branch:1.1.1.1.0.14
	gdb_5_2-2002-03-03-branchpoint:1.1.1.1
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.12
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.10
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.8
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.14
date	2013.01.01.06.41.37;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2012.01.04.08.28.11;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2011.07.08.02.27.18;	author hp;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2011.01.01.15.34.00;	author brobecke;	state Exp;
branches;
next	1.10;

1.10
date	2010.01.01.10.03.30;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.14.10.53.07;	author brobecke;	state Exp;
branches;
next	1.8;

1.8
date	2008.01.01.22.53.24;	author drow;	state Exp;
branches;
next	1.7;

1.7
date	2007.08.24.14.28.36;	author brobecke;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.09.17.59.18;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2002.11.22.04.20.49;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.22.04.09.40;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.06.18.41.09;	author cgd;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.03.16.04.31;	author rth;	state Exp;
branches
	1.2.6.1
	1.2.8.1
	1.2.10.1;
next	1.1;

1.1
date	99.04.16.01.35.04;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.12.2.1
date	2012.01.06.04.54.49;	author brobecke;	state Exp;
branches;
next	;

1.2.6.1
date	2002.11.22.04.26.42;	author cagney;	state Exp;
branches;
next	;

1.2.8.1
date	2002.11.15.19.19.28;	author carlton;	state Exp;
branches;
next	1.2.8.2;

1.2.8.2
date	2002.12.23.19.39.54;	author carlton;	state Exp;
branches;
next	;

1.2.10.1
date	2003.12.14.20.28.22;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.35.04;	author shebs;	state Exp;
branches
	1.1.1.1.18.1
	1.1.1.1.20.1;
next	;

1.1.1.1.18.1
date	2002.06.15.16.43.25;	author cagney;	state Exp;
branches;
next	;

1.1.1.1.20.1
date	2002.06.20.01.39.54;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* The IGEN simulator generator for GDB, the GNU Debugger.

   Copyright 2002-2013 Free Software Foundation, Inc.

   Contributed by Andrew Cagney.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "misc.h"
#include "lf.h"
#include "table.h"
#include "filter.h"

#include "igen.h"

#include "ld-insn.h"
#include "ld-decode.h"

#include "gen.h"

#include "gen-idecode.h"
#include "gen-engine.h"
#include "gen-icache.h"
#include "gen-semantics.h"


static void
print_engine_issue_prefix_hook (lf *file)
{
  lf_printf (file, "\n");
  lf_indent_suppress (file);
  lf_printf (file, "#if defined (ENGINE_ISSUE_PREFIX_HOOK)\n");
  lf_printf (file, "ENGINE_ISSUE_PREFIX_HOOK();\n");
  lf_indent_suppress (file);
  lf_printf (file, "#endif\n");
  lf_printf (file, "\n");
}

static void
print_engine_issue_postfix_hook (lf *file)
{
  lf_printf (file, "\n");
  lf_indent_suppress (file);
  lf_printf (file, "#if defined (ENGINE_ISSUE_POSTFIX_HOOK)\n");
  lf_printf (file, "ENGINE_ISSUE_POSTFIX_HOOK();\n");
  lf_indent_suppress (file);
  lf_printf (file, "#endif\n");
  lf_printf (file, "\n");
}


static void
print_run_body (lf *file, gen_entry *table)
{
  /* Output the function to execute real code:

     Unfortunatly, there are multiple cases to consider vis:

     <icache> X <smp>

     Consequently this function is written in multiple different ways */

  lf_printf (file, "{\n");
  lf_indent (file, +2);
  if (!options.gen.smp)
    {
      lf_printf (file, "%sinstruction_address cia;\n",
		 options.module.global.prefix.l);
    }
  lf_printf (file, "int current_cpu = next_cpu_nr;\n");

  if (options.gen.icache)
    {
      lf_printf (file, "/* flush the icache of a possible break insn */\n");
      lf_printf (file, "{\n");
      lf_printf (file, "  int cpu_nr;\n");
      lf_printf (file, "  for (cpu_nr = 0; cpu_nr < nr_cpus; cpu_nr++)\n");
      lf_printf (file, "    cpu_flush_icache (STATE_CPU (sd, cpu_nr));\n");
      lf_printf (file, "}\n");
    }

  if (!options.gen.smp)
    {

      lf_putstr (file, "\
/* CASE 1: NO SMP (with or with out instruction cache).\n\
\n\
In this case, we can take advantage of the fact that the current\n\
instruction address (CIA) does not need to be read from / written to\n\
the CPU object after the execution of an instruction.\n\
\n\
Instead, CIA is only saved when the main loop exits.  This occures\n\
when either sim_engine_halt or sim_engine_restart is called.  Both of\n\
these functions save the current instruction address before halting /\n\
restarting the simulator.\n\
\n\
As a variation, there may also be support for an instruction cracking\n\
cache. */\n\
\n\
");

      lf_putstr (file, "\n");
      lf_putstr (file, "/* prime the main loop */\n");
      lf_putstr (file, "SIM_ASSERT (current_cpu == 0);\n");
      lf_putstr (file, "SIM_ASSERT (nr_cpus == 1);\n");
      lf_putstr (file, "cia = CIA_GET (CPU);\n");

      lf_putstr (file, "\n");
      lf_putstr (file, "while (1)\n");
      lf_putstr (file, "  {\n");
      lf_indent (file, +4);

      lf_printf (file, "%sinstruction_address nia;\n",
		 options.module.global.prefix.l);

      lf_printf (file, "\n");
      if (!options.gen.icache)
	{
	  lf_printf (file,
		     "%sinstruction_word instruction_0 = IMEM%d (cia);\n",
		     options.module.global.prefix.l, options.insn_bit_size);
	  print_engine_issue_prefix_hook (file);
	  print_idecode_body (file, table, "nia = ");
	  print_engine_issue_postfix_hook (file);
	}
      else
	{
	  lf_putstr (file, "idecode_cache *cache_entry =\n");
	  lf_putstr (file, "  cpu_icache_entry (cpu, cia);\n");
	  lf_putstr (file, "if (cache_entry->address == cia)\n");
	  lf_putstr (file, "  {\n");
	  lf_indent (file, -4);
	  lf_putstr (file, "/* cache hit */\n");
	  lf_putstr (file,
		     "idecode_semantic *const semantic = cache_entry->semantic;\n");
	  lf_putstr (file, "cia = semantic (cpu, cache_entry, cia);\n");
	  /* tail */
	  lf_indent (file, -4);
	  lf_putstr (file, "  }\n");
	  lf_putstr (file, "else\n");
	  lf_putstr (file, "  {\n");
	  lf_indent (file, +4);
	  lf_putstr (file, "/* cache miss */\n");
	  if (!options.gen.semantic_icache)
	    {
	      lf_putstr (file, "idecode_semantic *semantic;\n");
	    }
	  lf_printf (file, "instruction_word instruction = IMEM%d (cia);\n",
		     options.insn_bit_size);
	  lf_putstr (file, "if (WITH_MON != 0)\n");
	  lf_putstr (file,
		     "  mon_event (mon_event_icache_miss, cpu, cia);\n");
	  if (options.gen.semantic_icache)
	    {
	      lf_putstr (file, "{\n");
	      lf_indent (file, +2);
	      print_engine_issue_prefix_hook (file);
	      print_idecode_body (file, table, "nia =");
	      print_engine_issue_postfix_hook (file);
	      lf_indent (file, -2);
	      lf_putstr (file, "}\n");
	    }
	  else
	    {
	      print_engine_issue_prefix_hook (file);
	      print_idecode_body (file, table, "semantic =");
	      lf_putstr (file, "nia = semantic (cpu, cache_entry, cia);\n");
	      print_engine_issue_postfix_hook (file);
	    }
	  lf_indent (file, -4);
	  lf_putstr (file, "  }\n");
	}

      /* update the cpu if necessary */
      switch (options.gen.nia)
	{
	case nia_is_cia_plus_one:
	  lf_printf (file, "\n");
	  lf_printf (file, "/* Update the instruction address */\n");
	  lf_printf (file, "cia = nia;\n");
	  break;
	case nia_is_void:
	case nia_is_invalid:
	  ERROR ("engine gen when NIA complex");
	}

      /* events */
      lf_putstr (file, "\n");
      lf_putstr (file, "/* process any events */\n");
      lf_putstr (file, "if (sim_events_tick (sd))\n");
      lf_putstr (file, "  {\n");
      lf_putstr (file, "    CIA_SET (CPU, cia);\n");
      lf_putstr (file, "    sim_events_process (sd);\n");
      lf_putstr (file, "    cia = CIA_GET (CPU);\n");
      lf_putstr (file, "  }\n");

      lf_indent (file, -4);
      lf_printf (file, "  }\n");
    }

  if (options.gen.smp)
    {

      lf_putstr (file, "\
/* CASE 2: SMP (With or without ICACHE)\n\
\n\
The complexity here comes from needing to correctly halt the simulator\n\
when it is aborted.  For instance, if cpu0 requests a restart then\n\
cpu1 will normally be the next cpu that is run.  Cpu0 being restarted\n\
after all the other CPU's and the event queue have been processed */\n\
\n\
");

      lf_putstr (file, "\n");
      lf_printf (file,
		 "/* have ensured that the event queue is NOT next */\n");
      lf_printf (file, "SIM_ASSERT (current_cpu >= 0);\n");
      lf_printf (file, "SIM_ASSERT (current_cpu <= nr_cpus - 1);\n");
      lf_printf (file, "SIM_ASSERT (nr_cpus <= MAX_NR_PROCESSORS);\n");

      lf_putstr (file, "\n");
      lf_putstr (file, "while (1)\n");
      lf_putstr (file, "  {\n");
      lf_indent (file, +4);
      lf_putstr (file, "sim_cpu *cpu = STATE_CPU (sd, current_cpu);\n");
      lf_putstr (file, "instruction_address cia = CIA_GET (cpu);\n");
      lf_putstr (file, "\n");

      if (!options.gen.icache)
	{
	  lf_printf (file, "instruction_word instruction_0 = IMEM%d (cia);\n",
		     options.insn_bit_size);
	  print_engine_issue_prefix_hook (file);
	  print_idecode_body (file, table, "cia =");
	  lf_putstr (file, "CIA_SET (cpu, cia);\n");
	  print_engine_issue_postfix_hook (file);
	}

      if (options.gen.icache)
	{
	  lf_putstr (file, "engine_cache *cache_entry =\n");
	  lf_putstr (file, "  cpu_icache_entry(processor, cia);\n");
	  lf_putstr (file, "\n");
	  lf_putstr (file, "if (cache_entry->address == cia) {\n");
	  {
	    lf_indent (file, +2);
	    lf_putstr (file, "\n");
	    lf_putstr (file, "/* cache hit */\n");
	    lf_putstr (file,
		       "engine_semantic *semantic = cache_entry->semantic;\n");
	    lf_putstr (file,
		       "cia = semantic(processor, cache_entry, cia);\n");
	    /* tail */
	    lf_putstr (file, "cpu_set_program_counter(processor, cia);\n");
	    lf_putstr (file, "\n");
	    lf_indent (file, -2);
	  }
	  lf_putstr (file, "}\n");
	  lf_putstr (file, "else {\n");
	  {
	    lf_indent (file, +2);
	    lf_putstr (file, "\n");
	    lf_putstr (file, "/* cache miss */\n");
	    if (!options.gen.semantic_icache)
	      {
		lf_putstr (file, "engine_semantic *semantic;\n");
	      }
	    lf_printf (file, "instruction_word instruction = IMEM%d (cia);\n",
		       options.insn_bit_size);
	    lf_putstr (file, "if (WITH_MON != 0)\n");
	    lf_putstr (file,
		       "  mon_event(mon_event_icache_miss, processors[current_cpu], cia);\n");
	    if (options.gen.semantic_icache)
	      {
		lf_putstr (file, "{\n");
		lf_indent (file, +2);
		print_engine_issue_prefix_hook (file);
		print_idecode_body (file, table, "cia =");
		print_engine_issue_postfix_hook (file);
		lf_indent (file, -2);
		lf_putstr (file, "}\n");
	      }
	    else
	      {
		print_engine_issue_prefix_hook (file);
		print_idecode_body (file, table, "semantic = ");
		lf_putstr (file,
			   "cia = semantic(processor, cache_entry, cia);\n");
		print_engine_issue_postfix_hook (file);
	      }
	    /* tail */
	    lf_putstr (file, "cpu_set_program_counter(processor, cia);\n");
	    lf_putstr (file, "\n");
	    lf_indent (file, -2);
	  }
	  lf_putstr (file, "}\n");
	}

      lf_putstr (file, "\n");
      lf_putstr (file, "current_cpu += 1;\n");
      lf_putstr (file, "if (current_cpu == nr_cpus)\n");
      lf_putstr (file, "  {\n");
      lf_putstr (file, "    if (sim_events_tick (sd))\n");
      lf_putstr (file, "      {\n");
      lf_putstr (file, "        sim_events_process (sd);\n");
      lf_putstr (file, "      }\n");
      lf_putstr (file, "    current_cpu = 0;\n");
      lf_putstr (file, "  }\n");

      /* tail */
      lf_indent (file, -4);
      lf_putstr (file, "  }\n");
    }


  lf_indent (file, -2);
  lf_putstr (file, "}\n");
}


/****************************************************************/

void
print_engine_run_function_header (lf *file,
				  char *processor,
				  function_decl_type decl_type)
{
  int indent;
  lf_printf (file, "\n");
  switch (decl_type)
    {
    case is_function_declaration:
      lf_print__function_type (file, "void", "INLINE_ENGINE", "\n");
      break;
    case is_function_definition:
      lf_print__function_type (file, "void", "INLINE_ENGINE", " ");
      break;
    case is_function_variable:
      lf_printf (file, "void (*");
      break;
    }
  indent = print_function_name (file, "run", NULL,	/* format name */
				processor, NULL,	/* expanded bits */
				function_name_prefix_engine);
  switch (decl_type)
    {
    case is_function_definition:
      lf_putstr (file, "\n(");
      indent = 1;
      break;
    case is_function_declaration:
      indent += lf_printf (file, " (");
      break;
    case is_function_variable:
      lf_putstr (file, ")\n(");
      indent = 1;
      break;
    }
  lf_indent (file, +indent);
  lf_printf (file, "SIM_DESC sd,\n");
  lf_printf (file, "int next_cpu_nr,\n");
  lf_printf (file, "int nr_cpus,\n");
  lf_printf (file, "int siggnal)");
  lf_indent (file, -indent);
  switch (decl_type)
    {
    case is_function_definition:
      lf_putstr (file, "\n");
      break;
    case is_function_variable:
    case is_function_declaration:
      lf_putstr (file, ";\n");
      break;
    }
}


void
gen_engine_h (lf *file,
	      gen_table *gen, insn_table *isa, cache_entry *cache_rules)
{
  gen_list *entry;
  for (entry = gen->tables; entry != NULL; entry = entry->next)
    {
      print_engine_run_function_header (file,
					(options.gen.multi_sim
					 ? entry->model->name
					 : NULL), is_function_declaration);
    }
}


void
gen_engine_c (lf *file,
	      gen_table *gen, insn_table *isa, cache_entry *cache_rules)
{
  gen_list *entry;
  /* the intro */
  print_includes (file);
  print_include_inline (file, options.module.semantics);
  print_include (file, options.module.engine);
  lf_printf (file, "\n");
  lf_printf (file, "#include \"sim-assert.h\"\n");
  lf_printf (file, "\n");
  print_idecode_globals (file);
  lf_printf (file, "\n");

  for (entry = gen->tables; entry != NULL; entry = entry->next)
    {
      switch (options.gen.code)
	{
	case generate_calls:
	  print_idecode_lookups (file, entry->table, cache_rules);

	  /* output the main engine routine */
	  print_engine_run_function_header (file,
					    (options.gen.multi_sim
					     ? entry->model->name
					     : NULL), is_function_definition);
	  print_run_body (file, entry->table);
	  break;

	case generate_jumps:
	  ERROR ("Jumps currently unimplemented");
	  break;
	}
    }
}
@


1.13
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright 2002, 2007-2012 Free Software Foundation, Inc.
@


1.12
log
@	Remove all #if 0'd code.
	* filter.c: Remove #if 0'd function it_is.
	(main): Remove #if 0'd code.
	* gen-engine.c: Remove #if 0'd functions print_jump,
	print_jump_insn, print_jump_definition,
	print_jump_internal_function, print_jump_body.
	(gen_engine_c): Remove #if 0'd code.
	* gen-idecode.c: Remove #if 0'd functions print_jump print_jump,
	print_jump_insn, print_jump_definition,
	print_jump_internal_function, print_jump_until_stop_body.
	* gen-model.c: Remove #if 0'd functions model_c_or_h_data,
	model_c_or_h_function, gen_model_h, model_c_insn,
	model_c_function, gen_model_c and types model_c_passed_data
	and struct _model_c_passed_data.
	* gen.c: Remove #if 0'd type constant_field_types and function
	insn_field_is_constant.
	(gen_entry_find_opcode_field): Remove #if 0'd code.
	* ld-insn.c (parse_insn_model_record): Remove #if 0'd code.
	* misc.h (STRDUP, STRNDUP): Remove #if 0'd macros.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.12.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright 2002, 2007-2012 Free Software Foundation, Inc.
@


1.11
log
@run copyright.sh for 2011.
@
text
@a335 319
#if 0
static void
print_jump (lf *file, int is_tail)
{
  if (!options.gen.smp)
    {
      lf_putstr (file, "if (event_queue_tick (sd))\n");
      lf_putstr (file, "  {\n");
      lf_putstr (file, "    CPU_CIA (processor) = nia;\n");
      lf_putstr (file, "    sim_events_process (sd);\n");
      lf_putstr (file, "  }\n");
      lf_putstr (file, "}\n");
    }

  if (options.gen.smp)
    {
      if (is_tail)
	lf_putstr (file, "cpu_set_program_counter(processor, nia);\n");
      lf_putstr (file, "current_cpu += 1;\n");
      lf_putstr (file, "if (current_cpu >= nr_cpus)\n");
      lf_putstr (file, "  {\n");
      lf_putstr (file, "    if (sim_events_tick (sd))\n");
      lf_putstr (file, "      {\n");
      lf_putstr (file, "        sim_events_process (sd);\n");
      lf_putstr (file, "      }\n");
      lf_putstr (file, "    current_cpu = 0;\n");
      lf_putstr (file, "  }\n");
      lf_putstr (file, "processor = processors[current_cpu];\n");
      lf_putstr (file, "nia = cpu_get_program_counter(processor);\n");
    }

  if (options.gen.icache)
    {
      lf_putstr (file, "cache_entry = cpu_icache_entry(processor, nia);\n");
      lf_putstr (file, "if (cache_entry->address == nia) {\n");
      lf_putstr (file, "  /* cache hit */\n");
      lf_putstr (file, "  goto *cache_entry->semantic;\n");
      lf_putstr (file, "}\n");
      if (is_tail)
	{
	  lf_putstr (file, "goto cache_miss;\n");
	}
    }

  if (!options.gen.icache && is_tail)
    {
      lf_printf (file, "goto engine;\n");
    }

}
#endif


#if 0
static void
print_jump_insn (lf *file,
		 insn_entry * instruction,
		 opcode_bits *expanded_bits,
		 opcode_field *opcodes, cache_entry *cache_rules)
{
  insn_opcodes opcode_path;

  memset (&opcode_path, 0, sizeof (opcode_path));
  opcode_path.opcode = opcodes;

  /* what we are for the moment */
  lf_printf (file, "\n");
  print_my_defines (file,
		    instruction->name,
		    instruction->format_name, expanded_bits);

  /* output the icache entry */
  if (options.gen.icache)
    {
      lf_printf (file, "\n");
      lf_indent (file, -1);
      print_function_name (file,
			   instruction->name,
			   instruction->format_name,
			   NULL, expanded_bits, function_name_prefix_icache);
      lf_printf (file, ":\n");
      lf_indent (file, +1);
      lf_printf (file, "{\n");
      lf_indent (file, +2);
      lf_putstr (file, "const unsigned_word cia = nia;\n");
      print_itrace (file, instruction, 1 /*putting-value-in-cache */ );
      print_idecode_validate (file, instruction, &opcode_path);
      lf_printf (file, "\n");
      lf_printf (file, "{\n");
      lf_indent (file, +2);
      print_icache_body (file, instruction, expanded_bits, cache_rules, 0,	/*use_defines */
			 put_values_in_icache);
      lf_printf (file, "cache_entry->address = nia;\n");
      lf_printf (file, "cache_entry->semantic = &&");
      print_function_name (file,
			   instruction->name,
			   instruction->format_name,
			   NULL,
			   expanded_bits, function_name_prefix_semantics);
      lf_printf (file, ";\n");
      if (options.gen.semantic_icache)
	{
	  print_semantic_body (file,
			       instruction, expanded_bits, &opcode_path);
	  print_jump (file, 1 /*is-tail */ );
	}
      else
	{
	  lf_printf (file, "/* goto ");
	  print_function_name (file,
			       instruction->name,
			       instruction->format_name,
			       NULL,
			       expanded_bits, function_name_prefix_semantics);
	  lf_printf (file, "; */\n");
	}
      lf_indent (file, -2);
      lf_putstr (file, "}\n");
      lf_indent (file, -2);
      lf_printf (file, "}\n");
    }

  /* print the semantics */
  lf_printf (file, "\n");
  lf_indent (file, -1);
  print_function_name (file,
		       instruction->name,
		       instruction->format_name,
		       NULL, expanded_bits, function_name_prefix_semantics);
  lf_printf (file, ":\n");
  lf_indent (file, +1);
  lf_printf (file, "{\n");
  lf_indent (file, +2);
  lf_putstr (file, "const unsigned_word cia = nia;\n");
  print_icache_body (file,
		     instruction,
		     expanded_bits,
		     cache_rules,
		     (options.gen.direct_access
		      ? define_variables
		      : declare_variables),
		     (options.gen.icache
		      ? get_values_from_icache : do_not_use_icache));
  print_semantic_body (file, instruction, expanded_bits, &opcode_path);
  if (options.gen.direct_access)
    print_icache_body (file,
		       instruction,
		       expanded_bits,
		       cache_rules,
		       undef_variables,
		       (options.gen.icache
			? get_values_from_icache : do_not_use_icache));
  print_jump (file, 1 /*is tail */ );
  lf_indent (file, -2);
  lf_printf (file, "}\n");
}
#endif


#if 0
static void
print_jump_definition (lf *file, gen_entry *entry, int depth, void *data)
{
  cache_entry *cache_rules = (cache_entry *) data;
  if (entry->opcode_rule->with_duplicates)
    {
      ASSERT (entry->nr_insns == 1
	      && entry->opcode == NULL
	      && entry->parent != NULL && entry->parent->opcode != NULL);
      ASSERT (entry->nr_insns == 1
	      && entry->opcode == NULL
	      && entry->parent != NULL
	      && entry->parent->opcode != NULL
	      && entry->parent->opcode_rule != NULL);
      print_jump_insn (file,
		       entry->insns->insn,
		       entry->expanded_bits, entry->opcode, cache_rules);
    }
  else
    {
      print_jump_insn (file, entry->insns->insn, NULL, NULL, cache_rules);
    }
}
#endif


#if 0
static void
print_jump_internal_function (lf *file, function_entry * function, void *data)
{
  if (function->is_internal)
    {
      lf_printf (file, "\n");
      lf_print__line_ref (file, function->line);
      lf_indent (file, -1);
      print_function_name (file,
			   function->name,
			   NULL,
			   NULL,
			   NULL,
			   (options.gen.icache
			    ? function_name_prefix_icache
			    : function_name_prefix_semantics));
      lf_printf (file, ":\n");
      lf_indent (file, +1);
      lf_printf (file, "{\n");
      lf_indent (file, +2);
      lf_printf (file, "const unsigned_word cia = nia;\n");
      table_print_code (file, function->code);
      lf_print__internal_ref (file);
      lf_printf (file, "error(\"Internal function must longjump\\n\");\n");
      lf_indent (file, -2);
      lf_printf (file, "}\n");
    }
}
#endif


#if 0
static void
print_jump_body (lf *file,
		 gen_entry *entry, insn_table *isa, cache_entry *cache_rules)
{
  lf_printf (file, "{\n");
  lf_indent (file, +2);
  lf_putstr (file, "jmp_buf halt;\n");
  lf_putstr (file, "jmp_buf restart;\n");
  lf_putstr (file, "cpu *processor = NULL;\n");
  lf_putstr (file, "unsigned_word nia = -1;\n");
  lf_putstr (file, "instruction_word instruction = 0;\n");
  if (options.gen.icache)
    {
      lf_putstr (file, "engine_cache *cache_entry = NULL;\n");
    }
  if (options.gen.smp)
    {
      lf_putstr (file, "int current_cpu = -1;\n");
    }

  /* all the switches and tables - they know about jumping */
  print_idecode_lookups (file, entry, cache_rules);

  /* start the simulation up */
  if (options.gen.icache)
    {
      lf_putstr (file, "\n");
      lf_putstr (file, "{\n");
      lf_putstr (file, "  int cpu_nr;\n");
      lf_putstr (file, "  for (cpu_nr = 0; cpu_nr < nr_cpus; cpu_nr++)\n");
      lf_putstr (file, "    cpu_flush_icache(processors[cpu_nr]);\n");
      lf_putstr (file, "}\n");
    }

  lf_putstr (file, "\n");
  lf_putstr (file, "psim_set_halt_and_restart(system, &halt, &restart);\n");

  lf_putstr (file, "\n");
  lf_putstr (file, "if (setjmp(halt))\n");
  lf_putstr (file, "  return;\n");

  lf_putstr (file, "\n");
  lf_putstr (file, "setjmp(restart);\n");

  lf_putstr (file, "\n");
  if (!options.gen.smp)
    {
      lf_putstr (file, "processor = processors[0];\n");
      lf_putstr (file, "nia = cpu_get_program_counter(processor);\n");
    }
  else
    {
      lf_putstr (file, "current_cpu = psim_last_cpu(system);\n");
    }

  if (!options.gen.icache)
    {
      lf_printf (file, "\n");
      lf_indent (file, -1);
      lf_printf (file, "engine:\n");
      lf_indent (file, +1);
    }

  print_jump (file, 0 /*is_tail */ );

  if (options.gen.icache)
    {
      lf_indent (file, -1);
      lf_printf (file, "cache_miss:\n");
      lf_indent (file, +1);
    }

  print_engine_issue_prefix_hook (file);
  lf_putstr (file, "instruction\n");
  lf_putstr (file,
	     "  = vm_instruction_map_read(cpu_instruction_map(processor),\n");
  lf_putstr (file, "                            processor, nia);\n");
  print_engine_issue_prefix_hook (file);
  print_idecode_body (file, entry, "/*IGORE*/");
  print_engine_issue_postfix_hook (file);

  /* print out a table of all the internals functions */
  function_entry_traverse (file, isa->functions,
			   print_jump_internal_function, NULL);

  /* print out a table of all the instructions */
  ERROR ("Use the list of semantic functions, not travere_tree");
  gen_entry_traverse_tree (file, entry, 1, NULL,	/* start */
			   print_jump_definition,	/* leaf */
			   NULL,	/* end */
			   cache_rules);
  lf_indent (file, -2);
  lf_printf (file, "}\n");
}
#endif


/****************************************************************/


a437 6
#if 0
	  print_engine_run_function_header (file,
					    entry->processor,
					    is_function_definition);
	  print_jump_body (file, entry->table, isa, cache_rules);
#endif
@


1.10
log
@Update copyright notices to add year 2010.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.9
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.8
log
@	Updated copyright notices for most files.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008 Free Software Foundation, Inc.
@


1.7
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d3 1
a3 1
   Copyright 2002, 2007 Free Software Foundation, Inc.
@


1.6
log
@Copyright updates for 2007.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.5
log
@2002-11-21  Andrew Cagney  <ac131313@@redhat.com>

	* filter.c: Re-indent.
	* filter.h, filter_host.h, gen-engine.c, gen-engine.h: Ditto.
	* gen-icache.c, gen-icache.h, gen-idecode.c: Ditto.
	* gen-idecode.h, gen-itable.c, gen-itable.h: Ditto.
	* gen-model.c, gen-model.h, gen-semantics.c: Ditto.
	* gen-semantics.h, gen-support.c, gen-support.h: Ditto.
	* gen.c, gen.h, igen.c, igen.h, ld-cache.c, ld-cache.h: Ditto.
	* ld-decode.c, ld-decode.h, ld-insn.c, ld-insn.h, lf.c: Ditto.
	* lf.h, misc.c, misc.h, table.c, table.h: Ditto.
@
text
@d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
@


1.4
log
@2002-11-21  Andrew Cagney  <ac131313@@redhat.com>

        * Makefile.in: Update copyright.  IGEN contributed to the FSF.
        * filter.c, filter.h, filter_host.c, filter_host.h: Ditto.
        * gen-engine.c, gen-engine.h, gen-icache.c, gen-icache.h: Ditto.
        * gen-idecode.c, gen-idecode.h, gen-itable.c: Ditto.
        * gen-itable.h, gen-model.c, gen-model.h, gen-semantics.c: Ditto.
        * gen-semantics.h, gen-support.c, gen-support.h, gen.c: Ditto.
        * gen.h, igen.c, igen.h, ld-cache.c, ld-cache.h: Ditto.
        * ld-decode.c, ld-decode.h, ld-insn.c, ld-insn.h, lf.c: Ditto.
        * lf.h, misc.c, misc.h, table.c, table.h: Ditto.
@
text
@d68 1
a68 2
print_run_body (lf *file,
	        gen_entry *table)
d71 1
a71 1
     
d73 1
a73 1
     
d75 1
a75 1
     
d77 1
a77 1
  
d82 2
a83 1
      lf_printf (file, "%sinstruction_address cia;\n", options.module.global.prefix.l);
d86 1
a86 1
  
d96 1
a96 1
  
d99 1
a99 1
      
d127 1
a127 1
      
d134 3
a136 3
	  lf_printf (file, "%sinstruction_word instruction_0 = IMEM%d (cia);\n",
		     options.module.global.prefix.l,
		     options.insn_bit_size);
d149 2
a150 1
	  lf_putstr (file, "idecode_semantic *const semantic = cache_entry->semantic;\n");
d166 2
a167 1
	  lf_putstr (file, "  mon_event (mon_event_icache_miss, cpu, cia);\n");
d188 1
a188 1
      
d215 1
a215 1
  
d218 1
a218 1
      
d228 1
a228 1
      
d230 2
a231 1
      lf_printf (file, "/* have ensured that the event queue is NOT next */\n");
d253 1
a253 1
      
d264 4
a267 2
	    lf_putstr (file, "engine_semantic *semantic = cache_entry->semantic;\n");
	    lf_putstr (file, "cia = semantic(processor, cache_entry, cia);\n");
d286 2
a287 1
	    lf_putstr (file, "  mon_event(mon_event_icache_miss, processors[current_cpu], cia);\n");
d293 1
a293 1
		print_idecode_body(file, table, "cia =");
d301 3
a303 2
		print_idecode_body(file, table, "semantic = ");
		lf_putstr (file, "cia = semantic(processor, cache_entry, cia);\n");
d313 1
a313 1
      
d324 1
a324 1
      
d329 2
a330 2
  
  
d340 1
a340 2
print_jump (lf *file,
	    int is_tail)
d351 1
a351 1
  
d368 1
a368 1
  
d376 4
a379 3
      if (is_tail) {
	lf_putstr (file, "goto cache_miss;\n");
      }
d381 1
a381 1
  
d386 1
a386 1
  
d394 1
a394 1
		 insn_entry *instruction,
d396 1
a396 2
		 opcode_field *opcodes,
		 cache_entry *cache_rules)
d407 2
a408 3
		    instruction->format_name,
		    expanded_bits);
  
d417 1
a417 3
			   NULL,
			   expanded_bits,
			   function_name_prefix_icache);
d423 1
a423 1
      print_itrace (file, instruction, 1/*putting-value-in-cache*/);
d428 1
a428 5
      print_icache_body (file,
			 instruction,
			 expanded_bits,
			 cache_rules,
			 0, /*use_defines*/
d436 1
a436 2
			   expanded_bits,
			   function_name_prefix_semantics);
d441 2
a442 4
			       instruction,
			       expanded_bits,
			       &opcode_path);
	  print_jump(file, 1/*is-tail*/);
d451 1
a451 2
			       expanded_bits,
			       function_name_prefix_semantics);
d459 1
a459 1
  
d466 1
a466 3
		       NULL,
		       expanded_bits,
		       function_name_prefix_semantics);
d480 2
a481 6
		      ? get_values_from_icache
		      : do_not_use_icache));
  print_semantic_body (file,
		       instruction,
		       expanded_bits,
		       &opcode_path);
d489 2
a490 3
			? get_values_from_icache
			: do_not_use_icache));
  print_jump(file, 1/*is tail*/);
d499 1
a499 4
print_jump_definition (lf *file,
		       gen_entry *entry,
		       int depth,
		       void *data)
d501 1
a501 1
  cache_entry *cache_rules = (cache_entry*)data;
d506 1
a506 2
	      && entry->parent != NULL
	      && entry->parent->opcode != NULL);
d514 1
a514 3
		       entry->expanded_bits,
		       entry->opcode,
		       cache_rules);
d516 1
a516 1
  else 
d518 1
a518 5
      print_jump_insn (file,
		       entry->insns->insn,
		       NULL,
		       NULL,
		       cache_rules);
d526 1
a526 3
print_jump_internal_function (lf *file,
			      function_entry *function,
			      void *data)
d559 1
a559 3
		 gen_entry *entry,
		 insn_table *isa,
		 cache_entry *cache_rules)
d576 1
a576 1
  
d579 1
a579 1
  
d590 1
a590 1
  
d593 1
a593 1
  
d597 1
a597 1
  
d600 1
a600 1
  
d611 1
a611 1
  
d619 3
a621 3
  
  print_jump(file, 0/*is_tail*/);
  
d628 2
a629 2
  
	  print_engine_issue_prefix_hook (file);
d631 2
a632 1
  lf_putstr (file, "  = vm_instruction_map_read(cpu_instruction_map(processor),\n");
d637 1
a637 1
  
d640 2
a641 3
			   print_jump_internal_function,
			   NULL);
  
d644 3
a646 5
  gen_entry_traverse_tree (file, entry,
			   1,
			   NULL, /* start */
			   print_jump_definition, /* leaf */
			   NULL, /* end */
d676 2
a677 5
  indent = print_function_name (file,
				"run",
				NULL, /* format name */
				processor,
				NULL, /* expanded bits */
d714 1
a714 3
	      gen_table *gen,
	      insn_table *isa,
	      cache_entry *cache_rules)
d722 1
a722 2
					 : NULL),
					is_function_declaration);
d728 2
a729 4
gen_engine_c(lf *file,
	     gen_table *gen,
	     insn_table *isa,
	     cache_entry *cache_rules)
d748 1
a748 1
	  
d753 1
a753 2
					     : NULL),
					    is_function_definition);
d756 1
a756 1
	  
d763 1
a763 2
	  print_jump_body (file, entry->table,
			   isa, cache_rules);
@


1.3
log
@2002-11-06  Richard Sandiford  <rsandifo@@redhat.com>

        * gen-engine.c (print_engine_issue_prefix_hook): Don't add the
        global prefix to ENGINE_ISSUE_PREFIX_HOOK.
        (print_engine_issue_postfix_hook): Likewise ENGINE_ISSUE_POSTFIX_HOOK.
@
text
@d1 1
a1 1
/*  This file is part of the program psim.
d3 1
a3 1
    Copyright (C) 1994-1998, Andrew Cagney <cagney@@highland.com.au>
d5 18
a22 15
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
    */
@


1.2
log
@        * gen-engine.c (print_run_body): Avoid multi-line strings.
        * lf.c (lf_print__gnu_copyleft): Likewise.
@
text
@d44 2
a45 4
  lf_printf (file, "#if defined (%sENGINE_ISSUE_PREFIX_HOOK)\n",
	     options.module.global.prefix.l);
  lf_printf (file, "%sENGINE_ISSUE_PREFIX_HOOK();\n",
	     options.module.global.prefix.l);
d56 2
a57 4
  lf_printf (file, "#if defined (%sENGINE_ISSUE_POSTFIX_HOOK)\n",
	     options.module.global.prefix.l);
  lf_printf (file, "%sENGINE_ISSUE_POSTFIX_HOOK();\n",
	     options.module.global.prefix.l);
@


1.2.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1 1
a1 1
/* The IGEN simulator generator for GDB, the GNU Debugger.
d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d5 15
a19 18
   Contributed by Andrew Cagney.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d44 4
a47 2
  lf_printf (file, "#if defined (ENGINE_ISSUE_PREFIX_HOOK)\n");
  lf_printf (file, "ENGINE_ISSUE_PREFIX_HOOK();\n");
d58 4
a61 2
  lf_printf (file, "#if defined (ENGINE_ISSUE_POSTFIX_HOOK)\n");
  lf_printf (file, "ENGINE_ISSUE_POSTFIX_HOOK();\n");
d69 2
a70 1
print_run_body (lf *file, gen_entry *table)
d73 1
a73 1

d75 1
a75 1

d77 1
a77 1

d79 1
a79 1

d84 1
a84 2
      lf_printf (file, "%sinstruction_address cia;\n",
		 options.module.global.prefix.l);
d87 1
a87 1

d97 1
a97 1

d100 1
a100 1

d128 1
a128 1

d135 3
a137 3
	  lf_printf (file,
		     "%sinstruction_word instruction_0 = IMEM%d (cia);\n",
		     options.module.global.prefix.l, options.insn_bit_size);
d150 1
a150 2
	  lf_putstr (file,
		     "idecode_semantic *const semantic = cache_entry->semantic;\n");
d166 1
a166 2
	  lf_putstr (file,
		     "  mon_event (mon_event_icache_miss, cpu, cia);\n");
d187 1
a187 1

d214 1
a214 1

d217 1
a217 1

d227 1
a227 1

d229 1
a229 2
      lf_printf (file,
		 "/* have ensured that the event queue is NOT next */\n");
d251 1
a251 1

d262 2
a263 4
	    lf_putstr (file,
		       "engine_semantic *semantic = cache_entry->semantic;\n");
	    lf_putstr (file,
		       "cia = semantic(processor, cache_entry, cia);\n");
d282 1
a282 2
	    lf_putstr (file,
		       "  mon_event(mon_event_icache_miss, processors[current_cpu], cia);\n");
d288 1
a288 1
		print_idecode_body (file, table, "cia =");
d296 2
a297 3
		print_idecode_body (file, table, "semantic = ");
		lf_putstr (file,
			   "cia = semantic(processor, cache_entry, cia);\n");
d307 1
a307 1

d318 1
a318 1

d323 2
a324 2


d334 2
a335 1
print_jump (lf *file, int is_tail)
d346 1
a346 1

d363 1
a363 1

d371 3
a373 4
      if (is_tail)
	{
	  lf_putstr (file, "goto cache_miss;\n");
	}
d375 1
a375 1

d380 1
a380 1

d388 1
a388 1
		 insn_entry * instruction,
d390 2
a391 1
		 opcode_field *opcodes, cache_entry *cache_rules)
d402 3
a404 2
		    instruction->format_name, expanded_bits);

d413 3
a415 1
			   NULL, expanded_bits, function_name_prefix_icache);
d421 1
a421 1
      print_itrace (file, instruction, 1 /*putting-value-in-cache */ );
d426 5
a430 1
      print_icache_body (file, instruction, expanded_bits, cache_rules, 0,	/*use_defines */
d438 2
a439 1
			   expanded_bits, function_name_prefix_semantics);
d444 4
a447 2
			       instruction, expanded_bits, &opcode_path);
	  print_jump (file, 1 /*is-tail */ );
d456 2
a457 1
			       expanded_bits, function_name_prefix_semantics);
d465 1
a465 1

d472 3
a474 1
		       NULL, expanded_bits, function_name_prefix_semantics);
d488 6
a493 2
		      ? get_values_from_icache : do_not_use_icache));
  print_semantic_body (file, instruction, expanded_bits, &opcode_path);
d501 3
a503 2
			? get_values_from_icache : do_not_use_icache));
  print_jump (file, 1 /*is tail */ );
d512 4
a515 1
print_jump_definition (lf *file, gen_entry *entry, int depth, void *data)
d517 1
a517 1
  cache_entry *cache_rules = (cache_entry *) data;
d522 2
a523 1
	      && entry->parent != NULL && entry->parent->opcode != NULL);
d531 3
a533 1
		       entry->expanded_bits, entry->opcode, cache_rules);
d535 1
a535 1
  else
d537 5
a541 1
      print_jump_insn (file, entry->insns->insn, NULL, NULL, cache_rules);
d549 3
a551 1
print_jump_internal_function (lf *file, function_entry * function, void *data)
d584 3
a586 1
		 gen_entry *entry, insn_table *isa, cache_entry *cache_rules)
d603 1
a603 1

d606 1
a606 1

d617 1
a617 1

d620 1
a620 1

d624 1
a624 1

d627 1
a627 1

d638 1
a638 1

d646 3
a648 3

  print_jump (file, 0 /*is_tail */ );

d655 2
a656 2

  print_engine_issue_prefix_hook (file);
d658 1
a658 2
  lf_putstr (file,
	     "  = vm_instruction_map_read(cpu_instruction_map(processor),\n");
d663 1
a663 1

d666 3
a668 2
			   print_jump_internal_function, NULL);

d671 5
a675 3
  gen_entry_traverse_tree (file, entry, 1, NULL,	/* start */
			   print_jump_definition,	/* leaf */
			   NULL,	/* end */
d705 5
a709 2
  indent = print_function_name (file, "run", NULL,	/* format name */
				processor, NULL,	/* expanded bits */
d746 3
a748 1
	      gen_table *gen, insn_table *isa, cache_entry *cache_rules)
d756 2
a757 1
					 : NULL), is_function_declaration);
d763 4
a766 2
gen_engine_c (lf *file,
	      gen_table *gen, insn_table *isa, cache_entry *cache_rules)
d785 1
a785 1

d790 2
a791 1
					     : NULL), is_function_definition);
d794 1
a794 1

d801 2
a802 1
	  print_jump_body (file, entry->table, isa, cache_rules);
@


1.2.6.1
log
@Import all the copyright and indent changes from the mainline (also
richards's tweak).
@
text
@d1 1
a1 1
/* The IGEN simulator generator for GDB, the GNU Debugger.
d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d5 15
a19 18
   Contributed by Andrew Cagney.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d44 4
a47 2
  lf_printf (file, "#if defined (ENGINE_ISSUE_PREFIX_HOOK)\n");
  lf_printf (file, "ENGINE_ISSUE_PREFIX_HOOK();\n");
d58 4
a61 2
  lf_printf (file, "#if defined (ENGINE_ISSUE_POSTFIX_HOOK)\n");
  lf_printf (file, "ENGINE_ISSUE_POSTFIX_HOOK();\n");
d69 2
a70 1
print_run_body (lf *file, gen_entry *table)
d73 1
a73 1

d75 1
a75 1

d77 1
a77 1

d79 1
a79 1

d84 1
a84 2
      lf_printf (file, "%sinstruction_address cia;\n",
		 options.module.global.prefix.l);
d87 1
a87 1

d97 1
a97 1

d100 1
a100 1

d128 1
a128 1

d135 3
a137 3
	  lf_printf (file,
		     "%sinstruction_word instruction_0 = IMEM%d (cia);\n",
		     options.module.global.prefix.l, options.insn_bit_size);
d150 1
a150 2
	  lf_putstr (file,
		     "idecode_semantic *const semantic = cache_entry->semantic;\n");
d166 1
a166 2
	  lf_putstr (file,
		     "  mon_event (mon_event_icache_miss, cpu, cia);\n");
d187 1
a187 1

d214 1
a214 1

d217 1
a217 1

d227 1
a227 1

d229 1
a229 2
      lf_printf (file,
		 "/* have ensured that the event queue is NOT next */\n");
d251 1
a251 1

d262 2
a263 4
	    lf_putstr (file,
		       "engine_semantic *semantic = cache_entry->semantic;\n");
	    lf_putstr (file,
		       "cia = semantic(processor, cache_entry, cia);\n");
d282 1
a282 2
	    lf_putstr (file,
		       "  mon_event(mon_event_icache_miss, processors[current_cpu], cia);\n");
d288 1
a288 1
		print_idecode_body (file, table, "cia =");
d296 2
a297 3
		print_idecode_body (file, table, "semantic = ");
		lf_putstr (file,
			   "cia = semantic(processor, cache_entry, cia);\n");
d307 1
a307 1

d318 1
a318 1

d323 2
a324 2


d334 2
a335 1
print_jump (lf *file, int is_tail)
d346 1
a346 1

d363 1
a363 1

d371 3
a373 4
      if (is_tail)
	{
	  lf_putstr (file, "goto cache_miss;\n");
	}
d375 1
a375 1

d380 1
a380 1

d388 1
a388 1
		 insn_entry * instruction,
d390 2
a391 1
		 opcode_field *opcodes, cache_entry *cache_rules)
d402 3
a404 2
		    instruction->format_name, expanded_bits);

d413 3
a415 1
			   NULL, expanded_bits, function_name_prefix_icache);
d421 1
a421 1
      print_itrace (file, instruction, 1 /*putting-value-in-cache */ );
d426 5
a430 1
      print_icache_body (file, instruction, expanded_bits, cache_rules, 0,	/*use_defines */
d438 2
a439 1
			   expanded_bits, function_name_prefix_semantics);
d444 4
a447 2
			       instruction, expanded_bits, &opcode_path);
	  print_jump (file, 1 /*is-tail */ );
d456 2
a457 1
			       expanded_bits, function_name_prefix_semantics);
d465 1
a465 1

d472 3
a474 1
		       NULL, expanded_bits, function_name_prefix_semantics);
d488 6
a493 2
		      ? get_values_from_icache : do_not_use_icache));
  print_semantic_body (file, instruction, expanded_bits, &opcode_path);
d501 3
a503 2
			? get_values_from_icache : do_not_use_icache));
  print_jump (file, 1 /*is tail */ );
d512 4
a515 1
print_jump_definition (lf *file, gen_entry *entry, int depth, void *data)
d517 1
a517 1
  cache_entry *cache_rules = (cache_entry *) data;
d522 2
a523 1
	      && entry->parent != NULL && entry->parent->opcode != NULL);
d531 3
a533 1
		       entry->expanded_bits, entry->opcode, cache_rules);
d535 1
a535 1
  else
d537 5
a541 1
      print_jump_insn (file, entry->insns->insn, NULL, NULL, cache_rules);
d549 3
a551 1
print_jump_internal_function (lf *file, function_entry * function, void *data)
d584 3
a586 1
		 gen_entry *entry, insn_table *isa, cache_entry *cache_rules)
d603 1
a603 1

d606 1
a606 1

d617 1
a617 1

d620 1
a620 1

d624 1
a624 1

d627 1
a627 1

d638 1
a638 1

d646 3
a648 3

  print_jump (file, 0 /*is_tail */ );

d655 2
a656 2

  print_engine_issue_prefix_hook (file);
d658 1
a658 2
  lf_putstr (file,
	     "  = vm_instruction_map_read(cpu_instruction_map(processor),\n");
d663 1
a663 1

d666 3
a668 2
			   print_jump_internal_function, NULL);

d671 5
a675 3
  gen_entry_traverse_tree (file, entry, 1, NULL,	/* start */
			   print_jump_definition,	/* leaf */
			   NULL,	/* end */
d705 5
a709 2
  indent = print_function_name (file, "run", NULL,	/* format name */
				processor, NULL,	/* expanded bits */
d746 3
a748 1
	      gen_table *gen, insn_table *isa, cache_entry *cache_rules)
d756 2
a757 1
					 : NULL), is_function_declaration);
d763 4
a766 2
gen_engine_c (lf *file,
	      gen_table *gen, insn_table *isa, cache_entry *cache_rules)
d785 1
a785 1

d790 2
a791 1
					     : NULL), is_function_definition);
d794 1
a794 1

d801 2
a802 1
	  print_jump_body (file, entry->table, isa, cache_rules);
@


1.2.8.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d44 4
a47 2
  lf_printf (file, "#if defined (ENGINE_ISSUE_PREFIX_HOOK)\n");
  lf_printf (file, "ENGINE_ISSUE_PREFIX_HOOK();\n");
d58 4
a61 2
  lf_printf (file, "#if defined (ENGINE_ISSUE_POSTFIX_HOOK)\n");
  lf_printf (file, "ENGINE_ISSUE_POSTFIX_HOOK();\n");
@


1.2.8.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d1 1
a1 1
/* The IGEN simulator generator for GDB, the GNU Debugger.
d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d5 15
a19 18
   Contributed by Andrew Cagney.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d65 2
a66 1
print_run_body (lf *file, gen_entry *table)
d69 1
a69 1

d71 1
a71 1

d73 1
a73 1

d75 1
a75 1

d80 1
a80 2
      lf_printf (file, "%sinstruction_address cia;\n",
		 options.module.global.prefix.l);
d83 1
a83 1

d93 1
a93 1

d96 1
a96 1

d124 1
a124 1

d131 3
a133 3
	  lf_printf (file,
		     "%sinstruction_word instruction_0 = IMEM%d (cia);\n",
		     options.module.global.prefix.l, options.insn_bit_size);
d146 1
a146 2
	  lf_putstr (file,
		     "idecode_semantic *const semantic = cache_entry->semantic;\n");
d162 1
a162 2
	  lf_putstr (file,
		     "  mon_event (mon_event_icache_miss, cpu, cia);\n");
d183 1
a183 1

d210 1
a210 1

d213 1
a213 1

d223 1
a223 1

d225 1
a225 2
      lf_printf (file,
		 "/* have ensured that the event queue is NOT next */\n");
d247 1
a247 1

d258 2
a259 4
	    lf_putstr (file,
		       "engine_semantic *semantic = cache_entry->semantic;\n");
	    lf_putstr (file,
		       "cia = semantic(processor, cache_entry, cia);\n");
d278 1
a278 2
	    lf_putstr (file,
		       "  mon_event(mon_event_icache_miss, processors[current_cpu], cia);\n");
d284 1
a284 1
		print_idecode_body (file, table, "cia =");
d292 2
a293 3
		print_idecode_body (file, table, "semantic = ");
		lf_putstr (file,
			   "cia = semantic(processor, cache_entry, cia);\n");
d303 1
a303 1

d314 1
a314 1

d319 2
a320 2


d330 2
a331 1
print_jump (lf *file, int is_tail)
d342 1
a342 1

d359 1
a359 1

d367 3
a369 4
      if (is_tail)
	{
	  lf_putstr (file, "goto cache_miss;\n");
	}
d371 1
a371 1

d376 1
a376 1

d384 1
a384 1
		 insn_entry * instruction,
d386 2
a387 1
		 opcode_field *opcodes, cache_entry *cache_rules)
d398 3
a400 2
		    instruction->format_name, expanded_bits);

d409 3
a411 1
			   NULL, expanded_bits, function_name_prefix_icache);
d417 1
a417 1
      print_itrace (file, instruction, 1 /*putting-value-in-cache */ );
d422 5
a426 1
      print_icache_body (file, instruction, expanded_bits, cache_rules, 0,	/*use_defines */
d434 2
a435 1
			   expanded_bits, function_name_prefix_semantics);
d440 4
a443 2
			       instruction, expanded_bits, &opcode_path);
	  print_jump (file, 1 /*is-tail */ );
d452 2
a453 1
			       expanded_bits, function_name_prefix_semantics);
d461 1
a461 1

d468 3
a470 1
		       NULL, expanded_bits, function_name_prefix_semantics);
d484 6
a489 2
		      ? get_values_from_icache : do_not_use_icache));
  print_semantic_body (file, instruction, expanded_bits, &opcode_path);
d497 3
a499 2
			? get_values_from_icache : do_not_use_icache));
  print_jump (file, 1 /*is tail */ );
d508 4
a511 1
print_jump_definition (lf *file, gen_entry *entry, int depth, void *data)
d513 1
a513 1
  cache_entry *cache_rules = (cache_entry *) data;
d518 2
a519 1
	      && entry->parent != NULL && entry->parent->opcode != NULL);
d527 3
a529 1
		       entry->expanded_bits, entry->opcode, cache_rules);
d531 1
a531 1
  else
d533 5
a537 1
      print_jump_insn (file, entry->insns->insn, NULL, NULL, cache_rules);
d545 3
a547 1
print_jump_internal_function (lf *file, function_entry * function, void *data)
d580 3
a582 1
		 gen_entry *entry, insn_table *isa, cache_entry *cache_rules)
d599 1
a599 1

d602 1
a602 1

d613 1
a613 1

d616 1
a616 1

d620 1
a620 1

d623 1
a623 1

d634 1
a634 1

d642 3
a644 3

  print_jump (file, 0 /*is_tail */ );

d651 2
a652 2

  print_engine_issue_prefix_hook (file);
d654 1
a654 2
  lf_putstr (file,
	     "  = vm_instruction_map_read(cpu_instruction_map(processor),\n");
d659 1
a659 1

d662 3
a664 2
			   print_jump_internal_function, NULL);

d667 5
a671 3
  gen_entry_traverse_tree (file, entry, 1, NULL,	/* start */
			   print_jump_definition,	/* leaf */
			   NULL,	/* end */
d701 5
a705 2
  indent = print_function_name (file, "run", NULL,	/* format name */
				processor, NULL,	/* expanded bits */
d742 3
a744 1
	      gen_table *gen, insn_table *isa, cache_entry *cache_rules)
d752 2
a753 1
					 : NULL), is_function_declaration);
d759 4
a762 2
gen_engine_c (lf *file,
	      gen_table *gen, insn_table *isa, cache_entry *cache_rules)
d781 1
a781 1

d786 2
a787 1
					     : NULL), is_function_definition);
d790 1
a790 1

d797 2
a798 1
	  print_jump_body (file, entry->table, isa, cache_rules);
@


1.1
log
@Initial revision
@
text
@d101 15
a115 15
      lf_putstr (file, "
/* CASE 1: NO SMP (with or with out instruction cache).

In this case, we can take advantage of the fact that the current
instruction address (CIA) does not need to be read from / written to
the CPU object after the execution of an instruction.

Instead, CIA is only saved when the main loop exits.  This occures
when either sim_engine_halt or sim_engine_restart is called.  Both of
these functions save the current instruction address before halting /
restarting the simulator.

As a variation, there may also be support for an instruction cracking
cache. */

d218 8
a225 8
      lf_putstr (file, "
/* CASE 2: SMP (With or without ICACHE)

The complexity here comes from needing to correctly halt the simulator
when it is aborted.  For instance, if cpu0 requests a restart then
cpu1 will normally be the next cpu that is run.  Cpu0 being restarted
after all the other CPU's and the event queue have been processed */

@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.1.20.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d101 15
a115 15
      lf_putstr (file, "\
/* CASE 1: NO SMP (with or with out instruction cache).\n\
\n\
In this case, we can take advantage of the fact that the current\n\
instruction address (CIA) does not need to be read from / written to\n\
the CPU object after the execution of an instruction.\n\
\n\
Instead, CIA is only saved when the main loop exits.  This occures\n\
when either sim_engine_halt or sim_engine_restart is called.  Both of\n\
these functions save the current instruction address before halting /\n\
restarting the simulator.\n\
\n\
As a variation, there may also be support for an instruction cracking\n\
cache. */\n\
\n\
d218 8
a225 8
      lf_putstr (file, "\
/* CASE 2: SMP (With or without ICACHE)\n\
\n\
The complexity here comes from needing to correctly halt the simulator\n\
when it is aborted.  For instance, if cpu0 requests a restart then\n\
cpu1 will normally be the next cpu that is run.  Cpu0 being restarted\n\
after all the other CPU's and the event queue have been processed */\n\
\n\
@


1.1.1.1.18.1
log
@merge from trunk
@
text
@d101 15
a115 15
      lf_putstr (file, "\
/* CASE 1: NO SMP (with or with out instruction cache).\n\
\n\
In this case, we can take advantage of the fact that the current\n\
instruction address (CIA) does not need to be read from / written to\n\
the CPU object after the execution of an instruction.\n\
\n\
Instead, CIA is only saved when the main loop exits.  This occures\n\
when either sim_engine_halt or sim_engine_restart is called.  Both of\n\
these functions save the current instruction address before halting /\n\
restarting the simulator.\n\
\n\
As a variation, there may also be support for an instruction cracking\n\
cache. */\n\
\n\
d218 8
a225 8
      lf_putstr (file, "\
/* CASE 2: SMP (With or without ICACHE)\n\
\n\
The complexity here comes from needing to correctly halt the simulator\n\
when it is aborted.  For instance, if cpu0 requests a restart then\n\
cpu1 will normally be the next cpu that is run.  Cpu0 being restarted\n\
after all the other CPU's and the event queue have been processed */\n\
\n\
@


