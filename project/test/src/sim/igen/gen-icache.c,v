head	1.13;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.13
	gdb_7_6-2013-04-26-release:1.13
	gdb_7_6-branch:1.13.0.2
	gdb_7_6-2013-03-12-branchpoint:1.13
	gdb_7_5_1-2012-11-29-release:1.12
	gdb_7_5-2012-08-17-release:1.12
	gdb_7_5-branch:1.12.0.2
	gdb_7_5-2012-07-18-branchpoint:1.12
	gdb_7_4_1-2012-04-26-release:1.11.2.1
	gdb_7_4-2012-01-24-release:1.11.2.1
	gdb_7_4-branch:1.11.0.2
	gdb_7_4-2011-12-13-branchpoint:1.11
	gdb_7_3_1-2011-09-04-release:1.10
	gdb_7_3-2011-07-26-release:1.10
	gdb_7_3-branch:1.10.0.2
	gdb_7_3-2011-04-01-branchpoint:1.10
	gdb_7_2-2010-09-02-release:1.9
	gdb_7_2-branch:1.9.0.4
	gdb_7_2-2010-07-07-branchpoint:1.9
	gdb_7_1-2010-03-18-release:1.9
	gdb_7_1-branch:1.9.0.2
	gdb_7_1-2010-02-18-branchpoint:1.9
	gdb_7_0_1-2009-12-22-release:1.8
	gdb_7_0-2009-10-06-release:1.8
	gdb_7_0-branch:1.8.0.4
	gdb_7_0-2009-09-16-branchpoint:1.8
	arc-sim-20090309:1.7
	msnyder-checkpoint-072509-branch:1.8.0.2
	msnyder-checkpoint-072509-branchpoint:1.8
	arc-insight_6_8-branch:1.7.0.16
	arc-insight_6_8-branchpoint:1.7
	insight_6_8-branch:1.7.0.14
	insight_6_8-branchpoint:1.7
	reverse-20081226-branch:1.7.0.12
	reverse-20081226-branchpoint:1.7
	multiprocess-20081120-branch:1.7.0.10
	multiprocess-20081120-branchpoint:1.7
	reverse-20080930-branch:1.7.0.8
	reverse-20080930-branchpoint:1.7
	reverse-20080717-branch:1.7.0.6
	reverse-20080717-branchpoint:1.7
	msnyder-reverse-20080609-branch:1.7.0.4
	msnyder-reverse-20080609-branchpoint:1.7
	drow-reverse-20070409-branch:1.5.0.2
	drow-reverse-20070409-branchpoint:1.5
	gdb_6_8-2008-03-27-release:1.7
	gdb_6_8-branch:1.7.0.2
	gdb_6_8-2008-02-26-branchpoint:1.7
	gdb_6_7_1-2007-10-29-release:1.6
	gdb_6_7-2007-10-10-release:1.6
	gdb_6_7-branch:1.6.0.2
	gdb_6_7-2007-09-07-branchpoint:1.6
	insight_6_6-20070208-release:1.4
	gdb_6_6-2006-12-18-release:1.4
	gdb_6_6-branch:1.4.0.88
	gdb_6_6-2006-11-15-branchpoint:1.4
	insight_6_5-20061003-release:1.4
	gdb-csl-symbian-6_4_50_20060226-12:1.4
	gdb-csl-sourcerygxx-3_4_4-25:1.4
	nickrob-async-20060828-mergepoint:1.4
	gdb-csl-symbian-6_4_50_20060226-11:1.4
	gdb-csl-sourcerygxx-4_1-17:1.4
	gdb-csl-20060226-branch-local-2:1.4
	gdb-csl-sourcerygxx-4_1-14:1.4
	gdb-csl-sourcerygxx-4_1-13:1.4
	gdb-csl-sourcerygxx-4_1-12:1.4
	gdb-csl-sourcerygxx-3_4_4-21:1.4
	gdb_6_5-20060621-release:1.4
	gdb-csl-sourcerygxx-4_1-9:1.4
	gdb-csl-sourcerygxx-4_1-8:1.4
	gdb-csl-sourcerygxx-4_1-7:1.4
	gdb-csl-arm-2006q1-6:1.4
	gdb-csl-sourcerygxx-4_1-6:1.4
	gdb-csl-symbian-6_4_50_20060226-10:1.4
	gdb-csl-symbian-6_4_50_20060226-9:1.4
	gdb-csl-symbian-6_4_50_20060226-8:1.4
	gdb-csl-coldfire-4_1-11:1.4
	gdb-csl-sourcerygxx-3_4_4-19:1.4
	gdb-csl-coldfire-4_1-10:1.4
	gdb_6_5-branch:1.4.0.86
	gdb_6_5-2006-05-14-branchpoint:1.4
	gdb-csl-sourcerygxx-4_1-5:1.4
	nickrob-async-20060513-branch:1.4.0.84
	nickrob-async-20060513-branchpoint:1.4
	gdb-csl-sourcerygxx-4_1-4:1.4
	msnyder-reverse-20060502-branch:1.4.0.82
	msnyder-reverse-20060502-branchpoint:1.4
	gdb-csl-morpho-4_1-4:1.4
	gdb-csl-sourcerygxx-3_4_4-17:1.4
	readline_5_1-import-branch:1.4.0.80
	readline_5_1-import-branchpoint:1.4
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.4
	gdb-csl-symbian-20060226-branch:1.4.0.78
	gdb-csl-symbian-20060226-branchpoint:1.4
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.4
	msnyder-reverse-20060331-branch:1.4.0.76
	msnyder-reverse-20060331-branchpoint:1.4
	gdb-csl-available-20060303-branch:1.4.0.74
	gdb-csl-available-20060303-branchpoint:1.4
	gdb-csl-20060226-branch:1.4.0.72
	gdb-csl-20060226-branchpoint:1.4
	gdb_6_4-20051202-release:1.4
	msnyder-fork-checkpoint-branch:1.4.0.70
	msnyder-fork-checkpoint-branchpoint:1.4
	gdb-csl-gxxpro-6_3-branch:1.4.0.68
	gdb-csl-gxxpro-6_3-branchpoint:1.4
	gdb_6_4-branch:1.4.0.66
	gdb_6_4-2005-11-01-branchpoint:1.4
	gdb-csl-arm-20051020-branch:1.4.0.64
	gdb-csl-arm-20051020-branchpoint:1.4
	msnyder-tracepoint-checkpoint-branch:1.4.0.62
	msnyder-tracepoint-checkpoint-branchpoint:1.4
	gdb-csl-arm-20050325-2005-q1b:1.4
	gdb-csl-arm-20050325-2005-q1a:1.4
	csl-arm-20050325-branch:1.4.0.60
	csl-arm-20050325-branchpoint:1.4
	gdb_6_3-20041109-release:1.4
	gdb_6_3-branch:1.4.0.56
	gdb_6_3-20041019-branchpoint:1.4
	drow_intercu-merge-20040921:1.4
	drow_intercu-merge-20040915:1.4
	jimb-gdb_6_2-e500-branch:1.4.0.58
	jimb-gdb_6_2-e500-branchpoint:1.4
	gdb_6_2-20040730-release:1.4
	gdb_6_2-branch:1.4.0.54
	gdb_6_2-2004-07-10-gmt-branchpoint:1.4
	gdb_6_1_1-20040616-release:1.4
	gdb_6_1-2004-04-05-release:1.4
	drow_intercu-merge-20040402:1.4
	drow_intercu-merge-20040327:1.4
	ezannoni_pie-20040323-branch:1.4.0.52
	ezannoni_pie-20040323-branchpoint:1.4
	cagney_tramp-20040321-mergepoint:1.4
	cagney_tramp-20040309-branch:1.4.0.50
	cagney_tramp-20040309-branchpoint:1.4
	gdb_6_1-branch:1.4.0.48
	gdb_6_1-2004-03-01-gmt-branchpoint:1.4
	drow_intercu-20040221-branch:1.4.0.46
	drow_intercu-20040221-branchpoint:1.4
	cagney_bfdfile-20040213-branch:1.4.0.44
	cagney_bfdfile-20040213-branchpoint:1.4
	drow-cplus-merge-20040208:1.4
	carlton_dictionary-20040126-merge:1.4
	cagney_bigcore-20040122-branch:1.4.0.42
	cagney_bigcore-20040122-branchpoint:1.4
	drow-cplus-merge-20040113:1.4
	drow-cplus-merge-20031224:1.4
	drow-cplus-merge-20031220:1.4
	carlton_dictionary-20031215-merge:1.4
	drow-cplus-merge-20031214:1.4
	carlton-dictionary-20031111-merge:1.4
	gdb_6_0-2003-10-04-release:1.4
	kettenis_sparc-20030918-branch:1.4.0.40
	kettenis_sparc-20030918-branchpoint:1.4
	carlton_dictionary-20030917-merge:1.4
	ezannoni_pie-20030916-branchpoint:1.4
	ezannoni_pie-20030916-branch:1.4.0.38
	cagney_x86i386-20030821-branch:1.4.0.36
	cagney_x86i386-20030821-branchpoint:1.4
	carlton_dictionary-20030805-merge:1.4
	carlton_dictionary-20030627-merge:1.4
	gdb_6_0-branch:1.4.0.34
	gdb_6_0-2003-06-23-branchpoint:1.4
	jimb-ppc64-linux-20030613-branch:1.4.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.4
	cagney_convert-20030606-branch:1.4.0.30
	cagney_convert-20030606-branchpoint:1.4
	cagney_writestrings-20030508-branch:1.4.0.28
	cagney_writestrings-20030508-branchpoint:1.4
	jimb-ppc64-linux-20030528-branch:1.4.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.4
	carlton_dictionary-20030523-merge:1.4
	cagney_fileio-20030521-branch:1.4.0.24
	cagney_fileio-20030521-branchpoint:1.4
	kettenis_i386newframe-20030517-mergepoint:1.4
	jimb-ppc64-linux-20030509-branch:1.4.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.4
	kettenis_i386newframe-20030504-mergepoint:1.4
	carlton_dictionary-20030430-merge:1.4
	kettenis_i386newframe-20030419-branch:1.4.0.20
	kettenis_i386newframe-20030419-branchpoint:1.4
	carlton_dictionary-20030416-merge:1.4
	cagney_frameaddr-20030409-mergepoint:1.4
	kettenis_i386newframe-20030406-branch:1.4.0.18
	kettenis_i386newframe-20030406-branchpoint:1.4
	cagney_frameaddr-20030403-branchpoint:1.4
	cagney_frameaddr-20030403-branch:1.4.0.16
	cagney_framebase-20030330-mergepoint:1.4
	cagney_framebase-20030326-branch:1.4.0.14
	cagney_framebase-20030326-branchpoint:1.4
	cagney_lazyid-20030317-branch:1.4.0.12
	cagney_lazyid-20030317-branchpoint:1.4
	kettenis-i386newframe-20030316-mergepoint:1.4
	offbyone-20030313-branch:1.4.0.10
	offbyone-20030313-branchpoint:1.4
	kettenis-i386newframe-20030308-branch:1.4.0.8
	kettenis-i386newframe-20030308-branchpoint:1.4
	carlton_dictionary-20030305-merge:1.4
	cagney_offbyone-20030303-branch:1.4.0.6
	cagney_offbyone-20030303-branchpoint:1.4
	carlton_dictionary-20030207-merge:1.4
	interps-20030202-branch:1.4.0.4
	interps-20030202-branchpoint:1.4
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2.6.1
	carlton_dictionary-20021115-merge:1.2
	kseitz_interps-20021105-merge:1.2
	kseitz_interps-20021103-merge:1.2
	drow-cplus-merge-20021020:1.2
	drow-cplus-merge-20021025:1.2
	carlton_dictionary-20021025-merge:1.2
	carlton_dictionary-20021011-merge:1.2
	drow-cplus-branch:1.2.0.10
	drow-cplus-branchpoint:1.2
	kseitz_interps-20020930-merge:1.2
	carlton_dictionary-20020927-merge:1.2
	carlton_dictionary-branch:1.2.0.8
	carlton_dictionary-20020920-branchpoint:1.2
	gdb_5_3-branch:1.2.0.6
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.4
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.2
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.1.1.1
	kseitz_interps-20020528-branch:1.1.1.1.0.20
	kseitz_interps-20020528-branchpoint:1.1.1.1
	cagney_regbuf-20020515-branch:1.1.1.1.0.18
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	jimb-macro-020506-branch:1.1.1.1.0.16
	jimb-macro-020506-branchpoint:1.1.1.1
	gdb_5_2-2002-04-29-release:1.1.1.1
	gdb_5_2-branch:1.1.1.1.0.14
	gdb_5_2-2002-03-03-branchpoint:1.1.1.1
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.12
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.10
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.8
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.13
date	2013.01.01.06.41.37;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2012.01.04.08.28.11;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2011.07.08.06.24.11;	author hp;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2011.01.01.15.34.00;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2010.01.01.10.03.30;	author brobecke;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.14.10.53.07;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2008.01.01.22.53.24;	author drow;	state Exp;
branches;
next	1.6;

1.6
date	2007.08.24.14.28.36;	author brobecke;	state Exp;
branches;
next	1.5;

1.5
date	2007.01.09.17.59.18;	author drow;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.22.04.20.49;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.22.04.09.40;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.17.21.44.06;	author cagney;	state Exp;
branches
	1.2.6.1
	1.2.8.1
	1.2.10.1;
next	1.1;

1.1
date	99.04.16.01.35.04;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.11.2.1
date	2012.01.06.04.54.49;	author brobecke;	state Exp;
branches;
next	;

1.2.6.1
date	2002.11.22.04.26.42;	author cagney;	state Exp;
branches;
next	;

1.2.8.1
date	2002.12.23.19.39.54;	author carlton;	state Exp;
branches;
next	;

1.2.10.1
date	2003.12.14.20.28.24;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.35.04;	author shebs;	state Exp;
branches
	1.1.1.1.18.1
	1.1.1.1.20.1;
next	;

1.1.1.1.18.1
date	2002.06.21.15.48.51;	author cagney;	state Exp;
branches;
next	;

1.1.1.1.20.1
date	2002.06.20.01.39.55;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* The IGEN simulator generator for GDB, the GNU Debugger.

   Copyright 2002-2013 Free Software Foundation, Inc.

   Contributed by Andrew Cagney.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */


#include "misc.h"
#include "lf.h"
#include "table.h"
#include "filter.h"
#include "igen.h"

#include "ld-insn.h"
#include "ld-decode.h"

#include "gen.h"

#include "gen-semantics.h"
#include "gen-idecode.h"
#include "gen-icache.h"



static void
print_icache_function_header (lf *file,
			      const char *basename,
			      const char *format_name,
			      opcode_bits *expanded_bits,
			      int is_function_definition,
			      int nr_prefetched_words)
{
  lf_printf (file, "\n");
  lf_print__function_type_function (file, print_icache_function_type,
				    "EXTERN_ICACHE", " ");
  print_function_name (file,
		       basename, format_name, NULL,
		       expanded_bits, function_name_prefix_icache);
  lf_printf (file, "\n(");
  print_icache_function_formal (file, nr_prefetched_words);
  lf_printf (file, ")");
  if (!is_function_definition)
    lf_printf (file, ";");
  lf_printf (file, "\n");
}


void
print_icache_declaration (lf *file,
			  insn_entry * insn,
			  opcode_bits *expanded_bits,
			  insn_opcodes *opcodes, int nr_prefetched_words)
{
  print_icache_function_header (file,
				insn->name,
				insn->format_name,
				expanded_bits,
				0 /* is not function definition */ ,
				nr_prefetched_words);
}



static void
print_icache_extraction (lf *file,
			 const char *format_name,
			 cache_entry_type cache_type,
			 const char *entry_name,
			 const char *entry_type,
			 const char *entry_expression,
			 char *single_insn_field,
			 line_ref *line,
			 insn_field_entry *cur_field,
			 opcode_bits *expanded_bits,
			 icache_decl_type what_to_declare,
			 icache_body_type what_to_do)
{
  const char *expression;
  opcode_bits *bits;
  char *reason;
  ASSERT (format_name != NULL);
  ASSERT (entry_name != NULL);

  /* figure out exactly what should be going on here */
  switch (cache_type)
    {
    case scratch_value:
      if ((what_to_do & put_values_in_icache)
	  || what_to_do == do_not_use_icache)
	{
	  reason = "scratch";
	  what_to_do = do_not_use_icache;
	}
      else
	return;
      break;
    case compute_value:
      if ((what_to_do & get_values_from_icache)
	  || what_to_do == do_not_use_icache)
	{
	  reason = "compute";
	  what_to_do = do_not_use_icache;
	}
      else
	return;
      break;
    case cache_value:
      if ((what_to_declare != undef_variables)
	  || !(what_to_do & put_values_in_icache))
	{
	  reason = "cache";
	  what_to_declare = ((what_to_do & put_values_in_icache)
			     ? declare_variables : what_to_declare);
	}
      else
	return;
      break;
    default:
      abort ();			/* Bad switch.  */
    }

  /* For the type, default to a simple unsigned */
  if (entry_type == NULL || strlen (entry_type) == 0)
    entry_type = "unsigned";

  /* look through the set of expanded sub fields to see if this field
     has been given a constant value */
  for (bits = expanded_bits; bits != NULL; bits = bits->next)
    {
      if (bits->field == cur_field)
	break;
    }

  /* Define a storage area for the cache element */
  switch (what_to_declare)
    {
    case undef_variables:
      /* We've finished with the #define value - destory it */
      lf_indent_suppress (file);
      lf_printf (file, "#undef %s\n", entry_name);
      return;
    case define_variables:
      /* Using direct access for this entry, clear any prior
         definition, then define it */
      lf_indent_suppress (file);
      lf_printf (file, "#undef %s\n", entry_name);
      /* Don't type cast pointer types! */
      lf_indent_suppress (file);
      if (strchr (entry_type, '*') != NULL)
	lf_printf (file, "#define %s (", entry_name);
      else
	lf_printf (file, "#define %s ((%s) ", entry_name, entry_type);
      break;
    case declare_variables:
      /* using variables to define the value */
      if (line != NULL)
	lf_print__line_ref (file, line);
      lf_printf (file, "%s const %s UNUSED = ", entry_type, entry_name);
      break;
    }


  /* define a value for that storage area as determined by what is in
     the cache */
  if (bits != NULL
      && single_insn_field != NULL
      && strcmp (entry_name, single_insn_field) == 0
      && strcmp (entry_name, cur_field->val_string) == 0
      && ((bits->opcode->is_boolean && bits->value == 0)
	  || (!bits->opcode->is_boolean)))
    {
      /* The cache rule is specifying what to do with a simple
         instruction field.

         Because of instruction expansion, the field is either a
         constant value or equal to the specified constant (boolean
         comparison). (The latter indicated by bits->value == 0).

         The case of a field not being equal to the specified boolean
         value is handled later. */
      expression = "constant field";
      ASSERT (bits->field == cur_field);
      if (bits->opcode->is_boolean)
	{
	  ASSERT (bits->value == 0);
	  lf_printf (file, "%d", bits->opcode->boolean_constant);
	}
      else if (bits->opcode->last < bits->field->last)
	{
	  lf_printf (file, "%d",
		     bits->value << (bits->field->last - bits->opcode->last));
	}
      else
	{
	  lf_printf (file, "%d", bits->value);
	}
    }
  else if (bits != NULL
	   && single_insn_field != NULL
	   && strncmp (entry_name,
		       single_insn_field,
		       strlen (single_insn_field)) == 0
	   && strncmp (entry_name + strlen (single_insn_field),
		       "_is_",
		       strlen ("_is_")) == 0
	   && ((bits->opcode->is_boolean
		&& ((unsigned)
		    atol (entry_name + strlen (single_insn_field) +
			  strlen ("_is_")) == bits->opcode->boolean_constant))
	       || (!bits->opcode->is_boolean)))
    {
      /* The cache rule defines an entry for the comparison between a
         single instruction field and a constant.  The value of the
         comparison in someway matches that of the opcode field that
         was made constant through expansion. */
      expression = "constant compare";
      if (bits->opcode->is_boolean)
	{
	  lf_printf (file, "%d /* %s == %d */",
		     bits->value == 0,
		     single_insn_field, bits->opcode->boolean_constant);
	}
      else if (bits->opcode->last < bits->field->last)
	{
	  lf_printf (file, "%d /* %s == %d */",
		     (atol
		      (entry_name + strlen (single_insn_field) +
		       strlen ("_is_")) ==
		      (bits->
		       value << (bits->field->last - bits->opcode->last))),
		     single_insn_field,
		     (bits->
		      value << (bits->field->last - bits->opcode->last)));
	}
      else
	{
	  lf_printf (file, "%d /* %s == %d */",
		     (atol
		      (entry_name + strlen (single_insn_field) +
		       strlen ("_is_")) == bits->value), single_insn_field,
		     bits->value);
	}
    }
  else
    {
      /* put the field in the local variable, possibly also enter it
         into the cache */
      expression = "extraction";
      /* handle the cache */
      if ((what_to_do & get_values_from_icache)
	  || (what_to_do & put_values_in_icache))
	{
	  lf_printf (file, "cache_entry->crack.%s.%s",
		     format_name, entry_name);
	  if (what_to_do & put_values_in_icache)	/* also put it in the cache? */
	    {
	      lf_printf (file, " = ");
	    }
	}
      if ((what_to_do & put_values_in_icache)
	  || what_to_do == do_not_use_icache)
	{
	  if (cur_field != NULL)
	    {
	      if (entry_expression != NULL && strlen (entry_expression) > 0)
		error (line,
		       "Instruction field entry with nonempty expression\n");
	      if (cur_field->first == 0
		  && cur_field->last == options.insn_bit_size - 1)
		lf_printf (file, "(instruction_%d)", cur_field->word_nr);
	      else if (cur_field->last == options.insn_bit_size - 1)
		lf_printf (file, "MASKED%d (instruction_%d, %d, %d)",
			   options.insn_bit_size,
			   cur_field->word_nr,
			   i2target (options.hi_bit_nr, cur_field->first),
			   i2target (options.hi_bit_nr, cur_field->last));
	      else
		lf_printf (file, "EXTRACTED%d (instruction_%d, %d, %d)",
			   options.insn_bit_size,
			   cur_field->word_nr,
			   i2target (options.hi_bit_nr, cur_field->first),
			   i2target (options.hi_bit_nr, cur_field->last));
	    }
	  else
	    {
	      lf_printf (file, "%s", entry_expression);
	    }
	}
    }

  switch (what_to_declare)
    {
    case define_variables:
      lf_printf (file, ")");
      break;
    case undef_variables:
      break;
    case declare_variables:
      lf_printf (file, ";");
      break;
    }

  ASSERT (reason != NULL && expression != NULL);
  lf_printf (file, " /* %s - %s */\n", reason, expression);
}


void
print_icache_body (lf *file,
		   insn_entry * instruction,
		   opcode_bits *expanded_bits,
		   cache_entry *cache_rules,
		   icache_decl_type what_to_declare,
		   icache_body_type what_to_do, int nr_prefetched_words)
{
  /* extract instruction fields */
  lf_printf (file, "/* Extraction: %s\n", instruction->name);
  lf_printf (file, "     ");
  switch (what_to_declare)
    {
    case define_variables:
      lf_printf (file, "#define");
      break;
    case declare_variables:
      lf_printf (file, "declare");
      break;
    case undef_variables:
      lf_printf (file, "#undef");
      break;
    }
  lf_printf (file, " ");
  switch (what_to_do)
    {
    case get_values_from_icache:
      lf_printf (file, "get-values-from-icache");
      break;
    case put_values_in_icache:
      lf_printf (file, "put-values-in-icache");
      break;
    case both_values_and_icache:
      lf_printf (file, "get-values-from-icache|put-values-in-icache");
      break;
    case do_not_use_icache:
      lf_printf (file, "do-not-use-icache");
      break;
    }
  lf_printf (file, "\n     ");
  print_insn_words (file, instruction);
  lf_printf (file, " */\n");

  /* pass zero - fetch from memory any missing instructions.

     Some of the instructions will have already been fetched (in the
     instruction array), others will still need fetching. */
  switch (what_to_do)
    {
    case get_values_from_icache:
      break;
    case put_values_in_icache:
    case both_values_and_icache:
    case do_not_use_icache:
      {
	int word_nr;
	switch (what_to_declare)
	  {
	  case undef_variables:
	    break;
	  case define_variables:
	  case declare_variables:
	    for (word_nr = nr_prefetched_words;
		 word_nr < instruction->nr_words; word_nr++)
	      {
		/* FIXME - should be using print_icache_extraction? */
		lf_printf (file,
			   "%sinstruction_word instruction_%d UNUSED = ",
			   options.module.global.prefix.l, word_nr);
		lf_printf (file, "IMEM%d_IMMED (cia, %d)",
			   options.insn_bit_size, word_nr);
		lf_printf (file, ";\n");
	      }
	  }
      }
    }

  /* if putting the instruction words in the cache, define references
     for them */
  if (options.gen.insn_in_icache)
    {
      /* FIXME: is the instruction_word type correct? */
      print_icache_extraction (file, instruction->format_name, cache_value, "insn",	/* name */
			       "instruction_word",	/* type */
			       "instruction",	/* expression */
			       NULL,	/* origin */
			       NULL,	/* line */
			       NULL, NULL, what_to_declare, what_to_do);
    }
  lf_printf (file, "\n");

  /* pass one - process instruction fields.

     If there is no cache rule, the default is to enter the field into
     the cache */
  {
    insn_word_entry *word;
    for (word = instruction->words; word != NULL; word = word->next)
      {
	insn_field_entry *cur_field;
	for (cur_field = word->first;
	     cur_field->first < options.insn_bit_size;
	     cur_field = cur_field->next)
	  {
	    /* Always expand named fields (even if constant), so
	       references are valid.  */
	    if (cur_field->type == insn_field_string)
	      {
		cache_entry *cache_rule;
		cache_entry_type value_type = cache_value;
		line_ref *value_line = instruction->line;
		/* check the cache table to see if it contains a rule
		   overriding the default cache action for an
		   instruction field */
		for (cache_rule = cache_rules;
		     cache_rule != NULL; cache_rule = cache_rule->next)
		  {
		    if (filter_is_subset (instruction->field_names,
					  cache_rule->original_fields)
			&& strcmp (cache_rule->name,
				   cur_field->val_string) == 0)
		      {
			value_type = cache_rule->entry_type;
			value_line = cache_rule->line;
			if (value_type == compute_value)
			  {
			    options.warning (cache_rule->line,
					     "instruction field of type `compute' changed to `cache'\n");
			    cache_rule->entry_type = cache_value;
			  }
			break;
		      }
		  }
		/* Define an entry for the field within the
		   instruction */
		print_icache_extraction (file, instruction->format_name, value_type, cur_field->val_string,	/* name */
					 NULL,	/* type */
					 NULL,	/* expression */
					 cur_field->val_string,	/* insn field */
					 value_line,
					 cur_field,
					 expanded_bits,
					 what_to_declare, what_to_do);
	      }
	  }
      }
  }

  /* pass two - any cache fields not processed above */
  {
    cache_entry *cache_rule;
    for (cache_rule = cache_rules;
	 cache_rule != NULL; cache_rule = cache_rule->next)
      {
	if (filter_is_subset (instruction->field_names,
			      cache_rule->original_fields)
	    && !filter_is_member (instruction->field_names, cache_rule->name))
	  {
	    char *single_field =
	      filter_next (cache_rule->original_fields, "");
	    if (filter_next (cache_rule->original_fields, single_field) !=
		NULL)
	      single_field = NULL;
	    print_icache_extraction (file, instruction->format_name, cache_rule->entry_type, cache_rule->name, cache_rule->type, cache_rule->expression, single_field, cache_rule->line, NULL,	/* cur_field */
				     expanded_bits,
				     what_to_declare, what_to_do);
	  }
      }
  }

  lf_print__internal_ref (file);
}



typedef struct _form_fields form_fields;
struct _form_fields
{
  char *name;
  filter *fields;
  form_fields *next;
};

static form_fields *
insn_table_cache_fields (insn_table *isa)
{
  form_fields *forms = NULL;
  insn_entry *insn;
  for (insn = isa->insns; insn != NULL; insn = insn->next)
    {
      form_fields **form = &forms;
      while (1)
	{
	  if (*form == NULL)
	    {
	      /* new format name, add it */
	      form_fields *new_form = ZALLOC (form_fields);
	      new_form->name = insn->format_name;
	      filter_add (&new_form->fields, insn->field_names);
	      *form = new_form;
	      break;
	    }
	  else if (strcmp ((*form)->name, insn->format_name) == 0)
	    {
	      /* already present, add field names to the existing list */
	      filter_add (&(*form)->fields, insn->field_names);
	      break;
	    }
	  form = &(*form)->next;
	}
    }
  return forms;
}



extern void
print_icache_struct (lf *file, insn_table *isa, cache_entry *cache_rules)
{
  /* Create a list of all the different instruction formats with their
     corresponding field names. */
  form_fields *formats = insn_table_cache_fields (isa);

  lf_printf (file, "\n");
  lf_printf (file, "#define WITH_%sIDECODE_CACHE_SIZE %d\n",
	     options.module.global.prefix.u,
	     (options.gen.icache ? options.gen.icache_size : 0));
  lf_printf (file, "\n");

  /* create an instruction cache if being used */
  if (options.gen.icache)
    {
      lf_printf (file, "typedef struct _%sidecode_cache {\n",
		 options.module.global.prefix.l);
      lf_indent (file, +2);
      {
	form_fields *format;
	lf_printf (file, "unsigned_word address;\n");
	lf_printf (file, "void *semantic;\n");
	lf_printf (file, "union {\n");
	lf_indent (file, +2);
	for (format = formats; format != NULL; format = format->next)
	  {
	    lf_printf (file, "struct {\n");
	    lf_indent (file, +2);
	    {
	      cache_entry *cache_rule;
	      char *field;
	      /* space for any instruction words */
	      if (options.gen.insn_in_icache)
		lf_printf (file, "instruction_word insn[%d];\n",
			   isa->max_nr_words);
	      /* define an entry for any applicable cache rules */
	      for (cache_rule = cache_rules;
		   cache_rule != NULL; cache_rule = cache_rule->next)
		{
		  /* nb - sort of correct - should really check against
		     individual instructions */
		  if (filter_is_subset
		      (format->fields, cache_rule->original_fields))
		    {
		      char *memb;
		      lf_printf (file, "%s %s;",
				 (cache_rule->type == NULL
				  ? "unsigned"
				  : cache_rule->type), cache_rule->name);
		      lf_printf (file, " /*");
		      for (memb =
			   filter_next (cache_rule->original_fields, "");
			   memb != NULL;
			   memb =
			   filter_next (cache_rule->original_fields, memb))
			{
			  lf_printf (file, " %s", memb);
			}
		      lf_printf (file, " */\n");
		    }
		}
	      /* define an entry for any fields not covered by a cache rule */
	      for (field = filter_next (format->fields, "");
		   field != NULL; field = filter_next (format->fields, field))
		{
		  cache_entry *cache_rule;
		  int found_rule = 0;
		  for (cache_rule = cache_rules;
		       cache_rule != NULL; cache_rule = cache_rule->next)
		    {
		      if (strcmp (cache_rule->name, field) == 0)
			{
			  found_rule = 1;
			  break;
			}
		    }
		  if (!found_rule)
		    lf_printf (file, "unsigned %s; /* default */\n", field);
		}
	    }
	    lf_indent (file, -2);
	    lf_printf (file, "} %s;\n", format->name);
	  }
	lf_indent (file, -2);
	lf_printf (file, "} crack;\n");
      }
      lf_indent (file, -2);
      lf_printf (file, "} %sidecode_cache;\n",
		 options.module.global.prefix.l);
    }
  else
    {
      /* alernativly, since no cache, emit a dummy definition for
         idecode_cache so that code refering to the type can still compile */
      lf_printf (file, "typedef void %sidecode_cache;\n",
		 options.module.global.prefix.l);
    }
  lf_printf (file, "\n");
}



static void
print_icache_function (lf *file,
		       insn_entry * instruction,
		       opcode_bits *expanded_bits,
		       insn_opcodes *opcodes,
		       cache_entry *cache_rules, int nr_prefetched_words)
{
  int indent;

  /* generate code to enter decoded instruction into the icache */
  lf_printf (file, "\n");
  lf_print__function_type_function (file, print_icache_function_type,
				    "EXTERN_ICACHE", "\n");
  indent = print_function_name (file,
				instruction->name,
				instruction->format_name,
				NULL,
				expanded_bits, function_name_prefix_icache);
  indent += lf_printf (file, " ");
  lf_indent (file, +indent);
  lf_printf (file, "(");
  print_icache_function_formal (file, nr_prefetched_words);
  lf_printf (file, ")\n");
  lf_indent (file, -indent);

  /* function header */
  lf_printf (file, "{\n");
  lf_indent (file, +2);

  print_my_defines (file,
		    instruction->name,
		    instruction->format_name, expanded_bits);
  print_itrace (file, instruction, 1 /*putting-value-in-cache */ );

  print_idecode_validate (file, instruction, opcodes);

  lf_printf (file, "\n");
  lf_printf (file, "{\n");
  lf_indent (file, +2);
  if (options.gen.semantic_icache)
    lf_printf (file, "unsigned_word nia;\n");
  print_icache_body (file,
		     instruction,
		     expanded_bits,
		     cache_rules,
		     (options.gen.direct_access
		      ? define_variables
		      : declare_variables),
		     (options.gen.semantic_icache
		      ? both_values_and_icache
		      : put_values_in_icache), nr_prefetched_words);

  lf_printf (file, "\n");
  lf_printf (file, "cache_entry->address = cia;\n");
  lf_printf (file, "cache_entry->semantic = ");
  print_function_name (file,
		       instruction->name,
		       instruction->format_name,
		       NULL, expanded_bits, function_name_prefix_semantics);
  lf_printf (file, ";\n");
  lf_printf (file, "\n");

  if (options.gen.semantic_icache)
    {
      lf_printf (file, "/* semantic routine */\n");
      print_semantic_body (file, instruction, expanded_bits, opcodes);
      lf_printf (file, "return nia;\n");
    }

  if (!options.gen.semantic_icache)
    {
      lf_printf (file, "/* return the function proper */\n");
      lf_printf (file, "return ");
      print_function_name (file,
			   instruction->name,
			   instruction->format_name,
			   NULL,
			   expanded_bits, function_name_prefix_semantics);
      lf_printf (file, ";\n");
    }

  if (options.gen.direct_access)
    {
      print_icache_body (file,
			 instruction,
			 expanded_bits,
			 cache_rules,
			 undef_variables,
			 (options.gen.semantic_icache
			  ? both_values_and_icache
			  : put_values_in_icache), nr_prefetched_words);
    }

  lf_indent (file, -2);
  lf_printf (file, "}\n");
  lf_indent (file, -2);
  lf_printf (file, "}\n");
}


void
print_icache_definition (lf *file,
			 insn_entry * insn,
			 opcode_bits *expanded_bits,
			 insn_opcodes *opcodes,
			 cache_entry *cache_rules, int nr_prefetched_words)
{
  print_icache_function (file,
			 insn,
			 expanded_bits,
			 opcodes, cache_rules, nr_prefetched_words);
}



void
print_icache_internal_function_declaration (lf *file,
					    function_entry * function,
					    void *data)
{
  ASSERT (options.gen.icache);
  if (function->is_internal)
    {
      lf_printf (file, "\n");
      lf_print__function_type_function (file, print_icache_function_type,
					"INLINE_ICACHE", "\n");
      print_function_name (file,
			   function->name,
			   NULL, NULL, NULL, function_name_prefix_icache);
      lf_printf (file, "\n(");
      print_icache_function_formal (file, 0);
      lf_printf (file, ");\n");
    }
}


void
print_icache_internal_function_definition (lf *file,
					   function_entry * function,
					   void *data)
{
  ASSERT (options.gen.icache);
  if (function->is_internal)
    {
      lf_printf (file, "\n");
      lf_print__function_type_function (file, print_icache_function_type,
					"INLINE_ICACHE", "\n");
      print_function_name (file,
			   function->name,
			   NULL, NULL, NULL, function_name_prefix_icache);
      lf_printf (file, "\n(");
      print_icache_function_formal (file, 0);
      lf_printf (file, ")\n");
      lf_printf (file, "{\n");
      lf_indent (file, +2);
      lf_printf (file, "/* semantic routine */\n");
      if (options.gen.semantic_icache)
	{
	  lf_print__line_ref (file, function->code->line);
	  table_print_code (file, function->code);
	  lf_printf (file,
		     "error (\"Internal function must longjump\\n\");\n");
	  lf_printf (file, "return 0;\n");
	}
      else
	{
	  lf_printf (file, "return ");
	  print_function_name (file,
			       function->name,
			       NULL,
			       NULL, NULL, function_name_prefix_semantics);
	  lf_printf (file, ";\n");
	}

      lf_print__internal_ref (file);
      lf_indent (file, -2);
      lf_printf (file, "}\n");
    }
}
@


1.12
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright 2002, 2007-2012 Free Software Foundation, Inc.
@


1.11
log
@	Correct handling of constant fields.
	* gen.c (insn_field_cmp): Tweak comment about neither field
	being an insn_field_string with a cond_eq-to-value condition.
	(insns_bit_useless) <case insn_field_string, case
	decode_find_mixed>: Handle cond_eq-to-value fields as
	insn_field_int.
	* gen-idecode.c (print_idecode_validate): Handle
	insn_field_string cond-equal-to-value fields as insn_field_int.
	* gen-icache.c (print_icache_body): Add comment why constant
	string fields are handled.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.11.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright 2002, 2007-2012 Free Software Foundation, Inc.
@


1.10
log
@run copyright.sh for 2011.
@
text
@d427 2
@


1.9
log
@Update copyright notices to add year 2010.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.8
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.7
log
@	Updated copyright notices for most files.
@
text
@d3 1
a3 1
   Copyright 2002, 2007, 2008 Free Software Foundation, Inc.
@


1.6
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d3 1
a3 1
   Copyright 2002, 2007 Free Software Foundation, Inc.
@


1.5
log
@Copyright updates for 2007.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.4
log
@2002-11-21  Andrew Cagney  <ac131313@@redhat.com>

	* filter.c: Re-indent.
	* filter.h, filter_host.h, gen-engine.c, gen-engine.h: Ditto.
	* gen-icache.c, gen-icache.h, gen-idecode.c: Ditto.
	* gen-idecode.h, gen-itable.c, gen-itable.h: Ditto.
	* gen-model.c, gen-model.h, gen-semantics.c: Ditto.
	* gen-semantics.h, gen-support.c, gen-support.h: Ditto.
	* gen.c, gen.h, igen.c, igen.h, ld-cache.c, ld-cache.h: Ditto.
	* ld-decode.c, ld-decode.h, ld-insn.c, ld-insn.h, lf.c: Ditto.
	* lf.h, misc.c, misc.h, table.c, table.h: Ditto.
@
text
@d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
@


1.3
log
@2002-11-21  Andrew Cagney  <ac131313@@redhat.com>

        * Makefile.in: Update copyright.  IGEN contributed to the FSF.
        * filter.c, filter.h, filter_host.c, filter_host.h: Ditto.
        * gen-engine.c, gen-engine.h, gen-icache.c, gen-icache.h: Ditto.
        * gen-idecode.c, gen-idecode.h, gen-itable.c: Ditto.
        * gen-itable.h, gen-model.c, gen-model.h, gen-semantics.c: Ditto.
        * gen-semantics.h, gen-support.c, gen-support.h, gen.c: Ditto.
        * gen.h, igen.c, igen.h, ld-cache.c, ld-cache.h: Ditto.
        * ld-decode.c, ld-decode.h, ld-insn.c, ld-insn.h, lf.c: Ditto.
        * lf.h, misc.c, misc.h, table.c, table.h: Ditto.
@
text
@d50 1
a50 1
  lf_printf(file, "\n");
d55 1
a55 2
		       expanded_bits,
		       function_name_prefix_icache);
d67 1
a67 1
			  insn_entry *insn,
d69 1
a69 2
			  insn_opcodes *opcodes,
			  int nr_prefetched_words)
d75 1
a75 1
				0/* is not function definition */,
d100 1
a100 1
  
d130 1
a130 2
			     ? declare_variables
			     : what_to_declare);
d136 1
a136 1
      abort (); /* Bad switch.  */
d138 1
a138 1
  
d142 1
a142 1
  
d145 1
a145 3
  for (bits = expanded_bits;
       bits != NULL;
       bits = bits->next)
d150 1
a150 1
  
d178 2
a179 2
  
  
d191 5
a195 5
	 
	 Because of instruction expansion, the field is either a
	 constant value or equal to the specified constant (boolean
	 comparison). (The latter indicated by bits->value == 0).
	 
d224 3
a226 2
		&& ((unsigned) atol (entry_name + strlen (single_insn_field) + strlen ("_is_"))
		    == bits->opcode->boolean_constant))
d230 3
a232 3
	 single instruction field and a constant.  The value of the
	 comparison in someway matches that of the opcode field that
	 was made constant through expansion. */
d238 1
a238 2
		     single_insn_field,
		     bits->opcode->boolean_constant);
d243 5
a247 2
		     (atol (entry_name + strlen (single_insn_field) + strlen ("_is_"))
		      == (bits->value << (bits->field->last - bits->opcode->last))),
d249 2
a250 1
		     (bits->value << (bits->field->last - bits->opcode->last)));
d255 3
a257 3
		     (atol (entry_name + strlen (single_insn_field) + strlen ("_is_"))
		      == bits->value),
		     single_insn_field,
d264 1
a264 1
	 into the cache */
d271 2
a272 3
		     format_name,
		     entry_name);
	  if (what_to_do & put_values_in_icache) /* also put it in the cache? */
d283 5
a287 4
		error (line, "Instruction field entry with nonempty expression\n");
	      if (cur_field->first == 0 && cur_field->last == options.insn_bit_size - 1)
		lf_printf (file, "(instruction_%d)",
			   cur_field->word_nr);
d307 1
a307 1
  
d327 1
a327 1
		   insn_entry *instruction,
d331 1
a331 2
		   icache_body_type what_to_do,
		   int nr_prefetched_words)
d366 2
a367 2
  lf_printf(file, " */\n");
  
d388 1
a388 2
		 word_nr < instruction->nr_words;
		 word_nr++)
d391 3
a393 3
		lf_printf (file, "%sinstruction_word instruction_%d UNUSED = ",
			   options.module.global.prefix.l,
			   word_nr);
d404 11
a414 15
  if (options.gen.insn_in_icache) {
    /* FIXME: is the instruction_word type correct? */
    print_icache_extraction (file,
			     instruction->format_name,
			     cache_value,
			     "insn", /* name */
			     "instruction_word", /* type */
			     "instruction", /* expression */
			     NULL, /* origin */
			     NULL, /* line */
			     NULL, NULL,
			     what_to_declare,
			     what_to_do);
  }
  lf_printf(file, "\n");
d422 1
a422 3
    for (word = instruction->words;
	 word != NULL;
	 word = word->next)
d438 1
a438 2
		     cache_rule != NULL;
		     cache_rule = cache_rule->next)
d442 2
a443 1
			&& strcmp (cache_rule->name, cur_field->val_string) == 0)
d457 5
a461 8
                   instruction */
		print_icache_extraction (file,
					 instruction->format_name,
					 value_type,
					 cur_field->val_string, /* name */
					 NULL, /* type */
					 NULL, /* expression */
					 cur_field->val_string, /* insn field */
d465 1
a465 2
					 what_to_declare,
					 what_to_do);
d475 1
a475 2
	 cache_rule != NULL;
	 cache_rule = cache_rule->next)
d479 1
a479 2
	    && !filter_is_member (instruction->field_names,
				  cache_rule->name))
d481 4
a484 2
	    char *single_field = filter_next (cache_rule->original_fields, "");
	    if (filter_next (cache_rule->original_fields, single_field) != NULL)
d486 1
a486 9
	    print_icache_extraction (file,
				     instruction->format_name,
				     cache_rule->entry_type,
				     cache_rule->name,
				     cache_rule->type,
				     cache_rule->expression,
				     single_field,
				     cache_rule->line,
				     NULL, /* cur_field */
d488 1
a488 2
				     what_to_declare,
				     what_to_do);
d499 2
a500 1
struct _form_fields {
d511 23
a533 24
  for (insn = isa->insns;
       insn != NULL;
       insn = insn->next) {
    form_fields **form = &forms;
    while (1)
      {
	if (*form == NULL)
	  {
	    /* new format name, add it */
	    form_fields *new_form = ZALLOC (form_fields);
	    new_form->name = insn->format_name;
	    filter_add (&new_form->fields, insn->field_names);
	    *form = new_form;
	    break;
	  }
	else if (strcmp ((*form)->name, insn->format_name) == 0)
	  {
	    /* already present, add field names to the existing list */
	    filter_add (&(*form)->fields, insn->field_names);
	    break;
	  }
	form = &(*form)->next;
      }
  }
d540 1
a540 3
print_icache_struct (lf *file,
		     insn_table *isa,
		     cache_entry *cache_rules)
d545 1
a545 1
  
d551 1
a551 1
  
d553 4
a556 9
  if (options.gen.icache) {
    lf_printf (file, "typedef struct _%sidecode_cache {\n",
	       options.module.global.prefix.l);
    lf_indent (file, +2);
    {
      form_fields *format;
      lf_printf (file, "unsigned_word address;\n");
      lf_printf (file, "void *semantic;\n");
      lf_printf (file, "union {\n");
d558 7
a564 6
      for (format = formats;
	   format != NULL;
	   format = format->next)
	{
	  lf_printf (file, "struct {\n");
	  lf_indent (file, +2);
d566 56
a621 50
	    cache_entry *cache_rule;
	    char *field;
	    /* space for any instruction words */
	    if (options.gen.insn_in_icache)
	      lf_printf (file, "instruction_word insn[%d];\n", isa->max_nr_words);
	    /* define an entry for any applicable cache rules */
	    for (cache_rule = cache_rules;
		 cache_rule != NULL;
		 cache_rule = cache_rule->next)
	      {
		/* nb - sort of correct - should really check against
                   individual instructions */
		if (filter_is_subset (format->fields, cache_rule->original_fields))
		  {
		    char *memb;
		    lf_printf (file, "%s %s;",
			       (cache_rule->type == NULL
				? "unsigned" 
				: cache_rule->type),
			       cache_rule->name);
		    lf_printf (file, " /*");
		    for (memb = filter_next (cache_rule->original_fields, "");
			 memb != NULL;
			 memb = filter_next (cache_rule->original_fields, memb))
		      {
			lf_printf (file, " %s", memb);
		      }
		    lf_printf (file, " */\n");
		  }
	      }
	    /* define an entry for any fields not covered by a cache rule */
	    for (field = filter_next (format->fields, "");
		 field != NULL;
		 field = filter_next (format->fields, field))
	      {
		cache_entry *cache_rule;
		int found_rule = 0;
		for (cache_rule = cache_rules;
		     cache_rule != NULL;
		     cache_rule = cache_rule->next)
		  {
		    if (strcmp (cache_rule->name, field) == 0)
		      {
			found_rule = 1;
			break;
		      }
		  }
		if (!found_rule)
		  lf_printf (file, "unsigned %s; /* default */\n", field);
	      }
d623 3
a625 3
	  lf_indent (file, -2);
	  lf_printf (file, "} %s;\n", format->name);
	}
d627 2
a628 1
      lf_printf (file, "} crack;\n");
a629 3
    lf_indent (file, -2);
    lf_printf (file, "} %sidecode_cache;\n", options.module.global.prefix.l);
  }
d633 3
a635 3
	 idecode_cache so that code refering to the type can still compile */
      lf_printf(file, "typedef void %sidecode_cache;\n",
		options.module.global.prefix.l);
d644 1
a644 1
		       insn_entry *instruction,
d647 1
a647 2
		       cache_entry *cache_rules,
		       int nr_prefetched_words)
d652 1
a652 1
  lf_printf(file, "\n");
d659 1
a659 2
				expanded_bits,
				function_name_prefix_icache);
d666 1
a666 1
  
d670 1
a670 1
  
d673 3
a675 4
		    instruction->format_name,
		    expanded_bits);
  print_itrace (file, instruction, 1/*putting-value-in-cache*/);
  
d677 1
a677 1
  
d692 2
a693 3
		      : put_values_in_icache),
		     nr_prefetched_words);
  
d700 1
a700 3
		       NULL,
		       expanded_bits,
		       function_name_prefix_semantics);
d704 7
a710 9
  if (options.gen.semantic_icache) {
    lf_printf (file, "/* semantic routine */\n");
    print_semantic_body (file,
			 instruction,
			 expanded_bits,
			 opcodes);
    lf_printf (file, "return nia;\n");
  }
  
d719 1
a719 2
			   expanded_bits,
			   function_name_prefix_semantics);
d722 1
a722 1
  
d732 1
a732 2
			  : put_values_in_icache),
			 nr_prefetched_words);
d734 1
a734 1
  
d744 1
a744 1
			 insn_entry *insn,
d747 1
a747 2
			 cache_entry *cache_rules,
			 int nr_prefetched_words)
d752 1
a752 3
			 opcodes,
			 cache_rules,
			 nr_prefetched_words);
d759 1
a759 1
					    function_entry *function,
d770 1
a770 4
			   NULL,
			   NULL,
			   NULL,
			   function_name_prefix_icache);
d780 1
a780 1
					   function_entry *function,
d791 1
a791 4
			   NULL,
			   NULL,
			   NULL,
			   function_name_prefix_icache);
d802 2
a803 1
	  lf_printf (file, "error (\"Internal function must longjump\\n\");\n");
d812 1
a812 3
			       NULL,
			       NULL,
			       function_name_prefix_semantics);
d815 1
a815 1
      
@


1.2
log
@* gen.c (gen_entry_expand_opcode): Initialize ``value'' to -1 and
``t'' to NULL.
* igen.c (main): Add default case to switch.
* gen-icache.c (print_icache_extraction): Ditto.
@
text
@d1 1
a1 1
/*  This file is part of the program psim.
d3 1
a3 1
    Copyright (C) 1994-1998, Andrew Cagney <cagney@@highland.com.au>
d5 18
a22 15
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
    */
@


1.2.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1 1
a1 1
/* The IGEN simulator generator for GDB, the GNU Debugger.
d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d5 15
a19 18
   Contributed by Andrew Cagney.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d47 1
a47 1
  lf_printf (file, "\n");
d52 2
a53 1
		       expanded_bits, function_name_prefix_icache);
d65 1
a65 1
			  insn_entry * insn,
d67 2
a68 1
			  insn_opcodes *opcodes, int nr_prefetched_words)
d74 1
a74 1
				0 /* is not function definition */ ,
d99 1
a99 1

d129 2
a130 1
			     ? declare_variables : what_to_declare);
d136 1
a136 1
      abort ();			/* Bad switch.  */
d138 1
a138 1

d142 1
a142 1

d145 3
a147 1
  for (bits = expanded_bits; bits != NULL; bits = bits->next)
d152 1
a152 1

d180 2
a181 2


d193 5
a197 5

         Because of instruction expansion, the field is either a
         constant value or equal to the specified constant (boolean
         comparison). (The latter indicated by bits->value == 0).

d226 2
a227 3
		&& ((unsigned)
		    atol (entry_name + strlen (single_insn_field) +
			  strlen ("_is_")) == bits->opcode->boolean_constant))
d231 3
a233 3
         single instruction field and a constant.  The value of the
         comparison in someway matches that of the opcode field that
         was made constant through expansion. */
d239 2
a240 1
		     single_insn_field, bits->opcode->boolean_constant);
d245 2
a246 5
		     (atol
		      (entry_name + strlen (single_insn_field) +
		       strlen ("_is_")) ==
		      (bits->
		       value << (bits->field->last - bits->opcode->last))),
d248 1
a248 2
		     (bits->
		      value << (bits->field->last - bits->opcode->last)));
d253 3
a255 3
		     (atol
		      (entry_name + strlen (single_insn_field) +
		       strlen ("_is_")) == bits->value), single_insn_field,
d262 1
a262 1
         into the cache */
d269 3
a271 2
		     format_name, entry_name);
	  if (what_to_do & put_values_in_icache)	/* also put it in the cache? */
d282 4
a285 5
		error (line,
		       "Instruction field entry with nonempty expression\n");
	      if (cur_field->first == 0
		  && cur_field->last == options.insn_bit_size - 1)
		lf_printf (file, "(instruction_%d)", cur_field->word_nr);
d305 1
a305 1

d325 1
a325 1
		   insn_entry * instruction,
d329 2
a330 1
		   icache_body_type what_to_do, int nr_prefetched_words)
d365 2
a366 2
  lf_printf (file, " */\n");

d387 2
a388 1
		 word_nr < instruction->nr_words; word_nr++)
d391 3
a393 3
		lf_printf (file,
			   "%sinstruction_word instruction_%d UNUSED = ",
			   options.module.global.prefix.l, word_nr);
d404 15
a418 11
  if (options.gen.insn_in_icache)
    {
      /* FIXME: is the instruction_word type correct? */
      print_icache_extraction (file, instruction->format_name, cache_value, "insn",	/* name */
			       "instruction_word",	/* type */
			       "instruction",	/* expression */
			       NULL,	/* origin */
			       NULL,	/* line */
			       NULL, NULL, what_to_declare, what_to_do);
    }
  lf_printf (file, "\n");
d426 3
a428 1
    for (word = instruction->words; word != NULL; word = word->next)
d444 2
a445 1
		     cache_rule != NULL; cache_rule = cache_rule->next)
d449 1
a449 2
			&& strcmp (cache_rule->name,
				   cur_field->val_string) == 0)
d463 8
a470 5
		   instruction */
		print_icache_extraction (file, instruction->format_name, value_type, cur_field->val_string,	/* name */
					 NULL,	/* type */
					 NULL,	/* expression */
					 cur_field->val_string,	/* insn field */
d474 2
a475 1
					 what_to_declare, what_to_do);
d485 2
a486 1
	 cache_rule != NULL; cache_rule = cache_rule->next)
d490 2
a491 1
	    && !filter_is_member (instruction->field_names, cache_rule->name))
d493 2
a494 4
	    char *single_field =
	      filter_next (cache_rule->original_fields, "");
	    if (filter_next (cache_rule->original_fields, single_field) !=
		NULL)
d496 9
a504 1
	    print_icache_extraction (file, instruction->format_name, cache_rule->entry_type, cache_rule->name, cache_rule->type, cache_rule->expression, single_field, cache_rule->line, NULL,	/* cur_field */
d506 2
a507 1
				     what_to_declare, what_to_do);
d518 1
a518 2
struct _form_fields
{
d529 24
a552 23
  for (insn = isa->insns; insn != NULL; insn = insn->next)
    {
      form_fields **form = &forms;
      while (1)
	{
	  if (*form == NULL)
	    {
	      /* new format name, add it */
	      form_fields *new_form = ZALLOC (form_fields);
	      new_form->name = insn->format_name;
	      filter_add (&new_form->fields, insn->field_names);
	      *form = new_form;
	      break;
	    }
	  else if (strcmp ((*form)->name, insn->format_name) == 0)
	    {
	      /* already present, add field names to the existing list */
	      filter_add (&(*form)->fields, insn->field_names);
	      break;
	    }
	  form = &(*form)->next;
	}
    }
d559 3
a561 1
print_icache_struct (lf *file, insn_table *isa, cache_entry *cache_rules)
d566 1
a566 1

d572 1
a572 1

d574 9
a582 4
  if (options.gen.icache)
    {
      lf_printf (file, "typedef struct _%sidecode_cache {\n",
		 options.module.global.prefix.l);
d584 6
a589 7
      {
	form_fields *format;
	lf_printf (file, "unsigned_word address;\n");
	lf_printf (file, "void *semantic;\n");
	lf_printf (file, "union {\n");
	lf_indent (file, +2);
	for (format = formats; format != NULL; format = format->next)
d591 50
a640 56
	    lf_printf (file, "struct {\n");
	    lf_indent (file, +2);
	    {
	      cache_entry *cache_rule;
	      char *field;
	      /* space for any instruction words */
	      if (options.gen.insn_in_icache)
		lf_printf (file, "instruction_word insn[%d];\n",
			   isa->max_nr_words);
	      /* define an entry for any applicable cache rules */
	      for (cache_rule = cache_rules;
		   cache_rule != NULL; cache_rule = cache_rule->next)
		{
		  /* nb - sort of correct - should really check against
		     individual instructions */
		  if (filter_is_subset
		      (format->fields, cache_rule->original_fields))
		    {
		      char *memb;
		      lf_printf (file, "%s %s;",
				 (cache_rule->type == NULL
				  ? "unsigned"
				  : cache_rule->type), cache_rule->name);
		      lf_printf (file, " /*");
		      for (memb =
			   filter_next (cache_rule->original_fields, "");
			   memb != NULL;
			   memb =
			   filter_next (cache_rule->original_fields, memb))
			{
			  lf_printf (file, " %s", memb);
			}
		      lf_printf (file, " */\n");
		    }
		}
	      /* define an entry for any fields not covered by a cache rule */
	      for (field = filter_next (format->fields, "");
		   field != NULL; field = filter_next (format->fields, field))
		{
		  cache_entry *cache_rule;
		  int found_rule = 0;
		  for (cache_rule = cache_rules;
		       cache_rule != NULL; cache_rule = cache_rule->next)
		    {
		      if (strcmp (cache_rule->name, field) == 0)
			{
			  found_rule = 1;
			  break;
			}
		    }
		  if (!found_rule)
		    lf_printf (file, "unsigned %s; /* default */\n", field);
		}
	    }
	    lf_indent (file, -2);
	    lf_printf (file, "} %s;\n", format->name);
d642 3
a644 3
	lf_indent (file, -2);
	lf_printf (file, "} crack;\n");
      }
d646 1
a646 2
      lf_printf (file, "} %sidecode_cache;\n",
		 options.module.global.prefix.l);
d648 3
d654 3
a656 3
         idecode_cache so that code refering to the type can still compile */
      lf_printf (file, "typedef void %sidecode_cache;\n",
		 options.module.global.prefix.l);
d665 1
a665 1
		       insn_entry * instruction,
d668 2
a669 1
		       cache_entry *cache_rules, int nr_prefetched_words)
d674 1
a674 1
  lf_printf (file, "\n");
d681 2
a682 1
				expanded_bits, function_name_prefix_icache);
d689 1
a689 1

d693 1
a693 1

d696 4
a699 3
		    instruction->format_name, expanded_bits);
  print_itrace (file, instruction, 1 /*putting-value-in-cache */ );

d701 1
a701 1

d716 3
a718 2
		      : put_values_in_icache), nr_prefetched_words);

d725 3
a727 1
		       NULL, expanded_bits, function_name_prefix_semantics);
d731 9
a739 7
  if (options.gen.semantic_icache)
    {
      lf_printf (file, "/* semantic routine */\n");
      print_semantic_body (file, instruction, expanded_bits, opcodes);
      lf_printf (file, "return nia;\n");
    }

d748 2
a749 1
			   expanded_bits, function_name_prefix_semantics);
d752 1
a752 1

d762 2
a763 1
			  : put_values_in_icache), nr_prefetched_words);
d765 1
a765 1

d775 1
a775 1
			 insn_entry * insn,
d778 2
a779 1
			 cache_entry *cache_rules, int nr_prefetched_words)
d784 3
a786 1
			 opcodes, cache_rules, nr_prefetched_words);
d793 1
a793 1
					    function_entry * function,
d804 4
a807 1
			   NULL, NULL, NULL, function_name_prefix_icache);
d817 1
a817 1
					   function_entry * function,
d828 4
a831 1
			   NULL, NULL, NULL, function_name_prefix_icache);
d842 1
a842 2
	  lf_printf (file,
		     "error (\"Internal function must longjump\\n\");\n");
d851 3
a853 1
			       NULL, NULL, function_name_prefix_semantics);
d856 1
a856 1

@


1.2.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d1 1
a1 1
/* The IGEN simulator generator for GDB, the GNU Debugger.
d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d5 15
a19 18
   Contributed by Andrew Cagney.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d47 1
a47 1
  lf_printf (file, "\n");
d52 2
a53 1
		       expanded_bits, function_name_prefix_icache);
d65 1
a65 1
			  insn_entry * insn,
d67 2
a68 1
			  insn_opcodes *opcodes, int nr_prefetched_words)
d74 1
a74 1
				0 /* is not function definition */ ,
d99 1
a99 1

d129 2
a130 1
			     ? declare_variables : what_to_declare);
d136 1
a136 1
      abort ();			/* Bad switch.  */
d138 1
a138 1

d142 1
a142 1

d145 3
a147 1
  for (bits = expanded_bits; bits != NULL; bits = bits->next)
d152 1
a152 1

d180 2
a181 2


d193 5
a197 5

         Because of instruction expansion, the field is either a
         constant value or equal to the specified constant (boolean
         comparison). (The latter indicated by bits->value == 0).

d226 2
a227 3
		&& ((unsigned)
		    atol (entry_name + strlen (single_insn_field) +
			  strlen ("_is_")) == bits->opcode->boolean_constant))
d231 3
a233 3
         single instruction field and a constant.  The value of the
         comparison in someway matches that of the opcode field that
         was made constant through expansion. */
d239 2
a240 1
		     single_insn_field, bits->opcode->boolean_constant);
d245 2
a246 5
		     (atol
		      (entry_name + strlen (single_insn_field) +
		       strlen ("_is_")) ==
		      (bits->
		       value << (bits->field->last - bits->opcode->last))),
d248 1
a248 2
		     (bits->
		      value << (bits->field->last - bits->opcode->last)));
d253 3
a255 3
		     (atol
		      (entry_name + strlen (single_insn_field) +
		       strlen ("_is_")) == bits->value), single_insn_field,
d262 1
a262 1
         into the cache */
d269 3
a271 2
		     format_name, entry_name);
	  if (what_to_do & put_values_in_icache)	/* also put it in the cache? */
d282 4
a285 5
		error (line,
		       "Instruction field entry with nonempty expression\n");
	      if (cur_field->first == 0
		  && cur_field->last == options.insn_bit_size - 1)
		lf_printf (file, "(instruction_%d)", cur_field->word_nr);
d305 1
a305 1

d325 1
a325 1
		   insn_entry * instruction,
d329 2
a330 1
		   icache_body_type what_to_do, int nr_prefetched_words)
d365 2
a366 2
  lf_printf (file, " */\n");

d387 2
a388 1
		 word_nr < instruction->nr_words; word_nr++)
d391 3
a393 3
		lf_printf (file,
			   "%sinstruction_word instruction_%d UNUSED = ",
			   options.module.global.prefix.l, word_nr);
d404 15
a418 11
  if (options.gen.insn_in_icache)
    {
      /* FIXME: is the instruction_word type correct? */
      print_icache_extraction (file, instruction->format_name, cache_value, "insn",	/* name */
			       "instruction_word",	/* type */
			       "instruction",	/* expression */
			       NULL,	/* origin */
			       NULL,	/* line */
			       NULL, NULL, what_to_declare, what_to_do);
    }
  lf_printf (file, "\n");
d426 3
a428 1
    for (word = instruction->words; word != NULL; word = word->next)
d444 2
a445 1
		     cache_rule != NULL; cache_rule = cache_rule->next)
d449 1
a449 2
			&& strcmp (cache_rule->name,
				   cur_field->val_string) == 0)
d463 8
a470 5
		   instruction */
		print_icache_extraction (file, instruction->format_name, value_type, cur_field->val_string,	/* name */
					 NULL,	/* type */
					 NULL,	/* expression */
					 cur_field->val_string,	/* insn field */
d474 2
a475 1
					 what_to_declare, what_to_do);
d485 2
a486 1
	 cache_rule != NULL; cache_rule = cache_rule->next)
d490 2
a491 1
	    && !filter_is_member (instruction->field_names, cache_rule->name))
d493 2
a494 4
	    char *single_field =
	      filter_next (cache_rule->original_fields, "");
	    if (filter_next (cache_rule->original_fields, single_field) !=
		NULL)
d496 9
a504 1
	    print_icache_extraction (file, instruction->format_name, cache_rule->entry_type, cache_rule->name, cache_rule->type, cache_rule->expression, single_field, cache_rule->line, NULL,	/* cur_field */
d506 2
a507 1
				     what_to_declare, what_to_do);
d518 1
a518 2
struct _form_fields
{
d529 24
a552 23
  for (insn = isa->insns; insn != NULL; insn = insn->next)
    {
      form_fields **form = &forms;
      while (1)
	{
	  if (*form == NULL)
	    {
	      /* new format name, add it */
	      form_fields *new_form = ZALLOC (form_fields);
	      new_form->name = insn->format_name;
	      filter_add (&new_form->fields, insn->field_names);
	      *form = new_form;
	      break;
	    }
	  else if (strcmp ((*form)->name, insn->format_name) == 0)
	    {
	      /* already present, add field names to the existing list */
	      filter_add (&(*form)->fields, insn->field_names);
	      break;
	    }
	  form = &(*form)->next;
	}
    }
d559 3
a561 1
print_icache_struct (lf *file, insn_table *isa, cache_entry *cache_rules)
d566 1
a566 1

d572 1
a572 1

d574 9
a582 4
  if (options.gen.icache)
    {
      lf_printf (file, "typedef struct _%sidecode_cache {\n",
		 options.module.global.prefix.l);
d584 6
a589 7
      {
	form_fields *format;
	lf_printf (file, "unsigned_word address;\n");
	lf_printf (file, "void *semantic;\n");
	lf_printf (file, "union {\n");
	lf_indent (file, +2);
	for (format = formats; format != NULL; format = format->next)
d591 50
a640 56
	    lf_printf (file, "struct {\n");
	    lf_indent (file, +2);
	    {
	      cache_entry *cache_rule;
	      char *field;
	      /* space for any instruction words */
	      if (options.gen.insn_in_icache)
		lf_printf (file, "instruction_word insn[%d];\n",
			   isa->max_nr_words);
	      /* define an entry for any applicable cache rules */
	      for (cache_rule = cache_rules;
		   cache_rule != NULL; cache_rule = cache_rule->next)
		{
		  /* nb - sort of correct - should really check against
		     individual instructions */
		  if (filter_is_subset
		      (format->fields, cache_rule->original_fields))
		    {
		      char *memb;
		      lf_printf (file, "%s %s;",
				 (cache_rule->type == NULL
				  ? "unsigned"
				  : cache_rule->type), cache_rule->name);
		      lf_printf (file, " /*");
		      for (memb =
			   filter_next (cache_rule->original_fields, "");
			   memb != NULL;
			   memb =
			   filter_next (cache_rule->original_fields, memb))
			{
			  lf_printf (file, " %s", memb);
			}
		      lf_printf (file, " */\n");
		    }
		}
	      /* define an entry for any fields not covered by a cache rule */
	      for (field = filter_next (format->fields, "");
		   field != NULL; field = filter_next (format->fields, field))
		{
		  cache_entry *cache_rule;
		  int found_rule = 0;
		  for (cache_rule = cache_rules;
		       cache_rule != NULL; cache_rule = cache_rule->next)
		    {
		      if (strcmp (cache_rule->name, field) == 0)
			{
			  found_rule = 1;
			  break;
			}
		    }
		  if (!found_rule)
		    lf_printf (file, "unsigned %s; /* default */\n", field);
		}
	    }
	    lf_indent (file, -2);
	    lf_printf (file, "} %s;\n", format->name);
d642 3
a644 3
	lf_indent (file, -2);
	lf_printf (file, "} crack;\n");
      }
d646 1
a646 2
      lf_printf (file, "} %sidecode_cache;\n",
		 options.module.global.prefix.l);
d648 3
d654 3
a656 3
         idecode_cache so that code refering to the type can still compile */
      lf_printf (file, "typedef void %sidecode_cache;\n",
		 options.module.global.prefix.l);
d665 1
a665 1
		       insn_entry * instruction,
d668 2
a669 1
		       cache_entry *cache_rules, int nr_prefetched_words)
d674 1
a674 1
  lf_printf (file, "\n");
d681 2
a682 1
				expanded_bits, function_name_prefix_icache);
d689 1
a689 1

d693 1
a693 1

d696 4
a699 3
		    instruction->format_name, expanded_bits);
  print_itrace (file, instruction, 1 /*putting-value-in-cache */ );

d701 1
a701 1

d716 3
a718 2
		      : put_values_in_icache), nr_prefetched_words);

d725 3
a727 1
		       NULL, expanded_bits, function_name_prefix_semantics);
d731 9
a739 7
  if (options.gen.semantic_icache)
    {
      lf_printf (file, "/* semantic routine */\n");
      print_semantic_body (file, instruction, expanded_bits, opcodes);
      lf_printf (file, "return nia;\n");
    }

d748 2
a749 1
			   expanded_bits, function_name_prefix_semantics);
d752 1
a752 1

d762 2
a763 1
			  : put_values_in_icache), nr_prefetched_words);
d765 1
a765 1

d775 1
a775 1
			 insn_entry * insn,
d778 2
a779 1
			 cache_entry *cache_rules, int nr_prefetched_words)
d784 3
a786 1
			 opcodes, cache_rules, nr_prefetched_words);
d793 1
a793 1
					    function_entry * function,
d804 4
a807 1
			   NULL, NULL, NULL, function_name_prefix_icache);
d817 1
a817 1
					   function_entry * function,
d828 4
a831 1
			   NULL, NULL, NULL, function_name_prefix_icache);
d842 1
a842 2
	  lf_printf (file,
		     "error (\"Internal function must longjump\\n\");\n");
d851 3
a853 1
			       NULL, NULL, function_name_prefix_semantics);
d856 1
a856 1

@


1.2.6.1
log
@Import all the copyright and indent changes from the mainline (also
richards's tweak).
@
text
@d1 1
a1 1
/* The IGEN simulator generator for GDB, the GNU Debugger.
d3 1
a3 1
   Copyright 2002 Free Software Foundation, Inc.
d5 15
a19 18
   Contributed by Andrew Cagney.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d47 1
a47 1
  lf_printf (file, "\n");
d52 2
a53 1
		       expanded_bits, function_name_prefix_icache);
d65 1
a65 1
			  insn_entry * insn,
d67 2
a68 1
			  insn_opcodes *opcodes, int nr_prefetched_words)
d74 1
a74 1
				0 /* is not function definition */ ,
d99 1
a99 1

d129 2
a130 1
			     ? declare_variables : what_to_declare);
d136 1
a136 1
      abort ();			/* Bad switch.  */
d138 1
a138 1

d142 1
a142 1

d145 3
a147 1
  for (bits = expanded_bits; bits != NULL; bits = bits->next)
d152 1
a152 1

d180 2
a181 2


d193 5
a197 5

         Because of instruction expansion, the field is either a
         constant value or equal to the specified constant (boolean
         comparison). (The latter indicated by bits->value == 0).

d226 2
a227 3
		&& ((unsigned)
		    atol (entry_name + strlen (single_insn_field) +
			  strlen ("_is_")) == bits->opcode->boolean_constant))
d231 3
a233 3
         single instruction field and a constant.  The value of the
         comparison in someway matches that of the opcode field that
         was made constant through expansion. */
d239 2
a240 1
		     single_insn_field, bits->opcode->boolean_constant);
d245 2
a246 5
		     (atol
		      (entry_name + strlen (single_insn_field) +
		       strlen ("_is_")) ==
		      (bits->
		       value << (bits->field->last - bits->opcode->last))),
d248 1
a248 2
		     (bits->
		      value << (bits->field->last - bits->opcode->last)));
d253 3
a255 3
		     (atol
		      (entry_name + strlen (single_insn_field) +
		       strlen ("_is_")) == bits->value), single_insn_field,
d262 1
a262 1
         into the cache */
d269 3
a271 2
		     format_name, entry_name);
	  if (what_to_do & put_values_in_icache)	/* also put it in the cache? */
d282 4
a285 5
		error (line,
		       "Instruction field entry with nonempty expression\n");
	      if (cur_field->first == 0
		  && cur_field->last == options.insn_bit_size - 1)
		lf_printf (file, "(instruction_%d)", cur_field->word_nr);
d305 1
a305 1

d325 1
a325 1
		   insn_entry * instruction,
d329 2
a330 1
		   icache_body_type what_to_do, int nr_prefetched_words)
d365 2
a366 2
  lf_printf (file, " */\n");

d387 2
a388 1
		 word_nr < instruction->nr_words; word_nr++)
d391 3
a393 3
		lf_printf (file,
			   "%sinstruction_word instruction_%d UNUSED = ",
			   options.module.global.prefix.l, word_nr);
d404 15
a418 11
  if (options.gen.insn_in_icache)
    {
      /* FIXME: is the instruction_word type correct? */
      print_icache_extraction (file, instruction->format_name, cache_value, "insn",	/* name */
			       "instruction_word",	/* type */
			       "instruction",	/* expression */
			       NULL,	/* origin */
			       NULL,	/* line */
			       NULL, NULL, what_to_declare, what_to_do);
    }
  lf_printf (file, "\n");
d426 3
a428 1
    for (word = instruction->words; word != NULL; word = word->next)
d444 2
a445 1
		     cache_rule != NULL; cache_rule = cache_rule->next)
d449 1
a449 2
			&& strcmp (cache_rule->name,
				   cur_field->val_string) == 0)
d463 8
a470 5
		   instruction */
		print_icache_extraction (file, instruction->format_name, value_type, cur_field->val_string,	/* name */
					 NULL,	/* type */
					 NULL,	/* expression */
					 cur_field->val_string,	/* insn field */
d474 2
a475 1
					 what_to_declare, what_to_do);
d485 2
a486 1
	 cache_rule != NULL; cache_rule = cache_rule->next)
d490 2
a491 1
	    && !filter_is_member (instruction->field_names, cache_rule->name))
d493 2
a494 4
	    char *single_field =
	      filter_next (cache_rule->original_fields, "");
	    if (filter_next (cache_rule->original_fields, single_field) !=
		NULL)
d496 9
a504 1
	    print_icache_extraction (file, instruction->format_name, cache_rule->entry_type, cache_rule->name, cache_rule->type, cache_rule->expression, single_field, cache_rule->line, NULL,	/* cur_field */
d506 2
a507 1
				     what_to_declare, what_to_do);
d518 1
a518 2
struct _form_fields
{
d529 24
a552 23
  for (insn = isa->insns; insn != NULL; insn = insn->next)
    {
      form_fields **form = &forms;
      while (1)
	{
	  if (*form == NULL)
	    {
	      /* new format name, add it */
	      form_fields *new_form = ZALLOC (form_fields);
	      new_form->name = insn->format_name;
	      filter_add (&new_form->fields, insn->field_names);
	      *form = new_form;
	      break;
	    }
	  else if (strcmp ((*form)->name, insn->format_name) == 0)
	    {
	      /* already present, add field names to the existing list */
	      filter_add (&(*form)->fields, insn->field_names);
	      break;
	    }
	  form = &(*form)->next;
	}
    }
d559 3
a561 1
print_icache_struct (lf *file, insn_table *isa, cache_entry *cache_rules)
d566 1
a566 1

d572 1
a572 1

d574 9
a582 4
  if (options.gen.icache)
    {
      lf_printf (file, "typedef struct _%sidecode_cache {\n",
		 options.module.global.prefix.l);
d584 6
a589 7
      {
	form_fields *format;
	lf_printf (file, "unsigned_word address;\n");
	lf_printf (file, "void *semantic;\n");
	lf_printf (file, "union {\n");
	lf_indent (file, +2);
	for (format = formats; format != NULL; format = format->next)
d591 50
a640 56
	    lf_printf (file, "struct {\n");
	    lf_indent (file, +2);
	    {
	      cache_entry *cache_rule;
	      char *field;
	      /* space for any instruction words */
	      if (options.gen.insn_in_icache)
		lf_printf (file, "instruction_word insn[%d];\n",
			   isa->max_nr_words);
	      /* define an entry for any applicable cache rules */
	      for (cache_rule = cache_rules;
		   cache_rule != NULL; cache_rule = cache_rule->next)
		{
		  /* nb - sort of correct - should really check against
		     individual instructions */
		  if (filter_is_subset
		      (format->fields, cache_rule->original_fields))
		    {
		      char *memb;
		      lf_printf (file, "%s %s;",
				 (cache_rule->type == NULL
				  ? "unsigned"
				  : cache_rule->type), cache_rule->name);
		      lf_printf (file, " /*");
		      for (memb =
			   filter_next (cache_rule->original_fields, "");
			   memb != NULL;
			   memb =
			   filter_next (cache_rule->original_fields, memb))
			{
			  lf_printf (file, " %s", memb);
			}
		      lf_printf (file, " */\n");
		    }
		}
	      /* define an entry for any fields not covered by a cache rule */
	      for (field = filter_next (format->fields, "");
		   field != NULL; field = filter_next (format->fields, field))
		{
		  cache_entry *cache_rule;
		  int found_rule = 0;
		  for (cache_rule = cache_rules;
		       cache_rule != NULL; cache_rule = cache_rule->next)
		    {
		      if (strcmp (cache_rule->name, field) == 0)
			{
			  found_rule = 1;
			  break;
			}
		    }
		  if (!found_rule)
		    lf_printf (file, "unsigned %s; /* default */\n", field);
		}
	    }
	    lf_indent (file, -2);
	    lf_printf (file, "} %s;\n", format->name);
d642 3
a644 3
	lf_indent (file, -2);
	lf_printf (file, "} crack;\n");
      }
d646 1
a646 2
      lf_printf (file, "} %sidecode_cache;\n",
		 options.module.global.prefix.l);
d648 3
d654 3
a656 3
         idecode_cache so that code refering to the type can still compile */
      lf_printf (file, "typedef void %sidecode_cache;\n",
		 options.module.global.prefix.l);
d665 1
a665 1
		       insn_entry * instruction,
d668 2
a669 1
		       cache_entry *cache_rules, int nr_prefetched_words)
d674 1
a674 1
  lf_printf (file, "\n");
d681 2
a682 1
				expanded_bits, function_name_prefix_icache);
d689 1
a689 1

d693 1
a693 1

d696 4
a699 3
		    instruction->format_name, expanded_bits);
  print_itrace (file, instruction, 1 /*putting-value-in-cache */ );

d701 1
a701 1

d716 3
a718 2
		      : put_values_in_icache), nr_prefetched_words);

d725 3
a727 1
		       NULL, expanded_bits, function_name_prefix_semantics);
d731 9
a739 7
  if (options.gen.semantic_icache)
    {
      lf_printf (file, "/* semantic routine */\n");
      print_semantic_body (file, instruction, expanded_bits, opcodes);
      lf_printf (file, "return nia;\n");
    }

d748 2
a749 1
			   expanded_bits, function_name_prefix_semantics);
d752 1
a752 1

d762 2
a763 1
			  : put_values_in_icache), nr_prefetched_words);
d765 1
a765 1

d775 1
a775 1
			 insn_entry * insn,
d778 2
a779 1
			 cache_entry *cache_rules, int nr_prefetched_words)
d784 3
a786 1
			 opcodes, cache_rules, nr_prefetched_words);
d793 1
a793 1
					    function_entry * function,
d804 4
a807 1
			   NULL, NULL, NULL, function_name_prefix_icache);
d817 1
a817 1
					   function_entry * function,
d828 4
a831 1
			   NULL, NULL, NULL, function_name_prefix_icache);
d842 1
a842 2
	  lf_printf (file,
		     "error (\"Internal function must longjump\\n\");\n");
d851 3
a853 1
			       NULL, NULL, function_name_prefix_semantics);
d856 1
a856 1

@


1.1
log
@Initial revision
@
text
@d135 2
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.1.18.1
log
@merge with trunk
@
text
@a134 2
    default:
      abort (); /* Bad switch.  */
@


1.1.1.1.20.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@a134 2
    default:
      abort (); /* Bad switch.  */
@


