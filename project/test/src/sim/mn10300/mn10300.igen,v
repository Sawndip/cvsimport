head	1.5;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.5
	gdb_7_6-2013-04-26-release:1.5
	gdb_7_6-branch:1.5.0.72
	gdb_7_6-2013-03-12-branchpoint:1.5
	gdb_7_5_1-2012-11-29-release:1.5
	gdb_7_5-2012-08-17-release:1.5
	gdb_7_5-branch:1.5.0.70
	gdb_7_5-2012-07-18-branchpoint:1.5
	gdb_7_4_1-2012-04-26-release:1.5
	gdb_7_4-2012-01-24-release:1.5
	gdb_7_4-branch:1.5.0.68
	gdb_7_4-2011-12-13-branchpoint:1.5
	gdb_7_3_1-2011-09-04-release:1.5
	gdb_7_3-2011-07-26-release:1.5
	gdb_7_3-branch:1.5.0.66
	gdb_7_3-2011-04-01-branchpoint:1.5
	gdb_7_2-2010-09-02-release:1.5
	gdb_7_2-branch:1.5.0.64
	gdb_7_2-2010-07-07-branchpoint:1.5
	gdb_7_1-2010-03-18-release:1.5
	gdb_7_1-branch:1.5.0.62
	gdb_7_1-2010-02-18-branchpoint:1.5
	gdb_7_0_1-2009-12-22-release:1.5
	gdb_7_0-2009-10-06-release:1.5
	gdb_7_0-branch:1.5.0.60
	gdb_7_0-2009-09-16-branchpoint:1.5
	arc-sim-20090309:1.5
	msnyder-checkpoint-072509-branch:1.5.0.58
	msnyder-checkpoint-072509-branchpoint:1.5
	arc-insight_6_8-branch:1.5.0.56
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.54
	insight_6_8-branchpoint:1.5
	reverse-20081226-branch:1.5.0.52
	reverse-20081226-branchpoint:1.5
	multiprocess-20081120-branch:1.5.0.50
	multiprocess-20081120-branchpoint:1.5
	reverse-20080930-branch:1.5.0.48
	reverse-20080930-branchpoint:1.5
	reverse-20080717-branch:1.5.0.46
	reverse-20080717-branchpoint:1.5
	msnyder-reverse-20080609-branch:1.5.0.44
	msnyder-reverse-20080609-branchpoint:1.5
	drow-reverse-20070409-branch:1.5.0.42
	drow-reverse-20070409-branchpoint:1.5
	gdb_6_8-2008-03-27-release:1.5
	gdb_6_8-branch:1.5.0.40
	gdb_6_8-2008-02-26-branchpoint:1.5
	gdb_6_7_1-2007-10-29-release:1.5
	gdb_6_7-2007-10-10-release:1.5
	gdb_6_7-branch:1.5.0.38
	gdb_6_7-2007-09-07-branchpoint:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-2006-12-18-release:1.5
	gdb_6_6-branch:1.5.0.36
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb-csl-symbian-6_4_50_20060226-12:1.5
	gdb-csl-sourcerygxx-3_4_4-25:1.5
	nickrob-async-20060828-mergepoint:1.5
	gdb-csl-symbian-6_4_50_20060226-11:1.5
	gdb-csl-sourcerygxx-4_1-17:1.5
	gdb-csl-20060226-branch-local-2:1.5
	gdb-csl-sourcerygxx-4_1-14:1.5
	gdb-csl-sourcerygxx-4_1-13:1.5
	gdb-csl-sourcerygxx-4_1-12:1.5
	gdb-csl-sourcerygxx-3_4_4-21:1.5
	gdb_6_5-20060621-release:1.5
	gdb-csl-sourcerygxx-4_1-9:1.5
	gdb-csl-sourcerygxx-4_1-8:1.5
	gdb-csl-sourcerygxx-4_1-7:1.5
	gdb-csl-arm-2006q1-6:1.5
	gdb-csl-sourcerygxx-4_1-6:1.5
	gdb-csl-symbian-6_4_50_20060226-10:1.5
	gdb-csl-symbian-6_4_50_20060226-9:1.5
	gdb-csl-symbian-6_4_50_20060226-8:1.5
	gdb-csl-coldfire-4_1-11:1.5
	gdb-csl-sourcerygxx-3_4_4-19:1.5
	gdb-csl-coldfire-4_1-10:1.5
	gdb_6_5-branch:1.5.0.34
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb-csl-sourcerygxx-4_1-5:1.5
	nickrob-async-20060513-branch:1.5.0.32
	nickrob-async-20060513-branchpoint:1.5
	gdb-csl-sourcerygxx-4_1-4:1.5
	msnyder-reverse-20060502-branch:1.5.0.30
	msnyder-reverse-20060502-branchpoint:1.5
	gdb-csl-morpho-4_1-4:1.5
	gdb-csl-sourcerygxx-3_4_4-17:1.5
	readline_5_1-import-branch:1.5.0.28
	readline_5_1-import-branchpoint:1.5
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.5
	gdb-csl-symbian-20060226-branch:1.5.0.26
	gdb-csl-symbian-20060226-branchpoint:1.5
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.5
	msnyder-reverse-20060331-branch:1.5.0.24
	msnyder-reverse-20060331-branchpoint:1.5
	gdb-csl-available-20060303-branch:1.5.0.22
	gdb-csl-available-20060303-branchpoint:1.5
	gdb-csl-20060226-branch:1.5.0.20
	gdb-csl-20060226-branchpoint:1.5
	gdb_6_4-20051202-release:1.5
	msnyder-fork-checkpoint-branch:1.5.0.18
	msnyder-fork-checkpoint-branchpoint:1.5
	gdb-csl-gxxpro-6_3-branch:1.5.0.16
	gdb-csl-gxxpro-6_3-branchpoint:1.5
	gdb_6_4-branch:1.5.0.14
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb-csl-arm-20051020-branch:1.5.0.12
	gdb-csl-arm-20051020-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.10
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb-csl-arm-20050325-2005-q1b:1.5
	gdb-csl-arm-20050325-2005-q1a:1.5
	csl-arm-20050325-branch:1.5.0.8
	csl-arm-20050325-branchpoint:1.5
	gdb_6_3-20041109-release:1.5
	gdb_6_3-branch:1.5.0.4
	gdb_6_3-20041019-branchpoint:1.5
	drow_intercu-merge-20040921:1.5
	drow_intercu-merge-20040915:1.5
	jimb-gdb_6_2-e500-branch:1.5.0.6
	jimb-gdb_6_2-e500-branchpoint:1.5
	gdb_6_2-20040730-release:1.5
	gdb_6_2-branch:1.5.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.5
	gdb_6_1_1-20040616-release:1.4
	gdb_6_1-2004-04-05-release:1.4
	drow_intercu-merge-20040402:1.4
	drow_intercu-merge-20040327:1.4
	ezannoni_pie-20040323-branch:1.4.0.76
	ezannoni_pie-20040323-branchpoint:1.4
	cagney_tramp-20040321-mergepoint:1.4
	cagney_tramp-20040309-branch:1.4.0.74
	cagney_tramp-20040309-branchpoint:1.4
	gdb_6_1-branch:1.4.0.72
	gdb_6_1-2004-03-01-gmt-branchpoint:1.4
	drow_intercu-20040221-branch:1.4.0.70
	drow_intercu-20040221-branchpoint:1.4
	cagney_bfdfile-20040213-branch:1.4.0.68
	cagney_bfdfile-20040213-branchpoint:1.4
	drow-cplus-merge-20040208:1.4
	carlton_dictionary-20040126-merge:1.4
	cagney_bigcore-20040122-branch:1.4.0.66
	cagney_bigcore-20040122-branchpoint:1.4
	drow-cplus-merge-20040113:1.4
	drow-cplus-merge-20031224:1.4
	drow-cplus-merge-20031220:1.4
	carlton_dictionary-20031215-merge:1.4
	drow-cplus-merge-20031214:1.4
	carlton-dictionary-20031111-merge:1.4
	gdb_6_0-2003-10-04-release:1.4
	kettenis_sparc-20030918-branch:1.4.0.64
	kettenis_sparc-20030918-branchpoint:1.4
	carlton_dictionary-20030917-merge:1.4
	ezannoni_pie-20030916-branchpoint:1.4
	ezannoni_pie-20030916-branch:1.4.0.62
	cagney_x86i386-20030821-branch:1.4.0.60
	cagney_x86i386-20030821-branchpoint:1.4
	carlton_dictionary-20030805-merge:1.4
	carlton_dictionary-20030627-merge:1.4
	gdb_6_0-branch:1.4.0.58
	gdb_6_0-2003-06-23-branchpoint:1.4
	jimb-ppc64-linux-20030613-branch:1.4.0.56
	jimb-ppc64-linux-20030613-branchpoint:1.4
	cagney_convert-20030606-branch:1.4.0.54
	cagney_convert-20030606-branchpoint:1.4
	cagney_writestrings-20030508-branch:1.4.0.52
	cagney_writestrings-20030508-branchpoint:1.4
	jimb-ppc64-linux-20030528-branch:1.4.0.50
	jimb-ppc64-linux-20030528-branchpoint:1.4
	carlton_dictionary-20030523-merge:1.4
	cagney_fileio-20030521-branch:1.4.0.48
	cagney_fileio-20030521-branchpoint:1.4
	kettenis_i386newframe-20030517-mergepoint:1.4
	jimb-ppc64-linux-20030509-branch:1.4.0.46
	jimb-ppc64-linux-20030509-branchpoint:1.4
	kettenis_i386newframe-20030504-mergepoint:1.4
	carlton_dictionary-20030430-merge:1.4
	kettenis_i386newframe-20030419-branch:1.4.0.44
	kettenis_i386newframe-20030419-branchpoint:1.4
	carlton_dictionary-20030416-merge:1.4
	cagney_frameaddr-20030409-mergepoint:1.4
	kettenis_i386newframe-20030406-branch:1.4.0.42
	kettenis_i386newframe-20030406-branchpoint:1.4
	cagney_frameaddr-20030403-branchpoint:1.4
	cagney_frameaddr-20030403-branch:1.4.0.40
	cagney_framebase-20030330-mergepoint:1.4
	cagney_framebase-20030326-branch:1.4.0.38
	cagney_framebase-20030326-branchpoint:1.4
	cagney_lazyid-20030317-branch:1.4.0.36
	cagney_lazyid-20030317-branchpoint:1.4
	kettenis-i386newframe-20030316-mergepoint:1.4
	offbyone-20030313-branch:1.4.0.34
	offbyone-20030313-branchpoint:1.4
	kettenis-i386newframe-20030308-branch:1.4.0.32
	kettenis-i386newframe-20030308-branchpoint:1.4
	carlton_dictionary-20030305-merge:1.4
	cagney_offbyone-20030303-branch:1.4.0.30
	cagney_offbyone-20030303-branchpoint:1.4
	carlton_dictionary-20030207-merge:1.4
	interps-20030202-branch:1.4.0.28
	interps-20030202-branchpoint:1.4
	cagney-unwind-20030108-branch:1.4.0.26
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.4
	carlton_dictionary-20021115-merge:1.4
	kseitz_interps-20021105-merge:1.4
	kseitz_interps-20021103-merge:1.4
	drow-cplus-merge-20021020:1.4
	drow-cplus-merge-20021025:1.4
	carlton_dictionary-20021025-merge:1.4
	carlton_dictionary-20021011-merge:1.4
	drow-cplus-branch:1.4.0.24
	drow-cplus-branchpoint:1.4
	kseitz_interps-20020930-merge:1.4
	carlton_dictionary-20020927-merge:1.4
	carlton_dictionary-branch:1.4.0.22
	carlton_dictionary-20020920-branchpoint:1.4
	gdb_5_3-branch:1.4.0.20
	gdb_5_3-2002-09-04-branchpoint:1.4
	kseitz_interps-20020829-merge:1.4
	cagney_sysregs-20020825-branch:1.4.0.18
	cagney_sysregs-20020825-branchpoint:1.4
	readline_4_3-import-branch:1.4.0.16
	readline_4_3-import-branchpoint:1.4
	gdb_5_2_1-2002-07-23-release:1.4
	kseitz_interps-20020528-branch:1.4.0.14
	kseitz_interps-20020528-branchpoint:1.4
	cagney_regbuf-20020515-branch:1.4.0.12
	cagney_regbuf-20020515-branchpoint:1.4
	jimb-macro-020506-branch:1.4.0.10
	jimb-macro-020506-branchpoint:1.4
	gdb_5_2-2002-04-29-release:1.4
	gdb_5_2-branch:1.4.0.8
	gdb_5_2-2002-03-03-branchpoint:1.4
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	insight-precleanup-2001-01-01:1.3
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.2
	gdb-1999-11-08:1.1.1.2
	gdb-1999-11-01:1.1.1.2
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2004.06.26.22.18.18;	author aoliva;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.07.04.52.00;	author jimb;	state Exp;
branches
	1.4.70.1;
next	1.3;

1.3
date	2000.05.29.19.05.41;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.18.22.56.28;	author aoliva;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.07;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.4.70.1
date	2004.09.16.17.02.12;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.35.07;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.33.18;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.12.07.03.56.43;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.5
log
@2000-08-07  Graham Stott  <grahams@@cygnus.co.uk>
* am33-2.igen (fmadd, fmsub, fmnadd, fmnsub): Correct typo.
2000-05-29  Alexandre Oliva  <aoliva@@cygnus.com>
* interp.c (fpu_disabled_exception, fpu_unimp_exception,
fpu_check_signal_exception): Take additional state arguments.
Print exception type and call program_interrupt.  Adjust callers.
(fpu_rsqrt, fpu_cmp, fpu_add, fpu_sub, fpu_mul, fpu_div,
fpu_fmadd, fpu_fmsub, fpu_fnmadd, fpu_fnmsub): Take additional
arguments.
* mn10300_sim.h (fpu_disabled_exception, fpu_unimp_exception,
fpu_check_signal_exception): Adjust prototypes.
(fpu_rsqrt, fpu_cmp, fpu_add, fpu_sub, fpu_mul, fpu_div,
fpu_fmadd, fpu_fmsub, fpu_fnmadd, fpu_fnmsub): Likewise.
* am33-2.igen: Adjust calls.
2000-05-19  Alexandre Oliva  <aoliva@@cygnus.com>
* op_utils.c (cmp2fcc): Moved...
* interp.c: ... here.
2000-05-18  Alexandre Oliva  <aoliva@@cygnus.com>
* am33-2.igen: Use `unsigned32', `signed32', `unsigned64' or
`signed64' where type width is relevant.
2000-05-15  Alexandre Oliva  <aoliva@@cygnus.com>
* mn10300_sim.h: Include sim-fpu.h.
(FD2FPU, FPU2FD): Enclose the FD argument in parentheses.
(fpu_check_signal_exception): Declare.
(struct fp_prec_t, fp_single_prec, fp_double_prec): Likewise.
(FP_SINGLE, FP_DOUBLE): Shorthands for fp_*_prec.
(fpu_rsqrt, fpu_cmp, fpu_add, fpu_sub, fpu_mul, fpu_div,
fpu_fmadd, fpu_fmsub, fpu_fnmadd, fpu_fnmsub): Declare.
* interp.c (fpu_disabled_exception): Document.
(fpu_unimp_exception): Likewise.
(fpu_check_signal_exception): Define.
(reg2val_32, round_32, val2reg_32, fp_single_prec): Likewise.
(reg2val_64, round_64, val2reg_64, fp_double_prec): Likewise.
(REG2VAL, ROUND, VAL2REG): Define shorthands.
(fpu_status_ok): Define.
(fpu_rsqrt, fpu_cmp, fpu_add, fpu_sub, fpu_mul, fpu_div,
fpu_fmadd, fpu_fmsub, fpu_fnmadd, fpu_fnmsub): Define.
* am33-2.igen (frsqrt, fcmp, fadd, fsub, fmul, fdiv,
fmadd, fmsub, fnmadd, fnmsub): Use new functions.
2000-04-27  Alexandre Oliva  <aoliva@@cygnus.com>
* interp.c (sim_create_inferior): Set PSW bit to enable FP insns
if architecture is AM33/2.0.
* am33.igen: Include am33-2.igen.
2000-04-23  Alexandre Oliva  <aoliva@@cygnus.com>
* mn10300.igen (movm, call, ret, retf): Check for am33_2 too.
* am33.igen (movm): Likewise.
2000-04-19  Alexandre Oliva  <aoliva@@cygnus.com>
* am33.igen: Added `*am33_2' to some instructions that were
missing it.
2000-04-07  Alexandre Oliva  <aoliva@@cygnus.com>
* am33-2.igen: New file.  All insns implemented, but FP flags are
only set for fcmp, exceptional conditions are not handled yet.
* Makefile.in (IGEN_INSN): Added am33-2.igen.
(tmp-igen): Added -M am33_2.
* mn10300.igen, am33.igen: Added `*am33_2' to all insns.
* gencode.c: Support FMT_D3.
* mn10300_sim.h (dword): New type.
(struct _state): Added fpregs.
(REG_FPCR, FPCR): New define.  All assorted bitmaps.
(XS2FS, AS2FS, Xf2FD): New macros.
(FS2FPU, FD2FPU, FPU2FS, FPU2FD): Likewise.
(load_dword, store_dword): New functions or macros.
(u642dw, dw2u64): New functions.
(fpu_disabled_exception, fpu_unimp_exception): Declared.
* interp.c (fpu_disabled_exception): Defined; no actual
implementation.
(fpu_unimp_exception): Likewise.
* op_utils.c (cmp2fcc): New function.
@
text
@// -*- C -*-
:option:::insn-bit-size:8
:option:::insn-specifying-widths:true
:option:::hi-bit-nr:7
:model:::mn10300:mn10300:
:model:::am33:am33:
:model:::am33_2:am33_2:

// What do we do with an illegal instruction?
:internal::::illegal:
{
  PC = cia;
  program_interrupt(SD, CPU, cia, SIM_SIGILL);
}

// 1000 DnDn imm8....; mov imm8,Dn (imm8 is sign extended)
4.0x8,2.DM1,2.DN0=DM1+8.IMM8:S0i:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /*  OP_8000 (); */
  signed32 immed = EXTEND8 (IMM8);
  State.regs[REG_D0+DN0] = immed;
  PC = cia;
}

// 1000 DmDn; mov Dm,Dn (Dm != Dn, see above when Dm == Dn)
4.0x8,2.DM1,2.DN0!DM1:S0:::mov
"mov"
*mn10300
*am33
*am33_2
{
  PC = cia;
  /* OP_80 (); */
  State.regs[REG_D0+DN0] = State.regs[REG_D0+DM1];
}


// 1111 0001 1110 DmAn; mov Dm,An
8.0xf1+1110,2.DM1,2.AN0:D0:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F1E0 (); */
  PC = cia;
  State.regs[REG_A0 + AN0] = State.regs[REG_D0 + DM1];
}


// 1111 0001 1101 AmDn; mov Am,Dn
8.0xf1+1101,2.AM1,2.DN0:D0a:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F1D0 (); */
  PC = cia;
  State.regs[REG_D0 + DN0] = State.regs[REG_A0 + AM1];
}


// 1001 AnAn imm8....; mov imm8,An (imm8 is zero-extended)
4.0x9,2.AM1,2.AN0=AM1+8.IMM8:S0ai:::mov
"mov"
*mn10300
*am33
*am33_2
{
   PC = cia;
   /* OP_9000 (); */
   State.regs[REG_A0+AN0] = IMM8;
}


// 1001 AmAn; mov Am,An (Am != An, save above when Am == An)
4.0x9,2.AM1,2.AN0!AM1:S0a:::mov
"mov"
*mn10300
*am33
*am33_2
{
   PC = cia;
   /* OP_90 (); */
   State.regs[REG_A0+AN0] = State.regs[REG_A0+AM1];
}


// 0011 11An; mov SP,An
4.0x3,11,2.AN0:S0b:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_3C (); */
  PC = cia;
  State.regs[REG_A0 + AN0] = State.regs[REG_SP];
}


// 1111 0010 1111 Am00; mov Am,SP
8.0xf2+4.0xf,2.AM1,00:D0b:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F2F0 (); */
  PC = cia;
  State.regs[REG_SP] = State.regs[REG_A0 + AM1];
}


// 1111 0010 1110 01Dn; mov PSW,Dn
8.0xf2+4.0xe,01,2.DN0:D0c:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F2E4 (); */
  PC = cia;
  State.regs[REG_D0 + DN0] = PSW;
}


// 1111 0010 1111 Dm11; mov Dm,PSW
8.0xf2+4.0xf,2.DM1,11:D0d:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F2F3 (); */
  PC = cia;
  PSW = State.regs[REG_D0 + DM1];
}


// 1111 0010 1110 00Dn; mov MDR,Dn
8.0xf2+4.0xe,00,2.DN0:D0e:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F2E0 (); */
  PC = cia;
  State.regs[REG_D0 + DN0] = State.regs[REG_MDR];
}


// 1111 0010 1111 Dm10; mov Dm,MDR
8.0xf2+4.0xf,2.DM1,10:D0f:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F2F2 (); */
  PC = cia;
  State.regs[REG_MDR] = State.regs[REG_D0 + DM1];
}


// 0111 DnAm; mov (Am),Dn
4.0x7,2.DN1,2.AM0:S0c:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_70 (); */
  PC = cia;
  State.regs[REG_D0 + DN1] = load_word (State.regs[REG_A0 + AM0]);
}


// 1111 1000 0000 DnAm d8......; mov (d8,Am),Dn (d8 is sign-extended)
8.0xf8+4.0x0,2.DN1,2.AM0+8.D8:D1:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F80000 (); */
  PC = cia;
  State.regs[REG_D0 + DN1]
    = load_word ((State.regs[REG_A0 + AM0] + EXTEND8 (D8)));
}


// 1111 1010 0000 DnAm d16.....; mov (d16,Am),Dn (d16 is sign-extended.)
8.0xfa+4.0x0,2.DN1,2.AM0+8.D16A+8.D16B:D2:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FA000000 (); */
  PC = cia;
  State.regs[REG_D0 + DN1]
    = load_word ((State.regs[REG_A0 + AM0] + EXTEND16 (FETCH16(D16A, D16B))));
}


// 1111 1100 0000 DnAm d32.....; mov (d32,Am),Dn
8.0xfc+4.0x0,2.DN1,2.AM0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FC000000 (); */
  PC = cia;
  State.regs[REG_D0 + DN1]
    = load_word ((State.regs[REG_A0 + AM0]
		  + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)));
}


// 0101 10Dn d8......; mov (d8,SP),Dn (d8 is zero-extended)
4.0x5,10,2.DN0+8.D8:S1:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_5800 (); */
  PC = cia;
  State.regs[REG_D0 + DN0] = load_word (State.regs[REG_SP] + D8);
}


// 1111 1010 1011 01Dn d16.....; mov (d16,SP),Dn (d16 is zero-extended.)
8.0xfa+4.0xb,01,2.DN0+8.IMM16A+8.IMM16B:D2a:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FAB40000 (); */
  PC = cia;
  State.regs[REG_D0 + DN0]
    = load_word (State.regs[REG_SP] + FETCH16(IMM16A, IMM16B));
}


// 1111 1010 1011 01Dn d32.....; mov (d32,SP),Dn
8.0xfc+4.0xb,01,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4a:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FCB40000 (); */
  PC = cia;
  State.regs[REG_D0 + DN0]
     = load_word (State.regs[REG_SP] + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D));
}


// 1111 0011 00Dn DiAm; mov (Di,Am),Dn
8.0xf3+00,2.DN2,2.DI,2.AM0:D0g:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F300 (); */
  PC = cia;
  State.regs[REG_D0 + DN2]
    = load_word ((State.regs[REG_A0 + AM0] + State.regs[REG_D0 + DI]));
}


// 0011 00Dn abs16...; mov (abs16),Dn (abs16 is zero-extended)
4.0x3,00,2.DN0+8.IMM16A+8.IMM16B:S2:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_300000 (); */
  PC = cia;
  State.regs[REG_D0 + DN0] = load_word (FETCH16(IMM16A, IMM16B));
}

// 1111 1100 1010 01Dn abs32...; mov (abs32),Dn
8.0xfc+4.0xa,01,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4b:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FCA40000 (); */
  PC = cia;
  State.regs[REG_D0 + DN0] = load_word (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D));
}


// 1111 0000 0000 AnAm; mov (Am),An
8.0xf0+4.0x0,2.AN1,2.AM0:D0h:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F000 (); */
  PC = cia;
  State.regs[REG_A0 + AN1] = load_word (State.regs[REG_A0 + AM0]);
}


// 1111 1000 0010 AnAm d8......; mov (d8,Am),An (d8 is sign-extended)
8.0xf8+4.0x2,2.AN1,2.AM0+8.D8:D1a:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F82000 (); */
  PC = cia;
  State.regs[REG_A0 + AN1]
    = load_word ((State.regs[REG_A0 + AM0] + EXTEND8 (D8)));
}


// 1111 1010 0010 AnAm d16.....; mov (d16,Am),An (d16 is sign-extended.)
8.0xfa+4.0x2,2.AN1,2.AM0+8.D16A+8.D16B:D2b:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FA200000 (); */
  PC = cia;
  State.regs[REG_A0 + AN1]
    = load_word ((State.regs[REG_A0 + AM0]
		  + EXTEND16 (FETCH16(D16A, D16B))));
}


// 1111 1100 0010 AnAm d32.....; mov (d32,Am),An
8.0xfc+4.0x2,2.AN1,2.AM0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4c:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FC200000 (); */
  PC = cia;
  State.regs[REG_A0 + AN1]
    = load_word ((State.regs[REG_A0 + AM0]
		  + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)));
}


// 0101 11An d8......; mov (d8,SP),An (d8 is zero-extended)
4.0x5,11,2.AN0+8.D8:S1a:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_5C00 (); */
  PC = cia;
  State.regs[REG_A0 + AN0]
    = load_word (State.regs[REG_SP] + D8);
}


// 1111 1010 1011 00An d16.....; mov (d16,SP),An (d16 is zero-extended.)
8.0xfa+4.0xb,00,2.AN0+8.IMM16A+8.IMM16B:D2c:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FAB00000 (); */
  PC = cia;
  State.regs[REG_A0 + AN0]
    = load_word (State.regs[REG_SP] + FETCH16(IMM16A, IMM16B));
}


// 1111 1100 1011 00An d32.....; mov (d32,SP),An
8.0xfc+4.0xb,00,2.AN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4d:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FCB00000 (); */
  PC = cia;
  State.regs[REG_A0 + AN0]
    = load_word (State.regs[REG_SP]
		 + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D));
}


// 1111 0011 10An DiAm; mov (Di,Am),An
8.0xf3+10,2.AN2,2.DI,2.AM0:D0i:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F380 (); */
  PC = cia;
  State.regs[REG_A0 + AN2]
    = load_word ((State.regs[REG_A0 + AM0]
		 + State.regs[REG_D0 + DI]));
}


// 1111 1010 1010 00An abs16...; mov (abs16),An (abs16 is zero-extended)
8.0xfa+4.0xa,00,2.AN0+8.IMM16A+8.IMM16B:D2d:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FAA00000 (); */
  PC = cia;
  State.regs[REG_A0 + AN0] = load_word (FETCH16(IMM16A, IMM16B));
}


// 1111 1100 1010 00An abs32...; mov (abs32),An
8.0xfc+4.0xa,00,2.AN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4e:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FCA00000 (); */
  PC = cia;
  State.regs[REG_A0 + AN0]
    = load_word (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D));
}


// 1111 1000 1111 00Am d8......; mov (d8,Am),SP (d8 is sign-extended)
8.0xf8+4.0xf,00,2.AM0+8.D8:D1b:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F8F000 (); */
  PC = cia;
  State.regs[REG_SP]
    = load_word ((State.regs[REG_A0 + AM0] + EXTEND8 (D8)));
}


// 0110 DmAn; mov Dm,(An)
4.0x6,2.DM1,2.AN0:S0d:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_60 (); */
  PC = cia;
  store_word (State.regs[REG_A0 + AN0], State.regs[REG_D0 + DM1]);
}


// 1111 1000 0001 DmAn d8......; mov Dm,(d8,An) (d8 is sign-extended)
8.0xf8+4.0x1,2.DM1,2.AN0+8.D8:D1c:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F81000 (); */
  PC = cia;
  store_word ((State.regs[REG_A0 + AN0] + EXTEND8 (D8)),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1010 0001 DmAn d16.....; mov Dm,(d16,An) (d16 is sign-extended.)
8.0xfa+4.0x1,2.DM1,2.AN0+8.D16A+8.D16B:D2e:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FA100000 (); */
  PC = cia;
  store_word ((State.regs[REG_A0 + AN0] + EXTEND16 (FETCH16(D16A, D16B))),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1100 0001 DmAn d32.....; mov Dm,(d32,An)
8.0xfc+4.0x1,2.DM1,2.AN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4f:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FC100000 (); */
  PC = cia;
  store_word ((State.regs[REG_A0 + AN0]
	       + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)),
	      State.regs[REG_D0 + DM1]);
}


// 0100 Dm10 d8......; mov Dm,(d8,SP) (d8 is zero-extended)
4.0x4,2.DM1,10+8.D8:S1b:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_4200 (); */
  PC = cia;
  store_word (State.regs[REG_SP] + D8, State.regs[REG_D0 + DM1]);
}


// 1111 1010 1001 Dm01 d16.....; mov Dm,(d16,SP) (d16 is zero-extended.)
8.0xfa+4.0x9,2.DM1,01+8.IMM16A+8.IMM16B:D2f:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FA910000 (); */
  PC = cia;
  store_word (State.regs[REG_SP] + FETCH16(IMM16A, IMM16B),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1100 1001 Dm01 d32.....; mov Dm,(d32,SP)
8.0xfc+4.0x9,2.DM1,01+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4g:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FC910000 (); */
  PC = cia;
  store_word (State.regs[REG_SP] + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D),
	      State.regs[REG_D0 + DM1]);
}


// 1111 0011 01Dm DiAn; mov Dm,(Di,An)
8.0xf3+01,2.DM2,2.DI,2.AN0:D0j:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F340 (); */
  PC = cia;
  store_word ((State.regs[REG_A0 + AN0] + State.regs[REG_D0 + DI]),
	      State.regs[REG_D0 + DM2]);
}


// 0000 Dm01 abs16..., mov Dm,(abs16) (abs16 is zero-extended).
4.0x0,2.DM1,01+8.IMM16A+8.IMM16B:S2a:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_10000 (); */
  PC = cia;
  store_word (FETCH16(IMM16A, IMM16B), State.regs[REG_D0 + DM1]);
}


// 1111 1100 1000 Dm01 abs32...; mov Dm,(abs32)
8.0xfc+4.0x8,2.DM1,01+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4h:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FC810000 (); */
  PC = cia;
  store_word (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D),
	      State.regs[REG_D0 + DM1]);
}


// 1111 0000 0001 AmAn; mov Am,(An)
8.0xf0+4.0x1,2.AM1,2.AN0:D0k:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F010 (); */
  PC = cia;
  store_word (State.regs[REG_A0 + AN0], State.regs[REG_A0 + AM1]);
}


// 1111 1000 0011 AmAn d8......; mov Am,(d8,An) (d8 is sign-extended)
8.0xf8+4.0x3,2.AM1,2.AN0+8.D8:D1d:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_F83000 (); */
  PC = cia;
  store_word ((State.regs[REG_A0 + AN0] + EXTEND8 (D8)),
	      State.regs[REG_A0 + AM1]);
}


// 1111 1010 0011 AmAn d16.....; mov Am,(d16,An) (d16 is sign-extended.)
8.0xfa+4.0x3,2.AM1,2.AN0+8.D16A+8.D16B:D2g:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FA300000 (); */
  PC = cia;
  store_word ((State.regs[REG_A0 + AN0] + EXTEND16 (FETCH16(D16A, D16B))),
	      State.regs[REG_A0 + AM1]);
}


// 1111 1100 0011 AmAn d32.....; mov Am,(d32,An)
8.0xfc+4.0x3,2.AM1,2.AN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4i:::mov
"mov"
*mn10300
*am33
*am33_2
{
  /* OP_FC300000 (); */
  PC = cia;
  store_word ((State.regs[REG_A0 + AN0]
	       + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)),
	      State.regs[REG_A0 + AM1]);
}


// 0100 Am11 d8......; mov Am,(d8,SP) (d8 is zero-extended)
4.0x4,2.AM1,11+8.D8:S1c:::mov
"mov"
*mn10300

*am33
*am33_2

{
  /* OP_4300 (); */
  PC = cia;
  store_word (State.regs[REG_SP] + (D8), State.regs[REG_A0 + (AM1)]);
}


// 1111 1010 1001 Am00 d16.....; mov Am,(d16,SP) (d16 is zero-extended.)
8.0xfa+4.0x9,2.AM1,00+8.IMM16A+8.IMM16B:D2h:::mov
"mov"
*mn10300

*am33
*am33_2

{
  /* OP_FA900000 (); */
  PC = cia;
  store_word (State.regs[REG_SP] + FETCH16(IMM16A, IMM16B),
	      State.regs[REG_A0 + AM1]);
}


// 1111 1100 1001 Am00 d32.....; mov Am,(d32,SP)
8.0xfc+4.0x9,2.AM1,00+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4j:::mov
"mov"
*mn10300

*am33
*am33_2

{
  /* OP_FC900000 (); */
  PC = cia;
  store_word (State.regs[REG_SP] + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D),
	      State.regs[REG_A0 + AM1]);
}


// 1111 0011 11Am DiAn; mov Am,(Di,An)
8.0xf3+11,2.AM2,2.DI,2.AN0:D0l:::mov
"mov"
*mn10300

*am33
*am33_2

{
  /* OP_F3C0 (); */
  PC = cia;
  store_word ((State.regs[REG_A0 + AN0] + State.regs[REG_D0 + DI]),
	      State.regs[REG_A0 + AM2]);
}


// 1111 1010 1000 Am00 abs16...; mov Am,(abs16) (abs16 is zero-extended)
8.0xfa+4.0x8,2.AM1,00+8.IMM16A+8.IMM16B:D2i:::mov
"mov"
*mn10300

*am33
*am33_2

{
  /* OP_FA800000 (); */
  PC = cia;
  store_word (FETCH16(IMM16A, IMM16B),
	      State.regs[REG_A0 + AM1]);
}


// 1111 1100 1000 Am00 abs32...; mov Am,(abs32)
8.0xfc+4.0x8,2.AM1,00+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4k:::mov
"mov"
*mn10300

*am33
*am33_2

{
  /* OP_FC800000 (); */
  PC = cia;
  store_word (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D),
	      State.regs[REG_A0 + AM1]);
}


// 1111 1000 1111 01An d8......; mov SP,(d8,An) (d8 is sign-extended)
8.0xf8+4.0xf,01,2.AN0+8.D8:D1e:::mov
"mov"
*mn10300

*am33
*am33_2

{
  /* OP_F8F400 (); */
  PC = cia;
  store_word (State.regs[REG_A0 + AN0] + EXTEND8 (D8),
	      State.regs[REG_SP]);
}


// 0010 11Dn imm16...; mov imm16,Dn (imm16 is sign-extended)
4.0x2,11,2.DN0+8.IMM16A+8.IMM16B:S2b:::mov
"mov"
*mn10300

*am33
*am33_2

{
  /* OP_2C0000 (); */
  unsigned32 value;

  PC = cia;
  value = EXTEND16 (FETCH16(IMM16A, IMM16B));
  State.regs[REG_D0 + DN0] = value;
}


// 1111 1100 1100 11Dn imm32...; mov imm32,Dn
8.0xfc+4.0xc,11,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4l:::mov
"mov"
*mn10300

*am33
*am33_2

{
  /* OP_FCCC0000 (); */
  unsigned32 value;

  PC = cia;
  value = FETCH32(IMM32A, IMM32B, IMM32C, IMM32D);
  State.regs[REG_D0 + DN0] = value;
}


// 0010 01An imm16...; mov imm16,An (imm16 is zero-extended)
4.0x2,01,2.AN0+8.IMM16A+8.IMM16B:S2c:::mov
"mov"
*mn10300

*am33
*am33_2

{
  /* OP_240000 (); */
  unsigned32 value;

  PC = cia;
  value = FETCH16(IMM16A, IMM16B);
  State.regs[REG_A0 + AN0] = value;
}


// 1111 1100 1101 11An imm32...; mov imm32,An
8.0xfc+4.0xd,11,2.AN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4m:::mov
"mov"
*mn10300

*am33
*am33_2

{
    /* OP_FCDC0000 (); */
    PC = cia;
    State.regs[REG_A0 + AN0] = FETCH32(IMM32A, IMM32B, IMM32C, IMM32D);
}


// 1111 0000 0100 DnAm; movbu (Am),Dn
8.0xf0+4.0x4,2.DN1,2.AM0:D0:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_F040 (); */
  PC = cia;
  State.regs[REG_D0 + DN1]
    = load_byte (State.regs[REG_A0 + AM0]);
}


// 1111 1000 0100 DnAm d8......; movbu (d8,Am),Dn (d8 is sign-extended)
8.0xf8+4.0x4,2.DN1,2.AM0+8.D8:D1f:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_F84000 (); */
  PC = cia;
  State.regs[REG_D0 + DN1]
    = load_byte ((State.regs[REG_A0 + AM0] + EXTEND8 (D8)));
}


// 1111 1010 0100 DnAm d16.....; movbu (d16,Am),Dn (d16 is sign-extended.)
8.0xfa+4.0x4,2.DN1,2.AM0+8.D16A+8.D16B:D2:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_FA400000 (); */
  PC = cia;
  State.regs[REG_D0 + DN1]
    = load_byte ((State.regs[REG_A0 + AM0]
		  + EXTEND16 (FETCH16(D16A, D16B))));
}


// 1111 1100 0100 DnAm d32.....; movbu (d32,Am),Dn
8.0xfc+4.0x4,2.DN1,2.AM0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_FC400000 (); */
  PC = cia;
  State.regs[REG_D0 + DN1]
    = load_byte ((State.regs[REG_A0 + AM0]
		  + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)));
}


// 1111 1000 1011 10Dn d8......; movbu (d8,SP),Dn (d8 is zero-extended)
8.0xf8+4.0xb,10,2.DN0+8.D8:D1a:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_F8B800 (); */
  PC = cia;
  State.regs[REG_D0 + DN0]
    = load_byte ((State.regs[REG_SP] + (D8)));
}


// 1111 1010 1011 10Dn d16.....; movbu (d16,SP),Dn (d16 is zero-extended.)
8.0xfa+4.0xb,10,2.DN0+8.IMM16A+8.IMM16B:D2a:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_FAB80000 (); */
  PC = cia;
  State.regs[REG_D0 + DN0]
    = load_byte ((State.regs[REG_SP]
		  + FETCH16(IMM16A, IMM16B)));
}


// 1111 1100 1011 10Dn d32.....; movbu (d32,SP),Dn
8.0xfc+4.0xb,10,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4a:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_FCB80000 (); */
  PC = cia;
  State.regs[REG_D0 + DN0]
    = load_byte (State.regs[REG_SP]
		 + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D));
}


// 1111 0100 00Dn DiAm; movbu (Di,Am),Dn
8.0xf4+00,2.DN2,2.DI,2.AM0:D0a:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_F400 (); */
  PC = cia;
  State.regs[REG_D0 + DN2]
    = load_byte ((State.regs[REG_A0 + AM0]
		  + State.regs[REG_D0 + DI]));
}


// 0011 01Dn abs16...; movbu (abs16),Dn (abs16 is zero-extended)
4.0x3,01,2.DN0+8.IMM16A+8.IMM16B:S2:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_340000 (); */
  PC = cia;
  State.regs[REG_D0 + DN0] = load_byte (FETCH16(IMM16A, IMM16B));
}


// 1111 1100 1010 10Dn abs32...; movbu (abs32),Dn
8.0xfc+4.0xa,10,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4b:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_FCA80000 (); */
  PC = cia;
  State.regs[REG_D0 + DN0]
    = load_byte (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D));
}


// 1111 0000 0101 DmAn; movbu Dm,(An)
8.0xf0+4.0x5,2.DM1,2.AN0:D0b:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_F050 (); */
  PC = cia;
  store_byte (State.regs[REG_A0 + AN0], State.regs[REG_D0 + DM1]);
}


// 1111 1000 0101 DmAn d8......; movbu Dm,(d8,An) (d8 is sign-extended)
8.0xf8+4.0x5,2.DM1,2.AN0+8.D8:D1b:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_F85000 (); */
  PC = cia;
  store_byte ((State.regs[REG_A0 + AN0] + EXTEND8 (D8)),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1010 0101 DmAn d16.....; movbu Dm,(d16,An) (d16 is sign-extended.)
8.0xfa+4.0x5,2.DM1,2.AN0+8.D16A+8.D16B:D2b:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_FA500000 (); */
  PC = cia;
  store_byte ((State.regs[REG_A0 + AN0] + EXTEND16 (FETCH16(D16A, D16B))),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1100 0101 DmAn d32.....; movbu Dm,(d32,An)
8.0xfc+4.0x5,2.DM1,2.AN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4c:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_FC500000 (); */
  PC = cia;
  store_byte ((State.regs[REG_A0 + AN0]
	       + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1000 1001 Dm10 d8......; movbu Dm,(d8,SP) (d8 is zero-extended)
8.0xf8+4.0x9,2.DM1,10+8.D8:D1c:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_F89200 (); */
  PC = cia;
  store_byte (State.regs[REG_SP] + (D8), State.regs[REG_D0 + DM1]);
}


// 1111 1010 1001 Dm10 d16.....; movbu Dm,(d16,SP) (d16 is zero-extended.)
8.0xfa+4.0x9,2.DM1,10+8.IMM16A+8.IMM16B:D2c:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_FA920000 (); */
  PC = cia;
  store_byte (State.regs[REG_SP] + FETCH16(IMM16A, IMM16B),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1100 1001 Dm10 d32.....; movbu Dm,(d32,SP)
8.0xfc+4.0x9,2.DM1,10+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4d:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_FC920000 (); */
  PC = cia;
  store_byte (State.regs[REG_SP] + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D),
	      State.regs[REG_D0 + DM1]);
}


// 1111 0100 01Dm DiAn; movbu Dm,(Di,An)
8.0xf4+01,2.DM2,2.DI,2.AN0:D0c:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_F440 (); */
  PC = cia;
  store_byte ((State.regs[REG_A0 + AN0] + State.regs[REG_D0 + DI]),
	      State.regs[REG_D0 + DM2]);
}


// 0000 Dm10 abs16...; movbu Dm,(abs16) (abs16 is zero-extended)
4.0x0,2.DM1,10+8.IMM16A+8.IMM16B:S2a:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_20000 (); */
  PC = cia;
  store_byte (FETCH16(IMM16A, IMM16B),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1100 1000 Dm10 abs32...; movbu Dm,(abs32)
8.0xfc+4.0x8,2.DM1,10+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4e:::movbu
"movbu"
*mn10300

*am33
*am33_2

{
  /* OP_FC820000 (); */
  PC = cia;
  store_byte (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D),
	      State.regs[REG_D0 + DM1]);
}


// 1111 0000 0110 DnAm; movhu (Am),Dn
8.0xf0+4.0x6,2.DN1,2.AM0:D0:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_F060 (); */
  PC = cia;
  State.regs[REG_D0 + DN1]
    = load_half (State.regs[REG_A0 + AM0]);
}


// 1111 1000 0110 DnAm d8......; movhu (d8,Am),Dn (d8 is sign-extended)
8.0xf8+4.0x6,2.DN1,2.AM0+8.D8:D1d:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_F86000 (); */
  PC = cia;
  State.regs[REG_D0 + DN1]
    = load_half ((State.regs[REG_A0 + AM0] + EXTEND8 (D8)));
}


// 1111 1010 0110 DnAm d16.....; movhu (d16,Am),Dn (d16 is sign-extended.)
8.0xfa+4.0x6,2.DN1,2.AM0+8.D16A+8.D16B:D2:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_FA600000 (); */
  PC = cia;
  State.regs[REG_D0 + DN1]
    = load_half ((State.regs[REG_A0 + AM0]
		  + EXTEND16 (FETCH16(D16A, D16B))));
}


// 1111 1100 0110 DnAm d32.....; movhu (d32,Am),Dn
8.0xfc+4.0x6,2.DN1,2.AM0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_FC600000 (); */
  PC = cia;
  State.regs[REG_D0 + DN1]
    = load_half ((State.regs[REG_A0 + AM0]
		  + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)));
}


// 1111 1000 1011 11Dn d8.....; movhu (d8,SP),Dn (d8 is zero-extended)
8.0xf8+4.0xb,11,2.DN0+8.D8:D1a:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_F8BC00 (); */
  PC = cia;
  State.regs[REG_D0 + DN0]
    = load_half ((State.regs[REG_SP] + (D8)));
}


// 1111 1010 1011 11Dn d16.....; movhu (d16,SP),Dn (d16 is zero-extended.)
8.0xfa+4.0xb,11,2.DN0+8.IMM16A+8.IMM16B:D2a:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_FABC0000 (); */
  PC = cia;
  State.regs[REG_D0 + DN0]
    = load_half ((State.regs[REG_SP] + FETCH16(IMM16A, IMM16B)));
}


// 1111 1100 1011 11Dn d32.....; movhu (d32,SP),Dn
8.0xfc+4.0xb,11,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4a:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_FCBC0000 (); */
  PC = cia;
  State.regs[REG_D0 + DN0]
    = load_half (State.regs[REG_SP] + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D));
}


// 1111 0100 10Dn DiAm; movhu (Di,Am),Dn
8.0xf4+10,2.DN2,2.DI,2.AM0:D0a:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_F480 (); */
  PC = cia;
  State.regs[REG_D0 + DN2]
    = load_half ((State.regs[REG_A0 + AM0] + State.regs[REG_D0 + DI]));
}


// 0011 10Dn abs16...; movhu (abs16),Dn (abs16 is zero-extended)
4.0x3,10,2.DN0+8.IMM16A+8.IMM16B:S2:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_380000 (); */
  PC = cia;
  State.regs[REG_D0 + DN0] = load_half (FETCH16(IMM16A, IMM16B));
}


// 1111 1100 1010 11Dn abs32...; movhu (abs32),Dn
8.0xfc+4.0xa,11,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4b:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_FCAC0000 (); */
  PC = cia;
  State.regs[REG_D0 + DN0]
    = load_half (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D));
}


// 1111 0000 0111 DmAn; movhu Dm,(An)
8.0xf0+4.0x7,2.DM1,2.AN0:D0b:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_F070 (); */
  PC = cia;
  store_half (State.regs[REG_A0 + AN0],
	      State.regs[REG_D0 + DM1]);
}


// 1111 1000 0111 DmAn d8......; movhu Dm,(d8,An) (d8 is sign-extended)
8.0xf8+4.0x7,2.DM1,2.AN0+8.D8:D1b:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_F87000 (); */
  PC = cia;
  store_half ((State.regs[REG_A0 + AN0] + EXTEND8 (D8)),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1010 0111 DnAm d16.....; movhu Dm,(d16,An) (d16 is sign-extended.)
8.0xfa+4.0x7,2.DM1,2.AN0+8.D16A+8.D16B:D2b:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_FA700000 (); */
  PC = cia;
  store_half ((State.regs[REG_A0 + AN0] + EXTEND16 (FETCH16(D16A, D16B))),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1100 0111 DmAn d32.....; movhu Dm,(d32,An)
8.0xfc+4.0x7,2.DM1,2.AN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4c:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_FC700000 (); */
  PC = cia;
  store_half ((State.regs[REG_A0 + AN0]
	       + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1000 1001 Dm11 d8....; movhu Dm,(d8,SP) (d8 is zero-extended)
8.0xf8+4.0x9,2.DM1,11+8.D8:D1c:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_F89300 (); */
  PC = cia;
  store_half (State.regs[REG_SP] + (D8),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1010 1001 Dm11 d16.....; movhu Dm,(d16,SP) (d16 is zero-extended.)
8.0xfa+4.0x9,2.DM1,11+8.IMM16A+8.IMM16B:D2c:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_FA930000 (); */
  PC = cia;
  store_half (State.regs[REG_SP] + FETCH16(IMM16A, IMM16B),
	      State.regs[REG_D0 + DM1]);
}


// 1111 1100 1001 Dm11 d32.....; movhu Dm,(d32,SP)
8.0xfc+4.0x9,2.DM1,11+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4d:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_FC930000 (); */
  PC = cia;
  store_half (State.regs[REG_SP] + FETCH32(IMM32A, IMM32B, IMM32C, IMM32D),
	      State.regs[REG_D0 + DM1]);
}


// 1111 0100 11Dm DiAn; movhu Dm,(Di,An)
8.0xf4+11,2.DM2,2.DI,2.AN0:D0c:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_F4C0 (); */
  PC = cia;
  store_half ((State.regs[REG_A0 + AN0] + State.regs[REG_D0 + DI]),
	      State.regs[REG_D0 + DM2]);
}


// 0000 Dm11 abs16...; movhu Dm,(abs16) (abs16 is zero-extended)
4.0x0,2.DM1,11+8.IMM16A+8.IMM16B:S2a:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_30000 (); */
  PC = cia;
  store_half (FETCH16(IMM16A, IMM16B), State.regs[REG_D0 + DM1]);
}


// 1111 1100 1000 Dm11 abs32...; movhu Dm,(abs32)
8.0xfc+4.0x8,2.DM1,11+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4e:::movhu
"movhu"
*mn10300

*am33
*am33_2

{
  /* OP_FC830000 (); */
  PC = cia;
  store_half (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D),
	      State.regs[REG_D0 + DM1]);
}


// 1111 0010 1101 00Dn; ext Dn
8.0xf2+4.0xd,00,2.DN0:D0:::ext
"ext"
*mn10300

*am33
*am33_2

{
  /* OP_F2D0 (); */
  PC = cia;
  if (State.regs[REG_D0 + DN0] & 0x80000000)
    State.regs[REG_MDR] = -1;
  else
    State.regs[REG_MDR] = 0;
}


// 0001 00Dn; extb Dn
4.0x1,00,2.DN0:S0:::extb
"extb"
*mn10300

*am33
*am33_2

{
  /* OP_10 (); */
  PC = cia;
  State.regs[REG_D0 + DN0] = EXTEND8 (State.regs[REG_D0 + DN0]);
}


// 0001 01Dn; extbu Dn
4.0x1,01,2.DN0:S0:::extbu
"extbu"
*mn10300

*am33
*am33_2

{
  /* OP_14 (); */
  PC = cia;
  State.regs[REG_D0 + DN0] &= 0xff;
}


// 0001 10Dn; exth Dn
4.0x1,10,2.DN0:S0:::exth
"exth"
*mn10300

*am33
*am33_2

{
  /* OP_18 (); */
  PC = cia;
  State.regs[REG_D0 + DN0] = EXTEND16 (State.regs[REG_D0 + DN0]);
}


// 0001 11Dn; exthu Dn
4.0x1,11,2.DN0:S0:::exthu
"exthu"
*mn10300

*am33
*am33_2

{
  /* OP_1C (); */
  PC = cia;
  State.regs[REG_D0 + DN0] &= 0xffff;
}


// 0000 Dn00; clr Dn
4.0x0,2.DN1,00:S0:::clr
"clr"
*mn10300

*am33
*am33_2

{
  /* OP_0 (); */
  PC = cia;
  State.regs[REG_D0 + DN1] = 0;

  PSW |= PSW_Z;
  PSW &= ~(PSW_V | PSW_C | PSW_N);
}


// 1110 DmDn; add Dm,Dn
4.0xe,2.DM1,2.DN0:S0:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_E0 (); */
  PC = cia;
  genericAdd(State.regs[REG_D0 + DM1], REG_D0 + DN0);
}

// 1111 0001 0110 DmAn; add Dm,An
8.0xf1+4.0x6,2.DM1,2.AN0:D0:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_F160 (); */
  PC = cia;
  genericAdd(State.regs[REG_D0 + DM1], REG_A0 + AN0);
}


// 1111 0001 0101 AmDn; add Am,Dn
8.0xf1+4.0x5,2.AM1,2.DN0:D0a:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_F150 (); */
  PC = cia;
  genericAdd(State.regs[REG_A0 + AM1], REG_D0 + DN0);
}


// 1111 0001 0111 AmAn; add Am,An
8.0xf1+4.0x7,2.AM1,2.AN0:D0b:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_F170 (); */
  PC = cia;
  genericAdd(State.regs[REG_A0 + AM1], REG_A0 + AN0);
}


// 0010 10Dn imm8....; add imm8,Dn (imm8 is sign-extended)
4.0x2,10,2.DN0+8.IMM8:S1:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_2800 (); */
  PC = cia;
  genericAdd(EXTEND8(IMM8), REG_D0 + DN0);
}


// 1111 1010 1100 00Dn imm16...; add imm16,Dn
8.0xfa+4.0xc,00,2.DN0+8.IMM16A+8.IMM16B:D2:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_FAC00000 (); */
  PC = cia;
  genericAdd(EXTEND16(FETCH16(IMM16A, IMM16B)), REG_D0 + DN0);
}


// 1111 1100 1100 00Dn imm32...; add imm32,Dn
8.0xfc+4.0xc,00,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_FCC00000 (); */
  PC = cia;
  genericAdd(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D), REG_D0 + DN0);
}


// 0010 00An imm8....; add imm8,An (imm8 is sign-extended)
4.0x2,00,2.AN0+8.IMM8:S1a:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_2000 (); */
  PC = cia;
  genericAdd(EXTEND8(IMM8), REG_A0 + AN0);
}


// 1111 1010 1101 00An imm16...; add imm16,An (imm16 is sign-extended.)
8.0xfa+4.0xd,00,2.AN0+8.IMM16A+8.IMM16B:D2a:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_FAD00000 (); */
  PC = cia;
  genericAdd(EXTEND16(FETCH16(IMM16A, IMM16B)), REG_A0 + AN0);
}


// 1111 1100 1101 00An imm32...; add imm32,An
8.0xfc+4.0xd,00,2.AN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4a:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_FCD00000 (); */
  PC = cia;
  genericAdd(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D), REG_A0 + AN0);
}


// 1111 1000 1111 1110 imm8....; add imm8,SP (imm8 is sign-extended.)
8.0xf8+8.0xfe+8.IMM8:D1:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_F8FE00 (); */
  unsigned32 imm;

  /* Note: no PSW changes. */
  PC = cia;
  imm = EXTEND8 (IMM8);
  State.regs[REG_SP] += imm;
}


// 1111 1010 1111 1110 imm16...; add imm16,SP (imm16 is sign-extended.)
8.0xfa+8.0xfe+8.IMM16A+8.IMM16B:D2b:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_FAFE0000 (); */
  unsigned32 imm;

  /* Note: no PSW changes. */
  PC = cia;
  imm = EXTEND16 (FETCH16(IMM16A, IMM16B));
  State.regs[REG_SP] += imm;
}


// 1111 1100 1111 1110 imm32...; add imm32,SP
8.0xfc+8.0xfe+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4b:::add
"add"
*mn10300

*am33
*am33_2

{
  /* OP_FCFE0000 (); */
  unsigned32 imm;

  /* Note: no PSW changes. */
  PC = cia;
  imm = FETCH32(IMM32A, IMM32B, IMM32C, IMM32D);
  State.regs[REG_SP] += imm;
}


// 1111 0001 0100 DmDn; addc Dm,Dn
8.0xf1+4.0x4,2.DM1,2.DN0:D0:::addc
"addc"
*mn10300

*am33
*am33_2

{
  /* OP_F140 (); */
  int z, c, n, v;
  unsigned32 reg1, reg2, sum;

  PC = cia;
  reg1 = State.regs[REG_D0 + DM1];
  reg2 = State.regs[REG_D0 + DN0];
  sum = reg1 + reg2 + ((PSW & PSW_C) != 0);
  State.regs[REG_D0 + DN0] = sum;

  z = ((PSW & PSW_Z) != 0) && (sum == 0);
  n = (sum & 0x80000000);
  c = (sum < reg1) || (sum < reg2);
  v = ((reg2 & 0x80000000) == (reg1 & 0x80000000)
       && (reg2 & 0x80000000) != (sum & 0x80000000));

  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | ( n ? PSW_N : 0)
	  | (c ? PSW_C : 0) | (v ? PSW_V : 0));
}


// 1111 0001 0000 DmDn; sub Dm,Dn
8.0xf1+4.0x0,2.DM1,2.DN0:D0:::sub
"sub"
*mn10300

*am33
*am33_2

{
  /* OP_F100 (); */
  PC = cia;
  genericSub(State.regs[REG_D0 + DM1], REG_D0 + DN0);
}

// 1111 0001 0010 DmAn; sub DmAn
8.0xf1+4.0x2,2.DM1,2.AN0:D0a:::sub
"sub"
*mn10300

*am33
*am33_2

{
  /* OP_F120 (); */
  PC = cia;
  genericSub(State.regs[REG_D0 + DM1], REG_A0 + AN0);
}


// 1111 0001 0001 AmDn; sub AmDn
8.0xf1+4.0x1,2.AM1,2.DN0:D0b:::sub
"sub"
*mn10300

*am33
*am33_2

{
  /* OP_F110 (); */
  PC = cia;
  genericSub(State.regs[REG_A0 + AM1], REG_D0 + DN0);
}


// 1111 0001 0011 AmAn; sub Am,An
8.0xf1+4.0x3,2.AM1,2.AN0:D0c:::sub
"sub"
*mn10300

*am33
*am33_2

{
  /* OP_F130 (); */
  PC = cia;
  genericSub(State.regs[REG_A0 + AM1], REG_A0 + AN0);
}


// 1111 1100 1100 01Dn imm32...; sub imm32,Dn
8.0xfc+4.0xc,01,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4:::sub
"sub"
*mn10300

*am33
*am33_2

{
  /* OP_FCC40000 (); */
  PC = cia;
  genericSub(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D), REG_D0 + DN0);
}


// 1111 1100 1101 01An imm32...; sub imm32,An
8.0xfc+4.0xd,01,2.AN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4a:::sub
"sub"
*mn10300

*am33
*am33_2

{
  /* OP_FCD40000 (); */
  PC = cia;
  genericSub(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D), REG_A0 + AN0);
}


// 1111 0001 1000 DmDn; subc Dm,Dn
8.0xf1+4.0x8,2.DM1,2.DN0:D0:::subc
"subc"
*mn10300

*am33
*am33_2

{
  /* OP_F180 (); */
  int z, c, n, v;
  unsigned32 reg1, reg2, difference;

  PC = cia;
  reg1 = State.regs[REG_D0 + DM1];
  reg2 = State.regs[REG_D0 + DN0];
  difference = reg2 - reg1 - ((PSW & PSW_C) != 0);
  State.regs[REG_D0 + DN0] = difference;

  z = ((PSW & PSW_Z) != 0) && (difference == 0);
  n = (difference & 0x80000000);
  c = (reg1 > reg2);
  v = ((reg2 & 0x80000000) != (reg1 & 0x80000000)
       && (reg2 & 0x80000000) != (difference & 0x80000000));

  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | ( n ? PSW_N : 0)
	  | (c ? PSW_C : 0) | (v ? PSW_V : 0));
}


// 1111 0010 0100 DmDn; mul Dm,Dn
8.0xf2+4.0x4,2.DM1,2.DN0:D0:::mul
"mul"
*mn10300

*am33
*am33_2

{
  /* OP_F240 (); */
  unsigned64 temp;
  int n, z;

  PC = cia;
  temp = ((signed64)(signed32)State.regs[REG_D0 + DN0]
          *  (signed64)(signed32)State.regs[REG_D0 + DM1]);
  State.regs[REG_D0 + DN0] = temp & 0xffffffff;
  State.regs[REG_MDR] = (temp & 0xffffffff00000000LL) >> 32;;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 0010 0101 DmDn; mulu Dm,Dn
8.0xf2+4.0x5,2.DM1,2.DN0:D0:::mulu
"mulu"
*mn10300

*am33
*am33_2

{
  /* OP_F250 (); */
  unsigned64 temp;
  int n, z;

  PC = cia;
  temp = ((unsigned64)State.regs[REG_D0 + DN0]
          * (unsigned64)State.regs[REG_D0 + DM1]);
  State.regs[REG_D0 + DN0] = temp & 0xffffffff;
  State.regs[REG_MDR] = (temp & 0xffffffff00000000LL) >> 32;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 0010 0110 DmDn; div Dm,Dn
8.0xf2+4.0x6,2.DM1,2.DN0:D0:::div
"div"
*mn10300

*am33
*am33_2

{
  /* OP_F260 (); */
  signed64 temp;
  signed32 denom;
  int n, z, v;

  PC = cia;
  denom = (signed32)State.regs[REG_D0 + DM1];

  temp = State.regs[REG_MDR];
  temp <<= 32;
  temp |= State.regs[REG_D0 + DN0];
  if ( !(v = (0 == denom)) )
    {
      State.regs[REG_MDR] = temp % (signed32)State.regs[REG_D0 + DM1];
      temp /= (signed32)State.regs[REG_D0 + DM1];
      State.regs[REG_D0 + DN0] = temp & 0xffffffff;
    }
  else
    {
      State.regs[REG_MDR] = temp;
      State.regs[REG_D0 + DN0] = 0xff;
    }
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (v ? PSW_V : 0));
}


// 1111 0010 0111 DmDn; divu Dm,Dn
8.0xf2+4.0x7,2.DM1,2.DN0:D0:::divu
"divu"
*mn10300

*am33
*am33_2

{
  /* OP_F270 (); */
  unsigned64 temp;
  unsigned32 denom;
  int n, z, v;

  PC = cia;
  denom = (unsigned32)State.regs[REG_D0 + DM1];
  temp = State.regs[REG_MDR];
  temp <<= 32;
  temp |= State.regs[REG_D0 + DN0];
  if ( !(v = (0 == denom)) ) 
    {
      State.regs[REG_MDR] = temp % State.regs[REG_D0 + DM1];
      temp /= State.regs[REG_D0 + DM1];
      State.regs[REG_D0 + DN0] = temp & 0xffffffff;
    }
  else
    {
      State.regs[REG_MDR] = temp;
      State.regs[REG_D0 + DN0] = 0xff;
    }
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (v ? PSW_V : 0));
}


// 0100 Dn00; inc Dn
4.0x4,2.DN1,00:S0:::inc
"inc"
*mn10300

*am33
*am33_2

{
  /* OP_40 (); */
  unsigned32 imm;

  PC = cia;
  imm = 1;
  genericAdd(imm, REG_D0 + DN1);
}


// 0100 An01
4.0x4,2.AN1,01:S0a:::inc
"inc"
*mn10300

*am33
*am33_2

{
  /* OP_41 (); */
  PC = cia;
  State.regs[REG_A0 + AN1] += 1;
}


// 0101 00An; inc4 An
4.0x5,00,2.AN0:S0:::inc4
"inc4"
*mn10300

*am33
*am33_2

{
  /* OP_50 (); */
  PC = cia;
  State.regs[REG_A0 + AN0] += 4;
}


// 1010 DnDn imm8....; cmp imm8,Dn (imm8 is sign-extended.)
4.0xa,2.DM1,2.DN0=DM1+IMM8:S0i:::cmp
"cmp"
*mn10300

*am33
*am33_2

{
  PC = cia;
  /* OP_A000 (); */
  genericCmp(EXTEND8 (IMM8), State.regs[REG_D0 + DN0]);
}


// 1010 DmDn; cmp Dm,Dn (Dm != Dn, see above when Dm == Dn)
4.0xa,2.DM1,2.DN0!DM1:S0:::cmp
"cmp"
*mn10300

*am33
*am33_2

{
  PC = cia;
  /* OP_A0 (); */
  genericCmp(State.regs[REG_D0 + DM1], State.regs[REG_D0 + DN0]);
}


// 1111 0001 1010 DmAn; cmp Dm,An
8.0xf1+4.0xa,2.DM1,2.AN0:D0:::cmp
"cmp"
*mn10300

*am33
*am33_2

{
  /* OP_F1A0 (); */
  PC = cia;
  genericCmp(State.regs[REG_D0 + DM1], State.regs[REG_A0 + AN0]);
}


// 1111 0001 1001 AmDn; cmp Am,Dn
8.0xf1+4.0x9,2.AM1,2.DN0:D0a:::cmp
"cmp"
*mn10300

*am33
*am33_2

{
  /* OP_F190 (); */
  PC = cia;
  genericCmp(State.regs[REG_A0 + AM1], State.regs[REG_D0 + DN0]);
}


// 1011 AnAn imm8....; cmp imm8,An (imm8 is zero-extended.)
4.0xb,2.AM1,2.AN0=AM1+IMM8:S0ai:::cmp
"cmp"
*mn10300

*am33
*am33_2

{
  PC = cia;
  /* OP_B000 (); */
  genericCmp(IMM8,
	     State.regs[REG_A0 + AN0]);
}


// 1011 AmAn; cmp Am,An (Dm != Dn, see above when Dm == Dn)
4.0xb,2.AM1,2.AN0!AM1:S0a:::cmp
"cmp"
*mn10300

*am33
*am33_2

{
  PC = cia;
  /* OP_B0 (); */
  genericCmp(State.regs[REG_A0 + AM1], State.regs[REG_A0 + AN0]);
}


// 1111 1010 1100 10Dn imm16...; cmp imm16,Dn (imm16 is sign-extended.)
8.0xfa+4.0xc,10,2.DN0+8.IMM16A+8.IMM16B:D2:::cmp
"cmp"
*mn10300

*am33
*am33_2

{
  /* OP_FAC80000 (); */
  PC = cia;
  genericCmp(EXTEND16(FETCH16(IMM16A, IMM16B)),
	     State.regs[REG_D0 + DN0]);
}


// 1111 1100 1100 10Dn imm32...; cmp imm32,Dn
8.0xfc+4.0xc,10,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4:::cmp
"cmp"
*mn10300

*am33
*am33_2

{
  /* OP_FCC80000 (); */
  PC = cia;
  genericCmp(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D),
	     State.regs[REG_D0 + DN0]);
}


// 1111 1010 1101 10An imm16...; cmp imm16,An (imm16 is zero-extended.)
8.0xfa+4.0xd,10,2.AN0+8.IMM16A+8.IMM16B:D2a:::cmp
"cmp"
*mn10300

*am33
*am33_2

{
  /* OP_FAD80000 (); */
  PC = cia;
  genericCmp(FETCH16(IMM16A, IMM16B),
	     State.regs[REG_A0 + AN0]);
}


// 1111 1100 1101 10An imm32...; cmp imm32,An
8.0xfc+4.0xd,10,2.AN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4a:::cmp
"cmp"
*mn10300

*am33
*am33_2

{
  /* OP_FCD80000 (); */
  PC = cia;
  genericCmp(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D),
	     State.regs[REG_A0 + AN0]);
}


// 1111 0010 0000 DmDn; and Dm,Dn
8.0xf2+4.0x0,2.DM1,2.DN0:D0:::and
"and"
*mn10300

*am33
*am33_2

{
  /* OP_F200 (); */
  int n, z;

  PC = cia;
  State.regs[REG_D0 + DN0] &= State.regs[REG_D0 + DM1];
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1000 1110 00Dn imm8....; and imm8,Dn (imm8 is zero-extended.)
8.0xf8+4.0xe,00,2.DN0+8.IMM8:D1:::and
"and"
*mn10300

*am33
*am33_2

{
  /* OP_F8E000 (); */
  int n, z;

  PC = cia;
  State.regs[REG_D0 + DN0] &= IMM8;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1010 1110 00Dn imm16...; and imm16,Dn (imm16 is zero-extended.)
8.0xfa+4.0xe,00,2.DN0+8.IMM16A+8.IMM16B:D2:::and
"and"
*mn10300

*am33
*am33_2

{
  /* OP_FAE00000 (); */
  int n, z;

  PC = cia;
  State.regs[REG_D0 + DN0] &= FETCH16(IMM16A, IMM16B);
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1100 1110 00Dn imm32...; and imm32,Dn
8.0xfc+4.0xe,00,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4:::and
"and"
*mn10300

*am33
*am33_2

{
  /* OP_FCE00000 (); */
  int n, z;

  PC = cia;
  State.regs[REG_D0 + DN0]
    &= FETCH32(IMM32A, IMM32B, IMM32C, IMM32D);
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1010 1111 1100 imm16...; and imm16,PSW (imm16 is zero-extended.)
8.0xfa+8.0xfc+8.IMM16A+8.IMM16B:D2a:::and
"and"
*mn10300

*am33
*am33_2

{
  /* OP_FAFC0000 (); */
  PC = cia;
  PSW &= FETCH16(IMM16A, IMM16B);
}



// 1111 0010 0001 DmDn; or DmDn
8.0xf2+4.0x1,2.DM1,2.DN0:D0:::or
"or"
*mn10300

*am33
*am33_2

{
  /* OP_F210 (); */
  PC = cia;
  genericOr(State.regs[REG_D0 + DM1], REG_D0 + DN0);
}


// 1111 1000 1110 01Dn imm8....; or imm8,Dn (imm8 is zero-extended.)n
8.0xf8+4.0xe,01,2.DN0+8.IMM8:D1:::or
"or"
*mn10300

*am33
*am33_2

{
  /* OP_F8E400 (); */
  PC = cia;
  genericOr(IMM8, REG_D0 + DN0);
}


// 1111 1010 1110 01Dn imm16...; or imm16,DN (imm16 is zero-extended.)
8.0xfa+4.0xe,01,2.DN0+8.IMM16A+8.IMM16B:D2:::or
"or"
*mn10300

*am33
*am33_2

{
  /* OP_FAE40000 (); */
  PC = cia;
  genericOr(FETCH16(IMM16A, IMM16B), REG_D0 + DN0);
}


// 1111 1100 1110 01Dn imm32...; or imm32,Dn
8.0xfc+4.0xe,01,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4:::or
"or"
*mn10300

*am33
*am33_2

{
  /* OP_FCE40000 (); */
  PC = cia;
  genericOr(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D), REG_D0 + DN0);
}


// 1111 1010 1111 1101 imm16...; or imm16,PSW (imm16 is zero-extended.)
8.0xfa+8.0xfd+8.IMM16A+8.IMM16B:D2a:::or
"or"
*mn10300

*am33
*am33_2

{
  /* OP_FAFD0000 (); */
  PC = cia;
  PSW |= FETCH16(IMM16A, IMM16B);
}


// 1111 0010 0010 DmDn; xor Dm,Dn
8.0xf2+4.0x2,2.DM1,2.DN0:D0:::xor
"xor"
*mn10300

*am33
*am33_2

{
  /* OP_F220 (); */
  PC = cia;
  genericXor(State.regs[REG_D0 + DM1], REG_D0 + DN0);
}


// 1111 1010 1110 10Dn imm16...; xor imm16,Dn (imm16 is zero-extended.)
8.0xfa+4.0xe,10,2.DN0+8.IMM16A+8.IMM16B:D2:::xor
"xor"
*mn10300

*am33
*am33_2

{
  /* OP_FAE80000 (); */
  PC = cia;
  genericXor(FETCH16(IMM16A, IMM16B), REG_D0 + DN0);
}


// 1111 1100 1110 10Dn imm32...; xor imm32,Dn
8.0xfc+4.0xe,10,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4:::xor
"xor"
*mn10300

*am33
*am33_2

{
  /* OP_FCE80000 (); */
  PC = cia;
  genericXor(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D), REG_D0 + DN0);
}


// 1111 0010 0011 00Dn; not Dn
8.0xf2+4.0x3,00,2.DN0:D0:::not
"not"
*mn10300

*am33
*am33_2

{
  /* OP_F230 (); */
  int n, z;

  PC = cia;
  State.regs[REG_D0 + DN0] = ~State.regs[REG_D0 + DN0];
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1000 1110 11Dn imm8....; btst imm8,Dn (imm8 is zero-extended.)
8.0xf8+4.0xe,11,2.DN0+8.IMM8:D1:::btst
"btst"
*mn10300

*am33
*am33_2

{
  /* OP_F8EC00 (); */
  PC = cia;
  genericBtst(IMM8, State.regs[REG_D0 + DN0]);
}


// 1111 1010 1110 11Dn imm16.....; btst imm16,Dn (imm16 is zero-extended.)
8.0xfa+4.0xe,11,2.DN0+8.IMM16A+8.IMM16B:D2:::btst
"btst"
*mn10300

*am33
*am33_2

{
  /* OP_FAEC0000 (); */
  PC = cia;
  genericBtst(FETCH16(IMM16A, IMM16B), State.regs[REG_D0 + DN0]);
}


// 1111 1100 1110 11Dn imm32...; btst imm32,Dn
8.0xfc+4.0xe,11,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4:::btst
"btst"
*mn10300

*am33
*am33_2

{
  /* OP_FCEC0000 (); */
  PC = cia;
  genericBtst(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D),
	      State.regs[REG_D0 + DN0]);
}


// 1111 1110 0000 0010 abs32... imm8....; btst imm8,(abs32) (imm8 is zero-extended., processing unit: byte)
8.0xfe+8.0x02+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D+8.IMM8:D5:::btst
"btst"
*mn10300

*am33
*am33_2

{
  /* OP_FE020000 (); */
  PC = cia;
  genericBtst(IMM8,
	      load_byte(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)));
}


// 1111 1010 1111 10An d8...... imm8....; 
// btst imm8,(d8,An) (d8 is sign-extended,imm8 is zero-extended., processing unit: byte)
8.0xfa+4.0xf,10,2.AN0+8.D8+8.IMM8:D2a:::btst
"btst"
*mn10300

*am33
*am33_2

{
  /* OP_FAF80000 (); */
  PC = cia;
  genericBtst(IMM8,
	      load_byte(State.regs[REG_A0 + AN0] + EXTEND8(D8)));
}


// 1111 0000 1000 DmAn; bset Dm,(An) (Processing unit byte)
8.0xf0+4.8,2.DM1,2.AN0:D0:::bset
"bset"
*mn10300

*am33
*am33_2

{
  /* OP_F080 (); */
  unsigned32 temp;
  int z;

  PC = cia;
  temp = load_byte (State.regs[REG_A0 + AN0]);
  z = (temp & State.regs[REG_D0 + DM1]) == 0;
  temp |= State.regs[REG_D0 + DM1];
  store_byte (State.regs[REG_A0 + AN0], temp);
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= (z ? PSW_Z : 0);
}


// 1111 1110 0000 0000 abs32... imm8....;
// bset imm8,(abs32) (imm8 is zero-extended., processing unit: byte)
8.0xfe+8.0x00+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D+8.IMM8:D5:::bset
"bset"
*mn10300

*am33
*am33_2

{
  /* OP_FE000000 (); */
  unsigned32 temp;
  int z;

  PC = cia;
  temp = load_byte (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D));
  z = (temp & IMM8) == 0;
  temp |= IMM8;
  store_byte (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D), temp);
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= (z ? PSW_Z : 0);
}


// 1111 1010 1111 00AnAn d8...... imm8....;
// bset imm8,(d8,An) (d8 is sign-extended, imm8 is zero-extended., processing unit: byte)
8.0xfa+4.0xf,00,2.AN0+8.D8+8.IMM8:D2:::bset
"bset"
*mn10300

*am33
*am33_2

{
  /* OP_FAF00000 (); */
  unsigned32 temp;
  int z;

  PC = cia;
  temp = load_byte ((State.regs[REG_A0 + AN0] + EXTEND8 (D8)));
  z = (temp & (IMM8)) == 0;
  temp |= (IMM8);
  store_byte ((State.regs[REG_A0 + AN0] + EXTEND8 (D8)), temp);
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= (z ? PSW_Z : 0);
}


// 1111 0000 1001 DmAn; bclr Dm,(An) (Processing unit byte)
8.0xf0+4.0x9,2.DM1,2.AN0:D0:::bclr
"bclr"
*mn10300

*am33
*am33_2

{
  /* OP_F090 (); */
  unsigned32 temp;
  int z;

  PC = cia;
  temp = load_byte (State.regs[REG_A0 + AN0]);
  z = (temp & State.regs[REG_D0 + DM1]) == 0;
  temp = temp & ~State.regs[REG_D0 + DM1];
  store_byte (State.regs[REG_A0 + AN0], temp);
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= (z ? PSW_Z : 0);
}


// 1111 1110 0000 0001 abs32... imm8....;
// bclr imm8,(abs32) (imm8 is zero-extended., processing unit: byte)
8.0xfe+8.0x01+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D+8.IMM8:D5:::bclr
"bclr"
*mn10300

*am33
*am33_2

{
  /* OP_FE010000 (); */
  unsigned32 temp;
  int z;

  PC = cia;
  temp = load_byte (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D));
  z = (temp & IMM8) == 0;
  temp = temp & ~(IMM8);
  store_byte (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D), temp);
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= (z ? PSW_Z : 0);
}


// 1111 1010 1111 01An d8...... imm8....;
// bclr imm8,(d8,An) (d8 is sign-extended, imm8 is zero-extended., processing unit: byte)
8.0xfa+4.0xf,01,2.AN0+8.D8+8.IMM8:D2:::bclr
"bclr"
*mn10300

*am33
*am33_2

{
  /* OP_FAF40000 (); */
  unsigned32 temp;
  int z;

  PC = cia;
  temp = load_byte ((State.regs[REG_A0 + AN0] + EXTEND8 (D8)));
  z = (temp & (IMM8)) == 0;
  temp = temp & ~(IMM8);
  store_byte ((State.regs[REG_A0 + AN0] + EXTEND8 (D8)), temp);
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= (z ? PSW_Z : 0);
}


// 1111 0010 1011 DmDn; asr Dm,Dn
8.0xf2+4.0xb,2.DM1,2.DN0:D0:::asr
"asr"
*mn10300

*am33
*am33_2

{
  /* OP_F2B0 (); */
  signed32 temp;
  int z, n, c;

  PC = cia;
  temp = State.regs[REG_D0 + DN0];
  c = temp & 1;
  temp >>= State.regs[REG_D0 + DM1];
  State.regs[REG_D0 + DN0] = temp;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (c ? PSW_C : 0));
}


// 1111 1000 1100 10Dn imm8...; asr imm8,Dn (imm8 is zero-extended.)
8.0xf8+4.0xc,10,2.DN0+8.IMM8:D1:::asr
"asr"
*mn10300

*am33
*am33_2

{
  /* OP_F8C800 (); */
  signed32 temp;
  int z, n, c;

  PC = cia;
  temp = State.regs[REG_D0 + DN0];
  c = temp & 1;
  temp >>= IMM8;
  State.regs[REG_D0 + DN0] = temp;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (c ? PSW_C : 0));
}


// 1111 0010 1010 DmDn; lsr Dm,Dn
8.0xf2+4.0xa,2.DM1,2.DN0:D0:::lsr
"lsr"
*mn10300

*am33
*am33_2

{
  /* OP_F2A0 (); */
  int z, n, c;

  PC = cia;
  c = State.regs[REG_D0 + DN0] & 1;
  State.regs[REG_D0 + DN0]
    >>= State.regs[REG_D0 + DM1];
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (c ? PSW_C : 0));
}


// 1111 1000 1100 01Dn imm8...; lsr imm8,Dn (imm8 is zero-extended.)
8.0xf8+4.0xc,01,2.DN0+8.IMM8:D1:::lsr
"lsr"
*mn10300

*am33
*am33_2

{
  /* OP_F8C400 (); */
  int z, n, c;

  PC = cia;
  c = State.regs[REG_D0 + DN0] & 1;
  State.regs[REG_D0 + DN0] >>=  IMM8;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (c ? PSW_C : 0));
}


// 1111 0010 1001 DmDn; asl Dm,Dn
8.0xf2+4.0x9,2.DM1,2.DN0:D0:::asl
"asl"
*mn10300

*am33
*am33_2

{
  /* OP_F290 (); */
  int n, z;

  PC = cia;
  State.regs[REG_D0 + DN0]
    <<= State.regs[REG_D0 + DM1];
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1000 1100 00Dn imm8...; asl imm8,Dn (imm8 is zero-extended.)
8.0xf8+4.0xc,00,2.DN0+8.IMM8:D1:::asl
"asl"
*mn10300

*am33
*am33_2

{
  /* OP_F8C000 (); */
  int n, z;

  PC = cia;
  State.regs[REG_D0 + DN0] <<= IMM8;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 0101 01Dn; als2 Dn
4.0x5,01,2.DN0:S0:::asl2
"asl2"
*mn10300

*am33
*am33_2

{
  /* OP_54 (); */
  int n, z;
  PC = cia;

  State.regs[REG_D0 + DN0] <<= 2;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 0010 1000 01Dn; ror Dn
8.0xf2+4.0x8,01,2.DN0:D0:::ror
"ror"
*mn10300

*am33
*am33_2

{
  /* OP_F284 (); */
  unsigned32 value;
  int c,n,z;

  PC = cia;
  value = State.regs[REG_D0 + DN0];
  c = (value & 0x1);

  value >>= 1;
  value |= ((PSW & PSW_C) != 0) ? 0x80000000 : 0;
  State.regs[REG_D0 + DN0] = value;
  z = (value == 0);
  n = (value & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (c ? PSW_C : 0));
}


// 1111 0010 1000 00Dn; rol Dn
8.0xf2+4.0x8,00,2.DN0:D0:::rol
"rol"
*mn10300

*am33
*am33_2

{
  /* OP_F280 (); */
  unsigned32 value;
  int c,n,z;

  PC = cia;
  value = State.regs[REG_D0 + DN0];
  c = (value & 0x80000000) ? 1 : 0;

  value <<= 1;
  value |= ((PSW & PSW_C) != 0);
  State.regs[REG_D0 + DN0] = value;
  z = (value == 0);
  n = (value & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (c ? PSW_C : 0));
}


// 1100 1000 d8......; beq (d8,PC) (d8 is sign-extended)
8.0xc8+8.D8:S1:::beq
"beq"
*mn10300

*am33
*am33_2

{
  /* OP_C800 (); */
  PC = cia;
  if ((PSW & PSW_Z))
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1100 1001 d8......; bne (d8,PC) (d8 is sign-extended)
8.0xc9+8.D8:S1:::bne
"bne"
*mn10300

*am33
*am33_2

{
  /* OP_C900 (); */
  PC = cia;
  if (!(PSW & PSW_Z))
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1100 0001 d8......; bgt (d8,PC) (d8 is sign-extended)
8.0xc1+8.D8:S1:::bgt
"bgt"
*mn10300

*am33
*am33_2

{
  /* OP_C100 (); */
  PC = cia;
  if (!((PSW & PSW_Z)
        || (((PSW & PSW_N) != 0) ^ ((PSW & PSW_V) != 0))))
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1100 0010 d8......; bge (d8,PC) (d8 is sign-extended)
8.0xc2+8.D8:S1:::bge
"bge"
*mn10300

*am33
*am33_2

{
  /* OP_C200 (); */
  PC = cia;
  if (!(((PSW & PSW_N) != 0) ^ ((PSW & PSW_V) != 0)))
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1100 0011 d8......; ble (d8,PC) (d8 is sign-extended)
8.0xc3+8.D8:S1:::ble
"ble"
*mn10300

*am33
*am33_2

{
  /* OP_C300 (); */
  PC = cia;
  if ((PSW & PSW_Z)
      || (((PSW & PSW_N) != 0) ^ ((PSW & PSW_V) != 0)))
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1100 0000 d8......; blt (d8,PC) (d8 is sign-extended)
8.0xc0+8.D8:S1:::blt
"blt"
*mn10300

*am33
*am33_2

{
  /* OP_C000 (); */
  PC = cia;
  if (((PSW & PSW_N) != 0) ^ ((PSW & PSW_V) != 0))
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1100 0101 d8......; bhi (d8,PC) (d8 is sign-extended)
8.0xc5+8.D8:S1:::bhi
"bhi"
*mn10300

*am33
*am33_2

{
  /* OP_C500 (); */
  PC = cia;
  if (!(((PSW & PSW_C) != 0) || (PSW & PSW_Z) != 0))
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1100 0110 d8......; bcc (d8,PC) (d8 is sign-extended)
8.0xc6+8.D8:S1:::bcc
"bcc"
*mn10300

*am33
*am33_2

{
  /* OP_C600 (); */
  PC = cia;
  if (!(PSW & PSW_C))
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1100 0101 d8......; bls (d8,PC) (d8 is sign-extended)
8.0xc7+8.D8:S1:::bls
"bls"
*mn10300

*am33
*am33_2

{
  /* OP_C700 (); */
  PC = cia;
  if (((PSW & PSW_C) != 0) || (PSW & PSW_Z) != 0)
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1100 0100 d8......; bcs (d8,PC) (d8 is sign-extended)
8.0xc4+8.D8:S1:::bcs
"bcs"
*mn10300

*am33
*am33_2

{
  /* OP_C400 (); */
  PC = cia;
  if (PSW & PSW_C)
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1111 1000 1110 1000 d8......; bvc (d8,PC) (d8 is sign-extended)
8.0xf8+8.0xe8+8.D8:D1:::bvc
"bvc"
*mn10300

*am33
*am33_2

{
  /* OP_F8E800 (); */
  PC = cia;
  if (!(PSW & PSW_V))
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1111 1000 1110 1001 d8......; bvs (d8,PC) (d8 is sign-extended)
8.0xf8+8.0xe9+8.D8:D1:::bvs
"bvs"
*mn10300

*am33
*am33_2

{
  /* OP_F8E900 (); */
  PC = cia;
  if (PSW & PSW_V)
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1111 1000 1110 1010 d8......; bnc (d8,PC) (d8 is sign-extended)
8.0xf8+8.0xea+8.D8:D1:::bnc
"bnc"
*mn10300

*am33
*am33_2

{
  /* OP_F8EA00 (); */
  PC = cia;
  if (!(PSW & PSW_N))
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1111 1000 1110 1010 d8......; bns (d8,PC) (d8 is sign-extended)
8.0xf8+8.0xeb+8.D8:D1:::bns
"bns"
*mn10300

*am33
*am33_2

{
  /* OP_F8EB00 (); */
  PC = cia;
  if (PSW & PSW_N)
    {
      State.regs[REG_PC] += EXTEND8 (D8);
      nia = PC;
    }
}


// 1100 1010 d8......; bra (d8,PC) (d8 is sign-extended)
8.0xca+8.D8:S1:::bra
"bra"
*mn10300

*am33
*am33_2

{
  /* OP_CA00 (); */
  PC = cia;
  State.regs[REG_PC] += EXTEND8 (D8);
  nia = PC;
}


// 1101 1000; leq
8.0xd8:S0:::leq
"leq"
*mn10300

*am33
*am33_2

{
  /* OP_D8 (); */
  PC = cia;
  if (PSW & PSW_Z)
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}


// 1101 1001; lne
8.0xd9:S0:::lne
"lne"
*mn10300

*am33
*am33_2

{
  /* OP_D9 (); */
  PC = cia;
  if (!(PSW & PSW_Z))
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}


// 1101 0001; lgt
8.0xd1:S0:::lgt
"lgt"
*mn10300

*am33
*am33_2

{
  /* OP_D1 (); */
  PC = cia;
  if (!((PSW & PSW_Z)
        || (((PSW & PSW_N) != 0) ^ ((PSW & PSW_V) != 0))))
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}


// 1101 0010; lge
8.0xd2:S0:::lge
"lge"
*mn10300

*am33
*am33_2

{
  /* OP_D2 (); */
  PC = cia;
  if (!(((PSW & PSW_N) != 0) ^ ((PSW & PSW_V) != 0)))
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}


// 1101 0011; lle
8.0xd3:S0:::lle
"lle"
*mn10300

*am33
*am33_2

{
  /* OP_D3 (); */
  PC = cia;
  if ((PSW & PSW_Z)
      || (((PSW & PSW_N) != 0) ^ ((PSW & PSW_V) != 0)))
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}


// 1101 0000; llt
8.0xd0:S0:::llt
"llt"
*mn10300

*am33
*am33_2

{
  /* OP_D0 (); */
  PC = cia;
  if (((PSW & PSW_N) != 0) ^ ((PSW & PSW_V) != 0))
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}


// 1101 0101; lhi
8.0xd5:S0:::lhi
"lhi"
*mn10300

*am33
*am33_2

{
  /* OP_D5 (); */
  PC = cia;
  if (!(((PSW & PSW_C) != 0) || (PSW & PSW_Z) != 0))
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}


// 1101 0110; lcc
8.0xd6:S0:::lcc
"lcc"
*mn10300

*am33
*am33_2

{
  /* OP_D6 (); */
  PC = cia;
  if (!(PSW & PSW_C))
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}


// 1101 0111; lls
8.0xd7:S0:::lls
"lls"
*mn10300

*am33
*am33_2

{
  /* OP_D7 (); */
  PC = cia;
  if (((PSW & PSW_C) != 0) || (PSW & PSW_Z) != 0)
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}


// 1101 0100; lcs
8.0xd4:S0:::lcs
"lcs"
*mn10300

*am33
*am33_2

{
  /* OP_D4 (); */
  PC = cia;
  if (PSW & PSW_C)
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}


// 1101 1010; lra
8.0xda:S0:::lra
"lra"
*mn10300

*am33
*am33_2

{
  /* OP_DA (); */
  PC = cia;
  State.regs[REG_PC] = State.regs[REG_LAR] - 4;
  nia = PC;
}


// 1101 1010; setlb
8.0xdb:S0:::setlb
"setlb"
*mn10300

*am33
*am33_2

{
  /* OP_DB (); */
  PC = cia;
  State.regs[REG_LIR] = load_word (State.regs[REG_PC] + 1);
  State.regs[REG_LAR] = State.regs[REG_PC] + 5;
}


// 1111 0000 1111 01An; jmp (An)
8.0xf0+4.0xf,01,2.AN0:D0:::jmp
"jmp"
*mn10300

*am33
*am33_2

{
  /* OP_F0F4 (); */
  PC = State.regs[REG_A0 + AN0];
  nia = PC;
}


// 1100 1100 d16.....; jmp (d16,PC) (d16 is sign-extended.)
8.0xcc+8.D16A+8.D16B:S2:::jmp
"jmp"
*mn10300

*am33
*am33_2

{
  /* OP_CC0000 (); */
  PC = cia + EXTEND16(FETCH16(D16A, D16B));
  nia = PC;
}


// 1101 1100 d32........; jmp (d32, PC)
8.0xdc+8.D32A+8.D32B+8.D32C+8.D32D:S4:::jmp
"jmp"
*mn10300

*am33
*am33_2

{
  /* OP_DC000000 (); */
  PC = cia + FETCH32(D32A, D32B, D32C, D32D);
  nia = PC;
}


// 1111 0000 1111 00An; calls (An)
8.0xf0+4.0xf,00,2.AN0:D0:::calls
"calls"
*mn10300

*am33
*am33_2

{
  /* OP_F0F0 (); */
  unsigned32 next_pc, sp;

  PC = cia;
  sp = State.regs[REG_SP];
  next_pc = State.regs[REG_PC] + 2;
  store_word(sp, next_pc);
  State.regs[REG_MDR] = next_pc;
  State.regs[REG_PC] = State.regs[REG_A0 + AN0];
  nia = PC;
}


// 1111 1010 1111 1111 d16.....; calls (d16,PC) (d16 is sign-extended.)
8.0xfa+8.0xff+8.D16A+8.D16B:D2:::calls
"calls"
*mn10300

*am33
*am33_2

{
  /* OP_FAFF0000 (); */
  unsigned32 next_pc, sp;

  PC = cia;
  sp = State.regs[REG_SP];
  next_pc = State.regs[REG_PC] + 4;
  store_word(sp, next_pc);
  State.regs[REG_MDR] = next_pc;
  State.regs[REG_PC] += EXTEND16 (FETCH16(D16A, D16B));
  nia = PC;
}


// 1111 1100 1111 1111 d32.....; calls (d32,PC)
8.0xfc+8.0xff+8.D32A+8.D32B+8.D32C+8.D32D:D4:::calls
"calls"
*mn10300

*am33
*am33_2

{
  /* OP_FCFF0000 (); */
  unsigned32 next_pc, sp;

  PC = cia;
  sp = State.regs[REG_SP];
  next_pc = State.regs[REG_PC] + 6;
  store_word(sp, next_pc);
  State.regs[REG_MDR] = next_pc;
  State.regs[REG_PC] += FETCH32(D32A, D32B, D32C, D32D);
  nia = PC;
}


// 1111 0000 1111 1100; rets
8.0xf0+8.0xfc:D0:::rets
"rets"
*mn10300

*am33
*am33_2

{
  /* OP_F0FC (); */
  unsigned32 sp;

  sp = State.regs[REG_SP];
  State.regs[REG_PC] = load_word(sp);
  nia = PC;
}


// 1111 0000 1111 1101; rti
8.0xf0+8.0xfd:D0:::rti
"rti"
*mn10300

*am33
*am33_2

{
  /* OP_F0FD (); */
  unsigned32 sp;

  sp = State.regs[REG_SP];
  PSW = load_half(sp);
  State.regs[REG_PC] = load_word(sp+4);
  State.regs[REG_SP] +=8;
  nia = PC;
}


// 1111 0000 1111 1110; trap
8.0xf0+8.0xfe:D0:::trap
"trap"
*mn10300

*am33
*am33_2

{
  /* OP_F0FE (); */
  unsigned32 sp, next_pc;

  PC = cia;
  sp = State.regs[REG_SP];
  next_pc = State.regs[REG_PC] + 2;
  store_word(sp, next_pc);
  nia = PC;
}


// 1111 0000 1111 1111; rtm
8.0xf0+8.0xff:D0:::rtm
"rtm"
*mn10300

*am33
*am33_2

{
  /* OP_F0FF (); */
  PC = cia;
  abort ();
}


// 1100 1011; nop
8.0xcb:S0:::nop
"nop"
*mn10300

*am33
*am33_2

{
  /* OP_CB (); */
  PC = cia;
}


// 1111 0101 0000  DmDn; udf20 Dm,Dn
8.0xf5+4.0x0,2.DM1,2.DN0:D0:::putx
"putx"
*mn10300
{
  /* OP_F500 (); */
  PC = cia;
  State.regs[REG_MDRQ] = State.regs[REG_D0 + DN0];
}


// 1111 0110 1111 DmDn; udf15 Dm,Dn
8.0xf6+4.0xf,2.DM1,2.DN0:D0:::getx
"getx"
*mn10300

*am33
*am33_2

{
  /* OP_F6F0 (); */
  int z, n;

  PC = cia;
  z = (State.regs[REG_MDRQ] == 0);
  n = ((State.regs[REG_MDRQ] & 0x80000000) != 0);
  State.regs[REG_D0 + DN0] = State.regs[REG_MDRQ];

  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= (z ? PSW_Z : 0) | (n ? PSW_N : 0);
}


// 1111 0110 0000 DmDn; udf00 Dm,Dn
8.0xf6+4.0x0,2.DM1,2.DN0:D0:::mulq
"mulq"
*mn10300

*am33
*am33_2

{
  /* OP_F600 (); */
  unsigned64 temp;
  int n, z;

  PC = cia;
  temp = ((signed64)(signed32)State.regs[REG_D0 + DN0]
          *  (signed64)(signed32)State.regs[REG_D0 + DM1]);
  State.regs[REG_D0 + DN0] = temp & 0xffffffff;
  State.regs[REG_MDRQ] = (temp & 0xffffffff00000000LL) >> 32;;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1001 0000 00Dn imm8....; udf00 imm8,Dn (imm8 is sign-extended.)
8.0xf9+4.0x,00,2.DN0+8.IMM8:D1:::mulq
"mulq"
*mn10300

*am33
*am33_2

{
  /* OP_F90000 (); */
  unsigned64 temp;
  int n, z;

  PC = cia;
  temp = ((signed64)(signed32)State.regs[REG_D0 + DN0]
          * (signed64)(signed32)EXTEND8 (IMM8));
  State.regs[REG_D0 + DN0] = temp & 0xffffffff;
  State.regs[REG_MDRQ] = (temp & 0xffffffff00000000LL) >> 32;;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1011 0000 00Dn imm16...; udf00 imm16,Dn (imm16 is sign-extended.)
8.0xfb+4.0x0,00,2.DN0+8.IMM16A+8.IMM16B:D2:::mulq
"mulq"
*mn10300

*am33
*am33_2

{
  /* OP_FB000000 (); */
  unsigned64 temp;
  int n, z;

  PC = cia;
  temp = ((signed64)(signed32)State.regs[REG_D0 + DN0]
          * (signed64)(signed32)EXTEND16 (FETCH16(IMM16A, IMM16B)));
  State.regs[REG_D0 + DN0] = temp & 0xffffffff;
  State.regs[REG_MDRQ] = (temp & 0xffffffff00000000LL) >> 32;;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1101 0000 00Dn imm32...; udf00 imm32,Dn
8.0xfd+4.0x0,00,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4:::mulq
"mulq"
*mn10300

*am33
*am33_2

{
  /* OP_FD000000 (); */
  unsigned64 temp;
  int n, z;

  PC = cia;
  temp = ((signed64)(signed32)State.regs[REG_D0 + DN0]
          * (signed64)(signed32)(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)));
  State.regs[REG_D0 + DN0] = temp & 0xffffffff;
  State.regs[REG_MDRQ] = (temp & 0xffffffff00000000LL) >> 32;;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 0110 0001 DmDn; udf01 Dm,Dn
8.0xf6+4.0x1,2.DM1,2.DN0:D0:::mulqu
"mulqu"
*mn10300

*am33
*am33_2

{
  /* OP_F610 (); */
  unsigned64 temp;
  int n, z;

  PC = cia;
  temp = ((unsigned64) State.regs[REG_D0 + DN0]
	  * (unsigned64) State.regs[REG_D0 + DM1]);
  State.regs[REG_D0 + DN0] = temp & 0xffffffff;
  State.regs[REG_MDRQ] = (temp & 0xffffffff00000000LL) >> 32;;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1001 0001 01Dn imm8....; udfu01 imm8,Dn (imm8 is zero-extended.)
8.0xf9+4.0x1,01,2.DN0+8.IMM8:D1:::mulqu
"mulqu"
*mn10300

*am33
*am33_2

{
  /* OP_F91400 (); */
  unsigned64 temp;
  int n, z;

  PC = cia;
  temp = ((unsigned64)State.regs[REG_D0 + DN0]
	  * (unsigned64)EXTEND8 (IMM8));
  State.regs[REG_D0 + DN0] = temp & 0xffffffff;
  State.regs[REG_MDRQ] = (temp & 0xffffffff00000000LL) >> 32;;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1011 0001 01Dn imm16...; udfu01 imm16,Dn (imm16 is zero-extended.)
8.0xfb+4.0x1,01,2.DN0+8.IMM16A+8.IMM16B:D2:::mulqu
"mulqu"
*mn10300

*am33
*am33_2

{
  /* OP_FB140000 (); */
  unsigned64 temp;
  int n, z;

  PC = cia;
  temp = ((unsigned64)State.regs[REG_D0 + DN0]
	  * (unsigned64) EXTEND16 (FETCH16(IMM16A, IMM16B)));
  State.regs[REG_D0 + DN0] = temp & 0xffffffff;
  State.regs[REG_MDRQ] = (temp & 0xffffffff00000000LL) >> 32;;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1101 0001 01Dn imm32...; udfu01 imm32,Dn
8.0xfd+4.0x1,01,2.DN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4:::mulqu
"mulqu"
*mn10300

*am33
*am33_2

{
  /* OP_FD140000 (); */
  unsigned64 temp;
  int n, z;

  PC = cia;
  temp = ((unsigned64)State.regs[REG_D0 + DN0]
          * (unsigned64)(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)));
  State.regs[REG_D0 + DN0] = temp & 0xffffffff;
  State.regs[REG_MDRQ] = (temp & 0xffffffff00000000LL) >> 32;;
  z = (State.regs[REG_D0 + DN0] == 0);
  n = (State.regs[REG_D0 + DN0] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 0110 0100 DmDn; udf04 Dm,Dn
8.0xf6+4.0x4,2.DM1,2.DN0:D0:::sat16
"sat16"
*mn10300

*am33
*am33_2

{
  /* OP_F640 (); */
  int temp;

  PC = cia;
  temp = State.regs[REG_D0 + DM1];
  temp = (temp > 0x7fff ? 0x7fff : temp);
  temp = (temp < -0x8000 ? -0x8000 : temp);
  State.regs[REG_D0 + DN0] = temp;
}


// 1111 0110 0101 DmDn; udf05 Dm,Dn
8.0xf6+4.0x5,2.DM1,2.DN0:D0:::sat24
"sat24"
*mn10300

*am33
*am33_2

{
  /* OP_F650 (); */
  int temp;

  PC = cia;
  temp = State.regs[REG_D0 + DM1];
  temp = (temp > 0x7fffff ? 0x7fffff : temp);
  temp = (temp < -0x800000 ? -0x800000 : temp);
  State.regs[REG_D0 + DN0] = temp;
}


// 1111 0110 0111 DmDn; udf07 Dm,Dn
8.0xf6+4.0x7,2.DM1,2.DN0:D0:::bsch
"bsch"
*mn10300

*am33
*am33_2

{
  /* OP_F670 (); */
  int temp, c;

  PC = cia;
  temp = State.regs[REG_D0 + DM1];
  temp <<= (State.regs[REG_D0 + DN0] & 0x1f);
  c = (temp != 0 ? 1 : 0);
  PSW &= ~(PSW_C);
  PSW |= (c ? PSW_C : 0);
}


// 1111 0000 1100 0000; syscall
8.0xf0+8.0xc0:D0:::syscall
"syscall"
*mn10300

*am33
*am33_2

{
  /* OP_F0C0 (); */
  PC = cia;
  do_syscall ();
}


// 1111 1111; break
8.0xff:S0:::break
"break"
*mn10300

*am33
*am33_2

{
  /* OP_FF (); */
  PC = cia;
  program_interrupt(SD, CPU, cia, SIM_SIGTRAP);
}

// 1100 1110 regs....; movm (SP),regs
8.0xce+8.REGS:S1:::movm
"movm"
*mn10300

*am33
*am33_2

{
  /* OP_CE00 (); */
  unsigned32 sp = State.regs[REG_SP];
  unsigned32 mask;

  PC = cia;
  mask = REGS;

  if (mask & 0x8)
    {
      sp += 4;
      State.regs[REG_LAR] = load_word (sp);
      sp += 4;
      State.regs[REG_LIR] = load_word (sp);
      sp += 4;
      State.regs[REG_MDR] = load_word (sp);
      sp += 4;
      State.regs[REG_A0 + 1] = load_word (sp);
      sp += 4;
      State.regs[REG_A0] = load_word (sp);
      sp += 4;
      State.regs[REG_D0 + 1] = load_word (sp);
      sp += 4;
      State.regs[REG_D0] = load_word (sp);
      sp += 4;
    }

  if (mask & 0x10)
    {
      State.regs[REG_A0 + 3] = load_word (sp);
      sp += 4;
    }

  if (mask & 0x20)
    {
      State.regs[REG_A0 + 2] = load_word (sp);
      sp += 4;
    }

  if (mask & 0x40)
    {
      State.regs[REG_D0 + 3] = load_word (sp);
      sp += 4;
    }

  if (mask & 0x80)
    {
      State.regs[REG_D0 + 2] = load_word (sp);
      sp += 4;
    }

  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33
      || STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2
      )
    {
      if (mask & 0x1)
	{
	  /* Need to restore MDRQ, MCRH, MCRL, and MCVF */
	  sp += 16;
	  State.regs[REG_E0 + 1] = load_word (sp);
	  sp += 4;
	  State.regs[REG_E0 + 0] = load_word (sp);
	  sp += 4;
	}

      if (mask & 0x2)
        {
	  State.regs[REG_E0 + 7] = load_word (sp);
	  sp += 4;
	  State.regs[REG_E0 + 6] = load_word (sp);
	  sp += 4;
	  State.regs[REG_E0 + 5] = load_word (sp);
	  sp += 4;
	  State.regs[REG_E0 + 4] = load_word (sp);
	  sp += 4;
	}

      if (mask & 0x4)
	{
	  State.regs[REG_E0 + 3] = load_word (sp);
	  sp += 4;
	  State.regs[REG_E0 + 2] = load_word (sp);
	  sp += 4;
	}
    }

  /* And make sure to update the stack pointer.  */
  State.regs[REG_SP] = sp;
}


// 1100 1111 regs....; movm regs,(SP)
8.0xcf+8.REGS:S1a:::movm
"movm"
*mn10300

*am33
*am33_2

{
  /* OP_CF00 (); */
  unsigned32 sp = State.regs[REG_SP];
  unsigned32 mask;

  PC = cia;
  mask = REGS;

  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33
      || STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2
      )
    {
      if (mask & 0x4)
	{
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 2]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 3]);
	}

      if (mask & 0x2)
        {
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 4]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 5]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 6]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 7]);
	}

      if (mask & 0x1)
	{
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 0]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 1]);
	  sp -= 16;
	  /* Need to save MDRQ, MCRH, MCRL, and MCVF */
	}
    }

  if (mask & 0x80)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_D0 + 2]);
    }

  if (mask & 0x40)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_D0 + 3]);
    }

  if (mask & 0x20)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_A0 + 2]);
    }

  if (mask & 0x10)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_A0 + 3]);
    }

  if (mask & 0x8)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_D0]);
      sp -= 4;
      store_word (sp, State.regs[REG_D0 + 1]);
      sp -= 4;
      store_word (sp, State.regs[REG_A0]);
      sp -= 4;
      store_word (sp, State.regs[REG_A0 + 1]);
      sp -= 4;
      store_word (sp, State.regs[REG_MDR]);
      sp -= 4;
      store_word (sp, State.regs[REG_LIR]);
      sp -= 4;
      store_word (sp, State.regs[REG_LAR]);
      sp -= 4;
    }

  /* And make sure to update the stack pointer.  */
  State.regs[REG_SP] = sp;
}

// 1100 1101 d16..... regs.... imm8....;
// call (d16,PC),regs,imm8 (d16 is sign-extended., imm8 is zero-extended.)
8.0xcd+8.D16A+8.D16B+8.REGS+8.IMM8:S4:::call
"call"
*mn10300

*am33
*am33_2

{
  /* OP_CD000000 (); */
  unsigned32 next_pc, sp;
  unsigned32 mask;

  PC = cia;
  sp = State.regs[REG_SP];
  next_pc = PC + 5;
  store_word(sp, next_pc);

  mask = REGS;

  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33
      || STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2
      )
    {
      if (mask & 0x4)
	{
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 2]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 3]);
	}

      if (mask & 0x2)
        {
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 4]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 5]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 6]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 7]);
	}

      if (mask & 0x1)
	{
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 0]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 1]);
	  sp -= 16;
	  /* Need to save MDRQ, MCRH, MCRL, and MCVF */
	}
    }

  if (mask & 0x80)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_D0 + 2]);
    }

  if (mask & 0x40)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_D0 + 3]);
    }

  if (mask & 0x20)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_A0 + 2]);
    }

  if (mask & 0x10)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_A0 + 3]);
    }

  if (mask & 0x8)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_D0]);
      sp -= 4;
      store_word (sp, State.regs[REG_D0 + 1]);
      sp -= 4;
      store_word (sp, State.regs[REG_A0]);
      sp -= 4;
      store_word (sp, State.regs[REG_A0 + 1]);
      sp -= 4;
      store_word (sp, State.regs[REG_MDR]);
      sp -= 4;
      store_word (sp, State.regs[REG_LIR]);
      sp -= 4;
      store_word (sp, State.regs[REG_LAR]);
      sp -= 4;
    }

  /* Update the stack pointer, note that the register saves to do not
     modify SP.  The SP adjustment is derived totally from the imm8
     field.  */
  State.regs[REG_SP] -= IMM8;
  State.regs[REG_MDR] = next_pc;
  State.regs[REG_PC] += EXTEND16 (FETCH16(D16A, D16B));
  nia = PC;
}


// 1101 1101 d32..... regs.... imm8....;
// call (d32,PC),regs,imm8 (imm8 is zero-extended.)
8.0xdd+8.D32A+8.D32B+8.D32C+8.D32D+8.REGS+8.IMM8:S6:::call
"call"
*mn10300

*am33
*am33_2

{
  /* OP_DD000000 (); */
  unsigned32 next_pc, sp;
  unsigned32 mask;

  PC = cia;
  sp = State.regs[REG_SP];
  next_pc = State.regs[REG_PC] + 7;
  /* could assert that nia == next_pc here */
  store_word(sp, next_pc);

  mask = REGS;

  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33
      || STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2
      )
    {
      if (mask & 0x4)
	{
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 2]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 3]);
	}

      if (mask & 0x2)
        {
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 4]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 5]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 6]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 7]);
	}

      if (mask & 0x1)
	{
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 0]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 1]);
	  sp -= 16;
	  /* Need to save MDRQ, MCRH, MCRL, and MCVF */
	}
    }

  if (mask & 0x80)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_D0 + 2]);
    }

  if (mask & 0x40)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_D0 + 3]);
    }

  if (mask & 0x20)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_A0 + 2]);
    }

  if (mask & 0x10)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_A0 + 3]);
    }

  if (mask & 0x8)
    {
      sp -= 4;
      store_word (sp, State.regs[REG_D0]);
      sp -= 4;
      store_word (sp, State.regs[REG_D0 + 1]);
      sp -= 4;
      store_word (sp, State.regs[REG_A0]);
      sp -= 4;
      store_word (sp, State.regs[REG_A0 + 1]);
      sp -= 4;
      store_word (sp, State.regs[REG_MDR]);
      sp -= 4;
      store_word (sp, State.regs[REG_LIR]);
      sp -= 4;
      store_word (sp, State.regs[REG_LAR]);
      sp -= 4;
    }

  /* Update the stack pointer, note that the register saves to do not
     modify SP.  The SP adjustment is derived totally from the imm8
     field.  */
  State.regs[REG_SP] -= IMM8;
  State.regs[REG_MDR] = next_pc;
  State.regs[REG_PC] += FETCH32(D32A, D32B, D32C, D32D);
  nia = PC;
}


// 1101 1111 regs.... imm8....; ret regs,imm8 (imm8 is zero-extended.)
8.0xdf+8.REGS+8.IMM8:S2:::ret
"ret"
*mn10300

*am33
*am33_2

{
  /* OP_DF0000 (); */
  unsigned32 sp, offset;
  unsigned32 mask;

  PC = cia;
  State.regs[REG_SP] += IMM8;
  sp = State.regs[REG_SP];

  offset = -4;
  mask = REGS;

  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33
      || STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2
      )
    {

      if (mask & 0x4)
	{
	  State.regs[REG_E0 + 2] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 3] = load_word (sp + offset);
	  offset -= 4;
	}

      if (mask & 0x2)
        {
	  State.regs[REG_E0 + 4] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 5] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 6] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 7] = load_word (sp + offset);
	  offset -= 4;
	}

      if (mask & 0x1)
	{
	  /* Need to restore MDRQ, MCRH, MCRL, and MCVF */
	  offset -= 16;
	  State.regs[REG_E0 + 0] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 1] = load_word (sp + offset);
	  offset -= 4;
	}

    }

  if (mask & 0x80)
    {
      State.regs[REG_D0 + 2] = load_word (sp + offset);
      offset -= 4;
    }

  if (mask & 0x40)
    {
      State.regs[REG_D0 + 3] = load_word (sp + offset);
      offset -= 4;
    }

  if (mask & 0x20)
    {
      State.regs[REG_A0 + 2] = load_word (sp + offset);
      offset -= 4;
    }

  if (mask & 0x10)
    {
      State.regs[REG_A0 + 3] = load_word (sp + offset);
      offset -= 4;
    }

  if (mask & 0x8)
    {
      State.regs[REG_D0] = load_word (sp + offset);
      offset -= 4;
      State.regs[REG_D0 + 1] = load_word (sp + offset);
      offset -= 4;
      State.regs[REG_A0] = load_word (sp + offset);
      offset -= 4;
      State.regs[REG_A0 + 1] = load_word (sp + offset);
      offset -= 4;
      State.regs[REG_MDR] = load_word (sp + offset);
      offset -= 4;
      State.regs[REG_LIR] = load_word (sp + offset);
      offset -= 4;
      State.regs[REG_LAR] = load_word (sp + offset);
      offset -= 4;
    }

  /* Restore the PC value.  */
  State.regs[REG_PC] = load_word(sp);
  nia = PC;
}


// 1101 1110 regs.... imm8....; retf regs,imm8 (imm8 is zero-extended.)
8.0xde+8.REGS+8.IMM8:S2:::retf
"retf"
*mn10300

*am33
*am33_2

{
  /* OP_DE0000 (); */
  unsigned32 sp, offset;
  unsigned32 mask;

  PC = cia;
  State.regs[REG_SP] += IMM8;
  sp = State.regs[REG_SP];
  State.regs[REG_PC] = State.regs[REG_MDR];

  offset = -4;
  mask = REGS;

  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33
      || STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2
      )
    {

      if (mask & 0x4)
	{
	  State.regs[REG_E0 + 2] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 3] = load_word (sp + offset);
	  offset -= 4;
	}

      if (mask & 0x2)
        {
	  State.regs[REG_E0 + 4] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 5] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 6] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 7] = load_word (sp + offset);
	  offset -= 4;
	}

      if (mask & 0x1)
	{
	  /* Need to restore MDRQ, MCRH, MCRL, and MCVF */
	  offset -= 16;
	  State.regs[REG_E0 + 0] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 1] = load_word (sp + offset);
	  offset -= 4;
	}

    }

  if (mask & 0x80)
    {
      State.regs[REG_D0 + 2] = load_word (sp + offset);
      offset -= 4;
    }

  if (mask & 0x40)
    {
      State.regs[REG_D0 + 3] = load_word (sp + offset);
      offset -= 4;
    }

  if (mask & 0x20)
    {
      State.regs[REG_A0 + 2] = load_word (sp + offset);
      offset -= 4;
    }

  if (mask & 0x10)
    {
      State.regs[REG_A0 + 3] = load_word (sp + offset);
      offset -= 4;
    }

  if (mask & 0x8)
    {
      State.regs[REG_D0] = load_word (sp + offset);
      offset -= 4;
      State.regs[REG_D0 + 1] = load_word (sp + offset);
      offset -= 4;
      State.regs[REG_A0] = load_word (sp + offset);
      offset -= 4;
      State.regs[REG_A0 + 1] = load_word (sp + offset);
      offset -= 4;
      State.regs[REG_MDR] = load_word (sp + offset);
      offset -= 4;
      State.regs[REG_LIR] = load_word (sp + offset);
      offset -= 4;
      State.regs[REG_LAR] = load_word (sp + offset);
      offset -= 4;
    }
  nia = PC;
}


:include::am33:am33.igen

@


1.4
log
@* mn10300.igen: Doc fixes.
@
text
@d7 1
d21 1
d34 1
d47 1
d60 1
d73 1
d86 1
d99 1
d112 1
d125 1
d138 1
d151 1
d164 1
d177 1
d190 1
d204 1
d218 1
d233 1
d246 1
d260 1
d274 1
d288 1
d300 1
d313 1
d326 1
d340 1
d355 1
d370 1
d384 1
d398 1
d413 1
d428 1
d441 1
d455 1
d469 1
d482 1
d496 1
d510 1
d525 1
d538 1
d552 1
d566 1
d580 1
d593 1
d607 1
d620 1
d634 1
d648 1
d664 1
d679 1
d695 1
d711 1
d727 1
d743 1
d759 1
d775 1
d793 1
d811 1
d829 1
d844 1
d860 1
d876 1
d893 1
d910 1
d926 1
d943 1
d960 1
d977 1
d992 1
d1008 1
d1023 1
d1039 1
d1055 1
d1072 1
d1087 1
d1103 1
d1119 1
d1135 1
d1151 1
d1167 1
d1183 1
d1199 1
d1216 1
d1233 1
d1249 1
d1265 1
d1281 1
d1297 1
d1312 1
d1328 1
d1344 1
d1360 1
d1376 1
d1393 1
d1409 1
d1425 1
d1441 1
d1457 1
d1472 1
d1488 1
d1506 1
d1521 1
d1536 1
d1551 1
d1566 1
d1584 1
d1598 1
d1613 1
d1628 1
d1643 1
d1658 1
d1673 1
d1688 1
d1703 1
d1718 1
d1733 1
d1752 1
d1771 1
d1790 1
d1821 1
d1835 1
d1850 1
d1865 1
d1880 1
d1895 1
d1910 1
d1941 1
d1966 1
d1991 1
d2029 1
d2066 1
d2084 1
d2099 1
d2114 1
d2129 1
d2144 1
d2159 1
d2174 1
d2190 1
d2205 1
d2221 1
d2237 1
d2253 1
d2269 1
d2290 1
d2311 1
d2332 1
d2354 1
d2370 1
d2385 1
d2400 1
d2415 1
d2430 1
d2445 1
d2460 1
d2475 1
d2490 1
d2511 1
d2526 1
d2541 1
d2557 1
d2574 1
d2590 1
d2614 1
d2638 1
d2661 1
d2685 1
d2709 1
d2732 1
d2757 1
d2782 1
d2805 1
d2827 1
d2849 1
d2870 1
d2891 1
d2918 1
d2945 1
d2964 1
d2983 1
d3003 1
d3022 1
d3042 1
d3061 1
d3080 1
d3099 1
d3118 1
d3137 1
d3156 1
d3175 1
d3194 1
d3213 1
d3229 1
d3248 1
d3267 1
d3287 1
d3306 1
d3326 1
d3345 1
d3364 1
d3383 1
d3402 1
d3421 1
d3437 1
d3453 1
d3468 1
d3483 1
d3498 1
d3520 1
d3542 1
d3564 1
d3582 1
d3602 1
d3622 1
d3637 1
d3662 1
d3684 1
d3709 1
d3734 1
d3759 1
d3784 1
d3809 1
d3834 1
d3859 1
d3884 1
d3904 1
d3924 1
d3945 1
d3960 1
d3974 1
d4028 1
d4073 1
d4084 1
d4172 1
d4187 1
d4281 1
d4297 1
d4390 1
d4405 1
d4495 1
d4511 1
@


1.4.70.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a6 1
:model:::am33_2:am33_2:
a19 1
*am33_2
a31 1
*am33_2
a43 1
*am33_2
a55 1
*am33_2
a67 1
*am33_2
a79 1
*am33_2
a91 1
*am33_2
a103 1
*am33_2
a115 1
*am33_2
a127 1
*am33_2
a139 1
*am33_2
a151 1
*am33_2
a163 1
*am33_2
a175 1
*am33_2
a188 1
*am33_2
a201 1
*am33_2
a215 1
*am33_2
a227 1
*am33_2
a240 1
*am33_2
a253 1
*am33_2
a266 1
*am33_2
a277 1
*am33_2
a289 1
*am33_2
a301 1
*am33_2
a314 1
*am33_2
a328 1
*am33_2
a342 1
*am33_2
a355 1
*am33_2
a368 1
*am33_2
a382 1
*am33_2
a396 1
*am33_2
a408 1
*am33_2
a421 1
*am33_2
a434 1
*am33_2
a446 1
*am33_2
a459 1
*am33_2
a472 1
*am33_2
a486 1
*am33_2
a498 1
*am33_2
a511 1
*am33_2
a524 1
*am33_2
a537 1
*am33_2
a549 1
*am33_2
a562 1
*am33_2
a574 1
*am33_2
a587 1
*am33_2
a600 1
*am33_2
a615 1
*am33_2
a629 1
*am33_2
a644 1
*am33_2
a659 1
*am33_2
a674 1
*am33_2
a689 1
*am33_2
a704 1
*am33_2
a719 1
*am33_2
a736 1
*am33_2
a753 1
*am33_2
a770 1
*am33_2
a784 1
*am33_2
a799 1
*am33_2
a814 1
*am33_2
a830 1
*am33_2
a846 1
*am33_2
a861 1
*am33_2
a877 1
*am33_2
a893 1
*am33_2
a909 1
*am33_2
a923 1
*am33_2
a938 1
*am33_2
a952 1
*am33_2
a967 1
*am33_2
a982 1
*am33_2
a998 1
*am33_2
a1012 1
*am33_2
a1027 1
*am33_2
a1042 1
*am33_2
a1057 1
*am33_2
a1072 1
*am33_2
a1087 1
*am33_2
a1102 1
*am33_2
a1117 1
*am33_2
a1133 1
*am33_2
a1149 1
*am33_2
a1164 1
*am33_2
a1179 1
*am33_2
a1194 1
*am33_2
a1209 1
*am33_2
a1223 1
*am33_2
a1238 1
*am33_2
a1253 1
*am33_2
a1268 1
*am33_2
a1283 1
*am33_2
a1299 1
*am33_2
a1314 1
*am33_2
a1329 1
*am33_2
a1344 1
*am33_2
a1359 1
*am33_2
a1373 1
*am33_2
a1388 1
*am33_2
a1405 1
*am33_2
a1419 1
*am33_2
a1433 1
*am33_2
a1447 1
*am33_2
a1461 1
*am33_2
a1478 1
*am33_2
a1491 1
*am33_2
a1505 1
*am33_2
a1519 1
*am33_2
a1533 1
*am33_2
a1547 1
*am33_2
a1561 1
*am33_2
a1575 1
*am33_2
a1589 1
*am33_2
a1603 1
*am33_2
a1617 1
*am33_2
a1635 1
*am33_2
a1653 1
*am33_2
a1671 1
*am33_2
a1701 1
*am33_2
a1714 1
*am33_2
a1728 1
*am33_2
a1742 1
*am33_2
a1756 1
*am33_2
a1770 1
*am33_2
a1784 1
*am33_2
a1814 1
*am33_2
a1838 1
*am33_2
a1862 1
*am33_2
a1899 1
*am33_2
a1935 1
*am33_2
a1952 1
*am33_2
a1966 1
*am33_2
a1980 1
*am33_2
a1994 1
*am33_2
a2008 1
*am33_2
a2022 1
*am33_2
a2036 1
*am33_2
a2051 1
*am33_2
a2065 1
*am33_2
a2080 1
*am33_2
a2095 1
*am33_2
a2110 1
*am33_2
a2125 1
*am33_2
a2145 1
*am33_2
a2165 1
*am33_2
a2185 1
*am33_2
a2206 1
*am33_2
a2221 1
*am33_2
a2235 1
*am33_2
a2249 1
*am33_2
a2263 1
*am33_2
a2277 1
*am33_2
a2291 1
*am33_2
a2305 1
*am33_2
a2319 1
*am33_2
a2333 1
*am33_2
a2353 1
*am33_2
a2367 1
*am33_2
a2381 1
*am33_2
a2396 1
*am33_2
a2412 1
*am33_2
a2427 1
*am33_2
a2450 1
*am33_2
a2473 1
*am33_2
a2495 1
*am33_2
a2518 1
*am33_2
a2541 1
*am33_2
a2563 1
*am33_2
a2587 1
*am33_2
a2611 1
*am33_2
a2633 1
*am33_2
a2654 1
*am33_2
a2675 1
*am33_2
a2695 1
*am33_2
a2715 1
*am33_2
a2741 1
*am33_2
a2767 1
*am33_2
a2785 1
*am33_2
a2803 1
*am33_2
a2822 1
*am33_2
a2840 1
*am33_2
a2859 1
*am33_2
a2877 1
*am33_2
a2895 1
*am33_2
a2913 1
*am33_2
a2931 1
*am33_2
a2949 1
*am33_2
a2967 1
*am33_2
a2985 1
*am33_2
a3003 1
*am33_2
a3021 1
*am33_2
a3036 1
*am33_2
a3054 1
*am33_2
a3072 1
*am33_2
a3091 1
*am33_2
a3109 1
*am33_2
a3128 1
*am33_2
a3146 1
*am33_2
a3164 1
*am33_2
a3182 1
*am33_2
a3200 1
*am33_2
a3218 1
*am33_2
a3233 1
*am33_2
a3248 1
*am33_2
a3262 1
*am33_2
a3276 1
*am33_2
a3290 1
*am33_2
a3311 1
*am33_2
a3332 1
*am33_2
a3353 1
*am33_2
a3370 1
*am33_2
a3389 1
*am33_2
a3408 1
*am33_2
a3422 1
*am33_2
a3446 1
*am33_2
a3467 1
*am33_2
a3491 1
*am33_2
a3515 1
*am33_2
a3539 1
*am33_2
a3563 1
*am33_2
a3587 1
*am33_2
a3611 1
*am33_2
a3635 1
*am33_2
a3659 1
*am33_2
a3678 1
*am33_2
a3697 1
*am33_2
a3717 1
*am33_2
a3731 1
*am33_2
a3744 1
*am33_2
a3797 1
      || STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2
a3841 1
*am33_2
a3851 1
      || STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2
a3938 1
*am33_2
a3952 1
      || STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2
a4045 1
*am33_2
a4060 1
      || STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2
a4152 1
*am33_2
a4166 1
      || STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2
a4255 1
*am33_2
a4270 1
      || STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2
@


1.3
log
@minor formatting tweaks to aid syncronisation
@
text
@d3802 1
a3802 1
	  /* Need to restore MDQR, MCRH, MCRL, and MCVF */
d3881 1
a3881 1
	  /* Need to save MDQR, MCRH, MCRL, and MCVF */
d3982 1
a3982 1
	  /* Need to save MDQR, MCRH, MCRL, and MCVF */
d4090 1
a4090 1
	  /* Need to save MDQR, MCRH, MCRL, and MCVF */
d4192 1
a4192 1
	  /* Need to restore MDQR, MCRH, MCRL, and MCVF */
d4296 1
a4296 1
	  /* Need to restore MDQR, MCRH, MCRL, and MCVF */
@


1.2
log
@* mn10300_sim.h (genericAdd, genericSub, genericCmp, genericOr,
genericXor, genericBtst): Use `unsigned32'.
* op_utils.c: Likewise.
* mn10300.igen, am33.igen: Use `unsigned32', `signed32',
`unsigned64' or `signed64' where type width is relevant.
@
text
@d3797 2
a3798 1
  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33)
d3851 2
a3852 1
  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33)
d3952 2
a3953 1
  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33)
d4060 2
a4061 1
  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33)
d4166 2
a4167 1
  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33)
d4270 2
a4271 1
  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33)
@


1.1
log
@Initial revision
@
text
@d6 1
d19 1
d31 1
d43 1
d55 1
d67 1
d79 1
d91 1
d103 1
d115 1
d127 1
d139 1
d151 1
d163 1
d175 1
d188 1
d201 1
d215 1
d227 1
d240 1
d253 1
d266 1
d277 1
d289 1
d301 1
d314 1
d328 1
d342 1
d355 1
d368 1
d382 1
d396 1
d408 1
d421 1
d434 1
d446 1
d459 1
d472 1
d486 1
d498 1
d511 1
d524 1
d537 1
d549 1
d562 1
d574 1
d587 1
d600 1
d614 3
d628 3
d643 3
d658 3
d673 3
d688 3
d703 3
d718 3
d723 1
a723 1
  unsigned long value;
d735 3
d740 1
a740 1
  unsigned long value;
d752 3
d757 1
a757 1
  unsigned long value;
d769 3
d783 3
d798 3
d813 3
d829 3
d845 3
d860 3
d876 3
d892 3
d908 3
d922 3
d937 3
d951 3
d966 3
d981 3
d997 3
d1011 3
d1026 3
d1041 3
d1056 3
d1071 3
d1086 3
d1101 3
d1116 3
d1132 3
d1148 3
d1163 3
d1178 3
d1193 3
d1208 3
d1222 3
d1237 3
d1252 3
d1267 3
d1282 3
d1298 3
d1313 3
d1328 3
d1343 3
d1358 3
d1372 3
d1387 3
d1404 3
d1418 3
d1432 3
d1446 3
d1460 3
d1477 3
d1490 3
d1504 3
d1518 3
d1532 3
d1546 3
d1560 3
d1574 3
d1588 3
d1602 3
d1616 3
d1621 1
a1621 1
  unsigned long imm;
d1634 3
d1639 1
a1639 1
  unsigned long imm;
d1652 3
d1657 1
a1657 1
  unsigned long imm;
d1670 3
d1676 1
a1676 1
  unsigned long reg1, reg2, sum;
d1700 3
d1713 3
d1727 3
d1741 3
d1755 3
d1769 3
d1783 3
d1789 1
a1789 1
  unsigned long reg1, reg2, difference;
d1813 3
d1818 1
a1818 1
  unsigned long long temp;
d1837 3
d1842 1
a1842 1
  unsigned long long temp;
d1861 3
d1898 3
d1934 3
d1939 1
a1939 1
  unsigned int imm;
d1951 3
d1965 3
d1979 3
d1993 3
d2007 3
d2021 3
d2035 3
d2050 3
d2064 3
d2079 3
d2094 3
d2109 3
d2124 3
d2144 3
d2164 3
d2184 3
d2205 3
d2220 3
d2234 3
d2248 3
d2262 3
d2276 3
d2290 3
d2304 3
d2318 3
d2332 3
d2352 3
d2366 3
d2380 3
d2395 3
d2411 3
d2426 3
d2431 1
a2431 1
  unsigned long temp;
d2449 3
d2454 1
a2454 1
  unsigned long temp;
d2472 3
d2477 1
a2477 1
  unsigned long temp;
d2494 3
d2499 1
a2499 1
  unsigned long temp;
d2517 3
d2522 1
a2522 1
  unsigned long temp;
d2540 3
d2545 1
a2545 1
  unsigned long temp;
d2562 3
d2567 1
a2567 1
  long temp;
d2586 3
d2591 1
a2591 1
  long temp;
d2610 3
d2632 3
d2653 3
d2674 3
d2694 3
d2714 3
d2719 1
a2719 1
  unsigned long value;
d2740 3
d2745 1
a2745 1
  unsigned long value;
d2766 3
d2784 3
d2802 3
d2821 3
d2839 3
d2858 3
d2876 3
d2894 3
d2912 3
d2930 3
d2948 3
d2966 3
d2984 3
d3002 3
d3020 3
d3035 3
d3053 3
d3071 3
d3090 3
d3108 3
d3127 3
d3145 3
d3163 3
d3181 3
d3199 3
d3217 3
d3232 3
d3247 3
d3261 3
d3275 3
d3289 3
d3294 1
a3294 1
  unsigned int next_pc, sp;
d3310 3
d3315 1
a3315 1
  unsigned int next_pc, sp;
d3331 3
d3336 1
a3336 1
  unsigned int next_pc, sp;
d3352 3
d3357 1
a3357 1
  unsigned int sp;
d3369 3
d3374 1
a3374 1
  unsigned int sp;
d3388 3
d3393 1
a3393 1
  unsigned int sp, next_pc;
d3407 3
d3421 3
d3445 3
d3466 3
d3471 1
a3471 1
  unsigned long long temp;
d3490 3
d3495 1
a3495 1
  unsigned long long temp;
d3514 3
d3519 1
a3519 1
  unsigned long long temp;
d3538 3
d3543 1
a3543 1
  unsigned long long temp;
d3562 3
d3567 1
a3567 1
  unsigned long long temp;
d3586 3
d3591 1
a3591 1
  unsigned long long temp;
d3610 3
d3615 1
a3615 1
  unsigned long long temp;
d3634 3
d3639 1
a3639 1
  unsigned long long temp;
d3658 3
d3677 3
d3696 3
d3716 3
d3730 3
d3743 3
d3748 2
a3749 2
  unsigned long sp = State.regs[REG_SP];
  unsigned long mask;
d3797 32
d3839 3
d3844 2
a3845 2
  unsigned long sp = State.regs[REG_SP];
  unsigned long mask;
d3850 32
d3935 3
d3940 2
a3941 2
  unsigned int next_pc, sp;
  unsigned long mask;
d3950 32
d4041 3
d4046 2
a4047 2
  unsigned int next_pc, sp;
  unsigned long mask;
d4057 32
d4147 3
d4152 2
a4153 2
  unsigned int sp, offset;
  unsigned long mask;
d4162 34
d4249 3
d4254 2
a4255 2
  unsigned int sp, offset;
  unsigned long mask;
d4260 1
a4260 1
  State.regs[REG_PC] = State.regs[REG_MDR] - 3;
d4265 34
d4341 1
d4343 3
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d3489 1
a3489 1
  State.regs[REG_PC] = State.regs[REG_MDR];
a3535 1
  nia = PC;
@


1.1.1.3
log
@import gdb-1999-12-06 snapshot
@
text
@a5 1
:model:::am33:am33:
a17 1
*am33
a28 1
*am33
a39 1
*am33
a50 1
*am33
a61 1
*am33
a72 1
*am33
a83 1
*am33
a94 1
*am33
a105 1
*am33
a116 1
*am33
a127 1
*am33
a138 1
*am33
a149 1
*am33
a160 1
*am33
a172 1
*am33
a184 1
*am33
a197 1
*am33
a208 1
*am33
a220 1
*am33
a232 1
*am33
a244 1
*am33
a254 1
*am33
a265 1
*am33
a276 1
*am33
a288 1
*am33
a301 1
*am33
a314 1
*am33
a326 1
*am33
a338 1
*am33
a351 1
*am33
a364 1
*am33
a375 1
*am33
a387 1
*am33
a399 1
*am33
a410 1
*am33
a422 1
*am33
a434 1
*am33
a447 1
*am33
a458 1
*am33
a470 1
*am33
a482 1
*am33
a494 1
*am33
a505 1
*am33
a517 1
*am33
a528 1
*am33
a540 1
*am33
a552 1
*am33
a565 3

*am33

a576 3

*am33

a588 3

*am33

a600 3

*am33

a612 3

*am33

a624 3

*am33

a636 3

*am33

a648 3

*am33

a662 3

*am33

a676 3

*am33

a690 3

*am33

a701 3

*am33

a713 3

*am33

a725 3

*am33

a738 3

*am33

a751 3

*am33

a763 3

*am33

a776 3

*am33

a789 3

*am33

a802 3

*am33

a813 3

*am33

a825 3

*am33

a836 3

*am33

a848 3

*am33

a860 3

*am33

a873 3

*am33

a884 3

*am33

a896 3

*am33

a908 3

*am33

a920 3

*am33

a932 3

*am33

a944 3

*am33

a956 3

*am33

a968 3

*am33

a981 3

*am33

a994 3

*am33

a1006 3

*am33

a1018 3

*am33

a1030 3

*am33

a1042 3

*am33

a1053 3

*am33

a1065 3

*am33

a1077 3

*am33

a1089 3

*am33

a1101 3

*am33

a1114 3

*am33

a1126 3

*am33

a1138 3

*am33

a1150 3

*am33

a1162 3

*am33

a1173 3

*am33

a1185 3

*am33

a1199 3

*am33

a1210 3

*am33

a1221 3

*am33

a1232 3

*am33

a1243 3

*am33

a1257 3

*am33

a1267 3

*am33

a1278 3

*am33

a1289 3

*am33

a1300 3

*am33

a1311 3

*am33

a1322 3

*am33

a1333 3

*am33

a1344 3

*am33

a1355 3

*am33

a1366 3

*am33

a1381 3

*am33

a1396 3

*am33

a1411 3

*am33

a1438 3

*am33

a1448 3

*am33

a1459 3

*am33

a1470 3

*am33

a1481 3

*am33

a1492 3

*am33

a1503 3

*am33

a1530 3

*am33

a1551 3

*am33

a1572 3

*am33

a1606 3

*am33

a1639 3

*am33

a1653 3

*am33

a1664 3

*am33

a1675 3

*am33

a1686 3

*am33

a1697 3

*am33

a1708 3

*am33

a1719 3

*am33

a1731 3

*am33

a1742 3

*am33

a1754 3

*am33

a1766 3

*am33

a1778 3

*am33

a1790 3

*am33

a1807 3

*am33

a1824 3

*am33

a1841 3

*am33

a1859 3

*am33

a1871 3

*am33

a1882 3

*am33

a1893 3

*am33

a1904 3

*am33

a1915 3

*am33

a1926 3

*am33

a1937 3

*am33

a1948 3

*am33

a1959 3

*am33

a1976 3

*am33

a1987 3

*am33

a1998 3

*am33

a2010 3

*am33

a2023 3

*am33

a2035 3

*am33

a2055 3

*am33

a2075 3

*am33

a2094 3

*am33

a2114 3

*am33

a2134 3

*am33

a2153 3

*am33

a2174 3

*am33

a2195 3

*am33

a2214 3

*am33

a2232 3

*am33

a2250 3

*am33

a2267 3

*am33

a2284 3

*am33

a2307 3

*am33

a2330 3

*am33

a2345 3

*am33

a2360 3

*am33

a2376 3

*am33

a2391 3

*am33

a2407 3

*am33

a2422 3

*am33

a2437 3

*am33

a2452 3

*am33

a2467 3

*am33

a2482 3

*am33

a2497 3

*am33

a2512 3

*am33

a2527 3

*am33

a2542 3

*am33

a2554 3

*am33

a2569 3

*am33

a2584 3

*am33

a2600 3

*am33

a2615 3

*am33

a2631 3

*am33

a2646 3

*am33

a2661 3

*am33

a2676 3

*am33

a2691 3

*am33

a2706 3

*am33

a2718 3

*am33

a2730 3

*am33

a2741 3

*am33

a2752 3

*am33

a2763 3

*am33

a2781 3

*am33

a2799 3

*am33

a2817 3

*am33

a2831 3

*am33

a2847 3

*am33

a2863 3

*am33

a2874 3

*am33

a2895 3

*am33

a2913 3

*am33

a2934 3

*am33

a2955 3

*am33

a2976 3

*am33

a2997 3

*am33

a3018 3

*am33

a3039 3

*am33

a3060 3

*am33

a3081 3

*am33

a3097 3

*am33

a3113 3

*am33

a3130 3

*am33

a3141 3

*am33

a3151 3

*am33

a3202 32
  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33)
    {
      if (mask & 0x1)
	{
	  /* Need to restore MDQR, MCRH, MCRL, and MCVF */
	  sp += 16;
	  State.regs[REG_E0 + 1] = load_word (sp);
	  sp += 4;
	  State.regs[REG_E0 + 0] = load_word (sp);
	  sp += 4;
	}

      if (mask & 0x2)
        {
	  State.regs[REG_E0 + 7] = load_word (sp);
	  sp += 4;
	  State.regs[REG_E0 + 6] = load_word (sp);
	  sp += 4;
	  State.regs[REG_E0 + 5] = load_word (sp);
	  sp += 4;
	  State.regs[REG_E0 + 4] = load_word (sp);
	  sp += 4;
	}

      if (mask & 0x4)
	{
	  State.regs[REG_E0 + 3] = load_word (sp);
	  sp += 4;
	  State.regs[REG_E0 + 2] = load_word (sp);
	  sp += 4;
	}
    }
a3212 3

*am33

a3220 32
  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33)
    {
      if (mask & 0x4)
	{
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 2]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 3]);
	}

      if (mask & 0x2)
        {
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 4]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 5]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 6]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 7]);
	}

      if (mask & 0x1)
	{
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 0]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 1]);
	  sp -= 16;
	  /* Need to save MDQR, MCRH, MCRL, and MCVF */
	}
    }
a3273 3

*am33

a3285 32
  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33)
    {
      if (mask & 0x4)
	{
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 2]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 3]);
	}

      if (mask & 0x2)
        {
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 4]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 5]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 6]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 7]);
	}

      if (mask & 0x1)
	{
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 0]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 1]);
	  sp -= 16;
	  /* Need to save MDQR, MCRH, MCRL, and MCVF */
	}
    }
a3344 3

*am33

a3357 32
  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33)
    {
      if (mask & 0x4)
	{
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 2]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 3]);
	}

      if (mask & 0x2)
        {
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 4]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 5]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 6]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 7]);
	}

      if (mask & 0x1)
	{
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 0]);
	  sp -= 4;
	  store_word (sp, State.regs[REG_E0 + 1]);
	  sp -= 16;
	  /* Need to save MDQR, MCRH, MCRL, and MCVF */
	}
    }
a3415 3

*am33

a3427 34
  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33)
    {

      if (mask & 0x4)
	{
	  State.regs[REG_E0 + 2] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 3] = load_word (sp + offset);
	  offset -= 4;
	}

      if (mask & 0x2)
        {
	  State.regs[REG_E0 + 4] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 5] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 6] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 7] = load_word (sp + offset);
	  offset -= 4;
	}

      if (mask & 0x1)
	{
	  /* Need to restore MDQR, MCRH, MCRL, and MCVF */
	  offset -= 16;
	  State.regs[REG_E0 + 0] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 1] = load_word (sp + offset);
	  offset -= 4;
	}

    }
a3480 3

*am33

a3493 34
  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33)
    {

      if (mask & 0x4)
	{
	  State.regs[REG_E0 + 2] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 3] = load_word (sp + offset);
	  offset -= 4;
	}

      if (mask & 0x2)
        {
	  State.regs[REG_E0 + 4] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 5] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 6] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 7] = load_word (sp + offset);
	  offset -= 4;
	}

      if (mask & 0x1)
	{
	  /* Need to restore MDQR, MCRH, MCRL, and MCVF */
	  offset -= 16;
	  State.regs[REG_E0 + 0] = load_word (sp + offset);
	  offset -= 4;
	  State.regs[REG_E0 + 1] = load_word (sp + offset);
	  offset -= 4;
	}

    }
a3537 3


:include::am33:am33.igen
@


