head	1.10;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.10
	gdb_7_6-2013-04-26-release:1.10
	gdb_7_6-branch:1.10.0.6
	gdb_7_6-2013-03-12-branchpoint:1.10
	gdb_7_5_1-2012-11-29-release:1.10
	gdb_7_5-2012-08-17-release:1.10
	gdb_7_5-branch:1.10.0.4
	gdb_7_5-2012-07-18-branchpoint:1.10
	gdb_7_4_1-2012-04-26-release:1.10
	gdb_7_4-2012-01-24-release:1.10
	gdb_7_4-branch:1.10.0.2
	gdb_7_4-2011-12-13-branchpoint:1.10
	gdb_7_3_1-2011-09-04-release:1.9
	gdb_7_3-2011-07-26-release:1.9
	gdb_7_3-branch:1.9.0.66
	gdb_7_3-2011-04-01-branchpoint:1.9
	gdb_7_2-2010-09-02-release:1.9
	gdb_7_2-branch:1.9.0.64
	gdb_7_2-2010-07-07-branchpoint:1.9
	gdb_7_1-2010-03-18-release:1.9
	gdb_7_1-branch:1.9.0.62
	gdb_7_1-2010-02-18-branchpoint:1.9
	gdb_7_0_1-2009-12-22-release:1.9
	gdb_7_0-2009-10-06-release:1.9
	gdb_7_0-branch:1.9.0.60
	gdb_7_0-2009-09-16-branchpoint:1.9
	arc-sim-20090309:1.9
	msnyder-checkpoint-072509-branch:1.9.0.58
	msnyder-checkpoint-072509-branchpoint:1.9
	arc-insight_6_8-branch:1.9.0.56
	arc-insight_6_8-branchpoint:1.9
	insight_6_8-branch:1.9.0.54
	insight_6_8-branchpoint:1.9
	reverse-20081226-branch:1.9.0.52
	reverse-20081226-branchpoint:1.9
	multiprocess-20081120-branch:1.9.0.50
	multiprocess-20081120-branchpoint:1.9
	reverse-20080930-branch:1.9.0.48
	reverse-20080930-branchpoint:1.9
	reverse-20080717-branch:1.9.0.46
	reverse-20080717-branchpoint:1.9
	msnyder-reverse-20080609-branch:1.9.0.44
	msnyder-reverse-20080609-branchpoint:1.9
	drow-reverse-20070409-branch:1.9.0.42
	drow-reverse-20070409-branchpoint:1.9
	gdb_6_8-2008-03-27-release:1.9
	gdb_6_8-branch:1.9.0.40
	gdb_6_8-2008-02-26-branchpoint:1.9
	gdb_6_7_1-2007-10-29-release:1.9
	gdb_6_7-2007-10-10-release:1.9
	gdb_6_7-branch:1.9.0.38
	gdb_6_7-2007-09-07-branchpoint:1.9
	insight_6_6-20070208-release:1.9
	gdb_6_6-2006-12-18-release:1.9
	gdb_6_6-branch:1.9.0.36
	gdb_6_6-2006-11-15-branchpoint:1.9
	insight_6_5-20061003-release:1.9
	gdb-csl-symbian-6_4_50_20060226-12:1.9
	gdb-csl-sourcerygxx-3_4_4-25:1.9
	nickrob-async-20060828-mergepoint:1.9
	gdb-csl-symbian-6_4_50_20060226-11:1.9
	gdb-csl-sourcerygxx-4_1-17:1.9
	gdb-csl-20060226-branch-local-2:1.9
	gdb-csl-sourcerygxx-4_1-14:1.9
	gdb-csl-sourcerygxx-4_1-13:1.9
	gdb-csl-sourcerygxx-4_1-12:1.9
	gdb-csl-sourcerygxx-3_4_4-21:1.9
	gdb_6_5-20060621-release:1.9
	gdb-csl-sourcerygxx-4_1-9:1.9
	gdb-csl-sourcerygxx-4_1-8:1.9
	gdb-csl-sourcerygxx-4_1-7:1.9
	gdb-csl-arm-2006q1-6:1.9
	gdb-csl-sourcerygxx-4_1-6:1.9
	gdb-csl-symbian-6_4_50_20060226-10:1.9
	gdb-csl-symbian-6_4_50_20060226-9:1.9
	gdb-csl-symbian-6_4_50_20060226-8:1.9
	gdb-csl-coldfire-4_1-11:1.9
	gdb-csl-sourcerygxx-3_4_4-19:1.9
	gdb-csl-coldfire-4_1-10:1.9
	gdb_6_5-branch:1.9.0.34
	gdb_6_5-2006-05-14-branchpoint:1.9
	gdb-csl-sourcerygxx-4_1-5:1.9
	nickrob-async-20060513-branch:1.9.0.32
	nickrob-async-20060513-branchpoint:1.9
	gdb-csl-sourcerygxx-4_1-4:1.9
	msnyder-reverse-20060502-branch:1.9.0.30
	msnyder-reverse-20060502-branchpoint:1.9
	gdb-csl-morpho-4_1-4:1.9
	gdb-csl-sourcerygxx-3_4_4-17:1.9
	readline_5_1-import-branch:1.9.0.28
	readline_5_1-import-branchpoint:1.9
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.9
	gdb-csl-symbian-20060226-branch:1.9.0.26
	gdb-csl-symbian-20060226-branchpoint:1.9
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.9
	msnyder-reverse-20060331-branch:1.9.0.24
	msnyder-reverse-20060331-branchpoint:1.9
	gdb-csl-available-20060303-branch:1.9.0.22
	gdb-csl-available-20060303-branchpoint:1.9
	gdb-csl-20060226-branch:1.9.0.20
	gdb-csl-20060226-branchpoint:1.9
	gdb_6_4-20051202-release:1.9
	msnyder-fork-checkpoint-branch:1.9.0.18
	msnyder-fork-checkpoint-branchpoint:1.9
	gdb-csl-gxxpro-6_3-branch:1.9.0.16
	gdb-csl-gxxpro-6_3-branchpoint:1.9
	gdb_6_4-branch:1.9.0.14
	gdb_6_4-2005-11-01-branchpoint:1.9
	gdb-csl-arm-20051020-branch:1.9.0.12
	gdb-csl-arm-20051020-branchpoint:1.9
	msnyder-tracepoint-checkpoint-branch:1.9.0.10
	msnyder-tracepoint-checkpoint-branchpoint:1.9
	gdb-csl-arm-20050325-2005-q1b:1.9
	gdb-csl-arm-20050325-2005-q1a:1.9
	csl-arm-20050325-branch:1.9.0.8
	csl-arm-20050325-branchpoint:1.9
	gdb_6_3-20041109-release:1.9
	gdb_6_3-branch:1.9.0.4
	gdb_6_3-20041019-branchpoint:1.9
	drow_intercu-merge-20040921:1.9
	drow_intercu-merge-20040915:1.9
	jimb-gdb_6_2-e500-branch:1.9.0.6
	jimb-gdb_6_2-e500-branchpoint:1.9
	gdb_6_2-20040730-release:1.9
	gdb_6_2-branch:1.9.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.9
	gdb_6_1_1-20040616-release:1.8
	gdb_6_1-2004-04-05-release:1.8
	drow_intercu-merge-20040402:1.8
	drow_intercu-merge-20040327:1.8
	ezannoni_pie-20040323-branch:1.8.0.48
	ezannoni_pie-20040323-branchpoint:1.8
	cagney_tramp-20040321-mergepoint:1.8
	cagney_tramp-20040309-branch:1.8.0.46
	cagney_tramp-20040309-branchpoint:1.8
	gdb_6_1-branch:1.8.0.44
	gdb_6_1-2004-03-01-gmt-branchpoint:1.8
	drow_intercu-20040221-branch:1.8.0.42
	drow_intercu-20040221-branchpoint:1.8
	cagney_bfdfile-20040213-branch:1.8.0.40
	cagney_bfdfile-20040213-branchpoint:1.8
	drow-cplus-merge-20040208:1.8
	carlton_dictionary-20040126-merge:1.8
	cagney_bigcore-20040122-branch:1.8.0.38
	cagney_bigcore-20040122-branchpoint:1.8
	drow-cplus-merge-20040113:1.8
	drow-cplus-merge-20031224:1.8
	drow-cplus-merge-20031220:1.8
	carlton_dictionary-20031215-merge:1.8
	drow-cplus-merge-20031214:1.8
	carlton-dictionary-20031111-merge:1.8
	gdb_6_0-2003-10-04-release:1.8
	kettenis_sparc-20030918-branch:1.8.0.36
	kettenis_sparc-20030918-branchpoint:1.8
	carlton_dictionary-20030917-merge:1.8
	ezannoni_pie-20030916-branchpoint:1.8
	ezannoni_pie-20030916-branch:1.8.0.34
	cagney_x86i386-20030821-branch:1.8.0.32
	cagney_x86i386-20030821-branchpoint:1.8
	carlton_dictionary-20030805-merge:1.8
	carlton_dictionary-20030627-merge:1.8
	gdb_6_0-branch:1.8.0.30
	gdb_6_0-2003-06-23-branchpoint:1.8
	jimb-ppc64-linux-20030613-branch:1.8.0.28
	jimb-ppc64-linux-20030613-branchpoint:1.8
	cagney_convert-20030606-branch:1.8.0.26
	cagney_convert-20030606-branchpoint:1.8
	cagney_writestrings-20030508-branch:1.8.0.24
	cagney_writestrings-20030508-branchpoint:1.8
	jimb-ppc64-linux-20030528-branch:1.8.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.8
	carlton_dictionary-20030523-merge:1.8
	cagney_fileio-20030521-branch:1.8.0.20
	cagney_fileio-20030521-branchpoint:1.8
	kettenis_i386newframe-20030517-mergepoint:1.8
	jimb-ppc64-linux-20030509-branch:1.8.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.8
	kettenis_i386newframe-20030504-mergepoint:1.8
	carlton_dictionary-20030430-merge:1.8
	kettenis_i386newframe-20030419-branch:1.8.0.16
	kettenis_i386newframe-20030419-branchpoint:1.8
	carlton_dictionary-20030416-merge:1.8
	cagney_frameaddr-20030409-mergepoint:1.8
	kettenis_i386newframe-20030406-branch:1.8.0.14
	kettenis_i386newframe-20030406-branchpoint:1.8
	cagney_frameaddr-20030403-branchpoint:1.8
	cagney_frameaddr-20030403-branch:1.8.0.12
	cagney_framebase-20030330-mergepoint:1.8
	cagney_framebase-20030326-branch:1.8.0.10
	cagney_framebase-20030326-branchpoint:1.8
	cagney_lazyid-20030317-branch:1.8.0.8
	cagney_lazyid-20030317-branchpoint:1.8
	kettenis-i386newframe-20030316-mergepoint:1.8
	offbyone-20030313-branch:1.8.0.6
	offbyone-20030313-branchpoint:1.8
	kettenis-i386newframe-20030308-branch:1.8.0.4
	kettenis-i386newframe-20030308-branchpoint:1.8
	carlton_dictionary-20030305-merge:1.8
	cagney_offbyone-20030303-branch:1.8.0.2
	cagney_offbyone-20030303-branchpoint:1.8
	carlton_dictionary-20030207-merge:1.7
	interps-20030202-branch:1.7.0.28
	interps-20030202-branchpoint:1.7
	cagney-unwind-20030108-branch:1.7.0.26
	cagney-unwind-20030108-branchpoint:1.7
	carlton_dictionary-20021223-merge:1.7
	gdb_5_3-2002-12-12-release:1.7
	carlton_dictionary-20021115-merge:1.7
	kseitz_interps-20021105-merge:1.7
	kseitz_interps-20021103-merge:1.7
	drow-cplus-merge-20021020:1.7
	drow-cplus-merge-20021025:1.7
	carlton_dictionary-20021025-merge:1.7
	carlton_dictionary-20021011-merge:1.7
	drow-cplus-branch:1.7.0.24
	drow-cplus-branchpoint:1.7
	kseitz_interps-20020930-merge:1.7
	carlton_dictionary-20020927-merge:1.7
	carlton_dictionary-branch:1.7.0.22
	carlton_dictionary-20020920-branchpoint:1.7
	gdb_5_3-branch:1.7.0.20
	gdb_5_3-2002-09-04-branchpoint:1.7
	kseitz_interps-20020829-merge:1.7
	cagney_sysregs-20020825-branch:1.7.0.18
	cagney_sysregs-20020825-branchpoint:1.7
	readline_4_3-import-branch:1.7.0.16
	readline_4_3-import-branchpoint:1.7
	gdb_5_2_1-2002-07-23-release:1.7
	kseitz_interps-20020528-branch:1.7.0.14
	kseitz_interps-20020528-branchpoint:1.7
	cagney_regbuf-20020515-branch:1.7.0.12
	cagney_regbuf-20020515-branchpoint:1.7
	jimb-macro-020506-branch:1.7.0.10
	jimb-macro-020506-branchpoint:1.7
	gdb_5_2-2002-04-29-release:1.7
	gdb_5_2-branch:1.7.0.8
	gdb_5_2-2002-03-03-branchpoint:1.7
	gdb_5_1_1-2002-01-24-release:1.7
	gdb_5_1_0_1-2002-01-03-release:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.7.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.7
	gdb_5_1-2001-11-21-release:1.7
	gdb_s390-2001-09-26-branch:1.7.0.4
	gdb_s390-2001-09-26-branchpoint:1.7
	gdb_5_1-2001-07-29-branch:1.7.0.2
	gdb_5_1-2001-07-29-branchpoint:1.7
	insight-precleanup-2001-01-01:1.7
	gdb-premipsmulti-2000-06-06-branch:1.6.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.6
	gdb_5_0-2000-05-19-release:1.2.2.1
	gdb_4_18_2-2000-05-18-release:1.2.2.1
	gdb_4_95_1-2000-05-11-snapshot:1.2.2.1
	gdb_4_95_0-2000-04-27-snapshot:1.2.2.1
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.10
date	2011.06.20.16.50.51;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.26.22.18.18;	author aoliva;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.26.23.27.09;	author cagney;	state Exp;
branches
	1.8.42.1;
next	1.7;

1.7
date	2000.08.09.18.42.04;	author aoliva;	state Exp;
branches
	1.7.22.1
	1.7.24.1;
next	1.6;

1.6
date	2000.05.29.19.02.56;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.22.20.34.09;	author aoliva;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.18.22.56.27;	author aoliva;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.25.09.48.40;	author aoliva;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.09.09.04.54;	author aoliva;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.12.07.03.56.43;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.8.42.1
date	2004.09.16.17.02.12;	author drow;	state Exp;
branches;
next	;

1.7.22.1
date	2003.03.06.00.56.42;	author carlton;	state Exp;
branches;
next	;

1.7.24.1
date	2003.12.14.20.28.28;	author drow;	state Exp;
branches;
next	;

1.2.2.1
date	2000.04.26.04.47.09;	author aoliva;	state Exp;
branches;
next	;

1.1.1.1
date	99.12.07.03.56.43;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.10
log
@	* am33.igen (sub Rm,Rn,Rd): Fix computation of carry flag.
@
text
@// Helper:            
//
// Given an extended register number, translate it into an index into the
// register array.  This is necessary as the upper 8 extended registers are
// actually synonyms for the d0-d3/a0-a3 registers.
//
//

:function:::int:translate_rreg:int rreg
{
  
  /* The higher register numbers actually correspond to the
     basic machine's address and data registers.  */
  if (rreg > 7 && rreg < 12)
    return REG_A0 + rreg - 8;
  else if (rreg > 11 && rreg < 16)
    return REG_D0 + rreg - 12;
  else
    return REG_E0 + rreg;
}

:function:::int:translate_xreg:int xreg
{
  switch (xreg)
    {
    case 0:
      return REG_SP;
    case 1:
      return REG_MDRQ;
    case 2:
      return REG_MCRH;
    case 3:
      return REG_MCRL;
    case 4:
      return REG_MCVF;
    default:
      sim_engine_abort (SD, CPU, cia, "%s:%d: bad switch\n", __FILE__, __LINE__);
    }
}

// 1111 0000 0010 00An; mov USP,An
8.0xf0+4.0x2,00,2.AN0:D0m:::mov
"mov"
*am33
*am33_2
{
  PC = cia;
  State.regs[REG_A0 + AN0] = State.regs[REG_USP];
}


// 1111 0000 0010 01An; mov SSP,An
8.0xf0+4.0x2,01,2.AN0:D0n:::mov
"mov"
*am33
*am33_2
{
  PC = cia;
  State.regs[REG_A0 + AN0] = State.regs[REG_SSP];
}


// 1111 0000 0010 10An; mov MSP,An
8.0xf0+4.0x2,10,2.AN0:D0o:::mov
"mov"
*am33
*am33_2
{
  PC = cia;
  State.regs[REG_A0 + AN0] = State.regs[REG_MSP];
}


// 1111 0000 0010 11An; mov PC,An
8.0xf0+4.0x2,11,2.AN0:D0p:::mov
"mov"
*am33
*am33_2
{
  PC = cia;
  State.regs[REG_A0 + AN0] = PC;
}


// 1111 0000 0011 Am00; mov Am,USP
8.0xf0+4.0x3,2.AM1,00:D0q:::mov
"mov"
*am33
*am33_2
{
  PC = cia;
  State.regs[REG_USP] = State.regs[REG_A0 + AM1];
}

// 1111 0000 0011 Am01; mov Am,SSP
8.0xf0+4.0x3,2.AM1,01:D0r:::mov
"mov"
*am33
*am33_2
{
  PC = cia;
  State.regs[REG_SSP] = State.regs[REG_A0 + AM1];
}

// 1111 0000 0011 Am10; mov Am,MSP
8.0xf0+4.0x3,2.AM1,10:D0s:::mov
"mov"
*am33
*am33_2
{
  PC = cia;
  State.regs[REG_MSP] = State.regs[REG_A0 + AM1];
}


// 1111 0000 1110 imm4; syscall
8.0xf0+4.0xe,IMM4:D0t:::syscall
"syscall"
*am33
*am33_2
{
  unsigned32 sp, next_pc;

  PC = cia;
  sp = State.regs[REG_SP];
  next_pc = State.regs[REG_PC] + 2;
  store_word (sp - 4, next_pc);
  store_word (sp - 8, PSW);
  State.regs[REG_PC] = 0x40000000 + IMM4 * 8;
  nia = PC;
}


// 1111 0010 1110 11Dn; mov EPSW,Dn
8.0xf2+4.0xe,11,2.DN0:D0u:::mov
"mov"
*am33
*am33_2
{
  PC = cia;
  State.regs[REG_D0 + DN0] = PSW;
}


// 1111 0010 1111 Dm01; mov Dm,EPSW
8.0xf2+4.0xf,2.DM1,01:D0v:::mov
"mov"
*am33
*am33_2
{
  PC = cia;
  PSW = State.regs[REG_D0 + DM1];
}

// 1111 0101 00Am Rn; mov Am,Rn
8.0xf5+00,2.AM1,4.RN0:D0w:::mov
"mov"
*am33
*am33_2
{
  int destreg = translate_rreg (SD_, RN0);

  PC = cia;
  State.regs[destreg] = State.regs[REG_A0 + AM1];
}

// 1111 0101 01Dm Rn; mov Dm,Rn
8.0xf5+01,2.DM1,4.RN0:D0x:::mov
"mov"
*am33
*am33_2
{
  int destreg = translate_rreg (SD_, RN0);

  PC = cia;
  State.regs[destreg] = State.regs[REG_D0 + DM1];
}

// 1111 0101 10Rm An; mov Rm,An
8.0xf5+10,4.RM1,2.AN0:D0y:::mov
"mov"
*am33
*am33_2
{
  int destreg = translate_rreg (SD_, RM1);

  PC = cia;
  State.regs[REG_A0 + AN0] = State.regs[destreg];
}

// 1111 0101 11Rm Dn; mov Rm,Dn
8.0xf5+11,4.RM1,2.DN0:D0z:::mov
"mov"
*am33
*am33_2
{
  int destreg = translate_rreg (SD_, RM1);

  PC = cia;
  State.regs[REG_D0 + DN0] = State.regs[destreg];
}


// 1111 1000 1100 1110 regs....; movm (USP),regs
8.0xf8+8.0xce+8.REGS:D1a:::movm
"movm"
*am33
*am33_2
{
  unsigned32 usp = State.regs[REG_USP];
  unsigned32 mask;

  PC = cia;
  mask = REGS;

  if (mask & 0x8)
    {
      usp += 4;
      State.regs[REG_LAR] = load_word (usp);
      usp += 4;
      State.regs[REG_LIR] = load_word (usp);
      usp += 4;
      State.regs[REG_MDR] = load_word (usp);
      usp += 4;
      State.regs[REG_A0 + 1] = load_word (usp);
      usp += 4;
      State.regs[REG_A0] = load_word (usp);
      usp += 4;
      State.regs[REG_D0 + 1] = load_word (usp);
      usp += 4;
      State.regs[REG_D0] = load_word (usp);
      usp += 4;
    }

  if (mask & 0x10)
    {
      State.regs[REG_A0 + 3] = load_word (usp);
      usp += 4;
    }

  if (mask & 0x20)
    {
      State.regs[REG_A0 + 2] = load_word (usp);
      usp += 4;
    }

  if (mask & 0x40)
    {
      State.regs[REG_D0 + 3] = load_word (usp);
      usp += 4;
    }

  if (mask & 0x80)
    {
      State.regs[REG_D0 + 2] = load_word (usp);
      usp += 4;
    }

  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33
      || STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2
      )
    {
      if (mask & 0x1)
	{
	  /* Need to restore MDQR, MCRH, MCRL, and MCVF */
	  usp += 16;
	  State.regs[REG_E0 + 1] = load_word (usp);
	  usp += 4;
	  State.regs[REG_E0 + 0] = load_word (usp);
	  usp += 4;
	}

      if (mask & 0x2)
        {
	  State.regs[REG_E0 + 7] = load_word (usp);
	  usp += 4;
	  State.regs[REG_E0 + 6] = load_word (usp);
	  usp += 4;
	  State.regs[REG_E0 + 5] = load_word (usp);
	  usp += 4;
	  State.regs[REG_E0 + 4] = load_word (usp);
	  usp += 4;
	}

      if (mask & 0x4)
	{
	  State.regs[REG_E0 + 3] = load_word (usp);
	  usp += 4;
	  State.regs[REG_E0 + 2] = load_word (usp);
	  usp += 4;
	}
    }

  /* And make sure to update the stack pointer.  */
  State.regs[REG_USP] = usp;
}

// 1111 1000 1100 1111 regs....; movm (USP),regs
8.0xf8+8.0xcf+8.REGS:D1b:::movm
"movm"
*am33
*am33_2
{
  unsigned32 usp = State.regs[REG_USP];
  unsigned32 mask;

  PC = cia;
  mask = REGS;

  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33
      || STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2
      )
    {
      if (mask & 0x4)
	{
	  usp -= 4;
	  store_word (usp, State.regs[REG_E0 + 2]);
	  usp -= 4;
	  store_word (usp, State.regs[REG_E0 + 3]);
	}

      if (mask & 0x2)
        {
	  usp -= 4;
	  store_word (usp, State.regs[REG_E0 + 4]);
	  usp -= 4;
	  store_word (usp, State.regs[REG_E0 + 5]);
	  usp -= 4;
	  store_word (usp, State.regs[REG_E0 + 6]);
	  usp -= 4;
	  store_word (usp, State.regs[REG_E0 + 7]);
	}

      if (mask & 0x1)
	{
	  usp -= 4;
	  store_word (usp, State.regs[REG_E0 + 0]);
	  usp -= 4;
	  store_word (usp, State.regs[REG_E0 + 1]);
	  usp -= 16;
	  /* Need to save MDQR, MCRH, MCRL, and MCVF */
	}
    }

  if (mask & 0x80)
    {
      usp -= 4;
      store_word (usp, State.regs[REG_D0 + 2]);
    }

  if (mask & 0x40)
    {
      usp -= 4;
      store_word (usp, State.regs[REG_D0 + 3]);
    }

  if (mask & 0x20)
    {
      usp -= 4;
      store_word (usp, State.regs[REG_A0 + 2]);
    }

  if (mask & 0x10)
    {
      usp -= 4;
      store_word (usp, State.regs[REG_A0 + 3]);
    }

  if (mask & 0x8)
    {
      usp -= 4;
      store_word (usp, State.regs[REG_D0]);
      usp -= 4;
      store_word (usp, State.regs[REG_D0 + 1]);
      usp -= 4;
      store_word (usp, State.regs[REG_A0]);
      usp -= 4;
      store_word (usp, State.regs[REG_A0 + 1]);
      usp -= 4;
      store_word (usp, State.regs[REG_MDR]);
      usp -= 4;
      store_word (usp, State.regs[REG_LIR]);
      usp -= 4;
      store_word (usp, State.regs[REG_LAR]);
      usp -= 4;
    }

  /* And make sure to update the stack pointer.  */
  State.regs[REG_USP] = usp;
}

// 1111 1100 1111 1100 imm32...; and imm32,EPSW 
8.0xfc+8.0xfc+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:4a:::and
"and"
*am33
*am33_2
{
  PC = cia;
  PSW &= FETCH32(IMM32A, IMM32B, IMM32C, IMM32D);
}

// 1111 1100 1111 1101 imm32...; or imm32,EPSW 
8.0xfc+8.0xfd+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D4a:::or
"or"
*am33
*am33_2
{
  PC = cia;
  PSW |= FETCH32(IMM32A, IMM32B, IMM32C, IMM32D);
}

// 1111 1001 0000 1000 Rm Rn; mov Rm,Rn (Rm != Rn)
8.0xf9+8.0x08+4.RM2,4.RN0!RM2:D1g:::mov
"mov"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;

  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  State.regs[dstreg] = State.regs[srcreg];
}

// 1111 1001 0001 1000 Rn Rn; ext Rn
8.0xf9+8.0x18+4.RN0,4.RN2=RN0:D1:::ext
"mov"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RN0);
  if (State.regs[srcreg] & 0x80000000)
    State.regs[REG_MDR] = -1;
  else
    State.regs[REG_MDR] = 0;
}

// 1111 1001 0010 1000 Rm Rn; extb Rm,Rn
8.0xf9+8.0x28+4.RM2,4.RN0!RM2:D1:::extb
"extb"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  State.regs[dstreg] = EXTEND8 (State.regs[srcreg]);
}

// 1111 1001 0011 1000 Rm Rn; extbu Rm,Rn
8.0xf9+8.0x38+4.RM2,4.RN0!RM2:D1:::extbu
"extbu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  State.regs[dstreg] = State.regs[srcreg] & 0xff;
}

// 1111 1001 0100 1000 Rm Rn; exth Rm,Rn
8.0xf9+8.0x48+4.RM2,4.RN0!RM2:D1:::exth
"exth"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  State.regs[dstreg] = EXTEND16 (State.regs[srcreg]);
}

// 1111 1001 0101 1000 Rm Rn; exthu Rm,Rn
8.0xf9+8.0x58+4.RM2,4.RN0!RM2:D1:::exthu
"exthu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  State.regs[dstreg] = State.regs[srcreg] & 0xffff;
}

// 1111 1001 0110 1000 Rn Rn; clr Rn
8.0xf9+8.0x68+4.RM2,4.RN0=RM2:D1:::clr
"clr"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);
  State.regs[dstreg] = 0;
  PSW |= PSW_Z;
  PSW &= ~(PSW_V | PSW_C | PSW_N);
}

// 1111 1001 0111 1000 Rm Rn; add Rm,Rn
8.0xf9+8.0x78+4.RM2,4.RN0:D1b:::add
"add"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  genericAdd (State.regs[srcreg], dstreg);
}

// 1111 1001 1000 1000 Rm Rn; addc Rm,Rn
8.0xf9+8.0x88+4.RM2,4.RN0:D1b:::addc
"addc"
*am33
*am33_2
{
  int srcreg, dstreg;
  int z, c, n, v;
  unsigned32 reg1, reg2, sum;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);

  reg1 = State.regs[srcreg];
  reg2 = State.regs[dstreg];
  sum = reg1 + reg2 + ((PSW & PSW_C) != 0);
  State.regs[dstreg] = sum;

  z = ((PSW & PSW_Z) != 0) && (sum == 0);
  n = (sum & 0x80000000);
  c = (sum < reg1) || (sum < reg2);
  v = ((reg2 & 0x80000000) == (reg1 & 0x80000000)
       && (reg2 & 0x80000000) != (sum & 0x80000000));

  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | ( n ? PSW_N : 0)
          | (c ? PSW_C : 0) | (v ? PSW_V : 0));
}

// 1111 1001 1001 1000 Rm Rn; sub Rm,Rn
8.0xf9+8.0x98+4.RM2,4.RN0:D1b:::sub
"sub"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  genericSub (State.regs[srcreg], dstreg);
}

// 1111 1001 1010 1000 Rm Rn; subc Rm,Rn
8.0xf9+8.0xa8+4.RM2,4.RN0:D1b:::subc
"subc"
*am33
*am33_2
{
  int srcreg, dstreg;
  int z, c, n, v;
  unsigned32 reg1, reg2, difference;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);

  reg1 = State.regs[srcreg];
  reg2 = State.regs[dstreg];
  difference = reg2 - reg1 - ((PSW & PSW_C) != 0);
  State.regs[dstreg] = difference;

  z = ((PSW & PSW_Z) != 0) && (difference == 0);
  n = (difference & 0x80000000);
  c = (reg1 > reg2);
  v = ((reg2 & 0x80000000) == (reg1 & 0x80000000)
       && (reg2 & 0x80000000) != (difference & 0x80000000));

  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | ( n ? PSW_N : 0)
          | (c ? PSW_C : 0) | (v ? PSW_V : 0));
}

// 1111 1001 1011 1000 Rn Rn; inc Rn
8.0xf9+8.0xb8+4.RN0,4.RN2=RN0:D1:::inc
"inc"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);
  genericAdd (1, dstreg);
}

// 1111 1001 1101 1000 Rn Rn; inc Rn
8.0xf9+8.0xc8+4.RN0,4.RN2=RN0:D1:::inc4
"inc4"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);
  genericAdd (4, dstreg);
}

// 1111 1001 1101 1000 Rm Rn; cmp Rm,Rn
8.0xf9+8.0xd8+4.RM2,4.RN0:D1:::cmp
"cmp"
*am33
*am33_2
{
  int srcreg1, srcreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RN0);
  srcreg2 = translate_rreg (SD_, RM2);
  genericCmp (State.regs[srcreg2], State.regs[srcreg1]);
}

// 1111 1001 1110 1000 XRm Rn; mov XRm,Rn
8.0xf9+8.0xe8+4.XRM2,4.RN0:D1l:::mov
"mov"
*am33
*am33_2
{
  int dstreg, srcreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);
  srcreg = translate_xreg (SD_, XRM2);

  State.regs[dstreg] = State.regs[srcreg];
}

// 1111 1001 1111 1000 Rm XRn; mov Rm,XRn
8.0xf9+8.0xf8+4.RM2,4.XRN0:D1m:::mov
"mov"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_xreg (SD_, XRN0);

  State.regs[dstreg] = State.regs[srcreg];
}

// 1111 1001 0000 1001 Rm Rn; and Rm,Rn
8.0xf9+8.0x09+4.RM2,4.RN0:D1a:::and
"and"
*am33
*am33_2
{
  int srcreg, dstreg;
  int z, n;

  PC = cia;

  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);

  State.regs[dstreg] &= State.regs[srcreg];
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1001 0001 1001 Rm Rn; or Rm,Rn
8.0xf9+8.0x19+4.RM2,4.RN0:D1a:::or
"or"
*am33
*am33_2
{
  int srcreg, dstreg;
  int z, n;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);

  State.regs[dstreg] |= State.regs[srcreg];
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1001 0010 1001 Rm Rn; xor Rm,Rn
8.0xf9+8.0x29+4.RM2,4.RN0:D1a:::xor
"xor"
*am33
*am33_2
{
  int srcreg, dstreg;
  int z, n;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);

  State.regs[dstreg] ^= State.regs[srcreg];
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1001 0011 1001 Rn Rn; not Rn
8.0xf9+8.0x39+4.RM2,4.RN0=RM2:D1:::not
"not"
*am33
*am33_2
{
  int dstreg;
  int z, n;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  State.regs[dstreg] = ~State.regs[dstreg];
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1001 0100 1001 Rm Rn; asr Rm,Rn
8.0xf9+8.0x49+4.RM2,4.RN0:D1a:::asr
"asr"
*am33
*am33_2
{
  int srcreg, dstreg;
  signed32 temp;
  int c, z, n;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);

  temp = State.regs[dstreg];
  c = temp & 1;
  temp >>= State.regs[srcreg];
  State.regs[dstreg] = temp;
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (c ? PSW_C : 0));
}

// 1111 1001 0101 1001 Rm Rn; lsr Rm,Rn
8.0xf9+8.0x59+4.RM2,4.RN0:D1a:::lsr
"lsr"
*am33
*am33_2
{
  int srcreg, dstreg;
  int z, n, c;

  PC = cia;

  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);

  c = State.regs[dstreg] & 1;
  State.regs[dstreg] >>= State.regs[srcreg];
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (c ? PSW_C : 0));
}

// 1111 1001 0110 1001 Rm Rn; asl Rm,Rn
8.0xf9+8.0x69+4.RM2,4.RN0:D1a:::asl
"asl"
*am33
*am33_2
{
  int srcreg, dstreg;
  int z, n;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);

  State.regs[dstreg] <<= State.regs[srcreg];
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1001 0111 1001 Rn Rn; asl2 Rn
8.0xf9+8.0x79+4.RM2,4.RN0=RM2:D1:::asl2
"asl2"
*am33
*am33_2
{
  int dstreg;
  int n, z;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  State.regs[dstreg] <<= 2;
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1001 1000 1001 Rn Rn; ror Rn
8.0xf9+8.0x89+4.RM2,4.RN0=RM2:D1:::ror
"ror"
*am33
*am33_2
{
  int dstreg;
  int c, n, z;
  unsigned32 value;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  value = State.regs[dstreg];
  c = (value & 0x1);

  value >>= 1;
  value |= ((PSW & PSW_C) != 0) ? 0x80000000 : 0;
  State.regs[dstreg] = value;
  z = (value == 0);
  n = (value & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (c ? PSW_C : 0));
}

// 1111 1001 1001 1001 Rn Rn; rol Rn
8.0xf9+8.0x99+4.RM2,4.RN0=RM2:D1:::rol
"rol"
*am33
*am33_2
{
  int dstreg;
  int c, n, z;
  unsigned32 value;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  value = State.regs[dstreg];
  c = (value & 0x80000000) ? 1 : 0;

  value <<= 1;
  value |= ((PSW & PSW_C) != 0);
  State.regs[dstreg] = value;
  z = (value == 0);
  n = (value & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (c ? PSW_C : 0));
}

// 1111 1001 1010 1001 Rm Rn; mul Rm,Rn
8.0xf9+8.0xa9+4.RM2,4.RN0:D1b:::mul
"mul"
*am33
*am33_2
{
  int srcreg, dstreg;
  unsigned64 temp;
  int n, z;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);

  temp = ((signed64)(signed32)State.regs[dstreg]
          *  (signed64)(signed32)State.regs[srcreg]);
  State.regs[dstreg] = temp & 0xffffffff;
  State.regs[REG_MDR] = (temp & 0xffffffff00000000LL) >> 32;
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1001 1011 1001 Rm Rn; mulu Rm,Rn
8.0xf9+8.0xb9+4.RM2,4.RN0:D1b:::mulu
"mulu"
*am33
*am33_2
{
  int srcreg, dstreg;
  unsigned64 temp;
  int n, z;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);

  temp = ((unsigned64)State.regs[dstreg]
          * (unsigned64)State.regs[srcreg]);
  State.regs[dstreg] = temp & 0xffffffff;
  State.regs[REG_MDR] = (temp & 0xffffffff00000000LL) >> 32;
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1001 1100 1001 Rm Rn; div Rm,Rn
8.0xf9+8.0xc9+4.RM2,4.RN0:D1b:::div
"div"
*am33
*am33_2
{
  int srcreg, dstreg;
  signed64 temp;
  int n, z;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);

  temp = State.regs[REG_MDR];
  temp <<= 32;
  temp |= State.regs[dstreg];
  State.regs[REG_MDR] = temp % (signed32)State.regs[srcreg];
  temp /= (signed32)State.regs[srcreg];
  State.regs[dstreg] = temp & 0xffffffff;
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1001 1101 1001 Rm Rn; divu Rm,Rn
8.0xf9+8.0xd9+4.RM2,4.RN0:D1b:::divu
"divu"
*am33
*am33_2
{
  int srcreg, dstreg;
  unsigned64 temp;
  int n, z;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);

  temp = State.regs[REG_MDR];
  temp <<= 32;
  temp |= State.regs[dstreg];
  State.regs[REG_MDR] = temp % State.regs[srcreg];
  temp /= State.regs[srcreg];
  State.regs[dstreg] = temp & 0xffffffff;
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}


// 1111 1001 0000 1010 Rm Rn; mov (Rm),Rn
8.0xf9+8.0x0a+4.RN2,4.RM0:D1h:::mov
"mov"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM0);
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_word (State.regs[srcreg]);
}

// 1111 1001 0001 1010 Rm Rn; mov Rm,(Rn)
8.0xf9+8.0x1a+4.RM2,4.RN0:D1i:::mov
"mov"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  store_word (State.regs[dstreg], State.regs[srcreg]);
}

// 1111 1001 0010 1010 Rm Rn; movbu (Rm),Rn
8.0xf9+8.0x2a+4.RN2,4.RM0:D1g:::movbu
"movbu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM0);
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_byte (State.regs[srcreg]);
}

// 1111 1001 0011 1010 Rm Rn; movbu Rm,(Rn)
8.0xf9+8.0x3a+4.RM2,4.RN0:D1i:::movbu
"movbu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  store_byte (State.regs[dstreg], State.regs[srcreg]);
}

// 1111 1001 0100 1010 Rm Rn; movhu (Rm),Rn
8.0xf9+8.0x4a+4.RN2,4.RM0:D1g:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM0);
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_half (State.regs[srcreg]);
}

// 1111 1001 0101 1010 Rm Rn; movhu Rm,(Rn)
8.0xf9+8.0x5a+4.RM2,4.RN0:D1i:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  store_half (State.regs[dstreg], State.regs[srcreg]);
}

// 1111 1001 0110 1010 Rm Rn; mov (Rm+),Rn
8.0xf9+8.0x6a+4.RN2,4.RM0!RN2:D1y:::mov
"mov"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM0);
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_word (State.regs[srcreg]);
  State.regs[srcreg] += 4;
}

// 1111 1001 0111 1010 Rm Rn; mov Rm,(Rn+)
8.0xf9+8.0x7a+4.RM2,4.RN0:D1z:::mov
"mov"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  store_word (State.regs[dstreg], State.regs[srcreg]);
  State.regs[dstreg] += 4;
}

// 1111 1001 1000 1010 Rn 0000; mov (sp),Rn
8.0xf9+8.0x8a+4.RN2,4.0000:D1j:::mov
"mov"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_word (State.regs[REG_SP]);
}

// 1111 1001 1001 1010 Rm 0000; mov Rm, (sp)
8.0xf9+8.0x9a+4.RM2,4.0000:D1k:::mov
"mov"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  store_word (State.regs[REG_SP], State.regs[srcreg]);
}

// 1111 1001 1010 1010 Rn 0000; mobvu (sp),Rn
8.0xf9+8.0xaa+4.RN2,4.0000:D1j:::movbu
"movbu"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_byte (State.regs[REG_SP]);
}

// 1111 1001 1011 1010 Rm 0000; movbu Rm, (sp)
8.0xf9+8.0xba+4.RM2,4.0000:D1k:::movbu
"movbu"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  store_byte (State.regs[REG_SP], State.regs[srcreg]);
}

// 1111 1001 1000 1100 Rn 0000; movhu (sp),Rn
8.0xf9+8.0xca+4.RN2,4.0000:D1j:::movhu
"movhu"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_half (State.regs[REG_SP]);
}

// 1111 1001 1001 1101 Rm 0000; movhu Rm, (sp)
8.0xf9+8.0xda+4.RM2,4.0000:D1k:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  store_half (State.regs[REG_SP], State.regs[srcreg]);
}

// 1111 1001 1110 1010 Rm Rn; movhu (Rm+),Rn
8.0xf9+8.0xea+4.RN2,4.RM0!RN2:D1y:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM0);
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_half (State.regs[srcreg]);
  State.regs[srcreg] += 2;
}

// 1111 1001 1111 1010 Rm Rn; movhu Rm,(Rn+)
8.0xf9+8.0xfa+4.RM2,4.RN0:D1z:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  store_half (State.regs[dstreg], State.regs[srcreg]);
  State.regs[dstreg] += 2;
}


// 1111 1001 0000 1011 Rm Rn; mac Rm,Rn
8.0xf9+8.0x0b+4.RM2,4.RN0:D1:::mac
"mac"
*am33
*am33_2
{
  int srcreg1, srcreg2;
  signed64 temp, sum;
  int c, v;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);

  temp = ((signed64)(signed32)State.regs[srcreg2]
          * (signed64)(signed32)State.regs[srcreg1]);
  sum = State.regs[REG_MCRL] + (temp & 0xffffffff);
  c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));
  State.regs[REG_MCRL] = sum;
  temp >>= 32;
  temp &= 0xffffffff;
  sum = State.regs[REG_MCRH] + temp + c;
  v = ((State.regs[REG_MCRH] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRH] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1001 0001 1011 Rm Rn; macu Rm,Rn
8.0xf9+8.0x1b+4.RM2,4.RN0:D1:::macu
"macu"
*am33
*am33_2
{
  int srcreg1, srcreg2;
  unsigned64 temp, sum;
  int c, v;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);

  temp = ((unsigned64)State.regs[srcreg2]
          * (unsigned64)State.regs[srcreg1]);
  sum = State.regs[REG_MCRL] + (temp & 0xffffffff);
  c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));
  State.regs[REG_MCRL] = sum;
  temp >>= 32;
  temp &= 0xffffffff;
  sum = State.regs[REG_MCRH] + temp + c;
  v = ((State.regs[REG_MCRH] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRH] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1001 0010 1011 Rm Rn; macb Rm,Rn
8.0xf9+8.0x2b+4.RM2,4.RN0:D1:::macb
"macb"
*am33
*am33_2
{
  int srcreg1, srcreg2;
  signed32 temp, sum;
  int v;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);

  temp = ((signed32)(signed8)(State.regs[srcreg2] & 0xff)
          * (signed32)(signed8)(State.regs[srcreg1] & 0xff));
  sum = State.regs[REG_MCRL] + temp;
  v = ((State.regs[REG_MCRL] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRL] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1001 0011 1011 Rm Rn; macbu Rm,Rn
8.0xf9+8.0x3b+4.RM2,4.RN0:D1:::macbu
"macbu"
*am33
*am33_2
{
  int srcreg1, srcreg2;
  signed64 temp, sum;
  int v;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);

  temp = ((unsigned32)(State.regs[srcreg2] & 0xff)
          * (unsigned32)(State.regs[srcreg1] & 0xff));
  sum = State.regs[REG_MCRL] + temp;
  v = ((State.regs[REG_MCRL] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRL] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1001 0100 1011 Rm Rn; mach Rm,Rn
8.0xf9+8.0x4b+4.RM2,4.RN0:D1:::mach
"mach"
*am33
*am33_2
{
  int srcreg1, srcreg2;
  signed64 temp, sum;
  int c, v;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);

  temp = ((unsigned64)(signed16)(State.regs[srcreg2] & 0xffff)
          * (unsigned64)(signed16)(State.regs[srcreg1] & 0xffff));
  sum = State.regs[REG_MCRL] + (temp & 0xffffffff);
  c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));
  State.regs[REG_MCRL] = sum;
  temp >>= 32;
  temp &= 0xffffffff;
  sum = State.regs[REG_MCRH] + temp + c;
  v = ((State.regs[REG_MCRH] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRH] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1001 0101 1011 Rm Rn; machu Rm,Rn
8.0xf9+8.0x5b+4.RM2,4.RN0:D1:::machu
"machu"
*am33
*am33_2
{
  int srcreg1, srcreg2;
  signed64 temp, sum;
  int c, v;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);

  temp = ((unsigned64)(State.regs[srcreg2] & 0xffff)
          * (unsigned64)(State.regs[srcreg1] & 0xffff));
  sum = State.regs[REG_MCRL] + (temp & 0xffffffff);
  c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));
  State.regs[REG_MCRL] = sum;
  temp >>= 32;
  temp &= 0xffffffff;
  sum = State.regs[REG_MCRH] + temp + c;
  v = ((State.regs[REG_MCRH] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRH] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1001 0110 1011 Rm Rn; dmach Rm,Rn
8.0xf9+8.0x6b+4.RM2,4.RN0:D1:::dmach
"dmach"
*am33
*am33_2
{
  int srcreg1, srcreg2;
  signed32 temp, temp2, sum;
  int v;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);

  temp = ((signed32)(signed16)(State.regs[srcreg2] & 0xffff)
          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));
  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)
	   * (signed32)(signed16)((State.regs[srcreg2] >> 16) & 0xffff));
  sum = temp + temp2 + State.regs[REG_MCRL];
  v = ((State.regs[REG_MCRL] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRL] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1001 0111 1011 Rm Rn; dmachu Rm,Rn
8.0xf9+8.0x7b+4.RM2,4.RN0:D1:::dmachu
"dmachu"
*am33
*am33_2
{
  int srcreg1, srcreg2;
  unsigned32 temp, temp2, sum;
  int v;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);

  temp = ((unsigned32)(State.regs[srcreg2] & 0xffff)
          * (unsigned32)(State.regs[srcreg1] & 0xffff));
  temp2 = ((unsigned32)((State.regs[srcreg1] >> 16) & 0xffff)
	   * (unsigned32)((State.regs[srcreg2] >> 16) & 0xffff));
  sum = temp + temp2 + State.regs[REG_MCRL];
  v = ((State.regs[REG_MCRL] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRL] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1001 1000 1011 Rm Rn; dmulh Rm,Rn
8.0xf9+8.0x8b+4.RM2,4.RN0:D1:::dmulh
"dmulh"
*am33
*am33_2
{
  int srcreg, dstreg;
  signed32 temp;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);

  temp = ((signed32)(signed16)(State.regs[dstreg] & 0xffff)
          * (signed32)(signed16)(State.regs[srcreg] & 0xffff));
  State.regs[REG_MDRQ] = temp;
  temp = ((signed32)(signed16)((State.regs[dstreg] >> 16) & 0xffff)
          * (signed32)(signed16)((State.regs[srcreg] >>16) & 0xffff));
  State.regs[dstreg] = temp;
}

// 1111 1001 1001 1011 Rm Rn; dmulhu Rm,Rn
8.0xf9+8.0x9b+4.RM2,4.RN0:D1:::dumachu
"dmachu"
*am33
*am33_2
{
  int srcreg, dstreg;
  unsigned32 temp;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);

  temp = ((unsigned32)(State.regs[dstreg] & 0xffff)
          * (unsigned32)(State.regs[srcreg] & 0xffff));
  State.regs[REG_MDRQ] = temp;
  temp = ((unsigned32)((State.regs[dstreg] >> 16) & 0xffff)
          * (unsigned32)((State.regs[srcreg] >>16) & 0xffff));
  State.regs[dstreg] = temp;
}

// 1111 1001 1010 1011 Rm Rn; sat16 Rm,Rn
8.0xf9+8.0xab+4.RM2,4.RN0:D1:::sat16
"sat16"
*am33
*am33_2
{
  int srcreg, dstreg;
  int value, z, n;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);

  value = State.regs[srcreg];

  if (value >= 0x7fff)
    State.regs[dstreg] = 0x7fff;
  else if (value <= 0xffff8000)
    State.regs[dstreg] = 0xffff8000;
  else
    State.regs[dstreg] = value;

  n = (State.regs[dstreg] & 0x8000) != 0;
  z = (State.regs[dstreg] == 0);
  PSW &= ~(PSW_Z | PSW_N);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1001 1011 1011 Rm Rn; mcste Rm,Rn 
8.0xf9+8.0xbb+4.RM2,4.RN0:D1:::mcste
"mcste"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);

  PSW &= ~(PSW_V | PSW_C);
  PSW |= (State.regs[REG_MCVF] ? PSW_V : 0);
  
  /* 32bit saturation.  */
  if (State.regs[srcreg] == 0x20)
    {
      signed64 tmp;

      tmp = State.regs[REG_MCRH];
      tmp <<= 32;
      tmp += State.regs[REG_MCRL];

      if (tmp > 0x7fffffff)    
	State.regs[dstreg] = 0x7fffffff;
      else if (tmp < 0xffffffff80000000LL)
	State.regs[dstreg] = 0x80000000;
      else
	State.regs[dstreg] = tmp;
    }
  /* 16bit saturation */
  else if (State.regs[srcreg] == 0x10)
    {
      signed64 tmp;

      tmp = State.regs[REG_MCRH];
      tmp <<= 32;
      tmp += State.regs[REG_MCRL];

      if (tmp > 0x7fff)    
	State.regs[dstreg] = 0x7fff;
      else if (tmp < 0xffffffffffff8000LL)
	State.regs[dstreg] = 0x8000;
      else
	State.regs[dstreg] = tmp;
    }
  /* 8 bit saturation */
  else if (State.regs[srcreg] == 0x8)
    {
      signed64 tmp;

      tmp = State.regs[REG_MCRH];
      tmp <<= 32;
      tmp += State.regs[REG_MCRL];

      if (tmp > 0x7f)    
	State.regs[dstreg] = 0x7f;
      else if (tmp < 0xffffffffffffff80LL)
	State.regs[dstreg] = 0x80;
      else
	State.regs[dstreg] = tmp;
    }
  /* 9 bit saturation */
  else if (State.regs[srcreg] == 0x9)
    {
      signed64 tmp;

      tmp = State.regs[REG_MCRH];
      tmp <<= 32;
      tmp += State.regs[REG_MCRL];

      if (tmp > 0x80)    
	State.regs[dstreg] = 0x80;
      else if (tmp < 0xffffffffffffff81LL)
	State.regs[dstreg] = 0x81;
      else
	State.regs[dstreg] = tmp;
    }
  /* 9 bit saturation */
  else if (State.regs[srcreg] == 0x30)
    {
      signed64 tmp;

      tmp = State.regs[REG_MCRH];
      tmp <<= 32;
      tmp += State.regs[REG_MCRL];

      if (tmp > 0x7fffffffffffLL)    
	tmp = 0x7fffffffffffLL;
      else if (tmp < 0xffff800000000000LL)
	tmp = 0xffff800000000000LL;

      tmp >>= 16;
      State.regs[dstreg] = tmp;
    }
}

// 1111 1001 1100 1011 Rm Rn; swap Rm,Rn
8.0xf9+8.0xcb+4.RM2,4.RN0:D1:::swap
"swap"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);

  State.regs[dstreg] = (((State.regs[srcreg] & 0xff) << 24)
			| (((State.regs[srcreg] >> 8) & 0xff) << 16)
			| (((State.regs[srcreg] >> 16) & 0xff) << 8)
			| ((State.regs[srcreg] >> 24) & 0xff));
}

// 1111 1101 1101 1011 Rm Rn; swaph Rm,Rn
8.0xf9+8.0xdb+4.RM2,4.RN0:D1:::swaph
"swaph"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);

  State.regs[dstreg] = (((State.regs[srcreg] & 0xff) << 8)
			| ((State.regs[srcreg] >> 8) & 0xff)
			| (((State.regs[srcreg] >> 16) & 0xff) << 24)
			| (((State.regs[srcreg] >> 24) & 0xff) << 16));
}

// 1111 1001 1110 1011 Rm Rn; swhw Rm,Rn
8.0xf9+8.0xeb+4.RM2,4.RN0:D1:::swhw
"swhw"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);

  State.regs[dstreg] = (((State.regs[srcreg] & 0xffff) << 16)
			| ((State.regs[srcreg] >> 16) & 0xffff));
}

// 1111 1001 1111 1011 Rm Rn; bsch Rm,Rn
8.0xf9+8.0xfb+4.RM2,4.RN0:D1:::bsch
"bsch"
*am33
*am33_2
{
  int temp, c, i;
  int srcreg, dstreg;
  int start;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);

  temp = State.regs[srcreg];
  start = (State.regs[dstreg] & 0x1f) - 1;
  if (start == -1)
    start = 31;
    
  c = 0;
  for (i = start; i >= 0; i--)
    {
      if (temp & (1 << i))
	{
	  c = 1;
	  State.regs[dstreg] = i;
	  break;
	}
    }

  if (i < 0)
    {
      c = 0;
      State.regs[dstreg] = 0;
    }
  PSW &= ~(PSW_C);
  PSW |= (c ? PSW_C : 0);
}


// 1111 1011 0000 1000 Rn Rn IMM8; mov IMM8,Rn
8.0xfb+8.0x08+4.RM2,4.RN0=RM2+8.IMM8:D2j:::mov
"mov"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);
  State.regs[dstreg] = EXTEND8 (IMM8);
}

// 1111 1011 0001 1000 Rn Rn IMM8; movu IMM8,Rn
8.0xfb+8.0x18+4.RM2,4.RN0=RM2+8.IMM8:D2:::movu
"movu"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);
  State.regs[dstreg] = IMM8 & 0xff;
}

// 1111 1011 0111 1000 Rn Rn IMM8; add IMM8,Rn
8.0xfb+8.0x78+4.RM2,4.RN0=RM2+8.IMM8:D2d:::add
"add"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);
  genericAdd (EXTEND8 (IMM8), dstreg);
}

// 1111 1011 1000 1000 Rn Rn IMM8; addc IMM8,Rn
8.0xfb+8.0x88+4.RM2,4.RN0=RM2+8.IMM8:D2d:::addc
"addc"
*am33
*am33_2
{
  int dstreg, imm;
  int z, c, n, v;
  unsigned32 reg2, sum;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  imm = EXTEND8 (IMM8);
  reg2 = State.regs[dstreg];
  sum = imm + reg2 + ((PSW & PSW_C) != 0);
  State.regs[dstreg] = sum;

  z = ((PSW & PSW_Z) != 0) && (sum == 0);
  n = (sum & 0x80000000);
  c = (sum < imm) || (sum < reg2);
  v = ((reg2 & 0x80000000) == (imm & 0x80000000)
       && (reg2 & 0x80000000) != (sum & 0x80000000));

  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | ( n ? PSW_N : 0)
          | (c ? PSW_C : 0) | (v ? PSW_V : 0));
}

// 1111 1011 1001 1000 Rn Rn IMM8; sub IMM8,Rn
8.0xfb+8.0x98+4.RM2,4.RN0=RM2+8.IMM8:D2d:::sub
"sub"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  genericSub (EXTEND8 (IMM8), dstreg);
}

// 1111 1011 1010 1000 Rn Rn IMM8; subc IMM8,Rn
8.0xfb+8.0xa8+4.RM2,4.RN0=RM2+8.IMM8:D2d:::subc
"subc"
*am33
*am33_2
{
  int imm, dstreg;
  int z, c, n, v;
  unsigned32 reg2, difference;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  imm = EXTEND8 (IMM8);
  reg2 = State.regs[dstreg];
  difference = reg2 - imm - ((PSW & PSW_C) != 0);
  State.regs[dstreg] = difference;

  z = ((PSW & PSW_Z) != 0) && (difference == 0);
  n = (difference & 0x80000000);
  c = (imm > reg2);
  v = ((reg2 & 0x80000000) == (imm & 0x80000000)
       && (reg2 & 0x80000000) != (difference & 0x80000000));

  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | ( n ? PSW_N : 0)
          | (c ? PSW_C : 0) | (v ? PSW_V : 0));
}

// 1111 1011 1101 1000 Rn Rn IMM8; cmp IMM8,Rn
8.0xfb+8.0xd8+4.RM2,4.RN0=RM2+8.IMM8:D2b:::cmp
"cmp"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RN0);
  genericCmp (EXTEND8 (IMM8), State.regs[srcreg]);
}

// 1111 1011 1111 1000 XRn XRn IMM8; mov IMM8,XRn
8.0xfb+8.0xf8+4.XRM2,4.XRN0=XRM2+8.IMM8:D2k:::mov
"mov"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_xreg (SD_, XRN0);

  State.regs[dstreg] = IMM8;
}

// 1111 1011 0000 1001 Rn Rn IMM8; and IMM8,Rn
8.0xfb+8.0x09+4.RM2,4.RN0=RM2+8.IMM8:D2d:::and
"and"
*am33
*am33_2
{
  int dstreg;
  int z, n;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  State.regs[dstreg] &= (IMM8 & 0xff);
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1011 0001 1001 Rn Rn IMM8; or IMM8,Rn
8.0xfb+8.0x19+4.RM2,4.RN0=RM2+8.IMM8:D2d:::or
"or"
*am33
*am33_2
{
  int dstreg;
  int z, n;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  State.regs[dstreg] |= (IMM8 & 0xff);
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1011 0010 1001 Rn Rn IMM8; xor IMM8,Rn
8.0xfb+8.0x29+4.RM2,4.RN0=RM2+8.IMM8:D2d:::xor
"xor"
*am33
*am33_2
{
  int dstreg;
  int z, n;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  State.regs[dstreg] ^= (IMM8 & 0xff);
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1011 0100 1001 Rn Rn IMM8; asr IMM8,Rn
8.0xfb+8.0x49+4.RM2,4.RN0=RM2+8.IMM8:D2a:::asr
"asr"
*am33
*am33_2
{
  int dstreg;
  signed32 temp;
  int c, z, n;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  temp = State.regs[dstreg];
  c = temp & 1;
  temp >>= (IMM8 & 0xff);
  State.regs[dstreg] = temp;
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (c ? PSW_C : 0));
}

// 1111 1011 0101 1001 Rn Rn IMM8; lsr IMM8,Rn
8.0xfb+8.0x59+4.RM2,4.RN0=RM2+8.IMM8:D2a:::lsr
"lsr"
*am33
*am33_2
{
  int dstreg;
  int z, n, c;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  c = State.regs[dstreg] & 1;
  State.regs[dstreg] >>= (IMM8 & 0xff);
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (c ? PSW_C : 0));
}

// 1111 1011 0110 1001 Rn Rn IMM8; asl IMM8,Rn
8.0xfb+8.0x69+4.RM2,4.RN0=RM2+8.IMM8:D2a:::asl
"asl"
*am33
*am33_2
{
  int dstreg;
  int z, n;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  State.regs[dstreg] <<= (IMM8 & 0xff);
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1011 1010 1001 Rn Rn IMM8; mul IMM8,Rn
8.0xfb+8.0xa9+4.RM2,4.RN0=RM2+8.IMM8:D2a:::mul
"mul"
*am33
*am33_2
{
  int dstreg;
  unsigned64 temp;
  int z, n;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  temp = ((signed64)(signed32)State.regs[dstreg]
          *  (signed64)(signed32)EXTEND8 (IMM8));
  State.regs[dstreg] = temp & 0xffffffff;
  State.regs[REG_MDR] = (temp & 0xffffffff00000000LL) >> 32;
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1011 1011 1001 Rn Rn IMM8; mulu IMM8,Rn
8.0xfb+8.0xb9+4.RM2,4.RN0=RM2+8.IMM8:D2a:::mulu
"mulu"
*am33
*am33_2
{
  int dstreg;
  unsigned64 temp;
  int z, n;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  temp = ((unsigned64)State.regs[dstreg]
          * (unsigned64)(IMM8 & 0xff));
  State.regs[dstreg] = temp & 0xffffffff;
  State.regs[REG_MDR] = (temp & 0xffffffff00000000LL) >> 32;
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1011 1110 1001 Rn Rn IMM8; btst imm8,Rn
8.0xfb+8.0xe9+4.RN2,4.RM0=RN2+8.IMM8:D2l:::btst
"btst"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM0);
  genericBtst(IMM8, State.regs[srcreg]);
}

// 1111 1011 0000 1010 Rn Rm IMM8; mov (d8,Rm),Rn
8.0xfb+8.0x0a+4.RN2,4.RM0+8.IMM8:D2l:::mov
"mov"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM0);
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_word (State.regs[srcreg] + EXTEND8 (IMM8));
}

// 1111 1011 0001 1010 Rn Rm IMM8; mov Rm,(d8,Rn)
8.0xfb+8.0x1a+4.RM2,4.RN0+8.IMM8:D2m:::mov
"mov"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  store_word (State.regs[dstreg] + EXTEND8 (IMM8), State.regs[srcreg]);
}

// 1111 1011 0010 1010 Rn Rm IMM8; movbu (d8,Rm),Rn
8.0xfb+8.0x2a+4.RN2,4.RM0+8.IMM8:D2l:::movbu
"movbu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM0);
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_byte (State.regs[srcreg] + EXTEND8 (IMM8));
}

// 1111 1011 0011 1010 Rn Rm IMM8; movbu Rm,(d8,Rn)
8.0xfb+8.0x3a+4.RM2,4.RN0+8.IMM8:D2m:::movbu
"movbu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  store_byte (State.regs[dstreg] + EXTEND8 (IMM8), State.regs[srcreg]);
}

// 1111 1011 0100 1010 Rn Rm IMM8; movhu (d8,Rm),Rn
8.0xfb+8.0x4a+4.RN2,4.RM0+8.IMM8:D2l:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM0);
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_half (State.regs[srcreg] + EXTEND8 (IMM8));
}

// 1111 1011 0101 1010 Rn Rm IMM8; movhu Rm,(d8,Rn)
8.0xfb+8.0x5a+4.RM2,4.RN0+8.IMM8:D2m:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  store_half (State.regs[dstreg] + EXTEND8 (IMM8), State.regs[srcreg]);
}

// 1111 1011 0110 1010 Rn Rm IMM8; mov (d8,Rm+),Rn
8.0xfb+8.0x6a+4.RN2,4.RM0!RN2+8.IMM8:D2y:::mov
"mov"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM0);
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_word (State.regs[srcreg]);
  State.regs[srcreg] += EXTEND8 (IMM8);
}

// 1111 1011 0111 1010 Rn Rm IMM8; mov Rm,(d8,Rn+)
8.0xfb+8.0x7a+4.RM2,4.RN0+8.IMM8:D2z:::mov
"mov"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  store_word (State.regs[dstreg], State.regs[srcreg]);
  State.regs[dstreg] += EXTEND8 (IMM8);
}


// 1111 1011 1000 1010 Rn 0000 IMM8; mov (d8,sp),Rn
8.0xfb+8.0x8a+4.RN2,4.0x0+8.IMM8:D2n:::mov
"mov"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_word (State.regs[REG_SP] + IMM8);
}

// 1111 1011 1001 1010 Rm 0000 IMM8; mov Rm,(d8,sp)
8.0xfb+8.0x9a+4.RM2,4.0x0+8.IMM8:D2o:::mov
"mov"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  store_word (State.regs[REG_SP] + IMM8, State.regs[srcreg]);
}

// 1111 1011 1010 1010 Rn Rm IMM8; movbu (d8,sp),Rn
8.0xfb+8.0xaa+4.RN2,4.0x0+8.IMM8:D2n:::movbu
"movbu"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_byte (State.regs[REG_SP] + IMM8);
}

// 1111 1011 1011 1010 Rn Rm IMM8; movbu Rm,(d8,sp)
8.0xfb+8.0xba+4.RM2,4.0x0+8.IMM8:D2o:::movbu
"movbu"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  store_byte (State.regs[REG_SP] + IMM8, State.regs[srcreg]);
}

// 1111 1011 1100 1010 Rn Rm IMM8; movhu (d8,sp),Rn
8.0xfb+8.0xca+4.RN2,4.0x0+8.IMM8:D2n:::movhu
"movhu"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_half (State.regs[REG_SP] + IMM8);
}

// 1111 1011 1101 1010 Rn Rm IMM8; movhu Rm,(d8,sp)
8.0xfb+8.0xda+4.RM2,4.0x0+8.IMM8:D2o:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  store_half (State.regs[REG_SP] + IMM8, State.regs[srcreg]);
}

// 1111 1011 1110 1010 Rn Rm IMM8; movhu (d8,Rm+),Rn
8.0xfb+8.0xea+4.RN2,4.RM0!RN2+8.IMM8:D2y:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM0);
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_half (State.regs[srcreg]);
  State.regs[srcreg] += EXTEND8 (IMM8);
}

// 1111 1011 1111 1010 Rn Rm IMM8; movhu Rm,(d8,Rn+)
8.0xfb+8.0xfa+4.RM2,4.RN0+8.IMM8:D2z:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  store_half (State.regs[dstreg], State.regs[srcreg]);
  State.regs[dstreg] += EXTEND8 (IMM8);
}


// 1111 1011 0000 1011 Rn Rn IMM8; mac imm8,Rn
8.0xfb+8.0x0b+4.RN2,4.RN0=RN2+8.IMM8:D2:::mac
"mac"
*am33
*am33_2
{
  int srcreg;
  signed64 temp, sum;
  int c, v;

  PC = cia;
  srcreg = translate_rreg (SD_, RN2);

  temp = ((signed64)(signed32)EXTEND8 (IMM8)
          * (signed64)(signed32)State.regs[srcreg]);
  sum = State.regs[REG_MCRL] + (temp & 0xffffffff);
  c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));
  State.regs[REG_MCRL] = sum;
  temp >>= 32;
  temp &= 0xffffffff;
  sum = State.regs[REG_MCRH] + temp + c;
  v = ((State.regs[REG_MCRH] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRH] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1011 0001 1011 Rn Rn IMM8; macu imm8,Rn
8.0xfb+8.0x1b+4.RN2,4.RN0=RN2+8.IMM8:D2:::macu
"macu"
*am33
*am33_2
{
  int srcreg;
  signed64 temp, sum;
  int c, v;

  PC = cia;
  srcreg = translate_rreg (SD_, RN2);

  temp = ((unsigned64) (IMM8)
          * (unsigned64)State.regs[srcreg]);
  sum = State.regs[REG_MCRL] + (temp & 0xffffffff);
  c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));
  State.regs[REG_MCRL] = sum;
  temp >>= 32;
  temp &= 0xffffffff;
  sum = State.regs[REG_MCRH] + temp + c;
  v = ((State.regs[REG_MCRH] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRH] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1011 0010 1011 Rn Rn IMM8; macb imm8,Rn
8.0xfb+8.0x2b+4.RN2,4.RN0=RN2+8.IMM8:D2:::macb
"macb"
*am33
*am33_2
{
  int srcreg;
  signed64 temp, sum;
  int c, v;

  PC = cia;
  srcreg = translate_rreg (SD_, RN2);

  temp = ((signed64)(signed8)EXTEND8 (IMM8)
          * (signed64)(signed8)State.regs[srcreg] & 0xff);
  sum = State.regs[REG_MCRL] + (temp & 0xffffffff);
  c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));
  State.regs[REG_MCRL] = sum;
  temp >>= 32;
  temp &= 0xffffffff;
  sum = State.regs[REG_MCRH] + temp + c;
  v = ((State.regs[REG_MCRH] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRH] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1011 0011 1011 Rn Rn IMM8; macbu imm8,Rn
8.0xfb+8.0x3b+4.RN2,4.RN0=RN2+8.IMM8:D2:::macbu
"macbu"
*am33
*am33_2
{
  int srcreg;
  signed64 temp, sum;
  int c, v;

  PC = cia;
  srcreg = translate_rreg (SD_, RN2);

  temp = ((unsigned64) (IMM8)
          * (unsigned64)State.regs[srcreg] & 0xff);
  sum = State.regs[REG_MCRL] + (temp & 0xffffffff);
  c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));
  State.regs[REG_MCRL] = sum;
  temp >>= 32;
  temp &= 0xffffffff;
  sum = State.regs[REG_MCRH] + temp + c;
  v = ((State.regs[REG_MCRH] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRH] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1011 0100 1011 Rn Rn IMM8; mach imm8,Rn
8.0xfb+8.0x4b+4.RN2,4.RN0=RN2+8.IMM8:D2:::mach
"mach"
*am33
*am33_2
{
  int srcreg;
  signed64 temp, sum;
  int c, v;

  PC = cia;
  srcreg = translate_rreg (SD_, RN2);

  temp = ((signed64)(signed16)EXTEND8 (IMM8)
          * (signed64)(signed16)State.regs[srcreg] & 0xffff);
  sum = State.regs[REG_MCRL] + (temp & 0xffffffff);
  c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));
  State.regs[REG_MCRL] = sum;
  temp >>= 32;
  temp &= 0xffffffff;
  sum = State.regs[REG_MCRH] + temp + c;
  v = ((State.regs[REG_MCRH] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRH] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1011 0101 1011 Rn Rn IMM8; machu imm8,Rn
8.0xfb+8.0x5b+4.RN2,4.RN0=RN2+8.IMM8:D2:::machu
"machu"
*am33
*am33_2
{
  int srcreg;
  signed64 temp, sum;
  int c, v;

  PC = cia;
  srcreg = translate_rreg (SD_, RN2);

  temp = ((unsigned64) (IMM8)
          * (unsigned64)State.regs[srcreg] & 0xffff);
  sum = State.regs[REG_MCRL] + (temp & 0xffffffff);
  c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));
  State.regs[REG_MCRL] = sum;
  temp >>= 32;
  temp &= 0xffffffff;
  sum = State.regs[REG_MCRH] + temp + c;
  v = ((State.regs[REG_MCRH] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRH] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1011 1011 1011 Rn Rn IMM8; mcste imm8,Rn
8.0xfb+8.0xbb+4.RN2,4.RN0=RN2+8.IMM8:D2:::mcste
"mcste"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  PSW &= ~(PSW_V | PSW_C);
  PSW |= (State.regs[REG_MCVF] ? PSW_V : 0);
  
  /* 32bit saturation.  */
  if (IMM8 == 0x20)
    {
      signed64 tmp;

      tmp = State.regs[REG_MCRH];
      tmp <<= 32;
      tmp += State.regs[REG_MCRL];

      if (tmp > 0x7fffffff)    
	State.regs[dstreg] = 0x7fffffff;
      else if (tmp < 0xffffffff80000000LL)
	State.regs[dstreg] = 0x80000000;
      else
	State.regs[dstreg] = tmp;
    }
  /* 16bit saturation */
  else if (IMM8 == 0x10)
    {
      signed64 tmp;

      tmp = State.regs[REG_MCRH];
      tmp <<= 32;
      tmp += State.regs[REG_MCRL];

      if (tmp > 0x7fff)    
	State.regs[dstreg] = 0x7fff;
      else if (tmp < 0xffffffffffff8000LL)
	State.regs[dstreg] = 0x8000;
      else
	State.regs[dstreg] = tmp;
    }
  /* 8 bit saturation */
  else if (IMM8 == 0x8)
    {
      signed64 tmp;

      tmp = State.regs[REG_MCRH];
      tmp <<= 32;
      tmp += State.regs[REG_MCRL];

      if (tmp > 0x7f)    
	State.regs[dstreg] = 0x7f;
      else if (tmp < 0xffffffffffffff80LL)
	State.regs[dstreg] = 0x80;
      else
	State.regs[dstreg] = tmp;
    }
  /* 9 bit saturation */
  else if (IMM8 == 0x9)
    {
      signed64 tmp;

      tmp = State.regs[REG_MCRH];
      tmp <<= 32;
      tmp += State.regs[REG_MCRL];

      if (tmp > 0x80)    
	State.regs[dstreg] = 0x80;
      else if (tmp < 0xffffffffffffff81LL)
	State.regs[dstreg] = 0x81;
      else
	State.regs[dstreg] = tmp;
    }
  /* 9 bit saturation */
  else if (IMM8 == 0x30)
    {
      signed64 tmp;

      tmp = State.regs[REG_MCRH];
      tmp <<= 32;
      tmp += State.regs[REG_MCRL];

      if (tmp > 0x7fffffffffffLL)    
	tmp = 0x7fffffffffffLL;
      else if (tmp < 0xffff800000000000LL)
	tmp = 0xffff800000000000LL;

      tmp >>= 16;
      State.regs[dstreg] = tmp;
    }
}

// 1111 1011 0111 1100 Rm Rn Rd; add Rm,Rn,Rd
8.0xfb+8.0x7c+4.RM2,4.RN0+4.RD0,4.0x0:D2c:::add
"add"
*am33
*am33_2
{
  int z, c, n, v;
  unsigned32 sum, source1, source2;
  int srcreg1, srcreg2, dstreg;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);
  dstreg = translate_rreg (SD_, RD0);

  source1 = State.regs[srcreg1];
  source2 = State.regs[srcreg2];
  sum = source1 + source2;
  State.regs[dstreg] = sum;

  z = (sum == 0);
  n = (sum & 0x80000000);
  c = (sum < source1) || (sum < source2);
  v = ((source1 & 0x80000000) == (source2 & 0x80000000)
       && (source1 & 0x80000000) != (sum & 0x80000000));

  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | ( n ? PSW_N : 0)
          | (c ? PSW_C : 0) | (v ? PSW_V : 0));
}

// 1111 1011 1000 1100 Rm Rn Rd; addc Rm,Rn,Rd
8.0xfb+8.0x8c+4.RM2,4.RN0+4.RD0,4.0x0:D2c:::addc
"addc"
*am33
*am33_2
{
  int z, c, n, v;
  unsigned32 sum, source1, source2;
  int srcreg1, srcreg2, dstreg;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);
  dstreg = translate_rreg (SD_, RD0);

  source1 = State.regs[srcreg1];
  source2 = State.regs[srcreg2];
  sum = source1 + source2 + ((PSW & PSW_C) != 0);
  State.regs[dstreg] = sum;

  z = ((PSW & PSW_Z) != 0) && (sum == 0);
  n = (sum & 0x80000000);
  c = (sum < source1) || (sum < source2);
  v = ((source1 & 0x80000000) == (source2 & 0x80000000)
       && (source1 & 0x80000000) != (sum & 0x80000000));

  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | ( n ? PSW_N : 0)
          | (c ? PSW_C : 0) | (v ? PSW_V : 0));
}

// 1111 1011 1001 1100 Rm Rn Rd; sub Rm,Rn,Rd
8.0xfb+8.0x9c+4.RM2,4.RN0+4.RD0,4.0x0:D2c:::sub
"sub"
*am33
*am33_2
{
  int z, c, n, v;
  unsigned32 difference, source1, source2;
  int srcreg1, srcreg2, dstreg;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);
  dstreg = translate_rreg (SD_, RD0);

  source1 = State.regs[srcreg1];
  source2 = State.regs[srcreg2];
  difference = source2 - source1;
  State.regs[dstreg] = difference;

  z = (difference == 0);
  n = (difference & 0x80000000);
  c = (source1 > source2);
  v = ((source1 & 0x80000000) == (source2 & 0x80000000)
       && (source1 & 0x80000000) != (difference & 0x80000000));

  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | ( n ? PSW_N : 0)
          | (c ? PSW_C : 0) | (v ? PSW_V : 0));
}

// 1111 1011 1010 1100 Rm Rn Rd; subc Rm,Rn,Rd
8.0xfb+8.0xac+4.RM2,4.RN0+4.RD0,4.0x0:D2c:::subc
"subc"
*am33
*am33_2
{
  int z, c, n, v;
  unsigned32 difference, source1, source2;
  int srcreg1, srcreg2, dstreg;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);
  dstreg = translate_rreg (SD_, RD0);

  source1 = State.regs[srcreg1];
  source2 = State.regs[srcreg2];
  difference = source2 - source1 - ((PSW & PSW_C) != 0);
  State.regs[dstreg] = difference;

  z = ((PSW & PSW_Z) != 0) && (difference == 0);
  n = (difference & 0x80000000);
  c = (source1 > source2);
  v = ((source1 & 0x80000000) == (source2 & 0x80000000)
       && (source1 & 0x80000000) != (difference & 0x80000000));

  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | ( n ? PSW_N : 0)
          | (c ? PSW_C : 0) | (v ? PSW_V : 0));
}

// 1111 1011 0000 1101 Rm Rn Rd; and Rm,Rn,Rd
8.0xfb+8.0x0d+4.RM2,4.RN0+4.RD0,4.0x0:D2c:::and
"and"
*am33
*am33_2
{
  int z, n;
  int srcreg1, srcreg2, dstreg;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);
  dstreg = translate_rreg (SD_, RD0);

  State.regs[dstreg] = State.regs[srcreg1] & State.regs[srcreg2];

  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000);

  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | ( n ? PSW_N : 0));
}

// 1111 1011 0001 1101 Rm Rn Rd; or Rm,Rn,Rd
8.0xfb+8.0x1d+4.RM2,4.RN0+4.RD0,4.0x0:D2c:::or
"or"
*am33
*am33_2
{
  int z, n;
  int srcreg1, srcreg2, dstreg;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);
  dstreg = translate_rreg (SD_, RD0);

  State.regs[dstreg] = State.regs[srcreg1] | State.regs[srcreg2];

  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000);

  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | ( n ? PSW_N : 0));
}

// 1111 1011 0010 1101 Rm Rn Rd; xor Rm,Rn,Rd
8.0xfb+8.0x2d+4.RM2,4.RN0+4.RD0,4.0x0:D2c:::xor
"xor"
*am33
*am33_2
{
  int z, n;
  int srcreg1, srcreg2, dstreg;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);
  dstreg = translate_rreg (SD_, RD0);

  State.regs[dstreg] = State.regs[srcreg1] ^ State.regs[srcreg2];

  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000);

  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | ( n ? PSW_N : 0));
}

// 1111 1011 0100 1101 Rm Rn Rd; asr Rm,Rn,Rd
8.0xfb+8.0x4d+4.RM2,4.RN0+4.RD0,4.0x0:D2c:::asr
"asr"
*am33
*am33_2
{
  int z, c, n;
  signed32 temp;
  int srcreg1, srcreg2, dstreg;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);
  dstreg = translate_rreg (SD_, RD0);

  temp = State.regs[srcreg2];
  c = temp & 1;
  temp >>= State.regs[srcreg1];
  State.regs[dstreg] = temp;

  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000);

  PSW &= ~(PSW_Z | PSW_N | PSW_C);
  PSW |= ((z ? PSW_Z : 0) | ( n ? PSW_N : 0));
}

// 1111 1011 0101 1101 Rm Rn Rd; lsr Rm,Rn,Rd
8.0xfb+8.0x5d+4.RM2,4.RN0+4.RD0,4.0x0:D2c:::lsr
"lsr"
*am33
*am33_2
{
  int z, c, n;
  int srcreg1, srcreg2, dstreg;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);
  dstreg = translate_rreg (SD_, RD0);

  c = State.regs[srcreg2] & 1;
  State.regs[dstreg] = State.regs[srcreg2] >> State.regs[srcreg1];

  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000);

  PSW &= ~(PSW_Z | PSW_N | PSW_C);
  PSW |= ((z ? PSW_Z : 0) | ( n ? PSW_N : 0));
}

// 1111 1011 0110 1101 Rm Rn Rd; asl Rm,Rn,Rd
8.0xfb+8.0x6d+4.RM2,4.RN0+4.RD0,4.0x0:D2c:::asl
"asl"
*am33
*am33_2
{
  int z, n;
  int srcreg1, srcreg2, dstreg;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);
  dstreg = translate_rreg (SD_, RD0);

  State.regs[dstreg] = State.regs[srcreg2] << State.regs[srcreg1];

  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000);

  PSW &= ~(PSW_Z | PSW_N | PSW_C);
  PSW |= ((z ? PSW_Z : 0) | ( n ? PSW_N : 0));
}

// 1111 1011 1010 1101 Rm Rn Rd1 Rd2; mul Rm,Rn,Rd1,Rd2
8.0xfb+8.0xad+4.RM2,4.RN0+4.RD0,4.RD2!RD0:D2c:::mul
"mul"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  signed64 temp;
  int n, z;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);
  dstreg1 = translate_rreg (SD_, RD0);
  dstreg2 = translate_rreg (SD_, RD2);

  temp = ((signed64)(signed32)State.regs[srcreg1]
          *  (signed64)(signed32)State.regs[srcreg2]);
  State.regs[dstreg2] = temp & 0xffffffff;
  State.regs[dstreg1] = (temp & 0xffffffff00000000LL) >> 32;

  z = (State.regs[dstreg1] == 0) && (State.regs[dstreg2] == 0);
  n = (State.regs[dstreg1] & 0x80000000);

  PSW &= ~(PSW_Z | PSW_N);
  PSW |= ((z ? PSW_Z : 0) | ( n ? PSW_N : 0));
}

// 1111 1011 1011 1101 Rm Rn Rd1 Rd2; mulu Rm,Rn,Rd1,Rd2
8.0xfb+8.0xbd+4.RM2,4.RN0+4.RD0,4.RD2!RD0:D2c:::mulu
"mulu"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  signed64 temp;
  int n, z;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);
  dstreg1 = translate_rreg (SD_, RD0);
  dstreg2 = translate_rreg (SD_, RD2);

  temp = ((unsigned64)State.regs[srcreg1]
          *  (unsigned64)State.regs[srcreg2]);
  State.regs[dstreg2] = temp & 0xffffffff;
  State.regs[dstreg1] = (temp & 0xffffffff00000000LL) >> 32;

  z = (State.regs[dstreg1] == 0) && (State.regs[dstreg2] == 0);
  n = (State.regs[dstreg1] & 0x80000000);

  PSW &= ~(PSW_Z | PSW_N);
  PSW |= ((z ? PSW_Z : 0) | ( n ? PSW_N : 0));
}

// 1111 1011 0000 1110 Rn 0000 abs8 ; mov (abs8),Rn
8.0xfb+8.0x0e+4.RN2,4.0x0+8.IMM8:D2p:::mov
"mov"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_word (IMM8);
}

// 1111 1011 0001 1110 Rm 0000 abs8 ; mov Rn,(abs8)
8.0xfb+8.0x1e+4.RM2,4.0x0+8.IMM8:D2q:::mov
"mov"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  store_word (IMM8, State.regs[srcreg]);
}

// 1111 1011 0010 1110 Rn 0000 abs8 ; movbu (abs8),Rn
8.0xfb+8.0x2e+4.RN2,4.0x0+8.IMM8:D2p:::movbu
"movbu"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_byte (IMM8);
}

// 1111 1011 0011 1110 Rm 0000 abs8 ; movbu Rn,(abs8)
8.0xfb+8.0x3e+4.RM2,4.0x0+8.IMM8:D2q:::movbu
"movbu"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  store_byte (IMM8, State.regs[srcreg]);
}

// 1111 1011 0100 1110 Rn 0000 abs8 ; movhu (abs8),Rn
8.0xfb+8.0x4e+4.RN2,4.0x0+8.IMM8:D2p:::movhu
"movhu"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_half (IMM8);
}

// 1111 1011 0101 1110 Rm 0000 abs8 ; movhu Rn,(abs8)
8.0xfb+8.0x5e+4.RM2,4.0x0+8.IMM8:D2q:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  store_half (IMM8, State.regs[srcreg]);
}

// 1111 1011 1000 1110 Ri Rm Rn; mov (Ri,Rm),Rn
8.0xfb+8.0x8e+4.RI0,4.RM0+4.RN0,4.0x0:D2r:::mov
"mov"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM0);
  srcreg2 = translate_rreg (SD_, RI0);
  dstreg = translate_rreg (SD_, RN0);
  State.regs[dstreg] = load_word (State.regs[srcreg1] + State.regs[srcreg2]);
}

// 1111 1011 1001 1110 Ri Rm Rn; mov Rn,(Ri,Rm)
8.0xfb+8.0x9e+4.RI0,4.RN0+4.RM0,4.0x0:D2s:::mov
"mov"
*am33
*am33_2
{
  int srcreg, dstreg1, dstreg2;

  PC = cia;
  srcreg = translate_rreg (SD_, RM0);
  dstreg1 = translate_rreg (SD_, RI0);
  dstreg2 = translate_rreg (SD_, RN0);
  store_word (State.regs[dstreg1] + State.regs[dstreg2], State.regs[srcreg]);
}

// 1111 1011 1010 1110 Ri Rm Rn; movbu (Ri,Rm),Rn
8.0xfb+8.0xae+4.RI0,4.RM0+4.RN0,4.0x0:D2r:::movbu
"movbu"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM0);
  srcreg2 = translate_rreg (SD_, RI0);
  dstreg = translate_rreg (SD_, RN0);
  State.regs[dstreg] = load_byte (State.regs[srcreg1] + State.regs[srcreg2]);
}

// 1111 1011 1011 1110 Ri Rm Rn; movbu Rn,(Ri,Rm)
8.0xfb+8.0xbe+4.RI0,4.RN0+4.RM0,4.0x0:D2s:::movbu
"movbu"
*am33
*am33_2
{
  int srcreg, dstreg1, dstreg2;

  PC = cia;
  srcreg = translate_rreg (SD_, RM0);
  dstreg1 = translate_rreg (SD_, RI0);
  dstreg2 = translate_rreg (SD_, RN0);
  store_byte (State.regs[dstreg1] + State.regs[dstreg2], State.regs[srcreg]);
}

// 1111 1011 1100 1110 Ri Rm Rn; movhu (Ri,Rm),Rn
8.0xfb+8.0xce+4.RI0,4.RM0+4.RN0,4.0x0:D2r:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM0);
  srcreg2 = translate_rreg (SD_, RI0);
  dstreg = translate_rreg (SD_, RN0);
  State.regs[dstreg] = load_half (State.regs[srcreg1] + State.regs[srcreg2]);
}

// 1111 1011 1101 1110 Ri Rm Rn; movhu Rn,(Ri,Rm)
8.0xfb+8.0xde+4.RI0,4.RN0+4.RM0,4.0x0:D2s:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg, dstreg1, dstreg2;

  PC = cia;
  srcreg = translate_rreg (SD_, RM0);
  dstreg1 = translate_rreg (SD_, RI0);
  dstreg2 = translate_rreg (SD_, RN0);
  store_half (State.regs[dstreg1] + State.regs[dstreg2], State.regs[srcreg]);
}

// 1111 1011 0000 1111 Rm Rn Rd1 Rd2; mac Rm,Rn,Rd1,Rd2
8.0xfb+8.0x0f+4.RM2,4.RN0+4.RD0,4.RD2!RD0:D2c:::mac
"mac"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  signed64 temp;
  unsigned32 sum;
  int c, v;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);
  dstreg1 = translate_rreg (SD_, RD0);
  dstreg2 = translate_rreg (SD_, RD2);

  temp = ((signed64)(signed32)State.regs[srcreg1]
          *  (signed64)(signed32)State.regs[srcreg2]);

  sum = State.regs[dstreg2] + (temp & 0xffffffff);
  c = (sum < State.regs[dstreg2]) || (sum < (temp & 0xffffffff));
  State.regs[dstreg2] = sum;
  temp >>= 32;
  temp &= 0xffffffff;
  sum = State.regs[dstreg1] + temp + c;
  v = ((State.regs[dstreg1] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[dstreg1] = sum;
  if (v)
    {
      State.regs[REG_MCVF] = 1;
      PSW &= ~(PSW_V);
      PSW |= (( v ? PSW_V : 0));
    }
}

// 1111 1011 0001 1111 Rm Rn Rd1 Rd2; macu Rm,Rn,Rd1,Rd2
8.0xfb+8.0x1f+4.RM2,4.RN0+4.RD0,4.RD2!RD0:D2c:::macu
"macu"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  signed64 temp;
  unsigned32 sum;
  int c, v;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);
  dstreg1 = translate_rreg (SD_, RD0);
  dstreg2 = translate_rreg (SD_, RD2);

  temp = ((unsigned64)State.regs[srcreg1]
          * (unsigned64)State.regs[srcreg2]);

  sum = State.regs[dstreg2] + (temp & 0xffffffff);
  c = (sum < State.regs[dstreg2]) || (sum < (temp & 0xffffffff));
  State.regs[dstreg2] = sum;
  temp >>= 32;
  temp &= 0xffffffff;
  sum = State.regs[dstreg1] + temp + c;
  v = ((State.regs[dstreg1] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[dstreg1] = sum;
  if (v)
    {
      State.regs[REG_MCVF] = 1;
      PSW &= ~(PSW_V);
      PSW |= (( v ? PSW_V : 0));
    }
}

// 1111 1011 0010 1111 Rm Rn Rd1; macb Rm,Rn,Rd1
8.0xfb+8.0x2f+4.RM2,4.RN0+4.RD0,4.0x0:D2c:::macb
"macb"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg;
  signed32 temp, sum;
  int v;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);
  dstreg = translate_rreg (SD_, RD0);

  temp = ((signed32)(State.regs[srcreg2] & 0xff)
          * (signed32)(State.regs[srcreg1] & 0xff));
  sum = State.regs[dstreg] + temp;
  v = ((State.regs[dstreg] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[dstreg] = sum;
  if (v)
    {
      State.regs[REG_MCVF] = 1;
      PSW &= ~(PSW_V);
      PSW |= ((v ? PSW_V : 0));
    }
}

// 1111 1011 0011 1111 Rm Rn Rd1; macbu Rm,Rn,Rd1
8.0xfb+8.0x3f+4.RM2,4.RN0+4.RD0,4.0x0:D2c:::macbu
"macbu"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg;
  signed32 temp, sum;
  int v;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);
  dstreg = translate_rreg (SD_, RD0);

  temp = ((unsigned32)(State.regs[srcreg2] & 0xff)
          * (unsigned32)(State.regs[srcreg1] & 0xff));
  sum = State.regs[dstreg] + temp;
  v = ((State.regs[dstreg] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[dstreg] = sum;
  if (v)
    {
      State.regs[REG_MCVF] = 1;
      PSW &= ~(PSW_V);
      PSW |= ((v ? PSW_V : 0));
    }
}

// 1111 1011 0100 1111 Rm Rn Rd1; mach Rm,Rn,Rd1,Rd2
8.0xfb+8.0x4f+4.RM2,4.RN0+4.RD0,4.RD2!RD0:D2c:::mach
"mach"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  signed64 temp, sum;
  int v;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);
  dstreg1 = translate_rreg (SD_, RD0);
  dstreg2 = translate_rreg (SD_, RD0);

  temp = ((signed32)(State.regs[srcreg2] & 0xffff)
          * (signed32)(State.regs[srcreg1] & 0xffff));
  State.regs[dstreg2] += (temp & 0xffffffff);
  sum = State.regs[dstreg1] + ((temp >> 32) & 0xffffffff);
  v = ((State.regs[dstreg1] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[dstreg1] = sum;
  if (v)
    {
      State.regs[REG_MCVF] = 1;
      PSW &= ~(PSW_V);
      PSW |= ((v ? PSW_V : 0));
    }
}

// 1111 1011 0101 1111 Rm Rn Rd1; machu Rm,Rn,Rd1,Rd2
8.0xfb+8.0x5f+4.RM2,4.RN0+4.RD0,4.RD2!RD0:D2c:::machu
"machu"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  signed64 temp, sum;
  int v;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);
  dstreg1 = translate_rreg (SD_, RD0);
  dstreg2 = translate_rreg (SD_, RD0);

  temp = ((unsigned32)(State.regs[srcreg2] & 0xffff)
          * (unsigned32)(State.regs[srcreg1] & 0xffff));
  State.regs[dstreg2] += (temp & 0xffffffff);
  sum = State.regs[dstreg1] + ((temp >> 32) & 0xffffffff);
  v = ((State.regs[dstreg1] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[dstreg1] = sum;
  if (v)
    {
      State.regs[REG_MCVF] = 1;
      PSW &= ~(PSW_V);
      PSW |= ((v ? PSW_V : 0));
    }
}

// 1111 1011 0110 1111 Rm Rn Rd1; dmach Rm,Rn,Rd1
8.0xfb+8.0x6f+4.RM2,4.RN0+4.RD0,4.0x0:D2c:::dmach
"dmach"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg;
  signed32 temp, temp2, sum;
  int v;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);
  dstreg = translate_rreg (SD_, RD0);

  temp = ((signed32)(State.regs[srcreg2] & 0xffff)
          * (signed32)(State.regs[srcreg1] & 0xffff));
  temp2 = ((signed32)((State.regs[srcreg1] >> 16) & 0xffff)
	   * (signed32)((State.regs[srcreg2] >> 16) & 0xffff));
  sum = temp + temp2 + State.regs[dstreg];
  v = ((State.regs[dstreg] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[dstreg] = sum;
  if (v)
    {
      State.regs[REG_MCVF] = 1;
      PSW &= ~(PSW_V);
      PSW |= ((v ? PSW_V : 0));
    }
}

// 1111 1011 0111 1111 Rm Rn Rd1; dmachu Rm,Rn,Rd1
8.0xfb+8.0x7f+4.RM2,4.RN0+4.RD0,4.0x0:D2c:::dmachu
"dmachu"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg;
  signed32 temp, temp2, sum;
  int v;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);
  dstreg = translate_rreg (SD_, RD0);

  temp = ((unsigned32)(State.regs[srcreg2] & 0xffff)
          * (unsigned32)(State.regs[srcreg1] & 0xffff));
  temp2 = ((unsigned32)((State.regs[srcreg1] >> 16) & 0xffff)
	   * (unsigned32)((State.regs[srcreg2] >> 16) & 0xffff));
  sum = temp + temp2 + State.regs[dstreg];
  v = ((State.regs[dstreg] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[dstreg] = sum;
  if (v)
    {
      State.regs[REG_MCVF] = 1;
      PSW &= ~(PSW_V);
      PSW |= ((v ? PSW_V : 0));
    }
}

// 1111 1011 1000 1111 Rm Rn Rd1 Rd2; dmulh Rm,Rn,Rd1,Rd2
8.0xfb+8.0x8f+4.RM2,4.RN0+4.RD0,4.RD2!RD0:D2c:::dmulh
"dmulh"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  signed64 temp;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);
  dstreg1 = translate_rreg (SD_, RD0);
  dstreg2 = translate_rreg (SD_, RD2);

  temp = ((signed32)(State.regs[srcreg1] & 0xffff)
          * (signed32)(State.regs[srcreg1] & 0xffff));
  State.regs[dstreg2] = temp;
  temp = ((signed32)((State.regs[srcreg1] >> 16) & 0xffff)
          * (signed32)((State.regs[srcreg1] >>16) & 0xffff));
  State.regs[dstreg1] = temp;
}

// 1111 1011 1001 1111 Rm Rn Rd1 Rd2; dmulhu Rm,Rn,Rd1,Rd2
8.0xfb+8.0x9f+4.RM2,4.RN0+4.RD0,4.RD2!RD0:D2c:::dmulhu
"dmulhu"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  signed64 temp;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);
  dstreg1 = translate_rreg (SD_, RD0);
  dstreg2 = translate_rreg (SD_, RD2);

  temp = ((unsigned32)(State.regs[srcreg1] & 0xffff)
          * (unsigned32)(State.regs[srcreg1] & 0xffff));
  State.regs[dstreg2] = temp;
  temp = ((unsigned32)((State.regs[srcreg1] >> 16) & 0xffff)
          * (unsigned32)((State.regs[srcreg1] >>16) & 0xffff));
  State.regs[dstreg1] = temp;
}

// 1111 1011 1010 1111 Rm Rn; sat24 Rm,Rn
8.0xfb+8.0xaf+4.RM2,4.RN0+8.0x0:D2:::sat24
"sat24"
*am33
*am33_2
{
  int srcreg, dstreg;
  int value, n, z;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);

  value = State.regs[srcreg];

  if (value >= 0x7fffff)
    State.regs[dstreg] = 0x7fffff;
  else if (value <= 0xff800000)
    State.regs[dstreg] = 0xff800000;
  else
    State.regs[dstreg] = value;

  n = (State.regs[dstreg] & 0x800000) != 0;
  z = (State.regs[dstreg] == 0);
  PSW &= ~(PSW_Z | PSW_N);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1011 1111 1111 Rm Rn Rd1; bsch Rm,Rn,Rd1
8.0xfb+8.0xff+4.RM2,4.RN0+4.RD0,4.0x0:D2c:::bsch
"bsch"
*am33
*am33_2
{
  int temp, c, i;
  int srcreg1, srcreg2, dstreg;
  int start;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM2);
  srcreg2 = translate_rreg (SD_, RN0);
  dstreg = translate_rreg (SD_, RD0);

  temp = State.regs[srcreg1];
  start = (State.regs[srcreg2] & 0x1f) - 1;
  if (start == -1)
    start = 31;

  c = 0;    
  for (i = start; i >= 0; i--)
    {
      if (temp & (1 << i))
	{
	  c = 1;
	  State.regs[dstreg] = i;
	  break;
	}
    }

  if (i < 0)
    {
      c = 0;
      State.regs[dstreg] = 0;
    }
  PSW &= ~(PSW_C);
  PSW |= (c ? PSW_C : 0);
}

// 1111 1101 0000 1000 Rn Rn IMM32; mov imm24,Rn
8.0xfd+8.0x08+4.RM2,4.RN0=RM2+8.IMM24A+8.IMM24B+8.IMM24C:D4t:::mov
"mov"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);
  State.regs[dstreg] = EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C));
}

// 1111 1101 0001 1000 Rn Rn IMM32; movu imm24,Rn
8.0xfd+8.0x18+4.RM2,4.RN0=RM2+8.IMM24A+8.IMM24B+8.IMM24C:D4k:::movu
"movu"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);
  State.regs[dstreg] = FETCH24 (IMM24A, IMM24B, IMM24C) & 0xffffff;
}

// 1111 1101 0111 1000 Rn Rn IMM32; add imm24,Rn
8.0xfd+8.0x78+4.RM2,4.RN0=RM2+8.IMM24A+8.IMM24B+8.IMM24C:D4c:::add
"add"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);
  genericAdd (EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C)), dstreg);
}

// 1111 1101 1000 1000 Rn Rn IMM32; addc imm24,Rn
8.0xfd+8.0x88+4.RM2,4.RN0=RM2+8.IMM24A+8.IMM24B+8.IMM24C:D4b:::addc
"addc"
*am33
*am33_2
{
  int dstreg, z, n, c, v;
  unsigned32 sum, imm, reg2;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  imm = EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C));
  reg2 = State.regs[dstreg];
  sum = imm + reg2 + ((PSW & PSW_C) != 0);
  State.regs[dstreg] = sum;

  z = ((PSW & PSW_Z) != 0) && (sum == 0);
  n = (sum & 0x80000000);
  c = (sum < imm) || (sum < reg2);
  v = ((reg2 & 0x80000000) == (imm & 0x80000000)
       && (reg2 & 0x80000000) != (sum & 0x80000000));

  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | ( n ? PSW_N : 0)
          | (c ? PSW_C : 0) | (v ? PSW_V : 0));
}

// 1111 1101 1001 1000 Rn Rn IMM32; sub imm24,Rn
8.0xfd+8.0x98+4.RM2,4.RN0=RM2+8.IMM24A+8.IMM24B+8.IMM24C:D4b:::sub
"sub"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);
  genericSub (EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C)), dstreg);
}

// 1111 1101 1010 1000 Rn Rn IMM32; subc imm24,Rn
8.0xfd+8.0xa8+4.RM2,4.RN0=RM2+8.IMM24A+8.IMM24B+8.IMM24C:D4b:::subc
"subc"
*am33
*am33_2
{
  int dstreg, z, n, c, v;
  unsigned32 difference, imm, reg2;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  imm = EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C));
  reg2 = State.regs[dstreg];
  difference = reg2 - imm - ((PSW & PSW_C) != 0);
  State.regs[dstreg] = difference;

  z = ((PSW & PSW_Z) != 0) && (difference == 0);
  n = (difference & 0x80000000);
  c = (imm > reg2);
  v = ((reg2 & 0x80000000) == (imm & 0x80000000)
       && (reg2 & 0x80000000) != (difference & 0x80000000));

  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | ( n ? PSW_N : 0)
          | (c ? PSW_C : 0) | (v ? PSW_V : 0));
}

// 1111 1101 1101 1000 Rn Rn IMM32; cmp imm24,Rn
8.0xfd+8.0xd8+4.RM2,4.RN0=RM2+8.IMM24A+8.IMM24B+8.IMM24C:D4b:::cmp
"cmp"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RN0);
  genericCmp (EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C)), State.regs[srcreg]);
}

// 1111 1101 1111 1000 XRn XRn IMM32; mov imm24,XRn
8.0xfd+8.0xf8+4.XRM2,4.XRN0=XRM2+8.IMM24A+8.IMM24B+8.IMM24C:D4o:::mov
"mov"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_xreg (SD_, XRN0);

  State.regs[dstreg] = FETCH24 (IMM24A, IMM24B, IMM24C) & 0xffffff;
}

// 1111 1101 0000 1001 Rn Rn IMM24; and imm24,Rn
8.0xfd+8.0x09+4.RM2,4.RN0=RM2+8.IMM24A+8.IMM24B+8.IMM24C:D4b:::and
"and"
*am33
*am33_2
{
  int dstreg;
  int z,n;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  State.regs[dstreg] &= (FETCH24 (IMM24A, IMM24B, IMM24C) & 0xffffff);
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1101 0001 1001 Rn Rn IMM24; or imm24,Rn
8.0xfd+8.0x19+4.RM2,4.RN0=RM2+8.IMM24A+8.IMM24B+8.IMM24C:D4b:::or
"or"
*am33
*am33_2
{
  int dstreg;
  int z,n;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  State.regs[dstreg] |= (FETCH24 (IMM24A, IMM24B, IMM24C) & 0xffffff);
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1101 0010 1001 Rn Rn IMM24; xor imm24,Rn
8.0xfd+8.0x29+4.RM2,4.RN0=RM2+8.IMM24A+8.IMM24B+8.IMM24C:D4b:::xor
"xor"
*am33
*am33_2
{
  int dstreg;
  int z,n;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  State.regs[dstreg] ^= (FETCH24 (IMM24A, IMM24B, IMM24C) & 0xffffff);
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1101 0100 1001 Rn Rn IMM24; asr imm24,Rn
8.0xfd+8.0x49+4.RM2,4.RN0=RM2+8.IMM24A+8.IMM24B+8.IMM24C:D4b:::asr
"asr"
*am33
*am33_2
{
  int dstreg;
  signed32 temp;
  int c, z, n;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  temp = State.regs[dstreg];
  c = temp & 1;
  temp >>= (FETCH24 (IMM24A, IMM24B, IMM24C));
  State.regs[dstreg] = temp;
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (c ? PSW_C : 0));
}


// 1111 1101 0101 1001 Rn Rn IMM24; lsr imm24,Rn
8.0xfd+8.0x59+4.RM2,4.RN0=RM2+8.IMM24A+8.IMM24B+8.IMM24C:D4b:::lsr
"lsr"
*am33
*am33_2
{
  int dstreg;
  int z, n, c;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  c = State.regs[dstreg] & 1;
  State.regs[dstreg] >>= (FETCH24 (IMM24A, IMM24B, IMM24C));
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (c ? PSW_C : 0));
}

// 1111 1101 0110 1001 Rn Rn IMM24; asl imm24,Rn
8.0xfd+8.0x69+4.RM2,4.RN0=RM2+8.IMM24A+8.IMM24B+8.IMM24C:D4b:::asl
"asl"
*am33
*am33_2
{
  int dstreg;
  int z, n;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  State.regs[dstreg] <<= (FETCH24 (IMM24A, IMM24B, IMM24C));
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1101 1010 1001 Rn Rn IMM24; mul imm24,Rn
8.0xfd+8.0xa9+4.RM2,4.RN0=RM2+8.IMM24A+8.IMM24B+8.IMM24C:D4b:::mul
"mul"
*am33
*am33_2
{
  int dstreg;
  unsigned64 temp;
  int z, n;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  temp = ((signed64)(signed32)State.regs[dstreg]
          *  (signed64)(signed32)EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C)));
  State.regs[dstreg] = temp & 0xffffffff;
  State.regs[REG_MDR] = (temp & 0xffffffff00000000LL) >> 32;
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1101 1011 1001 Rn Rn IMM24; mulu imm24,Rn
8.0xfd+8.0xb9+4.RM2,4.RN0=RM2+8.IMM24A+8.IMM24B+8.IMM24C:D4b:::mulu
"mulu"
*am33
*am33_2
{
  int dstreg;
  unsigned64 temp;
  int z, n;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  temp = ((unsigned64)State.regs[dstreg]
          *  (unsigned64)EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C)));
  State.regs[dstreg] = temp & 0xffffffff;
  State.regs[REG_MDR] = (temp & 0xffffffff00000000LL) >> 32;
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1101 1110 1001 Rn Rn IMM24; btst imm24,,Rn
8.0xfd+8.0xe9+4.RN2,4.RN0=RN2+8.IMM24A+8.IMM24B+8.IMM24C:D4p:::btst
"btst"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RN0);
  genericBtst (FETCH24 (IMM24A, IMM24B, IMM24C), State.regs[srcreg]);
}

// 1111 1101 0000 1010 Rn Rm IMM24; mov (d24,Rm),Rn
8.0xfd+8.0x0a+4.RN2,4.RM0+8.IMM24A+8.IMM24B+8.IMM24C:D4p:::mov
"mov"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM0);
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_word (State.regs[srcreg]
				  + EXTEND24 (FETCH24 (IMM24A,
						       IMM24B, IMM24C)));
}

// 1111 1101 0001 1010 Rm Rn IMM24; mov Rm,(d24,Rn)
8.0xfd+8.0x1a+4.RM2,4.RN0+8.IMM24A+8.IMM24B+8.IMM24C:D4q:::mov
"mov"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  store_word (State.regs[dstreg] + EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C)),
	      State.regs[srcreg]);
}

// 1111 1101 0010 1010 Rn Rm IMM24; movbu (d24,Rm),Rn
8.0xfd+8.0x2a+4.RN2,4.RM0+8.IMM24A+8.IMM24B+8.IMM24C:D4p:::movbu
"movbu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM0);
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_byte (State.regs[srcreg]
				  + EXTEND24 (FETCH24 (IMM24A,
						       IMM24B, IMM24C)));
}

// 1111 1101 0011 1010 Rm Rn IMM24; movbu Rm,(d24,Rn)
8.0xfd+8.0x3a+4.RM2,4.RN0+8.IMM24A+8.IMM24B+8.IMM24C:D4q:::movbu
"movbu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  store_byte (State.regs[dstreg] + EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C)),
	      State.regs[srcreg]);
}

// 1111 1101 0100 1010 Rn Rm IMM24; movhu (d24,Rm),Rn
8.0xfd+8.0x4a+4.RN2,4.RM0+8.IMM24A+8.IMM24B+8.IMM24C:D4p:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM0);
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_half (State.regs[srcreg]
				  + EXTEND24 (FETCH24 (IMM24A,
					      IMM24B, IMM24C)));
}

// 1111 1101 0101 1010 Rm Rn IMM24; movhu Rm,(d24,Rn)
8.0xfd+8.0x5a+4.RM2,4.RN0+8.IMM24A+8.IMM24B+8.IMM24C:D4q:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  store_half (State.regs[dstreg] + EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C)),
	      State.regs[srcreg]);
}

// 1111 1101 0110 1010 Rn Rm IMM24; mov (d24,Rm+),Rn
8.0xfd+8.0x6a+4.RN2,4.RM0!RN2+8.IMM24A+8.IMM24B+8.IMM24C:D4y:::mov
"mov"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM0);
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_word (State.regs[srcreg]);
  State.regs[srcreg] += EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C));
}

// 1111 1101 0111 1010 Rm Rn IMM24; mov Rm,(d24,Rn+)
8.0xfd+8.0x7a+4.RM2,4.RN0+8.IMM24A+8.IMM24B+8.IMM24C:D4z:::mov
"mov"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  store_word (State.regs[dstreg], State.regs[srcreg]);
  State.regs[dstreg] += EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C));
}


// 1111 1101 1000 1010 Rn 0000 IMM24; mov (d24,sp),Rn
8.0xfd+8.0x8a+4.RN2,4.0x0+IMM24A+8.IMM24B+8.IMM24C:D4r:::mov
"mov"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_word (State.regs[REG_SP]
				  + FETCH24 (IMM24A, IMM24B, IMM24C));
}

// 1111 1101 1001 1010 Rm 0000 IMM24; mov Rm,(d24,sp)
8.0xfd+8.0x9a+4.RM2,4.0x0+8.IMM24A+8.IMM24B+8.IMM24C:D4s:::mov
"mov"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  store_word (State.regs[REG_SP] + FETCH24 (IMM24A, IMM24B, IMM24C),
	      State.regs[srcreg]);
}

// 1111 1101 1010 1010 Rn 0000 IMM24; movbu (d24,sp),Rn
8.0xfd+8.0xaa+4.RN2,4.0x0+8.IMM24A+8.IMM24B+8.IMM24C:D4r:::movbu
"movbu"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_byte (State.regs[REG_SP]
				  + FETCH24 (IMM24A, IMM24B, IMM24C));
}

// 1111 1101 1011 1010 Rm 0000 IMM24; movbu Rm,(d24,sp)
8.0xfd+8.0xba+4.RM2,4.0x0+8.IMM24A+8.IMM24B+8.IMM24C:D4s:::movbu
"movbu"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  store_byte (State.regs[REG_SP] + FETCH24 (IMM24A, IMM24B, IMM24C),
	      State.regs[srcreg]);
}

// 1111 1101 1100 1010 Rn 0000 IMM24; movhu (d24,sp),Rn
8.0xfd+8.0xca+4.RN2,4.0x0+8.IMM24A+8.IMM24B+8.IMM24C:D4r:::movhu
"movhu"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_half (State.regs[REG_SP]
				  + FETCH24 (IMM24A, IMM24B, IMM24C));
}

// 1111 1101 1101 1010 Rm Rn IMM24; movhu Rm,(d24,sp)
8.0xfd+8.0xda+4.RM2,4.RN0+8.IMM24A+8.IMM24B+8.IMM24C:D4s:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  store_half (State.regs[REG_SP] + FETCH24 (IMM24A, IMM24B, IMM24C),
	      State.regs[srcreg]);
}

// 1111 1101 1110 1010 Rn Rm IMM24; movhu (d24,Rm+),Rn
8.0xfd+8.0xea+4.RN2,4.RM0!RN2+8.IMM24A+8.IMM24B+8.IMM24C:D4y:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM0);
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_half (State.regs[srcreg]);
  State.regs[dstreg] += EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C));
}

// 1111 1101 1111 1010 Rm Rn IMM24; movhu Rm,(d24,Rn+)
8.0xfd+8.0xfa+4.RM2,4.RN0+8.IMM24A+8.IMM24B+8.IMM24C:D4z:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  store_half (State.regs[dstreg], State.regs[srcreg]);
  State.regs[srcreg] += EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C));
}

// 1111 1101 0000 1011 Rn IMM24; mac imm24,Rn
8.0xfd+8.0x0b+4.RN2,4.RN0=RN2+8.IMM24A+8.IMM24B+8.IMM24C:D4z:::mac
"mac"
*am33
*am33_2
{
  int srcreg;
  signed64 temp, sum;
  int c, v;

  PC = cia;
  srcreg = translate_rreg (SD_, RN2);

  temp = ((signed64)EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C))
          * (signed64)State.regs[srcreg]);
  sum = State.regs[REG_MCRL] + (temp & 0xffffffff);
  c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));
  State.regs[REG_MCRL] = sum;
  temp >>= 32;
  temp &= 0xffffffff;
  sum = State.regs[REG_MCRH] + temp + c;
  v = ((State.regs[REG_MCRH] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRH] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1101 0001 1011 Rn IMM24; macu imm24,Rn
8.0xfd+8.0x1b+4.RN2,4.RN0=RN2+8.IMM24A+8.IMM24B+8.IMM24C:D4z:::macu
"macu"
*am33
*am33_2
{
  int srcreg;
  signed64 temp, sum;
  int c, v;

  PC = cia;
  srcreg = translate_rreg (SD_, RN2);

  temp = ((unsigned64) (FETCH24 (IMM24A, IMM24B, IMM24C))
          * (unsigned64)State.regs[srcreg]);
  sum = State.regs[REG_MCRL] + (temp & 0xffffffff);
  c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));
  State.regs[REG_MCRL] = sum;
  temp >>= 32;
  temp &= 0xffffffff;
  sum = State.regs[REG_MCRH] + temp + c;
  v = ((State.regs[REG_MCRH] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRH] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1101 0010 1011 Rn IMM24; macb imm24,Rn
8.0xfd+8.0x2b+4.RN2,4.RN0=RN2+8.IMM24A+8.IMM24B+8.IMM24C:D4z:::macb
"macb"
*am33
*am33_2
{
  int srcreg;
  signed64 temp, sum;
  int c, v;

  PC = cia;
  srcreg = translate_rreg (SD_, RN2);

  temp = ((signed64)EXTEND8 (FETCH24 (IMM24A, IMM24B, IMM24C))
          * (signed64)State.regs[srcreg] & 0xff);
  sum = State.regs[REG_MCRL] + (temp & 0xffffffff);
  c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));
  State.regs[REG_MCRL] = sum;
  temp >>= 32;
  temp &= 0xffffffff;
  sum = State.regs[REG_MCRH] + temp + c;
  v = ((State.regs[REG_MCRH] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRH] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1101 0011 1011 Rn IMM24; macbu imm24,Rn
8.0xfd+8.0x3b+4.RN2,4.RN0=RN2+8.IMM24A+8.IMM24B+8.IMM24C:D4z:::macbu
"macbu"
*am33
*am33_2
{
  int srcreg;
  signed64 temp, sum;
  int c, v;

  PC = cia;
  srcreg = translate_rreg (SD_, RN2);

  temp = ((unsigned64) (FETCH24 (IMM24A, IMM24B, IMM24C))
          * (unsigned64)State.regs[srcreg] & 0xff);
  sum = State.regs[REG_MCRL] + (temp & 0xffffffff);
  c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));
  State.regs[REG_MCRL] = sum;
  temp >>= 32;
  temp &= 0xffffffff;
  sum = State.regs[REG_MCRH] + temp + c;
  v = ((State.regs[REG_MCRH] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRH] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1101 0100 1011 Rn IMM24; mach imm24,Rn
8.0xfd+8.0x4b+4.RN2,4.RN0=RN2+8.IMM24A+8.IMM24B+8.IMM24C:D4z:::mach
"mach"
*am33
*am33_2
{
  int srcreg;
  signed64 temp, sum;
  int c, v;

  PC = cia;
  srcreg = translate_rreg (SD_, RN2);

  temp = ((signed64)EXTEND16 (FETCH24 (IMM24A, IMM24B, IMM24C))
          * (signed64)State.regs[srcreg] & 0xffff);
  sum = State.regs[REG_MCRL] + (temp & 0xffffffff);
  c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));
  State.regs[REG_MCRL] = sum;
  temp >>= 32;
  temp &= 0xffffffff;
  sum = State.regs[REG_MCRH] + temp + c;
  v = ((State.regs[REG_MCRH] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRH] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1101 0101 1011 Rn IMM24; machu imm24,Rn
8.0xfd+8.0x5b+4.RN2,4.RN0=RN2+8.IMM24A+8.IMM24B+8.IMM24C:D4z:::machu
"machu"
*am33
*am33_2
{
  int srcreg;
  signed64 temp, sum;
  int c, v;

  PC = cia;
  srcreg = translate_rreg (SD_, RN2);

  temp = ((unsigned64) (FETCH24 (IMM24A, IMM24B, IMM24C) & 0xffff)
          * (unsigned64)State.regs[srcreg] & 0xffff);
  sum = State.regs[REG_MCRL] + (temp & 0xffffffff);
  c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));
  State.regs[REG_MCRL] = sum;
  temp >>= 32;
  temp &= 0xffffffff;
  sum = State.regs[REG_MCRH] + temp + c;
  v = ((State.regs[REG_MCRH] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRH] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1101 0000 1110 Rn 0000 ABS24; mov (abs24),Rn
8.0xfd+8.0x0e+4.RN2,4.0x0+8.IMM24A+8.IMM24B+8.IMM24C:D4u:::mov
"mov"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_word (FETCH24 (IMM24A, IMM24B, IMM24C));
}

// 1111 1101 0001 1110 Rm 0000 ABS24; mov Rm,(abs24)
8.0xfd+8.0x1e+4.RM2,4.0x0+8.IMM24A+8.IMM24B+8.IMM24C:D4v:::mov
"mov"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  store_word (FETCH24 (IMM24A, IMM24B, IMM24C), State.regs[srcreg]);
}


// 1111 1101 0010 1110 Rn 0000 ABS24; movbu (abs24),Rn
8.0xfd+8.0x2e+4.RN2,4.0x0+8.IMM24A+8.IMM24B+8.IMM24C:D4t:::movbu
"movbu"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_byte (FETCH24 (IMM24A, IMM24B, IMM24C));
}

// 1111 1101 0011 1110 Rm 0000 ABS24; movbu Rm,(abs24)
8.0xfd+8.0x3e+4.RM2,4.0x0+8.IMM24A+8.IMM24B+8.IMM24C:D4u:::movbu
"movbu"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  store_byte (FETCH24 (IMM24A, IMM24B, IMM24C), State.regs[srcreg]);
}


// 1111 1101 0100 1110 Rn 0000 ABS24; movhu (abs24),Rn
8.0xfd+8.0x4e+4.RN2,4.0x0+8.IMM24A+8.IMM24B+8.IMM24C:D4t:::movhu
"movhu"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_half (FETCH24 (IMM24A, IMM24B, IMM24C));
}

// 1111 1101 0101 1110 Rm 0000 ABS24; movhu Rm,(abs24)
8.0xfd+8.0x5e+4.RM2,4.0x0+8.IMM24A+8.IMM24B+8.IMM24C:D4u:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  store_half (FETCH24 (IMM24A, IMM24B, IMM24C), State.regs[srcreg]);
}


// 1111 1110 0000 1000 Rn Rn IMM32; mov imm32,Rn
8.0xfe+8.0x08+4.RM2,4.RN0=RM2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::mov
"mov"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);
  State.regs[dstreg] = FETCH32(IMM32A, IMM32B, IMM32C, IMM32D);
}

// 1111 1110 0001 1000 Rn Rn IMM32; movu imm32,Rn
8.0xfe+8.0x18+4.RM2,4.RN0=RM2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::movu
"movu"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);
  State.regs[dstreg] = FETCH32(IMM32A, IMM32B, IMM32C, IMM32D);
}

// 1111 1110 0111 1000 Rn Rn IMM32; add imm32,Rn
8.0xfe+8.0x78+4.RM2,4.RN0=RM2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::add
"add"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);
  genericAdd (FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D), dstreg);
}

// 1111 1110 1000 1000 Rn Rn IMM32; addc imm32,Rn
8.0xfe+8.0x88+4.RM2,4.RN0=RM2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::addc
"addc"
*am33
*am33_2
{
  int dstreg;
  unsigned32 imm, reg2, sum;
  int z, n, c, v;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);
  reg2 = State.regs[dstreg];
  sum = imm + reg2 + ((PSW & PSW_C) != 0);
  State.regs[dstreg] = sum;

  z = ((PSW & PSW_Z) != 0) && (sum == 0);
  n = (sum & 0x80000000);
  c = (sum < imm) || (sum < reg2);
  v = ((reg2 & 0x80000000) == (imm & 0x80000000)
       && (reg2 & 0x80000000) != (sum & 0x80000000));

  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | ( n ? PSW_N : 0)
          | (c ? PSW_C : 0) | (v ? PSW_V : 0));
}

// 1111 1110 1001 1000 Rn Rn IMM32; sub imm32,Rn
8.0xfe+8.0x98+4.RM2,4.RN0=RM2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::sub
"sub"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);
  genericSub (FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D), dstreg);
}

// 1111 1110 1010 1000 Rn Rn IMM32; subc imm32,Rn
8.0xfe+8.0xa8+4.RM2,4.RN0=RM2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::subc
"subc"
*am33
*am33_2
{
  int dstreg;
  unsigned32 imm, reg2, difference;
  int z, n, c, v;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);
  reg2 = State.regs[dstreg];
  difference = reg2 - imm - ((PSW & PSW_C) != 0);
  State.regs[dstreg] = difference;

  z = ((PSW & PSW_Z) != 0) && (difference == 0);
  n = (difference & 0x80000000);
  c = (imm > reg2);
  v = ((reg2 & 0x80000000) == (imm & 0x80000000)
       && (reg2 & 0x80000000) != (difference & 0x80000000));

  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | ( n ? PSW_N : 0)
          | (c ? PSW_C : 0) | (v ? PSW_V : 0));
}

// 1111 1110 0111 1000 Rn Rn IMM32; cmp imm32,Rn
8.0xfe+8.0xd8+4.RM2,4.RN0=RM2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::cmp
"cmp"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RN0);
  genericCmp (FETCH32(IMM32A, IMM32B, IMM32C, IMM32D), State.regs[srcreg]);
}

// 1111 1110 1111 1000 XRn XRn IMM32; mov imm32,XRn
8.0xfe+8.0xf8+4.XRM2,4.XRN0=XRM2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5b:::mov
"mov"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_xreg (SD_, XRN0);

  State.regs[dstreg] = FETCH32(IMM32A, IMM32B, IMM32C, IMM32D);
}

// 1111 1110 0000 1001 Rn Rn IMM32; and imm32,Rn
8.0xfe+8.0x09+4.RM2,4.RN0=RM2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::and
"and"
*am33
*am33_2
{
  int dstreg;
  int z,n;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  State.regs[dstreg] &= (FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D));
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1110 0001 1001 Rn Rn IMM32; or imm32,Rn
8.0xfe+8.0x19+4.RM2,4.RN0=RM2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::or
"or"
*am33
*am33_2
{
  int dstreg;
  int z,n;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  State.regs[dstreg] |= (FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D));
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1110 0010 1001 Rn Rn IMM32; xor imm32,Rn
8.0xfe+8.0x29+4.RM2,4.RN0=RM2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::xor
"xor"
*am33
*am33_2
{
  int dstreg;
  int z,n;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  State.regs[dstreg] ^= (FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D));
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1110 0100 1001 Rn Rn IMM32; asr imm32,Rn
8.0xfe+8.0x49+4.RM2,4.RN0=RM2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::asr
"asr"
*am33
*am33_2
{
  int dstreg;
  signed32 temp;
  int c, z, n;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  temp = State.regs[dstreg];
  c = temp & 1;
  temp >>= (FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D));
  State.regs[dstreg] = temp;
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (c ? PSW_C : 0));
}

// 1111 1110 0101 1001 Rn Rn IMM32; lsr imm32,Rn
8.0xfe+8.0x59+4.RM2,4.RN0=RM2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::lsr
"lsr"
*am33
*am33_2
{
  int dstreg;
  int z, n, c;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  c = State.regs[dstreg] & 1;
  State.regs[dstreg] >>= (FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D));
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0) | (c ? PSW_C : 0));
}

// 1111 1110 0110 1001 Rn Rn IMM32; asl imm32,Rn
8.0xfe+8.0x69+4.RM2,4.RN0=RM2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::asl
"asl"
*am33
*am33_2
{
  int dstreg;
  int z, n;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  State.regs[dstreg] <<= (FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D));
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1110 1010 1001 Rn Rn IMM32; mul imm32,Rn
8.0xfe+8.0xa9+4.RM2,4.RN0=RM2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::mul
"mul"
*am33
*am33_2
{
  int dstreg;
  unsigned64 temp;
  int z, n;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  temp = ((signed64)(signed32)State.regs[dstreg]
          *  (signed64)(signed32)(FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D)));
  State.regs[dstreg] = temp & 0xffffffff;
  State.regs[REG_MDR] = (temp & 0xffffffff00000000LL) >> 32;
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1110 1011 1001 Rn Rn IMM32; mulu imm32,Rn
8.0xfe+8.0xb9+4.RM2,4.RN0=RM2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::mulu
"mulu"
*am33
*am33_2
{
  int dstreg;
  unsigned64 temp;
  int z, n;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);

  temp = ((unsigned64)State.regs[dstreg]
          *  (unsigned64) (FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D)));
  State.regs[dstreg] = temp & 0xffffffff;
  State.regs[REG_MDR] = (temp & 0xffffffff00000000LL) >> 32;
  z = (State.regs[dstreg] == 0);
  n = (State.regs[dstreg] & 0x80000000) != 0;
  PSW &= ~(PSW_Z | PSW_N | PSW_C | PSW_V);
  PSW |= ((z ? PSW_Z : 0) | (n ? PSW_N : 0));
}

// 1111 1110 1110 1001 Rn Rn IMM32; btst imm32,Rn
8.0xfe+8.0xe9+4.RM2,4.RN0=RM2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5a:::btst
"btst"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RN0);
  genericBtst (FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D), State.regs[srcreg]);
}

// 1111 1110 0000 1010 Rn Rm IMM32; mov (d32,Rm),Rn
8.0xfe+8.0x0a+4.RN2,4.RM0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5f:::mov
"mov"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM0);
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_word (State.regs[srcreg]
				  + FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D));
}

// 1111 1110 0001 1010 Rm Rn IMM32; mov Rm,(d32,Rn)
8.0xfe+8.0x1a+4.RM2,4.RN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5g:::mov
"mov"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  store_word (State.regs[dstreg] + FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D),
	      State.regs[srcreg]);
}

// 1111 1110 0010 1010 Rn Rm IMM32; movbu (d32,Rm),Rn
8.0xfe+8.0x2a+4.RN2,4.RM0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::movbu
"movbu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM0);
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_byte (State.regs[srcreg]
				  + FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D));
}

// 1111 1110 0011 1010 Rm Rn IMM32; movbu Rm,(d32,Rn)
8.0xfe+8.0x3a+4.RM2,4.RN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5b:::movbu
"movbu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  store_byte (State.regs[dstreg] + FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D),
	      State.regs[srcreg]);
}

// 1111 1110 0100 1010 Rn Rm IMM32; movhu (d32,Rm),Rn
8.0xfe+8.0x4a+4.RN2,4.RM0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM0);
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_half (State.regs[srcreg]
				  + FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D));
}

// 1111 1110 0101 1010 Rm Rn IMM32; movhu Rm,(d32,Rn)
8.0xfe+8.0x5a+4.RM2,4.RN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5b:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  store_half (State.regs[dstreg] + FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D),
	      State.regs[srcreg]);
}

// 1111 1110 0110 1010 Rn Rm IMM32; mov (d32,Rm+),Rn
8.0xfe+8.0x6a+4.RN2,4.RM0!RN2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5y:::mov
"mov"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM0);
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_word (State.regs[srcreg]);
  State.regs[srcreg] += FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);
}

// 1111 1110 0111 1010 Rm Rn IMM32; mov Rm,(d32,Rn+)
8.0xfe+8.0x7a+4.RM2,4.RN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5z:::mov
"mov"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  store_word (State.regs[dstreg], State.regs[srcreg]);
  State.regs[dstreg] += FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);
}


// 1111 1110 1000 1010 Rn 0000 IMM32; mov (d32,sp),Rn
8.0xfe+8.0x8a+4.RN2,4.0x0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5c:::mov
"mov"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_word (State.regs[REG_SP]
				  + FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D));
}

// 1111 1110 1001 1010 Rm 0000 IMM32; mov Rm,(d32,sp)
8.0xfe+8.0x9a+4.RM2,4.0x0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5d:::mov
"mov"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  store_word (State.regs[REG_SP] + FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D),
	      State.regs[srcreg]);
}

// 1111 1110 1010 1010 Rn 0000 IMM32; movbu (d32,sp),Rn
8.0xfe+8.0xaa+4.RN2,4.0x0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5c:::movbu
"movbu"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_byte (State.regs[REG_SP]
				  + FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D));
}

// 1111 1110 1011 1010 Rm 0000 IMM32; movbu Rm,(d32,sp)
8.0xfe+8.0xba+4.RM2,4.0x0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5d:::movbu
"movbu"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  store_byte (State.regs[REG_SP] + FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D),
	      State.regs[srcreg]);
}

// 1111 1110 1100 1010 Rn 0000 IMM32; movhu (d32,sp),Rn
8.0xfe+8.0xca+4.RN2,4.0x0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5c:::movhu
"movhu"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_half (State.regs[REG_SP]
				  + FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D));
}

// 1111 1110 1101 1010 Rm 0000 IMM32; movhu Rm,(d32,sp)
8.0xfe+8.0xda+4.RM2,4.0x0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5d:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  store_half (State.regs[REG_SP] + FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D),
	      State.regs[srcreg]);
}


// 1111 1110 1110 1010 Rn Rm IMM32; movhu (d32,Rm+),Rn
8.0xfe+8.0xea+4.RN2,4.RM0!RN2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5y:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM0);
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_half (State.regs[srcreg]);
  State.regs[srcreg] += FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);
}

// 1111 1110 1111 1010 Rm Rn IMM32; movhu Rm,(d32,Rn+)
8.0xfe+8.0xfa+4.RM2,4.RN0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5f:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  dstreg = translate_rreg (SD_, RN0);
  store_half (State.regs[dstreg], State.regs[srcreg]);
  State.regs[dstreg] += FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);
}


// 1111 1110 0000 1011 Rn Rn IMM32; mac imm32,Rn
8.0xfe+8.0x0b+4.RN2,4.RN0=RN2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::mac
"mac"
*am33
*am33_2
{
  int srcreg, imm;
  signed64 temp, sum;
  int c, v;

  PC = cia;
  srcreg = translate_rreg (SD_, RN0);
  imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);

  temp = ((signed64)(signed32)State.regs[srcreg]
          * (signed64)(signed32)imm);
  sum = State.regs[REG_MCRL] + (temp & 0xffffffff);
  c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));
  State.regs[REG_MCRL] = sum;
  temp >>= 32;
  temp &= 0xffffffff;
  sum = State.regs[REG_MCRH] + temp + c;
  v = ((State.regs[REG_MCRH] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRH] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1110 0001 1011 Rn Rn IMM32; macu imm32,Rn
8.0xfe+8.0x1b+4.RN2,4.RN0=RN2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::macu
"macu"
*am33
*am33_2
{
  int srcreg, imm;
  signed64 temp, sum;
  int c, v;

  PC = cia;
  srcreg = translate_rreg (SD_, RN0);
  imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);

  temp = ((unsigned64)State.regs[srcreg]
          * (unsigned64)imm);
  sum = State.regs[REG_MCRL] + (temp & 0xffffffff);
  c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));
  State.regs[REG_MCRL] = sum;
  temp >>= 32;
  temp &= 0xffffffff;
  sum = State.regs[REG_MCRH] + temp + c;
  v = ((State.regs[REG_MCRH] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRH] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1110 0010 1011 Rn Rn IMM32; macb imm32,Rn
8.0xfe+8.0x2b+4.RN2,4.RN0=RN2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::macb
"macb"
*am33
*am33_2
{
  int srcreg, imm;
  signed32 temp, sum;
  int v;

  PC = cia;
  srcreg = translate_rreg (SD_, RN0);
  imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);

  temp = ((signed32)(signed8)(State.regs[srcreg] & 0xff)
          * (signed32)(signed8)(imm & 0xff));
  sum = State.regs[REG_MCRL] + temp;
  v = ((State.regs[REG_MCRL] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRL] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1110 0011 1011 Rn Rn IMM32; macbu imm32,Rn
8.0xfe+8.0x3b+4.RN2,4.RN0=RN2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::macbu
"macbu"
*am33
*am33_2
{
  int srcreg, imm;
  signed32 temp, sum;
  int v;

  PC = cia;
  srcreg = translate_rreg (SD_, RN0);
  imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);

  temp = ((unsigned32)(State.regs[srcreg] & 0xff)
          * (unsigned32)(imm & 0xff));
  sum = State.regs[REG_MCRL] + temp;
  v = ((State.regs[REG_MCRL] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRL] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1110 0100 1011 Rn Rn IMM32; mach imm32,Rn
8.0xfe+8.0x4b+4.RN2,4.RN0=RN2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::mach
"mach"
*am33
*am33_2
{
  int srcreg, imm;
  signed32 temp, sum;
  int v;

  PC = cia;
  srcreg = translate_rreg (SD_, RN0);
  imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);

  temp = ((signed32)(signed16)(State.regs[srcreg] & 0xffff)
          * (signed32)(signed16)(imm & 0xffff));
  sum = State.regs[REG_MCRL] + temp;
  v = ((State.regs[REG_MCRL] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRL] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1110 0101 1011 Rn Rn IMM32; machu imm32,Rn
8.0xfe+8.0x5b+4.RN2,4.RN0=RN2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::machu
"machu"
*am33
*am33_2
{
  int srcreg, imm;
  signed32 temp, sum;
  int v;

  PC = cia;
  srcreg = translate_rreg (SD_, RN0);
  imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);

  temp = ((unsigned32)(State.regs[srcreg] & 0xffff)
          * (unsigned32)(imm & 0xffff));
  sum = State.regs[REG_MCRL] + temp;
  v = ((State.regs[REG_MCRL] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRL] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1110 0110 1011 Rn Rn IMM32; dmach imm32,Rn
8.0xfe+8.0x6b+4.RN2,4.RN0=RN2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::dmach
"dmach"
*am33
*am33_2
{
  int srcreg, imm;
  signed32 temp, temp2, sum;
  int v;

  PC = cia;
  srcreg = translate_rreg (SD_, RN0);
  imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);

  temp = ((signed32)(signed16)(State.regs[srcreg] & 0xffff)
          * (signed32)(signed16)(imm & 0xffff));
  temp2 = ((signed32)(signed16)((State.regs[srcreg] >> 16) & 0xffff)
	   * (signed32)(signed16)((imm >> 16) & 0xffff));
  sum = temp + temp2 + State.regs[REG_MCRL];
  v = ((State.regs[REG_MCRL] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRL] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1110 0111 1011 Rn Rn IMM32; dmachu imm32,Rn
8.0xfe+8.0x7b+4.RN2,4.RN0=RN2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::dmachu
"dmachu"
*am33
*am33_2
{
  int srcreg, imm;
  signed32 temp, temp2, sum;
  int v;

  PC = cia;
  srcreg = translate_rreg (SD_, RN0);
  imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);

  temp = ((unsigned32)(State.regs[srcreg] & 0xffff)
          * (unsigned32)(imm & 0xffff));
  temp2 = ((unsigned32)((State.regs[srcreg] >> 16) & 0xffff)
	   * (unsigned32)((imm >> 16) & 0xffff));
  sum = temp + temp2 + State.regs[REG_MCRL];
  v = ((State.regs[REG_MCRL] & 0x80000000) == (temp & 0x80000000)
        && (temp & 0x80000000) != (sum & 0x80000000));
  State.regs[REG_MCRL] = sum;
  if (v)
    State.regs[REG_MCVF] = 1;
}

// 1111 1110 1000 1011 Rn Rn IMM32; dmulh imm32,Rn
8.0xfe+8.0x8b+4.RN2,4.RN0=RN2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::dmulh
"dmulh"
*am33
*am33_2
{
  int imm, dstreg;
  signed32 temp;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);
  imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);

  temp = ((signed32)(signed16)(State.regs[dstreg] & 0xffff)
          * (signed32)(signed16)(imm & 0xffff));
  State.regs[REG_MDRQ] = temp;
  temp = ((signed32)(signed16)((State.regs[dstreg] >> 16) & 0xffff)
          * (signed32)(signed16)((imm>>16) & 0xffff));
  State.regs[dstreg] = temp;
}

// 1111 1110 1001 1011 Rn Rn IMM32; dmulhu imm32,Rn
8.0xfe+8.0x9b+4.RN2,4.RN0=RN2+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5:::dmulhu
"dmulhu"
*am33
*am33_2
{
  int imm, dstreg;
  signed32 temp;

  PC = cia;
  dstreg = translate_rreg (SD_, RN0);
  imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);

  temp = ((unsigned32)(State.regs[dstreg] & 0xffff)
          * (unsigned32)(imm & 0xffff));
  State.regs[REG_MDRQ] = temp;
  temp = ((unsigned32)((State.regs[dstreg] >> 16) & 0xffff)
          * (unsigned32)((imm >>16) & 0xffff));
  State.regs[dstreg] = temp;
}

// 1111 1110 0000 1110 Rn 0000 IMM32; mov (abs32),Rn
8.0xfe+8.0x0e+4.RN2,4.0x0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5h:::mov
"mov"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_word (FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D));
}

// 1111 1110 0001 1110 Rm 0000 IMM32; mov Rn,(abs32)
8.0xfe+8.0x1e+4.RM2,4.0x0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5e:::mov
"mov"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  store_word (FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D), State.regs[srcreg]);
}

// 1111 1110 0020 1110 Rn 0000 IMM32; movbu (abs32),Rn
8.0xfe+8.0x2e+4.RN2,4.0x0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5i:::movbu
"movbu"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_byte (FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D));
}

// 1111 1110 0011 1110 Rm 0000 IMM32; movbu Rn,(abs32)
8.0xfe+8.0x3e+4.RM2,4.0x0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5e:::movbu
"movbu"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  store_byte (FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D), State.regs[srcreg]);
}

// 1111 1110 0100 1110 Rn 0000 IMM32; movhu (abs32),Rn
8.0xfe+8.0x4e+4.RN2,4.0x0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5j:::movhu
"movhu"
*am33
*am33_2
{
  int dstreg;

  PC = cia;
  dstreg = translate_rreg (SD_, RN2);
  State.regs[dstreg] = load_half (FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D));
}

// 1111 1110 0101 1110 Rm 0000 IMM32; movhu Rn,(abs32)
8.0xfe+8.0x5e+4.RM2,4.0x0+8.IMM32A+8.IMM32B+8.IMM32C+8.IMM32D:D5e:::movhu
"movhu"
*am33
*am33_2
{
  int srcreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM2);
  store_half (FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D), State.regs[srcreg]);
}

// 1111 0111 0000 0000 Rm1 Rn1 Rm2 Rn2; add_add Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x00+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::add_add
"add_add"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] + State.regs[srcreg1];
  State.regs[dstreg2] += State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0001 0000 Rm1 Rn1 imm4 Rn2; add_add Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x10+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::add_add
"add_add"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] + State.regs[srcreg1];
  State.regs[dstreg2] += EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0010 0000 Rm1 Rn1 Rm2 Rn2; add_sub Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x20+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::add_sub
"add_sub"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] + State.regs[srcreg1];
  State.regs[dstreg2] -= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0011 0000 Rm1 Rn1 imm4 Rn2; add_sub Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x30+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::add_sub
"add_sub"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] + State.regs[srcreg1];
  State.regs[dstreg2] -= EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0100 0000 Rm1 Rn1 Rm2 Rn2; add_cmp Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x40+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::add_cmp
"add_cmp"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (State.regs[srcreg2], State.regs[dstreg2]);
  State.regs[dstreg1] += State.regs[srcreg1];
}

// 1111 0111 0101 0000 Rm1 Rn1 imm4 Rn2; add_cmp Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x50+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::add_cmp
"add_cmp"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (EXTEND4 (IMM4), State.regs[dstreg2]);
  State.regs[dstreg1] += State.regs[srcreg1];
}
  
// 1111 0111 0110 0000 Rm1 Rn1 Rm2 Rn2; add_mov Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x60+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::add_mov
"add_mov"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] + State.regs[srcreg1];
  State.regs[dstreg2] = State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0111 0000 Rm1 Rn1 imm4 Rn2; add_mov Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x70+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::add_mov
"add_mov"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] + State.regs[srcreg1];
  State.regs[dstreg2] = EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 1000 0000 Rm1 Rn1 Rm2 Rn2; add_asr Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x80+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::add_asr
"add_asr"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;
  signed int temp;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] + State.regs[srcreg1];
  temp = State.regs[dstreg2];
  temp >>= State.regs[srcreg2];
  State.regs[dstreg2] = temp;
  State.regs[dstreg1] = result1;
}

// 1111 0111 1001 0000 Rm1 Rn1 imm4 Rn2; add_asr Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x90+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::add_asr
"add_asr"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;
  signed int temp;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] + State.regs[srcreg1];
  temp = State.regs[dstreg2];
  temp >>= IMM4;
  State.regs[dstreg2] = temp;
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 1010 0000 Rm1 Rn1 Rm2 Rn2; add_lsr Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0xa0+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::add_lsr
"add_lsr"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] + State.regs[srcreg1];
  State.regs[dstreg2] >>= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 1011 0000 Rm1 Rn1 imm4 Rn2; add_lsr Rm1, Rn1, imm4, Rn2
8.0xf7+8.0xb0+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::add_lsr
"add_lsr"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] + State.regs[srcreg1];
  State.regs[dstreg2] >>= IMM4;
  State.regs[dstreg1] = result1;
}
  
  
// 1111 0111 1100 0000 Rm1 Rn1 Rm2 Rn2; add_asl Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0xc0+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::add_asl
"add_asl"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] + State.regs[srcreg1];
  State.regs[dstreg2] <<= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 1101 0000 Rm1 Rn1 imm4 Rn2; add_asl Rm1, Rn1, imm4, Rn2
8.0xf7+8.0xd0+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::add_asl
"add_asl"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] + State.regs[srcreg1];
  State.regs[dstreg2] <<= IMM4;
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0000 0001 Rm1 Rn1 Rm2 Rn2; cmp_add Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x01+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::cmp_add
"cmp_add"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (State.regs[srcreg1], State.regs[dstreg1]);
  State.regs[dstreg2] += State.regs[srcreg2];
}

// 1111 0111 0001 0001 Rm1 Rn1 imm4 Rn2; cmp_add Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x11+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::cmp_add
"cmp_add"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (State.regs[srcreg1], State.regs[dstreg1]);
  State.regs[dstreg2] += EXTEND4 (IMM4);
}
  
// 1111 0111 0010 0001 Rm1 Rn1 Rm2 Rn2; cmp_sub Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x21+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::cmp_sub
"cmp_sub"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (State.regs[srcreg1], State.regs[dstreg1]);
  State.regs[dstreg2] -= State.regs[srcreg2];
}

// 1111 0111 0011 0001 Rm1 Rn1 imm4 Rn2; cmp_sub Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x31+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::cmp_sub
"cmp_sub"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (State.regs[srcreg1], State.regs[dstreg1]);
  State.regs[dstreg2] -= EXTEND4 (IMM4);
}
  
// 1111 0111 0110 0001 Rm1 Rn1 Rm2 Rn2; cmp_mov Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x61+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::cmp_mov
"cmp_mov"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (State.regs[srcreg1], State.regs[dstreg1]);
  State.regs[dstreg2] = State.regs[srcreg2];
}

// 1111 0111 0111 0001 Rm1 Rn1 imm4 Rn2; cmp_mov Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x71+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::cmp_mov
"cmp_mov"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (State.regs[srcreg1], State.regs[dstreg1]);
  State.regs[dstreg2] = EXTEND4 (IMM4);
}
  
// 1111 0111 1000 0001 Rm1 Rn1 Rm2 Rn2; cmp_asr Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x81+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::cmp_asr
"cmp_asr"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  signed int temp;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (State.regs[srcreg1], State.regs[dstreg1]);
  temp = State.regs[dstreg2];
  temp >>= State.regs[srcreg2];
  State.regs[dstreg2] = temp;
}

// 1111 0111 1001 0001 Rm1 Rn1 imm4 Rn2; cmp_asr Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x91+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::cmp_asr
"cmp_asr"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  signed int temp;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (State.regs[srcreg1], State.regs[dstreg1]);
  temp = State.regs[dstreg2];
  temp >>= IMM4;
  State.regs[dstreg2] = temp;
}

// 1111 0111 1010 0001 Rm1 Rn1 Rm2 Rn2; cmp_lsr Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0xa1+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::cmp_lsr
"cmp_lsr"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (State.regs[srcreg1], State.regs[dstreg1]);
  State.regs[dstreg2] >>= State.regs[srcreg2];
}

// 1111 0111 1011 0001 Rm1 Rn1 imm4 Rn2; cmp_lsr Rm1, Rn1, imm4, Rn2
8.0xf7+8.0xb1+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::cmp_lsr
"cmp_lsr"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (State.regs[srcreg1], State.regs[dstreg1]);
  State.regs[dstreg2] >>= IMM4;
}
  
  
// 1111 0111 1100 0001 Rm1 Rn1 Rm2 Rn2; cmp_asl Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0xc1+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::cmp_asl
"cmp_asl"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (State.regs[srcreg1], State.regs[dstreg1]);
  State.regs[dstreg2] <<= State.regs[srcreg2];
}

// 1111 0111 1101 0001 Rm1 Rn1 imm4 Rn2; cmp_asl Rm1, Rn1, imm4, Rn2
8.0xf7+8.0xd1+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::cmp_asl
"cmp_asl"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (State.regs[srcreg1], State.regs[dstreg1]);
  State.regs[dstreg2] <<= IMM4;
}

// 1111 0111 0000 0010 Rm1 Rn1 Rm2 Rn2; sub_add Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x02+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::sub_add
"sub_add"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] - State.regs[srcreg1];
  State.regs[dstreg2] += State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0001 0010 Rm1 Rn1 imm4 Rn2; sub_add Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x12+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::sub_add
"sub_add"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] - State.regs[srcreg1];
  State.regs[dstreg2] += EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0010 0010 Rm1 Rn1 Rm2 Rn2; sub_sub Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x22+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::sub_sub
"sub_sub"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] - State.regs[srcreg1];
  State.regs[dstreg2] -= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0011 0010 Rm1 Rn1 imm4 Rn2; sub_sub Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x32+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::sub_sub
"sub_sub"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] - State.regs[srcreg1];
  State.regs[dstreg2] -= EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0100 0010 Rm1 Rn1 Rm2 Rn2; sub_cmp Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x42+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::sub_cmp
"sub_cmp"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (State.regs[srcreg2], State.regs[dstreg2]);
  State.regs[dstreg1] -= State.regs[srcreg1];
}

// 1111 0111 0101 0010 Rm1 Rn1 imm4 Rn2; sub_cmp Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x52+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::sub_cmp
"sub_cmp"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (EXTEND4 (IMM4), State.regs[dstreg2]);
  State.regs[dstreg1] -= State.regs[srcreg1];
}
  
// 1111 0111 0110 0010 Rm1 Rn1 Rm2 Rn2; sub_mov Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x62+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::sub_mov
"sub_mov"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] - State.regs[srcreg1];
  State.regs[dstreg2] = State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0111 0010 Rm1 Rn1 imm4 Rn2; sub_mov Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x72+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::sub_mov
"sub_mov"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] - State.regs[srcreg1];
  State.regs[dstreg2] = EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 1000 0010 Rm1 Rn1 Rm2 Rn2; sub_asr Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x82+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::sub_asr
"sub_asr"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;
  signed int temp;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] - State.regs[srcreg1];
  temp = State.regs[dstreg2];
  temp >>= State.regs[srcreg2];
  State.regs[dstreg2] = temp;
  State.regs[dstreg1] = result1;
}

// 1111 0111 1001 0010 Rm1 Rn1 imm4 Rn2; sub_asr Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x92+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::sub_asr
"sub_asr"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;
  signed int temp;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] - State.regs[srcreg1];
  temp = State.regs[dstreg2];
  temp >>= IMM4;
  State.regs[dstreg2] = temp;
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 1010 0010 Rm1 Rn1 Rm2 Rn2; sub_lsr Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0xa2+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::sub_lsr
"sub_lsr"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] - State.regs[srcreg1];
  State.regs[dstreg2] >>= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 1011 0010 Rm1 Rn1 imm4 Rn2; sub_lsr Rm1, Rn1, imm4, Rn2
8.0xf7+8.0xb2+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::sub_lsr
"sub_lsr"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] - State.regs[srcreg1];
  State.regs[dstreg2] >>= IMM4;
  State.regs[dstreg1] = result1;
}
  
  
// 1111 0111 1100 0010 Rm1 Rn1 Rm2 Rn2; sub_asl Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0xc2+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::sub_asl
"sub_asl"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] - State.regs[srcreg1];
  State.regs[dstreg2] <<= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 1101 0010 Rm1 Rn1 imm4 Rn2; sub_asl Rm1, Rn1, imm4, Rn2
8.0xf7+8.0xd2+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::sub_asl
"sub_asl"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] - State.regs[srcreg1];
  State.regs[dstreg2] <<= IMM4;
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0000 0011 Rm1 Rn1 Rm2 Rn2; mov_add Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x03+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::mov_add
"mov_add"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[srcreg1];
  State.regs[dstreg2] += State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0001 0011 Rm1 Rn1 imm4 Rn2; mov_add Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x13+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::mov_add
"mov_add"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[srcreg1];
  State.regs[dstreg2] += EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0010 0011 Rm1 Rn1 Rm2 Rn2; mov_sub Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x23+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::mov_sub
"mov_sub"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[srcreg1];
  State.regs[dstreg2] -= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0011 0011 Rm1 Rn1 imm4 Rn2; mov_sub Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x33+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::mov_sub
"mov_sub"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[srcreg1];
  State.regs[dstreg2] -= EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0100 0011 Rm1 Rn1 Rm2 Rn2; mov_cmp Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x43+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::mov_cmp
"mov_cmp"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (State.regs[srcreg2], State.regs[dstreg2]);
  State.regs[dstreg1] = State.regs[srcreg1];
}

// 1111 0111 0101 0011 Rm1 Rn1 imm4 Rn2; mov_cmp Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x53+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::mov_cmp
"mov_cmp"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (EXTEND4 (IMM4), State.regs[dstreg2]);
  State.regs[dstreg1] = State.regs[srcreg1];
}
  
// 1111 0111 0110 0011 Rm1 Rn1 Rm2 Rn2; mov_mov Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x63+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::mov_mov
"mov_mov"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[srcreg1];
  State.regs[dstreg2] = State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0111 0011 Rm1 Rn1 imm4 Rn2; mov_mov Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x73+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::mov_mov
"mov_mov"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[srcreg1];
  State.regs[dstreg2] = EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 1000 0011 Rm1 Rn1 Rm2 Rn2; mov_asr Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x83+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::mov_asr
"mov_asr"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;
  signed int temp;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[srcreg1];
  temp = State.regs[dstreg2];
  temp >>= State.regs[srcreg2];
  State.regs[dstreg2] = temp;
  State.regs[dstreg1] = result1;
}

// 1111 0111 1001 0011 Rm1 Rn1 imm4 Rn2; mov_asr Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x93+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::mov_asr
"mov_asr"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;
  signed int temp;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[srcreg1];
  temp = State.regs[dstreg2];
  temp >>= IMM4;
  State.regs[dstreg2] = temp;
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 1010 0011 Rm1 Rn1 Rm2 Rn2; mov_lsr Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0xa3+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::mov_lsr
"mov_lsr"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[srcreg1];
  State.regs[dstreg2] >>= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 1011 0011 Rm1 Rn1 imm4 Rn2; mov_lsr Rm1, Rn1, imm4, Rn2
8.0xf7+8.0xb3+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::mov_lsr
"mov_lsr"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[srcreg1];
  State.regs[dstreg2] >>= IMM4;
  State.regs[dstreg1] = result1;
}
  
  
// 1111 0111 1100 0011 Rm1 Rn1 Rm2 Rn2; mov_asl Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0xc3+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::mov_asl
"mov_asl"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[srcreg1];
  State.regs[dstreg2] <<= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 1101 0011 Rm1 Rn1 imm4 Rn2; mov_asl Rm1, Rn1, imm4, Rn2
8.0xf7+8.0xd3+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::mov_asl
"mov_asl"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[srcreg1];
  State.regs[dstreg2] <<= IMM4;
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0000 0100 imm4 Rn1 Rm2 Rn2; add_add imm4, Rn1, Rm2, Rn2
8.0xf7+8.0x04+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::add_add
"add_add"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] + EXTEND4 (IMM4A);
  State.regs[dstreg2] += State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0001 0100 imm4 Rn1 imm4 Rn2; add_add imm4, Rn1, imm4, Rn2
8.0xf7+8.0x14+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::add_add
"add_add"
*am33
*am33_2
{
  int dstreg1, dstreg2;
  int result1;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] + EXTEND4 (IMM4A);
  State.regs[dstreg2] += EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0010 0100 imm4 Rn1 Rm2 Rn2; add_sub imm4, Rn1, Rm2, Rn2
8.0xf7+8.0x24+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::add_sub
"add_sub"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] + EXTEND4 (IMM4A);
  State.regs[dstreg2] -= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0011 0100 imm4 Rn1 imm4 Rn2; add_sub imm4, Rn1, imm4, Rn2
8.0xf7+8.0x34+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::add_sub
"add_sub"
*am33
*am33_2
{
  int dstreg1, dstreg2;
  int result1;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] + EXTEND4 (IMM4A);
  State.regs[dstreg2] -= EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0100 0100 imm4 Rn1 Rm2 Rn2; add_cmp imm4, Rn1, Rm2, Rn2
8.0xf7+8.0x44+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::add_cmp
"add_cmp"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (State.regs[srcreg2], State.regs[dstreg2]);
  State.regs[dstreg1] += EXTEND4 (IMM4A);
}

// 1111 0111 0101 0100 imm4 Rn1 imm4 Rn2; add_cmp imm4, Rn1, imm4, Rn2
8.0xf7+8.0x54+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::add_cmp
"add_cmp"
*am33
*am33_2
{
  int dstreg1, dstreg2;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (EXTEND4 (IMM4), State.regs[dstreg2]);
  State.regs[dstreg1] += EXTEND4 (IMM4A);
}
  
// 1111 0111 0110 0100 imm4 Rn1 Rm2 Rn2; add_mov imm4, Rn1, Rm2, Rn2
8.0xf7+8.0x64+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::add_mov
"add_mov"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] + EXTEND4 (IMM4A);
  State.regs[dstreg2] = State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0111 0100 imm4 Rn1 imm4 Rn2; add_mov imm4, Rn1, imm4, Rn2
8.0xf7+8.0x74+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::add_mov
"add_mov"
*am33
*am33_2
{
  int dstreg1, dstreg2;
  int result1;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] + EXTEND4 (IMM4A);
  State.regs[dstreg2] = EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 1000 0100 imm4 Rn1 Rm2 Rn2; add_asr imm4, Rn1, Rm2, Rn2
8.0xf7+8.0x84+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::add_asr
"add_asr"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;
  int result1;
  signed int temp;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] + EXTEND4 (IMM4A);
  temp = State.regs[dstreg2];
  temp >>= State.regs[srcreg2];
  State.regs[dstreg2] = temp;
  State.regs[dstreg1] = result1;
}

// 1111 0111 1001 0100 imm4 Rn1 imm4 Rn2; add_asr imm4, Rn1, imm4, Rn2
8.0xf7+8.0x94+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::add_asr
"add_asr"
*am33
*am33_2
{
  int dstreg1, dstreg2;
  int result1;
  signed int temp;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] + EXTEND4 (IMM4A);
  temp = State.regs[dstreg2];
  temp >>= IMM4;
  State.regs[dstreg2] = temp;
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 1010 0100 imm4 Rn1 Rm2 Rn2; add_lsr imm4, Rn1, Rm2, Rn2
8.0xf7+8.0xa4+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::add_lsr
"add_lsr"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] + EXTEND4 (IMM4A);
  State.regs[dstreg2] >>= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 1011 0100 imm4 Rn1 imm4 Rn2; add_lsr imm4, Rn1, imm4, Rn2
8.0xf7+8.0xb4+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::add_lsr
"add_lsr"
*am33
*am33_2
{
  int dstreg1, dstreg2;
  int result1;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] + EXTEND4 (IMM4A);
  State.regs[dstreg2] >>= IMM4;
  State.regs[dstreg1] = result1;
}
  
  
// 1111 0111 1100 0100 imm4 Rn1 Rm2 Rn2; add_asl imm4, Rn1, Rm2, Rn2
8.0xf7+8.0xc4+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::add_asl
"add_asl"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] + EXTEND4 (IMM4A);
  State.regs[dstreg2] <<= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 1101 0100 imm4 Rn1 imm4 Rn2; add_asl imm4, Rn1, imm4, Rn2
8.0xf7+8.0xd4+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::add_asl
"add_asl"
*am33
*am33_2
{
  int dstreg1, dstreg2;
  int result1;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] + EXTEND4 (IMM4A);
  State.regs[dstreg2] <<= IMM4;
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0000 0101 imm4 Rn1 Rm2 Rn2; cmp_add imm4, Rn1, Rm2, Rn2
8.0xf7+8.0x05+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::cmp_add
"cmp_add"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (EXTEND4 (IMM4A), State.regs[dstreg1]);
  State.regs[dstreg2] += State.regs[srcreg2];
}

// 1111 0111 0001 0101 imm4 Rn1 imm4 Rn2; cmp_add imm4, Rn1, imm4, Rn2
8.0xf7+8.0x15+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::cmp_add
"cmp_add"
*am33
*am33_2
{
  int dstreg1, dstreg2;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (EXTEND4 (IMM4A), State.regs[dstreg1]);
  State.regs[dstreg2] += EXTEND4 (IMM4);
}
  
// 1111 0111 0010 0101 imm4 Rn1 Rm2 Rn2; cmp_sub imm4, Rn1, Rm2, Rn2
8.0xf7+8.0x25+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::cmp_sub
"cmp_sub"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (EXTEND4 (IMM4A), State.regs[dstreg1]);
  State.regs[dstreg2] -= State.regs[srcreg2];
}

// 1111 0111 0011 0101 imm4 Rn1 imm4 Rn2; cmp_sub imm4, Rn1, imm4, Rn2
8.0xf7+8.0x35+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::cmp_sub
"cmp_sub"
*am33
*am33_2
{
  int dstreg1, dstreg2;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (EXTEND4 (IMM4A), State.regs[dstreg1]);
  State.regs[dstreg2] -= EXTEND4 (IMM4);
}
  
// 1111 0111 0110 0101 imm4 Rn1 Rm2 Rn2; cmp_mov imm4, Rn1, Rm2, Rn2
8.0xf7+8.0x65+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::cmp_mov
"cmp_mov"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (EXTEND4 (IMM4A), State.regs[dstreg1]);
  State.regs[dstreg2] = State.regs[srcreg2];
}

// 1111 0111 0111 0101 imm4 Rn1 imm4 Rn2; cmp_mov imm4, Rn1, imm4, Rn2
8.0xf7+8.0x75+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::cmp_mov
"cmp_mov"
*am33
*am33_2
{
  int dstreg1, dstreg2;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (EXTEND4 (IMM4A), State.regs[dstreg1]);
  State.regs[dstreg2] = EXTEND4 (IMM4);
}
  
// 1111 0111 1000 0101 imm4 Rn1 Rm2 Rn2; cmp_asr imm4, Rn1, Rm2, Rn2
8.0xf7+8.0x85+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::cmp_asr
"cmp_asr"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;
  signed int temp;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (EXTEND4 (IMM4A), State.regs[dstreg1]);
  temp = State.regs[dstreg2];
  temp >>= State.regs[srcreg2];
  State.regs[dstreg2] = temp;
}

// 1111 0111 1001 0101 imm4 Rn1 imm4 Rn2; cmp_asr imm4, Rn1, imm4, Rn2
8.0xf7+8.0x95+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::cmp_asr
"cmp_asr"
*am33
*am33_2
{
  int dstreg1, dstreg2;
  signed int temp;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (EXTEND4 (IMM4A), State.regs[dstreg1]);
  temp = State.regs[dstreg2];
  temp >>= IMM4;
  State.regs[dstreg2] = temp;
}
  
// 1111 0111 1010 0101 imm4 Rn1 Rm2 Rn2; cmp_lsr imm4, Rn1, Rm2, Rn2
8.0xf7+8.0xa5+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::cmp_lsr
"cmp_lsr"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (EXTEND4 (IMM4A), State.regs[dstreg1]);
  State.regs[dstreg2] >>= State.regs[srcreg2];
}

// 1111 0111 1011 0101 imm4 Rn1 imm4 Rn2; cmp_lsr imm4, Rn1, imm4, Rn2
8.0xf7+8.0xb5+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::cmp_lsr
"cmp_lsr"
*am33
*am33_2
{
  int dstreg1, dstreg2;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (EXTEND4 (IMM4A), State.regs[dstreg1]);
  State.regs[dstreg2] >>= IMM4;
}
  
  
// 1111 0111 1100 0101 imm4 Rn1 Rm2 Rn2; cmp_asl imm4, Rn1, Rm2, Rn2
8.0xf7+8.0xc5+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::cmp_asl
"cmp_asl"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (EXTEND4 (IMM4A), State.regs[dstreg1]);
  State.regs[dstreg2] <<= State.regs[srcreg2];
}

// 1111 0111 1101 0101 imm4 Rn1 imm4 Rn2; cmp_asl imm4, Rn1, imm4, Rn2
8.0xf7+8.0xd5+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::cmp_asl
"cmp_asl"
*am33
*am33_2
{
  int dstreg1, dstreg2;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (EXTEND4 (IMM4A), State.regs[dstreg1]);
  State.regs[dstreg2] <<= IMM4;
}

// 1111 0111 0000 0110 imm4 Rn1 Rm2 Rn2; sub_add imm4, Rn1, Rm2, Rn2
8.0xf7+8.0x06+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::sub_add
"sub_add"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] - EXTEND4 (IMM4A);
  State.regs[dstreg2] += State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0001 0110 imm4 Rn1 imm4 Rn2; sub_add imm4, Rn1, imm4, Rn2
8.0xf7+8.0x16+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::sub_add
"sub_add"
*am33
*am33_2
{
  int dstreg1, dstreg2;
  int result1;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] - EXTEND4 (IMM4A);
  State.regs[dstreg2] += EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0010 0110 imm4 Rn1 Rm2 Rn2; sub_sub imm4, Rn1, Rm2, Rn2
8.0xf7+8.0x26+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::sub_sub
"sub_sub"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] - EXTEND4 (IMM4A);
  State.regs[dstreg2] -= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0011 0110 imm4 Rn1 imm4 Rn2; sub_sub imm4, Rn1, imm4, Rn2
8.0xf7+8.0x36+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::sub_sub
"sub_sub"
*am33
*am33_2
{
  int dstreg1, dstreg2;
  int result1;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] - EXTEND4 (IMM4A);
  State.regs[dstreg2] -= EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0100 0110 imm4 Rn1 Rm2 Rn2; sub_cmp imm4, Rn1, Rm2, Rn2
8.0xf7+8.0x46+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::sub_cmp
"sub_cmp"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (State.regs[srcreg2], State.regs[dstreg2]);
  State.regs[dstreg1] -= EXTEND4 (IMM4A);
}

// 1111 0111 0101 0110 imm4 Rn1 imm4 Rn2; sub_cmp imm4, Rn1, imm4, Rn2
8.0xf7+8.0x56+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::sub_cmp
"sub_cmp"
*am33
*am33_2
{
  int dstreg1, dstreg2;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (EXTEND4 (IMM4), State.regs[dstreg2]);
  State.regs[dstreg1] -= EXTEND4 (IMM4A);
}
  
// 1111 0111 0110 0110 imm4 Rn1 Rm2 Rn2; sub_mov imm4, Rn1, Rm2, Rn2
8.0xf7+8.0x66+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::sub_mov
"sub_mov"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] - EXTEND4 (IMM4A);
  State.regs[dstreg2] = State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0111 0110 imm4 Rn1 imm4 Rn2; sub_mov imm4, Rn1, imm4, Rn2
8.0xf7+8.0x76+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::sub_mov
"sub_mov"
*am33
*am33_2
{
  int dstreg1, dstreg2;
  int result1;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] - EXTEND4 (IMM4A);
  State.regs[dstreg2] = EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 1000 0110 imm4 Rn1 Rm2 Rn2; sub_asr imm4, Rn1, Rm2, Rn2
8.0xf7+8.0x86+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::sub_asr
"sub_asr"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;
  int result1;
  signed int temp;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] - EXTEND4 (IMM4A);
  temp = State.regs[dstreg2];
  temp >>= State.regs[srcreg2];
  State.regs[dstreg2] = temp;
  State.regs[dstreg1] = result1;
}

// 1111 0111 1001 0110 imm4 Rn1 imm4 Rn2; sub_asr imm4, Rn1, imm4, Rn2
8.0xf7+8.0x96+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::sub_asr
"sub_asr"
*am33
*am33_2
{
  int dstreg1, dstreg2;
  int result1;
  signed int temp;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] - EXTEND4 (IMM4A);
  temp = State.regs[dstreg2];
  temp >>= IMM4;
  State.regs[dstreg2] = temp;
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 1010 0110 imm4 Rn1 Rm2 Rn2; sub_lsr imm4, Rn1, Rm2, Rn2
8.0xf7+8.0xa6+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::sub_lsr
"sub_lsr"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] - EXTEND4 (IMM4A);
  State.regs[dstreg2] >>= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 1011 0110 imm4 Rn1 imm4 Rn2; sub_lsr imm4, Rn1, imm4, Rn2
8.0xf7+8.0xb6+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::sub_lsr
"sub_lsr"
*am33
*am33_2
{
  int dstreg1, dstreg2;
  int result1;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] - EXTEND4 (IMM4A);
  State.regs[dstreg2] >>= IMM4;
  State.regs[dstreg1] = result1;
}
  
  
// 1111 0111 1100 0110 imm4 Rn1 Rm2 Rn2; sub_asl imm4, Rn1, Rm2, Rn2
8.0xf7+8.0xc6+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::sub_asl
"sub_asl"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] - EXTEND4 (IMM4A);
  State.regs[dstreg2] <<= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 1101 0110 imm4 Rn1 imm4 Rn2; sub_asl imm4, Rn1, imm4, Rn2
8.0xf7+8.0xd6+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::sub_asl
"sub_asl"
*am33
*am33_2
{
  int dstreg1, dstreg2;
  int result1;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] - EXTEND4 (IMM4A);
  State.regs[dstreg2] <<= IMM4;
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0000 0111 imm4 Rn1 Rm2 Rn2; mov_add imm4, Rn1, Rm2, Rn2
8.0xf7+8.0x07+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::mov_add
"mov_add"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = EXTEND4 (IMM4A);
  State.regs[dstreg2] += State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0001 0111 imm4 Rn1 imm4 Rn2; mov_add imm4, Rn1, imm4, Rn2
8.0xf7+8.0x17+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::mov_add
"mov_add"
*am33
*am33_2
{
  int dstreg1, dstreg2;
  int result1;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = EXTEND4 (IMM4A);
  State.regs[dstreg2] += EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0010 0111 imm4 Rn1 Rm2 Rn2; mov_sub imm4, Rn1, Rm2, Rn2
8.0xf7+8.0x27+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::mov_sub
"mov_sub"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = EXTEND4 (IMM4A);
  State.regs[dstreg2] -= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0011 0111 imm4 Rn1 imm4 Rn2; mov_sub imm4, Rn1, imm4, Rn2
8.0xf7+8.0x37+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::mov_sub
"mov_sub"
*am33
*am33_2
{
  int dstreg1, dstreg2;
  int result1;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = EXTEND4 (IMM4A);
  State.regs[dstreg2] -= EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0100 0111 imm4 Rn1 Rm2 Rn2; mov_cmp imm4, Rn1, Rm2, Rn2
8.0xf7+8.0x47+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::mov_cmp
"mov_cmp"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (State.regs[srcreg2], State.regs[dstreg2]);
  State.regs[dstreg1] = EXTEND4 (IMM4A);
}

// 1111 0111 0101 0111 imm4 Rn1 imm4 Rn2; mov_cmp imm4, Rn1, imm4, Rn2
8.0xf7+8.0x57+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::mov_cmp
"mov_cmp"
*am33
*am33_2
{
  int dstreg1, dstreg2;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (EXTEND4 (IMM4), State.regs[dstreg2]);
  State.regs[dstreg1] = EXTEND4 (IMM4A);
}
  
// 1111 0111 0110 0111 imm4 Rn1 Rm2 Rn2; mov_mov imm4, Rn1, Rm2, Rn2
8.0xf7+8.0x67+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::mov_mov
"mov_mov"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = EXTEND4 (IMM4A);
  State.regs[dstreg2] = State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0111 0111 imm4 Rn1 imm4 Rn2; mov_mov imm4, Rn1, imm4, Rn2
8.0xf7+8.0x77+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::mov_mov
"mov_mov"
*am33
*am33_2
{
  int dstreg1, dstreg2;
  int result1;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = EXTEND4 (IMM4A);
  State.regs[dstreg2] = EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 1000 0111 imm4 Rn1 Rm2 Rn2; mov_asr imm4, Rn1, Rm2, Rn2
8.0xf7+8.0x87+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::mov_asr
"mov_asr"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;
  int result1;
  signed int temp;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = EXTEND4 (IMM4A);
  temp = State.regs[dstreg2];
  temp >>= State.regs[srcreg2];
  State.regs[dstreg2] = temp;
  State.regs[dstreg1] = result1;
}

// 1111 0111 1001 0111 imm4 Rn1 imm4 Rn2; mov_asr imm4, Rn1, imm4, Rn2
8.0xf7+8.0x97+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::mov_asr
"mov_asr"
*am33
*am33_2
{
  int dstreg1, dstreg2;
  int result1;
  signed int temp;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = EXTEND4 (IMM4A);
  temp = State.regs[dstreg2];
  temp >>= IMM4;
  State.regs[dstreg2] = temp;
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 1010 0111 imm4 Rn1 Rm2 Rn2; mov_lsr imm4, Rn1, Rm2, Rn2
8.0xf7+8.0xa7+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::mov_lsr
"mov_lsr"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = EXTEND4 (IMM4A);
  State.regs[dstreg2] >>= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 1011 0111 imm4 Rn1 imm4 Rn2; mov_lsr imm4, Rn1, imm4, Rn2
8.0xf7+8.0xb7+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::mov_lsr
"mov_lsr"
*am33
*am33_2
{
  int dstreg1, dstreg2;
  int result1;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = EXTEND4 (IMM4A);
  State.regs[dstreg2] >>= IMM4;
  State.regs[dstreg1] = result1;
}
  
  
// 1111 0111 1100 0111 imm4 Rn1 Rm2 Rn2; mov_asl imm4, Rn1, Rm2, Rn2
8.0xf7+8.0xc7+4.IMM4A,4.RN1+4.RM2,4.RN2!RN1:D2c:::mov_asl
"mov_asl"
*am33
*am33_2
{
  int srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = EXTEND4 (IMM4A);
  State.regs[dstreg2] <<= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 1101 0111 imm4 Rn1 imm4 Rn2; mov_asl imm4, Rn1, imm4, Rn2
8.0xf7+8.0xd7+4.IMM4A,4.RN1+4.IMM4,4.RN2!RN1:D2d:::mov_asl
"mov_asl"
*am33
*am33_2
{
  int dstreg1, dstreg2;
  int result1;

  PC = cia;
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = EXTEND4 (IMM4A);
  State.regs[dstreg2] <<= IMM4;
  State.regs[dstreg1] = result1;
}
 
// 1111 0111 0000 1000 Rm1 Rn1 Rm2 Rn2; and_add Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x08+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::and_add
"and_add"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] & State.regs[srcreg1];
  State.regs[dstreg2] += State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0001 1000 Rm1 Rn1 imm4 Rn2; and_add Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x18+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::and_add
"and_add"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] & State.regs[srcreg1];
  State.regs[dstreg2] += EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0010 1000 Rm1 Rn1 Rm2 Rn2; and_sub Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x28+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::and_sub
"and_sub"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] & State.regs[srcreg1];
  State.regs[dstreg2] -= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0011 1000 Rm1 Rn1 imm4 Rn2; and_sub Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x38+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::and_sub
"and_sub"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] & State.regs[srcreg1];
  State.regs[dstreg2] -= EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0100 1000 Rm1 Rn1 Rm2 Rn2; and_cmp Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x48+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::and_cmp
"and_cmp"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (State.regs[srcreg2], State.regs[dstreg2]);
  State.regs[dstreg1] &= State.regs[srcreg1];
}

// 1111 0111 0101 1000 Rm1 Rn1 imm4 Rn2; and_cmp Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x58+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::and_cmp
"and_cmp"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (EXTEND4 (IMM4), State.regs[dstreg2]);
  State.regs[dstreg1] &= State.regs[srcreg1];
}
  
// 1111 0111 0110 1000 Rm1 Rn1 Rm2 Rn2; and_mov Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x68+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::and_mov
"and_mov"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] & State.regs[srcreg1];
  State.regs[dstreg2] = State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0111 1000 Rm1 Rn1 imm4 Rn2; and_mov Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x78+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::and_mov
"and_mov"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] & State.regs[srcreg1];
  State.regs[dstreg2] = EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 1000 1000 Rm1 Rn1 Rm2 Rn2; and_asr Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x88+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::and_asr
"and_asr"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;
  signed int temp;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] & State.regs[srcreg1];
  temp = State.regs[dstreg2];
  temp >>= State.regs[srcreg2];
  State.regs[dstreg2] = temp;
  State.regs[dstreg1] = result1;
}

// 1111 0111 1001 1000 Rm1 Rn1 imm4 Rn2; and_asr Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x98+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::and_asr
"and_asr"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;
  signed int temp;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] & State.regs[srcreg1];
  temp = State.regs[dstreg2];
  temp >>= IMM4;
  State.regs[dstreg2] = temp;
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 1010 1000 Rm1 Rn1 Rm2 Rn2; and_lsr Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0xa8+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::and_lsr
"and_lsr"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] & State.regs[srcreg1];
  State.regs[dstreg2] >>= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 1011 1000 Rm1 Rn1 imm4 Rn2; and_lsr Rm1, Rn1, imm4, Rn2
8.0xf7+8.0xb8+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::and_lsr
"and_lsr"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] & State.regs[srcreg1];
  State.regs[dstreg2] >>= IMM4;
  State.regs[dstreg1] = result1;
}
  
  
// 1111 0111 1100 1000 Rm1 Rn1 Rm2 Rn2; and_asl Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0xc8+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::and_asl
"and_asl"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] & State.regs[srcreg1];
  State.regs[dstreg2] <<= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 1101 1000 Rm1 Rn1 imm4 Rn2; and_asl Rm1, Rn1, imm4, Rn2
8.0xf7+8.0xd8+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::and_asl
"and_asl"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] & State.regs[srcreg1];
  State.regs[dstreg2] <<= IMM4;
  State.regs[dstreg1] = result1;
}

// 1111 0111 0000 1001 Rm1 Rn1 Rm2 Rn2; dmach_add Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x09+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::dmach_add
"dmach_add"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  signed32 temp, temp2, sum;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)
          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));
  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)
           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));
  sum = temp + temp2 + State.regs[REG_MCRL];

  State.regs[dstreg2] += State.regs[srcreg2];
  State.regs[dstreg1] = sum;
}

// 1111 0111 0001 1001 Rm1 Rn1 imm4 Rn2; dmach_add Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x19+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::dmach_add
"dmach_add"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  signed32 temp, temp2, sum;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)
          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));
  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)
           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));
  sum = temp + temp2 + State.regs[REG_MCRL];

  State.regs[dstreg2] += EXTEND4 (IMM4);
  State.regs[dstreg1] = sum;
}
  
// 1111 0111 0010 1001 Rm1 Rn1 Rm2 Rn2; dmach_sub Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x29+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::dmach_sub
"dmach_sub"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  signed32 temp, temp2, sum;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)
          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));
  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)
           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));
  sum = temp + temp2 + State.regs[REG_MCRL];

  State.regs[dstreg2] -= State.regs[srcreg2];
  State.regs[dstreg1] = sum;
}

// 1111 0111 0011 1001 Rm1 Rn1 imm4 Rn2; dmach_sub Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x39+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::dmach_sub
"dmach_sub"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  signed32 temp, temp2, sum;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)
          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));
  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)
           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));
  sum = temp + temp2 + State.regs[REG_MCRL];

  State.regs[dstreg2] -= EXTEND4 (IMM4);
  State.regs[dstreg1] = sum;
}
  
// 1111 0111 0100 1001 Rm1 Rn1 Rm2 Rn2; dmach_cmp Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x49+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::dmach_cmp
"dmach_cmp"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  signed32 temp, temp2, sum;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)
          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));
  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)
           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));
  sum = temp + temp2 + State.regs[REG_MCRL];

  genericCmp (State.regs[srcreg2], State.regs[dstreg2]);
  State.regs[dstreg1] = sum;
}

// 1111 0111 0101 1001 Rm1 Rn1 imm4 Rn2; dmach_cmp Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x59+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::dmach_cmp
"dmach_cmp"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  signed32 temp, temp2, sum;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)
          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));
  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)
           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));
  sum = temp + temp2 + State.regs[REG_MCRL];

  genericCmp (EXTEND4 (IMM4), State.regs[dstreg2]);
  State.regs[dstreg1] = sum;
}
  
// 1111 0111 0110 1001 Rm1 Rn1 Rm2 Rn2; dmach_mov Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x69+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::dmach_mov
"dmach_mov"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  signed32 temp, temp2, sum;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)
          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));
  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)
           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));
  sum = temp + temp2 + State.regs[REG_MCRL];

  State.regs[dstreg2] = State.regs[srcreg2];
  State.regs[dstreg1] = sum;
}

// 1111 0111 0111 1001 Rm1 Rn1 imm4 Rn2; dmach_mov Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x79+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::dmach_mov
"dmach_mov"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  signed32 temp, temp2, sum;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)
          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));
  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)
           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));
  sum = temp + temp2 + State.regs[REG_MCRL];

  State.regs[dstreg2] = EXTEND4 (IMM4);
  State.regs[dstreg1] = sum;
}
  
// 1111 0111 1000 1001 Rm1 Rn1 Rm2 Rn2; dmach_asr Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x89+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::dmach_asr
"dmach_asr"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  signed32 temp, temp2, sum;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)
          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));
  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)
           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));
  sum = temp + temp2 + State.regs[REG_MCRL];

  temp = State.regs[dstreg2];
  temp >>= State.regs[srcreg2];
  State.regs[dstreg2] = temp;
  State.regs[dstreg1] = sum;
}

// 1111 0111 1001 1001 Rm1 Rn1 imm4 Rn2; dmach_asr Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x99+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::dmach_asr
"dmach_asr"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  signed32 temp, temp2, sum;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)
          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));
  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)
           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));
  sum = temp + temp2 + State.regs[REG_MCRL];

  temp = State.regs[dstreg2];
  temp >>= IMM4;
  State.regs[dstreg2] = temp;
  State.regs[dstreg1] = sum;
}
  
// 1111 0111 1010 1001 Rm1 Rn1 Rm2 Rn2; dmach_lsr Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0xa9+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::dmach_lsr
"dmach_lsr"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  signed32 temp, temp2, sum;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)
          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));
  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)
           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));
  sum = temp + temp2 + State.regs[REG_MCRL];

  State.regs[dstreg2] >>= State.regs[srcreg2];
  State.regs[dstreg1] = sum;
}

// 1111 0111 1011 1001 Rm1 Rn1 imm4 Rn2; dmach_lsr Rm1, Rn1, imm4, Rn2
8.0xf7+8.0xb9+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::dmach_lsr
"dmach_lsr"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  signed32 temp, temp2, sum;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)
          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));
  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)
           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));
  sum = temp + temp2 + State.regs[REG_MCRL];

  State.regs[dstreg2] >>= IMM4;
  State.regs[dstreg1] = sum;
}
  
  
// 1111 0111 1100 1001 Rm1 Rn1 Rm2 Rn2; dmach_asl Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0xc9+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::dmach_asl
"dmach_asl"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  signed32 temp, temp2, sum;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)
          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));
  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)
           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));
  sum = temp + temp2 + State.regs[REG_MCRL];

  State.regs[dstreg2] <<= State.regs[srcreg2];
  State.regs[dstreg1] = sum;
}

// 1111 0111 1101 1001 Rm1 Rn1 imm4 Rn2; dmach_asl Rm1, Rn1, imm4, Rn2
8.0xf7+8.0xd9+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::dmach_asl
"dmach_asl"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  signed32 temp, temp2, sum;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)
          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));
  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)
           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));
  sum = temp + temp2 + State.regs[REG_MCRL];

  State.regs[dstreg2] <<= IMM4;
  State.regs[dstreg1] = sum;
}

// 1111 0111 0000 1010 Rm1 Rn1 Rm2 Rn2; xor_add Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x0a+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::xor_add
"xor_add"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] ^ State.regs[srcreg1];
  State.regs[dstreg2] += State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0001 1010 Rm1 Rn1 imm4 Rn2; xor_add Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x1a+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::xor_add
"xor_add"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] ^ State.regs[srcreg1];
  State.regs[dstreg2] += EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0010 1010 Rm1 Rn1 Rm2 Rn2; xor_sub Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x2a+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::xor_sub
"xor_sub"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] ^ State.regs[srcreg1];
  State.regs[dstreg2] -= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0011 1010 Rm1 Rn1 imm4 Rn2; xor_sub Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x3a+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::xor_sub
"xor_sub"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] ^ State.regs[srcreg1];
  State.regs[dstreg2] -= EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0100 1010 Rm1 Rn1 Rm2 Rn2; xor_cmp Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x4a+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::xor_cmp
"xor_cmp"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (State.regs[srcreg2], State.regs[dstreg2]);
  State.regs[dstreg1] ^= State.regs[srcreg1];
}

// 1111 0111 0101 1010 Rm1 Rn1 imm4 Rn2; xor_cmp Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x5a+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::xor_cmp
"xor_cmp"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (EXTEND4 (IMM4), State.regs[dstreg2]);
  State.regs[dstreg1] ^= State.regs[srcreg1];
}
  
// 1111 0111 0110 1010 Rm1 Rn1 Rm2 Rn2; xor_mov Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x6a+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::xor_mov
"xor_mov"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] ^ State.regs[srcreg1];
  State.regs[dstreg2] = State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0111 1010 Rm1 Rn1 imm4 Rn2; xor_mov Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x7a+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::xor_mov
"xor_mov"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] ^ State.regs[srcreg1];
  State.regs[dstreg2] = EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 1000 1010 Rm1 Rn1 Rm2 Rn2; xor_asr Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x8a+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::xor_asr
"xor_asr"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;
  signed int temp;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] ^ State.regs[srcreg1];
  temp = State.regs[dstreg2];
  temp >>= State.regs[srcreg2];
  State.regs[dstreg2] = temp;
  State.regs[dstreg1] = result1;
}

// 1111 0111 1001 1010 Rm1 Rn1 imm4 Rn2; xor_asr Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x9a+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::xor_asr
"xor_asr"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;
  signed int temp;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] ^ State.regs[srcreg1];
  temp = State.regs[dstreg2];
  temp >>= IMM4;
  State.regs[dstreg2] = temp;
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 1010 1010 Rm1 Rn1 Rm2 Rn2; xor_lsr Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0xaa+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::xor_lsr
"xor_lsr"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] ^ State.regs[srcreg1];
  State.regs[dstreg2] >>= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 1011 1010 Rm1 Rn1 imm4 Rn2; xor_lsr Rm1, Rn1, imm4, Rn2
8.0xf7+8.0xba+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::xor_lsr
"xor_lsr"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] ^ State.regs[srcreg1];
  State.regs[dstreg2] >>= IMM4;
  State.regs[dstreg1] = result1;
}
  
  
// 1111 0111 1100 1010 Rm1 Rn1 Rm2 Rn2; xor_asl Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0xca+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::xor_asl
"xor_asl"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] ^ State.regs[srcreg1];
  State.regs[dstreg2] <<= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 1101 1010 Rm1 Rn1 imm4 Rn2; xor_asl Rm1, Rn1, imm4, Rn2
8.0xf7+8.0xda+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::xor_asl
"xor_asl"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] ^ State.regs[srcreg1];
  State.regs[dstreg2] <<= IMM4;
  State.regs[dstreg1] = result1;
}

// 1111 0111 0000 1011 Rm1 Rn1 Rm2 Rn2; swhw_add Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x0b+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::swhw_add
"swhw_add"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] ^ State.regs[srcreg1];
  State.regs[dstreg2] += State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0001 1011 Rm1 Rn1 imm4 Rn2; swhw_add Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x1b+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::swhw_add
"swhw_add"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = (((State.regs[srcreg1] & 0xffff) << 16)
               | ((State.regs[srcreg1] >> 16) & 0xffff));
  State.regs[dstreg2] += EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0010 1011 Rm1 Rn1 Rm2 Rn2; swhw_sub Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x2b+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::swhw_sub
"swhw_sub"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = (((State.regs[srcreg1] & 0xffff) << 16)
               | ((State.regs[srcreg1] >> 16) & 0xffff));
  State.regs[dstreg2] -= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0011 1011 Rm1 Rn1 imm4 Rn2; swhw_sub Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x3b+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::swhw_sub
"swhw_sub"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = (((State.regs[srcreg1] & 0xffff) << 16)
               | ((State.regs[srcreg1] >> 16) & 0xffff));
  State.regs[dstreg2] -= EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0100 1011 Rm1 Rn1 Rm2 Rn2; swhw_cmp Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x4b+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::swhw_cmp
"swhw_cmp"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (State.regs[srcreg2], State.regs[dstreg2]);
  State.regs[dstreg1] = (((State.regs[srcreg1] & 0xffff) << 16)
                         | ((State.regs[srcreg1] >> 16) & 0xffff));
}

// 1111 0111 0101 1011 Rm1 Rn1 imm4 Rn2; swhw_cmp Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x5b+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::swhw_cmp
"swhw_cmp"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (EXTEND4 (IMM4), State.regs[dstreg2]);
  State.regs[dstreg1] = (((State.regs[srcreg1] & 0xffff) << 16)
                         | ((State.regs[srcreg1] >> 16) & 0xffff));
}
  
// 1111 0111 0110 1011 Rm1 Rn1 Rm2 Rn2; swhw_mov Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x6b+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::swhw_mov
"swhw_mov"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = (((State.regs[srcreg1] & 0xffff) << 16)
               | ((State.regs[srcreg1] >> 16) & 0xffff));
  State.regs[dstreg2] = State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0111 1011 Rm1 Rn1 imm4 Rn2; swhw_mov Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x7b+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::swhw_mov
"swhw_mov"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = (((State.regs[srcreg1] & 0xffff) << 16)
               | ((State.regs[srcreg1] >> 16) & 0xffff));
  State.regs[dstreg2] = EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 1000 1011 Rm1 Rn1 Rm2 Rn2; swhw_asr Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x8b+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::swhw_asr
"swhw_asr"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;
  signed int temp;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = (((State.regs[srcreg1] & 0xffff) << 16)
               | ((State.regs[srcreg1] >> 16) & 0xffff));
  temp = State.regs[dstreg2];
  temp >>= State.regs[srcreg2];
  State.regs[dstreg2] = temp;
  State.regs[dstreg1] = result1;
}

// 1111 0111 1001 1011 Rm1 Rn1 imm4 Rn2; swhw_asr Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x9b+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::swhw_asr
"swhw_asr"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;
  signed int temp;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = (((State.regs[srcreg1] & 0xffff) << 16)
               | ((State.regs[srcreg1] >> 16) & 0xffff));
  temp = State.regs[dstreg2];
  temp >>= IMM4;
  State.regs[dstreg2] = temp;
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 1010 1011 Rm1 Rn1 Rm2 Rn2; swhw_lsr Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0xab+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::swhw_lsr
"swhw_lsr"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = (((State.regs[srcreg1] & 0xffff) << 16)
               | ((State.regs[srcreg1] >> 16) & 0xffff));
  State.regs[dstreg2] >>= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 1011 1011 Rm1 Rn1 imm4 Rn2; swhw_lsr Rm1, Rn1, imm4, Rn2
8.0xf7+8.0xbb+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::swhw_lsr
"swhw_lsr"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = (((State.regs[srcreg1] & 0xffff) << 16)
               | ((State.regs[srcreg1] >> 16) & 0xffff));
  State.regs[dstreg2] >>= IMM4;
  State.regs[dstreg1] = result1;
}
  
  
// 1111 0111 1100 1011 Rm1 Rn1 Rm2 Rn2; swhw_asl Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0xcb+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::swhw_asl
"swhw_asl"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = (((State.regs[srcreg1] & 0xffff) << 16)
               | ((State.regs[srcreg1] >> 16) & 0xffff));
  State.regs[dstreg2] <<= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 1101 1011 Rm1 Rn1 imm4 Rn2; swhw_asl Rm1, Rn1, imm4, Rn2
8.0xf7+8.0xdb+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::swhw_asl
"swhw_asl"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = (((State.regs[srcreg1] & 0xffff) << 16)
               | ((State.regs[srcreg1] >> 16) & 0xffff));
  State.regs[dstreg2] <<= IMM4;
  State.regs[dstreg1] = result1;
}

// 1111 0111 0000 1100 Rm1 Rn1 Rm2 Rn2; or_add Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x0c+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::or_add
"or_add"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] | State.regs[srcreg1];
  State.regs[dstreg2] += State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0001 1100 Rm1 Rn1 imm4 Rn2; or_add Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x1c+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::or_add
"or_add"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] | State.regs[srcreg1];
  State.regs[dstreg2] += EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0010 1100 Rm1 Rn1 Rm2 Rn2; or_sub Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x2c+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::or_sub
"or_sub"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] | State.regs[srcreg1];
  State.regs[dstreg2] -= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0011 1100 Rm1 Rn1 imm4 Rn2; or_sub Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x3c+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::or_sub
"or_sub"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] | State.regs[srcreg1];
  State.regs[dstreg2] -= EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0100 1100 Rm1 Rn1 Rm2 Rn2; or_cmp Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x4c+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::or_cmp
"or_cmp"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (State.regs[srcreg2], State.regs[dstreg2]);
  State.regs[dstreg1] |= State.regs[srcreg1];
}

// 1111 0111 0101 1100 Rm1 Rn1 imm4 Rn2; or_cmp Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x5c+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::or_cmp
"or_cmp"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (EXTEND4 (IMM4), State.regs[dstreg2]);
  State.regs[dstreg1] |= State.regs[srcreg1];
}
  
// 1111 0111 0110 1100 Rm1 Rn1 Rm2 Rn2; or_mov Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x6c+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::or_mov
"or_mov"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] | State.regs[srcreg1];
  State.regs[dstreg2] = State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0111 1100 Rm1 Rn1 imm4 Rn2; or_mov Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x7c+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::or_mov
"or_mov"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] | State.regs[srcreg1];
  State.regs[dstreg2] = EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 1000 1100 Rm1 Rn1 Rm2 Rn2; or_asr Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x8c+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::or_asr
"or_asr"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;
  signed int temp;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] | State.regs[srcreg1];
  temp = State.regs[dstreg2];
  temp >>= State.regs[srcreg2];
  State.regs[dstreg2] = temp;
  State.regs[dstreg1] = result1;
}

// 1111 0111 1001 1100 Rm1 Rn1 imm4 Rn2; or_asr Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x9c+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::or_asr
"or_asr"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;
  signed int temp;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] | State.regs[srcreg1];
  temp = State.regs[dstreg2];
  temp >>= IMM4;
  State.regs[dstreg2] = temp;
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 1010 1100 Rm1 Rn1 Rm2 Rn2; or_lsr Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0xac+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::or_lsr
"or_lsr"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] | State.regs[srcreg1];
  State.regs[dstreg2] >>= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 1011 1100 Rm1 Rn1 imm4 Rn2; or_lsr Rm1, Rn1, imm4, Rn2
8.0xf7+8.0xbc+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::or_lsr
"or_lsr"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] | State.regs[srcreg1];
  State.regs[dstreg2] >>= IMM4;
  State.regs[dstreg1] = result1;
}
  
  
// 1111 0111 1100 1100 Rm1 Rn1 Rm2 Rn2; or_asl Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0xcc+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::or_asl
"or_asl"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] | State.regs[srcreg1];
  State.regs[dstreg2] <<= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 1101 1100 Rm1 Rn1 imm4 Rn2; or_asl Rm1, Rn1, imm4, Rn2
8.0xf7+8.0xdc+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::or_asl
"or_asl"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  result1 = State.regs[dstreg1] | State.regs[srcreg1];
  State.regs[dstreg2] <<= IMM4;
  State.regs[dstreg1] = result1;
}

// 1111 0111 0000 1101 Rm1 Rn1 Rm2 Rn2; sat16_add Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x0d+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::sat16_add
"sat16_add"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  if (State.regs[srcreg1] >= 0x7fff)
    result1 = 0x7fff;
  else if (State.regs[srcreg1] <= 0xffff8000)
    result1 = 0xffff8000;
  else
    result1 = State.regs[srcreg1];

  State.regs[dstreg2] += State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0001 1101 Rm1 Rn1 imm4 Rn2; sat16_add Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x1d+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::sat16_add
"sat16_add"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  if (State.regs[srcreg1] >= 0x7fff)
    result1 = 0x7fff;
  else if (State.regs[srcreg1] <= 0xffff8000)
    result1 = 0xffff8000;
  else
    result1 = State.regs[srcreg1];

  State.regs[dstreg2] += EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0010 1101 Rm1 Rn1 Rm2 Rn2; sat16_sub Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x2d+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::sat16_sub
"sat16_sub"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  if (State.regs[srcreg1] >= 0x7fff)
    result1 = 0x7fff;
  else if (State.regs[srcreg1] <= 0xffff8000)
    result1 = 0xffff8000;
  else
    result1 = State.regs[srcreg1];

  State.regs[dstreg2] -= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0011 1101 Rm1 Rn1 imm4 Rn2; sat16_sub Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x3d+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::sat16_sub
"sat16_sub"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  if (State.regs[srcreg1] >= 0x7fff)
    result1 = 0x7fff;
  else if (State.regs[srcreg1] <= 0xffff8000)
    result1 = 0xffff8000;
  else
    result1 = State.regs[srcreg1];

  State.regs[dstreg2] -= EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 0100 1101 Rm1 Rn1 Rm2 Rn2; sat16_cmp Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x4d+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::sat16_cmp
"sat16_cmp"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (State.regs[dstreg2], State.regs[dstreg1]);
  if (State.regs[srcreg1] >= 0x7fff)
    State.regs[dstreg1] = 0x7fff;
  else if (State.regs[srcreg1] <= 0xffff8000)
    State.regs[dstreg1] = 0xffff8000;
  else
    State.regs[dstreg1] = State.regs[srcreg1];
}

// 1111 0111 0101 1101 Rm1 Rn1 imm4 Rn2; sat16_cmp Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x5d+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::sat16_cmp
"sat16_cmp"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  genericCmp (EXTEND4 (IMM4), State.regs[dstreg2]);
  if (State.regs[srcreg1] >= 0x7fff)
    State.regs[dstreg1] = 0x7fff;
  else if (State.regs[srcreg1] <= 0xffff8000)
    State.regs[dstreg1] = 0xffff8000;
  else
    State.regs[dstreg1] = State.regs[srcreg1];
}
  
// 1111 0111 0110 1101 Rm1 Rn1 Rm2 Rn2; sat16_mov Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x6d+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::sat16_mov
"sat16_mov"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  if (State.regs[srcreg1] >= 0x7fff)
    result1 = 0x7fff;
  else if (State.regs[srcreg1] <= 0xffff8000)
    result1 = 0xffff8000;
  else
    result1 = State.regs[srcreg1];

  State.regs[dstreg2] = State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 0111 1101 Rm1 Rn1 imm4 Rn2; sat16_mov Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x7d+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::sat16_mov
"sat16_mov"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  if (State.regs[srcreg1] >= 0x7fff)
    result1 = 0x7fff;
  else if (State.regs[srcreg1] <= 0xffff8000)
    result1 = 0xffff8000;
  else
    result1 = State.regs[srcreg1];

  State.regs[dstreg2] = EXTEND4 (IMM4);
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 1000 1101 Rm1 Rn1 Rm2 Rn2; sat16_asr Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0x8d+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::sat16_asr
"sat16_asr"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;
  signed int temp;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  if (State.regs[srcreg1] >= 0x7fff)
    result1 = 0x7fff;
  else if (State.regs[srcreg1] <= 0xffff8000)
    result1 = 0xffff8000;
  else
    result1 = State.regs[srcreg1];

  temp = State.regs[dstreg2];
  temp >>= State.regs[srcreg2];
  State.regs[dstreg2] = temp;
  State.regs[dstreg1] = result1;
}

// 1111 0111 1001 1101 Rm1 Rn1 imm4 Rn2; sat16_asr Rm1, Rn1, imm4, Rn2
8.0xf7+8.0x9d+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::sat16_asr
"sat16_asr"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;
  signed int temp;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  if (State.regs[srcreg1] >= 0x7fff)
    result1 = 0x7fff;
  else if (State.regs[srcreg1] <= 0xffff8000)
    result1 = 0xffff8000;
  else
    result1 = State.regs[srcreg1];

  temp = State.regs[dstreg2];
  temp >>= IMM4;
  State.regs[dstreg2] = temp;
  State.regs[dstreg1] = result1;
}
  
// 1111 0111 1010 1101 Rm1 Rn1 Rm2 Rn2; sat16_lsr Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0xad+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::sat16_lsr
"sat16_lsr"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  if (State.regs[srcreg1] >= 0x7fff)
    result1 = 0x7fff;
  else if (State.regs[srcreg1] <= 0xffff8000)
    result1 = 0xffff8000;
  else
    result1 = State.regs[srcreg1];

  State.regs[dstreg2] >>= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 1011 1101 Rm1 Rn1 imm4 Rn2; sat16_lsr Rm1, Rn1, imm4, Rn2
8.0xf7+8.0xbd+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::sat16_lsr
"sat16_lsr"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  if (State.regs[srcreg1] >= 0x7fff)
    result1 = 0x7fff;
  else if (State.regs[srcreg1] <= 0xffff8000)
    result1 = 0xffff8000;
  else
    result1 = State.regs[srcreg1];

  State.regs[dstreg2] >>= IMM4;
  State.regs[dstreg1] = result1;
}
  
  
// 1111 0111 1100 1101 Rm1 Rn1 Rm2 Rn2; sat16_asl Rm1, Rn1, Rm2, Rn2
8.0xf7+8.0xcd+4.RM1,4.RN1+4.RM2,4.RN2!RN1:D2:::sat16_asl
"sat16_asl"
*am33
*am33_2
{
  int srcreg1, srcreg2, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  srcreg2 = translate_rreg (SD_, RM2);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  if (State.regs[srcreg1] >= 0x7fff)
    result1 = 0x7fff;
  else if (State.regs[srcreg1] <= 0xffff8000)
    result1 = 0xffff8000;
  else
    result1 = State.regs[srcreg1];

  State.regs[dstreg2] <<= State.regs[srcreg2];
  State.regs[dstreg1] = result1;
}

// 1111 0111 1101 1101 Rm1 Rn1 imm4 Rn2; sat16_asl Rm1, Rn1, imm4, Rn2
8.0xf7+8.0xdd+4.RM1,4.RN1+4.IMM4,4.RN2!RN1:D2b:::sat16_asl
"sat16_asl"
*am33
*am33_2
{
  int srcreg1, dstreg1, dstreg2;
  int result1;

  PC = cia;
  srcreg1 = translate_rreg (SD_, RM1);
  dstreg1 = translate_rreg (SD_, RN1);
  dstreg2 = translate_rreg (SD_, RN2);

  if (State.regs[srcreg1] >= 0x7fff)
    result1 = 0x7fff;
  else if (State.regs[srcreg1] <= 0xffff8000)
    result1 = 0xffff8000;
  else
    result1 = State.regs[srcreg1];

  State.regs[dstreg2] <<= IMM4;
  State.regs[dstreg1] = result1;
}

// 1111 0111 1110 0000 Rm1 Rn1 imm4 0000; mov_llt (Rm+,imm4),Rn
8.0xf7+8.0xe0+4.RN,4.RM!RN+4.IMM4,4.0x0:D2:::mov_llt
"mov_llt"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM);
  dstreg = translate_rreg (SD_, RN);

  State.regs[dstreg] = load_word (State.regs[srcreg]);
  State.regs[srcreg] += EXTEND4 (IMM4);

  if (((PSW & PSW_N) != 0) ^ ((PSW & PSW_V) != 0))
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}

// 1111 0111 1110 0000 Rm1 Rn1 imm4 0001; mov_lgt (Rm+,imm4),Rn
8.0xf7+8.0xe0+4.RN,4.RM!RN+4.IMM4,4.0x1:D2:::mov_lgt
"mov_lgt"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM);
  dstreg = translate_rreg (SD_, RN);

  State.regs[dstreg] = load_word (State.regs[srcreg]);
  State.regs[srcreg] += EXTEND4 (IMM4);

  if (!((PSW & PSW_Z)
        || (((PSW & PSW_N) != 0) ^ ((PSW & PSW_V) != 0))))
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}

// 1111 0111 1110 0000 Rm1 Rn1 imm4 0010; mov_lge (Rm+,imm4),Rn
8.0xf7+8.0xe0+4.RN,4.RM!RN+4.IMM4,4.0x2:D2:::mov_lge
"mov_lge"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM);
  dstreg = translate_rreg (SD_, RN);

  State.regs[dstreg] = load_word (State.regs[srcreg]);
  State.regs[srcreg] += EXTEND4 (IMM4);

  if (!(((PSW & PSW_N) != 0) ^ ((PSW & PSW_V) != 0)))
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}

// 1111 0111 1110 0000 Rm1 Rn1 imm4 0011; mov_lle (Rm+,imm4),Rn
8.0xf7+8.0xe0+4.RN,4.RM!RN+4.IMM4,4.0x3:D2:::mov_lle
"mov_lle"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM);
  dstreg = translate_rreg (SD_, RN);

  State.regs[dstreg] = load_word (State.regs[srcreg]);
  State.regs[srcreg] += EXTEND4 (IMM4);

  if ((PSW & PSW_Z)
      || (((PSW & PSW_N) != 0) ^ ((PSW & PSW_V) != 0)))
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}

// 1111 0111 1110 0000 Rm1 Rn1 imm4 0100; mov_lcs (Rm+,imm4),Rn
8.0xf7+8.0xe0+4.RN,4.RM!RN+4.IMM4,4.0x4:D2:::mov_lcs
"mov_lcs"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM);
  dstreg = translate_rreg (SD_, RN);

  State.regs[dstreg] = load_word (State.regs[srcreg]);
  State.regs[srcreg] += EXTEND4 (IMM4);

  if (PSW & PSW_C)
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}

// 1111 0111 1110 0000 Rm1 Rn1 imm4 0101; mov_lhi (Rm+,imm4),Rn
8.0xf7+8.0xe0+4.RN,4.RM!RN+4.IMM4,4.0x5:D2:::mov_lhi
"mov_lhi"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM);
  dstreg = translate_rreg (SD_, RN);

  State.regs[dstreg] = load_word (State.regs[srcreg]);
  State.regs[srcreg] += EXTEND4 (IMM4);

  if (!(((PSW & PSW_C) != 0) || (PSW & PSW_Z) != 0))
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}

// 1111 0111 1110 0000 Rm1 Rn1 imm4 0110; mov_lcc (Rm+,imm4),Rn
8.0xf7+8.0xe0+4.RN,4.RM!RN+4.IMM4,4.0x6:D2:::mov_lcc
"mov_lcc"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM);
  dstreg = translate_rreg (SD_, RN);

  State.regs[dstreg] = load_word (State.regs[srcreg]);
  State.regs[srcreg] += EXTEND4 (IMM4);

  if (!(PSW & PSW_C))
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}

// 1111 0111 1110 0000 Rm1 Rn1 imm4 0111; mov_lls (Rm+,imm4),Rn
8.0xf7+8.0xe0+4.RN,4.RM!RN+4.IMM4,4.0x7:D2:::mov_lls
"mov_lls"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM);
  dstreg = translate_rreg (SD_, RN);

  State.regs[dstreg] = load_word (State.regs[srcreg]);
  State.regs[srcreg] += EXTEND4 (IMM4);

  if (((PSW & PSW_C) != 0) || (PSW & PSW_Z) != 0)
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}

// 1111 0111 1110 0000 Rm1 Rn1 imm4 1000; mov_leq (Rm+,imm4),Rn
8.0xf7+8.0xe0+4.RN,4.RM!RN+4.IMM4,4.0x8:D2:::mov_leq
"mov_leq"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM);
  dstreg = translate_rreg (SD_, RN);

  State.regs[dstreg] = load_word (State.regs[srcreg]);
  State.regs[srcreg] += EXTEND4 (IMM4);

  if (PSW & PSW_Z)
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}

// 1111 0111 1110 0000 Rm1 Rn1 imm4 1001; mov_lne (Rm+,imm4),Rn
8.0xf7+8.0xe0+4.RN,4.RM!RN+4.IMM4,4.0x9:D2:::mov_lne
"mov_lne"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM);
  dstreg = translate_rreg (SD_, RN);

  State.regs[dstreg] = load_word (State.regs[srcreg]);
  State.regs[srcreg] += EXTEND4 (IMM4);

  if (!(PSW & PSW_Z))
    {
      State.regs[REG_PC] = State.regs[REG_LAR] - 4;
      nia = PC;
    }
}

// 1111 0111 1110 0000 Rm1 Rn1 imm4 1010; mov_lra (Rm+,imm4),Rn
8.0xf7+8.0xe0+4.RN,4.RM!RN+4.IMM4,4.0xa:D2:::mov_lra
"mov_lra"
*am33
*am33_2
{
  int srcreg, dstreg;

  PC = cia;
  srcreg = translate_rreg (SD_, RM);
  dstreg = translate_rreg (SD_, RN);

  State.regs[dstreg] = load_word (State.regs[srcreg]);
  State.regs[srcreg] += EXTEND4 (IMM4);

  State.regs[REG_PC] = State.regs[REG_LAR] - 4;
  nia = PC;
}

:include::am33_2:am33-2.igen
@


1.9
log
@2000-08-07  Graham Stott  <grahams@@cygnus.co.uk>
* am33-2.igen (fmadd, fmsub, fmnadd, fmnsub): Correct typo.
2000-05-29  Alexandre Oliva  <aoliva@@cygnus.com>
* interp.c (fpu_disabled_exception, fpu_unimp_exception,
fpu_check_signal_exception): Take additional state arguments.
Print exception type and call program_interrupt.  Adjust callers.
(fpu_rsqrt, fpu_cmp, fpu_add, fpu_sub, fpu_mul, fpu_div,
fpu_fmadd, fpu_fmsub, fpu_fnmadd, fpu_fnmsub): Take additional
arguments.
* mn10300_sim.h (fpu_disabled_exception, fpu_unimp_exception,
fpu_check_signal_exception): Adjust prototypes.
(fpu_rsqrt, fpu_cmp, fpu_add, fpu_sub, fpu_mul, fpu_div,
fpu_fmadd, fpu_fmsub, fpu_fnmadd, fpu_fnmsub): Likewise.
* am33-2.igen: Adjust calls.
2000-05-19  Alexandre Oliva  <aoliva@@cygnus.com>
* op_utils.c (cmp2fcc): Moved...
* interp.c: ... here.
2000-05-18  Alexandre Oliva  <aoliva@@cygnus.com>
* am33-2.igen: Use `unsigned32', `signed32', `unsigned64' or
`signed64' where type width is relevant.
2000-05-15  Alexandre Oliva  <aoliva@@cygnus.com>
* mn10300_sim.h: Include sim-fpu.h.
(FD2FPU, FPU2FD): Enclose the FD argument in parentheses.
(fpu_check_signal_exception): Declare.
(struct fp_prec_t, fp_single_prec, fp_double_prec): Likewise.
(FP_SINGLE, FP_DOUBLE): Shorthands for fp_*_prec.
(fpu_rsqrt, fpu_cmp, fpu_add, fpu_sub, fpu_mul, fpu_div,
fpu_fmadd, fpu_fmsub, fpu_fnmadd, fpu_fnmsub): Declare.
* interp.c (fpu_disabled_exception): Document.
(fpu_unimp_exception): Likewise.
(fpu_check_signal_exception): Define.
(reg2val_32, round_32, val2reg_32, fp_single_prec): Likewise.
(reg2val_64, round_64, val2reg_64, fp_double_prec): Likewise.
(REG2VAL, ROUND, VAL2REG): Define shorthands.
(fpu_status_ok): Define.
(fpu_rsqrt, fpu_cmp, fpu_add, fpu_sub, fpu_mul, fpu_div,
fpu_fmadd, fpu_fmsub, fpu_fnmadd, fpu_fnmsub): Define.
* am33-2.igen (frsqrt, fcmp, fadd, fsub, fmul, fdiv,
fmadd, fmsub, fnmadd, fnmsub): Use new functions.
2000-04-27  Alexandre Oliva  <aoliva@@cygnus.com>
* interp.c (sim_create_inferior): Set PSW bit to enable FP insns
if architecture is AM33/2.0.
* am33.igen: Include am33-2.igen.
2000-04-23  Alexandre Oliva  <aoliva@@cygnus.com>
* mn10300.igen (movm, call, ret, retf): Check for am33_2 too.
* am33.igen (movm): Likewise.
2000-04-19  Alexandre Oliva  <aoliva@@cygnus.com>
* am33.igen: Added `*am33_2' to some instructions that were
missing it.
2000-04-07  Alexandre Oliva  <aoliva@@cygnus.com>
* am33-2.igen: New file.  All insns implemented, but FP flags are
only set for fcmp, exceptional conditions are not handled yet.
* Makefile.in (IGEN_INSN): Added am33-2.igen.
(tmp-igen): Added -M am33_2.
* mn10300.igen, am33.igen: Added `*am33_2' to all insns.
* gencode.c: Support FMT_D3.
* mn10300_sim.h (dword): New type.
(struct _state): Added fpregs.
(REG_FPCR, FPCR): New define.  All assorted bitmaps.
(XS2FS, AS2FS, Xf2FD): New macros.
(FS2FPU, FD2FPU, FPU2FS, FPU2FD): Likewise.
(load_dword, store_dword): New functions or macros.
(u642dw, dw2u64): New functions.
(fpu_disabled_exception, fpu_unimp_exception): Declared.
* interp.c (fpu_disabled_exception): Defined; no actual
implementation.
(fpu_unimp_exception): Likewise.
* op_utils.c (cmp2fcc): New function.
@
text
@d2576 1
a2576 1
  c = (source1 > source1);
@


1.8
log
@Index: common/ChangeLog
2003-02-26  Andrew Cagney  <cagney@@redhat.com>

	* sim-engine.h (sim_engine_abort): Add noreturn attribute.
	(sim_engine_vabort): Ditto.
	(sim_engine_halt, sim_engine_restart): Ditto.

Index: mn10300/ChangeLog
2003-02-26  Andrew Cagney  <cagney@@redhat.com>

	* am33.igen: Call sim_engine_abort instead of abort.
@
text
@d45 1
d56 1
d67 1
d78 1
d89 1
d99 1
d109 1
d120 1
d138 1
d149 1
d159 1
d171 1
d183 1
d195 1
d208 1
d260 1
d302 1
d311 1
d396 1
d406 1
d416 1
d431 1
d447 1
d461 1
d475 1
d489 1
d503 1
d518 1
d532 1
d562 1
d576 1
d606 1
d619 1
d632 1
d646 1
d661 1
d676 1
d697 1
d717 1
d737 1
d756 1
d780 1
d802 1
d822 1
d841 1
d866 1
d891 1
d915 1
d939 1
d965 1
d992 1
d1006 1
d1020 1
d1034 1
d1048 1
d1062 1
d1076 1
d1091 1
d1106 1
d1119 1
d1132 1
d1145 1
d1158 1
d1171 1
d1184 1
d1199 1
d1215 1
d1244 1
d1273 1
d1297 1
d1321 1
d1350 1
d1379 1
d1405 1
d1431 1
d1452 1
d1473 1
d1501 1
d1599 1
d1617 1
d1635 1
d1651 1
d1691 1
d1704 1
d1717 1
d1730 1
d1759 1
d1773 1
d1802 1
d1815 1
d1829 1
d1848 1
d1867 1
d1886 1
d1909 1
d1929 1
d1948 1
d1971 1
d1994 1
d2007 1
d2021 1
d2035 1
d2049 1
d2063 1
d2077 1
d2091 1
d2106 1
d2122 1
d2135 1
d2148 1
d2161 1
d2174 1
d2187 1
d2200 1
d2215 1
d2231 1
d2259 1
d2287 1
d2315 1
d2343 1
d2371 1
d2399 1
d2496 1
d2527 1
d2558 1
d2589 1
d2620 1
d2643 1
d2666 1
d2689 1
d2716 1
d2740 1
d2763 1
d2791 1
d2819 1
d2832 1
d2845 1
d2858 1
d2871 1
d2884 1
d2897 1
d2912 1
d2927 1
d2942 1
d2957 1
d2972 1
d2987 1
d3024 1
d3061 1
d3090 1
d3119 1
d3150 1
d3181 1
d3212 1
d3243 1
d3266 1
d3289 1
d3317 1
d3357 1
d3370 1
d3383 1
d3396 1
d3424 1
d3437 1
d3465 1
d3478 1
d3492 1
d3511 1
d3530 1
d3549 1
d3573 1
d3593 1
d3612 1
d3635 1
d3658 1
d3671 1
d3687 1
d3702 1
d3718 1
d3733 1
d3749 1
d3764 1
d3779 1
d3795 1
d3809 1
d3823 1
d3837 1
d3851 1
d3865 1
d3879 1
d3894 1
d3909 1
d3937 1
d3965 1
d3993 1
d4021 1
d4049 1
d4077 1
d4090 1
d4104 1
d4117 1
d4131 1
d4144 1
d4158 1
d4171 1
d4184 1
d4197 1
d4226 1
d4239 1
d4268 1
d4281 1
d4295 1
d4314 1
d4333 1
d4352 1
d4375 1
d4395 1
d4414 1
d4437 1
d4460 1
d4473 1
d4488 1
d4503 1
d4518 1
d4533 1
d4548 1
d4563 1
d4578 1
d4594 1
d4608 1
d4622 1
d4636 1
d4650 1
d4664 1
d4679 1
d4694 1
d4710 1
d4739 1
d4768 1
d4792 1
d4816 1
d4840 1
d4864 1
d4890 1
d4916 1
d4937 1
d4958 1
d4971 1
d4984 1
d4997 1
d5010 1
d5023 1
d5036 1
d5056 1
d5075 1
d5095 1
d5114 1
d5132 1
d5149 1
d5169 1
d5188 1
d5211 1
d5233 1
d5253 1
d5273 1
d5293 1
d5312 1
d5330 1
d5347 1
d5365 1
d5382 1
d5400 1
d5417 1
d5438 1
d5458 1
d5476 1
d5494 1
d5512 1
d5529 1
d5549 1
d5568 1
d5588 1
d5607 1
d5625 1
d5642 1
d5662 1
d5681 1
d5704 1
d5726 1
d5746 1
d5766 1
d5786 1
d5805 1
d5825 1
d5844 1
d5864 1
d5883 1
d5901 1
d5918 1
d5938 1
d5957 1
d5980 1
d6002 1
d6022 1
d6042 1
d6062 1
d6081 1
d6100 1
d6118 1
d6137 1
d6155 1
d6172 1
d6188 1
d6207 1
d6225 1
d6247 1
d6268 1
d6287 1
d6306 1
d6325 1
d6343 1
d6360 1
d6376 1
d6393 1
d6409 1
d6426 1
d6442 1
d6462 1
d6481 1
d6498 1
d6515 1
d6532 1
d6548 1
d6567 1
d6585 1
d6604 1
d6622 1
d6639 1
d6655 1
d6674 1
d6692 1
d6714 1
d6735 1
d6754 1
d6773 1
d6792 1
d6810 1
d6829 1
d6847 1
d6866 1
d6884 1
d6901 1
d6917 1
d6936 1
d6954 1
d6976 1
d6997 1
d7016 1
d7035 1
d7054 1
d7072 1
d7092 1
d7111 1
d7131 1
d7150 1
d7168 1
d7185 1
d7205 1
d7224 1
d7247 1
d7269 1
d7289 1
d7309 1
d7329 1
d7348 1
d7373 1
d7397 1
d7422 1
d7446 1
d7471 1
d7495 1
d7520 1
d7544 1
d7571 1
d7597 1
d7622 1
d7647 1
d7672 1
d7696 1
d7716 1
d7735 1
d7755 1
d7774 1
d7792 1
d7809 1
d7829 1
d7848 1
d7871 1
d7893 1
d7913 1
d7933 1
d7953 1
d7972 1
d7992 1
d8012 1
d8033 1
d8053 1
d8072 1
d8090 1
d8111 1
d8131 1
d8155 1
d8178 1
d8199 1
d8220 1
d8241 1
d8261 1
d8281 1
d8300 1
d8320 1
d8339 1
d8357 1
d8374 1
d8394 1
d8413 1
d8436 1
d8458 1
d8478 1
d8498 1
d8518 1
d8537 1
d8563 1
d8588 1
d8614 1
d8639 1
d8662 1
d8684 1
d8710 1
d8735 1
d8764 1
d8792 1
d8818 1
d8844 1
d8870 1
d8895 1
d8917 1
d8940 1
d8962 1
d8985 1
d9007 1
d9029 1
d9051 1
d9073 1
d9095 1
d9117 1
d9132 1
@


1.8.42.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a44 1
*am33_2
a54 1
*am33_2
a64 1
*am33_2
a74 1
*am33_2
a84 1
*am33_2
a93 1
*am33_2
a102 1
*am33_2
a112 1
*am33_2
a129 1
*am33_2
a139 1
*am33_2
a148 1
*am33_2
a159 1
*am33_2
a170 1
*am33_2
a181 1
*am33_2
a193 1
*am33_2
a244 1
      || STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2
a285 1
*am33_2
a293 1
      || STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2
a377 1
*am33_2
a386 1
*am33_2
a395 1
*am33_2
a409 1
*am33_2
a424 1
*am33_2
a437 1
*am33_2
a450 1
*am33_2
a463 1
*am33_2
a476 1
*am33_2
a490 1
*am33_2
a503 1
*am33_2
a532 1
*am33_2
a545 1
*am33_2
a574 1
*am33_2
a586 1
*am33_2
a598 1
*am33_2
a611 1
*am33_2
a625 1
*am33_2
a639 1
*am33_2
a659 1
*am33_2
a678 1
*am33_2
a697 1
*am33_2
a715 1
*am33_2
a738 1
*am33_2
a759 1
*am33_2
a778 1
*am33_2
a796 1
*am33_2
a820 1
*am33_2
a844 1
*am33_2
a867 1
*am33_2
a890 1
*am33_2
a915 1
*am33_2
a941 1
*am33_2
a954 1
*am33_2
a967 1
*am33_2
a980 1
*am33_2
a993 1
*am33_2
a1006 1
*am33_2
a1019 1
*am33_2
a1033 1
*am33_2
a1047 1
*am33_2
a1059 1
*am33_2
a1071 1
*am33_2
a1083 1
*am33_2
a1095 1
*am33_2
a1107 1
*am33_2
a1119 1
*am33_2
a1133 1
*am33_2
a1148 1
*am33_2
a1176 1
*am33_2
a1204 1
*am33_2
a1227 1
*am33_2
a1250 1
*am33_2
a1278 1
*am33_2
a1306 1
*am33_2
a1331 1
*am33_2
a1356 1
*am33_2
a1376 1
*am33_2
a1396 1
*am33_2
a1423 1
*am33_2
a1520 1
*am33_2
a1537 1
*am33_2
a1554 1
*am33_2
a1569 1
*am33_2
a1608 1
*am33_2
a1620 1
*am33_2
a1632 1
*am33_2
a1644 1
*am33_2
a1672 1
*am33_2
a1685 1
*am33_2
a1713 1
*am33_2
a1725 1
*am33_2
a1738 1
*am33_2
a1756 1
*am33_2
a1774 1
*am33_2
a1792 1
*am33_2
a1814 1
*am33_2
a1833 1
*am33_2
a1851 1
*am33_2
a1873 1
*am33_2
a1895 1
*am33_2
a1907 1
*am33_2
a1920 1
*am33_2
a1933 1
*am33_2
a1946 1
*am33_2
a1959 1
*am33_2
a1972 1
*am33_2
a1985 1
*am33_2
a1999 1
*am33_2
a2014 1
*am33_2
a2026 1
*am33_2
a2038 1
*am33_2
a2050 1
*am33_2
a2062 1
*am33_2
a2074 1
*am33_2
a2086 1
*am33_2
a2100 1
*am33_2
a2115 1
*am33_2
a2142 1
*am33_2
a2169 1
*am33_2
a2196 1
*am33_2
a2223 1
*am33_2
a2250 1
*am33_2
a2277 1
*am33_2
a2373 1
*am33_2
a2403 1
*am33_2
a2433 1
*am33_2
a2463 1
*am33_2
a2493 1
*am33_2
a2515 1
*am33_2
a2537 1
*am33_2
a2559 1
*am33_2
a2585 1
*am33_2
a2608 1
*am33_2
a2630 1
*am33_2
a2657 1
*am33_2
a2684 1
*am33_2
a2696 1
*am33_2
a2708 1
*am33_2
a2720 1
*am33_2
a2732 1
*am33_2
a2744 1
*am33_2
a2756 1
*am33_2
a2770 1
*am33_2
a2784 1
*am33_2
a2798 1
*am33_2
a2812 1
*am33_2
a2826 1
*am33_2
a2840 1
*am33_2
a2876 1
*am33_2
a2912 1
*am33_2
a2940 1
*am33_2
a2968 1
*am33_2
a2998 1
*am33_2
a3028 1
*am33_2
a3058 1
*am33_2
a3088 1
*am33_2
a3110 1
*am33_2
a3132 1
*am33_2
a3159 1
*am33_2
a3198 1
*am33_2
a3210 1
*am33_2
a3222 1
*am33_2
a3234 1
*am33_2
a3261 1
*am33_2
a3273 1
*am33_2
a3300 1
*am33_2
a3312 1
*am33_2
a3325 1
*am33_2
a3343 1
*am33_2
a3361 1
*am33_2
a3379 1
*am33_2
a3402 1
*am33_2
a3421 1
*am33_2
a3439 1
*am33_2
a3461 1
*am33_2
a3483 1
*am33_2
a3495 1
*am33_2
a3510 1
*am33_2
a3524 1
*am33_2
a3539 1
*am33_2
a3553 1
*am33_2
a3568 1
*am33_2
a3582 1
*am33_2
a3596 1
*am33_2
a3611 1
*am33_2
a3624 1
*am33_2
a3637 1
*am33_2
a3650 1
*am33_2
a3663 1
*am33_2
a3676 1
*am33_2
a3689 1
*am33_2
a3703 1
*am33_2
a3717 1
*am33_2
a3744 1
*am33_2
a3771 1
*am33_2
a3798 1
*am33_2
a3825 1
*am33_2
a3852 1
*am33_2
a3879 1
*am33_2
a3891 1
*am33_2
a3904 1
*am33_2
a3916 1
*am33_2
a3929 1
*am33_2
a3941 1
*am33_2
a3954 1
*am33_2
a3966 1
*am33_2
a3978 1
*am33_2
a3990 1
*am33_2
a4018 1
*am33_2
a4030 1
*am33_2
a4058 1
*am33_2
a4070 1
*am33_2
a4083 1
*am33_2
a4101 1
*am33_2
a4119 1
*am33_2
a4137 1
*am33_2
a4159 1
*am33_2
a4178 1
*am33_2
a4196 1
*am33_2
a4218 1
*am33_2
a4240 1
*am33_2
a4252 1
*am33_2
a4266 1
*am33_2
a4280 1
*am33_2
a4294 1
*am33_2
a4308 1
*am33_2
a4322 1
*am33_2
a4336 1
*am33_2
a4350 1
*am33_2
a4365 1
*am33_2
a4378 1
*am33_2
a4391 1
*am33_2
a4404 1
*am33_2
a4417 1
*am33_2
a4430 1
*am33_2
a4444 1
*am33_2
a4458 1
*am33_2
a4473 1
*am33_2
a4501 1
*am33_2
a4529 1
*am33_2
a4552 1
*am33_2
a4575 1
*am33_2
a4598 1
*am33_2
a4621 1
*am33_2
a4646 1
*am33_2
a4671 1
*am33_2
a4691 1
*am33_2
a4711 1
*am33_2
a4723 1
*am33_2
a4735 1
*am33_2
a4747 1
*am33_2
a4759 1
*am33_2
a4771 1
*am33_2
a4783 1
*am33_2
a4802 1
*am33_2
a4820 1
*am33_2
a4839 1
*am33_2
a4857 1
*am33_2
a4874 1
*am33_2
a4890 1
*am33_2
a4909 1
*am33_2
a4927 1
*am33_2
a4949 1
*am33_2
a4970 1
*am33_2
a4989 1
*am33_2
a5008 1
*am33_2
a5027 1
*am33_2
a5045 1
*am33_2
a5062 1
*am33_2
a5078 1
*am33_2
a5095 1
*am33_2
a5111 1
*am33_2
a5128 1
*am33_2
a5144 1
*am33_2
a5164 1
*am33_2
a5183 1
*am33_2
a5200 1
*am33_2
a5217 1
*am33_2
a5234 1
*am33_2
a5250 1
*am33_2
a5269 1
*am33_2
a5287 1
*am33_2
a5306 1
*am33_2
a5324 1
*am33_2
a5341 1
*am33_2
a5357 1
*am33_2
a5376 1
*am33_2
a5394 1
*am33_2
a5416 1
*am33_2
a5437 1
*am33_2
a5456 1
*am33_2
a5475 1
*am33_2
a5494 1
*am33_2
a5512 1
*am33_2
a5531 1
*am33_2
a5549 1
*am33_2
a5568 1
*am33_2
a5586 1
*am33_2
a5603 1
*am33_2
a5619 1
*am33_2
a5638 1
*am33_2
a5656 1
*am33_2
a5678 1
*am33_2
a5699 1
*am33_2
a5718 1
*am33_2
a5737 1
*am33_2
a5756 1
*am33_2
a5774 1
*am33_2
a5792 1
*am33_2
a5809 1
*am33_2
a5827 1
*am33_2
a5844 1
*am33_2
a5860 1
*am33_2
a5875 1
*am33_2
a5893 1
*am33_2
a5910 1
*am33_2
a5931 1
*am33_2
a5951 1
*am33_2
a5969 1
*am33_2
a5987 1
*am33_2
a6005 1
*am33_2
a6022 1
*am33_2
a6038 1
*am33_2
a6053 1
*am33_2
a6069 1
*am33_2
a6084 1
*am33_2
a6100 1
*am33_2
a6115 1
*am33_2
a6134 1
*am33_2
a6152 1
*am33_2
a6168 1
*am33_2
a6184 1
*am33_2
a6200 1
*am33_2
a6215 1
*am33_2
a6233 1
*am33_2
a6250 1
*am33_2
a6268 1
*am33_2
a6285 1
*am33_2
a6301 1
*am33_2
a6316 1
*am33_2
a6334 1
*am33_2
a6351 1
*am33_2
a6372 1
*am33_2
a6392 1
*am33_2
a6410 1
*am33_2
a6428 1
*am33_2
a6446 1
*am33_2
a6463 1
*am33_2
a6481 1
*am33_2
a6498 1
*am33_2
a6516 1
*am33_2
a6533 1
*am33_2
a6549 1
*am33_2
a6564 1
*am33_2
a6582 1
*am33_2
a6599 1
*am33_2
a6620 1
*am33_2
a6640 1
*am33_2
a6658 1
*am33_2
a6676 1
*am33_2
a6694 1
*am33_2
a6711 1
*am33_2
a6730 1
*am33_2
a6748 1
*am33_2
a6767 1
*am33_2
a6785 1
*am33_2
a6802 1
*am33_2
a6818 1
*am33_2
a6837 1
*am33_2
a6855 1
*am33_2
a6877 1
*am33_2
a6898 1
*am33_2
a6917 1
*am33_2
a6936 1
*am33_2
a6955 1
*am33_2
a6973 1
*am33_2
a6997 1
*am33_2
a7020 1
*am33_2
a7044 1
*am33_2
a7067 1
*am33_2
a7091 1
*am33_2
a7114 1
*am33_2
a7138 1
*am33_2
a7161 1
*am33_2
a7187 1
*am33_2
a7212 1
*am33_2
a7236 1
*am33_2
a7260 1
*am33_2
a7284 1
*am33_2
a7307 1
*am33_2
a7326 1
*am33_2
a7344 1
*am33_2
a7363 1
*am33_2
a7381 1
*am33_2
a7398 1
*am33_2
a7414 1
*am33_2
a7433 1
*am33_2
a7451 1
*am33_2
a7473 1
*am33_2
a7494 1
*am33_2
a7513 1
*am33_2
a7532 1
*am33_2
a7551 1
*am33_2
a7569 1
*am33_2
a7588 1
*am33_2
a7607 1
*am33_2
a7627 1
*am33_2
a7646 1
*am33_2
a7664 1
*am33_2
a7681 1
*am33_2
a7701 1
*am33_2
a7720 1
*am33_2
a7743 1
*am33_2
a7765 1
*am33_2
a7785 1
*am33_2
a7805 1
*am33_2
a7825 1
*am33_2
a7844 1
*am33_2
a7863 1
*am33_2
a7881 1
*am33_2
a7900 1
*am33_2
a7918 1
*am33_2
a7935 1
*am33_2
a7951 1
*am33_2
a7970 1
*am33_2
a7988 1
*am33_2
a8010 1
*am33_2
a8031 1
*am33_2
a8050 1
*am33_2
a8069 1
*am33_2
a8088 1
*am33_2
a8106 1
*am33_2
a8131 1
*am33_2
a8155 1
*am33_2
a8180 1
*am33_2
a8204 1
*am33_2
a8226 1
*am33_2
a8247 1
*am33_2
a8272 1
*am33_2
a8296 1
*am33_2
a8324 1
*am33_2
a8351 1
*am33_2
a8376 1
*am33_2
a8401 1
*am33_2
a8426 1
*am33_2
a8450 1
*am33_2
a8471 1
*am33_2
a8493 1
*am33_2
a8514 1
*am33_2
a8536 1
*am33_2
a8557 1
*am33_2
a8578 1
*am33_2
a8599 1
*am33_2
a8620 1
*am33_2
a8641 1
*am33_2
a8662 1
*am33_2
a8676 1
:include::am33_2:am33-2.igen
@


1.7
log
@* am33.igen: Warning clean-up.
(movm): Initialize PC and mask.
(mov, movbu, movhu): Set srcreg2 from RI0.
(bsch): Initialize c.
(sat16_cmp): Actually do the comparison.
(mov_llt): Do not overwrite dstreg with uninitialized variable.
@
text
@d37 1
a37 1
      abort ();
@


1.7.24.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d37 1
a37 1
      sim_engine_abort (SD, CPU, cia, "%s:%d: bad switch\n", __FILE__, __LINE__);
@


1.7.22.1
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d37 1
a37 1
      sim_engine_abort (SD, CPU, cia, "%s:%d: bad switch\n", __FILE__, __LINE__);
@


1.6
log
@minor formatting tweaks to aid syncronisation
@
text
@d290 3
d1584 1
d1648 1
a1648 1
  unsigned32 reg1, reg2, sum;
d1689 1
a1689 1
  unsigned32 reg1, reg2, difference;
d1835 1
a1835 1
  int srcreg, dstreg;
d2762 1
a2762 1
  srcreg1 = translate_rreg (SD_, RI0);
d2790 1
a2790 1
  srcreg1 = translate_rreg (SD_, RI0);
d2818 1
a2818 1
  srcreg1 = translate_rreg (SD_, RI0);
d3174 2
a3175 1
    
d3423 1
a3423 1
  int srcreg, dstreg;
d4180 1
a4180 1
  int srcreg, dstreg;
a4992 1
  signed int temp;
a5030 1
  signed int temp;
a5202 1
  signed int temp;
a5236 1
  signed int temp;
a5343 1
  int result1;
a5459 1
  signed int temp;
a5497 1
  signed int temp;
a5721 1
  signed int temp;
a5759 1
  signed int temp;
a5972 1
  signed int temp;
a6008 1
  signed int temp;
a6170 1
  signed int temp;
a6202 1
  signed int temp;
a6287 1
  int result1;
a6303 1
  int result1;
a6413 1
  signed int temp;
a6449 1
  signed int temp;
a6661 1
  signed int temp;
a6697 1
  signed int temp;
a6920 1
  signed int temp;
a6958 1
  signed int temp;
a7516 1
  signed int temp;
a7554 1
  signed int temp;
a7788 1
  signed int temp;
a7828 1
  signed int temp;
a8053 1
  signed int temp;
a8091 1
  signed int temp;
a8206 1
  int result1;
d8214 1
a8214 1
  State.regs[dstreg1] = result1;
a8379 1
  signed int temp;
a8429 1
  signed int temp;
a8452 1
  int result1;
a8465 1
  State.regs[dstreg] = result1;
@


1.5
log
@* am33.igen: Fix leading comments of SP-relative offset insns that
referred to other registers.  Make their offsets unsigned.
@
text
@d244 2
a245 1
  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33)
d290 2
a291 1
  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33)
d8703 1
@


1.4
log
@* mn10300_sim.h (genericAdd, genericSub, genericCmp, genericOr,
genericXor, genericBtst): Use `unsigned32'.
* op_utils.c: Likewise.
* mn10300.igen, am33.igen: Use `unsigned32', `signed32',
`unsigned64' or `signed64' where type width is relevant.
@
text
@d2017 1
a2017 1
// 1111 1011 1001 1010 Rm 0000 IMM8; mov Rm,(d8,Rn)
d2026 1
a2026 1
  store_word (State.regs[REG_SP] + EXTEND8 (IMM8), State.regs[srcreg]);
d2041 1
a2041 1
// 1111 1011 1011 1010 Rn Rm IMM8; movbu Rm,(sp,Rn)
d2050 1
a2050 1
  store_byte (State.regs[REG_SP] + EXTEND8 (IMM8), State.regs[srcreg]);
d3627 1
a3627 1
// 1111 1101 1010 1010 Rn 0000 IMM24; movbu (d24,Rm),Rn
d3637 1
a3637 2
				  + EXTEND24 (FETCH24 (IMM24A,
						       IMM24B, IMM24C)));
@


1.3
log
@* am33.igen (inc4 Rn): Use genericAdd so as to modify flags.
@
text
@d114 1
a114 1
  unsigned int sp, next_pc;
d195 2
a196 2
  unsigned long usp = State.regs[REG_USP];
  unsigned long mask;
d286 2
a287 2
  unsigned long usp = State.regs[REG_USP];
  unsigned long mask;
d502 1
a502 1
  unsigned long reg1, reg2, sum;
d544 1
a544 1
  unsigned long reg1, reg2, difference;
d713 1
a713 1
  long temp;
d795 1
a795 1
  unsigned long value;
d819 1
a819 1
  unsigned long value;
d842 1
a842 1
  unsigned long long temp;
d865 1
a865 1
  unsigned long long temp;
d888 1
a888 1
  long long temp;
d913 1
a913 1
  unsigned long long temp;
d1146 1
a1146 1
  long long temp, sum;
d1174 1
a1174 1
  unsigned long long temp, sum;
d1202 1
a1202 1
  long temp, sum;
d1225 1
a1225 1
  long long temp, sum;
d1248 1
a1248 1
  long long temp, sum;
d1276 1
a1276 1
  long long temp, sum;
d1304 1
a1304 1
  long temp, temp2, sum;
d1329 1
a1329 1
  unsigned long temp, temp2, sum;
d1354 1
a1354 1
  long temp;
d1374 1
a1374 1
  unsigned long temp;
d1432 1
a1432 1
      long long tmp;
d1448 1
a1448 1
      long long tmp;
d1464 1
a1464 1
      long long tmp;
d1480 1
a1480 1
      long long tmp;
d1496 1
a1496 1
      long long tmp;
d1642 1
a1642 1
  unsigned long reg1, reg2, sum;
d1683 1
a1683 1
  unsigned long reg1, reg2, difference;
d1789 1
a1789 1
  long temp;
d1848 1
a1848 1
  unsigned long long temp;
d1870 1
a1870 1
  unsigned long long temp;
d2112 1
a2112 1
  long long temp, sum;
d2139 1
a2139 1
  long long temp, sum;
d2166 1
a2166 1
  long long temp, sum;
d2193 1
a2193 1
  long long temp, sum;
d2220 1
a2220 1
  long long temp, sum;
d2247 1
a2247 1
  long long temp, sum;
d2284 1
a2284 1
      long long tmp;
d2300 1
a2300 1
      long long tmp;
d2316 1
a2316 1
      long long tmp;
d2332 1
a2332 1
      long long tmp;
d2348 1
a2348 1
      long long tmp;
d2370 1
a2370 1
  unsigned long sum, source1, source2;
d2400 1
a2400 1
  unsigned long sum, source1, source2;
d2430 1
a2430 1
  unsigned long difference, source1, source2;
d2460 1
a2460 1
  unsigned long difference, source1, source2;
d2556 1
a2556 1
  long temp;
d2627 1
a2627 1
  signed long long temp;
d2654 1
a2654 1
  signed long long temp;
d2837 2
a2838 2
  signed long long temp;
  unsigned long sum;
d2873 2
a2874 2
  signed long long temp;
  unsigned long sum;
d2909 1
a2909 1
  long temp, sum;
d2937 1
a2937 1
  long temp, sum;
d2965 1
a2965 1
  long long temp, sum;
d2995 1
a2995 1
  long long temp, sum;
d3025 1
a3025 1
  long temp, temp2, sum;
d3055 1
a3055 1
  long temp, temp2, sum;
d3085 1
a3085 1
  signed long long temp;
d3107 1
a3107 1
  signed long long temp;
d3230 1
a3230 1
  unsigned long sum, imm, reg2;
d3269 1
a3269 1
  unsigned long difference, imm, reg2;
d3375 1
a3375 1
  long temp;
d3435 1
a3435 1
  unsigned long long temp;
d3457 1
a3457 1
  unsigned long long temp;
d3714 1
a3714 1
  long long temp, sum;
d3741 1
a3741 1
  long long temp, sum;
d3768 1
a3768 1
  long long temp, sum;
d3795 1
a3795 1
  long long temp, sum;
d3822 1
a3822 1
  long long temp, sum;
d3849 1
a3849 1
  long long temp, sum;
d3987 1
a3987 1
  unsigned int imm, reg2, sum;
d4027 1
a4027 1
  unsigned int imm, reg2, difference;
d4134 1
a4134 1
  long temp;
d4193 1
a4193 1
  unsigned long long temp;
d4215 1
a4215 1
  unsigned long long temp;
d4470 1
a4470 1
  long long temp, sum;
d4498 1
a4498 1
  long long temp, sum;
d4526 1
a4526 1
  long temp, sum;
d4549 1
a4549 1
  long temp, sum;
d4572 1
a4572 1
  long temp, sum;
d4595 1
a4595 1
  long temp, sum;
d4618 1
a4618 1
  long temp, temp2, sum;
d4643 1
a4643 1
  long temp, temp2, sum;
d4668 1
a4668 1
  long temp;
d4688 1
a4688 1
  long temp;
d6991 1
a6991 1
  long temp, temp2, sum;
d7015 1
a7015 1
  long temp, temp2, sum;
d7038 1
a7038 1
  long temp, temp2, sum;
d7062 1
a7062 1
  long temp, temp2, sum;
d7085 1
a7085 1
  long temp, temp2, sum;
d7109 1
a7109 1
  long temp, temp2, sum;
d7132 1
a7132 1
  long temp, temp2, sum;
d7156 1
a7156 1
  long temp, temp2, sum;
d7179 1
a7179 1
  long temp, temp2, sum;
d7205 1
a7205 1
  long temp, temp2, sum;
d7230 1
a7230 1
  long temp, temp2, sum;
d7254 1
a7254 1
  long temp, temp2, sum;
d7278 1
a7278 1
  long temp, temp2, sum;
d7302 1
a7302 1
  long temp, temp2, sum;
@


1.2
log
@* am33.igen: Make SP-relative offsets unsigned.  Add `*am33' for
some instructions that were missing it.
@
text
@d587 1
a587 1
  State.regs[dstreg] += 4;
@


1.2.2.1
log
@* am33.igen (inc4 Rn): Use genericAdd so as to modify flags.
@
text
@d587 1
a587 1
  genericAdd (4, dstreg);
@


1.1
log
@Initial revision
@
text
@d1914 1
d1927 1
d1940 1
d1953 1
d1966 1
d1993 1
d2008 1
d2014 1
a2014 1
  State.regs[dstreg] = load_word (State.regs[REG_SP] + EXTEND8 (IMM8));
d2020 1
d2032 1
d2038 1
a2038 1
  State.regs[dstreg] = load_byte (State.regs[REG_SP] + EXTEND8 (IMM8));
d2044 1
d2056 1
d2062 1
a2062 1
  State.regs[dstreg] = load_half (State.regs[REG_SP] + EXTEND8 (IMM8));
d2068 1
d2074 1
a2074 1
  store_half (State.regs[REG_SP] + EXTEND8 (IMM8), State.regs[srcreg]);
d2094 1
d2109 1
d2136 1
d2163 1
d2190 1
d2217 1
d2244 1
d2271 1
d3611 1
a3611 2
				  + EXTEND24 (FETCH24 (IMM24A,
						       IMM24B, IMM24C)));
d3623 1
a3623 1
  store_word (State.regs[REG_SP] + EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C)),
d3650 1
a3650 1
  store_byte (State.regs[REG_SP] + EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C)),
d3664 1
a3664 2
				  + EXTEND24 (FETCH24 (IMM24A,
						       IMM24B, IMM24C)));
d3676 1
a3676 1
  store_half (State.regs[REG_SP] + EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C)),
@


1.1.1.1
log
@import gdb-1999-12-06 snapshot
@
text
@@
