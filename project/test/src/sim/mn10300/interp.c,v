head	1.9;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.9
	gdb_7_6-2013-04-26-release:1.9
	gdb_7_6-branch:1.9.0.4
	gdb_7_6-2013-03-12-branchpoint:1.9
	gdb_7_5_1-2012-11-29-release:1.9
	gdb_7_5-2012-08-17-release:1.9
	gdb_7_5-branch:1.9.0.2
	gdb_7_5-2012-07-18-branchpoint:1.9
	gdb_7_4_1-2012-04-26-release:1.7
	gdb_7_4-2012-01-24-release:1.7
	gdb_7_4-branch:1.7.0.2
	gdb_7_4-2011-12-13-branchpoint:1.7
	gdb_7_3_1-2011-09-04-release:1.6
	gdb_7_3-2011-07-26-release:1.6
	gdb_7_3-branch:1.6.0.2
	gdb_7_3-2011-04-01-branchpoint:1.6
	gdb_7_2-2010-09-02-release:1.5
	gdb_7_2-branch:1.5.0.64
	gdb_7_2-2010-07-07-branchpoint:1.5
	gdb_7_1-2010-03-18-release:1.5
	gdb_7_1-branch:1.5.0.62
	gdb_7_1-2010-02-18-branchpoint:1.5
	gdb_7_0_1-2009-12-22-release:1.5
	gdb_7_0-2009-10-06-release:1.5
	gdb_7_0-branch:1.5.0.60
	gdb_7_0-2009-09-16-branchpoint:1.5
	arc-sim-20090309:1.5
	msnyder-checkpoint-072509-branch:1.5.0.58
	msnyder-checkpoint-072509-branchpoint:1.5
	arc-insight_6_8-branch:1.5.0.56
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.54
	insight_6_8-branchpoint:1.5
	reverse-20081226-branch:1.5.0.52
	reverse-20081226-branchpoint:1.5
	multiprocess-20081120-branch:1.5.0.50
	multiprocess-20081120-branchpoint:1.5
	reverse-20080930-branch:1.5.0.48
	reverse-20080930-branchpoint:1.5
	reverse-20080717-branch:1.5.0.46
	reverse-20080717-branchpoint:1.5
	msnyder-reverse-20080609-branch:1.5.0.44
	msnyder-reverse-20080609-branchpoint:1.5
	drow-reverse-20070409-branch:1.5.0.42
	drow-reverse-20070409-branchpoint:1.5
	gdb_6_8-2008-03-27-release:1.5
	gdb_6_8-branch:1.5.0.40
	gdb_6_8-2008-02-26-branchpoint:1.5
	gdb_6_7_1-2007-10-29-release:1.5
	gdb_6_7-2007-10-10-release:1.5
	gdb_6_7-branch:1.5.0.38
	gdb_6_7-2007-09-07-branchpoint:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-2006-12-18-release:1.5
	gdb_6_6-branch:1.5.0.36
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb-csl-symbian-6_4_50_20060226-12:1.5
	gdb-csl-sourcerygxx-3_4_4-25:1.5
	nickrob-async-20060828-mergepoint:1.5
	gdb-csl-symbian-6_4_50_20060226-11:1.5
	gdb-csl-sourcerygxx-4_1-17:1.5
	gdb-csl-20060226-branch-local-2:1.5
	gdb-csl-sourcerygxx-4_1-14:1.5
	gdb-csl-sourcerygxx-4_1-13:1.5
	gdb-csl-sourcerygxx-4_1-12:1.5
	gdb-csl-sourcerygxx-3_4_4-21:1.5
	gdb_6_5-20060621-release:1.5
	gdb-csl-sourcerygxx-4_1-9:1.5
	gdb-csl-sourcerygxx-4_1-8:1.5
	gdb-csl-sourcerygxx-4_1-7:1.5
	gdb-csl-arm-2006q1-6:1.5
	gdb-csl-sourcerygxx-4_1-6:1.5
	gdb-csl-symbian-6_4_50_20060226-10:1.5
	gdb-csl-symbian-6_4_50_20060226-9:1.5
	gdb-csl-symbian-6_4_50_20060226-8:1.5
	gdb-csl-coldfire-4_1-11:1.5
	gdb-csl-sourcerygxx-3_4_4-19:1.5
	gdb-csl-coldfire-4_1-10:1.5
	gdb_6_5-branch:1.5.0.34
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb-csl-sourcerygxx-4_1-5:1.5
	nickrob-async-20060513-branch:1.5.0.32
	nickrob-async-20060513-branchpoint:1.5
	gdb-csl-sourcerygxx-4_1-4:1.5
	msnyder-reverse-20060502-branch:1.5.0.30
	msnyder-reverse-20060502-branchpoint:1.5
	gdb-csl-morpho-4_1-4:1.5
	gdb-csl-sourcerygxx-3_4_4-17:1.5
	readline_5_1-import-branch:1.5.0.28
	readline_5_1-import-branchpoint:1.5
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.5
	gdb-csl-symbian-20060226-branch:1.5.0.26
	gdb-csl-symbian-20060226-branchpoint:1.5
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.5
	msnyder-reverse-20060331-branch:1.5.0.24
	msnyder-reverse-20060331-branchpoint:1.5
	gdb-csl-available-20060303-branch:1.5.0.22
	gdb-csl-available-20060303-branchpoint:1.5
	gdb-csl-20060226-branch:1.5.0.20
	gdb-csl-20060226-branchpoint:1.5
	gdb_6_4-20051202-release:1.5
	msnyder-fork-checkpoint-branch:1.5.0.18
	msnyder-fork-checkpoint-branchpoint:1.5
	gdb-csl-gxxpro-6_3-branch:1.5.0.16
	gdb-csl-gxxpro-6_3-branchpoint:1.5
	gdb_6_4-branch:1.5.0.14
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb-csl-arm-20051020-branch:1.5.0.12
	gdb-csl-arm-20051020-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.10
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb-csl-arm-20050325-2005-q1b:1.5
	gdb-csl-arm-20050325-2005-q1a:1.5
	csl-arm-20050325-branch:1.5.0.8
	csl-arm-20050325-branchpoint:1.5
	gdb_6_3-20041109-release:1.5
	gdb_6_3-branch:1.5.0.4
	gdb_6_3-20041019-branchpoint:1.5
	drow_intercu-merge-20040921:1.5
	drow_intercu-merge-20040915:1.5
	jimb-gdb_6_2-e500-branch:1.5.0.6
	jimb-gdb_6_2-e500-branchpoint:1.5
	gdb_6_2-20040730-release:1.5
	gdb_6_2-branch:1.5.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.5
	gdb_6_1_1-20040616-release:1.2
	gdb_6_1-2004-04-05-release:1.2
	drow_intercu-merge-20040402:1.2
	drow_intercu-merge-20040327:1.2
	ezannoni_pie-20040323-branch:1.2.0.48
	ezannoni_pie-20040323-branchpoint:1.2
	cagney_tramp-20040321-mergepoint:1.2
	cagney_tramp-20040309-branch:1.2.0.46
	cagney_tramp-20040309-branchpoint:1.2
	gdb_6_1-branch:1.2.0.44
	gdb_6_1-2004-03-01-gmt-branchpoint:1.2
	drow_intercu-20040221-branch:1.2.0.42
	drow_intercu-20040221-branchpoint:1.2
	cagney_bfdfile-20040213-branch:1.2.0.40
	cagney_bfdfile-20040213-branchpoint:1.2
	drow-cplus-merge-20040208:1.2
	carlton_dictionary-20040126-merge:1.2
	cagney_bigcore-20040122-branch:1.2.0.38
	cagney_bigcore-20040122-branchpoint:1.2
	drow-cplus-merge-20040113:1.2
	drow-cplus-merge-20031224:1.2
	drow-cplus-merge-20031220:1.2
	carlton_dictionary-20031215-merge:1.2
	drow-cplus-merge-20031214:1.2
	carlton-dictionary-20031111-merge:1.2
	gdb_6_0-2003-10-04-release:1.2
	kettenis_sparc-20030918-branch:1.2.0.36
	kettenis_sparc-20030918-branchpoint:1.2
	carlton_dictionary-20030917-merge:1.2
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.34
	cagney_x86i386-20030821-branch:1.2.0.32
	cagney_x86i386-20030821-branchpoint:1.2
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.2.0.30
	gdb_6_0-2003-06-23-branchpoint:1.2
	jimb-ppc64-linux-20030613-branch:1.2.0.28
	jimb-ppc64-linux-20030613-branchpoint:1.2
	cagney_convert-20030606-branch:1.2.0.26
	cagney_convert-20030606-branchpoint:1.2
	cagney_writestrings-20030508-branch:1.2.0.24
	cagney_writestrings-20030508-branchpoint:1.2
	jimb-ppc64-linux-20030528-branch:1.2.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.2
	carlton_dictionary-20030523-merge:1.2
	cagney_fileio-20030521-branch:1.2.0.20
	cagney_fileio-20030521-branchpoint:1.2
	kettenis_i386newframe-20030517-mergepoint:1.2
	jimb-ppc64-linux-20030509-branch:1.2.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.2
	kettenis_i386newframe-20030504-mergepoint:1.2
	carlton_dictionary-20030430-merge:1.2
	kettenis_i386newframe-20030419-branch:1.2.0.16
	kettenis_i386newframe-20030419-branchpoint:1.2
	carlton_dictionary-20030416-merge:1.2
	cagney_frameaddr-20030409-mergepoint:1.2
	kettenis_i386newframe-20030406-branch:1.2.0.14
	kettenis_i386newframe-20030406-branchpoint:1.2
	cagney_frameaddr-20030403-branchpoint:1.2
	cagney_frameaddr-20030403-branch:1.2.0.12
	cagney_framebase-20030330-mergepoint:1.2
	cagney_framebase-20030326-branch:1.2.0.10
	cagney_framebase-20030326-branchpoint:1.2
	cagney_lazyid-20030317-branch:1.2.0.8
	cagney_lazyid-20030317-branchpoint:1.2
	kettenis-i386newframe-20030316-mergepoint:1.2
	offbyone-20030313-branch:1.2.0.6
	offbyone-20030313-branchpoint:1.2
	kettenis-i386newframe-20030308-branch:1.2.0.4
	kettenis-i386newframe-20030308-branchpoint:1.2
	carlton_dictionary-20030305-merge:1.2
	cagney_offbyone-20030303-branch:1.2.0.2
	cagney_offbyone-20030303-branchpoint:1.2
	carlton_dictionary-20030207-merge:1.1.1.3
	interps-20030202-branch:1.1.1.3.0.32
	interps-20030202-branchpoint:1.1.1.3
	cagney-unwind-20030108-branch:1.1.1.3.0.30
	cagney-unwind-20030108-branchpoint:1.1.1.3
	carlton_dictionary-20021223-merge:1.1.1.3
	gdb_5_3-2002-12-12-release:1.1.1.3
	carlton_dictionary-20021115-merge:1.1.1.3
	kseitz_interps-20021105-merge:1.1.1.3
	kseitz_interps-20021103-merge:1.1.1.3
	drow-cplus-merge-20021020:1.1.1.3
	drow-cplus-merge-20021025:1.1.1.3
	carlton_dictionary-20021025-merge:1.1.1.3
	carlton_dictionary-20021011-merge:1.1.1.3
	drow-cplus-branch:1.1.1.3.0.28
	drow-cplus-branchpoint:1.1.1.3
	kseitz_interps-20020930-merge:1.1.1.3
	carlton_dictionary-20020927-merge:1.1.1.3
	carlton_dictionary-branch:1.1.1.3.0.26
	carlton_dictionary-20020920-branchpoint:1.1.1.3
	gdb_5_3-branch:1.1.1.3.0.24
	gdb_5_3-2002-09-04-branchpoint:1.1.1.3
	kseitz_interps-20020829-merge:1.1.1.3
	cagney_sysregs-20020825-branch:1.1.1.3.0.22
	cagney_sysregs-20020825-branchpoint:1.1.1.3
	readline_4_3-import-branch:1.1.1.3.0.20
	readline_4_3-import-branchpoint:1.1.1.3
	gdb_5_2_1-2002-07-23-release:1.1.1.3
	kseitz_interps-20020528-branch:1.1.1.3.0.18
	kseitz_interps-20020528-branchpoint:1.1.1.3
	cagney_regbuf-20020515-branch:1.1.1.3.0.16
	cagney_regbuf-20020515-branchpoint:1.1.1.3
	jimb-macro-020506-branch:1.1.1.3.0.14
	jimb-macro-020506-branchpoint:1.1.1.3
	gdb_5_2-2002-04-29-release:1.1.1.3
	gdb_5_2-branch:1.1.1.3.0.12
	gdb_5_2-2002-03-03-branchpoint:1.1.1.3
	gdb_5_1_1-2002-01-24-release:1.1.1.3
	gdb_5_1_0_1-2002-01-03-release:1.1.1.3
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.3.0.10
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.3
	gdb_5_1-2001-11-21-release:1.1.1.3
	gdb_s390-2001-09-26-branch:1.1.1.3.0.8
	gdb_s390-2001-09-26-branchpoint:1.1.1.3
	gdb_5_1-2001-07-29-branch:1.1.1.3.0.6
	gdb_5_1-2001-07-29-branchpoint:1.1.1.3
	insight-precleanup-2001-01-01:1.1.1.3
	gdb-premipsmulti-2000-06-06-branch:1.1.1.3.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.3
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.9
date	2012.06.17.18.56.31;	author hp;	state Exp;
branches;
next	1.8;

1.8
date	2012.02.16.23.17.27;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2011.07.05.19.06.38;	author vapier;	state Exp;
branches;
next	1.6;

1.6
date	2011.01.11.14.19.33;	author aburgess;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.26.22.18.18;	author aoliva;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.26.21.53.47;	author aoliva;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.26.18.45.53;	author aoliva;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.27.23.26.34;	author cagney;	state Exp;
branches
	1.2.42.1;
next	1.1;

1.1
date	99.04.16.01.35.07;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.2.42.1
date	2004.09.16.17.02.12;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.35.07;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.33.16;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.19.23.30.02;	author jsm;	state Exp;
branches
	1.1.1.3.26.1
	1.1.1.3.28.1;
next	;

1.1.1.3.26.1
date	2003.03.06.00.56.42;	author carlton;	state Exp;
branches;
next	;

1.1.1.3.28.1
date	2003.12.14.20.28.28;	author drow;	state Exp;
branches;
next	;


desc
@@


1.9
log
@	* interp.c: Include config.h first.  Do not include sysdep.h.
@
text
@#include "config.h"
#include <signal.h>

#include "sim-main.h"
#include "sim-options.h"
#include "sim-hw.h"

#include "bfd.h"
#include "sim-assert.h"


#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif

#ifdef HAVE_STRING_H
#include <string.h>
#else
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif
#endif

#include "bfd.h"

#ifndef INLINE
#ifdef __GNUC__
#define INLINE inline
#else
#define INLINE
#endif
#endif


host_callback *mn10300_callback;
int mn10300_debug;
struct _state State;


/* simulation target board.  NULL=default configuration */
static char* board = NULL;

static DECLARE_OPTION_HANDLER (mn10300_option_handler);

enum {
  OPTION_BOARD = OPTION_START,
};

static SIM_RC
mn10300_option_handler (SIM_DESC sd,
			sim_cpu *cpu,
			int opt,
			char *arg,
			int is_command)
{
  int cpu_nr;
  switch (opt)
    {
    case OPTION_BOARD:
      {
	if (arg)
	  {
	    board = zalloc(strlen(arg) + 1);
	    strcpy(board, arg);
	  }
	return SIM_RC_OK;
      }
    }
  
  return SIM_RC_OK;
}

static const OPTION mn10300_options[] = 
{
#define BOARD_AM32 "stdeval1"
  { {"board", required_argument, NULL, OPTION_BOARD},
     '\0', "none" /* rely on compile-time string concatenation for other options */
           "|" BOARD_AM32
    , "Customize simulation for a particular board.", mn10300_option_handler },

  { {NULL, no_argument, NULL, 0}, '\0', NULL, NULL, NULL }
};

/* For compatibility */
SIM_DESC simulator;

/* These default values correspond to expected usage for the chip.  */

SIM_DESC
sim_open (SIM_OPEN_KIND kind,
	  host_callback *cb,
	  struct bfd *abfd,
	  char **argv)
{
  SIM_DESC sd = sim_state_alloc (kind, cb);
  mn10300_callback = cb;

  SIM_ASSERT (STATE_MAGIC (sd) == SIM_MAGIC_NUMBER);

  /* for compatibility */
  simulator = sd;

  /* FIXME: should be better way of setting up interrupts.  For
     moment, only support watchpoints causing a breakpoint (gdb
     halt). */
  STATE_WATCHPOINTS (sd)->pc = &(PC);
  STATE_WATCHPOINTS (sd)->sizeof_pc = sizeof (PC);
  STATE_WATCHPOINTS (sd)->interrupt_handler = NULL;
  STATE_WATCHPOINTS (sd)->interrupt_names = NULL;

  if (sim_pre_argv_init (sd, argv[0]) != SIM_RC_OK)
    return 0;
  sim_add_option_table (sd, NULL, mn10300_options);

  /* Allocate core managed memory */
  sim_do_command (sd, "memory region 0,0x100000");
  sim_do_command (sd, "memory region 0x40000000,0x200000");

  /* getopt will print the error message so we just have to exit if this fails.
     FIXME: Hmmm...  in the case of gdb we need getopt to call
     print_filtered.  */
  if (sim_parse_args (sd, argv) != SIM_RC_OK)
    {
      /* Uninstall the modules to avoid memory leaks,
	 file descriptor leaks, etc.  */
      sim_module_uninstall (sd);
      return 0;
    }

  if ( NULL != board
       && (strcmp(board, BOARD_AM32) == 0 ) )
    {
      /* environment */
      STATE_ENVIRONMENT (sd) = OPERATING_ENVIRONMENT;

      sim_do_command (sd, "memory region 0x44000000,0x40000");
      sim_do_command (sd, "memory region 0x48000000,0x400000");

      /* device support for mn1030002 */
      /* interrupt controller */

      sim_hw_parse (sd, "/mn103int@@0x34000100/reg 0x34000100 0x7C 0x34000200 0x8 0x34000280 0x8");

      /* DEBUG: NMI input's */
      sim_hw_parse (sd, "/glue@@0x30000000/reg 0x30000000 12");
      sim_hw_parse (sd, "/glue@@0x30000000 > int0 nmirq /mn103int");
      sim_hw_parse (sd, "/glue@@0x30000000 > int1 watchdog /mn103int");
      sim_hw_parse (sd, "/glue@@0x30000000 > int2 syserr /mn103int");
      
      /* DEBUG: ACK input */
      sim_hw_parse (sd, "/glue@@0x30002000/reg 0x30002000 4");
      sim_hw_parse (sd, "/glue@@0x30002000 > int ack /mn103int");
      
      /* DEBUG: LEVEL output */
      sim_hw_parse (sd, "/glue@@0x30004000/reg 0x30004000 8");
      sim_hw_parse (sd, "/mn103int > nmi int0 /glue@@0x30004000");
      sim_hw_parse (sd, "/mn103int > level int1 /glue@@0x30004000");
      
      /* DEBUG: A bunch of interrupt inputs */
      sim_hw_parse (sd, "/glue@@0x30006000/reg 0x30006000 32");
      sim_hw_parse (sd, "/glue@@0x30006000 > int0 irq-0 /mn103int");
      sim_hw_parse (sd, "/glue@@0x30006000 > int1 irq-1 /mn103int");
      sim_hw_parse (sd, "/glue@@0x30006000 > int2 irq-2 /mn103int");
      sim_hw_parse (sd, "/glue@@0x30006000 > int3 irq-3 /mn103int");
      sim_hw_parse (sd, "/glue@@0x30006000 > int4 irq-4 /mn103int");
      sim_hw_parse (sd, "/glue@@0x30006000 > int5 irq-5 /mn103int");
      sim_hw_parse (sd, "/glue@@0x30006000 > int6 irq-6 /mn103int");
      sim_hw_parse (sd, "/glue@@0x30006000 > int7 irq-7 /mn103int");
      
      /* processor interrupt device */
      
      /* the device */
      sim_hw_parse (sd, "/mn103cpu@@0x20000000");
      sim_hw_parse (sd, "/mn103cpu@@0x20000000/reg 0x20000000 0x42");
      
      /* DEBUG: ACK output wired upto a glue device */
      sim_hw_parse (sd, "/glue@@0x20002000");
      sim_hw_parse (sd, "/glue@@0x20002000/reg 0x20002000 4");
      sim_hw_parse (sd, "/mn103cpu > ack int0 /glue@@0x20002000");
      
      /* DEBUG: RESET/NMI/LEVEL wired up to a glue device */
      sim_hw_parse (sd, "/glue@@0x20004000");
      sim_hw_parse (sd, "/glue@@0x20004000/reg 0x20004000 12");
      sim_hw_parse (sd, "/glue@@0x20004000 > int0 reset /mn103cpu");
      sim_hw_parse (sd, "/glue@@0x20004000 > int1 nmi /mn103cpu");
      sim_hw_parse (sd, "/glue@@0x20004000 > int2 level /mn103cpu");
      
      /* REAL: The processor wired up to the real interrupt controller */
      sim_hw_parse (sd, "/mn103cpu > ack ack /mn103int");
      sim_hw_parse (sd, "/mn103int > level level /mn103cpu");
      sim_hw_parse (sd, "/mn103int > nmi nmi /mn103cpu");
      
      
      /* PAL */
      
      /* the device */
      sim_hw_parse (sd, "/pal@@0x31000000");
      sim_hw_parse (sd, "/pal@@0x31000000/reg 0x31000000 64");
      sim_hw_parse (sd, "/pal@@0x31000000/poll? true");
      
      /* DEBUG: PAL wired up to a glue device */
      sim_hw_parse (sd, "/glue@@0x31002000");
      sim_hw_parse (sd, "/glue@@0x31002000/reg 0x31002000 16");
      sim_hw_parse (sd, "/pal@@0x31000000 > countdown int0 /glue@@0x31002000");
      sim_hw_parse (sd, "/pal@@0x31000000 > timer int1 /glue@@0x31002000");
      sim_hw_parse (sd, "/pal@@0x31000000 > int int2 /glue@@0x31002000");
      sim_hw_parse (sd, "/glue@@0x31002000 > int0 int3 /glue@@0x31002000");
      sim_hw_parse (sd, "/glue@@0x31002000 > int1 int3 /glue@@0x31002000");
      sim_hw_parse (sd, "/glue@@0x31002000 > int2 int3 /glue@@0x31002000");
      
      /* REAL: The PAL wired up to the real interrupt controller */
      sim_hw_parse (sd, "/pal@@0x31000000 > countdown irq-0 /mn103int");
      sim_hw_parse (sd, "/pal@@0x31000000 > timer irq-1 /mn103int");
      sim_hw_parse (sd, "/pal@@0x31000000 > int irq-2 /mn103int");
      
      /* 8 and 16 bit timers */
      sim_hw_parse (sd, "/mn103tim@@0x34001000/reg 0x34001000 36 0x34001080 100 0x34004000 16");

      /* Hook timer interrupts up to interrupt controller */
      sim_hw_parse (sd, "/mn103tim > timer-0-underflow timer-0-underflow /mn103int");
      sim_hw_parse (sd, "/mn103tim > timer-1-underflow timer-1-underflow /mn103int");
      sim_hw_parse (sd, "/mn103tim > timer-2-underflow timer-2-underflow /mn103int");
      sim_hw_parse (sd, "/mn103tim > timer-3-underflow timer-3-underflow /mn103int");
      sim_hw_parse (sd, "/mn103tim > timer-4-underflow timer-4-underflow /mn103int");
      sim_hw_parse (sd, "/mn103tim > timer-5-underflow timer-5-underflow /mn103int");
      sim_hw_parse (sd, "/mn103tim > timer-6-underflow timer-6-underflow /mn103int");
      sim_hw_parse (sd, "/mn103tim > timer-6-compare-a timer-6-compare-a /mn103int");
      sim_hw_parse (sd, "/mn103tim > timer-6-compare-b timer-6-compare-b /mn103int");
      
      
      /* Serial devices 0,1,2 */
      sim_hw_parse (sd, "/mn103ser@@0x34000800/reg 0x34000800 48");
      sim_hw_parse (sd, "/mn103ser@@0x34000800/poll? true");
      
      /* Hook serial interrupts up to interrupt controller */
      sim_hw_parse (sd, "/mn103ser > serial-0-receive serial-0-receive /mn103int");
      sim_hw_parse (sd, "/mn103ser > serial-0-transmit serial-0-transmit /mn103int");
      sim_hw_parse (sd, "/mn103ser > serial-1-receive serial-1-receive /mn103int");
      sim_hw_parse (sd, "/mn103ser > serial-1-transmit serial-1-transmit /mn103int");
      sim_hw_parse (sd, "/mn103ser > serial-2-receive serial-2-receive /mn103int");
      sim_hw_parse (sd, "/mn103ser > serial-2-transmit serial-2-transmit /mn103int");
      
      sim_hw_parse (sd, "/mn103iop@@0x36008000/reg 0x36008000 8 0x36008020 8 0x36008040 0xc 0x36008060 8 0x36008080 8");

      /* Memory control registers */
      sim_do_command (sd, "memory region 0x32000020,0x30");
      /* Cache control register */
      sim_do_command (sd, "memory region 0x20000070,0x4");
      /* Cache purge regions */
      sim_do_command (sd, "memory region 0x28400000,0x800");
      sim_do_command (sd, "memory region 0x28401000,0x800");
      /* DMA registers */
      sim_do_command (sd, "memory region 0x32000100,0xF");
      sim_do_command (sd, "memory region 0x32000200,0xF");
      sim_do_command (sd, "memory region 0x32000400,0xF");
      sim_do_command (sd, "memory region 0x32000800,0xF");
    }
  else
    {
      if (board != NULL)
        {
	  sim_io_eprintf (sd, "Error: Board `%s' unknown.\n", board);
          return 0;
	}
    }
  
  

  /* check for/establish the a reference program image */
  if (sim_analyze_program (sd,
			   (STATE_PROG_ARGV (sd) != NULL
			    ? *STATE_PROG_ARGV (sd)
			    : NULL),
			   abfd) != SIM_RC_OK)
    {
      sim_module_uninstall (sd);
      return 0;
    }

  /* establish any remaining configuration options */
  if (sim_config (sd) != SIM_RC_OK)
    {
      sim_module_uninstall (sd);
      return 0;
    }

  if (sim_post_argv_init (sd) != SIM_RC_OK)
    {
      /* Uninstall the modules to avoid memory leaks,
	 file descriptor leaks, etc.  */
      sim_module_uninstall (sd);
      return 0;
    }


  /* set machine specific configuration */
/*   STATE_CPU (sd, 0)->psw_mask = (PSW_NP | PSW_EP | PSW_ID | PSW_SAT */
/* 			     | PSW_CY | PSW_OV | PSW_S | PSW_Z); */

  return sd;
}


void
sim_close (SIM_DESC sd, int quitting)
{
  sim_module_uninstall (sd);
}


SIM_RC
sim_create_inferior (SIM_DESC sd,
		     struct bfd *prog_bfd,
		     char **argv,
		     char **env)
{
  memset (&State, 0, sizeof (State));
  if (prog_bfd != NULL) {
    PC = bfd_get_start_address (prog_bfd);
  } else {
    PC = 0;
  }
  CIA_SET (STATE_CPU (sd, 0), (unsigned64) PC);

  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2)
    PSW |= PSW_FE;

  return SIM_RC_OK;
}

/* FIXME These would more efficient to use than load_mem/store_mem,
   but need to be changed to use the memory map.  */

uint8
get_byte (uint8 *x)
{
  return *x;
}

uint16
get_half (uint8 *x)
{
  uint8 *a = x;
  return (a[1] << 8) + (a[0]);
}

uint32
get_word (uint8 *x)
{
  uint8 *a = x;
  return (a[3]<<24) + (a[2]<<16) + (a[1]<<8) + (a[0]);
}

void
put_byte (uint8 *addr, uint8 data)
{
  uint8 *a = addr;
  a[0] = data;
}

void
put_half (uint8 *addr, uint16 data)
{
  uint8 *a = addr;
  a[0] = data & 0xff;
  a[1] = (data >> 8) & 0xff;
}

void
put_word (uint8 *addr, uint32 data)
{
  uint8 *a = addr;
  a[0] = data & 0xff;
  a[1] = (data >> 8) & 0xff;
  a[2] = (data >> 16) & 0xff;
  a[3] = (data >> 24) & 0xff;
}

int
sim_fetch_register (SIM_DESC sd,
		    int rn,
		    unsigned char *memory,
		    int length)
{
  put_word (memory, State.regs[rn]);
  return length;
}
 
int
sim_store_register (SIM_DESC sd,
		    int rn,
		    unsigned char *memory,
		    int length)
{
  State.regs[rn] = get_word (memory);
  return length;
}


void
mn10300_core_signal (SIM_DESC sd,
		     sim_cpu *cpu,
		     sim_cia cia,
		     unsigned map,
		     int nr_bytes,
		     address_word addr,
		     transfer_type transfer,
		     sim_core_signals sig)
{
  const char *copy = (transfer == read_transfer ? "read" : "write");
  address_word ip = CIA_ADDR (cia);

  switch (sig)
    {
    case sim_core_unmapped_signal:
      sim_io_eprintf (sd, "mn10300-core: %d byte %s to unmapped address 0x%lx at 0x%lx\n",
                      nr_bytes, copy, 
                      (unsigned long) addr, (unsigned long) ip);
      program_interrupt(sd, cpu, cia, SIM_SIGSEGV);
      break;

    case sim_core_unaligned_signal:
      sim_io_eprintf (sd, "mn10300-core: %d byte %s to unaligned address 0x%lx at 0x%lx\n",
                      nr_bytes, copy, 
                      (unsigned long) addr, (unsigned long) ip);
      program_interrupt(sd, cpu, cia, SIM_SIGBUS);
      break;

    default:
      sim_engine_abort (sd, cpu, cia,
                        "mn10300_core_signal - internal error - bad switch");
    }
}


void
program_interrupt (SIM_DESC sd,
		   sim_cpu *cpu,
		   sim_cia cia,
		   SIM_SIGNAL sig)
{
  int status;
  struct hw *device;
  static int in_interrupt = 0;

#ifdef SIM_CPU_EXCEPTION_TRIGGER
  SIM_CPU_EXCEPTION_TRIGGER(sd,cpu,cia);
#endif

  /* avoid infinite recursion */
  if (in_interrupt)
    {
      (*mn10300_callback->printf_filtered) (mn10300_callback, 
					    "ERROR: recursion in program_interrupt during software exception dispatch.");
    }
  else
    {
      in_interrupt = 1;
      /* copy NMI handler code from dv-mn103cpu.c */
      store_word (SP - 4, CIA_GET (cpu));
      store_half (SP - 8, PSW);

      /* Set the SYSEF flag in NMICR by backdoor method.  See
	 dv-mn103int.c:write_icr().  This is necessary because
         software exceptions are not modelled by actually talking to
         the interrupt controller, so it cannot set its own SYSEF
         flag. */
     if ((NULL != board) && (strcmp(board, BOARD_AM32) == 0))
       store_byte (0x34000103, 0x04);
    }

  PSW &= ~PSW_IE;
  SP = SP - 8;
  CIA_SET (cpu, 0x40000008);

  in_interrupt = 0;
  sim_engine_halt(sd, cpu, NULL, cia, sim_stopped, sig);
}


void
mn10300_cpu_exception_trigger(SIM_DESC sd, sim_cpu* cpu, address_word cia)
{
  ASSERT(cpu != NULL);

  if(State.exc_suspended > 0)
    sim_io_eprintf(sd, "Warning, nested exception triggered (%d)\n", State.exc_suspended); 

  CIA_SET (cpu, cia);
  memcpy(State.exc_trigger_regs, State.regs, sizeof(State.exc_trigger_regs));
  State.exc_suspended = 0;
}

void
mn10300_cpu_exception_suspend(SIM_DESC sd, sim_cpu* cpu, int exception)
{
  ASSERT(cpu != NULL);

  if(State.exc_suspended > 0)
    sim_io_eprintf(sd, "Warning, nested exception signal (%d then %d)\n", 
		   State.exc_suspended, exception); 

  memcpy(State.exc_suspend_regs, State.regs, sizeof(State.exc_suspend_regs));
  memcpy(State.regs, State.exc_trigger_regs, sizeof(State.regs));
  CIA_SET (cpu, PC); /* copy PC back from new State.regs */
  State.exc_suspended = exception;
}

void
mn10300_cpu_exception_resume(SIM_DESC sd, sim_cpu* cpu, int exception)
{
  ASSERT(cpu != NULL);

  if(exception == 0 && State.exc_suspended > 0)
    {
      if(State.exc_suspended != SIGTRAP) /* warn not for breakpoints */
         sim_io_eprintf(sd, "Warning, resuming but ignoring pending exception signal (%d)\n",
  		       State.exc_suspended); 
    }
  else if(exception != 0 && State.exc_suspended > 0)
    {
      if(exception != State.exc_suspended) 
	sim_io_eprintf(sd, "Warning, resuming with mismatched exception signal (%d vs %d)\n",
		       State.exc_suspended, exception); 
      
      memcpy(State.regs, State.exc_suspend_regs, sizeof(State.regs)); 
      CIA_SET (cpu, PC); /* copy PC back from new State.regs */
    }
  else if(exception != 0 && State.exc_suspended == 0)
    {
      sim_io_eprintf(sd, "Warning, ignoring spontanous exception signal (%d)\n", exception); 
    }
  State.exc_suspended = 0; 
}

/* This is called when an FP instruction is issued when the FP unit is
   disabled, i.e., the FE bit of PSW is zero.  It raises interrupt
   code 0x1c0.  */
void
fpu_disabled_exception (SIM_DESC sd, sim_cpu *cpu, sim_cia cia)
{
  sim_io_eprintf(sd, "FPU disabled exception\n");
  program_interrupt (sd, cpu, cia, SIM_SIGFPE);
}

/* This is called when the FP unit is enabled but one of the
   unimplemented insns is issued.  It raises interrupt code 0x1c8.  */
void
fpu_unimp_exception (SIM_DESC sd, sim_cpu *cpu, sim_cia cia)
{
  sim_io_eprintf(sd, "Unimplemented FPU instruction exception\n");
  program_interrupt (sd, cpu, cia, SIM_SIGFPE);
}

/* This is called at the end of any FP insns that may have triggered
   FP exceptions.  If no exception is enabled, it returns immediately.
   Otherwise, it raises an exception code 0x1d0.  */
void
fpu_check_signal_exception (SIM_DESC sd, sim_cpu *cpu, sim_cia cia)
{
  if ((FPCR & EC_MASK) == 0)
    return;

  sim_io_eprintf(sd, "FPU %s%s%s%s%s exception\n",
		 (FPCR & EC_V) ? "V" : "",
		 (FPCR & EC_Z) ? "Z" : "",
		 (FPCR & EC_O) ? "O" : "",
		 (FPCR & EC_U) ? "U" : "",
		 (FPCR & EC_I) ? "I" : "");
  program_interrupt (sd, cpu, cia, SIM_SIGFPE);
}

/* Convert a 32-bit single-precision FP value in the target platform
   format to a sim_fpu value.  */
static void
reg2val_32 (const void *reg, sim_fpu *val)
{
  FS2FPU (*(reg_t *)reg, *val);
}

/* Round the given sim_fpu value to single precision, following the
   target platform rounding and denormalization conventions.  On
   AM33/2.0, round_near is the only rounding mode.  */
static int
round_32 (sim_fpu *val)
{
  return sim_fpu_round_32 (val, sim_fpu_round_near, sim_fpu_denorm_zero);
}

/* Convert a sim_fpu value to the 32-bit single-precision target
   representation.  */
static void
val2reg_32 (const sim_fpu *val, void *reg)
{
  FPU2FS (*val, *(reg_t *)reg);
}

/* Define the 32-bit single-precision conversion and rounding uniform
   interface.  */
const struct fp_prec_t
fp_single_prec = {
  reg2val_32, round_32, val2reg_32
};

/* Convert a 64-bit double-precision FP value in the target platform
   format to a sim_fpu value.  */
static void
reg2val_64 (const void *reg, sim_fpu *val)
{
  FD2FPU (*(dword *)reg, *val);
}

/* Round the given sim_fpu value to double precision, following the
   target platform rounding and denormalization conventions.  On
   AM33/2.0, round_near is the only rounding mode.  */
int
round_64 (sim_fpu *val)
{
  return sim_fpu_round_64 (val, sim_fpu_round_near, sim_fpu_denorm_zero);
}

/* Convert a sim_fpu value to the 64-bit double-precision target
   representation.  */
static void
val2reg_64 (const sim_fpu *val, void *reg)
{
  FPU2FD (*val, *(dword *)reg);
}

/* Define the 64-bit single-precision conversion and rounding uniform
   interface.  */
const struct fp_prec_t
fp_double_prec = {
  reg2val_64, round_64, val2reg_64
};

/* Define shortcuts to the uniform interface operations.  */
#define REG2VAL(reg,val) (*ops->reg2val) (reg,val)
#define ROUND(val) (*ops->round) (val)
#define VAL2REG(val,reg) (*ops->val2reg) (val,reg)

/* Check whether overflow, underflow or inexact exceptions should be
   raised.  */
int
fpu_status_ok (sim_fpu_status stat)
{
  if ((stat & sim_fpu_status_overflow)
      && (FPCR & EE_O))
    FPCR |= EC_O;
  else if ((stat & (sim_fpu_status_underflow | sim_fpu_status_denorm))
	   && (FPCR & EE_U))
    FPCR |= EC_U;
  else if ((stat & (sim_fpu_status_inexact | sim_fpu_status_rounded))
	   && (FPCR & EE_I))
    FPCR |= EC_I;
  else if (stat & ~ (sim_fpu_status_overflow
		     | sim_fpu_status_underflow
		     | sim_fpu_status_denorm
		     | sim_fpu_status_inexact
		     | sim_fpu_status_rounded))
    abort ();
  else
    return 1;
  return 0;
}

/* Implement a 32/64 bit reciprocal square root, signaling FP
   exceptions when appropriate.  */
void
fpu_rsqrt (SIM_DESC sd, sim_cpu *cpu, sim_cia cia,
	   const void *reg_in, void *reg_out, const struct fp_prec_t *ops)
{
  sim_fpu in, med, out;

  REG2VAL (reg_in, &in);
  ROUND (&in);
  FPCR &= ~ EC_MASK;
  switch (sim_fpu_is (&in))
    {
    case SIM_FPU_IS_SNAN:
    case SIM_FPU_IS_NNUMBER:
    case SIM_FPU_IS_NINF:
      if (FPCR & EE_V)
	FPCR |= EC_V;
      else
	VAL2REG (&sim_fpu_qnan, reg_out);
      break;
	    
    case SIM_FPU_IS_QNAN:
      VAL2REG (&sim_fpu_qnan, reg_out);
      break;

    case SIM_FPU_IS_PINF:
      VAL2REG (&sim_fpu_zero, reg_out);
      break;

    case SIM_FPU_IS_PNUMBER:
      {
	/* Since we don't have a function to compute rsqrt directly,
	   use sqrt and inv.  */
	sim_fpu_status stat = 0;
	stat |= sim_fpu_sqrt (&med, &in);
	stat |= sim_fpu_inv (&out, &med);
	stat |= ROUND (&out);
	if (fpu_status_ok (stat))
	  VAL2REG (&out, reg_out);
      }
      break;

    case SIM_FPU_IS_NZERO:
    case SIM_FPU_IS_PZERO:
      if (FPCR & EE_Z)
	FPCR |= EC_Z;
      else
	{
	  /* Generate an INF with the same sign.  */
	  sim_fpu_inv (&out, &in);
	  VAL2REG (&out, reg_out);
	}
      break;

    default:
      abort ();
    }

  fpu_check_signal_exception (sd, cpu, cia);
}

static inline reg_t
cmp2fcc (int res)
{
  switch (res)
    {
    case SIM_FPU_IS_SNAN:
    case SIM_FPU_IS_QNAN:
      return FCC_U;
      
    case SIM_FPU_IS_NINF:
    case SIM_FPU_IS_NNUMBER:
    case SIM_FPU_IS_NDENORM:
      return FCC_L;
      
    case SIM_FPU_IS_PINF:
    case SIM_FPU_IS_PNUMBER:
    case SIM_FPU_IS_PDENORM:
      return FCC_G;
      
    case SIM_FPU_IS_NZERO:
    case SIM_FPU_IS_PZERO:
      return FCC_E;
      
    default:
      abort ();
    }
}

/* Implement a 32/64 bit FP compare, setting the FPCR status and/or
   exception bits as specified.  */
void
fpu_cmp (SIM_DESC sd, sim_cpu *cpu, sim_cia cia,
	 const void *reg_in1, const void *reg_in2,
	 const struct fp_prec_t *ops)
{
  sim_fpu m, n;

  REG2VAL (reg_in1, &m);
  REG2VAL (reg_in2, &n);
  FPCR &= ~ EC_MASK;
  FPCR &= ~ FCC_MASK;
  ROUND (&m);
  ROUND (&n);
  if (sim_fpu_is_snan (&m) || sim_fpu_is_snan (&n))
    {
      if (FPCR & EE_V)
	FPCR |= EC_V;
      else
	FPCR |= FCC_U;
    }
  else
    FPCR |= cmp2fcc (sim_fpu_cmp (&m, &n));

  fpu_check_signal_exception (sd, cpu, cia);
}

/* Implement a 32/64 bit FP add, setting FP exception bits when
   appropriate.  */
void
fpu_add (SIM_DESC sd, sim_cpu *cpu, sim_cia cia,
	 const void *reg_in1, const void *reg_in2,
	 void *reg_out, const struct fp_prec_t *ops)
{
  sim_fpu m, n, r;

  REG2VAL (reg_in1, &m);
  REG2VAL (reg_in2, &n);
  ROUND (&m);
  ROUND (&n);
  FPCR &= ~ EC_MASK;
  if (sim_fpu_is_snan (&m) || sim_fpu_is_snan (&n)
      || (sim_fpu_is (&m) == SIM_FPU_IS_PINF
	  && sim_fpu_is (&n) == SIM_FPU_IS_NINF)
      || (sim_fpu_is (&m) == SIM_FPU_IS_NINF
	  && sim_fpu_is (&n) == SIM_FPU_IS_PINF))
    {
      if (FPCR & EE_V)
	FPCR |= EC_V;
      else
	VAL2REG (&sim_fpu_qnan, reg_out);
    }
  else
    {
      sim_fpu_status stat = sim_fpu_add (&r, &m, &n);
      stat |= ROUND (&r);
      if (fpu_status_ok (stat))
	VAL2REG (&r, reg_out);
    }
  
  fpu_check_signal_exception (sd, cpu, cia);
}

/* Implement a 32/64 bit FP sub, setting FP exception bits when
   appropriate.  */
void
fpu_sub (SIM_DESC sd, sim_cpu *cpu, sim_cia cia,
	 const void *reg_in1, const void *reg_in2,
	 void *reg_out, const struct fp_prec_t *ops)
{
  sim_fpu m, n, r;

  REG2VAL (reg_in1, &m);
  REG2VAL (reg_in2, &n);
  ROUND (&m);
  ROUND (&n);
  FPCR &= ~ EC_MASK;
  if (sim_fpu_is_snan (&m) || sim_fpu_is_snan (&n)
      || (sim_fpu_is (&m) == SIM_FPU_IS_PINF
	  && sim_fpu_is (&n) == SIM_FPU_IS_PINF)
      || (sim_fpu_is (&m) == SIM_FPU_IS_NINF
	  && sim_fpu_is (&n) == SIM_FPU_IS_NINF))
    {
      if (FPCR & EE_V)
	FPCR |= EC_V;
      else
	VAL2REG (&sim_fpu_qnan, reg_out);
    }
  else
    {
      sim_fpu_status stat = sim_fpu_sub (&r, &m, &n);
      stat |= ROUND (&r);
      if (fpu_status_ok (stat))
	VAL2REG (&r, reg_out);
    }
  
  fpu_check_signal_exception (sd, cpu, cia);
}

/* Implement a 32/64 bit FP mul, setting FP exception bits when
   appropriate.  */
void
fpu_mul (SIM_DESC sd, sim_cpu *cpu, sim_cia cia,
	 const void *reg_in1, const void *reg_in2,
	 void *reg_out, const struct fp_prec_t *ops)
{
  sim_fpu m, n, r;

  REG2VAL (reg_in1, &m);
  REG2VAL (reg_in2, &n);
  ROUND (&m);
  ROUND (&n);
  FPCR &= ~ EC_MASK;
  if (sim_fpu_is_snan (&m) || sim_fpu_is_snan (&n)
      || (sim_fpu_is_infinity (&m) && sim_fpu_is_zero (&n))
      || (sim_fpu_is_zero (&m) && sim_fpu_is_infinity (&n)))
    {
      if (FPCR & EE_V)
	FPCR |= EC_V;
      else
	VAL2REG (&sim_fpu_qnan, reg_out);
    }
  else
    {
      sim_fpu_status stat = sim_fpu_mul (&r, &m, &n);
      stat |= ROUND (&r);
      if (fpu_status_ok (stat))
	VAL2REG (&r, reg_out);
    }
  
  fpu_check_signal_exception (sd, cpu, cia);
}

/* Implement a 32/64 bit FP div, setting FP exception bits when
   appropriate.  */
void
fpu_div (SIM_DESC sd, sim_cpu *cpu, sim_cia cia,
	 const void *reg_in1, const void *reg_in2,
	 void *reg_out, const struct fp_prec_t *ops)
{
  sim_fpu m, n, r;

  REG2VAL (reg_in1, &m);
  REG2VAL (reg_in2, &n);
  ROUND (&m);
  ROUND (&n);
  FPCR &= ~ EC_MASK;
  if (sim_fpu_is_snan (&m) || sim_fpu_is_snan (&n)
      || (sim_fpu_is_infinity (&m) && sim_fpu_is_infinity (&n))
      || (sim_fpu_is_zero (&m) && sim_fpu_is_zero (&n)))
    {
      if (FPCR & EE_V)
	FPCR |= EC_V;
      else
	VAL2REG (&sim_fpu_qnan, reg_out);
    }
  else if (sim_fpu_is_number (&m) && sim_fpu_is_zero (&n)
	   && (FPCR & EE_Z))
    FPCR |= EC_Z;
  else
    {
      sim_fpu_status stat = sim_fpu_div (&r, &m, &n);
      stat |= ROUND (&r);
      if (fpu_status_ok (stat))
	VAL2REG (&r, reg_out);
    }
  
  fpu_check_signal_exception (sd, cpu, cia);
}

/* Implement a 32/64 bit FP madd, setting FP exception bits when
   appropriate.  */
void
fpu_fmadd (SIM_DESC sd, sim_cpu *cpu, sim_cia cia,
	   const void *reg_in1, const void *reg_in2, const void *reg_in3,
	   void *reg_out, const struct fp_prec_t *ops)
{
  sim_fpu m1, m2, m, n, r;

  REG2VAL (reg_in1, &m1);
  REG2VAL (reg_in2, &m2);
  REG2VAL (reg_in3, &n);
  ROUND (&m1);
  ROUND (&m2);
  ROUND (&n);
  FPCR &= ~ EC_MASK;
  if (sim_fpu_is_snan (&m1) || sim_fpu_is_snan (&m2) || sim_fpu_is_snan (&n)
      || (sim_fpu_is_infinity (&m1) && sim_fpu_is_zero (&m2))
      || (sim_fpu_is_zero (&m1) && sim_fpu_is_infinity (&m2)))
    {
    invalid_operands:
      if (FPCR & EE_V)
	FPCR |= EC_V;
      else
	VAL2REG (&sim_fpu_qnan, reg_out);
    }
  else
    {
      sim_fpu_status stat = sim_fpu_mul (&m, &m1, &m2);

      if (sim_fpu_is_infinity (&m) && sim_fpu_is_infinity (&n)
	  && sim_fpu_sign (&m) != sim_fpu_sign (&n))
	goto invalid_operands;

      stat |= sim_fpu_add (&r, &m, &n);
      stat |= ROUND (&r);
      if (fpu_status_ok (stat))
	VAL2REG (&r, reg_out);
    }
  
  fpu_check_signal_exception (sd, cpu, cia);
}

/* Implement a 32/64 bit FP msub, setting FP exception bits when
   appropriate.  */
void
fpu_fmsub (SIM_DESC sd, sim_cpu *cpu, sim_cia cia,
	   const void *reg_in1, const void *reg_in2, const void *reg_in3,
	   void *reg_out, const struct fp_prec_t *ops)
{
  sim_fpu m1, m2, m, n, r;

  REG2VAL (reg_in1, &m1);
  REG2VAL (reg_in2, &m2);
  REG2VAL (reg_in3, &n);
  ROUND (&m1);
  ROUND (&m2);
  ROUND (&n);
  FPCR &= ~ EC_MASK;
  if (sim_fpu_is_snan (&m1) || sim_fpu_is_snan (&m2) || sim_fpu_is_snan (&n)
      || (sim_fpu_is_infinity (&m1) && sim_fpu_is_zero (&m2))
      || (sim_fpu_is_zero (&m1) && sim_fpu_is_infinity (&m2)))
    {
    invalid_operands:
      if (FPCR & EE_V)
	FPCR |= EC_V;
      else
	VAL2REG (&sim_fpu_qnan, reg_out);
    }
  else
    {
      sim_fpu_status stat = sim_fpu_mul (&m, &m1, &m2);

      if (sim_fpu_is_infinity (&m) && sim_fpu_is_infinity (&n)
	  && sim_fpu_sign (&m) == sim_fpu_sign (&n))
	goto invalid_operands;

      stat |= sim_fpu_sub (&r, &m, &n);
      stat |= ROUND (&r);
      if (fpu_status_ok (stat))
	VAL2REG (&r, reg_out);
    }
  
  fpu_check_signal_exception (sd, cpu, cia);
}

/* Implement a 32/64 bit FP nmadd, setting FP exception bits when
   appropriate.  */
void
fpu_fnmadd (SIM_DESC sd, sim_cpu *cpu, sim_cia cia,
	    const void *reg_in1, const void *reg_in2, const void *reg_in3,
	    void *reg_out, const struct fp_prec_t *ops)
{
  sim_fpu m1, m2, m, mm, n, r;

  REG2VAL (reg_in1, &m1);
  REG2VAL (reg_in2, &m2);
  REG2VAL (reg_in3, &n);
  ROUND (&m1);
  ROUND (&m2);
  ROUND (&n);
  FPCR &= ~ EC_MASK;
  if (sim_fpu_is_snan (&m1) || sim_fpu_is_snan (&m2) || sim_fpu_is_snan (&n)
      || (sim_fpu_is_infinity (&m1) && sim_fpu_is_zero (&m2))
      || (sim_fpu_is_zero (&m1) && sim_fpu_is_infinity (&m2)))
    {
    invalid_operands:
      if (FPCR & EE_V)
	FPCR |= EC_V;
      else
	VAL2REG (&sim_fpu_qnan, reg_out);
    }
  else
    {
      sim_fpu_status stat = sim_fpu_mul (&m, &m1, &m2);

      if (sim_fpu_is_infinity (&m) && sim_fpu_is_infinity (&n)
	  && sim_fpu_sign (&m) == sim_fpu_sign (&n))
	goto invalid_operands;

      stat |= sim_fpu_neg (&mm, &m);
      stat |= sim_fpu_add (&r, &mm, &n);
      stat |= ROUND (&r);
      if (fpu_status_ok (stat))
	VAL2REG (&r, reg_out);
    }
  
  fpu_check_signal_exception (sd, cpu, cia);
}

/* Implement a 32/64 bit FP nmsub, setting FP exception bits when
   appropriate.  */
void
fpu_fnmsub (SIM_DESC sd, sim_cpu *cpu, sim_cia cia,
	    const void *reg_in1, const void *reg_in2, const void *reg_in3,
	    void *reg_out, const struct fp_prec_t *ops)
{
  sim_fpu m1, m2, m, mm, n, r;

  REG2VAL (reg_in1, &m1);
  REG2VAL (reg_in2, &m2);
  REG2VAL (reg_in3, &n);
  ROUND (&m1);
  ROUND (&m2);
  ROUND (&n);
  FPCR &= ~ EC_MASK;
  if (sim_fpu_is_snan (&m1) || sim_fpu_is_snan (&m2) || sim_fpu_is_snan (&n)
      || (sim_fpu_is_infinity (&m1) && sim_fpu_is_zero (&m2))
      || (sim_fpu_is_zero (&m1) && sim_fpu_is_infinity (&m2)))
    {
    invalid_operands:
      if (FPCR & EE_V)
	FPCR |= EC_V;
      else
	VAL2REG (&sim_fpu_qnan, reg_out);
    }
  else
    {
      sim_fpu_status stat = sim_fpu_mul (&m, &m1, &m2);

      if (sim_fpu_is_infinity (&m) && sim_fpu_is_infinity (&n)
	  && sim_fpu_sign (&m) != sim_fpu_sign (&n))
	goto invalid_operands;

      stat |= sim_fpu_neg (&mm, &m);
      stat |= sim_fpu_sub (&r, &mm, &n);
      stat |= ROUND (&r);
      if (fpu_status_ok (stat))
	VAL2REG (&r, reg_out);
    }
  
  fpu_check_signal_exception (sd, cpu, cia);
}
@


1.8
log
@Update sim_fetch_register, sim_store_register for sh and mn10300.
Fix compile warnings for sh built on 64-bit hosts.
@
text
@d1 1
a7 1
#include "sysdep.h"
@


1.7
log
@sim: start a unified sim_do_command

Since sim_do_command for many people simply calls sim_args_command, start
a unified version of it.  For people who handle their own options, they
could switch to this by using sim_add_option_table instead.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d386 1
a386 1
  return -1;
@


1.6
log
@http://sourceware.org/ml/gdb-patches/2010-11/msg00112.html
gdb/ChangeLog
	* remote-sim.c (gdbsim_store_register): Update API to
	sim_store_register to check more error conditions.
include/gdb/ChangeLog
	* remote-sim.h (sim_store_register): Update the API
	documentation for this function.
sim/erc32/ChangeLog
sim/h8300/ChangeLog
sim/m32c/ChangeLog
sim/mn10300/ChangeLog
sim/ppc/ChangeLog
sim/rx/ChangeLog
sim/v850/ChangeLog
	* ???.c (sim_store_register): Update return value to
	match new API.
@
text
@a330 17
void
sim_do_command (SIM_DESC sd, char *cmd)
{
  char *mm_cmd = "memory-map";
  char *int_cmd = "interrupt";

  if (sim_args_command (sd, cmd) != SIM_RC_OK)
    {
      if (strncmp (cmd, mm_cmd, strlen (mm_cmd) == 0))
	sim_io_eprintf (sd, "`memory-map' command replaced by `sim memory'\n");
      else if (strncmp (cmd, int_cmd, strlen (int_cmd)) == 0)
	sim_io_eprintf (sd, "`interrupt' command replaced by `sim watch'\n");
      else
	sim_io_eprintf (sd, "Unknown command `%s'\n", cmd);
    }
}

@


1.5
log
@2000-08-07  Graham Stott  <grahams@@cygnus.co.uk>
* am33-2.igen (fmadd, fmsub, fmnadd, fmnsub): Correct typo.
2000-05-29  Alexandre Oliva  <aoliva@@cygnus.com>
* interp.c (fpu_disabled_exception, fpu_unimp_exception,
fpu_check_signal_exception): Take additional state arguments.
Print exception type and call program_interrupt.  Adjust callers.
(fpu_rsqrt, fpu_cmp, fpu_add, fpu_sub, fpu_mul, fpu_div,
fpu_fmadd, fpu_fmsub, fpu_fnmadd, fpu_fnmsub): Take additional
arguments.
* mn10300_sim.h (fpu_disabled_exception, fpu_unimp_exception,
fpu_check_signal_exception): Adjust prototypes.
(fpu_rsqrt, fpu_cmp, fpu_add, fpu_sub, fpu_mul, fpu_div,
fpu_fmadd, fpu_fmsub, fpu_fnmadd, fpu_fnmsub): Likewise.
* am33-2.igen: Adjust calls.
2000-05-19  Alexandre Oliva  <aoliva@@cygnus.com>
* op_utils.c (cmp2fcc): Moved...
* interp.c: ... here.
2000-05-18  Alexandre Oliva  <aoliva@@cygnus.com>
* am33-2.igen: Use `unsigned32', `signed32', `unsigned64' or
`signed64' where type width is relevant.
2000-05-15  Alexandre Oliva  <aoliva@@cygnus.com>
* mn10300_sim.h: Include sim-fpu.h.
(FD2FPU, FPU2FD): Enclose the FD argument in parentheses.
(fpu_check_signal_exception): Declare.
(struct fp_prec_t, fp_single_prec, fp_double_prec): Likewise.
(FP_SINGLE, FP_DOUBLE): Shorthands for fp_*_prec.
(fpu_rsqrt, fpu_cmp, fpu_add, fpu_sub, fpu_mul, fpu_div,
fpu_fmadd, fpu_fmsub, fpu_fnmadd, fpu_fnmsub): Declare.
* interp.c (fpu_disabled_exception): Document.
(fpu_unimp_exception): Likewise.
(fpu_check_signal_exception): Define.
(reg2val_32, round_32, val2reg_32, fp_single_prec): Likewise.
(reg2val_64, round_64, val2reg_64, fp_double_prec): Likewise.
(REG2VAL, ROUND, VAL2REG): Define shorthands.
(fpu_status_ok): Define.
(fpu_rsqrt, fpu_cmp, fpu_add, fpu_sub, fpu_mul, fpu_div,
fpu_fmadd, fpu_fmsub, fpu_fnmadd, fpu_fnmsub): Define.
* am33-2.igen (frsqrt, fcmp, fadd, fsub, fmul, fdiv,
fmadd, fmsub, fnmadd, fnmsub): Use new functions.
2000-04-27  Alexandre Oliva  <aoliva@@cygnus.com>
* interp.c (sim_create_inferior): Set PSW bit to enable FP insns
if architecture is AM33/2.0.
* am33.igen: Include am33-2.igen.
2000-04-23  Alexandre Oliva  <aoliva@@cygnus.com>
* mn10300.igen (movm, call, ret, retf): Check for am33_2 too.
* am33.igen (movm): Likewise.
2000-04-19  Alexandre Oliva  <aoliva@@cygnus.com>
* am33.igen: Added `*am33_2' to some instructions that were
missing it.
2000-04-07  Alexandre Oliva  <aoliva@@cygnus.com>
* am33-2.igen: New file.  All insns implemented, but FP flags are
only set for fcmp, exceptional conditions are not handled yet.
* Makefile.in (IGEN_INSN): Added am33-2.igen.
(tmp-igen): Added -M am33_2.
* mn10300.igen, am33.igen: Added `*am33_2' to all insns.
* gencode.c: Support FMT_D3.
* mn10300_sim.h (dword): New type.
(struct _state): Added fpregs.
(REG_FPCR, FPCR): New define.  All assorted bitmaps.
(XS2FS, AS2FS, Xf2FD): New macros.
(FS2FPU, FD2FPU, FPU2FS, FPU2FD): Likewise.
(load_dword, store_dword): New functions or macros.
(u642dw, dw2u64): New functions.
(fpu_disabled_exception, fpu_unimp_exception): Declared.
* interp.c (fpu_disabled_exception): Defined; no actual
implementation.
(fpu_unimp_exception): Likewise.
* op_utils.c (cmp2fcc): New function.
@
text
@d413 1
a413 1
  return -1;
@


1.4
log
@* interp.c, mn10300_sim.h, op_utils.c: Convert function prototypes
and definitions to ISO C.
@
text
@d325 3
d552 566
@


1.3
log
@* configure.in: Use common simulator always.  Don't subst sim_gen
nor mn10300_common.
* configure: Rebuilt.
* Makefile.in (WITHOUT_COMMON_OBJS, WITHOUT_COMMON_INTERP_DEP,
WITHOUT_COMMON_RUN_OBJS): Remove.
(WITH_COMMON_OBJS): Rename to MN10300_OBJS.
(WITH_COMMON_INTERP_DEP): Rename to MN10300_INTERP_DEP.
(WITH_COMMON_RUN_OBJS): Rename to SIM_RUN_OBJS.
(SIM_EXTRA_CFLAGS): Don't use @@sim_gen@@.
* interp.c: Remove non-common bits.
* mn10300_sim.h: Likewise.
@
text
@d50 5
a54 6
mn10300_option_handler (sd, cpu, opt, arg, is_command)
     SIM_DESC sd;
     sim_cpu *cpu;
     int opt;
     char *arg;
     int is_command;
d90 4
a93 5
sim_open (kind, cb, abfd, argv)
     SIM_OPEN_KIND kind;
     host_callback *cb;
     struct bfd *abfd;
     char **argv;
d305 1
a305 3
sim_close (sd, quitting)
     SIM_DESC sd;
     int quitting;
d312 4
a315 5
sim_create_inferior (sd, prog_bfd, argv, env)
     SIM_DESC sd;
     struct bfd *prog_bfd;
     char **argv;
     char **env;
d329 1
a329 3
sim_do_command (sd, cmd)
     SIM_DESC sd;
     char *cmd;
d349 1
a349 2
get_byte (x)
     uint8 *x;
d355 1
a355 2
get_half (x)
     uint8 *x;
d362 1
a362 2
get_word (x)
      uint8 *x;
d369 1
a369 3
put_byte (addr, data)
     uint8 *addr;
     uint8 data;
d376 1
a376 3
put_half (addr, data)
     uint8 *addr;
     uint16 data;
d384 1
a384 3
put_word (addr, data)
     uint8 *addr;
     uint32 data;
d394 4
a397 5
sim_fetch_register (sd, rn, memory, length)
     SIM_DESC sd;
     int rn;
     unsigned char *memory;
     int length;
d404 4
a407 5
sim_store_register (sd, rn, memory, length)
     SIM_DESC sd;
     int rn;
     unsigned char *memory;
     int length;
d416 7
a422 7
                 sim_cpu *cpu,
                 sim_cia cia,
                 unsigned map,
                 int nr_bytes,
                 address_word addr,
                 transfer_type transfer,
                 sim_core_signals sig)
@


1.2
log
@Index: arm/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* wrapper.c (sim_create_inferior, sim_open): Rename _bfd to bfd.

Index: common/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim-utils.h (sim_analyze_program, sim_load_file): Rename _bfd to bfd.
	* sim-hload.c (sim_load), sim-base.h (sim_state_base): Ditto.
	* nrun.c (main): Ditto.

Index: d10v/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: erc32/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interf.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: h8300/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* compile.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: h8500/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* compile.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: i960/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim-if.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: m32r/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim-if.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: m68hc11/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_prepare_for_program, sim_open)
	(sim_create_inferior): Rename _bfd to bfd.

Index: mcore/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: mips/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open):
	(sim_create_inferior):

Index: mn10200/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: mn10300/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior, sim_open)
	(sim_create_inferior): Rename _bfd to bfd.

Index: ppc/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* sim_calls.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: sh/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (init_dsp, sim_open, sim_create_inferior): Rename _bfd
	to bfd.

Index: v850/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* interp.c (sim_open, sim_create_inferior): Rename _bfd to bfd.

Index: z8k/ChangeLog
2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* iface.c (sim_open, sim_create_inferior): Rename _bfd to bfd.
@
text
@a2 1
#if WITH_COMMON
a5 3
#else
#include "mn10300_sim.h"
#endif
a84 851
#if WITH_COMMON
#else
static void dispatch PARAMS ((uint32, uint32, int));
static long hash PARAMS ((long));
static void init_system PARAMS ((void));

static SIM_OPEN_KIND sim_kind;
static char *myname;
#define MAX_HASH  127

struct hash_entry
{
  struct hash_entry *next;
  long opcode;
  long mask;
  struct simops *ops;
#ifdef HASH_STAT
  unsigned long count;
#endif
};

static int max_mem = 0;
struct hash_entry hash_table[MAX_HASH+1];


/* This probably doesn't do a very good job at bucket filling, but
   it's simple... */
static INLINE long 
hash(insn)
     long insn;
{
  /* These are one byte insns, we special case these since, in theory,
     they should be the most heavily used.  */
  if ((insn & 0xffffff00) == 0)
    {
      switch (insn & 0xf0)
	{
	  case 0x00:
	    return 0x70;

	  case 0x40:
	    return 0x71;

	  case 0x10:
	    return 0x72;

	  case 0x30:
	    return 0x73;

	  case 0x50:
	    return 0x74;

	  case 0x60:
	    return 0x75;

	  case 0x70:
	    return 0x76;

	  case 0x80:
	    return 0x77;

	  case 0x90:
	    return 0x78;

	  case 0xa0:
	    return 0x79;

	  case 0xb0:
	    return 0x7a;

	  case 0xe0:
	    return 0x7b;

	  default:
	    return 0x7c;
	}
    }

  /* These are two byte insns */
  if ((insn & 0xffff0000) == 0)
    {
      if ((insn & 0xf000) == 0x2000
	  || (insn & 0xf000) == 0x5000)
	return ((insn & 0xfc00) >> 8) & 0x7f;

      if ((insn & 0xf000) == 0x4000)
	return ((insn & 0xf300) >> 8) & 0x7f;

      if ((insn & 0xf000) == 0x8000
	  || (insn & 0xf000) == 0x9000
	  || (insn & 0xf000) == 0xa000
	  || (insn & 0xf000) == 0xb000)
	return ((insn & 0xf000) >> 8) & 0x7f;

      if ((insn & 0xff00) == 0xf000
	  || (insn & 0xff00) == 0xf100
	  || (insn & 0xff00) == 0xf200
	  || (insn & 0xff00) == 0xf500
	  || (insn & 0xff00) == 0xf600)
	return ((insn & 0xfff0) >> 4) & 0x7f;
 
      if ((insn & 0xf000) == 0xc000)
	return ((insn & 0xff00) >> 8) & 0x7f;

      return ((insn & 0xffc0) >> 6) & 0x7f;
    }

  /* These are three byte insns.  */
  if ((insn & 0xff000000) == 0)
    {
      if ((insn & 0xf00000) == 0x000000)
	return ((insn & 0xf30000) >> 16) & 0x7f;

      if ((insn & 0xf00000) == 0x200000
	  || (insn & 0xf00000) == 0x300000)
	return ((insn & 0xfc0000) >> 16) & 0x7f;

      if ((insn & 0xff0000) == 0xf80000)
	return ((insn & 0xfff000) >> 12) & 0x7f;

      if ((insn & 0xff0000) == 0xf90000)
	return ((insn & 0xfffc00) >> 10) & 0x7f;

      return ((insn & 0xff0000) >> 16) & 0x7f;
    }

  /* These are four byte or larger insns.  */
  if ((insn & 0xf0000000) == 0xf0000000)
    return ((insn & 0xfff00000) >> 20) & 0x7f;

  return ((insn & 0xff000000) >> 24) & 0x7f;
}

static INLINE void
dispatch (insn, extension, length)
     uint32 insn;
     uint32 extension;
     int length;
{
  struct hash_entry *h;

  h = &hash_table[hash(insn)];

  while ((insn & h->mask) != h->opcode
	  || (length != h->ops->length))
    {
      if (!h->next)
	{
	  (*mn10300_callback->printf_filtered) (mn10300_callback,
	    "ERROR looking up hash for 0x%x, PC=0x%x\n", insn, PC);
	  exit(1);
	}
      h = h->next;
    }


#ifdef HASH_STAT
  h->count++;
#endif

  /* Now call the right function.  */
  (h->ops->func)(insn, extension);
  PC += length;
}

void
sim_size (power)
     int power;

{
  if (State.mem)
    free (State.mem);

  max_mem = 1 << power;
  State.mem = (uint8 *) calloc (1,  1 << power);
  if (!State.mem)
    {
      (*mn10300_callback->printf_filtered) (mn10300_callback, "Allocation of main memory failed.\n");
      exit (1);
    }
}

static void
init_system ()
{
  if (!State.mem)
    sim_size(19);
}

int
sim_write (sd, addr, buffer, size)
     SIM_DESC sd;
     SIM_ADDR addr;
     unsigned char *buffer;
     int size;
{
  int i;

  init_system ();

  for (i = 0; i < size; i++)
    store_byte (addr + i, buffer[i]);

  return size;
}

/* Compare two opcode table entries for qsort.  */
static int
compare_simops (arg1, arg2)
     const PTR arg1;
     const PTR arg2;
{
  unsigned long code1 = ((struct simops *)arg1)->opcode;
  unsigned long code2 = ((struct simops *)arg2)->opcode;

  if (code1 < code2)
    return -1;
  if (code2 < code1)
    return 1;
  return 0;
}

SIM_DESC
sim_open (kind, cb, abfd, argv)
     SIM_OPEN_KIND kind;
     host_callback *cb;
     struct bfd *abfd;
     char **argv;
{
  struct simops *s;
  struct hash_entry *h;
  char **p;
  int i;

  mn10300_callback = cb;

  /* Sort the opcode array from smallest opcode to largest.
     This will generally improve simulator performance as the smaller
     opcodes are generally preferred to the larger opcodes.  */
  for (i = 0, s = Simops; s->func; s++, i++)
    ;
  qsort (Simops, i, sizeof (Simops[0]), compare_simops);

  sim_kind = kind;
  myname = argv[0];

  for (p = argv + 1; *p; ++p)
    {
      if (strcmp (*p, "-E") == 0)
	++p; /* ignore endian spec */
      else
#ifdef DEBUG
      if (strcmp (*p, "-t") == 0)
	mn10300_debug = DEBUG;
      else
#endif
	(*mn10300_callback->printf_filtered) (mn10300_callback, "ERROR: unsupported option(s): %s\n",*p);
    }

 /* put all the opcodes in the hash table */
  for (s = Simops; s->func; s++)
    {
      h = &hash_table[hash(s->opcode)];

      /* go to the last entry in the chain */
      while (h->next)
	{
	  /* Don't insert the same opcode more than once.  */
	  if (h->opcode == s->opcode
	      && h->mask == s->mask
	      && h->ops == s)
	    break;
	  else
	    h = h->next;
	}

      /* Don't insert the same opcode more than once.  */
      if (h->opcode == s->opcode
	  && h->mask == s->mask
	  && h->ops == s)
	continue;

      if (h->ops)
	{
	  h->next = calloc(1,sizeof(struct hash_entry));
	  h = h->next;
	}
      h->ops = s;
      h->mask = s->mask;
      h->opcode = s->opcode;
#if HASH_STAT
      h->count = 0;
#endif
    }


  /* fudge our descriptor for now */
  return (SIM_DESC) 1;
}


void
sim_close (sd, quitting)
     SIM_DESC sd;
     int quitting;
{
  /* nothing to do */
}

void
sim_set_profile (n)
     int n;
{
  (*mn10300_callback->printf_filtered) (mn10300_callback, "sim_set_profile %d\n", n);
}

void
sim_set_profile_size (n)
     int n;
{
  (*mn10300_callback->printf_filtered) (mn10300_callback, "sim_set_profile_size %d\n", n);
}

int
sim_stop (sd)
     SIM_DESC sd;
{
  return 0;
}

void
sim_resume (sd, step, siggnal)
     SIM_DESC sd;
     int step, siggnal;
{
  uint32 inst;
  reg_t oldpc;
  struct hash_entry *h;

  if (step)
    State.exception = SIGTRAP;
  else
    State.exception = 0;

  State.exited = 0;

  do
    {
      unsigned long insn, extension;

      /* Fetch the current instruction.  */
      inst = load_mem_big (PC, 2);
      oldpc = PC;

      /* Using a giant case statement may seem like a waste because of the
 	code/rodata size the table itself will consume.  However, using
 	a giant case statement speeds up the simulator by 10-15% by avoiding
 	cascading if/else statements or cascading case statements.  */

      switch ((inst >> 8) & 0xff)
	{
	  /* All the single byte insns except 0x80, 0x90, 0xa0, 0xb0
	     which must be handled specially.  */
	  case 0x00:
	  case 0x04:
	  case 0x08:
	  case 0x0c:
	  case 0x10:
	  case 0x11:
	  case 0x12:
	  case 0x13:
	  case 0x14:
	  case 0x15:
	  case 0x16:
	  case 0x17:
	  case 0x18:
	  case 0x19:
	  case 0x1a:
	  case 0x1b:
	  case 0x1c:
	  case 0x1d:
	  case 0x1e:
	  case 0x1f:
	  case 0x3c:
	  case 0x3d:
	  case 0x3e:
	  case 0x3f:
	  case 0x40:
	  case 0x41:
	  case 0x44:
	  case 0x45:
	  case 0x48:
	  case 0x49:
	  case 0x4c:
	  case 0x4d:
	  case 0x50:
	  case 0x51:
	  case 0x52:
	  case 0x53:
	  case 0x54:
	  case 0x55:
	  case 0x56:
	  case 0x57:
	  case 0x60:
	  case 0x61:
	  case 0x62:
	  case 0x63:
	  case 0x64:
	  case 0x65:
	  case 0x66:
	  case 0x67:
	  case 0x68:
	  case 0x69:
	  case 0x6a:
	  case 0x6b:
	  case 0x6c:
	  case 0x6d:
	  case 0x6e:
	  case 0x6f:
	  case 0x70:
	  case 0x71:
	  case 0x72:
	  case 0x73:
	  case 0x74:
	  case 0x75:
	  case 0x76:
	  case 0x77:
	  case 0x78:
	  case 0x79:
	  case 0x7a:
	  case 0x7b:
	  case 0x7c:
	  case 0x7d:
	  case 0x7e:
	  case 0x7f:
	  case 0xcb:
	  case 0xd0:
	  case 0xd1:
	  case 0xd2:
	  case 0xd3:
	  case 0xd4:
	  case 0xd5:
	  case 0xd6:
	  case 0xd7:
	  case 0xd8:
	  case 0xd9:
	  case 0xda:
	  case 0xdb:
	  case 0xe0:
	  case 0xe1:
	  case 0xe2:
	  case 0xe3:
	  case 0xe4:
	  case 0xe5:
	  case 0xe6:
	  case 0xe7:
	  case 0xe8:
	  case 0xe9:
	  case 0xea:
	  case 0xeb:
	  case 0xec:
	  case 0xed:
	  case 0xee:
	  case 0xef:
	  case 0xff:
	    insn = (inst >> 8) & 0xff;
	    extension = 0;
	    dispatch (insn, extension, 1);
	    break;

	  /* Special cases where dm == dn is used to encode a different
	     instruction.  */
	  case 0x80:
	  case 0x85:
	  case 0x8a:
	  case 0x8f:
	  case 0x90:
	  case 0x95:
	  case 0x9a:
	  case 0x9f:
	  case 0xa0:
	  case 0xa5:
	  case 0xaa:
	  case 0xaf:
	  case 0xb0:
	  case 0xb5:
	  case 0xba:
	  case 0xbf:
	    insn = inst;
	    extension = 0;
	    dispatch (insn, extension, 2);
	    break;

	  case 0x81:
	  case 0x82:
	  case 0x83:
	  case 0x84:
	  case 0x86:
	  case 0x87:
	  case 0x88:
	  case 0x89:
	  case 0x8b:
	  case 0x8c:
	  case 0x8d:
	  case 0x8e:
	  case 0x91:
	  case 0x92:
	  case 0x93:
	  case 0x94:
	  case 0x96:
	  case 0x97:
	  case 0x98:
	  case 0x99:
	  case 0x9b:
	  case 0x9c:
	  case 0x9d:
	  case 0x9e:
	  case 0xa1:
	  case 0xa2:
	  case 0xa3:
	  case 0xa4:
	  case 0xa6:
	  case 0xa7:
	  case 0xa8:
	  case 0xa9:
	  case 0xab:
	  case 0xac:
	  case 0xad:
	  case 0xae:
	  case 0xb1:
	  case 0xb2:
	  case 0xb3:
	  case 0xb4:
	  case 0xb6:
	  case 0xb7:
	  case 0xb8:
	  case 0xb9:
	  case 0xbb:
	  case 0xbc:
	  case 0xbd:
	  case 0xbe:
	    insn = (inst >> 8) & 0xff;
	    extension = 0;
	  dispatch (insn, extension, 1);
	  break;

	  /* The two byte instructions.  */
	  case 0x20:
	  case 0x21:
	  case 0x22:
	  case 0x23:
	  case 0x28:
	  case 0x29:
	  case 0x2a:
	  case 0x2b:
	  case 0x42:
	  case 0x43:
	  case 0x46:
	  case 0x47:
	  case 0x4a:
	  case 0x4b:
	  case 0x4e:
	  case 0x4f:
	  case 0x58:
	  case 0x59:
	  case 0x5a:
	  case 0x5b:
	  case 0x5c:
	  case 0x5d:
	  case 0x5e:
	  case 0x5f:
	  case 0xc0:
	  case 0xc1:
	  case 0xc2:
	  case 0xc3:
	  case 0xc4:
	  case 0xc5:
	  case 0xc6:
	  case 0xc7:
	  case 0xc8:
	  case 0xc9:
	  case 0xca:
	  case 0xce:
	  case 0xcf:
	  case 0xf0:
	  case 0xf1:
	  case 0xf2:
	  case 0xf3:
	  case 0xf4:
	  case 0xf5:
	  case 0xf6:
	    insn = inst;
	    extension = 0;
	    dispatch (insn, extension, 2);
	    break;

	  /* The three byte insns with a 16bit operand in little endian
	     format.  */
	  case 0x01:
	  case 0x02:
	  case 0x03:
	  case 0x05:
	  case 0x06:
	  case 0x07:
	  case 0x09:
	  case 0x0a:
	  case 0x0b:
	  case 0x0d:
	  case 0x0e:
	  case 0x0f:
	  case 0x24:
	  case 0x25:
	  case 0x26:
	  case 0x27:
	  case 0x2c:
	  case 0x2d:
	  case 0x2e:
	  case 0x2f:
	  case 0x30:
	  case 0x31:
	  case 0x32:
	  case 0x33:
	  case 0x34:
	  case 0x35:
	  case 0x36:
	  case 0x37:
	  case 0x38:
	  case 0x39:
	  case 0x3a:
	  case 0x3b:
	  case 0xcc:
	    insn = load_byte (PC);
	    insn <<= 16;
	    insn |= load_half (PC + 1);
	    extension = 0;
	    dispatch (insn, extension, 3);
	    break;

	  /* The three byte insns without 16bit operand.  */
	  case 0xde:
	  case 0xdf:
	  case 0xf8:
	  case 0xf9:
	    insn = load_mem_big (PC, 3);
	    extension = 0;
	    dispatch (insn, extension, 3);
	    break;
	  
	  /* Four byte insns.  */
	  case 0xfa:
	  case 0xfb:
	    if ((inst & 0xfffc) == 0xfaf0
		|| (inst & 0xfffc) == 0xfaf4
		|| (inst & 0xfffc) == 0xfaf8)
	      insn = load_mem_big (PC, 4);
	    else
	      {
		insn = inst;
		insn <<= 16;
		insn |= load_half (PC + 2);
		extension = 0;
	      }
	    dispatch (insn, extension, 4);
	    break;

	  /* Five byte insns.  */
	  case 0xcd:
	    insn = load_byte (PC);
	    insn <<= 24;
	    insn |= (load_half (PC + 1) << 8);
	    insn |= load_byte (PC + 3);
	    extension = load_byte (PC + 4);
	    dispatch (insn, extension, 5);
	    break;

	  case 0xdc:
	    insn = load_byte (PC);
	    insn <<= 24;
	    extension = load_word (PC + 1);
	    insn |= (extension & 0xffffff00) >> 8;
	    extension &= 0xff;
	    dispatch (insn, extension, 5);
	    break;
	
	  /* Six byte insns.  */
	  case 0xfc:
	  case 0xfd:
	    insn = (inst << 16);
	    extension = load_word (PC + 2);
	    insn |= ((extension & 0xffff0000) >> 16);
	    extension &= 0xffff;
	    dispatch (insn, extension, 6);
	    break;
	    
	  case 0xdd:
	    insn = load_byte (PC) << 24;
	    extension = load_word (PC + 1);
	    insn |= ((extension >> 8) & 0xffffff);
	    extension = (extension & 0xff) << 16;
	    extension |= load_byte (PC + 5) << 8;
	    extension |= load_byte (PC + 6);
	    dispatch (insn, extension, 7);
	    break;

	  case 0xfe:
	    insn = inst << 16;
	    extension = load_word (PC + 2);
	    insn |= ((extension >> 16) & 0xffff);
	    extension <<= 8;
	    extension &= 0xffff00;
	    extension |= load_byte (PC + 6);
	    dispatch (insn, extension, 7);
	    break;

	  default:
	    abort ();
	}
    }
  while (!State.exception);

#ifdef HASH_STAT
  {
    int i;
    for (i = 0; i < MAX_HASH; i++)
      {
	 struct hash_entry *h;
	 h = &hash_table[i];

	 printf("hash 0x%x:\n", i);

	 while (h)
	   {
	     printf("h->opcode = 0x%x, count = 0x%x\n", h->opcode, h->count);
	     h = h->next;
	   }

	 printf("\n\n");
      }
    fflush (stdout);
  }
#endif

}

int
sim_trace (sd)
     SIM_DESC sd;
{
#ifdef DEBUG
  mn10300_debug = DEBUG;
#endif
  sim_resume (sd, 0, 0);
  return 1;
}

void
sim_info (sd, verbose)
     SIM_DESC sd;
     int verbose;
{
  (*mn10300_callback->printf_filtered) (mn10300_callback, "sim_info\n");
}

SIM_RC
sim_create_inferior (sd, abfd, argv, env)
     SIM_DESC sd;
     struct bfd *abfd;
     char **argv;
     char **env;
{
  if (abfd != NULL)
    PC = bfd_get_start_address (abfd);
  else
    PC = 0;
  return SIM_RC_OK;
}

void
sim_set_callbacks (p)
     host_callback *p;
{
  mn10300_callback = p;
}

/* All the code for exiting, signals, etc needs to be revamped.

   This is enough to get c-torture limping though.  */

void
sim_stop_reason (sd, reason, sigrc)
     SIM_DESC sd;
     enum sim_stop *reason;
     int *sigrc;
{
  if (State.exited)
    *reason = sim_exited;
  else
    *reason = sim_stopped;

  if (State.exception == SIGQUIT)
    *sigrc = 0;
  else
    *sigrc = State.exception;
}

int
sim_read (sd, addr, buffer, size)
     SIM_DESC sd;
     SIM_ADDR addr;
     unsigned char *buffer;
     int size;
{
  int i;
  for (i = 0; i < size; i++)
    buffer[i] = load_byte (addr + i);

  return size;
} 

void
sim_do_command (sd, cmd)
     SIM_DESC sd;
     char *cmd;
{
  (*mn10300_callback->printf_filtered) (mn10300_callback, "\"%s\" is not a valid mn10300 simulator command.\n", cmd);
}

SIM_RC
sim_load (sd, prog, abfd, from_tty)
     SIM_DESC sd;
     char *prog;
     bfd *abfd;
     int from_tty;
{
  extern bfd *sim_load_file (); /* ??? Don't know where this should live.  */
  bfd *prog_bfd;

  prog_bfd = sim_load_file (sd, myname, mn10300_callback, prog, abfd,
			    sim_kind == SIM_OPEN_DEBUG,
			    0, sim_write);
  if (prog_bfd == NULL)
    return SIM_RC_FAIL;
  if (abfd == NULL)
    bfd_close (prog_bfd);
  return SIM_RC_OK;
} 
#endif  /* not WITH_COMMON */


#if WITH_COMMON

a350 1
#endif  /* WITH_COMMON */
@


1.2.42.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
d7 3
d54 6
a59 5
mn10300_option_handler (SIM_DESC sd,
			sim_cpu *cpu,
			int opt,
			char *arg,
			int is_command)
d89 851
d946 5
a950 4
sim_open (SIM_OPEN_KIND kind,
	  host_callback *cb,
	  struct bfd *abfd,
	  char **argv)
d1162 3
a1164 1
sim_close (SIM_DESC sd, int quitting)
d1171 5
a1175 4
sim_create_inferior (SIM_DESC sd,
		     struct bfd *prog_bfd,
		     char **argv,
		     char **env)
a1184 3
  if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2)
    PSW |= PSW_FE;

d1189 3
a1191 1
sim_do_command (SIM_DESC sd, char *cmd)
d1206 1
d1212 2
a1213 1
get_byte (uint8 *x)
d1219 2
a1220 1
get_half (uint8 *x)
d1227 2
a1228 1
get_word (uint8 *x)
d1235 3
a1237 1
put_byte (uint8 *addr, uint8 data)
d1244 3
a1246 1
put_half (uint8 *addr, uint16 data)
d1254 3
a1256 1
put_word (uint8 *addr, uint32 data)
d1266 5
a1270 4
sim_fetch_register (SIM_DESC sd,
		    int rn,
		    unsigned char *memory,
		    int length)
d1277 5
a1281 4
sim_store_register (SIM_DESC sd,
		    int rn,
		    unsigned char *memory,
		    int length)
d1290 7
a1296 7
		     sim_cpu *cpu,
		     sim_cia cia,
		     unsigned map,
		     int nr_bytes,
		     address_word addr,
		     transfer_type transfer,
		     sim_core_signals sig)
a1422 566

/* This is called when an FP instruction is issued when the FP unit is
   disabled, i.e., the FE bit of PSW is zero.  It raises interrupt
   code 0x1c0.  */
void
fpu_disabled_exception (SIM_DESC sd, sim_cpu *cpu, sim_cia cia)
{
  sim_io_eprintf(sd, "FPU disabled exception\n");
  program_interrupt (sd, cpu, cia, SIM_SIGFPE);
}

/* This is called when the FP unit is enabled but one of the
   unimplemented insns is issued.  It raises interrupt code 0x1c8.  */
void
fpu_unimp_exception (SIM_DESC sd, sim_cpu *cpu, sim_cia cia)
{
  sim_io_eprintf(sd, "Unimplemented FPU instruction exception\n");
  program_interrupt (sd, cpu, cia, SIM_SIGFPE);
}

/* This is called at the end of any FP insns that may have triggered
   FP exceptions.  If no exception is enabled, it returns immediately.
   Otherwise, it raises an exception code 0x1d0.  */
void
fpu_check_signal_exception (SIM_DESC sd, sim_cpu *cpu, sim_cia cia)
{
  if ((FPCR & EC_MASK) == 0)
    return;

  sim_io_eprintf(sd, "FPU %s%s%s%s%s exception\n",
		 (FPCR & EC_V) ? "V" : "",
		 (FPCR & EC_Z) ? "Z" : "",
		 (FPCR & EC_O) ? "O" : "",
		 (FPCR & EC_U) ? "U" : "",
		 (FPCR & EC_I) ? "I" : "");
  program_interrupt (sd, cpu, cia, SIM_SIGFPE);
}

/* Convert a 32-bit single-precision FP value in the target platform
   format to a sim_fpu value.  */
static void
reg2val_32 (const void *reg, sim_fpu *val)
{
  FS2FPU (*(reg_t *)reg, *val);
}

/* Round the given sim_fpu value to single precision, following the
   target platform rounding and denormalization conventions.  On
   AM33/2.0, round_near is the only rounding mode.  */
static int
round_32 (sim_fpu *val)
{
  return sim_fpu_round_32 (val, sim_fpu_round_near, sim_fpu_denorm_zero);
}

/* Convert a sim_fpu value to the 32-bit single-precision target
   representation.  */
static void
val2reg_32 (const sim_fpu *val, void *reg)
{
  FPU2FS (*val, *(reg_t *)reg);
}

/* Define the 32-bit single-precision conversion and rounding uniform
   interface.  */
const struct fp_prec_t
fp_single_prec = {
  reg2val_32, round_32, val2reg_32
};

/* Convert a 64-bit double-precision FP value in the target platform
   format to a sim_fpu value.  */
static void
reg2val_64 (const void *reg, sim_fpu *val)
{
  FD2FPU (*(dword *)reg, *val);
}

/* Round the given sim_fpu value to double precision, following the
   target platform rounding and denormalization conventions.  On
   AM33/2.0, round_near is the only rounding mode.  */
int
round_64 (sim_fpu *val)
{
  return sim_fpu_round_64 (val, sim_fpu_round_near, sim_fpu_denorm_zero);
}

/* Convert a sim_fpu value to the 64-bit double-precision target
   representation.  */
static void
val2reg_64 (const sim_fpu *val, void *reg)
{
  FPU2FD (*val, *(dword *)reg);
}

/* Define the 64-bit single-precision conversion and rounding uniform
   interface.  */
const struct fp_prec_t
fp_double_prec = {
  reg2val_64, round_64, val2reg_64
};

/* Define shortcuts to the uniform interface operations.  */
#define REG2VAL(reg,val) (*ops->reg2val) (reg,val)
#define ROUND(val) (*ops->round) (val)
#define VAL2REG(val,reg) (*ops->val2reg) (val,reg)

/* Check whether overflow, underflow or inexact exceptions should be
   raised.  */
int
fpu_status_ok (sim_fpu_status stat)
{
  if ((stat & sim_fpu_status_overflow)
      && (FPCR & EE_O))
    FPCR |= EC_O;
  else if ((stat & (sim_fpu_status_underflow | sim_fpu_status_denorm))
	   && (FPCR & EE_U))
    FPCR |= EC_U;
  else if ((stat & (sim_fpu_status_inexact | sim_fpu_status_rounded))
	   && (FPCR & EE_I))
    FPCR |= EC_I;
  else if (stat & ~ (sim_fpu_status_overflow
		     | sim_fpu_status_underflow
		     | sim_fpu_status_denorm
		     | sim_fpu_status_inexact
		     | sim_fpu_status_rounded))
    abort ();
  else
    return 1;
  return 0;
}

/* Implement a 32/64 bit reciprocal square root, signaling FP
   exceptions when appropriate.  */
void
fpu_rsqrt (SIM_DESC sd, sim_cpu *cpu, sim_cia cia,
	   const void *reg_in, void *reg_out, const struct fp_prec_t *ops)
{
  sim_fpu in, med, out;

  REG2VAL (reg_in, &in);
  ROUND (&in);
  FPCR &= ~ EC_MASK;
  switch (sim_fpu_is (&in))
    {
    case SIM_FPU_IS_SNAN:
    case SIM_FPU_IS_NNUMBER:
    case SIM_FPU_IS_NINF:
      if (FPCR & EE_V)
	FPCR |= EC_V;
      else
	VAL2REG (&sim_fpu_qnan, reg_out);
      break;
	    
    case SIM_FPU_IS_QNAN:
      VAL2REG (&sim_fpu_qnan, reg_out);
      break;

    case SIM_FPU_IS_PINF:
      VAL2REG (&sim_fpu_zero, reg_out);
      break;

    case SIM_FPU_IS_PNUMBER:
      {
	/* Since we don't have a function to compute rsqrt directly,
	   use sqrt and inv.  */
	sim_fpu_status stat = 0;
	stat |= sim_fpu_sqrt (&med, &in);
	stat |= sim_fpu_inv (&out, &med);
	stat |= ROUND (&out);
	if (fpu_status_ok (stat))
	  VAL2REG (&out, reg_out);
      }
      break;

    case SIM_FPU_IS_NZERO:
    case SIM_FPU_IS_PZERO:
      if (FPCR & EE_Z)
	FPCR |= EC_Z;
      else
	{
	  /* Generate an INF with the same sign.  */
	  sim_fpu_inv (&out, &in);
	  VAL2REG (&out, reg_out);
	}
      break;

    default:
      abort ();
    }

  fpu_check_signal_exception (sd, cpu, cia);
}

static inline reg_t
cmp2fcc (int res)
{
  switch (res)
    {
    case SIM_FPU_IS_SNAN:
    case SIM_FPU_IS_QNAN:
      return FCC_U;
      
    case SIM_FPU_IS_NINF:
    case SIM_FPU_IS_NNUMBER:
    case SIM_FPU_IS_NDENORM:
      return FCC_L;
      
    case SIM_FPU_IS_PINF:
    case SIM_FPU_IS_PNUMBER:
    case SIM_FPU_IS_PDENORM:
      return FCC_G;
      
    case SIM_FPU_IS_NZERO:
    case SIM_FPU_IS_PZERO:
      return FCC_E;
      
    default:
      abort ();
    }
}

/* Implement a 32/64 bit FP compare, setting the FPCR status and/or
   exception bits as specified.  */
void
fpu_cmp (SIM_DESC sd, sim_cpu *cpu, sim_cia cia,
	 const void *reg_in1, const void *reg_in2,
	 const struct fp_prec_t *ops)
{
  sim_fpu m, n;

  REG2VAL (reg_in1, &m);
  REG2VAL (reg_in2, &n);
  FPCR &= ~ EC_MASK;
  FPCR &= ~ FCC_MASK;
  ROUND (&m);
  ROUND (&n);
  if (sim_fpu_is_snan (&m) || sim_fpu_is_snan (&n))
    {
      if (FPCR & EE_V)
	FPCR |= EC_V;
      else
	FPCR |= FCC_U;
    }
  else
    FPCR |= cmp2fcc (sim_fpu_cmp (&m, &n));

  fpu_check_signal_exception (sd, cpu, cia);
}

/* Implement a 32/64 bit FP add, setting FP exception bits when
   appropriate.  */
void
fpu_add (SIM_DESC sd, sim_cpu *cpu, sim_cia cia,
	 const void *reg_in1, const void *reg_in2,
	 void *reg_out, const struct fp_prec_t *ops)
{
  sim_fpu m, n, r;

  REG2VAL (reg_in1, &m);
  REG2VAL (reg_in2, &n);
  ROUND (&m);
  ROUND (&n);
  FPCR &= ~ EC_MASK;
  if (sim_fpu_is_snan (&m) || sim_fpu_is_snan (&n)
      || (sim_fpu_is (&m) == SIM_FPU_IS_PINF
	  && sim_fpu_is (&n) == SIM_FPU_IS_NINF)
      || (sim_fpu_is (&m) == SIM_FPU_IS_NINF
	  && sim_fpu_is (&n) == SIM_FPU_IS_PINF))
    {
      if (FPCR & EE_V)
	FPCR |= EC_V;
      else
	VAL2REG (&sim_fpu_qnan, reg_out);
    }
  else
    {
      sim_fpu_status stat = sim_fpu_add (&r, &m, &n);
      stat |= ROUND (&r);
      if (fpu_status_ok (stat))
	VAL2REG (&r, reg_out);
    }
  
  fpu_check_signal_exception (sd, cpu, cia);
}

/* Implement a 32/64 bit FP sub, setting FP exception bits when
   appropriate.  */
void
fpu_sub (SIM_DESC sd, sim_cpu *cpu, sim_cia cia,
	 const void *reg_in1, const void *reg_in2,
	 void *reg_out, const struct fp_prec_t *ops)
{
  sim_fpu m, n, r;

  REG2VAL (reg_in1, &m);
  REG2VAL (reg_in2, &n);
  ROUND (&m);
  ROUND (&n);
  FPCR &= ~ EC_MASK;
  if (sim_fpu_is_snan (&m) || sim_fpu_is_snan (&n)
      || (sim_fpu_is (&m) == SIM_FPU_IS_PINF
	  && sim_fpu_is (&n) == SIM_FPU_IS_PINF)
      || (sim_fpu_is (&m) == SIM_FPU_IS_NINF
	  && sim_fpu_is (&n) == SIM_FPU_IS_NINF))
    {
      if (FPCR & EE_V)
	FPCR |= EC_V;
      else
	VAL2REG (&sim_fpu_qnan, reg_out);
    }
  else
    {
      sim_fpu_status stat = sim_fpu_sub (&r, &m, &n);
      stat |= ROUND (&r);
      if (fpu_status_ok (stat))
	VAL2REG (&r, reg_out);
    }
  
  fpu_check_signal_exception (sd, cpu, cia);
}

/* Implement a 32/64 bit FP mul, setting FP exception bits when
   appropriate.  */
void
fpu_mul (SIM_DESC sd, sim_cpu *cpu, sim_cia cia,
	 const void *reg_in1, const void *reg_in2,
	 void *reg_out, const struct fp_prec_t *ops)
{
  sim_fpu m, n, r;

  REG2VAL (reg_in1, &m);
  REG2VAL (reg_in2, &n);
  ROUND (&m);
  ROUND (&n);
  FPCR &= ~ EC_MASK;
  if (sim_fpu_is_snan (&m) || sim_fpu_is_snan (&n)
      || (sim_fpu_is_infinity (&m) && sim_fpu_is_zero (&n))
      || (sim_fpu_is_zero (&m) && sim_fpu_is_infinity (&n)))
    {
      if (FPCR & EE_V)
	FPCR |= EC_V;
      else
	VAL2REG (&sim_fpu_qnan, reg_out);
    }
  else
    {
      sim_fpu_status stat = sim_fpu_mul (&r, &m, &n);
      stat |= ROUND (&r);
      if (fpu_status_ok (stat))
	VAL2REG (&r, reg_out);
    }
  
  fpu_check_signal_exception (sd, cpu, cia);
}

/* Implement a 32/64 bit FP div, setting FP exception bits when
   appropriate.  */
void
fpu_div (SIM_DESC sd, sim_cpu *cpu, sim_cia cia,
	 const void *reg_in1, const void *reg_in2,
	 void *reg_out, const struct fp_prec_t *ops)
{
  sim_fpu m, n, r;

  REG2VAL (reg_in1, &m);
  REG2VAL (reg_in2, &n);
  ROUND (&m);
  ROUND (&n);
  FPCR &= ~ EC_MASK;
  if (sim_fpu_is_snan (&m) || sim_fpu_is_snan (&n)
      || (sim_fpu_is_infinity (&m) && sim_fpu_is_infinity (&n))
      || (sim_fpu_is_zero (&m) && sim_fpu_is_zero (&n)))
    {
      if (FPCR & EE_V)
	FPCR |= EC_V;
      else
	VAL2REG (&sim_fpu_qnan, reg_out);
    }
  else if (sim_fpu_is_number (&m) && sim_fpu_is_zero (&n)
	   && (FPCR & EE_Z))
    FPCR |= EC_Z;
  else
    {
      sim_fpu_status stat = sim_fpu_div (&r, &m, &n);
      stat |= ROUND (&r);
      if (fpu_status_ok (stat))
	VAL2REG (&r, reg_out);
    }
  
  fpu_check_signal_exception (sd, cpu, cia);
}

/* Implement a 32/64 bit FP madd, setting FP exception bits when
   appropriate.  */
void
fpu_fmadd (SIM_DESC sd, sim_cpu *cpu, sim_cia cia,
	   const void *reg_in1, const void *reg_in2, const void *reg_in3,
	   void *reg_out, const struct fp_prec_t *ops)
{
  sim_fpu m1, m2, m, n, r;

  REG2VAL (reg_in1, &m1);
  REG2VAL (reg_in2, &m2);
  REG2VAL (reg_in3, &n);
  ROUND (&m1);
  ROUND (&m2);
  ROUND (&n);
  FPCR &= ~ EC_MASK;
  if (sim_fpu_is_snan (&m1) || sim_fpu_is_snan (&m2) || sim_fpu_is_snan (&n)
      || (sim_fpu_is_infinity (&m1) && sim_fpu_is_zero (&m2))
      || (sim_fpu_is_zero (&m1) && sim_fpu_is_infinity (&m2)))
    {
    invalid_operands:
      if (FPCR & EE_V)
	FPCR |= EC_V;
      else
	VAL2REG (&sim_fpu_qnan, reg_out);
    }
  else
    {
      sim_fpu_status stat = sim_fpu_mul (&m, &m1, &m2);

      if (sim_fpu_is_infinity (&m) && sim_fpu_is_infinity (&n)
	  && sim_fpu_sign (&m) != sim_fpu_sign (&n))
	goto invalid_operands;

      stat |= sim_fpu_add (&r, &m, &n);
      stat |= ROUND (&r);
      if (fpu_status_ok (stat))
	VAL2REG (&r, reg_out);
    }
  
  fpu_check_signal_exception (sd, cpu, cia);
}

/* Implement a 32/64 bit FP msub, setting FP exception bits when
   appropriate.  */
void
fpu_fmsub (SIM_DESC sd, sim_cpu *cpu, sim_cia cia,
	   const void *reg_in1, const void *reg_in2, const void *reg_in3,
	   void *reg_out, const struct fp_prec_t *ops)
{
  sim_fpu m1, m2, m, n, r;

  REG2VAL (reg_in1, &m1);
  REG2VAL (reg_in2, &m2);
  REG2VAL (reg_in3, &n);
  ROUND (&m1);
  ROUND (&m2);
  ROUND (&n);
  FPCR &= ~ EC_MASK;
  if (sim_fpu_is_snan (&m1) || sim_fpu_is_snan (&m2) || sim_fpu_is_snan (&n)
      || (sim_fpu_is_infinity (&m1) && sim_fpu_is_zero (&m2))
      || (sim_fpu_is_zero (&m1) && sim_fpu_is_infinity (&m2)))
    {
    invalid_operands:
      if (FPCR & EE_V)
	FPCR |= EC_V;
      else
	VAL2REG (&sim_fpu_qnan, reg_out);
    }
  else
    {
      sim_fpu_status stat = sim_fpu_mul (&m, &m1, &m2);

      if (sim_fpu_is_infinity (&m) && sim_fpu_is_infinity (&n)
	  && sim_fpu_sign (&m) == sim_fpu_sign (&n))
	goto invalid_operands;

      stat |= sim_fpu_sub (&r, &m, &n);
      stat |= ROUND (&r);
      if (fpu_status_ok (stat))
	VAL2REG (&r, reg_out);
    }
  
  fpu_check_signal_exception (sd, cpu, cia);
}

/* Implement a 32/64 bit FP nmadd, setting FP exception bits when
   appropriate.  */
void
fpu_fnmadd (SIM_DESC sd, sim_cpu *cpu, sim_cia cia,
	    const void *reg_in1, const void *reg_in2, const void *reg_in3,
	    void *reg_out, const struct fp_prec_t *ops)
{
  sim_fpu m1, m2, m, mm, n, r;

  REG2VAL (reg_in1, &m1);
  REG2VAL (reg_in2, &m2);
  REG2VAL (reg_in3, &n);
  ROUND (&m1);
  ROUND (&m2);
  ROUND (&n);
  FPCR &= ~ EC_MASK;
  if (sim_fpu_is_snan (&m1) || sim_fpu_is_snan (&m2) || sim_fpu_is_snan (&n)
      || (sim_fpu_is_infinity (&m1) && sim_fpu_is_zero (&m2))
      || (sim_fpu_is_zero (&m1) && sim_fpu_is_infinity (&m2)))
    {
    invalid_operands:
      if (FPCR & EE_V)
	FPCR |= EC_V;
      else
	VAL2REG (&sim_fpu_qnan, reg_out);
    }
  else
    {
      sim_fpu_status stat = sim_fpu_mul (&m, &m1, &m2);

      if (sim_fpu_is_infinity (&m) && sim_fpu_is_infinity (&n)
	  && sim_fpu_sign (&m) == sim_fpu_sign (&n))
	goto invalid_operands;

      stat |= sim_fpu_neg (&mm, &m);
      stat |= sim_fpu_add (&r, &mm, &n);
      stat |= ROUND (&r);
      if (fpu_status_ok (stat))
	VAL2REG (&r, reg_out);
    }
  
  fpu_check_signal_exception (sd, cpu, cia);
}

/* Implement a 32/64 bit FP nmsub, setting FP exception bits when
   appropriate.  */
void
fpu_fnmsub (SIM_DESC sd, sim_cpu *cpu, sim_cia cia,
	    const void *reg_in1, const void *reg_in2, const void *reg_in3,
	    void *reg_out, const struct fp_prec_t *ops)
{
  sim_fpu m1, m2, m, mm, n, r;

  REG2VAL (reg_in1, &m1);
  REG2VAL (reg_in2, &m2);
  REG2VAL (reg_in3, &n);
  ROUND (&m1);
  ROUND (&m2);
  ROUND (&n);
  FPCR &= ~ EC_MASK;
  if (sim_fpu_is_snan (&m1) || sim_fpu_is_snan (&m2) || sim_fpu_is_snan (&n)
      || (sim_fpu_is_infinity (&m1) && sim_fpu_is_zero (&m2))
      || (sim_fpu_is_zero (&m1) && sim_fpu_is_infinity (&m2)))
    {
    invalid_operands:
      if (FPCR & EE_V)
	FPCR |= EC_V;
      else
	VAL2REG (&sim_fpu_qnan, reg_out);
    }
  else
    {
      sim_fpu_status stat = sim_fpu_mul (&m, &m1, &m2);

      if (sim_fpu_is_infinity (&m) && sim_fpu_is_infinity (&n)
	  && sim_fpu_sign (&m) != sim_fpu_sign (&n))
	goto invalid_operands;

      stat |= sim_fpu_neg (&mm, &m);
      stat |= sim_fpu_sub (&r, &mm, &n);
      stat |= ROUND (&r);
      if (fpu_status_ok (stat))
	VAL2REG (&r, reg_out);
    }
  
  fpu_check_signal_exception (sd, cpu, cia);
}
@


1.1
log
@Initial revision
@
text
@d315 1
a315 1
     struct _bfd *abfd;
d855 1
a855 1
     struct _bfd *abfd;
d949 1
a949 1
     struct _bfd *abfd;
d1117 4
a1120 4
      if ( NULL != board )
	{
	  printf("Error: invalid --board option.\n");
	  return 0;
d1173 1
a1173 1
     struct _bfd *prog_bfd;
d1332 1
d1338 22
a1359 4
  /* copy NMI handler code from dv-mn103cpu.c */
  /* XXX: possible infinite recursion if these store_*() calls fail! */
  store_word (SP - 4, CIA_GET (cpu));
  store_half (SP - 8, PSW);
d1364 1
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a1331 1
  static int in_interrupt = 0;
d1337 4
a1340 22
  /* avoid infinite recursion */
  if (in_interrupt)
    {
      (*mn10300_callback->printf_filtered) (mn10300_callback, 
					    "ERROR: recursion in program_interrupt during software exception dispatch.");
    }
  else
    {
      in_interrupt = 1;
      /* copy NMI handler code from dv-mn103cpu.c */
      store_word (SP - 4, CIA_GET (cpu));
      store_half (SP - 8, PSW);

      /* Set the SYSEF flag in NMICR by backdoor method.  See
	 dv-mn103int.c:write_icr().  This is necessary because
         software exceptions are not modelled by actually talking to
         the interrupt controller, so it cannot set its own SYSEF
         flag. */
     if ((NULL != board) && (strcmp(board, BOARD_AM32) == 0))
       store_byte (0x34000103, 0x04);
    }

a1344 1
  in_interrupt = 0;
@


1.1.1.3
log
@import gdb-1999-07-19 snapshot
@
text
@d1117 4
a1120 4
      if (board != NULL)
        {
	  sim_io_eprintf (sd, "Error: Board `%s' unknown.\n", board);
          return 0;
@


1.1.1.3.28.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d315 1
a315 1
     struct bfd *abfd;
d855 1
a855 1
     struct bfd *abfd;
d949 1
a949 1
     struct bfd *abfd;
d1173 1
a1173 1
     struct bfd *prog_bfd;
@


1.1.1.3.26.1
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d315 1
a315 1
     struct bfd *abfd;
d855 1
a855 1
     struct bfd *abfd;
d949 1
a949 1
     struct bfd *abfd;
d1173 1
a1173 1
     struct bfd *prog_bfd;
@


