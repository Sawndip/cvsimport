head	1.9;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.9
	gdb_7_6-2013-04-26-release:1.9
	gdb_7_6-branch:1.9.0.2
	gdb_7_6-2013-03-12-branchpoint:1.9
	gdb_7_5_1-2012-11-29-release:1.8
	gdb_7_5-2012-08-17-release:1.8
	gdb_7_5-branch:1.8.0.2
	gdb_7_5-2012-07-18-branchpoint:1.8
	gdb_7_4_1-2012-04-26-release:1.7.4.1
	gdb_7_4-2012-01-24-release:1.7.4.1
	gdb_7_4-branch:1.7.0.4
	gdb_7_4-2011-12-13-branchpoint:1.7
	gdb_7_3_1-2011-09-04-release:1.7
	gdb_7_3-2011-07-26-release:1.7
	gdb_7_3-branch:1.7.0.2
	gdb_7_3-2011-04-01-branchpoint:1.7
	gdb_7_2-2010-09-02-release:1.6
	gdb_7_2-branch:1.6.0.4
	gdb_7_2-2010-07-07-branchpoint:1.6
	gdb_7_1-2010-03-18-release:1.6
	gdb_7_1-branch:1.6.0.2
	gdb_7_1-2010-02-18-branchpoint:1.6
	gdb_7_0_1-2009-12-22-release:1.5
	gdb_7_0-2009-10-06-release:1.5
	gdb_7_0-branch:1.5.0.4
	gdb_7_0-2009-09-16-branchpoint:1.5
	arc-sim-20090309:1.4
	msnyder-checkpoint-072509-branch:1.5.0.2
	msnyder-checkpoint-072509-branchpoint:1.5
	arc-insight_6_8-branch:1.4.0.16
	arc-insight_6_8-branchpoint:1.4
	insight_6_8-branch:1.4.0.14
	insight_6_8-branchpoint:1.4
	reverse-20081226-branch:1.4.0.12
	reverse-20081226-branchpoint:1.4
	multiprocess-20081120-branch:1.4.0.10
	multiprocess-20081120-branchpoint:1.4
	reverse-20080930-branch:1.4.0.8
	reverse-20080930-branchpoint:1.4
	reverse-20080717-branch:1.4.0.6
	reverse-20080717-branchpoint:1.4
	msnyder-reverse-20080609-branch:1.4.0.4
	msnyder-reverse-20080609-branchpoint:1.4
	drow-reverse-20070409-branch:1.2.0.2
	drow-reverse-20070409-branchpoint:1.2
	gdb_6_8-2008-03-27-release:1.4
	gdb_6_8-branch:1.4.0.2
	gdb_6_8-2008-02-26-branchpoint:1.4
	gdb_6_7_1-2007-10-29-release:1.3
	gdb_6_7-2007-10-10-release:1.3
	gdb_6_7-branch:1.3.0.2
	gdb_6_7-2007-09-07-branchpoint:1.3
	insight_6_6-20070208-release:1.1
	gdb_6_6-2006-12-18-release:1.1
	gdb_6_6-branch:1.1.0.10
	gdb_6_6-2006-11-15-branchpoint:1.1
	insight_6_5-20061003-release:1.1
	nickrob-async-20060828-mergepoint:1.1
	gdb_6_5-20060621-release:1.1
	gdb_6_5-branch:1.1.0.8
	gdb_6_5-2006-05-14-branchpoint:1.1
	nickrob-async-20060513-branch:1.1.0.6
	nickrob-async-20060513-branchpoint:1.1
	msnyder-reverse-20060502-branch:1.1.0.4
	msnyder-reverse-20060502-branchpoint:1.1
	readline_5_1-import-branch:1.1.0.2
	readline_5_1-import-branchpoint:1.1;
locks; strict;
comment	@ * @;


1.9
date	2013.01.01.06.41.34;	author brobecke;	state Exp;
branches;
next	1.8;

1.8
date	2012.01.04.08.28.07;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2011.01.01.15.33.57;	author brobecke;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2010.01.01.10.03.28;	author brobecke;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.14.10.53.06;	author brobecke;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.01.22.53.23;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2007.08.24.14.28.35;	author brobecke;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.09.17.59.16;	author drow;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.03.03.01.45;	author hp;	state Exp;
branches;
next	;

1.7.4.1
date	2012.01.06.04.54.42;	author brobecke;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* The CRIS interrupt framework for GDB, the GNU Debugger.

   Copyright 2006-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "sim-main.h"
#include "hw-main.h"

/* DEVICE

   CRIS cpu virtual device (very rudimental; generic enough for all
   currently used CRIS versions).


   DESCRIPTION

   Implements the external CRIS functionality.  This includes the
   delivery of interrupts generated from other devices.


   PROPERTIES

   vec-for-int = <int-a> <vec-a> <int-b> <vec-b> ...
   These are the translations to interrupt vector for values appearing
   on the "int" port, as pairs of the value and the corresponding
   vector.  Defaults to no translation.  All values that may appear on
   the "int" port must be defined, or the device aborts.

   multiple-int = ("abort" | "ignore_previous" | <vector>)
   If multiple interrupt values are dispatched, this property decides
   what to do.  The value is either a number corresponding to the
   vector to use, or the string "abort" to cause a hard abort, or the
   string "ignore_previous", to silently use the new vector instead.
   The default is "abort".


   PORTS

   int (input)
   Interrupt port.  An event with a non-zero value on this port causes
   an interrupt.  If, after an event but before the interrupt has been
   properly dispatched, a non-zero value appears that is different
   after mapping than the previous, then the property multiple_int
   decides what to do.

   FIXME: reg port so internal registers can be read.  Requires
   chip-specific versions, though.  Ports "nmi" and "reset".


   BUGS
   When delivering an interrupt, this code assumes that there is only
   one processor (number 0).

   This code does not attempt to be efficient at handling pending
   interrupts.  It simply schedules the interrupt delivery handler
   every instruction cycle until all pending interrupts go away.
   It also works around a bug in sim_events_process when doing so.
   */

/* Keep this an enum for simple addition of "reset" and "nmi".  */
enum
 {
   INT_PORT,
 };

static const struct hw_port_descriptor cris_ports[] =
 {
   { "int", INT_PORT, 0, input_port },
   { NULL, 0, 0, 0 }
 };

struct cris_vec_tr
 {
   unsigned32 portval, vec;
 };

enum cris_multiple_ints
  {
    cris_multint_abort,
    cris_multint_ignore_previous,
    cris_multint_vector
  };

struct cris_hw
 {
   struct hw_event *pending_handler;
   unsigned32 pending_vector;
   struct cris_vec_tr *int_to_vec;
   enum cris_multiple_ints multi_int_action;
   unsigned32 multiple_int_vector;
 };

/* An event function, calling the actual CPU-model-specific
   interrupt-delivery function.  */

static void
deliver_cris_interrupt (struct hw *me, void *data)
{
  struct cris_hw *crishw = hw_data (me);
  SIM_DESC simulator = hw_system (me);
  sim_cpu *cpu = STATE_CPU (simulator, 0);
  unsigned int intno = crishw->pending_vector;

 if (CPU_CRIS_DELIVER_INTERRUPT (cpu) (cpu, CRIS_INT_INT, intno))
    {
      crishw->pending_vector = 0;
      crishw->pending_handler = NULL;
      return;
    }

 {
   /* Bug workaround: at time T with a pending number of cycles N to
      process, if re-scheduling an event at time T+M, M < N,
      sim_events_process gets stuck at T (updating the "time" to
      before the event rather than after the event, or somesuch).

      Hacking this locally is thankfully easy: if we see the same
      simulation time, increase the number of cycles.  Do this every
      time we get here, until a new time is seen (supposedly unstuck
      re-delivery).  (Fixing in SIM/GDB source will hopefully then
      also be easier, having a tangible test-case.)  */
   static signed64 last_events_time = 0;
   static signed64 delta = 1;
   signed64 this_events_time = hw_event_queue_time (me);

   if (this_events_time == last_events_time)
     delta++;
   else
     {
       delta = 1;
       last_events_time = this_events_time;
     }

   crishw->pending_handler
     = hw_event_queue_schedule (me, delta, deliver_cris_interrupt, NULL);
 }
}


/* A port-event function for events arriving to an interrupt port.  */

static void
cris_port_event (struct hw *me,
		 int my_port,
		 struct hw *source,
		 int source_port,
		 int intparam)
{
  struct cris_hw *crishw = hw_data (me);
  unsigned32 vec;

  /* A few placeholders; only the INT port is implemented.  */
  switch (my_port)
    {
    case INT_PORT:
      HW_TRACE ((me, "INT value=0x%x", intparam));
      break;

    default:
      hw_abort (me, "bad switch");
      break;
    }

  if (intparam == 0)
    return;

  if (crishw->int_to_vec != NULL)
    {
      unsigned int i;
      for (i = 0; crishw->int_to_vec[i].portval != 0; i++)
	if (crishw->int_to_vec[i].portval == intparam)
	  break;

      if (crishw->int_to_vec[i].portval == 0)
	hw_abort (me, "unsupported value for int port: 0x%x", intparam);

      vec = crishw->int_to_vec[i].vec;
    }
  else
    vec = (unsigned32) intparam;

  if (crishw->pending_vector != 0)
    {
      if (vec == crishw->pending_vector)
	return;

      switch (crishw->multi_int_action)
	{
	case cris_multint_abort:
	  hw_abort (me, "int 0x%x (0x%x) while int 0x%x hasn't been delivered",
		    vec, intparam, crishw->pending_vector);
	  break;

	case cris_multint_ignore_previous:
	  break;

	case cris_multint_vector:
	  vec = crishw->multiple_int_vector;
	  break;

	default:
	  hw_abort (me, "bad switch");
	}
    }

  crishw->pending_vector = vec;

  /* Schedule our event handler *now*.  */
  if (crishw->pending_handler == NULL)
    crishw->pending_handler
      = hw_event_queue_schedule (me, 0, deliver_cris_interrupt, NULL);
}

/* Instance initializer function.  */

static void
cris_finish (struct hw *me)
{
  struct cris_hw *crishw;
  const struct hw_property *vec_for_int;
  const struct hw_property *multiple_int;

  crishw = HW_ZALLOC (me, struct cris_hw);
  set_hw_data (me, crishw);
  set_hw_ports (me, cris_ports);
  set_hw_port_event (me, cris_port_event);

  vec_for_int = hw_find_property (me, "vec-for-int");
  if (vec_for_int != NULL)
    {
      unsigned32 vecsize;
      unsigned32 i;

      if (hw_property_type (vec_for_int) != array_property)
	hw_abort (me, "property \"vec-for-int\" has the wrong type");

      vecsize = hw_property_sizeof_array (vec_for_int) / sizeof (signed_cell);

      if ((vecsize % 2) != 0)
	hw_abort (me, "translation vector does not consist of even pairs");

      crishw->int_to_vec
	= hw_malloc (me, (vecsize/2 + 1) * sizeof (crishw->int_to_vec[0]));

      for (i = 0; i < vecsize/2; i++)
	{
	  signed_cell portval_sc;
	  signed_cell vec_sc;

	  if (!hw_find_integer_array_property (me, "vec-for-int", i*2,
					       &portval_sc)
	      || !hw_find_integer_array_property (me, "vec-for-int", i*2 + 1,
						  &vec_sc)
	      || portval_sc < 0
	      || vec_sc < 0)
	    hw_abort (me, "no valid vector translation pair %u", i);

	  crishw->int_to_vec[i].portval = (unsigned32) portval_sc;
	  crishw->int_to_vec[i].vec = (unsigned32) vec_sc;
	}

      crishw->int_to_vec[i].portval = 0;
      crishw->int_to_vec[i].vec = 0;
    }

  multiple_int = hw_find_property (me, "multiple-int");
  if (multiple_int != NULL)
    {
      if (hw_property_type (multiple_int) == integer_property)
	{
	  crishw->multiple_int_vector
	    = hw_find_integer_property (me, "multiple-int");
	  crishw->multi_int_action = cris_multint_vector;
	}
      else
	{
	  const char *action = hw_find_string_property (me, "multiple-int");

	  if (action == NULL)
	    hw_abort (me, "property \"multiple-int\" has the wrong type");

	  if (strcmp (action, "abort") == 0)
	    crishw->multi_int_action = cris_multint_abort;
	  else if (strcmp (action, "ignore_previous") == 0)
	    crishw->multi_int_action = cris_multint_ignore_previous;
	  else
	    hw_abort (me, "property \"multiple-int\" must be one of <vector number>\n"
		      "\"abort\" and \"ignore_previous\", not \"%s\"", action);
	}
    }
  else
    crishw->multi_int_action = cris_multint_abort;
}

const struct hw_descriptor dv_cris_descriptor[] = {
  { "cris", cris_finish, },
  { NULL },
};
@


1.8
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright 2006-2012 Free Software Foundation, Inc.
@


1.7
log
@run copyright.sh for 2011.
@
text
@d3 1
a3 1
   Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.7.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright 2006-2012 Free Software Foundation, Inc.
@


1.6
log
@Update copyright notices to add year 2010.
@
text
@d3 1
a3 1
   Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.5
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d3 1
a3 1
   Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.4
log
@	Updated copyright notices for most files.
@
text
@d3 1
a3 1
   Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.3
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d3 1
a3 1
   Copyright 2006, 2007 Free Software Foundation, Inc.
@


1.2
log
@Copyright updates for 2007.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d18 1
a18 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.1
log
@	* cris/dv-cris.c, cris/dv-rv.c, cris/rvdummy.c: New files.
	* cris/Makefile.in (CONFIG_DEVICES): Remove redundant setting.
	(dv-cris.o, dv-rv.o rvdummy$(EXEEXT), rvdummy.o): New rules.
	(all): Depend on rvdummy$(EXEEXT).
	* cris/configure.ac: Call SIM_AC_OPTION_WARNINGS.  Check for
	sys/socket.h and sys/select.h.  Call SIM_AC_OPTION_HARDWARE,
	default off.
	* cris/configure: Regenerate.
	* cris/cris-sim.h (cris_have_900000xxif): Declare here.
	(enum cris_interrupt_type, crisv10deliver_interrupt)
	(crisv32deliver_interrupt: New declarations.
	* cris/cris-tmpl.c [WITH_HW] (MY (f_model_insn_after)): Call
	sim_events_tickn and set state-events member work_pending when it's
	time for the next event.
	[WITH_HW] (MY (f_specific_init)): Set CPU-model-specific
	interrupt-delivery function.
	* cris/crisv10f.c (MY (deliver_interrupt)): New function.
	* cris/crisv32f.c (MY (deliver_interrupt)): New function.
	* cris/devices.c: Include hw-device.h.
	(device_io_read_buffer) [WITH_HW]: Call hw_io_read_buffer.
	(device_io_write_buffer): Only perform 0x900000xx-functions if
	cris_have_900000xxif is nonzero.  Else if WITH_HW defined,
	call hw_io_write_buffer.  Add return 0 last in function.
	* cris/sim-if.c (cris_have_900000xxif): Now global.
	(sim_open) [WITH_HW]: Clear deliver_interrupt cpu member.
	Force "-model" option, effectively.
	* cris/sim-main.h (cris_interrupt_delivery_fn): New type.
	(struct _sim_cpu) [WITH_HW]: New member deliver_interrupt.
@
text
@d3 1
a3 1
   Copyright 2006 Free Software Foundation, Inc.
@

