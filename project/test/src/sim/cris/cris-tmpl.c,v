head	1.14;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.14
	gdb_7_6-2013-04-26-release:1.14
	gdb_7_6-branch:1.14.0.2
	gdb_7_6-2013-03-12-branchpoint:1.14
	gdb_7_5_1-2012-11-29-release:1.13
	gdb_7_5-2012-08-17-release:1.13
	gdb_7_5-branch:1.13.0.2
	gdb_7_5-2012-07-18-branchpoint:1.13
	gdb_7_4_1-2012-04-26-release:1.12.4.1
	gdb_7_4-2012-01-24-release:1.12.4.1
	gdb_7_4-branch:1.12.0.4
	gdb_7_4-2011-12-13-branchpoint:1.12
	gdb_7_3_1-2011-09-04-release:1.12
	gdb_7_3-2011-07-26-release:1.12
	gdb_7_3-branch:1.12.0.2
	gdb_7_3-2011-04-01-branchpoint:1.12
	gdb_7_2-2010-09-02-release:1.11
	gdb_7_2-branch:1.11.0.4
	gdb_7_2-2010-07-07-branchpoint:1.11
	gdb_7_1-2010-03-18-release:1.11
	gdb_7_1-branch:1.11.0.2
	gdb_7_1-2010-02-18-branchpoint:1.11
	gdb_7_0_1-2009-12-22-release:1.10
	gdb_7_0-2009-10-06-release:1.10
	gdb_7_0-branch:1.10.0.4
	gdb_7_0-2009-09-16-branchpoint:1.10
	arc-sim-20090309:1.8
	msnyder-checkpoint-072509-branch:1.10.0.2
	msnyder-checkpoint-072509-branchpoint:1.10
	arc-insight_6_8-branch:1.8.0.16
	arc-insight_6_8-branchpoint:1.8
	insight_6_8-branch:1.8.0.14
	insight_6_8-branchpoint:1.8
	reverse-20081226-branch:1.8.0.12
	reverse-20081226-branchpoint:1.8
	multiprocess-20081120-branch:1.8.0.10
	multiprocess-20081120-branchpoint:1.8
	reverse-20080930-branch:1.8.0.8
	reverse-20080930-branchpoint:1.8
	reverse-20080717-branch:1.8.0.6
	reverse-20080717-branchpoint:1.8
	msnyder-reverse-20080609-branch:1.8.0.4
	msnyder-reverse-20080609-branchpoint:1.8
	drow-reverse-20070409-branch:1.6.0.2
	drow-reverse-20070409-branchpoint:1.6
	gdb_6_8-2008-03-27-release:1.8
	gdb_6_8-branch:1.8.0.2
	gdb_6_8-2008-02-26-branchpoint:1.8
	gdb_6_7_1-2007-10-29-release:1.7
	gdb_6_7-2007-10-10-release:1.7
	gdb_6_7-branch:1.7.0.2
	gdb_6_7-2007-09-07-branchpoint:1.7
	insight_6_6-20070208-release:1.5
	gdb_6_6-2006-12-18-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb-csl-symbian-6_4_50_20060226-12:1.4
	gdb-csl-sourcerygxx-3_4_4-25:1.2
	nickrob-async-20060828-mergepoint:1.5
	gdb-csl-symbian-6_4_50_20060226-11:1.4
	gdb-csl-sourcerygxx-4_1-17:1.4
	gdb-csl-20060226-branch-local-2:1.4
	gdb-csl-sourcerygxx-4_1-14:1.4
	gdb-csl-sourcerygxx-4_1-13:1.4
	gdb-csl-sourcerygxx-4_1-12:1.4
	gdb-csl-sourcerygxx-3_4_4-21:1.4
	gdb_6_5-20060621-release:1.5
	gdb-csl-sourcerygxx-4_1-9:1.4
	gdb-csl-sourcerygxx-4_1-8:1.4
	gdb-csl-sourcerygxx-4_1-7:1.4
	gdb-csl-arm-2006q1-6:1.4
	gdb-csl-sourcerygxx-4_1-6:1.4
	gdb-csl-symbian-6_4_50_20060226-10:1.4
	gdb-csl-symbian-6_4_50_20060226-9:1.4
	gdb-csl-symbian-6_4_50_20060226-8:1.4
	gdb-csl-coldfire-4_1-11:1.4
	gdb-csl-sourcerygxx-3_4_4-19:1.4
	gdb-csl-coldfire-4_1-10:1.4
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb-csl-sourcerygxx-4_1-5:1.4
	nickrob-async-20060513-branch:1.5.0.6
	nickrob-async-20060513-branchpoint:1.5
	gdb-csl-sourcerygxx-4_1-4:1.4
	msnyder-reverse-20060502-branch:1.5.0.4
	msnyder-reverse-20060502-branchpoint:1.5
	gdb-csl-morpho-4_1-4:1.4
	gdb-csl-sourcerygxx-3_4_4-17:1.4
	readline_5_1-import-branch:1.5.0.2
	readline_5_1-import-branchpoint:1.5
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.4
	gdb-csl-symbian-20060226-branch:1.4.0.8
	gdb-csl-symbian-20060226-branchpoint:1.4
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.4
	msnyder-reverse-20060331-branch:1.4.0.6
	msnyder-reverse-20060331-branchpoint:1.4
	gdb-csl-available-20060303-branch:1.4.0.4
	gdb-csl-available-20060303-branchpoint:1.4
	gdb-csl-20060226-branch:1.4.0.2
	gdb-csl-20060226-branchpoint:1.4
	gdb_6_4-20051202-release:1.1
	msnyder-fork-checkpoint-branch:1.2.0.4
	msnyder-fork-checkpoint-branchpoint:1.2
	gdb-csl-gxxpro-6_3-branch:1.2.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.2
	gdb_6_4-branch:1.1.0.8
	gdb_6_4-2005-11-01-branchpoint:1.1
	gdb-csl-arm-20051020-branch:1.1.0.6
	gdb-csl-arm-20051020-branchpoint:1.1
	msnyder-tracepoint-checkpoint-branch:1.1.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.1
	gdb-csl-arm-20050325-2005-q1b:1.1
	gdb-csl-arm-20050325-2005-q1a:1.1
	csl-arm-20050325-branch:1.1.0.2
	csl-arm-20050325-branchpoint:1.1;
locks; strict;
comment	@ * @;


1.14
date	2013.01.01.06.41.34;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2012.01.04.08.28.07;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2011.01.01.15.33.57;	author brobecke;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2010.01.01.10.03.28;	author brobecke;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.14.10.53.06;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.03.21.00.48;	author hp;	state Exp;
branches;
next	1.8;

1.8
date	2008.01.01.22.53.23;	author drow;	state Exp;
branches;
next	1.7;

1.7
date	2007.08.24.14.28.35;	author brobecke;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.09.17.59.16;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.03.03.01.45;	author hp;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.10.07.06.25;	author hp;	state Exp;
branches;
next	1.3;

1.3
date	2006.01.10.07.05.44;	author hp;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.16.04.50.57;	author hp;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.04.28.59;	author hp;	state Exp;
branches;
next	;

1.12.4.1
date	2012.01.06.04.54.41;	author brobecke;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* CRIS base simulator support code
   Copyright (C) 2004-2013 Free Software Foundation, Inc.
   Contributed by Axis Communications.

This file is part of the GNU simulators.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* The infrastructure is based on that of i960.c.  */

#define WANT_CPU

#include "sim-main.h"
#include "cgen-mem.h"
#include "cgen-ops.h"

#define MY(f) XCONCAT3(crisv,BASENUM,f)

/* Dispatcher for break insn.  */

USI
MY (f_break_handler) (SIM_CPU *cpu, USI breaknum, USI pc)
{
  SIM_DESC sd = CPU_STATE (cpu);
  USI ret = pc + 2;

  MY (f_h_pc_set) (cpu, ret);

  /* FIXME: Error out if IBR or ERP set.  */
  switch (breaknum)
    {
    case 13:
      MY (f_h_gr_set (cpu, 10,
		      cris_break_13_handler (cpu,
					     MY (f_h_gr_get (cpu, 9)),
					     MY (f_h_gr_get (cpu, 10)),
					     MY (f_h_gr_get (cpu, 11)),
					     MY (f_h_gr_get (cpu, 12)),
					     MY (f_h_gr_get (cpu, 13)),
					     MY (f_h_sr_get (cpu, 7)),
					     MY (f_h_sr_get (cpu, 11)),
					     pc)));
      break;

    case 14:
      sim_io_printf (sd, "%x\n", MY (f_h_gr_get (cpu, 3)));
      break;

    case 15:
      /* Re-use the Linux exit call.  */
      cris_break_13_handler (cpu, /* TARGET_SYS_exit */ 1, 0,
			     0, 0, 0, 0, 0, pc);

    default:
      abort ();
    }

  return MY (f_h_pc_get) (cpu);
}

/* Accessor function for simulator internal use.
   Note the contents of BUF are in target byte order.  */

int
MY (f_fetch_register) (SIM_CPU *current_cpu, int rn,
		      unsigned char *buf, int len ATTRIBUTE_UNUSED)
{
  SETTSI (buf, XCONCAT3(crisv,BASENUM,f_h_gr_get) (current_cpu, rn));
  return -1;
}

/* Accessor function for simulator internal use.
   Note the contents of BUF are in target byte order.  */

int
MY (f_store_register) (SIM_CPU *current_cpu, int rn,
		      unsigned char *buf, int len ATTRIBUTE_UNUSED)
{
  XCONCAT3(crisv,BASENUM,f_h_gr_set) (current_cpu, rn, GETTSI (buf));
  return -1;
}

#if WITH_PROFILE_MODEL_P

/* FIXME: Some of these should be inline or macros.  Later.  */

/* Initialize cycle counting for an insn.
   FIRST_P is non-zero if this is the first insn in a set of parallel
   insns.  */

void
MY (f_model_insn_before) (SIM_CPU *current_cpu, int first_p ATTRIBUTE_UNUSED)
{
  /* To give the impression that we actually know what PC is, we have to
     dump register contents *before* the *next* insn, not after the
     *previous* insn.  Uhh...  */

  /* FIXME: Move this to separate, overridable function.  */
  if ((CPU_CRIS_MISC_PROFILE (current_cpu)->flags
       & FLAG_CRIS_MISC_PROFILE_XSIM_TRACE)
#ifdef GET_H_INSN_PREFIXED_P
      /* For versions with prefixed insns, trace the combination as
	 one insn.  */
      && !GET_H_INSN_PREFIXED_P ()
#endif
      && 1)
  {
    int i;
    char flags[7];
    unsigned64 cycle_count;

    SIM_DESC sd = CPU_STATE (current_cpu);

    cris_trace_printf (sd, current_cpu, "%lx ",
		       0xffffffffUL & (unsigned long) (CPU (h_pc)));

    for (i = 0; i < 15; i++)
      cris_trace_printf (sd, current_cpu, "%lx ",
			 0xffffffffUL
			 & (unsigned long) (XCONCAT3(crisv,BASENUM,
						     f_h_gr_get) (current_cpu,
								  i)));
    flags[0] = GET_H_IBIT () != 0 ? 'I' : 'i';
    flags[1] = GET_H_XBIT () != 0 ? 'X' : 'x';
    flags[2] = GET_H_NBIT () != 0 ? 'N' : 'n';
    flags[3] = GET_H_ZBIT () != 0 ? 'Z' : 'z';
    flags[4] = GET_H_VBIT () != 0 ? 'V' : 'v';
    flags[5] = GET_H_CBIT () != 0 ? 'C' : 'c';
    flags[6] = 0;

    /* For anything else than basic tracing we'd add stall cycles for
       e.g. unaligned accesses.  FIXME: add --cris-trace=x options to
       match --cris-cycles=x.  */
    cycle_count
      = (CPU_CRIS_MISC_PROFILE (current_cpu)->basic_cycle_count
	 - CPU_CRIS_PREV_MISC_PROFILE (current_cpu)->basic_cycle_count);

    /* Emit ACR after flags and cycle count for this insn.  */
    if (BASENUM == 32)
      cris_trace_printf (sd, current_cpu, "%s %d %lx\n", flags,
			 (int) cycle_count,
			 0xffffffffUL
			 & (unsigned long) (XCONCAT3(crisv,BASENUM,
						     f_h_gr_get) (current_cpu,
								  15)));
    else
      cris_trace_printf (sd, current_cpu, "%s %d\n", flags,
			 (int) cycle_count);

    CPU_CRIS_PREV_MISC_PROFILE (current_cpu)[0]
      = CPU_CRIS_MISC_PROFILE (current_cpu)[0];
  }
}

/* Record the cycles computed for an insn.
   LAST_P is non-zero if this is the last insn in a set of parallel insns,
   and we update the total cycle count.
   CYCLES is the cycle count of the insn.  */

void
MY (f_model_insn_after) (SIM_CPU *current_cpu, int last_p ATTRIBUTE_UNUSED,
			 int cycles)
{
  PROFILE_DATA *p = CPU_PROFILE_DATA (current_cpu);

  PROFILE_MODEL_TOTAL_CYCLES (p) += cycles;
  CPU_CRIS_MISC_PROFILE (current_cpu)->basic_cycle_count += cycles;
  PROFILE_MODEL_CUR_INSN_CYCLES (p) = cycles;

#if WITH_HW
  /* For some reason, we don't get to the sim_events_tick call in
     cgen-run.c:engine_run_1.  Besides, more than one cycle has
     passed, so we want sim_events_tickn anyway.  The "events we want
     to process" is usually to initiate an interrupt, but might also
     be other events.  We can't do the former until the main loop is
     at point where it accepts changing the PC without internal
     inconsistency, so just set a flag and wait.  */
  if (sim_events_tickn (CPU_STATE (current_cpu), cycles))
    STATE_EVENTS (CPU_STATE (current_cpu))->work_pending = 1;
#endif
}

/* Initialize cycle counting for an insn.
   FIRST_P is non-zero if this is the first insn in a set of parallel
   insns.  */

void
MY (f_model_init_insn_cycles) (SIM_CPU *current_cpu ATTRIBUTE_UNUSED,
			       int first_p ATTRIBUTE_UNUSED)
{
  abort ();
}

/* Record the cycles computed for an insn.
   LAST_P is non-zero if this is the last insn in a set of parallel insns,
   and we update the total cycle count.  */

void
MY (f_model_update_insn_cycles) (SIM_CPU *current_cpu ATTRIBUTE_UNUSED,
				 int last_p ATTRIBUTE_UNUSED)
{
  abort ();
}

#if 0
void
MY (f_model_record_cycles) (SIM_CPU *current_cpu, unsigned long cycles)
{
  abort ();
}

void
MY (f_model_mark_get_h_gr) (SIM_CPU *current_cpu, ARGBUF *abuf)
{
  abort ();
}

void
MY (f_model_mark_set_h_gr) (SIM_CPU *current_cpu, ARGBUF *abuf)
{
  abort ();
}
#endif

/* Set the thread register contents.  */

void
MY (set_target_thread_data) (SIM_CPU *current_cpu, USI val)
{
  (CPU (XCONCAT2 (h_sr_v, BASENUM) [CRIS_TLS_REGISTER])) = val;
}

/* Create the context for a thread.  */

void *
MY (make_thread_cpu_data) (SIM_CPU *current_cpu, void *context)
{
  void *info = xmalloc (current_cpu->thread_cpu_data_size);

  if (context != NULL)
    memcpy (info,
	    context,
	    current_cpu->thread_cpu_data_size);
  else
    memset (info, 0, current_cpu->thread_cpu_data_size),abort();
  return info;
}

/* Hook function for per-cpu simulator initialization.  */

void
MY (f_specific_init) (SIM_CPU *current_cpu)
{
  current_cpu->make_thread_cpu_data = MY (make_thread_cpu_data);
  current_cpu->thread_cpu_data_size = sizeof (current_cpu->cpu_data);
  current_cpu->set_target_thread_data = MY (set_target_thread_data);
#if WITH_HW
  current_cpu->deliver_interrupt = MY (deliver_interrupt);
#endif
}

/* Model function for arbitrary single stall cycles.  */

int
MY (XCONCAT3 (f_model_crisv,BASENUM,
	      _u_stall)) (SIM_CPU *current_cpu ATTRIBUTE_UNUSED,
			  const IDESC *idesc,
			  int unit_num,
			  int referenced ATTRIBUTE_UNUSED)
{
  return idesc->timing->units[unit_num].done;
}

#ifndef SPECIFIC_U_SKIP4_FN

/* Model function for u-skip4 unit.  */

int
MY (XCONCAT3 (f_model_crisv,BASENUM,
	      _u_skip4)) (SIM_CPU *current_cpu,
			  const IDESC *idesc,
			  int unit_num,
			  int referenced ATTRIBUTE_UNUSED)
{
  /* Handle PC not being updated with pbb.  FIXME: What if not pbb?  */
  CPU (h_pc) += 4;
  return idesc->timing->units[unit_num].done;
}

#endif

#ifndef SPECIFIC_U_EXEC_FN

/* Model function for u-exec unit.  */

int
MY (XCONCAT3 (f_model_crisv,BASENUM,
	      _u_exec)) (SIM_CPU *current_cpu,
			 const IDESC *idesc,
			 int unit_num, int referenced ATTRIBUTE_UNUSED)
{
  /* Handle PC not being updated with pbb.  FIXME: What if not pbb?  */
  CPU (h_pc) += 2;
  return idesc->timing->units[unit_num].done;
}
#endif

#ifndef SPECIFIC_U_MEM_FN

/* Model function for u-mem unit.  */

int
MY (XCONCAT3 (f_model_crisv,BASENUM,
	      _u_mem)) (SIM_CPU *current_cpu ATTRIBUTE_UNUSED,
			const IDESC *idesc,
			int unit_num,
			int referenced ATTRIBUTE_UNUSED)
{
  return idesc->timing->units[unit_num].done;
}
#endif

#ifndef SPECIFIC_U_CONST16_FN

/* Model function for u-const16 unit.  */

int
MY (XCONCAT3 (f_model_crisv,BASENUM,
	      _u_const16)) (SIM_CPU *current_cpu,
			    const IDESC *idesc,
			    int unit_num,
			    int referenced ATTRIBUTE_UNUSED)
{
  CPU (h_pc) += 2;
  return idesc->timing->units[unit_num].done;
}
#endif /* SPECIFIC_U_CONST16_FN */

#ifndef SPECIFIC_U_CONST32_FN

/* This will be incorrect for early models, where a dword always take
   two cycles.  */
#define CRIS_MODEL_MASK_PC_STALL 2

/* Model function for u-const32 unit.  */

int
MY (XCONCAT3 (f_model_crisv,BASENUM,
	      _u_const32)) (SIM_CPU *current_cpu,
			    const IDESC *idesc,
			    int unit_num,
			    int referenced ATTRIBUTE_UNUSED)
{
  int unaligned_extra
    = (((CPU (h_pc) + 2) & CRIS_MODEL_MASK_PC_STALL)
       == CRIS_MODEL_MASK_PC_STALL);

  /* Handle PC not being updated with pbb.  FIXME: What if not pbb?  */
  CPU_CRIS_MISC_PROFILE (current_cpu)->unaligned_mem_dword_count
    += unaligned_extra;

  CPU (h_pc) += 4;
  return idesc->timing->units[unit_num].done;
}
#endif /* SPECIFIC_U_CONST32_FN */

#ifndef SPECIFIC_U_MOVEM_FN

/* Model function for u-movem unit.  */

int
MY (XCONCAT3 (f_model_crisv,BASENUM,
	      _u_movem)) (SIM_CPU *current_cpu ATTRIBUTE_UNUSED,
			  const IDESC *idesc ATTRIBUTE_UNUSED,
			  int unit_num ATTRIBUTE_UNUSED,
			  int referenced ATTRIBUTE_UNUSED,
			  INT limreg)
{
  /* FIXME: Add cycles for misalignment.  */

  if (limreg == -1)
    abort ();

  /* We don't record movem move cycles in movemsrc_stall_count since
     those cycles have historically been handled as ordinary cycles.  */
  return limreg + 1;
}
#endif /* SPECIFIC_U_MOVEM_FN */

#endif /* WITH_PROFILE_MODEL_P */
@


1.13
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 1
a2 1
   Copyright (C) 2004-2012 Free Software Foundation, Inc.
@


1.12
log
@run copyright.sh for 2011.
@
text
@d2 1
a2 2
   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.12.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 1
   Copyright (C) 2004-2012 Free Software Foundation, Inc.
@


1.11
log
@Update copyright notices to add year 2010.
@
text
@d2 1
a2 1
   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010
@


1.10
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d2 1
a2 1
   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009
@


1.9
log
@	* cris/sim-main.h (struct _sim_cpu): New member
	set_target_thread_data.
	* cris/crisv32f.c (CRIS_TLS_REGISTER): Define.
	* cris/crisv10f.c: Ditto.
	* cris/cris-tmpl.c (MY (set_target_thread_data)): New function.
	(MY (f_specific_init)): Set new _sim_cpu member to new function.
	* cris/traps.c (TARGET_SYS_set_thread_area): Define.
	(cris_break_13_handler) <case TARGET_SYS_set_thread_area>: New
	case.
@
text
@d2 2
a3 1
   Copyright (C) 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.8
log
@	Updated copyright notices for most files.
@
text
@d236 8
d267 1
@


1.7
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d2 1
a2 1
   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
@


1.6
log
@Copyright updates for 2007.
@
text
@d9 2
a10 2
the Free Software Foundation; either version 2, or (at your option)
any later version.
d17 2
a18 3
You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.5
log
@	* cris/dv-cris.c, cris/dv-rv.c, cris/rvdummy.c: New files.
	* cris/Makefile.in (CONFIG_DEVICES): Remove redundant setting.
	(dv-cris.o, dv-rv.o rvdummy$(EXEEXT), rvdummy.o): New rules.
	(all): Depend on rvdummy$(EXEEXT).
	* cris/configure.ac: Call SIM_AC_OPTION_WARNINGS.  Check for
	sys/socket.h and sys/select.h.  Call SIM_AC_OPTION_HARDWARE,
	default off.
	* cris/configure: Regenerate.
	* cris/cris-sim.h (cris_have_900000xxif): Declare here.
	(enum cris_interrupt_type, crisv10deliver_interrupt)
	(crisv32deliver_interrupt: New declarations.
	* cris/cris-tmpl.c [WITH_HW] (MY (f_model_insn_after)): Call
	sim_events_tickn and set state-events member work_pending when it's
	time for the next event.
	[WITH_HW] (MY (f_specific_init)): Set CPU-model-specific
	interrupt-delivery function.
	* cris/crisv10f.c (MY (deliver_interrupt)): New function.
	* cris/crisv32f.c (MY (deliver_interrupt)): New function.
	* cris/devices.c: Include hw-device.h.
	(device_io_read_buffer) [WITH_HW]: Call hw_io_read_buffer.
	(device_io_write_buffer): Only perform 0x900000xx-functions if
	cris_have_900000xxif is nonzero.  Else if WITH_HW defined,
	call hw_io_write_buffer.  Add return 0 last in function.
	* cris/sim-if.c (cris_have_900000xxif): Now global.
	(sim_open) [WITH_HW]: Clear deliver_interrupt cpu member.
	Force "-model" option, effectively.
	* cris/sim-main.h (cris_interrupt_delivery_fn): New type.
	(struct _sim_cpu) [WITH_HW]: New member deliver_interrupt.
@
text
@d2 1
a2 1
   Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.
@


1.4
log
@Update Copyright years
@
text
@d181 12
d260 3
@


1.3
log
@	* cris/cris-tmpl.c (MY (f_model_insn_before)): Only display basic
	cycle count for the current insn.
@
text
@d2 1
a2 1
   Copyright (C) 2004, 2005 Free Software Foundation, Inc.
@


1.2
log
@	* cris/cris-tmpl.c (MY (f_model_insn_before)): Make sure only the
	low 32 bits are used after an unsigned long cast.
@
text
@d122 2
d143 7
d153 1
a153 9
			 (int)
			 ((CPU_CRIS_MISC_PROFILE (current_cpu)
			   ->basic_cycle_count
			   - CPU_CRIS_PREV_MISC_PROFILE (current_cpu)
			   ->basic_cycle_count)
			  + (CPU_CRIS_MISC_PROFILE (current_cpu)
			     ->unaligned_mem_dword_count
			     - CPU_CRIS_PREV_MISC_PROFILE (current_cpu)
			     ->unaligned_mem_dword_count)),
d160 1
a160 9
			 (int)
			 ((CPU_CRIS_MISC_PROFILE (current_cpu)
			   ->basic_cycle_count
			   - CPU_CRIS_PREV_MISC_PROFILE (current_cpu)
			   ->basic_cycle_count)
			  + (CPU_CRIS_MISC_PROFILE (current_cpu)
			     ->unaligned_mem_dword_count
			     - CPU_CRIS_PREV_MISC_PROFILE (current_cpu)
			     ->unaligned_mem_dword_count)));
@


1.1
log
@	* cris: New directory, simulator for Axis Communications CRIS
	including CRIS v32, CGEN-based.
	* configure.ac: Add corresponding configury.
	* configure: Regenerate.
@
text
@d124 2
a125 1
    cris_trace_printf (sd, current_cpu, "%lx ", (unsigned long) (CPU (h_pc)));
d129 4
a132 3
			 (unsigned long) (XCONCAT3(crisv,BASENUM,
						   f_h_gr_get) (current_cpu,
								i)));
d153 4
a156 3
			 (unsigned long) (XCONCAT3(crisv,BASENUM,
						   f_h_gr_get) (current_cpu,
								15)));
@

