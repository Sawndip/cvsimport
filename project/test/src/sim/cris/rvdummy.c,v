head	1.10;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.10
	gdb_7_6-2013-04-26-release:1.10
	gdb_7_6-branch:1.10.0.2
	gdb_7_6-2013-03-12-branchpoint:1.10
	gdb_7_5_1-2012-11-29-release:1.9
	gdb_7_5-2012-08-17-release:1.9
	gdb_7_5-branch:1.9.0.2
	gdb_7_5-2012-07-18-branchpoint:1.9
	gdb_7_4_1-2012-04-26-release:1.8.4.1
	gdb_7_4-2012-01-24-release:1.8.4.1
	gdb_7_4-branch:1.8.0.4
	gdb_7_4-2011-12-13-branchpoint:1.8
	gdb_7_3_1-2011-09-04-release:1.8
	gdb_7_3-2011-07-26-release:1.8
	gdb_7_3-branch:1.8.0.2
	gdb_7_3-2011-04-01-branchpoint:1.8
	gdb_7_2-2010-09-02-release:1.7
	gdb_7_2-branch:1.7.0.2
	gdb_7_2-2010-07-07-branchpoint:1.7
	gdb_7_1-2010-03-18-release:1.6
	gdb_7_1-branch:1.6.0.2
	gdb_7_1-2010-02-18-branchpoint:1.6
	gdb_7_0_1-2009-12-22-release:1.5
	gdb_7_0-2009-10-06-release:1.5
	gdb_7_0-branch:1.5.0.4
	gdb_7_0-2009-09-16-branchpoint:1.5
	arc-sim-20090309:1.4
	msnyder-checkpoint-072509-branch:1.5.0.2
	msnyder-checkpoint-072509-branchpoint:1.5
	arc-insight_6_8-branch:1.4.0.16
	arc-insight_6_8-branchpoint:1.4
	insight_6_8-branch:1.4.0.14
	insight_6_8-branchpoint:1.4
	reverse-20081226-branch:1.4.0.12
	reverse-20081226-branchpoint:1.4
	multiprocess-20081120-branch:1.4.0.10
	multiprocess-20081120-branchpoint:1.4
	reverse-20080930-branch:1.4.0.8
	reverse-20080930-branchpoint:1.4
	reverse-20080717-branch:1.4.0.6
	reverse-20080717-branchpoint:1.4
	msnyder-reverse-20080609-branch:1.4.0.4
	msnyder-reverse-20080609-branchpoint:1.4
	drow-reverse-20070409-branch:1.2.0.2
	drow-reverse-20070409-branchpoint:1.2
	gdb_6_8-2008-03-27-release:1.4
	gdb_6_8-branch:1.4.0.2
	gdb_6_8-2008-02-26-branchpoint:1.4
	gdb_6_7_1-2007-10-29-release:1.3
	gdb_6_7-2007-10-10-release:1.3
	gdb_6_7-branch:1.3.0.2
	gdb_6_7-2007-09-07-branchpoint:1.3
	insight_6_6-20070208-release:1.1
	gdb_6_6-2006-12-18-release:1.1
	gdb_6_6-branch:1.1.0.10
	gdb_6_6-2006-11-15-branchpoint:1.1
	insight_6_5-20061003-release:1.1
	nickrob-async-20060828-mergepoint:1.1
	gdb_6_5-20060621-release:1.1
	gdb_6_5-branch:1.1.0.8
	gdb_6_5-2006-05-14-branchpoint:1.1
	nickrob-async-20060513-branch:1.1.0.6
	nickrob-async-20060513-branchpoint:1.1
	msnyder-reverse-20060502-branch:1.1.0.4
	msnyder-reverse-20060502-branchpoint:1.1
	readline_5_1-import-branch:1.1.0.2
	readline_5_1-import-branchpoint:1.1;
locks; strict;
comment	@ * @;


1.10
date	2013.01.01.06.41.34;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2012.01.04.08.28.08;	author brobecke;	state Exp;
branches;
next	1.8;

1.8
date	2011.01.01.15.33.57;	author brobecke;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2010.05.26.22.40.24;	author sezero;	state Exp;
branches;
next	1.6;

1.6
date	2010.01.01.10.03.28;	author brobecke;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.14.10.53.06;	author brobecke;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.01.22.53.23;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2007.08.24.14.28.35;	author brobecke;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.09.17.59.16;	author drow;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.03.03.01.45;	author hp;	state Exp;
branches;
next	;

1.8.4.1
date	2012.01.06.04.54.42;	author brobecke;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* Test-driver for the remote-virtual-component simulator framework
   for GDB, the GNU Debugger.

   Copyright 2006-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* Avoid any problems whatsoever building this program if we're not
   also building hardware support.  */

#if !WITH_HW
int
main (int argc, char *argv[])
{
  return 2;
}
#else

#ifdef HAVE_CONFIG_H
#include "cconfig.h"
#include "tconfig.h"
#endif

#include "getopt.h"
#include "libiberty.h"

#define _GNU_SOURCE
#include <stdio.h>

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#endif

#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif

#ifdef HAVE_SYS_TIME_H
#include <sys/time.h>
#endif

#ifdef HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif

#ifdef HAVE_ERRNO_H
#include <errno.h>
#endif

/* Not guarded in dv-sockser.c, so why here.  */
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>

enum rv_command {
  RV_READ_CMD = 0,
  RV_WRITE_CMD = 1,
  RV_IRQ_CMD = 2,
  RV_MEM_RD_CMD = 3,
  RV_MEM_WR_CMD = 4,
  RV_MBOX_HANDLE_CMD = 5,
  RV_MBOX_PUT_CMD = 6,
  RV_WATCHDOG_CMD = 7
};

enum opts { OPT_PORT = 1, OPT_TIMEOUT, OPT_VERBOSE };

struct option longopts[] =
  {
    {"port", required_argument, NULL, OPT_PORT},
    {"timeout", required_argument, NULL, OPT_TIMEOUT},
    {"verbose", no_argument, NULL, OPT_VERBOSE},
    {NULL, 0, NULL, 0}
  };

int port = 10000;
time_t timeout = 30000;
char *progname = "(unknown)";
int verbose = 0;

/* Required forward-declarations.  */
static void handle_input_file (int, char *);

/* Set up a "server" listening to the port in PORT for a raw TCP
   connection.  Return a file descriptor for the connection or -1 on
   error.  */

int setupsocket (void)
{
  int s;
  socklen_t len;
  int reuse = 1;
  struct sockaddr_in sa_in;
  struct sockaddr_in from;

  len = sizeof (from);
  memset (&from, 0, len);
  memset (&sa_in, 0, sizeof (sa_in));

  s = socket (AF_INET, SOCK_STREAM, 0);
  if (s == -1)
    return -1;

  if (setsockopt (s, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof reuse) != 0)
    return -1;

  sa_in.sin_port = htons (port);
  sa_in.sin_family = AF_INET;

  if (bind (s, (struct sockaddr *) & sa_in, sizeof sa_in) < 0)
    return -1;

  if (listen (s, 1) < 0)
    return -1;

  return accept (s, (struct sockaddr *) &from, &len);
}

/* Basic host-to-little-endian 32-bit value.  Could use the BFD
   machinery, but let's avoid it for this only dependency.  */

static void
h2le32 (unsigned char *dest, unsigned int val)
{
  dest[0] = val & 255;
  dest[1] = (val >> 8) & 255;
  dest[2] = (val >> 16) & 255;
  dest[3] = (val >> 24) & 255;
}

/* Send a blob of data.  */

static void
send_output (int fd, unsigned char *buf, int nbytes)
{
  while (nbytes > 0)
    {
      ssize_t written = write (fd, buf, nbytes);
      if (written < 0)
	{
	  fprintf (stderr, "%s: write to socket failed: %s\n",
		  progname, strerror (errno));
	  exit (2);
	}
      nbytes -= written;
    }
}

/* Receive a blob of data, NBYTES large.  Compare to the first NCOMP
   bytes of BUF; if not a match, write error message to stderr and
   exit (2).  Else put it in buf.  */

static void
expect_input (int fd, unsigned char *buf, int nbytes, int ncomp)
{
  unsigned char byt;
  int i;

  for (i = 0; i < nbytes; i++)
    {
      int r;

      do
	{
	  errno = 0;
	  r = read (fd, &byt, 1);
	}
      while (r <= 0 && (r == 0 || errno == EAGAIN));

      if (r != 1)
	{
	  fprintf (stderr, "%s: read from socket failed: %s",
		  progname, strerror (errno));
	  exit (2);
	}

      if (i < ncomp && byt != buf[i])
	{
	  int j;
	  fprintf (stderr, "%s: unexpected input,\n ", progname);
	  if (i == 0)
	    fprintf (stderr, "nothing,");
	  else
	    for (j = 0; j < i; j++)
	      fprintf (stderr, "%02x", buf[j]);
	  fprintf (stderr, "\nthen %02x instead of %02x\n", byt, buf[i]);
	  exit (2);
	}
      else
	buf[i] = byt;
    }
}

/* Handle everything about a nil-terminated line of input.
   Call exit (2) on error with error text on stderr.  */

static void
handle_input (int fd, char *buf, char *fname, int lineno)
{
  int nbytes = 0;
  int n = -1;
  char *s = buf + 2;
  unsigned int data;
  static unsigned char bytes[1024];
  int i;

  memset (bytes, 0, sizeof bytes);
  lineno++;

  if (buf[1] != ',')
    goto syntax_error;

  switch (buf[0])
    {
      /* Comment characters and empty lines.  */
    case 0: case '!': case '#':
      break;

      /* Include another file.  */
    case '@@':
      handle_input_file (fd, s);
      break;

      /* Raw input (to be expected).  */
    case 'i':
      do
	{
	  n = -1;
	  sscanf (s, "%02x%n", &data, &n);
	  s += n;
	  if (n > 0)
	    bytes[nbytes++] = data;
	}
      while (n > 0);
      expect_input (fd, bytes, nbytes, nbytes);
      if (verbose)
	{
	  printf ("i,");
	  for (i = 0; i < nbytes; i++)
	    printf ("%02x", bytes[i]);
	  printf ("\n");
	}
      break;

      /* Raw output (to be written).  */
    case 'o':
      do
	{
	  n = -1;
	  sscanf (s, "%02x%n", &data, &n);
	  if (n > 0)
	    {
	      s += n;
	      bytes[nbytes++] = data;
	    }
	}
      while (n > 0);
      if (*s != 0)
	goto syntax_error;
      send_output (fd, bytes, nbytes);
      if (verbose)
	{
	  printf ("o,");
	  for (i = 0; i < nbytes; i++)
	    printf ("%02x", bytes[i]);
	  printf ("\n");
	}
      break;

      /* Read a register.  */
    case 'r':
      {
	unsigned int addr;
	sscanf (s, "%x,%x%n", &addr, &data, &n);
	if (n < 0 || s[n] != 0)
	  goto syntax_error;
	bytes[0] = 11;
	bytes[1] = 0;
	bytes[2] = RV_READ_CMD;
	h2le32 (bytes + 3, addr);
	expect_input (fd, bytes, 11, 7);
	h2le32 (bytes + 7, data);
	send_output (fd, bytes, 11);
	if (verbose)
	  printf ("r,%x,%x\n", addr, data);
      }
      break;

      /* Write a register.  */
    case 'w':
      {
	unsigned int addr;
	sscanf (s, "%x,%x%n", &addr, &data, &n);
	if (n < 0 || s[n] != 0)
	  goto syntax_error;
	bytes[0] = 11;
	bytes[1] = 0;
	bytes[2] = RV_WRITE_CMD;
	h2le32 (bytes + 3, addr);
	h2le32 (bytes + 7, data);
	expect_input (fd, bytes, 11, 11);
	send_output (fd, bytes, 11);
	if (verbose)
	  printf ("w,%x,%x\n", addr, data);
      }
      break;

      /* Wait for some milliseconds.  */
    case 't':
      {
	int del = 0;
	struct timeval to;
	sscanf (s, "%d%n", &del, &n);
	if (n < 0 || s[n] != 0 || del == 0)
	  goto syntax_error;

	to.tv_sec = del / 1000;
	to.tv_usec = (del % 1000) * 1000;

	if (select (0, NULL, NULL, NULL, &to) != 0)
	  {
	    fprintf (stderr, "%s: problem waiting for %d ms:\n %s\n",
		     progname, del, strerror (errno));
	    exit (2);
	  }
	if (verbose)
	  printf ("t,%d\n", del);
      }
      break;

      /* Expect a watchdog command.  */
    case 'W':
      if (*s != 0)
	goto syntax_error;
      bytes[0] = 3;
      bytes[1] = 0;
      bytes[2] = RV_WATCHDOG_CMD;
      expect_input (fd, bytes, 3, 3);
      if (verbose)
	printf ("W\n");
      break;

      /* Send an IRQ notification.  */
    case 'I':
      sscanf (s, "%x%n", &data, &n);
      if (n < 0 || s[n] != 0)
	goto syntax_error;
      bytes[0] = 7;
      bytes[1] = 0;
      bytes[2] = RV_IRQ_CMD;
      h2le32 (bytes + 3, data);
      send_output (fd, bytes, 7);
      if (verbose)
	printf ("I,%x\n", data);
      break;

      /* DMA store (to CPU).  */
    case 's':
      {
	unsigned int addr;
	sscanf (s, "%x,%n", &addr, &n);

	if (n < 0 || s[n] == 0)
	  goto syntax_error;
	s += n;
	do
	  {
	    n = -1;
	    sscanf (s, "%02x%n", &data, &n);
	    if (n > 0)
	      {
		s += n;
		bytes[11 + nbytes++] = data;
	      }
	  }
	while (n > 0);

	if (*s != 0)
	  goto syntax_error;
	h2le32 (bytes, nbytes + 11);
	bytes[2] = RV_MEM_WR_CMD;
	h2le32 (bytes + 3, addr);
	h2le32 (bytes + 7, nbytes);
	send_output (fd, bytes, nbytes + 11);
	if (verbose)
	  {
	    printf ("s,%x,", addr);
	    for (i = 0; i < nbytes; i++)
	      printf ("%02x", bytes[i]);
	    printf ("\n");
	  }
      }
      break;

      /* DMA load (from CPU).  */
    case 'l':
      {
	unsigned int addr;
	sscanf (s, "%x,%n", &addr, &n);

	if (n < 0 || s[n] == 0)
	  goto syntax_error;
	s += n;
	do
	  {
	    n = -1;
	    sscanf (s, "%02x%n", &data, &n);
	    if (n > 0)
	      {
		s += n;
		bytes[11 + nbytes++] = data;
	      }
	  }
	while (n > 0);

	if (*s != 0)
	  goto syntax_error;
	h2le32 (bytes, nbytes + 11);
	bytes[0] = 11;
	bytes[1] = 0;
	bytes[2] = RV_MEM_RD_CMD;
	h2le32 (bytes + 3, addr);
	h2le32 (bytes + 7, nbytes);
	send_output (fd, bytes, 11);
	bytes[0] = (nbytes + 11) & 255;
	bytes[1] = ((nbytes + 11) >> 8) & 255;
	expect_input (fd, bytes, nbytes + 11, nbytes + 11);
	if (verbose)
	  {
	    printf ("l,%x,", addr);
	    for (i = 0; i < nbytes; i++)
	      printf ("%02x", bytes[i]);
	    printf ("\n");
	  }
      }
      break;

    syntax_error:
    default:
      fprintf (stderr, "%s: invalid command line in %s:%d:\n %s",
	       progname, fname, lineno, strerror (errno));
      exit (2);
    }
}

/* Loop over the contents of FNAME, using handle_input to parse each line.
   Errors to stderr, exit (2).  */

static void
handle_input_file (int fd, char *fname)
{
  static char buf[2048] = {0};
  int lineno = 0;
  FILE *f = fopen (fname, "r");

  if (f == NULL)
    {
      fprintf (stderr, "%s: problem opening %s: %s\n",
	       progname, fname, strerror (errno));
      exit (2);
    }

  /* Let's cut the buffer short, so we always get a newline.  */
  while (fgets (buf, sizeof (buf) - 1, f) != NULL)
    {
      buf[strlen (buf) - 1] = 0;
      lineno++;
      handle_input (fd, buf, fname, lineno);
    }

  fclose (f);
}

int
main (int argc, char *argv[])
{
  int optc;
  int fd;
  FILE *f;
  int i;

  progname = argv[0];
  while ((optc = getopt_long (argc, argv, "", longopts, NULL)) != -1)
    switch (optc)
      {
      case OPT_PORT:
	port = atoi (optarg);
	break;

      case OPT_TIMEOUT:
	timeout = (time_t) atoi (optarg);
	break;

      case OPT_VERBOSE:
	verbose = 1;
	break;
      }

  fd = setupsocket ();
  if (fd == -1)
    {
      fprintf (stderr, "%s: problem setting up the connection: %s\n",
	       progname, strerror (errno));
      exit (2);
    }

  for (i = optind; i < argc; i++)
    handle_input_file (fd, argv[i]);

  /* FIXME: option-controlled test for remaining input?  */
  close (fd);
  return 1;
}
#endif
@


1.9
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d4 1
a4 1
   Copyright 2006-2012 Free Software Foundation, Inc.
@


1.8
log
@run copyright.sh for 2011.
@
text
@d4 1
a4 1
   Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.8.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d4 1
a4 1
   Copyright 2006-2012 Free Software Foundation, Inc.
@


1.7
log
@2010-05-26  Ozkan Sezer  <sezeroz@@gmail.com>

gdb/
	* ser-tcp.c (net_open): Check error return from socket() call by its
	equality to -1 not by it being negative.
	(net_close): Likewise.

gdb/gdbserver/
	* gdbreplay.c (remote_open): Check error return from socket() call by
	its equality to -1 not by it being negative.
	* remote-utils.c (remote_open): Likewise.

sim/arm/
	* communicate.c (MYread_char): Check error return from accept() call
	by its equality to -1 not by it being negative.
	(MYread_charwait): Likewise.
	* main.c (main): Likewise for both socket() and accept() calls.

sim/common/
	* dv-sockser.c (dv_sockser_init): Check error return from socket()
	call by its equality to -1 not by it being negative.
	(connected_p): Likewise for accept() call.

sim/cris/
	* dv-rv.c (hw_rv_init_socket): Check error return from socket() call
	by its equality to -1 not by it being negative.
	(hw_rv_write): Likewise.
	(hw_rv_handle_incoming): Likewise.
	(hw_rv_poll_once): Likewise.
	* rvdummy.c (setupsocket): Likewise.
	(main): Likewise for accept() call as returned from setupsocket().

sim/m32c/
	* main.c (setup_tcp_console): Check error return from socket() call
	by its equality to -1 not by it being negative.
@
text
@d4 1
a4 1
   Copyright 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.6
log
@Update copyright notices to add year 2010.
@
text
@d121 1
a121 1
  if (s < 0)
d520 1
a520 1
  if (fd < 0)
@


1.5
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d4 1
a4 1
   Copyright 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.4
log
@	Updated copyright notices for most files.
@
text
@d4 1
a4 1
   Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.3
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d4 1
a4 1
   Copyright 2006, 2007 Free Software Foundation, Inc.
@


1.2
log
@Copyright updates for 2007.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.1
log
@	* cris/dv-cris.c, cris/dv-rv.c, cris/rvdummy.c: New files.
	* cris/Makefile.in (CONFIG_DEVICES): Remove redundant setting.
	(dv-cris.o, dv-rv.o rvdummy$(EXEEXT), rvdummy.o): New rules.
	(all): Depend on rvdummy$(EXEEXT).
	* cris/configure.ac: Call SIM_AC_OPTION_WARNINGS.  Check for
	sys/socket.h and sys/select.h.  Call SIM_AC_OPTION_HARDWARE,
	default off.
	* cris/configure: Regenerate.
	* cris/cris-sim.h (cris_have_900000xxif): Declare here.
	(enum cris_interrupt_type, crisv10deliver_interrupt)
	(crisv32deliver_interrupt: New declarations.
	* cris/cris-tmpl.c [WITH_HW] (MY (f_model_insn_after)): Call
	sim_events_tickn and set state-events member work_pending when it's
	time for the next event.
	[WITH_HW] (MY (f_specific_init)): Set CPU-model-specific
	interrupt-delivery function.
	* cris/crisv10f.c (MY (deliver_interrupt)): New function.
	* cris/crisv32f.c (MY (deliver_interrupt)): New function.
	* cris/devices.c: Include hw-device.h.
	(device_io_read_buffer) [WITH_HW]: Call hw_io_read_buffer.
	(device_io_write_buffer): Only perform 0x900000xx-functions if
	cris_have_900000xxif is nonzero.  Else if WITH_HW defined,
	call hw_io_write_buffer.  Add return 0 last in function.
	* cris/sim-if.c (cris_have_900000xxif): Now global.
	(sim_open) [WITH_HW]: Clear deliver_interrupt cpu member.
	Force "-model" option, effectively.
	* cris/sim-main.h (cris_interrupt_delivery_fn): New type.
	(struct _sim_cpu) [WITH_HW]: New member deliver_interrupt.
@
text
@d4 1
a4 1
   Copyright 2006 Free Software Foundation, Inc.
@

