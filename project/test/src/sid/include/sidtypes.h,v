head	1.4;
access;
symbols
	sid-snapshot-20180601:1.4
	sid-snapshot-20180501:1.4
	sid-snapshot-20180401:1.4
	sid-snapshot-20180301:1.4
	sid-snapshot-20180201:1.4
	sid-snapshot-20180101:1.4
	sid-snapshot-20171201:1.4
	sid-snapshot-20171101:1.4
	sid-snapshot-20171001:1.4
	sid-snapshot-20170901:1.4
	sid-snapshot-20170801:1.4
	sid-snapshot-20170701:1.4
	sid-snapshot-20170601:1.4
	sid-snapshot-20170501:1.4
	sid-snapshot-20170401:1.4
	sid-snapshot-20170301:1.4
	sid-snapshot-20170201:1.4
	sid-snapshot-20170101:1.4
	sid-snapshot-20161201:1.4
	sid-snapshot-20161101:1.4
	sid-snapshot-20160901:1.4
	sid-snapshot-20160801:1.4
	sid-snapshot-20160701:1.4
	sid-snapshot-20160601:1.4
	sid-snapshot-20160501:1.4
	sid-snapshot-20160401:1.4
	sid-snapshot-20160301:1.4
	sid-snapshot-20160201:1.4
	sid-snapshot-20160101:1.4
	sid-snapshot-20151201:1.4
	sid-snapshot-20151101:1.4
	sid-snapshot-20151001:1.4
	sid-snapshot-20150901:1.4
	sid-snapshot-20150801:1.4
	sid-snapshot-20150701:1.4
	sid-snapshot-20150601:1.4
	sid-snapshot-20150501:1.4
	sid-snapshot-20150401:1.4
	sid-snapshot-20150301:1.4
	sid-snapshot-20150201:1.4
	sid-snapshot-20150101:1.4
	sid-snapshot-20141201:1.4
	sid-snapshot-20141101:1.4
	sid-snapshot-20141001:1.4
	sid-snapshot-20140901:1.4
	sid-snapshot-20140801:1.4
	sid-snapshot-20140701:1.4
	sid-snapshot-20140601:1.4
	sid-snapshot-20140501:1.4
	sid-snapshot-20140401:1.4
	sid-snapshot-20140301:1.4
	sid-snapshot-20140201:1.4
	sid-snapshot-20140101:1.4
	sid-snapshot-20131201:1.4
	sid-snapshot-20131101:1.4
	sid-snapshot-20131001:1.4
	sid-snapshot-20130901:1.4
	sid-snapshot-20130801:1.4
	sid-snapshot-20130701:1.4
	sid-snapshot-20130601:1.4
	sid-snapshot-20130501:1.4
	sid-snapshot-20130401:1.4
	sid-snapshot-20130301:1.4
	sid-snapshot-20130201:1.4
	sid-snapshot-20130101:1.4
	sid-snapshot-20121201:1.4
	sid-snapshot-20121101:1.4
	sid-snapshot-20121001:1.4
	sid-snapshot-20120901:1.4
	sid-snapshot-20120801:1.4
	sid-snapshot-20120701:1.4
	sid-snapshot-20120601:1.4
	sid-snapshot-20120501:1.4
	sid-snapshot-20120401:1.4
	sid-snapshot-20120301:1.4
	sid-snapshot-20120201:1.4
	sid-snapshot-20120101:1.4
	sid-snapshot-20111201:1.4
	sid-snapshot-20111101:1.4
	sid-snapshot-20111001:1.4
	sid-snapshot-20110901:1.4
	sid-snapshot-20110801:1.4
	sid-snapshot-20110701:1.4
	sid-snapshot-20110601:1.4
	sid-snapshot-20110501:1.4
	sid-snapshot-20110401:1.4
	sid-snapshot-20110301:1.4
	sid-snapshot-20110201:1.4
	sid-snapshot-20110101:1.4
	sid-snapshot-20101201:1.4
	sid-snapshot-20101101:1.4
	sid-snapshot-20101001:1.4
	sid-snapshot-20100901:1.4
	sid-snapshot-20100801:1.4
	sid-snapshot-20100701:1.4
	sid-snapshot-20100601:1.4
	sid-snapshot-20100501:1.4
	sid-snapshot-20100401:1.4
	sid-snapshot-20100301:1.4
	sid-snapshot-20100201:1.4
	sid-snapshot-20100101:1.4
	sid-snapshot-20091201:1.4
	sid-snapshot-20091101:1.4
	sid-snapshot-20091001:1.4
	sid-snapshot-20090901:1.4
	sid-snapshot-20090801:1.4
	sid-snapshot-20090701:1.4
	sid-snapshot-20090601:1.4
	sid-snapshot-20090501:1.4
	sid-snapshot-20090401:1.4
	sid-snapshot-20090301:1.4
	sid-snapshot-20090201:1.4
	sid-snapshot-20090101:1.4
	sid-snapshot-20081201:1.4
	sid-snapshot-20081101:1.4
	sid-snapshot-20081001:1.4
	sid-snapshot-20080901:1.4
	sid-snapshot-20080801:1.4
	sid-snapshot-20080701:1.4
	sid-snapshot-20080601:1.4
	sid-snapshot-20080501:1.4
	sid-snapshot-20080403:1.4
	sid-snapshot-20080401:1.4
	sid-snapshot-20080301:1.4
	sid-snapshot-20080201:1.4
	sid-snapshot-20080101:1.4
	sid-snapshot-20071201:1.4
	sid-snapshot-20071101:1.4
	sid-snapshot-20071001:1.4
	sid-20020905-branchpoint:1.1
	sid-20020905-branch:1.1.0.2
	cygnus_cvs_20020108_pre:1.1;
locks; strict;
comment	@ * @;


1.4
date	2005.01.27.14.00.52;	author fche;	state Exp;
branches;
next	1.3;

1.3
date	2004.12.16.21.16.35;	author jimb;	state Exp;
branches;
next	1.2;

1.2
date	2004.12.15.20.07.10;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.07.19.31.09;	author fche;	state Exp;
branches;
next	;


desc
@@


1.4
log
@2005-01-26  Thiemo Seufer  <seufer@@csv.ica.uni-stuttgart.de>

	* sidtypes.h (HOST_BIG_ENDIAN): Add support for both MIPS
	endiannesses.
@
text
@// sidtypes.h - Different data types and automatic conversions between
// them (for example, big and little endian integrals).  -*- C++ -*-

// Copyright (C) 1999, 2000 Red Hat.
// This file is part of SID and is licensed under the GPL.
// See the file COPYING.SID for conditions for redistribution.

#ifndef SIDTYPES_H
#define SIDTYPES_H

#include <iostream>
#include <iomanip>
#include <cassert>

// In order to make the sid core header files host-independent,
// host-specific (autoconf-generated) headers are not #included here.
// Instead, we use a handful of compiler-provided macros to determine
// some key platform parameters.

#if defined(__NetBSD__)
# include <machine/endian.h>
# if BYTE_ORDER == LITTLE_ENDIAN
#  define HOST_BIG_ENDIAN false
# else
#  define HOST_BIG_ENDIAN true
# endif
#else
# if defined(__i386__) || defined(__x86_64__) || defined(__alpha__) || (defined(__mips__) && defined(_MIPSEL))
#  define HOST_BIG_ENDIAN false
# elif defined(__sparc__) || defined(__powerpc__) || (defined(__mips__) && defined(_MIPSEB))
#  define HOST_BIG_ENDIAN true
# else
#  error "Unknown host platform"
# endif
#endif


namespace sid {
  // XXX: Define these conditionally.
  typedef unsigned char host_int_1;
  typedef unsigned short host_int_2;
  typedef unsigned int host_int_4;
  typedef unsigned long long host_int_8;
  typedef signed char signed_host_int_1;
  typedef signed short signed_host_int_2;
  typedef signed int signed_host_int_4;
  typedef signed long long signed_host_int_8;



  
  // The following bytereverse functions are used to convert between
  // big-endian and little-endian integers.

  inline host_int_1
  bytereverse(host_int_1 value)
  {
    return value;
  }

  inline host_int_2
  bytereverse(host_int_2 value)
  {
    // This is a 386 instruction.
#if defined(__GNUC__) && (defined(__i386__) || defined (__x86_64__))
    __asm__("xchgb %b0,%h0" : "=q" (value) :  "0" (value));
#else
      value = ( ((value & 0xff00U) >> 8) 
	      | ((value & 0x00ffU) << 8));
#endif
    return value;
  }

  inline host_int_4
  bytereverse(host_int_4 value)
  {
#if defined(__GNUC__) && (defined(__i486__) || defined(__i586__) || defined(__i686__) || defined (__x86_64__))
    // This is a 486+ instruction
      __asm__ ("bswap %0" : "=r" (value) : "0" (value));
#else
      value = ( ((value & 0xff000000UL) >> 24)
	      | ((value & 0x00ff0000UL) >> 8)
	      | ((value & 0x0000ff00UL) << 8)
	      | ((value & 0x000000ffUL) << 24));
#endif
    return value;
  }

  inline host_int_8
  bytereverse(host_int_8 value)
  {
#if defined (__GNUC__) && defined (__x86_64__)
    // This is an x86_64 instruction.
    __asm__ ("bswap %0" : "=r" (value) : "0" (value));
#else
    host_int_4 upper = (value & 0xffffffff00000000ULL) >> 32;
    host_int_4 lower = (value & 0x00000000ffffffffULL);
    upper = bytereverse(upper);
    lower = bytereverse(lower);
    value = ((host_int_8)lower) << 32 | (host_int_8)upper;
#endif
    return value;
  }


  // A bi-endian integer class.
  // 
  // Each instance represents an integer quanitity, with an additional
  // tag that describes how that value should be stored in simulated
  // memory.
  //
  // The template class any_int<> should not be used directly.
  // Rather, use one of the typedef'd classes:
  // big_int_1, big_int_2, big_int_4, big_int_8
  // little_int_1, little_int_2, little_int_4, or little_int_8

  template <typename IntType, bool IsBig>
  class any_int
  {
  public:
    // Utility related types
    typedef IntType value_type;
    typedef any_int<IntType,HOST_BIG_ENDIAN> host_int_type;
    typedef any_int<host_int_1,IsBig> size_1_type;
    typedef any_int<host_int_2,IsBig> size_2_type;
    typedef any_int<host_int_4,IsBig> size_4_type;
    typedef any_int<host_int_8,IsBig> size_8_type;


    // Return the natural integer value represented by this object.
    // This value is the same, whether this class represents a big or
    // little endian value.
    IntType integer_value() const { return _integer_value; }
    operator IntType () const { return _integer_value; }
    
    // Return the simulated memory image of this value.  This may be
    // a byte-reversed copy of integer_value().
    IntType target_memory_value() const
      {
	if (IsBig == HOST_BIG_ENDIAN)
	  return this->_integer_value;
	else
	  return bytereverse (_integer_value);
      }

    // Set the simulated memory image of this value.  It may be
    // byte-reversed.
    void set_target_memory_value(IntType v)
      {
	if (IsBig == HOST_BIG_ENDIAN)
	  this->_integer_value = v;
	else
	  this->_integer_value = bytereverse(v);
      }



    // The default constructor constructs an object with value 0. 
    any_int(): _integer_value (0) {}

    // Construct from a big_int type.
    // Copies the integer_value.  Regardless of types, the value is
    // NOT byte-reversed by this call.
    // v is the big_int value to construct the new object from. 
    any_int(const any_int<IntType,true>& v): _integer_value (v.integer_value()) {}
 
    // Construct from a little_int type.
    // Copies the integer_value.  Regardless of types, the value is
    // NOT byte-reversed by this call.
    // v is the little_int value to construct the new object from.
    any_int(const any_int<IntType,false>& v): _integer_value (v.integer_value()) {}

    // Construct from a integer type.
    // The new object's integer_value() method will return `v'.
    // v is the integer value to construct the new object from. 
    any_int(IntType v): _integer_value(v) {}


    // Assign from a little_int type.
    // Copies the integer_value.  Regardless of types, the value is
    // NOT byte-reversed by this call.
    // v is the little_int value to be assigned from.
    any_int<IntType,IsBig>& operator = (const any_int<IntType,false>& v)
      {
	_integer_value = v.integer_value();
	return *this;
      }

    // Assign from a big_int type.
    // Copies the integer_value.  Regardless of types, the value is 
    // NOT byte-reversed by this call.
    // v is the little_int value to be assigned from.
    any_int<IntType,IsBig>& operator = (const any_int<IntType,true>& v)
      {
	_integer_value = v.integer_value();
	return *this;
      }
    
    // Assign from a integer type.
    // The new object's integer_value() method will return `v'.
    // v is the integer value to construct the new object from. 
    any_int<IntType,IsBig>& operator = (IntType v) {
      _integer_value = v;
      return *this;
    }

    // These functions access the stored value as if it was a byte array.

    // Write byte at offset ix in target memory image.
    // ix is the index of the byte in the in-memory image.
    // byte is the value to write.
    void write_byte(unsigned ix, host_int_1 byte)
      {
	assert (0 <= ix && ix < sizeof(IntType));
	char* value_ptr = reinterpret_cast<char*>(&this->_integer_value);
	if (IsBig != HOST_BIG_ENDIAN) {
	  value_ptr[(sizeof(IntType)-1)-ix] = byte;
	} else {
	  value_ptr[ix] = byte;
	}
      }

    // Read byte at offset ix from the target memory image.
    // ix is the index of the byte in the in-memory image.
    // Returns the value of the byte.
    host_int_1 read_byte(unsigned ix) const
      {
	assert (0 <= ix && ix < sizeof(IntType));
	const char* value_ptr = reinterpret_cast<const char*>(&this->_integer_value);
	if (IsBig != HOST_BIG_ENDIAN) {
	  return value_ptr[(sizeof(IntType)-1)-ix];
	} else {
	  return value_ptr[ix];
	}
      }

  private:
    IntType _integer_value;
  };


// ----------------------------------------------------------------------------


  // Stream any_int using current stream flags
  template <typename IntType, bool IsBig>
  inline std::ostream&
  operator << (std::ostream& o, const any_int<IntType,IsBig>& v)
  {
    host_int_8 value;
    value = v; 
    o << value;
    return o;
  }


  // Destream any_int using current stream flags
  template <typename IntType, bool IsBig>
  inline std::istream&
  operator >> (std::istream& i, any_int<IntType,IsBig>& v)
  {
    host_int_8 value;
    i >> value;
    v = (IntType) value;
    // XXX: range check?
    return i;
  }



// ----------------------------------------------------------------------------


  // A series of big-endian quantities: 1-8 bytes.
  typedef any_int<host_int_1,true> big_int_1;
  typedef any_int<host_int_2,true> big_int_2;
  typedef any_int<host_int_4,true> big_int_4;
  typedef any_int<host_int_8,true> big_int_8;
  

  // A series of little-endian quantities: 1-8 bytes.
  typedef any_int<host_int_1,false> little_int_1;
  typedef any_int<host_int_2,false> little_int_2;
  typedef any_int<host_int_4,false> little_int_4;
  typedef any_int<host_int_8,false> little_int_8;
}

#endif // SIDTYPES_H
@


1.3
log
@* sidtypes.h: (bytereverse (host_int_2)): The x86-64 has an
xchgb instruction, too.
(bytereverse (host_int_4)): The x86-64 has a bswap instruction, too.
(bytereverse (host_int_8)): Use bswap on the x86-64.
@
text
@d28 1
a28 1
# if defined(__i386__) || defined(__x86_64__) || defined(__alpha__) 
d30 1
a30 1
# elif defined(__sparc__) || defined(__powerpc__)
@


1.2
log
@2004-12-09  Jim Blandy  <jimb@@redhat.com>

	* sidtypes.h: Recognize AMD64 (x86-64) as a little-endian machine.
@
text
@d65 1
a65 1
#if defined(__i386__) && defined(__GNUC__)
d77 1
a77 1
#if defined(__GNUC__) && (defined(__i486__) || defined(__i586__) || defined(__i686__))
d92 4
d101 1
@


1.1
log
@* public snapshot of sid simulator
@
text
@d28 1
a28 1
# if defined(__i386__) || defined(__alpha__)
@

