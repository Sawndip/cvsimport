head	1.41;
access;
symbols
	sid-snapshot-20180601:1.41
	sid-snapshot-20180501:1.41
	sid-snapshot-20180401:1.41
	sid-snapshot-20180301:1.41
	sid-snapshot-20180201:1.41
	sid-snapshot-20180101:1.41
	sid-snapshot-20171201:1.41
	sid-snapshot-20171101:1.41
	sid-snapshot-20171001:1.41
	sid-snapshot-20170901:1.41
	sid-snapshot-20170801:1.41
	sid-snapshot-20170701:1.41
	sid-snapshot-20170601:1.41
	sid-snapshot-20170501:1.41
	sid-snapshot-20170401:1.41
	sid-snapshot-20170301:1.41
	sid-snapshot-20170201:1.41
	sid-snapshot-20170101:1.41
	sid-snapshot-20161201:1.41
	sid-snapshot-20161101:1.41
	sid-snapshot-20160901:1.41
	sid-snapshot-20160801:1.41
	sid-snapshot-20160701:1.41
	sid-snapshot-20160601:1.41
	sid-snapshot-20160501:1.41
	sid-snapshot-20160401:1.41
	sid-snapshot-20160301:1.41
	sid-snapshot-20160201:1.41
	sid-snapshot-20160101:1.41
	sid-snapshot-20151201:1.41
	sid-snapshot-20151101:1.41
	sid-snapshot-20151001:1.41
	sid-snapshot-20150901:1.41
	sid-snapshot-20150801:1.41
	sid-snapshot-20150701:1.41
	sid-snapshot-20150601:1.41
	sid-snapshot-20150501:1.41
	sid-snapshot-20150401:1.41
	sid-snapshot-20150301:1.41
	sid-snapshot-20150201:1.41
	sid-snapshot-20150101:1.41
	sid-snapshot-20141201:1.41
	sid-snapshot-20141101:1.41
	sid-snapshot-20141001:1.41
	sid-snapshot-20140901:1.41
	sid-snapshot-20140801:1.41
	sid-snapshot-20140701:1.41
	sid-snapshot-20140601:1.41
	sid-snapshot-20140501:1.41
	sid-snapshot-20140401:1.41
	sid-snapshot-20140301:1.41
	sid-snapshot-20140201:1.41
	sid-snapshot-20140101:1.41
	sid-snapshot-20131201:1.41
	sid-snapshot-20131101:1.41
	sid-snapshot-20131001:1.41
	sid-snapshot-20130901:1.41
	sid-snapshot-20130801:1.41
	sid-snapshot-20130701:1.41
	sid-snapshot-20130601:1.41
	sid-snapshot-20130501:1.41
	sid-snapshot-20130401:1.41
	sid-snapshot-20130301:1.41
	sid-snapshot-20130201:1.41
	sid-snapshot-20130101:1.41
	sid-snapshot-20121201:1.41
	sid-snapshot-20121101:1.41
	sid-snapshot-20121001:1.41
	sid-snapshot-20120901:1.41
	sid-snapshot-20120801:1.41
	sid-snapshot-20120701:1.41
	sid-snapshot-20120601:1.41
	sid-snapshot-20120501:1.41
	sid-snapshot-20120401:1.41
	sid-snapshot-20120301:1.41
	sid-snapshot-20120201:1.41
	sid-snapshot-20120101:1.41
	sid-snapshot-20111201:1.41
	sid-snapshot-20111101:1.41
	sid-snapshot-20111001:1.41
	sid-snapshot-20110901:1.41
	sid-snapshot-20110801:1.41
	sid-snapshot-20110701:1.41
	sid-snapshot-20110601:1.41
	sid-snapshot-20110501:1.41
	sid-snapshot-20110401:1.41
	sid-snapshot-20110301:1.41
	sid-snapshot-20110201:1.41
	sid-snapshot-20110101:1.41
	sid-snapshot-20101201:1.41
	sid-snapshot-20101101:1.41
	sid-snapshot-20101001:1.41
	sid-snapshot-20100901:1.41
	sid-snapshot-20100801:1.41
	sid-snapshot-20100701:1.41
	sid-snapshot-20100601:1.41
	sid-snapshot-20100501:1.41
	sid-snapshot-20100401:1.41
	sid-snapshot-20100301:1.41
	sid-snapshot-20100201:1.41
	sid-snapshot-20100101:1.41
	sid-snapshot-20091201:1.41
	sid-snapshot-20091101:1.41
	sid-snapshot-20091001:1.41
	sid-snapshot-20090901:1.41
	sid-snapshot-20090801:1.41
	sid-snapshot-20090701:1.41
	sid-snapshot-20090601:1.41
	sid-snapshot-20090501:1.41
	sid-snapshot-20090401:1.41
	sid-snapshot-20090301:1.41
	sid-snapshot-20090201:1.41
	sid-snapshot-20090101:1.41
	sid-snapshot-20081201:1.41
	sid-snapshot-20081101:1.41
	sid-snapshot-20081001:1.41
	sid-snapshot-20080901:1.41
	sid-snapshot-20080801:1.41
	sid-snapshot-20080701:1.41
	sid-snapshot-20080601:1.40
	sid-snapshot-20080501:1.40
	sid-snapshot-20080403:1.40
	sid-snapshot-20080401:1.40
	sid-snapshot-20080301:1.40
	sid-snapshot-20080201:1.40
	sid-snapshot-20080101:1.40
	sid-snapshot-20071201:1.40
	sid-snapshot-20071101:1.40
	sid-snapshot-20071001:1.40
	sid-20020905-branchpoint:1.19
	sid-20020905-branch:1.19.0.2
	cygnus_cvs_20020108_pre:1.16;
locks; strict;
comment	@ * @;


1.41
date	2008.06.17.18.11.01;	author brolley;	state Exp;
branches;
next	1.40;

1.40
date	2007.02.05.20.28.42;	author brolley;	state Exp;
branches;
next	1.39;

1.39
date	2006.09.27.20.28.21;	author brolley;	state Exp;
branches;
next	1.38;

1.38
date	2006.06.26.21.04.00;	author brolley;	state Exp;
branches;
next	1.37;

1.37
date	2006.06.20.18.13.45;	author brolley;	state Exp;
branches;
next	1.36;

1.36
date	2006.06.14.20.39.31;	author brolley;	state Exp;
branches;
next	1.35;

1.35
date	2006.05.11.19.29.51;	author brolley;	state Exp;
branches;
next	1.34;

1.34
date	2006.03.27.20.30.06;	author fche;	state Exp;
branches;
next	1.33;

1.33
date	2005.11.14.20.05.16;	author brolley;	state Exp;
branches;
next	1.32;

1.32
date	2005.08.23.21.09.24;	author brolley;	state Exp;
branches;
next	1.31;

1.31
date	2005.08.19.19.47.44;	author brolley;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.10.15.48.22;	author brolley;	state Exp;
branches;
next	1.29;

1.29
date	2004.06.29.19.10.41;	author scox;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.22.21.28.19;	author brolley;	state Exp;
branches;
next	1.27;

1.27
date	2003.10.21.21.38.24;	author brolley;	state Exp;
branches;
next	1.26;

1.26
date	2003.08.29.19.27.05;	author brolley;	state Exp;
branches;
next	1.25;

1.25
date	2003.04.16.18.15.16;	author brolley;	state Exp;
branches;
next	1.24;

1.24
date	2003.01.15.20.03.34;	author brolley;	state Exp;
branches;
next	1.23;

1.23
date	2002.11.29.05.52.42;	author bje;	state Exp;
branches;
next	1.22;

1.22
date	2002.11.22.20.35.00;	author fche;	state Exp;
branches;
next	1.21;

1.21
date	2002.11.11.22.28.29;	author fche;	state Exp;
branches;
next	1.20;

1.20
date	2002.10.03.21.00.49;	author brolley;	state Exp;
branches;
next	1.19;

1.19
date	2002.04.23.21.00.33;	author bje;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.00.16.27;	author bje;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.12.21.58.57;	author fche;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.28.21.16.49;	author fche;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.27.22.59.14;	author fitzsim;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.08.21.55.12;	author fche;	state Exp;
branches;
next	1.13;

1.13
date	2001.10.04.17.28.44;	author fche;	state Exp;
branches;
next	1.12;

1.12
date	2001.10.04.16.50.11;	author fche;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.04.10.26.51;	author bje;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.03.06.02.48;	author mrg;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.12.11.37.32;	author mrg;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.06.08.14.57;	author bje;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.25.00.26.28;	author bje;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.30.19.27.51;	author fche;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.00.00.40;	author bje;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.26.22.35.39;	author brolley;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.01.19.15.35;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.10.19.41.01;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.07.19.31.09;	author fche;	state Exp;
branches;
next	;


desc
@@


1.41
log
@2008-06-17  Dave Brolley  <brolley@@redhat.com>

        * sidmiscutil.h (change_log): New utility class.
        * sidcpuutil.h (basic_cpu): Now inherits from reversible_component.
        (step_pin_handler): Parameter now named 'tick'. Save the current
        tick. Handle exec_direction == "backward". Initialize change logging,
        if reversible. Finish change logging, if reversible.
        (step_backward): New method of basic_cpu.
        (reset_pin_handler): Terminte the current change log, if any.
        Set exec_direction to "forward".
        (change_log,change_log_begin,change_log_end,change_log_boundaries)
        (change_string,exec_direction,sim_sched,current_tick,last_tick): New
        members of basic_cpu.
        (init_change_logging,finish_change_logging,log_change)
        (restore_state_to_time): New virtual methods of basic_cpu.
        (basic_cpu): Initialize change_log, change_log_begin,
        change_log_end, change_log_boundaries, last_tick, exec_direction,
        and sim_sched. Add the exec-direction and sim-sched attributes.
        * sidattrutil.h (reversible_component): New mix-in class.
@
text
@// sidcpuutil.h - Elements common to CPU models.  -*- C++ -*-

// Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 Red Hat.
// This file is part of SID and is licensed under the GPL.
// See the file COPYING.SID for conditions for redistribution.

#ifndef SIDCPUUTIL_H
#define SIDCPUUTIL_H

#include <sidattrutil.h>
#include <sidpinutil.h>
#include <sidbusutil.h>
#include <sidcomputil.h>
#include <sidmiscutil.h>
#include <sidwatchutil.h>
#include <sidschedutil.h>

using std::string;
using std::pair;

namespace sidutil
{
  // kinds of endianness
  enum endian 
  {
    endian_unknown = 0,
    endian_big = 1,
    endian_little = 2
  };
  
  inline
    std::ostream& operator << (std::ostream& o, const endian& e)
      {
	switch (e) 
	  {
	  default: 
	  case endian_unknown: o << "unknown"; break;
	  case endian_big: o << "big"; break;
	  case endian_little: o << "little"; break;
	  }
	return o;
      }
  
  
  inline
    std::istream& operator >> (std::istream& i, endian& e)
      {
	std::string s;
	i >> s;
	if (s == "unknown" || s == "0") { e = endian_unknown; }
	else if (s == "big" || s == "1") { e = endian_big; }
	else if (s == "little" || s == "2") { e = endian_little; }
	else { i.setstate(std::ios::badbit); e = endian_unknown; }
	return i;
      }

  // ------------------------------------------------------------------------

  class cpu_exception {};

  class cpu_memory_fault: public cpu_exception
  {
  public:
    sid::host_int_4 pc;
    sid::host_int_4 address;
    sid::bus::status status;
    const char* operation;
    
    cpu_memory_fault (sid::host_int_4 p, sid::host_int_4 a, sid::bus::status s, const char* o):
      pc(p), address(a), status(s), operation(o) 
      {}
  };
  

  // ------------------------------------------------------------------------


  // Values travelling through the trap-type pin.
  // Additional "arguments" are sent through the trap-code pin.
  enum cpu_trap_type {
    cpu_trap_software = 1,      // trap instruction hit
    cpu_trap_breakpoint = 2,    // breakpoint instruction hit
    cpu_trap_syscall = 3,       // system call instruction hit
    cpu_trap_invalid_insn = 4,  // invalid instruction hit
    cpu_trap_memory_fault = 5,  // memory fault encountered
    cpu_trap_overflow = 6,      // arithmetic overflow
    cpu_trap_stepped = 7,       // single-step completed
  };


  // Possible trap disposition codes
  enum cpu_trap_disposition 
  {
    cpu_trap_unhandled = 0,     // dispatch to hardware fault handling
    cpu_trap_handled = 1,       // supervisor handled faulting instruction
    cpu_trap_reissue = 2,       // rerun faulting instruction
    cpu_trap_skip = 3,          // skip faulting instruction
  };


  // ------------------------------------------------------------------------


  class basic_cpu: public virtual sid::component,
		   protected virtual fixed_pin_map_component,
		   protected virtual fixed_accessor_map_component,
		   protected virtual fixed_attribute_map_component,
		   protected virtual fixed_relation_map_component,
		   protected virtual fixed_bus_map_component,
		   protected virtual configurable_component,
		   protected virtual reversible_component
  {
    // custom memory allocators for poisioning freshly-allocated memory
  public:
    void* operator new (size_t sz)
    {
      void* p = ::operator new (sz);
      // Initialize the object with garbage, to ease detection of missing initialization.
      char* q = (char*) p;
      char deadbeef[] = { 0xde, 0xad, 0xbe, 0xef };
      for (unsigned i=0; i<sz; i++)
	*q++ = deadbeef[i % 4];
      return p;
    }
    void operator delete (void* p)
    {
      ::operator delete (p);
    }

    // recursion protection
  protected:
    recursion_limited step_limit;

    // scheduler querying
  protected:
    friend class scheduler_time_query<basic_cpu>;
    scheduler_time_query<basic_cpu> sched_query;

    // triggerpoint support
  protected:
    friend class self_watcher<basic_cpu>;
    self_watcher<basic_cpu> triggerpoint_manager;
    // Virtual pin interfaces between self_watcher and fixed_pin_map_component
    sid::component::status pin_factory (const std::string& name)
      {
	sid::component::status s = this->triggerpoint_manager.create_virtual_pin (name);
	if (s == sid::component::not_found)
	  {
	    // If this is not a watchpoint, then return now.
	    // N.B. The name has been mapped by map_watchable_name and is of the form
	    //   watch:gdb%xxwatchpoint%xx<addr>%xx<len>:change
	    std::vector<std::string> tokens = sidutil::tokenize (name, ":");
	    if (tokens.size () != 3 || tokens[0] != "watch" || tokens[2] != "change")
	      return s;

	    // gdb%xxwatchpoint%xx<addr>%xx<len>
	    if (tokens[1].size () < 3 + 3 + 10 + 3 + 1 + 3 + 1)
	      return s;

	    std::string watchable_prefix = map_watchable_name ("gdb-watchpoint-");
	    unsigned watchable_prefix_length = watchable_prefix.size ();
	    if (tokens[1].substr (0, watchable_prefix_length) != watchable_prefix)
	      return s;

	    tokens = sidutil::tokenize (tokens[1].substr (watchable_prefix_length), tokens[1].substr (3, 1));
	    if (tokens.size () != 2)
	      return s;

	    // This is a watch point, add the necessary watchable now.
	    std::pair<sid::host_int_4,sid::host_int_4> addr_and_len;
	    s = sidutil::parse_attribute (tokens[0], addr_and_len.first);
	    assert (s == sid::component::ok);

	    tokens[1] = tokens[1].substr (2); // get past hex digits xx
	    s = sidutil::parse_attribute (tokens[1], addr_and_len.second);
	    assert (s == sid::component::ok);

	    add_watchable_register ("gdb-watchpoint-" + tokens[0] + "-" + tokens[1], addr_and_len, this,
				    & basic_cpu::read_watchpoint_memory,
				    & basic_cpu::write_watchpoint_memory);

	    // Now try to create the virtual pin again. It should succeed.
	    s = this->triggerpoint_manager.create_virtual_pin (name);
	    assert (s == sid::component::ok);
	  }
	return s;
      }
    void pin_junkyard (const std::string& name)
      {
	return this->triggerpoint_manager.destroy_virtual_pin (name);
      }
  // Helper functions for target view support
  template <class PinType>
  void add_watchable_pin (const std::string& name, PinType* pin)
    {
      this->add_pin (name, pin);
      this->add_attribute (name, pin, "pin");
      this->triggerpoint_manager.add_watchable_attribute (name);
      this->categorize (name, "watchable");
    }

  template <class ValueType>
  void add_watchable_register (const std::string& name, ValueType* value)
    {
      this->add_attribute (name, value, "register");
      this->triggerpoint_manager.add_watchable_value (name, value);
      this->categorize (name, "watchable");
    }

  template <class Class, typename Getter, typename Setter>
  void add_watchable_register (const std::string& name,
                               Class* receiver,
                               Getter getter,
                               Setter setter)
    {
      this->add_attribute_virtual (name, receiver, getter, setter, "register");
      this->triggerpoint_manager.add_watchable_attribute (name);
      this->categorize (name, "watchable");
    }

  template <class Class, typename Getter, typename Setter, typename Parameter>
  void add_watchable_register (const std::string& name,
                               Parameter param,
                               Class* receiver,
                               Getter getter,
                               Setter setter)
    {
      this->add_attribute_virtual_parameterized (name, param, receiver, 
                                                 getter, setter, "register");
      this->triggerpoint_manager.add_watchable_attribute (name);
      this->categorize (name, "watchable");
    }

  template <class ValueType>
  void add_watchable_ro_register (const std::string& name, ValueType* value)
    {
      this->add_attribute_ro (name, value, "register");
      this->triggerpoint_manager.add_watchable_attribute (name);
      this->categorize (name, "watchable");
    }

    // step/yield control pins
  protected:
    callback_pin<basic_cpu> step_pin;
    callback_pin<basic_cpu> yield_pin;
    callback_pin<basic_cpu> print_insn_summary_pin;
    bool yield_p;
    sid::host_int_4 step_insn_count;
    sid::host_int_8 total_insn_count;
    mutable sid::host_int_8 total_latency;
    sid::host_int_4 current_step_insn_count;
    sid::host_int_4 num_cycles;
    output_pin step_cycles_pin;
    output_pin cg_caller_pin;
    output_pin cg_callee_pin;
    output_pin cg_jump_pin;
    output_pin cg_return_pin;
    output_pin gprof_pc_hi_pin;
    output_pin gprof_pc_pin;
    output_pin sample_gprof_pin;
   
    // tracing
  private:
    string trace_filename;
    callback_pin<basic_cpu> trace_pin;
    class cpu_trace_stream: public std::ofstream
    {
    public:
      cpu_trace_stream ()
	:cout_p (true) {}
      cpu_trace_stream (const std::string& filename)
	:std::ofstream (filename.c_str ()), cout_p (false) {}
      void divert_to_file () { cout_p = false; }
      void divert_to_cout () { cout_p = true; }
      void open (const std::string& filename)
      {
	std::ofstream::open (filename.c_str (), std::ios::app);
	cout_p = false;
      }
      void end_line ()
      {
	if (LIKELY (cout_p))
	  std::cout << std::endl;
	else
	  *this << std::endl;
      }
    private:
      bool cout_p;

      template <typename T> friend
      basic_cpu::cpu_trace_stream& operator<< (basic_cpu::cpu_trace_stream& s, T t);
    };

    template <typename T> friend
    cpu_trace_stream& operator<< (cpu_trace_stream& s, T t);

    void trace_pin_handler (sid::host_int_4 value)
      {
	trace_stream << static_cast<char> (value);
      }

  public:
    bool trace_extract_p;
    bool trace_result_p;
    bool trace_disass_p;
    bool trace_semantics_p;
    bool trace_counter_p;
    bool final_insn_count_p;
    bool print_final_insn_count_p;
    bool enable_step_trap_p;
    cpu_trace_stream trace_stream;

    virtual void step_pin_handler (sid::host_int_4 tick)
      {
	recursion_record limit (& this->step_limit);
	if (UNLIKELY(! limit.ok())) return;

	this->yield_p = false;
	this->current_tick = tick;

	// Executing backward?
	if (UNLIKELY (exec_direction == "backward"))
	  {
	    step_backward ();
	    this->stepped (1);
	    return;
	  }

	this->current_step_insn_count = 0;
	if (UNLIKELY (reversible_p))
	  this->init_change_logging ();

	// Check for triggerpoints due right now; may set yield_p!
	this->triggerpoint_manager.check_and_dispatch ();

	// Enter insn loop.  Poll continue_after_insn_p after each instruction
	sid::host_int_8 prev_latency = this->total_latency;
	sid::host_int_8 prev_insn_count = this->total_insn_count;
	if (! this->yield_p)
	  {
	    if (UNLIKELY (this->gprof_configured_p))
	      this->sample_gprof (true);
	    this->step_insns ();
	  }
	sid::host_int_8 num_insns = this->total_insn_count - prev_insn_count;
	sid::host_int_8 latency = this->total_latency - prev_latency;

	// Clamp
	const sid::host_int_4 min_num_cycles = 1;
	const sid::host_int_4 max_num_cycles = 0x7FFFFFFF;
	sid::host_int_8 insn_cycles = num_insns + latency_to_cycles (latency);
	num_cycles =
	  insn_cycles <= min_num_cycles ? min_num_cycles :
	  insn_cycles >= max_num_cycles ? max_num_cycles :
	  insn_cycles;

	if (UNLIKELY (reversible_p))
	  this->finish_change_logging ();
	this->stepped (num_cycles);
      }

    virtual void step_backward ()
      {
	// Make sure the infrastructure for reverse execution is in place.
	if (UNLIKELY (! sim_sched || ! reversible_p))
	  {
	    std::cerr << "unable to execute in reverse" << endl;
	    this->signal_trap (cpu_trap_breakpoint, 0);
	    return;
	  }

	// Check whether we're at the start of the program.
	if (UNLIKELY (change_log_end <= change_log_begin))
	  {
	    // We're at the start of the program. See if there are previous
	    // instances to step backward into.
	    if (change_log_boundaries.empty ())
	      {
		std::cerr << "No previous program instances to return to" << endl;
		this->signal_trap (cpu_trap_breakpoint, 0);
		return;
	      }
	    std::cerr << "Stepping back into the previous program instance" << endl;

	    // Switch to the previous program instance.
	    change_log_begin = change_log_boundaries.back ();
	    change_log_boundaries.pop_back ();
	    assert (change_log_begin < change_log_end);
	  }

	// Unwind the change log until a triggerpoint is reached.
	//
	bool single_stepping = this->enable_step_trap_p;
	while (change_log_end > change_log_begin)
	  {
	    // Restore the state to the previous tick.
	    --this->current_tick;
	    restore_state_to_time (this->current_tick);

	    // We've restored all the changes which take us back to the start of the
	    // previous insn.  Now notify the scheduler to reset the rest of
	    // the system to this time.
	    if (LIKELY (sim_sched))
	      sim_sched->set_attribute_value ("time", make_numeric_attribute (this->current_tick));

	    // Check for single stepping.
	    if (single_stepping) 
	      {
		this->signal_trap (sidutil::cpu_trap_stepped);
		break;
	      }

	    // Check for triggerpoints due right now; may set yield_p!
	    this->triggerpoint_manager.check_and_dispatch ();
	    if (this->yield_p)
	      break;
	  }

	// Let GDB know if we run out of state to reverse.
	if (UNLIKELY (change_log_end <= change_log_begin))
	  {
	    std::cerr << "Program start reached while executing in reverse" << endl;
	    this->signal_trap (cpu_trap_breakpoint, 0);
	  }
      }
    void yield ()
      {
	this->yield_p = true;
	// A subsequent continue_after_insns_p should return false.
      }
    void yield_pin_handler (sid::host_int_4)
      {
	this->yield ();
      }
    virtual void print_insn_summary (sid::host_int_4)
      {
	if (print_final_insn_count_p)
	  std::cerr << "instruction count: " << this->total_insn_count << "  "
		    << "simulated cycles: " << this->total_latency + this->total_insn_count << std::endl;
      }
    virtual void stepped (sid::host_int_4 n)
      {
	this->step_cycles_pin.drive (n);
      }
    virtual void cg_profile (sid::host_int_4 caller, sid::host_int_4 callee)
    {
      last_caller = caller;
      last_callee = callee;
      // The drive sequence is important: see sw-profile-gprof
      this->cg_caller_pin.drive (caller);
      this->cg_callee_pin.drive (callee);

      if (UNLIKELY(this->trace_result_p)) 
	{
	  this->trace_stream << "cg-profile "
			     << make_numeric_attribute (caller, 
							std::ios::hex|std::ios::showbase)
			     << "->" 
			     << make_numeric_attribute (callee,
							std::ios::hex|std::ios::showbase)
	                     << "  ";
	}
    }
    virtual void cg_profile_jump (sid::host_int_4 caller, sid::host_int_4 callee)
    {
      last_caller = caller;
      last_callee = callee;
      this->cg_jump_pin.drive (callee);
    }

  public:
    void set_total_latency (sid::host_int_8 latency) { this->total_latency = latency; }
    void update_total_latency (sid::host_int_8 latency) { this->total_latency += latency; }
    sid::host_int_8 get_total_latency () const  { return this->total_latency; }

  protected:
    virtual sid::host_int_8 latency_to_cycles (sid::host_int_8 num)
    {
      // Identity relationship: 1 latency unit = 1 cycle.
      return num;
    }

    void sample_gprof (bool before)
    {
      // What is the current cycle/insn? Always count insns.
      sid::host_int_8 current_cycle = this->total_insn_count + this->current_step_insn_count;

      // If called before the insn execution loop, then the current insn
      // hasn't been counted yet.
      if (before)
	++current_cycle;

      // Count total_latency if we're in cycle mode.
      if (this->gprof_cycles != 0)
	current_cycle += this->total_latency;

      // Have we advanced?
      if (current_cycle <= this->gprof_prev_cycle)
	return;

      gprof_counter += current_cycle - this->gprof_prev_cycle;
      this->gprof_prev_cycle = current_cycle;

      this->gprof_pc_hi_pin.drive (this->get_pc_hi ());
      this->gprof_pc_pin.drive (this->get_pc ());
      if (this->gprof_cycles == 0)
	{
	  // Sample for gprof in insn-count mode.
	  sid::host_int_4 ticks = this->gprof_counter / this->step_insn_count;
	  if (ticks > 0)
	    {
	      this->sample_gprof_pin.drive (ticks);
	      this->gprof_counter %= this->step_insn_count;
	    }
	}
      else
	{
	  // Sample for gprof in cycle mode.
	  sid::host_int_4 ticks = this->gprof_counter / this->gprof_cycles;
	  if (ticks > 0)
	    {
	      this->sample_gprof_pin.drive (ticks);
	      this->gprof_counter %= this->gprof_cycles;
	    }
	}
    }

    virtual void step_insns () = 0;
    bool stop_after_insns_p (sid::host_int_4 num)
      {
	this->current_step_insn_count += num;

	bool rc;
	if (UNLIKELY(this->yield_p ||
		    (this->current_step_insn_count >= this->step_insn_count)))
          {
            // Batch updates to total_insn_count to avoid long-long
            // arithmetic overhead in the inner insn-stepping loops.
	    this->total_insn_count += this->current_step_insn_count;
	    this->current_step_insn_count = 0;
	    rc = true; // stop!
          }
        else
	  rc = false; // don't stop

	// Sample for gprof?
	if (UNLIKELY (this->gprof_configured_p))
	  this->sample_gprof (false);

	return rc;
      }

    void
    update_trace_destination ()
    {
      if (trace_filename == "-")
	trace_stream.divert_to_cout ();
      else
	{
	  trace_stream.close ();
	  trace_stream.open (trace_filename);
	  trace_stream << "start of trace" << std::endl;
	  if (trace_stream.good ())
	    trace_stream.divert_to_file ();
	  else
	    trace_filename = "io-error!";
	}
    }

    // Infer a change to trace_result_p after one of the other general 
    // trace flags are changed.
    void
    update_trace_result_p ()
    {
      this->trace_result_p = (this->trace_semantics_p || this->trace_disass_p);
    }

    void
    update_final_insn_count_p ()
    {
      if (this->final_insn_count_p)
	this->print_final_insn_count_p = true;
    }

    // Reset the processor model to power-up state.
  private:
    callback_pin<basic_cpu> reset_pin;
    virtual void reset () = 0;
    void reset_pin_handler(sid::host_int_4 v)
    {
      // If there's a change log, then start a new one.
      if (change_log_end != 0)
	{
	  change_log_boundaries.push_back (change_log_begin);
	  change_log_begin = change_log_end;
	}
      exec_direction = "forward";
      this->reset ();
      this->stepped(1);
    }

    // Flush internal abstract icache (if any)
  private:
    callback_pin<basic_cpu> flush_icache_pin;
    void flush_icache_pin_handler(sid::host_int_4 v) { this->flush_icache(); }
  protected:
    virtual void flush_icache () = 0;
    virtual void flush_icache (sid::host_int_4 pc) { this->flush_icache (); }

    // Set the initial PC after reset
  private:
    callback_pin<basic_cpu> pc_set_pin;
    virtual void set_pc(sid::host_int_4) = 0;
    virtual sid::host_int_4 get_pc() = 0;
    virtual sid::host_int_4 get_pc_hi() { return 0; }
    void pc_set_pin_handler(sid::host_int_4 v) { this->set_pc (v); }

    // Set the initial endianness after reset
  private:
    callback_pin<basic_cpu> endian_set_pin;
    virtual void set_endian(sid::host_int_4) = 0;
    void endian_set_pin_handler(sid::host_int_4 v) { this->set_endian (v); }
    callback_pin<basic_cpu> eflags_set_pin;
    virtual void set_eflags(sid::host_int_4) {}
    void eflags_set_pin_handler(sid::host_int_4 v) { this->set_eflags (v); }

    // Signal trap type code and argument
  private:
    output_pin trap_type_pin;
    output_pin trap_code_pin;
    input_pin trap_disposition_pin;
  protected:
    cpu_trap_disposition signal_trap (cpu_trap_type p, sid::host_int_4 param = 0)
      {
	// Prepare disposition pin in case we get no signal back
	this->trap_disposition_pin.driven (sid::host_int_4(cpu_trap_unhandled));
	this->trap_code_pin.drive (param);
	this->trap_type_pin.drive (sid::host_int_4(p));
	return static_cast<cpu_trap_disposition>(trap_disposition_pin.sense ());
      }

    void unconfigure_gprof ()
      {
	gprof_unconfigured_p = true;
	if (! gprof_configured_p)
	  return;

	assert (gprof);
	sid::pin *p;

	// Then disconnect the call graph notification pins.
	p = gprof->find_pin ("cg-caller");
	if (p) cg_caller_pin.disconnect (p); 
	p = gprof->find_pin ("cg-callee");
	if (p) cg_callee_pin.disconnect (p);
	p = gprof->find_pin ("sample");
	if (p) sample_gprof_pin.disconnect (p);

	gprof_configured_p = false;
      }

    void configure_gprof (const string &config)
      {
	if (gprof_configured_p)
	  return;

	// Connect the call graph notification pins.
	assert (gprof);
	sid::pin *p = gprof->find_pin ("cg-caller");
	if (p)
	  {
	    cg_caller_pin.connect (p); 
	    if (last_caller && last_callee)
	      p->driven (last_caller);
	  }
	p = gprof->find_pin ("cg-callee");
	if (p) {
	  cg_callee_pin.connect (p); 
	  if (last_caller && last_callee)
	    p->driven (last_callee); 
	}

	p = gprof->find_pin ("sample");
	if (p)
	  sample_gprof_pin.connect (p);

	// Set the state so that the next insn will be sampled, followed by
	// samples at the specified interval. Reset gprof_prev_cycle only
	// if gprof has been unconfigured at some point.
	vector<string> parts = tokenize (config.substr (6), ",");
	if (parts.size () == 2)
	  {
	    component::status s = parse_attribute (parts[1], gprof_cycles);
	    gprof_counter = gprof_cycles - 1;
	    if (gprof_unconfigured_p)
	      gprof_prev_cycle = this->total_insn_count + this->total_latency;
	  }
	else
	  {
	    gprof_cycles = 0;
	    gprof_counter = step_insn_count - 1;
	    if (gprof_unconfigured_p)
	      gprof_prev_cycle = this->total_insn_count;
	  }

	gprof_configured_p = true;
      }

    // ------------------------------------------------------------------------
    // dynamic configuration
  protected:
    component *gprof;
    component *core_probe;
    component *main;
    sid::host_int_4 last_caller;
    sid::host_int_4 last_callee;
    bool gprof_configured_p;
    bool gprof_unconfigured_p;
    sid::host_int_4 gprof_cycles;
    sid::host_int_4 gprof_counter;
    sid::host_int_8 gprof_prev_cycle;

    virtual void configure (const string &config)
      {
	// Call up to the base class
	configurable_component::configure (config);

	// Handle configuration specific to this component
	if (config.size () < 6)
	  return;
	if (config.substr (0, 6) == "gprof=")
	  {
	    if (! gprof)
	      return; // nothing to configure
	    // First get gprof to configure itself
	    gprof->set_attribute_value ("configure!", config);
	    // Now do our own configuration
	    if (config.size () > 6)
	      configure_gprof (config);
	    else
	      unconfigure_gprof ();
	    return;
	  }
	if (config.size () <= 11)
	  return;
	if (config.substr (0, 11) == "insn-count=")
	  {
	    sid::host_int_4 n;
	    sid::component::status s = parse_attribute (config.substr (11), n);
	    if (s == sid::component::ok)
	      {
		step_insn_count = n;
		if (gprof_configured_p && gprof_cycles == 0)
		  {
		    // Set the state so that the next insn will be sampled,
		    // followed by samples at the specified interval.
		    gprof_counter = step_insn_count - 1;
		    gprof_prev_cycle = this->total_insn_count;
		  }
	      }
	    return;
	  }
	if (config.substr (0, 8) == "verbose=")
	  {
	    if (main)
	      main->set_attribute_value ("verbose?", config.substr (8));
	    return;
	  }
	if (config.size () < 15)
	  return;
	if (config.substr (0, 11) == "trace-core=")
	  {
	    if (core_probe)
	      core_probe->set_attribute_value ("trace?", config.substr (11));
	    return;
	  }
	if (config.size () < 18)
	  return;
	if (config.substr (0, 14) == "trace-counter=")
	  {
	    trace_counter_p = (config.substr (14) == "true");
	    return;
	  }
	if (config.substr (0, 14) == "trace-extract=")
	  {
	    trace_extract_p = (config.substr (14) == "true");
	    return;
	  }
	if (config.size () < 20)
	  return;
	if (config.substr (0, 16) == "trace-semantics=")
	  {
	    trace_semantics_p = (config.substr (16) == "true");
	    update_trace_result_p ();
	    return;
	  }
	if (config.size () < 21)
	  return;
	if (config.substr (0, 17) == "final-insn-count=")
	  {
	    final_insn_count_p = (config.substr (17) == "true");
	    update_final_insn_count_p ();
	    return;
	  }
	if (config.size () < 22)
	  return;
	if (config.substr (0, 18) == "trace-disassemble=")
	  {
	    trace_disass_p = (config.substr (18) == "true");
	    update_trace_result_p ();
	    return;
	  }
      }

    // Reversible implementation
  protected:
    sidutil::change_log change_log;
    unsigned change_log_begin;
    unsigned change_log_end;
    vector<unsigned> change_log_boundaries;
    std::string change_string;
    string exec_direction;
    component *sim_sched;
    sid::host_int_4 current_tick;
    sid::host_int_4 last_tick;

    virtual void init_change_logging () {}
    virtual void finish_change_logging () {}

    // Log any changes since the last change was logged.  Target specific
    // changes are logged in change_log.finish ().
    virtual void log_change (const void* change, sid::host_int_4 length)
      {
	assert (reversible_p);
	change_log.push (& current_tick, sizeof (current_tick));
	change_log.add (change, length);
	change_log.finish ();
	++change_log_end;
      }

    // Restore the state represented by the given change log record.
    virtual void restore_change (const char* record, sid::host_int_4 length)
      {
      }

    // Restore our state to what it was at the given time.
    virtual void restore_state_to_time (sid::host_int_4 tick)
      {
	// Call up to the base class.
	reversible_component::restore_state_to_time (tick);

	// Nothing to restore?
	if (UNLIKELY (change_log_end == 0))
	  return;

	// Rewind the change log to the given time.
	unsigned found = change_log_end;
	while (change_log_end >= 1)
	  {
	    // Obtain the most recent change log record.
	    sid::host_int_4 length;
	    const char *record = (const char *)change_log.top (length);

	    // The first item in the record is the time (tick) of the change.
	    // If it's before our target time, then we're done.
	    sid::host_int_4 new_tick = *(sid::host_int_4*)record;
	    if (new_tick < tick)
	      break;

	    record += sizeof (new_tick);
	    length -= sizeof (new_tick);

	    // Restore the state represented by the record.
	    restore_change (record, length);

	    // We're done with this record.
	    change_log.pop ();
	    --change_log_end;

	    // Adjust program instance boundaries, if necessary.
	    if (change_log_end < change_log_begin)
	      {
		assert (! change_log_boundaries.empty ());
		change_log_begin = change_log_boundaries.back ();
		change_log_boundaries.pop_back ();
		assert (change_log_end >= change_log_begin);
	      }
	  }
      }
	
    virtual component::status dynamic_config(const string& spec)
      {
	// Call up to the base class
	component::status s = configurable_component::dynamic_config (spec);

	// Check whether insn-count must be forced to 1
	if (trace_counter_p)
	  configure ("insn-count=1");

	return s;
      }

    // state save/restore: Override these in derived classes, but
    // include a call up to this base implementation.
  protected:
    virtual void stream_state(std::ostream& o) const 
      {
	o << "basic-cpu"
	  // attrs
	  << " " << this->step_insn_count
	  << " " << this->enable_step_trap_p
	  << " " << this->total_insn_count
	  << " " << this->total_latency
	  << " " << this->trace_extract_p
	  << " " << this->trace_result_p
	  << " " << this->trace_disass_p
	  << " " << this->trace_semantics_p
	  << " " << this->trace_counter_p
	  << " " << this->final_insn_count_p
	  << " " << this->print_final_insn_count_p
	  // pins
	  << " " << this->step_cycles_pin
	  << " " << this->trap_type_pin
	  << " " << this->trap_code_pin;
      }

    virtual void destream_state(std::istream& i) 
      {
	std::string key;
	i >> key;
	if (key != "basic-cpu")
	  {
	    i.setstate (std::ios::badbit);
	    return;
	  }
	i >> this->step_insn_count
	  >> this->enable_step_trap_p
	  >> this->total_insn_count
	  >> this->total_latency
	  >> this->trace_extract_p
	  >> this->trace_result_p
	  >> this->trace_disass_p
	  >> this->trace_semantics_p
	  >> this->trace_counter_p
	  >> this->final_insn_count_p
	  >> this->print_final_insn_count_p
	  // pins
	  >> this->step_cycles_pin
	  >> this->trap_type_pin
	  >> this->trap_code_pin;
      }

    // helper functions
  private:
    friend std::ostream& operator << (std::ostream& o, const basic_cpu& c);
    friend std::istream& operator >> (std::istream& i, basic_cpu& c);
    std::string save_state() { return make_attribute(*this); }
    sid::component::status restore_state(const std::string& s)
      { return parse_attribute(s, *this); }


    // ------------------------------------------------------------------------
    // debugger access functions
  private:
    passthrough_bus debugger_bus;
    virtual std::string dbg_get_reg (sid::host_int_4 n) = 0;
    virtual sid::component::status dbg_set_reg (sid::host_int_4 n, const std::string& s) = 0;

  protected:
    template <typename PC>
    void create_gdb_register_attrs (sid::host_int_4 count, 
				    const std::string& expedited_regno_list, 
				    PC* pc)
      {
	this->add_watchable_register ("gdb-register-pc", pc);
	this->add_attribute_ro_value ("gdb-num-registers", count, "debugger");

	// The "expedited" register list string is the semi-colon-delimited list of
	// register numbers that should be sent to gdb immediately
	// every time sid stops, rather than let gdb ask for it
	// subsequently.  Usually, the PC, frame and stack pointer,
	// and status register should be included in the list.  It
	// makes gdb step operations much faster.
        // The register numbering scheme is that decided by gdb. 

	this->add_attribute_ro_value ("gdb-exp-registers", expedited_regno_list, "debugger");
	for (sid::host_int_4 i=0; i<count; i++)
	  {
	    std::string name = std::string ("gdb-register-") + make_numeric_attribute (i);
	    attribute_coder_base* coder =
	      new attribute_coder_virtual_parameterized<basic_cpu,sid::host_int_4>
	      (this, & basic_cpu::dbg_get_reg, & basic_cpu::dbg_set_reg, i);
	    this->add_attribute_coder (name, coder, "debugger");
	  }
      }


    // ------------------------------------------------------------------------
    // memory access functions

  protected:
    sid::bus* data_bus;
    sid::bus* insn_bus;
    sid::bus* disassembler_bus;

  protected:
    template <typename BigOrLittleInt>
    BigOrLittleInt read_insn_memory (sid::host_int_4 pc, sid::host_int_4 address, BigOrLittleInt);
    template <typename BigOrLittleInt>
    BigOrLittleInt write_insn_memory (sid::host_int_4 pc, sid::host_int_4 address, BigOrLittleInt value);
    template <typename BigOrLittleInt>
    BigOrLittleInt read_data_memory (sid::host_int_4 pc, sid::host_int_4 address, BigOrLittleInt);
    template <typename BigOrLittleInt>
    BigOrLittleInt write_data_memory (sid::host_int_4 pc, sid::host_int_4 address, BigOrLittleInt value);

    virtual sid::host_int_1 read_data_memory_1 (sid::host_int_4 pc, sid::host_int_4 address) = 0;
    virtual sid::host_int_2 read_data_memory_2 (sid::host_int_4 pc, sid::host_int_4 address) = 0;
    virtual sid::host_int_4 read_data_memory_4 (sid::host_int_4 pc, sid::host_int_4 address) = 0;
    virtual sid::host_int_8 read_data_memory_8 (sid::host_int_4 pc, sid::host_int_4 address) = 0;

    virtual bool handle_insn_memory_read_error (sid::bus::status s, sid::host_int_4 & address) { return false; }
    virtual bool handle_insn_memory_write_error (sid::bus::status s, sid::host_int_4 & address) { return false; }
    virtual bool handle_data_memory_read_error (sid::bus::status s, sid::host_int_4 & address) { return false; }
    virtual bool handle_data_memory_write_error (sid::bus::status s, sid::host_int_4 & address) { return false; }

    virtual void record_insn_memory_read_latency (sid::bus::status s) { total_latency += s.latency; }
    virtual void record_insn_memory_write_latency (sid::bus::status s) { total_latency += s.latency; }
    virtual void record_data_memory_read_latency (sid::bus::status s) { total_latency += s.latency; }
    virtual void record_data_memory_write_latency (sid::bus::status s) { total_latency += s.latency; }

    virtual std::string read_watchpoint_memory (std::pair<sid::host_int_4,sid::host_int_4> addr_and_length)
      {
	// Extract the address and length from the argument.
	sid::host_int_4 address = addr_and_length.first;
	sid::host_int_4 length  = addr_and_length.second;

	// We'll need the current pc.
	sid::host_int_4 pc = get_pc ();

	// Just read from insn memory by default
	switch (length)
	  {
	  case 1:
	    {
	      sid::host_int_1 r1 = read_data_memory_1 (pc, address);
	      return sidutil::make_attribute (r1);
	    }
	  case 2:
	    {
	      sid::host_int_2 r2 = read_data_memory_2 (pc, address);
	      return sidutil::make_attribute (r2);
	    }
	  case 4:
	    {
	      sid::host_int_4 r4 = read_data_memory_4 (pc, address);
	      return sidutil::make_attribute (r4);
	    }
	  case 8:
	    {
	      sid::host_int_8 r8 = read_data_memory_8 (pc, address);
	      return sidutil::make_attribute (r8);
	    }
	  }

	throw cpu_memory_fault (pc, address, sid::bus::unmapped, "watchpoint read");
	return "";
      }

    virtual sid::component::status write_watchpoint_memory (std::pair<sid::host_int_4,sid::host_int_4> addr_and_length, const std::string &value)
      {
	return sid::component::bad_value;
      }

    // ------------------------------------------------------------------------
    
public:
    basic_cpu ():
      total_latency (0),
      current_step_insn_count (0),
      step_limit ("instruction stepping", 1),
      sched_query (this),
      triggerpoint_manager (this),
      step_pin (this, & basic_cpu::step_pin_handler),
      yield_pin (this, & basic_cpu::yield_pin_handler),
      reset_pin (this, & basic_cpu::reset_pin_handler),
      print_insn_summary_pin (this, & basic_cpu::print_insn_summary),
      flush_icache_pin (this, & basic_cpu::flush_icache_pin_handler),
      pc_set_pin (this, & basic_cpu::pc_set_pin_handler),
      endian_set_pin (this, & basic_cpu::endian_set_pin_handler),
      eflags_set_pin (this, & basic_cpu::eflags_set_pin_handler),
      debugger_bus (& this->data_bus),
      trace_stream (),
      trace_filename ("-"), // standard output
      trace_pin (this, & basic_cpu::trace_pin_handler),
      gprof (0),
      last_caller (0),
      last_callee (0),
      gprof_configured_p (false),
      gprof_unconfigured_p (false),
      gprof_prev_cycle (0),
      core_probe (0),
      main (0),
      change_log (),
      change_log_begin (0),
      change_log_end (0),
      change_log_boundaries (),
      last_tick (~(sid::host_int_4)0),
      exec_direction ("forward"),
      sim_sched (0)
      {
	// buses
	this->data_bus = 0;
	add_accessor ("data-memory", & this->data_bus);
	this->insn_bus = 0;
	add_accessor ("insn-memory", & this->insn_bus);
	this->disassembler_bus = 0;
	add_accessor ("disassembler-memory", & this->disassembler_bus);
	add_bus ("debugger-bus", & this->debugger_bus);

	// pins
	add_pin ("step!", & this->step_pin);
	add_watchable_pin ("step-cycles", & this->step_cycles_pin);
	add_pin ("flush-icache", & this->flush_icache_pin);
	add_pin ("reset!", & this->reset_pin);
	add_pin ("yield", & this->yield_pin);
	add_pin ("start-pc-set!", & this->pc_set_pin);
	add_pin ("cg-caller", & this->cg_caller_pin);
	add_pin ("cg-callee", & this->cg_callee_pin);
	add_pin ("cg-return", & this->cg_return_pin);
	add_pin ("cg-jump", & this->cg_jump_pin);
	add_pin ("print-insn-summary!", & this->print_insn_summary_pin);
	add_pin ("sample-gprof", &sample_gprof_pin);
	add_pin ("gprof-pc-hi", &gprof_pc_hi_pin);
	add_pin ("gprof-pc", &gprof_pc_pin);
	add_pin ("endian-set!", & this->endian_set_pin);
	add_pin ("eflags-set!", & this->eflags_set_pin);
	add_watchable_pin ("trap", & this->trap_type_pin); // output side
	add_watchable_pin ("trap-code", & this->trap_code_pin);
	add_pin ("trap", & this->trap_disposition_pin); // input side
	add_pin ("trace", & this->trace_pin);

	// attributes
	this->step_insn_count = 1;
	add_attribute ("step-insn-count", & this->step_insn_count, "setting");
	this->enable_step_trap_p = false;
	add_attribute ("enable-step-trap?", & this->enable_step_trap_p, "setting");
	this->total_insn_count = 0;
	add_watchable_register ("insn-count", & this->total_insn_count);
	add_attribute_virtual ("state-snapshot", this,
			       & basic_cpu::save_state,
			       & basic_cpu::restore_state);
	add_attribute_notify ("trace-filename", & this->trace_filename, this,
			      & basic_cpu::update_trace_destination,
			      "setting");
	this->trace_extract_p = false;
	add_attribute ("trace-extract?", & trace_extract_p, "setting");
	this->trace_semantics_p = false;
	add_attribute_notify ("trace-semantics?", & this->trace_semantics_p, this,
			       & basic_cpu::update_trace_result_p, 
			       "setting");
	this->trace_disass_p = false;
	add_attribute_notify ("trace-disassemble?", & this->trace_disass_p, this,
			       & basic_cpu::update_trace_result_p, 
			       "setting");
	// `trace-result?' should go away after all simulators are updated to
	// use `trace-semantics?'.
	this->trace_result_p = false;
	add_attribute ("trace-result?", & this->trace_result_p, "setting");
	this->trace_counter_p = false;
	add_attribute ("trace-counter?", & this->trace_counter_p, "setting");
	this->final_insn_count_p = false;
	this->print_final_insn_count_p = false;
	add_attribute_notify ("final-insn-count?", & this->final_insn_count_p, this,
			      & basic_cpu::update_final_insn_count_p,
			      "setting");
	add_attribute ("exec-direction", &exec_direction, "setting");
	add_uni_relation("sim-sched", &this->sim_sched);

	// For dynamic configuration
	add_uni_relation("gprof", &this->gprof);
	add_uni_relation("core-probe", &this->core_probe);
	add_uni_relation("main", &this->main);
      }

    virtual ~basic_cpu() {}
  };


  inline std::ostream& operator << (std::ostream& o, const basic_cpu& c) {
    c.stream_state (o);
    return o;
  }
  inline std::istream& operator >> (std::istream& i, basic_cpu& c) {
    c.destream_state (i);
    return i;
  }

    template <typename T>
    basic_cpu::cpu_trace_stream& operator<< (basic_cpu::cpu_trace_stream& s, T t)
    {
      if (LIKELY (s.cout_p))
	std::cout << t;
      else
	static_cast <std::ofstream&> (s) << t;
      return s;
    }
  
    template <typename BigOrLittleInt>
    BigOrLittleInt basic_cpu::read_insn_memory (sid::host_int_4 pc, sid::host_int_4 address, BigOrLittleInt)
      {
	sid::bus::status s;
	do
	  {
	    BigOrLittleInt value;
	    if (LIKELY(this->insn_bus))
	      {
		s = this->insn_bus->read (address, value);
		if (LIKELY(s == sid::bus::ok))
		  {
		    if (UNLIKELY ((trace_counter_p || final_insn_count_p) && s.latency))
		      record_insn_memory_read_latency (s);
		    return value;
		  }
	      }
	    else
	      s = sid::bus::unmapped;
	  }
	while (UNLIKELY (handle_insn_memory_read_error (s, address)));

	throw cpu_memory_fault (pc, address, s, "insn read");
      }

    template <typename BigOrLittleInt>
    BigOrLittleInt basic_cpu::write_insn_memory (sid::host_int_4 pc, sid::host_int_4 address, BigOrLittleInt value)
      {
	sid::bus::status s;
	do
	  {
	    if (LIKELY(this->insn_bus))
	      {
		s = this->insn_bus->write (address, value);
		if (LIKELY(s == sid::bus::ok))
		  {
		    if (UNLIKELY ((trace_counter_p || final_insn_count_p) && s.latency))
		      record_insn_memory_write_latency (s);
		    return value;
		  }
	      }
	    else
	      s = sid::bus::unmapped;
	  }
	while (UNLIKELY (handle_insn_memory_read_error (s, address)));

	throw cpu_memory_fault (pc, address, s, "insn write");
      }

    template <typename BigOrLittleInt>
    BigOrLittleInt basic_cpu::read_data_memory (sid::host_int_4 pc, sid::host_int_4 address, BigOrLittleInt)
      {
	sid::bus::status s;
	do
	  {
	    BigOrLittleInt value;
	    if (LIKELY(this->data_bus))
	      {
		s = this->data_bus->read (address, value);
		if (LIKELY(s == sid::bus::ok))
		  {
		    if (UNLIKELY ((trace_counter_p || final_insn_count_p) && s.latency))
		      record_data_memory_read_latency (s);
		    return value;
		  }
	      }
	    else
	      s = sid::bus::unmapped;
	  }
	while (UNLIKELY (handle_insn_memory_read_error (s, address)));

	throw cpu_memory_fault (pc, address, s, "data read");
      }

    template <typename BigOrLittleInt>
    BigOrLittleInt basic_cpu::write_data_memory (sid::host_int_4 pc, sid::host_int_4 address, BigOrLittleInt value)
      {
	sid::bus::status s;
	do
	  {
	    if (LIKELY(this->data_bus))
	      {
		s = this->data_bus->write (address, value);
		if (LIKELY(s == sid::bus::ok))
		  {
		    if (UNLIKELY ((trace_counter_p || final_insn_count_p) && s.latency))
		      record_data_memory_write_latency (s);
		    return value;
		  }
	      }
	    else
	      s = sid::bus::unmapped;
	  }
	while (UNLIKELY (handle_insn_memory_read_error (s, address)));

	throw cpu_memory_fault (pc, address, s, "data write");
      }

  // ------------------------------------------------------------------------
  // Derived classes for memory access functions of various endianness

  class basic_big_endian_cpu: public basic_cpu
  {
    void set_endian(sid::host_int_4) {}
    void set_eflags(sid::host_int_4) {}

  protected:

    basic_big_endian_cpu ()
      {
	add_attribute_ro_value ("endian", endian_big, "register");
      }
    ~basic_big_endian_cpu () {}

    sid::host_int_1 read_insn_memory_1 (sid::host_int_4 pc, sid::host_int_4 address)
      {
	return this->read_insn_memory (pc, address, sid::big_int_1());
      }

    sid::host_int_2 read_insn_memory_2 (sid::host_int_4 pc, sid::host_int_4 address)
      {
	return this->read_insn_memory (pc, address, sid::big_int_2());
      }

    sid::host_int_4 read_insn_memory_4 (sid::host_int_4 pc, sid::host_int_4 address)
      {
	return this->read_insn_memory (pc, address, sid::big_int_4());
      }

    sid::host_int_8 read_insn_memory_8 (sid::host_int_4 pc, sid::host_int_4 address)
      {
	return this->read_insn_memory (pc, address, sid::big_int_8());
      }

    void write_insn_memory_1 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_1 value)
      {
	this->write_insn_memory (pc, address, sid::big_int_1(value));
      }

    void write_insn_memory_2 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_2 value)
      {
	this->write_insn_memory (pc, address, sid::big_int_2(value));
      }

    void write_insn_memory_4 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_4 value)
      {
	this->write_insn_memory (pc, address, sid::big_int_4(value));
      }

    void write_insn_memory_8 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_8 value)
      {
	this->write_insn_memory (pc, address, sid::big_int_8(value));
      }

    sid::host_int_1 read_data_memory_1 (sid::host_int_4 pc, sid::host_int_4 address)
      {
	return this->read_data_memory (pc, address, sid::big_int_1());
      }

    sid::host_int_2 read_data_memory_2 (sid::host_int_4 pc, sid::host_int_4 address)
      {
	return this->read_data_memory (pc, address, sid::big_int_2());
      }

    sid::host_int_4 read_data_memory_4 (sid::host_int_4 pc, sid::host_int_4 address)
      {
	return this->read_data_memory (pc, address, sid::big_int_4());
      }

    sid::host_int_8 read_data_memory_8 (sid::host_int_4 pc, sid::host_int_4 address)
      {
	return this->read_data_memory (pc, address, sid::big_int_8());
      }

    void write_data_memory_1 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_1 value)
      {
	this->write_data_memory (pc, address, sid::big_int_1(value));
      }

    void write_data_memory_2 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_2 value)
      {
	this->write_data_memory (pc, address, sid::big_int_2(value));
      }

    void write_data_memory_4 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_4 value)
      {
	this->write_data_memory (pc, address, sid::big_int_4(value));
      }

    void write_data_memory_8 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_8 value)
      {
	this->write_data_memory (pc, address, sid::big_int_8(value));
      }
  };


  // ----------------------------------------------------------------------------

  class basic_little_endian_cpu: public basic_cpu
  {
    void set_endian(sid::host_int_4) {}
    void set_eflags(sid::host_int_4) {}

  protected:
    basic_little_endian_cpu ()
      {
	add_attribute_ro_value ("endian", endian_little, "register");
      }
    ~basic_little_endian_cpu () {}

    sid::host_int_1 read_insn_memory_1 (sid::host_int_4 pc, sid::host_int_4 address)
      {
	return this->read_insn_memory (pc, address, sid::little_int_1());
      }

    sid::host_int_2 read_insn_memory_2 (sid::host_int_4 pc, sid::host_int_4 address)
      {
	return this->read_insn_memory (pc, address, sid::little_int_2());
      }

    sid::host_int_4 read_insn_memory_4 (sid::host_int_4 pc, sid::host_int_4 address)
      {
	return this->read_insn_memory (pc, address, sid::little_int_4());
      }

    sid::host_int_8 read_insn_memory_8 (sid::host_int_4 pc, sid::host_int_4 address)
      {
	return this->read_insn_memory (pc, address, sid::little_int_8());
      }

    void write_insn_memory_1 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_1 value)
      {
	this->write_insn_memory (pc, address, sid::little_int_1(value));
      }

    void write_insn_memory_2 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_2 value)
      {
	this->write_insn_memory (pc, address, sid::little_int_2(value));
      }

    void write_insn_memory_4 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_4 value)
      {
	this->write_insn_memory (pc, address, sid::little_int_4(value));
      }

    void write_insn_memory_8 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_8 value)
      {
	this->write_insn_memory (pc, address, sid::little_int_8(value));
      }

    sid::host_int_1 read_data_memory_1 (sid::host_int_4 pc, sid::host_int_4 address)
      {
	return this->read_data_memory (pc, address, sid::little_int_1());
      }

    sid::host_int_2 read_data_memory_2 (sid::host_int_4 pc, sid::host_int_4 address)
      {
	return this->read_data_memory (pc, address, sid::little_int_2());
      }

    sid::host_int_4 read_data_memory_4 (sid::host_int_4 pc, sid::host_int_4 address)
      {
	return this->read_data_memory (pc, address, sid::little_int_4());
      }

    sid::host_int_8 read_data_memory_8 (sid::host_int_4 pc, sid::host_int_4 address)
      {
	return this->read_data_memory (pc, address, sid::little_int_8());
      }

    void write_data_memory_1 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_1 value)
      {
	this->write_data_memory (pc, address, sid::little_int_1(value));
      }

    void write_data_memory_2 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_2 value)
      {
	this->write_data_memory (pc, address, sid::little_int_2(value));
      }

    void write_data_memory_4 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_4 value)
      {
	this->write_data_memory (pc, address, sid::little_int_4(value));
      }

    void write_data_memory_8 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_8 value)
      {
	this->write_data_memory (pc, address, sid::little_int_8(value));
      }
  };


  // ----------------------------------------------------------------------------


  class basic_bi_endian_cpu: public basic_cpu
  {
    endian _current_endianness;
  protected:
    endian current_endianness() const { return this->_current_endianness; }

  protected:
    basic_bi_endian_cpu ()
      {
	this->_current_endianness = endian_big;
	add_attribute ("endian", & this->_current_endianness, "register");
      }
    ~basic_bi_endian_cpu () {}

    void set_endian(sid::host_int_4 v)
      {
	switch (v)
	  {
	  case 1:
	    this->_current_endianness = endian_big;
	    break;
	  case 2:
	    this->_current_endianness = endian_little;
	    break;
	  default:
	    // XXX: warning message?
	    break;
	  }
      }

    void stream_state(std::ostream& o) const 
      {
	basic_cpu::stream_state(o);
	o << " " << this->_current_endianness;
      }

    void destream_state(std::istream& i) 
      {
	basic_cpu::destream_state(i);
	i >> this->_current_endianness;
      }


    sid::host_int_1 read_insn_memory_1 (sid::host_int_4 pc, sid::host_int_4 address)
      {
	if (this->_current_endianness == endian_little)
	  return this->read_insn_memory (pc, address, sid::little_int_1());
	else // endian_big or endian_unknown
	  return this->read_insn_memory (pc, address, sid::big_int_1());
      }

    sid::host_int_2 read_insn_memory_2 (sid::host_int_4 pc, sid::host_int_4 address)
      {
	if (this->_current_endianness == endian_little)
	  return this->read_insn_memory (pc, address, sid::little_int_2());
	else // endian_big or endian_unknown
	  return this->read_insn_memory (pc, address, sid::big_int_2());
      }

    sid::host_int_4 read_insn_memory_4 (sid::host_int_4 pc, sid::host_int_4 address)
      {
	if (this->_current_endianness == endian_little)
	  return this->read_insn_memory (pc, address, sid::little_int_4());
	else // endian_big or endian_unknown
	  return this->read_insn_memory (pc, address, sid::big_int_4());
      }

    sid::host_int_8 read_insn_memory_8 (sid::host_int_4 pc, sid::host_int_4 address)
      {
	if (this->_current_endianness == endian_little)
	  return this->read_insn_memory (pc, address, sid::little_int_8());
	else // endian_big or endian_unknown
	  return this->read_insn_memory (pc, address, sid::big_int_8());
      }

    void write_insn_memory_1 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_1 value)
      {
	if (this->_current_endianness == endian_little)
	  this->write_insn_memory (pc, address, sid::little_int_1(value));
	else // endian_big or endian_unknown
	  this->write_insn_memory (pc, address, sid::big_int_1(value));
      }

    void write_insn_memory_2 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_2 value)
      {
	if (this->_current_endianness == endian_little)
	  this->write_insn_memory (pc, address, sid::little_int_2(value));
	else // endian_big or endian_unknown
	  this->write_insn_memory (pc, address, sid::big_int_2(value));
      }

    void write_insn_memory_4 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_4 value)
      {
	if (this->_current_endianness == endian_little)
	  this->write_insn_memory (pc, address, sid::little_int_4(value));
	else // endian_big or endian_unknown
	  this->write_insn_memory (pc, address, sid::big_int_4(value));
      }

    void write_insn_memory_8 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_8 value)
      {
	if (this->_current_endianness == endian_little)
	  this->write_insn_memory (pc, address, sid::little_int_8(value));
	else // endian_big or endian_unknown
	  this->write_insn_memory (pc, address, sid::big_int_8(value));
      }

    sid::host_int_1 read_data_memory_1 (sid::host_int_4 pc, sid::host_int_4 address)
      {
	if (this->_current_endianness == endian_little)
	  return this->read_data_memory (pc, address, sid::little_int_1());
	else // endian_big or endian_unknown
	  return this->read_data_memory (pc, address, sid::big_int_1());
      }

    sid::host_int_2 read_data_memory_2 (sid::host_int_4 pc, sid::host_int_4 address)
      {
	if (this->_current_endianness == endian_little)
	  return this->read_data_memory (pc, address, sid::little_int_2());
	else // endian_big or endian_unknown
	  return this->read_data_memory (pc, address, sid::big_int_2());
      }

    sid::host_int_4 read_data_memory_4 (sid::host_int_4 pc, sid::host_int_4 address)
      {
	if (this->_current_endianness == endian_little)
	  return this->read_data_memory (pc, address, sid::little_int_4());
	else // endian_big or endian_unknown
	  return this->read_data_memory (pc, address, sid::big_int_4());
      }

    sid::host_int_8 read_data_memory_8 (sid::host_int_4 pc, sid::host_int_4 address)
      {
	if (this->_current_endianness == endian_little)
	  return this->read_data_memory (pc, address, sid::little_int_8());
	else // endian_big or endian_unknown
	  return this->read_data_memory (pc, address, sid::big_int_8());
      }

    void write_data_memory_1 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_1 value)
      {
	if (this->_current_endianness == endian_little)
	  this->write_data_memory (pc, address, sid::little_int_1(value));
	else // endian_big or endian_unknown
	  this->write_data_memory (pc, address, sid::big_int_1(value));
      }

    void write_data_memory_2 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_2 value)
      {
	if (this->_current_endianness == endian_little)
	  this->write_data_memory (pc, address, sid::little_int_2(value));
	else // endian_big or endian_unknown
	  this->write_data_memory (pc, address, sid::big_int_2(value));
      }

    void write_data_memory_4 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_4 value)
      {
	if (this->_current_endianness == endian_little)
	  this->write_data_memory (pc, address, sid::little_int_4(value));
	else // endian_big or endian_unknown
	  this->write_data_memory (pc, address, sid::big_int_4(value));
      }

    void write_data_memory_8 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_8 value)
      {
	if (this->_current_endianness == endian_little)
	  this->write_data_memory (pc, address, sid::little_int_8(value));
	else // endian_big or endian_unknown
	  this->write_data_memory (pc, address, sid::big_int_8(value));
      }
  };


} // end namespace sidutil


#endif // SIDCPUUTIL_H
@


1.40
log
@Support for Toshiba MeP.
@
text
@d19 1
d110 2
a111 1
		   protected virtual configurable_component
d313 1
a313 1
    virtual void step_pin_handler (sid::host_int_4)
d319 13
d357 2
d361 65
d589 12
a600 1
    void reset_pin_handler(sid::host_int_4 v) { this->reset (); this->stepped(1); }
d815 76
d1102 8
a1109 1
      main (0)
d1176 2
@


1.39
log
@2006-09-27  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (basic_cpu::configure): Set gprof_prev_cycle to
        total_insn_count when gprof 'cycles' not specified.
@
text
@d3 1
a3 1
// Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Red Hat.
d1007 1
a1007 1
    virtual ~basic_cpu() throw() {}
d1142 1
a1142 1
    ~basic_big_endian_cpu () throw() {}
d1238 1
a1238 1
    ~basic_little_endian_cpu () throw() {}
d1337 1
a1337 1
    ~basic_bi_endian_cpu () throw() {}
@


1.38
log
@2006-06-26  Dave Brolley  <brolley@@redhat.com>

        * commonCfg.cxx (GprofCfg): Connect the cpu's gprof-pc and gprof-pc-hi
        pins to our pc and p-hi pins respectively.
@
text
@d665 1
a665 1
		    gprof_prev_cycle = this->total_insn_count - 1;
@


1.37
log
@2006-06-20  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (basic_cpu): Remove gprof_prev_latency. Add
        gprof_prev_cycle, gprof_unconfigured_p.
        (sample_gprof): Now takes bool argument. Compute number of samples
        based on total_insn_count + current_step_insn_count + total_latency.
        (unconfigure_gprof): Set gprof_unconfigured_p.
        (configure_gprof): Only reset gprof_pref_cycle if gprof_unconfigured_p
        is true.
        (configure): When configuring --insn-count reset gprof_prev_cycle.
@
text
@d256 2
d422 2
d521 2
d869 1
a869 4
	std::string pc_str = this->attribute_value ("pc");
	sid::host_int_4 pc;
	sid::component::status rc = sidutil::parse_attribute (pc_str, pc);
	assert (rc == sid::component::ok);
d957 2
@


1.36
log
@2006-06-14  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (basic_cpu::sample_gprof_pin): New pin.
        (sample_gprof): New method of basic_cpu.
        (step_pin_handler): Don't reset current_step_insn_count.
        Call sample_gprof, if requested and save latency.
        (stop_after_insns_p): Likewise.
        (unconfigure_gprof): Now takes no arguments. Remove unused code.
        Disconnect the sample_gprof_pin.
        (configure_gprof): Now takes configuration string. Connect the
        sample_gprof_pin. Determine the sampling mode.
        (gprof_cycles,gprof_counter,gprof_prev_latency): New members of
        basic_cpu.
        (configure): Initialize gprof_counter.
        (basic_cpu): Add sample-gprof pin.
@
text
@d325 1
a325 2
	      this->sample_gprof (1);
	    this->gprof_prev_latency = this->total_latency;
d399 1
a399 1
    void sample_gprof (sid::host_int_4 num_insns)
d401 18
a418 1
      this->gprof_counter += num_insns;
a419 1
      // Sample for gprof in insn-count mode?
d422 1
a428 1
	  return;
d430 1
a430 7

      // Sample for gprof in cycle mode
      if ((sid::signed_host_int_8)(this->total_latency) > (sid::signed_host_int_8)(this->gprof_prev_latency))
	this->gprof_counter += this->total_latency - this->gprof_prev_latency;

      sid::host_int_4 ticks = this->gprof_counter / this->gprof_cycles;
      if (ticks > 0)
d432 7
a438 2
	  this->sample_gprof_pin.drive (ticks);
	  this->gprof_counter %= this->gprof_cycles;
d462 1
a462 7
	  {
	    // Count 1 fewer insns if exiting to account for the one counted on entry
	    if (rc)
	      --num;
	    this->sample_gprof (num);
	  }
	this->gprof_prev_latency = this->total_latency;
d545 1
d588 3
d596 2
d603 2
d619 1
d622 1
a622 1
    sid::host_int_8 gprof_prev_latency;
d655 6
a660 1
		  gprof_counter = step_insn_count - 1;
d927 2
a928 1
      gprof_prev_latency (0),
@


1.35
log
@2006-05-11  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (cg_profile): Now virtual.
        (cg_profile_jump): Now virtual.
        (dynamic_config): New vritual override.
@
text
@d256 1
a313 1
	this->current_step_insn_count = 0;
d323 6
a328 1
	  this->step_insns ();
d400 28
d432 2
d441 1
a441 1
	    return true;
d444 4
d449 4
a452 1
	    return false;
d454 3
d535 1
a535 1
    void unconfigure_gprof (const string &gprof_spec, sid::host_int_4 num_cycles)
a542 26
#if 0 // can't happen?
	// If 'cycles' was specified on the --gprof option, then
	// first, sample the address of the branch which caused
	// the reconfig for the given number of cycles.
	if (num_cycles && last_caller && gprof_spec.size () > 6)
	  {
	    vector<string> parts = tokenize (gprof_spec.substr (6), ",");
	    if (parts.size () > 1)
	      {
		p = gprof->find_pin ("sample");
		if (p)
		  {
		    std::string save_pc = this->attribute_value ("pc");
		    if (! save_pc.empty ())
		      {
			sid::component::status s = this->set_attribute_value ("pc", make_numeric_attribute (last_caller));
			if (s == sid::component::ok)
			  for (int i = 0; i < num_cycles; ++i)
			    p->driven (1);
			this->set_attribute_value ("pc", save_pc);
		      }
		  }
	      }
	  }
#endif

d548 2
d554 1
a554 1
    void configure_gprof ()
d575 16
d603 3
d623 1
a623 1
	      configure_gprof ();
d625 1
a625 1
	      unconfigure_gprof (config, num_cycles);
d635 5
a639 1
	      step_insn_count = n;
d885 1
d905 1
d930 1
@


1.34
log
@2006-03-27  Frank Ch. Eigler  <fche@@elastic.org>

	* sidcpuutil.h (basic_cpu::{read,write}_watchpoint_memory): Remove
	extra class qualification.
	* sidattrutil.h (configurable_component::nothing): Ditto.
@
text
@d3 1
a3 1
// Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005 Red Hat.
d357 1
a357 1
    void cg_profile (sid::host_int_4 caller, sid::host_int_4 callee)
d376 1
a376 1
    void cg_profile_jump (sid::host_int_4 caller, sid::host_int_4 callee)
d650 12
@


1.33
log
@2005-11-14  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (basic_cpu::pin_factory): Parse, recognize and add
        watchable register and virtual pin for names representing hardware
        watchpoints.
        (read_data_memory_*): Make accessible as virtual methods from basic_cpu.
        (read_watchpoint_memory): New method of basic_cpu.
@
text
@d778 1
a778 1
    virtual std::string basic_cpu::read_watchpoint_memory (std::pair<sid::host_int_4,sid::host_int_4> addr_and_length)
d819 1
a819 1
    virtual sid::component::status basic_cpu::write_watchpoint_memory (std::pair<sid::host_int_4,sid::host_int_4> addr_and_length, const std::string &value)
@


1.32
log
@2005-08-23  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (step_pin_handler): Don't call configure_gprof here.
        (unconfigure_gprof): Check gprof_configured_p.
        (configure_gprof): Check gprof_configured_p.
        (configure_gprof_p): Removed.
        (gprof_spec): Removed.
        (configure): Call configure_gprof here.
@
text
@d144 41
a184 1
	return this->triggerpoint_manager.create_virtual_pin (name);
d763 5
d778 46
a1040 2


@


1.31
log
@2005-08-19  Dave Brolley  <brolley@@redhat.com>

        * Contribute the following changes:

        2005-07-13  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (num_cycles): New member of basic_cpu.
        (step_pin_handler): Call configure_gprof.
        (cg_profile): Call last_caller and last_callee.
        (cg_profile_jump): Call last_caller and last_callee.
        (configure_gprof): New method of basic_cpu.
        (unconfigure_gprof): New method of basic_cpu.
        (gprof_configured_p,configure_gprof_p,last_caller,last_callee)
        (pprof_spec): New members of basic_cpu.
        (configure): Call configure_gprof.
        (basic_cpu): Initialize gprof_configured_p, configure_gprof_p,
        last_caller and last_callee.
        * sidattrutil.h (configurable_component): Moved here ...
        * sidcomputil.h (configurable_component): ... from here.
        * sidbusutil.h (bus_arbitrator): Inherit from no_relation_component.

        2005-06-24  Dave Brolley  <brolley@@redhat.com>

        * sidattrutil.h (fixed_attribute_map_with_logging_component):
        Initialize buffer_output to false.

        2005-06-21  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (basic_cpu::configure): Call update_final_insn_count_p
        after processing "final-insn-count".

        2005-06-06  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (print_final_insn_count_p): New member of basic_cpu.
        (print_insn_summary): Check print_final_insn_count_p.
        (update_final_insn_count_p): New method of basic_cpu.
        (core_probe,main); New members of basic_cpu.
        (basic_cpu::configure): Handle insn-count, verbose, trace-core,
        trace-counter, trace-extract, trace-semantics and final-insn-count.
        (stream_state): Stream print_final_insn_count_p.
        (destream_state): Destream print_final_insn_count_p.
        (basic_cpu): Initialize core_probe and main. Initialize
        print_final_insn_count_p. Add final-insn-count? using
        add_attribute_notify. Add relations core-probe and main.
        * sidcomputil.h (configurable_component::configure_pin_handler): Now
        virtual.

        2005-05-29  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (basic_cpu): New inherits from configurable_component.
        (cg_jump_pin,cg_return_pin): New members of basic_cpu.
        (cg_profile_jump): New method of basic_cpu.
        (configure): New virtual override on basic_cpu.
        (basic_cpu): Initialize gprof. Add cg-return and cg-jump pins. Add
        gprof relation.
        * sidcomputil.h (configurable_component): New mix-in class for component
s.
        * sidattrutil.h (sidcomputil.h): #include it.
        (fixed_attribute_map_with_logging_component): Inherit from
        configurable_component.
        (configure): New virtual override in
        fixed_attribute_map_with_logging_component.
@
text
@a272 3
	if (UNLIKELY (! gprof_configured_p && configure_gprof_p))
	  configure_gprof ();

d450 1
a450 1
    void unconfigure_gprof (sid::host_int_4 num_cycles)
d452 3
d456 5
a460 1
	// First sample the address of the branch which caused
d462 1
a462 2
	sid::pin *p;
	if (num_cycles && last_caller)
d464 2
a465 2
	    p = gprof->find_pin ("sample");
	    if (p)
d467 2
a468 2
		std::string save_pc = this->attribute_value ("pc");
		if (! save_pc.empty ())
d470 9
a478 8
		    sid::component::status s = this->set_attribute_value ("pc", make_numeric_attribute (last_caller));
		    if (s == sid::component::ok)
		      do
			{
			  p->driven (1);
			  --num_cycles;
			} while (num_cycles);
		    this->set_attribute_value ("pc", save_pc);
d482 1
a482 3

	// Then get gprof to reconfigure itself.
	gprof->set_attribute_value ("configure!", gprof_spec);
a484 2
	assert (! configure_gprof_p);
	assert (gprof_configured_p);
d488 2
a489 1
	if (p) cg_callee_pin.disconnect (p); 
d495 4
a498 1
	// First get gprof to reconfigure itself.
a499 5
	gprof->set_attribute_value ("configure!", gprof_spec);

	// Then connect the call graph notification pins.
	assert (configure_gprof_p);
	assert (! gprof_configured_p);
d513 1
a522 2
    bool gprof_configured_p;
    bool configure_gprof_p;
d525 1
a525 1
    string gprof_spec;
d539 7
a545 8
	    gprof_spec = config;
	    // Set a flag to configure the gprof component the next time
	    // our step! pin is driven....
	    configure_gprof_p = (config.size () > 6);
	    // ... unless we are unconfiguring the gprof, in which
	    // case do it now.
	    if (gprof_configured_p && ! configure_gprof_p)
	      unconfigure_gprof (num_cycles);
a753 2
      gprof_configured_p (false),
      configure_gprof_p (false),
d756 1
@


1.30
log
@2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (read_insn_memory): Only call
        record_insn_memory_read_latency if --trace-counter or
        --final-insn-count are specified.
        (write_insn_memory): Ditto.
        (read_data_memory): Ditto.
        (write_data_memory): Ditto.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (record_insn_memory_read_latency): New virtual method.
        (record_insn_memory_write_latency): New virtual method.
        (record_data_memory_read_latency): New virtual method.
        (record_data_memory_write_latency): New virtual method.
        (read_insn_memory): Call record_insn_memory_read_latency.
        (write_insn_memory): Call record_insn_memory_write_latency.
        (read_data_memory): Call record_data_memory_read_latency.
        (write_data_memory): Call record_data_memory_write_latency.
        * sidattrutil.h (fixed_attribute_map_with_logging_component::check_level):
        now protected and returns bool.
        * sidblockingutil.h: Rework ulog levels.
        * sidbusutil.h (bus_arbitrator): Rework ulog levels. Return the result
        of busy_status instead of bus::busy. New methods: busy_status and
        access_latency.
        (perform_read): Only call set_route_busy is status is bus::ok.
        (perform_write): Only call set_route_busy is status is bus::ok.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * sidbusutil.h (bus_arbitrator::input_interface): New class.
        (bus_arbitrator::reschedule): Reschedule after the given number of
        cycles.
        (bus_arbitrator::arbitrate_read): New method.
        (bus_arbitrator::arbitrate_write): New method.
        (bus_arbitrator::prioritize_request): New virtual method.
        (bus_arbitrator::perform_read): Propogate the lock from the upstream
        interface to the downstream interface.
        (bus_arbitrator::perform_write): Ditto.
        (bus_arbitrator::lock_downstream): New virtual method.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * sidblockingutil.h (blocking_component): Reimplement using mutexes
        for synchronization.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (basic_cpu): Inherit virtually from all base classes.
        (basic_cpu::step_pin_handler): Now virtual.
        (basic_cpu::{read,write}_{insn,data}_memory): No longer const. Call
        handle_{insn,data}_memory_{read,write}_error for bus errors.
        (basic_big_endian_cpu::{read,write_{insn,data}_memory*): No longer
        const.
        (basic_little_endian_cpu): Ditto.
        * sidcomp.h (bus::status_t): Add 'busy'.
        * sidattrutil.h: Remove unused code.
        * sidblockingutil.h: New header.
@
text
@d3 1
a3 1
// Copyright (C) 1999-2004 Red Hat.
d108 2
a109 1
		   protected virtual fixed_bus_map_component
d210 1
d214 2
d264 1
d273 3
d294 1
a294 1
	sid::host_int_4 num_cycles =
d298 1
d312 3
a314 2
	std::cerr << "instruction count: " << this->total_insn_count << "  "
		  << "simulated cycles: " << this->total_latency + this->total_insn_count << std::endl;
d322 2
d339 6
d402 6
d453 160
a612 1
    
d630 1
d656 1
d755 8
a762 1
      trace_pin (this, & basic_cpu::trace_pin_handler)
d782 2
d822 9
a830 1
	add_attribute ("final-insn-count?", & this->final_insn_count_p, "setting");
@


1.29
log
@	* compLoader.cxx (generic_loader):  Add eflags_pin.
	(elf_loader): Add eflags.
	(load_it): Set eflags.
	* elfload.c (readElfFile): Add eflags.
	* sidcpuutil.h (basic_cpu): Add eflags_set_pin, set_eflags.
	* commonCfg.cxx (add_cpu):  Add eflags-set pin.
@
text
@d104 5
a108 5
		   protected fixed_pin_map_component,
		   protected fixed_accessor_map_component,
		   protected fixed_attribute_map_component,
		   protected fixed_relation_map_component,
		   protected fixed_bus_map_component
d263 1
a263 1
    void step_pin_handler (sid::host_int_4)
d533 1
a533 1
    BigOrLittleInt read_insn_memory (sid::host_int_4 pc, sid::host_int_4 address, BigOrLittleInt) const;
d535 1
a535 1
    BigOrLittleInt write_insn_memory (sid::host_int_4 pc, sid::host_int_4 address, BigOrLittleInt value) const;
d537 1
a537 1
    BigOrLittleInt read_data_memory (sid::host_int_4 pc, sid::host_int_4 address, BigOrLittleInt) const;
d539 11
a549 1
    BigOrLittleInt write_data_memory (sid::host_int_4 pc, sid::host_int_4 address, BigOrLittleInt value) const;
d655 1
a655 1
    BigOrLittleInt basic_cpu::read_insn_memory (sid::host_int_4 pc, sid::host_int_4 address, BigOrLittleInt) const
a656 1
	BigOrLittleInt value;
d658 17
a674 7
	if (LIKELY(this->insn_bus))
	  s = this->insn_bus->read (address, value);
	else
	  s = sid::bus::unmapped;
	total_latency += s.latency;
	if (LIKELY(s == sid::bus::ok))
	  return value;
d680 1
a680 1
    BigOrLittleInt basic_cpu::write_insn_memory (sid::host_int_4 pc, sid::host_int_4 address, BigOrLittleInt value) const
d683 16
a698 7
	if (LIKELY(this->insn_bus))
	  s = this->insn_bus->write (address, value);
	else
	  s = sid::bus::unmapped;
	total_latency += s.latency;
	if (LIKELY(s == sid::bus::ok))
	  return value;
d704 1
a704 1
    BigOrLittleInt basic_cpu::read_data_memory (sid::host_int_4 pc, sid::host_int_4 address, BigOrLittleInt) const
a705 1
	BigOrLittleInt value;
d707 17
a723 7
	if (LIKELY(this->data_bus))
	  s = this->data_bus->read (address, value);
	else
	  s = sid::bus::unmapped;
	total_latency += s.latency;
	if (LIKELY(s == sid::bus::ok))
	  return value;
d729 1
a729 1
    BigOrLittleInt basic_cpu::write_data_memory (sid::host_int_4 pc, sid::host_int_4 address, BigOrLittleInt value) const
d732 16
a747 7
	if (LIKELY(this->data_bus))
	  s = this->data_bus->write (address, value);
	else
	  s = sid::bus::unmapped;
	total_latency += s.latency;
	if (LIKELY(s == sid::bus::ok))
	  return value;
d770 1
a770 1
    sid::host_int_1 read_insn_memory_1 (sid::host_int_4 pc, sid::host_int_4 address) const
d775 1
a775 1
    sid::host_int_2 read_insn_memory_2 (sid::host_int_4 pc, sid::host_int_4 address) const
d780 1
a780 1
    sid::host_int_4 read_insn_memory_4 (sid::host_int_4 pc, sid::host_int_4 address) const
d785 1
a785 1
    sid::host_int_8 read_insn_memory_8 (sid::host_int_4 pc, sid::host_int_4 address) const
d790 1
a790 1
    void write_insn_memory_1 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_1 value) const
d795 1
a795 1
    void write_insn_memory_2 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_2 value) const
d800 1
a800 1
    void write_insn_memory_4 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_4 value) const
d805 1
a805 1
    void write_insn_memory_8 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_8 value) const
d810 1
a810 1
    sid::host_int_1 read_data_memory_1 (sid::host_int_4 pc, sid::host_int_4 address) const
d815 1
a815 1
    sid::host_int_2 read_data_memory_2 (sid::host_int_4 pc, sid::host_int_4 address) const
d820 1
a820 1
    sid::host_int_4 read_data_memory_4 (sid::host_int_4 pc, sid::host_int_4 address) const
d825 1
a825 1
    sid::host_int_8 read_data_memory_8 (sid::host_int_4 pc, sid::host_int_4 address) const
d830 1
a830 1
    void write_data_memory_1 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_1 value) const
d835 1
a835 1
    void write_data_memory_2 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_2 value) const
d840 1
a840 1
    void write_data_memory_4 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_4 value) const
d845 1
a845 1
    void write_data_memory_8 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_8 value) const
d866 1
a866 1
    sid::host_int_1 read_insn_memory_1 (sid::host_int_4 pc, sid::host_int_4 address) const
d871 1
a871 1
    sid::host_int_2 read_insn_memory_2 (sid::host_int_4 pc, sid::host_int_4 address) const
d876 1
a876 1
    sid::host_int_4 read_insn_memory_4 (sid::host_int_4 pc, sid::host_int_4 address) const
d881 1
a881 1
    sid::host_int_8 read_insn_memory_8 (sid::host_int_4 pc, sid::host_int_4 address) const
d886 1
a886 1
    void write_insn_memory_1 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_1 value) const
d891 1
a891 1
    void write_insn_memory_2 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_2 value) const
d896 1
a896 1
    void write_insn_memory_4 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_4 value) const
d901 1
a901 1
    void write_insn_memory_8 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_8 value) const
d906 1
a906 1
    sid::host_int_1 read_data_memory_1 (sid::host_int_4 pc, sid::host_int_4 address) const
d911 1
a911 1
    sid::host_int_2 read_data_memory_2 (sid::host_int_4 pc, sid::host_int_4 address) const
d916 1
a916 1
    sid::host_int_4 read_data_memory_4 (sid::host_int_4 pc, sid::host_int_4 address) const
d921 1
a921 1
    sid::host_int_8 read_data_memory_8 (sid::host_int_4 pc, sid::host_int_4 address) const
d926 1
a926 1
    void write_data_memory_1 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_1 value) const
d931 1
a931 1
    void write_data_memory_2 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_2 value) const
d936 1
a936 1
    void write_data_memory_4 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_4 value) const
d941 1
a941 1
    void write_data_memory_8 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_8 value) const
d994 1
a994 1
    sid::host_int_1 read_insn_memory_1 (sid::host_int_4 pc, sid::host_int_4 address) const
d1002 1
a1002 1
    sid::host_int_2 read_insn_memory_2 (sid::host_int_4 pc, sid::host_int_4 address) const
d1010 1
a1010 1
    sid::host_int_4 read_insn_memory_4 (sid::host_int_4 pc, sid::host_int_4 address) const
d1018 1
a1018 1
    sid::host_int_8 read_insn_memory_8 (sid::host_int_4 pc, sid::host_int_4 address) const
d1026 1
a1026 1
    void write_insn_memory_1 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_1 value) const
d1034 1
a1034 1
    void write_insn_memory_2 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_2 value) const
d1042 1
a1042 1
    void write_insn_memory_4 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_4 value) const
d1050 1
a1050 1
    void write_insn_memory_8 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_8 value) const
d1058 1
a1058 1
    sid::host_int_1 read_data_memory_1 (sid::host_int_4 pc, sid::host_int_4 address) const
d1066 1
a1066 1
    sid::host_int_2 read_data_memory_2 (sid::host_int_4 pc, sid::host_int_4 address) const
d1074 1
a1074 1
    sid::host_int_4 read_data_memory_4 (sid::host_int_4 pc, sid::host_int_4 address) const
d1082 1
a1082 1
    sid::host_int_8 read_data_memory_8 (sid::host_int_4 pc, sid::host_int_4 address) const
d1090 1
a1090 1
    void write_data_memory_1 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_1 value) const
d1098 1
a1098 1
    void write_data_memory_2 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_2 value) const
d1106 1
a1106 1
    void write_data_memory_4 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_4 value) const
d1114 1
a1114 1
    void write_data_memory_8 (sid::host_int_4 pc, sid::host_int_4 address, sid::host_int_8 value) const
@


1.28
log
@2004-03-22  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (trace_pin): New member of basic_cpu.
        (trace_pin_handler): New method of basic_cpu.
        (basic_cpu): Add and initialize trace_pin.
@
text
@d410 3
d556 1
d582 1
d714 1
d811 1
@


1.27
log
@2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * sidbusutil.h (passthrough_bus::target): Now 'protected'.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        For Stan Cox  <scox@@redhat.com>
        * sidmiscutil.h (logger): New class.
        * sidattrutil.h (fixed_attribute_map_with_logging_component): Convert
        to use logger.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (set_total_latency): New method of basic_cpu.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * sidattrutil.h (SID_LOG_PERSISTENT_BUFFER): New macro.
        (SID_LOG_TRANSIENT_MALLOC_BUFFER): New macro.
        (buffer_output): New member of
        fixed_attribute_map_with_logging_component.
        (fixed_attribute_with_logging_component): Add buffer-output attribute.
        Use SID_LOG_PERSISTENT_BUFFER.
        (~fixed_attribute_with_logging_component): Use
        SID_LOG_PERSISTENT_BUFFER.
        (log): Buffer output based on buffer_output. Use
        SID_LOG_TRANSIENT_MALLOC_BUFFER.
        * sidcpuutil.h (get_total_latency): New method of basic_cpu.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * sidattrutil.h (log): Don't use STDCTYPE for vsnprint or vasprintf.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        For Stan Cox  <scox@@redhat.com>
        * sidmiscutil.h (bijection::find): Add typename.
        * sidbusutil.h (ro_value_control_register): New ValueType typedef.
        (control_register_bus::word_write, control_register_bus::word_read):
        Add typename

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * sidattrutil.h (iostream): #include it.
        (log): Use std::cerr and std::endl.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * sidattrutil.h (fixed_attribute_map_with_logging_component):
        Initialize saved_messages and saved_levels.
        (~fixed_attribute_map_with_logging_component): Output saved messages.
        Delete buffer if necessary.
        (log): Save message for later if output pin not connected. Otherwise
        output saved messages before the new message. Use vsnprintf or
        vasprintf if possible.
        (check_level): New member of fixed_attribute_map_with_logging_component.
        (output_saved_messages): Ditto.
@
text
@d3 1
a3 1
// Copyright (C) 1999, 2000, 2001, 2002, 2003 Red Hat.
d216 1
d248 5
d555 2
a556 1
      trace_filename ("-") // standard output
d581 1
@


1.26
log
@003-08-21  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (end_line): New method of basic_cpu::cpu_trace_stream.
        (operator<<): Use static_cast instead of dynamic_cast.
@
text
@d237 1
d239 3
d323 1
d325 1
@


1.25
log
@2003-04-16  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (final_insn_count_p): New member of basic_cpu.
        (update_total_latency): New method of basic_cpu.
        (stream_state): Output final_insn_count_p.
        (destream_state): Input final_insn_count_p.
        (basic_cpu): Add attribute final-insn-count.
@
text
@d230 7
d621 1
a621 1
	dynamic_cast <std::ofstream&> (s) << t;
@


1.24
log
@2003-01-15  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (sidutil): Add total_insn_count when computing
        simulated cycles.
@
text
@d242 1
d311 3
d424 1
d449 1
d591 2
@


1.23
log
@2002-11-29  Ben Elliston  <bje@@redhat.com>

	* sidcpuutil.h (basic_cpu::print_insn_summary_pin): New pin.
	(basic_cpu::print_insn_summary): New virtual method.
	(basic_cpu::basic_cpu): Construct print_insn_summary_pin and
	instantiate it with add_pin().
@
text
@d3 1
a3 1
// Copyright (C) 1999, 2000, 2001, 2002 Red Hat.
d286 1
a286 1
		  << "simulated cycles: " << this->total_latency << std::endl;
@


1.22
log
@* gcc 3.2 compatibility fixes

[e.g. include/ChangeLog]
2002-11-22  Frank Ch. Eigler  <fche@@redhat.com>

	* sidattrutil.h: Give up on hash tables - too many incompatible
	libstdc++'s out there.
	* configure.in: Don't bother looking for hash stuff.
	* configure, sidconfutil.in: Regenerated.
	* sidmiscutil.h: Add some "typename" qualifiers.
	* sidcpuutil.h (cpu_trace_stream): Trade publicness for friendliness
	regarding cout_p.

[e.g., component/parport/ChangeLog]
2002-11-22  Frank Ch. Eigler  <fche@@redhat.com>

	* ps2.cxx (parport_inputpin): Fix formal arg list.

[e.g., component/interrupt/ChangeLog]
2002-11-22  Frank Ch. Eigler  <fche@@redhat.com>

	* components.cxx (compInterruptDelete): Avoid dynamic_cast on
	deleted pointer.
@
text
@d203 1
d283 5
d524 1
d550 1
@


1.21
log
@* better c++ standard compliance

[e.g.]
[include/ChangeLog]
2002-11-11  Frank Ch. Eigler  <fche@@redhat.com>

        * sidcpuutil.h (cpu_trace_stream): Add some std:: qualifiers.

[component/glue/ChangeLog]
2002-11-11  Frank Ch. Eigler  <fche@@redhat.com>

        * glue.cxx (bus_prober): Dtor throw() fixes.
@
text
@a228 1
    private:
a229 3

      template <typename T> friend
      basic_cpu::cpu_trace_stream& operator<< (basic_cpu::cpu_trace_stream& s, T t);
@


1.20
log
@2002-10-03  Dave Brolley  <brolley@@redhat.com>
       From Ben Elliston  <bje@@redhat.com>

	* sidcpuutil.h (basic_cpu::disassembler_bus): New accessor.
	(basic_cpu::basic_cpu): Initialise; register "disassembler-memory".
@
text
@d600 1
a600 1
	cout << t;
d602 1
a602 1
	dynamic_cast <ofstream&> (s) << t;
@


1.19
log
@2002-04-23  Ben Elliston  <bje@@redhat.com>

	* sidcpuutil.h (basic_cpu::update_trace_destination): Open trace
	file in append mode.  Prefix trace session data with "start of
	trace" text.
@
text
@d499 1
d534 2
@


1.18
log
@* add "trace-filename" attribute to cgen-cpu components.

[include/ChangeLog]
2002-03-14  Ben Elliston  <bje@@redhat.com>

	* sidcpuutil.h (class basic_cpu): Add trace_filename member and a
	new cpu_trace_stream inner class, derived from an ofstream.
	(basic_cpu::trace_stream): Use a cpu_trace_stream.
	(basic_cpu::update_trace_destination): New method.
	(basic_cpu ctor): Initialise trace_stream and trace_filename. Add
	attribute "trace-filename" that notifies update_trace_destination.
	(operator <<): Add global function for cpu_trace_stream insertion.

[component/cgen-cpu/ChangeLog]
2002-03-14  Ben Elliston  <bje@@redhat.com>

	* common-xml/behavior.xml (tracing): New behavior section.
	* common-xml/interface.xml (trace-filename): New attribute.
	(trace-extract?): Associate with "tracing" behavior.
	(trace-result?): Likewise.
@
text
@d226 1
a226 1
	std::ofstream::open (filename.c_str ());
d343 1
@


1.17
log
@* step-out-of-range packet support

[sid/include]
2002-02-12  Frank Ch. Eigler  <fche@@redhat.com>

	* sidcpuutil.h (basic_cpu ctor): Add full gdb-register-pc attribute.
	(basic_cpu add_watchable_register): Associate watchable with raw
	Value*, not attribute string.

[sid/component/gdb]
2002-02-11  Frank Ch. Eigler  <fche@@redhat.com>

	* gdb.cxx (rangestep_program_hook, rangestep_program): New functions.
	(process_set_pc): Implement.
	(gdb ctor): Support new attribute "enable-E-packet?", default true.
	(cpu_trap_handler): When rangestepping, keep CPU going as needed.
	(exit_program, break_program, singlestep_program): Clear
	range-stepping variables.
	(continue_program, stop_handler, trapstop_handler): Ditto.
	* gdb.h: Corresponding changes.
	* gdbserv-state.c (gdbserv_data_packet): Implement support for
	'E'/'e' packets through new rangestep_program target hook.
	(gdbserv_fromtarget_break): Discard pending output packet.
	* gdbserv-state.h: Corresponding changes.
@
text
@d3 1
a3 1
// Copyright (C) 1999, 2000, 2001 Red Hat.
d211 28
d246 1
a246 1
    std::ostream& trace_stream;
d334 16
a518 1
      trace_stream (std::cout),
d523 3
a525 1
      debugger_bus (& this->data_bus)
d558 3
d592 10
@


1.16
log
@* --trace-counter extensions

[bsp]
2001-12-27  Frank Ch. Eigler  <fche@@redhat.com>

	* configrun-sid.in: Make cpu<->sched pin connections for time queries.

[component/cgen-cpu]
2001-12-27  Frank Ch. Eigler  <fche@@redhat.com>

	* cgen-cpu.h (cgen_bi_endian_cpu): Make trace_count a host_int_8.
	* compCGEN.cxx (cgen_read_memory): Don't distort memory latency

[include]
2001-12-27  Frank Ch. Eigler  <fche@@redhat.com>

	* sidcpuutil.h (basic_cpu): Add scheduler_time_query member.
	Add flush_icache(PC) virtual function.

[bsp/pregen]
2001-12-27  Frank Ch. Eigler  <fche@@redhat.com>

	* ALL.conf: Regenerated with cpu/sched etc. changes.
@
text
@d163 1
a163 1
      this->triggerpoint_manager.add_watchable_attribute (name);
d425 1
a425 1
	this->triggerpoint_manager.add_watchable_value ("gdb-register-pc", pc);
@


1.15
log
@	Changes to many generated files -- incorporate bochs into
	build system and configrun-sid.
@
text
@d16 1
d131 5
d200 1
a200 1
  private:
d324 2
d327 1
a327 1
    void flush_icache_pin_handler(sid::host_int_4 v) { this->flush_icache(); }
d471 1
@


1.14
log
@* call graph profiling support

[sid/bsp]
2001-11-08  Frank Ch. Eigler  <fche@@redhat.com>

	* configrun-sid.in (gprof): Connect call-graph pins.

[sid/include]
2001-11-08  Frank Ch. Eigler  <fche@@redhat.com>

	* sidcpuutil.h (basic_cpu): Add cg caller/callee pins, trace_stream
	fields.
	(basic_cpu ctor): Initialize them.
	(cg_profile): New function.

[sid/component/cgen-cpu]
2001-11-08  Frank Ch. Eigler  <fche@@redhat.com>

	* cgen-cpu.h (cgen_bi_endian_cpu): Remove trace_stream field: it's
	in basic_cpu now.
	* compCGEN.cxx: Corresponding change.

[sid/component/profiling]
2001-11-08  Frank Ch. Eigler  <fche@@redhat.com>

	* gprof.cxx (gprof_component): Add cg caller/callee pins, cg_count_map
	field.
	(accumulate_call): New function.
	(reset): Clear cg map.
	(store): Emit call graph info.  Emit histogram iff nonempty.
	* sw-profile-gprof.xml: Document call graph functionality.
	* sw-profile-gprof.txt: Regenerated.
@
text
@d420 1
a420 1
	// The "expedited" register list string is the list of
d426 1
@


1.13
log
@* cleanup++

2001-10-04  Frank Ch. Eigler  <fche@@redhat.com>

        * sidcpuutil.h (basic_cpu ctor): Initialize those tracing flags.
@
text
@d203 2
d212 1
d256 17
d465 1
d486 2
@


1.12
log
@* cleanup

2001-10-04  Frank Ch. Eigler  <fche@@redhat.com>

        * sidcpuutil.h (update_trace_result_p): New function.
        ({get,set}_trace_{sem,disasm,count,result}): Removed functions.
        (basic_cpu ctor): Use plain attributes or notify-attributes,
        not general virtual ones for the various tracing flags.
@
text
@d480 1
d482 1
d486 1
d492 1
d494 1
@


1.11
log
@2001-05-29  matthew green  <mrg@@redhat.com>

	* sidcpuutil.h (trace_disass_p, trace_semantics_p, trace_counter_p):
	New bools controlling disassembly tracing, semantic tracing (what
	was trace_result_p), and counter tracing, respectively.
	(set_trace_sem, get_trace_sem, set_trace_disasm, get_trace_disasm,
	set_trace_count, get_trace_count, get_trace_result): New methods,
	mostly for compatibility with old CPU components that use
	trace_result_p for what is now trace_semantics_p.  Remove later.
	(stream_state, destream_state): Handle trace_disass_p,
	trace_semantics_p and trace_counter_p.
	(basic_cpu ctor): New virtual attributes `trace-semantics?',
	`trace-disassemble?', `trace-counter?'. `trace-result?' is now
	virtual, and acts as if `trace-semantics?' was set.
	Much of the above can be undone when all CPU ports are converted to
	use trace_result_p in the new method.

2001-11-17  Jeff Johnston <jjohnstn@@redhat.com>

        * sidbusutil.h (passthrough_word_bus): Changed do_direct_passthrough
        to use reference parameter so address can be modified by routine.
@
text
@d280 4
a283 2
    component::status
    set_trace_sem (const string &s)
d285 1
a285 57
      if (s == "1")
        trace_semantics_p = true;
      else if (s == "0")
        trace_semantics_p = false;
      else
	return sid::component::bad_value;
      trace_result_p = (trace_semantics_p || trace_disass_p);
      return sid::component::ok;
    }

    string
    get_trace_sem ()
    {
      return trace_semantics_p ? "1" : "0";
    }

    component::status
    set_trace_disasm (const string& s)
    {
      if (s == "1")
        trace_disass_p = true;
      else if (s == "0")
        trace_disass_p = false;
      else
	return sid::component::bad_value;
      trace_result_p = (trace_semantics_p || trace_disass_p);
      return sid::component::ok;
    }

    string
    get_trace_disasm ()
    {
      return trace_disass_p ? "1" : "0";
    }

    component::status
    set_trace_count (const string& s)
    {
      if (s == "1")
        trace_counter_p = true;
      else if (s == "0")
        trace_counter_p = false;
      else
	return sid::component::bad_value;
      return sid::component::ok;
    }

    string
    get_trace_count ()
    {
      return trace_counter_p ? "1" : "0";
    }

    string
    get_trace_result ()
    {
      return trace_result_p ? "1" : "0";
d481 5
a485 3
	add_attribute_virtual ("trace-semantics?", this,
			       & basic_cpu::set_trace_sem, 
			       & basic_cpu::get_trace_sem, 
d489 2
a490 12
	add_attribute_virtual ("trace-result?", this,
			       & basic_cpu::set_trace_sem, 
			       & basic_cpu::get_trace_sem, 
			       "setting");
	add_attribute_virtual ("trace-disassemble?", this,
			       & basic_cpu::set_trace_disasm, 
			       & basic_cpu::get_trace_disasm, 
			       "setting");
	add_attribute_virtual ("trace-counter?", this,
			       & basic_cpu::set_trace_count, 
			       & basic_cpu::get_trace_count, 
			       "setting");
@


1.10
log
@* make it compile with GCC 3.0:
        - missing throw() specifiers in bus & component dtors
	- `std::' vs `::' namespace issues
@
text
@d206 3
d280 62
d396 3
d420 3
d535 18
a552 1
	add_attribute ("trace-result?", & trace_result_p, "setting");
d555 1
a555 1
    virtual ~basic_cpu() throw() {} 
@


1.9
log
@* GCC 3.0 & 2.95.3 fixes.

[component/audio/ChangeLog]
	* compAudio.cxx (fd_audio): Add missing throw() specifiers to this dtor.
	* components.h (basic_codec, generic_audio, nop_audio, fd_audio,
	linux_audio, solaris_audio): Add missing throw() specifiers to these
	dtors.

[component/cfgroot/ChangeLog]
	* compConfig.cxx (cfgroot_component): Add missing throw() specifiers
	to this dtor.

[component/tcl/ChangeLog]
	* compTcl.cxx (tcl_component): Add missing throw() specifiers to this
	dtor.

[include/ChangeLog]
	* sidattrutil.h (attribute_coder_base, attribute_coder_virtual,
	attribute_coder_alias, attribute_coder_virtual_parameterized,
	attribute_coder, attribute_coder_ro, attribute_coder_ro_value,
	attribute_coder_bus_rw, attribute_coder_bus_wo,
	fixed_attribute_map_component): Add missing throw() specifiers
	to these dtors.
	* sidbusutil.h (word_bus, passthrough_bus, mux_passthrough_bus,
	passthrough_word_bus, harvard_bus, byte_bus, callback_byte_bus,
@
text
@d113 1
a113 1
      void* p = std::operator new (sz);
d123 1
a123 1
      std::operator delete (p);
@


1.8
log
@2001-07-06  Ben Elliston  <bje@@redhat.com>

	* sidcpuutil.h: Use std::string for C++ conformance.
@
text
@d467 1
a467 1
    ~basic_cpu() {}
d484 5
a488 2
	sid::bus::status s = 
	  (LIKELY(this->insn_bus)) ? this->insn_bus->read (address, value) : sid::bus::unmapped;
d499 5
a503 2
	sid::bus::status s = 
	  (LIKELY(this->insn_bus)) ? this->insn_bus->write (address, value) : sid::bus::unmapped;
d515 5
a519 2
	sid::bus::status s = 
	  (LIKELY(this->data_bus)) ? this->data_bus->read (address, value) : sid::bus::unmapped;
d530 5
a534 2
	sid::bus::status s = 
	  (LIKELY(this->data_bus)) ? this->data_bus->write (address, value) : sid::bus::unmapped;
d557 1
a557 1
    ~basic_big_endian_cpu () {}
d652 1
a652 1
    ~basic_little_endian_cpu () {}
d751 1
a751 1
    ~basic_bi_endian_cpu () {}
@


1.7
log
@2001-06-24  Ben Elliston  <bje@@redhat.com>

	* sidcpuutil.h (basic_cpu::total_latency): New member.
	(basic_cpu constructor): Initialise it.
	(basic_cpu::step_pin_handler): Include latency in cycle counts.
	(basic_cpu::latency_to_cycles): New virtual method.
	(basic_cpu::read_insn_memory): Add bus latency to total_latency.
	(basic_cpu::write_insn_memory): Ditto.
	(basic_cpu::read_data_memory): Ditto.
	(basic_cpu::write_data_memory): Ditto.
	(basic_cpu::stream_state): Add total_latency to state snapshot.
	(basic_cpu::destream_state): Likewise.
@
text
@d17 2
@


1.6
log
@* consistency fix

2001-05-30  Frank Ch. Eigler  <fche@@redhat.com>

        * sidcpuutil.h (step_pin_handler): Check for triggerpoints due right
        now, before instruction evaluation loop.
@
text
@d3 1
a3 1
// Copyright (C) 1999-2001 Red Hat.
d198 1
d218 1
d223 1
d228 5
a232 4
	sid::host_int_4 num_cycles = 
	  num_insns <= min_num_cycles ? min_num_cycles :
	  num_insns >= max_num_cycles ? max_num_cycles :
	  num_insns;
d250 6
d326 1
d347 1
d421 1
d484 1
d496 1
d509 1
d521 1
@


1.5
log
@2001-05-24  Ben Elliston  <bje@@redhat.com>

	* sidcpuutil.h (basic_cpu::create_gdb_register_attrs): Document
	the meaning of the expedited_regno_list argument.
@
text
@d3 1
a3 1
// Copyright (C) 1999, 2000 Red Hat.
d213 3
d218 2
a219 1
	this->step_insns ();
@


1.4
log
@2001-03-26  Dave Brolley  <brolley@@redhat.com>

	* sidcpuutil.h (basic_cpu::stepped): Make it virtual and public so
	it can be overridden.
@
text
@d364 8
@


1.3
log
@* branch probability hinting

[cgen/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* sid.cpu (-op-gen-set-trace[-parallel], -create-virtual-insns!):
	Emit LIKELY/UNLIKELY branch probability hints.
	* sid-decode.cpu (-gen-record-args): Ditto.

[sid/include/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* sidconfig.h (LIKELY, UNLIKELY): New conditional cover macros
	for gcc's __builtin_expect branch probability hinting function.
	* sidbusutil.h (passthrough_bus, mux_password_bus, harvard_bus):
	Add some branch probability hints.
	* sidcpuutil.h (step_pin_handler, stop_after_insns_p,
	{read,write}_{insn,data}_memory): Ditto.
	* sidpinutil.h (callback_pin::driven): Remove unnecessary assert
	from critical path.

[eg. sid/component/mapper/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* compMapper.cxx ({read,write}_strideoffset_any): Added b.p. hints.
	(write_any, read_any, locate): Ditto.

[sid/component/cgen-cpu/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* cgen-engine.h (set_pbb_engine, chain, get_next_vpc, pbb_find,
	pbb_find_or_alloc, pbb_before, pbb_after): Add branch probability
	hints.

[eg. sid/component/cgen-cpu/arm7t/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* arm-decode.cxx, -sem.cxx, -semsw.cxx: Regenerated w/ b.p. hints.
	* thumb-decode.cxx, -sem.cxx, -semsw.cxx: Ditto.
@
text
@d236 4
a242 4
    void stepped (sid::host_int_4 n)
      {
	this->step_cycles_pin.drive (n);
      }
@


1.2
log
@* robustness incentive

2001-01-10  Frank Ch. Eigler  <fche@@redhat.com>

        * sidcpuutil.h (basic_cpu): Inherit from fixed_relation_map_component.
        Define a operator new/delete pair to poison new memory.
@
text
@d208 1
a208 1
	if (! limit.ok()) return;
d246 2
a247 2
	if (this->yield_p ||
	    (this->current_step_insn_count >= this->step_insn_count))
d458 2
a459 2
	  this->insn_bus ? this->insn_bus->read (address, value) : sid::bus::unmapped;
	if (s == sid::bus::ok)
d469 2
a470 2
	  this->insn_bus ? this->insn_bus->write (address, value) : sid::bus::unmapped;
	if (s == sid::bus::ok)
d481 2
a482 2
	  this->data_bus ? this->data_bus->read (address, value) : sid::bus::unmapped;
	if (s == sid::bus::ok)
d492 2
a493 2
	  this->data_bus ? this->data_bus->write (address, value) : sid::bus::unmapped;
	if (s == sid::bus::ok)
@


1.1
log
@* public snapshot of sid simulator
@
text
@d104 1
a104 1
		   protected no_relation_component,
d107 16
@

