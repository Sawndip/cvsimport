head	1.18;
access;
symbols
	sid-snapshot-20180601:1.18
	sid-snapshot-20180501:1.18
	sid-snapshot-20180401:1.18
	sid-snapshot-20180301:1.18
	sid-snapshot-20180201:1.18
	sid-snapshot-20180101:1.18
	sid-snapshot-20171201:1.18
	sid-snapshot-20171101:1.18
	sid-snapshot-20171001:1.18
	sid-snapshot-20170901:1.18
	sid-snapshot-20170801:1.18
	sid-snapshot-20170701:1.18
	sid-snapshot-20170601:1.18
	sid-snapshot-20170501:1.18
	sid-snapshot-20170401:1.18
	sid-snapshot-20170301:1.18
	sid-snapshot-20170201:1.18
	sid-snapshot-20170101:1.18
	sid-snapshot-20161201:1.18
	sid-snapshot-20161101:1.18
	sid-snapshot-20160901:1.18
	sid-snapshot-20160801:1.18
	sid-snapshot-20160701:1.18
	sid-snapshot-20160601:1.18
	sid-snapshot-20160501:1.18
	sid-snapshot-20160401:1.18
	sid-snapshot-20160301:1.18
	sid-snapshot-20160201:1.18
	sid-snapshot-20160101:1.18
	sid-snapshot-20151201:1.18
	sid-snapshot-20151101:1.18
	sid-snapshot-20151001:1.18
	sid-snapshot-20150901:1.18
	sid-snapshot-20150801:1.18
	sid-snapshot-20150701:1.18
	sid-snapshot-20150601:1.18
	sid-snapshot-20150501:1.18
	sid-snapshot-20150401:1.18
	sid-snapshot-20150301:1.18
	sid-snapshot-20150201:1.18
	sid-snapshot-20150101:1.18
	sid-snapshot-20141201:1.18
	sid-snapshot-20141101:1.18
	sid-snapshot-20141001:1.18
	sid-snapshot-20140901:1.18
	sid-snapshot-20140801:1.18
	sid-snapshot-20140701:1.18
	sid-snapshot-20140601:1.18
	sid-snapshot-20140501:1.18
	sid-snapshot-20140401:1.18
	sid-snapshot-20140301:1.18
	sid-snapshot-20140201:1.18
	sid-snapshot-20140101:1.18
	sid-snapshot-20131201:1.18
	sid-snapshot-20131101:1.18
	sid-snapshot-20131001:1.18
	sid-snapshot-20130901:1.18
	sid-snapshot-20130801:1.18
	sid-snapshot-20130701:1.18
	sid-snapshot-20130601:1.18
	sid-snapshot-20130501:1.18
	sid-snapshot-20130401:1.18
	sid-snapshot-20130301:1.18
	sid-snapshot-20130201:1.18
	sid-snapshot-20130101:1.18
	sid-snapshot-20121201:1.18
	sid-snapshot-20121101:1.18
	sid-snapshot-20121001:1.18
	sid-snapshot-20120901:1.18
	sid-snapshot-20120801:1.18
	sid-snapshot-20120701:1.18
	sid-snapshot-20120601:1.18
	sid-snapshot-20120501:1.18
	sid-snapshot-20120401:1.18
	sid-snapshot-20120301:1.18
	sid-snapshot-20120201:1.18
	sid-snapshot-20120101:1.18
	sid-snapshot-20111201:1.18
	sid-snapshot-20111101:1.18
	sid-snapshot-20111001:1.18
	sid-snapshot-20110901:1.18
	sid-snapshot-20110801:1.18
	sid-snapshot-20110701:1.18
	sid-snapshot-20110601:1.18
	sid-snapshot-20110501:1.18
	sid-snapshot-20110401:1.18
	sid-snapshot-20110301:1.18
	sid-snapshot-20110201:1.18
	sid-snapshot-20110101:1.18
	sid-snapshot-20101201:1.18
	sid-snapshot-20101101:1.18
	sid-snapshot-20101001:1.18
	sid-snapshot-20100901:1.18
	sid-snapshot-20100801:1.18
	sid-snapshot-20100701:1.18
	sid-snapshot-20100601:1.18
	sid-snapshot-20100501:1.18
	sid-snapshot-20100401:1.18
	sid-snapshot-20100301:1.18
	sid-snapshot-20100201:1.18
	sid-snapshot-20100101:1.18
	sid-snapshot-20091201:1.18
	sid-snapshot-20091101:1.18
	sid-snapshot-20091001:1.18
	sid-snapshot-20090901:1.18
	sid-snapshot-20090801:1.18
	sid-snapshot-20090701:1.18
	sid-snapshot-20090601:1.18
	sid-snapshot-20090501:1.18
	sid-snapshot-20090401:1.18
	sid-snapshot-20090301:1.18
	sid-snapshot-20090201:1.18
	sid-snapshot-20090101:1.18
	sid-snapshot-20081201:1.18
	sid-snapshot-20081101:1.18
	sid-snapshot-20081001:1.18
	sid-snapshot-20080901:1.18
	sid-snapshot-20080801:1.18
	sid-snapshot-20080701:1.18
	sid-snapshot-20080601:1.18
	sid-snapshot-20080501:1.18
	sid-snapshot-20080403:1.18
	sid-snapshot-20080401:1.18
	sid-snapshot-20080301:1.18
	sid-snapshot-20080201:1.18
	sid-snapshot-20080101:1.18
	sid-snapshot-20071201:1.18
	sid-snapshot-20071101:1.18
	sid-snapshot-20071001:1.18
	sid-20020905-branchpoint:1.12
	sid-20020905-branch:1.12.0.2
	cygnus_cvs_20020108_pre:1.11;
locks; strict;
comment	@ * @;


1.18
date	2007.02.05.20.28.42;	author brolley;	state Exp;
branches;
next	1.17;

1.17
date	2007.01.17.20.59.33;	author brolley;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.02.18.53.10;	author brolley;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.10.15.48.22;	author brolley;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.21.21.38.24;	author brolley;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.06.20.27.49;	author fche;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.04.04.22.32;	author bje;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.04.08.18.15;	author bje;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.04.01.52.08;	author bje;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.20.17.15.41;	author fche;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.22.00.43.35;	author bje;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.04.10.26.51;	author bje;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.03.06.02.48;	author mrg;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.12.11.37.32;	author mrg;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.28.19.36.17;	author brolley;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.01.19.15.35;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.12.20.34.07;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.07.19.31.09;	author fche;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Support for Toshiba MeP.
@
text
@// sidbusutil.h -*- C++ -*- Different types and sizes of buses.

// Copyright (C) 1999, 2000, 2001, 2002, 2004, 2005, 2007 Red Hat.
// This file is part of SID and is licensed under the GPL.
// See the file COPYING.SID for conditions for redistribution.

#ifndef SIDBUSUTIL_H
#define SIDBUSUTIL_H

#include <sidconfig.h>
#include <sidtypes.h>
#include <sidcomputil.h>
#include <sidschedutil.h>
#include <sidpinutil.h>
#include <sidblockingutil.h>

#include <string>
#include <map>
#include <vector>
#include <iostream>

namespace sidutil
{
  // The word_bus converts incoming bus access calls to a particular
  // preferred size & type.  The bus object is addressable as if it
  // was memory, with no alignment/size restrictions.

  template <typename DataType>
  class word_bus: public sid::bus
  {
  protected:
    word_bus() {}
    ~word_bus() {}

    virtual sid::bus::status word_write(sid::host_int_4 addr,
					DataType mask,
					DataType data) = 0;

    virtual sid::bus::status word_read(sid::host_int_4 addr,
				       DataType mask,
				       DataType& data) = 0;

    virtual void post_access_hook() { }

    // Method writes data at address. AccDataType can be different than
    // DataType. Method itself takes care to represent data to component
    // in its required data size.
    template <typename AccDataType>
    bus::status
    writeAny(sid::host_int_4 address, AccDataType data)
      {
	unsigned busWidth = sizeof(typename DataType::value_type);
	unsigned accWidth = sizeof(typename AccDataType::value_type);

	// Make local modifiable copy.
	sid::host_int_4 a = address;

	unsigned bytesWritten = 0;
	sid::host_int_2 max_latency = 0;
	DataType d = 0;
        DataType mask = 0;
	sid::bus::status s;
	while(bytesWritten < accWidth)
	  {
	    sid::host_int_1 byte = data.read_byte(bytesWritten);
	    d.write_byte((bytesWritten + a) % busWidth, byte);
	    mask.write_byte((bytesWritten + a) % busWidth, 0xff);

	    if(((bytesWritten + a) % busWidth == (busWidth - 1)) || // last byte in target
	       (bytesWritten == (accWidth - 1))) // last byte in source
	      {

		s = this->word_write(sid::host_int_4(a / busWidth), mask, d);
		if (s != sid::bus::ok)
		  {
		    this->post_access_hook();
		    return s;
		  }
		if (s.latency > max_latency)
		  max_latency = s.latency;

		a = a + busWidth; // advance address
		// Clear data.
		d = 0;
		// Clear mask.
		mask = 0;
	      }
	    bytesWritten ++;
	  }

	this->post_access_hook();
	s.latency = max_latency;
	return s;
      }
    

    // This method is used to read data from address. Like the above
    // case AccDataType can be different than DataType. Method returns
    // ok if sucessful.
    template <typename AccDataType>
    sid::bus::status
    readAny(sid::host_int_4 address, AccDataType& data)
      {
	unsigned busWidth = sizeof(typename DataType::value_type);
	unsigned accWidth = sizeof(typename AccDataType::value_type);
	
	// Make local modifiable copy.
	sid::host_int_4 a = address;
	
	unsigned bytesRead = 0;
	unsigned bytesAddressed = 0;
	sid::host_int_2 max_latency = 0;
        DataType mask = 0;
	sid::bus::status s;
	while(bytesAddressed < accWidth)
	  {
	    mask.write_byte((bytesAddressed + a) % busWidth, 0xff);

	    if(((bytesAddressed + a) % busWidth == (busWidth - 1)) || // last byte in target
	       (bytesAddressed == (accWidth - 1))) // last byte in source
	      {
		DataType d = 0;
		s = this->word_read(sid::host_int_4(a / busWidth), mask, d);
		if (s != sid::bus::ok)
		  {
		    this->post_access_hook();
		    return s;
		  }
		if (s.latency > max_latency)
		  max_latency = s.latency;

		// Copy over newly read bytes
		while (bytesRead <= bytesAddressed)
		  {
		    assert (mask.read_byte((bytesRead + a) % busWidth) == 0xff);
		    sid::host_int_1 byte = d.read_byte((bytesRead + a) % busWidth);
		    data.write_byte(bytesRead, byte);
		    bytesRead ++;
		  }

		a = a + busWidth; // advance address
		// Clear mask.
		mask = 0;
	      }
	    
	    bytesAddressed ++;
	  }
	assert (bytesAddressed == bytesRead);

	this->post_access_hook();
	s.latency = max_latency;
	return s;
      }
    
    
    // Some macros to make manufacturing of the cartesian-product
    // calls simpler.
#define SID_GB_WRITE(type1,type2) \
      sid::bus::status write(type1 addr, type2 data) throw () \
	  { return writeAny(addr, data); }
    
#define SID_GB_READ(type1,type2) \
      sid::bus::status read(type1 addr, type2& data) throw () \
	  { return readAny(addr, data); }
    
    SID_GB_WRITE(sid::host_int_4, sid::little_int_1)
    SID_GB_WRITE(sid::host_int_4, sid::big_int_1)
    SID_GB_WRITE(sid::host_int_4, sid::little_int_2)
    SID_GB_WRITE(sid::host_int_4, sid::big_int_2)
    SID_GB_WRITE(sid::host_int_4, sid::little_int_4)
    SID_GB_WRITE(sid::host_int_4, sid::big_int_4)
    SID_GB_WRITE(sid::host_int_4, sid::little_int_8)
    SID_GB_WRITE(sid::host_int_4, sid::big_int_8)

    SID_GB_READ(sid::host_int_4, sid::little_int_1)
    SID_GB_READ(sid::host_int_4, sid::big_int_1)
    SID_GB_READ(sid::host_int_4, sid::little_int_2)
    SID_GB_READ(sid::host_int_4, sid::big_int_2)
    SID_GB_READ(sid::host_int_4, sid::little_int_4)
    SID_GB_READ(sid::host_int_4, sid::big_int_4)
    SID_GB_READ(sid::host_int_4, sid::little_int_8)
    SID_GB_READ(sid::host_int_4, sid::big_int_8)

#undef SID_GB_WRITE
#undef SID_GB_READ
  };



  template <class Master, class DataType>
  class callback_word_bus: public word_bus<DataType>
  {
  public:
    typedef sid::bus::status (Master::*ReadFunction) (sid::host_int_4, DataType, DataType&);
    typedef sid::bus::status (Master::*WriteFunction) (sid::host_int_4, DataType, DataType);

  private:
    Master* receiver;
    ReadFunction read_callback;
    WriteFunction write_callback;

    sid::bus::status word_write(sid::host_int_4 addr,
				DataType mask,
				DataType data)
      {
	return (receiver->*write_callback) (addr, mask, data);
      }

    sid::bus::status word_read(sid::host_int_4 addr,
			       DataType mask,
			       DataType& data)
      {
	return (receiver->*read_callback) (addr, mask, data);
      }

  public:
    callback_word_bus (Master* m, ReadFunction rf, WriteFunction wf):
      receiver (m), read_callback (rf), write_callback (wf) {}
  };



  // This sort of bus passes accesses through to another, specified
  // by a meta-pointer.
  class passthrough_bus: public sid::bus
  {
  public:
    passthrough_bus(sid::bus** t): target(t) 
      {
	assert (target != 0);
      }
    ~passthrough_bus() {}
    
    // Some macros to make manufacturing of the cartesian-product
    // calls simpler.
#define SID_GB_WRITE(dtype) \
      sid::bus::status write(sid::host_int_4 addr, dtype data) throw ()\
	  { if (LIKELY(*target)) return (*target)->write(addr, data); else return sid::bus::unpermitted; }

#define SID_GB_READ(dtype) \
      sid::bus::status read(sid::host_int_4 addr, dtype& data) throw ()\
	  { if (LIKELY(*target)) return (*target)->read(addr, data); else return sid::bus::unpermitted; }

    SID_GB_WRITE(sid::little_int_1)
    SID_GB_WRITE(sid::big_int_1)
    SID_GB_WRITE(sid::little_int_2)
    SID_GB_WRITE(sid::big_int_2)
    SID_GB_WRITE(sid::little_int_4)
    SID_GB_WRITE(sid::big_int_4)
    SID_GB_WRITE(sid::little_int_8)
    SID_GB_WRITE(sid::big_int_8)

    SID_GB_READ(sid::little_int_1)
    SID_GB_READ(sid::big_int_1)
    SID_GB_READ(sid::little_int_2)
    SID_GB_READ(sid::big_int_2)
    SID_GB_READ(sid::little_int_4)
    SID_GB_READ(sid::big_int_4)
    SID_GB_READ(sid::little_int_8)
    SID_GB_READ(sid::big_int_8)

#undef SID_GB_WRITE
#undef SID_GB_READ

  protected:
    sid::bus** target;
  };

  // This sort of bus passes accesses through to one of two buses which
  // are specified by meta-pointers.  Access can be switched dynamically.
  class mux_passthrough_bus: public sid::bus
  {
  public:
    mux_passthrough_bus(sid::bus** t1, sid::bus** t2)
      {
	assert (t1 != 0);
        assert (t2 != 0);
	this->dummy_target = 0;
        this->t[0] = t1;
	this->index = 0;
	this->target = t1;
        this->t[1] = t2;
      }
    ~mux_passthrough_bus() {}
    void switch_bus()
    {
      // Switch to the next bus if the current one is valid (0 or 1)
      switch (this->index) 
	{
	case 0:
	case 1:
	  this->index = 1 - this->index;
	  this->target = this->t[this->index];
	  break;

	default:
	  ;
	  // do nothing
	}
    }
    void select_bus (int i)
    {
      // Set index to 2 (error) unless i is 0 or 1
      switch (i)
	{
	case 0:
	case 1:
	  this->index = i;
	  this->target = this->t[i];
	  break;

	default:
	  this->index = 2;
	  this->target = & this->dummy_target;
	}
    }
    
    // Some macros to make manufacturing of the cartesian-product
    // calls simpler.
#define SID_GB_WRITE(dtype) \
      sid::bus::status write(sid::host_int_4 addr, dtype data) throw ()\
	  { if (LIKELY(*target)) return (*target)->write(addr, data); else return sid::bus::unmapped; }

#define SID_GB_READ(dtype) \
      sid::bus::status read(sid::host_int_4 addr, dtype& data) throw ()\
	  { if (LIKELY(*target)) return (*target)->read(addr, data); else return sid::bus::unmapped; }

    SID_GB_WRITE(sid::little_int_1)
    SID_GB_WRITE(sid::big_int_1)
    SID_GB_WRITE(sid::little_int_2)
    SID_GB_WRITE(sid::big_int_2)
    SID_GB_WRITE(sid::little_int_4)
    SID_GB_WRITE(sid::big_int_4)
    SID_GB_WRITE(sid::little_int_8)
    SID_GB_WRITE(sid::big_int_8)

    SID_GB_READ(sid::little_int_1)
    SID_GB_READ(sid::big_int_1)
    SID_GB_READ(sid::little_int_2)
    SID_GB_READ(sid::big_int_2)
    SID_GB_READ(sid::little_int_4)
    SID_GB_READ(sid::big_int_4)
    SID_GB_READ(sid::little_int_8)
    SID_GB_READ(sid::big_int_8)

#undef SID_GB_WRITE
#undef SID_GB_READ

  private:
    int index;
    sid::bus* dummy_target;
    sid::bus** target;
    sid::bus** t[2];
  };

  // The passthrough_word_bus maps memory and either directly passes through to the underlying
  // bus or else converts the incoming bus access call to a particular
  // preferred size & type.  The bus object is addressable as if it
  // was memory, with no alignment/size restrictions.

  template <class DataType>
  class passthrough_word_bus: public word_bus<DataType>
  {

  protected:

    sid::bus **target;

    passthrough_word_bus(sid::bus **t): target(t) 
      { 
	assert (target != 0);
      }
    ~passthrough_word_bus() {}

    virtual sid::bus::status word_write(sid::host_int_4 addr,
					DataType mask,
					DataType data) = 0;

    virtual sid::bus::status word_read(sid::host_int_4 addr,
				       DataType mask,
				       DataType& data) = 0;

    virtual int do_direct_passthrough (sid::host_int_4& addr) { return 0; } 

    // Some macros to make manufacturing of the cartesian-product
    // calls simpler.
#define SID_GB_WRITE(type1,type2) \
      sid::bus::status write(type1 addr, type2 data) throw () \
	  { if (do_direct_passthrough (addr)) \
               return (*target)->write(addr, data); \
               return word_bus<DataType>::write(addr, data); }
    
#define SID_GB_READ(type1,type2) \
      sid::bus::status read(type1 addr, type2& data) throw () \
	  { if (do_direct_passthrough (addr)) \
               return (*target)->read(addr, data); \
            return word_bus<DataType>::read(addr, data); }
    
    SID_GB_WRITE(sid::host_int_4, sid::little_int_1)
    SID_GB_WRITE(sid::host_int_4, sid::big_int_1)
    SID_GB_WRITE(sid::host_int_4, sid::little_int_2)
    SID_GB_WRITE(sid::host_int_4, sid::big_int_2)
    SID_GB_WRITE(sid::host_int_4, sid::little_int_4)
    SID_GB_WRITE(sid::host_int_4, sid::big_int_4)
    SID_GB_WRITE(sid::host_int_4, sid::little_int_8)
    SID_GB_WRITE(sid::host_int_4, sid::big_int_8)

    SID_GB_READ(sid::host_int_4, sid::little_int_1)
    SID_GB_READ(sid::host_int_4, sid::big_int_1)
    SID_GB_READ(sid::host_int_4, sid::little_int_2)
    SID_GB_READ(sid::host_int_4, sid::big_int_2)
    SID_GB_READ(sid::host_int_4, sid::little_int_4)
    SID_GB_READ(sid::host_int_4, sid::big_int_4)
    SID_GB_READ(sid::host_int_4, sid::little_int_8)
    SID_GB_READ(sid::host_int_4, sid::big_int_8)

#undef SID_GB_WRITE
#undef SID_GB_READ
  };

  // The harvard bus allows a single virtual memory model to be broken
  // down into data and insn memory via section numbers (top byte of address).
  // The sections for data and insn are given in the form of first section number
  // and last section number.  The bus object is addressable as if it was memory, 
  // with no alignment/size restrictions.

  class harvard_bus: public sid::bus
  {
  protected:
    sid::bus   **insn_bus;
    sid::bus   **data_bus;
    sid::host_int_4 first_data_section;
    sid::host_int_4 last_data_section;
    sid::host_int_4 first_insn_section;
    sid::host_int_4 last_insn_section;

  public:
    harvard_bus (sid::bus **d_bus, sid::bus **i_bus, 
		 sid::host_int_4 first_data, sid::host_int_4 last_data,
                 sid::host_int_4 first_insn, sid::host_int_4 last_insn):
      insn_bus (i_bus),
      data_bus (d_bus),
      first_data_section (first_data),
      last_data_section (last_data),
      first_insn_section (first_insn),
      last_insn_section (last_insn)
      { 
	assert (insn_bus != 0);
	assert (data_bus != 0);
      }
    ~harvard_bus() {}

    sid::bus *map_addr_to_bus (sid::host_int_4 *addr)
      {
	sid::host_int_4 section = *addr >> 24;

	if (section >= first_data_section && section <= last_data_section)
          {
            *addr -= first_data_section << 24;
	    return *data_bus;
          }
	if (section >= first_insn_section && section <= last_insn_section)
          {
            *addr -= first_insn_section << 24;
	    return *insn_bus;
          }
	return NULL;
      }


    // Some macros to make manufacturing of the cartesian-product
    // calls simpler.
#define SID_GB_WRITE(type1) \
      sid::bus::status write(sid::host_int_4 addr, type1 data) throw () \
	  { sid::bus *bus = this->map_addr_to_bus (&addr); \
            if (UNLIKELY(bus == NULL)) \
              return sid::bus::unmapped; \
            else \
              return bus->write(addr, data); }
    
#define SID_GB_READ(type1) \
      sid::bus::status read(sid::host_int_4 addr, type1& data) throw () \
	  { sid::bus *bus = this->map_addr_to_bus (&addr); \
            if (UNLIKELY(bus == NULL)) \
              return sid::bus::unmapped; \
            else \
              return bus->read(addr, data); }
    
    SID_GB_WRITE(sid::little_int_1)
    SID_GB_WRITE(sid::big_int_1)
    SID_GB_WRITE(sid::little_int_2)
    SID_GB_WRITE(sid::big_int_2)
    SID_GB_WRITE(sid::little_int_4)
    SID_GB_WRITE(sid::big_int_4)
    SID_GB_WRITE(sid::little_int_8)
    SID_GB_WRITE(sid::big_int_8)

    SID_GB_READ(sid::little_int_1)
    SID_GB_READ(sid::big_int_1)
    SID_GB_READ(sid::little_int_2)
    SID_GB_READ(sid::big_int_2)
    SID_GB_READ(sid::little_int_4)
    SID_GB_READ(sid::big_int_4)
    SID_GB_READ(sid::little_int_8)
    SID_GB_READ(sid::big_int_8)

#undef SID_GB_WRITE
#undef SID_GB_READ
  };




  // For byte-wide peripherals - similar to word_bus<host_int_1>.
  // It accepts only byte-wide accesses.
  class byte_bus : public sid::bus
  {
  protected:
    byte_bus() {}
    ~byte_bus() {}
    
    virtual sid::bus::status 
    write_data(sid::host_int_4 addr, sid::host_int_1 data) throw () = 0;
    
    virtual sid::bus::status 
    read_data(sid::host_int_4 addr, sid::host_int_1& data) throw () = 0;
    
    // Byte accesses to a byte-wide component are easy.
    sid::bus::status 
    write(sid::host_int_4 addr, sid::little_int_1 data) throw () 
      {
	return write_data(addr, data.integer_value() );
      }

    sid::bus::status 
    write(sid::host_int_4 addr, sid::big_int_1 data) throw () 
      {
	return write_data( addr, data.integer_value() );
      }
    
    sid::bus::status 
    read( sid::host_int_4 addr, sid::little_int_1& data ) throw ()
      {
	sid::host_int_1 d;
	sid::bus::status s = read_data( addr, d );
	data = d;
	return s;
      }
        
    sid::bus::status 
    read( sid::host_int_4 addr, sid::big_int_1& data ) throw ()
      {
	sid::host_int_1 d;
	sid::bus::status s = read_data( addr, d );
	data = d;
	return s;
      }

    // Some macros to make manufacturing of the cartesian-product
    // calls simpler.
#define BYTE_BUS_WRITE_A4(dtype) \
    sid::bus::status write(sid::host_int_4 addr, dtype data ) throw () {\
          return sid::bus::unmapped; }

#define BYTE_BUS_READ_A4(dtype)\
    sid::bus::status read(sid::host_int_4 addr, dtype& data ) throw () { \
          return sid::bus::unmapped; }

    BYTE_BUS_WRITE_A4( sid::little_int_2 )
    BYTE_BUS_WRITE_A4( sid::big_int_2 )
    BYTE_BUS_WRITE_A4( sid::little_int_4 )
    BYTE_BUS_WRITE_A4( sid::big_int_4 )
    BYTE_BUS_WRITE_A4( sid::little_int_8 )
    BYTE_BUS_WRITE_A4( sid::big_int_8 )
    BYTE_BUS_READ_A4 ( sid::little_int_2 )
    BYTE_BUS_READ_A4 ( sid::big_int_2 )
    BYTE_BUS_READ_A4 ( sid::little_int_4 )
    BYTE_BUS_READ_A4 ( sid::big_int_4 )
    BYTE_BUS_READ_A4 ( sid::little_int_8 )
    BYTE_BUS_READ_A4 ( sid::big_int_8 )

#undef BYTE_BUS_WRITE_A4
#undef BYTE_BUS_READ_A4
  };


  // Callback_byte_bus class allows user to have different read/write
  // methods for each object of this class. User can have one read
  // and write method on class level for all objects of class
  // call_back_byte_bus or user can have seperate read and write
  // methods in class Reciever for each object of class
  // callback_byte_bus.
  template <class Receiver>
  class callback_byte_bus : public byte_bus {
  public:
    callback_byte_bus( Receiver* h,
		       sid::bus::status (Receiver::*r) ( 
			 sid::host_int_4, sid::host_int_1& ),
		       sid::bus::status (Receiver::*w) ( 
			 sid::host_int_4, sid::host_int_1 )
		      ) : receiver(h), reader(r), writer(w) {}

    ~callback_byte_bus() {}

  protected:
    Receiver* receiver;
    sid::bus::status (Receiver::*reader) ( sid::host_int_4 addr, 
					   sid::host_int_1& data );
    sid::bus::status (Receiver::*writer) ( sid::host_int_4 addr, 
					   sid::host_int_1 data );

    virtual sid::bus::status 
    read_data( sid::host_int_4 addr, sid::host_int_1& data ) throw() {
      return (receiver->*reader) ( addr, data );
    }

    virtual sid::bus::status 
    write_data( sid::host_int_4 addr, sid::host_int_1 data ) throw() {
      return (receiver->*writer) ( addr, data );
    }
    
  };


  template <typename DataType>
  class control_register;

  // This class is used to store different types of component
  // registers. Types of register storage supported by this class are
  // read-only, write-only, and read/write only registers.
  template <typename DataType>
  class control_register_bank
  {
  public:
    void add_writeonly_register(control_register<DataType>* reg,
				sid::host_int_4 address);
    void add_readonly_register(control_register<DataType>* reg,
			       sid::host_int_4 address);
    void add_readwrite_register(control_register<DataType>* reg,
				sid::host_int_4 address);
    ~control_register_bank () { }
    
  protected:
    typedef std::vector<control_register<DataType>*> reg_vector;
    typedef std::map<sid::host_int_4, reg_vector> reg_map;

    // read- and write- mappings for control registers
    reg_map read_map, write_map;
  };

  template <typename DataType>
  void 
  control_register_bank<DataType>::add_writeonly_register(control_register<DataType>* reg,
							  sid::host_int_4 address)
  {
    write_map[address].push_back(reg);
  }


  template <typename DataType>
  void 
  control_register_bank<DataType>::add_readonly_register(control_register<DataType>* reg, 
							  sid::host_int_4 address)
  {
    read_map[address].push_back(reg);
  }


  template <typename DataType>
  void 
  control_register_bank<DataType>::add_readwrite_register(control_register<DataType>* reg, 
							  sid::host_int_4 address)
  {
    this->add_writeonly_register(reg, address);
    this->add_readonly_register(reg, address);
  }


  // This is a general type of control register whose value is get/set
  // by a virtual function.
  template <typename DataType>
  class control_register
  {
  public:
    virtual void set (DataType set_value, DataType set_mask) = 0;
    virtual DataType get () = 0;
    DataType get_mask() const { return this->field_mask; }
    
    control_register(control_register_bank<DataType>* bank,
		     sid::host_int_4 offset,
		     DataType m,
		     bool read,
		     bool write): field_mask(m)
      {
	if (read)
	  bank->add_readonly_register(this, offset);
	if (write)
	  bank->add_writeonly_register(this, offset);
      }
  private:
    DataType field_mask;
  };

  // streaming ops for following class
  template <typename DataType> class value_control_register;
  
  template <typename DataType>
  std::ostream& 
  operator << (std::ostream& o, const value_control_register<DataType>& it)
  {  
    sid::host_int_8 v = (sid::host_int_8) it.field_value;
    o << v;
    return o;
  }


  template <typename DataType>
  std::istream& 
  operator >> (std::istream& i, value_control_register<DataType>& it)
  {
    sid::host_int_8 v;
    i >> v;
    it.field_value = v;
    return i;
  }


  // This is a type of control register whose value is stored directly.  It
  // provides an assignment and conversion operator for use like a variable.
  template <typename DataType>
  class value_control_register: public control_register<DataType>
  {
  protected:
    typedef typename DataType::value_type ValueType;

  public:
    void set (DataType set_value, DataType set_mask)
      {
	this->field_value = (this->field_value & ~set_mask) | (set_value & set_mask);
      }


    DataType get ()
      {
	return this->field_value; 
      }

    DataType get () const
      {
	return this->field_value; 
      }

    value_control_register(control_register_bank<DataType>* b,
			   sid::host_int_4 o,
			   DataType m,
			   bool r,
			   bool w,
			   DataType v): 
      control_register<DataType>(b,o,m,r,w),
      field_value(v) {}

    value_control_register(control_register_bank<DataType>* b,
			   sid::host_int_4 o,
			   DataType m,
			   bool r,
			   bool w):
      control_register<DataType>(b,o,m,r,w),
      field_value(0) {}

    // Some convenience operators for accessing register fields
    void operator = (const DataType& v)
      {
	DataType shifted_v = v << this->shift_amount();
	this->set (shifted_v, this->get_mask()); 
      }


    void operator = (const ValueType& v)
      {
	ValueType shifted_v = v << this->shift_amount();
	this->set (shifted_v, this->get_mask()); 
      }

    // conversion operators
    operator DataType () const
      {
	DataType shifted_v = this->get() >> this->shift_amount(); 
	return shifted_v;
      }

    operator ValueType () const
      {
	ValueType shifted_v = this->get() >> this->shift_amount(); 
	return shifted_v;
      }

    friend std::ostream& operator << <> (std::ostream& o, 
					 const value_control_register<DataType>& it);
    friend std::istream& operator >> <> (std::istream& i, 
					 value_control_register<DataType>& it);
    
  protected:
    // return index of mask LSB
    unsigned shift_amount() const
    {
      DataType mask = this->get_mask ();
      for (unsigned i=0; i<sizeof(DataType)*8; i++)
	if (mask & (1 << i))
	  return i;
      assert(0);
    }
    
  private:
    DataType field_value;
  };

  // This is a read-only value control register.  Its underlying value
  // may be changed programmatically, but as far as a bus accessor is
  // concerned, writing to the register has no effect.
  template <typename DataType>
  class ro_value_control_register: public value_control_register<DataType>
  {
  public:
    typedef typename value_control_register<DataType>::ValueType ValueType;

    ro_value_control_register(control_register_bank<DataType>* b,
			      sid::host_int_4 o,
			      DataType m,
			      DataType v):
      value_control_register<DataType>(b,o,m,true,true,v)
    {}
    
    ro_value_control_register(control_register_bank<DataType>* b,
			      sid::host_int_4 o,
			      DataType m):
      value_control_register<DataType>(b,o,m,true,true,0)
    {}

    // Some convenience operators for accessing register fields
    void operator = (const DataType& v)
      {
	ValueType shifted_v = v << this->shift_amount();
	value_control_register<DataType>::set (shifted_v, this->get_mask()); 
      }

  protected:
    void set (DataType set_value, DataType set_mask)
    {
      // do nothing
    }
  };

  // This is a type of control register whose value never changes.
  // One may also use it for reserved fields.
  // Read only register.
  template <typename DataType>
  class fixed_control_register: public value_control_register<DataType>
  {
  public:
    fixed_control_register(control_register_bank<DataType>* b,
			   sid::host_int_4 o,
			   DataType m):
      value_control_register<DataType>(b,o,m,true,true,0)
    {}
    
    fixed_control_register(control_register_bank<DataType>* b,
			   sid::host_int_4 o,
			   DataType m,
			   bool r,
			   bool w,
			   DataType v): 
      value_control_register<DataType>(b,o,m,r,w,v)
    {}

  protected:
    void set (DataType set_value, DataType set_mask)
      {
	// do nothing
	// XXX: check for match with field_value?
      }
  };


  // This is a type of control register whose value is set/get via
  // a pair of class member functions.
  template <typename DataType, class Class>
  class callback_control_register: public control_register<DataType>
  {
  public:
    callback_control_register(control_register_bank<DataType>* b,
			      sid::host_int_4 o,
			      DataType m,
			      bool r,
			      bool w,
			      Class* rec, 
			      void (Class::*s)(DataType, DataType), 
			      DataType (Class::*g)()): 
      control_register<DataType>(b,o,m,r,w),
      receiver(rec),
      set_callback(s),
      get_callback(g)
      {}

    // Read only register
    callback_control_register(control_register_bank<DataType>* b,
			      sid::host_int_4 o,
			      DataType m,
			      bool r,
			      bool w,
			      Class* rec, 
			      DataType (Class::*g)()): 
      control_register<DataType>(b,o,m,r,w),
      receiver(rec),
      set_callback(0),
      get_callback(g)
      {}

    // Write only register
    callback_control_register(control_register_bank<DataType>* b,
			      sid::host_int_4 o,
			      DataType m,
			      bool r,
			      bool w,
			      Class* rec, 
			      void (Class::*s)(DataType, DataType)):
      control_register<DataType>(b,o,m,r,w),
      receiver(rec),
      set_callback(s),
      get_callback(0)
      {}

  private:
    Class* receiver;
    void (Class::*set_callback) (DataType, DataType);
    DataType (Class::*get_callback) ();

    void set (DataType set_value, DataType set_mask)
      {
	assert(this->set_callback);
	(receiver->*set_callback)(set_value, set_mask); 
      }

    DataType get ()
      {
	assert(this->get_callback);
	return (receiver->*get_callback)(); 
      }
  };
  
  // This is a bus that acts like a look-up table for control
  // registers.  Each register may take up a bitfield of a word.
  // Read/Write accesses are dispatched to all the registers whose
  // bitfields overlap the accessed word.

  template <typename DataType>
  class control_register_bus: public control_register_bank<DataType>,
			      public word_bus <DataType>
  {
  protected:
    sid::bus::status word_write(sid::host_int_4 addr,
				DataType mask,
				DataType data)
      {
	typename control_register_bus<DataType>::reg_map::iterator i = 
		 this->write_map.find(addr);
	if (i == this->write_map.end())
	  return sid::bus::unmapped; // XXX: or unpermitted?
	
	DataType unmatched_mask = mask;

	// scan through all registers at this address
	for(typename control_register_bus<DataType>::reg_vector::iterator it =
		       i->second.begin();
	    it != i->second.end();
	    it++)
	  {
	    control_register<DataType>* reg = (*it);
	    DataType reg_mask = reg->get_mask();
	    if (reg_mask & mask) // overlap?
	      {
		// Assert that no other register took these bits already.
		assert ((unmatched_mask & reg_mask) == (mask & reg_mask)); 
		// Take the bits.
		unmatched_mask = unmatched_mask & ~reg_mask;
		// Hand over the masked data value.  Use both the
		// incoming write mask and the control register mask
		reg->set (data & mask & reg_mask, reg_mask & mask);
	      }
	  }

	// Assert that all bits in this word have been taken by control registers.
	assert (unmatched_mask == 0); 
	return sid::bus::ok;
      }


    sid::bus::status word_read(sid::host_int_4 addr,
			       DataType mask,
			       DataType& data_out)
      {
	typename control_register_bus<DataType>::reg_map::iterator i =
		 this->read_map.find(addr);
	if (i == this->read_map.end())
	  return sid::bus::unmapped; // XXX: or unpermitted?

	DataType data = 0;
	DataType unmatched_mask = mask;

	// scan through all registers at this address
	for(typename control_register_bus<DataType>::reg_vector::iterator it =
			i->second.begin();
	    it != i->second.end();
	    it++)
	  {
	    control_register<DataType>* reg = (*it);
	    DataType reg_mask = reg->get_mask();
	    if (reg_mask & mask) // overlap?
	      {
		// Assert that no other register took these bits already.
		assert ((unmatched_mask & reg_mask) == (mask & reg_mask)); 
		// Take the bits.
		unmatched_mask = unmatched_mask & ~reg_mask;
		// Hand over the masked data value.  Use both the
		// incoming read mask and the control register mask
		DataType d = reg->get ();
		data = data | (d & reg_mask & mask);
	      }
	  }

	// Assert that all bits in this word have been taken by control registers.
	assert (unmatched_mask == 0); 
	// Return the data.  (Caller will use the read mask.)
	data_out = data;
	return sid::bus::ok;
      }
  };


  // Following class is used to overwrite access supervisory
  // interface methods declared in class sid::component.
  
  class fixed_accessor_map_component: public virtual sid::component
  {
  public:

    ~fixed_accessor_map_component() {}

    // Returns vector of accessor names to components.
    std::vector<std::string>
    accessor_names() throw ()
      {
	std::vector<std::string> names;
	for(accessor_map_t::const_iterator it = this->accessor_map.begin();
	    it != this->accessor_map.end();
	    it++)
	  {
	    names.push_back(it->first);
	  }
	return names;
      }


    // Returns pointer to accessor bus corresponding to string name.
    sid::bus*
    connected_bus(const std::string& name) throw ()
      {
	accessor_map_t::iterator it = this->accessor_map.find(name);
	if (it == this->accessor_map.end())
	  return 0;
	else
	  return * it->second;
      }


    // Sets accessor represented by string name to bus pointed by argument.
    sid::component::status
    connect_accessor(const std::string& name, sid::bus* bus) throw ()
      {
	accessor_map_t::iterator it = this->accessor_map.find(name);
	if (it != this->accessor_map.end()) 
	  {
	    // Only allow setting if unset
	    if (*it->second == 0)
	      {
		*it->second = bus;
		return sid::component::ok;
	      }
	    else
	      return sid::component::bad_value;
	  }

	return sid::component::not_found;
      }

    // Disassociate a named accessor from a bus.
    sid::component::status
    disconnect_accessor(const std::string& name, sid::bus* bus) throw ()
      {
	accessor_map_t::iterator it = this->accessor_map.find(name);
	if (it != this->accessor_map.end()) 
	  {
	    // Only allow setting if set to given prior value
	    if (*it->second == bus)
	      {
		*it->second = 0;
		return sid::component::ok;
	      }
	    else
	      return sid::component::bad_value;
	  }

	return sid::component::not_found;
      }

  protected:
    // add accessor to component
    void
    add_accessor(const std::string& name, sid::bus** accessor_address)
      {
	assert(accessor_address);
	accessor_map[name] = accessor_address;
      }

  private:
    typedef std::map<std::string,sid::bus**> accessor_map_t;
    mutable accessor_map_t accessor_map;
    
  };

  
  // Class fixed_bus_map_component overwrites bus supervisory
  // interface declared in class sid::component.
  class fixed_bus_map_component: public virtual sid::component
  {
  public:
    ~fixed_bus_map_component() {}

    std::vector<std::string>
    bus_names() throw ()
      {
	std::vector<std::string> names;
	for(bus_map_t::const_iterator it = this->bus_map.begin();
	    it != this->bus_map.end();
	    it++)
	  {
	    names.push_back(it->first);
	  }
	return names;
      }
    
    // Returns pointer to bus that corresponds to string name.
    sid::bus*
    find_bus(const std::string& name) throw ()
      {
	bus_map_t::iterator it = this->bus_map.find(name);
	if (it == this->bus_map.end())
	  return 0;
	else
	  return it->second;
      }

  protected:
    void
    add_bus(const std::string& name, sid::bus* bus)
      {
	assert(bus);
	bus_map[name] = bus;
      }

    // Disassociate a named bus
    sid::component::status
    disconnect_bus(const std::string& name, sid::bus* bus) throw ()
      {
	bus_map_t::iterator it = this->bus_map.find(name);
	if (it != this->bus_map.end()) 
	  {
	    // Only allow setting if set to given prior value
	    if (it->second == bus)
	      {
		it->second = 0;
		return sid::component::ok;
	      }
	    else
	      return sid::component::bad_value;
	  }

	return sid::component::not_found;
      }

  private:
    typedef std::map<std::string,sid::bus*> bus_map_t;
    mutable bus_map_t bus_map;
  };

  // Following class is a virtual base class used for implementing bus
  // arbitrators.
  class bus_arbitrator: public virtual sid::component,
			protected fixed_bus_map_component,
			protected virtual fixed_pin_map_component,
			protected fixed_accessor_map_component,
			protected no_relation_component,
			public fixed_attribute_map_with_logging_component
  {
  public:
    bus_arbitrator () :
      sched ("step", this, & bus_arbitrator::step_cycle)
      {
	// Attributes
	add_attribute ("name", &name);
	// Control pins
	//
	add_pin ("running", & running_pin);
	running_pin.set_active_high ();
	add_pin ("active", & active_pin);
	active_pin.set_active_high ();
      }
    ~bus_arbitrator () { }

  protected:
    // A bus for requests from the input interfaces.
    // 
    class input_interface : public sid::bus
    { 
    public:
      input_interface (bus_arbitrator *h, int us) : host (h), upstream (us) { }

#define SID_GB_WRITE(dtype) \
      sid::bus::status write(sid::host_int_4 addr, dtype data) throw ()\
	  { return host->write(upstream, addr, data); }

#define SID_GB_READ(dtype) \
      sid::bus::status read(sid::host_int_4 addr, dtype& data) throw ()\
	  { return host->read(upstream, addr, data); }

      SID_GB_WRITE(sid::little_int_1)
      SID_GB_WRITE(sid::big_int_1)
      SID_GB_WRITE(sid::little_int_2)
      SID_GB_WRITE(sid::big_int_2)
      SID_GB_WRITE(sid::little_int_4)
      SID_GB_WRITE(sid::big_int_4)
      SID_GB_WRITE(sid::little_int_8)
      SID_GB_WRITE(sid::big_int_8)

      SID_GB_READ(sid::little_int_1)
      SID_GB_READ(sid::big_int_1)
      SID_GB_READ(sid::little_int_2)
      SID_GB_READ(sid::big_int_2)
      SID_GB_READ(sid::little_int_4)
      SID_GB_READ(sid::big_int_4)
      SID_GB_READ(sid::little_int_8)
      SID_GB_READ(sid::big_int_8)

#undef SID_GB_WRITE
#undef SID_GB_READ
    private:
      bus_arbitrator *host;
      int upstream;
    };
    friend class input_interface;

    // A struct representing a bus request
    struct bus_request
    {
      bus_request () {}
      bus_request (bool r, int us, int ds, sid::host_int_4 a, unsigned s)
	: is_read(r), upstream(us), downstream(ds), addr(a), size(s)
        { }
      bool operator== (const bus_request &r)
        {
	  return is_read == r.is_read
	    && upstream == r.upstream
	    && downstream == r.downstream
	    && addr == r.addr
	    && size == r.size;
        }
      bool is_read;
      int upstream;
      int downstream;
      sid::host_int_4 addr;
      unsigned size;
    };

  protected:
    // Handlers for input interfaces
    //
    template<class DataType>
    sid::bus::status
    write(int upstream, sid::host_int_4 addr, DataType data)
      {
	if (ulog_level >= 8 || ! check_passthrough (upstream))
	  log (5, "%s: received write request from %s interface at 0x%x\n",
	       name.c_str (), up2str(upstream), addr);
	return arbitrate_write (upstream, downstream_for_address (addr), addr, data);
      }

    template<class DataType>
    sid::bus::status
    read(int upstream, sid::host_int_4 addr, DataType& data)
      {
	if (ulog_level >= 8 || ! check_passthrough (upstream))
	  log (5, "%s: received read request from %s interface at 0x%x\n",
	       name.c_str (), up2str(upstream), addr);
	return arbitrate_read (upstream, downstream_for_address (addr), addr, data);
      }

    virtual const char *up2str (int upstream) = 0;
    virtual int downstream_for_address (sid::host_int_4 address) = 0;

  protected:
    // Advance time
    //
    virtual void step_cycle ()
      {
	log (5, "%s: Stepping\n", name.c_str());
	update_busy_routes ();
      }

    virtual void reschedule (sid::host_int_2 latency)
      {
        if (latency)
	  {
	    log (5, "%s: rescheduling (%d)\n", name.c_str (), latency);
	    sched.schedule_irregular (1);
	  }
      }

    // Methods for arbitration
    //
    template<class DataType>
    sid::bus::status arbitrate_read (int upstream,
				     int downstream,
				     sid::host_int_4 addr,
				     DataType& data)
      {
	// Check for direct passthrough
	if (check_passthrough (upstream))
	  return downstream_bus (downstream)->read (addr, data);

	// Prioritize the request
	// Execute it if it's ready
	bus_request r (true, upstream, downstream, addr, sizeof (data));
	if (prioritize_request (r))
	  return perform_read (r, data);

	return busy_status ();
      }

    template<class DataType>
    sid::bus::status arbitrate_write (int upstream,
				      int downstream,
				      sid::host_int_4 addr,
				      DataType data)
      {
	// Check for direct passthrough
	if (check_passthrough (upstream))
	  return downstream_bus (downstream)->write(addr, data);

	// Prioritize the request
	// Execute it if it's ready
	bus_request r (false, upstream, downstream, addr, sizeof (data));
	if (prioritize_request (r))
	  return perform_write (r, data);

	return busy_status ();
      }

    // Provide a default implementation which does no prioritization and
    // handles the requests right away as they arrive.
    virtual bool prioritize_request (bus_request &r) { return true; }

    // Methods for downstream accessors
    //
    template<class DataType>
    sid::bus::status perform_read (bus_request &r, DataType &data)
      {
	// See if the route is available
	if (check_route_busy (r.upstream, r.downstream))
	  return busy_status ();

	// Propagate any locked pin from upstream
	lock_downstream (r.upstream, r.downstream);

	// Perform the read
	sid::bus::status s = downstream_bus (r.downstream)->read (r.addr, data);

	// Update status
	if (s == sid::bus::ok)
	  s = set_route_busy (r, s);
	return s;
      }

    template<class DataType>
    sid::bus::status perform_write (bus_request &r, DataType data)
      {
	// See if the route is available
	if (check_route_busy (r.upstream, r.downstream))
	  return busy_status ();
  
	// Propogate any locked pin from upstream
	lock_downstream (r.upstream, r.downstream);

	// Perform the write
	sid::bus::status s = downstream_bus (r.downstream)->write (r.addr, data);

	// Update status
	if (s == sid::bus::ok)
	  s = set_route_busy (r, s);
	return s;
      }

    virtual bool check_passthrough (int = 0)
      {
	if (running_pin.state () != binary_pin_active
	    || active_pin.state () != binary_pin_active)
	  {
	    log (8, "%s: system is idle -- passthrough\n", name.c_str ());
	    return true;
	  }
	return false;
      }

  protected:
    // Methods for timing
    //
    // Default to no latency
    virtual sid::host_int_2 access_latency (bus_request &r) { return 0; }

  protected:
    // Route locking
    //
    virtual void lock_downstream (int upstream, int downstream) { }

    virtual bool check_route_busy (int upstream, int downstream) { return false; }

    virtual sid::bus::status set_route_busy (bus_request &r, sid::bus::status s) { return s; }
    virtual void update_busy_routes () {}
    virtual sid::bus::status busy_status ()
      {
	// Default - busy for 1 cycle
	sid::bus::status s (sid::bus::busy, 1);
	return s;
      }

    virtual sid::bus *downstream_bus (int downstream) = 0;

  protected:
    scheduler_event_subscription<bus_arbitrator> sched;
    // This class must be a friend of scheduler_event_subscription<T>.
    friend class scheduler_event_subscription<bus_arbitrator>;

    // Attributes
    string name;

    // Control pins
    //
    binary_input_pin running_pin;
    binary_input_pin active_pin;
  };
}



#endif // H_SIDBUSUTIL_H
@


1.17
log
@2007-01-17  Dave Brolley  <brolley@@redhat.com>

        * sidbusutil.h (value_control_register::ValueType): Now
        protected.
@
text
@d3 1
a3 1
// Copyright (C) 1999, 2000, 2001, 2002, 2004, 2005 Red Hat.
d33 1
a33 1
    ~word_bus() throw() {}
d232 1
a232 1
    ~passthrough_bus() throw() {}
d284 1
a284 1
    ~mux_passthrough_bus() throw() {}
d373 1
a373 1
    ~passthrough_word_bus() throw() {}
d451 1
a451 1
    ~harvard_bus() throw() {}
d520 1
a520 1
    ~byte_bus() throw() {}
d603 1
a603 1
    ~callback_byte_bus() throw() {}
d641 1
a641 1
    ~control_register_bank () throw () { }
d1046 1
a1046 1
    ~fixed_accessor_map_component() throw() {}
d1136 1
a1136 1
    ~fixed_bus_map_component() throw() {}
d1217 1
a1217 1
    ~bus_arbitrator () throw () { }
@


1.16
log
@2005-08-02  Dave Brolley  <brolley@@redhat.com>

        * sidbusutil.h (bus_arbitrator): Remove passthrough_pin.
        (check_passthrough): Now takes 'upstream' argument. Correct all calls.
        Don't check passthrough_pin here.
        (access_latency): New virtual method of bus_arbitrator.
        * sidblockingutil.h (blocking_component): Initialize still_blockable
        and control_status. Add blockable? using add_attribute_notify.
        (wait_for_child_thread): Assert that control_status != ctl_child_start.
        Return control_status.
        (child_completed): Set blockable to still_blockable.
        (set_blockable): New method of blocking_component.
        (still_blockable): New member of blocking_component.
@
text
@d733 1
a733 1
  private:
@


1.15
log
@2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (read_insn_memory): Only call
        record_insn_memory_read_latency if --trace-counter or
        --final-insn-count are specified.
        (write_insn_memory): Ditto.
        (read_data_memory): Ditto.
        (write_data_memory): Ditto.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (record_insn_memory_read_latency): New virtual method.
        (record_insn_memory_write_latency): New virtual method.
        (record_data_memory_read_latency): New virtual method.
        (record_data_memory_write_latency): New virtual method.
        (read_insn_memory): Call record_insn_memory_read_latency.
        (write_insn_memory): Call record_insn_memory_write_latency.
        (read_data_memory): Call record_data_memory_read_latency.
        (write_data_memory): Call record_data_memory_write_latency.
        * sidattrutil.h (fixed_attribute_map_with_logging_component::check_level):
        now protected and returns bool.
        * sidblockingutil.h: Rework ulog levels.
        * sidbusutil.h (bus_arbitrator): Rework ulog levels. Return the result
        of busy_status instead of bus::busy. New methods: busy_status and
        access_latency.
        (perform_read): Only call set_route_busy is status is bus::ok.
        (perform_write): Only call set_route_busy is status is bus::ok.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * sidbusutil.h (bus_arbitrator::input_interface): New class.
        (bus_arbitrator::reschedule): Reschedule after the given number of
        cycles.
        (bus_arbitrator::arbitrate_read): New method.
        (bus_arbitrator::arbitrate_write): New method.
        (bus_arbitrator::prioritize_request): New virtual method.
        (bus_arbitrator::perform_read): Propogate the lock from the upstream
        interface to the downstream interface.
        (bus_arbitrator::perform_write): Ditto.
        (bus_arbitrator::lock_downstream): New virtual method.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * sidblockingutil.h (blocking_component): Reimplement using mutexes
        for synchronization.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (basic_cpu): Inherit virtually from all base classes.
        (basic_cpu::step_pin_handler): Now virtual.
        (basic_cpu::{read,write}_{insn,data}_memory): No longer const. Call
        handle_{insn,data}_memory_{read,write}_error for bus errors.
        (basic_big_endian_cpu::{read,write_{insn,data}_memory*): No longer
        const.
        (basic_little_endian_cpu): Ditto.
        * sidcomp.h (bus::status_t): Add 'busy'.
        * sidattrutil.h: Remove unused code.
        * sidblockingutil.h: New header.
@
text
@d3 1
a3 1
// Copyright (C) 1999, 2000, 2001, 2002, 2004 Red Hat.
a1215 2
	add_pin ("passthrough", & passthrough_pin);
	passthrough_pin.set_active_high ();
d1290 1
a1290 1
	if (ulog_level >= 8 || ! check_passthrough ())
d1300 1
a1300 1
	if (ulog_level >= 8 || ! check_passthrough ())
d1336 1
a1336 1
	if (check_passthrough ())
d1355 1
a1355 1
	if (check_passthrough ())
d1411 1
a1411 1
    bool check_passthrough ()
a1412 6
	if (passthrough_pin.state () == binary_pin_active)
	  {
	    log (8, "%s: passthrough enabled\n", name.c_str ());
	    return true;
	  }

d1419 8
a1426 2
      return false;
    }
a1457 1
    binary_input_pin passthrough_pin;
@


1.14
log
@2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * sidbusutil.h (passthrough_bus::target): Now 'protected'.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        For Stan Cox  <scox@@redhat.com>
        * sidmiscutil.h (logger): New class.
        * sidattrutil.h (fixed_attribute_map_with_logging_component): Convert
        to use logger.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (set_total_latency): New method of basic_cpu.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * sidattrutil.h (SID_LOG_PERSISTENT_BUFFER): New macro.
        (SID_LOG_TRANSIENT_MALLOC_BUFFER): New macro.
        (buffer_output): New member of
        fixed_attribute_map_with_logging_component.
        (fixed_attribute_with_logging_component): Add buffer-output attribute.
        Use SID_LOG_PERSISTENT_BUFFER.
        (~fixed_attribute_with_logging_component): Use
        SID_LOG_PERSISTENT_BUFFER.
        (log): Buffer output based on buffer_output. Use
        SID_LOG_TRANSIENT_MALLOC_BUFFER.
        * sidcpuutil.h (get_total_latency): New method of basic_cpu.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * sidattrutil.h (log): Don't use STDCTYPE for vsnprint or vasprintf.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        For Stan Cox  <scox@@redhat.com>
        * sidmiscutil.h (bijection::find): Add typename.
        * sidbusutil.h (ro_value_control_register): New ValueType typedef.
        (control_register_bus::word_write, control_register_bus::word_read):
        Add typename

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * sidattrutil.h (iostream): #include it.
        (log): Use std::cerr and std::endl.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * sidattrutil.h (fixed_attribute_map_with_logging_component):
        Initialize saved_messages and saved_levels.
        (~fixed_attribute_map_with_logging_component): Output saved messages.
        Delete buffer if necessary.
        (log): Save message for later if output pin not connected. Otherwise
        output saved messages before the new message. Use vsnprintf or
        vasprintf if possible.
        (check_level): New member of fixed_attribute_map_with_logging_component.
        (output_saved_messages): Ditto.
@
text
@d3 1
a3 1
// Copyright (C) 1999, 2000, 2001, 2002 Red Hat.
d12 4
d59 1
d62 1
a71 1
		sid::bus::status s;
d79 2
d92 2
a93 1
	return sid::bus::ok;
d112 1
d114 1
a121 2
		sid::bus::status s;

d129 2
d151 2
a152 1
	return sid::bus::ok;
d1194 268
@


1.13
log
@2003-02-06  Frank Ch. Eigler  <fche@@redhat.com>

	* sidbusutil.h (control_register_bus word_read,write): C++ cleanup.
@
text
@d254 1
a254 1
  private:
@


1.12
log
@2002-03-01  Benjamin Kosnik  <bkoz@@redhat.com>
	* sidbusutil.h: Make typename usage explicit.
@
text
@d632 1
a632 1
  private:
a635 1
  protected:
d953 3
a955 2
	typename reg_map::iterator i = write_map.find(addr);
	if (i == write_map.end())
d961 2
a962 1
	for(typename reg_vector::iterator it = i->second.begin();
d990 3
a992 2
	typename reg_map::iterator i = read_map.find(addr);
	if (i == read_map.end())
d999 2
a1000 1
	for(typename reg_vector::iterator it = i->second.begin();
@


1.11
log
@	* sidbusutil.h (ro_value_control_register::operator=): Bug
	fix. Use parent's set() method.
@
text
@d3 1
a3 1
// Copyright (C) 1999, 2000, 2001 Red Hat.
d814 2
d954 1
a954 1
	reg_map::iterator i = write_map.find(addr);
d961 1
a961 1
	for(reg_vector::iterator it = i->second.begin();
d989 1
a989 1
	reg_map::iterator i = read_map.find(addr);
d997 1
a997 1
	for(reg_vector::iterator it = i->second.begin();
@


1.10
log
@2001-11-30  Ben Elliston  <bje@@redhat.com>

	* sidbusutil.h (class ro_value_control_register): New class.
	(value_control_register::shift_amount): Make protected.
@
text
@d830 2
a831 1
	value_control_register<DataType>::operator= (v);
@


1.9
log
@* resilience fix

2001-09-20  Frank Ch. Eigler  <fche@@redhat.com>

        * sidbusutil.h (mux_passthrough_bus): Rework to clean up and
        avoid NULL pointer dereference.
@
text
@a790 3
  
private:
    DataType field_value;
d792 1
d795 34
d830 1
a830 5
	DataType mask = this->get_mask ();
	for (unsigned i=0; i<sizeof(DataType)*8; i++)
	  if (mask & (1 << i))
	    return i;
	assert(0);
d832 6
@


1.8
log
@2001-08-22  Ben Elliston  <bje@@redhat.com>

	* sidbusutil.h (class fixed_control_register): Add a new
	convenience constructor which creates a register which is
	readable, writable and initialised to 0.
@
text
@d263 1
a263 1
    mux_passthrough_bus(sid::bus** t1, sid::bus** t2): index(0), target(t1) 
d267 5
a271 3
        t[0] = t1;
        t[1] = t2;
	t[2] = NULL;
d277 1
a277 1
      if ((index & ~1) == 0)
d279 9
a287 2
	  index ^= 1;
	  target = t[index];
d293 12
a304 5
      if ((i & ~1) == 0)
	index = i;
      else
	index = 2;
      target = t[index];
d340 1
d342 1
a342 1
    sid::bus** t[3];
@


1.7
log
@2001-05-29  matthew green  <mrg@@redhat.com>

	* sidcpuutil.h (trace_disass_p, trace_semantics_p, trace_counter_p):
	New bools controlling disassembly tracing, semantic tracing (what
	was trace_result_p), and counter tracing, respectively.
	(set_trace_sem, get_trace_sem, set_trace_disasm, get_trace_disasm,
	set_trace_count, get_trace_count, get_trace_result): New methods,
	mostly for compatibility with old CPU components that use
	trace_result_p for what is now trace_semantics_p.  Remove later.
	(stream_state, destream_state): Handle trace_disass_p,
	trace_semantics_p and trace_counter_p.
	(basic_cpu ctor): New virtual attributes `trace-semantics?',
	`trace-disassemble?', `trace-counter?'. `trace-result?' is now
	virtual, and acts as if `trace-semantics?' was set.
	Much of the above can be undone when all CPU ports are converted to
	use trace_result_p in the new method.

2001-11-17  Jeff Johnston <jjohnstn@@redhat.com>

        * sidbusutil.h (passthrough_word_bus): Changed do_direct_passthrough
        to use reference parameter so address can be modified by routine.
@
text
@d798 6
d809 1
a809 1
      {}
@


1.6
log
@* make it compile with GCC 3.0:
        - missing throw() specifiers in bus & component dtors
	- `std::' vs `::' namespace issues
@
text
@d3 1
a3 1
// Copyright (C) 1999, 2000 Red Hat.
d257 1
a257 1
  
d355 1
a355 1
    virtual int do_direct_passthrough (sid::host_int_4 addr) { return 0; } 
@


1.5
log
@* GCC 3.0 & 2.95.3 fixes.

[component/audio/ChangeLog]
	* compAudio.cxx (fd_audio): Add missing throw() specifiers to this dtor.
	* components.h (basic_codec, generic_audio, nop_audio, fd_audio,
	linux_audio, solaris_audio): Add missing throw() specifiers to these
	dtors.

[component/cfgroot/ChangeLog]
	* compConfig.cxx (cfgroot_component): Add missing throw() specifiers
	to this dtor.

[component/tcl/ChangeLog]
	* compTcl.cxx (tcl_component): Add missing throw() specifiers to this
	dtor.

[include/ChangeLog]
	* sidattrutil.h (attribute_coder_base, attribute_coder_virtual,
	attribute_coder_alias, attribute_coder_virtual_parameterized,
	attribute_coder, attribute_coder_ro, attribute_coder_ro_value,
	attribute_coder_bus_rw, attribute_coder_bus_wo,
	fixed_attribute_map_component): Add missing throw() specifiers
	to these dtors.
	* sidbusutil.h (word_bus, passthrough_bus, mux_passthrough_bus,
	passthrough_word_bus, harvard_bus, byte_bus, callback_byte_bus,
@
text
@d613 1
@


1.4
log
@2001-03-28  Dave Brolley  <brolley@@redhat.com>

	* sidbusutil.h (mux_passthrough_bus::select_bus): New function.
@
text
@d29 1
a29 1
    ~word_bus() {}
d221 1
a221 1
    ~passthrough_bus() {}
d271 1
a271 1
    ~mux_passthrough_bus() {}
d345 1
a345 1
    ~passthrough_word_bus() {}
d423 1
a423 1
    ~harvard_bus() {}
d492 1
a492 1
    ~byte_bus() {}
d575 1
a575 1
    ~callback_byte_bus() {}
d971 2
d1061 2
@


1.3
log
@* branch probability hinting

[cgen/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* sid.cpu (-op-gen-set-trace[-parallel], -create-virtual-insns!):
	Emit LIKELY/UNLIKELY branch probability hints.
	* sid-decode.cpu (-gen-record-args): Ditto.

[sid/include/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* sidconfig.h (LIKELY, UNLIKELY): New conditional cover macros
	for gcc's __builtin_expect branch probability hinting function.
	* sidbusutil.h (passthrough_bus, mux_password_bus, harvard_bus):
	Add some branch probability hints.
	* sidcpuutil.h (step_pin_handler, stop_after_insns_p,
	{read,write}_{insn,data}_memory): Ditto.
	* sidpinutil.h (callback_pin::driven): Remove unnecessary assert
	from critical path.

[eg. sid/component/mapper/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* compMapper.cxx ({read,write}_strideoffset_any): Added b.p. hints.
	(write_any, read_any, locate): Ditto.

[sid/component/cgen-cpu/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* cgen-engine.h (set_pbb_engine, chain, get_next_vpc, pbb_find,
	pbb_find_or_alloc, pbb_before, pbb_after): Add branch probability
	hints.

[eg. sid/component/cgen-cpu/arm7t/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* arm-decode.cxx, -sem.cxx, -semsw.cxx: Regenerated w/ b.p. hints.
	* thumb-decode.cxx, -sem.cxx, -semsw.cxx: Ditto.
@
text
@d269 1
d272 18
a289 1
    void switch_bus() { index ^= 1; target = t[index]; }
d295 1
a295 1
	  { if (LIKELY(*target)) return (*target)->write(addr, data); else return sid::bus::unpermitted; }
d299 1
a299 1
	  { if (LIKELY(*target)) return (*target)->read(addr, data); else return sid::bus::unpermitted; }
d325 1
a325 1
    sid::bus** t[2];
@


1.2
log
@
2001-01-12  Jeff Johnston  <jjohnstn@@redhat.com>

        * sidbusutil.h (mux_passthrough_bus): New bus allowing one
        input bus tied to one of two accessors with dynamic switching.
@
text
@d227 1
a227 1
	  { if (*target) return (*target)->write(addr, data); else return sid::bus::unpermitted; }
d231 1
a231 1
	  { if (*target) return (*target)->read(addr, data); else return sid::bus::unpermitted; }
d277 1
a277 1
	  { if (*target) return (*target)->write(addr, data); else return sid::bus::unpermitted; }
d281 1
a281 1
	  { if (*target) return (*target)->read(addr, data); else return sid::bus::unpermitted; }
d430 1
a430 1
            if (bus == NULL) \
d438 1
a438 1
            if (bus == NULL) \
@


1.1
log
@* public snapshot of sid simulator
@
text
@d258 52
@

