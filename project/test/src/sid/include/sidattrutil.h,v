head	1.11;
access;
symbols
	sid-snapshot-20180601:1.11
	sid-snapshot-20180501:1.11
	sid-snapshot-20180401:1.11
	sid-snapshot-20180301:1.11
	sid-snapshot-20180201:1.11
	sid-snapshot-20180101:1.11
	sid-snapshot-20171201:1.11
	sid-snapshot-20171101:1.11
	sid-snapshot-20171001:1.11
	sid-snapshot-20170901:1.11
	sid-snapshot-20170801:1.11
	sid-snapshot-20170701:1.11
	sid-snapshot-20170601:1.11
	sid-snapshot-20170501:1.11
	sid-snapshot-20170401:1.11
	sid-snapshot-20170301:1.11
	sid-snapshot-20170201:1.11
	sid-snapshot-20170101:1.11
	sid-snapshot-20161201:1.11
	sid-snapshot-20161101:1.11
	sid-snapshot-20160901:1.11
	sid-snapshot-20160801:1.11
	sid-snapshot-20160701:1.11
	sid-snapshot-20160601:1.11
	sid-snapshot-20160501:1.11
	sid-snapshot-20160401:1.11
	sid-snapshot-20160301:1.11
	sid-snapshot-20160201:1.11
	sid-snapshot-20160101:1.11
	sid-snapshot-20151201:1.11
	sid-snapshot-20151101:1.11
	sid-snapshot-20151001:1.11
	sid-snapshot-20150901:1.11
	sid-snapshot-20150801:1.11
	sid-snapshot-20150701:1.11
	sid-snapshot-20150601:1.11
	sid-snapshot-20150501:1.11
	sid-snapshot-20150401:1.11
	sid-snapshot-20150301:1.11
	sid-snapshot-20150201:1.11
	sid-snapshot-20150101:1.11
	sid-snapshot-20141201:1.11
	sid-snapshot-20141101:1.11
	sid-snapshot-20141001:1.11
	sid-snapshot-20140901:1.11
	sid-snapshot-20140801:1.11
	sid-snapshot-20140701:1.11
	sid-snapshot-20140601:1.11
	sid-snapshot-20140501:1.11
	sid-snapshot-20140401:1.11
	sid-snapshot-20140301:1.11
	sid-snapshot-20140201:1.11
	sid-snapshot-20140101:1.11
	sid-snapshot-20131201:1.11
	sid-snapshot-20131101:1.11
	sid-snapshot-20131001:1.11
	sid-snapshot-20130901:1.11
	sid-snapshot-20130801:1.11
	sid-snapshot-20130701:1.11
	sid-snapshot-20130601:1.11
	sid-snapshot-20130501:1.11
	sid-snapshot-20130401:1.11
	sid-snapshot-20130301:1.11
	sid-snapshot-20130201:1.11
	sid-snapshot-20130101:1.11
	sid-snapshot-20121201:1.11
	sid-snapshot-20121101:1.11
	sid-snapshot-20121001:1.11
	sid-snapshot-20120901:1.11
	sid-snapshot-20120801:1.11
	sid-snapshot-20120701:1.11
	sid-snapshot-20120601:1.11
	sid-snapshot-20120501:1.11
	sid-snapshot-20120401:1.11
	sid-snapshot-20120301:1.11
	sid-snapshot-20120201:1.11
	sid-snapshot-20120101:1.11
	sid-snapshot-20111201:1.11
	sid-snapshot-20111101:1.11
	sid-snapshot-20111001:1.11
	sid-snapshot-20110901:1.11
	sid-snapshot-20110801:1.11
	sid-snapshot-20110701:1.11
	sid-snapshot-20110601:1.11
	sid-snapshot-20110501:1.11
	sid-snapshot-20110401:1.11
	sid-snapshot-20110301:1.11
	sid-snapshot-20110201:1.11
	sid-snapshot-20110101:1.11
	sid-snapshot-20101201:1.11
	sid-snapshot-20101101:1.11
	sid-snapshot-20101001:1.11
	sid-snapshot-20100901:1.11
	sid-snapshot-20100801:1.11
	sid-snapshot-20100701:1.11
	sid-snapshot-20100601:1.11
	sid-snapshot-20100501:1.11
	sid-snapshot-20100401:1.11
	sid-snapshot-20100301:1.11
	sid-snapshot-20100201:1.11
	sid-snapshot-20100101:1.11
	sid-snapshot-20091201:1.11
	sid-snapshot-20091101:1.11
	sid-snapshot-20091001:1.11
	sid-snapshot-20090901:1.11
	sid-snapshot-20090801:1.11
	sid-snapshot-20090701:1.11
	sid-snapshot-20090601:1.11
	sid-snapshot-20090501:1.11
	sid-snapshot-20090401:1.11
	sid-snapshot-20090301:1.11
	sid-snapshot-20090201:1.11
	sid-snapshot-20090101:1.11
	sid-snapshot-20081201:1.11
	sid-snapshot-20081101:1.11
	sid-snapshot-20081001:1.11
	sid-snapshot-20080901:1.11
	sid-snapshot-20080801:1.11
	sid-snapshot-20080701:1.11
	sid-snapshot-20080601:1.10
	sid-snapshot-20080501:1.10
	sid-snapshot-20080403:1.10
	sid-snapshot-20080401:1.10
	sid-snapshot-20080301:1.10
	sid-snapshot-20080201:1.10
	sid-snapshot-20080101:1.10
	sid-snapshot-20071201:1.10
	sid-snapshot-20071101:1.10
	sid-snapshot-20071001:1.10
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.2
	cygnus_cvs_20020108_pre:1.2;
locks; strict;
comment	@ * @;


1.11
date	2008.06.17.18.11.01;	author brolley;	state Exp;
branches;
next	1.10;

1.10
date	2007.02.05.20.28.42;	author brolley;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.27.20.30.06;	author fche;	state Exp;
branches;
next	1.8;

1.8
date	2005.08.19.19.47.44;	author brolley;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.10.15.48.22;	author brolley;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.21.21.38.24;	author brolley;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.20.21.29.13;	author fche;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.10.18.33.50;	author brolley;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.22.20.35.00;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.12.11.37.32;	author mrg;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.07.19.31.09;	author fche;	state Exp;
branches;
next	;


desc
@@


1.11
log
@2008-06-17  Dave Brolley  <brolley@@redhat.com>

        * sidmiscutil.h (change_log): New utility class.
        * sidcpuutil.h (basic_cpu): Now inherits from reversible_component.
        (step_pin_handler): Parameter now named 'tick'. Save the current
        tick. Handle exec_direction == "backward". Initialize change logging,
        if reversible. Finish change logging, if reversible.
        (step_backward): New method of basic_cpu.
        (reset_pin_handler): Terminte the current change log, if any.
        Set exec_direction to "forward".
        (change_log,change_log_begin,change_log_end,change_log_boundaries)
        (change_string,exec_direction,sim_sched,current_tick,last_tick): New
        members of basic_cpu.
        (init_change_logging,finish_change_logging,log_change)
        (restore_state_to_time): New virtual methods of basic_cpu.
        (basic_cpu): Initialize change_log, change_log_begin,
        change_log_end, change_log_boundaries, last_tick, exec_direction,
        and sim_sched. Add the exec-direction and sim-sched attributes.
        * sidattrutil.h (reversible_component): New mix-in class.
@
text
@// sidattrutil.h - Classes to manage lists of component attributes and
// mappings between application objects and their string
// representations.  -*- C++ -*-

// Copyright (C) 1999, 2000, 2003, 2005, 2006, 2007 Red Hat.
// This file is part of SID and is licensed under the GPL.
// See the file COPYING.SID for conditions for redistribution.

#ifndef SIDATTRUTIL_H
#define SIDATTRUTIL_H

#include <sidconfig.h>
#include <sidcomputil.h>
#include <sidpinutil.h>
#include "sidtypes.h"

#include <string>
#include <typeinfo>
#include <map>

#include <cctype>
// XXX: kludge for compatibility both with old & new libstdc++
#if STD_CCTYPE
#define STDCTYPE(func) std::func
#else
#define STDCTYPE(func) func
#endif


#include <limits.h>
#include <stdio.h>
#include <stdarg.h>

// <ext/hash_map>? <hash_map>?  std::?  __gnu_cxx::?  Too much hassle.
#undef HAVE_HASHING

#include <iostream>
#if HAVE_SSTREAM
#include <sstream>
#elif HAVE_STRSTREAM_H
#include <strstream.h>
#else
#error "need <sstream> or <strstream.h>!"
#endif

#include <cassert>
#include <sidmiscutil.h>


namespace sidutil
{

  // Make a string from an object by the default output-streaming operator.
  template <typename Type>
  static std::string
  make_attribute (const Type& value)
  {
#if HAVE_SSTREAM
    std::ostringstream stream;
    stream << value;
    return stream.str ();
#elif HAVE_STRSTREAM_H
    ostrstream stream;
    stream << value;
    std::string result (stream.str (), stream.pcount ());
    stream.freeze (0);
    return result;
#else
#error "need <sstream> or <strstream.h>!"
#endif
  }


  // Attempt to make object from a string using the default input-streaming operator.
  template <typename Type>
  static sid::component::status
  parse_attribute (const std::string& str, Type& value)
  {
#if HAVE_SSTREAM
    std::istringstream stream (str);
    stream >> value;
#elif HAVE_STRSTREAM_H
    istrstream stream (str.data (), str.length ());
    stream >> value;
#else
#error "need <sstream> or <strstream.h>!"
#endif

    // Ensure stream is still good, and that operator>> has consumed entire string.
    if (! stream.bad () && (stream.rdbuf ()->in_avail () == 0))
      return sid::component::ok;
    else
      return sid::component::bad_value;
  }



// ---------------------------------------------------------------------------

  // Specific attribute make/parse routines for common types

  // Specialization for strings
static std::string
make_attribute (const std::string& value)
{
  return value;
}

static sid::component::status
parse_attribute (const std::string& str, std::string& value)
{
  value = str;
  return sid::component::ok;
}


  // Specialization for bools
static std::string
make_attribute (const bool& value)
{
  if (value)
    return "yes";
  else
    return "no";
}

static sid::component::status
parse_attribute (const std::string& str, bool& value)
{
  if (str == "yes" || str == "y" ||
      str == "true" || str == "t" ||
      str == "on" || 
      str == "1")
    {
      value = true;
      return sid::component::ok;
    }
  else if (str == "no" || str == "n" ||
	   str == "false" || str == "f" ||
	   str == "off" ||
	   str == "0")
    {
      value = false;
      return sid::component::ok;
    }

  return sid::component::bad_value;
}


  // Specialization for host_int_X

template <typename Value>
static std::string
make_numeric_attribute (const Value& value, std::ios::fmtflags ios_flags = std::ios::dec)
{
#if HAVE_SSTREAM
    std::ostringstream stream;
    stream.flags (ios_flags);
    stream << value;
    return stream.str ();
#elif HAVE_STRSTREAM_H
    ostrstream stream;
    stream.flags (ios_flags);
    stream << value;
    std::string result (stream.str (), stream.pcount ());
    stream.freeze (0);
    return result;
#else
#error "need <sstream> or <strstream.h>!"
#endif
}


static std::string
make_attribute (const sid::host_int_8& value)
{
  return sidutil::make_numeric_attribute (value);
}

static std::string
make_attribute (const sid::host_int_4& value)
{
  return sidutil::make_numeric_attribute (value);
}

static std::string
make_attribute (const sid::host_int_2& value)
{
  return sidutil::make_numeric_attribute (value);
}

static std::string
make_attribute (const sid::host_int_1& value)
{
  // widen to avoid representation as char
  return sidutil::make_numeric_attribute (sid::host_int_2(value));
}

static std::string
make_attribute (const sid::signed_host_int_8& value)
{
  return sidutil::make_numeric_attribute (value);
}

static std::string
make_attribute (const sid::signed_host_int_4& value)
{
  return sidutil::make_numeric_attribute (value);
}

static std::string
make_attribute (const sid::signed_host_int_2& value)
{
  return sidutil::make_numeric_attribute (value);
}

static std::string
make_attribute (const sid::signed_host_int_1& value)
{
  // widen to avoid representation as char
  return sidutil::make_numeric_attribute (sid::signed_host_int_2(value));
}


template <typename unsignedValue>
static sid::component::status
parse_unsigned_numeric_attribute (const std::string& str, unsignedValue& value)
{
  // Algorithm based on newlib's strtoul, from BSD.

  unsignedValue base = 10;
  unsigned parseoffset = 0;
  bool negative = false;

  if (str.length () == 0)
    return sid::component::bad_value;

  if (str.length () > parseoffset+1 && str.substr (parseoffset,1) == "-")
    {
      negative = true;
      parseoffset ++;
    }

  // NB: check longest prefixes first!
  if (str.length () > parseoffset+2 && (str.substr (parseoffset,2) == "0x" || 
					str.substr (parseoffset,2) == "0X"))
    {
      base = 16;
      parseoffset += 2;
    }
  else if (str.length () > parseoffset+2 && (str.substr (parseoffset,2) == "0b" ||
					     str.substr (parseoffset,2) == "0B"))
    {
      base = 2;
      parseoffset += 2;
    }
  else if (str.length () > parseoffset+1 && str.substr (parseoffset,1) == "0")
    {
      base = 8;
      parseoffset += 1;
    }

  //cout << "str=" << str << " base=" << base << " negative=" << negative;

  unsignedValue acc = 0;
  unsignedValue max = (unsignedValue) -1;
  unsignedValue cutoff = max / base;
  unsignedValue cutlim = max % base;
  for (unsigned i = parseoffset; i < str.length (); i++)
    {
      unsigned char c = str[i];
      // cout << "c=" << (int)c << " acc=" << acc << endl;
      if (STDCTYPE(isdigit) (c))
	c -= '0';
      else if (STDCTYPE(isalpha) (c))
	c -= STDCTYPE(isupper) (c) ? 'A' - 10 : 'a' - 10;
      else
	return sid::component::bad_value;

      // limit accumulation
      if (c >= base)
	return sid::component::bad_value;
      else if (acc > cutoff || (acc == cutoff && c > cutlim))
	return sid::component::bad_value;	

      acc *= base;
      acc += c;
    }

  value = negative ? -acc : acc;
  // cout << " value=" << value << endl;

  return sid::component::ok;
}


static sid::component::status
parse_attribute (const std::string& str, sid::host_int_8& value)
{
  return sidutil::parse_unsigned_numeric_attribute (str, value);
}

static sid::component::status
parse_attribute (const std::string& str, sid::host_int_4& value)
{
  return sidutil::parse_unsigned_numeric_attribute (str, value);
}

static sid::component::status
parse_attribute (const std::string& str, sid::host_int_2& value)
{
  return sidutil::parse_unsigned_numeric_attribute (str, value);
}

static sid::component::status
parse_attribute (const std::string& str, sid::host_int_1& value)
{
  return sidutil::parse_unsigned_numeric_attribute (str, value);
}

// Signed versions.
// ??? The unsigned versions don't mark negative values as bad so
// for now the signed versions don't mark big unsigned values as bad.

static sid::component::status
parse_attribute (const std::string& str, sid::signed_host_int_8& value)
{
  sid::host_int_8 uvalue;
  sid::component::status s = sidutil::parse_unsigned_numeric_attribute (str, uvalue);
  if (s == sid::component::ok)
    value = uvalue;
  return s;
}

static sid::component::status
parse_attribute (const std::string& str, sid::signed_host_int_4& value)
{
  sid::host_int_4 uvalue;
  sid::component::status s = sidutil::parse_unsigned_numeric_attribute (str, uvalue);
  if (s == sid::component::ok)
    value = uvalue;
  return s;
}

static sid::component::status
parse_attribute (const std::string& str, sid::signed_host_int_2& value)
{
  sid::host_int_2 uvalue;
  sid::component::status s = sidutil::parse_unsigned_numeric_attribute (str, uvalue);
  if (s == sid::component::ok)
    value = uvalue;
  return s;
}

static sid::component::status
parse_attribute (const std::string& str, sid::signed_host_int_1& value)
{
  sid::host_int_1 uvalue;
  sid::component::status s = sidutil::parse_unsigned_numeric_attribute (str, uvalue);
  if (s == sid::component::ok)
    value = uvalue;
  return s;
}



// Specialization for {big,little}_int types

template <typename IntType, bool IsBig>
static sid::component::status
parse_attribute (const std::string& str, sid::any_int<IntType,IsBig>& value)
{
  typename sid::any_int<IntType,IsBig>::value_type v;
  sid::component::status s = parse_attribute (str, v);
  if (s == sid::component::ok)
    value = v;
  return s;
}

template <typename IntType, bool IsBig>
static std::string
make_attribute (const sid::any_int<IntType,IsBig>& value)
{
  typename sid::any_int<IntType,IsBig>::value_type v = value.integer_value ();
  return make_attribute (v);
}




// ---------------------------------------------------------------------------


  // Abstract attribute-coder class provides interface to a pair of
  // string->object and object->string conversion functions.
  class attribute_coder_base
  {
  public:
    virtual std::string make_attribute() const = 0;
    virtual sid::component::status parse_attribute(const std::string& str) = 0;
    virtual ~attribute_coder_base() {}
  };


  // This kind of attribute coder calls a pair of unparameterized
  // member functions for making/parsing attribute strings.
  template <class Class>
  class attribute_coder_virtual: public attribute_coder_base
  {
  public:
    typedef std::string (Class::*getter_f) ();
    typedef sid::component::status (Class::*setter_f) (const std::string&);    

  private:
    Class* receiver;
    getter_f getter;
    setter_f setter;

  public:
    attribute_coder_virtual (Class* r, getter_f g, setter_f s):
      receiver (r), getter (g), setter (s) {}

    attribute_coder_virtual (Class* r, setter_f s, getter_f g):
      receiver (r), getter (g), setter (s) {}

    std::string make_attribute () const
      { return (receiver->*getter) (); }

    sid::component::status
    parse_attribute (const std::string& str)
      { return (receiver->*setter) (str); }

    ~attribute_coder_virtual() { }
  };


  // This kind of attribute coder redirects the calls to another
  // object's named attribute.  This may be used to create
  // aliased attributes.
  class attribute_coder_alias: public attribute_coder_base
  {
  private:
    sid::component* receiver;
    std::string name;

  public:
    attribute_coder_alias (sid::component* r, const std::string& n):
      receiver (r), name(n) {}

    std::string make_attribute () const
      { return receiver->attribute_value (name); }

    sid::component::status
    parse_attribute (const std::string& str)
      { return receiver->set_attribute_value (name, str); }

    ~attribute_coder_alias() { }
  };



  // This kind of attribute coder calls a pair of member functions for 
  // making/parsing attribute strings.  They are parameterized with a
  // value of some type.
  template <class Class, typename Parameter>
  class attribute_coder_virtual_parameterized: public attribute_coder_base
  {
  public:
    typedef std::string (Class::*getter_f) (Parameter);
    typedef sid::component::status (Class::*setter_f)
      (Parameter, const std::string&);    

  private:
    Class* receiver;
    Parameter parameter;
    getter_f getter;
    setter_f setter;

  public:
    attribute_coder_virtual_parameterized (Class* r, getter_f g, setter_f s,
					 Parameter p)
      :receiver (r), getter (g), setter (s), parameter (p) { }
      
    attribute_coder_virtual_parameterized (Class* r, setter_f s, getter_f g,
					 Parameter p)
      :receiver (r), getter (g), setter (s), parameter (p) { }
      
    std::string
    make_attribute () const
      {
	return (receiver->*getter) (parameter);
      }

    sid::component::status
    parse_attribute (const std::string& str)
      {
	return (receiver->*setter) (parameter, str);
      }

   ~attribute_coder_virtual_parameterized() { }

  };


  // This attribute coder stores a pointer to a value.  It forwards
  // make_attribute and parse_attribute to the pointed-to value for
  // mapping to/from strings.
  template <typename Value>
  class attribute_coder: public attribute_coder_base
  {
    Value* ptr;
  public:
    attribute_coder (Value* p): ptr (p) {}

    std::string make_attribute () const
      {
	return sidutil::make_attribute (*ptr);
      }

    sid::component::status parse_attribute (const std::string& str)
      {
	return sidutil::parse_attribute (str, *ptr);
      }

    ~attribute_coder() { }
  };


  // This attribute coder stores a pointer to a value.  It forwards
  // make_attribute to the pointed-to value for mapping from
  // strings. It intercepts parse_attribute to prevent a value change.
  template <typename Value>
  class attribute_coder_ro: public attribute_coder<Value>
  {
  public:
    attribute_coder_ro (Value* p): attribute_coder<Value> (p) {}

    // Override to disable writing.
    sid::component::status
    parse_attribute (const std::string& str)
      {
	return sid::component::bad_value;
      }
    
    ~attribute_coder_ro() { }
  };


  // This attribute coder stores a literal const value.  It forwards
  // make_attribute to the value for mapping from strings.  It
  // intercepts parse_attribute to prevent a value change.
  template <typename Value>
  class attribute_coder_ro_value: public attribute_coder_base
  {
    const Value value;

  public:
    attribute_coder_ro_value (const Value& v): value (v) {}

    std::string make_attribute () const
      {
	return sidutil::make_attribute (value);
      }

    sid::component::status parse_attribute (const std::string& str)
      {
	return sid::component::bad_value; 
      }
    
    ~attribute_coder_ro_value() { }
 
  };


  // This attribute coder is like basic attribute_coder<>, but it
  // calls a notification function after any parse_attribute attempt.
  template <typename Value, class Class>
  class attribute_coder_notify: public attribute_coder<Value>
  {
    typedef void (Class::*Callback) ();
    Class* receiver;
    Callback pmf;

  public:
    attribute_coder_notify (Value* p, Class* rec, Callback f):
      attribute_coder<Value> (p), receiver (rec), pmf (f) {}

    sid::component::status
    parse_attribute (const std::string& str)
      {
	sid::component::status stat = 
	  attribute_coder<Value>::parse_attribute (str);
	// XXX: make sense to call pmf if stat != ok?
	// XXX: could even endavour to restore previous value if != ok
	 (receiver->*pmf) ();
	return stat;
      }
  };


  // This attribute coder class performs its work by reading/writing
  // a fixed address via a bus.
  template <class DataType>
  class attribute_coder_bus_rw: public attribute_coder_base
  {
    mutable sid::bus* target;
    sid::host_int_4 address;

  public:
    attribute_coder_bus_rw (sid::bus* t, sid::host_int_4 a)
			  : target (t), address (a) 
      {
	assert (t != 0);
      }

    std::string make_attribute () const
      { 
	DataType value;
	sid::bus::status s2 = this->target->read (address, value);
	if (s2 == sid::bus::ok) return sidutil::make_attribute (value);
	else return "";
      }

    sid::component::status parse_attribute (const std::string& str)
      {
	DataType value;
	sid::component::status s1 = sidutil::parse_attribute (str, value);
	if (s1 != sid::component::ok) return s1;
	sid::bus::status s2 = this->target->write (address, value);
	if (s2 == sid::bus::ok) return sid::component::ok;
	else return sid::component::bad_value;
      }
    
    ~attribute_coder_bus_rw() { }
  };


  // This is a read-only variety of the same thing.
  template <class DataType>
  class attribute_coder_bus_ro: public attribute_coder_bus_rw<DataType>
  {
  public:
    attribute_coder_bus_ro (sid::bus* t, sid::host_int_4 a): 
      attribute_coder_bus_rw<DataType> (t, a) {}

    sid::component::status parse_attribute (const std::string& str)
      {
	return sid::component::bad_value;
      }
  };


  // This is a write-only variety of the same thing.  It returns the
  // last successfully written value on reads.
  template <class DataType>
  class attribute_coder_bus_wo: public attribute_coder_bus_rw<DataType>
  {
  public:
    attribute_coder_bus_wo (sid::bus* t, sid::host_int_4 a): 
      attribute_coder_bus_rw<DataType> (t, a),
      last_written_attribute ("no value")
      {}

    std::string make_attribute () const
      { 
	return this->last_written_attribute;
      }

    sid::component::status parse_attribute (const std::string& str)
      {
	sid::component::status s = attribute_coder_bus_rw<DataType>::parse_attribute (str);
	if (s == sid::component::ok)
	  this->last_written_attribute = str;
	return s;
      }

   ~attribute_coder_bus_wo() { }

  private:
    std::string last_written_attribute;
  };


#ifdef HAVE_HASHING
  struct hash_string
  {
    size_t
    operator () (const std::string& s) const
      {
	// XXX: improve? 
	return std::hash<const char*> () (s.c_str ()); 
      }
  };
#endif


  // A mix-in for classes with largely static attribute lists.
  class fixed_attribute_map_component: public virtual sid::component
  {
  private:
    // use hash table for this, if available
#ifdef HAVE_HASHING
    typedef std::hash_map<std::string,attribute_coder_base*,hash_string> attribute_map_t;
#else
    typedef std::map<std::string,attribute_coder_base*> attribute_map_t;
#endif
    mutable attribute_map_t attribute_map;

  private:
    // map attribute name <-> category name

    // Each matching entry in these parallel lists represents one
    // attribute name <-> category name relationship.
    std::vector<std::string> category_pair_attribute;
    std::vector<std::string> category_pair_category;

    // XXX: This used to be a pair of string->set<string> maps, but
    // the compiler working set blew up.
    
  protected:
    ~fixed_attribute_map_component () { /* XXX: delete coder objects */ }

    // Add or remove an attribute <-> category association.  The named
    // attribute must already exist.
    void
    categorize (const std::string& attr, const std::string& category)
      {
	assert (this->attribute_map.find (attr) != this->attribute_map.end ());

	// Add a matching pair into the category_pair vectors.
	this->category_pair_attribute.push_back (attr);
	this->category_pair_category.push_back (category);

	// size of both vectors should be same 
	assert (this->category_pair_attribute.size () == 
					this->category_pair_category.size ());
      }


    // Remove all entry pairs from the category_pair vectors where the
    // attribute name matches the argument attr.
    void
    uncategorize (const std::string& attr)
      {
	assert (this->attribute_map.find (attr) != this->attribute_map.end ());

	// Remove all entry pairs from the category_pair vectors where
	// the attribute name matches.
	unsigned i = 0;

	while (i < this->category_pair_attribute.size ())
	  {
	    if (this->category_pair_attribute[i] == attr)
	      {
		this->category_pair_attribute.erase (
				this->category_pair_attribute.begin () + i);

		this->category_pair_category.erase (
				this->category_pair_category.begin () + i );
	      }
	    else
	      i++;
	  }
	
	assert (this->category_pair_attribute.size () == 
		this->category_pair_category.size ());
      }


    // Low level add-attribute: supply associated coder instance
    // XXX: candidates for moving out-of-line
    void
    add_attribute_coder (const std::string& name,
			attribute_coder_base* coder_ptr)
      {
	assert (this->attribute_map.find (name) == this->attribute_map.end ());
	this->attribute_map[name] = coder_ptr;
      }
    
    
    void
    add_attribute_coder (const std::string& name,
			attribute_coder_base* coder_ptr, 
			const std::string& category)
      {
	this->add_attribute_coder (name, coder_ptr);
	this->categorize (name, category);
      }

    // Add basic attribute; use streaming conversions
    template <typename Value>
    void
    add_attribute (const std::string& name, Value* ptr)
      { 
	this->add_attribute_coder (name, new attribute_coder<Value> (ptr)); 
      }

    
    template <typename Value>
    void
    add_attribute (const std::string& name, Value* ptr, 
		  const std::string& category)
      { 
	this->add_attribute (name, ptr);
	this->categorize (name, category);
      }
    
    // Add read-only attribute
    template <typename Value>
    void
    add_attribute_ro (const std::string& name, Value* str_ptr)
      {
	this->add_attribute_coder (name,
				  new attribute_coder_ro<Value> (str_ptr));
      }
    
    template <typename Value>
    void
    add_attribute_ro (const std::string& name, Value* str_ptr, 
		     const std::string& category)
      {
	this->add_attribute_ro (name, str_ptr);
	this->categorize (name, category);
      }
    
    
    // Add read-only value attribute
    template <typename Value>
    void
    add_attribute_ro_value (const std::string& name, const Value& v)
      {
	this->add_attribute_coder (name,
				  new attribute_coder_ro_value<Value> (v));
      }
    
    
    template <typename Value>
    void
    add_attribute_ro_value (const std::string& name, const Value& v,
			   const std::string& category)
      {
	this->add_attribute_ro_value (name, v);
	this->categorize (name, category);
      }

    // Add an attribute alias
    void
    add_attribute_alias (const std::string& aka, const std::string& name)
      {
	this->add_attribute_coder (aka,
				   new attribute_coder_alias (this, name));
      }

    void
    add_attribute_alias (const std::string& aka, const std::string& name, 
			 const std::string& category)
      {
	this->add_attribute_alias (aka, name);
	this->categorize (name, category);
      }

    
    // Add a r/w attribute.  After a write, call given function.
    template <typename Value, class Class>
    void
    add_attribute_notify (const std::string& name, Value* str_ptr, 
			 Class* receiver,
			 void (Class::*pmf) ())
      {
	this->add_attribute_coder (name, 
				  new attribute_coder_notify<Value,Class>
				  (str_ptr, receiver, pmf));
      }
    
    template <typename Value, class Class>
    void
    add_attribute_notify (const std::string& name, Value* str_ptr, 
			 Class* receiver,
			 void (Class::*pmf) (),
			 const std::string& category)
      {
	this->add_attribute_notify (name, str_ptr, receiver, pmf);
	this->categorize (name, category);
      }
    
    
    // Add a r/w attribute.  Use given functions for getting/setting values.
    template <class Class, typename Getter, typename Setter>
    void
    add_attribute_virtual (const std::string& name,
			  Class* receiver,
			  Getter getter,
			  Setter setter)
      {
	this->add_attribute_coder (name,
				  new attribute_coder_virtual<Class> (receiver,
								      getter, 
								      setter));
      }
    
    template <class Class, typename Getter, typename Setter>
    void
    add_attribute_virtual (const std::string& name,
			  Class* receiver,
			  Getter getter,
			  Setter setter,
			  const std::string& category)
      {
	this->add_attribute_virtual (name, receiver, getter, setter);
	this->categorize (name, category);
      }

    // Add a parameterized r/w attribute.  Use given functions for getting/setting values.
    template <class Class, typename Getter, typename Setter, typename Parameter>
    void
    add_attribute_virtual_parameterized (const std::string& name,
					 Parameter param,
					 Class* receiver,
					 Getter getter,
					 Setter setter)
      {
	this->add_attribute_coder (name,
				   new attribute_coder_virtual_parameterized<Class,Parameter>
				   (receiver,
				    getter, 
				    setter,
				    param));
      }


    template <class Class, typename Getter, typename Setter, typename Parameter>
    void
    add_attribute_virtual_parameterized (const std::string& name,
					 Parameter param,
					 Class* receiver,
					 Getter getter,
					 Setter setter,
					 const std::string& category)
      {
	this->add_attribute_virtual_parameterized (name,
						   param,
						   receiver,
						   getter, 
						   setter);
	this->categorize (name, category);
      }



    // Removes attribute name from component.
    void
    remove_attribute (const std::string& name)
      {
	assert (this->attribute_map.find (name) != this->attribute_map.end ());
	this->uncategorize (name);
	this->attribute_map.erase (name);
	// XXX: delete coder?
      }
    
    
  public:
    // Returns vector containing names of all component's attributes.  
    std::vector<std::string>
    attribute_names () throw()
      {
	std::vector<std::string> names;
	for (attribute_map_t::const_iterator it = 
		               this->attribute_map.begin();
	     it != this->attribute_map.end();
	     it++)
	   {
	     names.push_back ((*it).first);
	   }
	return names;
      }
    
    // Method returns the names of a component's attribute in a given
    // category.
    std::vector<std::string>
    attribute_names (const std::string& category) throw()
      {
	 std::vector<std::string> attrs;
	 for (unsigned i= 0; i< this->category_pair_category.size(); i++)
	    {
	      if (this->category_pair_category[i] == category)
	        attrs.push_back (this->category_pair_attribute[i]);
	    }
	 return attrs;
      }
    
    // Method returns attribute value corresponding to attribute name
    // passed as argument. Method returns value in std::string form
    // using make_atribute method.
    std::string
    attribute_value (const std::string& name) throw()
      {
	attribute_map_t::iterator it = this->attribute_map.find(name);
	if (it == this->attribute_map.end())
	  return "";
	else
	  return ((*it).second)->make_attribute ();
      }
    
    
    // Method sets attribute value corresponding to attribute name (arg. 1).
    // The value of attribute is set by parsing argument value using
    // parse_attribute method. Method returns ok if value is set.
    component::status
    set_attribute_value (const std::string& name,
			const std::string& value) throw()
      {
	    attribute_map_t::iterator it = this->attribute_map.find (name);
	    if (it == this->attribute_map.end ())
	      return component::not_found;
	    else
	      return ((*it).second)->parse_attribute (value);
      }
  };

  // A configurable_component maintains a relationship with a
  // sid-control-dynamic-configurator component and reconfigures itself
  // when its configure! attribute is set.
  class configurable_component:
    public virtual fixed_attribute_map_component
  {
  public:
    configurable_component ()
      {
	add_attribute_virtual ("configure!", this,
			       & configurable_component::dynamic_config,
			       & configurable_component::nothing);
      }
    ~configurable_component() {}

    // Dynamic reconfiguration support
  private:
    std::string nothing() { return ""; }
  protected:
    virtual component::status
    dynamic_config(const std::string& spec)
      {
	// Call the configure method to handle each configuration item.
	std::vector<std::string> parts = sidutil::tokenize (spec, ":");
	unsigned size = parts.size ();
	for (unsigned i = 0; i < size; ++i)
	  configure (parts[i]);
	return component::ok;
      }

    virtual void configure (const std::string &config) {}
  };

  // A mix-in for classes with user logging.
  class fixed_attribute_map_with_logging_component
  : public virtual fixed_attribute_map_component,
    public virtual fixed_pin_map_component,
    public virtual configurable_component
  {
  protected:
    fixed_attribute_map_with_logging_component () :
      ulog_level (0),
      ulog_mode ("less"),
      ulog_out_pin (),
      buffer_output (false)
      {
	add_attribute ("buffer-output", &buffer_output, "setting");
	add_attribute ("ulog-level", &ulog_level, "setting");
	add_attribute ("ulog-mode",  &ulog_mode,  "setting");
	add_pin ("ulog-out", & ulog_out_pin);
	ulog_logger =  new logger (& ulog_out_pin, buffer_output, ulog_level, ulog_mode);
      }
    ~fixed_attribute_map_with_logging_component ()
      {
	// Output any saved messages.
	ulog_logger->output_saved_messages ();
      }

    void log (sid::host_int_4 level, const char *fmt, ...)
      {
	va_list ap;
	va_start (ap, fmt);
	// In case values changed
	ulog_logger->set_attributes (buffer_output, ulog_level, ulog_mode);
	ulog_logger->log (level, fmt, ap);
	va_end (ap);
      }

  protected:
    bool check_level (sid::host_int_4 level) const
      {
	return ulog_logger->check_level (level);
      }
    sid::host_int_4 ulog_level;
    std::string ulog_mode;
    sidutil::output_pin ulog_out_pin;
    bool buffer_output;
    sidutil::logger *ulog_logger;

protected:
    // Dynamic configuration support
    virtual void configure (const string &config)
      {
	// Call up to the base class
	configurable_component::configure (config);

	// Handle items specific to this component
	if (config.size () < 11)
	  return;
	if (config.substr (0, 10) == "ulog-mode=")
	  {
	    ulog_mode = config.substr (10);
	    ulog_logger->set_attributes (buffer_output, ulog_level, ulog_mode);
	    return;
	  }
	if (config.size () < 12)
	  return;
	if (config.substr (0, 11) == "ulog-level=")
	  {
	    sid::host_int_4 level;
	    sid::component::status s = sidutil::parse_attribute (config.substr (11), level);
	    if (s == sid::component::ok)
	      ulog_level = level;
	    ulog_logger->set_attributes (buffer_output, ulog_level, ulog_mode);
	    return;
	  }
      }
  };


  // A mix-in for components which need to save and restore state
  // at given time indices.
  class reversible_component :
    public virtual fixed_pin_map_component,
    public virtual fixed_attribute_map_component
  {
  public:
    reversible_component () :
      reversible_p (false),
      restore_to_time_pin (this, & reversible_component::restore_state_to_time)
      {
	add_pin ("restore-to-time!", & this->restore_to_time_pin);
	add_attribute ("reversible?", & reversible_p, "setting");
      }

    ~reversible_component () {}

  protected:
    bool reversible_p;

    virtual void restore_state_to_time (sid::host_int_4) {}
    callback_pin<reversible_component> restore_to_time_pin;
  };
}

#endif // SIDATTRUTIL_H
@


1.10
log
@Support for Toshiba MeP.
@
text
@d5 1
a5 1
// Copyright (C) 1999, 2000, 2003, 2005, 2007 Red Hat.
d1130 24
@


1.9
log
@2006-03-27  Frank Ch. Eigler  <fche@@elastic.org>

	* sidcpuutil.h (basic_cpu::{read,write}_watchpoint_memory): Remove
	extra class qualification.
	* sidattrutil.h (configurable_component::nothing): Ditto.
@
text
@d5 1
a5 1
// Copyright (C) 1999, 2000, 2003, 2005 Red Hat.
d402 1
a402 1
    virtual ~attribute_coder_base() throw() {}
d434 1
a434 1
    ~attribute_coder_virtual() throw() { }
d458 1
a458 1
    ~attribute_coder_alias() throw() { }
d501 1
a501 1
   ~attribute_coder_virtual_parameterized() throw() { }
d526 1
a526 1
    ~attribute_coder() throw() { }
d546 1
a546 1
    ~attribute_coder_ro() throw() { }
d571 1
a571 1
    ~attribute_coder_ro_value() throw() { }
d635 1
a635 1
    ~attribute_coder_bus_rw() throw() { }
d678 1
a678 1
   ~attribute_coder_bus_wo() throw() { }
d722 1
a722 1
    ~fixed_attribute_map_component () throw() { /* XXX: delete coder objects */ }
d1034 1
a1034 1
    ~configurable_component() throw() {}
d1073 1
a1073 1
    ~fixed_attribute_map_with_logging_component () throw()
@


1.8
log
@2005-08-19  Dave Brolley  <brolley@@redhat.com>

        * Contribute the following changes:

        2005-07-13  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (num_cycles): New member of basic_cpu.
        (step_pin_handler): Call configure_gprof.
        (cg_profile): Call last_caller and last_callee.
        (cg_profile_jump): Call last_caller and last_callee.
        (configure_gprof): New method of basic_cpu.
        (unconfigure_gprof): New method of basic_cpu.
        (gprof_configured_p,configure_gprof_p,last_caller,last_callee)
        (pprof_spec): New members of basic_cpu.
        (configure): Call configure_gprof.
        (basic_cpu): Initialize gprof_configured_p, configure_gprof_p,
        last_caller and last_callee.
        * sidattrutil.h (configurable_component): Moved here ...
        * sidcomputil.h (configurable_component): ... from here.
        * sidbusutil.h (bus_arbitrator): Inherit from no_relation_component.

        2005-06-24  Dave Brolley  <brolley@@redhat.com>

        * sidattrutil.h (fixed_attribute_map_with_logging_component):
        Initialize buffer_output to false.

        2005-06-21  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (basic_cpu::configure): Call update_final_insn_count_p
        after processing "final-insn-count".

        2005-06-06  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (print_final_insn_count_p): New member of basic_cpu.
        (print_insn_summary): Check print_final_insn_count_p.
        (update_final_insn_count_p): New method of basic_cpu.
        (core_probe,main); New members of basic_cpu.
        (basic_cpu::configure): Handle insn-count, verbose, trace-core,
        trace-counter, trace-extract, trace-semantics and final-insn-count.
        (stream_state): Stream print_final_insn_count_p.
        (destream_state): Destream print_final_insn_count_p.
        (basic_cpu): Initialize core_probe and main. Initialize
        print_final_insn_count_p. Add final-insn-count? using
        add_attribute_notify. Add relations core-probe and main.
        * sidcomputil.h (configurable_component::configure_pin_handler): Now
        virtual.

        2005-05-29  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (basic_cpu): New inherits from configurable_component.
        (cg_jump_pin,cg_return_pin): New members of basic_cpu.
        (cg_profile_jump): New method of basic_cpu.
        (configure): New virtual override on basic_cpu.
        (basic_cpu): Initialize gprof. Add cg-return and cg-jump pins. Add
        gprof relation.
        * sidcomputil.h (configurable_component): New mix-in class for component
s.
        * sidattrutil.h (sidcomputil.h): #include it.
        (fixed_attribute_map_with_logging_component): Inherit from
        configurable_component.
        (configure): New virtual override in
        fixed_attribute_map_with_logging_component.
@
text
@d1038 1
a1038 1
    std::string configurable_component::nothing() { return ""; }
@


1.7
log
@2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (read_insn_memory): Only call
        record_insn_memory_read_latency if --trace-counter or
        --final-insn-count are specified.
        (write_insn_memory): Ditto.
        (read_data_memory): Ditto.
        (write_data_memory): Ditto.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (record_insn_memory_read_latency): New virtual method.
        (record_insn_memory_write_latency): New virtual method.
        (record_data_memory_read_latency): New virtual method.
        (record_data_memory_write_latency): New virtual method.
        (read_insn_memory): Call record_insn_memory_read_latency.
        (write_insn_memory): Call record_insn_memory_write_latency.
        (read_data_memory): Call record_data_memory_read_latency.
        (write_data_memory): Call record_data_memory_write_latency.
        * sidattrutil.h (fixed_attribute_map_with_logging_component::check_level):
        now protected and returns bool.
        * sidblockingutil.h: Rework ulog levels.
        * sidbusutil.h (bus_arbitrator): Rework ulog levels. Return the result
        of busy_status instead of bus::busy. New methods: busy_status and
        access_latency.
        (perform_read): Only call set_route_busy is status is bus::ok.
        (perform_write): Only call set_route_busy is status is bus::ok.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * sidbusutil.h (bus_arbitrator::input_interface): New class.
        (bus_arbitrator::reschedule): Reschedule after the given number of
        cycles.
        (bus_arbitrator::arbitrate_read): New method.
        (bus_arbitrator::arbitrate_write): New method.
        (bus_arbitrator::prioritize_request): New virtual method.
        (bus_arbitrator::perform_read): Propogate the lock from the upstream
        interface to the downstream interface.
        (bus_arbitrator::perform_write): Ditto.
        (bus_arbitrator::lock_downstream): New virtual method.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * sidblockingutil.h (blocking_component): Reimplement using mutexes
        for synchronization.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (basic_cpu): Inherit virtually from all base classes.
        (basic_cpu::step_pin_handler): Now virtual.
        (basic_cpu::{read,write}_{insn,data}_memory): No longer const. Call
        handle_{insn,data}_memory_{read,write}_error for bus errors.
        (basic_big_endian_cpu::{read,write_{insn,data}_memory*): No longer
        const.
        (basic_little_endian_cpu): Ditto.
        * sidcomp.h (bus::status_t): Add 'busy'.
        * sidattrutil.h: Remove unused code.
        * sidblockingutil.h: New header.
@
text
@d5 1
a5 1
// Copyright (C) 1999, 2000, 2003 Red Hat.
d13 1
d1021 33
d1057 2
a1058 1
    public virtual fixed_pin_map_component
d1065 1
a1065 1
      buffer_output (true)
a1075 1
	// output_saved_messages ();
d1099 29
d1129 1
@


1.6
log
@2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * sidbusutil.h (passthrough_bus::target): Now 'protected'.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        For Stan Cox  <scox@@redhat.com>
        * sidmiscutil.h (logger): New class.
        * sidattrutil.h (fixed_attribute_map_with_logging_component): Convert
        to use logger.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (set_total_latency): New method of basic_cpu.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * sidattrutil.h (SID_LOG_PERSISTENT_BUFFER): New macro.
        (SID_LOG_TRANSIENT_MALLOC_BUFFER): New macro.
        (buffer_output): New member of
        fixed_attribute_map_with_logging_component.
        (fixed_attribute_with_logging_component): Add buffer-output attribute.
        Use SID_LOG_PERSISTENT_BUFFER.
        (~fixed_attribute_with_logging_component): Use
        SID_LOG_PERSISTENT_BUFFER.
        (log): Buffer output based on buffer_output. Use
        SID_LOG_TRANSIENT_MALLOC_BUFFER.
        * sidcpuutil.h (get_total_latency): New method of basic_cpu.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * sidattrutil.h (log): Don't use STDCTYPE for vsnprint or vasprintf.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        For Stan Cox  <scox@@redhat.com>
        * sidmiscutil.h (bijection::find): Add typename.
        * sidbusutil.h (ro_value_control_register): New ValueType typedef.
        (control_register_bus::word_write, control_register_bus::word_read):
        Add typename

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * sidattrutil.h (iostream): #include it.
        (log): Use std::cerr and std::endl.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * sidattrutil.h (fixed_attribute_map_with_logging_component):
        Initialize saved_messages and saved_levels.
        (~fixed_attribute_map_with_logging_component): Output saved messages.
        Delete buffer if necessary.
        (log): Save message for later if output pin not connected. Otherwise
        output saved messages before the new message. Use vsnprintf or
        vasprintf if possible.
        (check_level): New member of fixed_attribute_map_with_logging_component.
        (output_saved_messages): Ditto.
@
text
@a1024 2
#define SID_LOG_PERSISTENT_BUFFER (HAVE_VSNPRINTF || ! HAVE_VASPRINTF)
#define SID_LOG_TRANSIENT_MALLOC_BUFFER (! SID_LOG_PERSISTENT_BUFFER)
d1030 1
a1030 4
      buffer_output (true),
      buffer_size (4096), // big enough for now
      saved_messages (),
      saved_levels ()
a1036 3
#if SID_LOG_PERSISTENT_BUFFER
	buffer = new char[buffer_size];
#endif
a1042 3
#if SID_LOG_PERSISTENT_BUFFER
	delete [] buffer;
#endif
d1055 2
a1056 2
private:
    bool check_level (sid::host_int_4 level)
d1058 1
a1058 1
	ulog_logger->check_level (level);
a1059 16

    void output_saved_messages ()
      {
	while (saved_messages.size () > 0)
	  {
	    if (check_level (saved_levels[0]))
	      {
		std::string s = saved_messages[0];
		for (int i = 0; i < s.size (); ++i)
		  ulog_out_pin.drive (s[i]);
	      }
	    saved_messages.erase (saved_messages.begin ());
	    saved_levels.erase (saved_levels.begin ());
	  }
      }

a1064 6
    char *buffer;
    long buffer_size;
    std::vector<std::string> saved_messages;
    std::vector<sid::host_int_4> saved_levels;
#undef SID_LOG_PERSISTENT_BUFFER
#undef SID_LOG_TRANSIENT_MALLOC_BUFFER
@


1.5
log
@2003-06-20  Frank Ch. Eigler  <fche@@redhat.com>

	* sidattrutil.h (fixed_attribute_map_with_logging_component):
	Add throw() decoration to dtor.
@
text
@d5 1
a5 1
// Copyright (C) 1999, 2000, 2002, 2003 Red Hat.
d46 1
d691 1
a691 1
	return hash<const char*> () (s.c_str ()); 
d703 1
a703 1
    typedef hash_map<std::string,attribute_coder_base*,hash_string> attribute_map_t;
d1041 1
d1049 2
a1050 1
	output_saved_messages ();
d1056 1
a1056 1
    virtual void log (sid::host_int_4 level, const char *fmt, ...)
d1058 6
a1063 55
	if (! buffer_output)
	  {
	    // Output any saved messages first
	    output_saved_messages ();

	    // Check the logging level and mode.
	    if (! check_level (level))
	      return;
	  }

	// Write the message into a buffer.
	int length;
	for (;;)
	  {
	    va_list ap;
	    va_start (ap, fmt);
#if HAVE_VSNPRINTF
	    length = vsnprintf (buffer, buffer_size, fmt, ap);
	    va_end (ap);
	    if (length < buffer_size)
	      break;
	    delete [] buffer;
	    buffer_size = length + 256;
	    buffer = new char[buffer_size];
#elif HAVE_VASPRINTF
	    length = vasprintf (&buffer, fmt, ap);
	    va_end (ap);
	    break;
#else
	    length = STDCTYPE(vsprintf) (buffer, fmt, ap);
	    va_end (ap);
	    if (length >= buffer_size)
	      std::cerr << "Error: ulog buffer overflow!!!" << std::endl;
	    break;
#endif
	  }

	// If the output pin is not connected yet, Save the message for
	// later. This happens when the log message is issued from the
	// component's constructor.
	if (buffer_output)
	  {
	    saved_messages.push_back (std::string (buffer));
	    saved_levels.push_back (level);
	  }
	else
	  {
	    // Otherwise, output the new message.
	    for (int i = 0; i < length; ++i)
	      ulog_out_pin.drive (buffer[i]);
	  }

#if SID_LOG_TRANSIENT_MALLOC_BUFFER
	free (buffer);
#endif
d1069 1
a1069 8
	if (level > ulog_level)
	  return false;

	if (level != ulog_level
	    && (ulog_mode == "match" || ulog_mode == "equal"))
	  return false;

	return true;
d1091 1
@


1.4
log
@2003-06-10  Dave Brolley  <brolley@@redhat.com>

        * sidattrutil.h (sidpinutil.h): #include it.
        (iostream): Ditto.
        (stdio.h): Ditto.
        (stdarg.h): Ditto.
        (fixed_attribute_map_with_logging_component): New class.
@
text
@d1044 1
a1044 1
    ~fixed_attribute_map_with_logging_component () /* throw() */
@


1.3
log
@* gcc 3.2 compatibility fixes

[e.g. include/ChangeLog]
2002-11-22  Frank Ch. Eigler  <fche@@redhat.com>

	* sidattrutil.h: Give up on hash tables - too many incompatible
	libstdc++'s out there.
	* configure.in: Don't bother looking for hash stuff.
	* configure, sidconfutil.in: Regenerated.
	* sidmiscutil.h: Add some "typename" qualifiers.
	* sidcpuutil.h (cpu_trace_stream): Trade publicness for friendliness
	regarding cout_p.

[e.g., component/parport/ChangeLog]
2002-11-22  Frank Ch. Eigler  <fche@@redhat.com>

	* ps2.cxx (parport_inputpin): Fix formal arg list.

[e.g., component/interrupt/ChangeLog]
2002-11-22  Frank Ch. Eigler  <fche@@redhat.com>

	* components.cxx (compInterruptDelete): Avoid dynamic_cast on
	deleted pointer.
@
text
@d5 1
a5 1
// Copyright (C) 1999, 2000, 2002 Red Hat.
d13 1
d30 2
d36 1
d1017 133
@


1.2
log
@* GCC 3.0 & 2.95.3 fixes.

[component/audio/ChangeLog]
	* compAudio.cxx (fd_audio): Add missing throw() specifiers to this dtor.
	* components.h (basic_codec, generic_audio, nop_audio, fd_audio,
	linux_audio, solaris_audio): Add missing throw() specifiers to these
	dtors.

[component/cfgroot/ChangeLog]
	* compConfig.cxx (cfgroot_component): Add missing throw() specifiers
	to this dtor.

[component/tcl/ChangeLog]
	* compTcl.cxx (tcl_component): Add missing throw() specifiers to this
	dtor.

[include/ChangeLog]
	* sidattrutil.h (attribute_coder_base, attribute_coder_virtual,
	attribute_coder_alias, attribute_coder_virtual_parameterized,
	attribute_coder, attribute_coder_ro, attribute_coder_ro_value,
	attribute_coder_bus_rw, attribute_coder_bus_wo,
	fixed_attribute_map_component): Add missing throw() specifiers
	to these dtors.
	* sidbusutil.h (word_bus, passthrough_bus, mux_passthrough_bus,
	passthrough_word_bus, harvard_bus, byte_bus, callback_byte_bus,
@
text
@d5 1
a5 1
// Copyright (C) 1999, 2000 Red Hat.
d30 1
a30 9

#ifdef HAVE_EXT_HASH_MAP
#include <ext/hash_map>
#define HAVE_HASHING 1
#else
#ifdef HAVE_HASH_MAP
#include <hash_map>
#define HAVE_HASHING 1
#else
a31 2
#endif
#endif
d686 1
a686 1
	return std::hash<const char*> () (s.c_str ()); 
d698 1
a698 1
    typedef std::hash_map<std::string,attribute_coder_base*,hash_string> attribute_map_t;
@


1.1
log
@* public snapshot of sid simulator
@
text
@d406 1
a406 1
    virtual ~attribute_coder_base() {}
d438 1
a438 1
    ~attribute_coder_virtual() { }
d462 1
a462 1
    ~attribute_coder_alias() { }
d505 1
a505 1
   ~attribute_coder_virtual_parameterized() { }
d530 1
a530 1
    ~attribute_coder() { }
d550 1
a550 1
    ~attribute_coder_ro() { }
d575 1
a575 1
    ~attribute_coder_ro_value() { }
d639 1
a639 1
    ~attribute_coder_bus_rw() { }
d682 1
a682 1
   ~attribute_coder_bus_wo() { }
d726 1
a726 1
    ~fixed_attribute_map_component () { /* XXX: delete coder objects */ }
@

