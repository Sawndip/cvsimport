head	1.11;
access;
symbols
	sid-snapshot-20180601:1.11
	sid-snapshot-20180501:1.11
	sid-snapshot-20180401:1.11
	sid-snapshot-20180301:1.11
	sid-snapshot-20180201:1.11
	sid-snapshot-20180101:1.11
	sid-snapshot-20171201:1.11
	sid-snapshot-20171101:1.11
	sid-snapshot-20171001:1.11
	sid-snapshot-20170901:1.11
	sid-snapshot-20170801:1.11
	sid-snapshot-20170701:1.11
	sid-snapshot-20170601:1.11
	sid-snapshot-20170501:1.11
	sid-snapshot-20170401:1.11
	sid-snapshot-20170301:1.11
	sid-snapshot-20170201:1.11
	sid-snapshot-20170101:1.11
	sid-snapshot-20161201:1.11
	sid-snapshot-20161101:1.11
	sid-snapshot-20160901:1.11
	sid-snapshot-20160801:1.11
	sid-snapshot-20160701:1.11
	sid-snapshot-20160601:1.11
	sid-snapshot-20160501:1.11
	sid-snapshot-20160401:1.11
	sid-snapshot-20160301:1.11
	sid-snapshot-20160201:1.11
	sid-snapshot-20160101:1.11
	sid-snapshot-20151201:1.11
	sid-snapshot-20151101:1.11
	sid-snapshot-20151001:1.11
	sid-snapshot-20150901:1.11
	sid-snapshot-20150801:1.11
	sid-snapshot-20150701:1.11
	sid-snapshot-20150601:1.11
	sid-snapshot-20150501:1.11
	sid-snapshot-20150401:1.11
	sid-snapshot-20150301:1.11
	sid-snapshot-20150201:1.11
	sid-snapshot-20150101:1.11
	sid-snapshot-20141201:1.11
	sid-snapshot-20141101:1.11
	sid-snapshot-20141001:1.11
	sid-snapshot-20140901:1.11
	sid-snapshot-20140801:1.11
	sid-snapshot-20140701:1.11
	sid-snapshot-20140601:1.11
	sid-snapshot-20140501:1.11
	sid-snapshot-20140401:1.11
	sid-snapshot-20140301:1.11
	sid-snapshot-20140201:1.11
	sid-snapshot-20140101:1.11
	sid-snapshot-20131201:1.11
	sid-snapshot-20131101:1.11
	sid-snapshot-20131001:1.11
	sid-snapshot-20130901:1.11
	sid-snapshot-20130801:1.11
	sid-snapshot-20130701:1.11
	sid-snapshot-20130601:1.11
	sid-snapshot-20130501:1.11
	sid-snapshot-20130401:1.11
	sid-snapshot-20130301:1.11
	sid-snapshot-20130201:1.11
	sid-snapshot-20130101:1.11
	sid-snapshot-20121201:1.11
	sid-snapshot-20121101:1.11
	sid-snapshot-20121001:1.11
	sid-snapshot-20120901:1.11
	sid-snapshot-20120801:1.11
	sid-snapshot-20120701:1.11
	sid-snapshot-20120601:1.11
	sid-snapshot-20120501:1.11
	sid-snapshot-20120401:1.11
	sid-snapshot-20120301:1.11
	sid-snapshot-20120201:1.11
	sid-snapshot-20120101:1.11
	sid-snapshot-20111201:1.11
	sid-snapshot-20111101:1.11
	sid-snapshot-20111001:1.11
	sid-snapshot-20110901:1.11
	sid-snapshot-20110801:1.11
	sid-snapshot-20110701:1.11
	sid-snapshot-20110601:1.11
	sid-snapshot-20110501:1.11
	sid-snapshot-20110401:1.11
	sid-snapshot-20110301:1.11
	sid-snapshot-20110201:1.11
	sid-snapshot-20110101:1.11
	sid-snapshot-20101201:1.11
	sid-snapshot-20101101:1.11
	sid-snapshot-20101001:1.11
	sid-snapshot-20100901:1.11
	sid-snapshot-20100801:1.11
	sid-snapshot-20100701:1.11
	sid-snapshot-20100601:1.11
	sid-snapshot-20100501:1.11
	sid-snapshot-20100401:1.11
	sid-snapshot-20100301:1.11
	sid-snapshot-20100201:1.11
	sid-snapshot-20100101:1.11
	sid-snapshot-20091201:1.11
	sid-snapshot-20091101:1.11
	sid-snapshot-20091001:1.11
	sid-snapshot-20090901:1.11
	sid-snapshot-20090801:1.11
	sid-snapshot-20090701:1.11
	sid-snapshot-20090601:1.11
	sid-snapshot-20090501:1.11
	sid-snapshot-20090401:1.11
	sid-snapshot-20090301:1.11
	sid-snapshot-20090201:1.11
	sid-snapshot-20090101:1.11
	sid-snapshot-20081201:1.11
	sid-snapshot-20081101:1.10
	sid-snapshot-20081001:1.10
	sid-snapshot-20080901:1.10
	sid-snapshot-20080801:1.10
	sid-snapshot-20080701:1.10
	sid-snapshot-20080601:1.9
	sid-snapshot-20080501:1.9
	sid-snapshot-20080403:1.9
	sid-snapshot-20080401:1.9
	sid-snapshot-20080301:1.9
	sid-snapshot-20080201:1.9
	sid-snapshot-20080101:1.9
	sid-snapshot-20071201:1.9
	sid-snapshot-20071101:1.9
	sid-snapshot-20071001:1.9
	sid-20020905-branchpoint:1.4
	sid-20020905-branch:1.4.0.2
	cygnus_cvs_20020108_pre:1.4;
locks; strict;
comment	@ * @;


1.11
date	2008.11.07.21.35.44;	author fche;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.17.18.11.01;	author brolley;	state Exp;
branches;
next	1.9;

1.9
date	2007.02.05.20.28.42;	author brolley;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.17.19.51.02;	author brolley;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.21.21.38.24;	author brolley;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.22.20.35.00;	author fche;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.09.15.07.32;	author bje;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.25.15.32.51;	author fche;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.14.22.56.20;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.26.19.18.40;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.07.19.31.09;	author fche;	state Exp;
branches;
next	;


desc
@@


1.11
log
@2008-11-07  Frank Ch. Eigler  <fche@@redhat.com>

	* (*): Change some "char *" -> "const char *" declarations for
	warning suppression on gcc 4.3.
@
text
@// sidmiscutil.h - Useful utility classes.  -*- C++ -*-

// Copyright (C) 1999-2003, 2006, 2007 Red Hat.
// This file is part of SID and is licensed under the GPL.
// See the file COPYING.SID for conditions for redistribution.

#ifndef SIDMISCUTIL_H
#define SIDMISCUTIL_H

#include <sidconfig.h>
#include <sidpinutil.h>

#include <string>
#include <iostream>
#include <fstream>
#include <vector>
#include <map>
#include <cassert>
#include <cctype>
#include <cerrno>
#include <cstring>
#ifdef __CYGWIN__
#include <sys/cygwin.h>
#endif
// XXX: kludge for compatibility both with old & new libstdc++
#if STD_CCTYPE
#define STDCTYPE(func) std::func
#else
#define STDCTYPE(func) func
#endif

#include <limits.h>
#include <stdio.h>
#include <stdarg.h>

using std::string;
using std::vector;

namespace sidutil
{
  // Instances of this class template function as bidirectional lookup
  // tables (bijections) for mapping objects to each other by value.
  template <class Obj1, class Obj2>
  class bijection
  {
    typedef std::map<Obj1,Obj2> forward_t;
    typedef std::map<Obj2,Obj1> backward_t;
    mutable forward_t forward;
    mutable backward_t backward;
    
  public:
    
    // Find Obj2 by Obj1.
    bool
    find(const Obj1& one, Obj2& two) const
      {
	typename forward_t::const_iterator it = this->forward.find(one);
	if (it != this->forward.end())
	  {
	    typename backward_t::const_iterator ti = this->backward.find(it->second);
	    assert (ti != this->backward.end());
	    two = it->second;
	    return true;
	  }
	else
	  return false;
      }
    
    // Find Obj1 by Obj2.
    bool
    find(const Obj2& two, Obj1& one) const
      {
	typename backward_t::iterator ti = this->backward.find(two);
	if (ti != this->backward.end())
	  {
	    typename forward_t::const_iterator it = this->forward.find(ti->second);
	    assert (it != this->forward.end());
	    one = ti->second;
	    return true;
	  }
	else
	  return false;
      }
    
    // Register Obj1<->Obj2 pair.  Both must be unique.
    void
    add (const Obj1& one, const Obj2& two)
      {
	assert (this->forward.find(one) == this->forward.end());
	this->forward[one] = two;
	assert (this->backward.find(two) == this->backward.end());
	this->backward[two] = one;
      }
    
    // Register Obj1<->Obj2 pair.  Both must be unique.
    void
    add (const Obj2& two, const Obj1& one)
      {
	this->add (one, two);
      }
    
    void
    erase_all ()
      {
	this->forward.erase(this->forward.begin(), this->forward.end());
	this->backward.erase(this->backward.begin(), this->backward.end());
      }
  };
  
  
  // This class, a possible mix-in, may be used to limit the number of
  // levels of recursion of functions.  It functions as a counter that
  // trips an assert() failure if it is made to exceed a configured
  // limit.  A limit of 0 is nonsensical and disallowed by assertion.
  class recursion_limited
  {
    friend class recursion_record;
    
    // XXX: might be nice to be signal-safe.
    int count;
    int max;
    std::string label;

  protected:
    // These functions are for use by recursion_record instances
    
    void recursion_enter ()
      {
	if (this->count <= this->max)
	  this->count ++;
	if (! ok())
	  std::cerr << label << ": recursion limit exceeded (" << this->count << ")" << std::endl;
      }
    
    void recursion_exit ()
      {
	if (this->count > 0)
	  this->count --;
	else
	  std::cerr << label << ": recursion limit underflow (" << this->count << ")" << std::endl;
      }

    bool ok () const
      {
	return (this->count >= 0 && this->count <= this->max);
      }
    
  public:
    static const unsigned default_recursion_limit = 1000;
    
    recursion_limited (const std::string& l,
		       int m = default_recursion_limit): count(0), max(m), label(l)
      {
	assert (this->max > 0);
      }
  };
  
  
  // Each instance of the recursion_record class, during its lifetime,
  // occupies one spot in a designated recursion_limited object's
  // slot.  Merely instantiate an instance of this type in any block
  // that may suffer from indefinite recursion.
  class recursion_record
  {
    recursion_limited* limiter;
    
  public:
    recursion_record (recursion_limited* l): limiter(l)
      {
	this->limiter->recursion_enter ();
      }

     bool ok () const
      {
	return (this->limiter->ok());
      }
    
    ~recursion_record ()
      {
	this->limiter->recursion_exit ();
      }
  };
  


  // The string2stream and stream2string classes may be used as
  // wrappers around string values to transmit them to/from streams.
  // Normal string stream-in operators break on word boundaries.
  // These wrappers encode arbitrary strings safely.
  // Use as follows:
  //
  // ostream o;
  // string s = "anything at all";
  // o << string2stream(s);
  //
  // istream i;
  // string s;
  // i >> stream2string(s);

  struct string2stream
  {
    const std::string& sendme;
    friend std::ostream& operator << (std::ostream& o, const string2stream& it);
  public:
    string2stream (const std::string& s): sendme(s) {}
  };
  
  
  inline std::ostream& 
  operator << (std::ostream& o, const string2stream& it)
    {
      o << '"';
      for (unsigned i=0; i<it.sendme.length(); i++)
	{
	  char c = it.sendme[i];
	  char hex[] = "0123456789ABCDEF";
	  if ((isprint(c)) && (! isspace(c)) && (c != '%'))
	    // NB: character class must not include '%' itself, and must
	    // include only chars that iostream>>std::string would consider
	    // parts of a single string.
	    o << c;
	  else
	    // print URL-encoded char
	    o << "%" << hex[(c >> 4) & 0x0f] << hex[c & 0x0f];
	}
      o << '"';
      return o;
    } 
  
  struct stream2string
  {
    std::string& parseme;
    friend std::istream& operator >> (std::istream& i, const stream2string& it);
  public:
    stream2string (std::string& s): parseme(s) {}
  };
  

  inline std::istream& 
  operator >> (std::istream& i, const stream2string& it)
    {
      std::string encoded;
      i >> encoded;
      it.parseme = "";
      
      unsigned j;
      for (j=1; j<encoded.length()-1; j++)  // ignore double-quote delimiters
	{
	  char c = encoded[j];
	  if (c != '%')
	    it.parseme += c;
	  else if (j < encoded.length() - 3) // limiting case:  "......%DD"
	    {
	      char c1 = toupper (encoded[++j]);
	      char c2 = toupper (encoded[++j]);
	      
	      // hex decoding
	      unsigned d1 = 
		(c1 >= '0' && c1 <= '9') ? (c1 - '0') :
		(c1 >= 'A' && c1 <= 'F') ? (c1 - 'A' + 10) :
		(j = encoded.length(), 0); // error: detected just before exit
	      unsigned d2 = 
		(c2 >= '0' && c2 <= '9') ? (c2 - '0') :
		(c2 >= 'A' && c2 <= 'F') ? (c2 - 'A' + 10) :
		(j = encoded.length(), 0); // error: detected just before exit
	      
	      char cc = (d1 << 4) | d2;
	      it.parseme += cc;
	    }
	  else
	    break;
	}
      
      // set flag on parse error
      if (j != encoded.length() - 1)
	i.setstate(std::ios::badbit);
      
      return i;
    } 


  // Tokenize a string.  Use given set of separator characters.
  inline std::vector<std::string> 
  tokenize (const std::string& str, const std::string& sep)
    {
      std::vector<std::string> tokens;
      std::string remainder = str;
      
      while (remainder.size() > 0)
	{
	  std::string::size_type sep_pos = remainder.find_first_of (sep);
	  if (sep_pos == std::string::npos) // no more tokens
	    {
	      tokens.push_back (remainder);
	      break;
	    }
	  else
	    {
	      tokens.push_back (remainder.substr (0, sep_pos));
	      // trim token
	      remainder = remainder.substr (sep_pos);
	      // trim to next non-separator
	      sep_pos = remainder.find_first_not_of (sep);
	      if (sep_pos == std::string::npos) // none?
		{
		  tokens.push_back ("");
		  break;
		}
	      remainder = remainder.substr (sep_pos);
	    }
	}
      return tokens;
    }


  inline std::string
  std_error_string ()
    {
      const char* error_message = "(unknown error)";
#ifdef HAVE_STRERROR
      error_message = strerror (errno);
#endif
      return std::string(error_message);
    }


  // Return a vector of directory names, where the SID_LIBRARY_PATH
  // and SID_EXEC_PREFIX environment variables are pointing.  Convert
  // all paths to POSIX form on Cygwin.
  inline std::vector<std::string>
  sid_file_search_path ()
  {
    std::vector<std::string> search_directories;

    const char* slp = getenv ("SID_LIBRARY_PATH"); // run-time configuration
    if (slp)
      {
	search_directories = tokenize (slp, ":");
      }
    
    const char* sep = getenv ("SID_EXEC_PREFIX"); // install-time configuration
#ifdef __CYGWIN__
    char conv_fn[PATH_MAX*2];
    if (sep)
      {
	int rc = cygwin_conv_to_full_posix_path (sep, conv_fn);
	if (rc != 0)
	  std::cerr << "sid_file_search_path: cygwin_conv_to_full_posix_path failed: " 
		    << std_error_string () << std::endl;
	else
	  sep = conv_fn;
      }
#endif
    if (!sep) sep = SID_EXEC_PREFIX; // build-time configuration
    // We really just want to get to pkgdatadir, which is $prefix/share
    // Guess exec-prefix == prefix
    std::string pkglibdir1 = std::string(sep) + std::string("/share");
    search_directories.push_back (pkglibdir1);
    // Guess exec-prefix == prefix/H-HOST
    std::string pkglibdir2 = std::string(sep) + std::string("/../share");
    search_directories.push_back (pkglibdir2);

    return search_directories;
  }


  // Look around cwd, the standard search dirs (.../sid)
  // At worst, return the given name.
  inline std::string
  find_sid_data_file (const std::string& file)
  {
    std::vector<std::string> file_path = sid_file_search_path ();
    std::vector<std::string> path;

    path.push_back (std::string("")); // no prefix
    for (unsigned i=0; i<file_path.size(); i++)
      path.push_back (file_path[i] + std::string("/sid/"));

    for (unsigned i=0; i<path.size(); i++)
      {
	const std::string& dir = path[i];
	std::string full_path = dir + file;
	
	// Try to open it.
	std::ifstream f (full_path.c_str());
	if (f.good())
	  return full_path;
      }

    return file;
  }

  class logger
  {
#define SID_LOG_PERSISTENT_BUFFER (HAVE_VSNPRINTF || ! HAVE_VASPRINTF)
#define SID_LOG_TRANSIENT_MALLOC_BUFFER (! SID_LOG_PERSISTENT_BUFFER)
  public:
    logger (sidutil::output_pin *p_ulog_out_pin,
	    bool p_buffer_output,
	    sid::host_int_4 p_ulog_level,
	    std::string p_ulog_mode) :
      ulog_level (p_ulog_level),
      ulog_mode (p_ulog_mode),
      buffer_output (p_buffer_output),
      buffer_size (4096), // big enough for now
      saved_messages (),
      saved_levels ()
      {
	ulog_out_pin = p_ulog_out_pin;
#if SID_LOG_PERSISTENT_BUFFER
	buffer = new char[buffer_size];
#endif
      }
    ~logger ()
      {
	// Output any saved messages.
	output_saved_messages ();
#if SID_LOG_PERSISTENT_BUFFER
	delete [] buffer;
#endif
      }

    void set_attributes (bool p_buffer_output,
 			 sid::host_int_4 p_ulog_level,
 			 std::string p_ulog_mode)
    {
      buffer_output = p_buffer_output;
      ulog_level  = p_ulog_level;
      ulog_mode = p_ulog_mode;
    }

    virtual void log (sid::host_int_4 level, const char *fmt, va_list ap)
      {
	if (! buffer_output)
	  {
	    // Output any saved messages first
	    output_saved_messages ();

	    // Check the logging level and mode.
	    if (! check_level (level))
	      return;
	  }

	// Write the message into a buffer.
	int length;
	for (;;)
	  {
#if HAVE_VSNPRINTF
	    length = vsnprintf (buffer, buffer_size, fmt, ap);
	    if (length < buffer_size)
	      break;
	    delete [] buffer;
	    buffer_size = length + 256;
	    buffer = new char[buffer_size];
#elif HAVE_VASPRINTF
	    length = vasprintf (&buffer, fmt, ap);
	    break;
#else
	    length = STDCTYPE(vsprintf) (buffer, fmt, ap);
	    if (length >= buffer_size)
	      std::cerr << "Error: ulog buffer overflow!!!" << std::endl;
	    break;
#endif
	  }

	// If the output pin is not connected yet, Save the message for
	// later. This happens when the log message is issued from the
	// component's constructor.
	if (buffer_output)
	  {
	    saved_messages.push_back (std::string (buffer));
	    saved_levels.push_back (level);
	  }
	else
	  {
	    // Otherwise, output the new message.
	    for (int i = 0; i < length; ++i)
	      ulog_out_pin->drive (buffer[i]);
	  }

#if SID_LOG_TRANSIENT_MALLOC_BUFFER
	free (buffer);
#endif
      }

  public:
    bool check_level (sid::host_int_4 level)
      {
	if (level > ulog_level)
	  return false;

	if (level != ulog_level
	    && (ulog_mode == "match" || ulog_mode == "equal"))
	  return false;

	return true;
      }

  public:
    void output_saved_messages ()
      {
	while (saved_messages.size () > 0)
	  {
	    if (check_level (saved_levels[0]))
	      {
		std::string s = saved_messages[0];
		for (int i = 0; i < s.size (); ++i)
		  ulog_out_pin->drive (s[i]);
	      }
	    saved_messages.erase (saved_messages.begin ());
	    saved_levels.erase (saved_levels.begin ());
	  }
      }

  private:
    sid::host_int_4 ulog_level;
    std::string ulog_mode;
    sidutil::output_pin *ulog_out_pin;
    bool buffer_output;
    char *buffer;
    long buffer_size;
    std::vector<std::string> saved_messages;
    std::vector<sid::host_int_4> saved_levels;
#undef SID_LOG_PERSISTENT_BUFFER
#undef SID_LOG_TRANSIENT_MALLOC_BUFFER
  public:
    void delete_saved_messages ()
    {
      saved_messages.clear ();
      saved_levels.clear ();
    }
  };

  // This class is intended for the implementation of change logging and
  // change reversing. It is optimized for a potentially large number of
  // elements and for growth, shrinkage and access as a LIFO stack. It is
  // also optimized for growing again after shrinking.
  class change_log
  {
  public:
    change_log (sid::host_int_4 g = 0x100000) :
      growth_rate (g),
      buffer (0),
      buf_index (0),
      buf_size (0),
      current_length (0)
    {}
   ~change_log ()
    {
      if (buffer)
	delete buffer;
    }

    // Begin a new record and add the given data.
    void push (const void *data, sid::host_int_4 length)
    {
      current_length = 0;
      add (data, length);
    }

    // Add the given data to the current record.
    void add (const void *data, sid::host_int_4 length)
    {
      if (buf_index + length > buf_size)
	{
	  buf_size += growth_rate * length;
	  unsigned char* new_buf = new unsigned char[buf_size];
	  if (buffer)
	    {
	      memcpy (new_buf, buffer, buf_index);
	      delete buffer;
	    }
	  buffer = new_buf;
	}

      memcpy (buffer + buf_index, data, length);
      buf_index += length;
      current_length += length;
    }

    // Complete the current record by writing its length.
    void finish ()
    {
      unsigned char l = current_length;
      add (& l, 1);
    }

    // Remove the last record.
    void pop ()
    {
      unsigned len = buffer[--buf_index];
      buf_index -= len;
    }

    // Return a pointer to the last record.
    const void *top (sid::host_int_4 &length) const
    {
      length = buffer[buf_index - 1];
      return buffer + buf_index - length - 1;
    }

    // Is the change log emtpy?
    bool empty () const { return buf_index <= 0; }

  private:
    sid::host_int_4 growth_rate;
    unsigned char* buffer;
    sid::host_int_4 buf_index;
    sid::host_int_4 buf_size;
    unsigned char current_length;
  };
}

#endif // SIDMISCUTIL_H
@


1.10
log
@2008-06-17  Dave Brolley  <brolley@@redhat.com>

        * sidmiscutil.h (change_log): New utility class.
        * sidcpuutil.h (basic_cpu): Now inherits from reversible_component.
        (step_pin_handler): Parameter now named 'tick'. Save the current
        tick. Handle exec_direction == "backward". Initialize change logging,
        if reversible. Finish change logging, if reversible.
        (step_backward): New method of basic_cpu.
        (reset_pin_handler): Terminte the current change log, if any.
        Set exec_direction to "forward".
        (change_log,change_log_begin,change_log_end,change_log_boundaries)
        (change_string,exec_direction,sim_sched,current_tick,last_tick): New
        members of basic_cpu.
        (init_change_logging,finish_change_logging,log_change)
        (restore_state_to_time): New virtual methods of basic_cpu.
        (basic_cpu): Initialize change_log, change_log_begin,
        change_log_end, change_log_boundaries, last_tick, exec_direction,
        and sim_sched. Add the exec-direction and sim-sched attributes.
        * sidattrutil.h (reversible_component): New mix-in class.
@
text
@d335 1
a335 1
    char* slp = getenv ("SID_LIBRARY_PATH"); // run-time configuration
d341 1
a341 1
    char* sep = getenv ("SID_EXEC_PREFIX"); // install-time configuration
@


1.9
log
@Support for Toshiba MeP.
@
text
@d3 1
a3 1
// Copyright (C) 1999-2003, 2007 Red Hat.
d534 78
@


1.8
log
@2003-12-17  Dave Brolley  <brolley@@redhat.com>

        * sidmiscutil.h (delete_saved_messages): Use 'clear' method.
@
text
@d3 1
a3 1
// Copyright (C) 1999-2003 Red Hat.
d414 1
a414 1
    ~logger () throw()
@


1.7
log
@2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * sidbusutil.h (passthrough_bus::target): Now 'protected'.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        For Stan Cox  <scox@@redhat.com>
        * sidmiscutil.h (logger): New class.
        * sidattrutil.h (fixed_attribute_map_with_logging_component): Convert
        to use logger.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * sidcpuutil.h (set_total_latency): New method of basic_cpu.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * sidattrutil.h (SID_LOG_PERSISTENT_BUFFER): New macro.
        (SID_LOG_TRANSIENT_MALLOC_BUFFER): New macro.
        (buffer_output): New member of
        fixed_attribute_map_with_logging_component.
        (fixed_attribute_with_logging_component): Add buffer-output attribute.
        Use SID_LOG_PERSISTENT_BUFFER.
        (~fixed_attribute_with_logging_component): Use
        SID_LOG_PERSISTENT_BUFFER.
        (log): Buffer output based on buffer_output. Use
        SID_LOG_TRANSIENT_MALLOC_BUFFER.
        * sidcpuutil.h (get_total_latency): New method of basic_cpu.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * sidattrutil.h (log): Don't use STDCTYPE for vsnprint or vasprintf.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        For Stan Cox  <scox@@redhat.com>
        * sidmiscutil.h (bijection::find): Add typename.
        * sidbusutil.h (ro_value_control_register): New ValueType typedef.
        (control_register_bus::word_write, control_register_bus::word_read):
        Add typename

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * sidattrutil.h (iostream): #include it.
        (log): Use std::cerr and std::endl.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * sidattrutil.h (fixed_attribute_map_with_logging_component):
        Initialize saved_messages and saved_levels.
        (~fixed_attribute_map_with_logging_component): Output saved messages.
        Delete buffer if necessary.
        (log): Save message for later if output pin not connected. Otherwise
        output saved messages before the new message. Use vsnprintf or
        vasprintf if possible.
        (check_level): New member of fixed_attribute_map_with_logging_component.
        (output_saved_messages): Ditto.
@
text
@d3 1
a3 1
// Copyright (C) 1999-2002 Red Hat.
d529 2
a530 1
      saved_messages.erase (saved_messages.end ());
@


1.6
log
@* gcc 3.2 compatibility fixes

[e.g. include/ChangeLog]
2002-11-22  Frank Ch. Eigler  <fche@@redhat.com>

	* sidattrutil.h: Give up on hash tables - too many incompatible
	libstdc++'s out there.
	* configure.in: Don't bother looking for hash stuff.
	* configure, sidconfutil.in: Regenerated.
	* sidmiscutil.h: Add some "typename" qualifiers.
	* sidcpuutil.h (cpu_trace_stream): Trade publicness for friendliness
	regarding cout_p.

[e.g., component/parport/ChangeLog]
2002-11-22  Frank Ch. Eigler  <fche@@redhat.com>

	* ps2.cxx (parport_inputpin): Fix formal arg list.

[e.g., component/interrupt/ChangeLog]
2002-11-22  Frank Ch. Eigler  <fche@@redhat.com>

	* components.cxx (compInterruptDelete): Avoid dynamic_cast on
	deleted pointer.
@
text
@d11 1
d14 1
d25 10
d36 2
d393 139
@


1.5
log
@2002-09-09  Ben Elliston  <bje@@redhat.com>

	* sidmiscutil.h (sid_file_search_path): More ISO C++ conformance.
@
text
@d3 1
a3 1
// Copyright (C) 1999-2001 Red Hat.
d43 1
a43 1
	forward_t::const_iterator it = this->forward.find(one);
d46 1
a46 1
	    backward_t::const_iterator ti = this->backward.find(it->second);
d59 1
a59 1
	backward_t::iterator ti = this->backward.find(two);
d62 1
a62 1
	    forward_t::const_iterator it = this->forward.find(ti->second);
@


1.4
log
@* build fix

2001-05-25  Will Cohen  <wcohen@@redhat.com>

	* sidmiscutil.h: Added #include <sys/cygwin.h> for cygwin builds.
@
text
@d334 2
a335 2
	  cerr << "sid_file_search_path: cygwin_conv_to_full_posix_path failed: " 
	       << std_error_string () << endl;
@


1.3
log
@* build fix

2001-04-14  Harri Porten  <porten@@kde.org>

	* sidmiscutil.h (sidutil): added std:: prefixes for C++ ISO compliance.
@
text
@d20 3
@


1.2
log
@* function improvement

[include/ChangeLog]
2001-03-26  Frank Ch. Eigler  <fche@@redhat.com>

        * sidmiscutil.h (sid_file_search_path): New function for returning
        a canonical file search path based on SID_LIBRARY_PATH and
        SID_EXEC_PREFIX.
        (find_sid_data_file): New function to use the above to locate sid
        data files.
        * configure.in (SID_EXEC_PREFIX): AC_DEFINE.
        * configure, sidconfutil.h: Regenerated.

[component/cfgroot/ChangeLog]
2001-03-26  Frank Ch. Eigler  <fche@@redhat.com>

        * compConfig.cxx (configure): Use find_sid_data_file to locate
        given sid config file.
        * Makefile.am (AM_CXXFLAGS): Remove.
        * Makefile.in: Regenerated.

[component/memory/ChangeLog]
2001-03-26  Frank Ch. Eigler  <fche@@redhat.com>

        * generic.cxx (image{load,store,mmap}_handler): Use find_sid_data_file
        to locate image-file.

[component/tcl/ChangeLog]
2001-03-26  Frank Ch. Eigler  <fche@@redhat.com>

        * compTcl.cxx (scan_files): Use sid_file_search_path to locate tcl
        component sources.
        * Makefile.am (AM_CXXFLAGS): Remove definition.
        * Makefile.in: Regenerated.
@
text
@d316 1
a316 1
    vector<string> search_directories;
d340 1
a340 1
    string pkglibdir1 = string(sep) + string("/share");
d343 1
a343 1
    string pkglibdir2 = string(sep) + string("/../share");
d358 1
a358 1
    path.push_back (string("")); // no prefix
d360 1
a360 1
      path.push_back (file_path[i] + string("/sid/"));
@


1.1
log
@* public snapshot of sid simulator
@
text
@d3 1
a3 1
// Copyright (C) 1999, 2000 Red Hat.
d13 1
d308 69
@

