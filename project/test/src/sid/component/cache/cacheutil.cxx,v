head	1.11;
access;
symbols
	sid-snapshot-20180601:1.11
	sid-snapshot-20180501:1.11
	sid-snapshot-20180401:1.11
	sid-snapshot-20180301:1.11
	sid-snapshot-20180201:1.11
	sid-snapshot-20180101:1.11
	sid-snapshot-20171201:1.11
	sid-snapshot-20171101:1.11
	sid-snapshot-20171001:1.11
	sid-snapshot-20170901:1.11
	sid-snapshot-20170801:1.11
	sid-snapshot-20170701:1.11
	sid-snapshot-20170601:1.11
	sid-snapshot-20170501:1.11
	sid-snapshot-20170401:1.11
	sid-snapshot-20170301:1.11
	sid-snapshot-20170201:1.11
	sid-snapshot-20170101:1.11
	sid-snapshot-20161201:1.11
	sid-snapshot-20161101:1.11
	sid-snapshot-20160901:1.11
	sid-snapshot-20160801:1.11
	sid-snapshot-20160701:1.11
	sid-snapshot-20160601:1.11
	sid-snapshot-20160501:1.11
	sid-snapshot-20160401:1.11
	sid-snapshot-20160301:1.11
	sid-snapshot-20160201:1.11
	sid-snapshot-20160101:1.11
	sid-snapshot-20151201:1.11
	sid-snapshot-20151101:1.11
	sid-snapshot-20151001:1.11
	sid-snapshot-20150901:1.11
	sid-snapshot-20150801:1.11
	sid-snapshot-20150701:1.11
	sid-snapshot-20150601:1.11
	sid-snapshot-20150501:1.11
	sid-snapshot-20150401:1.11
	sid-snapshot-20150301:1.11
	sid-snapshot-20150201:1.11
	sid-snapshot-20150101:1.11
	sid-snapshot-20141201:1.11
	sid-snapshot-20141101:1.11
	sid-snapshot-20141001:1.11
	sid-snapshot-20140901:1.11
	sid-snapshot-20140801:1.11
	sid-snapshot-20140701:1.11
	sid-snapshot-20140601:1.11
	sid-snapshot-20140501:1.11
	sid-snapshot-20140401:1.11
	sid-snapshot-20140301:1.11
	sid-snapshot-20140201:1.11
	sid-snapshot-20140101:1.11
	sid-snapshot-20131201:1.11
	sid-snapshot-20131101:1.11
	sid-snapshot-20131001:1.11
	sid-snapshot-20130901:1.11
	sid-snapshot-20130801:1.11
	sid-snapshot-20130701:1.11
	sid-snapshot-20130601:1.11
	sid-snapshot-20130501:1.11
	sid-snapshot-20130401:1.11
	sid-snapshot-20130301:1.11
	sid-snapshot-20130201:1.11
	sid-snapshot-20130101:1.11
	sid-snapshot-20121201:1.11
	sid-snapshot-20121101:1.11
	sid-snapshot-20121001:1.11
	sid-snapshot-20120901:1.11
	sid-snapshot-20120801:1.11
	sid-snapshot-20120701:1.11
	sid-snapshot-20120601:1.11
	sid-snapshot-20120501:1.11
	sid-snapshot-20120401:1.11
	sid-snapshot-20120301:1.11
	sid-snapshot-20120201:1.11
	sid-snapshot-20120101:1.11
	sid-snapshot-20111201:1.11
	sid-snapshot-20111101:1.11
	sid-snapshot-20111001:1.11
	sid-snapshot-20110901:1.11
	sid-snapshot-20110801:1.11
	sid-snapshot-20110701:1.11
	sid-snapshot-20110601:1.11
	sid-snapshot-20110501:1.11
	sid-snapshot-20110401:1.11
	sid-snapshot-20110301:1.11
	sid-snapshot-20110201:1.11
	sid-snapshot-20110101:1.11
	sid-snapshot-20101201:1.11
	sid-snapshot-20101101:1.11
	sid-snapshot-20101001:1.11
	sid-snapshot-20100901:1.11
	sid-snapshot-20100801:1.11
	sid-snapshot-20100701:1.11
	sid-snapshot-20100601:1.11
	sid-snapshot-20100501:1.11
	sid-snapshot-20100401:1.11
	sid-snapshot-20100301:1.11
	sid-snapshot-20100201:1.11
	sid-snapshot-20100101:1.11
	sid-snapshot-20091201:1.11
	sid-snapshot-20091101:1.11
	sid-snapshot-20091001:1.11
	sid-snapshot-20090901:1.11
	sid-snapshot-20090801:1.11
	sid-snapshot-20090701:1.11
	sid-snapshot-20090601:1.11
	sid-snapshot-20090501:1.11
	sid-snapshot-20090401:1.11
	sid-snapshot-20090301:1.11
	sid-snapshot-20090201:1.11
	sid-snapshot-20090101:1.11
	sid-snapshot-20081201:1.11
	sid-snapshot-20081101:1.11
	sid-snapshot-20081001:1.11
	sid-snapshot-20080901:1.11
	sid-snapshot-20080801:1.11
	sid-snapshot-20080701:1.11
	sid-snapshot-20080601:1.11
	sid-snapshot-20080501:1.11
	sid-snapshot-20080403:1.11
	sid-snapshot-20080401:1.11
	sid-snapshot-20080301:1.11
	sid-snapshot-20080201:1.11
	sid-snapshot-20080101:1.11
	sid-snapshot-20071201:1.11
	sid-snapshot-20071101:1.11
	sid-snapshot-20071001:1.11
	sid-20020905-branchpoint:1.7
	sid-20020905-branch:1.7.0.2
	cygnus_cvs_20020108_pre:1.6;
locks; strict;
comment	@// @;


1.11
date	2005.05.10.15.41.05;	author brolley;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.20.17.10.48;	author brolley;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.10.21.51.10;	author brolley;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.29.20.26.08;	author brolley;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.08.20.33.18;	author bje;	state Exp;
branches;
next	1.6;

1.6
date	2001.12.01.00.08.53;	author fche;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.22.19.48.44;	author fche;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.27.20.23.50;	author fche;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.26.21.11.48;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.03.06.02.42;	author mrg;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.15.04.19.50;	author bje;	state Exp;
branches;
next	;


desc
@@


1.11
log
@2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * hw-cache.xml: Input to flush-set, invalidate-set and
        * hw-cache.txt: Regenerated.
        flush-and-invalidate-set is now an address.
        * cacheutil.h (addr_to_tag): New method of cache.
        * cacheutil.cxx (addr_to_tag): New method of cache.
        * cache.cxx (cache_component::flush_set): Input argument is now an address.
        (cache_component::flush_and_invalidate_set): Likewise.
        (blocking_cache_component::flush_set): Likewise.
        (blocking_cache_component::flush_and_invalidate_set): Likewise.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * cache.cxx (cache_component): Initialize data_width. Add "data-width"
        attribute.
        (read_line): Access the data 4 or 8 bytes at a time, depending on
        data_width.
        (write_line): Ditto.
        (read_downstream, write_downstream): New methods of cache_component.
        * cache.h (read_downstream, write_downstream): New methods of
        cache_component.
        (data_width): New member of cache_component.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * cache.cxx (cache_component): Add "operation-status" pin.
        (cache_component::flush_all_lines): Accumulate latency and call
        report_status.
        (cache_component::flush_line): Ditto.
        (cache_component::flush_set): Ditto.
        (cache_component::flush_and_invalidate_set): Ditto.
        (cache_component::invalidate_all_lines): Call report_status.
        (cache_component::invalidate_line): Ditto.
        (cache_component::flush_and_invalidate_line): Ditto.
        (cache_component::invalidate_set): Ditto.
        (cache_component::prefetch_line): Ditto.
        (cache_component::lock_line): Ditto.
        (cache_component::unlock_line): Ditto.
        (blocking_cache_component::flush_all_lines): Call report_status if
        child is blocked.
        (blocking_cache_component::flush_line): Ditto.
        (blocking_cache_component::flush_set): Ditto.
        (blocking_cache_component::flush_and_invalidate_set): Ditto.
        (blocking_cache_component::flush_and_invalidate_line): Ditto.
        (blocking_cache_component::prefetch_line): Ditto.
        * cache.h (report_status): New method of cache_component.
        (operation_status_pin): New output pin.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * cache.h (flush_all_lines, flush_line, flush_set)
        (flush_and_invalidate_set, flush_and_invalidate_line)
        (prefetch_line): Now virtual. Also, new methods of
        blocking_cache_component.
        (setup_flush_all_transaction, setup_flush_line_transaction)
        (setup_flush_set_transaction)
        (setup_flush_and_invalidate_set_transaction)
        (setup_flush_and_invalidate_line_transaction)
        (perform_flush_all_transaction, perform_flush_line_transaction)
        (perform_flush_set_transaction)
        (perform_flush_and_invalidate_set_transaction)
        (perform_flush_and_invalidate_line_transaction): New methods of
        blocking_cache_component.
        * cache.cxx (blocking_cache_component::write): Remove log message. Don't
        need return code from continue_child_thread_and_wait.
        blocking_cache_component::read): Ditto.
        (flush_all_lines, flush_line, flush_set)
        (flush_and_invalidate_set, flush_and_invalidate_line)
        (prefetch_line): New methods of blocking_cache_component.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * cache.cxx (cache_component): Initialize total_latency_p. Add
        "total-latency?" attribute.
        (read_line): Return the total latency of all accesses if total_latency_p
        is set.
        (write_line): Ditto.
        (handle_bus_error): Copy the status, s, to transaction_status.
        (blocking_cache_component::read): Always return transaction_status.
        (blocking_cache_component::write): Ditto.
        * cache.h (total_latency_p): New member of cache_component.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * cache.h (cache_component::lock_downstream): New virtual method.
        (cache_component::unlock_downstream): New virutal method.
        (blocking_cache_component::lock_downstream): New virtual override.
        (blocking_cache_component::unlock_downstream): New virtual override.
        * cache.cxx (read_line): Return the maximum latency from the reads
        performed if refill latency is not requested. Call lock_downstream
        before the first read. Call unlock_downstream before the final read.
        (write_line): Ditto.
        (blocking_cache_component): Add downstream-lock pin.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * cache.cxx (blocking_cache_child_thread_root): Don't call
        child->child_wait_for_resume.
        (handle_bus_error): Ditto.
        (DEFN_METHOD): SID_SIG_CHILD_BLOCKED is now ctl_child_blocked.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * Makefile.am (AM_XXXFLAGS): Set it to $(TOP_CXXFLAGS).
        (AM_MAKEFLAGS): Pass along TOP_CXXFLAGS.
        * Makefile.in: Regenerated.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * mep-cache.cxx (mep_cache): Inherit from blocking_cache_component.
        * mep-cache.h (mep_cache): Inherit from blocking_cache_component.
        * cache.h (sidblockingutil.h): #include it.
        (namespace sid): Add "using" clause. Remove sid:: qualifier from
        declarations.
        (cache_component): Inhereit virtually from
        fixed_attribute_map_component and fixed_pin_map_component.
        (cache_component::write): Variants now virtual.
        (cache_component::read): Ditto.
        (cache_component::handle_read_error): New virtual method.
        (cache_component::handle_write_error): New virtual method.
        (cache_bus::write_any): Call cache.write.
        (cache_bus::read_any): Call cache.read.
        (blocking_cache_component): New class.
        * cache.cxx (cache_component::write_any): Call handle_write_error to
        handle bus errors.
        (cache_component::write_line): Ditto.
        (cache_component::read_any): Call handle_read_error as above.
        (cache_component::read_line): Ditto.
        (blocking_cache_child_thread_root): New function.
        (blocking_cache_component): New constructor.
        (handle_bus_error): New method.
        (blocking_cache_component:write): New methods.
        (blocking_cache_component::read): New methods.
        (CacheListTypes): Add hw-blocking-cache-basic and
        hw-blocking-cache-buffer-8, hw-blocking-cache-direct* and
        hw-blocking-cache/*kb*.
        (CacheCreate): Parse and construct the above.
@
text
@// cacheutil.cxx -- Helper classes for a generic memory cache. -*- C++ -*-

// Copyright (C) 2001, 2002, 2004, 2005 Red Hat.
// This file is part of SID and is licensed under the GPL.
// See the file COPYING.SID for conditions for redistribution.

#include "cacheutil.h"

bool
operator== (const cache_tag& tag, const cache_line& line)
{
  return (line.valid_p () && tag == line.tag ());
}

bool
operator== (const cache_line& line, const cache_tag& tag)
{
  return (line.valid_p () && tag == line.tag ());
}

using std::cerr;
using std::hex;
using std::setw;
using std::setfill;
using std::endl;
using std::dec;

void
cache_line::dump () const
{
  cerr << "  ";

  if (dirty_p ())  cerr << 'M'; else cerr << '-';
  if (valid_p ())  cerr << 'V'; else cerr << '-';
  if (locked_p ()) cerr << 'L'; else cerr << '-';

  cerr << "  " << hex << setw (4) << setfill ('0') << tag () << "\t";
  dump_data ();
  cerr << dec << endl;
}

void
internal_cache_line::dump_data () const
{
  for (unsigned i = 0; i < size; i++)
    cerr << setw (2) << setfill ('0') << static_cast<unsigned> (data[i]);
}

internal_cache_line::internal_cache_line (unsigned line_size)
  :size (line_size), valid_bit (false), dirty_bit (false), lock_bit (false), atag (0)
{
  data = new byte [line_size];
  memset (data, 0, line_size);
}

internal_cache_line::~internal_cache_line ()
{
  delete [] data;
}

void
internal_cache_line::dirty ()
{
  dirty_bit = true;
}

void
internal_cache_line::clean ()
{
  dirty_bit = false;
}

void
internal_cache_line::validate ()
{
  valid_bit = true;
}

void
internal_cache_line::invalidate ()
{
  valid_bit = false;
}

void
internal_cache_line::lock ()
{
  lock_bit = true;
}

void
internal_cache_line::unlock ()
{
  lock_bit = false;
}

void
internal_cache_line::set_tag (cache_tag tag)
{
  atag = tag;
}

cache_tag
internal_cache_line::tag () const
{
  return atag;
}

bool
internal_cache_line::dirty_p () const
{
  return dirty_bit;
}

bool
internal_cache_line::valid_p () const
{
  return valid_bit;
}

bool
internal_cache_line::locked_p () const
{
  return lock_bit;
}

cache_set::cache_set (unsigned line_sz, unsigned nlines, cache_replacement_algorithm& alg, cache_line_factory &f)
  :replacer (alg),
   line_factory (f),
   line_size (line_sz)
{
  lines.resize (nlines);
  for (iterator_t it = lines.begin(); it != lines.end (); it++)
    *it = NULL;
}

cache_set::~cache_set ()
{
  for (iterator_t it = lines.begin (); it != lines.end (); it++)
    line_factory.destroy_line (*it);
}

void
cache_set::allocate_lines (unsigned index)
{
  unsigned way = 0;
  for (iterator_t it = lines.begin(); it != lines.end (); way++, it++)
    *it = line_factory.make_line (line_size, index, way);
}

unsigned
cache_set::num_lines () const
{
  return lines.size ();
}

cache_line&
cache_set::get_line (unsigned i) const
{
  return *lines[i];
}

void
cache_set::set_line (unsigned i, cache_line &line)
{
  lines[i] = &line;
}

cache_line*
cache_set::find (const cache_tag& tag)
{
  // Scan the lines in this set for tag. Might as well be linear; the
  // order of associativity will be small.

  for (const_iterator_t it = lines.begin (); it != lines.end (); it++)
    if (tag == *(*it) && (*it)->valid_p ())
      {
	replacer.update (*this, *(*it));
	return *it;
      }

  return NULL;
}


cache_line*
cache_set::find_any_dirty ()
{
  for (iterator_t it = lines.begin (); it != lines.end (); it++)
    {
      cache_line* i = * it;
      if (i->valid_p () && i->dirty_p ()) return i;
    }

  return 0;
}

void
cache_set::invalidate ()
{
  for (iterator_t it = lines.begin (); it != lines.end (); it++)
    (*it)->invalidate ();
}

bool
cache_set::vacancy_p () const
{
  for (const_iterator_t it = lines.begin (); it != lines.end (); it++)
    if (!(*it)->valid_p () || !(*it)->locked_p ())
      return true;

  return false;
}
    
void
cache_set::expunge_line (cache_line& line)
{
  line.unlock ();
  line.clean ();
  line.invalidate ();
}

cache_line *
cache_set::expell_line ()
{
  cache_line *line = replacer.expell (*this);
  return line;
}

void
cache_set::dump () const
{
  for (const_iterator_t it = lines.begin (); it != lines.end (); it++)
    (*it)->dump ();
}

cache::cache (unsigned cache_size, unsigned line_size, unsigned assoc,
	      cache_replacement_algorithm& replacer,
	      cache_line_factory& line_factory)
{
  assert (power_of_two_p (line_size));
  assert (cache_size >= line_size);

  // The cache size must be an even multiple of the line size.
  assert ((cache_size % line_size) == 0);

  int num_lines = cache_size / line_size;
  if (assoc > 0)
    assert (num_lines % assoc == 0 && assoc < num_lines);
  
  // The number of sets.  
  // If the cache is fully associative, there is only one set.
  int num_sets = (assoc == 0) ? 1 : (num_lines / assoc);
  sets.resize (num_sets);

  // The number of lines per set.
  // If the cache is fully associative, there is one set with as many
  // lines as there are in the cache.
  int lines_per_set = (assoc == 0) ? num_lines : assoc;
 
  for (iterator_t it = sets.begin (); it != sets.end (); it++)
    *it = new cache_set (line_size, lines_per_set, replacer, line_factory);
  
  num_non_tag_bits = log2 (line_size);

  // Pick a default hash function: the next few bits above the intra-line address bits
  unsigned cache_set_bits = log2 (sets.size());
  hash_params.mask = ((1U << cache_set_bits) - 1) << num_non_tag_bits;
  hash_params.shift = num_non_tag_bits;
}

cache::~cache ()
{
  for (unsigned i = 0; i < sets.size (); i++)
    delete sets[i];
}

void
cache::init ()
{
  unsigned index = 0;
  for (iterator_t it = sets.begin (); it != sets.end (); it++, index++)
    (*it)->allocate_lines (index);
}
  
cache_tag
cache::addr_to_tag (const sid::host_int_4& addr) const
{
  return addr >> num_non_tag_bits;
}

unsigned
cache::addr_to_index (const sid::host_int_4& addr) const
{
  return hash_fn (addr_to_tag (addr));
}

sid::host_int_4
cache::tag_to_addr (const cache_tag& tag) const
{
  return tag << num_non_tag_bits;
}

cache_line*
cache::find (cache_tag tag)
{
  unsigned index = hash_fn (tag);
  return sets[index]->find (tag);
}

cache_line*
cache::find_any_dirty ()
{
  for (unsigned i = 0; i < this->num_sets(); i++)
    {
      cache_line* foo = sets[i]->find_any_dirty ();
      if (foo) return foo;
    }
  return 0;
}


unsigned
cache::num_sets ()
{
  return sets.size ();
}

bool
cache::vacancy_p (const sid::host_int_4& addr) const
{
  unsigned index = hash_fn (addr_to_tag (addr));
  return sets[index]->vacancy_p ();
}

void
cache::invalidate ()
{
  for (iterator_t it = sets.begin (); it != sets.end(); it++)
    (*it)->invalidate ();
}

void
cache::invalidate (unsigned index)
{
  if (index >= sets.size ())
    return;
  sets[index]->invalidate ();
}

// Remove a line from the cache.
void
cache::expunge (cache_line& line)
{
  unsigned index = hash_fn (line.tag ());
  sets[index]->expunge_line (line);
}

// Replace a line in the cache with 'new_line'.  If the expelled
// line is dirty, set 'old_line' to it and return true, otherwise
// false.
cache_line *
cache::expell_line (cache_tag tag)
{
  unsigned index = hash_fn (tag);
  return sets[index]->expell_line ();
}

unsigned
cache::hash_fn (const cache_tag& tag) const
{
  sid::host_int_4 addr = tag_to_addr (tag);
  unsigned index = (addr & hash_params.mask) >> hash_params.shift;
  if (UNLIKELY(index >= this->sets.size()))
    {
      cerr << "cache: bad hash parameters (mask=" 
	   << sidutil::make_numeric_attribute (this->hash_params.mask, std::ios::hex|std::ios::showbase)
	   << " shift="
	   << sidutil::make_numeric_attribute (this->hash_params.shift)
	   << ") for address="
	   << sidutil::make_numeric_attribute (addr, std::ios::hex|std::ios::showbase)
	   << " #sets="
	   << sidutil::make_numeric_attribute (this->sets.size())
	   << endl;
      index = index % this->sets.size();
    }
  return index;
}

void
cache::dump () const
{
  unsigned i = 0;
  for (const_iterator_t it = sets.begin (); it != sets.end (); it++, i++)
    {
      cerr << "set " << i << endl;
      (*it)->dump ();
    }
}
@


1.10
log
@2004-07-20  Dave Brolley  <brolley@@redhat.com>

        * cacheutil.cxx (find): Make sure cache line is valid before returning
        it.
        * cache.cxx (write_any): Move call to addr_to_tag to a later point when
        the result is actually needed. Make sure cache line is valid before
        flushing it.
        (read_any): Make sure cache line is valid before flushing it.
@
text
@d3 1
a3 1
// Copyright (C) 2001, 2002, 2004 Red Hat.
d292 6
@


1.9
log
@2004-05-10  Dave Brolley  <brolley@@redhat.com>

        * cacheutil.cxx (find_any_dirty): Make sure the line is valid before
        checking the dirty bit.
        (vacancy_p): Line is also vacant if it is not valid.
@
text
@d176 1
a176 1
    if (tag == *(*it))
@


1.8
log
@2004-04-29  Dave Brolley  <brolley@@redhat.com>

        * cacheutil.cxx (cache_set::expell_line): Don't update the set here.

2004-04-29  Dave Brolley  <brolley@@redhat.com>

        * cache.cxx: Update calls to cache::find.
        * cacheutil.cxx (cache_set::allocate_lines): Now takes cache index as
        an argument. Update all callers.
        (cache_set::find): Now returns a pointer to the line, if found. Update
        all callers.
        (cache::find): Ditto.
        (cache_set::expell_line): Update the status of the expelled line.
        * cacheutil.h (cache_line_factory::make_line): Now takes cache index as
        an argument. Update all callers.
        (cache_set::allocate_lines): Now takes cache index as
        an argument. Update all callers.
        (cache_set::find): Now returns a pointer to the line, if found. Update
        all callers.
        (cache::find): Ditto.

2004-04-29  Dave Brolley  <brolley@@redhat.com>

        * cacheutil.h (cache_line): Removed copy constructor. Now virtual base
        class.
        (cache_line::operator=): Removed.
        (internal_cache_line): New class implements former cache_line class.
        (cache_set): Now takes cache_line_factory.
        (allocate_lines): New method moves line allocation from the constructor.
        (cache_set::set_line): Now takes reference to cache_line.
        (cache_set::replace_line): Renamed to expell_line. Now returns a pointer
        to the expelled line.
        (cache): Now takes cache_line_factory argument.
        (cache::init): New method moves set allocation from the constructor.
        (cache_set::expell_line): Renamed to expell_line. Now returns a pointer
        to the expelled line.
        (cache_line_factory): New class.
        * cacheutil.cxx (cache_line): Removed copy constructor. Now virtual base
        class.
        (cache_line::operator=): Removed.
        (internal_cache_line): New class implements former cache_line class.
        (cache_set): Now takes cache_line_factory.
        (allocate_lines): New method moves line allocation from the constructor.
        (cache_set::set_line): Now takes reference to cache_line.
        (dummy): Now internal to cache_set::find.
        (cache_set::replace_line): Renamed to expell_line. Now returns a pointer
        to the expelled line.
        (cache): Now takes cache_line_factory argument.
        (cache::init): New method moves set allocation from the constructor.
        (cache_set::expell_line): Renamed to expell_line. Now returns a pointer
        to the expelled line.
        * cache.h (cache_replacement_algorithm::expell): Renamed from 'replace'.
        Returns a pointer to the expelled line. Update specializations.
        (cache_component): Now takes a cache_line_factory as an argument.
        Private data now protected.
        (line_factory): New member of cache_component.
        (~cache_component): Now virtual.
        (CacheCreate): Pass internal_line_factory to cache_component.
        * cache.cxx (line_sizes): Make it static.
        (line_sizes): Ditto.
        (replacement_algorithms): Ditto.
        (internal_line_factory): New static cache_line_factory.
        (cache_component): Now takes a cache_line_factory as an argument. Pass
        the cache line factory to the constructor for acache. Save a reference
        to the line factory. Call acache.init
        (write_any): Rewrite to use cache::expell_line instead of the former
        cache::replace.
        (read_any): Ditto.
        (cache_replacement_algorithm::expell): Renamed from 'replace'. Returns
        a pointer to the expelled line. Update all callers and specializations.
        (CacheCreate): Pass internal_line_factory to cache_component.
@
text
@d192 1
a192 1
      if (i->dirty_p ()) return i;
d209 1
a209 1
    if (!(*it)->locked_p ())
@


1.7
log
@2002-06-08  Ben Elliston  <bje@@redhat.com>

	* cacheutil.h (cache_set::expunge): New method.
	(cache_set::operator[]): Likewise.
	(cache::invalidate): Likewise.
	(cache::operator[]): Likewise.
	* cacheutil.cxx (cache::invalidate): Implement.
	* cache.h (cache_component::flush_set_pin): New pin.
	(cache_component::flush_set): New callback method.
	(cache_component::invalidate_set_pin): New pin.
	(cache_component::invalidate_set): New method.
	* cache.cxx (cache_component constructor): Initialise and add
	"flush-set" and "invalidate-set" pins.
	(cache_component::flush_set): Implement.
	(cache_component::invalidate_set): Likewise.
	* hw-cache.xml: Update documentation.
@
text
@d3 1
a3 1
// Copyright (C) 2001, 2002 Red Hat.
a20 29
cache_line::cache_line (const cache_line& other)
{
  size = other.size;
  valid_bit = other.valid_bit;
  dirty_bit = other.dirty_bit;
  lock_bit = other.lock_bit;
  atag = other.atag;
  data = new byte [size];
  memcpy (data, other.data, size);
}

cache_line&
cache_line::operator= (const cache_line& other)
{
  if (this != &other)
    {
      // Beware of self-assignment.
      size = other.size;
      valid_bit = other.valid_bit;
      dirty_bit = other.dirty_bit;
      lock_bit = other.lock_bit;
      atag = other.atag;
      delete [] data;
      data = new byte [size];
      memcpy (data, other.data, size);
    }
  return *this;
}

d37 2
a38 4
  cerr << "  " << hex << setw (4) << setfill ('0') << atag << "\t";
  for (unsigned i = 0; i < size; i++)
    cerr << setw (2) << setfill ('0') << static_cast<unsigned> (data[i]);

d42 2
a43 2
cache_line::cache_line (unsigned line_size)
  :size (line_size), valid_bit (false), dirty_bit (false), lock_bit (false), atag (0)
d45 2
a46 2
  data = new byte [line_size];
  memset (data, 0, line_size);
d49 2
a50 2
cache_line::cache_line (unsigned line_size, cache_tag t)
  :size (line_size), valid_bit (false), dirty_bit (false), lock_bit (false), atag (t)
d56 1
a56 10
cache_line::cache_line (unsigned line_size, cache_tag t, std::vector <byte> initial_data)
  :size (line_size), valid_bit (false), dirty_bit (false), lock_bit (false), atag (t)
{
  assert (initial_data.size () == line_size);
  data = new byte [line_size];
  for (unsigned i = 0; i < line_size; i++)
    data[i] = initial_data[i];
}

cache_line::~cache_line ()
d62 1
a62 1
cache_line::dirty ()
d68 1
a68 1
cache_line::clean ()
d74 1
a74 1
cache_line::validate ()
d80 1
a80 1
cache_line::invalidate ()
d86 1
a86 1
cache_line::lock ()
d92 1
a92 1
cache_line::unlock ()
d97 6
d104 1
a104 1
cache_line::tag () const
d110 1
a110 1
cache_line::dirty_p () const
d116 1
a116 1
cache_line::valid_p () const
d122 1
a122 1
cache_line::locked_p () const
d127 4
a130 2
cache_set::cache_set (unsigned line_size, unsigned nlines, cache_replacement_algorithm& alg)
  :replacer (alg)
d134 1
a134 1
    *it = new cache_line (line_size);
d140 9
a148 1
    delete *it;
d164 1
a164 1
cache_set::set_line (unsigned i, const cache_line line)
d166 1
a166 1
  *lines[i] = line;
d169 2
a170 2
cache_line&
cache_set::find (const cache_tag& tag, bool& hit)
a171 2
  static cache_line dummy(0);

a177 1
	hit = true;
d179 1
a179 1
	return *(*it);
d181 2
a182 2
  hit = false;
  return dummy;
d223 2
a224 2
void
cache_set::replace_line (cache_line& old_line, cache_line new_line)
d226 2
a227 1
  return replacer.replace (*this, old_line, new_line);
d238 2
a239 1
	      cache_replacement_algorithm& replacer)
d262 1
a262 1
    *it = new cache_set (line_size, lines_per_set, replacer);
d278 8
d298 2
a299 2
cache_line&
cache::find (cache_tag tag, bool& hit)
d302 1
a302 1
  return sets[index]->find (tag, hit);
d356 2
a357 2
void
cache::replace (cache_line& old_line, cache_line new_line)
d359 2
a360 2
  unsigned index = hash_fn (new_line.tag ());
  return sets[index]->replace_line (old_line, new_line);
@


1.6
log
@2001-11-30  Frank Ch. Eigler  <fche@@redhat.com>

	* cacheutil.cxx (hash_fn): Fix std:: namespace reference.
@
text
@d3 1
a3 1
// Copyright (C) 2001 Red Hat.
d352 8
@


1.5
log
@* function ++, cleanup

2001-10-22  Frank Ch. Eigler  <fche@@redhat.com>

	* cache.cxx (flush_all): New function.  Associate with "flush-all" pin.
	* cacheutil.cxx (find_any_dirty): New functions.
	* cache.h, cacheutil.h: Relevant changes.
	Warning cleanups throughout.
	* hw-cache.xml (flush-all): Document new pin.
	* hw-cache-txt: Regenerated.
@
text
@d380 1
a380 1
	   << sidutil::make_numeric_attribute (this->hash_params.mask, ios::hex|ios::showbase)
d384 1
a384 1
	   << sidutil::make_numeric_attribute (addr, ios::hex|ios::showbase)
@


1.4
log
@* bug fix

2001-09-27  Frank Ch. Eigler  <fche@@redhat.com>

	* cache.cxx (emit_report): Remove extra blank line.
	(set_hash_mask, set_hash_shift): Exchange names to match functionality.
	* cacheutil.cxx (cache ctor): Compute good default hash_params.
@
text
@d212 13
d322 13
a334 1
int
@


1.3
log
@2001-09-26  Frank Ch. Eigler  <fche@@redhat.com>

	* cacheutil.cxx (hash_fn): Detect index overflow.  Complain loudly.
	* cacheutil.h: Include some more headers.
@
text
@d278 4
a281 3
  // suitable defaults
  hash_params.mask = 0x3fe0;
  hash_params.shift = 5;
@


1.2
log
@* make it compile with GCC 3.0:
        - missing throw() specifiers in bus & component dtors
	- `std::' vs `::' namespace issues
@
text
@d350 15
a364 1
  return (addr & hash_params.mask) >> hash_params.shift;
@


1.1
log
@Index: component/ChangeLog
2001-06-12  Ben Elliston  <bje@@redhat.com>

	* CATALOG: Add hw-cache-basic and friends.
	* configure.in (make_subdirs): Add cache.
	* configure: Regenerate.
	* Makefile.in: Ditto.

Index: component/cache/ChangeLog
2001-06-15  Ben Elliston  <bje@@redhat.com>

	* cache.cxx: New file.
	* cache.h: Likewise.
	* cacheutil.cxx: Likewise.
	* cacheutil.h: Likewise.
	* log2.h: Likewise.
	* hw-cache.txt: Likewise.

Index: component/testsuite/ChangeLog
2001-06-05  Ben Elliston  <bje@@redhat.com>

	* Makefile.am: New file.
	* Makefile.in: Generate.

2001-06-15  Ben Elliston  <bje@@redhat.com>

	* sidcomp.cache/cache.exp: New test case.
	* sidcomp.cache/cachedocs.exp: Ditto.
	* sidcomp.cache/cachemonkey.exp: Ditto.
	* sidcomp.cache/coherency.exp: Ditto.
	* sidcomp.cache/fifo.exp: Ditto.
	* sidcomp.cache/flush.exp: Ditto.
	* sidcomp.cache/lock.exp: Ditto.
	* sidcomp.cache/lru.exp: Ditto.
	* sidcomp.cache/misaligned.exp: Ditto.
	* sidcomp.cache/prefetch.exp: Ditto.
	* sidcomp.cache/random.exp: Ditto.
	* sidcomp.cache/types.exp: Ditto.
	* sidcomp.cache/utils.exp: Ditto.
	* sidcomp.cache/writealloc.exp: Ditto.
	* sidcomp.cache/writethru.exp: Ditto.
@
text
@d10 1
a10 1
std::operator== (const cache_tag& tag, const cache_line& line)
d16 1
a16 1
std::operator== (const cache_line& line, const cache_tag& tag)
d50 7
d76 1
a76 1
  data = new byte[line_size];
d83 1
a83 1
  data = new byte[line_size];
d87 1
a87 1
cache_line::cache_line (unsigned line_size, cache_tag t, vector<byte> initial_data)
d91 1
a91 1
  data = new byte[line_size];
@

