head	1.24;
access;
symbols
	sid-snapshot-20180601:1.24
	sid-snapshot-20180501:1.24
	sid-snapshot-20180401:1.24
	sid-snapshot-20180301:1.24
	sid-snapshot-20180201:1.24
	sid-snapshot-20180101:1.24
	sid-snapshot-20171201:1.24
	sid-snapshot-20171101:1.24
	sid-snapshot-20171001:1.24
	sid-snapshot-20170901:1.24
	sid-snapshot-20170801:1.24
	sid-snapshot-20170701:1.24
	sid-snapshot-20170601:1.24
	sid-snapshot-20170501:1.24
	sid-snapshot-20170401:1.24
	sid-snapshot-20170301:1.24
	sid-snapshot-20170201:1.24
	sid-snapshot-20170101:1.24
	sid-snapshot-20161201:1.24
	sid-snapshot-20161101:1.24
	sid-snapshot-20160901:1.24
	sid-snapshot-20160801:1.24
	sid-snapshot-20160701:1.24
	sid-snapshot-20160601:1.24
	sid-snapshot-20160501:1.24
	sid-snapshot-20160401:1.24
	sid-snapshot-20160301:1.24
	sid-snapshot-20160201:1.24
	sid-snapshot-20160101:1.24
	sid-snapshot-20151201:1.24
	sid-snapshot-20151101:1.24
	sid-snapshot-20151001:1.24
	sid-snapshot-20150901:1.24
	sid-snapshot-20150801:1.24
	sid-snapshot-20150701:1.24
	sid-snapshot-20150601:1.24
	sid-snapshot-20150501:1.24
	sid-snapshot-20150401:1.24
	sid-snapshot-20150301:1.24
	sid-snapshot-20150201:1.24
	sid-snapshot-20150101:1.24
	sid-snapshot-20141201:1.24
	sid-snapshot-20141101:1.24
	sid-snapshot-20141001:1.24
	sid-snapshot-20140901:1.24
	sid-snapshot-20140801:1.24
	sid-snapshot-20140701:1.24
	sid-snapshot-20140601:1.24
	sid-snapshot-20140501:1.24
	sid-snapshot-20140401:1.24
	sid-snapshot-20140301:1.24
	sid-snapshot-20140201:1.24
	sid-snapshot-20140101:1.24
	sid-snapshot-20131201:1.24
	sid-snapshot-20131101:1.24
	sid-snapshot-20131001:1.24
	sid-snapshot-20130901:1.24
	sid-snapshot-20130801:1.24
	sid-snapshot-20130701:1.24
	sid-snapshot-20130601:1.24
	sid-snapshot-20130501:1.24
	sid-snapshot-20130401:1.24
	sid-snapshot-20130301:1.24
	sid-snapshot-20130201:1.24
	sid-snapshot-20130101:1.24
	sid-snapshot-20121201:1.24
	sid-snapshot-20121101:1.24
	sid-snapshot-20121001:1.24
	sid-snapshot-20120901:1.24
	sid-snapshot-20120801:1.24
	sid-snapshot-20120701:1.24
	sid-snapshot-20120601:1.24
	sid-snapshot-20120501:1.24
	sid-snapshot-20120401:1.24
	sid-snapshot-20120301:1.24
	sid-snapshot-20120201:1.24
	sid-snapshot-20120101:1.24
	sid-snapshot-20111201:1.24
	sid-snapshot-20111101:1.24
	sid-snapshot-20111001:1.24
	sid-snapshot-20110901:1.24
	sid-snapshot-20110801:1.24
	sid-snapshot-20110701:1.24
	sid-snapshot-20110601:1.24
	sid-snapshot-20110501:1.24
	sid-snapshot-20110401:1.24
	sid-snapshot-20110301:1.24
	sid-snapshot-20110201:1.24
	sid-snapshot-20110101:1.24
	sid-snapshot-20101201:1.24
	sid-snapshot-20101101:1.24
	sid-snapshot-20101001:1.24
	sid-snapshot-20100901:1.24
	sid-snapshot-20100801:1.24
	sid-snapshot-20100701:1.24
	sid-snapshot-20100601:1.24
	sid-snapshot-20100501:1.24
	sid-snapshot-20100401:1.24
	sid-snapshot-20100301:1.24
	sid-snapshot-20100201:1.24
	sid-snapshot-20100101:1.24
	sid-snapshot-20091201:1.24
	sid-snapshot-20091101:1.24
	sid-snapshot-20091001:1.24
	sid-snapshot-20090901:1.24
	sid-snapshot-20090801:1.24
	sid-snapshot-20090701:1.24
	sid-snapshot-20090601:1.24
	sid-snapshot-20090501:1.24
	sid-snapshot-20090401:1.23
	sid-snapshot-20090301:1.23
	sid-snapshot-20090201:1.23
	sid-snapshot-20090101:1.23
	sid-snapshot-20081201:1.23
	sid-snapshot-20081101:1.23
	sid-snapshot-20081001:1.23
	sid-snapshot-20080901:1.23
	sid-snapshot-20080801:1.23
	sid-snapshot-20080701:1.23
	sid-snapshot-20080601:1.23
	sid-snapshot-20080501:1.23
	sid-snapshot-20080403:1.23
	sid-snapshot-20080401:1.23
	sid-snapshot-20080301:1.23
	sid-snapshot-20080201:1.23
	sid-snapshot-20080101:1.23
	sid-snapshot-20071201:1.23
	sid-snapshot-20071101:1.23
	sid-snapshot-20071001:1.23
	sid-20020905-branchpoint:1.15
	sid-20020905-branch:1.15.0.2
	cygnus_cvs_20020108_pre:1.11;
locks; strict;
comment	@// @;


1.24
date	2009.04.08.20.39.34;	author dj;	state Exp;
branches;
next	1.23;

1.23
date	2007.02.05.20.28.39;	author brolley;	state Exp;
branches;
next	1.22;

1.22
date	2006.05.10.20.24.48;	author brolley;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.01.21.07.00;	author fche;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.10.15.41.05;	author brolley;	state Exp;
branches;
next	1.19;

1.19
date	2004.07.20.17.10.48;	author brolley;	state Exp;
branches;
next	1.18;

1.18
date	2004.07.01.16.55.09;	author brolley;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.29.20.26.08;	author brolley;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.08.02.51.57;	author bje;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.16.19.14.46;	author brolley;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.08.20.33.18;	author bje;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.17.21.28.14;	author bje;	state Exp;
branches;
next	1.12;

1.12
date	2002.04.09.15.03.06;	author bje;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.28.20.58.39;	author fche;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.27.16.16.39;	author fche;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.04.20.16.08;	author fche;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.22.19.48.44;	author fche;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.27.20.23.50;	author fche;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.04.12.28.01;	author fche;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.09.08.13.08;	author bje;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.24.23.24.11;	author bje;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.21.13.37.08;	author bje;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.19.03.51.35;	author bje;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.15.04.19.50;	author bje;	state Exp;
branches;
next	;


desc
@@


1.24
log
@[cgen]
	* cpu/mep-c5.cpu: New.
	* cpu/mep-core.cpu: Add C5 support.
	* cpu/mep.opc: Likewise.
[opcodes]
	* mep-asm.c: Regenerate.
	* mep-desc.c: Regenerate.
	* mep-desc.h: Regenerate.
	* mep-dis.c: Regenerate.
	* mep-ibld.c: Regenerate.
	* mep-opc.c: Regenerate.
	* mep-opc.h: Regenerate.
[sid]
	* component/cache/cache.cxx (cache_component::cache_component):
	Add write_hint_pin().  Attach it to write-hint.
	(cache_component::write_hint): New.
	* component/cache/cache.h (write_hint_pin): New.
	(write_hint): New.

	* component/cgen-cpu/mep/Makefile.am: Regenerate.
	* component/cgen-cpu/mep/Makefile.in: Regenerate.
	* component/cgen-cpu/mep/mep-core1-decode.cxx: Regenerate.
	* component/cgen-cpu/mep/mep-core1-decode.h: Regenerate.
	* component/cgen-cpu/mep/mep-core1-defs.h: Regenerate.
	* component/cgen-cpu/mep/mep-core1-model.cxx: Regenerate.
	* component/cgen-cpu/mep/mep-core1-model.h: Regenerate.
	* component/cgen-cpu/mep/mep-core1-sem.cxx: Regenerate.
	* component/cgen-cpu/mep/mep-decode.cxx: Regenerate.
	* component/cgen-cpu/mep/mep-decode.h: Regenerate.
	* component/cgen-cpu/mep/mep-defs.h: Regenerate.
	* component/cgen-cpu/mep/mep-desc.h: Regenerate.
	* component/cgen-cpu/mep/mep-model.cxx: Regenerate.
	* component/cgen-cpu/mep/mep-model.h: Regenerate.
	* component/cgen-cpu/mep/mep-sem.cxx: Regenerate.
	* component/cgen-cpu/mep/mep.cxx (mep_cpu): Connect
	write-hint pin.
	(do_cache): Add C5 support.
	(do_cache_prefetch): Likewise.
	(do_casb3, do_cash3, do_casw3): New.
	* component/cgen-cpu/mep/mep.h: Add C5 support and write-hint pin.
	(do_casb3, do_cash3, do_casw3): New.

	* component/families/mep/Makefile.in: Regenerate.
	* component/families/mep/dsu.in: Add C5 support.
	* main/dynamic/mainDynamic.cxx: Add C5 support.
	* main/dynamic/mepCfg.cxx: Connect write-hint pin.
	* main/dynamic/mepCfg.h: Add C5 support.
@
text
@// cache.cxx -- A universal memory cache. -*- C++ -*-

// Copyright (C) 2001, 2002, 2004, 2005 Red Hat.
// This file is part of SID and is licensed under the GPL.
// See the file COPYING.SID for conditions for redistribution.

#include "config.h"

#include <sidcomp.h>
#include <sidso.h>
#include <sidcomputil.h>
#include <sidattrutil.h>
#include <sidpinutil.h>
#include <sidbusutil.h>
#include <sidmiscutil.h>
#include <sidtypes.h>

#include <algorithm>
#include <stdlib.h>
#include <vector>
#include <string>
#include <iostream>

using std::cout;
using std::endl;

#include "cache.h"
#include "mep-cache.h"

static string buffer_sizes[] =
  { "4", "8" };

static string line_sizes[] =
  { "16", "32", "64", "128" };

static string cache_sizes[] =
  { "1", "2", "4", "8", "16", "32", "64", "128", "256", "512" };

static string assocs[] =
  { "direct", "full", "2way", "4way" };

static string replacement_algorithms[] =
  { "lru", "fifo", "random" }; 

// One per replacement policy
static cache_replacement_null null_replacement;
static cache_replacement_lru lru_replacement;
static cache_replacement_fifo fifo_replacement;
static cache_replacement_random random_replacement;
static cache_line_factory internal_line_factory;
static mep_assoc_replacement_algorithm mep_assoc_replacement;

cache_component::cache_component (unsigned assocy,
				  unsigned cache_sz, 
				  unsigned line_sz,
				  cache_replacement_algorithm& replacer,
				  cache_line_factory& factory)
  :acache (cache_sz, line_sz, assocy, replacer, factory),
   upstream (*this),
   downstream (0),
   report_pin (this, &cache_component::emit_report),
   flush_all_pin (this, &cache_component::flush_all_lines),
   flush_pin (this, &cache_component::flush_line),
   flush_set_pin (this, &cache_component::flush_set),
   flush_and_invalidate_set_pin (this, &cache_component::flush_and_invalidate_set),
   invalidate_all_pin (this, &cache_component::invalidate_all_lines),
   invalidate_pin (this, &cache_component::invalidate_line),
   invalidate_set_pin (this, &cache_component::invalidate_set),
   flush_and_invalidate_pin (this, &cache_component::flush_and_invalidate_line),
   prefetch_pin (this, &cache_component::prefetch_line),
   write_hint_pin (this, &cache_component::write_hint),
   lock_pin (this, &cache_component::lock_line),
   unlock_pin (this, &cache_component::unlock_line),
   write_allocate_p (false),
   write_through_p (false),
   collect_p (true),
   report_heading ("cache profile report"),
   line_factory (factory),
   line_size (line_sz),
   cache_size (cache_sz),
   assoc (assocy),
   data_width (4),
   hit_latency (0),
   miss_latency (0),
   refill_latency (0),
   refill_latency_specified (false),
   total_latency_p (false)
{
  acache.init ();
  memset (&stats, 0, sizeof (stats));

  add_bus ("upstream", &upstream);
  add_accessor ("downstream", &downstream);
  
  add_pin ("report!", &report_pin);
  add_pin ("flush-all", &flush_all_pin);
  add_pin ("flush-set", &flush_set_pin);
  add_pin ("flush", &flush_pin);
  add_pin ("invalidate-all", &invalidate_all_pin);
  add_pin ("invalidate-set", &invalidate_set_pin);
  add_pin ("flush-and-invalidate-set", &flush_and_invalidate_set_pin);
  add_pin ("invalidate", &invalidate_pin);
  add_pin ("flush-and-invalidate", &flush_and_invalidate_pin);
  add_pin ("prefetch", &prefetch_pin);
  add_pin ("write-hint", &write_hint_pin);
  add_pin ("lock", &lock_pin);  
  add_pin ("unlock", &unlock_pin);
  add_pin ("operation-status", &operation_status_pin);
  
  add_attribute_ro ("cache-size", &cache_size, "setting");
  add_attribute_ro ("line-size", &line_size, "setting");
  add_attribute_virtual ("associativity", this,
			 &cache_component::associativity,
			 &cache_component::set_nothing,
			 "setting");
  add_attribute ("data-width", &data_width, "setting");

  add_attribute ("write-through?", &write_through_p, "setting");
  add_attribute ("write-allocate?", &write_allocate_p, "setting");

  add_attribute_virtual ("hash-bit-mask", this,
			 &cache_component::get_hash_mask,
			 &cache_component::set_hash_mask,
			 "setting");

  add_attribute_virtual ("hash-shift-amount", this,
			 &cache_component::get_hash_shift,
			 &cache_component::set_hash_shift,
			 "setting");

  add_attribute ("collect-statistics?", &collect_p, "setting");
  add_attribute ("report-heading", &report_heading, "setting");
  
  add_attribute_virtual ("dump!", this,
			 &cache_component::get_nothing,
			 &cache_component::dump,
			 "setting");

  add_attribute_ro ("read-accesses", &stats.reads, "register");
  add_attribute_ro ("write-accesses", &stats.writes, "register");
  add_attribute_ro ("misaligned-reads", &stats.misaligned_reads, "register");
  add_attribute_ro ("misaligned-writes", &stats.misaligned_writes, "register");
  add_attribute_ro ("flushes", &stats.flushes, "register");
  add_attribute_ro ("replacements", &stats.replacements, "register");

  add_attribute_virtual ("read-hit-rate", this,
			 &cache_component::read_hit_rate,
			 &cache_component::set_nothing,
			 "register");
  
  add_attribute_virtual ("write-hit-rate", this,
			 &cache_component::write_hit_rate,
			 &cache_component::set_nothing,
			 "register");

  add_attribute ("hit-latency", &hit_latency, "setting");
  add_attribute ("miss-latency", &miss_latency, "setting");
  add_attribute ("total-latency?", &total_latency_p, "setting");

  add_attribute_virtual ("refill-latency", this,
			 &cache_component::get_refill_latency,
			 &cache_component::set_refill_latency,
			 "setting");

  // FIXME: state save/restore
}




// dummy dtor
cache_component::~cache_component () throw ()
{
}


unsigned
cache_component::line_offset (const cache_line& line, const host_int_4& addr)
{
  return addr - acache.tag_to_addr (line.tag ());
}

template <typename DataType>
bus::status
cache_component::write_any (host_int_4 addr, DataType data)
{
  bus::status st, read_status;

  if (UNLIKELY (downstream == 0))
    return bus::unmapped;

  if (LIKELY (collect_p))
    stats.writes++;

  if (UNLIKELY (addr % sizeof (data) != 0))
    {
      if (LIKELY (collect_p))
	stats.misaligned_writes++;
    }

  // Punt on access across lines
  if (UNLIKELY (addr % line_size + sizeof (data) > line_size))
    return bus::misaligned;

  cache_tag tag = acache.addr_to_tag (addr);
  cache_line* line = acache.find (tag);
  if (LIKELY (line))
    {
      if (LIKELY (collect_p))
	stats.write_hits++;
      line->insert (line_offset (*line, addr), data);
      if (write_through_p)
	{
	  do
	    {
	      st = downstream->write (addr, data);
	      if (st == bus::ok)
		break;
	    }
	  while (handle_write_error (st, addr));
	  if (st != bus::ok)
	    return st;
	}
    }
  else
    {
      if (write_allocate_p && acache.vacancy_p (addr))
	{
	  if (collect_p)
	    stats.replacements++;

	  cache_line *expelled_line = acache.expell_line (tag);
	  assert (expelled_line);

	  if (! write_through_p)
	    {
	      if (expelled_line->valid_p () && expelled_line->dirty_p ())
		{
		  // flush a dirty line being replaced
		  if ((st = write_line (*expelled_line)) != bus::ok)
		    return st;
		}
	    }
	  else
	    {
	      do
		{
		  st = downstream->write (addr, data);
		  if (st == bus::ok)
		    break;
		}
	      while (handle_write_error (st, addr));
	      if (st != bus::ok)
		return st;
	    }

	  expelled_line->set_tag (tag);
	  if ((read_status = read_line (*expelled_line)) != bus::ok)
	    return read_status;
	      
	  expelled_line->insert (line_offset (*expelled_line, addr), data);
	}
      else
	{
	  // write through to memory to preserve the write
	  do
	    {
	      st = downstream->write (addr, data);
	      if (st == bus::ok)
		break;
	    }
	  while (handle_write_error (st, addr));
	  if (st != bus::ok)
	    return st;
	}
    }

  st = bus::ok;
  if (line)
    st.latency = hit_latency;
  else
    st.latency = read_status.latency + miss_latency;
  return st;
}

template <typename DataType>
bus::status
cache_component::read_any (host_int_4 addr, DataType& data)
{
  bus::status st, read_status;

  if (UNLIKELY (downstream == 0))
    return bus::unmapped;

  if (LIKELY (collect_p))
    stats.reads++;

  // Punt on misaligned accesses
  if (UNLIKELY (addr % sizeof (data) != 0))
    {
      if (LIKELY (collect_p))
	stats.misaligned_reads++;
    }

  // Punt on accesses across lines
  if (UNLIKELY (addr % line_size + sizeof (data) > line_size))
    return bus::misaligned;

  cache_tag tag = acache.addr_to_tag (addr);
  cache_line* line = acache.find (tag);
  if (LIKELY (line))
    {
      if (LIKELY (collect_p))
	stats.read_hits++;
      line->extract (line_offset (*line, addr), data);
    }
  else
    {
      // miss!
      if (acache.vacancy_p (addr))
	{
	  if (LIKELY (collect_p))
	    stats.replacements++;
	  
	  cache_line *expelled_line = acache.expell_line (tag);
	  assert (expelled_line);
	  if (expelled_line->valid_p () && expelled_line->dirty_p ())
	    {
	      // flush a dirty line being replaced
	      if ((st = write_line (*expelled_line)) != bus::ok)
		  return st;
	    }
	  expelled_line->set_tag (tag);
	  if ((read_status = read_line (*expelled_line)) != bus::ok)
	    return read_status;
	  expelled_line->extract (line_offset (*expelled_line, addr), data);
	}
      else
	{
	  do
	    {
	      st = downstream->read (addr, data);
	      if (st == bus::ok)
		break;
	    }
	  while (handle_read_error (st, addr));
	  st.latency += miss_latency;
	  return st;
	}
    }

  st = bus::ok;
  if (line)
    st.latency += hit_latency;
  else
    st.latency = read_status.latency + miss_latency;
  return st;
}

// Prepare a line for writing.  This means we are expecting to write
// to all the bytes in the line, so we set it up to *not* read the
// line from the cache on the first write to it, by making the line
// valid if needed.  As a side effect, if you don't write to all the
// bytes in the line, unwritten bytes are undefined when written to
// memory.
void
cache_component::write_hint (host_int_4 addr)
{
  bus::status st, read_status;

  if (UNLIKELY (downstream == 0))
    return;

  if (LIKELY (collect_p))
    stats.reads++;

  cache_tag tag = acache.addr_to_tag (addr);
  cache_line* line = acache.find (tag);
  if (LIKELY (line))
    {
      // Line already exists in cache, nothing to do.
    }
  else
    {
      // miss!
      if (acache.vacancy_p (addr))
	{
	  if (LIKELY (collect_p))
	    stats.replacements++;
	  
	  cache_line *expelled_line = acache.expell_line (tag);
	  assert (expelled_line);
	  if (expelled_line->valid_p () && expelled_line->dirty_p ())
	    {
	      // flush a dirty line being replaced
	      if ((st = write_line (*expelled_line)) != bus::ok)
		  return;
	    }
	  expelled_line->set_tag (tag);
	  // We don't actually read the line, though.
	  expelled_line->validate ();
	}
      else
	{
	  // No room in the cache, so our hint must go uneeded.
	}
    }

  st = bus::ok;
  if (line)
    st.latency += hit_latency;
  else
    st.latency = miss_latency;
  report_status (st);
  return;
}

bus::status
cache_component::read_line (cache_line& line)
{
  bus::status st;
  host_int_4 base = acache.tag_to_addr (line.tag ());
  lock_downstream ();
  host_int_2 actual_fill_latency = 0;
  for (host_int_4 offset = 0; offset < line_size; offset += data_width)
    {
      // Unlock the downstream interface for the last read
      if (offset + data_width >= line_size)
	unlock_downstream ();

      sid::big_int_8 data8;
      sid::big_int_4 data4;
      host_int_4 address = base + offset;
      if (data_width == 8)
	st = read_downstream (address, data8);
      else
	st = read_downstream (address, data4);

      if (st != bus::ok)
	{
	  unlock_downstream ();
	  return st;
	}

      if (total_latency_p)
	actual_fill_latency += st.latency;
      else if (st.latency > actual_fill_latency)
	actual_fill_latency = st.latency;

      if (data_width == 8)
	line.insert (offset, data8);
      else
	line.insert (offset, data4);
    }
  line.unlock ();
  line.clean ();
  line.validate ();

  if (refill_latency_specified && ! total_latency_p)
    st.latency = refill_latency;
  else
    st.latency = actual_fill_latency;

  return st;
}

bus::status
cache_component::write_line (cache_line& line)
{
  bus::status st;
  host_int_4 base = acache.tag_to_addr (line.tag ());
  lock_downstream ();
  host_int_2 actual_latency = 0;
  for (host_int_4 offset = 0; offset < line_size; offset += data_width)
    {
      // Unlock the downstream interface for the last write
      if (offset + data_width >= line_size)
	unlock_downstream ();

      sid::big_int_4 data4;
      sid::big_int_8 data8;
      host_int_4 address = base + offset;
      if (data_width == 8)
	{
	  line.extract (offset, data8);
	  st = write_downstream (address, data8);
	}
      else
	{
	  line.extract (offset, data4);
	  st = write_downstream (address, data4);
	}

      if (st != bus::ok)
	{
	  unlock_downstream ();
	  return st;
	}

      if (total_latency_p)
	actual_latency += st.latency;
      else if (st.latency > actual_latency)
	actual_latency = st.latency;
    }
  line.clean ();
  if (LIKELY (collect_p))
    stats.flushes++;
  st.latency = actual_latency;
  return st;
}

template<typename DataType>
bus::status
cache_component::read_downstream (host_int_4 address, DataType &data)
{
  bus::status st;
  do
    {
      st = downstream->read (address, data);
      if (st == bus::ok)
	break;
    }
  while (handle_read_error (st, address));
  return st;
}

template<typename DataType>
bus::status
cache_component::write_downstream (host_int_4 address, DataType data)
{
  bus::status st;
  do
    {
      st = downstream->write (address, data);
      if (st == bus::ok)
	break;
    }
  while (handle_write_error (st, address));
  return st;
}

void
cache_component::flush_all_lines (host_int_4)
{
  host_int_2 total_latency = 0;
  bus::status st;
  while (true)
    {
      cache_line* line = acache.find_any_dirty ();
      if (line == 0) break;
      st = write_line (*line);
      if (st != bus::ok)
	break;
      total_latency += st.latency;
    }
  st.latency = total_latency;
  report_status (st);
}

void
cache_component::flush_line (host_int_4 addr)
{
  bus::status st;
  cache_line* line = acache.find (acache.addr_to_tag (addr));
  if (line && line->dirty_p ())
    st = write_line (*line);
  report_status (st);
}

void
cache_component::flush_set (host_int_4 addr)
{
  host_int_4 index = acache.addr_to_index (addr);
  assert (index < acache.num_sets ());

  host_int_2 total_latency = 0;
  bus::status st;
  cache_set& set = acache [index];
  for (unsigned i = 0; i < set.num_lines(); i++)
    {
      cache_line& line = set [i];
      if (line.valid_p () && line.dirty_p ())
	{
	  st = write_line (line);
	  if (st != bus::ok)
	    break;
	  total_latency += st.latency;
	}
    }
  st.latency = total_latency;
  report_status (st);
}

void
cache_component::flush_and_invalidate_set (host_int_4 addr)
{
  host_int_4 index = acache.addr_to_index (addr);
  assert (index < acache.num_sets ());

  host_int_2 total_latency = 0;
  bus::status st;
  cache_set& set = acache [index];
  for (unsigned i = 0; i < set.num_lines(); i++)
    {
      cache_line& line = set [i];
      if (line.valid_p () && line.dirty_p ())
	{
	  st = write_line (line);
	  if (st != bus::ok)
	    break;
	  total_latency += st.latency;
	  line.invalidate ();
	}
    }
  st.latency = total_latency;
  report_status (st);
}

void
cache_component::invalidate_all_lines (host_int_4 ignore)
{
  acache.invalidate ();
  report_status (bus::ok);
}

void
cache_component::invalidate_line (host_int_4 addr)
{
  cache_line* line = acache.find (acache.addr_to_tag (addr));
  if (line)
    line->invalidate ();
  report_status (bus::ok);
}

void
cache_component::flush_and_invalidate_line (host_int_4 addr)
{
  cache_line* line = acache.find (acache.addr_to_tag (addr));
  if (line && line->dirty_p ())
    {
      bus::status st = write_line (*line);
      line->invalidate ();
      report_status (st);
      return;
    }
  report_status (bus::ok);
}

void
cache_component::invalidate_set (host_int_4 addr)
{
  host_int_4 set = acache.addr_to_index (addr);
  acache.invalidate (set);
  report_status (bus::ok);
}

void
cache_component::prefetch_line (host_int_4 addr)
{
  sid::big_int_1 dummy;
  bus::status st = read_any (addr, dummy);
  report_status (st);
}

void
cache_component::lock_line (host_int_4 addr)
{
  cache_line* line = acache.find (acache.addr_to_tag (addr));
  if (line)
    line->lock ();
  report_status (bus::ok);
}

void
cache_component::unlock_line (host_int_4 addr)
{
  cache_line* line = acache.find (acache.addr_to_tag (addr));
  if (line)
    line->unlock ();
  report_status (bus::ok);
}

void
cache_component::emit_report (host_int_4 ignore)
{
  cout << report_heading << endl
       << "reads:        " << make_attribute (stats.reads) << endl
       << "read hits:    " << read_hit_rate () << endl
       << "writes:       " << make_attribute (stats.writes) << endl
       << "write hits:   " << write_hit_rate () << endl
       << "replacements: " << make_attribute (stats.replacements) << endl
       << "flushes:      " << make_attribute (stats.flushes) << endl;
}

string
cache_component::get_hash_mask ()
{
  return make_attribute (acache.hash_params.mask);
}

string
cache_component::get_hash_shift ()
{
  return make_attribute (acache.hash_params.shift);
}

sid::component::status
cache_component::set_hash_shift (const string& value)
{
  unsigned shift;

  if (parse_attribute (value, shift) != sid::component::ok)
    return sid::component::bad_value;

  if ((acache.hash_params.mask >> shift) >= acache.num_sets ())
    return sid::component::bad_value;

  acache.hash_params.shift = shift;
  return sid::component::ok;
}

sid::component::status
cache_component::set_hash_mask (const string& value)
{
  sid::host_int_4 mask;

  if (parse_attribute (value, mask) != sid::component::ok)
    return sid::component::bad_value;

  if ((mask >> acache.hash_params.shift) >= acache.num_sets ())
    return sid::component::bad_value;

  acache.hash_params.mask = mask;
  return sid::component::ok;
}

string
cache_component::get_refill_latency ()
{
  return make_attribute (refill_latency);
}

sid::component::status
cache_component::set_refill_latency (const string& value)
{
  if (parse_attribute (value, refill_latency) != sid::component::ok)
    return sid::component::bad_value;
  refill_latency_specified = true;
  return sid::component::ok;
}

sid::component::status
cache_component::dump (const string& ignore)
{
  acache.dump ();
  return sid::component::ok;
}

string
cache_component::associativity ()
{
  switch (assoc)
    {
    case 0:
      return "fully-associative";
    case 1:
      return "direct-mapped";
    default:
      return make_attribute (assoc) + "-way";
    }
}

string
cache_component::read_hit_rate ()
{
  if (stats.reads == 0)
    return "0%";
  else
    {
      float rate = (static_cast<float> (stats.read_hits) / stats.reads) * 100;
      return make_attribute (static_cast<int> (rate)) + "%";
    }
}

string
cache_component::write_hit_rate ()
{
  if (stats.writes == 0)
    return "0%";
  else
    {
      float rate = (static_cast<float> (stats.write_hits) / stats.writes) * 100;
      return make_attribute (static_cast<int> (rate)) + "%";
    }
}

// ------------------------------------------------------------------------
// The blocking cache component.

// This function is the root of the blockable child thread. It gets passed
// to pthread_create.
//
extern "C" void *
blocking_cache_child_thread_root (void *comp)
{
  // Set up this thread to receive and handle signals from the parent thread.
  // this need only be done once.
  //
  blocking_cache_component *cache = static_cast<blocking_cache_component *>(comp);
  cache->child_init ();

  for (;;)
    {
      // Signal completion and wait for the signal to resume
      cache->child_completed ();

      // Now perform the transaction
      cache->perform_transaction ();
    }

  // We should never reach here.
  return NULL;
}

blocking_cache_component::blocking_cache_component (unsigned assocy,
						    unsigned cache_sz, 
						    unsigned line_sz,
						    cache_replacement_algorithm& replacer,
						    cache_line_factory& factory)
  :cache_component (assocy, cache_sz, line_sz, replacer, factory),
   blocking_component (this, blocking_cache_child_thread_root)
{
  add_pin ("downstream-lock", & downstream_lock_pin);
  downstream_lock_pin.set_active_high ();
}

blocking_cache_component::blocking_cache_component (void *child_self,
						    unsigned assocy,
						    unsigned cache_sz, 
						    unsigned line_sz,
						    cache_replacement_algorithm& replacer,
						    cache_line_factory& factory)
  :cache_component (assocy, cache_sz, line_sz, replacer, factory),
   blocking_component (child_self, blocking_cache_child_thread_root)
{
  add_pin ("downstream-lock", & downstream_lock_pin);
  downstream_lock_pin.set_active_high ();
}

// Handles bus errors from reads and writes from/to insn and data memory.
// Specifically, bus::busy is handled in blockable mode.
//
bool
blocking_cache_component::handle_bus_error (bus::status s)
{
  if (s != bus::busy)
    return false; // not handled

  // Signal that we're blocked and wait for the signal to try again
  transaction_status = s;
  child_blocked ();
  return true;
}

#define DEFN_METHOD(DataType) \
bus::status \
blocking_cache_component::write(host_int_4 addr, DataType data) \
{ \
  if (blockable) \
    { \
      /* Signal the child thread to resume */ \
      need_child_thread (); \
      setup_write_transaction (addr, data); \
      continue_child_thread_and_wait (); \
 \
      return transaction_status; \
    } \
  return this->write_any(addr, data); \
} \
bus::status \
blocking_cache_component::read(host_int_4 addr, DataType& data) \
{ \
  if (blockable) \
    { \
      /* Signal the child thread to resume */ \
      need_child_thread (); \
      setup_read_transaction (addr, data); \
      continue_child_thread_and_wait (); \
 \
      get_transaction_data (data); \
      return transaction_status; \
    } \
  return this->read_any(addr, data); \
}
DEFN_METHOD (big_int_1)
DEFN_METHOD (big_int_2)
DEFN_METHOD (big_int_4)
DEFN_METHOD (big_int_8)
DEFN_METHOD (little_int_1)
DEFN_METHOD (little_int_2)
DEFN_METHOD (little_int_4)
DEFN_METHOD (little_int_8)
#undef DEFN_METHOD

void
blocking_cache_component::flush_all_lines (host_int_4 v)
{
  if (blockable)
    {
      // Signal the child thread to resume
      need_child_thread ();
      setup_flush_all_transaction ();
      int signal = continue_child_thread_and_wait ();
      if (signal == ctl_child_blocked)
	report_status (transaction_status);
      return;
    }
  cache_component::flush_all_lines (v);
}

void
blocking_cache_component::flush_line (host_int_4 addr)
{
  if (blockable)
    {
      // Signal the child thread to resume
      need_child_thread ();
      setup_flush_line_transaction (addr);
      int signal = continue_child_thread_and_wait ();
      if (signal == ctl_child_blocked)
	report_status (transaction_status);
      return;
    }
  cache_component::flush_line (addr);
}

void
blocking_cache_component::flush_set (host_int_4 addr)
{
  if (blockable)
    {
      // Signal the child thread to resume
      need_child_thread ();
      setup_flush_set_transaction (addr);
      int signal = continue_child_thread_and_wait ();
      if (signal == ctl_child_blocked)
	report_status (transaction_status);
      return;
    }
  cache_component::flush_set (addr);
}

void
blocking_cache_component::flush_and_invalidate_set (host_int_4 addr)
{
  if (blockable)
    {
      // Signal the child thread to resume
      need_child_thread ();
      setup_flush_and_invalidate_set_transaction (addr);
      int signal = continue_child_thread_and_wait ();
      if (signal == ctl_child_blocked)
	report_status (transaction_status);
      return;
    }
  cache_component::flush_and_invalidate_set (addr);
}

void
blocking_cache_component::flush_and_invalidate_line (host_int_4 addr)
{
  if (blockable)
    {
      // Signal the child thread to resume
      need_child_thread ();
      setup_flush_and_invalidate_line_transaction (addr);
      int signal = continue_child_thread_and_wait ();
      if (signal == ctl_child_blocked)
	report_status (transaction_status);
      return;
    }
  cache_component::flush_and_invalidate_line (addr);
}

void
blocking_cache_component::prefetch_line (host_int_4 addr)
{
  sid::big_int_1 dummy;
  bus::status st = read (addr, dummy);
  report_status (st);
}


cache_line *
cache_replacement_fifo::expell (cache_set& cset)
{
  // If this is the first time through, expand fifo accordingly.
  if (fifo.size () != cset.num_lines ())
    fifo.resize (cset.num_lines ());

  for (unsigned i = 0; i < fifo.size (); i++)
    fifo[i]++;

  unsigned i;
  vector<int> candidates(fifo);

  int n = fifo.size ();
  while (n > 0)
    {
      vector<int>::iterator it;
      it = max_element (candidates.begin (), candidates.end ());
      i = distance (candidates.begin (), it);
      cache_line& line = cset.get_line (i);
      if (line.locked_p ())
	{
	  *it = -1;
	}
      else 
	{
	  // update state
	  fifo[i] = 0;
	  return &line;
	}
      n--;
    }

  return 0;
}

cache_line *
cache_replacement_lru::expell (cache_set& cset)
{
  unsigned oldest = 0;
  int index = -1;
  lru.resize (cset.num_lines ());

  for (unsigned i = 0; i < cset.num_lines (); i++)
    {
      cache_line& line = cset.get_line (i);
      if (!line.valid_p ())
	{
	  index = i;
	  break;
	}
      else if (!line.locked_p () && lru[i] > oldest)
	{
	  index = i;
	  oldest = lru[i];
	}
    }

  if (index < 0)
    return 0;

  lru[index] = 0;
  return &cset.get_line (index);
}

void
cache_replacement_lru::update (cache_set& cset, cache_line& selected_line)
{
  cache_tag t = selected_line.tag ();
  for (unsigned i = 0; i < lru.size (); i++)
    {
      if (cset.get_line (i) == t)
	lru[i] = 0;
      else
	lru[i]++;
    }
}

cache_line *
cache_replacement_null::expell (cache_set& cset)
{
  cache_line& line = cset.get_line (0);
  if (!line.locked_p ())
    return &line;

  return 0;
}

cache_line *
cache_replacement_random::expell (cache_set& cset)
{
  for (unsigned i = 0; i < cset.num_lines (); i++)
    {
      cache_line& line = cset.get_line (i);
      if (!line.valid_p ())
	return &line;
    }

  unsigned n = cset.num_lines ();
  vector<bool> candidates(n, true);

  while (n > 0)
    {
      unsigned i = rand () % cset.num_lines ();
      
      // Try, try again.
      if (!candidates[i]) continue;

      cache_line& line = cset.get_line (i);
      if (!line.locked_p ())
	return &line;

      candidates[i] = false;
      n--;
    }

  return 0;
}


static vector<string>
CacheListTypes ()
{
  string type;
  vector<string> types;

  types.push_back ("hw-cache-basic");
  types.push_back ("hw-blocking-cache-basic");

  for (unsigned i = 0; i < (sizeof (buffer_sizes) / sizeof (string)); i++)
    {
      types.push_back ("hw-cache-buffer-" + buffer_sizes[i]);
      types.push_back ("hw-blocking-cache-buffer-" + buffer_sizes[i]);
    }

  for (unsigned i = 0; i < (sizeof (assocs) / sizeof (string)); i++)
    for (unsigned j = 0; j < (sizeof (cache_sizes) / sizeof (string)); j++)
      for (unsigned k = 0; k < (sizeof (line_sizes) / sizeof (string)); k++)
	{
	  if (assocs[i] == "direct")
	    {
	      type = cache_sizes[j] + "kb/";
	      type += line_sizes[k];
	      types.push_back ("hw-cache-direct/" + type);
	      types.push_back ("hw-blocking-cache-direct/" + type);
	    }
	  else
	    for (unsigned m = 0;
		 m < (sizeof (replacement_algorithms) / sizeof (string)); m++)
	      {
		type = assocs[i] + "/";
		type += cache_sizes[j] + "kb/";
		type += line_sizes[k] + "/";
		type += replacement_algorithms[m];
		types.push_back ("hw-cache-" + type);
		types.push_back ("hw-blocking-cache-" + type);
	      }
	}

  for (unsigned i = 0; i < (sizeof (assocs) / sizeof (string)); i++)
    for (unsigned j = 0; j < (sizeof (cache_sizes) / sizeof (string)); j++)
      for (unsigned k = 0; k < (sizeof (line_sizes) / sizeof (string)); k++)
	{
	  type = "hw-mep-cache-";
	  type += assocs[i] + "/";
	  type += cache_sizes[j] + "kb/";
	  type += line_sizes[k];
	  types.push_back (type);
	}

  return types;
}

static component *
create_mep_cache (vector<string>& parts)
{
  // decode cache types: hw-mep-cache-<assoc>/<s>kb/<ls>
  //
  string assoc_string = parts[3];

  bool match;
  int i;
  for (match = false, i = 0; i < sizeof (assocs) / sizeof (string); i++)
    if (assoc_string == assocs[i])
      match = true;

  if (!match)
    return 0;
  
  // Parse "<x>kb", where <x> is a positive integer. 
  int cache_sz;
  string cache_size_string = parts[4].substr (0, parts[4].length() - 2);
  for (match = false, i = 0; i < sizeof (cache_sizes) / sizeof (string); i++)
    if (cache_size_string == cache_sizes[i])
      {
	cache_sz = atoi (cache_size_string.c_str ()) * 1024;
	match = true;
      }

  if (!match)
    return 0;
  
  int line_sz;
  string line_size_string = parts[5];
  for (match = false, i = 0; i < sizeof (line_sizes) / sizeof (string); i++)
    if (line_size_string == line_sizes[i])
      {
	line_sz = atoi (line_size_string.c_str ());
	match = true;
      }

  if (!match)
    return 0;

  int assoc;
  if (assoc_string == "direct")
    assoc = 1;
  else
    {
      int pos;
      if ((pos = assoc_string.find ("way", 0)) == string::npos)
	return 0;

      assoc_string.erase (pos, assoc_string.length () - pos);
      if ((assoc = atoi (assoc_string.c_str ())) == 0)
	return 0;
    }

  if (assoc == 1)
    return new mep_cache (assoc, cache_sz, line_sz, null_replacement);
  
  return new mep_cache (assoc, cache_sz, line_sz, mep_assoc_replacement);
}

static component*
CacheCreate (const string& typeName)
{
  unsigned i;
  bool match;

  if (typeName == "hw-cache-basic")
    return new cache_component (1, 16384, 32, null_replacement, internal_line_factory);

  if (typeName == "hw-blocking-cache-basic")
    return new blocking_cache_component (1, 16384, 32, null_replacement, internal_line_factory);

  if (typeName.substr (0, 16) == "hw-cache-buffer-")
    {
      unsigned size;
      if (parse_attribute (typeName.substr (16), size) != sid::component::ok)
	return 0;
      return new cache_component (0, size, size, null_replacement, internal_line_factory);
    }
  
  if (typeName.substr (0, 25) == "hw-blocking-cache-buffer-")
    {
      unsigned size;
      if (parse_attribute (typeName.substr (25), size) != sid::component::ok)
	return 0;
      return new blocking_cache_component (0, size, size, null_replacement, internal_line_factory);
    }
  
  vector<string> parts = sidutil::tokenize (typeName, "-/");

  if (parts.size () >= 6 && parts[0] == "hw" && parts[1] == "mep" && parts[1] != "cache")
    return create_mep_cache (parts);

  unsigned extra_ix;
  if (parts.size () >= 5 && parts[0] == "hw" && parts[1] == "cache")
    extra_ix = 0;
  else if (parts.size () >= 6 && parts[0] == "hw" && parts[1] == "blocking" && parts[2] == "cache")
    extra_ix = 1;
  else
    return 0;
  
  string assoc_string = parts[2 + extra_ix];
  for (match = false, i = 0; i < sizeof (assocs) / sizeof (string); i++)
    if (assoc_string == assocs[i])
      match = true;

  if (!match)
    return 0;
  
  // Parse "<x>kb", where <x> is a positive integer. 
  int cache_sz;
  string cache_size_string = parts[3 + extra_ix].substr (0, parts[3 + extra_ix].length() - 2);
  for (match = false, i = 0; i < sizeof (cache_sizes) / sizeof (string); i++)
    if (cache_size_string == cache_sizes[i])
      {
	cache_sz = atoi (cache_size_string.c_str ()) * 1024;
	match = true;
      }

  if (!match)
    return 0;
  
  int line_sz;
  string line_size_string = parts[4 + extra_ix];
  for (match = false, i = 0; i < sizeof (line_sizes) / sizeof (string); i++)
    if (line_size_string == line_sizes[i])
      {
	line_sz = atoi (line_size_string.c_str ());
	match = true;
      }

  if (!match)
    return 0;
  
  string replace_alg_string;
  if (assoc_string != "direct")
    if (parts.size () + extra_ix < 6)
      return 0;
    else
      {
	replace_alg_string = parts[5 + extra_ix];
	for (match = false, i = 0; i < sizeof (replacement_algorithms) / sizeof (string); i++)
	  if (replace_alg_string == replacement_algorithms[i])
	    match = true;
	
	if (!match)
	  return 0;
      }
  
  int assoc;
  if (assoc_string == "full")
    assoc = 0;
  else if (assoc_string == "direct")
    assoc = 1;
  else
    {
      int pos;
      if ((pos = assoc_string.find ("way", 0)) == string::npos)
        return 0;
      assoc_string.erase (pos, assoc_string.length () - pos);
      if ((assoc = atoi (assoc_string.c_str ())) == 0)
        return 0;
    }

  if (extra_ix == 0)
    {
      if (assoc == 1)
	return new cache_component (assoc, cache_sz, line_sz, null_replacement, internal_line_factory);
  
      if (replace_alg_string == "lru")
	return new cache_component (assoc, cache_sz, line_sz, lru_replacement, internal_line_factory);
      else if (replace_alg_string == "fifo")
	return new cache_component (assoc, cache_sz, line_sz, fifo_replacement, internal_line_factory);
      else if (replace_alg_string == "random")
	return new cache_component (assoc, cache_sz, line_sz, random_replacement, internal_line_factory);
    }
  else
    {
      if (assoc == 1)
	return new blocking_cache_component (assoc, cache_sz, line_sz, null_replacement, internal_line_factory);
  
      if (replace_alg_string == "lru")
	return new blocking_cache_component (assoc, cache_sz, line_sz, lru_replacement, internal_line_factory);
      else if (replace_alg_string == "fifo")
	return new blocking_cache_component (assoc, cache_sz, line_sz, fifo_replacement, internal_line_factory);
      else if (replace_alg_string == "random")
	return new blocking_cache_component (assoc, cache_sz, line_sz, random_replacement, internal_line_factory);
    }

  return 0;
}

static void
CacheDelete (component* c)
{
  delete dynamic_cast<cache_component*>(c);
}

DLLEXPORT extern const sid::component_library cache_component_library;

const sid::component_library cache_component_library =
{
  sid::COMPONENT_LIBRARY_MAGIC,
  &CacheListTypes,
  &CacheCreate,
  &CacheDelete
};
@


1.23
log
@Support for Toshiba MeP.
@
text
@d71 1
d105 1
d360 58
@


1.22
log
@2006-05-10  Dave Brolley  <brolley@@redhat.com>

        * cache.cxx (buffer_sizes): New static table.
        (CacheListTypes): List hw-cache-buffer-* using buffer_sizes. Same for
        hw-blocking-cache-buffer-*.
        (CacheCreate): Parse hw-cache-buffer-N and hw-blocking-cache-buffer-N
        in order to determine buffer size.
@
text
@d28 1
d51 1
d1092 12
d1107 61
d1198 3
@


1.21
log
@* DLLEXPORT decoration tweak, from Rex Sung-Tien Cho <song10@@andestech.com>
@
text
@d29 3
d1060 6
a1065 2
  types.push_back ("hw-cache-buffer-8");
  types.push_back ("hw-blocking-cache-buffer-8");
d1105 15
a1119 2
  if (typeName == "hw-cache-buffer-8")
    return new cache_component (0, 8, 8, null_replacement, internal_line_factory);
a1120 3
  if (typeName == "hw-blocking-cache-buffer-8")
    return new blocking_cache_component (0, 8, 8, null_replacement, internal_line_factory);
   
@


1.20
log
@2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * hw-cache.xml: Input to flush-set, invalidate-set and
        * hw-cache.txt: Regenerated.
        flush-and-invalidate-set is now an address.
        * cacheutil.h (addr_to_tag): New method of cache.
        * cacheutil.cxx (addr_to_tag): New method of cache.
        * cache.cxx (cache_component::flush_set): Input argument is now an address.
        (cache_component::flush_and_invalidate_set): Likewise.
        (blocking_cache_component::flush_set): Likewise.
        (blocking_cache_component::flush_and_invalidate_set): Likewise.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * cache.cxx (cache_component): Initialize data_width. Add "data-width"
        attribute.
        (read_line): Access the data 4 or 8 bytes at a time, depending on
        data_width.
        (write_line): Ditto.
        (read_downstream, write_downstream): New methods of cache_component.
        * cache.h (read_downstream, write_downstream): New methods of
        cache_component.
        (data_width): New member of cache_component.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * cache.cxx (cache_component): Add "operation-status" pin.
        (cache_component::flush_all_lines): Accumulate latency and call
        report_status.
        (cache_component::flush_line): Ditto.
        (cache_component::flush_set): Ditto.
        (cache_component::flush_and_invalidate_set): Ditto.
        (cache_component::invalidate_all_lines): Call report_status.
        (cache_component::invalidate_line): Ditto.
        (cache_component::flush_and_invalidate_line): Ditto.
        (cache_component::invalidate_set): Ditto.
        (cache_component::prefetch_line): Ditto.
        (cache_component::lock_line): Ditto.
        (cache_component::unlock_line): Ditto.
        (blocking_cache_component::flush_all_lines): Call report_status if
        child is blocked.
        (blocking_cache_component::flush_line): Ditto.
        (blocking_cache_component::flush_set): Ditto.
        (blocking_cache_component::flush_and_invalidate_set): Ditto.
        (blocking_cache_component::flush_and_invalidate_line): Ditto.
        (blocking_cache_component::prefetch_line): Ditto.
        * cache.h (report_status): New method of cache_component.
        (operation_status_pin): New output pin.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * cache.h (flush_all_lines, flush_line, flush_set)
        (flush_and_invalidate_set, flush_and_invalidate_line)
        (prefetch_line): Now virtual. Also, new methods of
        blocking_cache_component.
        (setup_flush_all_transaction, setup_flush_line_transaction)
        (setup_flush_set_transaction)
        (setup_flush_and_invalidate_set_transaction)
        (setup_flush_and_invalidate_line_transaction)
        (perform_flush_all_transaction, perform_flush_line_transaction)
        (perform_flush_set_transaction)
        (perform_flush_and_invalidate_set_transaction)
        (perform_flush_and_invalidate_line_transaction): New methods of
        blocking_cache_component.
        * cache.cxx (blocking_cache_component::write): Remove log message. Don't
        need return code from continue_child_thread_and_wait.
        blocking_cache_component::read): Ditto.
        (flush_all_lines, flush_line, flush_set)
        (flush_and_invalidate_set, flush_and_invalidate_line)
        (prefetch_line): New methods of blocking_cache_component.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * cache.cxx (cache_component): Initialize total_latency_p. Add
        "total-latency?" attribute.
        (read_line): Return the total latency of all accesses if total_latency_p
        is set.
        (write_line): Ditto.
        (handle_bus_error): Copy the status, s, to transaction_status.
        (blocking_cache_component::read): Always return transaction_status.
        (blocking_cache_component::write): Ditto.
        * cache.h (total_latency_p): New member of cache_component.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * cache.h (cache_component::lock_downstream): New virtual method.
        (cache_component::unlock_downstream): New virutal method.
        (blocking_cache_component::lock_downstream): New virtual override.
        (blocking_cache_component::unlock_downstream): New virtual override.
        * cache.cxx (read_line): Return the maximum latency from the reads
        performed if refill latency is not requested. Call lock_downstream
        before the first read. Call unlock_downstream before the final read.
        (write_line): Ditto.
        (blocking_cache_component): Add downstream-lock pin.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * cache.cxx (blocking_cache_child_thread_root): Don't call
        child->child_wait_for_resume.
        (handle_bus_error): Ditto.
        (DEFN_METHOD): SID_SIG_CHILD_BLOCKED is now ctl_child_blocked.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * Makefile.am (AM_XXXFLAGS): Set it to $(TOP_CXXFLAGS).
        (AM_MAKEFLAGS): Pass along TOP_CXXFLAGS.
        * Makefile.in: Regenerated.

2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * mep-cache.cxx (mep_cache): Inherit from blocking_cache_component.
        * mep-cache.h (mep_cache): Inherit from blocking_cache_component.
        * cache.h (sidblockingutil.h): #include it.
        (namespace sid): Add "using" clause. Remove sid:: qualifier from
        declarations.
        (cache_component): Inhereit virtually from
        fixed_attribute_map_component and fixed_pin_map_component.
        (cache_component::write): Variants now virtual.
        (cache_component::read): Ditto.
        (cache_component::handle_read_error): New virtual method.
        (cache_component::handle_write_error): New virtual method.
        (cache_bus::write_any): Call cache.write.
        (cache_bus::read_any): Call cache.read.
        (blocking_cache_component): New class.
        * cache.cxx (cache_component::write_any): Call handle_write_error to
        handle bus errors.
        (cache_component::write_line): Ditto.
        (cache_component::read_any): Call handle_read_error as above.
        (cache_component::read_line): Ditto.
        (blocking_cache_child_thread_root): New function.
        (blocking_cache_component): New constructor.
        (handle_bus_error): New method.
        (blocking_cache_component:write): New methods.
        (blocking_cache_component::read): New methods.
        (CacheListTypes): Add hw-blocking-cache-basic and
        hw-blocking-cache-buffer-8, hw-blocking-cache-direct* and
        hw-blocking-cache/*kb*.
        (CacheCreate): Parse and construct the above.
@
text
@a1048 2
extern const sid::component_library cache_component_library;

d1211 3
a1213 1
const sid::component_library cache_component_library DLLEXPORT =
@


1.19
log
@2004-07-20  Dave Brolley  <brolley@@redhat.com>

        * cacheutil.cxx (find): Make sure cache line is valid before returning
        it.
        * cache.cxx (write_any): Move call to addr_to_tag to a later point when
        the result is actually needed. Make sure cache line is valid before
        flushing it.
        (read_any): Make sure cache line is valid before flushing it.
@
text
@d3 1
a3 1
// Copyright (C) 2001, 2002, 2004 Red Hat.
d76 1
d80 2
a81 1
   refill_latency_specified (false)
d101 1
d109 1
d151 1
d207 8
a214 1
	  if ((st = downstream->write (addr, data)) != bus::ok)
d239 8
a246 1
	      if ((st = downstream->write (addr, data)) != bus::ok)
d259 8
a266 1
	  if ((st = downstream->write (addr, data)) != bus::ok)
d333 7
a339 1
	  st = downstream->read (addr, data);
a356 1
  int overall_latency = 0;
d358 16
a373 7
  for (host_int_4 offset = 0; offset < line_size; offset += 4)
    {
      sid::big_int_4 data;
      st = downstream->read (base + offset, data);
      // Record the latency of the first read.
      if (offset == 0)
	overall_latency = st.latency;
d375 14
a388 2
	return st;
      line.insert (offset, data);
d394 1
a394 1
  if (refill_latency_specified)
d397 1
a397 1
    st.latency = overall_latency;
d407 22
a428 5
  for (host_int_4 offset = 0; offset < line_size; offset += 4)
    {
      sid::big_int_4 data;
      line.extract (offset, data);
      st = downstream->write (base + offset, data);
d430 9
a438 1
	return st;
d443 31
d480 2
d486 4
a489 1
      (void) write_line (*line);
d491 2
d498 1
d501 2
a502 1
    (void) write_line (*line);
d506 1
a506 1
cache_component::flush_set (host_int_4 index)
d508 2
a509 2
  if (index >= acache.num_sets ())
    return; // bad value
d511 2
d518 6
a523 1
	(void) write_line (line);
d525 2
d530 1
a530 1
cache_component::flush_and_invalidate_set (host_int_4 index)
d532 2
a533 2
  if (index >= acache.num_sets ())
    return; // bad value
d535 2
d543 4
a546 1
	  (void) write_line (line);
d550 2
d558 1
d567 1
d576 1
a576 1
      (void) write_line (*line);
d578 2
d581 1
d585 1
a585 1
cache_component::invalidate_set (host_int_4 set)
d587 1
d589 1
d596 2
a597 1
  (void) read_any (addr, dummy);
d606 1
d615 1
d732 197
d1058 1
d1060 1
d1068 1
a1068 2
	      type = string ("hw-cache-direct/");
	      type += cache_sizes[j] + "kb/";
d1070 2
a1071 1
	      types.push_back (type);
d1077 1
a1077 2
		type = string ("hw-cache-");
		type += assocs[i] + "/";
d1081 2
a1082 1
		types.push_back (type);
d1097 3
d1103 3
d1108 6
a1113 1
  if (parts.size () < 5 || parts[0] != "hw" || parts[1] != "cache")
d1116 1
a1116 1
  string assoc_string = parts[2];
d1126 1
a1126 1
  string cache_size_string = parts[3].substr (0, parts[3].length() - 2);
d1138 1
a1138 1
  string line_size_string = parts[4];
d1151 1
a1151 1
    if (parts.size () < 6)
d1155 1
a1155 1
	replace_alg_string = parts[5];
d1179 16
a1194 2
  if (assoc == 1)
    return new cache_component (assoc, cache_sz, line_sz, null_replacement, internal_line_factory);
d1196 7
a1202 6
  if (replace_alg_string == "lru")
    return new cache_component (assoc, cache_sz, line_sz, lru_replacement, internal_line_factory);
  else if (replace_alg_string == "fifo")
    return new cache_component (assoc, cache_sz, line_sz, fifo_replacement, internal_line_factory);
  else if (replace_alg_string == "random")
    return new cache_component (assoc, cache_sz, line_sz, random_replacement, internal_line_factory);
@


1.18
log
@2004-07-01  Dave Brolley  <brolley@@redhat.com>

        * cache.cxx (write_any): Allow misaligned access. Return
        bus::misaligned for accesses which cross line boundary.
        (read_any): Ditto.
@
text
@a182 1
  cache_tag tag = acache.addr_to_tag (addr);
d193 1
d218 1
a218 1
	      if (expelled_line->dirty_p ())
d294 1
a294 1
	  if (expelled_line->dirty_p ())
@


1.17
log
@2004-04-29  Dave Brolley  <brolley@@redhat.com>

        * cacheutil.cxx (cache_set::expell_line): Don't update the set here.

2004-04-29  Dave Brolley  <brolley@@redhat.com>

        * cache.cxx: Update calls to cache::find.
        * cacheutil.cxx (cache_set::allocate_lines): Now takes cache index as
        an argument. Update all callers.
        (cache_set::find): Now returns a pointer to the line, if found. Update
        all callers.
        (cache::find): Ditto.
        (cache_set::expell_line): Update the status of the expelled line.
        * cacheutil.h (cache_line_factory::make_line): Now takes cache index as
        an argument. Update all callers.
        (cache_set::allocate_lines): Now takes cache index as
        an argument. Update all callers.
        (cache_set::find): Now returns a pointer to the line, if found. Update
        all callers.
        (cache::find): Ditto.

2004-04-29  Dave Brolley  <brolley@@redhat.com>

        * cacheutil.h (cache_line): Removed copy constructor. Now virtual base
        class.
        (cache_line::operator=): Removed.
        (internal_cache_line): New class implements former cache_line class.
        (cache_set): Now takes cache_line_factory.
        (allocate_lines): New method moves line allocation from the constructor.
        (cache_set::set_line): Now takes reference to cache_line.
        (cache_set::replace_line): Renamed to expell_line. Now returns a pointer
        to the expelled line.
        (cache): Now takes cache_line_factory argument.
        (cache::init): New method moves set allocation from the constructor.
        (cache_set::expell_line): Renamed to expell_line. Now returns a pointer
        to the expelled line.
        (cache_line_factory): New class.
        * cacheutil.cxx (cache_line): Removed copy constructor. Now virtual base
        class.
        (cache_line::operator=): Removed.
        (internal_cache_line): New class implements former cache_line class.
        (cache_set): Now takes cache_line_factory.
        (allocate_lines): New method moves line allocation from the constructor.
        (cache_set::set_line): Now takes reference to cache_line.
        (dummy): Now internal to cache_set::find.
        (cache_set::replace_line): Renamed to expell_line. Now returns a pointer
        to the expelled line.
        (cache): Now takes cache_line_factory argument.
        (cache::init): New method moves set allocation from the constructor.
        (cache_set::expell_line): Renamed to expell_line. Now returns a pointer
        to the expelled line.
        * cache.h (cache_replacement_algorithm::expell): Renamed from 'replace'.
        Returns a pointer to the expelled line. Update specializations.
        (cache_component): Now takes a cache_line_factory as an argument.
        Private data now protected.
        (line_factory): New member of cache_component.
        (~cache_component): Now virtual.
        (CacheCreate): Pass internal_line_factory to cache_component.
        * cache.cxx (line_sizes): Make it static.
        (line_sizes): Ditto.
        (replacement_algorithms): Ditto.
        (internal_line_factory): New static cache_line_factory.
        (cache_component): Now takes a cache_line_factory as an argument. Pass
        the cache line factory to the constructor for acache. Save a reference
        to the line factory. Call acache.init
        (write_any): Rewrite to use cache::expell_line instead of the former
        cache::replace.
        (read_any): Ditto.
        (cache_replacement_algorithm::expell): Renamed from 'replace'. Returns
        a pointer to the expelled line. Update all callers and specializations.
        (CacheCreate): Pass internal_line_factory to cache_component.
@
text
@a185 1
      // Punt on misaligned accesses
d188 1
d190 3
a192 16
      cache_line* line = acache.find (tag);
      if (line)
      {
	if (line->dirty_p ())
        {	
	  // flush a dirty line being replaced
	  if ((st = write_line (*line)) != bus::ok)
	    return st;
	}
	acache.expunge (*line);
      }

      st = downstream->read (addr, data);
      st.latency += miss_latency;
      return st;
    }
d270 1
d272 3
a274 4
      st = downstream->read (addr, data);
      st.latency += miss_latency;
      return st;
    }
@


1.16
log
@* contribute Red Hat patch from 2002-06-04.

2002-06-04  Graydon Hoare  <graydon@@redhat.com>

	* cache.h (cache_component::set_refill_latency): New method.
	(cache_component::get_refill_latency): New method.
	(cache_component::refill_latency_specified): New flag.
	(cache_component): Virtualize "refill-latency" attribute,
	note when it is set in "refill_latency_specified".
	* cache.cxx (read_line): Return either refill latency or
	downstream latencies, depending on whether explicit refill
	latency has been specified, not sum of both.
@
text
@d3 1
a3 1
// Copyright (C) 2001, 2002 Red Hat.
d29 1
a29 1
string line_sizes[] =
d32 1
a32 1
string cache_sizes[] =
d35 1
a35 1
string assocs[] =
d38 1
a38 1
string replacement_algorithms[] =
d46 1
d51 3
a53 2
				  cache_replacement_algorithm& replacer)
  :acache (cache_sz, line_sz, assocy, replacer),
d72 1
d81 1
a174 1
  bool hit;
d183 1
d190 2
a191 2
      cache_line& line = acache.find (acache.addr_to_tag (addr), hit);
      if (hit)
d193 1
a193 1
	if (line.dirty_p ())
d196 1
a196 1
	  if ((st = write_line (line)) != bus::ok)
d199 1
a199 1
	acache.expunge (line);
d207 2
a208 2
  cache_line& line = acache.find (acache.addr_to_tag (addr), hit);
  if (LIKELY (hit))
d212 1
a212 1
      line.insert (line_offset (line, addr), data);
d221 1
a221 1
      if (write_allocate_p)
d223 7
a229 1
	  if (acache.vacancy_p (addr))
d231 1
a231 12
	      cache_line expelled_line (line_size);
	      cache_line new_line (line_size, acache.addr_to_tag (addr));
	      if ((read_status = read_line (new_line)) != bus::ok)
		return read_status;
	      
	      new_line.insert (line_offset (new_line, addr), data);
	      acache.replace (expelled_line, new_line);
	      
	      if (collect_p)
		stats.replacements++;
	      
	      if (expelled_line.dirty_p () && !write_through_p)
d234 1
a234 1
		  if ((st = write_line (expelled_line)) != bus::ok)
d237 10
d248 1
a248 6
	      if (write_through_p)
		{
		  if ((st = downstream->write (addr, data)) != bus::ok)
		    return st;
		}
	    }
d259 1
a259 1
  if (hit)
d289 3
a291 3
  bool hit;
  cache_line& line = acache.find (acache.addr_to_tag (addr), hit);
  if (LIKELY (hit))
d295 1
a295 1
      line.extract (line_offset (line, addr), data);
d302 1
a302 9
	  cache_line expelled_line (line_size);
	  cache_line new_line (line_size, acache.addr_to_tag (addr));

	  if ((read_status = read_line (new_line)) != bus::ok)
	    return read_status;
	  new_line.extract (line_offset (new_line, addr), data);
	  acache.replace (expelled_line, new_line);

	  if (collect_p)
d305 3
a307 1
	  if (expelled_line.dirty_p ())
d310 1
a310 1
	      if ((st = write_line (expelled_line)) != bus::ok)
d313 4
d327 1
a327 1
  if (hit)
d396 3
a398 4
  bool hit;
  cache_line& line = acache.find (acache.addr_to_tag (addr), hit);
  if (hit && line.dirty_p ())
    (void) write_line (line);
d443 3
a445 4
  bool hit;
  cache_line& line = acache.find (acache.addr_to_tag (addr), hit);
  if (hit)
    line.invalidate ();
d451 2
a452 3
  bool hit;
  cache_line& line = acache.find (acache.addr_to_tag (addr), hit);
  if (hit && line.dirty_p ())
d454 2
a455 2
      (void) write_line (line);
      line.invalidate ();
d475 3
a477 4
  bool hit;
  cache_line& line = acache.find (acache.addr_to_tag (addr), hit);
  if (hit)
    line.lock ();
d483 3
a485 4
  bool hit;
  cache_line& line = acache.find (acache.addr_to_tag (addr), hit);
  if (hit)
    line.unlock ();
d602 2
a603 2
void
cache_replacement_fifo::replace (cache_set& cset, cache_line& old_line, cache_line new_line)
a627 4
	  old_line = line;
	  old_line.invalidate ();
	  cset.set_line (i, new_line);

d630 1
a630 1
	  return;
d634 2
d638 2
a639 2
void
cache_replacement_lru::replace (cache_set& cset, cache_line& old_line, cache_line new_line)
d661 2
a662 5
    return;
  
  old_line = cset.get_line (index);
  old_line.invalidate ();
  cset.set_line (index, new_line);
d664 1
d680 2
a681 2
void
cache_replacement_null::replace (cache_set& cset, cache_line& old_line, cache_line new_line)
d685 3
a687 5
    {
      old_line = line;
      old_line.invalidate ();
      cset.set_line (0, new_line);
    }
d690 2
a691 2
void
cache_replacement_random::replace (cache_set& cset, cache_line& old_line, cache_line new_line)
d697 1
a697 6
	{
	  old_line = line;
	  old_line.invalidate ();
	  cset.set_line (i, new_line);
	  return;
	}
d712 4
a715 11
	{
	  old_line = line;
	  old_line.invalidate ();
	  cset.set_line (i, new_line);
	  return;
	}
      else
	{
	  candidates[i] = false;
	  n--;
	}
d717 2
d766 1
a766 1
    return new cache_component (1, 16384, 32, null_replacement);
d769 1
a769 1
    return new cache_component (0, 8, 8, null_replacement);
d840 1
a840 1
    return new cache_component (assoc, cache_sz, line_sz, null_replacement);
d843 1
a843 1
    return new cache_component (assoc, cache_sz, line_sz, lru_replacement);
d845 1
a845 1
    return new cache_component (assoc, cache_sz, line_sz, fifo_replacement);
d847 1
a847 1
    return new cache_component (assoc, cache_sz, line_sz, random_replacement);
@


1.15
log
@2002-07-16  Dave Brolley  <brolley@@redhat.com>

	* cache.h (cache): Add flush_and_invalidate_set_pin and
	flush_and_invalidate_pin.
	* cache.cxx (cache_component): Initialize flush_and_invalidate_set_pin
	and flush_and_invalidate_pin. Add flush-and-invalidate and
	flush-and-invalidate-set pins.
	(flush_set): Don't flush an invalid line.
	(flush_and_invalidate_set): New method.
	(flush_and_invalidate_line): New method.
	* hw-cache.xml, hw-cache.txt: Modified accordingly.
@
text
@d75 2
a76 1
   refill_latency (0)
d143 5
a147 1
  add_attribute ("refill-latency", &refill_latency, "setting");
d153 2
d352 6
a357 1
  st.latency = refill_latency + overall_latency;
d542 15
@


1.14
log
@2002-06-08  Ben Elliston  <bje@@redhat.com>

	* cacheutil.h (cache_set::expunge): New method.
	(cache_set::operator[]): Likewise.
	(cache::invalidate): Likewise.
	(cache::operator[]): Likewise.
	* cacheutil.cxx (cache::invalidate): Implement.
	* cache.h (cache_component::flush_set_pin): New pin.
	(cache_component::flush_set): New callback method.
	(cache_component::invalidate_set_pin): New pin.
	(cache_component::invalidate_set): New method.
	* cache.cxx (cache_component constructor): Initialise and add
	"flush-set" and "invalidate-set" pins.
	(cache_component::flush_set): Implement.
	(cache_component::invalidate_set): Likewise.
	* hw-cache.xml: Update documentation.
@
text
@d58 1
d62 1
d88 1
d90 1
d398 1
a398 1
      if (line.dirty_p ())
d404 18
d434 12
@


1.13
log
@2002-05-17  Ben Elliston  <bje@@redhat.com>

	* Makefile.am (DEJAGNUTESTS): Add refill.exp.
	* cache.h (cache_component::refill_latency): New member.
	* cache.cxx (cache_component::read_line): Add refill latency.
	(cache_component::cache_component): Initialise it and add a
	corresponding "refill-latency" attribute.
	* hw-cache.xml (memory latency) : Document refill latency.
@
text
@d57 1
d60 1
d82 1
d85 1
d385 15
d412 6
@


1.12
log
@2002-04-09  Ben Elliston  <bje@@redhat.com>

	* cache.cxx (cache_component::read_line): Set the overall latency
	for a cache line fill to the latency of the first downstream read,
	not the last.
@
text
@d3 1
a3 1
// Copyright (C) 2001 Red Hat.
d70 2
a71 1
   miss_latency (0)
d134 1
d327 1
a327 1
      // Latency for line fills is the latency of the first read
d337 1
a337 1
  st.latency = overall_latency;
@


1.11
log
@2001-12-27  Frank Ch. Eigler  <fche@@redhat.com>

	* cache.cxx (CacheListTypes, CacheCreate): Support hw-cache-buffer-8
	component type.
	* hw-cache.xml, hw-cache.txt: Modified accordingly.
@
text
@d319 1
d325 3
d335 1
@


1.10
log
@2001-12-27  Frank Ch. Eigler  <fche@@redhat.com>

	* cache.cxx (cache_sizes): Add "1" and "2" kb support.
	* hw-cache.xml, hw-cache.txt: Modified accordingly.
@
text
@d657 1
d693 3
@


1.9
log
@2001-12-04  Frank Ch. Eigler  <fche@@redhat.com>

        * cache.cxx (cache_sizes): Add "4" for "4kb".
        * hw-cache.xml, hw-cache.txt: Modified accordingly.
@
text
@d33 1
a33 1
  { "4", "8", "16", "32", "64", "128", "256", "512" };
@


1.8
log
@* function ++, cleanup

2001-10-22  Frank Ch. Eigler  <fche@@redhat.com>

	* cache.cxx (flush_all): New function.  Associate with "flush-all" pin.
	* cacheutil.cxx (find_any_dirty): New functions.
	* cache.h, cacheutil.h: Relevant changes.
	Warning cleanups throughout.
	* hw-cache.xml (flush-all): Document new pin.
	* hw-cache-txt: Regenerated.
@
text
@d33 1
a33 1
  { "8", "16", "32", "64", "128", "256", "512" };
@


1.7
log
@* bug fix

2001-09-27  Frank Ch. Eigler  <fche@@redhat.com>

	* cache.cxx (emit_report): Remove extra blank line.
	(set_hash_mask, set_hash_shift): Exchange names to match functionality.
	* cacheutil.cxx (cache ctor): Compute good default hash_params.
@
text
@d51 5
a55 1
  :report_pin (this, &cache_component::emit_report),
a63 2
   downstream (0),
   upstream (*this),
d65 1
d69 2
a70 2
   report_heading ("cache profile report"),
   acache (cache_sz, line_sz, assocy, replacer)
d78 1
d354 11
d370 1
a370 1
    bus::status st = write_line (line);
d392 1
a392 1
  bus::status st = read_any (addr, dummy);
d553 1
a553 1
  int oldest;
d557 1
a557 1
  for (unsigned i = 0, oldest = 0; i < cset.num_lines (); i++)
d658 3
a660 3
  for (int i = 0; i < (sizeof (assocs) / sizeof (string)); i++)
    for (int j = 0; j < (sizeof (cache_sizes) / sizeof (string)); j++)
      for (int k = 0; k < (sizeof (line_sizes) / sizeof (string)); k++)
d670 1
a670 1
	    for (int m = 0;
d687 1
a687 1
  int i;
@


1.6
log
@* build fix

[e.g., cache/ChangeLog]
2001-08-04  Frank Ch. Eigler  <fche@@redhat.com>

	* cache.cxx (~cache_component): Define.
@
text
@d401 1
a401 1
  cout << report_heading << endl << endl
d423 1
a423 1
cache_component::set_hash_mask (const string& value)
d438 1
a438 1
cache_component::set_hash_shift (const string& value)
@


1.5
log
@2001-07-09  Ben Elliston  <bje@@redhat.com>

	* cache.cxx: Use std::cout and std::endl for C++ conformance.
@
text
@d133 7
@


1.4
log
@2001-06-24  Ben Elliston  <bje@@redhat.com>

	* cache.cxx (set_hash_mask): Validate parse_attribute result.
	(set_hash_shift): Ditto.
@
text
@d24 3
@


1.3
log
@2001-06-21  Ben Elliston  <bje@@redhat.com>

	* cache.h (cache_component::hit_latency): New member.
	(cache_component::miss_latency): Likewise.
	* cache.cxx (cache_component ctor): Add attributes for these.
	(cache_component::write_any): Add miss latency for misaligned
	accesses. Set latency correctly for return.
	(cache_component::read_any): Add miss latency for misaligned
	accesses. Set latency correctly for return.
	(cache_component::read_line): Return the true result of reads.
	(cache_component::write_line): Likewise for writes.
	* hw-cache.txt: Document latency extensions.
@
text
@d416 3
a418 1
  parse_attribute (value, shift);
d431 3
a433 1
  parse_attribute (value, mask);
@


1.2
log
@2001-06-19  Ben Elliston  <bje@@redhat.com>

	* cache.cxx (CacheCreate): Re-work using sidutil::tokenize.
@
text
@d124 3
d141 1
a141 1
  bus::status st;
d166 4
a169 1
      return downstream->read (addr, data);
d192 2
a193 2
	      if ((st = read_line (new_line)) != bus::ok)
		return st;
d222 7
a228 1
  return bus::ok;
d235 2
d248 4
a251 1
      return downstream->read (addr, data);
a254 2
  bus::status st;

d269 3
a271 3
	  
	  if ((st = read_line (new_line)) != bus::ok)
	    return st;
a272 1

d282 1
a282 1
		return st;
d286 5
a290 1
	return downstream->read (addr, data);
d292 7
a298 1
  return bus::ok;
d304 1
d309 1
a309 1
      bus::status st = downstream->read (base + offset, data);
d317 1
a317 1
  return bus::ok;
d323 1
d329 1
a329 1
      bus::status st = downstream->write (base + offset, data);
d336 1
a336 1
  return bus::ok;
@


1.1
log
@Index: component/ChangeLog
2001-06-12  Ben Elliston  <bje@@redhat.com>

	* CATALOG: Add hw-cache-basic and friends.
	* configure.in (make_subdirs): Add cache.
	* configure: Regenerate.
	* Makefile.in: Ditto.

Index: component/cache/ChangeLog
2001-06-15  Ben Elliston  <bje@@redhat.com>

	* cache.cxx: New file.
	* cache.h: Likewise.
	* cacheutil.cxx: Likewise.
	* cacheutil.h: Likewise.
	* log2.h: Likewise.
	* hw-cache.txt: Likewise.

Index: component/testsuite/ChangeLog
2001-06-05  Ben Elliston  <bje@@redhat.com>

	* Makefile.am: New file.
	* Makefile.in: Generate.

2001-06-15  Ben Elliston  <bje@@redhat.com>

	* sidcomp.cache/cache.exp: New test case.
	* sidcomp.cache/cachedocs.exp: Ditto.
	* sidcomp.cache/cachemonkey.exp: Ditto.
	* sidcomp.cache/coherency.exp: Ditto.
	* sidcomp.cache/fifo.exp: Ditto.
	* sidcomp.cache/flush.exp: Ditto.
	* sidcomp.cache/lock.exp: Ditto.
	* sidcomp.cache/lru.exp: Ditto.
	* sidcomp.cache/misaligned.exp: Ditto.
	* sidcomp.cache/prefetch.exp: Ditto.
	* sidcomp.cache/random.exp: Ditto.
	* sidcomp.cache/types.exp: Ditto.
	* sidcomp.cache/utils.exp: Ditto.
	* sidcomp.cache/writealloc.exp: Ditto.
	* sidcomp.cache/writethru.exp: Ditto.
@
text
@d15 1
d632 1
a633 2
  int i, index = 0, pos;
  int assoc, linesz, cachesz;
d637 2
d640 1
a640 1
  if (typeName.find ("hw-cache-", index) != 0)
a641 1
  index += strlen ("hw-cache-");
d643 1
a643 32
  // parse assoc + "/"
  if ((pos = typeName.find_first_of ("/", index)) == string::npos)
    return 0;
  string assoc_string = typeName.substr (index, (pos - index));
  index = pos + 1;

  string cache_size_string;

  // Parse "<x>kb", where <x> is a positive integer. 
  if ((pos = typeName.find_first_of ("/", index)) == string::npos)
    return 0;
  cache_size_string = typeName.substr (index, (pos - index));
  index = pos + 1;

  if ((pos = cache_size_string.find ("kb", 0)) == string::npos)
    return 0;
  cache_size_string.erase (pos, cache_size_string.length () - pos);

  string line_size_string;
  string replace_alg_string;

  if (assoc_string == "direct")
    line_size_string = typeName.substr (index, (typeName.length () - index));
  else
    {
      if ((pos = typeName.find_first_of ("/", index)) == string::npos)
	return 0;
      line_size_string = typeName.substr (index, (pos - index));
      index = pos + 1;
      replace_alg_string = typeName.substr (index, (typeName.length () - index));
    }

d645 1
a645 1
    if (assoc_string == assocs[i]) 
d647 1
d650 4
a653 1

d657 1
a657 1
	cachesz = atoi (cache_size_string.c_str ()) * 1024;
d660 1
d664 2
d669 1
a669 1
	linesz = atoi (line_size_string.c_str ());
d672 1
d676 1
d678 6
a683 4
    {
      for (match = false, i = 0;
	   i < sizeof (replacement_algorithms) / sizeof (string); i++)
	{
d686 6
a691 5
	}
      if (!match)
	return 0;
    }

d698 1
d707 2
a708 2
    return new cache_component (assoc, cachesz, linesz, null_replacement);

d710 1
a710 1
    return new cache_component (assoc, cachesz, linesz, lru_replacement);
d712 1
a712 1
    return new cache_component (assoc, cachesz, linesz, fifo_replacement);
d714 1
a714 1
    return new cache_component (assoc, cachesz, linesz, random_replacement);
@

