head	1.1;
access;
symbols
	sid-snapshot-20180601:1.1
	sid-snapshot-20180501:1.1
	sid-snapshot-20180401:1.1
	sid-snapshot-20180301:1.1
	sid-snapshot-20180201:1.1
	sid-snapshot-20180101:1.1
	sid-snapshot-20171201:1.1
	sid-snapshot-20171101:1.1
	sid-snapshot-20171001:1.1
	sid-snapshot-20170901:1.1
	sid-snapshot-20170801:1.1
	sid-snapshot-20170701:1.1
	sid-snapshot-20170601:1.1
	sid-snapshot-20170501:1.1
	sid-snapshot-20170401:1.1
	sid-snapshot-20170301:1.1
	sid-snapshot-20170201:1.1
	sid-snapshot-20170101:1.1
	sid-snapshot-20161201:1.1
	sid-snapshot-20161101:1.1
	sid-snapshot-20160901:1.1
	sid-snapshot-20160801:1.1
	sid-snapshot-20160701:1.1
	sid-snapshot-20160601:1.1
	sid-snapshot-20160501:1.1
	sid-snapshot-20160401:1.1
	sid-snapshot-20160301:1.1
	sid-snapshot-20160201:1.1
	sid-snapshot-20160101:1.1
	sid-snapshot-20151201:1.1
	sid-snapshot-20151101:1.1
	sid-snapshot-20151001:1.1
	sid-snapshot-20150901:1.1
	sid-snapshot-20150801:1.1
	sid-snapshot-20150701:1.1
	sid-snapshot-20150601:1.1
	sid-snapshot-20150501:1.1
	sid-snapshot-20150401:1.1
	sid-snapshot-20150301:1.1
	sid-snapshot-20150201:1.1
	sid-snapshot-20150101:1.1
	sid-snapshot-20141201:1.1
	sid-snapshot-20141101:1.1
	sid-snapshot-20141001:1.1
	sid-snapshot-20140901:1.1
	sid-snapshot-20140801:1.1
	sid-snapshot-20140701:1.1
	sid-snapshot-20140601:1.1
	sid-snapshot-20140501:1.1
	sid-snapshot-20140401:1.1
	sid-snapshot-20140301:1.1
	sid-snapshot-20140201:1.1
	sid-snapshot-20140101:1.1
	sid-snapshot-20131201:1.1
	sid-snapshot-20131101:1.1
	sid-snapshot-20131001:1.1
	sid-snapshot-20130901:1.1
	sid-snapshot-20130801:1.1
	sid-snapshot-20130701:1.1
	sid-snapshot-20130601:1.1
	sid-snapshot-20130501:1.1
	sid-snapshot-20130401:1.1
	sid-snapshot-20130301:1.1
	sid-snapshot-20130201:1.1
	sid-snapshot-20130101:1.1
	sid-snapshot-20121201:1.1
	sid-snapshot-20121101:1.1
	sid-snapshot-20121001:1.1
	sid-snapshot-20120901:1.1
	sid-snapshot-20120801:1.1
	sid-snapshot-20120701:1.1
	sid-snapshot-20120601:1.1
	sid-snapshot-20120501:1.1
	sid-snapshot-20120401:1.1
	sid-snapshot-20120301:1.1
	sid-snapshot-20120201:1.1
	sid-snapshot-20120101:1.1
	sid-snapshot-20111201:1.1
	sid-snapshot-20111101:1.1
	sid-snapshot-20111001:1.1
	sid-snapshot-20110901:1.1
	sid-snapshot-20110801:1.1
	sid-snapshot-20110701:1.1
	sid-snapshot-20110601:1.1
	sid-snapshot-20110501:1.1
	sid-snapshot-20110401:1.1
	sid-snapshot-20110301:1.1
	sid-snapshot-20110201:1.1
	sid-snapshot-20110101:1.1
	sid-snapshot-20101201:1.1
	sid-snapshot-20101101:1.1
	sid-snapshot-20101001:1.1
	sid-snapshot-20100901:1.1
	sid-snapshot-20100801:1.1
	sid-snapshot-20100701:1.1
	sid-snapshot-20100601:1.1
	sid-snapshot-20100501:1.1
	sid-snapshot-20100401:1.1
	sid-snapshot-20100301:1.1
	sid-snapshot-20100201:1.1
	sid-snapshot-20100101:1.1
	sid-snapshot-20091201:1.1
	sid-snapshot-20091101:1.1
	sid-snapshot-20091001:1.1
	sid-snapshot-20090901:1.1
	sid-snapshot-20090801:1.1
	sid-snapshot-20090701:1.1
	sid-snapshot-20090601:1.1
	sid-snapshot-20090501:1.1
	sid-snapshot-20090401:1.1
	sid-snapshot-20090301:1.1
	sid-snapshot-20090201:1.1
	sid-snapshot-20090101:1.1
	sid-snapshot-20081201:1.1
	sid-snapshot-20081101:1.1
	sid-snapshot-20081001:1.1
	sid-snapshot-20080901:1.1
	sid-snapshot-20080801:1.1
	sid-snapshot-20080701:1.1
	sid-snapshot-20080601:1.1
	sid-snapshot-20080501:1.1
	sid-snapshot-20080403:1.1
	sid-snapshot-20080401:1.1
	sid-snapshot-20080301:1.1
	sid-snapshot-20080201:1.1
	sid-snapshot-20080101:1.1
	sid-snapshot-20071201:1.1
	sid-snapshot-20071101:1.1
	sid-snapshot-20071001:1.1
	sid-20020905-branchpoint:1.1
	sid-20020905-branch:1.1.0.2
	cygnus_cvs_20020108_pre:1.1;
locks; strict;
comment	@// @;


1.1
date	2001.11.27.22.59.00;	author fitzsim;	state Exp;
branches;
next	;


desc
@@


1.1
log
@	Changes to many generated files -- incorporate bochs into
	build system and configrun-sid.
@
text
@//  Copyright (C) 2001  MandrakeSoft S.A.
//
//    MandrakeSoft S.A.
//    43, rue d'Aboukir
//    75002 Paris - France
//    http://www.linux-mandrake.com/
//    http://www.mandrakesoft.com/
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA




#define NEED_CPU_REG_SHORTCUTS 1
#include "bochs.h"
#define LOG_THIS BX_CPU_THIS_PTR







  Boolean
BX_CPU_C::get_CF(void)
{
  switch ( BX_CPU_THIS_PTR lf_flags_status & 0x00000f ) {
    case BX_LF_INDEX_KNOWN:
      return(BX_CPU_THIS_PTR eflags.cf);

    case BX_LF_INDEX_OSZAPC:
      switch (BX_CPU_THIS_PTR oszapc.instr) {
        case BX_INSTR_ADD8:
        case BX_INSTR_XADD8:
          BX_CPU_THIS_PTR eflags.cf = (BX_CPU_THIS_PTR oszapc.result_8 <
                              BX_CPU_THIS_PTR oszapc.op1_8);
          break;
        case BX_INSTR_ADD16:
        case BX_INSTR_XADD16:
          BX_CPU_THIS_PTR eflags.cf = (BX_CPU_THIS_PTR oszapc.result_16 <
                              BX_CPU_THIS_PTR oszapc.op1_16);
          break;
        case BX_INSTR_ADD32:
        case BX_INSTR_XADD32:
          BX_CPU_THIS_PTR eflags.cf = (BX_CPU_THIS_PTR oszapc.result_32 <
                              BX_CPU_THIS_PTR oszapc.op1_32);
          break;
        case BX_INSTR_ADC8:
          BX_CPU_THIS_PTR eflags.cf =
            (BX_CPU_THIS_PTR oszapc.result_8 <
             BX_CPU_THIS_PTR oszapc.op1_8) ||
            (BX_CPU_THIS_PTR oszapc.prev_CF &&
             BX_CPU_THIS_PTR oszapc.result_8 ==
             BX_CPU_THIS_PTR oszapc.op1_8);
          break;
        case BX_INSTR_ADC16:
          BX_CPU_THIS_PTR eflags.cf =
            (BX_CPU_THIS_PTR oszapc.result_16 <
             BX_CPU_THIS_PTR oszapc.op1_16) ||
            (BX_CPU_THIS_PTR oszapc.prev_CF &&
             BX_CPU_THIS_PTR oszapc.result_16 ==
             BX_CPU_THIS_PTR oszapc.op1_16);
          break;
        case BX_INSTR_ADC32:
          BX_CPU_THIS_PTR eflags.cf =
            (BX_CPU_THIS_PTR oszapc.result_32 <
             BX_CPU_THIS_PTR oszapc.op1_32) ||
            (BX_CPU_THIS_PTR oszapc.prev_CF &&
             BX_CPU_THIS_PTR oszapc.result_32 ==
             BX_CPU_THIS_PTR oszapc.op1_32);
          break;
        case BX_INSTR_SUB8:
        case BX_INSTR_CMP8:
        case BX_INSTR_CMPS8:
        case BX_INSTR_SCAS8:
          BX_CPU_THIS_PTR eflags.cf = (BX_CPU_THIS_PTR oszapc.op1_8 <
                              BX_CPU_THIS_PTR oszapc.op2_8);
          break;
        case BX_INSTR_SUB16:
        case BX_INSTR_CMP16:
        case BX_INSTR_CMPS16:
        case BX_INSTR_SCAS16:
          BX_CPU_THIS_PTR eflags.cf = (BX_CPU_THIS_PTR oszapc.op1_16 <
                              BX_CPU_THIS_PTR oszapc.op2_16);
          break;
        case BX_INSTR_SUB32:
        case BX_INSTR_CMP32:
        case BX_INSTR_CMPS32:
        case BX_INSTR_SCAS32:
          BX_CPU_THIS_PTR eflags.cf = (BX_CPU_THIS_PTR oszapc.op1_32 <
                              BX_CPU_THIS_PTR oszapc.op2_32);
          break;
        case BX_INSTR_SBB8:
          BX_CPU_THIS_PTR eflags.cf =
            (BX_CPU_THIS_PTR oszapc.op1_8 <
             BX_CPU_THIS_PTR oszapc.result_8) ||
            ((BX_CPU_THIS_PTR oszapc.op2_8==0xff) &&
             BX_CPU_THIS_PTR oszapc.prev_CF);
          break;
        case BX_INSTR_SBB16:
          BX_CPU_THIS_PTR eflags.cf =
            (BX_CPU_THIS_PTR oszapc.op1_16 <
             BX_CPU_THIS_PTR oszapc.result_16) ||
            ((BX_CPU_THIS_PTR oszapc.op2_16==0xffff) &&
             BX_CPU_THIS_PTR oszapc.prev_CF);
          break;
        case BX_INSTR_SBB32:
          BX_CPU_THIS_PTR eflags.cf =
            (BX_CPU_THIS_PTR oszapc.op1_32 <
             BX_CPU_THIS_PTR oszapc.result_32) ||
            ((BX_CPU_THIS_PTR oszapc.op2_32==0xffffffff) &&
             BX_CPU_THIS_PTR oszapc.prev_CF);
          break;
        case BX_INSTR_NEG8:
          BX_CPU_THIS_PTR eflags.cf =
            BX_CPU_THIS_PTR oszapc.op1_8 != 0;
          break;
        case BX_INSTR_NEG16:
          BX_CPU_THIS_PTR eflags.cf =
            BX_CPU_THIS_PTR oszapc.op1_16 != 0;
          break;
        case BX_INSTR_NEG32:
          BX_CPU_THIS_PTR eflags.cf =
            BX_CPU_THIS_PTR oszapc.op1_32 != 0;
          break;
        case BX_INSTR_OR8:
        case BX_INSTR_OR16:
        case BX_INSTR_OR32:
        case BX_INSTR_AND8:
        case BX_INSTR_AND16:
        case BX_INSTR_AND32:
        case BX_INSTR_TEST8:
        case BX_INSTR_TEST16:
        case BX_INSTR_TEST32:
        case BX_INSTR_XOR8:
        case BX_INSTR_XOR16:
        case BX_INSTR_XOR32:
          BX_CPU_THIS_PTR eflags.cf = 0;
          break;
        case BX_INSTR_SHR8:
          BX_CPU_THIS_PTR eflags.cf =
            (BX_CPU_THIS_PTR oszapc.op1_8 >>
              (BX_CPU_THIS_PTR oszapc.op2_8 - 1)) & 0x01;
          break;
        case BX_INSTR_SHR16:
          BX_CPU_THIS_PTR eflags.cf =
            (BX_CPU_THIS_PTR oszapc.op1_16 >>
              (BX_CPU_THIS_PTR oszapc.op2_16 - 1)) & 0x01;
          break;
        case BX_INSTR_SHR32:
          BX_CPU_THIS_PTR eflags.cf =
            (BX_CPU_THIS_PTR oszapc.op1_32 >>
              (BX_CPU_THIS_PTR oszapc.op2_32 - 1)) & 0x01;
          break;
        case BX_INSTR_SHL8:
          if (BX_CPU_THIS_PTR oszapc.op2_8 <= 8) {
            BX_CPU_THIS_PTR eflags.cf =
              (BX_CPU_THIS_PTR oszapc.op1_8 >>
                (8 - BX_CPU_THIS_PTR oszapc.op2_8)) & 0x01;
            }
          else {
            BX_CPU_THIS_PTR eflags.cf = 0;
            }
          break;
        case BX_INSTR_SHL16:
          if (BX_CPU_THIS_PTR oszapc.op2_16 <= 16) {
            BX_CPU_THIS_PTR eflags.cf =
              (BX_CPU_THIS_PTR oszapc.op1_16 >>
                (16 - BX_CPU_THIS_PTR oszapc.op2_16)) & 0x01;
            }
          else {
            BX_CPU_THIS_PTR eflags.cf = 0;
            }
          break;
        case BX_INSTR_SHL32:
          BX_CPU_THIS_PTR eflags.cf =
            (BX_CPU_THIS_PTR oszapc.op1_32 >>
              (32 - BX_CPU_THIS_PTR oszapc.op2_32)) & 0x01;
          break;
        default:
          BX_PANIC(("get_CF: OSZAPC: unknown instr %u\n",
            (unsigned) BX_CPU_THIS_PTR oszapc.instr));
        }
      BX_CPU_THIS_PTR lf_flags_status &= 0xfffff0;
      return(BX_CPU_THIS_PTR eflags.cf);

    default:
      BX_PANIC(("get_CF: unknown case\n"));
      return(0);
    }
}


  Boolean
BX_CPU_C::get_AF(void)
{
  switch ( (BX_CPU_THIS_PTR lf_flags_status>>8) & 0x00000f ) {
    case BX_LF_INDEX_KNOWN:
      return(BX_CPU_THIS_PTR eflags.af);

    case BX_LF_INDEX_OSZAPC:
      switch (BX_CPU_THIS_PTR oszapc.instr) {
        case BX_INSTR_ADD8:
        case BX_INSTR_ADC8:
        case BX_INSTR_SUB8:
        case BX_INSTR_SBB8:
        case BX_INSTR_CMP8:
        case BX_INSTR_XADD8:
        case BX_INSTR_CMPS8:
        case BX_INSTR_SCAS8:
          BX_CPU_THIS_PTR eflags.af =
            ((BX_CPU_THIS_PTR oszapc.op1_8 ^
              BX_CPU_THIS_PTR oszapc.op2_8) ^
             BX_CPU_THIS_PTR oszapc.result_8) & 0x10;
          break;
        case BX_INSTR_ADD16:
        case BX_INSTR_ADC16:
        case BX_INSTR_SUB16:
        case BX_INSTR_SBB16:
        case BX_INSTR_CMP16:
        case BX_INSTR_XADD16:
        case BX_INSTR_CMPS16:
        case BX_INSTR_SCAS16:
          BX_CPU_THIS_PTR eflags.af =
            ((BX_CPU_THIS_PTR oszapc.op1_16 ^
              BX_CPU_THIS_PTR oszapc.op2_16) ^
             BX_CPU_THIS_PTR oszapc.result_16) & 0x10;
          break;
        case BX_INSTR_ADD32:
        case BX_INSTR_ADC32:
        case BX_INSTR_SUB32:
        case BX_INSTR_SBB32:
        case BX_INSTR_CMP32:
        case BX_INSTR_XADD32:
        case BX_INSTR_CMPS32:
        case BX_INSTR_SCAS32:
          BX_CPU_THIS_PTR eflags.af =
            ((BX_CPU_THIS_PTR oszapc.op1_32 ^
              BX_CPU_THIS_PTR oszapc.op2_32) ^
             BX_CPU_THIS_PTR oszapc.result_32) & 0x10;
          break;
        case BX_INSTR_NEG8:
          BX_CPU_THIS_PTR eflags.af =
            (BX_CPU_THIS_PTR oszapc.op1_8 & 0x0f) > 0;
          break;
        case BX_INSTR_NEG16:
          BX_CPU_THIS_PTR eflags.af =
            (BX_CPU_THIS_PTR oszapc.op1_16 & 0x0f) > 0;
          break;
        case BX_INSTR_NEG32:
          BX_CPU_THIS_PTR eflags.af =
            (BX_CPU_THIS_PTR oszapc.op1_32 & 0x0f) > 0;
          break;
        case BX_INSTR_OR8:
        case BX_INSTR_OR16:
        case BX_INSTR_OR32:
        case BX_INSTR_AND8:
        case BX_INSTR_AND16:
        case BX_INSTR_AND32:
        case BX_INSTR_TEST8:
        case BX_INSTR_TEST16:
        case BX_INSTR_TEST32:
        case BX_INSTR_XOR8:
        case BX_INSTR_XOR16:
        case BX_INSTR_XOR32:
        case BX_INSTR_SHR8:
        case BX_INSTR_SHR16:
        case BX_INSTR_SHR32:
        case BX_INSTR_SHL8:
        case BX_INSTR_SHL16:
        case BX_INSTR_SHL32:
          BX_CPU_THIS_PTR eflags.af = 0;
          /* undefined */
          break;
        default:
          BX_PANIC(("get_AF: OSZAPC: unknown instr %u\n",
            (unsigned) BX_CPU_THIS_PTR oszapc.instr));
        }
      BX_CPU_THIS_PTR lf_flags_status &= 0xfff0ff;
      return(BX_CPU_THIS_PTR eflags.af);

    case BX_LF_INDEX_OSZAP:
      switch (BX_CPU_THIS_PTR oszap.instr) {
        case BX_INSTR_INC8:
          BX_CPU_THIS_PTR eflags.af =
            (BX_CPU_THIS_PTR oszap.result_8 & 0x0f) == 0;
          break;
        case BX_INSTR_INC16:
          BX_CPU_THIS_PTR eflags.af =
            (BX_CPU_THIS_PTR oszap.result_16 & 0x0f) == 0;
          break;
        case BX_INSTR_INC32:
          BX_CPU_THIS_PTR eflags.af =
            (BX_CPU_THIS_PTR oszap.result_32 & 0x0f) == 0;
          break;
        case BX_INSTR_DEC8:
          BX_CPU_THIS_PTR eflags.af =
            (BX_CPU_THIS_PTR oszap.result_8 & 0x0f) == 0x0f;
          break;
        case BX_INSTR_DEC16:
          BX_CPU_THIS_PTR eflags.af =
            (BX_CPU_THIS_PTR oszap.result_16 & 0x0f) == 0x0f;
          break;
        case BX_INSTR_DEC32:
          BX_CPU_THIS_PTR eflags.af =
            (BX_CPU_THIS_PTR oszap.result_32 & 0x0f) == 0x0f;
          break;
        default:
          BX_PANIC(("get_AF: OSZAP: unknown instr %u\n",
            (unsigned) BX_CPU_THIS_PTR oszap.instr));
        }
      BX_CPU_THIS_PTR lf_flags_status &= 0xfff0ff;
      return(BX_CPU_THIS_PTR eflags.af);

    default:
      BX_PANIC(("get_AF: unknown case\n"));
      return(0);
    }
}


  Boolean
BX_CPU_C::get_ZF(void)
{
  switch ( (BX_CPU_THIS_PTR lf_flags_status>>12) & 0x00000f ) {
    case BX_LF_INDEX_KNOWN:
      return(BX_CPU_THIS_PTR eflags.zf);

    case BX_LF_INDEX_OSZAPC:
      switch (BX_CPU_THIS_PTR oszapc.instr) {
        case BX_INSTR_ADD8:
        case BX_INSTR_ADC8:
        case BX_INSTR_SUB8:
        case BX_INSTR_SBB8:
        case BX_INSTR_CMP8:
        case BX_INSTR_NEG8:
        case BX_INSTR_XADD8:
        case BX_INSTR_OR8:
        case BX_INSTR_AND8:
        case BX_INSTR_TEST8:
        case BX_INSTR_XOR8:
        case BX_INSTR_CMPS8:
        case BX_INSTR_SCAS8:
        case BX_INSTR_SHR8:
        case BX_INSTR_SHL8:
          BX_CPU_THIS_PTR eflags.zf = (BX_CPU_THIS_PTR oszapc.result_8 == 0);
          break;
        case BX_INSTR_ADD16:
        case BX_INSTR_ADC16:
        case BX_INSTR_SUB16:
        case BX_INSTR_SBB16:
        case BX_INSTR_CMP16:
        case BX_INSTR_NEG16:
        case BX_INSTR_XADD16:
        case BX_INSTR_OR16:
        case BX_INSTR_AND16:
        case BX_INSTR_TEST16:
        case BX_INSTR_XOR16:
        case BX_INSTR_CMPS16:
        case BX_INSTR_SCAS16:
        case BX_INSTR_SHR16:
        case BX_INSTR_SHL16:
          BX_CPU_THIS_PTR eflags.zf = (BX_CPU_THIS_PTR oszapc.result_16 == 0);
          break;
        case BX_INSTR_ADD32:
        case BX_INSTR_ADC32:
        case BX_INSTR_SUB32:
        case BX_INSTR_SBB32:
        case BX_INSTR_CMP32:
        case BX_INSTR_NEG32:
        case BX_INSTR_XADD32:
        case BX_INSTR_OR32:
        case BX_INSTR_AND32:
        case BX_INSTR_TEST32:
        case BX_INSTR_XOR32:
        case BX_INSTR_CMPS32:
        case BX_INSTR_SCAS32:
        case BX_INSTR_SHR32:
        case BX_INSTR_SHL32:
          BX_CPU_THIS_PTR eflags.zf = (BX_CPU_THIS_PTR oszapc.result_32 == 0);
          break;
        default:
          BX_PANIC(("get_ZF: OSZAPC: unknown instr\n"));
        }
      BX_CPU_THIS_PTR lf_flags_status &= 0xff0fff;
      return(BX_CPU_THIS_PTR eflags.zf);

    case BX_LF_INDEX_OSZAP:
      switch (BX_CPU_THIS_PTR oszap.instr) {
        case BX_INSTR_INC8:
        case BX_INSTR_DEC8:
          BX_CPU_THIS_PTR eflags.zf = (BX_CPU_THIS_PTR oszap.result_8 == 0);
          break;
        case BX_INSTR_INC16:
        case BX_INSTR_DEC16:
          BX_CPU_THIS_PTR eflags.zf = (BX_CPU_THIS_PTR oszap.result_16 == 0);
          break;
        case BX_INSTR_INC32:
        case BX_INSTR_DEC32:
          BX_CPU_THIS_PTR eflags.zf = (BX_CPU_THIS_PTR oszap.result_32 == 0);
          break;
        default:
          BX_PANIC(("get_ZF: OSZAP: unknown instr\n"));
        }
      BX_CPU_THIS_PTR lf_flags_status &= 0xff0fff;
      return(BX_CPU_THIS_PTR eflags.zf);

    default:
      BX_PANIC(("get_ZF: unknown case\n"));
      return(0);
    }
}


  Boolean
BX_CPU_C::get_SF(void)
{
  switch ( (BX_CPU_THIS_PTR lf_flags_status>>16) & 0x00000f ) {
    case BX_LF_INDEX_KNOWN:
      return(BX_CPU_THIS_PTR eflags.sf);

    case BX_LF_INDEX_OSZAPC:
      switch (BX_CPU_THIS_PTR oszapc.instr) {
        case BX_INSTR_ADD8:
        case BX_INSTR_ADC8:
        case BX_INSTR_SUB8:
        case BX_INSTR_SBB8:
        case BX_INSTR_CMP8:
        case BX_INSTR_NEG8:
        case BX_INSTR_XADD8:
        case BX_INSTR_OR8:
        case BX_INSTR_AND8:
        case BX_INSTR_TEST8:
        case BX_INSTR_XOR8:
        case BX_INSTR_CMPS8:
        case BX_INSTR_SCAS8:
        case BX_INSTR_SHR8:
        case BX_INSTR_SHL8:
          BX_CPU_THIS_PTR eflags.sf =
            (BX_CPU_THIS_PTR oszapc.result_8 >= 0x80);
          break;
        case BX_INSTR_ADD16:
        case BX_INSTR_ADC16:
        case BX_INSTR_SUB16:
        case BX_INSTR_SBB16:
        case BX_INSTR_CMP16:
        case BX_INSTR_NEG16:
        case BX_INSTR_XADD16:
        case BX_INSTR_OR16:
        case BX_INSTR_AND16:
        case BX_INSTR_TEST16:
        case BX_INSTR_XOR16:
        case BX_INSTR_CMPS16:
        case BX_INSTR_SCAS16:
        case BX_INSTR_SHR16:
        case BX_INSTR_SHL16:
          BX_CPU_THIS_PTR eflags.sf =
            (BX_CPU_THIS_PTR oszapc.result_16 >= 0x8000);
          break;
        case BX_INSTR_ADD32:
        case BX_INSTR_ADC32:
        case BX_INSTR_SUB32:
        case BX_INSTR_SBB32:
        case BX_INSTR_CMP32:
        case BX_INSTR_NEG32:
        case BX_INSTR_XADD32:
        case BX_INSTR_OR32:
        case BX_INSTR_AND32:
        case BX_INSTR_TEST32:
        case BX_INSTR_XOR32:
        case BX_INSTR_CMPS32:
        case BX_INSTR_SCAS32:
        case BX_INSTR_SHR32:
        case BX_INSTR_SHL32:
          BX_CPU_THIS_PTR eflags.sf =
            (BX_CPU_THIS_PTR oszapc.result_32 >= 0x80000000);
          break;
        default:
          BX_PANIC(("get_SF: OSZAPC: unknown instr\n"));
        }
      BX_CPU_THIS_PTR lf_flags_status &= 0xf0ffff;
      return(BX_CPU_THIS_PTR eflags.sf);

    case BX_LF_INDEX_OSZAP:
      switch (BX_CPU_THIS_PTR oszap.instr) {
        case BX_INSTR_INC8:
        case BX_INSTR_DEC8:
          BX_CPU_THIS_PTR eflags.sf =
            (BX_CPU_THIS_PTR oszap.result_8 >= 0x80);
          break;
        case BX_INSTR_INC16:
        case BX_INSTR_DEC16:
          BX_CPU_THIS_PTR eflags.sf =
            (BX_CPU_THIS_PTR oszap.result_16 >= 0x8000);
          break;
        case BX_INSTR_INC32:
        case BX_INSTR_DEC32:
          BX_CPU_THIS_PTR eflags.sf =
            (BX_CPU_THIS_PTR oszap.result_32 >= 0x80000000);
          break;
        default:
          BX_PANIC(("get_SF: OSZAP: unknown instr\n"));
        }
      BX_CPU_THIS_PTR lf_flags_status &= 0xf0ffff;
      return(BX_CPU_THIS_PTR eflags.sf);

    default:
      BX_PANIC(("get_SF: unknown case\n"));
      return(0);
    }
}

  Boolean
BX_CPU_C::get_OF(void)
{
  Bit8u op1_b7, op2_b7, result_b7;
  Bit16u op1_b15, op2_b15, result_b15;
  Bit32u op1_b31, op2_b31, result_b31;

  switch ( (BX_CPU_THIS_PTR lf_flags_status>>20) & 0x00000f ) {
    case BX_LF_INDEX_KNOWN:
      return(BX_CPU_THIS_PTR eflags.of);

    case BX_LF_INDEX_OSZAPC:
      switch (BX_CPU_THIS_PTR oszapc.instr) {
        case BX_INSTR_ADD8:
        case BX_INSTR_ADC8:
        case BX_INSTR_XADD8:
          op1_b7 = BX_CPU_THIS_PTR oszapc.op1_8 & 0x80;
          op2_b7 = BX_CPU_THIS_PTR oszapc.op2_8 & 0x80;
          result_b7 = BX_CPU_THIS_PTR oszapc.result_8 & 0x80;

          BX_CPU_THIS_PTR eflags.of =  (op1_b7 == op2_b7) && (result_b7 ^ op2_b7);
          break;
        case BX_INSTR_ADD16:
        case BX_INSTR_ADC16:
        case BX_INSTR_XADD16:
          op1_b15 = BX_CPU_THIS_PTR oszapc.op1_16 & 0x8000;
          op2_b15 = BX_CPU_THIS_PTR oszapc.op2_16 & 0x8000;
          result_b15 = BX_CPU_THIS_PTR oszapc.result_16 & 0x8000;

          BX_CPU_THIS_PTR eflags.of =  (op1_b15 == op2_b15) && (result_b15 ^ op2_b15);
          break;
        case BX_INSTR_ADD32:
        case BX_INSTR_ADC32:
        case BX_INSTR_XADD32:
          op1_b31 = BX_CPU_THIS_PTR oszapc.op1_32 & 0x80000000;
          op2_b31 = BX_CPU_THIS_PTR oszapc.op2_32 & 0x80000000;
          result_b31 = BX_CPU_THIS_PTR oszapc.result_32 & 0x80000000;

          BX_CPU_THIS_PTR eflags.of =  (op1_b31 == op2_b31) && (result_b31 ^ op2_b31);
          break;
        case BX_INSTR_SUB8:
        case BX_INSTR_SBB8:
        case BX_INSTR_CMP8:
        case BX_INSTR_CMPS8:
        case BX_INSTR_SCAS8:
          op1_b7 = BX_CPU_THIS_PTR oszapc.op1_8 & 0x80;
          op2_b7 = BX_CPU_THIS_PTR oszapc.op2_8 & 0x80;
          result_b7 = BX_CPU_THIS_PTR oszapc.result_8 & 0x80;

          BX_CPU_THIS_PTR eflags.of =  (op1_b7 ^ op2_b7) && (op1_b7 ^ result_b7);
          break;
        case BX_INSTR_SUB16:
        case BX_INSTR_SBB16:
        case BX_INSTR_CMP16:
        case BX_INSTR_CMPS16:
        case BX_INSTR_SCAS16:
          op1_b15 = BX_CPU_THIS_PTR oszapc.op1_16 & 0x8000;
          op2_b15 = BX_CPU_THIS_PTR oszapc.op2_16 & 0x8000;
          result_b15 = BX_CPU_THIS_PTR oszapc.result_16 & 0x8000;

          BX_CPU_THIS_PTR eflags.of =  (op1_b15 ^ op2_b15) && (op1_b15 ^ result_b15);
          break;
        case BX_INSTR_SUB32:
        case BX_INSTR_SBB32:
        case BX_INSTR_CMP32:
        case BX_INSTR_CMPS32:
        case BX_INSTR_SCAS32:
          op1_b31 = BX_CPU_THIS_PTR oszapc.op1_32 & 0x80000000;
          op2_b31 = BX_CPU_THIS_PTR oszapc.op2_32 & 0x80000000;
          result_b31 = BX_CPU_THIS_PTR oszapc.result_32 & 0x80000000;

          BX_CPU_THIS_PTR eflags.of =  (op1_b31 ^ op2_b31) && (op1_b31 ^ result_b31);
          break;
        case BX_INSTR_NEG8:
          BX_CPU_THIS_PTR eflags.of =
            (BX_CPU_THIS_PTR oszapc.op1_8 == 0x80);
          break;
        case BX_INSTR_NEG16:
          BX_CPU_THIS_PTR eflags.of =
            (BX_CPU_THIS_PTR oszapc.op1_16 == 0x8000);
          break;
        case BX_INSTR_NEG32:
          BX_CPU_THIS_PTR eflags.of =
            (BX_CPU_THIS_PTR oszapc.op1_32 == 0x80000000);
          break;
        case BX_INSTR_OR8:
        case BX_INSTR_OR16:
        case BX_INSTR_OR32:
        case BX_INSTR_AND8:
        case BX_INSTR_AND16:
        case BX_INSTR_AND32:
        case BX_INSTR_TEST8:
        case BX_INSTR_TEST16:
        case BX_INSTR_TEST32:
        case BX_INSTR_XOR8:
        case BX_INSTR_XOR16:
        case BX_INSTR_XOR32:
          BX_CPU_THIS_PTR eflags.of = 0;
          break;
        case BX_INSTR_SHR8:
          if (BX_CPU_THIS_PTR oszapc.op2_8 == 1)
            BX_CPU_THIS_PTR eflags.of =
              (BX_CPU_THIS_PTR oszapc.op1_8 >= 0x80);
          break;
        case BX_INSTR_SHR16:
          if (BX_CPU_THIS_PTR oszapc.op2_16 == 1)
            BX_CPU_THIS_PTR eflags.of =
              (BX_CPU_THIS_PTR oszapc.op1_16 >= 0x8000);
          break;
        case BX_INSTR_SHR32:
          if (BX_CPU_THIS_PTR oszapc.op2_32 == 1)
            BX_CPU_THIS_PTR eflags.of =
              (BX_CPU_THIS_PTR oszapc.op1_32 >= 0x80000000);
          break;
        case BX_INSTR_SHL8:
          if (BX_CPU_THIS_PTR oszapc.op2_8 == 1)
            BX_CPU_THIS_PTR eflags.of =
              ((BX_CPU_THIS_PTR oszapc.op1_8 ^
                BX_CPU_THIS_PTR oszapc.result_8) & 0x80) > 0;
          break;
        case BX_INSTR_SHL16:
          if (BX_CPU_THIS_PTR oszapc.op2_16 == 1)
            BX_CPU_THIS_PTR eflags.of =
              ((BX_CPU_THIS_PTR oszapc.op1_16 ^
                BX_CPU_THIS_PTR oszapc.result_16) & 0x8000) > 0;
          break;
        case BX_INSTR_SHL32:
          if (BX_CPU_THIS_PTR oszapc.op2_32 == 1)
            BX_CPU_THIS_PTR eflags.of =
              ((BX_CPU_THIS_PTR oszapc.op1_32 ^
                BX_CPU_THIS_PTR oszapc.result_32) & 0x80000000) > 0;
          break;
        default:
          BX_PANIC(("get_OF: OSZAPC: unknown instr\n"));
        }
      BX_CPU_THIS_PTR lf_flags_status &= 0x0fffff;
      return(BX_CPU_THIS_PTR eflags.of);

    case BX_LF_INDEX_OSZAP:
      switch (BX_CPU_THIS_PTR oszap.instr) {
        case BX_INSTR_INC8:
          BX_CPU_THIS_PTR eflags.of =
            BX_CPU_THIS_PTR oszap.result_8 == 0x80;
          break;
        case BX_INSTR_INC16:
          BX_CPU_THIS_PTR eflags.of =
            BX_CPU_THIS_PTR oszap.result_16 == 0x8000;
          break;
        case BX_INSTR_INC32:
          BX_CPU_THIS_PTR eflags.of =
            BX_CPU_THIS_PTR oszap.result_32 == 0x80000000;
          break;
        case BX_INSTR_DEC8:
          BX_CPU_THIS_PTR eflags.of =
            BX_CPU_THIS_PTR oszap.result_8 == 0x7F;
          break;
        case BX_INSTR_DEC16:
          BX_CPU_THIS_PTR eflags.of =
            BX_CPU_THIS_PTR oszap.result_16 == 0x7FFF;
          break;
        case BX_INSTR_DEC32:
          BX_CPU_THIS_PTR eflags.of =
            BX_CPU_THIS_PTR oszap.result_32 == 0x7FFFFFFF;
          break;
        default:
          BX_PANIC(("get_OF: OSZAP: unknown instr\n"));
        }
      BX_CPU_THIS_PTR lf_flags_status &= 0x0fffff;
      return(BX_CPU_THIS_PTR eflags.of);

    default:
      BX_PANIC(("get_OF: unknown case\n"));
      return(0);
    }
}

  Boolean
BX_CPU_C::get_PF(void)
{
  switch ( (BX_CPU_THIS_PTR lf_flags_status>>4) & 0x00000f ) {
    case BX_LF_INDEX_KNOWN:
      return(BX_CPU_THIS_PTR lf_pf);
    case BX_LF_INDEX_OSZAPC:
      switch (BX_CPU_THIS_PTR oszapc.instr) {
        case BX_INSTR_ADD8:
        case BX_INSTR_ADC8:
        case BX_INSTR_SUB8:
        case BX_INSTR_SBB8:
        case BX_INSTR_CMP8:
        case BX_INSTR_NEG8:
        case BX_INSTR_XADD8:
        case BX_INSTR_OR8:
        case BX_INSTR_AND8:
        case BX_INSTR_TEST8:
        case BX_INSTR_XOR8:
        case BX_INSTR_CMPS8:
        case BX_INSTR_SCAS8:
        case BX_INSTR_SHR8:
        case BX_INSTR_SHL8:
          BX_CPU_THIS_PTR lf_pf =
            bx_parity_lookup[BX_CPU_THIS_PTR oszapc.result_8];
          break;
        case BX_INSTR_ADD16:
        case BX_INSTR_ADC16:
        case BX_INSTR_SUB16:
        case BX_INSTR_SBB16:
        case BX_INSTR_CMP16:
        case BX_INSTR_NEG16:
        case BX_INSTR_XADD16:
        case BX_INSTR_OR16:
        case BX_INSTR_AND16:
        case BX_INSTR_TEST16:
        case BX_INSTR_XOR16:
        case BX_INSTR_CMPS16:
        case BX_INSTR_SCAS16:
        case BX_INSTR_SHR16:
        case BX_INSTR_SHL16:
          BX_CPU_THIS_PTR lf_pf =
            bx_parity_lookup[(Bit8u) BX_CPU_THIS_PTR oszapc.result_16];
          break;
        case BX_INSTR_ADD32:
        case BX_INSTR_ADC32:
        case BX_INSTR_SUB32:
        case BX_INSTR_SBB32:
        case BX_INSTR_CMP32:
        case BX_INSTR_NEG32:
        case BX_INSTR_XADD32:
        case BX_INSTR_OR32:
        case BX_INSTR_AND32:
        case BX_INSTR_TEST32:
        case BX_INSTR_XOR32:
        case BX_INSTR_CMPS32:
        case BX_INSTR_SCAS32:
        case BX_INSTR_SHR32:
        case BX_INSTR_SHL32:
          BX_CPU_THIS_PTR lf_pf =
            bx_parity_lookup[(Bit8u) BX_CPU_THIS_PTR oszapc.result_32];
          break;
        default:
          BX_PANIC(("get_PF: OSZAPC: unknown instr\n"));
        }
      BX_CPU_THIS_PTR lf_flags_status &= 0xffff0f;
      return(BX_CPU_THIS_PTR lf_pf);

    case BX_LF_INDEX_OSZAP:
      switch (BX_CPU_THIS_PTR oszap.instr) {
        case BX_INSTR_INC8:
        case BX_INSTR_DEC8:
          BX_CPU_THIS_PTR lf_pf =
            bx_parity_lookup[BX_CPU_THIS_PTR oszap.result_8];
          break;
        case BX_INSTR_INC16:
        case BX_INSTR_DEC16:
          BX_CPU_THIS_PTR lf_pf =
            bx_parity_lookup[(Bit8u) BX_CPU_THIS_PTR oszap.result_16];
          break;
        case BX_INSTR_INC32:
        case BX_INSTR_DEC32:
          BX_CPU_THIS_PTR lf_pf =
            bx_parity_lookup[(Bit8u) BX_CPU_THIS_PTR oszap.result_32];
          break;
        default:
          BX_PANIC(("get_PF: OSZAP: unknown instr\n"));
        }
      BX_CPU_THIS_PTR lf_flags_status &= 0xffff0f;
      return(BX_CPU_THIS_PTR lf_pf);

    case BX_LF_INDEX_P:
      BX_CPU_THIS_PTR lf_pf = bx_parity_lookup[BX_CPU_THIS_PTR eflags.pf_byte];
      BX_CPU_THIS_PTR lf_flags_status &= 0xffff0f;
      return(BX_CPU_THIS_PTR lf_pf);

    default:
      BX_PANIC(("get_PF: unknown case\n"));
      return(0);
    }
}
@
