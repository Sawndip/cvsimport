head	1.15;
access;
symbols
	sid-snapshot-20180601:1.15
	sid-snapshot-20180501:1.15
	sid-snapshot-20180401:1.15
	sid-snapshot-20180301:1.15
	sid-snapshot-20180201:1.15
	sid-snapshot-20180101:1.15
	sid-snapshot-20171201:1.15
	sid-snapshot-20171101:1.15
	sid-snapshot-20171001:1.15
	sid-snapshot-20170901:1.15
	sid-snapshot-20170801:1.15
	sid-snapshot-20170701:1.15
	sid-snapshot-20170601:1.15
	sid-snapshot-20170501:1.15
	sid-snapshot-20170401:1.15
	sid-snapshot-20170301:1.15
	sid-snapshot-20170201:1.15
	sid-snapshot-20170101:1.15
	sid-snapshot-20161201:1.15
	sid-snapshot-20161101:1.15
	sid-snapshot-20160901:1.15
	sid-snapshot-20160801:1.15
	sid-snapshot-20160701:1.15
	sid-snapshot-20160601:1.15
	sid-snapshot-20160501:1.15
	sid-snapshot-20160401:1.15
	sid-snapshot-20160301:1.15
	sid-snapshot-20160201:1.15
	sid-snapshot-20160101:1.15
	sid-snapshot-20151201:1.15
	sid-snapshot-20151101:1.15
	sid-snapshot-20151001:1.15
	sid-snapshot-20150901:1.15
	sid-snapshot-20150801:1.15
	sid-snapshot-20150701:1.15
	sid-snapshot-20150601:1.15
	sid-snapshot-20150501:1.15
	sid-snapshot-20150401:1.15
	sid-snapshot-20150301:1.15
	sid-snapshot-20150201:1.15
	sid-snapshot-20150101:1.15
	sid-snapshot-20141201:1.15
	sid-snapshot-20141101:1.15
	sid-snapshot-20141001:1.15
	sid-snapshot-20140901:1.15
	sid-snapshot-20140801:1.15
	sid-snapshot-20140701:1.15
	sid-snapshot-20140601:1.15
	sid-snapshot-20140501:1.15
	sid-snapshot-20140401:1.15
	sid-snapshot-20140301:1.15
	sid-snapshot-20140201:1.15
	sid-snapshot-20140101:1.15
	sid-snapshot-20131201:1.15
	sid-snapshot-20131101:1.15
	sid-snapshot-20131001:1.15
	sid-snapshot-20130901:1.15
	sid-snapshot-20130801:1.15
	sid-snapshot-20130701:1.15
	sid-snapshot-20130601:1.15
	sid-snapshot-20130501:1.15
	sid-snapshot-20130401:1.15
	sid-snapshot-20130301:1.15
	sid-snapshot-20130201:1.15
	sid-snapshot-20130101:1.15
	sid-snapshot-20121201:1.15
	sid-snapshot-20121101:1.15
	sid-snapshot-20121001:1.15
	sid-snapshot-20120901:1.15
	sid-snapshot-20120801:1.15
	sid-snapshot-20120701:1.15
	sid-snapshot-20120601:1.15
	sid-snapshot-20120501:1.15
	sid-snapshot-20120401:1.15
	sid-snapshot-20120301:1.15
	sid-snapshot-20120201:1.15
	sid-snapshot-20120101:1.15
	sid-snapshot-20111201:1.15
	sid-snapshot-20111101:1.15
	sid-snapshot-20111001:1.15
	sid-snapshot-20110901:1.15
	sid-snapshot-20110801:1.15
	sid-snapshot-20110701:1.15
	sid-snapshot-20110601:1.15
	sid-snapshot-20110501:1.15
	sid-snapshot-20110401:1.15
	sid-snapshot-20110301:1.15
	sid-snapshot-20110201:1.15
	sid-snapshot-20110101:1.15
	sid-snapshot-20101201:1.15
	sid-snapshot-20101101:1.15
	sid-snapshot-20101001:1.15
	sid-snapshot-20100901:1.15
	sid-snapshot-20100801:1.15
	sid-snapshot-20100701:1.15
	sid-snapshot-20100601:1.15
	sid-snapshot-20100501:1.15
	sid-snapshot-20100401:1.15
	sid-snapshot-20100301:1.15
	sid-snapshot-20100201:1.15
	sid-snapshot-20100101:1.15
	sid-snapshot-20091201:1.15
	sid-snapshot-20091101:1.15
	sid-snapshot-20091001:1.15
	sid-snapshot-20090901:1.15
	sid-snapshot-20090801:1.15
	sid-snapshot-20090701:1.15
	sid-snapshot-20090601:1.15
	sid-snapshot-20090501:1.15
	sid-snapshot-20090401:1.15
	sid-snapshot-20090301:1.15
	sid-snapshot-20090201:1.15
	sid-snapshot-20090101:1.15
	sid-snapshot-20081201:1.15
	sid-snapshot-20081101:1.15
	sid-snapshot-20081001:1.15
	sid-snapshot-20080901:1.15
	sid-snapshot-20080801:1.15
	sid-snapshot-20080701:1.15
	sid-snapshot-20080601:1.15
	sid-snapshot-20080501:1.15
	sid-snapshot-20080403:1.15
	sid-snapshot-20080401:1.15
	sid-snapshot-20080301:1.15
	sid-snapshot-20080201:1.15
	sid-snapshot-20080101:1.15
	sid-snapshot-20071201:1.15
	sid-snapshot-20071101:1.15
	sid-snapshot-20071001:1.15
	sid-20020905-branchpoint:1.11
	sid-20020905-branch:1.11.0.2
	cygnus_cvs_20020108_pre:1.8;
locks; strict;
comment	@// @;


1.15
date	2006.03.01.21.07.01;	author fche;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.12.16.25.46;	author fche;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.14.19.06.21;	author brolley;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.11.22.28.28;	author fche;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.10.19.48.22;	author brolley;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.15.20.58.40;	author fche;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.12.18.03.18;	author fche;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.10.15.58.03;	author fche;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.26.21.12.02;	author fche;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.03.06.02.45;	author mrg;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.24.18.22.58;	author graydon;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.13.15.39.47;	author mrg;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.21.13.05.11;	author bje;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.01.19.15.34;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.07.19.30.55;	author fche;	state Exp;
branches;
next	;


desc
@@


1.15
log
@* DLLEXPORT decoration tweak, from Rex Sung-Tien Cho <song10@@andestech.com>
@
text
@// compMapper.cxx - a bus mapper component.  -*- C++ -*-

// Copyright (C) 1999-2003 Red Hat.
// This file is part of SID and is licensed under the GPL.
// See the file COPYING.SID for conditions for redistribution.

#include "config.h"

#include <sidcomp.h>
#include <sidso.h>
#include <sidtypes.h>
#include <sidcomputil.h>
#include <sidattrutil.h>
#include <sidpinutil.h>
#include <sidbusutil.h>
#include <sidmiscutil.h>

#include <vector>
#include <string>
#include <algorithm>
#include <functional>

#include <cstdlib>

using std::vector;
using std::string;
using std::ostream;
using std::istream;
using std::cout;
using std::cerr;
using std::endl;
using std::max;
using std::min;

using sid::component;
using sid::bus;
using sid::host_int_2;
using sid::host_int_4;
using sid::little_int_1;
using sid::little_int_2;
using sid::little_int_4;
using sid::little_int_8;
using sid::big_int_1;
using sid::big_int_2;
using sid::big_int_4;
using sid::big_int_8;
using sid::component_library;
using sid::COMPONENT_LIBRARY_MAGIC;

using sidutil::fixed_attribute_map_component;
using sidutil::no_relation_component;
using sidutil::fixed_pin_map_component;
using sidutil::fixed_bus_map_component;
using sidutil::make_numeric_attribute;
using sidutil::parse_attribute;
using sidutil::tokenize;
using sidutil::callback_pin;
using sidutil::attribute_coder_virtual_parameterized;


// ----------------------------------------------------------------------------


struct mapping_record
{
  host_int_4 mapped_base;       // Base of mapped address
  host_int_4 low, high;         // inclusive address range
  host_int_4 hit_count;         // number of accesses via this record
  bus* accessor;                // target bus

  host_int_2 bytes_per_word;    // how many bytes make up an address word. usually 1.
                                // multiply low, high, stride, width by this amount.
                                // note however that all bus communication still takes
                                // place in byte addresses. this just simplifies writing
                                // the mapping spec ([4,0x1010-0x1015] vs. [0x4040-0x4054])

  bool use_strideoffset_p;      // following fields valid?
  host_int_2 stride;	        // stride
  host_int_2 stride_shift;	// log2(stride)
  host_int_2 stride_mask;	// stride - 1
  host_int_2 offset;	        // offset
  host_int_2 width;	        // device access width
  host_int_2 width_shift;       // log2(width)

  string spec;                  // user-given specification string

  vector<host_int_4> banks;     // sorted list of bank #s in which this record is active
};


bool 
overlaps_p (const mapping_record& a, const mapping_record& b)
{
  // Reject disjoint banks
  vector<host_int_4> intersection (a.banks.size());
  vector<host_int_4>::iterator r = 
    set_intersection (a.banks.begin(), a.banks.end(),
		      b.banks.begin(), b.banks.end(),
		      intersection.begin());
  if (r == intersection.begin()) // empty intersection?
    return false;

  // I always rederive this little formula from first principles. 
  host_int_4 max_first = max(a.low, b.low);
  host_int_4 min_last = min(a.high, b.high);
  return (max_first <= min_last);
}


bool 
selected_p (const mapping_record& a, host_int_4 bank)
{
#if 0
  // This doesn't have to be fast, but since banks<> is kept sorted, might as well
  // use binary search.

  vector<host_int_4>::const_iterator where = 
    lower_bound (a.banks.begin (), a.banks.end (), bank);

  return (where != a.banks.end ());
#endif

  for (int i=0; i<a.banks.size(); i++)
    {
      if (a.banks[i] == bank) return true;
    }
  return false;
}



class mr_value_cmp: public std::binary_function<mapping_record, mapping_record, bool>
{
public:
  bool operator () (const mapping_record& a, const mapping_record& b) const
    {
      return (a.low < b.low); 
    }
};

class mr_ptr_cmp: public std::binary_function<mapping_record*, mapping_record*, bool>
{
public:
  bool operator () (const mapping_record* a, const mapping_record* b) const
    {
      return (a->low < b->low); 
    }
  
  bool operator () (const mapping_record* a, host_int_4 addr) const
    {
      return (a->high < addr); 
    }
  
  bool operator () (host_int_4 addr, const mapping_record* b) const
    {
      return (addr < b->low);
    }
};



// ------------------------------------------------------------------------


class generic_mapper;
class generic_mapper_bus: public bus
{
public:
  generic_mapper_bus (generic_mapper* target): target (target)
    {
      this->tlb1 = this->tlb2 = 0;
    }


  // The address lookup function - body below
  inline mapping_record* locate (host_int_4 address) const;

  template <class DataMaster, class DataSlave>
  inline bus::status
  write_strideoffset_any (host_int_4 address, const mapping_record* r,
			  DataMaster data, DataSlave)
    throw ();

  // Specialized read() for stride/offset slaves
  template <class DataMaster, class DataSlave>
  inline bus::status
  read_strideoffset_any (host_int_4 address, const mapping_record* r,
			 DataMaster& data, DataSlave) 
    throw ();

  // Generic write() & read()
  template <class Data>
  inline bus::status
  write_any (host_int_4 address, Data data) throw ();
  template <class Data>
  inline bus::status
  read_any (host_int_4 address, Data& data) throw ();


  // some macros to make manufacturing of the cartesian-product calls simpler
#define SID_GB_WRITE(Type) \
  bus::status write (host_int_4 address, Type data) throw () { return write_any (address,data); }
#define SID_GB_READ(Type) \
  bus::status read (host_int_4 address, Type& data) throw () { return read_any (address,data); }
  
  // -------------------------------------------------------------------

    SID_GB_WRITE(little_int_1);
    SID_GB_WRITE(little_int_2);
    SID_GB_WRITE(little_int_4);
    SID_GB_WRITE(little_int_8);
    SID_GB_READ(little_int_1);
    SID_GB_READ(little_int_2);
    SID_GB_READ(little_int_4);
    SID_GB_READ(little_int_8);

    SID_GB_WRITE(big_int_1);
    SID_GB_WRITE(big_int_2);
    SID_GB_WRITE(big_int_4);
    SID_GB_WRITE(big_int_8);
    SID_GB_READ(big_int_1);
    SID_GB_READ(big_int_2);
    SID_GB_READ(big_int_4);
    SID_GB_READ(big_int_8);
      
#undef SID_GB_WRITE
#undef SID_GB_READ

  ~generic_mapper_bus () throw ();

private:
  generic_mapper* target;
  mutable struct mapping_record* tlb1;
  mutable struct mapping_record* tlb2;

public:
  void clear_tlb () { tlb1 = tlb2 = 0; }
};

generic_mapper_bus::~generic_mapper_bus () throw () {
}



// ----------------------------------------------------------------------------

class generic_mapper: public virtual component,
		      protected fixed_attribute_map_component,
		      protected no_relation_component,
		      protected fixed_pin_map_component,
		      // NB: implements accessor sub-api directly
		      protected fixed_bus_map_component
{
public:
  generic_mapper (bool transparent_p);
  ~generic_mapper () throw() {}

  std::vector<string> accessor_names () throw();
  component::status connect_accessor (const string& name, bus* bus) throw();
  component::status disconnect_accessor (const string& name, bus* bus) throw();
  bus* connected_bus (const string& name) throw();

  mapping_record* make_name_mapping (const string& str, bus* bus) const;

protected:
  friend class generic_mapper_bus;

  vector<mapping_record> accessors; // All records
  generic_mapper_bus my_bus;

  // banking
  vector<mapping_record*> selected_accessors; // All records in current bank
  host_int_4 bank;
  callback_pin<generic_mapper> bank_pin;
  void bank_pin_handler (host_int_4);
  void bank_changed ();

  // stats
  host_int_4 access_count;
  host_int_4 cache_hit_count;

private:
  string save_state ();
  component::status restore_state (const string& state);

  string get_hits (std::string entry);
  component::status set_hits (std::string entry, const std::string& value);

  host_int_2 latency;
  bool is_transparent;
};


generic_mapper::generic_mapper (bool transparent_p)
  :my_bus (this),
   bank (0),
   bank_pin (this, & generic_mapper::bank_pin_handler),
   latency (0),
   is_transparent (transparent_p)
{
  add_bus ("access-port", &this->my_bus);
  add_attribute_virtual ("state-snapshot", this,
			 & generic_mapper::save_state,
			 & generic_mapper::restore_state);
  
  add_attribute ("latency", & this->latency, "setting");
  add_attribute_notify ("bank", & this->bank,
			this, & generic_mapper::bank_changed,
			"register");
  add_pin ("bank", & this->bank_pin);

  this->access_count = 0;
  add_attribute ("access-count", & this->access_count, "register");
  this->cache_hit_count = 0;
  add_attribute ("cache-hit-count", & this->cache_hit_count, "register");
}



void
generic_mapper::bank_pin_handler (host_int_4 new_bank)
{
  this->bank = new_bank;
  this->bank_changed ();
}


// Regenerate the selected-accessors sorted vector after the bank number
// or overall accessor list have changed.
void
generic_mapper::bank_changed ()
{
  this->selected_accessors.clear ();

  for (vector<mapping_record>::iterator it = this->accessors.begin();
       it != this->accessors.end();
       it++)
     {
       if (selected_p (*it, this->bank))
	 {
	   // cout << "mapper bank " << this->bank << " sel: " << it->spec << endl;
	   this->selected_accessors.push_back (& (*it));
	 }
     }

  sort (this->selected_accessors.begin(),
	this->selected_accessors.end(),
	mr_ptr_cmp ());

  this->my_bus.clear_tlb ();
}


vector<string>
generic_mapper::accessor_names () throw()
{
  vector<string> names;  
  for (vector<mapping_record>::const_iterator it = this->accessors.begin();
       it != this->accessors.end();
       it++)
     {
       names.push_back (it->spec);
     }  
  return names;
}

component::status
generic_mapper::connect_accessor (const string& name, bus* bus) throw()
  {
    // new entry
    mapping_record *r = make_name_mapping (name, bus);
    if (r == NULL)
      {
	return component::bad_value;
      }

    // Reject overlaps
    for (unsigned i=0; i<this->accessors.size(); i++)
      if (overlaps_p (this->accessors[i], *r))
	{
	  cerr << "mapper error: overlap between " << r->spec
	       << " and " << this->accessors[i].spec
	       << endl;
	  delete r;
	  return component::bad_value;
	}

    this->accessors.push_back (*r);
    // sort for aesthetic reasons
    sort (this->accessors.begin(), this->accessors.end(), mr_value_cmp ());
    this->bank_changed (); // recalculate selected_accessors

    add_attribute_virtual_parameterized (name + "-hits", 
					 name,
					 this,
					 & generic_mapper::get_hits,
					 & generic_mapper::set_hits,
					 "register");

    delete r;
    return component::ok;
  }


component::status
generic_mapper::disconnect_accessor (const string& name, bus* bus) throw()
  {
    for (vector<mapping_record>::iterator it = this->accessors.begin();
         it != this->accessors.end();
         it++)
       {
         // found existing entry
         if (it->spec == name)
	   {
	     remove_attribute (name + "-hits");
	     this->accessors.erase (it);
	     // sort for aesthetic reasons
	     sort (this->accessors.begin(), this->accessors.end(), mr_value_cmp ());
	     this->bank_changed (); // recalculate selected_accessors
	     return component::ok;
	   }
       }
    return component::not_found;
  }


bus* 
generic_mapper::connected_bus (const string& name) throw() 
  {
    for (vector<mapping_record>::const_iterator it = this->accessors.begin();
         it != this->accessors.end ();
         it++)
       {
	 // found existing entry
         if (it->spec == name)
	   return (*it).accessor;
       }
     return 0;
  }




// Parse a mapping specification and produce a mapping_record from it.
// Return 0 on parse or validity-checking error.
//
// Accept the following forms:
//
// GARBAGE1[SPEC]GARBAGE2
//
// where SPEC ::=
// LOW-HIGH
// LOW-HIGH,STRIDE,WIDTH
// MAPPED_BASE=LOW-HIGH
// MAPPED_BASE=LOW-HIGH,STRIDE,WIDTH
// BYTES_PER_WORD*LOW-HIGH
// BYTES_PER_WORD*LOW-HIGH,STRIDE,WIDTH
// BYTES_PER_WORD*MAPPED_BASE=LOW-HIGH
// BYTES_PER_WORD*MAPPED_BASE=LOW-HIGH,STRIDE,WIDTH
//
// and GARBAGE2 ::=
// {BANKS}GARBAGE3
// or GARBAGE3
//
// where BANKS ::=  specifies mapping banks
// BANK1,BANK2,BANK3,...                 (0- tokens)
//
// Each number may be specified in any format that parse_attribute()
// understands.
//
mapping_record* 
generic_mapper::make_name_mapping (const string& str, bus* acc) const 
{
  // Fill in this struct in stack; may return copy if all goes well
  mapping_record record;

  vector<string> fields_outer = tokenize (str, "[]");
  if (fields_outer.size() != 3)
    {
      cerr << "mapper error: parse error (missing [SPEC]) in " << str << endl;
      return 0;
    }

  string spec = fields_outer[1];
  string garbage2 = fields_outer[2];

  // Process bank numbers spec
  vector<string> bankspec = tokenize (garbage2, "{}");

  // cout << "suffix=" << garbage2 << endl;
  // for (int j=0; j<bankspec.size(); j++)
  //   cout << "bank[" << j << "] = `" << bankspec[j] << "'" << endl;

  if (bankspec.size() == 3)
    {
      // Process each number
      vector<string> banks = tokenize (bankspec[1], ",");
      for (unsigned i=0; i<banks.size(); i++)
	{
	  string bankstr = banks[i];
	  // accept & bypass empty strings
	  if (bankstr.length () == 0)
	    continue;

	  host_int_4 bank;
	  component::status stat = parse_attribute(bankstr, bank);
	  if (stat != component::ok) 
	    {
	      cerr << "mapper error: parse error (bank#) in " << str << endl;
	      return 0;
	    }

	  record.banks.push_back (bank);
	  // cout << "added bank=" << bank << endl;
	}
    }
  else if (bankspec.size() <= 1) // no "{" nor "}" appears, or no suffix at all
    {
      // No bank number specification: default 0
      record.banks.push_back (0);
      // cout << "set bank=" << 0 << endl;
    }
  else
    {
      cerr << "mapper error: parse error (bad {bank} block) in " << str << endl;
      return 0;
    }

  // Check for the BYTES_PER_WORD* specification.
  vector<string> fields = tokenize (spec, "*");  
  
  // Must have 1 or 2 tokens
  if (fields.size() > 2)
    {
      cerr << "mapper error: parse error (more than one word size) in "
	   << str << endl;
      return 0;
    }

  if (fields.size() == 2) 
    {
      // strip the word width off the front of the descriptor array
      component::status stat = parse_attribute(fields [0], record.bytes_per_word);
      if (stat != component::ok) 
	{
	  cerr << "mapper error: parse error (bytes_per_word) in " << str << endl;
	  return 0;
	}
      fields.erase (fields.begin ());
    }
  else
    record.bytes_per_word = 1;

  assert (fields.size() == 1);
  spec = fields[0];

  // Check for a mapped_base output address specification
  fields = tokenize (spec, "=");

  // Must have 1 or 2 tokens
  if (fields.size() > 2)
    {
      cerr << "mapper error: parse error (more than one mapped base address) in "
	   << str << endl;
      return 0;
    }

  bool mapped_base_default;
  if (fields.size() == 2) 
    {
      // strip the mapped_base address off the front of the descriptor array
      component::status stat = parse_attribute(fields [0], record.mapped_base);
      if (stat != component::ok) 
	{
	  cerr << "mapper error: parse error (mapped_base) in " << str << endl;
	  return 0;
	}
      fields.erase (fields.begin ());
      mapped_base_default = false;
    }
  else
    mapped_base_default = true;

  assert (fields.size() == 1);
  spec = fields[0];

  // Now parse the address range and the stride/width, if any
  fields = tokenize (spec, "-,");
  if (fields.size() != 2 && fields.size() != 4)
    {
      cerr << "mapper error: parse error (wrong number of arguments to [SPEC]) in " << str << endl;
      return 0;
    }

  // parse two or four fields
  component::status s1 = parse_attribute(fields[0], record.low);
  component::status s2 = parse_attribute(fields[1], record.high);
  if (s1 != component::ok || s2 != component::ok)
    {
      cerr << "mapper error: parse error (low-high) in " << str << endl;
      return 0;
    }

  record.use_strideoffset_p = (fields.size() == 4);
  if (record.use_strideoffset_p)
    {
      component::status s3 = parse_attribute(fields[2], record.stride);
      component::status s4 = parse_attribute(fields[3], record.width);
      if (s3 != component::ok || s4 != component::ok)
	{
	  cerr << "mapper error: parse error (stride,width) in " << str << endl;
	  return 0;
	}
    }

  // check fields for validity
  if (record.low > record.high)
    {
      cerr << "mapper error: illegal low-high in " << str << endl;
      return 0;
    }

  // We now enough information to set the default for the mapped_base address
  // if required.
  if (mapped_base_default)
    {
      if (is_transparent)
	record.mapped_base = record.low;
      else
	record.mapped_base = 0;
    }

  // scale all values by the word width
  record.mapped_base *= record.bytes_per_word;
  record.low    *= record.bytes_per_word;
  record.high   = (record.high + 1) * record.bytes_per_word - 1;
  record.stride *= record.bytes_per_word;
  record.width  *= record.bytes_per_word;

  // check further
  if (record.use_strideoffset_p)
    {
      if (record.width > record.stride)
	{
	  cerr << "mapper error: illegal stride<width in " << str << endl;
	  return 0;
	}

      // compute stride_shift & stride_mask
      record.stride_shift = 1;
      for (unsigned i = 0; i<32; i++)
	{
	  if (record.stride == (1 << record.stride_shift))
	    break;
	  if (i == 31)
	    {
	      cerr << "mapper error: illegal stride in " << str << endl;
	      return 0;
	    }
	  record.stride_shift ++;
	}
      record.stride_mask = record.stride - 1;

      // compute width_shift
      switch (record.width)
	{
	case 1:
	  record.width_shift = 0;
	  break;
	case 2:
	  record.width_shift = 1;
	  break;
	case 4:
	  record.width_shift = 2;
	  break;
	case 8:
	  record.width_shift = 3;
	  break;
	default:
	  cerr << "mapper error: illegal width in " << str << endl;
	  return 0;
	}

      // compute offset; adjust high/low to contain entire stride regions
      record.offset = record.low & record.stride_mask;
      record.mapped_base &= ~ record.stride_mask;
      record.low &= ~ record.stride_mask;
      record.high |= record.stride_mask;
    }
  else
    {
      // no stride/offset
      record.stride = 0;
      record.stride_shift = 0;
      record.stride_mask = 0; 
      record.offset = 0;
      record.width = 0;
      record.width_shift = 0;
    }


  // fill in slot
  record.accessor = acc;
  record.spec = str;
  record.hit_count = 0;

  /*
  cout << "new mapping_record: "
       << record.low << " " << record.high << " " << record.hit_count << " "
       << record.use_strideoffset_p << " " << record.stride << " " << record.stride_shift << " "
       << record.stride_mask << " " << record.offset << " " << record.width << " "
       << record.width_shift << " " << record.spec << endl;
  */

  // Return a copy of our hand-made record
  return new mapping_record (record);
}


inline mapping_record*
generic_mapper_bus::locate (host_int_4 address) const
{
  this->target->access_count ++;

  // check last-used entries first 
  mapping_record* cache = this->tlb1;
  if (LIKELY(cache && address <= cache->high && address >= cache->low))
    {
      this->target->cache_hit_count ++;
      cache->hit_count ++;
      return cache;
    }
  cache = this->tlb2;
  if (LIKELY(cache && address <= cache->high && address >= cache->low))
    {
      this->target->cache_hit_count ++;
      cache->hit_count ++;
      return cache;
    }

  // binary search in one statement!
  vector<mapping_record*>::iterator where = 
    lower_bound (this->target->selected_accessors.begin (),
		 this->target->selected_accessors.end (),
		 address,
		 mr_ptr_cmp ());

  while (where != this->target->selected_accessors.end ())
    {
      mapping_record* found = *where;
      // cout << " [found: " << found.first << "-" << found.last << "]" << endl;

      // Incoming address is smaller than the first map entry?
      if (UNLIKELY(address < found->low))
	break;

      // Incoming address is within this map entry?
      if (LIKELY(address <= found->high))
	{
	  found->hit_count ++;
	  this->tlb2 = this->tlb1;
	  this->tlb1 = found;
	  return found;
	}

      where ++;
    }

  return 0;
}



string
generic_mapper::get_hits (string entry)
{
  for (unsigned i=0; i<this->accessors.size(); i++)
    {
      if (this->accessors[i].spec == entry)
	return make_numeric_attribute (this->accessors[i].hit_count);
    }
  return "?";
}


component::status
generic_mapper::set_hits (string entry, const string& value)
{
  for (unsigned i=0; i<this->accessors.size(); i++)
    {
      if (this->accessors[i].spec == entry)
	return parse_attribute (value, this->accessors[i].hit_count);
    }
  return component::not_found;
}


string
generic_mapper::save_state ()
{
  // XXX: redo
  return string ();
} 


component::status
generic_mapper::restore_state (const string& state)
{
  // XXX: redo
  if (state == "")
    return component::ok;
  else 
    return component::bad_value;
} 


template <class Data>
inline bus::status
generic_mapper_bus::write_any (host_int_4 address, Data data) throw ()
  {
    const mapping_record* r = this->locate (address);
    if (LIKELY (r))
      {
	// bypass stride/offset calculations?
	if (LIKELY(! r->use_strideoffset_p))
	  {
	    host_int_4 mapped_address = address - (r->low - r->mapped_base);
	    bus::status st = r->accessor->write (mapped_address, data);
	    st.latency += this->target->latency;
	    return st;
	  }

	// Order these alternatives by guess of frequency of use
	if (r->width == 1)
	  {
	    typename Data::size_1_type s1data;
	    return write_strideoffset_any (address, r, data, s1data);
	  }
	else if (r->width == 4)
	  {
	    typename Data::size_4_type s4data;
	    return write_strideoffset_any (address, r, data, s4data);
	  }
	else if (r->width == 2)
	  {
	    typename Data::size_2_type s2data;
	    return write_strideoffset_any (address, r, data, s2data);
	  }
	else if (r->width == 8)
	  {
	    typename Data::size_8_type s8data;
	    return write_strideoffset_any (address, r, data, s8data);
	  }
	else
	  assert (0);
      }
    else
      return bus::unmapped;
  }


template <class Data>
inline bus::status
generic_mapper_bus::read_any (host_int_4 address, Data& data) throw ()
  {
    const mapping_record* r = this->locate (address);
    if (LIKELY (r))
      {
	// bypass stride/offset calculations?
	if (LIKELY(! r->use_strideoffset_p))
	  {
	    host_int_4 mapped_address = address - (r->low - r->mapped_base);
	    bus::status st = r->accessor->read (mapped_address, data);
	    st.latency += this->target->latency;
	    return st;
	  }

	// Order these alternatives by guess of frequency of use
	if (r->width == 1)
	  {
	    typename Data::size_1_type s1data;
	    return read_strideoffset_any (address, r, data, s1data);
	  }
	else if (r->width == 4)
	  {
	    typename Data::size_4_type s4data;
	    return read_strideoffset_any (address, r, data, s4data);
	  }
	else if (r->width == 2)
	  {
	    typename Data::size_2_type s2data;
	    return read_strideoffset_any (address, r, data, s2data);
	  }
	else if (r->width == 8)
	  {
	    typename Data::size_8_type s8data;
	    return read_strideoffset_any (address, r, data, s8data);
	  }
	else
	  assert (0);
      }
    else
      return bus::unmapped;
  }


  // Specialized write() for stride/offset slaves
template <class DataMaster, class DataSlave>
inline bus::status
generic_mapper_bus::write_strideoffset_any (host_int_4 address,
					    const mapping_record* r,
					    DataMaster data, DataSlave)
  throw ()
    {
      const host_int_4 master_offset = address & r->stride_mask;
      const host_int_4 master_size = sizeof (typename DataMaster::value_type);
      const host_int_4 slave_size = sizeof (typename DataSlave::value_type);
      const host_int_4 slave_offset = r->offset;

      // Signal error if master access does not include all of slave bus
      if (UNLIKELY((master_offset > slave_offset) || 
	 	   (master_offset+master_size < slave_offset+slave_size)))
	return bus::misaligned;

      // Signal error if master access spans stride boundary.
      if (UNLIKELY(master_size+master_offset > r->stride))
	return bus::misaligned;

      // Copy data bytes for slave
      DataSlave ds;
      for (unsigned i=0; i<slave_size; i++)
	ds.write_byte (i, data.read_byte (i + slave_offset - master_offset));

      host_int_4 mapped_address = (address - (r->low - r->mapped_base)) >> (r->stride_shift - r->width_shift);
      
      bus::status st = r->accessor->write (mapped_address, ds);
      st.latency += this->target->latency;
      return st;
    }


// Specialized read() for stride/offset slaves
template <class DataMaster, class DataSlave>
inline bus::status
generic_mapper_bus::read_strideoffset_any (host_int_4 address,
					   const mapping_record* r,
					   DataMaster& data,
					   DataSlave) throw ()
{
  const host_int_4 master_offset = address & r->stride_mask;
  const host_int_4 master_size = sizeof (typename DataMaster::value_type);
  const host_int_4 slave_size = sizeof (typename DataSlave::value_type);
  const host_int_4 slave_offset = r->offset;
  
  // Signal error if master access does not include all of slave bus
  if (UNLIKELY((master_offset > slave_offset) || 
	       (master_offset+master_size < slave_offset+slave_size)))
    return bus::misaligned;
  
  // Signal error if master access spans stride boundary.
  if (UNLIKELY(master_size+master_offset > r->stride))
    return bus::misaligned;
  
  DataSlave ds;
  host_int_4 mapped_address = (address - (r->low - r->mapped_base)) >> (r->stride_shift - r->width_shift);
  bus::status s = r->accessor->read (mapped_address, ds);
  
  // Copy data bytes for master
  for (unsigned i=0; i<slave_size; i++)
    data.write_byte (i, ds.read_byte (i + slave_offset - master_offset));
  
  // Add on latency
  s.latency += this->target->latency;
  return s;
}


// ----------------------------------------------------------------------------

static
vector<string>
compMapperListTypes ()
{
  vector<string> types;
  types.push_back ("hw-mapper-basic");
  types.push_back ("hw-mapper-transparent");
  return types;
}


static
component*
compMapperCreate (const string& typeName)
{
  if (typeName == "hw-mapper-basic")
    return new generic_mapper (false);
  else if (typeName == "hw-mapper-transparent")
    return new generic_mapper (true);
  else
    return 0;
}


static
void
compMapperDelete (component* c)
{
  delete dynamic_cast<generic_mapper*>(c);
}


// static object
DLLEXPORT extern const component_library mapper_component_library;

const component_library mapper_component_library =
{
  COMPONENT_LIBRARY_MAGIC,
  & compMapperListTypes, 
  & compMapperCreate,
  & compMapperDelete
};
@


1.14
log
@* build fixes for gcc 3.4

[cgen-cpu]
2005-02-12  Frank Ch. Eigler  <fche@@elastic.org>

	* cgen-engine.h (virtual_insn_type): Move decl here ...
	* cgen-cpu.h: ... from here.
	* Makefile.am (SOURCES): Don't try to build fp code.
	* Makefile.in: Regenerated.

[gdb]
2005-02-12  Frank Ch. Eigler  <fche@@elastic.org>

	* gdbserv-state.c (gdbserv_fromclient_break): Fix statementless
	label at end of block.

[mapper]
2005-02-12  Frank Ch. Eigler  <fche@@elastic.org>

	* compMapper.cxx (read/write_strideoffset_any, read/write_any):
	Move these generic_mapper_bus functions out of line.

[sched]
2005-02-12  Frank Ch. Eigler  <fche@@elastic.org>

	* compSched.cxx (scheduler_component): Clarify friend decl.

[timers/arm7t]
2005-02-12  Frank Ch. Eigler  <fche@@elastic.org>

	* arm7t-timer.h: Add needed friend decl.
@
text
@d1013 1
a1013 1
extern const component_library mapper_component_library;
d1015 1
a1015 1
const component_library mapper_component_library DLLEXPORT = 
@


1.13
log
@2003-02-13  Dave Brolley  <brolley@@redhat.com>

        * compMapper.cxx (make_name_mapping): Compute the upper bound of a
        mapped range correctly when bytes_per_word is specified.
@
text
@a177 2

  // Specialized write() for stride/offset slaves
d181 2
a182 28
			  DataMaster data, DataSlave) throw ()
    {
      const host_int_4 master_offset = address & r->stride_mask;
      const host_int_4 master_size = sizeof (typename DataMaster::value_type);
      const host_int_4 slave_size = sizeof (typename DataSlave::value_type);
      const host_int_4 slave_offset = r->offset;

      // Signal error if master access does not include all of slave bus
      if (UNLIKELY((master_offset > slave_offset) || 
	 	   (master_offset+master_size < slave_offset+slave_size)))
	return bus::misaligned;

      // Signal error if master access spans stride boundary.
      if (UNLIKELY(master_size+master_offset > r->stride))
	return bus::misaligned;

      // Copy data bytes for slave
      DataSlave ds;
      for (unsigned i=0; i<slave_size; i++)
	ds.write_byte (i, data.read_byte (i + slave_offset - master_offset));

      host_int_4 mapped_address = (address - (r->low - r->mapped_base)) >> (r->stride_shift - r->width_shift);
      
      bus::status st = r->accessor->write (mapped_address, ds);
      st.latency += target->latency;
      return st;
    }

d188 2
a189 29
			  DataMaster& data, DataSlave) throw ()
    {
      const host_int_4 master_offset = address & r->stride_mask;
      const host_int_4 master_size = sizeof (typename DataMaster::value_type);
      const host_int_4 slave_size = sizeof (typename DataSlave::value_type);
      const host_int_4 slave_offset = r->offset;

      // Signal error if master access does not include all of slave bus
      if (UNLIKELY((master_offset > slave_offset) || 
		   (master_offset+master_size < slave_offset+slave_size)))
	return bus::misaligned;

      // Signal error if master access spans stride boundary.
      if (UNLIKELY(master_size+master_offset > r->stride))
	return bus::misaligned;

      DataSlave ds;
      host_int_4 mapped_address = (address - (r->low - r->mapped_base)) >> (r->stride_shift - r->width_shift);
      bus::status s = r->accessor->read (mapped_address, ds);

      // Copy data bytes for master
      for (unsigned i=0; i<slave_size; i++)
	data.write_byte (i, ds.read_byte (i + slave_offset - master_offset));

      // Add on latency
      s.latency += target->latency;
      return s;
    }

a440 15
template <class Data>
inline bus::status
generic_mapper_bus::write_any (host_int_4 address, Data data) throw ()
  {
    const mapping_record* r = this->locate (address);
    if (LIKELY (r))
      {
	// bypass stride/offset calculations?
	if (LIKELY(! r->use_strideoffset_p))
	  {
	    host_int_4 mapped_address = address - (r->low - r->mapped_base);
	    bus::status st = r->accessor->write (mapped_address, data);
	    st.latency += target->latency;
	    return st;
	  }
a441 71
	// Order these alternatives by guess of frequency of use
	if (r->width == 1)
	  {
	    typename Data::size_1_type s1data;
	    return write_strideoffset_any (address, r, data, s1data);
	  }
	else if (r->width == 4)
	  {
	    typename Data::size_4_type s4data;
	    return write_strideoffset_any (address, r, data, s4data);
	  }
	else if (r->width == 2)
	  {
	    typename Data::size_2_type s2data;
	    return write_strideoffset_any (address, r, data, s2data);
	  }
	else if (r->width == 8)
	  {
	    typename Data::size_8_type s8data;
	    return write_strideoffset_any (address, r, data, s8data);
	  }
	else
	  assert (0);
      }
    else
      return bus::unmapped;
  }

template <class Data>
inline bus::status
generic_mapper_bus::read_any (host_int_4 address, Data& data) throw ()
  {
    const mapping_record* r = this->locate (address);
    if (LIKELY (r))
      {
	// bypass stride/offset calculations?
	if (LIKELY(! r->use_strideoffset_p))
	  {
	    host_int_4 mapped_address = address - (r->low - r->mapped_base);
	    bus::status st = r->accessor->read (mapped_address, data);
	    st.latency += target->latency;
	    return st;
	  }

	// Order these alternatives by guess of frequency of use
	if (r->width == 1)
	  {
	    typename Data::size_1_type s1data;
	    return read_strideoffset_any (address, r, data, s1data);
	  }
	else if (r->width == 4)
	  {
	    typename Data::size_4_type s4data;
	    return read_strideoffset_any (address, r, data, s4data);
	  }
	else if (r->width == 2)
	  {
	    typename Data::size_2_type s2data;
	    return read_strideoffset_any (address, r, data, s2data);
	  }
	else if (r->width == 8)
	  {
	    typename Data::size_8_type s8data;
	    return read_strideoffset_any (address, r, data, s8data);
	  }
	else
	  assert (0);
      }
    else
      return bus::unmapped;
  }
d817 160
@


1.12
log
@* better c++ standard compliance

[e.g.]
[include/ChangeLog]
2002-11-11  Frank Ch. Eigler  <fche@@redhat.com>

        * sidcpuutil.h (cpu_trace_stream): Add some std:: qualifiers.

[component/glue/ChangeLog]
2002-11-11  Frank Ch. Eigler  <fche@@redhat.com>

        * glue.cxx (bus_prober): Dtor throw() fixes.
@
text
@d3 1
a3 1
// Copyright (C) 1999-2002 Red Hat.
d777 1
a777 1
  record.high   *= record.bytes_per_word;
@


1.11
log
@2002-04-09  Dave Brolley  <brolley@@redhat.com>

	* hw-mapper-basic.xml: Describe <mapped_base> usage.
	* compMapper.cxx (struct mapping_record): New field, 'mapped_base'.
	(class generic_mapper_bus): Remove 'transparent_t' parameter,
	'low_multiplier' member  and 'is_transparent' member.
	(generic_mapper_bus::write_strideoffset_any): Compute mapped_address
	relative to mapped_base.
	(generic_mapper_bus::read_strideoffset_any): Ditto.
	(generic_mapper_bus::write_any): Ditto.
	(generic_mapper_bus::read_any): Ditto.
	(make_name_mapping): Remove 'garbage1' -- not used. Detect wordsize and
	mapped_base specifications using their operators.
@
text
@d397 1
a397 1
	   this->selected_accessors.push_back (it);
@


1.10
log
@* mapper bug fix, testsuite regression fixes

2002-03-15  Frank Ch. Eigler  <fche@@redhat.com>

        * compMapper.cxx (make_name_mapping): Tolerate bank-less suffix form.

2002-03-15  Frank Ch. Eigler  <fche@@redhat.com>

        * sidcomp.mapper/basicmapper.exp: Add several more specification-
        string test patterns.
@
text
@d66 1
d169 1
a169 1
  generic_mapper_bus (generic_mapper* target, bool transparent_p): target (target)
a171 1
      this->low_multiplier = (transparent_p ? 0 : 1);
d204 1
a204 1
      host_int_4 mapped_address = (address - (this->low_multiplier * r->low)) >> (r->stride_shift - r->width_shift);
d233 1
a233 1
      host_int_4 mapped_address = (address - (this->low_multiplier * r->low)) >> (r->stride_shift - r->width_shift);
a289 1
  unsigned low_multiplier;
d345 1
d350 1
a350 1
  :my_bus (this, transparent_p),
d353 2
a354 1
   latency (0)
d506 1
a506 1
	    host_int_4 mapped_address = address - (this->low_multiplier * r->low);
d550 1
a550 1
	    host_int_4 mapped_address = address - (this->low_multiplier * r->low);
d593 8
a600 4
// LOW-HIGH                              (2 tokens)
// LOW-HIGH,STRIDE,WIDTH                 (3 tokens)
// BYTES_PER_WORD*LOW-HIGH               (4 tokens)
// BYTES_PER_WORD*LOW-HIGH,STRIDE,WIDTH  (5 tokens)
a624 1
  string garbage1 = fields_outer[0];
d670 2
a671 2
  // XXX: equivocate */-/, separators
  vector<string> fields = tokenize (spec, "*-,");  
d673 2
a674 3
  // Must have between 2 and 5 tokens (including empties
  // before/after "[" and "]"
  if (fields.size() < 2 || fields.size() > 5)
d676 1
a676 1
      cerr << "mapper error: parse error (bad number of [SPEC] fields) in "
d681 1
a681 3
  // strip the word width off the front of the descriptor array
  record.bytes_per_word = 1;
  if (fields.size() == 3 || fields.size() == 5) 
d683 1
d692 16
d709 26
a734 5
  assert (fields.size() == 2 || fields.size() == 4);
  
  record.use_strideoffset_p = (fields.size() == 4);
  record.spec = str;
  record.hit_count = 0;
d744 2
d764 10
d775 1
d827 1
d845 2
@


1.9
log
@* mapper banking support

2002-03-11  Frank Ch. Eigler  <fche@@redhat.com>

        * compMapper.cxx (overlaps_p, selected_p, bank_changed): New/modified
        helper functions for banking.
        (bank_pin_handler, connect_accessor, disconnect_accessor): Ditto.
        (locate): Ditto.
        (make_name_mapping): Ditto; reorganize, tighten.  Change syntax of
        word-multiplier construct.
        (generic_mapper): Add new fields for bank tracking.
        * hw-mapper-basic.xml: Document banking system and syntax.
        * hw-mapper-basic.txt: Regenerated.
@
text
@d629 1
a629 1
  //  cout << "bank[" << j << "] = `" << bankspec[j] << "'" << endl;
d654 1
a654 1
  else if (bankspec.size() == 0) // no "{" nor "}" appears
@


1.8
log
@* new mapper variant

2001-10-10  Frank Ch. Eigler  <fche@@redhat.com>

	* compMapper.cxx (generic_mapper_bus): New field low_multiplier.
	(ctor): Initialize it depending on transparent mode.
	(write_strideoffset_any, read_strideoffset_any, write_any, read_any):
	Use field to be conditionally transparent.
	(generic_mapper ctor): Take transparent_p arg; pass it down.
	(compMapperListTypes, compMapperCreate): Support hw-mapper-transparent.
	* hw-mapper-basic.xml: Document this new variant.
	* hw-mapper-basic.txt: Regenerated.
@
text
@d3 1
a3 1
// Copyright (C) 1999-2001 Red Hat.
d57 1
d85 2
d93 9
d109 23
a131 1
class mr_cmp: public std::binary_function<mapping_record, mapping_record, bool>
d138 9
d148 1
a148 1
  bool operator () (const mapping_record& a, host_int_4 addr) const
d150 1
a150 1
      return (a.high < addr); 
d153 1
a153 1
  bool operator () (host_int_4 addr, const mapping_record& b) const
d155 1
a155 1
      return (addr < b.low);
d170 1
a170 2
      this->tlb1 = 0;
      this->tlb2 = 0;
d291 3
d324 1
a324 1
  vector<mapping_record> accessors;
d327 7
d351 2
d359 6
a364 2

  add_attribute ("latency", &latency, "setting");
d373 35
d443 3
a445 1
    sort(this->accessors.begin(),this->accessors.end(),mr_cmp());
d471 3
a473 1
	     sort(this->accessors.begin(),this->accessors.end(),mr_cmp());
d588 15
a602 4
// [LOW-HIGH]                              (4 tokens)
// [LOW-HIGH,STRIDE,WIDTH]                 (6 tokens)
// [BYTES_PER_WORD,LOW-HIGH]               (5 tokens)
// [BYTES_PER_WORD,LOW-HIGH,STRIDE,WIDTH]  (7 tokens)
d613 6
a618 1
  vector<string> fields = tokenize (str, "[-,]");
d620 41
a660 3
  // Must have between 4 and 7 tokens (including empties
  // before/after "[" and "]")
  if (fields.size() < 4 || fields.size() > 7)
d662 13
a674 1
      cerr << "mapper error: parse error (bad number of fields) in " << str << endl;
d680 1
a680 1
  if (fields.size() == 5 || fields.size() == 7) 
d682 1
a682 1
      component::status stat = parse_attribute(fields [fields.size () - 2], record.bytes_per_word);
d688 1
a688 1
      fields.pop_back ();
d690 2
d693 1
a693 1
  record.use_strideoffset_p = (fields.size() == 6);
d698 2
a699 2
  component::status s1 = parse_attribute(fields[1], record.low);
  component::status s2 = parse_attribute(fields[2], record.high);
d707 2
a708 2
      component::status s3 = parse_attribute(fields[3], record.stride);
      component::status s4 = parse_attribute(fields[4], record.width);
d828 5
a832 7
  vector<mapping_record>::iterator where = 
    lower_bound (this->target->accessors.begin (),
		this->target->accessors.end (),
		address,
		mr_cmp ());

  // XXX: other optimizations
d834 1
a834 1
  while (where != this->target->accessors.end ())
d836 1
a836 1
      mapping_record* found = & * where;
@


1.7
log
@2001-09-26  Frank Ch. Eigler  <fche@@redhat.com>

	* compMapper.cxx (tlb1/tlb2): Add support for a second tlb entry.
@
text
@d125 1
a125 1
  generic_mapper_bus (generic_mapper* target): target (target)
d129 1
d162 1
a162 1
      host_int_4 mapped_address = (address - r->low) >> (r->stride_shift - r->width_shift);
d191 1
a191 1
      host_int_4 mapped_address = (address - r->low) >> (r->stride_shift - r->width_shift);
d248 1
d266 1
a266 1
  generic_mapper ();
d297 2
a298 2
generic_mapper::generic_mapper ()
  :my_bus (this),
d408 1
a408 1
	    host_int_4 mapped_address = address - r->low;
d452 1
a452 1
	    host_int_4 mapped_address = address - r->low;
d749 1
d759 3
a761 1
    return new generic_mapper ();
@


1.6
log
@* make it compile with GCC 3.0:
        - missing throw() specifiers in bus & component dtors
	- `std::' vs `::' namespace issues
@
text
@d3 1
a3 1
// Copyright (C) 1999, 2000 Red Hat.
d127 2
a128 1
      this->tlb = 0;
d245 2
a246 1
  mutable struct mapping_record* tlb;
d491 2
a492 2
// [LOW-HIGH,BYTES_PER_WORD]               (5 tokens)
// [LOW-HIGH,STRIDE,WIDTH,BYTES_PER_WORD]  (7 tokens)
d644 9
a652 2
  // check last-used entry first 
  mapping_record* cache = this->tlb; // one-entry tlb
d682 2
a683 1
	  this->tlb = found;
@


1.5
log
@[sid/component/mapper]
2001-07-23  graydon hoare  <graydon@@redhat.com>

	* compMapper.cxx (make_name_mapping): Support mapping
	names with word size included as constant multiplier.

[sid/component/testsuite]
2001-07-23  graydon hoare  <graydon@@redhat.com>

	* sidcomp.mapper/basicmapper.exp: Add tests for mapping
	with word size specified in accessor name.
@
text
@d240 1
a240 1
  ~generic_mapper_bus ();
d247 1
a247 1
generic_mapper_bus::~generic_mapper_bus () {
d263 1
a263 1
  ~generic_mapper () {}
@


1.4
log
@* GCC 2.95.3 fixes.

[cache/ChangeLog]
	* cache.h (cache:bus::DEFN_METHOD): Generate function prototypes only.
	(::DEFN_METHOD): Generate actual inline function bodies after
	cache_component is defined.

[mapper/ChangeLog]
	* compMapper.cxx (generic_mapper_bus::write_any,
	generic_mapper_bus::read_any): Move function definition after
	generic_mapper is defined.
@
text
@d69 6
d487 4
a490 2
// [LOW-HIGH]
// [LOW-HIGH,STRIDE,WIDTH]
d503 1
a503 1
  // Must have either four or six tokens (including empties
d505 1
a505 1
  if (fields.size() != 4 && fields.size() != 6)
d511 13
d553 6
@


1.3
log
@2001-06-21  Ben Elliston  <bje@@redhat.com>

	* compMapper.cxx (generic_mapper::latency): New member.
	(generic_mapper constructor): Add a "latency" attribute.
	(generic_mapper_bus::write_strideoffset_any): Accumulate latency.
	(generic_mapper_bus::read_strideoffset_any): Likewise.
	(generic_mapper_bus::write_any): Likewise.
	(generic_mapper_bus::read_any): Likewise.
	* hw-mapper-basic.txt: Document extension.
@
text
@d196 1
a196 2

  // Generic write()
d199 1
a199 44
  write_any (host_int_4 address, Data data) throw ()
    {
      const mapping_record* r = this->locate (address);
      if (LIKELY (r))
	{
	  // bypass stride/offset calculations?
	  if (LIKELY(! r->use_strideoffset_p))
	    {
	      host_int_4 mapped_address = address - r->low;
	      bus::status st = r->accessor->write (mapped_address, data);
	      st.latency += target->latency;
	      return st;
	    }

	  // Order these alternatives by guess of frequency of use
	  if (r->width == 1)
	    {
	      typename Data::size_1_type s1data;
	      return write_strideoffset_any (address, r, data, s1data);
	    }
	  else if (r->width == 4)
	    {
	      typename Data::size_4_type s4data;
	      return write_strideoffset_any (address, r, data, s4data);
	    }
	  else if (r->width == 2)
	    {
	      typename Data::size_2_type s2data;
	      return write_strideoffset_any (address, r, data, s2data);
	    }
	  else if (r->width == 8)
	    {
	      typename Data::size_8_type s8data;
	      return write_strideoffset_any (address, r, data, s8data);
	    }
	  else
	    assert (0);
	}
      else
	return bus::unmapped;
    }


  // Generic read()
d202 1
a202 41
  read_any (host_int_4 address, Data& data) throw ()
    {
      const mapping_record* r = this->locate (address);
      if (LIKELY (r))
	{
	  // bypass stride/offset calculations?
	  if (LIKELY(! r->use_strideoffset_p))
	    {
	      host_int_4 mapped_address = address - r->low;
	      bus::status st = r->accessor->read (mapped_address, data);
	      st.latency += target->latency;
	      return st;
	    }

	  // Order these alternatives by guess of frequency of use
	  if (r->width == 1)
	    {
	      typename Data::size_1_type s1data;
	      return read_strideoffset_any (address, r, data, s1data);
	    }
	  else if (r->width == 4)
	    {
	      typename Data::size_4_type s4data;
	      return read_strideoffset_any (address, r, data, s4data);
	    }
	  else if (r->width == 2)
	    {
	      typename Data::size_2_type s2data;
	      return read_strideoffset_any (address, r, data, s2data);
	    }
	  else if (r->width == 8)
	    {
	      typename Data::size_8_type s8data;
	      return read_strideoffset_any (address, r, data, s8data);
	    }
	  else
	    assert (0);
	}
      else
	return bus::unmapped;
    }
d388 87
@


1.2
log
@* branch probability hinting

[cgen/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* sid.cpu (-op-gen-set-trace[-parallel], -create-virtual-insns!):
	Emit LIKELY/UNLIKELY branch probability hints.
	* sid-decode.cpu (-gen-record-args): Ditto.

[sid/include/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* sidconfig.h (LIKELY, UNLIKELY): New conditional cover macros
	for gcc's __builtin_expect branch probability hinting function.
	* sidbusutil.h (passthrough_bus, mux_password_bus, harvard_bus):
	Add some branch probability hints.
	* sidcpuutil.h (step_pin_handler, stop_after_insns_p,
	{read,write}_{insn,data}_memory): Ditto.
	* sidpinutil.h (callback_pin::driven): Remove unnecessary assert
	from critical path.

[eg. sid/component/mapper/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* compMapper.cxx ({read,write}_strideoffset_any): Added b.p. hints.
	(write_any, read_any, locate): Ditto.

[sid/component/cgen-cpu/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* cgen-engine.h (set_pbb_engine, chain, get_next_vpc, pbb_find,
	pbb_find_or_alloc, pbb_before, pbb_after): Add branch probability
	hints.

[eg. sid/component/cgen-cpu/arm7t/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* arm-decode.cxx, -sem.cxx, -semsw.cxx: Regenerated w/ b.p. hints.
	* thumb-decode.cxx, -sem.cxx, -semsw.cxx: Ditto.
@
text
@d155 4
a158 1
      return r->accessor->write (mapped_address, ds);
d190 2
d209 3
a211 1
	      return r->accessor->write (mapped_address, data);
d255 3
a257 1
	      return r->accessor->read (mapped_address, data);
d366 2
d372 2
a373 1
  :my_bus (this)
d379 2
@


1.1
log
@* public snapshot of sid simulator
@
text
@d141 2
a142 1
      if ((master_offset > slave_offset) || (master_offset+master_size < slave_offset+slave_size))
d146 1
a146 1
      if (master_size+master_offset > r->stride)
d171 2
a172 1
      if ((master_offset > slave_offset) || (master_offset+master_size < slave_offset+slave_size))
d176 1
a176 1
      if (master_size+master_offset > r->stride)
d198 1
a198 1
      if (r)
d201 1
a201 1
	  if (! r->use_strideoffset_p)
d242 1
a242 1
      if (r)
d245 1
a245 1
	  if (! r->use_strideoffset_p)
d600 1
a600 1
  if (cache && address <= cache->high && address >= cache->low)
d622 1
a622 1
      if (address < found->low)
d626 1
a626 1
      if (address <= found->high)
@

