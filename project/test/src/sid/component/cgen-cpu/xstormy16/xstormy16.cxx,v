head	1.4;
access;
symbols
	sid-snapshot-20180601:1.4
	sid-snapshot-20180501:1.4
	sid-snapshot-20180401:1.4
	sid-snapshot-20180301:1.4
	sid-snapshot-20180201:1.4
	sid-snapshot-20180101:1.4
	sid-snapshot-20171201:1.4
	sid-snapshot-20171101:1.4
	sid-snapshot-20171001:1.4
	sid-snapshot-20170901:1.4
	sid-snapshot-20170801:1.4
	sid-snapshot-20170701:1.4
	sid-snapshot-20170601:1.4
	sid-snapshot-20170501:1.4
	sid-snapshot-20170401:1.4
	sid-snapshot-20170301:1.4
	sid-snapshot-20170201:1.4
	sid-snapshot-20170101:1.4
	sid-snapshot-20161201:1.4
	sid-snapshot-20161101:1.4
	sid-snapshot-20160901:1.4
	sid-snapshot-20160801:1.4
	sid-snapshot-20160701:1.4
	sid-snapshot-20160601:1.4
	sid-snapshot-20160501:1.4
	sid-snapshot-20160401:1.4
	sid-snapshot-20160301:1.4
	sid-snapshot-20160201:1.4
	sid-snapshot-20160101:1.4
	sid-snapshot-20151201:1.4
	sid-snapshot-20151101:1.4
	sid-snapshot-20151001:1.4
	sid-snapshot-20150901:1.4
	sid-snapshot-20150801:1.4
	sid-snapshot-20150701:1.4
	sid-snapshot-20150601:1.4
	sid-snapshot-20150501:1.4
	sid-snapshot-20150401:1.4
	sid-snapshot-20150301:1.4
	sid-snapshot-20150201:1.4
	sid-snapshot-20150101:1.4
	sid-snapshot-20141201:1.4
	sid-snapshot-20141101:1.4
	sid-snapshot-20141001:1.4
	sid-snapshot-20140901:1.4
	sid-snapshot-20140801:1.4
	sid-snapshot-20140701:1.4
	sid-snapshot-20140601:1.4
	sid-snapshot-20140501:1.4
	sid-snapshot-20140401:1.4
	sid-snapshot-20140301:1.4
	sid-snapshot-20140201:1.4
	sid-snapshot-20140101:1.4
	sid-snapshot-20131201:1.4
	sid-snapshot-20131101:1.4
	sid-snapshot-20131001:1.4
	sid-snapshot-20130901:1.4
	sid-snapshot-20130801:1.4
	sid-snapshot-20130701:1.4
	sid-snapshot-20130601:1.4
	sid-snapshot-20130501:1.4
	sid-snapshot-20130401:1.4
	sid-snapshot-20130301:1.4
	sid-snapshot-20130201:1.4
	sid-snapshot-20130101:1.4
	sid-snapshot-20121201:1.4
	sid-snapshot-20121101:1.4
	sid-snapshot-20121001:1.4
	sid-snapshot-20120901:1.4
	sid-snapshot-20120801:1.4
	sid-snapshot-20120701:1.4
	sid-snapshot-20120601:1.4
	sid-snapshot-20120501:1.4
	sid-snapshot-20120401:1.4
	sid-snapshot-20120301:1.4
	sid-snapshot-20120201:1.4
	sid-snapshot-20120101:1.4
	sid-snapshot-20111201:1.4
	sid-snapshot-20111101:1.4
	sid-snapshot-20111001:1.4
	sid-snapshot-20110901:1.4
	sid-snapshot-20110801:1.4
	sid-snapshot-20110701:1.4
	sid-snapshot-20110601:1.4
	sid-snapshot-20110501:1.4
	sid-snapshot-20110401:1.4
	sid-snapshot-20110301:1.4
	sid-snapshot-20110201:1.4
	sid-snapshot-20110101:1.4
	sid-snapshot-20101201:1.4
	sid-snapshot-20101101:1.4
	sid-snapshot-20101001:1.4
	sid-snapshot-20100901:1.4
	sid-snapshot-20100801:1.4
	sid-snapshot-20100701:1.4
	sid-snapshot-20100601:1.4
	sid-snapshot-20100501:1.4
	sid-snapshot-20100401:1.4
	sid-snapshot-20100301:1.4
	sid-snapshot-20100201:1.4
	sid-snapshot-20100101:1.4
	sid-snapshot-20091201:1.4
	sid-snapshot-20091101:1.4
	sid-snapshot-20091001:1.4
	sid-snapshot-20090901:1.4
	sid-snapshot-20090801:1.4
	sid-snapshot-20090701:1.4
	sid-snapshot-20090601:1.4
	sid-snapshot-20090501:1.4
	sid-snapshot-20090401:1.4
	sid-snapshot-20090301:1.4
	sid-snapshot-20090201:1.4
	sid-snapshot-20090101:1.4
	sid-snapshot-20081201:1.4
	sid-snapshot-20081101:1.4
	sid-snapshot-20081001:1.4
	sid-snapshot-20080901:1.4
	sid-snapshot-20080801:1.4
	sid-snapshot-20080701:1.4
	sid-snapshot-20080601:1.3
	sid-snapshot-20080501:1.3
	sid-snapshot-20080403:1.3
	sid-snapshot-20080401:1.3
	sid-snapshot-20080301:1.3
	sid-snapshot-20080201:1.3
	sid-snapshot-20080101:1.3
	sid-snapshot-20071201:1.3
	sid-snapshot-20071101:1.3
	sid-snapshot-20071001:1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.2
	cygnus_cvs_20020108_pre:1.1;
locks; strict;
comment	@// @;


1.4
date	2008.06.17.18.06.52;	author brolley;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.18.22.57.29;	author dj;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.11.07.25.02;	author mrg;	state Exp;
branches;
next	1.1;

1.1
date	2001.12.17.09.31.20;	author mrg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@2008-06-17  Dave Brolley  <brolley@@redhat.com>

        * xstormy16.h (xstormy16_cpu_cgen): Now inherits from
        cgen_bi_endian_cpu.
        (h_pc_set_handler): New method of xstormy16_cpu_cgen.
        (h_gr_set_handler,init_change_logging,finish_change_logging)
        (log_pc_change,log_gr_change,restore_change) Likewise.
        (PC_UNCHANGED,PC_RESET,gr_changed,pc_changed,old_gr,old_h_pc):
        New members of xstormy16_cpu_cgen.
        (xstormy16_cpu): Now inherits only from xstormy16_cpu_cgen.
        * xstormy16.cxx (init_change_logging): New method of
        xstormy16_cpu_cgen.
        (finish_change_logging,log_pc_change,log_gr_change,restore_change):
        Likewise.
        * xstormy16-cpu.h: Regenerated.
@
text
@// xstormy16.cxx - Implementations of hand-written functions for the Xstormy16
// simulator. -*- C++ -*-

// Copyright (C) 2000, 2006 Red Hat.
// This file is part of SID and is licensed under the GPL.
// See the file COPYING.SID for conditions for redistribution.

#include "config.h"
#include "xstormy16.h"

extern "C" {
#include "bfd.h"
#include "dis-asm.h"
}

using namespace std;
using namespace sid;
using namespace sidutil;
using namespace xstormy16;

xstormy16_cpu::xstormy16_cpu ()
  :engine (32768) // XXX: tune size
{
  for (unsigned i = 0; i < 16; ++i)
    {
      string name = string ("GR") + make_numeric_attribute (i);
      SI* value = & this->hardware.h_gr[i];
      this->add_watchable_register (name, value);
    }
  
  // add syscall registers
  this->add_watchable_register (string("syscall-arg0"), &syscall_arg0);
  this->add_watchable_register (string("syscall-arg1"), &syscall_arg1);
  this->add_watchable_register (string("syscall-arg2"), &syscall_arg2);
  this->add_watchable_register (string("syscall-arg3"), &syscall_arg3);
  this->add_watchable_register (string("syscall-result"), &syscall_result);
  this->add_watchable_register (string("syscall-error"), &syscall_error);
  syscall_trap_num = 0;
  this->add_attribute (string("syscall-trap"), &syscall_trap_num, "setting");

  USI* value;
  value = & this->hardware.h_pc;
  this->add_watchable_register (string("pc"), value);
  
  this->create_gdb_register_attrs (17, "", & this->hardware.h_pc);
}

void
xstormy16_cpu::flush_icache ()
{
  this->engine.flush ();
}

void
xstormy16_cpu::reset()
{
  this->hardware.h_pc = 0;
  for (unsigned i = 0; i < 16; i++)
    this->hardware.h_gr[i] = 0;
}

void
xstormy16_cpu::invalid_insn (PCADDR pc)
{
  this->h_pc_set (pc);

  cpu_trap_disposition whatnext = this->signal_trap (cpu_trap_invalid_insn, pc);

  switch (whatnext)
    {
    case cpu_trap_unhandled:
      cerr << "xstormy16: unhandled invalid insn, pc=" << pc << endl;
      break;

    case cpu_trap_skip:
      {
	PCADDR npc = pc + 2;
	this->h_pc_set (npc);
      }
      break;

    case cpu_trap_handled:
    case cpu_trap_reissue:
      break;

    default:
      abort ();
    }

  this->yield();
  throw cpu_exception ();
}

// Memory trap(/fault) handling.
void
xstormy16_cpu::memory_trap (const cpu_memory_fault& t)
{
  this->h_pc_set (t.pc);

  cpu_trap_disposition whatnext = this->signal_trap (cpu_trap_memory_fault, t.address);

  switch (whatnext)
    {
    case cpu_trap_unhandled:
      cerr << "xstormy16: unhandled memory trap, pc=" << t.pc << endl;
      break;

    case cpu_trap_skip:
      {
	PCADDR pc = t.pc + 2;
	this->h_pc_set (pc);
      }
      break;

    case cpu_trap_handled:
    case cpu_trap_reissue:
      break;

    default:
      abort ();
    }

  this->yield();
}

// Stepper
void
xstormy16_cpu::step_insns ()
{
  bool found;
  
  while (true)
    {
      PCADDR pc = this->h_pc_get ();
      bool found;
      xstormy16_scache* sem = engine.find (pc, found);
      if (!found)
	{
	  try
	    {
	      // Fetch 16-bit pieces separately, so endianness
	      // conversions can be done on this chunk size.
	      UHI insn_hi = this->GETIMEMHI (pc, pc);
	      UHI insn_lo = this->GETIMEMHI (pc+2, pc+2);
	      USI insn = (insn_hi << 16) | insn_lo;
	      // BTW, this means that a 16-bit instruction will be
	      // shifted to the top 16 bits of `insn'.

	      // XXX: handle case of 16-bit insn placed at the very
	      // end of mapped memory (ie. causing unintentional
	      // SIGSEGV with the second GETIMEMHI call).

	      sem->decode (this, pc, insn, insn);
	    }
	  catch (cpu_memory_fault& t)
	    {
	      this->memory_trap (t);
	      break;
	    }
	}

      // Execute the instruction  -----------------------------------
      if (trace_result_p)
	{
          if (trace_counter_p)
	    this->trace_counter (pc);
	  if (trace_semantics_p)
	    this->begin_trace (pc, sem->idesc->insn_name);
          if (trace_disass_p)
	    this->disassemble (pc, print_insn_xstormy16,
                               bfd_target_elf_flavour,
                               bfd_arch_xstormy16,
                               BFD_ENDIAN_LITTLE, "xstormy16");
	}
      try
	{
	  sem->idesc->execute (this, sem);
	}
      catch (cpu_memory_fault& t)
	{
	  this->memory_trap (t);
	  this->yield ();
	}
      catch (cpu_exception& t)
	{
	  this->yield ();
	}
      if (trace_result_p)
	this->end_trace ();

      // Do post-instruction processing  ----------------------------
      if (this->enable_step_trap_p) 
	this->signal_trap (sidutil::cpu_trap_stepped);
      this->triggerpoint_manager.check_and_dispatch ();
      
      // test for exit condition
      if (stop_after_insns_p (1))
	break;
    }
}

string
xstormy16_cpu::dbg_get_reg (host_int_4 reg)
{
  string attr;
  host_int_4 val;
  int size = reg < 16 ? 2 : 4;

  /* Bank zero regs */
  if (reg < 16)
    val = h_gr_get (reg);
  else if (reg == 16)
    val = h_pc_get ();
  else
    val = 0;

  // Change to "target endian".
  little_int_4 v = val;
  for (unsigned i = 0; i < size; i++)
    attr += v.read_byte (i);

  return attr;
}

component::status
xstormy16_cpu::dbg_set_reg (host_int_4 reg, const string& attr)
{
  // change from "target endian"
  little_int_4 v;
  int size = reg < 16 ? 2 : 4;
  for (unsigned i = 0; i < size; i++)
    v.write_byte (i, attr[i]);
  host_int_4 val = v;

  /* Bank zero regs */
  if (reg < 16)
    h_gr_set (reg, val);
  else if (reg == 16)
    h_pc_set (val);
  else
    return component::bad_value;

  return component::ok;
}

// C++ implementations of instructions follow here

// sys -- testsuite syscall functionality
void
xstormy16_cpu::syscall ()
{
#if 1 // testsuite support
  syscall_arg0 = this->hardware.h_gr[1];
  syscall_arg1 = this->hardware.h_gr[2];
  syscall_arg2 = this->hardware.h_gr[3];
  syscall_arg3 = this->hardware.h_gr[4];

  string attrValue = make_attribute(0);
  this->set_attribute_value ("syscall-error", attrValue);

  cpu_trap_disposition whatnext = this->signal_trap (cpu_trap_software, syscall_trap_num);
  switch (whatnext)
    {
    case cpu_trap_unhandled:
      cerr << "hw-cpu-xstormy16: invalid insn handler unimplemented!" << endl;
      return;
      
    case cpu_trap_reissue:
      break;

    case cpu_trap_skip:
      this->h_pc_set (this->h_pc_get() + 2);
      /* fall-through */

    case cpu_trap_handled:
      {
	string errAttr = this->attribute_value ("syscall-error");
	string resultAttr = this->attribute_value ("syscall-result");
	
	host_int_4 errValue;
	host_int_4 resultValue;
	parse_attribute(errAttr, errValue);
	parse_attribute(resultAttr, resultValue);
	
	this->hardware.h_gr[0] = errValue;
	this->hardware.h_gr[1] = errValue != 0;
	this->hardware.h_gr[2] = resultValue;
      }
      return;
      
    default:
      abort ();
    }

  this->yield();
  throw cpu_exception ();
#endif
}

// break - perform breakpoint
void
xstormy16_cpu::do_brk ()
{
#if 1 // gdb suport
  cpu_trap_disposition whatnext = this->signal_trap (cpu_trap_breakpoint, 0);
  switch (whatnext)
    {
    case cpu_trap_unhandled:
      cerr << "hw-cpu-xstormy16: breakpoint handler unimplemented!" << endl;
      break;

    case cpu_trap_skip:
      this->h_pc_set (this->h_pc_get () + 2);
      break;

    case cpu_trap_handled:
    case cpu_trap_reissue:
      break;

    default:
      abort ();
    }

  this->yield();
  throw cpu_exception ();
#endif
}

// XXX finish me
// CPU stops the execution of the instruction and stops oscillation.
// Status is released by the generation of a port 0, port 1 or base
// timer interrupt request, the CPU is transferred to halt mode and
// returns to normal operation when it accepts the interrupt.
// In HALTX mode, the base timer continues operating, otherwise it is
// identical to HALT mode.
void
xstormy16_cpu::do_hold ()
{
}

void
xstormy16_cpu::do_holdx ()
{
}

// XXX finish me
// CPU stops the execution of the instruction, the peripheral
// circuits continue operating.  Status is released when then
// CPU accepts a reset or interrupt signal.
void
xstormy16_cpu::do_halt ()
{
}

// Count the bits in (16bit) register `reg', modulo 2.
int
xstormy16_cpu::parity (int reg)
{
  int tmp;
  tmp = reg ^ (reg >> 8);
  tmp ^= tmp >> 4;
  tmp ^= tmp >> 2;
  tmp ^= tmp >> 1;
  return tmp & 1;
}

// Called before execution of an insn.  Perform any tasks associated with
// logging changes in the state of this cpu during execution of an insn.
void
xstormy16_cpu_cgen::init_change_logging ()
{
  // Call up to the base class.
  cgen_bi_endian_cpu::init_change_logging ();

  // We will be tracking changes to the pc and to the gr registers.
  gr_changed = 0;
  pc_changed = PC_UNCHANGED;
}

// Called after execution of an insn.  Log the changes which occurred during
// execution of the insn.
void
xstormy16_cpu_cgen::finish_change_logging ()
{
  // Call up to the base class.
  cgen_bi_endian_cpu::finish_change_logging ();

  // The largest possible record would contain:
  //   1 byte representing the type of pc change
  //   A 16 bit mask indicating which gr registers changed
  //   Possibly the old pc value
  //   Old gr register values (if any)
  char buffer[1 + 2 + sizeof (old_h_pc) + sizeof (old_h_gr)];

  // Record the nature of any pc or gr changes.
  *(sid::host_int_1 *)(buffer + 0) = pc_changed;
  *(sid::host_int_2 *)(buffer + 1) = gr_changed;

  // If the pc change was too large to represent in the byte written above, then
  // record the old pc value.
  unsigned bufix = 3;
  if (pc_changed == PC_RESET)
    {
      *(USI *)(buffer + bufix) = old_h_pc;
      bufix += sizeof (old_h_pc);
    }

  // Record the old values of any gr registers that changed.
  sid::host_int_2 mask = 1;
  for (int i = 0; i < 16; ++i)
    {
      if ((gr_changed & mask) != 0)
	{
	  *(SI *)(buffer + bufix) = old_h_gr[i];
	  bufix += sizeof (old_h_gr[i]);
	  //		 std::cout << ' ' << std::hex << old_h_gr[i] << std::dec;
	}
      mask <<= 1;
    }

  // Save the change log record we have just created.
  log_change (buffer, bufix);
}

// Keep track of any changes to the pc.
void
xstormy16_cpu_cgen::log_pc_change (USI new_pc)
{
  // If this is the first change, then save the original pc value.
  if (LIKELY (pc_changed == PC_UNCHANGED))
    old_h_pc = this->hardware.h_pc;

  // Most of the time, pc changes are small enough to represented by one byte.
  // Save these changes in 'pc_changed'.
  //
  // The value of PC_UNCHANGED is zero and so this condition will be represented
  // with no special handling.
  //
  // The special value PC_RESET is an odd number and cannot occur under normal
  // circumstances.  It indicates a larger pc change.
  SI diff = new_pc - old_h_pc;
  if (LIKELY (-128 <= diff && diff <= 127))
    pc_changed = diff;
  else
    pc_changed = PC_RESET;
}

// Keep track of any changes to gr registers.  It is only necessary to
// save the original value of a register the first time it is changed.
void
xstormy16_cpu_cgen::log_gr_change (UINT regno, SI newval)
{
  if (! (gr_changed & (1 << regno)))
    {
      gr_changed |= 1 << regno;
      old_h_gr[regno] = this->hardware.h_gr[regno];
    }
}

// Given a change log record, restore the state that it represents.
void
xstormy16_cpu_cgen::restore_change (const char *data, sid::host_int_4 length)
{
  // The first byte indicates the nature of any change to the pc.
  assert (length >= 1);
  sid::signed_host_int_1 pc_changed = *(sid::host_int_1 *)data;
  ++data;
  --length;

  // The second two bytes are a bit mask indicating changes to gr registers.
  assert (length >= 2);
  sid::host_int_2 gr_changed = *(sid::host_int_2 *)data;
  data += 2;
  length -= 2;

  // Restore the pc.
  if (UNLIKELY (pc_changed == PC_RESET))
    {
      // For large changes to the pc, the previous pc value is recorded in the
      // change log record.
      this->hardware.h_pc = *(USI *)data;
      data += sizeof (USI);
      length -= sizeof (USI);
    }
  else
    {
      // Smaller changes to the pc are represented by a one byte delta.
      this->hardware.h_pc -= pc_changed;
    }

  // Restore any gr registers which changed.
  sid::host_int_2 mask = 1;
  for (int i = 0; i < 16; ++i)
    {
      if ((gr_changed & mask) != 0)
	{
	  assert (length >= sizeof (SI));
	  this->hardware.h_gr[i] = *(SI *)data;
	  data += sizeof (SI);
	  length -= sizeof (SI);
	}
      mask <<= 1;
    }

  // The entire record must be consumed.
  assert (length == 0);
}
@


1.3
log
@* xstormy16-decode.cxx: Regenerate.
* xstormy16-sem.cxx: Regenerate.
* xstormy16-write.cxx: Regenerate.

* xstormy16.cxx (parity): Fix logic.
@
text
@d4 1
a4 1
// Copyright (C) 2000 Red Hat.
d366 142
@


1.2
log
@[cgen/ChangeLog]
	* cpu/xstormy16.cpu (gr-Rbj-names): Rename this ...
	(gr-Rb-names): ... to this.
	(h-Rb): New hardware peice.
	(h-Rbj): Use gr-Rb-names.
	(Rb): Use h-Rb.

	(holdx): New instruction.

[opcodes/ChangeLog]
	* xstormy16-asm.c: Regenerate.
	* xstormy16-desc.c: Likewise.
	* xstormy16-desc.h: Likewise.
	* xstormy16-dis.c: Likewise.
	* xstormy16-opc.c: Likewise.
	* xstormy16-opc.h: Likewise.

[gas/testsuite/ChangeLog]
	* gas/xstormy16/allinsn.sh (movf, jmp, call, icall): Update.
	* gas/xstormy16/allinsn.d: Regenerate.
	* gas/xstormy16/allinsn.s: Regenerate.

[sid/component/cgen-cpu/xstormy16/ChangeLog]
	* xstormy16.cxx (do_holdx): Define.
	* xstormy16.h (do_holdx): Declare.
@
text
@d361 3
a363 3
  tmp ^= reg >> 4;
  tmp ^= reg >> 2;
  tmp ^= reg >> 1;
@


1.1
log
@* sanyo xstormy16 sid support.


[ChangeLog]
	* sid.spec: Add /usr/bin/xstormy16-elf-sid.

[bsp/ChangeLog]
	* Makefile.am (FAM10SCRIPTS): Add Xstormy16 support.
	* configrun-sid.in: Likewise.
	* xstormy16-elf-sid: New Xstormy16 frontend.

[bsp/pregen/ChangeLog]
	* pregen-configs.in: Add support for Xstormy16.
	* xstormy16-gloss.conf: New file.
	* xstormy16-gdb.conf: Likewise.
	* xstormy16-gloss-gdb.conf: Likewise.
	* xstormy16-gloss-gdb-tksm.conf: Likewise.

[component/ChangeLog]
	* CATALOG: Add hw-cpu-xstormy16.
	* tconfig.in: Add SIDTARGET_XSTORMY16.

[component/cgen-cpu/ChangeLog]
	* compCGEN.cxx: If SIDTARGET_XSTORMY16, add hw-cpu-xstormy16 support.
	* configure.in: Decend into xstormy16 if necessary.

[config/ChangeLog]
	* sidtargets.m4: Add Xstormy16 support.
	* config.sub: Likewise.
	* info.tcl.in: Likewise.
@
text
@d341 5
@

