head	1.2;
access;
symbols
	sid-snapshot-20180601:1.2
	sid-snapshot-20180501:1.2
	sid-snapshot-20180401:1.2
	sid-snapshot-20180301:1.2
	sid-snapshot-20180201:1.2
	sid-snapshot-20180101:1.2
	sid-snapshot-20171201:1.2
	sid-snapshot-20171101:1.2
	sid-snapshot-20171001:1.2
	sid-snapshot-20170901:1.2
	sid-snapshot-20170801:1.2
	sid-snapshot-20170701:1.2
	sid-snapshot-20170601:1.2
	sid-snapshot-20170501:1.2
	sid-snapshot-20170401:1.2
	sid-snapshot-20170301:1.2
	sid-snapshot-20170201:1.2
	sid-snapshot-20170101:1.2
	sid-snapshot-20161201:1.2
	sid-snapshot-20161101:1.2
	sid-snapshot-20160901:1.2
	sid-snapshot-20160801:1.2
	sid-snapshot-20160701:1.2
	sid-snapshot-20160601:1.2
	sid-snapshot-20160501:1.2
	sid-snapshot-20160401:1.2
	sid-snapshot-20160301:1.2
	sid-snapshot-20160201:1.2
	sid-snapshot-20160101:1.2
	sid-snapshot-20151201:1.2
	sid-snapshot-20151101:1.2
	sid-snapshot-20151001:1.2
	sid-snapshot-20150901:1.2
	sid-snapshot-20150801:1.2
	sid-snapshot-20150701:1.2
	sid-snapshot-20150601:1.2
	sid-snapshot-20150501:1.2
	sid-snapshot-20150401:1.2
	sid-snapshot-20150301:1.2
	sid-snapshot-20150201:1.2
	sid-snapshot-20150101:1.2
	sid-snapshot-20141201:1.2
	sid-snapshot-20141101:1.2
	sid-snapshot-20141001:1.2
	sid-snapshot-20140901:1.2
	sid-snapshot-20140801:1.2
	sid-snapshot-20140701:1.2
	sid-snapshot-20140601:1.2
	sid-snapshot-20140501:1.2
	sid-snapshot-20140401:1.2
	sid-snapshot-20140301:1.2
	sid-snapshot-20140201:1.2
	sid-snapshot-20140101:1.2
	sid-snapshot-20131201:1.2
	sid-snapshot-20131101:1.2
	sid-snapshot-20131001:1.2
	sid-snapshot-20130901:1.1
	sid-snapshot-20130801:1.1
	sid-snapshot-20130701:1.1
	sid-snapshot-20130601:1.1
	sid-snapshot-20130501:1.1
	sid-snapshot-20130401:1.1
	sid-snapshot-20130301:1.1
	sid-snapshot-20130201:1.1
	sid-snapshot-20130101:1.1
	sid-snapshot-20121201:1.1
	sid-snapshot-20121101:1.1
	sid-snapshot-20121001:1.1
	sid-snapshot-20120901:1.1
	sid-snapshot-20120801:1.1
	sid-snapshot-20120701:1.1
	sid-snapshot-20120601:1.1
	sid-snapshot-20120501:1.1
	sid-snapshot-20120401:1.1
	sid-snapshot-20120301:1.1
	sid-snapshot-20120201:1.1
	sid-snapshot-20120101:1.1
	sid-snapshot-20111201:1.1
	sid-snapshot-20111101:1.1
	sid-snapshot-20111001:1.1
	sid-snapshot-20110901:1.1
	sid-snapshot-20110801:1.1
	sid-snapshot-20110701:1.1
	sid-snapshot-20110601:1.1
	sid-snapshot-20110501:1.1
	sid-snapshot-20110401:1.1
	sid-snapshot-20110301:1.1
	sid-snapshot-20110201:1.1
	sid-snapshot-20110101:1.1
	sid-snapshot-20101201:1.1
	sid-snapshot-20101101:1.1
	sid-snapshot-20101001:1.1
	sid-snapshot-20100901:1.1
	sid-snapshot-20100801:1.1
	sid-snapshot-20100701:1.1
	sid-snapshot-20100601:1.1
	sid-snapshot-20100501:1.1
	sid-snapshot-20100401:1.1
	sid-snapshot-20100301:1.1
	sid-snapshot-20100201:1.1
	sid-snapshot-20100101:1.1
	sid-snapshot-20091201:1.1
	sid-snapshot-20091101:1.1
	sid-snapshot-20091001:1.1
	sid-snapshot-20090901:1.1
	sid-snapshot-20090801:1.1
	sid-snapshot-20090701:1.1
	sid-snapshot-20090601:1.1
	sid-snapshot-20090501:1.1
	sid-snapshot-20090401:1.1
	sid-snapshot-20090301:1.1
	sid-snapshot-20090201:1.1
	sid-snapshot-20090101:1.1
	sid-snapshot-20081201:1.1
	sid-snapshot-20081101:1.1
	sid-snapshot-20081001:1.1
	sid-snapshot-20080901:1.1
	sid-snapshot-20080801:1.1
	sid-snapshot-20080701:1.1
	sid-snapshot-20080601:1.1
	sid-snapshot-20080501:1.1
	sid-snapshot-20080403:1.1
	sid-snapshot-20080401:1.1
	sid-snapshot-20080301:1.1
	sid-snapshot-20080201:1.1
	sid-snapshot-20080101:1.1
	sid-snapshot-20071201:1.1
	sid-snapshot-20071101:1.1
	sid-snapshot-20071001:1.1;
locks; strict;
comment	@// @;


1.2
date	2013.09.22.04.32.42;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	2006.10.18.18.27.27;	author brolley;	state Exp;
branches;
next	;


desc
@@


1.2
log
@sid/component/cgen-cpu/mep/
	* mep.h (mep_cpu_cgen::~mep_cpu_cgen): New.
	* mep_basic.h (mep_basic_cpu::~mep_basic_cpu): New.
	* mep_ext1.h (mep_ext1_cpu::~mep_ext1_cpu): New.
sid/component/cgen-cpu/sh/
	* sh.h (sh_cpu_impl::~sh_cpu_impl): New.
	* sh2a_model.cxx: Specify dependent base class function with 'this->'.
	* sh3_model.cxx: Likewise.
	* sh4.cxx: Likewise.
	* sh64.c: Include sysdep.h first.
sid/component/gloss/
	* angel.h (arm_angel::~arm_angel): New.
	* m32r.h (m32r_libgloss::~m32r_libgloss): New.
	* mips.h (mips32_idt::~mips32_idt): New.
sid/component/mmu/
	* armRemap.cxx (operator<<): Avoid redeclaration of "it".
@
text
@// sh3_model.cxx - Hand-written code for the Toshiba Media Engine modelling. -*- C++ -*-

// Copyright (C) 2006 Red Hat.
// This file is part of SID and is licensed under the GPL.
// See the file COPYING.SID for conditions for redistribution.

#include "sh3_model.h"
#include "sh3.h"
#include "sh3e.h"

using namespace sh3;
using namespace sh3e;

template <class BASE, class CPU, class IDESC>
sh3_model<BASE,CPU,IDESC>::sh3_model (CPU* cpu) :
  BASE (cpu),
  sr_busy (0)
{
}

// --------------------------------------------------------------------------------
// Some inline-friendly private methods.
//
template <class BASE, class CPU, class IDESC>
inline void
sh3_model<BASE,CPU,IDESC>::set_sr_busy (sid::signed_host_int_4 cycles)
{
  if (cycles > 0)
    if (this->sr_busy < cycles)
      this->sr_busy = cycles;
}

template <class BASE, class CPU, class IDESC>
inline bool
sh3_model<BASE,CPU,IDESC>::insn_is_tstb (const sh3_idesc *idesc)
{
  return (idesc->sem_index == sh3::SH3_INSN_TSTB_COMPACT
	  || idesc->sem_index == sh3::SH3_INSN_TASB_COMPACT);
}

template <class BASE, class CPU, class IDESC>
inline bool
sh3_model<BASE,CPU,IDESC>::insn_is_tstb (const sh3e_idesc *idesc)
{
  return (idesc->sem_index == sh3e::SH3E_INSN_TSTB_COMPACT
	  || idesc->sem_index == sh3e::SH3E_INSN_TASB_COMPACT);
}

// --------------------------------------------------------------------------------
// Model overrides
//

template <class BASE, class CPU, class IDESC>
UINT
sh3_model<BASE,CPU,IDESC>::model_u_use_tbit_before (CPU *cpu, const IDESC *idesc, int unit_num)
{
  this->set_current_stall (this->sr_busy);
}

template <class BASE, class CPU, class IDESC>
UINT
sh3_model<BASE,CPU,IDESC>::model_u_set_sr_bit_after (CPU *cpu, const IDESC *idesc, int unit_num, unsigned long long referenced)
{
  // SR will be busy for this number of cycles.
  UINT cycles = 3;

  // Some insns use more cycles.
  if (insn_is_tstb (idesc))
    cycles += 2;

  this->set_sr_busy (cycles);

  return 0; // No additional latency
}

template <class BASE, class CPU, class IDESC>
UINT
sh3_model<BASE,CPU,IDESC>::model_u_ldc_sr_after (CPU *cpu, const IDESC *idesc, int unit_num, unsigned long long referenced)
{
  return 5; // 5 cycles on this machine.
}

template <class BASE, class CPU, class IDESC>
UINT
sh3_model<BASE, CPU, IDESC>::model_u_macw_after (CPU *cpu, const IDESC *idesc, int unit_num, unsigned long long referenced)
{
  // MAC model with multiply latency of 3.
  UINT extra_cycle = this->model_mac_after (cpu, 3);

  // Basic execution cycles for this insn.
  UINT cycles = this->unit_cycles (idesc, BASE::UNIT_U_MACW);

  return cycles + extra_cycle;
}

template <class BASE, class CPU, class IDESC>
UINT
sh3_model<BASE, CPU, IDESC>::model_u_macl_after (CPU *cpu, const IDESC *idesc, int unit_num, unsigned long long referenced)
{
  // MAC model with multiply latency of 3.
  UINT extra_cycle = this->model_mac_after (cpu, 3);

  // Basic execution cycles for this insn.
  UINT cycles = this->unit_cycles (idesc, BASE::UNIT_U_MACL);

  return cycles + extra_cycle;
}

template <class BASE, class CPU, class IDESC>
UINT
sh3_model<BASE, CPU, IDESC>::model_u_dmul_after (CPU *cpu, const IDESC *idesc, int unit_num, unsigned long long referenced)
{
  // MAC model with multiply latency of 3.
  UINT extra_cycle = this->model_mac_after (cpu, 3);

  // Basic execution cycles for this insn.
  UINT cycles = this->unit_cycles (idesc, BASE::UNIT_U_DMUL);

  return cycles + extra_cycle;
}

template <class BASE, class CPU, class IDESC>
UINT
sh3_model<BASE, CPU, IDESC>::model_u_mull_after (CPU *cpu, const IDESC *idesc, int unit_num, unsigned long long referenced)
{
  // MAC model with multiply latency of 3.
  UINT extra_cycle = this->model_mac_after (cpu, 3);

  // Basic execution cycles for this insn.
  UINT cycles = this->unit_cycles (idesc, BASE::UNIT_U_MULL);

  return cycles + extra_cycle;
}

template <class BASE, class CPU, class IDESC>
UINT
sh3_model<BASE,CPU,IDESC>::model_u_ldcl_after (CPU *cpu, const IDESC *idesc, int unit_num, unsigned long long referenced)
{
  // 1 cycle on this machine.
  this->exec_cycles += 1;
  return 1;
}

template <class BASE, class CPU, class IDESC>
UINT
sh3_model<BASE,CPU,IDESC>::model_u_trap_after (CPU *cpu, const IDESC *idesc, int unit_num, unsigned long long referenced)
{
  return 6; // 6 cycles on this machine.
}

template <class BASE, class CPU, class IDESC>
void
sh3_model<BASE,CPU,IDESC>::step_latency (sid::host_int_4 cycles)
{
  // Compute latency which has incurred since we were last called.
  sid::host_int_8 new_total_latency = BASE::cpu->get_total_latency ();
  sid::host_int_8 latency = cycles + (new_total_latency - this->save_total_latency);
  this->save_total_latency = new_total_latency;

  // If there's no latency, then nothing to do.
  if (LIKELY (latency == 0))
    return;

  this->advance_latency (latency);
}

template <class BASE, class CPU, class IDESC>
void
sh3_model<BASE,CPU,IDESC>::advance_latency (sid::host_int_4 latency)
{
  BASE::advance_latency (latency);

  MODEL_ADVANCE_LATENCY (sr_busy, latency);
}

// ------------------------------------------------------------------------------------------------
// Other utility methods.
//
// ... none yet

// ------------------------------------------------------------------------------------------------
// sh3e_model.
//
template <class BASE, class CPU, class IDESC>
sh3e_model<BASE,CPU,IDESC>::sh3e_model (CPU* cpu) :
  sh3_model<BASE,CPU,IDESC> (cpu)
{
}

template <class BASE, class CPU, class IDESC>
UINT
sh3e_model<BASE,CPU,IDESC>::model_u_fpu_after (CPU *cpu, const IDESC *idesc, int unit_num, unsigned long long referenced)
{
  UINT cycles = 1;
  this->exec_cycles += cycles;
  this->set_fpu_busy (cycles);
  // NOTE: No special latency for fpscr
  return 0; // No direct cycles used
}

template <class BASE, class CPU, class IDESC>
UINT
sh3e_model<BASE,CPU,IDESC>::model_u_fcnv_after (CPU *cpu, const IDESC *idesc, int unit_num, unsigned long long referenced)
{
  return this->model_u_fpu_after (cpu, idesc, unit_num, referenced);
}

template <class BASE, class CPU, class IDESC>
UINT
sh3e_model<BASE,CPU,IDESC>::model_u_fsqrt_after (CPU *cpu, const IDESC *idesc, int unit_num, unsigned long long referenced, INT loadreg)
{
  UINT cycles = 15;
  this->set_fpu_busy (cycles);
  this->set_fpr_busy (loadreg, cycles);
  return 0; // no direct cycles used
}

// Explicit instantiations
template class sh3_model<sh_common_model<sh3_sh3_model,sh3_cpu,sh3_idesc,sh3_scache>,sh3_cpu,sh3_idesc>;
template class sh3e_model<sh_common_model_with_fp<sh3e_sh3e_model,sh3e_cpu,sh3e_idesc,sh3e_scache>,sh3e_cpu,sh3e_idesc>;
@


1.1
log
@New cpu port.
@
text
@d91 1
a91 1
  UINT cycles = unit_cycles (idesc, BASE::UNIT_U_MACW);
d104 1
a104 1
  UINT cycles = unit_cycles (idesc, BASE::UNIT_U_MACL);
d114 1
a114 1
  UINT extra_cycle = model_mac_after (cpu, 3);
d117 1
a117 1
  UINT cycles = unit_cycles (idesc, BASE::UNIT_U_DMUL);
d127 1
a127 1
  UINT extra_cycle = model_mac_after (cpu, 3);
d130 1
a130 1
  UINT cycles = unit_cycles (idesc, BASE::UNIT_U_MULL);
@

