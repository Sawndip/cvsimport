head	1.9;
access;
symbols
	sid-snapshot-20180601:1.9
	sid-snapshot-20180501:1.9
	sid-snapshot-20180401:1.9
	sid-snapshot-20180301:1.9
	sid-snapshot-20180201:1.9
	sid-snapshot-20180101:1.9
	sid-snapshot-20171201:1.9
	sid-snapshot-20171101:1.9
	sid-snapshot-20171001:1.9
	sid-snapshot-20170901:1.9
	sid-snapshot-20170801:1.9
	sid-snapshot-20170701:1.9
	sid-snapshot-20170601:1.9
	sid-snapshot-20170501:1.9
	sid-snapshot-20170401:1.9
	sid-snapshot-20170301:1.9
	sid-snapshot-20170201:1.9
	sid-snapshot-20170101:1.9
	sid-snapshot-20161201:1.9
	sid-snapshot-20161101:1.9
	sid-snapshot-20160901:1.9
	sid-snapshot-20160801:1.9
	sid-snapshot-20160701:1.9
	sid-snapshot-20160601:1.9
	sid-snapshot-20160501:1.9
	sid-snapshot-20160401:1.9
	sid-snapshot-20160301:1.9
	sid-snapshot-20160201:1.9
	sid-snapshot-20160101:1.9
	sid-snapshot-20151201:1.9
	sid-snapshot-20151101:1.9
	sid-snapshot-20151001:1.9
	sid-snapshot-20150901:1.9
	sid-snapshot-20150801:1.9
	sid-snapshot-20150701:1.9
	sid-snapshot-20150601:1.9
	sid-snapshot-20150501:1.9
	sid-snapshot-20150401:1.9
	sid-snapshot-20150301:1.9
	sid-snapshot-20150201:1.9
	sid-snapshot-20150101:1.9
	sid-snapshot-20141201:1.9
	sid-snapshot-20141101:1.9
	sid-snapshot-20141001:1.9
	sid-snapshot-20140901:1.9
	sid-snapshot-20140801:1.9
	sid-snapshot-20140701:1.9
	sid-snapshot-20140601:1.9
	sid-snapshot-20140501:1.9
	sid-snapshot-20140401:1.9
	sid-snapshot-20140301:1.9
	sid-snapshot-20140201:1.9
	sid-snapshot-20140101:1.9
	sid-snapshot-20131201:1.9
	sid-snapshot-20131101:1.9
	sid-snapshot-20131001:1.9
	sid-snapshot-20130901:1.9
	sid-snapshot-20130801:1.9
	sid-snapshot-20130701:1.9
	sid-snapshot-20130601:1.9
	sid-snapshot-20130501:1.9
	sid-snapshot-20130401:1.9
	sid-snapshot-20130301:1.9
	sid-snapshot-20130201:1.9
	sid-snapshot-20130101:1.9
	sid-snapshot-20121201:1.9
	sid-snapshot-20121101:1.9
	sid-snapshot-20121001:1.9
	sid-snapshot-20120901:1.9
	sid-snapshot-20120801:1.9
	sid-snapshot-20120701:1.9
	sid-snapshot-20120601:1.9
	sid-snapshot-20120501:1.9
	sid-snapshot-20120401:1.9
	sid-snapshot-20120301:1.9
	sid-snapshot-20120201:1.9
	sid-snapshot-20120101:1.9
	sid-snapshot-20111201:1.9
	sid-snapshot-20111101:1.9
	sid-snapshot-20111001:1.9
	sid-snapshot-20110901:1.9
	sid-snapshot-20110801:1.9
	sid-snapshot-20110701:1.9
	sid-snapshot-20110601:1.9
	sid-snapshot-20110501:1.9
	sid-snapshot-20110401:1.9
	sid-snapshot-20110301:1.9
	sid-snapshot-20110201:1.9
	sid-snapshot-20110101:1.9
	sid-snapshot-20101201:1.9
	sid-snapshot-20101101:1.9
	sid-snapshot-20101001:1.9
	sid-snapshot-20100901:1.9
	sid-snapshot-20100801:1.9
	sid-snapshot-20100701:1.9
	sid-snapshot-20100601:1.9
	sid-snapshot-20100501:1.9
	sid-snapshot-20100401:1.9
	sid-snapshot-20100301:1.9
	sid-snapshot-20100201:1.8
	sid-snapshot-20100101:1.7
	sid-snapshot-20091201:1.7
	sid-snapshot-20091101:1.7
	sid-snapshot-20091001:1.6
	sid-snapshot-20090901:1.6
	sid-snapshot-20090801:1.6
	sid-snapshot-20090701:1.6
	sid-snapshot-20090601:1.6
	sid-snapshot-20090501:1.6
	sid-snapshot-20090401:1.6
	sid-snapshot-20090301:1.6
	sid-snapshot-20090201:1.6
	sid-snapshot-20090101:1.6
	sid-snapshot-20081201:1.6
	sid-snapshot-20081101:1.6
	sid-snapshot-20081001:1.6
	sid-snapshot-20080901:1.6
	sid-snapshot-20080801:1.6
	sid-snapshot-20080701:1.6
	sid-snapshot-20080601:1.6
	sid-snapshot-20080501:1.6
	sid-snapshot-20080403:1.6
	sid-snapshot-20080401:1.6
	sid-snapshot-20080301:1.6
	sid-snapshot-20080201:1.6
	sid-snapshot-20080101:1.6
	sid-snapshot-20071201:1.6
	sid-snapshot-20071101:1.6
	sid-snapshot-20071001:1.6
	sid-20020905-branchpoint:1.4
	sid-20020905-branch:1.4.0.2
	cygnus_cvs_20020108_pre:1.4;
locks; strict;
comment	@// @;


1.9
date	2010.02.12.02.33.04;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2010.01.02.21.18.54;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.24.00.45.55;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2006.10.18.18.37.51;	author brolley;	state Exp;
branches;
next	1.5;

1.5
date	2003.07.05.17.07.21;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.01.19.15.33;	author fche;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.29.20.03.26;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.15.21.14.26;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.07.19.30.49;	author fche;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Regenerate to pick up recent cgen changes.
[minor changes like removing K&R support, more consistent name for sfmt_empty]
@
text
@/* Simulator instruction semantics for m32rbf.

THIS FILE IS MACHINE GENERATED WITH CGEN.

Copyright (C) 2000-2010 Red Hat, Inc.

This file is part of the Red Hat simulators.


*/


#if HAVE_CONFIG_H
#include "config.h"
#endif
#include "m32rbf.h"

using namespace m32rbf; // FIXME: namespace organization still wip
#define GET_ATTR(name) GET_ATTR_##name ()


// ********** x-invalid: --invalid--

sem_status
m32rbf_sem_x_invalid (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 0;

  {
    current_cpu->invalid_insn (pc);
    assert (0);
    /* NOTREACHED */
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** add: add $dr,$sr

sem_status
m32rbf_sem_add (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = ADDSI (* FLD (i_dr), * FLD (i_sr));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** add3: add3 $dr,$sr,$hash$slo16

sem_status
m32rbf_sem_add3 (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_add3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = ADDSI (* FLD (i_sr), FLD (f_simm16));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** and: and $dr,$sr

sem_status
m32rbf_sem_and (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = ANDSI (* FLD (i_dr), * FLD (i_sr));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** and3: and3 $dr,$sr,$uimm16

sem_status
m32rbf_sem_and3 (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = ANDSI (* FLD (i_sr), FLD (f_uimm16));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** or: or $dr,$sr

sem_status
m32rbf_sem_or (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = ORSI (* FLD (i_dr), * FLD (i_sr));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** or3: or3 $dr,$sr,$hash$ulo16

sem_status
m32rbf_sem_or3 (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = ORSI (* FLD (i_sr), FLD (f_uimm16));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** xor: xor $dr,$sr

sem_status
m32rbf_sem_xor (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = XORSI (* FLD (i_dr), * FLD (i_sr));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** xor3: xor3 $dr,$sr,$uimm16

sem_status
m32rbf_sem_xor3 (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = XORSI (* FLD (i_sr), FLD (f_uimm16));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** addi: addi $dr,$simm8

sem_status
m32rbf_sem_addi (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = ADDSI (* FLD (i_dr), FLD (f_simm8));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** addv: addv $dr,$sr

sem_status
m32rbf_sem_addv (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

{
  SI temp0;BI temp1;
  temp0 = ADDSI (* FLD (i_dr), * FLD (i_sr));
  temp1 = ADDOFSI (* FLD (i_dr), * FLD (i_sr), 0);
  {
    SI opval = temp0;
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }
  {
    BI opval = temp1;
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "cond" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_cond = opval;
  }
}

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** addv3: addv3 $dr,$sr,$simm16

sem_status
m32rbf_sem_addv3 (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_add3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

{
  SI temp0;BI temp1;
  temp0 = ADDSI (* FLD (i_sr), FLD (f_simm16));
  temp1 = ADDOFSI (* FLD (i_sr), FLD (f_simm16), 0);
  {
    SI opval = temp0;
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }
  {
    BI opval = temp1;
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "cond" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_cond = opval;
  }
}

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** addx: addx $dr,$sr

sem_status
m32rbf_sem_addx (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

{
  SI temp0;BI temp1;
  temp0 = ADDCSI (* FLD (i_dr), * FLD (i_sr), current_cpu->hardware.h_cond);
  temp1 = ADDCFSI (* FLD (i_dr), * FLD (i_sr), current_cpu->hardware.h_cond);
  {
    SI opval = temp0;
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }
  {
    BI opval = temp1;
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "cond" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_cond = opval;
  }
}

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** bc8: bc.s $disp8

sem_status
m32rbf_sem_bc8 (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_bc8.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

if (current_cpu->hardware.h_cond) {
  {
    USI opval = FLD (i_disp8);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->branch (opval, npc, status);
  }
}

  current_cpu->done_cti_insn (npc, status);
  return status;
#undef FLD
}

// ********** bc24: bc.l $disp24

sem_status
m32rbf_sem_bc24 (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_bc24.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

if (current_cpu->hardware.h_cond) {
  {
    USI opval = FLD (i_disp24);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->branch (opval, npc, status);
  }
}

  current_cpu->done_cti_insn (npc, status);
  return status;
#undef FLD
}

// ********** beq: beq $src1,$src2,$disp16

sem_status
m32rbf_sem_beq (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_beq.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

if (EQSI (* FLD (i_src1), * FLD (i_src2))) {
  {
    USI opval = FLD (i_disp16);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->branch (opval, npc, status);
  }
}

  current_cpu->done_cti_insn (npc, status);
  return status;
#undef FLD
}

// ********** beqz: beqz $src2,$disp16

sem_status
m32rbf_sem_beqz (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_beq.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

if (EQSI (* FLD (i_src2), 0)) {
  {
    USI opval = FLD (i_disp16);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->branch (opval, npc, status);
  }
}

  current_cpu->done_cti_insn (npc, status);
  return status;
#undef FLD
}

// ********** bgez: bgez $src2,$disp16

sem_status
m32rbf_sem_bgez (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_beq.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

if (GESI (* FLD (i_src2), 0)) {
  {
    USI opval = FLD (i_disp16);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->branch (opval, npc, status);
  }
}

  current_cpu->done_cti_insn (npc, status);
  return status;
#undef FLD
}

// ********** bgtz: bgtz $src2,$disp16

sem_status
m32rbf_sem_bgtz (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_beq.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

if (GTSI (* FLD (i_src2), 0)) {
  {
    USI opval = FLD (i_disp16);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->branch (opval, npc, status);
  }
}

  current_cpu->done_cti_insn (npc, status);
  return status;
#undef FLD
}

// ********** blez: blez $src2,$disp16

sem_status
m32rbf_sem_blez (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_beq.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

if (LESI (* FLD (i_src2), 0)) {
  {
    USI opval = FLD (i_disp16);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->branch (opval, npc, status);
  }
}

  current_cpu->done_cti_insn (npc, status);
  return status;
#undef FLD
}

// ********** bltz: bltz $src2,$disp16

sem_status
m32rbf_sem_bltz (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_beq.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

if (LTSI (* FLD (i_src2), 0)) {
  {
    USI opval = FLD (i_disp16);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->branch (opval, npc, status);
  }
}

  current_cpu->done_cti_insn (npc, status);
  return status;
#undef FLD
}

// ********** bnez: bnez $src2,$disp16

sem_status
m32rbf_sem_bnez (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_beq.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

if (NESI (* FLD (i_src2), 0)) {
  {
    USI opval = FLD (i_disp16);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->branch (opval, npc, status);
  }
}

  current_cpu->done_cti_insn (npc, status);
  return status;
#undef FLD
}

// ********** bl8: bl.s $disp8

sem_status
m32rbf_sem_bl8 (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_bc8.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

{
  {
    SI opval = ADDSI (ANDSI (pc, -4), 4);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << ((UINT) 14) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_gr[((UINT) 14)] = opval;
  }
  {
    USI opval = FLD (i_disp8);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->branch (opval, npc, status);
  }
}

  current_cpu->done_cti_insn (npc, status);
  return status;
#undef FLD
}

// ********** bl24: bl.l $disp24

sem_status
m32rbf_sem_bl24 (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_bc24.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

{
  {
    SI opval = ADDSI (pc, 4);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << ((UINT) 14) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_gr[((UINT) 14)] = opval;
  }
  {
    USI opval = FLD (i_disp24);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->branch (opval, npc, status);
  }
}

  current_cpu->done_cti_insn (npc, status);
  return status;
#undef FLD
}

// ********** bnc8: bnc.s $disp8

sem_status
m32rbf_sem_bnc8 (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_bc8.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

if (NOTBI (current_cpu->hardware.h_cond)) {
  {
    USI opval = FLD (i_disp8);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->branch (opval, npc, status);
  }
}

  current_cpu->done_cti_insn (npc, status);
  return status;
#undef FLD
}

// ********** bnc24: bnc.l $disp24

sem_status
m32rbf_sem_bnc24 (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_bc24.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

if (NOTBI (current_cpu->hardware.h_cond)) {
  {
    USI opval = FLD (i_disp24);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->branch (opval, npc, status);
  }
}

  current_cpu->done_cti_insn (npc, status);
  return status;
#undef FLD
}

// ********** bne: bne $src1,$src2,$disp16

sem_status
m32rbf_sem_bne (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_beq.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

if (NESI (* FLD (i_src1), * FLD (i_src2))) {
  {
    USI opval = FLD (i_disp16);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->branch (opval, npc, status);
  }
}

  current_cpu->done_cti_insn (npc, status);
  return status;
#undef FLD
}

// ********** bra8: bra.s $disp8

sem_status
m32rbf_sem_bra8 (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_bc8.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    USI opval = FLD (i_disp8);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->branch (opval, npc, status);
  }

  current_cpu->done_cti_insn (npc, status);
  return status;
#undef FLD
}

// ********** bra24: bra.l $disp24

sem_status
m32rbf_sem_bra24 (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_bc24.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    USI opval = FLD (i_disp24);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->branch (opval, npc, status);
  }

  current_cpu->done_cti_insn (npc, status);
  return status;
#undef FLD
}

// ********** cmp: cmp $src1,$src2

sem_status
m32rbf_sem_cmp (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    BI opval = LTSI (* FLD (i_src1), * FLD (i_src2));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "cond" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_cond = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** cmpi: cmpi $src2,$simm16

sem_status
m32rbf_sem_cmpi (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    BI opval = LTSI (* FLD (i_src2), FLD (f_simm16));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "cond" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_cond = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** cmpu: cmpu $src1,$src2

sem_status
m32rbf_sem_cmpu (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    BI opval = LTUSI (* FLD (i_src1), * FLD (i_src2));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "cond" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_cond = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** cmpui: cmpui $src2,$simm16

sem_status
m32rbf_sem_cmpui (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    BI opval = LTUSI (* FLD (i_src2), FLD (f_simm16));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "cond" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_cond = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** div: div $dr,$sr

sem_status
m32rbf_sem_div (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

if (NESI (* FLD (i_sr), 0)) {
  {
    SI opval = DIVSI (* FLD (i_dr), * FLD (i_sr));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }
}

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** divu: divu $dr,$sr

sem_status
m32rbf_sem_divu (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

if (NESI (* FLD (i_sr), 0)) {
  {
    SI opval = UDIVSI (* FLD (i_dr), * FLD (i_sr));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }
}

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** rem: rem $dr,$sr

sem_status
m32rbf_sem_rem (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

if (NESI (* FLD (i_sr), 0)) {
  {
    SI opval = MODSI (* FLD (i_dr), * FLD (i_sr));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }
}

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** remu: remu $dr,$sr

sem_status
m32rbf_sem_remu (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

if (NESI (* FLD (i_sr), 0)) {
  {
    SI opval = UMODSI (* FLD (i_dr), * FLD (i_sr));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }
}

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** jl: jl $sr

sem_status
m32rbf_sem_jl (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_bset.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

{
  SI temp0;USI temp1;
  temp0 = ADDSI (ANDSI (pc, -4), 4);
  temp1 = ANDSI (* FLD (i_sr), -4);
  {
    SI opval = temp0;
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << ((UINT) 14) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_gr[((UINT) 14)] = opval;
  }
  {
    USI opval = temp1;
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->branch (opval, npc, status);
  }
}

  current_cpu->done_cti_insn (npc, status);
  return status;
#undef FLD
}

// ********** jmp: jmp $sr

sem_status
m32rbf_sem_jmp (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_bset.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    USI opval = ANDSI (* FLD (i_sr), -4);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->branch (opval, npc, status);
  }

  current_cpu->done_cti_insn (npc, status);
  return status;
#undef FLD
}

// ********** ld: ld $dr,@@$sr

sem_status
m32rbf_sem_ld (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = current_cpu->GETMEMSI (pc, * FLD (i_sr));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** ld-d: ld $dr,@@($slo16,$sr)

sem_status
m32rbf_sem_ld_d (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_add3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = current_cpu->GETMEMSI (pc, ADDSI (* FLD (i_sr), FLD (f_simm16)));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** ldb: ldb $dr,@@$sr

sem_status
m32rbf_sem_ldb (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = EXTQISI (current_cpu->GETMEMQI (pc, * FLD (i_sr)));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** ldb-d: ldb $dr,@@($slo16,$sr)

sem_status
m32rbf_sem_ldb_d (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_add3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = EXTQISI (current_cpu->GETMEMQI (pc, ADDSI (* FLD (i_sr), FLD (f_simm16))));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** ldh: ldh $dr,@@$sr

sem_status
m32rbf_sem_ldh (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = EXTHISI (current_cpu->GETMEMHI (pc, * FLD (i_sr)));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** ldh-d: ldh $dr,@@($slo16,$sr)

sem_status
m32rbf_sem_ldh_d (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_add3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = EXTHISI (current_cpu->GETMEMHI (pc, ADDSI (* FLD (i_sr), FLD (f_simm16))));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** ldub: ldub $dr,@@$sr

sem_status
m32rbf_sem_ldub (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = ZEXTQISI (current_cpu->GETMEMQI (pc, * FLD (i_sr)));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** ldub-d: ldub $dr,@@($slo16,$sr)

sem_status
m32rbf_sem_ldub_d (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_add3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = ZEXTQISI (current_cpu->GETMEMQI (pc, ADDSI (* FLD (i_sr), FLD (f_simm16))));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** lduh: lduh $dr,@@$sr

sem_status
m32rbf_sem_lduh (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = ZEXTHISI (current_cpu->GETMEMHI (pc, * FLD (i_sr)));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** lduh-d: lduh $dr,@@($slo16,$sr)

sem_status
m32rbf_sem_lduh_d (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_add3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = ZEXTHISI (current_cpu->GETMEMHI (pc, ADDSI (* FLD (i_sr), FLD (f_simm16))));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** ld-plus: ld $dr,@@$sr+

sem_status
m32rbf_sem_ld_plus (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

{
  SI temp0;SI temp1;
  temp0 = current_cpu->GETMEMSI (pc, * FLD (i_sr));
  temp1 = ADDSI (* FLD (i_sr), 4);
  {
    SI opval = temp0;
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }
  {
    SI opval = temp1;
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r2) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_sr) = opval;
  }
}

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** ld24: ld24 $dr,$uimm24

sem_status
m32rbf_sem_ld24 (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_ld24.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = FLD (i_uimm24);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** ldi8: ldi8 $dr,$simm8

sem_status
m32rbf_sem_ldi8 (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = FLD (f_simm8);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** ldi16: ldi16 $dr,$hash$slo16

sem_status
m32rbf_sem_ldi16 (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_add3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = FLD (f_simm16);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** lock: lock $dr,@@$sr

sem_status
m32rbf_sem_lock (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

{
  {
    BI opval = 1;
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "lock" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_lock = opval;
  }
  {
    SI opval = current_cpu->GETMEMSI (pc, * FLD (i_sr));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }
}

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** machi: machi $src1,$src2

sem_status
m32rbf_sem_machi (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    DI opval = SRADI (SLLDI (ADDDI (current_cpu->h_accum_get (), MULDI (EXTSIDI (ANDSI (* FLD (i_src1), 0xffff0000)), EXTHIDI (TRUNCSIHI (SRASI (* FLD (i_src2), 16))))), 8), 8);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "accum" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->h_accum_set (opval);
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** maclo: maclo $src1,$src2

sem_status
m32rbf_sem_maclo (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    DI opval = SRADI (SLLDI (ADDDI (current_cpu->h_accum_get (), MULDI (EXTSIDI (SLLSI (* FLD (i_src1), 16)), EXTHIDI (TRUNCSIHI (* FLD (i_src2))))), 8), 8);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "accum" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->h_accum_set (opval);
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** macwhi: macwhi $src1,$src2

sem_status
m32rbf_sem_macwhi (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    DI opval = SRADI (SLLDI (ADDDI (current_cpu->h_accum_get (), MULDI (EXTSIDI (* FLD (i_src1)), EXTHIDI (TRUNCSIHI (SRASI (* FLD (i_src2), 16))))), 8), 8);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "accum" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->h_accum_set (opval);
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** macwlo: macwlo $src1,$src2

sem_status
m32rbf_sem_macwlo (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    DI opval = SRADI (SLLDI (ADDDI (current_cpu->h_accum_get (), MULDI (EXTSIDI (* FLD (i_src1)), EXTHIDI (TRUNCSIHI (* FLD (i_src2))))), 8), 8);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "accum" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->h_accum_set (opval);
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** mul: mul $dr,$sr

sem_status
m32rbf_sem_mul (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = MULSI (* FLD (i_dr), * FLD (i_sr));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** mulhi: mulhi $src1,$src2

sem_status
m32rbf_sem_mulhi (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    DI opval = SRADI (SLLDI (MULDI (EXTSIDI (ANDSI (* FLD (i_src1), 0xffff0000)), EXTHIDI (TRUNCSIHI (SRASI (* FLD (i_src2), 16)))), 16), 16);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "accum" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->h_accum_set (opval);
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** mullo: mullo $src1,$src2

sem_status
m32rbf_sem_mullo (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    DI opval = SRADI (SLLDI (MULDI (EXTSIDI (SLLSI (* FLD (i_src1), 16)), EXTHIDI (TRUNCSIHI (* FLD (i_src2)))), 16), 16);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "accum" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->h_accum_set (opval);
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** mulwhi: mulwhi $src1,$src2

sem_status
m32rbf_sem_mulwhi (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    DI opval = SRADI (SLLDI (MULDI (EXTSIDI (* FLD (i_src1)), EXTHIDI (TRUNCSIHI (SRASI (* FLD (i_src2), 16)))), 8), 8);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "accum" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->h_accum_set (opval);
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** mulwlo: mulwlo $src1,$src2

sem_status
m32rbf_sem_mulwlo (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    DI opval = SRADI (SLLDI (MULDI (EXTSIDI (* FLD (i_src1)), EXTHIDI (TRUNCSIHI (* FLD (i_src2)))), 8), 8);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "accum" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->h_accum_set (opval);
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** mv: mv $dr,$sr

sem_status
m32rbf_sem_mv (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = * FLD (i_sr);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** mvfachi: mvfachi $dr

sem_status
m32rbf_sem_mvfachi (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_slli.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = TRUNCDISI (SRADI (current_cpu->h_accum_get (), 32));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** mvfaclo: mvfaclo $dr

sem_status
m32rbf_sem_mvfaclo (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_slli.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = TRUNCDISI (current_cpu->h_accum_get ());
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** mvfacmi: mvfacmi $dr

sem_status
m32rbf_sem_mvfacmi (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_slli.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = TRUNCDISI (SRADI (current_cpu->h_accum_get (), 16));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** mvfc: mvfc $dr,$scr

sem_status
m32rbf_sem_mvfc (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = current_cpu->h_cr_get (FLD (f_r2));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** mvtachi: mvtachi $src1

sem_status
m32rbf_sem_mvtachi (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    DI opval = ORDI (ANDDI (current_cpu->h_accum_get (), MAKEDI (0, 0xffffffff)), SLLDI (EXTSIDI (* FLD (i_src1)), 32));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "accum" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->h_accum_set (opval);
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** mvtaclo: mvtaclo $src1

sem_status
m32rbf_sem_mvtaclo (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    DI opval = ORDI (ANDDI (current_cpu->h_accum_get (), MAKEDI (0xffffffff, 0)), ZEXTSIDI (* FLD (i_src1)));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "accum" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->h_accum_set (opval);
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** mvtc: mvtc $sr,$dcr

sem_status
m32rbf_sem_mvtc (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    USI opval = * FLD (i_sr);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "cr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->h_cr_set (FLD (f_r1), opval);
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** neg: neg $dr,$sr

sem_status
m32rbf_sem_neg (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = NEGSI (* FLD (i_sr));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** nop: nop

sem_status
m32rbf_sem_nop (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

PROFILE_COUNT_FILLNOPS (current_cpu, abuf->addr);

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** not: not $dr,$sr

sem_status
m32rbf_sem_not (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = INVSI (* FLD (i_sr));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** rac: rac

sem_status
m32rbf_sem_rac (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

{
  DI tmp_tmp1;
  tmp_tmp1 = SLLDI (current_cpu->h_accum_get (), 1);
  tmp_tmp1 = ADDDI (tmp_tmp1, MAKEDI (0, 32768));
  {
    DI opval = (GTDI (tmp_tmp1, MAKEDI (32767, 0xffff0000))) ? (MAKEDI (32767, 0xffff0000)) : (LTDI (tmp_tmp1, MAKEDI (0xffff8000, 0))) ? (MAKEDI (0xffff8000, 0)) : (ANDDI (tmp_tmp1, MAKEDI (0xffffffff, 0xffff0000)));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "accum" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->h_accum_set (opval);
  }
}

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** rach: rach

sem_status
m32rbf_sem_rach (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

{
  DI tmp_tmp1;
  tmp_tmp1 = ANDDI (current_cpu->h_accum_get (), MAKEDI (16777215, 0xffffffff));
if (ANDIF (GEDI (tmp_tmp1, MAKEDI (16383, 0x80000000)), LEDI (tmp_tmp1, MAKEDI (8388607, 0xffffffff)))) {
  tmp_tmp1 = MAKEDI (16383, 0x80000000);
} else {
if (ANDIF (GEDI (tmp_tmp1, MAKEDI (8388608, 0)), LEDI (tmp_tmp1, MAKEDI (16760832, 0)))) {
  tmp_tmp1 = MAKEDI (16760832, 0);
} else {
  tmp_tmp1 = ANDDI (ADDDI (current_cpu->h_accum_get (), MAKEDI (0, 1073741824)), MAKEDI (0xffffffff, 0x80000000));
}
}
  tmp_tmp1 = SLLDI (tmp_tmp1, 1);
  {
    DI opval = SRADI (SLLDI (tmp_tmp1, 7), 7);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "accum" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->h_accum_set (opval);
  }
}

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** rte: rte

sem_status
m32rbf_sem_rte (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

{
  {
    USI opval = ANDSI (current_cpu->h_cr_get (((UINT) 6)), -4);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->branch (opval, npc, status);
  }
  {
    USI opval = current_cpu->h_cr_get (((UINT) 14));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "cr" << '[' << ((UINT) 6) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->h_cr_set (((UINT) 6), opval);
  }
  {
    UQI opval = current_cpu->hardware.h_bpsw;
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "psw" << ":=0x" << hex << (USI) opval << dec << "  ";
    current_cpu->h_psw_set (opval);
  }
  {
    UQI opval = current_cpu->hardware.h_bbpsw;
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "bpsw" << ":=0x" << hex << (USI) opval << dec << "  ";
    current_cpu->hardware.h_bpsw = opval;
  }
}

  current_cpu->done_cti_insn (npc, status);
  return status;
#undef FLD
}

// ********** seth: seth $dr,$hash$hi16

sem_status
m32rbf_sem_seth (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_seth.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = SLLSI (FLD (f_hi16), 16);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** sll: sll $dr,$sr

sem_status
m32rbf_sem_sll (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = SLLSI (* FLD (i_dr), ANDSI (* FLD (i_sr), 31));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** sll3: sll3 $dr,$sr,$simm16

sem_status
m32rbf_sem_sll3 (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_add3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = SLLSI (* FLD (i_sr), ANDSI (FLD (f_simm16), 31));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** slli: slli $dr,$uimm5

sem_status
m32rbf_sem_slli (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_slli.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = SLLSI (* FLD (i_dr), FLD (f_uimm5));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** sra: sra $dr,$sr

sem_status
m32rbf_sem_sra (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = SRASI (* FLD (i_dr), ANDSI (* FLD (i_sr), 31));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** sra3: sra3 $dr,$sr,$simm16

sem_status
m32rbf_sem_sra3 (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_add3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = SRASI (* FLD (i_sr), ANDSI (FLD (f_simm16), 31));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** srai: srai $dr,$uimm5

sem_status
m32rbf_sem_srai (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_slli.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = SRASI (* FLD (i_dr), FLD (f_uimm5));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** srl: srl $dr,$sr

sem_status
m32rbf_sem_srl (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = SRLSI (* FLD (i_dr), ANDSI (* FLD (i_sr), 31));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** srl3: srl3 $dr,$sr,$simm16

sem_status
m32rbf_sem_srl3 (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_add3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = SRLSI (* FLD (i_sr), ANDSI (FLD (f_simm16), 31));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** srli: srli $dr,$uimm5

sem_status
m32rbf_sem_srli (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_slli.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = SRLSI (* FLD (i_dr), FLD (f_uimm5));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** st: st $src1,@@$src2

sem_status
m32rbf_sem_st (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = * FLD (i_src1);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "memory" << '[' <<  "0x" << hex << (UDI) * FLD (i_src2) << dec << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->SETMEMSI (pc, * FLD (i_src2), opval);
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** st-d: st $src1,@@($slo16,$src2)

sem_status
m32rbf_sem_st_d (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = * FLD (i_src1);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "memory" << '[' <<  "0x" << hex << (UDI) ADDSI (* FLD (i_src2), FLD (f_simm16)) << dec << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->SETMEMSI (pc, ADDSI (* FLD (i_src2), FLD (f_simm16)), opval);
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** stb: stb $src1,@@$src2

sem_status
m32rbf_sem_stb (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    QI opval = * FLD (i_src1);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "memory" << '[' <<  "0x" << hex << (UDI) * FLD (i_src2) << dec << ']' << ":=0x" << hex << (SI) opval << dec << "  ";
    current_cpu->SETMEMQI (pc, * FLD (i_src2), opval);
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** stb-d: stb $src1,@@($slo16,$src2)

sem_status
m32rbf_sem_stb_d (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    QI opval = * FLD (i_src1);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "memory" << '[' <<  "0x" << hex << (UDI) ADDSI (* FLD (i_src2), FLD (f_simm16)) << dec << ']' << ":=0x" << hex << (SI) opval << dec << "  ";
    current_cpu->SETMEMQI (pc, ADDSI (* FLD (i_src2), FLD (f_simm16)), opval);
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** sth: sth $src1,@@$src2

sem_status
m32rbf_sem_sth (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    HI opval = * FLD (i_src1);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "memory" << '[' <<  "0x" << hex << (UDI) * FLD (i_src2) << dec << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->SETMEMHI (pc, * FLD (i_src2), opval);
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** sth-d: sth $src1,@@($slo16,$src2)

sem_status
m32rbf_sem_sth_d (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    HI opval = * FLD (i_src1);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "memory" << '[' <<  "0x" << hex << (UDI) ADDSI (* FLD (i_src2), FLD (f_simm16)) << dec << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->SETMEMHI (pc, ADDSI (* FLD (i_src2), FLD (f_simm16)), opval);
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** st-plus: st $src1,@@+$src2

sem_status
m32rbf_sem_st_plus (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

{
  SI tmp_new_src2;
  tmp_new_src2 = ADDSI (* FLD (i_src2), 4);
  {
    SI opval = * FLD (i_src1);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "memory" << '[' <<  "0x" << hex << (UDI) tmp_new_src2 << dec << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->SETMEMSI (pc, tmp_new_src2, opval);
  }
  {
    SI opval = tmp_new_src2;
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r2) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_src2) = opval;
  }
}

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** st-minus: st $src1,@@-$src2

sem_status
m32rbf_sem_st_minus (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

{
  SI tmp_new_src2;
  tmp_new_src2 = SUBSI (* FLD (i_src2), 4);
  {
    SI opval = * FLD (i_src1);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "memory" << '[' <<  "0x" << hex << (UDI) tmp_new_src2 << dec << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->SETMEMSI (pc, tmp_new_src2, opval);
  }
  {
    SI opval = tmp_new_src2;
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r2) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_src2) = opval;
  }
}

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** sub: sub $dr,$sr

sem_status
m32rbf_sem_sub (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    SI opval = SUBSI (* FLD (i_dr), * FLD (i_sr));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** subv: subv $dr,$sr

sem_status
m32rbf_sem_subv (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

{
  SI temp0;BI temp1;
  temp0 = SUBSI (* FLD (i_dr), * FLD (i_sr));
  temp1 = SUBOFSI (* FLD (i_dr), * FLD (i_sr), 0);
  {
    SI opval = temp0;
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }
  {
    BI opval = temp1;
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "cond" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_cond = opval;
  }
}

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** subx: subx $dr,$sr

sem_status
m32rbf_sem_subx (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_and3.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

{
  SI temp0;BI temp1;
  temp0 = SUBCSI (* FLD (i_dr), * FLD (i_sr), current_cpu->hardware.h_cond);
  temp1 = SUBCFSI (* FLD (i_dr), * FLD (i_sr), current_cpu->hardware.h_cond);
  {
    SI opval = temp0;
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "gr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
    * FLD (i_dr) = opval;
  }
  {
    BI opval = temp1;
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "cond" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_cond = opval;
  }
}

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** trap: trap $uimm4

sem_status
m32rbf_sem_trap (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_trap.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

{
  {
    USI opval = current_cpu->h_cr_get (((UINT) 6));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "cr" << '[' << ((UINT) 14) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->h_cr_set (((UINT) 14), opval);
  }
  {
    USI opval = ADDSI (pc, 4);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "cr" << '[' << ((UINT) 6) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->h_cr_set (((UINT) 6), opval);
  }
  {
    UQI opval = current_cpu->hardware.h_bpsw;
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "bbpsw" << ":=0x" << hex << (USI) opval << dec << "  ";
    current_cpu->hardware.h_bbpsw = opval;
  }
  {
    UQI opval = current_cpu->h_psw_get ();
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "bpsw" << ":=0x" << hex << (USI) opval << dec << "  ";
    current_cpu->hardware.h_bpsw = opval;
  }
  {
    UQI opval = ANDQI (current_cpu->h_psw_get (), 128);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "psw" << ":=0x" << hex << (USI) opval << dec << "  ";
    current_cpu->h_psw_set (opval);
  }
  {
    SI opval = current_cpu->m32r_trap (pc, FLD (f_uimm4));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->branch (opval, npc, status);
  }
}

  current_cpu->done_cti_insn (npc, status);
  return status;
#undef FLD
}

// ********** unlock: unlock $src1,@@$src2

sem_status
m32rbf_sem_unlock (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_st_d.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

{
if (current_cpu->hardware.h_lock) {
  {
    SI opval = * FLD (i_src1);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "memory" << '[' <<  "0x" << hex << (UDI) * FLD (i_src2) << dec << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->SETMEMSI (pc, * FLD (i_src2), opval);
  }
}
  {
    BI opval = 0;
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "lock" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_lock = opval;
  }
}

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** clrpsw: clrpsw $uimm8

sem_status
m32rbf_sem_clrpsw (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_clrpsw.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    USI opval = ANDSI (current_cpu->h_cr_get (((UINT) 0)), ORSI (ZEXTQISI (INVQI (FLD (f_uimm8))), 65280));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "cr" << '[' << ((UINT) 0) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->h_cr_set (((UINT) 0), opval);
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** setpsw: setpsw $uimm8

sem_status
m32rbf_sem_setpsw (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_clrpsw.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    USI opval = FLD (f_uimm8);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "cr" << '[' << ((UINT) 0) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->h_cr_set (((UINT) 0), opval);
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** bset: bset $uimm3,@@($slo16,$sr)

sem_status
m32rbf_sem_bset (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_bset.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    QI opval = ORQI (current_cpu->GETMEMQI (pc, ADDSI (* FLD (i_sr), FLD (f_simm16))), SLLQI (1, SUBSI (7, FLD (f_uimm3))));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "memory" << '[' <<  "0x" << hex << (UDI) ADDSI (* FLD (i_sr), FLD (f_simm16)) << dec << ']' << ":=0x" << hex << (SI) opval << dec << "  ";
    current_cpu->SETMEMQI (pc, ADDSI (* FLD (i_sr), FLD (f_simm16)), opval);
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** bclr: bclr $uimm3,@@($slo16,$sr)

sem_status
m32rbf_sem_bclr (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_bset.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    QI opval = ANDQI (current_cpu->GETMEMQI (pc, ADDSI (* FLD (i_sr), FLD (f_simm16))), INVQI (SLLQI (1, SUBSI (7, FLD (f_uimm3)))));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "memory" << '[' <<  "0x" << hex << (UDI) ADDSI (* FLD (i_sr), FLD (f_simm16)) << dec << ']' << ":=0x" << hex << (SI) opval << dec << "  ";
    current_cpu->SETMEMQI (pc, ADDSI (* FLD (i_sr), FLD (f_simm16)), opval);
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

// ********** btst: btst $uimm3,$sr

sem_status
m32rbf_sem_btst (m32rbf_cpu* current_cpu, m32rbf_scache* sem)
{
#define FLD(f) abuf->fields.sfmt_bset.f
  sem_status status = SEM_STATUS_NORMAL;
  m32rbf_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 2;

  {
    BI opval = ANDQI (SRLQI (* FLD (i_sr), SUBSI (7, FLD (f_uimm3))), 1);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "cond" << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_cond = opval;
  }

  current_cpu->done_insn (npc, status);
  return status;
#undef FLD
}

@


1.8
log
@Regenerate cgen files, update copyright year.
@
text
@d27 1
a27 1
#define FLD(f) abuf->fields.fmt_empty.f
d1793 1
a1793 1
#define FLD(f) abuf->fields.fmt_empty.f
d1834 1
a1834 1
#define FLD(f) abuf->fields.fmt_empty.f
d1862 1
a1862 1
#define FLD(f) abuf->fields.fmt_empty.f
d1899 1
a1899 1
#define FLD(f) abuf->fields.fmt_empty.f
@


1.7
log
@	* cgen-cpu.h: Update for new location of cgen/bitset.h.
	* tracedis.h: Ditto.

Plus update generated files to pick up two cgen changes:
1)
	* desc-cpu.scm (/gen-hash-defines): Remove #include of cgen-bitset.h.
	* sid-cpu.scm (cgen-desc.h): Update location of cgen's bitset.h.
2)
	* utils-sim.scm (/gen-set-itype-and-extract): New function.
	(/gen-bracketed-set-itype-and-extract): New function.
	(/gen-decode-default-entry): Rewrite.
	(/table-guts-to-mask, /all-opcode-bits-used?): New functions.
	(/gen-decode-insn-entry): New arg table-guts-thus-far, all callers
	updated.  Don't unnecessarily emit check for whether all opcode bits
	have been examined.
	(/gen-decode-expr-set-itype): Delete.
	(/gen-decode-expr-entry): Update.
	(/gen-decode-table-entry): New arg table-guts-thus-far, all callers
	updated.  Keep track of decoder tables used thus far.
	(/gen-decoder-switch): Ditto.
@
text
@d5 1
a5 1
Copyright (C) 2000-2009 Red Hat, Inc.
@


1.6
log
@2006-10-18  Dave Brolley  <brolley@@redhat.com>

        * Contribute the following changes:

        2006-05-11  Dave Brolley  <brolley@@redhat.com>

        * configure.in: Add sh support.
        * compCGEN.cxx: #include sh* cpu headers.
        (compCGENListTypes): List hw-cpu-sh*.
        (compCGENCreate): Handle hw-cpu-sh*.
        * sh: New directory.
@
text
@d5 1
a5 1
Copyright (C) 2000-2005 Red Hat, Inc.
d2562 1
a2562 1
    SI opval = ANDSI (current_cpu->h_cr_get (((UINT) 0)), ORSI (INVBI (FLD (f_uimm8)), 65280));
d2585 1
a2585 1
    SI opval = FLD (f_uimm8);
d2608 1
a2608 1
    QI opval = ORQI (current_cpu->GETMEMQI (pc, ADDSI (* FLD (i_sr), FLD (f_simm16))), SLLSI (1, SUBSI (7, FLD (f_uimm3))));
d2631 1
a2631 1
    QI opval = ANDQI (current_cpu->GETMEMQI (pc, ADDSI (* FLD (i_sr), FLD (f_simm16))), INVQI (SLLSI (1, SUBSI (7, FLD (f_uimm3)))));
d2654 1
a2654 1
    BI opval = ANDQI (SRLSI (* FLD (i_sr), SUBSI (7, FLD (f_uimm3))), 1);
@


1.5
log
@Regenerate cgen files (not due to any recent changes, just want to
establish a reference point).
@
text
@d5 1
a5 1
Copyright (C) 2000, 2001, 2002, 2003 Red Hat, Inc.
a18 1

a56 1
    * FLD (i_dr) = opval;
d59 1
a79 1
    * FLD (i_dr) = opval;
d82 1
a102 1
    * FLD (i_dr) = opval;
d105 1
a125 1
    * FLD (i_dr) = opval;
d128 1
a148 1
    * FLD (i_dr) = opval;
d151 1
a171 1
    * FLD (i_dr) = opval;
d174 1
a194 1
    * FLD (i_dr) = opval;
d197 1
a217 1
    * FLD (i_dr) = opval;
d220 1
a240 1
    * FLD (i_dr) = opval;
d243 1
a267 1
    * FLD (i_dr) = opval;
d270 1
a273 1
    current_cpu->hardware.h_cond = opval;
d276 1
a301 1
    * FLD (i_dr) = opval;
d304 1
a307 1
    current_cpu->hardware.h_cond = opval;
d310 1
a335 1
    * FLD (i_dr) = opval;
d338 1
a341 1
    current_cpu->hardware.h_cond = opval;
d344 1
a366 1
    current_cpu->branch (opval, npc, status);
d369 1
a391 1
    current_cpu->branch (opval, npc, status);
d394 1
a416 1
    current_cpu->branch (opval, npc, status);
d419 1
a441 1
    current_cpu->branch (opval, npc, status);
d444 1
a466 1
    current_cpu->branch (opval, npc, status);
d469 1
a491 1
    current_cpu->branch (opval, npc, status);
d494 1
a516 1
    current_cpu->branch (opval, npc, status);
d519 1
a541 1
    current_cpu->branch (opval, npc, status);
d544 1
a566 1
    current_cpu->branch (opval, npc, status);
d569 1
a591 1
    current_cpu->hardware.h_gr[((UINT) 14)] = opval;
d594 1
a597 1
    current_cpu->branch (opval, npc, status);
d600 1
a622 1
    current_cpu->hardware.h_gr[((UINT) 14)] = opval;
d625 1
a628 1
    current_cpu->branch (opval, npc, status);
d631 1
a653 1
    current_cpu->branch (opval, npc, status);
d656 1
a678 1
    current_cpu->branch (opval, npc, status);
d681 1
a703 1
    current_cpu->branch (opval, npc, status);
d706 1
a727 1
    current_cpu->branch (opval, npc, status);
d730 1
a750 1
    current_cpu->branch (opval, npc, status);
d753 1
a773 1
    current_cpu->hardware.h_cond = opval;
d776 1
a796 1
    current_cpu->hardware.h_cond = opval;
d799 1
a819 1
    current_cpu->hardware.h_cond = opval;
d822 1
a842 1
    current_cpu->hardware.h_cond = opval;
d845 1
a866 1
    * FLD (i_dr) = opval;
d869 1
a891 1
    * FLD (i_dr) = opval;
d894 1
a916 1
    * FLD (i_dr) = opval;
d919 1
a941 1
    * FLD (i_dr) = opval;
d944 1
d958 1
a958 1
#define FLD(f) abuf->fields.sfmt_and3.f
a969 1
    current_cpu->hardware.h_gr[((UINT) 14)] = opval;
d972 1
a975 1
    current_cpu->branch (opval, npc, status);
d978 1
d992 1
a992 1
#define FLD(f) abuf->fields.sfmt_and3.f
a999 1
    current_cpu->branch (opval, npc, status);
d1002 1
a1022 1
    * FLD (i_dr) = opval;
d1025 1
a1045 1
    * FLD (i_dr) = opval;
d1048 1
a1068 1
    * FLD (i_dr) = opval;
d1071 1
a1091 1
    * FLD (i_dr) = opval;
d1094 1
a1114 1
    * FLD (i_dr) = opval;
d1117 1
a1137 1
    * FLD (i_dr) = opval;
d1140 1
a1160 1
    * FLD (i_dr) = opval;
d1163 1
a1183 1
    * FLD (i_dr) = opval;
d1186 1
a1206 1
    * FLD (i_dr) = opval;
d1209 1
a1229 1
    * FLD (i_dr) = opval;
d1232 1
a1256 1
    * FLD (i_dr) = opval;
d1259 1
a1262 1
    * FLD (i_sr) = opval;
d1265 1
a1286 1
    * FLD (i_dr) = opval;
d1289 1
a1309 1
    * FLD (i_dr) = opval;
d1312 1
a1332 1
    * FLD (i_dr) = opval;
d1335 1
a1356 1
    current_cpu->hardware.h_lock = opval;
d1359 1
a1362 1
    * FLD (i_dr) = opval;
d1365 1
a1386 1
    current_cpu->h_accum_set (opval);
d1389 1
a1409 1
    current_cpu->h_accum_set (opval);
d1412 1
a1432 1
    current_cpu->h_accum_set (opval);
d1435 1
a1455 1
    current_cpu->h_accum_set (opval);
d1458 1
a1478 1
    * FLD (i_dr) = opval;
d1481 1
a1501 1
    current_cpu->h_accum_set (opval);
d1504 1
a1524 1
    current_cpu->h_accum_set (opval);
d1527 1
a1547 1
    current_cpu->h_accum_set (opval);
d1550 1
a1570 1
    current_cpu->h_accum_set (opval);
d1573 1
a1593 1
    * FLD (i_dr) = opval;
d1596 1
a1616 1
    * FLD (i_dr) = opval;
d1619 1
a1639 1
    * FLD (i_dr) = opval;
d1642 1
a1662 1
    * FLD (i_dr) = opval;
d1665 1
a1685 1
    * FLD (i_dr) = opval;
d1688 1
a1708 1
    current_cpu->h_accum_set (opval);
d1711 1
a1731 1
    current_cpu->h_accum_set (opval);
d1734 1
a1754 1
    current_cpu->h_cr_set (FLD (f_r1), opval);
d1757 1
a1777 1
    * FLD (i_dr) = opval;
d1780 1
a1818 1
    * FLD (i_dr) = opval;
d1821 1
a1845 1
    current_cpu->h_accum_set (opval);
d1848 1
a1882 1
    current_cpu->h_accum_set (opval);
d1885 1
a1907 1
    current_cpu->branch (opval, npc, status);
d1910 1
a1913 1
    current_cpu->h_cr_set (((UINT) 6), opval);
d1916 1
a1919 1
    current_cpu->h_psw_set (opval);
d1922 1
a1925 1
    current_cpu->hardware.h_bpsw = opval;
d1928 1
a1949 1
    * FLD (i_dr) = opval;
d1952 1
a1972 1
    * FLD (i_dr) = opval;
d1975 1
a1995 1
    * FLD (i_dr) = opval;
d1998 1
a2018 1
    * FLD (i_dr) = opval;
d2021 1
a2041 1
    * FLD (i_dr) = opval;
d2044 1
a2064 1
    * FLD (i_dr) = opval;
d2067 1
a2087 1
    * FLD (i_dr) = opval;
d2090 1
a2110 1
    * FLD (i_dr) = opval;
d2113 1
a2133 1
    * FLD (i_dr) = opval;
d2136 1
a2156 1
    * FLD (i_dr) = opval;
d2159 1
a2179 1
    current_cpu->SETMEMSI (pc, * FLD (i_src2), opval);
d2182 1
a2202 1
    current_cpu->SETMEMSI (pc, ADDSI (* FLD (i_src2), FLD (f_simm16)), opval);
d2205 1
a2225 1
    current_cpu->SETMEMQI (pc, * FLD (i_src2), opval);
d2228 1
a2248 1
    current_cpu->SETMEMQI (pc, ADDSI (* FLD (i_src2), FLD (f_simm16)), opval);
d2251 1
a2271 1
    current_cpu->SETMEMHI (pc, * FLD (i_src2), opval);
d2274 1
a2294 1
    current_cpu->SETMEMHI (pc, ADDSI (* FLD (i_src2), FLD (f_simm16)), opval);
d2297 1
a2320 1
    current_cpu->SETMEMSI (pc, tmp_new_src2, opval);
d2323 1
a2326 1
    * FLD (i_src2) = opval;
d2329 1
a2353 1
    current_cpu->SETMEMSI (pc, tmp_new_src2, opval);
d2356 1
a2359 1
    * FLD (i_src2) = opval;
d2362 1
a2383 1
    * FLD (i_dr) = opval;
d2386 1
a2410 1
    * FLD (i_dr) = opval;
d2413 1
a2416 1
    current_cpu->hardware.h_cond = opval;
d2419 1
a2444 1
    * FLD (i_dr) = opval;
d2447 1
a2450 1
    current_cpu->hardware.h_cond = opval;
d2453 1
a2475 1
    current_cpu->h_cr_set (((UINT) 14), opval);
d2478 1
a2481 1
    current_cpu->h_cr_set (((UINT) 6), opval);
d2484 1
a2487 1
    current_cpu->hardware.h_bbpsw = opval;
d2490 1
a2493 1
    current_cpu->hardware.h_bpsw = opval;
d2496 1
a2499 1
    current_cpu->h_psw_set (opval);
d2502 1
a2505 1
    current_cpu->branch (opval, npc, status);
d2508 1
a2531 1
    current_cpu->SETMEMSI (pc, * FLD (i_src2), opval);
d2534 1
d2539 2
d2542 67
d2610 25
a2634 1
      current_cpu->trace_stream << "lock" << ":=0x" << hex << opval << dec << "  ";
d2636 4
d2642 18
@


1.4
log
@* branch probability hinting

[cgen/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* sid.cpu (-op-gen-set-trace[-parallel], -create-virtual-insns!):
	Emit LIKELY/UNLIKELY branch probability hints.
	* sid-decode.cpu (-gen-record-args): Ditto.

[sid/include/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* sidconfig.h (LIKELY, UNLIKELY): New conditional cover macros
	for gcc's __builtin_expect branch probability hinting function.
	* sidbusutil.h (passthrough_bus, mux_password_bus, harvard_bus):
	Add some branch probability hints.
	* sidcpuutil.h (step_pin_handler, stop_after_insns_p,
	{read,write}_{insn,data}_memory): Ditto.
	* sidpinutil.h (callback_pin::driven): Remove unnecessary assert
	from critical path.

[eg. sid/component/mapper/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* compMapper.cxx ({read,write}_strideoffset_any): Added b.p. hints.
	(write_any, read_any, locate): Ditto.

[sid/component/cgen-cpu/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* cgen-engine.h (set_pbb_engine, chain, get_next_vpc, pbb_find,
	pbb_find_or_alloc, pbb_before, pbb_after): Add branch probability
	hints.

[eg. sid/component/cgen-cpu/arm7t/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* arm-decode.cxx, -sem.cxx, -semsw.cxx: Regenerated w/ b.p. hints.
	* thumb-decode.cxx, -sem.cxx, -semsw.cxx: Ditto.
@
text
@d5 1
a5 1
Copyright (C) 2000 Red Hat, Inc.
d7 1
a7 1
This file is part of the Cygnus Simulators.
d13 3
@


1.3
log
@[arm7t/ChangeLog]
2001-01-26  Frank Ch. Eigler  <fche@@redhat.com>

	* arm-decode.h, -sem.cxx: Regenerated with more tracing improvements,
	* thumb-decode.h, -sem.cxx: Ditto.

[m32r/ChangeLog]
2001-01-26  Frank Ch. Eigler  <fche@@redhat.com>

	* m32r-decode.h, -sem.cxx: Regenerated with more tracing improvements.
@
text
@d56 1
a56 1
    if (current_cpu->trace_result_p)
d79 1
a79 1
    if (current_cpu->trace_result_p)
d102 1
a102 1
    if (current_cpu->trace_result_p)
d125 1
a125 1
    if (current_cpu->trace_result_p)
d148 1
a148 1
    if (current_cpu->trace_result_p)
d171 1
a171 1
    if (current_cpu->trace_result_p)
d194 1
a194 1
    if (current_cpu->trace_result_p)
d217 1
a217 1
    if (current_cpu->trace_result_p)
d240 1
a240 1
    if (current_cpu->trace_result_p)
d267 1
a267 1
    if (current_cpu->trace_result_p)
d273 1
a273 1
    if (current_cpu->trace_result_p)
d301 1
a301 1
    if (current_cpu->trace_result_p)
d307 1
a307 1
    if (current_cpu->trace_result_p)
d335 1
a335 1
    if (current_cpu->trace_result_p)
d341 1
a341 1
    if (current_cpu->trace_result_p)
d366 1
a366 1
    if (current_cpu->trace_result_p)
d391 1
a391 1
    if (current_cpu->trace_result_p)
d416 1
a416 1
    if (current_cpu->trace_result_p)
d441 1
a441 1
    if (current_cpu->trace_result_p)
d466 1
a466 1
    if (current_cpu->trace_result_p)
d491 1
a491 1
    if (current_cpu->trace_result_p)
d516 1
a516 1
    if (current_cpu->trace_result_p)
d541 1
a541 1
    if (current_cpu->trace_result_p)
d566 1
a566 1
    if (current_cpu->trace_result_p)
d591 1
a591 1
    if (current_cpu->trace_result_p)
d597 1
a597 1
    if (current_cpu->trace_result_p)
d622 1
a622 1
    if (current_cpu->trace_result_p)
d628 1
a628 1
    if (current_cpu->trace_result_p)
d653 1
a653 1
    if (current_cpu->trace_result_p)
d678 1
a678 1
    if (current_cpu->trace_result_p)
d703 1
a703 1
    if (current_cpu->trace_result_p)
d727 1
a727 1
    if (current_cpu->trace_result_p)
d750 1
a750 1
    if (current_cpu->trace_result_p)
d773 1
a773 1
    if (current_cpu->trace_result_p)
d796 1
a796 1
    if (current_cpu->trace_result_p)
d819 1
a819 1
    if (current_cpu->trace_result_p)
d842 1
a842 1
    if (current_cpu->trace_result_p)
d866 1
a866 1
    if (current_cpu->trace_result_p)
d891 1
a891 1
    if (current_cpu->trace_result_p)
d916 1
a916 1
    if (current_cpu->trace_result_p)
d941 1
a941 1
    if (current_cpu->trace_result_p)
d969 1
a969 1
    if (current_cpu->trace_result_p)
d975 1
a975 1
    if (current_cpu->trace_result_p)
d999 1
a999 1
    if (current_cpu->trace_result_p)
d1022 1
a1022 1
    if (current_cpu->trace_result_p)
d1045 1
a1045 1
    if (current_cpu->trace_result_p)
d1068 1
a1068 1
    if (current_cpu->trace_result_p)
d1091 1
a1091 1
    if (current_cpu->trace_result_p)
d1114 1
a1114 1
    if (current_cpu->trace_result_p)
d1137 1
a1137 1
    if (current_cpu->trace_result_p)
d1160 1
a1160 1
    if (current_cpu->trace_result_p)
d1183 1
a1183 1
    if (current_cpu->trace_result_p)
d1206 1
a1206 1
    if (current_cpu->trace_result_p)
d1229 1
a1229 1
    if (current_cpu->trace_result_p)
d1256 1
a1256 1
    if (current_cpu->trace_result_p)
d1262 1
a1262 1
    if (current_cpu->trace_result_p)
d1286 1
a1286 1
    if (current_cpu->trace_result_p)
d1309 1
a1309 1
    if (current_cpu->trace_result_p)
d1332 1
a1332 1
    if (current_cpu->trace_result_p)
d1356 1
a1356 1
    if (current_cpu->trace_result_p)
d1362 1
a1362 1
    if (current_cpu->trace_result_p)
d1386 1
a1386 1
    if (current_cpu->trace_result_p)
d1409 1
a1409 1
    if (current_cpu->trace_result_p)
d1432 1
a1432 1
    if (current_cpu->trace_result_p)
d1455 1
a1455 1
    if (current_cpu->trace_result_p)
d1478 1
a1478 1
    if (current_cpu->trace_result_p)
d1501 1
a1501 1
    if (current_cpu->trace_result_p)
d1524 1
a1524 1
    if (current_cpu->trace_result_p)
d1547 1
a1547 1
    if (current_cpu->trace_result_p)
d1570 1
a1570 1
    if (current_cpu->trace_result_p)
d1593 1
a1593 1
    if (current_cpu->trace_result_p)
d1616 1
a1616 1
    if (current_cpu->trace_result_p)
d1639 1
a1639 1
    if (current_cpu->trace_result_p)
d1662 1
a1662 1
    if (current_cpu->trace_result_p)
d1685 1
a1685 1
    if (current_cpu->trace_result_p)
d1708 1
a1708 1
    if (current_cpu->trace_result_p)
d1731 1
a1731 1
    if (current_cpu->trace_result_p)
d1754 1
a1754 1
    if (current_cpu->trace_result_p)
d1777 1
a1777 1
    if (current_cpu->trace_result_p)
d1818 1
a1818 1
    if (current_cpu->trace_result_p)
d1845 1
a1845 1
    if (current_cpu->trace_result_p)
d1882 1
a1882 1
    if (current_cpu->trace_result_p)
d1907 1
a1907 1
    if (current_cpu->trace_result_p)
d1913 1
a1913 1
    if (current_cpu->trace_result_p)
d1919 1
a1919 1
    if (current_cpu->trace_result_p)
d1925 1
a1925 1
    if (current_cpu->trace_result_p)
d1949 1
a1949 1
    if (current_cpu->trace_result_p)
d1972 1
a1972 1
    if (current_cpu->trace_result_p)
d1995 1
a1995 1
    if (current_cpu->trace_result_p)
d2018 1
a2018 1
    if (current_cpu->trace_result_p)
d2041 1
a2041 1
    if (current_cpu->trace_result_p)
d2064 1
a2064 1
    if (current_cpu->trace_result_p)
d2087 1
a2087 1
    if (current_cpu->trace_result_p)
d2110 1
a2110 1
    if (current_cpu->trace_result_p)
d2133 1
a2133 1
    if (current_cpu->trace_result_p)
d2156 1
a2156 1
    if (current_cpu->trace_result_p)
d2179 1
a2179 1
    if (current_cpu->trace_result_p)
d2202 1
a2202 1
    if (current_cpu->trace_result_p)
d2225 1
a2225 1
    if (current_cpu->trace_result_p)
d2248 1
a2248 1
    if (current_cpu->trace_result_p)
d2271 1
a2271 1
    if (current_cpu->trace_result_p)
d2294 1
a2294 1
    if (current_cpu->trace_result_p)
d2320 1
a2320 1
    if (current_cpu->trace_result_p)
d2326 1
a2326 1
    if (current_cpu->trace_result_p)
d2353 1
a2353 1
    if (current_cpu->trace_result_p)
d2359 1
a2359 1
    if (current_cpu->trace_result_p)
d2383 1
a2383 1
    if (current_cpu->trace_result_p)
d2410 1
a2410 1
    if (current_cpu->trace_result_p)
d2416 1
a2416 1
    if (current_cpu->trace_result_p)
d2444 1
a2444 1
    if (current_cpu->trace_result_p)
d2450 1
a2450 1
    if (current_cpu->trace_result_p)
d2475 1
a2475 1
    if (current_cpu->trace_result_p)
d2481 1
a2481 1
    if (current_cpu->trace_result_p)
d2487 1
a2487 1
    if (current_cpu->trace_result_p)
d2493 1
a2493 1
    if (current_cpu->trace_result_p)
d2499 1
a2499 1
    if (current_cpu->trace_result_p)
d2505 1
a2505 1
    if (current_cpu->trace_result_p)
d2531 1
a2531 1
    if (current_cpu->trace_result_p)
d2538 1
a2538 1
    if (current_cpu->trace_result_p)
@


1.2
log
@* regen after cgen trace improvements
@
text
@d57 1
a57 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d80 1
a80 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d103 1
a103 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d126 1
a126 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d149 1
a149 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d172 1
a172 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d195 1
a195 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d218 1
a218 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d241 1
a241 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d268 1
a268 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d274 1
a274 1
      current_cpu->trace_stream << "condbit" << ":=0x" << hex << opval << dec << "  ";
d302 1
a302 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d308 1
a308 1
      current_cpu->trace_stream << "condbit" << ":=0x" << hex << opval << dec << "  ";
d336 1
a336 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d342 1
a342 1
      current_cpu->trace_stream << "condbit" << ":=0x" << hex << opval << dec << "  ";
d774 1
a774 1
      current_cpu->trace_stream << "condbit" << ":=0x" << hex << opval << dec << "  ";
d797 1
a797 1
      current_cpu->trace_stream << "condbit" << ":=0x" << hex << opval << dec << "  ";
d820 1
a820 1
      current_cpu->trace_stream << "condbit" << ":=0x" << hex << opval << dec << "  ";
d843 1
a843 1
      current_cpu->trace_stream << "condbit" << ":=0x" << hex << opval << dec << "  ";
d867 1
a867 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d892 1
a892 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d917 1
a917 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d942 1
a942 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1023 1
a1023 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1046 1
a1046 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1069 1
a1069 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1092 1
a1092 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1115 1
a1115 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1138 1
a1138 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1161 1
a1161 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1184 1
a1184 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1207 1
a1207 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1230 1
a1230 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1257 1
a1257 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1263 1
a1263 1
      current_cpu->trace_stream << "sr" << '[' << FLD (f_r2) << ']' << ":=0x" << hex << opval << dec << "  ";
d1287 1
a1287 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1310 1
a1310 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1333 1
a1333 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1363 1
a1363 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1479 1
a1479 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1594 1
a1594 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1617 1
a1617 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1640 1
a1640 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1663 1
a1663 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1686 1
a1686 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1755 1
a1755 1
      current_cpu->trace_stream << "dcr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1778 1
a1778 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1819 1
a1819 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1950 1
a1950 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1973 1
a1973 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d1996 1
a1996 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d2019 1
a2019 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d2042 1
a2042 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d2065 1
a2065 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d2088 1
a2088 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d2111 1
a2111 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d2134 1
a2134 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d2157 1
a2157 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d2327 1
a2327 1
      current_cpu->trace_stream << "src2" << '[' << FLD (f_r2) << ']' << ":=0x" << hex << opval << dec << "  ";
d2360 1
a2360 1
      current_cpu->trace_stream << "src2" << '[' << FLD (f_r2) << ']' << ":=0x" << hex << opval << dec << "  ";
d2384 1
a2384 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d2411 1
a2411 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d2417 1
a2417 1
      current_cpu->trace_stream << "condbit" << ":=0x" << hex << opval << dec << "  ";
d2445 1
a2445 1
      current_cpu->trace_stream << "dr" << '[' << FLD (f_r1) << ']' << ":=0x" << hex << opval << dec << "  ";
d2451 1
a2451 1
      current_cpu->trace_stream << "condbit" << ":=0x" << hex << opval << dec << "  ";
@


1.1
log
@* public snapshot of sid simulator
@
text
@d592 1
a592 1
      current_cpu->trace_stream << "gr-14" << '[' << ((UINT) 14) << ']' << ":=0x" << hex << opval << dec << "  ";
d623 1
a623 1
      current_cpu->trace_stream << "gr-14" << '[' << ((UINT) 14) << ']' << ":=0x" << hex << opval << dec << "  ";
d970 1
a970 1
      current_cpu->trace_stream << "gr-14" << '[' << ((UINT) 14) << ']' << ":=0x" << hex << opval << dec << "  ";
d1914 1
a1914 1
      current_cpu->trace_stream << "cr-6" << '[' << ((UINT) 6) << ']' << ":=0x" << hex << opval << dec << "  ";
d2476 1
a2476 1
      current_cpu->trace_stream << "cr-14" << '[' << ((UINT) 14) << ']' << ":=0x" << hex << opval << dec << "  ";
d2482 1
a2482 1
      current_cpu->trace_stream << "cr-6" << '[' << ((UINT) 6) << ']' << ":=0x" << hex << opval << dec << "  ";
@

