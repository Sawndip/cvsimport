head	1.6;
access;
symbols
	sid-snapshot-20180601:1.6
	sid-snapshot-20180501:1.6
	sid-snapshot-20180401:1.6
	sid-snapshot-20180301:1.6
	sid-snapshot-20180201:1.6
	sid-snapshot-20180101:1.6
	sid-snapshot-20171201:1.6
	sid-snapshot-20171101:1.6
	sid-snapshot-20171001:1.6
	sid-snapshot-20170901:1.6
	sid-snapshot-20170801:1.6
	sid-snapshot-20170701:1.6
	sid-snapshot-20170601:1.6
	sid-snapshot-20170501:1.6
	sid-snapshot-20170401:1.6
	sid-snapshot-20170301:1.6
	sid-snapshot-20170201:1.6
	sid-snapshot-20170101:1.6
	sid-snapshot-20161201:1.6
	sid-snapshot-20161101:1.6
	sid-snapshot-20160901:1.6
	sid-snapshot-20160801:1.6
	sid-snapshot-20160701:1.6
	sid-snapshot-20160601:1.6
	sid-snapshot-20160501:1.6
	sid-snapshot-20160401:1.6
	sid-snapshot-20160301:1.6
	sid-snapshot-20160201:1.6
	sid-snapshot-20160101:1.6
	sid-snapshot-20151201:1.6
	sid-snapshot-20151101:1.6
	sid-snapshot-20151001:1.6
	sid-snapshot-20150901:1.6
	sid-snapshot-20150801:1.6
	sid-snapshot-20150701:1.6
	sid-snapshot-20150601:1.6
	sid-snapshot-20150501:1.6
	sid-snapshot-20150401:1.6
	sid-snapshot-20150301:1.6
	sid-snapshot-20150201:1.6
	sid-snapshot-20150101:1.6
	sid-snapshot-20141201:1.6
	sid-snapshot-20141101:1.6
	sid-snapshot-20141001:1.6
	sid-snapshot-20140901:1.6
	sid-snapshot-20140801:1.6
	sid-snapshot-20140701:1.6
	sid-snapshot-20140601:1.6
	sid-snapshot-20140501:1.6
	sid-snapshot-20140401:1.6
	sid-snapshot-20140301:1.6
	sid-snapshot-20140201:1.6
	sid-snapshot-20140101:1.6
	sid-snapshot-20131201:1.6
	sid-snapshot-20131101:1.6
	sid-snapshot-20131001:1.6
	sid-snapshot-20130901:1.6
	sid-snapshot-20130801:1.6
	sid-snapshot-20130701:1.6
	sid-snapshot-20130601:1.6
	sid-snapshot-20130501:1.6
	sid-snapshot-20130401:1.6
	sid-snapshot-20130301:1.6
	sid-snapshot-20130201:1.6
	sid-snapshot-20130101:1.6
	sid-snapshot-20121201:1.6
	sid-snapshot-20121101:1.6
	sid-snapshot-20121001:1.6
	sid-snapshot-20120901:1.6
	sid-snapshot-20120801:1.6
	sid-snapshot-20120701:1.6
	sid-snapshot-20120601:1.6
	sid-snapshot-20120501:1.6
	sid-snapshot-20120401:1.6
	sid-snapshot-20120301:1.6
	sid-snapshot-20120201:1.6
	sid-snapshot-20120101:1.6
	sid-snapshot-20111201:1.6
	sid-snapshot-20111101:1.6
	sid-snapshot-20111001:1.6
	sid-snapshot-20110901:1.6
	sid-snapshot-20110801:1.6
	sid-snapshot-20110701:1.6
	sid-snapshot-20110601:1.6
	sid-snapshot-20110501:1.6
	sid-snapshot-20110401:1.6
	sid-snapshot-20110301:1.6
	sid-snapshot-20110201:1.6
	sid-snapshot-20110101:1.6
	sid-snapshot-20101201:1.6
	sid-snapshot-20101101:1.6
	sid-snapshot-20101001:1.6
	sid-snapshot-20100901:1.6
	sid-snapshot-20100801:1.6
	sid-snapshot-20100701:1.6
	sid-snapshot-20100601:1.6
	sid-snapshot-20100501:1.6
	sid-snapshot-20100401:1.6
	sid-snapshot-20100301:1.6
	sid-snapshot-20100201:1.6
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.4
	sid-snapshot-20090901:1.4
	sid-snapshot-20090801:1.4
	sid-snapshot-20090701:1.4
	sid-snapshot-20090601:1.4
	sid-snapshot-20090501:1.4
	sid-snapshot-20090401:1.4
	sid-snapshot-20090301:1.4
	sid-snapshot-20090201:1.4
	sid-snapshot-20090101:1.4
	sid-snapshot-20081201:1.4
	sid-snapshot-20081101:1.4
	sid-snapshot-20081001:1.4
	sid-snapshot-20080901:1.4
	sid-snapshot-20080801:1.4
	sid-snapshot-20080701:1.4
	sid-snapshot-20080601:1.4
	sid-snapshot-20080501:1.4
	sid-snapshot-20080403:1.4
	sid-snapshot-20080401:1.4
	sid-snapshot-20080301:1.4
	sid-snapshot-20080201:1.4
	sid-snapshot-20080101:1.4
	sid-snapshot-20071201:1.4
	sid-snapshot-20071101:1.4
	sid-snapshot-20071001:1.4
	sid-20020905-branchpoint:1.1
	sid-20020905-branch:1.1.0.2
	cygnus_cvs_20020108_pre:1.1;
locks; strict;
comment	@ * @;


1.6
date	2010.01.02.21.18.54;	author devans;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.24.00.45.55;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.05.17.07.20;	author devans;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.08.03.17.27;	author bje;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.07.14.42.48;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.07.19.30.48;	author fche;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Regenerate cgen files, update copyright year.
@
text
@/* CPU class elements for arm.

THIS FILE IS MACHINE GENERATED WITH CGEN.

Copyright (C) 2000-2010 Red Hat, Inc.

This file is part of the Red Hat simulators.


*/

// This file is included in the middle of the cpu class struct.

public:

// CPU state information.

  // Hardware elements.
  struct {
  /* ARM program counter (h-gr reg 15) */
  USI h_pc;
  /* General purpose registers */
  SI h_gr[16];
  /* user/system mode r8-r14 holding buffer */
  SI h_gr_usr[7];
  /* fiq mode r8-r14 regs */
  SI h_gr_fiq[7];
  /* supervisor mode r13-r14 regs */
  SI h_gr_svc[2];
  /* abort mode r13-r14 regs */
  SI h_gr_abt[2];
  /* irq mode r13-r14 regs */
  SI h_gr_irq[2];
  /* undefined mode r13-r14 regs */
  SI h_gr_und[2];
  /* carry bit */
  BI h_cbit;
  /* negative bit */
  BI h_nbit;
  /* overflow bit */
  BI h_vbit;
  /* zerobit */
  BI h_zbit;
  /* irq disable bit */
  BI h_ibit;
  /* fiq disable bit */
  BI h_fbit;
  /* thumb bit */
  BI h_tbit;
  /* m4,m3,m2,m1,m0 */
  UINT h_mbits;
  /* Saved Process Status Register during FIQ */
  SI h_spsr_fiq;
  /* Saved Process Status Register during SVC */
  SI h_spsr_svc;
  /* Saved Process Status Register during Abort */
  SI h_spsr_abt;
  /* Saved Process Status Register during IRQ */
  SI h_spsr_irq;
  /* Saved Process Status Register during Undefined */
  SI h_spsr_und;
  } hardware;

  void stream_cgen_hardware (std::ostream &ost) const 
  {
    ost << hardware.h_pc << ' ';
    for (int i = 0; i < 16; i++)
      ost << hardware.h_gr[i] << ' ';
    for (int i = 0; i < 7; i++)
      ost << hardware.h_gr_usr[i] << ' ';
    for (int i = 0; i < 7; i++)
      ost << hardware.h_gr_fiq[i] << ' ';
    for (int i = 0; i < 2; i++)
      ost << hardware.h_gr_svc[i] << ' ';
    for (int i = 0; i < 2; i++)
      ost << hardware.h_gr_abt[i] << ' ';
    for (int i = 0; i < 2; i++)
      ost << hardware.h_gr_irq[i] << ' ';
    for (int i = 0; i < 2; i++)
      ost << hardware.h_gr_und[i] << ' ';
    ost << hardware.h_cbit << ' ';
    ost << hardware.h_nbit << ' ';
    ost << hardware.h_vbit << ' ';
    ost << hardware.h_zbit << ' ';
    ost << hardware.h_ibit << ' ';
    ost << hardware.h_fbit << ' ';
    ost << hardware.h_tbit << ' ';
    ost << hardware.h_mbits << ' ';
    ost << hardware.h_spsr_fiq << ' ';
    ost << hardware.h_spsr_svc << ' ';
    ost << hardware.h_spsr_abt << ' ';
    ost << hardware.h_spsr_irq << ' ';
    ost << hardware.h_spsr_und << ' ';
  }
  void destream_cgen_hardware (std::istream &ist) 
  {
    ist >> hardware.h_pc;
    for (int i = 0; i < 16; i++)
      ist >> hardware.h_gr[i];
    for (int i = 0; i < 7; i++)
      ist >> hardware.h_gr_usr[i];
    for (int i = 0; i < 7; i++)
      ist >> hardware.h_gr_fiq[i];
    for (int i = 0; i < 2; i++)
      ist >> hardware.h_gr_svc[i];
    for (int i = 0; i < 2; i++)
      ist >> hardware.h_gr_abt[i];
    for (int i = 0; i < 2; i++)
      ist >> hardware.h_gr_irq[i];
    for (int i = 0; i < 2; i++)
      ist >> hardware.h_gr_und[i];
    ist >> hardware.h_cbit;
    ist >> hardware.h_nbit;
    ist >> hardware.h_vbit;
    ist >> hardware.h_zbit;
    ist >> hardware.h_ibit;
    ist >> hardware.h_fbit;
    ist >> hardware.h_tbit;
    ist >> hardware.h_mbits;
    ist >> hardware.h_spsr_fiq;
    ist >> hardware.h_spsr_svc;
    ist >> hardware.h_spsr_abt;
    ist >> hardware.h_spsr_irq;
    ist >> hardware.h_spsr_und;
  }
  // C++ register access function templates
#define current_cpu this

  inline USI h_pc_get () const { return this->hardware.h_pc; }
  inline void h_pc_set (USI newval) { if (current_cpu->hardware.h_tbit) {
current_cpu->hardware.h_pc = ANDSI (newval, -2);
} else {
current_cpu->hardware.h_pc = ANDSI (newval, -4);
}
 }

  inline SI h_gr_get (UINT regno) const { return this->hardware.h_gr[regno]; }
  inline void h_gr_set (UINT regno, SI newval) { this->hardware.h_gr[regno] = newval; }

  inline SI h_gr_usr_get (UINT regno) const { return this->hardware.h_gr_usr[regno]; }
  inline void h_gr_usr_set (UINT regno, SI newval) { this->hardware.h_gr_usr[regno] = newval; }

  inline SI h_gr_fiq_get (UINT regno) const { return this->hardware.h_gr_fiq[regno]; }
  inline void h_gr_fiq_set (UINT regno, SI newval) { this->hardware.h_gr_fiq[regno] = newval; }

  inline SI h_gr_svc_get (UINT regno) const { return this->hardware.h_gr_svc[regno]; }
  inline void h_gr_svc_set (UINT regno, SI newval) { this->hardware.h_gr_svc[regno] = newval; }

  inline SI h_gr_abt_get (UINT regno) const { return this->hardware.h_gr_abt[regno]; }
  inline void h_gr_abt_set (UINT regno, SI newval) { this->hardware.h_gr_abt[regno] = newval; }

  inline SI h_gr_irq_get (UINT regno) const { return this->hardware.h_gr_irq[regno]; }
  inline void h_gr_irq_set (UINT regno, SI newval) { this->hardware.h_gr_irq[regno] = newval; }

  inline SI h_gr_und_get (UINT regno) const { return this->hardware.h_gr_und[regno]; }
  inline void h_gr_und_set (UINT regno, SI newval) { this->hardware.h_gr_und[regno] = newval; }

  inline BI h_cbit_get () const { return this->hardware.h_cbit; }
  inline void h_cbit_set (BI newval) { this->hardware.h_cbit = newval; }

  inline BI h_nbit_get () const { return this->hardware.h_nbit; }
  inline void h_nbit_set (BI newval) { this->hardware.h_nbit = newval; }

  inline BI h_vbit_get () const { return this->hardware.h_vbit; }
  inline void h_vbit_set (BI newval) { this->hardware.h_vbit = newval; }

  inline BI h_zbit_get () const { return this->hardware.h_zbit; }
  inline void h_zbit_set (BI newval) { this->hardware.h_zbit = newval; }

  inline BI h_ibit_get () const { return this->hardware.h_ibit; }
  inline void h_ibit_set (BI newval) { this->hardware.h_ibit = newval; }

  inline BI h_fbit_get () const { return this->hardware.h_fbit; }
  inline void h_fbit_set (BI newval) { this->hardware.h_fbit = newval; }

  inline BI h_tbit_get () const { return this->hardware.h_tbit; }
  inline void h_tbit_set (BI newval) { {
current_cpu->arm_tbit_set (newval);
}
 }

  inline UINT h_mbits_get () const { return this->hardware.h_mbits; }
  inline void h_mbits_set (UINT newval) { {
  switch (newval)
  {
  case ARM_MODE_USER :   case ARM_MODE_FIQ :   case ARM_MODE_IRQ :   case ARM_MODE_SUPERVISOR :   case ARM_MODE_ABORT :   case ARM_MODE_UNDEFINED :   case ARM_MODE_SYSTEM : {
((void) 0); /*nop*/
}
    break;
  default : {
current_cpu->cgen_rtx_error ("bad value for M4-M0");
}
    break;
  }
current_cpu->arm_mbits_set (newval);
}
 }

  inline SI h_cpsr_get () const { return ORSI (SLLSI (ZEXTBISI (current_cpu->hardware.h_nbit), 31), ORSI (SLLSI (ZEXTBISI (current_cpu->hardware.h_zbit), 30), ORSI (SLLSI (ZEXTBISI (current_cpu->hardware.h_cbit), 29), ORSI (SLLSI (ZEXTBISI (current_cpu->hardware.h_vbit), 28), ORSI (SLLSI (ZEXTBISI (current_cpu->hardware.h_ibit), 7), ORSI (SLLSI (ZEXTBISI (current_cpu->hardware.h_fbit), 6), ORSI (SLLSI (ZEXTBISI (current_cpu->hardware.h_tbit), 5), current_cpu->hardware.h_mbits))))))); }
  inline void h_cpsr_set (SI newval) { {
current_cpu->hardware.h_nbit = NESI (ANDSI (newval, 0x80000000), 0);
current_cpu->hardware.h_zbit = NESI (ANDSI (newval, 1073741824), 0);
current_cpu->hardware.h_cbit = NESI (ANDSI (newval, 536870912), 0);
current_cpu->hardware.h_vbit = NESI (ANDSI (newval, 268435456), 0);
current_cpu->hardware.h_ibit = NESI (ANDSI (newval, 128), 0);
current_cpu->hardware.h_fbit = NESI (ANDSI (newval, 64), 0);
current_cpu->h_tbit_set (NESI (ANDSI (newval, 32), 0));
current_cpu->h_mbits_set (ANDSI (newval, 31));
}
 }

  inline SI h_spsr_fiq_get () const { return this->hardware.h_spsr_fiq; }
  inline void h_spsr_fiq_set (SI newval) { this->hardware.h_spsr_fiq = newval; }

  inline SI h_spsr_svc_get () const { return this->hardware.h_spsr_svc; }
  inline void h_spsr_svc_set (SI newval) { this->hardware.h_spsr_svc = newval; }

  inline SI h_spsr_abt_get () const { return this->hardware.h_spsr_abt; }
  inline void h_spsr_abt_set (SI newval) { this->hardware.h_spsr_abt = newval; }

  inline SI h_spsr_irq_get () const { return this->hardware.h_spsr_irq; }
  inline void h_spsr_irq_set (SI newval) { this->hardware.h_spsr_irq = newval; }

  inline SI h_spsr_und_get () const { return this->hardware.h_spsr_und; }
  inline void h_spsr_und_set (SI newval) { this->hardware.h_spsr_und = newval; }

  inline SI h_spsr_get () const { return (current_cpu->hardware.h_mbits == ARM_MODE_USER) ? ((current_cpu->cgen_rtx_error ("can't read spsr in user mode"), 0)) : (current_cpu->hardware.h_mbits == ARM_MODE_FIQ) ? (current_cpu->hardware.h_spsr_fiq) : (current_cpu->hardware.h_mbits == ARM_MODE_IRQ) ? (current_cpu->hardware.h_spsr_irq) : (current_cpu->hardware.h_mbits == ARM_MODE_SUPERVISOR) ? (current_cpu->hardware.h_spsr_svc) : (current_cpu->hardware.h_mbits == ARM_MODE_ABORT) ? (current_cpu->hardware.h_spsr_abt) : (current_cpu->hardware.h_mbits == ARM_MODE_UNDEFINED) ? (current_cpu->hardware.h_spsr_und) : (current_cpu->hardware.h_mbits == ARM_MODE_SYSTEM) ? ((current_cpu->cgen_rtx_error ("can't read spsr in system mode"), 0)) : ((current_cpu->cgen_rtx_error ("can't read spsr, invalid mode"), 0)); }
  inline void h_spsr_set (SI newval) {   switch (current_cpu->hardware.h_mbits)
  {
  case ARM_MODE_USER : {
current_cpu->cgen_rtx_error ("can't set spsr in user mode");
}
    break;
  case ARM_MODE_FIQ : {
current_cpu->hardware.h_spsr_fiq = newval;
}
    break;
  case ARM_MODE_IRQ : {
current_cpu->hardware.h_spsr_irq = newval;
}
    break;
  case ARM_MODE_SUPERVISOR : {
current_cpu->hardware.h_spsr_svc = newval;
}
    break;
  case ARM_MODE_ABORT : {
current_cpu->hardware.h_spsr_abt = newval;
}
    break;
  case ARM_MODE_UNDEFINED : {
current_cpu->hardware.h_spsr_und = newval;
}
    break;
  case ARM_MODE_SYSTEM : {
current_cpu->cgen_rtx_error ("can't set spsr in system mode");
}
    break;
  default : {
current_cpu->cgen_rtx_error ("can't set spsr, invalid mode");
}
    break;
  }
 }

  inline SI thumb_h_gr_t_get (UINT regno) const { return current_cpu->hardware.h_gr[regno]; }
  inline void thumb_h_gr_t_set (UINT regno, SI newval) { current_cpu->hardware.h_gr[regno] = newval;
 }

  inline SI thumb_h_lr_t_get () const { return current_cpu->hardware.h_gr[((UINT) 14)]; }
  inline void thumb_h_lr_t_set (SI newval) { current_cpu->hardware.h_gr[((UINT) 14)] = newval;
 }

  inline SI thumb_h_sp_t_get () const { return current_cpu->hardware.h_gr[((UINT) 13)]; }
  inline void thumb_h_sp_t_set (SI newval) { current_cpu->hardware.h_gr[((UINT) 13)] = newval;
 }

  inline SI thumb_h_hiregs_get (UINT regno) const { return current_cpu->hardware.h_gr[((regno) + (8))]; }
  inline void thumb_h_hiregs_set (UINT regno, SI newval) { current_cpu->hardware.h_gr[((regno) + (8))] = newval;
 }

#undef current_cpu

@


1.5
log
@	* cgen-cpu.h: Update for new location of cgen/bitset.h.
	* tracedis.h: Ditto.

Plus update generated files to pick up two cgen changes:
1)
	* desc-cpu.scm (/gen-hash-defines): Remove #include of cgen-bitset.h.
	* sid-cpu.scm (cgen-desc.h): Update location of cgen's bitset.h.
2)
	* utils-sim.scm (/gen-set-itype-and-extract): New function.
	(/gen-bracketed-set-itype-and-extract): New function.
	(/gen-decode-default-entry): Rewrite.
	(/table-guts-to-mask, /all-opcode-bits-used?): New functions.
	(/gen-decode-insn-entry): New arg table-guts-thus-far, all callers
	updated.  Don't unnecessarily emit check for whether all opcode bits
	have been examined.
	(/gen-decode-expr-set-itype): Delete.
	(/gen-decode-expr-entry): Update.
	(/gen-decode-table-entry): New arg table-guts-thus-far, all callers
	updated.  Keep track of decoder tables used thus far.
	(/gen-decoder-switch): Ditto.
@
text
@d5 1
a5 1
Copyright (C) 2000-2009 Red Hat, Inc.
@


1.4
log
@Regenerate cgen files (not due to any recent changes, just want to
establish a reference point).
@
text
@d5 1
a5 1
Copyright (C) 2000, 2001, 2002, 2003 Red Hat, Inc.
d64 62
@


1.3
log
@2002-09-07  Frank Ch. Eigler  <fche@@redhat.com>

        * arm-*, thumb-*: Regenerated files with Robert Cragie's new
        cgen instructions.
	* arm-defs.h: Removed.
	* arm7.h: Don't include arm-defs.h.
	* Makefile.am: Stop arm-defs.h generation.
	* Makefile.in: Regenerated.
@
text
@d5 1
a5 1
Copyright (C) 2000, 2001, 2002 Red Hat, Inc.
a63 62
  void stream_cgen_hardware (std::ostream &ost) const 
  {
    ost << hardware.h_pc << ' ';
    for (int i = 0; i < 16; i++)
      ost << hardware.h_gr[i] << ' ';
    for (int i = 0; i < 7; i++)
      ost << hardware.h_gr_usr[i] << ' ';
    for (int i = 0; i < 7; i++)
      ost << hardware.h_gr_fiq[i] << ' ';
    for (int i = 0; i < 2; i++)
      ost << hardware.h_gr_svc[i] << ' ';
    for (int i = 0; i < 2; i++)
      ost << hardware.h_gr_abt[i] << ' ';
    for (int i = 0; i < 2; i++)
      ost << hardware.h_gr_irq[i] << ' ';
    for (int i = 0; i < 2; i++)
      ost << hardware.h_gr_und[i] << ' ';
    ost << hardware.h_cbit << ' ';
    ost << hardware.h_nbit << ' ';
    ost << hardware.h_vbit << ' ';
    ost << hardware.h_zbit << ' ';
    ost << hardware.h_ibit << ' ';
    ost << hardware.h_fbit << ' ';
    ost << hardware.h_tbit << ' ';
    ost << hardware.h_mbits << ' ';
    ost << hardware.h_spsr_fiq << ' ';
    ost << hardware.h_spsr_svc << ' ';
    ost << hardware.h_spsr_abt << ' ';
    ost << hardware.h_spsr_irq << ' ';
    ost << hardware.h_spsr_und << ' ';
  }
  void destream_cgen_hardware (std::istream &ist) 
  {
    ist >> hardware.h_pc;
    for (int i = 0; i < 16; i++)
      ist >> hardware.h_gr[i];
    for (int i = 0; i < 7; i++)
      ist >> hardware.h_gr_usr[i];
    for (int i = 0; i < 7; i++)
      ist >> hardware.h_gr_fiq[i];
    for (int i = 0; i < 2; i++)
      ist >> hardware.h_gr_svc[i];
    for (int i = 0; i < 2; i++)
      ist >> hardware.h_gr_abt[i];
    for (int i = 0; i < 2; i++)
      ist >> hardware.h_gr_irq[i];
    for (int i = 0; i < 2; i++)
      ist >> hardware.h_gr_und[i];
    ist >> hardware.h_cbit;
    ist >> hardware.h_nbit;
    ist >> hardware.h_vbit;
    ist >> hardware.h_zbit;
    ist >> hardware.h_ibit;
    ist >> hardware.h_fbit;
    ist >> hardware.h_tbit;
    ist >> hardware.h_mbits;
    ist >> hardware.h_spsr_fiq;
    ist >> hardware.h_spsr_svc;
    ist >> hardware.h_spsr_abt;
    ist >> hardware.h_spsr_irq;
    ist >> hardware.h_spsr_und;
  }
@


1.2
log
@* arm7t missing instructions

[cgen]
2002-09-07  Frank Ch. Eigler  <fche@@redhat.com>

	From Robert Cragie <rcc@@jennic.com>:
	* cpu/arm7.cpu (ldm*-sw*, stm*-sw*): New instructions.

[sid]
2002-09-07  Frank Ch. Eigler  <fche@@redhat.com>

	* arm-*, thumb-*: Regenerated files with Robert Cragie's new
	cgen instructions.
@
text
@d64 62
@


1.1
log
@* public snapshot of sid simulator
@
text
@d5 1
a5 1
Copyright (C) 2000 Red Hat, Inc.
d7 1
a7 1
This file is part of the Cygnus Simulators.
@

