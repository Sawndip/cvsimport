head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	sid-snapshot-20100201:1.4
	sid-snapshot-20100101:1.3
	sid-snapshot-20091201:1.3
	sid-snapshot-20091101:1.3
	sid-snapshot-20091001:1.2
	sid-snapshot-20090901:1.2
	sid-snapshot-20090801:1.2
	sid-snapshot-20090701:1.2
	sid-snapshot-20090601:1.2
	sid-snapshot-20090501:1.2
	sid-snapshot-20090401:1.2
	sid-snapshot-20090301:1.2
	sid-snapshot-20090201:1.2
	sid-snapshot-20090101:1.2
	sid-snapshot-20081201:1.2
	sid-snapshot-20081101:1.2
	sid-snapshot-20081001:1.2
	sid-snapshot-20080901:1.2
	sid-snapshot-20080801:1.2
	sid-snapshot-20080701:1.2
	sid-snapshot-20080601:1.2
	sid-snapshot-20080501:1.2
	sid-snapshot-20080403:1.2
	sid-snapshot-20080401:1.2
	sid-snapshot-20080301:1.2
	sid-snapshot-20080201:1.2
	sid-snapshot-20080101:1.2
	sid-snapshot-20071201:1.2
	sid-snapshot-20071101:1.2
	sid-snapshot-20071001:1.2;
locks; strict;
comment	@// @;


1.5
date	2010.02.12.02.33.05;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	2010.01.02.21.18.55;	author devans;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.24.00.45.59;	author devans;	state Exp;
branches;
next	1.2;

1.2
date	2005.12.16.10.23.13;	author nathan;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.12.11.16.42;	author nathan;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Regenerate to pick up recent cgen changes.
[minor changes like removing K&R support, more consistent name for sfmt_empty]
@
text
@/* Simulator instruction semantics for mt.

THIS FILE IS MACHINE GENERATED WITH CGEN.

Copyright (C) 2000-2010 Red Hat, Inc.

This file is part of the Red Hat simulators.


*/


#if HAVE_CONFIG_H
#include "config.h"
#endif
#include "mt.h"

using namespace mt; // FIXME: namespace organization still wip
using namespace mt; // FIXME: namespace organization still wip
#define GET_ATTR(name) GET_ATTR_##name ()


// ********** x-invalid: --invalid--

void
mt_sem_x_invalid (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 0;

  {
    current_cpu->invalid_insn (pc);
    assert (0);
    /* NOTREACHED */
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** add: add $frdrrr,$frsr1,$frsr2

void
mt_sem_add (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_add.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = ADDSI (current_cpu->hardware.h_spr[FLD (f_sr1)], current_cpu->hardware.h_spr[FLD (f_sr2)]);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_drrr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_drrr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** addu: addu $frdrrr,$frsr1,$frsr2

void
mt_sem_addu (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_add.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = ADDSI (current_cpu->hardware.h_spr[FLD (f_sr1)], current_cpu->hardware.h_spr[FLD (f_sr2)]);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_drrr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_drrr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** addi: addi $frdr,$frsr1,#$imm16

void
mt_sem_addi (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

{
  HI tmp_tmp;
  tmp_tmp = ANDSI (FLD (f_imm16s), 65535);
  {
    SI opval = ADDSI (current_cpu->hardware.h_spr[FLD (f_sr1)], EXTHISI (tmp_tmp));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_dr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_dr)] = opval;
  }
}

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** addui: addui $frdr,$frsr1,#$imm16z

void
mt_sem_addui (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_addui.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = ADDSI (current_cpu->hardware.h_spr[FLD (f_sr1)], EXTSISI (FLD (f_imm16u)));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_dr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_dr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** sub: sub $frdrrr,$frsr1,$frsr2

void
mt_sem_sub (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_add.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = SUBSI (current_cpu->hardware.h_spr[FLD (f_sr1)], current_cpu->hardware.h_spr[FLD (f_sr2)]);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_drrr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_drrr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** subu: subu $frdrrr,$frsr1,$frsr2

void
mt_sem_subu (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_add.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = SUBSI (current_cpu->hardware.h_spr[FLD (f_sr1)], current_cpu->hardware.h_spr[FLD (f_sr2)]);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_drrr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_drrr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** subi: subi $frdr,$frsr1,#$imm16

void
mt_sem_subi (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

{
  HI tmp_tmp;
  tmp_tmp = ANDSI (FLD (f_imm16s), 65535);
  {
    SI opval = SUBSI (current_cpu->hardware.h_spr[FLD (f_sr1)], EXTHISI (tmp_tmp));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_dr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_dr)] = opval;
  }
}

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** subui: subui $frdr,$frsr1,#$imm16z

void
mt_sem_subui (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_addui.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = SUBSI (current_cpu->hardware.h_spr[FLD (f_sr1)], EXTSISI (FLD (f_imm16u)));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_dr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_dr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** mul: mul $frdrrr,$frsr1,$frsr2

void
mt_sem_mul (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_add.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

{
  HI tmp_op1;
  HI tmp_op2;
  tmp_op1 = ANDSI (current_cpu->hardware.h_spr[FLD (f_sr1)], 65535);
if (ORBI (LTHI (tmp_op1, -32768), GTHI (tmp_op1, 32767))) {
current_cpu->cgen_rtx_error ("operand out of range");
}
  tmp_op2 = ANDSI (current_cpu->hardware.h_spr[FLD (f_sr2)], 65535);
if (ORBI (LTHI (tmp_op2, -32768), GTHI (tmp_op2, 32767))) {
current_cpu->cgen_rtx_error ("operand out of range");
}
  {
    SI opval = MULSI (EXTHISI (tmp_op1), EXTHISI (tmp_op2));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_drrr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_drrr)] = opval;
  }
}

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** muli: muli $frdr,$frsr1,#$imm16

void
mt_sem_muli (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

{
  HI tmp_op1;
  HI tmp_op2;
  tmp_op1 = ANDSI (current_cpu->hardware.h_spr[FLD (f_sr1)], 65535);
if (ORBI (LTHI (tmp_op1, -32768), GTHI (tmp_op1, 32767))) {
current_cpu->cgen_rtx_error ("operand out of range");
}
  tmp_op2 = ANDSI (FLD (f_imm16s), 65535);
if (EQHI (tmp_op1, 0)) {
current_cpu->cgen_rtx_error ("op1 is 0");
}
if (EQHI (tmp_op2, 0)) {
current_cpu->cgen_rtx_error ("op2 is 0");
}
  {
    SI opval = MULSI (EXTHISI (tmp_op1), EXTHISI (tmp_op2));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_dr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_dr)] = opval;
  }
}

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** and: and $frdrrr,$frsr1,$frsr2

void
mt_sem_and (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_add.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = ANDSI (current_cpu->hardware.h_spr[FLD (f_sr1)], current_cpu->hardware.h_spr[FLD (f_sr2)]);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_drrr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_drrr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** andi: andi $frdr,$frsr1,#$imm16z

void
mt_sem_andi (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_addui.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = ANDSI (current_cpu->hardware.h_spr[FLD (f_sr1)], EXTSISI (FLD (f_imm16u)));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_dr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_dr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** or: or $frdrrr,$frsr1,$frsr2

void
mt_sem_or (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_add.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = ORSI (current_cpu->hardware.h_spr[FLD (f_sr1)], current_cpu->hardware.h_spr[FLD (f_sr2)]);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_drrr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_drrr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** nop: nop

void
mt_sem_nop (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** ori: ori $frdr,$frsr1,#$imm16z

void
mt_sem_ori (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_addui.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = ORSI (current_cpu->hardware.h_spr[FLD (f_sr1)], EXTSISI (FLD (f_imm16u)));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_dr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_dr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** xor: xor $frdrrr,$frsr1,$frsr2

void
mt_sem_xor (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_add.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = XORSI (current_cpu->hardware.h_spr[FLD (f_sr1)], current_cpu->hardware.h_spr[FLD (f_sr2)]);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_drrr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_drrr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** xori: xori $frdr,$frsr1,#$imm16z

void
mt_sem_xori (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_addui.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = XORSI (current_cpu->hardware.h_spr[FLD (f_sr1)], EXTSISI (FLD (f_imm16u)));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_dr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_dr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** nand: nand $frdrrr,$frsr1,$frsr2

void
mt_sem_nand (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_add.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = INVSI (ANDSI (current_cpu->hardware.h_spr[FLD (f_sr1)], current_cpu->hardware.h_spr[FLD (f_sr2)]));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_drrr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_drrr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** nandi: nandi $frdr,$frsr1,#$imm16z

void
mt_sem_nandi (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_addui.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = INVSI (ANDSI (current_cpu->hardware.h_spr[FLD (f_sr1)], EXTSISI (FLD (f_imm16u))));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_dr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_dr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** nor: nor $frdrrr,$frsr1,$frsr2

void
mt_sem_nor (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_add.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = INVSI (ORSI (current_cpu->hardware.h_spr[FLD (f_sr1)], current_cpu->hardware.h_spr[FLD (f_sr2)]));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_drrr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_drrr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** nori: nori $frdr,$frsr1,#$imm16z

void
mt_sem_nori (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_addui.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = INVSI (ORSI (current_cpu->hardware.h_spr[FLD (f_sr1)], EXTSISI (FLD (f_imm16u))));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_dr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_dr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** xnor: xnor $frdrrr,$frsr1,$frsr2

void
mt_sem_xnor (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_add.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = INVSI (XORSI (current_cpu->hardware.h_spr[FLD (f_sr1)], current_cpu->hardware.h_spr[FLD (f_sr2)]));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_drrr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_drrr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** xnori: xnori $frdr,$frsr1,#$imm16z

void
mt_sem_xnori (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_addui.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = INVSI (XORSI (current_cpu->hardware.h_spr[FLD (f_sr1)], EXTSISI (FLD (f_imm16u))));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_dr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_dr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** ldui: ldui $frdr,#$imm16z

void
mt_sem_ldui (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_addui.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = ANDSI (SLLSI (FLD (f_imm16u), 16), 0xffff0000);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_dr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_dr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** lsl: lsl $frdrrr,$frsr1,$frsr2

void
mt_sem_lsl (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_add.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = SLLSI (current_cpu->hardware.h_spr[FLD (f_sr1)], current_cpu->hardware.h_spr[FLD (f_sr2)]);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_drrr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_drrr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** lsli: lsli $frdr,$frsr1,#$imm16

void
mt_sem_lsli (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = SLLSI (current_cpu->hardware.h_spr[FLD (f_sr1)], FLD (f_imm16s));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_dr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_dr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** lsr: lsr $frdrrr,$frsr1,$frsr2

void
mt_sem_lsr (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_add.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = SRLSI (current_cpu->hardware.h_spr[FLD (f_sr1)], current_cpu->hardware.h_spr[FLD (f_sr2)]);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_drrr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_drrr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** lsri: lsri $frdr,$frsr1,#$imm16

void
mt_sem_lsri (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = SRLSI (current_cpu->hardware.h_spr[FLD (f_sr1)], FLD (f_imm16s));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_dr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_dr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** asr: asr $frdrrr,$frsr1,$frsr2

void
mt_sem_asr (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_add.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = SRASI (current_cpu->hardware.h_spr[FLD (f_sr1)], current_cpu->hardware.h_spr[FLD (f_sr2)]);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_drrr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_drrr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** asri: asri $frdr,$frsr1,#$imm16

void
mt_sem_asri (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    SI opval = SRASI (current_cpu->hardware.h_spr[FLD (f_sr1)], FLD (f_imm16s));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_dr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_dr)] = opval;
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** brlt: brlt $frsr1,$frsr2,$imm16o

void
mt_sem_brlt (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_brlt.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

{
if (LTUSI (current_cpu->hardware.h_spr[FLD (f_sr1)], current_cpu->hardware.h_spr[FLD (f_sr2)])) {
  {
    USI opval = ADDSI (pc, EXTSISI (FLD (f_imm16s)));
    buf.h_pc_writes [(tick + 1) % mt::pipe_sz].push (mt::write<USI>(pc, opval));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
  }
}
}

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** brle: brle $frsr1,$frsr2,$imm16o

void
mt_sem_brle (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_brlt.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

{
if (LEUSI (current_cpu->hardware.h_spr[FLD (f_sr1)], current_cpu->hardware.h_spr[FLD (f_sr2)])) {
  {
    USI opval = ADDSI (pc, EXTSISI (FLD (f_imm16s)));
    buf.h_pc_writes [(tick + 1) % mt::pipe_sz].push (mt::write<USI>(pc, opval));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
  }
}
}

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** breq: breq $frsr1,$frsr2,$imm16o

void
mt_sem_breq (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_brlt.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

{
if (EQSI (current_cpu->hardware.h_spr[FLD (f_sr1)], current_cpu->hardware.h_spr[FLD (f_sr2)])) {
  {
    USI opval = ADDSI (pc, EXTSISI (FLD (f_imm16s)));
    buf.h_pc_writes [(tick + 1) % mt::pipe_sz].push (mt::write<USI>(pc, opval));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
  }
}
}

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** brne: brne $frsr1,$frsr2,$imm16o

void
mt_sem_brne (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_brlt.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

{
if (NOTBI (EQSI (current_cpu->hardware.h_spr[FLD (f_sr1)], current_cpu->hardware.h_spr[FLD (f_sr2)]))) {
  {
    USI opval = ADDSI (pc, EXTSISI (FLD (f_imm16s)));
    buf.h_pc_writes [(tick + 1) % mt::pipe_sz].push (mt::write<USI>(pc, opval));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
  }
}
}

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** jmp: jmp $imm16o

void
mt_sem_jmp (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_brlt.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

  {
    USI opval = ADDSI (pc, EXTSISI (FLD (f_imm16s)));
    buf.h_pc_writes [(tick + 1) % mt::pipe_sz].push (mt::write<USI>(pc, opval));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
  }

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** jal: jal $frdrrr,$frsr1

void
mt_sem_jal (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_add.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

{
if (EQSI (current_cpu->hardware.h_spr[FLD (f_sr1)], 0)) {
current_cpu->do_syscall (pc);
} else {
{
  {
    SI opval = ADDSI (pc, 8);
    buf.h_spr_writes [(tick + 1) % mt::pipe_sz].push (mt::write<SI>(pc, opval, FLD (f_drrr)));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_drrr) << ']' << ":=0x" << hex << opval << dec << "  ";
  }
  {
    USI opval = current_cpu->hardware.h_spr[FLD (f_sr1)];
    buf.h_pc_writes [(tick + 1) % mt::pipe_sz].push (mt::write<USI>(pc, opval));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
  }
}
}
}

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** dbnz: dbnz $frsr1,$imm16o

void
mt_sem_dbnz (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_brlt.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

{
if (NOTBI (EQSI (current_cpu->hardware.h_spr[FLD (f_sr1)], 0))) {
  {
    USI opval = ADDSI (pc, EXTSISI (FLD (f_imm16s)));
    buf.h_pc_writes [(tick + 1) % mt::pipe_sz].push (mt::write<USI>(pc, opval));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
  }
}
}

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** ei: ei

void
mt_sem_ei (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

current_cpu->enable_interrupts ();

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** di: di

void
mt_sem_di (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

current_cpu->disable_interrupts ();

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** si: si $frdrrr

void
mt_sem_si (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_add.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

{
  {
    SI opval = ADDSI (pc, 4);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_drrr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_drrr)] = opval;
  }
current_cpu->do_syscall (pc);
}

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** reti: reti $frsr1

void
mt_sem_reti (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_brlt.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

{
current_cpu->enable_interrupts ();
  {
    USI opval = current_cpu->hardware.h_spr[FLD (f_sr1)];
    buf.h_pc_writes [(tick + 1) % mt::pipe_sz].push (mt::write<USI>(pc, opval));
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "pc" << ":=0x" << hex << opval << dec << "  ";
  }
}

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** ldw: ldw $frdr,$frsr1,#$imm16

void
mt_sem_ldw (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_addi.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

{
  USI tmp_ea;
  HI tmp_tmp;
  tmp_tmp = ANDSI (FLD (f_imm16s), 65535);
  tmp_ea = ANDSI (ADDSI (current_cpu->hardware.h_spr[FLD (f_sr1)], EXTHISI (tmp_tmp)), 0xfffffffc);
  {
    SI opval = current_cpu->GETMEMSI (pc, tmp_ea);
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "spr" << '[' << FLD (f_dr) << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->hardware.h_spr[FLD (f_dr)] = opval;
  }
}

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** stw: stw $frsr2,$frsr1,#$imm16

void
mt_sem_stw (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_brlt.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

{
  USI tmp_ea;
  HI tmp_tmp;
  tmp_tmp = ANDSI (FLD (f_imm16s), 65535);
  tmp_ea = ANDSI (ADDSI (current_cpu->hardware.h_spr[FLD (f_sr1)], EXTHISI (tmp_tmp)), 0xfffffffc);
  {
    SI opval = current_cpu->hardware.h_spr[FLD (f_sr2)];
    if (UNLIKELY(current_cpu->trace_result_p))
      current_cpu->trace_stream << "memory" << '[' <<  "0x" << hex << (UDI) tmp_ea << dec << ']' << ":=0x" << hex << opval << dec << "  ";
    current_cpu->SETMEMSI (pc, tmp_ea, opval);
  }
}

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** break: break

void
mt_sem_break (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

current_cpu->do_break (pc);

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** iflush: iflush

void
mt_sem_iflush (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** fbcb: fbcb $frsr1,#$rbbc,#$ball,#$brc,#$rc1,#$cbrb,#$cell,#$dup,#$ctxdisp

void
mt_sem_fbcb (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** mfbcb: mfbcb $frsr1,#$rbbc,$frsr2,#$rc1,#$cbrb,#$cell,#$dup,#$ctxdisp

void
mt_sem_mfbcb (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** fbcci: fbcci $frsr1,#$rbbc,#$ball,#$brc,#$fbdisp,#$cell,#$dup,#$ctxdisp

void
mt_sem_fbcci (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** fbrci: fbrci $frsr1,#$rbbc,#$ball,#$brc,#$fbdisp,#$cell,#$dup,#$ctxdisp

void
mt_sem_fbrci (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** fbcri: fbcri $frsr1,#$rbbc,#$ball,#$brc,#$fbdisp,#$cell,#$dup,#$ctxdisp

void
mt_sem_fbcri (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** fbrri: fbrri $frsr1,#$rbbc,#$ball,#$brc,#$fbdisp,#$cell,#$dup,#$ctxdisp

void
mt_sem_fbrri (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** mfbcci: mfbcci $frsr1,#$rbbc,$frsr2,#$fbdisp,#$cell,#$dup,#$ctxdisp

void
mt_sem_mfbcci (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** mfbrci: mfbrci $frsr1,#$rbbc,$frsr2,#$fbdisp,#$cell,#$dup,#$ctxdisp

void
mt_sem_mfbrci (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** mfbcri: mfbcri $frsr1,#$rbbc,$frsr2,#$fbdisp,#$cell,#$dup,#$ctxdisp

void
mt_sem_mfbcri (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** mfbrri: mfbrri $frsr1,#$rbbc,$frsr2,#$fbdisp,#$cell,#$dup,#$ctxdisp

void
mt_sem_mfbrri (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** fbcbdr: fbcbdr $frsr1,#$rbbc,$frsr2,#$ball2,#$brc2,#$rc1,#$cbrb,#$cell,#$dup,#$ctxdisp

void
mt_sem_fbcbdr (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** rcfbcb: rcfbcb #$rbbc,#$type,#$ball,#$brc,#$rownum,#$rc1,#$cbrb,#$cell,#$dup,#$ctxdisp

void
mt_sem_rcfbcb (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** mrcfbcb: mrcfbcb $frsr2,#$rbbc,#$type,#$rownum,#$rc1,#$cbrb,#$cell,#$dup,#$ctxdisp

void
mt_sem_mrcfbcb (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** cbcast: cbcast #$mask,#$rc2,#$ctxdisp

void
mt_sem_cbcast (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** dupcbcast: dupcbcast #$mask,#$cell,#$rc2,#$ctxdisp

void
mt_sem_dupcbcast (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** wfbi: wfbi #$bankaddr,#$rownum1,#$cell,#$dup,#$ctxdisp

void
mt_sem_wfbi (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** wfb: wfb $frsr1,$frsr2,#$fbdisp,#$rownum2,#$ctxdisp

void
mt_sem_wfb (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** rcrisc: rcrisc $frdrrr,#$rbbc,$frsr1,#$colnum,#$rc1,#$cbrb,#$cell,#$dup,#$ctxdisp

void
mt_sem_rcrisc (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** fbcbinc: fbcbinc $frsr1,#$rbbc,#$incamt,#$rc1,#$cbrb,#$cell,#$dup,#$ctxdisp

void
mt_sem_fbcbinc (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** rcxmode: rcxmode $frsr2,#$rda,#$wr,#$xmode,#$mask1,#$fbdisp,#$rownum2,#$rc2,#$ctxdisp

void
mt_sem_rcxmode (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** interleaver: intlvr $frsr1,#$mode,$frsr2,#$id,#$size

void
mt_sem_interleaver (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** wfbinc: wfbinc #$rda,#$wr,#$fbincr,#$ball,#$colnum,#$length,#$rownum1,#$rownum2,#$dup,#$ctxdisp

void
mt_sem_wfbinc (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** mwfbinc: mwfbinc $frsr2,#$rda,#$wr,#$fbincr,#$length,#$rownum1,#$rownum2,#$dup,#$ctxdisp

void
mt_sem_mwfbinc (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** wfbincr: wfbincr $frsr1,#$rda,#$wr,#$ball,#$colnum,#$length,#$rownum1,#$rownum2,#$dup,#$ctxdisp

void
mt_sem_wfbincr (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** mwfbincr: mwfbincr $frsr1,$frsr2,#$rda,#$wr,#$length,#$rownum1,#$rownum2,#$dup,#$ctxdisp

void
mt_sem_mwfbincr (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** fbcbincs: fbcbincs #$perm,#$a23,#$cr,#$cbs,#$incr,#$ccb,#$cdb,#$rownum2,#$dup,#$ctxdisp

void
mt_sem_fbcbincs (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** mfbcbincs: mfbcbincs $frsr1,#$perm,#$cbs,#$incr,#$ccb,#$cdb,#$rownum2,#$dup,#$ctxdisp

void
mt_sem_mfbcbincs (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** fbcbincrs: fbcbincrs $frsr1,#$perm,#$ball,#$colnum,#$cbx,#$ccb,#$cdb,#$rownum2,#$dup,#$ctxdisp

void
mt_sem_fbcbincrs (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** mfbcbincrs: mfbcbincrs $frsr1,$frsr2,#$perm,#$cbx,#$ccb,#$cdb,#$rownum2,#$dup,#$ctxdisp

void
mt_sem_mfbcbincrs (mt_cpu* current_cpu, mt_scache* sem, const int tick, 
	mt::write_stacks &buf)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  mt_scache* abuf = sem;
  unsigned long long written = 0;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

@


1.4
log
@Regenerate cgen files, update copyright year.
@
text
@d29 1
a29 1
#define FLD(f) abuf->fields.fmt_empty.f
d399 1
a399 1
#define FLD(f) abuf->fields.fmt_empty.f
d1004 1
a1004 1
#define FLD(f) abuf->fields.fmt_empty.f
d1023 1
a1023 1
#define FLD(f) abuf->fields.fmt_empty.f
d1156 1
a1156 1
#define FLD(f) abuf->fields.fmt_empty.f
d1175 1
a1175 1
#define FLD(f) abuf->fields.fmt_empty.f
d1194 1
a1194 1
#define FLD(f) abuf->fields.fmt_empty.f
d1213 1
a1213 1
#define FLD(f) abuf->fields.fmt_empty.f
d1232 1
a1232 1
#define FLD(f) abuf->fields.fmt_empty.f
d1251 1
a1251 1
#define FLD(f) abuf->fields.fmt_empty.f
d1270 1
a1270 1
#define FLD(f) abuf->fields.fmt_empty.f
d1289 1
a1289 1
#define FLD(f) abuf->fields.fmt_empty.f
d1308 1
a1308 1
#define FLD(f) abuf->fields.fmt_empty.f
d1327 1
a1327 1
#define FLD(f) abuf->fields.fmt_empty.f
d1346 1
a1346 1
#define FLD(f) abuf->fields.fmt_empty.f
d1365 1
a1365 1
#define FLD(f) abuf->fields.fmt_empty.f
d1384 1
a1384 1
#define FLD(f) abuf->fields.fmt_empty.f
d1403 1
a1403 1
#define FLD(f) abuf->fields.fmt_empty.f
d1422 1
a1422 1
#define FLD(f) abuf->fields.fmt_empty.f
d1441 1
a1441 1
#define FLD(f) abuf->fields.fmt_empty.f
d1460 1
a1460 1
#define FLD(f) abuf->fields.fmt_empty.f
d1479 1
a1479 1
#define FLD(f) abuf->fields.fmt_empty.f
d1498 1
a1498 1
#define FLD(f) abuf->fields.fmt_empty.f
d1517 1
a1517 1
#define FLD(f) abuf->fields.fmt_empty.f
d1536 1
a1536 1
#define FLD(f) abuf->fields.fmt_empty.f
d1555 1
a1555 1
#define FLD(f) abuf->fields.fmt_empty.f
d1574 1
a1574 1
#define FLD(f) abuf->fields.fmt_empty.f
d1593 1
a1593 1
#define FLD(f) abuf->fields.fmt_empty.f
d1612 1
a1612 1
#define FLD(f) abuf->fields.fmt_empty.f
d1631 1
a1631 1
#define FLD(f) abuf->fields.fmt_empty.f
d1650 1
a1650 1
#define FLD(f) abuf->fields.fmt_empty.f
d1669 1
a1669 1
#define FLD(f) abuf->fields.fmt_empty.f
d1688 1
a1688 1
#define FLD(f) abuf->fields.fmt_empty.f
d1707 1
a1707 1
#define FLD(f) abuf->fields.fmt_empty.f
d1726 1
a1726 1
#define FLD(f) abuf->fields.fmt_empty.f
@


1.3
log
@	* cgen-cpu.h: Update for new location of cgen/bitset.h.
	* tracedis.h: Ditto.

Plus update generated files to pick up two cgen changes:
1)
	* desc-cpu.scm (/gen-hash-defines): Remove #include of cgen-bitset.h.
	* sid-cpu.scm (cgen-desc.h): Update location of cgen's bitset.h.
2)
	* utils-sim.scm (/gen-set-itype-and-extract): New function.
	(/gen-bracketed-set-itype-and-extract): New function.
	(/gen-decode-default-entry): Rewrite.
	(/table-guts-to-mask, /all-opcode-bits-used?): New functions.
	(/gen-decode-insn-entry): New arg table-guts-thus-far, all callers
	updated.  Don't unnecessarily emit check for whether all opcode bits
	have been examined.
	(/gen-decode-expr-set-itype): Delete.
	(/gen-decode-expr-entry): Update.
	(/gen-decode-table-entry): New arg table-guts-thus-far, all callers
	updated.  Keep track of decoder tables used thus far.
	(/gen-decoder-switch): Ditto.
@
text
@d5 1
a5 1
Copyright (C) 2000-2009 Red Hat, Inc.
@


1.2
log
@	Second part of ms1 to mt renaming.
	* bfd/archures.c (bfd_arch_mt): Renamed.
	(bfd_mt_arch): Renamed.
	(bfd_archures_list): Adjusted.
	* bfd/bfd-in2.h: Rebuilt.
	* bfd/config.bfd (mt): Remove special case targ_archs.
	(mt-*-elf): Rename bfd_elf32_mt_vec.
	* bfd/configure: Rebuilt.
	* bfd/configure.in (bfd_elf32_mt_vec): Renamed.
	(selarchs) Remove mt special case.
	* bfd/cpu-mt.c (arch_info_struct): Adjust.
	(bfd_mt_arch): Renamed, adjust.
	* bfd/elf32-mt.c (mt_reloc_type_lookup, mt_info_to_howto_rela,
	mt_elf_relocate_hi16, mt_final_link_relocate, mt_relocate_section,
	mt_elf_howto_table): Renamed, adjusted.
	(mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook, mt_elf_check_relocs,
	elf32_mt_machine, mt_elf_object_p, mt_elf_set_private_flags,
	mt_elf_copy_private_bfd_data, mt_elf_merge_private_bfd_data,
	mt_elf_print_private_bfd_data): Renamed, adjusted.
	(TARGET_BIG_SYM, TARGET_BIG_NAME, ELF_ARCH, ELF_MACHINE_CODE,
	ELF_MAXPAGESIZE, elf_info_to_howto, elf_backend_relocate_section,
	bfd_elf32_bfd_reloc_type_lookup, elf_backend_gc_mark_hook,
	elf_backend_gc_sweep_hook, elf_backend_check_relocs,
	eld_backend_object_p, bfd_elf32_bfd_set_private_flags,
	bfd_elf32_bfd_copy_private_bfd_data,
	bfd_elf32_bfd_merge_private_bfd_data,
	bfd_elf32_bfd_print_private_bfd_data): Adjusted.
	* bfd/libbfd.h: Regenerated.
	* bfd/reloc.c (BFD_RELOC_MT_PC16, BFD_RELOC_MT_HI16,
	BFD_RELOC_MT_LO16, BFD_RELOC_MT_GNU_VTINHERIT,
	BFD_RELOC_MT_GNU_VTENTRY, BFD_RELOC_MT_PCINSN8): Renamed.
	* bfd/targets.c (bfd_elf32_mt_vec): Renamed.
	(_bfd_target_vector): Adjusted.
	* binutils/readelf.c (guess_is_rela): Use EM_MT.
	(dump_relocations, get_machine_name): Adjust.

	* cpu/mt.cpu (define-arch, define-isa): Set name to mt.
	(define-mach): Adjust.
	* cpu/mt.opc (CGEN_ASM_HASH): Update.
	(mt_asm_hash, mt_cgen_insn_supported): Renamed.
	(parse_loopsize, parse_imm16): Adjust.

	* gas/configure: Rebuilt.
	* gas/configure.in (mt): Remove special case.
	* gas/config/tc-mt.c (opcodes/mt-desc.h, opcodes/mt-opc.h): Change
	#includes.
	(mt_insn, mt_mach, mt_mach_bitmask, mt_flags, mt_architectures):
	Rename, adjust.
	(md_parse_option, md_show_usage, md_begin, md_assemble,
	md_cgen_lookup_reloc, md_atof): Adjust.
	(mt_force_relocation, mt_apply_fix, mt_fix_adjustable): Rename, adjust.
	* gas/config/tc-mt.h (TC_MT): Rename.
	(LISTING_HEADER, TARGET_ARCH, TARGET_FORMAT): Adjust.
	(md_apply_fix): Adjust.
	(mt_apply_fix, mt_fix_adjustable, mt_force_relocation): Rename.
	(TC_FORCE_RELOCATION, tc_fix_adjustable): Adjust.

	* gdb/mt-tdep.c (mt_arch_constants, mt_gdb_regnums): Rename, adjust.
	(mt_register_name, mt_register_type, mt_register_reggroup_p,
	mt_return_value, mt_skip_prologue, mt_breapoint_from_pc,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_frame_align,
	mt_registers_info, mt_push_dummy_call, mt_unwind_cache,
	mt_frame_unwind_cache, mt_unwind_pc, mt_unwind_dummy_id,
	mt_frame_this_id, mt_frame_prev_register, mt_frame_base_address,
	mt_frame_unwind, mt_frame_sniffer, mt_frame_base, mt_gdbarch_init,
	_initialize_mt_tdep): Rename & adjust.

	* include/dis-asm.h (print_insn_mt): Renamed.

	* include/elf/common.h (EM_MT): Renamed.
	* include/elf/mt.h: Rename relocs, cpu & other defines.

	* ld/emulparams/elf32mt.sh (ARCH, OUTPUT_FORMAT): Adjust.

	* opcodes/Makefile.am (HFILES, CFILES, ALL_MACHINES): Adjust.
	(stamp-mt): Adjust rule.
	(mt-asm.lo, mt-desc.lo, mt-dis.lo, mt-ibld.lo, mt-opc.lo): Rename &
	adjust.
	* opcodes/Makefile.in: Rebuilt.
	* opcodes/configure: Rebuilt.
	* opcodes/configure.in (bfd_mt_arch): Rename & adjust.
	* opcodes/disassemble.c (ARCH_mt): Renamed.
	(disassembler): Adjust.
	* opcodes/mt-asm.c: Renamed, rebuilt.
	* opcodes/mt-desc.c: Renamed, rebuilt.
	* opcodes/mt-desc.h: Renamed, rebuilt.
	* opcodes/mt-dis.c: Renamed, rebuilt.
	* opcodes/mt-ibld.c: Renamed, rebuilt.
	* opcodes/mt-opc.c: Renamed, rebuilt.
	* opcodes/mt-opc.h: Renamed, rebuilt.

	* sid/Makefile.in: Rebuilt.
	* sid/aclocal.m4: Rebuilt.
	* sid/configure: Rebuilt.
	* sid/sid.spec: Adjust.
	* sid/bsp/Makefile.am: Adjust.
	* sid/bsp/Makefile.in: Rebuilt.
	* sid/bsp/aclocal.m4: Rebuilt.
	* sid/bsp/configrun-sid.in: Adjust.
	* sid/bsp/pregen/Makefile.in: Rebuilt.
	* sid/bsp/pregen/mt-gdb.conf: Renamed & rebuilt.
	* sid/bsp/pregen/mt-gloss.conf: Renamed & rebuilt.
	* sid/bsp/pregen/pregen-configs.in: Adjust.
	* sid/component/aclocal.m4: Rebuilt.
	* sid/component/configure: Rebuilt.
	* sid/component/tconfig.in: Adjust.
	* sid/component/bochs/aclocal.m4: Rebuilt.
	* sid/component/cache/Makefile.in: Rebuilt.
	* sid/component/cgen-cpu/Makefile.in: Rebuilt.
	* sid/component/cgen-cpu/aclocal.m4: Rebuilt.
	* sid/component/cgen-cpu/compCGEN.cxx: Adjust.
	* sid/component/cgen-cpu/configure: Rebuilt.
	* sid/component/cgen-cpu/configure.in: Rebult.
	* sid/component/cgen-cpu/mt/Makefile.am: Adjust.
	* sid/component/cgen-cpu/mt/Makefile.in: Rebuilt.
	* sid/component/cgen-cpu/mt/hw-cpu-mt.txt: Adjust.
	* sid/component/cgen-cpu/mt/mt-cpu.h: Rebuilt.
	* sid/component/cgen-cpu/mt/mt-decode.cxx: Rebuilt.
	* sid/component/cgen-cpu/mt/mt-decode.h: Rebuilt.
	* sid/component/cgen-cpu/mt/mt-defs.h: Rebuilt.
	* sid/component/cgen-cpu/mt/mt-desc.h: Rebuilt.
	* sid/component/cgen-cpu/mt/mt-sem.cxx: Rebuilt.
	* sid/component/cgen-cpu/mt/mt-write.cxx: Rebuilt.
	* sid/component/cgen-cpu/mt/mt.cxx: Adjust.
	* sid/component/cgen-cpu/mt/mt.h: Adjust.
	* sid/component/consoles/Makefile.in: Rebuilt.
	* sid/component/families/aclocal.m4: Rebuilt.
	* sid/component/families/configure: Rebuilt.
	* sid/component/gdb/Makefile.in: Rebuilt.
	* sid/component/gloss/Makefile.in: Rebuilt.
	* sid/component/glue/Makefile.in: Rebuilt.
	* sid/component/ide/Makefile.in: Rebuilt.
	* sid/component/interrupt/Makefile.in: Rebuilt.
	* sid/component/lcd/Makefile.in: Rebuilt.
	* sid/component/lcd/testsuite/Makefile.in: Rebuilt.
	* sid/component/loader/Makefile.am: Rebuilt.
	* sid/component/loader/Makefile.in: Rebuilt.
	* sid/component/mapper/Makefile.in: Rebuilt.
	* sid/component/mapper/testsuite/Makefile.in: Rebuilt.
	* sid/component/memory/Makefile.in: Rebuilt.
	* sid/component/mmu/Makefile.in: Rebuilt.
	* sid/component/parport/Makefile.in: Rebuilt.
	* sid/component/profiling/Makefile.in: Rebuilt.
	* sid/component/rtc/Makefile.in: Rebuilt.
	* sid/component/sched/Makefile.in: Rebuilt.
	* sid/component/testsuite/Makefile.in: Rebuilt.
	* sid/component/timers/aclocal.m4: Rebuilt.
	* sid/component/timers/configure: Rebuilt.
	* sid/component/uart/Makefile.in: Rebuilt.
	* sid/component/uart/testsuite/Makefile.in: Rebuilt.
	* sid/config/config.sub: Adjust.
	* sid/config/info.tcl.in: Adjust.
	* sid/config/sidtargets.m4: Adjust.
	* sid/doc/Makefile.in: Rebuilt.
	* sid/main/dynamic/Makefile.am: Rebuilt.
	* sid/main/dynamic/Makefile.in: Rebuilt.
	* sid/main/dynamic/aclocal.m4: Rebuilt.
	* sid/main/dynamic/configure: Rebuilt.
@
text
@d5 1
a5 1
Copyright (C) 2000-2005 Red Hat, Inc.
d810 1
a810 1
if (LTSI (current_cpu->hardware.h_spr[FLD (f_sr1)], current_cpu->hardware.h_spr[FLD (f_sr2)])) {
d838 1
a838 1
if (LESI (current_cpu->hardware.h_spr[FLD (f_sr1)], current_cpu->hardware.h_spr[FLD (f_sr2)])) {
@


1.1
log
@Rename ms1 files to mt files (part 1 -- renames only)
@
text
@d1 1
a1 1
/* Simulator instruction semantics for ms1.
d16 1
a16 4
#include "ms1.h"

using namespace ms1; // FIXME: namespace organization still wip
using namespace ms1; // FIXME: namespace organization still wip
d18 2
d26 2
a27 2
ms1_sem_x_invalid (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d31 2
a32 1
  ms1_scache* abuf = sem;
d49 2
a50 2
ms1_sem_add (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d54 2
a55 1
  ms1_scache* abuf = sem;
d73 2
a74 2
ms1_sem_addu (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d78 2
a79 1
  ms1_scache* abuf = sem;
d97 2
a98 2
ms1_sem_addi (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d102 2
a103 1
  ms1_scache* abuf = sem;
d125 2
a126 2
ms1_sem_addui (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d130 2
a131 1
  ms1_scache* abuf = sem;
d149 2
a150 2
ms1_sem_sub (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d154 2
a155 1
  ms1_scache* abuf = sem;
d173 2
a174 2
ms1_sem_subu (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d178 2
a179 1
  ms1_scache* abuf = sem;
d197 2
a198 2
ms1_sem_subi (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d202 2
a203 1
  ms1_scache* abuf = sem;
d225 2
a226 2
ms1_sem_subui (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d230 2
a231 1
  ms1_scache* abuf = sem;
d249 2
a250 2
ms1_sem_mul (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d254 2
a255 1
  ms1_scache* abuf = sem;
d285 2
a286 2
ms1_sem_muli (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d290 2
a291 1
  ms1_scache* abuf = sem;
d324 2
a325 2
ms1_sem_and (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d329 2
a330 1
  ms1_scache* abuf = sem;
d348 2
a349 2
ms1_sem_andi (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d353 2
a354 1
  ms1_scache* abuf = sem;
d372 2
a373 2
ms1_sem_or (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d377 2
a378 1
  ms1_scache* abuf = sem;
d396 2
a397 2
ms1_sem_nop (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d401 2
a402 1
  ms1_scache* abuf = sem;
d415 2
a416 2
ms1_sem_ori (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d420 2
a421 1
  ms1_scache* abuf = sem;
d439 2
a440 2
ms1_sem_xor (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d444 2
a445 1
  ms1_scache* abuf = sem;
d463 2
a464 2
ms1_sem_xori (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d468 2
a469 1
  ms1_scache* abuf = sem;
d487 2
a488 2
ms1_sem_nand (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d492 2
a493 1
  ms1_scache* abuf = sem;
d511 2
a512 2
ms1_sem_nandi (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d516 2
a517 1
  ms1_scache* abuf = sem;
d535 2
a536 2
ms1_sem_nor (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d540 2
a541 1
  ms1_scache* abuf = sem;
d559 2
a560 2
ms1_sem_nori (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d564 2
a565 1
  ms1_scache* abuf = sem;
d583 2
a584 2
ms1_sem_xnor (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d588 2
a589 1
  ms1_scache* abuf = sem;
d607 2
a608 2
ms1_sem_xnori (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d612 2
a613 1
  ms1_scache* abuf = sem;
d631 2
a632 2
ms1_sem_ldui (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d636 2
a637 1
  ms1_scache* abuf = sem;
d655 2
a656 2
ms1_sem_lsl (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d660 2
a661 1
  ms1_scache* abuf = sem;
d679 2
a680 2
ms1_sem_lsli (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d684 2
a685 1
  ms1_scache* abuf = sem;
d703 2
a704 2
ms1_sem_lsr (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d708 2
a709 1
  ms1_scache* abuf = sem;
d727 2
a728 2
ms1_sem_lsri (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d732 2
a733 1
  ms1_scache* abuf = sem;
d751 2
a752 2
ms1_sem_asr (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d756 2
a757 1
  ms1_scache* abuf = sem;
d775 2
a776 2
ms1_sem_asri (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d780 2
a781 1
  ms1_scache* abuf = sem;
d799 2
a800 2
ms1_sem_brlt (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d804 2
a805 1
  ms1_scache* abuf = sem;
d813 1
a813 1
    buf.h_pc_writes [(tick + 1) % ms1::pipe_sz].push (ms1::write<USI>(pc, opval));
d827 2
a828 2
ms1_sem_brle (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d832 2
a833 1
  ms1_scache* abuf = sem;
d841 1
a841 1
    buf.h_pc_writes [(tick + 1) % ms1::pipe_sz].push (ms1::write<USI>(pc, opval));
d855 2
a856 2
ms1_sem_breq (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d860 2
a861 1
  ms1_scache* abuf = sem;
d869 1
a869 1
    buf.h_pc_writes [(tick + 1) % ms1::pipe_sz].push (ms1::write<USI>(pc, opval));
d883 2
a884 2
ms1_sem_brne (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d888 2
a889 1
  ms1_scache* abuf = sem;
d897 1
a897 1
    buf.h_pc_writes [(tick + 1) % ms1::pipe_sz].push (ms1::write<USI>(pc, opval));
d911 2
a912 2
ms1_sem_jmp (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d916 2
a917 1
  ms1_scache* abuf = sem;
d923 1
a923 1
    buf.h_pc_writes [(tick + 1) % ms1::pipe_sz].push (ms1::write<USI>(pc, opval));
d935 2
a936 2
ms1_sem_jal (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d940 2
a941 1
  ms1_scache* abuf = sem;
d952 1
a952 1
    buf.h_spr_writes [(tick + 1) % ms1::pipe_sz].push (ms1::write<SI>(pc, opval, FLD (f_drrr)));
d958 1
a958 1
    buf.h_pc_writes [(tick + 1) % ms1::pipe_sz].push (ms1::write<USI>(pc, opval));
d973 2
a974 2
ms1_sem_dbnz (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d978 2
a979 1
  ms1_scache* abuf = sem;
d987 1
a987 1
    buf.h_pc_writes [(tick + 1) % ms1::pipe_sz].push (ms1::write<USI>(pc, opval));
d1001 2
a1002 2
ms1_sem_ei (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1006 2
a1007 1
  ms1_scache* abuf = sem;
d1020 2
a1021 2
ms1_sem_di (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1025 2
a1026 1
  ms1_scache* abuf = sem;
d1039 2
a1040 2
ms1_sem_si (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1044 2
a1045 1
  ms1_scache* abuf = sem;
d1066 2
a1067 2
ms1_sem_reti (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1071 2
a1072 1
  ms1_scache* abuf = sem;
d1080 1
a1080 1
    buf.h_pc_writes [(tick + 1) % ms1::pipe_sz].push (ms1::write<USI>(pc, opval));
d1093 2
a1094 2
ms1_sem_ldw (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1098 2
a1099 1
  ms1_scache* abuf = sem;
d1123 2
a1124 2
ms1_sem_stw (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1128 2
a1129 1
  ms1_scache* abuf = sem;
d1153 2
a1154 2
ms1_sem_break (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1158 2
a1159 1
  ms1_scache* abuf = sem;
d1172 2
a1173 56
ms1_sem_iflush (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
{
#define FLD(f) abuf->fields.fmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  ms1_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** ldctxt: ldctxt $frsr1,$frsr2,#$rc,#$rcnum,#$contnum

void
ms1_sem_ldctxt (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
{
#define FLD(f) abuf->fields.fmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  ms1_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** ldfb: ldfb $frsr1,$frsr2,#$imm16z

void
ms1_sem_ldfb (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
{
#define FLD(f) abuf->fields.fmt_empty.f
  sem_status status = SEM_STATUS_NORMAL;
  ms1_scache* abuf = sem;
  PCADDR pc = abuf->addr;
  PCADDR npc = pc + 4;

((void) 0); /*nop*/

  current_cpu->done_insn (npc, status);
#undef FLD
}

// ********** stfb: stfb $frsr1,$frsr2,#$imm16z

void
ms1_sem_stfb (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1177 2
a1178 1
  ms1_scache* abuf = sem;
d1191 2
a1192 2
ms1_sem_fbcb (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1196 2
a1197 1
  ms1_scache* abuf = sem;
d1210 2
a1211 2
ms1_sem_mfbcb (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1215 2
a1216 1
  ms1_scache* abuf = sem;
d1229 2
a1230 2
ms1_sem_fbcci (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1234 2
a1235 1
  ms1_scache* abuf = sem;
d1248 2
a1249 2
ms1_sem_fbrci (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1253 2
a1254 1
  ms1_scache* abuf = sem;
d1267 2
a1268 2
ms1_sem_fbcri (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1272 2
a1273 1
  ms1_scache* abuf = sem;
d1286 2
a1287 2
ms1_sem_fbrri (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1291 2
a1292 1
  ms1_scache* abuf = sem;
d1305 2
a1306 2
ms1_sem_mfbcci (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1310 2
a1311 1
  ms1_scache* abuf = sem;
d1324 2
a1325 2
ms1_sem_mfbrci (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1329 2
a1330 1
  ms1_scache* abuf = sem;
d1343 2
a1344 2
ms1_sem_mfbcri (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1348 2
a1349 1
  ms1_scache* abuf = sem;
d1362 2
a1363 2
ms1_sem_mfbrri (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1367 2
a1368 1
  ms1_scache* abuf = sem;
d1381 2
a1382 2
ms1_sem_fbcbdr (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1386 2
a1387 1
  ms1_scache* abuf = sem;
d1400 2
a1401 2
ms1_sem_rcfbcb (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1405 2
a1406 1
  ms1_scache* abuf = sem;
d1419 2
a1420 2
ms1_sem_mrcfbcb (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1424 2
a1425 1
  ms1_scache* abuf = sem;
d1438 2
a1439 2
ms1_sem_cbcast (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1443 2
a1444 1
  ms1_scache* abuf = sem;
d1457 2
a1458 2
ms1_sem_dupcbcast (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1462 2
a1463 1
  ms1_scache* abuf = sem;
d1476 2
a1477 2
ms1_sem_wfbi (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1481 2
a1482 1
  ms1_scache* abuf = sem;
d1495 2
a1496 2
ms1_sem_wfb (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1500 2
a1501 1
  ms1_scache* abuf = sem;
d1514 2
a1515 2
ms1_sem_rcrisc (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1519 2
a1520 1
  ms1_scache* abuf = sem;
d1533 2
a1534 2
ms1_sem_fbcbinc (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1538 2
a1539 1
  ms1_scache* abuf = sem;
d1552 2
a1553 2
ms1_sem_rcxmode (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1557 2
a1558 1
  ms1_scache* abuf = sem;
d1571 2
a1572 2
ms1_sem_interleaver (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1576 2
a1577 1
  ms1_scache* abuf = sem;
d1590 2
a1591 2
ms1_sem_wfbinc (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1595 2
a1596 1
  ms1_scache* abuf = sem;
d1609 2
a1610 2
ms1_sem_mwfbinc (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1614 2
a1615 1
  ms1_scache* abuf = sem;
d1628 2
a1629 2
ms1_sem_wfbincr (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1633 2
a1634 1
  ms1_scache* abuf = sem;
d1647 2
a1648 2
ms1_sem_mwfbincr (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1652 2
a1653 1
  ms1_scache* abuf = sem;
d1666 2
a1667 2
ms1_sem_fbcbincs (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1671 2
a1672 1
  ms1_scache* abuf = sem;
d1685 2
a1686 2
ms1_sem_mfbcbincs (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1690 2
a1691 1
  ms1_scache* abuf = sem;
d1704 2
a1705 2
ms1_sem_fbcbincrs (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1709 2
a1710 1
  ms1_scache* abuf = sem;
d1723 2
a1724 2
ms1_sem_mfbcbincrs (ms1_cpu* current_cpu, ms1_scache* sem, const int tick, 
	ms1::write_stacks &buf)
d1728 2
a1729 1
  ms1_scache* abuf = sem;
@

