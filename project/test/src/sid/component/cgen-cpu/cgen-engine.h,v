head	1.8;
access;
symbols
	sid-snapshot-20180601:1.8
	sid-snapshot-20180501:1.8
	sid-snapshot-20180401:1.8
	sid-snapshot-20180301:1.8
	sid-snapshot-20180201:1.8
	sid-snapshot-20180101:1.8
	sid-snapshot-20171201:1.8
	sid-snapshot-20171101:1.8
	sid-snapshot-20171001:1.8
	sid-snapshot-20170901:1.8
	sid-snapshot-20170801:1.8
	sid-snapshot-20170701:1.8
	sid-snapshot-20170601:1.8
	sid-snapshot-20170501:1.8
	sid-snapshot-20170401:1.8
	sid-snapshot-20170301:1.8
	sid-snapshot-20170201:1.8
	sid-snapshot-20170101:1.8
	sid-snapshot-20161201:1.8
	sid-snapshot-20161101:1.8
	sid-snapshot-20160901:1.8
	sid-snapshot-20160801:1.8
	sid-snapshot-20160701:1.8
	sid-snapshot-20160601:1.8
	sid-snapshot-20160501:1.8
	sid-snapshot-20160401:1.8
	sid-snapshot-20160301:1.8
	sid-snapshot-20160201:1.8
	sid-snapshot-20160101:1.8
	sid-snapshot-20151201:1.8
	sid-snapshot-20151101:1.8
	sid-snapshot-20151001:1.8
	sid-snapshot-20150901:1.8
	sid-snapshot-20150801:1.8
	sid-snapshot-20150701:1.8
	sid-snapshot-20150601:1.8
	sid-snapshot-20150501:1.8
	sid-snapshot-20150401:1.8
	sid-snapshot-20150301:1.8
	sid-snapshot-20150201:1.8
	sid-snapshot-20150101:1.8
	sid-snapshot-20141201:1.8
	sid-snapshot-20141101:1.8
	sid-snapshot-20141001:1.8
	sid-snapshot-20140901:1.8
	sid-snapshot-20140801:1.8
	sid-snapshot-20140701:1.8
	sid-snapshot-20140601:1.8
	sid-snapshot-20140501:1.8
	sid-snapshot-20140401:1.8
	sid-snapshot-20140301:1.8
	sid-snapshot-20140201:1.8
	sid-snapshot-20140101:1.8
	sid-snapshot-20131201:1.8
	sid-snapshot-20131101:1.8
	sid-snapshot-20131001:1.8
	sid-snapshot-20130901:1.8
	sid-snapshot-20130801:1.8
	sid-snapshot-20130701:1.8
	sid-snapshot-20130601:1.8
	sid-snapshot-20130501:1.8
	sid-snapshot-20130401:1.8
	sid-snapshot-20130301:1.8
	sid-snapshot-20130201:1.8
	sid-snapshot-20130101:1.8
	sid-snapshot-20121201:1.8
	sid-snapshot-20121101:1.8
	sid-snapshot-20121001:1.8
	sid-snapshot-20120901:1.8
	sid-snapshot-20120801:1.8
	sid-snapshot-20120701:1.8
	sid-snapshot-20120601:1.8
	sid-snapshot-20120501:1.8
	sid-snapshot-20120401:1.8
	sid-snapshot-20120301:1.8
	sid-snapshot-20120201:1.8
	sid-snapshot-20120101:1.8
	sid-snapshot-20111201:1.8
	sid-snapshot-20111101:1.8
	sid-snapshot-20111001:1.8
	sid-snapshot-20110901:1.8
	sid-snapshot-20110801:1.8
	sid-snapshot-20110701:1.8
	sid-snapshot-20110601:1.8
	sid-snapshot-20110501:1.8
	sid-snapshot-20110401:1.8
	sid-snapshot-20110301:1.8
	sid-snapshot-20110201:1.8
	sid-snapshot-20110101:1.8
	sid-snapshot-20101201:1.8
	sid-snapshot-20101101:1.8
	sid-snapshot-20101001:1.8
	sid-snapshot-20100901:1.8
	sid-snapshot-20100801:1.8
	sid-snapshot-20100701:1.8
	sid-snapshot-20100601:1.8
	sid-snapshot-20100501:1.8
	sid-snapshot-20100401:1.8
	sid-snapshot-20100301:1.8
	sid-snapshot-20100201:1.8
	sid-snapshot-20100101:1.8
	sid-snapshot-20091201:1.8
	sid-snapshot-20091101:1.7
	sid-snapshot-20091001:1.7
	sid-snapshot-20090901:1.7
	sid-snapshot-20090801:1.7
	sid-snapshot-20090701:1.7
	sid-snapshot-20090601:1.7
	sid-snapshot-20090501:1.7
	sid-snapshot-20090401:1.7
	sid-snapshot-20090301:1.7
	sid-snapshot-20090201:1.7
	sid-snapshot-20090101:1.7
	sid-snapshot-20081201:1.7
	sid-snapshot-20081101:1.7
	sid-snapshot-20081001:1.7
	sid-snapshot-20080901:1.7
	sid-snapshot-20080801:1.7
	sid-snapshot-20080701:1.7
	sid-snapshot-20080601:1.7
	sid-snapshot-20080501:1.7
	sid-snapshot-20080403:1.7
	sid-snapshot-20080401:1.7
	sid-snapshot-20080301:1.7
	sid-snapshot-20080201:1.7
	sid-snapshot-20080101:1.7
	sid-snapshot-20071201:1.7
	sid-snapshot-20071101:1.7
	sid-snapshot-20071001:1.7
	sid-20020905-branchpoint:1.3
	sid-20020905-branch:1.3.0.2
	cygnus_cvs_20020108_pre:1.3;
locks; strict;
comment	@ * @;


1.8
date	2009.11.23.09.24.24;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.07.04.39.29;	author jimb;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.12.16.25.45;	author fche;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.21.21.29.31;	author brolley;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.06.20.44.34;	author fche;	state Exp;
branches;
next	1.3;

1.3
date	2001.12.15.00.05.54;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.01.19.15.31;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.07.19.30.47;	author fche;	state Exp;
branches;
next	;


desc
@@


1.8
log
@	* cgen-engine.h (EXTRACT_MSB0_SINT): Renamed from EXTRACT_MSB0_INT.
	(EXTRACT_LSB0_SINT): Renamed from EXTRACT_LSB0_INT.
	(EXTRACT_MSB0_LGSINT, EXTRACT_MSB0_LGUINT): Define.
	(EXTRACT_LSB0_LGSINT, EXTRACT_LSB0_LGUINT): Define.
plus regenerate cgen files.
@
text
@// cgen-engine.h - CGEN engine support.  -*- C++ -*-

// Copyright (C) 1999, 2000, 2003 Red Hat.
// This file is part of SID and is licensed under the GPL.
// See the file COPYING.SID for conditions for redistribution.

#ifndef CGEN_ENGINE_H
#define CGEN_ENGINE_H

namespace cgen {

// Result of semantic fns.

enum sem_status
{
  SEM_STATUS_NORMAL,
  SEM_STATUS_BRANCH_TAKEN,
  SEM_STATUS_DELAYED_BRANCH_TAKEN,
  SEM_STATUS_STALLED
};


// Virtual insn support.

// Canonical ids of virtual insns.
enum virtual_insn_type {
  VIRTUAL_INSN_INVALID,
  VIRTUAL_INSN_BEGIN,
  VIRTUAL_INSN_COND,
  VIRTUAL_INSN_CHAIN, VIRTUAL_INSN_CTI_CHAIN,
  VIRTUAL_INSN_BEFORE, VIRTUAL_INSN_AFTER,
};

// Exceptions used to exit the cpu's "main loop".

class cgen_trap
{
};

class cgen_yield_trap: public cgen_trap
{
public:
  PCADDR newpc;
  cgen_yield_trap(PCADDR p): newpc(p) {}
};

class cgen_memory_trap: public cgen_trap
{
public:
  ADDR address;
  PCADDR pc;
  ::sid::bus::status status;
  bool imem_p;
  const char* memory_name;
  const char* operation;

  cgen_memory_trap(PCADDR p, ADDR a, ::sid::bus::status s, const char* n, const char* o): 
    address(a), pc(p), status(s), imem_p(false), memory_name(n), operation(o) {}
  cgen_memory_trap(PCADDR p, ADDR a, ::sid::bus::status s, const char* n, const char* o, bool i): 
    address(a), pc(p), status(s), imem_p(i), memory_name(n), operation(o) {}
};

enum branch_status {
  BRANCH_UNTAKEN = 0,
  BRANCH_UNCACHEABLE = 1,
  BRANCH_CACHEABLE = 2
};

// Scache engine.

template <typename scache_content>
struct generic_scache_record
{
  PCADDR addr;
  scache_content content;
};


template <typename scache_record>
class scache_engine
{
private:

  scache_record* cache;
  size_t size; // XXX: must be power of two!
  unsigned mask;
  enum { UNUSED_ADDR = -1 }; // sentinel value

  inline size_t
  hash (PCADDR pc) const
    {
      // XXX: tune! [if all insns are 4 bytes, should at least do >> 2]
      return ((pc >> 1) & mask);
    }

public:

  scache_engine (size_t s):
    size(s)
    {
      mask = size - 1;
      cache = new scache_record[size];
      for (unsigned i = 0; i < size; ++i)
	cache[i].addr = (PCADDR) UNUSED_ADDR;
    }

  ~scache_engine ()
    {
      delete [] this->cache;
    }

  void
  zap (PCADDR pc)
    {
      assert (pc != (PCADDR) UNUSED_ADDR);
      scache_record* x = & cache[hash(pc)];
      if (x->addr == pc)
	x->addr = (PCADDR) UNUSED_ADDR;
    }

  void
  flush ()
    {
      for (unsigned i = 0; i < size; ++i)
	cache[i].addr = (PCADDR) UNUSED_ADDR;
    }

  
  inline scache_record*
  find (PCADDR pc, bool& reuse)
    {
      assert (pc != (PCADDR) UNUSED_ADDR);
      scache_record* x = & cache[hash(pc)];
      reuse = (x->addr == pc);
      return x;
    }
};

// PBB engine.
// This engine supports both the scache and pbb engines.  Either may be in
// use at various times during the execution of a program, and we don't want
// to keep separate copies of the cache [clumsy use of memory].
//
// ABUF is short for Argument BUFfer.

// Two kinds of computed goto (threaded) engines are supported: one entry per
// insn and one entry per insn fragment (where an insn can be made up of one
// or more fragments).

union cgoto_label {
  void* label;
  void** frags;
};

template <typename scache_record>
struct hash_table_entry
{
  PCADDR addr;
  scache_record* abuf;
};

// ??? This could be implemented by inheriting from `scache', but for the
// time being we don't.  Not sure it'll be warranted.

template <typename cpu_class, typename scache_record>
class pbb_engine
{
private:
  scache_record* cache;
  size_t cache_size; // XXX: must be power of two!
  size_t cache_size_mask;
  // ??? There is no perfect sentinel value to use, but this one should
  // work for the foreseeable future.
  enum { UNUSED_ADDR = -1 }; // sentinel value
  enum { MINIMUM_CACHE_SIZE = 8 };

  // true if using pbb engine, otherwise using scache engine
  bool pbb_p;

  typedef hash_table_entry<scache_record> hash_table_t;

  // Pointer to end of used part of pbb cache.
  scache_record* next_free;
  // Hash table into pbb cache.
  hash_table_t* hash_table;
  size_t hash_table_size;
  size_t hash_size_mask;

  // The pbb hash table is a linear collection of entries.  Lookup involves
  // scanning this many entries starting at the hash point.
  static const unsigned max_tries = 4;

  // Maximum number of real insns in a block (doesn't include virtual insns).
  // Most basic blocks are far shorter than this.
  // The actual maximum block size is min (step_insn_count, max_block_size).
  static const unsigned max_block_size = 32;

  // Indices of cpu's virtual insns.
  unsigned begin_index, cond_index, chain_index, cti_chain_index;
  unsigned before_index, after_index;
  bool index_init_p;

  PCADDR last_traced_pc_pbb;

public:

  pbb_engine (size_t s)
    {
      last_traced_pc_pbb = (PCADDR) UNUSED_ADDR;

      cache_size = s;
      if (cache_size < MINIMUM_CACHE_SIZE)
	cache_size = MINIMUM_CACHE_SIZE;
      cache_size_mask = cache_size - 1;
      cache = new scache_record[cache_size];

      hash_table_size = cache_size / 8;
      if (hash_table_size < 64)
	hash_table_size = 64;
      hash_size_mask = hash_table_size - 1;
      // We allocated max_tries-1 more entries to simplify lookup [we don't
      // have to handle wrapping around from the end to the beginning].
      hash_table_size += max_tries - 1;
      hash_table = new hash_table_t[hash_table_size];

      // Start out in scache mode, and empty the cache.
      pbb_p = false;
      index_init_p = false;
      flush ();

      begin_insn.addr = (PCADDR) UNUSED_ADDR;
      next_vpc = & begin_insn;
    }

  ~pbb_engine ()
    {
      delete [] this->cache;
      delete [] this->hash_table;
    }

  void
  set_pbb_engine ()
    {
      if (UNLIKELY(! index_init_p))
	{
	  // Look up virtual insns indices so we only do the lookup once.
	  // ??? Initialized here until pbb support finished.
	  begin_index = begin_insn.idesc->lookup_virtual (VIRTUAL_INSN_BEGIN);
	  cond_index = begin_insn.idesc->lookup_virtual (VIRTUAL_INSN_COND);
	  chain_index = begin_insn.idesc->lookup_virtual (VIRTUAL_INSN_CHAIN);
	  cti_chain_index = begin_insn.idesc->lookup_virtual (VIRTUAL_INSN_CTI_CHAIN);
	  before_index = begin_insn.idesc->lookup_virtual (VIRTUAL_INSN_BEFORE);
	  after_index = begin_insn.idesc->lookup_virtual (VIRTUAL_INSN_AFTER);
	  index_init_p = true;
	}
      pbb_p = true;
      flush ();
    }

  void
  set_scache_engine ()
    {
      pbb_p = false;
      flush ();
    }

  void
  flush ()
    {
      last_traced_pc_pbb = (PCADDR) UNUSED_ADDR;

      if (pbb_p)
	{
	  next_free = cache;
	  for (unsigned i = 0; i < hash_table_size; ++i)
	    hash_table[i].addr = (PCADDR) UNUSED_ADDR;
	}
      else
	{
	  for (unsigned i = 0; i < cache_size; ++i)
	    cache[i].addr = (PCADDR) UNUSED_ADDR;
	}
    }

  // Scache engine

private:

  inline size_t
  hash (PCADDR pc) const
    {
      // XXX: tune! [if all insns are 4 bytes, should at least do >> 2]
      return ((pc >> 1) & cache_size_mask);
    }

public:

  void
  zap (PCADDR pc)
    {
      assert (pc != (PCADDR) UNUSED_ADDR);
      scache_record* x = & cache[hash(pc)];
      if (x->addr == pc)
	x->addr = (PCADDR) UNUSED_ADDR;
    }
  
  inline scache_record*
  find (PCADDR pc, bool& reuse)
    {
      assert (pc != (PCADDR) UNUSED_ADDR);
      scache_record* x = & cache[hash(pc)];
      reuse = (x->addr == pc);
      return x;
    }

  // PBB engine.

private:

  inline size_t
  pbb_hash (PCADDR pc) const
    {
      // XXX: tune! [if all insns are 4 bytes, should at least do >> 2]
      return ((pc >> 1) & hash_size_mask);
    }

  // Virtual insn that starts the compiler.
  scache_record begin_insn;

  // Next insn to execute.  Only valid when engine is *not* running.
  scache_record *next_vpc;

  /*inline*/ scache_record*
  chain (cpu_class* cpu, scache_record*& next, PCADDR npc)
    {
      // Goto next block if we're already chained to it.
      if (LIKELY(next))
	return next;
      // Try to find next block.
      next = pbb_find (npc);
      if (LIKELY(next))
	return next;
      // Have to compile next block.
      return & this->begin_insn;
    }

public:

  // public begin_insn accessor
  inline scache_record* get_begin_insn () { return & this->begin_insn; }

  // public next_vpc accessor
  inline scache_record*
  get_next_vpc (PCADDR pc)
    {
      scache_record* vpc = this->next_vpc;
      if (LIKELY(vpc->addr == pc))
	return vpc;
      return & this->begin_insn;
    }

  // save vpc for next time
  inline void set_next_vpc (scache_record* vpc) { this->next_vpc = vpc; }

  // Return maximum number of real insns for a block.
  inline unsigned
  max_real_insns (cpu_class* cpu)
    {
      return max_block_size;
    }

  /*inline*/ scache_record*
  pbb_find (PCADDR pc) const
    {
      hash_table_t* hte = & hash_table[pbb_hash (pc)];

      for (unsigned i = 0; i < max_tries; ++i, ++hte)
	if (LIKELY(hte->addr == pc))
	  return hte->abuf;
      return 0;
    }

  /*inline*/ scache_record*
  pbb_find_or_alloc (PCADDR pc, unsigned n, bool& found)
    {
      assert (n <= cache_size);

      hash_table_t* hte = & hash_table[pbb_hash (pc)];

      unsigned i = 0;
      for (hash_table_t* p = hte; i < max_tries; ++i, ++p)
	{
	  if (LIKELY(p->addr == pc))
	    {
	      found = true;
	      return p->abuf;
	    }
	  if (p->addr == (PCADDR) UNUSED_ADDR)
	    break;
	}

      // Not found, so alloc N entries and return that.
      // If there's not enough room, flush the cache.
      // ??? garbage collect instead
      // If the hash table is full, throw out a pseudo-random entry.

      found = false;

      size_t remaining = cache_size - (next_free - cache);

      // Cache full?
      if (UNLIKELY(remaining < n))
	{
	  flush ();
	  hte->addr = pc;
	  hte->abuf = next_free;
	  next_free += n;
	  return hte->abuf;
	}
      // Hash table full?
      else if (UNLIKELY(i == max_tries))
	{
	  static unsigned last_tossed = 0;

	  if (++last_tossed == max_tries)
	    last_tossed = 0;
	  hte[last_tossed].addr = pc;
	  hte[last_tossed].abuf = next_free;
	  next_free += n;
	  return hte[last_tossed].abuf;
	}
      // Neither cache nor hash table is full.
      else
	{
	  hte[i].addr = pc;
	  hte[i].abuf = next_free;
	  next_free += n;
	  return hte[i].abuf;
	}
    }

  // Initialize the begin_insn member.  There's only one copy of this insn
  // [per engine], it is not emitted into the instruction stream.

  void
  compile_begin_insn (cpu_class* cpu)
    {
      this->begin_insn.idesc =
	& this->begin_insn.idesc->idesc_table[this->begin_index];
      this->begin_insn.execute.cgoto = this->begin_insn.idesc->cgoto;
    }

  void
  compile_cond_insn (cpu_class* cpu, scache_record* abuf, PCADDR pc, UINT cond)
    {
      abuf->idesc = & abuf->idesc->idesc_table[this->cond_index];
      abuf->addr = pc;
      abuf->cond = cond;
      abuf->execute.cgoto = abuf->idesc->cgoto;
    }

  void
  compile_chain_insn (cpu_class* cpu, scache_record* abuf, PCADDR pc, unsigned insn_count)
    {
      abuf->idesc = & abuf->idesc->idesc_table[this->chain_index];
      abuf->addr = pc;
      abuf->fields.chain.insn_count = insn_count;
      abuf->fields.chain.next = 0;
      abuf->execute.cgoto = abuf->idesc->cgoto;
      // Close off this block.
      this->next_free = abuf + 1;
    }

  void
  compile_cti_chain_insn (cpu_class* cpu, scache_record* abuf, PCADDR pc, unsigned insn_count)
    {
      abuf->idesc = & abuf->idesc->idesc_table[this->cti_chain_index];
      abuf->addr = pc;
      abuf->fields.chain.insn_count = insn_count;
      abuf->fields.chain.next = 0;
      abuf->fields.chain.branch_target = 0;
      abuf->execute.cgoto = abuf->idesc->cgoto;
      // Close off this block.
      this->next_free = abuf + 1;
    }

  void
  compile_before_insn (cpu_class* cpu, scache_record* abuf, PCADDR pc, scache_record* insn)
    {
      abuf->idesc = & abuf->idesc->idesc_table[this->before_index];
      abuf->addr = pc;
      abuf->fields.before.insn = insn;
      abuf->execute.cgoto = abuf->idesc->cgoto;
    }

  void
  compile_after_insn (cpu_class* cpu, scache_record* abuf, PCADDR pc, scache_record* insn)
    {
      abuf->idesc = & abuf->idesc->idesc_table[this->after_index];
      abuf->addr = pc;
      abuf->fields.before.insn = insn; // XXX: yeah, sharing field with "before" insn
      abuf->execute.cgoto = abuf->idesc->cgoto;
    }

  /*inline*/ scache_record*
  pbb_chain (cpu_class* cpu, scache_record* abuf)
    {
      cpu->h_pc_set (abuf->addr);
      return chain (cpu, abuf->fields.chain.next, abuf->addr);
    }

  // This handles all forms of cti insns (uncond/cond,
  // cacheable-address/noncacheable-address), at the expense of two
  // compare/conditional-branches.  We don't do any of this in the insn's
  // handler as there can be virtual insns executed between it and us
  // [e.g. after,writeback].

  /*inline*/ scache_record*
  pbb_cti_chain (cpu_class* cpu, scache_record* abuf, branch_status br_status, PCADDR npc)
    {
      // Is address runtime computed?
      if (br_status == BRANCH_UNCACHEABLE)
	{
	  cpu->h_pc_set (npc);
	  return & this->begin_insn;
	}

      scache_record** link;
      if (br_status == BRANCH_UNTAKEN)
	{
	  npc = abuf->addr;
	  cpu->h_pc_set (npc);
	  link = & abuf->fields.chain.next;
	}
      else
	{
	  cpu->h_pc_set (npc);
	  link = & abuf->fields.chain.branch_target;
	}

      return chain (cpu, *link, npc);
    }

  /*inline*/ void
  pbb_before (cpu_class* cpu, scache_record* abuf)
    {
      if (UNLIKELY(cpu->trace_result_p))
	{
	  last_traced_pc_pbb = abuf->addr;
	  cpu->trace_stream
	    << "0x" << std::ios::hex << abuf->addr << std::ios::dec
	    << ": " << abuf->fields.before.insn->idesc->insn_name << "\t";
	}
    }

  /*inline*/ void
  pbb_after (cpu_class* cpu, scache_record* abuf)
    {
      if (UNLIKELY(cpu->trace_result_p))
	{
	  cpu->trace_stream << std::endl;

	  // This after hook may be called for an instruction one or two past the
	  // one for which pbb_begin was called.  This can happen for delay slots,
	  // for example.  By emitting an "extra" trace entry here, the difference
	  // between scache and pbb traces should disappear.

	  if (UNLIKELY((last_traced_pc_pbb != UNUSED_ADDR) && 
		       (last_traced_pc_pbb != abuf->addr)))
	    {
	      cpu->trace_stream
		<< "0x" << std::ios::hex << abuf->addr << std::ios::dec
		<< ": " << abuf->fields.before.insn->idesc->insn_name << "\t"
		<< std::endl;
	    }
	}
    }
};

// Instruction field support macros.

/* Treating the TOTAL least significant bits of VAL as a field, and
   numbering its leftmost bit zero, return the LENGTH-bit subfield
   whose leftmost bit is START.
   The '*SINT' version sign-extends; the '*UINT' version doesn't.  */
#define EXTRACT_MSB0_SINT(val, total, start, length) \
(((INT) (val) << ((sizeof (INT) * 8) - (total) + (start))) \
 >> ((sizeof (INT) * 8) - (length)))
#define EXTRACT_MSB0_UINT(val, total, start, length) \
(((UINT) (val) << ((sizeof (UINT) * 8) - (total) + (start))) \
 >> ((sizeof (UINT) * 8) - (length)))

/* Treating the TOTAL least significant bits of VAL as a field, and
   numbering its rightmost bit zero, return the LENGTH-bit subfield
   whose leftmost bit is START.
   The '*SINT' version sign-extends; the '*UINT' version doesn't.  */
#define EXTRACT_LSB0_SINT(val, total, start, length) \
(((INT) (val) << ((sizeof (INT) * 8) - (start) - 1)) \
 >> ((sizeof (INT) * 8) - (length)))
#define EXTRACT_LSB0_UINT(val, total, start, length) \
(((UINT) (val) << ((sizeof (UINT) * 8) - (start) - 1)) \
 >> ((sizeof (UINT) * 8) - (length)))

#define EXTRACT_MSB0_LGSINT(val, total, start, length) \
(((CGEN_INSN_LGSINT) (val) << ((sizeof (CGEN_INSN_LGSINT) * 8) - (total) + (start))) \
 >> ((sizeof (CGEN_INSN_LGSINT) * 8) - (length)))
#define EXTRACT_MSB0_LGUINT(val, total, start, length) \
(((CGEN_INSN_UINT) (val) << ((sizeof (CGEN_INSN_LGUINT) * 8) - (total) + (start))) \
 >> ((sizeof (CGEN_INSN_LGUINT) * 8) - (length)))

#define EXTRACT_LSB0_LGSINT(val, total, start, length) \
(((CGEN_INSN_LGSINT) (val) << ((sizeof (CGEN_INSN_LGSINT) * 8) - (start) - 1)) \
 >> ((sizeof (CGEN_INSN_LGSINT) * 8) - (length)))
#define EXTRACT_LSB0_LGUINT(val, total, start, length) \
(((CGEN_INSN_LGUINT) (val) << ((sizeof (CGEN_INSN_LGUINT) * 8) - (start) - 1)) \
 >> ((sizeof (CGEN_INSN_LGUINT) * 8) - (length)))

} // namespace cgen

#endif /* CGEN_CPU_H */
@


1.7
log
@* cgen-engine.h (EXTRACT_MSB0_INT, EXTRACT_MSB0_UINT)
(EXTRACT_LSB0_INT, EXTRACT_LSB0_UINT): Doc fixes.
@
text
@d585 2
a586 2
   The '*INT' version sign-extends; the '*UINT' version doesn't.  */
#define EXTRACT_MSB0_INT(val, total, start, length) \
d596 2
a597 2
   The '*INT' version sign-extends; the '*UINT' version doesn't.  */
#define EXTRACT_LSB0_INT(val, total, start, length) \
d604 14
@


1.6
log
@* build fixes for gcc 3.4

[cgen-cpu]
2005-02-12  Frank Ch. Eigler  <fche@@elastic.org>

	* cgen-engine.h (virtual_insn_type): Move decl here ...
	* cgen-cpu.h: ... from here.
	* Makefile.am (SOURCES): Don't try to build fp code.
	* Makefile.in: Regenerated.

[gdb]
2005-02-12  Frank Ch. Eigler  <fche@@elastic.org>

	* gdbserv-state.c (gdbserv_fromclient_break): Fix statementless
	label at end of block.

[mapper]
2005-02-12  Frank Ch. Eigler  <fche@@elastic.org>

	* compMapper.cxx (read/write_strideoffset_any, read/write_any):
	Move these generic_mapper_bus functions out of line.

[sched]
2005-02-12  Frank Ch. Eigler  <fche@@elastic.org>

	* compSched.cxx (scheduler_component): Clarify friend decl.

[timers/arm7t]
2005-02-12  Frank Ch. Eigler  <fche@@elastic.org>

	* arm7t-timer.h: Add needed friend decl.
@
text
@d582 4
d593 4
@


1.5
log
@2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * cgen-model.h (class cgen_model): step_cycles and step_latency
        now public.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * cgen-model.h (sidtypes.h): #include it.
        (model_insn_before): Call step_latency. Initialize vliw_cycles.
        (model_insn_after): Call step_cycles. Update vliw_cycles.
        (step_cycles): New method.
        (step_latency): New method.
        (vliw_cycles): New member of cgen_model.
        * cgen-engine.h (enum sem_status): Add SEM_STATUS_STALLED.
@
text
@d22 12
d248 6
a253 6
	  begin_index = begin_insn.idesc->lookup_virtual (cgen::VIRTUAL_INSN_BEGIN);
	  cond_index = begin_insn.idesc->lookup_virtual (cgen::VIRTUAL_INSN_COND);
	  chain_index = begin_insn.idesc->lookup_virtual (cgen::VIRTUAL_INSN_CHAIN);
	  cti_chain_index = begin_insn.idesc->lookup_virtual (cgen::VIRTUAL_INSN_CTI_CHAIN);
	  before_index = begin_insn.idesc->lookup_virtual (cgen::VIRTUAL_INSN_BEFORE);
	  after_index = begin_insn.idesc->lookup_virtual (cgen::VIRTUAL_INSN_AFTER);
@


1.4
log
@2003-02-06  Frank Ch. Eigler  <fche@@redhat.com>

	* cgen-engine.h: C++ namespace cleanup.

2003-02-06  Frank Ch. Eigler  <fche@@redhat.com>

	* arm-semsw.cxx: Sort of regenerated.
@
text
@d3 1
a3 1
// Copyright (C) 1999, 2000 Red Hat.
d18 2
a19 1
  SEM_STATUS_DELAYED_BRANCH_TAKEN
@


1.3
log
@* tweak

2001-12-14  Frank Ch. Eigler  <fche@@redhat.com>

	* cgen-engine.h (generic_scache_record): New template.
@
text
@d235 6
a240 6
	  begin_index = begin_insn.idesc->lookup_virtual (VIRTUAL_INSN_BEGIN);
	  cond_index = begin_insn.idesc->lookup_virtual (VIRTUAL_INSN_COND);
	  chain_index = begin_insn.idesc->lookup_virtual (VIRTUAL_INSN_CHAIN);
	  cti_chain_index = begin_insn.idesc->lookup_virtual (VIRTUAL_INSN_CTI_CHAIN);
	  before_index = begin_insn.idesc->lookup_virtual (VIRTUAL_INSN_BEFORE);
	  after_index = begin_insn.idesc->lookup_virtual (VIRTUAL_INSN_AFTER);
d538 1
a538 1
	    << "0x" << hex << abuf->addr << dec
d548 1
a548 1
	  cpu->trace_stream << endl;
d559 1
a559 1
		<< "0x" << hex << abuf->addr << dec
d561 1
a561 1
		<< endl;
@


1.2
log
@* branch probability hinting

[cgen/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* sid.cpu (-op-gen-set-trace[-parallel], -create-virtual-insns!):
	Emit LIKELY/UNLIKELY branch probability hints.
	* sid-decode.cpu (-gen-record-args): Ditto.

[sid/include/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* sidconfig.h (LIKELY, UNLIKELY): New conditional cover macros
	for gcc's __builtin_expect branch probability hinting function.
	* sidbusutil.h (passthrough_bus, mux_password_bus, harvard_bus):
	Add some branch probability hints.
	* sidcpuutil.h (step_pin_handler, stop_after_insns_p,
	{read,write}_{insn,data}_memory): Ditto.
	* sidpinutil.h (callback_pin::driven): Remove unnecessary assert
	from critical path.

[eg. sid/component/mapper/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* compMapper.cxx ({read,write}_strideoffset_any): Added b.p. hints.
	(write_any, read_any, locate): Ditto.

[sid/component/cgen-cpu/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* cgen-engine.h (set_pbb_engine, chain, get_next_vpc, pbb_find,
	pbb_find_or_alloc, pbb_before, pbb_after): Add branch probability
	hints.

[eg. sid/component/cgen-cpu/arm7t/ChangeLog]
2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* arm-decode.cxx, -sem.cxx, -semsw.cxx: Regenerated w/ b.p. hints.
	* thumb-decode.cxx, -sem.cxx, -semsw.cxx: Ditto.
@
text
@d58 8
@


1.1
log
@* public snapshot of sid simulator
@
text
@d223 1
a223 1
      if (! index_init_p)
d316 1
a316 1
      if (next)
d320 1
a320 1
      if (next)
d336 1
a336 1
      if (vpc->addr == pc)
d357 1
a357 1
	if (hte->addr == pc)
d372 1
a372 1
	  if (p->addr == pc)
d391 1
a391 1
      if (remaining < n)
d400 1
a400 1
      else if (i == max_tries)
d526 1
a526 1
      if (cpu->trace_result_p)
d538 1
a538 1
      if (cpu->trace_result_p)
d547 2
a548 2
	  if ((last_traced_pc_pbb != UNUSED_ADDR) && 
	      (last_traced_pc_pbb != abuf->addr))
@

