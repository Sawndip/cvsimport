head	1.18;
access;
symbols
	sid-snapshot-20180601:1.18
	sid-snapshot-20180501:1.18
	sid-snapshot-20180401:1.18
	sid-snapshot-20180301:1.18
	sid-snapshot-20180201:1.18
	sid-snapshot-20180101:1.18
	sid-snapshot-20171201:1.18
	sid-snapshot-20171101:1.18
	sid-snapshot-20171001:1.18
	sid-snapshot-20170901:1.18
	sid-snapshot-20170801:1.18
	sid-snapshot-20170701:1.18
	sid-snapshot-20170601:1.18
	sid-snapshot-20170501:1.18
	sid-snapshot-20170401:1.18
	sid-snapshot-20170301:1.18
	sid-snapshot-20170201:1.18
	sid-snapshot-20170101:1.18
	sid-snapshot-20161201:1.18
	sid-snapshot-20161101:1.18
	sid-snapshot-20160901:1.18
	sid-snapshot-20160801:1.18
	sid-snapshot-20160701:1.18
	sid-snapshot-20160601:1.18
	sid-snapshot-20160501:1.18
	sid-snapshot-20160401:1.18
	sid-snapshot-20160301:1.18
	sid-snapshot-20160201:1.18
	sid-snapshot-20160101:1.18
	sid-snapshot-20151201:1.18
	sid-snapshot-20151101:1.18
	sid-snapshot-20151001:1.18
	sid-snapshot-20150901:1.18
	sid-snapshot-20150801:1.18
	sid-snapshot-20150701:1.18
	sid-snapshot-20150601:1.18
	sid-snapshot-20150501:1.18
	sid-snapshot-20150401:1.18
	sid-snapshot-20150301:1.18
	sid-snapshot-20150201:1.18
	sid-snapshot-20150101:1.18
	sid-snapshot-20141201:1.18
	sid-snapshot-20141101:1.18
	sid-snapshot-20141001:1.18
	sid-snapshot-20140901:1.18
	sid-snapshot-20140801:1.18
	sid-snapshot-20140701:1.18
	sid-snapshot-20140601:1.18
	sid-snapshot-20140501:1.18
	sid-snapshot-20140401:1.18
	sid-snapshot-20140301:1.18
	sid-snapshot-20140201:1.18
	sid-snapshot-20140101:1.18
	sid-snapshot-20131201:1.18
	sid-snapshot-20131101:1.18
	sid-snapshot-20131001:1.18
	sid-snapshot-20130901:1.18
	sid-snapshot-20130801:1.18
	sid-snapshot-20130701:1.18
	sid-snapshot-20130601:1.18
	sid-snapshot-20130501:1.18
	sid-snapshot-20130401:1.18
	sid-snapshot-20130301:1.18
	sid-snapshot-20130201:1.18
	sid-snapshot-20130101:1.18
	sid-snapshot-20121201:1.18
	sid-snapshot-20121101:1.18
	sid-snapshot-20121001:1.18
	sid-snapshot-20120901:1.18
	sid-snapshot-20120801:1.18
	sid-snapshot-20120701:1.18
	sid-snapshot-20120601:1.18
	sid-snapshot-20120501:1.18
	sid-snapshot-20120401:1.18
	sid-snapshot-20120301:1.18
	sid-snapshot-20120201:1.18
	sid-snapshot-20120101:1.18
	sid-snapshot-20111201:1.18
	sid-snapshot-20111101:1.18
	sid-snapshot-20111001:1.18
	sid-snapshot-20110901:1.18
	sid-snapshot-20110801:1.18
	sid-snapshot-20110701:1.18
	sid-snapshot-20110601:1.18
	sid-snapshot-20110501:1.18
	sid-snapshot-20110401:1.18
	sid-snapshot-20110301:1.18
	sid-snapshot-20110201:1.18
	sid-snapshot-20110101:1.18
	sid-snapshot-20101201:1.18
	sid-snapshot-20101101:1.18
	sid-snapshot-20101001:1.18
	sid-snapshot-20100901:1.18
	sid-snapshot-20100801:1.18
	sid-snapshot-20100701:1.18
	sid-snapshot-20100601:1.18
	sid-snapshot-20100501:1.18
	sid-snapshot-20100401:1.18
	sid-snapshot-20100301:1.18
	sid-snapshot-20100201:1.18
	sid-snapshot-20100101:1.18
	sid-snapshot-20091201:1.18
	sid-snapshot-20091101:1.18
	sid-snapshot-20091001:1.18
	sid-snapshot-20090901:1.18
	sid-snapshot-20090801:1.18
	sid-snapshot-20090701:1.18
	sid-snapshot-20090601:1.18
	sid-snapshot-20090501:1.18
	sid-snapshot-20090401:1.18
	sid-snapshot-20090301:1.18
	sid-snapshot-20090201:1.18
	sid-snapshot-20090101:1.18
	sid-snapshot-20081201:1.18
	sid-snapshot-20081101:1.18
	sid-snapshot-20081001:1.18
	sid-snapshot-20080901:1.18
	sid-snapshot-20080801:1.18
	sid-snapshot-20080701:1.18
	sid-snapshot-20080601:1.18
	sid-snapshot-20080501:1.18
	sid-snapshot-20080403:1.18
	sid-snapshot-20080401:1.18
	sid-snapshot-20080301:1.18
	sid-snapshot-20080201:1.18
	sid-snapshot-20080101:1.18
	sid-snapshot-20071201:1.18
	sid-snapshot-20071101:1.18
	sid-snapshot-20071001:1.18
	sid-20020905-branchpoint:1.7
	sid-20020905-branch:1.7.0.2
	cygnus_cvs_20020108_pre:1.5;
locks; strict;
comment	@// @;


1.18
date	2006.09.27.16.31.33;	author brolley;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.26.21.05.38;	author brolley;	state Exp;
branches;
next	1.16;

1.16
date	2006.06.14.20.38.56;	author brolley;	state Exp;
branches;
next	1.15;

1.15
date	2006.05.11.16.04.38;	author brolley;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.01.21.07.02;	author fche;	state Exp;
branches;
next	1.13;

1.13
date	2005.08.23.21.08.35;	author brolley;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.19.19.46.00;	author brolley;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.14.14.59.52;	author brolley;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.08.06.46.49;	author bje;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.22.20.35.00;	author fche;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.11.22.28.29;	author fche;	state Exp;
branches;
next	1.7;

1.7
date	2002.08.27.17.53.23;	author fche;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.18.18.04.20;	author fche;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.01.14.40.23;	author fche;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.08.21.55.11;	author fche;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.03.06.02.46;	author mrg;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.04.23.53.31;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.07.19.30.56;	author fche;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Update commented out tracing statement in 'accumulate' to print the number of ticks.
@
text
@// gprof.cxx - A component for generating gprof profile data.  -*- C++ -*-

// Copyright (C) 1999-2002, 2005, 2006 Red Hat.
// This file is part of SID and is licensed under the GPL.
// See the file COPYING.SID for conditions for redistribution.

#include "config.h"

#include <sidcomp.h>
#include <sidso.h>
#include <sidtypes.h>
#include <sidcomputil.h>
#include <sidattrutil.h>
#include <sidpinutil.h>
#include <sidbusutil.h>
#include <sidmiscutil.h>
#include <sidpinattrutil.h>
#include <sidschedutil.h>
#include <sidwatchutil.h>
#include <sidcpuutil.h>

#include <vector>
#include <string>
#include <algorithm>
#include <functional>
#include <queue>
#include <deque>
#include <map>
#include <iostream>
#include <cassert>
#include <cstdlib>
#include <fstream>

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif


namespace profiling_components
{
  using sid::host_int_8;
  using sid::host_int_4;
  using sid::host_int_2;
  using sid::host_int_1;
  using sid::big_int_8;
  using sid::big_int_4;
  using sid::big_int_2;
  using sid::big_int_1;
  using sid::little_int_8;
  using sid::little_int_4;
  using sid::little_int_2;
  using sid::little_int_1;
  using sid::component;
  using sid::bus;
  using sid::pin;

  using sidutil::fixed_pin_map_component;
  using sidutil::fixed_attribute_map_component;
  using sidutil::no_bus_component;
  using sidutil::no_accessor_component;
  using sidutil::fixed_relation_map_component;
  using sidutil::configurable_component;
  using sidutil::input_pin;
  using sidutil::output_pin;
  using sidutil::callback_pin;
  using sidutil::make_attribute;
  using sidutil::parse_attribute;
  using sidutil::tokenize;
  using sidutil::std_error_string;
  using sidutil::endian;
  using sidutil::endian_unknown;
  using sidutil::endian_big;
  using sidutil::endian_little;

  using std::map;
  using std::vector;
  using std::string;
  using std::ofstream;
  using std::cerr;
  using std::endl;
  using std::pair;
  using std::make_pair;
  using std::ostream;
  using std::ios;
  using std::ofstream;


// ----------------------------------------------------------------------------

  class gprof_component: public virtual component,
			 protected virtual fixed_pin_map_component,
			 protected no_accessor_component,
			 protected virtual fixed_attribute_map_component,
			 protected virtual fixed_relation_map_component,
			 protected no_bus_component,
			 protected configurable_component
  {
    typedef map<host_int_8,host_int_4> hitcount_map_t;
    typedef map<pair<host_int_8,host_int_8>,host_int_4> cg_count_map_t;
    
    // statistics
    struct statistics
    {
      hitcount_map_t value_hitcount_map;
      cg_count_map_t cg_count_map;
      host_int_4 value_count;
      host_int_8 value_min, value_max;
      host_int_8 limit_min, limit_max;
      host_int_4 bucket_size;
      host_int_4 pc_size;
      string output_file;
      statistics () :
	value_count (0),
	value_min (~(host_int_8)0),
	value_max (0),
	limit_min (0),
	limit_max (~(host_int_8)0),
	bucket_size (1), // != 0
	pc_size (4), // default
	output_file ("")
        { }
      const statistics &operator= (const statistics &other)
        {
	  this->value_count = other.value_count;
	  this->value_min   = other.value_min;
	  this->value_max   = other.value_max;
	  this->limit_min   = other.limit_min;
	  this->limit_max   = other.limit_max;
	  this->bucket_size = other.bucket_size;
	  this->pc_size     = other.pc_size;
	  this->output_file = other.output_file;
	}
    };

    vector<statistics> stats;
    unsigned current_stats;

    component* target_component;

    endian output_file_format;

    callback_pin<gprof_component> accumulate_pin;

    input_pin pc_hi_pin;
    input_pin pc_pin;
    input_pin cg_caller_hi_pin;
    input_pin cg_caller_pin;
    input_pin cg_callee_hi_pin;
    callback_pin<gprof_component> cg_callee_pin;

    callback_pin<gprof_component> reset_pin;
    callback_pin<gprof_component> store_pin;

    component::status set_nothing (const string& str)
      {
	return component::bad_value;
      }

    string value_min_get()
      {
	return make_attribute (this->stats[current_stats].value_min);
      }

    string value_max_get()
      {
	return make_attribute (this->stats[current_stats].value_max);
      }

    string value_count_get()
      {
	return make_attribute (this->stats[current_stats].value_count);
      }

    string limit_min_get()
      {
	return make_attribute (this->stats[current_stats].limit_min);
      }

    component::status limit_min_set(const string& str)
      {
	host_int_8 new_limit_min;
	component::status s = parse_attribute (str, new_limit_min);
	// Reject malformed input
	if (s == component::ok)
	  this->stats[current_stats].limit_min = new_limit_min;
	return s;
      }

    string limit_max_get()
      {
	return make_attribute (this->stats[current_stats].limit_max);
      }

    component::status limit_max_set(const string& str)
      {
	host_int_8 new_limit_max;
	component::status s = parse_attribute (str, new_limit_max);
	// Reject malformed input
	if (s == component::ok)
	  this->stats[current_stats].limit_max = new_limit_max;
	return s;
      }

    string bucket_size_get()
      {
	return make_attribute (this->stats[current_stats].bucket_size);
      }

    component::status bucket_size_set(const string& str)
      {
	host_int_4 new_bucket_size;
	component::status s = parse_attribute (str, new_bucket_size);

	// Reject malformed input
	if (s != component::ok) return s;

	// Reject change if we already have samples 
	statistics &st = this->stats[current_stats];
	if ((st.value_count != 0) &&
	    (st.bucket_size != new_bucket_size))
	  {
	    cerr << "sw-profile-gprof: invalid time to change bucket size" << endl;
	    return component::bad_value;
	  }

	// Reject invalid size
	if (new_bucket_size == 0)
	  {
	    cerr << "sw-profile-gprof: invalid null bucket size." << endl;
	    return component::bad_value;
	  }

	st.bucket_size = new_bucket_size;
	return component::ok;
      }


    string pc_size_get()
      {
	return make_attribute (this->stats[current_stats].pc_size);
      }

    component::status pc_size_set(const string& str)
      {
	host_int_4 new_pc_size;
	component::status s = parse_attribute (str, new_pc_size);

	// Reject malformed input
	if (s != component::ok) return s;

	// Reject invalid sizes
	if (new_pc_size != 4 && new_pc_size != 8)
	  {
	    cerr << "sw-profile-gprof: invalid pc size." << endl;
	    return component::bad_value;
	  }

	this->stats[current_stats].pc_size = new_pc_size;
	return component::ok;
      }


    string output_file_get()
      {
	return this->stats[current_stats].output_file;
      }

    component::status output_file_set(const string& str)
      {
	this->stats[current_stats].output_file = str;
	return component::ok;
      }

    void accumulate (host_int_4 ticks)
      {
	if (! this->target_component) return;

	host_int_8 value = (((host_int_8)this->pc_hi_pin.sense ()) << 32) | (this->pc_pin.sense () & 0xffffffff);

	// std::cout << "sampled " << ticks << " ticks at 0x" << std::hex << value << std::dec << " for " << stats[current_stats].output_file << endl;
	// Reject out-of-bounds samples
	statistics &st = this->stats[current_stats];
	if (value < st.limit_min || value > st.limit_max) return;

	st.value_count ++;

	assert (st.bucket_size != 0);
	host_int_8 quantized = (value / st.bucket_size) * st.bucket_size;

	if (quantized < st.value_min) st.value_min = quantized;
	if (quantized > st.value_max) st.value_max = quantized;
	st.value_hitcount_map [quantized] += ticks;
      }

    void accumulate_call (host_int_4 selfpc_low)
      {
	host_int_8 selfpc = (((host_int_8)this->cg_callee_hi_pin.sense ()) << 32) | (selfpc_low & 0xffffffff);
	host_int_8 callerpc = (((host_int_8)this->cg_caller_hi_pin.sense ()) << 32) | (this->cg_caller_pin.sense () & 0xffffffff);

	// Reject out-of-bounds samples
	statistics &st = this->stats[current_stats];
	if (selfpc < st.limit_min || selfpc > st.limit_max) return;
	if (callerpc < st.limit_min || callerpc > st.limit_max) return;

	st.value_count ++;

	assert (st.bucket_size != 0);
	host_int_8 c_quantized = (callerpc / st.bucket_size) * st.bucket_size;
	host_int_8 s_quantized = (selfpc / st.bucket_size) * st.bucket_size;

	if (c_quantized < st.value_min) st.value_min = c_quantized;
	if (s_quantized < st.value_min) st.value_min = s_quantized;
	if (c_quantized > st.value_max) st.value_max = c_quantized;
	if (s_quantized > st.value_max) st.value_max = s_quantized;

	st.cg_count_map [make_pair(c_quantized,s_quantized)] ++;
      }


    void reset (host_int_4)
      {
	statistics new_stats;
	if (! stats.empty ())
	  {
	    new_stats.bucket_size = stats[0].bucket_size;
	    new_stats.output_file = stats[0].output_file;
	  }
	stats.clear ();
	stats.push_back (new_stats);
	current_stats = 0;
      }


    // Write given host_int_X in target byte order
    template <typename IntType>
    void put_bytes (ostream& o, IntType v, unsigned count)
      {

	switch (this->output_file_format)
	  {
	  case endian_little:
	    {
	      sid::any_int<IntType, false> lv = v;
	      for (unsigned i=0; i<count; i++)
		o.put (lv.read_byte (i));
	    }
	    break;

	  case endian_big:
	    {
	      sid::any_int<IntType, true> bv = v;
	      for (unsigned i=0; i<count; i++)
		o.put (bv.read_byte (i));
	    }
	    break;

	  default:
	    assert (0);
	  }
      }

    void put_bytes (ostream& o, const char* v, unsigned count)
      {
	for (unsigned i=0; i<count; i++)
	  {
	    o.put (*v);
	    if (*v) v++;  // advance unless we've hit NULL terminator
	  }
      }


    void store (host_int_4)
      {
	// Fetch endianness from target CPU
	if (this->output_file_format == endian_unknown)
	  {
	    string value = this->target_component->attribute_value ("endian");
	    component::status s = parse_attribute (value, this->output_file_format);
	    if (s != component::ok)
	      this->output_file_format = endian_unknown;
	  }
	if (this->output_file_format == endian_unknown)
	  {
	    cerr << "sw-profile-gprof: Unknown endianness for output file." << endl;
	    return;
	  }

	for (vector<statistics>::iterator it = stats.begin ();
	     it != stats.end ();
	     ++it)
	  store_stats (*it);
      }

    void store_stats (statistics &stats)
      {
	if (stats.output_file.empty ())
	  stats.output_file = "gmon.out";

	ofstream of (stats.output_file.c_str (),
                     ios::out | ios::trunc | ios::binary);
	if (! of.good())
	  {
	    cerr << "sw-profile-gprof: Error opening "
		 << stats.output_file << ":" << std_error_string();
	    return;
	  }

	// write gmon header
	put_bytes (of, "gmon", 4);             // gmon_hdr.cookie
	// version number (1) in target-endian
	put_bytes (of, host_int_4(1), 4);      // gmon_hdr.version = GMON_VERSION
	// 12 bytes of padding
	put_bytes (of, host_int_4(0), 4);      // gmon_hdr.spare
	put_bytes (of, host_int_4(0), 4);      // gmon_hdr.spare
	put_bytes (of, host_int_4(0), 4);      // gmon_hdr.spare

	if (! stats.value_hitcount_map.empty())
	  {
	    // We may have to loop and dump out several adjacent histogram
	    // tables, because histogram bucket count overflow.  The
	    // bucket counts are limited to 16 bits, but a 32-bit counter
	    // in gprof may be accumulated my multiple overlapping
	    // histogram tables.  We copy the histogram table here, since
	    // its counters will be decremented by up to 2**16-1 per
	    // iteration.
	    hitcount_map_t value_hitcount_map_copy = stats.value_hitcount_map;
	    while (true)
	      {
		// write a new histogram record
		// GMON_Record_Tag
		put_bytes (of, host_int_1(0), 1);      // GMON_TAG_TIME_HIST
		// gmon_hist_hdr
		if (stats.pc_size == 4) // 4 byte pc
		  {
		    put_bytes (of, (host_int_4)stats.value_min, stats.pc_size);    // gmon_hist_hdr.low_pc
		    host_int_4 uprounded_value_max = stats.value_max + stats.bucket_size;
		    put_bytes (of, uprounded_value_max, stats.pc_size); // gmon_hist_hdr.high_pc
		  }
		else // 8 byte pc
		  {
		    put_bytes (of, stats.value_min, stats.pc_size);    // gmon_hist_hdr.low_pc
		    host_int_8 uprounded_value_max = stats.value_max + stats.bucket_size;
		    put_bytes (of, uprounded_value_max, stats.pc_size); // gmon_hist_hdr.high_pc
		  }
		assert (stats.bucket_size != 0);
		host_int_4 num_buckets = 1 + (stats.value_max - stats.value_min) / stats.bucket_size;
		put_bytes (of, num_buckets, 4);        // gmon_hist_hdr.hist_size
		put_bytes (of, host_int_4(1), 4);      // gmon_hist_hdr.prof_rate
		put_bytes (of, "tick", 15);            // gmon_hist_hdr.dimen
		put_bytes (of, "t", 1);                // gmon_hist_hdr.dimen_abbrev
		
		// Dump out histogram counts
		bool overflow = false;
		for (host_int_8 bucket = stats.value_min;
		     bucket <= stats.value_max;
		     bucket += stats.bucket_size)
		  {
		    const host_int_4 max_count = 65535;
		    host_int_4 count = 0;
		    
		    // Check if this bucket exists by find() instead of a
		    // blind []-lookup, because the latter would allocate
		    // fresh & useless 0-count buckets for all non-touched
		    // values.
		    hitcount_map_t::iterator b = value_hitcount_map_copy.find (bucket);
		    if (b != value_hitcount_map_copy.end())
		      count = b->second;
		    
		    if (count > max_count) // overflow!
		      {
			put_bytes (of, host_int_2(max_count), 2);
			b->second -= max_count;
			overflow = true;
		      }
		    else
		      {
			put_bytes (of, host_int_2(count), 2);
			b->second = 0; // in case we iterate due to overflow
		      }
		  }
		
		if (!overflow)
		  break;
	      }
	  } // (emitting hash table?)

	// Now spit out the call graph stastics.
	cg_count_map_t::const_iterator ci = stats.cg_count_map.begin();
	while (ci != stats.cg_count_map.end())
	  {
	    // write a new histogram record
	    // GMON_Record_Tag
	    put_bytes (of, host_int_1(1), 1);      // GMON_TAG_CG_ARC

	    // gmon_hist_hdr
	    if (stats.pc_size == 4) // 4 byte pc
	      {
		put_bytes (of, (host_int_4)(ci->first.first), 4);    // cg caller
		put_bytes (of, (host_int_4)(ci->first.second), 4);    // cg self
	      }
	    else // 8 byte pc
	      {
		put_bytes (of, ci->first.first, 8);    // cg caller
		put_bytes (of, ci->first.second, 8);    // cg self
	      }
	    put_bytes (of, ci->second, 4);    // cg count
	    
	    ci ++;
	  }

	of.close ();
      }

    void configure (const string &config)
      {
	// Call up to the base classes first
	configurable_component::configure (config);

	// Now handle relevent configuration for us.
	if (config.size () < 6)
	  return;
	if (config.substr (0, 6) == "gprof=")
	  {
	    // If a filename has been specified, then see if we need to switch files.
	    if (config.size () > 6)
	      {
		vector<string> parts = tokenize (config.substr (6), ",");

		// Special case: Default stats have not yet been assigned an
		// output file and no data has been collected yet. Simply
		// assign this file name.
		if (current_stats == 0 && stats[0].value_count == 0
		    && stats[0].output_file.empty ())
		  stats[0].output_file = parts[0];
		else
		  {
		    unsigned size = stats.size ();
		    unsigned i;
		    for (i = 0; i < size; ++i)
		      if (stats[i].output_file == parts[0])
			break;
		    // This is a new output file, so create new stats for it.
		    if (i >= size)
		      {
			statistics new_stats;
			new_stats.bucket_size = stats[0].bucket_size;
			new_stats.output_file = parts[0];
			stats.push_back (new_stats);
		      }
		    current_stats = i;
		  }
	      }
	    return;
	  }
      }

  public:
    gprof_component ():
      target_component (0),
      output_file_format (endian_unknown),
      accumulate_pin (this, & gprof_component::accumulate),
      cg_callee_pin (this, & gprof_component::accumulate_call),
      reset_pin (this, & gprof_component::reset),
      store_pin (this, & gprof_component::store),
      current_stats (0)
      {
	// Reset before adding attributes etc.
	reset (1);

	add_pin ("sample", & this->accumulate_pin);
	add_attribute ("sample", & this->accumulate_pin, "pin");
	add_pin ("pc", & this->pc_pin);
	add_attribute ("pc", & this->pc_pin, "pin");
	add_pin ("pc-hi", & this->pc_hi_pin);
	add_attribute ("pc-hi", & this->pc_hi_pin, "pin");
	add_pin ("cg-caller", & this->cg_caller_pin);
	add_attribute ("cg-caller", & this->cg_caller_pin, "pin");
	add_pin ("cg-caller-hi", & this->cg_caller_hi_pin);
	add_attribute ("cg-caller-hi", & this->cg_caller_hi_pin, "pin");
	add_pin ("cg-callee", & this->cg_callee_pin);
	add_attribute ("cg-callee", & this->cg_callee_pin, "pin");
	add_pin ("cg-callee-hi", & this->cg_callee_hi_pin);
	add_attribute ("cg-callee-hi", & this->cg_callee_hi_pin, "pin");
	add_pin ("reset", & this->reset_pin);
	add_attribute ("reset", & this->reset_pin, "pin");
	add_pin ("store", & this->store_pin);
	add_attribute ("store", & this->store_pin, "pin");
	add_attribute_virtual ("pc-size", this,
			       & gprof_component::pc_size_get,
			       & gprof_component::pc_size_set,
			       "setting");
	add_attribute_virtual ("bucket-size", this,
			       & gprof_component::bucket_size_get,
			       & gprof_component::bucket_size_set,
			       "setting");
	add_attribute_virtual ("value-min", this,
			       & gprof_component::value_min_get,
			       & gprof_component::set_nothing, // ro
			       "setting");
	add_attribute_virtual ("value-max", this,
			       & gprof_component::value_max_get,
			       & gprof_component::set_nothing, // ro
			       "setting");
	add_attribute_virtual ("value-count", this,
			       & gprof_component::value_count_get,
			       & gprof_component::set_nothing, // ro
			       "setting");
	add_attribute_virtual ("limit-min", this,
			       & gprof_component::limit_min_get,
			       & gprof_component::limit_min_set,
			       "setting");
	add_attribute_virtual ("limit-max", this,
			       & gprof_component::limit_max_get,
			       & gprof_component::limit_max_set,
			       "setting");
	add_attribute_virtual ("output-file", this,
			       & gprof_component::output_file_get,
			       & gprof_component::output_file_set,
			       "setting");
	add_attribute ("output-file-endianness", & this->output_file_format, "setting");
	add_uni_relation ("target-component", & this->target_component);

	pc_hi_pin.driven (0);
	cg_caller_hi_pin.driven (0);
	cg_callee_hi_pin.driven (0);
      }
    ~gprof_component () throw () { }
  };



// ----------------------------------------------------------------------------

  static
  vector<string>
  list_types()
{
  vector<string> types;
  types.push_back("sw-profile-gprof");
  return types;
}
  
  
  static
  component*
  create(const string& typeName)
{
  if (typeName == "sw-profile-gprof")
    return new gprof_component ();

  return 0;
}


  static
  void
  do_delete(component* c)
{
  delete dynamic_cast<gprof_component*>(c);
}

  
} // end namespace



// static object in root namespace
DLLEXPORT extern const sid::component_library prof_component_library;

const sid::component_library prof_component_library =
{
  sid::COMPONENT_LIBRARY_MAGIC,
  & profiling_components::list_types, 
  & profiling_components::create,
  & profiling_components::do_delete
};

@


1.17
log
@2006-06-26  Dave Brolley  <brolley@@redhat.com>

        * gprof.cxx (target_attribute): Removed from gprof_component.
        (pc_pin,pc_hi_pin): Added to gprof_component.
        (bucket_size_set): Use local reference for this->stats[current_stats].
        (accumulate_call): Likewise.
        (accumulate): Likewise. Use pc_pin and pc_hi_pin instead of
        target_attribute to get the pc.
        (gprof_component): Add pc and pc-hi pins. Don't add value-attribute
        attribute. Initialize the driven value of pc_hi_pin with 0.
@
text
@d280 1
a280 1
	//	std::cout << "sampled at 0x" << std::hex << value << std::dec << " for " << stats[current_stats].output_file << endl;
@


1.16
log
@2006-06-14  Dave Brolley  <brolley@@redhat.com>

        * gprof.cxx (gprof_component): Remove sim_sched and sim_sched_event.
        Remove the sim-sched-event attribute and the sim-sched relation.
        (accumulate): Increment the bucket count by the value driven on the
        pin.
        (configure): No longer a subscription to the target scheduler to
        maintain.
@
text
@a137 1
    string target_attribute;
d144 2
d218 3
a220 2
	if ((this->stats[current_stats].value_count != 0) &&
	    (this->stats[current_stats].bucket_size != new_bucket_size))
d233 1
a233 1
	this->stats[current_stats].bucket_size = new_bucket_size;
d278 1
a278 12
	string value_str = this->target_component->attribute_value (this->target_attribute);
	host_int_8 value;
	component::status s = parse_attribute (value_str, value);
	if (s != component::ok) return;

	value_str = this->target_component->attribute_value (this->target_attribute + "-hi");
	host_int_8 value_hi;
	s = parse_attribute (value_str, value_hi);
	if (s != component::ok)
	  value_hi = 0;

	value = (value_hi << 32) | (value & 0xffffffff);
d282 2
a283 1
	if (value < this->stats[current_stats].limit_min || value > this->stats[current_stats].limit_max) return;
d285 1
a285 1
	stats[current_stats].value_count ++;
d287 2
a288 2
	assert (this->stats[current_stats].bucket_size != 0);
	host_int_8 quantized = (value / this->stats[current_stats].bucket_size) * this->stats[current_stats].bucket_size;
d290 3
a292 3
	if (quantized < this->stats[current_stats].value_min) this->stats[current_stats].value_min = quantized;
	if (quantized > this->stats[current_stats].value_max) this->stats[current_stats].value_max = quantized;
	this->stats[current_stats].value_hitcount_map [quantized] += ticks;
d301 14
a314 13
	if (selfpc < this->stats[current_stats].limit_min || selfpc > this->stats[current_stats].limit_max) return;
	if (callerpc < this->stats[current_stats].limit_min || callerpc > this->stats[current_stats].limit_max) return;

	stats[current_stats].value_count ++;

	assert (this->stats[current_stats].bucket_size != 0);
	host_int_8 c_quantized = (callerpc / this->stats[current_stats].bucket_size) * this->stats[current_stats].bucket_size;
	host_int_8 s_quantized = (selfpc / this->stats[current_stats].bucket_size) * this->stats[current_stats].bucket_size;

	if (c_quantized < this->stats[current_stats].value_min) this->stats[current_stats].value_min = c_quantized;
	if (s_quantized < this->stats[current_stats].value_min) this->stats[current_stats].value_min = s_quantized;
	if (c_quantized > this->stats[current_stats].value_max) this->stats[current_stats].value_max = c_quantized;
	if (s_quantized > this->stats[current_stats].value_max) this->stats[current_stats].value_max = s_quantized;
d316 1
a316 1
	this->stats[current_stats].cg_count_map [make_pair(c_quantized,s_quantized)] ++;
a558 1
      target_attribute ("pc"),
d572 4
a615 1
	add_attribute ("value-attribute", & this->target_attribute, "setting");
d623 1
@


1.15
log
@2006-05-11  Dave Brolley  <brolley@@redhat.com>

        * gprof.cxx (hitcount_map_t): PC now host_int_8.
        (cg_count_map_t): Likewise.
        (statistics): value_min,value_max,limit_min,limit_max likewise.
        New member, pc_size.
        (statistics::operator=): Copy pc_size.
        (cg_caller_hi_pin): New pin.
        (cg_callee_hi_pin): New pin.
        (limit_min_set): Handle 64 bits.
        (limit_max_set): Handle 64 bits.
        (pc_size_get): New method.
        (pc_size_set): New method.
        (accumulate): Use target_attribute + "-hi" to obtain 64 bit pc. Handle
        64 bits throughout.
        (accumulate_call): Use {caller,callee}_hi pin to obtain 64 bit pc. Handle
        64 bits throughout.
        (store_stats): Handle 32 or 64 bit pc.
        (gprof_component): Add cg-caller_hi and cg-callee-hi pins. Add pc-size
        attribute. Initialize value on cg-caller-hi and cg-callee-hi to zero.
        * sw-profile-gprof.xml: Document cg-caller-hi, cg-callee-hi,
        bucket-size, pc-size.
        * sw-profile-gprof.txt: Regenerated.
@
text
@a137 3
    component *sim_sched;
    string sim_sched_event;

d272 1
a272 1
    void accumulate (host_int_4)
d300 1
a300 1
	this->stats[current_stats].value_hitcount_map [quantized] ++;
a558 19

		// If cycles was specified, then we need to be subscribed to the
		// target scheduler
		if (! sim_sched)
		  return;
		if (parts.size () == 2)
		  {
		    host_int_4 cycles;
		    component::status s = parse_attribute (parts[1], cycles);
		    if (s == component::ok)
		      {
			sim_sched->connect_pin (sim_sched_event + "-event", & accumulate_pin);
			sim_sched->set_attribute_value (sim_sched_event + "-time", make_attribute (cycles));
			// Take a sample now to make up for the one which just got cancelled when
			// N-time was set.
			accumulate (1);
			return;
		      }
		  }
a559 4
	    // No gprof config or cycles was not specified. We will not be triggered by the
	    // target scheduler.
	    if (sim_sched)
	      sim_sched->disconnect_pin (sim_sched_event + "-event", & accumulate_pin);
a565 2
      sim_sched (0),
      sim_sched_event ("0"),
a579 1
	add_attribute ("sim-sched-event", & this->sim_sched_event, "setting");
a626 1
	add_uni_relation ("sim-sched", & this->sim_sched);
@


1.14
log
@* DLLEXPORT decoration tweak, from Rex Sung-Tien Cho <song10@@andestech.com>
@
text
@d3 1
a3 1
// Copyright (C) 1999-2002, 2005 Red Hat.
d98 2
a99 2
    typedef map<host_int_4,host_int_4> hitcount_map_t;
    typedef map<pair<host_int_4,host_int_4>,host_int_4> cg_count_map_t;
d107 2
a108 2
      host_int_4 value_min, value_max;
      host_int_4 limit_min, limit_max;
d110 1
d114 1
a114 1
	value_min (~0),
d117 1
a117 1
	limit_max (~0),
d119 1
d130 1
d148 1
d150 1
d183 1
a183 1
	host_int_4 new_limit_min;
d198 1
a198 1
	host_int_4 new_limit_max;
d239 25
d280 1
a280 1
	host_int_4 value;
d283 9
d299 1
a299 1
	host_int_4 quantized = (value / this->stats[current_stats].bucket_size) * this->stats[current_stats].bucket_size;
d306 1
a306 1
    void accumulate_call (host_int_4 selfpc)
d308 2
a309 1
	host_int_4 callerpc = this->cg_caller_pin.sense();
d318 2
a319 2
	host_int_4 c_quantized = (callerpc / this->stats[current_stats].bucket_size) * this->stats[current_stats].bucket_size;
	host_int_4 s_quantized = (selfpc / this->stats[current_stats].bucket_size) * this->stats[current_stats].bucket_size;
d443 12
a454 3
		put_bytes (of, stats.value_min, 4);    // gmon_hist_hdr.low_pc
		host_int_4 uprounded_value_max = stats.value_max + stats.bucket_size;
		put_bytes (of, uprounded_value_max, 4); // gmon_hist_hdr.high_pc
d464 1
a464 1
		for (host_int_4 bucket = stats.value_min;
d506 10
a515 2
	    put_bytes (of, ci->first.first, 4);    // cg caller
	    put_bytes (of, ci->first.second, 4);    // cg self
d611 2
d615 2
d621 4
d657 3
@


1.13
log
@2005-08-23  Dave Brolley  <brolley@@redhat.com>

        * gprof.cxx (configure): Don't reset the N-regular attribute of the
        scheduler. Call accumulate when configuring for cycles=N.
@
text
@d634 1
a634 1
extern const sid::component_library prof_component_library;
d636 1
a636 1
const sid::component_library prof_component_library DLLEXPORT = 
@


1.12
log
@2005-08-19  Dave Brolley  <brolley@@redhat.com>

        * Contribute the following changes:

        2005-07-13  Dave Brolley  <brolley@@redhat.com>

        * gprof.cxx (gprof_component): Inherit virtually from
        fixed_attribute_map_component.

        2005-05-29  Dave Brolley  <brolley@@redhat.com>

        * gprof.cxx: Keep a vector of statistics to allow switching from
        one output file to another dynamically.
        (sid::pin,sidutil::configurable_component)
        (sidutil::output_pin,sidutil::tokenize): Add using clauses.
        (profiling_components): Inherit virtually from fixed_pin_map_component
        and fixed_relation_map_component. Inherit from configurable_component.
        (statistics): New struct type.
        (stats,current_stats): New members of gprof_component.
        (set_nothing,value_min_get,value_max_get,value_count_get,limit_min_get)
        (limit_min_set,limit_max_get,limit_max_set,output_file_get)
        (output_file_set): New methods of gprof_component.
        (reset): Initialize stats vector.
        (store): Call store stats for each element of the stats vector.
        (configure): New virtual override in gprof_component.
        (gprof_component): Call reset. Add sim-sched-event attribute. Add
        sim-sched relation.
@
text
@a516 1
			sim_sched->set_attribute_value (sim_sched_event + "-regular", "true");
d518 3
d528 1
a528 4
	      {
		sim_sched->disconnect_pin (sim_sched_event + "-event", & accumulate_pin);
		sim_sched->set_attribute_value (sim_sched_event + "-regular", "false");
	      }
@


1.11
log
@2003-05-13  Dave Brolley  <brolley@@redhat.com>

        * gprof.cxx (profiling_components): Set bucket count to zero when it
        is empty.
@
text
@d3 1
a3 1
// Copyright (C) 1999-2002 Red Hat.
d55 1
d62 1
d64 1
d68 1
d91 1
a91 1
			 protected fixed_pin_map_component,
d93 4
a96 3
			 protected fixed_attribute_map_component,
			 protected fixed_relation_map_component,
			 protected no_bus_component
d102 35
a136 6
    hitcount_map_t value_hitcount_map;
    cg_count_map_t cg_count_map;
    host_int_4 value_count;
    host_int_4 value_min, value_max;
    host_int_4 limit_min, limit_max;
    host_int_4 bucket_size;
a140 1
    string output_file;
d151 50
d203 1
a203 1
	return make_attribute (this->bucket_size);
d215 2
a216 2
	if ((this->value_count != 0) &&
	    (this->bucket_size != new_bucket_size))
d229 1
a229 1
	this->bucket_size = new_bucket_size;
d234 11
d253 1
a253 1

d255 1
a255 1
	if (value < this->limit_min || value > this->limit_max) return;
d257 1
a257 1
	value_count ++;
d259 2
a260 2
	assert (this->bucket_size != 0);
	host_int_4 quantized = (value / this->bucket_size) * this->bucket_size;
d262 3
a264 3
	if (quantized < this->value_min) this->value_min = quantized;
	if (quantized > this->value_max) this->value_max = quantized;
	this->value_hitcount_map [quantized] ++;
d272 2
a273 2
	if (selfpc < this->limit_min || selfpc > this->limit_max) return;
	if (callerpc < this->limit_min || callerpc > this->limit_max) return;
d275 1
a275 1
	value_count ++;
d277 3
a279 3
	assert (this->bucket_size != 0);
	host_int_4 c_quantized = (callerpc / this->bucket_size) * this->bucket_size;
	host_int_4 s_quantized = (selfpc / this->bucket_size) * this->bucket_size;
d281 4
a284 4
	if (c_quantized < this->value_min) this->value_min = c_quantized;
	if (s_quantized < this->value_min) this->value_min = s_quantized;
	if (c_quantized > this->value_max) this->value_max = c_quantized;
	if (s_quantized > this->value_max) this->value_max = s_quantized;
d286 1
a286 1
	this->cg_count_map [make_pair(c_quantized,s_quantized)] ++;
d292 9
a300 5
	this->cg_count_map.clear ();
	this->value_hitcount_map.clear ();
	this->value_min = ~0;
	this->value_max = 0;
	value_count = 0;
d358 12
a369 1
	ofstream of (this->output_file.c_str (),
d374 1
a374 1
		 << this->output_file << ":" << std_error_string();
d387 1
a387 1
	if (! this->value_hitcount_map.empty())
d396 1
a396 1
	    hitcount_map_t value_hitcount_map_copy = this->value_hitcount_map;
d403 2
a404 2
		put_bytes (of, this->value_min, 4);    // gmon_hist_hdr.low_pc
		host_int_4 uprounded_value_max = this->value_max + this->bucket_size;
d406 2
a407 2
		assert (this->bucket_size != 0);
		host_int_4 num_buckets = 1 + (this->value_max - this->value_min) / this->bucket_size;
d415 3
a417 3
		for (host_int_4 bucket = this->value_min;
		     bucket <= this->value_max;
		     bucket += this->bucket_size)
d449 2
a450 2
	cg_count_map_t::const_iterator ci = this->cg_count_map.begin();
	while (ci != this->cg_count_map.end())
d467 66
d536 2
a537 6
      value_count (0),
      value_min (~0),
      value_max (0),
      limit_min (0),
      limit_max (~0),
      bucket_size (1), // != 0
a539 1
      output_file ("gmon.out"),
d544 2
a545 1
      store_pin (this, & gprof_component::store)
d547 3
d552 1
d565 20
a584 5
	add_attribute_ro ("value-min", & this->value_min, "register");
	add_attribute_ro ("value-max", & this->value_max, "register");
	add_attribute_ro ("value-count", & this->value_count, "register");
	add_attribute ("limit-min", & this->limit_min, "setting");
	add_attribute ("limit-max", & this->limit_max, "setting");
d586 4
a589 1
	add_attribute ("output-file", & this->output_file, "setting");
d592 1
@


1.10
log
@* Remove duplicated `using' keywords (merge botch?)
@
text
@d330 1
@


1.9
log
@* gcc 3.2 compatibility fixes

[e.g. include/ChangeLog]
2002-11-22  Frank Ch. Eigler  <fche@@redhat.com>

	* sidattrutil.h: Give up on hash tables - too many incompatible
	libstdc++'s out there.
	* configure.in: Don't bother looking for hash stuff.
	* configure, sidconfutil.in: Regenerated.
	* sidmiscutil.h: Add some "typename" qualifiers.
	* sidcpuutil.h (cpu_trace_stream): Trade publicness for friendliness
	regarding cout_p.

[e.g., component/parport/ChangeLog]
2002-11-22  Frank Ch. Eigler  <fche@@redhat.com>

	* ps2.cxx (parport_inputpin): Fix formal arg list.

[e.g., component/interrupt/ChangeLog]
2002-11-22  Frank Ch. Eigler  <fche@@redhat.com>

	* components.cxx (compInterruptDelete): Avoid dynamic_cast on
	deleted pointer.
@
text
@a81 2
  using std::ios;
  using std::ofstream;
@


1.8
log
@* better c++ standard compliance

[e.g.]
[include/ChangeLog]
2002-11-11  Frank Ch. Eigler  <fche@@redhat.com>

        * sidcpuutil.h (cpu_trace_stream): Add some std:: qualifiers.

[component/glue/ChangeLog]
2002-11-11  Frank Ch. Eigler  <fche@@redhat.com>

        * glue.cxx (bus_prober): Dtor throw() fixes.
@
text
@a71 1
  using std::hash_map;
a94 12
#ifdef HAVE_HASHING
    struct hash_cg_pair
    {
      size_t operator () (const pair<host_int_4,host_int_4>& s) const
      {
	return (s.first << 1) ^ s.second;
      }
    };

    typedef hash_map<host_int_4,host_int_4> hitcount_map_t;
    typedef hash_map<pair<host_int_4,host_int_4>,host_int_4,hash_cg_pair> cg_count_map_t;
#else
a96 1
#endif
@


1.7
log
@2002-08-27  Frank Ch. Eigler  <fche@@redhat.com>

	From Anthony Green <green@@redhat.com>:
	* gprof.cxx (store): Specify binary mode on output file.
@
text
@d81 4
@


1.6
log
@2002-02-18  Frank Ch. Eigler  <fche@@redhat.com>

	* gprof.cxx (store): Emit high_pc for histogram as gprof expects it
	(exclusive upper limit), not actual (maximum value).
@
text
@d272 2
a273 1
	ofstream of (this->output_file.c_str ());
@


1.5
log
@2001-12-01  Frank Ch. Eigler  <fche@@redhat.com>

	* gprof.cxx (make_pair): Import from std::.
@
text
@d3 1
a3 1
// Copyright (C) 1999-2001 Red Hat.
d306 2
a307 1
		put_bytes (of, this->value_max, 4);    // gmon_hist_hdr.high_pc
a310 1
		// XXX: actual prof_rate not available here ...
@


1.4
log
@* call graph profiling support

[sid/bsp]
2001-11-08  Frank Ch. Eigler  <fche@@redhat.com>

	* configrun-sid.in (gprof): Connect call-graph pins.

[sid/include]
2001-11-08  Frank Ch. Eigler  <fche@@redhat.com>

	* sidcpuutil.h (basic_cpu): Add cg caller/callee pins, trace_stream
	fields.
	(basic_cpu ctor): Initialize them.
	(cg_profile): New function.

[sid/component/cgen-cpu]
2001-11-08  Frank Ch. Eigler  <fche@@redhat.com>

	* cgen-cpu.h (cgen_bi_endian_cpu): Remove trace_stream field: it's
	in basic_cpu now.
	* compCGEN.cxx: Corresponding change.

[sid/component/profiling]
2001-11-08  Frank Ch. Eigler  <fche@@redhat.com>

	* gprof.cxx (gprof_component): Add cg caller/callee pins, cg_count_map
	field.
	(accumulate_call): New function.
	(reset): Clear cg map.
	(store): Emit call graph info.  Emit histogram iff nonempty.
	* sw-profile-gprof.xml: Document call graph functionality.
	* sw-profile-gprof.txt: Regenerated.
@
text
@d79 1
@


1.3
log
@* make it compile with GCC 3.0:
        - missing throw() specifiers in bus & component dtors
	- `std::' vs `::' namespace issues
@
text
@d3 1
a3 1
// Copyright (C) 1999, 2000 Red Hat.
d61 1
d78 1
d81 1
d92 8
d101 1
d104 1
d109 1
d122 4
a128 1

d184 23
d209 1
d288 1
a288 9
	// We may have to loop and dump out several adjacent histogram
	// tables, because histogram bucket count overflow.  The
	// bucket counts are limited to 16 bits, but a 32-bit counter
	// in gprof may be accumulated my multiple overlapping
	// histogram tables.  We copy the histogram table here, since
	// its counters will be decremented by up to 2**16-1 per
	// iteration.
	hitcount_map_t value_hitcount_map_copy = this->value_hitcount_map;
	while (true)
d290 9
a298 19
	    // write a new histogram record
	    // GMON_Record_Tag
	    put_bytes (of, host_int_1(0), 1);      // GMON_TAG_TIME_HIST
	    // gmon_hist_hdr
	    put_bytes (of, this->value_min, 4);    // gmon_hist_hdr.low_pc
	    put_bytes (of, this->value_max, 4);    // gmon_hist_hdr.high_pc
	    assert (this->bucket_size != 0);
	    host_int_4 num_buckets = 1 + (this->value_max - this->value_min) / this->bucket_size;
	    put_bytes (of, num_buckets, 4);        // gmon_hist_hdr.hist_size
	    // XXX: actual prof_rate not available here ...
	    put_bytes (of, host_int_4(1), 4);      // gmon_hist_hdr.prof_rate
	    put_bytes (of, "tick", 15);            // gmon_hist_hdr.dimen
	    put_bytes (of, "t", 1);                // gmon_hist_hdr.dimen_abbrev

	    // Dump out histogram counts
	    bool overflow = false;
	    for (host_int_4 bucket = this->value_min;
		 bucket <= this->value_max;
		 bucket += this->bucket_size)
d300 19
a318 12
		const host_int_4 max_count = 65535;
		host_int_4 count = 0;

		// Check if this bucket exists by find() instead of a
		// blind []-lookup, because the latter would allocate
		// fresh & useless 0-count buckets for all non-touched
		// values.
		hitcount_map_t::iterator b = value_hitcount_map_copy.find (bucket);
		if (b != value_hitcount_map_copy.end())
		  count = b->second;

		if (count > max_count) // overflow!
d320 21
a340 7
		    put_bytes (of, host_int_2(max_count), 2);
		    b->second -= max_count;
		    overflow = true;
		  }
		else
		  {
		    put_bytes (of, host_int_2(count), 2);
d342 3
d346 1
d348 14
a361 2
	    if (!overflow)
	      break;
d381 1
d387 4
@


1.2
log
@* function++

2001-04-04  Frank Ch. Eigler  <fche@@redhat.com>

        * gprof.cxx (limit_min, limit_max): New variables/attributes.
        (accumulate): Respect them.
        * sw-profile-gprof.txt: Document them.
@
text
@d344 1
@


1.1
log
@* public snapshot of sid simulator
@
text
@d98 1
d154 3
d313 2
d337 2
@

