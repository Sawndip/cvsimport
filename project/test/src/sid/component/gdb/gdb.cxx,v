head	1.18;
access;
symbols
	sid-snapshot-20180601:1.18
	sid-snapshot-20180501:1.18
	sid-snapshot-20180401:1.18
	sid-snapshot-20180301:1.18
	sid-snapshot-20180201:1.18
	sid-snapshot-20180101:1.18
	sid-snapshot-20171201:1.18
	sid-snapshot-20171101:1.18
	sid-snapshot-20171001:1.18
	sid-snapshot-20170901:1.18
	sid-snapshot-20170801:1.18
	sid-snapshot-20170701:1.18
	sid-snapshot-20170601:1.18
	sid-snapshot-20170501:1.18
	sid-snapshot-20170401:1.18
	sid-snapshot-20170301:1.18
	sid-snapshot-20170201:1.18
	sid-snapshot-20170101:1.18
	sid-snapshot-20161201:1.18
	sid-snapshot-20161101:1.18
	sid-snapshot-20160901:1.18
	sid-snapshot-20160801:1.18
	sid-snapshot-20160701:1.18
	sid-snapshot-20160601:1.18
	sid-snapshot-20160501:1.18
	sid-snapshot-20160401:1.18
	sid-snapshot-20160301:1.18
	sid-snapshot-20160201:1.18
	sid-snapshot-20160101:1.18
	sid-snapshot-20151201:1.18
	sid-snapshot-20151101:1.18
	sid-snapshot-20151001:1.18
	sid-snapshot-20150901:1.18
	sid-snapshot-20150801:1.18
	sid-snapshot-20150701:1.18
	sid-snapshot-20150601:1.18
	sid-snapshot-20150501:1.18
	sid-snapshot-20150401:1.18
	sid-snapshot-20150301:1.18
	sid-snapshot-20150201:1.18
	sid-snapshot-20150101:1.18
	sid-snapshot-20141201:1.18
	sid-snapshot-20141101:1.18
	sid-snapshot-20141001:1.18
	sid-snapshot-20140901:1.18
	sid-snapshot-20140801:1.18
	sid-snapshot-20140701:1.18
	sid-snapshot-20140601:1.18
	sid-snapshot-20140501:1.18
	sid-snapshot-20140401:1.18
	sid-snapshot-20140301:1.18
	sid-snapshot-20140201:1.18
	sid-snapshot-20140101:1.18
	sid-snapshot-20131201:1.18
	sid-snapshot-20131101:1.18
	sid-snapshot-20131001:1.18
	sid-snapshot-20130901:1.18
	sid-snapshot-20130801:1.18
	sid-snapshot-20130701:1.18
	sid-snapshot-20130601:1.18
	sid-snapshot-20130501:1.18
	sid-snapshot-20130401:1.18
	sid-snapshot-20130301:1.18
	sid-snapshot-20130201:1.18
	sid-snapshot-20130101:1.18
	sid-snapshot-20121201:1.18
	sid-snapshot-20121101:1.18
	sid-snapshot-20121001:1.18
	sid-snapshot-20120901:1.18
	sid-snapshot-20120801:1.18
	sid-snapshot-20120701:1.18
	sid-snapshot-20120601:1.18
	sid-snapshot-20120501:1.18
	sid-snapshot-20120401:1.18
	sid-snapshot-20120301:1.18
	sid-snapshot-20120201:1.18
	sid-snapshot-20120101:1.18
	sid-snapshot-20111201:1.18
	sid-snapshot-20111101:1.18
	sid-snapshot-20111001:1.18
	sid-snapshot-20110901:1.18
	sid-snapshot-20110801:1.18
	sid-snapshot-20110701:1.18
	sid-snapshot-20110601:1.18
	sid-snapshot-20110501:1.18
	sid-snapshot-20110401:1.18
	sid-snapshot-20110301:1.18
	sid-snapshot-20110201:1.18
	sid-snapshot-20110101:1.18
	sid-snapshot-20101201:1.18
	sid-snapshot-20101101:1.18
	sid-snapshot-20101001:1.18
	sid-snapshot-20100901:1.18
	sid-snapshot-20100801:1.18
	sid-snapshot-20100701:1.18
	sid-snapshot-20100601:1.18
	sid-snapshot-20100501:1.18
	sid-snapshot-20100401:1.18
	sid-snapshot-20100301:1.18
	sid-snapshot-20100201:1.18
	sid-snapshot-20100101:1.18
	sid-snapshot-20091201:1.18
	sid-snapshot-20091101:1.18
	sid-snapshot-20091001:1.18
	sid-snapshot-20090901:1.18
	sid-snapshot-20090801:1.18
	sid-snapshot-20090701:1.18
	sid-snapshot-20090601:1.18
	sid-snapshot-20090501:1.18
	sid-snapshot-20090401:1.18
	sid-snapshot-20090301:1.18
	sid-snapshot-20090201:1.18
	sid-snapshot-20090101:1.18
	sid-snapshot-20081201:1.18
	sid-snapshot-20081101:1.18
	sid-snapshot-20081001:1.18
	sid-snapshot-20080901:1.18
	sid-snapshot-20080801:1.18
	sid-snapshot-20080701:1.18
	sid-snapshot-20080601:1.17
	sid-snapshot-20080501:1.17
	sid-snapshot-20080403:1.17
	sid-snapshot-20080401:1.17
	sid-snapshot-20080301:1.17
	sid-snapshot-20080201:1.17
	sid-snapshot-20080101:1.17
	sid-snapshot-20071201:1.17
	sid-snapshot-20071101:1.17
	sid-snapshot-20071001:1.17
	sid-20020905-branchpoint:1.10
	sid-20020905-branch:1.10.0.2
	cygnus_cvs_20020108_pre:1.8;
locks; strict;
comment	@// @;


1.18
date	2008.06.17.18.08.51;	author brolley;	state Exp;
branches;
next	1.17;

1.17
date	2006.03.01.21.07.00;	author fche;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.14.20.04.53;	author brolley;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.19.19.43.50;	author brolley;	state Exp;
branches;
next	1.14;

1.14
date	2004.08.11.20.59.05;	author brolley;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.01.16.54.47;	author brolley;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.28.21.18.07;	author brolley;	state Exp;
branches;
next	1.11;

1.11
date	2004.03.22.21.27.23;	author brolley;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.08.19.15.30;	author fche;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.12.21.58.58;	author fche;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.17.17.50.13;	author brolley;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.03.17.06.01;	author fche;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.03.06.02.43;	author mrg;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.30.16.12.19;	author fche;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.20.11.41.42;	author fche;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.26.15.36.59;	author nsd;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.04.01.00.11;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.07.19.30.50;	author fche;	state Exp;
branches;
next	;


desc
@@


1.18
log
@2008-06-17  Dave Brolley  <brolley@@redhat.com>

        * gdbserv-target.h (set_exec_direction): New member of
        gdbserv_target.
        * gdbserv-state.c (gdbserv_data_packet): Initialize exec_direction.
        Check for a 'b' prefix for the S, s, C, and c packets.  Call
        gdbserv->target->set_exec_direction.
        * gdb.h (set_exec_direction): New function prototype.
        * gdb.cxx (set_exec_direction_hook): New function.
        (gdbsid_target_attach): Set gdbtarget->set_exec_direction.
        (set_exec_direction): New function.
@
text
@// gdb.cxx - GDB stub implementation.  -*- C++ -*-

// Copyright (C) 1999-2002, 2004, 2005, 2006 Red Hat.
// This file is part of SID and is licensed under the GPL.
// See the file COPYING.SID for conditions for redistribution.

#include "config.h"
#include "gdb.h"
#include <cassert>

extern "C" {
#include <stdio.h>
#include "gdbserv.h"
#include "gdbserv-client.h"
#include "gdbserv-target.h"
#include "gdbserv-utils.h"
#include "gdbserv-output.h"
}

// ----------------------------------------------------------------------------
// Interface functions to gdbserv code: client side

extern "C" void
gdbsid_client_write_hook (struct gdbserv *gdbserv, const unsigned char* ch, unsigned len)
{
  assert (gdbserv != 0);
  assert (ch != 0);
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  g->gdbsid_client_write (ch, len);
}



// ----------------------------------------------------------------------------
// Interface functions to gdbserv code: target side

extern "C" struct gdbserv_target*
gdbsid_target_attach_hook (struct gdbserv *gdbserv, void *globalstate)
{
  gdb* g = static_cast<gdb*> (globalstate);
  return g->gdbsid_target_attach (gdbserv);
}

extern "C" void
process_rcmd_hook (struct gdbserv *gdbserv, const char* cmd, int sizeof_cmd)
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  g->process_rcmd (cmd, sizeof_cmd);
}

extern "C" void
process_set_gen_hook (struct gdbserv *gdbserv)
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->process_set_gen ();
}

extern "C" void
process_get_gen_hook (struct gdbserv *gdbserv)
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->process_get_gen ();
}

extern "C" void
process_set_args_hook (struct gdbserv *gdbserv)
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->process_set_args ();
}

extern "C" int
process_set_reg_hook (struct gdbserv *gdbserv, int reg)
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->process_set_reg (reg);
}

extern "C" int
process_set_regs_hook (struct gdbserv *gdbserv)
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->process_set_regs ();
}

extern "C" void
process_get_reg_hook (struct gdbserv *gdbserv, int reg)
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->process_get_reg (reg);
}

extern "C" void
process_get_regs_hook (struct gdbserv *gdbserv)
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->process_get_regs ();
}

extern "C" void
process_get_exp_regs_hook (struct gdbserv *gdbserv)
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->process_get_exp_regs ();
}

extern "C" void
process_get_mem_hook (struct gdbserv *gdbserv,
		      struct gdbserv_reg *reg_addr,
		      struct gdbserv_reg *reg_len)
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->process_get_mem (reg_addr, reg_len);
}

extern "C" void
process_set_mem_hook (struct gdbserv *gdbserv,
		      struct gdbserv_reg *reg_addr,
		      struct gdbserv_reg *reg_len,
                      int binary)
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->process_set_mem (reg_addr, reg_len, binary);
}

extern "C" void
process_set_pc_hook (struct gdbserv *gdbserv, struct gdbserv_reg *val) 
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->process_set_pc (val);
}

extern "C" int
process_signal_hook (struct gdbserv *gdbserv, int sig) 
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->process_signal (sig);
}

extern "C" void
flush_i_cache_hook (struct gdbserv *gdbserv) 
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->flush_i_cache ();
}

extern "C" unsigned long
compute_signal_hook (struct gdbserv *gdbserv, unsigned long sig)
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->compute_signal (sig);
}

extern "C" unsigned long
get_trap_number_hook (struct gdbserv *gdbserv)
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->get_trap_number ();
}

extern "C" int
exit_program_hook (struct gdbserv *gdbserv)
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->exit_program ();
}

extern "C" int
break_program_hook (struct gdbserv *gdbserv)
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->break_program ();
}

extern "C" void
restart_program_hook (struct gdbserv *gdbserv)
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->restart_program ();
}

extern "C" int
singlestep_program_hook (struct gdbserv *gdbserv)
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->singlestep_program ();
}

extern "C" int
rangestep_program_hook (struct gdbserv *gdbserv, struct gdbserv_reg *val1,
			struct gdbserv_reg *val2)
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->rangestep_program (val1, val2);
}


extern "C" void
sigkill_program_hook (struct gdbserv *gdbserv)
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  g->sigkill_program ();
}

extern "C" int
continue_program_hook (struct gdbserv *gdbserv) 
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->continue_program ();
}

extern "C" int
remove_breakpoint_hook (struct gdbserv *gdbserv, unsigned long type,
			struct gdbserv_reg *addr, struct gdbserv_reg* len)
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->remove_breakpoint (type, addr, len);
}

extern "C" int
set_breakpoint_hook (struct gdbserv *gdbserv, unsigned long type,
		     struct gdbserv_reg *addr, struct gdbserv_reg* len)
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->set_breakpoint (type, addr, len);
}

extern "C" void
process_detach_hook (struct gdbserv *gdbserv)
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->process_detach ();
}

extern "C" int
set_exec_direction_hook (struct gdbserv *gdbserv, const char *direction)
{
  gdb* g = static_cast<gdb*> (gdbserv_target_data (gdbserv));
  return g->set_exec_direction (direction);
}




// ----------------------------------------------------------------------------
// Implementations for base class.


struct gdbserv_target*
gdb::gdbsid_target_attach (struct gdbserv *gdbserv)
{
  // Do nothing if we're not configured properly.
  if (this->cpu == 0)
    {
      cerr << "Error: Cannot attach to gdb: cpu relationship is not configured." << endl;
      return 0;
    }

  if (this->gdbserv == 0)
    {
      struct gdbserv_target* gdbtarget = new ::gdbserv_target();
      assert (gdbtarget != 0);
      memset (gdbtarget, 0, sizeof (*gdbtarget)); // XXX: needed?

      gdbtarget->process_rcmd = process_rcmd_hook;
      gdbtarget->process_get_gen = process_get_gen_hook;
      gdbtarget->process_set_gen = process_set_gen_hook;
      gdbtarget->process_set_args = process_set_args_hook;
      gdbtarget->process_set_reg = process_set_reg_hook;
      gdbtarget->process_get_reg = process_get_reg_hook;
      gdbtarget->process_set_regs = process_set_regs_hook;
      gdbtarget->process_get_regs = process_get_regs_hook;
      gdbtarget->process_get_exp_regs = process_get_exp_regs_hook;
      gdbtarget->process_get_mem = process_get_mem_hook;
      gdbtarget->process_set_mem = process_set_mem_hook;
      gdbtarget->process_set_pc = process_set_pc_hook;
      gdbtarget->process_signal = process_signal_hook;
      gdbtarget->flush_i_cache = flush_i_cache_hook;
      gdbtarget->compute_signal = compute_signal_hook;
      gdbtarget->get_trap_number = get_trap_number_hook;
      gdbtarget->exit_program = exit_program_hook;
      gdbtarget->break_program = break_program_hook;
      gdbtarget->restart_program = restart_program_hook;
      gdbtarget->singlestep_program = singlestep_program_hook;
      gdbtarget->rangestep_program = rangestep_program_hook;
      gdbtarget->sigkill_program = sigkill_program_hook;
      gdbtarget->continue_program = continue_program_hook;
      gdbtarget->set_exec_direction = set_exec_direction_hook;
      gdbtarget->remove_breakpoint = remove_breakpoint_hook;
      gdbtarget->set_breakpoint = set_breakpoint_hook;
      gdbtarget->detach = process_detach_hook;

      // install mutual pointers
      gdbtarget->data = static_cast<void*>(this);
      this->gdbserv = gdbserv;

      if (trace_gdbsid)
	cerr << "gdb open" << endl;

      // shut down target
      target_power (false);
      
      // signal gdb
      last_signal = GDBSERV_SIGTRAP;
      gdbserv_fromtarget_break (gdbserv, last_signal);

      return gdbtarget;
    }
  else
    {
      cerr << "Error: Cannot attach again to gdb." << endl;
      return 0;
    }
}


void
gdb::process_rcmd (const char *cmd, int sizeof_cmd)
{
  string command = string (cmd, sizeof_cmd);
  vector<string> tokens = sidutil::tokenize (command, " ");

  if (trace_gdbsid)
    cerr << "process_rcmd " << command << endl;

  if (tokens.size() >= 1 &&
      tokens[0] == "set" &&
      this->cfgroot != 0)
    {
      // pass command string straight through to cfgroot
      component::status s = this->cfgroot->set_attribute_value ("config-line!", command);
      if (s != component::ok)
	gdbserv_output_string (gdbserv, "E02");
      else
	gdbserv_output_string (gdbserv, "OK");

      return;
    }

  gdbserv_output_string (gdbserv, "E01");
}


void
gdb::process_get_gen ()
{
}


void
gdb::process_set_gen ()
{

  if (trace_gdbsid)
    cerr << "process_set_gen" << endl;

#if 0
  char *lhs;
  char *rhs;
  size_t sizeof_buf;

  sizeof_buf = gdbserv_input_size (gdbserv);
  if (sizeof_buf <= 0)
    {
      gdbserv_output_string (gdbserv, "E01");
      return;
    }
  lhs = (char*) alloca (sizeof_buf + 1);
  gdbserv_input_string (gdbserv, lhs, sizeof_buf + 1);
  rhs = strchr (lhs, '=');
  if (rhs == NULL)
    {
      gdbserv_output_string (gdbserv, "E02");
      return;
    }
  *rhs++ = '\0';
  //  if (this->general_set_func)
  //    gdbsid->general_set_func (gdbsid->general_set_data, lhs, rhs);
#endif
}


void
gdb::process_set_args ()
{
  if (trace_gdbsid)
    cerr << "process_set_args" << endl;

  if (gloss)
    {
      ; // XXX: collect arguments etc.
    }
  else
    {
      cerr << "Warning: gloss component not configured!" << endl;
    }
}

using std::hex;
using std::setw;
using std::dec;

int
gdb::process_set_reg (int reg)
{
  string reg_image;

  if (trace_gdbsid)
    cerr << "process_set_reg " << reg << " = [" << hex;
  
  dbg_register_number_t regno = reg;
  string reg_name = string("gdb-register-") + make_numeric_attribute(regno);

  int byte = gdbserv_input_byte (gdbserv);
  while (byte >= 0) 
    {
      if (trace_gdbsid)
	cerr << setw(2) << (unsigned) byte << " ";
      
      reg_image += (char) byte;
      byte = gdbserv_input_byte (gdbserv);
    }

  if (trace_gdbsid)
    cerr << "]" << dec << endl;

  component::status s = cpu->set_attribute_value (reg_name, reg_image);
  if (s != component::ok)
    return -1;
    
  return 0;
}


void
gdb::process_get_reg (int reg)
{
  if (trace_gdbsid)
    cerr << "process_get_reg " << reg << endl;

  // Not implemented
  gdbserv_output_string (gdbserv, "E01");
}


int
gdb::process_set_regs ()
{
  if (trace_gdbsid)
    cerr << "process_set_regs" << endl;

  // Not implemented
  gdbserv_output_string (gdbserv, "E01");

  return 0;
}


void
gdb::process_get_regs ()
{
  if (trace_gdbsid)
    cerr << "process_get_regs " << endl;

  dbg_register_number_t num_regs;
  string num_regs_str = cpu->attribute_value ("gdb-num-registers");
  component::status s = parse_attribute (num_regs_str, num_regs);
  if (s != component::ok)
    num_regs = 0;

  if (trace_gdbsid)
    cerr << "num_regs=" << num_regs;
  unsigned num_bytes = 0;

  for (dbg_register_number_t regno=0; regno<num_regs; regno++) 
    {
      string reg_name = string("gdb-register-") 
	+ make_numeric_attribute(regno);
      string value = cpu->attribute_value (reg_name);

      for (unsigned i=0; i < value.length(); i++)
	{
	  gdbserv_output_byte (gdbserv, value[i]);
	  num_bytes ++;
	}
    }

  if (trace_gdbsid)
    cerr << " bytes=" << num_bytes << endl;
}


void
gdb::process_get_exp_regs ()
{
  if (trace_gdbsid)
    cerr << "process_get_exp_regs";

  string exp_regs_str = cpu->attribute_value ("gdb-exp-registers");
  // None supplied
  if (exp_regs_str == "")
    return;

  vector<string> exp_regs_list = tokenize (exp_regs_str, ";");
  unsigned num_bytes = 0;

  for (unsigned i=0; i<exp_regs_list.size(); i++)
    {
      dbg_register_number_t regno;
      component::status s = parse_attribute (exp_regs_list[i], regno);
      if (s != component::ok)
	continue;

      if (trace_gdbsid)
	cerr << " " << regno;

      string reg_name = string("gdb-register-") + make_numeric_attribute (regno);
      string value = cpu->attribute_value (reg_name);

      // encode register number
      string regno_hex = make_numeric_attribute (regno, ios::hex); // no ios::showbase
      gdbserv_output_string (gdbserv, regno_hex.c_str());
      gdbserv_output_char (gdbserv, ':');

      // and value
      for (unsigned i=0; i < value.length(); i++)
	{
	  gdbserv_output_byte (gdbserv, value[i]);
	  num_bytes ++;
	}
      gdbserv_output_char (gdbserv, ';');
    }

  if (trace_gdbsid)
    cerr << " bytes=" << num_bytes << endl;
}



// Helper functions

template <class Type>
void
read_bus_word(gdbserv* gdbserv, 
	      sid::bus* bus,
	      host_int_4 address,
	      const Type& _dummy)
{
  Type value;
  bus::status s = bus->read (address, value);
  if (s == bus::ok) 
    {
      for (unsigned i=0; i < sizeof(typename Type::value_type); i++)
	gdbserv_output_byte (gdbserv, value.read_byte(i));
    }
  else if (s == bus::misaligned)
    {
      // Try it one byte at a time
      for (unsigned i=0; i < sizeof(typename Type::value_type); i++)
	{
	  big_int_1 b; // endianness of a single byte is irrelevent
	  s = bus->read (address + i, b);
	  if (s == bus::ok) 
	    gdbserv_output_byte (gdbserv, b);
	  else
	    gdbserv_output_string (gdbserv, "E05");
	}
    }
  else
    gdbserv_output_string (gdbserv, "E05");
}


template <class Type>
void
write_bus_word(gdbserv* gdbserv, 
	       int binary,
	       sid::bus* bus,
	       host_int_4 address,
	       const Type& _dummy)
{
  Type value;

  for (unsigned i=0; i < sizeof(typename Type::value_type); i++)
    {
      char b;
      if (binary)
	gdbserv_input_escaped_binary (gdbserv, & b, 1);
      else
	gdbserv_input_bytes (gdbserv, & b, 1);

      value.write_byte (i, b);
    }

  bus::status s = bus->write (address, value);
  if (s == bus::misaligned)
    {
      // Try it a byte at a time
      for (unsigned i=0; i < sizeof(typename Type::value_type); i++)
	{
	  // endianness of a single byte is irrelevent
	  big_int_1 b = value.read_byte (i);
	  s = bus->write (address + i, b);
	  if (s != bus::ok)
	    gdbserv_output_string (gdbserv, "E05");
	}
    }
  else if (s != bus::ok)
    gdbserv_output_string (gdbserv, "E05");
}



void
gdb::process_get_mem (struct gdbserv_reg *reg_addr,
		      struct gdbserv_reg *reg_len)
{
  unsigned long long addr8;
  gdbserv_reg_to_ulonglong (gdbserv, reg_addr, &addr8);
  unsigned long len;
  gdbserv_reg_to_ulong (gdbserv, reg_len, &len);

  if (trace_gdbsid)
    cerr << "process_get_mem addr=" << addr8 << " len=" << len << endl;

  if (! cpu)
    {
      cerr << "No cpu!" << endl;
      gdbserv_output_string (gdbserv, "E01");
      return;
    }
  sid::bus* memory = cpu->find_bus ("debugger-bus");
  if (! memory)
    {
      cerr << "No debugger-bus!" << endl;
      gdbserv_output_string (gdbserv, "E02");
      return;
    }
 
  endian e;
  component::status s = 
    parse_attribute (cpu->attribute_value ("endian"), e);
  if (s != component::ok) assert (e == endian_unknown);

  // XXX: 64-bit addresses unsupported
  if (0 && addr8 >= (1ULL << 32))
    {
      cerr << "Bad address" << endl;
      gdbserv_output_string (gdbserv, "E03");
      return;
    }
  host_int_4 addr = addr8; // truncate

  if (len==1 && e==endian_big) 
    read_bus_word (gdbserv, memory, addr, big_int_1());
  else if (len==1 && e==endian_little)
    read_bus_word (gdbserv, memory, addr, little_int_1());
  else if (len==2 && e==endian_big) 
    read_bus_word (gdbserv, memory, addr, big_int_2());
  else if (len==2 && e==endian_little)
    read_bus_word (gdbserv, memory, addr, little_int_2());
  else if (len==4 && e==endian_big) 
    read_bus_word (gdbserv, memory, addr, big_int_4());
  else if (len==4 && e==endian_little)
    read_bus_word (gdbserv, memory, addr, little_int_4());
  else if (len==8 && e==endian_big) 
    read_bus_word (gdbserv, memory, addr, big_int_8());
  else if (len==8 && e==endian_little)
    read_bus_word (gdbserv, memory, addr, little_int_8());
  else if (e==endian_little)
    {
      for (unsigned long i=0; i<len; i++)
	read_bus_word (gdbserv, memory, addr + i, little_int_1());
    }
  else if (e==endian_big)
    {
      for (unsigned long i=0; i<len; i++)
	read_bus_word (gdbserv, memory, addr + i, big_int_1());
    }
  else
    {
      cerr << "Unknown endianness/size combination!" << endl;
      gdbserv_output_string (gdbserv, "E04");
    }
}


void
gdb::process_set_mem (struct gdbserv_reg *reg_addr,
		      struct gdbserv_reg *reg_len,
		      int binary)
{
  unsigned long long addr8;
  gdbserv_reg_to_ulonglong (gdbserv, reg_addr, &addr8);

  unsigned long len;
  gdbserv_reg_to_ulong (gdbserv, reg_len, &len);

  if (trace_gdbsid)
    cerr << "process_set_mem"
	<< " addr=" << addr8 
	<< " len=" << len 
	<< " binary=" << binary 
        << endl;

  if (! cpu)
    {
      cerr << "No cpu!" << endl;
      gdbserv_output_string (gdbserv, "E01");
      return;
    }
  sid::bus* memory = cpu->find_bus ("debugger-bus");
  if (! memory)
    {
      cerr << "No debugger-bus!" << endl;
      gdbserv_output_string (gdbserv, "E02");
      return;
    }
 
  endian e;
  component::status s = 
    parse_attribute (cpu->attribute_value ("endian"), e);
  if (s != component::ok) assert (e == endian_unknown);

  // XXX: 64-bit addresses unsupported
  if (0 && addr8 >= (1ULL << 32))
    {
      cerr << "Bad address" << endl;
      gdbserv_output_string (gdbserv, "E03");
      return;
    }
  host_int_4 addr = addr8; // truncate

  if (len==1 && e==endian_big) 
    write_bus_word (gdbserv, binary, memory, addr, big_int_1());
  else if (len==1 && e==endian_little)
    write_bus_word (gdbserv, binary, memory, addr, little_int_1());
  else if (len==2 && e==endian_big) 
    write_bus_word (gdbserv, binary, memory, addr, big_int_2());
  else if (len==2 && e==endian_little)
    write_bus_word (gdbserv, binary, memory, addr, little_int_2());
  else if (len==4 && e==endian_big) 
    write_bus_word (gdbserv, binary, memory, addr, big_int_4());
  else if (len==4 && e==endian_little)
    write_bus_word (gdbserv, binary, memory, addr, little_int_4());
  else if (len==8 && e==endian_big) 
    write_bus_word (gdbserv, binary, memory, addr, big_int_8());
  else if (len==8 && e==endian_little)
    write_bus_word (gdbserv, binary, memory, addr, little_int_8());
  else if (e==endian_little)
    {
      for (unsigned long i=0; i<len; i++)
	write_bus_word (gdbserv, binary, memory, addr + i, little_int_1());
    }
  else if (e==endian_big)
    {
      for (unsigned long i=0; i<len; i++)
	write_bus_word (gdbserv, binary, memory, addr + i, big_int_1());
    }
  else
    {
      cerr << "Unknown endianness/size combination!" << endl;
      gdbserv_output_string (gdbserv, "E04");
    }
}


void
gdb::process_set_pc (struct gdbserv_reg* val) 
{
  if (trace_gdbsid)
    cerr << "process_set_pc ";

  host_int_8 pc;
  gdbserv_reg_to_ulonglong (gdbserv, val, & pc);

  if (trace_gdbsid)
    cerr << pc;

  // Handle disharvardization
  if (this->gdb_pc_mask)
    {
      pc &= this->gdb_pc_mask;
      if (trace_gdbsid)
	cerr << " =Z=> "
	     << pc;
    }
      
  if (trace_gdbsid)
    cerr << endl;

  component::status s = cpu->set_attribute_value ("gdb-register-pc",
						  make_numeric_attribute (pc));
  if (s != component::ok)
    {
      cerr << "cannot set gdb-register-pc " << pc << endl;
    }
}


int
gdb::process_signal (int sig)
{
  if (trace_gdbsid)
    cerr << "process_signal " << sig << endl;

  // Mark next occurrence of this signal as to be ignored
  this->pending_signal_counts [sig] ++;

  return 0;
}


void
gdb::flush_i_cache () 
{
  if (trace_gdbsid)
    cerr << "flush_i_cache" << endl;

  this->icache_flush_pin.drive (0);
}


unsigned long
gdb::compute_signal (unsigned long sig)
{
  if (trace_gdbsid)
    cerr << "compute_signal " << sig << endl;

  return sig;
}


unsigned long
gdb::get_trap_number ()
{
  if (trace_gdbsid)
    cerr << "get_trap_number " << endl;

  return last_signal;
}


int
gdb::exit_program ()
{
  if (trace_gdbsid)
    cerr << "exit_program " << endl;

  // Turn off the range-stepping!
  this->step_range_start = 0;
  this->step_range_end = 0;

  // shut down target
  target_power (false);

  // signal gdb
  last_signal = GDBSERV_SIGINT;
  gdbserv_fromtarget_break (gdbserv, last_signal);

  // [don't] signal cfgroot to shut down
  // this->process_signal_pin.drive (1);

  return 0;
}


int
gdb::break_program ()
{
  if (trace_gdbsid)
    cerr << "break_program " << endl;

  // Turn off the range-stepping!
  this->step_range_start = 0;
  this->step_range_end = 0;

  // shut down target
  target_power (false);

  // signal gdb
  last_signal = GDBSERV_SIGINT;
  gdbserv_fromtarget_break (gdbserv, last_signal);
  return 0;
}


void
gdb::restart_program ()
{
  if (trace_gdbsid)
    cerr << "restart_program " << endl;

  // Drive restart pin so reset can be performed
  this->restart_pin.drive (1);
}


int
gdb::singlestep_program ()
{
  if (trace_gdbsid)
    cerr << "singlestep_program " << endl;

  assert (cpu != 0);
  component::status s = cpu->set_attribute_value ("enable-step-trap?", "1");
  if (s != component::ok)
    {
      cerr << "Cannot set enable-step-trap? attribute in cpu: status " << (int)s << endl;
    }

  this->step_range_start = 0;
  this->step_range_end = 0;

  // turn on target subsystem
  target_power (true);

  return 0;
}


int
gdb::rangestep_program (struct gdbserv_reg* range_start, struct gdbserv_reg* range_end)
{
  if (! this->enable_E_packet)
    return GDBSERV_TARGET_RC_ERROR;

  if (trace_gdbsid)
    cerr << "rangestep_program ";

  assert (cpu != 0);
  component::status s = cpu->set_attribute_value ("enable-step-trap?", "1");
  if (s != component::ok)
    {
      cerr << "Cannot set enable-step-trap? attribute in cpu: status " << (int)s << endl;
    }

  gdbserv_reg_to_ulonglong (gdbserv, range_start, & this->step_range_start);
  gdbserv_reg_to_ulonglong (gdbserv, range_end, & this->step_range_end);

  if (trace_gdbsid)
    cerr << "[" << this->step_range_start << "," << this->step_range_end << ")";

  // Handle disharvardization
  if (this->gdb_pc_mask)
    {
      this->step_range_start &= this->gdb_pc_mask;
      this->step_range_end &= this->gdb_pc_mask;
      if (trace_gdbsid)
	cerr << " =Z=> "
	     << "[" << this->step_range_start << "," << this->step_range_end << ")";
    }

  if (trace_gdbsid)
    cerr << endl;

  // turn on target subsystem
  target_power (true);

  return GDBSERV_TARGET_RC_OK;
}


void
gdb::sigkill_program ()
{
  if (trace_gdbsid)
    cerr << "sigkill_program " << endl;

  // signal gdb
  last_signal = GDBSERV_SIGKILL;
  gdbserv_fromtarget_exit (gdbserv, last_signal);
}


int
gdb::continue_program () 
{
  if (trace_gdbsid)
    cerr << "continue_program " << endl;

  // turn off single-stepping
  assert (cpu != 0);
  component::status s = cpu->set_attribute_value ("enable-step-trap?", "0");
  if (s != component::ok)
    {
      cerr << "Cannot clear enable-step-trap? attribute in cpu: status " << (int) s << endl;
    }

  this->step_range_start = 0;
  this->step_range_end = 0;

  // turn on target subsystem
  target_power (true);
  return 0;
}


int
gdb::remove_breakpoint (unsigned long type, struct gdbserv_reg *addr, struct gdbserv_reg *len)
{
  host_int_8 watch_pc;
  gdbserv_reg_to_ulonglong (gdbserv, addr, &watch_pc);

  unsigned long bp_length;
  gdbserv_reg_to_ulong (gdbserv, len, &bp_length);

  if (trace_gdbsid)
    cerr << "remove_breakpoint"
	 << " type " << type
	 << " addr " << watch_pc
	 << " length " << bp_length
	 << endl;

  if (! enable_Z_packet) return 1;
  if (this->cpu == 0) return -1;

  int rc = 1; // Not supported

  if ((type == GDBSERV_TARGET_BP_HARDWARE) || 
      (type == GDBSERV_TARGET_BP_SOFTWARE && force_Z_sw_to_hw))
    rc = this->remove_hw_breakpoint (watch_pc, bp_length) ? 0 : -1;
  else if ((type == GDBSERV_TARGET_BP_SOFTWARE) || 
	   (type == GDBSERV_TARGET_BP_HARDWARE && force_Z_hw_to_sw))
    rc = this->remove_sw_breakpoint (watch_pc, bp_length) ? 0 : -1;
  else if (type == GDBSERV_TARGET_BP_WRITE)
    rc = this->remove_hw_watchpoint (watch_pc, bp_length) ? 0 : -1;
  // Fail on uses of other breakpoint types (WRITE, READ, ACCESS, UNKNOWN)

  return rc;
}


bool
gdb::remove_all_hw_breakpoints ()
{
  while (true)
    {
      hw_breakpoints_t::iterator it = this->hw_breakpoints.begin();
      if (it == this->hw_breakpoints.end()) break;

      // clean up carcass with refcount=0
      if (it->second == 0)
	{
	  this->hw_breakpoints.erase(it);
	  continue;
	}

      // decrement refcount
      host_int_8 address = it->first;
      bool ok = this->remove_hw_breakpoint (address, 0);
      if (!ok) return ok;
    }
  return true;
}


bool
gdb::remove_hw_breakpoint (host_int_8 address, host_int_4 length)
{  
  if (this->hw_breakpoints[address] <= 0)
    {
      cerr << "sw-debug-gdb: duplicate breakpoint count underflow!" << endl;
      return false;
    }

  string watcher_name;
  if (this->gdb_pc_mask)
    {
      watcher_name =
	string ("watch:") + 
	map_watchable_name ("gdb-register-pc") + string (":") +
	string ("mask/value:") + 
	make_numeric_attribute (this->gdb_pc_mask) + string (":") +
	make_numeric_attribute (address);
    }
  else
    {
      watcher_name =
	string ("watch:") + 
	map_watchable_name ("gdb-register-pc") + string (":") +
	string ("value:") + 
	make_numeric_attribute (address);
    }
  // see also ::add_hw_breakpoint()
  
  this->hw_breakpoints[address] --;
  if (this->hw_breakpoints[address] == 0)
    {
      component::status s = this->cpu->disconnect_pin (watcher_name, & this->trapstop_pin);
      return (s == component::ok);
    }
  else
    return true;
}


bool
gdb::remove_all_sw_breakpoints ()
{
  while (true)
    {
      sw_breakpoints_t::iterator it = this->sw_breakpoints.begin();
      if (it == this->sw_breakpoints.end()) break;

      host_int_8 address = it->first;
      bool ok = this->remove_hw_breakpoint (address, 0 /* unknown length */);
      if (!ok) return ok;
    }
  return true;
}


bool
gdb::remove_sw_breakpoint (host_int_8 address, host_int_4 length)
{
  // see also ::add_sw_breakpoint()

  // reject absent entry
  if (this->sw_breakpoints.find(address) == this->sw_breakpoints.end())
    return fallback_Z_sw_to_hw && this->remove_hw_breakpoint (address, length);

  // Beyond this point, don't try to fall back to hw breakpoints.
  // That's because only a successful add_sw_breakpoint would pass the
  // previous test.  If it fails anything beyond this point, then a sw
  // breakpoint is already in place, and cannot possibly be removed by
  // using hw breakpoints.

  sid::bus* memory = cpu->find_bus ("debugger-bus");
  if (! memory)
    return false;

  string imem = this->sw_breakpoints [address];

  if (length != 0 && (imem.length() != length))
    return false;
  // maybe we don't know the removal length any more; update length if so
  if (length == 0)
    length = imem.length();

  // put back insn memory at given address
  for (host_int_4 i=0; i<length; i++)
    {
      little_int_1 byte; // == big_int_1

      // store back old image
      byte = imem[i]; // range already checked above
      bus::status s = memory->write (address + i, byte);
      if (s != bus::ok)
	return false;
    }

  // success!
  this->sw_breakpoints.erase (address);
  return true;
}


bool
gdb::remove_all_hw_watchpoints ()
{
  while (true)
    {
      hw_watchpoints_t::iterator it = this->hw_watchpoints.begin();
      if (it == this->hw_watchpoints.end()) break;

      // clean up carcass with refcount=0
      if (it->second == 0)
	{
	  this->hw_watchpoints.erase(it);
	  continue;
	}

      // decrement refcount
      string watcher_name = it->first;
      bool ok = this->remove_hw_watchpoint (watcher_name);
      if (!ok) return ok;
    }
  return true;
}


bool
gdb::remove_hw_watchpoint (const string &watcher_name)
{  
  if (this->hw_watchpoints[watcher_name] <= 0)
    {
      cerr << "sw-debug-gdb: duplicate watchpoint count underflow!" << endl;
      return false;
    }

  this->hw_watchpoints[watcher_name] --;
  if (this->hw_watchpoints[watcher_name] == 0)
    {
      component::status s = this->cpu->disconnect_pin (watcher_name, & this->trapstop_pin);
      return (s == component::ok);
    }
  else
    return true;
}


bool
gdb::remove_hw_watchpoint (host_int_8 address, host_int_4 length)
{  
  string watcher_name = string ("watch:")
    + map_watchable_name ("gdb-watchpoint-"
			  + make_numeric_attribute (address)
			  + "-"
			  + make_numeric_attribute (length))
    + ":change";

  return remove_hw_watchpoint (watcher_name);
}


int
gdb::set_breakpoint (unsigned long type, struct gdbserv_reg *addr, struct gdbserv_reg *len)
{
  host_int_8 watch_pc;
  gdbserv_reg_to_ulonglong (gdbserv, addr, &watch_pc);

  unsigned long bp_length;
  gdbserv_reg_to_ulong (gdbserv, len, &bp_length);

  if (trace_gdbsid)
    cerr << "add_breakpoint"
	 << " type " << type
	 << " addr " << watch_pc
	 << " length " << bp_length
	 << endl;


  if (! enable_Z_packet) return 1;
  if (this->cpu == 0) return -1;

  int rc = 1; // Not supported

  if ((type == GDBSERV_TARGET_BP_HARDWARE) || 
      (type == GDBSERV_TARGET_BP_SOFTWARE && force_Z_sw_to_hw))
    rc = this->add_hw_breakpoint (watch_pc, bp_length) ? 0 : -1;
  else if ((type == GDBSERV_TARGET_BP_SOFTWARE) || 
	   (type == GDBSERV_TARGET_BP_HARDWARE && force_Z_hw_to_sw))
    rc = this->add_sw_breakpoint (watch_pc, bp_length) ? 0 : -1;
  else if (type == GDBSERV_TARGET_BP_WRITE)
    rc = this->add_hw_watchpoint (watch_pc, bp_length) ? 0 : -1;
  // Fail on uses of other breakpoint types (READ, ACCESS, UNKNOWN)

  return rc;
}


bool
gdb::add_hw_breakpoint (host_int_8 address, host_int_4 length)
{
  // XXX: be sensitive to length

  string watcher_name;
  if (this->gdb_pc_mask)
    {
      watcher_name =
	string ("watch:") + 
	map_watchable_name ("gdb-register-pc") + string (":") +
	string ("mask/value:") + 
	make_numeric_attribute (this->gdb_pc_mask) + string (":") +
	make_numeric_attribute (address);
    }
  else
    {
      watcher_name =
	string ("watch:") + 
	map_watchable_name ("gdb-register-pc") + string (":") +
	string ("value:") + 
	make_numeric_attribute (address);
    }
  // see also ::remove_hw_breakpoint()

  this->hw_breakpoints[address] ++;
  if (this->hw_breakpoints[address] == 1)
    {
      component::status s = this->cpu->connect_pin (watcher_name, & this->trapstop_pin);
      return (s == component::ok);
    }
  else
    return true;
}


bool
gdb::add_sw_breakpoint (host_int_8 address, host_int_4 length)
{
  // see also ::remove_sw_breakpoint()

  // reject duplicate
  if (this->sw_breakpoints.find(address) != this->sw_breakpoints.end())
    return false;

  sid::bus* memory = cpu->find_bus ("debugger-bus");
  if (! memory)
    return fallback_Z_sw_to_hw && this->add_hw_breakpoint (address, length);

  // fetch cpu sw breakpoint image
  endian e;
  component::status s = 
    parse_attribute (cpu->attribute_value ("endian"), e);
  if (s != component::ok) assert (e == endian_unknown);
  string bp_attr_name = string("gdb-sw-breakpoint") + 
    (e == endian_little ? string ("-little") :
     e == endian_big ? string ("-big") :
     string ("")); // should not happen; will fail when used
  string bp = cpu->attribute_value (bp_attr_name);
  if (bp.length() != length)
    return fallback_Z_sw_to_hw && this->add_hw_breakpoint (address, length);

  // fetch insn memory at given address; replace it byte by byte
  string imem;
  for (host_int_4 i=0; i<length; i++)
    {
      little_int_1 byte; // == big_int_1

      // fetch old image
      bus::status s = memory->read (address + i, byte);
      if (s != bus::ok)
	return fallback_Z_sw_to_hw && this->add_hw_breakpoint (address, length);
      imem += byte;

      // store new image
      byte = bp[i]; // range already checked above
      s = memory->write (address + i, byte);
      if (s != bus::ok)
	return fallback_Z_sw_to_hw && this->add_hw_breakpoint (address, length);
    }

  // success!
  this->sw_breakpoints [address] = imem;
  return true;
}


int
gdb::set_exec_direction (const char *direction)
{
  if (trace_gdbsid)
    cerr << "set_exec_direction " << endl;

  assert (cpu != 0);
  component::status s = cpu->set_attribute_value ("exec-direction", direction);
  if (s != component::ok)
    {
      cerr << "Cannot set exec-direction attribute in cpu: status " << (int)s << endl;
    }

  return 0;
}


bool
gdb::add_hw_watchpoint (host_int_8 address, host_int_4 length)
{
  // XXX: be sensitive to length

  string watcher_name = string ("watch:")
    + map_watchable_name ("gdb-watchpoint-"
			  + make_numeric_attribute (address)
			  + "-"
			  + make_numeric_attribute (length))
    + ":change";

  // see also ::remove_hw_watchpoint()

  this->hw_watchpoints[watcher_name] ++;
  if (this->hw_watchpoints[watcher_name] == 1)
    {
      component::status s = this->cpu->connect_pin (watcher_name, & this->trapstop_pin);
      return (s == component::ok);
    }
  else
    return true;
}


void
gdb::process_detach ()
{
  if (trace_gdbsid)
    cerr << "process_detach " << endl;

  bool ok =
    this->remove_all_hw_breakpoints () &&
    this->remove_all_sw_breakpoints () &&
    this->remove_all_hw_watchpoints ();
  if (!ok)
    {
      cerr << "sw-debug-gdb: cannot clean up breakpoints" << endl;
    }

  // Decouple from gdbserv; caller will free it.
  this->gdbserv = 0;

  // Conditionally stop sim.
  if (this->exit_on_detach)
    {
      // shut down target
      target_power (false);
      // signal cfgroot to shut down
      this->process_signal_pin.drive (1);
    }
  else
    {
      // Don't resume target subsystem.  It may be halted on purpose,
      // such as after having executed an exit().  A gdb re-attach may
      // bring the target back to life.
    }
}

// Increment a given attribute value, interpreted as a plain `int'.
static void 
increment_attribute (sid::component* comp, const string& attr, int increment)
{
  assert(comp);
  string valstr = comp->attribute_value (attr);
  int num;
  component::status s = parse_attribute(valstr, num);
  if (s != component::ok)
    {
      cerr << "Cannot parse " << attr << " attribute: string " << valstr
	   << " status " << (int) s << endl;
      return;
    }
  
  num += increment;
  
  valstr = make_numeric_attribute (num);
  
  s = comp->set_attribute_value (attr, valstr);
  if (s != component::ok)
    {
      cerr << "Cannot set " << attr << " attribute: string " << valstr
	   << " status " << (int) s << endl;
      return;
    }
}

void
gdb::target_power (bool on)
{
  if (trace_gdbsid)
    cerr << "target_power " << on << endl;

  // clear signal cause
  last_signal = GDBSERV_SIGNONE;

  // signal target system to yield
  this->yield_pin.drive (0);

  // increment/decrement enabled? attribute of target schedulers when 'on'
  // is true/false respectively.  Do not increment/decrement the attribute
  // if the scheduler is already enabled/disabled from our point of view.
  int incr = on ? 1 : -1;
  for (unsigned i=0; i<target_schedulers.size(); i++)
    {
      bool enabled = target_schedulers_enabled[i];
      if (trace_gdbsid)
	cerr << "  Target scheduler " << i << " enabled==" << enabled << endl;
      if (enabled != on)
	{
	  increment_attribute (target_schedulers[i], "enabled?", incr);
	  target_schedulers_enabled[i] = on;
	}
    }

  // increment/decrement enabled? attribute of host schedulers when 'on'
  // is false/true respectively.  Do not increment/decrement the attribute
  // if the scheduler is already enabled/disabled from our point of view.
  for (unsigned j=0; j<host_schedulers.size(); j++)
    {
      bool yielded = host_schedulers_host_time_yielded[j];
      if (trace_gdbsid)
	cerr << "  Host scheduler " << j << " yielded==" << yielded << endl;
      if (yielded == on)
	{
	  increment_attribute (host_schedulers[j], "yield-host-time?", -incr);
	  host_schedulers_host_time_yielded[j] = ! on;
	}
    }
}


// ----------------------------------------------------------------------------
// Interface functions to gdbserv / client code


void
gdb::gdbsid_client_write (const unsigned char* ch, unsigned len)
{
  if (! this->connected_p)
    {
      cerr << "gdb: warning: writing but not yet connected" << endl;
    }

  for (unsigned i = 0; i < len; i++)
    {
      this->remote_tx_pin.drive (ch[i]);
    }
}


void
gdb::remote_rx_eof_handler ()
{
  if (this->trace_gdbserv)
    cout << "gdb: disconnect" << endl;

  if (! this->connected_p)
    {
      cerr << "gdb: unexpected disconnection." << endl;
      return;
    }

  this->connected_p = false;

  gdbserv_fromclient_detach (this->gdbserv);

  assert (this->gdbserv_client != 0);
  delete this->gdbserv_client;
  this->gdbserv_client = 0;
}


void
gdb::remote_rx_handler (host_int_4 value)
{
  // dispatch to EOF handler
  if (value & ~0x00FF)
    return this->remote_rx_eof_handler ();

  // first byte coming from a connection?
  if (! this->connected_p)
    {
      if (this->trace_gdbserv)
	cout << "gdb: connect" << endl;

      this->connected_p = true;

      assert (this->gdbserv_client == 0);
      this->gdbserv_client = new ::gdbserv_client();
      this->gdbserv_client->write = & gdbsid_client_write_hook;
      this->gdbserv_client->data = static_cast<void*>(this);

      // Attach to gdbserv engine.  NB: This calls back into this
      // object through the attach_hook.
      struct gdbserv* serv = gdbserv_fromclient_attach (this->gdbserv_client,
							& gdbsid_target_attach_hook,
							static_cast<void*>(this));
      if (serv == 0)
	{
	  // This shouldn't happen, since 
	  cerr << "gdb: refusing connection" << endl;
	  this->connected_p = false;
	  delete this->gdbserv_client;
	  this->gdbserv_client = 0;
	  this->remote_tx_pin.drive (~0); // send EOF
	  return;
	}
    }

  // forward the byte to gdbserv-input.
  assert (this->gdbserv != 0);

  char data = (value & 0x00FF);
  gdbserv_fromclient_data (this->gdbserv, & data, 1);
}


// ----------------------------------------------------------------------------
// Interface functions to sid code

gdb::gdb ():
  init_pin (this, & gdb::init_handler), 
  deinit_pin (this, & gdb::deinit_handler),
  connected_p (false),
  remote_rx_pin (this, & gdb::remote_rx_handler),
  cpu (0),
  gloss (0),
  cpu_trap_ipin (this, & gdb::cpu_trap_handler),
  gloss_process_signal_pin (this, & gdb::gloss_signal_handler),
  target_tx_pin (this, & gdb::target_tx_handler),
  stop_pin (this, & gdb::stop_handler),
  trapstop_pin (this, & gdb::trapstop_handler),
  start_pin (this, & gdb::start_handler),
  gdbserv (0),
  gdbserv_client (0)
{
  add_pin ("init", & init_pin);
  add_attribute ("init", & init_pin, "pin");
  add_pin ("deinit", & deinit_pin);
  add_attribute ("deinit", & deinit_pin, "pin");
  add_pin ("trap-code", & cpu_trap_code_pin);
  add_pin ("process-signal", & process_signal_pin);
  add_pin ("restart", & restart_pin);
  add_pin ("gloss-process-signal", & gloss_process_signal_pin);
  add_pin ("remote-rx", & remote_rx_pin);
  add_attribute ("remote-rx", & remote_rx_pin, "pin");
  add_pin ("remote-tx", & remote_tx_pin);
  add_attribute ("remote-tx", & remote_tx_pin, "pin");
  add_pin ("target-tx", & target_tx_pin);
  add_attribute ("target-tx", & target_tx_pin, "pin");
  add_pin ("trap", & cpu_trap_ipin, & cpu_trap_opin);
  add_pin ("yield", & yield_pin);
  add_attribute ("yield", & yield_pin, "pin");
  add_pin ("flush-icache", & icache_flush_pin);
  add_attribute ("flush-icache", & icache_flush_pin, "pin");
  add_pin ("stop-target", & stop_pin);
  add_attribute ("stop-target", & stop_pin, "pin");
  add_pin ("start-target", & start_pin);
  add_attribute ("start-target", & start_pin, "pin");

  // NB: We don't have to register the stoptrap_pin as an externally
  // visible input pin.
  // add_pin ("stop-target-trap", & stoptrap_pin);

  this->connected_p = false;
  add_attribute_ro ("connected?", & this->connected_p, "register");

  cpu = 0;
  gloss = 0;
  cfgroot = 0;
  add_uni_relation ("cfgroot", & cfgroot);
  add_uni_relation ("cpu", & cpu);
  add_uni_relation ("gloss", & gloss);
  add_multi_relation ("target-schedulers", & target_schedulers);
  add_multi_relation ("host-schedulers", & host_schedulers);

  // trace flags
  trace_gdbserv = false;
  trace_gdbsid = false;
  exit_on_detach = false;
  enable_Z_packet = true;
  force_Z_sw_to_hw = false;
  force_Z_hw_to_sw = false;
  fallback_Z_sw_to_hw = true;
  enable_E_packet = true;
  operating_mode_p = true;
  gdb_pc_mask = 0;
  step_range_start = 0;
  step_range_end = 0;

  add_attribute_notify ("trace-gdbserv?", & trace_gdbserv, 
			this, & gdb::update_trace_flags, "setting");
  add_attribute_notify ("trace-gdbsid?", & trace_gdbsid,
			this, & gdb::update_trace_flags, "setting");
  add_attribute ("exit-on-detach?", & exit_on_detach, "setting");
  add_attribute ("enable-Z-packet?", & enable_Z_packet, "setting");
  add_attribute ("force-Z-hw-to-sw?", & force_Z_sw_to_hw, "setting");
  add_attribute ("force-Z-sw-to-hw?", & force_Z_hw_to_sw, "setting");
  add_attribute ("fallback-Z-sw-to-hw?", & fallback_Z_sw_to_hw, "setting");
  add_attribute ("enable-E-packet?", & enable_E_packet, "setting");
  add_attribute ("operating-mode?", & operating_mode_p, "setting");
  add_attribute ("gdb-pc-mask", & gdb_pc_mask, "setting");
  add_attribute_alias ("Z-packet-pc-mask", "gdb-pc-mask"); // backward compat.
}



void
gdb::init_handler (host_int_4) 
{
  if (!cpu) 
    {
      cerr << "sid-gdb: no debug cpu specified." << endl;
      return;
    }

  // Initialize vectors representing the state of each host/target scheduler.
  for (unsigned i=0; i<target_schedulers.size(); i++)
    target_schedulers_enabled.push_back (true);
  for (unsigned j=0; j<host_schedulers.size(); j++)
    host_schedulers_host_time_yielded.push_back (false);

  // suspend down target system
  target_power (false);
}


void
gdb::deinit_handler (host_int_4) 
{
  // disconnect if needed
  if (this->connected_p)
    {
      // shut down target
      target_power (false);
      // signal gdb
      gdbserv_fromtarget_exit (gdbserv, 0);
      this->remote_rx_eof_handler ();
    }
}



void
gdb::update_trace_flags()
{
  gdbserv_state_trace = trace_gdbserv ? stderr : NULL;
} 


// Some sid-side component would like the target CPU to stop and hand
// control to the debugger.
void
gdb::stop_handler (host_int_4)
{
  if (trace_gdbsid)
    cerr << "stop_handler" << endl;

  // Turn off the range-stepping!
  this->step_range_start = 0;
  this->step_range_end = 0;

  // ignore if signal is pending
  if (this->pending_signal_counts [GDBSERV_SIGINT] > 0)
    {
      this->pending_signal_counts [GDBSERV_SIGINT] --;
      return;
    }

  // shut down target
  target_power (false);

  // attached?
  if (this->gdbserv == 0)
    {
      // XXX: Is this warning useful?
      cerr << "gdb: warning: stopping without attached debugger!" << endl;
    }
  else
    {
      // signal gdb
      last_signal = GDBSERV_SIGINT;
      gdbserv_fromtarget_break (gdbserv, last_signal);
    }
}


// The "target-stop-trap" pin was tickled, presumably because the CPU has
// hit an hardware breakpoint, emulated by a PC triggerpoint.
void
gdb::trapstop_handler (host_int_4)
{
  if (trace_gdbsid)
    cerr << "trapstop_handler" << endl;

  // ignore if signal is pending
  if (this->pending_signal_counts [GDBSERV_SIGTRAP] > 0)
    {
      this->pending_signal_counts [GDBSERV_SIGTRAP] --;
      return;
    }

  // Turn off the range-stepping!
  this->step_range_start = 0;
  this->step_range_end = 0;

  // shut down target
  target_power (false);

  // attached?
  if (this->gdbserv == 0)
    {
      // XXX: Is this warning useful?
      cerr << "gdb: warning: stopping without attached debugger!" << endl;
    }
  else
    {
      // signal gdb
      last_signal = GDBSERV_SIGTRAP;
      gdbserv_fromtarget_break (gdbserv, last_signal);
    }
}


// Some sid-side component would like the target CPU to start again.
// NB: This could upset an attached external debugger.
void
gdb::start_handler (host_int_4)
{
  if (trace_gdbsid)
    cerr << "start_handler" << endl;

  // resume target
  target_power (true);

  // attached?
  if (this->gdbserv != 0)
    {
      // We may already be halted, or running.  But there is no way to
      // inform gdb that we are about to resume running.
      cerr << "gdb: warning: starting without informing attached debugger!" << endl;
    }
}



// The GLOSS emulator is signalling that a process exit signal 
// is in process.
void
gdb::gloss_signal_handler (host_int_4 value)
{
  if (trace_gdbsid)
    cerr << "gloss_signal " << value << endl;

  // shut down target
  target_power (false);

  // detached?
  if (this->gdbserv == 0)
    {
      // forward signal
      this->process_signal_pin.drive (value);
    }
  else
    {
      // signal gdb
      last_signal = value & 0xff;
      gdbserv_fromtarget_exit (gdbserv, value >> 8);
    }
}


// The CPU is signalling that a trap of some sort is in progress.
void
gdb::cpu_trap_handler (host_int_4 trap_type) 
{
  if (trace_gdbsid)
    cerr << "cpu_trap_handler t=" << trap_type << endl;

  // Don't handle CPU traps in operating mode, except for:
  // - single-stepping
  if (this->operating_mode_p &&
      (trap_type != sidutil::cpu_trap_stepped))
    return;

  // Handle pending step-out-of-range packet
  if (trap_type == sidutil::cpu_trap_stepped &&
      this->step_range_end)
    {
      host_int_8 pc;
      string pcval = cpu->attribute_value ("gdb-register-pc");
      component::status s = parse_attribute (pcval, pc);
      if (s != component::ok)
	{
	  cerr << "cannot parse gdb-register-pc " << pcval << endl;
	}
      else
	{
	  // Handle disharvardization
	  if (this->gdb_pc_mask)
	    pc &= this->gdb_pc_mask;

	  // Note the [start, end) interpretation!
	  if (pc >= this->step_range_start && pc < this->step_range_end)
	    {
	      if (trace_gdbsid)
		cerr << "(pc=" << pc << " - resuming)" << endl;
	      this->cpu_trap_opin.drive (cpu_trap_handled);
	      return;
	    }

	  // Turn off the range-stepping!
	  this->step_range_start = 0;
	  this->step_range_end = 0;
	}
    }

  host_int_4 trapsig =
    trap_type == sidutil::cpu_trap_software ? GDBSERV_SIGTRAP :
    trap_type == sidutil::cpu_trap_breakpoint ? GDBSERV_SIGTRAP :
    trap_type == sidutil::cpu_trap_syscall ? GDBSERV_SIGTRAP :
    trap_type == sidutil::cpu_trap_invalid_insn ? GDBSERV_SIGILL :
    trap_type == sidutil::cpu_trap_memory_fault ? GDBSERV_SIGSEGV:
    trap_type == sidutil::cpu_trap_overflow ? GDBSERV_SIGFPE :
    trap_type == sidutil::cpu_trap_stepped ? GDBSERV_SIGTRAP :
    GDBSERV_SIGQUIT;

  // detached?
  if (this->gdbserv == 0)
    {
      // shut down target
      target_power (false);
      // forward signal
      this->process_signal_pin.drive (trap_type);
    }
  else 
    {
      // ignore if signal is pending
      if (this->pending_signal_counts [trapsig] > 0)
	{
	  this->pending_signal_counts [trapsig] --;
	  return;
	}

      // ack signal
      this->cpu_trap_opin.drive (cpu_trap_handled);
      // shut down target
      target_power (false);
      // signal gdb
      if (last_signal == GDBSERV_SIGNONE) 
	last_signal = trapsig;
      gdbserv_fromtarget_break (gdbserv, last_signal);
    }
}



// A 'standard output' character came in from the target.  Send it on
// to gdb via a "O" packet.  Each will pile up a pending '+' ACK in
// return ... gah.
void
gdb::target_tx_handler (host_int_4 value)
{
  // detached?
  if (this->gdbserv == 0)
    {
      ; // do nothing
    }
  else
    {
      gdbserv_output_discard (gdbserv);
      gdbserv_output_char (gdbserv, 'O');
      gdbserv_output_byte (gdbserv, ((int) value) & 0xFF);  
      gdbserv_output_packet (gdbserv);
      gdbserv_output_discard (gdbserv);
    }
}


void
gdb::configure (const string &config)
{
  // Call up to the base class first
  configurable_component::configure (config);

  // Now handle relevent configuration for us.
  if (config.size () <= 8)
    return;
  if (config.substr (0, 8) == "verbose=")
    {
      bool verbose_p = (config.substr (8) == "true");
      trace_gdbserv = verbose_p;
      trace_gdbsid = verbose_p;
      return;
    }
}


gdb::~gdb() throw()
{
  // Do nothing here; disconnection and gdbserv memory cleanup ought
  // to have occurred during deinit / detach earlier.
}



// ----------------------------------------------------------------------------

// Standard DLL wrapper-stuff

static vector<string>
gdb_list_types () 
{
  vector<string> types;
  types.push_back ("sw-debug-gdb");
  return types;
}

static component*
gdb_create (const string& name) 
{
  if (name == "sw-debug-gdb")
    return new gdb ();
  else
    return 0;
}

static void
gdb_delete (component* c) 
{
  delete dynamic_cast<gdb*>(c);
}

// static object
DLLEXPORT extern const component_library gdb_component_library;

const component_library gdb_component_library = {
  COMPONENT_LIBRARY_MAGIC,
  & gdb_list_types, 
  & gdb_create,
  & gdb_delete
};
@


1.17
log
@* DLLEXPORT decoration tweak, from Rex Sung-Tien Cho <song10@@andestech.com>
@
text
@d3 1
a3 1
// Copyright (C) 1999-2002, 2004, 2005 Red Hat.
d235 7
d288 1
d1340 17
@


1.16
log
@2005-11-14  Dave Brolley  <brolley@@redhat.com>

        * gdb.h (hw_watchpoints_t): New typedef in gdb.
        (hw_watchpoints): New member of gdb.
        (remove_all_hw_watchpoints, remove_hw_watchpoint): New methods
        of gdb.
        (add_hw_watchpoint): New method of gdb.
        * gdb.cxx (remove_breakpoint): Handle GDBSERV_TARGET_BP_WRITE.
        (set_breakpoint): Likewise.
        (remove_all_hw_watchpoints, remove_hw_watchpoint): New methods
        of gdb.
        (add_hw_watchpoint): New method of gdb.
        (process_detach): Call remove_all_hw_watchpoints.
@
text
@d1967 1
a1967 1
extern const component_library gdb_component_library;
d1969 1
a1969 1
const component_library gdb_component_library DLLEXPORT = {
@


1.15
log
@2005-08-19  Dave Brolley  <brolley@@redhat.com>

        * Contribute the following changes:

        2005-07-13  Dave Brolley  <brolley@@redhat.com>

        * gdb.h (configurable_component): Inherit virtually from
        fixed_attribute_map_component.

        2005-06-06  Dave Brolley  <brolley@@redhat.com>

        * gdb.cxx (configure): New virtual override in gdb.
        * gdb.h (configure): Likewise.
        (gdb): fixed_pin_map_component, fixed_relation_map_component and
        configurable_component inherited virtually.
        * sw-debug-gdb.xml: Add description of new interfaces.
        * sw-debug-gdb.txt: Regenerated.
@
text
@d1010 1
a1010 1
  bool ok = false;
d1014 1
a1014 1
    ok = this->remove_hw_breakpoint (watch_pc, bp_length);
d1017 3
a1019 1
    ok = this->remove_sw_breakpoint (watch_pc, bp_length);
d1022 1
a1022 1
  return ok ? 0 : -1;
d1151 58
d1228 2
a1229 1
  bool ok = false;
d1233 1
a1233 1
    ok = this->add_hw_breakpoint (watch_pc, bp_length);
d1236 4
a1239 2
    ok = this->add_sw_breakpoint (watch_pc, bp_length);
  // Fail on uses of other breakpoint types (WRITE, READ, ACCESS, UNKNOWN)
d1241 1
a1241 1
  return ok ? 0 : -1;
d1332 25
d1365 2
a1366 1
    this->remove_all_sw_breakpoints ();
@


1.14
log
@2004-08-11  Dave Brolley  <brolley@@redhat.com>

        * gdb.cxx (read_bus_word): Handle bus::misaligned. Return type now
        'void' again.
        (write_bus_word): Ditto.
        (process_get_mem): Don't handle bus::misaligned here.
        (process_set_mem): Ditto.
@
text
@d3 1
a3 1
// Copyright (C) 1999-2002, 2004 Red Hat.
d1823 18
@


1.13
log
@2004-07-01  Dave Brolley  <brolley@@redhat.com>

        * gdb.cxx (read_bus_word): Now returns bus::status. Return status
        from bus->read.
        (write_bus_word): Ditto for status from bus->write.
        (process_get_mem): Back out previous patch. Retry access
        one byte at a time if bus::misaligned is returned from downstream.
        (process_set_mem): Ditto.
@
text
@d535 1
a535 1
bus::status
d548 14
a561 2
  // misaligned will be handled by the caller
  else if (s != bus::misaligned)
a562 1
  return s;
d567 1
a567 1
bus::status
d588 13
a600 3
  if (s == bus::ok || s == bus::misaligned)
    ; // No response means "OK" -- misaligned will be handled by the caller
  else
a601 1
  return s;
a645 1
  bus::status b = bus::misaligned;
d647 1
a647 1
    b = read_bus_word (gdbserv, memory, addr, big_int_1());
d649 1
a649 1
    b = read_bus_word (gdbserv, memory, addr, little_int_1());
d651 1
a651 1
    b = read_bus_word (gdbserv, memory, addr, big_int_2());
d653 1
a653 1
    b = read_bus_word (gdbserv, memory, addr, little_int_2());
d655 1
a655 1
    b = read_bus_word (gdbserv, memory, addr, big_int_4());
d657 1
a657 1
    b = read_bus_word (gdbserv, memory, addr, little_int_4());
d659 1
a659 1
    b = read_bus_word (gdbserv, memory, addr, big_int_8());
d661 2
a662 7
    b = read_bus_word (gdbserv, memory, addr, little_int_8());

  if (b != bus::misaligned)
    return;
  
  // Unaligned access or unsupported size.
  if (e==endian_little)
a725 1
  bus::status b = bus::misaligned;
d727 16
a742 21
    b = write_bus_word (gdbserv, binary, memory, addr, big_int_1());
  if (len==1 && e==endian_little)
    b = write_bus_word (gdbserv, binary, memory, addr, little_int_1());
  if (len==2 && e==endian_big) 
    b = write_bus_word (gdbserv, binary, memory, addr, big_int_2());
  if (len==2 && e==endian_little)
    b = write_bus_word (gdbserv, binary, memory, addr, little_int_2());
  if (len==4 && e==endian_big) 
    b = write_bus_word (gdbserv, binary, memory, addr, big_int_4());
  if (len==4 && e==endian_little)
    b = write_bus_word (gdbserv, binary, memory, addr, little_int_4());
  if (len==8 && e==endian_big) 
    b = write_bus_word (gdbserv, binary, memory, addr, big_int_8());
  if (len==8 && e==endian_little)
    b = write_bus_word (gdbserv, binary, memory, addr, little_int_8());

  if (b != bus::misaligned)
    return;

  // Unaligned access or unsupported size.
  if (e==endian_little)
@


1.12
log
@2004-06-28  Dave Brolley  <brolley@@redhat.com>

        * gdb.cxx (process_get_mem): Use byte-at-a-time access for unaligned
        requests.
        (process_set_mem): Ditto.
@
text
@d535 1
a535 1
void 
d548 2
a549 1
  else
d551 1
d556 1
a556 1
void 
d577 2
a578 2
  if (s == bus::ok)
    ; // No response means "OK"
d581 1
d626 17
a642 19
  if (addr % len == 0)
    {
      if (len==1 && e==endian_big) 
	{ read_bus_word (gdbserv, memory, addr, big_int_1()); return; }
      if (len==1 && e==endian_little)
	{ read_bus_word (gdbserv, memory, addr, little_int_1()); return; }
      if (len==2 && e==endian_big) 
	{ read_bus_word (gdbserv, memory, addr, big_int_2()); return; }
      if (len==2 && e==endian_little)
	{ read_bus_word (gdbserv, memory, addr, little_int_2()); return; }
      if (len==4 && e==endian_big) 
	{ read_bus_word (gdbserv, memory, addr, big_int_4()); return; }
      if (len==4 && e==endian_little)
	{ read_bus_word (gdbserv, memory, addr, little_int_4()); return; }
      if (len==8 && e==endian_big) 
	{ read_bus_word (gdbserv, memory, addr, big_int_8()); return; }
      if (len==8 && e==endian_little)
	{ read_bus_word (gdbserv, memory, addr, little_int_8()); return; }
    }
d644 3
d712 20
a731 19
  if (addr % len == 0)
    {
      if (len==1 && e==endian_big) 
	{ write_bus_word (gdbserv, binary, memory, addr, big_int_1()); return; }
      if (len==1 && e==endian_little)
	{ write_bus_word (gdbserv, binary, memory, addr, little_int_1()); return; }
      if (len==2 && e==endian_big) 
	{ write_bus_word (gdbserv, binary, memory, addr, big_int_2()); return; }
      if (len==2 && e==endian_little)
	{ write_bus_word (gdbserv, binary, memory, addr, little_int_2()); return; }
      if (len==4 && e==endian_big) 
	{ write_bus_word (gdbserv, binary, memory, addr, big_int_4()); return; }
      if (len==4 && e==endian_little)
	{ write_bus_word (gdbserv, binary, memory, addr, little_int_4()); return; }
      if (len==8 && e==endian_big) 
	{ write_bus_word (gdbserv, binary, memory, addr, big_int_8()); return; }
      if (len==8 && e==endian_little)
	{ write_bus_word (gdbserv, binary, memory, addr, little_int_8()); return; }
    }
@


1.11
log
@2004-03-22  Dave Brolley  <brolley@@redhat.com>

        * gdb.cxx (deinit_handler): Call target_power and
        gdbserv_fromtarget_exit.
@
text
@d623 22
a644 17
  if (len==1 && e==endian_big) 
    read_bus_word (gdbserv, memory, addr, big_int_1());
  else if (len==1 && e==endian_little)
    read_bus_word (gdbserv, memory, addr, little_int_1());
  else if (len==2 && e==endian_big) 
    read_bus_word (gdbserv, memory, addr, big_int_2());
  else if (len==2 && e==endian_little)
    read_bus_word (gdbserv, memory, addr, little_int_2());
  else if (len==4 && e==endian_big) 
    read_bus_word (gdbserv, memory, addr, big_int_4());
  else if (len==4 && e==endian_little)
    read_bus_word (gdbserv, memory, addr, little_int_4());
  else if (len==8 && e==endian_big) 
    read_bus_word (gdbserv, memory, addr, big_int_8());
  else if (len==8 && e==endian_little)
    read_bus_word (gdbserv, memory, addr, little_int_8());
  else if (e==endian_little)
d708 22
a729 17
  if (len==1 && e==endian_big) 
    write_bus_word (gdbserv, binary, memory, addr, big_int_1());
  else if (len==1 && e==endian_little)
    write_bus_word (gdbserv, binary, memory, addr, little_int_1());
  else if (len==2 && e==endian_big) 
    write_bus_word (gdbserv, binary, memory, addr, big_int_2());
  else if (len==2 && e==endian_little)
    write_bus_word (gdbserv, binary, memory, addr, little_int_2());
  else if (len==4 && e==endian_big) 
    write_bus_word (gdbserv, binary, memory, addr, big_int_4());
  else if (len==4 && e==endian_little)
    write_bus_word (gdbserv, binary, memory, addr, little_int_4());
  else if (len==8 && e==endian_big) 
    write_bus_word (gdbserv, binary, memory, addr, big_int_8());
  else if (len==8 && e==endian_little)
    write_bus_word (gdbserv, binary, memory, addr, little_int_8());
  else if (e==endian_little)
@


1.10
log
@2002-05-07  Frank Ch. Eigler  <fche@@redhat.com>

	* gdb.cxx (add_sw_breakpoint, remove_sw_breakpoint): New functions
	for managing software breakpoints (Z0/z0 packets).
	(remove_all_hw_breakpoints): Ditto.
	(set_breakpoint, remove_breakpoints): Dispatch to them as appropriate.
	* gdb.h (force_Z_sw_to_hw, force_Z_hw_to_sw, fallback_Z_sw_to_hw):
	New parameters / attributes.
	(gdb_pc_mask): Renamed parameter from hw_breakpoint_pc_mask.
	* sw-debug-gdb.xml: Document new attributes.
	* sw-debug-gdb.txt: Regenerated.
@
text
@d3 1
a3 1
// Copyright (C) 1999-2002 Red Hat.
d1553 7
a1559 1
    this->remote_rx_eof_handler ();
@


1.9
log
@* step-out-of-range packet support

[sid/include]
2002-02-12  Frank Ch. Eigler  <fche@@redhat.com>

	* sidcpuutil.h (basic_cpu ctor): Add full gdb-register-pc attribute.
	(basic_cpu add_watchable_register): Associate watchable with raw
	Value*, not attribute string.

[sid/component/gdb]
2002-02-11  Frank Ch. Eigler  <fche@@redhat.com>

	* gdb.cxx (rangestep_program_hook, rangestep_program): New functions.
	(process_set_pc): Implement.
	(gdb ctor): Support new attribute "enable-E-packet?", default true.
	(cpu_trap_handler): When rangestepping, keep CPU going as needed.
	(exit_program, break_program, singlestep_program): Clear
	range-stepping variables.
	(continue_program, stop_handler, trapstop_handler): Ditto.
	* gdb.h: Corresponding changes.
	* gdbserv-state.c (gdbserv_data_packet): Implement support for
	'E'/'e' packets through new rangestep_program target hook.
	(gdbserv_fromtarget_break): Discard pending output packet.
	* gdbserv-state.h: Corresponding changes.
@
text
@d750 1
a750 1
  if (this->hw_breakpoint_pc_mask)
d752 1
a752 1
      pc &= this->hw_breakpoint_pc_mask;
d914 1
a914 1
  if (this->hw_breakpoint_pc_mask)
d916 2
a917 2
      this->step_range_start &= this->hw_breakpoint_pc_mask;
      this->step_range_end &= this->hw_breakpoint_pc_mask;
d971 6
d978 6
a983 1
    cerr << "remove_breakpoint type " << type << endl;
d985 1
d987 1
a987 1
  if (this->cpu == 0) return -1;
d989 7
a995 2
  host_int_8 watch_pc;
  gdbserv_reg_to_ulonglong (gdbserv, addr, &watch_pc);
a996 1
  bool ok = this->remove_hw_breakpoint (watch_pc);
d1018 1
a1018 1
      bool ok = this->remove_hw_breakpoint (address);
d1026 1
a1026 1
gdb::remove_hw_breakpoint (host_int_8 address)
d1035 1
a1035 1
  if (this->hw_breakpoint_pc_mask)
d1041 1
a1041 1
	make_numeric_attribute (this->hw_breakpoint_pc_mask) + string (":") +
d1065 61
d1129 6
d1136 7
a1142 1
    cerr << "set_breakpoint type " << type << endl;
a1143 1

d1145 1
d1147 7
a1153 2
  host_int_8 watch_pc;
  gdbserv_reg_to_ulonglong (gdbserv, addr, &watch_pc);
a1154 1
  bool ok = this->add_hw_breakpoint (watch_pc);
d1160 4
a1163 2
gdb::add_hw_breakpoint (host_int_8 address)
{  
d1165 1
a1165 1
  if (this->hw_breakpoint_pc_mask)
d1171 1
a1171 1
	make_numeric_attribute (this->hw_breakpoint_pc_mask) + string (":") +
a1183 1
  
d1195 50
d1252 3
a1254 1
  bool ok = this->remove_all_hw_breakpoints ();
d1257 1
a1257 1
      cerr << "sw-debug-gdb: cannot clean up hardware breakpoints" << endl;
d1502 3
d1507 1
a1507 1
  hw_breakpoint_pc_mask = 0;
d1517 3
d1522 2
a1523 1
  add_attribute ("Z-packet-pc-mask", & hw_breakpoint_pc_mask, "setting");
d1714 2
a1715 2
	  if (this->hw_breakpoint_pc_mask)
	    pc &= this->hw_breakpoint_pc_mask;
@


1.8
log
@2001-10-16  Dave Brolley  <brolley@@redhat.com>

	* gdb.h (target_schedulers_enabled): New vector member of class gdb.
	(host_schedulers_host_time_yielded): Ditto.
	* gdb.cxx (increment_attribute): New function.
	(target_power): Maintain internal vectors to track whether we have
	enabled the target scheduler and asked the host scheduler to yield host
	time. Increment/decrement the appropriate attribute of each scheduler
	instead of setting to 1 or 0.
	(init_handler): Initialize internal vectors representing the state of
	the host and target schedulers.
@
text
@d3 1
a3 1
// Copyright (C) 1999-2001 Red Hat.
d189 9
d278 1
d741 19
a759 1
    cerr << "process_set_pc" << endl;
d761 6
a766 1
  // XXX: why is this a stub?
d819 4
d843 4
d881 3
d890 43
d959 3
d1356 1
d1359 2
d1368 1
d1420 4
d1464 4
d1546 32
@


1.7
log
@* support "monitor set COMPONENT ATTRIBUTE VALUE" from gdb.
* part 1/2

2001-10-03  Frank Ch. Eigler  <fche@@redhat.com>

        * gdb.cxx (ctor): Add "cfgroot" relationship.
        (process_rcmd_hook, process_rcmd): Support "set" Rcmds.
        * gdb.h: Corresponding changes.
@
text
@d1043 27
d1083 4
a1086 1
  // Set/clear enabled? attribute of target schedulers
d1089 4
a1092 3
      assert(target_schedulers[i]);
      component::status s = target_schedulers[i]->set_attribute_value ("enabled?", (on ? "1" : "0"));
      if (s != component::ok)
d1094 2
a1095 1
	  cerr << "Cannot set enabled? attribute in scheduler: status " << (int) s << endl;
d1099 3
a1101 1
  // Set/clear yield-host-time? attribute of host schedulers
d1104 4
a1107 4
      assert(host_schedulers[j]);
      component::status s = host_schedulers[j]->set_attribute_value ("yield-host-time?",
							      (on ? "0" : "1"));
      if (s != component::ok)
d1109 2
a1110 1
	  cerr << "Cannot set yield? attribute in scheduler: status " << (int) s << endl;
d1289 7
a1295 1
  
@


1.6
log
@* make it compile with GCC 3.0:
        - missing throw() specifiers in bus & component dtors
	- `std::' vs `::' namespace issues
@
text
@d45 1
a45 1
process_get_gen_hook (struct gdbserv *gdbserv)
d48 1
a48 1
  return g->process_get_gen ();
d59 7
d227 2
d249 1
d300 27
d1219 2
@


1.5
log
@* gdb-interface extension

2001-07-30  Frank Ch. Eigler  <fche@@redhat.com>

	* gdb.h (gdb::hw_breakpoint_pc_mask): New member variable.
	* gdb.cxx (gdb ctor): Expose it as `Z-packet-pc-mask' attribute.
	(remove_hw_breakpoint, add_hw_breakpoint): Respect it.
@
text
@d344 3
d1428 1
a1428 1
gdb::~gdb()
@


1.4
log
@* trace tweak

2001-07-20  Frank Ch. Eigler  <fche@@redhat.com>

	* gdb.cxx (process_set_reg): Make optional trace more informative.
@
text
@d3 1
a3 1
// Copyright (C) 1999, 2000, 2001 Red Hat.
d888 19
a906 5
  string watcher_name = 
    string("watch:") + 
    map_watchable_name ("gdb-register-pc") +
    string(":value:") + 
    make_numeric_attribute (address);
d939 20
a958 5
  string watcher_name = 
    string("watch:") + 
    map_watchable_name ("gdb-register-pc") +
    string(":value:") + 
    make_numeric_attribute (address);
d1190 1
d1199 1
@


1.3
log
@	* gdb.cxx (gdb::gloss_signal_handler): Extract exit value from
	bits 8..15 of process exit signal.
@
text
@d351 1
a351 1
    cerr << "process_set_reg " << reg << endl;
d359 2
a360 2
      // if (trace_gdbsid)
      // cerr << "[" << hex << byte << "]" << dec << endl;
d365 3
@


1.2
log
@
2001-01-03  Jeff Johnston  <jjohnstn@@redhat.com>

        * gdb.cxx (restart_program): Added code to drive
        new "restart" output pin.
        * gdb.h (restart_pin): New output pin.
@
text
@d1309 2
a1310 2
      last_signal = value;  // XXX: is this an exit(value) rc?
      gdbserv_fromtarget_exit (gdbserv, last_signal);
@


1.1
log
@* public snapshot of sid simulator
@
text
@d3 1
a3 1
// Copyright (C) 1999, 2000 Red Hat.
d779 2
a780 1
  // XXX: what to do here?
d1120 1
@

