head	1.8;
access;
symbols
	sid-snapshot-20180601:1.8
	sid-snapshot-20180501:1.8
	sid-snapshot-20180401:1.8
	sid-snapshot-20180301:1.8
	sid-snapshot-20180201:1.8
	sid-snapshot-20180101:1.8
	sid-snapshot-20171201:1.8
	sid-snapshot-20171101:1.8
	sid-snapshot-20171001:1.8
	sid-snapshot-20170901:1.8
	sid-snapshot-20170801:1.8
	sid-snapshot-20170701:1.8
	sid-snapshot-20170601:1.8
	sid-snapshot-20170501:1.8
	sid-snapshot-20170401:1.8
	sid-snapshot-20170301:1.8
	sid-snapshot-20170201:1.8
	sid-snapshot-20170101:1.8
	sid-snapshot-20161201:1.8
	sid-snapshot-20161101:1.8
	sid-snapshot-20160901:1.8
	sid-snapshot-20160801:1.8
	sid-snapshot-20160701:1.8
	sid-snapshot-20160601:1.8
	sid-snapshot-20160501:1.8
	sid-snapshot-20160401:1.8
	sid-snapshot-20160301:1.8
	sid-snapshot-20160201:1.8
	sid-snapshot-20160101:1.8
	sid-snapshot-20151201:1.8
	sid-snapshot-20151101:1.8
	sid-snapshot-20151001:1.8
	sid-snapshot-20150901:1.8
	sid-snapshot-20150801:1.8
	sid-snapshot-20150701:1.8
	sid-snapshot-20150601:1.8
	sid-snapshot-20150501:1.8
	sid-snapshot-20150401:1.8
	sid-snapshot-20150301:1.8
	sid-snapshot-20150201:1.8
	sid-snapshot-20150101:1.8
	sid-snapshot-20141201:1.8
	sid-snapshot-20141101:1.8
	sid-snapshot-20141001:1.8
	sid-snapshot-20140901:1.8
	sid-snapshot-20140801:1.8
	sid-snapshot-20140701:1.8
	sid-snapshot-20140601:1.8
	sid-snapshot-20140501:1.8
	sid-snapshot-20140401:1.8
	sid-snapshot-20140301:1.8
	sid-snapshot-20140201:1.8
	sid-snapshot-20140101:1.8
	sid-snapshot-20131201:1.8
	sid-snapshot-20131101:1.8
	sid-snapshot-20131001:1.8
	sid-snapshot-20130901:1.8
	sid-snapshot-20130801:1.8
	sid-snapshot-20130701:1.8
	sid-snapshot-20130601:1.8
	sid-snapshot-20130501:1.8
	sid-snapshot-20130401:1.8
	sid-snapshot-20130301:1.8
	sid-snapshot-20130201:1.8
	sid-snapshot-20130101:1.8
	sid-snapshot-20121201:1.8
	sid-snapshot-20121101:1.8
	sid-snapshot-20121001:1.8
	sid-snapshot-20120901:1.8
	sid-snapshot-20120801:1.8
	sid-snapshot-20120701:1.8
	sid-snapshot-20120601:1.8
	sid-snapshot-20120501:1.8
	sid-snapshot-20120401:1.8
	sid-snapshot-20120301:1.8
	sid-snapshot-20120201:1.8
	sid-snapshot-20120101:1.8
	sid-snapshot-20111201:1.8
	sid-snapshot-20111101:1.8
	sid-snapshot-20111001:1.8
	sid-snapshot-20110901:1.8
	sid-snapshot-20110801:1.8
	sid-snapshot-20110701:1.8
	sid-snapshot-20110601:1.8
	sid-snapshot-20110501:1.8
	sid-snapshot-20110401:1.8
	sid-snapshot-20110301:1.8
	sid-snapshot-20110201:1.8
	sid-snapshot-20110101:1.8
	sid-snapshot-20101201:1.8
	sid-snapshot-20101101:1.8
	sid-snapshot-20101001:1.8
	sid-snapshot-20100901:1.8
	sid-snapshot-20100801:1.8
	sid-snapshot-20100701:1.8
	sid-snapshot-20100601:1.8
	sid-snapshot-20100501:1.8
	sid-snapshot-20100401:1.8
	sid-snapshot-20100301:1.8
	sid-snapshot-20100201:1.8
	sid-snapshot-20100101:1.8
	sid-snapshot-20091201:1.8
	sid-snapshot-20091101:1.8
	sid-snapshot-20091001:1.8
	sid-snapshot-20090901:1.8
	sid-snapshot-20090801:1.8
	sid-snapshot-20090701:1.8
	sid-snapshot-20090601:1.8
	sid-snapshot-20090501:1.8
	sid-snapshot-20090401:1.8
	sid-snapshot-20090301:1.8
	sid-snapshot-20090201:1.8
	sid-snapshot-20090101:1.8
	sid-snapshot-20081201:1.8
	sid-snapshot-20081101:1.8
	sid-snapshot-20081001:1.8
	sid-snapshot-20080901:1.8
	sid-snapshot-20080801:1.8
	sid-snapshot-20080701:1.8
	sid-snapshot-20080601:1.8
	sid-snapshot-20080501:1.8
	sid-snapshot-20080403:1.8
	sid-snapshot-20080401:1.8
	sid-snapshot-20080301:1.8
	sid-snapshot-20080201:1.8
	sid-snapshot-20080101:1.8
	sid-snapshot-20071201:1.8
	sid-snapshot-20071101:1.8
	sid-snapshot-20071001:1.8
	sid-20020905-branchpoint:1.8
	sid-20020905-branch:1.8.0.2
	cygnus_cvs_20020108_pre:1.6;
locks; strict;
comment	@# @;


1.8
date	2002.03.15.20.58.42;	author fche;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.12.18.03.26;	author fche;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.24.18.22.57;	author graydon;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.13.15.19.09;	author fche;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.21.13.20.11;	author bje;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.21.05.54.42;	author bje;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.20.07.18.37;	author bje;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.07.19.31.02;	author fche;	state Exp;
branches;
next	;


desc
@@


1.8
log
@* mapper bug fix, testsuite regression fixes

2002-03-15  Frank Ch. Eigler  <fche@@redhat.com>

        * compMapper.cxx (make_name_mapping): Tolerate bank-less suffix form.

2002-03-15  Frank Ch. Eigler  <fche@@redhat.com>

        * sidcomp.mapper/basicmapper.exp: Add several more specification-
        string test patterns.
@
text
@# -*- Tcl -*-
# basicmapper.exp
#
# Copyright (C) 1999, 2002 Red Hat
#
# Description:
# A testsuite for the generic mapper component (hw-mapper-basic).

set test "sid configuration"
sid_config_component_test_with_tracing "basicmapper.conf" \
	"load libmapper.la mapper_component_library" \
	"hw-mapper-basic"
pass $test

set test "sid startup"
if {[sid_start "basicmapper.conf"]} { pass $test } else { fail $test; return }


set test "all attributes are present"
sid_assert_includes_all "sid::component::attribute_names $victim" \
	{state-snapshot latency}


set test "access-port bus is present"
sid_assert_includes_all "sid::component::bus_names $victim" "access-port"


set test "acquire mapper bus handle"
set mbus [sid_cmd "sid::component::find_bus $victim access-port"]
if {$mbus != ""} { pass $test } else { fail $test }


set test "no known accessors at startup"
set accessors [sid_cmd "sid::component::accessor_names $victim"]
if {$accessors == ""} { pass $test } else { fail $test }


if {[info exists buses_array]} { unset buses_array }
foreach num {1 2 3 4} {
    set test "generate test bus #$num"
    set buses_array($num) [sid_cmd "sid::bus::new"]
    if {$buses_array($num) == ""} { fail $test } else { pass $test }
}


set test "connect test bus #1 to the mapper"
set accname {[0x100,0x200,1,1]}
set result [sid_cmd "sid::component::connect_accessor $victim [list $accname] $buses_array(1)"]
if {$result != "ok"} { fail "$test -- got $result" } else { pass $test }


set test "prior accessor is now registered"
set accname {[0x100,0x200,1,1]}
set accessors [sid_cmd "sid::component::accessor_names $victim"]
if {[string compare [lindex $accessors 0] $accname] == 0} { pass $test } else { fail "$test $accessors $accname" }


# Try out some bad accessor names.  They should be rejected as bad values.

foreach bad_accessor \
    {abc [foo] [bar [0,abc] [zog] [0-foo] [0--foo] [0x100-0x200,3,1] [0x100-0x200,1,3] [0x100]{a} [1-2]{} } {
	set test "connect an accessor with an invalid name: $bad_accessor"
	set result \
	    [sid_cmd "sid::component::connect_accessor $victim [list $bad_accessor] $buses_array(1)"]
	if {$result == "bad_value"} { pass $test } else { fail $test }
}


set test "only one accessor is still registered"
set accname {[0x100,0x200,1,1]}
set accessors [sid_cmd "sid::component::accessor_names $victim"]
if {[string compare [lindex $accessors 0] $accname] == 0} { pass $test } else { fail $test }

set test "connect test bus #2 to the mapper"
set accname {bar:[0x300-0x600,4,1]{0}}
set result [sid_cmd "sid::component::connect_accessor $victim [list $accname] $buses_array(2)"]
if {$result != "ok"} { fail "$test -- got $result" } else { pass $test }

set test "connect test bus #3 to the mapper"
set accname {foo:[8*0x300-0x600]:bar}
set result [sid_cmd "sid::component::connect_accessor $victim [list $accname] $buses_array(3)"]
if {$result != "ok"} { fail "$test -- got $result" } else { pass $test }

set test "connect test bus #4 to the mapper"
set accname {[1*0xff00-0xff01,4,1]{1,2,3,4}}
set result [sid_cmd "sid::component::connect_accessor $victim [list $accname] $buses_array(4)"]
if {$result != "ok"} { fail "$test -- got $result" } else { pass $test }


set test "four accessors are now registered"
set okay 1
set accessors [sid_cmd "sid::component::accessor_names $victim"]
set expected {[0x100,0x200,1,1] bar:[0x300-0x600,4,1]{0} foo:[8*0x300-0x600]:bar [1*0xff00-0xff01,4,1]{1,2,3,4}}

if {[llength $accessors] != 4} {
    fail $test
} else {
    for {set i 0} {$i < 4} {incr i} {
	if {[lindex $accessors $i] != [lindex $expected $i]} {
	    fail "$test -- expected [lindex $expected $i], got [lindex $accessors $i]"
	    set okay 0
	    break
	}
    }
    if {$okay} { pass $test }
}

set test "detect & reject overlapping address ranges"
set sca sid::component::connect_accessor
set r1 [sid_cmd [list $sca $victim \[0x300-0x600,4,1\] $buses_array(2)]]
set r2 [sid_cmd [list $sca $victim \[0x200-0x500,4,1\] $buses_array(2)]]
set r3 [sid_cmd [list $sca $victim \[0x400-0x500,4,1\] $buses_array(2)]]
set r4 [sid_cmd [list $sca $victim \[0x500-0x700,4,1\] $buses_array(2)]]
set r5 [sid_cmd [list $sca $victim \[0x200-0x700,4,1\] $buses_array(2)]]
set r6 [sid_cmd [list $sca $victim \[0x0-0xffff\] $buses_array(2)]]
if {"$r1$r2$r3$r4$r5$r6" == "bad_valuebad_valuebad_valuebad_valuebad_valuebad_value"} then { pass $test } else { fail $test }

set test "disconnect existing accessors--to start afresh"
set accessors [sid_cmd "sid::component::accessor_names $victim"]
set okay 1
for {set i 0} {$i < [llength $accessors]} {incr i} {
    set num [expr $i + 1]
    set acc [lindex $accessors $i]
    set bus [sid_cmd [list sid::component::connected_bus $victim $acc]]
    set result [sid_cmd [list sid::component::disconnect_accessor $victim $acc $bus]]
    if {$result != "ok"} { set okay 0; break }
}
if {$okay} { pass $test } else { fail $test }

# We need many, many mapped regions to test all widths and strides:
# For each transaction width below, we have a nominated starting location for the mapped
# regsions.  Then, for each stride, we have a 0x800 byte long region, 0x1000 bytes apart:
#
# +--- base
# |
# v 0            0x800   0x1000        0x1800  0x2000         0x2800  0x3000
# +---------------+-----+---------------+-----+----------------+-----+
# | stride1 regn  |.....| stride2 regn  |.....| stride4 regn   |.....|
# +---------------+-----+---------------+-----+----------------+-----+
#
# All of the mapped regions are tied to a simple bus object in Tcl.
# All widths, strides and byte orders are tested to ensure that the
# memory transaction is mapped to the right place.

set basetable(1) 0x1000
set basetable(2) 0x10000
set basetable(4) 0x20000
set basetable(8) 0x30000

# Set up all of the mapped regions described above.
# Do not create regions when the width is greater than the stride.
# It doesn't make sense (FIXME: so add a test case for it!)

set okay 1
unset acc
foreach width {1 2 4 8} {
    set test "establish many ${width}-byte wide accessors for testing"
    set base $basetable($width) 
    set offset 0
    for {set stride 1} {$stride <= 256} {set stride [expr $stride << 1]} {
	
	if {$width > $stride} continue
	
	set acc(start) [format %\#x [expr $base + $offset]]
	set acc(end) [format %\#x [expr $acc(start) + 0x800]]
	set offset [expr $offset + 0x1000]

	set accname "\[$acc(start)-$acc(end),$stride,$width\]"
	set result [sid_cmd "sid::component::connect_accessor $victim [list $accname] $buses_array(1)"]
	if {$result != "ok"} { set okay 0; break }
    }
    if {$okay} { pass $test } else { fail $test }
}
unset acc
unset offset

# Populate the hook_read(..) associative array.

sid_cmd "if {[info exists hook_written]} { unset hook_written }"
sid_cmd "if {[info exists hook_read]} { unset hook_read }"
foreach endian {l b} {
    foreach width {1 2 4 8} {
	sid_cmd "set hook_read(h4,${endian}${width},$buses_array(1)) {return {{ok 0} 0}}"
	sid_cmd "set hook_written(h4,${endian}${width},$buses_array(1)) {return {ok 0}}"
    }
}


# Now a simple walk test.  Within each mapped region, assert that all
# accesses are sent to their rightful locations on the device bus:
# (s => stride value)
#
# +--- 0   s      2s     3s     4s     5s     6s
# |        |      |      |      |      |      |    .. etc.
# v        v      v      v      v      v      v
# +-----------------------------------------------------+
# |XXX     |XXX   |XXX   |XXX   |XXX   |XXX   |         | mapper-bus
# +--------+------+------+------+------+------+---------+
#   |        /     /      /      /     /
#   |       /     /      /      /     /
#   V      V     V      V      V     V
# +-----+-----+-----+-----+-----+-----+
# | XXX | XXX | XXX | XXX | XXX | XXX | device-bus
# +-----+-----+-----+-----+-----+-----+

foreach width {1 2 4 8} {
    set offset 0
    set base $basetable($width)
    for {set stride 1} {$stride <= 256} {set stride [expr $stride << 1]} {
	
	if {$width > $stride} continue

	set test "simple walk along bus (aligned ${width}-byte reads/writes) with stride $stride"
	set okay 1
	set start_addr [format %\#x [expr $base + $offset]]
	set end_addr [format %\#x [expr $start_addr + 0x800]]
	set offset [expr $offset + 0x1000]
	
	# ensure that all register accesses are to adjacent indices.
	set expected_index 0
	for {set addr $start_addr} {$addr < $end_addr} {set addr [expr $addr + $stride]} {
	    # skip 75% of the exhaustive iterations
	    if {rand() < 0.25} then { set lb [list l b] } else { set lb [list] }
	    foreach endian $lb {
		set result [sid_cmd "sid::bus::write_h4_${endian}${width} $mbus $addr 0xFF"]
		if {![sid_bus_ok_p $result] || \
			[sid_cmd "set written_addr"] != $expected_index || \
			[string index [sid_cmd "set written_endian"] 0] != $endian || \
			[sid_cmd "set written_width"] != $width} {
		    set okay 0
		}
		
		set result [sid_cmd "sid::bus::read_h4_${endian}${width} $mbus $addr"]
		if {![sid_bus_ok_p $result] || \
			[sid_cmd "set read_addr"] != $expected_index || \
			[string index [sid_cmd "set read_endian"] 0] != $endian || \
			[sid_cmd "set read_width"] != $width} {
		    set okay 0
		}
	    }
	    
	    set expected_index [expr $expected_index + $width]
	}
	if {$okay} { pass $test } else { fail $test }
    }
}


# Test also the case where access width has to be adjusted 
# for accessor's declared width.
foreach width {1 2 4 8} {
    set offset 0
    set base $basetable($width)
    for {set stride 1} {$stride <= 256} {set stride [expr $stride << 1]} {
	
	if {$width > $stride} then { continue }

	set start_addr [format %\#x [expr $base + $offset]]
	set end_addr [format %\#x [expr $start_addr + 0x800]]
	set offset [expr $offset + 0x1000]

	foreach accwidth {1 2 4 8} {
	    set test "width-adjusted walk along bus (${accwidth}-byte reads/writes) with stride $stride width $width"
	    set okay 1

	    # ensure that all register accesses are to adjacent indices.
	    set expected_index 0
	    for {set addr $start_addr} {$addr < $end_addr} {set addr [expr $addr + $stride]} {
		set req "acc=$accwidth width=$width addr=$addr stride=$stride"

		if {($accwidth > $stride) || ($accwidth < $width) || (($addr % $stride) >= $width)} then { 
		    set expresult "misaligned" 
		} else {
		    set expresult "ok" 
		}

		# skip 95% of the exhaustive iterations
		if {rand() < 0.05} then { set lb [list l b] } else { set lb [list] }
		foreach endian $lb {
		    set result [sid_cmd "sid::bus::write_h4_${endian}${accwidth} $mbus $addr 0xFF"]
		    if {$expresult == "ok" || [lindex $result 0] != $expresult} {
			set desired [list $expected_index $endian $width]
			set actual [list \
					[sid_cmd "set written_addr"] \
					[string index [sid_cmd "set written_endian"] 0] \
					[sid_cmd "set written_width"]]
			if {$desired != $actual} then {
			    verbose "mismatch write: $desired vs $actual, $expresult vs $result, $req"
			    set okay 0
			}
		    }

		    set result [sid_cmd "sid::bus::read_h4_${endian}${accwidth} $mbus $addr"]
		    if {$expresult == "ok" || [lindex [lindex $result 0] 0] != $expresult} {
			set desired [list $expected_index $endian $width]
			set actual [list \
					[sid_cmd "set read_addr"] \
					[string index [sid_cmd "set read_endian"] 0] \
					[sid_cmd "set read_width"]]
			if {$desired != $actual} then {
			    verbose "mismatch read: $desired vs $actual, $expresult vs $result, $req"
			    set okay 0
			}
		    }
		}
		
		set expected_index [expr $expected_index + $width]
	    }

	    if {$okay} { pass $test } else { fail $test }
	}
    }
}





sid_cmd "if {[info exists hook_written]} { unset hook_written }"
sid_cmd "if {[info exists hook_read]} { unset hook_read }"


set  test "sid stop"
if {[sid_stop]} { pass $test } else { fail $test; return }

# zap conf file if tests were successful
global exit_status
if {$exit_status == "0"} { file delete "basicmapper.conf" }
@


1.7
log
@* mapper banking support

2002-03-11  Frank Ch. Eigler  <fche@@redhat.com>

        * compMapper.cxx (overlaps_p, selected_p, bank_changed): New/modified
        helper functions for banking.
        (bank_pin_handler, connect_accessor, disconnect_accessor): Ditto.
        (locate): Ditto.
        (make_name_mapping): Ditto; reorganize, tighten.  Change syntax of
        word-multiplier construct.
        (generic_mapper): Add new fields for bank tracking.
        * hw-mapper-basic.xml: Document banking system and syntax.
        * hw-mapper-basic.txt: Regenerated.
@
text
@d61 1
a61 1
    {abc [foo] [bar [0,abc] [zog] [0-foo] [0--foo] [0x100-0x200,3,1] [0x100-0x200,1,3]} {
d75 1
a75 1
set accname {[0x300-0x600,4,1]}
d80 1
a80 1
set accname {[8*0x300-0x600]}
d85 1
a85 1
set accname {[1*0xff00-0xff01,4,1]}
d93 1
a93 1
set expected {[0x100,0x200,1,1] [0x300-0x600,4,1] [8*0x300-0x600] [1*0xff00-0xff01,4,1]}
@


1.6
log
@[sid/component/mapper]
2001-07-23  graydon hoare  <graydon@@redhat.com>

	* compMapper.cxx (make_name_mapping): Support mapping
	names with word size included as constant multiplier.

[sid/component/testsuite]
2001-07-23  graydon hoare  <graydon@@redhat.com>

	* sidcomp.mapper/basicmapper.exp: Add tests for mapping
	with word size specified in accessor name.
@
text
@d4 1
a4 1
# Copyright (C) 1999 Red Hat
d80 1
a80 1
set accname {[0x300-0x600,8]}
d85 1
a85 1
set accname {[0xff00-0xff01,4,1,4]}
d90 1
a90 1
set test "three accessors are now registered"
d93 1
a93 1
set expected {[0x100,0x200,1,1] [0x300-0x600,4,1] [0x300-0x600,8] [0xff00-0xff01,4,1,4]}
@


1.5
log
@* test suite cleanup

2001-07-13  Frank Ch. Eigler  <fche@@redhat.com>

	* config/default.exp: Stop using [sid_find_file] for component libs.
	Forget about mksid.
	* sidcomp.*/*.exp: Stop using [sid_find_file] to find component
	shared libraries for "load" cmds in sid configuration files.
@
text
@d39 1
a39 1
foreach num {1 2} {
a73 1

d79 10
d90 1
a90 1
set test "two accessors are now registered"
d93 1
a93 1
set expected {[0x100,0x200,1,1] [0x300-0x600,4,1]}
d95 1
a95 1
if {[llength $accessors] != 2} {
d98 1
a98 1
    for {set i 0} {$i < 2} {incr i} {
@


1.4
log
@2001-06-21  Ben Elliston  <bje@@redhat.com>

	* sidcomp.mapper/basicmapper.exp: Test for the existence of a
	"latency" attribute.
	* sidcomp.memory/genericmemory.exp: Test for the existence of
	"read-latency" and "write-latency" attributes.
@
text
@d11 1
a11 1
	"load [sid_find_file libmapper.la] mapper_component_library" \
@


1.3
log
@2001-06-21  Ben Elliston  <bje@@redhat.com>

	* sidcomp.cache/utils.exp: Use sid_bus_ok_p to detect bus write
	errors instead of the common construction: if {$result == "ok"}.
	* sidcomp.ide/diskio.exp: Likewise.
	* sidcomp.lcd/lcdbase.exp: Likewise.
	* sidcomp.mapper/basicmapper.exp: Likewise.
	* sidcomp.memory/am29.exp: Likewise.
	* sidcomp.memory/at29.exp: Likewise.
	* sidcomp.memory/at29val.exp: Likewise.
	* sidcomp.memory/genericmemory.exp: Likewise.
	* sidcomp.mmu/arm-remap.exp: Likewise.
	* sidcomp.rtc/ds1642.exp: Likewise.
	* sidcomp.rtc/ds1742.exp: Likewise.
	* sidcomp.timers/timerbase.exp: Likewise.
@
text
@d21 1
a21 1
	{"state-snapshot"}
@


1.2
log
@2001-06-20  Ben Elliston  <bje@@redhat.com>

	* sidcomp.cache/coherency.exp: Use sid_bus_ok_p to detect bus read
	errors instead of the frequently used (and less readable)
	construction: if {[lindex $result] 0 == "ok"}.
	* sidcomp.cache/writealloc.exp: Likewise.
	* sidcomp.cache/writethru.exp: Likewise.
	* sidcomp.gloss/angel.exp: Likewise.
	* sidcomp.ide/diskio.exp: Likewise.
	* sidcomp.interrupt/arm-interrupt.exp: Likewise.
	* sidcomp.interrupt/cma222-interrupt.exp: Likewise.
	* sidcomp.lcd/lcdbase.exp: Likewise.
	* sidcomp.mapper/basicmapper.exp: Likewise.
	* sidcomp.memory/am29.exp: Likewise.
	* sidcomp.memory/at29.exp: Likewise.
	* sidcomp.memory/at29val.exp: Likewise.
	* sidcomp.memory/genericmemory.exp: Likewise.
	* sidcomp.mmu/arm-remap.exp: Likewise.
	* sidcomp.parport/parport.exp: Likewise.
	* sidcomp.rtc/ds1642.exp: Likewise.
	* sidcomp.rtc/ds1742.exp: Likewise.
	* sidcomp.timers/timerbase.exp: Likewise.
	* sidcomp.timers/timersched.exp: Likewise.
@
text
@d174 2
a175 2
	sid_cmd "set hook_read(h4,${endian}${width},$buses_array(1)) {return {ok 0}}"
	sid_cmd "set hook_written(h4,${endian}${width},$buses_array(1)) {return ok}"
d217 1
a217 1
		if {$result != "ok" || \
d272 1
a272 1
		    if {$expresult == "ok" || $result != $expresult} {
d285 1
a285 1
		    if {$expresult == "ok" || [lindex $result 0] != $expresult} {
@


1.1
log
@* public snapshot of sid simulator
@
text
@d225 1
a225 1
		if {[lindex $result 0] != "ok" || \
@

