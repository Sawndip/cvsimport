head	1.6;
access;
symbols
	sid-snapshot-20180601:1.6
	sid-snapshot-20180501:1.6
	sid-snapshot-20180401:1.6
	sid-snapshot-20180301:1.6
	sid-snapshot-20180201:1.6
	sid-snapshot-20180101:1.6
	sid-snapshot-20171201:1.6
	sid-snapshot-20171101:1.6
	sid-snapshot-20171001:1.6
	sid-snapshot-20170901:1.6
	sid-snapshot-20170801:1.6
	sid-snapshot-20170701:1.6
	sid-snapshot-20170601:1.6
	sid-snapshot-20170501:1.6
	sid-snapshot-20170401:1.6
	sid-snapshot-20170301:1.6
	sid-snapshot-20170201:1.6
	sid-snapshot-20170101:1.6
	sid-snapshot-20161201:1.6
	sid-snapshot-20161101:1.6
	sid-snapshot-20160901:1.6
	sid-snapshot-20160801:1.6
	sid-snapshot-20160701:1.6
	sid-snapshot-20160601:1.6
	sid-snapshot-20160501:1.6
	sid-snapshot-20160401:1.6
	sid-snapshot-20160301:1.6
	sid-snapshot-20160201:1.6
	sid-snapshot-20160101:1.6
	sid-snapshot-20151201:1.6
	sid-snapshot-20151101:1.6
	sid-snapshot-20151001:1.6
	sid-snapshot-20150901:1.6
	sid-snapshot-20150801:1.6
	sid-snapshot-20150701:1.6
	sid-snapshot-20150601:1.6
	sid-snapshot-20150501:1.6
	sid-snapshot-20150401:1.6
	sid-snapshot-20150301:1.6
	sid-snapshot-20150201:1.6
	sid-snapshot-20150101:1.6
	sid-snapshot-20141201:1.6
	sid-snapshot-20141101:1.6
	sid-snapshot-20141001:1.6
	sid-snapshot-20140901:1.6
	sid-snapshot-20140801:1.6
	sid-snapshot-20140701:1.6
	sid-snapshot-20140601:1.6
	sid-snapshot-20140501:1.6
	sid-snapshot-20140401:1.6
	sid-snapshot-20140301:1.6
	sid-snapshot-20140201:1.6
	sid-snapshot-20140101:1.6
	sid-snapshot-20131201:1.6
	sid-snapshot-20131101:1.6
	sid-snapshot-20131001:1.6
	sid-snapshot-20130901:1.6
	sid-snapshot-20130801:1.6
	sid-snapshot-20130701:1.6
	sid-snapshot-20130601:1.6
	sid-snapshot-20130501:1.6
	sid-snapshot-20130401:1.6
	sid-snapshot-20130301:1.6
	sid-snapshot-20130201:1.6
	sid-snapshot-20130101:1.6
	sid-snapshot-20121201:1.6
	sid-snapshot-20121101:1.6
	sid-snapshot-20121001:1.6
	sid-snapshot-20120901:1.6
	sid-snapshot-20120801:1.6
	sid-snapshot-20120701:1.6
	sid-snapshot-20120601:1.6
	sid-snapshot-20120501:1.6
	sid-snapshot-20120401:1.6
	sid-snapshot-20120301:1.6
	sid-snapshot-20120201:1.6
	sid-snapshot-20120101:1.6
	sid-snapshot-20111201:1.6
	sid-snapshot-20111101:1.6
	sid-snapshot-20111001:1.6
	sid-snapshot-20110901:1.6
	sid-snapshot-20110801:1.6
	sid-snapshot-20110701:1.6
	sid-snapshot-20110601:1.6
	sid-snapshot-20110501:1.6
	sid-snapshot-20110401:1.6
	sid-snapshot-20110301:1.6
	sid-snapshot-20110201:1.6
	sid-snapshot-20110101:1.6
	sid-snapshot-20101201:1.6
	sid-snapshot-20101101:1.6
	sid-snapshot-20101001:1.6
	sid-snapshot-20100901:1.6
	sid-snapshot-20100801:1.6
	sid-snapshot-20100701:1.6
	sid-snapshot-20100601:1.6
	sid-snapshot-20100501:1.6
	sid-snapshot-20100401:1.6
	sid-snapshot-20100301:1.6
	sid-snapshot-20100201:1.6
	sid-snapshot-20100101:1.6
	sid-snapshot-20091201:1.6
	sid-snapshot-20091101:1.6
	sid-snapshot-20091001:1.6
	sid-snapshot-20090901:1.6
	sid-snapshot-20090801:1.6
	sid-snapshot-20090701:1.6
	sid-snapshot-20090601:1.6
	sid-snapshot-20090501:1.6
	sid-snapshot-20090401:1.6
	sid-snapshot-20090301:1.6
	sid-snapshot-20090201:1.6
	sid-snapshot-20090101:1.6
	sid-snapshot-20081201:1.6
	sid-snapshot-20081101:1.6
	sid-snapshot-20081001:1.6
	sid-snapshot-20080901:1.6
	sid-snapshot-20080801:1.6
	sid-snapshot-20080701:1.6
	sid-snapshot-20080601:1.6
	sid-snapshot-20080501:1.6
	sid-snapshot-20080403:1.6
	sid-snapshot-20080401:1.6
	sid-snapshot-20080301:1.6
	sid-snapshot-20080201:1.6
	sid-snapshot-20080101:1.6
	sid-snapshot-20071201:1.6
	sid-snapshot-20071101:1.6
	sid-snapshot-20071001:1.6
	sid-20020905-branchpoint:1.6
	sid-20020905-branch:1.6.0.2
	cygnus_cvs_20020108_pre:1.6;
locks; strict;
comment	@# @;


1.6
date	2001.07.13.15.19.09;	author fche;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.21.13.20.12;	author bje;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.21.05.54.42;	author bje;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.20.07.18.40;	author bje;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.13.21.39.21;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.07.19.31.03;	author fche;	state Exp;
branches;
next	;


desc
@@


1.6
log
@* test suite cleanup

2001-07-13  Frank Ch. Eigler  <fche@@redhat.com>

	* config/default.exp: Stop using [sid_find_file] for component libs.
	Forget about mksid.
	* sidcomp.*/*.exp: Stop using [sid_find_file] to find component
	shared libraries for "load" cmds in sid configuration files.
@
text
@set test "sid configuration"
sid_config_component_test "base.conf" \
    "load libmemory.la mem_component_library" \
    "hw-memory-ram/rom-basic"
pass $test


set test "sid startup"
if [sid_start "base.conf"] then { pass $test } else { fail $test ; return }

set test "attribute list"
sid_assert_includes_all "sid::component::attribute_names $victim" \
	"size state-snapshot read-latency write-latency"

set test "set size = 512"
sid_assert_success "sid::component::set_attribute_value $victim size 0x200"

set test "get buses"
set robus [sid_cmd "sid::component::find_bus $victim read-only-port"]
set rwbus [sid_cmd "sid::component::find_bus $victim read-write-port"]
if {$robus == "" || $rwbus == ""} then { fail $test } else { pass $test }

set test "fill memory with junk bytes"
set data 4
set size [sid_cmd "sid::component::attribute_value $victim size"]
for {set addr 0} {$addr < $size} {incr addr} {
# some pseudorandom sequence
    set data [expr {(($data * 17) + 23) % 256}]
    set result [sid_cmd "sid::bus::write_h4_l1 $rwbus $addr $data"]
    if ![sid_bus_ok_p $result] then { fail $test; break }
}
if {$addr == $size} then { pass $test } else { fail $test }

set test "read junk from memory via read-only port"
set data 4
set size [sid_cmd "sid::component::attribute_value $victim size"]
for {set addr 0} {$addr < $size} {incr addr} {
# same pseudorandom sequence as above
    set data [expr {(($data * 17) + 23) % 256}]
    set result [sid_cmd "sid::bus::read_h4_l1 $robus $addr"]
    if ![sid_bus_ok_p $result] then { fail "$test (bus error)" ; break }
    set result_data [lindex $result 1]
    if {$result_data != $data} then {fail "$test - mismatch @@ $addr - $result_data vs $data" ; break}
}
if {$addr == $size} then { pass $test } else { fail $test }

set test "get memory state dump"
set state [sid_cmd "sid::component::attribute_value $victim state-snapshot"]
if {$state != ""} then { pass $test } else { fail $test }

set test "reset memory size"
sid_assert_success "sid::component::set_attribute_value $victim size 234000"

set test "spot check clear memory"
set result0 [sid_cmd "sid::bus::read_h4_l1 $rwbus 0x0"]
set result1 [sid_cmd "sid::bus::read_h4_l1 $rwbus 0x2F4D"]
set result2 [sid_cmd "sid::bus::read_h4_l1 $rwbus 0x39BA"]
if {$result0 != "{ok 0} 0" || $result1 != "{ok 0} 0" || $result2 != "{ok 0} 0"} then { fail $test } else { pass $test }

set test "set memory state dump"
#set t $timeout ; set timeout 30
set ok [sid_cmd "sid::component::set_attribute_value $victim state-snapshot [list $state]"]
#set timeout $t
if {$ok == "ok"} then { pass $test } else { fail $test }

set test "check memory size after restore"
set new_size [sid_cmd "sid::component::attribute_value $victim size"]
if {$size == $new_size} then { pass $test } else { fail $test }

set test "reread junk from memory after restore"
set data 4
set size [sid_cmd "sid::component::attribute_value $victim size"]
for {set addr 0} {$addr < $size} {incr addr} {
# same pseudorandom sequence as above
    set data [expr {(($data * 17) + 23) % 256}]
    set result [sid_cmd "sid::bus::read_h4_l1 $robus $addr"]
    if ![sid_bus_ok_p $result] then { fail "$test (bus error)" ; break }
    set result_data [lindex $result 1]
    if {$result_data != $data} then {fail "$test - mismatch @@ $addr - $result_data vs $data" ; break}
}
if {$addr == $size} then { pass $test } else { fail $test }

set test "test for memory leaks"
set iterations 100
for {set i 0} {$i < $iterations} {incr i} {
# some size between 1 .. 16 MB
    set size [expr {1000000 + (($i * 101) % 16) * 1000000}]
    sid_cmd "sid::component::set_attribute_value $victim size $size"
}
sid_assert_success "sid::component::set_attribute_value $victim size 0"

set test "resize memory for file test"  
sid_assert_success "sid::component::set_attribute_value $victim size 7234"

set test "read memory image from a file"
set file [open "test.dat" "w"]
fconfigure $file -translation binary
set data 0
set size [sid_cmd "sid::component::attribute_value $victim size"]
for {set i 0} {$i < $size} {incr i} {
    set data [expr {(($data * 19) + 13) % 256}]
    puts -nonewline $file [binary format "c" $data]
}
close $file
set res [sid_cmd "sid::component::set_attribute_value $victim image-file test.dat"]
set pin [sid_cmd "sid::component::find_pin $victim image-load"]
sid_cmd "sid::pin::driven_h4 $pin 0"
file delete -force $file
if {$res == "ok" && $pin != ""} then { pass $test } else { fail $test }

set test "verify read memory image"
set data 0
set size [sid_cmd "sid::component::attribute_value $victim size"]
for {set i 0} {$i < $size} {incr i} {
    set data [expr {(($data * 19) + 13) % 256}]
    set result [sid_cmd "sid::bus::read_h4_l1 $robus $i"]
    if ![sid_bus_ok_p $result] then { fail "$test (bus error)" ; break }
    set result_data [lindex $result 1]
    if {$result_data != $data} then {fail "$test - mismatch @@ $i - $result_data vs $data" ; break}
}
if {$i == $size} then { pass $test } else { fail $test }

set test "make a big memory buffer"
set size 10000
sid_assert_success "sid::component::set_attribute_value $victim size $size"

set test "fill it sparsely"
set data 0
set sparse 10
for {set i 0} {$i < $sparse} {incr i} {
    set data [expr {(($data * 19) + 13) % $size}]
    set addr $data
    set result [sid_cmd "sid::bus::write_h4_l1 $rwbus $addr 0xFE"]
    if ![sid_bus_ok_p $result] then { fail $test ; break }
}
if {$i == $sparse} then { pass $test } else { fail $test }

set test "take sparse (RLE) snapshot"
set state [sid_cmd "sid::component::attribute_value $victim state-snapshot"]
if {[string length $state] < 10 || [string length $state] > 5000} then { fail $test } else { pass $test }

set test "clear memory"
set result [sid_cmd "sid::component::set_attribute_value $victim size 0"]
if {$result == "ok"} then { pass $test } else { fail $test }

set test "reload sparse (RLE) snapshot"
set result [sid_cmd "sid::component::set_attribute_value $victim state-snapshot [list $state]"]
if {$result == "ok"} then { pass $test } else { fail $test }

set test "load junk snapshot"
set result [sid_cmd "sid::component::set_attribute_value $victim state-snapshot bad-crap-bad-crap"]
if {$result == "bad_value"} then { pass $test } else { fail $test }

set test "save & restore large memory snapshot"
set o1 [sid_cmd "sid::component::set_attribute_value $victim size 800000"]
set state [sid_cmd "sid::component::attribute_value $victim state-snapshot"]
set o2 [sid_cmd "sid::component::set_attribute_value $victim state-snapshot [list $state]"]
if {$state != "" && $o1 == "ok" && $o2 == "ok"} then { pass $test } else { fail "$test - $o1 $o2" }

set size 8192
set test "reset memory size to $size"
set result [sid_cmd "sid::component::set_attribute_value $victim size $size"]
if {$result == "ok"} then {pass $test} else {fail $test}

set test "map memory image from a file"
set file [open "test.dat" "w"]
fconfigure $file -translation binary
set data 0
for {set i 0} {$i < $size} {incr i} {
    set data [expr {(($data * 17) + 19) % 256}]
    puts -nonewline $file [binary format "c" $data]
}
close $file
file copy -force "test.dat" "test.dat.orig"
set res [sid_cmd "sid::component::set_attribute_value $victim image-file test.dat"]
set pin [sid_cmd "sid::component::find_pin $victim image-mmap"]
sid_cmd "sid::pin::driven_h4 $pin 0"
if {$res == "ok" && $pin != ""} then { pass $test } else { fail $test }

set test "verify mmap memory image via read"
set data 0
set size [sid_cmd "sid::component::attribute_value $victim size"]
for {set i 0} {$i < $size} {incr i} {
    set data [expr {(($data * 17) + 19) % 256}]
    set result [sid_cmd "sid::bus::read_h4_l1 $robus $i"]
    if ![sid_bus_ok_p $result] then { fail "$test (bus error $ @@i)" ; break }
    set result_data [lindex $result 1]
    if {$result_data != $data} then {fail "$test - mismatch @@ $i - $result_data vs $data" ; break}
}
if {$i == $size} then { pass $test } else { fail $test }

set test "modify mmap memory image"
set data 0
set size [sid_cmd "sid::component::attribute_value $victim size"]
for {set i 0} {$i < $size} {incr i} {
    set data [expr {(($data * 13) + 29) % 256}]
    set result [sid_cmd "sid::bus::write_h4_l1 $rwbus $i $data"]
    if ![sid_bus_ok_p $result] {fail "$test - $result @@ $i" ; break}
    set result [sid_cmd "sid::bus::read_h4_l1 $rwbus $i"]
    if {![sid_bus_ok_p $result] || [lindex $result 1] != $data} then {
	fail "$test - mismatch @@ $i - $result vs $data" ; break }
}
if {$i == $size} then { pass $test } else { fail $test }

set test "write out memory image"
set res [sid_cmd "sid::component::set_attribute_value $victim image-file \"test.dat.save\""]
set pin [sid_cmd "sid::component::find_pin $victim image-store"]
sid_cmd "sid::pin::driven_h4 $pin 0"
if {$res == "ok" && $pin != ""} then { pass $test } else { fail $test }

set test "check written memory image"
set file [open "test.dat.save" "r"]
fconfigure $file -translation binary
set data 0
set size [sid_cmd "sid::component::attribute_value $victim size"]
for {set i 0} {$i < $size} {incr i} {
    set data [expr {(($data * 13) + 29) % 256}]
    binary scan [read $file 1] "c" result_data
    set result_data [expr {$result_data + 256} & 255]
    if {$result_data != $data} then {fail "$test - mismatch @@ $i - $result_data vs $data" ; break}
}
close $file
if {$i == $size} then { pass $test } else { fail $test }

set test "msync memory"
set pin [sid_cmd "sid::component::find_pin $victim image-msync"]
sid_cmd "sid::pin::driven_h4 $pin 0"
file copy -force "test.dat" "test.dat.msync"
if {$pin != ""} then { pass $test } else { fail $test }

set test "check msync'd memory image"
set file [open "test.dat.msync" "r"]
fconfigure $file -translation binary
set data 0
set size [sid_cmd "sid::component::attribute_value $victim size"]
for {set i 0} {$i < $size} {incr i} {
    set data [expr {(($data * 13) + 29) % 256}]
    binary scan [read $file 1] "c" result_data
    set result_data [expr {$result_data + 256} & 255]
    if {$result_data != $data} then {fail "$test - mismatch @@ $i - $result_data vs $data" ; break}
}
close $file
if {$i == $size} then { pass $test } else { fail $test }


set test "sid stop"
if [sid_stop] then { pass $test } else { fail $test ; return }


# zap temp file if tests were successful 
global exit_status
if {$exit_status == "0"} then { file delete "base.conf" }
@


1.5
log
@2001-06-21  Ben Elliston  <bje@@redhat.com>

	* sidcomp.mapper/basicmapper.exp: Test for the existence of a
	"latency" attribute.
	* sidcomp.memory/genericmemory.exp: Test for the existence of
	"read-latency" and "write-latency" attributes.
@
text
@d3 1
a3 1
    "load [sid_find_file libmemory.la] mem_component_library" \
@


1.4
log
@2001-06-21  Ben Elliston  <bje@@redhat.com>

	* sidcomp.cache/utils.exp: Use sid_bus_ok_p to detect bus write
	errors instead of the common construction: if {$result == "ok"}.
	* sidcomp.ide/diskio.exp: Likewise.
	* sidcomp.lcd/lcdbase.exp: Likewise.
	* sidcomp.mapper/basicmapper.exp: Likewise.
	* sidcomp.memory/am29.exp: Likewise.
	* sidcomp.memory/at29.exp: Likewise.
	* sidcomp.memory/at29val.exp: Likewise.
	* sidcomp.memory/genericmemory.exp: Likewise.
	* sidcomp.mmu/arm-remap.exp: Likewise.
	* sidcomp.rtc/ds1642.exp: Likewise.
	* sidcomp.rtc/ds1742.exp: Likewise.
	* sidcomp.timers/timerbase.exp: Likewise.
@
text
@d12 2
a13 1
sid_assert_includes_all "sid::component::attribute_names $victim" "size state-snapshot"
@


1.3
log
@2001-06-20  Ben Elliston  <bje@@redhat.com>

	* sidcomp.cache/coherency.exp: Use sid_bus_ok_p to detect bus read
	errors instead of the frequently used (and less readable)
	construction: if {[lindex $result] 0 == "ok"}.
	* sidcomp.cache/writealloc.exp: Likewise.
	* sidcomp.cache/writethru.exp: Likewise.
	* sidcomp.gloss/angel.exp: Likewise.
	* sidcomp.ide/diskio.exp: Likewise.
	* sidcomp.interrupt/arm-interrupt.exp: Likewise.
	* sidcomp.interrupt/cma222-interrupt.exp: Likewise.
	* sidcomp.lcd/lcdbase.exp: Likewise.
	* sidcomp.mapper/basicmapper.exp: Likewise.
	* sidcomp.memory/am29.exp: Likewise.
	* sidcomp.memory/at29.exp: Likewise.
	* sidcomp.memory/at29val.exp: Likewise.
	* sidcomp.memory/genericmemory.exp: Likewise.
	* sidcomp.mmu/arm-remap.exp: Likewise.
	* sidcomp.parport/parport.exp: Likewise.
	* sidcomp.rtc/ds1642.exp: Likewise.
	* sidcomp.rtc/ds1742.exp: Likewise.
	* sidcomp.timers/timerbase.exp: Likewise.
	* sidcomp.timers/timersched.exp: Likewise.
@
text
@d29 1
a29 1
    if {$result != "ok"} then { fail $test ; break }
d57 1
a57 1
if {$result0 != "ok 0" || $result1 != "ok 0" || $result2 != "ok 0"} then { fail $test } else { pass $test }
d133 1
a133 1
    if {$result != "ok"} then { fail $test ; break }
d197 1
a197 1
    if {$result != "ok"} then {fail "$test - $result @@ $i" ; break}
@


1.2
log
@* mmap support

[bsp/ChangeLog]
2001-03-13  Frank Ch. Eigler  <fche@@redhat.com>

        * configrun-sid.in: Add "mmap" memory region option.
        Document it and others in "--help" text.

[component/memory/ChangeLog]
2001-03-13  Frank Ch. Eigler  <fche@@redhat.com>

        Adding support for memory-mapped files and pin-based error signalling.
        * generic.cxx (generic_memory ctor): Add three new pins.
        (generic_memory dtor): munmap if mapping.
        (attempt_resize): Drive error pin when needed.  munmap if mapping.
        (imageload_handler, imagestore_handler): Drive error pin when needed.
        (imagemsync_handler, imagemmap_handler): New functions.
        * generic.h: Corresponding changes.
        * hw-memory-ram_rom-basic.txt: Document extensions.

[component/testsuite/ChangeLog]
2001-03-13  Frank Ch. Eigler  <fche@@redhat.com>

        * sidcomp.mapper/busif.exp: Disable if !enable_shared.
        * sidcomp.memory/genericmemory.exp: Add tests for mmap functions.
@
text
@d40 1
a40 2
    set status [lindex $result 0]
    if {$status != "ok"} then {fail "$test - bad" ; break }
d76 1
a76 2
    set status [lindex $result 0]
    if {$status != "ok"} then {fail "$test - bad" ; break}
d116 1
a116 2
    set status [lindex $result 0]
    if {$status != "ok"} then {fail "$test - bad" ; break}
d185 1
a185 2
    set status [lindex $result 0]
    if {$status != "ok"} then {fail "$test - $status @@ $i" ; break}
d199 1
a199 1
    if {[lindex $result 0] != "ok" || [lindex $result 1] != $data} then {
@


1.1
log
@* public snapshot of sid simulator
@
text
@d162 87
@

