head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	sid-snapshot-20090401:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	sid-20020905-branchpoint:1.5
	sid-20020905-branch:1.5.0.2
	cygnus_cvs_20020108_pre:1.5;
locks; strict;
comment	@# @;


1.5
date	2001.09.25.18.26.01;	author fche;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.22.05.32.18;	author bje;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.19.01.55.48;	author bje;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.13.15.19.09;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.23.13.06.43;	author fche;	state Exp;
branches;
next	;


desc
@@


1.5
log
@* mild test cleanup

2001-09-25  Frank Ch. Eigler  <fche@@redhat.com>

        * lib/monkey.exp (do_one_test): Set a short timeout.
        (monkey_start): Don't use sid_find_file to look for victim's
        component library.
        * config/default.exp (sid_cmd): Use "\r" (not "\n") as send EOL.
        * sidcomp.mapper/busif.exp (sid_read_write): Ditto.
@
text
@# unix.exp - Test driver for the SID component testsuite.  -*- Tcl -*-

# Copyright (C) 1999, 2000, 2001 Red Hat.
# This file is part of SID and is licensed under the GPL.
# See the file COPYING.SID for conditions for redistribution.

############################################################################
# Utility routines for sid test cases

source "../../config/info.tcl"

proc sid_config_component_etc_test { file pfx type sfx } {
    global prefix
    set f [open $file "w"]
    puts $f "$pfx"
    puts $f "load libtclapi.la tcl_bridge_library"
    puts $f "new bridge-tcl tester"
    puts $f "new $type real-victim"
    puts $f "set tester load! [sid_find_file tester.tcl]"
    puts $f "set tester hexify? yes-please-and-thanks"
    puts $f "relate tester victim real-victim"
    puts $f "relate tester real-victim real-victim"
    puts $f "connect-pin main perform-activity -> tester command-io!"
    puts $f "connect-pin main perform-activity -> tester !event"
    puts $f "$sfx"
    verbose "Created sid configuration file $file without tracing" 
    close $f
}

proc sid_config_component_etc_test_with_tracing { file pfx type sfx } {
    global prefix
    set f [open $file "w"]
    puts $f "$pfx"
    puts $f "load libtclapi.la tcl_bridge_library"
    puts $f "new bridge-tcl tester"
    puts $f "new sid-api-trace wrapper"
    puts $f "new $type real-victim"
    puts $f "set tester load! [sid_find_file tester.tcl]"
    puts $f "set tester hexify? yes-please-and-thanks"
    puts $f "relate tester victim wrapper"
    puts $f "relate tester real-victim real-victim"
    puts $f "relate wrapper victim real-victim"
    puts $f "set wrapper victim-trace? 1"
    puts $f "connect-pin main perform-activity -> tester command-io!"
    puts $f "connect-pin main perform-activity -> tester !event"
    puts $f "connect-pin main perform-activity -> wrapper !event"
    puts $f "$sfx"
    verbose "Created sid configuration file $file with tracing" 
    close $f
}


proc sid_config_component_test_with_tracing { file pfx type } {
    sid_config_component_etc_test_with_tracing $file $pfx $type ""
}

proc sid_config_component_test { file pfx type } {
    sid_config_component_etc_test $file $pfx $type ""
}


# Start up a SID.  Use the plain main/dynamic "sid" frontend.

proc sid_start {file} {
    global spawn_id
    global TOOL_OPTIONS
    global prefix
    global srcdir
    global victim
    global env
    verbose "starting sid" 2

    if {[string match "*install*" $TOOL_OPTIONS]} then {
	# testing install tree
	# rely on compiled-in SID_EXEC_PREFIX to find parts
    } else {
	# testing build tree
	set env(SID_LIBRARY_PATH) [join [glob "../*" "$srcdir/../*"] ":"]
	# srcdir=/..../sid/component/testsuite
	set tcl_library "$srcdir/../../../tcl/library"
        global host_os
	switch -glob $host_os {
	  {cygwin*} { set tcl_library [exec cygpath -w $tcl_library] }
        }
	set env(TCL_LIBRARY) $tcl_library
    }

    set sid [sid_find_file "sid" "sid.exe"]

    set pid [spawn $sid $file]

    global timeout
    set last_timeout $timeout
    set timeout 30
    expect {
	timeout { perror "timeout while starting [list $sid $file]"; return 0}
	eof { perror "eof while starting [list $sid $file]"; return 0}
	-re "tester.ready" }
    set timeout $last_timeout

    set victim [sid_cmd "set relationships(victim)"]
    verbose "victim component: $victim" 2
    return $pid
}


proc sid_stop {} {
    global spawn_id
    verbose "closing down sid" 2
    catch {close}
    catch {exec "kill" [exp_pid]}
    wait
    return 1
}



# generate a printworthy subset of argument
proc prettyprint { cmd } {
    regsub -all {[^ -~]} $cmd {.} cmdpretty
    return [list $cmdpretty]
}


proc sid_cmd { cmd } {
    global spawn_id
    global expect_out
    global test

    if [catch { exp_pid }] then {
	unresolved "$test - spawned sid process already gone"
	return
    }

    # wait for prompt
    global timeout
    set last_timeout $timeout
    set timeout 3
    set ok 1
    expect {
	timeout { unresolved "$test - timeout before [prettyprint $cmd]"; set ok 0 }
	eof { unresolved "$test - eof before [prettyprint $cmd]"; set ok 0 }
	"command>"
    }
    set timeout $last_timeout
    if {! $ok} then { return "" }

    # encode string
    binary scan $cmd H* encoded

    # bump up buffer size, big time
    set desired_match_max [expr 10 * [string length $encoded]]
    if {[match_max] < $desired_match_max} then { match_max $desired_match_max }

    set iterations [expr [string length $encoded] / 64]
    for {set i 0} {$i < $iterations} {incr i} {
	set first [expr $i * 64]
	set last [expr $first + 63]
	send "[string range $encoded $first $last]+\r"
    }
    set first [expr $i * 64]
    send "[string range $encoded $first end]\r"

    expect {
	timeout { fail "$test - timeout after [prettyprint $cmd]" ; return "" }
	eof { fail "$test - eof after [prettyprint $cmd]"; return "" }
	-re "(ERROR:\[^\n\]*)" {
	    fail "$test - [prettyprint $expect_out(1,string)] after [prettyprint $cmd]"
	    return ""
	}
	-re "result>>(\[0-9a-f\]*)<<result" {
	    set result $expect_out(1,string)
	}
	-re "split>>(\[0-9a-f\]*)<<split" {
	    set result $expect_out(1,string)
	    while {1} {
		expect {
		    timeout { fail "$test - timeout3" ; return "" }
		    eof { fail "$test - eof3" ; return "" }
		    -re "split>>(\[0-9a-f\]*)<<split" {
			append result $expect_out(1,string)
		    }
		    -re "split-end" { break }
		}
	    }
	}
    }
    # undo encoding in tester.tcl
    set decoded [binary format H* $result]
    verbose "result $decoded" 3
    return $decoded
}

# assert a general predicate.
# pass or fail the DejaGnu test based on the result.
proc sid_assert {predicate} {
    global test
    if $predicate { pass $test } else { fail $test }
}

# call a command; ignore result (but assert that it's not an ERROR.)
proc sid_assert_success {cmd} {
    global test
    set result [sid_cmd $cmd]
    if [string match "*ERROR*" $result] then { fail $test } else { pass $test }
}

# call a command; assert match on return value
proc sid_assert_matches {cmd pattern} {
    global test
    set result [sid_cmd $cmd]
    if [string match $pattern $result] then { pass $test } else { fail $test }
}

proc sid_assert_equals {cmd number} {
    global test
    set result [sid_cmd $cmd]
    if {$result == $number} then { pass $test } else { fail $test }
}

# call a command; assert match on list result
proc sid_assert_includes_all {cmd patterns} {
    global test
    set result [sid_cmd $cmd]
    foreach pat $patterns {
	if {[string first $pat $result] == -1} then {fail $test ; return }
    }
    pass $test
}

# call a command; assert match on list result
proc sid_assert_includes_none {cmd patterns} {
    global test
    set result [sid_cmd $cmd]
    foreach pat $patterns {
	if {[string first $pat $result] != -1} then {fail $test ; return }
    }
    pass $test
}

# Verify a bus transaction.  $arg is the result of a sid::bus
# operation.  This proc relies on a subtle characteristic of Tcl:
# lindex 0 of a scalar is the scalar itself.  Thus, this handles both
# read and write status values (e.g. {{ok 0} 55} or {ok 0}).

proc sid_bus_ok_p {arg} {
    return [string match ok [lindex [lindex $arg 0] 0]]
}


# Find a file somewhere in the build or install directory hierarchy.
# Decide where to look based on TOOL_OPTIONS variable (the --tool_opts=VALUE
# option from $RUNTESTFLAGS).  If that includes the substring "install", use 
# the install directory tree ($prefix etc.) to find the given file.  If the
# variable is unset or set not to "install", use the build & source directories 
# instead.
proc sid_find_file {args} {
    global TOOL_OPTIONS
    global prefix
    global srcdir
    if {[string match "*install*" $TOOL_OPTIONS]} then {
	set bases [list "$prefix"]
    } else {
	# try to get to the build and source directory
	set bases [list "../.." "$srcdir/../.."]
    }
    set files {} 
    foreach base $bases {
        foreach file $args {
	    verbose "looking for $file under $base" 2
	    if {[llength $files] > 0} then { break }
	    set files [concat $files [glob -nocomplain -- $base/$file $base/*/$file $base/*/*/$file $base/*/*/*/$file]]
	}
    }
    verbose -log "found $files" 2
    switch [llength $files] {
	0 { perror "No matches for $args under $bases" }
	1 { return $files }
	default { return [lindex $files 0] }
    }
}


# These routines don't really belong in unix.exp, but until there's
# another file.
# These were derived from find_gas,etc. in libgloss.exp.
# There's no real heuristic that will work, so for now go with something
# simple: use dejagnu's tool_root_dir.

proc sid_find_gas { toolchain_prefix } {
    global tool_root_dir target_alias
    verbose -log " trd=${tool_root_dir} tal=${target_alias}  tp=${toolchain_prefix}" 2
    if {[is_remote host] || 
	($target_alias != $toolchain_prefix) ||
	![file exists ${tool_root_dir}/../gas/as-new]} {
	return ${toolchain_prefix}-as
    } else {
	return ${tool_root_dir}/../gas/as-new
    }
}

proc sid_find_ld { toolchain_prefix } {
    global tool_root_dir target_alias
    verbose -log " trd=${tool_root_dir} tal=${target_alias}  tp=${toolchain_prefix}" 2
    if {[is_remote host] || 
	($target_alias != $toolchain_prefix) ||
	![file exists ${tool_root_dir}/../ld/ld-new]} {
	return ${toolchain_prefix}-ld
    } else {
	return ${tool_root_dir}/../ld/ld-new
    }
}


proc sid_find_gcc { toolchain_prefix } {
    global tool_root_dir target_alias
    verbose -log " trd=${tool_root_dir} tal=${target_alias}  tp=${toolchain_prefix}" 2
    if {[is_remote host] || 
	($target_alias != $toolchain_prefix) ||
	![file exists ${tool_root_dir}/../gcc/xgcc]} {
	return ${toolchain_prefix}-gcc
    } else {
	return "${tool_root_dir}/../gcc/xgcc -B${tool_root_dir}/../gcc/"
    }
}

proc sid_find_sid {} {
    return [sid_find_file "sid" "sid.exe"]
}


proc sid_find_sid_bsp { toolchain_prefix } {
    # ignore toolchain_prefix.
    return [sid_find_file "configrun-sid"]
}


############################################################################
# Routines automatically called by runtest

# sidcomp_version -- print and return version number
proc sidcomp_version {} {
    puts "version?"
    set version 0.1
    clone_output "sidcomp test $version\n"
}

# sidcomp_exit -- quit and cleanup
proc sidcomp_exit {} {
    # Do nothing.
}

# sidcomp_start -- start the test bucket
proc sidcomp_start {} {
    global TOOL_OPTIONS host_triplet crappy_tcl
    if {[info exists TOOL_OPTIONS]} then { } else { set TOOL_OPTIONS "build" }

    # tcl on some platforms can't handle passing large strings between
    # the expect and the sid processes without corruption.  Set crappy_tcl
    # for these
    switch -glob $host_triplet {
	*-*-solaris* { set crappy_tcl 1 }
	default { set crappy_tcl 0 }
    }
}


############################################################################
# Do these things during test suite startup.

sidcomp_start
@


1.4
log
@2001-08-22  Ben Elliston  <bje@@redhat.com>

	* config/default.exp (sid_assert): New proc.
@
text
@d159 1
a159 1
	send "[string range $encoded $first $last]+\n"
d162 1
a162 1
    send "[string range $encoded $first end]\n"
@


1.3
log
@	* config/default.exp (sid_stop): Don't close with -slave.
@
text
@d194 6
@


1.2
log
@* test suite cleanup

2001-07-13  Frank Ch. Eigler  <fche@@redhat.com>

	* config/default.exp: Stop using [sid_find_file] for component libs.
	Forget about mksid.
	* sidcomp.*/*.exp: Stop using [sid_find_file] to find component
	shared libraries for "load" cmds in sid configuration files.
@
text
@d110 1
a110 1
    catch {close -slave}
@


1.1
log
@* test fix: don't fail in presence of --target_board=SOMETHING

[config/ChangeLog]
2001-06-23  Frank Ch. Eigler  <fche@@redhat.com>

        * unix.exp: File removed; moved to testsuite/config/default.exp.

[component/testsuite/ChangeLog]
2001-06-23  Frank Ch. Eigler  <fche@@redhat.com>

        * config/default.exp: New file, moved from ../../config/unix.exp.
@
text
@d16 1
a16 1
    puts $f "load [sid_find_file libtclapi.la] tcl_bridge_library"
d34 1
a34 1
    puts $f "load [sid_find_file libtclapi.la] tcl_bridge_library"
d62 1
a62 5
# Start up a SID executable.  If TOOL_OPTIONS includes the substring
# "static", then use a statically linked sid program, built using
# mksidconf.  Otherwise use the plain main/dynamic "sid" frontend.
# In this case, TOOL_OPTIONS also better include "install", since
# mksid currently only works on the install tree.
d88 1
a88 8
    if {[string match "*static*" $TOOL_OPTIONS]} then {
	set mksidconf [sid_find_file "mksidconf"]
	system $mksidconf -static $file
	regsub "(.*).conf" $file {./\1} sid
        regsub "(.*).conf" $file {\1.sconf} file
    } else {
	set sid [sid_find_file "sid" "sid.exe"]
    }
@

