head	1.4;
access;
symbols
	sid-snapshot-20180601:1.4
	sid-snapshot-20180501:1.4
	sid-snapshot-20180401:1.4
	sid-snapshot-20180301:1.4
	sid-snapshot-20180201:1.4
	sid-snapshot-20180101:1.4
	sid-snapshot-20171201:1.4
	sid-snapshot-20171101:1.4
	sid-snapshot-20171001:1.4
	sid-snapshot-20170901:1.4
	sid-snapshot-20170801:1.4
	sid-snapshot-20170701:1.4
	sid-snapshot-20170601:1.4
	sid-snapshot-20170501:1.4
	sid-snapshot-20170401:1.4
	sid-snapshot-20170301:1.4
	sid-snapshot-20170201:1.4
	sid-snapshot-20170101:1.4
	sid-snapshot-20161201:1.4
	sid-snapshot-20161101:1.4
	sid-snapshot-20160901:1.4
	sid-snapshot-20160801:1.4
	sid-snapshot-20160701:1.4
	sid-snapshot-20160601:1.4
	sid-snapshot-20160501:1.4
	sid-snapshot-20160401:1.4
	sid-snapshot-20160301:1.4
	sid-snapshot-20160201:1.4
	sid-snapshot-20160101:1.4
	sid-snapshot-20151201:1.4
	sid-snapshot-20151101:1.4
	sid-snapshot-20151001:1.4
	sid-snapshot-20150901:1.4
	sid-snapshot-20150801:1.4
	sid-snapshot-20150701:1.4
	sid-snapshot-20150601:1.4
	sid-snapshot-20150501:1.4
	sid-snapshot-20150401:1.4
	sid-snapshot-20150301:1.4
	sid-snapshot-20150201:1.4
	sid-snapshot-20150101:1.4
	sid-snapshot-20141201:1.4
	sid-snapshot-20141101:1.4
	sid-snapshot-20141001:1.4
	sid-snapshot-20140901:1.4
	sid-snapshot-20140801:1.4
	sid-snapshot-20140701:1.4
	sid-snapshot-20140601:1.4
	sid-snapshot-20140501:1.4
	sid-snapshot-20140401:1.4
	sid-snapshot-20140301:1.4
	sid-snapshot-20140201:1.4
	sid-snapshot-20140101:1.4
	sid-snapshot-20131201:1.4
	sid-snapshot-20131101:1.4
	sid-snapshot-20131001:1.4
	sid-snapshot-20130901:1.4
	sid-snapshot-20130801:1.4
	sid-snapshot-20130701:1.4
	sid-snapshot-20130601:1.4
	sid-snapshot-20130501:1.4
	sid-snapshot-20130401:1.4
	sid-snapshot-20130301:1.4
	sid-snapshot-20130201:1.4
	sid-snapshot-20130101:1.4
	sid-snapshot-20121201:1.4
	sid-snapshot-20121101:1.4
	sid-snapshot-20121001:1.4
	sid-snapshot-20120901:1.4
	sid-snapshot-20120801:1.4
	sid-snapshot-20120701:1.4
	sid-snapshot-20120601:1.4
	sid-snapshot-20120501:1.4
	sid-snapshot-20120401:1.4
	sid-snapshot-20120301:1.4
	sid-snapshot-20120201:1.4
	sid-snapshot-20120101:1.4
	sid-snapshot-20111201:1.4
	sid-snapshot-20111101:1.4
	sid-snapshot-20111001:1.4
	sid-snapshot-20110901:1.4
	sid-snapshot-20110801:1.4
	sid-snapshot-20110701:1.4
	sid-snapshot-20110601:1.4
	sid-snapshot-20110501:1.4
	sid-snapshot-20110401:1.4
	sid-snapshot-20110301:1.4
	sid-snapshot-20110201:1.4
	sid-snapshot-20110101:1.4
	sid-snapshot-20101201:1.4
	sid-snapshot-20101101:1.4
	sid-snapshot-20101001:1.4
	sid-snapshot-20100901:1.4
	sid-snapshot-20100801:1.4
	sid-snapshot-20100701:1.4
	sid-snapshot-20100601:1.4
	sid-snapshot-20100501:1.4
	sid-snapshot-20100401:1.4
	sid-snapshot-20100301:1.4
	sid-snapshot-20100201:1.4
	sid-snapshot-20100101:1.4
	sid-snapshot-20091201:1.4
	sid-snapshot-20091101:1.4
	sid-snapshot-20091001:1.4
	sid-snapshot-20090901:1.4
	sid-snapshot-20090801:1.4
	sid-snapshot-20090701:1.4
	sid-snapshot-20090601:1.4
	sid-snapshot-20090501:1.4
	sid-snapshot-20090401:1.4
	sid-snapshot-20090301:1.4
	sid-snapshot-20090201:1.4
	sid-snapshot-20090101:1.4
	sid-snapshot-20081201:1.4
	sid-snapshot-20081101:1.4
	sid-snapshot-20081001:1.4
	sid-snapshot-20080901:1.4
	sid-snapshot-20080801:1.4
	sid-snapshot-20080701:1.4
	sid-snapshot-20080601:1.4
	sid-snapshot-20080501:1.4
	sid-snapshot-20080403:1.4
	sid-snapshot-20080401:1.4
	sid-snapshot-20080301:1.4
	sid-snapshot-20080201:1.4
	sid-snapshot-20080101:1.4
	sid-snapshot-20071201:1.4
	sid-snapshot-20071101:1.4
	sid-snapshot-20071001:1.4
	sid-20020905-branchpoint:1.4
	sid-20020905-branch:1.4.0.2
	cygnus_cvs_20020108_pre:1.4;
locks; strict;
comment	@# @;


1.4
date	2001.07.13.15.19.09;	author fche;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.28.23.41.02;	author bje;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.20.07.18.34;	author bje;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.07.19.31.02;	author fche;	state Exp;
branches;
next	;


desc
@@


1.4
log
@* test suite cleanup

2001-07-13  Frank Ch. Eigler  <fche@@redhat.com>

	* config/default.exp: Stop using [sid_find_file] for component libs.
	Forget about mksid.
	* sidcomp.*/*.exp: Stop using [sid_find_file] to find component
	shared libraries for "load" cmds in sid configuration files.
@
text
@# Testsuite for the Cogent CMA222 ARM interrupt controller.
# This testsuite tries to exercise just about every aspect of this
# component simulation.
#
# Copyright (C) 2000, 2001 Red Hat

if {! $sidtarget(arm)} then { untested "hw-interrupt-cogen/cma222 not available"; return }

# The number of available regular interrupt lines.
set numLines 8

# A convenience variable.
set all_ones 0xFF

set test "sid configuration"
sid_config_component_test "cma222-intr.conf" \
    "load libinterrupt.la interrupt_component_library" \
    "hw-interrupt-cogent/cma222"
pass $test

set test "sid start"
if {[sid_start "cma222-intr.conf"]} {
    pass $test
} else {
    fail $test
    return
}

# A pin we use again, and again, and again.
set probe_pin [sid_cmd "sid::pin::new"]


# Set up an array of triggerpoint sensor pins (connected to the victim).
# Maintain another array that counts the number of times the triggerpoints are hit.

#catch {unset watchpins triggercount}
foreach watchable \
  {interrupt irq-raw-status irq-enable-register} {
    set test "establish a triggerpoint for watchable state variable: $watchable"
    set watchpins($watchable) [sid_cmd "sid::pin::new"]
    sid_cmd "set triggercount($watchable) 0"
    sid_cmd \
        "set hook_driven_h4($watchpins($watchable)) {global triggercount driven_h4_value; incr triggercount($watchable) }"

    # Some limited URL encoding hacks.
    # see sid/include/sidwatchutil.h for the rules.
    regsub -all -- "-" $watchable "%2D" watchEnc
    set result [sid_cmd "sid::component::connect_pin $victim watch:${watchEnc}:change $watchpins($watchable)"]
    set w [sid_cmd "sid::component::attribute_names_in_category $victim watchable"]
    if {$result == "ok"} { pass $test } else { fail "$test -- $result" }
}


# There are no attributes for this component, but let's do this for good measure.
set test "attribute list"
sid_assert_success "sid::component::attribute_names $victim"


# Check for presence of the output pin.
set test "get irq pin"
sid_assert_success "sid::component::find_pin $victim interrupt"


# Check for presence of input pins. Record the names given to them by
# the Tcl bridge--we use them later.

# Check for all 8 interrupt input lines.
for {set i 0} {$i < $numLines} {incr i} {
    set test "get interrupt-source-$i pin"
    if {[set irq_source($i) [sid_cmd "sid::component::find_pin $victim interrupt-source-$i"]] != ""} {
	pass $test
    } else {
	fail $test
    }
}


# Check for the presence of the register set (a named bus). Record the
# name given to it by sid_cmd, as we'll use it throughout this
# testsuite. 
set test "get irq-register bus" 
if {[set bus [sid_cmd "sid::component::find_bus $victim irq-registers"]] != ""} {
    pass $test
} else {
    fail $test
}

if {0 == 1} {
set test "Save state"
set state [sid_cmd "sid::component::attribute_value $victim state-snapshot"]
if {$state != ""} then { pass $test } else { fail $test }

# Allow interrupts from any source.
# This is a basic version of the more complete testing that happens
# further on in this script.

foreach pattern {0x0 0x12 0x55 0xAA 0xFF} {
    set test "disable all interrupt lines"
    sid_assert_success "sid::bus::write_h4_l1 $bus 0x18 0x00"

    set test "validate all interrupt lines are disabled"
    set result [sid_cmd "sid::bus::read_h4_l1 $bus 0x10"]

    if [sid_bus_ok_p $result] {
	if {[lindex $result 1] == 0} { pass $test } else { fail $test }
    } else {
	fail "$test (bus error; status $result)"
    }

    set test "initialise set of enabled interrupt lines"
    sid_assert_success "sid::bus::write_h4_l1 $bus 0x18 $pattern"

    set test "validate set of enabled interrupt lines"
    set result [sid_cmd "sid::bus::read_h4_l1 $bus 0x10"]
    if [sid_bus_ok_p $result] then {
	if {[lindex $result 1] == $pattern} { pass $test } else { fail "$test (pattern $pattern; result $result)" }
    } else {
	fail "$test (bus error; status $result)"
    }
}

set test "Repeat Save state"
set rpstate [sid_cmd "sid::component::attribute_value $victim state-snapshot"]
set comp_res [string compare $state $rpstate]
if {$comp_res != 0} then { pass $test } else { fail $test }

set test "Restore State"
set ok [sid_cmd "sid::component::set_attribute_value $victim state-snapshot [list $state]"]
if {$ok == "ok"} then { pass $test } else { fail $test }
}

# At the completion of this test, all interrupts *should* be enabled.


# Generate an interrupt on each of the regular interrupt lines.
# Once it is acknowledged, suspend the interrupt source.

# This is a double nested loop -- $numLines*$numLines tests are performed
# to make sure that other interrupt lines going high does not invoke an
# interrupt (ie. to ensure that the masking works correctly for all cases).

sid_cmd "set hook_driven_h4($probe_pin) { 
    global driven_h4_value interrupted
    # Make the pin values sensible.
    # The pin values are normally negated in the controller to make it
    # easy to connect this component to related CPUs like the ARM7.

    if \[expr \$driven_h4_value == 0\] { 
	set interrupted 1
    } else {
        set interrupted 0
    }
}"

sid_cmd "sid::component::connect_pin $victim interrupt $probe_pin"

set failures 0
for {set i 0} {$i < $numLines} {incr i} {
    set test "disable all interrupt lines"
#note "outer loop $i"
    sid_assert_success "sid::bus::write_h4_l1 $bus 0x18 0x00"

    set test "validate all interrupt lines are cleared"
    set result [sid_cmd "sid::bus::read_h4_l1 $bus 0x0"]
    if [sid_bus_ok_p $result] then {
	set val [lindex $result 1]
	if {$val != 0} {
	    incr failures
	    fail $test
	}
    } else {
	incr failures
	fail "$test -- [lindex $result 0]"
    }

    set test "validate all interrupt lines are disabled"
    set result [sid_cmd "sid::bus::read_h4_l1 $bus 0x10"]
    if [sid_bus_ok_p $result] then {
	set val [lindex $result 1]
	if {$val != 0} {
	    incr failures
	    fail $test
	}
    } else {
	incr failures
	fail "$test -- [lindex $result 0]"
    }

    set test "enable interrupt line $i"
    sid_assert_success "sid::bus::write_h4_l1 $bus 0x18 [expr 1 << $i]"

    set test "validate only interrupt line $i is enabled"
    set result [sid_cmd "sid::bus::read_h4_l1 $bus 0x10"]
    
    if [sid_bus_ok_p $result] {
	if {[lindex $result 1] != [expr 1 << $i]} {
	    incr failures
	    fail $test
	}
    } else {
	incr failures
	fail "$test -- [lindex $result 0]"
    }
    
# XXX mrg this does not work yet.

    # Note that this has large portions of code in the "incr" section,
    # like a perl 'continue' section.
    for {set j 0} {$j < $numLines} {
	# Lower the interrupt source.	
	sid_cmd "sid::pin::driven_h4 $irq_source($j) 0"

	# this doesn't work for the cma222; interrupts 0, 3 and 4 are
	# only de-asserted by clearing the bit in the various register.
	# so, we check that it hasn't been deasserted, and then clear
	# it anyway.  note that we only do this if we are testing the
	# same interrupt from the outer loop.

	if {$j == 0 || $j == 3 || $j == 4} {
	    if {$j == $i && $old_failures == $failures} {
		set test "validate interrupt $j is still enabled"
		set result [sid_cmd "sid::bus::read_h4_l1 $bus 0x0"]
		if [sid_bus_ok_p $result] {
		    set val [lindex $result 1]
		    if {$val == [expr 1 << $j]} { pass $test } else { fail "$test (result $val)" }
		} else {
		    incr failures
		    fail "$test (bus error; status $result)"
		}
	    }
            sid_assert_success "sid::bus::write_h4_l1 $bus 0x8 0xFF"
	}

	# Now make sure that the interrupt is really no longer pending.

# disable this bit for now, cuz it doesn't quite work yet.
	if {0 == 1} {
	    set test "making sure interrupt $j is no longer pending"
	    set result [sid_cmd "sid::bus::read_h4_l1 $bus 0x0"]
	    if [sid_bus_ok_p $result] {
		if {[lindex $result 1] == 0} { pass $test } else { fail "$test (result $result)" }
	    } else {
		fail "$test (bus error; status $result)"
	    }
	}

	incr j
    } {
	# save this away
	set old_failures $failures

#note "inner loop $j"
	sid_cmd "set interrupted 0"
	
	# Raise an interrupt on interrupt line `j'.
	sid_cmd "sid::pin::driven_h4 $irq_source($j) 1"
	
	if {$i == $j} { set test "permitting" } else { set test "masking" }
	append test " interrupt from interrupt $j when enabling interrupt $i only"
	    
	set result [sid_cmd "set interrupted"]
	#set result [sid_cmd "sid::pin::read_h4_l1 $bus 0"]
	if {$result == "1"} {
	    if {$i == $j} { 
		set test_save $test
		set test "bit $i is set in the masked status register"
		set result [sid_cmd "sid::bus::read_h4_l1 $bus 0"]
		if [sid_bus_ok_p $result] {
		    if {[lindex $result 1] != [expr 1 << $i]} {
			incr failures
			fail $test
			continue;
		    }
		} else {
		    incr failures
		    fail "$test -- [lindex $result 0]"
		    continue;
		}
		set test $test_save
	    } else {
		incr failures
		fail $test
		continue;
	    }
	} else {
	    if {$i == $j} { 
		incr failures
		fail "$test (no interrupt)"
		continue;
	    }
	}
    }
}

if {!$failures} { pass "interrupt masking" }


sid_cmd "sid::component::disconnect_pin $victim interrupt $probe_pin"



# Test if triggerpoints fired correctly.

set num 17
set test "interrupt triggerpoint fired $num times"
set count [sid_cmd "set triggercount(interrupt)"]
if {$count == "$num"} { pass $test } else { fail "$test; fired $count times" }

set num 128
set test "irq-raw-status triggerpoint fired $num times"
set count [sid_cmd "set triggercount(irq-raw-status)"]
if {$count == "$num"} { pass $test } else { fail "$test; fired $count times" }

set num 15
set test "irq-enable-register triggerpoint fired $num times"
set count [sid_cmd "set triggercount(irq-enable-register)"]
if {$count == "$num"} { pass $test } else { fail "$test; fired $count times" }

catch {unset watchpins triggercount}


set test "sid stop"
if {[sid_stop]} { pass $test } else { fail $test ; return }

# zap temp file if tests were successful
global exit_status
if {$exit_status == "0"} {
    file delete "cma222-intr.conf"
}
@


1.3
log
@2001-06-29  Ben Elliston  <bje@@redhat.com>

	* sidcomp.interrupt/cma222-interrupt.exp: Return the right
	component type name if the target is not available in the
	configuration.
@
text
@d17 1
a17 1
    "load [sid_find_file libinterrupt.la] interrupt_component_library" \
@


1.2
log
@2001-06-20  Ben Elliston  <bje@@redhat.com>

	* sidcomp.cache/coherency.exp: Use sid_bus_ok_p to detect bus read
	errors instead of the frequently used (and less readable)
	construction: if {[lindex $result] 0 == "ok"}.
	* sidcomp.cache/writealloc.exp: Likewise.
	* sidcomp.cache/writethru.exp: Likewise.
	* sidcomp.gloss/angel.exp: Likewise.
	* sidcomp.ide/diskio.exp: Likewise.
	* sidcomp.interrupt/arm-interrupt.exp: Likewise.
	* sidcomp.interrupt/cma222-interrupt.exp: Likewise.
	* sidcomp.lcd/lcdbase.exp: Likewise.
	* sidcomp.mapper/basicmapper.exp: Likewise.
	* sidcomp.memory/am29.exp: Likewise.
	* sidcomp.memory/at29.exp: Likewise.
	* sidcomp.memory/at29val.exp: Likewise.
	* sidcomp.memory/genericmemory.exp: Likewise.
	* sidcomp.mmu/arm-remap.exp: Likewise.
	* sidcomp.parport/parport.exp: Likewise.
	* sidcomp.rtc/ds1642.exp: Likewise.
	* sidcomp.rtc/ds1742.exp: Likewise.
	* sidcomp.timers/timerbase.exp: Likewise.
	* sidcomp.timers/timersched.exp: Likewise.
@
text
@d5 1
a5 1
# Copyright (C) 2000 Red Hat
d7 1
a7 1
if {! $sidtarget(arm)} then { untested "hw-interrupt-arm/ref not available"; return }
@


1.1
log
@* public snapshot of sid simulator
@
text
@d104 1
a104 2
    set status [lindex $result 0]
    if {[lindex $result 0] == "ok"} {
d107 1
a107 1
	fail "$test (bus error; status $status)"
d115 1
a115 2
    set status [lindex $result 0]
    if {[lindex $result 0] == "ok"} {
d118 1
a118 1
	fail "$test (bus error; status $status)"
d165 1
a165 1
    if {[lindex $result 0] == "ok"} {
d178 1
a178 1
    if {[lindex $result 0] == "ok"} {
d194 2
a195 1
    if {[lindex $result 0] == "ok"} {
d223 1
a223 2
		set status [lindex $result 0]
		if {$status == "ok"} {
d228 1
a228 1
		    fail "$test (bus error; status $status)"
d240 1
a240 2
	    set status [lindex $result 0]
	    if {$status == "ok"} {
d243 1
a243 1
		fail "$test (bus error; status $status)"
d268 1
a268 1
		if {[lindex $result 0] == "ok"} {
@

