head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	sid-snapshot-20090401:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	sid-20020905-branchpoint:1.5
	sid-20020905-branch:1.5.0.2
	cygnus_cvs_20020108_pre:1.5;
locks; strict;
comment	@# @;


1.5
date	2001.07.13.15.19.09;	author fche;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.21.05.54.42;	author bje;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.20.07.18.31;	author bje;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.31.06.19.59;	author bje;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.07.19.31.01;	author fche;	state Exp;
branches;
next	;


desc
@@


1.5
log
@* test suite cleanup

2001-07-13  Frank Ch. Eigler  <fche@@redhat.com>

	* config/default.exp: Stop using [sid_find_file] for component libs.
	Forget about mksid.
	* sidcomp.*/*.exp: Stop using [sid_find_file] to find component
	shared libraries for "load" cmds in sid configuration files.
@
text
@set test "sid configuration"
sid_config_component_test "diskio.conf" \
    "load libide.la ide_component_library" \
    "hw-disk-ide"
pass $test

set junk_files ""

set test "sid startup"
if [sid_start "diskio.conf"] then { pass $test } else { fail $test ; return }


set test "get buses"
set controlbus [sid_cmd "sid::component::find_bus $victim control-block-bus"]
set commandbus [sid_cmd "sid::component::find_bus $victim command-block-bus"]
if {$controlbus != "" && $commandbus != ""} then { pass $test } else { fail $test }



# IDE client subroutines

proc wait_ide_bit  { bus address mask value } {
    global test
    set iters 0
    while {$iters < 10} {
	set result [sid_cmd "sid::bus::read_h4_l1 $bus $address"]
	if ![sid_bus_ok_p $result] then {
	    fail "$test - wait $address $mask $value - [lindex $result 0]" 
	    return "oops1"
	}
	set byte [lindex $result 1]
	if {($byte & $mask) == $value} then { return "ok" }
	incr iters
    }
    fail "$test - wait $address $mask $value - timeout"
    return "oops2"
}

proc wait_drdy { } {
    global commandbus
    return [wait_ide_bit $commandbus 07 0x40 0x40]
}

proc wait_drq { } {
    global controlbus
    return [wait_ide_bit $controlbus 06 0x08 0x08]
}

proc wait_error { } {
    global controlbus
    return [wait_ide_bit $controlbus 06 0x01 0x01]
}

proc wait_noerror { } {
    global controlbus
    return [wait_ide_bit $controlbus 06 0x01 0x00]
}


array set sector ""
proc read_sector { size } {
    global test
    global commandbus
    global sector
    set bytes 0
    while {$bytes < 512} {
	if {$size == 1} then {
	    set result [sid_cmd "sid::bus::read_h4_l1 $commandbus 00"]
	} elseif {$size == "2l"} {
	    set result [sid_cmd "sid::bus::read_h4_l2 $commandbus 00"]
	} else {
	    set result [sid_cmd "sid::bus::read_h4_b2 $commandbus 00"]
	}
	if ![sid_bus_ok_p $result] then {
	    fail "$test - read sector - read status [lindex $result 0]" 
	    return "gack"
	}
	set value [lindex $result 1]
	if {$size == 1} then {
	    set sector($bytes) $value
	    incr bytes
	} elseif {$size == "2l"} {
	    set high [expr {($value >> 8) & 0xff}]
	    set low [expr {$value & 0xff}]
	    set sector($bytes) $low
	    incr bytes
	    set sector($bytes) $high
	    incr bytes
	} else {
	    set low [expr {($value >> 8) & 0xff}]
	    set high [expr {$value & 0xff}]
	    set sector($bytes) $low
	    incr bytes
	    set sector($bytes) $high
	    incr bytes
	}
    }
    return "ok"
}


proc write_sector { size } {
    global test
    global commandbus
    global sector
    set bytes 0
    while {$bytes < 512} {
	if {$size == "1"} then {
	    set value $sector($bytes)
	    incr bytes
	} elseif {$size == "2l"} {
	    set low $sector($bytes)
	    incr bytes
	    set high $sector($bytes)
	    incr bytes
	    set value [expr {($high << 8) | $low}]
	} else {
	    set high $sector($bytes)
	    incr bytes
	    set low $sector($bytes)
	    incr bytes
	    set value [expr {($high << 8) | $low}]
	}
	if {$size == 1} then {
	    set result [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x00 $value"]
	} elseif {$size == "2l"} {
	    set result [sid_cmd "sid::bus::write_h4_l2 $commandbus 0x00 $value"]
	} else {
	    set result [sid_cmd "sid::bus::write_h4_b2 $commandbus 0x00 $value"]
	}
	if ![sid_bus_ok_p $result] then {
	    fail "$test - write sector - write status $result" 
	    return "gack"
	}
    }
    return "ok"
}


proc prepare_sector_transfer { drive cylinder head sector lba } {
    global commandbus
    verbose -log "transfer drive=$drive cylinder=$cylinder head=$head sector=$sector lba=$lba"
    # one sector
    set oks [lindex [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x02 0x01"] 0]
    # sector number
    lappend oks [lindex [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x03 $sector"] 0]
    # cylinder low/high
    set cyllow [expr {$cylinder & 0xff}]
    set cylhigh [expr {($cylinder >> 8) & 0xff}]
    lappend oks [lindex [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x04 $cyllow"] 0]
    lappend oks [lindex [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x05 $cylhigh"] 0]
    # drive/head
    set drivhead [expr {($drive ? 0x10 : 0x00) | ($head & 0xf) | ($lba ? 0x40 : 0x00)}]
    lappend oks [lindex [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x06 $drivhead"] 0]
    if {$oks == "ok ok ok ok ok"} then { return "ok" } else { return "nope" }
}


proc sector_substring { from length } {
    global sector
    set result ""
    for {set i $from} {$i < ($from + $length)} {incr i} {
	append result [format "%c" $sector($i)]
    }
    return $result
}

proc set_sector { s } {
    global sector
    for {set i 0} {$i < 512} {incr i} {
	scan [string index $s [expr {$i % [string length $s]}]] %c byte
	set sector($i) $byte
    }
}



set test "configure drive 0"
set oks [sid_cmd "sid::component::set_attribute_value $victim drive0-present? 1"]
set testfile0 "diskio.drive0"
lappend junk_files "$testfile0"
lappend oks [sid_cmd "sid::component::set_attribute_value $victim drive0-file $testfile0"]
# 512c 16h 64s : 256 MB
lappend oks [sid_cmd "sid::component::set_attribute_value $victim drive0-num-cylinders 512"]
lappend oks [sid_cmd "sid::component::set_attribute_value $victim drive0-num-heads 16"]
lappend oks [sid_cmd "sid::component::set_attribute_value $victim drive0-num-sectors-per-track 64"]
if {$oks == "ok ok ok ok ok"} then { pass $test } else { fail $test }


set test "read identification for drive 0"
set oks [wait_drdy]
lappend oks [lindex [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x06 0x00"] 0]
lappend oks [lindex [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x07 0xEC"] 0]
lappend oks [wait_drq]
lappend oks [read_sector 1]
verbose -log "serial: [sector_substring 20 20]"
verbose -log "fw: [sector_substring 46 8]"
set model [sector_substring 54 40]
verbose -log "model: $model"
if {$oks == "ok ok ok ok ok" 
    && [string match "SID virtual IDE*" $model]} then { 
    pass $test 
} else { fail $test }


set test "read identification for nonexistent drive 1"
set oks [wait_drdy]
lappend oks [lindex [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x06 0x10"] 0]
lappend oks [lindex [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x07 0xEC"] 0]
lappend oks [wait_error]
if {$oks == "ok ok ok ok" } then { pass $test } else { fail $test }


set test "write first sector of drive 0"
# 64 chars, repeated
set_sector "<-- Super duper rubber dingy oh sector data 0123456789ABCDEF -->"
set oks [wait_drdy]
lappend oks [prepare_sector_transfer 0 0 0 0 0]
lappend oks [lindex [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x07 0x30"] 0]
lappend oks [wait_drq]
lappend oks [write_sector 1]
lappend oks [wait_noerror]
if {$oks == "ok ok ok ok ok ok"} then { pass $test } else { fail $test }


set test "write second sector of drive 0 using shorts"
# 64 chars, repeated
set_sector "<- oh one two three four five six seven eight nine ten eleven ->"
set oks [wait_drdy]
lappend oks [prepare_sector_transfer 0 0 0 1 0]
lappend oks [lindex [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x07 0x30"] 0]
lappend oks [wait_drq]
lappend oks [write_sector 2b]
lappend oks [wait_noerror]
if {$oks == "ok ok ok ok ok ok"} then { pass $test } else { fail $test }


set test "configure drive 1"
set oks [sid_cmd "sid::component::set_attribute_value $victim drive1-present? 1"]
set testfile1 "diskio.drive1"
lappend junk_files "$testfile1"
lappend oks [sid_cmd "sid::component::set_attribute_value $victim drive1-file $testfile1"]
# 4c 4h 4s : 32 MB
lappend oks [sid_cmd "sid::component::set_attribute_value $victim drive1-num-cylinders 16"]
lappend oks [sid_cmd "sid::component::set_attribute_value $victim drive1-num-heads 16"]
lappend oks [sid_cmd "sid::component::set_attribute_value $victim drive1-num-sectors-per-track 16"]
if {$oks == "ok ok ok ok ok"} then { pass $test } else { fail $test }


set test "copy CHS sectors 0,1 on drive 0 TO LBA sectors 1,0 on drive 1"
set oks [wait_drdy]
lappend oks [prepare_sector_transfer 0 0 0 0 0]
lappend oks [lindex [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x07 0x20"] 0]
lappend oks [wait_drq]
lappend oks [read_sector 2l]
lappend oks [wait_noerror]
lappend oks [prepare_sector_transfer 1 0 0 1 1]
lappend oks [lindex [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x07 0x30"] 0]
lappend oks [wait_drq]
lappend oks [write_sector 2b]
lappend oks [wait_noerror]
lappend oks [prepare_sector_transfer 0 0 0 1 0]
lappend oks [lindex [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x07 0x20"] 0]
lappend oks [wait_drq]
lappend oks [read_sector 1]
lappend oks [wait_noerror]
lappend oks [prepare_sector_transfer 1 0 0 0 1]
lappend oks [lindex [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x07 0x30"] 0]
lappend oks [wait_drq]
lappend oks [write_sector 1]
lappend oks [wait_noerror]
if {$oks == "ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok ok"} then { pass $test } else { fail $test }


set test "shut down ide drive models"
# this way they close their fstreams
set oks [sid_cmd "sid::component::set_attribute_value $victim drive0-file /dev/null"]
lappend oks [sid_cmd "sid::component::set_attribute_value $victim drive1-file /dev/null"]
lappend oks [sid_cmd "sid::component::set_attribute_value $victim drive0-present? 0"]
lappend oks [sid_cmd "sid::component::set_attribute_value $victim drive1-present? 0"]
if {$oks == "ok ok ok ok"} then { pass $test } else { fail $test }


set test "check contents of $testfile1"
set tf1 [open $testfile1 "r"]
set contents [read $tf1]
close $tf1
verbose -log "$testfile1: $contents"
# Check just the very beginning and end.
if {[string match "?? oh one*ABCDEF ???" $contents] && [string length $contents]==1024} then { pass $test } else { fail $test }


set test "sid stop"
if [sid_stop] then { pass $test } else { fail $test }


# zap temp files if tests were successful 
global exit_status
if {$exit_status == "0"} then { 
    file delete "diskio.conf" 
    foreach f $junk_files {
	file delete $f
    }
}

# be polite to other ide tests that use $contents
catch {unset contents}
@


1.4
log
@2001-06-21  Ben Elliston  <bje@@redhat.com>

	* sidcomp.cache/utils.exp: Use sid_bus_ok_p to detect bus write
	errors instead of the common construction: if {$result == "ok"}.
	* sidcomp.ide/diskio.exp: Likewise.
	* sidcomp.lcd/lcdbase.exp: Likewise.
	* sidcomp.mapper/basicmapper.exp: Likewise.
	* sidcomp.memory/am29.exp: Likewise.
	* sidcomp.memory/at29.exp: Likewise.
	* sidcomp.memory/at29val.exp: Likewise.
	* sidcomp.memory/genericmemory.exp: Likewise.
	* sidcomp.mmu/arm-remap.exp: Likewise.
	* sidcomp.rtc/ds1642.exp: Likewise.
	* sidcomp.rtc/ds1742.exp: Likewise.
	* sidcomp.timers/timerbase.exp: Likewise.
@
text
@d3 1
a3 1
    "load [sid_find_file libide.la] ide_component_library" \
@


1.3
log
@2001-06-20  Ben Elliston  <bje@@redhat.com>

	* sidcomp.cache/coherency.exp: Use sid_bus_ok_p to detect bus read
	errors instead of the frequently used (and less readable)
	construction: if {[lindex $result] 0 == "ok"}.
	* sidcomp.cache/writealloc.exp: Likewise.
	* sidcomp.cache/writethru.exp: Likewise.
	* sidcomp.gloss/angel.exp: Likewise.
	* sidcomp.ide/diskio.exp: Likewise.
	* sidcomp.interrupt/arm-interrupt.exp: Likewise.
	* sidcomp.interrupt/cma222-interrupt.exp: Likewise.
	* sidcomp.lcd/lcdbase.exp: Likewise.
	* sidcomp.mapper/basicmapper.exp: Likewise.
	* sidcomp.memory/am29.exp: Likewise.
	* sidcomp.memory/at29.exp: Likewise.
	* sidcomp.memory/at29val.exp: Likewise.
	* sidcomp.memory/genericmemory.exp: Likewise.
	* sidcomp.mmu/arm-remap.exp: Likewise.
	* sidcomp.parport/parport.exp: Likewise.
	* sidcomp.rtc/ds1642.exp: Likewise.
	* sidcomp.rtc/ds1742.exp: Likewise.
	* sidcomp.timers/timerbase.exp: Likewise.
	* sidcomp.timers/timersched.exp: Likewise.
@
text
@d131 1
a131 1
	if {$result != "ok"} then { 
d144 1
a144 1
    set oks [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x02 0x01"]
d146 1
a146 1
    lappend oks [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x03 $sector"]
d150 2
a151 2
    lappend oks [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x04 $cyllow"]
    lappend oks [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x05 $cylhigh"]
d154 1
a154 1
    lappend oks [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x06 $drivhead"]
d192 2
a193 2
lappend oks [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x06 0x00"]
lappend oks [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x07 0xEC"]
d208 2
a209 2
lappend oks [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x06 0x10"]
lappend oks [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x07 0xEC"]
d219 1
a219 1
lappend oks [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x07 0x30"]
d231 1
a231 1
lappend oks [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x07 0x30"]
d253 1
a253 1
lappend oks [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x07 0x20"]
d258 1
a258 1
lappend oks [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x07 0x30"]
d263 1
a263 1
lappend oks [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x07 0x20"]
d268 1
a268 1
lappend oks [sid_cmd "sid::bus::write_h4_l1 $commandbus 0x07 0x30"]
@


1.2
log
@2001-05-31  Ben Elliston  <bje@@redhat.com>

	* lib/docs.exp (doc_includes_component): Fail on regexp misses.
	* lib/monkey.exp (monkey_test): Re-enable tests.
	* sidcomp.ide/diskio.exp: Unset $contents at completion.
@
text
@d27 1
a27 1
	if {[lindex $result 0] != "ok"} then { 
d74 1
a74 1
	if {[lindex $result 0] != "ok"} then { 
@


1.1
log
@* public snapshot of sid simulator
@
text
@d305 3
@

