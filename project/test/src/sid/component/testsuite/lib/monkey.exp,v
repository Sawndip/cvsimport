head	1.11;
access;
symbols
	sid-snapshot-20180601:1.11
	sid-snapshot-20180501:1.11
	sid-snapshot-20180401:1.11
	sid-snapshot-20180301:1.11
	sid-snapshot-20180201:1.11
	sid-snapshot-20180101:1.11
	sid-snapshot-20171201:1.11
	sid-snapshot-20171101:1.11
	sid-snapshot-20171001:1.11
	sid-snapshot-20170901:1.11
	sid-snapshot-20170801:1.11
	sid-snapshot-20170701:1.11
	sid-snapshot-20170601:1.11
	sid-snapshot-20170501:1.11
	sid-snapshot-20170401:1.11
	sid-snapshot-20170301:1.11
	sid-snapshot-20170201:1.11
	sid-snapshot-20170101:1.11
	sid-snapshot-20161201:1.11
	sid-snapshot-20161101:1.11
	sid-snapshot-20160901:1.11
	sid-snapshot-20160801:1.11
	sid-snapshot-20160701:1.11
	sid-snapshot-20160601:1.11
	sid-snapshot-20160501:1.11
	sid-snapshot-20160401:1.11
	sid-snapshot-20160301:1.11
	sid-snapshot-20160201:1.11
	sid-snapshot-20160101:1.11
	sid-snapshot-20151201:1.11
	sid-snapshot-20151101:1.11
	sid-snapshot-20151001:1.11
	sid-snapshot-20150901:1.11
	sid-snapshot-20150801:1.11
	sid-snapshot-20150701:1.11
	sid-snapshot-20150601:1.11
	sid-snapshot-20150501:1.11
	sid-snapshot-20150401:1.11
	sid-snapshot-20150301:1.11
	sid-snapshot-20150201:1.11
	sid-snapshot-20150101:1.11
	sid-snapshot-20141201:1.11
	sid-snapshot-20141101:1.11
	sid-snapshot-20141001:1.11
	sid-snapshot-20140901:1.11
	sid-snapshot-20140801:1.11
	sid-snapshot-20140701:1.11
	sid-snapshot-20140601:1.11
	sid-snapshot-20140501:1.11
	sid-snapshot-20140401:1.11
	sid-snapshot-20140301:1.11
	sid-snapshot-20140201:1.11
	sid-snapshot-20140101:1.11
	sid-snapshot-20131201:1.11
	sid-snapshot-20131101:1.11
	sid-snapshot-20131001:1.11
	sid-snapshot-20130901:1.11
	sid-snapshot-20130801:1.11
	sid-snapshot-20130701:1.11
	sid-snapshot-20130601:1.11
	sid-snapshot-20130501:1.11
	sid-snapshot-20130401:1.11
	sid-snapshot-20130301:1.11
	sid-snapshot-20130201:1.11
	sid-snapshot-20130101:1.11
	sid-snapshot-20121201:1.11
	sid-snapshot-20121101:1.11
	sid-snapshot-20121001:1.11
	sid-snapshot-20120901:1.11
	sid-snapshot-20120801:1.11
	sid-snapshot-20120701:1.11
	sid-snapshot-20120601:1.11
	sid-snapshot-20120501:1.11
	sid-snapshot-20120401:1.11
	sid-snapshot-20120301:1.11
	sid-snapshot-20120201:1.11
	sid-snapshot-20120101:1.11
	sid-snapshot-20111201:1.11
	sid-snapshot-20111101:1.11
	sid-snapshot-20111001:1.11
	sid-snapshot-20110901:1.11
	sid-snapshot-20110801:1.11
	sid-snapshot-20110701:1.11
	sid-snapshot-20110601:1.11
	sid-snapshot-20110501:1.11
	sid-snapshot-20110401:1.11
	sid-snapshot-20110301:1.11
	sid-snapshot-20110201:1.11
	sid-snapshot-20110101:1.11
	sid-snapshot-20101201:1.11
	sid-snapshot-20101101:1.11
	sid-snapshot-20101001:1.11
	sid-snapshot-20100901:1.11
	sid-snapshot-20100801:1.11
	sid-snapshot-20100701:1.11
	sid-snapshot-20100601:1.11
	sid-snapshot-20100501:1.11
	sid-snapshot-20100401:1.11
	sid-snapshot-20100301:1.11
	sid-snapshot-20100201:1.11
	sid-snapshot-20100101:1.11
	sid-snapshot-20091201:1.11
	sid-snapshot-20091101:1.11
	sid-snapshot-20091001:1.11
	sid-snapshot-20090901:1.11
	sid-snapshot-20090801:1.11
	sid-snapshot-20090701:1.11
	sid-snapshot-20090601:1.11
	sid-snapshot-20090501:1.11
	sid-snapshot-20090401:1.11
	sid-snapshot-20090301:1.11
	sid-snapshot-20090201:1.11
	sid-snapshot-20090101:1.11
	sid-snapshot-20081201:1.11
	sid-snapshot-20081101:1.11
	sid-snapshot-20081001:1.11
	sid-snapshot-20080901:1.11
	sid-snapshot-20080801:1.11
	sid-snapshot-20080701:1.11
	sid-snapshot-20080601:1.11
	sid-snapshot-20080501:1.11
	sid-snapshot-20080403:1.11
	sid-snapshot-20080401:1.11
	sid-snapshot-20080301:1.11
	sid-snapshot-20080201:1.11
	sid-snapshot-20080101:1.11
	sid-snapshot-20071201:1.11
	sid-snapshot-20071101:1.11
	sid-snapshot-20071001:1.11
	sid-20020905-branchpoint:1.11
	sid-20020905-branch:1.11.0.2
	cygnus_cvs_20020108_pre:1.10;
locks; strict;
comment	@# @;


1.11
date	2002.01.08.01.24.59;	author bje;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.25.18.26.02;	author fche;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.21.12.03.05;	author fche;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.20.17.17.54;	author fche;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.24.00.31.50;	author fche;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.22.06.21.15;	author bje;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.22.05.02.46;	author bje;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.18.06.53.18;	author bje;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.31.06.19.56;	author bje;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.01.19.10.25;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.07.19.30.58;	author fche;	state Exp;
branches;
next	;


desc
@@


1.11
log
@2002-01-08  Ben Elliston  <bje@@redhat.com>

	* lib/monkey.exp (monkey_stop): Delete monkey.conf on success.
@
text
@# -*- Tcl -*-
# monkey.exp
#
# Copyright (C) 2000, 2001 Red Hat
#
# Procedures for a monkey testing library. These procs are used to
# fire random input to a victim component. If sid does not close its
# stdin (ie crash), then the test is considered to have passed.
#
# State save/restore functionality is sometimes tested also.  It
# confirms that standard attributes recover their save-time values at
# any subsequent restore.
#
# Dejagnu WARNINGs are emitted when something was overlooked.
#
# monkey_start and monkey_stop must be called at the start and end of
# the test case. monkey_test can run a complete monkey test on a
# component.



# Return a random number between 0 and n-1.
proc random {n} {
    return [expr [expr int(16777216 * [expr rand()])] % int($n)]
}


# generate string with sequential chars between [low .. high]
proc string_spectrum {low high} {
    set chars {} 
    for {set i $low} {$i <= $high} {incr i} {
	lappend chars $i
    }
    return [binary format c* $chars]
}


set charsets(0) "0123456789"; set lenexps(0) 4
set charsets(1) [string_spectrum 0 255] ; set lenexps(1) 12
set charsets(2) "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"; set lenexps(2) 8
set charsets(3) "bx-0123456789abcdef"; set lenexps(3) 4

proc random_string {} {
    global charsets lenexps
    set class [random 4]
    set charset $charsets($class)
    set lenexp $lenexps($class)

    set numchars [string length $charset]
    set len [random [expr pow(2,$lenexp)]]
    set garbage {}
    for {set i 0} {$i < $len} {incr i} {
	append garbage [string index $charset [random $numchars]]
    }
    return $garbage
}


# Override these procs in client .exp files to make monkey avoid accessing
# specific pins/buses/attributes, based on respective names.

proc pin_safe_p {pin_name} { return 1 }
proc bus_safe_p {bus_name} { return 1 }
proc attr_safe_p {attr_name} { return 1 }
proc state_safe_p {} { return 1 }
proc state_saved_p {attr_name} { return 1 }
# XXX: add more?
# eg., add parameters for operation type, non-name arguments 



# Run a monkey test for a component.
# type -- the component type.
# symbol -- the name of the component library header.
# lib -- the library name (e.g. libtimers.la).
# iterations -- the number of random events to generate for the test.
#   (may be overridden by a SID_MONKEYS environment variable)

proc monkey_test {type sym lib {iterations 30s}} {
    global env
    global pins buses attributes

    if [info exist env(SID_MONKEYS)] {
	set iterations $env(SID_MONKEYS)
    }

    global test
    set test "monkey test $type"
    if {[monkey_start $type $sym $lib] < 0} then { return }

    # If $iterations ends in a recognised time specifier
    # (e.g. m => minutes), then run the tests for the specified
    # duration, rather than as a fixed number of iterations.

    set condition "pass"
    if {[regexp {[smhd]$} $iterations]} {
	regexp {([0-9]+)[smhd]$} $iterations ignore units
	set now [clock seconds]
	switch [string range $iterations end end] {
	    s { set finishtime [expr $units + $now] }
	    m { set finishtime [expr 60 * $units + $now] }
	    h { set finishtime [expr 3600 * $units + $now] }
	    d { set finishtime [expr 3600 * 24 * $units + $now] }
	    default { error "unknown unit of time in $iterations" }
	}
	if [expr $finishtime - [clock seconds] > 60] then {
	    note "Testing $type until [clock format $finishtime]"
	}
	while {[clock seconds] < $finishtime} {
	    if {[do_one_test] == 0} then {set condition "fail"; break}
	}
    } else {
	for {set i 0} {$i < $iterations} {incr i} {
	    if {[do_one_test] == 0} then {set condition "fail"; break}
	}
    }
    monkey_stop
    $condition "$test ($iterations iterations)"

    catch {unset pins buses attributes}

    # restore hooks for next monkey_test
    proc pin_safe_p {pin_name} { return 1 }
    proc bus_safe_p {bus_name} { return 1 }
    proc attr_safe_p {attr_name} { return 1 }
    proc state_safe_p {} { return 1 }
    proc state_saved_p {attr_name} { return 1 }
}


# Do one monkey testing round
proc do_one_test {} {
    global num_state_snapshots timeout

    set prev_timeout $timeout
    set timeout 2

    set value [random 100]

    # skew distribution toward effective tests
    if {$value < 30} then { 
	set result [monkey_test_pin]
    } elseif {$value < 50} then {
	set result [monkey_test_bus]
    } elseif {$value < 96} then {
	set result [monkey_test_attribute]
    } elseif {$value < 98} then {
	set result [monkey_test_state_save]
    } else {
	set result [monkey_test_state_restore]
    }

    set timeout $prev_timeout
    return [expr ![string match "eof" $result]]
}



# Start the monkey test--only called by monkey_test.  Return <0 on failure.
proc monkey_start {type sym lib} {
    global test victim
    global pins buses attributes
    global num_state_snapshots
    global state_snapshots
    global state_snapshot_attrs state_snapshot_bad_attrs
    
    sid_config_component_test_with_tracing \
	    "monkey.conf" "load $lib $sym" $type
	    
    sid_start "monkey.conf"
    if {$victim == ""} then { fail "$test - sid startup"; return -1 }
   
    catch {unset pins buses attributes}
    set pins [sid_cmd [list sid::component::pin_names $victim]]
    set buses [sid_cmd [list sid::component::bus_names $victim]]
    set attributes [sid_cmd [list sid::component::attribute_names $victim]]

    catch {unset num_state_snapshots state_snapshots state_snapshot_attrs state_snapshot_bad_attrs}
    set num_state_snapshots 0
    set state_snapshot_bad_attrs [list]

    return 0
}

proc monkey_stop {} {
    global exit_status

    sid_stop
    # zap temp file if tests were successful 
    global exit_status
    if {$exit_status == "0"} then { file delete "monkey.conf" }
}


# Monkey test a pin (decided at runtime).
proc monkey_test_pin {} {
    global pins victim

    # Pick a random pin.
    if {[llength $pins] == 0} then { return }
    set pin [lindex $pins [random [llength $pins]]]
    if {! [pin_safe_p $pin]} then { return }

    set handle [sid_cmd [list sid::component::find_pin $victim $pin]]
    if {$handle == ""} then {
	# probably just output-only pin
	return
    }

    # Value-carrying pin.
    set value [random [expr int(pow(2,16))]]
    set result [sid_cmd [list sid::pin::driven_h4 $handle $value]]
   
    # sid::pin::driven_h4 returns nothing!
    # if [string match "" $result] then { return "eof" }
}

# Monkey test a bus (transaction type and width decided at runtime).
# The entire 2^32 address space is not tested, but the important
# addresses lie in the 0 to 1K range.

proc monkey_test_bus {} {
    global buses victim

    # Pick a random bus.
    if {[llength $buses] == 0} then { return }
    set bus [lindex $buses [random [llength $buses]]]
    if {! [bus_safe_p $bus]} then { return }

    set handle [sid_cmd [list sid::component::find_bus $victim $bus]]

    # Pick an endianness.
    if {[random 2] > 0} { set endian b } else { set endian l }

    # Pick data width.
    switch [random 4] {
	0 { set width 1 }
	1 { set width 2 }
	2 { set width 4 }
	3 { set width 8 }
	default { warning "This should never happen!" }
    }

    # Pick address.
    set addr [random [expr int(pow(2,30))]]

    # Pick read or write operation.
    if {[random 2] > 0} { set op write } else { set op read }
    
    # Do the operation.
    if {$op == "write"} {
	switch $width {
	    1 { set data [random 256] }
	    2 { set data [random 65536] }
	    4 { set data [random [expr int(pow(2,30))]] }
	    8 { set data [random [expr int(pow(2,30))]] }
	}
	set result [sid_cmd [list sid::bus::write_h4_$endian$width $handle $addr $data]]
    } else {
	set result [sid_cmd [list sid::bus::read_h4_$endian$width $handle $addr]]
    }
    if [string match "" $result] then { return "eof" }
}    

# Monkey test an attribute (decided at runtime).
# A random string of garbage, composed of a random number of
# characters from $charset is used.

proc monkey_test_attribute {} {
    global charset numchars
    global attributes victim

    # Pick a random attribute.
    if {[llength $attributes] == 0} then { return }
    set attr [lindex $attributes [random [llength $attributes]]]
    if {! [attr_safe_p $attr]} then { return }

    set garbage [random_string]
    set result [sid_cmd [list sid::component::set_attribute_value $victim $attr [list $garbage]]]
    if [string match "" $result] then { return "eof" }
}


# Accumulate a state snapshot of the target component.
# Collect both the "state-snapshot" attribute, and also pin/register/setting attributes.
proc monkey_test_state_save {} {
    global num_state_snapshots
    global state_snapshots
    global state_snapshot_attrs
    global victim

    # do no work if this is deemed unsafe
    if {! [state_safe_p]} then { return }

    set state [sid_cmd [list sid::component::attribute_value $victim state-snapshot]]
    if {$state == ""} then {
	# state save/restore apparently not supported
	return
    }

    incr num_state_snapshots
    set state_snapshots($num_state_snapshots) $state

    # fetch all user-visible attribute names
    set attrnames [list]
    foreach category {pin setting register} {
	set attrlist [sid_cmd [list sid::component::attribute_names_in_category $victim $category]]
	foreach an $attrlist {
	    lappend attrnames $an
	}
    }
    # collect their current values 
    foreach attrname $attrnames {
	set attrvalue [sid_cmd [list sid::component::attribute_value $victim $attrname]]
	set state_snapshot_attrs($num_state_snapshots,$attrname) $attrvalue
    }
}


# Pick a random state snapshot accumulated from the target component and attempt to
# restore it.  Confirm that user-visible attributes are back to their old values.
proc monkey_test_state_restore {} {
    global num_state_snapshots
    global state_snapshots
    global state_snapshot_attrs state_snapshot_bad_attrs
    global victim
    global test

    if {$num_state_snapshots == 0} then {
	return
    }

    set pick [expr [random $num_state_snapshots] + 1]

    set state $state_snapshots($pick)
    set result [sid_cmd [list sid::component::set_attribute_value $victim state-snapshot $state]]
    if {$result != "ok"} then {
	# don't warn over and over again - dummy attribute
	set attrname "state-snapshot"
	if {[lsearch -exact $state_snapshot_bad_attrs $attrname] == -1} then {
	    warning "$test - state restore failed"
	    lappend state_snapshot_bad_attrs $attrname
	}
    }

    # fetch all user-visible attribute names
    set attrnames [list]
    foreach category {pin setting register} {
	set attrlist [sid_cmd [list sid::component::attribute_names_in_category $victim $category]]
	foreach an $attrlist {
	    lappend attrnames $an
	}
    }
    # compare their current values 
    foreach attrname $attrnames {
	set attrvalue1 [sid_cmd [list sid::component::attribute_value $victim $attrname]]
	set attrvalue2 $state_snapshot_attrs($pick,$attrname)
	if {$attrvalue1 != $attrvalue2} then {
	    # quietly accept failure for known-unsaved attributes
	    if {! [state_saved_p $attrname]} then {
		lappend state_snapshot_bad_attrs $attrname
	    }
	    # don't warn over and over again
	    if {[lsearch -exact $state_snapshot_bad_attrs $attrname] == -1} then {
		warning "$test - state restore did not preserve $attrname"
		lappend state_snapshot_bad_attrs $attrname
	    }
	}
    }
}
@


1.10
log
@* mild test cleanup

2001-09-25  Frank Ch. Eigler  <fche@@redhat.com>

        * lib/monkey.exp (do_one_test): Set a short timeout.
        (monkey_start): Don't use sid_find_file to look for victim's
        component library.
        * config/default.exp (sid_cmd): Use "\r" (not "\n") as send EOL.
        * sidcomp.mapper/busif.exp (sid_read_write): Ditto.
@
text
@d186 2
d189 3
@


1.9
log
@2001-09-21  Frank Ch. Eigler  <fche@@redhat.com>

	* lib/monkey.exp (monkey_test_state_restore): Undo this change.
@
text
@d133 4
a136 1
    global num_state_snapshots
d139 1
d152 2
d168 1
a168 1
	    "monkey.conf" "load [sid_find_file $lib] $sym" $type
@


1.8
log
@* resilience tweak

2001-09-20  Frank Ch. Eigler  <fche@@redhat.com>

        * lib/monkey.exp (monkey_test_attribute): Add another paranoid
        level of tcl quoting for garbage strings.
        (monkey_test_state_restore): Ditto.
@
text
@d325 1
a325 1
    set result [sid_cmd [list sid::component::set_attribute_value $victim state-snapshot [list $state]]]
@


1.7
log
@* duh bug fixes

2001-08-23  Frank Ch. Eigler  <fche@@redhat.com>

	* lib/monkey.exp (monkey_stop): New routine.
	(monkey_test): Upon failure in test loop, break out, to always
	call `monkey_stop'.
	(monkey_test_pin): Don't mistakenly return "eof".
@
text
@d268 1
a268 1
    set result [sid_cmd [list sid::component::set_attribute_value $victim $attr $garbage]]
d325 1
a325 1
    set result [sid_cmd [list sid::component::set_attribute_value $victim state-snapshot $state]]
@


1.6
log
@2001-06-22  Ben Elliston  <bje@@redhat.com>

	* lib/monkey.exp (monkey_test): If an individual monkey test
	fails, bail out immediately.
@
text
@d95 1
d110 1
a110 1
	    if {[do_one_test] == 0} then return
d114 1
a114 1
	    if {[do_one_test] == 0} then return
d117 2
a118 2
    sid_stop
    pass "$test ($iterations iterations)"
d179 5
d202 3
a204 1
    if [string match "" $result] then { return "eof" }
@


1.5
log
@2001-06-22  Ben Elliston  <bje@@redhat.com>

	* lib/monkey.exp (monkey_test): Correct logic thinko when deciding
	whether or not to output the finishing time.
@
text
@d4 1
a4 1
# Copyright (C) 2000 Red Hat
d10 4
a13 2
# State save/restore functionality is sometimes tested also.  It confirms that
# standard attributes recover their save-time values at any subsequent restore. 
d109 1
a109 1
	    do_one_test
d113 1
a113 1
	    do_one_test
d137 1
a137 1
	monkey_test_pin
d139 1
a139 1
	monkey_test_bus
d141 1
a141 1
	monkey_test_attribute
d143 1
a143 1
	monkey_test_state_save
d145 1
a145 1
	monkey_test_state_restore
d147 1
d195 2
a196 1
    sid_cmd [list sid::pin::driven_h4 $handle $value]
d239 1
a239 1
	sid_cmd [list sid::bus::write_h4_$endian$width $handle $addr $data]
d241 1
a241 1
	sid_cmd [list sid::bus::read_h4_$endian$width $handle $addr]
d243 1
d260 2
a261 1
    sid_cmd [list sid::component::set_attribute_value $victim $attr $garbage]
@


1.4
log
@2001-06-18  Ben Elliston  <bje@@redhat.com>

	* lib/monkey.exp (monkey_test): Only notify the user of the test
	completion time if the test is going to take more than 60 seconds
	to run.
@
text
@d103 1
a103 1
        if {[clock seconds] - $finishtime > 60} {
@


1.3
log
@2001-05-31  Ben Elliston  <bje@@redhat.com>

	* lib/docs.exp (doc_includes_component): Fail on regexp misses.
	* lib/monkey.exp (monkey_test): Re-enable tests.
	* sidcomp.ide/diskio.exp: Unset $contents at completion.
@
text
@d103 3
a105 1
	note "Testing $type until [clock format $finishtime]"
@


1.2
log
@* bad monkey, no banana

2001-03-01  Frank Ch. Eigler  <fche@@redhat.com>

	* lib/monkey.exp (monkey_test): Disabled this class of tests
	temporarily.
@
text
@a77 5

    # Disable this class of tests, until dejagnu/expect/tcl/sid
    # misinteractions are analyzed.
    return
    
a80 1
    
@


1.1
log
@* public snapshot of sid simulator
@
text
@d78 5
d86 1
a86 1

@

