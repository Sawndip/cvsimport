head	1.13;
access;
symbols
	sid-snapshot-20180601:1.13
	sid-snapshot-20180501:1.13
	sid-snapshot-20180401:1.13
	sid-snapshot-20180301:1.13
	sid-snapshot-20180201:1.13
	sid-snapshot-20180101:1.13
	sid-snapshot-20171201:1.13
	sid-snapshot-20171101:1.13
	sid-snapshot-20171001:1.13
	sid-snapshot-20170901:1.13
	sid-snapshot-20170801:1.13
	sid-snapshot-20170701:1.13
	sid-snapshot-20170601:1.13
	sid-snapshot-20170501:1.13
	sid-snapshot-20170401:1.13
	sid-snapshot-20170301:1.13
	sid-snapshot-20170201:1.13
	sid-snapshot-20170101:1.13
	sid-snapshot-20161201:1.13
	sid-snapshot-20161101:1.13
	sid-snapshot-20160901:1.13
	sid-snapshot-20160801:1.13
	sid-snapshot-20160701:1.13
	sid-snapshot-20160601:1.13
	sid-snapshot-20160501:1.13
	sid-snapshot-20160401:1.13
	sid-snapshot-20160301:1.13
	sid-snapshot-20160201:1.13
	sid-snapshot-20160101:1.13
	sid-snapshot-20151201:1.13
	sid-snapshot-20151101:1.13
	sid-snapshot-20151001:1.13
	sid-snapshot-20150901:1.13
	sid-snapshot-20150801:1.13
	sid-snapshot-20150701:1.13
	sid-snapshot-20150601:1.13
	sid-snapshot-20150501:1.13
	sid-snapshot-20150401:1.13
	sid-snapshot-20150301:1.13
	sid-snapshot-20150201:1.13
	sid-snapshot-20150101:1.13
	sid-snapshot-20141201:1.13
	sid-snapshot-20141101:1.13
	sid-snapshot-20141001:1.13
	sid-snapshot-20140901:1.13
	sid-snapshot-20140801:1.13
	sid-snapshot-20140701:1.13
	sid-snapshot-20140601:1.13
	sid-snapshot-20140501:1.13
	sid-snapshot-20140401:1.13
	sid-snapshot-20140301:1.13
	sid-snapshot-20140201:1.13
	sid-snapshot-20140101:1.13
	sid-snapshot-20131201:1.13
	sid-snapshot-20131101:1.13
	sid-snapshot-20131001:1.13
	sid-snapshot-20130901:1.13
	sid-snapshot-20130801:1.13
	sid-snapshot-20130701:1.13
	sid-snapshot-20130601:1.13
	sid-snapshot-20130501:1.13
	sid-snapshot-20130401:1.13
	sid-snapshot-20130301:1.13
	sid-snapshot-20130201:1.13
	sid-snapshot-20130101:1.13
	sid-snapshot-20121201:1.13
	sid-snapshot-20121101:1.13
	sid-snapshot-20121001:1.13
	sid-snapshot-20120901:1.13
	sid-snapshot-20120801:1.13
	sid-snapshot-20120701:1.13
	sid-snapshot-20120601:1.13
	sid-snapshot-20120501:1.13
	sid-snapshot-20120401:1.13
	sid-snapshot-20120301:1.13
	sid-snapshot-20120201:1.13
	sid-snapshot-20120101:1.13
	sid-snapshot-20111201:1.13
	sid-snapshot-20111101:1.13
	sid-snapshot-20111001:1.13
	sid-snapshot-20110901:1.13
	sid-snapshot-20110801:1.13
	sid-snapshot-20110701:1.13
	sid-snapshot-20110601:1.13
	sid-snapshot-20110501:1.13
	sid-snapshot-20110401:1.13
	sid-snapshot-20110301:1.13
	sid-snapshot-20110201:1.13
	sid-snapshot-20110101:1.13
	sid-snapshot-20101201:1.13
	sid-snapshot-20101101:1.13
	sid-snapshot-20101001:1.13
	sid-snapshot-20100901:1.13
	sid-snapshot-20100801:1.13
	sid-snapshot-20100701:1.13
	sid-snapshot-20100601:1.13
	sid-snapshot-20100501:1.13
	sid-snapshot-20100401:1.13
	sid-snapshot-20100301:1.13
	sid-snapshot-20100201:1.13
	sid-snapshot-20100101:1.13
	sid-snapshot-20091201:1.13
	sid-snapshot-20091101:1.13
	sid-snapshot-20091001:1.13
	sid-snapshot-20090901:1.13
	sid-snapshot-20090801:1.13
	sid-snapshot-20090701:1.13
	sid-snapshot-20090601:1.13
	sid-snapshot-20090501:1.13
	sid-snapshot-20090401:1.13
	sid-snapshot-20090301:1.13
	sid-snapshot-20090201:1.13
	sid-snapshot-20090101:1.13
	sid-snapshot-20081201:1.13
	sid-snapshot-20081101:1.13
	sid-snapshot-20081001:1.13
	sid-snapshot-20080901:1.13
	sid-snapshot-20080801:1.13
	sid-snapshot-20080701:1.13
	sid-snapshot-20080601:1.13
	sid-snapshot-20080501:1.13
	sid-snapshot-20080403:1.13
	sid-snapshot-20080401:1.13
	sid-snapshot-20080301:1.13
	sid-snapshot-20080201:1.13
	sid-snapshot-20080101:1.13
	sid-snapshot-20071201:1.13
	sid-snapshot-20071101:1.13
	sid-snapshot-20071001:1.13
	sid-20020905-branchpoint:1.4
	sid-20020905-branch:1.4.0.2
	cygnus_cvs_20020108_pre:1.2;
locks; strict;
comment	@ * @;


1.13
date	2006.05.11.15.08.51;	author brolley;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.19.19.45.22;	author brolley;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.29.19.10.39;	author scox;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.10.23.10.51;	author fche;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.29.20.27.32;	author brolley;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.26.16.44.40;	author brolley;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.23.20.08.53;	author brolley;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.12.20.30.08;	author brolley;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.21.21.30.44;	author brolley;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.05.16.36.48;	author brolley;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.05.16.33.02;	author brolley;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.13.14.26.05;	author mrg;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.07.19.30.54;	author fche;	state Exp;
branches;
next	;


desc
@@


1.13
log
@2006-05-11  Dave Brolley  <brolley@@redhat.com>

        * elfload.c (readElfFile): symTabEntry is now 24 bytes in length.
        Add 64 bit support for SHT_STRTAB and SHT_SYMTAB. Add 64 bit support
        for reading the symbol table.
@
text
@/* Simple ELF loader
 *
 * Copyright (c) 1998, 2002, 2004, 2005, 2006 Red Hat
 *
 * The authors hereby grant permission to use, copy, modify, distribute,
 * and license this software and its documentation for any purpose, provided
 * that existing copyright notices are retained in all copies and that this
 * notice is included verbatim in any distributions. No written agreement,
 * license, or royalty fee is required for any of the authorized uses.
 * Modifications to this software may be copyrighted by their authors
 * and need not follow the licensing terms described here, provided that
 * the new terms are clearly indicated on the first page of each file where
 * they apply.
 */
#include <elfload.h>
#include <unistd.h>
#include "libiberty.h"

#define PT_LOAD 1

/* The loadAreas table is reused by each loader.  */
static struct LoadAreas
{
  unsigned long long loadAddr;
  unsigned long long filesize;
  unsigned long long offset;
  int flags;
  int loaded;
} *loadAreas = 0;

static void
newLoadArea (int index)
{
  static loadAreaNum = 0;
  if (index >= loadAreaNum)
    {
      loadAreaNum = index + 10;
      loadAreas = xrealloc (loadAreas, loadAreaNum * sizeof (*loadAreas));
    }
}

/* A new section table is created for each loader in the system.  */
static struct TextSection *textSections;
static int textSectionCount;
static int textSectionNum;

static void
newTextSection (int index)
{
  if (index >= textSectionNum)
    {
      textSectionNum = index + 10;
      textSections = xrealloc (textSections, textSectionNum * sizeof (*textSections));
    }
}

int
textSectionAddress (unsigned long long address, const struct TextSection *section_table)
{
  int i;

  /* Not a text section address if there is no table.  */
  if (! section_table)
    return 0;

  /* The table begins with the given pointer and is terminated by an entry with
     zeroes for both the high and low bounds.  */
  for (i = 0; section_table[i].lbound != 0 || section_table[i].hbound != 0; i++)
    {
      if (section_table[i].lbound <= address
	  && address <= section_table[i].hbound)
	return 1;
    }
  return 0;
}

/* A new string table table is created for each loader in the system.  */
static struct StringTable *stringTables;
static int stringTableCount;
static int stringTableNum;

static void
newStringTable (int index)
{
  if (index >= stringTableNum)
    {
      stringTableNum = index + 10;
      stringTables = xrealloc (stringTables, stringTableNum * sizeof (*stringTables));
    }
}

/* A new symbol table is created for each loader in the system.  */
static struct Symbol *symbolTable;
static int symbolCount;
static int symbolNum;

static void
newSymbol (int index)
{
  if (index >= symbolNum)
    {
      symbolNum = index + 10;
      symbolTable = xrealloc (symbolTable, symbolNum * sizeof (*symbolTable));
    }
}


/* Read in an ELF file, using FUNC to read data from the stream.
   The result is a boolean indicating success.
   The entry point as specified in the ELF header is stored in *ENTRY_POINT.
   The endianness as specified in the ELF header is stored in *LITTLE_ENDIAN.
*/

int
readElfFile (PFLOAD func, unsigned* entry_point, int* little_endian,
	     unsigned* e_flags, const struct TextSection **section_table,
	     const struct Symbol **symbol_table)
{
  unsigned char fileHeader [64];
  unsigned char psymHdr [56];
  unsigned char secHdr [64];
  unsigned char symTabEntry [24];
  unsigned long long psymOffset;
  int psymSize;
  int psymNum;
  unsigned long long symbolTableOffset;
  unsigned long long symbolTableSize;
  unsigned long long symbolTableStringTableIx;
  int eFlags;
  unsigned long long secOffset;
  int secSize;
  int secNum;
  unsigned long long entryPoint = 0;
  int x;
  int littleEndian;
  int sixtyfourbit;
  int loadAreaCount = 0;

  /* This is relatively straightforward. We first read in the file header,
     find out how many sections there are, determine which ones are loadable
     (via the psym header), and load them.

     There is one major failing, tho--if the psym header isn't at the front
     of the file, and we're loading from a stream that we can't back
     up on, we will lose.  */
  if (func (0, fileHeader, 0, 64, 0) != 64)
    {
      return 0;
    }

  /* Check this is an ELF file.  */
  if (fileHeader[0] != 0x7f
    || fileHeader[1] != 'E'
    || fileHeader[2] != 'L'
    || fileHeader[3] != 'F')
      return 0;

  sixtyfourbit = (fileHeader[EI_CLASS] == ELFCLASS64);
  littleEndian = (fileHeader[EI_DATA] == ELFDATA2LSB);

  if (sixtyfourbit) 
    {
      entryPoint = fetchQuad (fileHeader+24, littleEndian);
      psymOffset = fetchQuad (fileHeader+32, littleEndian);
      eFlags = fetchWord (fileHeader+40, littleEndian);
      psymSize = fetchShort (fileHeader+54, littleEndian);
      psymNum = fetchShort (fileHeader+56, littleEndian);
    }
  else
    {
      entryPoint = fetchWord (fileHeader+24, littleEndian);
      psymOffset = fetchWord (fileHeader+28, littleEndian);
      eFlags = fetchWord (fileHeader+36, littleEndian);
      psymSize = fetchShort (fileHeader+42, littleEndian);
      psymNum = fetchShort (fileHeader+44, littleEndian);
    }
  for (x = 0; x < psymNum; x++)
    {
      if (func (0, psymHdr, psymOffset, psymSize, 0) != psymSize)
	{
	  return 0;
	}
      if (sixtyfourbit)
        {
	  if (fetchWord (psymHdr, littleEndian) == PT_LOAD)
	    {
	      newLoadArea (loadAreaCount);
	      loadAreas[loadAreaCount].loadAddr = fetchQuad(psymHdr+24,
							    littleEndian);
	      loadAreas[loadAreaCount].offset = fetchQuad(psymHdr+8, littleEndian);
	      loadAreas[loadAreaCount].filesize = fetchQuad(psymHdr+32,
							    littleEndian);
	      loadAreas[loadAreaCount].flags = fetchWord(psymHdr+4, littleEndian);
	      loadAreas[loadAreaCount].loaded = 0;
	      loadAreaCount++;
	    }
        }
      else
        {
	  if (fetchWord (psymHdr, littleEndian) == PT_LOAD)
	    {
	      newLoadArea (loadAreaCount);
	      loadAreas[loadAreaCount].loadAddr = fetchWord(psymHdr+12,
								    littleEndian);
	      loadAreas[loadAreaCount].offset = fetchWord(psymHdr+4, littleEndian);
	      loadAreas[loadAreaCount].filesize = fetchWord(psymHdr+16,
							    littleEndian);
	      loadAreas[loadAreaCount].flags = fetchWord(psymHdr+24, littleEndian);
	      loadAreas[loadAreaCount].loaded = 0;
	      loadAreaCount++;
	    }
        }
      psymOffset += psymSize;
    }
  /* Yuck. N^2 behavior (where N is the # of loadable sections). */
  for (x = 0; x < loadAreaCount; x++)
    {
      int which, is_insn;
      int smallest = -1, smallestSz = -1;
      /* Find smallest not-loaded */
      for (which = 0; which < loadAreaCount; which++)
	{
	  if (! loadAreas[which].loaded)
	    {
	      if (smallest < 0 || loadAreas[which].offset < smallestSz)
		{
		  smallest = which;
		  smallestSz = loadAreas[which].offset;
		}
	    }
	}
      is_insn = (((loadAreas[smallest].loadAddr) & PF_X|PF_R) == (PF_X|PF_R))
	      || ((loadAreas[smallest].loadAddr >> 32) & 1);
      if (func (loadAreas[smallest].loadAddr,
		NULL,
		loadAreas[smallest].offset,
		loadAreas[smallest].filesize,
		is_insn) != loadAreas[smallest].filesize)
	{
	  return 0;
	}
      loadAreas[smallest].loaded = 1;
    }

  /* FIXME: If no program segment header, loop over sections instead.  */
  /* FIXME: admin part of program segment is loaded.  */

  /* Look in the section table in order to determine which sections contain
     code, data, symbols and strings.  */
  if (sixtyfourbit) 
    {
      secOffset = fetchQuad (fileHeader+40, littleEndian);
      secSize = fetchShort (fileHeader+58, littleEndian);
      secNum = fetchShort (fileHeader+60, littleEndian);
    }
  else
    {
      secOffset = fetchWord (fileHeader+32, littleEndian);
      secSize = fetchShort (fileHeader+46, littleEndian);
      secNum = fetchShort (fileHeader+48, littleEndian);
    }
  textSections = 0;
  textSectionNum = 0;
  textSectionCount = 0;
  stringTables = 0;
  stringTableNum = 0;
  stringTableCount = 0;
  newTextSection (textSectionCount);
  for (x = 0; x < secNum; x++)
    {
      if (func (0, secHdr, secOffset, secSize, 0) != secSize)
	{
	  return 0;
	}
      if (sixtyfourbit)
        {
	  if (fetchQuad(secHdr+8, littleEndian) & SHF_EXECINSTR)
	    {
	      textSections[textSectionCount].lbound = 
		fetchQuad(secHdr+16, littleEndian);
	      textSections[textSectionCount].hbound = 
		textSections[textSectionCount].lbound
		+ fetchQuad(secHdr+32, littleEndian) - 1;
	      textSectionCount++;
	      newTextSection (textSectionCount);
	    }
	  else if (fetchWord(secHdr+4, littleEndian) == SHT_STRTAB)
	    {
	      unsigned offset = fetchQuad(secHdr+24, littleEndian);
	      unsigned size = fetchQuad(secHdr+32, littleEndian);
	      char *strings = xmalloc (size);
	      newStringTable (stringTableCount);
	      stringTables[stringTableCount].ix = x;
	      stringTables[stringTableCount].strings = strings;
	      if (func (0, strings, offset, size, 0) != size)
		return 0;
	      ++stringTableCount;
	    }
	  else if (fetchWord(secHdr+4, littleEndian) == SHT_SYMTAB)
	    {
	      symbolTableOffset = fetchQuad(secHdr+24, littleEndian);
	      symbolTableSize = fetchQuad(secHdr+32, littleEndian);
	      symbolTableStringTableIx = fetchWord(secHdr+40, littleEndian);
	    }
        }
      else
        {
	  unsigned flags = fetchWord(secHdr+8, littleEndian);
	  if (flags & SHF_EXECINSTR)
	    {
	      textSections[textSectionCount].lbound = 
		fetchWord(secHdr+12, littleEndian);
	      textSections[textSectionCount].hbound = 
		textSections[textSectionCount].lbound
		+ fetchWord(secHdr+20, littleEndian) - 1;
	      textSectionCount++;
	      newTextSection (textSectionCount);
	    }
	  else if (fetchWord(secHdr+4, littleEndian) == SHT_STRTAB)
	    {
	      unsigned offset = fetchWord(secHdr+16, littleEndian);
	      unsigned size = fetchWord(secHdr+20, littleEndian);
	      char *strings = xmalloc (size);
	      newStringTable (stringTableCount);
	      stringTables[stringTableCount].ix = x;
	      stringTables[stringTableCount].strings = strings;
	      if (func (0, strings, offset, size, 0) != size)
		return 0;
	      ++stringTableCount;
	    }
	  else if (fetchWord(secHdr+4, littleEndian) == SHT_SYMTAB)
	    {
	      symbolTableOffset = fetchWord(secHdr+16, littleEndian);
	      symbolTableSize = fetchWord(secHdr+20, littleEndian);
	      symbolTableStringTableIx = fetchWord(secHdr+24, littleEndian);
	    }
        }
      secOffset += secSize;
    }

  /* Terminate this portion of the section table.  */
  textSections[textSectionCount].lbound = 0;
  textSections[textSectionCount].hbound = 0;

  /* Can't look for functions in the symbol table until all the sections have been
     examined, since the string table for the symbol table may follow the symbol
     table itself.  Identify the correct string table first.  */
  const char *strings = 0;
  for (x = 0; x < stringTableCount; ++x)
    {
      if (stringTables[x].ix == symbolTableStringTableIx)
	strings = stringTables[x].strings;
    }

  /* Now look for functions and record their addresses and lengths.  */
  symbolTable = 0;
  symbolCount = 0;
  symbolNum = 0;
  newSymbol (symbolCount);
  if (strings)
    {
      const unsigned symTabEntrySize = sixtyfourbit ? 24 : 16;
      for (x = 0; x < symbolTableSize; x += symTabEntrySize)
	{
	  if (func (0, symTabEntry, symbolTableOffset + x, symTabEntrySize, 0) != symTabEntrySize)
	    return 0;
	  // TODO: Save only symbols representing functions
	  // PROBLEM: Some don't have the STT_FUNC flag set
	  if (sixtyfourbit)
	    {
	      symbolTable[symbolCount].name = strings + fetchWord(symTabEntry+0, littleEndian);
	      symbolTable[symbolCount].addr = fetchQuad(symTabEntry+8, littleEndian);
	      symbolTable[symbolCount].size = fetchQuad(symTabEntry+16, littleEndian);
	    }
	  else
	    {
	      symbolTable[symbolCount].name = strings + fetchWord(symTabEntry+0, littleEndian);
	      symbolTable[symbolCount].addr = fetchWord(symTabEntry+4, littleEndian);
	      symbolTable[symbolCount].size = fetchWord(symTabEntry+8, littleEndian);
	    }
#if 0
	  printf ("found symbol %s at 0x%Lx for 0x%Lx\n",
		  symbolTable[symbolCount].name,
		  symbolTable[symbolCount].addr,
		  symbolTable[symbolCount].size);
#endif
	  symbolCount++;
	  newSymbol (symbolCount);
	}
    }
  // Terminate the symbol table.
  symbolTable[symbolCount].name = 0;

  *entry_point = entryPoint;
  *little_endian = littleEndian;
  *section_table = textSections;
  *symbol_table = symbolTable;
  *e_flags = eFlags;

  return 1;
}
@


1.12
log
@2005-08-19  Dave Brolley  <brolley@@redhat.com>

        * Contribute the following changes:

        2005-07-13  Dave Brolley  <brolley@@redhat.com>

        * compLoader.cxx (generic_loader): Inherit virtually from
        fixed_attribute_map_component. Inherit from no_relation_component.

        2005-06-06  Dave Brolley  <brolley@@redhat.com>

        * elfload.c (readElfFile): Return and empty symbol table if none found.

        * compLoader.cxx: Add using cleause for
        sidutil::configurable_component.
        (generic_loader): fixed_pin_map_component and configurable_component
        inherited virtually.
        (configure): New virtual override in generic_loader.
        (check_function_pin_handler): Return the empty string if no function
        is associated with the given address.
        * sw-load-elf.xml: Add description of new interfaces.
        * sw-load-elf.txt: Regenerated.

        2005-05-29  Dave Brolley  <brolley@@redhat.com>

        * elfload.h (StringTable, Symbol): New struct types.
        (readElfFile): New takes symbol_table argument.
        (SHT_SYMTAB, SHT_STRTAB, ELF32_ST_TYPE, STT_FUNC): New macros.
        * elfload.c (stringTables,stringTableCount,stringTableNum): New
        static variables.
        (newStringTable): New static function.
        (symbolTable,symbolCount,symbolNum): New static variables.
        (newSymbol): New static function.
        (readElfFile): New takes symbol_table argument. Build string tables and
        symbol table while reading the input file.
        * compLoader.cxx (elf_loader): New constructor.
        (load_it): Obtain symmol_table from readElfFile.
        (check_function_pin,symbol_table,current_function): New members
        of elf_loader.
        (check_function_pin_handler): New method of elf_loader.
@
text
@d3 1
a3 1
 * Copyright (c) 1998, 2002, 2004, 2005 Red Hat
d122 1
a122 1
  unsigned char symTabEntry [16];
d287 18
d362 2
a363 1
      for (x = 0; x < symbolTableSize; x += sizeof (symTabEntry))
d365 1
a365 1
	  if (func (0, symTabEntry, symbolTableOffset + x, sizeof (symTabEntry), 0) != sizeof (symTabEntry))
d369 12
a380 3
	  symbolTable[symbolCount].name = strings + fetchWord(symTabEntry+0, littleEndian);
	  symbolTable[symbolCount].addr = fetchWord(symTabEntry+4, littleEndian);
	  symbolTable[symbolCount].size = fetchWord(symTabEntry+8, littleEndian);
@


1.11
log
@	* compLoader.cxx (generic_loader):  Add eflags_pin.
	(elf_loader): Add eflags.
	(load_it): Set eflags.
	* elfload.c (readElfFile): Add eflags.
	* sidcpuutil.h (basic_cpu): Add eflags_set_pin, set_eflags.
	* commonCfg.cxx (add_cpu):  Add eflags-set pin.
@
text
@d3 1
a3 1
 * Copyright (c) 1998, 2002, 2004 Red Hat
d62 1
a62 1
  // Not a text section address if there is no table.
d77 30
d116 2
a117 1
	     unsigned* e_flags, const struct TextSection **section_table)
d122 1
d126 3
d249 1
a249 5
     code and which contain data.  */
  textSections = 0;
  textSectionNum = 0;
  textSectionCount = 0;
  newTextSection (textSectionCount);
d262 7
d290 2
a291 1
	  if (fetchWord(secHdr+8, littleEndian) & SHF_EXECINSTR)
d301 18
d327 39
d369 1
@


1.10
log
@2004-05-10  Frank Ch. Eigler  <fche@@elastic.org>

	* elfload.c (textSectionAddress): Fix declaration placement typo.
@
text
@d85 2
a86 1
readElfFile (PFLOAD func, unsigned* entry_point, int* little_endian, const struct TextSection **section_table)
d94 1
d130 1
d138 1
d273 1
@


1.9
log
@2004-04-29  Dave Brolley  <brolley@@redhat.com>

        * elfload.c (textSectionAddress): Check section table before accessing.
        * compLoader.cxx (loader_probe_bus): Initialize section_table.
@
text
@d60 2
a67 1
  int i;
@


1.8
log
@2004-02-26  Dave Brolley  <brolley@@redhat.com>

        * elfload.c (textSectionNum): Now file level static.
        (readElfFile): Initialize textSections, textSectionNum and
        textSectionCount for each load. Set *section_table after all
        sections have been saved.
@
text
@d60 4
@


1.7
log
@2004-02-23  Dave Brolley  <brolley@@redhat.com>

        * elfload.c (readElfFile): Get address from offset 16 for 64 bit and
        offset 12 for 16 bit.
@
text
@d42 4
a45 4
/* The section table is kept for the duration of the simulation.
   It is divided into sub tables, one for each loader in the system.  */
static int textSectionCount = 0;
static struct TextSection *textSections = 0;
a49 1
  static textSectionNum = 0;
d206 3
a209 1
  *section_table = textSections + textSectionCount;
a259 1
  textSectionCount++;
d263 2
@


1.6
log
@2004-02-12  Dave Brolley  <brolley@@redhat.com>

        * elfload.h: Use 'unsigned long long' instead of host_int_8.
        (struct TextSection): Moved here from elfload.c
        (SHF_EXECINSTR): New macro.
        * elfload.c (loadAreas): Now a pointer to a dynamically allocated
        table.
        (textSections): Ditto.
        (newLoadArea): New static function.
        (newTextSection): Ditto.
        (textSectionAddress): Now takes a pointer to a section table.
        (readElfFile): fileHeader, psymHdr, secHdr now automatic arrays.
        Allocate loadAreas and textSections as required. Build textSections
        from the ELF section table; one for each executable loaded.
        * compLoader.cxx (sid::host_int_8): Add 'using' clause.
        (textSegmentAddress): renamed to textSectionAddress and moved to
        elfload.h.
        (setSection_table): New method of loader_probe_bus.
        (SID_GB_WRITE): Call textSectionAddress and pass section_table.
        (section_table): New member of loader_probe_bus.
        (load_it): Get section_table address from readElfFile.
        * Makefile.am (LIBIBERTY): New variable.
        (libloader_la_LIBADD): Add $(LIBIBERTY).
        * Makefile.in: Regenerated.
@
text
@d232 1
a232 1
		fetchQuad(secHdr+24, littleEndian);
d245 1
a245 1
		fetchWord(secHdr+16, littleEndian);
@


1.5
log
@2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * compLoader.cxx (loader_probe_bus): Now takes pin as an argument.
        Remove warn_write_to_code_p. Initialize write_to_code_address_pin.
        (SID_GB_WRITE): Drive write_to_code_address_pin instead of
        generating a message here.
        (write_to_code_address_pin): New member of generic_loader.
        (set_warn_write_to_code): Removed.
        (generic_loader): remove "warn-write-to-code?" attribute and pin.
        Add "write-to-code-address" pin.
        * sw-load-elf.xml: Remove reference to "warn-write-to-code?" pin
        and attribute. Document "write-to-code-address" pin.
        * sw-load-elf.txt: Regenerated.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * compLoader.cxx: Use sidutil::fixed_bus_map_component.
        (loader_probe_bus): New class.
        (warn_write_to_code_pin): New member of generic_loader.
        (probe_upstream): Ditto.
        (probe_downstream): Ditto.
        (set_warn_write_to_code): New method of generic_loader.
        (generic_loader): Now inherits fixed_bus_map_component.
        Initialize new members.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        For Stan Cox  <scox@@redhat.com>
        * elfload.c (textSegmentAddress): New function.
        * elfload.h (textSegmentAddress): Likewise.
@
text
@d3 1
a3 1
 * Copyright (c) 1998, 2002 Red Hat
d17 1
a17 3

unsigned char fileHeader [64];
unsigned char psymHdr[56];
d21 2
a22 1
struct LoadAreas
d24 3
a26 3
  host_int_8 loadAddr;
  host_int_8 filesize;
  host_int_8 offset;
d29 1
a29 1
} loadAreas[100]; // XXX: limit on number of loadable sections
d31 2
a32 1
static struct TextSegment
d34 12
a45 5
  host_int_8 lbound;
  host_int_8 hbound;
} textSegments[100];
static int textSegmentsCount = 0;
enum {execute_flag = 1};
d47 10
d59 1
a59 1
textSegmentAddress (int address)
d61 2
d64 1
a64 1
  for (i = 0; i < textSegmentsCount ; i++)
d66 2
a67 2
      if (textSegments[i].lbound <= address
	  && address <= textSegments[i].hbound)
d81 1
a81 1
readElfFile (PFLOAD func, unsigned* entry_point, int* little_endian)
d83 4
a86 1
  host_int_8 psymOffset;
d89 4
a92 2
  host_int_8 entryPoint = 0;
  int loadAreaCount = 0;
d96 1
d105 1
a105 1
  if (func (NULL, fileHeader, 0, 64, 0) != 64)
d136 4
a141 4
	  if (func (NULL, psymHdr, psymOffset, 56, 0) != 56)
	    {
	      return 0;
	    }
d144 1
a151 11
	      
	      if (loadAreas[loadAreaCount].flags & execute_flag)
		{
		  textSegments[textSegmentsCount].lbound = 
		    loadAreas[loadAreaCount].loadAddr;
		  textSegments[textSegmentsCount].hbound = 
		    loadAreas[loadAreaCount].loadAddr
		    + loadAreas[loadAreaCount].filesize;
		  textSegmentsCount++;
		}

a156 4
	  if (func (NULL, psymHdr, psymOffset, 32, 0) != 32)
	    {
	      return 0;
	    }
d159 1
a166 11

	      if (loadAreas[loadAreaCount].flags & execute_flag)
		{
		  textSegments[textSegmentsCount].lbound = 
		    loadAreas[loadAreaCount].loadAddr;
		  textSegments[textSegmentsCount].hbound = 
		    loadAreas[loadAreaCount].loadAddr
		    + loadAreas[loadAreaCount].filesize;
		  textSegmentsCount++;
		}

d204 56
@


1.4
log
@Update copyright date.
@
text
@d32 23
d126 11
d155 11
@


1.3
log
@2002-02-05  Dave Brolley  <brolley@@redhat.com>

	* elfload.c (readElfFile): Obtain the load address from offset 24 for
	elf64 and from offset 12 for elf32.
@
text
@d3 1
a3 1
 * Copyright (c) 1998 Red Hat
@


1.2
log
@[bsp/ChangeLog]
2001-01-13  matthew green  <mrg@@redhat.com>

	* configrun-sid.in: `load-accessor' becomes Harvard architecture
	friendly.  Split into `load-accessor-insn' and `load-accessor-data'.

[component/loader/ChangeLog]
2001-01-13  matthew green  <mrg@@redhat.com>

	* compLoader.cxx (load_accessor): Delete member.
	(load_accessor_insn, load_accessor_data): New bus* members.
	(ctor): Initialise load_accessor_insn and load_accessor_data.
	Add `load-accessor-insn' and `load-accessor-data' accessors
	and delete `load-accessor'.
	(load_function): Extend to 64 bit addresses, and have an instruction
	space identifier.
	(load_it): Check both load_accessor_insn and load_accessor_data are set,
	and use the appropriate one.  Extend messages to meantion instruction or
	data loads.
	* elfload.h (fetchQuadLittle, fetchQuadBig, fetchQuad): New macros.
	(PFLOAD): Make 64-bit & Harvard address space friendly
	(sw-load-elf.txt): Document `load-accessor-insn' and `load-accessor-data'
	accessors.
        * elfload.c (readElfFile): Support 64-bit ELF as well as 32-bit ELF.
	* sw-load-elf.txt: Document `load-accessor-insn' and `load-accessor-data'
	accessors.
@
text
@d96 1
a96 1
	      loadAreas[loadAreaCount].loadAddr = fetchQuad(psymHdr+16,
d114 1
a114 1
	      loadAreas[loadAreaCount].loadAddr = fetchWord(psymHdr+8,
@


1.1
log
@* public snapshot of sid simulator
@
text
@d18 2
a19 2
unsigned char fileHeader [52];
unsigned char psymHdr[32];
d25 4
a28 4
  char *loadAddr;
  int memsize;
  int filesize;
  int offset;
a31 1

d41 1
a41 1
  int psymOffset;
d44 1
a44 1
  unsigned entryPoint = 0;
d48 1
d56 2
a57 2
     up on, we will lose. */
  if (func (NULL, fileHeader, 0, 52) != 52)
d61 9
d71 15
a85 4
  entryPoint = fetchWord (fileHeader+24, littleEndian);
  psymOffset = fetchWord (fileHeader+28, littleEndian);
  psymSize = fetchShort (fileHeader+42, littleEndian);
  psymNum = fetchShort (fileHeader+44, littleEndian);
d88 36
a123 14
      if (func (NULL, psymHdr, psymOffset, 32) != 32)
	{
	  return 0;
	}
      if (fetchWord (psymHdr, littleEndian) == PT_LOAD)
	{
	  loadAreas[loadAreaCount].loadAddr = (char *)fetchWord(psymHdr+8,
								littleEndian);
	  loadAreas[loadAreaCount].offset = fetchWord(psymHdr+4, littleEndian);
	  loadAreas[loadAreaCount].filesize = fetchWord(psymHdr+16,
							littleEndian);
	  loadAreas[loadAreaCount].loaded = 0;
	  loadAreaCount++;
	}
d129 1
a129 1
      int which;
d143 2
d148 2
a149 1
		loadAreas[smallest].filesize) != loadAreas[smallest].filesize)
@

