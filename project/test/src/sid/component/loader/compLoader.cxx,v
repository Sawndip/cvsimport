head	1.13;
access;
symbols
	sid-snapshot-20180601:1.13
	sid-snapshot-20180501:1.13
	sid-snapshot-20180401:1.13
	sid-snapshot-20180301:1.13
	sid-snapshot-20180201:1.13
	sid-snapshot-20180101:1.13
	sid-snapshot-20171201:1.13
	sid-snapshot-20171101:1.13
	sid-snapshot-20171001:1.13
	sid-snapshot-20170901:1.13
	sid-snapshot-20170801:1.13
	sid-snapshot-20170701:1.13
	sid-snapshot-20170601:1.13
	sid-snapshot-20170501:1.13
	sid-snapshot-20170401:1.13
	sid-snapshot-20170301:1.13
	sid-snapshot-20170201:1.13
	sid-snapshot-20170101:1.13
	sid-snapshot-20161201:1.13
	sid-snapshot-20161101:1.13
	sid-snapshot-20160901:1.13
	sid-snapshot-20160801:1.13
	sid-snapshot-20160701:1.13
	sid-snapshot-20160601:1.13
	sid-snapshot-20160501:1.13
	sid-snapshot-20160401:1.13
	sid-snapshot-20160301:1.13
	sid-snapshot-20160201:1.13
	sid-snapshot-20160101:1.13
	sid-snapshot-20151201:1.13
	sid-snapshot-20151101:1.13
	sid-snapshot-20151001:1.13
	sid-snapshot-20150901:1.13
	sid-snapshot-20150801:1.13
	sid-snapshot-20150701:1.13
	sid-snapshot-20150601:1.13
	sid-snapshot-20150501:1.13
	sid-snapshot-20150401:1.13
	sid-snapshot-20150301:1.13
	sid-snapshot-20150201:1.13
	sid-snapshot-20150101:1.13
	sid-snapshot-20141201:1.13
	sid-snapshot-20141101:1.13
	sid-snapshot-20141001:1.13
	sid-snapshot-20140901:1.13
	sid-snapshot-20140801:1.13
	sid-snapshot-20140701:1.13
	sid-snapshot-20140601:1.13
	sid-snapshot-20140501:1.13
	sid-snapshot-20140401:1.13
	sid-snapshot-20140301:1.13
	sid-snapshot-20140201:1.13
	sid-snapshot-20140101:1.13
	sid-snapshot-20131201:1.13
	sid-snapshot-20131101:1.13
	sid-snapshot-20131001:1.13
	sid-snapshot-20130901:1.13
	sid-snapshot-20130801:1.13
	sid-snapshot-20130701:1.13
	sid-snapshot-20130601:1.13
	sid-snapshot-20130501:1.13
	sid-snapshot-20130401:1.13
	sid-snapshot-20130301:1.13
	sid-snapshot-20130201:1.13
	sid-snapshot-20130101:1.13
	sid-snapshot-20121201:1.13
	sid-snapshot-20121101:1.13
	sid-snapshot-20121001:1.13
	sid-snapshot-20120901:1.13
	sid-snapshot-20120801:1.13
	sid-snapshot-20120701:1.13
	sid-snapshot-20120601:1.13
	sid-snapshot-20120501:1.13
	sid-snapshot-20120401:1.13
	sid-snapshot-20120301:1.13
	sid-snapshot-20120201:1.13
	sid-snapshot-20120101:1.13
	sid-snapshot-20111201:1.13
	sid-snapshot-20111101:1.13
	sid-snapshot-20111001:1.13
	sid-snapshot-20110901:1.13
	sid-snapshot-20110801:1.13
	sid-snapshot-20110701:1.13
	sid-snapshot-20110601:1.13
	sid-snapshot-20110501:1.13
	sid-snapshot-20110401:1.13
	sid-snapshot-20110301:1.13
	sid-snapshot-20110201:1.13
	sid-snapshot-20110101:1.13
	sid-snapshot-20101201:1.13
	sid-snapshot-20101101:1.13
	sid-snapshot-20101001:1.13
	sid-snapshot-20100901:1.13
	sid-snapshot-20100801:1.13
	sid-snapshot-20100701:1.13
	sid-snapshot-20100601:1.13
	sid-snapshot-20100501:1.13
	sid-snapshot-20100401:1.13
	sid-snapshot-20100301:1.13
	sid-snapshot-20100201:1.13
	sid-snapshot-20100101:1.13
	sid-snapshot-20091201:1.13
	sid-snapshot-20091101:1.13
	sid-snapshot-20091001:1.13
	sid-snapshot-20090901:1.13
	sid-snapshot-20090801:1.13
	sid-snapshot-20090701:1.13
	sid-snapshot-20090601:1.13
	sid-snapshot-20090501:1.13
	sid-snapshot-20090401:1.13
	sid-snapshot-20090301:1.13
	sid-snapshot-20090201:1.13
	sid-snapshot-20090101:1.13
	sid-snapshot-20081201:1.13
	sid-snapshot-20081101:1.13
	sid-snapshot-20081001:1.13
	sid-snapshot-20080901:1.13
	sid-snapshot-20080801:1.13
	sid-snapshot-20080701:1.13
	sid-snapshot-20080601:1.13
	sid-snapshot-20080501:1.13
	sid-snapshot-20080403:1.13
	sid-snapshot-20080401:1.13
	sid-snapshot-20080301:1.13
	sid-snapshot-20080201:1.13
	sid-snapshot-20080101:1.13
	sid-snapshot-20071201:1.13
	sid-snapshot-20071101:1.13
	sid-snapshot-20071001:1.13
	sid-20020905-branchpoint:1.5
	sid-20020905-branch:1.5.0.2
	cygnus_cvs_20020108_pre:1.5;
locks; strict;
comment	@// @;


1.13
date	2006.06.20.18.40.36;	author brolley;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.01.21.07.01;	author fche;	state Exp;
branches;
next	1.11;

1.11
date	2005.08.19.19.45.22;	author brolley;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.12.16.11.20;	author brolley;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.29.19.10.39;	author scox;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.29.20.27.32;	author brolley;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.12.20.30.08;	author brolley;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.21.21.30.44;	author brolley;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.03.06.02.45;	author mrg;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.22.07.32.52;	author bje;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.03.19.34.38;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2001.01.13.14.26.05;	author mrg;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.07.19.30.54;	author fche;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Fix typo in comment.
@
text
@// compLoader.cxx - object file loader component.  -*- C++ -*-

// Copyright (C) 1999, 2000, 2003, 2004, 2005 Red Hat.
// This file is part of SID and is licensed under the GPL.
// See the file COPYING.SID for conditions for redistribution.

#include <sidcomp.h>
#include <sidso.h>
#include <sidcomputil.h>
#include <sidattrutil.h>
#include <sidpinutil.h>
#include <sidbusutil.h>
#include <sidcpuutil.h>
#include <sidtypes.h>
#include <sidmiscutil.h>

#include <vector>
#include <string>
#include <cstdlib>
#include <ctime>
#include <cerrno>
#include <unistd.h>
#include <fstream>

extern "C" {
#include "elfload.h"
}

using std::vector;
using std::string;
using std::ostream;
using std::istream;
using std::ios;
using std::endl;
using std::cout;
using std::ifstream;
using std::cerr;

using sid::component;
using sid::bus;
using sid::host_int_1;
using sid::little_int_1;
using sid::host_int_4;
using sid::host_int_8;
using sid::component_library;
using sid::COMPONENT_LIBRARY_MAGIC;

using sidutil::fixed_bus_map_component;
using sidutil::fixed_attribute_map_component;
using sidutil::fixed_pin_map_component;
using sidutil::fixed_accessor_map_component;
using sidutil::no_relation_component;
using sidutil::configurable_component;
using sidutil::output_pin;
using sidutil::callback_pin;
using sidutil::string2stream;
using sidutil::stream2string;
using sidutil::make_attribute;
using sidutil::make_numeric_attribute;
using sidutil::parse_attribute;
using sidutil::std_error_string;

// ----------------------------------------------------------------------------

// A bus for allowing the loader to perform random checks against reads and writes
// to memory. For example writing to a code area. Default implementation
class loader_probe_bus: public sidutil::passthrough_bus
  {
  public:
    loader_probe_bus (sid::bus **t, output_pin *p) :
      sidutil::passthrough_bus (t),
      write_to_code_address_pin (p),
      section_table (0)
    {
      assert (t);
    }
    ~loader_probe_bus() throw() {}
    
    void set_section_table (const struct TextSection *s) { section_table = s; }

    void probe_address (sid::host_int_4 addr)
      {
	if (write_to_code_address_pin && textSectionAddress (addr, section_table))
	  write_to_code_address_pin->drive (addr);
      }

    // Some macros to make manufacturing of the cartesian-product
    // calls simpler.
#define SID_GB_WRITE(dtype) \
      sid::bus::status write(sid::host_int_4 addr, dtype data) throw ()\
	  { if (LIKELY(*target)) \
              { \
                probe_address (addr); \
                return (*target)->write(addr, data); \
              } \
            else return sid::bus::unpermitted; \
          }

    SID_GB_WRITE(sid::little_int_1)
    SID_GB_WRITE(sid::big_int_1)
    SID_GB_WRITE(sid::little_int_2)
    SID_GB_WRITE(sid::big_int_2)
    SID_GB_WRITE(sid::little_int_4)
    SID_GB_WRITE(sid::big_int_4)
    SID_GB_WRITE(sid::little_int_8)
    SID_GB_WRITE(sid::big_int_8)

#undef SID_GB_WRITE

    output_pin *write_to_code_address_pin;
    const struct TextSection *section_table;
  };

class generic_loader: public virtual component,
		      protected fixed_bus_map_component,
		      protected virtual fixed_attribute_map_component,
		      protected virtual fixed_pin_map_component,
		      protected fixed_accessor_map_component,
		      protected no_relation_component,
		      protected virtual configurable_component
{
private:
  callback_pin<generic_loader> doit_pin;

protected:
  // entry point address
  output_pin start_pc_pin;
  // endianness as specified in ELF header.
  // The value is one of sidutil::endian_*.
  output_pin endian_pin;
  // eflags as specified in ELF header.
  output_pin eflags_pin;

  // Provide address of write attempt to code section
  output_pin write_to_code_address_pin;

  // Signal this if something went wrong.
  output_pin error_pin;

  // Attribute settings
  bool verbose_p;

  // loadable file names
  string load_file;

  // accessors
  bus* load_accessor_insn;
  bus* load_accessor_data;

  loader_probe_bus probe_upstream;
  bus           *probe_downstream;
  callback_pin<generic_loader> probe_pin;

  void handle_probe_pin (sid::host_int_4 v)
    {
      probe_upstream.probe_address (v);
    }

  // The load pin was triggered.
  virtual void load_it (host_int_4) = 0;

  // state control
  friend ostream& operator << (ostream& o, const generic_loader& it);
  friend istream& operator >> (istream& i, generic_loader& it);
  string save_state() { return make_attribute(*this); }
  sid::component::status restore_state(const string& state)
    { return parse_attribute(state, *this); }

  virtual void configure (const string &config);

public:
  generic_loader(): 
    doit_pin(this, & generic_loader::load_it), 
    verbose_p(false),
    load_file("/dev/null"),
    load_accessor_insn(0),
    load_accessor_data(0),
    probe_upstream (& probe_downstream, & this->write_to_code_address_pin),
    probe_downstream(0),
    probe_pin (this, & generic_loader::handle_probe_pin)
    {
      add_pin("load!", & this->doit_pin);
      add_pin("start-pc-set", & this->start_pc_pin);
      add_pin("endian-set", & this->endian_pin);
      add_pin("eflags-set", &this->eflags_pin);
      add_pin("error", & this->error_pin);
      add_pin("write-to-code-address", & this->write_to_code_address_pin);
      add_accessor("load-accessor-insn", & this->load_accessor_insn);
      add_accessor("load-accessor-data", & this->load_accessor_data);
      add_attribute("file", & this->load_file, "setting");
      add_bus ("probe-upstream", & this->probe_upstream);
      add_accessor ("probe-downstream", & this->probe_downstream);
      add_pin ("probe", & this->probe_pin);
      add_attribute("verbose?", & this->verbose_p, "setting");
      add_attribute_virtual ("state-snapshot", this,
			     & generic_loader::save_state,
			     & generic_loader::restore_state);
    }
  ~generic_loader() throw() { }
    
};

void
generic_loader::configure (const string &config)
{
  // Call up to the base class first
  configurable_component::configure (config);

  // Now handle relevent configuration for us.
  if (config.size () < 12)
    return;
  if (config.substr (0, 8) == "verbose=")
    {
      verbose_p = (config.substr (8) == "true");
      return;
    }
}

ostream& 
operator << (ostream& out, const generic_loader& it)
{
  out << "loader-state "
      << string2stream(it.load_file) << " "
      << it.verbose_p;

  return out;
}


istream& 
operator >> (istream& in, generic_loader& it)
{
  string coding;
  in >> coding;
  if (coding == "loader-state")
    {
      in >> stream2string(it.load_file)
	 >> it.verbose_p;
    }
  else
    {
      in.setstate(ios::badbit);
    }

  return in;
}

// ----------------------------------------------------------------------------

class elf_loader: public generic_loader
{
public:
  elf_loader ()
    : generic_loader (),
      symbol_table (0),
      current_function (""),
      check_function_pin (this, &elf_loader::check_function_pin_handler)
    {
      add_pin ("function?", &check_function_pin);
      add_attribute ("current-function", & current_function);
    }
  ~elf_loader () throw () {}

private:
  // static pointer to active instance (XXX: concurrency?)
  static elf_loader* freeloader;

  // callback function from C code in elfload.c
  static int load_function(host_int_8 dest_addr, char* host_addr, host_int_8 file_offset, host_int_8 bytes, int insn_space);
  static int verbose_function(char* s);

  // stream for current file  
  ifstream* file;

  void load_it (host_int_4)
    {
      if (this->load_accessor_insn == 0 || this->load_accessor_data == 0)
	{
	  cerr << "loader: error - target accessors not configured!" << endl;
	  this->error_pin.drive (0);
	  return;
	}

      if (this->verbose_p)
	{
	  cout << "loader: reading program " << this->load_file << endl;
	}

      assert(elf_loader::freeloader == 0);
      this->file = new ifstream(this->load_file.c_str(), ios::binary | ios::in);
      if (! this->file->good())
	{
	  cerr << "loader: error opening " << load_file << ": "
	       << std_error_string() << endl;
	  return;
	}

      elf_loader::freeloader = this;
      unsigned entry_point;
      int little_endian_p;
      unsigned eflags;

      const struct TextSection *section_table;
      int success_p = readElfFile(& elf_loader::load_function,
				  & entry_point, & little_endian_p,
				  & eflags, & section_table, & symbol_table);
      probe_upstream.set_section_table (section_table);
      elf_loader::freeloader = 0;

      if (success_p)
	{
	  // Tell anyone who's listening things we learned about the elf file.
	  this->start_pc_pin.drive((host_int_4) entry_point);
	  if (little_endian_p)
	    this->endian_pin.drive(sidutil::endian_little);
	  else
	    this->endian_pin.drive(sidutil::endian_big);
	  this->eflags_pin.drive((host_int_4) eflags);

	  if (this->verbose_p)
	    cout << "loader: starting "
		 << (little_endian_p ? "little-" : "big-") << "endian"
		 << " program at pc=" 
		 << make_numeric_attribute (entry_point, ios::hex | ios::showbase)
		 << endl;
	}
      else
	{
	  cerr << "loader: error loading " << load_file << endl;
	  this->error_pin.drive (0);
	}

      delete this->file;
      this->file = 0;
    }

protected:
  callback_pin<elf_loader> check_function_pin;
  void check_function_pin_handler (host_int_4 addr);

  const struct Symbol *symbol_table;
  string current_function;
};

// static variable
elf_loader* elf_loader::freeloader = 0;

// static function
int
elf_loader::load_function(host_int_8 dest_addr, char *host_addr, host_int_8 file_offset, host_int_8 bytes, int insn_space)
{
  elf_loader& l = * elf_loader::freeloader;
  string who = insn_space ? "instruction" : "data";

  if (l.verbose_p)
    {
      if (host_addr == 0)
	cout << "loader: reading "
	     << make_numeric_attribute (bytes, ios::hex | ios::showbase)
	     << " bytes from file offset "
	     << make_numeric_attribute (file_offset, ios::hex | ios::showbase)
	     << " into target " << who << " memory at "
	     << make_numeric_attribute (dest_addr, ios::hex | ios::showbase)
	     << endl;
    }

  ifstream& f = * l.file;
  bus* b;

  if (insn_space)
    b = l.load_accessor_insn;
  else
    b = l.load_accessor_data;
  assert (b);

  // go to proper offset in file
  f.seekg(file_offset);

  // fetch lots of characters
  for (int n = 0; n < bytes; n++)
    {
      char c;
      f.get(c);
      if (!f.good())
	{
	  cerr << "loader: error reading byte " << file_offset+n
	       << " from file " << l.load_file << endl;
	  return -1; // oops
	}

      if (host_addr) // read into host buffer
	{
	  // cerr << "H:" << (void*)host_addr << ":" << hex << (int)c << dec << endl;
	  *host_addr++ = c;
	}
      else // read into target memory
	{
	  host_int_8 a = dest_addr++;
	  little_int_1 data = c;
	  host_int_4 addr = a;

	  bus::status s = b->write(addr, data);

	  if (s != bus::ok) // abort on error
	    {
	      cerr << "loader: write to " << who << " accessor failed at address "
		   << make_numeric_attribute (addr, ios::hex | ios::showbase)
		   << ", status "
		   << (int) s << endl;
	      return -1;
	    }
	  // else
	  //  cerr << "T:" << addr << ":" << data << endl;
	}
    }
  return bytes;
}

void
elf_loader::check_function_pin_handler (host_int_4 addr)
{
  // Find the function corresponding to the given address in the symbol
  // table, if any, and set current_function to that name. If a function is
  // found, set current_function to a string representing the address.
  if (symbol_table)
    {
      unsigned closest = 0;
      host_int_8 min_difference = ~(host_int_8)0;
      unsigned ix;
      for (ix = 0; symbol_table[ix].name; ++ix)
	{
	  // Don't consider unnamed symbols.
	  if (! symbol_table[ix].name[0])
	    continue;
	  host_int_8 sym_addr = symbol_table[ix].addr;
	  host_int_8 sym_size = symbol_table[ix].size;
	  if (addr == sym_addr)
	    break;
	  if (addr > sym_addr && addr < (sym_addr + sym_size))
	    break;
	  if (addr - sym_addr < min_difference)
	    {
	      min_difference = addr - sym_addr;
	      closest = ix;
	    }
	}
      if (symbol_table[ix].name)
	{
	  current_function = symbol_table[ix].name;
	  return;
	}
      if (closest != 0)
	{
	  current_function = symbol_table[closest].name;
	  return;
	}
    }
  current_function = "";
}

// ----------------------------------------------------------------------------

static
vector<string>
compLoaderListTypes()
{
  vector<string> types;
  types.push_back("sw-load-elf");
  return types;
}

static
component*
compLoaderCreate(const string& typeName)
{
  if (typeName == "sw-load-elf")
    return new elf_loader();
  else
    return 0;
}

static
void
compLoaderDelete(component* c)
{
  delete dynamic_cast<elf_loader*>(c);
}

// static object
DLLEXPORT extern const component_library loader_component_library;

const component_library loader_component_library =
{
  COMPONENT_LIBRARY_MAGIC,
  & compLoaderListTypes, 
  & compLoaderCreate,
  & compLoaderDelete
};
@


1.12
log
@* DLLEXPORT decoration tweak, from Rex Sung-Tien Cho <song10@@andestech.com>
@
text
@d423 1
a423 1
  // table, if any, and set current_function to that name. If no function is
@


1.11
log
@2005-08-19  Dave Brolley  <brolley@@redhat.com>

        * Contribute the following changes:

        2005-07-13  Dave Brolley  <brolley@@redhat.com>

        * compLoader.cxx (generic_loader): Inherit virtually from
        fixed_attribute_map_component. Inherit from no_relation_component.

        2005-06-06  Dave Brolley  <brolley@@redhat.com>

        * elfload.c (readElfFile): Return and empty symbol table if none found.

        * compLoader.cxx: Add using cleause for
        sidutil::configurable_component.
        (generic_loader): fixed_pin_map_component and configurable_component
        inherited virtually.
        (configure): New virtual override in generic_loader.
        (check_function_pin_handler): Return the empty string if no function
        is associated with the given address.
        * sw-load-elf.xml: Add description of new interfaces.
        * sw-load-elf.txt: Regenerated.

        2005-05-29  Dave Brolley  <brolley@@redhat.com>

        * elfload.h (StringTable, Symbol): New struct types.
        (readElfFile): New takes symbol_table argument.
        (SHT_SYMTAB, SHT_STRTAB, ELF32_ST_TYPE, STT_FUNC): New macros.
        * elfload.c (stringTables,stringTableCount,stringTableNum): New
        static variables.
        (newStringTable): New static function.
        (symbolTable,symbolCount,symbolNum): New static variables.
        (newSymbol): New static function.
        (readElfFile): New takes symbol_table argument. Build string tables and
        symbol table while reading the input file.
        * compLoader.cxx (elf_loader): New constructor.
        (load_it): Obtain symmol_table from readElfFile.
        (check_function_pin,symbol_table,current_function): New members
        of elf_loader.
        (check_function_pin_handler): New method of elf_loader.
@
text
@d490 1
a490 1
extern const component_library loader_component_library;
d492 1
a492 1
const component_library loader_component_library DLLEXPORT = 
@


1.10
log
@2005-05-12  Dave Brolley  <brolley@@redhat.com>

        * compLoader.cxx (probe_address): New method of loader_probe_bus.
        (loader_probe_bus::write): Call probe_address.
        (handle_probe_pin): New method of generic_loader.
        (generic_loader): Initialize probe_pin and add "probe" pin.
        * sw-load-elf.xml: Describe the new pin.
        * sw-load-elf.txt: Regenerated.
@
text
@d3 1
a3 1
// Copyright (C) 1999, 2000, 2003, 2004 Red Hat.
d53 1
d116 2
a117 2
		      protected fixed_attribute_map_component,
		      protected fixed_pin_map_component,
d119 2
a120 1
		      protected no_relation_component
d169 2
d203 16
d252 13
d306 1
a306 1
				  & eflags, & section_table);
d336 7
d419 42
@


1.9
log
@	* compLoader.cxx (generic_loader):  Add eflags_pin.
	(elf_loader): Add eflags.
	(load_it): Set eflags.
	* elfload.c (readElfFile): Add eflags.
	* sidcpuutil.h (basic_cpu): Add eflags_set_pin, set_eflags.
	* commonCfg.cxx (add_cpu):  Add eflags-set pin.
@
text
@d80 6
d92 1
a92 2
                if (write_to_code_address_pin && textSectionAddress (addr, section_table)) \
                  write_to_code_address_pin->drive (addr); \
d150 6
d175 2
a176 1
    probe_downstream(0)
d189 1
@


1.8
log
@2004-04-29  Dave Brolley  <brolley@@redhat.com>

        * elfload.c (textSectionAddress): Check section table before accessing.
        * compLoader.cxx (loader_probe_bus): Initialize section_table.
@
text
@d124 2
d169 1
d255 2
d260 1
a260 1
				  & section_table);
d272 1
@


1.7
log
@2004-02-12  Dave Brolley  <brolley@@redhat.com>

        * elfload.h: Use 'unsigned long long' instead of host_int_8.
        (struct TextSection): Moved here from elfload.c
        (SHF_EXECINSTR): New macro.
        * elfload.c (loadAreas): Now a pointer to a dynamically allocated
        table.
        (textSections): Ditto.
        (newLoadArea): New static function.
        (newTextSection): Ditto.
        (textSectionAddress): Now takes a pointer to a section table.
        (readElfFile): fileHeader, psymHdr, secHdr now automatic arrays.
        Allocate loadAreas and textSections as required. Build textSections
        from the ELF section table; one for each executable loaded.
        * compLoader.cxx (sid::host_int_8): Add 'using' clause.
        (textSegmentAddress): renamed to textSectionAddress and moved to
        elfload.h.
        (setSection_table): New method of loader_probe_bus.
        (SID_GB_WRITE): Call textSectionAddress and pass section_table.
        (section_table): New member of loader_probe_bus.
        (load_it): Get section_table address from readElfFile.
        * Makefile.am (LIBIBERTY): New variable.
        (libloader_la_LIBADD): Add $(LIBIBERTY).
        * Makefile.in: Regenerated.
@
text
@d71 2
a72 1
      write_to_code_address_pin (p)
@


1.6
log
@2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * compLoader.cxx (loader_probe_bus): Now takes pin as an argument.
        Remove warn_write_to_code_p. Initialize write_to_code_address_pin.
        (SID_GB_WRITE): Drive write_to_code_address_pin instead of
        generating a message here.
        (write_to_code_address_pin): New member of generic_loader.
        (set_warn_write_to_code): Removed.
        (generic_loader): remove "warn-write-to-code?" attribute and pin.
        Add "write-to-code-address" pin.
        * sw-load-elf.xml: Remove reference to "warn-write-to-code?" pin
        and attribute. Document "write-to-code-address" pin.
        * sw-load-elf.txt: Regenerated.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        * compLoader.cxx: Use sidutil::fixed_bus_map_component.
        (loader_probe_bus): New class.
        (warn_write_to_code_pin): New member of generic_loader.
        (probe_upstream): Ditto.
        (probe_downstream): Ditto.
        (set_warn_write_to_code): New method of generic_loader.
        (generic_loader): Now inherits fixed_bus_map_component.
        Initialize new members.

2003-10-07  Dave Brolley  <brolley@@redhat.com>

        For Stan Cox  <scox@@redhat.com>
        * elfload.c (textSegmentAddress): New function.
        * elfload.h (textSegmentAddress): Likewise.
@
text
@d3 1
a3 1
// Copyright (C) 1999, 2000, 2003 Red Hat.
d44 1
a65 2
extern "C" int textSegmentAddress(int);

d77 2
d85 1
a85 1
                if (write_to_code_address_pin && textSegmentAddress (addr)) \
d104 1
d251 1
d253 3
a255 1
				  & entry_point, & little_endian_p);
@


1.5
log
@* make it compile with GCC 3.0:
        - missing throw() specifiers in bus & component dtors
	- `std::' vs `::' namespace issues
@
text
@d3 1
a3 1
// Copyright (C) 1999, 2000 Red Hat.
d47 1
a47 1
using sidutil::no_bus_component;
d63 42
d106 1
a106 1
		      protected no_bus_component,
d122 3
d128 3
a131 1
  bool verbose_p;
d138 3
d157 3
a159 1
    load_accessor_data(0)
d165 1
d169 2
@


1.4
log
@2001-06-22  Ben Elliston  <bje@@redhat.com>

	* compLoader.cxx (elf_loader::load_function): Don't loop while
	memory appears delayed -- just write.
@
text
@d121 1
@


1.3
log
@* tweak

2001-04-03  Frank Ch. Eigler  <fche@@redhat.com>

        * compLoader.cxx (load_it): Emit verbose message for starting_pc.
@
text
@d242 1
a242 1
	     << make_numeric_attribute ((void *)dest_addr, ios::hex | ios::showbase)
d281 1
a281 6
	  bus::status s;

	  do // loop while memory getting ready
	    {
	      s = b->write(addr, data);
	    } while (s == bus::delayed);
@


1.2
log
@[bsp/ChangeLog]
2001-01-13  matthew green  <mrg@@redhat.com>

	* configrun-sid.in: `load-accessor' becomes Harvard architecture
	friendly.  Split into `load-accessor-insn' and `load-accessor-data'.

[component/loader/ChangeLog]
2001-01-13  matthew green  <mrg@@redhat.com>

	* compLoader.cxx (load_accessor): Delete member.
	(load_accessor_insn, load_accessor_data): New bus* members.
	(ctor): Initialise load_accessor_insn and load_accessor_data.
	Add `load-accessor-insn' and `load-accessor-data' accessors
	and delete `load-accessor'.
	(load_function): Extend to 64 bit addresses, and have an instruction
	space identifier.
	(load_it): Check both load_accessor_insn and load_accessor_data are set,
	and use the appropriate one.  Extend messages to meantion instruction or
	data loads.
	* elfload.h (fetchQuadLittle, fetchQuadBig, fetchQuad): New macros.
	(PFLOAD): Make 64-bit & Harvard address space friendly
	(sw-load-elf.txt): Document `load-accessor-insn' and `load-accessor-data'
	accessors.
        * elfload.c (readElfFile): Support 64-bit ELF as well as 32-bit ELF.
	* sw-load-elf.txt: Document `load-accessor-insn' and `load-accessor-data'
	accessors.
@
text
@d178 1
a178 1
	  cout << "loader: Reading program " << this->load_file << endl;
d205 7
@


1.1
log
@* public snapshot of sid simulator
@
text
@a62 1

d88 2
a89 1
  bus* load_accessor;
d106 2
a107 1
    load_accessor(0)
d113 2
a114 1
      add_accessor("load-accessor", & this->load_accessor);
a123 1

a152 2


a154 1

d161 2
a162 1
  static int load_function(char* dest_addr, char* host_addr, int file_offset, int bytes);
d169 1
a169 1
      if (this->load_accessor == 0)
d171 1
a171 1
	  cerr << "loader: error - target accessor not configured!" << endl;
d183 1
a183 1
      if(! this->file->good())
a216 1

d222 1
a222 1
elf_loader::load_function(char* dest_addr, char* host_addr, int file_offset, int bytes)
d224 4
a227 1
  if (elf_loader::freeloader->verbose_p)
d229 1
a229 1
      if(host_addr == 0)
d234 1
a234 1
	     << " into target memory at "
a238 1
  elf_loader& l = * elf_loader::freeloader;
d240 6
a245 1
  bus* b = l.load_accessor;
d252 1
a252 1
  for(int n=0; n<bytes; n++)
d256 1
a256 1
      if(! f.good())
d270 1
a270 1
	  host_int_4 a = (host_int_4)(dest_addr ++);
d275 1
d279 1
a279 1
	    } while(s == bus::delayed);
d281 1
a281 1
	  if(s != bus::ok) // abort on error
d283 1
a283 1
	      cerr << "loader: write to accessor failed at address "
a295 2


a297 1

a306 1

d311 1
a311 1
  if(typeName == "sw-load-elf")
a316 1

a322 1

@

