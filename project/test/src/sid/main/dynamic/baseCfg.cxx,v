head	1.4;
access;
symbols
	sid-snapshot-20180601:1.4
	sid-snapshot-20180501:1.4
	sid-snapshot-20180401:1.4
	sid-snapshot-20180301:1.4
	sid-snapshot-20180201:1.4
	sid-snapshot-20180101:1.4
	sid-snapshot-20171201:1.4
	sid-snapshot-20171101:1.4
	sid-snapshot-20171001:1.4
	sid-snapshot-20170901:1.4
	sid-snapshot-20170801:1.4
	sid-snapshot-20170701:1.4
	sid-snapshot-20170601:1.4
	sid-snapshot-20170501:1.4
	sid-snapshot-20170401:1.4
	sid-snapshot-20170301:1.4
	sid-snapshot-20170201:1.4
	sid-snapshot-20170101:1.4
	sid-snapshot-20161201:1.4
	sid-snapshot-20161101:1.4
	sid-snapshot-20160901:1.4
	sid-snapshot-20160801:1.4
	sid-snapshot-20160701:1.4
	sid-snapshot-20160601:1.4
	sid-snapshot-20160501:1.4
	sid-snapshot-20160401:1.4
	sid-snapshot-20160301:1.4
	sid-snapshot-20160201:1.4
	sid-snapshot-20160101:1.4
	sid-snapshot-20151201:1.4
	sid-snapshot-20151101:1.4
	sid-snapshot-20151001:1.4
	sid-snapshot-20150901:1.4
	sid-snapshot-20150801:1.4
	sid-snapshot-20150701:1.4
	sid-snapshot-20150601:1.4
	sid-snapshot-20150501:1.4
	sid-snapshot-20150401:1.4
	sid-snapshot-20150301:1.4
	sid-snapshot-20150201:1.4
	sid-snapshot-20150101:1.4
	sid-snapshot-20141201:1.4
	sid-snapshot-20141101:1.4
	sid-snapshot-20141001:1.4
	sid-snapshot-20140901:1.4
	sid-snapshot-20140801:1.4
	sid-snapshot-20140701:1.4
	sid-snapshot-20140601:1.4
	sid-snapshot-20140501:1.4
	sid-snapshot-20140401:1.4
	sid-snapshot-20140301:1.4
	sid-snapshot-20140201:1.4
	sid-snapshot-20140101:1.4
	sid-snapshot-20131201:1.4
	sid-snapshot-20131101:1.4
	sid-snapshot-20131001:1.4
	sid-snapshot-20130901:1.4
	sid-snapshot-20130801:1.4
	sid-snapshot-20130701:1.4
	sid-snapshot-20130601:1.4
	sid-snapshot-20130501:1.4
	sid-snapshot-20130401:1.4
	sid-snapshot-20130301:1.4
	sid-snapshot-20130201:1.4
	sid-snapshot-20130101:1.4
	sid-snapshot-20121201:1.4
	sid-snapshot-20121101:1.4
	sid-snapshot-20121001:1.4
	sid-snapshot-20120901:1.4
	sid-snapshot-20120801:1.4
	sid-snapshot-20120701:1.4
	sid-snapshot-20120601:1.4
	sid-snapshot-20120501:1.4
	sid-snapshot-20120401:1.4
	sid-snapshot-20120301:1.4
	sid-snapshot-20120201:1.4
	sid-snapshot-20120101:1.4
	sid-snapshot-20111201:1.4
	sid-snapshot-20111101:1.4
	sid-snapshot-20111001:1.4
	sid-snapshot-20110901:1.4
	sid-snapshot-20110801:1.4
	sid-snapshot-20110701:1.4
	sid-snapshot-20110601:1.4
	sid-snapshot-20110501:1.4
	sid-snapshot-20110401:1.4
	sid-snapshot-20110301:1.4
	sid-snapshot-20110201:1.4
	sid-snapshot-20110101:1.4
	sid-snapshot-20101201:1.4
	sid-snapshot-20101101:1.4
	sid-snapshot-20101001:1.4
	sid-snapshot-20100901:1.4
	sid-snapshot-20100801:1.4
	sid-snapshot-20100701:1.4
	sid-snapshot-20100601:1.4
	sid-snapshot-20100501:1.4
	sid-snapshot-20100401:1.4
	sid-snapshot-20100301:1.4
	sid-snapshot-20100201:1.4
	sid-snapshot-20100101:1.4
	sid-snapshot-20091201:1.4
	sid-snapshot-20091101:1.4
	sid-snapshot-20091001:1.4
	sid-snapshot-20090901:1.4
	sid-snapshot-20090801:1.4
	sid-snapshot-20090701:1.4
	sid-snapshot-20090601:1.4
	sid-snapshot-20090501:1.4
	sid-snapshot-20090401:1.4
	sid-snapshot-20090301:1.4
	sid-snapshot-20090201:1.4
	sid-snapshot-20090101:1.4
	sid-snapshot-20081201:1.4
	sid-snapshot-20081101:1.4
	sid-snapshot-20081001:1.4
	sid-snapshot-20080901:1.4
	sid-snapshot-20080801:1.4
	sid-snapshot-20080701:1.4
	sid-snapshot-20080601:1.4
	sid-snapshot-20080501:1.4
	sid-snapshot-20080403:1.4
	sid-snapshot-20080401:1.4
	sid-snapshot-20080301:1.4
	sid-snapshot-20080201:1.4
	sid-snapshot-20080101:1.4
	sid-snapshot-20071201:1.4
	sid-snapshot-20071101:1.4
	sid-snapshot-20071001:1.4;
locks; strict;
comment	@// @;


1.4
date	2005.08.19.19.48.45;	author brolley;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.31.16.48.03;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.30.16.52.44;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.09.04.22.50;	author bje;	state Exp;
branches;
next	;


desc
@@


1.4
log
@2005-08-19  Dave Brolley  <brolley@@redhat.com>
        (record_data_memory_write_latency): New virtual method.
        * Contribute the following changes:n_memory_read_latency.
        (write_insn_memory): Call record_insn_memory_write_latency.
        2005-07-13  Dave Brolley  <brolley@@redhat.com>ad_latency.
        (write_data_memory): Call record_data_memory_write_latency.
        * mepCfg.cxx (set_dynamic_config): New method of MepMemCfg.::check_level
        (MepCacheCfg::set_dynamic_config): Don't use the new-config pin
        or the dynamic-configurator attribute. Instead, relate the cache
        to the dynamic configurator using its client relation.
        (MepBoardCfg::write_config): Likewise for the insn_buffer, dmac,result
        hw_engines and peripherals. Call set_dynamic_config for shared_main_mem.
        * mainDynamic.cxx (BoardConfig): New struct type.
        (main): Keep a vector of the boards in board_configs. Call:ok.
        set_start_config for each board after all the --wrap options have
        been seen. Call add_wrapped_component to identify each wrapped
        component to the session.y@@redhat.com>
        * commonCfg.h (wrapped_components): New member of SessionCfg.
        (add_wrapped_component): New method of SessionCfg.New class.
        (wrap_config): Likewise.ule): Reschedule after the given number of
        * commonCfg.cxx (wrap_config): New method of SessionCfg.
        (profile_config): Use possible_wrap_name to obtain the component
        being wrapped so we can get its name.
        (GdbCfg::write_config): Don't connect the new-config pin or use the
        dynamic-configurator relation. Instead, use the dynamic configurator's
        client relation.
        (BoardCfg::write_config): Likewise. Relate the dynamic configurator
        to gloss.
        * baseCfg.cxx (wrap_component): Now returns AtomicCfg *.
        (possible_wrap_name): Likewise.
        (dynamic_config_for_wrapped_children): Don't connect the dynamic
        configurator's new-config pin to the components or relate the
        dynamic configurator to them. Rather, relate the components to the
        dynamic configurator using its 'client' relation.
        * baseCfg.h (wrap_component): Now returns AtomicCfg *.
        (possible_wrap_name): Likewise.

        2005-07-05  Dave Brolley  <brolley@@redhat.com>

        * commonCfg.cxx (BoardCfg::write_load): Connect dynamic configurator's
        "reset" pin to output 2 of reset_net.
        (write_config): Set the "start-config" attribute of the dynamic
        configurator not gloss. Relate "main" to the dynamic configurator
        unconditionally. Connect the "config-error" pins of the dynamic
        configurator and gloss.

        2005-06-30  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (try_add_gprof): Make sure an argument is specified
        after the comma.

        2005-06-06  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (need_sess): Now takes 'verbose' argument. Use it
        to initialize sess->verbose. Update all callers.
        (main): Add " --model-busses" to board_start_config instead of
        " --model_busses" (typo).
        * commonCfg.h (need_core_probe): New member of SessionCfg.
        (BoardCfg::dynamic_configurator): Now public.
        * commonCfg.cxx (SessionCfg): Initialize need_core_probe.
        (profile_config): Set need_core_probe for --trace-core. Call
        use_tcl_bridge and possible_wrap_name for --wrap.
        (LoaderCfg): Don't set verbose? attribute here.
        (GlossCfg): Likewise.
        (GdbCfg::write_config): Connect the stub and the socket to the
        dynamic_configurator.
        (BoardCfg): Initialize core_probe and warmup_funcs. Connect the cpu's
        print-insn-summary pin to the shutdown sequence here.
        (BoardCfg::write_load): Connect the dynamic configurator's step! pin
        to the init-sequence's output 6. Set the core_probe's trace?
        attribute. Set the gloss and loader's verbose? attributes.
        (BoardCfg::write_config): Give the dynamic configurator its own
        subscription to sim-sched. Set the cpu's 'main' and core-probe
        relations. Connect gloss, core_probe, loader and all of the board's
        wrapped childred to the dynamic configurator. Check whether components
        are wrapped before connecting them to the dynamic configurator. Don't co
nnect
        the cpu's print-insn-summary pin to the shutdown sequence here.
        * baseCfg.cxx (AtomicCfg): Initialize my_possibly_wrapped.
        (wrap_component): Set my_possibly_wrapped.
        (possible_wrap_name): New static method of AtomicCfg.
        (AtomicCfg::write_construct): Check my_possibly_wrapped. Set
        victim-trace? to false if only possibly wrapped.
        (dynamic_config_for_wrapped_children): New method of AggregateCfg.
        * baseCfg.h (possible_wrap_name): New static method of AtomicCfg.
        (possibly_wrapped): New method of AtomicCfg.
        (my_possibly_wrapped): New member of AtomicCfg.
        (dynamic_config_for_wrapped_children): New method of AggregateCfg.

        2005-05-29  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (usage): Document --profile-config,--profile-func,
        --warmup-func and --warmup.
        (Defs): Initialize warmup, profile_func and start_config.
        (warmup,profile_func,warmup_func,start_config): New members of Defs.
        (need_sess): Call profile_config with "sid-internal-warmup:".
        (opt_warmup,opt_warmup_func,opt_profile_func,opt_profile_config): New
        enumerators.
        (long_options): Add --profile-config,--profile-func,
        --warmup-func and --warmup.
        (main): Accumulate start_config with reconfigurable options which occur
        before the first --board. For each board call set_start_config with
        the value of start_config concatenated with the additional reconfigurabl
e
        options specified for that --board. Call set_warmup, add_warmup_func and
        add_profile_func for each board. Handle new option enums.
        * commonCfg.h (add_profile_config): New method of SessionCfg.
        (profile_config_error, profile_opt_value, profile_opt_int_value)
        (profile_opt_gprof_value, match_profile_opt, profile_config): New
        methods of SessionCfg.
        (GprofCfg): New constructor.
        (write_load): New virtual override in BoardCfg.
        (add_profile_func, add_warmup_func, set_warmup, set_start_config): New
        methods of BoardCfg.
        (need_gprof): New member of BoardCfg.
        (start_config,warmup_funcs,profile_funcs): New members of BoardCfg.
        * commonCfg.cxx (SessionCfg): Initialize need_gprof.
        (add_profile_config): New method of SessionCfg.
        (profile_config_error, profile_opt_value, profile_opt_int_value)
        (profile_opt_gprof_value, match_profile_opt, profile_config): New
        methods of SessionCfg.
        (GprofCfg): Always add a sunscription to sim_sched. Set the
        sim-sched-event attribute.
        (GprofCfg): New constructor.
        (BoardCfg): Initialize dynamic_configurator and start_config.
        (write_load): New virtual override in BoardCfg.
        (BoardCfg::write_config): Make connections and set attributes to allow
        for dynamic configuration.
        (add_profile_func, add_warmup_func, set_warmup, set_start_config): New
        methods of BoardCfg.
@
text
@#include "baseCfg.h"
#include <fstream>
#include <vector>
#include <map>


ResolvedName::ResolvedName () : target (""), slot ("") {}
ResolvedName::ResolvedName (const string t, const string s) :
  target (t), slot (s)
{}


Writer::Writer (sid::component *c, const string filename) : 
  main_component (c),
  out (NULL),
  out_is_file (false)
{
  if (filename == "-")
    out = &cout;
  else if (filename != "")
    {
      out = new ofstream (filename.c_str());
      if (!(out && (*out)))
	{
	  cerr << "Cannot open output file '" << filename << "'.  Aborting." << endl;
	  exit (4);
	}
      out_is_file = true;
    }
}

Writer::~Writer() 
{
  if (out && out_is_file)
    {
      delete out;
    }
}


void Writer::write_line(string s)
{
  if (out)
    (*out) << s << endl;
  sid::component::status res = 
    main_component->set_attribute_value ("config-line!", s);
  if (res != sid::component::ok)
    {
      cerr << "Configuration error.  Aborting." << endl;
      exit (3);
    }
}
  
void Writer::write_file(string s)
{
  if (out)
    (*out) << "set main config-file! " << s << endl;
  sid::component::status res = 
    main_component->set_attribute_value ("config-file!", s);    
  if (res != sid::component::ok)
    {
      cerr << "Configuration error.  Aborting." << endl;
      exit (2);
    }
}


// ComponentCfg

struct ComponentCfg_impl 
{
  vector<Writable *> my_pre;
  vector<Writable *> my_post;
  map <role, map< string, pair<ComponentCfg *, string> > > my_name_map;
};

ComponentCfg::ComponentCfg (const string n) :
  my_name (n),
  c_impl (NULL)
{
  c_impl = new ComponentCfg_impl ();
}

ComponentCfg::~ComponentCfg() 
{
  if (c_impl)
    {
      for (vector<Writable *>::const_iterator i = c_impl->my_pre.begin();
	   i != c_impl->my_pre.end(); ++i)
	delete (*i);    
      for (vector<Writable *>::const_iterator i = c_impl->my_post.begin();
	   i != c_impl->my_post.end(); ++i)
	delete (*i);
      delete c_impl;
    }
}

const string ComponentCfg::get_name()
{
  return my_name;
}

void ComponentCfg::add_prefix (const string prefix)
{
  if (prefix != "")
    {
      my_name = prefix + "/" + my_name;
    }
}

void ComponentCfg::write_all (Writer &w)
{
  this->write_load (w);
  this->write_construct (w);
  this->write_config (w);
}

void ComponentCfg::write_config (Writer &w)
{
  this->write_pre(w);
  this->write_post(w);
}

void ComponentCfg::add_pre (Writable *w)
{
  assert (c_impl);
  assert (w);
  c_impl->my_pre.push_back(w);
}

void ComponentCfg::add_post (Writable *w)
{
  assert (c_impl);
  assert (w);
  c_impl->my_post.push_back(w);
}

void ComponentCfg::conn_pin (ComponentCfg *src, const string srcport, 
			     ComponentCfg *dst, const string dstport, 
			     const direction dir, 
			     bool virt)
{
  add_post (new PinConnection (src, srcport, dst, dstport, dir, virt));
}

void ComponentCfg::conn_bus (ComponentCfg *src, 
			     const string srcport,
			     ComponentCfg *dst, 
			     const string dstport,
			     bool virt)
{
  add_post (new BusConnection (src, srcport, dst, dstport, virt));
}

void ComponentCfg::set (ComponentCfg *targ, 
			const string attr, 
			const string val,
			bool virt)
{
  add_post (new Setting (targ, attr, val, virt));
}

void ComponentCfg::relate (ComponentCfg *relater, 
			   const string relationship, 
			   ComponentCfg *related,
			   bool virt)
{
  add_post (new Relation (relater, relationship, related, virt));
}


void ComponentCfg::write_pre (Writer &w)
{
  assert (c_impl);
  for (vector<Writable *>::const_iterator i = c_impl->my_pre.begin();
       i != c_impl->my_pre.end(); ++i)
    {
      assert (*i);
      (*i)->write_to (w);
    }
}
void ComponentCfg::write_post (Writer &w)
{
  assert (c_impl);
  for (vector<Writable *>::const_iterator i = c_impl->my_post.begin();
       i != c_impl->my_post.end(); ++i)
    {
      assert (*i);
      (*i)->write_to (w);
    }
}

void ComponentCfg::map_name (ComponentCfg *c, role r, 
			     const string outer, const string inner)
{
  string s(inner);
  assert (c);
  assert (c_impl);
  c_impl->my_name_map [r] [outer] = pair<ComponentCfg *, string>(c,s);
}

const ResolvedName ComponentCfg::resolve(const role r, const string name)
{
  assert (c_impl);
  if (c_impl->my_name_map [r].find (name) == 
      c_impl->my_name_map [r].end())
    return ResolvedName(my_name, name);
  
  // note: name binding is intentionally delayed here, to make sure
  // we resolve in the context of the component's "final destination"
  // rather than its location when the name mapping is setup.
  pair <ComponentCfg *, string> ref = c_impl->my_name_map [r] [name];
  assert (ref.first);
  return ref.first->resolve (r, ref.second);
}


// AtomicCfg

struct AtomicCfg_impl
{
  static map<string, AtomicCfg *> atomic_names;
  static map<string, bool> already_loaded;
};

map<string, bool> AtomicCfg_impl::already_loaded;
map<string, AtomicCfg *> AtomicCfg_impl::atomic_names;

AtomicCfg::AtomicCfg (const string name, const string complib, 
		      const string compsym, const string comptype) :
  ComponentCfg (name),
  my_wrapped (false),
  my_possibly_wrapped (false),
  my_complib (complib),
  my_compsym (compsym),
  my_comptype (comptype)
{
  AtomicCfg_impl::atomic_names [name] = this;
}

void AtomicCfg::add_prefix (const string prefix)
{
  ComponentCfg::add_prefix (prefix);
  AtomicCfg_impl::atomic_names [my_name] = this;
}

AtomicCfg::~AtomicCfg() {}

AtomicCfg *AtomicCfg::wrap_component (const string name)
{
  if (AtomicCfg_impl::atomic_names.find (name) == 
      AtomicCfg_impl::atomic_names.end ())
    return 0;
  AtomicCfg *comp = AtomicCfg_impl::atomic_names[name];
  comp->my_wrapped = true;
  comp->my_possibly_wrapped = false;
  return comp;
}

AtomicCfg *
AtomicCfg::possible_wrap_name (const string &name)
{
  if (AtomicCfg_impl::atomic_names.find (name) == 
      AtomicCfg_impl::atomic_names.end ())
    return 0;
  AtomicCfg *comp = AtomicCfg_impl::atomic_names[name];
  if (! comp->my_wrapped)
    comp->my_possibly_wrapped = true;
  return comp;
}

void AtomicCfg::reset_load_map () 
{
  AtomicCfg_impl::already_loaded.erase 
    (AtomicCfg_impl::already_loaded.begin (), 
     AtomicCfg_impl::already_loaded.end ());
}

void AtomicCfg::write_load (Writer &w) 
{
  if (my_complib == "" || my_compsym == "")
    return;
  if (AtomicCfg_impl::already_loaded.find (my_complib) != 
      AtomicCfg_impl::already_loaded.end ())
    return;
  w.write_line ("load " + my_complib + " " + my_compsym);      
  AtomicCfg_impl::already_loaded [my_complib] = true;
}

void AtomicCfg::write_construct (Writer &w)
{
  if (my_comptype == "")
    return;
  if (my_wrapped || my_possibly_wrapped)
    {
      w.write_line ("new sid-api-trace " + my_name);
      w.write_line ("new " + my_comptype + " " + my_name + "-traced");      
      w.write_line ("relate " + my_name + " victim " + my_name + "-traced");      
      w.write_line ("set " + my_name + " victim-name " + my_name + "-traced");      
      if (my_possibly_wrapped)
	w.write_line ("set " + my_name + " victim-trace? 0");      
    }
  else
    w.write_line ("new " + my_comptype + " " + my_name);
}


// AggregateCfg

struct AggregateCfg_impl
{
  vector<ComponentCfg *> my_children;
};

AggregateCfg::AggregateCfg (const string name) :
  ComponentCfg (name),
  a_impl (NULL)
{
  a_impl = new AggregateCfg_impl ();
  assert (a_impl);
}

AggregateCfg::~AggregateCfg() 
{
  if (a_impl)
    {
      for (vector<ComponentCfg *>::const_iterator i = a_impl->my_children.begin();
	   i != a_impl->my_children.end(); ++i)
	delete (*i);  
      if (a_impl)
	delete a_impl;
    }
}

void AggregateCfg::add_prefix (const string prefix)
{
  assert (a_impl);
  if (prefix.size() > 0 && prefix != string(""))
    {
      my_name = prefix + "-" + my_name;
      for (vector<ComponentCfg *>::const_iterator i = a_impl->my_children.begin();
	   i != a_impl->my_children.end(); ++i)
	(*i)->add_prefix (prefix);
    }
}

void AggregateCfg::write_load (Writer &w) 
{
  assert (a_impl);
  for (vector<ComponentCfg *>::const_iterator i = a_impl->my_children.begin();
       i != a_impl->my_children.end(); ++i)
    (*i)->write_load (w);
}

void AggregateCfg::write_construct (Writer &w) 
{
  assert (a_impl);
  for (vector<ComponentCfg *>::const_iterator i = a_impl->my_children.begin();
       i != a_impl->my_children.end(); ++i)
    (*i)->write_construct (w);
}

void AggregateCfg::write_config (Writer &w) 
{
  assert (a_impl);
  this->write_pre (w);
  for (vector<ComponentCfg *>::const_iterator i = a_impl->my_children.begin();
       i != a_impl->my_children.end(); ++i)
    (*i)->write_config (w);
  this->write_post (w);
}

void AggregateCfg::add_child (ComponentCfg *c)
{
  assert (c);
  assert (a_impl);
  c->add_prefix (this->my_name);
  a_impl->my_children.push_back (c);
}

const ResolvedName AggregateCfg::resolve(const role r, const string name)
{
  // note: name binding is intentionally delayed here, to make sure
  // we resolve in the context of the component's "final destination"
  // rather than its location when the name mapping is setup.
  //
  // also: aggregates will _not_ return their own name, since they
  // do not formally exist as instantiated components in sid
  assert (c_impl);
  pair <ComponentCfg *, string> ref = c_impl->my_name_map [r] [name];
  assert (ref.first);
  return ref.first->resolve (r, ref.second);
}


void AggregateCfg::dynamic_config_for_wrapped_children (AtomicCfg *dynamic_configurator, Writer &w)
{
  assert (dynamic_configurator);
  for (vector<ComponentCfg *>::const_iterator i = a_impl->my_children.begin();
       i != a_impl->my_children.end(); ++i)
    {
      if (*i == dynamic_configurator)
	continue;
      AtomicCfg *a = dynamic_cast<AtomicCfg *>(*i);
      if (a)
	{
	  if (a->possibly_wrapped ())
	    {
	      Relation (dynamic_configurator, "client", a).write_to (w);
	    }
	  continue;
	}
      AggregateCfg *ag = dynamic_cast<AggregateCfg *>(*i);
      if (ag)
	{
	  ag->dynamic_config_for_wrapped_children (dynamic_configurator, w);
	  continue;
	}
      assert (false);
    }
}


Connection::Connection (ComponentCfg *src, const string srcport, 
			ComponentCfg *dst, const string dstport,
			bool virt) :
  my_src (src), my_srcport (srcport), 
  my_dst (dst), my_dstport (dstport),
  my_virt (virt)
{
  assert (src);
  assert (dst);
}    


PinConnection::PinConnection (ComponentCfg *src, const string srcport, 
			      ComponentCfg *dst, const string dstport, 
			      const direction dir,
			      bool virt) :
  Connection (src, srcport, dst, dstport, virt),
  my_dir (dir)
{
  assert (src);
  assert (dst);
}    

void PinConnection::write_to (Writer &w)
{
  if (my_virt)
    {
      switch (my_dir)
	{
	case src_to_dst:
	  {
	    ResolvedName s = my_src->resolve (out_pin, my_srcport);
	    ResolvedName d = my_dst->resolve (in_pin, my_dstport);
	    w.write_line ("connect-pin " + s.target + " " + s.slot + " -> " + d.target + " " + d.slot);
	  }
	  break;
	case dst_to_src:
	  {
	    ResolvedName s = my_src->resolve (in_pin, my_srcport);
	    ResolvedName d = my_dst->resolve (out_pin, my_dstport);
	    w.write_line ("connect-pin " + s.target + " " + s.slot + " <- " + d.target + " " + d.slot);
	  }
	  break;
	case both:
	  {
	    // note: we might not use "<->" here since the port names on either
	    // end of the mapping, while the same from the user's perspective,
	    // may resolve to _different_ names depending on whether they are
	    // treated as in_pins or out_pins.
	    
	    ResolvedName s1 = my_src->resolve (out_pin, my_srcport);
	    ResolvedName d1 = my_dst->resolve (in_pin, my_dstport);
	    ResolvedName s2 = my_src->resolve (in_pin, my_srcport);
	    ResolvedName d2 = my_dst->resolve (out_pin, my_dstport);
	    if (s1.target == s2.target &&
		s1.slot == s2.slot &&
		d2.target == d1.target &&
		d2.slot == d1.slot)
	      {
		w.write_line ("connect-pin " + s1.target + " " + s1.slot + " <-> " + d1.target + " " + d1.slot);
	      }
	    else 
	      {
		w.write_line ("connect-pin " + s1.target + " " + s1.slot + " -> " + d1.target + " " + d1.slot);
		w.write_line ("connect-pin " + s2.target + " " + s2.slot + " <- " + d2.target + " " + d2.slot);
	      }
	  }
	  break;
	}
    }
  else
    {
      // non-virtual pin connection.
      string dir (my_dir == src_to_dst ? " -> " : (my_dir == dst_to_src ? " <- " : " <-> "));
      w.write_line ("connect-pin" + my_src->get_name() + " " + my_srcport + 
		    dir + my_dst->get_name() + " " + my_dstport);
    }
}

BusConnection::BusConnection (ComponentCfg *src, const string srcport,
			      ComponentCfg *dst, const string dstport,
			      bool virt) :
  Connection (src, srcport, dst, dstport, virt)
{
  assert (src);
  assert (dst);
}

void BusConnection::write_to (Writer &w)
{
  ResolvedName s;
  ResolvedName d;
  if (my_virt)
    {
      s = my_src->resolve (accessor, my_srcport);
      d = my_dst->resolve (bus, my_dstport);
    }
  else
    {
      s.target = my_src->get_name();
      s.slot = my_srcport;
      d.target = my_dst->get_name();
      d.slot = my_dstport;
    }
  w.write_line ("connect-bus " + s.target + " " + s.slot + " " + d.target + " " + d.slot);
}

Setting::Setting (ComponentCfg *targ, const string attr, 
		  const string val, bool virt) :
  my_targ (targ), 
  my_attr (attr),
  my_val (val),
  my_virt (virt)
{
  assert(targ);
}

void Setting::write_to (Writer &w)
{
  ResolvedName s;
  if (my_virt)
    s = my_targ->resolve (attr, my_attr);
  else
    {
      s.target = my_targ->get_name();
      s.slot = my_attr;
    }
  if (my_val.find (' ', 0) == -1)
    w.write_line ("set " + s.target + " " + s.slot + " " + my_val);
  else
    w.write_line ("set " + s.target + " " + s.slot + " \"" + my_val + "\"");
}

Relation::Relation (ComponentCfg *relater, const string relationship, 
		    ComponentCfg *related, bool virt) :
  my_relater (relater), 
  my_relationship (relationship),
  my_related (related),
  my_virt (true)
{
  assert (relater);
  assert (related);
}

void Relation::write_to (Writer &w)
{
  ResolvedName s; 
  ResolvedName d; 
  if (my_virt)
    {
      s = my_relater->resolve (relater, my_relationship);
      d = my_related->resolve (related, my_relationship);
    }
  else
    {
      s.target = my_relater->get_name();
      s.slot = my_relationship;
      d.target = my_related->get_name();
    }
  w.write_line ("relate " + s.target + " " + s.slot + " " + d.target);
}

@


1.3
log
@2003-01-31  Frank Ch. Eigler  <fche@@redhat.com>

	* baseCfg.cxx, commonCfg.cxx: More of the same.
@
text
@d232 2
a233 1
  wrapped (false),
d249 1
a249 1
bool AtomicCfg::wrap_component (const string name)
d253 17
a269 3
    return false;
  AtomicCfg_impl::atomic_names[name]->wrapped = true;
  return true;
d294 1
a294 1
  if (wrapped)
d299 3
d396 27
@


1.2
log
@2003-01-30  Frank Ch. Eigler  <fche@@redhat.com>

	* baseCfg.cxx: Remove some erroneous default parameters in fn decls.
@
text
@d381 1
a381 1
			bool virt = true) :
d393 2
a394 2
			      const direction dir = src_to_dst,
			      bool virt = true) :
d460 1
a460 1
			      bool virt = true) :
d487 1
a487 1
		  const string val, bool virt = true) :
d513 1
a513 1
		    ComponentCfg *related, bool virt = true) :
@


1.1
log
@* new simulator mainline

2002-05-30  Frank Ch. Eigler  <fche@@redhat.com>

	* mainDynamic.cxx (main): Add new "--rc" option to control passing
	cfgroot stop-code as sid process exit rc.

2002-04-29  Graydon Hoare  <graydon@@redhat.com>

	* mainDynamic.cxx: Make step_insn_count a string.

2002-04-29  Graydon Hoare  <graydon@@redhat.com>

	* commonCfg.h (Mapping): New class.
	* commonCfg.cxx (MapperCfg): Update to use Mapping objects.
	* mainDynamic.cxx (try_add_memory): Use Mapping objects.
	(Defs): Make step_insn_count a defaultable option.

2002-04-23  Graydon Hoare  <graydon@@redhat.com>

	* mainDynamic.cxx (try_add_memory): Force mappings to base address
	0 in extra memory region, to ignore transparent / basic mapper
	distinction in board-specific code.

2002-04-15  Dave Brolley  <brolley@@redhat.com>

	* commonCfg.cxx (struct MemCfg_impl): New struct.
	(MemCfg_impl::get_by_name): New function.
	(MemCfg::MemCfg): Add 'this' to name_map.
	* commonCfg.h (MemCfg_impl::get_by_name): New function.

2002-04-09  Dave Brolley  <brolley@@redhat.com>

	* commonCfg.cxx (add_mapping): New variant.
	* commonCfg.h (add_mapping): New variant.

2002-03-25  Graydon Hoare  <graydon@@redhat.com>

	* mainDynamic.cxx (try_load_file): Support "all-cpu" sub-option
	to --load option.
	* commonCfg.h (CpuCfg::get_all): Likewise.
	* commonCfg.cxx (CpuCfg::get_all): Likewise.

2002-03-11  Graydon Hoare  <graydon@@redhat.com>

	* mainDynamic.cxx (main): Add opt_gloss.
	* commonCfg.cxx (BoardCfg::use_gloss): Define.
	* commonCfg.h: Likewise.

2002-02-22  Graydon Hoare  <graydon@@redhat.com>

	* Makefile.am (INCLUDE): Add -I$(srcdir)/../../../include.
	* Makefile.in: Regenerate.
	* mainDynamic.cxx: Un-guard #include <getopt.h>, getting it
	from libiberty now.

2002-02-08  Graydon Hoare  <graydon@@redhat.com>

	* baseCfg.cxx: New file.
	* baseCfg.h: New file.
	* commonCfg.cxx: New file.
	* commonCfg.h: New file.
	* mainDynamic.cxx: Complete rewrite, incorporate contents of
	configrun-sid.in perl script.
	* Makefile.am (sid): Add new files to target.
	* Makefile.in: Regenerate.
@
text
@d140 2
a141 2
			     const direction dir = src_to_dst, 
			     bool virt = true)
d150 1
a150 1
			     bool virt = true)
d158 1
a158 1
			bool virt = true)
d166 1
a166 1
			   bool virt = true)
@

