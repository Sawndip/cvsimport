head	1.15;
access;
symbols
	sid-snapshot-20180601:1.15
	sid-snapshot-20180501:1.15
	sid-snapshot-20180401:1.15
	sid-snapshot-20180301:1.15
	sid-snapshot-20180201:1.15
	sid-snapshot-20180101:1.15
	sid-snapshot-20171201:1.15
	sid-snapshot-20171101:1.15
	sid-snapshot-20171001:1.15
	sid-snapshot-20170901:1.15
	sid-snapshot-20170801:1.15
	sid-snapshot-20170701:1.15
	sid-snapshot-20170601:1.15
	sid-snapshot-20170501:1.15
	sid-snapshot-20170401:1.15
	sid-snapshot-20170301:1.15
	sid-snapshot-20170201:1.15
	sid-snapshot-20170101:1.15
	sid-snapshot-20161201:1.15
	sid-snapshot-20161101:1.15
	sid-snapshot-20160901:1.15
	sid-snapshot-20160801:1.15
	sid-snapshot-20160701:1.15
	sid-snapshot-20160601:1.15
	sid-snapshot-20160501:1.15
	sid-snapshot-20160401:1.15
	sid-snapshot-20160301:1.15
	sid-snapshot-20160201:1.15
	sid-snapshot-20160101:1.15
	sid-snapshot-20151201:1.15
	sid-snapshot-20151101:1.15
	sid-snapshot-20151001:1.15
	sid-snapshot-20150901:1.15
	sid-snapshot-20150801:1.15
	sid-snapshot-20150701:1.15
	sid-snapshot-20150601:1.15
	sid-snapshot-20150501:1.15
	sid-snapshot-20150401:1.15
	sid-snapshot-20150301:1.15
	sid-snapshot-20150201:1.15
	sid-snapshot-20150101:1.15
	sid-snapshot-20141201:1.15
	sid-snapshot-20141101:1.15
	sid-snapshot-20141001:1.15
	sid-snapshot-20140901:1.15
	sid-snapshot-20140801:1.15
	sid-snapshot-20140701:1.15
	sid-snapshot-20140601:1.15
	sid-snapshot-20140501:1.15
	sid-snapshot-20140401:1.15
	sid-snapshot-20140301:1.15
	sid-snapshot-20140201:1.15
	sid-snapshot-20140101:1.15
	sid-snapshot-20131201:1.15
	sid-snapshot-20131101:1.15
	sid-snapshot-20131001:1.15
	sid-snapshot-20130901:1.15
	sid-snapshot-20130801:1.15
	sid-snapshot-20130701:1.15
	sid-snapshot-20130601:1.15
	sid-snapshot-20130501:1.15
	sid-snapshot-20130401:1.15
	sid-snapshot-20130301:1.15
	sid-snapshot-20130201:1.15
	sid-snapshot-20130101:1.15
	sid-snapshot-20121201:1.15
	sid-snapshot-20121101:1.15
	sid-snapshot-20121001:1.15
	sid-snapshot-20120901:1.15
	sid-snapshot-20120801:1.15
	sid-snapshot-20120701:1.15
	sid-snapshot-20120601:1.15
	sid-snapshot-20120501:1.15
	sid-snapshot-20120401:1.15
	sid-snapshot-20120301:1.15
	sid-snapshot-20120201:1.15
	sid-snapshot-20120101:1.15
	sid-snapshot-20111201:1.15
	sid-snapshot-20111101:1.15
	sid-snapshot-20111001:1.15
	sid-snapshot-20110901:1.15
	sid-snapshot-20110801:1.15
	sid-snapshot-20110701:1.15
	sid-snapshot-20110601:1.15
	sid-snapshot-20110501:1.15
	sid-snapshot-20110401:1.15
	sid-snapshot-20110301:1.15
	sid-snapshot-20110201:1.15
	sid-snapshot-20110101:1.15
	sid-snapshot-20101201:1.15
	sid-snapshot-20101101:1.15
	sid-snapshot-20101001:1.15
	sid-snapshot-20100901:1.15
	sid-snapshot-20100801:1.15
	sid-snapshot-20100701:1.15
	sid-snapshot-20100601:1.15
	sid-snapshot-20100501:1.15
	sid-snapshot-20100401:1.15
	sid-snapshot-20100301:1.15
	sid-snapshot-20100201:1.15
	sid-snapshot-20100101:1.15
	sid-snapshot-20091201:1.15
	sid-snapshot-20091101:1.15
	sid-snapshot-20091001:1.15
	sid-snapshot-20090901:1.15
	sid-snapshot-20090801:1.15
	sid-snapshot-20090701:1.15
	sid-snapshot-20090601:1.15
	sid-snapshot-20090501:1.15
	sid-snapshot-20090401:1.13
	sid-snapshot-20090301:1.13
	sid-snapshot-20090201:1.12
	sid-snapshot-20090101:1.12
	sid-snapshot-20081201:1.12
	sid-snapshot-20081101:1.12
	sid-snapshot-20081001:1.12
	sid-snapshot-20080901:1.12
	sid-snapshot-20080801:1.12
	sid-snapshot-20080701:1.12
	sid-snapshot-20080601:1.11
	sid-snapshot-20080501:1.11
	sid-snapshot-20080403:1.11
	sid-snapshot-20080401:1.11
	sid-snapshot-20080301:1.11
	sid-snapshot-20080201:1.11
	sid-snapshot-20080101:1.11
	sid-snapshot-20071201:1.11
	sid-snapshot-20071101:1.11
	sid-snapshot-20071001:1.11
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.2
	cygnus_cvs_20020108_pre:1.2;
locks; strict;
comment	@// @;


1.15
date	2009.04.30.21.18.38;	author dj;	state Exp;
branches;
next	1.14;

1.14
date	2009.04.08.20.39.35;	author dj;	state Exp;
branches;
next	1.13;

1.13
date	2009.02.03.21.29.29;	author dj;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.17.18.11.51;	author brolley;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.08.21.52.03;	author brolley;	state Exp;
branches;
next	1.10;

1.10
date	2007.02.05.20.28.42;	author brolley;	state Exp;
branches;
next	1.9;

1.9
date	2006.10.18.18.46.17;	author brolley;	state Exp;
branches;
next	1.8;

1.8
date	2005.08.23.21.09.48;	author brolley;	state Exp;
branches;
next	1.7;

1.7
date	2005.08.19.19.48.45;	author brolley;	state Exp;
branches;
next	1.6;

1.6
date	2004.03.22.21.28.55;	author brolley;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.21.21.39.04;	author brolley;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.10.18.29.51;	author brolley;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.09.04.22.50;	author bje;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.05.19.57.05;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.07.19.31.10;	author fche;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Index: sid/component/cgen-cpu/mep

* Makefile.am: Regenerate.
* Makefile.in: Regenerate.
* common_model.cxx: Regenerate.
* mep-core1-decode.cxx: Regenerate.
* mep-core1-sem: Regenerate.
* mep-cpu.h: Regenerate.
* mep-decode.cxx: Regenerate.
* mep-desc.h: Regenerate.
* mep-sem.cxx: Regenerate.
* mep_ext1.h: Regenerate.
* ivc2-cop.cxx: New.
* ivc2-cpu.h: New.
* ivc2.h: New.
* mep-cop1-16-decode.cxx: New.
* mep-cop1-16-decode.h: New.
* mep-cop1-16-defs.h: New.
* mep-cop1-16-model.cxx: New.
* mep-cop1-16-model.h: New.
* mep-cop1-16-sem.cxx: New.
* mep-cop1-32-decode.cxx: New.
* mep-cop1-32-decode.h: New.
* mep-cop1-32-defs.h: New.
* mep-cop1-32-model.cxx: New.
* mep-cop1-32-model.h: New.
* mep-cop1-32-sem.cxx: New.
* mep-cop1-48-decode.cxx: New.
* mep-cop1-48-decode.h: New.
* mep-cop1-48-defs.h: New.
* mep-cop1-48-model.cxx: New.
* mep-cop1-48-model.h: New.
* mep-cop1-48-sem.cxx: New.
* mep-cop1-64-decode.cxx: New.
* mep-cop1-64-decode.h: New.
* mep-cop1-64-defs.h: New.
* mep-cop1-64-model.cxx: New.
* mep-cop1-64-model.h: New.
* mep-cop1-64-sem.cxx: New.

* mep.cxx (mep_cpu::mep_cpu): Add ivc2-decode? pin.
(mep_cpu::step_insns): Flush register write queu before looping,
and after each insn bundle.

* mep.h: Regenerate.
(mep_print_insn_set_ivc2_mode): Declare.
(mep_cpu): Add register write queues.  Add IVC2 support.
(decode_bundling): Likewise.
(step_one_insn): Likewise.

Index: sid/main/dynamic

* mainDynamic: Regenerate.
* mepCfg.cxx (MepBoardCfg::set_ivc2_decode): New.
* mepCfg.h (MepBoardCfg::set_ivc2_decode): Add.
@
text
@// mainDynamic.cxx - high-tech mainline.  -*- C++ -*-

// Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Red Hat.
// This file is part of SID and is licensed under the GPL.
// See the file COPYING.SID for conditions for redistribution.

#include "config.h"

#include "../../version.h"

#include "baseCfg.h"
#include "commonCfg.h"
#include <sidmiscutil.h>
#include <getopt.h>

#ifdef SIDTARGET_MEP
#include "mepCfg.h"
#endif /* SIDTARGET_MEP */

#if defined (SIDTARGET_SH) || defined (SIDTARGET_SH64)
#include "shCfg.h"
#endif /* SIDTARGET_SH */

#include <string>

// Stub functions to set breakpoints on
static void sid_pre_configure () {}
static void sid_post_configure () {}
static void sid_pre_run () {}
static void sid_post_run () {}

extern sid::component_library /* *not* DLLIMPORT */ config_component_library;


typedef struct {
  const char *name;
  const char *blurb;
  BoardCfg * (*factory) (const string name, SessionCfg *sess);
} boardspec;


static BoardCfg * 
mk_basic (const string name, SessionCfg *sess)
{
  return new BoardCfg (name, "none", sess, false, true, true);
}

#ifdef SIDTARGET_MEP
/* begin-mepcfgtool-factories */
static BoardCfg *
mk_default (const string name, SessionCfg *sess)
{
  MepBoardCfg *b = new MepBoardCfg (name, "default", sess);
  b->set_core_type (MEP_CORE_C5);
  b->set_cpu ("mep-ext1");
  b->add_irq_board ();
  b->set_imem_size (32);
  b->set_dmem_bank_num (4);
  b->set_dmem_size (128);
  b->set_icache_size (16);
  b->set_icache_way (1);
  b->set_icache_line_size (32);
  b->set_dcache_size (16);
  b->set_dcache_way (1);
  b->set_dcache_line_size (32);
  b->set_core_id (50);
  b->set_intc_channel_bitw (32);
  b->set_intc_level (15);
  b->set_icache_cwf (false);
  b->set_dcache_cwf (false);
  b->add_timer (4);
  b->add_dmac (6, 64, true);
  b->add_cop ("ivc2", 0);
  b->set_ivc2_decode (1);
  b->set_cop_vliw_bitw (64);
  b->set_cop_data_bus_width (64);
  for (int ccr = 0; ccr < 64; ++ccr)
    b->set_cop_ccr (ccr, 0x00000000);
  b->set_opt_biu (64);
  b->set_endian ("little");
  b->set_opt_abs (true);
  b->set_opt_ave (true);
  b->set_opt_bit (true);
  b->set_opt_clp (true);
  b->set_opt_div (true);
  b->set_opt_ldz (true);
  b->set_opt_min (true);
  b->set_opt_mul (true);
  b->set_opt_sat (true);
  b->set_opt_dsu (false);
  b->set_opt_uci (false);
  return b;
}
/* end-mepcfgtool-factories */

#endif /* SIDTARGET_MEP */

static boardspec boards [] = {
  {"basic", "basic cpu + memory board", & mk_basic},
#ifdef SIDTARGET_MEP
/* begin-mepcfgtool-boards */
  { "default", "MeP custom board 'default'", & mk_default },
/* end-mepcfgtool-boards */
#endif /* SIDTARGET_MEP */
#if defined (SIDTARGET_SH) || defined (SIDTARGET_SH64)
  { "sh", "sh default board", & mk_sh },
  { "sh2", "sh2 board", & mk_sh2 },
  { "sh2e", "sh2e board", & mk_sh2e },
  { "sh2a", "sh2a default board", & mk_sh2a },
  { "sh2a-nofpu", "sh2a board with no fpu", & mk_sh2a_nofpu },
  { "sh2a-single-only", "sh2a board with single precision fpu", & mk_sh2a_fpu_single },
  { "sh2a-single", "sh2a board with fpu: default precision is single", & mk_sh2a_fpu },
  { "sh2a-fpu", "sh2a board with fpu", & mk_sh2a_fpu }, // same as sh2a-single
  { "sh3", "sh3 board", & mk_sh3 },
  { "sh3e", "sh3e board", & mk_sh3e },
  { "sh4", "sh4 board with fpu", & mk_sh4 },
  { "sh4-nofpu", "sh4 board with no fpu", & mk_sh4_nofpu },
  { "sh4-single-only", "sh4 board with single precision fpu", & mk_sh4_single },
  { "sh4-single", "sh4 board with fpu: default precision is single", & mk_sh4 },
  { "sh4a", "sh4a board with fpu", & mk_sh4a },
  { "sh4a-nofpu", "sh4a board with no fpu", & mk_sh4a_nofpu },
  { "sh4a-single-only", "sh4a board with single precision fpu", & mk_sh4a_single },
  { "sh4a-single", "sh4a board with fpu: default precision is single", & mk_sh4a },
  { "sh4al", "sh4al board", & mk_sh4al },
#if defined (SIDTARGET_SH64)
  { "sh5", "sh5 default board", & mk_sh5_64media },
  { "sh5-compact", "sh5 compact board", & mk_sh5_compact },
  { "sh5-32media", "sh5 32 bit media board", & mk_sh5_32media },
  { "sh5-64media", "sh5 64 bit media board", & mk_sh5_64media },
#endif
#endif
  {0, 0, 0}
};
    
void
version ()
{
  cout << "sid " << SID_RELEASE << endl;
  cout << "Copyright 1999-2002 Red Hat, Inc." << endl;
  cout << "sid is free software, covered by the GNU General Public License," << endl;
  cout << "as interpreted by the COPYING.SID terms." << endl;
}

 
void
usage ()
{
  cout << "Usage: sid OPTIONS [FILE] ..." << endl;
  cout << "Options:" << endl;
  cout << "-h, --help            Print this help" << endl;
  cout << "-v, --version         Print version" << endl;
  cout << "-n, --no-run          Load/check configuration but do not run simulation" << endl;
  cout << "-f FILE               Also read configuration FILE" << endl;
  cout << "-e LINE               Also do configuration LINE" << endl;
  cout << endl;
  cout << "All -b options are performed first, in sequence. " << endl;
  cout << "All -f/-e options are performed after -b options, in sequence." << endl;
  cout << "FILE names supplied without -f are done last, in sequence." << endl;
  cout << endl;
  cout << "--persistent          Run top-level loop indefinitely" << endl;
  cout << "--profile-config=NAME,OPTIONS" << endl;
  cout << "                      Specify options for a named profiling configuration" << endl;
  cout << "--rc                  Pass stop code as simulator exit rc" << endl;
  cout << "--reversible          Configure for reversible simulation" << endl;
  cout << "--save-temps=FILE     Write config to FILE, '-' for stdout." << endl;
  cout << "--wrap=COMPONENT      Turn on SID API tracing for COMPONENT" << endl;
  cout << "--verbose             Turn on run-time verbosity settings" << endl;
  cout << "--tksm                Add a an experimental Tk system monitor" << endl;
  cout << "--tksched             Add a simple Tk sim-scheduler controller" << endl;
  cout << "--board=BOARD         Instantiate builtin BOARD; remaining options" << endl
       << "                      apply to most recently instantiated BOARD." << endl
       << "                      BOARD may be any of:" << endl;
  for (boardspec *board = boards; board->name; ++board)
    cout << "                         " << board->name << "\t" << board->blurb << endl;
  cout << endl
       << "Board-specific options:" << endl;
  cout << "--cpu=CPU             Change board to use CPU" << endl;
  cout << "--load=FILE           Load FILE into board's memory" << endl
       << "                      Sub options (comma separated):" << endl
       << "                         bus=MAPPER   Load file into bus MAPPER" << endl
       << "                         cpu=CPU      Set pc of cpu CPU on load" << endl
       << "                         all-cpus     Shortcut for using all CPUs" << endl;
  cout << "--gloss               Give board a gloss (operating system)" << endl;
  cout << "--gdb=PORT            Give board a gdb stub on tcp port PORT" << endl;
  cout << "--engine=scache|pbb   Set board's engine type to scache or pbb" << endl;
  cout << "--sidrtc=ADDR         Add a real-time clock at address ADDR" << endl;
  cout << "--sidcodec=ADDR       Add an audio codec at address ADDR" << endl;
  cout << "--insn-count=COUNT    Set block of uninterrupted ticks for insns" << endl;
  cout << "--enable-warnings     Turn on CPU execution warnings" << endl;
  cout << "--final-insn-count    Turn on CPU instruction count summary" << endl;
  cout << "--trace-extract       Turn on CPU insn decode tracing" << endl;
  cout << "--trace-semantics     Turn on CPU execute tracing" << endl;
  cout << "--trace-disassemble   Turn on CPU execute disassembly" << endl;
  cout << "--trace-counter       Turn on CPU insn tracing" << endl;
  cout << "--trace-core          Turn on bus access tracing" << endl;
  cout << "--icache=TYPE         Put insn cache hw-cache-TYPE on board" << endl;
  cout << "--dcache=TYPE         Put data cache hw-cache-TYPE on board" << endl
       << "                      e.g., direct/64kb/32, 4way/256kb/64/lru" << endl;
  cout << "--EB | --EL           Set powerup CPU mode to big/little endian" << endl;
  cout << "--gprof=FILE          Turn on GPROF profiling, collect in FILE " << endl
       << "                      Sub option (comma separated):" << endl
       << "                         cycles[=N]   collect data every N simulated cycles, " << endl
       << "                                      default N=1." << endl
       << "                         (if cycles is not specified, default to " << endl
       << "                          collect data every Insn-count ticks.)" << endl;
  cout << "--memory-region=BASE,SIZE " << endl
       << "                      Add RAM region from BASE to BASE+SIZE-1." << endl
       << "                      Sub options (comma separated):" << endl
       << "                         bus=MAPPER   Attach memory to bus MAPPER" << endl
       << "                         read-only    Make memory read-only" << endl
       << "                         alias=BASE2  Add an alias at BASE2" << endl
       << "                         file=NAME    Load/save memory from file" << endl
       << "                         mmap         Memory map given file" << endl
       << "                         latency=r:w  Set read, write latencies [0:0]" << endl
       << "                         latency=rw   Set both latencies [0]" << endl;
  cout << "--profile-func=FUNCTIONS:NAME" << endl;
  cout << "                      Specify functions which use a given profiling configuration" << endl;
  cout << "--ulog-level=LEVEL    Set the logging level for the current board" << endl;
  cout << "--ulog-mode=less|match|equal" << endl
       << "                      Set the logging mode for the current board" << endl;
  cout << "--ulog-file=-|FILE    Set the log file name" << endl;
  cout << "--warmup              Start the simulation in 'warm-up' mode" << endl;
  cout << "--warmup-func=FUNCTIONS" << endl;
  cout << "                      Specify functions to be simulated in 'warm-up' mode" << endl;
  cout << "--warn-write-to-code  Generate a warning when memory containing executable code is written to" << endl;
  cout << "--no-warn-write-to-code  Do not generate a warning when memory containing executable code is written to" << endl;
  cout << "--warn-write-to-rom   Generate a warning when read only memory is written to" << endl;
  cout << "--allow-write-to-rom  Allow read only memory to be written to" << endl;
  // MeP specific options
  cout << "--model-busses        Turn on bus arbitration modelling" << endl;
  cout << "--dsp-user-out        Display user written DSP trace output for --trace-disassemble" << endl;
  cout << "--no-dsp-user-out     Display normal insn disassembly of DSP insns for --trace-disassemble" << endl;
  cout << "--local-mem=START,SIZE,NAME[,api]" << endl;
  cout << "--global-mem=START,SIZE[,cached][,rom]" << endl;
  cout << "--shadow-mem=START,SIZE,BASE[,cached][,MODULE_NAME]" << endl;
  cout << "--biu-width=N" << endl;
  cout << "--dmac-channel-bitw=N" << endl;
  cout << "--dmac-rectangle" << endl;
  cout << "--dmac-no-rectangle" << endl;
  cout << "--insn=abs|ave|bit|clp|div|ldz|min|mul|sat" << endl;
  cout << "--no-insn=abs|ave|bit|clp|div|ldz|min|mul|sat" << endl;
  cout << "--imem-size=N" << endl;
  cout << "--dmem-size=N" << endl;
  cout << "--dmem-bank-num=N" << endl;
  cout << "--dmem-fixed-start-address" << endl;
  cout << "--dmem-no-fixed-start-address" << endl;
  cout << "--icache-size=N" << endl;
  cout << "--icache-line-size=N" << endl;
  cout << "--icache-way=N" << endl;
  cout << "--icache-cwf=on|off" << endl;
  cout << "--dcache-size=N" << endl;
  cout << "--dcache-line-size=N" << endl;
  cout << "--dcache-way=N" << endl;
  cout << "--dcache-cwf=on|off" << endl;
  cout << "--corrupt-caches" << endl;
  cout << "--intc-channel-bitw=N" << endl;
  cout << "--intc-level=N" << endl;
  cout << "--timer-channel-bitw=N" << endl;
  // End MeP specific options
  cout << endl
       << " note: most board-specific options can be used in board-neutral position " << endl
       << " where they are interpreted as session-specific or default settings. " << endl;
}

string optstring (const char *def=NULL)
{
  const char *in = optarg ? optarg : (def ? def : "");
  string str("");
  str.insert (0, in, strlen(in));
  return str;
}

sid::host_int_4 addr (const string optname, const string in)
{
  sid::host_int_4 val = 0;
  if (sidutil::parse_unsigned_numeric_attribute (in, val)
      != sid::component::ok)
    {
      cerr << "cannot parse address option " << optname << " = '" << in << "'" << endl;
      exit (10);
    }
  return val;
}

sid::host_int_4 optaddr (const string optname)
{
  return addr (optname, optstring());
}

void try_load_file (const string memspec,
		    BoardCfg *board,
		    SessionCfg *sess)
{

  vector <CpuCfg *> cpus;
  MapperCfg *map = NULL;

  static int i = 0;
  assert (sess);
  LoaderCfg *loader = new LoaderCfg ("loader-" + sidutil::make_numeric_attribute (i), sess); 
  assert (loader);

  vector<string> toks = sidutil::tokenize (memspec, ",");

  for (vector<string>::const_iterator i = toks.begin();
       i != toks.end(); ++i)
    {
      vector<string> subtoks = sidutil::tokenize (*i, "=");
      switch (subtoks.size ())
	{
	case 1:
	  if (subtoks[0] == "all-cpus")
	    {
	      CpuCfg::get_all (cpus);
	    }
	  else
	    {
	      loader->set_file (*i);
	    }
	  break;
	case 2:
	  if (subtoks[0] == "bus")
	    {
	      map = MapperCfg::get_by_name (subtoks[1]);
	      if (map == NULL)
		{
		  cerr << "error: --load bus=" 
		       << *i << " refers to unknown memory bus" << endl;
		  exit (12);
		}
	    }	  
	  else if (subtoks[0] == "cpu")
	    {
	      CpuCfg *cpu = CpuCfg::get_by_name (subtoks[1]);
	      if (cpu == NULL)
		{
		  cerr << "error: --load cpu=" 
		       << *i << " refers to unknown cpu" << endl;
		  exit (12);
		}
	      else
		cpus.push_back (cpu);
	    }
	  else
	    goto bad_sub_option;
	  break;
	default:
	  goto bad_sub_option;
	}
      continue;
    bad_sub_option:
      cerr << "error: unknown sub-option to --load: " << *i << endl;
      exit (19);      
    }
  

  // try using specified map, or try to default to using board map

  if (map)
    {
      loader->set_target (map, "access-port");
      sess->set_loader (loader);
    }
  else
    {
      if (board)
	{
	  assert (board->main_mapper);
	  loader->set_target (board->main_mapper, "access-port");
	  board->set_loader (loader);
	}
      else
	{
	  cerr << "no bus named and no default board map for --load" << endl;
	  exit (20);	  
	}
    }

  // try to default to using board cpu

  if (cpus.size () == 0)
    {
      if (board)
	cpus.push_back (board->cpu);
      else
	cerr << "warning: no cpus specified and no default board cpu for --load" << endl;	  
    }

  // construct loader

  for (vector<CpuCfg *>::const_iterator c = cpus.begin(); 
       c != cpus.end (); ++c)
    {      
      assert (*c);
      loader->add_cpu (*c);
    }
}

void try_add_memory (const string memspec, 
		     BoardCfg *board, 
		     SessionCfg *sess)
{
  MemCfg *mem = NULL;
  static int memcount = 0;
  vector<sid::host_int_4> bases;
  vector<string> toks = sidutil::tokenize (memspec, ",");
  bool mmap_p = false;
  bool read_only_p = false;
  string filename ("");

  MapperCfg *map = NULL;
  assert (sess);

  if (toks.size() < 2)
    {
      cerr << "error: --memory-region requires BASE,SIZE argument" << endl;
      exit (11);
    }
  bases.push_back (addr ("--memory-region BASE", toks[0]));
  sid::host_int_4 size = addr ("--memory-region SIZE", toks[1]);

  mem = new MemCfg ("extra-mem-" + 
		    sidutil::make_numeric_attribute (memcount++));

  assert (mem);
  mem->set_size (size);
  for (vector<string>::const_iterator i = (toks.begin() + 2);
       i != toks.end(); ++i)
    {
      vector<string> subtoks = sidutil::tokenize (*i, "=");
      switch (subtoks.size())
	{
	case 1:
	  assert (mem);
	  if (subtoks[0] == "read-only")
	    read_only_p = true;
	  else if (subtoks[0] == "mmap")
	    mmap_p = true;
	  else
	    goto bad_sub_option;
	  break;
	case 2:
	  if (subtoks[0] == "bus")
	    {
	      map = MapperCfg::get_by_name (subtoks[1]);
	      if (map == NULL)
		{
		  cerr << "error: --memory-region bus=" 
		       << *i << " refers to unknown memory bus" << endl;
		  exit (12);
		}
	    }
	  else if (subtoks[0] == "alias")
	    {
	      bases.push_back (addr ("--memory-region alias", subtoks[1]));
	    }
	  else if (subtoks[0] == "file")
	    {
	      assert (mem);
	      filename = subtoks[1];
	    }
	  else if (subtoks[0] == "latency")
	    {
	      vector<string> lat = sidutil::tokenize (subtoks[1], ":");
	      assert (mem);
	      switch (lat.size())
		{
		case 1:
		  mem->set_read_latency (addr ("--memory-region latency", lat[0]));
		  mem->set_write_latency (addr ("--memory-region latency", lat[0]));
		  break;
		case 2:
		  mem->set_read_latency (addr ("--memory-region read latency", lat[0]));
		  mem->set_write_latency (addr ("--memory-region write latency", lat[1]));
		  break;
		default:
		  cerr << "error: --memory-region latency must be RW or R:W" << endl;
		  exit (12);
		}
	    }
	  else
	    goto bad_sub_option;
	  break;
	default:
	  goto bad_sub_option;
	}
      continue;
    bad_sub_option:
      cerr << "error: unknown sub-option to --memory-region: " << *i << endl;
      exit (13);      
    }

  // try to default to using board map if no map has been specified.

  if (map)
    {
      sess->add_child (mem);
    }
  else
    {
      if (board && board->main_mapper)
	{
	  board->add_child (mem);
	} 
      else
	{
	  cerr << "no bus named and no default board map for --memory-region" << endl;
	  exit (18);
	}
    } 

  assert (mem);
  string port ( read_only_p ? "read-only-port" : "read-write-port");

  // map the memory into the mapper, at all specified locations.
  for (vector<sid::host_int_4>::const_iterator i = bases.begin();
       i != bases.end(); ++i)
    {
      Mapping m = Mapping()
	.slave(mem).bus(port)
	.low(*i).high((*i) + size - 1);
      if (map)
	map->map (m.base(0));
      else if (board)
	board->add_memory (m);
      else
	assert (false); // impossible. we already checked!
    }

  // handle image-file loading, mmaping and saving
  if (filename.size() > 0)
    {
      mem->set (mem, "image-file", filename);      
      string loadpin (mmap_p ? "image-mmap" : "image-load");
      sess->init_seq->add_output (1, mem, loadpin);      
      if (! (mmap_p || read_only_p))
	sess->shutdown_seq->add_output (6, mem, "image-store");
    }

  sess->add_memory (mem);
}


void try_add_gprof(const string optstring, BoardCfg *board)
{
  gprof_type type;
  string interval_string;
  int interval = 1;
  vector<string> toks = sidutil::tokenize (optstring, ",");

  type = instruction_count;	// default type value
  if (toks.size() > 1)		// if we have a type argument
    {
      if (toks[1].empty ())
	{
          cerr << "error: unknown sub-option to --gprof: " << optstring << endl;
          exit (21);      
	}
      vector<string> subtoks = sidutil::tokenize (toks[1], "=");
      if (subtoks[0] == "cycles")	// If it is cycles
        {
          type = simulated_cycles;
          interval = 1;		// default interval value
          if (subtoks.size() > 1)	// if we have a number of cycles argument
            {
              interval_string = subtoks[1];
              interval = atoi(interval_string.c_str());
              if (interval < 1) 
                {
                  interval = 1;
                }
            }
        }
      else
        {
          cerr << "error: unknown sub-option to --gprof: " << subtoks[0] << endl;
          exit (21);      
        }
    }

  board->set_gprof (toks[0], type, interval);

}



void option_requires_board (BoardCfg *curr_board, 
			    const string option_name)
{
  if (! curr_board)
    {
      cerr << "error: option --" << option_name << " must be preceeded by option --board" << endl;
      exit (7);
    }
}


struct Defs {
  Defs () : cpu(""), 
	    enable_warnings (false),
            final_insn_count (false),
	    trace_extract (false),
	    trace_semantics (false),
	    trace_disassemble (false),
	    trace_counter (false),
	    trace_core (false),
	    ulog_level (0),
	    ulog_mode ("less"),
	    ulog_file ("-"),
	    warmup (false),
	    profile_func (""),
	    warmup_func (""),
	    start_config (""),
	    warn_write_to_code (true),
	    warn_write_to_rom (false),
	    allow_write_to_rom (false),
	    // MeP specific options
	    model_busses (false),
	    dsp_user_out (false),
	    corrupt_caches (false),
	    // End MeP specific options
	    step_insn_count ("10000")
  {}
  string cpu;
  bool enable_warnings;
  bool final_insn_count;
  bool trace_extract;
  bool trace_semantics;
  bool trace_disassemble;
  bool trace_counter;
  bool trace_core;
  sid::host_int_4 ulog_level;
  string ulog_mode;
  string ulog_file;
  bool warmup;
  string profile_func;
  string warmup_func;
  string start_config;
  string step_insn_count;
  bool warn_write_to_code;
  bool warn_write_to_rom;
  bool allow_write_to_rom;
  // MeP specific options
  bool model_busses;
  bool dsp_user_out;
  bool corrupt_caches;
  // End MeP specific options
};
  
struct BoardConfig
{
  BoardCfg *board;
  string config;
};

static void need_sess (SessionCfg *&sess, bool verbose)
{
  if (! sess)
    {
      sess = new SessionCfg ("");
      sess->profile_config ("sid-internal-warmup:");
      sess->verbose = verbose;
    }
}

// main line
int
main(int argc, char* argv[])
{
  vector< pair<bool,string> > config_items;
  bool dry_run_p = false;
  bool verbose_p = false;
  bool persistent_p = false;
  bool rc_p = false;
  string output_file ("");
  SessionCfg *sess = NULL;
  BoardCfg *curr_board = NULL;
  vector<BoardConfig> board_configs;
  int nboards = 0;

  if (argc == 1)
    {
      version ();
      cout << endl;
      usage ();
      return 1;
    }

  Defs defaults;

  enum option_num { opt_help, opt_version, opt_save_temps, opt_wrap, 
		    opt_verbose, opt_tksched, opt_enable_warnings,
		    opt_persistent, opt_profile_config,
		    opt_rc, opt_reversible, opt_no_run, opt_sidrtc, opt_sidcodec, 
		    opt_tksm, opt_board, opt_cpu, opt_gdb, opt_gloss, opt_engine, 
		    opt_insn_count, opt_load, opt_icache, opt_dcache, 
		    opt_memory_region, opt_profile_func,
		    opt_trace_extract, opt_trace_semantics,
		    opt_trace_disassemble, opt_trace_counter, opt_trace_core,
		    opt_final_insn_count, opt_eb, opt_el, opt_gprof,
		    opt_ulog_level, opt_ulog_mode, opt_ulog_file,
		    opt_warmup, opt_warmup_func,
		    opt_warn_write_to_code, no_opt_warn_write_to_code,
  		    opt_warn_write_to_rom, opt_allow_write_to_rom,
		    // MeP specific options
		    opt_model_busses,
		    opt_dsp_user_out, opt_no_dsp_user_out,
		    opt_local_mem, opt_global_mem, opt_shadow_mem,
		    opt_biu_width, opt_insn, opt_no_insn,
		    opt_imem_size, opt_dmem_size, opt_dmem_bank_num,
		    opt_dmem_fixed_start_address, opt_dmem_no_fixed_start_address,
		    opt_icache_size, opt_icache_line_size, opt_icache_way, opt_icache_cwf,
		    opt_dcache_size, opt_dcache_line_size, opt_dcache_way, opt_dcache_cwf,
		    opt_dmac_channel_bitw, opt_dmac_rectangle, opt_dmac_no_rectangle,
		    opt_corrupt_caches,
		    opt_intc_channel_bitw, opt_intc_level,
		    opt_timer_channel_bitw
		    // End MeP specific options
  };
		    
  int curr_opt;

  static struct option long_options [] = {
    // name, has-arg, *flag, val
    
    // short-option equivalents
    {"help",    no_argument, NULL, 'h' },
    {"version", no_argument, NULL, 'v' },
    {"no-run",  no_argument, NULL, 'n' },

    // per-session settings
    {"save-temps",      required_argument, & curr_opt, opt_save_temps },
    {"wrap",            required_argument, & curr_opt, opt_wrap },
    {"verbose",         no_argument, & curr_opt, opt_verbose },
    {"tksched",         no_argument, & curr_opt, opt_tksched },
    {"enable-warnings", no_argument, & curr_opt, opt_enable_warnings },
    {"persistent",      no_argument, & curr_opt, opt_persistent },
    {"profile-config",  required_argument, &curr_opt, opt_profile_config },
    {"rc",              no_argument, & curr_opt, opt_rc },
    {"reversible",      no_argument, & curr_opt, opt_reversible },
    {"tksm",            no_argument, & curr_opt, opt_tksm },


    // per-board settings
    {"board",             required_argument, & curr_opt, opt_board },
    {"cpu",               required_argument, & curr_opt, opt_cpu },    
    {"gdb",               required_argument, & curr_opt, opt_gdb },
    {"gprof",             required_argument, & curr_opt, opt_gprof },
    {"engine",            required_argument, & curr_opt, opt_engine },
    {"sidrtc",          required_argument, & curr_opt, opt_sidrtc },
    {"sidcodec",        required_argument, & curr_opt, opt_sidcodec },
    {"insn-count",        required_argument, & curr_opt, opt_insn_count },
    {"load",              required_argument, & curr_opt, opt_load },
    {"icache",            required_argument, & curr_opt, opt_icache },
    {"dcache",            required_argument, & curr_opt, opt_dcache },
    {"memory-region",     required_argument, & curr_opt, opt_memory_region },
    {"gloss",             no_argument, & curr_opt, opt_gloss },
    {"profile-func",      required_argument, &curr_opt, opt_profile_func },
    {"trace-extract",     no_argument, & curr_opt, opt_trace_extract },
    {"trace-semantics",   no_argument, & curr_opt, opt_trace_semantics },
    {"trace-disassemble", no_argument, & curr_opt, opt_trace_disassemble },
    {"trace-counter",     no_argument, & curr_opt, opt_trace_counter },
    {"trace-core",        no_argument, & curr_opt, opt_trace_core },
    {"final-insn-count",  no_argument, & curr_opt, opt_final_insn_count },
    {"EB",                no_argument, & curr_opt, opt_eb },
    {"EL",                no_argument, & curr_opt, opt_el },
    {"ulog-level",        required_argument, &curr_opt, opt_ulog_level },
    {"ulog-mode",         required_argument, &curr_opt, opt_ulog_mode },
    {"ulog-file",         required_argument, &curr_opt, opt_ulog_file },
    {"warmup",            no_argument, &curr_opt, opt_warmup },
    {"warmup-func",       required_argument, &curr_opt, opt_warmup_func },
    {"warn-write-to-code",no_argument, & curr_opt, opt_warn_write_to_code },
    {"no-warn-write-to-code",no_argument, & curr_opt, no_opt_warn_write_to_code },
    {"warn-write-to-rom",no_argument, & curr_opt, opt_warn_write_to_rom },
    {"allow-write-to-rom",no_argument, & curr_opt, opt_allow_write_to_rom },
    // MeP specific options
    {"model-busses",no_argument, & curr_opt, opt_model_busses },
    {"dsp-user-out",no_argument, & curr_opt, opt_dsp_user_out },
    {"no-dsp-user-out",no_argument, & curr_opt, opt_no_dsp_user_out },
    {"local-mem",required_argument, & curr_opt, opt_local_mem },
    {"global-mem",required_argument, & curr_opt, opt_global_mem },
    {"shadow-mem",required_argument, & curr_opt, opt_shadow_mem },
    {"dmac-channel-bitw",required_argument, & curr_opt, opt_dmac_channel_bitw },
    {"biu-width",required_argument, & curr_opt, opt_biu_width },
    {"dmac-rectangle",no_argument, & curr_opt, opt_dmac_rectangle },
    {"dmac-no-rectangle",no_argument, & curr_opt, opt_dmac_no_rectangle },
    {"insn",required_argument, & curr_opt, opt_insn },
    {"no-insn",required_argument, & curr_opt, opt_no_insn },
    {"imem-size",required_argument, & curr_opt, opt_imem_size },
    {"dmem-size",required_argument, & curr_opt, opt_dmem_size },
    {"dmem-bank-num",required_argument, & curr_opt, opt_dmem_bank_num },
    {"dmem-fixed-start-address",no_argument, & curr_opt, opt_dmem_fixed_start_address },
    {"dmem-no-fixed-start-address",no_argument, & curr_opt, opt_dmem_no_fixed_start_address },
    {"icache-size",required_argument, & curr_opt, opt_icache_size },
    {"icache-line-size",required_argument, & curr_opt, opt_icache_line_size },
    {"icache-way",required_argument, & curr_opt, opt_icache_way },
    {"icache-cwf",required_argument, & curr_opt, opt_icache_cwf },
    {"dcache-size",required_argument, & curr_opt, opt_dcache_size },
    {"dcache-line-size",required_argument, & curr_opt, opt_dcache_line_size },
    {"dcache-way",required_argument, & curr_opt, opt_dcache_way },
    {"dcache-cwf",required_argument, & curr_opt, opt_dcache_cwf },
    {"corrupt-caches",no_argument, & curr_opt, opt_corrupt_caches },
    {"intc-channel-bitw",required_argument, & curr_opt, opt_intc_channel_bitw },
    {"intc-level",required_argument, & curr_opt, opt_intc_level },
    {"timer-channel-bitw",required_argument, & curr_opt, opt_timer_channel_bitw },
    // End MeP specific options
    { 0, 0, NULL, 0 }
 };

  string board_start_config = "";
  string wrap_config = "";
  while (true)
    {
      int c = getopt_long (argc, argv, "+hvne:f:",
			   long_options, NULL);
      if (c == EOF)
	break;

      switch (c)
	{
	case 'h':
	  usage ();
	  return 0;

	case 'v':
	  version ();
	  return 0;
	  
	case 'n':
	  dry_run_p = true;
	  break;

	case 'e':
	  config_items.push_back (make_pair (false, optstring()));
	  break;

	case 'f':
	  config_items.push_back (make_pair (true, optstring()));
	  break;

	case 0:

	  switch ((enum option_num)curr_opt)
	    {
	    case opt_save_temps:
	      output_file = optstring();
	      break;
	      

	    case opt_board:
	      {
		need_sess (sess, verbose_p);
		if (curr_board)
		  {
		    sess->add_board (curr_board);
		    if (! defaults.warmup)
		      {
			BoardConfig bc = { curr_board, defaults.start_config + board_start_config };
			board_configs.push_back (bc);
		      }
		    board_start_config = "";
		  }
		curr_board = NULL;
		string new_board_type = optstring();
		string new_board_name (new_board_type + "-" + 
				       sidutil::make_attribute(nboards++));
		
		for (boardspec *i = boards; i->name; ++i)
		  {
		    if (new_board_type == i->name)
		      {
			curr_board = i->factory (new_board_name, sess);
			assert (curr_board);
			if (defaults.cpu != "")
			  curr_board->set_cpu (defaults.cpu);
			if (defaults.trace_extract)
			  curr_board->trace_extract();
			if (defaults.trace_semantics)
			  curr_board->trace_semantics();
			if (defaults.trace_disassemble)
			  curr_board->trace_disassemble();
			if (defaults.trace_counter)
			  curr_board->trace_counter();
			if (defaults.final_insn_count)
			  curr_board->final_insn_count();
			if (defaults.trace_core)
			  curr_board->trace_core();
			if (defaults.enable_warnings)
			  curr_board->enable_warnings();
			curr_board->set_ulog_level (defaults.ulog_level);
			curr_board->set_ulog_mode (defaults.ulog_mode);
			curr_board->set_ulog_file (defaults.ulog_file);
			curr_board->set_warmup (defaults.warmup);
			curr_board->add_warmup_func (defaults.warmup_func);
			curr_board->add_profile_func (defaults.profile_func);
			if (defaults.step_insn_count != "10000")
			  curr_board->set_step_insn_count(defaults.step_insn_count);
			if (defaults.warn_write_to_code)
			  curr_board->set_warn_write_to_code(true);
			else
			  curr_board->set_warn_write_to_code(false);
			if (defaults.warn_write_to_rom)
			  curr_board->set_warn_write_to_rom(true);
			if (defaults.allow_write_to_rom)
			  curr_board->set_allow_write_to_rom(true);
			// MeP specific options
			curr_board->set_config_index (i - boards);
			if (defaults.model_busses)
			  curr_board->set_model_busses(true);
			if (defaults.dsp_user_out)
			  curr_board->set_dsp_user_out(true);
			if (defaults.corrupt_caches)
			  curr_board->set_corrupt_caches(true);
			// End MeP specific options
			break;
		      }
		  }
		if (! curr_board)
		  {
		    cerr << "unknown board: " << new_board_type << endl;
		    exit (5);
		  }
	      }
	      break;


	    case opt_tksched:
	      if (sess)
		sess->use_tksched();
	      break;

	    case opt_tksm:
	      if (sess)
		sess->use_tksm();
	      break;
	      
	    case opt_verbose:
	      verbose_p = true;
	      if (sess)
		sess->verbose = true;
	      defaults.start_config += " --verbose";
	      break;
	     
	    case opt_gprof:
	      option_requires_board (curr_board, "gprof");
	      try_add_gprof(optstring(), curr_board);
	      board_start_config += " --gprof=" + optstring();
	      break;

	    case opt_gdb:
	      option_requires_board (curr_board, "gdb");
	      curr_board->set_gdb (optstring());
	      persistent_p = true;
	      break;

	    case opt_gloss:
	      option_requires_board (curr_board, "gloss");
	      curr_board->use_gloss ();
	      break;

	    case opt_load:
	      need_sess (sess, verbose_p);
	      try_load_file (optstring(), curr_board, sess);
	      break;
	      
	    case opt_cpu:
	      if (curr_board)
		curr_board->set_cpu (optstring());
	      else
		defaults.cpu = optstring();
	      break;	      
	      
	    case opt_trace_extract:
	      if (curr_board)
		{
		  board_start_config += " --trace-extract";
		  curr_board->trace_extract();
		}
	      else
		{
		  defaults.trace_extract = true;
		  defaults.start_config += " --trace-extract";
		}
	      break;

	    case opt_trace_semantics:
	      if (curr_board)
		{
		  board_start_config += " --trace-semantics";
		  curr_board->trace_semantics();
		}
	      else
		{
		  defaults.trace_semantics = true;
		  defaults.start_config += " --trace-semantics";
		}
	      break;

	    case opt_trace_disassemble:
	      if (curr_board)
		{
		  curr_board->trace_disassemble();
		  board_start_config += " --trace-disassemble";
		}
	      else
		{
		  defaults.trace_disassemble = true;
		  defaults.start_config += " --trace-disassemble";
		}
	      break;

	    case opt_trace_counter:
	      if (curr_board)
		{
		  curr_board->trace_counter();
		  board_start_config += " --trace-counter";
		}
	      else
		{
		  defaults.trace_counter = true;
		  defaults.start_config += " --trace-counter";
		}
	      break;

	    case opt_final_insn_count:
	      if (curr_board)
		{
		  curr_board->final_insn_count();
		  board_start_config += " --final-insn-count";
		}
	      else
		{
		  defaults.final_insn_count = true;
		  defaults.start_config += " --final-insn-count";
		}
	      break;

	    case opt_trace_core:
	      if (curr_board)
		{
		  curr_board->trace_core();
		  board_start_config += " --trace-core";
		}
	      else
		{
		  defaults.trace_core = true;
		  defaults.start_config += " --trace-core";
		}
	      break;

	    case opt_enable_warnings:
	      if (curr_board)
		curr_board->enable_warnings();
	      else
		defaults.enable_warnings = true;
	      break;

	    case opt_wrap:
	      {
		string c (optstring());
		if (sess)
		  sess->use_tcl_bridge ();
		AtomicCfg *comp = AtomicCfg::wrap_component (c);
		if (! comp)
		  {
		    cerr << "error: no component named '" << c << "' to wrap" << endl;
		    exit (9);
		  }
		sess->add_wrapped_component (comp);
	      }
	      break;

	      
	    case opt_insn_count:
	      if (curr_board)
		{
		  curr_board->set_step_insn_count(optstring());
		  board_start_config += " --insn-count=" + optstring();
		}
	      else
		{
		  defaults.step_insn_count = optstring();
		  defaults.start_config += " --insn-count=" + optstring();
		}
	      break;

	    case opt_persistent:
	      persistent_p = true;
	      break;

	    case opt_rc:
	      rc_p = true;
	      break;

	    case opt_reversible:
	      if (sess)
		{
		  sess->set_reversible ();
		  // --insn-count must be 1 for this to work correctly
		  if (curr_board)
		    {
		      curr_board->set_step_insn_count("1");
		      board_start_config += " --insn-count=1";
		    }
		  else
		    {
		      defaults.step_insn_count = "1";
		      defaults.start_config += " --insn-count=1";
		    }
		}
	      break;

	    case opt_sidrtc:
	      option_requires_board (curr_board, "sidrtc");
	      curr_board->add_sidrtc (optaddr("sidrtc"));
	      break;

	    case opt_sidcodec:
	      option_requires_board (curr_board, "sidcodec");
	      curr_board->add_sidcodec (optaddr("sidcodec"));
	      break;
	      
	    case opt_eb:
	      option_requires_board (curr_board, "EB");
	      curr_board->set_endian ("big");
	      break;

	    case opt_el:
	      option_requires_board (curr_board, "EL");
	      curr_board->set_endian ("little");
	      break;

	    case opt_memory_region:
	      need_sess (sess, verbose_p);
	      try_add_memory (optstring(), curr_board, sess);
	      break;

	    case opt_dcache:
	      option_requires_board (curr_board, "dcache");
	      curr_board->add_dcache (optstring());
	      break;

	    case opt_icache:
	      option_requires_board (curr_board, "icache");
	      curr_board->add_icache (optstring());
	      break;

	    case opt_engine:
	      {
		option_requires_board (curr_board, "engine");
		string engine = optstring();
		if (engine == "pbb" || engine == "scache")
		  curr_board->set_engine (optstring());
		else
		  {
		    cerr << "error: --engine must be either pbb or scache" << endl;
		    exit (8);
		  }
	      }
	      break;

	    case opt_ulog_level:
	      if (curr_board)
		{
		  curr_board->set_ulog_level (optaddr ("ulog-level"));
		  board_start_config += " --ulog-level=" + optstring();
		}
	      else
		{
		  defaults.ulog_level = optaddr ("ulog-level");
		  defaults.start_config += " --ulog-level=" + optstring();
		  need_sess (sess, verbose_p);
		  sess->set_ulog_level (optaddr ("ulog-level"));
		}
	      break;

	    case opt_ulog_mode:
	      if (curr_board)
		{
		  curr_board->set_ulog_mode (optstring ());
		  board_start_config += " --ulog-mode=" + optstring();
		}
	      else
		{
		  defaults.ulog_mode = optstring ();
		  defaults.start_config += " --ulog-mode=" + optstring();
		  need_sess (sess, verbose_p);
		  sess->set_ulog_mode (optstring ());
		}
	      break;

	    case opt_ulog_file:
	      need_sess (sess, verbose_p);
	      sess->add_ulog_file (optstring ());
	      if (curr_board)
		curr_board->set_ulog_file (optstring ());
	      else
		{
		  defaults.ulog_file = optstring ();
		  sess->set_ulog_file (optstring ());
		}
	      break;

	    case opt_warmup:
	      if (curr_board)
		curr_board->set_warmup (true);
	      else
		defaults.warmup = true;
	      break;

	    case opt_warmup_func:
	      if (curr_board)
		curr_board->add_warmup_func (optstring ());
	      else
		{
		  if (! defaults.warmup_func.empty ())
		    defaults.warmup_func += ",";
		  defaults.warmup_func += optstring ();
		}
	      break;

	    case opt_profile_func:
	      if (curr_board)
		curr_board->add_profile_func (optstring ());
	      else
		{
		  if (! defaults.profile_func.empty ())
		    defaults.profile_func += "|";
		  defaults.profile_func += optstring ();
		}
	      break;

	    case opt_profile_config:
	      need_sess (sess, verbose_p);
	      sess->profile_config (optstring ());
	      break;

	    case opt_warn_write_to_code:
	      if (curr_board)
		curr_board->set_warn_write_to_code (true);
	      else
		defaults.warn_write_to_code = true;
	      break;

	    case no_opt_warn_write_to_code:
	      if (curr_board)
		curr_board->set_warn_write_to_code (false);
	      else
		defaults.warn_write_to_code = false;
	      break;

	    case opt_warn_write_to_rom:
	      if (curr_board)
		curr_board->set_warn_write_to_rom (true);
	      else
		defaults.warn_write_to_rom = true;
	      break;

	    case opt_allow_write_to_rom:
	      if (curr_board)
		curr_board->set_allow_write_to_rom (true);
	      else
		defaults.allow_write_to_rom = true;
	      break;

	    // MeP specific options.
	    case opt_model_busses:
	      if (curr_board)
		{
		  curr_board->set_model_busses (true);
		  board_start_config += " --model-busses";
		}
	      else
		{
		  defaults.model_busses = true;
		  defaults.start_config += " --model-busses";
		}
	      break;

	    case opt_dsp_user_out:
	      if (curr_board)
		curr_board->set_dsp_user_out (true);
	      else
		defaults.dsp_user_out = true;
	      break;

	    case opt_no_dsp_user_out:
	      if (curr_board)
		curr_board->set_dsp_user_out (false);
	      else
		defaults.dsp_user_out = false;
	      break;

	    case opt_local_mem:
	      if (curr_board)
		curr_board->set_opt_local_mem (optstring ());
	      break;
	      
	    case opt_global_mem:
	      if (curr_board)
		curr_board->set_opt_global_mem (optstring ());
	      break;
	      
	    case opt_shadow_mem:
	      if (curr_board)
		curr_board->set_opt_shadow_mem (optstring ());
	      break;
	      
	    case opt_dmac_channel_bitw:
	      if (curr_board)
		curr_board->set_opt_dmac_channel_bitw (optstring ());
	      break;

	    case opt_biu_width:
	      if (curr_board)
		curr_board->set_opt_biu_width (optstring ());
	      break;
	      
	    case opt_dmac_rectangle:
	      if (curr_board)
		curr_board->set_opt_dmac_rectangle (true);
	      break;
	      
	    case opt_dmac_no_rectangle:
	      if (curr_board)
		curr_board->set_opt_dmac_rectangle (false);
	      break;
	      
	    case opt_insn:
	      if (curr_board)
		curr_board->set_opt_insn (optstring ());
	      break;
	      
	    case opt_no_insn:
	      if (curr_board)
		curr_board->set_opt_no_insn (optstring ());
	      break;
	      
	    case opt_imem_size:
	      if (curr_board)
		curr_board->set_opt_imem_size (optstring ());
	      break;
	      
	    case opt_dmem_size:
	      if (curr_board)
		curr_board->set_opt_dmem_size (optstring ());
	      break;
	      
	    case opt_dmem_bank_num:
	      if (curr_board)
		curr_board->set_opt_dmem_bank_num (optstring ());
	      break;
	      
	    case opt_dmem_fixed_start_address:
	      if (curr_board)
		curr_board->set_opt_dmem_fixed_start_address (true);
	      break;
	      
	    case opt_dmem_no_fixed_start_address:
	      if (curr_board)
		curr_board->set_opt_dmem_fixed_start_address (false);
	      break;
	      
	    case opt_icache_size:
	      if (curr_board)
		curr_board->set_opt_icache_size (optstring ());
	      break;
	      
	    case opt_icache_line_size:
	      if (curr_board)
		curr_board->set_opt_icache_line_size (optstring ());
	      break;
	      
	    case opt_icache_way:
	      if (curr_board)
		curr_board->set_opt_icache_way (optstring ());
	      break;
	      
	    case opt_icache_cwf:
	      {
		string cwf = optstring();
		if (cwf == "on" || cwf == "off")
		  {
		    if (curr_board)
		      curr_board->set_opt_icache_cwf (cwf);
		  }
		else
		  {
		    cerr << "error: --icache-cwf must be either on or off" << endl;
		    exit (8);
		  }
	      }
	      break;

	    case opt_dcache_size:
	      if (curr_board)
		curr_board->set_opt_dcache_size (optstring ());
	      break;
	      
	    case opt_dcache_line_size:
	      if (curr_board)
		curr_board->set_opt_dcache_line_size (optstring ());
	      break;
	      
	    case opt_dcache_way:
	      if (curr_board)
		curr_board->set_opt_dcache_way (optstring ());
	      break;
	      
	    case opt_dcache_cwf:
	      {
		string cwf = optstring();
		if (cwf == "on" || cwf == "off")
		  {
		    if (curr_board)
		      curr_board->set_opt_dcache_cwf (cwf);
		  }
		else
		  {
		    cerr << "error: --dcache-cwf must be either on or off" << endl;
		    exit (8);
		  }
	      }
	      break;

	    case opt_corrupt_caches:
	      if (curr_board)
		curr_board->set_corrupt_caches (true);
	      else
		defaults.corrupt_caches = true;
	      break;

	    case opt_intc_channel_bitw:
	      if (curr_board)
		curr_board->set_opt_intc_channel_bitw (optstring ());
	      break;
	      
	    case opt_intc_level:
	      if (curr_board)
		curr_board->set_opt_intc_level (optstring ());
	      break;

	    case opt_timer_channel_bitw:
	      if (curr_board)
		curr_board->set_opt_timer_channel_bitw (optstring ());
	      break;
	    // End MeP specific options.
	    }
	  break;


	case '?':
	default:
	  usage ();
	  return 1;
	}
    }

  if (sess && curr_board)
    {
      sess->add_board (curr_board);
      if (! defaults.warmup)
	{
	  BoardConfig bc = { curr_board, defaults.start_config + board_start_config };
	  board_configs.push_back (bc);

	  string wrap_config = sess->wrap_config ();
	  for (vector<BoardConfig>::const_iterator it = board_configs.begin ();
	       it != board_configs.end ();
	       ++it)
	    it->board->set_start_config (it->config + wrap_config);
	}
    }

  if (persistent_p)
    config_items.push_back (make_pair (false, string("set main persistent? true")));

  if (verbose_p)
    config_items.push_back (make_pair (false, string("set main verbose? true")));

  sid::component* main_component = 
    config_component_library.create_component("sid-control-cfgroot");
  if(main_component == 0)
    {
      cerr << "Cannot instantiate configuration root component." << endl;
      return 2;
    }

  sid_pre_configure ();
  Writer config_writer (main_component, output_file);

  
  // Treat remaining arguments as file names
  for (unsigned j=optind; j<argc; j++)
    {
      config_items.push_back (make_pair (true, string(argv[j])));
    }

  // instantiate any built-in boards
  if (sess)
    sess->write_all (config_writer);
  
  // NB: There is no problem if config_items is empty.  cfgroot will
  // abort a run if there are no other configured components.

  for (vector <pair <bool, string> >::const_iterator i = config_items.begin();
       i != config_items.end(); ++i)
    {
      if (i->first == true)
	config_writer.write_file (i->second);
      else
	config_writer.write_line (i->second);
    }
  
  sid_post_configure ();

  if (! dry_run_p)
    {
      // drive the root's "run" pin.
      sid_pre_run ();
      sid::pin* run_pin = main_component->find_pin ("run!");
      if (! run_pin)
	{
	  cerr << "Cannot find root run pin." << endl;
	  return 4;
	}
      
      // run the simulation
      run_pin->driven (0);
      // the simulation has ended.
      sid_post_run ();
    }

  // fetch exit-code from cfgroot
  sid::host_int_4 code;
  sid::component::status s = 
    sidutil::parse_attribute (main_component->attribute_value ("stop-code"), code);
  if (s != sid::component::ok)
    code = 0;

  // delete cfgroot and the rest of the world
  config_component_library.delete_component (main_component);

  if (rc_p)
    return ((code >> 8) & 0xff); // extract just the rc portion of the wait struct
  else
    return 0;
}


#ifndef SID_STATIC
// Define a stub lt_preloaded_symbols[], as if libtool's
// "--dlpreopen libnull.la" linker option was given (for an empty libnull.la).
// This must agree with ltmain.sh & libltdl.
struct symbols {
  const char *name;
  void* address;
};
extern struct symbols lt_preloaded_symbols[];
struct symbols lt_preloaded_symbols[] = { 0, 0 };
#endif // !SID_STATIC

@


1.14
log
@[cgen]
	* cpu/mep-c5.cpu: New.
	* cpu/mep-core.cpu: Add C5 support.
	* cpu/mep.opc: Likewise.
[opcodes]
	* mep-asm.c: Regenerate.
	* mep-desc.c: Regenerate.
	* mep-desc.h: Regenerate.
	* mep-dis.c: Regenerate.
	* mep-ibld.c: Regenerate.
	* mep-opc.c: Regenerate.
	* mep-opc.h: Regenerate.
[sid]
	* component/cache/cache.cxx (cache_component::cache_component):
	Add write_hint_pin().  Attach it to write-hint.
	(cache_component::write_hint): New.
	* component/cache/cache.h (write_hint_pin): New.
	(write_hint): New.

	* component/cgen-cpu/mep/Makefile.am: Regenerate.
	* component/cgen-cpu/mep/Makefile.in: Regenerate.
	* component/cgen-cpu/mep/mep-core1-decode.cxx: Regenerate.
	* component/cgen-cpu/mep/mep-core1-decode.h: Regenerate.
	* component/cgen-cpu/mep/mep-core1-defs.h: Regenerate.
	* component/cgen-cpu/mep/mep-core1-model.cxx: Regenerate.
	* component/cgen-cpu/mep/mep-core1-model.h: Regenerate.
	* component/cgen-cpu/mep/mep-core1-sem.cxx: Regenerate.
	* component/cgen-cpu/mep/mep-decode.cxx: Regenerate.
	* component/cgen-cpu/mep/mep-decode.h: Regenerate.
	* component/cgen-cpu/mep/mep-defs.h: Regenerate.
	* component/cgen-cpu/mep/mep-desc.h: Regenerate.
	* component/cgen-cpu/mep/mep-model.cxx: Regenerate.
	* component/cgen-cpu/mep/mep-model.h: Regenerate.
	* component/cgen-cpu/mep/mep-sem.cxx: Regenerate.
	* component/cgen-cpu/mep/mep.cxx (mep_cpu): Connect
	write-hint pin.
	(do_cache): Add C5 support.
	(do_cache_prefetch): Likewise.
	(do_casb3, do_cash3, do_casw3): New.
	* component/cgen-cpu/mep/mep.h: Add C5 support and write-hint pin.
	(do_casb3, do_cash3, do_casw3): New.

	* component/families/mep/Makefile.in: Regenerate.
	* component/families/mep/dsu.in: Add C5 support.
	* main/dynamic/mainDynamic.cxx: Add C5 support.
	* main/dynamic/mepCfg.cxx: Connect write-hint pin.
	* main/dynamic/mepCfg.h: Add C5 support.
@
text
@d73 6
@


1.13
log
@* compCGEN.cxx: Update to new MeP configuration.
* Makefile.am: Update to new MeP configuration.
* Makefile.in: Likewise.
* common_model.cxx: Likewise.
* mep-core1-decode.cxx: Likewise.
* mep-cpu.h: Likewise.
* mep-decode.cxx: Likewise.
* mep-desc.h: Likewise.
* mep.h: Likewise.
* mm_int.h (no_relation_component): Update to new MeP configuration.
* mepCfg.cxx (MepMemCfg): Update to new MeP configuration.
* mainDynamic.cxx (mk_sample): Update to new MeP configuration.
@
text
@d54 1
a54 1
  b->set_core_type (MEP_CORE_C4);
@


1.12
log
@2008-06-17  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (usage): Document --reversible.
        (try_add_memory): Call sess->add_memory.
        (option_num): add opt_reversible.
        (long_options): Add "reversible".
        (main): Handle opt_reversible.
        * commonCfg.h (set_reversible): New method of SessionCfg.
        (add_memory): Likewise.
        (reversible_p): New member of SessionCfg.
        (memory): Likewise.
        * commonCfg.cxx (CpuCfg): Establish sim-sched relation.
        (SessionCfg): Initialize reversible_p.
        (SessionCfg::write_load): Set up all memory regions as reversible,
        if requested.
        (BoardCfg::write_config): Set up the cpu to be reversible, if
        requested.
@
text
@d51 1
a51 1
mk_simple (const string name, SessionCfg *sess)
d53 2
a54 3
  MepBoardCfg *b = new MepBoardCfg (name, "simple", sess);

  b->set_core_type (MEP_CORE_C2);
d57 11
a67 29
  b->set_core_id (1);
  b->set_intc_channel_bitw (8);
  b->set_intc_level (15);
  b->set_opt_biu (64);
  b->set_endian ("big");
  b->set_opt_abs (false);
  b->set_opt_ave (false);
  b->set_opt_bit (false);
  b->set_opt_clp (false);
  b->set_opt_div (false);
  b->set_opt_ldz (false);
  b->set_opt_min (false);
  b->set_opt_mul (false);
  b->set_opt_sat (false);
  b->set_opt_dsu (false);
  b->set_opt_uci (false);
  return b;
}

static BoardCfg *
mk_fmax (const string name, SessionCfg *sess)
{
  MepBoardCfg *b = new MepBoardCfg (name, "fmax", sess);

  b->set_core_type (MEP_CORE_C2);
  b->set_cpu ("mep-ext2");
  b->add_irq_board ();
  b->set_core_id (2);
  b->set_intc_channel_bitw (8);
d69 4
a72 5
  b->add_cop ("fmax_cop", 0);
  b->set_cop_data_bus_width (32);
  b->set_cop_ccr ( 0, 0x00000101);
  b->set_cop_ccr ( 1, 0x00000000);
  b->set_cop_ccr (15, 0x00000000);
d74 1
a74 1
  b->set_endian ("big");
d96 1
a96 2
  { "simple", "MeP custom board 'simple'", & mk_simple },
  { "fmax", "MeP custom board 'fmax'", & mk_fmax },
@


1.11
log
@COrrect comments identifying MeP specific options.
@
text
@d179 1
d554 2
d709 1
a709 1
		    opt_rc, opt_no_run, opt_sidrtc, opt_sidcodec, 
d755 1
d1110 18
@


1.10
log
@Support for Toshiba MeP.
@
text
@d243 1
a243 1
  // MeP-specific options
d273 1
d629 1
a629 1
	    // MeP-specific
d633 1
a633 1
	    // End MeP-specific
d655 1
a655 1
  // MeP-specific
d659 1
d717 1
a717 1
		    // Mep-specific options
d729 3
a731 1
		    opt_timer_channel_bitw };
d787 1
a787 1
    // Mep-specific options
d817 1
d917 1
a917 1
			// Mep-specific options
d925 1
d1259 1
a1259 1
	      // Mep-specific options.
d1440 1
a1440 1
	      // End Mep-specific options.
@


1.9
log
@2006-10-18  Dave Brolley  <brolley@@redhat.com>

        * Contribue the following changes:

        2006-07-19  Dave Brolley  <brolley@@redhat.com>

        * shCfg.h (insn_buffer): All references removed.
        (main_memory): New member of ShBoardCfg.
        * shCfg.cxx (insn_buffer): All references removed.
        (ShBoardCfg): Don't initialize icache or ocache. Assume icache and
        ocache are always created. Don't connect memory heirarchy here.
        (write_config): Do it here instead.

        2006-05-11  Dave Brolley  <brolley@@redhat.com>

        * Makefile.am: Add sh support.
        * mainDynamic.cxx: Likewise.
        * shCfg.cxx: New source file.
        * shCfg.h: New source file.
        * commonCfg.cxx (GprofCfg): Set bucket-size for hw-cpu-sh*.
@
text
@d16 4
d48 63
d114 6
d239 34
d625 8
d651 7
d712 16
a727 1
		    opt_warmup, opt_warmup_func };
d779 34
d904 16
d1224 211
@


1.8
log
@2005-08-23  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (try_add_gprof): Initialize interval.
        * commonCfg.cxx (set_priority): New method of SchedCfg.
        (GprofCfg): Always call set_time, set_regular and set_priority.
        (BoardCfg::write_load): Don't connect init-seq to the dynamic
        configurator's step! pin. Call set_priority.
        * commonCfg.h (set_priority): New method of SchedCfg.
        (config_priority,gprof_priority,default_priority): New constants in
        SchedCfg.
@
text
@d3 1
a3 1
// Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005 Red Hat.
d16 3
d47 27
@


1.7
log
@2005-08-19  Dave Brolley  <brolley@@redhat.com>
        (record_data_memory_write_latency): New virtual method.
        * Contribute the following changes:n_memory_read_latency.
        (write_insn_memory): Call record_insn_memory_write_latency.
        2005-07-13  Dave Brolley  <brolley@@redhat.com>ad_latency.
        (write_data_memory): Call record_data_memory_write_latency.
        * mepCfg.cxx (set_dynamic_config): New method of MepMemCfg.::check_level
        (MepCacheCfg::set_dynamic_config): Don't use the new-config pin
        or the dynamic-configurator attribute. Instead, relate the cache
        to the dynamic configurator using its client relation.
        (MepBoardCfg::write_config): Likewise for the insn_buffer, dmac,result
        hw_engines and peripherals. Call set_dynamic_config for shared_main_mem.
        * mainDynamic.cxx (BoardConfig): New struct type.
        (main): Keep a vector of the boards in board_configs. Call:ok.
        set_start_config for each board after all the --wrap options have
        been seen. Call add_wrapped_component to identify each wrapped
        component to the session.y@@redhat.com>
        * commonCfg.h (wrapped_components): New member of SessionCfg.
        (add_wrapped_component): New method of SessionCfg.New class.
        (wrap_config): Likewise.ule): Reschedule after the given number of
        * commonCfg.cxx (wrap_config): New method of SessionCfg.
        (profile_config): Use possible_wrap_name to obtain the component
        being wrapped so we can get its name.
        (GdbCfg::write_config): Don't connect the new-config pin or use the
        dynamic-configurator relation. Instead, use the dynamic configurator's
        client relation.
        (BoardCfg::write_config): Likewise. Relate the dynamic configurator
        to gloss.
        * baseCfg.cxx (wrap_component): Now returns AtomicCfg *.
        (possible_wrap_name): Likewise.
        (dynamic_config_for_wrapped_children): Don't connect the dynamic
        configurator's new-config pin to the components or relate the
        dynamic configurator to them. Rather, relate the components to the
        dynamic configurator using its 'client' relation.
        * baseCfg.h (wrap_component): Now returns AtomicCfg *.
        (possible_wrap_name): Likewise.

        2005-07-05  Dave Brolley  <brolley@@redhat.com>

        * commonCfg.cxx (BoardCfg::write_load): Connect dynamic configurator's
        "reset" pin to output 2 of reset_net.
        (write_config): Set the "start-config" attribute of the dynamic
        configurator not gloss. Relate "main" to the dynamic configurator
        unconditionally. Connect the "config-error" pins of the dynamic
        configurator and gloss.

        2005-06-30  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (try_add_gprof): Make sure an argument is specified
        after the comma.

        2005-06-06  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (need_sess): Now takes 'verbose' argument. Use it
        to initialize sess->verbose. Update all callers.
        (main): Add " --model-busses" to board_start_config instead of
        " --model_busses" (typo).
        * commonCfg.h (need_core_probe): New member of SessionCfg.
        (BoardCfg::dynamic_configurator): Now public.
        * commonCfg.cxx (SessionCfg): Initialize need_core_probe.
        (profile_config): Set need_core_probe for --trace-core. Call
        use_tcl_bridge and possible_wrap_name for --wrap.
        (LoaderCfg): Don't set verbose? attribute here.
        (GlossCfg): Likewise.
        (GdbCfg::write_config): Connect the stub and the socket to the
        dynamic_configurator.
        (BoardCfg): Initialize core_probe and warmup_funcs. Connect the cpu's
        print-insn-summary pin to the shutdown sequence here.
        (BoardCfg::write_load): Connect the dynamic configurator's step! pin
        to the init-sequence's output 6. Set the core_probe's trace?
        attribute. Set the gloss and loader's verbose? attributes.
        (BoardCfg::write_config): Give the dynamic configurator its own
        subscription to sim-sched. Set the cpu's 'main' and core-probe
        relations. Connect gloss, core_probe, loader and all of the board's
        wrapped childred to the dynamic configurator. Check whether components
        are wrapped before connecting them to the dynamic configurator. Don't co
nnect
        the cpu's print-insn-summary pin to the shutdown sequence here.
        * baseCfg.cxx (AtomicCfg): Initialize my_possibly_wrapped.
        (wrap_component): Set my_possibly_wrapped.
        (possible_wrap_name): New static method of AtomicCfg.
        (AtomicCfg::write_construct): Check my_possibly_wrapped. Set
        victim-trace? to false if only possibly wrapped.
        (dynamic_config_for_wrapped_children): New method of AggregateCfg.
        * baseCfg.h (possible_wrap_name): New static method of AtomicCfg.
        (possibly_wrapped): New method of AtomicCfg.
        (my_possibly_wrapped): New member of AtomicCfg.
        (dynamic_config_for_wrapped_children): New method of AggregateCfg.

        2005-05-29  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (usage): Document --profile-config,--profile-func,
        --warmup-func and --warmup.
        (Defs): Initialize warmup, profile_func and start_config.
        (warmup,profile_func,warmup_func,start_config): New members of Defs.
        (need_sess): Call profile_config with "sid-internal-warmup:".
        (opt_warmup,opt_warmup_func,opt_profile_func,opt_profile_config): New
        enumerators.
        (long_options): Add --profile-config,--profile-func,
        --warmup-func and --warmup.
        (main): Accumulate start_config with reconfigurable options which occur
        before the first --board. For each board call set_start_config with
        the value of start_config concatenated with the additional reconfigurabl
e
        options specified for that --board. Call set_warmup, add_warmup_func and
        add_profile_func for each board. Handle new option enums.
        * commonCfg.h (add_profile_config): New method of SessionCfg.
        (profile_config_error, profile_opt_value, profile_opt_int_value)
        (profile_opt_gprof_value, match_profile_opt, profile_config): New
        methods of SessionCfg.
        (GprofCfg): New constructor.
        (write_load): New virtual override in BoardCfg.
        (add_profile_func, add_warmup_func, set_warmup, set_start_config): New
        methods of BoardCfg.
        (need_gprof): New member of BoardCfg.
        (start_config,warmup_funcs,profile_funcs): New members of BoardCfg.
        * commonCfg.cxx (SessionCfg): Initialize need_gprof.
        (add_profile_config): New method of SessionCfg.
        (profile_config_error, profile_opt_value, profile_opt_int_value)
        (profile_opt_gprof_value, match_profile_opt, profile_config): New
        methods of SessionCfg.
        (GprofCfg): Always add a sunscription to sim_sched. Set the
        sim-sched-event attribute.
        (GprofCfg): New constructor.
        (BoardCfg): Initialize dynamic_configurator and start_config.
        (write_load): New virtual override in BoardCfg.
        (BoardCfg::write_config): Make connections and set attributes to allow
        for dynamic configuration.
        (add_profile_func, add_warmup_func, set_warmup, set_start_config): New
        methods of BoardCfg.
@
text
@d422 1
a422 1
  int interval;
@


1.6
log
@2004-03-22  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (main): Call add_board in place of add_child.
        * commonCfg.h (add_gdb): New method of SessionCfg.
        (add_board): Ditto.
        (write_config): Ditto.
        (board_count): New member of SessionCfg.
        (gdb_count): Ditto.
        * commonCfg.cxx (SessionCfg): Initialize board_count and gdb_count.
        (SessionCfg::write_config): New method.
        (set_gdb): Call sess->add_gdb.
@
text
@d3 1
a3 1
// Copyright (C) 1999-2004 Red Hat.
d17 2
d73 2
d127 2
d133 3
d428 5
a433 1
      
d484 4
d501 4
d508 5
d514 1
a514 1
void need_sess (SessionCfg *&sess)
d517 5
a521 1
    sess = new SessionCfg ("");
a523 1

d536 1
d551 2
a552 1
		    opt_persistent, opt_rc, opt_no_run, opt_sidrtc, opt_sidcodec, 
d555 2
a556 1
		    opt_memory_region, opt_trace_extract, opt_trace_semantics,
d559 2
a560 1
		    opt_ulog_level, opt_ulog_mode, opt_ulog_file };
d579 1
d598 1
d610 2
d614 3
a616 1
  
d657 1
a657 1
		need_sess (sess);
d659 9
a667 1
		  sess->add_board (curr_board);
d698 3
d729 1
d735 1
d750 1
a750 1
	      need_sess (sess);
d763 4
a766 1
		curr_board->trace_extract();
d768 4
a771 1
		defaults.trace_extract = true;
d776 4
a779 1
		curr_board->trace_semantics();
d781 4
a784 1
		defaults.trace_semantics = true;
d789 4
a792 1
		curr_board->trace_disassemble();
d794 4
a797 1
		defaults.trace_disassemble = true;
d802 4
a805 1
		curr_board->trace_counter();
d807 4
a810 1
		defaults.trace_counter = true;
d815 4
a818 1
		curr_board->final_insn_count();
d820 4
a823 1
		defaults.final_insn_count = true;
d828 4
a831 1
		curr_board->trace_core();
d833 4
a836 1
		defaults.trace_core = true;
d851 2
a852 1
		if (! AtomicCfg::wrap_component (c))
d857 1
d864 4
a867 1
		curr_board->set_step_insn_count(optstring());
d869 4
a872 1
		defaults.step_insn_count = optstring();
d904 1
a904 1
	      need_sess (sess);
d934 4
a937 1
		curr_board->set_ulog_level (optaddr ("ulog-level"));
d941 2
a942 1
		  need_sess (sess);
d949 4
a952 1
		curr_board->set_ulog_mode (optstring ());
d956 2
a957 1
		  need_sess (sess);
d963 1
a963 1
	      need_sess (sess);
d973 34
d1009 1
a1009 1
	  
d1019 14
a1032 1
    sess->add_board (curr_board);
@


1.5
log
@2003-10-21  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (try_load_file): Call set_loader of
        session or board as appropriate.
        * commonCfg.h (loader): New member of SessionCfg.
        (set_loader): New method of SessionCfg.
        (loader): New member of SessionCfg.
        (set_loader): New method of BoardCfg.
        * commonCfg.cxx (SessionCfg): Initialize loader.
        (set_loader): New method of SessionCfg.
        (BoardCfg): Initialize loader.
        (set_loader): New method of SessionCfg.
        (set_loader): New method of BoardCfg.
@
text
@d3 1
a3 1
// Copyright (C) 1999, 2000, 2001, 2002, 2003 Red Hat.
d620 1
a620 1
		  sess->add_child (curr_board);
d881 1
a881 1
    sess->add_child (curr_board);
@


1.4
log
@2003-06-10  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (usage): Document --ulog-* options.
        (try_add_memory): Don't make the base of the mapping zero by default.
        (Defs): New members: ulog_level, ulog_mode, ulog_file.
        (option_num): New members: opt_ulog_level, opt_ulog_mode,
        opt_ulog_file.
        (long_options): Add ulog-*.
        (main): Provide defaults for ulog-*. Handle opt_ulog_*.
        * commonCfg.h (struct UlogCfg): New struct.
        (SessionCfg): Now inherits UlogCfg.
        (add_ulog_file): New method of SessionCfg.
        (ulog_map): New member of SessionCfg.
        (BoardCfg): Now inherits UlogCfg.
        * commonCfg.cxx (SessionCfg): Add a ulog mapping for "-" to ulog_map.
        (add_ulog_file): New method of SeessionCfg.
        (BoardCfg): Initialize UlogCfg.
        (add_memory): Set the base for the mapping to 0.
@
text
@d126 1
a126 1
  cout << "--ulog-file=*|FILE    Set the log file name" << endl;
d229 1
a229 1
      sess->add_child (loader);
d237 1
a237 1
	  board->add_child (loader);
a378 1
  assert (map);
@


1.3
log
@* new simulator mainline

2002-05-30  Frank Ch. Eigler  <fche@@redhat.com>

	* mainDynamic.cxx (main): Add new "--rc" option to control passing
	cfgroot stop-code as sid process exit rc.

2002-04-29  Graydon Hoare  <graydon@@redhat.com>

	* mainDynamic.cxx: Make step_insn_count a string.

2002-04-29  Graydon Hoare  <graydon@@redhat.com>

	* commonCfg.h (Mapping): New class.
	* commonCfg.cxx (MapperCfg): Update to use Mapping objects.
	* mainDynamic.cxx (try_add_memory): Use Mapping objects.
	(Defs): Make step_insn_count a defaultable option.

2002-04-23  Graydon Hoare  <graydon@@redhat.com>

	* mainDynamic.cxx (try_add_memory): Force mappings to base address
	0 in extra memory region, to ignore transparent / basic mapper
	distinction in board-specific code.

2002-04-15  Dave Brolley  <brolley@@redhat.com>

	* commonCfg.cxx (struct MemCfg_impl): New struct.
	(MemCfg_impl::get_by_name): New function.
	(MemCfg::MemCfg): Add 'this' to name_map.
	* commonCfg.h (MemCfg_impl::get_by_name): New function.

2002-04-09  Dave Brolley  <brolley@@redhat.com>

	* commonCfg.cxx (add_mapping): New variant.
	* commonCfg.h (add_mapping): New variant.

2002-03-25  Graydon Hoare  <graydon@@redhat.com>

	* mainDynamic.cxx (try_load_file): Support "all-cpu" sub-option
	to --load option.
	* commonCfg.h (CpuCfg::get_all): Likewise.
	* commonCfg.cxx (CpuCfg::get_all): Likewise.

2002-03-11  Graydon Hoare  <graydon@@redhat.com>

	* mainDynamic.cxx (main): Add opt_gloss.
	* commonCfg.cxx (BoardCfg::use_gloss): Define.
	* commonCfg.h: Likewise.

2002-02-22  Graydon Hoare  <graydon@@redhat.com>

	* Makefile.am (INCLUDE): Add -I$(srcdir)/../../../include.
	* Makefile.in: Regenerate.
	* mainDynamic.cxx: Un-guard #include <getopt.h>, getting it
	from libiberty now.

2002-02-08  Graydon Hoare  <graydon@@redhat.com>

	* baseCfg.cxx: New file.
	* baseCfg.h: New file.
	* commonCfg.cxx: New file.
	* commonCfg.h: New file.
	* mainDynamic.cxx: Complete rewrite, incorporate contents of
	configrun-sid.in perl script.
	* Makefile.am (sid): Add new files to target.
	* Makefile.in: Regenerate.
@
text
@d3 1
a3 1
// Copyright (C) 1999, 2000, 2001, 2002 Red Hat.
d123 4
d388 1
a388 1
	.slave(mem).bus(port).base(0)
d391 1
a391 1
	map->map (m);
d469 3
d482 3
d527 2
a528 1
		    opt_final_insn_count, opt_eb, opt_el, opt_gprof };
d573 3
d649 3
d835 34
@


1.2
log
@* version string

2001-10-05  Frank Ch. Eigler  <fche@@redhat.com>

	* Makefile.am (all-local): Create version.h file with $(VERSION) in it.
	* Makefile.in: Regenerated.

[main/dynamic]
2001-10-05  Frank Ch. Eigler  <fche@@redhat.com>

        * mainDynamic.cxx (version): New function.  Use SID_VERSION from
        new version.h file.
        (main): Support "-v" option to print this information.
        * Makefile.am (sid_DEPENDENCIES): List version.h.
        * configure, Makefile.in: Regenerated.
@
text
@d1 1
a1 1
// mainDynamic.cxx - One possible mainline.  -*- C++ -*-
d3 1
a3 1
// Copyright (C) 1999-2001 Red Hat.
d11 3
a13 7
#include <sidcomp.h>
#include <sidso.h>
#include <sidpinutil.h>
#include <sidcomputil.h>

#include <unistd.h>
#ifdef HAVE_GETOPT_H
a14 10
#endif


using namespace std;
using namespace sid;
using namespace sidutil;


// Link to compConfig component directly.
extern component_library /* *not* DLLIMPORT */ config_component_library;
d23 1
d26 19
d49 1
a49 1
  cout << "Copyright 1999-2001 Red Hat, Inc." << endl;
d54 1
d59 6
a64 6
  cout << "OPTIONS:" << endl;
  cout << "-h        print this help" << endl;
  cout << "-v        print version" << endl;
  cout << "-n        load/check configuration but do not run simulation" << endl;
  cout << "-f FILE   also read configuration FILE" << endl;
  cout << "-e LINE   also do configuration LINE" << endl;
d66 2
a67 1
  cout << "All -f/-e options are performed first, in sequence." << endl;
d69 414
d492 7
a498 1
  string config_file;
d508 57
d567 2
a568 1
      int c = getopt (argc, argv, "hvne:f:");
d587 1
a587 1
	  config_items.push_back (make_pair (false, string(optarg)));
d591 229
a819 1
	  config_items.push_back (make_pair (true, string(optarg)));
d821 1
d823 1
d830 5
d836 2
a837 5
  // Treat remaining arguments as file names
  for (unsigned j=optind; j<argc; j++)
    {
      config_items.push_back (make_pair (true, string(argv[j])));
    }
d839 1
a839 1
  component* main_component = 
d848 1
a848 2
  // select & load the config file
  bool config_ok = true;
d850 6
d857 4
d864 2
a865 1
  for (unsigned k=0; k < config_items.size(); k++)
d867 2
a868 5
      const pair<bool,string>& item = config_items[k];
      sid::component::status s;

      if (item.first == true)
	s = main_component->set_attribute_value ("config-file!", item.second);
d870 1
a870 10
	s = main_component->set_attribute_value ("config-line!", item.second);

      if(s != sid::component::ok)
	config_ok = false;
    }

  if (! config_ok)
    {
      cerr << "Configuration error.  Aborting." << endl;
      return 3;
d872 1
a872 1

a874 1

d892 7
d901 5
@


1.1
log
@* public snapshot of sid simulator
@
text
@d3 1
a3 1
// Copyright (C) 1999, 2000 Red Hat.
d9 2
d40 9
d54 1
d74 3
a76 1
      usage();
d82 1
a82 1
      int c = getopt (argc, argv, "hne:f:");
d90 4
@

