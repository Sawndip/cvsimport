head	1.13;
access;
symbols
	sid-snapshot-20180601:1.13
	sid-snapshot-20180501:1.13
	sid-snapshot-20180401:1.13
	sid-snapshot-20180301:1.13
	sid-snapshot-20180201:1.13
	sid-snapshot-20180101:1.13
	sid-snapshot-20171201:1.13
	sid-snapshot-20171101:1.13
	sid-snapshot-20171001:1.13
	sid-snapshot-20170901:1.13
	sid-snapshot-20170801:1.13
	sid-snapshot-20170701:1.13
	sid-snapshot-20170601:1.13
	sid-snapshot-20170501:1.13
	sid-snapshot-20170401:1.13
	sid-snapshot-20170301:1.13
	sid-snapshot-20170201:1.13
	sid-snapshot-20170101:1.13
	sid-snapshot-20161201:1.13
	sid-snapshot-20161101:1.13
	sid-snapshot-20160901:1.13
	sid-snapshot-20160801:1.13
	sid-snapshot-20160701:1.13
	sid-snapshot-20160601:1.13
	sid-snapshot-20160501:1.13
	sid-snapshot-20160401:1.13
	sid-snapshot-20160301:1.13
	sid-snapshot-20160201:1.13
	sid-snapshot-20160101:1.13
	sid-snapshot-20151201:1.13
	sid-snapshot-20151101:1.13
	sid-snapshot-20151001:1.13
	sid-snapshot-20150901:1.13
	sid-snapshot-20150801:1.13
	sid-snapshot-20150701:1.13
	sid-snapshot-20150601:1.13
	sid-snapshot-20150501:1.13
	sid-snapshot-20150401:1.13
	sid-snapshot-20150301:1.13
	sid-snapshot-20150201:1.13
	sid-snapshot-20150101:1.13
	sid-snapshot-20141201:1.13
	sid-snapshot-20141101:1.13
	sid-snapshot-20141001:1.13
	sid-snapshot-20140901:1.13
	sid-snapshot-20140801:1.13
	sid-snapshot-20140701:1.13
	sid-snapshot-20140601:1.13
	sid-snapshot-20140501:1.13
	sid-snapshot-20140401:1.13
	sid-snapshot-20140301:1.13
	sid-snapshot-20140201:1.13
	sid-snapshot-20140101:1.13
	sid-snapshot-20131201:1.13
	sid-snapshot-20131101:1.13
	sid-snapshot-20131001:1.13
	sid-snapshot-20130901:1.13
	sid-snapshot-20130801:1.13
	sid-snapshot-20130701:1.13
	sid-snapshot-20130601:1.13
	sid-snapshot-20130501:1.13
	sid-snapshot-20130401:1.13
	sid-snapshot-20130301:1.13
	sid-snapshot-20130201:1.13
	sid-snapshot-20130101:1.13
	sid-snapshot-20121201:1.13
	sid-snapshot-20121101:1.13
	sid-snapshot-20121001:1.13
	sid-snapshot-20120901:1.13
	sid-snapshot-20120801:1.13
	sid-snapshot-20120701:1.13
	sid-snapshot-20120601:1.13
	sid-snapshot-20120501:1.13
	sid-snapshot-20120401:1.13
	sid-snapshot-20120301:1.13
	sid-snapshot-20120201:1.13
	sid-snapshot-20120101:1.13
	sid-snapshot-20111201:1.13
	sid-snapshot-20111101:1.13
	sid-snapshot-20111001:1.13
	sid-snapshot-20110901:1.13
	sid-snapshot-20110801:1.13
	sid-snapshot-20110701:1.13
	sid-snapshot-20110601:1.13
	sid-snapshot-20110501:1.13
	sid-snapshot-20110401:1.13
	sid-snapshot-20110301:1.13
	sid-snapshot-20110201:1.13
	sid-snapshot-20110101:1.13
	sid-snapshot-20101201:1.13
	sid-snapshot-20101101:1.13
	sid-snapshot-20101001:1.13
	sid-snapshot-20100901:1.13
	sid-snapshot-20100801:1.13
	sid-snapshot-20100701:1.13
	sid-snapshot-20100601:1.13
	sid-snapshot-20100501:1.13
	sid-snapshot-20100401:1.13
	sid-snapshot-20100301:1.13
	sid-snapshot-20100201:1.13
	sid-snapshot-20100101:1.13
	sid-snapshot-20091201:1.13
	sid-snapshot-20091101:1.13
	sid-snapshot-20091001:1.13
	sid-snapshot-20090901:1.13
	sid-snapshot-20090801:1.13
	sid-snapshot-20090701:1.13
	sid-snapshot-20090601:1.13
	sid-snapshot-20090501:1.13
	sid-snapshot-20090401:1.13
	sid-snapshot-20090301:1.13
	sid-snapshot-20090201:1.13
	sid-snapshot-20090101:1.13
	sid-snapshot-20081201:1.13
	sid-snapshot-20081101:1.13
	sid-snapshot-20081001:1.13
	sid-snapshot-20080901:1.13
	sid-snapshot-20080801:1.13
	sid-snapshot-20080701:1.13
	sid-snapshot-20080601:1.12
	sid-snapshot-20080501:1.12
	sid-snapshot-20080403:1.12
	sid-snapshot-20080401:1.12
	sid-snapshot-20080301:1.12
	sid-snapshot-20080201:1.12
	sid-snapshot-20080101:1.12
	sid-snapshot-20071201:1.12
	sid-snapshot-20071101:1.12
	sid-snapshot-20071001:1.12;
locks; strict;
comment	@ * @;


1.13
date	2008.06.17.18.11.51;	author brolley;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.19.17.00.54;	author brolley;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.05.20.28.42;	author brolley;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.11.20.27.02;	author brolley;	state Exp;
branches;
next	1.9;

1.9
date	2005.08.23.21.09.48;	author brolley;	state Exp;
branches;
next	1.8;

1.8
date	2005.08.19.19.48.45;	author brolley;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.10.15.51.08;	author brolley;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.29.20.28.01;	author brolley;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.01.23.35.37;	author brolley;	state Exp;
branches;
next	1.4;

1.4
date	2004.03.22.21.28.55;	author brolley;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.21.21.39.04;	author brolley;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.10.18.29.51;	author brolley;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.09.04.22.50;	author bje;	state Exp;
branches;
next	;


desc
@@


1.13
log
@2008-06-17  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (usage): Document --reversible.
        (try_add_memory): Call sess->add_memory.
        (option_num): add opt_reversible.
        (long_options): Add "reversible".
        (main): Handle opt_reversible.
        * commonCfg.h (set_reversible): New method of SessionCfg.
        (add_memory): Likewise.
        (reversible_p): New member of SessionCfg.
        (memory): Likewise.
        * commonCfg.cxx (CpuCfg): Establish sim-sched relation.
        (SessionCfg): Initialize reversible_p.
        (SessionCfg::write_load): Set up all memory regions as reversible,
        if requested.
        (BoardCfg::write_config): Set up the cpu to be reversible, if
        requested.
@
text
@#ifndef __commonCfg_h__
#define __commonCfg_h__

#include "baseCfg.h"
#include <vector>

class MemCfg :
  virtual public AtomicCfg
{
public:
  MemCfg (const string name);
  MemCfg (const string name, 
	  sid::host_int_4 sz);
  MemCfg (const string name, 
	  sid::host_int_4 read_lat,
	  sid::host_int_4 write_lat);
  MemCfg (const string name, 
	  sid::host_int_4 sz,
	  sid::host_int_4 read_lat,
	  sid::host_int_4 write_lat);
  virtual ~MemCfg();
  void set_read_latency (sid::host_int_4 lat);
  void set_write_latency (sid::host_int_4 lat);
  void set_size (sid::host_int_4 sz);
  sid::host_int_4 size();
  sid::host_int_4 read_latency();
  sid::host_int_4 write_latency();  
  static MemCfg *get_by_name (const string name);

 protected:
  sid::host_int_4 my_size;
  sid::host_int_4 my_read_latency;
  sid::host_int_4 my_write_latency;    
};

class CacheCfg :
  virtual public AtomicCfg
{
public:
  // n-byte buffers
  CacheCfg (const string name, sid::host_int_4 size = 8);
  // direct caches
  CacheCfg (const string name, 
	    const sid::host_int_4 size, 
	    const sid::host_int_4 linesize);
  // complex associative caches
  CacheCfg (const string name, 
	    const string assoc, 
	    const sid::host_int_4 size, 
	    const sid::host_int_4 linesize, 
	    const string replace);
  virtual ~CacheCfg();
  void set_upstream (ComponentCfg *c, const string accessorname);
  void set_downstream (ComponentCfg *c, const string busname);
  void set_hit_latency (sid::host_int_4 i);
  void set_miss_latency (sid::host_int_4 i);
  void set_refill_latency (sid::host_int_4 i);
  sid::host_int_4 size ();
  sid::host_int_4 line_size ();
  void set_size (sid::host_int_4 sz);
  void set_line_size (sid::host_int_4 sz);
  void set_way (sid::host_int_4 sz);
  sid::host_int_4 get_size () const { return my_size; }
  sid::host_int_4 get_line_size () const {return my_line_size; }
 protected:
  virtual void compute_comptype ();
  string my_assoc;
  sid::host_int_4 my_size;
  sid::host_int_4 my_line_size;
  string my_replace;
};

class BlockingCacheCfg :
  public CacheCfg
{
public:
  // 8-byte buffers
  BlockingCacheCfg (const string name);
  // direct caches
  BlockingCacheCfg (const string name, 
		    const sid::host_int_4 size, 
		    const sid::host_int_4 linesize);
  // complex associative caches
  BlockingCacheCfg (const string name, 
		    const string assoc, 
		    const sid::host_int_4 size, 
		    const sid::host_int_4 linesize, 
		    const string replace);
  virtual ~BlockingCacheCfg();
};


class SchedCfg :
  virtual public AtomicCfg
{
public:
  SchedCfg (const string name, const string variant);
  virtual ~SchedCfg ();
  int add_subscription (ComponentCfg *c, 
			string event);
  int add_subscription (ComponentCfg *c, 
			string event, 
			string control);
  int add_subscription (ComponentCfg *c, 
			string event, 
			string control,
			string time_query,
			string time_high,
			string time_low);
  void set_regular (int n, bool v);
  void set_time (int n, int tv);
  void set_priority (int n, int pv);
  virtual void write_config (Writer &w);

  static const int config_priority  = 2;
  static const int gprof_priority   = 1;
  static const int default_priority = 0;

protected:
  int n;
};

// small helper for optional values
template <typename T>
struct Maybe
{
  Maybe () : val (), specified (false) {}
  Maybe (const T &x) : val (x), specified (true) {}
  T val;
  bool specified;
};

// helper for unambiguously constructing mappings 
struct Mapping
{
  Maybe <ComponentCfg *>  _slave;
  Maybe <string>          _bus;
  Maybe <string>          _banks;
  Maybe <sid::host_int_4> _low;
  Maybe <sid::host_int_4> _high;
  Maybe <sid::host_int_4> _wordsz;
  Maybe <sid::host_int_4> _stride;
  Maybe <sid::host_int_4> _width;
  Maybe <sid::host_int_4> _base;
  
  public:
  
  Mapping () {}
  
  Mapping & slave  (ComponentCfg *i)   { _slave = Maybe <ComponentCfg *> (i);   return *this; }
  Mapping & bus    (const string &i)   { _bus = Maybe <string> (i);             return *this; }
  Mapping & banks  (const string &i)   { _banks = Maybe <string> (i);           return *this; }
  Mapping & low    (sid::host_int_4 i) { _low = Maybe <sid::host_int_4> (i);    return *this; }
  Mapping & high   (sid::host_int_4 i) { _high = Maybe <sid::host_int_4> (i);   return *this; }
  Mapping & wordsz (sid::host_int_4 i) { _wordsz = Maybe <sid::host_int_4> (i); return *this; }
  Mapping & stride (sid::host_int_4 i) { _stride = Maybe <sid::host_int_4> (i); return *this; }
  Mapping & width  (sid::host_int_4 i) { _width = Maybe <sid::host_int_4> (i);  return *this; }
  Mapping & base   (sid::host_int_4 i) { _base = Maybe <sid::host_int_4> (i);   return *this; }  
  
  Mapping & slave  () { _slave = Maybe <ComponentCfg *> ();   return *this; }
  Mapping & bus    () { _bus = Maybe <string> ();             return *this; }
  Mapping & banks  () { _banks = Maybe <string> ();           return *this; }
  Mapping & low    () { _low = Maybe <sid::host_int_4> ();    return *this; }
  Mapping & high   () { _high = Maybe <sid::host_int_4> ();   return *this; }
  Mapping & wordsz () { _wordsz = Maybe <sid::host_int_4> (); return *this; }
  Mapping & stride () { _stride = Maybe <sid::host_int_4> (); return *this; }
  Mapping & width  () { _width = Maybe <sid::host_int_4> ();  return *this; }
  Mapping & base   () { _base = Maybe <sid::host_int_4> ();   return *this; }  
  
};

class MapperCfg :
  virtual public AtomicCfg
{
public:
  MapperCfg (const string name, bool transparent = false);
  virtual ~MapperCfg ();
  virtual void map (const Mapping &m);
  void set_transparent (bool t);
  virtual void add_prefix (const string prefix);
  static MapperCfg *get_by_name (const string name);
};


class GlueSeqCfg : 
  virtual public AtomicCfg
{
 public:
  GlueSeqCfg (const string name);
  void add_output (int seqnum, ComponentCfg *c, string pin_name);
  virtual void write_config (Writer &w);
 protected:
  int n;
};

// Configs which support logging should inherit this
struct UlogCfg
{
  UlogCfg (sid::host_int_4 l = 0, const string m = "less", const string f = "-")
    : ulog_level (l), ulog_mode (m), ulog_file (f)
  {}
  virtual void set_ulog_level (sid::host_int_4 l) { ulog_level = l; }
  virtual void set_ulog_mode (const string m) { ulog_mode = m; }
  virtual void set_ulog_file (const string f) { ulog_file = f; }
  sid::host_int_4 ulog_level;
  string ulog_mode;
  string ulog_file;
};

// you should really only make one of these, with an empty name,
// unless you want some crazy multi-session support.
class BoardCfg;
class LoaderCfg;

struct SessionCfg :
  virtual public AggregateCfg, public UlogCfg
{
  SessionCfg (const string name);
  virtual ~SessionCfg ();  
  SchedCfg *host_sched;
  SchedCfg *sim_sched;
  GlueSeqCfg *init_seq;
  GlueSeqCfg *reset_net;
  GlueSeqCfg *shutdown_seq;
  GlueSeqCfg *yield_net;
  AtomicCfg *stdio_obj;
  AtomicCfg *main_obj;
  LoaderCfg *loader;
  // optional bits
  virtual void write_load (Writer &w);
  void use_audio();
  void use_tksched();
  void use_tksm();
  void use_tcl_bridge();
  void use_no_stdio ();
  void set_reversible () { reversible_p = true; }
  virtual void set_loader (LoaderCfg *l);
  LoaderCfg *get_loader () const { return loader; }
  AtomicCfg *audio;
  AtomicCfg *tksched;
  AtomicCfg *tksm;
  AtomicCfg *tcl_bridge;
  bool verbose;
  bool use_stdio;
  bool reversible_p;
  bool need_gprof;
  bool need_core_probe;
  bool maybe_model_busses;
  void add_ulog_file (const string filename);

  map<const string, AtomicCfg *> ulog_map;
  void add_gdb () { ++gdb_count; }
  void add_board (ComponentCfg *b) { ++board_count; add_child (b); }
  void add_memory (MemCfg *mem) { memory.push_back (mem); }
  vector<MemCfg *> memory;
  virtual void write_config (Writer &w);
  // Support for dynamic configuration profiles
  vector<AtomicCfg *> wrapped_components;
  void add_wrapped_component (AtomicCfg *comp) { wrapped_components.push_back (comp); }
  string wrap_config ();
  void profile_config (const string &spec);
protected:
  void add_profile_config (const string &name, const string &options);
  void profile_config_error (const string &spec);
  string profile_opt_value (const string& opt, const vector<string>& opt_parts, unsigned max_parts);
  string profile_opt_int_value (const string& opt, const vector<string>& opt_parts);
  string profile_opt_gprof_value (const string& opt, const vector<string>& opt_parts);
  bool match_profile_opt (const string &opt, const string& want, unsigned min_size);
private:
  sid::host_int_4 board_count;
  sid::host_int_4 gdb_count;
};

class CpuCfg :
  virtual public AtomicCfg
{
public:
  CpuCfg (const string name, 
	  const string variant,
	  SessionCfg *sess);
  virtual ~CpuCfg ();
  void set_imem (ComponentCfg *m, string busname);
  void set_dmem (ComponentCfg *m, string busname);
  void set_disasm_mem (ComponentCfg *m, string busname);
  void set_variant (const string var);
  int get_subscription_number();
  virtual void add_prefix (const string prefix);
  static CpuCfg *get_by_name (const string name);
  static void get_all (vector <CpuCfg *> &targ);
 protected:
  int event_subscription;
};

class LoaderCfg :
  virtual public AtomicCfg
{
public:
  LoaderCfg (const string name, 
	     SessionCfg *sess);
  virtual ~LoaderCfg ();
  void set_target (ComponentCfg *mem, const string mem_bus_name);
  void add_cpu (CpuCfg *cpu);
  void set_file (const string filename);
};


class GlossCfg :
  virtual public AtomicCfg
{
public:
  GlossCfg (const string name, 
	    CpuCfg *cpu, 
	    ComponentCfg *mem,
	    const string mem_bus_name,
	    SessionCfg *sess);
  GlossCfg (const string name, 
	    CpuCfg *cpu, 
	    SessionCfg *sess);
  virtual ~GlossCfg ();
};

class GprofCfg :
  virtual public AtomicCfg
{
public:
  GprofCfg (const string name, 
	    const string filename,
	    CpuCfg *cpu, 
	    SessionCfg *sess,
	    gprof_type type,
            int interval);
  GprofCfg (const string name, 
	    CpuCfg *cpu, 
	    SessionCfg *sess);
  virtual ~GprofCfg ();
};

class GdbCfg :
  virtual public AggregateCfg
{
 public:
  GdbCfg (const string name, 
	  const string port, 
	  CpuCfg *c, 
	  BoardCfg *b,
	  SessionCfg *s);
  virtual ~GdbCfg ();
  virtual void write_config (Writer &w);
 protected:
  CpuCfg *cpu;
  BoardCfg *board;
  SessionCfg *sess;
  AtomicCfg *stub;
  AtomicCfg *sock;
};

class LoaderCfg;
class BoardCfg :
virtual public AggregateCfg, public UlogCfg
{
public:
  BoardCfg (const string name,
	    const string default_cpu_variant,
	    SessionCfg *s,
	    bool with_default_gloss = true,
	    bool with_z_packet = true,
	    bool with_cpu_main_mem_connect = false);    
  virtual void use_gloss ();
  virtual void set_cpu (const string variant);
  virtual void set_loader (LoaderCfg *l);
  virtual void set_gdb (const string port);
  virtual void set_gprof (const string filename, gprof_type type, int interval);
  virtual void set_engine (const string engine);
  virtual void set_step_insn_count (const string count);
  virtual void set_endian (const string endian);
  virtual void add_sidrtc (sid::host_int_4 addr);
  virtual void add_sidcodec (sid::host_int_4 addr);
  virtual void add_dcache (const string type);
  virtual void add_icache (const string type);
  virtual void add_memory (const Mapping &m);
  virtual void enable_warnings ();
  virtual void final_insn_count ();
  virtual void trace_counter ();
  virtual void trace_extract ();
  virtual void trace_semantics ();
  virtual void trace_disassemble ();
  virtual void trace_core ();
  virtual void set_warmup (bool w = true);
  virtual void add_profile_func (const string &spec);
  virtual void add_warmup_func (const string &funcs);
  virtual void set_start_config (const string &config);
  virtual void write_load (Writer &w);
  virtual void write_config (Writer &w);

  // Mep-specific options
  virtual void set_config_index (unsigned i = 0) {}
  virtual void set_warn_write_to_code (bool b = true) {}
  virtual void set_warn_write_to_rom (bool b = true) {}
  virtual void set_allow_write_to_rom (bool b = true) {}
  virtual void set_model_busses (bool b = true) {}
  virtual void set_dsp_user_out (bool b = true) {}
  virtual void set_corrupt_caches (bool b = true) {}
  virtual void set_opt_insn (string s = "") {}
  virtual void set_opt_no_insn (string s = "") {}
  virtual void set_opt_local_mem (string s = "") {}
  virtual void set_opt_global_mem (string s = "") {}
  virtual void set_opt_shadow_mem (string s = "") {}
  virtual void set_opt_dmac_channel_bitw (string s = "") {}
  virtual void set_opt_biu_width (string s = "") {}
  virtual void set_opt_dmac_rectangle (bool b = false) {}
  virtual void set_opt_imem_size (string s = "") {}
  virtual void set_opt_dmem_size (string s = "") {}
  virtual void set_opt_dmem_bank_num (string s = "") {}
  virtual void set_opt_dmem_fixed_start_address (bool b = false) {}
  virtual void set_opt_icache_size (string s = "") {}
  virtual void set_opt_icache_line_size (string s = "") {}
  virtual void set_opt_icache_way (string s = "") {}
  virtual void set_opt_icache_cwf (string s = "") {}
  virtual void set_opt_dcache_size (string s = "") {}
  virtual void set_opt_dcache_line_size (string s = "") {}
  virtual void set_opt_dcache_way (string s = "") {}
  virtual void set_opt_dcache_cwf (string s = "") {}
  virtual void set_opt_intc_channel_bitw (string s = "") {}
  virtual void set_opt_intc_level (string s = "") {}
  virtual void set_opt_timer_channel_bitw (string s = "") {}

  virtual ~BoardCfg ();

  GlueSeqCfg *cache_flush_net;
  bool z_packet;
  CpuCfg *cpu;
  SessionCfg *sess;
  MapperCfg *main_mapper;
  AtomicCfg *dynamic_configurator;

 protected:
  GdbCfg *gdb;
  GlossCfg *gloss;
  GprofCfg *gprof;
  AtomicCfg *core_probe;
  AtomicCfg *icache;
  AtomicCfg *dcache;  
  LoaderCfg *loader;

  string start_config;
  string warmup_funcs;
  string profile_funcs;
  string step_insn_count;
  bool step_insn_count_1_required_p;
};

#endif // __commonCfg_h__
@


1.12
log
@2007-02-19  Dave Brolley  <brolley@@redhat.com>

        * mepCfg.cxx (MepMemCfg::set_dynamic_config): Relate the gbmif as a
        client of the dynamic_configurator if it exists.
        (MepBoardCfg::map_mm_int): Removed.
        (MepBoardCfg::write_load): Call set_model_busses, if necessary.
        (MepBoardCfg::write_config): Call shared_main_mem->mep_mm_int, if
        necessary. Relate the gbif and lbif clients of the dynamic_configurator
        if they exist and may be wrapped.
        * commonCfg.cxx (SessionCfg): Initialize maybe_model_busses.
        (profile_config): Set maybe_model_busses, if necessary.
        * commonCfg.h (maybe_model_busses): New member of SessionCfg.
@
text
@d236 1
d245 1
d254 2
@


1.11
log
@Support for Toshiba MeP.
@
text
@d246 1
@


1.10
log
@2006-05-11  Dave Brolley  <brolley@@redhat.com>

        * commonCfg.cxx (CacheCfg::CacheCfg (const string name)): Now takes
        a second argument for the size of the buffer. Initialize my_size using
        the size provided. Call compute_comptype.
        (compute_comptype): Use my_size to complete "hw_cache_buffer-".
        (BoardCfg): Initalize step_insn_count. Initialize
        step_insn_count_1_required.
        (BoardCfg::write_load): Set the cpu's step-insn-count based on
        step_insn_count_1_required.
        (set_step_insn_count): Just set step_insn_count here.
        (trace_counter): Set step_insn_count_1_required.
        * commonCfg.h (CacheCfg::CacheCfg (const string name)): Now takes
        a second argument for the size of the buffer.
        (step_insn_count): New member of BoardCfg.
        (step_insn_count_1_required): New member of BoardCfg.
@
text
@d390 32
@


1.9
log
@2005-08-23  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (try_add_gprof): Initialize interval.
        * commonCfg.cxx (set_priority): New method of SchedCfg.
        (GprofCfg): Always call set_time, set_regular and set_priority.
        (BoardCfg::write_load): Don't connect init-seq to the dynamic
        configurator's step! pin. Call set_priority.
        * commonCfg.h (set_priority): New method of SchedCfg.
        (config_priority,gprof_priority,default_priority): New constants in
        SchedCfg.
@
text
@d40 2
a41 2
  // 8-byte buffers
  CacheCfg (const string name);
d411 2
@


1.8
log
@2005-08-19  Dave Brolley  <brolley@@redhat.com>
        (record_data_memory_write_latency): New virtual method.
        * Contribute the following changes:n_memory_read_latency.
        (write_insn_memory): Call record_insn_memory_write_latency.
        2005-07-13  Dave Brolley  <brolley@@redhat.com>ad_latency.
        (write_data_memory): Call record_data_memory_write_latency.
        * mepCfg.cxx (set_dynamic_config): New method of MepMemCfg.::check_level
        (MepCacheCfg::set_dynamic_config): Don't use the new-config pin
        or the dynamic-configurator attribute. Instead, relate the cache
        to the dynamic configurator using its client relation.
        (MepBoardCfg::write_config): Likewise for the insn_buffer, dmac,result
        hw_engines and peripherals. Call set_dynamic_config for shared_main_mem.
        * mainDynamic.cxx (BoardConfig): New struct type.
        (main): Keep a vector of the boards in board_configs. Call:ok.
        set_start_config for each board after all the --wrap options have
        been seen. Call add_wrapped_component to identify each wrapped
        component to the session.y@@redhat.com>
        * commonCfg.h (wrapped_components): New member of SessionCfg.
        (add_wrapped_component): New method of SessionCfg.New class.
        (wrap_config): Likewise.ule): Reschedule after the given number of
        * commonCfg.cxx (wrap_config): New method of SessionCfg.
        (profile_config): Use possible_wrap_name to obtain the component
        being wrapped so we can get its name.
        (GdbCfg::write_config): Don't connect the new-config pin or use the
        dynamic-configurator relation. Instead, use the dynamic configurator's
        client relation.
        (BoardCfg::write_config): Likewise. Relate the dynamic configurator
        to gloss.
        * baseCfg.cxx (wrap_component): Now returns AtomicCfg *.
        (possible_wrap_name): Likewise.
        (dynamic_config_for_wrapped_children): Don't connect the dynamic
        configurator's new-config pin to the components or relate the
        dynamic configurator to them. Rather, relate the components to the
        dynamic configurator using its 'client' relation.
        * baseCfg.h (wrap_component): Now returns AtomicCfg *.
        (possible_wrap_name): Likewise.

        2005-07-05  Dave Brolley  <brolley@@redhat.com>

        * commonCfg.cxx (BoardCfg::write_load): Connect dynamic configurator's
        "reset" pin to output 2 of reset_net.
        (write_config): Set the "start-config" attribute of the dynamic
        configurator not gloss. Relate "main" to the dynamic configurator
        unconditionally. Connect the "config-error" pins of the dynamic
        configurator and gloss.

        2005-06-30  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (try_add_gprof): Make sure an argument is specified
        after the comma.

        2005-06-06  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (need_sess): Now takes 'verbose' argument. Use it
        to initialize sess->verbose. Update all callers.
        (main): Add " --model-busses" to board_start_config instead of
        " --model_busses" (typo).
        * commonCfg.h (need_core_probe): New member of SessionCfg.
        (BoardCfg::dynamic_configurator): Now public.
        * commonCfg.cxx (SessionCfg): Initialize need_core_probe.
        (profile_config): Set need_core_probe for --trace-core. Call
        use_tcl_bridge and possible_wrap_name for --wrap.
        (LoaderCfg): Don't set verbose? attribute here.
        (GlossCfg): Likewise.
        (GdbCfg::write_config): Connect the stub and the socket to the
        dynamic_configurator.
        (BoardCfg): Initialize core_probe and warmup_funcs. Connect the cpu's
        print-insn-summary pin to the shutdown sequence here.
        (BoardCfg::write_load): Connect the dynamic configurator's step! pin
        to the init-sequence's output 6. Set the core_probe's trace?
        attribute. Set the gloss and loader's verbose? attributes.
        (BoardCfg::write_config): Give the dynamic configurator its own
        subscription to sim-sched. Set the cpu's 'main' and core-probe
        relations. Connect gloss, core_probe, loader and all of the board's
        wrapped childred to the dynamic configurator. Check whether components
        are wrapped before connecting them to the dynamic configurator. Don't co
nnect
        the cpu's print-insn-summary pin to the shutdown sequence here.
        * baseCfg.cxx (AtomicCfg): Initialize my_possibly_wrapped.
        (wrap_component): Set my_possibly_wrapped.
        (possible_wrap_name): New static method of AtomicCfg.
        (AtomicCfg::write_construct): Check my_possibly_wrapped. Set
        victim-trace? to false if only possibly wrapped.
        (dynamic_config_for_wrapped_children): New method of AggregateCfg.
        * baseCfg.h (possible_wrap_name): New static method of AtomicCfg.
        (possibly_wrapped): New method of AtomicCfg.
        (my_possibly_wrapped): New member of AtomicCfg.
        (dynamic_config_for_wrapped_children): New method of AggregateCfg.

        2005-05-29  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (usage): Document --profile-config,--profile-func,
        --warmup-func and --warmup.
        (Defs): Initialize warmup, profile_func and start_config.
        (warmup,profile_func,warmup_func,start_config): New members of Defs.
        (need_sess): Call profile_config with "sid-internal-warmup:".
        (opt_warmup,opt_warmup_func,opt_profile_func,opt_profile_config): New
        enumerators.
        (long_options): Add --profile-config,--profile-func,
        --warmup-func and --warmup.
        (main): Accumulate start_config with reconfigurable options which occur
        before the first --board. For each board call set_start_config with
        the value of start_config concatenated with the additional reconfigurabl
e
        options specified for that --board. Call set_warmup, add_warmup_func and
        add_profile_func for each board. Handle new option enums.
        * commonCfg.h (add_profile_config): New method of SessionCfg.
        (profile_config_error, profile_opt_value, profile_opt_int_value)
        (profile_opt_gprof_value, match_profile_opt, profile_config): New
        methods of SessionCfg.
        (GprofCfg): New constructor.
        (write_load): New virtual override in BoardCfg.
        (add_profile_func, add_warmup_func, set_warmup, set_start_config): New
        methods of BoardCfg.
        (need_gprof): New member of BoardCfg.
        (start_config,warmup_funcs,profile_funcs): New members of BoardCfg.
        * commonCfg.cxx (SessionCfg): Initialize need_gprof.
        (add_profile_config): New method of SessionCfg.
        (profile_config_error, profile_opt_value, profile_opt_int_value)
        (profile_opt_gprof_value, match_profile_opt, profile_config): New
        methods of SessionCfg.
        (GprofCfg): Always add a sunscription to sim_sched. Set the
        sim-sched-event attribute.
        (GprofCfg): New constructor.
        (BoardCfg): Initialize dynamic_configurator and start_config.
        (write_load): New virtual override in BoardCfg.
        (BoardCfg::write_config): Make connections and set attributes to allow
        for dynamic configuration.
        (add_profile_func, add_warmup_func, set_warmup, set_start_config): New
        methods of BoardCfg.
@
text
@d112 1
d114 5
@


1.7
log
@2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * commonCfg.cxx (~BlockingCacheCfg): New destructor.
        (BlockingCacheCfg): New constructors.
        * commonCfg.h (BlockingCacheCfg): New class.
@
text
@d238 2
d241 1
d246 12
d321 3
d377 5
d391 1
d401 4
@


1.6
log
@2004-04-27  Dave Brolley  <brolley@@redhat.com>

        * commonCfg.h (CacheCfg::compute_comptype): Now virtual.
        (SessionCfg::get_loader): New method.
@
text
@d73 19
@


1.5
log
@2004-04-01  Dave Brolley  <brolley@@redhat.com>

        * commonCfg.h (get_size): New method of CacheCfg.
        (get_line_size): Ditto.
@
text
@d66 1
a66 1
  void compute_comptype ();
d212 1
@


1.4
log
@2004-03-22  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (main): Call add_board in place of add_child.
        * commonCfg.h (add_gdb): New method of SessionCfg.
        (add_board): Ditto.
        (write_config): Ditto.
        (board_count): New member of SessionCfg.
        (gdb_count): Ditto.
        * commonCfg.cxx (SessionCfg): Initialize board_count and gdb_count.
        (SessionCfg::write_config): New method.
        (set_gdb): Call sess->add_gdb.
@
text
@d63 2
@


1.3
log
@2003-10-21  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (try_load_file): Call set_loader of
        session or board as appropriate.
        * commonCfg.h (loader): New member of SessionCfg.
        (set_loader): New method of SessionCfg.
        (loader): New member of SessionCfg.
        (set_loader): New method of BoardCfg.
        * commonCfg.cxx (SessionCfg): Initialize loader.
        (set_loader): New method of SessionCfg.
        (BoardCfg): Initialize loader.
        (set_loader): New method of SessionCfg.
        (set_loader): New method of BoardCfg.
@
text
@d185 1
d218 6
a286 1
class BoardCfg;
@


1.2
log
@2003-06-10  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (usage): Document --ulog-* options.
        (try_add_memory): Don't make the base of the mapping zero by default.
        (Defs): New members: ulog_level, ulog_mode, ulog_file.
        (option_num): New members: opt_ulog_level, opt_ulog_mode,
        opt_ulog_file.
        (long_options): Add ulog-*.
        (main): Provide defaults for ulog-*. Handle opt_ulog_*.
        * commonCfg.h (struct UlogCfg): New struct.
        (SessionCfg): Now inherits UlogCfg.
        (add_ulog_file): New method of SessionCfg.
        (ulog_map): New member of SessionCfg.
        (BoardCfg): Now inherits UlogCfg.
        * commonCfg.cxx (SessionCfg): Add a ulog mapping for "-" to ulog_map.
        (add_ulog_file): New method of SeessionCfg.
        (BoardCfg): Initialize UlogCfg.
        (add_memory): Set the base for the mapping to 0.
@
text
@d185 2
d200 1
d208 1
d300 1
d313 1
d348 1
@


1.1
log
@* new simulator mainline

2002-05-30  Frank Ch. Eigler  <fche@@redhat.com>

	* mainDynamic.cxx (main): Add new "--rc" option to control passing
	cfgroot stop-code as sid process exit rc.

2002-04-29  Graydon Hoare  <graydon@@redhat.com>

	* mainDynamic.cxx: Make step_insn_count a string.

2002-04-29  Graydon Hoare  <graydon@@redhat.com>

	* commonCfg.h (Mapping): New class.
	* commonCfg.cxx (MapperCfg): Update to use Mapping objects.
	* mainDynamic.cxx (try_add_memory): Use Mapping objects.
	(Defs): Make step_insn_count a defaultable option.

2002-04-23  Graydon Hoare  <graydon@@redhat.com>

	* mainDynamic.cxx (try_add_memory): Force mappings to base address
	0 in extra memory region, to ignore transparent / basic mapper
	distinction in board-specific code.

2002-04-15  Dave Brolley  <brolley@@redhat.com>

	* commonCfg.cxx (struct MemCfg_impl): New struct.
	(MemCfg_impl::get_by_name): New function.
	(MemCfg::MemCfg): Add 'this' to name_map.
	* commonCfg.h (MemCfg_impl::get_by_name): New function.

2002-04-09  Dave Brolley  <brolley@@redhat.com>

	* commonCfg.cxx (add_mapping): New variant.
	* commonCfg.h (add_mapping): New variant.

2002-03-25  Graydon Hoare  <graydon@@redhat.com>

	* mainDynamic.cxx (try_load_file): Support "all-cpu" sub-option
	to --load option.
	* commonCfg.h (CpuCfg::get_all): Likewise.
	* commonCfg.cxx (CpuCfg::get_all): Likewise.

2002-03-11  Graydon Hoare  <graydon@@redhat.com>

	* mainDynamic.cxx (main): Add opt_gloss.
	* commonCfg.cxx (BoardCfg::use_gloss): Define.
	* commonCfg.h: Likewise.

2002-02-22  Graydon Hoare  <graydon@@redhat.com>

	* Makefile.am (INCLUDE): Add -I$(srcdir)/../../../include.
	* Makefile.in: Regenerate.
	* mainDynamic.cxx: Un-guard #include <getopt.h>, getting it
	from libiberty now.

2002-02-08  Graydon Hoare  <graydon@@redhat.com>

	* baseCfg.cxx: New file.
	* baseCfg.h: New file.
	* commonCfg.cxx: New file.
	* commonCfg.h: New file.
	* mainDynamic.cxx: Complete rewrite, incorporate contents of
	configrun-sid.in perl script.
	* Makefile.am (sid): Add new files to target.
	* Makefile.in: Regenerate.
@
text
@d169 14
d186 1
a186 1
  virtual public AggregateCfg
d211 2
d297 1
a297 1
  virtual public AggregateCfg
d326 1
@

