head	1.23;
access;
symbols
	sid-snapshot-20180601:1.23
	sid-snapshot-20180501:1.23
	sid-snapshot-20180401:1.23
	sid-snapshot-20180301:1.23
	sid-snapshot-20180201:1.23
	sid-snapshot-20180101:1.23
	sid-snapshot-20171201:1.23
	sid-snapshot-20171101:1.23
	sid-snapshot-20171001:1.23
	sid-snapshot-20170901:1.23
	sid-snapshot-20170801:1.23
	sid-snapshot-20170701:1.23
	sid-snapshot-20170601:1.23
	sid-snapshot-20170501:1.23
	sid-snapshot-20170401:1.23
	sid-snapshot-20170301:1.23
	sid-snapshot-20170201:1.23
	sid-snapshot-20170101:1.23
	sid-snapshot-20161201:1.23
	sid-snapshot-20161101:1.23
	sid-snapshot-20160901:1.23
	sid-snapshot-20160801:1.23
	sid-snapshot-20160701:1.23
	sid-snapshot-20160601:1.23
	sid-snapshot-20160501:1.23
	sid-snapshot-20160401:1.23
	sid-snapshot-20160301:1.23
	sid-snapshot-20160201:1.23
	sid-snapshot-20160101:1.23
	sid-snapshot-20151201:1.23
	sid-snapshot-20151101:1.23
	sid-snapshot-20151001:1.23
	sid-snapshot-20150901:1.23
	sid-snapshot-20150801:1.23
	sid-snapshot-20150701:1.23
	sid-snapshot-20150601:1.23
	sid-snapshot-20150501:1.23
	sid-snapshot-20150401:1.23
	sid-snapshot-20150301:1.23
	sid-snapshot-20150201:1.23
	sid-snapshot-20150101:1.23
	sid-snapshot-20141201:1.23
	sid-snapshot-20141101:1.23
	sid-snapshot-20141001:1.23
	sid-snapshot-20140901:1.23
	sid-snapshot-20140801:1.23
	sid-snapshot-20140701:1.23
	sid-snapshot-20140601:1.23
	sid-snapshot-20140501:1.23
	sid-snapshot-20140401:1.23
	sid-snapshot-20140301:1.23
	sid-snapshot-20140201:1.23
	sid-snapshot-20140101:1.23
	sid-snapshot-20131201:1.23
	sid-snapshot-20131101:1.23
	sid-snapshot-20131001:1.23
	sid-snapshot-20130901:1.23
	sid-snapshot-20130801:1.23
	sid-snapshot-20130701:1.23
	sid-snapshot-20130601:1.23
	sid-snapshot-20130501:1.23
	sid-snapshot-20130401:1.23
	sid-snapshot-20130301:1.23
	sid-snapshot-20130201:1.23
	sid-snapshot-20130101:1.23
	sid-snapshot-20121201:1.23
	sid-snapshot-20121101:1.23
	sid-snapshot-20121001:1.23
	sid-snapshot-20120901:1.23
	sid-snapshot-20120801:1.23
	sid-snapshot-20120701:1.23
	sid-snapshot-20120601:1.23
	sid-snapshot-20120501:1.23
	sid-snapshot-20120401:1.23
	sid-snapshot-20120301:1.23
	sid-snapshot-20120201:1.23
	sid-snapshot-20120101:1.23
	sid-snapshot-20111201:1.23
	sid-snapshot-20111101:1.23
	sid-snapshot-20111001:1.23
	sid-snapshot-20110901:1.23
	sid-snapshot-20110801:1.23
	sid-snapshot-20110701:1.23
	sid-snapshot-20110601:1.23
	sid-snapshot-20110501:1.23
	sid-snapshot-20110401:1.23
	sid-snapshot-20110301:1.23
	sid-snapshot-20110201:1.23
	sid-snapshot-20110101:1.23
	sid-snapshot-20101201:1.23
	sid-snapshot-20101101:1.23
	sid-snapshot-20101001:1.23
	sid-snapshot-20100901:1.23
	sid-snapshot-20100801:1.23
	sid-snapshot-20100701:1.23
	sid-snapshot-20100601:1.23
	sid-snapshot-20100501:1.23
	sid-snapshot-20100401:1.23
	sid-snapshot-20100301:1.23
	sid-snapshot-20100201:1.23
	sid-snapshot-20100101:1.23
	sid-snapshot-20091201:1.23
	sid-snapshot-20091101:1.23
	sid-snapshot-20091001:1.23
	sid-snapshot-20090901:1.23
	sid-snapshot-20090801:1.23
	sid-snapshot-20090701:1.23
	sid-snapshot-20090601:1.23
	sid-snapshot-20090501:1.23
	sid-snapshot-20090401:1.23
	sid-snapshot-20090301:1.23
	sid-snapshot-20090201:1.23
	sid-snapshot-20090101:1.23
	sid-snapshot-20081201:1.23
	sid-snapshot-20081101:1.23
	sid-snapshot-20081001:1.23
	sid-snapshot-20080901:1.23
	sid-snapshot-20080801:1.23
	sid-snapshot-20080701:1.23
	sid-snapshot-20080601:1.22
	sid-snapshot-20080501:1.22
	sid-snapshot-20080403:1.22
	sid-snapshot-20080401:1.22
	sid-snapshot-20080301:1.22
	sid-snapshot-20080201:1.22
	sid-snapshot-20080101:1.22
	sid-snapshot-20071201:1.22
	sid-snapshot-20071101:1.22
	sid-snapshot-20071001:1.22;
locks; strict;
comment	@// @;


1.23
date	2008.06.17.18.11.51;	author brolley;	state Exp;
branches;
next	1.22;

1.22
date	2007.02.19.17.00.54;	author brolley;	state Exp;
branches;
next	1.21;

1.21
date	2007.02.05.20.28.42;	author brolley;	state Exp;
branches;
next	1.20;

1.20
date	2006.10.23.21.14.33;	author brolley;	state Exp;
branches;
next	1.19;

1.19
date	2006.10.18.18.46.17;	author brolley;	state Exp;
branches;
next	1.18;

1.18
date	2006.09.27.20.28.47;	author brolley;	state Exp;
branches;
next	1.17;

1.17
date	2006.09.19.18.40.56;	author brolley;	state Exp;
branches;
next	1.16;

1.16
date	2006.07.14.19.45.51;	author brolley;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.26.21.03.00;	author brolley;	state Exp;
branches;
next	1.14;

1.14
date	2006.06.20.18.40.20;	author brolley;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.14.20.41.28;	author brolley;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.11.20.27.02;	author brolley;	state Exp;
branches;
next	1.11;

1.11
date	2005.08.23.21.09.48;	author brolley;	state Exp;
branches;
next	1.10;

1.10
date	2005.08.19.19.48.45;	author brolley;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.10.15.51.08;	author brolley;	state Exp;
branches;
next	1.8;

1.8
date	2004.06.29.19.10.41;	author scox;	state Exp;
branches;
next	1.7;

1.7
date	2004.03.22.21.28.55;	author brolley;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.27.18.55.34;	author brolley;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.21.21.39.04;	author brolley;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.10.18.29.51;	author brolley;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.16.22.01.07;	author brolley;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.31.16.48.03;	author fche;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.09.04.22.50;	author bje;	state Exp;
branches;
next	;


desc
@@


1.23
log
@2008-06-17  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (usage): Document --reversible.
        (try_add_memory): Call sess->add_memory.
        (option_num): add opt_reversible.
        (long_options): Add "reversible".
        (main): Handle opt_reversible.
        * commonCfg.h (set_reversible): New method of SessionCfg.
        (add_memory): Likewise.
        (reversible_p): New member of SessionCfg.
        (memory): Likewise.
        * commonCfg.cxx (CpuCfg): Establish sim-sched relation.
        (SessionCfg): Initialize reversible_p.
        (SessionCfg::write_load): Set up all memory regions as reversible,
        if requested.
        (BoardCfg::write_config): Set up the cpu to be reversible, if
        requested.
@
text
@
#include "commonCfg.h"

// MemCfg
struct MemCfg_impl
{
  static map <string, MemCfg *> name_map;
};

map <string, MemCfg *> MemCfg_impl::name_map;

MemCfg *MemCfg::get_by_name (const string name)
{
  if (MemCfg_impl::name_map.find (name) ==
      MemCfg_impl::name_map.end())
    return NULL;
  return MemCfg_impl::name_map [name];
}

MemCfg::~MemCfg () {}
MemCfg::MemCfg (const string name) : 
  ComponentCfg (name),
  AtomicCfg (name, 
	     "libmemory.la", 
	     "mem_component_library",
	     "hw-memory-ram/rom-basic")
{
  MemCfg_impl::name_map [my_name] = this;
}

MemCfg::MemCfg (const string name, 
	sid::host_int_4 sz) : 
  ComponentCfg (name),
  AtomicCfg (name, 
	     "libmemory.la", 
	     "mem_component_library", 
	     "hw-memory-ram/rom-basic")
{
  set_size (sz);
  MemCfg_impl::name_map [my_name] = this;
}

MemCfg::MemCfg (const string name, 
	sid::host_int_4 read_lat,
	sid::host_int_4 write_lat) : 
  ComponentCfg (name),
  AtomicCfg (name, 
	     "libmemory.la", 
	     "mem_component_library",
	     "hw-memory-ram/rom-basic")
{
  set_read_latency (read_lat);
  set_write_latency (write_lat);
  MemCfg_impl::name_map [my_name] = this;
}

MemCfg::MemCfg (const string name, 
	sid::host_int_4 sz,
	sid::host_int_4 read_lat,
	sid::host_int_4 write_lat) : 
  ComponentCfg (name),
  AtomicCfg (name, 
	     "libmemory.la", 
	     "mem_component_library",
	     "hw-memory-ram/rom-basic")
{
  set_size (sz);
  set_read_latency (read_lat);
  set_write_latency (write_lat);
  MemCfg_impl::name_map [my_name] = this;
}


void MemCfg::set_read_latency (sid::host_int_4 lat)
{
  my_read_latency = lat;
  set (this, "read-latency", sidutil::make_attribute(lat));
}

void MemCfg::set_write_latency (sid::host_int_4 lat)
{
  my_write_latency = lat;
  set (this, "write-latency", sidutil::make_attribute(lat));
}

void MemCfg::set_size (sid::host_int_4 sz)
{
  my_size = sz;
  set (this, "size", "0x" + sidutil::make_numeric_attribute(sz, std::ios::hex));
}

sid::host_int_4 MemCfg::size()
{
  return my_size;
}

sid::host_int_4 MemCfg::read_latency()
{
  return my_read_latency;
}

sid::host_int_4 MemCfg::write_latency()
{
  return my_write_latency;
}



// CacheCfg
CacheCfg::~CacheCfg () {}
CacheCfg::CacheCfg (const string name, sid::host_int_4 size) : 
  ComponentCfg (name),
  AtomicCfg (name, 
	     "libcache.la", 
	     "cache_component_library",
	     "hw-cache-buffer-" + sidutil::make_attribute (size)),
  my_assoc (""),
  my_size (size),
  my_line_size (0),
  my_replace ("")
{}

// direct caches
CacheCfg::CacheCfg (const string name, 
		    const sid::host_int_4 size, 
		    const sid::host_int_4 linesize) : 
  ComponentCfg (name),
  AtomicCfg (name, 
	     "libcache.la", 
	     "cache_component_library",
	     "hw-cache-direct/" + 
	     sidutil::make_attribute(size) + "kb/" +
	     sidutil::make_attribute(linesize)),
  my_assoc ("direct"),
  my_size (size),
  my_line_size (linesize),
  my_replace ("")
{}

// complex associative caches
CacheCfg::CacheCfg (const string name, 
	  const string assoc, 
	  const sid::host_int_4 size, 
	  const sid::host_int_4 linesize, 
	  const string replace) : 
  ComponentCfg (name),
  AtomicCfg (name, 
	     "libcache.la", 
	     "cache_component_library",
	     "hw-cache-" + assoc + "/" + 
	     sidutil::make_attribute(size) + "kb/" +
	     sidutil::make_attribute(linesize) + "/" +
	     replace),
  my_assoc (assoc),
  my_size (size),
  my_line_size (linesize),
  my_replace (replace)
{}

void CacheCfg::compute_comptype ()
{
  if (my_assoc == "")
    {
      my_comptype = "hw-cache-buffer-" + sidutil::make_attribute (my_size);
    }
  else
    {
      string replace = my_replace;

      if (my_assoc != "direct" && replace == "")
	replace = "lru";

      if (replace == "")
	{
	  my_comptype = "hw-cache-" + my_assoc + "/"
	    + sidutil::make_attribute(my_size) + "kb/"
	    + sidutil::make_attribute(my_line_size);
	} 
      else 
	{
	  my_comptype = "hw-cache-" + my_assoc + "/"
	    + sidutil::make_attribute(my_size) + "kb/"
	    + sidutil::make_attribute(my_line_size) + "/"
	    + replace;
	}
    }
}

sid::host_int_4 CacheCfg::size ()
{
  return my_size;
}

sid::host_int_4 CacheCfg::line_size ()
{
  return my_line_size;
}

void CacheCfg::set_size (sid::host_int_4 sz)
{
  my_size = sz;
  compute_comptype ();
}

void CacheCfg::set_line_size (sid::host_int_4 sz)
{
  my_line_size = sz;
  compute_comptype ();
}

void CacheCfg::set_way (sid::host_int_4 w)
{
  switch (w)
    {
    case 1:
      my_assoc = "direct";
      break;
    case 2:
      my_assoc = "2way";
      break;
    case 4:
      my_assoc = "4way";
      break;
    default:
      assert (false);
    }
  compute_comptype ();
}

void CacheCfg::set_upstream (ComponentCfg *c, const string accessorname)
{
  assert (c);
  conn_bus (c, accessorname, this, "upstream");
}

void CacheCfg::set_downstream (ComponentCfg *c, const string busname)
{
  assert (c);
  conn_bus (this, "downstream", c, busname);
}

void CacheCfg::set_hit_latency (sid::host_int_4 i)
{
  set (this, "hit-latency", sidutil::make_attribute (i));
}

void CacheCfg::set_miss_latency (sid::host_int_4 i)
{
  set (this, "miss-latency", sidutil::make_attribute (i));
}

void CacheCfg::set_refill_latency (sid::host_int_4 i)
{
  set (this, "refill-latency", sidutil::make_attribute (i));
}

// BlockingCacheCfg
BlockingCacheCfg::~BlockingCacheCfg () {}
BlockingCacheCfg::BlockingCacheCfg (const string name) : 
  CacheCfg (name),
  ComponentCfg (name),
  AtomicCfg (name, 
	     "libcache.la", 
	     "cache_component_library",
	     "hw-blocking-cache-buffer-8")
{}

// direct caches
BlockingCacheCfg::BlockingCacheCfg (const string name, 
		    const sid::host_int_4 size, 
		    const sid::host_int_4 linesize) : 
  CacheCfg (name, size, linesize),
  ComponentCfg (name),
  AtomicCfg (name, 
	     "libcache.la", 
	     "cache_component_library",
	     "hw-blocking-cache-direct/" + 
	     sidutil::make_attribute(size) + "kb/" +
	     sidutil::make_attribute(linesize))
{}

// complex associative caches
BlockingCacheCfg::BlockingCacheCfg (const string name, 
	  const string assoc, 
	  const sid::host_int_4 size, 
	  const sid::host_int_4 linesize, 
	  const string replace) : 
  CacheCfg (name, assoc, size, linesize, replace),
  ComponentCfg (name),
  AtomicCfg (name, 
	     "libcache.la", 
	     "cache_component_library",
	     "hw-blocking-cache-" + assoc + "/" + 
	     sidutil::make_attribute(size) + "kb/" +
	     sidutil::make_attribute(linesize) + "/" +
	     replace)
{}

// CpuCfg


struct CpuCfg_impl
{
  static map <string, CpuCfg *> name_map;
};

map <string, CpuCfg *> CpuCfg_impl::name_map;

CpuCfg *CpuCfg::get_by_name (const string name)
{
  if (CpuCfg_impl::name_map.find (name) ==
      CpuCfg_impl::name_map.end())
    return NULL;
  return CpuCfg_impl::name_map [name];
}

void CpuCfg::get_all (vector <CpuCfg *> &targ)
{
  for (map <string, CpuCfg *>::const_iterator i = CpuCfg_impl::name_map.begin();
       i != CpuCfg_impl::name_map.end(); ++i)
    targ.push_back (i->second);
}


CpuCfg::~CpuCfg () {}
CpuCfg::CpuCfg (const string name, 
		const string variant, 
		SessionCfg *sess) : 
    ComponentCfg (name),
    AtomicCfg (name, 
	       "libcgencpu.la", 
	       "cgen_component_library",
	       "hw-cpu-" + variant),
    event_subscription (0)
{
  assert (sess);
  assert (sess->reset_net);
  assert (sess->yield_net);
  assert (sess->sim_sched);
  CpuCfg_impl::name_map [my_name] = this;
  sess->reset_net->add_output (0, this, "reset!");
  sess->yield_net->add_output (0, this, "yield");
  event_subscription = 
    sess->sim_sched->add_subscription 
    (this, "step!", "step-cycles", 
     "time-query", "time-high", "time-low");
  relate (this, "sim-sched", sess->sim_sched);
}


void CpuCfg::set_imem (ComponentCfg *m, string busname)
{
  conn_bus (this, "insn-memory", m, busname);
}

void CpuCfg::set_dmem (ComponentCfg *m, string busname)
{
  conn_bus (this, "data-memory", m, busname);
}

void CpuCfg::set_disasm_mem (ComponentCfg *m, string busname)
{
  conn_bus (this, "disassembler-memory", m, busname);
}

void CpuCfg::set_variant (const string var)
{
  my_comptype = string ("hw-cpu-" + var);
}

int CpuCfg::get_subscription_number ()
{
  return event_subscription;
}

void CpuCfg::add_prefix (const string prefix)
{
  CpuCfg_impl::name_map.erase (my_name);
  AtomicCfg::add_prefix (prefix);
  CpuCfg_impl::name_map [my_name] = this;
}


// SchedCfg
SchedCfg::~SchedCfg () {}
SchedCfg::SchedCfg (const string name, const string variant) :
  ComponentCfg (name),
  AtomicCfg (name, 
	     "libsched.la",
	     "sched_component_library",
	     "sid-sched-" + variant),     //variant is "host-accurate" or "sim"
  n(0)
{}


int SchedCfg::add_subscription (ComponentCfg *c, 
		      string event)
{
  string s = sidutil::make_attribute (n);
  conn_pin (this, s + "-event", c, event);
  return n++;
}

int SchedCfg::add_subscription (ComponentCfg *c, 
		      string event, 
		      string control)
{
  string s = sidutil::make_attribute (n);
  conn_pin (this, s + "-event", c, event);
  conn_pin (this, s + "-control", c, control, dst_to_src);
  return n++;
}

int SchedCfg::add_subscription (ComponentCfg *c, 
		      string event, 
		      string control,
		      string time_query,
		      string time_high,
		      string time_low)
{
  string s = sidutil::make_attribute (n);
  conn_pin (this, s + "-event", c, event);
  conn_pin (this, s + "-control", c, control, dst_to_src);
  conn_pin (this, "time-query", c, time_query, dst_to_src);
  conn_pin (this, "time-high", c, time_high);
  conn_pin (this, "time-low", c, time_low);
  return n++;
}

void SchedCfg::set_regular (int n, bool v)
{
  string s = sidutil::make_attribute (n);
  set (this, s + "-regular?", v ? "true" : "false");
}

void SchedCfg::set_time (int n, int tv)
{
  string s = sidutil::make_attribute (n);
  string ts = sidutil::make_attribute (tv);
  set (this, s + "-time", ts);
}

void SchedCfg::set_priority (int n, int pv)
{
  string s = sidutil::make_attribute (n);
  string ps = sidutil::make_attribute (pv);
  set (this, s + "-priority", ps);
}

void SchedCfg::write_config (Writer &w)
{
  Setting (this, "num-clients", sidutil::make_attribute (n)).write_to (w);
  AtomicCfg::write_config (w);
}

// MapperCfg
struct MapperCfg_impl
{
  static map <string, MapperCfg *> name_map;
};

map <string, MapperCfg *> MapperCfg_impl::name_map;

MapperCfg *MapperCfg::get_by_name (const string name)
{
  if (MapperCfg_impl::name_map.find (name) ==
      MapperCfg_impl::name_map.end())
    return NULL;
  return MapperCfg_impl::name_map [name];
}

MapperCfg::~MapperCfg () {}
MapperCfg::MapperCfg (const string name, bool transparent) :
  ComponentCfg (name),
  AtomicCfg (name, 
	     "libmapper.la", 
	     "mapper_component_library", 
	     string("hw-mapper-") + (transparent ? "transparent" : "basic"))
{
  MapperCfg_impl::name_map [my_name] = this;
}



void MapperCfg::set_transparent (bool t)
{
  if (t)
    my_comptype = "hw-mapper-transparent";
  else
    my_comptype = "hw-mapper-basic";
}

void MapperCfg::add_prefix (const string prefix)
{
  MapperCfg_impl::name_map.erase (my_name);
  AtomicCfg::add_prefix (prefix);
  MapperCfg_impl::name_map [my_name] = this;
}

void MapperCfg::map (const Mapping &m) 
{
  // FIXME: report an error here?
  if (! (m._slave.specified && m._bus.specified))
    return;
  
  string map_accessor = "[";
  if (m._wordsz.specified)
    map_accessor += "0x" + sidutil::make_numeric_attribute(m._wordsz.val, std::ios::hex) + "*";

  if (m._base.specified)
    map_accessor += "0x" + sidutil::make_numeric_attribute(m._base.val, std::ios::hex) + "=";

  // always include a low and a high. default to 0 if not specified.
  // FIXME: perhaps issuing a warning here would be better?
  map_accessor += "0x" + 
    sidutil::make_numeric_attribute(m._low.specified ? 
				    m._low.val : 0, std::ios::hex) 
    + "-0x"
    + sidutil::make_numeric_attribute(m._high.specified ? 
				      m._high.val : 0, std::ios::hex);

  // Both stride and width must be specified for either to make sense.
  if (m._stride.specified && m._width.specified)
    map_accessor += ",0x" 
      + sidutil::make_numeric_attribute(m._stride.val, std::ios::hex) 
      + ",0x"
      + sidutil::make_numeric_attribute(m._width.val, std::ios::hex);
  
  map_accessor += "]";

  if (m._banks.specified)
    map_accessor += m._banks.val;

  conn_bus (this, map_accessor, m._slave.val, m._bus.val);
}

// GlusSeqCfg 

GlueSeqCfg::GlueSeqCfg (const string name)
  : ComponentCfg (name),
    AtomicCfg (name,
	       "libglue.la", 
	       "glue_component_library", 
	       "hw-glue-sequence"),
    n(-1)
{}

void GlueSeqCfg::add_output (int seqnum, ComponentCfg *c, string pin_name)
{
  n = seqnum > n ? seqnum : n;
  string s = sidutil::make_attribute (seqnum);
  conn_pin (this, "output-" + s, c, pin_name);
}

void GlueSeqCfg::write_config (Writer &w)
{
  Setting (this, "num-outputs", sidutil::make_attribute (n+1)).write_to (w);
  AtomicCfg::write_config (w);
}


// SessionCfg
SessionCfg::~SessionCfg () {}
SessionCfg::SessionCfg (const string name)
  : ComponentCfg (name),
    AggregateCfg (name),
    host_sched (new SchedCfg ("host-sched", "host-accurate")),
    sim_sched (new SchedCfg ("sim-sched", "sim")),
    init_seq (new GlueSeqCfg ("init-seq")),
    reset_net (new GlueSeqCfg ("reset-net")),
    shutdown_seq (new GlueSeqCfg ("shutdown-seq")),
    yield_net (new GlueSeqCfg ("yield-net")),
    stdio_obj (NULL),
    // built-in (currently global)
    main_obj ( new AtomicCfg ("main", "", "", "") ),
    // optional bits
    audio (NULL),
    tksched (NULL),
    tksm (NULL),
    tcl_bridge (NULL),
    loader (NULL),
    verbose (false),
    reversible_p (false),
    use_stdio (true),
    need_gprof (false),
    need_core_probe (false),
    maybe_model_busses (false),
    board_count (0),
    gdb_count (0)
{
  add_child (host_sched);
  add_child (sim_sched);
  add_child (init_seq);
  add_child (reset_net);
  add_child (shutdown_seq);
  add_child (yield_net);
  add_child (main_obj);
  
  conn_pin (main_obj, "perform-activity", host_sched, "advance");
  conn_pin (main_obj, "perform-activity", sim_sched, "advance");
  conn_pin (main_obj, "starting", init_seq, "input");
  conn_pin (main_obj, "stopping", shutdown_seq, "input");
  yield_net->add_output (0, host_sched, "yield");
  init_seq->add_output (0, reset_net, "input");

  AtomicCfg *ulog = new AtomicCfg ("ulog-cout",
				   "libconsoles.la", 
				   "console_component_library", 
				   "sid-io-fileio");
  ulog_map["-"] = ulog;
  add_child (ulog);
}

void
SessionCfg::add_ulog_file (const string name)
{
  if (ulog_map.find (name) != ulog_map.end ())
    return; // already there

  // There is no existing logger for this file, so add a new one.
  AtomicCfg *ulog = new AtomicCfg ("ulog-" + name, 
				   "libconsoles.la", 
				   "console_component_library", 
				   "sid-io-fileio");
  set (ulog, "filename", name);
  ulog_map[name] = ulog;
  add_child (ulog);
}

void
SessionCfg::add_profile_config (const string &name, const string &options)
{
  set (main_obj, "dynamic-config!", name + "|" + options);
}

void SessionCfg::set_loader (LoaderCfg *l)
{
  if (loader)
    return;
  loader = l;
  add_child (l);
}

void SessionCfg::use_no_stdio ()
{
  use_stdio = false;
}

void SessionCfg::write_load (Writer &w)
{
  if (use_stdio)
    {
      stdio_obj = new AtomicCfg ("stdio", 
				 "libconsoles.la", 
				 "console_component_library", 
				 "sid-io-stdio");
      add_child (stdio_obj);
      int n = host_sched->add_subscription (stdio_obj, "poll");
      host_sched->set_regular (n, true);
      host_sched->set_time (n, 150);
      use_stdio = false;
    }

  // Setup all memory regions to be reversible, if specified.
  if (reversible_p)
    for (vector<MemCfg *>::iterator it = memory.begin ();
	 it != memory.end ();
	 ++it)
      {
	set (*it, "reversible?", "true");
	relate (*it, "sim-sched", sim_sched);
	conn_pin (sim_sched, "time-set", *it, "restore-to-time!");
      }

  AggregateCfg::write_load (w);
}

void SessionCfg::use_audio () 
{
  if (audio)
    return;
  audio = new AtomicCfg ("audio", "libaudio.la", 
			 "audio_component_library",
			 "sid-io-audio");
  add_child (audio);
  int n = host_sched->add_subscription (audio, "poll");
  host_sched->set_regular (n, true);
  host_sched->set_time (n, 100);
}

void SessionCfg::use_tksched ()
{
  if (tksched)
    return;
  use_tcl_bridge();
  tksched = new AtomicCfg ("tksched", "libtclapi.la", 
			   "tcl_bridge_library",
			   "sid-visual-sched");
  add_child (tksched);
  relate (tksched, "scheduler", sim_sched);
}

void SessionCfg::use_tksm ()
{
  if (tksm)
    return;
  use_tcl_bridge();
  tksm = new AtomicCfg ("tksm", "libtclapi.la", 
			"tcl_bridge_library",
			   "sid-control-tksm");
  add_child (tksm);
  assert (main_obj);
  assert (host_sched);
  relate (main_obj, "component-catalog-informees", tksm);
  int n = host_sched->add_subscription (tksm, "refresh");
  host_sched->set_regular (n, true);
  host_sched->set_time (n, 1000);
}

void SessionCfg::use_tcl_bridge ()
{
  if (tcl_bridge)
    return;
  tcl_bridge = new AtomicCfg ("tcl-event-consumer", "libtclapi.la", 
			      "tcl_bridge_library",
			      "bridge-tcl");
  add_child (tcl_bridge);
  assert (host_sched);
  assert (init_seq);
  host_sched->add_subscription (tcl_bridge, "!event", "!event-control");
  init_seq->add_output (7, tcl_bridge, "!event");
}

string
SessionCfg::wrap_config ()
{
  string spec;
  for (vector<AtomicCfg *>::const_iterator it = wrapped_components.begin ();
       it != wrapped_components.end ();
       ++it)
    spec += " --wrap=" + (*it)->get_name ();
  return spec;
}

// Process the argument to --profile-config which will
// be a subset of the allowable SID command line options
// which can be dynamically changed.
//
void
SessionCfg::profile_config_error (const string &spec)
{
  cerr << "error: invalid argument to --profile-config: " << spec << endl;
  exit (8);
}

string
SessionCfg::profile_opt_value (const string& opt, const vector<string>& opt_parts, unsigned max_parts)
{
  unsigned size = opt_parts.size ();
  if (size > max_parts)
    profile_config_error (opt); // doesn't return

  if (max_parts == 1)
    return "true";

  return opt_parts[1];
}

string
SessionCfg::profile_opt_int_value (const string& opt, const vector<string>& opt_parts)
{
  unsigned size = opt_parts.size ();
  if (size != 2)
    profile_config_error (opt); // doesn't return

  unsigned n;
  sid::component::status s = sidutil::parse_attribute (opt_parts[1], n);
  if (s != sid::component::ok)
    profile_config_error (opt); // doesn't return

  return opt_parts[1];
}

string
SessionCfg::profile_opt_gprof_value (const string& opt, const vector<string>& opt_parts)
{
  unsigned size = opt_parts.size ();
  if (size < 2 || size > 3)
    profile_config_error (opt); // doesn't return

  vector<string> sub_parts = sidutil::tokenize (opt_parts[1], ",");
  if (sub_parts.size () > 2)
    profile_config_error (opt); // doesn't return

  string value = sub_parts[0];
  if (sub_parts.size () == 2)
    {
      if (sub_parts[1] != "cycles")
	profile_config_error (opt); // doesn't return

      if (size == 3)
	{
	  unsigned n;
	  sid::component::status s = sidutil::parse_attribute (opt_parts[2], n);
	  if (s != sid::component::ok)
	    profile_config_error (opt); // doesn't return
	  value += "," + opt_parts[2];
	}
      else
	value += ",1";
    }

  need_gprof = true;
  return value;
}

bool
SessionCfg::match_profile_opt (const string &opt, const string& want, unsigned min_size)
{
  unsigned opt_size = opt.size ();
  unsigned want_size = want.size ();
  if (opt_size < min_size || opt_size > want_size)
    return false;
  return opt == want.substr (0, opt_size);
}

void 
SessionCfg::profile_config (const string &spec)
{
  // Extract the name of the config profile
  vector<string> parts = sidutil::tokenize (spec, ":");
  if (parts.size () != 2)
    profile_config_error (spec);
  string name = parts[0];

  // Initialize the candidate options to their default values.
  string trace_extract = "false";
  string trace_semantics = "false";
  string trace_disassemble = "false";
  string trace_core = "false";
  string trace_counter = "false";
  string ulog_level = "0";
  string ulog_mode = "less";
  string wrap = "";
  string verbose = "false";
  string final_insn_count = "false";
  string gprof = "";
  string insn_count = "10000";
  // mep-specific options
  string model_busses = "false";

  // Now examine the spec and reset those which are specified.
  vector<string>opts = sidutil::tokenize (parts[1], " ");
  int size = opts.size ();
  for (int i = 0; i < size; ++i)
    {
      const string opt = opts[i];
      vector<string> opt_parts = sidutil::tokenize (opt, "=");
      const string opt_name = opt_parts[0];

      if (match_profile_opt (opt_name, "--trace-extract", 9))
	trace_extract = profile_opt_value (opt, opt_parts, 1);
      else if (match_profile_opt (opt_name, "--trace-semantics", 9))
	trace_semantics = profile_opt_value (opt, opt_parts, 1);
      else if (match_profile_opt (opt_name, "--trace-disassemble", 9))
	trace_disassemble = profile_opt_value (opt, opt_parts, 1);
      else if (match_profile_opt (opt_name, "--trace-core", 11))
	{
	  trace_core = profile_opt_value (opt, opt_parts, 1);
	  need_core_probe = true;
	}
      else if (match_profile_opt (opt_name, "--trace-counter", 11))
	trace_counter = profile_opt_value (opt, opt_parts, 1);
      else if (match_profile_opt (opt_name, "--ulog-level=", 8))
	ulog_level = profile_opt_int_value (opt, opt_parts);
      else if (match_profile_opt (opt_name, "--ulog-mode=", 8))
	ulog_mode = profile_opt_value (opt, opt_parts, 2);
      else if (match_profile_opt (opt_name, "--verbose", 3))
	verbose = profile_opt_value (opt, opt_parts, 1);
      else if (match_profile_opt (opt_name, "--wrap=", 3))
	{
	  string comp_name = profile_opt_value (opt, opt_parts, 2);
	  use_tcl_bridge ();
	  AtomicCfg *comp = AtomicCfg::possible_wrap_name (comp_name);
	  if (! wrap.empty ()) wrap += ",";
	  if (comp)
	    wrap += comp->get_name ();
	  else
	    wrap += comp_name;
	}
      else if (match_profile_opt (opt_name, "--final-insn-count", 3))
	final_insn_count = profile_opt_value (opt, opt_parts, 1);
      else if (match_profile_opt (opt_name, "--gprof=", 3))
	gprof = profile_opt_gprof_value (opt, opt_parts);
      else if (match_profile_opt (opt_name, "--insn-count=", 3))
	insn_count = profile_opt_int_value (opt, opt_parts);
      // mep-specific options
      else if (match_profile_opt (opt_name, "--model-busses", 3))
	model_busses = profile_opt_value (opt, opt_parts, 1);
    }

  if (model_busses != "false")
    maybe_model_busses = true;

  // Now contruct a string representing the complete configuration
  add_profile_config (name,
		      "trace-extract="     + trace_extract     + ":" +
		      "trace-semantics="   + trace_semantics   + ":" +
		      "trace-disassemble=" + trace_disassemble + ":" +
		      "trace-core="        + trace_core        + ":" +
		      "trace-counter="     + trace_counter     + ":" +
		      "ulog-level="        + ulog_level        + ":" +
		      "ulog-mode="         + ulog_mode         + ":" +
		      "wrap="              + wrap              + ":" +
		      "verbose="           + verbose           + ":" +
		      "final-insn-count="  + final_insn_count  + ":" +
		      "gprof="             + gprof             + ":" +
		      "insn-count="        + insn_count        + ":" +
		      // mep-specific options
		      "model-busses="      + model_busses);
}

void SessionCfg::write_config (Writer &w)
{
  AggregateCfg::write_config (w);

  // Stop the host scheduler if all of the GDB stubs are stopped
  if (gdb_count)
    {
      assert (host_sched);
      Setting (host_sched, "yield-host-time-threshold",
	       sidutil::make_attribute (gdb_count)).write_to (w);
      Setting (host_sched, "yield-host-time?", "0").write_to (w);
    }

  // Stop the sim scheduler if any of the GDB stubs are stopped
  assert (sim_sched);
  Setting (sim_sched, "enable-threshold",
	   sidutil::make_attribute (board_count)).write_to (w);
  Setting (sim_sched, "enabled?",
	   sidutil::make_attribute (board_count)).write_to (w);
}

// LoaderCfg 
LoaderCfg::~LoaderCfg () {}
LoaderCfg::LoaderCfg (const string name, 
		      SessionCfg *sess) :
  ComponentCfg (name),
  AtomicCfg ( name, "libloader.la", 
	      "loader_component_library",
	      "sw-load-elf")
{
  assert (sess);
  set (this, "file", "a.out");
  conn_pin (this, "error", sess->main_obj, "stop!");
  sess->init_seq->add_output (1, this, "load!");
}

void LoaderCfg::set_target (ComponentCfg *mem, const string mem_bus_name)
{
  assert (mem);
  conn_bus (this, "load-accessor-data", mem, mem_bus_name);
  conn_bus (this, "load-accessor-insn", mem, mem_bus_name);
}

void LoaderCfg::add_cpu (CpuCfg *cpu) 
{
  assert (cpu);
  conn_pin (this, "start-pc-set", cpu, "start-pc-set!");
  conn_pin (this, "endian-set", cpu, "endian-set!");
  conn_pin (this, "eflags-set", cpu, "eflags-set!");
}

void LoaderCfg::set_file (const string filename)
{
  set (this, "file", filename);
}


// GlossCfg
GlossCfg::~GlossCfg () {}
GlossCfg::GlossCfg (const string name, 
		    CpuCfg *cpu, 
		    ComponentCfg *mem,
		    const string mem_bus_name,
		    SessionCfg *sess) :
  ComponentCfg (name),
  AtomicCfg ( name, "libgloss.la", 
	      "gloss_component_library",
	      "sw-gloss-generic/libgloss")    
{
  assert (cpu);
  assert (mem);
  assert (sess);
  relate (this, "cpu", cpu);
  conn_pin (this, "trap", cpu, "trap", both);
  conn_pin (this, "trap-code", cpu, "trap-code", dst_to_src);
  conn_bus (this, "target-memory", mem, mem_bus_name);
  assert (sess->init_seq);
  sess->init_seq->add_output (2, this, "reset");
}

GlossCfg::GlossCfg (const string name, 
		    CpuCfg *cpu, 
		    SessionCfg *sess) :
  ComponentCfg (name),
  AtomicCfg ( name, "libgloss.la", 
	      "gloss_component_library",
	      "sw-gloss-generic/libgloss")    
{
  assert (cpu);
  assert (sess);
  relate (this, "cpu", cpu);
  conn_pin (this, "trap", cpu, "trap", both);
  conn_pin (this, "trap-code", cpu, "trap-code", dst_to_src);
  assert (sess->init_seq);
  sess->init_seq->add_output (2, this, "reset");
}

// GprofCfg
GprofCfg::~GprofCfg() {}
GprofCfg::GprofCfg (const string name, 
		    const string filename,
		    CpuCfg *cpu, 
		    SessionCfg *sess,
		    gprof_type type,
                    int interval) :
  ComponentCfg (name),
  AtomicCfg ( name, "libprof.la", 
	      "prof_component_library",
	      "sw-profile-gprof")
{
  assert (cpu);
  assert (sess);

  conn_pin (cpu, "sample-gprof", this, "sample");

  sess->shutdown_seq->add_output (7, this, "store");
  relate (this, "target-component", cpu);
  conn_pin (cpu, "cg-caller", this, "cg-caller");
  conn_pin (cpu, "cg-callee", this, "cg-callee");
  conn_pin (cpu, "gprof-pc-hi", this, "pc-hi");
  conn_pin (cpu, "gprof-pc", this, "pc");
  if (cpu->comp_type().substr(0, 10) == "hw-cpu-mep")
    set (this, "bucket-size", "2"); // bytes-per-bucket
  else if (cpu->comp_type().substr(0, 9) == "hw-cpu-sh")
    set (this, "bucket-size", "2"); // bytes-per-bucket
  else
    set (this, "bucket-size", "4"); // bytes-per-bucket
  set (this, "output-file", filename);
}

// Create a gprof component but don't activate it
GprofCfg::GprofCfg (const string name,
		    CpuCfg *cpu, 
		    SessionCfg *sess) :
  ComponentCfg (name),
  AtomicCfg ( name, "libprof.la", 
	      "prof_component_library",
	      "sw-profile-gprof")
{
  assert (cpu);
  assert (sess);

  sess->shutdown_seq->add_output (7, this, "store");
  relate (this, "target-component", cpu);
  if (cpu->comp_type().substr(0, 10) == "hw-cpu-mep")
    set (this, "bucket-size", "2"); // bytes-per-bucket
  else if (cpu->comp_type().substr(0, 9) == "hw-cpu-sh")
    set (this, "bucket-size", "2"); // bytes-per-bucket
  else
    set (this, "bucket-size", "4"); // bytes-per-bucket
}



// GdbCfg
GdbCfg::~GdbCfg () {}
GdbCfg::GdbCfg (const string name, 
		const string port,
		CpuCfg *c, 
		BoardCfg *b,
		SessionCfg *s) :
  ComponentCfg (name),
  AggregateCfg (name),
  cpu (c),
  board (b),
  sess (s),
  sock (NULL),
  stub (NULL)  
{
  assert (cpu);
  assert (board);
  assert (sess);

  sock = new AtomicCfg ("socket", 
			"libconsoles.la", 
			"console_component_library", 
			"sid-io-socket-server");
  stub  = new AtomicCfg ( "stub", "libgdb.la", 
			  "gdb_component_library",
			  "sw-debug-gdb");
  add_child (sock);
  add_child (stub);

  // hook up our stub to the session and board
  relate (stub, "cpu", cpu);
  relate (stub, "cfgroot", sess->main_obj);
  relate (stub, "target-schedulers", sess->sim_sched);
  relate (stub, "host-schedulers", sess->host_sched);
  sess->init_seq->add_output (3, stub, "init");
  sess->shutdown_seq->add_output (5, stub, "deinit");
  conn_pin (stub, "flush-icache", board->cache_flush_net, "input");
  conn_pin (stub, "restart", sess->reset_net, "input");
  set (stub, "exit-on-detach?", "true");
  
  // hook up our socket to the outside world
  sess->init_seq->add_output (2, sock, "init");
  sess->shutdown_seq->add_output (6, sock, "fini");
  conn_pin (sock, "rx", stub, "remote-rx");
  conn_pin (sock, "tx", stub, "remote-tx", dst_to_src);
  sess->host_sched->add_subscription (sock, "poll-event", "poll-control");
  set (sock, "sockaddr-local", "0.0.0.0:" + port);

  // expose stub's names to the outside as our names
  map_name (stub, out_pin, "yield",                "yield");
  map_name (stub, in_pin,  "trap",                 "trap");
  map_name (stub, out_pin, "trap",                 "trap");
  map_name (stub, in_pin,  "trap-code",            "trap-code");
  map_name (stub, in_pin,  "gloss-process-signal", "gloss-process-signal");
  map_name (stub, out_pin, "process-signal",       "process-signal");
  map_name (stub, in_pin,  "target-tx",            "target-tx");
  map_name (stub, relater, "gloss",                "gloss");
  map_name (stub, attr,    "enable-Z-packet?",     "enable-Z-packet?");
  map_name (stub, attr,    "operating-mode?",      "operating-mode?");
}


void GdbCfg::write_config (Writer &w)
{
  AggregateCfg::write_config (w);
  assert (sock);
  assert (stub);
  if (sess->verbose)
    {      
      Setting (stub, "trace-gdbsid?", "true").write_to (w); 
      Setting (stub, "trace-gdbserv?", "true").write_to (w); 
      Setting (sock, "verbose?", "true").write_to (w); 
    }

  // the stub and socket need to be connected to the dynamic_configurator.
  if (board->dynamic_configurator)
    {
      if (! stub->possibly_wrapped ())
	{
	  Relation (board->dynamic_configurator, "client", stub).write_to (w);
	}
      if (! sock->possibly_wrapped ())
	{
	  Relation (board->dynamic_configurator, "client", sock).write_to (w);
	}
    }
}


// BoardCfg
BoardCfg::~BoardCfg () {}
BoardCfg::BoardCfg (const string name, 
		    const string default_cpu_variant,		    
		    SessionCfg *s,
		    bool with_default_gloss,
		    bool with_z_packet,
		    bool with_cpu_main_mem_connect) :
  ComponentCfg (name),
  AggregateCfg (name),
  UlogCfg (),
  cache_flush_net (NULL),
  z_packet (with_z_packet),
  sess (s),
  cpu (NULL),
  gdb (NULL),
  gloss (NULL),
  gprof (NULL),
  main_mapper (NULL),
  icache (NULL),
  dcache (NULL),
  loader (NULL),
  core_probe (0),
  dynamic_configurator (NULL),
  start_config (""),
  warmup_funcs ("_Sid_config"),
  step_insn_count ("10000"),
  step_insn_count_1_required_p (false)
{
  assert (sess);
  cpu = new CpuCfg ("cpu", default_cpu_variant, sess);
  set_engine ("pbb");
  main_mapper = new MapperCfg ("main-map");
  assert (main_mapper);

  cache_flush_net = new GlueSeqCfg ("cache-flush-net");
  cache_flush_net->add_output (1, cpu, "flush-icache");

  if (with_default_gloss)
    use_gloss ();

  if (with_cpu_main_mem_connect)
    {
      cpu->set_imem (main_mapper, "access-port");
      cpu->set_dmem (main_mapper, "access-port");
    }
 
  sess->shutdown_seq->add_output (0, cpu, "print-insn-summary!");

  add_child (cpu);
  add_child (main_mapper);
  add_child (cache_flush_net);
}


void BoardCfg::use_gloss () 
{
  if (gloss)
    return;
  gloss = new GlossCfg ("gloss", cpu, main_mapper, "access-port", sess);
  add_child (gloss);
}

void BoardCfg::set_cpu (const string variant)
{
  assert (cpu);
  cpu->set_variant(variant);
}

void BoardCfg::set_gdb (const string port)
{
  if (gdb)
    return;
  gdb = new GdbCfg ("gdb", port, cpu, this, sess);
  add_child (gdb);
  sess->use_no_stdio ();
  sess->add_gdb ();
}


void BoardCfg::set_loader (LoaderCfg *l)
{
  if (loader)
    return;
  loader = l;
  add_child (l);
}

void BoardCfg::write_load (Writer &w)
{
  if (gloss)
    {
      // Create a dynamic reconfigurator to be used by this gloss
      dynamic_configurator = new AtomicCfg ("dynamic-config", "libconfig.la", 
					    "config_component_library",
					    "sid-control-dynamic-configurator");
      sess->reset_net->add_output (2, dynamic_configurator, "reset");
      int slot = sess->sim_sched->add_subscription (dynamic_configurator, "step!", "step-control");
      sess->sim_sched->set_priority (slot, SchedCfg::config_priority);
      add_child (dynamic_configurator);

      // If we may need a gprof for dynamic configuration but don't have
      // one yet, then create a disabled one.
      if (! gprof && sess->need_gprof)
	{
	  gprof = new GprofCfg ("gprof", cpu, sess);
	  add_child (gprof);
	}

      // If we may need a core_probe for dynamic configuration but don't have
      // one yet, then create a disabled one.
      if (! core_probe && sess->need_core_probe)
	{
	  trace_core ();
	  core_probe->set (core_probe, "trace?", "false");
	}

      if (sess->verbose)
	set (gloss, "verbose?", "true");
    }
  if (loader)
    if (sess->verbose)
      set (loader, "verbose?", "true");

  set (cpu, "step-insn-count", step_insn_count_1_required_p ? "1" : step_insn_count);

  AggregateCfg::write_load (w);
}

void BoardCfg::write_config (Writer &w)
{
  AggregateCfg::write_config (w);

  // Make the connection which allows the cpu to query the loader regarding
  // addresses.
  if (loader)
    {
      Relation (cpu, "loader", loader).write_to (w);
      PinConnection (cpu, "disassembly-symbol-address", loader, "function?").write_to (w);
    }

  if (gloss)
    {      
      if (gdb)
	{ 
	  // gdb chained off gloss	  
	  PinConnection  (gloss, "trap-chain", gdb, "trap", both).write_to (w); 
	  PinConnection (gloss, "trap-code-chain", gdb, "trap-code").write_to (w);
	  PinConnection (gloss, "process-signal", gdb, "gloss-process-signal").write_to (w);
	  PinConnection (gdb, "process-signal", sess->main_obj, "stop!").write_to (w);
	  PinConnection (gdb, "yield", sess->yield_net, "input").write_to (w);
	  PinConnection (gloss, "debug-tx", gdb, "target-tx").write_to (w);
	  Relation (gdb, "gloss", gloss).write_to (w);
	  Setting (gdb, "enable-Z-packet?", z_packet ? "true" : "false").write_to (w);
	  Setting (gdb, "operating-mode?", "false").write_to (w);
	} 
      else 
	{
	  // gloss alone	  
	  assert (sess->stdio_obj);
	  PinConnection (gloss, "debug-tx", sess->stdio_obj, "stdout").write_to(w);
	  PinConnection (gloss, "debug-rx", sess->stdio_obj, "stdin", dst_to_src).write_to(w);
	  PinConnection (gloss, "debug-rx-eof", sess->stdio_obj, "eof", dst_to_src).write_to(w);
	  PinConnection (gloss, "process-signal", sess->main_obj, "stop!").write_to(w);
	  PinConnection (gloss, "process-signal", sess->yield_net, "input").write_to(w);
	}

      // Set up for dynamic configuration
      assert (dynamic_configurator);
      Relation (dynamic_configurator, "main", sess->main_obj).write_to (w);
      PinConnection (dynamic_configurator, "step-control", cpu, "yield").write_to (w);
      Relation (gloss, "main", sess->main_obj).write_to (w);
      Relation (gloss, "dynamic-configurator", dynamic_configurator).write_to (w);
      PinConnection (gloss, "configure", dynamic_configurator, "configure!").write_to (w);
      PinConnection (dynamic_configurator, "config-result", gloss, "config-result").write_to (w);
      PinConnection (dynamic_configurator, "config-error", gloss, "config-error").write_to (w);

      // Set the starting configuration
      if (start_config.empty ())
	start_config = "sid-internal-warmup";
      Setting (dynamic_configurator, "start-config", start_config).write_to (w);

      // Connect the new-config pin of the dynamic configurator to
      // the components of this board which need to know when the
      // configuration changes.
      assert (cpu);
      Relation (cpu, "main", sess->main_obj).write_to (w);
      if (! cpu->possibly_wrapped ())
	{
	  Relation (dynamic_configurator, "client", cpu).write_to (w);
	}
      if (gprof)
      	{
	  // gprof's configure! attribute will be set by the cpu.
	  Relation (cpu, "gprof", gprof).write_to (w);
      	}
      if (! gloss->possibly_wrapped ())
	{
	  Relation (dynamic_configurator, "client", gloss).write_to (w);
	}
      if (core_probe)
	Relation (cpu, "core-probe", core_probe).write_to (w);

      // Connect the new-config pin of the dynamic configurator to any wrapped child components
      dynamic_config_for_wrapped_children (dynamic_configurator, w);

      // Make the connections which enable the dynamic configurator to change configs on function
      // call and return.
      if (loader)
	{
	  if (! loader->possibly_wrapped ())
	    {
	      Relation (dynamic_configurator, "client", loader).write_to (w);
	    }
	  PinConnection (cpu, "cg-caller", dynamic_configurator, "function-caller!").write_to (w);
	  PinConnection (cpu, "cg-callee", dynamic_configurator, "function-callee!").write_to (w);
	  PinConnection (cpu, "cg-jump", dynamic_configurator, "function-jump!").write_to (w);
	  PinConnection (cpu, "cg-return", dynamic_configurator, "function-return!").write_to (w);
	  Relation (dynamic_configurator, "loader", loader).write_to (w);
	  PinConnection (dynamic_configurator, "function-address", loader, "function?").write_to (w);
	}

      // Initialize the warmup functions and profile functions.
      assert (! warmup_funcs.empty ());
      Setting (dynamic_configurator, "warmup-functions!", warmup_funcs).write_to (w);
      if (! profile_funcs.empty ())
	Setting (dynamic_configurator, "profile-functions!", profile_funcs.substr (1)).write_to (w); // Skip the initial delimeter.
    }
  else
    {
      if (gdb)
	{
	  // gdb alone
	  PinConnection (cpu, "trap", gdb, "trap", both).write_to(w);
	  PinConnection (cpu, "trap-code", gdb, "trap-code").write_to(w);
	}
    }  

  // Set up the cpu to be reversible, if requested.
  if (sess->reversible_p)
    {
      Setting (cpu, "reversible?", "true").write_to (w);
      PinConnection (sess->sim_sched, "time-set", cpu, "restore-to-time!").write_to(w);
    }
}

void BoardCfg::set_gprof (const string filename, gprof_type type, int interval)
{
  if (gprof)
    return;
  gprof = new GprofCfg ("gprof", filename, cpu, sess, type, interval);
  add_child (gprof);
}

void BoardCfg::set_engine (const string engine)
{
  assert (cpu);
  cpu->set (cpu, "engine-type", engine);
}

void BoardCfg::set_step_insn_count (const string count)
{
  assert (cpu);
  step_insn_count = count;
}

void BoardCfg::set_endian (const string endian)
{
  assert (cpu);
  cpu->set (cpu, "endian", endian);
}

void BoardCfg::add_sidrtc (sid::host_int_4 addr)
{
  AtomicCfg *rtc = new AtomicCfg ("rtc", "librtc.la", 
				  "rtc_component_library",
				  "hw-rtc-sid");
  add_child (rtc);
  assert (main_mapper);
  main_mapper->map (Mapping()
		    .slave(rtc).bus("registers")
		    .low(addr).high(addr+7));
}

void BoardCfg::add_sidcodec (sid::host_int_4 addr)
{
  AtomicCfg *codec = new AtomicCfg ("codec", "libaudio.la", 
				    "audio_component_library",
				    "hw-audio-sid");
  assert (sess);
  sess->use_audio ();
  assert (sess->audio);

  add_child (codec);
  main_mapper->map (Mapping()
		    .slave(codec).bus("registers")
		    .low(addr).high(addr+19));
  codec->conn_pin (codec, "tx-sample", sess->audio, "tx-sample");
  codec->conn_pin (codec, "rx-sample", sess->audio, "rx-sample", dst_to_src);
  codec->conn_pin (codec, "tx-mode", sess->audio, "tx-mode");
  codec->conn_pin (codec, "tx-pending", sess->audio, "tx-pending", dst_to_src);
  codec->conn_pin (codec, "rx-mode", sess->audio, "rx-mode");
  codec->conn_pin (codec, "rx-pending", sess->audio, "rx-pending", dst_to_src);
  codec->conn_pin (codec, "config-set", sess->audio, "config-set");
}


void BoardCfg::trace_extract ()
{
  assert (cpu);
  cpu->set (cpu, "trace-extract?", "true");
}

void BoardCfg::trace_semantics ()
{
  assert (cpu);
  cpu->set (cpu, "trace-semantics?", "true");
}

void BoardCfg::final_insn_count ()
{
  assert (cpu);
  assert (sess->shutdown_seq);
  cpu->set (cpu, "final-insn-count?", "true");
}

void BoardCfg::trace_counter ()
{
  assert (cpu);
  cpu->set (cpu, "trace-counter?", "true");
  step_insn_count_1_required_p = true;
}

void BoardCfg::trace_disassemble ()
{
  assert (cpu);
  cpu->set (cpu, "trace-disassemble?", "true");
}

void BoardCfg::enable_warnings ()
{
  assert (cpu);
  cpu->set (cpu, "enable-warnings?", "true");
}

void BoardCfg::add_dcache (const string type)
{
  static int num = 0;
  AtomicCfg *new_dcache = new AtomicCfg ("dcache-" + sidutil::make_attribute (num++), 
					 "libcache.la", 
					 "cache_component_library",
					 "hw-cache-" + type);
  add_child (new_dcache);
  if (dcache)
    {
      // we are extending the existing dcache chain
      dcache->map_name (new_dcache, accessor, "downstream", "downstream");
      dcache->conn_bus (dcache, "downstream", new_dcache, "upstream", false);
    }
  else
    {
      // we are chaining off the CPU
      assert (cpu);
      cpu->map_name (new_dcache, accessor, "data-memory", "downstream");
      cpu->conn_bus (cpu, "data-memory", new_dcache, "upstream", false);
    }
  dcache = new_dcache;
}

void BoardCfg::add_icache (const string type)
{
  static int num = 0;
  AtomicCfg *new_icache = new AtomicCfg ("icache-" + sidutil::make_attribute (num++), 
					 "libcache.la", 
					 "cache_component_library",
					 "hw-cache-" + type);
  add_child (new_icache);
  assert (cache_flush_net);
  cache_flush_net->add_output (1, new_icache, "flush-all");
  if (icache)
    {
      // we are extending the existing icache chain
      icache->map_name (new_icache, accessor, "downstream", "downstream");
      icache->conn_bus (icache, "downstream", new_icache, "upstream", false);
    }
  else
    {
      // we are chaining off the CPU
      assert (cpu);
      cpu->map_name (new_icache, accessor, "insn-memory", "downstream");
      cpu->conn_bus (cpu, "insn-memory", new_icache, "upstream", false);
    }
  icache = new_icache;
}

void BoardCfg::add_memory (const Mapping &m)
{
  if (main_mapper)
    {
      Mapping map(m);
      main_mapper->map (map.base(0));
    }
}


void BoardCfg::trace_core ()
{
  if (core_probe)
    return;
  core_probe = new AtomicCfg ("probe", "libglue.la", 
			      "glue_component_library", "hw-glue-probe-bus");
  add_child (core_probe);
  assert (main_mapper);
  main_mapper->map_name (core_probe, bus, "access-port", "upstream");
  // this connection needs to be non-virtual, to avoid a feedback loop
  core_probe->conn_bus (core_probe, "downstream", main_mapper, "access-port", false);
  core_probe->set (core_probe, "trace?", "true");
}

void BoardCfg::add_profile_func (const string &spec)
{
  if (! spec.empty ())
    profile_funcs += "|" + spec;
}

void BoardCfg::add_warmup_func (const string &funcs)
{
  if (! funcs.empty ())
    warmup_funcs += "," + funcs;
}

void BoardCfg::set_warmup (bool w)
{
  if (w)
    start_config = "sid-internal-warmup";
}

void BoardCfg::set_start_config (const string &config)
{
  if (! start_config.empty ())
    return;

  if (! config.empty ())
    {
      start_config = "sid-internal-start-" + get_name ();
      sess->profile_config (start_config + ":" + config.substr (1));  // get past leading comma
    }
}
@


1.22
log
@2007-02-19  Dave Brolley  <brolley@@redhat.com>

        * mepCfg.cxx (MepMemCfg::set_dynamic_config): Relate the gbmif as a
        client of the dynamic_configurator if it exists.
        (MepBoardCfg::map_mm_int): Removed.
        (MepBoardCfg::write_load): Call set_model_busses, if necessary.
        (MepBoardCfg::write_config): Call shared_main_mem->mep_mm_int, if
        necessary. Relate the gbif and lbif clients of the dynamic_configurator
        if they exist and may be wrapped.
        * commonCfg.cxx (SessionCfg): Initialize maybe_model_busses.
        (profile_config): Set maybe_model_busses, if necessary.
        * commonCfg.h (maybe_model_busses): New member of SessionCfg.
@
text
@d347 1
d583 1
d663 12
d1403 7
@


1.21
log
@Support for Toshiba MeP.
@
text
@d585 1
d888 3
@


1.20
log
@2006-10-23  Dave Brolley  <brolley@@redhat.com>

        * commonCfg.cxx (CacheCfg (const string, sid::host_int_4)):
        Initialize type as "hw-cache-buffer-" + size. Don't call
        compute_comptype.
@
text
@d834 2
d882 3
d900 3
a902 1
		      "insn-count="        + insn_count);
d1026 3
a1028 1
  if (cpu->comp_type().substr(0, 9) == "hw-cpu-sh")
d1049 3
a1051 1
  if (cpu->comp_type().substr(0, 9) == "hw-cpu-sh")
@


1.19
log
@2006-10-18  Dave Brolley  <brolley@@redhat.com>

        * Contribue the following changes:

        2006-07-19  Dave Brolley  <brolley@@redhat.com>

        * shCfg.h (insn_buffer): All references removed.
        (main_memory): New member of ShBoardCfg.
        * shCfg.cxx (insn_buffer): All references removed.
        (ShBoardCfg): Don't initialize icache or ocache. Assume icache and
        ocache are always created. Don't connect memory heirarchy here.
        (write_config): Do it here instead.

        2006-05-11  Dave Brolley  <brolley@@redhat.com>

        * Makefile.am: Add sh support.
        * mainDynamic.cxx: Likewise.
        * shCfg.cxx: New source file.
        * shCfg.h: New source file.
        * commonCfg.cxx (GprofCfg): Set bucket-size for hw-cpu-sh*.
@
text
@d116 1
a116 1
	     ""),
d121 1
a121 3
{
  compute_comptype ();
}
@


1.18
log
@2006-09-27  Dave Brolley  <brolley@@redhat.com>

        * commonCfg.cxx (profile_opt_gprof_value): Handle "gprof=<file>,cycles".
@
text
@d1021 4
a1024 1
  set (this, "bucket-size", "4"); // bytes-per-bucket
d1042 4
a1045 1
  set (this, "bucket-size", "4"); // bytes-per-bucket
@


1.17
log
@2006-09-19  Dave Brolley  <brolley@@redhat.com>

        * commonCfg.cxx (MemCfg::set_size): Use make_numeric_attribute and pass
        std::ios::hex.
        (MapperCfg::map): Likewise.
@
text
@d779 3
d783 1
a783 1
  if (size == 3)
d785 1
a785 1
      if (sub_parts.size () != 2 || sub_parts[1] != "cycles")
d788 10
a797 6
      unsigned n;
      sid::component::status s = sidutil::parse_attribute (opt_parts[2], n);
      if (s != sid::component::ok)
	profile_config_error (opt); // doesn't return

      value += "," + opt_parts[2];
@


1.16
log
@2006-07-14  Dave Brolley  <brolley@@redhat.com>

        * commonCfg.cxx (BoardCfg::write_config): Connect stdio_obj's eof pin to
        gloss' debug-rx-eof pin.
@
text
@d89 1
a89 1
  set (this, "size", sidutil::make_attribute(sz));
d509 1
a509 1
    map_accessor += sidutil::make_attribute(m._wordsz.val) + "*";
d512 1
a512 1
    map_accessor += sidutil::make_attribute(m._base.val) + "=";
d516 6
a521 6
  map_accessor += 
    sidutil::make_attribute(m._low.specified ? 
			    m._low.val : 0) 
    + "-"
    + sidutil::make_attribute(m._high.specified ? 
			      m._high.val : 0);
d525 4
a528 4
    map_accessor += "," 
      + sidutil::make_attribute(m._stride.val) 
      + ","
      + sidutil::make_attribute(m._width.val);
@


1.15
log
@2006-06-26  Dave Brolley  <brolley@@redhat.com>

        * commonCfg.cxx (GprofCfg): Connect the cpu's gprof-pc and gprof-pc-hi
        pins to our pc and p-hi pins respectively.
@
text
@d1288 1
@


1.14
log
@2006-06-20  Dave Brolley  <brolley@@redhat.com>

        * commonCfg.cxx (BoardCfg::write_config): If there is a loader, then
        relate it to the cpu and connect the cpu's disassembly-symbol-address
        pin to the loader's function? pin.
@
text
@d1012 2
a1013 1
  set (this, "value-attribute", "pc");
a1031 1
  set (this, "value-attribute", "pc");
@


1.13
log
@2006-06-14  Dave Brolley  <brolley@@redhat.com>

        * commonCfg.cxx (GprofCfg): Don't subscribe to the target scheduler.
        Connect the cpu's sample-gprof pin to our sample pin. No longer any
        relation with the target scheduler.
        (BoardCfg::write_config): Nl longer any relation between gprof and
        the target scheduler.
@
text
@d1259 8
@


1.12
log
@2006-05-11  Dave Brolley  <brolley@@redhat.com>

        * commonCfg.cxx (CacheCfg::CacheCfg (const string name)): Now takes
        a second argument for the size of the buffer. Initialize my_size using
        the size provided. Call compute_comptype.
        (compute_comptype): Use my_size to complete "hw_cache_buffer-".
        (BoardCfg): Initalize step_insn_count. Initialize
        step_insn_count_1_required.
        (BoardCfg::write_load): Set the cpu's step-insn-count based on
        step_insn_count_1_required.
        (set_step_insn_count): Just set step_insn_count here.
        (trace_counter): Set step_insn_count_1_required.
        * commonCfg.h (CacheCfg::CacheCfg (const string name)): Now takes
        a second argument for the size of the buffer.
        (step_insn_count): New member of BoardCfg.
        (step_insn_count_1_required): New member of BoardCfg.
@
text
@a1004 7
  // Add a subscription to the target scheduler. Even if it's not
  // used now, it could be used due to dynamic configuration.
  assert (sess->sim_sched);
  int slot = sess->sim_sched->add_subscription (this, "sample");
  sess->sim_sched->set_regular (slot, true);
  sess->sim_sched->set_time (slot, interval);
  sess->sim_sched->set_priority (slot, SchedCfg::gprof_priority);
d1006 1
a1006 7
  if (type != simulated_cycles)
    {
      // default to instruction_count
      string ev = sidutil::make_attribute (cpu->get_subscription_number());
      ev += "-event";
      conn_pin (sess->sim_sched, ev, this, "sample");
    }
a1014 1
  set (this, "sim-sched-event", sidutil::make_attribute (slot));
a1027 7
  // Add a subscription to the target scheduler. Even if it's not
  // used now, it could be used due to dynamic configuration.
  assert (sess->sim_sched);
  int slot = sess->sim_sched->add_subscription (this, "sample");
  sess->sim_sched->set_regular (slot, true);
  sess->sim_sched->set_time (slot, 1);
  sess->sim_sched->set_priority (slot, SchedCfg::gprof_priority);
a1032 1
  set (this, "sim-sched-event", sidutil::make_attribute (slot));
a1310 1
	  Relation (gprof, "sim-sched", sess->sim_sched).write_to (w);
@


1.11
log
@2005-08-23  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (try_add_gprof): Initialize interval.
        * commonCfg.cxx (set_priority): New method of SchedCfg.
        (GprofCfg): Always call set_time, set_regular and set_priority.
        (BoardCfg::write_load): Don't connect init-seq to the dynamic
        configurator's step! pin. Call set_priority.
        * commonCfg.h (set_priority): New method of SchedCfg.
        (config_priority,gprof_priority,default_priority): New constants in
        SchedCfg.
@
text
@d111 1
a111 1
CacheCfg::CacheCfg (const string name) : 
d116 1
a116 1
	     "hw-cache-buffer-8"),
d118 1
a118 1
  my_size (8),
d121 3
a123 1
{}
d166 1
a166 1
      my_comptype = "hw-cache-buffer-8";
d1173 3
a1175 1
  warmup_funcs ("_Sid_config")
a1178 1
  set_step_insn_count ("10000");
d1272 2
d1396 1
a1396 1
  cpu->set (cpu, "step-insn-count", count);
d1463 1
@


1.10
log
@2005-08-19  Dave Brolley  <brolley@@redhat.com>
        (record_data_memory_write_latency): New virtual method.
        * Contribute the following changes:n_memory_read_latency.
        (write_insn_memory): Call record_insn_memory_write_latency.
        2005-07-13  Dave Brolley  <brolley@@redhat.com>ad_latency.
        (write_data_memory): Call record_data_memory_write_latency.
        * mepCfg.cxx (set_dynamic_config): New method of MepMemCfg.::check_level
        (MepCacheCfg::set_dynamic_config): Don't use the new-config pin
        or the dynamic-configurator attribute. Instead, relate the cache
        to the dynamic configurator using its client relation.
        (MepBoardCfg::write_config): Likewise for the insn_buffer, dmac,result
        hw_engines and peripherals. Call set_dynamic_config for shared_main_mem.
        * mainDynamic.cxx (BoardConfig): New struct type.
        (main): Keep a vector of the boards in board_configs. Call:ok.
        set_start_config for each board after all the --wrap options have
        been seen. Call add_wrapped_component to identify each wrapped
        component to the session.y@@redhat.com>
        * commonCfg.h (wrapped_components): New member of SessionCfg.
        (add_wrapped_component): New method of SessionCfg.New class.
        (wrap_config): Likewise.ule): Reschedule after the given number of
        * commonCfg.cxx (wrap_config): New method of SessionCfg.
        (profile_config): Use possible_wrap_name to obtain the component
        being wrapped so we can get its name.
        (GdbCfg::write_config): Don't connect the new-config pin or use the
        dynamic-configurator relation. Instead, use the dynamic configurator's
        client relation.
        (BoardCfg::write_config): Likewise. Relate the dynamic configurator
        to gloss.
        * baseCfg.cxx (wrap_component): Now returns AtomicCfg *.
        (possible_wrap_name): Likewise.
        (dynamic_config_for_wrapped_children): Don't connect the dynamic
        configurator's new-config pin to the components or relate the
        dynamic configurator to them. Rather, relate the components to the
        dynamic configurator using its 'client' relation.
        * baseCfg.h (wrap_component): Now returns AtomicCfg *.
        (possible_wrap_name): Likewise.

        2005-07-05  Dave Brolley  <brolley@@redhat.com>

        * commonCfg.cxx (BoardCfg::write_load): Connect dynamic configurator's
        "reset" pin to output 2 of reset_net.
        (write_config): Set the "start-config" attribute of the dynamic
        configurator not gloss. Relate "main" to the dynamic configurator
        unconditionally. Connect the "config-error" pins of the dynamic
        configurator and gloss.

        2005-06-30  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (try_add_gprof): Make sure an argument is specified
        after the comma.

        2005-06-06  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (need_sess): Now takes 'verbose' argument. Use it
        to initialize sess->verbose. Update all callers.
        (main): Add " --model-busses" to board_start_config instead of
        " --model_busses" (typo).
        * commonCfg.h (need_core_probe): New member of SessionCfg.
        (BoardCfg::dynamic_configurator): Now public.
        * commonCfg.cxx (SessionCfg): Initialize need_core_probe.
        (profile_config): Set need_core_probe for --trace-core. Call
        use_tcl_bridge and possible_wrap_name for --wrap.
        (LoaderCfg): Don't set verbose? attribute here.
        (GlossCfg): Likewise.
        (GdbCfg::write_config): Connect the stub and the socket to the
        dynamic_configurator.
        (BoardCfg): Initialize core_probe and warmup_funcs. Connect the cpu's
        print-insn-summary pin to the shutdown sequence here.
        (BoardCfg::write_load): Connect the dynamic configurator's step! pin
        to the init-sequence's output 6. Set the core_probe's trace?
        attribute. Set the gloss and loader's verbose? attributes.
        (BoardCfg::write_config): Give the dynamic configurator its own
        subscription to sim-sched. Set the cpu's 'main' and core-probe
        relations. Connect gloss, core_probe, loader and all of the board's
        wrapped childred to the dynamic configurator. Check whether components
        are wrapped before connecting them to the dynamic configurator. Don't co
nnect
        the cpu's print-insn-summary pin to the shutdown sequence here.
        * baseCfg.cxx (AtomicCfg): Initialize my_possibly_wrapped.
        (wrap_component): Set my_possibly_wrapped.
        (possible_wrap_name): New static method of AtomicCfg.
        (AtomicCfg::write_construct): Check my_possibly_wrapped. Set
        victim-trace? to false if only possibly wrapped.
        (dynamic_config_for_wrapped_children): New method of AggregateCfg.
        * baseCfg.h (possible_wrap_name): New static method of AtomicCfg.
        (possibly_wrapped): New method of AtomicCfg.
        (my_possibly_wrapped): New member of AtomicCfg.
        (dynamic_config_for_wrapped_children): New method of AggregateCfg.

        2005-05-29  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (usage): Document --profile-config,--profile-func,
        --warmup-func and --warmup.
        (Defs): Initialize warmup, profile_func and start_config.
        (warmup,profile_func,warmup_func,start_config): New members of Defs.
        (need_sess): Call profile_config with "sid-internal-warmup:".
        (opt_warmup,opt_warmup_func,opt_profile_func,opt_profile_config): New
        enumerators.
        (long_options): Add --profile-config,--profile-func,
        --warmup-func and --warmup.
        (main): Accumulate start_config with reconfigurable options which occur
        before the first --board. For each board call set_start_config with
        the value of start_config concatenated with the additional reconfigurabl
e
        options specified for that --board. Call set_warmup, add_warmup_func and
        add_profile_func for each board. Handle new option enums.
        * commonCfg.h (add_profile_config): New method of SessionCfg.
        (profile_config_error, profile_opt_value, profile_opt_int_value)
        (profile_opt_gprof_value, match_profile_opt, profile_config): New
        methods of SessionCfg.
        (GprofCfg): New constructor.
        (write_load): New virtual override in BoardCfg.
        (add_profile_func, add_warmup_func, set_warmup, set_start_config): New
        methods of BoardCfg.
        (need_gprof): New member of BoardCfg.
        (start_config,warmup_funcs,profile_funcs): New members of BoardCfg.
        * commonCfg.cxx (SessionCfg): Initialize need_gprof.
        (add_profile_config): New method of SessionCfg.
        (profile_config_error, profile_opt_value, profile_opt_int_value)
        (profile_opt_gprof_value, match_profile_opt, profile_config): New
        methods of SessionCfg.
        (GprofCfg): Always add a sunscription to sim_sched. Set the
        sim-sched-event attribute.
        (GprofCfg): New constructor.
        (BoardCfg): Initialize dynamic_configurator and start_config.
        (write_load): New virtual override in BoardCfg.
        (BoardCfg::write_config): Make connections and set attributes to allow
        for dynamic configuration.
        (add_profile_func, add_warmup_func, set_warmup, set_start_config): New
        methods of BoardCfg.
@
text
@d442 7
d1007 3
d1011 1
a1011 6
  if (type == simulated_cycles)
    {
      sess->sim_sched->set_regular (slot, true);
      sess->sim_sched->set_time (slot, interval);
    }
  else		// default to instruction_count
d1013 1
d1018 1
d1044 3
a1240 1
      sess->init_seq->add_output (6, dynamic_configurator, "step!");
d1242 2
a1243 1
      sess->sim_sched->add_subscription (dynamic_configurator, "step!", "step-control");
@


1.9
log
@2005-05-10  Dave Brolley  <brolley@@redhat.com>

        * commonCfg.cxx (~BlockingCacheCfg): New destructor.
        (BlockingCacheCfg): New constructors.
        * commonCfg.h (BlockingCacheCfg): New class.
@
text
@d576 2
d620 6
d712 172
a915 1
  set (this, "verbose?", sess->verbose ? "true" : "false");
a959 1
  set (this, "verbose?", sess->verbose ? "true" : "false");
a976 1
  set (this, "verbose?", sess->verbose ? "true" : "false");
a980 1

d996 5
a1002 2
      assert (sess->sim_sched);
      int slot = sess->sim_sched->add_subscription (this, "sample");
d1019 24
d1120 13
d1157 5
a1161 1
  loader (NULL)
d1181 3
d1223 39
d1265 1
d1290 62
a1440 1
  sess->shutdown_seq->add_output (0, cpu, "print-insn-summary!");
d1535 30
@


1.8
log
@	* compLoader.cxx (generic_loader):  Add eflags_pin.
	(elf_loader): Add eflags.
	(load_it): Set eflags.
	* elfload.c (readElfFile): Add eflags.
	* sidcpuutil.h (basic_cpu): Add eflags_set_pin, set_eflags.
	* commonCfg.cxx (add_cpu):  Add eflags-set pin.
@
text
@d257 42
@


1.7
log
@2004-03-22  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (main): Call add_board in place of add_child.
        * commonCfg.h (add_gdb): New method of SessionCfg.
        (add_board): Ditto.
        (write_config): Ditto.
        (board_count): New member of SessionCfg.
        (gdb_count): Ditto.
        * commonCfg.cxx (SessionCfg): Initialize board_count and gdb_count.
        (SessionCfg::write_config): New method.
        (set_gdb): Call sess->add_gdb.
@
text
@d711 1
@


1.6
log
@2003-10-26  Dave Brolley  <brolley@@redhat.com>

        * commonCfg.cxx (BoardCfg): Initialize 'gprof'.
@
text
@d533 3
a535 1
    use_stdio (true)
d662 20
d945 1
@


1.5
log
@2003-10-21  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (try_load_file): Call set_loader of
        session or board as appropriate.
        * commonCfg.h (loader): New member of SessionCfg.
        (set_loader): New method of SessionCfg.
        (loader): New member of SessionCfg.
        (set_loader): New method of BoardCfg.
        * commonCfg.cxx (SessionCfg): Initialize loader.
        (set_loader): New method of SessionCfg.
        (BoardCfg): Initialize loader.
        (set_loader): New method of SessionCfg.
        (set_loader): New method of BoardCfg.
@
text
@d872 1
@


1.4
log
@2003-06-10  Dave Brolley  <brolley@@redhat.com>

        * mainDynamic.cxx (usage): Document --ulog-* options.
        (try_add_memory): Don't make the base of the mapping zero by default.
        (Defs): New members: ulog_level, ulog_mode, ulog_file.
        (option_num): New members: opt_ulog_level, opt_ulog_mode,
        opt_ulog_file.
        (long_options): Add ulog-*.
        (main): Provide defaults for ulog-*. Handle opt_ulog_*.
        * commonCfg.h (struct UlogCfg): New struct.
        (SessionCfg): Now inherits UlogCfg.
        (add_ulog_file): New method of SessionCfg.
        (ulog_map): New member of SessionCfg.
        (BoardCfg): Now inherits UlogCfg.
        * commonCfg.cxx (SessionCfg): Add a ulog mapping for "-" to ulog_map.
        (add_ulog_file): New method of SeessionCfg.
        (BoardCfg): Initialize UlogCfg.
        (add_memory): Set the base for the mapping to 0.
@
text
@d531 1
d550 1
a550 1
  AtomicCfg *ulog = new AtomicCfg ("ulog-*",
d553 2
a554 2
				   "sid-io-stdio");
  ulog_map["*"] = ulog;
d568 1
a568 1
				   "sid-io-stdio");
d574 8
d874 2
a875 1
  dcache (NULL)
d922 9
@


1.3
log
@2003-04-16  Dave Brolley  <brolley@@redhat.com>

        * commonCfg.cxx (final_insn_count): Set cpu attribute 'final-insn-count'.
@
text
@d548 23
d856 1
d1105 4
a1108 1
    main_mapper->map (m);
@


1.2
log
@2003-01-31  Frank Ch. Eigler  <fche@@redhat.com>

	* baseCfg.cxx, commonCfg.cxx: More of the same.
@
text
@d1007 1
@


1.1
log
@* new simulator mainline

2002-05-30  Frank Ch. Eigler  <fche@@redhat.com>

	* mainDynamic.cxx (main): Add new "--rc" option to control passing
	cfgroot stop-code as sid process exit rc.

2002-04-29  Graydon Hoare  <graydon@@redhat.com>

	* mainDynamic.cxx: Make step_insn_count a string.

2002-04-29  Graydon Hoare  <graydon@@redhat.com>

	* commonCfg.h (Mapping): New class.
	* commonCfg.cxx (MapperCfg): Update to use Mapping objects.
	* mainDynamic.cxx (try_add_memory): Use Mapping objects.
	(Defs): Make step_insn_count a defaultable option.

2002-04-23  Graydon Hoare  <graydon@@redhat.com>

	* mainDynamic.cxx (try_add_memory): Force mappings to base address
	0 in extra memory region, to ignore transparent / basic mapper
	distinction in board-specific code.

2002-04-15  Dave Brolley  <brolley@@redhat.com>

	* commonCfg.cxx (struct MemCfg_impl): New struct.
	(MemCfg_impl::get_by_name): New function.
	(MemCfg::MemCfg): Add 'this' to name_map.
	* commonCfg.h (MemCfg_impl::get_by_name): New function.

2002-04-09  Dave Brolley  <brolley@@redhat.com>

	* commonCfg.cxx (add_mapping): New variant.
	* commonCfg.h (add_mapping): New variant.

2002-03-25  Graydon Hoare  <graydon@@redhat.com>

	* mainDynamic.cxx (try_load_file): Support "all-cpu" sub-option
	to --load option.
	* commonCfg.h (CpuCfg::get_all): Likewise.
	* commonCfg.cxx (CpuCfg::get_all): Likewise.

2002-03-11  Graydon Hoare  <graydon@@redhat.com>

	* mainDynamic.cxx (main): Add opt_gloss.
	* commonCfg.cxx (BoardCfg::use_gloss): Define.
	* commonCfg.h: Likewise.

2002-02-22  Graydon Hoare  <graydon@@redhat.com>

	* Makefile.am (INCLUDE): Add -I$(srcdir)/../../../include.
	* Makefile.in: Regenerate.
	* mainDynamic.cxx: Un-guard #include <getopt.h>, getting it
	from libiberty now.

2002-02-08  Graydon Hoare  <graydon@@redhat.com>

	* baseCfg.cxx: New file.
	* baseCfg.h: New file.
	* commonCfg.cxx: New file.
	* commonCfg.h: New file.
	* mainDynamic.cxx: Complete rewrite, incorporate contents of
	configrun-sid.in perl script.
	* Makefile.am (sid): Add new files to target.
	* Makefile.in: Regenerate.
@
text
@d423 1
a423 1
MapperCfg::MapperCfg (const string name, bool transparent = false) :
d828 3
a830 3
		    bool with_default_gloss = true,
		    bool with_z_packet = true,
		    bool with_cpu_main_mem_connect = false) :
@

