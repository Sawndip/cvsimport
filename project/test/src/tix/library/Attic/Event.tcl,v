head	1.3;
access;
symbols
	gdb_5_3-2002-12-12-release:1.2
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TIX_TCL_8_3:1.1.1.1
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2003.03.07.23.09.21;	author hunt;	state dead;
branches;
next	1.2;

1.2
date	2001.09.08.23.25.52;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.28;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.28;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Remove directory.
@
text
@# Event.tcl --
#
#	Handles the event bindings of the -command and -browsecmd options
#	(and various of others such as -validatecmd).
#
# Copyright (c) 1996, Expert Interface Technologies
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#

#----------------------------------------------------------------------
# Evaluate high-level bindings (-command, -browsecmd, etc):
# with % subsitution or without (compatibility mode)
#
#
# BUG : if a -command is intercepted by a hook, the hook must use
#       the same record name as the issuer of the -command. For the time
#	being, you must use the name "bind" as the record name!!!!!
#
#----------------------------------------------------------------------
set _tix_event_flags ""
append _tix_event_flags " %%"
append _tix_event_flags " %#"
#append _tix_event_flags " %a"
append _tix_event_flags " %b"
append _tix_event_flags " %c"
append _tix_event_flags " %d"
append _tix_event_flags " %f"
append _tix_event_flags " %h"
append _tix_event_flags " %k"
append _tix_event_flags " %m"
append _tix_event_flags " %o"
append _tix_event_flags " %p"
append _tix_event_flags " %s"
append _tix_event_flags " %t"
append _tix_event_flags " %w"
append _tix_event_flags " %x"
append _tix_event_flags " %y"
append _tix_event_flags " %A"
append _tix_event_flags " %B"
append _tix_event_flags " %E"
append _tix_event_flags " %K"
append _tix_event_flags " %N"
append _tix_event_flags " %R"
#append _tix_event_flags " %S"
append _tix_event_flags " %T"
append _tix_event_flags " %W"
append _tix_event_flags " %X"
append _tix_event_flags " %Y"

proc tixBind {tag event action} {
    global _tix_event_flags

    append cmd "_tixRecordFlags $event $_tix_event_flags;"
    append cmd "$action; "
    append cmd "_tixDeleteFlags"

    bind $tag $event $cmd
}

# This is a "name stack" for storing the "bind" structures
#
# The bottom of the event stack is usually a raw event (generated by tixBind)
# but it may also be a programatically triggered (caused by tixEvalCmdBinding)
#
#

set tixEvent(nameStack)		""
set tixEvent(stackLevel)        0

proc tixPushEventStack {} {
    global tixEvent

    set lastEvent [lindex $tixEvent(nameStack) 0]
    incr tixEvent(stackLevel)
    set thisEvent _tix_event$tixEvent(stackLevel)

    set tixEvent(nameStack) \
	[list $thisEvent $tixEvent(nameStack)]

    if {$lastEvent == ""} {
	upvar #0 $thisEvent this
	set this(type) <Application>
    } else {
	upvar #0 $lastEvent last
	upvar #0 $thisEvent this

	foreach name [array names last] {
	    set this($name) $last($name)
	}
    }

    return $thisEvent
}

proc tixPopEventStack {varName} {
    global tixEvent

    if {$varName != [lindex $tixEvent(nameStack) 0]} {
	error "unmatched tixPushEventStack and tixPopEventStack calls"
    }
    incr tixEvent(stackLevel) -1
    set tixEvent(nameStack) [lindex $tixEvent(nameStack) 1]
    global $varName
    unset $varName
}


# Events triggered by tixBind
#
proc _tixRecordFlags [concat event $_tix_event_flags] {
    global _tix_event_flags

    set thisName [tixPushEventStack]; upvar #0 $thisName this

    set this(type) $event
    foreach f $_tix_event_flags {
	set this($f) [set $f]
    }
}

proc _tixDeleteFlags {} {
    global tixEvent

    tixPopEventStack [lindex $tixEvent(nameStack) 0]
}

# programatically trigged events
#
proc tixEvalCmdBinding {w cmd {subst ""} args} {
    global tixPriv tixEvent tix

    set thisName [tixPushEventStack]; upvar #0 $thisName this

    if {$subst != ""} {
	upvar $subst bind

	if [info exists bind(specs)] {
	    foreach spec $bind(specs) {
		set this($spec) $bind($spec)
	    }
	}
	if [info exists bind(type)] {
	    set this(type) $bind(type)
	}
    }

    if [catch {
	if [tixGetBoolean -nocomplain $tix(-extracmdargs)] {
	    # Compatibility mode
	    #
	    set ret [uplevel #0 $cmd $args]
	} else {
	    set ret [uplevel $cmd]
	}
    } error] {
	if [catch {
	    tixCmdErrorHandler $error
	} error] {
	    # double fault: just print out 
	    tixBuiltInCmdErrorHandler $error
	}
	tixPopEventStack $thisName
	return ""
    } else {
	tixPopEventStack $thisName

	return $ret
    }
}

proc tixEvent {option args} {
    global tixPriv  tixEvent
    set varName [lindex $tixEvent(nameStack) 0]

    if {$varName == ""} {
	error "tixEvent called when no event is being processed"
    } else {
	upvar #0 $varName event
    }

    case $option {
	type {
	    return $event(type)
	}
	value {
	    if [info exists event(%V)] {
		return $event(%V)
	    } else {
		return ""
	    }
	}
	flag {
	    set f %[lindex $args 0]
	    if [info exists event($f)] {
		return $event($f)
	    }
	    error "The flag \"[lindex $args 0]\" does not exist"
	}
	match {
	    return [string match [lindex $args 0] $event(type)]
	}
	default {
	    error "unknown option \"$option\""
	}
    }
}

# tixBuiltInCmdErrorHandler --
#
#	Default method to report command handler errors. This procedure is
#	also called if double-fault happens (command handler causes error,
#	then tixCmdErrorHandler causes error).
#
proc tixBuiltInCmdErrorHandler {errorMsg} {
    global errorInfo tcl_platform
    if ![info exists errorInfo] {
	set errorInfo "???"
    }
    if {$tcl_platform(platform) == "windows"} then {
	bgerror "Tix Error: $errorMsg"
    } else {
	puts "Error:\n $errorMsg\n$errorInfo"
    }
}

# tixCmdErrorHandler --
#
#	You can redefine this command to handle the errors that occur
#	in the command handlers. See the programmer's documentation
#	for details
#
if ![string compare [info command tixCmdErrorHandler] ""] {
    proc tixCmdErrorHandler {errorMsg} {
	tixBuiltInCmdErrorHandler $errorMsg
    }
}

@


1.2
log
@Touched all tix files to ease next import.
@
text
@@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@
