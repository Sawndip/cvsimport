head	1.6;
access;
symbols
	msnyder-tracepoint-checkpoint-branch:1.5.0.50
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	ezannoni_pie-20040323-branch:1.5.0.48
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.46
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.44
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.42
	cagney_x86i386-20030821-branch:1.5.0.40
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.38
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.36
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.34
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.32
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.30
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.28
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.26
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.24
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.22
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.20
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.18
	cagney-unwind-20030108-branchpoint:1.5
	carlton_dictionary-20021223-merge:1.5
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.16
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.14
	carlton_dictionary-20020920-branchpoint:1.5
	sid-20020905-branchpoint:1.5
	sid-20020905-branch:1.5.0.12
	gdb_5_3-branch:1.5.0.10
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.8
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.6
	readline_4_3-import-branchpoint:1.5
	kseitz_interps-20020528-branch:1.5.0.4
	kseitz_interps-20020528-branchpoint:1.5
	cagney_regbuf-20020515-branch:1.5.0.2
	cagney_regbuf-20020515-branchpoint:1.5
	gdb_5_2-branch:1.4.0.8
	gdb_5_2-2002-03-03-branchpoint:1.4
	cygnus_cvs_20020108_pre:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.6
date	2005.06.29.01.58.56;	author bje;	state dead;
branches;
next	1.5;

1.5
date	2002.04.21.08.47.07;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.17.16.36.44;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.05.06.34.02;	author geoffk;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.02.22.35.10;	author guo;	state Exp;
branches;
next	1.1;

1.1
date	99.11.09.01.28.42;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.11.09.01.28.42;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Remove old version of DejaGnu.
@
text
@# Copyright (C) 1992 - 2001 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 

# Please email any bugs, comments, and/or additions to this file to:
# bug-dejagnu@@gnu.org

# This file was written by Rob Savoye. (rob@@welcomehome.org)

#
# Most of the procedures found here mimic their unix counter-part. 
# This file is sourced by runtest.exp, so they are usable by any test case.
#

#
# Gets the directories in a directory
#     args: the first is the dir to look in, the next
#         is the pattern to match. It
#         defaults to *. Patterns are csh style
#   	  globbing rules
#     returns: a list of dirs or NULL
#
proc getdirs { args } {
    if { [lindex $args 0] == "-all" } {
	set alldirs 1
	set args [lrange $args 1 end]
    } else {
	set alldirs 0
    }

    set path [lindex $args 0]
    if { [llength $args] > 1} {
	set pattern [lindex $args 1]
    } else {
	set pattern "*"
    }
    verbose "Looking in ${path} for directories that match \"${pattern}\"" 3
    catch "glob ${path}/${pattern}" tmp
    if { ${tmp} != "" } {
	foreach i ${tmp} {
	    if [file isdirectory $i] {
		switch -- "[file tail $i]" {
		    "testsuite" -
		    "config" -
		    "lib" -
		    "CVS" -
		    "RCS" -
		    "SCCS" {
			verbose "Ignoring directory [file tail $i]" 3
			continue
		    }
		    default {
			if [file readable $i] {
			    verbose "Found directory [file tail $i]" 3
			    lappend dirs $i
			    if { $alldirs } {
				eval lappend dirs [getdirs -all $i $pattern]
			    }
			}
		    }
		}
	    }
	}
    } else {
	perror "$tmp"
	return ""
    }
    
    if ![info exists dirs] {
	return ""
    } else {
	return $dirs
    }
}

#
# Finds all the files recursively
#     rootdir - this is the directory to start the search
#   	  from. This is and all subdirectories are search for
#   	  filenames. Directory names are not included in the
#   	  list, but the filenames have path information. 
#     pattern - this is the pattern to match. Patterns are csh style
#   	  globbing rules.
#     returns: a list or a NULL.
#
proc find { rootdir pattern } {
    # first find all the directories
    set dirs "$rootdir "
    while 1 {
	set tmp $rootdir
	set rootdir ""
	if [string match "" $tmp] {
	    break
	}
	foreach i $tmp {
	    set j [getdirs -all $i]
	    if ![string match "" $j] {
		append dirs "$j "
		set rootdir $j
		unset j
	    } else {
		set rootdir ""
	    }
	}
	set tmp ""
    }
    
    # find all the files that match the pattern
    foreach i $dirs {
	verbose "Looking in $i" 3
	set tmp [glob -nocomplain $i/$pattern]
	if { [llength $tmp] != 0 } {
	    foreach j $tmp {
		if ![file isdirectory $j] {
		    lappend files $j
		    verbose "Adding $j to file list" 3
		}
	    }
	}
    }
    
    if ![info exists files] {
	lappend files ""
    }
    return $files
}

#
# Search the path for a file. This is basically a version
# of the BSD-unix which utility. This procedure depends on
# the shell environment variable $PATH. It returns 0 if $PATH
# does not exist or the binary is not in the path. If the
# binary is in the path, it returns the full path to the binary.
#
proc which { file } {
    global env
    
    # strip off any extraneous arguments (like flags to the compiler)
    set file [lindex $file 0]
    
    # if it exists then the path must be OK
    # ??? What if $file has no path and "." isn't in $PATH?
    if [file exists $file] {
	return $file
    }
    if [info exists env(PATH)] {
	set path [split $env(PATH) ":"]
    } else {
	return 0
    }
    
    foreach i $path {
	verbose "Checking against $i" 3
	if [file exists $i/$file] {
	    if [file executable $i/$file] {
		return $i/$file
	    } else {
		warning "$i/$file exists but is not an executable"
	    }
	}
    }
    # not in path
    return 0
}

#
# Looks for a string in a file. 
#     return:list of lines that matched or NULL if none match.
#     args:  first arg is the filename,
#            second is the pattern,
#            third are any options.
#     Options: line  - puts line numbers of match in list
#
proc grep { args } {
    
    set file [lindex $args 0]
    set pattern [lindex $args 1]
    
    verbose "Grepping $file for the pattern \"$pattern\"" 3
    
    set argc [llength $args]
    if { $argc > 2 } {
	for { set i 2 } { $i < $argc } { incr i } {
	    append options [lindex $args $i]
	    append options " "
	}
    } else {
	set options ""
    }
    
    set i 0
    set fd [open $file r]
    while { [gets $fd cur_line]>=0 } {
	incr i
	if [regexp -- "$pattern" $cur_line match] {
	    if ![string match "" $options] {
		foreach opt $options {
		    case $opt in {
			"line" {
			    lappend grep_out [concat $i $match]
			}
		    }
		}
	    } else {
		lappend grep_out $match
	    }
	}
    }
    close $fd
    unset fd
    unset i
    if ![info exists grep_out] {
	set grep_out ""
    }
    return $grep_out
}

#
# Remove elements based on patterns. elements are delimited by spaces.
# pattern is the pattern to look for using glob style matching
# list is the list to check against
# returns the new list
#
proc prune { list pattern } {
    set tmp {}
    foreach i $list {
	verbose "Checking pattern \"$pattern\" against $i" 3
	if ![string match $pattern $i] {
	    lappend tmp $i
	} else {
	    verbose "Removing element $i from list" 3
	}
    }
    return $tmp
}

# 
# Attempt to kill a process that you started on the local machine.
#
proc slay { name } {
    set in [open [concat "|ps"] r]
    while {[gets $in line]>-1} {
	if ![string match "*expect*slay*" $line] {
	    if [string match "*$name*" $line] {
		set pid [lindex $line 0]
		catch "exec kill -9 $pid]"
		verbose "Killing $name, pid = $pid\n"
	    }
	}
    }
    close $in
}

#
# Convert a relative path to an absolute one on the local machine.
#
proc absolute { path } {
    if [string match "." $path] {
        return [pwd]
    }
    
    set basedir [pwd]
    cd $path
    set path [pwd]
    cd $basedir
    return $path
}

#
# Source a file and trap any real errors. This ignores extraneous
# output. returns a 1 if there was an error, otherwise it returns 0.
#
proc psource { file } {
    global errorInfo
    global errorCode

    unset errorInfo
    if [file exists $file] {
	catch "source $file"
	if [info exists errorInfo] {
	    send_error "ERROR: errors in $file\n"
	    send_error "$errorInfo"
	    return 1
	}
    }
    return 0
}

#
# Check if a testcase should be run or not
#
# RUNTESTS is a copy of global `runtests'.
#
# This proc hides the details of global `runtests' from the test scripts, and
# implements uniform handling of "script arguments" where those arguments are
# file names (ie: the "foo" in make check RUNTESTFLAGS="bar.exp=foo").
# "glob" style expressions are supported as well as multiple files (with
# spaces between them).
# Eg: RUNTESTFLAGS="bar.exp=foo1.c foo2.c foo3*.c bar/baz*.c"
#
proc runtest_file_p { runtests testcase } {
    if [string length [lindex $runtests 1]] {
	foreach ptn [lindex $runtests 1] {
	    if [string match "*/$ptn" $testcase] {
		return 1
	    }
	    if [string match $ptn $testcase] {
		return 1
	    }
	}
	return 0
    }
    return 1
}

#
# Delete various system verbosities from TEXT on SYSTEM
#
# An example is:
# ld.so: warning: /usr/lib/libc.so.1.8.1 has older revision than expected 9
#
# SYSTEM is typical $target_triplet or $host_triplet.
#

#
# Compares two files line-by-line
#     returns 1 it the files match,
#     returns 0 if there was a file error,
#     returns -1 if they didn't match.
#
proc diff { file_1 file_2 } {
    set eof -1
    set differences 0
    
    if [file exists ${file_1}] {
        set file_a [open ${file_1} r]
    } else {
        warning "${file_1} doesn't exist"
        return 0
    }
    
    if [file exists ${file_2}] {
        set file_b [open ${file_2} r]
    } else {
        warning "${file_2} doesn't exist"
        return 0
    }
    
    verbose "# Diff'ing: ${file_1} ${file_2}\n" 1
    
    set list_a ""
    while { [gets ${file_a} line] != ${eof} } {
        if [regexp "^#.*$" ${line}] {
            continue
        } else {
            lappend list_a ${line}
        }
    }
    close ${file_a}
    
    set list_b ""
    while { [gets ${file_b} line] != ${eof} } {
        if [regexp "^#.*$" ${line}] {
            continue
        } else {
            lappend list_b ${line}
        }
    }
    close ${file_b}
    for { set i 0 } { $i < [llength $list_a] } { incr i } {
        set line_a [lindex ${list_a} ${i}]
        set line_b [lindex ${list_b} ${i}]

#        verbose "\t${file_1}: ${i}: ${line_a}\n" 3
#        verbose "\t${file_2}: ${i}: ${line_b}\n" 3
        if [string compare ${line_a} ${line_b}] {
	    verbose "line #${i}\n" 2
            verbose "\< ${line_a}\n" 2
            verbose "\> ${line_b}\n" 2

	    send_log "line #${i}\n"
            send_log "\< ${line_a}\n"
            send_log "\> ${line_b}\n"

            set differences -1
        }
    }
    
    if { $differences == -1 || [llength ${list_a}] != [llength ${list_b}] } {
	verbose "Files not the same" 2
        set differences -1
    } else {
	verbose "Files are the same" 2
	set differences 1
    }
    return ${differences}
}

#
# Set an environment variable
#
proc setenv { var val } {
    global env
    
    set env($var) $val
}

#
# Unset an environment variable
#
proc unsetenv { var } {
    global env
    unset env($var)
}

#
# Get a value from an environment variable
#
proc getenv { var } {
    global env

    if [info exists env($var)] {
	return $env($var)
    } else {
	return ""
    }
}
@


1.5
log
@Synchronise with sources from savanaha repository
@
text
@@


1.4
log
@        * lib/utils.exp (runtest_file_p): An argument can match trailing
        directories as well as the basename.
@
text
@d1 1
a1 1
# Copyright (C) 92, 93, 94, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.
d18 1
a18 1
# bug-dejagnu@@prep.ai.mit.edu
d20 1
a20 1
# This file was written by Rob Savoye. (rob@@cygnus.com)
d108 1
a108 1
	    set j [getdirs $i]
a439 1

@


1.3
log
@Back out this change:

	* lib/utils.exp: Add support for a -maxdepth <n>
        option to limit find to <n> directories deep.
	* runtest.exp: Handle multiple directories in TCL variables
        dir_to_run and cmdline_dir_to_run; limit *.exp find to
        one directory level to avoid foo/bar/baz.exp getting tested
        twice (when ${dir} is 'foo', and when ${dir} is 'foo/bar').

also rearrange the next ChangeLog entry so that it's clear what the
separate changes to runtest.exp are.  Also replace 8 initial spaces
in the ChangeLog with tabs.
@
text
@d311 1
a311 1
# Eg: RUNTESTFLAGS="bar.exp=foo1.c foo2.c foo3*.c bar*.c"
a314 1
	set basename [file tail $testcase]
d316 1
a316 1
	    if [string match $ptn $basename] {
@


1.2
log
@* runtest.exp: Handle multiple directories in TCL variables
dir_to_run and cmdline_dir_to_run; limit *.exp find to
one directory level to avoid foo/bar/baz.exp getting tested
twice (when ${dir} is 'foo', and when ${dir} is 'foo/bar').

* lib/utils.exp (find): Add support for a -maxdepth <n>
option to limit find to <n> directories deep.
@
text
@d90 7
a96 13
# Args:
#     [-maxdepth <n>]
#         limit recursive find depth to <n> level;
#         default is to recursively find in all subdirectories
#     rootdir
#         the directory to start the search from. This is and all
#         subdirectories are searched for filenames. Directory names
#         are not included in the list, but the filenames have path
#         information. 
#     pattern
#         the pattern to match. Patterns are csh style globbing rules.
# Returns:
#     a list or a NULL.
d98 1
a98 10
proc find { args } {
    if { [lindex $args 0] == "-maxdepth" } {
        set maxdepth [lindex $args 1]
	set args [lrange $args 2 end]
    } else {
	set maxdepth 0
    }
    set rootdir [lindex $args 0]
    set pattern [lindex $args 1]

d101 1
a101 2
    set depth 1
    while { $maxdepth == 0 || $depth < $maxdepth } {
a117 1
        set depth [expr $depth + 1]
@


1.1
log
@Initial revision
@
text
@d90 13
a102 7
#     rootdir - this is the directory to start the search
#   	  from. This is and all subdirectories are search for
#   	  filenames. Directory names are not included in the
#   	  list, but the filenames have path information. 
#     pattern - this is the pattern to match. Patterns are csh style
#   	  globbing rules.
#     returns: a list or a NULL.
d104 10
a113 1
proc find { rootdir pattern } {
d116 2
a117 1
    while 1 {
d134 1
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@
