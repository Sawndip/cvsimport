head	1.27;
access;
symbols
	sid-snapshot-20180601:1.27
	sid-snapshot-20180501:1.27
	sid-snapshot-20180401:1.27
	sid-snapshot-20180301:1.27
	sid-snapshot-20180201:1.27
	sid-snapshot-20180101:1.27
	sid-snapshot-20171201:1.27
	sid-snapshot-20171101:1.27
	sid-snapshot-20171001:1.27
	sid-snapshot-20170901:1.27
	sid-snapshot-20170801:1.27
	sid-snapshot-20170701:1.27
	sid-snapshot-20170601:1.27
	sid-snapshot-20170501:1.27
	sid-snapshot-20170401:1.27
	sid-snapshot-20170301:1.27
	sid-snapshot-20170201:1.27
	sid-snapshot-20170101:1.27
	sid-snapshot-20161201:1.27
	sid-snapshot-20161101:1.27
	sid-snapshot-20160901:1.27
	sid-snapshot-20160801:1.27
	sid-snapshot-20160701:1.27
	sid-snapshot-20160601:1.27
	sid-snapshot-20160501:1.27
	sid-snapshot-20160401:1.27
	sid-snapshot-20160301:1.27
	sid-snapshot-20160201:1.27
	sid-snapshot-20160101:1.27
	sid-snapshot-20151201:1.27
	sid-snapshot-20151101:1.27
	sid-snapshot-20151001:1.27
	sid-snapshot-20150901:1.27
	sid-snapshot-20150801:1.27
	sid-snapshot-20150701:1.27
	sid-snapshot-20150601:1.27
	sid-snapshot-20150501:1.27
	sid-snapshot-20150401:1.27
	cygwin-1_7_35-release:1.27
	sid-snapshot-20150301:1.27
	cygwin-1_7_34-release:1.27
	sid-snapshot-20150201:1.27
	sid-snapshot-20150101:1.27
	sid-snapshot-20141201:1.27
	cygwin-1_7_33-release:1.27
	sid-snapshot-20141101:1.27
	sid-snapshot-20141001:1.27
	sid-snapshot-20140901:1.27
	cygwin-1_7_32-release:1.27
	sid-snapshot-20140801:1.27
	cygwin-1_7_31-release:1.27
	sid-snapshot-20140701:1.27
	sid-snapshot-20140601:1.27
	cygwin-1_7_30-release:1.27
	sid-snapshot-20140501:1.27
	cygwin-1_7_29-release:1.27
	sid-snapshot-20140401:1.27
	sid-snapshot-20140301:1.27
	cygwin-1_7_28-release:1.27
	sid-snapshot-20140201:1.27
	sid-snapshot-20140101:1.27
	sid-snapshot-20131201:1.27
	cygwin-1_7_27-release:1.27
	cygwin-1_7_26-release:1.27
	sid-snapshot-20131101:1.27
	sid-snapshot-20131001:1.27
	binutils-2_24-branch:1.27.0.22
	binutils-2_24-branchpoint:1.27
	binutils-2_21_1:1.27
	sid-snapshot-20130901:1.27
	cygwin-1_7_25-release:1.27
	gdb_7_6_1-2013-08-30-release:1.27
	cygwin-1_7_24-release:1.27
	cygwin-1_7_23-release:1.27
	sid-snapshot-20130801:1.27
	cygwin-1_7_22-release:1.27
	cygwin-1_7_21-release:1.27
	sid-snapshot-20130701:1.27
	cygwin-1_7_20-release:1.27
	cygwin-1_7_19-release:1.27
	sid-snapshot-20130601:1.27
	sid-snapshot-20130501:1.27
	gdb_7_6-2013-04-26-release:1.27
	cygwin-64bit-postmerge:1.27
	cygwin-64bit-premerge-branch:1.27.0.20
	cygwin-64bit-premerge:1.27
	sid-snapshot-20130401:1.27
	binutils-2_23_2:1.27
	gdb_7_6-branch:1.27.0.18
	gdb_7_6-2013-03-12-branchpoint:1.27
	cygwin-1_7_18-release:1.27
	sid-snapshot-20130301:1.27
	sid-snapshot-20130201:1.27
	sid-snapshot-20130101:1.27
	sid-snapshot-20121201:1.27
	gdb_7_5_1-2012-11-29-release:1.27
	binutils-2_23_1:1.27
	sid-snapshot-20121101:1.27
	binutils-2_23:1.27
	cygwin-1_7_17-release:1.27
	sid-snapshot-20121001:1.27
	sid-snapshot-20120901:1.27
	gdb_7_5-2012-08-17-release:1.27
	cygwin-64bit-branch:1.27.0.16
	sid-snapshot-20120801:1.27
	binutils-2_23-branch:1.27.0.14
	binutils-2_23-branchpoint:1.27
	cygwin-1_7_16-release:1.27
	gdb_7_5-branch:1.27.0.12
	gdb_7_5-2012-07-18-branchpoint:1.27
	sid-snapshot-20120701:1.27
	sid-snapshot-20120601:1.27
	cygwin-1_7_15-release:1.27
	sid-snapshot-20120501:1.27
	binutils-2_22_branch:1.27.0.10
	gdb_7_4_1-2012-04-26-release:1.27
	cygwin-1_7_14_2-release:1.27
	cygwin-1_7_14-release:1.27
	cygwin-1_7_12-release:1.27
	sid-snapshot-20120401:1.27
	sid-snapshot-20120301:1.27
	cygwin-1_7_11-release:1.27
	cygwin-1_7_10-release:1.27
	sid-snapshot-20120201:1.27
	gdb_7_4-2012-01-24-release:1.27
	sid-snapshot-20120101:1.27
	gdb_7_4-branch:1.27.0.8
	gdb_7_4-2011-12-13-branchpoint:1.27
	sid-snapshot-20111201:1.27
	binutils-2_22:1.27
	sid-snapshot-20111101:1.27
	sid-snapshot-20111001:1.27
	binutils-2_22-branch:1.27.0.6
	binutils-2_22-branchpoint:1.27
	gdb_7_3_1-2011-09-04-release:1.27
	sid-snapshot-20110901:1.27
	sid-snapshot-20110801:1.27
	gdb_7_3-2011-07-26-release:1.27
	sid-snapshot-20110701:1.27
	sid-snapshot-20110601:1.27
	sid-snapshot-20110501:1.27
	gdb_7_3-branch:1.27.0.4
	gdb_7_3-2011-04-01-branchpoint:1.27
	sid-snapshot-20110401:1.27
	cygwin-1_7_9-release:1.27
	sid-snapshot-20110301:1.27
	cygwin-1_7_8-release:1.27
	sid-snapshot-20110201:1.27
	sid-snapshot-20110101:1.27
	binutils-2_21:1.27
	sid-snapshot-20101201:1.27
	binutils-2_21-branch:1.27.0.2
	binutils-2_21-branchpoint:1.27
	sid-snapshot-20101101:1.27
	sid-snapshot-20101001:1.26
	binutils-2_20_1:1.23
	gdb_7_2-2010-09-02-release:1.26
	sid-snapshot-20100901:1.26
	cygwin-1_7_7-release:1.26
	sid-snapshot-20100801:1.26
	gdb_7_2-branch:1.26.0.2
	gdb_7_2-2010-07-07-branchpoint:1.26
	sid-snapshot-20100701:1.26
	sid-snapshot-20100601:1.26
	sid-snapshot-20100501:1.26
	cygwin-1_7_5-release:1.25
	cygwin-1_7_4-release:1.25
	sid-snapshot-20100401:1.25
	cygwin-1_7_3-release:1.25
	cygwin-1_7_2-release:1.25
	gdb_7_1-2010-03-18-release:1.25
	sid-snapshot-20100301:1.25
	gdb_7_1-branch:1.25.0.2
	gdb_7_1-2010-02-18-branchpoint:1.25
	sid-snapshot-20100201:1.25
	sid-snapshot-20100101:1.25
	gdb_7_0_1-2009-12-22-release:1.23
	cygwin-1_7_1-release:1.25
	sid-snapshot-20091201:1.25
	sid-snapshot-20091101:1.24
	binutils-2_20:1.23
	gdb_7_0-2009-10-06-release:1.23
	sid-snapshot-20091001:1.23
	gdb_7_0-branch:1.23.0.66
	gdb_7_0-2009-09-16-branchpoint:1.23
	arc-sim-20090309:1.23.54.1
	binutils-arc-20081103-branch:1.23.0.64
	binutils-arc-20081103-branchpoint:1.23
	binutils-2_20-branch:1.23.0.62
	binutils-2_20-branchpoint:1.23
	sid-snapshot-20090901:1.23
	sid-snapshot-20090801:1.23
	msnyder-checkpoint-072509-branch:1.23.0.60
	msnyder-checkpoint-072509-branchpoint:1.23
	sid-snapshot-20090701:1.23
	dje-cgen-play1-branch:1.23.0.58
	dje-cgen-play1-branchpoint:1.23
	sid-snapshot-20090601:1.23
	sid-snapshot-20090501:1.23
	sid-snapshot-20090401:1.23
	arc-20081103-branch:1.23.0.56
	arc-20081103-branchpoint:1.23
	arc-insight_6_8-branch:1.23.0.54
	arc-insight_6_8-branchpoint:1.23
	insight_6_8-branch:1.23.0.52
	insight_6_8-branchpoint:1.23
	sid-snapshot-20090301:1.23
	binutils-2_19_1:1.23
	sid-snapshot-20090201:1.23
	sid-snapshot-20090101:1.23
	reverse-20081226-branch:1.23.0.50
	reverse-20081226-branchpoint:1.23
	sid-snapshot-20081201:1.23
	multiprocess-20081120-branch:1.23.0.48
	multiprocess-20081120-branchpoint:1.23
	sid-snapshot-20081101:1.23
	binutils-2_19:1.23
	sid-snapshot-20081001:1.23
	reverse-20080930-branch:1.23.0.46
	reverse-20080930-branchpoint:1.23
	binutils-2_19-branch:1.23.0.44
	binutils-2_19-branchpoint:1.23
	sid-snapshot-20080901:1.23
	sid-snapshot-20080801:1.23
	reverse-20080717-branch:1.23.0.42
	reverse-20080717-branchpoint:1.23
	sid-snapshot-20080701:1.23
	msnyder-reverse-20080609-branch:1.23.0.40
	msnyder-reverse-20080609-branchpoint:1.23
	drow-reverse-20070409-branch:1.23.0.38
	drow-reverse-20070409-branchpoint:1.23
	sid-snapshot-20080601:1.23
	sid-snapshot-20080501:1.23
	sid-snapshot-20080403:1.23
	sid-snapshot-20080401:1.23
	gdb_6_8-2008-03-27-release:1.23
	sid-snapshot-20080301:1.23
	gdb_6_8-branch:1.23.0.36
	gdb_6_8-2008-02-26-branchpoint:1.23
	sid-snapshot-20080201:1.23
	sid-snapshot-20080101:1.23
	sid-snapshot-20071201:1.23
	sid-snapshot-20071101:1.23
	gdb_6_7_1-2007-10-29-release:1.23
	gdb_6_7-2007-10-10-release:1.23
	sid-snapshot-20071001:1.23
	gdb_6_7-branch:1.23.0.34
	gdb_6_7-2007-09-07-branchpoint:1.23
	binutils-2_18:1.23
	binutils-2_18-branch:1.23.0.32
	binutils-2_18-branchpoint:1.23
	insight_6_6-20070208-release:1.23
	binutils-csl-coldfire-4_1-32:1.23
	binutils-csl-sourcerygxx-4_1-32:1.23
	gdb_6_6-2006-12-18-release:1.23
	binutils-csl-innovasic-fido-3_4_4-33:1.23
	binutils-csl-sourcerygxx-3_4_4-32:1.21
	binutils-csl-coldfire-4_1-30:1.23
	binutils-csl-sourcerygxx-4_1-30:1.23
	binutils-csl-coldfire-4_1-28:1.23
	binutils-csl-sourcerygxx-4_1-29:1.23
	binutils-csl-sourcerygxx-4_1-28:1.23
	gdb_6_6-branch:1.23.0.30
	gdb_6_6-2006-11-15-branchpoint:1.23
	binutils-csl-arm-2006q3-27:1.23
	binutils-csl-sourcerygxx-4_1-27:1.23
	binutils-csl-arm-2006q3-26:1.23
	binutils-csl-sourcerygxx-4_1-26:1.23
	binutils-csl-sourcerygxx-4_1-25:1.23
	binutils-csl-sourcerygxx-4_1-24:1.23
	binutils-csl-sourcerygxx-4_1-23:1.23
	insight_6_5-20061003-release:1.23
	gdb-csl-symbian-6_4_50_20060226-12:1.23
	binutils-csl-sourcerygxx-4_1-21:1.23
	binutils-csl-arm-2006q3-21:1.23
	binutils-csl-sourcerygxx-4_1-22:1.23
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.23
	binutils-csl-sourcerygxx-4_1-20:1.23
	binutils-csl-arm-2006q3-19:1.23
	binutils-csl-sourcerygxx-4_1-19:1.23
	binutils-csl-sourcerygxx-4_1-18:1.23
	binutils-csl-renesas-4_1-9:1.23
	gdb-csl-sourcerygxx-3_4_4-25:1.23
	binutils-csl-sourcerygxx-3_4_4-25:1.21
	nickrob-async-20060828-mergepoint:1.23
	gdb-csl-symbian-6_4_50_20060226-11:1.23
	binutils-csl-renesas-4_1-8:1.23
	binutils-csl-renesas-4_1-7:1.23
	binutils-csl-renesas-4_1-6:1.23
	gdb-csl-sourcerygxx-4_1-17:1.23
	binutils-csl-sourcerygxx-4_1-17:1.23
	gdb-csl-20060226-branch-local-2:1.23
	cr-0x5f1:1.23.0.28
	gdb-csl-sourcerygxx-4_1-14:1.23
	binutils-csl-sourcerygxx-4_1-14:1.23
	binutils-csl-sourcerygxx-4_1-15:1.23
	gdb-csl-sourcerygxx-4_1-13:1.23
	binutils-csl-sourcerygxx-4_1-13:1.23
	binutils-2_17:1.23
	gdb-csl-sourcerygxx-4_1-12:1.23
	binutils-csl-sourcerygxx-4_1-12:1.23
	gdb-csl-sourcerygxx-3_4_4-21:1.23
	binutils-csl-sourcerygxx-3_4_4-21:1.23
	gdb_6_5-20060621-release:1.23
	binutils-csl-wrs-linux-3_4_4-24:1.21
	binutils-csl-wrs-linux-3_4_4-23:1.21
	gdb-csl-sourcerygxx-4_1-9:1.23
	binutils-csl-sourcerygxx-4_1-9:1.23
	gdb-csl-sourcerygxx-4_1-8:1.23
	binutils-csl-sourcerygxx-4_1-8:1.23
	gdb-csl-sourcerygxx-4_1-7:1.23
	binutils-csl-sourcerygxx-4_1-7:1.23
	gdb-csl-arm-2006q1-6:1.23
	binutils-csl-arm-2006q1-6:1.23
	gdb-csl-sourcerygxx-4_1-6:1.23
	binutils-csl-sourcerygxx-4_1-6:1.23
	binutils-csl-wrs-linux-3_4_4-22:1.21
	gdb-csl-symbian-6_4_50_20060226-10:1.23
	gdb-csl-symbian-6_4_50_20060226-9:1.23
	gdb-csl-symbian-6_4_50_20060226-8:1.23
	gdb-csl-coldfire-4_1-11:1.23
	binutils-csl-coldfire-4_1-11:1.23
	gdb-csl-sourcerygxx-3_4_4-19:1.23
	binutils-csl-sourcerygxx-3_4_4-19:1.23
	gdb-csl-coldfire-4_1-10:1.23
	gdb_6_5-branch:1.23.0.26
	gdb_6_5-2006-05-14-branchpoint:1.23
	binutils-csl-coldfire-4_1-10:1.23
	gdb-csl-sourcerygxx-4_1-5:1.23
	binutils-csl-sourcerygxx-4_1-5:1.23
	nickrob-async-20060513-branch:1.23.0.24
	nickrob-async-20060513-branchpoint:1.23
	gdb-csl-sourcerygxx-4_1-4:1.23
	binutils-csl-sourcerygxx-4_1-4:1.23
	msnyder-reverse-20060502-branch:1.23.0.22
	msnyder-reverse-20060502-branchpoint:1.23
	binutils-csl-wrs-linux-3_4_4-21:1.21
	gdb-csl-morpho-4_1-4:1.23
	binutils-csl-morpho-4_1-4:1.23
	gdb-csl-sourcerygxx-3_4_4-17:1.23
	binutils-csl-sourcerygxx-3_4_4-17:1.23
	binutils-csl-wrs-linux-3_4_4-20:1.21
	readline_5_1-import-branch:1.23.0.20
	readline_5_1-import-branchpoint:1.23
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.23
	binutils-2_17-branch:1.23.0.18
	binutils-2_17-branchpoint:1.23
	gdb-csl-symbian-20060226-branch:1.23.0.16
	gdb-csl-symbian-20060226-branchpoint:1.23
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.23
	msnyder-reverse-20060331-branch:1.23.0.14
	msnyder-reverse-20060331-branchpoint:1.23
	binutils-csl-2_17-branch:1.23.0.12
	binutils-csl-2_17-branchpoint:1.23
	gdb-csl-available-20060303-branch:1.23.0.10
	gdb-csl-available-20060303-branchpoint:1.23
	gdb-csl-20060226-branch:1.23.0.8
	gdb-csl-20060226-branchpoint:1.23
	gdb_6_4-20051202-release:1.23
	msnyder-fork-checkpoint-branch:1.23.0.6
	msnyder-fork-checkpoint-branchpoint:1.23
	gdb-csl-gxxpro-6_3-branch:1.23.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.23
	gdb_6_4-branch:1.23.0.2
	gdb_6_4-2005-11-01-branchpoint:1.23
	gdb-csl-arm-20051020-branch:1.22.0.4
	gdb-csl-arm-20051020-branchpoint:1.22
	binutils-csl-gxxpro-3_4-branch:1.21.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.21
	binutils-2_16_1:1.21
	msnyder-tracepoint-checkpoint-branch:1.22.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.22
	gdb-csl-arm-20050325-2005-q1b:1.21
	binutils-csl-arm-2005q1b:1.21
	binutils-2_16:1.21
	gdb-csl-arm-20050325-2005-q1a:1.21
	binutils-csl-arm-2005q1a:1.21
	csl-arm-20050325-branch:1.21.0.6
	csl-arm-20050325-branchpoint:1.21
	binutils-csl-arm-2005q1-branch:1.21.0.4
	binutils-csl-arm-2005q1-branchpoint:1.21
	binutils-2_16-branch:1.21.0.2
	binutils-2_16-branchpoint:1.21
	csl-arm-2004-q3d:1.19
	gdb_6_3-20041109-release:1.19
	gdb_6_3-branch:1.19.0.24
	gdb_6_3-20041019-branchpoint:1.19
	csl-arm-2004-q3:1.19
	drow_intercu-merge-20040921:1.19
	drow_intercu-merge-20040915:1.19
	jimb-gdb_6_2-e500-branch:1.19.0.26
	jimb-gdb_6_2-e500-branchpoint:1.19
	gdb_6_2-20040730-release:1.19
	gdb_6_2-branch:1.19.0.22
	gdb_6_2-2004-07-10-gmt-branchpoint:1.19
	gdb_6_1_1-20040616-release:1.19
	binutils-2_15:1.19
	binutils-2_15-branchpoint:1.19
	csl-arm-2004-q1a:1.19
	csl-arm-2004-q1:1.19
	gdb_6_1-2004-04-05-release:1.19
	drow_intercu-merge-20040402:1.19
	drow_intercu-merge-20040327:1.19
	ezannoni_pie-20040323-branch:1.19.0.20
	ezannoni_pie-20040323-branchpoint:1.19
	cagney_tramp-20040321-mergepoint:1.19
	cagney_tramp-20040309-branch:1.19.0.18
	cagney_tramp-20040309-branchpoint:1.19
	gdb_6_1-branch:1.19.0.16
	gdb_6_1-2004-03-01-gmt-branchpoint:1.19
	drow_intercu-20040221-branch:1.19.0.14
	drow_intercu-20040221-branchpoint:1.19
	binutils-2_15-branch:1.19.0.12
	cagney_bfdfile-20040213-branch:1.19.0.10
	cagney_bfdfile-20040213-branchpoint:1.19
	drow-cplus-merge-20040208:1.19
	carlton_dictionary-20040126-merge:1.19
	cagney_bigcore-20040122-branch:1.19.0.8
	cagney_bigcore-20040122-branchpoint:1.19
	drow-cplus-merge-20040113:1.19
	csl-arm-2003-q4:1.19
	drow-cplus-merge-20031224:1.19
	drow-cplus-merge-20031220:1.19
	carlton_dictionary-20031215-merge:1.19
	drow-cplus-merge-20031214:1.19
	carlton-dictionary-20031111-merge:1.19
	gdb_6_0-2003-10-04-release:1.18
	kettenis_sparc-20030918-branch:1.19.0.6
	kettenis_sparc-20030918-branchpoint:1.19
	carlton_dictionary-20030917-merge:1.19
	ezannoni_pie-20030916-branchpoint:1.19
	ezannoni_pie-20030916-branch:1.19.0.4
	cagney_x86i386-20030821-branch:1.19.0.2
	cagney_x86i386-20030821-branchpoint:1.19
	carlton_dictionary-20030805-merge:1.18
	carlton_dictionary-20030627-merge:1.18
	gdb_6_0-branch:1.18.0.36
	gdb_6_0-2003-06-23-branchpoint:1.18
	jimb-ppc64-linux-20030613-branch:1.18.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.18
	binutils-2_14:1.18
	cagney_convert-20030606-branch:1.18.0.32
	cagney_convert-20030606-branchpoint:1.18
	cagney_writestrings-20030508-branch:1.18.0.30
	cagney_writestrings-20030508-branchpoint:1.18
	jimb-ppc64-linux-20030528-branch:1.18.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.18
	carlton_dictionary-20030523-merge:1.18
	cagney_fileio-20030521-branch:1.18.0.26
	cagney_fileio-20030521-branchpoint:1.18
	kettenis_i386newframe-20030517-mergepoint:1.18
	jimb-ppc64-linux-20030509-branch:1.18.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.18
	kettenis_i386newframe-20030504-mergepoint:1.18
	carlton_dictionary-20030430-merge:1.18
	binutils-2_14-branch:1.18.0.22
	binutils-2_14-branchpoint:1.18
	kettenis_i386newframe-20030419-branch:1.18.0.20
	kettenis_i386newframe-20030419-branchpoint:1.18
	carlton_dictionary-20030416-merge:1.18
	cagney_frameaddr-20030409-mergepoint:1.18
	kettenis_i386newframe-20030406-branch:1.18.0.18
	kettenis_i386newframe-20030406-branchpoint:1.18
	cagney_frameaddr-20030403-branchpoint:1.18
	cagney_frameaddr-20030403-branch:1.18.0.16
	cagney_framebase-20030330-mergepoint:1.18
	cagney_framebase-20030326-branch:1.18.0.14
	cagney_framebase-20030326-branchpoint:1.18
	cagney_lazyid-20030317-branch:1.18.0.12
	cagney_lazyid-20030317-branchpoint:1.18
	kettenis-i386newframe-20030316-mergepoint:1.18
	offbyone-20030313-branch:1.18.0.10
	offbyone-20030313-branchpoint:1.18
	kettenis-i386newframe-20030308-branch:1.18.0.8
	kettenis-i386newframe-20030308-branchpoint:1.18
	carlton_dictionary-20030305-merge:1.18
	cagney_offbyone-20030303-branch:1.18.0.6
	cagney_offbyone-20030303-branchpoint:1.18
	w32api-2_2:1.18
	mingw-runtime-2_4:1.18
	carlton_dictionary-20030207-merge:1.18
	interps-20030202-branch:1.18.0.4
	interps-20030202-branchpoint:1.18
	cagney-unwind-20030108-branch:1.18.0.2
	cagney-unwind-20030108-branchpoint:1.18
	binutils-2_13_2_1:1.16
	binutils-2_13_2:1.16
	carlton_dictionary-20021223-merge:1.18
	gdb_5_3-2002-12-12-release:1.16
	carlton_dictionary-20021115-merge:1.17
	binutils-2_13_1:1.16
	kseitz_interps-20021105-merge:1.17
	kseitz_interps-20021103-merge:1.17
	drow-cplus-merge-20021020:1.17
	drow-cplus-merge-20021025:1.17
	carlton_dictionary-20021025-merge:1.17
	carlton_dictionary-20021011-merge:1.16
	drow-cplus-branch:1.16.0.24
	drow-cplus-branchpoint:1.16
	kseitz_interps-20020930-merge:1.16
	carlton_dictionary-20020927-merge:1.16
	carlton_dictionary-branch:1.16.0.22
	carlton_dictionary-20020920-branchpoint:1.16
	sid-20020905-branchpoint:1.16
	sid-20020905-branch:1.16.0.20
	gdb_5_3-branch:1.16.0.18
	gdb_5_3-2002-09-04-branchpoint:1.16
	kseitz_interps-20020829-merge:1.16
	cagney_sysregs-20020825-branch:1.16.0.16
	cagney_sysregs-20020825-branchpoint:1.16
	readline_4_3-import-branch:1.16.0.14
	readline_4_3-import-branchpoint:1.16
	binutils-2_13:1.16
	gdb_5_2_1-2002-07-23-release:1.16
	binutils-2_13-branchpoint:1.16
	binutils-2_13-branch:1.16.0.12
	kseitz_interps-20020528-branch:1.16.0.10
	kseitz_interps-20020528-branchpoint:1.16
	cagney_regbuf-20020515-branch:1.16.0.8
	cagney_regbuf-20020515-branchpoint:1.16
	binutils-2_12_1:1.16
	jimb-macro-020506-branch:1.16.0.6
	jimb-macro-020506-branchpoint:1.16
	gdb_5_2-2002-04-29-release:1.16
	binutils-2_12:1.16
	gdb_5_2-branch:1.16.0.4
	gdb_5_2-2002-03-03-branchpoint:1.16
	binutils-2_12-branch:1.16.0.2
	binutils-2_12-branchpoint:1.16
	gdb_5_1_1-2002-01-24-release:1.14
	gdb_5_1_0_1-2002-01-03-release:1.14
	cygnus_cvs_20020108_pre:1.14
	gdb_5_1_0_1-2002-01-03-branch:1.14.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.14
	gdb_5_1-2001-11-21-release:1.14
	gdb_s390-2001-09-26-branch:1.14.0.4
	gdb_s390-2001-09-26-branchpoint:1.14
	gdb_5_1-2001-07-29-branch:1.14.0.2
	gdb_5_1-2001-07-29-branchpoint:1.14
	binutils-2_11_2:1.8.2.1
	binutils-2_11_1:1.8.2.1
	binutils-2_11:1.8
	x86_64versiong3:1.9
	binutils-2_11-branch:1.8.0.2
	insight-precleanup-2001-01-01:1.7
	binutils-2_10_1:1.4
	binutils-2_10:1.4
	gdb-premipsmulti-2000-06-06-branch:1.5.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.5
	gdb_5_0-2000-05-19-release:1.4
	gdb_4_18_2-2000-05-18-release:1.4
	gdb_4_95_1-2000-05-11-snapshot:1.4
	gdb_4_95_0-2000-04-27-snapshot:1.4
	gdb_5_0-2000-04-10-branch:1.4.0.4
	gdb_5_0-2000-04-10-branchpoint:1.4
	binutils-2_10-branch:1.4.0.2
	binutils-2_10-branchpoint:1.4
	binutils_latest_snapshot:1.27
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2010.10.09.06.50.21;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2010.04.15.10.26.09;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2009.11.23.03.56.28;	author devans;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.24.00.17.07;	author devans;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.28.19.38.59;	author brolley;	state Exp;
branches
	1.23.54.1
	1.23.64.1;
next	1.22;

1.22
date	2005.05.10.10.21.12;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2005.03.03.11.58.09;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2005.01.25.20.22.35;	author aoliva;	state Exp;
branches;
next	1.19;

1.19
date	2003.08.08.21.21.24;	author meissner;	state Exp;
branches;
next	1.18;

1.18
date	2002.12.02.21.51.52;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2002.10.14.10.55.14;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.28.19.15.46;	author obrien;	state Exp;
branches
	1.16.10.1
	1.16.22.1
	1.16.24.1;
next	1.15;

1.15
date	2002.01.22.21.45.33;	author graydon;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.12.21.20.59;	author jjohnstn;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.12.02.32.25;	author fche;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.14.20.38.42;	author geoffk;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.23.15.34.43;	author jhealy;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.14.02.27.44;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.02.23.04.39;	author patrickm;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.09.17.01.07;	author jjohnstn;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.07.26.22.44.42;	author brolley;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.19.01.22.42;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.16.19.28.07;	author fche;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.24.23.57.23;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.24.21.56.53;	author aph;	state Exp;
branches;
next	1.2;

1.2
date	99.08.19.05.45.30;	author devans;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.05;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.23.54.1
date	2009.03.09.20.36.11;	author amylaar;	state Exp;
branches;
next	;

1.23.64.1
date	2009.09.10.15.09.41;	author amylaar;	state Exp;
branches;
next	;

1.16.10.1
date	2002.11.03.21.52.24;	author ezannoni;	state Exp;
branches;
next	;

1.16.22.1
date	2002.10.25.23.49.59;	author carlton;	state Exp;
branches;
next	1.16.22.2;

1.16.22.2
date	2002.12.23.19.39.25;	author carlton;	state Exp;
branches;
next	1.16.22.3;

1.16.22.3
date	2003.09.17.21.28.55;	author carlton;	state Exp;
branches;
next	;

1.16.24.1
date	2002.10.26.17.12.27;	author drow;	state Exp;
branches;
next	1.16.24.2;

1.16.24.2
date	2003.12.14.20.28.01;	author drow;	state Exp;
branches;
next	;

1.8.2.1
date	2001.06.07.03.21.40;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.05;	author rth;	state Exp;
branches;
next	;


desc
@@


1.27
log
@cgen/
	* utils-cgen.scm (gen-attr-accessors): Rename bool attribute to bool_.
	* cpu/mep.opc (mep_cgen_insn_supported): Ditto.
include/opcode/
	* cgen.h (CGEN_ATTR, CGEN_ATTR_TYPE): Rename bool attribute to bool_.
	(CGEN_ATTR_BOOLS, CGEN_ATTR_CGEN_INSN_ALIAS_VALUE): Likewise.

opcodes/
	* fr30-desc.h: Regenerate.
	* frv-desc.h: Regenerate.
	* ip2k-desc.h: Regenerate.
	* iq2000-desc.h: Regenerate.
	* lm32-desc.h: Regenerate.
	* m32c-desc.h: Regenerate.
	* m32r-desc.h: Regenerate.
	* mep-desc.h: Regenerate.
	* mep-opc.c: Regenerate.
	* mt-desc.h: Regenerate.
	* openrisc-desc.h: Regenerate.
	* xc16x-desc.h: Regenerate.
	* xstormy16-desc.h: Regenerate.
@
text
@/* Header file for targets using CGEN: Cpu tools GENerator.

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2009, 2010
   Free Software Foundation, Inc.

   This file is part of GDB, the GNU debugger, and the GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License along
   with this program; if not, write to the Free Software Foundation, Inc.,
   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */

#ifndef OPCODE_CGEN_H
#define OPCODE_CGEN_H

#include "symcat.h"
#include "cgen/bitset.h"

/* ??? IWBN to replace bfd in the name.  */
#include "bfd_stdint.h"

/* ??? This file requires bfd.h but only to get bfd_vma.
   Seems like an awful lot to require just to get such a fundamental type.
   Perhaps the definition of bfd_vma can be moved outside of bfd.h.
   Or perhaps one could duplicate its definition in another file.
   Until such time, this file conditionally compiles definitions that require
   bfd_vma using __BFD_H_SEEN__.  */

/* Enums must be defined before they can be used.
   Allow them to be used in struct definitions, even though the enum must
   be defined elsewhere.
   If CGEN_ARCH isn't defined, this file is being included by something other
   than <arch>-desc.h.  */

/* Prepend the arch name, defined in <arch>-desc.h, and _cgen_ to symbol S.
   The lack of spaces in the arg list is important for non-stdc systems.
   This file is included by <arch>-desc.h.
   It can be included independently of <arch>-desc.h, in which case the arch
   dependent portions will be declared as "unknown_cgen_foo".  */

#ifndef CGEN_SYM
#define CGEN_SYM(s) CONCAT3 (unknown,_cgen_,s)
#endif

/* This file contains the static (unchanging) pieces and as much other stuff
   as we can reasonably put here.  It's generally cleaner to put stuff here
   rather than having it machine generated if possible.  */

/* The assembler syntax is made up of expressions (duh...).
   At the lowest level the values are mnemonics, register names, numbers, etc.
   Above that are subexpressions, if any (an example might be the
   "effective address" in m68k cpus).  Subexpressions are wip.
   At the second highest level are the insns themselves.  Above that are
   pseudo-insns, synthetic insns, and macros, if any.  */

/* Lots of cpu's have a fixed insn size, or one which rarely changes,
   and it's generally easier to handle these by treating the insn as an
   integer type, rather than an array of characters.  So we allow targets
   to control this.  When an integer type the value is in host byte order,
   when an array of characters the value is in target byte order.  */

typedef unsigned int CGEN_INSN_INT;
typedef int64_t CGEN_INSN_LGSINT; /* large/long SINT */
typedef uint64_t CGEN_INSN_LGUINT; /* large/long UINT */

#if CGEN_INT_INSN_P
typedef CGEN_INSN_INT CGEN_INSN_BYTES;
typedef CGEN_INSN_INT *CGEN_INSN_BYTES_PTR;
#else
typedef unsigned char *CGEN_INSN_BYTES;
typedef unsigned char *CGEN_INSN_BYTES_PTR;
#endif

#ifdef __GNUC__
#define CGEN_INLINE __inline__
#else
#define CGEN_INLINE
#endif

enum cgen_endian
{
  CGEN_ENDIAN_UNKNOWN,
  CGEN_ENDIAN_LITTLE,
  CGEN_ENDIAN_BIG
};

/* Forward decl.  */

typedef struct cgen_insn CGEN_INSN;

/* Opaque pointer version for use by external world.  */

typedef struct cgen_cpu_desc *CGEN_CPU_DESC;

/* Attributes.
   Attributes are used to describe various random things associated with
   an object (ifield, hardware, operand, insn, whatever) and are specified
   as name/value pairs.
   Integer attributes computed at compile time are currently all that's
   supported, though adding string attributes and run-time computation is
   straightforward.  Integer attribute values are always host int's
   (signed or unsigned).  For portability, this means 32 bits.
   Integer attributes are further categorized as boolean, bitset, integer,
   and enum types.  Boolean attributes appear frequently enough that they're
   recorded in one host int.  This limits the maximum number of boolean
   attributes to 32, though that's a *lot* of attributes.  */

/* Type of attribute values.  */

typedef CGEN_BITSET     CGEN_ATTR_VALUE_BITSET_TYPE;
typedef int             CGEN_ATTR_VALUE_ENUM_TYPE;
typedef union
{
  CGEN_ATTR_VALUE_BITSET_TYPE bitset;
  CGEN_ATTR_VALUE_ENUM_TYPE   nonbitset;
} CGEN_ATTR_VALUE_TYPE;

/* Struct to record attribute information.  */

typedef struct
{
  /* Boolean attributes.  */
  unsigned int bool_;
  /* Non-boolean integer attributes.  */
  CGEN_ATTR_VALUE_TYPE nonbool[1];
} CGEN_ATTR;

/* Define a structure member for attributes with N non-boolean entries.
   There is no maximum number of non-boolean attributes.
   There is a maximum of 32 boolean attributes (since they are all recorded
   in one host int).  */

#define CGEN_ATTR_TYPE(n) \
struct { unsigned int bool_; \
	 CGEN_ATTR_VALUE_TYPE nonbool[(n) ? (n) : 1]; }

/* Return the boolean attributes.  */

#define CGEN_ATTR_BOOLS(a) ((a)->bool_)

/* Non-boolean attribute numbers are offset by this much.  */

#define CGEN_ATTR_NBOOL_OFFSET 32

/* Given a boolean attribute number, return its mask.  */

#define CGEN_ATTR_MASK(attr) (1 << (attr))

/* Return the value of boolean attribute ATTR in ATTRS.  */

#define CGEN_BOOL_ATTR(attrs, attr) ((CGEN_ATTR_MASK (attr) & (attrs)) != 0)

/* Return value of attribute ATTR in ATTR_TABLE for OBJ.
   OBJ is a pointer to the entity that has the attributes
   (??? not used at present but is reserved for future purposes - eventually
   the goal is to allow recording attributes in source form and computing
   them lazily at runtime, not sure of the details yet).  */

#define CGEN_ATTR_VALUE(obj, attr_table, attr) \
((unsigned int) (attr) < CGEN_ATTR_NBOOL_OFFSET \
 ? ((CGEN_ATTR_BOOLS (attr_table) & CGEN_ATTR_MASK (attr)) != 0) \
 : ((attr_table)->nonbool[(attr) - CGEN_ATTR_NBOOL_OFFSET].nonbitset))
#define CGEN_BITSET_ATTR_VALUE(obj, attr_table, attr) \
 ((attr_table)->nonbool[(attr) - CGEN_ATTR_NBOOL_OFFSET].bitset)

/* Attribute name/value tables.
   These are used to assist parsing of descriptions at run-time.  */

typedef struct
{
  const char * name;
  unsigned value;
} CGEN_ATTR_ENTRY;

/* For each domain (ifld,hw,operand,insn), list of attributes.  */

typedef struct
{
  const char * name;
  const CGEN_ATTR_ENTRY * dfault;
  const CGEN_ATTR_ENTRY * vals;
} CGEN_ATTR_TABLE;

/* Instruction set variants.  */

typedef struct {
  const char *name;

  /* Default instruction size (in bits).
     This is used by the assembler when it encounters an unknown insn.  */
  unsigned int default_insn_bitsize;

  /* Base instruction size (in bits).
     For non-LIW cpus this is generally the length of the smallest insn.
     For LIW cpus its wip (work-in-progress).  For the m32r its 32.  */
  unsigned int base_insn_bitsize;

  /* Minimum/maximum instruction size (in bits).  */
  unsigned int min_insn_bitsize;
  unsigned int max_insn_bitsize;
} CGEN_ISA;

/* Machine variants.  */

typedef struct {
  const char *name;
  /* The argument to bfd_arch_info->scan.  */
  const char *bfd_name;
  /* one of enum mach_attr */
  int num;
  /* parameter from mach->cpu */
  unsigned int insn_chunk_bitsize;
} CGEN_MACH;

/* Parse result (also extraction result).

   The result of parsing an insn is stored here.
   To generate the actual insn, this is passed to the insert handler.
   When printing an insn, the result of extraction is stored here.
   To print the insn, this is passed to the print handler.

   It is machine generated so we don't define it here,
   but we do need a forward decl for the handler fns.

   There is one member for each possible field in the insn.
   The type depends on the field.
   Also recorded here is the computed length of the insn for architectures
   where it varies.
*/

typedef struct cgen_fields CGEN_FIELDS;

/* Total length of the insn, as recorded in the `fields' struct.  */
/* ??? The field insert handler has lots of opportunities for optimization
   if it ever gets inlined.  On architectures where insns all have the same
   size, may wish to detect that and make this macro a constant - to allow
   further optimizations.  */

#define CGEN_FIELDS_BITSIZE(fields) ((fields)->length)

/* Extraction support for variable length insn sets.  */

/* When disassembling we don't know the number of bytes to read at the start.
   So the first CGEN_BASE_INSN_SIZE bytes are read at the start and the rest
   are read when needed.  This struct controls this.  It is basically the
   disassemble_info stuff, except that we provide a cache for values already
   read (since bytes can typically be read several times to fetch multiple
   operands that may be in them), and that extraction of fields is needed
   in contexts other than disassembly.  */

typedef struct {
  /* A pointer to the disassemble_info struct.
     We don't require dis-asm.h so we use void * for the type here.
     If NULL, BYTES is full of valid data (VALID == -1).  */
  void *dis_info;
  /* Points to a working buffer of sufficient size.  */
  unsigned char *insn_bytes;
  /* Mask of bytes that are valid in INSN_BYTES.  */
  unsigned int valid;
} CGEN_EXTRACT_INFO;

/* Associated with each insn or expression is a set of "handlers" for
   performing operations like parsing, printing, etc.  These require a bfd_vma
   value to be passed around but we don't want all applications to need bfd.h.
   So this stuff is only provided if bfd.h has been included.  */

/* Parse handler.
   CD is a cpu table descriptor.
   INSN is a pointer to a struct describing the insn being parsed.
   STRP is a pointer to a pointer to the text being parsed.
   FIELDS is a pointer to a cgen_fields struct in which the results are placed.
   If the expression is successfully parsed, *STRP is updated.
   If not it is left alone.
   The result is NULL if success or an error message.  */
typedef const char * (cgen_parse_fn)
  (CGEN_CPU_DESC, const CGEN_INSN *insn_,
   const char **strp_, CGEN_FIELDS *fields_);

/* Insert handler.
   CD is a cpu table descriptor.
   INSN is a pointer to a struct describing the insn being parsed.
   FIELDS is a pointer to a cgen_fields struct from which the values
   are fetched.
   INSNP is a pointer to a buffer in which to place the insn.
   PC is the pc value of the insn.
   The result is an error message or NULL if success.  */

#ifdef __BFD_H_SEEN__
typedef const char * (cgen_insert_fn)
  (CGEN_CPU_DESC, const CGEN_INSN *insn_,
   CGEN_FIELDS *fields_, CGEN_INSN_BYTES_PTR insnp_,
   bfd_vma pc_);
#else
typedef const char * (cgen_insert_fn) ();
#endif

/* Extract handler.
   CD is a cpu table descriptor.
   INSN is a pointer to a struct describing the insn being parsed.
   The second argument is a pointer to a struct controlling extraction
   (only used for variable length insns).
   EX_INFO is a pointer to a struct for controlling reading of further
   bytes for the insn.
   BASE_INSN is the first CGEN_BASE_INSN_SIZE bytes (host order).
   FIELDS is a pointer to a cgen_fields struct in which the results are placed.
   PC is the pc value of the insn.
   The result is the length of the insn in bits or zero if not recognized.  */

#ifdef __BFD_H_SEEN__
typedef int (cgen_extract_fn)
  (CGEN_CPU_DESC, const CGEN_INSN *insn_,
   CGEN_EXTRACT_INFO *ex_info_, CGEN_INSN_INT base_insn_,
   CGEN_FIELDS *fields_, bfd_vma pc_);
#else
typedef int (cgen_extract_fn) ();
#endif

/* Print handler.
   CD is a cpu table descriptor.
   INFO is a pointer to the disassembly info.
   Eg: disassemble_info.  It's defined as `PTR' so this file can be included
   without dis-asm.h.
   INSN is a pointer to a struct describing the insn being printed.
   FIELDS is a pointer to a cgen_fields struct.
   PC is the pc value of the insn.
   LEN is the length of the insn, in bits.  */

#ifdef __BFD_H_SEEN__
typedef void (cgen_print_fn)
  (CGEN_CPU_DESC, void * info_, const CGEN_INSN *insn_,
   CGEN_FIELDS *fields_, bfd_vma pc_, int len_);
#else
typedef void (cgen_print_fn) ();
#endif

/* Parse/insert/extract/print handlers.

   Indices into the handler tables.
   We could use pointers here instead, but 90% of them are generally identical
   and that's a lot of redundant data.  Making these unsigned char indices
   into tables of pointers saves a bit of space.
   Using indices also keeps assembler code out of the disassembler and
   vice versa.  */

struct cgen_opcode_handler
{
  unsigned char parse, insert, extract, print;
};

/* Assembler interface.

   The interface to the assembler is intended to be clean in the sense that
   libopcodes.a is a standalone entity and could be used with any assembler.
   Not that one would necessarily want to do that but rather that it helps
   keep a clean interface.  The interface will obviously be slanted towards
   GAS, but at least it's a start.
   ??? Note that one possible user of the assembler besides GAS is GDB.

   Parsing is controlled by the assembler which calls
   CGEN_SYM (assemble_insn).  If it can parse and build the entire insn
   it doesn't call back to the assembler.  If it needs/wants to call back
   to the assembler, cgen_parse_operand_fn is called which can either

   - return a number to be inserted in the insn
   - return a "register" value to be inserted
     (the register might not be a register per pe)
   - queue the argument and return a marker saying the expression has been
     queued (eg: a fix-up)
   - return an error message indicating the expression wasn't recognizable

   The result is an error message or NULL for success.
   The parsed value is stored in the bfd_vma *.  */

/* Values for indicating what the caller wants.  */

enum cgen_parse_operand_type
{
  CGEN_PARSE_OPERAND_INIT,
  CGEN_PARSE_OPERAND_INTEGER,
  CGEN_PARSE_OPERAND_ADDRESS,
  CGEN_PARSE_OPERAND_SYMBOLIC
};

/* Values for indicating what was parsed.  */

enum cgen_parse_operand_result
{
  CGEN_PARSE_OPERAND_RESULT_NUMBER,
  CGEN_PARSE_OPERAND_RESULT_REGISTER,
  CGEN_PARSE_OPERAND_RESULT_QUEUED,
  CGEN_PARSE_OPERAND_RESULT_ERROR
};

#ifdef __BFD_H_SEEN__ /* Don't require bfd.h unnecessarily.  */
typedef const char * (cgen_parse_operand_fn)
  (CGEN_CPU_DESC,
   enum cgen_parse_operand_type, const char **, int, int,
   enum cgen_parse_operand_result *, bfd_vma *);
#else
typedef const char * (cgen_parse_operand_fn) ();
#endif

/* Set the cgen_parse_operand_fn callback.  */

extern void cgen_set_parse_operand_fn
  (CGEN_CPU_DESC, cgen_parse_operand_fn);

/* Called before trying to match a table entry with the insn.  */

extern void cgen_init_parse_operand (CGEN_CPU_DESC);

/* Operand values (keywords, integers, symbols, etc.)  */

/* Types of assembler elements.  */

enum cgen_asm_type
{
  CGEN_ASM_NONE, CGEN_ASM_KEYWORD, CGEN_ASM_MAX
};

#ifndef CGEN_ARCH
enum cgen_hw_type { CGEN_HW_MAX };
#endif

/* List of hardware elements.  */

typedef struct
{
  char *name;
  enum cgen_hw_type type;
  /* There is currently no example where both index specs and value specs
     are required, so for now both are clumped under "asm_data".  */
  enum cgen_asm_type asm_type;
  void *asm_data;
#ifndef CGEN_HW_NBOOL_ATTRS
#define CGEN_HW_NBOOL_ATTRS 1
#endif
  CGEN_ATTR_TYPE (CGEN_HW_NBOOL_ATTRS) attrs;
#define CGEN_HW_ATTRS(hw) (&(hw)->attrs)
} CGEN_HW_ENTRY;

/* Return value of attribute ATTR in HW.  */

#define CGEN_HW_ATTR_VALUE(hw, attr) \
CGEN_ATTR_VALUE ((hw), CGEN_HW_ATTRS (hw), (attr))

/* Table of hardware elements for selected mach, computed at runtime.
   enum cgen_hw_type is an index into this table (specifically `entries').  */

typedef struct {
  /* Pointer to null terminated table of all compiled in entries.  */
  const CGEN_HW_ENTRY *init_entries;
  unsigned int entry_size; /* since the attribute member is variable sized */
  /* Array of all entries, initial and run-time added.  */
  const CGEN_HW_ENTRY **entries;
  /* Number of elements in `entries'.  */
  unsigned int num_entries;
  /* For now, xrealloc is called each time a new entry is added at runtime.
     ??? May wish to keep track of some slop to reduce the number of calls to
     xrealloc, except that there's unlikely to be many and not expected to be
     in speed critical code.  */
} CGEN_HW_TABLE;

extern const CGEN_HW_ENTRY * cgen_hw_lookup_by_name
  (CGEN_CPU_DESC, const char *);
extern const CGEN_HW_ENTRY * cgen_hw_lookup_by_num
  (CGEN_CPU_DESC, unsigned int);

/* This struct is used to describe things like register names, etc.  */

typedef struct cgen_keyword_entry
{
  /* Name (as in register name).  */
  char * name;

  /* Value (as in register number).
     The value cannot be -1 as that is used to indicate "not found".
     IDEA: Have "FUNCTION" attribute? [function is called to fetch value].  */
  int value;

  /* Attributes.
     This should, but technically needn't, appear last.  It is a variable sized
     array in that one architecture may have 1 nonbool attribute and another
     may have more.  Having this last means the non-architecture specific code
     needn't care.  The goal is to eventually record
     attributes in their raw form, evaluate them at run-time, and cache the
     values, so this worry will go away anyway.  */
  /* ??? Moving this last should be done by treating keywords like insn lists
     and moving the `next' fields into a CGEN_KEYWORD_LIST struct.  */
  /* FIXME: Not used yet.  */
#ifndef CGEN_KEYWORD_NBOOL_ATTRS
#define CGEN_KEYWORD_NBOOL_ATTRS 1
#endif
  CGEN_ATTR_TYPE (CGEN_KEYWORD_NBOOL_ATTRS) attrs;

  /* ??? Putting these here means compiled in entries can't be const.
     Not a really big deal, but something to consider.  */
  /* Next name hash table entry.  */
  struct cgen_keyword_entry *next_name;
  /* Next value hash table entry.  */
  struct cgen_keyword_entry *next_value;
} CGEN_KEYWORD_ENTRY;

/* Top level struct for describing a set of related keywords
   (e.g. register names).

   This struct supports run-time entry of new values, and hashed lookups.  */

typedef struct cgen_keyword
{
  /* Pointer to initial [compiled in] values.  */
  CGEN_KEYWORD_ENTRY *init_entries;
  
  /* Number of entries in `init_entries'.  */
  unsigned int num_init_entries;
  
  /* Hash table used for name lookup.  */
  CGEN_KEYWORD_ENTRY **name_hash_table;
  
  /* Hash table used for value lookup.  */
  CGEN_KEYWORD_ENTRY **value_hash_table;
  
  /* Number of entries in the hash_tables.  */
  unsigned int hash_table_size;
  
  /* Pointer to null keyword "" entry if present.  */
  const CGEN_KEYWORD_ENTRY *null_entry;

  /* String containing non-alphanumeric characters used
     in keywords.  
     At present, the highest number of entries used is 1.  */
  char nonalpha_chars[8];
} CGEN_KEYWORD;

/* Structure used for searching.  */

typedef struct
{
  /* Table being searched.  */
  const CGEN_KEYWORD *table;
  
  /* Specification of what is being searched for.  */
  const char *spec;
  
  /* Current index in hash table.  */
  unsigned int current_hash;
  
  /* Current element in current hash chain.  */
  CGEN_KEYWORD_ENTRY *current_entry;
} CGEN_KEYWORD_SEARCH;

/* Lookup a keyword from its name.  */

const CGEN_KEYWORD_ENTRY *cgen_keyword_lookup_name
  (CGEN_KEYWORD *, const char *);

/* Lookup a keyword from its value.  */

const CGEN_KEYWORD_ENTRY *cgen_keyword_lookup_value
  (CGEN_KEYWORD *, int);

/* Add a keyword.  */

void cgen_keyword_add (CGEN_KEYWORD *, CGEN_KEYWORD_ENTRY *);

/* Keyword searching.
   This can be used to retrieve every keyword, or a subset.  */

CGEN_KEYWORD_SEARCH cgen_keyword_search_init
  (CGEN_KEYWORD *, const char *);
const CGEN_KEYWORD_ENTRY *cgen_keyword_search_next
  (CGEN_KEYWORD_SEARCH *);

/* Operand value support routines.  */

extern const char *cgen_parse_keyword
  (CGEN_CPU_DESC, const char **, CGEN_KEYWORD *, long *);
#ifdef __BFD_H_SEEN__ /* Don't require bfd.h unnecessarily.  */
extern const char *cgen_parse_signed_integer
  (CGEN_CPU_DESC, const char **, int, long *);
extern const char *cgen_parse_unsigned_integer
  (CGEN_CPU_DESC, const char **, int, unsigned long *);
extern const char *cgen_parse_address
  (CGEN_CPU_DESC, const char **, int, int,
   enum cgen_parse_operand_result *, bfd_vma *);
extern const char *cgen_validate_signed_integer
  (long, long, long);
extern const char *cgen_validate_unsigned_integer
  (unsigned long, unsigned long, unsigned long);
#endif

/* Operand modes.  */

/* ??? This duplicates the values in arch.h.  Revisit.
   These however need the CGEN_ prefix [as does everything in this file].  */
/* ??? Targets may need to add their own modes so we may wish to move this
   to <arch>-opc.h, or add a hook.  */

enum cgen_mode {
  CGEN_MODE_VOID, /* ??? rename simulator's VM to VOID? */
  CGEN_MODE_BI, CGEN_MODE_QI, CGEN_MODE_HI, CGEN_MODE_SI, CGEN_MODE_DI,
  CGEN_MODE_UBI, CGEN_MODE_UQI, CGEN_MODE_UHI, CGEN_MODE_USI, CGEN_MODE_UDI,
  CGEN_MODE_SF, CGEN_MODE_DF, CGEN_MODE_XF, CGEN_MODE_TF,
  CGEN_MODE_TARGET_MAX,
  CGEN_MODE_INT, CGEN_MODE_UINT,
  CGEN_MODE_MAX
};

/* FIXME: Until simulator is updated.  */

#define CGEN_MODE_VM CGEN_MODE_VOID

/* Operands.  */

#ifndef CGEN_ARCH
enum cgen_operand_type { CGEN_OPERAND_MAX };
#endif

/* "nil" indicator for the operand instance table */
#define CGEN_OPERAND_NIL CGEN_OPERAND_MAX

/* A tree of these structs represents the multi-ifield
   structure of an operand's hw-index value, if it exists.  */

struct cgen_ifld;

typedef struct cgen_maybe_multi_ifield
{
  int count; /* 0: indexed by single cgen_ifld (possibly null: dead entry);
		n: indexed by array of more cgen_maybe_multi_ifields.  */
  union
  {
    const void *p;
    const struct cgen_maybe_multi_ifield * multi;
    const struct cgen_ifld * leaf;
  } val;
}
CGEN_MAYBE_MULTI_IFLD;

/* This struct defines each entry in the operand table.  */

typedef struct
{
  /* Name as it appears in the syntax string.  */
  char *name;

  /* Operand type.  */
  enum cgen_operand_type type;

  /* The hardware element associated with this operand.  */
  enum cgen_hw_type hw_type;

  /* FIXME: We don't yet record ifield definitions, which we should.
     When we do it might make sense to delete start/length (since they will
     be duplicated in the ifield's definition) and replace them with a
     pointer to the ifield entry.  */

  /* Bit position.
     This is just a hint, and may be unused in more complex operands.
     May be unused for a modifier.  */
  unsigned char start;

  /* The number of bits in the operand.
     This is just a hint, and may be unused in more complex operands.
     May be unused for a modifier.  */
  unsigned char length;

  /* The (possibly-multi) ifield used as an index for this operand, if it
     is indexed by a field at all. This substitutes / extends the start and
     length fields above, but unsure at this time whether they are used
     anywhere.  */
  CGEN_MAYBE_MULTI_IFLD index_fields;
#if 0 /* ??? Interesting idea but relocs tend to get too complicated,
	 and ABI dependent, for simple table lookups to work.  */
  /* Ideally this would be the internal (external?) reloc type.  */
  int reloc_type;
#endif

  /* Attributes.
     This should, but technically needn't, appear last.  It is a variable sized
     array in that one architecture may have 1 nonbool attribute and another
     may have more.  Having this last means the non-architecture specific code
     needn't care, now or tomorrow.  The goal is to eventually record
     attributes in their raw form, evaluate them at run-time, and cache the
     values, so this worry will go away anyway.  */
#ifndef CGEN_OPERAND_NBOOL_ATTRS
#define CGEN_OPERAND_NBOOL_ATTRS 1
#endif
  CGEN_ATTR_TYPE (CGEN_OPERAND_NBOOL_ATTRS) attrs;
#define CGEN_OPERAND_ATTRS(operand) (&(operand)->attrs)
} CGEN_OPERAND;

/* Return value of attribute ATTR in OPERAND.  */

#define CGEN_OPERAND_ATTR_VALUE(operand, attr) \
CGEN_ATTR_VALUE ((operand), CGEN_OPERAND_ATTRS (operand), (attr))

/* Table of operands for selected mach/isa, computed at runtime.
   enum cgen_operand_type is an index into this table (specifically
   `entries').  */

typedef struct {
  /* Pointer to null terminated table of all compiled in entries.  */
  const CGEN_OPERAND *init_entries;
  unsigned int entry_size; /* since the attribute member is variable sized */
  /* Array of all entries, initial and run-time added.  */
  const CGEN_OPERAND **entries;
  /* Number of elements in `entries'.  */
  unsigned int num_entries;
  /* For now, xrealloc is called each time a new entry is added at runtime.
     ??? May wish to keep track of some slop to reduce the number of calls to
     xrealloc, except that there's unlikely to be many and not expected to be
     in speed critical code.  */
} CGEN_OPERAND_TABLE;

extern const CGEN_OPERAND * cgen_operand_lookup_by_name
  (CGEN_CPU_DESC, const char *);
extern const CGEN_OPERAND * cgen_operand_lookup_by_num
  (CGEN_CPU_DESC, int);

/* Instruction operand instances.

   For each instruction, a list of the hardware elements that are read and
   written are recorded.  */

/* The type of the instance.  */

enum cgen_opinst_type {
  /* End of table marker.  */
  CGEN_OPINST_END = 0,
  CGEN_OPINST_INPUT, CGEN_OPINST_OUTPUT
};

typedef struct
{
  /* Input or output indicator.  */
  enum cgen_opinst_type type;

  /* Name of operand.  */
  const char *name;

  /* The hardware element referenced.  */
  enum cgen_hw_type hw_type;

  /* The mode in which the operand is being used.  */
  enum cgen_mode mode;

  /* The operand table entry CGEN_OPERAND_NIL if there is none
     (i.e. an explicit hardware reference).  */
  enum cgen_operand_type op_type;

  /* If `operand' is "nil", the index (e.g. into array of registers).  */
  int index;

  /* Attributes.
     ??? This perhaps should be a real attribute struct but there's
     no current need, so we save a bit of space and just have a set of
     flags.  The interface is such that this can easily be made attributes
     should it prove useful.  */
  unsigned int attrs;
#define CGEN_OPINST_ATTRS(opinst) ((opinst)->attrs)
/* Return value of attribute ATTR in OPINST.  */
#define CGEN_OPINST_ATTR(opinst, attr) \
((CGEN_OPINST_ATTRS (opinst) & (attr)) != 0)
/* Operand is conditionally referenced (read/written).  */
#define CGEN_OPINST_COND_REF 1
} CGEN_OPINST;

/* Syntax string.

   Each insn format and subexpression has one of these.

   The syntax "string" consists of characters (n > 0 && n < 128), and operand
   values (n >= 128), and is terminated by 0.  Operand values are 128 + index
   into the operand table.  The operand table doesn't exist in C, per se, as
   the data is recorded in the parse/insert/extract/print switch statements. */

/* This should be at least as large as necessary for any target. */
#define CGEN_MAX_SYNTAX_ELEMENTS 48

/* A target may know its own precise maximum.  Assert that it falls below
   the above limit. */
#ifdef CGEN_ACTUAL_MAX_SYNTAX_ELEMENTS
#if CGEN_ACTUAL_MAX_SYNTAX_ELEMENTS > CGEN_MAX_SYNTAX_ELEMENTS
#error "CGEN_ACTUAL_MAX_SYNTAX_ELEMENTS too high - enlarge CGEN_MAX_SYNTAX_ELEMENTS"
#endif
#endif

typedef unsigned short CGEN_SYNTAX_CHAR_TYPE;

typedef struct
{
  CGEN_SYNTAX_CHAR_TYPE syntax[CGEN_MAX_SYNTAX_ELEMENTS];
} CGEN_SYNTAX;

#define CGEN_SYNTAX_STRING(syn) (syn->syntax)
#define CGEN_SYNTAX_CHAR_P(c) ((c) < 128)
#define CGEN_SYNTAX_CHAR(c) ((unsigned char)c)
#define CGEN_SYNTAX_FIELD(c) ((c) - 128)
#define CGEN_SYNTAX_MAKE_FIELD(c) ((c) + 128)

/* ??? I can't currently think of any case where the mnemonic doesn't come
   first [and if one ever doesn't building the hash tables will be tricky].
   However, we treat mnemonics as just another operand of the instruction.
   A value of 1 means "this is where the mnemonic appears".  1 isn't
   special other than it's a non-printable ASCII char.  */

#define CGEN_SYNTAX_MNEMONIC       1
#define CGEN_SYNTAX_MNEMONIC_P(ch) ((ch) == CGEN_SYNTAX_MNEMONIC)

/* Instruction fields.

   ??? We currently don't allow adding fields at run-time.
   Easy to fix when needed.  */

typedef struct cgen_ifld {
  /* Enum of ifield.  */
  int num;
#define CGEN_IFLD_NUM(f) ((f)->num)

  /* Name of the field, distinguishes it from all other fields.  */
  const char *name;
#define CGEN_IFLD_NAME(f) ((f)->name)

  /* Default offset, in bits, from the start of the insn to the word
     containing the field.  */
  int word_offset;
#define CGEN_IFLD_WORD_OFFSET(f) ((f)->word_offset)

  /* Default length of the word containing the field.  */
  int word_size;
#define CGEN_IFLD_WORD_SIZE(f) ((f)->word_size)

  /* Default starting bit number.
     Whether lsb=0 or msb=0 is determined by CGEN_INSN_LSB0_P.  */
  int start;
#define CGEN_IFLD_START(f) ((f)->start)

  /* Length of the field, in bits.  */
  int length;
#define CGEN_IFLD_LENGTH(f) ((f)->length)

#ifndef CGEN_IFLD_NBOOL_ATTRS
#define CGEN_IFLD_NBOOL_ATTRS 1
#endif
  CGEN_ATTR_TYPE (CGEN_IFLD_NBOOL_ATTRS) attrs;
#define CGEN_IFLD_ATTRS(f) (&(f)->attrs)
} CGEN_IFLD;

/* Return value of attribute ATTR in IFLD.  */
#define CGEN_IFLD_ATTR_VALUE(ifld, attr) \
CGEN_ATTR_VALUE ((ifld), CGEN_IFLD_ATTRS (ifld), (attr))

/* Instruction data.  */

/* Instruction formats.

   Instructions are grouped by format.  Associated with an instruction is its
   format.  Each insn's opcode table entry contains a format table entry.
   ??? There is usually very few formats compared with the number of insns,
   so one can reduce the size of the opcode table by recording the format table
   as a separate entity.  Given that we currently don't, format table entries
   are also distinguished by their operands.  This increases the size of the
   table, but reduces the number of tables.  It's all minutiae anyway so it
   doesn't really matter [at this point in time].

   ??? Support for variable length ISA's is wip.  */

/* Accompanying each iformat description is a list of its fields.  */

typedef struct {
  const CGEN_IFLD *ifld;
#define CGEN_IFMT_IFLD_IFLD(ii) ((ii)->ifld)
} CGEN_IFMT_IFLD;

/* This should be at least as large as necessary for any target. */
#define CGEN_MAX_IFMT_OPERANDS 16

/* A target may know its own precise maximum.  Assert that it falls below
   the above limit. */
#ifdef CGEN_ACTUAL_MAX_IFMT_OPERANDS
#if CGEN_ACTUAL_MAX_IFMT_OPERANDS > CGEN_MAX_IFMT_OPERANDS
#error "CGEN_ACTUAL_MAX_IFMT_OPERANDS too high - enlarge CGEN_MAX_IFMT_OPERANDS"
#endif
#endif


typedef struct
{
  /* Length that MASK and VALUE have been calculated to
     [VALUE is recorded elsewhere].
     Normally it is base_insn_bitsize.  On [V]LIW architectures where the base
     insn size may be larger than the size of an insn, this field is less than
     base_insn_bitsize.  */
  unsigned char mask_length;
#define CGEN_IFMT_MASK_LENGTH(ifmt) ((ifmt)->mask_length)

  /* Total length of instruction, in bits.  */
  unsigned char length;
#define CGEN_IFMT_LENGTH(ifmt) ((ifmt)->length)

  /* Mask to apply to the first MASK_LENGTH bits.
     Each insn's value is stored with the insn.
     The first step in recognizing an insn for disassembly is
     (opcode & mask) == value.  */
  CGEN_INSN_INT mask;
#define CGEN_IFMT_MASK(ifmt) ((ifmt)->mask)

  /* Instruction fields.
     +1 for trailing NULL.  */
  CGEN_IFMT_IFLD iflds[CGEN_MAX_IFMT_OPERANDS + 1];
#define CGEN_IFMT_IFLDS(ifmt) ((ifmt)->iflds)
} CGEN_IFMT;

/* Instruction values.  */

typedef struct
{
  /* The opcode portion of the base insn.  */
  CGEN_INSN_INT base_value;

#ifdef CGEN_MAX_EXTRA_OPCODE_OPERANDS
  /* Extra opcode values beyond base_value.  */
  unsigned long ifield_values[CGEN_MAX_EXTRA_OPCODE_OPERANDS];
#endif
} CGEN_IVALUE;

/* Instruction opcode table.
   This contains the syntax and format data of an instruction.  */

/* ??? Some ports already have an opcode table yet still need to use the rest
   of what cgen_insn has.  Plus keeping the opcode data with the operand
   instance data can create a pretty big file.  So we keep them separately.
   Not sure this is a good idea in the long run.  */

typedef struct
{
  /* Indices into parse/insert/extract/print handler tables.  */
  struct cgen_opcode_handler handlers;
#define CGEN_OPCODE_HANDLERS(opc) (& (opc)->handlers)

  /* Syntax string.  */
  CGEN_SYNTAX syntax;
#define CGEN_OPCODE_SYNTAX(opc) (& (opc)->syntax)

  /* Format entry.  */
  const CGEN_IFMT *format;
#define CGEN_OPCODE_FORMAT(opc) ((opc)->format)
#define CGEN_OPCODE_MASK_BITSIZE(opc) CGEN_IFMT_MASK_LENGTH (CGEN_OPCODE_FORMAT (opc))
#define CGEN_OPCODE_BITSIZE(opc) CGEN_IFMT_LENGTH (CGEN_OPCODE_FORMAT (opc))
#define CGEN_OPCODE_IFLDS(opc) CGEN_IFMT_IFLDS (CGEN_OPCODE_FORMAT (opc))

  /* Instruction opcode value.  */
  CGEN_IVALUE value;
#define CGEN_OPCODE_VALUE(opc) (& (opc)->value)
#define CGEN_OPCODE_BASE_VALUE(opc) (CGEN_OPCODE_VALUE (opc)->base_value)
#define CGEN_OPCODE_BASE_MASK(opc) CGEN_IFMT_MASK (CGEN_OPCODE_FORMAT (opc))
} CGEN_OPCODE;

/* Instruction attributes.
   This is made a published type as applications can cache a pointer to
   the attributes for speed.  */

#ifndef CGEN_INSN_NBOOL_ATTRS
#define CGEN_INSN_NBOOL_ATTRS 1
#endif
typedef CGEN_ATTR_TYPE (CGEN_INSN_NBOOL_ATTRS) CGEN_INSN_ATTR_TYPE;

/* Enum of architecture independent attributes.  */

#ifndef CGEN_ARCH
/* ??? Numbers here are recorded in two places.  */
typedef enum cgen_insn_attr {
  CGEN_INSN_ALIAS = 0
} CGEN_INSN_ATTR;
#define CGEN_ATTR_CGEN_INSN_ALIAS_VALUE(attrs) ((attrs)->bool_ & (1 << CGEN_INSN_ALIAS))
#endif

/* This struct defines each entry in the instruction table.  */

typedef struct
{
  /* Each real instruction is enumerated.  */
  /* ??? This may go away in time.  */
  int num;
#define CGEN_INSN_NUM(insn) ((insn)->base->num)

  /* Name of entry (that distinguishes it from all other entries).  */
  /* ??? If mnemonics have operands, try to print full mnemonic.  */
  const char *name;
#define CGEN_INSN_NAME(insn) ((insn)->base->name)

  /* Mnemonic.  This is used when parsing and printing the insn.
     In the case of insns that have operands on the mnemonics, this is
     only the constant part.  E.g. for conditional execution of an `add' insn,
     where the full mnemonic is addeq, addne, etc., and the condition is
     treated as an operand, this is only "add".  */
  const char *mnemonic;
#define CGEN_INSN_MNEMONIC(insn) ((insn)->base->mnemonic)

  /* Total length of instruction, in bits.  */
  int bitsize;
#define CGEN_INSN_BITSIZE(insn) ((insn)->base->bitsize)

#if 0 /* ??? Disabled for now as there is a problem with embedded newlines
	 and the table is already pretty big.  Should perhaps be moved
	 to a file of its own.  */
  /* Semantics, as RTL.  */
  /* ??? Plain text or bytecodes?  */
  /* ??? Note that the operand instance table could be computed at run-time
     if we parse this and cache the results.  Something to eventually do.  */
  const char *rtx;
#define CGEN_INSN_RTX(insn) ((insn)->base->rtx)
#endif

  /* Attributes.
     This must appear last.  It is a variable sized array in that one
     architecture may have 1 nonbool attribute and another may have more.
     Having this last means the non-architecture specific code needn't
     care.  The goal is to eventually record attributes in their raw form,
     evaluate them at run-time, and cache the values, so this worry will go
     away anyway.  */
  CGEN_INSN_ATTR_TYPE attrs;
#define CGEN_INSN_ATTRS(insn) (&(insn)->base->attrs)
/* Return value of attribute ATTR in INSN.  */
#define CGEN_INSN_ATTR_VALUE(insn, attr) \
CGEN_ATTR_VALUE ((insn), CGEN_INSN_ATTRS (insn), (attr))
#define CGEN_INSN_BITSET_ATTR_VALUE(insn, attr) \
  CGEN_BITSET_ATTR_VALUE ((insn), CGEN_INSN_ATTRS (insn), (attr))
} CGEN_IBASE;

/* Return non-zero if INSN is the "invalid" insn marker.  */

#define CGEN_INSN_INVALID_P(insn) (CGEN_INSN_MNEMONIC (insn) == 0)

/* Main struct contain instruction information.
   BASE is always present, the rest is present only if asked for.  */

struct cgen_insn
{
  /* ??? May be of use to put a type indicator here.
     Then this struct could different info for different classes of insns.  */
  /* ??? A speedup can be had by moving `base' into this struct.
     Maybe later.  */
  const CGEN_IBASE *base;
  const CGEN_OPCODE *opcode;
  const CGEN_OPINST *opinst;

  /* Regex to disambiguate overloaded opcodes */
  void *rx;
#define CGEN_INSN_RX(insn) ((insn)->rx)
#define CGEN_MAX_RX_ELEMENTS (CGEN_MAX_SYNTAX_ELEMENTS * 5)
};

/* Instruction lists.
   This is used for adding new entries and for creating the hash lists.  */

typedef struct cgen_insn_list
{
  struct cgen_insn_list *next;
  const CGEN_INSN *insn;
} CGEN_INSN_LIST;

/* Table of instructions.  */

typedef struct
{
  const CGEN_INSN *init_entries;
  unsigned int entry_size; /* since the attribute member is variable sized */
  unsigned int num_init_entries;
  CGEN_INSN_LIST *new_entries;
} CGEN_INSN_TABLE;

/* Return number of instructions.  This includes any added at run-time.  */

extern int cgen_insn_count (CGEN_CPU_DESC);
extern int cgen_macro_insn_count (CGEN_CPU_DESC);

/* Macros to access the other insn elements not recorded in CGEN_IBASE.  */

/* Fetch INSN's operand instance table.  */
/* ??? Doesn't handle insns added at runtime.  */
#define CGEN_INSN_OPERANDS(insn) ((insn)->opinst)

/* Return INSN's opcode table entry.  */
#define CGEN_INSN_OPCODE(insn) ((insn)->opcode)

/* Return INSN's handler data.  */
#define CGEN_INSN_HANDLERS(insn) CGEN_OPCODE_HANDLERS (CGEN_INSN_OPCODE (insn))

/* Return INSN's syntax.  */
#define CGEN_INSN_SYNTAX(insn) CGEN_OPCODE_SYNTAX (CGEN_INSN_OPCODE (insn))

/* Return size of base mask in bits.  */
#define CGEN_INSN_MASK_BITSIZE(insn) \
  CGEN_OPCODE_MASK_BITSIZE (CGEN_INSN_OPCODE (insn))

/* Return mask of base part of INSN.  */
#define CGEN_INSN_BASE_MASK(insn) \
  CGEN_OPCODE_BASE_MASK (CGEN_INSN_OPCODE (insn))

/* Return value of base part of INSN.  */
#define CGEN_INSN_BASE_VALUE(insn) \
  CGEN_OPCODE_BASE_VALUE (CGEN_INSN_OPCODE (insn))

/* Standard way to test whether INSN is supported by MACH.
   MACH is one of enum mach_attr.
   The "|1" is because the base mach is always selected.  */
#define CGEN_INSN_MACH_HAS_P(insn, mach) \
((CGEN_INSN_ATTR_VALUE ((insn), CGEN_INSN_MACH) & ((1 << (mach)) | 1)) != 0)

/* Macro instructions.
   Macro insns aren't real insns, they map to one or more real insns.
   E.g. An architecture's "nop" insn may actually be an "mv r0,r0" or
   some such.

   Macro insns can expand to nothing (e.g. a nop that is optimized away).
   This is useful in multi-insn macros that build a constant in a register.
   Of course this isn't the default behaviour and must be explicitly enabled.

   Assembly of macro-insns is relatively straightforward.  Disassembly isn't.
   However, disassembly of at least some kinds of macro insns is important
   in order that the disassembled code preserve the readability of the original
   insn.  What is attempted here is to disassemble all "simple" macro-insns,
   where "simple" is currently defined to mean "expands to one real insn".

   Simple macro-insns are handled specially.  They are emitted as ALIAS's
   of real insns.  This simplifies their handling since there's usually more
   of them than any other kind of macro-insn, and proper disassembly of them
   falls out for free.  */

/* For each macro-insn there may be multiple expansion possibilities,
   depending on the arguments.  This structure is accessed via the `data'
   member of CGEN_INSN.  */

typedef struct cgen_minsn_expansion {
  /* Function to do the expansion.
     If the expansion fails (e.g. "no match") NULL is returned.
     Space for the expansion is obtained with malloc.
     It is up to the caller to free it.  */
  const char * (* fn)
     (const struct cgen_minsn_expansion *,
      const char *, const char **, int *,
      CGEN_OPERAND **);
#define CGEN_MIEXPN_FN(ex) ((ex)->fn)

  /* Instruction(s) the macro expands to.
     The format of STR is defined by FN.
     It is typically the assembly code of the real insn, but it could also be
     the original Scheme expression or a tokenized form of it (with FN being
     an appropriate interpreter).  */
  const char * str;
#define CGEN_MIEXPN_STR(ex) ((ex)->str)
} CGEN_MINSN_EXPANSION;

/* Normal expander.
   When supported, this function will convert the input string to another
   string and the parser will be invoked recursively.  The output string
   may contain further macro invocations.  */

extern const char * cgen_expand_macro_insn
  (CGEN_CPU_DESC, const struct cgen_minsn_expansion *,
   const char *, const char **, int *, CGEN_OPERAND **);

/* The assembler insn table is hashed based on some function of the mnemonic
   (the actually hashing done is up to the target, but we provide a few
   examples like the first letter or a function of the entire mnemonic).  */

extern CGEN_INSN_LIST * cgen_asm_lookup_insn
  (CGEN_CPU_DESC, const char *);
#define CGEN_ASM_LOOKUP_INSN(cd, string) cgen_asm_lookup_insn ((cd), (string))
#define CGEN_ASM_NEXT_INSN(insn) ((insn)->next)

/* The disassembler insn table is hashed based on some function of machine
   instruction (the actually hashing done is up to the target).  */

extern CGEN_INSN_LIST * cgen_dis_lookup_insn
  (CGEN_CPU_DESC, const char *, CGEN_INSN_INT);
/* FIXME: delete these two */
#define CGEN_DIS_LOOKUP_INSN(cd, buf, value) cgen_dis_lookup_insn ((cd), (buf), (value))
#define CGEN_DIS_NEXT_INSN(insn) ((insn)->next)

/* The CPU description.
   A copy of this is created when the cpu table is "opened".
   All global state information is recorded here.
   Access macros are provided for "public" members.  */

typedef struct cgen_cpu_desc
{
  /* Bitmap of selected machine(s) (a la BFD machine number).  */
  int machs;

  /* Bitmap of selected isa(s).  */
  CGEN_BITSET *isas;
#define CGEN_CPU_ISAS(cd) ((cd)->isas)

  /* Current endian.  */
  enum cgen_endian endian;
#define CGEN_CPU_ENDIAN(cd) ((cd)->endian)

  /* Current insn endian.  */
  enum cgen_endian insn_endian;
#define CGEN_CPU_INSN_ENDIAN(cd) ((cd)->insn_endian)

  /* Word size (in bits).  */
  /* ??? Or maybe maximum word size - might we ever need to allow a cpu table
     to be opened for both sparc32/sparc64?
     ??? Another alternative is to create a table of selected machs and
     lazily fetch the data from there.  */
  unsigned int word_bitsize;

  /* Instruction chunk size (in bits), for purposes of endianness
     conversion.  */
  unsigned int insn_chunk_bitsize;

  /* Indicator if sizes are unknown.
     This is used by default_insn_bitsize,base_insn_bitsize if there is a
     difference between the selected isa's.  */
#define CGEN_SIZE_UNKNOWN 65535

  /* Default instruction size (in bits).
     This is used by the assembler when it encounters an unknown insn.  */
  unsigned int default_insn_bitsize;

  /* Base instruction size (in bits).
     For non-LIW cpus this is generally the length of the smallest insn.
     For LIW cpus its wip (work-in-progress).  For the m32r its 32.  */
  unsigned int base_insn_bitsize;

  /* Minimum/maximum instruction size (in bits).  */
  unsigned int min_insn_bitsize;
  unsigned int max_insn_bitsize;

  /* Instruction set variants.  */
  const CGEN_ISA *isa_table;

  /* Machine variants.  */
  const CGEN_MACH *mach_table;

  /* Hardware elements.  */
  CGEN_HW_TABLE hw_table;

  /* Instruction fields.  */
  const CGEN_IFLD *ifld_table;

  /* Operands.  */
  CGEN_OPERAND_TABLE operand_table;

  /* Main instruction table.  */
  CGEN_INSN_TABLE insn_table;
#define CGEN_CPU_INSN_TABLE(cd) (& (cd)->insn_table)

  /* Macro instructions are defined separately and are combined with real
     insns during hash table computation.  */
  CGEN_INSN_TABLE macro_insn_table;

  /* Copy of CGEN_INT_INSN_P.  */
  int int_insn_p;

  /* Called to rebuild the tables after something has changed.  */
  void (*rebuild_tables) (CGEN_CPU_DESC);

  /* Operand parser callback.  */
  cgen_parse_operand_fn * parse_operand_fn;

  /* Parse/insert/extract/print cover fns for operands.  */
  const char * (*parse_operand)
    (CGEN_CPU_DESC, int opindex_, const char **, CGEN_FIELDS *fields_);
#ifdef __BFD_H_SEEN__
  const char * (*insert_operand)
    (CGEN_CPU_DESC, int opindex_, CGEN_FIELDS *fields_,
     CGEN_INSN_BYTES_PTR, bfd_vma pc_);
  int (*extract_operand)
    (CGEN_CPU_DESC, int opindex_, CGEN_EXTRACT_INFO *, CGEN_INSN_INT,
     CGEN_FIELDS *fields_, bfd_vma pc_);
  void (*print_operand)
    (CGEN_CPU_DESC, int opindex_, void * info_, CGEN_FIELDS * fields_,
     void const *attrs_, bfd_vma pc_, int length_);
#else
  const char * (*insert_operand) ();
  int (*extract_operand) ();
  void (*print_operand) ();
#endif
#define CGEN_CPU_PARSE_OPERAND(cd) ((cd)->parse_operand)
#define CGEN_CPU_INSERT_OPERAND(cd) ((cd)->insert_operand)
#define CGEN_CPU_EXTRACT_OPERAND(cd) ((cd)->extract_operand)
#define CGEN_CPU_PRINT_OPERAND(cd) ((cd)->print_operand)

  /* Size of CGEN_FIELDS struct.  */
  unsigned int sizeof_fields;
#define CGEN_CPU_SIZEOF_FIELDS(cd) ((cd)->sizeof_fields)

  /* Set the bitsize field.  */
  void (*set_fields_bitsize) (CGEN_FIELDS *fields_, int size_);
#define CGEN_CPU_SET_FIELDS_BITSIZE(cd) ((cd)->set_fields_bitsize)

  /* CGEN_FIELDS accessors.  */
  int (*get_int_operand)
    (CGEN_CPU_DESC, int opindex_, const CGEN_FIELDS *fields_);
  void (*set_int_operand)
    (CGEN_CPU_DESC, int opindex_, CGEN_FIELDS *fields_, int value_);
#ifdef __BFD_H_SEEN__
  bfd_vma (*get_vma_operand)
    (CGEN_CPU_DESC, int opindex_, const CGEN_FIELDS *fields_);
  void (*set_vma_operand)
    (CGEN_CPU_DESC, int opindex_, CGEN_FIELDS *fields_, bfd_vma value_);
#else
  long (*get_vma_operand) ();
  void (*set_vma_operand) ();
#endif
#define CGEN_CPU_GET_INT_OPERAND(cd) ((cd)->get_int_operand)
#define CGEN_CPU_SET_INT_OPERAND(cd) ((cd)->set_int_operand)
#define CGEN_CPU_GET_VMA_OPERAND(cd) ((cd)->get_vma_operand)
#define CGEN_CPU_SET_VMA_OPERAND(cd) ((cd)->set_vma_operand)

  /* Instruction parse/insert/extract/print handlers.  */
  /* FIXME: make these types uppercase.  */
  cgen_parse_fn * const *parse_handlers;
  cgen_insert_fn * const *insert_handlers;
  cgen_extract_fn * const *extract_handlers;
  cgen_print_fn * const *print_handlers;
#define CGEN_PARSE_FN(cd, insn)   (cd->parse_handlers[(insn)->opcode->handlers.parse])
#define CGEN_INSERT_FN(cd, insn)  (cd->insert_handlers[(insn)->opcode->handlers.insert])
#define CGEN_EXTRACT_FN(cd, insn) (cd->extract_handlers[(insn)->opcode->handlers.extract])
#define CGEN_PRINT_FN(cd, insn)   (cd->print_handlers[(insn)->opcode->handlers.print])

  /* Return non-zero if insn should be added to hash table.  */
  int (* asm_hash_p) (const CGEN_INSN *);

  /* Assembler hash function.  */
  unsigned int (* asm_hash) (const char *);

  /* Number of entries in assembler hash table.  */
  unsigned int asm_hash_size;

  /* Return non-zero if insn should be added to hash table.  */
  int (* dis_hash_p) (const CGEN_INSN *);

  /* Disassembler hash function.  */
  unsigned int (* dis_hash) (const char *, CGEN_INSN_INT);

  /* Number of entries in disassembler hash table.  */
  unsigned int dis_hash_size;

  /* Assembler instruction hash table.  */
  CGEN_INSN_LIST **asm_hash_table;
  CGEN_INSN_LIST *asm_hash_table_entries;

  /* Disassembler instruction hash table.  */
  CGEN_INSN_LIST **dis_hash_table;
  CGEN_INSN_LIST *dis_hash_table_entries;

  /* This field could be turned into a bitfield if room for other flags is needed.  */
  unsigned int signed_overflow_ok_p;
       
} CGEN_CPU_TABLE;

/* wip */
#ifndef CGEN_WORD_ENDIAN
#define CGEN_WORD_ENDIAN(cd) CGEN_CPU_ENDIAN (cd)
#endif
#ifndef CGEN_INSN_WORD_ENDIAN
#define CGEN_INSN_WORD_ENDIAN(cd) CGEN_CPU_INSN_ENDIAN (cd)
#endif

/* Prototypes of major functions.  */
/* FIXME: Move more CGEN_SYM-defined functions into CGEN_CPU_DESC.
   Not the init fns though, as that would drag in things that mightn't be
   used and might not even exist.  */

/* Argument types to cpu_open.  */

enum cgen_cpu_open_arg {
  CGEN_CPU_OPEN_END,
  /* Select instruction set(s), arg is bitmap or 0 meaning "unspecified".  */
  CGEN_CPU_OPEN_ISAS,
  /* Select machine(s), arg is bitmap or 0 meaning "unspecified".  */
  CGEN_CPU_OPEN_MACHS,
  /* Select machine, arg is mach's bfd name.
     Multiple machines can be specified by repeated use.  */
  CGEN_CPU_OPEN_BFDMACH,
  /* Select endian, arg is CGEN_ENDIAN_*.  */
  CGEN_CPU_OPEN_ENDIAN
};

/* Open a cpu descriptor table for use.
   ??? We only support ISO C stdargs here, not K&R.
   Laziness, plus experiment to see if anything requires K&R - eventually
   K&R will no longer be supported - e.g. GDB is currently trying this.  */

extern CGEN_CPU_DESC CGEN_SYM (cpu_open) (enum cgen_cpu_open_arg, ...);

/* Cover fn to handle simple case.  */

extern CGEN_CPU_DESC CGEN_SYM (cpu_open_1)
   (const char *mach_name_, enum cgen_endian endian_);

/* Close it.  */

extern void CGEN_SYM (cpu_close) (CGEN_CPU_DESC);

/* Initialize the opcode table for use.
   Called by init_asm/init_dis.  */

extern void CGEN_SYM (init_opcode_table) (CGEN_CPU_DESC cd_);

/* build the insn selection regex.
   called by init_opcode_table */

extern char * CGEN_SYM(build_insn_regex) (CGEN_INSN *insn_);

/* Initialize the ibld table for use.
   Called by init_asm/init_dis.  */

extern void CGEN_SYM (init_ibld_table) (CGEN_CPU_DESC cd_);

/* Initialize an cpu table for assembler or disassembler use.
   These must be called immediately after cpu_open.  */

extern void CGEN_SYM (init_asm) (CGEN_CPU_DESC);
extern void CGEN_SYM (init_dis) (CGEN_CPU_DESC);

/* Initialize the operand instance table for use.  */

extern void CGEN_SYM (init_opinst_table) (CGEN_CPU_DESC cd_);

/* Assemble an instruction.  */

extern const CGEN_INSN * CGEN_SYM (assemble_insn)
  (CGEN_CPU_DESC, const char *, CGEN_FIELDS *,
   CGEN_INSN_BYTES_PTR, char **);

extern const CGEN_KEYWORD CGEN_SYM (operand_mach);
extern int CGEN_SYM (get_mach) (const char *);

/* Operand index computation.  */
extern const CGEN_INSN * cgen_lookup_insn
  (CGEN_CPU_DESC, const CGEN_INSN * insn_,
   CGEN_INSN_INT int_value_, unsigned char *bytes_value_,
   int length_, CGEN_FIELDS *fields_, int alias_p_);
extern void cgen_get_insn_operands
  (CGEN_CPU_DESC, const CGEN_INSN * insn_,
   const CGEN_FIELDS *fields_, int *indices_);
extern const CGEN_INSN * cgen_lookup_get_insn_operands
  (CGEN_CPU_DESC, const CGEN_INSN *insn_,
   CGEN_INSN_INT int_value_, unsigned char *bytes_value_,
   int length_, int *indices_, CGEN_FIELDS *fields_);

/* Cover fns to bfd_get/set.  */

extern CGEN_INSN_INT cgen_get_insn_value
  (CGEN_CPU_DESC, unsigned char *, int);
extern void cgen_put_insn_value
  (CGEN_CPU_DESC, unsigned char *, int, CGEN_INSN_INT);

/* Read in a cpu description file.
   ??? For future concerns, including adding instructions to the assembler/
   disassembler at run-time.  */

extern const char * cgen_read_cpu_file (CGEN_CPU_DESC, const char * filename_);

/* Allow signed overflow of instruction fields.  */
extern void cgen_set_signed_overflow_ok (CGEN_CPU_DESC);

/* Generate an error message if a signed field in an instruction overflows.  */
extern void cgen_clear_signed_overflow_ok (CGEN_CPU_DESC);

/* Will an error message be generated if a signed field in an instruction overflows ? */
extern unsigned int cgen_signed_overflow_ok_p (CGEN_CPU_DESC);

#endif /* OPCODE_CGEN_H */
@


1.26
log
@Upgrade header files to use GPLv3
@
text
@d132 1
a132 1
  unsigned int bool;
d143 1
a143 1
struct { unsigned int bool; \
d148 1
a148 1
#define CGEN_ATTR_BOOLS(a) ((a)->bool)
d985 1
a985 1
#define CGEN_ATTR_CGEN_INSN_ALIAS_VALUE(attrs) ((attrs)->bool & (1 << CGEN_INSN_ALIAS))
@


1.25
log
@	* cgen.h: Include bfd_stdint.h.
	(CGEN_INSN_LGSINT, CGEN_INSN_LGUINT): New types.
@
text
@d3 2
a4 2
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2009
Free Software Foundation, Inc.
d6 1
a6 1
This file is part of GDB, the GNU debugger, and the GNU Binutils.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.24
log
@	cpu/
	* m32c.opc (opc.h): cgen-types.h -> cgen/basic-modes.h.
	cgen-ops.h -> cgen/basic-ops.h.

	include/opcode/
	* cgen-bitset.h: Delete, moved to ../cgen/bitset.h.
	* cgen.h: Update.  Improve multi-inclusion macro name.

	include/cgen/
	* basic-modes.h: New file.  Moved here from opcodes/cgen-types.h.
	* basic-ops.h: New file.  Moved here from opcodes/cgen-ops.h.
	* bitset.h: New file.  Moved here from ../opcode/cgen-bitset.h.
	Update license to GPL v3.

	opcodes/
	* cgen-ops.h: Delete, moved to ../include/cgen/basic-ops.h.
	* cgen-types.h: Delete, moved to ../include/cgen/basic-modes.h.
	* cgen-bitset.c: Update.
	* fr30-desc.h: Regenerate.
	* frv-desc.h: Regenerate.
	* ip2k-desc.h: Regenerate.
	* iq2000-desc.h: Regenerate.
	* lm32-desc.h: Regenerate.
	* m32c-desc.h: Regenerate.
	* m32c-opc.h: Regenerate.
	* m32r-desc.h: Regenerate.
	* mep-desc.h: Regenerate.
	* mt-desc.h: Regenerate.
	* openrisc-desc.h: Regenerate.
	* xc16x-desc.h: Regenerate.
	* xstormy16-desc.h: Regenerate.
@
text
@d28 3
d72 3
@


1.23
log
@2005-10-28  Dave Brolley  <brolley@@redhat.com>

        Contribute the following changes:
        2005-02-16  Dave Brolley  <brolley@@redhat.com>

        * cgen-bitset.h: Rename CGEN_ISA_MASK to CGEN_BITSET. Rename
        cgen_isa_mask_* to cgen_bitset_*.
        * cgen.h: Likewise.
@
text
@d3 1
a3 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005
d22 2
a23 2
#ifndef CGEN_H
#define CGEN_H
d26 2
a27 1
#include "cgen-bitset.h"
d1474 1
a1474 1
#endif /* CGEN_H */
@


1.23.64.1
log
@Commit patches for ARCompact support to binutils-arc-20081103-branch .
@
text
@d1342 1
a1342 1
  unsigned int (* dis_hash) (const char *, CGEN_INSN_INT, int);
@


1.23.54.1
log
@Check in ARCompact simulator.  A valid configuration is arc-elf.
This is not quite finished and has most likely a few files that are
obsolete & not used, but it's good enough to run gcc regression tests.
@
text
@d3 1
a3 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2007
d1342 1
a1342 1
  unsigned int (* dis_hash) (const char *, CGEN_INSN_INT, int);
@


1.22
log
@Update the address and phone number of the FSF organization
@
text
@d25 2
d112 7
a118 1
typedef int CGEN_ATTR_VALUE_TYPE;
d164 3
a166 1
 : ((attr_table)->nonbool[(attr) - CGEN_ATTR_NBOOL_OFFSET]))
d174 1
a174 1
  CGEN_ATTR_VALUE_TYPE value;
d978 1
d1030 2
d1195 3
a1197 4
  /* Bitmap of selected isa(s).
     ??? Simultaneous multiple isas might not make sense, but it's not (yet)
     precluded.  */
  int isas;
@


1.21
log
@update copyright dates
@
text
@d20 1
a20 1
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.20
log
@bfd/ChangeLog:
2004-12-10  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (elf32_frv_relocate_section): Force local binding
for TLSMOFF.
* reloc.c: Add R_FRV_TLSMOFF.
* elf32-frv.c (elf32_frv_howto_table): Likewise.
(frv_reloc_map, frv_reloc_type_lookup): Map it.
(elf32_frv_relocate_section): Handle it.
(elf32_frv_check_relocs): Likewise.
* libbfd.h, bfd-in2.h: Rebuilt.
2004-11-26  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (_frvfdpic_emit_got_relocs_plt_entries): Don't crash
when given an undefweak TLS symbol.  Fix constant TLS PLT entries
such that they return the constant in gr9.
(_frvfdpic_relax_tls_entries): Don't crash for undefweak TLS
symbols.
(_frvfdpic_size_got_plt): Set _cooked_size of dynamic sections.
too, such that they shrink on relaxation.
(elf32_frvfdpic_finish_dynamic_sections): Check __ROFIXUP_END__ as
marking the position right past the _GLOBAL_OFFSET_TABLE_ value.
(_frvfdpic_assign_plt_entries): Shrink constant TLS PLT entries
if we can guarantee the use of 16-bit constants.
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
Introduce TLS support for FR-V FDPIC.
* reloc.c: Add TLS relocations.
* elf32-frv.c (elf32_frv_howto_table): Add TLS relocations.
(elf32_frv_rel_tlsdesc_value_howto): New.
(elf32_frv_rel_tlsoff_howto): New.
(frv_reloc_map): Add new mappings.
(struct frvfdpic_elf_link_hash_table): Add pointer to summary
reloc information.
(frvfdpic_dynamic_got_plt_info): New.
(frvfdpic_plt_tls_ret_offset): New.
(ELF_DYNAMIC_INTERPRETER, DEFAULT_STACK_SIZE): Move earlier.
(struct _frvfdpic_dynamic_got_info): Likewise.  Add TLS members.
(struct _frvfdpic_dynamic_got_plt_info): Likewise.
(FRVFDPIC_SYM_LOCAL): Regard symbols defined in the absolute
section as local.
(struct frvfdpic_relocs_info): Add TLS fields.
(frvfdpic_relocs_info_hash): Warning clean up.
(frvfdpic_relocs_info_find): Initialize tlsplt_entry.
(frvfdpic_pic_merge_early_relocs_info): Merge TLS fields.
(FRVFDPIC_TLS_BIAS): Define.
(tls_biased_base): New.
(_frvfdpic_emit_got_relocs_plt_entries): Deal with TLS
relocations.
(frv_reloc_type_lookup): Likewise.
(frvfdpic_info_to_howto_rel): Likewise.
(elf32_frv_relocate_section): Likewise.
(_frv_create_got_section): Create the PLT section here.
(elf32_frvfdpic_create_dynamic_sections): Not here.
(_frvfdpic_count_nontls_entries): Move out of...
(_frvfdpic_count_got_plt_entries): ... here.
(_frvfdpic_count_tls_entries): Likewise.  Add TLS support.
(_frvfdpic_count_relocs_fixups): Likewise.  Add relaxation
support.
(_frvfdpic_relax_tls_entries): New.
(_frvfdpic_compute_got_alloc_data): Add TLS support.
(_frvfdpic_get_tlsdesc_entry): New.
(_frvfdpic_assign_got_entries): Add TLS support.
(_frvfdpic_assign_plt_entries): Likewise.
(_frvfdpic_reset_got_plt_entries): New.
(_frvfdpic_size_got_plt): Move out of...
(elf32_frvfdpic_size_dynamic_sections): ... here.
(_frvfdpic_relax_got_plt_entries): New.
(elf32_frvfdpic_relax_section): New.
(elf32_frvfdpic_finish_dynamic_sections): Add TLS sanity check.
(elf32_frv_check_relocs): Add TLS support.
(bfd_elf32_bfd_relax_section): Define for FDPIC.
* libbfd.h, bfd-in2.h: Rebuilt.
cpu/ChangeLog:
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* frv.cpu: Add support for TLS annotations in loads and calll.
* frv.opc (parse_symbolic_address): New.
(parse_ldd_annotation): New.
(parse_call_annotation): New.
(parse_ld_annotation): New.
(parse_ulo16, parse_uslo16): Use parse_symbolic_address.
Introduce TLS relocations.
(parse_d12, parse_s12, parse_u12): Likewise.
(parse_uhi16): Likewise.  Fix constant checking on 64-bit host.
(parse_call_label, print_at): New.
gas/ChangeLog:
* config/tc-frv.c (md_apply_fix3): Mark TLS symbols as such.
2004-12-10  Alexandre Oliva  <aoliva@@redhat.com>
* config/tc-frv.c (frv_pic_ptr): Add tlsmoff support.
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* cgen.c (gas_cgen_parse_operand): Handle
CGEN_PARSE_OPERAND_SYMBOLIC.
* config/tc-frv.c (md_cgen_lookup_reloc): Handle TLS relocations.
(frv_force_relocation): Likewise.  Fix handling of PIC
relocations.
(md_apply_fix3): Likewise.
include/elf/ChangeLog:
2004-12-10  Alexandre Oliva  <aoliva@@redhat.com>
* frv.h: Add R_FRV_TLSMOFF.
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* frv.h: Add TLS relocations.
include/opcode/ChangeLog:
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* cgen.h (enum cgen_parse_operand_type): Add
CGEN_PARSE_OPERAND_SYMBOLIC.
ld/testsuite/ChangeLog:
* ld-frv/fdpic.exp: Add -mfdpic to ASFLAGS.
* ld-frv/tls.exp: Likewise.
2004-11-26  Alexandre Oliva  <aoliva@@redhat.com>
* ld-frv/tls-3.s: New.
* ld-frv/tls-static-3.d: New.
* ld-frv/tls-dynamic-3.d: New.
* ld-frv/tls-pie-3.d: New.
* ld-frv/tls-shared-3.d: New.
* ld-frv/tls-relax-static-3.d: New.
* ld-frv/tls-relax-dynamic-3.d: New.
* ld-frv/tls-relax-pie-3.d: New.
* ld-frv/tls-relax-shared-3.d: New.
* ld-frv/tls.exp: Run the new tests.
* ld-frv/tls-dynamic-2.d: Adjust for improved relaxation.
* ld-frv/tls-relax-dynamic-2.d: Likewise.
* ld-frv/tls-relax-initial-shared-2.d: Likewise.
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* ld-frv/tls-1-dep.s: New.
* ld-frv/tls-1-shared.lds: New.
* ld-frv/tls-1.s: New.
* ld-frv/tls-2.s: New.
* ld-frv/tls-dynamic-1.d: New.
* ld-frv/tls-dynamic-2.d: New.
* ld-frv/tls-initial-shared-2.d: New.
* ld-frv/tls-pie-1.d: New.
* ld-frv/tls-relax-dynamic-1.d: New.
* ld-frv/tls-relax-dynamic-2.d: New.
* ld-frv/tls-relax-initial-shared-2.d: New.
* ld-frv/tls-relax-pie-1.d: New.
* ld-frv/tls-relax-shared-1.d: New.
* ld-frv/tls-relax-shared-2.d: New.
* ld-frv/tls-relax-static-1.d: New.
* ld-frv/tls-shared-1-fail.d: New.
* ld-frv/tls-shared-1.d: New.
* ld-frv/tls-shared-2.d: New.
* ld-frv/tls-static-1.d: New.
* ld-frv/tls.exp: New.
* ld-frv/fdpic-pie-1.d: Adjust for 64-bit host.
* ld-frv/fdpic-pie-2.d: Likewise.
* ld-frv/fdpic-pie-6.d: Likewise.
* ld-frv/fdpic-pie-7.d: Likewise.
* ld-frv/fdpic-pie-8.d: Likewise.
* ld-frv/fdpic-shared-1.d: Likewise.
* ld-frv/fdpic-shared-2.d: Likewise.
* ld-frv/fdpic-shared-3.d: Likewise.
* ld-frv/fdpic-shared-4.d: Likewise.
* ld-frv/fdpic-shared-5.d: Likewise.
* ld-frv/fdpic-shared-6.d: Likewise.
* ld-frv/fdpic-shared-7.d: Likewise.
* ld-frv/fdpic-shared-8.d: Likewise.
* ld-frv/fdpic-shared-local-2.d: Likewise.
* ld-frv/fdpic-shared-local-8.d: Likewise.
* ld-frv/fdpic-static-1.d: Likewise.
* ld-frv/fdpic-static-2.d: Likewise.
* ld-frv/fdpic-static-6.d: Likewise.
* ld-frv/fdpic-static-7.d: Likewise.
* ld-frv/fdpic-static-8.d: Likewise.
opcodes/ChangeLog:
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* frv-asm.c: Rebuilt.
* frv-desc.c: Rebuilt.
* frv-desc.h: Rebuilt.
* frv-dis.c: Rebuilt.
* frv-ibld.c: Rebuilt.
* frv-opc.c: Rebuilt.
* frv-opc.h: Rebuilt.
@
text
@d3 1
a3 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
@


1.19
log
@Convert cgen to C-90
@
text
@d372 2
a373 1
  CGEN_PARSE_OPERAND_ADDRESS
@


1.18
log
@	* cgen.h (struct cgen_maybe_multi_ifield): Add "const PTR p" to union.
	Constify "leaf" and "multi".
@
text
@d245 1
a245 1
     We don't require dis-asm.h so we use PTR for the type here.
d247 1
a247 1
  PTR dis_info;
d268 2
a269 2
     PARAMS ((CGEN_CPU_DESC, const CGEN_INSN *insn_,
	      const char **strp_, CGEN_FIELDS *fields_));
d282 3
a284 3
     PARAMS ((CGEN_CPU_DESC, const CGEN_INSN *insn_,
	      CGEN_FIELDS *fields_, CGEN_INSN_BYTES_PTR insnp_,
	      bfd_vma pc_));
d303 3
a305 3
     PARAMS ((CGEN_CPU_DESC, const CGEN_INSN *insn_,
	      CGEN_EXTRACT_INFO *ex_info_, CGEN_INSN_INT base_insn_,
	      CGEN_FIELDS *fields_, bfd_vma pc_));
d322 2
a323 2
     PARAMS ((CGEN_CPU_DESC, PTR info_, const CGEN_INSN *insn_,
	      CGEN_FIELDS *fields_, bfd_vma pc_, int len_));
d387 3
a389 3
     PARAMS ((CGEN_CPU_DESC,
	      enum cgen_parse_operand_type, const char **, int, int,
	      enum cgen_parse_operand_result *, bfd_vma *));
d397 1
a397 1
     PARAMS ((CGEN_CPU_DESC, cgen_parse_operand_fn));
d401 1
a401 1
extern void cgen_init_parse_operand PARAMS ((CGEN_CPU_DESC));
d425 1
a425 1
  PTR asm_data;
d456 1
a456 1
     PARAMS ((CGEN_CPU_DESC, const char *));
d458 1
a458 1
     PARAMS ((CGEN_CPU_DESC, unsigned int));
d546 1
a546 1
  PARAMS ((CGEN_KEYWORD *, const char *));
d551 1
a551 1
  PARAMS ((CGEN_KEYWORD *, int));
d555 1
a555 1
void cgen_keyword_add PARAMS ((CGEN_KEYWORD *, CGEN_KEYWORD_ENTRY *));
d561 1
a561 1
  PARAMS ((CGEN_KEYWORD *, const char *));
d563 1
a563 1
  PARAMS ((CGEN_KEYWORD_SEARCH *));
d568 1
a568 1
     PARAMS ((CGEN_CPU_DESC, const char **, CGEN_KEYWORD *, long *));
d571 1
a571 1
     PARAMS ((CGEN_CPU_DESC, const char **, int, long *));
d573 1
a573 1
     PARAMS ((CGEN_CPU_DESC, const char **, int, unsigned long *));
d575 2
a576 2
     PARAMS ((CGEN_CPU_DESC, const char **, int, int,
	      enum cgen_parse_operand_result *, bfd_vma *));
d578 1
a578 1
     PARAMS ((long, long, long));
d580 1
a580 1
     PARAMS ((unsigned long, unsigned long, unsigned long));
d624 1
a624 1
    const PTR p;
d708 1
a708 1
     PARAMS ((CGEN_CPU_DESC, const char *));
d710 1
a710 1
     PARAMS ((CGEN_CPU_DESC, int));
d1064 2
a1065 2
extern int cgen_insn_count PARAMS ((CGEN_CPU_DESC));
extern int cgen_macro_insn_count PARAMS ((CGEN_CPU_DESC));
d1129 4
a1132 3
  const char * (* fn) PARAMS ((const struct cgen_minsn_expansion *,
			       const char *, const char **, int *,
			       CGEN_OPERAND **));
d1150 2
a1151 2
     PARAMS ((CGEN_CPU_DESC, const struct cgen_minsn_expansion *,
	      const char *, const char **, int *, CGEN_OPERAND **));
d1158 1
a1158 1
     PARAMS ((CGEN_CPU_DESC, const char *));
d1166 1
a1166 1
     PARAMS ((CGEN_CPU_DESC, const char *, CGEN_INSN_INT));
d1250 1
a1250 1
  void (*rebuild_tables) PARAMS ((CGEN_CPU_DESC));
d1257 1
a1257 2
     PARAMS ((CGEN_CPU_DESC, int opindex_, const char **,
	      CGEN_FIELDS *fields_));
d1260 2
a1261 2
     PARAMS ((CGEN_CPU_DESC, int opindex_, CGEN_FIELDS *fields_,
	      CGEN_INSN_BYTES_PTR, bfd_vma pc_));
d1263 2
a1264 2
     PARAMS ((CGEN_CPU_DESC, int opindex_, CGEN_EXTRACT_INFO *, CGEN_INSN_INT,
	      CGEN_FIELDS *fields_, bfd_vma pc_));
d1266 2
a1267 2
     PARAMS ((CGEN_CPU_DESC, int opindex_, PTR info_, CGEN_FIELDS * fields_,
	      void const *attrs_, bfd_vma pc_, int length_));
d1283 1
a1283 1
  void (*set_fields_bitsize) PARAMS ((CGEN_FIELDS *fields_, int size_));
d1288 1
a1288 1
       PARAMS ((CGEN_CPU_DESC, int opindex_, const CGEN_FIELDS *fields_));
d1290 1
a1290 1
       PARAMS ((CGEN_CPU_DESC, int opindex_, CGEN_FIELDS *fields_, int value_));
d1293 1
a1293 1
       PARAMS ((CGEN_CPU_DESC, int opindex_, const CGEN_FIELDS *fields_));
d1295 1
a1295 1
       PARAMS ((CGEN_CPU_DESC, int opindex_, CGEN_FIELDS *fields_, bfd_vma value_));
d1317 1
a1317 1
  int (* asm_hash_p) PARAMS ((const CGEN_INSN *));
d1320 1
a1320 1
  unsigned int (* asm_hash) PARAMS ((const char *));
d1326 1
a1326 1
  int (* dis_hash_p) PARAMS ((const CGEN_INSN *));
d1329 1
a1329 1
  unsigned int (* dis_hash) PARAMS ((const char *, CGEN_INSN_INT));
d1384 2
a1385 2
extern CGEN_CPU_DESC CGEN_SYM (cpu_open_1) PARAMS ((const char *mach_name_,
						    enum cgen_endian endian_));
d1389 1
a1389 1
extern void CGEN_SYM (cpu_close) PARAMS ((CGEN_CPU_DESC));
d1394 1
a1394 1
extern void CGEN_SYM (init_opcode_table) PARAMS ((CGEN_CPU_DESC cd_));
d1399 1
a1399 1
extern char * CGEN_SYM(build_insn_regex) PARAMS ((CGEN_INSN *insn_));
d1404 1
a1404 1
extern void CGEN_SYM (init_ibld_table) PARAMS ((CGEN_CPU_DESC cd_));
d1409 2
a1410 2
extern void CGEN_SYM (init_asm) PARAMS ((CGEN_CPU_DESC));
extern void CGEN_SYM (init_dis) PARAMS ((CGEN_CPU_DESC));
d1414 1
a1414 1
extern void CGEN_SYM (init_opinst_table) PARAMS ((CGEN_CPU_DESC cd_));
d1419 2
a1420 2
     PARAMS ((CGEN_CPU_DESC, const char *, CGEN_FIELDS *,
	      CGEN_INSN_BYTES_PTR, char **));
d1423 1
a1423 1
extern int CGEN_SYM (get_mach) PARAMS ((const char *));
d1427 3
a1429 3
     PARAMS ((CGEN_CPU_DESC, const CGEN_INSN * insn_,
	      CGEN_INSN_INT int_value_, unsigned char *bytes_value_,
	      int length_, CGEN_FIELDS *fields_, int alias_p_));
d1431 2
a1432 2
     PARAMS ((CGEN_CPU_DESC, const CGEN_INSN * insn_,
	      const CGEN_FIELDS *fields_, int *indices_));
d1434 3
a1436 3
     PARAMS ((CGEN_CPU_DESC, const CGEN_INSN *insn_,
	      CGEN_INSN_INT int_value_, unsigned char *bytes_value_,
	      int length_, int *indices_, CGEN_FIELDS *fields_));
d1441 1
a1441 1
     PARAMS ((CGEN_CPU_DESC, unsigned char *, int));
d1443 1
a1443 1
     PARAMS ((CGEN_CPU_DESC, unsigned char *, int, CGEN_INSN_INT));
d1449 1
a1449 2
extern const char * cgen_read_cpu_file
     PARAMS ((CGEN_CPU_DESC, const char * filename_));
d1452 1
a1452 1
extern void cgen_set_signed_overflow_ok PARAMS ((CGEN_CPU_DESC));
d1455 1
a1455 1
extern void cgen_clear_signed_overflow_ok PARAMS ((CGEN_CPU_DESC));
d1458 1
a1458 1
extern unsigned int cgen_signed_overflow_ok_p PARAMS ((CGEN_CPU_DESC));
@


1.17
log
@	* cgen.h: Test __BFD_H_SEEN__ rather than BFD_VERSION_DATE.
@
text
@d3 2
a4 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d624 3
a626 2
    struct cgen_maybe_multi_ifield * multi;
    struct cgen_ifld * leaf;
@


1.16
log
@2002-01-27  David O'Brien  <obrien@@FreeBSD.org>
	* cgen.h (BFD_VERSION): Use BFD_VERSION_DATE instead.

Approved by:  Nick Clifton <nickc@@cambridge.redhat.com>
              <m3k7u2g5uc.fsf@@north-pole.nickc.cambridge.redhat.com>
@
text
@d29 1
a29 1
   bfd_vma using BFD_VERSION_DATE.  */
d279 1
a279 1
#ifdef BFD_VERSION_DATE
d300 1
a300 1
#ifdef BFD_VERSION_DATE
d319 1
a319 1
#ifdef BFD_VERSION_DATE
d384 1
a384 1
#ifdef BFD_VERSION_DATE /* Don't require bfd.h unnecessarily.  */
d568 1
a568 1
#ifdef BFD_VERSION_DATE /* Don't require bfd.h unnecessarily.  */
d1256 1
a1256 1
#ifdef BFD_VERSION_DATE
d1289 1
a1289 1
#ifdef BFD_VERSION_DATE
@


1.16.10.1
log
@merge from mainline
@
text
@d29 1
a29 1
   bfd_vma using __BFD_H_SEEN__.  */
d279 1
a279 1
#ifdef __BFD_H_SEEN__
d300 1
a300 1
#ifdef __BFD_H_SEEN__
d319 1
a319 1
#ifdef __BFD_H_SEEN__
d384 1
a384 1
#ifdef __BFD_H_SEEN__ /* Don't require bfd.h unnecessarily.  */
d568 1
a568 1
#ifdef __BFD_H_SEEN__ /* Don't require bfd.h unnecessarily.  */
d1256 1
a1256 1
#ifdef __BFD_H_SEEN__
d1289 1
a1289 1
#ifdef __BFD_H_SEEN__
@


1.16.24.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d29 1
a29 1
   bfd_vma using __BFD_H_SEEN__.  */
d279 1
a279 1
#ifdef __BFD_H_SEEN__
d300 1
a300 1
#ifdef __BFD_H_SEEN__
d319 1
a319 1
#ifdef __BFD_H_SEEN__
d384 1
a384 1
#ifdef __BFD_H_SEEN__ /* Don't require bfd.h unnecessarily.  */
d568 1
a568 1
#ifdef __BFD_H_SEEN__ /* Don't require bfd.h unnecessarily.  */
d1256 1
a1256 1
#ifdef __BFD_H_SEEN__
d1289 1
a1289 1
#ifdef __BFD_H_SEEN__
@


1.16.24.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 2
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
Free Software Foundation, Inc.
d244 1
a244 1
     We don't require dis-asm.h so we use void * for the type here.
d246 1
a246 1
  void *dis_info;
d267 2
a268 2
  (CGEN_CPU_DESC, const CGEN_INSN *insn_,
   const char **strp_, CGEN_FIELDS *fields_);
d281 3
a283 3
  (CGEN_CPU_DESC, const CGEN_INSN *insn_,
   CGEN_FIELDS *fields_, CGEN_INSN_BYTES_PTR insnp_,
   bfd_vma pc_);
d302 3
a304 3
  (CGEN_CPU_DESC, const CGEN_INSN *insn_,
   CGEN_EXTRACT_INFO *ex_info_, CGEN_INSN_INT base_insn_,
   CGEN_FIELDS *fields_, bfd_vma pc_);
d321 2
a322 2
  (CGEN_CPU_DESC, void * info_, const CGEN_INSN *insn_,
   CGEN_FIELDS *fields_, bfd_vma pc_, int len_);
d386 3
a388 3
  (CGEN_CPU_DESC,
   enum cgen_parse_operand_type, const char **, int, int,
   enum cgen_parse_operand_result *, bfd_vma *);
d396 1
a396 1
  (CGEN_CPU_DESC, cgen_parse_operand_fn);
d400 1
a400 1
extern void cgen_init_parse_operand (CGEN_CPU_DESC);
d424 1
a424 1
  void *asm_data;
d455 1
a455 1
  (CGEN_CPU_DESC, const char *);
d457 1
a457 1
  (CGEN_CPU_DESC, unsigned int);
d545 1
a545 1
  (CGEN_KEYWORD *, const char *);
d550 1
a550 1
  (CGEN_KEYWORD *, int);
d554 1
a554 1
void cgen_keyword_add (CGEN_KEYWORD *, CGEN_KEYWORD_ENTRY *);
d560 1
a560 1
  (CGEN_KEYWORD *, const char *);
d562 1
a562 1
  (CGEN_KEYWORD_SEARCH *);
d567 1
a567 1
  (CGEN_CPU_DESC, const char **, CGEN_KEYWORD *, long *);
d570 1
a570 1
  (CGEN_CPU_DESC, const char **, int, long *);
d572 1
a572 1
  (CGEN_CPU_DESC, const char **, int, unsigned long *);
d574 2
a575 2
  (CGEN_CPU_DESC, const char **, int, int,
   enum cgen_parse_operand_result *, bfd_vma *);
d577 1
a577 1
  (long, long, long);
d579 1
a579 1
  (unsigned long, unsigned long, unsigned long);
d623 2
a624 3
    const void *p;
    const struct cgen_maybe_multi_ifield * multi;
    const struct cgen_ifld * leaf;
d706 1
a706 1
  (CGEN_CPU_DESC, const char *);
d708 1
a708 1
  (CGEN_CPU_DESC, int);
d1062 2
a1063 2
extern int cgen_insn_count (CGEN_CPU_DESC);
extern int cgen_macro_insn_count (CGEN_CPU_DESC);
d1127 3
a1129 4
  const char * (* fn)
     (const struct cgen_minsn_expansion *,
      const char *, const char **, int *,
      CGEN_OPERAND **);
d1147 2
a1148 2
  (CGEN_CPU_DESC, const struct cgen_minsn_expansion *,
   const char *, const char **, int *, CGEN_OPERAND **);
d1155 1
a1155 1
  (CGEN_CPU_DESC, const char *);
d1163 1
a1163 1
  (CGEN_CPU_DESC, const char *, CGEN_INSN_INT);
d1247 1
a1247 1
  void (*rebuild_tables) (CGEN_CPU_DESC);
d1254 2
a1255 1
    (CGEN_CPU_DESC, int opindex_, const char **, CGEN_FIELDS *fields_);
d1258 2
a1259 2
    (CGEN_CPU_DESC, int opindex_, CGEN_FIELDS *fields_,
     CGEN_INSN_BYTES_PTR, bfd_vma pc_);
d1261 2
a1262 2
    (CGEN_CPU_DESC, int opindex_, CGEN_EXTRACT_INFO *, CGEN_INSN_INT,
     CGEN_FIELDS *fields_, bfd_vma pc_);
d1264 2
a1265 2
    (CGEN_CPU_DESC, int opindex_, void * info_, CGEN_FIELDS * fields_,
     void const *attrs_, bfd_vma pc_, int length_);
d1281 1
a1281 1
  void (*set_fields_bitsize) (CGEN_FIELDS *fields_, int size_);
d1286 1
a1286 1
    (CGEN_CPU_DESC, int opindex_, const CGEN_FIELDS *fields_);
d1288 1
a1288 1
    (CGEN_CPU_DESC, int opindex_, CGEN_FIELDS *fields_, int value_);
d1291 1
a1291 1
    (CGEN_CPU_DESC, int opindex_, const CGEN_FIELDS *fields_);
d1293 1
a1293 1
    (CGEN_CPU_DESC, int opindex_, CGEN_FIELDS *fields_, bfd_vma value_);
d1315 1
a1315 1
  int (* asm_hash_p) (const CGEN_INSN *);
d1318 1
a1318 1
  unsigned int (* asm_hash) (const char *);
d1324 1
a1324 1
  int (* dis_hash_p) (const CGEN_INSN *);
d1327 1
a1327 1
  unsigned int (* dis_hash) (const char *, CGEN_INSN_INT);
d1382 2
a1383 2
extern CGEN_CPU_DESC CGEN_SYM (cpu_open_1)
   (const char *mach_name_, enum cgen_endian endian_);
d1387 1
a1387 1
extern void CGEN_SYM (cpu_close) (CGEN_CPU_DESC);
d1392 1
a1392 1
extern void CGEN_SYM (init_opcode_table) (CGEN_CPU_DESC cd_);
d1397 1
a1397 1
extern char * CGEN_SYM(build_insn_regex) (CGEN_INSN *insn_);
d1402 1
a1402 1
extern void CGEN_SYM (init_ibld_table) (CGEN_CPU_DESC cd_);
d1407 2
a1408 2
extern void CGEN_SYM (init_asm) (CGEN_CPU_DESC);
extern void CGEN_SYM (init_dis) (CGEN_CPU_DESC);
d1412 1
a1412 1
extern void CGEN_SYM (init_opinst_table) (CGEN_CPU_DESC cd_);
d1417 2
a1418 2
  (CGEN_CPU_DESC, const char *, CGEN_FIELDS *,
   CGEN_INSN_BYTES_PTR, char **);
d1421 1
a1421 1
extern int CGEN_SYM (get_mach) (const char *);
d1425 3
a1427 3
  (CGEN_CPU_DESC, const CGEN_INSN * insn_,
   CGEN_INSN_INT int_value_, unsigned char *bytes_value_,
   int length_, CGEN_FIELDS *fields_, int alias_p_);
d1429 2
a1430 2
  (CGEN_CPU_DESC, const CGEN_INSN * insn_,
   const CGEN_FIELDS *fields_, int *indices_);
d1432 3
a1434 3
  (CGEN_CPU_DESC, const CGEN_INSN *insn_,
   CGEN_INSN_INT int_value_, unsigned char *bytes_value_,
   int length_, int *indices_, CGEN_FIELDS *fields_);
d1439 1
a1439 1
  (CGEN_CPU_DESC, unsigned char *, int);
d1441 1
a1441 1
  (CGEN_CPU_DESC, unsigned char *, int, CGEN_INSN_INT);
d1447 2
a1448 1
extern const char * cgen_read_cpu_file (CGEN_CPU_DESC, const char * filename_);
d1451 1
a1451 1
extern void cgen_set_signed_overflow_ok (CGEN_CPU_DESC);
d1454 1
a1454 1
extern void cgen_clear_signed_overflow_ok (CGEN_CPU_DESC);
d1457 1
a1457 1
extern unsigned int cgen_signed_overflow_ok_p (CGEN_CPU_DESC);
@


1.16.22.1
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d29 1
a29 1
   bfd_vma using __BFD_H_SEEN__.  */
d279 1
a279 1
#ifdef __BFD_H_SEEN__
d300 1
a300 1
#ifdef __BFD_H_SEEN__
d319 1
a319 1
#ifdef __BFD_H_SEEN__
d384 1
a384 1
#ifdef __BFD_H_SEEN__ /* Don't require bfd.h unnecessarily.  */
d568 1
a568 1
#ifdef __BFD_H_SEEN__ /* Don't require bfd.h unnecessarily.  */
d1256 1
a1256 1
#ifdef __BFD_H_SEEN__
d1289 1
a1289 1
#ifdef __BFD_H_SEEN__
@


1.16.22.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d3 1
a3 2
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
Free Software Foundation, Inc.
d623 2
a624 3
    const PTR p;
    const struct cgen_maybe_multi_ifield * multi;
    const struct cgen_ifld * leaf;
@


1.16.22.3
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d245 1
a245 1
     We don't require dis-asm.h so we use void * for the type here.
d247 1
a247 1
  void *dis_info;
d268 2
a269 2
  (CGEN_CPU_DESC, const CGEN_INSN *insn_,
   const char **strp_, CGEN_FIELDS *fields_);
d282 3
a284 3
  (CGEN_CPU_DESC, const CGEN_INSN *insn_,
   CGEN_FIELDS *fields_, CGEN_INSN_BYTES_PTR insnp_,
   bfd_vma pc_);
d303 3
a305 3
  (CGEN_CPU_DESC, const CGEN_INSN *insn_,
   CGEN_EXTRACT_INFO *ex_info_, CGEN_INSN_INT base_insn_,
   CGEN_FIELDS *fields_, bfd_vma pc_);
d322 2
a323 2
  (CGEN_CPU_DESC, void * info_, const CGEN_INSN *insn_,
   CGEN_FIELDS *fields_, bfd_vma pc_, int len_);
d387 3
a389 3
  (CGEN_CPU_DESC,
   enum cgen_parse_operand_type, const char **, int, int,
   enum cgen_parse_operand_result *, bfd_vma *);
d397 1
a397 1
  (CGEN_CPU_DESC, cgen_parse_operand_fn);
d401 1
a401 1
extern void cgen_init_parse_operand (CGEN_CPU_DESC);
d425 1
a425 1
  void *asm_data;
d456 1
a456 1
  (CGEN_CPU_DESC, const char *);
d458 1
a458 1
  (CGEN_CPU_DESC, unsigned int);
d546 1
a546 1
  (CGEN_KEYWORD *, const char *);
d551 1
a551 1
  (CGEN_KEYWORD *, int);
d555 1
a555 1
void cgen_keyword_add (CGEN_KEYWORD *, CGEN_KEYWORD_ENTRY *);
d561 1
a561 1
  (CGEN_KEYWORD *, const char *);
d563 1
a563 1
  (CGEN_KEYWORD_SEARCH *);
d568 1
a568 1
  (CGEN_CPU_DESC, const char **, CGEN_KEYWORD *, long *);
d571 1
a571 1
  (CGEN_CPU_DESC, const char **, int, long *);
d573 1
a573 1
  (CGEN_CPU_DESC, const char **, int, unsigned long *);
d575 2
a576 2
  (CGEN_CPU_DESC, const char **, int, int,
   enum cgen_parse_operand_result *, bfd_vma *);
d578 1
a578 1
  (long, long, long);
d580 1
a580 1
  (unsigned long, unsigned long, unsigned long);
d624 1
a624 1
    const void *p;
d708 1
a708 1
  (CGEN_CPU_DESC, const char *);
d710 1
a710 1
  (CGEN_CPU_DESC, int);
d1064 2
a1065 2
extern int cgen_insn_count (CGEN_CPU_DESC);
extern int cgen_macro_insn_count (CGEN_CPU_DESC);
d1129 3
a1131 4
  const char * (* fn)
     (const struct cgen_minsn_expansion *,
      const char *, const char **, int *,
      CGEN_OPERAND **);
d1149 2
a1150 2
  (CGEN_CPU_DESC, const struct cgen_minsn_expansion *,
   const char *, const char **, int *, CGEN_OPERAND **);
d1157 1
a1157 1
  (CGEN_CPU_DESC, const char *);
d1165 1
a1165 1
  (CGEN_CPU_DESC, const char *, CGEN_INSN_INT);
d1249 1
a1249 1
  void (*rebuild_tables) (CGEN_CPU_DESC);
d1256 2
a1257 1
    (CGEN_CPU_DESC, int opindex_, const char **, CGEN_FIELDS *fields_);
d1260 2
a1261 2
    (CGEN_CPU_DESC, int opindex_, CGEN_FIELDS *fields_,
     CGEN_INSN_BYTES_PTR, bfd_vma pc_);
d1263 2
a1264 2
    (CGEN_CPU_DESC, int opindex_, CGEN_EXTRACT_INFO *, CGEN_INSN_INT,
     CGEN_FIELDS *fields_, bfd_vma pc_);
d1266 2
a1267 2
    (CGEN_CPU_DESC, int opindex_, void * info_, CGEN_FIELDS * fields_,
     void const *attrs_, bfd_vma pc_, int length_);
d1283 1
a1283 1
  void (*set_fields_bitsize) (CGEN_FIELDS *fields_, int size_);
d1288 1
a1288 1
    (CGEN_CPU_DESC, int opindex_, const CGEN_FIELDS *fields_);
d1290 1
a1290 1
    (CGEN_CPU_DESC, int opindex_, CGEN_FIELDS *fields_, int value_);
d1293 1
a1293 1
    (CGEN_CPU_DESC, int opindex_, const CGEN_FIELDS *fields_);
d1295 1
a1295 1
    (CGEN_CPU_DESC, int opindex_, CGEN_FIELDS *fields_, bfd_vma value_);
d1317 1
a1317 1
  int (* asm_hash_p) (const CGEN_INSN *);
d1320 1
a1320 1
  unsigned int (* asm_hash) (const char *);
d1326 1
a1326 1
  int (* dis_hash_p) (const CGEN_INSN *);
d1329 1
a1329 1
  unsigned int (* dis_hash) (const char *, CGEN_INSN_INT);
d1384 2
a1385 2
extern CGEN_CPU_DESC CGEN_SYM (cpu_open_1)
   (const char *mach_name_, enum cgen_endian endian_);
d1389 1
a1389 1
extern void CGEN_SYM (cpu_close) (CGEN_CPU_DESC);
d1394 1
a1394 1
extern void CGEN_SYM (init_opcode_table) (CGEN_CPU_DESC cd_);
d1399 1
a1399 1
extern char * CGEN_SYM(build_insn_regex) (CGEN_INSN *insn_);
d1404 1
a1404 1
extern void CGEN_SYM (init_ibld_table) (CGEN_CPU_DESC cd_);
d1409 2
a1410 2
extern void CGEN_SYM (init_asm) (CGEN_CPU_DESC);
extern void CGEN_SYM (init_dis) (CGEN_CPU_DESC);
d1414 1
a1414 1
extern void CGEN_SYM (init_opinst_table) (CGEN_CPU_DESC cd_);
d1419 2
a1420 2
  (CGEN_CPU_DESC, const char *, CGEN_FIELDS *,
   CGEN_INSN_BYTES_PTR, char **);
d1423 1
a1423 1
extern int CGEN_SYM (get_mach) (const char *);
d1427 3
a1429 3
  (CGEN_CPU_DESC, const CGEN_INSN * insn_,
   CGEN_INSN_INT int_value_, unsigned char *bytes_value_,
   int length_, CGEN_FIELDS *fields_, int alias_p_);
d1431 2
a1432 2
  (CGEN_CPU_DESC, const CGEN_INSN * insn_,
   const CGEN_FIELDS *fields_, int *indices_);
d1434 3
a1436 3
  (CGEN_CPU_DESC, const CGEN_INSN *insn_,
   CGEN_INSN_INT int_value_, unsigned char *bytes_value_,
   int length_, int *indices_, CGEN_FIELDS *fields_);
d1441 1
a1441 1
  (CGEN_CPU_DESC, unsigned char *, int);
d1443 1
a1443 1
  (CGEN_CPU_DESC, unsigned char *, int, CGEN_INSN_INT);
d1449 2
a1450 1
extern const char * cgen_read_cpu_file (CGEN_CPU_DESC, const char * filename_);
d1453 1
a1453 1
extern void cgen_set_signed_overflow_ok (CGEN_CPU_DESC);
d1456 1
a1456 1
extern void cgen_clear_signed_overflow_ok (CGEN_CPU_DESC);
d1459 1
a1459 1
extern unsigned int cgen_signed_overflow_ok_p (CGEN_CPU_DESC);
@


1.15
log
@[ include/opcode/ChangeLog ]

2002-01-22  Graydon Hoare  <graydon@@redhat.com>

	* cgen.h (CGEN_MAYBE_MULTI_IFLD): New structure.
	(CGEN_OPERAND): Add CGEN_MAYBE_MULTI_IFLD field.

[ opcodes/ChangeLog ]

2002-01-22  Graydon Hoare  <graydon@@redhat.com>

	* fr30-asm.c: Regenerate.
	* fr30-desc.c: Likewise.
	* fr30-desc.h: Likewise.
	* fr30-dis.c: Likewise.
	* fr30-ibld.c: Likewise.
	* fr30-opc.c: Likewise.
	* fr30-opc.h: Likewise.
	* m32r-asm.c: Likewise.
	* m32r-desc.c: Likewise.
	* m32r-desc.h: Likewise.
	* m32r-dis.c: Likewise.
	* m32r-ibld.c: Likewise.
	* m32r-opc.c: Likewise.
	* m32r-opc.h: Likewise.
	* m32r-opinst.c: Likewise.
	* openrisc-asm.c: Likewise.
	* openrisc-desc.c: Likewise.
	* openrisc-desc.h: Likewise.
	* openrisc-dis.c: Likewise.
	* openrisc-ibld.c: Likewise.
	* openrisc-opc.c: Likewise.
	* openrisc-opc.h: Likewise.
	* xstormy16-desc.c: Likewise.

[ cgen/ChangeLog ]

2002-01-22  Graydon Hoare  <graydon@@redhat.com>

	* desc-cpu.scm (ifld-number-cache): Add.
	(ifld-number): Add.
	(gen-maybe-multi-ifld-of-op): Add.
	(gen-maybe-multi-ifld): Add.
	(gen-multi-ifield-nodes): Add.
	(cgen-desc.c): Add call to gen-multi-ifield-nodes.
@
text
@d29 1
a29 1
   bfd_vma using BFD_VERSION.  */
d279 1
a279 1
#ifdef BFD_VERSION
d300 1
a300 1
#ifdef BFD_VERSION
d319 1
a319 1
#ifdef BFD_VERSION
d384 1
a384 1
#ifdef BFD_VERSION /* Don't require bfd.h unnecessarily.  */
d568 1
a568 1
#ifdef BFD_VERSION /* Don't require bfd.h unnecessarily.  */
d1256 1
a1256 1
#ifdef BFD_VERSION
d1289 1
a1289 1
#ifdef BFD_VERSION
@


1.14
log
@
2001-07-12  Jeff Johnston  <jjohnstn@@redhat.com>

        * opcode/cgen.h (CGEN_INSN): Add regex support.
        (build_insn_regex): Declare.
@
text
@d612 17
d657 5
@


1.13
log
@* some support for funny-endian 16/32-bit insn sets

[cgen/ChangeLog]
2001-07-11  Frank Ch. Eigler  <fche@@redhat.com>

        * desc-cpu.scm (-gen-mach-table-defns): Emit fourth field: the
        mach->cpu insn-chunk-bitsize.
        (-gen-cpu-open): In @@arch@@_cgen_rebuild_tables, process above new
        field toward CGEN_CPU_TABLE->insn_chunk_bitsize.
        * mach.scm (<cpu>): New field insn-chunk-bitsize.
        (-cpu-parse, -cpu-read): Parse/initialize it.
        * doc/rtl.texi (define-cpu): Document it.

[opcodes/ChangeLog]
2001-07-11  Frank Ch. Eigler  <fche@@redhat.com>

        * cgen-dis.in (print_insn): Use cgen_get_insn_value instead of
        bfd_get_bits.
        * cgen-opc.c (cgen_get_insn_value, cgen_put_insn_value): Respect
        non-zero CGEN_CPU_DESC->insn_chunk_bitsize.

[include/opcode/ChangeLog]
2001-07-11  Frank Ch. Eigler  <fche@@redhat.com>

        * cgen.h (CGEN_MACH): Add insn_chunk_bitsize field.
        (cgen_cpu_desc): Ditto.
@
text
@d1012 5
d1371 5
@


1.12
log
@Index: opcodes/ChangeLog
2001-06-13  Geoffrey Keating  <geoffk@@redhat.com>

	* cgen-asm.c (cgen_parse_keyword): When looking for the
	boundaries of a keyword, allow any special characters
	that are actually in one of the allowed keyword.
	* cgen-opc.c (cgen_keyword_add): Add any special characters
	to the nonalpha_chars field.

Index: cgen/ChangeLog
2001-06-13  Geoffrey Keating  <geoffk@@redhat.com>

	* desc.scm (<keyword> 'gen-defn): Add extra zero into
	CGEN_KEYWORD_ENTRY initializers.

Index: include/opcode/ChangeLog
2001-06-13  Geoffrey Keating  <geoffk@@redhat.com>

	* cgen.h (cgen_keyword): Add nonalpha_chars field.
@
text
@d202 2
d1170 4
@


1.11
log
@2001-05-23  John Healy  <jhealy@@redhat.com>

        * cgen.h: Increased CGEN_MAX_SYNTAX_ELEMENTS to 48.
@
text
@d516 5
@


1.10
log
@Fix typos in ChangeLogs; add coff/external.h; fix copyright dates
@
text
@d739 1
a739 1
#define CGEN_MAX_SYNTAX_ELEMENTS 40
@


1.9
log
@	Binutils portion of fix for syntax array elements when max
	operands is greater than 127.

	2001-02-02  Patrick Macdonald  <patrickm@@redhat.com>

	* cgen.h (CGEN_SYNTAX_CHAR_TYPE): Typedef as unsigned short.
	(CGEN_MAX_SYNTAX_ELEMENTS): Rename from CGEN_MAX_SYNTAX_BYTES.
	(CGEN_SYNTAX): Define using CGEN_MAX_SYNTAX_ELEMENTS.

	* fr30-desc.h: Regenerate with CGEN_MAX_SYNTAX_ELEMENTS.
	* m32r-desc.h: Regenerate.
@
text
@d3 1
a3 1
Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.8
log
@
2001-01-09  Jeff Johnston  <jjohnstn@@redhat.com>

        * cgen.h (CGEN_SYNTAX_CHAR_TYPE): New typedef based on max number
        of operands (unsigned char or unsigned short).
        (CGEN_SYNTAX): Changed to make array CGEN_SYNTAX_CHAR_TYPE.
        (CGEN_SYNTAX_CHAR): Changed to cast to unsigned char.
@
text
@d739 1
a739 1
#define CGEN_MAX_SYNTAX_BYTES 40
d743 3
a745 3
#ifdef CGEN_ACTUAL_MAX_SYNTAX_BYTES
#if CGEN_ACTUAL_MAX_SYNTAX_BYTES > CGEN_MAX_SYNTAX_BYTES
#error "CGEN_ACTUAL_MAX_SYNTAX_BYTES too high - enlarge CGEN_MAX_SYNTAX_BYTES"
a748 3
#if !defined(MAX_OPERANDS) || MAX_OPERANDS <= 127
typedef unsigned char CGEN_SYNTAX_CHAR_TYPE;
#else
a749 1
#endif
d753 1
a753 1
  CGEN_SYNTAX_CHAR_TYPE syntax[CGEN_MAX_SYNTAX_BYTES];
@


1.8.2.1
log
@Update copyright notices.
@
text
@d3 1
a3 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.7
log
@2000-07-26  Dave Brolley  <brolley@@redhat.com>

	* cgen.h (cgen_hw_lookup_by_num): Second parameter is unsigned.
@
text
@d3 1
a3 1
Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d749 5
d757 1
a757 1
  unsigned char syntax[CGEN_MAX_SYNTAX_BYTES];
d762 1
a762 1
#define CGEN_SYNTAX_CHAR(c) (c)
@


1.6
log
@Applied Stephane Carrez <Stephane.Carrez@@worldnet.fr> patches to add support
for m68hc11 and m68hc12 processors.
@
text
@d455 1
a455 1
     PARAMS ((CGEN_CPU_DESC, int));
@


1.5
log
@* cgen/opcodes fix
* approved by nickc

[opcodes/ChangeLog]
2000-05-16  Frank Ch. Eigler  <fche@@redhat.com>

	* fr30-desc.h: Partially regenerated to account for changed
	CGEN_MAX_* -> CGEN_ACTUAL_MAX_* macros.
	* m32r-desc.h: Ditto.

[include/opcode/ChangeLog]
2000-05-16  Frank Ch. Eigler  <fche@@redhat.com>

	* cgen.h (CGEN_MAX_SYNTAX_BYTES): Increase to 32.  Check that
	it exceeds CGEN_ACTUAL_MAX_SYNTAX_BYTES, if set.
	(CGEN_MAX_IFMT_OPERANDS): Increase to 16.  Check that it exceeds
	CGEN_ACTUAL_MAX_IFMT_OPERANDS, if set.
@
text
@d739 1
a739 1
#define CGEN_MAX_SYNTAX_BYTES 32
@


1.4
log
@Rename 'flags' to 'signed_overflow_ok_p'
@
text
@d738 9
a746 2
#ifndef CGEN_MAX_SYNTAX_BYTES
#define CGEN_MAX_SYNTAX_BYTES 16
d749 1
d835 9
a843 2
#ifndef CGEN_MAX_IFMT_OPERANDS
#define CGEN_MAX_IFMT_OPERANDS 1
d845 1
@


1.3
log
@2000-02-24  Andrew Haley  <aph@@cygnus.com>

        * cgen.h (CGEN_INSN_MACH_HAS_P): New macro.
        (CGEN_CPU_TABLE): flags: new field.
        Add prototypes for new functions.
@
text
@d1285 2
a1286 3
  /* Customisation for CGEN operations.  */
#define CGEN_FLAG_SIGNED_OVERFLOW_OK	(1 << 0)
  unsigned int flags;
a1388 6

/* Set the flags in the CGEN_CPU_DESC.  */
extern void cgen_set_flags PARAMS ((CGEN_CPU_DESC, unsigned int));

/* Read the flags in the CGEN_CPU_DESC.  */
extern unsigned int cgen_get_flags PARAMS ((CGEN_CPU_DESC));
@


1.2
log
@* cgen.h (CGEN_INSN_MACH_HAS_P): New macro.
@
text
@d3 1
a3 1
Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
d1284 5
d1390 15
@


1.1
log
@Initial revision
@
text
@d1040 6
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

