head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.20.24.52;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.17;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.30;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.54;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.37;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.00;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@/* 
 * tkUnixMenu.c --
 *
 *	This module implements the UNIX platform-specific features of menus.
 *
 * Copyright (c) 1996-1998 by Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkUnixMenu.c,v 1.7 2002/02/22 13:13:13 dkf Exp $
 */

#include "tkPort.h"
#include "default.h"
#include "tkInt.h"
#include "tkUnixInt.h"
#include "tkMenu.h"

/*
 * Constants used for menu drawing.
 */

#define MENU_MARGIN_WIDTH	2
#define MENU_DIVIDER_HEIGHT	2

/*
 * Platform specific flags for Unix.
 */

#define ENTRY_HELP_MENU		ENTRY_PLATFORM_FLAG1

/*
 * Procedures used internally.
 */

static void		SetHelpMenu _ANSI_ARGS_((TkMenu *menuPtr));
static void		DrawMenuEntryAccelerator _ANSI_ARGS_((
			    TkMenu *menuPtr, TkMenuEntry *mePtr, 
			    Drawable d, GC gc, Tk_Font tkfont,
			    CONST Tk_FontMetrics *fmPtr,
			    Tk_3DBorder activeBorder, int x, int y,
			    int width, int height, int drawArrow));
static void		DrawMenuEntryBackground _ANSI_ARGS_((
			    TkMenu *menuPtr, TkMenuEntry *mePtr,
			    Drawable d, Tk_3DBorder activeBorder,
			    Tk_3DBorder bgBorder, int x, int y,
			    int width, int heigth));
static void		DrawMenuEntryIndicator _ANSI_ARGS_((
			    TkMenu *menuPtr, TkMenuEntry *mePtr,
			    Drawable d, GC gc, GC indicatorGC, 
			    Tk_Font tkfont,
			    CONST Tk_FontMetrics *fmPtr, int x, int y,
			    int width, int height));
static void		DrawMenuEntryLabel _ANSI_ARGS_((
			    TkMenu * menuPtr, TkMenuEntry *mePtr, Drawable d,
			    GC gc, Tk_Font tkfont,
			    CONST Tk_FontMetrics *fmPtr, int x, int y,
			    int width, int height));
static void		DrawMenuSeparator _ANSI_ARGS_((TkMenu *menuPtr,
			    TkMenuEntry *mePtr, Drawable d, GC gc, 
			    Tk_Font tkfont, CONST Tk_FontMetrics *fmPtr, 
			    int x, int y, int width, int height));
static void		DrawTearoffEntry _ANSI_ARGS_((TkMenu *menuPtr,
			    TkMenuEntry *mePtr, Drawable d, GC gc, 
			    Tk_Font tkfont, CONST Tk_FontMetrics *fmPtr, 
			    int x, int y, int width, int height));
static void		DrawMenuUnderline _ANSI_ARGS_((TkMenu *menuPtr,
			    TkMenuEntry *mePtr, Drawable d, GC gc,
			    Tk_Font tkfont, CONST Tk_FontMetrics *fmPtr, int x,
			    int y, int width, int height));
static void		GetMenuAccelGeometry _ANSI_ARGS_((TkMenu *menuPtr,
			    TkMenuEntry *mePtr, Tk_Font tkfont,
			    CONST Tk_FontMetrics *fmPtr, int *widthPtr,
			    int *heightPtr));
static void		GetMenuLabelGeometry _ANSI_ARGS_((TkMenuEntry *mePtr,
			    Tk_Font tkfont, CONST Tk_FontMetrics *fmPtr,
			    int *widthPtr, int *heightPtr));
static void		GetMenuIndicatorGeometry _ANSI_ARGS_((
			    TkMenu *menuPtr, TkMenuEntry *mePtr, 
			    Tk_Font tkfont, CONST Tk_FontMetrics *fmPtr, 
			    int *widthPtr, int *heightPtr));
static void		GetMenuSeparatorGeometry _ANSI_ARGS_((
			    TkMenu *menuPtr, TkMenuEntry *mePtr,
			    Tk_Font tkfont, CONST Tk_FontMetrics *fmPtr,
			    int *widthPtr, int *heightPtr));
static void		GetTearoffEntryGeometry _ANSI_ARGS_((TkMenu *menuPtr,
			    TkMenuEntry *mePtr, Tk_Font tkfont,
			    CONST Tk_FontMetrics *fmPtr, int *widthPtr,
			    int *heightPtr));


/*
 *----------------------------------------------------------------------
 *
 * TkpNewMenu --
 *
 *	Gets the platform-specific piece of the menu. Invoked during idle
 *	after the generic part of the menu has been created.
 *
 * Results:
 *	Standard TCL error.
 *
 * Side effects:
 *	Allocates any platform specific allocations and places them
 *	in the platformData field of the menuPtr.
 *
 *----------------------------------------------------------------------
 */

int
TkpNewMenu(menuPtr)
    TkMenu *menuPtr;
{
    SetHelpMenu(menuPtr);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpDestroyMenu --
 *
 *	Destroys platform-specific menu structures. Called when the
 *	generic menu structure is destroyed for the menu.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	All platform-specific allocations are freed up.
 *
 *----------------------------------------------------------------------
 */

void
TkpDestroyMenu(menuPtr)
    TkMenu *menuPtr;
{
    /*
     * Nothing to do.
     */
}

/*
 *----------------------------------------------------------------------
 *
 * TkpDestroyMenuEntry --
 *
 *	Cleans up platform-specific menu entry items. Called when entry
 *	is destroyed in the generic code.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	All platform specific allocations are freed up.
 *
 *----------------------------------------------------------------------
 */

void
TkpDestroyMenuEntry(mEntryPtr)
    TkMenuEntry *mEntryPtr;
{
    /*
     * Nothing to do.
     */
}

/*
 *----------------------------------------------------------------------
 *
 * TkpConfigureMenuEntry --
 *
 *	Processes configuration options for menu entries. Called when
 *	the generic options are processed for the menu.
 *
 * Results:
 *	Returns standard TCL result. If TCL_ERROR is returned, then
 *	the interp's result contains an error message.
 *
 * Side effects:
 *	Configuration information get set for mePtr; old resources
 *	get freed, if any need it.
 *
 *----------------------------------------------------------------------
 */

int
TkpConfigureMenuEntry(mePtr)
    register TkMenuEntry *mePtr;	/* Information about menu entry;  may
					 * or may not already have values for
					 * some fields. */
{
    /*
     * If this is a cascade menu, and the child menu exists, check to
     * see if the child menu is a help menu.
     */

    if ((mePtr->type == CASCADE_ENTRY) && (mePtr->namePtr != NULL)) {
	TkMenuReferences *menuRefPtr;

	menuRefPtr = TkFindMenuReferencesObj(mePtr->menuPtr->interp,
		mePtr->namePtr);
	if ((menuRefPtr != NULL) && (menuRefPtr->menuPtr != NULL)) {
	    SetHelpMenu(menuRefPtr->menuPtr);
	}
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpMenuNewEntry --
 *
 *	Called when a new entry is created in a menu. Fills in platform
 *	specific data for the entry. The platformEntryData field
 *	is used to store the indicator diameter for radio button
 *	and check box entries.
 *
 * Results:
 * 	Standard TCL error.
 *
 * Side effects:
 *	None on Unix.
 *
 *----------------------------------------------------------------------
 */

int
TkpMenuNewEntry(mePtr)
    TkMenuEntry *mePtr;
{
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpSetWindowMenuBar --
 *
 *	Sets up the menu as a menubar in the given window.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Recomputes geometry of given window.
 *
 *----------------------------------------------------------------------
 */

void
TkpSetWindowMenuBar(tkwin, menuPtr)
    Tk_Window tkwin;			/* The window we are setting */
    TkMenu *menuPtr;			/* The menu we are setting */
{
    if (menuPtr == NULL) {
	TkUnixSetMenubar(tkwin, NULL);
    } else {
	TkUnixSetMenubar(tkwin, menuPtr->tkwin);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkpSetMainMenuBar --
 *
 *	Called when a toplevel widget is brought to front. On the
 *	Macintosh, sets up the menubar that goes accross the top
 *	of the main monitor. On other platforms, nothing is necessary.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Recompute geometry of given window.
 *
 *----------------------------------------------------------------------
 */

void
TkpSetMainMenubar(interp, tkwin, menuName)
    Tcl_Interp *interp;
    Tk_Window tkwin;
    char *menuName;
{
    /*
     * Nothing to do.
     */
}

/*
 *----------------------------------------------------------------------
 *
 * GetMenuIndicatorGeometry --
 *
 *	Fills out the geometry of the indicator in a menu item. Note
 *	that the mePtr->height field must have already been filled in
 *	by GetMenuLabelGeometry since this height depends on the label
 *	height.
 *
 * Results:
 *	widthPtr and heightPtr point to the new geometry values.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
GetMenuIndicatorGeometry(menuPtr, mePtr, tkfont, fmPtr, widthPtr, heightPtr)
    TkMenu *menuPtr;			/* The menu we are drawing. */
    TkMenuEntry *mePtr;			/* The entry we are interested in. */
    Tk_Font tkfont;			/* The precalculated font */
    CONST Tk_FontMetrics *fmPtr;	/* The precalculated metrics */
    int *widthPtr;			/* The resulting width */
    int *heightPtr;			/* The resulting height */
{
    if ((mePtr->type == CHECK_BUTTON_ENTRY)
	    || (mePtr->type == RADIO_BUTTON_ENTRY)) {
	if (!mePtr->hideMargin && mePtr->indicatorOn) {
	    if ((mePtr->image != NULL) || (mePtr->bitmapPtr != NULL)) {
		*widthPtr = (14 * mePtr->height) / 10;
		*heightPtr = mePtr->height;
		if (mePtr->type == CHECK_BUTTON_ENTRY) {
		    mePtr->platformEntryData = 
			    (TkMenuPlatformEntryData) ((65 * mePtr->height)
			    / 100);
		} else {
		    mePtr->platformEntryData = 
			    (TkMenuPlatformEntryData) ((75 * mePtr->height)
			    / 100);
		}	            
	    } else {
		*widthPtr = *heightPtr = mePtr->height;
		if (mePtr->type == CHECK_BUTTON_ENTRY) {
		    mePtr->platformEntryData = (TkMenuPlatformEntryData)
			((80 * mePtr->height) / 100);
		} else {
		    mePtr->platformEntryData = (TkMenuPlatformEntryData)
			mePtr->height;
		}
	    }
	} else {
	    int borderWidth;

	    Tk_GetPixelsFromObj(NULL, menuPtr->tkwin,
		    menuPtr->borderWidthPtr, &borderWidth);
	    *heightPtr = 0;
	    *widthPtr = borderWidth;
	}
    } else {
	int borderWidth;

	Tk_GetPixelsFromObj(NULL, menuPtr->tkwin, menuPtr->borderWidthPtr,
		&borderWidth);
        *heightPtr = 0;
        *widthPtr = borderWidth;
    }
}


/*
 *----------------------------------------------------------------------
 *
 * GetMenuAccelGeometry --
 *
 *	Get the geometry of the accelerator area of a menu item.
 *
 * Results:
 *	heightPtr and widthPtr are set.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
GetMenuAccelGeometry(menuPtr, mePtr, tkfont, fmPtr, widthPtr, heightPtr)
    TkMenu *menuPtr;		/* The menu was are drawing */
    TkMenuEntry *mePtr;		/* The entry we are getting the geometry for */
    Tk_Font tkfont;		/* The precalculated font */
    CONST Tk_FontMetrics *fmPtr;/* The precalculated font metrics */
    int *widthPtr;		/* The width of the acclerator area */
    int *heightPtr;		/* The height of the accelerator area */
{
    *heightPtr = fmPtr->linespace;
    if (mePtr->type == CASCADE_ENTRY) {
    	*widthPtr = 2 * CASCADE_ARROW_WIDTH;
    } else if ((menuPtr->menuType != MENUBAR)
	    && (mePtr->accelPtr != NULL)) {
	char *accel = Tcl_GetStringFromObj(mePtr->accelPtr, NULL);
	
    	*widthPtr = Tk_TextWidth(tkfont, accel, mePtr->accelLength);
    } else {
    	*widthPtr = 0;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * DrawMenuEntryBackground --
 *
 *	This procedure draws the background part of a menu.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Commands are output to X to display the menu in its
 *	current mode.
 *
 *----------------------------------------------------------------------
 */

static void
DrawMenuEntryBackground(menuPtr, mePtr, d, activeBorder, bgBorder, x, y,
	width, height)
    TkMenu *menuPtr;		/* The menu we are drawing */
    TkMenuEntry *mePtr;		/* The entry we are drawing. */
    Drawable d;			/* The drawable we are drawing into */
    Tk_3DBorder activeBorder;	/* The border for an active item */
    Tk_3DBorder bgBorder;	/* The background border */
    int x;			/* Left coordinate of entry rect */
    int y;			/* Right coordinate of entry rect */
    int width;			/* Width of entry rect */
    int height;			/* Height of entry rect */
{
    if (mePtr->state == ENTRY_ACTIVE) {
	int relief;
	int activeBorderWidth;

    	bgBorder = activeBorder;

	if ((menuPtr->menuType == MENUBAR)
		&& ((menuPtr->postedCascade == NULL)
		|| (menuPtr->postedCascade != mePtr))) {
	    relief = TK_RELIEF_FLAT;
	} else {
	    relief = TK_RELIEF_RAISED;
	}

	Tk_GetPixelsFromObj(NULL, menuPtr->tkwin,
		menuPtr->activeBorderWidthPtr, &activeBorderWidth);
	Tk_Fill3DRectangle(menuPtr->tkwin, d, bgBorder, x, y, width, height,
		activeBorderWidth, relief);
    } else {
	Tk_Fill3DRectangle(menuPtr->tkwin, d, bgBorder, x, y, width, height,
		0, TK_RELIEF_FLAT);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * DrawMenuEntryAccelerator --
 *
 *	This procedure draws the background part of a menu.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Commands are output to X to display the menu in its
 *	current mode.
 *
 *----------------------------------------------------------------------
 */

static void
DrawMenuEntryAccelerator(menuPtr, mePtr, d, gc, tkfont, fmPtr, activeBorder,
	x, y, width, height, drawArrow)
    TkMenu *menuPtr;			/* The menu we are drawing */
    TkMenuEntry *mePtr;			/* The entry we are drawing */
    Drawable d;				/* The drawable we are drawing into */
    GC gc;				/* The precalculated gc to draw with */
    Tk_Font tkfont;			/* The precalculated font */
    CONST Tk_FontMetrics *fmPtr;	/* The precalculated metrics */
    Tk_3DBorder activeBorder;		/* The border for an active item */
    int x;				/* Left coordinate of entry rect */
    int y;				/* Top coordinate of entry rect */
    int width;				/* Width of entry */
    int height;				/* Height of entry */
    int drawArrow;			/* Whether or not to draw arrow. */
{
    XPoint points[3];
    int borderWidth, activeBorderWidth;
    
    /*
     * Draw accelerator or cascade arrow.
     */

    if (menuPtr->menuType == MENUBAR) {
	return;
    }

    Tk_GetPixelsFromObj(NULL, menuPtr->tkwin, menuPtr->borderWidthPtr,
	    &borderWidth);
    Tk_GetPixelsFromObj(NULL, menuPtr->tkwin, menuPtr->activeBorderWidthPtr,
	    &activeBorderWidth);
    if ((mePtr->type == CASCADE_ENTRY) && drawArrow) {
    	points[0].x = x + width - borderWidth - activeBorderWidth
	        - CASCADE_ARROW_WIDTH;
    	points[0].y = y + (height - CASCADE_ARROW_HEIGHT)/2;
    	points[1].x = points[0].x;
    	points[1].y = points[0].y + CASCADE_ARROW_HEIGHT;
    	points[2].x = points[0].x + CASCADE_ARROW_WIDTH;
    	points[2].y = points[0].y + CASCADE_ARROW_HEIGHT/2;
    	Tk_Fill3DPolygon(menuPtr->tkwin, d, activeBorder, points, 3,
		DECORATION_BORDER_WIDTH,
	    	(menuPtr->postedCascade == mePtr)
	    	? TK_RELIEF_SUNKEN : TK_RELIEF_RAISED);
    } else if (mePtr->accelPtr != NULL) {
	char *accel = Tcl_GetStringFromObj(mePtr->accelPtr, NULL);
	int left = x + mePtr->labelWidth + activeBorderWidth
	        + mePtr->indicatorSpace;
	
	if (menuPtr->menuType == MENUBAR) {
	    left += 5;
	}
    	Tk_DrawChars(menuPtr->display, d, gc, tkfont, accel,
		mePtr->accelLength, left,
		(y + (height + fmPtr->ascent - fmPtr->descent) / 2));
    }
}

/*
 *----------------------------------------------------------------------
 *
 * DrawMenuEntryIndicator --
 *
 *	This procedure draws the background part of a menu.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Commands are output to X to display the menu in its
 *	current mode.
 *
 *----------------------------------------------------------------------
 */

static void
DrawMenuEntryIndicator(menuPtr, mePtr, d, gc, indicatorGC, tkfont, fmPtr,
	x, y, width, height)
    TkMenu *menuPtr;			/* The menu we are drawing */
    TkMenuEntry *mePtr;			/* The entry we are drawing */
    Drawable d;				/* The drawable to draw into */
    GC gc;				/* The gc to draw with */
    GC indicatorGC;			/* The gc that indicators draw with */
    Tk_Font tkfont;			/* The font to draw with */
    CONST Tk_FontMetrics *fmPtr;	/* The font metrics of the font */
    int x;				/* The left of the entry rect */
    int y;				/* The top of the entry rect */
    int width;				/* Width of menu entry */
    int height;				/* Height of menu entry */
{
    /*
     * Draw check-button indicator.
     */

    if ((mePtr->type == CHECK_BUTTON_ENTRY) && mePtr->indicatorOn) {
	int dim, top, left;
	int activeBorderWidth;
	Tk_3DBorder border;
	
	dim = (int) mePtr->platformEntryData;
	Tk_GetPixelsFromObj(NULL, menuPtr->tkwin,
		menuPtr->activeBorderWidthPtr, &activeBorderWidth);
	left = x + activeBorderWidth + (mePtr->indicatorSpace - dim)/2;
	if (menuPtr->menuType == MENUBAR) {
	    left += 5;
	}
	top = y + (height - dim)/2;
	border = Tk_Get3DBorderFromObj(menuPtr->tkwin,
		menuPtr->borderPtr);
	Tk_Fill3DRectangle(menuPtr->tkwin, d, border, left, top, dim,
		dim, DECORATION_BORDER_WIDTH, TK_RELIEF_SUNKEN);
	left += DECORATION_BORDER_WIDTH;
	top += DECORATION_BORDER_WIDTH;
	dim -= 2*DECORATION_BORDER_WIDTH;
	if ((dim > 0) && (mePtr->entryFlags
		& ENTRY_SELECTED)) {
	    XFillRectangle(menuPtr->display, d, indicatorGC, left, top,
		    (unsigned int) dim, (unsigned int) dim);
	}
    }

    /*
     * Draw radio-button indicator.
     */

    if ((mePtr->type == RADIO_BUTTON_ENTRY) && mePtr->indicatorOn) {
	XPoint points[4];
	int radius;
	Tk_3DBorder border;

	border = Tk_Get3DBorderFromObj(menuPtr->tkwin, 
		menuPtr->borderPtr);
	radius = ((int) mePtr->platformEntryData)/2;
	points[0].x = x + (mePtr->indicatorSpace
		- (int) mePtr->platformEntryData)/2;
	points[0].y = y + (height)/2;
	points[1].x = points[0].x + radius;
	points[1].y = points[0].y + radius;
	points[2].x = points[1].x + radius;
	points[2].y = points[0].y;
	points[3].x = points[1].x;
	points[3].y = points[0].y - radius;
	if (mePtr->entryFlags & ENTRY_SELECTED) {
	    XFillPolygon(menuPtr->display, d, indicatorGC, points, 4,
		    Convex, CoordModeOrigin);
	} else {
	    Tk_Fill3DPolygon(menuPtr->tkwin, d, border, points, 4,
		    DECORATION_BORDER_WIDTH, TK_RELIEF_FLAT);
	}
	Tk_Draw3DPolygon(menuPtr->tkwin, d, border, points, 4,
		DECORATION_BORDER_WIDTH, TK_RELIEF_SUNKEN);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * DrawMenuSeparator --
 *
 *	This procedure draws a separator menu item.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Commands are output to X to display the menu in its
 *	current mode.
 *
 *----------------------------------------------------------------------
 */

static void
DrawMenuSeparator(menuPtr, mePtr, d, gc, tkfont, fmPtr, x, y, width, height)
    TkMenu *menuPtr;			/* The menu we are drawing */
    TkMenuEntry *mePtr;			/* The entry we are drawing */
    Drawable d;				/* The drawable we are using */
    GC gc;				/* The gc to draw into */
    Tk_Font tkfont;			/* The font to draw with */
    CONST Tk_FontMetrics *fmPtr;	/* The font metrics from the font */
    int x;
    int y;
    int width;
    int height;
{
    XPoint points[2];
    Tk_3DBorder border;

    if (menuPtr->menuType == MENUBAR) {
	return;
    }
    
    points[0].x = x;
    points[0].y = y + height/2;
    points[1].x = width - 1;
    points[1].y = points[0].y;
    border = Tk_Get3DBorderFromObj(menuPtr->tkwin, menuPtr->borderPtr);
    Tk_Draw3DPolygon(menuPtr->tkwin, d, border, points, 2, 1,
	    TK_RELIEF_RAISED);
}

/*
 *----------------------------------------------------------------------
 *
 * DrawMenuEntryLabel --
 *
 *	This procedure draws the label part of a menu.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Commands are output to X to display the menu in its
 *	current mode.
 *
 *----------------------------------------------------------------------
 */

static void
DrawMenuEntryLabel(menuPtr, mePtr, d, gc, tkfont, fmPtr, x, y, width, height)
    TkMenu *menuPtr;		/* The menu we are drawing. */
    TkMenuEntry *mePtr;		/* The entry we are drawing. */
    Drawable d;			/* What we are drawing into. */
    GC gc;			/* The gc we are drawing into.*/
    Tk_Font tkfont;		/* The precalculated font. */
    CONST Tk_FontMetrics *fmPtr;/* The precalculated font metrics. */
    int x;			/* Left edge. */
    int y;			/* Top edge. */
    int width;			/* width of entry. */
    int height;			/* height of entry. */
{
    int indicatorSpace =  mePtr->indicatorSpace;
    int activeBorderWidth;
    int leftEdge;
    int imageHeight, imageWidth;
    int textHeight = 0, textWidth = 0;	/* stop GCC warning */
    int haveImage = 0, haveText = 0;
    int imageXOffset = 0, imageYOffset = 0;
    int textXOffset = 0, textYOffset = 0;

    Tk_GetPixelsFromObj(NULL, menuPtr->tkwin, menuPtr->activeBorderWidthPtr,
	    &activeBorderWidth);
    leftEdge = x + indicatorSpace + activeBorderWidth;
    if (menuPtr->menuType == MENUBAR) {
	leftEdge += 5;
    }
    
    /*
     * Work out what we will need to draw first.
     */

    if (mePtr->image != NULL) {
    	Tk_SizeOfImage(mePtr->image, &imageWidth, &imageHeight);
	haveImage = 1;
    } else if (mePtr->bitmapPtr != NULL) {
	Pixmap bitmap = Tk_GetBitmapFromObj(menuPtr->tkwin, mePtr->bitmapPtr);
	Tk_SizeOfBitmap(menuPtr->display, bitmap, &imageWidth, &imageHeight);
	haveImage = 1;
    }
    if (!haveImage || (mePtr->compound != COMPOUND_NONE)) {
	if (mePtr->labelLength > 0) {
	    char *label = Tcl_GetStringFromObj(mePtr->labelPtr, NULL);
	    textWidth = Tk_TextWidth(tkfont, label, mePtr->labelLength);
	    textHeight = fmPtr->linespace;
	    haveText = 1;
	}
    }
    
    /*
     * Now work out what the relative positions are.
     */

    if (haveImage && haveText) {
	int fullWidth = (imageWidth > textWidth ? imageWidth : textWidth);
	switch ((enum compound) mePtr->compound) {
	    case COMPOUND_TOP: {
		textXOffset = (fullWidth - textWidth)/2;
		textYOffset = imageHeight/2 + 2;
		imageXOffset = (fullWidth - imageWidth)/2;
		imageYOffset = -textHeight/2;
		break;
	    }
	    case COMPOUND_BOTTOM: {
		textXOffset = (fullWidth - textWidth)/2;
		textYOffset = -imageHeight/2;
		imageXOffset = (fullWidth - imageWidth)/2;
		imageYOffset = textHeight/2 + 2;
		break;
	    }
	    case COMPOUND_LEFT: {
		textXOffset = imageWidth + 2;
		textYOffset = 0;
		imageXOffset = 0;
		imageYOffset = 0;
		break;
	    }
	    case COMPOUND_RIGHT: {
		textXOffset = 0;
		textYOffset = 0;
		imageXOffset = textWidth + 2;
		imageYOffset = 0;
		break;
	    }
	    case COMPOUND_CENTER: {
		textXOffset = (fullWidth - textWidth)/2;
		textYOffset = 0;
		imageXOffset = (fullWidth - imageWidth)/2;
		imageYOffset = 0;
		break;
	    }
	    case COMPOUND_NONE: {break;}
	}
    } else {
	textXOffset = 0;
	textYOffset = 0;
	imageXOffset = 0;
	imageYOffset = 0;
    }
    
    /*
     * Draw label and/or bitmap or image for entry.
     */

    if (mePtr->image != NULL) {
    	if ((mePtr->selectImage != NULL)
	    	&& (mePtr->entryFlags & ENTRY_SELECTED)) {
	    Tk_RedrawImage(mePtr->selectImage, 0, 0,
		    imageWidth, imageHeight, d, leftEdge + imageXOffset,
		    (int) (y + (mePtr->height - imageHeight)/2 + imageYOffset));
    	} else {
	    Tk_RedrawImage(mePtr->image, 0, 0, imageWidth,
		    imageHeight, d, leftEdge + imageXOffset,
		    (int) (y + (mePtr->height - imageHeight)/2 + imageYOffset));
    	}
    } else if (mePtr->bitmapPtr != None) {
	Pixmap bitmap = Tk_GetBitmapFromObj(menuPtr->tkwin, mePtr->bitmapPtr);
	XCopyPlane(menuPtr->display, bitmap, d,	gc, 0, 0, 
		(unsigned) imageWidth, (unsigned) imageHeight, 
		leftEdge + imageXOffset,
		(int) (y + (mePtr->height - imageHeight)/2 + imageYOffset), 1);
    }
    if ((mePtr->compound != COMPOUND_NONE) || !haveImage) {
	int baseline = y + (height + fmPtr->ascent - fmPtr->descent) / 2;
    	if (mePtr->labelLength > 0) {
	    char *label = Tcl_GetStringFromObj(mePtr->labelPtr, NULL);
	    Tk_DrawChars(menuPtr->display, d, gc, tkfont, label,
		    mePtr->labelLength, leftEdge + textXOffset, 
		    baseline + textYOffset);
	    DrawMenuUnderline(menuPtr, mePtr, d, gc, tkfont, fmPtr, 
		    x + textXOffset, y + textYOffset,
		    width, height);
    	}
    }

    if (mePtr->state == ENTRY_DISABLED) {
	if (menuPtr->disabledFgPtr == NULL) {
	    XFillRectangle(menuPtr->display, d, menuPtr->disabledGC, x, y,
		    (unsigned) width, (unsigned) height);
	} else if ((mePtr->image != NULL) 
		&& (menuPtr->disabledImageGC != None)) {
	    XFillRectangle(menuPtr->display, d, menuPtr->disabledImageGC,
		    leftEdge + imageXOffset,
		    (int) (y + (mePtr->height - imageHeight)/2 + imageYOffset),
		    (unsigned) imageWidth, (unsigned) imageHeight);
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * DrawMenuUnderline --
 *
 *	On appropriate platforms, draw the underline character for the
 *	menu.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Commands are output to X to display the menu in its
 *	current mode.
 *
 *----------------------------------------------------------------------
 */

static void
DrawMenuUnderline(menuPtr, mePtr, d, gc, tkfont, fmPtr, x, y, width, height)
    TkMenu *menuPtr;			/* The menu to draw into */
    TkMenuEntry *mePtr;			/* The entry we are drawing */
    Drawable d;				/* What we are drawing into */
    GC gc;				/* The gc to draw into */
    Tk_Font tkfont;			/* The precalculated font */
    CONST Tk_FontMetrics *fmPtr;	/* The precalculated font metrics */
    int x;
    int y;
    int width;
    int height;
{
    int indicatorSpace = mePtr->indicatorSpace;

    if (mePtr->underline >= 0) {
	int activeBorderWidth;
	int leftEdge;
	char *label = Tcl_GetStringFromObj(mePtr->labelPtr, NULL);
	CONST char *start = Tcl_UtfAtIndex(label, mePtr->underline);
	CONST char *end = Tcl_UtfNext(start);

	Tk_GetPixelsFromObj(NULL, menuPtr->tkwin,
		menuPtr->activeBorderWidthPtr, &activeBorderWidth);
	leftEdge = x + indicatorSpace + activeBorderWidth;
	if (menuPtr->menuType == MENUBAR) {
	    leftEdge += 5;
	}

	Tk_UnderlineChars(menuPtr->display, d, gc, tkfont, label,
    		leftEdge, y + (height + fmPtr->ascent - fmPtr->descent) / 2,
		start - label, end - label);
    }		
}

/*
 *----------------------------------------------------------------------
 *
 * TkpPostMenu --
 *
 *	Posts a menu on the screen
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The menu is posted and handled.
 *
 *----------------------------------------------------------------------
 */

int
TkpPostMenu(interp, menuPtr, x, y)
    Tcl_Interp *interp;
    TkMenu *menuPtr;
    int x;
    int y;
{
    return TkPostTearoffMenu(interp, menuPtr, x, y);
}

/*
 *----------------------------------------------------------------------
 *
 * GetMenuSeparatorGeometry --
 *
 *	Gets the width and height of the indicator area of a menu.
 *
 * Results:
 *	widthPtr and heightPtr are set.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
GetMenuSeparatorGeometry(menuPtr, mePtr, tkfont, fmPtr, widthPtr,
	heightPtr) 
    TkMenu *menuPtr;			/* The menu we are measuring */
    TkMenuEntry *mePtr;			/* The entry we are measuring */
    Tk_Font tkfont;			/* The precalculated font */
    CONST Tk_FontMetrics *fmPtr;	/* The precalcualted font metrics */
    int *widthPtr;			/* The resulting width */
    int *heightPtr;			/* The resulting height */
{
    *widthPtr = 0;
    *heightPtr = fmPtr->linespace;
}

/*
 *----------------------------------------------------------------------
 *
 * GetTearoffEntryGeometry --
 *
 *	Gets the width and height of the indicator area of a menu.
 *
 * Results:
 *	widthPtr and heightPtr are set.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
GetTearoffEntryGeometry(menuPtr, mePtr, tkfont, fmPtr, widthPtr, heightPtr)
    TkMenu *menuPtr;			/* The menu we are drawing */
    TkMenuEntry *mePtr;			/* The entry we are measuring */
    Tk_Font tkfont;			/* The precalculated font */
    CONST Tk_FontMetrics *fmPtr;	/* The precalculated font metrics */
    int *widthPtr;			/* The resulting width */
    int *heightPtr;			/* The resulting height */
{
    if (menuPtr->menuType != MASTER_MENU) {
	*heightPtr = 0;
	*widthPtr = 0;
    } else {
	*heightPtr = fmPtr->linespace;
	*widthPtr = Tk_TextWidth(tkfont, "W", 1);
    }
}

/*
 *--------------------------------------------------------------
 *
 * TkpComputeMenubarGeometry --
 *
 *	This procedure is invoked to recompute the size and
 *	layout of a menu that is a menubar clone.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Fields of menu entries are changed to reflect their
 *	current positions, and the size of the menu window
 *	itself may be changed.
 *
 *--------------------------------------------------------------
 */

void
TkpComputeMenubarGeometry(menuPtr)
    TkMenu *menuPtr;		/* Structure describing menu. */
{
    Tk_Font tkfont;
    Tk_FontMetrics menuMetrics, entryMetrics, *fmPtr;
    int width, height;
    int i, j;
    int x, y, currentRowHeight, maxWidth;
    int maxWindowWidth;
    int lastRowBreak;
    int helpMenuIndex = -1;
    TkMenuEntry *mePtr;
    int lastEntry;
    Tk_Font menuFont;
    int borderWidth;
    int activeBorderWidth;
    
    if (menuPtr->tkwin == NULL) {
	return;
    }

    Tk_GetPixelsFromObj(NULL, menuPtr->tkwin, menuPtr->borderWidthPtr,
	    &borderWidth);
    Tk_GetPixelsFromObj(NULL, menuPtr->tkwin, menuPtr->activeBorderWidthPtr,
	    &activeBorderWidth);
    maxWidth = 0;
    if (menuPtr->numEntries == 0) {
	height = 0;
    } else {
	int borderWidth;
	
	maxWindowWidth = Tk_Width(menuPtr->tkwin);
	if (maxWindowWidth == 1) {
	    maxWindowWidth = 0x7ffffff;
	}
	currentRowHeight = 0;
	Tk_GetPixelsFromObj(NULL, menuPtr->tkwin, menuPtr->borderWidthPtr,
		&borderWidth);
	x = y = borderWidth;
	lastRowBreak = 0;
	
	/*
	 * On the Mac especially, getting font metrics can be quite slow,
	 * so we want to do it intelligently. We are going to precalculate
	 * them and pass them down to all of the measureing and drawing
	 * routines. We will measure the font metrics of the menu once,
	 * and if an entry has a font set, we will measure it as we come
	 * to it, and then we decide which set to give the geometry routines.
	 */

	menuFont = Tk_GetFontFromObj(menuPtr->tkwin, menuPtr->fontPtr);
	Tk_GetFontMetrics(menuFont, &menuMetrics);
	
	for (i = 0; i < menuPtr->numEntries; i++) {
	    mePtr = menuPtr->entries[i];
	    mePtr->entryFlags &= ~ENTRY_LAST_COLUMN;
	    if (mePtr->fontPtr != NULL) {
		tkfont = Tk_GetFontFromObj(menuPtr->tkwin, mePtr->fontPtr);
		Tk_GetFontMetrics(tkfont, &entryMetrics);
		fmPtr = &entryMetrics;
	    } else {
		tkfont = menuFont;
		fmPtr = &menuMetrics;
	    }

	    /*
	     * For every entry, we need to check to see whether or not we
	     * wrap. If we do wrap, then we have to adjust all of the previous
	     * entries' height and y position, because when we see them
	     * the first time, we don't know how big its neighbor might
	     * be.
	     */
	    
	    if ((mePtr->type == SEPARATOR_ENTRY)
		    || (mePtr->type == TEAROFF_ENTRY)) {
		mePtr->height = mePtr->width = 0;
	    } else {
		GetMenuLabelGeometry(mePtr, tkfont, fmPtr, &width, &height);
		mePtr->height = height + 2 * activeBorderWidth + 10;
		mePtr->width = width;

		GetMenuIndicatorGeometry(menuPtr, mePtr, tkfont, fmPtr,
			&width, &height);
		mePtr->indicatorSpace = width;
		if (width > 0) {
		    mePtr->width += width;
		}
		mePtr->width += 2 * activeBorderWidth + 10;
	    }
	    if (mePtr->entryFlags & ENTRY_HELP_MENU) {
		helpMenuIndex = i;
	    } else if (x + mePtr->width + borderWidth > maxWindowWidth) {

		if (i == lastRowBreak) {
		    mePtr->y = y;
		    mePtr->x = x;
		    lastRowBreak++;
		    y += mePtr->height;
		    currentRowHeight = 0;
		} else {
		    x = borderWidth;
		    for (j = lastRowBreak; j < i; j++) {
			menuPtr->entries[j]->y = y + currentRowHeight
			        - menuPtr->entries[j]->height;
			menuPtr->entries[j]->x = x;
			x += menuPtr->entries[j]->width;
		    }
		    lastRowBreak = i;
		    y += currentRowHeight;
		    currentRowHeight = mePtr->height;
		}
		if (x > maxWidth) {
		    maxWidth = x;
		}
		x = borderWidth;
	    } else {
		x += mePtr->width;
		if (mePtr->height > currentRowHeight) {
		    currentRowHeight = mePtr->height;
		}
	    } 
	}

	lastEntry = menuPtr->numEntries - 1;
	if (helpMenuIndex == lastEntry) {
	    lastEntry--;
	}
	if ((lastEntry >= 0) && (x + menuPtr->entries[lastEntry]->width
		+ borderWidth > maxWidth)) {
	    maxWidth = x + menuPtr->entries[lastEntry]->width + borderWidth;
	}
	x = borderWidth;
	for (j = lastRowBreak; j < menuPtr->numEntries; j++) {
	    if (j == helpMenuIndex) {
		continue;
	    }
	    menuPtr->entries[j]->y = y + currentRowHeight
		    - menuPtr->entries[j]->height;
	    menuPtr->entries[j]->x = x;
	    x += menuPtr->entries[j]->width;
	}
	

	if (helpMenuIndex != -1) {
	    mePtr = menuPtr->entries[helpMenuIndex];
	    if (x + mePtr->width + borderWidth > maxWindowWidth) {
		y += currentRowHeight;
		currentRowHeight = mePtr->height;
		x = borderWidth;
	    } else if (mePtr->height > currentRowHeight) {
		currentRowHeight = mePtr->height;
	    }
	    mePtr->x = maxWindowWidth - borderWidth - mePtr->width;
	    mePtr->y = y + currentRowHeight - mePtr->height;
	}
	height = y + currentRowHeight + borderWidth;
    }
    width = Tk_Width(menuPtr->tkwin);    

    /*
     * The X server doesn't like zero dimensions, so round up to at least
     * 1 (a zero-sized menu should never really occur, anyway).
     */

    if (width <= 0) {
	width = 1;
    }
    if (height <= 0) {
	height = 1;
    }
    menuPtr->totalWidth = maxWidth;
    menuPtr->totalHeight = height;
}

/*
 *----------------------------------------------------------------------
 *
 * DrawTearoffEntry --
 *
 *	This procedure draws the background part of a menu.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Commands are output to X to display the menu in its
 *	current mode.
 *
 *----------------------------------------------------------------------
 */

static void
DrawTearoffEntry(menuPtr, mePtr, d, gc, tkfont, fmPtr, x, y, width, height)
    TkMenu *menuPtr;			/* The menu we are drawing */
    TkMenuEntry *mePtr;			/* The entry we are drawing */
    Drawable d;				/* The drawable we are drawing into */
    GC gc;				/* The gc we are drawing with */
    Tk_Font tkfont;			/* The font we are drawing with */
    CONST Tk_FontMetrics *fmPtr;	/* The metrics we are drawing with */
    int x;
    int y;
    int width;
    int height;
{
    XPoint points[2];
    int segmentWidth, maxX;
    Tk_3DBorder border;

    if (menuPtr->menuType != MASTER_MENU) {
	return;
    }
    
    points[0].x = x;
    points[0].y = y + height/2;
    points[1].y = points[0].y;
    segmentWidth = 6;
    maxX  = width - 1;
    border = Tk_Get3DBorderFromObj(menuPtr->tkwin, menuPtr->borderPtr);

    while (points[0].x < maxX) {
	points[1].x = points[0].x + segmentWidth;
	if (points[1].x > maxX) {
	    points[1].x = maxX;
	}
	Tk_Draw3DPolygon(menuPtr->tkwin, d, border, points, 2, 1,
		TK_RELIEF_RAISED);
	points[0].x += 2 * segmentWidth;
    }
}

/*
 *--------------------------------------------------------------
 *
 * TkpInitializeMenuBindings --
 *
 *	For every interp, initializes the bindings for Windows
 *	menus. Does nothing on Mac or XWindows.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	C-level bindings are setup for the interp which will
 *	handle Alt-key sequences for menus without beeping
 *	or interfering with user-defined Alt-key bindings.
 *
 *--------------------------------------------------------------
 */

void
TkpInitializeMenuBindings(interp, bindingTable)
    Tcl_Interp *interp;		    /* The interpreter to set. */
    Tk_BindingTable bindingTable;   /* The table to add to. */
{
    /*
     * Nothing to do.
     */
}

/*
 *----------------------------------------------------------------------
 *
 * SetHelpMenu --
 *
 *	Given a menu, check to see whether or not it is a help menu
 *	cascade in a menubar. If it is, the entry that points to
 *	this menu will be marked.
 *
 * RESULTS:
 *	None.
 *
 * Side effects:
 *	Will set the ENTRY_HELP_MENU flag appropriately.
 *
 *----------------------------------------------------------------------
 */

static void
SetHelpMenu(menuPtr)
     TkMenu *menuPtr;		/* The menu we are checking */
{
    TkMenuEntry *cascadeEntryPtr;

    for (cascadeEntryPtr = menuPtr->menuRefPtr->parentEntryPtr;
	    cascadeEntryPtr != NULL;
	    cascadeEntryPtr = cascadeEntryPtr->nextCascadePtr) {
	if ((cascadeEntryPtr->menuPtr->menuType == MENUBAR)
		&& (cascadeEntryPtr->menuPtr->masterMenuPtr->tkwin != NULL)
		&& (menuPtr->masterMenuPtr->tkwin != NULL)) {
	    TkMenu *masterMenuPtr = cascadeEntryPtr->menuPtr->masterMenuPtr;
	    char *helpMenuName = ckalloc(strlen(Tk_PathName(
		    masterMenuPtr->tkwin)) + strlen(".help") + 1);

	    strcpy(helpMenuName, Tk_PathName(masterMenuPtr->tkwin));
	    strcat(helpMenuName, ".help");
	    if (strcmp(helpMenuName,
		    Tk_PathName(menuPtr->masterMenuPtr->tkwin)) == 0) {
		cascadeEntryPtr->entryFlags |= ENTRY_HELP_MENU;
	    } else {
		cascadeEntryPtr->entryFlags &= ~ENTRY_HELP_MENU;
	    }
	    ckfree(helpMenuName);
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkpDrawMenuEntry --
 *
 *	Draws the given menu entry at the given coordinates with the
 *	given attributes.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	X Server commands are executed to display the menu entry.
 *
 *----------------------------------------------------------------------
 */

void
TkpDrawMenuEntry(mePtr, d, tkfont, menuMetricsPtr, x, y, width, height, 
	strictMotif, drawArrow)
    TkMenuEntry *mePtr;		    /* The entry to draw */
    Drawable d;			    /* What to draw into */
    Tk_Font tkfont;		    /* Precalculated font for menu */
    CONST Tk_FontMetrics *menuMetricsPtr;
				    /* Precalculated metrics for menu */
    int x;			    /* X-coordinate of topleft of entry */
    int y;			    /* Y-coordinate of topleft of entry */
    int width;			    /* Width of the entry rectangle */
    int height;			    /* Height of the current rectangle */
    int strictMotif;		    /* Boolean flag */
    int drawArrow;		    /* Whether or not to draw the cascade
				     * arrow for cascade items. Only applies
				     * to Windows. */
{
    GC gc, indicatorGC;
    TkMenu *menuPtr = mePtr->menuPtr;
    Tk_3DBorder bgBorder, activeBorder;
    CONST Tk_FontMetrics *fmPtr;
    Tk_FontMetrics entryMetrics;
    int padY = (menuPtr->menuType == MENUBAR) ? 3 : 0;
    int adjustedY = y + padY;
    int adjustedHeight = height - 2 * padY;

    /*
     * Choose the gc for drawing the foreground part of the entry.
     */

    if ((mePtr->state == ENTRY_ACTIVE) && !strictMotif) {
	gc = mePtr->activeGC;
	if (gc == NULL) {
	    gc = menuPtr->activeGC;
	}
    } else {
    	TkMenuEntry *cascadeEntryPtr;
    	int parentDisabled = 0;
    	
    	for (cascadeEntryPtr = menuPtr->menuRefPtr->parentEntryPtr;
    		cascadeEntryPtr != NULL;
    		cascadeEntryPtr = cascadeEntryPtr->nextCascadePtr) {
	    if (cascadeEntryPtr->namePtr != NULL) {
		char *name = Tcl_GetStringFromObj(cascadeEntryPtr->namePtr,
			NULL);

		if (strcmp(name, Tk_PathName(menuPtr->tkwin)) == 0) {
		    if (cascadeEntryPtr->state == ENTRY_DISABLED) {
			parentDisabled = 1;
		    }
		    break;
    	    	}
    	    }
    	}

	if (((parentDisabled || (mePtr->state == ENTRY_DISABLED)))
		&& (menuPtr->disabledFgPtr != NULL)) {
	    gc = mePtr->disabledGC;
	    if (gc == NULL) {
		gc = menuPtr->disabledGC;
	    }
	} else {
	    gc = mePtr->textGC;
	    if (gc == NULL) {
		gc = menuPtr->textGC;
	    }
	}
    }
    indicatorGC = mePtr->indicatorGC;
    if (indicatorGC == NULL) {
	indicatorGC = menuPtr->indicatorGC;
    }

    bgBorder = Tk_Get3DBorderFromObj(menuPtr->tkwin,
	    (mePtr->borderPtr == NULL)
	    ? menuPtr->borderPtr : mePtr->borderPtr);
    if (strictMotif) {
	activeBorder = bgBorder;
    } else {
	activeBorder = Tk_Get3DBorderFromObj(menuPtr->tkwin,
	    (mePtr->activeBorderPtr == NULL)
	    ? menuPtr->activeBorderPtr : mePtr->activeBorderPtr);
    }

    if (mePtr->fontPtr == NULL) {
	fmPtr = menuMetricsPtr;
    } else {
	tkfont = Tk_GetFontFromObj(menuPtr->tkwin, mePtr->fontPtr);
	Tk_GetFontMetrics(tkfont, &entryMetrics);
	fmPtr = &entryMetrics;
    }

    /*
     * Need to draw the entire background, including padding. On Unix,
     * for menubars, we have to draw the rest of the entry taking
     * into account the padding.
     */
    
    DrawMenuEntryBackground(menuPtr, mePtr, d, activeBorder, 
	    bgBorder, x, y, width, height);
    
    if (mePtr->type == SEPARATOR_ENTRY) {
	DrawMenuSeparator(menuPtr, mePtr, d, gc, tkfont, 
		fmPtr, x, adjustedY, width, adjustedHeight);
    } else if (mePtr->type == TEAROFF_ENTRY) {
	DrawTearoffEntry(menuPtr, mePtr, d, gc, tkfont, fmPtr, x, adjustedY,
		width, adjustedHeight);
    } else {
	DrawMenuEntryLabel(menuPtr, mePtr, d, gc, tkfont, fmPtr, x, adjustedY,
		width, adjustedHeight);
	DrawMenuEntryAccelerator(menuPtr, mePtr, d, gc, tkfont, fmPtr,
		activeBorder, x, adjustedY, width, adjustedHeight, drawArrow);
	if (!mePtr->hideMargin) {
	    DrawMenuEntryIndicator(menuPtr, mePtr, d, gc, indicatorGC, tkfont,
		    fmPtr, x, adjustedY, width, adjustedHeight);
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * GetMenuLabelGeometry --
 *
 *	Figures out the size of the label portion of a menu item.
 *
 * Results:
 *	widthPtr and heightPtr are filled in with the correct geometry
 *	information.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
GetMenuLabelGeometry(mePtr, tkfont, fmPtr, widthPtr, heightPtr)
    TkMenuEntry *mePtr;			/* The entry we are computing */
    Tk_Font tkfont;			/* The precalculated font */
    CONST Tk_FontMetrics *fmPtr;	/* The precalculated metrics */
    int *widthPtr;			/* The resulting width of the label
					 * portion */
    int *heightPtr;			/* The resulting height of the label
					 * portion */
{
    TkMenu *menuPtr = mePtr->menuPtr;
    int haveImage = 0;
 
    if (mePtr->image != NULL) {
    	Tk_SizeOfImage(mePtr->image, widthPtr, heightPtr);
	haveImage = 1;
    } else if (mePtr->bitmapPtr !=  NULL) {
	Pixmap bitmap = Tk_GetBitmapFromObj(menuPtr->tkwin, mePtr->bitmapPtr);
    	Tk_SizeOfBitmap(menuPtr->display, bitmap, widthPtr, heightPtr);
	haveImage = 1;
    } else {
	*heightPtr = 0;
	*widthPtr = 0;
    }
    	
    if (haveImage && (mePtr->compound == COMPOUND_NONE)) {
	/* We don't care about the text in this case */
    } else {
	/* Either it is compound or we don't have an image */
    	if (mePtr->labelPtr != NULL) {
	    int textWidth;
	    char *label = Tcl_GetStringFromObj(mePtr->labelPtr, NULL);
	    textWidth = Tk_TextWidth(tkfont, label, mePtr->labelLength);
	    
	    if ((mePtr->compound != COMPOUND_NONE) && haveImage) {
		switch ((enum compound) mePtr->compound) {
		    case COMPOUND_TOP:
		    case COMPOUND_BOTTOM: {
			if (textWidth > *widthPtr) {
			    *widthPtr = textWidth;
			}
			/* Add text and padding */
			*heightPtr += fmPtr->linespace + 2;
			break;
		    }
		    case COMPOUND_LEFT:
		    case COMPOUND_RIGHT: {
			if (fmPtr->linespace > *heightPtr) {
			    *heightPtr = fmPtr->linespace;
			}
			/* Add text and padding */
			*widthPtr += textWidth + 2;
			break;
		    }
		    case COMPOUND_CENTER: {
			if (fmPtr->linespace > *heightPtr) {
			    *heightPtr = fmPtr->linespace;
			}
			if (textWidth > *widthPtr) {
			    *widthPtr = textWidth;
			}
			break;
		    }
		    case COMPOUND_NONE: {break;}
		}
    	} else {
		/* We don't have an image or we're not compound */
		*heightPtr = fmPtr->linespace;
		*widthPtr = textWidth;
	    }
	} else {
	    /* An empty entry still has this height */
	    *heightPtr = fmPtr->linespace;
    	}
    }
    *heightPtr += 1;
}

/*
 *--------------------------------------------------------------
 *
 * TkpComputeStandardMenuGeometry --
 *
 *	This procedure is invoked to recompute the size and
 *	layout of a menu that is not a menubar clone.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Fields of menu entries are changed to reflect their
 *	current positions, and the size of the menu window
 *	itself may be changed.
 *
 *--------------------------------------------------------------
 */

void
TkpComputeStandardMenuGeometry(
    menuPtr)		/* Structure describing menu. */
    TkMenu *menuPtr;
{
    Tk_Font tkfont, menuFont;
    Tk_FontMetrics menuMetrics, entryMetrics, *fmPtr;
    int x, y, height, width, indicatorSpace, labelWidth, accelWidth;
    int windowWidth, windowHeight, accelSpace;
    int i, j, lastColumnBreak = 0;
    TkMenuEntry *mePtr;
    int borderWidth, activeBorderWidth;
    
    if (menuPtr->tkwin == NULL) {
	return;
    }

    Tk_GetPixelsFromObj(NULL, menuPtr->tkwin, menuPtr->borderWidthPtr,
	    &borderWidth);
    Tk_GetPixelsFromObj(NULL, menuPtr->tkwin, menuPtr->activeBorderWidthPtr,
	    &activeBorderWidth);
    x = y = borderWidth;
    indicatorSpace = labelWidth = accelWidth = 0;
    windowHeight = windowWidth = 0;

    /*
     * On the Mac especially, getting font metrics can be quite slow,
     * so we want to do it intelligently. We are going to precalculate
     * them and pass them down to all of the measuring and drawing
     * routines. We will measure the font metrics of the menu once.
     * If an entry does not have its own font set, then we give
     * the geometry/drawing routines the menu's font and metrics.
     * If an entry has its own font, we will measure that font and
     * give all of the geometry/drawing the entry's font and metrics.
     */

    menuFont = Tk_GetFontFromObj(menuPtr->tkwin, menuPtr->fontPtr);
    Tk_GetFontMetrics(menuFont, &menuMetrics);
    accelSpace = Tk_TextWidth(menuFont, "M", 1);

    for (i = 0; i < menuPtr->numEntries; i++) {
	mePtr = menuPtr->entries[i];
	if (mePtr->fontPtr == NULL) {
	    tkfont = menuFont;
	    fmPtr = &menuMetrics;
	} else {
	    tkfont = Tk_GetFontFromObj(menuPtr->tkwin, mePtr->fontPtr);
	    Tk_GetFontMetrics(tkfont, &entryMetrics);
	    fmPtr = &entryMetrics;
	}

	if ((i > 0) && mePtr->columnBreak) {
	    if (accelWidth != 0) {
		labelWidth += accelSpace;
	    }
	    for (j = lastColumnBreak; j < i; j++) {
		menuPtr->entries[j]->indicatorSpace = indicatorSpace;
		menuPtr->entries[j]->labelWidth = labelWidth;
		menuPtr->entries[j]->width = indicatorSpace + labelWidth
			+ accelWidth + 2 * activeBorderWidth;
		menuPtr->entries[j]->x = x;
		menuPtr->entries[j]->entryFlags &= ~ENTRY_LAST_COLUMN;
	    }
	    x += indicatorSpace + labelWidth + accelWidth
		    + 2 * activeBorderWidth;
	    windowWidth = x;
	    indicatorSpace = labelWidth = accelWidth = 0;
	    lastColumnBreak = i;
	    y = borderWidth;
	}

	if (mePtr->type == SEPARATOR_ENTRY) {
	    GetMenuSeparatorGeometry(menuPtr, mePtr, tkfont,
	    	    fmPtr, &width, &height);
	    mePtr->height = height;
	} else if (mePtr->type == TEAROFF_ENTRY) {
	    GetTearoffEntryGeometry(menuPtr, mePtr, tkfont, 
	    	    fmPtr, &width, &height);
	    mePtr->height = height;
	    labelWidth = width;
	} else {
	    
	    /*
	     * For each entry, compute the height required by that
	     * particular entry, plus three widths:  the width of the
	     * label, the width to allow for an indicator to be displayed
	     * to the left of the label (if any), and the width of the
	     * accelerator to be displayed to the right of the label
	     * (if any).  These sizes depend, of course, on the type
	     * of the entry.
	     */
	    
	    GetMenuLabelGeometry(mePtr, tkfont, fmPtr, &width,
	    	    &height);
	    mePtr->height = height;
	    if (!mePtr->hideMargin) {
		width += MENU_MARGIN_WIDTH;
	    }
	    if (width > labelWidth) {
	    	labelWidth = width;
	    }
	
	    GetMenuAccelGeometry(menuPtr, mePtr, tkfont,
		    fmPtr, &width, &height);
	    if (height > mePtr->height) {
	    	mePtr->height = height;
	    }
	    if (!mePtr->hideMargin) {
		width += MENU_MARGIN_WIDTH;
	    }
	    if (width > accelWidth) {
	    	accelWidth = width;
	    }

	    GetMenuIndicatorGeometry(menuPtr, mePtr, tkfont, 
	    	    fmPtr, &width, &height);
	    if (height > mePtr->height) {
	    	mePtr->height = height;
	    }
	    if (!mePtr->hideMargin) {
		width += MENU_MARGIN_WIDTH;
	    }
	    if (width > indicatorSpace) {
	    	indicatorSpace = width;
	    }

	    mePtr->height += 2 * activeBorderWidth + MENU_DIVIDER_HEIGHT;
    	}
        mePtr->y = y;
	y += mePtr->height;
	if (y > windowHeight) {
	    windowHeight = y;
	}
    }

    if (accelWidth != 0) {
	labelWidth += accelSpace;
    }
    for (j = lastColumnBreak; j < menuPtr->numEntries; j++) {
	menuPtr->entries[j]->indicatorSpace = indicatorSpace;
	menuPtr->entries[j]->labelWidth = labelWidth;
	menuPtr->entries[j]->width = indicatorSpace + labelWidth
		+ accelWidth + 2 * activeBorderWidth;
	menuPtr->entries[j]->x = x;
	menuPtr->entries[j]->entryFlags |= ENTRY_LAST_COLUMN;
    }
    windowWidth = x + indicatorSpace + labelWidth + accelWidth
	    + 2 * activeBorderWidth + 2 * borderWidth;


    windowHeight += borderWidth;
    
    /*
     * The X server doesn't like zero dimensions, so round up to at least
     * 1 (a zero-sized menu should never really occur, anyway).
     */

    if (windowWidth <= 0) {
	windowWidth = 1;
    }
    if (windowHeight <= 0) {
	windowHeight = 1;
    }
    menuPtr->totalWidth = windowWidth;
    menuPtr->totalHeight = windowHeight;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpMenuNotifyToplevelCreate --
 *
 *	This routine reconfigures the menu and the clones indicated by
 *	menuName becuase a toplevel has been created and any system
 *	menus need to be created. Not applicable to UNIX.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	An idle handler is set up to do the reconfiguration.
 *
 *----------------------------------------------------------------------
 */

void
TkpMenuNotifyToplevelCreate(interp, menuName)
    Tcl_Interp *interp;			/* The interp the menu lives in. */
    char *menuName;			/* The name of the menu to 
					 * reconfigure. */
{
    /*
     * Nothing to do.
     */
}

/*
 *----------------------------------------------------------------------
 *
 * TkpMenuInit --
 *
 *	Does platform-specific initialization of menus.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
TkpMenuInit()
{
    /*
     * Nothing to do.
     */
}


/*
 *----------------------------------------------------------------------
 *
 * TkpMenuThreadInit --
 *
 *	Does platform-specific initialization of thread-specific
 *      menu state.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
TkpMenuThreadInit()
{
    /*
     * Nothing to do.
     */
}

@


1.4
log
@touched all sources to ease next import
@
text
@d11 1
a11 1
 * RCS: @@(#) $Id: tkUnixMenu.c,v 1.7.6.1 2000/05/04 21:26:30 spolk Exp $
a705 1
    int baseline;
d710 4
d723 1
a723 1
     * Draw label or bitmap or image for entry.
a725 1
    baseline = y + (height + fmPtr->ascent - fmPtr->descent) / 2;
d728 71
d802 2
a803 2
		    imageWidth, imageHeight, d, leftEdge,
	            (int) (y + (mePtr->height - imageHeight)/2));
d806 2
a807 2
		    imageHeight, d, leftEdge,
		    (int) (y + (mePtr->height - imageHeight)/2));
a809 1
    	int width, height;
d811 7
a817 5
        Tk_SizeOfBitmap(menuPtr->display,bitmap, &width, &height);
    	XCopyPlane(menuPtr->display, bitmap, d,	gc, 0, 0, (unsigned) width,
		(unsigned) height, leftEdge,
	    	(int) (y + (mePtr->height - height)/2), 1);
    } else {
d821 4
a824 2
		    mePtr->labelLength, leftEdge, baseline);
	    DrawMenuUnderline(menuPtr, mePtr, d, gc, tkfont, fmPtr, x, y,
d836 2
a837 2
		    leftEdge,
		    (int) (y + (mePtr->height - imageHeight)/2),
d880 2
a881 2
	char *start = Tcl_UtfAtIndex(label, mePtr->underline);
	char *end = Tcl_UtfNext(start);
d1476 1
d1480 1
d1484 1
d1486 3
a1488 1
    	*heightPtr = fmPtr->linespace;
d1490 4
d1495 1
d1497 1
d1499 31
a1529 1
    	    *widthPtr = Tk_TextWidth(tkfont, label, mePtr->labelLength);
d1531 7
a1537 1
    	    *widthPtr = 0;
a1806 1

@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
 * Copyright (c) 1996-1997 by Sun Microsystems, Inc.
d11 1
a11 1
 * RCS: @@(#) $Id: tkUnixMenu.c,v 1.2 1998/09/14 18:23:57 stanton Exp $
d181 1
a181 1
 *	interp->result contains an error message.
d201 1
a201 1
    if ((mePtr->type == CASCADE_ENTRY) && (mePtr->name != NULL)) {
d204 2
a205 2
	menuRefPtr = TkFindMenuReferences(mePtr->menuPtr->interp,
		mePtr->name);
d324 15
a338 9
    if (!mePtr->hideMargin && mePtr->indicatorOn &&
	    ((mePtr->type == CHECK_BUTTON_ENTRY)
	    || (mePtr->type == RADIO_BUTTON_ENTRY))) {
        if ((mePtr->image != NULL) || (mePtr->bitmap != None)) {
            *widthPtr = (14 * mePtr->height) / 10;
            *heightPtr = mePtr->height;
            if (mePtr->type == CHECK_BUTTON_ENTRY) {
    		mePtr->platformEntryData = 
			(TkMenuPlatformEntryData) ((65 * mePtr->height) / 100);
d340 3
a342 7
    	    	mePtr->platformEntryData = 
			(TkMenuPlatformEntryData) ((75 * mePtr->height) / 100);
    	    }	            
        } else {
            *widthPtr = *heightPtr = mePtr->height;
	    if (mePtr->type == CHECK_BUTTON_ENTRY) {
		mePtr->platformEntryData = (TkMenuPlatformEntryData)
d344 2
a345 2
	    } else {
		mePtr->platformEntryData = (TkMenuPlatformEntryData)
d347 1
d349 7
d358 4
d363 1
a363 1
        *widthPtr = menuPtr->borderWidth;
d396 5
a400 2
    } else if ((menuPtr->menuType != MENUBAR) && (mePtr->accel != NULL)) {
    	*widthPtr = Tk_TextWidth(tkfont, mePtr->accel, mePtr->accelLength);
d436 1
a436 1
    if (mePtr->state == tkActiveUid) {
d438 2
d449 3
a451 1
	
d453 1
a453 1
		menuPtr->activeBorderWidth, relief);
d494 1
d504 4
d509 2
a510 2
    	points[0].x = x + width - menuPtr->borderWidth
	        - menuPtr->activeBorderWidth - CASCADE_ARROW_WIDTH;
d520 3
a522 2
    } else if (mePtr->accel != NULL) {
	int left = x + mePtr->labelWidth + menuPtr->activeBorderWidth
d524 1
d528 1
a528 1
    	Tk_DrawChars(menuPtr->display, d, gc, tkfont, mePtr->accel,
a565 1

d570 4
a573 3
    if ((mePtr->type == CHECK_BUTTON_ENTRY)
	    && mePtr->indicatorOn) {
    	int dim, top, left;
d576 3
a578 2
    	left = x + menuPtr->activeBorderWidth
		+ (mePtr->indicatorSpace - dim)/2;
d582 4
a585 2
    	top = y + (height - dim)/2;
    	Tk_Fill3DRectangle(menuPtr->tkwin, d, menuPtr->border, left, top, dim,
d587 5
a591 5
    	left += DECORATION_BORDER_WIDTH;
    	top += DECORATION_BORDER_WIDTH;
    	dim -= 2*DECORATION_BORDER_WIDTH;
    	if ((dim > 0) && (mePtr->entryFlags
	    	& ENTRY_SELECTED)) {
d594 1
a594 1
    	}
d601 4
a604 4
    if ((mePtr->type == RADIO_BUTTON_ENTRY)
	    && mePtr->indicatorOn) {
    	XPoint points[4];
    	int radius;
d606 2
d609 1
a609 1
    	points[0].x = x + (mePtr->indicatorSpace
d612 11
a622 11
    	points[1].x = points[0].x + radius;
    	points[1].y = points[0].y + radius;
    	points[2].x = points[1].x + radius;
    	points[2].y = points[0].y;
    	points[3].x = points[1].x;
    	points[3].y = points[0].y - radius;
    	if (mePtr->entryFlags & ENTRY_SELECTED) {
	    XFillPolygon(menuPtr->display, d, indicatorGC, points, 4, Convex,
		    CoordModeOrigin);
    	} else {
	    Tk_Fill3DPolygon(menuPtr->tkwin, d, menuPtr->border, points, 4,
d624 3
a626 3
    	}
        Tk_Draw3DPolygon(menuPtr->tkwin, d, menuPtr->border, points, 4,
	        DECORATION_BORDER_WIDTH, TK_RELIEF_SUNKEN);
d661 1
a661 1
    int margin;
a666 1
    margin = (fmPtr->ascent + fmPtr->descent)/2;
d671 2
a672 1
    Tk_Draw3DPolygon(menuPtr->tkwin, d, menuPtr->border, points, 2, 1,
d694 11
a704 18
DrawMenuEntryLabel(
    menuPtr,			/* The menu we are drawing */
    mePtr,			/* The entry we are drawing */
    d,				/* What we are drawing into */
    gc,				/* The gc we are drawing into */
    tkfont,			/* The precalculated font */
    fmPtr,			/* The precalculated font metrics */
    x,				/* left edge */
    y,				/* right edge */
    width,			/* width of entry */
    height)			/* height of entry */
    TkMenu *menuPtr;
    TkMenuEntry *mePtr;
    Drawable d;
    GC gc;
    Tk_Font tkfont;
    CONST Tk_FontMetrics *fmPtr;
    int x, y, width, height;
d708 2
a709 1
    int leftEdge = x + indicatorSpace + menuPtr->activeBorderWidth;
d712 3
d736 1
a736 1
    } else if (mePtr->bitmap != None) {
d738 4
a741 6

        Tk_SizeOfBitmap(menuPtr->display,
	        mePtr->bitmap, &width, &height);
    	XCopyPlane(menuPtr->display,
	    	mePtr->bitmap, d,
	    	gc, 0, 0, (unsigned) width, (unsigned) height, leftEdge,
d745 3
a747 3
	    Tk_DrawChars(menuPtr->display, d, gc,
		    tkfont, mePtr->label, mePtr->labelLength,
		    leftEdge, baseline);
d753 2
a754 2
    if (mePtr->state == tkDisabledUid) {
	if (menuPtr->disabledFg == NULL) {
d799 1
d801 9
a809 1
	int leftEdge = x + indicatorSpace + menuPtr->activeBorderWidth;
d813 2
a814 2
	
    	Tk_UnderlineChars(menuPtr->display, d, gc, tkfont, mePtr->label,
d816 1
a816 1
		mePtr->underline, mePtr->underline + 1);
d906 1
a906 1
	*widthPtr = Tk_TextWidth(tkfont, "W", -1);
d937 1
a937 1
    int x, y, currentRowHeight, currentRowWidth, maxWidth;
d943 3
d951 4
d959 2
d966 3
a968 1
	x = y = menuPtr->borderWidth;
a969 1
	currentRowWidth = 0;
d979 3
a981 2
	
	Tk_GetFontMetrics(menuPtr->tkfont, &menuMetrics);
d986 2
a987 5
	    tkfont = mePtr->tkfont;
	    if (tkfont == NULL) {
		tkfont = menuPtr->tkfont;
		fmPtr = &menuMetrics;
	    } else {
d990 3
d994 1
a994 1
	    
d1007 5
a1011 2
		
		GetMenuLabelGeometry(mePtr, tkfont, fmPtr,
a1012 5
		mePtr->height = height + 2 * menuPtr->activeBorderWidth + 10;
		mePtr->width = width;
		
		GetMenuIndicatorGeometry(menuPtr, mePtr,
			tkfont, fmPtr, &width, &height);
d1017 1
a1017 1
		mePtr->width += 2 * menuPtr->activeBorderWidth + 10;
d1021 1
a1021 2
	    } else if (x + mePtr->width + menuPtr->borderWidth
		    > maxWindowWidth) {
d1030 1
a1030 1
		    x = menuPtr->borderWidth;
d1044 1
a1044 1
		x = menuPtr->borderWidth;
d1058 2
a1059 3
		+ menuPtr->borderWidth > maxWidth)) {
	    maxWidth = x + menuPtr->entries[lastEntry]->width
		    + menuPtr->borderWidth;
d1061 1
a1061 1
	x = menuPtr->borderWidth;
d1075 1
a1075 1
	    if (x + mePtr->width + menuPtr->borderWidth > maxWindowWidth) {
d1078 1
a1078 1
		x = menuPtr->borderWidth;
d1082 1
a1082 1
	    mePtr->x = maxWindowWidth - menuPtr->borderWidth - mePtr->width;
d1085 1
a1085 1
	height = y + currentRowHeight + menuPtr->borderWidth;
d1135 2
a1136 1
    int margin, segmentWidth, maxX;
a1141 1
    margin = (fmPtr->ascent + fmPtr->descent)/2;
d1147 1
d1154 1
a1154 1
	Tk_Draw3DPolygon(menuPtr->tkwin, d, menuPtr->border, points, 2, 1,
d1156 1
a1156 1
	points[0].x += 2*segmentWidth;
d1283 1
a1283 2
    if ((mePtr->state == tkActiveUid)
	    && !strictMotif) {
d1295 9
a1303 4
    	    if (strcmp(cascadeEntryPtr->name, 
    	    	    Tk_PathName(menuPtr->tkwin)) == 0) {
    	    	if (cascadeEntryPtr->state == tkDisabledUid) {
    	    	    parentDisabled = 1;
a1304 1
    	    	break;
d1308 2
a1309 2
	if (((parentDisabled || (mePtr->state == tkDisabledUid)))
		&& (menuPtr->disabledFg != NULL)) {
d1325 4
a1328 5
	    
    bgBorder = mePtr->border;
    if (bgBorder == NULL) {
	bgBorder = menuPtr->border;
    }
d1332 3
a1334 4
	activeBorder = mePtr->activeBorder;
	if (activeBorder == NULL) {
	    activeBorder = menuPtr->activeBorder;
	}
d1337 1
a1337 1
    if (mePtr->tkfont == NULL) {
d1340 1
a1340 1
	tkfont = mePtr->tkfont;
d1403 3
a1405 2
    } else if (mePtr->bitmap != (Pixmap) NULL) {
    	Tk_SizeOfBitmap(menuPtr->display, mePtr->bitmap, widthPtr, heightPtr);
d1409 4
a1412 2
    	if (mePtr->label != NULL) {
    	    *widthPtr = Tk_TextWidth(tkfont, mePtr->label, mePtr->labelLength);
d1444 1
a1444 1
    Tk_Font tkfont;
d1450 1
d1456 5
a1460 1
    x = y = menuPtr->borderWidth;
d1475 3
a1477 2
    Tk_GetFontMetrics(menuPtr->tkfont, &menuMetrics);
    accelSpace = Tk_TextWidth(menuPtr->tkfont, "M", 1);
d1481 9
a1489 9
    	tkfont = mePtr->tkfont;
    	if (tkfont == NULL) {
    	    tkfont = menuPtr->tkfont;
    	    fmPtr = &menuMetrics;
    	} else {
    	    Tk_GetFontMetrics(tkfont, &entryMetrics);
    	    fmPtr = &entryMetrics;
    	}
    	
d1498 1
a1498 1
			+ accelWidth + 2 * menuPtr->activeBorderWidth;
d1503 1
a1503 1
		    + 2 * menuPtr->activeBorderWidth;
d1507 1
a1507 1
	    y = menuPtr->borderWidth;
d1565 1
a1565 2
	    mePtr->height += 2 * menuPtr->activeBorderWidth + 
	    	    MENU_DIVIDER_HEIGHT;
d1581 1
a1581 1
		+ accelWidth + 2 * menuPtr->activeBorderWidth;
d1586 1
a1586 1
	    + 2 * menuPtr->activeBorderWidth + 2 * menuPtr->borderWidth;
d1589 1
a1589 1
    windowHeight += menuPtr->borderWidth;
d1658 28
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d6 1
a6 1
 * Copyright (c) 1996-1998 by Sun Microsystems, Inc.
d11 1
a11 1
 * RCS: @@(#) $Id: tkUnixMenu.c,v 1.7.6.1 2000/05/04 21:26:30 spolk Exp $
d181 1
a181 1
 *	the interp's result contains an error message.
d201 1
a201 1
    if ((mePtr->type == CASCADE_ENTRY) && (mePtr->namePtr != NULL)) {
d204 2
a205 2
	menuRefPtr = TkFindMenuReferencesObj(mePtr->menuPtr->interp,
		mePtr->namePtr);
d324 9
a332 15
    if ((mePtr->type == CHECK_BUTTON_ENTRY)
	    || (mePtr->type == RADIO_BUTTON_ENTRY)) {
	if (!mePtr->hideMargin && mePtr->indicatorOn) {
	    if ((mePtr->image != NULL) || (mePtr->bitmapPtr != NULL)) {
		*widthPtr = (14 * mePtr->height) / 10;
		*heightPtr = mePtr->height;
		if (mePtr->type == CHECK_BUTTON_ENTRY) {
		    mePtr->platformEntryData = 
			    (TkMenuPlatformEntryData) ((65 * mePtr->height)
			    / 100);
		} else {
		    mePtr->platformEntryData = 
			    (TkMenuPlatformEntryData) ((75 * mePtr->height)
			    / 100);
		}	            
d334 7
a340 3
		*widthPtr = *heightPtr = mePtr->height;
		if (mePtr->type == CHECK_BUTTON_ENTRY) {
		    mePtr->platformEntryData = (TkMenuPlatformEntryData)
d342 2
a343 2
		} else {
		    mePtr->platformEntryData = (TkMenuPlatformEntryData)
a344 1
		}
a345 7
	} else {
	    int borderWidth;

	    Tk_GetPixelsFromObj(NULL, menuPtr->tkwin,
		    menuPtr->borderWidthPtr, &borderWidth);
	    *heightPtr = 0;
	    *widthPtr = borderWidth;
a347 4
	int borderWidth;

	Tk_GetPixelsFromObj(NULL, menuPtr->tkwin, menuPtr->borderWidthPtr,
		&borderWidth);
d349 1
a349 1
        *widthPtr = borderWidth;
d382 2
a383 5
    } else if ((menuPtr->menuType != MENUBAR)
	    && (mePtr->accelPtr != NULL)) {
	char *accel = Tcl_GetStringFromObj(mePtr->accelPtr, NULL);
	
    	*widthPtr = Tk_TextWidth(tkfont, accel, mePtr->accelLength);
d419 1
a419 1
    if (mePtr->state == ENTRY_ACTIVE) {
a420 2
	int activeBorderWidth;

d430 1
a430 3

	Tk_GetPixelsFromObj(NULL, menuPtr->tkwin,
		menuPtr->activeBorderWidthPtr, &activeBorderWidth);
d432 1
a432 1
		activeBorderWidth, relief);
a472 1
    int borderWidth, activeBorderWidth;
a481 4
    Tk_GetPixelsFromObj(NULL, menuPtr->tkwin, menuPtr->borderWidthPtr,
	    &borderWidth);
    Tk_GetPixelsFromObj(NULL, menuPtr->tkwin, menuPtr->activeBorderWidthPtr,
	    &activeBorderWidth);
d483 2
a484 2
    	points[0].x = x + width - borderWidth - activeBorderWidth
	        - CASCADE_ARROW_WIDTH;
d494 2
a495 3
    } else if (mePtr->accelPtr != NULL) {
	char *accel = Tcl_GetStringFromObj(mePtr->accelPtr, NULL);
	int left = x + mePtr->labelWidth + activeBorderWidth
a496 1
	
d500 1
a500 1
    	Tk_DrawChars(menuPtr->display, d, gc, tkfont, accel,
d538 1
d543 3
a545 4
    if ((mePtr->type == CHECK_BUTTON_ENTRY) && mePtr->indicatorOn) {
	int dim, top, left;
	int activeBorderWidth;
	Tk_3DBorder border;
d548 2
a549 3
	Tk_GetPixelsFromObj(NULL, menuPtr->tkwin,
		menuPtr->activeBorderWidthPtr, &activeBorderWidth);
	left = x + activeBorderWidth + (mePtr->indicatorSpace - dim)/2;
d553 2
a554 4
	top = y + (height - dim)/2;
	border = Tk_Get3DBorderFromObj(menuPtr->tkwin,
		menuPtr->borderPtr);
	Tk_Fill3DRectangle(menuPtr->tkwin, d, border, left, top, dim,
d556 5
a560 5
	left += DECORATION_BORDER_WIDTH;
	top += DECORATION_BORDER_WIDTH;
	dim -= 2*DECORATION_BORDER_WIDTH;
	if ((dim > 0) && (mePtr->entryFlags
		& ENTRY_SELECTED)) {
d563 1
a563 1
	}
d570 4
a573 4
    if ((mePtr->type == RADIO_BUTTON_ENTRY) && mePtr->indicatorOn) {
	XPoint points[4];
	int radius;
	Tk_3DBorder border;
a574 2
	border = Tk_Get3DBorderFromObj(menuPtr->tkwin, 
		menuPtr->borderPtr);
d576 1
a576 1
	points[0].x = x + (mePtr->indicatorSpace
d579 11
a589 11
	points[1].x = points[0].x + radius;
	points[1].y = points[0].y + radius;
	points[2].x = points[1].x + radius;
	points[2].y = points[0].y;
	points[3].x = points[1].x;
	points[3].y = points[0].y - radius;
	if (mePtr->entryFlags & ENTRY_SELECTED) {
	    XFillPolygon(menuPtr->display, d, indicatorGC, points, 4,
		    Convex, CoordModeOrigin);
	} else {
	    Tk_Fill3DPolygon(menuPtr->tkwin, d, border, points, 4,
d591 3
a593 3
	}
	Tk_Draw3DPolygon(menuPtr->tkwin, d, border, points, 4,
		DECORATION_BORDER_WIDTH, TK_RELIEF_SUNKEN);
d628 1
a628 1
    Tk_3DBorder border;
d634 1
d639 1
a639 2
    border = Tk_Get3DBorderFromObj(menuPtr->tkwin, menuPtr->borderPtr);
    Tk_Draw3DPolygon(menuPtr->tkwin, d, border, points, 2, 1,
d661 18
a678 11
DrawMenuEntryLabel(menuPtr, mePtr, d, gc, tkfont, fmPtr, x, y, width, height)
    TkMenu *menuPtr;		/* The menu we are drawing. */
    TkMenuEntry *mePtr;		/* The entry we are drawing. */
    Drawable d;			/* What we are drawing into. */
    GC gc;			/* The gc we are drawing into.*/
    Tk_Font tkfont;		/* The precalculated font. */
    CONST Tk_FontMetrics *fmPtr;/* The precalculated font metrics. */
    int x;			/* Left edge. */
    int y;			/* Top edge. */
    int width;			/* width of entry. */
    int height;			/* height of entry. */
d682 1
a682 2
    int activeBorderWidth;
    int leftEdge;
a684 3
    Tk_GetPixelsFromObj(NULL, menuPtr->tkwin, menuPtr->activeBorderWidthPtr,
	    &activeBorderWidth);
    leftEdge = x + indicatorSpace + activeBorderWidth;
d706 1
a706 1
    } else if (mePtr->bitmapPtr != None) {
d708 6
a713 4
	Pixmap bitmap = Tk_GetBitmapFromObj(menuPtr->tkwin, mePtr->bitmapPtr);
        Tk_SizeOfBitmap(menuPtr->display,bitmap, &width, &height);
    	XCopyPlane(menuPtr->display, bitmap, d,	gc, 0, 0, (unsigned) width,
		(unsigned) height, leftEdge,
d717 3
a719 3
	    char *label = Tcl_GetStringFromObj(mePtr->labelPtr, NULL);
	    Tk_DrawChars(menuPtr->display, d, gc, tkfont, label,
		    mePtr->labelLength, leftEdge, baseline);
d725 2
a726 2
    if (mePtr->state == ENTRY_DISABLED) {
	if (menuPtr->disabledFgPtr == NULL) {
a770 1

d772 1
a772 9
	int activeBorderWidth;
	int leftEdge;
	char *label = Tcl_GetStringFromObj(mePtr->labelPtr, NULL);
	char *start = Tcl_UtfAtIndex(label, mePtr->underline);
	char *end = Tcl_UtfNext(start);

	Tk_GetPixelsFromObj(NULL, menuPtr->tkwin,
		menuPtr->activeBorderWidthPtr, &activeBorderWidth);
	leftEdge = x + indicatorSpace + activeBorderWidth;
d776 2
a777 2

	Tk_UnderlineChars(menuPtr->display, d, gc, tkfont, label,
d779 1
a779 1
		start - label, end - label);
d869 1
a869 1
	*widthPtr = Tk_TextWidth(tkfont, "W", 1);
d900 1
a900 1
    int x, y, currentRowHeight, maxWidth;
a905 3
    Tk_Font menuFont;
    int borderWidth;
    int activeBorderWidth;
a910 4
    Tk_GetPixelsFromObj(NULL, menuPtr->tkwin, menuPtr->borderWidthPtr,
	    &borderWidth);
    Tk_GetPixelsFromObj(NULL, menuPtr->tkwin, menuPtr->activeBorderWidthPtr,
	    &activeBorderWidth);
a914 2
	int borderWidth;
	
d920 1
a920 3
	Tk_GetPixelsFromObj(NULL, menuPtr->tkwin, menuPtr->borderWidthPtr,
		&borderWidth);
	x = y = borderWidth;
d922 1
d932 2
a933 3

	menuFont = Tk_GetFontFromObj(menuPtr->tkwin, menuPtr->fontPtr);
	Tk_GetFontMetrics(menuFont, &menuMetrics);
d938 5
a942 2
	    if (mePtr->fontPtr != NULL) {
		tkfont = Tk_GetFontFromObj(menuPtr->tkwin, mePtr->fontPtr);
a944 3
	    } else {
		tkfont = menuFont;
		fmPtr = &menuMetrics;
d946 1
a946 1

d959 4
a962 2
		GetMenuLabelGeometry(mePtr, tkfont, fmPtr, &width, &height);
		mePtr->height = height + 2 * activeBorderWidth + 10;
d964 3
a966 3

		GetMenuIndicatorGeometry(menuPtr, mePtr, tkfont, fmPtr,
			&width, &height);
d971 1
a971 1
		mePtr->width += 2 * activeBorderWidth + 10;
d975 2
a976 1
	    } else if (x + mePtr->width + borderWidth > maxWindowWidth) {
d985 1
a985 1
		    x = borderWidth;
d999 1
a999 1
		x = borderWidth;
d1013 3
a1015 2
		+ borderWidth > maxWidth)) {
	    maxWidth = x + menuPtr->entries[lastEntry]->width + borderWidth;
d1017 1
a1017 1
	x = borderWidth;
d1031 1
a1031 1
	    if (x + mePtr->width + borderWidth > maxWindowWidth) {
d1034 1
a1034 1
		x = borderWidth;
d1038 1
a1038 1
	    mePtr->x = maxWindowWidth - borderWidth - mePtr->width;
d1041 1
a1041 1
	height = y + currentRowHeight + borderWidth;
d1091 1
a1091 2
    int segmentWidth, maxX;
    Tk_3DBorder border;
d1097 1
a1102 1
    border = Tk_Get3DBorderFromObj(menuPtr->tkwin, menuPtr->borderPtr);
d1109 1
a1109 1
	Tk_Draw3DPolygon(menuPtr->tkwin, d, border, points, 2, 1,
d1111 1
a1111 1
	points[0].x += 2 * segmentWidth;
d1238 2
a1239 1
    if ((mePtr->state == ENTRY_ACTIVE) && !strictMotif) {
d1251 4
a1254 9
	    if (cascadeEntryPtr->namePtr != NULL) {
		char *name = Tcl_GetStringFromObj(cascadeEntryPtr->namePtr,
			NULL);

		if (strcmp(name, Tk_PathName(menuPtr->tkwin)) == 0) {
		    if (cascadeEntryPtr->state == ENTRY_DISABLED) {
			parentDisabled = 1;
		    }
		    break;
d1256 1
d1260 2
a1261 2
	if (((parentDisabled || (mePtr->state == ENTRY_DISABLED)))
		&& (menuPtr->disabledFgPtr != NULL)) {
d1277 5
a1281 4

    bgBorder = Tk_Get3DBorderFromObj(menuPtr->tkwin,
	    (mePtr->borderPtr == NULL)
	    ? menuPtr->borderPtr : mePtr->borderPtr);
d1285 4
a1288 3
	activeBorder = Tk_Get3DBorderFromObj(menuPtr->tkwin,
	    (mePtr->activeBorderPtr == NULL)
	    ? menuPtr->activeBorderPtr : mePtr->activeBorderPtr);
d1291 1
a1291 1
    if (mePtr->fontPtr == NULL) {
d1294 1
a1294 1
	tkfont = Tk_GetFontFromObj(menuPtr->tkwin, mePtr->fontPtr);
d1357 2
a1358 3
    } else if (mePtr->bitmapPtr !=  NULL) {
	Pixmap bitmap = Tk_GetBitmapFromObj(menuPtr->tkwin, mePtr->bitmapPtr);
    	Tk_SizeOfBitmap(menuPtr->display, bitmap, widthPtr, heightPtr);
d1362 2
a1363 4
    	if (mePtr->labelPtr != NULL) {
	    char *label = Tcl_GetStringFromObj(mePtr->labelPtr, NULL);
	    
    	    *widthPtr = Tk_TextWidth(tkfont, label, mePtr->labelLength);
d1395 1
a1395 1
    Tk_Font tkfont, menuFont;
a1400 1
    int borderWidth, activeBorderWidth;
d1406 1
a1406 5
    Tk_GetPixelsFromObj(NULL, menuPtr->tkwin, menuPtr->borderWidthPtr,
	    &borderWidth);
    Tk_GetPixelsFromObj(NULL, menuPtr->tkwin, menuPtr->activeBorderWidthPtr,
	    &activeBorderWidth);
    x = y = borderWidth;
d1421 2
a1422 3
    menuFont = Tk_GetFontFromObj(menuPtr->tkwin, menuPtr->fontPtr);
    Tk_GetFontMetrics(menuFont, &menuMetrics);
    accelSpace = Tk_TextWidth(menuFont, "M", 1);
d1426 9
a1434 9
	if (mePtr->fontPtr == NULL) {
	    tkfont = menuFont;
	    fmPtr = &menuMetrics;
	} else {
	    tkfont = Tk_GetFontFromObj(menuPtr->tkwin, mePtr->fontPtr);
	    Tk_GetFontMetrics(tkfont, &entryMetrics);
	    fmPtr = &entryMetrics;
	}

d1443 1
a1443 1
			+ accelWidth + 2 * activeBorderWidth;
d1448 1
a1448 1
		    + 2 * activeBorderWidth;
d1452 1
a1452 1
	    y = borderWidth;
d1510 2
a1511 1
	    mePtr->height += 2 * activeBorderWidth + MENU_DIVIDER_HEIGHT;
d1527 1
a1527 1
		+ accelWidth + 2 * activeBorderWidth;
d1532 1
a1532 1
	    + 2 * activeBorderWidth + 2 * borderWidth;
d1535 1
a1535 1
    windowHeight += borderWidth;
a1603 28


/*
 *----------------------------------------------------------------------
 *
 * TkpMenuThreadInit --
 *
 *	Does platform-specific initialization of thread-specific
 *      menu state.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
TkpMenuThreadInit()
{
    /*
     * Nothing to do.
     */
}


@


1.1.1.3
log
@import tk 8.4.0
@
text
@d11 1
a11 1
 * RCS: @@(#) $Id: tkUnixMenu.c,v 1.7 2002/02/22 13:13:13 dkf Exp $
d706 1
a710 4
    int textHeight = 0, textWidth = 0;	/* stop GCC warning */
    int haveImage = 0, haveText = 0;
    int imageXOffset = 0, imageYOffset = 0;
    int textXOffset = 0, textYOffset = 0;
d720 1
a720 1
     * Work out what we will need to draw first.
d723 1
a725 71
	haveImage = 1;
    } else if (mePtr->bitmapPtr != NULL) {
	Pixmap bitmap = Tk_GetBitmapFromObj(menuPtr->tkwin, mePtr->bitmapPtr);
	Tk_SizeOfBitmap(menuPtr->display, bitmap, &imageWidth, &imageHeight);
	haveImage = 1;
    }
    if (!haveImage || (mePtr->compound != COMPOUND_NONE)) {
	if (mePtr->labelLength > 0) {
	    char *label = Tcl_GetStringFromObj(mePtr->labelPtr, NULL);
	    textWidth = Tk_TextWidth(tkfont, label, mePtr->labelLength);
	    textHeight = fmPtr->linespace;
	    haveText = 1;
	}
    }
    
    /*
     * Now work out what the relative positions are.
     */

    if (haveImage && haveText) {
	int fullWidth = (imageWidth > textWidth ? imageWidth : textWidth);
	switch ((enum compound) mePtr->compound) {
	    case COMPOUND_TOP: {
		textXOffset = (fullWidth - textWidth)/2;
		textYOffset = imageHeight/2 + 2;
		imageXOffset = (fullWidth - imageWidth)/2;
		imageYOffset = -textHeight/2;
		break;
	    }
	    case COMPOUND_BOTTOM: {
		textXOffset = (fullWidth - textWidth)/2;
		textYOffset = -imageHeight/2;
		imageXOffset = (fullWidth - imageWidth)/2;
		imageYOffset = textHeight/2 + 2;
		break;
	    }
	    case COMPOUND_LEFT: {
		textXOffset = imageWidth + 2;
		textYOffset = 0;
		imageXOffset = 0;
		imageYOffset = 0;
		break;
	    }
	    case COMPOUND_RIGHT: {
		textXOffset = 0;
		textYOffset = 0;
		imageXOffset = textWidth + 2;
		imageYOffset = 0;
		break;
	    }
	    case COMPOUND_CENTER: {
		textXOffset = (fullWidth - textWidth)/2;
		textYOffset = 0;
		imageXOffset = (fullWidth - imageWidth)/2;
		imageYOffset = 0;
		break;
	    }
	    case COMPOUND_NONE: {break;}
	}
    } else {
	textXOffset = 0;
	textYOffset = 0;
	imageXOffset = 0;
	imageYOffset = 0;
    }
    
    /*
     * Draw label and/or bitmap or image for entry.
     */

    if (mePtr->image != NULL) {
d729 2
a730 2
		    imageWidth, imageHeight, d, leftEdge + imageXOffset,
		    (int) (y + (mePtr->height - imageHeight)/2 + imageYOffset));
d733 2
a734 2
		    imageHeight, d, leftEdge + imageXOffset,
		    (int) (y + (mePtr->height - imageHeight)/2 + imageYOffset));
d737 1
d739 5
a743 7
	XCopyPlane(menuPtr->display, bitmap, d,	gc, 0, 0, 
		(unsigned) imageWidth, (unsigned) imageHeight, 
		leftEdge + imageXOffset,
		(int) (y + (mePtr->height - imageHeight)/2 + imageYOffset), 1);
    }
    if ((mePtr->compound != COMPOUND_NONE) || !haveImage) {
	int baseline = y + (height + fmPtr->ascent - fmPtr->descent) / 2;
d747 2
a748 4
		    mePtr->labelLength, leftEdge + textXOffset, 
		    baseline + textYOffset);
	    DrawMenuUnderline(menuPtr, mePtr, d, gc, tkfont, fmPtr, 
		    x + textXOffset, y + textYOffset,
d760 2
a761 2
		    leftEdge + imageXOffset,
		    (int) (y + (mePtr->height - imageHeight)/2 + imageYOffset),
d804 2
a805 2
	CONST char *start = Tcl_UtfAtIndex(label, mePtr->underline);
	CONST char *end = Tcl_UtfNext(start);
a1399 1
    int haveImage = 0;
a1402 1
	haveImage = 1;
a1405 1
	haveImage = 1;
d1407 1
a1407 3
	*heightPtr = 0;
	*widthPtr = 0;
    }
a1408 4
    if (haveImage && (mePtr->compound == COMPOUND_NONE)) {
	/* We don't care about the text in this case */
    } else {
	/* Either it is compound or we don't have an image */
a1409 1
	    int textWidth;
a1410 1
	    textWidth = Tk_TextWidth(tkfont, label, mePtr->labelLength);
d1412 1
a1412 31
	    if ((mePtr->compound != COMPOUND_NONE) && haveImage) {
		switch ((enum compound) mePtr->compound) {
		    case COMPOUND_TOP:
		    case COMPOUND_BOTTOM: {
			if (textWidth > *widthPtr) {
			    *widthPtr = textWidth;
			}
			/* Add text and padding */
			*heightPtr += fmPtr->linespace + 2;
			break;
		    }
		    case COMPOUND_LEFT:
		    case COMPOUND_RIGHT: {
			if (fmPtr->linespace > *heightPtr) {
			    *heightPtr = fmPtr->linespace;
			}
			/* Add text and padding */
			*widthPtr += textWidth + 2;
			break;
		    }
		    case COMPOUND_CENTER: {
			if (fmPtr->linespace > *heightPtr) {
			    *heightPtr = fmPtr->linespace;
			}
			if (textWidth > *widthPtr) {
			    *widthPtr = textWidth;
			}
			break;
		    }
		    case COMPOUND_NONE: {break;}
		}
d1414 1
a1414 7
		/* We don't have an image or we're not compound */
		*heightPtr = fmPtr->linespace;
		*widthPtr = textWidth;
	    }
	} else {
	    /* An empty entry still has this height */
	    *heightPtr = fmPtr->linespace;
d1684 1
@


