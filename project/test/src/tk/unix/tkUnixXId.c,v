head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.20.24.52;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.17;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.30;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.54;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.37;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.02;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@/* 
 * tkUnixXId.c --
 *
 *	This file provides a replacement function for the default X
 *	resource allocator (_XAllocID).  The problem with the default
 *	allocator is that it never re-uses ids, which causes long-lived
 *	applications to crash when X resource identifiers wrap around.
 *	The replacement functions in this file re-use old identifiers
 *	to prevent this problem.
 *
 *	The code in this file is based on similar implementations by
 *	George C. Kaplan and Michael Hoegeman.
 *
 * Copyright (c) 1993 The Regents of the University of California.
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkUnixXId.c,v 1.7 2002/04/12 10:06:09 hobbs Exp $
 */

/*
 * The definition below is needed on some systems so that we can access
 * the resource_alloc field of Display structures in order to replace
 * the resource allocator.
 */

#define XLIB_ILLEGAL_ACCESS 1

#include "tkUnixInt.h"
#include "tkPort.h"

/*
 * A structure of the following type is used to hold one or more
 * available resource identifiers.  There is a list of these structures
 * for each display.
 */

#define IDS_PER_STACK 10
typedef struct TkIdStack {
    XID ids[IDS_PER_STACK];		/* Array of free identifiers. */
    int numUsed;			/* Indicates how many of the entries
					 * in ids are currently in use. */
    TkDisplay *dispPtr;			/* Display to which ids belong. */
    struct TkIdStack *nextPtr;		/* Next bunch of free identifiers
					 * for the same display. */
} TkIdStack;

/*
 * Forward declarations for procedures defined in this file:
 */

static XID		AllocXId _ANSI_ARGS_((Display *display));
static Tk_RestrictAction CheckRestrictProc _ANSI_ARGS_((
			    ClientData clientData, XEvent *eventPtr));
static void		WindowIdCleanup _ANSI_ARGS_((ClientData clientData));
static void		WindowIdCleanup2 _ANSI_ARGS_((ClientData clientData));

/*
 *----------------------------------------------------------------------
 *
 * TkInitXId --
 *
 *	This procedure is called to initialize the id allocator for
 *	a given display.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The official allocator for the display is set up to be AllocXId.
 *
 *----------------------------------------------------------------------
 */

void
TkInitXId(dispPtr)
    TkDisplay *dispPtr;			/* Tk's information about the
					 * display. */
{
    dispPtr->idStackPtr = NULL;
    dispPtr->defaultAllocProc = (XID (*) _ANSI_ARGS_((Display *display))) 
            dispPtr->display->resource_alloc;
    dispPtr->display->resource_alloc = AllocXId;
    dispPtr->windowStackPtr = NULL;
    dispPtr->idCleanupScheduled = (Tcl_TimerToken) 0;
}

/*
 *----------------------------------------------------------------------
 *
 * TkFreeXId --
 *
 *	This procedure is called to free resources for the id allocator
 *	for a given display.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Frees the id and window stack pools.
 *
 *----------------------------------------------------------------------
 */

void
TkFreeXId(dispPtr)
    TkDisplay *dispPtr;			/* Tk's information about the
					 * display. */
{
    TkIdStack *stackPtr, *freePtr;

    if (dispPtr->idCleanupScheduled) {
	Tcl_DeleteTimerHandler(dispPtr->idCleanupScheduled);
    }

    for (stackPtr = dispPtr->idStackPtr; stackPtr != NULL; ) {
	freePtr = stackPtr;
	stackPtr = stackPtr->nextPtr;
	ckfree((char *) freePtr);
    }
    dispPtr->idStackPtr = NULL;

    for (stackPtr = dispPtr->windowStackPtr; stackPtr != NULL; ) {
	freePtr = stackPtr;
	stackPtr = stackPtr->nextPtr;
	ckfree((char *) freePtr);
    }
    dispPtr->windowStackPtr = NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * AllocXId --
 *
 *	This procedure is invoked by Xlib as the resource allocator
 *	for a display.
 *
 * Results:
 *	The return value is an X resource identifier that isn't currently
 *	in use.
 *
 * Side effects:
 *	The identifier is removed from the stack of free identifiers,
 *	if it was previously on the stack.
 *
 *----------------------------------------------------------------------
 */

static XID
AllocXId(display)
    Display *display;			/* Display for which to allocate. */
{
    TkDisplay *dispPtr;
    TkIdStack *stackPtr;

    /*
     * Find Tk's information about the display.
     */

    dispPtr = TkGetDisplay(display);
    
    /*
     * If the topmost chunk on the stack is empty then free it.  Then
     * check for a free id on the stack and return it if it exists.
     */

    stackPtr = dispPtr->idStackPtr;
    if (stackPtr != NULL) {
	while (stackPtr->numUsed == 0) {
	    dispPtr->idStackPtr = stackPtr->nextPtr;
	    ckfree((char *) stackPtr);
	    stackPtr = dispPtr->idStackPtr;
	    if (stackPtr == NULL) {
		goto defAlloc;
	    }
	}
	stackPtr->numUsed--;
	return stackPtr->ids[stackPtr->numUsed];
    }

    /*
     * No free ids in the stack:  just get one from the default
     * allocator.
     */

    defAlloc:
    return (*dispPtr->defaultAllocProc)(display);
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_FreeXId --
 *
 *	This procedure is called to indicate that an X resource identifier
 *	is now free.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The identifier is added to the stack of free identifiers for its
 *	display, so that it can be re-used.
 *
 *----------------------------------------------------------------------
 */

void
Tk_FreeXId(display, xid)
    Display *display;			/* Display for which xid was
					 * allocated. */
    XID xid;				/* Identifier that is no longer
					 * in use. */
{
    TkDisplay *dispPtr;
    TkIdStack *stackPtr;

    /*
     * Find Tk's information about the display.
     */

    dispPtr = TkGetDisplay(display);

    /*
     * Add a new chunk to the stack if the current chunk is full.
     */
    
    stackPtr = dispPtr->idStackPtr;
    if ((stackPtr == NULL) || (stackPtr->numUsed >= IDS_PER_STACK)) {
	stackPtr = (TkIdStack *) ckalloc(sizeof(TkIdStack));
	stackPtr->numUsed = 0;
	stackPtr->dispPtr = dispPtr;
	stackPtr->nextPtr = dispPtr->idStackPtr;
	dispPtr->idStackPtr = stackPtr;
    }

    /*
     * Add the id to the current chunk.
     */

    stackPtr->ids[stackPtr->numUsed] = xid;
    stackPtr->numUsed++;
}

/*
 *----------------------------------------------------------------------
 *
 * TkFreeWindowId --
 *
 *	This procedure is invoked instead of TkFreeXId for window ids.
 *	See below for the reason why.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The id given by w will eventually be freed, so that it can be
 *	reused for other resources.
 *
 * Design:
 *	Freeing window ids is very tricky because there could still be
 *	events pending for a window in the event queue (or even in the
 *	server) at the time the window is destroyed.  If the window
 *	id were to get reused immediately for another window, old
 *	events could "drop in" on the new window, causing unexpected
 *	behavior.
 *
 *	Thus we have to wait to re-use a window id until we know that
 *	there are no events left for it.  Right now this is done in
 *	two steps.  First, we wait until we know that the server
 *	has seen the XDestroyWindow request, so we can be sure that
 *	it won't generate more events for the window and that any
 *	existing events are in our queue.  Second, we make sure that
 *	there are no events whatsoever in our queue (this is conservative
 *	but safe).
 *
 * 	The first step is done by remembering the request id of the
 *	XDestroyWindow request and using LastKnownRequestProcessed to
 *	see what events the server has processed.  If multiple windows
 *	get destroyed at about the same time, we just remember the
 *	most recent request number for any of them (again, conservative
 *	but safe).
 *
 *	There are a few other complications as well.  When Tk destroys a
 *	sub-tree of windows, it only issues a single XDestroyWindow call,
 *	at the very end for the root of the subtree.  We can't free any of
 *	the window ids until the final XDestroyWindow call.  To make sure
 *	that this happens, we have to keep track of deletions in progress,
 *	hence the need for the "destroyCount" field of the display.
 *
 *	One final problem.  Some servers, like Sun X11/News servers still
 *	seem to have problems with ids getting reused too quickly.  I'm
 *	not completely sure why this is a problem, but delaying the
 *	recycling of ids appears to eliminate it.  Therefore, we wait
 *	an additional few seconds, even after "the coast is clear"
 *	before reusing the ids.
 *
 *----------------------------------------------------------------------
 */

void
TkFreeWindowId(dispPtr, w)
    TkDisplay *dispPtr;		/* Display that w belongs to. */
    Window w;			/* X identifier for window on dispPtr. */
{
    TkIdStack *stackPtr;

    /*
     * Put the window id on a separate stack of window ids, rather
     * than the main stack, so it won't get reused right away.  Add
     * a new chunk to the stack if the current chunk is full.
     */

    stackPtr = dispPtr->windowStackPtr;
    if ((stackPtr == NULL) || (stackPtr->numUsed >= IDS_PER_STACK)) {
	stackPtr = (TkIdStack *) ckalloc(sizeof(TkIdStack));
	stackPtr->numUsed = 0;
	stackPtr->dispPtr = dispPtr;
	stackPtr->nextPtr = dispPtr->windowStackPtr;
	dispPtr->windowStackPtr = stackPtr;
    }

    /*
     * Add the id to the current chunk.
     */

    stackPtr->ids[stackPtr->numUsed] = w;
    stackPtr->numUsed++;

    /*
     * Schedule a call to WindowIdCleanup if one isn't already
     * scheduled.
     */

    if (!dispPtr->idCleanupScheduled) {
	dispPtr->idCleanupScheduled =
	    Tcl_CreateTimerHandler(100, WindowIdCleanup, (ClientData) dispPtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * WindowIdCleanup --
 *
 *	See if we can now free up all the accumulated ids of
 *	deleted windows.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	If it's safe to move the window ids back to the main free
 *	list, we schedule this to happen after a few mores seconds
 *	of delay.  If it's not safe to move them yet, a timer handler
 *	gets invoked to try again later.
 *
 *----------------------------------------------------------------------
 */

static void
WindowIdCleanup(clientData)
    ClientData clientData;	/* Pointer to TkDisplay for display */
{
    TkDisplay *dispPtr = (TkDisplay *) clientData;
    int anyEvents, delta;
    Tk_RestrictProc *oldProc;
    ClientData oldData;
    static Tcl_Time timeout = {0, 0};

    dispPtr->idCleanupScheduled = (Tcl_TimerToken) 0;

    /*
     * See if it's safe to recycle the window ids.  It's safe if:
     * (a) no deletions are in progress.
     * (b) the server has seen all of the requests up to the last
     *     XDestroyWindow request.
     * (c) there are no events in the event queue; the only way to
     *     test for this right now is to create a restrict proc that
     *     will filter the events, then call Tcl_DoOneEvent to see if
     *	   the procedure gets invoked.
     */

    if (dispPtr->destroyCount > 0) {
	goto tryAgain;
    }
    delta = LastKnownRequestProcessed(dispPtr->display)
	    - dispPtr->lastDestroyRequest;
    if (delta < 0) {
	XSync(dispPtr->display, False);
    }
    anyEvents = 0;
    oldProc = Tk_RestrictEvents(CheckRestrictProc, (ClientData) &anyEvents,
	    &oldData);
    TkUnixDoOneXEvent(&timeout);
    Tk_RestrictEvents(oldProc, oldData, &oldData);
    if (anyEvents) {
	goto tryAgain;
    }

    /*
     * These ids look safe to recycle, but we still need to delay a bit
     * more (see comments for TkFreeWindowId).  Schedule the final freeing.
     */

    if (dispPtr->windowStackPtr != NULL) {
	Tcl_CreateTimerHandler(5000, WindowIdCleanup2,
		(ClientData) dispPtr->windowStackPtr);
	dispPtr->windowStackPtr = NULL;
    }
    return;

    /*
     * It's still not safe to free up the ids.  Try again a bit later.
     */

    tryAgain:
    dispPtr->idCleanupScheduled =
	Tcl_CreateTimerHandler(500, WindowIdCleanup, (ClientData) dispPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * WindowIdCleanup2 --
 *
 *	This procedure is the last one in the chain that recycles
 *	window ids.  It takes all of the ids indicated by its
 *	argument and adds them back to the main id free list.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Window ids get added to the main free list for their display.
 *
 *----------------------------------------------------------------------
 */

static void
WindowIdCleanup2(clientData)
    ClientData clientData;	/* Pointer to TkIdStack list. */
{
    TkIdStack *stackPtr = (TkIdStack *) clientData;
    TkIdStack *lastPtr;

    lastPtr = stackPtr;
    while (lastPtr->nextPtr != NULL) {
	lastPtr = lastPtr->nextPtr;
    }
    lastPtr->nextPtr = stackPtr->dispPtr->idStackPtr;
    stackPtr->dispPtr->idStackPtr = stackPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * CheckRestrictProc --
 *
 *	This procedure is a restrict procedure, called by Tcl_DoOneEvent
 *	to filter X events.  All it does is to set a flag to indicate
 *	that there are X events present.
 *
 * Results:
 *	Sets the integer pointed to by the argument, then returns
 *	TK_DEFER_EVENT.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static Tk_RestrictAction
CheckRestrictProc(clientData, eventPtr)
    ClientData clientData;	/* Pointer to flag to set. */
    XEvent *eventPtr;		/* Event to filter;  not used. */
{
    int *flag = (int *) clientData;
    *flag = 1;
    return TK_DEFER_EVENT;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_GetPixmap --
 *
 *	Same as the XCreatePixmap procedure except that it manages
 *	resource identifiers better.
 *
 * Results:
 *	Returns a new pixmap.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Pixmap
Tk_GetPixmap(display, d, width, height, depth)
    Display *display;		/* Display for new pixmap. */
    Drawable d;			/* Drawable where pixmap will be used. */
    int width, height;		/* Dimensions of pixmap. */
    int depth;			/* Bits per pixel for pixmap. */
{
    return XCreatePixmap(display, d, (unsigned) width, (unsigned) height,
	    (unsigned) depth);
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_FreePixmap --
 *
 *	Same as the XFreePixmap procedure except that it also marks
 *	the resource identifier as free.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The pixmap is freed in the X server and its resource identifier
 *	is saved for re-use.
 *
 *----------------------------------------------------------------------
 */

void
Tk_FreePixmap(display, pixmap)
    Display *display;		/* Display for which pixmap was allocated. */
    Pixmap pixmap;		/* Identifier for pixmap. */
{
    XFreePixmap(display, pixmap);
    Tk_FreeXId(display, (XID) pixmap);
}

/*
 *----------------------------------------------------------------------
 *
 * TkpWindowWasRecentlyDeleted --
 *
 *	Checks whether the window was recently deleted. This is called
 *	by the generic error handler to detect asynchronous notification
 *	of errors due to operations by Tk on a window that was already
 *	deleted by the server.
 *
 * Results:
 *	1 if the window was deleted recently, 0 otherwise.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
TkpWindowWasRecentlyDeleted(win, dispPtr)
    Window win;		/* The window to check for. */
    TkDisplay *dispPtr;	/* The window belongs to this display. */
{
    TkIdStack *stackPtr;
    int i;

    for (stackPtr = dispPtr->windowStackPtr;
         stackPtr != NULL;
         stackPtr = stackPtr->nextPtr) {
        for (i = 0; i < stackPtr->numUsed; i++) {
            if ((Window) stackPtr->ids[i] == win) {
                return 1;
            }
        }
    }
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpScanWindowId --
 *
 *	Given a string, produce the corresponding Window Id.
 *
 * Results:
 *      The return value is normally TCL_OK;  in this case *idPtr
 *      will be set to the Window value equivalent to string.  If
 *      string is improperly formed then TCL_ERROR is returned and
 *      an error message will be left in the interp's result.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
TkpScanWindowId(interp, string, idPtr)
    Tcl_Interp *interp;	
    CONST char *string;
    Window *idPtr;
{
    int value;
    if (Tcl_GetInt(interp, string, &value) != TCL_OK) {
	return TCL_ERROR;
    }
    *idPtr = (Window) value;
    return TCL_OK;
}

@


1.4
log
@touched all sources to ease next import
@
text
@d20 1
a20 1
 * RCS: @@(#) $Id: tkUnixXId.c,v 1.7.6.1 2000/05/04 21:26:31 spolk Exp $
d87 44
a130 1
    dispPtr->idCleanupScheduled = 0;
d339 2
a340 2
	dispPtr->idCleanupScheduled = 1;
	Tcl_CreateTimerHandler(100, WindowIdCleanup, (ClientData) dispPtr);
d374 1
a374 1
    dispPtr->idCleanupScheduled = 0;
d421 2
a422 2
    dispPtr->idCleanupScheduled = 1;
    Tcl_CreateTimerHandler(500, WindowIdCleanup, (ClientData) dispPtr);
d579 33
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
 * Copyright (c) 1994-1995 Sun Microsystems, Inc.
d20 1
a20 1
 * RCS: @@(#) $Id: tkUnixXId.c,v 1.7 1999/01/26 04:11:43 jingham Exp $
d31 1
a31 1
#include "tkInt.h"
a32 1
#include "tkUnixInt.h"
d72 1
a72 1
 *	The official allocator for the display is set up to be Tk_AllocXID.
d537 1
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d15 1
a15 1
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
d20 1
a20 1
 * RCS: @@(#) $Id: tkUnixXId.c,v 1.7.6.1 2000/05/04 21:26:31 spolk Exp $
d31 2
a33 1
#include "tkPort.h"
d73 1
a73 1
 *	The official allocator for the display is set up to be AllocXId.
a537 1

@


1.1.1.3
log
@import tk 8.4.0
@
text
@d20 1
a20 1
 * RCS: @@(#) $Id: tkUnixXId.c,v 1.7 2002/04/12 10:06:09 hobbs Exp $
d87 1
a87 44
    dispPtr->idCleanupScheduled = (Tcl_TimerToken) 0;
}

/*
 *----------------------------------------------------------------------
 *
 * TkFreeXId --
 *
 *	This procedure is called to free resources for the id allocator
 *	for a given display.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Frees the id and window stack pools.
 *
 *----------------------------------------------------------------------
 */

void
TkFreeXId(dispPtr)
    TkDisplay *dispPtr;			/* Tk's information about the
					 * display. */
{
    TkIdStack *stackPtr, *freePtr;

    if (dispPtr->idCleanupScheduled) {
	Tcl_DeleteTimerHandler(dispPtr->idCleanupScheduled);
    }

    for (stackPtr = dispPtr->idStackPtr; stackPtr != NULL; ) {
	freePtr = stackPtr;
	stackPtr = stackPtr->nextPtr;
	ckfree((char *) freePtr);
    }
    dispPtr->idStackPtr = NULL;

    for (stackPtr = dispPtr->windowStackPtr; stackPtr != NULL; ) {
	freePtr = stackPtr;
	stackPtr = stackPtr->nextPtr;
	ckfree((char *) freePtr);
    }
    dispPtr->windowStackPtr = NULL;
d296 2
a297 2
	dispPtr->idCleanupScheduled =
	    Tcl_CreateTimerHandler(100, WindowIdCleanup, (ClientData) dispPtr);
d331 1
a331 1
    dispPtr->idCleanupScheduled = (Tcl_TimerToken) 0;
d378 2
a379 2
    dispPtr->idCleanupScheduled =
	Tcl_CreateTimerHandler(500, WindowIdCleanup, (ClientData) dispPtr);
a535 33
}

/*
 *----------------------------------------------------------------------
 *
 * TkpScanWindowId --
 *
 *	Given a string, produce the corresponding Window Id.
 *
 * Results:
 *      The return value is normally TCL_OK;  in this case *idPtr
 *      will be set to the Window value equivalent to string.  If
 *      string is improperly formed then TCL_ERROR is returned and
 *      an error message will be left in the interp's result.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
TkpScanWindowId(interp, string, idPtr)
    Tcl_Interp *interp;	
    CONST char *string;
    Window *idPtr;
{
    int value;
    if (Tcl_GetInt(interp, string, &value) != TCL_OK) {
	return TCL_ERROR;
    }
    *idPtr = (Window) value;
    return TCL_OK;
@


