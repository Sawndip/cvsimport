head	1.6;
access;
symbols
	sid-snapshot-20180601:1.6
	sid-snapshot-20180501:1.6
	sid-snapshot-20180401:1.6
	sid-snapshot-20180301:1.6
	sid-snapshot-20180201:1.6
	sid-snapshot-20180101:1.6
	sid-snapshot-20171201:1.6
	sid-snapshot-20171101:1.6
	sid-snapshot-20171001:1.6
	sid-snapshot-20170901:1.6
	sid-snapshot-20170801:1.6
	sid-snapshot-20170701:1.6
	sid-snapshot-20170601:1.6
	sid-snapshot-20170501:1.6
	sid-snapshot-20170401:1.6
	sid-snapshot-20170301:1.6
	sid-snapshot-20170201:1.6
	sid-snapshot-20170101:1.6
	sid-snapshot-20161201:1.6
	sid-snapshot-20161101:1.6
	sid-snapshot-20160901:1.6
	sid-snapshot-20160801:1.6
	sid-snapshot-20160701:1.6
	sid-snapshot-20160601:1.6
	sid-snapshot-20160501:1.6
	sid-snapshot-20160401:1.6
	sid-snapshot-20160301:1.6
	sid-snapshot-20160201:1.6
	sid-snapshot-20160101:1.6
	sid-snapshot-20151201:1.6
	sid-snapshot-20151101:1.6
	sid-snapshot-20151001:1.6
	sid-snapshot-20150901:1.6
	sid-snapshot-20150801:1.6
	sid-snapshot-20150701:1.6
	sid-snapshot-20150601:1.6
	sid-snapshot-20150501:1.6
	sid-snapshot-20150401:1.6
	sid-snapshot-20150301:1.6
	sid-snapshot-20150201:1.6
	sid-snapshot-20150101:1.6
	sid-snapshot-20141201:1.6
	sid-snapshot-20141101:1.6
	sid-snapshot-20141001:1.6
	sid-snapshot-20140901:1.6
	sid-snapshot-20140801:1.6
	sid-snapshot-20140701:1.6
	sid-snapshot-20140601:1.6
	sid-snapshot-20140501:1.6
	sid-snapshot-20140401:1.6
	sid-snapshot-20140301:1.6
	sid-snapshot-20140201:1.6
	sid-snapshot-20140101:1.6
	sid-snapshot-20131201:1.6
	sid-snapshot-20131101:1.6
	sid-snapshot-20131001:1.6
	sid-snapshot-20130901:1.6
	sid-snapshot-20130801:1.6
	sid-snapshot-20130701:1.6
	sid-snapshot-20130601:1.6
	insight_7_6-2013-04-10-branchpoint:1.6
	gdb_7_6-branch:1.6.0.12
	sid-snapshot-20130501:1.6
	sid-snapshot-20130401:1.6
	sid-snapshot-20130301:1.6
	sid-snapshot-20130201:1.6
	sid-snapshot-20130101:1.6
	sid-snapshot-20121201:1.6
	sid-snapshot-20121101:1.6
	sid-snapshot-20121001:1.6
	sid-snapshot-20120901:1.6
	gdb_7_5-branch:1.6.0.10
	sid-snapshot-20120801:1.6
	sid-snapshot-20120701:1.6
	sid-snapshot-20120601:1.6
	sid-snapshot-20120501:1.6
	sid-snapshot-20120401:1.6
	gdb_7_4-branch:1.6.0.8
	sid-snapshot-20120301:1.6
	sid-snapshot-20120201:1.6
	sid-snapshot-20120101:1.6
	sid-snapshot-20111201:1.6
	sid-snapshot-20111101:1.6
	sid-snapshot-20111001:1.6
	sid-snapshot-20110901:1.6
	gdb_7_3-branch:1.6.0.6
	sid-snapshot-20110801:1.6
	sid-snapshot-20110701:1.6
	sid-snapshot-20110601:1.6
	sid-snapshot-20110501:1.6
	sid-snapshot-20110401:1.6
	sid-snapshot-20110301:1.6
	sid-snapshot-20110201:1.6
	sid-snapshot-20110101:1.6
	sid-snapshot-20101201:1.6
	sid-snapshot-20101101:1.6
	sid-snapshot-20101001:1.6
	sid-snapshot-20100901:1.6
	sid-snapshot-20100801:1.6
	sid-snapshot-20100701:1.6
	sid-snapshot-20100601:1.6
	sid-snapshot-20100501:1.6
	sid-snapshot-20100401:1.6
	sid-snapshot-20100301:1.6
	gdb_7_1-branch:1.6.0.4
	gdb_7_0-branch:1.6.0.2
	sid-snapshot-20100201:1.6
	sid-snapshot-20100101:1.6
	sid-snapshot-20091201:1.6
	sid-snapshot-20091101:1.6
	sid-snapshot-20091001:1.6
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.6
	sid-snapshot-20090801:1.6
	sid-snapshot-20090701:1.6
	sid-snapshot-20090601:1.6
	sid-snapshot-20090501:1.6
	kevinb-pre-tk8_5_7_merge:1.6
	sid-snapshot-20090401:1.6
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.6
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.4
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.6
date	2009.02.26.20.26.10;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.21.20.24.52;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.17;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.30;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.54;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.37;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.37.59;	author kseitz;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.01.21.19.53.34;	author hunt;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Backport upstream fix for "no event type or button # or keysym"
error when starting a tk application.
@
text
@/* 
 * tkUnixEvent.c --
 *
 *	This file implements an event source for X displays for the
 *	UNIX version of Tk.
 *
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkUnixEvent.c,v 1.10 2002/09/15 20:38:18 mdejong Exp $
 */

#include "tkInt.h"
#include "tkUnixInt.h"
#include <signal.h>

/*
 * The following static indicates whether this module has been initialized
 * in the current thread.
 */

typedef struct ThreadSpecificData {
    int initialized;
} ThreadSpecificData;
static Tcl_ThreadDataKey dataKey;

#if defined(TK_USE_INPUT_METHODS) && defined(PEEK_XCLOSEIM)
/*
 * Structure used to peek into internal XIM data structure.
 * Enabled only on systems where we are sure it works.
 */
struct XIMPeek {
    void *junk1, *junk2;
    XIC  ic_chain;
};
#endif

/*
 * Prototypes for procedures that are referenced only in this file:
 */

static void		DisplayCheckProc _ANSI_ARGS_((ClientData clientData,
			    int flags));
static void		DisplayExitHandler _ANSI_ARGS_((
			    ClientData clientData));
static void		DisplayFileProc _ANSI_ARGS_((ClientData clientData,
			    int flags));
static void		DisplaySetupProc _ANSI_ARGS_((ClientData clientData,
			    int flags));
static void		TransferXEventsToTcl _ANSI_ARGS_((Display *display));
#ifdef TK_USE_INPUT_METHODS
static void		OpenIM _ANSI_ARGS_((TkDisplay *dispPtr));
#endif


/*
 *----------------------------------------------------------------------
 *
 * TkCreateXEventSource --
 *
 *	This procedure is called during Tk initialization to create
 *	the event source for X Window events.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	A new event source is created.
 *
 *----------------------------------------------------------------------
 */

void
TkCreateXEventSource()
{
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    if (!tsdPtr->initialized) {
	tsdPtr->initialized = 1;
	Tcl_CreateEventSource(DisplaySetupProc, DisplayCheckProc, NULL);
	Tcl_CreateExitHandler(DisplayExitHandler, NULL);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * DisplayExitHandler --
 *
 *	This function is called during finalization to clean up the
 *	display module.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
DisplayExitHandler(clientData)
    ClientData clientData;	/* Not used. */
{
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    Tcl_DeleteEventSource(DisplaySetupProc, DisplayCheckProc, NULL);
    tsdPtr->initialized = 0;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpOpenDisplay --
 *
 *	Allocates a new TkDisplay, opens the X display, and establishes
 *	the file handler for the connection.
 *
 * Results:
 *	A pointer to a Tk display structure.
 *
 * Side effects:
 *	Opens a display.
 *
 *----------------------------------------------------------------------
 */

TkDisplay *
TkpOpenDisplay(display_name)
    CONST char *display_name;
{
    TkDisplay *dispPtr;
    Display *display = XOpenDisplay(display_name);

    if (display == NULL) {
	return NULL;
    }
    dispPtr = (TkDisplay *) ckalloc(sizeof(TkDisplay));
    memset(dispPtr, 0, sizeof(TkDisplay));
    dispPtr->display = display;
#ifdef TK_USE_INPUT_METHODS
    OpenIM(dispPtr);
#endif
    Tcl_CreateFileHandler(ConnectionNumber(display), TCL_READABLE,
	    DisplayFileProc, (ClientData) dispPtr);
    return dispPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpCloseDisplay --
 *
 *	Cancels notifier callbacks and closes a display.  
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Deallocates the displayPtr and unix-specific resources.
 *
 *----------------------------------------------------------------------
 */

void
TkpCloseDisplay(dispPtr)
    TkDisplay *dispPtr;
{
    TkSendCleanup(dispPtr);

    TkFreeXId(dispPtr);

    TkWmCleanup(dispPtr);

#ifdef TK_USE_INPUT_METHODS
#if TK_XIM_SPOT
    if (dispPtr->inputXfs) {
	XFreeFontSet(dispPtr->display, dispPtr->inputXfs);
    }
#endif
    if (dispPtr->inputMethod) {
	/*
	 * This caused core dumps on some systems (Solaris 2.3 1/6/95).
	 * The most likely cause of this is a bug in X that accesses
	 * memory that was already deallocated inside XCloseIM().
	 * One can work around this issue by making sure a XDestroyIC()
	 * gets invoked for each XCreateIC().
	 */

#if defined(TK_USE_INPUT_METHODS) && defined(PEEK_XCLOSEIM)
	struct XIMPeek *peek = (struct XIMPeek *) dispPtr->inputMethod;
	if (peek->ic_chain != NULL)
	    panic("input contexts not freed before XCloseIM");
#endif
	XCloseIM(dispPtr->inputMethod);
    }
#endif

    if (dispPtr->display != 0) {
	Tcl_DeleteFileHandler(ConnectionNumber(dispPtr->display));
	(void) XSync(dispPtr->display, False);
	(void) XCloseDisplay(dispPtr->display);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * DisplaySetupProc --
 *
 *	This procedure implements the setup part of the UNIX X display
 *	event source.  It is invoked by Tcl_DoOneEvent before entering
 *	the notifier to check for events on all displays.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	If data is queued on a display inside Xlib, then the maximum
 *	block time will be set to 0 to ensure that the notifier returns
 *	control to Tcl even if there is no more data on the X connection.
 *
 *----------------------------------------------------------------------
 */

static void
DisplaySetupProc(clientData, flags)
    ClientData clientData;	/* Not used. */
    int flags;
{
    TkDisplay *dispPtr;
    static Tcl_Time blockTime = { 0, 0 };

    if (!(flags & TCL_WINDOW_EVENTS)) {
	return;
    }

    for (dispPtr = TkGetDisplayList(); dispPtr != NULL;
	 dispPtr = dispPtr->nextPtr) {

	/*
	 * Flush the display. If data is pending on the X queue, set
	 * the block time to zero.  This ensures that we won't block
	 * in the notifier if there is data in the X queue, but not on
	 * the server socket.
	 */

	XFlush(dispPtr->display);
	if (QLength(dispPtr->display) > 0) {
	    Tcl_SetMaxBlockTime(&blockTime);
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 *  TransferXEventsToTcl
 *
 *      Transfer events from the X event queue to the Tk event queue.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Moves queued X events onto the Tcl event queue.
 *
 *----------------------------------------------------------------------
 */

static void
TransferXEventsToTcl(display)
    Display *display;
{
    int numFound;
    XEvent event;

    numFound = QLength(display);

    /*
     * Transfer events from the X event queue to the Tk event queue.
     */

    while (numFound > 0) {
	XNextEvent(display, &event);
#ifdef GenericEvent
	if (event.type == GenericEvent) {
	    xGenericEvent *xgePtr = (xGenericEvent *) &event;

	    Tcl_Panic("Wild GenericEvent; panic! (extension=%d,evtype=%d)",
		      xgePtr->extension, xgePtr->evtype);
	}
#endif
	Tk_QueueWindowEvent(&event, TCL_QUEUE_TAIL);
	numFound--;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * DisplayCheckProc --
 *
 *	This procedure checks for events sitting in the X event
 *	queue.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Moves queued events onto the Tcl event queue.
 *
 *----------------------------------------------------------------------
 */

static void
DisplayCheckProc(clientData, flags)
    ClientData clientData;	/* Not used. */
    int flags;
{
    TkDisplay *dispPtr;

    if (!(flags & TCL_WINDOW_EVENTS)) {
	return;
    }

    for (dispPtr = TkGetDisplayList(); dispPtr != NULL;
	 dispPtr = dispPtr->nextPtr) {
	XFlush(dispPtr->display);
	TransferXEventsToTcl(dispPtr->display);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * DisplayFileProc --
 *
 *	This procedure implements the file handler for the X connection.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Makes entries on the Tcl event queue for all the events available
 *	from all the displays.
 *
 *----------------------------------------------------------------------
 */

static void
DisplayFileProc(clientData, flags)
    ClientData clientData;		/* The display pointer. */
    int flags;				/* Should be TCL_READABLE. */
{
    TkDisplay *dispPtr = (TkDisplay *) clientData;
    Display *display = dispPtr->display;
    int numFound;

    XFlush(display);
    numFound = XEventsQueued(display, QueuedAfterReading);
    if (numFound == 0) {
	
	/*
	 * Things are very tricky if there aren't any events readable
	 * at this point (after all, there was supposedly data
	 * available on the connection).  A couple of things could
	 * have occurred:
	 * 
	 * One possibility is that there were only error events in the
	 * input from the server.  If this happens, we should return
	 * (we don't want to go to sleep in XNextEvent below, since
	 * this would block out other sources of input to the
	 * process).
	 *
	 * Another possibility is that our connection to the server
	 * has been closed.  This will not necessarily be detected in
	 * XEventsQueued (!!), so if we just return then there will be
	 * an infinite loop.  To detect such an error, generate a NoOp
	 * protocol request to exercise the connection to the server,
	 * then return.  However, must disable SIGPIPE while sending
	 * the request, or else the process will die from the signal
	 * and won't invoke the X error function to print a nice (?!)
	 * message.
	 */
	
	void (*oldHandler)();
	
	oldHandler = (void (*)()) signal(SIGPIPE, SIG_IGN);
	XNoOp(display);
	XFlush(display);
	(void) signal(SIGPIPE, oldHandler);
    }
    
    TransferXEventsToTcl(display);
}

/*
 *----------------------------------------------------------------------
 *
 * TkUnixDoOneXEvent --
 *
 *	This routine waits for an X event to be processed or for
 *	a timeout to occur.  The timeout is specified as an absolute
 *	time.  This routine is called when Tk needs to wait for a
 *	particular X event without letting arbitrary events be
 *	processed.  The caller will typically call Tk_RestrictEvents
 *	to set up an event filter before calling this routine.  This
 *	routine will service at most one event per invocation.
 *
 * Results:
 *	Returns 0 if the timeout has expired, otherwise returns 1.
 *
 * Side effects:
 *	Can invoke arbitrary Tcl scripts.
 *
 *----------------------------------------------------------------------
 */

int
TkUnixDoOneXEvent(timePtr)
    Tcl_Time *timePtr;		/* Specifies the absolute time when the
				 * call should time out. */
{
    TkDisplay *dispPtr;
    static fd_mask readMask[MASK_SIZE];
    struct timeval blockTime, *timeoutPtr;
    Tcl_Time now;
    int fd, index, bit, numFound, numFdBits = 0;

    /*
     * Look for queued events first. 
     */

    if (Tcl_ServiceEvent(TCL_WINDOW_EVENTS)) {
	return 1;
    }

    /*
     * Compute the next block time and check to see if we have timed out.
     * Note that HP-UX defines tv_sec to be unsigned so we have to be
     * careful in our arithmetic.
     */

    if (timePtr) {
	TclpGetTime(&now);
	blockTime.tv_sec = timePtr->sec;
	blockTime.tv_usec = timePtr->usec - now.usec;
	if (blockTime.tv_usec < 0) {
	    now.sec += 1;
	    blockTime.tv_usec += 1000000;
	}
	if (blockTime.tv_sec < now.sec) {
	    blockTime.tv_sec = 0;
	    blockTime.tv_usec = 0;
	} else {
	    blockTime.tv_sec -= now.sec;
	}
	timeoutPtr = &blockTime;
    } else {
	timeoutPtr = NULL;
    }

    /*
     * Set up the select mask for all of the displays.  If a display has
     * data pending, then we want to poll instead of blocking.
     */

    memset((VOID *) readMask, 0, MASK_SIZE*sizeof(fd_mask));
    for (dispPtr = TkGetDisplayList(); dispPtr != NULL;
	 dispPtr = dispPtr->nextPtr) {
	XFlush(dispPtr->display);
	if (QLength(dispPtr->display) > 0) {
	    blockTime.tv_sec = 0;
	    blockTime.tv_usec = 0;
	}
	fd = ConnectionNumber(dispPtr->display);
	index = fd/(NBBY*sizeof(fd_mask));
	bit = 1 << (fd%(NBBY*sizeof(fd_mask)));
	readMask[index] |= bit;
	if (numFdBits <= fd) {
	    numFdBits = fd+1;
	}
    }

    numFound = select(numFdBits, (SELECT_MASK *) &readMask[0], NULL, NULL,
	    timeoutPtr);
    if (numFound <= 0) {
	/*
	 * Some systems don't clear the masks after an error, so
	 * we have to do it here.
	 */

	memset((VOID *) readMask, 0, MASK_SIZE*sizeof(fd_mask));
    }

    /*
     * Process any new events on the display connections.
     */

    for (dispPtr = TkGetDisplayList(); dispPtr != NULL;
	 dispPtr = dispPtr->nextPtr) {
	fd = ConnectionNumber(dispPtr->display);
	index = fd/(NBBY*sizeof(fd_mask));
	bit = 1 << (fd%(NBBY*sizeof(fd_mask)));
	if ((readMask[index] & bit) || (QLength(dispPtr->display) > 0)) {
	    DisplayFileProc((ClientData)dispPtr, TCL_READABLE);
	}
    }
    if (Tcl_ServiceEvent(TCL_WINDOW_EVENTS)) {
	return 1;
    }

    /*
     * Check to see if we timed out.
     */

    if (timePtr) {
	TclpGetTime(&now);
	if ((now.sec > timePtr->sec) || ((now.sec == timePtr->sec)
		&& (now.usec > timePtr->usec))) {
	    return 0;
	}
    }

    /*
     * We had an event but we did not generate a Tcl event from it. Behave
     * as though we dealt with it. (JYL&SS)
     */

    return 1;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpSync --
 *
 *	This routine ensures that all pending X requests have been
 *	seen by the server, and that any pending X events have been
 *	moved onto the Tk event queue.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Places new events on the Tk event queue.
 *
 *----------------------------------------------------------------------
 */

void
TkpSync(display)
    Display *display;		/* Display to sync. */
{
    XSync(display, False);

    /*
     * Transfer events from the X event queue to the Tk event queue.
     */
    TransferXEventsToTcl(display);
}
#ifdef TK_USE_INPUT_METHODS

/* 
 *--------------------------------------------------------------
 *
 * OpenIM --
 *
 *	Tries to open an X input method, associated with the
 *	given display.  Right now we can only deal with a bare-bones
 *	input style:  no preedit, and no status.
 *
 * Results:
 *	Stores the input method in dispPtr->inputMethod;  if there isn't
 *	a suitable input method, then NULL is stored in dispPtr->inputMethod.
 *
 * Side effects:
 *	An input method gets opened.
 *
 *--------------------------------------------------------------
 */

static void
OpenIM(dispPtr)
    TkDisplay *dispPtr;		/* Tk's structure for the display. */
{
    unsigned short i;
    XIMStyles *stylePtr;
    char *modifier_list;

    if ((modifier_list = XSetLocaleModifiers("")) == NULL) {
	goto error;
    }

    dispPtr->inputMethod = XOpenIM(dispPtr->display, NULL, NULL, NULL);
    if (dispPtr->inputMethod == NULL) {
	return;
    }

    if ((XGetIMValues(dispPtr->inputMethod, XNQueryInputStyle, &stylePtr,
	    NULL) != NULL) || (stylePtr == NULL)) {
	goto error;
    }
#if TK_XIM_SPOT
    /*
     * If we want to do over-the-spot XIM, we have to check that this
     * mode is supported.  If not we will fall-through to the check below.
     */
    for (i = 0; i < stylePtr->count_styles; i++) {
	if (stylePtr->supported_styles[i]
		== (XIMPreeditPosition | XIMStatusNothing)) {
	    dispPtr->flags |= TK_DISPLAY_XIM_SPOT;
	    XFree(stylePtr);
	    return;
	}
    }
#endif
    for (i = 0; i < stylePtr->count_styles; i++) {
	if (stylePtr->supported_styles[i]
		== (XIMPreeditNothing | XIMStatusNothing)) {
	    XFree(stylePtr);
	    return;
	}
    }
    XFree(stylePtr);

    error:

    if (dispPtr->inputMethod) {
	/*
	 * This call should not suffer from any core dumping problems
	 * since we have not allocated any input contexts.
	 */
	XCloseIM(dispPtr->inputMethod);
	dispPtr->inputMethod = NULL;
    }
}
#endif /* TK_USE_INPUT_METHODS */
@


1.5
log
@Updated to tk 8.4.1
@
text
@d291 8
@


1.4
log
@touched all sources to ease next import
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tkUnixEvent.c,v 1.7.6.1 2000/05/04 21:26:30 spolk Exp $
d29 11
d53 3
d135 1
a135 1
    char *display_name;
d144 1
d146 3
d165 1
a165 1
 *	Deallocates the displayPtr.
d171 2
a172 2
TkpCloseDisplay(displayPtr)
    TkDisplay *displayPtr;
d174 29
a202 1
    TkDisplay *dispPtr = (TkDisplay *) displayPtr;
d205 3
a207 4
        Tcl_DeleteFileHandler(ConnectionNumber(dispPtr->display));
	
        (void) XSync(dispPtr->display, False);
        (void) XCloseDisplay(dispPtr->display);
a208 2
    
    ckfree((char *) dispPtr);
a275 1

a329 2


d559 67
d627 8
d636 1
a636 1

@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tkUnixEvent.c,v 1.9 1999/01/26 04:11:42 jingham Exp $
d20 2
a21 1
 * The following static indicates whether this module has been initialized.
d24 4
a27 1
static int initialized = 0;
d41 2
d64 5
a68 2
    if (!initialized) {
	initialized = 1;
d95 3
d99 1
a99 1
    initialized = 0;
d200 1
a200 1
    for (dispPtr = tkDisplayList; dispPtr != NULL;
d211 1
a211 1
	if (XQLength(dispPtr->display) > 0) {
d220 37
a276 2
    XEvent event;
    int numFound;
d282 1
a282 1
    for (dispPtr = tkDisplayList; dispPtr != NULL;
d285 3
a287 1
	numFound = XQLength(dispPtr->display);
a288 3
	/*
	 * Transfer events from the X event queue to the Tk event queue.
	 */
a289 7
	while (numFound > 0) {
	    XNextEvent(dispPtr->display, &event);
	    Tk_QueueWindowEvent(&event, TCL_QUEUE_TAIL);
	    numFound--;
	}
    }
}
a314 1
    XEvent event;
d352 1
a352 9
    /*
     * Transfer events from the X event queue to the Tk event queue.
     */

    while (numFound > 0) {
	XNextEvent(display, &event);
	Tk_QueueWindowEvent(&event, TCL_QUEUE_TAIL);
	numFound--;
    }
d427 1
a427 1
    for (dispPtr = tkDisplayList; dispPtr != NULL;
d430 1
a430 1
	if (XQLength(dispPtr->display) > 0) {
d458 1
a458 1
    for (dispPtr = tkDisplayList; dispPtr != NULL;
d463 1
a463 1
	if ((readMask[index] & bit) || (XQLength(dispPtr->display) > 0)) {
a512 3
    int numFound = 0;
    XEvent event;

d518 1
a519 6
    numFound = XQLength(display);
    while (numFound > 0) {
	XNextEvent(display, &event);
	Tk_QueueWindowEvent(&event, TCL_QUEUE_TAIL);
	numFound--;
    }
d521 1
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tkUnixEvent.c,v 1.7.6.1 2000/05/04 21:26:30 spolk Exp $
d20 1
a20 2
 * The following static indicates whether this module has been initialized
 * in the current thread.
d23 1
a23 4
typedef struct ThreadSpecificData {
    int initialized;
} ThreadSpecificData;
static Tcl_ThreadDataKey dataKey;
a36 2
static void		TransferXEventsToTcl _ANSI_ARGS_((Display *display));

d58 2
a59 5
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    if (!tsdPtr->initialized) {
	tsdPtr->initialized = 1;
a85 3
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

d87 1
a87 1
    tsdPtr->initialized = 0;
d188 1
a188 1
    for (dispPtr = TkGetDisplayList(); dispPtr != NULL;
d199 1
a199 1
	if (QLength(dispPtr->display) > 0) {
a207 37
 *  TransferXEventsToTcl
 *
 *      Transfer events from the X event queue to the Tk event queue.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Moves queued X events onto the Tcl event queue.
 *
 *----------------------------------------------------------------------
 */


static void
TransferXEventsToTcl(display)
    Display *display;
{
    int numFound;
    XEvent event;

    numFound = QLength(display);

    /*
     * Transfer events from the X event queue to the Tk event queue.
     */

    while (numFound > 0) {
	XNextEvent(display, &event);
	Tk_QueueWindowEvent(&event, TCL_QUEUE_TAIL);
	numFound--;
    }
}

/*
 *----------------------------------------------------------------------
 *
d228 2
d235 1
a235 1
    for (dispPtr = TkGetDisplayList(); dispPtr != NULL;
d238 11
a248 1
	TransferXEventsToTcl(dispPtr->display);
a250 2


d276 1
d314 9
a322 1
    TransferXEventsToTcl(display);
d397 1
a397 1
    for (dispPtr = TkGetDisplayList(); dispPtr != NULL;
d400 1
a400 1
	if (QLength(dispPtr->display) > 0) {
d428 1
a428 1
    for (dispPtr = TkGetDisplayList(); dispPtr != NULL;
d433 1
a433 1
	if ((readMask[index] & bit) || (QLength(dispPtr->display) > 0)) {
d483 3
a490 1
    TransferXEventsToTcl(display);
d492 6
a498 1

@


1.1.1.3
log
@import tk 8.4.0
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tkUnixEvent.c,v 1.9 2002/06/19 19:37:55 mdejong Exp $
a41 3
#ifdef TK_USE_INPUT_METHODS
static void		OpenIM _ANSI_ARGS_((TkDisplay *dispPtr));
#endif
d121 1
a121 1
    CONST char *display_name;
a129 1
    memset(dispPtr, 0, sizeof(TkDisplay));
a130 3
#ifdef TK_USE_INPUT_METHODS
    OpenIM(dispPtr);
#endif
d147 1
a147 1
 *	Deallocates the displayPtr and unix-specific resources.
d153 2
a154 2
TkpCloseDisplay(dispPtr)
    TkDisplay *dispPtr;
d156 1
a156 23
    TkSendCleanup(dispPtr);

    TkFreeXId(dispPtr);

    TkWmCleanup(dispPtr);

#ifdef TK_USE_INPUT_METHODS
#if TK_XIM_SPOT
    if (dispPtr->inputXfs) {
	XFreeFontSet(dispPtr->display, dispPtr->inputXfs);
    }
#endif
    if (dispPtr->inputMethod) {
	/*
	 * This caused core dumps on some systems (Solaris 2.3 1/6/95).
	 * The most likely cause of this is a bug in X that accesses
	 * memory that was already deallocated inside XCloseIM().
	 * One can work around this issue by making sure a XDestroyIC()
	 * gets invoked for each XCreateIC().
	 */
	XCloseIM(dispPtr->inputMethod);
    }
#endif
d159 4
a162 3
	Tcl_DeleteFileHandler(ConnectionNumber(dispPtr->display));
	(void) XSync(dispPtr->display, False);
	(void) XCloseDisplay(dispPtr->display);
d164 2
d233 1
d288 2
d519 1
a520 64
#ifdef TK_USE_INPUT_METHODS

/* 
 *--------------------------------------------------------------
 *
 * OpenIM --
 *
 *	Tries to open an X input method, associated with the
 *	given display.  Right now we can only deal with a bare-bones
 *	input style:  no preedit, and no status.
 *
 * Results:
 *	Stores the input method in dispPtr->inputMethod;  if there isn't
 *	a suitable input method, then NULL is stored in dispPtr->inputMethod.
 *
 * Side effects:
 *	An input method gets opened.
 *
 *--------------------------------------------------------------
 */

static void
OpenIM(dispPtr)
    TkDisplay *dispPtr;		/* Tk's structure for the display. */
{
    unsigned short i;
    XIMStyles *stylePtr;
    char *modifier_list;

    if ((modifier_list = XSetLocaleModifiers("")) == NULL) {
	goto error;
    }

    dispPtr->inputMethod = XOpenIM(dispPtr->display, NULL, NULL, NULL);
    if (dispPtr->inputMethod == NULL) {
	return;
    }

    if ((XGetIMValues(dispPtr->inputMethod, XNQueryInputStyle, &stylePtr,
	    NULL) != NULL) || (stylePtr == NULL)) {
	goto error;
    }
#if TK_XIM_SPOT
    /*
     * If we want to do over-the-spot XIM, we have to check that this
     * mode is supported.  If not we will fall-through to the check below.
     */
    for (i = 0; i < stylePtr->count_styles; i++) {
	if (stylePtr->supported_styles[i]
		== (XIMPreeditPosition | XIMStatusNothing)) {
	    dispPtr->flags |= TK_DISPLAY_XIM_SPOT;
	    XFree(stylePtr);
	    return;
	}
    }
#endif
    for (i = 0; i < stylePtr->count_styles; i++) {
	if (stylePtr->supported_styles[i]
		== (XIMPreeditNothing | XIMStatusNothing)) {
	    XFree(stylePtr);
	    return;
	}
    }
    XFree(stylePtr);
a521 12
    error:

    if (dispPtr->inputMethod) {
	/*
	 * This call should not suffer from any core dumping problems
	 * since we have not allocated any input contexts.
	 */
	XCloseIM(dispPtr->inputMethod);
	dispPtr->inputMethod = NULL;
    }
}
#endif /* TK_USE_INPUT_METHODS */
@


1.1.1.4
log
@imported tk 8.4.1
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tkUnixEvent.c,v 1.10 2002/09/15 20:38:18 mdejong Exp $
a28 11
#if defined(TK_USE_INPUT_METHODS) && defined(PEEK_XCLOSEIM)
/*
 * Structure used to peek into internal XIM data structure.
 * Enabled only on systems where we are sure it works.
 */
struct XIMPeek {
    void *junk1, *junk2;
    XIC  ic_chain;
};
#endif

a182 6

#if defined(TK_USE_INPUT_METHODS) && defined(PEEK_XCLOSEIM)
	struct XIMPeek *peek = (struct XIMPeek *) dispPtr->inputMethod;
	if (peek->ic_chain != NULL)
	    panic("input contexts not freed before XCloseIM");
#endif
@


