head	1.6;
access;
symbols
	sid-snapshot-20180601:1.6
	sid-snapshot-20180501:1.6
	sid-snapshot-20180401:1.6
	sid-snapshot-20180301:1.6
	sid-snapshot-20180201:1.6
	sid-snapshot-20180101:1.6
	sid-snapshot-20171201:1.6
	sid-snapshot-20171101:1.6
	sid-snapshot-20171001:1.6
	sid-snapshot-20170901:1.6
	sid-snapshot-20170801:1.6
	sid-snapshot-20170701:1.6
	sid-snapshot-20170601:1.6
	sid-snapshot-20170501:1.6
	sid-snapshot-20170401:1.6
	sid-snapshot-20170301:1.6
	sid-snapshot-20170201:1.6
	sid-snapshot-20170101:1.6
	sid-snapshot-20161201:1.6
	sid-snapshot-20161101:1.6
	sid-snapshot-20160901:1.6
	sid-snapshot-20160801:1.6
	sid-snapshot-20160701:1.6
	sid-snapshot-20160601:1.6
	sid-snapshot-20160501:1.6
	sid-snapshot-20160401:1.6
	sid-snapshot-20160301:1.6
	sid-snapshot-20160201:1.6
	sid-snapshot-20160101:1.6
	sid-snapshot-20151201:1.6
	sid-snapshot-20151101:1.6
	sid-snapshot-20151001:1.6
	sid-snapshot-20150901:1.6
	sid-snapshot-20150801:1.6
	sid-snapshot-20150701:1.6
	sid-snapshot-20150601:1.6
	sid-snapshot-20150501:1.6
	sid-snapshot-20150401:1.6
	sid-snapshot-20150301:1.6
	sid-snapshot-20150201:1.6
	sid-snapshot-20150101:1.6
	sid-snapshot-20141201:1.6
	sid-snapshot-20141101:1.6
	sid-snapshot-20141001:1.6
	sid-snapshot-20140901:1.6
	sid-snapshot-20140801:1.6
	sid-snapshot-20140701:1.6
	sid-snapshot-20140601:1.6
	sid-snapshot-20140501:1.6
	sid-snapshot-20140401:1.6
	sid-snapshot-20140301:1.6
	sid-snapshot-20140201:1.6
	sid-snapshot-20140101:1.6
	sid-snapshot-20131201:1.6
	sid-snapshot-20131101:1.6
	sid-snapshot-20131001:1.6
	sid-snapshot-20130901:1.6
	sid-snapshot-20130801:1.6
	sid-snapshot-20130701:1.6
	sid-snapshot-20130601:1.6
	insight_7_6-2013-04-10-branchpoint:1.6
	gdb_7_6-branch:1.6.0.28
	sid-snapshot-20130501:1.6
	sid-snapshot-20130401:1.6
	sid-snapshot-20130301:1.6
	sid-snapshot-20130201:1.6
	sid-snapshot-20130101:1.6
	sid-snapshot-20121201:1.6
	sid-snapshot-20121101:1.6
	sid-snapshot-20121001:1.6
	sid-snapshot-20120901:1.6
	gdb_7_5-branch:1.6.0.26
	sid-snapshot-20120801:1.6
	sid-snapshot-20120701:1.6
	sid-snapshot-20120601:1.6
	sid-snapshot-20120501:1.6
	sid-snapshot-20120401:1.6
	gdb_7_4-branch:1.6.0.24
	sid-snapshot-20120301:1.6
	sid-snapshot-20120201:1.6
	sid-snapshot-20120101:1.6
	sid-snapshot-20111201:1.6
	sid-snapshot-20111101:1.6
	sid-snapshot-20111001:1.6
	sid-snapshot-20110901:1.6
	gdb_7_3-branch:1.6.0.22
	sid-snapshot-20110801:1.6
	sid-snapshot-20110701:1.6
	sid-snapshot-20110601:1.6
	sid-snapshot-20110501:1.6
	sid-snapshot-20110401:1.6
	sid-snapshot-20110301:1.6
	sid-snapshot-20110201:1.6
	sid-snapshot-20110101:1.6
	sid-snapshot-20101201:1.6
	sid-snapshot-20101101:1.6
	sid-snapshot-20101001:1.6
	sid-snapshot-20100901:1.6
	sid-snapshot-20100801:1.6
	sid-snapshot-20100701:1.6
	sid-snapshot-20100601:1.6
	sid-snapshot-20100501:1.6
	sid-snapshot-20100401:1.6
	sid-snapshot-20100301:1.6
	gdb_7_1-branch:1.6.0.20
	gdb_7_0-branch:1.6.0.18
	sid-snapshot-20100201:1.6
	sid-snapshot-20100101:1.6
	sid-snapshot-20091201:1.6
	sid-snapshot-20091101:1.6
	sid-snapshot-20091001:1.6
	arc-sim-20090309:1.6
	sid-snapshot-20090901:1.6
	sid-snapshot-20090801:1.6
	sid-snapshot-20090701:1.6
	sid-snapshot-20090601:1.6
	sid-snapshot-20090501:1.6
	kevinb-pre-tk8_5_7_merge:1.6
	sid-snapshot-20090401:1.6
	arc-insight_6_8-branch:1.6.0.16
	arc-insight_6_8-branchpoint:1.6
	insight_6_8-branch:1.6.0.14
	insight_6_8-branchpoint:1.6
	sid-snapshot-20090301:1.6
	sid-snapshot-20090201:1.6
	sid-snapshot-20090101:1.6
	sid-snapshot-20081201:1.6
	sid-snapshot-20081101:1.6
	sid-snapshot-20081001:1.6
	sid-snapshot-20080901:1.6
	sid-snapshot-20080801:1.6
	sid-snapshot-20080701:1.6
	sid-snapshot-20080601:1.6
	sid-snapshot-20080501:1.6
	sid-snapshot-20080403:1.6
	sid-snapshot-20080401:1.6
	gdb_6_8-branch:1.6.0.12
	sid-snapshot-20080301:1.6
	sid-snapshot-20080201:1.6
	sid-snapshot-20080101:1.6
	sid-snapshot-20071201:1.6
	sid-snapshot-20071101:1.6
	sid-snapshot-20071001:1.6
	insight_6_6-20070208-release:1.6
	gdb_6_6-branch:1.6.0.10
	gdb_6_6-2006-11-15-branchpoint:1.6
	insight_6_5-20061003-release:1.6
	gdb_6_5-branch:1.6.0.8
	gdb_6_5-2006-05-14-branchpoint:1.6
	gdb_6_4-branch:1.6.0.6
	gdb_6_4-2005-11-01-branchpoint:1.6
	gdb_6_1-2004-04-05-release:1.6
	gdb_6_1-branch:1.6.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	gdb_6_0-2003-10-04-release:1.6
	gdb_6_0-branch:1.6.0.2
	gdb_6_0-2003-06-23-branchpoint:1.6
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.3
	tcltk840-20020924-branch:1.4.0.2
	tcltk840-20020924-branchpoint:1.4
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.3
	sid-20020905-branch:1.3.0.6
	gdb_5_3-branch:1.3.0.4
	gdb_5_3-2002-09-04-branchpoint:1.3
	gdb_5_2_1-2002-07-23-release:1.3
	gdb_5_2-2002-04-29-release:1.3
	gdb_5_2-branch:1.3.0.2
	gdb_5_2-2002-03-03-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.6
date	2003.01.21.20.24.53;	author hunt;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.21.19.53.17;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.24.18.39.30;	author kseitz;	state Exp;
branches;
next	1.3;

1.3
date	2001.09.13.00.42.07;	author irox;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.55;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.38;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.28;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Updated to tk 8.4.1
@
text
@/*
 * tkWinDialog.c --
 *
 *	Contains the Windows implementation of the common dialog boxes.
 *
 * Copyright (c) 1996-1997 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkWinDialog.c,v 1.29 2002/08/14 15:31:21 vincentdarley Exp $
 *
 */

#include "tkWinInt.h"
#include "tkFileFilter.h"

#include <commdlg.h>    /* includes common dialog functionality */
#include <dlgs.h>       /* includes common dialog template defines */
#include <cderr.h>      /* includes the common dialog error codes */

/*
 * This controls the use of the new style tk_chooseDirectory dialog.
 */
#define USE_NEW_CHOOSEDIR 1
#ifdef USE_NEW_CHOOSEDIR
#include <shlobj.h>     /* includes SHBrowseForFolder */

/* These needed for compilation with VC++ 5.2 */
#ifndef BIF_EDITBOX
#define BIF_EDITBOX 0x10
#endif
#ifndef BIF_VALIDATE
#define BIF_VALIDATE 0x0020
#endif
#ifndef BFFM_VALIDATEFAILED
#ifdef UNICODE
#define BFFM_VALIDATEFAILED 4
#else
#define BFFM_VALIDATEFAILED 3
#endif
#endif 

/*
 * The following structure is used by the new Tk_ChooseDirectoryObjCmd
 * to pass data between it and its callback. Unqiue to Winodws platform.
 */
typedef struct ChooseDirData {
   TCHAR utfInitDir[MAX_PATH];       /* Initial folder to use */
   TCHAR utfRetDir[MAX_PATH];        /* Returned folder to use */
   Tcl_Interp *interp;
   int mustExist;                    /* true if file must exist to return from
				      * callback */
} CHOOSEDIRDATA;
#endif

typedef struct ThreadSpecificData { 
    int debugFlag;            /* Flags whether we should output debugging 
			       * information while displaying a builtin 
			       * dialog. */
    Tcl_Interp *debugInterp;  /* Interpreter to used for debugging. */
    UINT WM_LBSELCHANGED;     /* Holds a registered windows event used for
			       * communicating between the Directory
			       * Chooser dialog and its hook proc. */
} ThreadSpecificData;
static Tcl_ThreadDataKey dataKey;

/*
 * The following structures are used by Tk_MessageBoxCmd() to parse 
 * arguments and return results.
 */

static const TkStateMap iconMap[] = {
    {MB_ICONERROR,		"error"},
    {MB_ICONINFORMATION,	"info"},
    {MB_ICONQUESTION,		"question"},
    {MB_ICONWARNING,		"warning"},
    {-1,			NULL}
};
	  
static const TkStateMap typeMap[] = {
    {MB_ABORTRETRYIGNORE,	"abortretryignore"},
    {MB_OK, 			"ok"},
    {MB_OKCANCEL,		"okcancel"},
    {MB_RETRYCANCEL,		"retrycancel"},
    {MB_YESNO,			"yesno"},
    {MB_YESNOCANCEL,		"yesnocancel"},
    {-1,			NULL}
};

static const TkStateMap buttonMap[] = {
    {IDABORT,			"abort"},
    {IDRETRY,			"retry"},
    {IDIGNORE,			"ignore"},
    {IDOK,			"ok"},
    {IDCANCEL,			"cancel"},
    {IDNO,			"no"},
    {IDYES,			"yes"},
    {-1,			NULL}
};

static const int buttonFlagMap[] = {
    MB_DEFBUTTON1, MB_DEFBUTTON2, MB_DEFBUTTON3, MB_DEFBUTTON4
};

static const struct {int type; int btnIds[3];} allowedTypes[] = {
    {MB_ABORTRETRYIGNORE,	{IDABORT, IDRETRY,  IDIGNORE}},
    {MB_OK, 			{IDOK,    -1,       -1      }},
    {MB_OKCANCEL,		{IDOK,    IDCANCEL, -1      }},
    {MB_RETRYCANCEL,		{IDRETRY, IDCANCEL, -1      }},
    {MB_YESNO,			{IDYES,   IDNO,     -1      }},
    {MB_YESNOCANCEL,		{IDYES,   IDNO,     IDCANCEL}}
};

#define NUM_TYPES (sizeof(allowedTypes) / sizeof(allowedTypes[0]))

/*
 * The value of TK_MULTI_MAX_PATH dictactes how many files can
 * be retrieved with tk_get*File -multiple 1.  It must be allocated
 * on the stack, so make it large enough but not too large.  -- hobbs
 * The data is stored as <dir>\0<file1>\0<file2>\0...<fileN>\0\0.
 * MAX_PATH == 260 on Win2K/NT.
 */

#define TK_MULTI_MAX_PATH	(MAX_PATH*20)

/*
 * The following structure is used to pass information between the directory
 * chooser procedure, Tk_ChooseDirectoryObjCmd(), and its dialog hook proc.
 */

typedef struct ChooseDir {
    Tcl_Interp *interp;		/* Interp, used only if debug is turned on, 
				 * for setting the "tk_dialog" variable. */
    int lastCtrl;		/* Used by hook proc to keep track of last
				 * control that had input focus, so when OK
				 * is pressed we know whether to browse a
				 * new directory or return. */
    int lastIdx;		/* Last item that was selected in directory 
				 * browser listbox. */
    TCHAR path[MAX_PATH];	/* On return from choose directory dialog, 
				 * holds the selected path.  Cannot return 
				 * selected path in ofnPtr->lpstrFile because
				 * the default dialog proc stores a '\0' in 
				 * it, since, of course, no _file_ was 
				 * selected. */
    OPENFILENAME *ofnPtr;	/* pointer to the OFN structure */
} ChooseDir;

/*
 * Definitions of procedures used only in this file.
 */

#ifdef USE_NEW_CHOOSEDIR
static UINT APIENTRY	ChooseDirectoryValidateProc(HWND hdlg, UINT uMsg,
			    LPARAM wParam, LPARAM lParam);
#else
static UINT APIENTRY	ChooseDirectoryHookProc(HWND hdlg, UINT uMsg, 
			    WPARAM wParam, LPARAM lParam);
#endif
static UINT CALLBACK	ColorDlgHookProc(HWND hDlg, UINT uMsg, WPARAM wParam,
			    LPARAM lParam);
static int 		GetFileNameA(ClientData clientData, 
			    Tcl_Interp *interp, int objc, 
			    Tcl_Obj *CONST objv[], int isOpen);
static int 		GetFileNameW(ClientData clientData, 
			    Tcl_Interp *interp, int objc, 
			    Tcl_Obj *CONST objv[], int isOpen);
static int 		MakeFilter(Tcl_Interp *interp, char *string, 
			    Tcl_DString *dsPtr);
static UINT APIENTRY	OFNHookProc(HWND hdlg, UINT uMsg, WPARAM wParam, 
			    LPARAM lParam);
static UINT APIENTRY	OFNHookProcW(HWND hdlg, UINT uMsg, WPARAM wParam, 
			    LPARAM lParam);
static void		SetTkDialog(ClientData clientData);

/*
 *-------------------------------------------------------------------------
 *
 * TkWinDialogDebug --
 *
 *	Function to turn on/off debugging support for common dialogs under
 *	windows.  The variable "tk_debug" is set to the identifier of the
 *	dialog window when the modal dialog window pops up and it is safe to 
 *	send messages to the dialog.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	This variable only makes sense if just one dialog is up at a time.
 *
 *-------------------------------------------------------------------------
 */

void	    	
TkWinDialogDebug(
    int debug)
{
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    tsdPtr->debugFlag = debug;
}

/*
 *-------------------------------------------------------------------------
 *
 * Tk_ChooseColorObjCmd --
 *
 *	This procedure implements the color dialog box for the Windows
 *	platform. See the user documentation for details on what it
 *	does.
 *
 * Results:
 *	See user documentation.
 *
 * Side effects:
 *	A dialog window is created the first time this procedure is called.
 *	This window is not destroyed and will be reused the next time the
 *	application invokes the "tk_chooseColor" command.
 *
 *-------------------------------------------------------------------------
 */

int
Tk_ChooseColorObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Main window associated with interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Tk_Window tkwin, parent;
    HWND hWnd;
    int i, oldMode, winCode, result;
    CHOOSECOLOR chooseColor;
    static int inited = 0;
    static COLORREF dwCustColors[16];
    static long oldColor;		/* the color selected last time */
    static CONST char *optionStrings[] = {
	"-initialcolor", "-parent", "-title", NULL
    };
    enum options {
	COLOR_INITIAL, COLOR_PARENT, COLOR_TITLE
    };

    result = TCL_OK;
    if (inited == 0) {
	/*
	 * dwCustColors stores the custom color which the user can
	 * modify. We store these colors in a static array so that the next
	 * time the color dialog pops up, the same set of custom colors
	 * remain in the dialog.
	 */
	for (i = 0; i < 16; i++) {
	    dwCustColors[i] = RGB(255-i * 10, i, i * 10);
	}
	oldColor = RGB(0xa0, 0xa0, 0xa0);
	inited = 1;
    }

    tkwin = (Tk_Window) clientData;

    parent			= tkwin;
    chooseColor.lStructSize	= sizeof(CHOOSECOLOR);
    chooseColor.hwndOwner	= NULL;			
    chooseColor.hInstance	= NULL;
    chooseColor.rgbResult	= oldColor;
    chooseColor.lpCustColors	= dwCustColors;
    chooseColor.Flags		= CC_RGBINIT | CC_FULLOPEN | CC_ENABLEHOOK;
    chooseColor.lCustData	= (LPARAM) NULL;
    chooseColor.lpfnHook	= (LPOFNHOOKPROC) ColorDlgHookProc;
    chooseColor.lpTemplateName	= (LPTSTR) interp;

    for (i = 1; i < objc; i += 2) {
	int index;
	char *string;
	Tcl_Obj *optionPtr, *valuePtr;

	optionPtr = objv[i];
	valuePtr = objv[i + 1];

	if (Tcl_GetIndexFromObj(interp, optionPtr, optionStrings, "option",
		TCL_EXACT, &index) != TCL_OK) {
	    return TCL_ERROR;
	}
	if (i + 1 == objc) {
	    string = Tcl_GetStringFromObj(optionPtr, NULL);
	    Tcl_AppendResult(interp, "value for \"", string, "\" missing", 
		    (char *) NULL);
	    return TCL_ERROR;
	}

	string = Tcl_GetStringFromObj(valuePtr, NULL);
	switch ((enum options) index) {
	    case COLOR_INITIAL: {
		XColor *colorPtr;

		colorPtr = Tk_GetColor(interp, tkwin, string);
		if (colorPtr == NULL) {
		    return TCL_ERROR;
		}
		chooseColor.rgbResult = RGB(colorPtr->red / 0x100, 
			colorPtr->green / 0x100, colorPtr->blue / 0x100);
		break;
	    }
	    case COLOR_PARENT: {
		parent = Tk_NameToWindow(interp, string, tkwin);
		if (parent == NULL) {
		    return TCL_ERROR;
		}
		break;
	    }
	    case COLOR_TITLE: {
		chooseColor.lCustData = (LPARAM) string;
		break;
	    }
	}
    }

    Tk_MakeWindowExist(parent);
    chooseColor.hwndOwner = NULL;
    hWnd = Tk_GetHWND(Tk_WindowId(parent));
    chooseColor.hwndOwner = hWnd;
    
    oldMode = Tcl_SetServiceMode(TCL_SERVICE_ALL);
    winCode = ChooseColor(&chooseColor);
    (void) Tcl_SetServiceMode(oldMode);

    /*
     * Ensure that hWnd is enabled, because it can happen that we
     * have updated the wrapper of the parent, which causes us to
     * leave this child disabled (Windows loses sync).
     */
    EnableWindow(hWnd, 1);

    /*
     * Clear the interp result since anything may have happened during the
     * modal loop.
     */

    Tcl_ResetResult(interp);

    /*
     * 3. Process the result of the dialog
     */

    if (winCode) {
	/*
	 * User has selected a color
	 */
	char color[100];

	sprintf(color, "#%02x%02x%02x",
		GetRValue(chooseColor.rgbResult), 
	        GetGValue(chooseColor.rgbResult), 
		GetBValue(chooseColor.rgbResult));
        Tcl_AppendResult(interp, color, NULL);
	oldColor = chooseColor.rgbResult;
	result = TCL_OK;
    }

    return result;
}

/*
 *-------------------------------------------------------------------------
 *
 * ColorDlgHookProc --
 *
 *	Provides special handling of messages for the Color common dialog
 *	box.  Used to set the title when the dialog first appears.
 *
 * Results:
 *	The return value is 0 if the default dialog box procedure should
 *	handle the message, non-zero otherwise. 
 *
 * Side effects:
 *	Changes the title of the dialog window.
 *
 *----------------------------------------------------------------------
 */

static UINT CALLBACK 
ColorDlgHookProc(hDlg, uMsg, wParam, lParam)
    HWND hDlg;			/* Handle to the color dialog. */
    UINT uMsg;			/* Type of message. */
    WPARAM wParam;		/* First message parameter. */
    LPARAM lParam;		/* Second message parameter. */
{
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    switch (uMsg) {
	case WM_INITDIALOG: {
	    const char *title;
	    CHOOSECOLOR *ccPtr;
	    Tcl_DString ds;

	    /* 
	     * Set the title string of the dialog.
	     */

	    ccPtr = (CHOOSECOLOR *) lParam;
	    title = (const char *) ccPtr->lCustData;
	    if ((title != NULL) && (title[0] != '\0')) {
		(*tkWinProcs->setWindowText)(hDlg,
			Tcl_WinUtfToTChar(title, -1, &ds));
		Tcl_DStringFree(&ds);
	    }
	    if (tsdPtr->debugFlag) {
		tsdPtr->debugInterp = (Tcl_Interp *) ccPtr->lpTemplateName;
		Tcl_DoWhenIdle(SetTkDialog, (ClientData) hDlg);
	    }
	    return TRUE;
	}
    }
    return FALSE;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_GetOpenFileCmd --
 *
 *	This procedure implements the "open file" dialog box for the
 *	Windows platform. See the user documentation for details on what
 *	it does.
 *
 * Results:
 *	See user documentation.
 *
 * Side effects:
 *	A dialog window is created the first this procedure is called.
 *
 *----------------------------------------------------------------------
 */

int
Tk_GetOpenFileObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Main window associated with interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    if (TkWinGetPlatformId() == VER_PLATFORM_WIN32_NT) {
	return GetFileNameW(clientData, interp, objc, objv, 1);
    } else {
	return GetFileNameA(clientData, interp, objc, objv, 1);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_GetSaveFileCmd --
 *
 *	Same as Tk_GetOpenFileCmd but opens a "save file" dialog box
 *	instead
 *
 * Results:
 *	Same as Tk_GetOpenFileCmd.
 *
 * Side effects:
 *	Same as Tk_GetOpenFileCmd.
 *
 *----------------------------------------------------------------------
 */

int
Tk_GetSaveFileObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Main window associated with interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    if (TkWinGetPlatformId() == VER_PLATFORM_WIN32_NT) {
	return GetFileNameW(clientData, interp, objc, objv, 0);
    } else {
	return GetFileNameA(clientData, interp, objc, objv, 0);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * GetFileNameW --
 *
 *	Calls GetOpenFileName() or GetSaveFileName().
 *
 * Results:
 *	See user documentation.
 *
 * Side effects:
 *	See user documentation.
 *
 *----------------------------------------------------------------------
 */

static int 
GetFileNameW(clientData, interp, objc, objv, open)
    ClientData clientData;	/* Main window associated with interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
    int open;			/* 1 to call GetOpenFileName(), 0 to 
				 * call GetSaveFileName(). */
{
    OPENFILENAMEW ofn;
    WCHAR file[TK_MULTI_MAX_PATH];
    int result, winCode, oldMode, i, multi = 0;
    char *extension, *filter, *title;
    Tk_Window tkwin;
    HWND hWnd;
    Tcl_DString utfFilterString, utfDirString;
    Tcl_DString extString, filterString, dirString, titleString;
    Tcl_Encoding unicodeEncoding = TkWinGetUnicodeEncoding();
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    static CONST char *saveOptionStrings[] = {
	"-defaultextension", "-filetypes", "-initialdir", "-initialfile",
	"-parent", "-title", NULL
    };
    static CONST char *openOptionStrings[] = {
	"-defaultextension", "-filetypes", "-initialdir", "-initialfile",
	"-multiple", "-parent", "-title", NULL
    };
    CONST char **optionStrings;

    enum options {
	FILE_DEFAULT,	FILE_TYPES,	FILE_INITDIR,	FILE_INITFILE,
	FILE_MULTIPLE,	FILE_PARENT,	FILE_TITLE
    };

    result = TCL_ERROR;
    file[0] = '\0';

    /*
     * Parse the arguments.
     */

    extension = NULL;
    filter = NULL;
    Tcl_DStringInit(&utfFilterString);
    Tcl_DStringInit(&utfDirString);
    tkwin = (Tk_Window) clientData;
    title = NULL;

    if (open) {
	optionStrings = openOptionStrings;
    } else {
	optionStrings = saveOptionStrings;
    }

    for (i = 1; i < objc; i += 2) {
	int index;
	char *string;
	Tcl_Obj *optionPtr, *valuePtr;

	optionPtr = objv[i];
	valuePtr = objv[i + 1];

	if (Tcl_GetIndexFromObj(interp, optionPtr, optionStrings,
		"option", 0, &index) != TCL_OK) {
	    goto end;
	}
	/*
	 * We want to maximize code sharing between the open and save file
	 * dialog implementations; in particular, the switch statement below.
	 * We use different sets of option strings from the GetIndexFromObj
	 * call above, but a single enumeration for both.  The save file
	 * dialog doesn't support -multiple, but it falls in the middle of
	 * the enumeration.  Ultimately, this means that when the index found
	 * by GetIndexFromObj is >= FILE_MULTIPLE, when doing a save file
	 * dialog, we have to increment the index, so that it matches the
	 * open file dialog enumeration.
	 */
	if (!open && index >= FILE_MULTIPLE) {
	    index++;
	}
	if (i + 1 == objc) {
	    string = Tcl_GetStringFromObj(optionPtr, NULL);
	    Tcl_AppendResult(interp, "value for \"", string, "\" missing", 
		    (char *) NULL);
	    goto end;
	}

	string = Tcl_GetStringFromObj(valuePtr, NULL);
	switch ((enum options) index) {
	    case FILE_DEFAULT: {
		if (string[0] == '.') {
		    string++;
		}
		extension = string;
		break;
	    }
	    case FILE_TYPES: {
		Tcl_DStringFree(&utfFilterString);
		if (MakeFilter(interp, string, &utfFilterString) != TCL_OK) {
		    goto end;
		}
		filter = Tcl_DStringValue(&utfFilterString);
		break;
	    }
	    case FILE_INITDIR: {
		Tcl_DStringFree(&utfDirString);
		if (Tcl_TranslateFileName(interp, string,
			&utfDirString) == NULL) {
		    goto end;
		}
		break;
	    }
	    case FILE_INITFILE: {
		Tcl_DString ds;

		if (Tcl_TranslateFileName(interp, string, &ds) == NULL) {
		    goto end;
		}
		Tcl_UtfToExternal(NULL, unicodeEncoding, Tcl_DStringValue(&ds),
			Tcl_DStringLength(&ds), 0, NULL, (char *) file,
			sizeof(file), NULL, NULL, NULL);
		break;
	    }
	    case FILE_MULTIPLE: {
		if (Tcl_GetBooleanFromObj(interp, valuePtr,
			&multi) != TCL_OK) {
		    return TCL_ERROR;
		}
		break;
	    }
	    case FILE_PARENT: {
		tkwin = Tk_NameToWindow(interp, string, tkwin);
		if (tkwin == NULL) {
		    goto end;
		}
		break;
	    }
	    case FILE_TITLE: {
		title = string;
		break;
	    }
	}
    }

    if (filter == NULL) {
	if (MakeFilter(interp, "", &utfFilterString) != TCL_OK) {
	    goto end;
	}
    }

    Tk_MakeWindowExist(tkwin);
    hWnd = Tk_GetHWND(Tk_WindowId(tkwin));

    ZeroMemory(&ofn, sizeof(OPENFILENAMEW));
    ofn.lStructSize		= sizeof(OPENFILENAMEW);
    ofn.hwndOwner		= hWnd;
#ifdef _WIN64
    ofn.hInstance		= (HINSTANCE) GetWindowLongPtr(ofn.hwndOwner, 
					GWLP_HINSTANCE);
#else
    ofn.hInstance		= (HINSTANCE) GetWindowLong(ofn.hwndOwner, 
					GWL_HINSTANCE);
#endif
    ofn.lpstrFile		= (WCHAR *) file;
    ofn.nMaxFile		= TK_MULTI_MAX_PATH;
    ofn.Flags			= OFN_HIDEREADONLY | OFN_PATHMUSTEXIST 
				  | OFN_NOCHANGEDIR | OFN_EXPLORER;
    ofn.lpfnHook		= (LPOFNHOOKPROC) OFNHookProcW;
    ofn.lCustData		= (LPARAM) interp;

    if (open != 0) {
	ofn.Flags |= OFN_FILEMUSTEXIST;
    } else {
	ofn.Flags |= OFN_OVERWRITEPROMPT;
    }

    if (tsdPtr->debugFlag != 0) {
	ofn.Flags |= OFN_ENABLEHOOK;
    }

    if (multi != 0) {
	ofn.Flags |= OFN_ALLOWMULTISELECT;
    }

    if (extension != NULL) {
	Tcl_UtfToExternalDString(unicodeEncoding, extension, -1, &extString);
	ofn.lpstrDefExt = (WCHAR *) Tcl_DStringValue(&extString);
    }

    Tcl_UtfToExternalDString(unicodeEncoding,
	    Tcl_DStringValue(&utfFilterString),
	    Tcl_DStringLength(&utfFilterString), &filterString);
    ofn.lpstrFilter = (WCHAR *) Tcl_DStringValue(&filterString);

    if (Tcl_DStringValue(&utfDirString)[0] != '\0') {
	Tcl_UtfToExternalDString(unicodeEncoding,
		Tcl_DStringValue(&utfDirString),
		Tcl_DStringLength(&utfDirString), &dirString);
    } else {
	/*
	 * NT 5.0 changed the meaning of lpstrInitialDir, so we have
	 * to ensure that we set the [pwd] if the user didn't specify
	 * anything else.
	 */
	Tcl_DString cwd;

	Tcl_DStringFree(&utfDirString);
	if ((Tcl_GetCwd(interp, &utfDirString) == (char *) NULL) ||
		(Tcl_TranslateFileName(interp,
			Tcl_DStringValue(&utfDirString), &cwd) == NULL)) {
	    Tcl_ResetResult(interp);
	} else {
	    Tcl_UtfToExternalDString(unicodeEncoding, Tcl_DStringValue(&cwd),
		    Tcl_DStringLength(&cwd), &dirString);
	}
	Tcl_DStringFree(&cwd);
    }
    ofn.lpstrInitialDir = (WCHAR *) Tcl_DStringValue(&dirString);

    if (title != NULL) {
	Tcl_UtfToExternalDString(unicodeEncoding, title, -1, &titleString);
	ofn.lpstrTitle = (WCHAR *) Tcl_DStringValue(&titleString);
    }

    /*
     * Popup the dialog.
     */

    oldMode = Tcl_SetServiceMode(TCL_SERVICE_ALL);
    if (open != 0) {
	winCode = GetOpenFileNameW(&ofn);
    } else {
	winCode = GetSaveFileNameW(&ofn);
    }
    Tcl_SetServiceMode(oldMode);

    /*
     * Ensure that hWnd is enabled, because it can happen that we
     * have updated the wrapper of the parent, which causes us to
     * leave this child disabled (Windows loses sync).
     */
    EnableWindow(hWnd, 1);

    /*
     * Clear the interp result since anything may have happened during the
     * modal loop.
     */

    Tcl_ResetResult(interp);

    /*
     * Process the results.
     */

    if (winCode != 0) {
	if (ofn.Flags & OFN_ALLOWMULTISELECT) {
            /*
	     * The result in custData->szFile contains many items,
	     * separated with null characters.  It is terminated with
	     * two nulls in a row.  The first element is the directory
	     * path.
	     */
	    char *dir;
	    char *p;
	    char *file;
	    WCHAR *files;
	    Tcl_DString ds;
	    Tcl_DString fullname, filename;
	    Tcl_Obj *returnList;
	    int count = 0;

	    returnList = Tcl_NewObj();
	    Tcl_IncrRefCount(returnList);

	    files = ofn.lpstrFile;
	    Tcl_ExternalToUtfDString(unicodeEncoding, (char *) files, -1, &ds);

	    /* Get directory */
	    dir = Tcl_DStringValue(&ds);
	    for (p = dir; p && *p; p++) {
		/*
		 * Change the pathname to the Tcl "normalized" pathname, where
		 * back slashes are used instead of forward slashes
		 */
		if (*p == '\\') {
		    *p = '/';
		}
	    }

	    while (*files != '\0') {
		while (*files != '\0') {
		    files++;
		}
		files++;
		if (*files != '\0') {
		    count++;
		    Tcl_ExternalToUtfDString(unicodeEncoding,
			    (char *)files, -1, &filename);
		    file = Tcl_DStringValue(&filename);
		    for (p = file; *p != '\0'; p++) {
			if (*p == '\\') {
			    *p = '/';
			}
		    }
		    Tcl_DStringInit(&fullname);
		    Tcl_DStringAppend(&fullname, dir, -1);
		    Tcl_DStringAppend(&fullname, "/", -1);
		    Tcl_DStringAppend(&fullname, file, -1);
		    Tcl_ListObjAppendElement(interp, returnList,
			    Tcl_NewStringObj(Tcl_DStringValue(&fullname), -1));
		    Tcl_DStringFree(&fullname);
		    Tcl_DStringFree(&filename);
		}
	    }
	    if (count == 0) {
		/*
		 * Only one file was returned.
		 */
		Tcl_ListObjAppendElement(interp, returnList,
			Tcl_NewStringObj(dir, -1));
	    }
	    Tcl_SetObjResult(interp, returnList);
	    Tcl_DecrRefCount(returnList);
	    Tcl_DStringFree(&ds);
	} else {
	    char *p;
	    Tcl_DString ds;
	    
	    Tcl_ExternalToUtfDString(unicodeEncoding,
		    (char *) ofn.lpstrFile, -1, &ds);
	    for (p = Tcl_DStringValue(&ds); *p != '\0'; p++) {
		/*
		 * Change the pathname to the Tcl "normalized" pathname, where
		 * back slashes are used instead of forward slashes
		 */
		if (*p == '\\') {
		    *p = '/';
		}
	    }
	    Tcl_AppendResult(interp, Tcl_DStringValue(&ds), NULL);
	    Tcl_DStringFree(&ds);
	}
	result = TCL_OK;
    } else {
	/*
	 * Use the CommDlgExtendedError() function to retrieve the error code.
	 * This function can return one of about two dozen codes; most of
	 * these indicate some sort of gross system failure (insufficient
	 * memory, bad window handles, etc.).  Most of the error codes will be
	 * ignored; as we find we want more specific error messages for
	 * particular errors, we can extend the code as needed.
	 *
	 * We could also check for FNERR_BUFFERTOOSMALL, but we can't
	 * really do anything about it when it happens.
	 */

	if (CommDlgExtendedError() == FNERR_INVALIDFILENAME) {
	    char *p;
	    Tcl_DString ds;
	    
	    Tcl_ExternalToUtfDString(unicodeEncoding,
		    (char *) ofn.lpstrFile, -1, &ds);
	    for (p = Tcl_DStringValue(&ds); *p != '\0'; p++) {
		/*
		 * Change the pathname to the Tcl "normalized" pathname,
		 * where back slashes are used instead of forward slashes
		 */
		if (*p == '\\') {
		    *p = '/';
		}
	    }
	    Tcl_SetResult(interp, "invalid filename \"", TCL_STATIC);
	    Tcl_AppendResult(interp, Tcl_DStringValue(&ds), "\"", NULL);
	    Tcl_DStringFree(&ds);
	} else {
	    result = TCL_OK;
	}
    }
    
    if (ofn.lpstrTitle != NULL) {
	Tcl_DStringFree(&titleString);
    }
    if (ofn.lpstrInitialDir != NULL) {
	Tcl_DStringFree(&dirString);
    }
    Tcl_DStringFree(&filterString);
    if (ofn.lpstrDefExt != NULL) {
	Tcl_DStringFree(&extString);
    }

    end:
    Tcl_DStringFree(&utfDirString);
    Tcl_DStringFree(&utfFilterString);

    return result;
}

/*
 *-------------------------------------------------------------------------
 *
 * OFNHookProcW --
 *
 *	Hook procedure called only if debugging is turned on.  Sets
 *	the "tk_dialog" variable when the dialog is ready to receive
 *	messages.
 *
 * Results:
 *	Returns 0 to allow default processing of messages to occur.
 *
 * Side effects:
 *	None.
 *
 *-------------------------------------------------------------------------
 */

static UINT APIENTRY 
OFNHookProcW(
    HWND hdlg,		// handle to child dialog window
    UINT uMsg,		// message identifier
    WPARAM wParam,	// message parameter
    LPARAM lParam) 	// message parameter
{
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    OPENFILENAMEW *ofnPtr;

    if (uMsg == WM_INITDIALOG) {
#ifdef _WIN64
	SetWindowLongPtr(hdlg, GWLP_USERDATA, lParam);
#else
	SetWindowLong(hdlg, GWL_USERDATA, lParam);
#endif
    } else if (uMsg == WM_WINDOWPOSCHANGED) {
	/*
	 * This message is delivered at the right time to enable Tk
	 * to set the debug information.  Unhooks itself so it 
	 * won't set the debug information every time it gets a 
	 * WM_WINDOWPOSCHANGED message.
	 */

#ifdef _WIN64
        ofnPtr = (OPENFILENAMEW *) GetWindowLongPtr(hdlg, GWLP_USERDATA);
#else
        ofnPtr = (OPENFILENAMEW *) GetWindowLong(hdlg, GWL_USERDATA);
#endif
	if (ofnPtr != NULL) {
	    hdlg = GetParent(hdlg);
	    tsdPtr->debugInterp = (Tcl_Interp *) ofnPtr->lCustData;
	    Tcl_DoWhenIdle(SetTkDialog, (ClientData) hdlg);
#ifdef _WIN64
	    SetWindowLongPtr(hdlg, GWLP_USERDATA, (LPARAM) NULL);
#else
	    SetWindowLong(hdlg, GWL_USERDATA, (LPARAM) NULL);
#endif
	}
    }
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * GetFileNameA --
 *
 *	Calls GetOpenFileName() or GetSaveFileName().
 *
 * Results:
 *	See user documentation.
 *
 * Side effects:
 *	See user documentation.
 *
 *----------------------------------------------------------------------
 */

static int 
GetFileNameA(clientData, interp, objc, objv, open)
    ClientData clientData;	/* Main window associated with interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
    int open;			/* 1 to call GetOpenFileName(), 0 to 
				 * call GetSaveFileName(). */
{
    OPENFILENAME ofn;
    TCHAR file[TK_MULTI_MAX_PATH], savePath[MAX_PATH];
    int result, winCode, oldMode, i, multi = 0;
    char *extension, *filter, *title;
    Tk_Window tkwin;
    HWND hWnd;
    Tcl_DString utfFilterString, utfDirString;
    Tcl_DString extString, filterString, dirString, titleString;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    static CONST char *saveOptionStrings[] = {
	"-defaultextension", "-filetypes", "-initialdir", "-initialfile",
	"-parent", "-title", NULL
    };
    static CONST char *openOptionStrings[] = {
	"-defaultextension", "-filetypes", "-initialdir", "-initialfile",
	"-multiple", "-parent", "-title", NULL
    };
    CONST char **optionStrings;

    enum options {
	FILE_DEFAULT,	FILE_TYPES,	FILE_INITDIR,	FILE_INITFILE,
	FILE_MULTIPLE,	FILE_PARENT,	FILE_TITLE
    };

    result = TCL_ERROR;
    file[0] = '\0';

    /*
     * Parse the arguments.
     */

    extension = NULL;
    filter = NULL;
    Tcl_DStringInit(&utfFilterString);
    Tcl_DStringInit(&utfDirString);
    tkwin = (Tk_Window) clientData;
    title = NULL;

    if (open) {
	optionStrings = openOptionStrings;
    } else {
	optionStrings = saveOptionStrings;
    }

    for (i = 1; i < objc; i += 2) {
	int index;
	char *string;
	Tcl_Obj *optionPtr, *valuePtr;

	optionPtr = objv[i];
	valuePtr = objv[i + 1];

	if (Tcl_GetIndexFromObj(interp, optionPtr, optionStrings,
		"option", 0, &index) != TCL_OK) {
	    goto end;
	}
	/*
	 * We want to maximize code sharing between the open and save file
	 * dialog implementations; in particular, the switch statement below.
	 * We use different sets of option strings from the GetIndexFromObj
	 * call above, but a single enumeration for both.  The save file
	 * dialog doesn't support -multiple, but it falls in the middle of
	 * the enumeration.  Ultimately, this means that when the index found
	 * by GetIndexFromObj is >= FILE_MULTIPLE, when doing a save file
	 * dialog, we have to increment the index, so that it matches the
	 * open file dialog enumeration.
	 */
	if (!open && index >= FILE_MULTIPLE) {
	    index++;
	}
	if (i + 1 == objc) {
	    string = Tcl_GetStringFromObj(optionPtr, NULL);
	    Tcl_AppendResult(interp, "value for \"", string, "\" missing", 
		    (char *) NULL);
	    goto end;
	}

	string = Tcl_GetStringFromObj(valuePtr, NULL);
	switch ((enum options) index) {
	    case FILE_DEFAULT: {
		if (string[0] == '.') {
		    string++;
		}
		extension = string;
		break;
	    }
	    case FILE_TYPES: {
		Tcl_DStringFree(&utfFilterString);
		if (MakeFilter(interp, string, &utfFilterString) != TCL_OK) {
		    goto end;
		}
		filter = Tcl_DStringValue(&utfFilterString);
		break;
	    }
	    case FILE_INITDIR: {
		Tcl_DStringFree(&utfDirString);
		if (Tcl_TranslateFileName(interp, string,
			&utfDirString) == NULL) {
		    goto end;
		}
		break;
	    }
	    case FILE_INITFILE: {
		Tcl_DString ds;

		if (Tcl_TranslateFileName(interp, string, &ds) == NULL) {
		    goto end;
		}
		Tcl_UtfToExternal(NULL, NULL, Tcl_DStringValue(&ds), 
			Tcl_DStringLength(&ds), 0, NULL, (char *) file, 
			sizeof(file), NULL, NULL, NULL);
		break;
	    }
	    case FILE_MULTIPLE: {
		if (Tcl_GetBooleanFromObj(interp, valuePtr,
			&multi) != TCL_OK) {
		    return TCL_ERROR;
		}
		break;
	    }
	    case FILE_PARENT: {
		tkwin = Tk_NameToWindow(interp, string, tkwin);
		if (tkwin == NULL) {
		    goto end;
		}
		break;
	    }
	    case FILE_TITLE: {
		title = string;
		break;
	    }
	}
    }

    if (filter == NULL) {
	if (MakeFilter(interp, "", &utfFilterString) != TCL_OK) {
	    goto end;
	}
    }

    Tk_MakeWindowExist(tkwin);
    hWnd = Tk_GetHWND(Tk_WindowId(tkwin));

    ofn.lStructSize		= sizeof(ofn);
    ofn.hwndOwner		= hWnd;
#ifdef _WIN64
    ofn.hInstance		= (HINSTANCE) GetWindowLongPtr(ofn.hwndOwner, 
					GWLP_HINSTANCE);
#else
    ofn.hInstance		= (HINSTANCE) GetWindowLong(ofn.hwndOwner, 
					GWL_HINSTANCE);
#endif
    ofn.lpstrFilter		= NULL;
    ofn.lpstrCustomFilter	= NULL;
    ofn.nMaxCustFilter		= 0;
    ofn.nFilterIndex		= 0;
    ofn.lpstrFile		= (LPTSTR) file;
    ofn.nMaxFile		= TK_MULTI_MAX_PATH;
    ofn.lpstrFileTitle		= NULL;
    ofn.nMaxFileTitle		= 0;
    ofn.lpstrInitialDir		= NULL;
    ofn.lpstrTitle		= NULL;
    ofn.Flags			= OFN_HIDEREADONLY | OFN_PATHMUSTEXIST 
				  | OFN_NOCHANGEDIR | OFN_EXPLORER;
    ofn.nFileOffset		= 0;
    ofn.nFileExtension		= 0;
    ofn.lpstrDefExt		= NULL;
    ofn.lpfnHook		= (LPOFNHOOKPROC) OFNHookProc;
    ofn.lCustData		= (LPARAM) interp;
    ofn.lpTemplateName		= NULL;

    if (open != 0) {
	ofn.Flags |= OFN_FILEMUSTEXIST;
    } else {
	ofn.Flags |= OFN_OVERWRITEPROMPT;
    }

    if (tsdPtr->debugFlag != 0) {
	ofn.Flags |= OFN_ENABLEHOOK;
    }

    if (multi != 0) {
	ofn.Flags |= OFN_ALLOWMULTISELECT;
    }

    if (extension != NULL) {
	Tcl_UtfToExternalDString(NULL, extension, -1, &extString);
	ofn.lpstrDefExt = (LPTSTR) Tcl_DStringValue(&extString);
    }
    Tcl_UtfToExternalDString(NULL, Tcl_DStringValue(&utfFilterString),
	    Tcl_DStringLength(&utfFilterString), &filterString);
    ofn.lpstrFilter = (LPTSTR) Tcl_DStringValue(&filterString);

    if (Tcl_DStringValue(&utfDirString)[0] != '\0') {
	Tcl_UtfToExternalDString(NULL, Tcl_DStringValue(&utfDirString),
		Tcl_DStringLength(&utfDirString), &dirString);
    } else {
	/*
	 * NT 5.0 changed the meaning of lpstrInitialDir, so we have
	 * to ensure that we set the [pwd] if the user didn't specify
	 * anything else.
	 */
	Tcl_DString cwd;

	Tcl_DStringFree(&utfDirString);
	if ((Tcl_GetCwd(interp, &utfDirString) == (char *) NULL) ||
		(Tcl_TranslateFileName(interp,
			Tcl_DStringValue(&utfDirString), &cwd) == NULL)) {
	    Tcl_ResetResult(interp);
	} else {
	    Tcl_UtfToExternalDString(NULL, Tcl_DStringValue(&cwd),
		    Tcl_DStringLength(&cwd), &dirString);
	}
	Tcl_DStringFree(&cwd);
    }
    ofn.lpstrInitialDir = (LPTSTR) Tcl_DStringValue(&dirString);

    if (title != NULL) {
	Tcl_UtfToExternalDString(NULL, title, -1, &titleString);
	ofn.lpstrTitle = (LPTSTR) Tcl_DStringValue(&titleString);
    }

    /*
     * Popup the dialog.
     */

    GetCurrentDirectory(MAX_PATH, savePath);
    oldMode = Tcl_SetServiceMode(TCL_SERVICE_ALL);
    if (open != 0) {
	winCode = GetOpenFileName(&ofn);
    } else {
	winCode = GetSaveFileName(&ofn);
    }
    Tcl_SetServiceMode(oldMode);
    SetCurrentDirectory(savePath);

    /*
     * Ensure that hWnd is enabled, because it can happen that we
     * have updated the wrapper of the parent, which causes us to
     * leave this child disabled (Windows loses sync).
     */
    EnableWindow(hWnd, 1);

    /*
     * Clear the interp result since anything may have happened during the
     * modal loop.
     */

    Tcl_ResetResult(interp);

    /*
     * Process the results.
     */

    if (winCode != 0) {
	if (ofn.Flags & OFN_ALLOWMULTISELECT) {
            /*
	     * The result in custData->szFile contains many items,
	     * separated with null characters.  It is terminated with
	     * two nulls in a row.  The first element is the directory
	     * path.
	     */
	    char *dir;
	    char *p;
	    char *file;
	    char *files;
	    Tcl_DString ds;
	    Tcl_DString fullname, filename;
	    Tcl_Obj *returnList;
	    int count = 0;

	    returnList = Tcl_NewObj();
	    Tcl_IncrRefCount(returnList);

	    files = ofn.lpstrFile;
	    Tcl_ExternalToUtfDString(NULL, (char *) files, -1, &ds);

	    /* Get directory */
	    dir = Tcl_DStringValue(&ds);
	    for (p = dir; p && *p; p++) {
		/*
		 * Change the pathname to the Tcl "normalized" pathname, where
		 * back slashes are used instead of forward slashes
		 */
		if (*p == '\\') {
		    *p = '/';
		}
	    }

	    while (*files != '\0') {
		while (*files != '\0') {
		    files++;
		}
		files++;
		if (*files != '\0') {
		    count++;
		    Tcl_ExternalToUtfDString(NULL,
			    (char *)files, -1, &filename);
		    file = Tcl_DStringValue(&filename);
		    for (p = file; *p != '\0'; p++) {
			if (*p == '\\') {
			    *p = '/';
			}
		    }
		    Tcl_DStringInit(&fullname);
		    Tcl_DStringAppend(&fullname, dir, -1);
		    Tcl_DStringAppend(&fullname, "/", -1);
		    Tcl_DStringAppend(&fullname, file, -1);
		    Tcl_ListObjAppendElement(interp, returnList,
			    Tcl_NewStringObj(Tcl_DStringValue(&fullname), -1));
		    Tcl_DStringFree(&fullname);
		    Tcl_DStringFree(&filename);
		}
	    }
	    if (count == 0) {
		/*
		 * Only one file was returned.
		 */
		Tcl_ListObjAppendElement(interp, returnList,
			Tcl_NewStringObj(dir, -1));
	    }
	    Tcl_SetObjResult(interp, returnList);
	    Tcl_DecrRefCount(returnList);
	    Tcl_DStringFree(&ds);
	} else {
	    char *p;
	    Tcl_DString ds;

	    Tcl_ExternalToUtfDString(NULL, (char *) ofn.lpstrFile, -1, &ds);
	    for (p = Tcl_DStringValue(&ds); *p != '\0'; p++) {
		/*
		 * Change the pathname to the Tcl "normalized" pathname, where
		 * back slashes are used instead of forward slashes
		 */
		if (*p == '\\') {
		    *p = '/';
		}
	    }
	    Tcl_AppendResult(interp, Tcl_DStringValue(&ds), NULL);
	    Tcl_DStringFree(&ds);
	}
	result = TCL_OK;
    } else {
	/*
	 * Use the CommDlgExtendedError() function to retrieve the error code.
	 * This function can return one of about two dozen codes; most of
	 * these indicate some sort of gross system failure (insufficient
	 * memory, bad window handles, etc.).  Most of the error codes will be
	 * ignored;; as we find we want specific error messages for particular
	 * errors, we can extend the code as needed.
	 *
	 * We could also check for FNERR_BUFFERTOOSMALL, but we can't
	 * really do anything about it when it happens.
	 */
	if (CommDlgExtendedError() == FNERR_INVALIDFILENAME) {
	    char *p;
	    Tcl_DString ds;

	    Tcl_ExternalToUtfDString(NULL, (char *) ofn.lpstrFile, -1, &ds);
	    for (p = Tcl_DStringValue(&ds); *p != '\0'; p++) {
		/*
		 * Change the pathname to the Tcl "normalized" pathname,
		 * where back slashes are used instead of forward slashes
		 */
		if (*p == '\\') {
		    *p = '/';
		}
	    }
	    Tcl_SetResult(interp, "invalid filename \"", TCL_STATIC);
	    Tcl_AppendResult(interp, Tcl_DStringValue(&ds), "\"", NULL);
	    Tcl_DStringFree(&ds);
	} else {
	    result = TCL_OK;
	}
    }

    if (ofn.lpstrTitle != NULL) {
	Tcl_DStringFree(&titleString);
    }
    if (ofn.lpstrInitialDir != NULL) {
	Tcl_DStringFree(&dirString);
    }
    Tcl_DStringFree(&filterString);
    if (ofn.lpstrDefExt != NULL) {
	Tcl_DStringFree(&extString);
    }

    end:
    Tcl_DStringFree(&utfDirString);
    Tcl_DStringFree(&utfFilterString);

    return result;
}

/*
 *-------------------------------------------------------------------------
 *
 * OFNHookProc --
 *
 *	Hook procedure called only if debugging is turned on.  Sets
 *	the "tk_dialog" variable when the dialog is ready to receive
 *	messages.
 *
 * Results:
 *	Returns 0 to allow default processing of messages to occur.
 *
 * Side effects:
 *	None.
 *
 *-------------------------------------------------------------------------
 */

static UINT APIENTRY 
OFNHookProc(
    HWND hdlg,		// handle to child dialog window
    UINT uMsg,		// message identifier
    WPARAM wParam,	// message parameter
    LPARAM lParam) 	// message parameter
{
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    OPENFILENAME *ofnPtr;

    if (uMsg == WM_INITDIALOG) {
#ifdef _WIN64
	SetWindowLongPtr(hdlg, GWLP_USERDATA, lParam);
#else
	SetWindowLong(hdlg, GWL_USERDATA, lParam);
#endif
    } else if (uMsg == WM_WINDOWPOSCHANGED) {
	/*
	 * This message is delivered at the right time to both 
	 * old-style and explorer-style hook procs to enable Tk
	 * to set the debug information.  Unhooks itself so it 
	 * won't set the debug information every time it gets a 
	 * WM_WINDOWPOSCHANGED message.
	 */

#ifdef _WIN64
        ofnPtr = (OPENFILENAME *) GetWindowLongPtr(hdlg, GWLP_USERDATA);
#else
        ofnPtr = (OPENFILENAME *) GetWindowLong(hdlg, GWL_USERDATA);
#endif
	if (ofnPtr != NULL) {
	    if (ofnPtr->Flags & OFN_EXPLORER) {
		hdlg = GetParent(hdlg);
	    }
	    tsdPtr->debugInterp = (Tcl_Interp *) ofnPtr->lCustData;
	    Tcl_DoWhenIdle(SetTkDialog, (ClientData) hdlg);
#ifdef _WIN64
	    SetWindowLongPtr(hdlg, GWLP_USERDATA, (LPARAM) NULL);
#else
	    SetWindowLong(hdlg, GWL_USERDATA, (LPARAM) NULL);
#endif
	}
    }
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * MakeFilter --
 *
 *	Allocate a buffer to store the filters in a format understood by
 *	Windows
 *
 * Results:
 *	A standard TCL return value.
 *
 * Side effects:
 *	ofnPtr->lpstrFilter is modified.
 *
 *----------------------------------------------------------------------
 */
static int 
MakeFilter(interp, string, dsPtr) 
    Tcl_Interp *interp;		/* Current interpreter. */
    char *string;		/* String value of the -filetypes option */
    Tcl_DString *dsPtr;		/* Filled with windows filter string. */
{
    char *filterStr;
    char *p;
    int pass;
    FileFilterList flist;
    FileFilter *filterPtr;

    TkInitFileFilters(&flist);
    if (TkGetFileFilters(interp, &flist, string, 1) != TCL_OK) {
	return TCL_ERROR;
    }

    if (flist.filters == NULL) {
	/*
	 * Use "All Files (*.*) as the default filter if none is specified
	 */
	char *defaultFilter = "All Files (*.*)";

	p = filterStr = (char*)ckalloc(30 * sizeof(char));

	strcpy(p, defaultFilter);
	p+= strlen(defaultFilter);

	*p++ = '\0';
	*p++ = '*';
	*p++ = '.';
	*p++ = '*';
	*p++ = '\0';
	*p++ = '\0';
	*p = '\0';

    } else {
	/* We format the filetype into a string understood by Windows:
	 * {"Text Documents" {.doc .txt} {TEXT}} becomes
	 * "Text Documents (*.doc,*.txt)\0*.doc;*.txt\0"
	 *
	 * See the Windows OPENFILENAME manual page for details on the filter
	 * string format.
	 */

	/*
	 * Since we may only add asterisks (*) to the filter, we need at most
	 * twice the size of the string to format the filter
	 */
	filterStr = ckalloc((unsigned int) strlen(string) * 3);

	for (filterPtr = flist.filters, p = filterStr; filterPtr;
	        filterPtr = filterPtr->next) {
	    char *sep;
	    FileFilterClause *clausePtr;

	    /*
	     *  First, put in the name of the file type
	     */
	    strcpy(p, filterPtr->name);
	    p+= strlen(filterPtr->name);
	    *p++ = ' ';
	    *p++ = '(';

	    for (pass = 1; pass <= 2; pass++) {
		/*
		 * In the first pass, we format the extensions in the 
		 * name field. In the second pass, we format the extensions in
		 * the filter pattern field
		 */
		sep = "";
		for (clausePtr=filterPtr->clauses;clausePtr;
		         clausePtr=clausePtr->next) {
		    GlobPattern *globPtr;
		

		    for (globPtr=clausePtr->patterns; globPtr;
			    globPtr=globPtr->next) {
			strcpy(p, sep);
			p+= strlen(sep);
			strcpy(p, globPtr->pattern);
			p+= strlen(globPtr->pattern);

			if (pass==1) {
			    sep = ",";
			} else {
			    sep = ";";
			}
		    }
		}
		if (pass == 1) {
		    if (pass == 1) {
			*p ++ = ')';
		    }
		}
		*p ++ = '\0';
	    }
	}

	/*
	 * Windows requires the filter string to be ended by two NULL
	 * characters.
	 */
	*p++ = '\0';
	*p = '\0';
    }

    Tcl_DStringAppend(dsPtr, filterStr, (int) (p - filterStr));
    ckfree((char *) filterStr);

    TkFreeFileFilters(&flist);
    return TCL_OK;
}

#ifdef USE_NEW_CHOOSEDIR
/*
 *----------------------------------------------------------------------
 *
 * Tk_ChooseDirectoryObjCmd --
 *
 * This procedure implements the "tk_chooseDirectory" dialog box
 * for the Windows platform. See the user documentation for details
 * on what it does. Uses the newer SHBrowseForFolder explorer type
 * interface.
 *
 * Results:
 * See user documentation.
 *
 * Side effects:
 * A modal dialog window is created.  Tcl_SetServiceMode() is
 * called to allow background events to be processed
 *
 *----------------------------------------------------------------------

The procedure tk_chooseDirectory pops up a dialog box for the user to
select a directory.  The following option-value pairs are possible as
command line arguments:

-initialdir dirname

Specifies that the directories in directory should be displayed when the
dialog pops up.  If this parameter is not specified, then the directories
in the current working directory are displayed.  If the parameter specifies
a relative path, the return value will convert the relative path to an
absolute path.  This option may not always work on the Macintosh.  This is
not a bug.  Rather, the General Controls control panel on the Mac allows
the end user to override the application default directory.

-parent window

Makes window the logical parent of the dialog.  The dialog is displayed on
top of its parent window.

-title titleString

Specifies a string to display as the title of the dialog box.  If this
option is not specified, then a default title will be displayed.

-mustexist boolean

Specifies whether the user may specify non-existant directories.  If this
parameter is true, then the user may only select directories that already
exist.  The default value is false.

New Behaviour:

- If mustexist = 0 and a user entered folder does not exist, a prompt will
  pop-up asking if the user wants another chance to change it. The old
  dialog just returned the bogus entry. On mustexist = 1, the entries MUST
  exist before exiting the box with OK.

  Bugs:

- If valid abs directory name is entered into the entry box and Enter
  pressed, the box will close returning the name. This is inconsistent when
  entering relative names or names with forward slashes, which are
  invalidated then corrected in the callback. After correction, the box is
  held open to allow further modification by the user.

- Not sure how to implement localization of message prompts.

- -title is really -message.
ToDo:
- Fix bugs.
- test to see what platforms this really works on.  May require v4.71
  of shell32.dll everywhere (what is standard?).
 *
 */
int
Tk_ChooseDirectoryObjCmd(clientData, interp, objc, objv)
    ClientData clientData;      /* Main window associated with interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    char path[MAX_PATH];
    int oldMode, result, i;
    LPCITEMIDLIST pidl;		/* Returned by browser */
    BROWSEINFO bInfo;		/* Used by browser */
    CHOOSEDIRDATA cdCBData;	/* Structure to pass back and forth */
    LPMALLOC pMalloc;		/* Used by shell */

    Tk_Window tkwin;
    HWND hWnd;
    char *utfTitle;		/* Title for window */
    TCHAR saveDir[MAX_PATH];
    Tcl_DString titleString;	/* UTF Title */
    Tcl_DString initDirString;	/* Initial directory */
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *)
	Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    static CONST char *optionStrings[] = {
        "-initialdir", "-mustexist",  "-parent",  "-title", (char *) NULL
    };
    enum options {
        DIR_INITIAL,   DIR_EXIST,  DIR_PARENT, FILE_TITLE
    };

    /*
     * Initialize
     */
    result		= TCL_ERROR;
    path[0]		= '\0';
    utfTitle		= NULL;

    ZeroMemory(&cdCBData, sizeof(CHOOSEDIRDATA));
    cdCBData.interp	= interp;

    tkwin = (Tk_Window) clientData;
    /*
     * Process the command line options
     */
    for (i = 1; i < objc; i += 2) {
        int index;
        char *string;
        Tcl_Obj *optionPtr, *valuePtr;

        optionPtr = objv[i];
        valuePtr = objv[i + 1];

        if (Tcl_GetIndexFromObj(interp, optionPtr, optionStrings, "option",
                0, &index) != TCL_OK) {
            goto cleanup;
        }
        if (i + 1 == objc) {
            string = Tcl_GetStringFromObj(optionPtr, NULL);
            Tcl_AppendResult(interp, "value for \"", string, "\" missing",
                    (char *) NULL);
            goto cleanup;
        }

	string = Tcl_GetString(valuePtr);
        switch ((enum options) index) {
            case DIR_INITIAL: {
                if (Tcl_TranslateFileName(interp, string,
			&initDirString) == NULL) {
		    goto cleanup;
		}
                string = Tcl_DStringValue(&initDirString);
                /*
                 * Convert possible relative path to full path to keep
                 * dialog happy
                 */
                GetFullPathName(string, MAX_PATH, saveDir, NULL);
                lstrcpyn(cdCBData.utfInitDir, saveDir, MAX_PATH);
                Tcl_DStringFree(&initDirString);
                break;
            }
            case DIR_EXIST: {
                if (Tcl_GetBooleanFromObj(interp, valuePtr,
                        &cdCBData.mustExist) != TCL_OK) {
                    goto cleanup;
                }
                break;
            }
            case DIR_PARENT: {
                tkwin = Tk_NameToWindow(interp, string, tkwin);
                if (tkwin == NULL) {
                    goto cleanup;
                }
                break;
            }
            case FILE_TITLE: {
                utfTitle = string;
                break;
            }
        }
    }

    /*
     * Get ready to call the browser
     */

    Tk_MakeWindowExist(tkwin);
    hWnd = Tk_GetHWND(Tk_WindowId(tkwin));

    /*
     * Setup the parameters used by SHBrowseForFolder
     */

    bInfo.hwndOwner      = hWnd;
    bInfo.pszDisplayName = path;
    bInfo.pidlRoot       = NULL;
    if (lstrlen(cdCBData.utfInitDir) == 0) {
        GetCurrentDirectory(MAX_PATH, cdCBData.utfInitDir);
    }
    bInfo.lParam = (LPARAM) &cdCBData;

    if (utfTitle != NULL) {
        Tcl_UtfToExternalDString(NULL, utfTitle, -1, &titleString);
        bInfo.lpszTitle = (LPTSTR) Tcl_DStringValue(&titleString);
    } else {
        bInfo.lpszTitle = "Please choose a directory, then select OK.";
    }

    /*
     * Set flags to add edit box (needs 4.71 Shell DLLs), status text line,
     * validate edit box and
     */
    bInfo.ulFlags  =  BIF_EDITBOX | BIF_STATUSTEXT | BIF_RETURNFSANCESTORS
        | BIF_VALIDATE;

    /*
     * Callback to handle events
     */
    bInfo.lpfn     = (BFFCALLBACK) ChooseDirectoryValidateProc;

    /*
     * Display dialog in background and process result.
     * We look to give the user a chance to change their mind
     * on an invalid folder if mustexist is 0;
     */

    oldMode = Tcl_SetServiceMode(TCL_SERVICE_ALL);
    GetCurrentDirectory(MAX_PATH, saveDir);
    if (SHGetMalloc(&pMalloc) == NOERROR) {
	pidl = SHBrowseForFolder(&bInfo);
	/* Null for cancel button or invalid dir, otherwise valid*/
	if (pidl != NULL) {
	    if (!SHGetPathFromIDList(pidl, path)) {
		Tcl_SetResult(interp, "Error: Not a file system folder\n",
			TCL_VOLATILE);
	    };
	    pMalloc->lpVtbl->Free(pMalloc, (void *) pidl);
	} else if (lstrlen(cdCBData.utfRetDir) > 0) {
	    lstrcpy(path, cdCBData.utfRetDir);
	}
	pMalloc->lpVtbl->Release(pMalloc);
    }
    SetCurrentDirectory(saveDir);
    Tcl_SetServiceMode(oldMode);

    /*
     * Ensure that hWnd is enabled, because it can happen that we
     * have updated the wrapper of the parent, which causes us to
     * leave this child disabled (Windows loses sync).
     */
    EnableWindow(hWnd, 1);

    /*
     * Change the pathname to the Tcl "normalized" pathname, where
     * back slashes are used instead of forward slashes
     */
    Tcl_ResetResult(interp);
    if (*path) {
        char *p;
        Tcl_DString ds;

        Tcl_ExternalToUtfDString(NULL, (char *) path, -1, &ds);
        for (p = Tcl_DStringValue(&ds); *p != '\0'; p++) {
            if (*p == '\\') {
                *p = '/';
            }
        }
        Tcl_AppendResult(interp, Tcl_DStringValue(&ds), NULL);
        Tcl_DStringFree(&ds);
    }

    result = TCL_OK;

    if (utfTitle != NULL) {
        Tcl_DStringFree(&titleString);
    }

    cleanup:
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * ChooseDirectoryValidateProc --
 *
 * Hook procedure called by the explorer ChooseDirectory dialog when events
 * occur.  It is used to validate the text entry the user may have entered.
 *
 * Results:
 * Returns 0 to allow default processing of message, or 1 to
 * tell default dialog procedure not to close.
 *
 *----------------------------------------------------------------------
 */
static UINT APIENTRY
ChooseDirectoryValidateProc (
    HWND hwnd,
    UINT message,
    LPARAM lParam,
    LPARAM lpData)
{
    TCHAR selDir[MAX_PATH];
    CHOOSEDIRDATA *chooseDirSharedData;
    Tcl_DString initDirString;
    char string[MAX_PATH];
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *)
        Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    chooseDirSharedData = (CHOOSEDIRDATA *)lpData;

#ifdef _WIN64
    SetWindowLongPtr(hwnd, GWLP_USERDATA, lpData);
#else
    SetWindowLong(hwnd, GWL_USERDATA, lpData);
#endif

    if (tsdPtr->debugFlag) {
        tsdPtr->debugInterp = (Tcl_Interp *) chooseDirSharedData->interp;
        Tcl_DoWhenIdle(SetTkDialog, (ClientData) hwnd);
    }
    chooseDirSharedData->utfRetDir[0] = '\0';
    switch (message) {
        case BFFM_VALIDATEFAILED:
            /*
             * First save and check to see if it is a valid path name, if
             * so then make that path the one shown in the
             * window. Otherwise, it failed the check and should be treated
             * as such. Use Set/GetCurrentDirectory which allows relative
             * path names and names with forward slashes. Use
             * Tcl_TranslateFileName to make sure names like ~ are
             * converted correctly.
             */
            Tcl_TranslateFileName(chooseDirSharedData->interp,
                    (char *)lParam, &initDirString);
            lstrcpyn (string, Tcl_DStringValue(&initDirString), MAX_PATH);
            Tcl_DStringFree(&initDirString);

            if (SetCurrentDirectory((char *)string) == 0) {
                LPTSTR lpFilePart[MAX_PATH];
                /*
                 * Get the full path name to the user entry,
                 * at this point it doesn't exist so see if
                 * it is supposed to. Otherwise just return it.
                 */
                GetFullPathName(string, MAX_PATH,
			chooseDirSharedData->utfRetDir, /*unused*/ lpFilePart);
                if (chooseDirSharedData->mustExist) {
                    /*
                     * User HAS to select a valid directory.
                     */
                    wsprintf(selDir, _T("Directory '%.200s' does not exist,\nplease select or enter an existing directory."), chooseDirSharedData->utfRetDir);
                    MessageBox(NULL, selDir, NULL, MB_ICONEXCLAMATION|MB_OK);
                    return 1;
                }
            } else {
                /*
                 * Changed to new folder OK, return immediatly with the
                 * current directory in utfRetDir.
                 */
                GetCurrentDirectory(MAX_PATH, chooseDirSharedData->utfRetDir);
                return 0;
            }
            return 0;

        case BFFM_SELCHANGED:
            /*
             * Set the status window to the currently selected path.
             * And enable the OK button if a file system folder, otherwise
             * disable the OK button for things like server names.
             * perhaps a new switch -enablenonfolders can be used to allow
             * non folders to be selected.
             *
             * Not called when user changes edit box directly.
             */

            if (SHGetPathFromIDList((LPITEMIDLIST) lParam, selDir)) {
                SendMessage(hwnd, BFFM_SETSTATUSTEXT, 0, (LPARAM) selDir);
                // enable the OK button
                SendMessage(hwnd, BFFM_ENABLEOK, 0, (LPARAM) 1);
                //EnableWindow(GetDlgItem(hwnd, IDOK), TRUE);
                SetCurrentDirectory(selDir);
            } else {
                // disable the OK button
                SendMessage(hwnd, BFFM_ENABLEOK, 0, (LPARAM) 0);
                //EnableWindow(GetDlgItem(hwnd, IDOK), FALSE);
            }
            UpdateWindow(hwnd);
            return 1;

        case BFFM_INITIALIZED:
            /*
             * Directory browser intializing - tell it where to start from,
             * user specified parameter.
             */
            SetCurrentDirectory((char *) lpData);
            SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)lpData);
            SendMessage(hwnd, BFFM_ENABLEOK, 0, (LPARAM) 1);
            break;

    }
    return 0;
}
#else
/*
 *----------------------------------------------------------------------
 *
 * Tk_ChooseDirectoryObjCmd --
 *
 *	This procedure implements the "tk_chooseDirectory" dialog box 
 *	for the Windows platform. See the user documentation for details 
 *	on what it does.
 *
 * Results:
 *	See user documentation.
 *
 * Side effects:
 *	A modal dialog window is created.  Tcl_SetServiceMode() is
 *	called to allow background events to be processed
 *
 *----------------------------------------------------------------------
 */

int
Tk_ChooseDirectoryObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Main window associated with interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    OPENFILENAME ofn;
    TCHAR path[MAX_PATH], savePath[MAX_PATH];
    ChooseDir cd;
    int result, mustExist, code, mode, i;
    Tk_Window tkwin;
    HWND hWnd;
    char *utfTitle;
    Tcl_DString utfDirString;
    Tcl_DString titleString, dirString;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    static CONST char *optionStrings[] = {
	"-initialdir",	"-mustexist",	"-parent",	"-title",
	NULL
    };
    enum options {
	DIR_INITIAL,	DIR_EXIST,	DIR_PARENT,	FILE_TITLE
    };

    if (tsdPtr->WM_LBSELCHANGED == 0) {
        tsdPtr->WM_LBSELCHANGED = RegisterWindowMessage(LBSELCHSTRING);
    }
   
    result = TCL_ERROR;
    path[0] = '\0';

    Tcl_DStringInit(&utfDirString);
    mustExist = 0;
    tkwin = (Tk_Window) clientData;
    utfTitle = NULL;

    for (i = 1; i < objc; i += 2) {
	int index;
	char *string;
	Tcl_Obj *optionPtr, *valuePtr;

	optionPtr = objv[i];
	valuePtr = objv[i + 1];

	if (Tcl_GetIndexFromObj(interp, optionPtr, optionStrings, "option",
		0, &index) != TCL_OK) {
	    goto cleanup;
	}
	if (i + 1 == objc) {
	    string = Tcl_GetStringFromObj(optionPtr, NULL);
	    Tcl_AppendResult(interp, "value for \"", string, "\" missing", 
		    (char *) NULL);
	    goto cleanup;
	}

	string = Tcl_GetStringFromObj(valuePtr, NULL);
	switch ((enum options) index) {
	    case DIR_INITIAL: {
		Tcl_DStringFree(&utfDirString);
		if (Tcl_TranslateFileName(interp, string, 
			&utfDirString) == NULL) {
		    goto cleanup;
		}
		break;
	    }
	    case DIR_EXIST: {
		if (Tcl_GetBooleanFromObj(interp, valuePtr, &mustExist) != TCL_OK) {
		    goto cleanup;
		}
		break;
	    }
	    case DIR_PARENT: {
		tkwin = Tk_NameToWindow(interp, string, tkwin);
		if (tkwin == NULL) {
		    goto cleanup;
		}
		break;
	    }
	    case FILE_TITLE: {
		utfTitle = string;
		break;
	    }
	}
    }

    Tk_MakeWindowExist(tkwin);
    hWnd = Tk_GetHWND(Tk_WindowId(tkwin));

    cd.interp = interp;
    cd.ofnPtr = &ofn;

    ofn.lStructSize		= sizeof(ofn);
    ofn.hwndOwner		= hWnd;
#ifdef _WIN64
    ofn.hInstance		= (HINSTANCE) GetWindowLongPtr(ofn.hwndOwner, 
					GWLP_HINSTANCE);
#else
    ofn.hInstance		= (HINSTANCE) GetWindowLong(ofn.hwndOwner, 
					GWL_HINSTANCE);
#endif
    ofn.lpstrFilter		= NULL;
    ofn.lpstrCustomFilter	= NULL;
    ofn.nMaxCustFilter		= 0;
    ofn.nFilterIndex		= 0;
    ofn.lpstrFile		= NULL; //(TCHAR *) path;
    ofn.nMaxFile		= MAX_PATH;
    ofn.lpstrFileTitle		= NULL;
    ofn.nMaxFileTitle		= 0;
    ofn.lpstrInitialDir		= NULL;
    ofn.lpstrTitle		= NULL;
    ofn.Flags			= OFN_HIDEREADONLY
				  | OFN_ENABLEHOOK | OFN_ENABLETEMPLATE;
    ofn.nFileOffset		= 0;
    ofn.nFileExtension		= 0;
    ofn.lpstrDefExt		= NULL;
    ofn.lCustData		= (LPARAM) &cd;
    ofn.lpfnHook		= (LPOFNHOOKPROC) ChooseDirectoryHookProc;
    ofn.lpTemplateName		= MAKEINTRESOURCE(FILEOPENORD);

    if (Tcl_DStringValue(&utfDirString)[0] != '\0') {
	Tcl_UtfToExternalDString(NULL, Tcl_DStringValue(&utfDirString), 
		Tcl_DStringLength(&utfDirString), &dirString);
    } else {
	/*
	 * NT 5.0 changed the meaning of lpstrInitialDir, so we have
	 * to ensure that we set the [pwd] if the user didn't specify
	 * anything else.
	 */
	Tcl_DString cwd;

	Tcl_DStringFree(&utfDirString);
	if ((Tcl_GetCwd(interp, &utfDirString) == (char *) NULL) ||
		(Tcl_TranslateFileName(interp,
			Tcl_DStringValue(&utfDirString), &cwd) == NULL)) {
	    Tcl_ResetResult(interp);
	} else {
	    Tcl_UtfToExternalDString(NULL, Tcl_DStringValue(&cwd),
		    Tcl_DStringLength(&cwd), &dirString);
	}
	Tcl_DStringFree(&cwd);
    }
    ofn.lpstrInitialDir = (LPTSTR) Tcl_DStringValue(&dirString);

    if (mustExist) {
	ofn.Flags |= OFN_PATHMUSTEXIST;
    }
    if (utfTitle != NULL) {
	Tcl_UtfToExternalDString(NULL, utfTitle, -1, &titleString);
	ofn.lpstrTitle = (LPTSTR) Tcl_DStringValue(&titleString);
    }

    /*
     * Display dialog.  The choose directory dialog doesn't preserve the
     * current directory, so it must be saved and restored here.
     */
    
    GetCurrentDirectory(MAX_PATH, savePath);
    mode = Tcl_SetServiceMode(TCL_SERVICE_ALL);
    code = GetOpenFileName(&ofn);
    Tcl_SetServiceMode(mode);
    SetCurrentDirectory(savePath);

    /*
     * Ensure that hWnd is enabled, because it can happen that we
     * have updated the wrapper of the parent, which causes us to
     * leave this child disabled (Windows loses sync).
     */
    EnableWindow(hWnd, 1);

    Tcl_ResetResult(interp);
    if (code != 0) {
	/*
	 * Change the pathname to the Tcl "normalized" pathname, where
	 * back slashes are used instead of forward slashes
	 */

	char *p;
	Tcl_DString ds;

	Tcl_ExternalToUtfDString(NULL, (char *) cd.path, -1, &ds);
	for (p = Tcl_DStringValue(&ds); *p != '\0'; p++) {
	    if (*p == '\\') {
		*p = '/';
	    }
	}
	Tcl_AppendResult(interp, Tcl_DStringValue(&ds), NULL);
	Tcl_DStringFree(&ds);
    }

    if (ofn.lpstrTitle != NULL) {
	Tcl_DStringFree(&titleString);
    }
    if (ofn.lpstrInitialDir != NULL) {
	Tcl_DStringFree(&dirString);
    }
    result = TCL_OK;

    cleanup:
    Tcl_DStringFree(&utfDirString);

    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * ChooseDirectoryHookProc --
 *
 *	Hook procedure called by the ChooseDirectory dialog to modify
 *	its default behavior.  The ChooseDirectory dialog is really an
 *	OpenFile dialog with certain controls rearranged and certain
 *	behaviors changed.  For instance, typing a name in the 
 *	ChooseDirectory dialog selects a directory, rather than 
 *	selecting a file.
 *
 * Results:
 *	Returns 0 to allow default processing of message, or 1 to 
 *	tell default dialog procedure not to process the message.
 *
 * Side effects:
 *	A dialog window is created the first this procedure is called.
 *	This window is not destroyed and will be reused the next time
 *	the application invokes the "tk_getOpenFile" or
 *	"tk_getSaveFile" command.
 *
 *----------------------------------------------------------------------
 */

static UINT APIENTRY 
ChooseDirectoryHookProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    OPENFILENAME *ofnPtr;
    ChooseDir *cdPtr;

    if (message == WM_INITDIALOG) {
	ofnPtr = (OPENFILENAME *) lParam;
	cdPtr = (ChooseDir *) ofnPtr->lCustData;
	cdPtr->lastCtrl = 0;
	cdPtr->lastIdx = 1000;
	cdPtr->path[0] = '\0';
#ifdef _WIN64
	SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) cdPtr);
#else
	SetWindowLong(hwnd, GWL_USERDATA, (LONG) cdPtr);
#endif

	if (ofnPtr->lpstrInitialDir == NULL) {
	    GetCurrentDirectory(MAX_PATH, cdPtr->path);
	} else {
	    lstrcpy(cdPtr->path, ofnPtr->lpstrInitialDir);
	}
	SetDlgItemText(hwnd, edt10, cdPtr->path);
	SendDlgItemMessage(hwnd, edt10, EM_SETSEL, 0, -1);
	if (tsdPtr->debugFlag) {
	    tsdPtr->debugInterp = cdPtr->interp;
	    Tcl_DoWhenIdle(SetTkDialog, (ClientData) hwnd);
	}
	return 0;
    }

    /*
     * GWL_USERDATA keeps track of cdPtr.
     */
    
#ifdef _WIN64
    cdPtr = (ChooseDir *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
#else
    cdPtr = (ChooseDir *) GetWindowLong(hwnd, GWL_USERDATA);
#endif
    if (cdPtr == NULL) {
	return 0;
    }
    ofnPtr = cdPtr->ofnPtr;

    if (message == tsdPtr->WM_LBSELCHANGED) {
	/*
	 * Called when double-clicking on directory.
	 * If directory wasn't already open, browse that directory.
	 * If directory was already open, return selected directory.
	 */

	int idCtrl, thisItem;

	idCtrl = (int) wParam;
        thisItem = LOWORD(lParam);

	GetCurrentDirectory(MAX_PATH, cdPtr->path);
	if (idCtrl == lst2) {
	    if (cdPtr->lastIdx == thisItem) {
		EndDialog(hwnd, IDOK);
		return 1;
	    }
	    cdPtr->lastIdx = thisItem;
	}
	SetDlgItemText(hwnd, edt10, cdPtr->path);
	SendDlgItemMessage(hwnd, edt10, EM_SETSEL, 0, -1);
    } else if (message == WM_COMMAND) {
	int idCtrl, notifyCode;

	idCtrl = LOWORD(wParam);
	notifyCode = HIWORD(wParam);

	if ((idCtrl != IDOK) || (notifyCode != BN_CLICKED)) {
	    /*
	     * OK Button wasn't clicked.  Do the default.
	     */

	    if ((idCtrl == lst2) || (idCtrl == edt10)) {
		cdPtr->lastCtrl = idCtrl;
	    }
	    return 0;
	}

	/*
	 * Dialogs also get the message that OK was clicked when Enter 
	 * is pressed in some other control.  Find out what window
	 * we were really in when we got the supposed "OK", because the 
	 * behavior is different.
	 */

	if (cdPtr->lastCtrl == edt10) {
	    /*
	     * Hit Enter or clicked OK while typing a directory name in the 
	     * edit control.
	     * If it's a new name, try to go to that directory.
	     * If the name hasn't changed since last time, return selected 
	     * directory.
	     */

	    int changed;
	    TCHAR tmp[MAX_PATH];

	    if (GetDlgItemText(hwnd, edt10, tmp, MAX_PATH) == 0) {
		return 0;
	    }

	    changed = lstrcmp(cdPtr->path, tmp);
	    lstrcpy(cdPtr->path, tmp);

	    if (SetCurrentDirectory(cdPtr->path) == 0) {
		/*
		 * Non-existent directory.
		 */

		if (ofnPtr->Flags & OFN_PATHMUSTEXIST) {
		    /*
		     * Directory must exist.  Complain, then rehighlight text.
		     */

		    wsprintf(tmp, _T("Cannot change directory to \"%.200s\"."),
			    cdPtr->path);
		    MessageBox(hwnd, tmp, NULL, MB_OK);
		    SendDlgItemMessage(hwnd, edt10, EM_SETSEL, 0, -1);
		    return 0;
		} 
		if (changed) {
		    /*
		     * Directory was invalid, but we want to keep displaying
		     * this name.  Don't update the listbox that displays the 
		     * current directory heirarchy, or it'll erase the name.
		     */
		    
		    SendDlgItemMessage(hwnd, edt10, EM_SETSEL, 0, -1);
		    return 0;
		}
	    }
	    if (changed == 0) {
		/*
		 * Name hasn't changed since the last time we hit return
		 * or double-clicked on a directory, so return this.
		 */

		EndDialog(hwnd, IDOK);
		return 1;
	    }
	    
	    cdPtr->lastCtrl = IDOK;

	    /*
	     * The following is the magic code, determined by running 
	     * Spy++ on some other directory chooser, that it takes to 
	     * get this dialog to update the listbox to display the 
	     * current directory.
	     */

	    SetDlgItemText(hwnd, edt1, cdPtr->path);
	    SendMessage(hwnd, WM_COMMAND, (WPARAM) MAKELONG(cmb2, 0x8003), 
		    (LPARAM) GetDlgItem(hwnd, cmb2));
	    return 0;
	} else if (idCtrl == lst2) {
	    /*
	     * Enter key was pressed while in listbox.  
	     * If it's a new directory, allow default behavior to open dir.
	     * If the directory hasn't changed, return selected directory.
	     */

	    int thisItem;

	    thisItem = (int) SendDlgItemMessage(hwnd, lst2, LB_GETCURSEL, 0, 0);
	    if (cdPtr->lastIdx == thisItem) {
		GetCurrentDirectory(MAX_PATH, cdPtr->path);
		EndDialog(hwnd, IDOK);
		return 1;
	    }
	} else if (idCtrl == IDOK) {
	    /* 
	     * The OK button was clicked. Return the value currently selected
             * in the entry.
	     */

	    GetCurrentDirectory(MAX_PATH, cdPtr->path);
	    EndDialog(hwnd, IDOK);
	    return 1;
	}
    }
    return 0;
}
#endif

/*
 *----------------------------------------------------------------------
 *
 * Tk_MessageBoxObjCmd --
 *
 *	This procedure implements the MessageBox window for the
 *	Windows platform. See the user documentation for details on what
 *	it does.
 *
 * Results:
 *	See user documentation.
 *
 * Side effects:
 *	None. The MessageBox window will be destroy before this procedure
 *	returns.
 *
 *----------------------------------------------------------------------
 */

int
Tk_MessageBoxObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Main window associated with interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Tk_Window tkwin, parent;
    HWND hWnd;
    char *message, *title;
    int defaultBtn, icon, type;
    int i, oldMode, flags, winCode;
    Tcl_DString messageString, titleString;
    Tcl_Encoding unicodeEncoding = TkWinGetUnicodeEncoding();
    static CONST char *optionStrings[] = {
	"-default",	"-icon",	"-message",	"-parent",
	"-title",	"-type",	NULL
    };
    enum options {
	MSG_DEFAULT,	MSG_ICON,	MSG_MESSAGE,	MSG_PARENT,
	MSG_TITLE,	MSG_TYPE
    };

    tkwin = (Tk_Window) clientData;

    defaultBtn	= -1;
    icon	= MB_ICONINFORMATION;
    message	= NULL;
    parent	= tkwin;
    title	= NULL;
    type	= MB_OK;

    for (i = 1; i < objc; i += 2) {
	int index;
	char *string;
	Tcl_Obj *optionPtr, *valuePtr;

	optionPtr = objv[i];
	valuePtr = objv[i + 1];

	if (Tcl_GetIndexFromObj(interp, optionPtr, optionStrings, "option",
		TCL_EXACT, &index) != TCL_OK) {
	    return TCL_ERROR;
	}
	if (i + 1 == objc) {
	    string = Tcl_GetStringFromObj(optionPtr, NULL);
	    Tcl_AppendResult(interp, "value for \"", string, "\" missing", 
		    (char *) NULL);
	    return TCL_ERROR;
	}

        string = Tcl_GetStringFromObj(valuePtr, NULL);
	switch ((enum options) index) {
        case MSG_DEFAULT:
	    defaultBtn = TkFindStateNumObj(interp, optionPtr, buttonMap, 
		    valuePtr);
	    if (defaultBtn < 0) {
		return TCL_ERROR;
	    }
	    break;

	case MSG_ICON:
	    icon = TkFindStateNumObj(interp, optionPtr, iconMap, valuePtr);
	    if (icon < 0) {
		return TCL_ERROR;
	    }
	    break;

	case MSG_MESSAGE:
	    message = string;
	    break;

	case MSG_PARENT: 
	    parent = Tk_NameToWindow(interp, string, tkwin);
	    if (parent == NULL) {
		return TCL_ERROR;
	    }
	    break;

	case MSG_TITLE:
	    title = string;
	    break;

	case MSG_TYPE:
	    type = TkFindStateNumObj(interp, optionPtr, typeMap, valuePtr);
	    if (type < 0) {
		return TCL_ERROR;
	    }
	    break;

	}
    }

    Tk_MakeWindowExist(parent);
    hWnd = Tk_GetHWND(Tk_WindowId(parent));
    
    flags = 0;
    if (defaultBtn >= 0) {
	int defaultBtnIdx;

	defaultBtnIdx = -1;
	for (i = 0; i < NUM_TYPES; i++) {
	    if (type == allowedTypes[i].type) {
		int j;

		for (j = 0; j < 3; j++) {
		    if (allowedTypes[i].btnIds[j] == defaultBtn) {
			defaultBtnIdx = j;
			break;
		    }
		}
		if (defaultBtnIdx < 0) {
		    Tcl_AppendResult(interp, "invalid default button \"",
			    TkFindStateString(buttonMap, defaultBtn), 
			    "\"", NULL);
		    return TCL_ERROR;
		}
		break;
	    }
	}
	flags = buttonFlagMap[defaultBtnIdx];
    }

    flags |= icon | type | MB_SYSTEMMODAL;

    Tcl_UtfToExternalDString(unicodeEncoding, message, -1, &messageString);
    Tcl_UtfToExternalDString(unicodeEncoding, title, -1, &titleString);

    oldMode = Tcl_SetServiceMode(TCL_SERVICE_ALL);
    /*
     * MessageBoxW exists for all platforms.  Use it to allow unicode
     * error message to be displayed correctly where possible by the OS.
     */
    winCode = MessageBoxW(hWnd, (WCHAR *) Tcl_DStringValue(&messageString),
		(WCHAR *) Tcl_DStringValue(&titleString), flags);
    (void) Tcl_SetServiceMode(oldMode);

    /*
     * Ensure that hWnd is enabled, because it can happen that we
     * have updated the wrapper of the parent, which causes us to
     * leave this child disabled (Windows loses sync).
     */
    EnableWindow(hWnd, 1);

    Tcl_DStringFree(&messageString);
    Tcl_DStringFree(&titleString);

    Tcl_SetResult(interp, TkFindStateString(buttonMap, winCode), TCL_STATIC);
    return TCL_OK;
}

static void 
SetTkDialog(ClientData clientData)
{
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    char buf[32];

    sprintf(buf, "0x%p", (HWND) clientData);
    Tcl_SetVar(tsdPtr->debugInterp, "tk_dialog", buf, TCL_GLOBAL_ONLY);
}
@


1.5
log
@touched all sources to ease next import
@
text
@a0 1

d11 1
a11 1
 * RCS: @@(#) $Id: tkWinDialog.c,v 1.11.6.2 2000/09/26 16:09:56 spolk Exp $
d22 35
a72 1

d118 10
d147 1
d154 4
d160 1
a175 1
static int		TrySetDirectory(HWND hwnd, const TCHAR *dir);
d235 1
a235 1
    int i, oldMode, winCode;
d237 1
a237 1
    static inited = 0;
d240 2
a241 2
    static char *optionStrings[] = {
	"-initialcolor",    "-parent",	    "-title",	    NULL
d244 1
a244 1
	COLOR_INITIAL,	    COLOR_PARENT,   COLOR_TITLE
d247 1
d272 1
a272 1
    chooseColor.lpfnHook	= ColorDlgHookProc;
d352 1
a352 1
	char result[100];
d354 2
a355 2
	sprintf(result, "#%02x%02x%02x",
	GetRValue(chooseColor.rgbResult), 
d358 1
a358 1
        Tcl_AppendResult(interp, result, NULL);
d360 1
d362 2
a363 1
    return TCL_OK;
d407 2
a408 2
		Tcl_UtfToExternalDString(NULL, title, -1, &ds);
		SetWindowText(hDlg, (TCHAR *) Tcl_DStringValue(&ds));
a508 1
    Tcl_Encoding unicodeEncoding = Tcl_GetEncoding(NULL, "unicode");
d510 2
a511 2
    WCHAR file[MAX_PATH];
    int result, winCode, oldMode, i;
d517 1
d520 5
a524 1
    static char *optionStrings[] = {
d526 1
a526 1
	"-parent",	"-title",	NULL
d528 2
d532 1
a532 1
	FILE_PARENT,	FILE_TITLE
d549 6
d563 2
a564 2
	if (Tcl_GetIndexFromObj(interp, optionPtr, optionStrings, "option", 
		0, &index) != TCL_OK) {
d567 14
d607 1
a607 1
		if (Tcl_TranslateFileName(interp, string, 
d619 2
a620 2
		Tcl_UtfToExternal(NULL, unicodeEncoding, Tcl_DStringValue(&ds), 
			Tcl_DStringLength(&ds), 0, NULL, (char *) file, 
d624 7
d654 2
a655 1
    ofn.lStructSize		= sizeof(ofn);
d657 4
d663 1
a663 4
    ofn.lpstrFilter		= NULL;
    ofn.lpstrCustomFilter	= NULL;
    ofn.nMaxCustFilter		= 0;
    ofn.nFilterIndex		= 0;
d665 1
a665 5
    ofn.nMaxFile		= MAX_PATH;
    ofn.lpstrFileTitle		= NULL;
    ofn.nMaxFileTitle		= 0;
    ofn.lpstrInitialDir		= NULL;
    ofn.lpstrTitle		= NULL;
d668 1
a668 4
    ofn.nFileOffset		= 0;
    ofn.nFileExtension		= 0;
    ofn.lpstrDefExt		= NULL;
    ofn.lpfnHook		= OFNHookProcW;
a669 1
    ofn.lpTemplateName		= NULL;
d681 4
d690 2
a691 1
    Tcl_UtfToExternalDString(unicodeEncoding, Tcl_DStringValue(&utfFilterString),
d696 2
a697 1
	Tcl_UtfToExternalDString(unicodeEncoding, Tcl_DStringValue(&utfDirString),
d699 18
a716 1
        ofn.lpstrInitialDir = (WCHAR *) Tcl_DStringValue(&dirString);
d718 1
d756 100
a855 2
	char *p;
	Tcl_DString ds;
d857 14
a870 8
	Tcl_ExternalToUtfDString(unicodeEncoding, (char *) ofn.lpstrFile, -1, &ds);
	for (p = Tcl_DStringValue(&ds); *p != '\0'; p++) {
	    /*
	     * Change the pathname to the Tcl "normalized" pathname, where
	     * back slashes are used instead of forward slashes
	     */
	    if (*p == '\\') {
		*p = '/';
d872 5
a877 2
	Tcl_AppendResult(interp, Tcl_DStringValue(&ds), NULL);
	Tcl_DStringFree(&ds);
d879 1
a879 1

a889 1
    result = TCL_OK;
d928 3
d932 1
d941 3
d945 1
d950 3
d954 1
d986 2
a987 2
    TCHAR file[MAX_PATH], savePath[MAX_PATH];
    int result, winCode, oldMode, i;
d995 1
a995 1
    static char *optionStrings[] = {
d997 1
a997 1
	"-parent",	"-title",	NULL
d999 6
d1007 1
a1007 1
	FILE_PARENT,	FILE_TITLE
d1024 6
d1038 2
a1039 2
	if (Tcl_GetIndexFromObj(interp, optionPtr, optionStrings, "option", 
		0, &index) != TCL_OK) {
d1042 14
d1082 1
a1082 1
		if (Tcl_TranslateFileName(interp, string, 
d1099 7
d1131 4
d1137 1
d1143 1
a1143 1
    ofn.nMaxFile		= MAX_PATH;
d1153 1
a1153 1
    ofn.lpfnHook		= OFNHookProc;
d1167 4
d1182 18
a1199 1
        ofn.lpstrInitialDir = (LPTSTR) Tcl_DStringValue(&dirString);
d1201 2
d1209 1
a1209 1
     * Popup the dialog.  
d1241 102
a1342 2
	char *p;
	Tcl_DString ds;
d1344 9
a1352 8
	Tcl_ExternalToUtfDString(NULL, (char *) ofn.lpstrFile, -1, &ds);
	for (p = Tcl_DStringValue(&ds); *p != '\0'; p++) {
	    /*
	     * Change the pathname to the Tcl "normalized" pathname, where
	     * back slashes are used instead of forward slashes
	     */
	    if (*p == '\\') {
		*p = '/';
d1354 5
a1359 2
	Tcl_AppendResult(interp, Tcl_DStringValue(&ds), NULL);
	Tcl_DStringFree(&ds);
a1371 1
    result = TCL_OK;
d1410 3
d1414 1
d1424 3
d1428 1
d1435 3
d1439 1
d1510 1
a1510 1
	filterStr = ckalloc(strlen(string) * 3);
d1568 1
a1568 1
    Tcl_DStringAppend(dsPtr, filterStr, p - filterStr);
d1575 396
d2008 1
a2008 1
    static char *optionStrings[] = {
d2081 1
d2085 4
d2091 1
d2108 1
a2108 1
    ofn.lpfnHook		= ChooseDirectoryHookProc;
d2114 18
a2131 1
	ofn.lpstrInitialDir = (LPTSTR) Tcl_DStringValue(&dirString);
d2133 2
d2230 1
a2230 6

    /*
     * GWL_USERDATA keeps track of ofnPtr.
     */
    
    ofnPtr = (OPENFILENAME *) GetWindowLong(hwnd, GWL_USERDATA);
a2232 3
        ChooseDir *cdPtr;

	SetWindowLong(hwnd, GWL_USERDATA, lParam);
d2238 5
d2257 11
a2267 1
    if (ofnPtr == NULL) {
d2270 1
a2278 1
        ChooseDir *cdPtr;
a2282 1
	cdPtr = (ChooseDir *) ofnPtr->lCustData;
a2294 1
        ChooseDir *cdPtr;
a2298 1
	cdPtr = (ChooseDir *) ofnPtr->lCustData;
d2347 1
a2347 1
		    wsprintf(tmp, __TEXT("Cannot change directory to \"%.200s\"."), 
d2415 1
d2449 2
a2450 1
    static char *optionStrings[] = {
d2561 2
a2562 2
    Tcl_UtfToExternalDString(NULL, message, -1, &messageString);
    Tcl_UtfToExternalDString(NULL, title, -1, &titleString);
d2565 6
a2570 2
    winCode = MessageBox(hWnd, Tcl_DStringValue(&messageString),
		Tcl_DStringValue(&titleString), flags);
a2592 3
    HWND hwnd;

    hwnd = (HWND) clientData;
d2594 1
a2594 1
    sprintf(buf, "0x%08x", hwnd);
@


1.4
log
@touched all sources to ease next import
@
text
@@


1.3
log
@	* configure: Regenerated.
	* win/configure: Regenerated.
	* win/configure.in: Set XINCLUDES using absolute path
	rather than relative path.
	* win/tkWinDialog.c (ChooseDirectoryHookProc): Use
	__TEXT instead of _T (this might be bad practice).
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@d39 1
d1526 1
a1526 1
		    wsprintf(tmp, _T("Cannot change directory to \"%.200s\"."), 
@


1.1
log
@Initial revision
@
text
@d1 1
d12 1
a12 1
 * RCS: @@(#) $Id: tkWinDialog.c,v 1.12 1999/01/26 04:11:44 jingham Exp $
d15 1
a15 1
 
d23 11
a33 1
#if ((TK_MAJOR_VERSION == 4) && (TK_MINOR_VERSION <= 2))
d35 2
a36 1
 * The following function is implemented on tk4.3 and after only 
a37 2
#define Tk_GetHWND TkWinGetHWND
#endif
d39 28
a66 2
#define SAVE_FILE 0
#define OPEN_FILE 1
d68 11
a78 24
/*----------------------------------------------------------------------
 * MsgTypeInfo --
 *
 *	This structure stores the type of available message box in an
 *	easy-to-process format. Used by th Tk_MessageBox() function
 *----------------------------------------------------------------------
 */
typedef struct MsgTypeInfo {
    char * name;
    int type;
    int numButtons;
    char * btnNames[3];
} MsgTypeInfo;

#define NUM_TYPES 6

static MsgTypeInfo 
msgTypeInfo[NUM_TYPES] = {
    {"abortretryignore", MB_ABORTRETRYIGNORE, 3, {"abort", "retry", "ignore"}},
    {"ok", 		 MB_OK, 	      1, {"ok"                      }},
    {"okcancel",	 MB_OKCANCEL,	      2, {"ok",    "cancel"         }},
    {"retrycancel",	 MB_RETRYCANCEL,      2, {"retry", "cancel"         }},
    {"yesno",		 MB_YESNO,	      2, {"yes",   "no"             }},
    {"yesnocancel",	 MB_YESNOCANCEL,      3, {"yes",   "no",    "cancel"}}
d81 2
d84 2
a85 2
 * The following structure is used in the GetOpenFileName() and
 * GetSaveFileName() calls.
d87 17
a103 4
typedef struct _OpenFileData {
    Tcl_Interp * interp;
    TCHAR szFile[(256*MAX_PATH)+1];
} OpenFileData;
d106 1
a106 1
 * The following structure is used in the ChooseColor() call.
d108 19
a126 18
typedef struct _ChooseColorData {
    Tcl_Interp * interp;
    char * title;			/* Title of the color dialog */
} ChooseColorData;


static int 		GetFileName _ANSI_ARGS_((ClientData clientData,
    			    Tcl_Interp *interp, int argc, char **argv,
    			    int isOpen));
static UINT CALLBACK	ColorDlgHookProc _ANSI_ARGS_((HWND hDlg, UINT uMsg,
			    WPARAM wParam, LPARAM lParam));
static int 		MakeFilter _ANSI_ARGS_((Tcl_Interp *interp,
    			    OPENFILENAME *ofnPtr, char * string));
static int		ParseFileDlgArgs _ANSI_ARGS_((Tcl_Interp * interp,
    			    OPENFILENAME *ofnPtr, int argc, char ** argv,
			    int isOpen));
static int 		ProcessCDError _ANSI_ARGS_((Tcl_Interp * interp,
			    DWORD dwErrorCode, HWND hWnd));
d129 1
a129 1
 *----------------------------------------------------------------------
d131 1
a131 1
 * EvalArgv --
d133 4
a136 4
 *	Invokes the Tcl procedure with the arguments. argv[0] is set by
 *	the caller of this function. It may be different than cmdName.
 *	The TCL command will see argv[0], not cmdName, as its name if it
 *	invokes [lindex [info level 0] 0]
d139 1
a139 2
 *	TCL_ERROR if the command does not exist and cannot be autoloaded.
 *	Otherwise, return the result of the evaluation of the command.
d142 1
a142 1
 *	The command may be autoloaded.
d144 1
a144 1
 *----------------------------------------------------------------------
d147 3
a149 6
static int 
EvalArgv(interp, cmdName, argc, argv)
    Tcl_Interp *interp;		/* Current interpreter. */
    char * cmdName;		/* Name of the TCL command to call */
    int argc;			/* Number of arguments. */
    char **argv;		/* Argument strings. */
d151 2
a152 22
    Tcl_CmdInfo cmdInfo;

    if (!Tcl_GetCommandInfo(interp, cmdName, &cmdInfo)) {
	char * cmdArgv[2];

	/*
	 * This comand is not in the interpreter yet -- looks like we
	 * have to auto-load it
	 */
	if (!Tcl_GetCommandInfo(interp, "auto_load", &cmdInfo)) {
	    Tcl_ResetResult(interp);
	    Tcl_AppendResult(interp, "cannot execute command \"auto_load\"",
		NULL);
	    return TCL_ERROR;
	}

	cmdArgv[0] = "auto_load";
	cmdArgv[1] = cmdName;

	if ((*cmdInfo.proc)(cmdInfo.clientData, interp, 2, cmdArgv)!= TCL_OK){ 
	    return TCL_ERROR;
	}
d154 1
a154 9
	if (!Tcl_GetCommandInfo(interp, cmdName, &cmdInfo)) {
	    Tcl_ResetResult(interp);
	    Tcl_AppendResult(interp, "cannot auto-load command \"",
		cmdName, "\"",NULL);
	    return TCL_ERROR;
	}
    }

    return (*cmdInfo.proc)(cmdInfo.clientData, interp, argc, argv);
d158 1
a158 1
 *----------------------------------------------------------------------
d160 1
a160 1
 * Tk_ChooseColorCmd --
d174 1
a174 1
 *----------------------------------------------------------------------
d178 1
a178 1
Tk_ChooseColorCmd(clientData, interp, argc, argv)
d181 2
a182 2
    int argc;			/* Number of arguments. */
    char **argv;		/* Argument strings. */
d184 3
a186 3
    Tk_Window parent = Tk_MainWindow(interp);
    ChooseColorData custData;
    int oldMode;
a187 4
    char * colorStr = NULL;
    int i;
    int winCode, tclCode;
    XColor * colorPtr = NULL;
d189 1
a189 1
    static long dwCustColors[16];
d191 6
d198 1
a198 3
    custData.title     = NULL;

    if (!inited) {
d201 1
a201 1
	 * modify. We store these colors in a fixed array so that the next
d205 2
a206 2
	for (i=0; i<16; i++) {
	    dwCustColors[i] = (RGB(255-i*10, i, i*10)) ;
d208 1
a208 1
	oldColor = RGB(0xa0,0xa0,0xa0);
d212 1
a212 3
    /*
     * 1. Parse the arguments
     */
d214 15
a228 16
    chooseColor.lStructSize  = sizeof(CHOOSECOLOR) ;
    chooseColor.hwndOwner    = 0;			/* filled in below */
    chooseColor.hInstance    = 0;
    chooseColor.rgbResult    = oldColor;
    chooseColor.lpCustColors = (LPDWORD) dwCustColors ;
    chooseColor.Flags        = CC_RGBINIT | CC_FULLOPEN | CC_ENABLEHOOK;
    chooseColor.lCustData    = (LPARAM)&custData;
    chooseColor.lpfnHook     = ColorDlgHookProc;
    chooseColor.lpTemplateName = NULL;

    for (i=1; i<argc; i+=2) {
        int v = i+1;
	int len = strlen(argv[i]);

	if (strncmp(argv[i], "-initialcolor", len)==0) {
	    if (v==argc) {goto arg_missing;}
d230 2
a231 4
	    colorStr = argv[v];
	}
	else if (strncmp(argv[i], "-parent", len)==0) {
	    if (v==argc) {goto arg_missing;}
d233 3
a235 4
	    parent=Tk_NameToWindow(interp, argv[v], Tk_MainWindow(interp));
	    if (parent == NULL) {
		return TCL_ERROR;
	    }
d237 5
a241 10
	else if (strncmp(argv[i], "-title", len)==0) {
	    if (v==argc) {goto arg_missing;}

	    custData.title = argv[v];
	}
	else {
    	    Tcl_AppendResult(interp, "unknown option \"", 
		argv[i], "\", must be -initialcolor, -parent or -title",
		NULL);
		return TCL_ERROR;
a242 1
    }
d244 4
a247 4
    if (Tk_WindowId(parent) == None) {
	Tk_MakeWindowExist(parent);
    }
    chooseColor.hwndOwner = Tk_GetHWND(Tk_WindowId(parent));
d249 19
a267 4
    if (colorStr != NULL) {
	colorPtr = Tk_GetColor(interp, Tk_MainWindow(interp), colorStr);
	if (!colorPtr) {
	    return TCL_ERROR;
d269 1
a269 7
	chooseColor.rgbResult = RGB((colorPtr->red/0x100), 
	    (colorPtr->green/0x100), (colorPtr->blue/0x100));
    }	

    /*
     * 2. Popup the dialog
     */
d271 5
d281 7
d297 1
d305 3
a307 3
	    GetRValue(chooseColor.rgbResult), 
	    GetGValue(chooseColor.rgbResult), 
	    GetBValue(chooseColor.rgbResult));
a308 2
	tclCode = TCL_OK;

a309 6
    } else {
	/*
	 * User probably pressed Cancel, or an error occurred
	 */
	tclCode = ProcessCDError(interp, CommDlgExtendedError(), 
	     chooseColor.hwndOwner);
d311 1
a311 11

    if (colorPtr) {
	Tk_FreeColor(colorPtr);
    }

    return tclCode;

  arg_missing:
    Tcl_AppendResult(interp, "value for \"", argv[argc-1], "\" missing",
	NULL);
    return TCL_ERROR;
d315 1
a315 1
 *----------------------------------------------------------------------
d319 2
a320 2
 *	Gets called during the execution of the color dialog. It processes
 *	the "interesting" messages that Windows send to the dialog.
d323 2
a324 1
 *	TRUE if the message has been processed, FALSE otherwise.
d327 1
a327 1
 *	Changes the title of the dialog window when it is popped up.
d332 6
a337 6
static UINT
CALLBACK ColorDlgHookProc(hDlg, uMsg, wParam, lParam)
    HWND hDlg;			/* Handle to the color dialog */
    UINT uMsg;			/* Type of message */
    WPARAM wParam;		/* word param, interpretation depends on uMsg*/
    LPARAM lParam;		/* long param, interpretation depends on uMsg*/
d339 2
a340 2
    CHOOSECOLOR * ccPtr;
    ChooseColorData * pCustData;
d343 21
a363 9
      case WM_INITDIALOG:
	/* Save the pointer to CHOOSECOLOR so that we can use it later */
	SetWindowLong(hDlg, DWL_USER, lParam);

	/* Set the title string of the dialog */
	ccPtr = (CHOOSECOLOR*)lParam;
	pCustData = (ChooseColorData*)(ccPtr->lCustData);
	if (pCustData->title && *(pCustData->title)) {
 	    SetWindowText(hDlg, (LPCSTR)pCustData->title);
a364 2

	return TRUE;
a365 1

a382 3
 *	This window is not destroyed and will be reused the next time
 *	the application invokes the "tk_getOpenFile" or
 *	"tk_getSaveFile" command.
d388 1
a388 1
Tk_GetOpenFileCmd(clientData, interp, argc, argv)
d391 2
a392 2
    int argc;			/* Number of arguments. */
    char **argv;		/* Argument strings. */
d394 5
a398 1
    return GetFileName(clientData, interp, argc, argv, OPEN_FILE);
d419 1
a419 1
Tk_GetSaveFileCmd(clientData, interp, argc, argv)
d422 2
a423 2
    int argc;			/* Number of arguments. */
    char **argv;		/* Argument strings. */
d425 5
a429 1
    return GetFileName(clientData, interp, argc, argv, SAVE_FILE);
d435 1
a435 1
 * GetFileName --
d449 1
a449 1
GetFileName(clientData, interp, argc, argv, isOpen)
d452 4
a455 4
    int argc;			/* Number of arguments. */
    char **argv;		/* Argument strings. */
    int isOpen;			/* true if we should call GetOpenFileName(),
				 * false if we should call GetSaveFileName() */
d457 22
a478 6
    OPENFILENAME openFileName, *ofnPtr;
    int tclCode, winCode, oldMode;
    OpenFileData *custData;
    char buffer[MAX_PATH+1];
    
    ofnPtr = &openFileName;
d481 1
a481 1
     * 1. Parse the arguments.
d483 137
a619 2
    if (ParseFileDlgArgs(interp, ofnPtr, argc, argv, isOpen) != TCL_OK) {
	return TCL_ERROR;
a620 1
    custData = (OpenFileData*) ofnPtr->lCustData;
d623 1
a623 1
     * 2. Call the common dialog function.
d625 1
d627 2
a628 3
    GetCurrentDirectory(MAX_PATH+1, buffer);
    if (isOpen) {
	winCode = GetOpenFileName(ofnPtr);
d630 1
a630 1
	winCode = GetSaveFileName(ofnPtr);
d632 8
a639 2
    SetCurrentDirectory(buffer);
    (void) Tcl_SetServiceMode(oldMode);
a647 4
    if (ofnPtr->lpstrInitialDir != NULL) {
	ckfree((char*) ofnPtr->lpstrInitialDir);
    }

d649 1
a649 1
     * 3. Process the results.
a650 23
    if (winCode) {
	if (ofnPtr->Flags & OFN_ALLOWMULTISELECT) {
	    /* The result in custData->szFile contains many items,
               separated with null characters.  It is terminated with
               two nulls in a row.  The first element is the directory
               path. */
	    char *dir;
	    int dirlen;
	    char *p;
	    Tcl_DString fullname;
	    Tcl_ResetResult(interp);

	    /* Get directory */
	    dir = custData->szFile;
	    for (p = custData->szFile; p && *p; p++) {
		/*
		 * Change the pathname to the Tcl "normalized" pathname, where
		 * back slashes are used instead of forward slashes
		 */
		if (*p == '\\') {
		    *p = '/';
		}
	    }
d652 12
a663 19
	    if (p[1] == '\0') {
		/* Only one file was returned.  */
		Tcl_AppendElement(interp, dir);
	    } else {
		while (*(++p)) {
		    char *filname = p;
		    for (; p && *p; p++) {
			if (*p == '\\') { *p = '/'; }
		    }
		    Tcl_DStringInit(&fullname);
		    /* Add "dir/fname" to list */
		    Tcl_DStringAppend(&fullname, dir, -1);
		    Tcl_DStringAppend(&fullname, "/", -1);
		    Tcl_DStringAppend(&fullname, filname, -1);
		    /* Add to result string */
		    Tcl_AppendElement(interp, Tcl_DStringValue(&fullname));
		    /* Reset dynamic string */
		    Tcl_DStringFree(&fullname);
		}
a664 18
	    tclCode = TCL_OK;
	} else {
	    /* Not a multiple-selection box; just treat it as a single
               element. */
	    char *p;
	    Tcl_ResetResult(interp);
	    
	    for (p = custData->szFile; p && *p; p++) {
		/*
		 * Change the pathname to the Tcl "normalized" pathname, where
		 * back slashes are used instead of forward slashes
		 */
		if (*p == '\\') {
		    *p = '/';
		}
	    }
	    Tcl_AppendResult(interp, custData->szFile, NULL);
	    tclCode = TCL_OK;
d666 2
a667 3
    } else {
	tclCode = ProcessCDError(interp, CommDlgExtendedError(),
				 ofnPtr->hwndOwner);
d670 2
a671 2
    if (custData) {
	ckfree((char*)custData);
d673 2
a674 2
    if (ofnPtr->lpstrFilter) {
	ckfree((char*)ofnPtr->lpstrFilter);
d676 51
d728 9
a736 1
    return tclCode;
d742 1
a742 1
 * ParseFileDlgArgs --
d744 1
a744 1
 *	Parses the arguments passed to tk_getOpenFile and tk_getSaveFile.
d747 1
a747 1
 *	A standard TCL return value.
d750 1
a750 2
 *	The OPENFILENAME structure is initialized and modified according
 *	to the arguments.
d756 7
a762 7
ParseFileDlgArgs(interp, ofnPtr, argc, argv, isOpen)
    Tcl_Interp * interp;	/* Current interpreter. */
    OPENFILENAME *ofnPtr;	/* Info about the file dialog */
    int argc;			/* Number of arguments. */
    char **argv;		/* Argument strings. */
    int isOpen;			/* true if we should call GetOpenFileName(),
				 * false if we should call GetSaveFileName() */
d764 101
a864 31
    OpenFileData * custData;
    int i;
    Tk_Window parent = Tk_MainWindow(interp);
    int doneFilter = 0;
    int windowsMajorVersion;
    Tcl_DString buffer;

    custData = (OpenFileData*)ckalloc(sizeof(OpenFileData));
    custData->interp = interp;
    strcpy(custData->szFile, "");

    /* Fill in the OPENFILENAME structure to */
    ofnPtr->lStructSize       = sizeof(OPENFILENAME);
    ofnPtr->hwndOwner         = 0;			/* filled in below */
    ofnPtr->lpstrFilter       = NULL;
    ofnPtr->lpstrCustomFilter = NULL;
    ofnPtr->nMaxCustFilter    = 0;
    ofnPtr->nFilterIndex      = 0;
    ofnPtr->lpstrFile         = custData->szFile;
    ofnPtr->nMaxFile          = sizeof(custData->szFile);
    ofnPtr->lpstrFileTitle    = NULL;
    ofnPtr->nMaxFileTitle     = 0;
    ofnPtr->lpstrInitialDir   = NULL;
    ofnPtr->lpstrTitle        = NULL;
    ofnPtr->nFileOffset       = 0;
    ofnPtr->nFileExtension    = 0;
    ofnPtr->lpstrDefExt       = NULL;
    ofnPtr->lpfnHook 	      = NULL; 
    ofnPtr->lCustData         = (DWORD)custData;
    ofnPtr->lpTemplateName    = NULL;
    ofnPtr->Flags             = OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
d866 4
a869 8
    windowsMajorVersion = LOBYTE(LOWORD(GetVersion()));
    if (windowsMajorVersion >= 4) {
	/*
	 * Use the "explorer" style file selection box on platforms that
	 * support it (Win95 and NT4.0, both have a major version number
	 * of 4)
	 */
	ofnPtr->Flags |= OFN_EXPLORER;
d872 25
d898 2
a899 2
    if (isOpen) {
	ofnPtr->Flags |= OFN_FILEMUSTEXIST;
d901 1
a901 1
	ofnPtr->Flags |= OFN_OVERWRITEPROMPT;
d904 3
a906 3
    for (i=1; i<argc; i+=2) {
        int v = i+1;
	int len = strlen(argv[i]);
d908 7
a914 2
	if (strncmp(argv[i], "-defaultextension", len)==0) {
	    if (v==argc) {goto arg_missing;}
d916 23
a938 8
	    ofnPtr->lpstrDefExt = argv[v];
	    if (ofnPtr->lpstrDefExt[0] == '.') {
		/* Windows will insert the dot for us */
		ofnPtr->lpstrDefExt ++;
	    }
	}
	else if (strncmp(argv[i], "-filetypes", len)==0) {
	    if (v==argc) {goto arg_missing;}
d940 6
a945 7
	    if (MakeFilter(interp, ofnPtr, argv[v]) != TCL_OK) {
		return TCL_ERROR;
	    }
	    doneFilter = 1;
	}
	else if (strncmp(argv[i], "-initialdir", len)==0) {
	    if (v==argc) {goto arg_missing;}
d947 4
a950 9
	    if (Tcl_TranslateFileName(interp, argv[v], &buffer) == NULL) {
		return TCL_ERROR;
	    }
	    ofnPtr->lpstrInitialDir = ckalloc(Tcl_DStringLength(&buffer)+1);
	    strcpy((char*)ofnPtr->lpstrInitialDir, Tcl_DStringValue(&buffer));
	    Tcl_DStringFree(&buffer);
	}
	else if (strncmp(argv[i], "-initialfile", len)==0) {
	    if (v==argc) {goto arg_missing;}
d952 1
a952 8
	    if (Tcl_TranslateFileName(interp, argv[v], &buffer) == NULL) {
		return TCL_ERROR;
	    }
	    strcpy(ofnPtr->lpstrFile, Tcl_DStringValue(&buffer));
	    Tcl_DStringFree(&buffer);
	}
	else if (strncmp(argv[i], "-parent", len)==0) {
	    if (v==argc) {goto arg_missing;}
d954 3
a956 7
	    parent=Tk_NameToWindow(interp, argv[v], Tk_MainWindow(interp));
	    if (parent == NULL) {
		return TCL_ERROR;
	    }
	}
	else if (strncmp(argv[i], "-title", len)==0) {
	    if (v==argc) {goto arg_missing;}
d958 3
a960 5
	    ofnPtr->lpstrTitle = argv[v];
	}
	else if (strncmp(argv[i], "-multiple", len)==0) {
	    int tmp;
	    if (v==argc) {goto arg_missing;}
d962 8
a969 2
	    if (Tcl_GetBoolean(interp, argv[i+1], &tmp) != TCL_OK) {
		return TCL_ERROR;
a970 10
	    if (tmp) {
		ofnPtr->Flags |= OFN_ALLOWMULTISELECT;
	    }
	}
	else {
    	    Tcl_AppendResult(interp, "unknown option \"", 
		argv[i], "\", must be -defaultextension, ",
		"-filetypes, -initialdir, -initialfile, -parent or -title",
		NULL);
	    return TCL_ERROR;
d972 2
d976 9
a984 4
    if (!doneFilter) {
	if (MakeFilter(interp, ofnPtr, "") != TCL_OK) {
	    return TCL_ERROR;
	}
d986 1
d988 24
a1011 4
    if (Tk_WindowId(parent) == None) {
	Tk_MakeWindowExist(parent);
    }
    ofnPtr->hwndOwner = Tk_GetHWND(Tk_WindowId(parent));
d1013 21
a1033 1
    return TCL_OK;
d1035 11
a1045 4
  arg_missing:
    Tcl_AppendResult(interp, "value for \"", argv[argc-1], "\" missing",
	NULL);
    return TCL_ERROR;
d1064 2
a1065 1
static int MakeFilter(interp, ofnPtr, string) 
a1066 1
    OPENFILENAME *ofnPtr;	/* Info about the file dialog */
d1068 1
d1083 1
a1083 1
	 * Use "All Files (*.*) as the default filter is none is specified
d1171 2
a1172 4
    if (ofnPtr->lpstrFilter != NULL) {
	ckfree((char*)ofnPtr->lpstrFilter);
    }
    ofnPtr->lpstrFilter = filterStr;
d1181 1
a1181 1
 * Tk_MessageBoxCmd --
d1183 3
a1185 3
 *	This procedure implements the MessageBox window for the
 *	Windows platform. See the user documentation for details on what
 *	it does.
d1191 2
a1192 2
 *	None. The MessageBox window will be destroy before this procedure
 *	returns.
d1198 1
a1198 1
Tk_MessageBoxCmd(clientData, interp, argc, argv)
d1201 2
a1202 2
    int argc;			/* Number of arguments. */
    char **argv;		/* Argument strings. */
d1204 5
a1208 2
    int flags;
    Tk_Window parent = NULL;
d1210 70
a1279 39
    char *message = "";
    char *title = "";
    int icon = MB_ICONINFORMATION;
    int type = MB_OK;
    int modal = MB_SYSTEMMODAL;
    int i, j;
    char *result;
    int code, oldMode;
    char *defaultBtn = NULL;
    int defaultBtnIdx = -1;

    for (i=1; i<argc; i+=2) {
	int v = i+1;
	int len = strlen(argv[i]);

	if (strncmp(argv[i], "-default", len)==0) {
	    if (v==argc) {goto arg_missing;}

	    defaultBtn = argv[v];
	}
	else if (strncmp(argv[i], "-icon", len)==0) {
	    if (v==argc) {goto arg_missing;}

	    if (strcmp(argv[v], "error") == 0) {
		icon = MB_ICONERROR;
	    }
	    else if (strcmp(argv[v], "info") == 0) {
		icon = MB_ICONINFORMATION;
	    }
	    else if (strcmp(argv[v], "question") == 0) {
		icon = MB_ICONQUESTION;
	    }
	    else if (strcmp(argv[v], "warning") == 0) {
		icon = MB_ICONWARNING;
	    }
	    else {
	        Tcl_AppendResult(interp, "invalid icon \"", argv[v],
		    "\", must be error, info, question or warning", NULL);
		return TCL_ERROR;
d1282 53
a1334 2
	else if (strncmp(argv[i], "-message", len)==0) {
	    if (v==argc) {goto arg_missing;}
d1336 22
a1357 1
	    message = argv[v];
d1359 14
a1372 2
	else if (strncmp(argv[i], "-parent", len)==0) {
	    if (v==argc) {goto arg_missing;}
d1374 111
a1484 3
	    parent=Tk_NameToWindow(interp, argv[v], Tk_MainWindow(interp));
	    if (parent == NULL) {
		return TCL_ERROR;
d1486 1
a1487 2
	else if (strncmp(argv[i], "-title", len)==0) {
	    if (v==argc) {goto arg_missing;}
d1489 25
a1513 4
	    title = argv[v];
	}
	else if (strncmp(argv[i], "-type", len)==0) {
	    int found = 0;
d1515 4
a1518 1
	    if (v==argc) {goto arg_missing;}
d1520 20
a1539 5
	    for (j=0; j<NUM_TYPES; j++) {
		if (strcmp(argv[v], msgTypeInfo[j].name) == 0) {
		    type = msgTypeInfo[j].type;
		    found = 1;
		    break;
d1542 8
a1549 5
	    if (!found) {
		Tcl_AppendResult(interp, "invalid message box type \"", 
		    argv[v], "\", must be abortretryignore, ok, ",
		    "okcancel, retrycancel, yesno or yesnocancel", NULL);
		return TCL_ERROR;
d1551 38
d1590 58
a1647 2
	else if (strncmp (argv[i], "-modal", len) == 0) {
	    if (v==argc) {goto arg_missing;}
d1649 21
a1669 2
	    if (strcmp(argv[v], "system") == 0) {
		modal = MB_SYSTEMMODAL;
d1671 6
a1676 2
	    else if (strcmp(argv[v], "task") == 0) {
		modal = MB_TASKMODAL;
d1678 10
a1687 2
	    else if (strcmp(argv[v], "owner") == 0) {
		modal = MB_APPLMODAL;
d1689 9
a1697 3
	    else {
		Tcl_AppendResult(interp, "invalid modality \"", argv[v],
		    "\", must be system, task or owner", NULL);
d1700 1
a1700 8
	}
	else {
    	    Tcl_AppendResult(interp, "unknown option \"", 
		argv[i], "\", must be -default, -icon, ",
		"-message, -parent, -title or -type", NULL);
		return TCL_ERROR;
	}
    }
a1701 11
    /* Make sure we have a valid hWnd to act as the parent of this message box
     */
    if (parent == NULL && modal == MB_TASKMODAL) {
	hWnd = NULL;
    }
    else {
	if (parent == NULL) {
	    parent = Tk_MainWindow(interp);
	}
	if (Tk_WindowId(parent) == None) {
	    Tk_MakeWindowExist(parent);
a1702 1
	hWnd = Tk_GetHWND(Tk_WindowId(parent));
d1705 15
a1719 6
    if (defaultBtn != NULL) {
	for (i=0; i<NUM_TYPES; i++) {
	    if (type == msgTypeInfo[i].type) {
		for (j=0; j<msgTypeInfo[i].numButtons; j++) {
		    if (strcmp(defaultBtn, msgTypeInfo[i].btnNames[j])==0) {
		        defaultBtnIdx = j;
d1725 2
a1726 1
			defaultBtn, "\"", NULL);
d1732 7
a1739 11
	switch (defaultBtnIdx) {
	  case 0: flags = MB_DEFBUTTON1; break;
	  case 1: flags = MB_DEFBUTTON2; break;
	  case 2: flags = MB_DEFBUTTON3; break;
	  case 3: flags = MB_DEFBUTTON4; break;
	}
    } else {
	flags = 0;
    }
    
    flags |= icon | type;
d1741 2
a1742 1
    code = MessageBox(hWnd, message, title, flags|modal);
a1744 11
    switch (code) {
      case IDABORT:	result = "abort";  break;
      case IDCANCEL:	result = "cancel"; break;
      case IDIGNORE:	result = "ignore"; break;
      case IDNO:	result = "no";     break;
      case IDOK:	result = "ok";     break;
      case IDRETRY:	result = "retry";  break;
      case IDYES:	result = "yes";    break;
      default:		result = "";
    }

d1746 3
a1748 4
     * When we come to here interp->result may have been changed by some
     * background scripts. Call Tcl_SetResult() to make sure that any stuff
     * lingering in interp->result will not appear in the result of
     * this command.
d1750 4
d1755 1
a1755 1
    Tcl_SetResult(interp, result, TCL_STATIC);
d1757 1
d1759 2
a1760 30
  arg_missing:
    Tcl_AppendResult(interp, "value for \"", argv[argc-1], "\" missing",
	NULL);
    return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 *
 * ProcessCDError --
 *
 *	This procedure gets called if a Windows-specific error message
 *	has occurred during the execution of a common dialog or the
 *	user has pressed the CANCEL button.
 *
 * Results:
 *	If an error has indeed happened, returns a standard TCL result
 *	that reports the error code in string format. If the user has
 *	pressed the CANCEL button (dwErrorCode == 0), resets
 *	interp->result to the empty string.
 *
 * Side effects:
 *	interp->result is changed.
 *
 *----------------------------------------------------------------------
 */
static int ProcessCDError(interp, dwErrorCode, hWnd)
    Tcl_Interp * interp;		/* Current interpreter. */
    DWORD dwErrorCode;			/* The Windows-specific error code */
    HWND hWnd;				/* window in which the error happened*/
d1762 4
a1765 1
    char *string;
d1767 1
a1767 37
    Tcl_ResetResult(interp);

    switch(dwErrorCode) {
      case 0:	  /* User has hit CANCEL */
	return TCL_OK;

      case CDERR_DIALOGFAILURE:   string="CDERR_DIALOGFAILURE";  	break;
      case CDERR_STRUCTSIZE:      string="CDERR_STRUCTSIZE";   		break;
      case CDERR_INITIALIZATION:  string="CDERR_INITIALIZATION";   	break;
      case CDERR_NOTEMPLATE:      string="CDERR_NOTEMPLATE";   		break;
      case CDERR_NOHINSTANCE:     string="CDERR_NOHINSTANCE";   	break;
      case CDERR_LOADSTRFAILURE:  string="CDERR_LOADSTRFAILURE";   	break;
      case CDERR_FINDRESFAILURE:  string="CDERR_FINDRESFAILURE";   	break;
      case CDERR_LOADRESFAILURE:  string="CDERR_LOADRESFAILURE";   	break;
      case CDERR_LOCKRESFAILURE:  string="CDERR_LOCKRESFAILURE";   	break;
      case CDERR_MEMALLOCFAILURE: string="CDERR_MEMALLOCFAILURE";   	break;
      case CDERR_MEMLOCKFAILURE:  string="CDERR_MEMLOCKFAILURE";   	break;
      case CDERR_NOHOOK:          string="CDERR_NOHOOK";   	 	break;
      case PDERR_SETUPFAILURE:    string="PDERR_SETUPFAILURE";   	break;
      case PDERR_PARSEFAILURE:    string="PDERR_PARSEFAILURE";   	break;
      case PDERR_RETDEFFAILURE:   string="PDERR_RETDEFFAILURE";   	break;
      case PDERR_LOADDRVFAILURE:  string="PDERR_LOADDRVFAILURE";   	break;
      case PDERR_GETDEVMODEFAIL:  string="PDERR_GETDEVMODEFAIL";   	break;
      case PDERR_INITFAILURE:     string="PDERR_INITFAILURE";   	break;
      case PDERR_NODEVICES:       string="PDERR_NODEVICES";   		break;
      case PDERR_NODEFAULTPRN:    string="PDERR_NODEFAULTPRN";   	break;
      case PDERR_DNDMMISMATCH:    string="PDERR_DNDMMISMATCH";   	break;
      case PDERR_CREATEICFAILURE: string="PDERR_CREATEICFAILURE";   	break;
      case PDERR_PRINTERNOTFOUND: string="PDERR_PRINTERNOTFOUND";   	break;
      case CFERR_NOFONTS:         string="CFERR_NOFONTS";   	 	break;
      case FNERR_SUBCLASSFAILURE: string="FNERR_SUBCLASSFAILURE";   	break;
      case FNERR_INVALIDFILENAME: string="FNERR_INVALIDFILENAME";   	break;
      case FNERR_BUFFERTOOSMALL:  string="FNERR_BUFFERTOOSMALL";   	break;
	
      default:
	string="unknown error";
    }
d1769 2
a1770 2
    Tcl_AppendResult(interp, "Win32 internal error: ", string, NULL); 
    return TCL_ERROR;
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@a0 1

d11 1
a11 1
 * RCS: @@(#) $Id: tkWinDialog.c,v 1.11.6.2 2000/09/26 16:09:56 spolk Exp $
d14 1
a14 1

d22 1
a22 11
typedef struct ThreadSpecificData { 
    int debugFlag;            /* Flags whether we should output debugging 
			       * information while displaying a builtin 
			       * dialog. */
    Tcl_Interp *debugInterp;  /* Interpreter to used for debugging. */
    UINT WM_LBSELCHANGED;     /* Holds a registered windows event used for
			       * communicating between the Directory
			       * Chooser dialog and its hook proc. */
} ThreadSpecificData;
static Tcl_ThreadDataKey dataKey;

d24 1
a24 2
 * The following structures are used by Tk_MessageBoxCmd() to parse 
 * arguments and return results.
d26 2
d29 2
a30 17
static const TkStateMap iconMap[] = {
    {MB_ICONERROR,		"error"},
    {MB_ICONINFORMATION,	"info"},
    {MB_ICONQUESTION,		"question"},
    {MB_ICONWARNING,		"warning"},
    {-1,			NULL}
};
	  
static const TkStateMap typeMap[] = {
    {MB_ABORTRETRYIGNORE,	"abortretryignore"},
    {MB_OK, 			"ok"},
    {MB_OKCANCEL,		"okcancel"},
    {MB_RETRYCANCEL,		"retrycancel"},
    {MB_YESNO,			"yesno"},
    {MB_YESNOCANCEL,		"yesnocancel"},
    {-1,			NULL}
};
d32 24
a55 9
static const TkStateMap buttonMap[] = {
    {IDABORT,			"abort"},
    {IDRETRY,			"retry"},
    {IDIGNORE,			"ignore"},
    {IDOK,			"ok"},
    {IDCANCEL,			"cancel"},
    {IDNO,			"no"},
    {IDYES,			"yes"},
    {-1,			NULL}
a57 15
static const int buttonFlagMap[] = {
    MB_DEFBUTTON1, MB_DEFBUTTON2, MB_DEFBUTTON3, MB_DEFBUTTON4
};

static const struct {int type; int btnIds[3];} allowedTypes[] = {
    {MB_ABORTRETRYIGNORE,	{IDABORT, IDRETRY,  IDIGNORE}},
    {MB_OK, 			{IDOK,    -1,       -1      }},
    {MB_OKCANCEL,		{IDOK,    IDCANCEL, -1      }},
    {MB_RETRYCANCEL,		{IDRETRY, IDCANCEL, -1      }},
    {MB_YESNO,			{IDYES,   IDNO,     -1      }},
    {MB_YESNOCANCEL,		{IDYES,   IDNO,     IDCANCEL}}
};

#define NUM_TYPES (sizeof(allowedTypes) / sizeof(allowedTypes[0]))

d59 2
a60 2
 * The following structure is used to pass information between the directory
 * chooser procedure, Tk_ChooseDirectoryObjCmd(), and its dialog hook proc.
d62 4
a65 17

typedef struct ChooseDir {
    Tcl_Interp *interp;		/* Interp, used only if debug is turned on, 
				 * for setting the "tk_dialog" variable. */
    int lastCtrl;		/* Used by hook proc to keep track of last
				 * control that had input focus, so when OK
				 * is pressed we know whether to browse a
				 * new directory or return. */
    int lastIdx;		/* Last item that was selected in directory 
				 * browser listbox. */
    TCHAR path[MAX_PATH];	/* On return from choose directory dialog, 
				 * holds the selected path.  Cannot return 
				 * selected path in ofnPtr->lpstrFile because
				 * the default dialog proc stores a '\0' in 
				 * it, since, of course, no _file_ was 
				 * selected. */
} ChooseDir;
d68 1
a68 1
 * Definitions of procedures used only in this file.
d70 18
a87 19

static UINT APIENTRY	ChooseDirectoryHookProc(HWND hdlg, UINT uMsg, 
			    WPARAM wParam, LPARAM lParam);
static UINT CALLBACK	ColorDlgHookProc(HWND hDlg, UINT uMsg, WPARAM wParam,
			    LPARAM lParam);
static int 		GetFileNameA(ClientData clientData, 
			    Tcl_Interp *interp, int objc, 
			    Tcl_Obj *CONST objv[], int isOpen);
static int 		GetFileNameW(ClientData clientData, 
			    Tcl_Interp *interp, int objc, 
			    Tcl_Obj *CONST objv[], int isOpen);
static int 		MakeFilter(Tcl_Interp *interp, char *string, 
			    Tcl_DString *dsPtr);
static UINT APIENTRY	OFNHookProc(HWND hdlg, UINT uMsg, WPARAM wParam, 
			    LPARAM lParam);
static UINT APIENTRY	OFNHookProcW(HWND hdlg, UINT uMsg, WPARAM wParam, 
			    LPARAM lParam);
static void		SetTkDialog(ClientData clientData);
static int		TrySetDirectory(HWND hwnd, const TCHAR *dir);
d90 1
a90 1
 *-------------------------------------------------------------------------
d92 1
a92 1
 * TkWinDialogDebug --
d94 4
a97 4
 *	Function to turn on/off debugging support for common dialogs under
 *	windows.  The variable "tk_debug" is set to the identifier of the
 *	dialog window when the modal dialog window pops up and it is safe to 
 *	send messages to the dialog.
d100 2
a101 1
 *	None.
d104 1
a104 1
 *	This variable only makes sense if just one dialog is up at a time.
d106 1
a106 1
 *-------------------------------------------------------------------------
d109 6
a114 3
void	    	
TkWinDialogDebug(
    int debug)
d116 22
a137 2
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
d139 9
a147 1
    tsdPtr->debugFlag = debug;
d151 1
a151 1
 *-------------------------------------------------------------------------
d153 1
a153 1
 * Tk_ChooseColorObjCmd --
d167 1
a167 1
 *-------------------------------------------------------------------------
d171 1
a171 1
Tk_ChooseColorObjCmd(clientData, interp, objc, objv)
d174 2
a175 2
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
d177 3
a179 3
    Tk_Window tkwin, parent;
    HWND hWnd;
    int i, oldMode, winCode;
d181 4
d186 1
a186 1
    static COLORREF dwCustColors[16];
a187 6
    static char *optionStrings[] = {
	"-initialcolor",    "-parent",	    "-title",	    NULL
    };
    enum options {
	COLOR_INITIAL,	    COLOR_PARENT,   COLOR_TITLE
    };
d189 3
a191 1
    if (inited == 0) {
d194 1
a194 1
	 * modify. We store these colors in a static array so that the next
d198 2
a199 2
	for (i = 0; i < 16; i++) {
	    dwCustColors[i] = RGB(255-i * 10, i, i * 10);
d201 1
a201 1
	oldColor = RGB(0xa0, 0xa0, 0xa0);
d205 3
a207 1
    tkwin = (Tk_Window) clientData;
d209 16
a224 15
    parent			= tkwin;
    chooseColor.lStructSize	= sizeof(CHOOSECOLOR);
    chooseColor.hwndOwner	= NULL;			
    chooseColor.hInstance	= NULL;
    chooseColor.rgbResult	= oldColor;
    chooseColor.lpCustColors	= dwCustColors;
    chooseColor.Flags		= CC_RGBINIT | CC_FULLOPEN | CC_ENABLEHOOK;
    chooseColor.lCustData	= (LPARAM) NULL;
    chooseColor.lpfnHook	= ColorDlgHookProc;
    chooseColor.lpTemplateName	= (LPTSTR) interp;

    for (i = 1; i < objc; i += 2) {
	int index;
	char *string;
	Tcl_Obj *optionPtr, *valuePtr;
d226 4
a229 2
	optionPtr = objv[i];
	valuePtr = objv[i + 1];
d231 9
a239 3
	if (Tcl_GetIndexFromObj(interp, optionPtr, optionStrings, "option",
		TCL_EXACT, &index) != TCL_OK) {
	    return TCL_ERROR;
d241 5
a245 5
	if (i + 1 == objc) {
	    string = Tcl_GetStringFromObj(optionPtr, NULL);
	    Tcl_AppendResult(interp, "value for \"", string, "\" missing", 
		    (char *) NULL);
	    return TCL_ERROR;
d247 1
d249 4
a252 4
	string = Tcl_GetStringFromObj(valuePtr, NULL);
	switch ((enum options) index) {
	    case COLOR_INITIAL: {
		XColor *colorPtr;
d254 4
a257 19
		colorPtr = Tk_GetColor(interp, tkwin, string);
		if (colorPtr == NULL) {
		    return TCL_ERROR;
		}
		chooseColor.rgbResult = RGB(colorPtr->red / 0x100, 
			colorPtr->green / 0x100, colorPtr->blue / 0x100);
		break;
	    }
	    case COLOR_PARENT: {
		parent = Tk_NameToWindow(interp, string, tkwin);
		if (parent == NULL) {
		    return TCL_ERROR;
		}
		break;
	    }
	    case COLOR_TITLE: {
		chooseColor.lCustData = (LPARAM) string;
		break;
	    }
d259 7
a265 1
    }
a266 5
    Tk_MakeWindowExist(parent);
    chooseColor.hwndOwner = NULL;
    hWnd = Tk_GetHWND(Tk_WindowId(parent));
    chooseColor.hwndOwner = hWnd;
    
a271 7
     * Ensure that hWnd is enabled, because it can happen that we
     * have updated the wrapper of the parent, which causes us to
     * leave this child disabled (Windows loses sync).
     */
    EnableWindow(hWnd, 1);

    /*
a280 1

d288 3
a290 3
	GetRValue(chooseColor.rgbResult), 
	        GetGValue(chooseColor.rgbResult), 
		GetBValue(chooseColor.rgbResult));
d292 2
d295 10
d306 7
a312 1
    return TCL_OK;
d316 1
a316 1
 *-------------------------------------------------------------------------
d320 2
a321 2
 *	Provides special handling of messages for the Color common dialog
 *	box.  Used to set the title when the dialog first appears.
d324 1
a324 2
 *	The return value is 0 if the default dialog box procedure should
 *	handle the message, non-zero otherwise. 
d327 1
a327 1
 *	Changes the title of the dialog window.
d332 6
a337 6
static UINT CALLBACK 
ColorDlgHookProc(hDlg, uMsg, wParam, lParam)
    HWND hDlg;			/* Handle to the color dialog. */
    UINT uMsg;			/* Type of message. */
    WPARAM wParam;		/* First message parameter. */
    LPARAM lParam;		/* Second message parameter. */
d339 2
a340 2
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
d343 10
a352 4
	case WM_INITDIALOG: {
	    const char *title;
	    CHOOSECOLOR *ccPtr;
	    Tcl_DString ds;
d354 2
a355 3
	    /* 
	     * Set the title string of the dialog.
	     */
a356 14
	    ccPtr = (CHOOSECOLOR *) lParam;
	    title = (const char *) ccPtr->lCustData;
	    if ((title != NULL) && (title[0] != '\0')) {
		Tcl_UtfToExternalDString(NULL, title, -1, &ds);
		SetWindowText(hDlg, (TCHAR *) Tcl_DStringValue(&ds));
		Tcl_DStringFree(&ds);
	    }
	    if (tsdPtr->debugFlag) {
		tsdPtr->debugInterp = (Tcl_Interp *) ccPtr->lpTemplateName;
		Tcl_DoWhenIdle(SetTkDialog, (ClientData) hDlg);
	    }
	    return TRUE;
	}
    }
d374 3
d382 1
a382 1
Tk_GetOpenFileObjCmd(clientData, interp, objc, objv)
d385 2
a386 2
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
d388 1
a388 5
    if (TkWinGetPlatformId() == VER_PLATFORM_WIN32_NT) {
	return GetFileNameW(clientData, interp, objc, objv, 1);
    } else {
	return GetFileNameA(clientData, interp, objc, objv, 1);
    }
d409 1
a409 1
Tk_GetSaveFileObjCmd(clientData, interp, objc, objv)
d412 2
a413 2
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
d415 1
a415 5
    if (TkWinGetPlatformId() == VER_PLATFORM_WIN32_NT) {
	return GetFileNameW(clientData, interp, objc, objv, 0);
    } else {
	return GetFileNameA(clientData, interp, objc, objv, 0);
    }
d421 1
a421 1
 * GetFileNameW --
d435 1
a435 1
GetFileNameW(clientData, interp, objc, objv, open)
d438 4
a441 4
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
    int open;			/* 1 to call GetOpenFileName(), 0 to 
				 * call GetSaveFileName(). */
d443 6
a448 22
    Tcl_Encoding unicodeEncoding = Tcl_GetEncoding(NULL, "unicode");
    OPENFILENAMEW ofn;
    WCHAR file[MAX_PATH];
    int result, winCode, oldMode, i;
    char *extension, *filter, *title;
    Tk_Window tkwin;
    HWND hWnd;
    Tcl_DString utfFilterString, utfDirString;
    Tcl_DString extString, filterString, dirString, titleString;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    static char *optionStrings[] = {
	"-defaultextension", "-filetypes", "-initialdir", "-initialfile",
	"-parent",	"-title",	NULL
    };
    enum options {
	FILE_DEFAULT,	FILE_TYPES,	FILE_INITDIR,	FILE_INITFILE,
	FILE_PARENT,	FILE_TITLE
    };

    result = TCL_ERROR;
    file[0] = '\0';
d451 1
a451 1
     * Parse the arguments.
d453 2
a454 137

    extension = NULL;
    filter = NULL;
    Tcl_DStringInit(&utfFilterString);
    Tcl_DStringInit(&utfDirString);
    tkwin = (Tk_Window) clientData;
    title = NULL;

    for (i = 1; i < objc; i += 2) {
	int index;
	char *string;
	Tcl_Obj *optionPtr, *valuePtr;

	optionPtr = objv[i];
	valuePtr = objv[i + 1];

	if (Tcl_GetIndexFromObj(interp, optionPtr, optionStrings, "option", 
		0, &index) != TCL_OK) {
	    goto end;
	}
	if (i + 1 == objc) {
	    string = Tcl_GetStringFromObj(optionPtr, NULL);
	    Tcl_AppendResult(interp, "value for \"", string, "\" missing", 
		    (char *) NULL);
	    goto end;
	}

	string = Tcl_GetStringFromObj(valuePtr, NULL);
	switch ((enum options) index) {
	    case FILE_DEFAULT: {
		if (string[0] == '.') {
		    string++;
		}
		extension = string;
		break;
	    }
	    case FILE_TYPES: {
		Tcl_DStringFree(&utfFilterString);
		if (MakeFilter(interp, string, &utfFilterString) != TCL_OK) {
		    goto end;
		}
		filter = Tcl_DStringValue(&utfFilterString);
		break;
	    }
	    case FILE_INITDIR: {
		Tcl_DStringFree(&utfDirString);
		if (Tcl_TranslateFileName(interp, string, 
			&utfDirString) == NULL) {
		    goto end;
		}
		break;
	    }
	    case FILE_INITFILE: {
		Tcl_DString ds;

		if (Tcl_TranslateFileName(interp, string, &ds) == NULL) {
		    goto end;
		}
		Tcl_UtfToExternal(NULL, unicodeEncoding, Tcl_DStringValue(&ds), 
			Tcl_DStringLength(&ds), 0, NULL, (char *) file, 
			sizeof(file), NULL, NULL, NULL);
		break;
	    }
	    case FILE_PARENT: {
		tkwin = Tk_NameToWindow(interp, string, tkwin);
		if (tkwin == NULL) {
		    goto end;
		}
		break;
	    }
	    case FILE_TITLE: {
		title = string;
		break;
	    }
	}
    }

    if (filter == NULL) {
	if (MakeFilter(interp, "", &utfFilterString) != TCL_OK) {
	    goto end;
	}
    }

    Tk_MakeWindowExist(tkwin);
    hWnd = Tk_GetHWND(Tk_WindowId(tkwin));

    ofn.lStructSize		= sizeof(ofn);
    ofn.hwndOwner		= hWnd;
    ofn.hInstance		= (HINSTANCE) GetWindowLong(ofn.hwndOwner, 
					GWL_HINSTANCE);
    ofn.lpstrFilter		= NULL;
    ofn.lpstrCustomFilter	= NULL;
    ofn.nMaxCustFilter		= 0;
    ofn.nFilterIndex		= 0;
    ofn.lpstrFile		= (WCHAR *) file;
    ofn.nMaxFile		= MAX_PATH;
    ofn.lpstrFileTitle		= NULL;
    ofn.nMaxFileTitle		= 0;
    ofn.lpstrInitialDir		= NULL;
    ofn.lpstrTitle		= NULL;
    ofn.Flags			= OFN_HIDEREADONLY | OFN_PATHMUSTEXIST 
				  | OFN_NOCHANGEDIR | OFN_EXPLORER;
    ofn.nFileOffset		= 0;
    ofn.nFileExtension		= 0;
    ofn.lpstrDefExt		= NULL;
    ofn.lpfnHook		= OFNHookProcW;
    ofn.lCustData		= (LPARAM) interp;
    ofn.lpTemplateName		= NULL;

    if (open != 0) {
	ofn.Flags |= OFN_FILEMUSTEXIST;
    } else {
	ofn.Flags |= OFN_OVERWRITEPROMPT;
    }

    if (tsdPtr->debugFlag != 0) {
	ofn.Flags |= OFN_ENABLEHOOK;
    }

    if (extension != NULL) {
	Tcl_UtfToExternalDString(unicodeEncoding, extension, -1, &extString);
	ofn.lpstrDefExt = (WCHAR *) Tcl_DStringValue(&extString);
    }

    Tcl_UtfToExternalDString(unicodeEncoding, Tcl_DStringValue(&utfFilterString),
	    Tcl_DStringLength(&utfFilterString), &filterString);
    ofn.lpstrFilter = (WCHAR *) Tcl_DStringValue(&filterString);

    if (Tcl_DStringValue(&utfDirString)[0] != '\0') {
	Tcl_UtfToExternalDString(unicodeEncoding, Tcl_DStringValue(&utfDirString),
		Tcl_DStringLength(&utfDirString), &dirString);
        ofn.lpstrInitialDir = (WCHAR *) Tcl_DStringValue(&dirString);
    }

    if (title != NULL) {
	Tcl_UtfToExternalDString(unicodeEncoding, title, -1, &titleString);
	ofn.lpstrTitle = (WCHAR *) Tcl_DStringValue(&titleString);
d456 1
d459 1
a459 1
     * Popup the dialog.
a460 1

d462 3
a464 2
    if (open != 0) {
	winCode = GetOpenFileNameW(&ofn);
d466 1
a466 1
	winCode = GetSaveFileNameW(&ofn);
d468 2
a469 8
    Tcl_SetServiceMode(oldMode);

    /*
     * Ensure that hWnd is enabled, because it can happen that we
     * have updated the wrapper of the parent, which causes us to
     * leave this child disabled (Windows loses sync).
     */
    EnableWindow(hWnd, 1);
d478 4
d483 1
a483 1
     * Process the results.
d485 23
d509 35
a543 12
    if (winCode != 0) {
	char *p;
	Tcl_DString ds;

	Tcl_ExternalToUtfDString(unicodeEncoding, (char *) ofn.lpstrFile, -1, &ds);
	for (p = Tcl_DStringValue(&ds); *p != '\0'; p++) {
	    /*
	     * Change the pathname to the Tcl "normalized" pathname, where
	     * back slashes are used instead of forward slashes
	     */
	    if (*p == '\\') {
		*p = '/';
d545 2
d548 3
a550 2
	Tcl_AppendResult(interp, Tcl_DStringValue(&ds), NULL);
	Tcl_DStringFree(&ds);
d553 2
a554 2
    if (ofn.lpstrTitle != NULL) {
	Tcl_DStringFree(&titleString);
d556 2
a557 2
    if (ofn.lpstrInitialDir != NULL) {
	Tcl_DStringFree(&dirString);
a558 51
    Tcl_DStringFree(&filterString);
    if (ofn.lpstrDefExt != NULL) {
	Tcl_DStringFree(&extString);
    }
    result = TCL_OK;

    end:
    Tcl_DStringFree(&utfDirString);
    Tcl_DStringFree(&utfFilterString);

    return result;
}

/*
 *-------------------------------------------------------------------------
 *
 * OFNHookProcW --
 *
 *	Hook procedure called only if debugging is turned on.  Sets
 *	the "tk_dialog" variable when the dialog is ready to receive
 *	messages.
 *
 * Results:
 *	Returns 0 to allow default processing of messages to occur.
 *
 * Side effects:
 *	None.
 *
 *-------------------------------------------------------------------------
 */

static UINT APIENTRY 
OFNHookProcW(
    HWND hdlg,		// handle to child dialog window
    UINT uMsg,		// message identifier
    WPARAM wParam,	// message parameter
    LPARAM lParam) 	// message parameter
{
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    OPENFILENAMEW *ofnPtr;

    if (uMsg == WM_INITDIALOG) {
	SetWindowLong(hdlg, GWL_USERDATA, lParam);
    } else if (uMsg == WM_WINDOWPOSCHANGED) {
	/*
	 * This message is delivered at the right time to enable Tk
	 * to set the debug information.  Unhooks itself so it 
	 * won't set the debug information every time it gets a 
	 * WM_WINDOWPOSCHANGED message.
	 */
d560 1
a560 9
        ofnPtr = (OPENFILENAMEW *) GetWindowLong(hdlg, GWL_USERDATA);
	if (ofnPtr != NULL) {
	    hdlg = GetParent(hdlg);
	    tsdPtr->debugInterp = (Tcl_Interp *) ofnPtr->lCustData;
	    Tcl_DoWhenIdle(SetTkDialog, (ClientData) hdlg);
	    SetWindowLong(hdlg, GWL_USERDATA, (LPARAM) NULL);
	}
    }
    return 0;
d566 1
a566 1
 * GetFileNameA --
d568 1
a568 1
 *	Calls GetOpenFileName() or GetSaveFileName().
d571 1
a571 1
 *	See user documentation.
d574 2
a575 1
 *	See user documentation.
d581 7
a587 7
GetFileNameA(clientData, interp, objc, objv, open)
    ClientData clientData;	/* Main window associated with interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
    int open;			/* 1 to call GetOpenFileName(), 0 to 
				 * call GetSaveFileName(). */
d589 31
a619 18
    OPENFILENAME ofn;
    TCHAR file[MAX_PATH], savePath[MAX_PATH];
    int result, winCode, oldMode, i;
    char *extension, *filter, *title;
    Tk_Window tkwin;
    HWND hWnd;
    Tcl_DString utfFilterString, utfDirString;
    Tcl_DString extString, filterString, dirString, titleString;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    static char *optionStrings[] = {
	"-defaultextension", "-filetypes", "-initialdir", "-initialfile",
	"-parent",	"-title",	NULL
    };
    enum options {
	FILE_DEFAULT,	FILE_TYPES,	FILE_INITDIR,	FILE_INITFILE,
	FILE_PARENT,	FILE_TITLE
    };
d621 8
a628 81
    result = TCL_ERROR;
    file[0] = '\0';

    /*
     * Parse the arguments.
     */

    extension = NULL;
    filter = NULL;
    Tcl_DStringInit(&utfFilterString);
    Tcl_DStringInit(&utfDirString);
    tkwin = (Tk_Window) clientData;
    title = NULL;

    for (i = 1; i < objc; i += 2) {
	int index;
	char *string;
	Tcl_Obj *optionPtr, *valuePtr;

	optionPtr = objv[i];
	valuePtr = objv[i + 1];

	if (Tcl_GetIndexFromObj(interp, optionPtr, optionStrings, "option", 
		0, &index) != TCL_OK) {
	    goto end;
	}
	if (i + 1 == objc) {
	    string = Tcl_GetStringFromObj(optionPtr, NULL);
	    Tcl_AppendResult(interp, "value for \"", string, "\" missing", 
		    (char *) NULL);
	    goto end;
	}

	string = Tcl_GetStringFromObj(valuePtr, NULL);
	switch ((enum options) index) {
	    case FILE_DEFAULT: {
		if (string[0] == '.') {
		    string++;
		}
		extension = string;
		break;
	    }
	    case FILE_TYPES: {
		Tcl_DStringFree(&utfFilterString);
		if (MakeFilter(interp, string, &utfFilterString) != TCL_OK) {
		    goto end;
		}
		filter = Tcl_DStringValue(&utfFilterString);
		break;
	    }
	    case FILE_INITDIR: {
		Tcl_DStringFree(&utfDirString);
		if (Tcl_TranslateFileName(interp, string, 
			&utfDirString) == NULL) {
		    goto end;
		}
		break;
	    }
	    case FILE_INITFILE: {
		Tcl_DString ds;

		if (Tcl_TranslateFileName(interp, string, &ds) == NULL) {
		    goto end;
		}
		Tcl_UtfToExternal(NULL, NULL, Tcl_DStringValue(&ds), 
			Tcl_DStringLength(&ds), 0, NULL, (char *) file, 
			sizeof(file), NULL, NULL, NULL);
		break;
	    }
	    case FILE_PARENT: {
		tkwin = Tk_NameToWindow(interp, string, tkwin);
		if (tkwin == NULL) {
		    goto end;
		}
		break;
	    }
	    case FILE_TITLE: {
		title = string;
		break;
	    }
	}
a630 5
    if (filter == NULL) {
	if (MakeFilter(interp, "", &utfFilterString) != TCL_OK) {
	    goto end;
	}
    }
d632 2
a633 28
    Tk_MakeWindowExist(tkwin);
    hWnd = Tk_GetHWND(Tk_WindowId(tkwin));

    ofn.lStructSize		= sizeof(ofn);
    ofn.hwndOwner		= hWnd;
    ofn.hInstance		= (HINSTANCE) GetWindowLong(ofn.hwndOwner, 
					GWL_HINSTANCE);
    ofn.lpstrFilter		= NULL;
    ofn.lpstrCustomFilter	= NULL;
    ofn.nMaxCustFilter		= 0;
    ofn.nFilterIndex		= 0;
    ofn.lpstrFile		= (LPTSTR) file;
    ofn.nMaxFile		= MAX_PATH;
    ofn.lpstrFileTitle		= NULL;
    ofn.nMaxFileTitle		= 0;
    ofn.lpstrInitialDir		= NULL;
    ofn.lpstrTitle		= NULL;
    ofn.Flags			= OFN_HIDEREADONLY | OFN_PATHMUSTEXIST 
				  | OFN_NOCHANGEDIR | OFN_EXPLORER;
    ofn.nFileOffset		= 0;
    ofn.nFileExtension		= 0;
    ofn.lpstrDefExt		= NULL;
    ofn.lpfnHook		= OFNHookProc;
    ofn.lCustData		= (LPARAM) interp;
    ofn.lpTemplateName		= NULL;

    if (open != 0) {
	ofn.Flags |= OFN_FILEMUSTEXIST;
d635 1
a635 1
	ofn.Flags |= OFN_OVERWRITEPROMPT;
d638 3
a640 3
    if (tsdPtr->debugFlag != 0) {
	ofn.Flags |= OFN_ENABLEHOOK;
    }
d642 2
a643 7
    if (extension != NULL) {
	Tcl_UtfToExternalDString(NULL, extension, -1, &extString);
	ofn.lpstrDefExt = (LPTSTR) Tcl_DStringValue(&extString);
    }
    Tcl_UtfToExternalDString(NULL, Tcl_DStringValue(&utfFilterString),
	    Tcl_DStringLength(&utfFilterString), &filterString);
    ofn.lpstrFilter = (LPTSTR) Tcl_DStringValue(&filterString);
d645 8
a652 9
    if (Tcl_DStringValue(&utfDirString)[0] != '\0') {
	Tcl_UtfToExternalDString(NULL, Tcl_DStringValue(&utfDirString),
		Tcl_DStringLength(&utfDirString), &dirString);
        ofn.lpstrInitialDir = (LPTSTR) Tcl_DStringValue(&dirString);
    }
    if (title != NULL) {
	Tcl_UtfToExternalDString(NULL, title, -1, &titleString);
	ofn.lpstrTitle = (LPTSTR) Tcl_DStringValue(&titleString);
    }
d654 7
a660 3
    /*
     * Popup the dialog.  
     */
d662 9
a670 9
    GetCurrentDirectory(MAX_PATH, savePath);
    oldMode = Tcl_SetServiceMode(TCL_SERVICE_ALL);
    if (open != 0) {
	winCode = GetOpenFileName(&ofn);
    } else {
	winCode = GetSaveFileName(&ofn);
    }
    Tcl_SetServiceMode(oldMode);
    SetCurrentDirectory(savePath);
d672 8
a679 6
    /*
     * Ensure that hWnd is enabled, because it can happen that we
     * have updated the wrapper of the parent, which causes us to
     * leave this child disabled (Windows loses sync).
     */
    EnableWindow(hWnd, 1);
d681 7
a687 4
    /*
     * Clear the interp result since anything may have happened during the
     * modal loop.
     */
d689 5
a693 1
    Tcl_ResetResult(interp);
d695 5
a699 16
    /*
     * Process the results.
     */

    if (winCode != 0) {
	char *p;
	Tcl_DString ds;

	Tcl_ExternalToUtfDString(NULL, (char *) ofn.lpstrFile, -1, &ds);
	for (p = Tcl_DStringValue(&ds); *p != '\0'; p++) {
	    /*
	     * Change the pathname to the Tcl "normalized" pathname, where
	     * back slashes are used instead of forward slashes
	     */
	    if (*p == '\\') {
		*p = '/';
d702 7
a708 2
	Tcl_AppendResult(interp, Tcl_DStringValue(&ds), NULL);
	Tcl_DStringFree(&ds);
d711 4
a714 2
    if (ofn.lpstrTitle != NULL) {
	Tcl_DStringFree(&titleString);
d716 3
a718 6
    if (ofn.lpstrInitialDir != NULL) {
	Tcl_DStringFree(&dirString);
    }
    Tcl_DStringFree(&filterString);
    if (ofn.lpstrDefExt != NULL) {
	Tcl_DStringFree(&extString);
d720 1
a720 1
    result = TCL_OK;
d722 1
a722 24
    end:
    Tcl_DStringFree(&utfDirString);
    Tcl_DStringFree(&utfFilterString);

    return result;
}

/*
 *-------------------------------------------------------------------------
 *
 * OFNHookProc --
 *
 *	Hook procedure called only if debugging is turned on.  Sets
 *	the "tk_dialog" variable when the dialog is ready to receive
 *	messages.
 *
 * Results:
 *	Returns 0 to allow default processing of messages to occur.
 *
 * Side effects:
 *	None.
 *
 *-------------------------------------------------------------------------
 */
d724 4
a727 33
static UINT APIENTRY 
OFNHookProc(
    HWND hdlg,		// handle to child dialog window
    UINT uMsg,		// message identifier
    WPARAM wParam,	// message parameter
    LPARAM lParam) 	// message parameter
{
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    OPENFILENAME *ofnPtr;

    if (uMsg == WM_INITDIALOG) {
	SetWindowLong(hdlg, GWL_USERDATA, lParam);
    } else if (uMsg == WM_WINDOWPOSCHANGED) {
	/*
	 * This message is delivered at the right time to both 
	 * old-style and explorer-style hook procs to enable Tk
	 * to set the debug information.  Unhooks itself so it 
	 * won't set the debug information every time it gets a 
	 * WM_WINDOWPOSCHANGED message.
	 */

        ofnPtr = (OPENFILENAME *) GetWindowLong(hdlg, GWL_USERDATA);
	if (ofnPtr != NULL) {
	    if (ofnPtr->Flags & OFN_EXPLORER) {
		hdlg = GetParent(hdlg);
	    }
	    tsdPtr->debugInterp = (Tcl_Interp *) ofnPtr->lCustData;
	    Tcl_DoWhenIdle(SetTkDialog, (ClientData) hdlg);
	    SetWindowLong(hdlg, GWL_USERDATA, (LPARAM) NULL);
	}
    }
    return 0;
d746 1
a746 2
static int 
MakeFilter(interp, string, dsPtr) 
d748 1
a749 1
    Tcl_DString *dsPtr;		/* Filled with windows filter string. */
d764 1
a764 1
	 * Use "All Files (*.*) as the default filter if none is specified
d852 4
a855 2
    Tcl_DStringAppend(dsPtr, filterStr, p - filterStr);
    ckfree((char *) filterStr);
d864 1
a864 1
 * Tk_ChooseDirectoryObjCmd --
d866 3
a868 3
 *	This procedure implements the "tk_chooseDirectory" dialog box 
 *	for the Windows platform. See the user documentation for details 
 *	on what it does.
d874 2
a875 2
 *	A modal dialog window is created.  Tcl_SetServiceMode() is
 *	called to allow background events to be processed
d881 1
a881 1
Tk_ChooseDirectoryObjCmd(clientData, interp, objc, objv)
d884 2
a885 2
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
d887 2
a888 5
    OPENFILENAME ofn;
    TCHAR path[MAX_PATH], savePath[MAX_PATH];
    ChooseDir cd;
    int result, mustExist, code, mode, i;
    Tk_Window tkwin;
d890 39
a928 70
    char *utfTitle;
    Tcl_DString utfDirString;
    Tcl_DString titleString, dirString;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    static char *optionStrings[] = {
	"-initialdir",	"-mustexist",	"-parent",	"-title",
	NULL
    };
    enum options {
	DIR_INITIAL,	DIR_EXIST,	DIR_PARENT,	FILE_TITLE
    };

    if (tsdPtr->WM_LBSELCHANGED == 0) {
        tsdPtr->WM_LBSELCHANGED = RegisterWindowMessage(LBSELCHSTRING);
    }
   
    result = TCL_ERROR;
    path[0] = '\0';

    Tcl_DStringInit(&utfDirString);
    mustExist = 0;
    tkwin = (Tk_Window) clientData;
    utfTitle = NULL;

    for (i = 1; i < objc; i += 2) {
	int index;
	char *string;
	Tcl_Obj *optionPtr, *valuePtr;

	optionPtr = objv[i];
	valuePtr = objv[i + 1];

	if (Tcl_GetIndexFromObj(interp, optionPtr, optionStrings, "option",
		0, &index) != TCL_OK) {
	    goto cleanup;
	}
	if (i + 1 == objc) {
	    string = Tcl_GetStringFromObj(optionPtr, NULL);
	    Tcl_AppendResult(interp, "value for \"", string, "\" missing", 
		    (char *) NULL);
	    goto cleanup;
	}

	string = Tcl_GetStringFromObj(valuePtr, NULL);
	switch ((enum options) index) {
	    case DIR_INITIAL: {
		Tcl_DStringFree(&utfDirString);
		if (Tcl_TranslateFileName(interp, string, 
			&utfDirString) == NULL) {
		    goto cleanup;
		}
		break;
	    }
	    case DIR_EXIST: {
		if (Tcl_GetBooleanFromObj(interp, valuePtr, &mustExist) != TCL_OK) {
		    goto cleanup;
		}
		break;
	    }
	    case DIR_PARENT: {
		tkwin = Tk_NameToWindow(interp, string, tkwin);
		if (tkwin == NULL) {
		    goto cleanup;
		}
		break;
	    }
	    case FILE_TITLE: {
		utfTitle = string;
		break;
d931 2
a932 1
    }
d934 4
a937 2
    Tk_MakeWindowExist(tkwin);
    hWnd = Tk_GetHWND(Tk_WindowId(tkwin));
d939 3
a941 70
    cd.interp = interp;

    ofn.lStructSize		= sizeof(ofn);
    ofn.hwndOwner		= hWnd;
    ofn.hInstance		= (HINSTANCE) GetWindowLong(ofn.hwndOwner, 
					GWL_HINSTANCE);
    ofn.lpstrFilter		= NULL;
    ofn.lpstrCustomFilter	= NULL;
    ofn.nMaxCustFilter		= 0;
    ofn.nFilterIndex		= 0;
    ofn.lpstrFile		= NULL; //(TCHAR *) path;
    ofn.nMaxFile		= MAX_PATH;
    ofn.lpstrFileTitle		= NULL;
    ofn.nMaxFileTitle		= 0;
    ofn.lpstrInitialDir		= NULL;
    ofn.lpstrTitle		= NULL;
    ofn.Flags			= OFN_HIDEREADONLY
				  | OFN_ENABLEHOOK | OFN_ENABLETEMPLATE;
    ofn.nFileOffset		= 0;
    ofn.nFileExtension		= 0;
    ofn.lpstrDefExt		= NULL;
    ofn.lCustData		= (LPARAM) &cd;
    ofn.lpfnHook		= ChooseDirectoryHookProc;
    ofn.lpTemplateName		= MAKEINTRESOURCE(FILEOPENORD);

    if (Tcl_DStringValue(&utfDirString)[0] != '\0') {
	Tcl_UtfToExternalDString(NULL, Tcl_DStringValue(&utfDirString), 
		Tcl_DStringLength(&utfDirString), &dirString);
	ofn.lpstrInitialDir = (LPTSTR) Tcl_DStringValue(&dirString);
    }
    if (mustExist) {
	ofn.Flags |= OFN_PATHMUSTEXIST;
    }
    if (utfTitle != NULL) {
	Tcl_UtfToExternalDString(NULL, utfTitle, -1, &titleString);
	ofn.lpstrTitle = (LPTSTR) Tcl_DStringValue(&titleString);
    }

    /*
     * Display dialog.  The choose directory dialog doesn't preserve the
     * current directory, so it must be saved and restored here.
     */
    
    GetCurrentDirectory(MAX_PATH, savePath);
    mode = Tcl_SetServiceMode(TCL_SERVICE_ALL);
    code = GetOpenFileName(&ofn);
    Tcl_SetServiceMode(mode);
    SetCurrentDirectory(savePath);

    /*
     * Ensure that hWnd is enabled, because it can happen that we
     * have updated the wrapper of the parent, which causes us to
     * leave this child disabled (Windows loses sync).
     */
    EnableWindow(hWnd, 1);

    Tcl_ResetResult(interp);
    if (code != 0) {
	/*
	 * Change the pathname to the Tcl "normalized" pathname, where
	 * back slashes are used instead of forward slashes
	 */

	char *p;
	Tcl_DString ds;

	Tcl_ExternalToUtfDString(NULL, (char *) cd.path, -1, &ds);
	for (p = Tcl_DStringValue(&ds); *p != '\0'; p++) {
	    if (*p == '\\') {
		*p = '/';
d944 2
a945 11
	Tcl_AppendResult(interp, Tcl_DStringValue(&ds), NULL);
	Tcl_DStringFree(&ds);
    }

    if (ofn.lpstrTitle != NULL) {
	Tcl_DStringFree(&titleString);
    }
    if (ofn.lpstrInitialDir != NULL) {
	Tcl_DStringFree(&dirString);
    }
    result = TCL_OK;
d947 1
a947 68
    cleanup:
    Tcl_DStringFree(&utfDirString);

    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * ChooseDirectoryHookProc --
 *
 *	Hook procedure called by the ChooseDirectory dialog to modify
 *	its default behavior.  The ChooseDirectory dialog is really an
 *	OpenFile dialog with certain controls rearranged and certain
 *	behaviors changed.  For instance, typing a name in the 
 *	ChooseDirectory dialog selects a directory, rather than 
 *	selecting a file.
 *
 * Results:
 *	Returns 0 to allow default processing of message, or 1 to 
 *	tell default dialog procedure not to process the message.
 *
 * Side effects:
 *	A dialog window is created the first this procedure is called.
 *	This window is not destroyed and will be reused the next time
 *	the application invokes the "tk_getOpenFile" or
 *	"tk_getSaveFile" command.
 *
 *----------------------------------------------------------------------
 */

static UINT APIENTRY 
ChooseDirectoryHookProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    OPENFILENAME *ofnPtr;

    /*
     * GWL_USERDATA keeps track of ofnPtr.
     */
    
    ofnPtr = (OPENFILENAME *) GetWindowLong(hwnd, GWL_USERDATA);

    if (message == WM_INITDIALOG) {
        ChooseDir *cdPtr;

	SetWindowLong(hwnd, GWL_USERDATA, lParam);
	ofnPtr = (OPENFILENAME *) lParam;
	cdPtr = (ChooseDir *) ofnPtr->lCustData;
	cdPtr->lastCtrl = 0;
	cdPtr->lastIdx = 1000;
	cdPtr->path[0] = '\0';

	if (ofnPtr->lpstrInitialDir == NULL) {
	    GetCurrentDirectory(MAX_PATH, cdPtr->path);
	} else {
	    lstrcpy(cdPtr->path, ofnPtr->lpstrInitialDir);
	}
	SetDlgItemText(hwnd, edt10, cdPtr->path);
	SendDlgItemMessage(hwnd, edt10, EM_SETSEL, 0, -1);
	if (tsdPtr->debugFlag) {
	    tsdPtr->debugInterp = cdPtr->interp;
	    Tcl_DoWhenIdle(SetTkDialog, (ClientData) hwnd);
d949 2
a950 15
	return 0;
    }
    if (ofnPtr == NULL) {
	return 0;
    }

    if (message == tsdPtr->WM_LBSELCHANGED) {
	/*
	 * Called when double-clicking on directory.
	 * If directory wasn't already open, browse that directory.
	 * If directory was already open, return selected directory.
	 */

        ChooseDir *cdPtr;
	int idCtrl, thisItem;
d952 1
a952 39
	idCtrl = (int) wParam;
        thisItem = LOWORD(lParam);
	cdPtr = (ChooseDir *) ofnPtr->lCustData;

	GetCurrentDirectory(MAX_PATH, cdPtr->path);
	if (idCtrl == lst2) {
	    if (cdPtr->lastIdx == thisItem) {
		EndDialog(hwnd, IDOK);
		return 1;
	    }
	    cdPtr->lastIdx = thisItem;
	}
	SetDlgItemText(hwnd, edt10, cdPtr->path);
	SendDlgItemMessage(hwnd, edt10, EM_SETSEL, 0, -1);
    } else if (message == WM_COMMAND) {
        ChooseDir *cdPtr;
	int idCtrl, notifyCode;

	idCtrl = LOWORD(wParam);
	notifyCode = HIWORD(wParam);
	cdPtr = (ChooseDir *) ofnPtr->lCustData;

	if ((idCtrl != IDOK) || (notifyCode != BN_CLICKED)) {
	    /*
	     * OK Button wasn't clicked.  Do the default.
	     */

	    if ((idCtrl == lst2) || (idCtrl == edt10)) {
		cdPtr->lastCtrl = idCtrl;
	    }
	    return 0;
	}

	/*
	 * Dialogs also get the message that OK was clicked when Enter 
	 * is pressed in some other control.  Find out what window
	 * we were really in when we got the supposed "OK", because the 
	 * behavior is different.
	 */
d954 5
a958 44
	if (cdPtr->lastCtrl == edt10) {
	    /*
	     * Hit Enter or clicked OK while typing a directory name in the 
	     * edit control.
	     * If it's a new name, try to go to that directory.
	     * If the name hasn't changed since last time, return selected 
	     * directory.
	     */

	    int changed;
	    TCHAR tmp[MAX_PATH];

	    if (GetDlgItemText(hwnd, edt10, tmp, MAX_PATH) == 0) {
		return 0;
	    }

	    changed = lstrcmp(cdPtr->path, tmp);
	    lstrcpy(cdPtr->path, tmp);

	    if (SetCurrentDirectory(cdPtr->path) == 0) {
		/*
		 * Non-existent directory.
		 */

		if (ofnPtr->Flags & OFN_PATHMUSTEXIST) {
		    /*
		     * Directory must exist.  Complain, then rehighlight text.
		     */

		    wsprintf(tmp, _T("Cannot change directory to \"%.200s\"."), 
			    cdPtr->path);
		    MessageBox(hwnd, tmp, NULL, MB_OK);
		    SendDlgItemMessage(hwnd, edt10, EM_SETSEL, 0, -1);
		    return 0;
		} 
		if (changed) {
		    /*
		     * Directory was invalid, but we want to keep displaying
		     * this name.  Don't update the listbox that displays the 
		     * current directory heirarchy, or it'll erase the name.
		     */
		    
		    SendDlgItemMessage(hwnd, edt10, EM_SETSEL, 0, -1);
		    return 0;
d961 5
a965 8
	    if (changed == 0) {
		/*
		 * Name hasn't changed since the last time we hit return
		 * or double-clicked on a directory, so return this.
		 */

		EndDialog(hwnd, IDOK);
		return 1;
a966 38
	    
	    cdPtr->lastCtrl = IDOK;

	    /*
	     * The following is the magic code, determined by running 
	     * Spy++ on some other directory chooser, that it takes to 
	     * get this dialog to update the listbox to display the 
	     * current directory.
	     */

	    SetDlgItemText(hwnd, edt1, cdPtr->path);
	    SendMessage(hwnd, WM_COMMAND, (WPARAM) MAKELONG(cmb2, 0x8003), 
		    (LPARAM) GetDlgItem(hwnd, cmb2));
	    return 0;
	} else if (idCtrl == lst2) {
	    /*
	     * Enter key was pressed while in listbox.  
	     * If it's a new directory, allow default behavior to open dir.
	     * If the directory hasn't changed, return selected directory.
	     */

	    int thisItem;

	    thisItem = (int) SendDlgItemMessage(hwnd, lst2, LB_GETCURSEL, 0, 0);
	    if (cdPtr->lastIdx == thisItem) {
		GetCurrentDirectory(MAX_PATH, cdPtr->path);
		EndDialog(hwnd, IDOK);
		return 1;
	    }
	} else if (idCtrl == IDOK) {
	    /* 
	     * The OK button was clicked. Return the value currently selected
             * in the entry.
	     */

	    GetCurrentDirectory(MAX_PATH, cdPtr->path);
	    EndDialog(hwnd, IDOK);
	    return 1;
d968 2
a969 22
    }
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_MessageBoxObjCmd --
 *
 *	This procedure implements the MessageBox window for the
 *	Windows platform. See the user documentation for details on what
 *	it does.
 *
 * Results:
 *	See user documentation.
 *
 * Side effects:
 *	None. The MessageBox window will be destroy before this procedure
 *	returns.
 *
 *----------------------------------------------------------------------
 */
d971 5
a975 57
int
Tk_MessageBoxObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Main window associated with interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Tk_Window tkwin, parent;
    HWND hWnd;
    char *message, *title;
    int defaultBtn, icon, type;
    int i, oldMode, flags, winCode;
    Tcl_DString messageString, titleString;
    static char *optionStrings[] = {
	"-default",	"-icon",	"-message",	"-parent",
	"-title",	"-type",	NULL
    };
    enum options {
	MSG_DEFAULT,	MSG_ICON,	MSG_MESSAGE,	MSG_PARENT,
	MSG_TITLE,	MSG_TYPE
    };

    tkwin = (Tk_Window) clientData;

    defaultBtn	= -1;
    icon	= MB_ICONINFORMATION;
    message	= NULL;
    parent	= tkwin;
    title	= NULL;
    type	= MB_OK;

    for (i = 1; i < objc; i += 2) {
	int index;
	char *string;
	Tcl_Obj *optionPtr, *valuePtr;

	optionPtr = objv[i];
	valuePtr = objv[i + 1];

	if (Tcl_GetIndexFromObj(interp, optionPtr, optionStrings, "option",
		TCL_EXACT, &index) != TCL_OK) {
	    return TCL_ERROR;
	}
	if (i + 1 == objc) {
	    string = Tcl_GetStringFromObj(optionPtr, NULL);
	    Tcl_AppendResult(interp, "value for \"", string, "\" missing", 
		    (char *) NULL);
	    return TCL_ERROR;
	}

        string = Tcl_GetStringFromObj(valuePtr, NULL);
	switch ((enum options) index) {
        case MSG_DEFAULT:
	    defaultBtn = TkFindStateNumObj(interp, optionPtr, buttonMap, 
		    valuePtr);
	    if (defaultBtn < 0) {
		return TCL_ERROR;
d977 2
a978 6
	    break;

	case MSG_ICON:
	    icon = TkFindStateNumObj(interp, optionPtr, iconMap, valuePtr);
	    if (icon < 0) {
		return TCL_ERROR;
d980 3
a982 9
	    break;

	case MSG_MESSAGE:
	    message = string;
	    break;

	case MSG_PARENT: 
	    parent = Tk_NameToWindow(interp, string, tkwin);
	    if (parent == NULL) {
d985 5
a989 9
	    break;

	case MSG_TITLE:
	    title = string;
	    break;

	case MSG_TYPE:
	    type = TkFindStateNumObj(interp, optionPtr, typeMap, valuePtr);
	    if (type < 0) {
d991 2
a992 2
	    }
	    break;
d994 11
d1006 1
d1009 6
a1014 15
    Tk_MakeWindowExist(parent);
    hWnd = Tk_GetHWND(Tk_WindowId(parent));
    
    flags = 0;
    if (defaultBtn >= 0) {
	int defaultBtnIdx;

	defaultBtnIdx = -1;
	for (i = 0; i < NUM_TYPES; i++) {
	    if (type == allowedTypes[i].type) {
		int j;

		for (j = 0; j < 3; j++) {
		    if (allowedTypes[i].btnIds[j] == defaultBtn) {
			defaultBtnIdx = j;
d1020 1
a1020 2
			    TkFindStateString(buttonMap, defaultBtn), 
			    "\"", NULL);
d1026 9
a1034 1
	flags = buttonFlagMap[defaultBtnIdx];
d1036 2
a1037 6

    flags |= icon | type | MB_SYSTEMMODAL;

    Tcl_UtfToExternalDString(NULL, message, -1, &messageString);
    Tcl_UtfToExternalDString(NULL, title, -1, &titleString);

d1039 1
a1039 2
    winCode = MessageBox(hWnd, Tcl_DStringValue(&messageString),
		Tcl_DStringValue(&titleString), flags);
d1042 11
d1054 4
a1057 3
     * Ensure that hWnd is enabled, because it can happen that we
     * have updated the wrapper of the parent, which causes us to
     * leave this child disabled (Windows loses sync).
a1058 1
    EnableWindow(hWnd, 1);
d1060 2
a1061 2
    Tcl_DStringFree(&messageString);
    Tcl_DStringFree(&titleString);
d1063 4
a1066 2
    Tcl_SetResult(interp, TkFindStateString(buttonMap, winCode), TCL_STATIC);
    return TCL_OK;
d1068 27
d1096 1
a1096 7
static void 
SetTkDialog(ClientData clientData)
{
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    char buf[32];
    HWND hwnd;
d1098 35
a1132 1
    hwnd = (HWND) clientData;
d1134 2
a1135 2
    sprintf(buf, "0x%08x", hwnd);
    Tcl_SetVar(tsdPtr->debugInterp, "tk_dialog", buf, TCL_GLOBAL_ONLY);
@


1.1.1.3
log
@import tk 8.4.0
@
text
@d1 1
d12 1
a12 1
 * RCS: @@(#) $Id: tkWinDialog.c,v 1.29 2002/08/14 15:31:21 vincentdarley Exp $
a22 35
/*
 * This controls the use of the new style tk_chooseDirectory dialog.
 */
#define USE_NEW_CHOOSEDIR 1
#ifdef USE_NEW_CHOOSEDIR
#include <shlobj.h>     /* includes SHBrowseForFolder */

/* These needed for compilation with VC++ 5.2 */
#ifndef BIF_EDITBOX
#define BIF_EDITBOX 0x10
#endif
#ifndef BIF_VALIDATE
#define BIF_VALIDATE 0x0020
#endif
#ifndef BFFM_VALIDATEFAILED
#ifdef UNICODE
#define BFFM_VALIDATEFAILED 4
#else
#define BFFM_VALIDATEFAILED 3
#endif
#endif 

/*
 * The following structure is used by the new Tk_ChooseDirectoryObjCmd
 * to pass data between it and its callback. Unqiue to Winodws platform.
 */
typedef struct ChooseDirData {
   TCHAR utfInitDir[MAX_PATH];       /* Initial folder to use */
   TCHAR utfRetDir[MAX_PATH];        /* Returned folder to use */
   Tcl_Interp *interp;
   int mustExist;                    /* true if file must exist to return from
				      * callback */
} CHOOSEDIRDATA;
#endif

a83 10
 * The value of TK_MULTI_MAX_PATH dictactes how many files can
 * be retrieved with tk_get*File -multiple 1.  It must be allocated
 * on the stack, so make it large enough but not too large.  -- hobbs
 * The data is stored as <dir>\0<file1>\0<file2>\0...<fileN>\0\0.
 * MAX_PATH == 260 on Win2K/NT.
 */

#define TK_MULTI_MAX_PATH	(MAX_PATH*20)

/*
a102 1
    OPENFILENAME *ofnPtr;	/* pointer to the OFN structure */
a108 4
#ifdef USE_NEW_CHOOSEDIR
static UINT APIENTRY	ChooseDirectoryValidateProc(HWND hdlg, UINT uMsg,
			    LPARAM wParam, LPARAM lParam);
#else
a110 1
#endif
d126 1
d186 1
a186 1
    int i, oldMode, winCode, result;
d188 1
a188 1
    static int inited = 0;
d191 2
a192 2
    static CONST char *optionStrings[] = {
	"-initialcolor", "-parent", "-title", NULL
d195 1
a195 1
	COLOR_INITIAL, COLOR_PARENT, COLOR_TITLE
a197 1
    result = TCL_OK;
d222 1
a222 1
    chooseColor.lpfnHook	= (LPOFNHOOKPROC) ColorDlgHookProc;
d302 1
a302 1
	char color[100];
d304 2
a305 2
	sprintf(color, "#%02x%02x%02x",
		GetRValue(chooseColor.rgbResult), 
d308 1
a308 1
        Tcl_AppendResult(interp, color, NULL);
a309 1
	result = TCL_OK;
d311 1
a311 2

    return result;
d355 2
a356 2
		(*tkWinProcs->setWindowText)(hDlg,
			Tcl_WinUtfToTChar(title, -1, &ds));
d457 1
d459 2
a460 2
    WCHAR file[TK_MULTI_MAX_PATH];
    int result, winCode, oldMode, i, multi = 0;
a465 1
    Tcl_Encoding unicodeEncoding = TkWinGetUnicodeEncoding();
d468 1
a468 1
    static CONST char *saveOptionStrings[] = {
d470 1
a470 1
	"-parent", "-title", NULL
a471 6
    static CONST char *openOptionStrings[] = {
	"-defaultextension", "-filetypes", "-initialdir", "-initialfile",
	"-multiple", "-parent", "-title", NULL
    };
    CONST char **optionStrings;

d474 1
a474 1
	FILE_MULTIPLE,	FILE_PARENT,	FILE_TITLE
a490 6
    if (open) {
	optionStrings = openOptionStrings;
    } else {
	optionStrings = saveOptionStrings;
    }

d499 2
a500 2
	if (Tcl_GetIndexFromObj(interp, optionPtr, optionStrings,
		"option", 0, &index) != TCL_OK) {
a502 14
	/*
	 * We want to maximize code sharing between the open and save file
	 * dialog implementations; in particular, the switch statement below.
	 * We use different sets of option strings from the GetIndexFromObj
	 * call above, but a single enumeration for both.  The save file
	 * dialog doesn't support -multiple, but it falls in the middle of
	 * the enumeration.  Ultimately, this means that when the index found
	 * by GetIndexFromObj is >= FILE_MULTIPLE, when doing a save file
	 * dialog, we have to increment the index, so that it matches the
	 * open file dialog enumeration.
	 */
	if (!open && index >= FILE_MULTIPLE) {
	    index++;
	}
d529 1
a529 1
		if (Tcl_TranslateFileName(interp, string,
d541 2
a542 2
		Tcl_UtfToExternal(NULL, unicodeEncoding, Tcl_DStringValue(&ds),
			Tcl_DStringLength(&ds), 0, NULL, (char *) file,
a545 7
	    case FILE_MULTIPLE: {
		if (Tcl_GetBooleanFromObj(interp, valuePtr,
			&multi) != TCL_OK) {
		    return TCL_ERROR;
		}
		break;
	    }
d569 1
a569 2
    ZeroMemory(&ofn, sizeof(OPENFILENAMEW));
    ofn.lStructSize		= sizeof(OPENFILENAMEW);
a570 4
#ifdef _WIN64
    ofn.hInstance		= (HINSTANCE) GetWindowLongPtr(ofn.hwndOwner, 
					GWLP_HINSTANCE);
#else
d573 4
a576 1
#endif
d578 5
a582 1
    ofn.nMaxFile		= TK_MULTI_MAX_PATH;
d585 4
a588 1
    ofn.lpfnHook		= (LPOFNHOOKPROC) OFNHookProcW;
d590 1
a601 4
    if (multi != 0) {
	ofn.Flags |= OFN_ALLOWMULTISELECT;
    }

d607 1
a607 2
    Tcl_UtfToExternalDString(unicodeEncoding,
	    Tcl_DStringValue(&utfFilterString),
d612 1
a612 2
	Tcl_UtfToExternalDString(unicodeEncoding,
		Tcl_DStringValue(&utfDirString),
d614 1
a614 18
    } else {
	/*
	 * NT 5.0 changed the meaning of lpstrInitialDir, so we have
	 * to ensure that we set the [pwd] if the user didn't specify
	 * anything else.
	 */
	Tcl_DString cwd;

	Tcl_DStringFree(&utfDirString);
	if ((Tcl_GetCwd(interp, &utfDirString) == (char *) NULL) ||
		(Tcl_TranslateFileName(interp,
			Tcl_DStringValue(&utfDirString), &cwd) == NULL)) {
	    Tcl_ResetResult(interp);
	} else {
	    Tcl_UtfToExternalDString(unicodeEncoding, Tcl_DStringValue(&cwd),
		    Tcl_DStringLength(&cwd), &dirString);
	}
	Tcl_DStringFree(&cwd);
a615 1
    ofn.lpstrInitialDir = (WCHAR *) Tcl_DStringValue(&dirString);
d653 8
a660 6
	if (ofn.Flags & OFN_ALLOWMULTISELECT) {
            /*
	     * The result in custData->szFile contains many items,
	     * separated with null characters.  It is terminated with
	     * two nulls in a row.  The first element is the directory
	     * path.
d662 2
a663 25
	    char *dir;
	    char *p;
	    char *file;
	    WCHAR *files;
	    Tcl_DString ds;
	    Tcl_DString fullname, filename;
	    Tcl_Obj *returnList;
	    int count = 0;

	    returnList = Tcl_NewObj();
	    Tcl_IncrRefCount(returnList);

	    files = ofn.lpstrFile;
	    Tcl_ExternalToUtfDString(unicodeEncoding, (char *) files, -1, &ds);

	    /* Get directory */
	    dir = Tcl_DStringValue(&ds);
	    for (p = dir; p && *p; p++) {
		/*
		 * Change the pathname to the Tcl "normalized" pathname, where
		 * back slashes are used instead of forward slashes
		 */
		if (*p == '\\') {
		    *p = '/';
		}
a664 53

	    while (*files != '\0') {
		while (*files != '\0') {
		    files++;
		}
		files++;
		if (*files != '\0') {
		    count++;
		    Tcl_ExternalToUtfDString(unicodeEncoding,
			    (char *)files, -1, &filename);
		    file = Tcl_DStringValue(&filename);
		    for (p = file; *p != '\0'; p++) {
			if (*p == '\\') {
			    *p = '/';
			}
		    }
		    Tcl_DStringInit(&fullname);
		    Tcl_DStringAppend(&fullname, dir, -1);
		    Tcl_DStringAppend(&fullname, "/", -1);
		    Tcl_DStringAppend(&fullname, file, -1);
		    Tcl_ListObjAppendElement(interp, returnList,
			    Tcl_NewStringObj(Tcl_DStringValue(&fullname), -1));
		    Tcl_DStringFree(&fullname);
		    Tcl_DStringFree(&filename);
		}
	    }
	    if (count == 0) {
		/*
		 * Only one file was returned.
		 */
		Tcl_ListObjAppendElement(interp, returnList,
			Tcl_NewStringObj(dir, -1));
	    }
	    Tcl_SetObjResult(interp, returnList);
	    Tcl_DecrRefCount(returnList);
	    Tcl_DStringFree(&ds);
	} else {
	    char *p;
	    Tcl_DString ds;
	    
	    Tcl_ExternalToUtfDString(unicodeEncoding,
		    (char *) ofn.lpstrFile, -1, &ds);
	    for (p = Tcl_DStringValue(&ds); *p != '\0'; p++) {
		/*
		 * Change the pathname to the Tcl "normalized" pathname, where
		 * back slashes are used instead of forward slashes
		 */
		if (*p == '\\') {
		    *p = '/';
		}
	    }
	    Tcl_AppendResult(interp, Tcl_DStringValue(&ds), NULL);
	    Tcl_DStringFree(&ds);
d666 3
a668 13
	result = TCL_OK;
    } else {
	/*
	 * Use the CommDlgExtendedError() function to retrieve the error code.
	 * This function can return one of about two dozen codes; most of
	 * these indicate some sort of gross system failure (insufficient
	 * memory, bad window handles, etc.).  Most of the error codes will be
	 * ignored; as we find we want more specific error messages for
	 * particular errors, we can extend the code as needed.
	 *
	 * We could also check for FNERR_BUFFERTOOSMALL, but we can't
	 * really do anything about it when it happens.
	 */
a669 23
	if (CommDlgExtendedError() == FNERR_INVALIDFILENAME) {
	    char *p;
	    Tcl_DString ds;
	    
	    Tcl_ExternalToUtfDString(unicodeEncoding,
		    (char *) ofn.lpstrFile, -1, &ds);
	    for (p = Tcl_DStringValue(&ds); *p != '\0'; p++) {
		/*
		 * Change the pathname to the Tcl "normalized" pathname,
		 * where back slashes are used instead of forward slashes
		 */
		if (*p == '\\') {
		    *p = '/';
		}
	    }
	    Tcl_SetResult(interp, "invalid filename \"", TCL_STATIC);
	    Tcl_AppendResult(interp, Tcl_DStringValue(&ds), "\"", NULL);
	    Tcl_DStringFree(&ds);
	} else {
	    result = TCL_OK;
	}
    }
    
d680 1
a718 3
#ifdef _WIN64
	SetWindowLongPtr(hdlg, GWLP_USERDATA, lParam);
#else
a719 1
#endif
a727 3
#ifdef _WIN64
        ofnPtr = (OPENFILENAMEW *) GetWindowLongPtr(hdlg, GWLP_USERDATA);
#else
a728 1
#endif
a732 3
#ifdef _WIN64
	    SetWindowLongPtr(hdlg, GWLP_USERDATA, (LPARAM) NULL);
#else
a733 1
#endif
d765 2
a766 2
    TCHAR file[TK_MULTI_MAX_PATH], savePath[MAX_PATH];
    int result, winCode, oldMode, i, multi = 0;
d774 1
a774 1
    static CONST char *saveOptionStrings[] = {
d776 1
a776 1
	"-parent", "-title", NULL
a777 6
    static CONST char *openOptionStrings[] = {
	"-defaultextension", "-filetypes", "-initialdir", "-initialfile",
	"-multiple", "-parent", "-title", NULL
    };
    CONST char **optionStrings;

d780 1
a780 1
	FILE_MULTIPLE,	FILE_PARENT,	FILE_TITLE
a796 6
    if (open) {
	optionStrings = openOptionStrings;
    } else {
	optionStrings = saveOptionStrings;
    }

d805 2
a806 2
	if (Tcl_GetIndexFromObj(interp, optionPtr, optionStrings,
		"option", 0, &index) != TCL_OK) {
a808 14
	/*
	 * We want to maximize code sharing between the open and save file
	 * dialog implementations; in particular, the switch statement below.
	 * We use different sets of option strings from the GetIndexFromObj
	 * call above, but a single enumeration for both.  The save file
	 * dialog doesn't support -multiple, but it falls in the middle of
	 * the enumeration.  Ultimately, this means that when the index found
	 * by GetIndexFromObj is >= FILE_MULTIPLE, when doing a save file
	 * dialog, we have to increment the index, so that it matches the
	 * open file dialog enumeration.
	 */
	if (!open && index >= FILE_MULTIPLE) {
	    index++;
	}
d835 1
a835 1
		if (Tcl_TranslateFileName(interp, string,
a851 7
	    case FILE_MULTIPLE: {
		if (Tcl_GetBooleanFromObj(interp, valuePtr,
			&multi) != TCL_OK) {
		    return TCL_ERROR;
		}
		break;
	    }
a876 4
#ifdef _WIN64
    ofn.hInstance		= (HINSTANCE) GetWindowLongPtr(ofn.hwndOwner, 
					GWLP_HINSTANCE);
#else
a878 1
#endif
d884 1
a884 1
    ofn.nMaxFile		= TK_MULTI_MAX_PATH;
d894 1
a894 1
    ofn.lpfnHook		= (LPOFNHOOKPROC) OFNHookProc;
a907 4
    if (multi != 0) {
	ofn.Flags |= OFN_ALLOWMULTISELECT;
    }

d919 1
a919 18
    } else {
	/*
	 * NT 5.0 changed the meaning of lpstrInitialDir, so we have
	 * to ensure that we set the [pwd] if the user didn't specify
	 * anything else.
	 */
	Tcl_DString cwd;

	Tcl_DStringFree(&utfDirString);
	if ((Tcl_GetCwd(interp, &utfDirString) == (char *) NULL) ||
		(Tcl_TranslateFileName(interp,
			Tcl_DStringValue(&utfDirString), &cwd) == NULL)) {
	    Tcl_ResetResult(interp);
	} else {
	    Tcl_UtfToExternalDString(NULL, Tcl_DStringValue(&cwd),
		    Tcl_DStringLength(&cwd), &dirString);
	}
	Tcl_DStringFree(&cwd);
a920 2
    ofn.lpstrInitialDir = (LPTSTR) Tcl_DStringValue(&dirString);

d927 1
a927 1
     * Popup the dialog.
d959 8
a966 6
	if (ofn.Flags & OFN_ALLOWMULTISELECT) {
            /*
	     * The result in custData->szFile contains many items,
	     * separated with null characters.  It is terminated with
	     * two nulls in a row.  The first element is the directory
	     * path.
d968 2
a969 58
	    char *dir;
	    char *p;
	    char *file;
	    char *files;
	    Tcl_DString ds;
	    Tcl_DString fullname, filename;
	    Tcl_Obj *returnList;
	    int count = 0;

	    returnList = Tcl_NewObj();
	    Tcl_IncrRefCount(returnList);

	    files = ofn.lpstrFile;
	    Tcl_ExternalToUtfDString(NULL, (char *) files, -1, &ds);

	    /* Get directory */
	    dir = Tcl_DStringValue(&ds);
	    for (p = dir; p && *p; p++) {
		/*
		 * Change the pathname to the Tcl "normalized" pathname, where
		 * back slashes are used instead of forward slashes
		 */
		if (*p == '\\') {
		    *p = '/';
		}
	    }

	    while (*files != '\0') {
		while (*files != '\0') {
		    files++;
		}
		files++;
		if (*files != '\0') {
		    count++;
		    Tcl_ExternalToUtfDString(NULL,
			    (char *)files, -1, &filename);
		    file = Tcl_DStringValue(&filename);
		    for (p = file; *p != '\0'; p++) {
			if (*p == '\\') {
			    *p = '/';
			}
		    }
		    Tcl_DStringInit(&fullname);
		    Tcl_DStringAppend(&fullname, dir, -1);
		    Tcl_DStringAppend(&fullname, "/", -1);
		    Tcl_DStringAppend(&fullname, file, -1);
		    Tcl_ListObjAppendElement(interp, returnList,
			    Tcl_NewStringObj(Tcl_DStringValue(&fullname), -1));
		    Tcl_DStringFree(&fullname);
		    Tcl_DStringFree(&filename);
		}
	    }
	    if (count == 0) {
		/*
		 * Only one file was returned.
		 */
		Tcl_ListObjAppendElement(interp, returnList,
			Tcl_NewStringObj(dir, -1));
a970 52
	    Tcl_SetObjResult(interp, returnList);
	    Tcl_DecrRefCount(returnList);
	    Tcl_DStringFree(&ds);
	} else {
	    char *p;
	    Tcl_DString ds;

	    Tcl_ExternalToUtfDString(NULL, (char *) ofn.lpstrFile, -1, &ds);
	    for (p = Tcl_DStringValue(&ds); *p != '\0'; p++) {
		/*
		 * Change the pathname to the Tcl "normalized" pathname, where
		 * back slashes are used instead of forward slashes
		 */
		if (*p == '\\') {
		    *p = '/';
		}
	    }
	    Tcl_AppendResult(interp, Tcl_DStringValue(&ds), NULL);
	    Tcl_DStringFree(&ds);
	}
	result = TCL_OK;
    } else {
	/*
	 * Use the CommDlgExtendedError() function to retrieve the error code.
	 * This function can return one of about two dozen codes; most of
	 * these indicate some sort of gross system failure (insufficient
	 * memory, bad window handles, etc.).  Most of the error codes will be
	 * ignored;; as we find we want specific error messages for particular
	 * errors, we can extend the code as needed.
	 *
	 * We could also check for FNERR_BUFFERTOOSMALL, but we can't
	 * really do anything about it when it happens.
	 */
	if (CommDlgExtendedError() == FNERR_INVALIDFILENAME) {
	    char *p;
	    Tcl_DString ds;

	    Tcl_ExternalToUtfDString(NULL, (char *) ofn.lpstrFile, -1, &ds);
	    for (p = Tcl_DStringValue(&ds); *p != '\0'; p++) {
		/*
		 * Change the pathname to the Tcl "normalized" pathname,
		 * where back slashes are used instead of forward slashes
		 */
		if (*p == '\\') {
		    *p = '/';
		}
	    }
	    Tcl_SetResult(interp, "invalid filename \"", TCL_STATIC);
	    Tcl_AppendResult(interp, Tcl_DStringValue(&ds), "\"", NULL);
	    Tcl_DStringFree(&ds);
	} else {
	    result = TCL_OK;
d972 2
d986 1
a1024 3
#ifdef _WIN64
	SetWindowLongPtr(hdlg, GWLP_USERDATA, lParam);
#else
a1025 1
#endif
a1034 3
#ifdef _WIN64
        ofnPtr = (OPENFILENAME *) GetWindowLongPtr(hdlg, GWLP_USERDATA);
#else
a1035 1
#endif
a1041 3
#ifdef _WIN64
	    SetWindowLongPtr(hdlg, GWLP_USERDATA, (LPARAM) NULL);
#else
a1042 1
#endif
d1113 1
a1113 1
	filterStr = ckalloc((unsigned int) strlen(string) * 3);
d1171 1
a1171 1
    Tcl_DStringAppend(dsPtr, filterStr, (int) (p - filterStr));
a1177 396
#ifdef USE_NEW_CHOOSEDIR
/*
 *----------------------------------------------------------------------
 *
 * Tk_ChooseDirectoryObjCmd --
 *
 * This procedure implements the "tk_chooseDirectory" dialog box
 * for the Windows platform. See the user documentation for details
 * on what it does. Uses the newer SHBrowseForFolder explorer type
 * interface.
 *
 * Results:
 * See user documentation.
 *
 * Side effects:
 * A modal dialog window is created.  Tcl_SetServiceMode() is
 * called to allow background events to be processed
 *
 *----------------------------------------------------------------------

The procedure tk_chooseDirectory pops up a dialog box for the user to
select a directory.  The following option-value pairs are possible as
command line arguments:

-initialdir dirname

Specifies that the directories in directory should be displayed when the
dialog pops up.  If this parameter is not specified, then the directories
in the current working directory are displayed.  If the parameter specifies
a relative path, the return value will convert the relative path to an
absolute path.  This option may not always work on the Macintosh.  This is
not a bug.  Rather, the General Controls control panel on the Mac allows
the end user to override the application default directory.

-parent window

Makes window the logical parent of the dialog.  The dialog is displayed on
top of its parent window.

-title titleString

Specifies a string to display as the title of the dialog box.  If this
option is not specified, then a default title will be displayed.

-mustexist boolean

Specifies whether the user may specify non-existant directories.  If this
parameter is true, then the user may only select directories that already
exist.  The default value is false.

New Behaviour:

- If mustexist = 0 and a user entered folder does not exist, a prompt will
  pop-up asking if the user wants another chance to change it. The old
  dialog just returned the bogus entry. On mustexist = 1, the entries MUST
  exist before exiting the box with OK.

  Bugs:

- If valid abs directory name is entered into the entry box and Enter
  pressed, the box will close returning the name. This is inconsistent when
  entering relative names or names with forward slashes, which are
  invalidated then corrected in the callback. After correction, the box is
  held open to allow further modification by the user.

- Not sure how to implement localization of message prompts.

- -title is really -message.
ToDo:
- Fix bugs.
- test to see what platforms this really works on.  May require v4.71
  of shell32.dll everywhere (what is standard?).
 *
 */
int
Tk_ChooseDirectoryObjCmd(clientData, interp, objc, objv)
    ClientData clientData;      /* Main window associated with interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    char path[MAX_PATH];
    int oldMode, result, i;
    LPCITEMIDLIST pidl;		/* Returned by browser */
    BROWSEINFO bInfo;		/* Used by browser */
    CHOOSEDIRDATA cdCBData;	/* Structure to pass back and forth */
    LPMALLOC pMalloc;		/* Used by shell */

    Tk_Window tkwin;
    HWND hWnd;
    char *utfTitle;		/* Title for window */
    TCHAR saveDir[MAX_PATH];
    Tcl_DString titleString;	/* UTF Title */
    Tcl_DString initDirString;	/* Initial directory */
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *)
	Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    static CONST char *optionStrings[] = {
        "-initialdir", "-mustexist",  "-parent",  "-title", (char *) NULL
    };
    enum options {
        DIR_INITIAL,   DIR_EXIST,  DIR_PARENT, FILE_TITLE
    };

    /*
     * Initialize
     */
    result		= TCL_ERROR;
    path[0]		= '\0';
    utfTitle		= NULL;

    ZeroMemory(&cdCBData, sizeof(CHOOSEDIRDATA));
    cdCBData.interp	= interp;

    tkwin = (Tk_Window) clientData;
    /*
     * Process the command line options
     */
    for (i = 1; i < objc; i += 2) {
        int index;
        char *string;
        Tcl_Obj *optionPtr, *valuePtr;

        optionPtr = objv[i];
        valuePtr = objv[i + 1];

        if (Tcl_GetIndexFromObj(interp, optionPtr, optionStrings, "option",
                0, &index) != TCL_OK) {
            goto cleanup;
        }
        if (i + 1 == objc) {
            string = Tcl_GetStringFromObj(optionPtr, NULL);
            Tcl_AppendResult(interp, "value for \"", string, "\" missing",
                    (char *) NULL);
            goto cleanup;
        }

	string = Tcl_GetString(valuePtr);
        switch ((enum options) index) {
            case DIR_INITIAL: {
                if (Tcl_TranslateFileName(interp, string,
			&initDirString) == NULL) {
		    goto cleanup;
		}
                string = Tcl_DStringValue(&initDirString);
                /*
                 * Convert possible relative path to full path to keep
                 * dialog happy
                 */
                GetFullPathName(string, MAX_PATH, saveDir, NULL);
                lstrcpyn(cdCBData.utfInitDir, saveDir, MAX_PATH);
                Tcl_DStringFree(&initDirString);
                break;
            }
            case DIR_EXIST: {
                if (Tcl_GetBooleanFromObj(interp, valuePtr,
                        &cdCBData.mustExist) != TCL_OK) {
                    goto cleanup;
                }
                break;
            }
            case DIR_PARENT: {
                tkwin = Tk_NameToWindow(interp, string, tkwin);
                if (tkwin == NULL) {
                    goto cleanup;
                }
                break;
            }
            case FILE_TITLE: {
                utfTitle = string;
                break;
            }
        }
    }

    /*
     * Get ready to call the browser
     */

    Tk_MakeWindowExist(tkwin);
    hWnd = Tk_GetHWND(Tk_WindowId(tkwin));

    /*
     * Setup the parameters used by SHBrowseForFolder
     */

    bInfo.hwndOwner      = hWnd;
    bInfo.pszDisplayName = path;
    bInfo.pidlRoot       = NULL;
    if (lstrlen(cdCBData.utfInitDir) == 0) {
        GetCurrentDirectory(MAX_PATH, cdCBData.utfInitDir);
    }
    bInfo.lParam = (LPARAM) &cdCBData;

    if (utfTitle != NULL) {
        Tcl_UtfToExternalDString(NULL, utfTitle, -1, &titleString);
        bInfo.lpszTitle = (LPTSTR) Tcl_DStringValue(&titleString);
    } else {
        bInfo.lpszTitle = "Please choose a directory, then select OK.";
    }

    /*
     * Set flags to add edit box (needs 4.71 Shell DLLs), status text line,
     * validate edit box and
     */
    bInfo.ulFlags  =  BIF_EDITBOX | BIF_STATUSTEXT | BIF_RETURNFSANCESTORS
        | BIF_VALIDATE;

    /*
     * Callback to handle events
     */
    bInfo.lpfn     = (BFFCALLBACK) ChooseDirectoryValidateProc;

    /*
     * Display dialog in background and process result.
     * We look to give the user a chance to change their mind
     * on an invalid folder if mustexist is 0;
     */

    oldMode = Tcl_SetServiceMode(TCL_SERVICE_ALL);
    GetCurrentDirectory(MAX_PATH, saveDir);
    if (SHGetMalloc(&pMalloc) == NOERROR) {
	pidl = SHBrowseForFolder(&bInfo);
	/* Null for cancel button or invalid dir, otherwise valid*/
	if (pidl != NULL) {
	    if (!SHGetPathFromIDList(pidl, path)) {
		Tcl_SetResult(interp, "Error: Not a file system folder\n",
			TCL_VOLATILE);
	    };
	    pMalloc->lpVtbl->Free(pMalloc, (void *) pidl);
	} else if (lstrlen(cdCBData.utfRetDir) > 0) {
	    lstrcpy(path, cdCBData.utfRetDir);
	}
	pMalloc->lpVtbl->Release(pMalloc);
    }
    SetCurrentDirectory(saveDir);
    Tcl_SetServiceMode(oldMode);

    /*
     * Ensure that hWnd is enabled, because it can happen that we
     * have updated the wrapper of the parent, which causes us to
     * leave this child disabled (Windows loses sync).
     */
    EnableWindow(hWnd, 1);

    /*
     * Change the pathname to the Tcl "normalized" pathname, where
     * back slashes are used instead of forward slashes
     */
    Tcl_ResetResult(interp);
    if (*path) {
        char *p;
        Tcl_DString ds;

        Tcl_ExternalToUtfDString(NULL, (char *) path, -1, &ds);
        for (p = Tcl_DStringValue(&ds); *p != '\0'; p++) {
            if (*p == '\\') {
                *p = '/';
            }
        }
        Tcl_AppendResult(interp, Tcl_DStringValue(&ds), NULL);
        Tcl_DStringFree(&ds);
    }

    result = TCL_OK;

    if (utfTitle != NULL) {
        Tcl_DStringFree(&titleString);
    }

    cleanup:
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * ChooseDirectoryValidateProc --
 *
 * Hook procedure called by the explorer ChooseDirectory dialog when events
 * occur.  It is used to validate the text entry the user may have entered.
 *
 * Results:
 * Returns 0 to allow default processing of message, or 1 to
 * tell default dialog procedure not to close.
 *
 *----------------------------------------------------------------------
 */
static UINT APIENTRY
ChooseDirectoryValidateProc (
    HWND hwnd,
    UINT message,
    LPARAM lParam,
    LPARAM lpData)
{
    TCHAR selDir[MAX_PATH];
    CHOOSEDIRDATA *chooseDirSharedData;
    Tcl_DString initDirString;
    char string[MAX_PATH];
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *)
        Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    chooseDirSharedData = (CHOOSEDIRDATA *)lpData;

#ifdef _WIN64
    SetWindowLongPtr(hwnd, GWLP_USERDATA, lpData);
#else
    SetWindowLong(hwnd, GWL_USERDATA, lpData);
#endif

    if (tsdPtr->debugFlag) {
        tsdPtr->debugInterp = (Tcl_Interp *) chooseDirSharedData->interp;
        Tcl_DoWhenIdle(SetTkDialog, (ClientData) hwnd);
    }
    chooseDirSharedData->utfRetDir[0] = '\0';
    switch (message) {
        case BFFM_VALIDATEFAILED:
            /*
             * First save and check to see if it is a valid path name, if
             * so then make that path the one shown in the
             * window. Otherwise, it failed the check and should be treated
             * as such. Use Set/GetCurrentDirectory which allows relative
             * path names and names with forward slashes. Use
             * Tcl_TranslateFileName to make sure names like ~ are
             * converted correctly.
             */
            Tcl_TranslateFileName(chooseDirSharedData->interp,
                    (char *)lParam, &initDirString);
            lstrcpyn (string, Tcl_DStringValue(&initDirString), MAX_PATH);
            Tcl_DStringFree(&initDirString);

            if (SetCurrentDirectory((char *)string) == 0) {
                LPTSTR lpFilePart[MAX_PATH];
                /*
                 * Get the full path name to the user entry,
                 * at this point it doesn't exist so see if
                 * it is supposed to. Otherwise just return it.
                 */
                GetFullPathName(string, MAX_PATH,
			chooseDirSharedData->utfRetDir, /*unused*/ lpFilePart);
                if (chooseDirSharedData->mustExist) {
                    /*
                     * User HAS to select a valid directory.
                     */
                    wsprintf(selDir, _T("Directory '%.200s' does not exist,\nplease select or enter an existing directory."), chooseDirSharedData->utfRetDir);
                    MessageBox(NULL, selDir, NULL, MB_ICONEXCLAMATION|MB_OK);
                    return 1;
                }
            } else {
                /*
                 * Changed to new folder OK, return immediatly with the
                 * current directory in utfRetDir.
                 */
                GetCurrentDirectory(MAX_PATH, chooseDirSharedData->utfRetDir);
                return 0;
            }
            return 0;

        case BFFM_SELCHANGED:
            /*
             * Set the status window to the currently selected path.
             * And enable the OK button if a file system folder, otherwise
             * disable the OK button for things like server names.
             * perhaps a new switch -enablenonfolders can be used to allow
             * non folders to be selected.
             *
             * Not called when user changes edit box directly.
             */

            if (SHGetPathFromIDList((LPITEMIDLIST) lParam, selDir)) {
                SendMessage(hwnd, BFFM_SETSTATUSTEXT, 0, (LPARAM) selDir);
                // enable the OK button
                SendMessage(hwnd, BFFM_ENABLEOK, 0, (LPARAM) 1);
                //EnableWindow(GetDlgItem(hwnd, IDOK), TRUE);
                SetCurrentDirectory(selDir);
            } else {
                // disable the OK button
                SendMessage(hwnd, BFFM_ENABLEOK, 0, (LPARAM) 0);
                //EnableWindow(GetDlgItem(hwnd, IDOK), FALSE);
            }
            UpdateWindow(hwnd);
            return 1;

        case BFFM_INITIALIZED:
            /*
             * Directory browser intializing - tell it where to start from,
             * user specified parameter.
             */
            SetCurrentDirectory((char *) lpData);
            SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)lpData);
            SendMessage(hwnd, BFFM_ENABLEOK, 0, (LPARAM) 1);
            break;

    }
    return 0;
}
#else
d1215 1
a1215 1
    static CONST char *optionStrings[] = {
a1287 1
    cd.ofnPtr = &ofn;
a1290 4
#ifdef _WIN64
    ofn.hInstance		= (HINSTANCE) GetWindowLongPtr(ofn.hwndOwner, 
					GWLP_HINSTANCE);
#else
a1292 1
#endif
d1309 1
a1309 1
    ofn.lpfnHook		= (LPOFNHOOKPROC) ChooseDirectoryHookProc;
d1315 1
a1315 18
    } else {
	/*
	 * NT 5.0 changed the meaning of lpstrInitialDir, so we have
	 * to ensure that we set the [pwd] if the user didn't specify
	 * anything else.
	 */
	Tcl_DString cwd;

	Tcl_DStringFree(&utfDirString);
	if ((Tcl_GetCwd(interp, &utfDirString) == (char *) NULL) ||
		(Tcl_TranslateFileName(interp,
			Tcl_DStringValue(&utfDirString), &cwd) == NULL)) {
	    Tcl_ResetResult(interp);
	} else {
	    Tcl_UtfToExternalDString(NULL, Tcl_DStringValue(&cwd),
		    Tcl_DStringLength(&cwd), &dirString);
	}
	Tcl_DStringFree(&cwd);
a1316 2
    ofn.lpstrInitialDir = (LPTSTR) Tcl_DStringValue(&dirString);

d1412 6
a1417 1
    ChooseDir *cdPtr;
d1420 3
a1427 5
#ifdef _WIN64
	SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) cdPtr);
#else
	SetWindowLong(hwnd, GWL_USERDATA, (LONG) cdPtr);
#endif
d1442 1
a1442 11

    /*
     * GWL_USERDATA keeps track of cdPtr.
     */
    
#ifdef _WIN64
    cdPtr = (ChooseDir *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
#else
    cdPtr = (ChooseDir *) GetWindowLong(hwnd, GWL_USERDATA);
#endif
    if (cdPtr == NULL) {
a1444 1
    ofnPtr = cdPtr->ofnPtr;
d1453 1
d1458 1
d1471 1
d1476 1
d1525 1
a1525 1
		    wsprintf(tmp, _T("Cannot change directory to \"%.200s\"."),
a1592 1
#endif
d1626 1
a1626 2
    Tcl_Encoding unicodeEncoding = TkWinGetUnicodeEncoding();
    static CONST char *optionStrings[] = {
d1737 2
a1738 2
    Tcl_UtfToExternalDString(unicodeEncoding, message, -1, &messageString);
    Tcl_UtfToExternalDString(unicodeEncoding, title, -1, &titleString);
d1741 2
a1742 6
    /*
     * MessageBoxW exists for all platforms.  Use it to allow unicode
     * error message to be displayed correctly where possible by the OS.
     */
    winCode = MessageBoxW(hWnd, (WCHAR *) Tcl_DStringValue(&messageString),
		(WCHAR *) Tcl_DStringValue(&titleString), flags);
d1765 3
d1769 1
a1769 1
    sprintf(buf, "0x%p", (HWND) clientData);
@


