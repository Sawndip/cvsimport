head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.20.24.53;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.17;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.30;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.55;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.38;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.29;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@/*
 * tkWinKey.c --
 *
 *	This file contains X emulation routines for keyboard related
 *	functions.
 *
 * Copyright (c) 1995 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkWinKey.c,v 1.14 2001/05/30 22:41:11 hobbs Exp $
 */

#include "tkWinInt.h"
/*
 * The keymap table holds mappings of Windows keycodes to X keysyms.
 * If Windows ever comes along and changes the value of their keycodes,
 * this will break all kinds of things.  However, this table lookup is much
 * faster than the alternative, in which we walked a list of keycodes looking
 * for a match.  Since this lookup is performed for every Windows keypress
 * event, it seems like a worthwhile improvement to use the table.
 */
#define MAX_KEYCODE 145 /* VK_SCROLL is the last entry in our table below */
static KeySym keymap[] = {
    NoSymbol, NoSymbol, NoSymbol, XK_Cancel, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, XK_BackSpace, XK_Tab,
	NoSymbol, NoSymbol, XK_Clear, XK_Return, NoSymbol,
	NoSymbol, XK_Shift_L, XK_Control_L, XK_Alt_L, XK_Pause,
	XK_Caps_Lock, NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, XK_Escape, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, XK_space, XK_Prior, XK_Next,
	XK_End, XK_Home, XK_Left, XK_Up, XK_Right,
	XK_Down, XK_Select, XK_Print, XK_Execute, NoSymbol,
	XK_Insert, XK_Delete, XK_Help, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, XK_Win_L, XK_Win_R, XK_App, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, XK_F1, XK_F2, XK_F3,
	XK_F4, XK_F5, XK_F6, XK_F7, XK_F8,
	XK_F9, XK_F10, XK_F11, XK_F12, XK_F13,
	XK_F14, XK_F15, XK_F16, XK_F17, XK_F18,
	XK_F19,	XK_F20, XK_F21, XK_F22, XK_F23,
	XK_F24,	NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, NoSymbol, XK_Num_Lock,
	XK_Scroll_Lock
};

/*
 * Prototypes for local procedures defined in this file:
 */

static KeySym		KeycodeToKeysym _ANSI_ARGS_((unsigned int keycode,
			    int state, int noascii));

/*
 *----------------------------------------------------------------------
 *
 * TkpGetString --
 *
 *	Retrieve the UTF string equivalent for the given keyboard event.
 *
 * Results:
 *	Returns the UTF string.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

char *
TkpGetString(winPtr, eventPtr, dsPtr)
    TkWindow *winPtr;		/* Window where event occurred:  needed to
				 * get input context. */
    XEvent *eventPtr;		/* X keyboard event. */
    Tcl_DString *dsPtr;		/* Uninitialized or empty string to hold
				 * result. */
{
    KeySym keysym;
    XKeyEvent* keyEv = &eventPtr->xkey;

    Tcl_DStringInit(dsPtr);
    if (eventPtr->xkey.send_event == -1) {
        if (eventPtr->xkey.nbytes > 0) {
	    Tcl_ExternalToUtfDString(TkWinGetKeyInputEncoding(),
                    eventPtr->xkey.trans_chars, eventPtr->xkey.nbytes, dsPtr);
        }
    } else if (eventPtr->xkey.send_event == -2) {
        /*
         * Special case for win2000 multi-lingal IME input. 
         * xkey.trans_chars[] already contains a UNICODE char.
         */

        int unichar;
        char buf[TCL_UTF_MAX];
        int len;

        unichar = (eventPtr->xkey.trans_chars[1] & 0xff);
        unichar <<= 8;
        unichar |= (eventPtr->xkey.trans_chars[0] & 0xff);

        len = Tcl_UniCharToUtf((Tcl_UniChar) unichar, buf);

        Tcl_DStringAppend(dsPtr, buf, len);
    } else  {
	/*
	 * This is an event generated from generic code.  It has no
	 * nchars or trans_chars members. 
	 */

	keysym = KeycodeToKeysym(eventPtr->xkey.keycode,
		eventPtr->xkey.state, 0);
	if (((keysym != NoSymbol) && (keysym > 0) && (keysym < 256)) 
		|| (keysym == XK_Return)
		|| (keysym == XK_Tab)) {
	    char buf[TCL_UTF_MAX];
	    int len = Tcl_UniCharToUtf((Tcl_UniChar) (keysym & 255), buf);
	    Tcl_DStringAppend(dsPtr, buf, len);
	}
    }
    return Tcl_DStringValue(dsPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * XKeycodeToKeysym --
 *
 *	Translate from a system-dependent keycode to a
 *	system-independent keysym.
 *
 * Results:
 *	Returns the translated keysym, or NoSymbol on failure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

KeySym
XKeycodeToKeysym(display, keycode, index)
    Display* display;
    unsigned int keycode;
    int index;
{
    int state = 0;

    if (index & 0x01) {
	state |= ShiftMask;
    }
    return KeycodeToKeysym(keycode, state, 0);
}



/*
 *----------------------------------------------------------------------
 *
 * KeycodeToKeysym --
 *
 *	Translate from a system-dependent keycode to a
 *	system-independent keysym.
 *
 * Results:
 *	Returns the translated keysym, or NoSymbol on failure.
 *
 * Side effects:
 *	It may affect the internal state of the keyboard, such as
 *      remembered dead key or lock indicator lamps.
 *
 *----------------------------------------------------------------------
 */

static KeySym
KeycodeToKeysym(keycode, state, noascii)
    unsigned int keycode;
    int state;
    int noascii;
{
    BYTE keys[256];
    int result, deadkey, shift;
    char buf[4];
    unsigned int scancode = MapVirtualKey(keycode, 0);

    /*
     * Do not run keycodes of lock keys through ToAscii().
     * One of ToAscii()'s side effects is to handle the lights
     * on the keyboard, and we don't want to mess that up.
     */

    if (noascii || keycode == VK_CAPITAL || keycode == VK_SCROLL ||
	    keycode == VK_NUMLOCK)
        goto skipToAscii;

    /*
     * Use MapVirtualKey() to detect some dead keys.
     */

    if (MapVirtualKey(keycode, 2) > 0x7fffUL)
        return XK_Multi_key;

    /*
     * Set up a keyboard with correct modifiers
     */

    memset(keys, 0, 256);
    if (state & ShiftMask)
        keys[VK_SHIFT] = 0x80;
    if (state & ControlMask)
	keys[VK_CONTROL] = 0x80;
    if (state & Mod2Mask)
	keys[VK_MENU] = 0x80;

    /* 
     * Make sure all lock button info is correct so we don't mess up the
     * lights
     */

    if (state & LockMask)
	keys[VK_CAPITAL] = 1;
    if (state & Mod3Mask)
	keys[VK_SCROLL] = 1;
    if (state & Mod1Mask)
	keys[VK_NUMLOCK] = 1;

    result = ToAscii(keycode, scancode, keys, (LPWORD) buf, 0);

    if (result < 0) {
        /*
         * Win95/98:
         * This was a dead char, which is now remembered by the keyboard.
         * Call ToAscii() again to forget it.
         * WinNT:
         * This was a dead char, overwriting any previously remembered
         * key. Calling ToAscii() again does not affect anything.
         */

        ToAscii(keycode, scancode, keys, (LPWORD) buf, 0);
        return XK_Multi_key;
    }
    if (result == 2) {
        /*
         * This was a dead char, and there were one previously remembered
         * by the keyboard.
         * Call ToAscii() again with proper parameters to restore it.
         */

        /* 
	 * Get information about the old char
	 */

        deadkey = VkKeyScan(buf[0]);
        shift = deadkey >> 8;
        deadkey &= 255;
        scancode = MapVirtualKey(deadkey, 0);

        /*
	 * Set up a keyboard with proper modifier keys
	 */

        memset(keys, 0, 256);
        if (shift & 1)
            keys[VK_SHIFT] = 0x80;
        if (shift & 2)
            keys[VK_CONTROL] = 0x80;
        if (shift & 4)
            keys[VK_MENU] = 0x80;
        ToAscii(deadkey, scancode, keys, (LPWORD) buf, 0);
        return XK_Multi_key;
    }

    /*
     * Keycode mapped to a valid Latin-1 character.  Since the keysyms
     * for alphanumeric characters map onto Latin-1, we just return it.
     *
     * We treat 0x7F as a special case mostly for backwards compatibility.
     * In versions of Tk<=8.2, Control-Backspace returned "XK_BackSpace"
     * as the X Keysym.  This was due to the fact that we did not
     * initialize the keys array properly when we passed it to ToAscii, above.
     * We had previously not been setting the state bit for the Control key.
     * When we fixed that, we found that Control-Backspace on Windows is
     * interpreted as ASCII-127 (0x7F), which corresponds to the Delete key.
     *
     * Upon discovering this, we realized we had two choices:  return XK_Delete
     * or return XK_BackSpace.  If we returned XK_Delete, that could be
     * considered "more correct" (although the correctness would be dependant
     * on whether you believe that ToAscii is doing the right thing in that
     * case); however, this would break backwards compatibility, and worse,
     * it would limit application programmers -- they would effectively be
     * unable to bind to <Control-Backspace> on Windows.  We therefore chose
     * instead to return XK_BackSpace (handled here by letting the code
     * "fall-through" to the return statement below, which works because the
     * keycode for this event is VK_BACKSPACE, and the keymap table maps that
     * keycode to XK_BackSpace).
     */

    if (result == 1 && UCHAR(buf[0]) >= 0x20 && UCHAR(buf[0]) != 0x7F) {
	return (KeySym) UCHAR(buf[0]);
    }

    /*
     * Keycode is a non-alphanumeric key, so we have to do the lookup.
     */

    skipToAscii:
    if (keycode < 0 || keycode > MAX_KEYCODE) {
	return NoSymbol;
    }
    switch (keycode) {
	/*
	 * Windows only gives us an undifferentiated VK_CONTROL
	 * code (for example) when either Control key is pressed.
	 * To distinguish between left and right, we have to query the
	 * state of one of the two to determine which was actually
	 * pressed.  So if the keycode indicates Control, Shift, or Menu
	 * (the key that everybody else calls Alt), do this extra test.
	 * If the right-side key was pressed, return the appropriate
	 * keycode.  Otherwise, we fall through and rely on the
	 * keymap table to hold the correct keysym value.
	 */
	case VK_CONTROL: {
	    if (GetKeyState(VK_RCONTROL) & 0x80) {
		return XK_Control_R;
	    }
	    break;
	}
	case VK_SHIFT: {
	    if (GetKeyState(VK_RSHIFT) & 0x80) {
		return XK_Shift_R;
	    }
	    break;
	}
	case VK_MENU: {
	    if (GetKeyState(VK_RMENU) & 0x80) {
		return XK_Alt_R;
	    }
	    break;
	}
    }
    return keymap[keycode];
}


/*
 *----------------------------------------------------------------------
 *
 * TkpGetKeySym --
 *
 *	Given an X KeyPress or KeyRelease event, map the
 *	keycode in the event into a KeySym.
 *
 * Results:
 *	The return value is the KeySym corresponding to
 *	eventPtr, or NoSymbol if no matching Keysym could be
 *	found.
 *
 * Side effects:
 *	In the first call for a given display, keycode-to-
 *	KeySym maps get loaded.
 *
 *----------------------------------------------------------------------
 */

KeySym
TkpGetKeySym(dispPtr, eventPtr)
    TkDisplay *dispPtr;		/* Display in which to map keycode. */
    XEvent *eventPtr;		/* Description of X event. */
{
    KeySym sym;
    int state = eventPtr->xkey.state;

    /*
     * Refresh the mapping information if it's stale
     */

    if (dispPtr->bindInfoStale) {
	TkpInitKeymapInfo(dispPtr);
    }

    sym = KeycodeToKeysym(eventPtr->xkey.keycode, state, 0);

    /*
     * Special handling: if this is a ctrl-alt or shifted key, and there
     * is no keysym defined, try without the modifiers.
     */

    if ((sym == NoSymbol) && ((state & ControlMask) || (state & Mod2Mask))) {
        state &=  ~(ControlMask | Mod2Mask);
        sym = KeycodeToKeysym(eventPtr->xkey.keycode, state, 0);
    }
    if ((sym == NoSymbol) && (state & ShiftMask)) {
        state &=  ~ShiftMask;
        sym = KeycodeToKeysym(eventPtr->xkey.keycode, state, 0);
    }
    return sym;
}

/*
 *--------------------------------------------------------------
 *
 * TkpInitKeymapInfo --
 *
 *	This procedure is invoked to scan keymap information
 *	to recompute stuff that's important for binding, such
 *	as the modifier key (if any) that corresponds to "mode
 *	switch".
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Keymap-related information in dispPtr is updated.
 *
 *--------------------------------------------------------------
 */

void
TkpInitKeymapInfo(dispPtr)
    TkDisplay *dispPtr;		/* Display for which to recompute keymap
				 * information. */
{
    XModifierKeymap *modMapPtr;
    KeyCode *codePtr;
    KeySym keysym;
    int count, i, j, max, arraySize;
#define KEYCODE_ARRAY_SIZE 20

    dispPtr->bindInfoStale = 0;
    modMapPtr = XGetModifierMapping(dispPtr->display);

    /*
     * Check the keycodes associated with the Lock modifier.  If
     * any of them is associated with the XK_Shift_Lock modifier,
     * then Lock has to be interpreted as Shift Lock, not Caps Lock.
     */

    dispPtr->lockUsage = LU_IGNORE;
    codePtr = modMapPtr->modifiermap + modMapPtr->max_keypermod*LockMapIndex;
    for (count = modMapPtr->max_keypermod; count > 0; count--, codePtr++) {
	if (*codePtr == 0) {
	    continue;
	}
	keysym = KeycodeToKeysym(*codePtr, 0, 1);
	if (keysym == XK_Shift_Lock) {
	    dispPtr->lockUsage = LU_SHIFT;
	    break;
	}
	if (keysym == XK_Caps_Lock) {
	    dispPtr->lockUsage = LU_CAPS;
	    break;
	}
    }

    /*
     * Look through the keycodes associated with modifiers to see if
     * the the "mode switch", "meta", or "alt" keysyms are associated
     * with any modifiers.  If so, remember their modifier mask bits.
     */

    dispPtr->modeModMask = 0;
    dispPtr->metaModMask = 0;
    dispPtr->altModMask = 0;
    codePtr = modMapPtr->modifiermap;
    max = 8*modMapPtr->max_keypermod;
    for (i = 0; i < max; i++, codePtr++) {
	if (*codePtr == 0) {
	    continue;
	}
	keysym = KeycodeToKeysym(*codePtr, 0, 1);
	if (keysym == XK_Mode_switch) {
	    dispPtr->modeModMask |= ShiftMask << (i/modMapPtr->max_keypermod);
	}
	if ((keysym == XK_Meta_L) || (keysym == XK_Meta_R)) {
	    dispPtr->metaModMask |= ShiftMask << (i/modMapPtr->max_keypermod);
	}
	if ((keysym == XK_Alt_L) || (keysym == XK_Alt_R)) {
	    dispPtr->altModMask |= ShiftMask << (i/modMapPtr->max_keypermod);
	}
    }

    /*
     * Create an array of the keycodes for all modifier keys.
     */

    if (dispPtr->modKeyCodes != NULL) {
	ckfree((char *) dispPtr->modKeyCodes);
    }
    dispPtr->numModKeyCodes = 0;
    arraySize = KEYCODE_ARRAY_SIZE;
    dispPtr->modKeyCodes = (KeyCode *) ckalloc((unsigned)
	    (KEYCODE_ARRAY_SIZE * sizeof(KeyCode)));
    for (i = 0, codePtr = modMapPtr->modifiermap; i < max; i++, codePtr++) {
	if (*codePtr == 0) {
	    continue;
	}

	/*
	 * Make sure that the keycode isn't already in the array.
	 */

	for (j = 0; j < dispPtr->numModKeyCodes; j++) {
	    if (dispPtr->modKeyCodes[j] == *codePtr) {
		goto nextModCode;
	    }
	}
	if (dispPtr->numModKeyCodes >= arraySize) {
	    KeyCode *new;

	    /*
	     * Ran out of space in the array;  grow it.
	     */

	    arraySize *= 2;
	    new = (KeyCode *) ckalloc((unsigned)
		    (arraySize * sizeof(KeyCode)));
	    memcpy((VOID *) new, (VOID *) dispPtr->modKeyCodes,
		    (dispPtr->numModKeyCodes * sizeof(KeyCode)));
	    ckfree((char *) dispPtr->modKeyCodes);
	    dispPtr->modKeyCodes = new;
	}
	dispPtr->modKeyCodes[dispPtr->numModKeyCodes] = *codePtr;
	dispPtr->numModKeyCodes++;
	nextModCode: continue;
    }
    XFreeModifiermap(modMapPtr);
}

/*
 * When mapping from a keysym to a keycode, need
 * information about the modifier state that should be used
 * so that when they call XKeycodeToKeysym taking into
 * account the xkey.state, they will get back the original
 * keysym.
 */

void
TkpSetKeycodeAndState(tkwin, keySym, eventPtr)
    Tk_Window tkwin;
    KeySym keySym;
    XEvent *eventPtr;
{
    int i;
    SHORT result;
    int shift;
    
    eventPtr->xkey.keycode = 0;
    if (keySym == NoSymbol) {
        return;
    }

    /*
     * We check our private map first for a virtual keycode,
     * as VkKeyScan will return values that don't map to X
     * for the "extended" Syms.  This may be due to just casting
     * problems below, but this works.
     */
    for (i = 0; i <= MAX_KEYCODE; i++) {
	if (keymap[i] == keySym) {
            eventPtr->xkey.keycode = i;
            return;
	}
    }
    if (keySym >= 0x20) {
	result = VkKeyScan((char) keySym);
	if (result != -1) {
            shift = result >> 8;
            if (shift & 1)
                eventPtr->xkey.state |= ShiftMask;
            if (shift & 2)
                eventPtr->xkey.state |= ControlMask;
            if (shift & 4)
                eventPtr->xkey.state |= Mod2Mask;
            eventPtr->xkey.keycode = (KeyCode) (result & 0xff);
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * XKeysymToKeycode --
 *
 *	Translate a keysym back into a keycode.
 *
 * Results:
 *	Returns the keycode that would generate the specified keysym.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

KeyCode
XKeysymToKeycode(display, keysym)
    Display* display;
    KeySym keysym;
{
    int i;
    SHORT result;

    /*
     * We check our private map first for a virtual keycode,
     * as VkKeyScan will return values that don't map to X
     * for the "extended" Syms.  This may be due to just casting
     * problems below, but this works.
     */
    if (keysym == NoSymbol) {
	return 0;
    }
    for (i = 0; i <= MAX_KEYCODE; i++) {
	if (keymap[i] == keysym) {
	    return ((KeyCode) i);
	}
    }
    if (keysym >= 0x20) {
	result = VkKeyScan((char) keysym);
	if (result != -1) {
	    return (KeyCode) (result & 0xff);
	}
    }

    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * XGetModifierMapping --
 *
 *	Fetch the current keycodes used as modifiers.
 *
 * Results:
 *	Returns a new modifier map.
 *
 * Side effects:
 *	Allocates a new modifier map data structure.
 *
 *----------------------------------------------------------------------
 */

XModifierKeymap	*
XGetModifierMapping(display)
    Display* display;
{
    XModifierKeymap *map = (XModifierKeymap *)ckalloc(sizeof(XModifierKeymap));

    map->max_keypermod = 1;
    map->modifiermap = (KeyCode *) ckalloc(sizeof(KeyCode)*8);
    map->modifiermap[ShiftMapIndex] = VK_SHIFT;
    map->modifiermap[LockMapIndex] = VK_CAPITAL;
    map->modifiermap[ControlMapIndex] = VK_CONTROL;
    map->modifiermap[Mod1MapIndex] = VK_NUMLOCK;
    map->modifiermap[Mod2MapIndex] = VK_MENU;
    map->modifiermap[Mod3MapIndex] = VK_SCROLL;
    map->modifiermap[Mod4MapIndex] = 0;
    map->modifiermap[Mod5MapIndex] = 0;
    return map;
}

/*
 *----------------------------------------------------------------------
 *
 * XFreeModifiermap --
 *
 *	Deallocate a modifier map that was created by
 *	XGetModifierMapping.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Frees the datastructure referenced by modmap.
 *
 *----------------------------------------------------------------------
 */

void
XFreeModifiermap(modmap)
    XModifierKeymap* modmap;
{
    ckfree((char *) modmap->modifiermap);
    ckfree((char *) modmap);
}

/*
 *----------------------------------------------------------------------
 *
 * XStringToKeysym --
 *
 *	Translate a keysym name to the matching keysym. 
 *
 * Results:
 *	Returns the keysym.  Since this is already handled by
 *	Tk's StringToKeysym function, we just return NoSymbol.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

KeySym
XStringToKeysym(string)
    _Xconst char *string;
{
    return NoSymbol;
}

/*
 *----------------------------------------------------------------------
 *
 * XKeysymToString --
 *
 *	Convert a keysym to character form.
 *
 * Results:
 *	Returns NULL, since Tk will have handled this already.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

char *
XKeysymToString(keysym)
    KeySym keysym;
{
    return NULL;
}
@


1.4
log
@touched all sources to ease next import
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tkWinKey.c,v 1.7.6.2 2000/09/26 16:10:02 spolk Exp $
d93 23
a115 1
    if (eventPtr->xkey.send_event != -1) {
a129 3
    } else if (eventPtr->xkey.nbytes > 0) {
	Tcl_ExternalToUtfDString(NULL, eventPtr->xkey.trans_chars,
		eventPtr->xkey.nbytes, dsPtr);
a586 8
    {
        /* Debug log */
        FILE *fp = fopen("c:\\temp\\tklog.txt", "a");
        if (fp != NULL) {
            fprintf(fp, "TkpSetKeycode. Keycode %d State %d Keysym %d\n", eventPtr->xkey.keycode, eventPtr->xkey.state, keySym);
            fclose(fp);
        }
    }
a742 2


@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* 
d12 1
a12 1
 * RCS: @@(#) $Id: tkWinKey.c,v 1.9 1999/01/26 04:11:44 jingham Exp $
d16 41
d58 2
a59 3
/* 
 * FIXME - these are in i386-cygwin32/includes/Windows32/Defines.h
 * but not in the current Progressive release...
d62 2
a63 77
#ifdef __CYGWIN32__
#define VK_LWIN (91)
#define VK_RWIN (92)
#define VK_APPS (93)
#endif

typedef struct {
    unsigned int keycode;
    KeySym keysym;
} Keys;

static Keys keymap[] = {
    VK_CANCEL, XK_Cancel,
    VK_BACK, XK_BackSpace,
    VK_TAB, XK_Tab,
    VK_CLEAR, XK_Clear,
    VK_RETURN, XK_Return,
    VK_SHIFT, XK_Shift_L,
    VK_CONTROL, XK_Control_L,
    VK_MENU, XK_Alt_L,
    VK_PAUSE, XK_Pause,
    VK_CAPITAL, XK_Caps_Lock,
    VK_ESCAPE, XK_Escape,
    VK_SPACE, XK_space,
    VK_PRIOR, XK_Prior,
    VK_NEXT, XK_Next,
    VK_END, XK_End,
    VK_HOME, XK_Home,
    VK_LEFT, XK_Left,
    VK_UP, XK_Up,
    VK_RIGHT, XK_Right,
    VK_DOWN, XK_Down,
    VK_SELECT, XK_Select,
    VK_PRINT, XK_Print,
    VK_EXECUTE, XK_Execute,
    VK_INSERT, XK_Insert,
    VK_DELETE, XK_Delete,
    VK_HELP, XK_Help,
    VK_F1, XK_F1,
    VK_F2, XK_F2,
    VK_F3, XK_F3,
    VK_F4, XK_F4,
    VK_F5, XK_F5,
    VK_F6, XK_F6,
    VK_F7, XK_F7,
    VK_F8, XK_F8,
    VK_F9, XK_F9,
    VK_F10, XK_F10,
    VK_F11, XK_F11,
    VK_F12, XK_F12,
    VK_F13, XK_F13,
    VK_F14, XK_F14,
    VK_F15, XK_F15,
    VK_F16, XK_F16,
    VK_F17, XK_F17,
    VK_F18, XK_F18,
    VK_F19, XK_F19,
    VK_F20, XK_F20,
    VK_F21, XK_F21,
    VK_F22, XK_F22,
    VK_F23, XK_F23,
    VK_F24, XK_F24,
    VK_NUMLOCK, XK_Num_Lock, 
    VK_SCROLL, XK_Scroll_Lock,

    /*
     * The following support the new keys in the Microsoft keyboard.
     * Win_L and Win_R have the windows logo.  App has the menu.
     */

    VK_LWIN, XK_Win_L,
    VK_RWIN, XK_Win_R,
    VK_APPS, XK_App,

    0, NoSymbol
};

d68 1
a68 1
 * XLookupString --
d70 1
a70 1
 *	Retrieve the string equivalent for the given keyboard event.
d73 1
a73 1
 *	Returns the number of characters stored in buffer_return.
d76 1
a76 2
 *	Retrieves the characters stored in the event and inserts them
 *	into buffer_return.
d81 7
a87 8
int
XLookupString(event_struct, buffer_return, bytes_buffer, keysym_return,
	status_in_out)
    XKeyEvent* event_struct;
    char* buffer_return;
    int bytes_buffer;
    KeySym* keysym_return;
    XComposeStatus* status_in_out;
d89 2
a90 1
    int i, limit;
d92 2
a93 1
    if (event_struct->send_event != -1) {
d99 2
a100 12
	int index;
	KeySym keysym;

	index = 0;
	if (event_struct->state & ShiftMask) {
	    index |= 1;
	}
	if (event_struct->state & Mod1Mask) {
	    index |= 2;
	}
	keysym = XKeycodeToKeysym(event_struct->display, 
		event_struct->keycode, index);
d104 3
a106 2
	    buffer_return[0] = (char) keysym;
	    return 1;
d108 3
a110 14
	return 0;
    }
    if ((event_struct->nchars <= 0) || (buffer_return == NULL)) {
	return 0;
    }
    limit = (event_struct->nchars < bytes_buffer) ? event_struct->nchars :
	bytes_buffer;

    for (i = 0; i < limit; i++) {
	buffer_return[i] = event_struct->trans_chars[i];
    }

    if (keysym_return != NULL) {
	*keysym_return = NoSymbol;
d112 1
a112 1
    return i;
d138 34
a171 1
    Keys* key;
d173 1
a173 1
    int result;
d177 21
d199 17
a215 1
    if (index & 0x02) {
d217 15
d233 29
a261 2
    if (index & 0x01) {
	keys[VK_SHIFT] = 0x80;
a262 1
    result = ToAscii(keycode, scancode, keys, (LPWORD) buf, 0);
d267 20
d289 2
a290 2
    if (result == 1 && buf[0] >= 0x20) {
	return (KeySym) buf[0];
d297 33
a329 3
    for (key = keymap; key->keycode != 0; key++) {
	if (key->keycode == keycode) {
	    return key->keysym;
d332 3
d336 240
a575 1
    return NoSymbol;
d599 1
a599 1
    Keys* key;
d602 14
a622 10
    /*
     * Couldn't map the character to a virtual keycode, so do a
     * table lookup.
     */

    for (key = keymap; key->keycode != 0; key++) {
	if (key->keysym == keysym) {
	    return key->keycode;
	}
    }
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d1 1
a1 1
/*
d12 1
a12 1
 * RCS: @@(#) $Id: tkWinKey.c,v 1.7.6.2 2000/09/26 16:10:02 spolk Exp $
d16 4
a19 7
/*
 * The keymap table holds mappings of Windows keycodes to X keysyms.
 * If Windows ever comes along and changes the value of their keycodes,
 * this will break all kinds of things.  However, this table lookup is much
 * faster than the alternative, in which we walked a list of keycodes looking
 * for a match.  Since this lookup is performed for every Windows keypress
 * event, it seems like a worthwhile improvement to use the table.
d21 76
a96 32
#define MAX_KEYCODE 145 /* VK_SCROLL is the last entry in our table below */
static KeySym keymap[] = {
    NoSymbol, NoSymbol, NoSymbol, XK_Cancel, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, XK_BackSpace, XK_Tab,
	NoSymbol, NoSymbol, XK_Clear, XK_Return, NoSymbol,
	NoSymbol, XK_Shift_L, XK_Control_L, XK_Alt_L, XK_Pause,
	XK_Caps_Lock, NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, XK_Escape, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, XK_space, XK_Prior, XK_Next,
	XK_End, XK_Home, XK_Left, XK_Up, XK_Right,
	XK_Down, XK_Select, XK_Print, XK_Execute, NoSymbol,
	XK_Insert, XK_Delete, XK_Help, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, XK_Win_L, XK_Win_R, XK_App, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, XK_F1, XK_F2, XK_F3,
	XK_F4, XK_F5, XK_F6, XK_F7, XK_F8,
	XK_F9, XK_F10, XK_F11, XK_F12, XK_F13,
	XK_F14, XK_F15, XK_F16, XK_F17, XK_F18,
	XK_F19,	XK_F20, XK_F21, XK_F22, XK_F23,
	XK_F24,	NoSymbol, NoSymbol, NoSymbol, NoSymbol,
	NoSymbol, NoSymbol, NoSymbol, NoSymbol, XK_Num_Lock,
	XK_Scroll_Lock
a98 6
/*
 * Prototypes for local procedures defined in this file:
 */

static KeySym		KeycodeToKeysym _ANSI_ARGS_((unsigned int keycode,
			    int state, int noascii));
d103 1
a103 1
 * TkpGetString --
d105 1
a105 1
 *	Retrieve the UTF string equivalent for the given keyboard event.
d108 1
a108 1
 *	Returns the UTF string.
d111 2
a112 1
 *	None.
d117 8
a124 7
char *
TkpGetString(winPtr, eventPtr, dsPtr)
    TkWindow *winPtr;		/* Window where event occurred:  needed to
				 * get input context. */
    XEvent *eventPtr;		/* X keyboard event. */
    Tcl_DString *dsPtr;		/* Uninitialized or empty string to hold
				 * result. */
d126 1
a126 2
    KeySym keysym;
    XKeyEvent* keyEv = &eventPtr->xkey;
d128 1
a128 2
    Tcl_DStringInit(dsPtr);
    if (eventPtr->xkey.send_event != -1) {
d134 12
a145 2
	keysym = KeycodeToKeysym(eventPtr->xkey.keycode,
		eventPtr->xkey.state, 0);
d149 2
a150 3
	    char buf[TCL_UTF_MAX];
	    int len = Tcl_UniCharToUtf((Tcl_UniChar) (keysym & 255), buf);
	    Tcl_DStringAppend(dsPtr, buf, len);
d152 14
a165 3
    } else if (eventPtr->xkey.nbytes > 0) {
	Tcl_ExternalToUtfDString(NULL, eventPtr->xkey.trans_chars,
		eventPtr->xkey.nbytes, dsPtr);
d167 1
a167 1
    return Tcl_DStringValue(dsPtr);
d193 1
a193 34
    int state = 0;

    if (index & 0x01) {
	state |= ShiftMask;
    }
    return KeycodeToKeysym(keycode, state, 0);
}



/*
 *----------------------------------------------------------------------
 *
 * KeycodeToKeysym --
 *
 *	Translate from a system-dependent keycode to a
 *	system-independent keysym.
 *
 * Results:
 *	Returns the translated keysym, or NoSymbol on failure.
 *
 * Side effects:
 *	It may affect the internal state of the keyboard, such as
 *      remembered dead key or lock indicator lamps.
 *
 *----------------------------------------------------------------------
 */

static KeySym
KeycodeToKeysym(keycode, state, noascii)
    unsigned int keycode;
    int state;
    int noascii;
{
d195 1
a195 1
    int result, deadkey, shift;
a198 21
    /*
     * Do not run keycodes of lock keys through ToAscii().
     * One of ToAscii()'s side effects is to handle the lights
     * on the keyboard, and we don't want to mess that up.
     */

    if (noascii || keycode == VK_CAPITAL || keycode == VK_SCROLL ||
	    keycode == VK_NUMLOCK)
        goto skipToAscii;

    /*
     * Use MapVirtualKey() to detect some dead keys.
     */

    if (MapVirtualKey(keycode, 2) > 0x7fffUL)
        return XK_Multi_key;

    /*
     * Set up a keyboard with correct modifiers
     */

d200 1
a200 17
    if (state & ShiftMask)
        keys[VK_SHIFT] = 0x80;
    if (state & ControlMask)
	keys[VK_CONTROL] = 0x80;
    if (state & Mod2Mask)
	keys[VK_MENU] = 0x80;

    /* 
     * Make sure all lock button info is correct so we don't mess up the
     * lights
     */

    if (state & LockMask)
	keys[VK_CAPITAL] = 1;
    if (state & Mod3Mask)
	keys[VK_SCROLL] = 1;
    if (state & Mod1Mask)
a201 15

    result = ToAscii(keycode, scancode, keys, (LPWORD) buf, 0);

    if (result < 0) {
        /*
         * Win95/98:
         * This was a dead char, which is now remembered by the keyboard.
         * Call ToAscii() again to forget it.
         * WinNT:
         * This was a dead char, overwriting any previously remembered
         * key. Calling ToAscii() again does not affect anything.
         */

        ToAscii(keycode, scancode, keys, (LPWORD) buf, 0);
        return XK_Multi_key;
d203 2
a204 29
    if (result == 2) {
        /*
         * This was a dead char, and there were one previously remembered
         * by the keyboard.
         * Call ToAscii() again with proper parameters to restore it.
         */

        /* 
	 * Get information about the old char
	 */

        deadkey = VkKeyScan(buf[0]);
        shift = deadkey >> 8;
        deadkey &= 255;
        scancode = MapVirtualKey(deadkey, 0);

        /*
	 * Set up a keyboard with proper modifier keys
	 */

        memset(keys, 0, 256);
        if (shift & 1)
            keys[VK_SHIFT] = 0x80;
        if (shift & 2)
            keys[VK_CONTROL] = 0x80;
        if (shift & 4)
            keys[VK_MENU] = 0x80;
        ToAscii(deadkey, scancode, keys, (LPWORD) buf, 0);
        return XK_Multi_key;
d206 1
a210 20
     *
     * We treat 0x7F as a special case mostly for backwards compatibility.
     * In versions of Tk<=8.2, Control-Backspace returned "XK_BackSpace"
     * as the X Keysym.  This was due to the fact that we did not
     * initialize the keys array properly when we passed it to ToAscii, above.
     * We had previously not been setting the state bit for the Control key.
     * When we fixed that, we found that Control-Backspace on Windows is
     * interpreted as ASCII-127 (0x7F), which corresponds to the Delete key.
     *
     * Upon discovering this, we realized we had two choices:  return XK_Delete
     * or return XK_BackSpace.  If we returned XK_Delete, that could be
     * considered "more correct" (although the correctness would be dependant
     * on whether you believe that ToAscii is doing the right thing in that
     * case); however, this would break backwards compatibility, and worse,
     * it would limit application programmers -- they would effectively be
     * unable to bind to <Control-Backspace> on Windows.  We therefore chose
     * instead to return XK_BackSpace (handled here by letting the code
     * "fall-through" to the return statement below, which works because the
     * keycode for this event is VK_BACKSPACE, and the keymap table maps that
     * keycode to XK_BackSpace).
d213 2
a214 2
    if (result == 1 && UCHAR(buf[0]) >= 0x20 && UCHAR(buf[0]) != 0x7F) {
	return (KeySym) UCHAR(buf[0]);
d221 3
a223 33
    skipToAscii:
    if (keycode < 0 || keycode > MAX_KEYCODE) {
	return NoSymbol;
    }
    switch (keycode) {
	/*
	 * Windows only gives us an undifferentiated VK_CONTROL
	 * code (for example) when either Control key is pressed.
	 * To distinguish between left and right, we have to query the
	 * state of one of the two to determine which was actually
	 * pressed.  So if the keycode indicates Control, Shift, or Menu
	 * (the key that everybody else calls Alt), do this extra test.
	 * If the right-side key was pressed, return the appropriate
	 * keycode.  Otherwise, we fall through and rely on the
	 * keymap table to hold the correct keysym value.
	 */
	case VK_CONTROL: {
	    if (GetKeyState(VK_RCONTROL) & 0x80) {
		return XK_Control_R;
	    }
	    break;
	}
	case VK_SHIFT: {
	    if (GetKeyState(VK_RSHIFT) & 0x80) {
		return XK_Shift_R;
	    }
	    break;
	}
	case VK_MENU: {
	    if (GetKeyState(VK_RMENU) & 0x80) {
		return XK_Alt_R;
	    }
	    break;
a225 3
    return keymap[keycode];
}

d227 1
a227 240
/*
 *----------------------------------------------------------------------
 *
 * TkpGetKeySym --
 *
 *	Given an X KeyPress or KeyRelease event, map the
 *	keycode in the event into a KeySym.
 *
 * Results:
 *	The return value is the KeySym corresponding to
 *	eventPtr, or NoSymbol if no matching Keysym could be
 *	found.
 *
 * Side effects:
 *	In the first call for a given display, keycode-to-
 *	KeySym maps get loaded.
 *
 *----------------------------------------------------------------------
 */

KeySym
TkpGetKeySym(dispPtr, eventPtr)
    TkDisplay *dispPtr;		/* Display in which to map keycode. */
    XEvent *eventPtr;		/* Description of X event. */
{
    KeySym sym;
    int state = eventPtr->xkey.state;

    /*
     * Refresh the mapping information if it's stale
     */

    if (dispPtr->bindInfoStale) {
	TkpInitKeymapInfo(dispPtr);
    }

    sym = KeycodeToKeysym(eventPtr->xkey.keycode, state, 0);

    /*
     * Special handling: if this is a ctrl-alt or shifted key, and there
     * is no keysym defined, try without the modifiers.
     */

    if ((sym == NoSymbol) && ((state & ControlMask) || (state & Mod2Mask))) {
        state &=  ~(ControlMask | Mod2Mask);
        sym = KeycodeToKeysym(eventPtr->xkey.keycode, state, 0);
    }
    if ((sym == NoSymbol) && (state & ShiftMask)) {
        state &=  ~ShiftMask;
        sym = KeycodeToKeysym(eventPtr->xkey.keycode, state, 0);
    }
    return sym;
}

/*
 *--------------------------------------------------------------
 *
 * TkpInitKeymapInfo --
 *
 *	This procedure is invoked to scan keymap information
 *	to recompute stuff that's important for binding, such
 *	as the modifier key (if any) that corresponds to "mode
 *	switch".
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Keymap-related information in dispPtr is updated.
 *
 *--------------------------------------------------------------
 */

void
TkpInitKeymapInfo(dispPtr)
    TkDisplay *dispPtr;		/* Display for which to recompute keymap
				 * information. */
{
    XModifierKeymap *modMapPtr;
    KeyCode *codePtr;
    KeySym keysym;
    int count, i, j, max, arraySize;
#define KEYCODE_ARRAY_SIZE 20

    dispPtr->bindInfoStale = 0;
    modMapPtr = XGetModifierMapping(dispPtr->display);

    /*
     * Check the keycodes associated with the Lock modifier.  If
     * any of them is associated with the XK_Shift_Lock modifier,
     * then Lock has to be interpreted as Shift Lock, not Caps Lock.
     */

    dispPtr->lockUsage = LU_IGNORE;
    codePtr = modMapPtr->modifiermap + modMapPtr->max_keypermod*LockMapIndex;
    for (count = modMapPtr->max_keypermod; count > 0; count--, codePtr++) {
	if (*codePtr == 0) {
	    continue;
	}
	keysym = KeycodeToKeysym(*codePtr, 0, 1);
	if (keysym == XK_Shift_Lock) {
	    dispPtr->lockUsage = LU_SHIFT;
	    break;
	}
	if (keysym == XK_Caps_Lock) {
	    dispPtr->lockUsage = LU_CAPS;
	    break;
	}
    }

    /*
     * Look through the keycodes associated with modifiers to see if
     * the the "mode switch", "meta", or "alt" keysyms are associated
     * with any modifiers.  If so, remember their modifier mask bits.
     */

    dispPtr->modeModMask = 0;
    dispPtr->metaModMask = 0;
    dispPtr->altModMask = 0;
    codePtr = modMapPtr->modifiermap;
    max = 8*modMapPtr->max_keypermod;
    for (i = 0; i < max; i++, codePtr++) {
	if (*codePtr == 0) {
	    continue;
	}
	keysym = KeycodeToKeysym(*codePtr, 0, 1);
	if (keysym == XK_Mode_switch) {
	    dispPtr->modeModMask |= ShiftMask << (i/modMapPtr->max_keypermod);
	}
	if ((keysym == XK_Meta_L) || (keysym == XK_Meta_R)) {
	    dispPtr->metaModMask |= ShiftMask << (i/modMapPtr->max_keypermod);
	}
	if ((keysym == XK_Alt_L) || (keysym == XK_Alt_R)) {
	    dispPtr->altModMask |= ShiftMask << (i/modMapPtr->max_keypermod);
	}
    }

    /*
     * Create an array of the keycodes for all modifier keys.
     */

    if (dispPtr->modKeyCodes != NULL) {
	ckfree((char *) dispPtr->modKeyCodes);
    }
    dispPtr->numModKeyCodes = 0;
    arraySize = KEYCODE_ARRAY_SIZE;
    dispPtr->modKeyCodes = (KeyCode *) ckalloc((unsigned)
	    (KEYCODE_ARRAY_SIZE * sizeof(KeyCode)));
    for (i = 0, codePtr = modMapPtr->modifiermap; i < max; i++, codePtr++) {
	if (*codePtr == 0) {
	    continue;
	}

	/*
	 * Make sure that the keycode isn't already in the array.
	 */

	for (j = 0; j < dispPtr->numModKeyCodes; j++) {
	    if (dispPtr->modKeyCodes[j] == *codePtr) {
		goto nextModCode;
	    }
	}
	if (dispPtr->numModKeyCodes >= arraySize) {
	    KeyCode *new;

	    /*
	     * Ran out of space in the array;  grow it.
	     */

	    arraySize *= 2;
	    new = (KeyCode *) ckalloc((unsigned)
		    (arraySize * sizeof(KeyCode)));
	    memcpy((VOID *) new, (VOID *) dispPtr->modKeyCodes,
		    (dispPtr->numModKeyCodes * sizeof(KeyCode)));
	    ckfree((char *) dispPtr->modKeyCodes);
	    dispPtr->modKeyCodes = new;
	}
	dispPtr->modKeyCodes[dispPtr->numModKeyCodes] = *codePtr;
	dispPtr->numModKeyCodes++;
	nextModCode: continue;
    }
    XFreeModifiermap(modMapPtr);
}

/*
 * When mapping from a keysym to a keycode, need
 * information about the modifier state that should be used
 * so that when they call XKeycodeToKeysym taking into
 * account the xkey.state, they will get back the original
 * keysym.
 */

void
TkpSetKeycodeAndState(tkwin, keySym, eventPtr)
    Tk_Window tkwin;
    KeySym keySym;
    XEvent *eventPtr;
{
    int i;
    SHORT result;
    int shift;
    
    eventPtr->xkey.keycode = 0;
    if (keySym == NoSymbol) {
        return;
    }

    /*
     * We check our private map first for a virtual keycode,
     * as VkKeyScan will return values that don't map to X
     * for the "extended" Syms.  This may be due to just casting
     * problems below, but this works.
     */
    for (i = 0; i <= MAX_KEYCODE; i++) {
	if (keymap[i] == keySym) {
            eventPtr->xkey.keycode = i;
            return;
	}
    }
    if (keySym >= 0x20) {
	result = VkKeyScan((char) keySym);
	if (result != -1) {
            shift = result >> 8;
            if (shift & 1)
                eventPtr->xkey.state |= ShiftMask;
            if (shift & 2)
                eventPtr->xkey.state |= ControlMask;
            if (shift & 4)
                eventPtr->xkey.state |= Mod2Mask;
            eventPtr->xkey.keycode = (KeyCode) (result & 0xff);
	}
    }
    {
        /* Debug log */
        FILE *fp = fopen("c:\\temp\\tklog.txt", "a");
        if (fp != NULL) {
            fprintf(fp, "TkpSetKeycode. Keycode %d State %d Keysym %d\n", eventPtr->xkey.keycode, eventPtr->xkey.state, keySym);
            fclose(fp);
        }
    }
d251 1
a251 1
    int i;
a253 14
    /*
     * We check our private map first for a virtual keycode,
     * as VkKeyScan will return values that don't map to X
     * for the "extended" Syms.  This may be due to just casting
     * problems below, but this works.
     */
    if (keysym == NoSymbol) {
	return 0;
    }
    for (i = 0; i <= MAX_KEYCODE; i++) {
	if (keymap[i] == keysym) {
	    return ((KeyCode) i);
	}
    }
d261 10
@


1.1.1.3
log
@import tk 8.4.0
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tkWinKey.c,v 1.14 2001/05/30 22:41:11 hobbs Exp $
d93 1
a93 23
    if (eventPtr->xkey.send_event == -1) {
        if (eventPtr->xkey.nbytes > 0) {
	    Tcl_ExternalToUtfDString(TkWinGetKeyInputEncoding(),
                    eventPtr->xkey.trans_chars, eventPtr->xkey.nbytes, dsPtr);
        }
    } else if (eventPtr->xkey.send_event == -2) {
        /*
         * Special case for win2000 multi-lingal IME input. 
         * xkey.trans_chars[] already contains a UNICODE char.
         */

        int unichar;
        char buf[TCL_UTF_MAX];
        int len;

        unichar = (eventPtr->xkey.trans_chars[1] & 0xff);
        unichar <<= 8;
        unichar |= (eventPtr->xkey.trans_chars[0] & 0xff);

        len = Tcl_UniCharToUtf((Tcl_UniChar) unichar, buf);

        Tcl_DStringAppend(dsPtr, buf, len);
    } else  {
d108 3
d568 8
d732 2
@


