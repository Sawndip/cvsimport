head	1.6;
access;
symbols
	sid-snapshot-20180601:1.6
	sid-snapshot-20180501:1.6
	sid-snapshot-20180401:1.6
	sid-snapshot-20180301:1.6
	sid-snapshot-20180201:1.6
	sid-snapshot-20180101:1.6
	sid-snapshot-20171201:1.6
	sid-snapshot-20171101:1.6
	sid-snapshot-20171001:1.6
	sid-snapshot-20170901:1.6
	sid-snapshot-20170801:1.6
	sid-snapshot-20170701:1.6
	sid-snapshot-20170601:1.6
	sid-snapshot-20170501:1.6
	sid-snapshot-20170401:1.6
	sid-snapshot-20170301:1.6
	sid-snapshot-20170201:1.6
	sid-snapshot-20170101:1.6
	sid-snapshot-20161201:1.6
	sid-snapshot-20161101:1.6
	sid-snapshot-20160901:1.6
	sid-snapshot-20160801:1.6
	sid-snapshot-20160701:1.6
	sid-snapshot-20160601:1.6
	sid-snapshot-20160501:1.6
	sid-snapshot-20160401:1.6
	sid-snapshot-20160301:1.6
	sid-snapshot-20160201:1.6
	sid-snapshot-20160101:1.6
	sid-snapshot-20151201:1.6
	sid-snapshot-20151101:1.6
	sid-snapshot-20151001:1.6
	sid-snapshot-20150901:1.6
	sid-snapshot-20150801:1.6
	sid-snapshot-20150701:1.6
	sid-snapshot-20150601:1.6
	sid-snapshot-20150501:1.6
	sid-snapshot-20150401:1.6
	sid-snapshot-20150301:1.6
	sid-snapshot-20150201:1.6
	sid-snapshot-20150101:1.6
	sid-snapshot-20141201:1.6
	sid-snapshot-20141101:1.6
	sid-snapshot-20141001:1.6
	sid-snapshot-20140901:1.6
	sid-snapshot-20140801:1.6
	sid-snapshot-20140701:1.6
	sid-snapshot-20140601:1.6
	sid-snapshot-20140501:1.6
	sid-snapshot-20140401:1.6
	sid-snapshot-20140301:1.6
	sid-snapshot-20140201:1.6
	sid-snapshot-20140101:1.6
	sid-snapshot-20131201:1.6
	sid-snapshot-20131101:1.6
	sid-snapshot-20131001:1.6
	sid-snapshot-20130901:1.6
	sid-snapshot-20130801:1.6
	sid-snapshot-20130701:1.6
	sid-snapshot-20130601:1.6
	insight_7_6-2013-04-10-branchpoint:1.6
	gdb_7_6-branch:1.6.0.28
	sid-snapshot-20130501:1.6
	sid-snapshot-20130401:1.6
	sid-snapshot-20130301:1.6
	sid-snapshot-20130201:1.6
	sid-snapshot-20130101:1.6
	sid-snapshot-20121201:1.6
	sid-snapshot-20121101:1.6
	sid-snapshot-20121001:1.6
	sid-snapshot-20120901:1.6
	gdb_7_5-branch:1.6.0.26
	sid-snapshot-20120801:1.6
	sid-snapshot-20120701:1.6
	sid-snapshot-20120601:1.6
	sid-snapshot-20120501:1.6
	sid-snapshot-20120401:1.6
	gdb_7_4-branch:1.6.0.24
	sid-snapshot-20120301:1.6
	sid-snapshot-20120201:1.6
	sid-snapshot-20120101:1.6
	sid-snapshot-20111201:1.6
	sid-snapshot-20111101:1.6
	sid-snapshot-20111001:1.6
	sid-snapshot-20110901:1.6
	gdb_7_3-branch:1.6.0.22
	sid-snapshot-20110801:1.6
	sid-snapshot-20110701:1.6
	sid-snapshot-20110601:1.6
	sid-snapshot-20110501:1.6
	sid-snapshot-20110401:1.6
	sid-snapshot-20110301:1.6
	sid-snapshot-20110201:1.6
	sid-snapshot-20110101:1.6
	sid-snapshot-20101201:1.6
	sid-snapshot-20101101:1.6
	sid-snapshot-20101001:1.6
	sid-snapshot-20100901:1.6
	sid-snapshot-20100801:1.6
	sid-snapshot-20100701:1.6
	sid-snapshot-20100601:1.6
	sid-snapshot-20100501:1.6
	sid-snapshot-20100401:1.6
	sid-snapshot-20100301:1.6
	gdb_7_1-branch:1.6.0.20
	gdb_7_0-branch:1.6.0.18
	sid-snapshot-20100201:1.6
	sid-snapshot-20100101:1.6
	sid-snapshot-20091201:1.6
	sid-snapshot-20091101:1.6
	sid-snapshot-20091001:1.6
	arc-sim-20090309:1.6
	sid-snapshot-20090901:1.6
	sid-snapshot-20090801:1.6
	sid-snapshot-20090701:1.6
	sid-snapshot-20090601:1.6
	sid-snapshot-20090501:1.6
	kevinb-pre-tk8_5_7_merge:1.6
	sid-snapshot-20090401:1.6
	arc-insight_6_8-branch:1.6.0.16
	arc-insight_6_8-branchpoint:1.6
	insight_6_8-branch:1.6.0.14
	insight_6_8-branchpoint:1.6
	sid-snapshot-20090301:1.6
	sid-snapshot-20090201:1.6
	sid-snapshot-20090101:1.6
	sid-snapshot-20081201:1.6
	sid-snapshot-20081101:1.6
	sid-snapshot-20081001:1.6
	sid-snapshot-20080901:1.6
	sid-snapshot-20080801:1.6
	sid-snapshot-20080701:1.6
	sid-snapshot-20080601:1.6
	sid-snapshot-20080501:1.6
	sid-snapshot-20080403:1.6
	sid-snapshot-20080401:1.6
	gdb_6_8-branch:1.6.0.12
	sid-snapshot-20080301:1.6
	sid-snapshot-20080201:1.6
	sid-snapshot-20080101:1.6
	sid-snapshot-20071201:1.6
	sid-snapshot-20071101:1.6
	sid-snapshot-20071001:1.6
	insight_6_6-20070208-release:1.6
	gdb_6_6-branch:1.6.0.10
	gdb_6_6-2006-11-15-branchpoint:1.6
	insight_6_5-20061003-release:1.6
	gdb_6_5-branch:1.6.0.8
	gdb_6_5-2006-05-14-branchpoint:1.6
	gdb_6_4-branch:1.6.0.6
	gdb_6_4-2005-11-01-branchpoint:1.6
	gdb_6_1-2004-04-05-release:1.6
	gdb_6_1-branch:1.6.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	gdb_6_0-2003-10-04-release:1.6
	gdb_6_0-branch:1.6.0.2
	gdb_6_0-2003-06-23-branchpoint:1.6
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.3
	tcltk840-20020924-branch:1.4.0.2
	tcltk840-20020924-branchpoint:1.4
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.3
	sid-20020905-branch:1.3.0.6
	gdb_5_3-branch:1.3.0.4
	gdb_5_3-2002-09-04-branchpoint:1.3
	gdb_5_2_1-2002-07-23-release:1.3
	gdb_5_2-2002-04-29-release:1.3
	gdb_5_2-branch:1.3.0.2
	gdb_5_2-2002-03-03-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.6
date	2003.01.21.20.24.53;	author hunt;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.21.19.53.17;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.24.18.39.30;	author kseitz;	state Exp;
branches;
next	1.3;

1.3
date	2001.10.16.05.58.44;	author irox;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.55;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.38;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.27;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Updated to tk 8.4.1
@
text
@/* 
 * tkWinButton.c --
 *
 *	This file implements the Windows specific portion of the button
 *	widgets.
 *
 * Copyright (c) 1996-1998 by Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkWinButton.c,v 1.20 2002/09/03 01:05:11 hobbs Exp $
 */

#define OEMRESOURCE
#include "tkWinInt.h"
#include "tkButton.h"

/*
 * These macros define the base style flags for the different button types.
 */

#define LABEL_STYLE (BS_OWNERDRAW | WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS)
#define PUSH_STYLE (BS_OWNERDRAW | BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS)
#define CHECK_STYLE (BS_OWNERDRAW | BS_CHECKBOX | WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS)
#define RADIO_STYLE (BS_OWNERDRAW | BS_RADIOBUTTON | WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS)

/*
 * Declaration of Windows specific button structure.
 */

typedef struct WinButton {
    TkButton info;		/* Generic button info. */
    WNDPROC oldProc;		/* Old window procedure. */
    HWND hwnd;			/* Current window handle. */
    Pixmap pixmap;		/* Bitmap for rendering the button. */
    DWORD style;		/* Window style flags. */
} WinButton;


/*
 * The following macro reverses the order of RGB bytes to convert
 * between RGBQUAD and COLORREF values.
 */

#define FlipColor(rgb) (RGB(GetBValue(rgb),GetGValue(rgb),GetRValue(rgb)))

/*
 * The following enumeration defines the meaning of the palette entries
 * in the "buttons" image used to draw checkbox and radiobutton indicators.
 */

enum {
    PAL_CHECK = 0,
    PAL_TOP_OUTER = 1,
    PAL_BOTTOM_OUTER = 2,
    PAL_BOTTOM_INNER = 3,
    PAL_INTERIOR = 4,
    PAL_TOP_INNER = 5,
    PAL_BACKGROUND = 6
};

/*
 * Cached information about the boxes bitmap, and the default border 
 * width for a button in string form for use in Tk_OptionSpec for 
 * the various button widget classes.
 */

typedef struct ThreadSpecificData { 
    BITMAPINFOHEADER *boxesPtr;   /* Information about the bitmap. */
    DWORD *boxesPalette;	  /* Pointer to color palette. */
    LPSTR boxesBits;		  /* Pointer to bitmap data. */
    DWORD boxHeight;              /* Height of each sub-image. */
    DWORD boxWidth ;              /* Width of each sub-image. */
    char defWidth[TCL_INTEGER_SPACE];
} ThreadSpecificData;
static Tcl_ThreadDataKey dataKey;

/*
 * Declarations for functions defined in this file.
 */
static LRESULT CALLBACK	ButtonProc _ANSI_ARGS_((HWND hwnd, UINT message,
			    WPARAM wParam, LPARAM lParam));
static Window		CreateProc _ANSI_ARGS_((Tk_Window tkwin,
			    Window parent, ClientData instanceData));
static void		InitBoxes _ANSI_ARGS_((void));

/*
 * The class procedure table for the button widgets.
 */

Tk_ClassProcs tkpButtonProcs = { 
    sizeof(Tk_ClassProcs),	/* size */
    TkButtonWorldChanged,	/* worldChangedProc */
    CreateProc,			/* createProc */
};


/*
 *----------------------------------------------------------------------
 *
 * InitBoxes --
 *
 *	This function load the Tk 3d button bitmap.  "buttons" is a 16 
 *	color bitmap that is laid out such that the top row contains 
 *	the 4 checkbox images, and the bottom row contains the radio 
 *	button images. Note that the bitmap is stored in bottom-up 
 *	format.  Also, the first seven palette entries are used to 
 *	identify the different parts of the bitmaps so we can do the 
 *	appropriate color mappings based on the current button colors.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Loads the "buttons" resource.
 *
 *----------------------------------------------------------------------
 */

static void
InitBoxes()
{
    /*
     * For DLLs like Tk, the HINSTANCE is the same as the HMODULE.
     */

    HMODULE module = (HINSTANCE) Tk_GetHINSTANCE();
    HRSRC hrsrc;
    HGLOBAL hblk;
    LPBITMAPINFOHEADER newBitmap;
    DWORD size;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    hrsrc = FindResource(module, "buttons", RT_BITMAP);
    if (hrsrc) {
	hblk = LoadResource(module, hrsrc);
	tsdPtr->boxesPtr = (LPBITMAPINFOHEADER)LockResource(hblk);
    }

    /*
     * Copy the DIBitmap into writable memory.
     */

    if (tsdPtr->boxesPtr != NULL && !(tsdPtr->boxesPtr->biWidth % 4)
	    && !(tsdPtr->boxesPtr->biHeight % 2)) {
	size = tsdPtr->boxesPtr->biSize + (1 << tsdPtr->boxesPtr->biBitCount) 
                * sizeof(RGBQUAD) + tsdPtr->boxesPtr->biSizeImage;
	newBitmap = (LPBITMAPINFOHEADER) ckalloc(size);
	memcpy(newBitmap, tsdPtr->boxesPtr, size);
	tsdPtr->boxesPtr = newBitmap;
	tsdPtr->boxWidth = tsdPtr->boxesPtr->biWidth / 4;
	tsdPtr->boxHeight = tsdPtr->boxesPtr->biHeight / 2;
	tsdPtr->boxesPalette = (DWORD*) (((LPSTR) tsdPtr->boxesPtr) 
                + tsdPtr->boxesPtr->biSize);
	tsdPtr->boxesBits = ((LPSTR) tsdPtr->boxesPalette)
	    + ((1 << tsdPtr->boxesPtr->biBitCount) * sizeof(RGBQUAD));
    } else {
	tsdPtr->boxesPtr = NULL;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkpButtonSetDefaults --
 *
 *	This procedure is invoked before option tables are created for
 *	buttons.  It modifies some of the default values to match the
 *	current values defined for this platform.
 *
 * Results:
 *	Some of the default values in *specPtr are modified.
 *
 * Side effects:
 *	Updates some of.
 *
 *----------------------------------------------------------------------
 */

void
TkpButtonSetDefaults(specPtr)
    Tk_OptionSpec *specPtr;	/* Points to an array of option specs,
				 * terminated by one with type
				 * TK_OPTION_END. */
{
    int width;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    if (tsdPtr->defWidth[0] == 0) {
	width = GetSystemMetrics(SM_CXEDGE);
	if (width == 0) {
	    width = 1;
	}
	sprintf(tsdPtr->defWidth, "%d", width);
    }
    for ( ; specPtr->type != TK_OPTION_END; specPtr++) {
	if (specPtr->internalOffset == Tk_Offset(TkButton, borderWidth)) {
	    specPtr->defValue = tsdPtr->defWidth;
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkpCreateButton --
 *
 *	Allocate a new TkButton structure.
 *
 * Results:
 *	Returns a newly allocated TkButton structure.
 *
 * Side effects:
 *	Registers an event handler for the widget.
 *
 *----------------------------------------------------------------------
 */

TkButton *
TkpCreateButton(tkwin)
    Tk_Window tkwin;
{
    WinButton *butPtr;

    butPtr = (WinButton *)ckalloc(sizeof(WinButton));
    butPtr->hwnd = NULL;
    return (TkButton *) butPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * CreateProc --
 *
 *	This function creates a new Button control, subclasses
 *	the instance, and generates a new Window object.
 *
 * Results:
 *	Returns the newly allocated Window object, or None on failure.
 *
 * Side effects:
 *	Causes a new Button control to come into existence.
 *
 *----------------------------------------------------------------------
 */

static Window
CreateProc(tkwin, parentWin, instanceData)
    Tk_Window tkwin;		/* Token for window. */
    Window parentWin;		/* Parent of new window. */
    ClientData instanceData;	/* Button instance data. */
{
    Window window;
    HWND parent;
    char *class;
    WinButton *butPtr = (WinButton *)instanceData;

    parent = Tk_GetHWND(parentWin);
    if (butPtr->info.type == TYPE_LABEL) {
	class = "STATIC";
	butPtr->style = SS_OWNERDRAW | WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS;
    } else {
	class = "BUTTON";
	butPtr->style = BS_OWNERDRAW | WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS;
    }
    butPtr->hwnd = CreateWindow(class, NULL, butPtr->style,
	    Tk_X(tkwin), Tk_Y(tkwin), Tk_Width(tkwin), Tk_Height(tkwin),
	    parent, NULL, Tk_GetHINSTANCE(), NULL);
    SetWindowPos(butPtr->hwnd, HWND_TOP, 0, 0, 0, 0,
		    SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
#ifdef _WIN64
    butPtr->oldProc = (WNDPROC)SetWindowLongPtr(butPtr->hwnd, GWLP_WNDPROC,
	    (LONG_PTR) ButtonProc);
#else
    butPtr->oldProc = (WNDPROC)SetWindowLong(butPtr->hwnd, GWL_WNDPROC,
	    (DWORD) ButtonProc);
#endif

    window = Tk_AttachHWND(tkwin, butPtr->hwnd);
    return window;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpDestroyButton --
 *
 *	Free data structures associated with the button control.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Restores the default control state.
 *
 *----------------------------------------------------------------------
 */

void
TkpDestroyButton(butPtr)
    TkButton *butPtr;
{
    WinButton *winButPtr = (WinButton *)butPtr;
    HWND hwnd = winButPtr->hwnd;
    if (hwnd) {
#ifdef _WIN64
	SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) winButPtr->oldProc);
#else
	SetWindowLong(hwnd, GWL_WNDPROC, (DWORD) winButPtr->oldProc);
#endif
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkpDisplayButton --
 *
 *	This procedure is invoked to display a button widget.  It is
 *	normally invoked as an idle handler.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Information appears on the screen.  The REDRAW_PENDING flag
 *	is cleared.
 *
 *----------------------------------------------------------------------
 */

void
TkpDisplayButton(clientData)
    ClientData clientData;	/* Information about widget. */
{
    TkWinDCState state;
    HDC dc;
    register TkButton *butPtr = (TkButton *) clientData;
    GC gc;
    Tk_3DBorder border;
    Pixmap pixmap;
    int x = 0;			/* Initialization only needed to stop
				 * compiler warning. */
    int y, relief;
    register Tk_Window tkwin = butPtr->tkwin;
    int width, height, haveImage = 0, haveText = 0, drawRing = 0;
    RECT rect;
    int defaultWidth;		/* Width of default ring. */
    int offset;			/* 0 means this is a label widget.  1 means
				 * it is a flavor of button, so we offset
				 * the text to make the button appear to
				 * move up and down as the relief changes. */
    int textXOffset = 0, textYOffset = 0; /* text offsets for use with
					   * compound buttons and focus ring */
    DWORD *boxesPalette;

    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    boxesPalette= tsdPtr->boxesPalette;
    butPtr->flags &= ~REDRAW_PENDING;
    if ((butPtr->tkwin == NULL) || !Tk_IsMapped(tkwin)) {
	return;
    }

    border = butPtr->normalBorder;
    if ((butPtr->state == STATE_DISABLED) && (butPtr->disabledFg != NULL)) {
	gc = butPtr->disabledGC;
    } else if ((butPtr->state == STATE_ACTIVE)
	    && !Tk_StrictMotif(butPtr->tkwin)) {
	gc = butPtr->activeTextGC;
	border = butPtr->activeBorder;
    } else {
	gc = butPtr->normalTextGC;
    }
    if ((butPtr->flags & SELECTED) && (butPtr->state != STATE_ACTIVE)
	    && (butPtr->selectBorder != NULL) && !butPtr->indicatorOn) {
	border = butPtr->selectBorder;
    }

    /*
     * Override the relief specified for the button if this is a
     * checkbutton or radiobutton and there's no indicator.  The new
     * relief is as follows:
     *      If the button is select  --> "sunken"
     *      If relief==overrelief    --> relief
     *      Otherwise                --> overrelief
     *
     * The effect we are trying to achieve is as follows:
     *
     *      value    mouse-over?   -->   relief
     *     -------  ------------        --------
     *       off        no               flat
     *       off        yes              raised
     *       on         no               sunken
     *       on         yes              sunken
     *
     * This is accomplished by configuring the checkbutton or radiobutton
     * like this:
     *
     *     -indicatoron 0 -overrelief raised -offrelief flat
     *
     * Bindings (see library/button.tcl) will copy the -overrelief into
     * -relief on mouseover.  Hence, we can tell if we are in mouse-over by
     * comparing relief against overRelief.  This is an aweful kludge, but
     * it gives use the desired behavior while keeping the code backwards
     * compatible.
     */

    relief = butPtr->relief;
    if ((butPtr->type >= TYPE_CHECK_BUTTON) && !butPtr->indicatorOn) {
	if (butPtr->flags & SELECTED) {
	    relief = TK_RELIEF_SUNKEN;
	} else if (butPtr->overRelief != relief) {
	    relief = butPtr->offRelief;
	}
    }

    /*
     * Compute width of default ring and offset for pushed buttons.
     */

    if (butPtr->type == TYPE_BUTTON) {
	defaultWidth = ((butPtr->defaultState == DEFAULT_ACTIVE)
		? butPtr->highlightWidth : 0);
	offset = 1;
    } else {
	defaultWidth = 0;
	if ((butPtr->type >= TYPE_CHECK_BUTTON) && !butPtr->indicatorOn) {
	    offset = 1;
	} else {
	    offset = 0;
	}
    }

    /*
     * In order to avoid screen flashes, this procedure redraws
     * the button in a pixmap, then copies the pixmap to the
     * screen in a single operation.  This means that there's no
     * point in time where the on-sreen image has been cleared.
     */

    pixmap = Tk_GetPixmap(butPtr->display, Tk_WindowId(tkwin),
	    Tk_Width(tkwin), Tk_Height(tkwin), Tk_Depth(tkwin));
    Tk_Fill3DRectangle(tkwin, pixmap, border, 0, 0, Tk_Width(tkwin),
	    Tk_Height(tkwin), 0, TK_RELIEF_FLAT);

    /*
     * Display image or bitmap or text for button.
     */

    if (butPtr->image != None) {
	Tk_SizeOfImage(butPtr->image, &width, &height);
	haveImage = 1;
    } else if (butPtr->bitmap != None) {
	Tk_SizeOfBitmap(butPtr->display, butPtr->bitmap, &width, &height);
	haveImage = 1;
    }

    haveText = (butPtr->textWidth != 0 && butPtr->textHeight != 0);
    
    if (butPtr->compound != COMPOUND_NONE && haveImage && haveText) {
	int imageXOffset, imageYOffset, fullWidth,
	    fullHeight;
	imageXOffset = 0;
	imageYOffset = 0;
	fullWidth = 0;
	fullHeight = 0;

	switch ((enum compound) butPtr->compound) {
	    case COMPOUND_TOP: 
	    case COMPOUND_BOTTOM: {
		/* Image is above or below text */
		if (butPtr->compound == COMPOUND_TOP) {
		    textYOffset = height + butPtr->padY;
		} else {
		    imageYOffset = butPtr->textHeight + butPtr->padY;
		}
		fullHeight = height + butPtr->textHeight + butPtr->padY;
		fullWidth = (width > butPtr->textWidth ? width :
			butPtr->textWidth);
		textXOffset = (fullWidth - butPtr->textWidth)/2;
		imageXOffset = (fullWidth - width)/2;
		break;
	    }
	    case COMPOUND_LEFT:
	    case COMPOUND_RIGHT: {
		/* Image is left or right of text */
		if (butPtr->compound == COMPOUND_LEFT) {
		    textXOffset = width + butPtr->padX;
		} else {
		    imageXOffset = butPtr->textWidth + butPtr->padX;
		}
		fullWidth = butPtr->textWidth + butPtr->padX + width;
		fullHeight = (height > butPtr->textHeight ? height :
			butPtr->textHeight);
		textYOffset = (fullHeight - butPtr->textHeight)/2;
		imageYOffset = (fullHeight - height)/2;
		break;
	    }
	    case COMPOUND_CENTER: {
		/* Image and text are superimposed */
		fullWidth = (width > butPtr->textWidth ? width :
			butPtr->textWidth);
		fullHeight = (height > butPtr->textHeight ? height :
			butPtr->textHeight);
		textXOffset = (fullWidth - butPtr->textWidth)/2;
		imageXOffset = (fullWidth - width)/2;
		textYOffset = (fullHeight - butPtr->textHeight)/2;
		imageYOffset = (fullHeight - height)/2;
		break;
	    }
	    case COMPOUND_NONE: {break;}
	}
	TkComputeAnchor(butPtr->anchor, tkwin, butPtr->padX, butPtr->padY,
		butPtr->indicatorSpace + fullWidth, fullHeight, &x, &y);
	x += butPtr->indicatorSpace;

	if (relief == TK_RELIEF_SUNKEN) {
	    x += offset;
	    y += offset;
	}

	if (butPtr->image != NULL) {
	    if ((butPtr->selectImage != NULL) && (butPtr->flags & SELECTED)) {
		Tk_RedrawImage(butPtr->selectImage, 0, 0,
			width, height, pixmap, x + imageXOffset,
			y + imageYOffset);
	    } else {
		Tk_RedrawImage(butPtr->image, 0, 0, width,
			height, pixmap, x + imageXOffset, y + imageYOffset);
	    }
	} else {
	    XSetClipOrigin(butPtr->display, gc, x + imageXOffset,
		    y + imageYOffset);
	    XCopyPlane(butPtr->display, butPtr->bitmap, pixmap, gc,
		    0, 0, (unsigned int) width,
		    (unsigned int) height, x + imageXOffset,
		    y + imageYOffset, 1);
	    XSetClipOrigin(butPtr->display, gc, 0, 0);
	}
	
	Tk_DrawTextLayout(butPtr->display, pixmap, gc, butPtr->textLayout,
		x + textXOffset, y + textYOffset, 0, -1);
	Tk_UnderlineTextLayout(butPtr->display, pixmap, gc,
		butPtr->textLayout, x + textXOffset, y + textYOffset,
		butPtr->underline);
	height = fullHeight;
	drawRing = 1;
    } else {
	if (haveImage) {
	    TkComputeAnchor(butPtr->anchor, tkwin, 0, 0,
		    butPtr->indicatorSpace + width, height, &x, &y);
	    x += butPtr->indicatorSpace;
	    
	    if (relief == TK_RELIEF_SUNKEN) {
		x += offset;
		y += offset;
	    }
	    if (butPtr->image != NULL) {
		if ((butPtr->selectImage != NULL) &&
			(butPtr->flags & SELECTED)) {
		    Tk_RedrawImage(butPtr->selectImage, 0, 0, width, height,
			    pixmap, x, y);
		} else {
		    Tk_RedrawImage(butPtr->image, 0, 0, width, height, pixmap,
			    x, y);
		}
	    } else {
		XSetClipOrigin(butPtr->display, gc, x, y);
		XCopyPlane(butPtr->display, butPtr->bitmap, pixmap, gc, 0, 0,
			(unsigned int) width, (unsigned int) height, x, y, 1);
		XSetClipOrigin(butPtr->display, gc, 0, 0);
	    }
		        
	} else {
	    TkComputeAnchor(butPtr->anchor, tkwin, butPtr->padX, butPtr->padY,
		    butPtr->indicatorSpace + butPtr->textWidth,
		    butPtr->textHeight,	&x, &y);

	    x += butPtr->indicatorSpace;
	    
	    if (relief == TK_RELIEF_SUNKEN) {
		x += offset;
		y += offset;
	    }
	    Tk_DrawTextLayout(butPtr->display, pixmap, gc, butPtr->textLayout,
		    x, y, 0, -1);
	    Tk_UnderlineTextLayout(butPtr->display, pixmap, gc,
		    butPtr->textLayout, x, y, butPtr->underline);

	    height = butPtr->textHeight;
	    drawRing = 1;
	}
    }

    /*
     * Draw the focus ring.  If this is a push button then we need to
     * put it around the inner edge of the border, otherwise we put it
     * around the text.  The text offsets are only non-zero when this
     * is a compound button.
     */
    
    if (drawRing && butPtr->flags & GOT_FOCUS && butPtr->type != TYPE_LABEL) {
	dc = TkWinGetDrawableDC(butPtr->display, pixmap, &state);
	if (butPtr->type == TYPE_BUTTON || !butPtr->indicatorOn) {
	    rect.top = butPtr->borderWidth + 1 + defaultWidth;
	    rect.left = rect.top;
	    rect.right = Tk_Width(tkwin) - rect.left;
	    rect.bottom = Tk_Height(tkwin) - rect.top;
	} else {
	    rect.top = y-1 + textYOffset;
	    rect.left = x-1 + textXOffset;
	    rect.right = x+butPtr->textWidth + 1 + textXOffset;
	    rect.bottom = y+butPtr->textHeight + 2 + textYOffset;
	}
	SetTextColor(dc, gc->foreground);
	SetBkColor(dc, gc->background);
	DrawFocusRect(dc, &rect);
	TkWinReleaseDrawableDC(pixmap, dc, &state);
    }

    y += height/2;
    
    /*
     * Draw the indicator for check buttons and radio buttons.  At this
     * point x and y refer to the top-left corner of the text or image
     * or bitmap.
     */

    if ((butPtr->type >= TYPE_CHECK_BUTTON) && butPtr->indicatorOn
	    && tsdPtr->boxesPtr) {
	int xSrc, ySrc;

	x -= butPtr->indicatorSpace;
	y -= butPtr->indicatorDiameter / 2;

	xSrc = (butPtr->flags & SELECTED) ? tsdPtr->boxWidth : 0;
	if (butPtr->state == STATE_ACTIVE) {
	    xSrc += tsdPtr->boxWidth*2;
	}
	ySrc = (butPtr->type == TYPE_RADIO_BUTTON) ? 0 : tsdPtr->boxHeight;
		
	/*
	 * Update the palette in the boxes bitmap to reflect the current
	 * button colors.  Note that this code relies on the layout of the
	 * bitmap's palette.  Also, all of the colors used to draw the
	 * bitmap must be in the palette that is selected into the DC of
	 * the offscreen pixmap.  This requires that the static colors
	 * be placed into the palette.
	 */

	boxesPalette[PAL_CHECK] = FlipColor(gc->foreground);
	boxesPalette[PAL_TOP_OUTER] = FlipColor(TkWinGetBorderPixels(tkwin,
		border, TK_3D_DARK_GC));
	boxesPalette[PAL_TOP_INNER] = FlipColor(TkWinGetBorderPixels(tkwin,
		border, TK_3D_DARK2));
	boxesPalette[PAL_BOTTOM_INNER] = FlipColor(TkWinGetBorderPixels(tkwin,
		border, TK_3D_LIGHT2));
	boxesPalette[PAL_BOTTOM_OUTER] = FlipColor(TkWinGetBorderPixels(tkwin,
		border, TK_3D_LIGHT_GC));
	if (butPtr->state == STATE_DISABLED) {
	    boxesPalette[PAL_INTERIOR] = FlipColor(TkWinGetBorderPixels(tkwin,
		border, TK_3D_LIGHT2));
	} else if (butPtr->selectBorder != NULL) {
	    boxesPalette[PAL_INTERIOR] = FlipColor(TkWinGetBorderPixels(tkwin,
		    butPtr->selectBorder, TK_3D_FLAT_GC));
	} else {
	    boxesPalette[PAL_INTERIOR] = FlipColor(GetSysColor(COLOR_WINDOW));
	}
	boxesPalette[PAL_BACKGROUND] = FlipColor(TkWinGetBorderPixels(tkwin,
		border, TK_3D_FLAT_GC));

	dc = TkWinGetDrawableDC(butPtr->display, pixmap, &state);
	StretchDIBits(dc, x, y, tsdPtr->boxWidth, tsdPtr->boxHeight, 
                xSrc, ySrc, tsdPtr->boxWidth, tsdPtr->boxHeight, 
                tsdPtr->boxesBits, (LPBITMAPINFO) tsdPtr->boxesPtr, 
                DIB_RGB_COLORS, SRCCOPY);
	TkWinReleaseDrawableDC(pixmap, dc, &state);
    }

    /*
     * If the button is disabled with a stipple rather than a special
     * foreground color, generate the stippled effect.  If the widget
     * is selected and we use a different background color when selected,
     * must temporarily modify the GC.
     */

    if ((butPtr->state == STATE_DISABLED)
	    && ((butPtr->disabledFg == NULL) || (butPtr->image != NULL))) {
	if ((butPtr->flags & SELECTED) && !butPtr->indicatorOn
		&& (butPtr->selectBorder != NULL)) {
	    XSetForeground(butPtr->display, butPtr->disabledGC,
		    Tk_3DBorderColor(butPtr->selectBorder)->pixel);
	}
	XFillRectangle(butPtr->display, pixmap, butPtr->disabledGC,
		butPtr->inset, butPtr->inset,
		(unsigned) (Tk_Width(tkwin) - 2*butPtr->inset),
		(unsigned) (Tk_Height(tkwin) - 2*butPtr->inset));
	if ((butPtr->flags & SELECTED) && !butPtr->indicatorOn
		&& (butPtr->selectBorder != NULL)) {
	    XSetForeground(butPtr->display, butPtr->disabledGC,
		    Tk_3DBorderColor(butPtr->normalBorder)->pixel);
	}
    }

    /*
     * Draw the border and traversal highlight last.  This way, if the
     * button's contents overflow they'll be covered up by the border.
     */

    if (relief != TK_RELIEF_FLAT) {
	Tk_Draw3DRectangle(tkwin, pixmap, border,
		defaultWidth, defaultWidth,
		Tk_Width(tkwin) - 2*defaultWidth,
		Tk_Height(tkwin) - 2*defaultWidth,
		butPtr->borderWidth, relief);
    }
    if (defaultWidth != 0) {
	dc = TkWinGetDrawableDC(butPtr->display, pixmap, &state);
	TkWinFillRect(dc, 0, 0, Tk_Width(tkwin), defaultWidth,
		butPtr->highlightColorPtr->pixel);
	TkWinFillRect(dc, 0, 0, defaultWidth, Tk_Height(tkwin),
		butPtr->highlightColorPtr->pixel);
	TkWinFillRect(dc, 0, Tk_Height(tkwin) - defaultWidth,
		Tk_Width(tkwin), defaultWidth,
		butPtr->highlightColorPtr->pixel);
	TkWinFillRect(dc, Tk_Width(tkwin) - defaultWidth, 0,
		defaultWidth, Tk_Height(tkwin),
		butPtr->highlightColorPtr->pixel);
	TkWinReleaseDrawableDC(pixmap, dc, &state);
    }

    if (butPtr->flags & GOT_FOCUS) {
	Tk_SetCaretPos(tkwin, x, y, 0 /* not used */);
    }

    /*
     * Copy the information from the off-screen pixmap onto the screen,
     * then delete the pixmap.
     */

    XCopyArea(butPtr->display, pixmap, Tk_WindowId(tkwin),
	    butPtr->copyGC, 0, 0, (unsigned) Tk_Width(tkwin),
	    (unsigned) Tk_Height(tkwin), 0, 0);
    Tk_FreePixmap(butPtr->display, pixmap);
}

/*
 *----------------------------------------------------------------------
 *
 * TkpComputeButtonGeometry --
 *
 *	After changes in a button's text or bitmap, this procedure
 *	recomputes the button's geometry and passes this information
 *	along to the geometry manager for the window.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The button's window may change size.
 *
 *----------------------------------------------------------------------
 */

void
TkpComputeButtonGeometry(butPtr)
    register TkButton *butPtr;	/* Button whose geometry may have changed. */
{
    int txtWidth, txtHeight;		/* Width and height of text */
    int imgWidth, imgHeight;		/* Width and height of image */
    int width = 0, height = 0;		/* Width and height of button */
    int haveImage, haveText;
    int avgWidth;
    int minWidth;
    /* Vertical and horizontal dialog units size in pixels. */
    double vDLU, hDLU;
    Tk_FontMetrics fm;
    
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
	Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    if (butPtr->highlightWidth < 0) {
	butPtr->highlightWidth = 0;
    }
    butPtr->inset = butPtr->highlightWidth + butPtr->borderWidth;
    butPtr->indicatorSpace = 0;

    if (!tsdPtr->boxesPtr) {
	InitBoxes();
    }

    /* Figure out image metrics */
    if (butPtr->image != NULL) {
	Tk_SizeOfImage(butPtr->image, &imgWidth, &imgHeight);
	haveImage = 1;
    } else if (butPtr->bitmap != None) {
	Tk_SizeOfBitmap(butPtr->display, butPtr->bitmap,
			&imgWidth, &imgHeight);
	haveImage = 1;
    } else {
	imgWidth = 0;
	imgHeight = 0;
	haveImage = 0;
    }

    /* 
     * Figure out font metrics (even if we don't have text because we need
     * DLUs (based on font, not text) for some spacing calculations below).
     */
    Tk_FreeTextLayout(butPtr->textLayout);
    butPtr->textLayout = Tk_ComputeTextLayout(butPtr->tkfont,
	    Tcl_GetString(butPtr->textPtr), -1, butPtr->wrapLength,
	    butPtr->justify, 0, &butPtr->textWidth, &butPtr->textHeight);

    txtWidth = butPtr->textWidth;
    txtHeight = butPtr->textHeight;
    haveText = (*(Tcl_GetString(butPtr->textPtr)) != '\0');
    avgWidth = (Tk_TextWidth(butPtr->tkfont,
	    "abcdefghijklmnopqurstuvwzyABCDEFGHIJKLMNOPQURSTUVWZY",
	    52) + 26) / 52;
    Tk_GetFontMetrics(butPtr->tkfont, &fm);

    /* Compute dialog units for layout calculations. */
    hDLU = avgWidth / 4.0;
    vDLU = fm.linespace / 8.0;

    /*
     * First, let's try to compute button size "by the book" (See "Microsoft
     * Windows User Experience" (ISBN 0-7356-0566-1), Chapter 14 - Visual
     * Design, Section 4 - Layout (page 448)).
     *
     * Note, that Tk "buttons" are Microsoft "Command buttons", Tk
     * "checkbuttons" are Microsoft "check boxes", Tk "radiobuttons" are
     * Microsoft "option buttons", and Tk "labels" are Microsoft "text
     * labels".
     */

    /*
     * Set width and height by button type; See User Experience table, p449.
     * These are text-based measurements, even if the text is "".
     * If there is an image, height will get set again later.
     */
    switch (butPtr->type) {
        case TYPE_BUTTON: {
	    /*
	     * First compute the minimum width of the button in 
	     * characters.	MWUE says that the button should be
	     * 50 DLUs.  We allow 6 DLUs padding left and right.
	     * (There is no rule but this is consistent with the
	     * fact that button text is 8 DLUs high and buttons
	     * are 14 DLUs high.)
	     * 
	     * The width is specified in characters.  A character
	     * is, by definition, 4 DLUs wide.  11 char * 4 DLU
	     * is 44 DLU + 6 DLU padding = 50 DLU.	Therefore,
	     * width = -11 -> MWUE compliant buttons.
	     */
	    if (butPtr->width < 0) {
		/* Min width in characters */
		minWidth = -(butPtr->width);
		/* Allow for characters */
		width = avgWidth * minWidth;
		/* Add for padding */
		width += (int)(0.5 + (6 * hDLU));
	    } 

	    /*
	     * If shrink-wrapping was requested (width = 0) or
	     * if the text is wider than the default button width,
	     * adjust the button width up to suit.	
	     */
	    if (butPtr->width == 0 
		    || (txtWidth + (int)(0.5 + (6 * hDLU)) > width)) {
		width = txtWidth + (int)(0.5 + (6 * hDLU));
	    }

	    /*
	     * The User Experience says 14 DLUs.  Since text is, by
	     * definition, 8 DLU/line, this allows for multi-line text
	     * while working perfectly for single-line text.
	     */
	    height = txtHeight + (int)(0.5 + (6 * vDLU));

	    /*
	     * The above includes 6 DLUs of padding which should include
	     * defaults of 1 pixel of highlightwidth, 2 pixels of 
	     * borderwidth, 1 pixel of padding and 1 pixel of extra inset 
	     * on each side.  Those will be added later so reduce width 
	     * and height now to compensate.
	     */
	    width  -= 10;
	    height -= 10;

	    if (!haveImage) {
		/*
		 * Extra inset for the focus ring.
		 */
		butPtr->inset += 1;
	    }
	    break;
	}

        case TYPE_LABEL: {
            /*
             * The User Experience says, "as wide as needed".
             */
            width = txtWidth;

            /*
             * The User Experience says, "8 (DLUs) per line of text."
             * Since text is, by definition, 8 DLU/line, this allows
             * for multi-line text while working perfectly for single-line
             * text.
             */
            if (txtHeight) {
                height = txtHeight;
            } else {
		/*
		 * If there's no text, we want the height to be one linespace.
		 */
                height = fm.linespace;
            }
            break;
        }

        case TYPE_RADIO_BUTTON:
        case TYPE_CHECK_BUTTON: {
            /* See note for TYPE_LABEL */
            width = txtWidth;
            /*
             * The User Experience says 10 DLUs.  (Is that one DLU above
             * and below for the focus ring?)	 See note above about
             * multi-line text and 8 DLU/line.
             */
            height = txtHeight + (int)(0.5 + (2.0 * vDLU));
            
            /*
             * The above includes 2 DLUs of padding which should include
             * defaults of 1 pixel of highlightwidth, 0 pixels of 
             * borderwidth, and 1 pixel of padding on each side.  Those
             * will be added later so reduce height now to compensate.
             */
            height -= 4;
            
            /*
             * Extra inset for the focus ring.
             */
            butPtr->inset += 1;
            break;
        }
    }/* switch */

    /*
     * At this point, the width and height are correct for a Tk text
     * button, excluding padding and inset, but we have to allow for
     * compound buttons.  The image may be above, below, left, or right
     * of the text.
     */

    /*
     * If the button is compound (i.e., it shows both an image and text),
     * the new geometry is a combination of the image and text geometry.
     * We only honor the compound bit if the button has both text and an
     * image, because otherwise it is not really a compound button.
     */
    if (butPtr->compound != COMPOUND_NONE && haveImage && haveText) {
	switch ((enum compound) butPtr->compound) {
	    case COMPOUND_TOP:
	    case COMPOUND_BOTTOM: {
		/* Image is above or below text */
		if (imgWidth > width) {
		    width = imgWidth;
		}
		height += imgHeight + butPtr->padY;
		break;
	    }
	    case COMPOUND_LEFT:
	    case COMPOUND_RIGHT: {
		/* Image is left or right of text */
		/*
		 * Only increase width of button if image doesn't fit in
		 * slack space of default button width
		 */
		if ((imgWidth + txtWidth + butPtr->padX) > width) {
		    width = imgWidth + txtWidth + butPtr->padX;
		}

		if (imgHeight > height) {
		    height = imgHeight;
		}
		break;
	    }
	    case COMPOUND_CENTER: {
		/* Image and text are superimposed */
		if (imgWidth > width) {
		    width = imgWidth;
		}
		if (imgHeight > height) {
		    height = imgHeight;
		}
		break;
	    }
	} /* switch */

        /* Fix up for minimum width */
        if (butPtr->width < 0) {
            /* minWidth in pixels (because there's an image */
            minWidth = -(butPtr->width);
            if (width < minWidth) {
                width =  minWidth;
            }
        } else if (butPtr->width > 0) {
	    width = butPtr->width;
	}

	if (butPtr->height > 0) {
	    height = butPtr->height;
	}

	width += 2*butPtr->padX;
	height += 2*butPtr->padY;
    } else if (haveImage) {
	if (butPtr->width > 0) {
	    width = butPtr->width;
	} else {
	    width = imgWidth;
	}
	if (butPtr->height > 0) {
	    height = butPtr->height;
	} else {
	    height = imgHeight;
	}
    } else {
        /* No image.  May or may not be text.  May or may not be compound. */

        /*
	 * butPtr->width is in characters.  We need to allow for that
	 * many characters on the face, not in the over-all button width
	 */
        if (butPtr->width > 0) {
	    width = butPtr->width * avgWidth;
	}

	/*
	 * butPtr->height is in lines of text. We need to allow for
	 * that many lines on the face, not in the over-all button
	 * height.
	 */
	if (butPtr->height > 0) {
	    height = butPtr->height * fm.linespace;

	    /*
	     * Make the same adjustments as above to get same height for
	     * e.g. a one line text with -height 0 or 1.  [Bug #565485]
	     */

	    switch (butPtr->type) {
		case TYPE_BUTTON: {
		    height += (int)(0.5 + (6 * vDLU)) - 10;
		    break;
		}
		case TYPE_RADIO_BUTTON:
		case TYPE_CHECK_BUTTON: {
		    height += (int)(0.5 + (2.0 * vDLU)) - 4;
		    break;
		}
	    }
	}
	    
	width  += 2 * butPtr->padX;
	height += 2 * butPtr->padY;
    }

    /* Fix up width and height for indicator sizing and spacing */
    if (butPtr->type == TYPE_RADIO_BUTTON
	    || butPtr->type == TYPE_CHECK_BUTTON) {
	if (butPtr->indicatorOn) {
	    butPtr->indicatorDiameter = tsdPtr->boxHeight;

            /* 
             * Make sure we can see the whole indicator, even if the text
             * or image is very small.
             */
            if (height < butPtr->indicatorDiameter) {
                height = butPtr->indicatorDiameter;
            }

	    /*
	     * There is no rule for space between the indicator and
	     * the text (the two are atomic on 'Windows) but the User
	     * Experience page 451 says leave 3 hDLUs between "text
	     * labels and their associated controls".
	     */
	    butPtr->indicatorSpace = butPtr->indicatorDiameter +
		(int)(0.5 + (3.0 * hDLU));
	    width += butPtr->indicatorSpace;
	}
    }

    /*
     * Inset is always added to the size.
     */
    width  += 2 * butPtr->inset;
    height += 2 * butPtr->inset;

    Tk_GeometryRequest(butPtr->tkwin, width, height);
    Tk_SetInternalBorder(butPtr->tkwin, butPtr->inset);
}

/*
 *----------------------------------------------------------------------
 *
 * ButtonProc --
 *
 *	This function is call by Windows whenever an event occurs on
 *	a button control created by Tk.
 *
 * Results:
 *	Standard Windows return value.
 *
 * Side effects:
 *	May generate events.
 *
 *----------------------------------------------------------------------
 */

static LRESULT CALLBACK
ButtonProc(hwnd, message, wParam, lParam)
    HWND hwnd;
    UINT message;
    WPARAM wParam;
    LPARAM lParam;
{
    LRESULT result;
    WinButton *butPtr;
    Tk_Window tkwin = Tk_HWNDToWindow(hwnd);

    if (tkwin == NULL) {
	panic("ButtonProc called on an invalid HWND");
    }
    butPtr = (WinButton *)((TkWindow*)tkwin)->instanceData;

    switch(message) {
	case WM_ERASEBKGND:
	    return 0;

	case BM_GETCHECK:
	    if (((butPtr->info.type == TYPE_CHECK_BUTTON)
		    || (butPtr->info.type == TYPE_RADIO_BUTTON))
		    && butPtr->info.indicatorOn) {
		return (butPtr->info.flags & SELECTED)
		    ? BST_CHECKED : BST_UNCHECKED;
	    }
	    return 0;

	case BM_GETSTATE: {
	    DWORD state = 0;
	    if (((butPtr->info.type == TYPE_CHECK_BUTTON)
		    || (butPtr->info.type == TYPE_RADIO_BUTTON))
		    && butPtr->info.indicatorOn) {
		state = (butPtr->info.flags & SELECTED)
		    ? BST_CHECKED : BST_UNCHECKED;
	    }
	    if (butPtr->info.flags & GOT_FOCUS) {
		state |= BST_FOCUS;
	    }
	    return state;
	}
	case WM_ENABLE:
	    break;

	case WM_PAINT: {
	    PAINTSTRUCT ps;
	    BeginPaint(hwnd, &ps);
	    EndPaint(hwnd, &ps);
	    TkpDisplayButton((ClientData)butPtr);

	    /*
	     * Special note: must cancel any existing idle handler
	     * for TkpDisplayButton;  it's no longer needed, and
	     * TkpDisplayButton cleared the REDRAW_PENDING flag.
	     */
           
	    Tcl_CancelIdleCall(TkpDisplayButton, (ClientData)butPtr);
	    return 0;
	}
	case BN_CLICKED: {
	    int code;
	    Tcl_Interp *interp = butPtr->info.interp;
	    if (butPtr->info.state != STATE_DISABLED) {
		Tcl_Preserve((ClientData)interp);
		code = TkInvokeButton((TkButton*)butPtr);
		if (code != TCL_OK && code != TCL_CONTINUE
			&& code != TCL_BREAK) {
		    Tcl_AddErrorInfo(interp, "\n    (button invoke)");
		    Tcl_BackgroundError(interp);
		}
		Tcl_Release((ClientData)interp);
	    }
	    Tcl_ServiceAll();
	    return 0;
	}

	default:
	    if (Tk_TranslateWinEvent(hwnd, message, wParam, lParam, &result)) {
		return result;
	    }
    }
    return DefWindowProc(hwnd, message, wParam, lParam);
}
@


1.5
log
@touched all sources to ease next import
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tkWinButton.c,v 1.8.6.1 2000/05/04 21:26:31 spolk Exp $
a27 4
static DWORD buttonStyles[] = {
    LABEL_STYLE, PUSH_STYLE, CHECK_STYLE, RADIO_STYLE
};

a36 1
    int pixFlags;		/* Button flags for pixmap field. */
a81 4

static int		ButtonBindProc _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, XEvent *eventPtr,
			    Tk_Window tkwin, KeySym keySym));
a83 1
static DWORD		ComputeStyle _ANSI_ARGS_((WinButton* butPtr));
a87 3
/* CYGNUS LOCAL.  */
static void		TkpRealDisplayButton _ANSI_ARGS_((ClientData, int));

d92 4
a95 4
TkClassProcs tkpButtonProcs = { 
    CreateProc,			/* createProc. */
    TkButtonWorldChanged,	/* geometryProc. */
    NULL			/* modalProc. */ 
a229 3
    /* CYGNUS LOCAL: Use the pixmap field.  */
    butPtr->pixmap = 0;
    butPtr->pixFlags = 0;
d274 4
d280 1
d309 3
d313 1
a313 5
    }
    /* CYGNUS LOCAL: Free the pixmap.  */
    if (winButPtr->pixmap != 0) {
	Tk_FreePixmap(butPtr->display, winButPtr->pixmap);
	winButPtr->pixmap = 0;
a338 13
    /* CYGNUS LOCAL: Use a subroutine.  */
    TkpRealDisplayButton(clientData, 1);
}

/* CYGNUS LOCAL: This is the old TkpDisplayButton, with a force
   argument added.  The idea is to speed up redrawing a button due to
   a WM_PAINT event by saving a pixmap of the image.  */

static void
TkpRealDisplayButton(clientData, force)
    ClientData clientData;
    int force;
{
d349 2
a350 1
    int width, height;
d356 2
a368 15
    /* CYGNUS LOCAL: Use the saved pixmap if we can.  */
    if (! force && ((WinButton *)butPtr)->pixmap != 0
	    && ((WinButton *)butPtr)->pixFlags == butPtr->flags) {
	XCopyArea(butPtr->display, ((WinButton *)butPtr)->pixmap,
		Tk_WindowId(tkwin), butPtr->copyGC, 0, 0,
		(unsigned) Tk_Width(tkwin), (unsigned) Tk_Height(tkwin),
		0, 0);
	return;
    }

    if (((WinButton *)butPtr)->pixmap != 0) {
	Tk_FreePixmap(butPtr->display, ((WinButton*)butPtr)->pixmap);
	((WinButton*)butPtr)->pixmap = 0;
    }

d386 25
a410 1
     * checkbutton or radiobutton and there's no indicator.
d415 5
a419 2
	relief = (butPtr->flags & SELECTED) ? TK_RELIEF_SUNKEN
		: TK_RELIEF_RAISED;
d457 5
d463 57
a519 3
	imageOrBitmap:
	TkComputeAnchor(butPtr->anchor, tkwin, 0, 0,
		butPtr->indicatorSpace + width, height, &x, &y);
d526 1
d529 3
a531 2
		Tk_RedrawImage(butPtr->selectImage, 0, 0, width, height,
			pixmap, x, y);
d533 2
a534 2
		Tk_RedrawImage(butPtr->image, 0, 0, width, height, pixmap,
			x, y);
d537 6
a542 3
	    XSetClipOrigin(butPtr->display, gc, x, y);
	    XCopyPlane(butPtr->display, butPtr->bitmap, pixmap, gc, 0, 0,
		    (unsigned int) width, (unsigned int) height, x, y, 1);
d545 8
a552 4
	y += height/2;
    } else if (butPtr->bitmap != None) {
	Tk_SizeOfBitmap(butPtr->display, butPtr->bitmap, &width, &height);
	goto imageOrBitmap;
d554 40
a593 6
	RECT rect;
	TkComputeAnchor(butPtr->anchor, tkwin, butPtr->padX, butPtr->padY,
		butPtr->indicatorSpace + butPtr->textWidth, butPtr->textHeight,
		&x, &y);

	x += butPtr->indicatorSpace;
d595 2
a596 3
	if (relief == TK_RELIEF_SUNKEN) {
	    x += offset;
	    y += offset;
d598 1
a598 4
	Tk_DrawTextLayout(butPtr->display, pixmap, gc, butPtr->textLayout,
		x, y, 0, -1);
	Tk_UnderlineTextLayout(butPtr->display, pixmap, gc,
		butPtr->textLayout, x, y, butPtr->underline);
d600 24
a623 25
	/*
	 * Draw the focus ring.  If this is a push button then we need to put
	 * it around the inner edge of the border, otherwise we put it around
	 * the text.
	 */

	if (butPtr->flags & GOT_FOCUS && butPtr->type != TYPE_LABEL) {
	    dc = TkWinGetDrawableDC(butPtr->display, pixmap, &state);
	    if (butPtr->type == TYPE_BUTTON || !butPtr->indicatorOn) {
		rect.top = butPtr->borderWidth + 1 + defaultWidth;
		rect.left = rect.top;
		rect.right = Tk_Width(tkwin) - rect.left;
		rect.bottom = Tk_Height(tkwin) - rect.top;
	    } else {
		rect.top = y-2;
		rect.left = x-2;
		rect.right = x+butPtr->textWidth + 1;
		rect.bottom = y+butPtr->textHeight + 1;
	    }
	    SetTextColor(dc, gc->foreground);
	    SetBkColor(dc, gc->background);
	    DrawFocusRect(dc, &rect);
	    TkWinReleaseDrawableDC(pixmap, dc, &state);
	}
	y += butPtr->textHeight/2;
d626 2
d737 4
d749 1
a749 7

    /* CYGNUS LOCAL: Don't free the pixmap; save it for the next
       redisplay.
       Tk_FreePixmap(butPtr->display, pixmap);
    */
    ((WinButton*)butPtr)->pixmap = pixmap;
    ((WinButton*)butPtr)->pixFlags = butPtr->flags;
d774 8
a781 1
    int width, height, avgWidth;
d783 1
d785 1
a785 1
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
d797 1
d799 229
a1027 2
	Tk_SizeOfImage(butPtr->image, &width, &height);
	imageOrBitmap:
d1030 2
d1035 2
a1037 7
	if ((butPtr->type >= TYPE_CHECK_BUTTON) && butPtr->indicatorOn) {
	    butPtr->indicatorSpace = tsdPtr->boxWidth * 2;
	    butPtr->indicatorDiameter = tsdPtr->boxHeight;
	}
    } else if (butPtr->bitmap != None) {
	Tk_SizeOfBitmap(butPtr->display, butPtr->bitmap, &width, &height);
	goto imageOrBitmap;
d1039 1
a1039 9
	Tk_FreeTextLayout(butPtr->textLayout);
	butPtr->textLayout = Tk_ComputeTextLayout(butPtr->tkfont,
		Tcl_GetString(butPtr->textPtr), -1, butPtr->wrapLength,
		butPtr->justify, 0, &butPtr->textWidth, &butPtr->textHeight);

	width = butPtr->textWidth;
	height = butPtr->textHeight;
	avgWidth = Tk_TextWidth(butPtr->tkfont, "0", 1);
	Tk_GetFontMetrics(butPtr->tkfont, &fm);
d1041 5
a1045 1
	if (butPtr->width > 0) {
d1049 6
a1054 3
	if (butPtr->type == TYPE_BUTTON) {
		height = butPtr->height * fm.ascent;
	} else if (butPtr->height > 0) {
d1056 17
d1074 4
d1079 4
a1082 1
	if ((butPtr->type >= TYPE_CHECK_BUTTON) && butPtr->indicatorOn) {
a1083 2
	    butPtr->indicatorSpace = butPtr->indicatorDiameter + avgWidth;
	}
d1085 7
a1091 3
	/*
	 * Increase the inset to allow for the focus ring.
	 */
d1093 9
a1101 2
	if (butPtr->type != TYPE_LABEL) {
	    butPtr->inset += 3;
d1106 1
a1106 4
     * When issuing the geometry request, add extra space for the indicator,
     * if any, and for the border and padding, plus an extra pixel so the
     * display can be offset by 1 pixel in either direction for the raised
     * or lowered effect.
d1108 2
d1111 1
a1111 11
    if ((butPtr->image == NULL) && (butPtr->bitmap == None)) {
	width += 2*butPtr->padX;
	height += 2*butPtr->padY;
    }
    if ((butPtr->type == TYPE_BUTTON)
	    || ((butPtr->type >= TYPE_CHECK_BUTTON) && !butPtr->indicatorOn)) {
	width += 1;
	height += 1;
    }
    Tk_GeometryRequest(butPtr->tkwin, (int) (width + butPtr->indicatorSpace
	    + 2*butPtr->inset), (int) (height + 2*butPtr->inset));
a1112 6

    /* CYGNUS LOCAL: Discard any saved pixmap.  */
    if (((WinButton*)butPtr)->pixmap != 0) {
	Tk_FreePixmap(butPtr->display, ((WinButton*)butPtr)->pixmap);
	((WinButton*)butPtr)->pixmap = 0;
    }
a1215 1

@


1.4
log
@touched all sources to ease next import
@
text
@@


1.3
log
@	* win/tkWinButton.c (TkpComputeButtonGeometry):
        Windows look and feel fix modified to leave
        labels alone.
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@d735 1
a735 1
	} else {
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
 * Copyright (c) 1996 by Sun Microsystems, Inc.
d12 1
a12 1
 * RCS: @@(#) $Id: tkWinButton.c,v 1.2 1998/09/14 18:23:59 stanton Exp $
d69 3
a71 1
 * Set to non-zero if this module is initialized.
d74 9
a82 17
static int initialized = 0;

/*
 * Variables for the cached information about the boxes bitmap.
 */

static BITMAPINFOHEADER *boxesPtr = NULL;   /* Information about the bitmap. */
static DWORD *boxesPalette = NULL;	    /* Pointer to color palette. */
static LPSTR boxesBits = NULL;		    /* Pointer to bitmap data. */
static DWORD boxHeight = 0, boxWidth = 0;    /* Size of each sub-image. */

/*
 * This variable holds the default border width for a button in string
 * form for use in a Tk_ConfigSpec.
 */

static char defWidth[8];
a96 1
static void		UpdateButtonDefaults _ANSI_ARGS_((void));
d146 2
d152 1
a152 1
	boxesPtr = (LPBITMAPINFOHEADER)LockResource(hblk);
d159 4
a162 4
    if (boxesPtr != NULL && !(boxesPtr->biWidth % 4)
	    && !(boxesPtr->biHeight % 2)) {
	size = boxesPtr->biSize + (1 << boxesPtr->biBitCount) * sizeof(RGBQUAD)
	    + boxesPtr->biSizeImage;
d164 8
a171 7
	memcpy(newBitmap, boxesPtr, size);
	boxesPtr = newBitmap;
	boxWidth = boxesPtr->biWidth / 4;
	boxHeight = boxesPtr->biHeight / 2;
	boxesPalette = (DWORD*) (((LPSTR)boxesPtr) + boxesPtr->biSize);
	boxesBits = ((LPSTR)boxesPalette)
	    + ((1 << boxesPtr->biBitCount) * sizeof(RGBQUAD));
d173 1
a173 1
	boxesPtr = NULL;
d180 1
a180 1
 * UpdateButtonDefaults --
d182 3
a184 2
 *	This function retrieves the current system defaults for
 *	the button widgets.
d187 1
a187 1
 *	None.
d190 1
a190 1
 *	Updates the configuration defaults for buttons.
d196 4
a199 1
UpdateButtonDefaults()
d201 14
a214 11
    Tk_ConfigSpec *specPtr;
    int width = GetSystemMetrics(SM_CXEDGE);

    if (width == 0) {
	width = 1;
    }
    sprintf(defWidth, "%d", width);
    for (specPtr = tkpButtonConfigSpecs; specPtr->type != TK_CONFIG_END;
	    specPtr++) {
	if (specPtr->offset == Tk_Offset(TkButton, borderWidth)) {
	    specPtr->defValue = defWidth;
a240 5
    if (!initialized) {
	UpdateButtonDefaults();
	initialized = 1;
    }

d380 1
d382 2
a383 5
    /* CYGNUS LOCAL: If the generic code has asked us to draw
       ourselves, force a full refresh.  */
    if ((butPtr->flags & REDRAW_PENDING) != 0) {
	force = 1;
    }
d385 1
d407 1
a407 1
    if ((butPtr->state == tkDisabledUid) && (butPtr->disabledFg != NULL)) {
d409 1
a409 1
    } else if ((butPtr->state == tkActiveUid)
d416 1
a416 1
    if ((butPtr->flags & SELECTED) && (butPtr->state != tkActiveUid)
d437 1
a437 1
	defaultWidth = ((butPtr->defaultState == tkActiveUid)
d546 1
a546 1
	    && boxesPtr) {
d552 3
a554 3
	xSrc = (butPtr->flags & SELECTED) ? boxWidth : 0;
	if (butPtr->state == tkActiveUid) {
	    xSrc += boxWidth*2;
d556 1
a556 1
	ySrc = (butPtr->type == TYPE_RADIO_BUTTON) ? 0 : boxHeight;
d576 1
a576 1
	if (butPtr->state == tkDisabledUid) {
d589 4
a592 3
	StretchDIBits(dc, x, y, boxWidth, boxHeight, xSrc, ySrc, 
		boxWidth, boxHeight, boxesBits, (LPBITMAPINFO)boxesPtr, 
		DIB_RGB_COLORS, SRCCOPY);
d603 1
a603 1
    if ((butPtr->state == tkDisabledUid)
d689 2
d698 1
a698 1
    if (!boxesPtr) {
d712 2
a713 2
	    butPtr->indicatorSpace = boxWidth * 2;
	    butPtr->indicatorDiameter = boxHeight;
d721 2
a722 2
		butPtr->text, -1, butPtr->wrapLength, butPtr->justify, 0,
		&butPtr->textWidth, &butPtr->textHeight);
d732 4
a735 1
	if (butPtr->height > 0) {
d740 1
a740 1
	    butPtr->indicatorDiameter = boxHeight;
d846 9
a854 2
	    /* CYGNUS LOCAL: Don't force the button to be recomputed.  */
	    TkpRealDisplayButton((ClientData)butPtr, 0);
d860 1
a860 1
	    if (butPtr->info.state != tkDisabledUid) {
d881 1
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d7 1
a7 1
 * Copyright (c) 1996-1998 by Sun Microsystems, Inc.
d12 1
a12 1
 * RCS: @@(#) $Id: tkWinButton.c,v 1.8.6.1 2000/05/04 21:26:31 spolk Exp $
d69 1
a69 3
 * Cached information about the boxes bitmap, and the default border 
 * width for a button in string form for use in Tk_OptionSpec for 
 * the various button widget classes.
d72 17
a88 9
typedef struct ThreadSpecificData { 
    BITMAPINFOHEADER *boxesPtr;   /* Information about the bitmap. */
    DWORD *boxesPalette;	  /* Pointer to color palette. */
    LPSTR boxesBits;		  /* Pointer to bitmap data. */
    DWORD boxHeight;              /* Height of each sub-image. */
    DWORD boxWidth ;              /* Width of each sub-image. */
    char defWidth[TCL_INTEGER_SPACE];
} ThreadSpecificData;
static Tcl_ThreadDataKey dataKey;
d103 1
a152 2
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
d157 1
a157 1
	tsdPtr->boxesPtr = (LPBITMAPINFOHEADER)LockResource(hblk);
d164 4
a167 4
    if (tsdPtr->boxesPtr != NULL && !(tsdPtr->boxesPtr->biWidth % 4)
	    && !(tsdPtr->boxesPtr->biHeight % 2)) {
	size = tsdPtr->boxesPtr->biSize + (1 << tsdPtr->boxesPtr->biBitCount) 
                * sizeof(RGBQUAD) + tsdPtr->boxesPtr->biSizeImage;
d169 7
a175 8
	memcpy(newBitmap, tsdPtr->boxesPtr, size);
	tsdPtr->boxesPtr = newBitmap;
	tsdPtr->boxWidth = tsdPtr->boxesPtr->biWidth / 4;
	tsdPtr->boxHeight = tsdPtr->boxesPtr->biHeight / 2;
	tsdPtr->boxesPalette = (DWORD*) (((LPSTR) tsdPtr->boxesPtr) 
                + tsdPtr->boxesPtr->biSize);
	tsdPtr->boxesBits = ((LPSTR) tsdPtr->boxesPalette)
	    + ((1 << tsdPtr->boxesPtr->biBitCount) * sizeof(RGBQUAD));
d177 1
a177 1
	tsdPtr->boxesPtr = NULL;
d184 1
a184 1
 * TkpButtonSetDefaults --
d186 2
a187 3
 *	This procedure is invoked before option tables are created for
 *	buttons.  It modifies some of the default values to match the
 *	current values defined for this platform.
d190 1
a190 1
 *	Some of the default values in *specPtr are modified.
d193 1
a193 1
 *	Updates some of.
d199 1
a199 4
TkpButtonSetDefaults(specPtr)
    Tk_OptionSpec *specPtr;	/* Points to an array of option specs,
				 * terminated by one with type
				 * TK_OPTION_END. */
d201 11
a211 14
    int width;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    if (tsdPtr->defWidth[0] == 0) {
	width = GetSystemMetrics(SM_CXEDGE);
	if (width == 0) {
	    width = 1;
	}
	sprintf(tsdPtr->defWidth, "%d", width);
    }
    for ( ; specPtr->type != TK_OPTION_END; specPtr++) {
	if (specPtr->internalOffset == Tk_Offset(TkButton, borderWidth)) {
	    specPtr->defValue = tsdPtr->defWidth;
d238 5
a381 1
    DWORD *boxesPalette;
d383 5
a387 2
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
a388 1
    boxesPalette= tsdPtr->boxesPalette;
d410 1
a410 1
    if ((butPtr->state == STATE_DISABLED) && (butPtr->disabledFg != NULL)) {
d412 1
a412 1
    } else if ((butPtr->state == STATE_ACTIVE)
d419 1
a419 1
    if ((butPtr->flags & SELECTED) && (butPtr->state != STATE_ACTIVE)
d440 1
a440 1
	defaultWidth = ((butPtr->defaultState == DEFAULT_ACTIVE)
d549 1
a549 1
	    && tsdPtr->boxesPtr) {
d555 3
a557 3
	xSrc = (butPtr->flags & SELECTED) ? tsdPtr->boxWidth : 0;
	if (butPtr->state == STATE_ACTIVE) {
	    xSrc += tsdPtr->boxWidth*2;
d559 1
a559 1
	ySrc = (butPtr->type == TYPE_RADIO_BUTTON) ? 0 : tsdPtr->boxHeight;
d579 1
a579 1
	if (butPtr->state == STATE_DISABLED) {
d592 3
a594 4
	StretchDIBits(dc, x, y, tsdPtr->boxWidth, tsdPtr->boxHeight, 
                xSrc, ySrc, tsdPtr->boxWidth, tsdPtr->boxHeight, 
                tsdPtr->boxesBits, (LPBITMAPINFO) tsdPtr->boxesPtr, 
                DIB_RGB_COLORS, SRCCOPY);
d605 1
a605 1
    if ((butPtr->state == STATE_DISABLED)
a690 2
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
d698 1
a698 1
    if (!tsdPtr->boxesPtr) {
d712 2
a713 2
	    butPtr->indicatorSpace = tsdPtr->boxWidth * 2;
	    butPtr->indicatorDiameter = tsdPtr->boxHeight;
d721 2
a722 2
		Tcl_GetString(butPtr->textPtr), -1, butPtr->wrapLength,
		butPtr->justify, 0, &butPtr->textWidth, &butPtr->textHeight);
d732 1
a732 4

	if (butPtr->type == TYPE_BUTTON) {
		height = butPtr->height * fm.ascent;
	} else {
d737 1
a737 1
	    butPtr->indicatorDiameter = tsdPtr->boxHeight;
d843 2
a844 9
	    TkpDisplayButton((ClientData)butPtr);

	    /*
	     * Special note: must cancel any existing idle handler
	     * for TkpDisplayButton;  it's no longer needed, and
	     * TkpDisplayButton cleared the REDRAW_PENDING flag.
	     */
           
	    Tcl_CancelIdleCall(TkpDisplayButton, (ClientData)butPtr);
d850 1
a850 1
	    if (butPtr->info.state != STATE_DISABLED) {
a870 1

@


1.1.1.3
log
@import tk 8.4.0
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tkWinButton.c,v 1.20 2002/09/03 01:05:11 hobbs Exp $
d28 4
d41 1
d87 4
d93 1
d98 3
d105 4
a108 4
Tk_ClassProcs tkpButtonProcs = { 
    sizeof(Tk_ClassProcs),	/* size */
    TkButtonWorldChanged,	/* worldChangedProc */
    CreateProc,			/* createProc */
d243 3
a289 4
#ifdef _WIN64
    butPtr->oldProc = (WNDPROC)SetWindowLongPtr(butPtr->hwnd, GWLP_WNDPROC,
	    (LONG_PTR) ButtonProc);
#else
a291 1
#endif
a319 3
#ifdef _WIN64
	SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) winButPtr->oldProc);
#else
d321 5
a325 1
#endif
d351 13
d374 1
a374 2
    int width, height, haveImage = 0, haveText = 0, drawRing = 0;
    RECT rect;
a379 2
    int textXOffset = 0, textYOffset = 0; /* text offsets for use with
					   * compound buttons and focus ring */
d391 15
d423 1
a423 25
     * checkbutton or radiobutton and there's no indicator.  The new
     * relief is as follows:
     *      If the button is select  --> "sunken"
     *      If relief==overrelief    --> relief
     *      Otherwise                --> overrelief
     *
     * The effect we are trying to achieve is as follows:
     *
     *      value    mouse-over?   -->   relief
     *     -------  ------------        --------
     *       off        no               flat
     *       off        yes              raised
     *       on         no               sunken
     *       on         yes              sunken
     *
     * This is accomplished by configuring the checkbutton or radiobutton
     * like this:
     *
     *     -indicatoron 0 -overrelief raised -offrelief flat
     *
     * Bindings (see library/button.tcl) will copy the -overrelief into
     * -relief on mouseover.  Hence, we can tell if we are in mouse-over by
     * comparing relief against overRelief.  This is an aweful kludge, but
     * it gives use the desired behavior while keeping the code backwards
     * compatible.
d428 2
a429 5
	if (butPtr->flags & SELECTED) {
	    relief = TK_RELIEF_SUNKEN;
	} else if (butPtr->overRelief != relief) {
	    relief = butPtr->offRelief;
	}
a466 5
	haveImage = 1;
    } else if (butPtr->bitmap != None) {
	Tk_SizeOfBitmap(butPtr->display, butPtr->bitmap, &width, &height);
	haveImage = 1;
    }
d468 3
a470 57
    haveText = (butPtr->textWidth != 0 && butPtr->textHeight != 0);
    
    if (butPtr->compound != COMPOUND_NONE && haveImage && haveText) {
	int imageXOffset, imageYOffset, fullWidth,
	    fullHeight;
	imageXOffset = 0;
	imageYOffset = 0;
	fullWidth = 0;
	fullHeight = 0;

	switch ((enum compound) butPtr->compound) {
	    case COMPOUND_TOP: 
	    case COMPOUND_BOTTOM: {
		/* Image is above or below text */
		if (butPtr->compound == COMPOUND_TOP) {
		    textYOffset = height + butPtr->padY;
		} else {
		    imageYOffset = butPtr->textHeight + butPtr->padY;
		}
		fullHeight = height + butPtr->textHeight + butPtr->padY;
		fullWidth = (width > butPtr->textWidth ? width :
			butPtr->textWidth);
		textXOffset = (fullWidth - butPtr->textWidth)/2;
		imageXOffset = (fullWidth - width)/2;
		break;
	    }
	    case COMPOUND_LEFT:
	    case COMPOUND_RIGHT: {
		/* Image is left or right of text */
		if (butPtr->compound == COMPOUND_LEFT) {
		    textXOffset = width + butPtr->padX;
		} else {
		    imageXOffset = butPtr->textWidth + butPtr->padX;
		}
		fullWidth = butPtr->textWidth + butPtr->padX + width;
		fullHeight = (height > butPtr->textHeight ? height :
			butPtr->textHeight);
		textYOffset = (fullHeight - butPtr->textHeight)/2;
		imageYOffset = (fullHeight - height)/2;
		break;
	    }
	    case COMPOUND_CENTER: {
		/* Image and text are superimposed */
		fullWidth = (width > butPtr->textWidth ? width :
			butPtr->textWidth);
		fullHeight = (height > butPtr->textHeight ? height :
			butPtr->textHeight);
		textXOffset = (fullWidth - butPtr->textWidth)/2;
		imageXOffset = (fullWidth - width)/2;
		textYOffset = (fullHeight - butPtr->textHeight)/2;
		imageYOffset = (fullHeight - height)/2;
		break;
	    }
	    case COMPOUND_NONE: {break;}
	}
	TkComputeAnchor(butPtr->anchor, tkwin, butPtr->padX, butPtr->padY,
		butPtr->indicatorSpace + fullWidth, fullHeight, &x, &y);
a476 1

d479 2
a480 3
		Tk_RedrawImage(butPtr->selectImage, 0, 0,
			width, height, pixmap, x + imageXOffset,
			y + imageYOffset);
d482 2
a483 2
		Tk_RedrawImage(butPtr->image, 0, 0, width,
			height, pixmap, x + imageXOffset, y + imageYOffset);
d486 3
a488 6
	    XSetClipOrigin(butPtr->display, gc, x + imageXOffset,
		    y + imageYOffset);
	    XCopyPlane(butPtr->display, butPtr->bitmap, pixmap, gc,
		    0, 0, (unsigned int) width,
		    (unsigned int) height, x + imageXOffset,
		    y + imageYOffset, 1);
d491 16
a506 1
	
d508 1
a508 1
		x + textXOffset, y + textYOffset, 0, -1);
d510 15
a524 23
		butPtr->textLayout, x + textXOffset, y + textYOffset,
		butPtr->underline);
	height = fullHeight;
	drawRing = 1;
    } else {
	if (haveImage) {
	    TkComputeAnchor(butPtr->anchor, tkwin, 0, 0,
		    butPtr->indicatorSpace + width, height, &x, &y);
	    x += butPtr->indicatorSpace;
	    
	    if (relief == TK_RELIEF_SUNKEN) {
		x += offset;
		y += offset;
	    }
	    if (butPtr->image != NULL) {
		if ((butPtr->selectImage != NULL) &&
			(butPtr->flags & SELECTED)) {
		    Tk_RedrawImage(butPtr->selectImage, 0, 0, width, height,
			    pixmap, x, y);
		} else {
		    Tk_RedrawImage(butPtr->image, 0, 0, width, height, pixmap,
			    x, y);
		}
d526 9
a534 24
		XSetClipOrigin(butPtr->display, gc, x, y);
		XCopyPlane(butPtr->display, butPtr->bitmap, pixmap, gc, 0, 0,
			(unsigned int) width, (unsigned int) height, x, y, 1);
		XSetClipOrigin(butPtr->display, gc, 0, 0);
	    }
		        
	} else {
	    TkComputeAnchor(butPtr->anchor, tkwin, butPtr->padX, butPtr->padY,
		    butPtr->indicatorSpace + butPtr->textWidth,
		    butPtr->textHeight,	&x, &y);

	    x += butPtr->indicatorSpace;
	    
	    if (relief == TK_RELIEF_SUNKEN) {
		x += offset;
		y += offset;
	    }
	    Tk_DrawTextLayout(butPtr->display, pixmap, gc, butPtr->textLayout,
		    x, y, 0, -1);
	    Tk_UnderlineTextLayout(butPtr->display, pixmap, gc,
		    butPtr->textLayout, x, y, butPtr->underline);

	    height = butPtr->textHeight;
	    drawRing = 1;
d536 1
a539 28
     * Draw the focus ring.  If this is a push button then we need to
     * put it around the inner edge of the border, otherwise we put it
     * around the text.  The text offsets are only non-zero when this
     * is a compound button.
     */
    
    if (drawRing && butPtr->flags & GOT_FOCUS && butPtr->type != TYPE_LABEL) {
	dc = TkWinGetDrawableDC(butPtr->display, pixmap, &state);
	if (butPtr->type == TYPE_BUTTON || !butPtr->indicatorOn) {
	    rect.top = butPtr->borderWidth + 1 + defaultWidth;
	    rect.left = rect.top;
	    rect.right = Tk_Width(tkwin) - rect.left;
	    rect.bottom = Tk_Height(tkwin) - rect.top;
	} else {
	    rect.top = y-1 + textYOffset;
	    rect.left = x-1 + textXOffset;
	    rect.right = x+butPtr->textWidth + 1 + textXOffset;
	    rect.bottom = y+butPtr->textHeight + 2 + textYOffset;
	}
	SetTextColor(dc, gc->foreground);
	SetBkColor(dc, gc->background);
	DrawFocusRect(dc, &rect);
	TkWinReleaseDrawableDC(pixmap, dc, &state);
    }

    y += height/2;
    
    /*
a647 4
    if (butPtr->flags & GOT_FOCUS) {
	Tk_SetCaretPos(tkwin, x, y, 0 /* not used */);
    }

d656 7
a662 1
    Tk_FreePixmap(butPtr->display, pixmap);
d687 1
a687 8
    int txtWidth, txtHeight;		/* Width and height of text */
    int imgWidth, imgHeight;		/* Width and height of image */
    int width = 0, height = 0;		/* Width and height of button */
    int haveImage, haveText;
    int avgWidth;
    int minWidth;
    /* Vertical and horizontal dialog units size in pixels. */
    double vDLU, hDLU;
a688 1
    
d690 1
a690 1
	Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
a701 1
    /* Figure out image metrics */
d703 3
a705 219
	Tk_SizeOfImage(butPtr->image, &imgWidth, &imgHeight);
	haveImage = 1;
    } else if (butPtr->bitmap != None) {
	Tk_SizeOfBitmap(butPtr->display, butPtr->bitmap,
			&imgWidth, &imgHeight);
	haveImage = 1;
    } else {
	imgWidth = 0;
	imgHeight = 0;
	haveImage = 0;
    }

    /* 
     * Figure out font metrics (even if we don't have text because we need
     * DLUs (based on font, not text) for some spacing calculations below).
     */
    Tk_FreeTextLayout(butPtr->textLayout);
    butPtr->textLayout = Tk_ComputeTextLayout(butPtr->tkfont,
	    Tcl_GetString(butPtr->textPtr), -1, butPtr->wrapLength,
	    butPtr->justify, 0, &butPtr->textWidth, &butPtr->textHeight);

    txtWidth = butPtr->textWidth;
    txtHeight = butPtr->textHeight;
    haveText = (*(Tcl_GetString(butPtr->textPtr)) != '\0');
    avgWidth = (Tk_TextWidth(butPtr->tkfont,
	    "abcdefghijklmnopqurstuvwzyABCDEFGHIJKLMNOPQURSTUVWZY",
	    52) + 26) / 52;
    Tk_GetFontMetrics(butPtr->tkfont, &fm);

    /* Compute dialog units for layout calculations. */
    hDLU = avgWidth / 4.0;
    vDLU = fm.linespace / 8.0;

    /*
     * First, let's try to compute button size "by the book" (See "Microsoft
     * Windows User Experience" (ISBN 0-7356-0566-1), Chapter 14 - Visual
     * Design, Section 4 - Layout (page 448)).
     *
     * Note, that Tk "buttons" are Microsoft "Command buttons", Tk
     * "checkbuttons" are Microsoft "check boxes", Tk "radiobuttons" are
     * Microsoft "option buttons", and Tk "labels" are Microsoft "text
     * labels".
     */

    /*
     * Set width and height by button type; See User Experience table, p449.
     * These are text-based measurements, even if the text is "".
     * If there is an image, height will get set again later.
     */
    switch (butPtr->type) {
        case TYPE_BUTTON: {
	    /*
	     * First compute the minimum width of the button in 
	     * characters.	MWUE says that the button should be
	     * 50 DLUs.  We allow 6 DLUs padding left and right.
	     * (There is no rule but this is consistent with the
	     * fact that button text is 8 DLUs high and buttons
	     * are 14 DLUs high.)
	     * 
	     * The width is specified in characters.  A character
	     * is, by definition, 4 DLUs wide.  11 char * 4 DLU
	     * is 44 DLU + 6 DLU padding = 50 DLU.	Therefore,
	     * width = -11 -> MWUE compliant buttons.
	     */
	    if (butPtr->width < 0) {
		/* Min width in characters */
		minWidth = -(butPtr->width);
		/* Allow for characters */
		width = avgWidth * minWidth;
		/* Add for padding */
		width += (int)(0.5 + (6 * hDLU));
	    } 

	    /*
	     * If shrink-wrapping was requested (width = 0) or
	     * if the text is wider than the default button width,
	     * adjust the button width up to suit.	
	     */
	    if (butPtr->width == 0 
		    || (txtWidth + (int)(0.5 + (6 * hDLU)) > width)) {
		width = txtWidth + (int)(0.5 + (6 * hDLU));
	    }

	    /*
	     * The User Experience says 14 DLUs.  Since text is, by
	     * definition, 8 DLU/line, this allows for multi-line text
	     * while working perfectly for single-line text.
	     */
	    height = txtHeight + (int)(0.5 + (6 * vDLU));

	    /*
	     * The above includes 6 DLUs of padding which should include
	     * defaults of 1 pixel of highlightwidth, 2 pixels of 
	     * borderwidth, 1 pixel of padding and 1 pixel of extra inset 
	     * on each side.  Those will be added later so reduce width 
	     * and height now to compensate.
	     */
	    width  -= 10;
	    height -= 10;

	    if (!haveImage) {
		/*
		 * Extra inset for the focus ring.
		 */
		butPtr->inset += 1;
	    }
	    break;
	}

        case TYPE_LABEL: {
            /*
             * The User Experience says, "as wide as needed".
             */
            width = txtWidth;

            /*
             * The User Experience says, "8 (DLUs) per line of text."
             * Since text is, by definition, 8 DLU/line, this allows
             * for multi-line text while working perfectly for single-line
             * text.
             */
            if (txtHeight) {
                height = txtHeight;
            } else {
		/*
		 * If there's no text, we want the height to be one linespace.
		 */
                height = fm.linespace;
            }
            break;
        }

        case TYPE_RADIO_BUTTON:
        case TYPE_CHECK_BUTTON: {
            /* See note for TYPE_LABEL */
            width = txtWidth;
            /*
             * The User Experience says 10 DLUs.  (Is that one DLU above
             * and below for the focus ring?)	 See note above about
             * multi-line text and 8 DLU/line.
             */
            height = txtHeight + (int)(0.5 + (2.0 * vDLU));
            
            /*
             * The above includes 2 DLUs of padding which should include
             * defaults of 1 pixel of highlightwidth, 0 pixels of 
             * borderwidth, and 1 pixel of padding on each side.  Those
             * will be added later so reduce height now to compensate.
             */
            height -= 4;
            
            /*
             * Extra inset for the focus ring.
             */
            butPtr->inset += 1;
            break;
        }
    }/* switch */

    /*
     * At this point, the width and height are correct for a Tk text
     * button, excluding padding and inset, but we have to allow for
     * compound buttons.  The image may be above, below, left, or right
     * of the text.
     */

    /*
     * If the button is compound (i.e., it shows both an image and text),
     * the new geometry is a combination of the image and text geometry.
     * We only honor the compound bit if the button has both text and an
     * image, because otherwise it is not really a compound button.
     */
    if (butPtr->compound != COMPOUND_NONE && haveImage && haveText) {
	switch ((enum compound) butPtr->compound) {
	    case COMPOUND_TOP:
	    case COMPOUND_BOTTOM: {
		/* Image is above or below text */
		if (imgWidth > width) {
		    width = imgWidth;
		}
		height += imgHeight + butPtr->padY;
		break;
	    }
	    case COMPOUND_LEFT:
	    case COMPOUND_RIGHT: {
		/* Image is left or right of text */
		/*
		 * Only increase width of button if image doesn't fit in
		 * slack space of default button width
		 */
		if ((imgWidth + txtWidth + butPtr->padX) > width) {
		    width = imgWidth + txtWidth + butPtr->padX;
		}

		if (imgHeight > height) {
		    height = imgHeight;
		}
		break;
	    }
	    case COMPOUND_CENTER: {
		/* Image and text are superimposed */
		if (imgWidth > width) {
		    width = imgWidth;
		}
		if (imgHeight > height) {
		    height = imgHeight;
		}
		break;
	    }
	} /* switch */

        /* Fix up for minimum width */
        if (butPtr->width < 0) {
            /* minWidth in pixels (because there's an image */
            minWidth = -(butPtr->width);
            if (width < minWidth) {
                width =  minWidth;
            }
        } else if (butPtr->width > 0) {
a707 1

d711 3
a713 13

	width += 2*butPtr->padX;
	height += 2*butPtr->padY;
    } else if (haveImage) {
	if (butPtr->width > 0) {
	    width = butPtr->width;
	} else {
	    width = imgWidth;
	}
	if (butPtr->height > 0) {
	    height = butPtr->height;
	} else {
	    height = imgHeight;
d715 3
d719 9
a727 1
        /* No image.  May or may not be text.  May or may not be compound. */
d729 1
a729 5
        /*
	 * butPtr->width is in characters.  We need to allow for that
	 * many characters on the face, not in the over-all button width
	 */
        if (butPtr->width > 0) {
d733 3
a735 6
	/*
	 * butPtr->height is in lines of text. We need to allow for
	 * that many lines on the face, not in the over-all button
	 * height.
	 */
	if (butPtr->height > 0) {
a736 17

	    /*
	     * Make the same adjustments as above to get same height for
	     * e.g. a one line text with -height 0 or 1.  [Bug #565485]
	     */

	    switch (butPtr->type) {
		case TYPE_BUTTON: {
		    height += (int)(0.5 + (6 * vDLU)) - 10;
		    break;
		}
		case TYPE_RADIO_BUTTON:
		case TYPE_CHECK_BUTTON: {
		    height += (int)(0.5 + (2.0 * vDLU)) - 4;
		    break;
		}
	    }
a737 4
	    
	width  += 2 * butPtr->padX;
	height += 2 * butPtr->padY;
    }
d739 1
a739 4
    /* Fix up width and height for indicator sizing and spacing */
    if (butPtr->type == TYPE_RADIO_BUTTON
	    || butPtr->type == TYPE_CHECK_BUTTON) {
	if (butPtr->indicatorOn) {
d741 2
d744 3
a746 7
            /* 
             * Make sure we can see the whole indicator, even if the text
             * or image is very small.
             */
            if (height < butPtr->indicatorDiameter) {
                height = butPtr->indicatorDiameter;
            }
d748 2
a749 9
	    /*
	     * There is no rule for space between the indicator and
	     * the text (the two are atomic on 'Windows) but the User
	     * Experience page 451 says leave 3 hDLUs between "text
	     * labels and their associated controls".
	     */
	    butPtr->indicatorSpace = butPtr->indicatorDiameter +
		(int)(0.5 + (3.0 * hDLU));
	    width += butPtr->indicatorSpace;
d754 4
a757 1
     * Inset is always added to the size.
a758 2
    width  += 2 * butPtr->inset;
    height += 2 * butPtr->inset;
d760 11
a770 1
    Tk_GeometryRequest(butPtr->tkwin, width, height);
d772 6
d881 1
@


