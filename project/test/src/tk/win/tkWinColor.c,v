head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.20.24.53;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.17;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.30;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.55;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.30;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.38;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.27;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@/* 
 * tkWinColor.c --
 *
 *	Functions to map color names to system color values.
 *
 * Copyright (c) 1995 Sun Microsystems, Inc.
 * Copyright (c) 1994 Software Research Associates, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkWinColor.c,v 1.6 2000/07/06 03:17:44 mo Exp $
 */

#include "tkWinInt.h"
#include "tkColor.h"

/*
 * The following structure is used to keep track of each color that is
 * allocated by this module.
 */

typedef struct WinColor {
    TkColor info;		/* Generic color information. */
    int index;			/* Index for GetSysColor(), -1 if color
				 * is not a "live" system color. */
} WinColor;

/*
 * The sysColors array contains the names and index values for the
 * Windows indirect system color names.  In use, all of the names
 * will have the string "System" prepended, but we omit it in the table
 * to save space.
 */

typedef struct {
    char *name;
    int index;
} SystemColorEntry;


static SystemColorEntry sysColors[] = {
    "3dDarkShadow",		COLOR_3DDKSHADOW,
    "3dLight",			COLOR_3DLIGHT,
    "ActiveBorder",		COLOR_ACTIVEBORDER,
    "ActiveCaption",		COLOR_ACTIVECAPTION,
    "AppWorkspace",		COLOR_APPWORKSPACE,
    "Background",		COLOR_BACKGROUND,
    "ButtonFace",		COLOR_BTNFACE,
    "ButtonHighlight",		COLOR_BTNHIGHLIGHT,
    "ButtonShadow",		COLOR_BTNSHADOW,
    "ButtonText",		COLOR_BTNTEXT,
    "CaptionText",		COLOR_CAPTIONTEXT,
    "DisabledText",		COLOR_GRAYTEXT,
    "GrayText",			COLOR_GRAYTEXT,
    "Highlight",		COLOR_HIGHLIGHT,
    "HighlightText",		COLOR_HIGHLIGHTTEXT,
    "InactiveBorder",		COLOR_INACTIVEBORDER,
    "InactiveCaption",		COLOR_INACTIVECAPTION,
    "InactiveCaptionText",	COLOR_INACTIVECAPTIONTEXT,
    "InfoBackground",		COLOR_INFOBK,
    "InfoText",			COLOR_INFOTEXT,
    "Menu",			COLOR_MENU,
    "MenuText",			COLOR_MENUTEXT,
    "Scrollbar",		COLOR_SCROLLBAR,
    "Window",			COLOR_WINDOW,
    "WindowFrame",		COLOR_WINDOWFRAME,
    "WindowText",		COLOR_WINDOWTEXT,
    NULL,			0
};

typedef struct ThreadSpecificData { 
    int ncolors;
} ThreadSpecificData;
static Tcl_ThreadDataKey dataKey;

/*
 * Forward declarations for functions defined later in this file.
 */

static int	FindSystemColor _ANSI_ARGS_((const char *name,
		    XColor *colorPtr, int *indexPtr));

/*
 *----------------------------------------------------------------------
 *
 * FindSystemColor --
 *
 *	This routine finds the color entry that corresponds to the
 *	specified color.
 *
 * Results:
 *	Returns non-zero on success.  The RGB values of the XColor
 *	will be initialized to the proper values on success.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
FindSystemColor(name, colorPtr, indexPtr)
    const char *name;		/* Color name. */
    XColor *colorPtr;		/* Where to store results. */
    int *indexPtr;		/* Out parameter to store color index. */
{
    int l, u, r, i;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    /*
     * Count the number of elements in the color array if we haven't
     * done so yet.
     */

    if (tsdPtr->ncolors == 0) {
	SystemColorEntry *ePtr;
	int version;

	version = LOBYTE(LOWORD(GetVersion()));
	for (ePtr = sysColors; ePtr->name != NULL; ePtr++) {
	    if (version < 4) {
		if (ePtr->index == COLOR_3DDKSHADOW) {
		    ePtr->index = COLOR_BTNSHADOW;
		} else if (ePtr->index == COLOR_3DLIGHT) {
		    ePtr->index = COLOR_BTNHIGHLIGHT;
		}
	    }
	    tsdPtr->ncolors++;
	}
    }

    /*
     * Perform a binary search on the sorted array of colors.
     */

    l = 0;
    u = tsdPtr->ncolors - 1;
    while (l <= u) {
	i = (l + u) / 2;
	r = strcasecmp(name, sysColors[i].name);
	if (r == 0) {
	    break;
	} else if (r < 0) {
	    u = i-1;
	} else {
	    l = i+1;
	}
    }
    if (l > u) {
	return 0;
    }

    *indexPtr = sysColors[i].index;
    colorPtr->pixel = GetSysColor(sysColors[i].index);
    /*
     * x257 is (value<<8 + value) to get the properly bit shifted
     * and padded value.  [Bug: 4919]
     */
    colorPtr->red = GetRValue(colorPtr->pixel) * 257;
    colorPtr->green = GetGValue(colorPtr->pixel) * 257;
    colorPtr->blue = GetBValue(colorPtr->pixel) * 257;
    colorPtr->flags = DoRed|DoGreen|DoBlue;
    colorPtr->pad = 0;
    return 1;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpGetColor --
 *
 *	Allocate a new TkColor for the color with the given name.
 *
 * Results:
 *	Returns a newly allocated TkColor, or NULL on failure.
 *
 * Side effects:
 *	May invalidate the colormap cache associated with tkwin upon
 *	allocating a new colormap entry.  Allocates a new TkColor
 *	structure.
 *
 *----------------------------------------------------------------------
 */

TkColor *
TkpGetColor(tkwin, name)
    Tk_Window tkwin;		/* Window in which color will be used. */
    Tk_Uid name;		/* Name of color to allocated (in form
				 * suitable for passing to XParseColor). */
{
    WinColor *winColPtr;
    XColor color;
    int index = -1;		/* -1 indicates that this is not an indirect
				 * sytem color. */

    /*
     * Check to see if it is a system color or an X color string.  If the
     * color is found, allocate a new WinColor and store the XColor and the
     * system color index.
     */

    if (((strncasecmp(name, "system", 6) == 0)
	    && FindSystemColor(name+6, &color, &index))
	    || XParseColor(Tk_Display(tkwin), Tk_Colormap(tkwin), name,
		    &color)) {
	winColPtr = (WinColor *) ckalloc(sizeof(WinColor));
	winColPtr->info.color = color;
	winColPtr->index = index;

	XAllocColor(Tk_Display(tkwin), Tk_Colormap(tkwin),
		&winColPtr->info.color);
 	return (TkColor *) winColPtr; 
    }
    return (TkColor *) NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpGetColorByValue --
 *
 *	Given a desired set of red-green-blue intensities for a color,
 *	locate a pixel value to use to draw that color in a given
 *	window.
 *
 * Results:
 *	The return value is a pointer to an TkColor structure that
 *	indicates the closest red, blue, and green intensities available
 *	to those specified in colorPtr, and also specifies a pixel
 *	value to use to draw in that color.
 *
 * Side effects:
 *	May invalidate the colormap cache for the specified window.
 *	Allocates a new TkColor structure.
 *
 *----------------------------------------------------------------------
 */

TkColor *
TkpGetColorByValue(tkwin, colorPtr)
    Tk_Window tkwin;		/* Window in which color will be used. */
    XColor *colorPtr;		/* Red, green, and blue fields indicate
				 * desired color. */
{
    WinColor *tkColPtr = (WinColor *) ckalloc(sizeof(WinColor));

    tkColPtr->info.color.red = colorPtr->red;
    tkColPtr->info.color.green = colorPtr->green;
    tkColPtr->info.color.blue = colorPtr->blue;
    tkColPtr->info.color.pixel = 0;
    tkColPtr->index = -1;
    XAllocColor(Tk_Display(tkwin), Tk_Colormap(tkwin), &tkColPtr->info.color);
    return (TkColor *) tkColPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TkpFreeColor --
 *
 *	Release the specified color back to the system.
 *
 * Results:
 *	None
 *
 * Side effects:
 *	Invalidates the colormap cache for the colormap associated with
 *	the given color.
 *
 *----------------------------------------------------------------------
 */

void
TkpFreeColor(tkColPtr)
    TkColor *tkColPtr;		/* Color to be released.  Must have been
				 * allocated by TkpGetColor or
				 * TkpGetColorByValue. */
{
    Screen *screen = tkColPtr->screen;

    XFreeColors(DisplayOfScreen(screen), tkColPtr->colormap,
	    &tkColPtr->color.pixel, 1, 0L);
}

/*
 *----------------------------------------------------------------------
 *
 * TkWinIndexOfColor --
 *
 *	Given a color, return the system color index that was used
 *	to create the color.
 *
 * Results:
 *	If the color was allocated using a system indirect color name,
 *	then the corresponding GetSysColor() index is returned.
 *	Otherwise, -1 is returned.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
TkWinIndexOfColor(colorPtr)
    XColor *colorPtr;
{
    register WinColor *winColPtr = (WinColor *) colorPtr;
    if (winColPtr->info.magic == COLOR_MAGIC) {
	return winColPtr->index;
    }    
    return -1;
}

/*
 *----------------------------------------------------------------------
 *
 * XAllocColor --
 *
 *	Find the closest available color to the specified XColor.
 *
 * Results:
 *	Updates the color argument and returns 1 on success.  Otherwise
 *	returns 0.
 *
 * Side effects:
 *	Allocates a new color in the palette.
 *
 *----------------------------------------------------------------------
 */

int
XAllocColor(display, colormap, color)
    Display* display;
    Colormap colormap;
    XColor* color;
{
    TkWinColormap *cmap = (TkWinColormap *) colormap;
    PALETTEENTRY entry, closeEntry;
    HDC dc = GetDC(NULL);

    entry.peRed = (color->red) >> 8;
    entry.peGreen = (color->green) >> 8;
    entry.peBlue = (color->blue) >> 8;
    entry.peFlags = 0;

    if (GetDeviceCaps(dc, RASTERCAPS) & RC_PALETTE) {
	unsigned long sizePalette = GetDeviceCaps(dc, SIZEPALETTE);
	UINT newPixel, closePixel;
	int new, refCount;
	Tcl_HashEntry *entryPtr;
	UINT index;

	/*
	 * Find the nearest existing palette entry.
	 */
	
	newPixel = RGB(entry.peRed, entry.peGreen, entry.peBlue);
	index = GetNearestPaletteIndex(cmap->palette, newPixel);
	GetPaletteEntries(cmap->palette, index, 1, &closeEntry);
	closePixel = RGB(closeEntry.peRed, closeEntry.peGreen,
		closeEntry.peBlue);

	/*
	 * If this is not a duplicate, allocate a new entry.  Note that
	 * we may get values for index that are above the current size
	 * of the palette.  This happens because we don't shrink the size of
	 * the palette object when we deallocate colors so there may be
	 * stale values that match in the upper slots.  We should ignore
	 * those values and just put the new color in as if the colors
	 * had not matched.
	 */
	
	if ((index >= cmap->size) || (newPixel != closePixel)) {
	    if (cmap->size == sizePalette) {
		color->red   = closeEntry.peRed * 257;
		color->green = closeEntry.peGreen * 257;
		color->blue  = closeEntry.peBlue * 257;
		entry = closeEntry;
		if (index >= cmap->size) {
		    OutputDebugString("XAllocColor: Colormap is bigger than we thought");
		}
	    } else {
		cmap->size++;
		ResizePalette(cmap->palette, cmap->size);
		SetPaletteEntries(cmap->palette, cmap->size - 1, 1, &entry);
	    }
	}

	color->pixel = PALETTERGB(entry.peRed, entry.peGreen, entry.peBlue);
	entryPtr = Tcl_CreateHashEntry(&cmap->refCounts,
		(char *) color->pixel, &new);
	if (new) {
	    refCount = 1;
	} else {
	    refCount = ((int) Tcl_GetHashValue(entryPtr)) + 1;
	}
	Tcl_SetHashValue(entryPtr, (ClientData)refCount);
    } else {
	
	/*
	 * Determine what color will actually be used on non-colormap systems.
	 */
	
	color->pixel = GetNearestColor(dc,
		RGB(entry.peRed, entry.peGreen, entry.peBlue));
	color->red    = GetRValue(color->pixel) * 257;
	color->green  = GetGValue(color->pixel) * 257;
	color->blue   = GetBValue(color->pixel) * 257;
    }

    ReleaseDC(NULL, dc);
    return 1;
}

/*
 *----------------------------------------------------------------------
 *
 * XFreeColors --
 *
 *	Deallocate a block of colors.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Removes entries for the current palette and compacts the
 *	remaining set.
 *
 *----------------------------------------------------------------------
 */

void
XFreeColors(display, colormap, pixels, npixels, planes)
    Display* display;
    Colormap colormap;
    unsigned long* pixels;
    int npixels;
    unsigned long planes;
{
    TkWinColormap *cmap = (TkWinColormap *) colormap;
    COLORREF cref;
    UINT count, index, refCount;
    int i;
    PALETTEENTRY entry, *entries;
    Tcl_HashEntry *entryPtr;
    HDC dc = GetDC(NULL);

    /*
     * We don't have to do anything for non-palette devices.
     */
    
    if (GetDeviceCaps(dc, RASTERCAPS) & RC_PALETTE) {

	/*
	 * This is really slow for large values of npixels.
	 */

	for (i = 0; i < npixels; i++) {
	    entryPtr = Tcl_FindHashEntry(&cmap->refCounts,
		    (char *) pixels[i]);
	    if (!entryPtr) {
		panic("Tried to free a color that isn't allocated.");
	    }
	    refCount = (int) Tcl_GetHashValue(entryPtr) - 1;
	    if (refCount == 0) {
		cref = pixels[i] & 0x00ffffff;
		index = GetNearestPaletteIndex(cmap->palette, cref);
		GetPaletteEntries(cmap->palette, index, 1, &entry);
		if (cref == RGB(entry.peRed, entry.peGreen, entry.peBlue)) {
		    count = cmap->size - index;
		    entries = (PALETTEENTRY *) ckalloc(sizeof(PALETTEENTRY)
			    * count);
		    GetPaletteEntries(cmap->palette, index+1, count, entries);
		    SetPaletteEntries(cmap->palette, index, count, entries);
		    ckfree((char *) entries);
		    cmap->size--;
		} else {
		    panic("Tried to free a color that isn't allocated.");
		}
		Tcl_DeleteHashEntry(entryPtr);
	    } else {
		Tcl_SetHashValue(entryPtr, (ClientData)refCount);
	    }
	}
    }
    ReleaseDC(NULL, dc);
}

/*
 *----------------------------------------------------------------------
 *
 * XCreateColormap --
 *
 *	Allocate a new colormap.
 *
 * Results:
 *	Returns a newly allocated colormap.
 *
 * Side effects:
 *	Allocates an empty palette and color list.
 *
 *----------------------------------------------------------------------
 */

Colormap
XCreateColormap(display, w, visual, alloc)
    Display* display;
    Window w;
    Visual* visual;
    int alloc;
{
    char logPalBuf[sizeof(LOGPALETTE) + 256 * sizeof(PALETTEENTRY)];
    LOGPALETTE *logPalettePtr;
    PALETTEENTRY *entryPtr;
    TkWinColormap *cmap;
    Tcl_HashEntry *hashPtr;
    int new;
    UINT i;
    HPALETTE sysPal;

    /*
     * Allocate a starting palette with all of the reserved colors.
     */

    logPalettePtr = (LOGPALETTE *) logPalBuf;
    logPalettePtr->palVersion = 0x300;
    sysPal = (HPALETTE) GetStockObject(DEFAULT_PALETTE);
    logPalettePtr->palNumEntries = GetPaletteEntries(sysPal, 0, 256,
	    logPalettePtr->palPalEntry);

    cmap = (TkWinColormap *) ckalloc(sizeof(TkWinColormap));
    cmap->size = logPalettePtr->palNumEntries;
    cmap->stale = 0;
    cmap->palette = CreatePalette(logPalettePtr);

    /*
     * Add hash entries for each of the static colors.
     */

    Tcl_InitHashTable(&cmap->refCounts, TCL_ONE_WORD_KEYS);
    for (i = 0; i < logPalettePtr->palNumEntries; i++) {
	entryPtr = logPalettePtr->palPalEntry + i;
	hashPtr = Tcl_CreateHashEntry(&cmap->refCounts, (char*) PALETTERGB(
	    entryPtr->peRed, entryPtr->peGreen, entryPtr->peBlue), &new);
	Tcl_SetHashValue(hashPtr, (ClientData)1);
    }

    return (Colormap)cmap;
}

/*
 *----------------------------------------------------------------------
 *
 * XFreeColormap --
 *
 *	Frees the resources associated with the given colormap.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Deletes the palette associated with the colormap.  Note that
 *	the palette must not be selected into a device context when
 *	this occurs.
 *
 *----------------------------------------------------------------------
 */

void
XFreeColormap(display, colormap)
    Display* display;
    Colormap colormap;
{
    TkWinColormap *cmap = (TkWinColormap *) colormap;
    if (!DeleteObject(cmap->palette)) {
	panic("Unable to free colormap, palette is still selected.");
    }
    Tcl_DeleteHashTable(&cmap->refCounts);
    ckfree((char *) cmap);
}

/*
 *----------------------------------------------------------------------
 *
 * TkWinSelectPalette --
 *
 *	This function sets up the specified device context with a
 *	given palette.  If the palette is stale, it realizes it in
 *	the background unless the palette is the current global
 *	palette.
 *
 * Results:
 *	Returns the previous palette selected into the device context.
 *
 * Side effects:
 *	May change the system palette.
 *
 *----------------------------------------------------------------------
 */

HPALETTE
TkWinSelectPalette(dc, colormap)
    HDC dc;
    Colormap colormap;
{
    TkWinColormap *cmap = (TkWinColormap *) colormap;
    HPALETTE oldPalette;

    oldPalette = SelectPalette(dc, cmap->palette,
	    (cmap->palette == TkWinGetSystemPalette()) ? FALSE : TRUE);
    RealizePalette(dc);
    return oldPalette;
}
@


1.4
log
@touched all sources to ease next import
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tkWinColor.c,v 1.7.6.3 2000/10/02 23:14:06 spolk Exp $
a82 2
static int	GetColorByName _ANSI_ARGS_((char *name, XColor *color));
static int	GetColorByValue _ANSI_ARGS_((char *value, XColor *color));
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tkWinColor.c,v 1.12 1999/01/26 04:11:44 jingham Exp $
d15 2
a16 2
#include <tkColor.h>
#include <tkWinInt.h>
a29 6
 * colorTable is a hash table used to look up X colors by name.
 */

static Tcl_HashTable colorTable;

/*
d72 4
a75 1
static int ncolors = 0;
d111 2
d119 1
a119 1
    if (ncolors == 0) {
d132 1
a132 1
	    ncolors++;
d141 1
a141 1
    u = ncolors - 1;
d159 7
a165 3
    colorPtr->red = GetRValue(colorPtr->pixel) << 8;
    colorPtr->green = GetGValue(colorPtr->pixel) << 8;
    colorPtr->blue = GetBValue(colorPtr->pixel) << 8;
d345 1
a345 1
    
d380 3
a382 3
		color->red = closeEntry.peRed << 8;
		color->green = closeEntry.peGreen << 8;
		color->blue = closeEntry.peBlue << 8;
d411 3
a413 3
	color->red = (GetRValue(color->pixel) << 8);
	color->green = (GetGValue(color->pixel) << 8);
	color->blue = (GetBValue(color->pixel) << 8);
a617 28
}

/* CYGNUS LOCAL: The system colors have changed.  Update them.  */

static void
ChangeColor(tkColPtr)
    TkColor *tkColPtr;
{
    WinColor *winColPtr = (WinColor *) tkColPtr;

    if (winColPtr->index != -1) {
	unsigned long pixel;

	pixel = GetSysColor(winColPtr->index);
	if (pixel != winColPtr->info.color.pixel) {
	    winColPtr->info.color.pixel = pixel;
	    winColPtr->info.color.red = GetRValue(pixel) << 8;
	    winColPtr->info.color.green = GetGValue(pixel) << 8;
	    winColPtr->info.color.blue = GetBValue(pixel) << 8;
	    TkColorChanged((TkColor *) winColPtr);
	}
    }
}

void
TkWinSysColorChange()
{
    TkMapOverColors(ChangeColor);
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tkWinColor.c,v 1.7.6.3 2000/10/02 23:14:06 spolk Exp $
d15 2
a16 2
#include "tkWinInt.h"
#include "tkColor.h"
d30 6
d78 1
a78 4
typedef struct ThreadSpecificData { 
    int ncolors;
} ThreadSpecificData;
static Tcl_ThreadDataKey dataKey;
a113 2
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
d120 1
a120 1
    if (tsdPtr->ncolors == 0) {
d133 1
a133 1
	    tsdPtr->ncolors++;
d142 1
a142 1
    u = tsdPtr->ncolors - 1;
d160 3
a162 7
    /*
     * x257 is (value<<8 + value) to get the properly bit shifted
     * and padded value.  [Bug: 4919]
     */
    colorPtr->red = GetRValue(colorPtr->pixel) * 257;
    colorPtr->green = GetGValue(colorPtr->pixel) * 257;
    colorPtr->blue = GetBValue(colorPtr->pixel) * 257;
d342 1
a342 1

d377 3
a379 3
		color->red   = closeEntry.peRed * 257;
		color->green = closeEntry.peGreen * 257;
		color->blue  = closeEntry.peBlue * 257;
d408 3
a410 3
	color->red    = GetRValue(color->pixel) * 257;
	color->green  = GetGValue(color->pixel) * 257;
	color->blue   = GetBValue(color->pixel) * 257;
d615 28
@


1.1.1.3
log
@import tk 8.4.0
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tkWinColor.c,v 1.6 2000/07/06 03:17:44 mo Exp $
d83 2
@


