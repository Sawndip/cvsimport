head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.20.24.42;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.12;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.24;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.50;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.31;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.06;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@/* 
 * tkCanvArc.c --
 *
 *	This file implements arc items for canvas widgets.
 *
 * Copyright (c) 1992-1994 The Regents of the University of California.
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkCanvArc.c,v 1.10 2002/08/05 04:30:38 dgp Exp $
 */

#include <stdio.h>
#include "tkPort.h"
#include "tkInt.h"
#include "tkCanvas.h"
/*
 * The structure below defines the record for each arc item.
 */

typedef enum {
    PIESLICE_STYLE, CHORD_STYLE, ARC_STYLE
} Style;

typedef struct ArcItem  {
    Tk_Item header;		/* Generic stuff that's the same for all
				 * types.  MUST BE FIRST IN STRUCTURE. */
    Tk_Outline outline;		/* Outline structure */
    double bbox[4];		/* Coordinates (x1, y1, x2, y2) of bounding
				 * box for oval of which arc is a piece. */
    double start;		/* Angle at which arc begins, in degrees
				 * between 0 and 360. */
    double extent;		/* Extent of arc (angular distance from
				 * start to end of arc) in degrees between
				 * -360 and 360. */
    double *outlinePtr;		/* Points to (x,y) coordinates for points
				 * that define one or two closed polygons
				 * representing the portion of the outline
				 * that isn't part of the arc (the V-shape
				 * for a pie slice or a line-like segment
				 * for a chord).  Malloc'ed. */
    int numOutlinePoints;	/* Number of points at outlinePtr.  Zero
				 * means no space allocated. */
    Tk_TSOffset tsoffset;
    XColor *fillColor;		/* Color for filling arc (used for drawing
				 * outline too when style is "arc").  NULL
				 * means don't fill arc. */
    XColor *activeFillColor;	/* Color for filling arc (used for drawing
				 * outline too when style is "arc" and state
				 * is "active").  NULL means use fillColor. */
    XColor *disabledFillColor;	/* Color for filling arc (used for drawing
				 * outline too when style is "arc" and state
				 * is "disabled". NULL means use fillColor */
    Pixmap fillStipple;		/* Stipple bitmap for filling item. */
    Pixmap activeFillStipple;	/* Stipple bitmap for filling item if state
				 * is active. */
    Pixmap disabledFillStipple;	/* Stipple bitmap for filling item if state
				 * is disabled. */
    Style style;		/* How to draw arc: arc, chord, or pieslice. */
    GC fillGC;			/* Graphics context for filling item. */
    double center1[2];		/* Coordinates of center of arc outline at
				 * start (see ComputeArcOutline). */
    double center2[2];		/* Coordinates of center of arc outline at
				 * start+extent (see ComputeArcOutline). */
} ArcItem;

/*
 * The definitions below define the sizes of the polygons used to
 * display outline information for various styles of arcs:
 */

#define CHORD_OUTLINE_PTS	7
#define PIE_OUTLINE1_PTS	6
#define PIE_OUTLINE2_PTS	7

/*
 * Information used for parsing configuration specs:
 */

static int	StyleParseProc _ANSI_ARGS_((
		    ClientData clientData, Tcl_Interp *interp,
		    Tk_Window tkwin, CONST char *value,
		    char *widgRec, int offset));
static char *	StylePrintProc _ANSI_ARGS_((
		    ClientData clientData, Tk_Window tkwin,
		    char *widgRec, int offset,
		    Tcl_FreeProc **freeProcPtr));

static Tk_CustomOption stateOption = {
    (Tk_OptionParseProc *) TkStateParseProc,
    TkStatePrintProc, (ClientData) 2
};
static Tk_CustomOption styleOption = {
    (Tk_OptionParseProc *) StyleParseProc,
    StylePrintProc, (ClientData) NULL
};
static Tk_CustomOption tagsOption = {
    (Tk_OptionParseProc *) Tk_CanvasTagsParseProc,
    Tk_CanvasTagsPrintProc, (ClientData) NULL
};
static Tk_CustomOption dashOption = {
    (Tk_OptionParseProc *) TkCanvasDashParseProc,
    TkCanvasDashPrintProc, (ClientData) NULL
};
static Tk_CustomOption offsetOption = {
    (Tk_OptionParseProc *) TkOffsetParseProc,
    TkOffsetPrintProc, (ClientData) (TK_OFFSET_RELATIVE)
};
static Tk_CustomOption pixelOption = {
    (Tk_OptionParseProc *) TkPixelParseProc,
    TkPixelPrintProc, (ClientData) NULL
};

static Tk_ConfigSpec configSpecs[] = {
    {TK_CONFIG_CUSTOM, "-activedash", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, outline.activeDash),
	TK_CONFIG_NULL_OK, &dashOption},
    {TK_CONFIG_COLOR, "-activefill", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, activeFillColor),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_COLOR, "-activeoutline", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, outline.activeColor),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_BITMAP, "-activeoutlinestipple", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, outline.activeStipple),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_BITMAP, "-activestipple", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, activeFillStipple),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_CUSTOM, "-activewidth", (char *) NULL, (char *) NULL,
	"0.0", Tk_Offset(ArcItem, outline.activeWidth),
	TK_CONFIG_DONT_SET_DEFAULT, &pixelOption},
    {TK_CONFIG_CUSTOM, "-dash", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, outline.dash),
	TK_CONFIG_NULL_OK, &dashOption},
    {TK_CONFIG_PIXELS, "-dashoffset", (char *) NULL, (char *) NULL,
	"0", Tk_Offset(ArcItem, outline.offset), TK_CONFIG_DONT_SET_DEFAULT},
    {TK_CONFIG_CUSTOM, "-disableddash", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, outline.disabledDash),
	TK_CONFIG_NULL_OK, &dashOption},
    {TK_CONFIG_COLOR, "-disabledfill", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, disabledFillColor),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_COLOR, "-disabledoutline", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, outline.disabledColor),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_BITMAP, "-disabledoutlinestipple", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, outline.disabledStipple),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_BITMAP, "-disabledstipple", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, disabledFillStipple),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_CUSTOM, "-disabledwidth", (char *) NULL, (char *) NULL,
	"0.0", Tk_Offset(ArcItem, outline.disabledWidth),
	TK_CONFIG_DONT_SET_DEFAULT, &pixelOption},
    {TK_CONFIG_DOUBLE, "-extent", (char *) NULL, (char *) NULL,
	"90", Tk_Offset(ArcItem, extent), TK_CONFIG_DONT_SET_DEFAULT},
    {TK_CONFIG_COLOR, "-fill", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, fillColor), TK_CONFIG_NULL_OK},
    {TK_CONFIG_CUSTOM, "-offset", (char *) NULL, (char *) NULL,
	"0,0", Tk_Offset(ArcItem, tsoffset),
	TK_CONFIG_DONT_SET_DEFAULT, &offsetOption},
    {TK_CONFIG_COLOR, "-outline", (char *) NULL, (char *) NULL,
	"black", Tk_Offset(ArcItem, outline.color), TK_CONFIG_NULL_OK},
    {TK_CONFIG_CUSTOM, "-outlineoffset", (char *) NULL, (char *) NULL,
	"0,0", Tk_Offset(ArcItem, outline.tsoffset),
	TK_CONFIG_DONT_SET_DEFAULT, &offsetOption},
    {TK_CONFIG_BITMAP, "-outlinestipple", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, outline.stipple),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_DOUBLE, "-start", (char *) NULL, (char *) NULL,
	"0", Tk_Offset(ArcItem, start), TK_CONFIG_DONT_SET_DEFAULT},
    {TK_CONFIG_CUSTOM, "-state", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(Tk_Item, state), TK_CONFIG_NULL_OK,
	&stateOption},
    {TK_CONFIG_BITMAP, "-stipple", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, fillStipple), TK_CONFIG_NULL_OK},
    {TK_CONFIG_CUSTOM, "-style", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, style), TK_CONFIG_DONT_SET_DEFAULT,
	&styleOption},
    {TK_CONFIG_CUSTOM, "-tags", (char *) NULL, (char *) NULL,
	(char *) NULL, 0, TK_CONFIG_NULL_OK, &tagsOption},
    {TK_CONFIG_CUSTOM, "-width", (char *) NULL, (char *) NULL,
	"1.0", Tk_Offset(ArcItem, outline.width), TK_CONFIG_DONT_SET_DEFAULT,
	&pixelOption},
    {TK_CONFIG_END, (char *) NULL, (char *) NULL, (char *) NULL,
	(char *) NULL, 0, 0}
};

/*
 * Prototypes for procedures defined in this file:
 */

static void		ComputeArcBbox _ANSI_ARGS_((Tk_Canvas canvas,
			    ArcItem *arcPtr));
static int		ConfigureArc _ANSI_ARGS_((Tcl_Interp *interp,
			    Tk_Canvas canvas, Tk_Item *itemPtr, int objc,
			    Tcl_Obj *CONST objv[], int flags));
static int		CreateArc _ANSI_ARGS_((Tcl_Interp *interp,
			    Tk_Canvas canvas, struct Tk_Item *itemPtr,
			    int objc, Tcl_Obj *CONST objv[]));
static void		DeleteArc _ANSI_ARGS_((Tk_Canvas canvas,
			    Tk_Item *itemPtr, Display *display));
static void		DisplayArc _ANSI_ARGS_((Tk_Canvas canvas,
			    Tk_Item *itemPtr, Display *display, Drawable dst,
			    int x, int y, int width, int height));
static int		ArcCoords _ANSI_ARGS_((Tcl_Interp *interp,
			    Tk_Canvas canvas, Tk_Item *itemPtr, int objc,
			    Tcl_Obj *CONST objv[]));
static int		ArcToArea _ANSI_ARGS_((Tk_Canvas canvas,
			    Tk_Item *itemPtr, double *rectPtr));
static double		ArcToPoint _ANSI_ARGS_((Tk_Canvas canvas,
			    Tk_Item *itemPtr, double *coordPtr));
static int		ArcToPostscript _ANSI_ARGS_((Tcl_Interp *interp,
			    Tk_Canvas canvas, Tk_Item *itemPtr, int prepass));
static void		ScaleArc _ANSI_ARGS_((Tk_Canvas canvas,
			    Tk_Item *itemPtr, double originX, double originY,
			    double scaleX, double scaleY));
static void		TranslateArc _ANSI_ARGS_((Tk_Canvas canvas,
			    Tk_Item *itemPtr, double deltaX, double deltaY));
static int		AngleInRange _ANSI_ARGS_((double x, double y,
			    double start, double extent));
static void		ComputeArcOutline _ANSI_ARGS_((Tk_Canvas canvas,
			    ArcItem *arcPtr));
static int		HorizLineToArc _ANSI_ARGS_((double x1, double x2,
			    double y, double rx, double ry,
			    double start, double extent));
static int		VertLineToArc _ANSI_ARGS_((double x, double y1,
			    double y2, double rx, double ry,
			    double start, double extent));

/*
 * The structures below defines the arc item types by means of procedures
 * that can be invoked by generic item code.
 */

Tk_ItemType tkArcType = {
    "arc",				/* name */
    sizeof(ArcItem),			/* itemSize */
    CreateArc,				/* createProc */
    configSpecs,			/* configSpecs */
    ConfigureArc,			/* configureProc */
    ArcCoords,				/* coordProc */
    DeleteArc,				/* deleteProc */
    DisplayArc,				/* displayProc */
    TK_CONFIG_OBJS,			/* flags */
    ArcToPoint,				/* pointProc */
    ArcToArea,				/* areaProc */
    ArcToPostscript,			/* postscriptProc */
    ScaleArc,				/* scaleProc */
    TranslateArc,			/* translateProc */
    (Tk_ItemIndexProc *) NULL,		/* indexProc */
    (Tk_ItemCursorProc *) NULL,		/* icursorProc */
    (Tk_ItemSelectionProc *) NULL,	/* selectionProc */
    (Tk_ItemInsertProc *) NULL,		/* insertProc */
    (Tk_ItemDCharsProc *) NULL,		/* dTextProc */
    (Tk_ItemType *) NULL,		/* nextPtr */
};

#ifndef PI
#    define PI 3.14159265358979323846
#endif


/*
 *--------------------------------------------------------------
 *
 * CreateArc --
 *
 *	This procedure is invoked to create a new arc item in
 *	a canvas.
 *
 * Results:
 *	A standard Tcl return value.  If an error occurred in
 *	creating the item, then an error message is left in
 *	the interp's result;  in this case itemPtr is
 *	left uninitialized, so it can be safely freed by the
 *	caller.
 *
 * Side effects:
 *	A new arc item is created.
 *
 *--------------------------------------------------------------
 */

static int
CreateArc(interp, canvas, itemPtr, objc, objv)
    Tcl_Interp *interp;			/* Interpreter for error reporting. */
    Tk_Canvas canvas;			/* Canvas to hold new item. */
    Tk_Item *itemPtr;			/* Record to hold new item;  header
					 * has been initialized by caller. */
    int objc;				/* Number of arguments in objv. */
    Tcl_Obj *CONST objv[];		/* Arguments describing arc. */
{
    ArcItem *arcPtr = (ArcItem *) itemPtr;
    int i = 4;

    if (objc == 1) {
	i = 1;
    } else if (objc > 1) {
	char *arg = Tcl_GetString(objv[1]);
	if ((arg[0] == '-') && (arg[1] >= 'a') && (arg[1] <= 'z')) {
	    i = 1;
	}
    }

    if (objc < i) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
		Tk_PathName(Tk_CanvasTkwin(canvas)), " create ",
		itemPtr->typePtr->name, " x1 y1 x2 y2 ?options?\"",
		(char *) NULL);
	return TCL_ERROR;
    }

    /*
     * Carry out initialization that is needed in order to clean
     * up after errors during the the remainder of this procedure.
     */

    Tk_CreateOutline(&(arcPtr->outline));
    arcPtr->start = 0;
    arcPtr->extent = 90;
    arcPtr->outlinePtr = NULL;
    arcPtr->numOutlinePoints = 0;
    arcPtr->tsoffset.flags = 0;
    arcPtr->tsoffset.xoffset = 0;
    arcPtr->tsoffset.yoffset = 0;
    arcPtr->fillColor = NULL;
    arcPtr->activeFillColor = NULL;
    arcPtr->disabledFillColor = NULL;
    arcPtr->fillStipple = None;
    arcPtr->activeFillStipple = None;
    arcPtr->disabledFillStipple = None;
    arcPtr->style = PIESLICE_STYLE;
    arcPtr->fillGC = None;

    /*
     * Process the arguments to fill in the item record.
     */

    if ((ArcCoords(interp, canvas, itemPtr, i, objv) != TCL_OK)) {
	goto error;
    }
    if (ConfigureArc(interp, canvas, itemPtr, objc-4, objv+4, 0) == TCL_OK) {
	return TCL_OK;
    }
    error:
    DeleteArc(canvas, itemPtr, Tk_Display(Tk_CanvasTkwin(canvas)));
    return TCL_ERROR;
}

/*
 *--------------------------------------------------------------
 *
 * ArcCoords --
 *
 *	This procedure is invoked to process the "coords" widget
 *	command on arcs.  See the user documentation for details
 *	on what it does.
 *
 * Results:
 *	Returns TCL_OK or TCL_ERROR, and sets the interp's result.
 *
 * Side effects:
 *	The coordinates for the given item may be changed.
 *
 *--------------------------------------------------------------
 */

static int
ArcCoords(interp, canvas, itemPtr, objc, objv)
    Tcl_Interp *interp;			/* Used for error reporting. */
    Tk_Canvas canvas;			/* Canvas containing item. */
    Tk_Item *itemPtr;			/* Item whose coordinates are to be
					 * read or modified. */
    int objc;				/* Number of coordinates supplied in
					 * objv. */
    Tcl_Obj *CONST objv[];		/* Array of coordinates: x1, y1,
					 * x2, y2, ... */
{
    ArcItem *arcPtr = (ArcItem *) itemPtr;

    if (objc == 0) {
	Tcl_Obj *obj = Tcl_NewObj();
	Tcl_Obj *subobj = Tcl_NewDoubleObj(arcPtr->bbox[0]);
	Tcl_ListObjAppendElement(interp, obj, subobj);
	subobj = Tcl_NewDoubleObj(arcPtr->bbox[1]);
	Tcl_ListObjAppendElement(interp, obj, subobj);
	subobj = Tcl_NewDoubleObj(arcPtr->bbox[2]);
	Tcl_ListObjAppendElement(interp, obj, subobj);
	subobj = Tcl_NewDoubleObj(arcPtr->bbox[3]);
	Tcl_ListObjAppendElement(interp, obj, subobj);
	Tcl_SetObjResult(interp, obj);
    } else if ((objc == 1)||(objc == 4)) {
	if (objc==1) {
	    if (Tcl_ListObjGetElements(interp, objv[0], &objc,
		    (Tcl_Obj ***) &objv) != TCL_OK) {
		return TCL_ERROR;
	    } else if (objc != 4) {
		char buf[64 + TCL_INTEGER_SPACE];
	
		sprintf(buf, "wrong # coordinates: expected 4, got %d", objc);
		Tcl_SetResult(interp, buf, TCL_VOLATILE);
		return TCL_ERROR;
	    }
	}
	if ((Tk_CanvasGetCoordFromObj(interp, canvas, objv[0],
 		    &arcPtr->bbox[0]) != TCL_OK)
		|| (Tk_CanvasGetCoordFromObj(interp, canvas, objv[1],
		    &arcPtr->bbox[1]) != TCL_OK)
		|| (Tk_CanvasGetCoordFromObj(interp, canvas, objv[2],
			&arcPtr->bbox[2]) != TCL_OK)
		|| (Tk_CanvasGetCoordFromObj(interp, canvas, objv[3],
			&arcPtr->bbox[3]) != TCL_OK)) {
	    return TCL_ERROR;
	}
	ComputeArcBbox(canvas, arcPtr);
    } else {
	char buf[64 + TCL_INTEGER_SPACE];
	
	sprintf(buf, "wrong # coordinates: expected 0 or 4, got %d", objc);
	Tcl_SetResult(interp, buf, TCL_VOLATILE);
	return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * ConfigureArc --
 *
 *	This procedure is invoked to configure various aspects
 *	of a arc item, such as its outline and fill colors.
 *
 * Results:
 *	A standard Tcl result code.  If an error occurs, then
 *	an error message is left in the interp's result.
 *
 * Side effects:
 *	Configuration information, such as colors and stipple
 *	patterns, may be set for itemPtr.
 *
 *--------------------------------------------------------------
 */

static int
ConfigureArc(interp, canvas, itemPtr, objc, objv, flags)
    Tcl_Interp *interp;		/* Used for error reporting. */
    Tk_Canvas canvas;		/* Canvas containing itemPtr. */
    Tk_Item *itemPtr;		/* Arc item to reconfigure. */
    int objc;			/* Number of elements in objv.  */
    Tcl_Obj *CONST objv[];	/* Arguments describing things to configure. */
    int flags;			/* Flags to pass to Tk_ConfigureWidget. */
{
    ArcItem *arcPtr = (ArcItem *) itemPtr;
    XGCValues gcValues;
    GC newGC;
    unsigned long mask;
    int i;
    Tk_Window tkwin;
    Tk_TSOffset *tsoffset;
    XColor *color;
    Pixmap stipple;
    Tk_State state;

    tkwin = Tk_CanvasTkwin(canvas);
    if (TCL_OK != Tk_ConfigureWidget(interp, tkwin, configSpecs, objc,
	    (CONST char **) objv, (char *) arcPtr, flags|TK_CONFIG_OBJS)) {
	return TCL_ERROR;
    }

    state = itemPtr->state;

    /*
     * A few of the options require additional processing, such as
     * style and graphics contexts.
     */

    if (arcPtr->outline.activeWidth > arcPtr->outline.width ||
	    arcPtr->outline.activeDash.number != 0 ||
	    arcPtr->outline.activeColor != NULL ||
	    arcPtr->outline.activeStipple != None ||
	    arcPtr->activeFillColor != NULL ||
	    arcPtr->activeFillStipple != None) {
	itemPtr->redraw_flags |= TK_ITEM_STATE_DEPENDANT;
    } else {
	itemPtr->redraw_flags &= ~TK_ITEM_STATE_DEPENDANT;
    }

    tsoffset = &arcPtr->outline.tsoffset;
    flags = tsoffset->flags;
    if (flags & TK_OFFSET_LEFT) {
	tsoffset->xoffset = (int) (arcPtr->bbox[0] + 0.5);
    } else if (flags & TK_OFFSET_CENTER) {
	tsoffset->xoffset = (int) ((arcPtr->bbox[0]+arcPtr->bbox[2]+1)/2);
    } else if (flags & TK_OFFSET_RIGHT) {
	tsoffset->xoffset = (int) (arcPtr->bbox[2] + 0.5);
    }
    if (flags & TK_OFFSET_TOP) {
	tsoffset->yoffset = (int) (arcPtr->bbox[1] + 0.5);
    } else if (flags & TK_OFFSET_MIDDLE) {
	tsoffset->yoffset = (int) ((arcPtr->bbox[1]+arcPtr->bbox[3]+1)/2);
    } else if (flags & TK_OFFSET_BOTTOM) {
	tsoffset->yoffset = (int) (arcPtr->bbox[2] + 0.5);
    }

    i = (int) (arcPtr->start/360.0);
    arcPtr->start -= i*360.0;
    if (arcPtr->start < 0) {
	arcPtr->start += 360.0;
    }
    i = (int) (arcPtr->extent/360.0);
    arcPtr->extent -= i*360.0;

    mask = Tk_ConfigOutlineGC(&gcValues, canvas, itemPtr,
	    &(arcPtr->outline));
    if (mask) {
	gcValues.cap_style = CapButt;
	mask |= GCCapStyle;
	newGC = Tk_GetGC(tkwin, mask, &gcValues);
    } else {
	newGC = None;
    }
    if (arcPtr->outline.gc != None) {
	Tk_FreeGC(Tk_Display(tkwin), arcPtr->outline.gc);
    }
    arcPtr->outline.gc = newGC;

    if(state == TK_STATE_NULL) {
	state = ((TkCanvas *)canvas)->canvas_state;
    }
    if (state==TK_STATE_HIDDEN) {
	ComputeArcBbox(canvas, arcPtr);
	return TCL_OK;
    }

    color = arcPtr->fillColor;
    stipple = arcPtr->fillStipple;
    if (((TkCanvas *)canvas)->currentItemPtr == itemPtr) {
	if (arcPtr->activeFillColor!=NULL) {
	    color = arcPtr->activeFillColor;
	}
	if (arcPtr->activeFillStipple!=None) {
	    stipple = arcPtr->activeFillStipple;
	}
    } else if (state==TK_STATE_DISABLED) {
	if (arcPtr->disabledFillColor!=NULL) {
	    color = arcPtr->disabledFillColor;
	}
	if (arcPtr->disabledFillStipple!=None) {
	    stipple = arcPtr->disabledFillStipple;
	}
      }

    if (arcPtr->style == ARC_STYLE) {
	newGC = None;
    } else if (color == NULL) {
	newGC = None;
    } else {
	gcValues.foreground = color->pixel;
	if (arcPtr->style == CHORD_STYLE) {
	    gcValues.arc_mode = ArcChord;
	} else {
	    gcValues.arc_mode = ArcPieSlice;
	}
	mask = GCForeground|GCArcMode;
	if (stipple != None) {
	    gcValues.stipple = stipple;
	    gcValues.fill_style = FillStippled;
	    mask |= GCStipple|GCFillStyle;
	}
	newGC = Tk_GetGC(tkwin, mask, &gcValues);
    }
    if (arcPtr->fillGC != None) {
	Tk_FreeGC(Tk_Display(tkwin), arcPtr->fillGC);
    }
    arcPtr->fillGC = newGC;

    tsoffset = &arcPtr->tsoffset;
    flags = tsoffset->flags;
    if (flags & TK_OFFSET_LEFT) {
	tsoffset->xoffset = (int) (arcPtr->bbox[0] + 0.5);
    } else if (flags & TK_OFFSET_CENTER) {
	tsoffset->xoffset = (int) ((arcPtr->bbox[0]+arcPtr->bbox[2]+1)/2);
    } else if (flags & TK_OFFSET_RIGHT) {
	tsoffset->xoffset = (int) (arcPtr->bbox[2] + 0.5);
    }
    if (flags & TK_OFFSET_TOP) {
	tsoffset->yoffset = (int) (arcPtr->bbox[1] + 0.5);
    } else if (flags & TK_OFFSET_MIDDLE) {
	tsoffset->yoffset = (int) ((arcPtr->bbox[1]+arcPtr->bbox[3]+1)/2);
    } else if (flags & TK_OFFSET_BOTTOM) {
	tsoffset->yoffset = (int) (arcPtr->bbox[3] + 0.5);
    }

    ComputeArcBbox(canvas, arcPtr);
    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * DeleteArc --
 *
 *	This procedure is called to clean up the data structure
 *	associated with a arc item.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Resources associated with itemPtr are released.
 *
 *--------------------------------------------------------------
 */

static void
DeleteArc(canvas, itemPtr, display)
    Tk_Canvas canvas;			/* Info about overall canvas. */
    Tk_Item *itemPtr;			/* Item that is being deleted. */
    Display *display;			/* Display containing window for
					 * canvas. */
{
    ArcItem *arcPtr = (ArcItem *) itemPtr;

    Tk_DeleteOutline(display, &(arcPtr->outline));
    if (arcPtr->numOutlinePoints != 0) {
	ckfree((char *) arcPtr->outlinePtr);
    }
    if (arcPtr->fillColor != NULL) {
	Tk_FreeColor(arcPtr->fillColor);
    }
    if (arcPtr->activeFillColor != NULL) {
	Tk_FreeColor(arcPtr->activeFillColor);
    }
    if (arcPtr->disabledFillColor != NULL) {
	Tk_FreeColor(arcPtr->disabledFillColor);
    }
    if (arcPtr->fillStipple != None) {
	Tk_FreeBitmap(display, arcPtr->fillStipple);
    }
    if (arcPtr->activeFillStipple != None) {
	Tk_FreeBitmap(display, arcPtr->activeFillStipple);
    }
    if (arcPtr->disabledFillStipple != None) {
	Tk_FreeBitmap(display, arcPtr->disabledFillStipple);
    }
    if (arcPtr->fillGC != None) {
	Tk_FreeGC(display, arcPtr->fillGC);
    }
}

/*
 *--------------------------------------------------------------
 *
 * ComputeArcBbox --
 *
 *	This procedure is invoked to compute the bounding box of
 *	all the pixels that may be drawn as part of an arc.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The fields x1, y1, x2, and y2 are updated in the header
 *	for itemPtr.
 *
 *--------------------------------------------------------------
 */

	/* ARGSUSED */
static void
ComputeArcBbox(canvas, arcPtr)
    Tk_Canvas canvas;			/* Canvas that contains item. */
    ArcItem *arcPtr;			/* Item whose bbox is to be
					 * recomputed. */
{
    double tmp, center[2], point[2];
    double width;
    Tk_State state = arcPtr->header.state;

    if(state == TK_STATE_NULL) {
	state = ((TkCanvas *)canvas)->canvas_state;
    }

    width = arcPtr->outline.width;
    if (width < 1.0) {
	width = 1.0;
    }
    if (state==TK_STATE_HIDDEN) {
	arcPtr->header.x1 = arcPtr->header.x2 =
	arcPtr->header.y1 = arcPtr->header.y2 = -1;
	return;
    } else if (((TkCanvas *)canvas)->currentItemPtr == (Tk_Item *) arcPtr) {
	if (arcPtr->outline.activeWidth>width) {
	    width = arcPtr->outline.activeWidth;
	}
    } else if (state==TK_STATE_DISABLED) {
	if (arcPtr->outline.disabledWidth>0) {
	    width = arcPtr->outline.disabledWidth;
	}
    }

    /*
     * Make sure that the first coordinates are the lowest ones.
     */

    if (arcPtr->bbox[1] > arcPtr->bbox[3]) {
	double tmp;
	tmp = arcPtr->bbox[3];
	arcPtr->bbox[3] = arcPtr->bbox[1];
	arcPtr->bbox[1] = tmp;
    }
    if (arcPtr->bbox[0] > arcPtr->bbox[2]) {
	double tmp;
	tmp = arcPtr->bbox[2];
	arcPtr->bbox[2] = arcPtr->bbox[0];
	arcPtr->bbox[0] = tmp;
    }

    ComputeArcOutline(canvas,arcPtr);

    /*
     * To compute the bounding box, start with the the bbox formed
     * by the two endpoints of the arc.  Then add in the center of
     * the arc's oval (if relevant) and the 3-o'clock, 6-o'clock,
     * 9-o'clock, and 12-o'clock positions, if they are relevant.
     */

    arcPtr->header.x1 = arcPtr->header.x2 = (int) arcPtr->center1[0];
    arcPtr->header.y1 = arcPtr->header.y2 = (int) arcPtr->center1[1];
    TkIncludePoint((Tk_Item *) arcPtr, arcPtr->center2);
    center[0] = (arcPtr->bbox[0] + arcPtr->bbox[2])/2;
    center[1] = (arcPtr->bbox[1] + arcPtr->bbox[3])/2;
    if (arcPtr->style == PIESLICE_STYLE) {
	TkIncludePoint((Tk_Item *) arcPtr, center);
    }

    tmp = -arcPtr->start;
    if (tmp < 0) {
	tmp += 360.0;
    }
    if ((tmp < arcPtr->extent) || ((tmp-360) > arcPtr->extent)) {
	point[0] = arcPtr->bbox[2];
	point[1] = center[1];
	TkIncludePoint((Tk_Item *) arcPtr, point);
    }
    tmp = 90.0 - arcPtr->start;
    if (tmp < 0) {
	tmp += 360.0;
    }
    if ((tmp < arcPtr->extent) || ((tmp-360) > arcPtr->extent)) {
	point[0] = center[0];
	point[1] = arcPtr->bbox[1];
	TkIncludePoint((Tk_Item *) arcPtr, point);
    }
    tmp = 180.0 - arcPtr->start;
    if (tmp < 0) {
	tmp += 360.0;
    }
    if ((tmp < arcPtr->extent) || ((tmp-360) > arcPtr->extent)) {
	point[0] = arcPtr->bbox[0];
	point[1] = center[1];
	TkIncludePoint((Tk_Item *) arcPtr, point);
    }
    tmp = 270.0 - arcPtr->start;
    if (tmp < 0) {
	tmp += 360.0;
    }
    if ((tmp < arcPtr->extent) || ((tmp-360) > arcPtr->extent)) {
	point[0] = center[0];
	point[1] = arcPtr->bbox[3];
	TkIncludePoint((Tk_Item *) arcPtr, point);
    }

    /*
     * Lastly, expand by the width of the arc (if the arc's outline is
     * being drawn) and add one extra pixel just for safety.
     */

    if (arcPtr->outline.gc == None) {
	tmp = 1;
    } else {
	tmp = (int) ((width + 1.0)/2.0 + 1);
    }
    arcPtr->header.x1 -= (int) tmp;
    arcPtr->header.y1 -= (int) tmp;
    arcPtr->header.x2 += (int) tmp;
    arcPtr->header.y2 += (int) tmp;
}

/*
 *--------------------------------------------------------------
 *
 * DisplayArc --
 *
 *	This procedure is invoked to draw an arc item in a given
 *	drawable.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	ItemPtr is drawn in drawable using the transformation
 *	information in canvas.
 *
 *--------------------------------------------------------------
 */

static void
DisplayArc(canvas, itemPtr, display, drawable, x, y, width, height)
    Tk_Canvas canvas;			/* Canvas that contains item. */
    Tk_Item *itemPtr;			/* Item to be displayed. */
    Display *display;			/* Display on which to draw item. */
    Drawable drawable;			/* Pixmap or window in which to draw
					 * item. */
    int x, y, width, height;		/* Describes region of canvas that
					 * must be redisplayed (not used). */
{
    ArcItem *arcPtr = (ArcItem *) itemPtr;
    short x1, y1, x2, y2;
    int start, extent, dashnumber;
    double lineWidth;
    Tk_State state = itemPtr->state;
    Pixmap stipple;

    if(state == TK_STATE_NULL) {
	state = ((TkCanvas *)canvas)->canvas_state;
    }
    lineWidth = arcPtr->outline.width;
    if (lineWidth < 1.0) {
	lineWidth = 1.0;
    }
    dashnumber = arcPtr->outline.dash.number;
    stipple = arcPtr->fillStipple;
    if (((TkCanvas *)canvas)->currentItemPtr == itemPtr) {
	if (arcPtr->outline.activeWidth>lineWidth) {
	    lineWidth = arcPtr->outline.activeWidth;
	}
	if (arcPtr->outline.activeDash.number != 0) {
	    dashnumber = arcPtr->outline.activeDash.number;
	}
	if (arcPtr->activeFillStipple != None) {
	    stipple = arcPtr->activeFillStipple;
	}
    } else if (state==TK_STATE_DISABLED) {
	if (arcPtr->outline.disabledWidth > 0) {
	    lineWidth = arcPtr->outline.disabledWidth;
	}
	if (arcPtr->outline.disabledDash.number != 0) {
	    dashnumber = arcPtr->outline.disabledDash.number;
	}
	if (arcPtr->disabledFillStipple != None) {
	    stipple = arcPtr->disabledFillStipple;
	}
    }

    /*
     * Compute the screen coordinates of the bounding box for the item,
     * plus integer values for the angles.
     */

    Tk_CanvasDrawableCoords(canvas, arcPtr->bbox[0], arcPtr->bbox[1],
	    &x1, &y1);
    Tk_CanvasDrawableCoords(canvas, arcPtr->bbox[2], arcPtr->bbox[3],
	    &x2, &y2);
    if (x2 <= x1) {
	x2 = x1+1;
    }
    if (y2 <= y1) {
	y2 = y1+1;
    }
    start = (int) ((64*arcPtr->start) + 0.5);
    extent = (int) ((64*arcPtr->extent) + 0.5);

    /*
     * Display filled arc first (if wanted), then outline.  If the extent
     * is zero then don't invoke XFillArc or XDrawArc, since this causes
     * some window servers to crash and should be a no-op anyway.
     */

    if ((arcPtr->fillGC != None) && (extent != 0)) {
	if (stipple != None) {
	    int w=0; int h=0;
	    Tk_TSOffset *tsoffset = &arcPtr->tsoffset;
	    int flags = tsoffset->flags;
	    if (flags & (TK_OFFSET_CENTER|TK_OFFSET_MIDDLE)) {
		Tk_SizeOfBitmap(display, stipple, &w, &h);
		if (flags & TK_OFFSET_CENTER) {
		    w /= 2;
		} else {
		    w = 0;
		}
		if (flags & TK_OFFSET_MIDDLE) {
		    h /= 2;
		} else {
		    h = 0;
		}
	    }
	    tsoffset->xoffset -= w;
	    tsoffset->yoffset -= h;
	    Tk_CanvasSetOffset(canvas, arcPtr->fillGC, tsoffset);
	    if (tsoffset) {
		tsoffset->xoffset += w;
		tsoffset->yoffset += h;
	    }
	}
	XFillArc(display, drawable, arcPtr->fillGC, x1, y1, (unsigned) (x2-x1),
		(unsigned) (y2-y1), start, extent);
	if (stipple != None) {
	    XSetTSOrigin(display, arcPtr->fillGC, 0, 0);
	}
    }
    if (arcPtr->outline.gc != None) {
	Tk_ChangeOutlineGC(canvas, itemPtr, &(arcPtr->outline));

	if (extent != 0) {
	    XDrawArc(display, drawable, arcPtr->outline.gc, x1, y1,
		    (unsigned) (x2-x1), (unsigned) (y2-y1), start, extent);
	}

	/*
	 * If the outline width is very thin, don't use polygons to draw
	 * the linear parts of the outline (this often results in nothing
	 * being displayed); just draw lines instead. The same is done if
	 * the outline is dashed, because then polygons don't work.
	 */

	if (lineWidth < 1.5 || dashnumber != 0) {
	    Tk_CanvasDrawableCoords(canvas, arcPtr->center1[0],
		    arcPtr->center1[1], &x1, &y1);
	    Tk_CanvasDrawableCoords(canvas, arcPtr->center2[0],
		    arcPtr->center2[1], &x2, &y2);

	    if (arcPtr->style == CHORD_STYLE) {
		XDrawLine(display, drawable, arcPtr->outline.gc,
			x1, y1, x2, y2);
	    } else if (arcPtr->style == PIESLICE_STYLE) {
		short cx, cy;

		Tk_CanvasDrawableCoords(canvas,
			(arcPtr->bbox[0] + arcPtr->bbox[2])/2.0,
			(arcPtr->bbox[1] + arcPtr->bbox[3])/2.0, &cx, &cy);
		XDrawLine(display, drawable, arcPtr->outline.gc,
			cx, cy, x1, y1);
		XDrawLine(display, drawable, arcPtr->outline.gc,
			cx, cy, x2, y2);
	    }
	} else {
	    if (arcPtr->style == CHORD_STYLE) {
		TkFillPolygon(canvas, arcPtr->outlinePtr, CHORD_OUTLINE_PTS,
			display, drawable, arcPtr->outline.gc, None);
	    } else if (arcPtr->style == PIESLICE_STYLE) {
		TkFillPolygon(canvas, arcPtr->outlinePtr, PIE_OUTLINE1_PTS,
			display, drawable, arcPtr->outline.gc, None);
		TkFillPolygon(canvas, arcPtr->outlinePtr + 2*PIE_OUTLINE1_PTS,
			PIE_OUTLINE2_PTS, display, drawable, arcPtr->outline.gc,
			None);
	    }
	}

	Tk_ResetOutlineGC(canvas, itemPtr, &(arcPtr->outline));
    }
}

/*
 *--------------------------------------------------------------
 *
 * ArcToPoint --
 *
 *	Computes the distance from a given point to a given
 *	arc, in canvas units.
 *
 * Results:
 *	The return value is 0 if the point whose x and y coordinates
 *	are coordPtr[0] and coordPtr[1] is inside the arc.  If the
 *	point isn't inside the arc then the return value is the
 *	distance from the point to the arc.  If itemPtr is filled,
 *	then anywhere in the interior is considered "inside"; if
 *	itemPtr isn't filled, then "inside" means only the area
 *	occupied by the outline.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

	/* ARGSUSED */
static double
ArcToPoint(canvas, itemPtr, pointPtr)
    Tk_Canvas canvas;		/* Canvas containing item. */
    Tk_Item *itemPtr;		/* Item to check against point. */
    double *pointPtr;		/* Pointer to x and y coordinates. */
{
    ArcItem *arcPtr = (ArcItem *) itemPtr;
    double vertex[2], pointAngle, diff, dist, newDist;
    double poly[8], polyDist, width, t1, t2;
    int filled, angleInRange;
    Tk_State state = itemPtr->state;

    if(state == TK_STATE_NULL) {
	state = ((TkCanvas *)canvas)->canvas_state;
    }

    width = (double) arcPtr->outline.width;
    if (((TkCanvas *)canvas)->currentItemPtr == itemPtr) {
	if (arcPtr->outline.activeWidth>width) {
	    width = (double) arcPtr->outline.activeWidth;
	}
    } else if (state == TK_STATE_DISABLED) {
	if (arcPtr->outline.disabledWidth>0) {
	    width = (double) arcPtr->outline.disabledWidth;
	}
    }

    /*
     * See if the point is within the angular range of the arc.
     * Remember, X angles are backwards from the way we'd normally
     * think of them.  Also, compensate for any eccentricity of
     * the oval.
     */

    vertex[0] = (arcPtr->bbox[0] + arcPtr->bbox[2])/2.0;
    vertex[1] = (arcPtr->bbox[1] + arcPtr->bbox[3])/2.0;
    t1 = arcPtr->bbox[3] - arcPtr->bbox[1];
    if (t1 != 0.0) {
	t1 = (pointPtr[1] - vertex[1]) / t1;
    }
    t2 = arcPtr->bbox[2] - arcPtr->bbox[0];
    if (t2 != 0.0) {
	t2 = (pointPtr[0] - vertex[0]) / t2;
    }
    if ((t1 == 0.0) && (t2 == 0.0)) {
	pointAngle = 0;
    } else {
	pointAngle = -atan2(t1, t2)*180/PI;
    }
    diff = pointAngle - arcPtr->start;
    diff -= ((int) (diff/360.0) * 360.0);
    if (diff < 0) {
	diff += 360.0;
    }
    angleInRange = (diff <= arcPtr->extent) ||
	    ((arcPtr->extent < 0) && ((diff - 360.0) >= arcPtr->extent));

    /*
     * Now perform different tests depending on what kind of arc
     * we're dealing with.
     */

    if (arcPtr->style == ARC_STYLE) {
	if (angleInRange) {
	    return TkOvalToPoint(arcPtr->bbox, width,
		    0, pointPtr);
	}
	dist = hypot(pointPtr[0] - arcPtr->center1[0],
		pointPtr[1] - arcPtr->center1[1]);
	newDist = hypot(pointPtr[0] - arcPtr->center2[0],
		pointPtr[1] - arcPtr->center2[1]);
	if (newDist < dist) {
	    return newDist;
	}
	return dist;
    }

    if ((arcPtr->fillGC != None) || (arcPtr->outline.gc == None)) {
	filled = 1;
    } else {
	filled = 0;
    }
    if (arcPtr->outline.gc == None) {
	width = 0.0;
    }

    if (arcPtr->style == PIESLICE_STYLE) {
	if (width > 1.0) {
	    dist = TkPolygonToPoint(arcPtr->outlinePtr, PIE_OUTLINE1_PTS,
		    pointPtr);
	    newDist = TkPolygonToPoint(arcPtr->outlinePtr + 2*PIE_OUTLINE1_PTS,
			PIE_OUTLINE2_PTS, pointPtr);
	} else {
	    dist = TkLineToPoint(vertex, arcPtr->center1, pointPtr);
	    newDist = TkLineToPoint(vertex, arcPtr->center2, pointPtr);
	}
	if (newDist < dist) {
	    dist = newDist;
	}
	if (angleInRange) {
	    newDist = TkOvalToPoint(arcPtr->bbox, width, filled, pointPtr);
	    if (newDist < dist) {
		dist = newDist;
	    }
	}
	return dist;
    }

    /*
     * This is a chord-style arc.  We have to deal specially with the
     * triangular piece that represents the difference between a
     * chord-style arc and a pie-slice arc (for small angles this piece
     * is excluded here where it would be included for pie slices;
     * for large angles the piece is included here but would be
     * excluded for pie slices).
     */

    if (width > 1.0) {
	dist = TkPolygonToPoint(arcPtr->outlinePtr, CHORD_OUTLINE_PTS,
		    pointPtr);
    } else {
	dist = TkLineToPoint(arcPtr->center1, arcPtr->center2, pointPtr);
    }
    poly[0] = poly[6] = vertex[0];
    poly[1] = poly[7] = vertex[1];
    poly[2] = arcPtr->center1[0];
    poly[3] = arcPtr->center1[1];
    poly[4] = arcPtr->center2[0];
    poly[5] = arcPtr->center2[1];
    polyDist = TkPolygonToPoint(poly, 4, pointPtr);
    if (angleInRange) {
	if ((arcPtr->extent < -180.0) || (arcPtr->extent > 180.0)
		|| (polyDist > 0.0)) {
	    newDist = TkOvalToPoint(arcPtr->bbox, width, filled, pointPtr);
	    if (newDist < dist) {
		dist = newDist;
	    }
	}
    } else {
	if ((arcPtr->extent < -180.0) || (arcPtr->extent > 180.0)) {
	    if (filled && (polyDist < dist)) {
		dist = polyDist;
	    }
	}
    }
    return dist;
}

/*
 *--------------------------------------------------------------
 *
 * ArcToArea --
 *
 *	This procedure is called to determine whether an item
 *	lies entirely inside, entirely outside, or overlapping
 *	a given area.
 *
 * Results:
 *	-1 is returned if the item is entirely outside the area
 *	given by rectPtr, 0 if it overlaps, and 1 if it is entirely
 *	inside the given area.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

	/* ARGSUSED */
static int
ArcToArea(canvas, itemPtr, rectPtr)
    Tk_Canvas canvas;		/* Canvas containing item. */
    Tk_Item *itemPtr;		/* Item to check against arc. */
    double *rectPtr;		/* Pointer to array of four coordinates
				 * (x1, y1, x2, y2) describing rectangular
				 * area.  */
{
    ArcItem *arcPtr = (ArcItem *) itemPtr;
    double rx, ry;		/* Radii for transformed oval:  these define
				 * an oval centered at the origin. */
    double tRect[4];		/* Transformed version of x1, y1, x2, y2,
				 * for coord. system where arc is centered
				 * on the origin. */
    double center[2], width, angle, tmp;
    double points[20], *pointPtr;
    int numPoints, filled;
    int inside;			/* Non-zero means every test so far suggests
				 * that arc is inside rectangle.  0 means
				 * every test so far shows arc to be outside
				 * of rectangle. */
    int newInside;
    Tk_State state = itemPtr->state;

    if(state == TK_STATE_NULL) {
	state = ((TkCanvas *)canvas)->canvas_state;
    }
    width = (double) arcPtr->outline.width;
    if (((TkCanvas *)canvas)->currentItemPtr == itemPtr) {
	if (arcPtr->outline.activeWidth>width) {
	    width = (double) arcPtr->outline.activeWidth;
	}
    } else if (state==TK_STATE_DISABLED) {
	if (arcPtr->outline.disabledWidth>0) {
	    width = (double) arcPtr->outline.disabledWidth;
	}
    }

    if ((arcPtr->fillGC != None) || (arcPtr->outline.gc == None)) {
	filled = 1;
    } else {
	filled = 0;
    }
    if (arcPtr->outline.gc == None) {
	width = 0.0;
    }

    /*
     * Transform both the arc and the rectangle so that the arc's oval
     * is centered on the origin.
     */

    center[0] = (arcPtr->bbox[0] + arcPtr->bbox[2])/2.0;
    center[1] = (arcPtr->bbox[1] + arcPtr->bbox[3])/2.0;
    tRect[0] = rectPtr[0] - center[0];
    tRect[1] = rectPtr[1] - center[1];
    tRect[2] = rectPtr[2] - center[0];
    tRect[3] = rectPtr[3] - center[1];
    rx = arcPtr->bbox[2] - center[0] + width/2.0;
    ry = arcPtr->bbox[3] - center[1] + width/2.0;

    /*
     * Find the extreme points of the arc and see whether these are all
     * inside the rectangle (in which case we're done), partly in and
     * partly out (in which case we're done), or all outside (in which
     * case we have more work to do).  The extreme points include the
     * following, which are checked in order:
     *
     * 1. The outside points of the arc, corresponding to start and
     *	  extent.
     * 2. The center of the arc (but only in pie-slice mode).
     * 3. The 12, 3, 6, and 9-o'clock positions (but only if the arc
     *    includes those angles).
     */

    pointPtr = points;
    angle = -arcPtr->start*(PI/180.0);
    pointPtr[0] = rx*cos(angle);
    pointPtr[1] = ry*sin(angle);
    angle += -arcPtr->extent*(PI/180.0);
    pointPtr[2] = rx*cos(angle);
    pointPtr[3] = ry*sin(angle);
    numPoints = 2;
    pointPtr += 4;

    if ((arcPtr->style == PIESLICE_STYLE) && (arcPtr->extent < 180.0)) {
	pointPtr[0] = 0.0;
	pointPtr[1] = 0.0;
	numPoints++;
	pointPtr += 2;
    }

    tmp = -arcPtr->start;
    if (tmp < 0) {
	tmp += 360.0;
    }
    if ((tmp < arcPtr->extent) || ((tmp-360) > arcPtr->extent)) {
	pointPtr[0] = rx;
	pointPtr[1] = 0.0;
	numPoints++;
	pointPtr += 2;
    }
    tmp = 90.0 - arcPtr->start;
    if (tmp < 0) {
	tmp += 360.0;
    }
    if ((tmp < arcPtr->extent) || ((tmp-360) > arcPtr->extent)) {
	pointPtr[0] = 0.0;
	pointPtr[1] = -ry;
	numPoints++;
	pointPtr += 2;
    }
    tmp = 180.0 - arcPtr->start;
    if (tmp < 0) {
	tmp += 360.0;
    }
    if ((tmp < arcPtr->extent) || ((tmp-360) > arcPtr->extent)) {
	pointPtr[0] = -rx;
	pointPtr[1] = 0.0;
	numPoints++;
	pointPtr += 2;
    }
    tmp = 270.0 - arcPtr->start;
    if (tmp < 0) {
	tmp += 360.0;
    }
    if ((tmp < arcPtr->extent) || ((tmp-360) > arcPtr->extent)) {
	pointPtr[0] = 0.0;
	pointPtr[1] = ry;
	numPoints++;
    }

    /*
     * Now that we've located the extreme points, loop through them all
     * to see which are inside the rectangle.
     */

    inside = (points[0] > tRect[0]) && (points[0] < tRect[2])
	    && (points[1] > tRect[1]) && (points[1] < tRect[3]);
    for (pointPtr = points+2; numPoints > 1; pointPtr += 2, numPoints--) {
	newInside = (pointPtr[0] > tRect[0]) && (pointPtr[0] < tRect[2])
		&& (pointPtr[1] > tRect[1]) && (pointPtr[1] < tRect[3]);
	if (newInside != inside) {
	    return 0;
	}
    }

    if (inside) {
	return 1;
    }

    /*
     * So far, oval appears to be outside rectangle, but can't yet tell
     * for sure.  Next, test each of the four sides of the rectangle
     * against the bounding region for the arc.  If any intersections
     * are found, then return "overlapping".  First, test against the
     * polygon(s) forming the sides of a chord or pie-slice.
     */

    if (arcPtr->style == PIESLICE_STYLE) {
	if (width >= 1.0) {
	    if (TkPolygonToArea(arcPtr->outlinePtr, PIE_OUTLINE1_PTS,
		    rectPtr) != -1)  {
		return 0;
	    }
	    if (TkPolygonToArea(arcPtr->outlinePtr + 2*PIE_OUTLINE1_PTS,
		    PIE_OUTLINE2_PTS, rectPtr) != -1) {
		return 0;
	    }
	} else {
	    if ((TkLineToArea(center, arcPtr->center1, rectPtr) != -1) ||
		    (TkLineToArea(center, arcPtr->center2, rectPtr) != -1)) {
		return 0;
	    }
	}
    } else if (arcPtr->style == CHORD_STYLE) {
	if (width >= 1.0) {
	    if (TkPolygonToArea(arcPtr->outlinePtr, CHORD_OUTLINE_PTS,
		    rectPtr) != -1) {
		return 0;
	    }
	} else {
	    if (TkLineToArea(arcPtr->center1, arcPtr->center2,
		    rectPtr) != -1) {
		return 0;
	    }
	}
    }

    /*
     * Next check for overlap between each of the four sides and the
     * outer perimiter of the arc.  If the arc isn't filled, then also
     * check the inner perimeter of the arc.
     */

    if (HorizLineToArc(tRect[0], tRect[2], tRect[1], rx, ry, arcPtr->start,
		arcPtr->extent)
	    || HorizLineToArc(tRect[0], tRect[2], tRect[3], rx, ry,
		arcPtr->start, arcPtr->extent)
	    || VertLineToArc(tRect[0], tRect[1], tRect[3], rx, ry,
		arcPtr->start, arcPtr->extent)
	    || VertLineToArc(tRect[2], tRect[1], tRect[3], rx, ry,
		arcPtr->start, arcPtr->extent)) {
	return 0;
    }
    if ((width > 1.0) && !filled) {
	rx -= width;
	ry -= width;
	if (HorizLineToArc(tRect[0], tRect[2], tRect[1], rx, ry, arcPtr->start,
		    arcPtr->extent)
		|| HorizLineToArc(tRect[0], tRect[2], tRect[3], rx, ry,
		    arcPtr->start, arcPtr->extent)
		|| VertLineToArc(tRect[0], tRect[1], tRect[3], rx, ry,
		    arcPtr->start, arcPtr->extent)
		|| VertLineToArc(tRect[2], tRect[1], tRect[3], rx, ry,
		    arcPtr->start, arcPtr->extent)) {
	    return 0;
	}
    }

    /*
     * The arc still appears to be totally disjoint from the rectangle,
     * but it's also possible that the rectangle is totally inside the arc.
     * Do one last check, which is to check one point of the rectangle
     * to see if it's inside the arc.  If it is, we've got overlap.  If
     * it isn't, the arc's really outside the rectangle.
     */

    if (ArcToPoint(canvas, itemPtr, rectPtr) == 0.0) {
	return 0;
    }
    return -1;
}

/*
 *--------------------------------------------------------------
 *
 * ScaleArc --
 *
 *	This procedure is invoked to rescale an arc item.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The arc referred to by itemPtr is rescaled so that the
 *	following transformation is applied to all point
 *	coordinates:
 *		x' = originX + scaleX*(x-originX)
 *		y' = originY + scaleY*(y-originY)
 *
 *--------------------------------------------------------------
 */

static void
ScaleArc(canvas, itemPtr, originX, originY, scaleX, scaleY)
    Tk_Canvas canvas;			/* Canvas containing arc. */
    Tk_Item *itemPtr;			/* Arc to be scaled. */
    double originX, originY;		/* Origin about which to scale rect. */
    double scaleX;			/* Amount to scale in X direction. */
    double scaleY;			/* Amount to scale in Y direction. */
{
    ArcItem *arcPtr = (ArcItem *) itemPtr;

    arcPtr->bbox[0] = originX + scaleX*(arcPtr->bbox[0] - originX);
    arcPtr->bbox[1] = originY + scaleY*(arcPtr->bbox[1] - originY);
    arcPtr->bbox[2] = originX + scaleX*(arcPtr->bbox[2] - originX);
    arcPtr->bbox[3] = originY + scaleY*(arcPtr->bbox[3] - originY);
    ComputeArcBbox(canvas, arcPtr);
}

/*
 *--------------------------------------------------------------
 *
 * TranslateArc --
 *
 *	This procedure is called to move an arc by a given amount.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The position of the arc is offset by (xDelta, yDelta), and
 *	the bounding box is updated in the generic part of the item
 *	structure.
 *
 *--------------------------------------------------------------
 */

static void
TranslateArc(canvas, itemPtr, deltaX, deltaY)
    Tk_Canvas canvas;			/* Canvas containing item. */
    Tk_Item *itemPtr;			/* Item that is being moved. */
    double deltaX, deltaY;		/* Amount by which item is to be
					 * moved. */
{
    ArcItem *arcPtr = (ArcItem *) itemPtr;

    arcPtr->bbox[0] += deltaX;
    arcPtr->bbox[1] += deltaY;
    arcPtr->bbox[2] += deltaX;
    arcPtr->bbox[3] += deltaY;
    ComputeArcBbox(canvas, arcPtr);
}

/*
 *--------------------------------------------------------------
 *
 * ComputeArcOutline --
 *
 *	This procedure creates a polygon describing everything in
 *	the outline for an arc except what's in the curved part.
 *	For a "pie slice" arc this is a V-shaped chunk, and for
 *	a "chord" arc this is a linear chunk (with cutaway corners).
 *	For "arc" arcs, this stuff isn't relevant.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The information at arcPtr->outlinePtr gets modified, and
 *	storage for arcPtr->outlinePtr may be allocated or freed.
 *
 *--------------------------------------------------------------
 */

static void
ComputeArcOutline(canvas,arcPtr)
    Tk_Canvas canvas;			/* Information about overall canvas. */
    ArcItem *arcPtr;			/* Information about arc. */
{
    double sin1, cos1, sin2, cos2, angle, width, halfWidth;
    double boxWidth, boxHeight;
    double vertex[2], corner1[2], corner2[2];
    double *outlinePtr;
    Tk_State state = arcPtr->header.state;


    /*
     * Make sure that the outlinePtr array is large enough to hold
     * either a chord or pie-slice outline.
     */

    if (arcPtr->numOutlinePoints == 0) {
	arcPtr->outlinePtr = (double *) ckalloc((unsigned)
		(26 * sizeof(double)));
	arcPtr->numOutlinePoints = 22;
    }
    outlinePtr = arcPtr->outlinePtr;

    if(state == TK_STATE_NULL) {
	state = ((TkCanvas *)canvas)->canvas_state;
    }

    /*
     * First compute the two points that lie at the centers of
     * the ends of the curved arc segment, which are marked with
     * X's in the figure below:
     *
     *
     *				  * * *
     *			      *          *
     *			   *      * *      *
     *			 *    *         *    *
     *			*   *             *   *
     *			 X *               * X
     *
     * The code is tricky because the arc can be ovular in shape.
     * It computes the position for a unit circle, and then
     * scales to fit the shape of the arc's bounding box.
     *
     * Also, watch out because angles go counter-clockwise like you
     * might expect, but the y-coordinate system is inverted.  To
     * handle this, just negate the angles in all the computations.
     */

    boxWidth = arcPtr->bbox[2] - arcPtr->bbox[0];
    boxHeight = arcPtr->bbox[3] - arcPtr->bbox[1];
    angle = -arcPtr->start*PI/180.0;
    sin1 = sin(angle);
    cos1 = cos(angle);
    angle -= arcPtr->extent*PI/180.0;
    sin2 = sin(angle);
    cos2 = cos(angle);
    vertex[0] = (arcPtr->bbox[0] + arcPtr->bbox[2])/2.0;
    vertex[1] = (arcPtr->bbox[1] + arcPtr->bbox[3])/2.0;
    arcPtr->center1[0] = vertex[0] + cos1*boxWidth/2.0;
    arcPtr->center1[1] = vertex[1] + sin1*boxHeight/2.0;
    arcPtr->center2[0] = vertex[0] + cos2*boxWidth/2.0;
    arcPtr->center2[1] = vertex[1] + sin2*boxHeight/2.0;

    /*
     * Next compute the "outermost corners" of the arc, which are
     * marked with X's in the figure below:
     *
     *				  * * *
     *			      *          *
     *			   *      * *      *
     *			 *    *         *    *
     *			X   *             *   X
     *			   *               *
     *
     * The code below is tricky because it has to handle eccentricity
     * in the shape of the oval.  The key in the code below is to
     * realize that the slope of the line from arcPtr->center1 to corner1
     * is (boxWidth*sin1)/(boxHeight*cos1), and similarly for arcPtr->center2
     * and corner2.  These formulas can be computed from the formula for
     * the oval.
     */

    width = arcPtr->outline.width;
    if (((TkCanvas *)canvas)->currentItemPtr == (Tk_Item *) arcPtr) {
	if (arcPtr->outline.activeWidth>arcPtr->outline.width) {
	    width = arcPtr->outline.activeWidth;
	}
    } else if (state==TK_STATE_DISABLED) {
	if (arcPtr->outline.disabledWidth>arcPtr->outline.width) {
	    width = arcPtr->outline.disabledWidth;
	}
    }
    halfWidth = width/2.0;

    if (((boxWidth*sin1) == 0.0) && ((boxHeight*cos1) == 0.0)) {
	angle = 0.0;
    } else {
	angle = atan2(boxWidth*sin1, boxHeight*cos1);
    }
    corner1[0] = arcPtr->center1[0] + cos(angle)*halfWidth;
    corner1[1] = arcPtr->center1[1] + sin(angle)*halfWidth;
    if (((boxWidth*sin2) == 0.0) && ((boxHeight*cos2) == 0.0)) {
	angle = 0.0;
    } else {
	angle = atan2(boxWidth*sin2, boxHeight*cos2);
    }
    corner2[0] = arcPtr->center2[0] + cos(angle)*halfWidth;
    corner2[1] = arcPtr->center2[1] + sin(angle)*halfWidth;

    /*
     * For a chord outline, generate a six-sided polygon with three
     * points for each end of the chord.  The first and third points
     * for each end are butt points generated on either side of the
     * center point.  The second point is the corner point.
     */

    if (arcPtr->style == CHORD_STYLE) {
	outlinePtr[0] = outlinePtr[12] = corner1[0];
	outlinePtr[1] = outlinePtr[13] = corner1[1];
	TkGetButtPoints(arcPtr->center2, arcPtr->center1,
		width, 0, outlinePtr+10, outlinePtr+2);
	outlinePtr[4] = arcPtr->center2[0] + outlinePtr[2]
		- arcPtr->center1[0];
	outlinePtr[5] = arcPtr->center2[1] + outlinePtr[3]
		- arcPtr->center1[1];
	outlinePtr[6] = corner2[0];
	outlinePtr[7] = corner2[1];
	outlinePtr[8] = arcPtr->center2[0] + outlinePtr[10]
		- arcPtr->center1[0];
	outlinePtr[9] = arcPtr->center2[1] + outlinePtr[11]
		- arcPtr->center1[1];
    } else if (arcPtr->style == PIESLICE_STYLE) {
	/*
	 * For pie slices, generate two polygons, one for each side
	 * of the pie slice.  The first arm has a shape like this,
	 * where the center of the oval is X, arcPtr->center1 is at Y, and
	 * corner1 is at Z:
	 *
	 *	 _____________________
	 *	|		      \
	 *	|		       \
	 *	X		     Y  Z
	 *	|		       /
	 *	|_____________________/
	 *
	 */

	TkGetButtPoints(arcPtr->center1, vertex, width, 0,
		outlinePtr, outlinePtr+2);
	outlinePtr[4] = arcPtr->center1[0] + outlinePtr[2] - vertex[0];
	outlinePtr[5] = arcPtr->center1[1] + outlinePtr[3] - vertex[1];
	outlinePtr[6] = corner1[0];
	outlinePtr[7] = corner1[1];
	outlinePtr[8] = arcPtr->center1[0] + outlinePtr[0] - vertex[0];
	outlinePtr[9] = arcPtr->center1[1] + outlinePtr[1] - vertex[1];
	outlinePtr[10] = outlinePtr[0];
	outlinePtr[11] = outlinePtr[1];

	/*
	 * The second arm has a shape like this:
	 *
	 *
	 *	   ______________________
	 *	  /			  \
	 *	 /			   \
	 *	Z  Y			X  /
	 *	 \			  /
	 *	  \______________________/
	 *
	 * Similar to above X is the center of the oval/circle, Y is
	 * arcPtr->center2, and Z is corner2.  The extra jog out to the left
	 * of X is needed in or to produce a butted joint with the
	 * first arm;  the corner to the right of X is one of the
	 * first two points of the first arm, depending on extent.
	 */

	TkGetButtPoints(arcPtr->center2, vertex, width, 0,
		outlinePtr+12, outlinePtr+16);
	if ((arcPtr->extent > 180) ||
		((arcPtr->extent < 0) && (arcPtr->extent > -180))) {
	    outlinePtr[14] = outlinePtr[0];
	    outlinePtr[15] = outlinePtr[1];
	} else {
	    outlinePtr[14] = outlinePtr[2];
	    outlinePtr[15] = outlinePtr[3];
	}
	outlinePtr[18] = arcPtr->center2[0] + outlinePtr[16] - vertex[0];
	outlinePtr[19] = arcPtr->center2[1] + outlinePtr[17] - vertex[1];
	outlinePtr[20] = corner2[0];
	outlinePtr[21] = corner2[1];
	outlinePtr[22] = arcPtr->center2[0] + outlinePtr[12] - vertex[0];
	outlinePtr[23] = arcPtr->center2[1] + outlinePtr[13] - vertex[1];
	outlinePtr[24] = outlinePtr[12];
	outlinePtr[25] = outlinePtr[13];
    }
}

/*
 *--------------------------------------------------------------
 *
 * HorizLineToArc --
 *
 *	Determines whether a horizontal line segment intersects
 *	a given arc.
 *
 * Results:
 *	The return value is 1 if the given line intersects the
 *	infinitely-thin arc section defined by rx, ry, start,
 *	and extent, and 0 otherwise.  Only the perimeter of the
 *	arc is checked: interior areas (e.g. pie-slice or chord)
 *	are not checked.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

static int
HorizLineToArc(x1, x2, y, rx, ry, start, extent)
    double x1, x2;		/* X-coords of endpoints of line segment. 
				 * X1 must be <= x2. */
    double y;			/* Y-coordinate of line segment. */
    double rx, ry;		/* These x- and y-radii define an oval
				 * centered at the origin. */
    double start, extent;	/* Angles that define extent of arc, in
				 * the standard fashion for this module. */
{
    double tmp;
    double tx, ty;		/* Coordinates of intersection point in
				 * transformed coordinate system. */
    double x;

    /*
     * Compute the x-coordinate of one possible intersection point
     * between the arc and the line.  Use a transformed coordinate
     * system where the oval is a unit circle centered at the origin.
     * Then scale back to get actual x-coordinate.
     */

    ty = y/ry;
    tmp = 1 - ty*ty;
    if (tmp < 0) {
	return 0;
    }
    tx = sqrt(tmp);
    x = tx*rx;

    /*
     * Test both intersection points.
     */

    if ((x >= x1) && (x <= x2) && AngleInRange(tx, ty, start, extent)) {
	return 1;
    }
    if ((-x >= x1) && (-x <= x2) && AngleInRange(-tx, ty, start, extent)) {
	return 1;
    }
    return 0;
}

/*
 *--------------------------------------------------------------
 *
 * VertLineToArc --
 *
 *	Determines whether a vertical line segment intersects
 *	a given arc.
 *
 * Results:
 *	The return value is 1 if the given line intersects the
 *	infinitely-thin arc section defined by rx, ry, start,
 *	and extent, and 0 otherwise.  Only the perimeter of the
 *	arc is checked: interior areas (e.g. pie-slice or chord)
 *	are not checked.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

static int
VertLineToArc(x, y1, y2, rx, ry, start, extent)
    double x;			/* X-coordinate of line segment. */
    double y1, y2;		/* Y-coords of endpoints of line segment. 
				 * Y1 must be <= y2. */
    double rx, ry;		/* These x- and y-radii define an oval
				 * centered at the origin. */
    double start, extent;	/* Angles that define extent of arc, in
				 * the standard fashion for this module. */
{
    double tmp;
    double tx, ty;		/* Coordinates of intersection point in
				 * transformed coordinate system. */
    double y;

    /*
     * Compute the y-coordinate of one possible intersection point
     * between the arc and the line.  Use a transformed coordinate
     * system where the oval is a unit circle centered at the origin.
     * Then scale back to get actual y-coordinate.
     */

    tx = x/rx;
    tmp = 1 - tx*tx;
    if (tmp < 0) {
	return 0;
    }
    ty = sqrt(tmp);
    y = ty*ry;

    /*
     * Test both intersection points.
     */

    if ((y > y1) && (y < y2) && AngleInRange(tx, ty, start, extent)) {
	return 1;
    }
    if ((-y > y1) && (-y < y2) && AngleInRange(tx, -ty, start, extent)) {
	return 1;
    }
    return 0;
}

/*
 *--------------------------------------------------------------
 *
 * AngleInRange --
 *
 *	Determine whether the angle from the origin to a given
 *	point is within a given range.
 *
 * Results:
 *	The return value is 1 if the angle from (0,0) to (x,y)
 *	is in the range given by start and extent, where angles
 *	are interpreted in the standard way for ovals (meaning
 *	backwards from normal interpretation).  Otherwise the
 *	return value is 0.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

static int
AngleInRange(x, y, start, extent)
    double x, y;		/* Coordinate of point;  angle measured
				 * from origin to here, relative to x-axis. */
    double start;		/* First angle, degrees, >=0, <=360. */
    double extent;		/* Size of arc in degrees >=-360, <=360. */
{
    double diff;

    if ((x == 0.0) && (y == 0.0)) {
	return 1;
    }
    diff = -atan2(y, x);
    diff = diff*(180.0/PI) - start;
    while (diff > 360.0) {
	diff -= 360.0;
    }
    while (diff < 0.0) {
	diff += 360.0;
    }
    if (extent >= 0) {
	return diff <= extent;
    }
    return (diff-360.0) >= extent;
}

/*
 *--------------------------------------------------------------
 *
 * ArcToPostscript --
 *
 *	This procedure is called to generate Postscript for
 *	arc items.
 *
 * Results:
 *	The return value is a standard Tcl result.  If an error
 *	occurs in generating Postscript then an error message is
 *	left in the interp's result, replacing whatever used
 *	to be there.  If no error occurs, then Postscript for the
 *	item is appended to the result.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

static int
ArcToPostscript(interp, canvas, itemPtr, prepass)
    Tcl_Interp *interp;			/* Leave Postscript or error message
					 * here. */
    Tk_Canvas canvas;			/* Information about overall canvas. */
    Tk_Item *itemPtr;			/* Item for which Postscript is
					 * wanted. */
    int prepass;			/* 1 means this is a prepass to
					 * collect font information;  0 means
					 * final Postscript is being created. */
{
    ArcItem *arcPtr = (ArcItem *) itemPtr;
    char buffer[400];
    double y1, y2, ang1, ang2;
    XColor *color;
    Pixmap stipple;
    XColor *fillColor;
    Pixmap fillStipple;
    Tk_State state = itemPtr->state;

    y1 = Tk_CanvasPsY(canvas, arcPtr->bbox[1]);
    y2 = Tk_CanvasPsY(canvas, arcPtr->bbox[3]);
    ang1 = arcPtr->start;
    ang2 = ang1 + arcPtr->extent;
    if (ang2 < ang1) {
	ang1 = ang2;
	ang2 = arcPtr->start;
    }

    if(state == TK_STATE_NULL) {
	state = ((TkCanvas *)canvas)->canvas_state;
    }
    color = arcPtr->outline.color;
    stipple = arcPtr->outline.stipple;
    fillColor = arcPtr->fillColor;
    fillStipple = arcPtr->fillStipple;
    if (((TkCanvas *)canvas)->currentItemPtr == itemPtr) {
	if (arcPtr->outline.activeColor!=NULL) {
	    color = arcPtr->outline.activeColor;
	}
	if (arcPtr->outline.activeStipple!=None) {
	    stipple = arcPtr->outline.activeStipple;
	}
	if (arcPtr->activeFillColor!=NULL) {
	    fillColor = arcPtr->activeFillColor;
	}
	if (arcPtr->activeFillStipple!=None) {
	    fillStipple = arcPtr->activeFillStipple;
	}
    } else if (state==TK_STATE_DISABLED) {
	if (arcPtr->outline.disabledColor!=NULL) {
	    color = arcPtr->outline.disabledColor;
	}
	if (arcPtr->outline.disabledStipple!=None) {
	    stipple = arcPtr->outline.disabledStipple;
	}
	if (arcPtr->disabledFillColor!=NULL) {
	    fillColor = arcPtr->disabledFillColor;
	}
	if (arcPtr->disabledFillStipple!=None) {
	    fillStipple = arcPtr->disabledFillStipple;
	}
    }

    /*
     * If the arc is filled, output Postscript for the interior region
     * of the arc.
     */

    if (arcPtr->fillGC != None) {
	sprintf(buffer, "matrix currentmatrix\n%.15g %.15g translate %.15g %.15g scale\n",
		(arcPtr->bbox[0] + arcPtr->bbox[2])/2, (y1 + y2)/2,
		(arcPtr->bbox[2] - arcPtr->bbox[0])/2, (y1 - y2)/2);
	Tcl_AppendResult(interp, buffer, (char *) NULL);
	if (arcPtr->style == CHORD_STYLE) {
	    sprintf(buffer, "0 0 1 %.15g %.15g arc closepath\nsetmatrix\n",
		    ang1, ang2);
	} else {
	    sprintf(buffer,
		    "0 0 moveto 0 0 1 %.15g %.15g arc closepath\nsetmatrix\n",
		    ang1, ang2);
	}
	Tcl_AppendResult(interp, buffer, (char *) NULL);
	if (Tk_CanvasPsColor(interp, canvas, fillColor) != TCL_OK) {
	    return TCL_ERROR;
	};
	if (fillStipple != None) {
	    Tcl_AppendResult(interp, "clip ", (char *) NULL);
	    if (Tk_CanvasPsStipple(interp, canvas, fillStipple)
		    != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (arcPtr->outline.gc != None) {
		Tcl_AppendResult(interp, "grestore gsave\n", (char *) NULL);
	    }
	} else {
	    Tcl_AppendResult(interp, "fill\n", (char *) NULL);
	}
    }

    /*
     * If there's an outline for the arc, draw it.
     */

    if (arcPtr->outline.gc != None) {
	sprintf(buffer, "matrix currentmatrix\n%.15g %.15g translate %.15g %.15g scale\n",
		(arcPtr->bbox[0] + arcPtr->bbox[2])/2, (y1 + y2)/2,
		(arcPtr->bbox[2] - arcPtr->bbox[0])/2, (y1 - y2)/2);
	Tcl_AppendResult(interp, buffer, (char *) NULL);
	sprintf(buffer, "0 0 1 %.15g %.15g", ang1, ang2);
	Tcl_AppendResult(interp, buffer,
		" arc\nsetmatrix\n0 setlinecap\n", (char *) NULL);
	if (Tk_CanvasPsOutline(canvas, itemPtr,
		&(arcPtr->outline)) != TCL_OK) {
	    return TCL_ERROR;
	}
	if (arcPtr->style != ARC_STYLE) {
	    Tcl_AppendResult(interp, "grestore gsave\n", (char *) NULL);
	    if (arcPtr->style == CHORD_STYLE) {
		Tk_CanvasPsPath(interp, canvas, arcPtr->outlinePtr,
			CHORD_OUTLINE_PTS);
	    } else {
		Tk_CanvasPsPath(interp, canvas, arcPtr->outlinePtr,
			PIE_OUTLINE1_PTS);
		if (Tk_CanvasPsColor(interp, canvas, color)
			!= TCL_OK) {
		    return TCL_ERROR;
		}
		if (stipple != None) {
		    Tcl_AppendResult(interp, "clip ", (char *) NULL);
		    if (Tk_CanvasPsStipple(interp, canvas,
			    stipple) != TCL_OK) {
			return TCL_ERROR;
		    }
		} else {
		    Tcl_AppendResult(interp, "fill\n", (char *) NULL);
		}
		Tcl_AppendResult(interp, "grestore gsave\n", (char *) NULL);
		Tk_CanvasPsPath(interp, canvas,
			arcPtr->outlinePtr + 2*PIE_OUTLINE1_PTS,
			PIE_OUTLINE2_PTS);
	    }
	    if (Tk_CanvasPsColor(interp, canvas, color)
		    != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (stipple != None) {
		Tcl_AppendResult(interp, "clip ", (char *) NULL);
		if (Tk_CanvasPsStipple(interp, canvas,
			stipple) != TCL_OK) {
		    return TCL_ERROR;
		}
	    } else {
		Tcl_AppendResult(interp, "fill\n", (char *) NULL);
	    }
	}
    }

    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * StyleParseProc --
 *
 *	This procedure is invoked during option processing to handle
 *	the "-style" option.
 *
 * Results:
 *	A standard Tcl return value.
 *
 * Side effects:
 *	The state for a given item gets replaced by the state
 *	indicated in the value argument.
 *
 *--------------------------------------------------------------
 */

static int
StyleParseProc(clientData, interp, tkwin, value, widgRec, offset)
    ClientData clientData;		/* some flags.*/
    Tcl_Interp *interp;			/* Used for reporting errors. */
    Tk_Window tkwin;			/* Window containing canvas widget. */
    CONST char *value;			/* Value of option. */
    char *widgRec;			/* Pointer to record for item. */
    int offset;				/* Offset into item. */
{
    int c;
    size_t length;

    register Style *stylePtr = (Style *) (widgRec + offset);

    if(value == NULL || *value == 0) {
	*stylePtr = PIESLICE_STYLE;
	return TCL_OK;
    }

    c = value[0];
    length = strlen(value);

    if ((c == 'a') && (strncmp(value, "arc", length) == 0)) {
	*stylePtr = ARC_STYLE;
	return TCL_OK;
    }
    if ((c == 'c') && (strncmp(value, "chord", length) == 0)) {
	*stylePtr = CHORD_STYLE;
	return TCL_OK;
    }
    if ((c == 'p') && (strncmp(value, "pieslice", length) == 0)) {
	*stylePtr = PIESLICE_STYLE;
	return TCL_OK;
    }

    Tcl_AppendResult(interp, "bad -style option \"",
	    value, "\": must be arc, chord, or pieslice",
	    (char *) NULL);
    *stylePtr = PIESLICE_STYLE;
    return TCL_ERROR;
}

/*
 *--------------------------------------------------------------
 *
 * StylePrintProc --
 *
 *	This procedure is invoked by the Tk configuration code
 *	to produce a printable string for the "-style"
 *	configuration option.
 *
 * Results:
 *	The return value is a string describing the state for
 *	the item referred to by "widgRec".  In addition, *freeProcPtr
 *	is filled in with the address of a procedure to call to free
 *	the result string when it's no longer needed (or NULL to
 *	indicate that the string doesn't need to be freed).
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

static char *
StylePrintProc(clientData, tkwin, widgRec, offset, freeProcPtr)
    ClientData clientData;		/* Ignored. */
    Tk_Window tkwin;			/* Ignored. */
    char *widgRec;			/* Pointer to record for item. */
    int offset;				/* Offset into item. */
    Tcl_FreeProc **freeProcPtr;		/* Pointer to variable to fill in with
					 * information about how to reclaim
					 * storage for return string. */
{
    register Style *stylePtr = (Style *) (widgRec + offset);

    if (*stylePtr==ARC_STYLE) {
	return "arc";
    } else if (*stylePtr==CHORD_STYLE) {
	return "chord";
    } else {
	return "pieslice";
    }
}
@


1.4
log
@touched all sources to ease next import
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tkCanvArc.c,v 1.7.6.2 2000/09/11 14:55:36 spolk Exp $
d199 2
a200 2
			    Tk_Canvas canvas, Tk_Item *itemPtr, int argc,
			    Tcl_Obj *CONST argv[], int flags));
d203 1
a203 1
			    int argc, Tcl_Obj *CONST argv[]));
d210 2
a211 2
			    Tk_Canvas canvas, Tk_Item *itemPtr, int argc,
			    Tcl_Obj *CONST argv[]));
d289 1
a289 1
CreateArc(interp, canvas, itemPtr, argc, argv)
d294 2
a295 2
    int argc;				/* Number of arguments in argv. */
    Tcl_Obj *CONST argv[];		/* Arguments describing arc. */
d298 1
a298 1
    int i;
d300 1
a300 1
    if (argc==1) {
d302 3
a304 4
    } else {
	char *arg = Tcl_GetStringFromObj(argv[1], NULL);
	if ((argc>1) && (arg[0] == '-')
		&& (arg[1] >= 'a') && (arg[1] <= 'z')) {
a305 2
	} else {
	    i = 4;
d308 2
a309 1
    if (argc < i) {
d343 1
a343 1
    if ((ArcCoords(interp, canvas, itemPtr, i, argv) != TCL_OK)) {
d346 1
a346 1
    if (ConfigureArc(interp, canvas, itemPtr, argc-4, argv+4, 0) == TCL_OK) {
d373 1
a373 1
ArcCoords(interp, canvas, itemPtr, argc, argv)
d378 3
a380 3
    int argc;				/* Number of coordinates supplied in
					 * argv. */
    Tcl_Obj *CONST argv[];		/* Array of coordinates: x1, y1,
d385 1
a385 1
    if (argc == 0) {
d396 4
a399 4
    } else if ((argc == 1)||(argc == 4)) {
	if (argc==1) {
	    if (Tcl_ListObjGetElements(interp, argv[0], &argc,
		    (Tcl_Obj ***) &argv) != TCL_OK) {
d401 1
a401 1
	    } else if (argc != 4) {
d404 1
a404 1
		sprintf(buf, "wrong # coordinates: expected 4, got %d", argc);
d409 1
a409 1
	if ((Tk_CanvasGetCoordFromObj(interp, canvas, argv[0],
d411 1
a411 1
		|| (Tk_CanvasGetCoordFromObj(interp, canvas, argv[1],
d413 1
a413 1
		|| (Tk_CanvasGetCoordFromObj(interp, canvas, argv[2],
d415 1
a415 1
		|| (Tk_CanvasGetCoordFromObj(interp, canvas, argv[3],
d423 1
a423 1
	sprintf(buf, "wrong # coordinates: expected 0 or 4, got %d", argc);
d450 1
a450 1
ConfigureArc(interp, canvas, itemPtr, argc, argv, flags)
d454 2
a455 2
    int argc;			/* Number of elements in argv.  */
    Tcl_Obj *CONST argv[];	/* Arguments describing things to configure. */
d470 2
a471 2
    if (Tk_ConfigureWidget(interp, tkwin, configSpecs, argc, (char **) argv,
	    (char *) arcPtr, flags|TK_CONFIG_OBJS) != TCL_OK) {
a2145 1

@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
 * Copyright (c) 1994-1995 Sun Microsystems, Inc.
d12 1
a12 1
 * RCS: @@(#) $Id: tkCanvArc.c,v 1.9 1999/01/26 04:11:19 jingham Exp $
d18 1
a18 1

d23 4
d30 1
d46 1
a46 3
    int width;			/* Width of outline (in pixels). */
    XColor *outlineColor;	/* Color for outline.  NULL means don't
				 * draw outline. */
d50 6
d57 5
a61 3
    Pixmap outlineStipple;	/* Stipple bitmap for outline. */
    Tk_Uid style;		/* How to draw arc: arc, chord, or pieslice. */
    GC outlineGC;		/* Graphics context for outline. */
d82 19
a100 1
static Tk_CustomOption tagsOption = {Tk_CanvasTagsParseProc,
d103 12
d117 41
d162 3
d166 4
a169 1
	"black", Tk_Offset(ArcItem, outlineColor), TK_CONFIG_NULL_OK},
d171 2
a172 1
	(char *) NULL, Tk_Offset(ArcItem, outlineStipple), TK_CONFIG_NULL_OK},
d175 3
d180 3
a182 2
    {TK_CONFIG_UID, "-style", (char *) NULL, (char *) NULL,
	"pieslice", Tk_Offset(ArcItem, style), TK_CONFIG_DONT_SET_DEFAULT},
d185 3
a187 2
    {TK_CONFIG_PIXELS, "-width", (char *) NULL, (char *) NULL,
	"1", Tk_Offset(ArcItem, width), TK_CONFIG_DONT_SET_DEFAULT},
d200 1
a200 1
			    char **argv, int flags));
d203 1
a203 1
			    int argc, char **argv));
d211 1
a211 1
			    char **argv));
d225 2
a226 1
static void		ComputeArcOutline _ANSI_ARGS_((ArcItem *arcPtr));
d248 1
a248 1
    0,					/* alwaysRedraw */
d259 1
a259 1
    (Tk_ItemType *) NULL		/* nextPtr */
a265 8
/*
 * The uid's below comprise the legal values for the "-style"
 * option for arcs.
 */

static Tk_Uid arcUid =  NULL;
static Tk_Uid chordUid =  NULL;
static Tk_Uid pieSliceUid = NULL;
d278 1
a278 1
 *	interp->result;  in this case itemPtr is
d295 1
a295 1
    char **argv;			/* Arguments describing arc. */
d298 1
d300 12
a311 1
    if (argc < 4) {
a319 10
     * Carry out once-only initialization.
     */

    if (arcUid == NULL) {
	arcUid = Tk_GetUid("arc");
	chordUid = Tk_GetUid("chord");
	pieSliceUid = Tk_GetUid("pieslice");
    }

    /*
d324 1
d329 3
a331 2
    arcPtr->width = 1;
    arcPtr->outlineColor = NULL;
d333 2
d336 3
a338 3
    arcPtr->outlineStipple = None;
    arcPtr->style = pieSliceUid;
    arcPtr->outlineGC = None;
d345 2
a346 8
    if ((Tk_CanvasGetCoord(interp, canvas, argv[0], &arcPtr->bbox[0]) != TCL_OK)
	    || (Tk_CanvasGetCoord(interp, canvas, argv[1],
		&arcPtr->bbox[1]) != TCL_OK)
	    || (Tk_CanvasGetCoord(interp, canvas, argv[2],
		    &arcPtr->bbox[2]) != TCL_OK)
	    || (Tk_CanvasGetCoord(interp, canvas, argv[3],
		    &arcPtr->bbox[3]) != TCL_OK)) {
	return TCL_ERROR;
d348 2
a349 4

    if (ConfigureArc(interp, canvas, itemPtr, argc-4, argv+4, 0) != TCL_OK) {
	DeleteArc(canvas, itemPtr, Tk_Display(Tk_CanvasTkwin(canvas)));
	return TCL_ERROR;
d351 3
a353 1
    return TCL_OK;
d366 1
a366 1
 *	Returns TCL_OK or TCL_ERROR, and sets interp->result.
d382 1
a382 1
    char **argv;			/* Array of coordinates: x1, y1,
a385 2
    char c0[TCL_DOUBLE_SPACE], c1[TCL_DOUBLE_SPACE];
    char c2[TCL_DOUBLE_SPACE], c3[TCL_DOUBLE_SPACE];
d388 26
a413 10
	Tcl_PrintDouble(interp, arcPtr->bbox[0], c0);
	Tcl_PrintDouble(interp, arcPtr->bbox[1], c1);
	Tcl_PrintDouble(interp, arcPtr->bbox[2], c2);
	Tcl_PrintDouble(interp, arcPtr->bbox[3], c3);
	Tcl_AppendResult(interp, c0, " ", c1, " ", c2, " ", c3,
		(char *) NULL);
    } else if (argc == 4) {
	if ((Tk_CanvasGetCoord(interp, canvas, argv[0],
		    &arcPtr->bbox[0]) != TCL_OK)
		|| (Tk_CanvasGetCoord(interp, canvas, argv[1],
d415 1
a415 1
		|| (Tk_CanvasGetCoord(interp, canvas, argv[2],
d417 1
a417 1
		|| (Tk_CanvasGetCoord(interp, canvas, argv[3],
d423 4
a426 3
	sprintf(interp->result,
		"wrong # coordinates: expected 0 or 4, got %d",
		argc);
d442 1
a442 1
 *	an error message is left in interp->result.
d457 1
a457 1
    char **argv;		/* Arguments describing things to configure. */
d466 4
d472 2
a473 2
    if (Tk_ConfigureWidget(interp, tkwin, configSpecs, argc, argv,
	    (char *) arcPtr, flags) != TCL_OK) {
d477 2
d484 28
d520 11
a530 7
    if ((arcPtr->style != arcUid) && (arcPtr->style != chordUid)
	    && (arcPtr->style != pieSliceUid)) {
	Tcl_AppendResult(interp, "bad -style option \"",
		arcPtr->style, "\": must be arc, chord, or pieslice",
		(char *) NULL);
	arcPtr->style = pieSliceUid;
	return TCL_ERROR;
d532 1
d534 2
a535 2
    if (arcPtr->width < 0) {
	arcPtr->width = 1;
d537 20
a556 11
    if (arcPtr->outlineColor == NULL) {
	newGC = None;
    } else {
	gcValues.foreground = arcPtr->outlineColor->pixel;
	gcValues.cap_style = CapButt;
	gcValues.line_width = arcPtr->width;
	mask = GCForeground|GCCapStyle|GCLineWidth;
	if (arcPtr->outlineStipple != None) {
	    gcValues.stipple = arcPtr->outlineStipple;
	    gcValues.fill_style = FillStippled;
	    mask |= GCStipple|GCFillStyle;
d558 1
a558 7
	newGC = Tk_GetGCColor(tkwin, mask, &gcValues, arcPtr->outlineColor,
			      NULL);
    }
    if (arcPtr->outlineGC != None) {
	Tk_FreeGC(Tk_Display(tkwin), arcPtr->outlineGC);
    }
    arcPtr->outlineGC = newGC;
d560 3
a562 1
    if ((arcPtr->fillColor == NULL) || (arcPtr->style == arcUid)) {
d565 2
a566 2
	gcValues.foreground = arcPtr->fillColor->pixel;
	if (arcPtr->style == chordUid) {
d572 2
a573 2
	if (arcPtr->fillStipple != None) {
	    gcValues.stipple = arcPtr->fillStipple;
d577 1
a577 1
	newGC = Tk_GetGCColor(tkwin, mask, &gcValues, arcPtr->fillColor, NULL);
d584 17
d631 1
a634 3
    if (arcPtr->outlineColor != NULL) {
	Tk_FreeColor(arcPtr->outlineColor);
    }
d638 6
d647 2
a648 2
    if (arcPtr->outlineStipple != None) {
	Tk_FreeBitmap(display, arcPtr->outlineStipple);
d650 2
a651 2
    if (arcPtr->outlineGC != None) {
	Tk_FreeGC(display, arcPtr->outlineGC);
d684 24
d726 1
a726 1
    ComputeArcOutline(arcPtr);
d740 1
a740 1
    if (arcPtr->style == pieSliceUid) {
d786 1
a786 1
    if (arcPtr->outlineColor == NULL) {
d789 1
a789 1
	tmp = (arcPtr->width + 1)/2 + 1;
d827 35
a861 1
    int start, extent;
d888 24
a911 2
	if (arcPtr->fillStipple != None) {
	    Tk_CanvasSetStippleOrigin(canvas, arcPtr->fillGC);
d915 1
a915 1
	if (arcPtr->fillStipple != None) {
d919 3
a921 4
    if (arcPtr->outlineGC != None) {
	if (arcPtr->outlineStipple != None) {
	    Tk_CanvasSetStippleOrigin(canvas, arcPtr->outlineGC);
	}
d923 1
a923 1
	    XDrawArc(display, drawable, arcPtr->outlineGC, x1, y1,
d930 2
a931 1
	 * being displayed); just draw lines instead.
d934 1
a934 1
	if (arcPtr->width <= 2) {
d940 2
a941 2
	    if (arcPtr->style == chordUid) {
		XDrawLine(display, drawable, arcPtr->outlineGC,
d943 1
a943 1
	    } else if (arcPtr->style == pieSliceUid) {
d949 1
a949 1
		XDrawLine(display, drawable, arcPtr->outlineGC,
d951 1
a951 1
		XDrawLine(display, drawable, arcPtr->outlineGC,
d955 1
a955 1
	    if (arcPtr->style == chordUid) {
d957 2
a958 2
			display, drawable, arcPtr->outlineGC, None);
	    } else if (arcPtr->style == pieSliceUid) {
d960 1
a960 1
			display, drawable, arcPtr->outlineGC, None);
d962 1
a962 1
			PIE_OUTLINE2_PTS, display, drawable, arcPtr->outlineGC,
d966 2
a967 3
	if (arcPtr->outlineStipple != None) {
	    XSetTSOrigin(display, arcPtr->outlineGC, 0, 0);
	}
d1005 16
d1031 8
a1038 2
    t1 = (pointPtr[1] - vertex[1])/(arcPtr->bbox[3] - arcPtr->bbox[1]);
    t2 = (pointPtr[0] - vertex[0])/(arcPtr->bbox[2] - arcPtr->bbox[0]);
d1057 1
a1057 1
    if (arcPtr->style == arcUid) {
d1059 1
a1059 1
	    return TkOvalToPoint(arcPtr->bbox, (double) arcPtr->width,
d1072 1
a1072 1
    if ((arcPtr->fillGC != None) || (arcPtr->outlineGC == None)) {
d1077 1
a1077 1
    if (arcPtr->outlineGC == None) {
a1078 2
    } else {
	width = arcPtr->width;
d1081 1
a1081 1
    if (arcPtr->style == pieSliceUid) {
d1186 15
d1202 1
a1202 1
    if ((arcPtr->fillGC != None) || (arcPtr->outlineGC == None)) {
d1207 1
a1207 1
    if (arcPtr->outlineGC == None) {
a1208 2
    } else {
	width = arcPtr->width;
d1249 1
a1249 1
    if ((arcPtr->style == pieSliceUid) && (arcPtr->extent < 180.0)) {
d1323 1
a1323 1
    if (arcPtr->style == pieSliceUid) {
d1339 1
a1339 1
    } else if (arcPtr->style == chordUid) {
d1491 2
a1492 1
ComputeArcOutline(arcPtr)
d1495 1
a1495 1
    double sin1, cos1, sin2, cos2, angle, halfWidth;
d1499 2
d1514 4
d1574 12
a1585 1
    halfWidth = arcPtr->width/2.0;
d1608 1
a1608 1
    if (arcPtr->style == chordUid) {
d1612 1
a1612 1
		(double) arcPtr->width, 0, outlinePtr+10, outlinePtr+2);
d1623 1
a1623 1
    } else if (arcPtr->style == pieSliceUid) {
d1639 1
a1639 1
	TkGetButtPoints(arcPtr->center1, vertex, (double) arcPtr->width, 0,
d1668 1
a1668 1
	TkGetButtPoints(arcPtr->center2, vertex, (double) arcPtr->width, 0,
d1875 1
a1875 1
 *	left in interp->result, replacing whatever used
d1899 5
d1914 35
d1959 1
a1959 1
	if (arcPtr->style == chordUid) {
d1968 1
a1968 1
	if (Tk_CanvasPsColor(interp, canvas, arcPtr->fillColor) != TCL_OK) {
d1971 1
a1971 1
	if (arcPtr->fillStipple != None) {
d1973 1
a1973 1
	    if (Tk_CanvasPsStipple(interp, canvas, arcPtr->fillStipple)
d1977 1
a1977 1
	    if (arcPtr->outlineGC != None) {
d1989 1
a1989 1
    if (arcPtr->outlineGC != None) {
d1994 5
a1998 6
	sprintf(buffer, "0 0 1 %.15g %.15g arc\nsetmatrix\n", ang1, ang2);
	Tcl_AppendResult(interp, buffer, (char *) NULL);
	sprintf(buffer, "%d setlinewidth\n0 setlinecap\n", arcPtr->width);
	Tcl_AppendResult(interp, buffer, (char *) NULL);
	if (Tk_CanvasPsColor(interp, canvas, arcPtr->outlineColor)
		!= TCL_OK) {
d2001 1
a2001 10
	if (arcPtr->outlineStipple != None) {
	    Tcl_AppendResult(interp, "StrokeClip ", (char *) NULL);
	    if (Tk_CanvasPsStipple(interp, canvas,
		    arcPtr->outlineStipple) != TCL_OK) {
		return TCL_ERROR;
	    }
	} else {
	    Tcl_AppendResult(interp, "stroke\n", (char *) NULL);
	}
	if (arcPtr->style != arcUid) {
d2003 1
a2003 1
	    if (arcPtr->style == chordUid) {
d2009 1
a2009 1
		if (Tk_CanvasPsColor(interp, canvas, arcPtr->outlineColor)
d2013 1
a2013 1
		if (arcPtr->outlineStipple != None) {
d2016 1
a2016 1
			    arcPtr->outlineStipple) != TCL_OK) {
d2027 1
a2027 1
	    if (Tk_CanvasPsColor(interp, canvas, arcPtr->outlineColor)
d2031 1
a2031 1
	    if (arcPtr->outlineStipple != None) {
d2034 1
a2034 1
			arcPtr->outlineStipple) != TCL_OK) {
d2045 104
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d7 1
a7 1
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
d12 1
a12 1
 * RCS: @@(#) $Id: tkCanvArc.c,v 1.7.6.2 2000/09/11 14:55:36 spolk Exp $
d18 1
a18 1
#include "tkCanvas.h"
a22 4
typedef enum {
    PIESLICE_STYLE, CHORD_STYLE, ARC_STYLE
} Style;

a25 1
    Tk_Outline outline;		/* Outline structure */
d41 3
a43 1
    Tk_TSOffset tsoffset;
a46 6
    XColor *activeFillColor;	/* Color for filling arc (used for drawing
				 * outline too when style is "arc" and state
				 * is "active").  NULL means use fillColor. */
    XColor *disabledFillColor;	/* Color for filling arc (used for drawing
				 * outline too when style is "arc" and state
				 * is "disabled". NULL means use fillColor */
d48 3
a50 5
    Pixmap activeFillStipple;	/* Stipple bitmap for filling item if state
				 * is active. */
    Pixmap disabledFillStipple;	/* Stipple bitmap for filling item if state
				 * is disabled. */
    Style style;		/* How to draw arc: arc, chord, or pieslice. */
d71 1
a71 19
static int	StyleParseProc _ANSI_ARGS_((
		    ClientData clientData, Tcl_Interp *interp,
		    Tk_Window tkwin, CONST char *value,
		    char *widgRec, int offset));
static char *	StylePrintProc _ANSI_ARGS_((
		    ClientData clientData, Tk_Window tkwin,
		    char *widgRec, int offset,
		    Tcl_FreeProc **freeProcPtr));

static Tk_CustomOption stateOption = {
    (Tk_OptionParseProc *) TkStateParseProc,
    TkStatePrintProc, (ClientData) 2
};
static Tk_CustomOption styleOption = {
    (Tk_OptionParseProc *) StyleParseProc,
    StylePrintProc, (ClientData) NULL
};
static Tk_CustomOption tagsOption = {
    (Tk_OptionParseProc *) Tk_CanvasTagsParseProc,
a73 12
static Tk_CustomOption dashOption = {
    (Tk_OptionParseProc *) TkCanvasDashParseProc,
    TkCanvasDashPrintProc, (ClientData) NULL
};
static Tk_CustomOption offsetOption = {
    (Tk_OptionParseProc *) TkOffsetParseProc,
    TkOffsetPrintProc, (ClientData) (TK_OFFSET_RELATIVE)
};
static Tk_CustomOption pixelOption = {
    (Tk_OptionParseProc *) TkPixelParseProc,
    TkPixelPrintProc, (ClientData) NULL
};
a75 41
    {TK_CONFIG_CUSTOM, "-activedash", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, outline.activeDash),
	TK_CONFIG_NULL_OK, &dashOption},
    {TK_CONFIG_COLOR, "-activefill", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, activeFillColor),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_COLOR, "-activeoutline", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, outline.activeColor),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_BITMAP, "-activeoutlinestipple", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, outline.activeStipple),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_BITMAP, "-activestipple", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, activeFillStipple),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_CUSTOM, "-activewidth", (char *) NULL, (char *) NULL,
	"0.0", Tk_Offset(ArcItem, outline.activeWidth),
	TK_CONFIG_DONT_SET_DEFAULT, &pixelOption},
    {TK_CONFIG_CUSTOM, "-dash", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, outline.dash),
	TK_CONFIG_NULL_OK, &dashOption},
    {TK_CONFIG_PIXELS, "-dashoffset", (char *) NULL, (char *) NULL,
	"0", Tk_Offset(ArcItem, outline.offset), TK_CONFIG_DONT_SET_DEFAULT},
    {TK_CONFIG_CUSTOM, "-disableddash", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, outline.disabledDash),
	TK_CONFIG_NULL_OK, &dashOption},
    {TK_CONFIG_COLOR, "-disabledfill", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, disabledFillColor),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_COLOR, "-disabledoutline", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, outline.disabledColor),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_BITMAP, "-disabledoutlinestipple", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, outline.disabledStipple),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_BITMAP, "-disabledstipple", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, disabledFillStipple),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_CUSTOM, "-disabledwidth", (char *) NULL, (char *) NULL,
	"0.0", Tk_Offset(ArcItem, outline.disabledWidth),
	TK_CONFIG_DONT_SET_DEFAULT, &pixelOption},
a79 3
    {TK_CONFIG_CUSTOM, "-offset", (char *) NULL, (char *) NULL,
	"0,0", Tk_Offset(ArcItem, tsoffset),
	TK_CONFIG_DONT_SET_DEFAULT, &offsetOption},
d81 1
a81 4
	"black", Tk_Offset(ArcItem, outline.color), TK_CONFIG_NULL_OK},
    {TK_CONFIG_CUSTOM, "-outlineoffset", (char *) NULL, (char *) NULL,
	"0,0", Tk_Offset(ArcItem, outline.tsoffset),
	TK_CONFIG_DONT_SET_DEFAULT, &offsetOption},
d83 1
a83 2
	(char *) NULL, Tk_Offset(ArcItem, outline.stipple),
	TK_CONFIG_NULL_OK},
a85 3
    {TK_CONFIG_CUSTOM, "-state", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(Tk_Item, state), TK_CONFIG_NULL_OK,
	&stateOption},
d88 2
a89 3
    {TK_CONFIG_CUSTOM, "-style", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(ArcItem, style), TK_CONFIG_DONT_SET_DEFAULT,
	&styleOption},
d92 2
a93 3
    {TK_CONFIG_CUSTOM, "-width", (char *) NULL, (char *) NULL,
	"1.0", Tk_Offset(ArcItem, outline.width), TK_CONFIG_DONT_SET_DEFAULT,
	&pixelOption},
d106 1
a106 1
			    Tcl_Obj *CONST argv[], int flags));
d109 1
a109 1
			    int argc, Tcl_Obj *CONST argv[]));
d117 1
a117 1
			    Tcl_Obj *CONST argv[]));
d131 1
a131 2
static void		ComputeArcOutline _ANSI_ARGS_((Tk_Canvas canvas,
			    ArcItem *arcPtr));
d153 1
a153 1
    TK_CONFIG_OBJS,			/* flags */
d164 1
a164 1
    (Tk_ItemType *) NULL,		/* nextPtr */
d171 8
d191 1
a191 1
 *	the interp's result;  in this case itemPtr is
d208 1
a208 1
    Tcl_Obj *CONST argv[];		/* Arguments describing arc. */
a210 1
    int i;
d212 1
a212 12
    if (argc==1) {
	i = 1;
    } else {
	char *arg = Tcl_GetStringFromObj(argv[1], NULL);
	if ((argc>1) && (arg[0] == '-')
		&& (arg[1] >= 'a') && (arg[1] <= 'z')) {
	    i = 1;
	} else {
	    i = 4;
	}
    }
    if (argc < i) {
d221 10
a234 1
    Tk_CreateOutline(&(arcPtr->outline));
d239 2
a240 3
    arcPtr->tsoffset.flags = 0;
    arcPtr->tsoffset.xoffset = 0;
    arcPtr->tsoffset.yoffset = 0;
a241 2
    arcPtr->activeFillColor = NULL;
    arcPtr->disabledFillColor = NULL;
d243 3
a245 3
    arcPtr->activeFillStipple = None;
    arcPtr->disabledFillStipple = None;
    arcPtr->style = PIESLICE_STYLE;
d252 8
a259 2
    if ((ArcCoords(interp, canvas, itemPtr, i, argv) != TCL_OK)) {
	goto error;
d261 4
a264 2
    if (ConfigureArc(interp, canvas, itemPtr, argc-4, argv+4, 0) == TCL_OK) {
	return TCL_OK;
d266 1
a266 3
    error:
    DeleteArc(canvas, itemPtr, Tk_Display(Tk_CanvasTkwin(canvas)));
    return TCL_ERROR;
d279 1
a279 1
 *	Returns TCL_OK or TCL_ERROR, and sets the interp's result.
d295 1
a295 1
    Tcl_Obj *CONST argv[];		/* Array of coordinates: x1, y1,
d299 2
d303 10
a312 26
	Tcl_Obj *obj = Tcl_NewObj();
	Tcl_Obj *subobj = Tcl_NewDoubleObj(arcPtr->bbox[0]);
	Tcl_ListObjAppendElement(interp, obj, subobj);
	subobj = Tcl_NewDoubleObj(arcPtr->bbox[1]);
	Tcl_ListObjAppendElement(interp, obj, subobj);
	subobj = Tcl_NewDoubleObj(arcPtr->bbox[2]);
	Tcl_ListObjAppendElement(interp, obj, subobj);
	subobj = Tcl_NewDoubleObj(arcPtr->bbox[3]);
	Tcl_ListObjAppendElement(interp, obj, subobj);
	Tcl_SetObjResult(interp, obj);
    } else if ((argc == 1)||(argc == 4)) {
	if (argc==1) {
	    if (Tcl_ListObjGetElements(interp, argv[0], &argc,
		    (Tcl_Obj ***) &argv) != TCL_OK) {
		return TCL_ERROR;
	    } else if (argc != 4) {
		char buf[64 + TCL_INTEGER_SPACE];
	
		sprintf(buf, "wrong # coordinates: expected 4, got %d", argc);
		Tcl_SetResult(interp, buf, TCL_VOLATILE);
		return TCL_ERROR;
	    }
	}
	if ((Tk_CanvasGetCoordFromObj(interp, canvas, argv[0],
 		    &arcPtr->bbox[0]) != TCL_OK)
		|| (Tk_CanvasGetCoordFromObj(interp, canvas, argv[1],
d314 1
a314 1
		|| (Tk_CanvasGetCoordFromObj(interp, canvas, argv[2],
d316 1
a316 1
		|| (Tk_CanvasGetCoordFromObj(interp, canvas, argv[3],
d322 3
a324 4
	char buf[64 + TCL_INTEGER_SPACE];
	
	sprintf(buf, "wrong # coordinates: expected 0 or 4, got %d", argc);
	Tcl_SetResult(interp, buf, TCL_VOLATILE);
d340 1
a340 1
 *	an error message is left in the interp's result.
d355 1
a355 1
    Tcl_Obj *CONST argv[];	/* Arguments describing things to configure. */
a363 4
    Tk_TSOffset *tsoffset;
    XColor *color;
    Pixmap stipple;
    Tk_State state;
d366 2
a367 2
    if (Tk_ConfigureWidget(interp, tkwin, configSpecs, argc, (char **) argv,
	    (char *) arcPtr, flags|TK_CONFIG_OBJS) != TCL_OK) {
a370 2
    state = itemPtr->state;

a375 28
    if (arcPtr->outline.activeWidth > arcPtr->outline.width ||
	    arcPtr->outline.activeDash.number != 0 ||
	    arcPtr->outline.activeColor != NULL ||
	    arcPtr->outline.activeStipple != None ||
	    arcPtr->activeFillColor != NULL ||
	    arcPtr->activeFillStipple != None) {
	itemPtr->redraw_flags |= TK_ITEM_STATE_DEPENDANT;
    } else {
	itemPtr->redraw_flags &= ~TK_ITEM_STATE_DEPENDANT;
    }

    tsoffset = &arcPtr->outline.tsoffset;
    flags = tsoffset->flags;
    if (flags & TK_OFFSET_LEFT) {
	tsoffset->xoffset = (int) (arcPtr->bbox[0] + 0.5);
    } else if (flags & TK_OFFSET_CENTER) {
	tsoffset->xoffset = (int) ((arcPtr->bbox[0]+arcPtr->bbox[2]+1)/2);
    } else if (flags & TK_OFFSET_RIGHT) {
	tsoffset->xoffset = (int) (arcPtr->bbox[2] + 0.5);
    }
    if (flags & TK_OFFSET_TOP) {
	tsoffset->yoffset = (int) (arcPtr->bbox[1] + 0.5);
    } else if (flags & TK_OFFSET_MIDDLE) {
	tsoffset->yoffset = (int) ((arcPtr->bbox[1]+arcPtr->bbox[3]+1)/2);
    } else if (flags & TK_OFFSET_BOTTOM) {
	tsoffset->yoffset = (int) (arcPtr->bbox[2] + 0.5);
    }

d384 7
a390 8
    mask = Tk_ConfigOutlineGC(&gcValues, canvas, itemPtr,
	    &(arcPtr->outline));
    if (mask) {
	gcValues.cap_style = CapButt;
	mask |= GCCapStyle;
	newGC = Tk_GetGC(tkwin, mask, &gcValues);
    } else {
	newGC = None;
d392 3
a394 2
    if (arcPtr->outline.gc != None) {
	Tk_FreeGC(Tk_Display(tkwin), arcPtr->outline.gc);
d396 14
a409 4
    arcPtr->outline.gc = newGC;

    if(state == TK_STATE_NULL) {
	state = ((TkCanvas *)canvas)->canvas_state;
d411 2
a412 3
    if (state==TK_STATE_HIDDEN) {
	ComputeArcBbox(canvas, arcPtr);
	return TCL_OK;
d414 1
d416 1
a416 21
    color = arcPtr->fillColor;
    stipple = arcPtr->fillStipple;
    if (((TkCanvas *)canvas)->currentItemPtr == itemPtr) {
	if (arcPtr->activeFillColor!=NULL) {
	    color = arcPtr->activeFillColor;
	}
	if (arcPtr->activeFillStipple!=None) {
	    stipple = arcPtr->activeFillStipple;
	}
    } else if (state==TK_STATE_DISABLED) {
	if (arcPtr->disabledFillColor!=NULL) {
	    color = arcPtr->disabledFillColor;
	}
	if (arcPtr->disabledFillStipple!=None) {
	    stipple = arcPtr->disabledFillStipple;
	}
      }

    if (arcPtr->style == ARC_STYLE) {
	newGC = None;
    } else if (color == NULL) {
d419 2
a420 2
	gcValues.foreground = color->pixel;
	if (arcPtr->style == CHORD_STYLE) {
d426 2
a427 2
	if (stipple != None) {
	    gcValues.stipple = stipple;
d431 1
a431 1
	newGC = Tk_GetGC(tkwin, mask, &gcValues);
a437 17
    tsoffset = &arcPtr->tsoffset;
    flags = tsoffset->flags;
    if (flags & TK_OFFSET_LEFT) {
	tsoffset->xoffset = (int) (arcPtr->bbox[0] + 0.5);
    } else if (flags & TK_OFFSET_CENTER) {
	tsoffset->xoffset = (int) ((arcPtr->bbox[0]+arcPtr->bbox[2]+1)/2);
    } else if (flags & TK_OFFSET_RIGHT) {
	tsoffset->xoffset = (int) (arcPtr->bbox[2] + 0.5);
    }
    if (flags & TK_OFFSET_TOP) {
	tsoffset->yoffset = (int) (arcPtr->bbox[1] + 0.5);
    } else if (flags & TK_OFFSET_MIDDLE) {
	tsoffset->yoffset = (int) ((arcPtr->bbox[1]+arcPtr->bbox[3]+1)/2);
    } else if (flags & TK_OFFSET_BOTTOM) {
	tsoffset->yoffset = (int) (arcPtr->bbox[3] + 0.5);
    }

a467 1
    Tk_DeleteOutline(display, &(arcPtr->outline));
d471 3
a476 6
    if (arcPtr->activeFillColor != NULL) {
	Tk_FreeColor(arcPtr->activeFillColor);
    }
    if (arcPtr->disabledFillColor != NULL) {
	Tk_FreeColor(arcPtr->disabledFillColor);
    }
d480 2
a481 2
    if (arcPtr->activeFillStipple != None) {
	Tk_FreeBitmap(display, arcPtr->activeFillStipple);
d483 2
a484 2
    if (arcPtr->disabledFillStipple != None) {
	Tk_FreeBitmap(display, arcPtr->disabledFillStipple);
a516 24
    double width;
    Tk_State state = arcPtr->header.state;

    if(state == TK_STATE_NULL) {
	state = ((TkCanvas *)canvas)->canvas_state;
    }

    width = arcPtr->outline.width;
    if (width < 1.0) {
	width = 1.0;
    }
    if (state==TK_STATE_HIDDEN) {
	arcPtr->header.x1 = arcPtr->header.x2 =
	arcPtr->header.y1 = arcPtr->header.y2 = -1;
	return;
    } else if (((TkCanvas *)canvas)->currentItemPtr == (Tk_Item *) arcPtr) {
	if (arcPtr->outline.activeWidth>width) {
	    width = arcPtr->outline.activeWidth;
	}
    } else if (state==TK_STATE_DISABLED) {
	if (arcPtr->outline.disabledWidth>0) {
	    width = arcPtr->outline.disabledWidth;
	}
    }
d535 1
a535 1
    ComputeArcOutline(canvas,arcPtr);
d549 1
a549 1
    if (arcPtr->style == PIESLICE_STYLE) {
d595 1
a595 1
    if (arcPtr->outline.gc == None) {
d598 1
a598 1
	tmp = (int) ((width + 1.0)/2.0 + 1);
d636 1
a636 35
    int start, extent, dashnumber;
    double lineWidth;
    Tk_State state = itemPtr->state;
    Pixmap stipple;

    if(state == TK_STATE_NULL) {
	state = ((TkCanvas *)canvas)->canvas_state;
    }
    lineWidth = arcPtr->outline.width;
    if (lineWidth < 1.0) {
	lineWidth = 1.0;
    }
    dashnumber = arcPtr->outline.dash.number;
    stipple = arcPtr->fillStipple;
    if (((TkCanvas *)canvas)->currentItemPtr == itemPtr) {
	if (arcPtr->outline.activeWidth>lineWidth) {
	    lineWidth = arcPtr->outline.activeWidth;
	}
	if (arcPtr->outline.activeDash.number != 0) {
	    dashnumber = arcPtr->outline.activeDash.number;
	}
	if (arcPtr->activeFillStipple != None) {
	    stipple = arcPtr->activeFillStipple;
	}
    } else if (state==TK_STATE_DISABLED) {
	if (arcPtr->outline.disabledWidth > 0) {
	    lineWidth = arcPtr->outline.disabledWidth;
	}
	if (arcPtr->outline.disabledDash.number != 0) {
	    dashnumber = arcPtr->outline.disabledDash.number;
	}
	if (arcPtr->disabledFillStipple != None) {
	    stipple = arcPtr->disabledFillStipple;
	}
    }
d663 2
a664 24
	if (stipple != None) {
	    int w=0; int h=0;
	    Tk_TSOffset *tsoffset = &arcPtr->tsoffset;
	    int flags = tsoffset->flags;
	    if (flags & (TK_OFFSET_CENTER|TK_OFFSET_MIDDLE)) {
		Tk_SizeOfBitmap(display, stipple, &w, &h);
		if (flags & TK_OFFSET_CENTER) {
		    w /= 2;
		} else {
		    w = 0;
		}
		if (flags & TK_OFFSET_MIDDLE) {
		    h /= 2;
		} else {
		    h = 0;
		}
	    }
	    tsoffset->xoffset -= w;
	    tsoffset->yoffset -= h;
	    Tk_CanvasSetOffset(canvas, arcPtr->fillGC, tsoffset);
	    if (tsoffset) {
		tsoffset->xoffset += w;
		tsoffset->yoffset += h;
	    }
d668 1
a668 1
	if (stipple != None) {
d672 4
a675 3
    if (arcPtr->outline.gc != None) {
	Tk_ChangeOutlineGC(canvas, itemPtr, &(arcPtr->outline));

d677 1
a677 1
	    XDrawArc(display, drawable, arcPtr->outline.gc, x1, y1,
d684 1
a684 2
	 * being displayed); just draw lines instead. The same is done if
	 * the outline is dashed, because then polygons don't work.
d687 1
a687 1
	if (lineWidth < 1.5 || dashnumber != 0) {
d693 2
a694 2
	    if (arcPtr->style == CHORD_STYLE) {
		XDrawLine(display, drawable, arcPtr->outline.gc,
d696 1
a696 1
	    } else if (arcPtr->style == PIESLICE_STYLE) {
d702 1
a702 1
		XDrawLine(display, drawable, arcPtr->outline.gc,
d704 1
a704 1
		XDrawLine(display, drawable, arcPtr->outline.gc,
d708 1
a708 1
	    if (arcPtr->style == CHORD_STYLE) {
d710 2
a711 2
			display, drawable, arcPtr->outline.gc, None);
	    } else if (arcPtr->style == PIESLICE_STYLE) {
d713 1
a713 1
			display, drawable, arcPtr->outline.gc, None);
d715 1
a715 1
			PIE_OUTLINE2_PTS, display, drawable, arcPtr->outline.gc,
d719 3
a721 2

	Tk_ResetOutlineGC(canvas, itemPtr, &(arcPtr->outline));
a758 16
    Tk_State state = itemPtr->state;

    if(state == TK_STATE_NULL) {
	state = ((TkCanvas *)canvas)->canvas_state;
    }

    width = (double) arcPtr->outline.width;
    if (((TkCanvas *)canvas)->currentItemPtr == itemPtr) {
	if (arcPtr->outline.activeWidth>width) {
	    width = (double) arcPtr->outline.activeWidth;
	}
    } else if (state == TK_STATE_DISABLED) {
	if (arcPtr->outline.disabledWidth>0) {
	    width = (double) arcPtr->outline.disabledWidth;
	}
    }
d769 2
a770 8
    t1 = arcPtr->bbox[3] - arcPtr->bbox[1];
    if (t1 != 0.0) {
	t1 = (pointPtr[1] - vertex[1]) / t1;
    }
    t2 = arcPtr->bbox[2] - arcPtr->bbox[0];
    if (t2 != 0.0) {
	t2 = (pointPtr[0] - vertex[0]) / t2;
    }
d789 1
a789 1
    if (arcPtr->style == ARC_STYLE) {
d791 1
a791 1
	    return TkOvalToPoint(arcPtr->bbox, width,
d804 1
a804 1
    if ((arcPtr->fillGC != None) || (arcPtr->outline.gc == None)) {
d809 1
a809 1
    if (arcPtr->outline.gc == None) {
d811 2
d815 1
a815 1
    if (arcPtr->style == PIESLICE_STYLE) {
a919 15
    Tk_State state = itemPtr->state;

    if(state == TK_STATE_NULL) {
	state = ((TkCanvas *)canvas)->canvas_state;
    }
    width = (double) arcPtr->outline.width;
    if (((TkCanvas *)canvas)->currentItemPtr == itemPtr) {
	if (arcPtr->outline.activeWidth>width) {
	    width = (double) arcPtr->outline.activeWidth;
	}
    } else if (state==TK_STATE_DISABLED) {
	if (arcPtr->outline.disabledWidth>0) {
	    width = (double) arcPtr->outline.disabledWidth;
	}
    }
d921 1
a921 1
    if ((arcPtr->fillGC != None) || (arcPtr->outline.gc == None)) {
d926 1
a926 1
    if (arcPtr->outline.gc == None) {
d928 2
d970 1
a970 1
    if ((arcPtr->style == PIESLICE_STYLE) && (arcPtr->extent < 180.0)) {
d1044 1
a1044 1
    if (arcPtr->style == PIESLICE_STYLE) {
d1060 1
a1060 1
    } else if (arcPtr->style == CHORD_STYLE) {
d1212 1
a1212 2
ComputeArcOutline(canvas,arcPtr)
    Tk_Canvas canvas;			/* Information about overall canvas. */
d1215 1
a1215 1
    double sin1, cos1, sin2, cos2, angle, width, halfWidth;
a1218 2
    Tk_State state = arcPtr->header.state;

a1231 4
    if(state == TK_STATE_NULL) {
	state = ((TkCanvas *)canvas)->canvas_state;
    }

d1288 1
a1288 12
    width = arcPtr->outline.width;
    if (((TkCanvas *)canvas)->currentItemPtr == (Tk_Item *) arcPtr) {
	if (arcPtr->outline.activeWidth>arcPtr->outline.width) {
	    width = arcPtr->outline.activeWidth;
	}
    } else if (state==TK_STATE_DISABLED) {
	if (arcPtr->outline.disabledWidth>arcPtr->outline.width) {
	    width = arcPtr->outline.disabledWidth;
	}
    }
    halfWidth = width/2.0;

d1311 1
a1311 1
    if (arcPtr->style == CHORD_STYLE) {
d1315 1
a1315 1
		width, 0, outlinePtr+10, outlinePtr+2);
d1326 1
a1326 1
    } else if (arcPtr->style == PIESLICE_STYLE) {
d1342 1
a1342 1
	TkGetButtPoints(arcPtr->center1, vertex, width, 0,
d1371 1
a1371 1
	TkGetButtPoints(arcPtr->center2, vertex, width, 0,
d1578 1
a1578 1
 *	left in the interp's result, replacing whatever used
a1601 5
    XColor *color;
    Pixmap stipple;
    XColor *fillColor;
    Pixmap fillStipple;
    Tk_State state = itemPtr->state;
a1611 35
    if(state == TK_STATE_NULL) {
	state = ((TkCanvas *)canvas)->canvas_state;
    }
    color = arcPtr->outline.color;
    stipple = arcPtr->outline.stipple;
    fillColor = arcPtr->fillColor;
    fillStipple = arcPtr->fillStipple;
    if (((TkCanvas *)canvas)->currentItemPtr == itemPtr) {
	if (arcPtr->outline.activeColor!=NULL) {
	    color = arcPtr->outline.activeColor;
	}
	if (arcPtr->outline.activeStipple!=None) {
	    stipple = arcPtr->outline.activeStipple;
	}
	if (arcPtr->activeFillColor!=NULL) {
	    fillColor = arcPtr->activeFillColor;
	}
	if (arcPtr->activeFillStipple!=None) {
	    fillStipple = arcPtr->activeFillStipple;
	}
    } else if (state==TK_STATE_DISABLED) {
	if (arcPtr->outline.disabledColor!=NULL) {
	    color = arcPtr->outline.disabledColor;
	}
	if (arcPtr->outline.disabledStipple!=None) {
	    stipple = arcPtr->outline.disabledStipple;
	}
	if (arcPtr->disabledFillColor!=NULL) {
	    fillColor = arcPtr->disabledFillColor;
	}
	if (arcPtr->disabledFillStipple!=None) {
	    fillStipple = arcPtr->disabledFillStipple;
	}
    }

d1622 1
a1622 1
	if (arcPtr->style == CHORD_STYLE) {
d1631 1
a1631 1
	if (Tk_CanvasPsColor(interp, canvas, fillColor) != TCL_OK) {
d1634 1
a1634 1
	if (fillStipple != None) {
d1636 1
a1636 1
	    if (Tk_CanvasPsStipple(interp, canvas, fillStipple)
d1640 1
a1640 1
	    if (arcPtr->outline.gc != None) {
d1652 1
a1652 1
    if (arcPtr->outline.gc != None) {
d1657 6
a1662 5
	sprintf(buffer, "0 0 1 %.15g %.15g", ang1, ang2);
	Tcl_AppendResult(interp, buffer,
		" arc\nsetmatrix\n0 setlinecap\n", (char *) NULL);
	if (Tk_CanvasPsOutline(canvas, itemPtr,
		&(arcPtr->outline)) != TCL_OK) {
d1665 10
a1674 1
	if (arcPtr->style != ARC_STYLE) {
d1676 1
a1676 1
	    if (arcPtr->style == CHORD_STYLE) {
d1682 1
a1682 1
		if (Tk_CanvasPsColor(interp, canvas, color)
d1686 1
a1686 1
		if (stipple != None) {
d1689 1
a1689 1
			    stipple) != TCL_OK) {
d1700 1
a1700 1
	    if (Tk_CanvasPsColor(interp, canvas, color)
d1704 1
a1704 1
	    if (stipple != None) {
d1707 1
a1707 1
			stipple) != TCL_OK) {
a1717 104

/*
 *--------------------------------------------------------------
 *
 * StyleParseProc --
 *
 *	This procedure is invoked during option processing to handle
 *	the "-style" option.
 *
 * Results:
 *	A standard Tcl return value.
 *
 * Side effects:
 *	The state for a given item gets replaced by the state
 *	indicated in the value argument.
 *
 *--------------------------------------------------------------
 */

static int
StyleParseProc(clientData, interp, tkwin, value, widgRec, offset)
    ClientData clientData;		/* some flags.*/
    Tcl_Interp *interp;			/* Used for reporting errors. */
    Tk_Window tkwin;			/* Window containing canvas widget. */
    CONST char *value;			/* Value of option. */
    char *widgRec;			/* Pointer to record for item. */
    int offset;				/* Offset into item. */
{
    int c;
    size_t length;

    register Style *stylePtr = (Style *) (widgRec + offset);

    if(value == NULL || *value == 0) {
	*stylePtr = PIESLICE_STYLE;
	return TCL_OK;
    }

    c = value[0];
    length = strlen(value);

    if ((c == 'a') && (strncmp(value, "arc", length) == 0)) {
	*stylePtr = ARC_STYLE;
	return TCL_OK;
    }
    if ((c == 'c') && (strncmp(value, "chord", length) == 0)) {
	*stylePtr = CHORD_STYLE;
	return TCL_OK;
    }
    if ((c == 'p') && (strncmp(value, "pieslice", length) == 0)) {
	*stylePtr = PIESLICE_STYLE;
	return TCL_OK;
    }

    Tcl_AppendResult(interp, "bad -style option \"",
	    value, "\": must be arc, chord, or pieslice",
	    (char *) NULL);
    *stylePtr = PIESLICE_STYLE;
    return TCL_ERROR;
}

/*
 *--------------------------------------------------------------
 *
 * StylePrintProc --
 *
 *	This procedure is invoked by the Tk configuration code
 *	to produce a printable string for the "-style"
 *	configuration option.
 *
 * Results:
 *	The return value is a string describing the state for
 *	the item referred to by "widgRec".  In addition, *freeProcPtr
 *	is filled in with the address of a procedure to call to free
 *	the result string when it's no longer needed (or NULL to
 *	indicate that the string doesn't need to be freed).
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

static char *
StylePrintProc(clientData, tkwin, widgRec, offset, freeProcPtr)
    ClientData clientData;		/* Ignored. */
    Tk_Window tkwin;			/* Ignored. */
    char *widgRec;			/* Pointer to record for item. */
    int offset;				/* Offset into item. */
    Tcl_FreeProc **freeProcPtr;		/* Pointer to variable to fill in with
					 * information about how to reclaim
					 * storage for return string. */
{
    register Style *stylePtr = (Style *) (widgRec + offset);

    if (*stylePtr==ARC_STYLE) {
	return "arc";
    } else if (*stylePtr==CHORD_STYLE) {
	return "chord";
    } else {
	return "pieslice";
    }
}

@


1.1.1.3
log
@import tk 8.4.0
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tkCanvArc.c,v 1.10 2002/08/05 04:30:38 dgp Exp $
d199 2
a200 2
			    Tk_Canvas canvas, Tk_Item *itemPtr, int objc,
			    Tcl_Obj *CONST objv[], int flags));
d203 1
a203 1
			    int objc, Tcl_Obj *CONST objv[]));
d210 2
a211 2
			    Tk_Canvas canvas, Tk_Item *itemPtr, int objc,
			    Tcl_Obj *CONST objv[]));
d289 1
a289 1
CreateArc(interp, canvas, itemPtr, objc, objv)
d294 2
a295 2
    int objc;				/* Number of arguments in objv. */
    Tcl_Obj *CONST objv[];		/* Arguments describing arc. */
d298 1
a298 1
    int i = 4;
d300 1
a300 1
    if (objc == 1) {
d302 4
a305 3
    } else if (objc > 1) {
	char *arg = Tcl_GetString(objv[1]);
	if ((arg[0] == '-') && (arg[1] >= 'a') && (arg[1] <= 'z')) {
d307 2
d311 1
a311 2

    if (objc < i) {
d345 1
a345 1
    if ((ArcCoords(interp, canvas, itemPtr, i, objv) != TCL_OK)) {
d348 1
a348 1
    if (ConfigureArc(interp, canvas, itemPtr, objc-4, objv+4, 0) == TCL_OK) {
d375 1
a375 1
ArcCoords(interp, canvas, itemPtr, objc, objv)
d380 3
a382 3
    int objc;				/* Number of coordinates supplied in
					 * objv. */
    Tcl_Obj *CONST objv[];		/* Array of coordinates: x1, y1,
d387 1
a387 1
    if (objc == 0) {
d398 4
a401 4
    } else if ((objc == 1)||(objc == 4)) {
	if (objc==1) {
	    if (Tcl_ListObjGetElements(interp, objv[0], &objc,
		    (Tcl_Obj ***) &objv) != TCL_OK) {
d403 1
a403 1
	    } else if (objc != 4) {
d406 1
a406 1
		sprintf(buf, "wrong # coordinates: expected 4, got %d", objc);
d411 1
a411 1
	if ((Tk_CanvasGetCoordFromObj(interp, canvas, objv[0],
d413 1
a413 1
		|| (Tk_CanvasGetCoordFromObj(interp, canvas, objv[1],
d415 1
a415 1
		|| (Tk_CanvasGetCoordFromObj(interp, canvas, objv[2],
d417 1
a417 1
		|| (Tk_CanvasGetCoordFromObj(interp, canvas, objv[3],
d425 1
a425 1
	sprintf(buf, "wrong # coordinates: expected 0 or 4, got %d", objc);
d452 1
a452 1
ConfigureArc(interp, canvas, itemPtr, objc, objv, flags)
d456 2
a457 2
    int objc;			/* Number of elements in objv.  */
    Tcl_Obj *CONST objv[];	/* Arguments describing things to configure. */
d472 2
a473 2
    if (TCL_OK != Tk_ConfigureWidget(interp, tkwin, configSpecs, objc,
	    (CONST char **) objv, (char *) arcPtr, flags|TK_CONFIG_OBJS)) {
d2148 1
@


