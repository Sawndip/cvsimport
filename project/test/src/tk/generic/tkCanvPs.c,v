head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.4
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.20.24.42;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.12;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.24;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.50;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.31;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.07;	author kseitz;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.01.21.19.53.45;	author hunt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@/* 
 * tkCanvPs.c --
 *
 *	This module provides Postscript output support for canvases,
 *	including the "postscript" widget command plus a few utility
 *	procedures used for generating Postscript.
 *
 * Copyright (c) 1991-1994 The Regents of the University of California.
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkCanvPs.c,v 1.12 2002/10/10 21:01:17 hobbs Exp $
 */

#include "tkInt.h"
#include "tkCanvas.h"
#include "tkPort.h"

/*
 * See tkCanvas.h for key data structures used to implement canvases.
 */

/*
 * The following definition is used in generating postscript for images
 * and windows.
 */

typedef struct TkColormapData {	/* Hold color information for a window */
    int separated;		/* Whether to use separate color bands */
    int color;			/* Whether window is color or black/white */
    int ncolors;		/* Number of color values stored */
    XColor *colors;		/* Pixel value -> RGB mappings */
    int red_mask, green_mask, blue_mask;	/* Masks and shifts for each */
    int red_shift, green_shift, blue_shift;	/* color band */
} TkColormapData;

/*
 * One of the following structures is created to keep track of Postscript
 * output being generated.  It consists mostly of information provided on
 * the widget command line.
 */

typedef struct TkPostscriptInfo {
    int x, y, width, height;	/* Area to print, in canvas pixel
				 * coordinates. */
    int x2, y2;			/* x+width and y+height. */
    char *pageXString;		/* String value of "-pagex" option or NULL. */
    char *pageYString;		/* String value of "-pagey" option or NULL. */
    double pageX, pageY;	/* Postscript coordinates (in points)
				 * corresponding to pageXString and
				 * pageYString. Don't forget that y-values
				 * grow upwards for Postscript! */
    char *pageWidthString;	/* Printed width of output. */
    char *pageHeightString;	/* Printed height of output. */
    double scale;		/* Scale factor for conversion: each pixel
				 * maps into this many points. */
    Tk_Anchor pageAnchor;	/* How to anchor bbox on Postscript page. */
    int rotate;			/* Non-zero means output should be rotated
				 * on page (landscape mode). */
    char *fontVar;		/* If non-NULL, gives name of global variable
				 * containing font mapping information.
				 * Malloc'ed. */
    char *colorVar;		/* If non-NULL, give name of global variable
				 * containing color mapping information.
				 * Malloc'ed. */
    char *colorMode;		/* Mode for handling colors:  "monochrome",
				 * "gray", or "color".  Malloc'ed. */
    int colorLevel;		/* Numeric value corresponding to colorMode:
				 * 0 for mono, 1 for gray, 2 for color. */
    char *fileName;		/* Name of file in which to write Postscript;
				 * NULL means return Postscript info as
				 * result. Malloc'ed. */
    char *channelName;		/* If -channel is specified, the name of
                                 * the channel to use. */
    Tcl_Channel chan;		/* Open channel corresponding to fileName. */
    Tcl_HashTable fontTable;	/* Hash table containing names of all font
				 * families used in output.  The hash table
				 * values are not used. */
    int prepass;		/* Non-zero means that we're currently in
				 * the pre-pass that collects font information,
				 * so the Postscript generated isn't
				 * relevant. */
    int prolog;			/* Non-zero means output should contain
				   the file prolog.ps in the header. */
} TkPostscriptInfo;

/*
 * The table below provides a template that's used to process arguments
 * to the canvas "postscript" command and fill in TkPostscriptInfo
 * structures.
 */

static Tk_ConfigSpec configSpecs[] = {
    {TK_CONFIG_STRING, "-colormap", (char *) NULL, (char *) NULL,
	"", Tk_Offset(TkPostscriptInfo, colorVar), 0},
    {TK_CONFIG_STRING, "-colormode", (char *) NULL, (char *) NULL,
	"", Tk_Offset(TkPostscriptInfo, colorMode), 0},
    {TK_CONFIG_STRING, "-file", (char *) NULL, (char *) NULL,
	"", Tk_Offset(TkPostscriptInfo, fileName), 0},
    {TK_CONFIG_STRING, "-channel", (char *) NULL, (char *) NULL,
	"", Tk_Offset(TkPostscriptInfo, channelName), 0},
    {TK_CONFIG_STRING, "-fontmap", (char *) NULL, (char *) NULL,
	"", Tk_Offset(TkPostscriptInfo, fontVar), 0},
    {TK_CONFIG_PIXELS, "-height", (char *) NULL, (char *) NULL,
	"", Tk_Offset(TkPostscriptInfo, height), 0},
    {TK_CONFIG_ANCHOR, "-pageanchor", (char *) NULL, (char *) NULL,
	"", Tk_Offset(TkPostscriptInfo, pageAnchor), 0},
    {TK_CONFIG_STRING, "-pageheight", (char *) NULL, (char *) NULL,
	"", Tk_Offset(TkPostscriptInfo, pageHeightString), 0},
    {TK_CONFIG_STRING, "-pagewidth", (char *) NULL, (char *) NULL,
	"", Tk_Offset(TkPostscriptInfo, pageWidthString), 0},
    {TK_CONFIG_STRING, "-pagex", (char *) NULL, (char *) NULL,
	"", Tk_Offset(TkPostscriptInfo, pageXString), 0},
    {TK_CONFIG_STRING, "-pagey", (char *) NULL, (char *) NULL,
	"", Tk_Offset(TkPostscriptInfo, pageYString), 0},
    {TK_CONFIG_BOOLEAN, "-prolog", (char *) NULL, (char *) NULL,
	"", Tk_Offset(TkPostscriptInfo, prolog), 0},
    {TK_CONFIG_BOOLEAN, "-rotate", (char *) NULL, (char *) NULL,
	"", Tk_Offset(TkPostscriptInfo, rotate), 0},
    {TK_CONFIG_PIXELS, "-width", (char *) NULL, (char *) NULL,
	"", Tk_Offset(TkPostscriptInfo, width), 0},
    {TK_CONFIG_PIXELS, "-x", (char *) NULL, (char *) NULL,
	"", Tk_Offset(TkPostscriptInfo, x), 0},
    {TK_CONFIG_PIXELS, "-y", (char *) NULL, (char *) NULL,
	"", Tk_Offset(TkPostscriptInfo, y), 0},
    {TK_CONFIG_END, (char *) NULL, (char *) NULL, (char *) NULL,
	(char *) NULL, 0, 0}
};

/*
 * Forward declarations for procedures defined later in this file:
 */

static int		GetPostscriptPoints _ANSI_ARGS_((Tcl_Interp *interp,
			    char *string, double *doublePtr));

/*
 *--------------------------------------------------------------
 *
 * TkCanvPostscriptCmd --
 *
 *	This procedure is invoked to process the "postscript" options
 *	of the widget command for canvas widgets. See the user
 *	documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *--------------------------------------------------------------
 */

    /* ARGSUSED */
int
TkCanvPostscriptCmd(canvasPtr, interp, argc, argv)
    TkCanvas *canvasPtr;		/* Information about canvas widget. */
    Tcl_Interp *interp;			/* Current interpreter. */
    int argc;				/* Number of arguments. */
    CONST char **argv;			/* Argument strings.  Caller has
					 * already parsed this command enough
					 * to know that argv[1] is
					 * "postscript". */
{
    TkPostscriptInfo psInfo;
    Tk_PostscriptInfo oldInfoPtr;
    int result;
    Tk_Item *itemPtr;
#define STRING_LENGTH 400
    char string[STRING_LENGTH+1];
    CONST char *p;
    time_t now;
    size_t length;
    Tk_Window tkwin = canvasPtr->tkwin;
    int deltaX = 0, deltaY = 0;		/* Offset of lower-left corner of
					 * area to be marked up, measured
					 * in canvas units from the positioning
					 * point on the page (reflects
					 * anchor position).  Initial values
					 * needed only to stop compiler
					 * warnings. */
    Tcl_HashSearch search;
    Tcl_HashEntry *hPtr;
    Tcl_DString buffer;
    char psenccmd[]="::tk::ensure_psenc_is_loaded";

    /*
     *----------------------------------------------------------------
     * Initialize the data structure describing Postscript generation,
     * then process all the arguments to fill the data structure in.
     *----------------------------------------------------------------
     */
    result = Tcl_EvalEx(interp,psenccmd,-1,TCL_EVAL_GLOBAL);
    if (result != TCL_OK) {
        return result;
    }
    oldInfoPtr = canvasPtr->psInfo;
    canvasPtr->psInfo = (Tk_PostscriptInfo) &psInfo;
    psInfo.x = canvasPtr->xOrigin;
    psInfo.y = canvasPtr->yOrigin;
    psInfo.width = -1;
    psInfo.height = -1;
    psInfo.pageXString = NULL;
    psInfo.pageYString = NULL;
    psInfo.pageX = 72*4.25;
    psInfo.pageY = 72*5.5;
    psInfo.pageWidthString = NULL;
    psInfo.pageHeightString = NULL;
    psInfo.scale = 1.0;
    psInfo.pageAnchor = TK_ANCHOR_CENTER;
    psInfo.rotate = 0;
    psInfo.fontVar = NULL;
    psInfo.colorVar = NULL;
    psInfo.colorMode = NULL;
    psInfo.colorLevel = 0;
    psInfo.fileName = NULL;
    psInfo.channelName = NULL;
    psInfo.chan = NULL;
    psInfo.prepass = 0;
    psInfo.prolog = 1;
    Tcl_InitHashTable(&psInfo.fontTable, TCL_STRING_KEYS);
    result = Tk_ConfigureWidget(interp, tkwin,
	    configSpecs, argc-2, argv+2, (char *) &psInfo,
	    TK_CONFIG_ARGV_ONLY);
    if (result != TCL_OK) {
	goto cleanup;
    }

    if (psInfo.width == -1) {
	psInfo.width = Tk_Width(tkwin);
    }
    if (psInfo.height == -1) {
	psInfo.height = Tk_Height(tkwin);
    }
    psInfo.x2 = psInfo.x + psInfo.width;
    psInfo.y2 = psInfo.y + psInfo.height;

    if (psInfo.pageXString != NULL) {
	if (GetPostscriptPoints(interp, psInfo.pageXString,
		&psInfo.pageX) != TCL_OK) {
	    goto cleanup;
	}
    }
    if (psInfo.pageYString != NULL) {
	if (GetPostscriptPoints(interp, psInfo.pageYString,
		&psInfo.pageY) != TCL_OK) {
	    goto cleanup;
	}
    }
    if (psInfo.pageWidthString != NULL) {
	if (GetPostscriptPoints(interp, psInfo.pageWidthString,
		&psInfo.scale) != TCL_OK) {
	    goto cleanup;
	}
	psInfo.scale /= psInfo.width;
    } else if (psInfo.pageHeightString != NULL) {
	if (GetPostscriptPoints(interp, psInfo.pageHeightString,
		&psInfo.scale) != TCL_OK) {
	    goto cleanup;
	}
	psInfo.scale /= psInfo.height;
    } else {
	psInfo.scale = (72.0/25.4)*WidthMMOfScreen(Tk_Screen(tkwin));
	psInfo.scale /= WidthOfScreen(Tk_Screen(tkwin));
    }
    switch (psInfo.pageAnchor) {
	case TK_ANCHOR_NW:
	case TK_ANCHOR_W:
	case TK_ANCHOR_SW:
	    deltaX = 0;
	    break;
	case TK_ANCHOR_N:
	case TK_ANCHOR_CENTER:
	case TK_ANCHOR_S:
	    deltaX = -psInfo.width/2;
	    break;
	case TK_ANCHOR_NE:
	case TK_ANCHOR_E:
	case TK_ANCHOR_SE:
	    deltaX = -psInfo.width;
	    break;
    }
    switch (psInfo.pageAnchor) {
	case TK_ANCHOR_NW:
	case TK_ANCHOR_N:
	case TK_ANCHOR_NE:
	    deltaY = - psInfo.height;
	    break;
	case TK_ANCHOR_W:
	case TK_ANCHOR_CENTER:
	case TK_ANCHOR_E:
	    deltaY = -psInfo.height/2;
	    break;
	case TK_ANCHOR_SW:
	case TK_ANCHOR_S:
	case TK_ANCHOR_SE:
	    deltaY = 0;
	    break;
    }

    if (psInfo.colorMode == NULL) {
	psInfo.colorLevel = 2;
    } else {
	length = strlen(psInfo.colorMode);
	if (strncmp(psInfo.colorMode, "monochrome", length) == 0) {
	    psInfo.colorLevel = 0;
	} else if (strncmp(psInfo.colorMode, "gray", length) == 0) {
	    psInfo.colorLevel = 1;
	} else if (strncmp(psInfo.colorMode, "color", length) == 0) {
	    psInfo.colorLevel = 2;
	} else {
	    Tcl_AppendResult(interp, "bad color mode \"",
		    psInfo.colorMode, "\": must be monochrome, ",
		    "gray, or color", (char *) NULL);
	    goto cleanup;
	}
    }

    if (psInfo.fileName != NULL) {

        /*
         * Check that -file and -channel are not both specified.
         */

        if (psInfo.channelName != NULL) {
            Tcl_AppendResult(interp, "can't specify both -file",
                    " and -channel", (char *) NULL);
            result = TCL_ERROR;
            goto cleanup;
        }

        /*
         * Check that we are not in a safe interpreter. If we are, disallow
         * the -file specification.
         */

        if (Tcl_IsSafe(interp)) {
            Tcl_AppendResult(interp, "can't specify -file in a",
                    " safe interpreter", (char *) NULL);
            result = TCL_ERROR;
            goto cleanup;
        }
        
	p = Tcl_TranslateFileName(interp, psInfo.fileName, &buffer);
	if (p == NULL) {
	    goto cleanup;
	}
	psInfo.chan = Tcl_OpenFileChannel(interp, p, "w", 0666);
	Tcl_DStringFree(&buffer);
	if (psInfo.chan == NULL) {
	    goto cleanup;
	}
    }

    if (psInfo.channelName != NULL) {
        int mode;
        
        /*
         * Check that the channel is found in this interpreter and that it
         * is open for writing.
         */

        psInfo.chan = Tcl_GetChannel(interp, psInfo.channelName,
                &mode);
        if (psInfo.chan == (Tcl_Channel) NULL) {
            result = TCL_ERROR;
            goto cleanup;
        }
        if ((mode & TCL_WRITABLE) == 0) {
            Tcl_AppendResult(interp, "channel \"",
                    psInfo.channelName, "\" wasn't opened for writing",
                    (char *) NULL);
            result = TCL_ERROR;
            goto cleanup;
        }
    }
    
    /*
     *--------------------------------------------------------
     * Make a pre-pass over all of the items, generating Postscript
     * and then throwing it away.  The purpose of this pass is just
     * to collect information about all the fonts in use, so that
     * we can output font information in the proper form required
     * by the Document Structuring Conventions.
     *--------------------------------------------------------
     */

    psInfo.prepass = 1;
    for (itemPtr = canvasPtr->firstItemPtr; itemPtr != NULL;
	    itemPtr = itemPtr->nextPtr) {
	if ((itemPtr->x1 >= psInfo.x2) || (itemPtr->x2 < psInfo.x)
		|| (itemPtr->y1 >= psInfo.y2) || (itemPtr->y2 < psInfo.y)) {
	    continue;
	}
	if (itemPtr->typePtr->postscriptProc == NULL) {
	    continue;
	}
	result = (*itemPtr->typePtr->postscriptProc)(interp,
		(Tk_Canvas) canvasPtr, itemPtr, 1);
	Tcl_ResetResult(interp);
	if (result != TCL_OK) {
	    /*
	     * An error just occurred.  Just skip out of this loop.
	     * There's no need to report the error now;  it can be
	     * reported later (errors can happen later that don't
	     * happen now, so we still have to check for errors later
	     * anyway).
	     */
	    break;
	}
    }
    psInfo.prepass = 0;

    /*
     *--------------------------------------------------------
     * Generate the header and prolog for the Postscript.
     *--------------------------------------------------------
     */

    if (psInfo.prolog) {
      Tcl_AppendResult(interp, "%!PS-Adobe-3.0 EPSF-3.0\n",
		       "%%Creator: Tk Canvas Widget\n", (char *) NULL);
#ifdef HAVE_PW_GECOS
    if (!Tcl_IsSafe(interp)) {
	struct passwd *pwPtr = getpwuid(getuid());	/* INTL: Native. */
	Tcl_AppendResult(interp, "%%For: ",
		(pwPtr != NULL) ? pwPtr->pw_gecos : "Unknown", "\n",
		(char *) NULL);
	endpwent();
    }
#endif /* HAVE_PW_GECOS */
    Tcl_AppendResult(interp, "%%Title: Window ",
	    Tk_PathName(tkwin), "\n", (char *) NULL);
    time(&now);
    Tcl_AppendResult(interp, "%%CreationDate: ",
	    ctime(&now), (char *) NULL);		/* INTL: Native. */
    if (!psInfo.rotate) {
	sprintf(string, "%d %d %d %d",
		(int) (psInfo.pageX + psInfo.scale*deltaX),
		(int) (psInfo.pageY + psInfo.scale*deltaY),
		(int) (psInfo.pageX + psInfo.scale*(deltaX + psInfo.width)
			+ 1.0),
		(int) (psInfo.pageY + psInfo.scale*(deltaY + psInfo.height)
			+ 1.0));
    } else {
	sprintf(string, "%d %d %d %d",
		(int) (psInfo.pageX - psInfo.scale*(deltaY + psInfo.height)),
		(int) (psInfo.pageY + psInfo.scale*deltaX),
		(int) (psInfo.pageX - psInfo.scale*deltaY + 1.0),
		(int) (psInfo.pageY + psInfo.scale*(deltaX + psInfo.width)
			+ 1.0));
    }
    Tcl_AppendResult(interp, "%%BoundingBox: ", string,
	    "\n", (char *) NULL);
    Tcl_AppendResult(interp, "%%Pages: 1\n", 
	    "%%DocumentData: Clean7Bit\n", (char *) NULL);
    Tcl_AppendResult(interp, "%%Orientation: ",
	    psInfo.rotate ? "Landscape\n" : "Portrait\n", (char *) NULL);
    p = "%%DocumentNeededResources: font ";
    for (hPtr = Tcl_FirstHashEntry(&psInfo.fontTable, &search);
	    hPtr != NULL; hPtr = Tcl_NextHashEntry(&search)) {
	Tcl_AppendResult(interp, p,
		Tcl_GetHashKey(&psInfo.fontTable, hPtr),
		"\n", (char *) NULL);
	p = "%%+ font ";
    }
    Tcl_AppendResult(interp, "%%EndComments\n\n", (char *) NULL);

    /*
     * Insert the prolog
     */
    Tcl_AppendResult(interp, Tcl_GetVar(interp,"::tk::ps_preamable",
	    TCL_GLOBAL_ONLY), (char *) NULL);

    if (psInfo.chan != NULL) {
        Tcl_Write(psInfo.chan, Tcl_GetStringResult(interp), -1);
	Tcl_ResetResult(canvasPtr->interp);
    }

    /*
     *-----------------------------------------------------------
     * Document setup:  set the color level and include fonts.
     *-----------------------------------------------------------
     */

    sprintf(string, "/CL %d def\n", psInfo.colorLevel);
    Tcl_AppendResult(interp, "%%BeginSetup\n", string,
	    (char *) NULL);
    for (hPtr = Tcl_FirstHashEntry(&psInfo.fontTable, &search);
	    hPtr != NULL; hPtr = Tcl_NextHashEntry(&search)) {
	Tcl_AppendResult(interp, "%%IncludeResource: font ",
		Tcl_GetHashKey(&psInfo.fontTable, hPtr), "\n", (char *) NULL);
    }
    Tcl_AppendResult(interp, "%%EndSetup\n\n", (char *) NULL);

    /*
     *-----------------------------------------------------------
     * Page setup:  move to page positioning point, rotate if
     * needed, set scale factor, offset for proper anchor position,
     * and set clip region.
     *-----------------------------------------------------------
     */

    Tcl_AppendResult(interp, "%%Page: 1 1\n", "save\n",
	    (char *) NULL);
    sprintf(string, "%.1f %.1f translate\n", psInfo.pageX, psInfo.pageY);
    Tcl_AppendResult(interp, string, (char *) NULL);
    if (psInfo.rotate) {
	Tcl_AppendResult(interp, "90 rotate\n", (char *) NULL);
    }
    sprintf(string, "%.4g %.4g scale\n", psInfo.scale, psInfo.scale);
    Tcl_AppendResult(interp, string, (char *) NULL);
    sprintf(string, "%d %d translate\n", deltaX - psInfo.x, deltaY);
    Tcl_AppendResult(interp, string, (char *) NULL);
    sprintf(string, "%d %.15g moveto %d %.15g lineto %d %.15g lineto %d %.15g",
	    psInfo.x,
	    Tk_PostscriptY((double) psInfo.y, (Tk_PostscriptInfo) &psInfo),
	    psInfo.x2,
	    Tk_PostscriptY((double) psInfo.y, (Tk_PostscriptInfo) &psInfo),
	    psInfo.x2, 
	    Tk_PostscriptY((double) psInfo.y2, (Tk_PostscriptInfo) &psInfo),
	    psInfo.x,
	    Tk_PostscriptY((double) psInfo.y2, (Tk_PostscriptInfo) &psInfo));
    Tcl_AppendResult(interp, string,
	" lineto closepath clip newpath\n", (char *) NULL);
    }
    if (psInfo.chan != NULL) {
	Tcl_Write(psInfo.chan, Tcl_GetStringResult(interp), -1);
	Tcl_ResetResult(canvasPtr->interp);
    }

    /*
     *---------------------------------------------------------------------
     * Iterate through all the items, having each relevant one draw itself.
     * Quit if any of the items returns an error.
     *---------------------------------------------------------------------
     */

    result = TCL_OK;
    for (itemPtr = canvasPtr->firstItemPtr; itemPtr != NULL;
	    itemPtr = itemPtr->nextPtr) {
	if ((itemPtr->x1 >= psInfo.x2) || (itemPtr->x2 < psInfo.x)
		|| (itemPtr->y1 >= psInfo.y2) || (itemPtr->y2 < psInfo.y)) {
	    continue;
	}
	if (itemPtr->typePtr->postscriptProc == NULL) {
	    continue;
	}
	if (itemPtr->state == TK_STATE_HIDDEN) {
	    continue;
	}
	Tcl_AppendResult(interp, "gsave\n", (char *) NULL);
	result = (*itemPtr->typePtr->postscriptProc)(interp,
		(Tk_Canvas) canvasPtr, itemPtr, 0);
	if (result != TCL_OK) {
	    char msg[64 + TCL_INTEGER_SPACE];

	    sprintf(msg, "\n    (generating Postscript for item %d)",
		    itemPtr->id);
	    Tcl_AddErrorInfo(interp, msg);
	    goto cleanup;
	}
	Tcl_AppendResult(interp, "grestore\n", (char *) NULL);
	if (psInfo.chan != NULL) {
	    Tcl_Write(psInfo.chan, Tcl_GetStringResult(interp), -1);
	    Tcl_ResetResult(interp);
	}
    }

    /*
     *---------------------------------------------------------------------
     * Output page-end information, such as commands to print the page
     * and document trailer stuff.
     *---------------------------------------------------------------------
     */

    if (psInfo.prolog) {
      Tcl_AppendResult(interp, "restore showpage\n\n",
	    "%%Trailer\nend\n%%EOF\n", (char *) NULL);
    }
    if (psInfo.chan != NULL) {
	Tcl_Write(psInfo.chan, Tcl_GetStringResult(interp), -1);
	Tcl_ResetResult(canvasPtr->interp);
    }

    /*
     * Clean up psInfo to release malloc'ed stuff.
     */

    cleanup:
    if (psInfo.pageXString != NULL) {
	ckfree(psInfo.pageXString);
    }
    if (psInfo.pageYString != NULL) {
	ckfree(psInfo.pageYString);
    }
    if (psInfo.pageWidthString != NULL) {
	ckfree(psInfo.pageWidthString);
    }
    if (psInfo.pageHeightString != NULL) {
	ckfree(psInfo.pageHeightString);
    }
    if (psInfo.fontVar != NULL) {
	ckfree(psInfo.fontVar);
    }
    if (psInfo.colorVar != NULL) {
	ckfree(psInfo.colorVar);
    }
    if (psInfo.colorMode != NULL) {
	ckfree(psInfo.colorMode);
    }
    if (psInfo.fileName != NULL) {
	ckfree(psInfo.fileName);
    }
    if ((psInfo.chan != NULL) && (psInfo.channelName == NULL)) {
	Tcl_Close(interp, psInfo.chan);
    }
    if (psInfo.channelName != NULL) {
        ckfree(psInfo.channelName);
    }
    Tcl_DeleteHashTable(&psInfo.fontTable);
    canvasPtr->psInfo = (Tk_PostscriptInfo) oldInfoPtr;
    return result;
}

/*
 *--------------------------------------------------------------
 *
 * Tk_PostscriptColor --
 *
 *	This procedure is called by individual canvas items when
 *	they want to set a color value for output.  Given information
 *	about an X color, this procedure will generate Postscript
 *	commands to set up an appropriate color in Postscript.
 *
 * Results:
 *	Returns a standard Tcl return value.  If an error occurs
 *	then an error message will be left in the interp's result.
 *	If no error occurs, then additional Postscript will be
 *	appended to the interp's result.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

int
Tk_PostscriptColor(interp, psInfo, colorPtr)
    Tcl_Interp *interp;
    Tk_PostscriptInfo psInfo;		/* Postscript info. */
    XColor *colorPtr;			/* Information about color. */
{
    TkPostscriptInfo *psInfoPtr = (TkPostscriptInfo *) psInfo;
    int tmp;
    double red, green, blue;
    char string[200];

    if (psInfoPtr->prepass) {
	return TCL_OK;
    }

    /*
     * If there is a color map defined, then look up the color's name
     * in the map and use the Postscript commands found there, if there
     * are any.
     */

    if (psInfoPtr->colorVar != NULL) {
	CONST char *cmdString;

	cmdString = Tcl_GetVar2(interp, psInfoPtr->colorVar,
		Tk_NameOfColor(colorPtr), 0);
	if (cmdString != NULL) {
	    Tcl_AppendResult(interp, cmdString, "\n", (char *) NULL);
	    return TCL_OK;
	}
    }

    /*
     * No color map entry for this color.  Grab the color's intensities
     * and output Postscript commands for them.  Special note:  X uses
     * a range of 0-65535 for intensities, but most displays only use
     * a range of 0-255, which maps to (0, 256, 512, ... 65280) in the
     * X scale.  This means that there's no way to get perfect white,
     * since the highest intensity is only 65280 out of 65535.  To
     * work around this problem, rescale the X intensity to a 0-255
     * scale and use that as the basis for the Postscript colors.  This
     * scheme still won't work if the display only uses 4 bits per color,
     * but most diplays use at least 8 bits.
     */

    tmp = colorPtr->red;
    red = ((double) (tmp >> 8))/255.0;
    tmp = colorPtr->green;
    green = ((double) (tmp >> 8))/255.0;
    tmp = colorPtr->blue;
    blue = ((double) (tmp >> 8))/255.0;
    sprintf(string, "%.3f %.3f %.3f setrgbcolor AdjustColor\n",
	    red, green, blue);
    Tcl_AppendResult(interp, string, (char *) NULL);
    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * Tk_PostscriptFont --
 *
 *	This procedure is called by individual canvas items when
 *	they want to output text.  Given information about an X
 *	font, this procedure will generate Postscript commands
 *	to set up an appropriate font in Postscript.
 *
 * Results:
 *	Returns a standard Tcl return value.  If an error occurs
 *	then an error message will be left in the interp's result.
 *	If no error occurs, then additional Postscript will be
 *	appended to the interp's result.
 *
 * Side effects:
 *	The Postscript font name is entered into psInfoPtr->fontTable
 *	if it wasn't already there.
 *
 *--------------------------------------------------------------
 */

int
Tk_PostscriptFont(interp, psInfo, tkfont)
    Tcl_Interp *interp;
    Tk_PostscriptInfo psInfo;		/* Postscript Info. */
    Tk_Font tkfont;			/* Information about font in which text
					 * is to be printed. */
{
    TkPostscriptInfo *psInfoPtr = (TkPostscriptInfo *) psInfo;
    char *end;
    char pointString[TCL_INTEGER_SPACE];
    Tcl_DString ds;
    int i, points;

    /*
     * First, look up the font's name in the font map, if there is one.
     * If there is an entry for this font, it consists of a list
     * containing font name and size.  Use this information.
     */

    Tcl_DStringInit(&ds);
    
    if (psInfoPtr->fontVar != NULL) {
	CONST char *list;
	int argc;
	double size;
	CONST char **argv;
	CONST char *name;

	name = Tk_NameOfFont(tkfont);
	list = Tcl_GetVar2(interp, psInfoPtr->fontVar, name, 0);
	if (list != NULL) {
	    if (Tcl_SplitList(interp, list, &argc, &argv) != TCL_OK) {
		badMapEntry:
		Tcl_ResetResult(interp);
		Tcl_AppendResult(interp, "bad font map entry for \"", name,
			"\": \"", list, "\"", (char *) NULL);
		return TCL_ERROR;
	    }
	    if (argc != 2) {
		goto badMapEntry;
	    }
	    size = strtod(argv[1], &end);
	    if ((size <= 0) || (*end != 0)) {
		goto badMapEntry;
	    }

	    Tcl_DStringAppend(&ds, argv[0], -1);
	    points = (int) size;
	    
	    ckfree((char *) argv);
	    goto findfont;
	}
    } 

    points = Tk_PostscriptFontName(tkfont, &ds);

    findfont:
    sprintf(pointString, "%d", points);
    Tcl_AppendResult(interp, "/", Tcl_DStringValue(&ds), " findfont ",
	    pointString, " scalefont ", (char *) NULL);
    if (strncasecmp(Tcl_DStringValue(&ds), "Symbol", 7) != 0) {
	Tcl_AppendResult(interp, "ISOEncode ", (char *) NULL);
    }
    Tcl_AppendResult(interp, "setfont\n", (char *) NULL);
    Tcl_CreateHashEntry(&psInfoPtr->fontTable, Tcl_DStringValue(&ds), &i);
    Tcl_DStringFree(&ds);

    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * Tk_PostscriptBitmap --
 *
 *	This procedure is called to output the contents of a
 *	sub-region of a bitmap in proper image data format for
 *	Postscript (i.e. data between angle brackets, one bit
 *	per pixel).
 *
 * Results:
 *	Returns a standard Tcl return value.  If an error occurs
 *	then an error message will be left in the interp's result.
 *	If no error occurs, then additional Postscript will be
 *	appended to the interp's result.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

int
Tk_PostscriptBitmap(interp, tkwin, psInfo, bitmap, startX, startY, width,
	height)
    Tcl_Interp *interp;
    Tk_Window tkwin;
    Tk_PostscriptInfo psInfo;		/* Postscript info. */
    Pixmap bitmap;			/* Bitmap for which to generate
					 * Postscript. */
    int startX, startY;			/* Coordinates of upper-left corner
					 * of rectangular region to output. */
    int width, height;			/* Height of rectangular region. */
{
    TkPostscriptInfo *psInfoPtr = (TkPostscriptInfo *) psInfo;
    XImage *imagePtr;
    int charsInLine, x, y, lastX, lastY, value, mask;
    unsigned int totalWidth, totalHeight;
    char string[100];
    Window dummyRoot;
    int dummyX, dummyY;
    unsigned dummyBorderwidth, dummyDepth;

    if (psInfoPtr->prepass) {
	return TCL_OK;
    }

    /*
     * The following call should probably be a call to Tk_SizeOfBitmap
     * instead, but it seems that we are occasionally invoked by custom
     * item types that create their own bitmaps without registering them
     * with Tk.  XGetGeometry is a bit slower than Tk_SizeOfBitmap, but
     * it shouldn't matter here.
     */

    XGetGeometry(Tk_Display(tkwin), bitmap, &dummyRoot,
	    (int *) &dummyX, (int *) &dummyY, (unsigned int *) &totalWidth,
	    (unsigned int *) &totalHeight, &dummyBorderwidth, &dummyDepth);
    imagePtr = XGetImage(Tk_Display(tkwin), bitmap, 0, 0,
	    totalWidth, totalHeight, 1, XYPixmap);
    Tcl_AppendResult(interp, "<", (char *) NULL);
    mask = 0x80;
    value = 0;
    charsInLine = 0;
    lastX = startX + width - 1;
    lastY = startY + height - 1;
    for (y = lastY; y >= startY; y--) {
	for (x = startX; x <= lastX; x++) {
	    if (XGetPixel(imagePtr, x, y)) {
		value |= mask;
	    }
	    mask >>= 1;
	    if (mask == 0) {
		sprintf(string, "%02x", value);
		Tcl_AppendResult(interp, string, (char *) NULL);
		mask = 0x80;
		value = 0;
		charsInLine += 2;
		if (charsInLine >= 60) {
		    Tcl_AppendResult(interp, "\n", (char *) NULL);
		    charsInLine = 0;
		}
	    }
	}
	if (mask != 0x80) {
	    sprintf(string, "%02x", value);
	    Tcl_AppendResult(interp, string, (char *) NULL);
	    mask = 0x80;
	    value = 0;
	    charsInLine += 2;
	}
    }
    Tcl_AppendResult(interp, ">", (char *) NULL);
    XDestroyImage(imagePtr);
    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * Tk_PostscriptStipple --
 *
 *	This procedure is called by individual canvas items when
 *	they have created a path that they'd like to be filled with
 *	a stipple pattern.  Given information about an X bitmap,
 *	this procedure will generate Postscript commands to fill
 *	the current clip region using a stipple pattern defined by the
 *	bitmap.
 *
 * Results:
 *	Returns a standard Tcl return value.  If an error occurs
 *	then an error message will be left in the interp's result.
 *	If no error occurs, then additional Postscript will be
 *	appended to the interp's result.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

int
Tk_PostscriptStipple(interp, tkwin, psInfo, bitmap)
    Tcl_Interp *interp;
    Tk_Window tkwin;
    Tk_PostscriptInfo psInfo;		/* Interpreter for returning Postscript
					 * or error message. */
    Pixmap bitmap;			/* Bitmap to use for stippling. */
{
    TkPostscriptInfo *psInfoPtr = (TkPostscriptInfo *) psInfo;
    int width, height;
    char string[TCL_INTEGER_SPACE * 2];
    Window dummyRoot;
    int dummyX, dummyY;
    unsigned dummyBorderwidth, dummyDepth;

    if (psInfoPtr->prepass) {
	return TCL_OK;
    }

    /*
     * The following call should probably be a call to Tk_SizeOfBitmap
     * instead, but it seems that we are occasionally invoked by custom
     * item types that create their own bitmaps without registering them
     * with Tk.  XGetGeometry is a bit slower than Tk_SizeOfBitmap, but
     * it shouldn't matter here.
     */

    XGetGeometry(Tk_Display(tkwin), bitmap, &dummyRoot,
	    (int *) &dummyX, (int *) &dummyY, (unsigned *) &width,
	    (unsigned *) &height, &dummyBorderwidth, &dummyDepth);
    sprintf(string, "%d %d ", width, height);
    Tcl_AppendResult(interp, string, (char *) NULL);
    if (Tk_PostscriptBitmap(interp, tkwin, psInfo, bitmap, 0, 0,
	    width, height) != TCL_OK) {
	return TCL_ERROR;
    }
    Tcl_AppendResult(interp, " StippleFill\n", (char *) NULL);
    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * Tk_PostscriptY --
 *
 *	Given a y-coordinate in local coordinates, this procedure
 *	returns a y-coordinate to use for Postscript output.
 *
 * Results:
 *	Returns the Postscript coordinate that corresponds to
 *	"y".
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

double
Tk_PostscriptY(y, psInfo)
    double y;				/* Y-coordinate in canvas coords. */
    Tk_PostscriptInfo psInfo;		/* Postscript info */
{
    TkPostscriptInfo *psInfoPtr = (TkPostscriptInfo *) psInfo;

    return psInfoPtr->y2 - y;
}

/*
 *--------------------------------------------------------------
 *
 * Tk_PostscriptPath --
 *
 *	Given an array of points for a path, generate Postscript
 *	commands to create the path.
 *
 * Results:
 *	Postscript commands get appended to what's in the interp's result.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

void
Tk_PostscriptPath(interp, psInfo, coordPtr, numPoints)
    Tcl_Interp *interp;
    Tk_PostscriptInfo psInfo;		/* Canvas on whose behalf Postscript
					 * is being generated. */
    double *coordPtr;			/* Pointer to first in array of
					 * 2*numPoints coordinates giving
					 * points for path. */
    int numPoints;			/* Number of points at *coordPtr. */
{
    TkPostscriptInfo *psInfoPtr = (TkPostscriptInfo *) psInfo;
    char buffer[200];

    if (psInfoPtr->prepass) {
	return;
    }
    sprintf(buffer, "%.15g %.15g moveto\n", coordPtr[0],
	    Tk_PostscriptY(coordPtr[1], psInfo));
    Tcl_AppendResult(interp, buffer, (char *) NULL);
    for (numPoints--, coordPtr += 2; numPoints > 0;
	    numPoints--, coordPtr += 2) {
	sprintf(buffer, "%.15g %.15g lineto\n", coordPtr[0],
		Tk_PostscriptY(coordPtr[1], psInfo));
	Tcl_AppendResult(interp, buffer, (char *) NULL);
    }
}

/*
 *--------------------------------------------------------------
 *
 * GetPostscriptPoints --
 *
 *	Given a string, returns the number of Postscript points
 *	corresponding to that string.
 *
 * Results:
 *	The return value is a standard Tcl return result.  If
 *	TCL_OK is returned, then everything went well and the
 *	screen distance is stored at *doublePtr;  otherwise
 *	TCL_ERROR is returned and an error message is left in
 *	the interp's result.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

static int
GetPostscriptPoints(interp, string, doublePtr)
    Tcl_Interp *interp;		/* Use this for error reporting. */
    char *string;		/* String describing a screen distance. */
    double *doublePtr;		/* Place to store converted result. */
{
    char *end;
    double d;

    d = strtod(string, &end);
    if (end == string) {
	error:
	Tcl_AppendResult(interp, "bad distance \"", string,
		"\"", (char *) NULL);
	return TCL_ERROR;
    }
    while ((*end != '\0') && isspace(UCHAR(*end))) {
	end++;
    }
    switch (*end) {
	case 'c':
	    d *= 72.0/2.54;
	    end++;
	    break;
	case 'i':
	    d *= 72.0;
	    end++;
	    break;
	case 'm':
	    d *= 72.0/25.4;
	    end++;
	    break;
	case 0:
	    break;
	case 'p':
	    end++;
	    break;
	default:
	    goto error;
    }
    while ((*end != '\0') && isspace(UCHAR(*end))) {
	end++;
    }
    if (*end != 0) {
	goto error;
    }
    *doublePtr = d;
    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * TkImageGetColor --
 *
 *	This procedure converts a pixel value to three floating
 *      point numbers, representing the amount of red, green, and 
 *      blue in that pixel on the screen.  It makes use of colormap
 *      data passed as an argument, and should work for all Visual
 *      types.
 *
 *	This implementation is bogus on Windows because the colormap
 *	data is never filled in.  Instead all postscript generated
 *	data coming through here is expected to be RGB color data.
 *	To handle lower bit-depth images properly, XQueryColors
 *	must be implemented for Windows.
 *
 * Results:
 *	Returns red, green, and blue color values in the range 
 *      0 to 1.  There are no error returns.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */
#ifdef WIN32
#include <windows.h>

/*
 * We could just define these instead of pulling in windows.h.
 #define GetRValue(rgb)	((BYTE)(rgb))
 #define GetGValue(rgb)	((BYTE)(((WORD)(rgb)) >> 8))
 #define GetBValue(rgb)	((BYTE)((rgb)>>16))
*/

static void
TkImageGetColor(cdata, pixel, red, green, blue)
    TkColormapData *cdata;              /* Colormap data */
    unsigned long pixel;                /* Pixel value to look up */
    double *red, *green, *blue;         /* Color data to return */
{
    *red   = (double) GetRValue(pixel) / 255.0;
    *green = (double) GetGValue(pixel) / 255.0;
    *blue  = (double) GetBValue(pixel) / 255.0;
}
#else
static void
TkImageGetColor(cdata, pixel, red, green, blue)
    TkColormapData *cdata;              /* Colormap data */
    unsigned long pixel;                /* Pixel value to look up */
    double *red, *green, *blue;         /* Color data to return */
{
    if (cdata->separated) {
	int r = (pixel & cdata->red_mask) >> cdata->red_shift;
	int g = (pixel & cdata->green_mask) >> cdata->green_shift;
	int b = (pixel & cdata->blue_mask) >> cdata->blue_shift;
	*red   = cdata->colors[r].red / 65535.0;
	*green = cdata->colors[g].green / 65535.0;
	*blue  = cdata->colors[b].blue / 65535.0;
    } else {
	*red   = cdata->colors[pixel].red / 65535.0;
	*green = cdata->colors[pixel].green / 65535.0;
	*blue  = cdata->colors[pixel].blue / 65535.0;
    }
}
#endif

/*
 *--------------------------------------------------------------
 *
 * TkPostscriptImage --
 *
 *	This procedure is called to output the contents of an
 *	image in Postscript, using a format appropriate for the 
 *      current color mode (i.e. one bit per pixel in monochrome, 
 *      one byte per pixel in gray, and three bytes per pixel in
 *      color).
 *
 * Results:
 *	Returns a standard Tcl return value.  If an error occurs
 *	then an error message will be left in interp->result.
 *	If no error occurs, then additional Postscript will be
 *	appended to interp->result.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

int
TkPostscriptImage(interp, tkwin, psInfo, ximage, x, y, width, height)
    Tcl_Interp *interp;
    Tk_Window tkwin;
    Tk_PostscriptInfo psInfo;	/* postscript info */
    XImage *ximage;		/* Image to draw */
    int x, y;			/* First pixel to output */
    int width, height;		/* Width and height of area */
{
    TkPostscriptInfo *psInfoPtr = (TkPostscriptInfo *) psInfo;
    char buffer[256];
    int xx, yy, band, maxRows;
    double red, green, blue;
    int bytesPerLine=0, maxWidth=0;
    int level = psInfoPtr->colorLevel;
    Colormap cmap;
    int i, depth, ncolors;
    Visual *visual;
    TkColormapData cdata;

    if (psInfoPtr->prepass) {
	return TCL_OK;
    }

    cmap = Tk_Colormap(tkwin);
    depth = Tk_Depth(tkwin);
    visual = Tk_Visual(tkwin);

    /*
     * Obtain information about the colormap, ie the mapping between
     * pixel values and RGB values.  The code below should work
     * for all Visual types.
     */

    ncolors = visual->map_entries;
    cdata.colors = (XColor *) ckalloc(sizeof(XColor) * ncolors);
    cdata.ncolors = ncolors;

    if (visual->class == DirectColor || visual->class == TrueColor) {
	cdata.separated = 1;
	cdata.red_mask = visual->red_mask;
	cdata.green_mask = visual->green_mask;
	cdata.blue_mask = visual->blue_mask;
	cdata.red_shift = 0;
	cdata.green_shift = 0;
	cdata.blue_shift = 0;
	while ((0x0001 & (cdata.red_mask >> cdata.red_shift)) == 0)
	    cdata.red_shift ++;
	while ((0x0001 & (cdata.green_mask >> cdata.green_shift)) == 0)
	    cdata.green_shift ++;
	while ((0x0001 & (cdata.blue_mask >> cdata.blue_shift)) == 0)
	    cdata.blue_shift ++;
	for (i = 0; i < ncolors; i ++)
	    cdata.colors[i].pixel =
		((i << cdata.red_shift) & cdata.red_mask) |
		((i << cdata.green_shift) & cdata.green_mask) |
		((i << cdata.blue_shift) & cdata.blue_mask);
    } else {
	cdata.separated=0;
	for (i = 0; i < ncolors; i ++)
	    cdata.colors[i].pixel = i;
    }
    if (visual->class == StaticGray || visual->class == GrayScale)
	cdata.color = 0;
    else
	cdata.color = 1;

    XQueryColors(Tk_Display(tkwin), cmap, cdata.colors, ncolors);

    /*
     * Figure out which color level to use (possibly lower than the 
     * one specified by the user).  For example, if the user specifies
     * color with monochrome screen, use gray or monochrome mode instead. 
     */

    if (!cdata.color && level == 2) {
	level = 1;
    }

    if (!cdata.color && cdata.ncolors == 2) {
	level = 0;
    }

    /*
     * Check that at least one row of the image can be represented
     * with a string less than 64 KB long (this is a limit in the 
     * Postscript interpreter).
     */

    switch (level) {
	case 0: bytesPerLine = (width + 7) / 8;  maxWidth = 240000;  break;
	case 1: bytesPerLine = width;  maxWidth = 60000;  break;
	case 2: bytesPerLine = 3 * width;  maxWidth = 20000;  break;
    }

    if (bytesPerLine > 60000) {
	Tcl_ResetResult(interp);
	sprintf(buffer,
		"Can't generate Postscript for images more than %d pixels wide",
		maxWidth);
	Tcl_AppendResult(interp, buffer, (char *) NULL);
	ckfree((char *) cdata.colors);
	return TCL_ERROR;
    }

    maxRows = 60000 / bytesPerLine;

    for (band = height-1; band >= 0; band -= maxRows) {
	int rows = (band >= maxRows) ? maxRows : band + 1;
	int lineLen = 0;
	switch (level) {
	    case 0:
		sprintf(buffer, "%d %d 1 matrix {\n<", width, rows);
		Tcl_AppendResult(interp, buffer, (char *) NULL);
		break;
	    case 1:
		sprintf(buffer, "%d %d 8 matrix {\n<", width, rows);
		Tcl_AppendResult(interp, buffer, (char *) NULL);
		break;
	    case 2:
		sprintf(buffer, "%d %d 8 matrix {\n<",
			width, rows);
		Tcl_AppendResult(interp, buffer, (char *) NULL);
		break;
	}
	for (yy = band; yy > band - rows; yy--) {
	    switch (level) {
		case 0: {
		    /*
		     * Generate data for image in monochrome mode.
		     * No attempt at dithering is made--instead, just
		     * set a threshold.
		     */
		    unsigned char mask=0x80;
		    unsigned char data=0x00;
		    for (xx = x; xx< x+width; xx++) {
			TkImageGetColor(&cdata, XGetPixel(ximage, xx, yy),
					&red, &green, &blue);
			if (0.30 * red + 0.59 * green + 0.11 * blue > 0.5)
			    data |= mask;
			mask >>= 1;
			if (mask == 0) {
			    sprintf(buffer, "%02X", data);
			    Tcl_AppendResult(interp, buffer, (char *) NULL);
			    lineLen += 2;
			    if (lineLen > 60) {
			        lineLen = 0;
			        Tcl_AppendResult(interp, "\n", (char *) NULL);
			    }
			    mask=0x80;
			    data=0x00;
			}
		    }
		    if ((width % 8) != 0) {
		        sprintf(buffer, "%02X", data);
		        Tcl_AppendResult(interp, buffer, (char *) NULL);
		        mask=0x80;
		        data=0x00;
		    }
		    break;
		}
		case 1: {
		    /*
		     * Generate data in gray mode--in this case, take a 
		     * weighted sum of the red, green, and blue values.
		     */
		    for (xx = x; xx < x+width; xx ++) {
			TkImageGetColor(&cdata, XGetPixel(ximage, xx, yy),
					&red, &green, &blue);
			sprintf(buffer, "%02X", (int) floor(0.5 + 255.0 *
				(0.30 * red + 0.59 * green + 0.11 * blue)));
			Tcl_AppendResult(interp, buffer, (char *) NULL);
			lineLen += 2;
			if (lineLen > 60) {
			    lineLen = 0;
			    Tcl_AppendResult(interp, "\n", (char *) NULL);
			}
		    }
		    break;
		}
		case 2: {
		    /*
		     * Finally, color mode.  Here, just output the red, green,
		     * and blue values directly.
		     */
		    for (xx = x; xx < x+width; xx++) {
			TkImageGetColor(&cdata, XGetPixel(ximage, xx, yy),
				&red, &green, &blue);
			sprintf(buffer, "%02X%02X%02X",
				(int) floor(0.5 + 255.0 * red),
				(int) floor(0.5 + 255.0 * green),
				(int) floor(0.5 + 255.0 * blue));
			Tcl_AppendResult(interp, buffer, (char *) NULL);
			lineLen += 6;
			if (lineLen > 60) {
			    lineLen = 0;
			    Tcl_AppendResult(interp, "\n", (char *) NULL);
			}
		    }
		    break;
		}
	    }
	}
	switch (level) {
	    case 0: sprintf(buffer, ">\n} image\n"); break;
	    case 1: sprintf(buffer, ">\n} image\n"); break;
	    case 2: sprintf(buffer, ">\n} false 3 colorimage\n"); break;
	}
	Tcl_AppendResult(interp, buffer, (char *) NULL);
	sprintf(buffer, "0 %d translate\n", rows);
	Tcl_AppendResult(interp, buffer, (char *) NULL);
    }
    ckfree((char *) cdata.colors);
    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * Tk_PostscriptPhoto --
 *
 *	This procedure is called to output the contents of a
 *	photo image in Postscript, using a format appropriate for
 *	the requested postscript color mode (i.e. one byte per pixel
 *	in gray, and three bytes per pixel in color).
 *
 * Results:
 *	Returns a standard Tcl return value.  If an error occurs
 *	then an error message will be left in interp->result.
 *	If no error occurs, then additional Postscript will be
 *	appended to the interpreter's result.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */
int
Tk_PostscriptPhoto(interp, blockPtr, psInfo, width, height)
    Tcl_Interp *interp;
    Tk_PhotoImageBlock *blockPtr;
    Tk_PostscriptInfo psInfo;
    int width, height;
{
    TkPostscriptInfo *psInfoPtr = (TkPostscriptInfo *) psInfo;
    int colorLevel = psInfoPtr->colorLevel;
    static int codeIncluded = 0;

    unsigned char *pixelPtr;
    char buffer[256], cspace[40], decode[40];
    int bpc;
    int xx, yy, lineLen;
    float red, green, blue;
    int alpha;
    int bytesPerLine=0, maxWidth=0;

    unsigned char opaque = 255;
    unsigned char *alphaPtr;
    int alphaOffset, alphaPitch, alphaIncr;

    if (psInfoPtr->prepass) {
	codeIncluded = 0;
	return TCL_OK;
    }

    /*
     * Define the "TkPhoto" function, which is a modified version
     * of the original "transparentimage" function posted
     * by ian@@five-d.com (Ian Kemmish) to comp.lang.postscript.
     * For a monochrome colorLevel this is a slightly different
     * version that uses the imagemask command instead of image.
     */

    if( !codeIncluded && (colorLevel != 0) ) {
	/*
	 * Color and gray-scale code.
	 */

	codeIncluded = !0;
	Tcl_AppendResult( interp,
		"/TkPhoto { \n",
		"  gsave \n",
		"  32 dict begin \n",
		"  /tinteger exch def \n",
		"  /transparent 1 string def \n",
		"  transparent 0 tinteger put \n",
		"  /olddict exch def \n",
		"  olddict /DataSource get dup type /filetype ne { \n",
		"    olddict /DataSource 3 -1 roll \n",
		"    0 () /SubFileDecode filter put \n",
		"  } { \n",
		"    pop \n",
		"  } ifelse \n",
		"  /newdict olddict maxlength dict def \n",
		"  olddict newdict copy pop \n",
		"  /w newdict /Width get def \n",
		"  /crpp newdict /Decode get length 2 idiv def \n",
		"  /str w string def \n",
		"  /pix w crpp mul string def \n",
		"  /substrlen 2 w log 2 log div floor exp cvi def \n",
		"  /substrs [ \n",
		"  { \n",
		"     substrlen string \n",
		"     0 1 substrlen 1 sub { \n",
		"       1 index exch tinteger put \n",
		"     } for \n",
		"     /substrlen substrlen 2 idiv def \n",
		"     substrlen 0 eq {exit} if \n",
		"  } loop \n",
		"  ] def \n",
		"  /h newdict /Height get def \n",
		"  1 w div 1 h div matrix scale \n",
		"  olddict /ImageMatrix get exch matrix concatmatrix \n",
		"  matrix invertmatrix concat \n",
		"  newdict /Height 1 put \n",
		"  newdict /DataSource pix put \n",
		"  /mat [w 0 0 h 0 0] def \n",
		"  newdict /ImageMatrix mat put \n",
		"  0 1 h 1 sub { \n",
		"    mat 5 3 -1 roll neg put \n",
		"    olddict /DataSource get str readstring pop pop \n",
		"    /tail str def \n",
		"    /x 0 def \n",
		"    olddict /DataSource get pix readstring pop pop \n",
		"    { \n",
		"      tail transparent search dup /done exch not def \n",
		"      {exch pop exch pop} if \n",
		"      /w1 exch length def \n",
		"      w1 0 ne { \n",
		"        newdict /DataSource ",
		          " pix x crpp mul w1 crpp mul getinterval put \n",
		"        newdict /Width w1 put \n",
		"        mat 4 x neg put \n",
		"        /x x w1 add def \n",
		"        newdict image \n",
		"        /tail tail w1 tail length w1 sub getinterval def \n",
		"      } if \n",
		"      done {exit} if \n",
		"      tail substrs { \n",
		"        anchorsearch {pop} if \n",
		"      } forall \n",
		"      /tail exch def \n",
		"      tail length 0 eq {exit} if \n",
		"      /x w tail length sub def \n",
		"    } loop \n",
		"  } for \n",
		"  end \n",
		"  grestore \n",
		"} bind def \n\n\n", (char *) NULL);
    } else if( !codeIncluded && (colorLevel == 0) ) {
	/*
	 * Monochrome-only code
	 */

	codeIncluded = !0;
	Tcl_AppendResult( interp,
		"/TkPhoto { \n",
		"  gsave \n",
		"  32 dict begin \n",
		"  /dummyInteger exch def \n",
		"  /olddict exch def \n",
		"  olddict /DataSource get dup type /filetype ne { \n",
		"    olddict /DataSource 3 -1 roll \n",
		"    0 () /SubFileDecode filter put \n",
		"  } { \n",
		"    pop \n",
		"  } ifelse \n",
		"  /newdict olddict maxlength dict def \n",
		"  olddict newdict copy pop \n",
		"  /w newdict /Width get def \n",
		"  /pix w 7 add 8 idiv string def \n",
		"  /h newdict /Height get def \n",
		"  1 w div 1 h div matrix scale \n",
		"  olddict /ImageMatrix get exch matrix concatmatrix \n",
		"  matrix invertmatrix concat \n",
		"  newdict /Height 1 put \n",
		"  newdict /DataSource pix put \n",
		"  /mat [w 0 0 h 0 0] def \n",
		"  newdict /ImageMatrix mat put \n",
		"  0 1 h 1 sub { \n",
		"    mat 5 3 -1 roll neg put \n",
		"    0.000 0.000 0.000 setrgbcolor \n",
		"    olddict /DataSource get pix readstring pop pop \n",
		"    newdict /DataSource pix put \n",
		"    newdict imagemask \n",
		"    1.000 1.000 1.000 setrgbcolor \n",
		"    olddict /DataSource get pix readstring pop pop \n",
		"    newdict /DataSource pix put \n",
		"    newdict imagemask \n",
		"  } for \n",
		"  end \n",
		"  grestore \n",
		"} bind def \n\n\n", (char *) NULL);
    }

    /*
     * Check that at least one row of the image can be represented
     * with a string less than 64 KB long (this is a limit in the
     * Postscript interpreter).
     */

    switch (colorLevel)
	{
	    case 0: bytesPerLine = (width + 7) / 8;  maxWidth = 240000;  break;
	    case 1: bytesPerLine = width;  maxWidth = 60000;  break;
	    case 2: bytesPerLine = 3 * width;  maxWidth = 20000;  break;
	}
    if (bytesPerLine > 60000) {
	Tcl_ResetResult(interp);
	sprintf(buffer,
		"Can't generate Postscript for images more than %d pixels wide",
		maxWidth);
	Tcl_AppendResult(interp, buffer, (char *) NULL);
	return TCL_ERROR;
    }

    /*
     * Set up the postscript code except for the image-data stream.
     */

    switch (colorLevel) {
	case 0: 
	    strcpy( cspace, "/DeviceGray");
	    strcpy( decode, "[1 0]");
	    bpc = 1;
	    break;
	case 1: 
	    strcpy( cspace, "/DeviceGray");
	    strcpy( decode, "[0 1]");
	    bpc = 8;
	    break;
	default:
	    strcpy( cspace, "/DeviceRGB");
	    strcpy( decode, "[0 1 0 1 0 1]");
	    bpc = 8;
	    break;
    }


    Tcl_AppendResult(interp,
	    cspace, " setcolorspace\n\n", (char *) NULL);

    sprintf(buffer,
	    "  /Width %d\n  /Height %d\n  /BitsPerComponent %d\n",
	    width, height,  bpc);
    Tcl_AppendResult(interp,
	    "<<\n  /ImageType 1\n", buffer,
	    "  /DataSource currentfile",
	    "  /ASCIIHexDecode filter\n", (char *) NULL);


    sprintf(buffer,
	    "  /ImageMatrix [1 0 0 -1 0 %d]\n", height);
    Tcl_AppendResult(interp, buffer,
	    "  /Decode ", decode, "\n>>\n1 TkPhoto\n", (char *) NULL);


    /*
     * Check the PhotoImageBlock information.
     * We assume that:
     *     if pixelSize is 1,2 or 4, the image is R,G,B,A;
     *     if pixelSize is 3, the image is R,G,B and offset[3] is bogus.
     */

    if (blockPtr->pixelSize == 3) {
	/*
	 * No alpha information: the whole image is opaque.
	 */

	alphaPtr = &opaque;
	alphaPitch = alphaIncr = alphaOffset = 0;
    } else {
	/*
	 * Set up alpha handling.
	 */

	alphaPtr = blockPtr->pixelPtr;
	alphaPitch = blockPtr->pitch;
	alphaIncr = blockPtr->pixelSize;
	alphaOffset = blockPtr->offset[3];
    }


    for (yy = 0, lineLen=0; yy < height; yy++) {
	switch (colorLevel) {
	    case 0: {
		/*
		 * Generate data for image in monochrome mode.
		 * No attempt at dithering is made--instead, just
		 * set a threshold.
		 * To handle transparecies we need to output two lines:
		 * one for the black pixels, one for the white ones.
		 */

		unsigned char mask=0x80;
		unsigned char data=0x00;
		for (xx = 0; xx< width; xx ++) {
		    pixelPtr = blockPtr->pixelPtr 
			+ (yy * blockPtr->pitch) 
			+ (xx *blockPtr->pixelSize);

		    red = pixelPtr[blockPtr->offset[0]];
		    green = pixelPtr[blockPtr->offset[1]];
		    blue = pixelPtr[blockPtr->offset[2]];

		    alpha = *(alphaPtr + (yy * alphaPitch)
			    + (xx * alphaIncr) + alphaOffset);

		    /*
		     * If pixel is less than threshold, then it is black.
		     */

		    if ((alpha != 0) && 
			    ( 0.3086 * red 
				    + 0.6094 * green 
				    + 0.082 * blue < 128)) {
			data |= mask;
		    }
		    mask >>= 1;
		    if (mask == 0) {
			sprintf(buffer, "%02X", data);
			Tcl_AppendResult(interp, buffer, (char *) NULL);
			lineLen += 2;
			if (lineLen >= 60) {
			    lineLen = 0;
			    Tcl_AppendResult(interp, "\n", (char *) NULL);
			}
			mask=0x80;
			data=0x00;
		    }
		}
		if ((width % 8) != 0) {
		    sprintf(buffer, "%02X", data);
		    Tcl_AppendResult(interp, buffer, (char *) NULL);
		    mask=0x80;
		    data=0x00;
		}

		mask=0x80;
		data=0x00;
		for (xx = 0; xx< width; xx ++) {
		    pixelPtr = blockPtr->pixelPtr 
			+ (yy * blockPtr->pitch) 
			+ (xx *blockPtr->pixelSize);

		    red = pixelPtr[blockPtr->offset[0]];
		    green = pixelPtr[blockPtr->offset[1]];
		    blue = pixelPtr[blockPtr->offset[2]];

		    alpha = *(alphaPtr + (yy * alphaPitch)
			    + (xx * alphaIncr) + alphaOffset);
			    
		    /*
		     * If pixel is greater than threshold, then it is white.
		     */

		    if ((alpha != 0) && 
			    (  0.3086 * red 
				    + 0.6094 * green 
				    + 0.082 * blue >= 128)) {
			data |= mask;
		    }
		    mask >>= 1;
		    if (mask == 0) {
			sprintf(buffer, "%02X", data);
			Tcl_AppendResult(interp, buffer, (char *) NULL);
			lineLen += 2;
			if (lineLen >= 60) {
			    lineLen = 0;
			    Tcl_AppendResult(interp, "\n", (char *) NULL);
			}
			mask=0x80;
			data=0x00;
		    }
		}
		if ((width % 8) != 0) {
		    sprintf(buffer, "%02X", data);
		    Tcl_AppendResult(interp, buffer, (char *) NULL);
		    mask=0x80;
		    data=0x00;
		}
		break;
	    }
	    case 1: {
		/*
		 * Generate transparency data.
		 * We must prevent a transparent value of 0
		 * because of a bug in some HP printers.
		 */

		for (xx = 0; xx < width; xx ++) {
		    alpha = *(alphaPtr + (yy * alphaPitch)
			    + (xx * alphaIncr) + alphaOffset);
		    sprintf(buffer, "%02X", alpha | 0x01);
		    Tcl_AppendResult(interp, buffer, (char *) NULL);
		    lineLen += 2;
		    if (lineLen >= 60) {
			lineLen = 0;
			Tcl_AppendResult(interp, "\n", (char *) NULL);
		    }
		}


		/*
		 * Generate data in gray mode--in this case, take a 
		 * weighted sum of the red, green, and blue values.
		 */

		for (xx = 0; xx < width; xx ++) {
		    pixelPtr = blockPtr->pixelPtr 
			+ (yy * blockPtr->pitch) 
			+ (xx *blockPtr->pixelSize);

		    red = pixelPtr[blockPtr->offset[0]];
		    green = pixelPtr[blockPtr->offset[1]];
		    blue = pixelPtr[blockPtr->offset[2]];

		    sprintf(buffer, "%02X", (int) floor(0.5 +
			    ( 0.3086 * red + 0.6094 * green + 0.0820 * blue)));
		    Tcl_AppendResult(interp, buffer, (char *) NULL);
		    lineLen += 2;
		    if (lineLen >= 60) {
			lineLen = 0;
			Tcl_AppendResult(interp, "\n", (char *) NULL);
		    }
		}
		break;
	    }
	    default: {
		/*
		 * Generate transparency data.
		 * We must prevent a transparent value of 0
		 * because of a bug in some HP printers.
		 */

		for (xx = 0; xx < width; xx ++) {
		    alpha = *(alphaPtr + (yy * alphaPitch)
			    + (xx * alphaIncr) + alphaOffset);
		    sprintf(buffer, "%02X", alpha | 0x01);
		    Tcl_AppendResult(interp, buffer, (char *) NULL);
		    lineLen += 2;
		    if (lineLen >= 60) {
			lineLen = 0;
			Tcl_AppendResult(interp, "\n", (char *) NULL);
		    }
		}


		/*
		 * Finally, color mode.  Here, just output the red, green,
		 * and blue values directly.
		 */

		for (xx = 0; xx < width; xx ++) {
		    pixelPtr = blockPtr->pixelPtr 
			+ (yy * blockPtr->pitch) 
			+ (xx *blockPtr->pixelSize);

		    sprintf(buffer, "%02X%02X%02X",
			    pixelPtr[blockPtr->offset[0]],
			    pixelPtr[blockPtr->offset[1]],
			    pixelPtr[blockPtr->offset[2]]);
		    Tcl_AppendResult(interp, buffer, (char *) NULL);
		    lineLen += 6;
		    if (lineLen >= 60) {
			lineLen = 0;
			Tcl_AppendResult(interp, "\n", (char *) NULL);
		    }
		}
		break;
	    }
	}
    }

    Tcl_AppendResult(interp, ">\n", (char *) NULL);
    return TCL_OK;
}
@


1.4
log
@touched all sources to ease next import
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tkCanvPs.c,v 1.7.6.2 2000/09/26 16:07:51 spolk Exp $
d26 14
a132 314
 * The prolog data. Generated by str2c from prolog.ps
 * This was split in small chunks by str2c because
 * some C compiler have limitations on the size of static strings.
 * (str2c is a small tcl script in tcl's tool directory (source release))
 */
static CONST char * CONST  prolog[]= {
	/* Start of part 1 (2000 characters) */
	"%%BeginProlog\n\
50 dict begin\n\
\n\
% This is a standard prolog for Postscript generated by Tk's canvas\n\
% widget.\n\
% RCS: @@(#) $Id: tkCanvPs.c,v 1.7.6.2 2000/09/26 16:07:51 spolk Exp $\n\
\n\
% The definitions below just define all of the variables used in\n\
% any of the procedures here.  This is needed for obscure reasons\n\
% explained on p. 716 of the Postscript manual (Section H.2.7,\n\
% \"Initializing Variables,\" in the section on Encapsulated Postscript).\n\
\n\
/baseline 0 def\n\
/stipimage 0 def\n\
/height 0 def\n\
/justify 0 def\n\
/lineLength 0 def\n\
/spacing 0 def\n\
/stipple 0 def\n\
/strings 0 def\n\
/xoffset 0 def\n\
/yoffset 0 def\n\
/tmpstip null def\n\
\n\
% Define the array ISOLatin1Encoding (which specifies how characters are\n\
% encoded for ISO-8859-1 fonts), if it isn't already present (Postscript\n\
% level 2 is supposed to define it, but level 1 doesn't).\n\
\n\
systemdict /ISOLatin1Encoding known not {\n\
    /ISOLatin1Encoding [\n\
	/space /space /space /space /space /space /space /space\n\
	/space /space /space /space /space /space /space /space\n\
	/space /space /space /space /space /space /space /space\n\
	/space /space /space /space /space /space /space /space\n\
	/space /exclam /quotedbl /numbersign /dollar /percent /ampersand\n\
	    /quoteright\n\
	/parenleft /parenright /asterisk /plus /comma /minus /period /slash\n\
	/zero /one /two /three /four /five /six /seven\n\
	/eight /nine /colon /semicolon /less /equal /greater /question\n\
	/at /A /B /C /D /E /F /G\n\
	/H /I /J /K /L /M /N /O\n\
	/P /Q /R /S /T /U /V /W\n\
	/X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore\n\
	/quoteleft /a /b /c /d /e /f /g\n\
	/h /i /j /k /l /m /n /o\n\
	/p /q /r /s /t /u /v /w\n\
	/x /y /z /braceleft /bar /braceright /asciitilde /space\n\
	/space /space /space /space /space /space /space /space\n\
	/space /space /space /space /space /space /space /space\n\
	/dotlessi /grave /acute /circumflex /tilde /macron /breve /dotaccent\n\
	/dieresis /space /ring /cedilla /space /hungarumlaut /ogonek /caron\n\
	/space /exclamdown /cent /sterling /currency /yen /brokenbar /section\n\
	/dieresis /copyright /ordfem",
	/* End of part 1 */

	/* Start of part 2 (2000 characters) */
	"inine /guillemotleft /logicalnot /hyphen\n\
	    /registered /macron\n\
	/degree /plusminus /twosuperior /threesuperior /acute /mu /paragraph\n\
	    /periodcentered\n\
	/cedillar /onesuperior /ordmasculine /guillemotright /onequarter\n\
	    /onehalf /threequarters /questiondown\n\
	/Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla\n\
	/Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex\n\
	    /Idieresis\n\
	/Eth /Ntilde /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply\n\
	/Oslash /Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn\n\
	    /germandbls\n\
	/agrave /aacute /acircumflex /atilde /adieresis /aring /ae /ccedilla\n\
	/egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex\n\
	    /idieresis\n\
	/eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide\n\
	/oslash /ugrave /uacute /ucircumflex /udieresis /yacute /thorn\n\
	    /ydieresis\n\
    ] def\n\
} if\n\
\n\
% font ISOEncode font\n\
% This procedure changes the encoding of a font from the default\n\
% Postscript encoding to ISOLatin1.  It's typically invoked just\n\
% before invoking \"setfont\".  The body of this procedure comes from\n\
% Section 5.6.1 of the Postscript book.\n\
\n\
/ISOEncode {\n\
    dup length dict begin\n\
	{1 index /FID ne {def} {pop pop} ifelse} forall\n\
	/Encoding ISOLatin1Encoding def\n\
	currentdict\n\
    end\n\
\n\
    % I'm not sure why it's necessary to use \"definefont\" on this new\n\
    % font, but it seems to be important; just use the name \"Temporary\"\n\
    % for the font.\n\
\n\
    /Temporary exch definefont\n\
} bind def\n\
\n\
% StrokeClip\n\
%\n\
% This procedure converts the current path into a clip area under\n\
% the assumption of stroking.  It's a bit tricky because some Postscript\n\
% interpreters get errors during strokepath for dashed lines.  If\n\
% this happens then turn off dashes and try again.\n\
\n\
/StrokeClip {\n\
    {strokepath} stopped {\n\
	(This Postscript printer gets limitcheck overflows when) =\n\
	(stippling dashed lines;  lines will be printed solid instead.) =\n\
	[] 0 setdash strokepath} if\n\
    clip\n\
} bind def\n\
\n\
% d",
	/* End of part 2 */

	/* Start of part 3 (2000 characters) */
	"esiredSize EvenPixels closestSize\n\
%\n\
% The procedure below is used for stippling.  Given the optimal size\n\
% of a dot in a stipple pattern in the current user coordinate system,\n\
% compute the closest size that is an exact multiple of the device's\n\
% pixel size.  This allows stipple patterns to be displayed without\n\
% aliasing effects.\n\
\n\
/EvenPixels {\n\
    % Compute exact number of device pixels per stipple dot.\n\
    dup 0 matrix currentmatrix dtransform\n\
    dup mul exch dup mul add sqrt\n\
\n\
    % Round to an integer, make sure the number is at least 1, and compute\n\
    % user coord distance corresponding to this.\n\
    dup round dup 1 lt {pop 1} if\n\
    exch div mul\n\
} bind def\n\
\n\
% width height string StippleFill --\n\
%\n\
% Given a path already set up and a clipping region generated from\n\
% it, this procedure will fill the clipping region with a stipple\n\
% pattern.  \"String\" contains a proper image description of the\n\
% stipple pattern and \"width\" and \"height\" give its dimensions.  Each\n\
% stipple dot is assumed to be about one unit across in the current\n\
% user coordinate system.  This procedure trashes the graphics state.\n\
\n\
/StippleFill {\n\
    % The following code is needed to work around a NeWSprint bug.\n\
\n\
    /tmpstip 1 index def\n\
\n\
    % Change the scaling so that one user unit in user coordinates\n\
    % corresponds to the size of one stipple dot.\n\
    1 EvenPixels dup scale\n\
\n\
    % Compute the bounding box occupied by the path (which is now\n\
    % the clipping region), and round the lower coordinates down\n\
    % to the nearest starting point for the stipple pattern.  Be\n\
    % careful about negative numbers, since the rounding works\n\
    % differently on them.\n\
\n\
    pathbbox\n\
    4 2 roll\n\
    5 index div dup 0 lt {1 sub} if cvi 5 index mul 4 1 roll\n\
    6 index div dup 0 lt {1 sub} if cvi 6 index mul 3 2 roll\n\
\n\
    % Stack now: width height string y1 y2 x1 x2\n\
    % Below is a doubly-nested for loop to iterate across this area\n\
    % in units of the stipple pattern size, going up columns then\n\
    % acr",
	/* End of part 3 */

	/* Start of part 4 (2000 characters) */
	"oss rows, blasting out a stipple-pattern-sized rectangle at\n\
    % each position\n\
\n\
    6 index exch {\n\
	2 index 5 index 3 index {\n\
	    % Stack now: width height string y1 y2 x y\n\
\n\
	    gsave\n\
	    1 index exch translate\n\
	    5 index 5 index true matrix tmpstip imagemask\n\
	    grestore\n\
	} for\n\
	pop\n\
    } for\n\
    pop pop pop pop pop\n\
} bind def\n\
\n\
% -- AdjustColor --\n\
% Given a color value already set for output by the caller, adjusts\n\
% that value to a grayscale or mono value if requested by the CL\n\
% variable.\n\
\n\
/AdjustColor {\n\
    CL 2 lt {\n\
	currentgray\n\
	CL 0 eq {\n\
	    .5 lt {0} {1} ifelse\n\
	} if\n\
	setgray\n\
    } if\n\
} bind def\n\
\n\
% x y strings spacing xoffset yoffset justify stipple DrawText --\n\
% This procedure does all of the real work of drawing text.  The\n\
% color and font must already have been set by the caller, and the\n\
% following arguments must be on the stack:\n\
%\n\
% x, y -	Coordinates at which to draw text.\n\
% strings -	An array of strings, one for each line of the text item,\n\
%		in order from top to bottom.\n\
% spacing -	Spacing between lines.\n\
% xoffset -	Horizontal offset for text bbox relative to x and y: 0 for\n\
%		nw/w/sw anchor, -0.5 for n/center/s, and -1.0 for ne/e/se.\n\
% yoffset -	Vertical offset for text bbox relative to x and y: 0 for\n\
%		nw/n/ne anchor, +0.5 for w/center/e, and +1.0 for sw/s/se.\n\
% justify -	0 for left justification, 0.5 for center, 1 for right justify.\n\
% stipple -	Boolean value indicating whether or not text is to be\n\
%		drawn in stippled fashion.  If text is stippled,\n\
%		procedure StippleText must have been defined to call\n\
%		StippleFill in the right way.\n\
%\n\
% Also, when this procedure is invoked, the color and font must already\n\
% have been set for the text.\n\
\n\
/DrawText {\n\
    /stipple exch def\n\
    /justify exch def\n\
    /yoffset exch def\n\
    /xoffset exch def\n\
    /spacing exch def\n\
    /strings exch def\n\
\n\
    % First scan through all of the text to find the widest line.\n\
\n\
    /lineLength 0 def\n\
    strings {\n\
	stringwidth pop\n\
	dup lineLength gt {/lineLength exch def}",
	/* End of part 4 */

	/* Start of part 5 (1546 characters) */
	" {pop} ifelse\n\
	newpath\n\
    } forall\n\
\n\
    % Compute the baseline offset and the actual font height.\n\
\n\
    0 0 moveto (TXygqPZ) false charpath\n\
    pathbbox dup /baseline exch def\n\
    exch pop exch sub /height exch def pop\n\
    newpath\n\
\n\
    % Translate coordinates first so that the origin is at the upper-left\n\
    % corner of the text's bounding box. Remember that x and y for\n\
    % positioning are still on the stack.\n\
\n\
    translate\n\
    lineLength xoffset mul\n\
    strings length 1 sub spacing mul height add yoffset mul translate\n\
\n\
    % Now use the baseline and justification information to translate so\n\
    % that the origin is at the baseline and positioning point for the\n\
    % first line of text.\n\
\n\
    justify lineLength mul baseline neg translate\n\
\n\
    % Iterate over each of the lines to output it.  For each line,\n\
    % compute its width again so it can be properly justified, then\n\
    % display it.\n\
\n\
    strings {\n\
	dup stringwidth pop\n\
	justify neg mul 0 moveto\n\
	stipple {\n\
\n\
	    % The text is stippled, so turn it into a path and print\n\
	    % by calling StippledText, which in turn calls StippleFill.\n\
	    % Unfortunately, many Postscript interpreters will get\n\
	    % overflow errors if we try to do the whole string at\n\
	    % once, so do it a character at a time.\n\
\n\
	    gsave\n\
	    /char (X) def\n\
	    {\n\
		char 0 3 -1 roll put\n\
		currentpoint\n\
		gsave\n\
		char true charpath clip StippleText\n\
		grestore\n\
		char stringwidth translate\n\
		moveto\n\
	    } forall\n\
	    grestore\n\
	} {show} ifelse\n\
	0 spacing neg translate\n\
    } forall\n\
} bind def\n\
\n\
%%EndProlog\n\
",
	/* End of part 5 */

	NULL	/* End of data marker */
};

/*
d163 1
a163 1
    char **argv;			/* Argument strings.  Caller has
d173 2
a174 1
    char string[STRING_LENGTH+1], *p;
d188 1
a188 1
    CONST char * CONST *chunk;
d196 4
a199 1

d424 2
a425 2
    Tcl_AppendResult(interp, "%!PS-Adobe-3.0 EPSF-3.0\n",
	    "%%Creator: Tk Canvas Widget\n", (char *) NULL);
d475 2
a476 3
    for (chunk=prolog; *chunk; chunk++) {
	Tcl_AppendResult(interp, *chunk, (char *) NULL);
    }
d479 1
a479 1
	Tcl_Write(psInfo.chan, Tcl_GetStringResult(interp), -1);
d673 1
a673 1
	char *cmdString;
d753 1
a753 1
	char *list, **argv;
d756 2
a757 1
	char *name;
d1116 6
d1131 9
d1147 11
d1162 1
a1162 1
	*red = cdata->colors[r].red / 65535.0;
d1164 1
a1164 1
	*blue = cdata->colors[b].blue / 65535.0;
d1166 1
a1166 1
	*red = cdata->colors[pixel].red / 65535.0;
d1168 1
a1168 1
	*blue = cdata->colors[pixel].blue / 65535.0;
d1171 1
a1262 1

d1285 1
a1285 2
    switch (level)
    {
d1366 1
a1366 3
							    (0.30 * red +
							     0.59 * green +
							     0.11 * blue)));
d1381 1
a1381 1
			for (xx = x; xx < x+width; xx++) {
a1872 1

@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
 * Copyright (c) 1994-1996 Sun Microsystems, Inc.
d14 1
a14 1
 * RCS: @@(#) $Id: tkCanvPs.c,v 1.11 1999/01/26 04:11:20 jingham Exp $
d71 2
d104 2
d122 1
d131 1
a131 1
% RCS: @@(#) $Id: tkCanvPs.c,v 1.11 1999/01/26 04:11:20 jingham Exp $\n\
d468 2
a469 1
    TkPostscriptInfo psInfo, *oldInfoPtr;
d476 1
d496 2
a497 2
    oldInfoPtr = canvasPtr->psInfoPtr;
    canvasPtr->psInfoPtr = &psInfo;
d519 1
d521 1
a521 1
    result = Tk_ConfigureWidget(canvasPtr->interp, canvasPtr->tkwin,
d529 1
a529 1
	psInfo.width = Tk_Width(canvasPtr->tkwin);
d532 1
a532 1
	psInfo.height = Tk_Height(canvasPtr->tkwin);
d538 1
a538 1
	if (GetPostscriptPoints(canvasPtr->interp, psInfo.pageXString,
d544 1
a544 1
	if (GetPostscriptPoints(canvasPtr->interp, psInfo.pageYString,
d550 1
a550 1
	if (GetPostscriptPoints(canvasPtr->interp, psInfo.pageWidthString,
d556 1
a556 1
	if (GetPostscriptPoints(canvasPtr->interp, psInfo.pageHeightString,
d562 2
a563 2
	psInfo.scale = (72.0/25.4)*WidthMMOfScreen(Tk_Screen(canvasPtr->tkwin));
	psInfo.scale /= WidthOfScreen(Tk_Screen(canvasPtr->tkwin));
d611 1
a611 1
	    Tcl_AppendResult(canvasPtr->interp, "bad color mode \"",
d625 1
a625 1
            Tcl_AppendResult(canvasPtr->interp, "can't specify both -file",
d636 2
a637 2
        if (Tcl_IsSafe(canvasPtr->interp)) {
            Tcl_AppendResult(canvasPtr->interp, "can't specify -file in a",
d643 1
a643 1
	p = Tcl_TranslateFileName(canvasPtr->interp, psInfo.fileName, &buffer);
d647 1
a647 1
	psInfo.chan = Tcl_OpenFileChannel(canvasPtr->interp, p, "w", 0666);
d662 1
a662 1
        psInfo.chan = Tcl_GetChannel(canvasPtr->interp, psInfo.channelName,
d669 1
a669 1
            Tcl_AppendResult(canvasPtr->interp, "channel \"",
d697 1
a697 1
	result = (*itemPtr->typePtr->postscriptProc)(canvasPtr->interp,
d699 1
a699 1
	Tcl_ResetResult(canvasPtr->interp);
d719 2
a720 1
    Tcl_AppendResult(canvasPtr->interp, "%!PS-Adobe-3.0 EPSF-3.0\n",
d722 1
a722 1
#if !(defined(__WIN32__) || defined(MAC_TCL))
d724 2
a725 2
	struct passwd *pwPtr = getpwuid(getuid());
	Tcl_AppendResult(canvasPtr->interp, "%%For: ",
d730 3
a732 3
#endif /* __WIN32__ || MAC_TCL */
    Tcl_AppendResult(canvasPtr->interp, "%%Title: Window ",
	    Tk_PathName(canvasPtr->tkwin), "\n", (char *) NULL);
d734 2
a735 2
    Tcl_AppendResult(canvasPtr->interp, "%%CreationDate: ",
	    ctime(&now), (char *) NULL);
d752 1
a752 1
    Tcl_AppendResult(canvasPtr->interp, "%%BoundingBox: ", string,
d754 1
a754 1
    Tcl_AppendResult(canvasPtr->interp, "%%Pages: 1\n", 
d756 1
a756 1
    Tcl_AppendResult(canvasPtr->interp, "%%Orientation: ",
d761 1
a761 1
	Tcl_AppendResult(canvasPtr->interp, p,
d766 1
a766 1
    Tcl_AppendResult(canvasPtr->interp, "%%EndComments\n\n", (char *) NULL);
d776 1
a776 1
	Tcl_Write(psInfo.chan, canvasPtr->interp->result, -1);
d787 1
a787 1
    Tcl_AppendResult(canvasPtr->interp, "%%BeginSetup\n", string,
d791 1
a791 1
	Tcl_AppendResult(canvasPtr->interp, "%%IncludeResource: font ",
d794 1
a794 1
    Tcl_AppendResult(canvasPtr->interp, "%%EndSetup\n\n", (char *) NULL);
d804 1
a804 1
    Tcl_AppendResult(canvasPtr->interp, "%%Page: 1 1\n", "save\n",
d807 1
a807 1
    Tcl_AppendResult(canvasPtr->interp, string, (char *) NULL);
d809 1
a809 1
	Tcl_AppendResult(canvasPtr->interp, "90 rotate\n", (char *) NULL);
d812 1
a812 1
    Tcl_AppendResult(canvasPtr->interp, string, (char *) NULL);
d814 1
a814 1
    Tcl_AppendResult(canvasPtr->interp, string, (char *) NULL);
d816 9
a824 5
	    psInfo.x, Tk_CanvasPsY((Tk_Canvas) canvasPtr, (double) psInfo.y),
	    psInfo.x2, Tk_CanvasPsY((Tk_Canvas) canvasPtr, (double) psInfo.y),
	    psInfo.x2, Tk_CanvasPsY((Tk_Canvas) canvasPtr, (double) psInfo.y2),
	    psInfo.x, Tk_CanvasPsY((Tk_Canvas) canvasPtr, (double) psInfo.y2));
    Tcl_AppendResult(canvasPtr->interp, string,
d826 1
d828 1
a828 1
	Tcl_Write(psInfo.chan, canvasPtr->interp->result, -1);
d849 5
a853 2
	Tcl_AppendResult(canvasPtr->interp, "gsave\n", (char *) NULL);
	result = (*itemPtr->typePtr->postscriptProc)(canvasPtr->interp,
d856 1
a856 1
	    char msg[100];
d860 1
a860 1
	    Tcl_AddErrorInfo(canvasPtr->interp, msg);
d863 1
a863 1
	Tcl_AppendResult(canvasPtr->interp, "grestore\n", (char *) NULL);
d865 2
a866 2
	    Tcl_Write(psInfo.chan, canvasPtr->interp->result, -1);
	    Tcl_ResetResult(canvasPtr->interp);
d877 2
a878 1
    Tcl_AppendResult(canvasPtr->interp, "restore showpage\n\n",
d880 1
d882 1
a882 1
	Tcl_Write(psInfo.chan, canvasPtr->interp->result, -1);
d916 1
a916 1
	Tcl_Close(canvasPtr->interp, psInfo.chan);
d922 1
a922 1
    canvasPtr->psInfoPtr = oldInfoPtr;
d929 1
a929 1
 * Tk_CanvasPsColor --
d938 1
a938 1
 *	then an error message will be left in interp->result.
d940 1
a940 1
 *	appended to interp->result.
d949 3
a951 4
Tk_CanvasPsColor(interp, canvas, colorPtr)
    Tcl_Interp *interp;			/* Interpreter for returning Postscript
					 * or error message. */
    Tk_Canvas canvas;			/* Information about canvas. */
d954 1
a954 2
    TkCanvas *canvasPtr = (TkCanvas *) canvas;
    TkPostscriptInfo *psInfoPtr = canvasPtr->psInfoPtr;
d1008 1
a1008 1
 * Tk_CanvasPsFont --
d1017 1
a1017 1
 *	then an error message will be left in interp->result.
d1019 1
a1019 1
 *	appended to the interp->result.
d1029 3
a1031 4
Tk_CanvasPsFont(interp, canvas, tkfont)
    Tcl_Interp *interp;			/* Interpreter for returning Postscript
					 * or error message. */
    Tk_Canvas canvas;			/* Information about canvas. */
d1035 1
a1035 2
    TkCanvas *canvasPtr = (TkCanvas *) canvas;
    TkPostscriptInfo *psInfoPtr = canvasPtr->psInfoPtr;
d1037 1
a1037 1
    char pointString[20];
d1100 1
a1100 1
 * Tk_CanvasPsBitmap --
d1109 1
a1109 1
 *	then an error message will be left in interp->result.
d1111 1
a1111 1
 *	appended to interp->result.
d1120 5
a1124 4
Tk_CanvasPsBitmap(interp, canvas, bitmap, startX, startY, width, height)
    Tcl_Interp *interp;			/* Interpreter for returning Postscript
					 * or error message. */
    Tk_Canvas canvas;			/* Information about canvas. */
d1131 1
a1131 2
    TkCanvas *canvasPtr = (TkCanvas *) canvas;
    TkPostscriptInfo *psInfoPtr = canvasPtr->psInfoPtr;
d1152 1
a1152 1
    XGetGeometry(Tk_Display(Tk_CanvasTkwin(canvas)), bitmap, &dummyRoot,
d1155 1
a1155 1
    imagePtr = XGetImage(Tk_Display(canvasPtr->tkwin), bitmap, 0, 0,
d1197 1
a1197 1
 * Tk_CanvasPsStipple --
d1208 1
a1208 1
 *	then an error message will be left in interp->result.
d1210 1
a1210 1
 *	appended to interp->result.
d1219 4
a1222 2
Tk_CanvasPsStipple(interp, canvas, bitmap)
    Tcl_Interp *interp;			/* Interpreter for returning Postscript
a1223 1
    Tk_Canvas canvas;			/* Information about canvas. */
d1226 1
a1226 2
    TkCanvas *canvasPtr = (TkCanvas *) canvas;
    TkPostscriptInfo *psInfoPtr = canvasPtr->psInfoPtr;
d1228 1
a1228 1
    char string[100];
d1245 1
a1245 1
    XGetGeometry(Tk_Display(Tk_CanvasTkwin(canvas)), bitmap, &dummyRoot,
d1250 1
a1250 1
    if (Tk_CanvasPsBitmap(interp, (Tk_Canvas) canvasPtr, bitmap, 0, 0,
d1261 1
a1261 1
 * Tk_CanvasPsY --
d1263 1
a1263 1
 *	Given a y-coordinate in canvas coordinates, this procedure
d1277 1
a1277 3
Tk_CanvasPsY(canvas, y)
    Tk_Canvas canvas;			/* Token for canvas on whose behalf
					 * Postscript is being generated. */
d1279 1
d1281 1
a1281 1
    TkPostscriptInfo *psInfoPtr = ((TkCanvas *) canvas)->psInfoPtr;
d1289 1
a1289 1
 * Tk_CanvasPsPath --
d1295 1
a1295 1
 *	Postscript commands get appended to what's in interp->result.
d1304 3
a1306 4
Tk_CanvasPsPath(interp, canvas, coordPtr, numPoints)
    Tcl_Interp *interp;			/* Put generated Postscript in this
					 * interpreter's result field. */
    Tk_Canvas canvas;			/* Canvas on whose behalf Postscript
d1313 1
a1313 1
    TkPostscriptInfo *psInfoPtr = ((TkCanvas *) canvas)->psInfoPtr;
d1320 1
a1320 1
	    Tk_CanvasPsY(canvas, coordPtr[1]));
d1325 1
a1325 1
		Tk_CanvasPsY(canvas, coordPtr[1]));
d1343 1
a1343 1
 *	interp->result.
d1400 747
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d9 1
a9 1
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
d14 1
a14 1
 * RCS: @@(#) $Id: tkCanvPs.c,v 1.7.6.2 2000/09/26 16:07:51 spolk Exp $
a70 2
    int prolog;			/* Non-zero means output should contain
				   the file prolog.ps in the header. */
a101 2
    {TK_CONFIG_BOOLEAN, "-prolog", (char *) NULL, (char *) NULL,
	"", Tk_Offset(TkPostscriptInfo, prolog), 0},
a117 1
 * (str2c is a small tcl script in tcl's tool directory (source release))
d126 1
a126 1
% RCS: @@(#) $Id: tkCanvPs.c,v 1.7.6.2 2000/09/26 16:07:51 spolk Exp $\n\
d463 1
a463 2
    TkPostscriptInfo psInfo;
    Tk_PostscriptInfo oldInfoPtr;
a469 1
    Tk_Window tkwin = canvasPtr->tkwin;
d489 2
a490 2
    oldInfoPtr = canvasPtr->psInfo;
    canvasPtr->psInfo = (Tk_PostscriptInfo) &psInfo;
a511 1
    psInfo.prolog = 1;
d513 1
a513 1
    result = Tk_ConfigureWidget(interp, tkwin,
d521 1
a521 1
	psInfo.width = Tk_Width(tkwin);
d524 1
a524 1
	psInfo.height = Tk_Height(tkwin);
d530 1
a530 1
	if (GetPostscriptPoints(interp, psInfo.pageXString,
d536 1
a536 1
	if (GetPostscriptPoints(interp, psInfo.pageYString,
d542 1
a542 1
	if (GetPostscriptPoints(interp, psInfo.pageWidthString,
d548 1
a548 1
	if (GetPostscriptPoints(interp, psInfo.pageHeightString,
d554 2
a555 2
	psInfo.scale = (72.0/25.4)*WidthMMOfScreen(Tk_Screen(tkwin));
	psInfo.scale /= WidthOfScreen(Tk_Screen(tkwin));
d603 1
a603 1
	    Tcl_AppendResult(interp, "bad color mode \"",
d617 1
a617 1
            Tcl_AppendResult(interp, "can't specify both -file",
d628 2
a629 2
        if (Tcl_IsSafe(interp)) {
            Tcl_AppendResult(interp, "can't specify -file in a",
d635 1
a635 1
	p = Tcl_TranslateFileName(interp, psInfo.fileName, &buffer);
d639 1
a639 1
	psInfo.chan = Tcl_OpenFileChannel(interp, p, "w", 0666);
d654 1
a654 1
        psInfo.chan = Tcl_GetChannel(interp, psInfo.channelName,
d661 1
a661 1
            Tcl_AppendResult(interp, "channel \"",
d689 1
a689 1
	result = (*itemPtr->typePtr->postscriptProc)(interp,
d691 1
a691 1
	Tcl_ResetResult(interp);
d711 1
a711 2
    if (psInfo.prolog) {
    Tcl_AppendResult(interp, "%!PS-Adobe-3.0 EPSF-3.0\n",
d713 1
a713 1
#ifdef HAVE_PW_GECOS
d715 2
a716 2
	struct passwd *pwPtr = getpwuid(getuid());	/* INTL: Native. */
	Tcl_AppendResult(interp, "%%For: ",
d721 3
a723 3
#endif /* HAVE_PW_GECOS */
    Tcl_AppendResult(interp, "%%Title: Window ",
	    Tk_PathName(tkwin), "\n", (char *) NULL);
d725 2
a726 2
    Tcl_AppendResult(interp, "%%CreationDate: ",
	    ctime(&now), (char *) NULL);		/* INTL: Native. */
d743 1
a743 1
    Tcl_AppendResult(interp, "%%BoundingBox: ", string,
d745 1
a745 1
    Tcl_AppendResult(interp, "%%Pages: 1\n", 
d747 1
a747 1
    Tcl_AppendResult(interp, "%%Orientation: ",
d752 1
a752 1
	Tcl_AppendResult(interp, p,
d757 1
a757 1
    Tcl_AppendResult(interp, "%%EndComments\n\n", (char *) NULL);
d767 1
a767 1
	Tcl_Write(psInfo.chan, Tcl_GetStringResult(interp), -1);
d778 1
a778 1
    Tcl_AppendResult(interp, "%%BeginSetup\n", string,
d782 1
a782 1
	Tcl_AppendResult(interp, "%%IncludeResource: font ",
d785 1
a785 1
    Tcl_AppendResult(interp, "%%EndSetup\n\n", (char *) NULL);
d795 1
a795 1
    Tcl_AppendResult(interp, "%%Page: 1 1\n", "save\n",
d798 1
a798 1
    Tcl_AppendResult(interp, string, (char *) NULL);
d800 1
a800 1
	Tcl_AppendResult(interp, "90 rotate\n", (char *) NULL);
d803 1
a803 1
    Tcl_AppendResult(interp, string, (char *) NULL);
d805 1
a805 1
    Tcl_AppendResult(interp, string, (char *) NULL);
d807 5
a811 9
	    psInfo.x,
	    Tk_PostscriptY((double) psInfo.y, (Tk_PostscriptInfo) &psInfo),
	    psInfo.x2,
	    Tk_PostscriptY((double) psInfo.y, (Tk_PostscriptInfo) &psInfo),
	    psInfo.x2, 
	    Tk_PostscriptY((double) psInfo.y2, (Tk_PostscriptInfo) &psInfo),
	    psInfo.x,
	    Tk_PostscriptY((double) psInfo.y2, (Tk_PostscriptInfo) &psInfo));
    Tcl_AppendResult(interp, string,
a812 1
    }
d814 1
a814 1
	Tcl_Write(psInfo.chan, Tcl_GetStringResult(interp), -1);
d835 2
a836 5
	if (itemPtr->state == TK_STATE_HIDDEN) {
	    continue;
	}
	Tcl_AppendResult(interp, "gsave\n", (char *) NULL);
	result = (*itemPtr->typePtr->postscriptProc)(interp,
d839 1
a839 1
	    char msg[64 + TCL_INTEGER_SPACE];
d843 1
a843 1
	    Tcl_AddErrorInfo(interp, msg);
d846 1
a846 1
	Tcl_AppendResult(interp, "grestore\n", (char *) NULL);
d848 2
a849 2
	    Tcl_Write(psInfo.chan, Tcl_GetStringResult(interp), -1);
	    Tcl_ResetResult(interp);
d860 1
a860 2
    if (psInfo.prolog) {
      Tcl_AppendResult(interp, "restore showpage\n\n",
a861 1
    }
d863 1
a863 1
	Tcl_Write(psInfo.chan, Tcl_GetStringResult(interp), -1);
d897 1
a897 1
	Tcl_Close(interp, psInfo.chan);
d903 1
a903 1
    canvasPtr->psInfo = (Tk_PostscriptInfo) oldInfoPtr;
d910 1
a910 1
 * Tk_PostscriptColor --
d919 1
a919 1
 *	then an error message will be left in the interp's result.
d921 1
a921 1
 *	appended to the interp's result.
d930 4
a933 3
Tk_PostscriptColor(interp, psInfo, colorPtr)
    Tcl_Interp *interp;
    Tk_PostscriptInfo psInfo;		/* Postscript info. */
d936 2
a937 1
    TkPostscriptInfo *psInfoPtr = (TkPostscriptInfo *) psInfo;
d991 1
a991 1
 * Tk_PostscriptFont --
d1000 1
a1000 1
 *	then an error message will be left in the interp's result.
d1002 1
a1002 1
 *	appended to the interp's result.
d1012 4
a1015 3
Tk_PostscriptFont(interp, psInfo, tkfont)
    Tcl_Interp *interp;
    Tk_PostscriptInfo psInfo;		/* Postscript Info. */
d1019 2
a1020 1
    TkPostscriptInfo *psInfoPtr = (TkPostscriptInfo *) psInfo;
d1022 1
a1022 1
    char pointString[TCL_INTEGER_SPACE];
d1085 1
a1085 1
 * Tk_PostscriptBitmap --
d1094 1
a1094 1
 *	then an error message will be left in the interp's result.
d1096 1
a1096 1
 *	appended to the interp's result.
d1105 4
a1108 5
Tk_PostscriptBitmap(interp, tkwin, psInfo, bitmap, startX, startY, width,
	height)
    Tcl_Interp *interp;
    Tk_Window tkwin;
    Tk_PostscriptInfo psInfo;		/* Postscript info. */
d1115 2
a1116 1
    TkPostscriptInfo *psInfoPtr = (TkPostscriptInfo *) psInfo;
d1137 1
a1137 1
    XGetGeometry(Tk_Display(tkwin), bitmap, &dummyRoot,
d1140 1
a1140 1
    imagePtr = XGetImage(Tk_Display(tkwin), bitmap, 0, 0,
d1182 1
a1182 1
 * Tk_PostscriptStipple --
d1193 1
a1193 1
 *	then an error message will be left in the interp's result.
d1195 1
a1195 1
 *	appended to the interp's result.
d1204 2
a1205 4
Tk_PostscriptStipple(interp, tkwin, psInfo, bitmap)
    Tcl_Interp *interp;
    Tk_Window tkwin;
    Tk_PostscriptInfo psInfo;		/* Interpreter for returning Postscript
d1207 1
d1210 2
a1211 1
    TkPostscriptInfo *psInfoPtr = (TkPostscriptInfo *) psInfo;
d1213 1
a1213 1
    char string[TCL_INTEGER_SPACE * 2];
d1230 1
a1230 1
    XGetGeometry(Tk_Display(tkwin), bitmap, &dummyRoot,
d1235 1
a1235 1
    if (Tk_PostscriptBitmap(interp, tkwin, psInfo, bitmap, 0, 0,
d1246 1
a1246 1
 * Tk_PostscriptY --
d1248 1
a1248 1
 *	Given a y-coordinate in local coordinates, this procedure
d1262 3
a1264 1
Tk_PostscriptY(y, psInfo)
a1265 1
    Tk_PostscriptInfo psInfo;		/* Postscript info */
d1267 1
a1267 1
    TkPostscriptInfo *psInfoPtr = (TkPostscriptInfo *) psInfo;
d1275 1
a1275 1
 * Tk_PostscriptPath --
d1281 1
a1281 1
 *	Postscript commands get appended to what's in the interp's result.
d1290 4
a1293 3
Tk_PostscriptPath(interp, psInfo, coordPtr, numPoints)
    Tcl_Interp *interp;
    Tk_PostscriptInfo psInfo;		/* Canvas on whose behalf Postscript
d1300 1
a1300 1
    TkPostscriptInfo *psInfoPtr = (TkPostscriptInfo *) psInfo;
d1307 1
a1307 1
	    Tk_PostscriptY(coordPtr[1], psInfo));
d1312 1
a1312 1
		Tk_PostscriptY(coordPtr[1], psInfo));
d1330 1
a1330 1
 *	the interp's result.
a1386 747

/*
 *--------------------------------------------------------------
 *
 * TkImageGetColor --
 *
 *	This procedure converts a pixel value to three floating
 *      point numbers, representing the amount of red, green, and 
 *      blue in that pixel on the screen.  It makes use of colormap
 *      data passed as an argument, and should work for all Visual
 *      types.
 *
 * Results:
 *	Returns red, green, and blue color values in the range 
 *      0 to 1.  There are no error returns.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

static void
TkImageGetColor(cdata, pixel, red, green, blue)
    TkColormapData *cdata;              /* Colormap data */
    unsigned long pixel;                /* Pixel value to look up */
    double *red, *green, *blue;         /* Color data to return */
{
    if (cdata->separated) {
	int r = (pixel & cdata->red_mask) >> cdata->red_shift;
	int g = (pixel & cdata->green_mask) >> cdata->green_shift;
	int b = (pixel & cdata->blue_mask) >> cdata->blue_shift;
	*red = cdata->colors[r].red / 65535.0;
	*green = cdata->colors[g].green / 65535.0;
	*blue = cdata->colors[b].blue / 65535.0;
    } else {
	*red = cdata->colors[pixel].red / 65535.0;
	*green = cdata->colors[pixel].green / 65535.0;
	*blue = cdata->colors[pixel].blue / 65535.0;
    }
}

/*
 *--------------------------------------------------------------
 *
 * TkPostscriptImage --
 *
 *	This procedure is called to output the contents of an
 *	image in Postscript, using a format appropriate for the 
 *      current color mode (i.e. one bit per pixel in monochrome, 
 *      one byte per pixel in gray, and three bytes per pixel in
 *      color).
 *
 * Results:
 *	Returns a standard Tcl return value.  If an error occurs
 *	then an error message will be left in interp->result.
 *	If no error occurs, then additional Postscript will be
 *	appended to interp->result.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

int
TkPostscriptImage(interp, tkwin, psInfo, ximage, x, y, width, height)
    Tcl_Interp *interp;
    Tk_Window tkwin;
    Tk_PostscriptInfo psInfo;	/* postscript info */
    XImage *ximage;		/* Image to draw */
    int x, y;			/* First pixel to output */
    int width, height;		/* Width and height of area */
{
    TkPostscriptInfo *psInfoPtr = (TkPostscriptInfo *) psInfo;
    char buffer[256];
    int xx, yy, band, maxRows;
    double red, green, blue;
    int bytesPerLine=0, maxWidth=0;
    int level = psInfoPtr->colorLevel;
    Colormap cmap;
    int i, depth, ncolors;
    Visual *visual;
    TkColormapData cdata;

    if (psInfoPtr->prepass) {
	return TCL_OK;
    }

    cmap = Tk_Colormap(tkwin);
    depth = Tk_Depth(tkwin);
    visual = Tk_Visual(tkwin);

    /*
     * Obtain information about the colormap, ie the mapping between
     * pixel values and RGB values.  The code below should work
     * for all Visual types.
     */

    ncolors = visual->map_entries;
    cdata.colors = (XColor *) ckalloc(sizeof(XColor) * ncolors);
    cdata.ncolors = ncolors;

    if (visual->class == DirectColor || visual->class == TrueColor) {
	cdata.separated = 1;
	cdata.red_mask = visual->red_mask;
	cdata.green_mask = visual->green_mask;
	cdata.blue_mask = visual->blue_mask;
	cdata.red_shift = 0;
	cdata.green_shift = 0;
	cdata.blue_shift = 0;
	while ((0x0001 & (cdata.red_mask >> cdata.red_shift)) == 0)
	    cdata.red_shift ++;
	while ((0x0001 & (cdata.green_mask >> cdata.green_shift)) == 0)
	    cdata.green_shift ++;
	while ((0x0001 & (cdata.blue_mask >> cdata.blue_shift)) == 0)
	    cdata.blue_shift ++;
	for (i = 0; i < ncolors; i ++)
	    cdata.colors[i].pixel =
		((i << cdata.red_shift) & cdata.red_mask) |
		((i << cdata.green_shift) & cdata.green_mask) |
		((i << cdata.blue_shift) & cdata.blue_mask);
    } else {
	cdata.separated=0;
	for (i = 0; i < ncolors; i ++)
	    cdata.colors[i].pixel = i;
    }
    if (visual->class == StaticGray || visual->class == GrayScale)
	cdata.color = 0;
    else
	cdata.color = 1;


    XQueryColors(Tk_Display(tkwin), cmap, cdata.colors, ncolors);

    /*
     * Figure out which color level to use (possibly lower than the 
     * one specified by the user).  For example, if the user specifies
     * color with monochrome screen, use gray or monochrome mode instead. 
     */

    if (!cdata.color && level == 2) {
	level = 1;
    }

    if (!cdata.color && cdata.ncolors == 2) {
	level = 0;
    }

    /*
     * Check that at least one row of the image can be represented
     * with a string less than 64 KB long (this is a limit in the 
     * Postscript interpreter).
     */

    switch (level)
    {
	case 0: bytesPerLine = (width + 7) / 8;  maxWidth = 240000;  break;
	case 1: bytesPerLine = width;  maxWidth = 60000;  break;
	case 2: bytesPerLine = 3 * width;  maxWidth = 20000;  break;
    }

    if (bytesPerLine > 60000) {
	Tcl_ResetResult(interp);
	sprintf(buffer,
		"Can't generate Postscript for images more than %d pixels wide",
		maxWidth);
	Tcl_AppendResult(interp, buffer, (char *) NULL);
	ckfree((char *) cdata.colors);
	return TCL_ERROR;
    }

    maxRows = 60000 / bytesPerLine;

    for (band = height-1; band >= 0; band -= maxRows) {
	int rows = (band >= maxRows) ? maxRows : band + 1;
	int lineLen = 0;
	switch (level) {
	    case 0:
		sprintf(buffer, "%d %d 1 matrix {\n<", width, rows);
		Tcl_AppendResult(interp, buffer, (char *) NULL);
		break;
	    case 1:
		sprintf(buffer, "%d %d 8 matrix {\n<", width, rows);
		Tcl_AppendResult(interp, buffer, (char *) NULL);
		break;
	    case 2:
		sprintf(buffer, "%d %d 8 matrix {\n<",
			width, rows);
		Tcl_AppendResult(interp, buffer, (char *) NULL);
		break;
	}
	for (yy = band; yy > band - rows; yy--) {
	    switch (level) {
		case 0: {
		    /*
		     * Generate data for image in monochrome mode.
		     * No attempt at dithering is made--instead, just
		     * set a threshold.
		     */
		    unsigned char mask=0x80;
		    unsigned char data=0x00;
		    for (xx = x; xx< x+width; xx++) {
			TkImageGetColor(&cdata, XGetPixel(ximage, xx, yy),
					&red, &green, &blue);
			if (0.30 * red + 0.59 * green + 0.11 * blue > 0.5)
			    data |= mask;
			mask >>= 1;
			if (mask == 0) {
			    sprintf(buffer, "%02X", data);
			    Tcl_AppendResult(interp, buffer, (char *) NULL);
			    lineLen += 2;
			    if (lineLen > 60) {
			        lineLen = 0;
			        Tcl_AppendResult(interp, "\n", (char *) NULL);
			    }
			    mask=0x80;
			    data=0x00;
			}
		    }
		    if ((width % 8) != 0) {
		        sprintf(buffer, "%02X", data);
		        Tcl_AppendResult(interp, buffer, (char *) NULL);
		        mask=0x80;
		        data=0x00;
		    }
		    break;
		}
		case 1: {
		    /*
		     * Generate data in gray mode--in this case, take a 
		     * weighted sum of the red, green, and blue values.
		     */
		    for (xx = x; xx < x+width; xx ++) {
			TkImageGetColor(&cdata, XGetPixel(ximage, xx, yy),
					&red, &green, &blue);
			sprintf(buffer, "%02X", (int) floor(0.5 + 255.0 *
							    (0.30 * red +
							     0.59 * green +
							     0.11 * blue)));
			Tcl_AppendResult(interp, buffer, (char *) NULL);
			lineLen += 2;
			if (lineLen > 60) {
			    lineLen = 0;
			    Tcl_AppendResult(interp, "\n", (char *) NULL);
			}
		    }
		    break;
		}
		case 2: {
		    /*
		     * Finally, color mode.  Here, just output the red, green,
		     * and blue values directly.
		     */
			for (xx = x; xx < x+width; xx++) {
			TkImageGetColor(&cdata, XGetPixel(ximage, xx, yy),
				&red, &green, &blue);
			sprintf(buffer, "%02X%02X%02X",
				(int) floor(0.5 + 255.0 * red),
				(int) floor(0.5 + 255.0 * green),
				(int) floor(0.5 + 255.0 * blue));
			Tcl_AppendResult(interp, buffer, (char *) NULL);
			lineLen += 6;
			if (lineLen > 60) {
			    lineLen = 0;
			    Tcl_AppendResult(interp, "\n", (char *) NULL);
			}
		    }
		    break;
		}
	    }
	}
	switch (level) {
	    case 0: sprintf(buffer, ">\n} image\n"); break;
	    case 1: sprintf(buffer, ">\n} image\n"); break;
	    case 2: sprintf(buffer, ">\n} false 3 colorimage\n"); break;
	}
	Tcl_AppendResult(interp, buffer, (char *) NULL);
	sprintf(buffer, "0 %d translate\n", rows);
	Tcl_AppendResult(interp, buffer, (char *) NULL);
    }
    ckfree((char *) cdata.colors);
    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * Tk_PostscriptPhoto --
 *
 *	This procedure is called to output the contents of a
 *	photo image in Postscript, using a format appropriate for
 *	the requested postscript color mode (i.e. one byte per pixel
 *	in gray, and three bytes per pixel in color).
 *
 * Results:
 *	Returns a standard Tcl return value.  If an error occurs
 *	then an error message will be left in interp->result.
 *	If no error occurs, then additional Postscript will be
 *	appended to the interpreter's result.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */
int
Tk_PostscriptPhoto(interp, blockPtr, psInfo, width, height)
    Tcl_Interp *interp;
    Tk_PhotoImageBlock *blockPtr;
    Tk_PostscriptInfo psInfo;
    int width, height;
{
    TkPostscriptInfo *psInfoPtr = (TkPostscriptInfo *) psInfo;
    int colorLevel = psInfoPtr->colorLevel;
    static int codeIncluded = 0;

    unsigned char *pixelPtr;
    char buffer[256], cspace[40], decode[40];
    int bpc;
    int xx, yy, lineLen;
    float red, green, blue;
    int alpha;
    int bytesPerLine=0, maxWidth=0;

    unsigned char opaque = 255;
    unsigned char *alphaPtr;
    int alphaOffset, alphaPitch, alphaIncr;

    if (psInfoPtr->prepass) {
	codeIncluded = 0;
	return TCL_OK;
    }

    /*
     * Define the "TkPhoto" function, which is a modified version
     * of the original "transparentimage" function posted
     * by ian@@five-d.com (Ian Kemmish) to comp.lang.postscript.
     * For a monochrome colorLevel this is a slightly different
     * version that uses the imagemask command instead of image.
     */

    if( !codeIncluded && (colorLevel != 0) ) {
	/*
	 * Color and gray-scale code.
	 */

	codeIncluded = !0;
	Tcl_AppendResult( interp,
		"/TkPhoto { \n",
		"  gsave \n",
		"  32 dict begin \n",
		"  /tinteger exch def \n",
		"  /transparent 1 string def \n",
		"  transparent 0 tinteger put \n",
		"  /olddict exch def \n",
		"  olddict /DataSource get dup type /filetype ne { \n",
		"    olddict /DataSource 3 -1 roll \n",
		"    0 () /SubFileDecode filter put \n",
		"  } { \n",
		"    pop \n",
		"  } ifelse \n",
		"  /newdict olddict maxlength dict def \n",
		"  olddict newdict copy pop \n",
		"  /w newdict /Width get def \n",
		"  /crpp newdict /Decode get length 2 idiv def \n",
		"  /str w string def \n",
		"  /pix w crpp mul string def \n",
		"  /substrlen 2 w log 2 log div floor exp cvi def \n",
		"  /substrs [ \n",
		"  { \n",
		"     substrlen string \n",
		"     0 1 substrlen 1 sub { \n",
		"       1 index exch tinteger put \n",
		"     } for \n",
		"     /substrlen substrlen 2 idiv def \n",
		"     substrlen 0 eq {exit} if \n",
		"  } loop \n",
		"  ] def \n",
		"  /h newdict /Height get def \n",
		"  1 w div 1 h div matrix scale \n",
		"  olddict /ImageMatrix get exch matrix concatmatrix \n",
		"  matrix invertmatrix concat \n",
		"  newdict /Height 1 put \n",
		"  newdict /DataSource pix put \n",
		"  /mat [w 0 0 h 0 0] def \n",
		"  newdict /ImageMatrix mat put \n",
		"  0 1 h 1 sub { \n",
		"    mat 5 3 -1 roll neg put \n",
		"    olddict /DataSource get str readstring pop pop \n",
		"    /tail str def \n",
		"    /x 0 def \n",
		"    olddict /DataSource get pix readstring pop pop \n",
		"    { \n",
		"      tail transparent search dup /done exch not def \n",
		"      {exch pop exch pop} if \n",
		"      /w1 exch length def \n",
		"      w1 0 ne { \n",
		"        newdict /DataSource ",
		          " pix x crpp mul w1 crpp mul getinterval put \n",
		"        newdict /Width w1 put \n",
		"        mat 4 x neg put \n",
		"        /x x w1 add def \n",
		"        newdict image \n",
		"        /tail tail w1 tail length w1 sub getinterval def \n",
		"      } if \n",
		"      done {exit} if \n",
		"      tail substrs { \n",
		"        anchorsearch {pop} if \n",
		"      } forall \n",
		"      /tail exch def \n",
		"      tail length 0 eq {exit} if \n",
		"      /x w tail length sub def \n",
		"    } loop \n",
		"  } for \n",
		"  end \n",
		"  grestore \n",
		"} bind def \n\n\n", (char *) NULL);
    } else if( !codeIncluded && (colorLevel == 0) ) {
	/*
	 * Monochrome-only code
	 */

	codeIncluded = !0;
	Tcl_AppendResult( interp,
		"/TkPhoto { \n",
		"  gsave \n",
		"  32 dict begin \n",
		"  /dummyInteger exch def \n",
		"  /olddict exch def \n",
		"  olddict /DataSource get dup type /filetype ne { \n",
		"    olddict /DataSource 3 -1 roll \n",
		"    0 () /SubFileDecode filter put \n",
		"  } { \n",
		"    pop \n",
		"  } ifelse \n",
		"  /newdict olddict maxlength dict def \n",
		"  olddict newdict copy pop \n",
		"  /w newdict /Width get def \n",
		"  /pix w 7 add 8 idiv string def \n",
		"  /h newdict /Height get def \n",
		"  1 w div 1 h div matrix scale \n",
		"  olddict /ImageMatrix get exch matrix concatmatrix \n",
		"  matrix invertmatrix concat \n",
		"  newdict /Height 1 put \n",
		"  newdict /DataSource pix put \n",
		"  /mat [w 0 0 h 0 0] def \n",
		"  newdict /ImageMatrix mat put \n",
		"  0 1 h 1 sub { \n",
		"    mat 5 3 -1 roll neg put \n",
		"    0.000 0.000 0.000 setrgbcolor \n",
		"    olddict /DataSource get pix readstring pop pop \n",
		"    newdict /DataSource pix put \n",
		"    newdict imagemask \n",
		"    1.000 1.000 1.000 setrgbcolor \n",
		"    olddict /DataSource get pix readstring pop pop \n",
		"    newdict /DataSource pix put \n",
		"    newdict imagemask \n",
		"  } for \n",
		"  end \n",
		"  grestore \n",
		"} bind def \n\n\n", (char *) NULL);
    }

    /*
     * Check that at least one row of the image can be represented
     * with a string less than 64 KB long (this is a limit in the
     * Postscript interpreter).
     */

    switch (colorLevel)
	{
	    case 0: bytesPerLine = (width + 7) / 8;  maxWidth = 240000;  break;
	    case 1: bytesPerLine = width;  maxWidth = 60000;  break;
	    case 2: bytesPerLine = 3 * width;  maxWidth = 20000;  break;
	}
    if (bytesPerLine > 60000) {
	Tcl_ResetResult(interp);
	sprintf(buffer,
		"Can't generate Postscript for images more than %d pixels wide",
		maxWidth);
	Tcl_AppendResult(interp, buffer, (char *) NULL);
	return TCL_ERROR;
    }

    /*
     * Set up the postscript code except for the image-data stream.
     */

    switch (colorLevel) {
	case 0: 
	    strcpy( cspace, "/DeviceGray");
	    strcpy( decode, "[1 0]");
	    bpc = 1;
	    break;
	case 1: 
	    strcpy( cspace, "/DeviceGray");
	    strcpy( decode, "[0 1]");
	    bpc = 8;
	    break;
	default:
	    strcpy( cspace, "/DeviceRGB");
	    strcpy( decode, "[0 1 0 1 0 1]");
	    bpc = 8;
	    break;
    }


    Tcl_AppendResult(interp,
	    cspace, " setcolorspace\n\n", (char *) NULL);

    sprintf(buffer,
	    "  /Width %d\n  /Height %d\n  /BitsPerComponent %d\n",
	    width, height,  bpc);
    Tcl_AppendResult(interp,
	    "<<\n  /ImageType 1\n", buffer,
	    "  /DataSource currentfile",
	    "  /ASCIIHexDecode filter\n", (char *) NULL);


    sprintf(buffer,
	    "  /ImageMatrix [1 0 0 -1 0 %d]\n", height);
    Tcl_AppendResult(interp, buffer,
	    "  /Decode ", decode, "\n>>\n1 TkPhoto\n", (char *) NULL);


    /*
     * Check the PhotoImageBlock information.
     * We assume that:
     *     if pixelSize is 1,2 or 4, the image is R,G,B,A;
     *     if pixelSize is 3, the image is R,G,B and offset[3] is bogus.
     */

    if (blockPtr->pixelSize == 3) {
	/*
	 * No alpha information: the whole image is opaque.
	 */

	alphaPtr = &opaque;
	alphaPitch = alphaIncr = alphaOffset = 0;
    } else {
	/*
	 * Set up alpha handling.
	 */

	alphaPtr = blockPtr->pixelPtr;
	alphaPitch = blockPtr->pitch;
	alphaIncr = blockPtr->pixelSize;
	alphaOffset = blockPtr->offset[3];
    }


    for (yy = 0, lineLen=0; yy < height; yy++) {
	switch (colorLevel) {
	    case 0: {
		/*
		 * Generate data for image in monochrome mode.
		 * No attempt at dithering is made--instead, just
		 * set a threshold.
		 * To handle transparecies we need to output two lines:
		 * one for the black pixels, one for the white ones.
		 */

		unsigned char mask=0x80;
		unsigned char data=0x00;
		for (xx = 0; xx< width; xx ++) {
		    pixelPtr = blockPtr->pixelPtr 
			+ (yy * blockPtr->pitch) 
			+ (xx *blockPtr->pixelSize);

		    red = pixelPtr[blockPtr->offset[0]];
		    green = pixelPtr[blockPtr->offset[1]];
		    blue = pixelPtr[blockPtr->offset[2]];

		    alpha = *(alphaPtr + (yy * alphaPitch)
			    + (xx * alphaIncr) + alphaOffset);

		    /*
		     * If pixel is less than threshold, then it is black.
		     */

		    if ((alpha != 0) && 
			    ( 0.3086 * red 
				    + 0.6094 * green 
				    + 0.082 * blue < 128)) {
			data |= mask;
		    }
		    mask >>= 1;
		    if (mask == 0) {
			sprintf(buffer, "%02X", data);
			Tcl_AppendResult(interp, buffer, (char *) NULL);
			lineLen += 2;
			if (lineLen >= 60) {
			    lineLen = 0;
			    Tcl_AppendResult(interp, "\n", (char *) NULL);
			}
			mask=0x80;
			data=0x00;
		    }
		}
		if ((width % 8) != 0) {
		    sprintf(buffer, "%02X", data);
		    Tcl_AppendResult(interp, buffer, (char *) NULL);
		    mask=0x80;
		    data=0x00;
		}

		mask=0x80;
		data=0x00;
		for (xx = 0; xx< width; xx ++) {
		    pixelPtr = blockPtr->pixelPtr 
			+ (yy * blockPtr->pitch) 
			+ (xx *blockPtr->pixelSize);

		    red = pixelPtr[blockPtr->offset[0]];
		    green = pixelPtr[blockPtr->offset[1]];
		    blue = pixelPtr[blockPtr->offset[2]];

		    alpha = *(alphaPtr + (yy * alphaPitch)
			    + (xx * alphaIncr) + alphaOffset);
			    
		    /*
		     * If pixel is greater than threshold, then it is white.
		     */

		    if ((alpha != 0) && 
			    (  0.3086 * red 
				    + 0.6094 * green 
				    + 0.082 * blue >= 128)) {
			data |= mask;
		    }
		    mask >>= 1;
		    if (mask == 0) {
			sprintf(buffer, "%02X", data);
			Tcl_AppendResult(interp, buffer, (char *) NULL);
			lineLen += 2;
			if (lineLen >= 60) {
			    lineLen = 0;
			    Tcl_AppendResult(interp, "\n", (char *) NULL);
			}
			mask=0x80;
			data=0x00;
		    }
		}
		if ((width % 8) != 0) {
		    sprintf(buffer, "%02X", data);
		    Tcl_AppendResult(interp, buffer, (char *) NULL);
		    mask=0x80;
		    data=0x00;
		}
		break;
	    }
	    case 1: {
		/*
		 * Generate transparency data.
		 * We must prevent a transparent value of 0
		 * because of a bug in some HP printers.
		 */

		for (xx = 0; xx < width; xx ++) {
		    alpha = *(alphaPtr + (yy * alphaPitch)
			    + (xx * alphaIncr) + alphaOffset);
		    sprintf(buffer, "%02X", alpha | 0x01);
		    Tcl_AppendResult(interp, buffer, (char *) NULL);
		    lineLen += 2;
		    if (lineLen >= 60) {
			lineLen = 0;
			Tcl_AppendResult(interp, "\n", (char *) NULL);
		    }
		}


		/*
		 * Generate data in gray mode--in this case, take a 
		 * weighted sum of the red, green, and blue values.
		 */

		for (xx = 0; xx < width; xx ++) {
		    pixelPtr = blockPtr->pixelPtr 
			+ (yy * blockPtr->pitch) 
			+ (xx *blockPtr->pixelSize);

		    red = pixelPtr[blockPtr->offset[0]];
		    green = pixelPtr[blockPtr->offset[1]];
		    blue = pixelPtr[blockPtr->offset[2]];

		    sprintf(buffer, "%02X", (int) floor(0.5 +
			    ( 0.3086 * red + 0.6094 * green + 0.0820 * blue)));
		    Tcl_AppendResult(interp, buffer, (char *) NULL);
		    lineLen += 2;
		    if (lineLen >= 60) {
			lineLen = 0;
			Tcl_AppendResult(interp, "\n", (char *) NULL);
		    }
		}
		break;
	    }
	    default: {
		/*
		 * Generate transparency data.
		 * We must prevent a transparent value of 0
		 * because of a bug in some HP printers.
		 */

		for (xx = 0; xx < width; xx ++) {
		    alpha = *(alphaPtr + (yy * alphaPitch)
			    + (xx * alphaIncr) + alphaOffset);
		    sprintf(buffer, "%02X", alpha | 0x01);
		    Tcl_AppendResult(interp, buffer, (char *) NULL);
		    lineLen += 2;
		    if (lineLen >= 60) {
			lineLen = 0;
			Tcl_AppendResult(interp, "\n", (char *) NULL);
		    }
		}


		/*
		 * Finally, color mode.  Here, just output the red, green,
		 * and blue values directly.
		 */

		for (xx = 0; xx < width; xx ++) {
		    pixelPtr = blockPtr->pixelPtr 
			+ (yy * blockPtr->pitch) 
			+ (xx *blockPtr->pixelSize);

		    sprintf(buffer, "%02X%02X%02X",
			    pixelPtr[blockPtr->offset[0]],
			    pixelPtr[blockPtr->offset[1]],
			    pixelPtr[blockPtr->offset[2]]);
		    Tcl_AppendResult(interp, buffer, (char *) NULL);
		    lineLen += 6;
		    if (lineLen >= 60) {
			lineLen = 0;
			Tcl_AppendResult(interp, "\n", (char *) NULL);
		    }
		}
		break;
	    }
	}
    }

    Tcl_AppendResult(interp, ">\n", (char *) NULL);
    return TCL_OK;
}

@


1.1.1.3
log
@import tk 8.4.0
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tkCanvPs.c,v 1.10 2002/08/05 04:30:38 dgp Exp $
d119 314
d463 1
a463 1
    CONST char **argv;			/* Argument strings.  Caller has
d473 1
a473 2
    char string[STRING_LENGTH+1];
    CONST char *p;
d487 1
a487 1
    char psenccmd[]="::tk::ensure_psenc_is_loaded";
d495 1
a495 4
    result = Tcl_EvalEx(interp,psenccmd,-1,TCL_EVAL_GLOBAL);
    if (result != TCL_OK) {
        return result;
    }
d720 2
a721 2
      Tcl_AppendResult(interp, "%!PS-Adobe-3.0 EPSF-3.0\n",
		       "%%Creator: Tk Canvas Widget\n", (char *) NULL);
d771 4
a774 1
    Tcl_AppendResult(interp, Tcl_GetVar(interp,"::tk::ps_preamable",TCL_GLOBAL_ONLY), (char *) NULL);
d776 1
a776 1
        Tcl_Write(psInfo.chan, Tcl_GetStringResult(interp), -1);
a778 1
    
d970 1
a970 1
	CONST char *cmdString;
d1050 1
a1050 1
	CONST char *list;
d1053 1
a1053 2
	CONST char **argv;
	CONST char *name;
d2146 1
@


1.1.1.4
log
@imported tk 8.4.1
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tkCanvPs.c,v 1.12 2002/10/10 21:01:17 hobbs Exp $
a25 14
 * The following definition is used in generating postscript for images
 * and windows.
 */

typedef struct TkColormapData {	/* Hold color information for a window */
    int separated;		/* Whether to use separate color bands */
    int color;			/* Whether window is color or black/white */
    int ncolors;		/* Number of color values stored */
    XColor *colors;		/* Pixel value -> RGB mappings */
    int red_mask, green_mask, blue_mask;	/* Masks and shifts for each */
    int red_shift, green_shift, blue_shift;	/* color band */
} TkColormapData;

/*
d461 1
a461 3
    Tcl_AppendResult(interp, Tcl_GetVar(interp,"::tk::ps_preamable",
	    TCL_GLOBAL_ONLY), (char *) NULL);

d466 1
a1100 6
 *	This implementation is bogus on Windows because the colormap
 *	data is never filled in.  Instead all postscript generated
 *	data coming through here is expected to be RGB color data.
 *	To handle lower bit-depth images properly, XQueryColors
 *	must be implemented for Windows.
 *
a1109 9
#ifdef WIN32
#include <windows.h>

/*
 * We could just define these instead of pulling in windows.h.
 #define GetRValue(rgb)	((BYTE)(rgb))
 #define GetGValue(rgb)	((BYTE)(((WORD)(rgb)) >> 8))
 #define GetBValue(rgb)	((BYTE)((rgb)>>16))
*/
a1116 11
    *red   = (double) GetRValue(pixel) / 255.0;
    *green = (double) GetGValue(pixel) / 255.0;
    *blue  = (double) GetBValue(pixel) / 255.0;
}
#else
static void
TkImageGetColor(cdata, pixel, red, green, blue)
    TkColormapData *cdata;              /* Colormap data */
    unsigned long pixel;                /* Pixel value to look up */
    double *red, *green, *blue;         /* Color data to return */
{
d1121 1
a1121 1
	*red   = cdata->colors[r].red / 65535.0;
d1123 1
a1123 1
	*blue  = cdata->colors[b].blue / 65535.0;
d1125 1
a1125 1
	*red   = cdata->colors[pixel].red / 65535.0;
d1127 1
a1127 1
	*blue  = cdata->colors[pixel].blue / 65535.0;
a1129 1
#endif
d1221 1
d1244 2
a1245 1
    switch (level) {
d1326 3
a1328 1
				(0.30 * red + 0.59 * green + 0.11 * blue)));
d1343 1
a1343 1
		    for (xx = x; xx < x+width; xx++) {
@


