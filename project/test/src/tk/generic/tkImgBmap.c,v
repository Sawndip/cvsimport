head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.20.24.44;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.13;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.25;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.51;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.32;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.13;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@/* 
 * tkImgBmap.c --
 *
 *	This procedure implements images of type "bitmap" for Tk.
 *
 * Copyright (c) 1994 The Regents of the University of California.
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
 * Copyright (c) 1999 by Scriptics Corporation.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkImgBmap.c,v 1.15 2002/08/05 04:30:39 dgp Exp $
 */

#include "tkInt.h"
#include "tkPort.h"

/*
 * The following data structure represents the master for a bitmap
 * image:
 */

typedef struct BitmapMaster {
    Tk_ImageMaster tkMaster;	/* Tk's token for image master.  NULL means
				 * the image is being deleted. */
    Tcl_Interp *interp;		/* Interpreter for application that is
				 * using image. */
    Tcl_Command imageCmd;	/* Token for image command (used to delete
				 * it when the image goes away).  NULL means
				 * the image command has already been
				 * deleted. */
    int width, height;		/* Dimensions of image. */
    char *data;			/* Data comprising bitmap (suitable for
				 * input to XCreateBitmapFromData).   May
				 * be NULL if no data.  Malloc'ed. */
    char *maskData;		/* Data for bitmap's mask (suitable for
				 * input to XCreateBitmapFromData).
				 * Malloc'ed. */
    Tk_Uid fgUid;		/* Value of -foreground option (malloc'ed). */
    Tk_Uid bgUid;		/* Value of -background option (malloc'ed). */
    char *fileString;		/* Value of -file option (malloc'ed). */
    char *dataString;		/* Value of -data option (malloc'ed). */
    char *maskFileString;	/* Value of -maskfile option (malloc'ed). */
    char *maskDataString;	/* Value of -maskdata option (malloc'ed). */
    struct BitmapInstance *instancePtr;
				/* First in list of all instances associated
				 * with this master. */
} BitmapMaster;

/*
 * The following data structure represents all of the instances of an
 * image that lie within a particular window:
 */

typedef struct BitmapInstance {
    int refCount;		/* Number of instances that share this
				 * data structure. */
    BitmapMaster *masterPtr;	/* Pointer to master for image. */
    Tk_Window tkwin;		/* Window in which the instances will be
				 * displayed. */
    XColor *fg;			/* Foreground color for displaying image. */
    XColor *bg;			/* Background color for displaying image. */
    Pixmap bitmap;		/* The bitmap to display. */
    Pixmap mask;		/* Mask: only display bitmap pixels where
				 * there are 1's here. */
    GC gc;			/* Graphics context for displaying bitmap.
				 * None means there was an error while
				 * setting up the instance, so it cannot
				 * be displayed. */
    struct BitmapInstance *nextPtr;
				/* Next in list of all instance structures
				 * associated with masterPtr (NULL means
				 * end of list). */
} BitmapInstance;

/*
 * The type record for bitmap images:
 */

static int		GetByte _ANSI_ARGS_((Tcl_Channel chan));
static int		ImgBmapCreate _ANSI_ARGS_((Tcl_Interp *interp,
			    char *name, int argc, Tcl_Obj *CONST objv[],
			    Tk_ImageType *typePtr, Tk_ImageMaster master,
			    ClientData *clientDataPtr));
static ClientData	ImgBmapGet _ANSI_ARGS_((Tk_Window tkwin,
			    ClientData clientData));
static void		ImgBmapDisplay _ANSI_ARGS_((ClientData clientData,
			    Display *display, Drawable drawable, 
			    int imageX, int imageY, int width, int height,
			    int drawableX, int drawableY));
static void		ImgBmapFree _ANSI_ARGS_((ClientData clientData,
			    Display *display));
static void		ImgBmapDelete _ANSI_ARGS_((ClientData clientData));
static int		ImgBmapPostscript _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, Tk_Window tkwin,
			    Tk_PostscriptInfo psinfo, int x, int y,
			    int width, int height, int prepass));

Tk_ImageType tkBitmapImageType = {
    "bitmap",			/* name */
    ImgBmapCreate,		/* createProc */
    ImgBmapGet,			/* getProc */
    ImgBmapDisplay,		/* displayProc */
    ImgBmapFree,		/* freeProc */
    ImgBmapDelete,		/* deleteProc */
    ImgBmapPostscript,		/* postscriptProc */
    (Tk_ImageType *) NULL	/* nextPtr */
};

/*
 * Information used for parsing configuration specs:
 */

static Tk_ConfigSpec configSpecs[] = {
    {TK_CONFIG_UID, "-background", (char *) NULL, (char *) NULL,
	"", Tk_Offset(BitmapMaster, bgUid), 0},
    {TK_CONFIG_STRING, "-data", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(BitmapMaster, dataString), TK_CONFIG_NULL_OK},
    {TK_CONFIG_STRING, "-file", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(BitmapMaster, fileString), TK_CONFIG_NULL_OK},
    {TK_CONFIG_UID, "-foreground", (char *) NULL, (char *) NULL,
	"#000000", Tk_Offset(BitmapMaster, fgUid), 0},
    {TK_CONFIG_STRING, "-maskdata", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(BitmapMaster, maskDataString),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_STRING, "-maskfile", (char *) NULL, (char *) NULL,
	(char *) NULL, Tk_Offset(BitmapMaster, maskFileString),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_END, (char *) NULL, (char *) NULL, (char *) NULL,
	(char *) NULL, 0, 0}
};

/*
 * The following data structure is used to describe the state of
 * parsing a bitmap file or string.  It is used for communication
 * between TkGetBitmapData and NextBitmapWord.
 */

#define MAX_WORD_LENGTH 100
typedef struct ParseInfo {
    char *string;		/* Next character of string data for bitmap,
				 * or NULL if bitmap is being read from
				 * file. */
    Tcl_Channel chan;		/* File containing bitmap data, or NULL
				 * if no file. */
    char word[MAX_WORD_LENGTH+1];
				/* Current word of bitmap data, NULL
				 * terminated. */
    int wordLength;		/* Number of non-NULL bytes in word. */
} ParseInfo;

/*
 * Prototypes for procedures used only locally in this file:
 */

static int		ImgBmapCmd _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, int argc, Tcl_Obj *CONST objv[]));
static void		ImgBmapCmdDeletedProc _ANSI_ARGS_((
			    ClientData clientData));
static void		ImgBmapConfigureInstance _ANSI_ARGS_((
			    BitmapInstance *instancePtr));
static int		ImgBmapConfigureMaster _ANSI_ARGS_((
			    BitmapMaster *masterPtr, int argc, Tcl_Obj *CONST objv[],
			    int flags));
static int		NextBitmapWord _ANSI_ARGS_((ParseInfo *parseInfoPtr));

/*
 *----------------------------------------------------------------------
 *
 * ImgBmapCreate --
 *
 *	This procedure is called by the Tk image code to create "test"
 *	images.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	The data structure for a new image is allocated.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
static int
ImgBmapCreate(interp, name, argc, argv, typePtr, master, clientDataPtr)
    Tcl_Interp *interp;		/* Interpreter for application containing
				 * image. */
    char *name;			/* Name to use for image. */
    int argc;			/* Number of arguments. */
    Tcl_Obj *CONST argv[];	/* Argument objects for options (doesn't
				 * include image name or type). */
    Tk_ImageType *typePtr;	/* Pointer to our type record (not used). */
    Tk_ImageMaster master;	/* Token for image, to be used by us in
				 * later callbacks. */
    ClientData *clientDataPtr;	/* Store manager's token for image here;
				 * it will be returned in later callbacks. */
{
    BitmapMaster *masterPtr;

    masterPtr = (BitmapMaster *) ckalloc(sizeof(BitmapMaster));
    masterPtr->tkMaster = master;
    masterPtr->interp = interp;
    masterPtr->imageCmd = Tcl_CreateObjCommand(interp, name, ImgBmapCmd,
	    (ClientData) masterPtr, ImgBmapCmdDeletedProc);
    masterPtr->width = masterPtr->height = 0;
    masterPtr->data = NULL;
    masterPtr->maskData = NULL;
    masterPtr->fgUid = NULL;
    masterPtr->bgUid = NULL;
    masterPtr->fileString = NULL;
    masterPtr->dataString = NULL;
    masterPtr->maskFileString = NULL;
    masterPtr->maskDataString = NULL;
    masterPtr->instancePtr = NULL;
    if (ImgBmapConfigureMaster(masterPtr, argc, argv, 0) != TCL_OK) {
	ImgBmapDelete((ClientData) masterPtr);
	return TCL_ERROR;
    }
    *clientDataPtr = (ClientData) masterPtr;
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ImgBmapConfigureMaster --
 *
 *	This procedure is called when a bitmap image is created or
 *	reconfigured.  It process configuration options and resets
 *	any instances of the image.
 *
 * Results:
 *	A standard Tcl return value.  If TCL_ERROR is returned then
 *	an error message is left in the masterPtr->interp's result.
 *
 * Side effects:
 *	Existing instances of the image will be redisplayed to match
 *	the new configuration options.
 *
 *----------------------------------------------------------------------
 */

static int
ImgBmapConfigureMaster(masterPtr, objc, objv, flags)
    BitmapMaster *masterPtr;	/* Pointer to data structure describing
				 * overall bitmap image to (reconfigure). */
    int objc;			/* Number of entries in objv. */
    Tcl_Obj *CONST objv[];	/* Pairs of configuration options for image. */
    int flags;			/* Flags to pass to Tk_ConfigureWidget,
				 * such as TK_CONFIG_ARGV_ONLY. */
{
    BitmapInstance *instancePtr;
    int maskWidth, maskHeight, dummy1, dummy2;

    CONST char **argv = (CONST char **) ckalloc((objc+1) * sizeof(char *));
    for (dummy1 = 0; dummy1 < objc; dummy1++) {
	argv[dummy1]=Tcl_GetString(objv[dummy1]);
    }
    argv[objc] = NULL;

    if (Tk_ConfigureWidget(masterPtr->interp, Tk_MainWindow(masterPtr->interp),
	    configSpecs, objc, argv, (char *) masterPtr, flags)
	    != TCL_OK) {
	ckfree((char *) argv);
	return TCL_ERROR;
    }
    ckfree((char *) argv);

    /*
     * Parse the bitmap and/or mask to create binary data.  Make sure that
     * the bitmap and mask have the same dimensions.
     */

    if (masterPtr->data != NULL) {
	ckfree(masterPtr->data);
	masterPtr->data = NULL;
    }
    if ((masterPtr->fileString != NULL) || (masterPtr->dataString != NULL)) {
	masterPtr->data = TkGetBitmapData(masterPtr->interp,
		masterPtr->dataString, masterPtr->fileString,
		&masterPtr->width, &masterPtr->height, &dummy1, &dummy2);
	if (masterPtr->data == NULL) {
	    return TCL_ERROR;
	}
    }
    if (masterPtr->maskData != NULL) {
	ckfree(masterPtr->maskData);
	masterPtr->maskData = NULL;
    }
    if ((masterPtr->maskFileString != NULL)
	    || (masterPtr->maskDataString != NULL)) {
	if (masterPtr->data == NULL) {
	    Tcl_SetResult(masterPtr->interp, "can't have mask without bitmap",
		    TCL_STATIC);
	    return TCL_ERROR;
	}
	masterPtr->maskData = TkGetBitmapData(masterPtr->interp,
		masterPtr->maskDataString, masterPtr->maskFileString,
		&maskWidth, &maskHeight, &dummy1, &dummy2);
	if (masterPtr->maskData == NULL) {
	    return TCL_ERROR;
	}
	if ((maskWidth != masterPtr->width)
		|| (maskHeight != masterPtr->height)) {
	    ckfree(masterPtr->maskData);
	    masterPtr->maskData = NULL;
	    Tcl_SetResult(masterPtr->interp,
		    "bitmap and mask have different sizes", TCL_STATIC);
	    return TCL_ERROR;
	}
    }

    /*
     * Cycle through all of the instances of this image, regenerating
     * the information for each instance.  Then force the image to be
     * redisplayed everywhere that it is used.
     */

    for (instancePtr = masterPtr->instancePtr; instancePtr != NULL;
	    instancePtr = instancePtr->nextPtr) {
	ImgBmapConfigureInstance(instancePtr);
    }
    Tk_ImageChanged(masterPtr->tkMaster, 0, 0, masterPtr->width,
	    masterPtr->height, masterPtr->width, masterPtr->height);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ImgBmapConfigureInstance --
 *
 *	This procedure is called to create displaying information for
 *	a bitmap image instance based on the configuration information
 *	in the master.  It is invoked both when new instances are
 *	created and when the master is reconfigured.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Generates errors via Tcl_BackgroundError if there are problems
 *	in setting up the instance.
 *
 *----------------------------------------------------------------------
 */

static void
ImgBmapConfigureInstance(instancePtr)
    BitmapInstance *instancePtr;	/* Instance to reconfigure. */
{
    BitmapMaster *masterPtr = instancePtr->masterPtr;
    XColor *colorPtr;
    XGCValues gcValues;
    GC gc;
    unsigned int mask;
    Pixmap oldMask;

    /*
     * For each of the options in masterPtr, translate the string
     * form into an internal form appropriate for instancePtr.
     */

    if (*masterPtr->bgUid != 0) {
	colorPtr = Tk_GetColor(masterPtr->interp, instancePtr->tkwin,
		masterPtr->bgUid);
	if (colorPtr == NULL) {
	    goto error;
	}
    } else {
	colorPtr = NULL;
    }
    if (instancePtr->bg != NULL) {
	Tk_FreeColor(instancePtr->bg);
    }
    instancePtr->bg = colorPtr;

    colorPtr = Tk_GetColor(masterPtr->interp, instancePtr->tkwin,
	    masterPtr->fgUid);
    if (colorPtr == NULL) {
	goto error;
    }
    if (instancePtr->fg != NULL) {
	Tk_FreeColor(instancePtr->fg);
    }
    instancePtr->fg = colorPtr;

    if (instancePtr->bitmap != None) {
	Tk_FreePixmap(Tk_Display(instancePtr->tkwin), instancePtr->bitmap);
	instancePtr->bitmap = None;
    }
    if (masterPtr->data != NULL) {
	instancePtr->bitmap = XCreateBitmapFromData(
		Tk_Display(instancePtr->tkwin),
		RootWindowOfScreen(Tk_Screen(instancePtr->tkwin)),
		masterPtr->data, (unsigned) masterPtr->width,
		(unsigned) masterPtr->height);
    }

    /*
     * Careful:  We have to allocate a new mask Pixmap before deleting
     * the old one.  Otherwise, The XID allocator will always return
     * the same XID for the new Pixmap as was used for the old Pixmap.
     * And that will prevent the mask from changing in the GC below.
     */
    oldMask = instancePtr->mask;
    instancePtr->mask = None;
    if (masterPtr->maskData != NULL) {
	instancePtr->mask = XCreateBitmapFromData(
		Tk_Display(instancePtr->tkwin),
		RootWindowOfScreen(Tk_Screen(instancePtr->tkwin)),
		masterPtr->maskData, (unsigned) masterPtr->width,
		(unsigned) masterPtr->height);
    }
    if (oldMask != None) {
      Tk_FreePixmap(Tk_Display(instancePtr->tkwin), oldMask);
    }

    if (masterPtr->data != NULL) {
	gcValues.foreground = instancePtr->fg->pixel;
	gcValues.graphics_exposures = False;
	mask = GCForeground|GCGraphicsExposures;
	if (instancePtr->bg != NULL) {
	    gcValues.background = instancePtr->bg->pixel;
	    mask |= GCBackground;
	    if (instancePtr->mask != None) {
		gcValues.clip_mask = instancePtr->mask;
		mask |= GCClipMask;
	    }
	} else {
	    gcValues.clip_mask = instancePtr->bitmap;
	    mask |= GCClipMask;
	}
	gc = Tk_GetGC(instancePtr->tkwin, mask, &gcValues);
    } else {
	gc = None;
    }
    if (instancePtr->gc != None) {
	Tk_FreeGC(Tk_Display(instancePtr->tkwin), instancePtr->gc);
    }
    instancePtr->gc = gc;
    return;

    error:
    /*
     * An error occurred: clear the graphics context in the instance to
     * make it clear that this instance cannot be displayed.  Then report
     * the error.
     */

    if (instancePtr->gc != None) {
	Tk_FreeGC(Tk_Display(instancePtr->tkwin), instancePtr->gc);
    }
    instancePtr->gc = None;
    Tcl_AddErrorInfo(masterPtr->interp, "\n    (while configuring image \"");
    Tcl_AddErrorInfo(masterPtr->interp, Tk_NameOfImage(masterPtr->tkMaster));
    Tcl_AddErrorInfo(masterPtr->interp, "\")");
    Tcl_BackgroundError(masterPtr->interp);
}

/*
 *----------------------------------------------------------------------
 *
 * TkGetBitmapData --
 *
 *	Given a file name or ASCII string, this procedure parses the
 *	file or string contents to produce binary data for a bitmap.
 *
 * Results:
 *	If the bitmap description was parsed successfully then the
 *	return value is a malloc-ed array containing the bitmap data.
 *	The dimensions of the data are stored in *widthPtr and
 *	*heightPtr.  *hotXPtr and *hotYPtr are set to the bitmap
 *	hotspot if one is defined, otherwise they are set to -1, -1.
 *	If an error occurred, NULL is returned and an error message is
 *	left in the interp's result.
 *
 * Side effects:
 *	A bitmap is created.
 *
 *----------------------------------------------------------------------
 */

char *
TkGetBitmapData(interp, string, fileName, widthPtr, heightPtr,
	hotXPtr, hotYPtr)
    Tcl_Interp *interp;			/* For reporting errors, or NULL. */
    char *string;			/* String describing bitmap.  May
					 * be NULL. */
    char *fileName;			/* Name of file containing bitmap
					 * description.  Used only if string
					 * is NULL.  Must not be NULL if
					 * string is NULL. */
    int *widthPtr, *heightPtr;		/* Dimensions of bitmap get returned
					 * here. */
    int *hotXPtr, *hotYPtr;		/* Position of hot spot or -1,-1. */
{
    int width, height, numBytes, hotX, hotY;
    CONST char *expandedFileName;
    char *p, *end;
    ParseInfo pi;
    char *data = NULL;
    Tcl_DString buffer;

    pi.string = string;
    if (string == NULL) {
        if ((interp != NULL) && Tcl_IsSafe(interp)) {
            Tcl_AppendResult(interp, "can't get bitmap data from a file in a",
                    " safe interpreter", (char *) NULL);
            return NULL;
        }
	expandedFileName = Tcl_TranslateFileName(interp, fileName, &buffer);
	if (expandedFileName == NULL) {
	    return NULL;
	}
	pi.chan = Tcl_OpenFileChannel(interp, expandedFileName, "r", 0);
	Tcl_DStringFree(&buffer);
	if (pi.chan == NULL) {
	    if (interp != NULL) {
		Tcl_ResetResult(interp);
		Tcl_AppendResult(interp, "couldn't read bitmap file \"",
			fileName, "\": ", Tcl_PosixError(interp),
			(char *) NULL);
	    }
	    return NULL;
	}
	
        if (Tcl_SetChannelOption(interp, pi.chan, "-translation", "binary")
		!= TCL_OK) {
            return NULL;
        }
        if (Tcl_SetChannelOption(interp, pi.chan, "-encoding", "binary")
		!= TCL_OK) {
            return NULL;
        }
    } else {
	pi.chan = NULL;
    }

    /*
     * Parse the lines that define the dimensions of the bitmap,
     * plus the first line that defines the bitmap data (it declares
     * the name of a data variable but doesn't include any actual
     * data).  These lines look something like the following:
     *
     *		#define foo_width 16
     *		#define foo_height 16
     *		#define foo_x_hot 3
     *		#define foo_y_hot 3
     *		static char foo_bits[] = {
     *
     * The x_hot and y_hot lines may or may not be present.  It's
     * important to check for "char" in the last line, in order to
     * reject old X10-style bitmaps that used shorts.
     */

    width = 0;
    height = 0;
    hotX = -1;
    hotY = -1;
    while (1) {
	if (NextBitmapWord(&pi) != TCL_OK) {
	    goto error;
	}
	if ((pi.wordLength >= 6) && (pi.word[pi.wordLength-6] == '_')
		&& (strcmp(pi.word+pi.wordLength-6, "_width") == 0)) {
	    if (NextBitmapWord(&pi) != TCL_OK) {
		goto error;
	    }
	    width = strtol(pi.word, &end, 0);
	    if ((end == pi.word) || (*end != 0)) {
		goto error;
	    }
	} else if ((pi.wordLength >= 7) && (pi.word[pi.wordLength-7] == '_')
		&& (strcmp(pi.word+pi.wordLength-7, "_height") == 0)) {
	    if (NextBitmapWord(&pi) != TCL_OK) {
		goto error;
	    }
	    height = strtol(pi.word, &end, 0);
	    if ((end == pi.word) || (*end != 0)) {
		goto error;
	    }
	} else if ((pi.wordLength >= 6) && (pi.word[pi.wordLength-6] == '_')
		&& (strcmp(pi.word+pi.wordLength-6, "_x_hot") == 0)) {
	    if (NextBitmapWord(&pi) != TCL_OK) {
		goto error;
	    }
	    hotX = strtol(pi.word, &end, 0);
	    if ((end == pi.word) || (*end != 0)) {
		goto error;
	    }
	} else if ((pi.wordLength >= 6) && (pi.word[pi.wordLength-6] == '_')
		&& (strcmp(pi.word+pi.wordLength-6, "_y_hot") == 0)) {
	    if (NextBitmapWord(&pi) != TCL_OK) {
		goto error;
	    }
	    hotY = strtol(pi.word, &end, 0);
	    if ((end == pi.word) || (*end != 0)) {
		goto error;
	    }
	} else if ((pi.word[0] == 'c') && (strcmp(pi.word, "char") == 0)) {
	    while (1) {
		if (NextBitmapWord(&pi) != TCL_OK) {
		    goto error;
		}
		if ((pi.word[0] == '{') && (pi.word[1] == 0)) {
		    goto getData;
		}
	    }
	} else if ((pi.word[0] == '{') && (pi.word[1] == 0)) {
	    if (interp != NULL) {
		Tcl_AppendResult(interp, "format error in bitmap data; ",
			"looks like it's an obsolete X10 bitmap file",
			(char *) NULL);
	    }
	    goto errorCleanup;
	}
    }

    /*
     * Now we've read everything but the data.  Allocate an array
     * and read in the data.
     */

    getData:
    if ((width <= 0) || (height <= 0)) {
	goto error;
    }
    numBytes = ((width+7)/8) * height;
    data = (char *) ckalloc((unsigned) numBytes);
    for (p = data; numBytes > 0; p++, numBytes--) {
	if (NextBitmapWord(&pi) != TCL_OK) {
	    goto error;
	}
	*p = (char) strtol(pi.word, &end, 0);
	if (end == pi.word) {
	    goto error;
	}
    }

    /*
     * All done.  Clean up and return.
     */

    if (pi.chan != NULL) {
	Tcl_Close(NULL, pi.chan);
    }
    *widthPtr = width;
    *heightPtr = height;
    *hotXPtr = hotX;
    *hotYPtr = hotY;
    return data;

    error:
    if (interp != NULL) {
	Tcl_SetResult(interp, "format error in bitmap data", TCL_STATIC);
    }
    
    errorCleanup:
    if (data != NULL) {
	ckfree(data);
    }
    if (pi.chan != NULL) {
	Tcl_Close(NULL, pi.chan);
    }
    return NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * NextBitmapWord --
 *
 *	This procedure retrieves the next word of information (stuff
 *	between commas or white space) from a bitmap description.
 *
 * Results:
 *	Returns TCL_OK if all went well.  In this case the next word,
 *	and its length, will be availble in *parseInfoPtr.  If the end
 *	of the bitmap description was reached then TCL_ERROR is returned.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
NextBitmapWord(parseInfoPtr)
    ParseInfo *parseInfoPtr;		/* Describes what we're reading
					 * and where we are in it. */
{
    char *src, *dst;
    int c;

    parseInfoPtr->wordLength = 0;
    dst = parseInfoPtr->word;
    if (parseInfoPtr->string != NULL) {
	for (src = parseInfoPtr->string; isspace(UCHAR(*src)) || (*src == ',');
		src++) {
	    if (*src == 0) {
		return TCL_ERROR;
	    }
	}
	for ( ; !isspace(UCHAR(*src)) && (*src != ',') && (*src != 0); src++) {
	    *dst = *src;
	    dst++;
	    parseInfoPtr->wordLength++;
	    if (parseInfoPtr->wordLength > MAX_WORD_LENGTH) {
		return TCL_ERROR;
	    }
	}
	parseInfoPtr->string = src;
    } else {
	for (c = GetByte(parseInfoPtr->chan); isspace(UCHAR(c)) || (c == ',');
		c = GetByte(parseInfoPtr->chan)) {
	    if (c == EOF) {
		return TCL_ERROR;
	    }
	}
	for ( ; !isspace(UCHAR(c)) && (c != ',') && (c != EOF);
		c = GetByte(parseInfoPtr->chan)) {
	    *dst = c;
	    dst++;
	    parseInfoPtr->wordLength++;
	    if (parseInfoPtr->wordLength > MAX_WORD_LENGTH) {
		return TCL_ERROR;
	    }
	}
    }
    if (parseInfoPtr->wordLength == 0) {
	return TCL_ERROR;
    }
    parseInfoPtr->word[parseInfoPtr->wordLength] = 0;
    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * ImgBmapCmd --
 *
 *	This procedure is invoked to process the Tcl command
 *	that corresponds to an image managed by this module.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *--------------------------------------------------------------
 */

static int
ImgBmapCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Information about the image master. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    static CONST char *bmapOptions[] = {"cget", "configure", (char *) NULL};
    BitmapMaster *masterPtr = (BitmapMaster *) clientData;
    int code, index;

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "option ?arg arg ...?");
	return TCL_ERROR;
    }
    if (Tcl_GetIndexFromObj(interp, objv[1], bmapOptions, "option", 0,
	    &index) != TCL_OK) {
	return TCL_ERROR;
    }
    switch (index) {
      case 0: {
	if (objc != 3) {
	    Tcl_WrongNumArgs(interp, 2, objv, "option");
	    return TCL_ERROR;
	}
	return Tk_ConfigureValue(interp, Tk_MainWindow(interp), configSpecs,
		(char *) masterPtr, Tcl_GetString(objv[2]), 0);
      }
      case 1: {
	if (objc == 2) {
	    code = Tk_ConfigureInfo(interp, Tk_MainWindow(interp),
		    configSpecs, (char *) masterPtr, (char *) NULL, 0);
	} else if (objc == 3) {
	    code = Tk_ConfigureInfo(interp, Tk_MainWindow(interp),
		    configSpecs, (char *) masterPtr,
		    Tcl_GetString(objv[2]), 0);
	} else {
	    code = ImgBmapConfigureMaster(masterPtr, objc-2, objv+2,
		    TK_CONFIG_ARGV_ONLY);
	}
	return code;
      }
      default: {
	panic("bad const entries to bmapOptions in ImgBmapCmd");
      }
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ImgBmapGet --
 *
 *	This procedure is called for each use of a bitmap image in a
 *	widget.
 *
 * Results:
 *	The return value is a token for the instance, which is passed
 *	back to us in calls to ImgBmapDisplay and ImgBmapFree.
 *
 * Side effects:
 *	A data structure is set up for the instance (or, an existing
 *	instance is re-used for the new one).
 *
 *----------------------------------------------------------------------
 */

static ClientData
ImgBmapGet(tkwin, masterData)
    Tk_Window tkwin;		/* Window in which the instance will be
				 * used. */
    ClientData masterData;	/* Pointer to our master structure for the
				 * image. */
{
    BitmapMaster *masterPtr = (BitmapMaster *) masterData;
    BitmapInstance *instancePtr;

    /*
     * See if there is already an instance for this window.  If so
     * then just re-use it.
     */

    for (instancePtr = masterPtr->instancePtr; instancePtr != NULL;
	    instancePtr = instancePtr->nextPtr) {
	if (instancePtr->tkwin == tkwin) {
	    instancePtr->refCount++;
	    return (ClientData) instancePtr;
	}
    }

    /*
     * The image isn't already in use in this window.  Make a new
     * instance of the image.
     */

    instancePtr = (BitmapInstance *) ckalloc(sizeof(BitmapInstance));
    instancePtr->refCount = 1;
    instancePtr->masterPtr = masterPtr;
    instancePtr->tkwin = tkwin;
    instancePtr->fg = NULL;
    instancePtr->bg = NULL;
    instancePtr->bitmap = None;
    instancePtr->mask = None;
    instancePtr->gc = None;
    instancePtr->nextPtr = masterPtr->instancePtr;
    masterPtr->instancePtr = instancePtr;
    ImgBmapConfigureInstance(instancePtr);

    /*
     * If this is the first instance, must set the size of the image.
     */

    if (instancePtr->nextPtr == NULL) {
	Tk_ImageChanged(masterPtr->tkMaster, 0, 0, 0, 0, masterPtr->width,
		masterPtr->height);
    }

    return (ClientData) instancePtr;
}

/*
 *----------------------------------------------------------------------
 *
 * ImgBmapDisplay --
 *
 *	This procedure is invoked to draw a bitmap image.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	A portion of the image gets rendered in a pixmap or window.
 *
 *----------------------------------------------------------------------
 */

static void
ImgBmapDisplay(clientData, display, drawable, imageX, imageY, width,
	height, drawableX, drawableY)
    ClientData clientData;	/* Pointer to BitmapInstance structure for
				 * for instance to be displayed. */
    Display *display;		/* Display on which to draw image. */
    Drawable drawable;		/* Pixmap or window in which to draw image. */
    int imageX, imageY;		/* Upper-left corner of region within image
				 * to draw. */
    int width, height;		/* Dimensions of region within image to draw. */
    int drawableX, drawableY;	/* Coordinates within drawable that
				 * correspond to imageX and imageY. */
{
    BitmapInstance *instancePtr = (BitmapInstance *) clientData;
    int masking;

    /*
     * If there's no graphics context, it means that an error occurred
     * while creating the image instance so it can't be displayed.
     */

    if (instancePtr->gc == None) {
	return;
    }

    /*
     * If masking is in effect, must modify the mask origin within
     * the graphics context to line up with the image's origin.
     * Then draw the image and reset the clip origin, if there's
     * a mask.
     */

    masking = (instancePtr->mask != None) || (instancePtr->bg == NULL);
    if (masking) {
	XSetClipOrigin(display, instancePtr->gc, drawableX - imageX,
		drawableY - imageY);
    }
    XCopyPlane(display, instancePtr->bitmap, drawable, instancePtr->gc,
	    imageX, imageY, (unsigned) width, (unsigned) height,
	    drawableX, drawableY, 1);
    if (masking) {
	XSetClipOrigin(display, instancePtr->gc, 0, 0);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ImgBmapFree --
 *
 *	This procedure is called when a widget ceases to use a
 *	particular instance of an image.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Internal data structures get cleaned up.
 *
 *----------------------------------------------------------------------
 */

static void
ImgBmapFree(clientData, display)
    ClientData clientData;	/* Pointer to BitmapInstance structure for
				 * for instance to be displayed. */
    Display *display;		/* Display containing window that used image. */
{
    BitmapInstance *instancePtr = (BitmapInstance *) clientData;
    BitmapInstance *prevPtr;

    instancePtr->refCount--;
    if (instancePtr->refCount > 0) {
	return;
    }

    /*
     * There are no more uses of the image within this widget.  Free
     * the instance structure.
     */

    if (instancePtr->fg != NULL) {
	Tk_FreeColor(instancePtr->fg);
    }
    if (instancePtr->bg != NULL) {
	Tk_FreeColor(instancePtr->bg);
    }
    if (instancePtr->bitmap != None) {
	Tk_FreePixmap(display, instancePtr->bitmap);
    }
    if (instancePtr->mask != None) {
	Tk_FreePixmap(display, instancePtr->mask);
    }
    if (instancePtr->gc != None) {
	Tk_FreeGC(display, instancePtr->gc);
    }
    if (instancePtr->masterPtr->instancePtr == instancePtr) {
	instancePtr->masterPtr->instancePtr = instancePtr->nextPtr;
    } else {
	for (prevPtr = instancePtr->masterPtr->instancePtr;
		prevPtr->nextPtr != instancePtr; prevPtr = prevPtr->nextPtr) {
	    /* Empty loop body */
	}
	prevPtr->nextPtr = instancePtr->nextPtr;
    }
    ckfree((char *) instancePtr);
}

/*
 *----------------------------------------------------------------------
 *
 * ImgBmapDelete --
 *
 *	This procedure is called by the image code to delete the
 *	master structure for an image.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Resources associated with the image get freed.
 *
 *----------------------------------------------------------------------
 */

static void
ImgBmapDelete(masterData)
    ClientData masterData;	/* Pointer to BitmapMaster structure for
				 * image.  Must not have any more instances. */
{
    BitmapMaster *masterPtr = (BitmapMaster *) masterData;

    if (masterPtr->instancePtr != NULL) {
	panic("tried to delete bitmap image when instances still exist");
    }
    masterPtr->tkMaster = NULL;
    if (masterPtr->imageCmd != NULL) {
	Tcl_DeleteCommandFromToken(masterPtr->interp, masterPtr->imageCmd);
    }
    if (masterPtr->data != NULL) {
	ckfree(masterPtr->data);
    }
    if (masterPtr->maskData != NULL) {
	ckfree(masterPtr->maskData);
    }
    Tk_FreeOptions(configSpecs, (char *) masterPtr, (Display *) NULL, 0);
    ckfree((char *) masterPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * ImgBmapCmdDeletedProc --
 *
 *	This procedure is invoked when the image command for an image
 *	is deleted.  It deletes the image.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The image is deleted.
 *
 *----------------------------------------------------------------------
 */

static void
ImgBmapCmdDeletedProc(clientData)
    ClientData clientData;	/* Pointer to BitmapMaster structure for
				 * image. */
{
    BitmapMaster *masterPtr = (BitmapMaster *) clientData;

    masterPtr->imageCmd = NULL;
    if (masterPtr->tkMaster != NULL) {
	Tk_DeleteImage(masterPtr->interp, Tk_NameOfImage(masterPtr->tkMaster));
    }
}

/*
 *----------------------------------------------------------------------
 *
 * GetByte --
 *
 *	Get the next byte from the open channel.
 *
 * Results:
 *	The next byte or EOF.
 *
 * Side effects:
 *	We read from the channel.
 *
 *----------------------------------------------------------------------
 */

static int
GetByte(chan)
    Tcl_Channel chan;	/* The channel we read from. */
{
    char buffer;
    int size;

    size = Tcl_Read(chan, &buffer, 1);
    if (size <= 0) {
	return EOF;
    } else {
	return buffer;
    }
}


/*
 *----------------------------------------------------------------------
 *
 * ImgBmapPsImagemask --
 *
 *	This procedure generates postscript suitable for rendering a
 *      single bitmap of an image.  A single bitmap image might contain both
 *      a foreground and a background bitmap.  This routine is called once
 *      for each such bitmap in a bitmap image.
 *
 *      Prior to invoking this routine, the following setup has occurred:
 *
 *	   1.  The postscript foreground color has been set to the color
 *	       used to render the bitmap.
 *
 *	   2.  The origin of the postscript coordinate system is set to
 *             the lower left corner of the bitmap.
 *
 *	   3.  The postscript coordinate system has been scaled so that
 *	       the entire bitmap is one unit squared.
 *
 * 	Some postscript implementations cannot handle bitmap strings
 *	longer than about 60k characters.  If the bitmap data is that big
 *	or bigger, then we render it by splitting it into several smaller
 *	bitmaps.
 *
 * Results:
 *	Returns TCL_OK on success.  Returns TCL_ERROR and leaves and error
 *	message in interp->result if there is a problem.
 *
 * Side effects:
 *	Postscript code is appended to interp->result.
 *
 *----------------------------------------------------------------------
 */

static int
ImgBmapPsImagemask(interp, width, height, data)
    Tcl_Interp *interp;       /* Append postscript to this interpreter */
    int width, height;        /* Width and height of the bitmap in pixels */
    char *data;               /* Data for the bitmap */
{
    int i, j, nBytePerRow;
    char buffer[200];

    /* 
     * The bit order of bitmaps in Tk is the opposite of the bit order that
     * postscript uses.  (In Tk, the least significant bit is on the right
     * side of the bitmap and in postscript the least significant bit is shown
     * on the left.)  The following array is used to reverse the order of bits
     * within a byte so that the bits will be in the order postscript expects.
     */
    static unsigned char bit_reverse[] = {
       0, 128, 64, 192, 32, 160,  96, 224, 16, 144, 80, 208, 48, 176, 112, 240,
       8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248,
       4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244,
      12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252,
       2, 130, 66, 194, 34, 162,  98, 226, 18, 146, 82, 210, 50, 178, 114, 242,
      10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250,
       6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246,
      14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254,
       1, 129, 65, 193, 33, 161,  97, 225, 17, 145, 81, 209, 49, 177, 113, 241,
       9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249,
       5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245,
      13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253,
       3, 131, 67, 195, 35, 163,  99, 227, 19, 147, 83, 211, 51, 179, 115, 243,
      11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251,
       7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247,
      15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255,
    };

    if (width*height > 60000) {
	Tcl_ResetResult(interp);
	Tcl_AppendResult(interp, "unable to generate postscript for bitmaps "
		"larger than 60000 pixels", 0);
	return TCL_ERROR;
    }
    sprintf(buffer, "0 0 moveto %d %d true [%d 0 0 %d 0 %d] {<\n",
      width, height, width, -height, height);
    Tcl_AppendResult(interp, buffer, 0);
    nBytePerRow = (width+7)/8;
    for(i=0; i<height; i++){
      for(j=0; j<nBytePerRow; j++){
        sprintf(buffer, " %02x", bit_reverse[0xff & data[i*nBytePerRow + j]]);
        Tcl_AppendResult(interp, buffer, 0);
      }
      Tcl_AppendResult(interp, "\n", 0);
    }
    Tcl_AppendResult(interp, ">} imagemask \n", 0);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ImgBmapPostscript --
 *
 *	This procedure generates postscript for rendering a bitmap image.
 *
 * Results:
 *	On success, this routine writes postscript code into interp->result
 *      and returns TCL_OK  TCL_ERROR is returned and an error
 *      message is left in interp->result if anything goes wrong.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
ImgBmapPostscript(clientData, interp, tkwin, psinfo, x, y, width, height,
	prepass)
    ClientData clientData;
    Tcl_Interp *interp;
    Tk_Window tkwin;
    Tk_PostscriptInfo psinfo;
    int x, y, width, height, prepass;
{
    BitmapMaster *masterPtr = (BitmapMaster *) clientData;
    char buffer[200];

    if (prepass) {
	return TCL_OK;
    }

    /*
     * There is nothing to do for bitmaps with zero width or height
     */
    if( width<=0 || height<=0 || masterPtr->width<=0 || masterPtr->height<=0 ){
	return TCL_OK;
    }

    /*
     * Translate the origin of the coordinate system to be the lower-left
     * corner of the bitmap and adjust the scale of the coordinate system
     * so that entire bitmap covers one square unit of the page.
     * The calling function put a "gsave" into the postscript and
     * will add a "grestore" at after this routine returns, so it is safe
     * to make whatever changes are necessary here.
     */
    if( x!=0 || y!=0 ){
	sprintf(buffer, "%d %d moveto\n", x, y);
	Tcl_AppendResult(interp, buffer, 0);
    }
    if( width!=1 || height!=1 ){
	sprintf(buffer, "%d %d scale\n", width, height);
 	Tcl_AppendResult(interp, buffer, 0);
    }

    /*
     * Color the background, if there is one.  This step is skipped if the
     * background is transparent.  If the background is not transparent and
     * there is no background mask, then color the complete rectangle that
     * encloses the bitmap.  If there is a background mask, then only apply
     * color to the bits specified by the mask.
     */
    if ((masterPtr->bgUid != NULL) && (masterPtr->bgUid[0] != '\000')) {
	XColor color;
	XParseColor(Tk_Display(tkwin), Tk_Colormap(tkwin), masterPtr->bgUid,
		&color);
	if (Tk_PostscriptColor(interp, psinfo, &color) != TCL_OK) {
	    return TCL_ERROR;
	}
	if (masterPtr->maskData == NULL) {
	    Tcl_AppendResult(interp,
		"0 0 moveto 1 0 rlineto 0 1 rlineto -1 0 rlineto "
		"closepath fill\n", 0
	    );
	} else if (ImgBmapPsImagemask(interp, masterPtr->width,
		     masterPtr->height, masterPtr->maskData) != TCL_OK) {
	    return TCL_ERROR;
	}
    }

    /*
     * Draw the bitmap foreground, assuming there is one.
     */
    if ( (masterPtr->fgUid != NULL) && (masterPtr->data != NULL) ) {
	XColor color;
	XParseColor(Tk_Display(tkwin), Tk_Colormap(tkwin), masterPtr->fgUid,
		&color);
	if (Tk_PostscriptColor(interp, psinfo, &color) != TCL_OK) {
	    return TCL_ERROR;
	}
	if (ImgBmapPsImagemask(interp, masterPtr->width, masterPtr->height,
		masterPtr->data) != TCL_OK) {
	    return TCL_ERROR;
	}
    }
    return TCL_OK;
}
@


1.4
log
@touched all sources to ease next import
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tkImgBmap.c,v 1.7.6.2 2000/09/11 14:55:41 spolk Exp $
a216 1

d257 1
a257 1
    char **argv = (char **) ckalloc((objc+1) * sizeof(char *));
d501 2
a502 1
    char *p, *end, *expandedFileName;
d765 1
a765 1
    static char *bmapOptions[] = {"cget", "configure", (char *) NULL};
d1109 92
d1203 1
a1203 2
 *	This procedure is called by the image code to create
 *	postscript output for an image.
d1206 3
a1208 1
 *	None.
a1225 2
    int rowsAtOnce, rowsThisTime;
    int curRow, yy;
d1231 8
d1240 6
a1245 1
     * Color the background, if there is one.
d1247 8
d1256 8
a1263 1
    if (masterPtr->bgUid != NULL) {
a1266 4
	sprintf(buffer,
		"%d %d moveto %d 0 rlineto 0 %d rlineto %d %s\n",
		x, y, width, height, -width,"0 rlineto closepath");
	Tcl_AppendResult(interp, buffer, (char *) NULL);
d1270 9
a1278 1
	Tcl_AppendResult(interp, "fill\n", (char *) NULL);
d1282 1
a1282 4
     * Draw the bitmap, if there is a foreground color.  If the bitmap
     * is very large, then chop it up into multiple bitmaps, each
     * consisting of one or more rows.  This is needed because Postscript
     * can't handle single strings longer than 64 KBytes long.
d1284 1
a1284 2

    if (masterPtr->fgUid != NULL) {
d1291 2
a1292 5
	if (width > 60000) {
	    Tcl_ResetResult(interp);
	    Tcl_AppendResult(interp, "can't generate Postscript",
		    " for bitmaps more than 60000 pixels wide",
		    (char *) NULL);
a1294 22
	rowsAtOnce = 60000/width;
	if (rowsAtOnce < 1) {
	    rowsAtOnce = 1;
	}
	sprintf(buffer, "%d %d translate\n", x, y);
	Tcl_AppendResult(interp, buffer, (char *) NULL);
	for (curRow = y+height-1; curRow >= y; curRow -= rowsAtOnce) {
	    rowsThisTime = rowsAtOnce;
	    if (rowsThisTime > (curRow + 1 - y)) {
		rowsThisTime = curRow + 1 - y;
	    }
	    sprintf(buffer, "%d %d", width, rowsThisTime);
	    Tcl_AppendResult(interp, buffer, " true matrix {\n<",
		    (char *) NULL);
	    for (yy = curRow; yy >= (curRow - rowsThisTime + 1); yy--) {
		sprintf(buffer, "row %d\n", yy);
		Tcl_AppendResult(interp, buffer, (char *) NULL);
	    }
	    sprintf(buffer, "0 %.15g", (double) rowsThisTime);
	    Tcl_AppendResult(interp, ">\n} imagemask\n", buffer,
		    " translate\n", (char *) NULL);
	}
a1297 1

@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d8 1
d13 1
a13 1
 * RCS: @@(#) $Id: tkImgBmap.c,v 1.12 1999/01/26 04:11:23 jingham Exp $
d95 4
d107 1
d158 1
a158 1
			    Tcl_Interp *interp, int argc, char **argv));
d164 1
a164 1
			    BitmapMaster *masterPtr, int argc, char **argv,
d187 1
a187 1
ImgBmapCreate(interp, name, argc, objv, typePtr, master, clientDataPtr)
d192 1
a192 1
    Tcl_Obj *CONST objv[];	/* Argument objects for options (doesn't
a200 2
    char **argv;
    int i;
d205 1
a205 1
    masterPtr->imageCmd = Tcl_CreateCommand(interp, name, ImgBmapCmd,
a217 8
    /*
     * Convert the objv arguments into string equivalent.
     * A proper conversion to object format will need to be done in the future
     */
    argv = (char **) ckalloc(argc * sizeof(char *));
    for (i = 0; i < argc; i++) {
      argv[i] = Tcl_GetStringFromObj(objv[i], NULL);
    }
a219 1
	ckfree((char *) argv);
a221 1
    ckfree((char *) argv);
d237 1
a237 1
 *	an error message is left in masterPtr->interp->result.
d247 1
a247 1
ImgBmapConfigureMaster(masterPtr, argc, argv, flags)
d250 2
a251 2
    int argc;			/* Number of entries in argv. */
    char **argv;		/* Pairs of configuration options for image. */
d258 6
d265 1
a265 1
	    configSpecs, argc, argv, (char *) masterPtr, flags)
d267 1
d270 1
d296 2
a297 1
	    masterPtr->interp->result = "can't have mask without bitmap";
d310 2
a311 1
	    masterPtr->interp->result = "bitmap and mask have different sizes";
d360 1
d403 8
a410 4
    if (instancePtr->mask != None) {
	Tk_FreePixmap(Tk_Display(instancePtr->tkwin), instancePtr->mask);
	instancePtr->mask = None;
    }
d418 3
d437 1
a437 2
	gc = Tk_GetGCColor(instancePtr->tkwin, mask, &gcValues,
			   instancePtr->fg, instancePtr->bg);
d479 1
a479 1
 *	left in interp->result.
d529 9
d658 1
a658 1
	interp->result = "format error in bitmap data";
d660 1
d759 1
a759 1
ImgBmapCmd(clientData, interp, argc, argv)
d762 2
a763 2
    int argc;			/* Number of arguments. */
    char **argv;		/* Argument strings. */
d765 1
d767 1
a767 2
    int c, code;
    size_t length;
d769 2
a770 4
    if (argc < 2) {
	sprintf(interp->result,
		"wrong # args: should be \"%.50s option ?arg arg ...?\"",
		argv[0]);
d773 8
a780 8
    c = argv[1][0];
    length = strlen(argv[1]);
    if ((c == 'c') && (strncmp(argv[1], "cget", length) == 0)
	    && (length >= 2)) {
	if (argc != 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " cget option\"",
		    (char *) NULL);
d784 4
a787 4
		(char *) masterPtr, argv[2], 0);
    } else if ((c == 'c') && (strncmp(argv[1], "configure", length) == 0)
	    && (length >= 2)) {
	if (argc == 2) {
d790 1
a790 1
	} else if (argc == 3) {
d792 2
a793 1
		    configSpecs, (char *) masterPtr, argv[2], 0);
d795 1
a795 1
	    code = ImgBmapConfigureMaster(masterPtr, argc-2, argv+2,
d799 4
a802 4
    } else {
	Tcl_AppendResult(interp, "bad option \"", argv[1],
		"\": must be cget or configure", (char *) NULL);
	return TCL_ERROR;
d804 1
d1104 101
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@a7 1
 * Copyright (c) 1999 by Scriptics Corporation.
d12 1
a12 1
 * RCS: @@(#) $Id: tkImgBmap.c,v 1.7.6.2 2000/09/11 14:55:41 spolk Exp $
a93 4
static int		ImgBmapPostscript _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, Tk_Window tkwin,
			    Tk_PostscriptInfo psinfo, int x, int y,
			    int width, int height, int prepass));
a101 1
    ImgBmapPostscript,		/* postscriptProc */
d152 1
a152 1
			    Tcl_Interp *interp, int argc, Tcl_Obj *CONST objv[]));
d158 1
a158 1
			    BitmapMaster *masterPtr, int argc, Tcl_Obj *CONST objv[],
d181 1
a181 1
ImgBmapCreate(interp, name, argc, argv, typePtr, master, clientDataPtr)
d186 1
a186 1
    Tcl_Obj *CONST argv[];	/* Argument objects for options (doesn't
d195 2
d201 1
a201 1
    masterPtr->imageCmd = Tcl_CreateObjCommand(interp, name, ImgBmapCmd,
d214 8
d224 1
d227 1
d243 1
a243 1
 *	an error message is left in the masterPtr->interp's result.
d253 1
a253 1
ImgBmapConfigureMaster(masterPtr, objc, objv, flags)
d256 2
a257 2
    int objc;			/* Number of entries in objv. */
    Tcl_Obj *CONST objv[];	/* Pairs of configuration options for image. */
a263 6
    char **argv = (char **) ckalloc((objc+1) * sizeof(char *));
    for (dummy1 = 0; dummy1 < objc; dummy1++) {
	argv[dummy1]=Tcl_GetString(objv[dummy1]);
    }
    argv[objc] = NULL;

d265 1
a265 1
	    configSpecs, objc, argv, (char *) masterPtr, flags)
a266 1
	ckfree((char *) argv);
a268 1
    ckfree((char *) argv);
d294 1
a294 2
	    Tcl_SetResult(masterPtr->interp, "can't have mask without bitmap",
		    TCL_STATIC);
d307 1
a307 2
	    Tcl_SetResult(masterPtr->interp,
		    "bitmap and mask have different sizes", TCL_STATIC);
a355 1
    Pixmap oldMask;
d398 4
a401 8
    /*
     * Careful:  We have to allocate a new mask Pixmap before deleting
     * the old one.  Otherwise, The XID allocator will always return
     * the same XID for the new Pixmap as was used for the old Pixmap.
     * And that will prevent the mask from changing in the GC below.
     */
    oldMask = instancePtr->mask;
    instancePtr->mask = None;
a408 3
    if (oldMask != None) {
      Tk_FreePixmap(Tk_Display(instancePtr->tkwin), oldMask);
    }
d425 2
a426 1
	gc = Tk_GetGC(instancePtr->tkwin, mask, &gcValues);
d468 1
a468 1
 *	left in the interp's result.
a517 9
	
        if (Tcl_SetChannelOption(interp, pi.chan, "-translation", "binary")
		!= TCL_OK) {
            return NULL;
        }
        if (Tcl_SetChannelOption(interp, pi.chan, "-encoding", "binary")
		!= TCL_OK) {
            return NULL;
        }
d638 1
a638 1
	Tcl_SetResult(interp, "format error in bitmap data", TCL_STATIC);
a639 1
    
d738 1
a738 1
ImgBmapCmd(clientData, interp, objc, objv)
d741 2
a742 2
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
a743 1
    static char *bmapOptions[] = {"cget", "configure", (char *) NULL};
d745 2
a746 1
    int code, index;
d748 4
a751 2
    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "option ?arg arg ...?");
d754 8
a761 8
    if (Tcl_GetIndexFromObj(interp, objv[1], bmapOptions, "option", 0,
	    &index) != TCL_OK) {
	return TCL_ERROR;
    }
    switch (index) {
      case 0: {
	if (objc != 3) {
	    Tcl_WrongNumArgs(interp, 2, objv, "option");
d765 4
a768 4
		(char *) masterPtr, Tcl_GetString(objv[2]), 0);
      }
      case 1: {
	if (objc == 2) {
d771 1
a771 1
	} else if (objc == 3) {
d773 1
a773 2
		    configSpecs, (char *) masterPtr,
		    Tcl_GetString(objv[2]), 0);
d775 1
a775 1
	    code = ImgBmapConfigureMaster(masterPtr, objc-2, objv+2,
d779 4
a782 4
      }
      default: {
	panic("bad const entries to bmapOptions in ImgBmapCmd");
      }
a783 1
    return TCL_OK;
a1082 101


/*
 *----------------------------------------------------------------------
 *
 * ImgBmapPostscript --
 *
 *	This procedure is called by the image code to create
 *	postscript output for an image.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
ImgBmapPostscript(clientData, interp, tkwin, psinfo, x, y, width, height,
	prepass)
    ClientData clientData;
    Tcl_Interp *interp;
    Tk_Window tkwin;
    Tk_PostscriptInfo psinfo;
    int x, y, width, height, prepass;
{
    BitmapMaster *masterPtr = (BitmapMaster *) clientData;
    int rowsAtOnce, rowsThisTime;
    int curRow, yy;
    char buffer[200];

    if (prepass) {
	return TCL_OK;
    }
    /*
     * Color the background, if there is one.
     */

    if (masterPtr->bgUid != NULL) {
	XColor color;
	XParseColor(Tk_Display(tkwin), Tk_Colormap(tkwin), masterPtr->bgUid,
		&color);
	sprintf(buffer,
		"%d %d moveto %d 0 rlineto 0 %d rlineto %d %s\n",
		x, y, width, height, -width,"0 rlineto closepath");
	Tcl_AppendResult(interp, buffer, (char *) NULL);
	if (Tk_PostscriptColor(interp, psinfo, &color) != TCL_OK) {
	    return TCL_ERROR;
	}
	Tcl_AppendResult(interp, "fill\n", (char *) NULL);
    }

    /*
     * Draw the bitmap, if there is a foreground color.  If the bitmap
     * is very large, then chop it up into multiple bitmaps, each
     * consisting of one or more rows.  This is needed because Postscript
     * can't handle single strings longer than 64 KBytes long.
     */

    if (masterPtr->fgUid != NULL) {
	XColor color;
	XParseColor(Tk_Display(tkwin), Tk_Colormap(tkwin), masterPtr->fgUid,
		&color);
	if (Tk_PostscriptColor(interp, psinfo, &color) != TCL_OK) {
	    return TCL_ERROR;
	}
	if (width > 60000) {
	    Tcl_ResetResult(interp);
	    Tcl_AppendResult(interp, "can't generate Postscript",
		    " for bitmaps more than 60000 pixels wide",
		    (char *) NULL);
	    return TCL_ERROR;
	}
	rowsAtOnce = 60000/width;
	if (rowsAtOnce < 1) {
	    rowsAtOnce = 1;
	}
	sprintf(buffer, "%d %d translate\n", x, y);
	Tcl_AppendResult(interp, buffer, (char *) NULL);
	for (curRow = y+height-1; curRow >= y; curRow -= rowsAtOnce) {
	    rowsThisTime = rowsAtOnce;
	    if (rowsThisTime > (curRow + 1 - y)) {
		rowsThisTime = curRow + 1 - y;
	    }
	    sprintf(buffer, "%d %d", width, rowsThisTime);
	    Tcl_AppendResult(interp, buffer, " true matrix {\n<",
		    (char *) NULL);
	    for (yy = curRow; yy >= (curRow - rowsThisTime + 1); yy--) {
		sprintf(buffer, "row %d\n", yy);
		Tcl_AppendResult(interp, buffer, (char *) NULL);
	    }
	    sprintf(buffer, "0 %.15g", (double) rowsThisTime);
	    Tcl_AppendResult(interp, ">\n} imagemask\n", buffer,
		    " translate\n", (char *) NULL);
	}
    }
    return TCL_OK;
}

@


1.1.1.3
log
@import tk 8.4.0
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tkImgBmap.c,v 1.15 2002/08/05 04:30:39 dgp Exp $
d217 1
d258 1
a258 1
    CONST char **argv = (CONST char **) ckalloc((objc+1) * sizeof(char *));
d502 1
a502 2
    CONST char *expandedFileName;
    char *p, *end;
d765 1
a765 1
    static CONST char *bmapOptions[] = {"cget", "configure", (char *) NULL};
a1108 92
 * ImgBmapPsImagemask --
 *
 *	This procedure generates postscript suitable for rendering a
 *      single bitmap of an image.  A single bitmap image might contain both
 *      a foreground and a background bitmap.  This routine is called once
 *      for each such bitmap in a bitmap image.
 *
 *      Prior to invoking this routine, the following setup has occurred:
 *
 *	   1.  The postscript foreground color has been set to the color
 *	       used to render the bitmap.
 *
 *	   2.  The origin of the postscript coordinate system is set to
 *             the lower left corner of the bitmap.
 *
 *	   3.  The postscript coordinate system has been scaled so that
 *	       the entire bitmap is one unit squared.
 *
 * 	Some postscript implementations cannot handle bitmap strings
 *	longer than about 60k characters.  If the bitmap data is that big
 *	or bigger, then we render it by splitting it into several smaller
 *	bitmaps.
 *
 * Results:
 *	Returns TCL_OK on success.  Returns TCL_ERROR and leaves and error
 *	message in interp->result if there is a problem.
 *
 * Side effects:
 *	Postscript code is appended to interp->result.
 *
 *----------------------------------------------------------------------
 */

static int
ImgBmapPsImagemask(interp, width, height, data)
    Tcl_Interp *interp;       /* Append postscript to this interpreter */
    int width, height;        /* Width and height of the bitmap in pixels */
    char *data;               /* Data for the bitmap */
{
    int i, j, nBytePerRow;
    char buffer[200];

    /* 
     * The bit order of bitmaps in Tk is the opposite of the bit order that
     * postscript uses.  (In Tk, the least significant bit is on the right
     * side of the bitmap and in postscript the least significant bit is shown
     * on the left.)  The following array is used to reverse the order of bits
     * within a byte so that the bits will be in the order postscript expects.
     */
    static unsigned char bit_reverse[] = {
       0, 128, 64, 192, 32, 160,  96, 224, 16, 144, 80, 208, 48, 176, 112, 240,
       8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248,
       4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244,
      12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252,
       2, 130, 66, 194, 34, 162,  98, 226, 18, 146, 82, 210, 50, 178, 114, 242,
      10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250,
       6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246,
      14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254,
       1, 129, 65, 193, 33, 161,  97, 225, 17, 145, 81, 209, 49, 177, 113, 241,
       9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249,
       5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245,
      13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253,
       3, 131, 67, 195, 35, 163,  99, 227, 19, 147, 83, 211, 51, 179, 115, 243,
      11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251,
       7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247,
      15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255,
    };

    if (width*height > 60000) {
	Tcl_ResetResult(interp);
	Tcl_AppendResult(interp, "unable to generate postscript for bitmaps "
		"larger than 60000 pixels", 0);
	return TCL_ERROR;
    }
    sprintf(buffer, "0 0 moveto %d %d true [%d 0 0 %d 0 %d] {<\n",
      width, height, width, -height, height);
    Tcl_AppendResult(interp, buffer, 0);
    nBytePerRow = (width+7)/8;
    for(i=0; i<height; i++){
      for(j=0; j<nBytePerRow; j++){
        sprintf(buffer, " %02x", bit_reverse[0xff & data[i*nBytePerRow + j]]);
        Tcl_AppendResult(interp, buffer, 0);
      }
      Tcl_AppendResult(interp, "\n", 0);
    }
    Tcl_AppendResult(interp, ">} imagemask \n", 0);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
d1111 2
a1112 1
 *	This procedure generates postscript for rendering a bitmap image.
d1115 1
a1115 3
 *	On success, this routine writes postscript code into interp->result
 *      and returns TCL_OK  TCL_ERROR is returned and an error
 *      message is left in interp->result if anything goes wrong.
d1133 2
a1139 8

    /*
     * There is nothing to do for bitmaps with zero width or height
     */
    if( width<=0 || height<=0 || masterPtr->width<=0 || masterPtr->height<=0 ){
	return TCL_OK;
    }

d1141 1
a1141 6
     * Translate the origin of the coordinate system to be the lower-left
     * corner of the bitmap and adjust the scale of the coordinate system
     * so that entire bitmap covers one square unit of the page.
     * The calling function put a "gsave" into the postscript and
     * will add a "grestore" at after this routine returns, so it is safe
     * to make whatever changes are necessary here.
a1142 8
    if( x!=0 || y!=0 ){
	sprintf(buffer, "%d %d moveto\n", x, y);
	Tcl_AppendResult(interp, buffer, 0);
    }
    if( width!=1 || height!=1 ){
	sprintf(buffer, "%d %d scale\n", width, height);
 	Tcl_AppendResult(interp, buffer, 0);
    }
d1144 1
a1144 8
    /*
     * Color the background, if there is one.  This step is skipped if the
     * background is transparent.  If the background is not transparent and
     * there is no background mask, then color the complete rectangle that
     * encloses the bitmap.  If there is a background mask, then only apply
     * color to the bits specified by the mask.
     */
    if ((masterPtr->bgUid != NULL) && (masterPtr->bgUid[0] != '\000')) {
d1148 4
d1155 1
a1155 9
	if (masterPtr->maskData == NULL) {
	    Tcl_AppendResult(interp,
		"0 0 moveto 1 0 rlineto 0 1 rlineto -1 0 rlineto "
		"closepath fill\n", 0
	    );
	} else if (ImgBmapPsImagemask(interp, masterPtr->width,
		     masterPtr->height, masterPtr->maskData) != TCL_OK) {
	    return TCL_ERROR;
	}
d1159 4
a1162 1
     * Draw the bitmap foreground, assuming there is one.
d1164 2
a1165 1
    if ( (masterPtr->fgUid != NULL) && (masterPtr->data != NULL) ) {
d1172 5
a1176 2
	if (ImgBmapPsImagemask(interp, masterPtr->width, masterPtr->height,
		masterPtr->data) != TCL_OK) {
d1179 22
d1204 1
@


