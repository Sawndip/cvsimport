head	1.6;
access;
symbols
	sid-snapshot-20180601:1.6
	sid-snapshot-20180501:1.6
	sid-snapshot-20180401:1.6
	sid-snapshot-20180301:1.6
	sid-snapshot-20180201:1.6
	sid-snapshot-20180101:1.6
	sid-snapshot-20171201:1.6
	sid-snapshot-20171101:1.6
	sid-snapshot-20171001:1.6
	sid-snapshot-20170901:1.6
	sid-snapshot-20170801:1.6
	sid-snapshot-20170701:1.6
	sid-snapshot-20170601:1.6
	sid-snapshot-20170501:1.6
	sid-snapshot-20170401:1.6
	sid-snapshot-20170301:1.6
	sid-snapshot-20170201:1.6
	sid-snapshot-20170101:1.6
	sid-snapshot-20161201:1.6
	sid-snapshot-20161101:1.6
	sid-snapshot-20160901:1.6
	sid-snapshot-20160801:1.6
	sid-snapshot-20160701:1.6
	sid-snapshot-20160601:1.6
	sid-snapshot-20160501:1.6
	sid-snapshot-20160401:1.6
	sid-snapshot-20160301:1.6
	sid-snapshot-20160201:1.6
	sid-snapshot-20160101:1.6
	sid-snapshot-20151201:1.6
	sid-snapshot-20151101:1.6
	sid-snapshot-20151001:1.6
	sid-snapshot-20150901:1.6
	sid-snapshot-20150801:1.6
	sid-snapshot-20150701:1.6
	sid-snapshot-20150601:1.6
	sid-snapshot-20150501:1.6
	sid-snapshot-20150401:1.6
	sid-snapshot-20150301:1.6
	sid-snapshot-20150201:1.6
	sid-snapshot-20150101:1.6
	sid-snapshot-20141201:1.6
	sid-snapshot-20141101:1.6
	sid-snapshot-20141001:1.6
	sid-snapshot-20140901:1.6
	sid-snapshot-20140801:1.6
	sid-snapshot-20140701:1.6
	sid-snapshot-20140601:1.6
	sid-snapshot-20140501:1.6
	sid-snapshot-20140401:1.6
	sid-snapshot-20140301:1.6
	sid-snapshot-20140201:1.6
	sid-snapshot-20140101:1.6
	sid-snapshot-20131201:1.6
	sid-snapshot-20131101:1.6
	sid-snapshot-20131001:1.6
	sid-snapshot-20130901:1.6
	sid-snapshot-20130801:1.6
	sid-snapshot-20130701:1.6
	sid-snapshot-20130601:1.6
	insight_7_6-2013-04-10-branchpoint:1.6
	gdb_7_6-branch:1.6.0.28
	sid-snapshot-20130501:1.6
	sid-snapshot-20130401:1.6
	sid-snapshot-20130301:1.6
	sid-snapshot-20130201:1.6
	sid-snapshot-20130101:1.6
	sid-snapshot-20121201:1.6
	sid-snapshot-20121101:1.6
	sid-snapshot-20121001:1.6
	sid-snapshot-20120901:1.6
	gdb_7_5-branch:1.6.0.26
	sid-snapshot-20120801:1.6
	sid-snapshot-20120701:1.6
	sid-snapshot-20120601:1.6
	sid-snapshot-20120501:1.6
	sid-snapshot-20120401:1.6
	gdb_7_4-branch:1.6.0.24
	sid-snapshot-20120301:1.6
	sid-snapshot-20120201:1.6
	sid-snapshot-20120101:1.6
	sid-snapshot-20111201:1.6
	sid-snapshot-20111101:1.6
	sid-snapshot-20111001:1.6
	sid-snapshot-20110901:1.6
	gdb_7_3-branch:1.6.0.22
	sid-snapshot-20110801:1.6
	sid-snapshot-20110701:1.6
	sid-snapshot-20110601:1.6
	sid-snapshot-20110501:1.6
	sid-snapshot-20110401:1.6
	sid-snapshot-20110301:1.6
	sid-snapshot-20110201:1.6
	sid-snapshot-20110101:1.6
	sid-snapshot-20101201:1.6
	sid-snapshot-20101101:1.6
	sid-snapshot-20101001:1.6
	sid-snapshot-20100901:1.6
	sid-snapshot-20100801:1.6
	sid-snapshot-20100701:1.6
	sid-snapshot-20100601:1.6
	sid-snapshot-20100501:1.6
	sid-snapshot-20100401:1.6
	sid-snapshot-20100301:1.6
	gdb_7_1-branch:1.6.0.20
	gdb_7_0-branch:1.6.0.18
	sid-snapshot-20100201:1.6
	sid-snapshot-20100101:1.6
	sid-snapshot-20091201:1.6
	sid-snapshot-20091101:1.6
	sid-snapshot-20091001:1.6
	arc-sim-20090309:1.6
	sid-snapshot-20090901:1.6
	sid-snapshot-20090801:1.6
	sid-snapshot-20090701:1.6
	sid-snapshot-20090601:1.6
	sid-snapshot-20090501:1.6
	kevinb-pre-tk8_5_7_merge:1.6
	sid-snapshot-20090401:1.6
	arc-insight_6_8-branch:1.6.0.16
	arc-insight_6_8-branchpoint:1.6
	insight_6_8-branch:1.6.0.14
	insight_6_8-branchpoint:1.6
	sid-snapshot-20090301:1.6
	sid-snapshot-20090201:1.6
	sid-snapshot-20090101:1.6
	sid-snapshot-20081201:1.6
	sid-snapshot-20081101:1.6
	sid-snapshot-20081001:1.6
	sid-snapshot-20080901:1.6
	sid-snapshot-20080801:1.6
	sid-snapshot-20080701:1.6
	sid-snapshot-20080601:1.6
	sid-snapshot-20080501:1.6
	sid-snapshot-20080403:1.6
	sid-snapshot-20080401:1.6
	gdb_6_8-branch:1.6.0.12
	sid-snapshot-20080301:1.6
	sid-snapshot-20080201:1.6
	sid-snapshot-20080101:1.6
	sid-snapshot-20071201:1.6
	sid-snapshot-20071101:1.6
	sid-snapshot-20071001:1.6
	insight_6_6-20070208-release:1.6
	gdb_6_6-branch:1.6.0.10
	gdb_6_6-2006-11-15-branchpoint:1.6
	insight_6_5-20061003-release:1.6
	gdb_6_5-branch:1.6.0.8
	gdb_6_5-2006-05-14-branchpoint:1.6
	gdb_6_4-branch:1.6.0.6
	gdb_6_4-2005-11-01-branchpoint:1.6
	gdb_6_1-2004-04-05-release:1.6
	gdb_6_1-branch:1.6.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	gdb_6_0-2003-10-04-release:1.6
	gdb_6_0-branch:1.6.0.2
	gdb_6_0-2003-06-23-branchpoint:1.6
	TK8_4_1:1.1.1.4
	gdb_5_3-2002-12-12-release:1.3
	tcltk840-20020924-branch:1.4.0.2
	tcltk840-20020924-branchpoint:1.4
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.3
	sid-20020905-branch:1.3.0.4
	gdb_5_3-branch:1.3.0.2
	gdb_5_3-2002-09-04-branchpoint:1.3
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.6
date	2003.01.21.20.24.45;	author hunt;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.21.19.53.13;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.24.18.39.25;	author kseitz;	state Exp;
branches;
next	1.3;

1.3
date	2002.08.01.01.33.47;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.51;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.33;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.20;	author kseitz;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.01.21.19.54.05;	author hunt;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Updated to tk 8.4.1
@
text
@/* 
 * tkText.c --
 *
 *	This module provides a big chunk of the implementation of
 *	multi-line editable text widgets for Tk.  Among other things,
 *	it provides the Tcl command interfaces to text widgets and
 *	the display code.  The B-tree representation of text is
 *	implemented elsewhere.
 *
 * Copyright (c) 1992-1994 The Regents of the University of California.
 * Copyright (c) 1994-1996 Sun Microsystems, Inc.
 * Copyright (c) 1999 by Scriptics Corporation.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkText.c,v 1.32 2002/10/02 21:23:10 hobbs Exp $
 */

#include "default.h"
#include "tkPort.h"
#include "tkInt.h"
#include "tkUndo.h"

#if defined(MAC_TCL) || defined(MAC_OSX_TK)
#define Style TkStyle
#define DInfo TkDInfo
#endif

#include "tkText.h"

/*
 * Custom options for handling "-state"
 */

static Tk_CustomOption stateOption = {
    (Tk_OptionParseProc *) TkStateParseProc,
    TkStatePrintProc, (ClientData) NULL /* only "normal" and "disabled" */
};

/*
 * Information used to parse text configuration options:
 */

static Tk_ConfigSpec configSpecs[] = {
    {TK_CONFIG_BOOLEAN, "-autoseparators", "autoSeparators",
        "AutoSeparators", DEF_TEXT_AUTO_SEPARATORS,
        Tk_Offset(TkText, autoSeparators), 0},
    {TK_CONFIG_BORDER, "-background", "background", "Background",
	DEF_TEXT_BG_COLOR, Tk_Offset(TkText, border), TK_CONFIG_COLOR_ONLY},
    {TK_CONFIG_BORDER, "-background", "background", "Background",
	DEF_TEXT_BG_MONO, Tk_Offset(TkText, border), TK_CONFIG_MONO_ONLY},
    {TK_CONFIG_SYNONYM, "-bd", "borderWidth", (char *) NULL,
	(char *) NULL, 0, 0},
    {TK_CONFIG_SYNONYM, "-bg", "background", (char *) NULL,
	(char *) NULL, 0, 0},
    {TK_CONFIG_PIXELS, "-borderwidth", "borderWidth", "BorderWidth",
	DEF_TEXT_BORDER_WIDTH, Tk_Offset(TkText, borderWidth), 0},
    {TK_CONFIG_ACTIVE_CURSOR, "-cursor", "cursor", "Cursor",
	DEF_TEXT_CURSOR, Tk_Offset(TkText, cursor), TK_CONFIG_NULL_OK},
    {TK_CONFIG_BOOLEAN, "-exportselection", "exportSelection",
	"ExportSelection", DEF_TEXT_EXPORT_SELECTION,
	Tk_Offset(TkText, exportSelection), 0},
    {TK_CONFIG_SYNONYM, "-fg", "foreground", (char *) NULL,
	(char *) NULL, 0, 0},
    {TK_CONFIG_FONT, "-font", "font", "Font",
	DEF_TEXT_FONT, Tk_Offset(TkText, tkfont), 0},
    {TK_CONFIG_COLOR, "-foreground", "foreground", "Foreground",
	DEF_TEXT_FG, Tk_Offset(TkText, fgColor), 0},
    {TK_CONFIG_PIXELS, "-height", "height", "Height",
	DEF_TEXT_HEIGHT, Tk_Offset(TkText, height), 0},
    {TK_CONFIG_COLOR, "-highlightbackground", "highlightBackground",
	"HighlightBackground", DEF_TEXT_HIGHLIGHT_BG,
	Tk_Offset(TkText, highlightBgColorPtr), 0},
    {TK_CONFIG_COLOR, "-highlightcolor", "highlightColor", "HighlightColor",
	DEF_TEXT_HIGHLIGHT, Tk_Offset(TkText, highlightColorPtr), 0},
    {TK_CONFIG_PIXELS, "-highlightthickness", "highlightThickness",
	"HighlightThickness",
	DEF_TEXT_HIGHLIGHT_WIDTH, Tk_Offset(TkText, highlightWidth), 0},
    {TK_CONFIG_BORDER, "-insertbackground", "insertBackground", "Foreground",
	DEF_TEXT_INSERT_BG, Tk_Offset(TkText, insertBorder), 0},
    {TK_CONFIG_PIXELS, "-insertborderwidth", "insertBorderWidth", "BorderWidth",
	DEF_TEXT_INSERT_BD_COLOR, Tk_Offset(TkText, insertBorderWidth),
	TK_CONFIG_COLOR_ONLY},
    {TK_CONFIG_PIXELS, "-insertborderwidth", "insertBorderWidth", "BorderWidth",
	DEF_TEXT_INSERT_BD_MONO, Tk_Offset(TkText, insertBorderWidth),
	TK_CONFIG_MONO_ONLY},
    {TK_CONFIG_INT, "-insertofftime", "insertOffTime", "OffTime",
	DEF_TEXT_INSERT_OFF_TIME, Tk_Offset(TkText, insertOffTime), 0},
    {TK_CONFIG_INT, "-insertontime", "insertOnTime", "OnTime",
	DEF_TEXT_INSERT_ON_TIME, Tk_Offset(TkText, insertOnTime), 0},
    {TK_CONFIG_PIXELS, "-insertwidth", "insertWidth", "InsertWidth",
	DEF_TEXT_INSERT_WIDTH, Tk_Offset(TkText, insertWidth), 0},
    {TK_CONFIG_INT, "-maxundo", "maxUndo", "MaxUndo",
	DEF_TEXT_MAX_UNDO, Tk_Offset(TkText, maxUndo), 0},
    {TK_CONFIG_PIXELS, "-padx", "padX", "Pad",
	DEF_TEXT_PADX, Tk_Offset(TkText, padX), 0},
    {TK_CONFIG_PIXELS, "-pady", "padY", "Pad",
	DEF_TEXT_PADY, Tk_Offset(TkText, padY), 0},
    {TK_CONFIG_RELIEF, "-relief", "relief", "Relief",
	DEF_TEXT_RELIEF, Tk_Offset(TkText, relief), 0},
    {TK_CONFIG_BORDER, "-selectbackground", "selectBackground", "Foreground",
	DEF_TEXT_SELECT_COLOR, Tk_Offset(TkText, selBorder),
	TK_CONFIG_COLOR_ONLY},
    {TK_CONFIG_BORDER, "-selectbackground", "selectBackground", "Foreground",
	DEF_TEXT_SELECT_MONO, Tk_Offset(TkText, selBorder),
	TK_CONFIG_MONO_ONLY},
    {TK_CONFIG_STRING, "-selectborderwidth", "selectBorderWidth", "BorderWidth",
	DEF_TEXT_SELECT_BD_COLOR, Tk_Offset(TkText, selBdString),
	TK_CONFIG_COLOR_ONLY|TK_CONFIG_NULL_OK},
    {TK_CONFIG_STRING, "-selectborderwidth", "selectBorderWidth", "BorderWidth",
	DEF_TEXT_SELECT_BD_MONO, Tk_Offset(TkText, selBdString),
	TK_CONFIG_MONO_ONLY|TK_CONFIG_NULL_OK},
    {TK_CONFIG_COLOR, "-selectforeground", "selectForeground", "Background",
	DEF_TEXT_SELECT_FG_COLOR, Tk_Offset(TkText, selFgColorPtr),
	TK_CONFIG_COLOR_ONLY},
    {TK_CONFIG_COLOR, "-selectforeground", "selectForeground", "Background",
	DEF_TEXT_SELECT_FG_MONO, Tk_Offset(TkText, selFgColorPtr),
	TK_CONFIG_MONO_ONLY},
    {TK_CONFIG_BOOLEAN, "-setgrid", "setGrid", "SetGrid",
	DEF_TEXT_SET_GRID, Tk_Offset(TkText, setGrid), 0},
    {TK_CONFIG_PIXELS, "-spacing1", "spacing1", "Spacing",
	DEF_TEXT_SPACING1, Tk_Offset(TkText, spacing1),
	TK_CONFIG_DONT_SET_DEFAULT},
    {TK_CONFIG_PIXELS, "-spacing2", "spacing2", "Spacing",
	DEF_TEXT_SPACING2, Tk_Offset(TkText, spacing2),
	TK_CONFIG_DONT_SET_DEFAULT},
    {TK_CONFIG_PIXELS, "-spacing3", "spacing3", "Spacing",
	DEF_TEXT_SPACING3, Tk_Offset(TkText, spacing3),
	TK_CONFIG_DONT_SET_DEFAULT},
    {TK_CONFIG_CUSTOM, "-state", "state", "State",
	DEF_TEXT_STATE, Tk_Offset(TkText, state), 0, &stateOption},
    {TK_CONFIG_STRING, "-tabs", "tabs", "Tabs",
	DEF_TEXT_TABS, Tk_Offset(TkText, tabOptionString), TK_CONFIG_NULL_OK},
    {TK_CONFIG_STRING, "-takefocus", "takeFocus", "TakeFocus",
	DEF_TEXT_TAKE_FOCUS, Tk_Offset(TkText, takeFocus),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_BOOLEAN, "-undo", "undo", "Undo",
        DEF_TEXT_UNDO, Tk_Offset(TkText, undo), 0},
    {TK_CONFIG_INT, "-width", "width", "Width",
	DEF_TEXT_WIDTH, Tk_Offset(TkText, width), 0},
    {TK_CONFIG_CUSTOM, "-wrap", "wrap", "Wrap",
	DEF_TEXT_WRAP, Tk_Offset(TkText, wrapMode), 0, &textWrapModeOption},
    {TK_CONFIG_STRING, "-xscrollcommand", "xScrollCommand", "ScrollCommand",
	DEF_TEXT_XSCROLL_COMMAND, Tk_Offset(TkText, xScrollCmd),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_STRING, "-yscrollcommand", "yScrollCommand", "ScrollCommand",
	DEF_TEXT_YSCROLL_COMMAND, Tk_Offset(TkText, yScrollCmd),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_END, (char *) NULL, (char *) NULL, (char *) NULL,
	(char *) NULL, 0, 0}
};

/*
 * Boolean variable indicating whether or not special debugging code
 * should be executed.
 */

int tkTextDebug = 0;

/*
 * Custom options for handling "-wrap":
 */

static int		WrapModeParseProc _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, Tk_Window tkwin,
			    CONST char *value, char *widgRec, int offset));
static char *		WrapModePrintProc _ANSI_ARGS_((ClientData clientData,
			    Tk_Window tkwin, char *widgRec, int offset,
			    Tcl_FreeProc **freeProcPtr));

Tk_CustomOption textWrapModeOption = {
    WrapModeParseProc,
    WrapModePrintProc,
    (ClientData) NULL
};

/*
 *--------------------------------------------------------------
 *
 * WrapModeParseProc --
 *
 *	This procedure is invoked during option processing to handle
 *	"-wrap" options for text widgets.
 *
 * Results:
 *	A standard Tcl return value.
 *
 * Side effects:
 *	The wrap mode for a given item gets replaced by the wrap mode
 *	indicated in the value argument.
 *
 *--------------------------------------------------------------
 */

static int
WrapModeParseProc(clientData, interp, tkwin, value, widgRec, offset)
    ClientData clientData;		/* some flags.*/
    Tcl_Interp *interp;			/* Used for reporting errors. */
    Tk_Window tkwin;			/* Window containing canvas widget. */
    CONST char *value;			/* Value of option (list of tag
					 * names). */
    char *widgRec;			/* Pointer to record for item. */
    int offset;				/* Offset into item. */
{
    int c;
    size_t length;

    register TkWrapMode *wrapPtr = (TkWrapMode *) (widgRec + offset);

    if(value == NULL || *value == 0) {
	*wrapPtr = TEXT_WRAPMODE_NULL;
	return TCL_OK;
    }

    c = value[0];
    length = strlen(value);

    if ((c == 'c') && (strncmp(value, "char", length) == 0)) {
	*wrapPtr = TEXT_WRAPMODE_CHAR;
	return TCL_OK;
    }
    if ((c == 'n') && (strncmp(value, "none", length) == 0)) {
	*wrapPtr = TEXT_WRAPMODE_NONE;
	return TCL_OK;
    }
    if ((c == 'w') && (strncmp(value, "word", length) == 0)) {
	*wrapPtr = TEXT_WRAPMODE_WORD;
	return TCL_OK;
    }
    Tcl_AppendResult(interp, "bad wrap mode \"", value,
	    "\": must be char, none, or word",
	    (char *) NULL);
    *wrapPtr = TEXT_WRAPMODE_CHAR;
    return TCL_ERROR;
}

/*
 *--------------------------------------------------------------
 *
 * WrapModePrintProc --
 *
 *	This procedure is invoked by the Tk configuration code
 *	to produce a printable string for the "-wrap" configuration
 *	option for canvas items.
 *
 * Results:
 *	The return value is a string describing the state for
 *	the item referred to by "widgRec".  In addition, *freeProcPtr
 *	is filled in with the address of a procedure to call to free
 *	the result string when it's no longer needed (or NULL to
 *	indicate that the string doesn't need to be freed).
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

static char *
WrapModePrintProc(clientData, tkwin, widgRec, offset, freeProcPtr)
    ClientData clientData;		/* Ignored. */
    Tk_Window tkwin;			/* Window containing canvas widget. */
    char *widgRec;			/* Pointer to record for item. */
    int offset;				/* Ignored. */
    Tcl_FreeProc **freeProcPtr;		/* Pointer to variable to fill in with
					 * information about how to reclaim
					 * storage for return string. */
{
    register TkWrapMode *wrapPtr = (TkWrapMode *) (widgRec + offset);

    if (*wrapPtr==TEXT_WRAPMODE_CHAR) {
	return "char";
    } else if (*wrapPtr==TEXT_WRAPMODE_NONE) {
	return "none";
    } else if (*wrapPtr==TEXT_WRAPMODE_WORD) {
	return "word";
    } else {
	return "";
    }
}

/*
 * Forward declarations for procedures defined later in this file:
 */

static int		ConfigureText _ANSI_ARGS_((Tcl_Interp *interp,
			    TkText *textPtr, int argc, CONST char **argv,
			    int flags));
static int		DeleteChars _ANSI_ARGS_((TkText *textPtr,
			    CONST char *index1String, CONST char *index2String,
			    TkTextIndex *indexPtr1, TkTextIndex *indexPtr2));
static void		DestroyText _ANSI_ARGS_((char *memPtr));
static void		InsertChars _ANSI_ARGS_((TkText *textPtr,
			    TkTextIndex *indexPtr, CONST char *string));
static void		TextBlinkProc _ANSI_ARGS_((ClientData clientData));
static void		TextCmdDeletedProc _ANSI_ARGS_((
			    ClientData clientData));
static void		TextEventProc _ANSI_ARGS_((ClientData clientData,
			    XEvent *eventPtr));
static int		TextFetchSelection _ANSI_ARGS_((ClientData clientData,
			    int offset, char *buffer, int maxBytes));
static int		TextIndexSortProc _ANSI_ARGS_((CONST VOID *first,
			    CONST VOID *second));
static int		TextSearchCmd _ANSI_ARGS_((TkText *textPtr,
			    Tcl_Interp *interp, int argc, CONST char **argv));
static int		TextEditCmd _ANSI_ARGS_((TkText *textPtr,
			    Tcl_Interp *interp, int argc, CONST char **argv));
static int		TextWidgetCmd _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, int argc, CONST char **argv));
static void		TextWorldChanged _ANSI_ARGS_((
			    ClientData instanceData));
static int		TextDumpCmd _ANSI_ARGS_((TkText *textPtr,
			    Tcl_Interp *interp, int argc, CONST char **argv));
static void		DumpLine _ANSI_ARGS_((Tcl_Interp *interp, 
			    TkText *textPtr, int what, TkTextLine *linePtr,
			    int start, int end, int lineno,
			    CONST char *command));
static int		DumpSegment _ANSI_ARGS_((Tcl_Interp *interp, char *key,
			    char *value, CONST char * command,
			    TkTextIndex *index, int what));
static int		TextEditUndo _ANSI_ARGS_((TkText *textPtr));
static int		TextEditRedo _ANSI_ARGS_((TkText *textPtr));
static void		TextGetText _ANSI_ARGS_((TkTextIndex * index1,
			    TkTextIndex * index2, Tcl_DString *dsPtr));
static void		updateDirtyFlag _ANSI_ARGS_((TkText *textPtr));

/*
 * The structure below defines text class behavior by means of procedures
 * that can be invoked from generic window code.
 */

static Tk_ClassProcs textClass = {
    sizeof(Tk_ClassProcs),	/* size */
    TextWorldChanged,		/* worldChangedProc */
};


/*
 *--------------------------------------------------------------
 *
 * Tk_TextCmd --
 *
 *	This procedure is invoked to process the "text" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *--------------------------------------------------------------
 */

int
Tk_TextCmd(clientData, interp, argc, argv)
    ClientData clientData;	/* Main window associated with
				 * interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int argc;			/* Number of arguments. */
    CONST char **argv;		/* Argument strings. */
{
    Tk_Window tkwin = (Tk_Window) clientData;
    Tk_Window new;
    register TkText *textPtr;
    TkTextIndex startIndex;

    if (argc < 2) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
		argv[0], " pathName ?options?\"", (char *) NULL);
	return TCL_ERROR;
    }

    /*
     * Create the window.
     */

    new = Tk_CreateWindowFromPath(interp, tkwin, argv[1], (char *) NULL);
    if (new == NULL) {
	return TCL_ERROR;
    }

    /*
     * Create the text widget and initialize everything to zero,
     * then set the necessary initial (non-NULL) values.
     */

    textPtr = (TkText *) ckalloc(sizeof(TkText));
    memset((VOID *) textPtr, 0, sizeof(TkText));

    textPtr->tkwin = new;
    textPtr->display = Tk_Display(new);
    textPtr->interp = interp;
    textPtr->widgetCmd = Tcl_CreateCommand(interp,
	    Tk_PathName(textPtr->tkwin), TextWidgetCmd,
	    (ClientData) textPtr, TextCmdDeletedProc);
    textPtr->tree = TkBTreeCreate(textPtr);
    Tcl_InitHashTable(&textPtr->tagTable, TCL_STRING_KEYS);
    Tcl_InitHashTable(&textPtr->markTable, TCL_STRING_KEYS);
    Tcl_InitHashTable(&textPtr->windowTable, TCL_STRING_KEYS);
    Tcl_InitHashTable(&textPtr->imageTable, TCL_STRING_KEYS);
    textPtr->state = TK_STATE_NORMAL;
    textPtr->relief = TK_RELIEF_FLAT;
    textPtr->cursor = None;
    textPtr->charWidth = 1;
    textPtr->wrapMode = TEXT_WRAPMODE_CHAR;
    textPtr->prevWidth = Tk_Width(new);
    textPtr->prevHeight = Tk_Height(new);
    TkTextCreateDInfo(textPtr);
    TkTextMakeByteIndex(textPtr->tree, 0, 0, &startIndex);
    TkTextSetYView(textPtr, &startIndex, 0);
    textPtr->exportSelection = 1;
    textPtr->pickEvent.type = LeaveNotify;
    textPtr->undoStack = TkUndoInitStack(interp,0);
    textPtr->undo = 1;
    textPtr->isDirtyIncrement = 1;
    textPtr->autoSeparators = 1;
    textPtr->lastEditMode = TK_TEXT_EDIT_OTHER;

    /*
     * Create the "sel" tag and the "current" and "insert" marks.
     */

    textPtr->selTagPtr = TkTextCreateTag(textPtr, "sel");
    textPtr->selTagPtr->reliefString =
	    (char *) ckalloc(sizeof(DEF_TEXT_SELECT_RELIEF));
    strcpy(textPtr->selTagPtr->reliefString, DEF_TEXT_SELECT_RELIEF);
    textPtr->selTagPtr->relief = TK_RELIEF_RAISED;
    textPtr->currentMarkPtr = TkTextSetMark(textPtr, "current", &startIndex);
    textPtr->insertMarkPtr = TkTextSetMark(textPtr, "insert", &startIndex);

    Tk_SetClass(textPtr->tkwin, "Text");
    Tk_SetClassProcs(textPtr->tkwin, &textClass, (ClientData) textPtr);
    Tk_CreateEventHandler(textPtr->tkwin,
	    ExposureMask|StructureNotifyMask|FocusChangeMask,
	    TextEventProc, (ClientData) textPtr);
    Tk_CreateEventHandler(textPtr->tkwin, KeyPressMask|KeyReleaseMask
	    |ButtonPressMask|ButtonReleaseMask|EnterWindowMask
	    |LeaveWindowMask|PointerMotionMask|VirtualEventMask,
	    TkTextBindProc, (ClientData) textPtr);
    Tk_CreateSelHandler(textPtr->tkwin, XA_PRIMARY, XA_STRING,
	    TextFetchSelection, (ClientData) textPtr, XA_STRING);
    if (ConfigureText(interp, textPtr, argc-2, argv+2, 0) != TCL_OK) {
	Tk_DestroyWindow(textPtr->tkwin);
	return TCL_ERROR;
    }
    Tcl_SetResult(interp, Tk_PathName(textPtr->tkwin), TCL_STATIC);

    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * TextWidgetCmd --
 *
 *	This procedure is invoked to process the Tcl command
 *	that corresponds to a text widget.  See the user
 *	documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *--------------------------------------------------------------
 */

static int
TextWidgetCmd(clientData, interp, argc, argv)
    ClientData clientData;	/* Information about text widget. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int argc;			/* Number of arguments. */
    CONST char **argv;		/* Argument strings. */
{
    register TkText *textPtr = (TkText *) clientData;
    int c, result = TCL_OK;
    size_t length;
    TkTextIndex index1, index2;

    if (argc < 2) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
		argv[0], " option ?arg arg ...?\"", (char *) NULL);
	return TCL_ERROR;
    }
    Tcl_Preserve((ClientData) textPtr);
    c = argv[1][0];
    length = strlen(argv[1]);
    if ((c == 'b') && (strncmp(argv[1], "bbox", length) == 0)) {
	int x, y, width, height;

	if (argc != 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " bbox index\"", (char *) NULL);
	    result = TCL_ERROR;
	    goto done;
	}
	if (TkTextGetIndex(interp, textPtr, argv[2], &index1) != TCL_OK) {
	    result = TCL_ERROR;
	    goto done;
	}
	if (TkTextCharBbox(textPtr, &index1, &x, &y, &width, &height) == 0) {
	    char buf[TCL_INTEGER_SPACE * 4];
	    
	    sprintf(buf, "%d %d %d %d", x, y, width, height);
	    Tcl_SetResult(interp, buf, TCL_VOLATILE);
	}
    } else if ((c == 'c') && (strncmp(argv[1], "cget", length) == 0)
	    && (length >= 2)) {
	if (argc != 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " cget option\"",
		    (char *) NULL);
	    result = TCL_ERROR;
	    goto done;
	}
	result = Tk_ConfigureValue(interp, textPtr->tkwin, configSpecs,
		(char *) textPtr, argv[2], 0);
    } else if ((c == 'c') && (strncmp(argv[1], "compare", length) == 0)
	    && (length >= 3)) {
	int relation, value;
	CONST char *p;

	if (argc != 5) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " compare index1 op index2\"", (char *) NULL);
	    result = TCL_ERROR;
	    goto done;
	}
	if ((TkTextGetIndex(interp, textPtr, argv[2], &index1) != TCL_OK)
		|| (TkTextGetIndex(interp, textPtr, argv[4], &index2)
		!= TCL_OK)) {
	    result = TCL_ERROR;
	    goto done;
	}
	relation = TkTextIndexCmp(&index1, &index2);
	p = argv[3];
	if (p[0] == '<') {
		value = (relation < 0);
	    if ((p[1] == '=') && (p[2] == 0)) {
		value = (relation <= 0);
	    } else if (p[1] != 0) {
		compareError:
		Tcl_AppendResult(interp, "bad comparison operator \"",
			argv[3], "\": must be <, <=, ==, >=, >, or !=",
			(char *) NULL);
		result = TCL_ERROR;
		goto done;
	    }
	} else if (p[0] == '>') {
		value = (relation > 0);
	    if ((p[1] == '=') && (p[2] == 0)) {
		value = (relation >= 0);
	    } else if (p[1] != 0) {
		goto compareError;
	    }
	} else if ((p[0] == '=') && (p[1] == '=') && (p[2] == 0)) {
	    value = (relation == 0);
	} else if ((p[0] == '!') && (p[1] == '=') && (p[2] == 0)) {
	    value = (relation != 0);
	} else {
	    goto compareError;
	}
	Tcl_SetResult(interp, ((value) ? "1" : "0"), TCL_STATIC);
    } else if ((c == 'c') && (strncmp(argv[1], "configure", length) == 0)
	    && (length >= 3)) {
	if (argc == 2) {
	    result = Tk_ConfigureInfo(interp, textPtr->tkwin, configSpecs,
		    (char *) textPtr, (char *) NULL, 0);
	} else if (argc == 3) {
	    result = Tk_ConfigureInfo(interp, textPtr->tkwin, configSpecs,
		    (char *) textPtr, argv[2], 0);
	} else {
	    result = ConfigureText(interp, textPtr, argc-2, argv+2,
		    TK_CONFIG_ARGV_ONLY);
	}
    } else if ((c == 'd') && (strncmp(argv[1], "debug", length) == 0)
	    && (length >= 3)) {
	if (argc > 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " debug boolean\"", (char *) NULL);
	    result = TCL_ERROR;
	    goto done;
	}
	if (argc == 2) {
	    Tcl_SetResult(interp, ((tkBTreeDebug) ? "1" : "0"), TCL_STATIC);
	} else {
	    if (Tcl_GetBoolean(interp, argv[2], &tkBTreeDebug) != TCL_OK) {
		result = TCL_ERROR;
		goto done;
	    }
	    tkTextDebug = tkBTreeDebug;
	}
    } else if ((c == 'd') && (strncmp(argv[1], "delete", length) == 0)
	    && (length >= 3)) {
	int i;

	if (argc < 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " delete index1 ?index2 ...?\"", (char *) NULL);
	    result = TCL_ERROR;
	    goto done;
	}
	if (textPtr->state == TK_STATE_NORMAL) {
	    if (argc < 5) {
		/*
		 * Simple case requires no predetermination of indices.
		 */
		result = DeleteChars(textPtr, argv[2],
			(argc == 4) ? argv[3] : NULL, NULL, NULL);
	    } else {
		/*
		 * Multi-index pair case requires that we prevalidate the
		 * indices and sort from last to first so that deletes
		 * occur in the exact (unshifted) text.  It also needs to
		 * handle partial and fully overlapping ranges.  We have to
		 * do this with multiple passes.
		 */
		TkTextIndex *indices, *ixStart, *ixEnd, *lastStart, *lastEnd;
		char *useIdx;

		argc -= 2;
		argv += 2;
		indices = (TkTextIndex *)
		    ckalloc((argc + 1) * sizeof(TkTextIndex));

		/*
		 * First pass verifies that all indices are valid.
		 */
		for (i = 0; i < argc; i++) {
		    if (TkTextGetIndex(interp, textPtr, argv[i],
			    &indices[i]) != TCL_OK) {
			result = TCL_ERROR;
			ckfree((char *) indices);
			goto done;
		    }
		}
		/*
		 * Pad out the pairs evenly to make later code easier.
		 */
		if (argc & 1) {
		    indices[i] = indices[i-1];
		    TkTextIndexForwChars(&indices[i], 1, &indices[i]);
		    argc++;
		}
		useIdx = (char *) ckalloc((unsigned) argc);
		memset(useIdx, 0, (unsigned) argc);
		/*
		 * Do a decreasing order sort so that we delete the end
		 * ranges first to maintain index consistency.
		 */
		qsort((VOID *) indices, (unsigned) (argc / 2),
			2 * sizeof(TkTextIndex), TextIndexSortProc);
		lastStart = lastEnd = NULL;
		/*
		 * Second pass will handle bogus ranges (end < start) and
		 * overlapping ranges.
		 */
		for (i = 0; i < argc; i += 2) {
		    ixStart = &indices[i];
		    ixEnd   = &indices[i+1];
		    if (TkTextIndexCmp(ixEnd, ixStart) <= 0) {
			continue;
		    }
		    if (lastStart) {
			if (TkTextIndexCmp(ixStart, lastStart) == 0) {
			    /*
			     * Start indices were equal, and the sort placed
			     * the longest range first, so skip this one.
			     */
			    continue;
			} else if (TkTextIndexCmp(lastStart, ixEnd) < 0) {
			    /*
			     * The next pair has a start range before the end
			     * point of the last range.  Constrain the delete
			     * range, but use the pointer values.
			     */
			    *ixEnd = *lastStart;
			    if (TkTextIndexCmp(ixEnd, ixStart) <= 0) {
				continue;
			    }
			}
		    }
		    lastStart = ixStart;
		    lastEnd   = ixEnd;
		    useIdx[i]   = 1;
		}
		/*
		 * Final pass take the input from the previous and deletes
		 * the ranges which are flagged to be deleted.
		 */
		for (i = 0; i < argc; i += 2) {
		    if (useIdx[i]) {
			/*
			 * We don't need to check the return value because all
			 * indices are preparsed above.
			 */
			DeleteChars(textPtr, NULL, NULL,
				&indices[i], &indices[i+1]);
		    }
		}
		ckfree((char *) indices);
	    }
	}
    } else if ((c == 'd') && (strncmp(argv[1], "dlineinfo", length) == 0)
	    && (length >= 2)) {
	int x, y, width, height, base;

	if (argc != 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " dlineinfo index\"", (char *) NULL);
	    result = TCL_ERROR;
	    goto done;
	}
	if (TkTextGetIndex(interp, textPtr, argv[2], &index1) != TCL_OK) {
	    result = TCL_ERROR;
	    goto done;
	}
	if (TkTextDLineInfo(textPtr, &index1, &x, &y, &width, &height, &base)
		== 0) {
	    char buf[TCL_INTEGER_SPACE * 5];
	    
	    sprintf(buf, "%d %d %d %d %d", x, y, width, height, base);
	    Tcl_SetResult(interp, buf, TCL_VOLATILE);
	}
    } else if ((c == 'e') && (strncmp(argv[1], "edit", length) == 0)) {
        result = TextEditCmd(textPtr, interp, argc, argv);
    } else if ((c == 'g') && (strncmp(argv[1], "get", length) == 0)) {
	Tcl_Obj *objPtr = NULL;
	Tcl_DString ds;
	int i, found = 0;

	if (argc < 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " get index1 ?index2 ...?\"", (char *) NULL);
	    result = TCL_ERROR;
	    goto done;
	}
	for (i = 2; i < argc; i += 2) {
	    if (TkTextGetIndex(interp, textPtr, argv[i], &index1) != TCL_OK) {
		result = TCL_ERROR;
		goto done;
	    }
	    if (i+1 == argc) {
		index2 = index1;
		TkTextIndexForwChars(&index2, 1, &index2);
	    } else if (TkTextGetIndex(interp, textPtr, argv[i+1], &index2)
		    != TCL_OK) {
		if (objPtr) {
		    Tcl_DecrRefCount(objPtr);
		}
		result = TCL_ERROR;
		goto done;
	    }
	    if (TkTextIndexCmp(&index1, &index2) < 0) {
		/* 
		 * Place the text in a DString and move it to the result.
		 * Since this could in principle be a megabyte or more, we
		 * want to do it efficiently!
		 */
		TextGetText(&index1, &index2, &ds);
		found++;
		if (found == 1) {
		    Tcl_DStringResult(interp, &ds);
		} else {
		    if (found == 2) {
			/*
			 * Move the first item we put into the result into
			 * the first element of the list object.
			 */
			objPtr = Tcl_NewObj();
			Tcl_ListObjAppendElement(NULL, objPtr,
				Tcl_GetObjResult(interp));
		    }
		    Tcl_ListObjAppendElement(NULL, objPtr,
			    Tcl_NewStringObj(Tcl_DStringValue(&ds),
				    Tcl_DStringLength(&ds)));
		}
		Tcl_DStringFree(&ds);
	    }
	}
	if (found > 1) {
	    Tcl_SetObjResult(interp, objPtr);
	}
    } else if ((c == 'i') && (strncmp(argv[1], "index", length) == 0)
	    && (length >= 3)) {
	char buf[200];

	if (argc != 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " index index\"",
		    (char *) NULL);
	    result = TCL_ERROR;
	    goto done;
	}
	if (TkTextGetIndex(interp, textPtr, argv[2], &index1) != TCL_OK) {
	    result = TCL_ERROR;
	    goto done;
	}
	TkTextPrintIndex(&index1, buf);
	Tcl_SetResult(interp, buf, TCL_VOLATILE);
    } else if ((c == 'i') && (strncmp(argv[1], "insert", length) == 0)
	    && (length >= 3)) {
	int i, j, numTags;
	CONST char **tagNames;
	TkTextTag **oldTagArrayPtr;

	if (argc < 4) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0],
		    " insert index chars ?tagList chars tagList ...?\"",
		    (char *) NULL);
	    result = TCL_ERROR;
	    goto done;
	}
	if (TkTextGetIndex(interp, textPtr, argv[2], &index1) != TCL_OK) {
	    result = TCL_ERROR;
	    goto done;
	}
	if (textPtr->state == TK_STATE_NORMAL) {
	    for (j = 3;  j < argc; j += 2) {
		InsertChars(textPtr, &index1, argv[j]);
		if (argc > (j+1)) {
		    TkTextIndexForwBytes(&index1, (int) strlen(argv[j]),
			    &index2);
		    oldTagArrayPtr = TkBTreeGetTags(&index1, &numTags);
		    if (oldTagArrayPtr != NULL) {
			for (i = 0; i < numTags; i++) {
			    TkBTreeTag(&index1, &index2, oldTagArrayPtr[i], 0);
			}
			ckfree((char *) oldTagArrayPtr);
		    }
		    if (Tcl_SplitList(interp, argv[j+1], &numTags, &tagNames)
			    != TCL_OK) {
			result = TCL_ERROR;
			goto done;
		    }
		    for (i = 0; i < numTags; i++) {
			TkBTreeTag(&index1, &index2,
				TkTextCreateTag(textPtr, tagNames[i]), 1);
		    }
		    ckfree((char *) tagNames);
		    index1 = index2;
		}
	    }
	}
    } else if ((c == 'd') && (strncmp(argv[1], "dump", length) == 0)) {
	result = TextDumpCmd(textPtr, interp, argc, argv);
    } else if ((c == 'i') && (strncmp(argv[1], "image", length) == 0)) {
	result = TkTextImageCmd(textPtr, interp, argc, argv);
    } else if ((c == 'm') && (strncmp(argv[1], "mark", length) == 0)) {
	result = TkTextMarkCmd(textPtr, interp, argc, argv);
    } else if ((c == 's') && (strcmp(argv[1], "scan") == 0) && (length >= 2)) {
	result = TkTextScanCmd(textPtr, interp, argc, argv);
    } else if ((c == 's') && (strcmp(argv[1], "search") == 0)
	    && (length >= 3)) {
	result = TextSearchCmd(textPtr, interp, argc, argv);
    } else if ((c == 's') && (strcmp(argv[1], "see") == 0) && (length >= 3)) {
	result = TkTextSeeCmd(textPtr, interp, argc, argv);
    } else if ((c == 't') && (strcmp(argv[1], "tag") == 0)) {
	result = TkTextTagCmd(textPtr, interp, argc, argv);
    } else if ((c == 'w') && (strncmp(argv[1], "window", length) == 0)) {
	result = TkTextWindowCmd(textPtr, interp, argc, argv);
    } else if ((c == 'x') && (strncmp(argv[1], "xview", length) == 0)) {
	result = TkTextXviewCmd(textPtr, interp, argc, argv);
    } else if ((c == 'y') && (strncmp(argv[1], "yview", length) == 0)
	    && (length >= 2)) {
	result = TkTextYviewCmd(textPtr, interp, argc, argv);
    } else {
	Tcl_AppendResult(interp, "bad option \"", argv[1],
		"\": must be bbox, cget, compare, configure, debug, delete, ",
                "dlineinfo, dump, edit, get, image, index, insert, mark, ",
                "scan, search, see, tag, window, xview, or yview",
		(char *) NULL);
	result = TCL_ERROR;
    }

    done:
    Tcl_Release((ClientData) textPtr);
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * TextIndexSortProc --
 *
 *	This procedure is called by qsort when sorting an array of
 *	indices in *decreasing* order (last to first).
 *
 * Results:
 *	The return value is -1 if the first argument should be before
 *	the second element, 0 if it's equivalent, and 1 if it should be
 *	after the second element.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
TextIndexSortProc(first, second)
    CONST VOID *first, *second;		/* Elements to be compared. */
{
    TkTextIndex *pair1 = (TkTextIndex *) first;
    TkTextIndex *pair2 = (TkTextIndex *) second;
    int cmp = TkTextIndexCmp(&pair1[1], &pair2[1]);

    if (cmp == 0) {
	/*
	 * If the first indices were equal, we want the second index of the
	 * pair also to be the greater.  Use pointer magic to access the
	 * second index pair.
	 */
	cmp = TkTextIndexCmp(&pair1[0], &pair2[0]);
    }
    if (cmp > 0) {
	return -1;
    } else if (cmp < 0) {
	return 1;
    }
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * DestroyText --
 *
 *	This procedure is invoked by Tcl_EventuallyFree or Tcl_Release
 *	to clean up the internal structure of a text at a safe time
 *	(when no-one is using it anymore).
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Everything associated with the text is freed up.
 *
 *----------------------------------------------------------------------
 */

static void
DestroyText(memPtr)
    char *memPtr;		/* Info about text widget. */
{
    register TkText *textPtr = (TkText *) memPtr;
    Tcl_HashSearch search;
    Tcl_HashEntry *hPtr;
    TkTextTag *tagPtr;

    /*
     * Free up all the stuff that requires special handling, then
     * let Tk_FreeOptions handle all the standard option-related
     * stuff.  Special note:  free up display-related information
     * before deleting the B-tree, since display-related stuff
     * may refer to stuff in the B-tree.
     */

    TkTextFreeDInfo(textPtr);
    TkBTreeDestroy(textPtr->tree);
    for (hPtr = Tcl_FirstHashEntry(&textPtr->tagTable, &search);
	    hPtr != NULL; hPtr = Tcl_NextHashEntry(&search)) {
	tagPtr = (TkTextTag *) Tcl_GetHashValue(hPtr);
	TkTextFreeTag(textPtr, tagPtr);
    }
    Tcl_DeleteHashTable(&textPtr->tagTable);
    for (hPtr = Tcl_FirstHashEntry(&textPtr->markTable, &search);
	    hPtr != NULL; hPtr = Tcl_NextHashEntry(&search)) {
	ckfree((char *) Tcl_GetHashValue(hPtr));
    }
    Tcl_DeleteHashTable(&textPtr->markTable);
    if (textPtr->tabArrayPtr != NULL) {
	ckfree((char *) textPtr->tabArrayPtr);
    }
    if (textPtr->insertBlinkHandler != NULL) {
	Tcl_DeleteTimerHandler(textPtr->insertBlinkHandler);
    }
    if (textPtr->bindingTable != NULL) {
	Tk_DeleteBindingTable(textPtr->bindingTable);
    }
    TkUndoFreeStack(textPtr->undoStack);

    /*
     * NOTE: do NOT free up selBorder, selBdString, or selFgColorPtr:
     * they are duplicates of information in the "sel" tag, which was
     * freed up as part of deleting the tags above.
     */

    textPtr->selBorder = NULL;
    textPtr->selBdString = NULL;
    textPtr->selFgColorPtr = NULL;
    Tk_FreeOptions(configSpecs, (char *) textPtr, textPtr->display, 0);
    ckfree((char *) textPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * ConfigureText --
 *
 *	This procedure is called to process an argv/argc list, plus
 *	the Tk option database, in order to configure (or
 *	reconfigure) a text widget.
 *
 * Results:
 *	The return value is a standard Tcl result.  If TCL_ERROR is
 *	returned, then the interp's result contains an error message.
 *
 * Side effects:
 *	Configuration information, such as text string, colors, font,
 *	etc. get set for textPtr;  old resources get freed, if there
 *	were any.
 *
 *----------------------------------------------------------------------
 */

static int
ConfigureText(interp, textPtr, argc, argv, flags)
    Tcl_Interp *interp;		/* Used for error reporting. */
    register TkText *textPtr;	/* Information about widget;  may or may
				 * not already have values for some fields. */
    int argc;			/* Number of valid entries in argv. */
    CONST char **argv;		/* Arguments. */
    int flags;			/* Flags to pass to Tk_ConfigureWidget. */
{
    int oldExport = textPtr->exportSelection;

    if (Tk_ConfigureWidget(interp, textPtr->tkwin, configSpecs,
	    argc, argv, (char *) textPtr, flags) != TCL_OK) {
	return TCL_ERROR;
    }

    TkUndoSetDepth(textPtr->undoStack, textPtr->maxUndo);

    /*
     * A few other options also need special processing, such as parsing
     * the geometry and setting the background from a 3-D border.
     */

    Tk_SetBackgroundFromBorder(textPtr->tkwin, textPtr->border);

    /*
     * Don't allow negative spacings.
     */

    if (textPtr->spacing1 < 0) {
	textPtr->spacing1 = 0;
    }
    if (textPtr->spacing2 < 0) {
	textPtr->spacing2 = 0;
    }
    if (textPtr->spacing3 < 0) {
	textPtr->spacing3 = 0;
    }

    /*
     * Parse tab stops.
     */

    if (textPtr->tabArrayPtr != NULL) {
	ckfree((char *) textPtr->tabArrayPtr);
	textPtr->tabArrayPtr = NULL;
    }
    if (textPtr->tabOptionString != NULL) {
	textPtr->tabArrayPtr = TkTextGetTabs(interp, textPtr->tkwin,
		textPtr->tabOptionString);
	if (textPtr->tabArrayPtr == NULL) {
	    Tcl_AddErrorInfo(interp,"\n    (while processing -tabs option)");
	    return TCL_ERROR;
	}
    }

    /*
     * Make sure that configuration options are properly mirrored
     * between the widget record and the "sel" tags.  NOTE: we don't
     * have to free up information during the mirroring;  old
     * information was freed when it was replaced in the widget
     * record.
     */

    textPtr->selTagPtr->border = textPtr->selBorder;
    if (textPtr->selTagPtr->bdString != textPtr->selBdString) {
	textPtr->selTagPtr->bdString = textPtr->selBdString;
	if (textPtr->selBdString != NULL) {
	    if (Tk_GetPixels(interp, textPtr->tkwin, textPtr->selBdString,
		    &textPtr->selTagPtr->borderWidth) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (textPtr->selTagPtr->borderWidth < 0) {
		textPtr->selTagPtr->borderWidth = 0;
	    }
	}
    }
    textPtr->selTagPtr->fgColor = textPtr->selFgColorPtr;
    textPtr->selTagPtr->affectsDisplay = 0;
    if ((textPtr->selTagPtr->border != NULL)
	    || (textPtr->selTagPtr->bdString != NULL)
	    || (textPtr->selTagPtr->reliefString != NULL)
	    || (textPtr->selTagPtr->bgStipple != None)
	    || (textPtr->selTagPtr->fgColor != NULL)
	    || (textPtr->selTagPtr->tkfont != None)
	    || (textPtr->selTagPtr->fgStipple != None)
	    || (textPtr->selTagPtr->justifyString != NULL)
	    || (textPtr->selTagPtr->lMargin1String != NULL)
	    || (textPtr->selTagPtr->lMargin2String != NULL)
	    || (textPtr->selTagPtr->offsetString != NULL)
	    || (textPtr->selTagPtr->overstrikeString != NULL)
	    || (textPtr->selTagPtr->rMarginString != NULL)
	    || (textPtr->selTagPtr->spacing1String != NULL)
	    || (textPtr->selTagPtr->spacing2String != NULL)
	    || (textPtr->selTagPtr->spacing3String != NULL)
	    || (textPtr->selTagPtr->tabString != NULL)
	    || (textPtr->selTagPtr->underlineString != NULL)
	    || (textPtr->selTagPtr->elideString != NULL)
	    || (textPtr->selTagPtr->wrapMode != TEXT_WRAPMODE_NULL)) {
	textPtr->selTagPtr->affectsDisplay = 1;
    }
    TkTextRedrawTag(textPtr, (TkTextIndex *) NULL, (TkTextIndex *) NULL,
	    textPtr->selTagPtr, 1);

    /*
     * Claim the selection if we've suddenly started exporting it and there
     * are tagged characters.
     */

    if (textPtr->exportSelection && (!oldExport)) {
	TkTextSearch search;
	TkTextIndex first, last;

	TkTextMakeByteIndex(textPtr->tree, 0, 0, &first);
	TkTextMakeByteIndex(textPtr->tree,
		TkBTreeNumLines(textPtr->tree), 0, &last);
	TkBTreeStartSearch(&first, &last, textPtr->selTagPtr, &search);
	if (TkBTreeCharTagged(&first, textPtr->selTagPtr)
		|| TkBTreeNextTag(&search)) {
	    Tk_OwnSelection(textPtr->tkwin, XA_PRIMARY, TkTextLostSelection,
		    (ClientData) textPtr);
	    textPtr->flags |= GOT_SELECTION;
	}
    }

    /*
     * Account for state changes that would reenable blinking cursor state.
     */

    if (textPtr->flags & GOT_FOCUS) {
	Tcl_DeleteTimerHandler(textPtr->insertBlinkHandler);
	textPtr->insertBlinkHandler = (Tcl_TimerToken) NULL;
	TextBlinkProc((ClientData) textPtr);
    }

    /*
     * Register the desired geometry for the window, and arrange for
     * the window to be redisplayed.
     */

    if (textPtr->width <= 0) {
	textPtr->width = 1;
    }
    if (textPtr->height <= 0) {
	textPtr->height = 1;
    }
    TextWorldChanged((ClientData) textPtr);
    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * TextWorldChanged --
 *
 *      This procedure is called when the world has changed in some
 *      way and the widget needs to recompute all its graphics contexts
 *	and determine its new geometry.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *	Configures all tags in the Text with a empty argc/argv, for
 *	the side effect of causing all the items to recompute their
 *	geometry and to be redisplayed.
 *
 *---------------------------------------------------------------------------
 */
 
static void
TextWorldChanged(instanceData)
    ClientData instanceData;	/* Information about widget. */
{
    TkText *textPtr;
    Tk_FontMetrics fm;

    textPtr = (TkText *) instanceData;

    textPtr->charWidth = Tk_TextWidth(textPtr->tkfont, "0", 1);
    if (textPtr->charWidth <= 0) {
	textPtr->charWidth = 1;
    }
    Tk_GetFontMetrics(textPtr->tkfont, &fm);
    Tk_GeometryRequest(textPtr->tkwin,
	    textPtr->width * textPtr->charWidth + 2*textPtr->borderWidth
		    + 2*textPtr->padX + 2*textPtr->highlightWidth,
	    textPtr->height * (fm.linespace + textPtr->spacing1
		    + textPtr->spacing3) + 2*textPtr->borderWidth
		    + 2*textPtr->padY + 2*textPtr->highlightWidth);
    Tk_SetInternalBorder(textPtr->tkwin,
	    textPtr->borderWidth + textPtr->highlightWidth);
    if (textPtr->setGrid) {
	Tk_SetGrid(textPtr->tkwin, textPtr->width, textPtr->height,
		textPtr->charWidth, fm.linespace);
    } else {
	Tk_UnsetGrid(textPtr->tkwin);
    }

    TkTextRelayoutWindow(textPtr);
}

/*
 *--------------------------------------------------------------
 *
 * TextEventProc --
 *
 *	This procedure is invoked by the Tk dispatcher on
 *	structure changes to a text.  For texts with 3D
 *	borders, this procedure is also invoked for exposures.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	When the window gets deleted, internal structures get
 *	cleaned up.  When it gets exposed, it is redisplayed.
 *
 *--------------------------------------------------------------
 */

static void
TextEventProc(clientData, eventPtr)
    ClientData clientData;	/* Information about window. */
    register XEvent *eventPtr;	/* Information about event. */
{
    register TkText *textPtr = (TkText *) clientData;
    TkTextIndex index, index2;

    if (eventPtr->type == Expose) {
	TkTextRedrawRegion(textPtr, eventPtr->xexpose.x,
		eventPtr->xexpose.y, eventPtr->xexpose.width,
		eventPtr->xexpose.height);
    } else if (eventPtr->type == ConfigureNotify) {
	if ((textPtr->prevWidth != Tk_Width(textPtr->tkwin))
		|| (textPtr->prevHeight != Tk_Height(textPtr->tkwin))) {
	    TkTextRelayoutWindow(textPtr);
	    textPtr->prevWidth = Tk_Width(textPtr->tkwin);
	    textPtr->prevHeight = Tk_Height(textPtr->tkwin);
	}
    } else if (eventPtr->type == DestroyNotify) {
	if (textPtr->tkwin != NULL) {
	    if (textPtr->setGrid) {
		Tk_UnsetGrid(textPtr->tkwin);
	    }
	    textPtr->tkwin = NULL;
	    Tcl_DeleteCommandFromToken(textPtr->interp,
		    textPtr->widgetCmd);
	}
	Tcl_EventuallyFree((ClientData) textPtr, DestroyText);
    } else if ((eventPtr->type == FocusIn) || (eventPtr->type == FocusOut)) {
	if (eventPtr->xfocus.detail != NotifyInferior) {
	    Tcl_DeleteTimerHandler(textPtr->insertBlinkHandler);
	    if (eventPtr->type == FocusIn) {
		textPtr->flags |= GOT_FOCUS | INSERT_ON;
		if (textPtr->insertOffTime != 0) {
		    textPtr->insertBlinkHandler = Tcl_CreateTimerHandler(
			    textPtr->insertOnTime, TextBlinkProc,
			    (ClientData) textPtr);
		}
	    } else {
		textPtr->flags &= ~(GOT_FOCUS | INSERT_ON);
		textPtr->insertBlinkHandler = (Tcl_TimerToken) NULL;
	    }
#ifndef ALWAYS_SHOW_SELECTION
	    TkTextRedrawTag(textPtr, NULL, NULL, textPtr->selTagPtr, 1);
#endif
	    TkTextMarkSegToIndex(textPtr, textPtr->insertMarkPtr, &index);
	    TkTextIndexForwChars(&index, 1, &index2);
	    TkTextChanged(textPtr, &index, &index2);
	    if (textPtr->highlightWidth > 0) {
		TkTextRedrawRegion(textPtr, 0, 0, textPtr->highlightWidth,
			textPtr->highlightWidth);
	    }
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TextCmdDeletedProc --
 *
 *	This procedure is invoked when a widget command is deleted.  If
 *	the widget isn't already in the process of being destroyed,
 *	this command destroys it.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The widget is destroyed.
 *
 *----------------------------------------------------------------------
 */

static void
TextCmdDeletedProc(clientData)
    ClientData clientData;	/* Pointer to widget record for widget. */
{
    TkText *textPtr = (TkText *) clientData;
    Tk_Window tkwin = textPtr->tkwin;

    /*
     * This procedure could be invoked either because the window was
     * destroyed and the command was then deleted (in which case tkwin
     * is NULL) or because the command was deleted, and then this procedure
     * destroys the widget.
     */

    if (tkwin != NULL) {
	if (textPtr->setGrid) {
	    Tk_UnsetGrid(textPtr->tkwin);
	}
	textPtr->tkwin = NULL;
	Tk_DestroyWindow(tkwin);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * InsertChars --
 *
 *	This procedure implements most of the functionality of the
 *	"insert" widget command.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The characters in "string" get added to the text just before
 *	the character indicated by "indexPtr".
 *
 *----------------------------------------------------------------------
 */

static void
InsertChars(textPtr, indexPtr, string)
    TkText *textPtr;		/* Overall information about text widget. */
    TkTextIndex *indexPtr;	/* Where to insert new characters.  May be
				 * modified and/or invalidated. */
    CONST char *string;		/* Null-terminated string containing new
				 * information to add to text. */
{
    int lineIndex, resetView, offset;
    TkTextIndex newTop;
    char indexBuffer[TK_POS_CHARS];

    /*
     * Don't allow insertions on the last (dummy) line of the text.
     */

    lineIndex = TkBTreeLineIndex(indexPtr->linePtr);
    if (lineIndex == TkBTreeNumLines(textPtr->tree)) {
	lineIndex--;
	TkTextMakeByteIndex(textPtr->tree, lineIndex, 1000000, indexPtr);
    }

    /*
     * Notify the display module that lines are about to change, then do
     * the insertion.  If the insertion occurs on the top line of the
     * widget (textPtr->topIndex), then we have to recompute topIndex
     * after the insertion, since the insertion could invalidate it.
     */

    resetView = offset = 0;
    if (indexPtr->linePtr == textPtr->topIndex.linePtr) {
	resetView = 1;
	offset = textPtr->topIndex.byteIndex;
	if (offset > indexPtr->byteIndex) {
	    offset += strlen(string);
	}
    }
    TkTextChanged(textPtr, indexPtr, indexPtr);
    TkBTreeInsertChars(indexPtr, string);

    /*
     * Push the insertion on the undo stack
     */

    if ( textPtr->undo ) {
        TkTextIndex     toIndex;

        Tcl_DString actionCommand;
        Tcl_DString revertCommand;
        
        if (textPtr->autoSeparators &&
            textPtr->lastEditMode != TK_TEXT_EDIT_INSERT) {
            TkUndoInsertUndoSeparator(textPtr->undoStack);
        }
        
        textPtr->lastEditMode = TK_TEXT_EDIT_INSERT;
        
        Tcl_DStringInit(&actionCommand);
        Tcl_DStringInit(&revertCommand);
        
        Tcl_DStringAppend(&actionCommand,Tcl_GetCommandName(textPtr->interp,textPtr->widgetCmd),-1);
        Tcl_DStringAppend(&actionCommand," insert ",-1);
        TkTextPrintIndex(indexPtr,indexBuffer);
        Tcl_DStringAppend(&actionCommand,indexBuffer,-1);
        Tcl_DStringAppend(&actionCommand," ",-1);
        Tcl_DStringAppendElement(&actionCommand,string);
        Tcl_DStringAppend(&actionCommand,";",-1);
        Tcl_DStringAppend(&actionCommand,Tcl_GetCommandName(textPtr->interp,textPtr->widgetCmd),-1);
        Tcl_DStringAppend(&actionCommand," mark set insert ",-1);
        TkTextIndexForwBytes(indexPtr, (int) strlen(string),
			&toIndex);
        TkTextPrintIndex(&toIndex, indexBuffer);
        Tcl_DStringAppend(&actionCommand,indexBuffer,-1);
        Tcl_DStringAppend(&actionCommand,"; ",-1);
        Tcl_DStringAppend(&actionCommand,Tcl_GetCommandName(textPtr->interp,textPtr->widgetCmd),-1);
        Tcl_DStringAppend(&actionCommand," see insert",-1);
        
        Tcl_DStringAppend(&revertCommand,Tcl_GetCommandName(textPtr->interp,textPtr->widgetCmd),-1);
        Tcl_DStringAppend(&revertCommand," delete ",-1);
        TkTextPrintIndex(indexPtr,indexBuffer);
        Tcl_DStringAppend(&revertCommand,indexBuffer,-1);
        Tcl_DStringAppend(&revertCommand," ",-1);
        TkTextPrintIndex(&toIndex, indexBuffer);
        Tcl_DStringAppend(&revertCommand,indexBuffer,-1);
        Tcl_DStringAppend(&revertCommand," ;",-1);
        Tcl_DStringAppend(&revertCommand,Tcl_GetCommandName(textPtr->interp,textPtr->widgetCmd),-1);
        Tcl_DStringAppend(&revertCommand," mark set insert ",-1);
        TkTextPrintIndex(indexPtr,indexBuffer);
        Tcl_DStringAppend(&revertCommand,indexBuffer,-1);
        Tcl_DStringAppend(&revertCommand,"; ",-1);
        Tcl_DStringAppend(&revertCommand,Tcl_GetCommandName(textPtr->interp,textPtr->widgetCmd),-1);
        Tcl_DStringAppend(&revertCommand," see insert",-1);
        
        TkUndoPushAction(textPtr->undoStack,&actionCommand, &revertCommand);

     	Tcl_DStringFree(&actionCommand);
     	Tcl_DStringFree(&revertCommand);

    }
    updateDirtyFlag(textPtr);

    if (resetView) {
	TkTextMakeByteIndex(textPtr->tree, lineIndex, 0, &newTop);
	TkTextIndexForwBytes(&newTop, offset, &newTop);
	TkTextSetYView(textPtr, &newTop, 0);
    }

    /*
     * Invalidate any selection retrievals in progress.
     */

    textPtr->abortSelections = 1;
}

/*
 *----------------------------------------------------------------------
 *
 * DeleteChars --
 *
 *	This procedure implements most of the functionality of the
 *	"delete" widget command.
 *
 * Results:
 *	Returns a standard Tcl result, and leaves an error message
 *	in textPtr->interp if there is an error.
 *
 * Side effects:
 *	Characters get deleted from the text.
 *
 *----------------------------------------------------------------------
 */

static int
DeleteChars(textPtr, index1String, index2String, indexPtr1, indexPtr2)
    TkText *textPtr;		/* Overall information about text widget. */
    CONST char *index1String;	/* String describing location of first
				 * character to delete. */
    CONST char *index2String;	/* String describing location of last
				 * character to delete.  NULL means just
				 * delete the one character given by
				 * index1String. */
    TkTextIndex *indexPtr1;	/* index describing location of first
				 * character to delete. */
    TkTextIndex *indexPtr2;	/* index describing location of last
				 * character to delete.  NULL means just
				 * delete the one character given by
				 * indexPtr1. */
{
    int line1, line2, line, byteIndex, resetView;
    TkTextIndex index1, index2;
    char indexBuffer[TK_POS_CHARS];

    /*
     * Parse the starting and stopping indices.
     */

    if (index1String != NULL) {
	if (TkTextGetIndex(textPtr->interp, textPtr, index1String, &index1)
		!= TCL_OK) {
	    return TCL_ERROR;
	}
	if (index2String != NULL) {
	    if (TkTextGetIndex(textPtr->interp, textPtr, index2String, &index2)
		    != TCL_OK) {
		return TCL_ERROR;
	    }
	} else {
	    index2 = index1;
	    TkTextIndexForwChars(&index2, 1, &index2);
	}
    } else {
	index1 = *indexPtr1;
	if (indexPtr2 != NULL) {
	    index2 = *indexPtr2;
	} else {
	    index2 = index1;
	    TkTextIndexForwChars(&index2, 1, &index2);
	}
    }

    /*
     * Make sure there's really something to delete.
     */

    if (TkTextIndexCmp(&index1, &index2) >= 0) {
	return TCL_OK;
    }

    /*
     * The code below is ugly, but it's needed to make sure there
     * is always a dummy empty line at the end of the text.  If the
     * final newline of the file (just before the dummy line) is being
     * deleted, then back up index to just before the newline.  If
     * there is a newline just before the first character being deleted,
     * then back up the first index too, so that an even number of lines
     * gets deleted.  Furthermore, remove any tags that are present on
     * the newline that isn't going to be deleted after all (this simulates
     * deleting the newline and then adding a "clean" one back again).
     */

    line1 = TkBTreeLineIndex(index1.linePtr);
    line2 = TkBTreeLineIndex(index2.linePtr);
    if (line2 == TkBTreeNumLines(textPtr->tree)) {
	TkTextTag **arrayPtr;
	int arraySize, i;
	TkTextIndex oldIndex2;

	oldIndex2 = index2;
	TkTextIndexBackChars(&oldIndex2, 1, &index2);
	line2--;
	if ((index1.byteIndex == 0) && (line1 != 0)) {
	    TkTextIndexBackChars(&index1, 1, &index1);
	    line1--;
	}
	arrayPtr = TkBTreeGetTags(&index2, &arraySize);
	if (arrayPtr != NULL) {
	    for (i = 0; i < arraySize; i++) {
		TkBTreeTag(&index2, &oldIndex2, arrayPtr[i], 0);
	    }
	    ckfree((char *) arrayPtr);
	}
    }

    /*
     * Tell the display what's about to happen so it can discard
     * obsolete display information, then do the deletion.  Also,
     * if the deletion involves the top line on the screen, then
     * we have to reset the view (the deletion will invalidate
     * textPtr->topIndex).  Compute what the new first character
     * will be, then do the deletion, then reset the view.
     */

    TkTextChanged(textPtr, &index1, &index2);
    resetView = 0;
    line = 0;
    byteIndex = 0;
    if (TkTextIndexCmp(&index2, &textPtr->topIndex) >= 0) {
	if (TkTextIndexCmp(&index1, &textPtr->topIndex) <= 0) {
	    /*
	     * Deletion range straddles topIndex: use the beginning
	     * of the range as the new topIndex.
	     */

	    resetView = 1;
	    line = line1;
	    byteIndex = index1.byteIndex;
	} else if (index1.linePtr == textPtr->topIndex.linePtr) {
	    /*
	     * Deletion range starts on top line but after topIndex.
	     * Use the current topIndex as the new one.
	     */

	    resetView = 1;
	    line = line1;
	    byteIndex = textPtr->topIndex.byteIndex;
	}
    } else if (index2.linePtr == textPtr->topIndex.linePtr) {
	/*
	 * Deletion range ends on top line but before topIndex.
	 * Figure out what will be the new character index for
	 * the character currently pointed to by topIndex.
	 */

	resetView = 1;
	line = line2;
	byteIndex = textPtr->topIndex.byteIndex;
	if (index1.linePtr != index2.linePtr) {
	    byteIndex -= index2.byteIndex;
	} else {
	    byteIndex -= (index2.byteIndex - index1.byteIndex);
	}
    }

    /*
     * Push the deletion on the undo stack
     */

    if (textPtr->undo) {
	Tcl_DString ds;
        Tcl_DString actionCommand;
        Tcl_DString revertCommand;
    
	if (textPtr->autoSeparators
		&& (textPtr->lastEditMode != TK_TEXT_EDIT_DELETE)) {
	   TkUndoInsertUndoSeparator(textPtr->undoStack);
	}

	textPtr->lastEditMode = TK_TEXT_EDIT_DELETE;

        Tcl_DStringInit(&actionCommand);
        Tcl_DStringInit(&revertCommand);

        Tcl_DStringAppend(&actionCommand,Tcl_GetCommandName(textPtr->interp,textPtr->widgetCmd),-1);
        Tcl_DStringAppend(&actionCommand," delete ",-1);
        TkTextPrintIndex(&index1,indexBuffer);
        Tcl_DStringAppend(&actionCommand,indexBuffer,-1);
        Tcl_DStringAppend(&actionCommand," ",-1);
        TkTextPrintIndex(&index2, indexBuffer);
        Tcl_DStringAppend(&actionCommand,indexBuffer,-1);
        Tcl_DStringAppend(&actionCommand,"; ",-1);
        Tcl_DStringAppend(&actionCommand,Tcl_GetCommandName(textPtr->interp,textPtr->widgetCmd),-1);
        Tcl_DStringAppend(&actionCommand," mark set insert ",-1);
        TkTextPrintIndex(&index1,indexBuffer);
        Tcl_DStringAppend(&actionCommand,indexBuffer,-1);

        Tcl_DStringAppend(&actionCommand,"; ",-1);
        Tcl_DStringAppend(&actionCommand,Tcl_GetCommandName(textPtr->interp,textPtr->widgetCmd),-1);
        Tcl_DStringAppend(&actionCommand," see insert",-1);

	TextGetText(&index1, &index2, &ds);

        Tcl_DStringAppend(&revertCommand,Tcl_GetCommandName(textPtr->interp,textPtr->widgetCmd),-1);
        Tcl_DStringAppend(&revertCommand," insert ",-1);
        TkTextPrintIndex(&index1,indexBuffer);
        Tcl_DStringAppend(&revertCommand,indexBuffer,-1);
        Tcl_DStringAppend(&revertCommand," ",-1);
        Tcl_DStringAppendElement(&revertCommand,Tcl_DStringValue(&ds));
        Tcl_DStringAppend(&revertCommand,"; ",-1);
        Tcl_DStringAppend(&revertCommand,Tcl_GetCommandName(textPtr->interp,textPtr->widgetCmd),-1);
        Tcl_DStringAppend(&revertCommand," mark set insert ",-1);
        TkTextPrintIndex(&index2, indexBuffer);
        Tcl_DStringAppend(&revertCommand,indexBuffer,-1);
        Tcl_DStringAppend(&revertCommand,"; ",-1);
        Tcl_DStringAppend(&revertCommand,Tcl_GetCommandName(textPtr->interp,textPtr->widgetCmd),-1);
        Tcl_DStringAppend(&revertCommand," see insert",-1);

        TkUndoPushAction(textPtr->undoStack,&actionCommand, &revertCommand);

        Tcl_DStringFree(&actionCommand);
        Tcl_DStringFree(&revertCommand);

    }
    updateDirtyFlag(textPtr);

    TkBTreeDeleteChars(&index1, &index2);
    if (resetView) {
	TkTextMakeByteIndex(textPtr->tree, line, byteIndex, &index1);
	TkTextSetYView(textPtr, &index1, 0);
    }

    /*
     * Invalidate any selection retrievals in progress.
     */

    textPtr->abortSelections = 1;

    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * TextFetchSelection --
 *
 *	This procedure is called back by Tk when the selection is
 *	requested by someone.  It returns part or all of the selection
 *	in a buffer provided by the caller.
 *
 * Results:
 *	The return value is the number of non-NULL bytes stored
 *	at buffer.  Buffer is filled (or partially filled) with a
 *	NULL-terminated string containing part or all of the selection,
 *	as given by offset and maxBytes.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
TextFetchSelection(clientData, offset, buffer, maxBytes)
    ClientData clientData;		/* Information about text widget. */
    int offset;				/* Offset within selection of first
					 * character to be returned. */
    char *buffer;			/* Location in which to place
					 * selection. */
    int maxBytes;			/* Maximum number of bytes to place
					 * at buffer, not including terminating
					 * NULL character. */
{
    register TkText *textPtr = (TkText *) clientData;
    TkTextIndex eof;
    int count, chunkSize, offsetInSeg;
    TkTextSearch search;
    TkTextSegment *segPtr;

    if (!textPtr->exportSelection) {
	return -1;
    }

    /*
     * Find the beginning of the next range of selected text.  Note:  if
     * the selection is being retrieved in multiple pieces (offset != 0)
     * and some modification has been made to the text that affects the
     * selection then reject the selection request (make 'em start over
     * again).
     */

    if (offset == 0) {
	TkTextMakeByteIndex(textPtr->tree, 0, 0, &textPtr->selIndex);
	textPtr->abortSelections = 0;
    } else if (textPtr->abortSelections) {
	return 0;
    }
    TkTextMakeByteIndex(textPtr->tree, TkBTreeNumLines(textPtr->tree), 0, &eof);
    TkBTreeStartSearch(&textPtr->selIndex, &eof, textPtr->selTagPtr, &search);
    if (!TkBTreeCharTagged(&textPtr->selIndex, textPtr->selTagPtr)) {
	if (!TkBTreeNextTag(&search)) {
	    if (offset == 0) {
		return -1;
	    } else {
		return 0;
	    }
	}
	textPtr->selIndex = search.curIndex;
    }

    /*
     * Each iteration through the outer loop below scans one selected range.
     * Each iteration through the inner loop scans one segment in the
     * selected range.
     */

    count = 0;
    while (1) {
	/*
	 * Find the end of the current range of selected text.
	 */

	if (!TkBTreeNextTag(&search)) {
	    panic("TextFetchSelection couldn't find end of range");
	}

	/*
	 * Copy information from character segments into the buffer
	 * until either we run out of space in the buffer or we get
	 * to the end of this range of text.
	 */

	while (1) {
	    if (maxBytes == 0) {
		goto done;
	    }
	    segPtr = TkTextIndexToSeg(&textPtr->selIndex, &offsetInSeg);
	    chunkSize = segPtr->size - offsetInSeg;
	    if (chunkSize > maxBytes) {
		chunkSize = maxBytes;
	    }
	    if (textPtr->selIndex.linePtr == search.curIndex.linePtr) {
		int leftInRange;

		leftInRange = search.curIndex.byteIndex
			- textPtr->selIndex.byteIndex;
		if (leftInRange < chunkSize) {
		    chunkSize = leftInRange;
		    if (chunkSize <= 0) {
			break;
		    }
		}
	    }
	    if ((segPtr->typePtr == &tkTextCharType)
		    && !TkTextIsElided(textPtr, &textPtr->selIndex)) {
		memcpy((VOID *) buffer, (VOID *) (segPtr->body.chars
			+ offsetInSeg), (size_t) chunkSize);
		buffer += chunkSize;
		maxBytes -= chunkSize;
		count += chunkSize;
	    }
	    TkTextIndexForwBytes(&textPtr->selIndex, chunkSize,
		    &textPtr->selIndex);
	}

	/*
	 * Find the beginning of the next range of selected text.
	 */

	if (!TkBTreeNextTag(&search)) {
	    break;
	}
	textPtr->selIndex = search.curIndex;
    }

    done:
    *buffer = 0;
    return count;
}

/*
 *----------------------------------------------------------------------
 *
 * TkTextLostSelection --
 *
 *	This procedure is called back by Tk when the selection is
 *	grabbed away from a text widget.  On Windows and Mac systems, we
 *	want to remember the selection for the next time the focus
 *	enters the window.  On Unix, just remove the "sel" tag from
 *	everything in the widget.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The "sel" tag is cleared from the window.
 *
 *----------------------------------------------------------------------
 */

void
TkTextLostSelection(clientData)
    ClientData clientData;		/* Information about text widget. */
{
    register TkText *textPtr = (TkText *) clientData;
    XEvent event;
#ifdef ALWAYS_SHOW_SELECTION
    TkTextIndex start, end;

    if (!textPtr->exportSelection) {
	return;
    }

    /*
     * On Windows and Mac systems, we want to remember the selection
     * for the next time the focus enters the window.  On Unix, 
     * just remove the "sel" tag from everything in the widget.
     */

    TkTextMakeByteIndex(textPtr->tree, 0, 0, &start);
    TkTextMakeByteIndex(textPtr->tree, TkBTreeNumLines(textPtr->tree), 0, &end);
    TkTextRedrawTag(textPtr, &start, &end, textPtr->selTagPtr, 1);
    TkBTreeTag(&start, &end, textPtr->selTagPtr, 0);
#endif

    /*
     * Send an event that the selection changed.  This is equivalent to
     * "event generate $textWidget <<Selection>>"
     */

    memset((VOID *) &event, 0, sizeof(event));
    event.xany.type = VirtualEvent;
    event.xany.serial = NextRequest(Tk_Display(textPtr->tkwin));
    event.xany.send_event = False;
    event.xany.window = Tk_WindowId(textPtr->tkwin);
    event.xany.display = Tk_Display(textPtr->tkwin);
    ((XVirtualEvent *) &event)->name = Tk_GetUid("Selection");
    Tk_HandleEvent(&event);

    textPtr->flags &= ~GOT_SELECTION;
}

/*
 *----------------------------------------------------------------------
 *
 * TextBlinkProc --
 *
 *	This procedure is called as a timer handler to blink the
 *	insertion cursor off and on.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The cursor gets turned on or off, redisplay gets invoked,
 *	and this procedure reschedules itself.
 *
 *----------------------------------------------------------------------
 */

static void
TextBlinkProc(clientData)
    ClientData clientData;	/* Pointer to record describing text. */
{
    register TkText *textPtr = (TkText *) clientData;
    TkTextIndex index;
    int x, y, w, h;

    if ((textPtr->state == TK_STATE_DISABLED) ||
	    !(textPtr->flags & GOT_FOCUS) || (textPtr->insertOffTime == 0)) {
	return;
    }
    if (textPtr->flags & INSERT_ON) {
	textPtr->flags &= ~INSERT_ON;
	textPtr->insertBlinkHandler = Tcl_CreateTimerHandler(
		textPtr->insertOffTime, TextBlinkProc, (ClientData) textPtr);
    } else {
	textPtr->flags |= INSERT_ON;
	textPtr->insertBlinkHandler = Tcl_CreateTimerHandler(
		textPtr->insertOnTime, TextBlinkProc, (ClientData) textPtr);
    }
    TkTextMarkSegToIndex(textPtr, textPtr->insertMarkPtr, &index);
    if (TkTextCharBbox(textPtr, &index, &x, &y, &w, &h) == 0) {
	TkTextRedrawRegion(textPtr, x - textPtr->insertWidth / 2, y,
		textPtr->insertWidth, h);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TextSearchCmd --
 *
 *	This procedure is invoked to process the "search" widget command
 *	for text widgets.  See the user documentation for details on what
 *	it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

static int
TextSearchCmd(textPtr, interp, argc, argv)
    TkText *textPtr;		/* Information about text widget. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int argc;			/* Number of arguments. */
    CONST char **argv;		/* Argument strings. */
{
    int backwards, exact, searchElide, c, i, argsLeft, noCase, leftToScan;
    size_t length;
    int numLines, startingLine, startingByte, lineNum, firstByte, lastByte;
    int code, matchLength, matchByte, passes, stopLine, searchWholeText;
    int patLength;
    CONST char *arg, *pattern, *varName, *p, *startOfLine;
    char buffer[20];
    TkTextIndex index, stopIndex;
    Tcl_DString line, patDString;
    TkTextSegment *segPtr;
    TkTextLine *linePtr;
    TkTextIndex curIndex;
    Tcl_Obj *patObj = NULL;
    Tcl_RegExp regexp = NULL;		/* Initialization needed only to
					 * prevent compiler warning. */

    /*
     * Parse switches and other arguments.
     */

    exact = 1;
    searchElide = 0;
    curIndex.tree = textPtr->tree;
    backwards = 0;
    noCase = 0;
    varName = NULL;
    for (i = 2; i < argc; i++) {
	arg = argv[i];
	if (arg[0] != '-') {
	    break;
	}
	length = strlen(arg);
	if (length < 2) {
	    badSwitch:
	    Tcl_AppendResult(interp, "bad switch \"", arg,
		    "\": must be --, -backward, -count, -elide, -exact, ",
		    "-forward, -nocase, or -regexp", (char *) NULL);
	    return TCL_ERROR;
	}
	c = arg[1];
	if ((c == 'b') && (strncmp(argv[i], "-backwards", length) == 0)) {
	    backwards = 1;
	} else if ((c == 'c') && (strncmp(argv[i], "-count", length) == 0)) {
	    if (i >= (argc-1)) {
		Tcl_SetResult(interp, "no value given for \"-count\" option",
			TCL_STATIC);
		return TCL_ERROR;
	    }
	    i++;
	    varName = argv[i];
	} else if ((c == 'e') && (length > 2)
		&& (strncmp(argv[i], "-exact", length) == 0)) {
	    exact = 1;
	} else if ((c == 'e') && (length > 2)
		&& (strncmp(argv[i], "-elide", length) == 0)) {
	    searchElide = 1;
	} else if ((c == 'h') && (strncmp(argv[i], "-hidden", length) == 0)) {
	    /*
	     * -hidden is kept around for backwards compatibility with
	     * the dash patch, but -elide is the official option
	     */
	    searchElide = 1;
	} else if ((c == 'f') && (strncmp(argv[i], "-forwards", length) == 0)) {
	    backwards = 0;
	} else if ((c == 'n') && (strncmp(argv[i], "-nocase", length) == 0)) {
	    noCase = 1;
	} else if ((c == 'r') && (strncmp(argv[i], "-regexp", length) == 0)) {
	    exact = 0;
	} else if ((c == '-') && (strncmp(argv[i], "--", length) == 0)) {
	    i++;
	    break;
	} else {
	    goto badSwitch;
	}
    }
    argsLeft = argc - (i+2);
    if ((argsLeft != 0) && (argsLeft != 1)) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
		argv[0], " search ?switches? pattern index ?stopIndex?\"",
		(char *) NULL);
	return TCL_ERROR;
    }
    pattern = argv[i];

    /*
     * Convert the pattern to lower-case if we're supposed to ignore case.
     */

    if (noCase && exact) {
	Tcl_DStringInit(&patDString);
	Tcl_DStringAppend(&patDString, pattern, -1);
	Tcl_UtfToLower(Tcl_DStringValue(&patDString));
	pattern = Tcl_DStringValue(&patDString);
    }

    Tcl_DStringInit(&line);
    if (TkTextGetIndex(interp, textPtr, argv[i+1], &index) != TCL_OK) {
	code = TCL_ERROR;
	goto done;
    }
    numLines = TkBTreeNumLines(textPtr->tree);
    startingLine = TkBTreeLineIndex(index.linePtr);
    startingByte = index.byteIndex;
    if (startingLine >= numLines) {
	if (backwards) {
	    startingLine = TkBTreeNumLines(textPtr->tree) - 1;
	    startingByte = TkBTreeBytesInLine(TkBTreeFindLine(textPtr->tree,
		    startingLine));
	} else {
	    startingLine = 0;
	    startingByte = 0;
	}
    }
    if (argsLeft == 1) {
	if (TkTextGetIndex(interp, textPtr, argv[i+2], &stopIndex) != TCL_OK) {
	    code = TCL_ERROR;
	    goto done;
	}
	stopLine = TkBTreeLineIndex(stopIndex.linePtr);
	if (!backwards && (stopLine == numLines)) {
	    stopLine = numLines-1;
	}
	searchWholeText = 0;
    } else {
	stopLine = 0;
	searchWholeText = 1;
    }

    /*
     * Scan through all of the lines of the text circularly, starting
     * at the given index.
     */

    matchLength = patLength = 0;	/* Only needed to prevent compiler
					 * warnings. */
    if (exact) {
	patLength = strlen(pattern);
    } else {
	patObj = Tcl_NewStringObj(pattern, -1);
	Tcl_IncrRefCount(patObj);
	regexp = Tcl_GetRegExpFromObj(interp, patObj,
		(noCase ? TCL_REG_NOCASE : 0) | TCL_REG_ADVANCED);
	if (regexp == NULL) {
	    code = TCL_ERROR;
	    goto done;
	}
    }
    lineNum = startingLine;
    code = TCL_OK;
    for (passes = 0; passes < 2; ) {
	if (lineNum >= numLines) {
	    /*
	     * Don't search the dummy last line of the text.
	     */

	    goto nextLine;
	}

	/*
	 * Extract the text from the line.  If we're doing regular
	 * expression matching, drop the newline from the line, so
	 * that "$" can be used to match the end of the line.
	 */

	linePtr = TkBTreeFindLine(textPtr->tree, lineNum);
	curIndex.linePtr = linePtr; curIndex.byteIndex = 0;
	for (segPtr = linePtr->segPtr; segPtr != NULL;
		curIndex.byteIndex += segPtr->size, segPtr = segPtr->nextPtr) {
	    if ((segPtr->typePtr != &tkTextCharType)
		    || (!searchElide && TkTextIsElided(textPtr, &curIndex))) {
		continue;
	    }
	    Tcl_DStringAppend(&line, segPtr->body.chars, segPtr->size);
	}
	if (!exact) {
	    Tcl_DStringSetLength(&line, Tcl_DStringLength(&line)-1);
	}
	startOfLine = Tcl_DStringValue(&line);

	/*
	 * If we're ignoring case, convert the line to lower case.
	 */

	if (noCase) {
	    Tcl_DStringSetLength(&line,
		    Tcl_UtfToLower(Tcl_DStringValue(&line)));
	}

	/*
	 * Check for matches within the current line.  If so, and if we're
	 * searching backwards, repeat the search to find the last match
	 * in the line.  (Note: The lastByte should include the NULL char
	 * so we can handle searching for end of line easier.)
	 */

	matchByte = -1;
	firstByte = 0;
	lastByte = Tcl_DStringLength(&line) + 1;
	if (lineNum == startingLine) {
	    int indexInDString;

	    /*
	     * The starting line is tricky: the first time we see it
	     * we check one part of the line, and the second pass through
	     * we check the other part of the line.  We have to be very
	     * careful here because there could be embedded windows or
	     * other things that are not in the extracted line.  Rescan
	     * the original line to compute the index in it of the first
	     * character.
	     */

	    indexInDString = startingByte;
	    for (segPtr = linePtr->segPtr, leftToScan = startingByte;
		    leftToScan > 0; segPtr = segPtr->nextPtr) {
		if (segPtr->typePtr != &tkTextCharType) {
		    indexInDString -= segPtr->size;
		}
		leftToScan -= segPtr->size;
	    }

	    passes++;
	    if ((passes == 1) ^ backwards) {
		/*
		 * Only use the last part of the line.
		 */

		firstByte = indexInDString;
		if ((firstByte >= Tcl_DStringLength(&line))
			&& !((Tcl_DStringLength(&line) == 0) && !exact)) {
		    goto nextLine;
		}
	    } else {
		/*
		 * Use only the first part of the line.
		 */

		lastByte = indexInDString;
	    }
	}
	do {
	    int thisLength;
	    Tcl_UniChar ch;

	    if (exact) {
		p = strstr(startOfLine + firstByte,	/* INTL: Native. */
			pattern); 
		if (p == NULL) {
		    break;
		}
		i = p - startOfLine;
		thisLength = patLength;
	    } else {
		CONST char *start, *end;
		int match;

		match = Tcl_RegExpExec(interp, regexp,
			startOfLine + firstByte, startOfLine);
		if (match < 0) {
		    code = TCL_ERROR;
		    goto done;
		}
		if (!match) {
		    break;
		}
		Tcl_RegExpRange(regexp, 0, &start, &end);
		i = start - startOfLine;
		thisLength = end - start;
	    }
	    if (i >= lastByte) {
		break;
	    }
	    matchByte = i;
	    matchLength = thisLength;
	    firstByte = i + Tcl_UtfToUniChar(startOfLine + matchByte, &ch);
	} while (backwards);

	/*
	 * If we found a match then we're done.  Make sure that
	 * the match occurred before the stopping index, if one was
	 * specified.
	 */

	if (matchByte >= 0) {
	    int numChars;

	    /*
	     * Convert the byte length to a character count.
	     */

	    numChars = Tcl_NumUtfChars(startOfLine + matchByte,
		    matchLength);

	    /*
	     * The index information returned by the regular expression
	     * parser only considers textual information:  it doesn't
	     * account for embedded windows, elided text (when we are not
	     * searching elided text) or any other non-textual info.
	     * Scan through the line's segments again to adjust both
	     * matchChar and matchCount.
	     *
	     * We will walk through the segments of this line until we have
	     * either reached the end of the match or we have reached the end
	     * of the line.
	     */

	    curIndex.linePtr = linePtr; curIndex.byteIndex = 0;
	    for (segPtr = linePtr->segPtr, leftToScan = matchByte;
		    leftToScan >= 0 && segPtr; segPtr = segPtr->nextPtr) {
		if (segPtr->typePtr != &tkTextCharType || \
			(!searchElide && TkTextIsElided(textPtr, &curIndex))) {
		    matchByte += segPtr->size;
		} else {
		    leftToScan -= segPtr->size;
		}
		curIndex.byteIndex += segPtr->size;
	    }
	    for (leftToScan += matchLength; leftToScan > 0;
		    segPtr = segPtr->nextPtr) {
		if (segPtr->typePtr != &tkTextCharType) {
		    numChars += segPtr->size;
		    continue;
		}
		leftToScan -= segPtr->size;
	    }
	    TkTextMakeByteIndex(textPtr->tree, lineNum, matchByte, &index);
	    if (!searchWholeText) {
		if (!backwards && (TkTextIndexCmp(&index, &stopIndex) >= 0)) {
		    goto done;
		}
		if (backwards && (TkTextIndexCmp(&index, &stopIndex) < 0)) {
		    goto done;
		}
	    }
	    if (varName != NULL) {
		sprintf(buffer, "%d", numChars);
		if (Tcl_SetVar(interp, varName, buffer, TCL_LEAVE_ERR_MSG)
			== NULL) {
		    code = TCL_ERROR;
		    goto done;
		}
	    }
	    TkTextPrintIndex(&index, buffer);
	    Tcl_SetResult(interp, buffer, TCL_VOLATILE);
	    goto done;
	}

	/*
	 * Go to the next (or previous) line;
	 */

	nextLine:
	if (backwards) {
	    lineNum--;
	    if (!searchWholeText) {
		if (lineNum < stopLine) {
		    break;
		}
	    } else if (lineNum < 0) {
		lineNum = numLines-1;
	    }
	} else {
	    lineNum++;
	    if (!searchWholeText) {
		if (lineNum > stopLine) {
		    break;
		}
	    } else if (lineNum >= numLines) {
		lineNum = 0;
	    }
	}
	Tcl_DStringSetLength(&line, 0);
    }
    done:
    Tcl_DStringFree(&line);
    if (noCase && exact) {
	Tcl_DStringFree(&patDString);
    }
    if (patObj != NULL) {
	Tcl_DecrRefCount(patObj);
    }
    return code;
}

/*
 *----------------------------------------------------------------------
 *
 * TkTextGetTabs --
 *
 *	Parses a string description of a set of tab stops.
 *
 * Results:
 *	The return value is a pointer to a malloc'ed structure holding
 *	parsed information about the tab stops.  If an error occurred
 *	then the return value is NULL and an error message is left in
 *	the interp's result.
 *
 * Side effects:
 *	Memory is allocated for the structure that is returned.  It is
 *	up to the caller to free this structure when it is no longer
 *	needed.
 *
 *----------------------------------------------------------------------
 */

TkTextTabArray *
TkTextGetTabs(interp, tkwin, string)
    Tcl_Interp *interp;			/* Used for error reporting. */
    Tk_Window tkwin;			/* Window in which the tabs will be
					 * used. */
    char *string;			/* Description of the tab stops.  See
					 * the text manual entry for details. */
{
    int argc, i, count, c;
    CONST char **argv;
    TkTextTabArray *tabArrayPtr;
    TkTextTab *tabPtr;
    Tcl_UniChar ch;

    if (Tcl_SplitList(interp, string, &argc, &argv) != TCL_OK) {
	return NULL;
    }

    /*
     * First find out how many entries we need to allocate in the
     * tab array.
     */

    count = 0;
    for (i = 0; i < argc; i++) {
	c = argv[i][0];
	if ((c != 'l') && (c != 'r') && (c != 'c') && (c != 'n')) {
	    count++;
	}
    }

    /*
     * Parse the elements of the list one at a time to fill in the
     * array.
     */

    tabArrayPtr = (TkTextTabArray *) ckalloc((unsigned)
	    (sizeof(TkTextTabArray) + (count-1)*sizeof(TkTextTab)));
    tabArrayPtr->numTabs = 0;
    for (i = 0, tabPtr = &tabArrayPtr->tabs[0]; i  < argc; i++, tabPtr++) {
	if (Tk_GetPixels(interp, tkwin, argv[i], &tabPtr->location)
		!= TCL_OK) {
	    goto error;
	}
	tabArrayPtr->numTabs++;

	/*
	 * See if there is an explicit alignment in the next list
	 * element.  Otherwise just use "left".
	 */

	tabPtr->alignment = LEFT;
	if ((i+1) == argc) {
	    continue;
	}
	Tcl_UtfToUniChar(argv[i+1], &ch);
	if (!Tcl_UniCharIsAlpha(ch)) {
	    continue;
	}
	i += 1;
	c = argv[i][0];
	if ((c == 'l') && (strncmp(argv[i], "left",
		strlen(argv[i])) == 0)) {
	    tabPtr->alignment = LEFT;
	} else if ((c == 'r') && (strncmp(argv[i], "right",
		strlen(argv[i])) == 0)) {
	    tabPtr->alignment = RIGHT;
	} else if ((c == 'c') && (strncmp(argv[i], "center",
		strlen(argv[i])) == 0)) {
	    tabPtr->alignment = CENTER;
	} else if ((c == 'n') && (strncmp(argv[i],
		"numeric", strlen(argv[i])) == 0)) {
	    tabPtr->alignment = NUMERIC;
	} else {
	    Tcl_AppendResult(interp, "bad tab alignment \"",
		    argv[i], "\": must be left, right, center, or numeric",
		    (char *) NULL);
	    goto error;
	}
    }
    ckfree((char *) argv);
    return tabArrayPtr;

    error:
    ckfree((char *) tabArrayPtr);
    ckfree((char *) argv);
    return NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * TextDumpCmd --
 *
 *	Return information about the text, tags, marks, and embedded windows
 *	and images in a text widget.  See the man page for the description
 *	of the text dump operation for all the details.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	Memory is allocated for the result, if needed (standard Tcl result
 *	side effects).
 *
 *----------------------------------------------------------------------
 */

static int
TextDumpCmd(textPtr, interp, argc, argv)
    register TkText *textPtr;	/* Information about text widget. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int argc;			/* Number of arguments. */
    CONST char **argv;		/* Argument strings.  Someone else has already
				 * parsed this command enough to know that
				 * argv[1] is "dump". */
{
    TkTextIndex index1, index2;
    int arg;
    int lineno;			/* Current line number */
    int what = 0;		/* bitfield to select segment types */
    int atEnd;			/* True if dumping up to logical end */
    TkTextLine *linePtr;
    CONST char *command = NULL;	/* Script callback to apply to segments */
#define TK_DUMP_TEXT	0x1
#define TK_DUMP_MARK	0x2
#define TK_DUMP_TAG	0x4
#define TK_DUMP_WIN	0x8
#define TK_DUMP_IMG	0x10
#define TK_DUMP_ALL	(TK_DUMP_TEXT|TK_DUMP_MARK|TK_DUMP_TAG| \
	TK_DUMP_WIN|TK_DUMP_IMG)

    for (arg=2 ; argv[arg] != (char *) NULL ; arg++) {
	size_t len;
	if (argv[arg][0] != '-') {
	    break;
	}
	len = strlen(argv[arg]);
	if (strncmp("-all", argv[arg], len) == 0) {
	    what = TK_DUMP_ALL;
	} else if (strncmp("-text", argv[arg], len) == 0) {
	    what |= TK_DUMP_TEXT;
	} else if (strncmp("-tag", argv[arg], len) == 0) {
	    what |= TK_DUMP_TAG;
	} else if (strncmp("-mark", argv[arg], len) == 0) {
	    what |= TK_DUMP_MARK;
	} else if (strncmp("-image", argv[arg], len) == 0) {
	    what |= TK_DUMP_IMG;
	} else if (strncmp("-window", argv[arg], len) == 0) {
	    what |= TK_DUMP_WIN;
	} else if (strncmp("-command", argv[arg], len) == 0) {
	    arg++;
	    if (arg >= argc) {
		Tcl_AppendResult(interp, "Usage: ", argv[0], " dump ?-all -image -text -mark -tag -window? ?-command script? index ?index2?", NULL);
		return TCL_ERROR;
	    }
	    command = argv[arg];
	} else {
	    Tcl_AppendResult(interp, "Usage: ", argv[0], " dump ?-all -image -text -mark -tag -window? ?-command script? index ?index2?", NULL);
	    return TCL_ERROR;
	}
    }
    if (arg >= argc) {
	Tcl_AppendResult(interp, "Usage: ", argv[0], " dump ?-all -image -text -mark -tag -window? ?-command script? index ?index2?", NULL);
	return TCL_ERROR;
    }
    if (what == 0) {
	what = TK_DUMP_ALL;
    }
    if (TkTextGetIndex(interp, textPtr, argv[arg], &index1) != TCL_OK) {
	return TCL_ERROR;
    }
    lineno = TkBTreeLineIndex(index1.linePtr);
    arg++;
    atEnd = 0;
    if (argc == arg) {
	TkTextIndexForwChars(&index1, 1, &index2);
    } else {
	if (TkTextGetIndex(interp, textPtr, argv[arg], &index2) != TCL_OK) {
	    return TCL_ERROR;
	}
	if (strncmp(argv[arg], "end", strlen(argv[arg])) == 0) {
	    atEnd = 1;
	}
    }
    if (TkTextIndexCmp(&index1, &index2) >= 0) {
	return TCL_OK;
    }
    if (index1.linePtr == index2.linePtr) {
	DumpLine(interp, textPtr, what, index1.linePtr,
	    index1.byteIndex, index2.byteIndex, lineno, command);
    } else {
	DumpLine(interp, textPtr, what, index1.linePtr,
		index1.byteIndex, 32000000, lineno, command);
	linePtr = index1.linePtr;
	while ((linePtr = TkBTreeNextLine(linePtr)) != (TkTextLine *)NULL) {
	    lineno++;
	    if (linePtr == index2.linePtr) {
		break;
	    }
	    DumpLine(interp, textPtr, what, linePtr, 0, 32000000,
		    lineno, command);
	}
	DumpLine(interp, textPtr, what, index2.linePtr, 0,
		index2.byteIndex, lineno, command);
    }
    /*
     * Special case to get the leftovers hiding at the end mark.
     */
    if (atEnd) {
	DumpLine(interp, textPtr, what & ~TK_DUMP_TEXT, index2.linePtr,
		0, 1, lineno, command);			    

    }
    return TCL_OK;
}

/*
 * DumpLine
 * 	Return information about a given text line from character
 *	position "start" up to, but not including, "end".
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	None, but see DumpSegment.
 */
static void
DumpLine(interp, textPtr, what, linePtr, startByte, endByte, lineno, command)
    Tcl_Interp *interp;
    TkText *textPtr;
    int what;			/* bit flags to select segment types */
    TkTextLine *linePtr;	/* The current line */
    int startByte, endByte;	/* Byte range to dump */
    int lineno;			/* Line number for indices dump */
    CONST char *command;	/* Script to apply to the segment */
{
    int offset;
    TkTextSegment *segPtr;
    TkTextIndex index;
    /*
     * Must loop through line looking at its segments.
     * character
     * toggleOn, toggleOff
     * mark
     * image
     * window
     */

    for (offset = 0, segPtr = linePtr->segPtr ;
	    (offset < endByte) && (segPtr != (TkTextSegment *)NULL) ;
	    offset += segPtr->size, segPtr = segPtr->nextPtr) {
	if ((what & TK_DUMP_TEXT) && (segPtr->typePtr == &tkTextCharType) &&
		(offset + segPtr->size > startByte)) {
	    char savedChar;		/* Last char used in the seg */
	    int last = segPtr->size;	/* Index of savedChar */
	    int first = 0;		/* Index of first char in seg */
	    if (offset + segPtr->size > endByte) {
		last = endByte - offset;
	    }
	    if (startByte > offset) {
		first = startByte - offset;
	    }
	    savedChar = segPtr->body.chars[last];
	    segPtr->body.chars[last] = '\0';
	    
	    TkTextMakeByteIndex(textPtr->tree, lineno, offset + first, &index);
	    DumpSegment(interp, "text", segPtr->body.chars + first,
		    command, &index, what);
	    segPtr->body.chars[last] = savedChar;
	} else if ((offset >= startByte)) {
	    if ((what & TK_DUMP_MARK) && (segPtr->typePtr->name[0] == 'm')) {
		TkTextMark *markPtr = (TkTextMark *)&segPtr->body;
		char *name = Tcl_GetHashKey(&textPtr->markTable, markPtr->hPtr);

		TkTextMakeByteIndex(textPtr->tree, lineno, offset, &index);
		DumpSegment(interp, "mark", name, command, &index, what);
	    } else if ((what & TK_DUMP_TAG) &&
			(segPtr->typePtr == &tkTextToggleOnType)) {
		TkTextMakeByteIndex(textPtr->tree, lineno, offset, &index);
		DumpSegment(interp, "tagon",
			segPtr->body.toggle.tagPtr->name,
			command, &index, what);
	    } else if ((what & TK_DUMP_TAG) && 
			(segPtr->typePtr == &tkTextToggleOffType)) {
		TkTextMakeByteIndex(textPtr->tree, lineno, offset, &index);
		DumpSegment(interp, "tagoff",
			segPtr->body.toggle.tagPtr->name,
			command, &index, what);
	    } else if ((what & TK_DUMP_IMG) && 
			(segPtr->typePtr->name[0] == 'i')) {
		TkTextEmbImage *eiPtr = (TkTextEmbImage *)&segPtr->body;
		char *name = (eiPtr->name ==  NULL) ? "" : eiPtr->name;
		TkTextMakeByteIndex(textPtr->tree, lineno, offset, &index);
		DumpSegment(interp, "image", name,
			command, &index, what);
	    } else if ((what & TK_DUMP_WIN) && 
			(segPtr->typePtr->name[0] == 'w')) {
		TkTextEmbWindow *ewPtr = (TkTextEmbWindow *)&segPtr->body;
		char *pathname;
		if (ewPtr->tkwin == (Tk_Window) NULL) {
		    pathname = "";
		} else {
		    pathname = Tk_PathName(ewPtr->tkwin);
		}
		TkTextMakeByteIndex(textPtr->tree, lineno, offset, &index);
		DumpSegment(interp, "window", pathname,
			command, &index, what);
	    }
	}
    }
}

/*
 * DumpSegment
 *	Either append information about the current segment to the result,
 *	or make a script callback with that information as arguments.
 *
 * Results:
 *	None
 *
 * Side effects:
 *	Either evals the callback or appends elements to the result string.
 */
static int
DumpSegment(interp, key, value, command, index, what)
    Tcl_Interp *interp;
    char *key;			/* Segment type key */
    char *value;		/* Segment value */
    CONST char *command;	/* Script callback */
    TkTextIndex *index;         /* index with line/byte position info */
    int what;			/* Look for TK_DUMP_INDEX bit */
{
    char buffer[TCL_INTEGER_SPACE*2];
    TkTextPrintIndex(index, buffer);
    if (command == NULL) {
	Tcl_AppendElement(interp, key);
	Tcl_AppendElement(interp, value);
	Tcl_AppendElement(interp, buffer);
	return TCL_OK;
    } else {
	CONST char *argv[4];
	char *list;
	int result;
	argv[0] = key;
	argv[1] = value;
	argv[2] = buffer;
	argv[3] = NULL;
	list = Tcl_Merge(3, argv);
	result = Tcl_VarEval(interp, command, " ", list, (char *) NULL);
	ckfree(list);
	return result;
    }
}

/*
 * TextEditUndo --
 *    undo the last change.
 *
 * Results:
 *    None
 *
 * Side effects:
 *    None.
 */

static int
TextEditUndo(textPtr)
    TkText     * textPtr;          /* Overall information about text widget. */
{
    int status;

    if (!textPtr->undo) {
       return TCL_OK;
    }

    /* Turn off the undo feature */
    textPtr->undo = 0;

    /* The dirty counter should count downwards as we are undoing things */
    textPtr->isDirtyIncrement = -1;

    /* revert one compound action */
    status = TkUndoRevert(textPtr->undoStack);

    /* Restore the isdirty increment */
    textPtr->isDirtyIncrement = 1;

    /* Turn back on the undo feature */
    textPtr->undo = 1;

    return status;
}

/*
 * TextEditRedo --
 *    redo the last undone change.
 *
 * Results:
 *    None
 *
 * Side effects:
 *    None.
 */

static int
TextEditRedo(textPtr)
    TkText     * textPtr;       /* Overall information about text widget. */
{
    int status;

    if (!textPtr->undo) {
       return TCL_OK;
    }

    /* Turn off the undo feature temporarily */
    textPtr->undo = 0;

    /* reapply one compound action */
    status = TkUndoApply(textPtr->undoStack);

    /* Turn back on the undo feature */
    textPtr->undo = 1;

    return status;
}

/*
 * TextEditCmd --
 *
 *    Handle the subcommands to "$text edit ...".
 *    See documentation for details.
 *
 * Results:
 *    None
 *
 * Side effects:
 *    None.
 */

static int
TextEditCmd(textPtr, interp, argc, argv)
    TkText *textPtr;          /* Information about text widget. */
    Tcl_Interp *interp;       /* Current interpreter. */
    int argc;                 /* Number of arguments. */
    CONST char **argv;        /* Argument strings. */
{
    int      c, setModified;
    size_t   length;

    if (argc < 3) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
		argv[0], " edit option ?arg arg ...?\"", (char *) NULL);
	return TCL_ERROR;
    }
    c = argv[2][0];
    length = strlen(argv[2]);
    if ((c == 'm') && (strncmp(argv[2], "modified", length) == 0)) {
	if (argc == 3) {
	    Tcl_SetObjResult(interp, Tcl_NewBooleanObj(textPtr->isDirty));
	} else if (argc != 4) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " edit modified ?boolean?\"", (char *) NULL);
	    return TCL_ERROR;
	} else {
	    XEvent event;
	    if (Tcl_GetBoolean(interp, argv[3], &setModified) != TCL_OK) {
		return TCL_ERROR;
            }
	    /*
	     * Set or reset the dirty info and trigger a Modified event.
	     */

	    if (setModified) {
		textPtr->isDirty     = 1;
		textPtr->modifiedSet = 1;
	    } else {
		textPtr->isDirty     = 0;
		textPtr->modifiedSet = 0;
	    }

	    /*
	     * Send an event that the text was modified.  This is equivalent to
	     * "event generate $textWidget <<Modified>>"
	     */

	    memset((VOID *) &event, 0, sizeof(event));
	    event.xany.type = VirtualEvent;
	    event.xany.serial = NextRequest(Tk_Display(textPtr->tkwin));
	    event.xany.send_event = False;
	    event.xany.window = Tk_WindowId(textPtr->tkwin);
	    event.xany.display = Tk_Display(textPtr->tkwin);
	    ((XVirtualEvent *) &event)->name = Tk_GetUid("Modified");
	    Tk_HandleEvent(&event);
        }
    } else if ((c == 'r') && (strncmp(argv[2], "redo", length) == 0)
	    && (length >= 3)) {
	if (argc != 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " edit redo\"", (char *) NULL);
	    return TCL_ERROR;
	}
        if ( TextEditRedo(textPtr) ) {
            Tcl_AppendResult(interp, "nothing to redo", (char *) NULL);
	    return TCL_ERROR;
        }
    } else if ((c == 'r') && (strncmp(argv[2], "reset", length) == 0)
	    && (length >= 3)) {
	if (argc != 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " edit reset\"", (char *) NULL);
	    return TCL_ERROR;
	}
        TkUndoClearStacks(textPtr->undoStack);
    } else if ((c == 's') && (strncmp(argv[2], "separator", length) == 0)) {
	if (argc != 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " edit separator\"", (char *) NULL);
	    return TCL_ERROR;
	}
        TkUndoInsertUndoSeparator(textPtr->undoStack);
    } else if ((c == 'u') && (strncmp(argv[2], "undo", length) == 0)) {
	if (argc != 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " edit undo\"", (char *) NULL);
	    return TCL_ERROR;
	}
        if ( TextEditUndo(textPtr) ) {
            Tcl_AppendResult(interp, "nothing to undo",
		    (char *) NULL);
	    return TCL_ERROR;
        }
    } else {
	Tcl_AppendResult(interp, "bad edit option \"", argv[2],
		"\": must be modified, redo, reset, separator or undo",
		(char *) NULL);
	return TCL_ERROR;
    }
    
    return TCL_OK;
}

/*
 * TextGetText --
 *    Returns the text from indexPtr1 to indexPtr2, placing that text
 *    in the Tcl_DString given.  That DString should be free or uninitialized.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Memory will be allocated for the DString.  Remember to free it.
 */

static void 
TextGetText(indexPtr1,indexPtr2, dsPtr)
    TkTextIndex *indexPtr1;
    TkTextIndex *indexPtr2;
    Tcl_DString *dsPtr;
{
    TkTextIndex tmpIndex;
    Tcl_DStringInit(dsPtr);
    
    TkTextMakeByteIndex(indexPtr1->tree, TkBTreeLineIndex(indexPtr1->linePtr),
	    indexPtr1->byteIndex, &tmpIndex);

    if (TkTextIndexCmp(indexPtr1, indexPtr2) < 0) {
	while (1) {
	    int offset, last;
	    TkTextSegment *segPtr;

	    segPtr = TkTextIndexToSeg(&tmpIndex, &offset);
	    last = segPtr->size;
	    if (tmpIndex.linePtr == indexPtr2->linePtr) {
		int last2;

		if (indexPtr2->byteIndex == tmpIndex.byteIndex) {
		    break;
		}
		last2 = indexPtr2->byteIndex - tmpIndex.byteIndex + offset;
		if (last2 < last) {
		    last = last2;
		}
	    }
	    if (segPtr->typePtr == &tkTextCharType) {
		Tcl_DStringAppend(dsPtr, segPtr->body.chars + offset,
			last - offset);
	    }
	    TkTextIndexForwBytes(&tmpIndex, last-offset, &tmpIndex);
	}
    }
}

/*
 * updateDirtyFlag --
 *    increases the dirtyness of the text widget
 *
 * Results:
 *    None
 *
 * Side effects:
 *    None.
 */

static void updateDirtyFlag (textPtr)
    TkText *textPtr;          /* Information about text widget. */
{
    int oldDirtyFlag;

    if (textPtr->modifiedSet) {
        return;
    }
    oldDirtyFlag = textPtr->isDirty;
    textPtr->isDirty += textPtr->isDirtyIncrement;
    if (textPtr->isDirty == 0 || oldDirtyFlag == 0) {
	XEvent event;
	/*
	 * Send an event that the text was modified.  This is equivalent to
	 * "event generate $textWidget <<Modified>>"
	 */

	memset((VOID *) &event, 0, sizeof(event));
	event.xany.type = VirtualEvent;
	event.xany.serial = NextRequest(Tk_Display(textPtr->tkwin));
	event.xany.send_event = False;
	event.xany.window = Tk_WindowId(textPtr->tkwin);
	event.xany.display = Tk_Display(textPtr->tkwin);
	((XVirtualEvent *) &event)->name = Tk_GetUid("Modified");
	Tk_HandleEvent(&event);
    }
}
@


1.5
log
@touched all sources to ease next import
@
text
@d17 1
a17 1
 * RCS: @@(#) $Id: tkText.c,v 1.8.6.2 2000/09/26 16:08:28 spolk Exp $
d23 1
d25 1
a25 1
#ifdef MAC_TCL
d46 3
d94 2
d138 2
a149 4
    /* Red Hat Local */
    {TK_CONFIG_INT, "-tabsize", "tabSize", "TabSize",
	DEF_TEXT_TAB_SIZE, Tk_Offset(TkText, tabsize), 0},
    /* End Red Hat Local */
d166 2
a167 2
			    Tcl_Interp *interp, Tk_Window tkwin, char *value,
			    char *widgRec, int offset));
d201 1
a201 1
    char *value;			/* Value of option (list of tag
d288 2
a289 1
			    TkText *textPtr, int argc, char **argv, int flags));
d291 2
a292 1
			    char *index1String, char *index2String));
d295 1
a295 1
			    TkTextIndex *indexPtr, char *string));
d303 2
d306 3
a308 1
			    Tcl_Interp *interp, int argc, char **argv));
d310 1
a310 1
			    Tcl_Interp *interp, int argc, char **argv));
d314 1
a314 1
			    Tcl_Interp *interp, int argc, char **argv));
d317 2
a318 1
			    int start, int end, int lineno, char *command));
d320 7
a326 2
			    char *value, char * command, TkTextIndex *index,
			    int what));
d333 3
a335 4
static TkClassProcs textClass = {
    NULL,			/* createProc. */
    TextWorldChanged,		/* geometryProc. */
    NULL			/* modalProc. */
d362 1
a362 1
    char **argv;		/* Argument strings. */
d384 5
d390 2
a399 1
    textPtr->numTags = 0;
a403 4
    textPtr->border = NULL;
    textPtr->borderWidth = 0;
    textPtr->padX = 0;
    textPtr->padY = 0;
a404 3
    textPtr->highlightWidth = 0;
    textPtr->highlightBgColorPtr = NULL;
    textPtr->highlightColorPtr = NULL;
a405 2
    textPtr->fgColor = NULL;
    textPtr->tkfont = NULL;
a406 6
    textPtr->spacing1 = 0;
    textPtr->spacing2 = 0;
    textPtr->spacing3 = 0;
    textPtr->tabOptionString = NULL;
    textPtr->tabsize = 8;
    textPtr->tabArrayPtr = NULL;
a407 3
    textPtr->width = 0;
    textPtr->height = 0;
    textPtr->setGrid = 0;
a412 4
    textPtr->selTagPtr = NULL;
    textPtr->selBorder = NULL;
    textPtr->selBdString = NULL;
    textPtr->selFgColorPtr = NULL;
a413 10
    textPtr->abortSelections = 0;
    textPtr->insertMarkPtr = NULL;
    textPtr->insertBorder = NULL;
    textPtr->insertWidth = 0;
    textPtr->insertBorderWidth = 0;
    textPtr->insertOnTime = 0;
    textPtr->insertOffTime = 0;
    textPtr->insertBlinkHandler = (Tcl_TimerToken) NULL;
    textPtr->bindingTable = NULL;
    textPtr->currentMarkPtr = NULL;
d415 5
a419 11
    textPtr->pickEvent.xcrossing.x = 0;
    textPtr->pickEvent.xcrossing.y = 0;
    textPtr->numCurTags = 0;
    textPtr->curTagArrayPtr = NULL;
    textPtr->takeFocus = NULL;
    textPtr->xScrollCmd = NULL;
    textPtr->yScrollCmd = NULL;
    
    /*
     * KHAMIS */
    textPtr->flags = 0;
d434 1
a434 1
    TkSetClassProcs(textPtr->tkwin, &textClass, (ClientData) textPtr);
d452 18
a469 29

static void
ViewArgs (reason, argc, argv, mode)
     char *reason;
     int argc;
     char *argv[];
     int mode;
{
    int i;
    if (reason)
    {
	fprintf (stderr, "%s\nused arguments:\n", reason);
    }
    for (i=0; i<argc; i++)
    {
	if (mode)
	{
	    fprintf (stderr, "%s ", argv[i]);
	}
	else
	{
	    fprintf (stderr, "argv[%i] = [%s]\n", i, argv[i]);
	}
    }
    if (mode && mode != 2)
    {
	fprintf (stderr, "\n");
    }
}
d476 1
a476 1
    char **argv;		/* Argument strings. */
d479 1
a479 1
    int result = TCL_OK;
a480 1
    int c;
d524 1
a524 1
	char *p;
d598 3
a600 4
	    
/*ViewArgs ("editor", argc, argv, 0);*/
	    
	if ((argc != 3) && (argc != 4)) {
d602 1
a602 1
		    argv[0], " delete index1 ?index2?\"", (char *) NULL);
d607 99
a705 2
	    result = DeleteChars(textPtr, argv[2],
		    (argc == 4) ? argv[3] : (char *) NULL);
d728 2
d731 5
a735 1
	if ((argc != 3) && (argc != 4)) {
d737 1
a737 1
		    argv[0], " get index1 ?index2?\"", (char *) NULL);
d741 12
a752 26
	if (TkTextGetIndex(interp, textPtr, argv[2], &index1) != TCL_OK) {
	    result = TCL_ERROR;
	    goto done;
	}
	if (argc == 3) {
	    index2 = index1;
	    TkTextIndexForwChars(&index2, 1, &index2);
	} else if (TkTextGetIndex(interp, textPtr, argv[3], &index2)
		!= TCL_OK) {
	    result = TCL_ERROR;
	    goto done;
	}
	if (TkTextIndexCmp(&index1, &index2) >= 0) {
	    goto done;
	}
	while (1) {
	    int offset, last, savedChar;
	    TkTextSegment *segPtr;

	    segPtr = TkTextIndexToSeg(&index1, &offset);
	    last = segPtr->size;
	    if (index1.linePtr == index2.linePtr) {
		int last2;

		if (index2.byteIndex == index1.byteIndex) {
		    break;
d754 26
a779 3
		last2 = index2.byteIndex - index1.byteIndex + offset;
		if (last2 < last) {
		    last = last2;
d781 1
d783 3
a785 8
	    if (segPtr->typePtr == &tkTextCharType) {
		savedChar = segPtr->body.chars[last];
		segPtr->body.chars[last] = 0;
		Tcl_AppendResult(interp, segPtr->body.chars + offset,
			(char *) NULL);
		segPtr->body.chars[last] = savedChar;
	    }
	    TkTextIndexForwBytes(&index1, last-offset, &index1);
d807 1
a807 1
	char **tagNames;
a809 2
/*ViewArgs ("editor", argc, argv, 0);*/

d874 2
a875 2
		"dlineinfo, dump, get, image, index, insert, mark, scan, ",
		"search, see, tag, window, xview, or yview",
d888 43
d985 1
d1027 1
a1027 1
    char **argv;		/* Arguments. */
d1037 2
d1147 10
d1363 1
a1363 1
    char *string;		/* Null-terminated string containing new
d1368 1
d1397 62
d1491 1
a1491 1
DeleteChars(textPtr, index1String, index2String)
d1493 1
a1493 1
    char *index1String;		/* String describing location of first
d1495 1
a1495 1
    char *index2String;		/* String describing location of last
d1499 6
d1508 1
d1514 2
a1515 6
    if (TkTextGetIndex(textPtr->interp, textPtr, index1String, &index1)
	    != TCL_OK) {
	return TCL_ERROR;
    }
    if (index2String != NULL) {
	if (TkTextGetIndex(textPtr->interp, textPtr, index2String, &index2)
d1519 9
d1529 7
a1535 2
	index2 = index1;
	TkTextIndexForwChars(&index2, 1, &index2);
d1630 62
d1871 1
d1890 15
d1948 4
a1951 3
    TkTextCharBbox(textPtr, &index, &x, &y, &w, &h);
    TkTextRedrawRegion(textPtr, x - textPtr->insertWidth / 2, y,
	    textPtr->insertWidth, h);
d1977 1
a1977 1
    char **argv;		/* Argument strings. */
d1984 1
a1984 1
    char *arg, *pattern, *varName, *p, *startOfLine;
d2070 1
a2071 1
	Tcl_UtfToLower(pattern);
d2231 1
a2231 1
		char *start, *end;
d2392 1
a2392 1
    char **argv;
d2496 1
a2496 1
    char **argv;		/* Argument strings.  Someone else has already
d2506 1
a2506 1
    char *command = NULL;	/* Script callback to apply to segments */
d2619 1
a2619 1
    char *command;		/* Script to apply to the segment */
d2638 3
a2640 3
	    char savedChar;			/* Last char used in the seg */
	    int last = segPtr->size;		/* Index of savedChar */
	    int first = 0;			/* Index of first char in seg */
d2713 1
a2713 1
    char *command;		/* Script callback */
d2719 1
a2719 1
    if (command == (char *) NULL) {
d2725 1
a2725 1
	char *argv[4];
d2731 1
a2731 1
	argv[3] = (char *) NULL;
d2738 211
d2950 4
d2955 4
d2960 55
@


1.4
log
@touched all sources to ease next import
@
text
@@


1.3
log
@        From Mo DeJong  <supermo@@bayarea.net>
        * generic/tkText.c (ExecSyncCmd):
        Remove -synccommand option from Tk text widget.
        This local modification was used by an very old
        version of Source-Navigator, but is no longer
        needed. Remove ExecSyncCmd function.
        * generic/tkText.h (TkText): Remove SyncCmd member.
        * library/msgbox.tcl (tkMessageBox): Remove unused
        -modal option. This was a local mod to tk.
        * tests/text.test: Add default value for -tabsize.
        This is a local mod to tk.
        * tests/wm.test: Fixup iconwindow error messages.
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@d142 1
a142 6
	
    {TK_CONFIG_STRING, "-synccommand", "syncCommand", "SyncCommand",
	DEF_TEXT_YSCROLL_COMMAND, Tk_Offset(TkText, SyncCmd),
	TK_CONFIG_NULL_OK},
	
	
d145 1
a145 1
	
a435 1
    textPtr->SyncCmd = NULL;
a467 48
}

/*
 *--------------------------------------------------------------
 *
 * TextWidgetCmd --
 *
 *	This procedure is invoked to process the Tcl command
 *	that corresponds to a text widget.  See the user
 *	documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *--------------------------------------------------------------
 */
static int 
ExecSyncCmd (interp, textPtr, argc, argv)
     Tcl_Interp *interp;
     TkText *textPtr;
     int argc;
     char *argv[];
{
    static int ExecSyncCmdActive=0;
    int i, ret;
    Tcl_DString cmd;
    
    if (ExecSyncCmdActive)
    {
    	return TCL_OK;
    }
    ExecSyncCmdActive = 1;
    
    Tcl_DStringInit (&cmd);
    Tcl_DStringAppend (&cmd, textPtr->SyncCmd, -1);
    for (i=1;i<argc;i++) {
	Tcl_DStringAppendElement (&cmd, argv[i]);
    }

    ret = Tcl_Eval (interp, Tcl_DStringValue(&cmd));
    Tcl_DStringFree (&cmd);
    
    ExecSyncCmdActive = 0;
    
    return ret;
@


1.1
log
@Initial revision
@
text
@d12 1
d17 1
a17 1
 * RCS: @@(#) $Id: tkText.c,v 1.19 1999/01/26 04:11:26 jingham Exp $
d32 9
d125 2
a126 2
    {TK_CONFIG_UID, "-state", "state", "State",
	DEF_TEXT_STATE, Tk_Offset(TkText, state), 0},
d134 2
a135 2
    {TK_CONFIG_UID, "-wrap", "wrap", "Wrap",
	DEF_TEXT_WRAP, Tk_Offset(TkText, wrapMode), 0},
d156 2
a157 1
 * Tk_Uid's used to represent text states:
d160 78
a237 5
Tk_Uid tkTextCharUid = NULL;
Tk_Uid tkTextDisabledUid = NULL;
Tk_Uid tkTextNoneUid = NULL;
Tk_Uid tkTextNormalUid = NULL;
Tk_Uid tkTextWordUid = NULL;
d240 19
a258 2
 * Boolean variable indicating whether or not special debugging code
 * should be executed.
d261 22
a282 1
int tkTextDebug = 0;
d314 1
a314 1
			    char *value, char * command, int lineno, int offset,
a365 12
     * Perform once-only initialization:
     */

    if (tkTextNormalUid == NULL) {
	tkTextCharUid = Tk_GetUid("char");
	tkTextDisabledUid = Tk_GetUid("disabled");
	tkTextNoneUid = Tk_GetUid("none");
	tkTextNormalUid = Tk_GetUid("normal");
	tkTextWordUid = Tk_GetUid("word");
    }

    /*
d387 1
a387 1
    textPtr->state = tkTextNormalUid;
d406 1
a406 1
    textPtr->wrapMode = tkTextCharUid;
d413 1
a413 1
    TkTextMakeIndex(textPtr->tree, 0, 0, &startIndex);
d449 2
a450 1
    textPtr->selTagPtr->reliefString = (char *) ckalloc(7);
d471 1
a471 1
    interp->result = Tk_PathName(textPtr->tkwin);
d588 4
a591 1
	    sprintf(interp->result, "%d %d %d %d", x, y, width, height);
d649 1
a649 1
	interp->result = (value) ? "1" : "0";
d671 1
a671 1
	    interp->result = (tkBTreeDebug) ? "1" : "0";
d690 1
a690 12
	if (textPtr->state == tkTextNormalUid) {
	    /*
	     * KHAMIS
	     * Call synchronize command
	     * BEFORE INSERTING INTO THE EDITOR
	     ***********************************/
	    if (textPtr->SyncCmd && *textPtr->SyncCmd) {
	    	result = ExecSyncCmd (interp, textPtr, argc, argv);
		if (result == TCL_ERROR) {
		    goto done;
		}
	    }
d710 4
a713 2
	    sprintf(interp->result, "%d %d %d %d %d", x, y, width,
		    height, base);
d746 1
a746 1
		if (index2.charIndex == index1.charIndex) {
d749 1
a749 1
		last2 = index2.charIndex - index1.charIndex + offset;
d761 1
a761 1
	    TkTextIndexForwChars(&index1, last-offset, &index1);
d765 2
d778 2
a779 1
	TkTextPrintIndex(&index1, interp->result);
d800 1
a800 12
	if (textPtr->state == tkTextNormalUid) {
	    /*
	     * KHAMIS
	     * Call synchronize command
	     * BEFORE INSERTING INTO THE EDITOR
	     ***********************************/
	    if (textPtr->SyncCmd && *textPtr->SyncCmd) {
	    	result = ExecSyncCmd (interp, textPtr, argc, argv);
		if (result == TCL_ERROR) {
		    goto done;
		}
	    }
d804 1
a804 1
		    TkTextIndexForwChars(&index1, (int) strlen(argv[j]),
d852 2
a853 2
		"dlineinfo, get, image, index, insert, mark, scan, search, see, ",
		"tag, window, xview, or yview",
d945 1
a945 1
 *	returned, then interp->result contains an error message.
a975 17
    if ((textPtr->state != tkTextNormalUid)
	    && (textPtr->state != tkTextDisabledUid)) {
	Tcl_AppendResult(interp, "bad state value \"", textPtr->state,
		"\": must be normal or disabled", (char *) NULL);
	textPtr->state = tkTextNormalUid;
	return TCL_ERROR;
    }

    if ((textPtr->wrapMode != tkTextCharUid)
	    && (textPtr->wrapMode != tkTextNoneUid)
	    && (textPtr->wrapMode != tkTextWordUid)) {
	Tcl_AppendResult(interp, "bad wrap mode \"", textPtr->wrapMode,
		"\": must be char, none, or word", (char *) NULL);
	textPtr->wrapMode = tkTextCharUid;
	return TCL_ERROR;
    }

d1050 2
a1051 1
	    || (textPtr->selTagPtr->wrapMode != NULL)) {
d1066 2
a1067 2
	TkTextMakeIndex(textPtr->tree, 0, 0, &first);
	TkTextMakeIndex(textPtr->tree,
d1298 1
a1298 1
	TkTextMakeIndex(textPtr->tree, lineIndex, 1000000, indexPtr);
d1311 2
a1312 2
	offset = textPtr->topIndex.charIndex;
	if (offset > indexPtr->charIndex) {
d1319 2
a1320 2
	TkTextMakeIndex(textPtr->tree, lineIndex, 0, &newTop);
	TkTextIndexForwChars(&newTop, offset, &newTop);
d1359 1
a1359 1
    int line1, line2, line, charIndex, resetView;
d1410 1
a1410 1
	if ((index1.charIndex == 0) && (line1 != 0)) {
d1433 3
a1435 1
    resetView = line = charIndex = 0;
d1445 1
a1445 1
	    charIndex = index1.charIndex;
d1454 1
a1454 1
	    charIndex = textPtr->topIndex.charIndex;
d1465 1
a1465 1
	charIndex = textPtr->topIndex.charIndex;
d1467 1
a1467 1
	    charIndex -= index2.charIndex;
d1469 1
a1469 1
	    charIndex -= (index2.charIndex - index1.charIndex);
d1474 1
a1474 1
	TkTextMakeIndex(textPtr->tree, line, charIndex, &index1);
d1538 1
a1538 1
	TkTextMakeIndex(textPtr->tree, 0, 0, &textPtr->selIndex);
d1543 1
a1543 1
    TkTextMakeIndex(textPtr->tree, TkBTreeNumLines(textPtr->tree), 0, &eof);
d1590 2
a1591 2
		leftInRange = search.curIndex.charIndex
			- textPtr->selIndex.charIndex;
d1599 2
a1600 1
	    if (segPtr->typePtr == &tkTextCharType) {
d1607 1
a1607 1
	    TkTextIndexForwChars(&textPtr->selIndex, chunkSize,
d1664 2
a1665 2
    TkTextMakeIndex(textPtr->tree, 0, 0, &start);
    TkTextMakeIndex(textPtr->tree, TkBTreeNumLines(textPtr->tree), 0, &end);
d1698 2
a1699 1
    if (!(textPtr->flags & GOT_FOCUS) || (textPtr->insertOffTime == 0)) {
d1742 1
a1742 1
    int backwards, exact, c, i, argsLeft, noCase, leftToScan;
d1744 2
a1745 2
    int numLines, startingLine, startingChar, lineNum, firstChar, lastChar;
    int code, matchLength, matchChar, passes, stopLine, searchWholeText;
d1753 2
d1763 2
d1777 2
a1778 2
		    "\": must be -forward, -backward, -exact, -regexp, ",
		    "-nocase, -count, or --", (char *) NULL);
d1786 2
a1787 1
		interp->result = "no value given for \"-count\" option";
d1792 2
a1793 1
	} else if ((c == 'e') && (strncmp(argv[i], "-exact", length) == 0)) {
d1795 9
d1820 1
a1820 1
		argv[0], " search ?switches? pattern index ?stopIndex?",
d1830 1
a1830 1
    if (noCase) {
d1834 1
a1834 5
	for (p = pattern; *p != 0; p++) {
	    if (isupper(UCHAR(*p))) {
		*p = tolower(UCHAR(*p));
	    }
	}
d1837 1
d1839 2
a1840 1
	return TCL_ERROR;
d1844 1
a1844 1
    startingChar = index.charIndex;
d1848 1
a1848 1
	    startingChar = TkBTreeCharsInLine(TkBTreeFindLine(textPtr->tree,
d1852 1
a1852 1
	    startingChar = 0;
d1857 2
a1858 1
	    return TCL_ERROR;
d1880 4
a1883 1
	regexp = Tcl_RegExpCompile(interp, pattern);
d1885 2
a1886 1
	    return TCL_ERROR;
a1890 1
    Tcl_DStringInit(&line);
d1907 1
d1909 3
a1911 2
		segPtr = segPtr->nextPtr) {
	    if (segPtr->typePtr != &tkTextCharType) {
d1926 2
a1927 5
	    for (p = Tcl_DStringValue(&line); *p != 0; p++) {
		if (isupper(UCHAR(*p))) {
		    *p = tolower(UCHAR(*p));
		}
	    }
d1933 2
a1934 1
	 * in the line.
d1937 3
a1939 3
	matchChar = -1;
	firstChar = 0;
	lastChar = INT_MAX;
d1953 2
a1954 2
	    indexInDString = startingChar;
	    for (segPtr = linePtr->segPtr, leftToScan = startingChar;
d1968 3
a1970 2
		firstChar = indexInDString;
		if (firstChar >= Tcl_DStringLength(&line)) {
d1978 1
a1978 1
		lastChar = indexInDString;
d1983 2
d1986 2
a1987 1
		p = strstr(startOfLine + firstChar, pattern);
d1998 1
a1998 1
			startOfLine + firstChar, startOfLine);
d2010 1
a2010 1
	    if (i >= lastChar) {
d2013 1
a2013 1
	    matchChar = i;
d2015 1
a2015 1
	    firstChar = matchChar+1;
d2024 10
a2033 1
	if (matchChar >= 0) {
d2037 2
a2038 1
	     * account for embedded windows or any other non-textual info.
d2041 4
d2047 8
a2054 5
	    for (segPtr = linePtr->segPtr, leftToScan = matchChar;
		    leftToScan >= 0; segPtr = segPtr->nextPtr) {
		if (segPtr->typePtr != &tkTextCharType) {
		    matchChar += segPtr->size;
		    continue;
d2056 1
a2056 1
		leftToScan -= segPtr->size;
d2061 1
a2061 1
		    matchLength += segPtr->size;
d2066 1
a2066 1
	    TkTextMakeIndex(textPtr->tree, lineNum, matchChar, &index);
d2076 1
a2076 1
		sprintf(buffer, "%d", matchLength);
d2083 2
a2084 1
	    TkTextPrintIndex(&index, interp->result);
d2116 1
a2116 1
    if (noCase) {
d2119 3
d2136 1
a2136 1
 *	interp->result.
d2158 1
d2201 2
a2202 2
	c = UCHAR(argv[i+1][0]);
	if (!isalpha(c)) {
d2206 1
d2318 1
a2318 1
    lineno = TkBTreeLineIndex(index1.linePtr) + 1;
d2336 1
a2336 1
	    index1.charIndex, index2.charIndex, lineno, command);
d2339 1
a2339 1
		index1.charIndex, 32000000, lineno, command);
d2350 1
a2350 1
		index2.charIndex, lineno, command);
d2357 1
a2357 1
		0, 1, lineno, command);
d2375 1
a2375 1
DumpLine(interp, textPtr, what, linePtr, start, end, lineno, command)
d2380 1
a2380 1
    int start, end;		/* Character range to dump */
d2386 1
d2395 1
d2397 1
a2397 1
	    (offset < end) && (segPtr != (TkTextSegment *)NULL) ;
d2400 1
a2400 1
		(offset + segPtr->size > start)) {
d2404 2
a2405 2
	    if (offset + segPtr->size > end) {
		last = end - offset;
d2407 2
a2408 2
	    if (start > offset) {
		first = start - offset;
d2412 2
d2415 1
a2415 1
		    command, lineno, offset + first, what);
d2417 1
a2417 1
	} else if ((offset >= start)) {
d2421 3
a2423 2
		DumpSegment(interp, "mark", name,
			command, lineno, offset, what);
d2426 1
d2429 1
a2429 1
			command, lineno, offset, what);
d2432 1
d2435 1
a2435 1
			command, lineno, offset, what);
d2440 1
d2442 1
a2442 1
			command, lineno, offset, what);
d2452 1
d2454 1
a2454 1
			command, lineno, offset, what);
d2472 1
a2472 1
DumpSegment(interp, key, value, command, lineno, offset, what)
d2477 1
a2477 2
    int lineno;			/* Line number for indices dump */
    int offset;			/* Character position */
d2480 2
a2481 2
    char buffer[30];
    sprintf(buffer, "%d.%d", lineno, offset);
d2501 2
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@a11 1
 * Copyright (c) 1999 by Scriptics Corporation.
d16 1
a16 1
 * RCS: @@(#) $Id: tkText.c,v 1.8.6.2 2000/09/26 16:08:28 spolk Exp $
a30 9
 * Custom options for handling "-state"
 */

static Tk_CustomOption stateOption = {
    (Tk_OptionParseProc *) TkStateParseProc,
    TkStatePrintProc, (ClientData) NULL /* only "normal" and "disabled" */
};

/*
d115 2
a116 2
    {TK_CONFIG_CUSTOM, "-state", "state", "State",
	DEF_TEXT_STATE, Tk_Offset(TkText, state), 0, &stateOption},
d124 2
a125 2
    {TK_CONFIG_CUSTOM, "-wrap", "wrap", "Wrap",
	DEF_TEXT_WRAP, Tk_Offset(TkText, wrapMode), 0, &textWrapModeOption},
d146 1
a146 2
 * Boolean variable indicating whether or not special debugging code
 * should be executed.
d149 5
a153 1
int tkTextDebug = 0;
d156 2
a157 1
 * Custom options for handling "-wrap":
d160 1
a160 117
static int		WrapModeParseProc _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, Tk_Window tkwin, char *value,
			    char *widgRec, int offset));
static char *		WrapModePrintProc _ANSI_ARGS_((ClientData clientData,
			    Tk_Window tkwin, char *widgRec, int offset,
			    Tcl_FreeProc **freeProcPtr));

Tk_CustomOption textWrapModeOption = {
    WrapModeParseProc,
    WrapModePrintProc,
    (ClientData) NULL
};

/*
 *--------------------------------------------------------------
 *
 * WrapModeParseProc --
 *
 *	This procedure is invoked during option processing to handle
 *	"-wrap" options for text widgets.
 *
 * Results:
 *	A standard Tcl return value.
 *
 * Side effects:
 *	The wrap mode for a given item gets replaced by the wrap mode
 *	indicated in the value argument.
 *
 *--------------------------------------------------------------
 */

static int
WrapModeParseProc(clientData, interp, tkwin, value, widgRec, offset)
    ClientData clientData;		/* some flags.*/
    Tcl_Interp *interp;			/* Used for reporting errors. */
    Tk_Window tkwin;			/* Window containing canvas widget. */
    char *value;			/* Value of option (list of tag
					 * names). */
    char *widgRec;			/* Pointer to record for item. */
    int offset;				/* Offset into item. */
{
    int c;
    size_t length;

    register TkWrapMode *wrapPtr = (TkWrapMode *) (widgRec + offset);

    if(value == NULL || *value == 0) {
	*wrapPtr = TEXT_WRAPMODE_NULL;
	return TCL_OK;
    }

    c = value[0];
    length = strlen(value);

    if ((c == 'c') && (strncmp(value, "char", length) == 0)) {
	*wrapPtr = TEXT_WRAPMODE_CHAR;
	return TCL_OK;
    }
    if ((c == 'n') && (strncmp(value, "none", length) == 0)) {
	*wrapPtr = TEXT_WRAPMODE_NONE;
	return TCL_OK;
    }
    if ((c == 'w') && (strncmp(value, "word", length) == 0)) {
	*wrapPtr = TEXT_WRAPMODE_WORD;
	return TCL_OK;
    }
    Tcl_AppendResult(interp, "bad wrap mode \"", value,
	    "\": must be char, none, or word",
	    (char *) NULL);
    *wrapPtr = TEXT_WRAPMODE_CHAR;
    return TCL_ERROR;
}

/*
 *--------------------------------------------------------------
 *
 * WrapModePrintProc --
 *
 *	This procedure is invoked by the Tk configuration code
 *	to produce a printable string for the "-wrap" configuration
 *	option for canvas items.
 *
 * Results:
 *	The return value is a string describing the state for
 *	the item referred to by "widgRec".  In addition, *freeProcPtr
 *	is filled in with the address of a procedure to call to free
 *	the result string when it's no longer needed (or NULL to
 *	indicate that the string doesn't need to be freed).
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

static char *
WrapModePrintProc(clientData, tkwin, widgRec, offset, freeProcPtr)
    ClientData clientData;		/* Ignored. */
    Tk_Window tkwin;			/* Window containing canvas widget. */
    char *widgRec;			/* Pointer to record for item. */
    int offset;				/* Ignored. */
    Tcl_FreeProc **freeProcPtr;		/* Pointer to variable to fill in with
					 * information about how to reclaim
					 * storage for return string. */
{
    register TkWrapMode *wrapPtr = (TkWrapMode *) (widgRec + offset);

    if (*wrapPtr==TEXT_WRAPMODE_CHAR) {
	return "char";
    } else if (*wrapPtr==TEXT_WRAPMODE_NONE) {
	return "none";
    } else if (*wrapPtr==TEXT_WRAPMODE_WORD) {
	return "word";
    } else {
	return "";
    }
}
d192 1
a192 1
			    char *value, char * command, TkTextIndex *index,
d244 12
d277 1
a277 1
    textPtr->state = TK_STATE_NORMAL;
d296 1
a296 1
    textPtr->wrapMode = TEXT_WRAPMODE_CHAR;
d303 1
a303 1
    TkTextMakeByteIndex(textPtr->tree, 0, 0, &startIndex);
d339 1
a339 2
    textPtr->selTagPtr->reliefString =
	    (char *) ckalloc(sizeof(DEF_TEXT_SELECT_RELIEF));
d360 1
a360 1
    Tcl_SetResult(interp, Tk_PathName(textPtr->tkwin), TCL_STATIC);
d477 1
a477 4
	    char buf[TCL_INTEGER_SPACE * 4];
	    
	    sprintf(buf, "%d %d %d %d", x, y, width, height);
	    Tcl_SetResult(interp, buf, TCL_VOLATILE);
d535 1
a535 1
	Tcl_SetResult(interp, ((value) ? "1" : "0"), TCL_STATIC);
d557 1
a557 1
	    Tcl_SetResult(interp, ((tkBTreeDebug) ? "1" : "0"), TCL_STATIC);
d576 12
a587 1
	if (textPtr->state == TK_STATE_NORMAL) {
d607 2
a608 4
	    char buf[TCL_INTEGER_SPACE * 5];
	    
	    sprintf(buf, "%d %d %d %d %d", x, y, width, height, base);
	    Tcl_SetResult(interp, buf, TCL_VOLATILE);
d641 1
a641 1
		if (index2.byteIndex == index1.byteIndex) {
d644 1
a644 1
		last2 = index2.byteIndex - index1.byteIndex + offset;
d656 1
a656 1
	    TkTextIndexForwBytes(&index1, last-offset, &index1);
a659 2
	char buf[200];

d671 1
a671 2
	TkTextPrintIndex(&index1, buf);
	Tcl_SetResult(interp, buf, TCL_VOLATILE);
d692 12
a703 1
	if (textPtr->state == TK_STATE_NORMAL) {
d707 1
a707 1
		    TkTextIndexForwBytes(&index1, (int) strlen(argv[j]),
d755 2
a756 2
		"dlineinfo, dump, get, image, index, insert, mark, scan, ",
		"search, see, tag, window, xview, or yview",
d848 1
a848 1
 *	returned, then the interp's result contains an error message.
d879 17
d970 1
a970 2
	    || (textPtr->selTagPtr->elideString != NULL)
	    || (textPtr->selTagPtr->wrapMode != TEXT_WRAPMODE_NULL)) {
d985 2
a986 2
	TkTextMakeByteIndex(textPtr->tree, 0, 0, &first);
	TkTextMakeByteIndex(textPtr->tree,
d1217 1
a1217 1
	TkTextMakeByteIndex(textPtr->tree, lineIndex, 1000000, indexPtr);
d1230 2
a1231 2
	offset = textPtr->topIndex.byteIndex;
	if (offset > indexPtr->byteIndex) {
d1238 2
a1239 2
	TkTextMakeByteIndex(textPtr->tree, lineIndex, 0, &newTop);
	TkTextIndexForwBytes(&newTop, offset, &newTop);
d1278 1
a1278 1
    int line1, line2, line, byteIndex, resetView;
d1329 1
a1329 1
	if ((index1.byteIndex == 0) && (line1 != 0)) {
d1352 1
a1352 3
    resetView = 0;
    line = 0;
    byteIndex = 0;
d1362 1
a1362 1
	    byteIndex = index1.byteIndex;
d1371 1
a1371 1
	    byteIndex = textPtr->topIndex.byteIndex;
d1382 1
a1382 1
	byteIndex = textPtr->topIndex.byteIndex;
d1384 1
a1384 1
	    byteIndex -= index2.byteIndex;
d1386 1
a1386 1
	    byteIndex -= (index2.byteIndex - index1.byteIndex);
d1391 1
a1391 1
	TkTextMakeByteIndex(textPtr->tree, line, byteIndex, &index1);
d1455 1
a1455 1
	TkTextMakeByteIndex(textPtr->tree, 0, 0, &textPtr->selIndex);
d1460 1
a1460 1
    TkTextMakeByteIndex(textPtr->tree, TkBTreeNumLines(textPtr->tree), 0, &eof);
d1507 2
a1508 2
		leftInRange = search.curIndex.byteIndex
			- textPtr->selIndex.byteIndex;
d1516 1
a1516 2
	    if ((segPtr->typePtr == &tkTextCharType)
		    && !TkTextIsElided(textPtr, &textPtr->selIndex)) {
d1523 1
a1523 1
	    TkTextIndexForwBytes(&textPtr->selIndex, chunkSize,
d1580 2
a1581 2
    TkTextMakeByteIndex(textPtr->tree, 0, 0, &start);
    TkTextMakeByteIndex(textPtr->tree, TkBTreeNumLines(textPtr->tree), 0, &end);
d1614 1
a1614 2
    if ((textPtr->state == TK_STATE_DISABLED) ||
	    !(textPtr->flags & GOT_FOCUS) || (textPtr->insertOffTime == 0)) {
d1657 1
a1657 1
    int backwards, exact, searchElide, c, i, argsLeft, noCase, leftToScan;
d1659 2
a1660 2
    int numLines, startingLine, startingByte, lineNum, firstByte, lastByte;
    int code, matchLength, matchByte, passes, stopLine, searchWholeText;
a1667 2
    TkTextIndex curIndex;
    Tcl_Obj *patObj = NULL;
a1675 2
    searchElide = 0;
    curIndex.tree = textPtr->tree;
d1688 2
a1689 2
		    "\": must be --, -backward, -count, -elide, -exact, ",
		    "-forward, -nocase, or -regexp", (char *) NULL);
d1697 1
a1697 2
		Tcl_SetResult(interp, "no value given for \"-count\" option",
			TCL_STATIC);
d1702 1
a1702 2
	} else if ((c == 'e') && (length > 2)
		&& (strncmp(argv[i], "-exact", length) == 0)) {
a1703 9
	} else if ((c == 'e') && (length > 2)
		&& (strncmp(argv[i], "-elide", length) == 0)) {
	    searchElide = 1;
	} else if ((c == 'h') && (strncmp(argv[i], "-hidden", length) == 0)) {
	    /*
	     * -hidden is kept around for backwards compatibility with
	     * the dash patch, but -elide is the official option
	     */
	    searchElide = 1;
d1720 1
a1720 1
		argv[0], " search ?switches? pattern index ?stopIndex?\"",
d1730 1
a1730 1
    if (noCase && exact) {
d1734 5
a1738 1
	Tcl_UtfToLower(pattern);
a1740 1
    Tcl_DStringInit(&line);
d1742 1
a1742 2
	code = TCL_ERROR;
	goto done;
d1746 1
a1746 1
    startingByte = index.byteIndex;
d1750 1
a1750 1
	    startingByte = TkBTreeBytesInLine(TkBTreeFindLine(textPtr->tree,
d1754 1
a1754 1
	    startingByte = 0;
d1759 1
a1759 2
	    code = TCL_ERROR;
	    goto done;
d1781 1
a1781 4
	patObj = Tcl_NewStringObj(pattern, -1);
	Tcl_IncrRefCount(patObj);
	regexp = Tcl_GetRegExpFromObj(interp, patObj,
		(noCase ? TCL_REG_NOCASE : 0) | TCL_REG_ADVANCED);
d1783 1
a1783 2
	    code = TCL_ERROR;
	    goto done;
d1788 1
a1804 1
	curIndex.linePtr = linePtr; curIndex.byteIndex = 0;
d1806 2
a1807 3
		curIndex.byteIndex += segPtr->size, segPtr = segPtr->nextPtr) {
	    if ((segPtr->typePtr != &tkTextCharType)
		    || (!searchElide && TkTextIsElided(textPtr, &curIndex))) {
d1822 5
a1826 2
	    Tcl_DStringSetLength(&line,
		    Tcl_UtfToLower(Tcl_DStringValue(&line)));
d1832 1
a1832 2
	 * in the line.  (Note: The lastByte should include the NULL char
	 * so we can handle searching for end of line easier.)
d1835 3
a1837 3
	matchByte = -1;
	firstByte = 0;
	lastByte = Tcl_DStringLength(&line) + 1;
d1851 2
a1852 2
	    indexInDString = startingByte;
	    for (segPtr = linePtr->segPtr, leftToScan = startingByte;
d1866 2
a1867 3
		firstByte = indexInDString;
		if ((firstByte >= Tcl_DStringLength(&line))
			&& !((Tcl_DStringLength(&line) == 0) && !exact)) {
d1875 1
a1875 1
		lastByte = indexInDString;
a1879 2
	    Tcl_UniChar ch;

d1881 1
a1881 2
		p = strstr(startOfLine + firstByte,	/* INTL: Native. */
			pattern); 
d1892 1
a1892 1
			startOfLine + firstByte, startOfLine);
d1904 1
a1904 1
	    if (i >= lastByte) {
d1907 1
a1907 1
	    matchByte = i;
d1909 1
a1909 1
	    firstByte = i + Tcl_UtfToUniChar(startOfLine + matchByte, &ch);
d1918 1
a1918 10
	if (matchByte >= 0) {
	    int numChars;

	    /*
	     * Convert the byte length to a character count.
	     */

	    numChars = Tcl_NumUtfChars(startOfLine + matchByte,
		    matchLength);

d1922 1
a1922 2
	     * account for embedded windows, elided text (when we are not
	     * searching elided text) or any other non-textual info.
a1924 4
	     *
	     * We will walk through the segments of this line until we have
	     * either reached the end of the match or we have reached the end
	     * of the line.
d1927 5
a1931 8
	    curIndex.linePtr = linePtr; curIndex.byteIndex = 0;
	    for (segPtr = linePtr->segPtr, leftToScan = matchByte;
		    leftToScan >= 0 && segPtr; segPtr = segPtr->nextPtr) {
		if (segPtr->typePtr != &tkTextCharType || \
			(!searchElide && TkTextIsElided(textPtr, &curIndex))) {
		    matchByte += segPtr->size;
		} else {
		    leftToScan -= segPtr->size;
d1933 1
a1933 1
		curIndex.byteIndex += segPtr->size;
d1938 1
a1938 1
		    numChars += segPtr->size;
d1943 1
a1943 1
	    TkTextMakeByteIndex(textPtr->tree, lineNum, matchByte, &index);
d1953 1
a1953 1
		sprintf(buffer, "%d", numChars);
d1960 1
a1960 2
	    TkTextPrintIndex(&index, buffer);
	    Tcl_SetResult(interp, buffer, TCL_VOLATILE);
d1992 1
a1992 1
    if (noCase && exact) {
a1994 3
    if (patObj != NULL) {
	Tcl_DecrRefCount(patObj);
    }
d2009 1
a2009 1
 *	the interp's result.
a2030 1
    Tcl_UniChar ch;
d2073 2
a2074 2
	Tcl_UtfToUniChar(argv[i+1], &ch);
	if (!Tcl_UniCharIsAlpha(ch)) {
a2077 1
	c = argv[i][0];
d2189 1
a2189 1
    lineno = TkBTreeLineIndex(index1.linePtr);
d2207 1
a2207 1
	    index1.byteIndex, index2.byteIndex, lineno, command);
d2210 1
a2210 1
		index1.byteIndex, 32000000, lineno, command);
d2221 1
a2221 1
		index2.byteIndex, lineno, command);
d2228 1
a2228 1
		0, 1, lineno, command);			    
d2246 1
a2246 1
DumpLine(interp, textPtr, what, linePtr, startByte, endByte, lineno, command)
d2251 1
a2251 1
    int startByte, endByte;	/* Byte range to dump */
a2256 1
    TkTextIndex index;
a2264 1

d2266 1
a2266 1
	    (offset < endByte) && (segPtr != (TkTextSegment *)NULL) ;
d2269 1
a2269 1
		(offset + segPtr->size > startByte)) {
d2273 2
a2274 2
	    if (offset + segPtr->size > endByte) {
		last = endByte - offset;
d2276 2
a2277 2
	    if (startByte > offset) {
		first = startByte - offset;
a2280 2
	    
	    TkTextMakeByteIndex(textPtr->tree, lineno, offset + first, &index);
d2282 1
a2282 1
		    command, &index, what);
d2284 1
a2284 1
	} else if ((offset >= startByte)) {
d2288 2
a2289 3

		TkTextMakeByteIndex(textPtr->tree, lineno, offset, &index);
		DumpSegment(interp, "mark", name, command, &index, what);
a2291 1
		TkTextMakeByteIndex(textPtr->tree, lineno, offset, &index);
d2294 1
a2294 1
			command, &index, what);
a2296 1
		TkTextMakeByteIndex(textPtr->tree, lineno, offset, &index);
d2299 1
a2299 1
			command, &index, what);
a2303 1
		TkTextMakeByteIndex(textPtr->tree, lineno, offset, &index);
d2305 1
a2305 1
			command, &index, what);
a2314 1
		TkTextMakeByteIndex(textPtr->tree, lineno, offset, &index);
d2316 1
a2316 1
			command, &index, what);
d2334 1
a2334 1
DumpSegment(interp, key, value, command, index, what)
d2339 2
a2340 1
    TkTextIndex *index;         /* index with line/byte position info */
d2343 2
a2344 2
    char buffer[TCL_INTEGER_SPACE*2];
    TkTextPrintIndex(index, buffer);
a2363 2


@


1.1.1.3
log
@import tk 8.4.0
@
text
@d17 1
a17 1
 * RCS: @@(#) $Id: tkText.c,v 1.31 2002/08/31 06:12:27 das Exp $
a22 1
#include "tkUndo.h"
d24 1
a24 1
#if defined(MAC_TCL) || defined(MAC_OSX_TK)
a44 3
    {TK_CONFIG_BOOLEAN, "-autoseparators", "autoSeparators",
        "AutoSeparators", DEF_TEXT_AUTO_SEPARATORS,
        Tk_Offset(TkText, autoSeparators), 0},
a89 2
    {TK_CONFIG_INT, "-maxundo", "maxUndo", "MaxUndo",
	DEF_TEXT_MAX_UNDO, Tk_Offset(TkText, maxUndo), 0},
a131 2
    {TK_CONFIG_BOOLEAN, "-undo", "undo", "Undo",
        DEF_TEXT_UNDO, Tk_Offset(TkText, undo), 0},
d142 9
d167 2
a168 2
			    Tcl_Interp *interp, Tk_Window tkwin,
			    CONST char *value, char *widgRec, int offset));
d202 1
a202 1
    CONST char *value;			/* Value of option (list of tag
d289 1
a289 2
			    TkText *textPtr, int argc, CONST char **argv,
			    int flags));
d291 1
a291 2
			    CONST char *index1String, CONST char *index2String,
			    TkTextIndex *indexPtr1, TkTextIndex *indexPtr2));
d294 1
a294 1
			    TkTextIndex *indexPtr, CONST char *string));
a301 2
static int		TextIndexSortProc _ANSI_ARGS_((CONST VOID *first,
			    CONST VOID *second));
d303 1
a303 3
			    Tcl_Interp *interp, int argc, CONST char **argv));
static int		TextEditCmd _ANSI_ARGS_((TkText *textPtr,
			    Tcl_Interp *interp, int argc, CONST char **argv));
d305 1
a305 1
			    Tcl_Interp *interp, int argc, CONST char **argv));
d309 1
a309 1
			    Tcl_Interp *interp, int argc, CONST char **argv));
d312 1
a312 2
			    int start, int end, int lineno,
			    CONST char *command));
d314 2
a315 7
			    char *value, CONST char * command,
			    TkTextIndex *index, int what));
static int		TextEditUndo _ANSI_ARGS_((TkText *textPtr));
static int		TextEditRedo _ANSI_ARGS_((TkText *textPtr));
static void		TextGetText _ANSI_ARGS_((TkTextIndex * index1,
			    TkTextIndex * index2, Tcl_DString *dsPtr));
static void		updateDirtyFlag _ANSI_ARGS_((TkText *textPtr));
d322 4
a325 3
static Tk_ClassProcs textClass = {
    sizeof(Tk_ClassProcs),	/* size */
    TextWorldChanged,		/* worldChangedProc */
d352 1
a352 1
    CONST char **argv;		/* Argument strings. */
a373 5
    /*
     * Create the text widget and initialize everything to zero,
     * then set the necessary initial (non-NULL) values.
     */

a374 2
    memset((VOID *) textPtr, 0, sizeof(TkText));

d383 1
d388 4
d393 3
d397 2
d400 6
d407 3
d415 4
d420 10
d431 12
a442 5
    textPtr->undoStack = TkUndoInitStack(interp,0);
    textPtr->undo = 1;
    textPtr->isDirtyIncrement = 1;
    textPtr->autoSeparators = 1;
    textPtr->lastEditMode = TK_TEXT_EDIT_OTHER;
d457 1
a457 1
    Tk_SetClassProcs(textPtr->tkwin, &textClass, (ClientData) textPtr);
d493 59
d558 1
a558 1
    CONST char **argv;		/* Argument strings. */
d561 1
a561 1
    int c, result = TCL_OK;
d563 1
d607 1
a607 1
	CONST char *p;
d681 4
a684 3
	int i;

	if (argc < 3) {
d686 1
a686 1
		    argv[0], " delete index1 ?index2 ...?\"", (char *) NULL);
d691 2
a692 99
	    if (argc < 5) {
		/*
		 * Simple case requires no predetermination of indices.
		 */
		result = DeleteChars(textPtr, argv[2],
			(argc == 4) ? argv[3] : NULL, NULL, NULL);
	    } else {
		/*
		 * Multi-index pair case requires that we prevalidate the
		 * indices and sort from last to first so that deletes
		 * occur in the exact (unshifted) text.  It also needs to
		 * handle partial and fully overlapping ranges.  We have to
		 * do this with multiple passes.
		 */
		TkTextIndex *indices, *ixStart, *ixEnd, *lastStart, *lastEnd;
		char *useIdx;

		argc -= 2;
		argv += 2;
		indices = (TkTextIndex *)
		    ckalloc((argc + 1) * sizeof(TkTextIndex));

		/*
		 * First pass verifies that all indices are valid.
		 */
		for (i = 0; i < argc; i++) {
		    if (TkTextGetIndex(interp, textPtr, argv[i],
			    &indices[i]) != TCL_OK) {
			result = TCL_ERROR;
			ckfree((char *) indices);
			goto done;
		    }
		}
		/*
		 * Pad out the pairs evenly to make later code easier.
		 */
		if (argc & 1) {
		    indices[i] = indices[i-1];
		    TkTextIndexForwChars(&indices[i], 1, &indices[i]);
		    argc++;
		}
		useIdx = (char *) ckalloc((unsigned) argc);
		memset(useIdx, 0, (unsigned) argc);
		/*
		 * Do a decreasing order sort so that we delete the end
		 * ranges first to maintain index consistency.
		 */
		qsort((VOID *) indices, (unsigned) (argc / 2),
			2 * sizeof(TkTextIndex), TextIndexSortProc);
		lastStart = lastEnd = NULL;
		/*
		 * Second pass will handle bogus ranges (end < start) and
		 * overlapping ranges.
		 */
		for (i = 0; i < argc; i += 2) {
		    ixStart = &indices[i];
		    ixEnd   = &indices[i+1];
		    if (TkTextIndexCmp(ixEnd, ixStart) <= 0) {
			continue;
		    }
		    if (lastStart) {
			if (TkTextIndexCmp(ixStart, lastStart) == 0) {
			    /*
			     * Start indices were equal, and the sort placed
			     * the longest range first, so skip this one.
			     */
			    continue;
			} else if (TkTextIndexCmp(lastStart, ixEnd) < 0) {
			    /*
			     * The next pair has a start range before the end
			     * point of the last range.  Constrain the delete
			     * range, but use the pointer values.
			     */
			    *ixEnd = *lastStart;
			    if (TkTextIndexCmp(ixEnd, ixStart) <= 0) {
				continue;
			    }
			}
		    }
		    lastStart = ixStart;
		    lastEnd   = ixEnd;
		    useIdx[i]   = 1;
		}
		/*
		 * Final pass take the input from the previous and deletes
		 * the ranges which are flagged to be deleted.
		 */
		for (i = 0; i < argc; i += 2) {
		    if (useIdx[i]) {
			/*
			 * We don't need to check the return value because all
			 * indices are preparsed above.
			 */
			DeleteChars(textPtr, NULL, NULL,
				&indices[i], &indices[i+1]);
		    }
		}
		ckfree((char *) indices);
	    }
a714 2
    } else if ((c == 'e') && (strncmp(argv[1], "edit", length) == 0)) {
        result = TextEditCmd(textPtr, interp, argc, argv);
d716 1
a716 5
	Tcl_Obj *objPtr = NULL;
	Tcl_DString ds;
	int i, found = 0;

	if (argc < 3) {
d718 1
a718 1
		    argv[0], " get index1 ?index2 ...?\"", (char *) NULL);
d722 30
a751 12
	for (i = 2; i < argc; i += 2) {
	    if (TkTextGetIndex(interp, textPtr, argv[i], &index1) != TCL_OK) {
		result = TCL_ERROR;
		goto done;
	    }
	    if (i+1 == argc) {
		index2 = index1;
		TkTextIndexForwChars(&index2, 1, &index2);
	    } else if (TkTextGetIndex(interp, textPtr, argv[i+1], &index2)
		    != TCL_OK) {
		if (objPtr) {
		    Tcl_DecrRefCount(objPtr);
a752 2
		result = TCL_ERROR;
		goto done;
d754 6
a759 25
	    if (TkTextIndexCmp(&index1, &index2) < 0) {
		/* 
		 * Place the text in a DString and move it to the result.
		 * Since this could in principle be a megabyte or more, we
		 * want to do it efficiently!
		 */
		TextGetText(&index1, &index2, &ds);
		found++;
		if (found == 1) {
		    Tcl_DStringResult(interp, &ds);
		} else {
		    if (found == 2) {
			/*
			 * Move the first item we put into the result into
			 * the first element of the list object.
			 */
			objPtr = Tcl_NewObj();
			Tcl_ListObjAppendElement(NULL, objPtr,
				Tcl_GetObjResult(interp));
		    }
		    Tcl_ListObjAppendElement(NULL, objPtr,
			    Tcl_NewStringObj(Tcl_DStringValue(&ds),
				    Tcl_DStringLength(&ds)));
		}
		Tcl_DStringFree(&ds);
d761 1
a761 3
	}
	if (found > 1) {
	    Tcl_SetObjResult(interp, objPtr);
d783 1
a783 1
	CONST char **tagNames;
d786 2
d852 2
a853 2
                "dlineinfo, dump, edit, get, image, index, insert, mark, ",
                "scan, search, see, tag, window, xview, or yview",
a865 43
 * TextIndexSortProc --
 *
 *	This procedure is called by qsort when sorting an array of
 *	indices in *decreasing* order (last to first).
 *
 * Results:
 *	The return value is -1 if the first argument should be before
 *	the second element, 0 if it's equivalent, and 1 if it should be
 *	after the second element.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
TextIndexSortProc(first, second)
    CONST VOID *first, *second;		/* Elements to be compared. */
{
    TkTextIndex *pair1 = (TkTextIndex *) first;
    TkTextIndex *pair2 = (TkTextIndex *) second;
    int cmp = TkTextIndexCmp(&pair1[1], &pair2[1]);

    if (cmp == 0) {
	/*
	 * If the first indices were equal, we want the second index of the
	 * pair also to be the greater.  Use pointer magic to access the
	 * second index pair.
	 */
	cmp = TkTextIndexCmp(&pair1[0], &pair2[0]);
    }
    if (cmp > 0) {
	return -1;
    } else if (cmp < 0) {
	return 1;
    }
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
a919 1
    TkUndoFreeStack(textPtr->undoStack);
d961 1
a961 1
    CONST char **argv;		/* Arguments. */
a970 2
    TkUndoSetDepth(textPtr->undoStack, textPtr->maxUndo);

a1078 10
     * Account for state changes that would reenable blinking cursor state.
     */

    if (textPtr->flags & GOT_FOCUS) {
	Tcl_DeleteTimerHandler(textPtr->insertBlinkHandler);
	textPtr->insertBlinkHandler = (Tcl_TimerToken) NULL;
	TextBlinkProc((ClientData) textPtr);
    }

    /*
d1285 1
a1285 1
    CONST char *string;		/* Null-terminated string containing new
a1289 1
    char indexBuffer[TK_POS_CHARS];
a1317 62

    /*
     * Push the insertion on the undo stack
     */

    if ( textPtr->undo ) {
        TkTextIndex     toIndex;

        Tcl_DString actionCommand;
        Tcl_DString revertCommand;
        
        if (textPtr->autoSeparators &&
            textPtr->lastEditMode != TK_TEXT_EDIT_INSERT) {
            TkUndoInsertUndoSeparator(textPtr->undoStack);
        }
        
        textPtr->lastEditMode = TK_TEXT_EDIT_INSERT;
        
        Tcl_DStringInit(&actionCommand);
        Tcl_DStringInit(&revertCommand);
        
        Tcl_DStringAppend(&actionCommand,Tcl_GetCommandName(textPtr->interp,textPtr->widgetCmd),-1);
        Tcl_DStringAppend(&actionCommand," insert ",-1);
        TkTextPrintIndex(indexPtr,indexBuffer);
        Tcl_DStringAppend(&actionCommand,indexBuffer,-1);
        Tcl_DStringAppend(&actionCommand," ",-1);
        Tcl_DStringAppendElement(&actionCommand,string);
        Tcl_DStringAppend(&actionCommand,";",-1);
        Tcl_DStringAppend(&actionCommand,Tcl_GetCommandName(textPtr->interp,textPtr->widgetCmd),-1);
        Tcl_DStringAppend(&actionCommand," mark set insert ",-1);
        TkTextIndexForwBytes(indexPtr, (int) strlen(string),
			&toIndex);
        TkTextPrintIndex(&toIndex, indexBuffer);
        Tcl_DStringAppend(&actionCommand,indexBuffer,-1);
        Tcl_DStringAppend(&actionCommand,"; ",-1);
        Tcl_DStringAppend(&actionCommand,Tcl_GetCommandName(textPtr->interp,textPtr->widgetCmd),-1);
        Tcl_DStringAppend(&actionCommand," see insert",-1);
        
        Tcl_DStringAppend(&revertCommand,Tcl_GetCommandName(textPtr->interp,textPtr->widgetCmd),-1);
        Tcl_DStringAppend(&revertCommand," delete ",-1);
        TkTextPrintIndex(indexPtr,indexBuffer);
        Tcl_DStringAppend(&revertCommand,indexBuffer,-1);
        Tcl_DStringAppend(&revertCommand," ",-1);
        TkTextPrintIndex(&toIndex, indexBuffer);
        Tcl_DStringAppend(&revertCommand,indexBuffer,-1);
        Tcl_DStringAppend(&revertCommand," ;",-1);
        Tcl_DStringAppend(&revertCommand,Tcl_GetCommandName(textPtr->interp,textPtr->widgetCmd),-1);
        Tcl_DStringAppend(&revertCommand," mark set insert ",-1);
        TkTextPrintIndex(indexPtr,indexBuffer);
        Tcl_DStringAppend(&revertCommand,indexBuffer,-1);
        Tcl_DStringAppend(&revertCommand,"; ",-1);
        Tcl_DStringAppend(&revertCommand,Tcl_GetCommandName(textPtr->interp,textPtr->widgetCmd),-1);
        Tcl_DStringAppend(&revertCommand," see insert",-1);
        
        TkUndoPushAction(textPtr->undoStack,&actionCommand, &revertCommand);

     	Tcl_DStringFree(&actionCommand);
     	Tcl_DStringFree(&revertCommand);

    }
    updateDirtyFlag(textPtr);

d1350 1
a1350 1
DeleteChars(textPtr, index1String, index2String, indexPtr1, indexPtr2)
d1352 1
a1352 1
    CONST char *index1String;	/* String describing location of first
d1354 1
a1354 1
    CONST char *index2String;	/* String describing location of last
a1357 6
    TkTextIndex *indexPtr1;	/* index describing location of first
				 * character to delete. */
    TkTextIndex *indexPtr2;	/* index describing location of last
				 * character to delete.  NULL means just
				 * delete the one character given by
				 * indexPtr1. */
a1360 1
    char indexBuffer[TK_POS_CHARS];
d1366 6
a1371 2
    if (index1String != NULL) {
	if (TkTextGetIndex(textPtr->interp, textPtr, index1String, &index1)
a1374 9
	if (index2String != NULL) {
	    if (TkTextGetIndex(textPtr->interp, textPtr, index2String, &index2)
		    != TCL_OK) {
		return TCL_ERROR;
	    }
	} else {
	    index2 = index1;
	    TkTextIndexForwChars(&index2, 1, &index2);
	}
d1376 2
a1377 7
	index1 = *indexPtr1;
	if (indexPtr2 != NULL) {
	    index2 = *indexPtr2;
	} else {
	    index2 = index1;
	    TkTextIndexForwChars(&index2, 1, &index2);
	}
a1471 62

    /*
     * Push the deletion on the undo stack
     */

    if (textPtr->undo) {
	Tcl_DString ds;
        Tcl_DString actionCommand;
        Tcl_DString revertCommand;
    
	if (textPtr->autoSeparators
		&& (textPtr->lastEditMode != TK_TEXT_EDIT_DELETE)) {
	   TkUndoInsertUndoSeparator(textPtr->undoStack);
	}

	textPtr->lastEditMode = TK_TEXT_EDIT_DELETE;

        Tcl_DStringInit(&actionCommand);
        Tcl_DStringInit(&revertCommand);

        Tcl_DStringAppend(&actionCommand,Tcl_GetCommandName(textPtr->interp,textPtr->widgetCmd),-1);
        Tcl_DStringAppend(&actionCommand," delete ",-1);
        TkTextPrintIndex(&index1,indexBuffer);
        Tcl_DStringAppend(&actionCommand,indexBuffer,-1);
        Tcl_DStringAppend(&actionCommand," ",-1);
        TkTextPrintIndex(&index2, indexBuffer);
        Tcl_DStringAppend(&actionCommand,indexBuffer,-1);
        Tcl_DStringAppend(&actionCommand,"; ",-1);
        Tcl_DStringAppend(&actionCommand,Tcl_GetCommandName(textPtr->interp,textPtr->widgetCmd),-1);
        Tcl_DStringAppend(&actionCommand," mark set insert ",-1);
        TkTextPrintIndex(&index1,indexBuffer);
        Tcl_DStringAppend(&actionCommand,indexBuffer,-1);

        Tcl_DStringAppend(&actionCommand,"; ",-1);
        Tcl_DStringAppend(&actionCommand,Tcl_GetCommandName(textPtr->interp,textPtr->widgetCmd),-1);
        Tcl_DStringAppend(&actionCommand," see insert",-1);

	TextGetText(&index1, &index2, &ds);

        Tcl_DStringAppend(&revertCommand,Tcl_GetCommandName(textPtr->interp,textPtr->widgetCmd),-1);
        Tcl_DStringAppend(&revertCommand," insert ",-1);
        TkTextPrintIndex(&index1,indexBuffer);
        Tcl_DStringAppend(&revertCommand,indexBuffer,-1);
        Tcl_DStringAppend(&revertCommand," ",-1);
        Tcl_DStringAppendElement(&revertCommand,Tcl_DStringValue(&ds));
        Tcl_DStringAppend(&revertCommand,"; ",-1);
        Tcl_DStringAppend(&revertCommand,Tcl_GetCommandName(textPtr->interp,textPtr->widgetCmd),-1);
        Tcl_DStringAppend(&revertCommand," mark set insert ",-1);
        TkTextPrintIndex(&index2, indexBuffer);
        Tcl_DStringAppend(&revertCommand,indexBuffer,-1);
        Tcl_DStringAppend(&revertCommand,"; ",-1);
        Tcl_DStringAppend(&revertCommand,Tcl_GetCommandName(textPtr->interp,textPtr->widgetCmd),-1);
        Tcl_DStringAppend(&revertCommand," see insert",-1);

        TkUndoPushAction(textPtr->undoStack,&actionCommand, &revertCommand);

        Tcl_DStringFree(&actionCommand);
        Tcl_DStringFree(&revertCommand);

    }
    updateDirtyFlag(textPtr);

a1650 1
    XEvent event;
a1668 15

    /*
     * Send an event that the selection changed.  This is equivalent to
     * "event generate $textWidget <<Selection>>"
     */

    memset((VOID *) &event, 0, sizeof(event));
    event.xany.type = VirtualEvent;
    event.xany.serial = NextRequest(Tk_Display(textPtr->tkwin));
    event.xany.send_event = False;
    event.xany.window = Tk_WindowId(textPtr->tkwin);
    event.xany.display = Tk_Display(textPtr->tkwin);
    ((XVirtualEvent *) &event)->name = Tk_GetUid("Selection");
    Tk_HandleEvent(&event);

d1740 1
a1740 1
    CONST char **argv;		/* Argument strings. */
d1747 1
a1747 1
    CONST char *arg, *pattern, *varName, *p, *startOfLine;
a1832 1
	Tcl_UtfToLower(Tcl_DStringValue(&patDString));
d1834 1
d1994 1
a1994 1
		CONST char *start, *end;
d2155 1
a2155 1
    CONST char **argv;
d2259 1
a2259 1
    CONST char **argv;		/* Argument strings.  Someone else has already
d2269 1
a2269 1
    CONST char *command = NULL;	/* Script callback to apply to segments */
d2382 1
a2382 1
    CONST char *command;	/* Script to apply to the segment */
d2401 3
a2403 3
	    char savedChar;		/* Last char used in the seg */
	    int last = segPtr->size;	/* Index of savedChar */
	    int first = 0;		/* Index of first char in seg */
d2476 1
a2476 1
    CONST char *command;	/* Script callback */
d2482 1
a2482 1
    if (command == NULL) {
d2488 1
a2488 1
	CONST char *argv[4];
d2494 1
a2494 1
	argv[3] = NULL;
a2500 85

/*
 * TextEditUndo --
 *    undo the last change.
 *
 * Results:
 *    None
 *
 * Side effects:
 *    None.
 */

static int
TextEditUndo(textPtr)
    TkText     * textPtr;          /* Overall information about text widget. */
{
    int status;

    if (!textPtr->undo) {
       return TCL_OK;
    }

    /* Turn off the undo feature */
    textPtr->undo = 0;

    /* The dirty counter should count downwards as we are undoing things */
    textPtr->isDirtyIncrement = -1;

    /* revert one compound action */
    status = TkUndoRevert(textPtr->undoStack);

    /* Restore the isdirty increment */
    textPtr->isDirtyIncrement = 1;

    /* Turn back on the undo feature */
    textPtr->undo = 1;

    return status;
}

/*
 * TextEditRedo --
 *    redo the last undone change.
 *
 * Results:
 *    None
 *
 * Side effects:
 *    None.
 */

static int
TextEditRedo(textPtr)
    TkText     * textPtr;       /* Overall information about text widget. */
{
    int status;

    if (!textPtr->undo) {
       return TCL_OK;
    }

    /* Turn off the undo feature temporarily */
    textPtr->undo = 0;

    /* reapply one compound action */
    status = TkUndoApply(textPtr->undoStack);

    /* Turn back on the undo feature */
    textPtr->undo = 1;

    return status;
}

/*
 * TextEditCmd --
 *
 *    Handle the subcommands to "$text edit ...".
 *    See documentation for details.
 *
 * Results:
 *    None
 *
 * Side effects:
 *    None.
 */
a2501 32
static int
TextEditCmd(textPtr, interp, argc, argv)
    TkText *textPtr;          /* Information about text widget. */
    Tcl_Interp *interp;       /* Current interpreter. */
    int argc;                 /* Number of arguments. */
    CONST char **argv;        /* Argument strings. */
{
    int      c, setModified;
    size_t   length;

    if (argc < 3) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
		argv[0], " edit option ?arg arg ...?\"", (char *) NULL);
	return TCL_ERROR;
    }
    c = argv[2][0];
    length = strlen(argv[2]);
    if ((c == 'm') && (strncmp(argv[2], "modified", length) == 0)) {
	if (argc == 3) {
	    Tcl_SetObjResult(interp, Tcl_NewBooleanObj(textPtr->isDirty));
	} else if (argc != 4) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " edit modified ?boolean?\"", (char *) NULL);
	    return TCL_ERROR;
	} else {
	    XEvent event;
	    if (Tcl_GetBoolean(interp, argv[3], &setModified) != TCL_OK) {
		return TCL_ERROR;
            }
	    /*
	     * Set or reset the dirty info and trigger a Modified event.
	     */
a2502 7
	    if (setModified) {
		textPtr->isDirty     = 1;
		textPtr->modifiedSet = 1;
	    } else {
		textPtr->isDirty     = 0;
		textPtr->modifiedSet = 0;
	    }
a2503 150
	    /*
	     * Send an event that the text was modified.  This is equivalent to
	     * "event generate $textWidget <<Modified>>"
	     */

	    memset((VOID *) &event, 0, sizeof(event));
	    event.xany.type = VirtualEvent;
	    event.xany.serial = NextRequest(Tk_Display(textPtr->tkwin));
	    event.xany.send_event = False;
	    event.xany.window = Tk_WindowId(textPtr->tkwin);
	    event.xany.display = Tk_Display(textPtr->tkwin);
	    ((XVirtualEvent *) &event)->name = Tk_GetUid("Modified");
	    Tk_HandleEvent(&event);
        }
    } else if ((c == 'r') && (strncmp(argv[2], "redo", length) == 0)
	    && (length >= 3)) {
	if (argc != 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " edit redo\"", (char *) NULL);
	    return TCL_ERROR;
	}
        if ( TextEditRedo(textPtr) ) {
            Tcl_AppendResult(interp, "nothing to redo", (char *) NULL);
	    return TCL_ERROR;
        }
    } else if ((c == 'r') && (strncmp(argv[2], "reset", length) == 0)
	    && (length >= 3)) {
	if (argc != 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " edit reset\"", (char *) NULL);
	    return TCL_ERROR;
	}
        TkUndoClearStacks(textPtr->undoStack);
    } else if ((c == 's') && (strncmp(argv[2], "separator", length) == 0)) {
	if (argc != 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " edit separator\"", (char *) NULL);
	    return TCL_ERROR;
	}
        TkUndoInsertUndoSeparator(textPtr->undoStack);
    } else if ((c == 'u') && (strncmp(argv[2], "undo", length) == 0)) {
	if (argc != 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " edit undo\"", (char *) NULL);
	    return TCL_ERROR;
	}
        if ( TextEditUndo(textPtr) ) {
            Tcl_AppendResult(interp, "nothing to undo",
		    (char *) NULL);
	    return TCL_ERROR;
        }
    } else {
	Tcl_AppendResult(interp, "bad edit option \"", argv[2],
		"\": must be modified, redo, reset, separator or undo",
		(char *) NULL);
	return TCL_ERROR;
    }
    
    return TCL_OK;
}

/*
 * TextGetText --
 *    Returns the text from indexPtr1 to indexPtr2, placing that text
 *    in the Tcl_DString given.  That DString should be free or uninitialized.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *    Memory will be allocated for the DString.  Remember to free it.
 */

static void 
TextGetText(indexPtr1,indexPtr2, dsPtr)
    TkTextIndex *indexPtr1;
    TkTextIndex *indexPtr2;
    Tcl_DString *dsPtr;
{
    TkTextIndex tmpIndex;
    Tcl_DStringInit(dsPtr);
    
    TkTextMakeByteIndex(indexPtr1->tree, TkBTreeLineIndex(indexPtr1->linePtr),
	    indexPtr1->byteIndex, &tmpIndex);

    if (TkTextIndexCmp(indexPtr1, indexPtr2) < 0) {
	while (1) {
	    int offset, last;
	    TkTextSegment *segPtr;

	    segPtr = TkTextIndexToSeg(&tmpIndex, &offset);
	    last = segPtr->size;
	    if (tmpIndex.linePtr == indexPtr2->linePtr) {
		int last2;

		if (indexPtr2->byteIndex == tmpIndex.byteIndex) {
		    break;
		}
		last2 = indexPtr2->byteIndex - tmpIndex.byteIndex + offset;
		if (last2 < last) {
		    last = last2;
		}
	    }
	    if (segPtr->typePtr == &tkTextCharType) {
		Tcl_DStringAppend(dsPtr, segPtr->body.chars + offset,
			last - offset);
	    }
	    TkTextIndexForwBytes(&tmpIndex, last-offset, &tmpIndex);
	}
    }
}

/*
 * updateDirtyFlag --
 *    increases the dirtyness of the text widget
 *
 * Results:
 *    None
 *
 * Side effects:
 *    None.
 */

static void updateDirtyFlag (textPtr)
    TkText *textPtr;          /* Information about text widget. */
{
    int oldDirtyFlag;

    if (textPtr->modifiedSet) {
        return;
    }
    oldDirtyFlag = textPtr->isDirty;
    textPtr->isDirty += textPtr->isDirtyIncrement;
    if (textPtr->isDirty == 0 || oldDirtyFlag == 0) {
	XEvent event;
	/*
	 * Send an event that the text was modified.  This is equivalent to
	 * "event generate $textWidget <<Modified>>"
	 */

	memset((VOID *) &event, 0, sizeof(event));
	event.xany.type = VirtualEvent;
	event.xany.serial = NextRequest(Tk_Display(textPtr->tkwin));
	event.xany.send_event = False;
	event.xany.window = Tk_WindowId(textPtr->tkwin);
	event.xany.display = Tk_Display(textPtr->tkwin);
	((XVirtualEvent *) &event)->name = Tk_GetUid("Modified");
	Tk_HandleEvent(&event);
    }
}
@


1.1.1.4
log
@imported tk 8.4.1
@
text
@d17 1
a17 1
 * RCS: @@(#) $Id: tkText.c,v 1.32 2002/10/02 21:23:10 hobbs Exp $
d1948 3
a1950 4
    if (TkTextCharBbox(textPtr, &index, &x, &y, &w, &h) == 0) {
	TkTextRedrawRegion(textPtr, x - textPtr->insertWidth / 2, y,
		textPtr->insertWidth, h);
    }
@


