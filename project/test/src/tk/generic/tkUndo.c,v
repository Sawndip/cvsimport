head	1.3;
access;
symbols
	sid-snapshot-20180601:1.3
	sid-snapshot-20180501:1.3
	sid-snapshot-20180401:1.3
	sid-snapshot-20180301:1.3
	sid-snapshot-20180201:1.3
	sid-snapshot-20180101:1.3
	sid-snapshot-20171201:1.3
	sid-snapshot-20171101:1.3
	sid-snapshot-20171001:1.3
	sid-snapshot-20170901:1.3
	sid-snapshot-20170801:1.3
	sid-snapshot-20170701:1.3
	sid-snapshot-20170601:1.3
	sid-snapshot-20170501:1.3
	sid-snapshot-20170401:1.3
	sid-snapshot-20170301:1.3
	sid-snapshot-20170201:1.3
	sid-snapshot-20170101:1.3
	sid-snapshot-20161201:1.3
	sid-snapshot-20161101:1.3
	sid-snapshot-20160901:1.3
	sid-snapshot-20160801:1.3
	sid-snapshot-20160701:1.3
	sid-snapshot-20160601:1.3
	sid-snapshot-20160501:1.3
	sid-snapshot-20160401:1.3
	sid-snapshot-20160301:1.3
	sid-snapshot-20160201:1.3
	sid-snapshot-20160101:1.3
	sid-snapshot-20151201:1.3
	sid-snapshot-20151101:1.3
	sid-snapshot-20151001:1.3
	sid-snapshot-20150901:1.3
	sid-snapshot-20150801:1.3
	sid-snapshot-20150701:1.3
	sid-snapshot-20150601:1.3
	sid-snapshot-20150501:1.3
	sid-snapshot-20150401:1.3
	sid-snapshot-20150301:1.3
	sid-snapshot-20150201:1.3
	sid-snapshot-20150101:1.3
	sid-snapshot-20141201:1.3
	sid-snapshot-20141101:1.3
	sid-snapshot-20141001:1.3
	sid-snapshot-20140901:1.3
	sid-snapshot-20140801:1.3
	sid-snapshot-20140701:1.3
	sid-snapshot-20140601:1.3
	sid-snapshot-20140501:1.3
	sid-snapshot-20140401:1.3
	sid-snapshot-20140301:1.3
	sid-snapshot-20140201:1.3
	sid-snapshot-20140101:1.3
	sid-snapshot-20131201:1.3
	sid-snapshot-20131101:1.3
	sid-snapshot-20131001:1.3
	sid-snapshot-20130901:1.3
	sid-snapshot-20130801:1.3
	sid-snapshot-20130701:1.3
	sid-snapshot-20130601:1.3
	insight_7_6-2013-04-10-branchpoint:1.3
	gdb_7_6-branch:1.3.0.28
	sid-snapshot-20130501:1.3
	sid-snapshot-20130401:1.3
	sid-snapshot-20130301:1.3
	sid-snapshot-20130201:1.3
	sid-snapshot-20130101:1.3
	sid-snapshot-20121201:1.3
	sid-snapshot-20121101:1.3
	sid-snapshot-20121001:1.3
	sid-snapshot-20120901:1.3
	gdb_7_5-branch:1.3.0.26
	sid-snapshot-20120801:1.3
	sid-snapshot-20120701:1.3
	sid-snapshot-20120601:1.3
	sid-snapshot-20120501:1.3
	sid-snapshot-20120401:1.3
	gdb_7_4-branch:1.3.0.24
	sid-snapshot-20120301:1.3
	sid-snapshot-20120201:1.3
	sid-snapshot-20120101:1.3
	sid-snapshot-20111201:1.3
	sid-snapshot-20111101:1.3
	sid-snapshot-20111001:1.3
	sid-snapshot-20110901:1.3
	gdb_7_3-branch:1.3.0.22
	sid-snapshot-20110801:1.3
	sid-snapshot-20110701:1.3
	sid-snapshot-20110601:1.3
	sid-snapshot-20110501:1.3
	sid-snapshot-20110401:1.3
	sid-snapshot-20110301:1.3
	sid-snapshot-20110201:1.3
	sid-snapshot-20110101:1.3
	sid-snapshot-20101201:1.3
	sid-snapshot-20101101:1.3
	sid-snapshot-20101001:1.3
	sid-snapshot-20100901:1.3
	sid-snapshot-20100801:1.3
	sid-snapshot-20100701:1.3
	sid-snapshot-20100601:1.3
	sid-snapshot-20100501:1.3
	sid-snapshot-20100401:1.3
	sid-snapshot-20100301:1.3
	gdb_7_1-branch:1.3.0.20
	gdb_7_0-branch:1.3.0.18
	sid-snapshot-20100201:1.3
	sid-snapshot-20100101:1.3
	sid-snapshot-20091201:1.3
	sid-snapshot-20091101:1.3
	sid-snapshot-20091001:1.3
	arc-sim-20090309:1.3
	sid-snapshot-20090901:1.3
	sid-snapshot-20090801:1.3
	sid-snapshot-20090701:1.3
	sid-snapshot-20090601:1.3
	sid-snapshot-20090501:1.3
	kevinb-pre-tk8_5_7_merge:1.3
	sid-snapshot-20090401:1.3
	arc-insight_6_8-branch:1.3.0.16
	arc-insight_6_8-branchpoint:1.3
	insight_6_8-branch:1.3.0.14
	insight_6_8-branchpoint:1.3
	sid-snapshot-20090301:1.3
	sid-snapshot-20090201:1.3
	sid-snapshot-20090101:1.3
	sid-snapshot-20081201:1.3
	sid-snapshot-20081101:1.3
	sid-snapshot-20081001:1.3
	sid-snapshot-20080901:1.3
	sid-snapshot-20080801:1.3
	sid-snapshot-20080701:1.3
	sid-snapshot-20080601:1.3
	sid-snapshot-20080501:1.3
	sid-snapshot-20080403:1.3
	sid-snapshot-20080401:1.3
	gdb_6_8-branch:1.3.0.12
	sid-snapshot-20080301:1.3
	sid-snapshot-20080201:1.3
	sid-snapshot-20080101:1.3
	sid-snapshot-20071201:1.3
	sid-snapshot-20071101:1.3
	sid-snapshot-20071001:1.3
	insight_6_6-20070208-release:1.3
	gdb_6_6-branch:1.3.0.10
	gdb_6_6-2006-11-15-branchpoint:1.3
	insight_6_5-20061003-release:1.3
	gdb_6_5-branch:1.3.0.8
	gdb_6_5-2006-05-14-branchpoint:1.3
	gdb_6_4-branch:1.3.0.6
	gdb_6_4-2005-11-01-branchpoint:1.3
	gdb_6_1-2004-04-05-release:1.3
	gdb_6_1-branch:1.3.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.3
	gdb_6_0-2003-10-04-release:1.3
	gdb_6_0-branch:1.3.0.2
	gdb_6_0-2003-06-23-branchpoint:1.3
	TK8_4_1:1.1.1.1
	tcltk840-20020924-branch:1.1.1.1.0.2
	tcltk840-20020924-branchpoint:1.1.1.1
	TK_8_4_0:1.1.1.1
	NET:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2003.01.21.20.24.46;	author hunt;	state Exp;
branches
	1.3.16.1;
next	1.2;

1.2
date	2003.01.21.19.53.13;	author hunt;	state Exp;
branches;
next	1.1;

1.1
date	2002.09.24.20.38.22;	author kseitz;	state Exp;
branches
	1.1.1.1;
next	;

1.3.16.1
date	2009.09.11.04.46.03;	author amylaar;	state Exp;
branches;
next	;

1.1.1.1
date	2002.09.24.20.38.22;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Updated to tk 8.4.1
@
text
@/* 
 * tkUndo.c --
 *
 *	This module provides the implementation of an undo stack.
 *
 * Copyright (c) 2002 by Ludwig Callewaert.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkUndo.c,v 1.1 2002/06/21 23:09:55 hobbs Exp $
 */

#include "tkUndo.h"


/*
 * TkUndoPushStack
 *    Push elem on the stack identified by stack.
 *
 * Results:
 *    None
 *
 * Side effects:
 *    None.
 */
 
void TkUndoPushStack ( stack, elem )
    TkUndoAtom ** stack;
    TkUndoAtom *  elem;
{ 
    elem->next = *stack;
    *stack = elem;
}

/*
 * TkUndoPopStack --
 *    Remove and return the top element from the stack identified by 
 *      stack.
 *
 * Results:
 *    None
 *
 * Side effects:
 *    None.
 */
 
TkUndoAtom * TkUndoPopStack ( stack )
    TkUndoAtom ** stack ;
{ 
    TkUndoAtom * elem = NULL;
    if (*stack != NULL ) {
        elem   = *stack;
        *stack = elem->next;
    }
    return elem;
}

/*
 * TkUndoInsertSeparator --
 *    insert a separator on the stack, indicating a border for
 *      an undo/redo chunk.
 *
 * Results:
 *    None
 *
 * Side effects:
 *    None.
 */
 
int TkUndoInsertSeparator ( stack )
    TkUndoAtom ** stack;
{
    TkUndoAtom * separator;

    if ( *stack != NULL && (*stack)->type != TK_UNDO_SEPARATOR ) {
        separator = (TkUndoAtom *) ckalloc(sizeof(TkUndoAtom));
        separator->type = TK_UNDO_SEPARATOR;
        TkUndoPushStack(stack,separator);
        return 1;
    } else {
        return 0;
    }
}

/*
 * TkUndoClearStack --
 *    Clear an entire undo or redo stack and destroy all elements in it.
 *
 * Results:
 *    None
 *
 * Side effects:
 *    None.
 */

void TkUndoClearStack ( stack )
    TkUndoAtom ** stack;      /* An Undo or Redo stack */
{
    TkUndoAtom * elem;

    while ( (elem = TkUndoPopStack(stack)) ) {
        if ( elem->type != TK_UNDO_SEPARATOR ) {
            Tcl_DecrRefCount(elem->apply);
            Tcl_DecrRefCount(elem->revert);
        }
        ckfree((char *)elem);
    }
    *stack = NULL;
}

/*
 * TkUndoPushAction
 *    Push a new elem on the stack identified by stack.
 *    action and revert are given through Tcl_DStrings
 *
 * Results:
 *    None
 *
 * Side effects:
 *    None.
 */
 
void TkUndoPushAction ( stack, actionScript, revertScript )
    TkUndoRedoStack * stack;      /* An Undo or Redo stack */
    Tcl_DString * actionScript; /* The script to get the action (redo) */
    Tcl_DString * revertScript; /* The script to revert the action (undo) */
{ 
    TkUndoAtom * atom;

    atom = (TkUndoAtom *) ckalloc(sizeof(TkUndoAtom));
    atom->type = TK_UNDO_ACTION;

    atom->apply = Tcl_NewStringObj(Tcl_DStringValue(actionScript),Tcl_DStringLength(actionScript));
    Tcl_IncrRefCount(atom->apply);

    atom->revert = Tcl_NewStringObj(Tcl_DStringValue(revertScript),Tcl_DStringLength(revertScript));
    Tcl_IncrRefCount(atom->revert);

    TkUndoPushStack(&(stack->undoStack), atom);
    TkUndoClearStack(&(stack->redoStack));
}


/*
 * TkUndoInitStack
 *    Initialize a new undo/redo stack
 *
 * Results:
 *    un Undo/Redo stack pointer
 *
 * Side effects:
 *    None.
 */
 
TkUndoRedoStack * TkUndoInitStack ( interp, maxdepth )
    Tcl_Interp * interp;          /* The interpreter */
    int          maxdepth;        /* The maximum stack depth */
{ 
    TkUndoRedoStack * stack;      /* An Undo/Redo stack */
    stack = (TkUndoRedoStack *) ckalloc(sizeof(TkUndoRedoStack));
    stack->undoStack = NULL;
    stack->redoStack = NULL;
    stack->interp    = interp;
    stack->maxdepth  = maxdepth; 
    stack->depth     = 0;
    return stack;
}


/*
 * TkUndoInitStack
 *    Initialize a new undo/redo stack
 *
 * Results:
 *    un Undo/Redo stack pointer
 *
 * Side effects:
 *    None.
 */
 
void TkUndoSetDepth ( stack, maxdepth )
    TkUndoRedoStack * stack;           /* An Undo/Redo stack */
    int               maxdepth;        /* The maximum stack depth */
{
    TkUndoAtom * elem;
    TkUndoAtom * prevelem;
    int sepNumber = 0;
    
    stack->maxdepth = maxdepth;

    if ((stack->maxdepth > 0) && (stack->depth > stack->maxdepth)) {
        /* Maximum stack depth exceeded. We have to remove the last compound
           elements on the stack */
        elem = stack->undoStack;
        prevelem = NULL;
        while ( sepNumber <= stack->maxdepth ) {
            if (elem != NULL && (elem->type == TK_UNDO_SEPARATOR) ) {
                sepNumber++;
            }
            prevelem = elem;
            elem = elem->next;
        }
        prevelem->next = NULL;
        while ( elem ) {
           prevelem = elem;
           elem = elem->next;
           ckfree((char *) elem);
        }
        stack->depth = stack->maxdepth;
    }
}


/*
 * TkUndoClearStacks
 *    Clear both the undo and redo stack
 *
 * Results:
 *    None
 *
 * Side effects:
 *    None.
 */
 
void TkUndoClearStacks ( stack )
    TkUndoRedoStack * stack;      /* An Undo/Redo stack */
{ 
    TkUndoClearStack(&(stack->undoStack));
    TkUndoClearStack(&(stack->redoStack));
    stack->depth = 0;
}


/*
 * TkUndoFreeStack
 *    Clear both the undo and redo stack
 *    also free the memory allocated to the u/r stack pointer
 *
 * Results:
 *    None
 *
 * Side effects:
 *    None.
 */
 
void TkUndoFreeStack ( stack )
    TkUndoRedoStack * stack;      /* An Undo/Redo stack */
{ 
   TkUndoClearStacks(stack);
/*   ckfree((TkUndoRedoStack *) stack); */
   ckfree((char *) stack);
}


/*
 * TkUndoInsertUndoSeparator --
 *    insert a separator on the undo stack, indicating a border for
 *      an undo/redo chunk.
 *
 * Results:
 *    None
 *
 * Side effects:
 *    None.
 */
 
void TkUndoInsertUndoSeparator ( stack )
    TkUndoRedoStack * stack;
{
/*    TkUndoAtom * elem;
    TkUndoAtom * prevelem;
    int sepNumber = 0;
*/
    
    if ( TkUndoInsertSeparator(&(stack->undoStack)) ) {
        ++(stack->depth);
        TkUndoSetDepth(stack,stack->maxdepth);
/*        if ((stack->maxdepth > 0) && (stack->depth > stack->maxdepth)) {
            elem = stack->undoStack;
            prevelem = NULL;
            while ( sepNumber < stack->depth ) {
                if (elem != NULL && (elem->type == TK_UNDO_SEPARATOR) ) {
                    sepNumber++;
                }
                prevelem = elem;
                elem = elem->next;
            }
            prevelem->next = NULL;
            while ( elem ) {
               prevelem = elem;
               elem = elem->next;
               ckfree((char *) elem);
            }
            stack->depth;
        } */
    }
}


/*
 * TkUndoRevert --
 *    Undo a compound action on the stack.
 *
 * Results:
 *    A TCL status code
 *
 * Side effects:
 *    None.
 */
 
int TkUndoRevert ( stack )
    TkUndoRedoStack * stack;
{
    TkUndoAtom * elem;

    /* insert a separator on the undo and the redo stack */

    TkUndoInsertUndoSeparator(stack);
    TkUndoInsertSeparator(&(stack->redoStack));

    /* Pop and skip the first separator if there is one*/

    elem = TkUndoPopStack(&(stack->undoStack));

    if ( elem == NULL ) {
        return TCL_ERROR;
    }

    if ( ( elem != NULL ) && ( elem->type == TK_UNDO_SEPARATOR ) ) {
        ckfree((char *) elem);
        elem = TkUndoPopStack(&(stack->undoStack));
    }
    
    while ( elem && (elem->type != TK_UNDO_SEPARATOR) ) {
        Tcl_EvalObjEx(stack->interp,elem->revert,TCL_EVAL_GLOBAL);
        
        TkUndoPushStack(&(stack->redoStack),elem);
        elem = TkUndoPopStack(&(stack->undoStack));
    }
    
    /* insert a separator on the redo stack */
    
    TkUndoInsertSeparator(&(stack->redoStack));
    
    --(stack->depth);
    
    return TCL_OK;
}


/*
 * TkUndoApply --
 *    Redo a compound action on the stack.
 *
 * Results:
 *    A TCL status code
 *
 * Side effects:
 *    None.
 */
 
int TkUndoApply ( stack )
    TkUndoRedoStack * stack;
{
    TkUndoAtom *elem;

    /* insert a separator on the undo stack */

    TkUndoInsertSeparator(&(stack->undoStack));

    /* Pop and skip the first separator if there is one*/

    elem = TkUndoPopStack(&(stack->redoStack));

    if ( elem == NULL ) {
       return TCL_ERROR;
    }

    if ( ( elem != NULL ) && ( elem->type == TK_UNDO_SEPARATOR ) ) {
        ckfree((char *) elem);
        elem = TkUndoPopStack(&(stack->redoStack));
    }

    while ( elem && (elem->type != TK_UNDO_SEPARATOR) ) {
        Tcl_EvalObjEx(stack->interp,elem->apply,TCL_EVAL_GLOBAL);
        
        TkUndoPushStack(&(stack->undoStack), elem);
        elem = TkUndoPopStack(&(stack->redoStack));
    }

    /* insert a separator on the undo stack */
    
    TkUndoInsertSeparator(&(stack->undoStack));

    ++(stack->depth);
    
    return TCL_OK;
}

@


1.3.16.1
log
@gdb/insight for ARCompact (from Richard Stuckey)
@
text
@d11 1
a11 1
 * RCS: @@(#) $Id: tkUndo.c,v 1.3 2003/01/21 20:24:46 hunt Exp $
@


1.2
log
@touched all sources to ease next import
@
text
@d11 1
a11 1
 * RCS: @@(#) $Id: tkUndo.c,v 1.1.1.1 2002/09/24 20:38:22 kseitz Exp $
@


1.1
log
@Initial revision
@
text
@d11 1
a11 1
 * RCS: @@(#) $Id: tkUndo.c,v 1.1 2002/06/21 23:09:55 hobbs Exp $
@


1.1.1.1
log
@import tk 8.4.0
@
text
@@
