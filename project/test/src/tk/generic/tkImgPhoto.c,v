head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.4
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.20.24.44;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.13;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.25;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.51;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.32;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.14;	author kseitz;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.01.21.19.53.56;	author hunt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@/*
 * tkImgPhoto.c --
 *
 *	Implements images of type "photo" for Tk.  Photo images are
 *	stored in full color (32 bits per pixel including alpha channel)
 *	and displayed using dithering if necessary.
 *
 * Copyright (c) 1994 The Australian National University.
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
 * Copyright (c) 2002 Donal K. Fellows
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * Author: Paul Mackerras (paulus@@cs.anu.edu.au),
 *	   Department of Computer Science,
 *	   Australian National University.
 *
 * RCS: @@(#) $Id: tkImgPhoto.c,v 1.36 2002/10/18 00:48:22 hobbs Exp $
 */

#include "tkInt.h"
#include "tkPort.h"
#include "tclMath.h"
#include <ctype.h>

#ifdef __WIN32__
#include "tkWinInt.h"
#endif

/*
 * Declaration for internal Xlib function used here:
 */

extern int _XInitImageFuncPtrs _ANSI_ARGS_((XImage *image));

/*
 * A signed 8-bit integral type.  If chars are unsigned and the compiler
 * isn't an ANSI one, then we have to use short instead (which wastes
 * space) to get signed behavior.
 */

#if defined(__STDC__) || defined(_AIX)
    typedef signed char schar;
#else
#   ifndef __CHAR_UNSIGNED__
	typedef char schar;
#   else
	typedef short schar;
#   endif
#endif

/*
 * An unsigned 32-bit integral type, used for pixel values.
 * We use int rather than long here to accommodate those systems
 * where longs are 64 bits.
 */

typedef unsigned int pixel;

/*
 * The maximum number of pixels to transmit to the server in a
 * single XPutImage call.
 */

#define MAX_PIXELS 65536

/*
 * The set of colors required to display a photo image in a window depends on:
 *	- the visual used by the window
 *	- the palette, which specifies how many levels of each primary
 *	  color to use, and
 *	- the gamma value for the image.
 *
 * Pixel values allocated for specific colors are valid only for the
 * colormap in which they were allocated.  Sets of pixel values
 * allocated for displaying photos are re-used in other windows if
 * possible, that is, if the display, colormap, palette and gamma
 * values match.  A hash table is used to locate these sets of pixel
 * values, using the following data structure as key:
 */

typedef struct {
    Display *display;		/* Qualifies the colormap resource ID */
    Colormap colormap;		/* Colormap that the windows are using. */
    double gamma;		/* Gamma exponent value for images. */
    Tk_Uid palette;		/* Specifies how many shades of each primary
				 * we want to allocate. */
} ColorTableId;

/*
 * For a particular (display, colormap, palette, gamma) combination,
 * a data structure of the following type is used to store the allocated
 * pixel values and other information:
 */

typedef struct ColorTable {
    ColorTableId id;		/* Information used in selecting this
				 * color table. */
    int	flags;			/* See below. */
    int	refCount;		/* Number of instances using this map. */
    int liveRefCount;		/* Number of instances which are actually
				 * in use, using this map. */
    int	numColors;		/* Number of colors allocated for this map. */

    XVisualInfo	visualInfo;	/* Information about the visual for windows
				 * using this color table. */

    pixel redValues[256];	/* Maps 8-bit values of red intensity
				 * to a pixel value or index in pixelMap. */
    pixel greenValues[256];	/* Ditto for green intensity */
    pixel blueValues[256];	/* Ditto for blue intensity */
    unsigned long *pixelMap;	/* Actual pixel values allocated. */

    unsigned char colorQuant[3][256];
				/* Maps 8-bit intensities to quantized
				 * intensities.  The first index is 0 for
				 * red, 1 for green, 2 for blue. */
} ColorTable;

/*
 * Bit definitions for the flags field of a ColorTable.
 * BLACK_AND_WHITE:		1 means only black and white colors are
 *				available.
 * COLOR_WINDOW:		1 means a full 3-D color cube has been
 *				allocated.
 * DISPOSE_PENDING:		1 means a call to DisposeColorTable has
 *				been scheduled as an idle handler, but it
 *				hasn't been invoked yet.
 * MAP_COLORS:			1 means pixel values should be mapped
 *				through pixelMap.
 */
#ifdef COLOR_WINDOW
#undef COLOR_WINDOW
#endif

#define BLACK_AND_WHITE		1
#define COLOR_WINDOW		2
#define DISPOSE_PENDING		4
#define MAP_COLORS		8

/*
 * Definition of the data associated with each photo image master.
 */

typedef struct PhotoMaster {
    Tk_ImageMaster tkMaster;	/* Tk's token for image master.  NULL means
				 * the image is being deleted. */
    Tcl_Interp *interp;		/* Interpreter associated with the
				 * application using this image. */
    Tcl_Command imageCmd;	/* Token for image command (used to delete
				 * it when the image goes away).  NULL means
				 * the image command has already been
				 * deleted. */
    int	flags;			/* Sundry flags, defined below. */
    int	width, height;		/* Dimensions of image. */
    int userWidth, userHeight;	/* User-declared image dimensions. */
    Tk_Uid palette;		/* User-specified default palette for
				 * instances of this image. */
    double gamma;		/* Display gamma value to correct for. */
    char *fileString;		/* Name of file to read into image. */
    Tcl_Obj *dataString;	/* Object to use as contents of image. */
    Tcl_Obj *format;		/* User-specified format of data in image
				 * file or string value. */
    unsigned char *pix32;	/* Local storage for 32-bit image. */
    int ditherX, ditherY;	/* Location of first incorrectly
				 * dithered pixel in image. */
    TkRegion validRegion;	/* Tk region indicating which parts of
				 * the image have valid image data. */
    struct PhotoInstance *instancePtr;
				/* First in the list of instances
				 * associated with this master. */
} PhotoMaster;

/*
 * Bit definitions for the flags field of a PhotoMaster.
 * COLOR_IMAGE:			1 means that the image has different color
 *				components.
 * IMAGE_CHANGED:		1 means that the instances of this image
 *				need to be redithered.
 */

#define COLOR_IMAGE		1
#define IMAGE_CHANGED		2

/*
 * The following data structure represents all of the instances of
 * a photo image in windows on a given screen that are using the
 * same colormap.
 */

typedef struct PhotoInstance {
    PhotoMaster *masterPtr;	/* Pointer to master for image. */
    Display *display;		/* Display for windows using this instance. */
    Colormap colormap;		/* The image may only be used in windows with
				 * this particular colormap. */
    struct PhotoInstance *nextPtr;
				/* Pointer to the next instance in the list
				 * of instances associated with this master. */
    int refCount;		/* Number of instances using this structure. */
    Tk_Uid palette;		/* Palette for these particular instances. */
    double gamma;		/* Gamma value for these instances. */
    Tk_Uid defaultPalette;	/* Default palette to use if a palette
				 * is not specified for the master. */
    ColorTable *colorTablePtr;	/* Pointer to information about colors
				 * allocated for image display in windows
				 * like this one. */
    Pixmap pixels;		/* X pixmap containing dithered image. */
    int width, height;		/* Dimensions of the pixmap. */
    schar *error;		/* Error image, used in dithering. */
    XImage *imagePtr;		/* Image structure for converted pixels. */
    XVisualInfo visualInfo;	/* Information about the visual that these
				 * windows are using. */
    GC gc;			/* Graphics context for writing images
				 * to the pixmap. */
} PhotoInstance;

/*
 * The following data structure is used to return information
 * from ParseSubcommandOptions:
 */

struct SubcommandOptions {
    int options;		/* Individual bits indicate which
				 * options were specified - see below. */
    Tcl_Obj *name;		/* Name specified without an option. */
    int fromX, fromY;		/* Values specified for -from option. */
    int fromX2, fromY2;		/* Second coordinate pair for -from option. */
    int toX, toY;		/* Values specified for -to option. */
    int toX2, toY2;		/* Second coordinate pair for -to option. */
    int zoomX, zoomY;		/* Values specified for -zoom option. */
    int subsampleX, subsampleY;	/* Values specified for -subsample option. */
    Tcl_Obj *format;		/* Value specified for -format option. */
    XColor *background;		/* Value specified for -background option. */
    int compositingRule;	/* Value specified for -compositingrule opt */
};

/*
 * Bit definitions for use with ParseSubcommandOptions:
 * Each bit is set in the allowedOptions parameter on a call to
 * ParseSubcommandOptions if that option is allowed for the current
 * photo image subcommand.  On return, the bit is set in the options
 * field of the SubcommandOptions structure if that option was specified.
 *
 * OPT_BACKGROUND:		Set if -format option allowed/specified.
 * OPT_COMPOSITE:		Set if -compositingrule option allowed/spec'd.
 * OPT_FORMAT:			Set if -format option allowed/specified.
 * OPT_FROM:			Set if -from option allowed/specified.
 * OPT_GRAYSCALE:		Set if -grayscale option allowed/specified.
 * OPT_SHRINK:			Set if -shrink option allowed/specified.
 * OPT_SUBSAMPLE:		Set if -subsample option allowed/spec'd.
 * OPT_TO:			Set if -to option allowed/specified.
 * OPT_ZOOM:			Set if -zoom option allowed/specified.
 */

#define OPT_BACKGROUND	1
#define OPT_COMPOSITE	2
#define OPT_FORMAT	4
#define OPT_FROM	8
#define OPT_GRAYSCALE	0x10
#define OPT_SHRINK	0x20
#define OPT_SUBSAMPLE	0x40
#define OPT_TO		0x80
#define OPT_ZOOM	0x100

/*
 * List of option names.  The order here must match the order of
 * declarations of the OPT_* constants above.
 */

static char *optionNames[] = {
    "-background",
    "-compositingrule",
    "-format",
    "-from",
    "-grayscale",
    "-shrink",
    "-subsample",
    "-to",
    "-zoom",
    (char *) NULL
};

/*
 * Message to generate when an attempt to resize an image fails due
 * to memory problems.
 */
#define TK_PHOTO_ALLOC_FAILURE_MESSAGE \
	"not enough free memory for image buffer"

/*
 * Functions used in the type record for photo images.
 */

static int		ImgPhotoCreate _ANSI_ARGS_((Tcl_Interp *interp,
			    char *name, int objc, Tcl_Obj *CONST objv[],
			    Tk_ImageType *typePtr, Tk_ImageMaster master,
			    ClientData *clientDataPtr));
static ClientData	ImgPhotoGet _ANSI_ARGS_((Tk_Window tkwin,
			    ClientData clientData));
static void		ImgPhotoDisplay _ANSI_ARGS_((ClientData clientData,
			    Display *display, Drawable drawable,
			    int imageX, int imageY, int width, int height,
			    int drawableX, int drawableY));
static void		ImgPhotoFree _ANSI_ARGS_((ClientData clientData,
			    Display *display));
static void		ImgPhotoDelete _ANSI_ARGS_((ClientData clientData));
static int		ImgPhotoPostscript _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, Tk_Window tkwin,
			    Tk_PostscriptInfo psInfo, int x, int y, int width,
			    int height, int prepass));

/*
 * The type record itself for photo images:
 */

Tk_ImageType tkPhotoImageType = {
    "photo",			/* name */
    ImgPhotoCreate,		/* createProc */
    ImgPhotoGet,		/* getProc */
    ImgPhotoDisplay,		/* displayProc */
    ImgPhotoFree,		/* freeProc */
    ImgPhotoDelete,		/* deleteProc */
    ImgPhotoPostscript,		/* postscriptProc */
    (Tk_ImageType *) NULL	/* nextPtr */
};

typedef struct ThreadSpecificData {
    Tk_PhotoImageFormat *formatList;  /* Pointer to the first in the 
				       * list of known photo image formats.*/
    Tk_PhotoImageFormat *oldFormatList;  /* Pointer to the first in the 
				       * list of known photo image formats.*/
    int initialized;	/* set to 1 if we've initialized the strucuture */
} ThreadSpecificData;
static Tcl_ThreadDataKey dataKey;

/*
 * Default configuration
 */

#define DEF_PHOTO_GAMMA		"1"
#define DEF_PHOTO_HEIGHT	"0"
#define DEF_PHOTO_PALETTE	""
#define DEF_PHOTO_WIDTH		"0"

/*
 * Information used for parsing configuration specifications:
 */
static Tk_ConfigSpec configSpecs[] = {
    {TK_CONFIG_STRING, "-file", (char *) NULL, (char *) NULL,
	 (char *) NULL, Tk_Offset(PhotoMaster, fileString), TK_CONFIG_NULL_OK},
    {TK_CONFIG_DOUBLE, "-gamma", (char *) NULL, (char *) NULL,
	 DEF_PHOTO_GAMMA, Tk_Offset(PhotoMaster, gamma), 0},
    {TK_CONFIG_INT, "-height", (char *) NULL, (char *) NULL,
	 DEF_PHOTO_HEIGHT, Tk_Offset(PhotoMaster, userHeight), 0},
    {TK_CONFIG_UID, "-palette", (char *) NULL, (char *) NULL,
	 DEF_PHOTO_PALETTE, Tk_Offset(PhotoMaster, palette), 0},
    {TK_CONFIG_INT, "-width", (char *) NULL, (char *) NULL,
	 DEF_PHOTO_WIDTH, Tk_Offset(PhotoMaster, userWidth), 0},
    {TK_CONFIG_END, (char *) NULL, (char *) NULL, (char *) NULL,
	 (char *) NULL, 0, 0}
};

/*
 * Hash table used to hash from (display, colormap, palette, gamma)
 * to ColorTable address.
 */

static Tcl_HashTable imgPhotoColorHash;
static int imgPhotoColorHashInitialized;
#define N_COLOR_HASH	(sizeof(ColorTableId) / sizeof(int))

/*
 * Forward declarations
 */

static void		PhotoFormatThreadExitProc _ANSI_ARGS_((
			    ClientData clientData));
static int		ImgPhotoCmd _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
static int		ParseSubcommandOptions _ANSI_ARGS_((
			    struct SubcommandOptions *optPtr,
			    Tcl_Interp *interp, int allowedOptions,
			    int *indexPtr, int objc, Tcl_Obj *CONST objv[]));
static void		ImgPhotoCmdDeletedProc _ANSI_ARGS_((
			    ClientData clientData));
static int		ImgPhotoConfigureMaster _ANSI_ARGS_((
			    Tcl_Interp *interp, PhotoMaster *masterPtr,
			    int objc, Tcl_Obj *CONST objv[], int flags));
static void		ImgPhotoConfigureInstance _ANSI_ARGS_((
			    PhotoInstance *instancePtr));
static int		ImgPhotoSetSize _ANSI_ARGS_((PhotoMaster *masterPtr,
			    int width, int height));
static void		ImgPhotoInstanceSetSize _ANSI_ARGS_((
			    PhotoInstance *instancePtr));
static int		ImgStringWrite _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *formatString,
			    Tk_PhotoImageBlock *blockPtr));
static char *		ImgGetPhoto _ANSI_ARGS_((PhotoMaster *masterPtr,
			    Tk_PhotoImageBlock *blockPtr,
			    struct SubcommandOptions *optPtr));
static int		IsValidPalette _ANSI_ARGS_((PhotoInstance *instancePtr,
			    CONST char *palette));
static int		CountBits _ANSI_ARGS_((pixel mask));
static void		GetColorTable _ANSI_ARGS_((PhotoInstance *instancePtr));
static void		FreeColorTable _ANSI_ARGS_((ColorTable *colorPtr,
			    int force));
static void		AllocateColors _ANSI_ARGS_((ColorTable *colorPtr));
static void		DisposeColorTable _ANSI_ARGS_((ClientData clientData));
static void		DisposeInstance _ANSI_ARGS_((ClientData clientData));
static int		ReclaimColors _ANSI_ARGS_((ColorTableId *id,
			    int numColors));
static int		MatchFileFormat _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Channel chan, char *fileName, Tcl_Obj *formatString,
			    Tk_PhotoImageFormat **imageFormatPtr,
			    int *widthPtr, int *heightPtr, int *oldformat));
static int		MatchStringFormat _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *data, Tcl_Obj *formatString,
			    Tk_PhotoImageFormat **imageFormatPtr,
			    int *widthPtr, int *heightPtr, int *oldformat));
static Tcl_ObjCmdProc *	PhotoOptionFind _ANSI_ARGS_((Tcl_Interp * interp,
			    Tcl_Obj *obj));
static void		DitherInstance _ANSI_ARGS_((PhotoInstance *instancePtr,
			    int x, int y, int width, int height));
static void		PhotoOptionCleanupProc _ANSI_ARGS_((
			    ClientData clientData, Tcl_Interp *interp));

#undef MIN
#define MIN(a, b)	((a) < (b)? (a): (b))
#undef MAX
#define MAX(a, b)	((a) > (b)? (a): (b))

/*
 *----------------------------------------------------------------------
 *
 * Tk_CreateOldPhotoImageFormat, Tk_CreatePhotoImageFormat --
 *
 *	This procedure is invoked by an image file handler to register
 *	a new photo image format and the procedures that handle the
 *	new format.  The procedure is typically invoked during
 *	Tcl_AppInit.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The new image file format is entered into a table used in the
 *	photo image "read" and "write" subcommands.
 *
 *----------------------------------------------------------------------
 */

static void
PhotoFormatThreadExitProc(clientData)
    ClientData clientData;	/* not used */
{
    Tk_PhotoImageFormat *freePtr;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    while (tsdPtr->oldFormatList != NULL) {
	freePtr = tsdPtr->oldFormatList;
	tsdPtr->oldFormatList = tsdPtr->oldFormatList->nextPtr;
	ckfree((char *) freePtr->name);
	ckfree((char *) freePtr);
    }
    while (tsdPtr->formatList != NULL) {
	freePtr = tsdPtr->formatList;
	tsdPtr->formatList = tsdPtr->formatList->nextPtr;
	ckfree((char *) freePtr->name);
	ckfree((char *) freePtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_CreateOldPhotoImageFormat, Tk_CreatePhotoImageFormat --
 *
 *	This procedure is invoked by an image file handler to register
 *	a new photo image format and the procedures that handle the
 *	new format.  The procedure is typically invoked during
 *	Tcl_AppInit.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The new image file format is entered into a table used in the
 *	photo image "read" and "write" subcommands.
 *
 *----------------------------------------------------------------------
 */
void
Tk_CreateOldPhotoImageFormat(formatPtr)
    Tk_PhotoImageFormat *formatPtr;
				/* Structure describing the format.  All of
				 * the fields except "nextPtr" must be filled
				 * in by caller.  Must not have been passed
				 * to Tk_CreatePhotoImageFormat previously. */
{
    Tk_PhotoImageFormat *copyPtr;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    if (!tsdPtr->initialized) {
	tsdPtr->initialized = 1;
	Tcl_CreateThreadExitHandler(PhotoFormatThreadExitProc, NULL);
    }
    copyPtr = (Tk_PhotoImageFormat *) ckalloc(sizeof(Tk_PhotoImageFormat));
    *copyPtr = *formatPtr;
    copyPtr->name = (char *) ckalloc((unsigned) (strlen(formatPtr->name) + 1));
    strcpy(copyPtr->name, formatPtr->name);
    copyPtr->nextPtr = tsdPtr->oldFormatList;
    tsdPtr->oldFormatList = copyPtr;
}

void
Tk_CreatePhotoImageFormat(formatPtr)
    Tk_PhotoImageFormat *formatPtr;
				/* Structure describing the format.  All of
				 * the fields except "nextPtr" must be filled
				 * in by caller.  Must not have been passed
				 * to Tk_CreatePhotoImageFormat previously. */
{
    Tk_PhotoImageFormat *copyPtr;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    if (!tsdPtr->initialized) {
	tsdPtr->initialized = 1;
	Tcl_CreateThreadExitHandler(PhotoFormatThreadExitProc, NULL);
    }
    copyPtr = (Tk_PhotoImageFormat *) ckalloc(sizeof(Tk_PhotoImageFormat));
    *copyPtr = *formatPtr;
    copyPtr->name = (char *) ckalloc((unsigned) (strlen(formatPtr->name) + 1));
    strcpy(copyPtr->name, formatPtr->name);
    if (isupper((unsigned char) *formatPtr->name)) {
	copyPtr->nextPtr = tsdPtr->oldFormatList;
	tsdPtr->oldFormatList = copyPtr;
    } else {
	copyPtr->nextPtr = tsdPtr->formatList;
	tsdPtr->formatList = copyPtr;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ImgPhotoCreate --
 *
 *	This procedure is called by the Tk image code to create
 *	a new photo image.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	The data structure for a new photo image is allocated and
 *	initialized.
 *
 *----------------------------------------------------------------------
 */

static int
ImgPhotoCreate(interp, name, objc, objv, typePtr, master, clientDataPtr)
    Tcl_Interp *interp;		/* Interpreter for application containing
				 * image. */
    char *name;			/* Name to use for image. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects for options (doesn't
				 * include image name or type). */
    Tk_ImageType *typePtr;	/* Pointer to our type record (not used). */
    Tk_ImageMaster master;	/* Token for image, to be used by us in
				 * later callbacks. */
    ClientData *clientDataPtr;	/* Store manager's token for image here;
				 * it will be returned in later callbacks. */
{
    PhotoMaster *masterPtr;

    /*
     * Allocate and initialize the photo image master record.
     */

    masterPtr = (PhotoMaster *) ckalloc(sizeof(PhotoMaster));
    memset((void *) masterPtr, 0, sizeof(PhotoMaster));
    masterPtr->tkMaster = master;
    masterPtr->interp = interp;
    masterPtr->imageCmd = Tcl_CreateObjCommand(interp, name, ImgPhotoCmd,
	    (ClientData) masterPtr, ImgPhotoCmdDeletedProc);
    masterPtr->palette = NULL;
    masterPtr->pix32 = NULL;
    masterPtr->instancePtr = NULL;
    masterPtr->validRegion = TkCreateRegion();

    /*
     * Process configuration options given in the image create command.
     */

    if (ImgPhotoConfigureMaster(interp, masterPtr, objc, objv, 0) != TCL_OK) {
	ImgPhotoDelete((ClientData) masterPtr);
	return TCL_ERROR;
    }

    *clientDataPtr = (ClientData) masterPtr;
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ImgPhotoCmd --
 *
 *	This procedure is invoked to process the Tcl command that
 *	corresponds to a photo image.  See the user documentation
 *	for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

static int
ImgPhotoCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Information about photo master. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    int oldformat = 0;
    static CONST char *photoOptions[] = {
	"blank", "cget", "configure", "copy", "data", "get", "put",
	"read", "redither", "transparency", "write", (char *) NULL
    };
    enum options {
	PHOTO_BLANK, PHOTO_CGET, PHOTO_CONFIGURE, PHOTO_COPY, PHOTO_DATA,
	PHOTO_GET, PHOTO_PUT, PHOTO_READ, PHOTO_REDITHER, PHOTO_TRANS,
	PHOTO_WRITE
    };

    PhotoMaster *masterPtr = (PhotoMaster *) clientData;
    int result, index;
    int x, y, width, height;
    int dataWidth, dataHeight;
    struct SubcommandOptions options;
    int listArgc;
    CONST char **listArgv;
    CONST char **srcArgv;
    unsigned char *pixelPtr;
    Tk_PhotoImageBlock block;
    Tk_Window tkwin;
    XColor color;
    Tk_PhotoImageFormat *imageFormat;
    int imageWidth, imageHeight;
    int matched;
    Tcl_Channel chan;
    Tk_PhotoHandle srcHandle;
    size_t length;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "option ?arg arg ...?");
	return TCL_ERROR;
    }

    if (Tcl_GetIndexFromObj(interp, objv[1], photoOptions, "option", 0,
	    &index) != TCL_OK) {
	Tcl_ObjCmdProc *proc;
	proc = PhotoOptionFind(interp, objv[1]);
	if (proc == (Tcl_ObjCmdProc *) NULL) {
	    return TCL_ERROR;
	}
	return proc(clientData, interp, objc, objv);
    }

    switch ((enum options) index) {
    case PHOTO_BLANK:
	/*
	 * photo blank command - just call Tk_PhotoBlank.
	 */

	if (objc == 2) {
	    Tk_PhotoBlank(masterPtr);
	} else {
	    Tcl_WrongNumArgs(interp, 2, objv, (char *) NULL);
	    return TCL_ERROR;
	}
	break;

    case PHOTO_CGET: {
	char *arg;

	if (objc != 3) {
	    Tcl_WrongNumArgs(interp, 2, objv, "option");
	    return TCL_ERROR;
	}
	arg = Tcl_GetStringFromObj(objv[2], (int *) &length);
	if (strncmp(arg,"-data", length) == 0) {
	    if (masterPtr->dataString) {
		Tcl_SetObjResult(interp, masterPtr->dataString);
	    }
	    return TCL_OK;
	}
	if (strncmp(arg,"-format", length) == 0) {
	    if (masterPtr->format) {
		Tcl_SetObjResult(interp, masterPtr->format);
	    }
	    return TCL_OK;
	}
	Tk_ConfigureValue(interp, Tk_MainWindow(interp), configSpecs,
		(char *) masterPtr, Tcl_GetString(objv[2]), 0);
	break;
    }

    case PHOTO_CONFIGURE:
	/*
	 * photo configure command - handle this in the standard way.
	 */

	if (objc == 2) {
	    Tcl_Obj *obj, *subobj;
	    result = Tk_ConfigureInfo(interp, Tk_MainWindow(interp),
		    configSpecs, (char *) masterPtr, (char *) NULL, 0);
	    if (result != TCL_OK) {
		return result;
	    }
	    obj = Tcl_NewObj();
	    subobj = Tcl_NewStringObj("-data {} {} {}", 14);
	    if (masterPtr->dataString) {
		Tcl_ListObjAppendElement(interp, subobj, masterPtr->dataString);
	    } else {
		Tcl_AppendStringsToObj(subobj, " {}", (char *) NULL);
	    }
	    Tcl_ListObjAppendElement(interp, obj, subobj);
	    subobj = Tcl_NewStringObj("-format {} {} {}", 16);
	    if (masterPtr->format) {
		Tcl_ListObjAppendElement(interp, subobj, masterPtr->format);
	    } else {
		Tcl_AppendStringsToObj(subobj, " {}", (char *) NULL);
	    }
	    Tcl_ListObjAppendElement(interp, obj, subobj);
	    Tcl_ListObjAppendList(interp, obj, Tcl_GetObjResult(interp));
	    Tcl_SetObjResult(interp, obj);
	    return TCL_OK;
	}
	if (objc == 3) {
	    char *arg = Tcl_GetStringFromObj(objv[2], (int *) &length);
	    if (!strncmp(arg, "-data", length)) {
		Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
			"-data {} {} {}", (char *) NULL);
		if (masterPtr->dataString) {
		    Tcl_ListObjAppendElement(interp, Tcl_GetObjResult(interp),
			    masterPtr->dataString);
		} else {
		    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
			    " {}", (char *) NULL);
		}
		return TCL_OK;
	    } else if (!strncmp(arg, "-format", length)) {
		Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
			"-format {} {} {}", (char *) NULL);
		if (masterPtr->format) {
		    Tcl_ListObjAppendElement(interp, Tcl_GetObjResult(interp),
			    masterPtr->format);
		} else {
		    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
			    " {}", (char *) NULL);
		}
		return TCL_OK;
	    } else {
		return Tk_ConfigureInfo(interp, Tk_MainWindow(interp),
			configSpecs, (char *) masterPtr, arg, 0);
	    }
	}
	return ImgPhotoConfigureMaster(interp, masterPtr, objc-2, objv+2,
		TK_CONFIG_ARGV_ONLY);

    case PHOTO_COPY:
	/*
	 * photo copy command - first parse options.
	 */

	index = 2;
	memset((VOID *) &options, 0, sizeof(options));
	options.zoomX = options.zoomY = 1;
	options.subsampleX = options.subsampleY = 1;
	options.name = NULL;
	options.compositingRule = TK_PHOTO_COMPOSITE_OVERLAY;
	if (ParseSubcommandOptions(&options, interp,
		OPT_FROM | OPT_TO | OPT_ZOOM | OPT_SUBSAMPLE | OPT_SHRINK |
		OPT_COMPOSITE, &index, objc, objv) != TCL_OK) {
	    return TCL_ERROR;
	}
	if (options.name == NULL || index < objc) {
	    Tcl_WrongNumArgs(interp, 2, objv,
		    "source-image ?-compositingrule rule? ?-from x1 y1 x2 y2? ?-to x1 y1 x2 y2? ?-zoom x y? ?-subsample x y?");
	    return TCL_ERROR;
	}

	/*
	 * Look for the source image and get a pointer to its image data.
	 * Check the values given for the -from option.
	 */

	srcHandle = Tk_FindPhoto(interp, Tcl_GetString(options.name));
	if (srcHandle == NULL) {
	    Tcl_AppendResult(interp, "image \"",
		    Tcl_GetString(options.name), "\" doesn't",
		    " exist or is not a photo image", (char *) NULL);
	    return TCL_ERROR;
	}
	Tk_PhotoGetImage(srcHandle, &block);
	if ((options.fromX2 > block.width) || (options.fromY2 > block.height)
		|| (options.fromX2 > block.width)
		|| (options.fromY2 > block.height)) {
	    Tcl_AppendResult(interp, "coordinates for -from option extend ",
		    "outside source image", (char *) NULL);
	    return TCL_ERROR;
	}

	/*
	 * Fill in default values for unspecified parameters.
	 */

	if (!(options.options & OPT_FROM) || (options.fromX2 < 0)) {
	    options.fromX2 = block.width;
	    options.fromY2 = block.height;
	}
	if (!(options.options & OPT_TO) || (options.toX2 < 0)) {
	    width = options.fromX2 - options.fromX;
	    if (options.subsampleX > 0) {
		width = (width + options.subsampleX - 1) / options.subsampleX;
	    } else if (options.subsampleX == 0) {
		width = 0;
	    } else {
		width = (width - options.subsampleX - 1) / -options.subsampleX;
	    }
	    options.toX2 = options.toX + width * options.zoomX;

	    height = options.fromY2 - options.fromY;
	    if (options.subsampleY > 0) {
		height = (height + options.subsampleY - 1)
			/ options.subsampleY;
	    } else if (options.subsampleY == 0) {
		height = 0;
	    } else {
		height = (height - options.subsampleY - 1)
			/ -options.subsampleY;
	    }
	    options.toY2 = options.toY + height * options.zoomY;
	}

	/*
	 * Set the destination image size if the -shrink option was specified.
	 */

	if (options.options & OPT_SHRINK) {
	    if (ImgPhotoSetSize(masterPtr, options.toX2,
		    options.toY2) != TCL_OK) {
		Tcl_ResetResult(interp);
		Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
			TK_PHOTO_ALLOC_FAILURE_MESSAGE, (char *) NULL);
		return TCL_ERROR;
	    }
	}

	/*
	 * Copy the image data over using Tk_PhotoPutZoomedBlock.
	 */

	block.pixelPtr += options.fromX * block.pixelSize
		+ options.fromY * block.pitch;
	block.width = options.fromX2 - options.fromX;
	block.height = options.fromY2 - options.fromY;
	Tk_PhotoPutZoomedBlock((Tk_PhotoHandle) masterPtr, &block,
		options.toX, options.toY, options.toX2 - options.toX,
		options.toY2 - options.toY, options.zoomX, options.zoomY,
		options.subsampleX, options.subsampleY,
		options.compositingRule);

	break;

    case PHOTO_DATA: {
	char *data;

	/*
	 * photo data command - first parse and check any options given.
	 */
	Tk_ImageStringWriteProc *stringWriteProc = NULL;

	index = 2;
	memset((VOID *) &options, 0, sizeof(options));
	options.name = NULL;
	options.format = NULL;
	options.fromX = 0;
	options.fromY = 0;
	if (ParseSubcommandOptions(&options, interp,
		OPT_FORMAT | OPT_FROM | OPT_GRAYSCALE | OPT_BACKGROUND,
		&index, objc, objv) != TCL_OK) {
	    return TCL_ERROR;
	}
	if ((options.name != NULL) || (index < objc)) {
	    Tcl_WrongNumArgs(interp, 2, objv, "?options?");
	    return TCL_ERROR;
	}
	if ((options.fromX > masterPtr->width)
		|| (options.fromY > masterPtr->height)
		|| (options.fromX2 > masterPtr->width)
		|| (options.fromY2 > masterPtr->height)) {
	    Tcl_AppendResult(interp, "coordinates for -from option extend ",
		    "outside image", (char *) NULL);
	    return TCL_ERROR;
	}

	/*
	 * Fill in default values for unspecified parameters.
	 */

	if (((options.options & OPT_FROM) == 0) || (options.fromX2 < 0)) {
	    options.fromX2 = masterPtr->width;
	    options.fromY2 = masterPtr->height;
	}

	/*
	 * Search for an appropriate image string format handler.
	 */

	if (options.options & OPT_FORMAT) {
	    for (imageFormat = tsdPtr->formatList; imageFormat != NULL;
	 	imageFormat = imageFormat->nextPtr) {
		if ((strncasecmp(Tcl_GetString(options.format),
			imageFormat->name, strlen(imageFormat->name)) == 0)) {
		    if (imageFormat->stringWriteProc != NULL) {
			stringWriteProc = imageFormat->stringWriteProc;
			break;
		    }
		}
	    }
	    if (stringWriteProc == NULL) {
		Tcl_AppendResult(interp, "image string format \"",
			Tcl_GetString(options.format),
			"\" is not supported", (char *) NULL);
		return TCL_ERROR;
	    }
	} else {
	    stringWriteProc = ImgStringWrite;
	}

	/*
	 * Call the handler's string write procedure to write out
	 * the image.
	 */

	data = ImgGetPhoto(masterPtr, &block, &options);

	result = ((int (*) _ANSI_ARGS_((Tcl_Interp *interp, Tcl_Obj *formatString,
		Tk_PhotoImageBlock *blockPtr, VOID *dummy))) stringWriteProc)
		(interp, options.format, &block, (VOID *) NULL);
	if (options.background) {
	    Tk_FreeColor(options.background);
	}
	if (data) {
	    ckfree(data);
	}
	return result;
	break;
    }

    case PHOTO_GET: {
	/*
	 * photo get command - first parse and check parameters.
	 */

	char string[TCL_INTEGER_SPACE * 3];

	if (objc != 4) {
	    Tcl_WrongNumArgs(interp, 2, objv, "x y");
	    return TCL_ERROR;
	}
	if ((Tcl_GetIntFromObj(interp, objv[2], &x) != TCL_OK)
		|| (Tcl_GetIntFromObj(interp, objv[3], &y) != TCL_OK)) {
	    return TCL_ERROR;
	}
	if ((x < 0) || (x >= masterPtr->width)
		|| (y < 0) || (y >= masterPtr->height)) {
	    Tcl_AppendResult(interp, Tcl_GetString(objv[0]), " get: ",
		    "coordinates out of range", (char *) NULL);
	    return TCL_ERROR;
	}

	/*
	 * Extract the value of the desired pixel and format it as a string.
	 */

	pixelPtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;
	sprintf(string, "%d %d %d", pixelPtr[0], pixelPtr[1],
		pixelPtr[2]);
	Tcl_AppendResult(interp, string, (char *) NULL);
	break;
    }

    case PHOTO_PUT:
	/*
	 * photo put command - first parse the options and colors specified.
	 */

	index = 2;
	memset((VOID *) &options, 0, sizeof(options));
	options.name = NULL;
	if (ParseSubcommandOptions(&options, interp, OPT_TO|OPT_FORMAT,
		&index, objc, objv) != TCL_OK) {
	    return TCL_ERROR;
	}
	if ((options.name == NULL) || (index < objc)) {
	    Tcl_WrongNumArgs(interp, 2, objv, "data ?options?");
	    return TCL_ERROR;
	}

	if (MatchStringFormat(interp, options.name ? objv[2]:NULL, 
		options.format, &imageFormat, &imageWidth,
		&imageHeight, &oldformat) == TCL_OK) {
	    Tcl_Obj *format, *data;

	    if (((options.options & OPT_TO) == 0) || (options.toX2 < 0)) {
		options.toX2 = options.toX + imageWidth;
		options.toY2 = options.toY + imageHeight;
	    }
	    if (imageWidth > options.toX2 - options.toX) {
		imageWidth = options.toX2 - options.toX;
	    }
	    if (imageHeight > options.toY2 - options.toY) {
		imageHeight = options.toY2 - options.toY;
	    }
	    format = options.format;
	    data = objv[2];
	    if (oldformat) {
		if (format) {
		    format = (Tcl_Obj *) Tcl_GetString(format);
		}
		data = (Tcl_Obj *) Tcl_GetString(data);
	    }
	    if ((*imageFormat->stringReadProc)(interp, data,
		    format, (Tk_PhotoHandle) masterPtr,
		    options.toX, options.toY, imageWidth, imageHeight,
		    0, 0) != TCL_OK) {
		return TCL_ERROR;
	    }
	    masterPtr->flags |= IMAGE_CHANGED;
	    return TCL_OK;
	}
	if (options.options & OPT_FORMAT) {
	    return TCL_ERROR;
	}
	Tcl_ResetResult(interp);
	if (Tcl_SplitList(interp, Tcl_GetString(options.name),
		&dataHeight, &srcArgv) != TCL_OK) {
	    return TCL_ERROR;
	}
	tkwin = Tk_MainWindow(interp);
	block.pixelPtr = NULL;
	dataWidth = 0;
	pixelPtr = NULL;
	for (y = 0; y < dataHeight; ++y) {
	    if (Tcl_SplitList(interp, srcArgv[y], &listArgc, &listArgv)
		    != TCL_OK) {
		break;
	    }
	    if (y == 0) {
		dataWidth = listArgc;
		pixelPtr = (unsigned char *)
			ckalloc((unsigned) dataWidth * dataHeight * 3);
		block.pixelPtr = pixelPtr;
	    } else if (listArgc != dataWidth) {
		Tcl_AppendResult(interp, "all elements of color list must",
			" have the same number of elements", (char *) NULL);
		ckfree((char *) listArgv);
		break;
	    }
	    for (x = 0; x < dataWidth; ++x) {
		if (!XParseColor(Tk_Display(tkwin), Tk_Colormap(tkwin),
			listArgv[x], &color)) {
		    Tcl_AppendResult(interp, "can't parse color \"",
			    listArgv[x], "\"", (char *) NULL);
		    break;
		}
		*pixelPtr++ = color.red >> 8;
		*pixelPtr++ = color.green >> 8;
		*pixelPtr++ = color.blue >> 8;
	    }
	    ckfree((char *) listArgv);
	    if (x < dataWidth) {
		break;
	    }
	}
	ckfree((char *) srcArgv);
	if (y < dataHeight || dataHeight == 0 || dataWidth == 0) {
	    if (block.pixelPtr != NULL) {
		ckfree((char *) block.pixelPtr);
	    }
	    if (y < dataHeight) {
		return TCL_ERROR;
	    }
	    return TCL_OK;
	}

	/*
	 * Fill in default values for the -to option, then
	 * copy the block in using Tk_PhotoPutBlock.
	 */

	if (!(options.options & OPT_TO) || (options.toX2 < 0)) {
	    options.toX2 = options.toX + dataWidth;
	    options.toY2 = options.toY + dataHeight;
	}
	block.width = dataWidth;
	block.height = dataHeight;
	block.pitch = dataWidth * 3;
	block.pixelSize = 3;
	block.offset[0] = 0;
	block.offset[1] = 1;
	block.offset[2] = 2;
	block.offset[3] = 0;
	Tk_PhotoPutBlock((ClientData)masterPtr, &block,
		options.toX, options.toY, options.toX2 - options.toX,
		options.toY2 - options.toY, TK_PHOTO_COMPOSITE_SET);
	ckfree((char *) block.pixelPtr);
	break;

    case PHOTO_READ: {
	Tcl_Obj *format;

	/*
	 * photo read command - first parse the options specified.
	 */

	index = 2;
	memset((VOID *) &options, 0, sizeof(options));
	options.name = NULL;
	options.format = NULL;
	if (ParseSubcommandOptions(&options, interp,
		OPT_FORMAT | OPT_FROM | OPT_TO | OPT_SHRINK,
		&index, objc, objv) != TCL_OK) {
	    return TCL_ERROR;
	}
	if ((options.name == NULL) || (index < objc)) {
	    Tcl_WrongNumArgs(interp, 2, objv, "fileName ?options?");
	    return TCL_ERROR;
	}

        /*
         * Prevent file system access in safe interpreters.
         */

        if (Tcl_IsSafe(interp)) {
            Tcl_AppendResult(interp, "can't get image from a file in a",
		    " safe interpreter", (char *) NULL);
            return TCL_ERROR;
        }
        
	/*
	 * Open the image file and look for a handler for it.
	 */

	chan = Tcl_OpenFileChannel(interp,
		Tcl_GetString(options.name), "r", 0);
	if (chan == NULL) {
	    return TCL_ERROR;
	}
        if (Tcl_SetChannelOption(interp, chan, "-translation", "binary")
		!= TCL_OK) {
	    Tcl_Close(NULL, chan);
            return TCL_ERROR;
        }
        if (Tcl_SetChannelOption(interp, chan, "-encoding", "binary")
		!= TCL_OK) {
	    Tcl_Close(NULL, chan);
            return TCL_ERROR;
        }
    
	if (MatchFileFormat(interp, chan,
		Tcl_GetString(options.name), options.format, &imageFormat,
		&imageWidth, &imageHeight, &oldformat) != TCL_OK) {
	    Tcl_Close(NULL, chan);
	    return TCL_ERROR;
	}

	/*
	 * Check the values given for the -from option.
	 */

	if ((options.fromX > imageWidth) || (options.fromY > imageHeight)
		|| (options.fromX2 > imageWidth)
		|| (options.fromY2 > imageHeight)) {
	    Tcl_AppendResult(interp, "coordinates for -from option extend ",
		    "outside source image", (char *) NULL);
	    Tcl_Close(NULL, chan);
	    return TCL_ERROR;
	}
	if (((options.options & OPT_FROM) == 0) || (options.fromX2 < 0)) {
	    width = imageWidth - options.fromX;
	    height = imageHeight - options.fromY;
	} else {
	    width = options.fromX2 - options.fromX;
	    height = options.fromY2 - options.fromY;
	}

	/*
	 * If the -shrink option was specified, set the size of the image.
	 */

	if (options.options & OPT_SHRINK) {
	    if (ImgPhotoSetSize(masterPtr, options.toX + width,
		    options.toY + height) != TCL_OK) {
		Tcl_ResetResult(interp);
		Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
			TK_PHOTO_ALLOC_FAILURE_MESSAGE, (char *) NULL);
		return TCL_ERROR;
	    }
	}

	/*
	 * Call the handler's file read procedure to read the data
	 * into the image.
	 */

	format = options.format;
	if (oldformat && format) {
	    format = (Tcl_Obj *) Tcl_GetString(format);
	}
	result = (*imageFormat->fileReadProc)(interp, chan,
		Tcl_GetString(options.name),
		format, (Tk_PhotoHandle) masterPtr, options.toX,
		options.toY, width, height, options.fromX, options.fromY);
	if (chan != NULL) {
	    Tcl_Close(NULL, chan);
	}
	return result;
	break;
    }

    case PHOTO_REDITHER:
	if (objc != 2) {
	    Tcl_WrongNumArgs(interp, 2, objv, (char *) NULL);
	    return TCL_ERROR;
	}

	/*
	 * Call Dither if any part of the image is not correctly
	 * dithered at present.
	 */

	x = masterPtr->ditherX;
	y = masterPtr->ditherY;
	if (masterPtr->ditherX != 0) {
	    Tk_DitherPhoto((Tk_PhotoHandle) masterPtr, x, y,
		    masterPtr->width - x, 1);
	}
	if (masterPtr->ditherY < masterPtr->height) {
	    x = 0;
	    Tk_DitherPhoto((Tk_PhotoHandle)masterPtr, 0,
		    masterPtr->ditherY, masterPtr->width,
		    masterPtr->height - masterPtr->ditherY);
	}

	if (y < masterPtr->height) {
	    /*
	     * Tell the core image code that part of the image has changed.
	     */

	    Tk_ImageChanged(masterPtr->tkMaster, x, y,
		    (masterPtr->width - x), (masterPtr->height - y),
		    masterPtr->width, masterPtr->height);
	}
	break;

    case PHOTO_TRANS: {
	static CONST char *photoTransOptions[] = {
	    "get", "set", (char *) NULL
	};
	enum transOptions {
	    PHOTO_TRANS_GET, PHOTO_TRANS_SET
	};

	if (objc < 3) {
	    Tcl_WrongNumArgs(interp, 2, objv, "option ?arg arg ...?");
	    return TCL_ERROR;
	}
	if (Tcl_GetIndexFromObj(interp, objv[2], photoTransOptions, "option",
		0, &index) != TCL_OK) {
	    return TCL_ERROR;
	}

	switch ((enum transOptions) index) {
	case PHOTO_TRANS_GET: {
	    XRectangle testBox;
	    TkRegion testRegion;

	    if (objc != 5) {
		Tcl_WrongNumArgs(interp, 3, objv, "x y");
		return TCL_ERROR;
	    }
	    if ((Tcl_GetIntFromObj(interp, objv[3], &x) != TCL_OK)
		    || (Tcl_GetIntFromObj(interp, objv[4], &y) != TCL_OK)) {
		return TCL_ERROR;
	    }
	    if ((x < 0) || (x >= masterPtr->width)
		|| (y < 0) || (y >= masterPtr->height)) {
		Tcl_AppendResult(interp, Tcl_GetString(objv[0]),
			" transparency get: coordinates out of range",
			(char *) NULL);
		return TCL_ERROR;
	    }

	    testBox.x = x;
	    testBox.y = y;
	    testBox.width = 1;
	    testBox.height = 1;
	    /* What a way to do a test! */
	    testRegion = TkCreateRegion();
	    TkUnionRectWithRegion(&testBox, testRegion, testRegion);
	    TkIntersectRegion(testRegion, masterPtr->validRegion, testRegion);
	    TkClipBox(testRegion, &testBox);
	    TkDestroyRegion(testRegion);

	    Tcl_SetBooleanObj(Tcl_GetObjResult(interp),
		    (testBox.width==0 && testBox.height==0));
	    return TCL_OK;
	}

	case PHOTO_TRANS_SET: {
	    int transFlag;
	    XRectangle setBox;

	    if (objc != 6) {
		Tcl_WrongNumArgs(interp, 3, objv, "x y boolean");
		return TCL_ERROR;
	    }
	    if ((Tcl_GetIntFromObj(interp, objv[3], &x) != TCL_OK)
		    || (Tcl_GetIntFromObj(interp, objv[4], &y) != TCL_OK)
		    || (Tcl_GetBooleanFromObj(interp, objv[5],
		    &transFlag) != TCL_OK)) {
		return TCL_ERROR;
	    }
	    if ((x < 0) || (x >= masterPtr->width)
		|| (y < 0) || (y >= masterPtr->height)) {
		Tcl_AppendResult(interp, Tcl_GetString(objv[0]),
			" transparency set: coordinates out of range",
			(char *) NULL);
		return TCL_ERROR;
	    }

	    setBox.x = x;
	    setBox.y = y;
	    setBox.width = 1;
	    setBox.height = 1;
	    pixelPtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;

	    if (transFlag) {
		/*
		 * Make pixel transparent.
		 */
		TkRegion clearRegion = TkCreateRegion();

		TkUnionRectWithRegion(&setBox, clearRegion, clearRegion);
		TkSubtractRegion(masterPtr->validRegion, clearRegion,
			masterPtr->validRegion);
		TkDestroyRegion(clearRegion);
		/*
		 * Set the alpha value correctly.
		 */
		pixelPtr[3] = 0;
	    } else {
		/*
		 * Make pixel opaque.
		 */
		TkUnionRectWithRegion(&setBox, masterPtr->validRegion,
			masterPtr->validRegion);
		pixelPtr[3] = 255;
	    }

	    /*
	     * Inform the generic image code that the image
	     * has (potentially) changed.
	     */

	    Tk_ImageChanged(masterPtr->tkMaster, x, y, 1, 1,
		    masterPtr->width, masterPtr->height);
	    masterPtr->flags &= ~IMAGE_CHANGED;
	}

	}
	return TCL_OK;
    }

    case PHOTO_WRITE: {
	char *data;
	Tcl_Obj *format;

        /*
         * Prevent file system access in safe interpreters.
         */

        if (Tcl_IsSafe(interp)) {
            Tcl_AppendResult(interp, "can't write image to a file in a",
		    " safe interpreter", (char *) NULL);
            return TCL_ERROR;
        }
        
	/*
	 * photo write command - first parse and check any options given.
	 */

	index = 2;
	memset((VOID *) &options, 0, sizeof(options));
	options.name = NULL;
	options.format = NULL;
	if (ParseSubcommandOptions(&options, interp,
		OPT_FORMAT | OPT_FROM | OPT_GRAYSCALE | OPT_BACKGROUND,
		&index, objc, objv) != TCL_OK) {
	    return TCL_ERROR;
	}
	if ((options.name == NULL) || (index < objc)) {
	    Tcl_WrongNumArgs(interp, 2, objv, "fileName ?options?");
	    return TCL_ERROR;
	}
	if ((options.fromX > masterPtr->width)
		|| (options.fromY > masterPtr->height)
		|| (options.fromX2 > masterPtr->width)
		|| (options.fromY2 > masterPtr->height)) {
	    Tcl_AppendResult(interp, "coordinates for -from option extend ",
		    "outside image", (char *) NULL);
	    return TCL_ERROR;
	}

	/*
	 * Fill in default values for unspecified parameters.
	 */

	if (!(options.options & OPT_FROM) || (options.fromX2 < 0)) {
	    options.fromX2 = masterPtr->width;
	    options.fromY2 = masterPtr->height;
	}

	/*
	 * Search for an appropriate image file format handler,
	 * and give an error if none is found.
	 */

	matched = 0;
	for (imageFormat = tsdPtr->formatList; imageFormat != NULL;
		imageFormat = imageFormat->nextPtr) {
	    if ((options.format == NULL)
		    || (strncasecmp(Tcl_GetString(options.format),
		    imageFormat->name, strlen(imageFormat->name)) == 0)) {
		matched = 1;
		if (imageFormat->fileWriteProc != NULL) {
		    break;
		}
	    }
	}
	if (imageFormat == NULL) {
	    oldformat = 1;
	    for (imageFormat = tsdPtr->oldFormatList; imageFormat != NULL;
		    imageFormat = imageFormat->nextPtr) {
		if ((options.format == NULL)
			|| (strncasecmp(Tcl_GetString(options.format),
			imageFormat->name, strlen(imageFormat->name)) == 0)) {
		    matched = 1;
		    if (imageFormat->fileWriteProc != NULL) {
			break;
		    }
		}
	    }
	}
	if (imageFormat == NULL) {
	    if (options.format == NULL) {
		Tcl_AppendResult(interp, "no available image file format ",
			"has file writing capability", (char *) NULL);
	    } else if (!matched) {
		Tcl_AppendResult(interp, "image file format \"",
			Tcl_GetString(options.format),
			"\" is unknown", (char *) NULL);
	    } else {
		Tcl_AppendResult(interp, "image file format \"",
			Tcl_GetString(options.format),
			"\" has no file writing capability",
			(char *) NULL);
	    }
	    return TCL_ERROR;
	}

	/*
	 * Call the handler's file write procedure to write out
	 * the image.
	 */

	data = ImgGetPhoto(masterPtr, &block, &options);
	format = options.format;
	if (oldformat && format) {
	    format = (Tcl_Obj *) Tcl_GetString(options.format);
	}
	result = (*imageFormat->fileWriteProc)(interp,
		Tcl_GetString(options.name), format, &block);
	if (options.background) {
	    Tk_FreeColor(options.background);
	}
	if (data) {
	    ckfree(data);
	}
	return result;
    }

    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ParseSubcommandOptions --
 *
 *	This procedure is invoked to process one of the options
 *	which may be specified for the photo image subcommands,
 *	namely, -from, -to, -zoom, -subsample, -format, -shrink,
 *	and -compositingrule.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	Fields in *optPtr get filled in.
 *
 *----------------------------------------------------------------------
 */

static int
ParseSubcommandOptions(optPtr, interp, allowedOptions, optIndexPtr, objc, objv)
    struct SubcommandOptions *optPtr;
				/* Information about the options specified
				 * and the values given is returned here. */
    Tcl_Interp *interp;		/* Interpreter to use for reporting errors. */
    int allowedOptions;		/* Indicates which options are valid for
				 * the current command. */
    int *optIndexPtr;		/* Points to a variable containing the
				 * current index in objv; this variable is
				 * updated by this procedure. */
    int objc;			/* Number of arguments in objv[]. */
    Tcl_Obj *CONST objv[];	/* Arguments to be parsed. */
{
    int index, c, bit, currentBit;
    int length;
    char *option, **listPtr;
    int values[4];
    int numValues, maxValues, argIndex;

    for (index = *optIndexPtr; index < objc; *optIndexPtr = ++index) {
	/*
	 * We can have one value specified without an option;
	 * it goes into optPtr->name.
	 */

	option = Tcl_GetStringFromObj(objv[index], &length);
	if (option[0] != '-') {
	    if (optPtr->name == NULL) {
		optPtr->name = objv[index];
		continue;
	    }
	    break;
	}

	/*
	 * Work out which option this is.
	 */

	c = option[0];
	bit = 0;
	currentBit = 1;
	for (listPtr = optionNames; *listPtr != NULL; ++listPtr) {
	    if ((c == *listPtr[0])
		    && (strncmp(option, *listPtr, (size_t) length) == 0)) {
		if (bit != 0) {
		    bit = 0;	/* An ambiguous option. */
		    break;
		}
		bit = currentBit;
	    }
	    currentBit <<= 1;
	}

	/*
	 * If this option is not recognized and allowed, put
	 * an error message in the interpreter and return.
	 */

	if ((allowedOptions & bit) == 0) {
	    Tcl_AppendResult(interp, "unrecognized option \"",
	    	    Tcl_GetString(objv[index]),
		    "\": must be ", (char *)NULL);
	    bit = 1;
	    for (listPtr = optionNames; *listPtr != NULL; ++listPtr) {
		if ((allowedOptions & bit) != 0) {
		    if ((allowedOptions & (bit - 1)) != 0) {
			Tcl_AppendResult(interp, ", ", (char *) NULL);
			if ((allowedOptions & ~((bit << 1) - 1)) == 0) {
			    Tcl_AppendResult(interp, "or ", (char *) NULL);
			}
		    }
		    Tcl_AppendResult(interp, *listPtr, (char *) NULL);
		}
		bit <<= 1;
	    }
	    return TCL_ERROR;
	}

	/*
	 * For the -from, -to, -zoom and -subsample options,
	 * parse the values given.  Report an error if too few
	 * or too many values are given.
	 */

	if (bit == OPT_BACKGROUND) {
	    /*
	     * The -background option takes a single XColor value.
	     */

	    if (index + 1 < objc) {
		*optIndexPtr = ++index;
		optPtr->background = Tk_GetColor(interp, Tk_MainWindow(interp),
			Tk_GetUid(Tcl_GetString(objv[index])));
		if (!optPtr->background) {
		    return TCL_ERROR;
		}
	    } else {
		Tcl_AppendResult(interp, "the \"-background\" option ",
			"requires a value", (char *) NULL);
		return TCL_ERROR;
	    }
	} else if (bit == OPT_FORMAT) {
	    /*
	     * The -format option takes a single string value.  Note
	     * that parsing this is outside the scope of this
	     * function.
	     */

	    if (index + 1 < objc) {
		*optIndexPtr = ++index;
		optPtr->format = objv[index];
	    } else {
		Tcl_AppendResult(interp, "the \"-format\" option ",
			"requires a value", (char *) NULL);
		return TCL_ERROR;
	    }
	} else if (bit == OPT_COMPOSITE) {
	    /*
	     * The -compositingrule option takes a single value from
	     * a well-known set.
	     */

	    if (index + 1 < objc) {
		/*
		 * Note that these must match the TK_PHOTO_COMPOSITE_*
		 * constants.
		 */
		static CONST char *compositingRules[] = {
		    "overlay", "set",
		    NULL
		};

		index++;
		if (Tcl_GetIndexFromObj(interp, objv[index], compositingRules,
			"compositing rule", 0, &optPtr->compositingRule)
			!= TCL_OK) {
		    return TCL_ERROR;
		}
		*optIndexPtr = index;
	    } else {
		Tcl_AppendResult(interp, "the \"-compositingrule\" option ",
			"requires a value", (char *) NULL);
		return TCL_ERROR;
	    }
	} else if ((bit != OPT_SHRINK) && (bit != OPT_GRAYSCALE)) {
	    char *val;
	    maxValues = ((bit == OPT_FROM) || (bit == OPT_TO))? 4: 2;
	    argIndex = index + 1;
	    for (numValues = 0; numValues < maxValues; ++numValues) {
		if (argIndex >= objc) {
		    break;
		}
	        val = Tcl_GetString(objv[argIndex]);
		if ((argIndex < objc) && (isdigit(UCHAR(val[0]))
			|| ((val[0] == '-') && isdigit(UCHAR(val[1]))))) {
		    if (Tcl_GetInt(interp, val, &values[numValues])
			    != TCL_OK) {
			return TCL_ERROR;
		    }
		} else {
		    break;
		}
		++argIndex;
	    }

	    if (numValues == 0) {
		Tcl_AppendResult(interp, "the \"", option, "\" option ",
			 "requires one ", maxValues == 2? "or two": "to four",
			 " integer values", (char *) NULL);
		return TCL_ERROR;
	    }
	    *optIndexPtr = (index += numValues);

	    /*
	     * Y values default to the corresponding X value if not specified.
	     */

	    if (numValues == 1) {
		values[1] = values[0];
	    }
	    if (numValues == 3) {
		values[3] = values[2];
	    }

	    /*
	     * Check the values given and put them in the appropriate
	     * field of the SubcommandOptions structure.
	     */

	    switch (bit) {
		case OPT_FROM:
		    if ((values[0] < 0) || (values[1] < 0) || ((numValues > 2)
			    && ((values[2] < 0) || (values[3] < 0)))) {
			Tcl_AppendResult(interp, "value(s) for the -from",
				" option must be non-negative", (char *) NULL);
			return TCL_ERROR;
		    }
		    if (numValues <= 2) {
			optPtr->fromX = values[0];
			optPtr->fromY = values[1];
			optPtr->fromX2 = -1;
			optPtr->fromY2 = -1;
		    } else {
			optPtr->fromX = MIN(values[0], values[2]);
			optPtr->fromY = MIN(values[1], values[3]);
			optPtr->fromX2 = MAX(values[0], values[2]);
			optPtr->fromY2 = MAX(values[1], values[3]);
		    }
		    break;
		case OPT_SUBSAMPLE:
		    optPtr->subsampleX = values[0];
		    optPtr->subsampleY = values[1];
		    break;
		case OPT_TO:
		    if ((values[0] < 0) || (values[1] < 0) || ((numValues > 2)
			    && ((values[2] < 0) || (values[3] < 0)))) {
			Tcl_AppendResult(interp, "value(s) for the -to",
				" option must be non-negative", (char *) NULL);
			return TCL_ERROR;
		    }
		    if (numValues <= 2) {
			optPtr->toX = values[0];
			optPtr->toY = values[1];
			optPtr->toX2 = -1;
			optPtr->toY2 = -1;
		    } else {
			optPtr->toX = MIN(values[0], values[2]);
			optPtr->toY = MIN(values[1], values[3]);
			optPtr->toX2 = MAX(values[0], values[2]);
			optPtr->toY2 = MAX(values[1], values[3]);
		    }
		    break;
		case OPT_ZOOM:
		    if ((values[0] <= 0) || (values[1] <= 0)) {
			Tcl_AppendResult(interp, "value(s) for the -zoom",
				" option must be positive", (char *) NULL);
			return TCL_ERROR;
		    }
		    optPtr->zoomX = values[0];
		    optPtr->zoomY = values[1];
		    break;
	    }
	}

	/*
	 * Remember that we saw this option.
	 */

	optPtr->options |= bit;
    }

    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ImgPhotoConfigureMaster --
 *
 *	This procedure is called when a photo image is created or
 *	reconfigured.  It processes configuration options and resets
 *	any instances of the image.
 *
 * Results:
 *	A standard Tcl return value.  If TCL_ERROR is returned then
 *	an error message is left in the masterPtr->interp's result.
 *
 * Side effects:
 *	Existing instances of the image will be redisplayed to match
 *	the new configuration options.
 *
 *----------------------------------------------------------------------
 */

static int
ImgPhotoConfigureMaster(interp, masterPtr, objc, objv, flags)
    Tcl_Interp *interp;		/* Interpreter to use for reporting errors. */
    PhotoMaster *masterPtr;	/* Pointer to data structure describing
				 * overall photo image to (re)configure. */
    int objc;			/* Number of entries in objv. */
    Tcl_Obj *CONST objv[];	/* Pairs of configuration options for image. */
    int flags;			/* Flags to pass to Tk_ConfigureWidget,
				 * such as TK_CONFIG_ARGV_ONLY. */
{
    PhotoInstance *instancePtr;
    CONST char *oldFileString, *oldPaletteString;
    Tcl_Obj *oldData, *data = NULL, *oldFormat, *format = NULL;
    int length, i, j;
    double oldGamma;
    int result;
    Tcl_Channel chan;
    Tk_PhotoImageFormat *imageFormat;
    int imageWidth, imageHeight;
    CONST char **args;
    int oldformat;
    Tcl_Obj *tempdata, *tempformat;

    args = (CONST char **) ckalloc((objc + 1) * sizeof(char *));
    for (i = 0, j = 0; i < objc; i++,j++) {
	args[j] = Tcl_GetStringFromObj(objv[i], &length);
	if ((length > 1) && (args[j][0] == '-')) {
	    if ((args[j][1] == 'd') &&
		    !strncmp(args[j], "-data", (size_t) length)) {
		if (++i < objc) {
		    data = objv[i];
		    j--;
		} else {
		    Tcl_AppendResult(interp,
			    "value for \"-data\" missing", (char *) NULL);
		    return TCL_ERROR;
		}
	    } else if ((args[j][1] == 'f') &&
		    !strncmp(args[j], "-format", (size_t) length)) {
		if (++i < objc) {
		    format = objv[i];
		    j--;
		} else {
		    Tcl_AppendResult(interp,
			    "value for \"-format\" missing", (char *) NULL);
		    return TCL_ERROR;
		}
	    }
	}
    }

    /*
     * Save the current values for fileString and dataString, so we
     * can tell if the user specifies them anew.
     * IMPORTANT: if the format changes we have to interpret
     * "-file" and "-data" again as well!!!!!!! It might be
     * that the format string influences how "-data" or "-file"
     * is interpreted.
     */

    oldFileString = masterPtr->fileString;
    if (oldFileString == NULL) {
	oldData = masterPtr->dataString;
	if (oldData != NULL) {
	    Tcl_IncrRefCount(oldData);
	}
    } else {
	oldData = NULL;
    }
    oldFormat = masterPtr->format;
    if (oldFormat != NULL) {
	Tcl_IncrRefCount(oldFormat);
    }
    oldPaletteString = masterPtr->palette;
    oldGamma = masterPtr->gamma;

    /*
     * Process the configuration options specified.
     */

    if (Tk_ConfigureWidget(interp, Tk_MainWindow(interp), configSpecs,
	    j, args, (char *) masterPtr, flags) != TCL_OK) {
	ckfree((char *) args);
	goto errorExit;
    }
    ckfree((char *) args);

    /*
     * Regard the empty string for -file, -data or -format as the null
     * value.
     */

    if ((masterPtr->fileString != NULL) && (masterPtr->fileString[0] == 0)) {
	ckfree(masterPtr->fileString);
	masterPtr->fileString = NULL;
    }
    if (data) {
	if (data->length
		|| (data->typePtr == Tcl_GetObjType("bytearray")
			&& data->internalRep.otherValuePtr != NULL)) {
	    Tcl_IncrRefCount(data);
	} else {
	    data = NULL;
	}
	if (masterPtr->dataString) {
	    Tcl_DecrRefCount(masterPtr->dataString);
	}
	masterPtr->dataString = data;
    }
    if (format) {
	if (format->length) {
	    Tcl_IncrRefCount(format);
	} else {
	    format = NULL;
	}
	if (masterPtr->format) {
	    Tcl_DecrRefCount(masterPtr->format);
	}
	masterPtr->format = format;
    }
    /*
     * Set the image to the user-requested size, if any,
     * and make sure storage is correctly allocated for this image.
     */

    if (ImgPhotoSetSize(masterPtr, masterPtr->width,
	    masterPtr->height) != TCL_OK) {
	Tcl_ResetResult(interp);
	Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		TK_PHOTO_ALLOC_FAILURE_MESSAGE, (char *) NULL);
	goto errorExit;
    }

    /*
     * Read in the image from the file or string if the user has
     * specified the -file or -data option.
     */

    if ((masterPtr->fileString != NULL)
	    && ((masterPtr->fileString != oldFileString)
	    || (masterPtr->format != oldFormat))) {

        /*
         * Prevent file system access in a safe interpreter.
         */

        if (Tcl_IsSafe(interp)) {
	    Tcl_ResetResult(interp);
            Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		    "can't get image from a file in a safe interpreter",
		    (char *) NULL);
	    goto errorExit;
        }
        
	chan = Tcl_OpenFileChannel(interp, masterPtr->fileString, "r", 0);
	if (chan == NULL) {
	    goto errorExit;
	}
	/*
	 * -translation binary also sets -encoding binary
	 */
        if ((Tcl_SetChannelOption(interp, chan,
		"-translation", "binary") != TCL_OK) ||
		(MatchFileFormat(interp, chan, masterPtr->fileString,
			masterPtr->format, &imageFormat, &imageWidth,
			&imageHeight, &oldformat) != TCL_OK)) {
	    Tcl_Close(NULL, chan);
	    goto errorExit;
	}
	result = ImgPhotoSetSize(masterPtr, imageWidth, imageHeight);
	if (result != TCL_OK) {
	    Tcl_Close(NULL, chan);
	    Tcl_ResetResult(interp);
	    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		    TK_PHOTO_ALLOC_FAILURE_MESSAGE, (char *) NULL);
	    goto errorExit;
	}
	tempformat = masterPtr->format;
	if (oldformat && tempformat) {
	    tempformat = (Tcl_Obj *) Tcl_GetString(tempformat);
	}
	result = (*imageFormat->fileReadProc)(interp, chan,
		masterPtr->fileString, tempformat,
		(Tk_PhotoHandle) masterPtr, 0, 0,
		imageWidth, imageHeight, 0, 0);
	Tcl_Close(NULL, chan);
	if (result != TCL_OK) {
	    goto errorExit;
	}

	Tcl_ResetResult(interp);
	masterPtr->flags |= IMAGE_CHANGED;
    }

    if ((masterPtr->fileString == NULL) && (masterPtr->dataString != NULL)
	    && ((masterPtr->dataString != oldData)
		    || (masterPtr->format != oldFormat))) {

	if (MatchStringFormat(interp, masterPtr->dataString,
		masterPtr->format, &imageFormat, &imageWidth,
		&imageHeight, &oldformat) != TCL_OK) {
	    goto errorExit;
	}
	if (ImgPhotoSetSize(masterPtr, imageWidth, imageHeight) != TCL_OK) {
	    Tcl_ResetResult(interp);
	    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		    TK_PHOTO_ALLOC_FAILURE_MESSAGE, (char *) NULL);
	    goto errorExit;
	}
	tempformat = masterPtr->format;
	tempdata = masterPtr->dataString;
	if (oldformat) {
	    if (tempformat) {
		tempformat = (Tcl_Obj *) Tcl_GetString(tempformat);
	    }
	    tempdata = (Tcl_Obj *) Tcl_GetString(tempdata);
	}
	if ((*imageFormat->stringReadProc)(interp, tempdata,
		tempformat, (Tk_PhotoHandle) masterPtr,
		0, 0, imageWidth, imageHeight, 0, 0) != TCL_OK) {
	    goto errorExit;
	}

	Tcl_ResetResult(interp);
	masterPtr->flags |= IMAGE_CHANGED;
    }

    /*
     * Enforce a reasonable value for gamma.
     */

    if (masterPtr->gamma <= 0) {
	masterPtr->gamma = 1.0;
    }

    if ((masterPtr->gamma != oldGamma)
	    || (masterPtr->palette != oldPaletteString)) {
	masterPtr->flags |= IMAGE_CHANGED;
    }

    /*
     * Cycle through all of the instances of this image, regenerating
     * the information for each instance.  Then force the image to be
     * redisplayed everywhere that it is used.
     */

    for (instancePtr = masterPtr->instancePtr; instancePtr != NULL;
	    instancePtr = instancePtr->nextPtr) {
	ImgPhotoConfigureInstance(instancePtr);
    }

    /*
     * Inform the generic image code that the image
     * has (potentially) changed.
     */

    Tk_ImageChanged(masterPtr->tkMaster, 0, 0, masterPtr->width,
	    masterPtr->height, masterPtr->width, masterPtr->height);
    masterPtr->flags &= ~IMAGE_CHANGED;

    if (oldData != NULL) {
	Tcl_DecrRefCount(oldData);
    }
    if (oldFormat != NULL) {
	Tcl_DecrRefCount(oldFormat);
    }
    return TCL_OK;

  errorExit:
    if (oldData != NULL) {
	Tcl_DecrRefCount(oldData);
    }
    if (oldFormat != NULL) {
	Tcl_DecrRefCount(oldFormat);
    }
    return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 *
 * ImgPhotoConfigureInstance --
 *
 *	This procedure is called to create displaying information for
 *	a photo image instance based on the configuration information
 *	in the master.  It is invoked both when new instances are
 *	created and when the master is reconfigured.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Generates errors via Tcl_BackgroundError if there are problems
 *	in setting up the instance.
 *
 *----------------------------------------------------------------------
 */

static void
ImgPhotoConfigureInstance(instancePtr)
    PhotoInstance *instancePtr;	/* Instance to reconfigure. */
{
    PhotoMaster *masterPtr = instancePtr->masterPtr;
    XImage *imagePtr;
    int bitsPerPixel;
    ColorTable *colorTablePtr;
    XRectangle validBox;

    /*
     * If the -palette configuration option has been set for the master,
     * use the value specified for our palette, but only if it is
     * a valid palette for our windows.  Use the gamma value specified
     * the master.
     */

    if ((masterPtr->palette && masterPtr->palette[0])
	    && IsValidPalette(instancePtr, masterPtr->palette)) {
	instancePtr->palette = masterPtr->palette;
    } else {
	instancePtr->palette = instancePtr->defaultPalette;
    }
    instancePtr->gamma = masterPtr->gamma;

    /*
     * If we don't currently have a color table, or if the one we
     * have no longer applies (e.g. because our palette or gamma
     * has changed), get a new one.
     */

    colorTablePtr = instancePtr->colorTablePtr;
    if ((colorTablePtr == NULL)
	    || (instancePtr->colormap != colorTablePtr->id.colormap)
	    || (instancePtr->palette != colorTablePtr->id.palette)
	    || (instancePtr->gamma != colorTablePtr->id.gamma)) {
	/*
	 * Free up our old color table, and get a new one.
	 */

	if (colorTablePtr != NULL) {
	    colorTablePtr->liveRefCount -= 1;
	    FreeColorTable(colorTablePtr, 0);
	}
	GetColorTable(instancePtr);

	/*
	 * Create a new XImage structure for sending data to
	 * the X server, if necessary.
	 */

	if (instancePtr->colorTablePtr->flags & BLACK_AND_WHITE) {
	    bitsPerPixel = 1;
	} else {
	    bitsPerPixel = instancePtr->visualInfo.depth;
	}

	if ((instancePtr->imagePtr == NULL)
		|| (instancePtr->imagePtr->bits_per_pixel != bitsPerPixel)) {
	    if (instancePtr->imagePtr != NULL) {
		XFree((char *) instancePtr->imagePtr);
	    }
	    imagePtr = XCreateImage(instancePtr->display,
		    instancePtr->visualInfo.visual, (unsigned) bitsPerPixel,
		    (bitsPerPixel > 1? ZPixmap: XYBitmap), 0, (char *) NULL,
		    1, 1, 32, 0);
	    instancePtr->imagePtr = imagePtr;

	    /*
	     * Determine the endianness of this machine.
	     * We create images using the local host's endianness, rather
	     * than the endianness of the server; otherwise we would have
	     * to byte-swap any 16 or 32 bit values that we store in the
	     * image in those situations where the server's endianness
	     * is different from ours.
	     *
	     * FIXME: use autoconf to figure this out.
	     */

	    if (imagePtr != NULL) {
		union {
		    int i;
		    char c[sizeof(int)];
		} kludge;

		imagePtr->bitmap_unit = sizeof(pixel) * NBBY;
		kludge.i = 0;
		kludge.c[0] = 1;
		imagePtr->byte_order = (kludge.i == 1) ? LSBFirst : MSBFirst;
		_XInitImageFuncPtrs(imagePtr);
	    }
	}
    }

    /*
     * If the user has specified a width and/or height for the master
     * which is different from our current width/height, set the size
     * to the values specified by the user.  If we have no pixmap, we
     * do this also, since it has the side effect of allocating a
     * pixmap for us.
     */

    if ((instancePtr->pixels == None) || (instancePtr->error == NULL)
	    || (instancePtr->width != masterPtr->width)
	    || (instancePtr->height != masterPtr->height)) {
	ImgPhotoInstanceSetSize(instancePtr);
    }

    /*
     * Redither this instance if necessary.
     */

    if ((masterPtr->flags & IMAGE_CHANGED)
	    || (instancePtr->colorTablePtr != colorTablePtr)) {
	TkClipBox(masterPtr->validRegion, &validBox);
	if ((validBox.width > 0) && (validBox.height > 0)) {
	    DitherInstance(instancePtr, validBox.x, validBox.y,
		    validBox.width, validBox.height);
	}
    }

}

/*
 *----------------------------------------------------------------------
 *
 * ImgPhotoGet --
 *
 *	This procedure is called for each use of a photo image in a
 *	widget.
 *
 * Results:
 *	The return value is a token for the instance, which is passed
 *	back to us in calls to ImgPhotoDisplay and ImgPhotoFree.
 *
 * Side effects:
 *	A data structure is set up for the instance (or, an existing
 *	instance is re-used for the new one).
 *
 *----------------------------------------------------------------------
 */

static ClientData
ImgPhotoGet(tkwin, masterData)
    Tk_Window tkwin;		/* Window in which the instance will be
				 * used. */
    ClientData masterData;	/* Pointer to our master structure for the
				 * image. */
{
    PhotoMaster *masterPtr = (PhotoMaster *) masterData;
    PhotoInstance *instancePtr;
    Colormap colormap;
    int mono, nRed, nGreen, nBlue;
    XVisualInfo visualInfo, *visInfoPtr;
    char buf[TCL_INTEGER_SPACE * 3];
    int numVisuals;
    XColor *white, *black;
    XGCValues gcValues;

    /*
     * Table of "best" choices for palette for PseudoColor displays
     * with between 3 and 15 bits/pixel.
     */

    static int paletteChoice[13][3] = {
	/*  #red, #green, #blue */
	 {2,  2,  2,			/* 3 bits, 8 colors */},
	 {2,  3,  2,			/* 4 bits, 12 colors */},
	 {3,  4,  2,			/* 5 bits, 24 colors */},
	 {4,  5,  3,			/* 6 bits, 60 colors */},
	 {5,  6,  4,			/* 7 bits, 120 colors */},
	 {7,  7,  4,			/* 8 bits, 198 colors */},
	 {8, 10,  6,			/* 9 bits, 480 colors */},
	{10, 12,  8,			/* 10 bits, 960 colors */},
	{14, 15,  9,			/* 11 bits, 1890 colors */},
	{16, 20, 12,			/* 12 bits, 3840 colors */},
	{20, 24, 16,			/* 13 bits, 7680 colors */},
	{26, 30, 20,			/* 14 bits, 15600 colors */},
	{32, 32, 30,			/* 15 bits, 30720 colors */}
    };

    /*
     * See if there is already an instance for windows using
     * the same colormap.  If so then just re-use it.
     */

    colormap = Tk_Colormap(tkwin);
    for (instancePtr = masterPtr->instancePtr; instancePtr != NULL;
	    instancePtr = instancePtr->nextPtr) {
	if ((colormap == instancePtr->colormap)
		&& (Tk_Display(tkwin) == instancePtr->display)) {

	    /*
	     * Re-use this instance.
	     */

	    if (instancePtr->refCount == 0) {
		/*
		 * We are resurrecting this instance.
		 */

		Tcl_CancelIdleCall(DisposeInstance, (ClientData) instancePtr);
		if (instancePtr->colorTablePtr != NULL) {
		    FreeColorTable(instancePtr->colorTablePtr, 0);
		}
		GetColorTable(instancePtr);
	    }
	    instancePtr->refCount++;
	    return (ClientData) instancePtr;
	}
    }

    /*
     * The image isn't already in use in a window with the same colormap.
     * Make a new instance of the image.
     */

    instancePtr = (PhotoInstance *) ckalloc(sizeof(PhotoInstance));
    instancePtr->masterPtr = masterPtr;
    instancePtr->display = Tk_Display(tkwin);
    instancePtr->colormap = Tk_Colormap(tkwin);
    Tk_PreserveColormap(instancePtr->display, instancePtr->colormap);
    instancePtr->refCount = 1;
    instancePtr->colorTablePtr = NULL;
    instancePtr->pixels = None;
    instancePtr->error = NULL;
    instancePtr->width = 0;
    instancePtr->height = 0;
    instancePtr->imagePtr = 0;
    instancePtr->nextPtr = masterPtr->instancePtr;
    masterPtr->instancePtr = instancePtr;

    /*
     * Obtain information about the visual and decide on the
     * default palette.
     */

    visualInfo.screen = Tk_ScreenNumber(tkwin);
    visualInfo.visualid = XVisualIDFromVisual(Tk_Visual(tkwin));
    visInfoPtr = XGetVisualInfo(Tk_Display(tkwin),
	    VisualScreenMask | VisualIDMask, &visualInfo, &numVisuals);
    nRed = 2;
    nGreen = nBlue = 0;
    mono = 1;
    if (visInfoPtr != NULL) {
	instancePtr->visualInfo = *visInfoPtr;
	switch (visInfoPtr->class) {
	    case DirectColor:
	    case TrueColor:
		nRed = 1 << CountBits(visInfoPtr->red_mask);
		nGreen = 1 << CountBits(visInfoPtr->green_mask);
		nBlue = 1 << CountBits(visInfoPtr->blue_mask);
		mono = 0;
		break;
	    case PseudoColor:
	    case StaticColor:
		if (visInfoPtr->depth > 15) {
		    nRed = 32;
		    nGreen = 32;
		    nBlue = 32;
		    mono = 0;
		} else if (visInfoPtr->depth >= 3) {
		    int *ip = paletteChoice[visInfoPtr->depth - 3];
    
		    nRed = ip[0];
		    nGreen = ip[1];
		    nBlue = ip[2];
		    mono = 0;
		}
		break;
	    case GrayScale:
	    case StaticGray:
		nRed = 1 << visInfoPtr->depth;
		break;
	}
	XFree((char *) visInfoPtr);

    } else {
	panic("ImgPhotoGet couldn't find visual for window");
    }

    sprintf(buf, ((mono) ? "%d": "%d/%d/%d"), nRed, nGreen, nBlue);
    instancePtr->defaultPalette = Tk_GetUid(buf);

    /*
     * Make a GC with background = black and foreground = white.
     */

    white = Tk_GetColor(masterPtr->interp, tkwin, "white");
    black = Tk_GetColor(masterPtr->interp, tkwin, "black");
    gcValues.foreground = (white != NULL)? white->pixel:
	    WhitePixelOfScreen(Tk_Screen(tkwin));
    gcValues.background = (black != NULL)? black->pixel:
	    BlackPixelOfScreen(Tk_Screen(tkwin));
    gcValues.graphics_exposures = False;
    instancePtr->gc = Tk_GetGC(tkwin,
	    GCForeground|GCBackground|GCGraphicsExposures, &gcValues);

    /*
     * Set configuration options and finish the initialization of the instance.
     * This will also dither the image if necessary.
     */

    ImgPhotoConfigureInstance(instancePtr);

    /*
     * If this is the first instance, must set the size of the image.
     */

    if (instancePtr->nextPtr == NULL) {
	Tk_ImageChanged(masterPtr->tkMaster, 0, 0, 0, 0,
		masterPtr->width, masterPtr->height);
    }

    return (ClientData) instancePtr;
}

/*
 *----------------------------------------------------------------------
 *
 * ImgPhotoDisplay --
 *
 *	This procedure is invoked to draw a photo image.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	A portion of the image gets rendered in a pixmap or window.
 *
 *----------------------------------------------------------------------
 */

static void
ImgPhotoDisplay(clientData, display, drawable, imageX, imageY, width,
	height, drawableX, drawableY)
    ClientData clientData;	/* Pointer to PhotoInstance structure for
				 * for instance to be displayed. */
    Display *display;		/* Display on which to draw image. */
    Drawable drawable;		/* Pixmap or window in which to draw image. */
    int imageX, imageY;		/* Upper-left corner of region within image
				 * to draw. */
    int width, height;		/* Dimensions of region within image to draw. */
    int drawableX, drawableY;	/* Coordinates within drawable that
				 * correspond to imageX and imageY. */
{
    PhotoInstance *instancePtr = (PhotoInstance *) clientData;

    /*
     * If there's no pixmap, it means that an error occurred
     * while creating the image instance so it can't be displayed.
     */

    if (instancePtr->pixels == None) {
	return;
    }

    /*
     * masterPtr->region describes which parts of the image contain
     * valid data.  We set this region as the clip mask for the gc,
     * setting its origin appropriately, and use it when drawing the
     * image.
     */

    TkSetRegion(display, instancePtr->gc, instancePtr->masterPtr->validRegion);
    XSetClipOrigin(display, instancePtr->gc, drawableX - imageX,
	    drawableY - imageY);
    XCopyArea(display, instancePtr->pixels, drawable, instancePtr->gc,
	    imageX, imageY, (unsigned) width, (unsigned) height,
	    drawableX, drawableY);
    XSetClipMask(display, instancePtr->gc, None);
    XSetClipOrigin(display, instancePtr->gc, 0, 0);
}

/*
 *----------------------------------------------------------------------
 *
 * ImgPhotoFree --
 *
 *	This procedure is called when a widget ceases to use a
 *	particular instance of an image.  We don't actually get
 *	rid of the instance until later because we may be about
 *	to get this instance again.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Internal data structures get cleaned up, later.
 *
 *----------------------------------------------------------------------
 */

static void
ImgPhotoFree(clientData, display)
    ClientData clientData;	/* Pointer to PhotoInstance structure for
				 * for instance to be displayed. */
    Display *display;		/* Display containing window that used image. */
{
    PhotoInstance *instancePtr = (PhotoInstance *) clientData;
    ColorTable *colorPtr;

    instancePtr->refCount -= 1;
    if (instancePtr->refCount > 0) {
	return;
    }

    /*
     * There are no more uses of the image within this widget.
     * Decrement the count of live uses of its color table, so
     * that its colors can be reclaimed if necessary, and
     * set up an idle call to free the instance structure.
     */

    colorPtr = instancePtr->colorTablePtr;
    if (colorPtr != NULL) {
	colorPtr->liveRefCount -= 1;
    }
    
    Tcl_DoWhenIdle(DisposeInstance, (ClientData) instancePtr);
}

/*
 *----------------------------------------------------------------------
 *
 * ImgPhotoDelete --
 *
 *	This procedure is called by the image code to delete the
 *	master structure for an image.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Resources associated with the image get freed.
 *
 *----------------------------------------------------------------------
 */

static void
ImgPhotoDelete(masterData)
    ClientData masterData;	/* Pointer to PhotoMaster structure for
				 * image.  Must not have any more instances. */
{
    PhotoMaster *masterPtr = (PhotoMaster *) masterData;
    PhotoInstance *instancePtr;

    while ((instancePtr = masterPtr->instancePtr) != NULL) {
	if (instancePtr->refCount > 0) {
	    panic("tried to delete photo image when instances still exist");
	}
	Tcl_CancelIdleCall(DisposeInstance, (ClientData) instancePtr);
	DisposeInstance((ClientData) instancePtr);
    }
    masterPtr->tkMaster = NULL;
    if (masterPtr->imageCmd != NULL) {
	Tcl_DeleteCommandFromToken(masterPtr->interp, masterPtr->imageCmd);
    }
    if (masterPtr->pix32 != NULL) {
	ckfree((char *) masterPtr->pix32);
    }
    if (masterPtr->validRegion != NULL) {
	TkDestroyRegion(masterPtr->validRegion);
    }
    if (masterPtr->dataString != NULL) {
	Tcl_DecrRefCount(masterPtr->dataString);
    }
    if (masterPtr->format != NULL) {
	Tcl_DecrRefCount(masterPtr->format);
    }
    Tk_FreeOptions(configSpecs, (char *) masterPtr, (Display *) NULL, 0);
    ckfree((char *) masterPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * ImgPhotoCmdDeletedProc --
 *
 *	This procedure is invoked when the image command for an image
 *	is deleted.  It deletes the image.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The image is deleted.
 *
 *----------------------------------------------------------------------
 */

static void
ImgPhotoCmdDeletedProc(clientData)
    ClientData clientData;	/* Pointer to PhotoMaster structure for
				 * image. */
{
    PhotoMaster *masterPtr = (PhotoMaster *) clientData;

    masterPtr->imageCmd = NULL;
    if (masterPtr->tkMaster != NULL) {
	Tk_DeleteImage(masterPtr->interp, Tk_NameOfImage(masterPtr->tkMaster));
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ImgPhotoSetSize --
 *
 *	This procedure reallocates the image storage and instance
 *	pixmaps for a photo image, as necessary, to change the
 *	image's size to `width' x `height' pixels.
 *
 * Results:
 *	TCL_OK if successful, TCL_ERROR if failure occurred (currently
 *	just with memory allocation.)
 *
 * Side effects:
 *	Storage gets reallocated, for the master and all its instances.
 *
 *----------------------------------------------------------------------
 */

static int
ImgPhotoSetSize(masterPtr, width, height)
    PhotoMaster *masterPtr;
    int width, height;
{
    unsigned char *newPix32 = NULL;
    int h, offset, pitch;
    unsigned char *srcPtr, *destPtr;
    XRectangle validBox, clipBox;
    TkRegion clipRegion;
    PhotoInstance *instancePtr;

    if (masterPtr->userWidth > 0) {
	width = masterPtr->userWidth;
    }
    if (masterPtr->userHeight > 0) {
	height = masterPtr->userHeight;
    }

    pitch = width * 4;

    /*
     * Test if we're going to (re)allocate the main buffer now, so
     * that any failures will leave the photo unchanged.
     */
    if ((width != masterPtr->width) || (height != masterPtr->height)
	    || (masterPtr->pix32 == NULL)) {
	/*
	 * Not a u-long, but should be one.
	 */
	unsigned /*long*/ newPixSize = (unsigned /*long*/) (height * pitch);

	newPix32 = (unsigned char *) attemptckalloc(newPixSize);
	/*
	 * The result could validly be NULL if the number of bytes
	 * requested was 0. [Bug 619544]
	 */
	if (newPix32 == NULL && newPixSize != 0) {
	    return TCL_ERROR;
	}
    }

    /*
     * We have to trim the valid region if it is currently
     * larger than the new image size.
     */

    TkClipBox(masterPtr->validRegion, &validBox);
    if ((validBox.x + validBox.width > width)
	    || (validBox.y + validBox.height > height)) {
	clipBox.x = 0;
	clipBox.y = 0;
	clipBox.width = width;
	clipBox.height = height;
	clipRegion = TkCreateRegion();
	TkUnionRectWithRegion(&clipBox, clipRegion, clipRegion);
	TkIntersectRegion(masterPtr->validRegion, clipRegion,
		masterPtr->validRegion);
	TkDestroyRegion(clipRegion);
	TkClipBox(masterPtr->validRegion, &validBox);
    }

    /*
     * Use the reallocated storage (allocation above) for the 32-bit
     * image and copy over valid regions.  Note that this test is true
     * precisely when the allocation has already been done.
     */
    if (newPix32 != NULL) {
	/*
	 * Zero the new array.  The dithering code shouldn't read the
	 * areas outside validBox, but they might be copied to another
	 * photo image or written to a file.
	 */

	if ((masterPtr->pix32 != NULL)
	    && ((width == masterPtr->width) || (width == validBox.width))) {
	    if (validBox.y > 0) {
		memset((VOID *) newPix32, 0, (size_t) (validBox.y * pitch));
	    }
	    h = validBox.y + validBox.height;
	    if (h < height) {
		memset((VOID *) (newPix32 + h * pitch), 0,
			(size_t) ((height - h) * pitch));
	    }
	} else {
	    memset((VOID *) newPix32, 0, (size_t) (height * pitch));
	}

	if (masterPtr->pix32 != NULL) {

	    /*
	     * Copy the common area over to the new array array and
	     * free the old array.
	     */

	    if (width == masterPtr->width) {

		/*
		 * The region to be copied is contiguous.
		 */

		offset = validBox.y * pitch;
		memcpy((VOID *) (newPix32 + offset),
			(VOID *) (masterPtr->pix32 + offset),
			(size_t) (validBox.height * pitch));

	    } else if ((validBox.width > 0) && (validBox.height > 0)) {

		/*
		 * Area to be copied is not contiguous - copy line by line.
		 */

		destPtr = newPix32 + (validBox.y * width + validBox.x) * 4;
		srcPtr = masterPtr->pix32 + (validBox.y * masterPtr->width
			+ validBox.x) * 4;
		for (h = validBox.height; h > 0; h--) {
		    memcpy((VOID *) destPtr, (VOID *) srcPtr,
			    (size_t) (validBox.width * 4));
		    destPtr += width * 4;
		    srcPtr += masterPtr->width * 4;
		}
	    }

	    ckfree((char *) masterPtr->pix32);
	}

	masterPtr->pix32 = newPix32;
	masterPtr->width = width;
	masterPtr->height = height;

	/*
	 * Dithering will be correct up to the end of the last
	 * pre-existing complete scanline.
	 */

	if ((validBox.x > 0) || (validBox.y > 0)) {
	    masterPtr->ditherX = 0;
	    masterPtr->ditherY = 0;
	} else if (validBox.width == width) {
	    if ((int) validBox.height < masterPtr->ditherY) {
		masterPtr->ditherX = 0;
		masterPtr->ditherY = validBox.height;
	    }
	} else if ((masterPtr->ditherY > 0)
		|| ((int) validBox.width < masterPtr->ditherX)) {
	    masterPtr->ditherX = validBox.width;
	    masterPtr->ditherY = 0;
	}
    }

    /*
     * Now adjust the sizes of the pixmaps for all of the instances.
     */

    for (instancePtr = masterPtr->instancePtr; instancePtr != NULL;
	    instancePtr = instancePtr->nextPtr) {
	ImgPhotoInstanceSetSize(instancePtr);
    }

    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ImgPhotoInstanceSetSize --
 *
 * 	This procedure reallocates the instance pixmap and dithering
 *	error array for a photo instance, as necessary, to change the
 *	image's size to `width' x `height' pixels.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Storage gets reallocated, here and in the X server.
 *
 *----------------------------------------------------------------------
 */

static void
ImgPhotoInstanceSetSize(instancePtr)
    PhotoInstance *instancePtr;		/* Instance whose size is to be
					 * changed. */
{
    PhotoMaster *masterPtr;
    schar *newError;
    schar *errSrcPtr, *errDestPtr;
    int h, offset;
    XRectangle validBox;
    Pixmap newPixmap;

    masterPtr = instancePtr->masterPtr;
    TkClipBox(masterPtr->validRegion, &validBox);

    if ((instancePtr->width != masterPtr->width)
	    || (instancePtr->height != masterPtr->height)
	    || (instancePtr->pixels == None)) {
	newPixmap = Tk_GetPixmap(instancePtr->display,
		RootWindow(instancePtr->display,
		    instancePtr->visualInfo.screen),
		(masterPtr->width > 0) ? masterPtr->width: 1,
		(masterPtr->height > 0) ? masterPtr->height: 1,
		instancePtr->visualInfo.depth);
        if (!newPixmap) {
            panic("Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\n");
            return;
        }

	/*
	 * The following is a gross hack needed to properly support colormaps
	 * under Windows.  Before the pixels can be copied to the pixmap,
	 * the relevent colormap must be associated with the drawable.
	 * Normally we can infer this association from the window that
	 * was used to create the pixmap.  However, in this case we're
	 * using the root window, so we have to be more explicit.
	 */

	TkSetPixmapColormap(newPixmap, instancePtr->colormap);

	if (instancePtr->pixels != None) {
	    /*
	     * Copy any common pixels from the old pixmap and free it.
	     */
	    XCopyArea(instancePtr->display, instancePtr->pixels, newPixmap,
		    instancePtr->gc, validBox.x, validBox.y,
		    validBox.width, validBox.height, validBox.x, validBox.y);
	    Tk_FreePixmap(instancePtr->display, instancePtr->pixels);
	}
	instancePtr->pixels = newPixmap;
    }

    if ((instancePtr->width != masterPtr->width)
	    || (instancePtr->height != masterPtr->height)
	    || (instancePtr->error == NULL)) {

	newError = (schar *) ckalloc((unsigned)
		(masterPtr->height * masterPtr->width * 3 * sizeof(schar)));

	/*
	 * Zero the new array so that we don't get bogus error values
	 * propagating into areas we dither later.
	 */

	if ((instancePtr->error != NULL)
	    && ((instancePtr->width == masterPtr->width)
		|| (validBox.width == masterPtr->width))) {
	    if (validBox.y > 0) {
		memset((VOID *) newError, 0, (size_t)
			(validBox.y * masterPtr->width * 3 * sizeof(schar)));
	    }
	    h = validBox.y + validBox.height;
	    if (h < masterPtr->height) {
		memset((VOID *) (newError + h * masterPtr->width * 3), 0,
			(size_t) ((masterPtr->height - h)
			    * masterPtr->width * 3 * sizeof(schar)));
	    }
	} else {
	    memset((VOID *) newError, 0, (size_t)
		    (masterPtr->height * masterPtr->width * 3 * sizeof(schar)));
	}

	if (instancePtr->error != NULL) {

	    /*
	     * Copy the common area over to the new array
	     * and free the old array.
	     */

	    if (masterPtr->width == instancePtr->width) {

		offset = validBox.y * masterPtr->width * 3;
		memcpy((VOID *) (newError + offset),
			(VOID *) (instancePtr->error + offset),
			(size_t) (validBox.height
			* masterPtr->width * 3 * sizeof(schar)));

	    } else if (validBox.width > 0 && validBox.height > 0) {

		errDestPtr = newError
			+ (validBox.y * masterPtr->width + validBox.x) * 3;
		errSrcPtr = instancePtr->error
			+ (validBox.y * instancePtr->width + validBox.x) * 3;
		for (h = validBox.height; h > 0; --h) {
		    memcpy((VOID *) errDestPtr, (VOID *) errSrcPtr,
			    validBox.width * 3 * sizeof(schar));
		    errDestPtr += masterPtr->width * 3;
		    errSrcPtr += instancePtr->width * 3;
		}
	    }
	    ckfree((char *) instancePtr->error);
	}

	instancePtr->error = newError;
    }

    instancePtr->width = masterPtr->width;
    instancePtr->height = masterPtr->height;
}

/*
 *----------------------------------------------------------------------
 *
 * IsValidPalette --
 *
 *	This procedure is called to check whether a value given for
 *	the -palette option is valid for a particular instance
 * 	of a photo image.
 *
 * Results:
 *	A boolean value: 1 if the palette is acceptable, 0 otherwise.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
IsValidPalette(instancePtr, palette)
    PhotoInstance *instancePtr;		/* Instance to which the palette
					 * specification is to be applied. */
    CONST char *palette;		/* Palette specification string. */
{
    int nRed, nGreen, nBlue, mono, numColors;
    char *endp;

    /*
     * First parse the specification: it must be of the form
     * %d or %d/%d/%d.
     */

    nRed = strtol(palette, &endp, 10);
    if ((endp == palette) || ((*endp != 0) && (*endp != '/'))
	    || (nRed < 2) || (nRed > 256)) {
	return 0;
    }

    if (*endp == 0) {
	mono = 1;
	nGreen = nBlue = nRed;
    } else {
	palette = endp + 1;
	nGreen = strtol(palette, &endp, 10);
	if ((endp == palette) || (*endp != '/') || (nGreen < 2)
		|| (nGreen > 256)) {
	    return 0;
	}
	palette = endp + 1;
	nBlue = strtol(palette, &endp, 10);
	if ((endp == palette) || (*endp != 0) || (nBlue < 2)
		|| (nBlue > 256)) {
	    return 0;
	}
	mono = 0;
    }

    switch (instancePtr->visualInfo.class) {
	case DirectColor:
	case TrueColor:
	    if ((nRed > (1 << CountBits(instancePtr->visualInfo.red_mask)))
		    || (nGreen > (1
			<< CountBits(instancePtr->visualInfo.green_mask)))
		    || (nBlue > (1
			<< CountBits(instancePtr->visualInfo.blue_mask)))) {
		return 0;
	    }
	    break;
	case PseudoColor:
	case StaticColor:
	    numColors = nRed;
	    if (!mono) {
		numColors *= nGreen*nBlue;
	    }
	    if (numColors > (1 << instancePtr->visualInfo.depth)) {
		return 0;
	    }
	    break;
	case GrayScale:
	case StaticGray:
	    if (!mono || (nRed > (1 << instancePtr->visualInfo.depth))) {
		return 0;
	    }
	    break;
    }

    return 1;
}

/*
 *----------------------------------------------------------------------
 *
 * CountBits --
 *
 *	This procedure counts how many bits are set to 1 in `mask'.
 *
 * Results:
 *	The integer number of bits.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
CountBits(mask)
    pixel mask;			/* Value to count the 1 bits in. */
{
    int n;

    for( n = 0; mask != 0; mask &= mask - 1 )
	n++;
    return n;
}

/*
 *----------------------------------------------------------------------
 *
 * GetColorTable --
 *
 *	This procedure is called to allocate a table of colormap
 *	information for an instance of a photo image.  Only one such
 *	table is allocated for all photo instances using the same
 *	display, colormap, palette and gamma values, so that the
 *	application need only request a set of colors from the X
 *	server once for all such photo widgets.  This procedure
 *	maintains a hash table to find previously-allocated
 *	ColorTables.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	A new ColorTable may be allocated and placed in the hash
 *	table, and have colors allocated for it.
 *
 *----------------------------------------------------------------------
 */

static void
GetColorTable(instancePtr)
    PhotoInstance *instancePtr;		/* Instance needing a color table. */
{
    ColorTable *colorPtr;
    Tcl_HashEntry *entry;
    ColorTableId id;
    int isNew;

    /*
     * Look for an existing ColorTable in the hash table.
     */

    memset((VOID *) &id, 0, sizeof(id));
    id.display = instancePtr->display;
    id.colormap = instancePtr->colormap;
    id.palette = instancePtr->palette;
    id.gamma = instancePtr->gamma;
    if (!imgPhotoColorHashInitialized) {
	Tcl_InitHashTable(&imgPhotoColorHash, N_COLOR_HASH);
	imgPhotoColorHashInitialized = 1;
    }
    entry = Tcl_CreateHashEntry(&imgPhotoColorHash, (char *) &id, &isNew);

    if (!isNew) {
	/*
	 * Re-use the existing entry.
	 */

	colorPtr = (ColorTable *) Tcl_GetHashValue(entry);

    } else {
	/*
	 * No color table currently available; need to make one.
	 */

	colorPtr = (ColorTable *) ckalloc(sizeof(ColorTable));

	/*
	 * The following line of code should not normally be needed due
	 * to the assignment in the following line.  However, it compensates
	 * for bugs in some compilers (HP, for example) where
	 * sizeof(ColorTable) is 24 but the assignment only copies 20 bytes,
	 * leaving 4 bytes uninitialized;  these cause problems when using
	 * the id for lookups in imgPhotoColorHash, and can result in
	 * core dumps.
	 */

	memset((VOID *) &colorPtr->id, 0, sizeof(ColorTableId));
	colorPtr->id = id;
	Tk_PreserveColormap(colorPtr->id.display, colorPtr->id.colormap);
	colorPtr->flags = 0;
	colorPtr->refCount = 0;
	colorPtr->liveRefCount = 0;
	colorPtr->numColors = 0;
	colorPtr->visualInfo = instancePtr->visualInfo;
	colorPtr->pixelMap = NULL;
	Tcl_SetHashValue(entry, colorPtr);
    }

    colorPtr->refCount++;
    colorPtr->liveRefCount++;
    instancePtr->colorTablePtr = colorPtr;
    if (colorPtr->flags & DISPOSE_PENDING) {
	Tcl_CancelIdleCall(DisposeColorTable, (ClientData) colorPtr);
	colorPtr->flags &= ~DISPOSE_PENDING;
    }

    /*
     * Allocate colors for this color table if necessary.
     */

    if ((colorPtr->numColors == 0)
	    && ((colorPtr->flags & BLACK_AND_WHITE) == 0)) {
	AllocateColors(colorPtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * FreeColorTable --
 *
 *	This procedure is called when an instance ceases using a
 *	color table.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	If no other instances are using this color table, a when-idle
 *	handler is registered to free up the color table and the colors
 *	allocated for it.
 *
 *----------------------------------------------------------------------
 */

static void
FreeColorTable(colorPtr, force)
    ColorTable *colorPtr;	/* Pointer to the color table which is
				 * no longer required by an instance. */
    int force;			/* Force free to happen immediately. */
{
    colorPtr->refCount--;
    if (colorPtr->refCount > 0) {
	return;
    }
    if (force) {
	if ((colorPtr->flags & DISPOSE_PENDING) != 0) {
	    Tcl_CancelIdleCall(DisposeColorTable, (ClientData) colorPtr);
	    colorPtr->flags &= ~DISPOSE_PENDING;
	}
	DisposeColorTable((ClientData) colorPtr);
    } else if ((colorPtr->flags & DISPOSE_PENDING) == 0) {
	Tcl_DoWhenIdle(DisposeColorTable, (ClientData) colorPtr);
	colorPtr->flags |= DISPOSE_PENDING;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * AllocateColors --
 *
 *	This procedure allocates the colors required by a color table,
 *	and sets up the fields in the color table data structure which
 *	are used in dithering.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Colors are allocated from the X server.  Fields in the
 *	color table data structure are updated.
 *
 *----------------------------------------------------------------------
 */

static void
AllocateColors(colorPtr)
    ColorTable *colorPtr;	/* Pointer to the color table requiring
				 * colors to be allocated. */
{
    int i, r, g, b, rMult, mono;
    int numColors, nRed, nGreen, nBlue;
    double fr, fg, fb, igam;
    XColor *colors;
    unsigned long *pixels;

    /* 16-bit intensity value for i/n of full intensity. */
#   define CFRAC(i, n)	((i) * 65535 / (n))

    /* As for CFRAC, but apply exponent of g. */
#   define CGFRAC(i, n, g)	((int)(65535 * pow((double)(i) / (n), (g))))

    /*
     * First parse the palette specification to get the required number of
     * shades of each primary.
     */

    mono = sscanf(colorPtr->id.palette, "%d/%d/%d", &nRed, &nGreen, &nBlue)
	    <= 1;
    igam = 1.0 / colorPtr->id.gamma;

    /*
     * Each time around this loop, we reduce the number of colors we're
     * trying to allocate until we succeed in allocating all of the colors
     * we need.
     */

    for (;;) {
	/*
	 * If we are using 1 bit/pixel, we don't need to allocate
	 * any colors (we just use the foreground and background
	 * colors in the GC).
	 */

	if (mono && (nRed <= 2)) {
	    colorPtr->flags |= BLACK_AND_WHITE;
	    return;
	}

	/*
	 * Calculate the RGB coordinates of the colors we want to
	 * allocate and store them in *colors.
	 */

	if ((colorPtr->visualInfo.class == DirectColor)
	    || (colorPtr->visualInfo.class == TrueColor)) {

	    /*
	     * Direct/True Color: allocate shades of red, green, blue
	     * independently.
	     */

	    if (mono) {
		numColors = nGreen = nBlue = nRed;
	    } else {
		numColors = MAX(MAX(nRed, nGreen), nBlue);
	    }
	    colors = (XColor *) ckalloc(numColors * sizeof(XColor));

	    for (i = 0; i < numColors; ++i) {
		if (igam == 1.0) {
		    colors[i].red = CFRAC(i, nRed - 1);
		    colors[i].green = CFRAC(i, nGreen - 1);
		    colors[i].blue = CFRAC(i, nBlue - 1);
		} else {
		    colors[i].red = CGFRAC(i, nRed - 1, igam);
		    colors[i].green = CGFRAC(i, nGreen - 1, igam);
		    colors[i].blue = CGFRAC(i, nBlue - 1, igam);
		}
	    }
	} else {
	    /*
	     * PseudoColor, StaticColor, GrayScale or StaticGray visual:
	     * we have to allocate each color in the color cube separately.
	     */

	    numColors = (mono) ? nRed: (nRed * nGreen * nBlue);
	    colors = (XColor *) ckalloc(numColors * sizeof(XColor));

	    if (!mono) {
		/*
		 * Color display using a PseudoColor or StaticColor visual.
		 */

		i = 0;
		for (r = 0; r < nRed; ++r) {
		    for (g = 0; g < nGreen; ++g) {
			for (b = 0; b < nBlue; ++b) {
			    if (igam == 1.0) {
				colors[i].red = CFRAC(r, nRed - 1);
				colors[i].green = CFRAC(g, nGreen - 1);
				colors[i].blue = CFRAC(b, nBlue - 1);
			    } else {
				colors[i].red = CGFRAC(r, nRed - 1, igam);
				colors[i].green = CGFRAC(g, nGreen - 1, igam);
				colors[i].blue = CGFRAC(b, nBlue - 1, igam);
			    }
			    i++;
			}
		    }
		}
	    } else {
		/*
		 * Monochrome display - allocate the shades of grey we want.
		 */

		for (i = 0; i < numColors; ++i) {
		    if (igam == 1.0) {
			r = CFRAC(i, numColors - 1);
		    } else {
			r = CGFRAC(i, numColors - 1, igam);
		    }
		    colors[i].red = colors[i].green = colors[i].blue = r;
		}
	    }
	}

	/*
	 * Now try to allocate the colors we've calculated.
	 */

	pixels = (unsigned long *) ckalloc(numColors * sizeof(unsigned long));
	for (i = 0; i < numColors; ++i) {
	    if (!XAllocColor(colorPtr->id.display, colorPtr->id.colormap,
		    &colors[i])) {

		/*
		 * Can't get all the colors we want in the default colormap;
		 * first try freeing colors from other unused color tables.
		 */

		if (!ReclaimColors(&colorPtr->id, numColors - i)
			|| !XAllocColor(colorPtr->id.display,
			colorPtr->id.colormap, &colors[i])) {
		    /*
		     * Still can't allocate the color.
		     */
		    break;
		}
	    }
	    pixels[i] = colors[i].pixel;
	}

	/*
	 * If we didn't get all of the colors, reduce the
	 * resolution of the color cube, free the ones we got,
	 * and try again.
	 */

	if (i >= numColors) {
	    break;
	}
	XFreeColors(colorPtr->id.display, colorPtr->id.colormap, pixels, i, 0);
	ckfree((char *) colors);
	ckfree((char *) pixels);

	if (!mono) {
	    if ((nRed == 2) && (nGreen == 2) && (nBlue == 2)) {
		/*
		 * Fall back to 1-bit monochrome display.
		 */

		mono = 1;
	    } else {
		/*
		 * Reduce the number of shades of each primary to about
		 * 3/4 of the previous value.  This should reduce the
		 * total number of colors required to about half the
		 * previous value for PseudoColor displays.
		 */

		nRed = (nRed * 3 + 2) / 4;
		nGreen = (nGreen * 3 + 2) / 4;
		nBlue = (nBlue * 3 + 2) / 4;
	    }
	} else {
	    /*
	     * Reduce the number of shades of gray to about 1/2.
	     */

	    nRed = nRed / 2;
	}
    }
    
    /*
     * We have allocated all of the necessary colors:
     * fill in various fields of the ColorTable record.
     */

    if (!mono) {
	colorPtr->flags |= COLOR_WINDOW;

	/*
	 * The following is a hairy hack.  We only want to index into
	 * the pixelMap on colormap displays.  However, if the display
	 * is on Windows, then we actually want to store the index not
	 * the value since we will be passing the color table into the
	 * TkPutImage call.
	 */
	
#ifndef __WIN32__
	if ((colorPtr->visualInfo.class != DirectColor)
		&& (colorPtr->visualInfo.class != TrueColor)) {
	    colorPtr->flags |= MAP_COLORS;
	}
#endif /* __WIN32__ */
    }

    colorPtr->numColors = numColors;
    colorPtr->pixelMap = pixels;

    /*
     * Set up quantization tables for dithering.
     */
    rMult = nGreen * nBlue;
    for (i = 0; i < 256; ++i) {
	r = (i * (nRed - 1) + 127) / 255;
	if (mono) {
	    fr = (double) colors[r].red / 65535.0;
	    if (colorPtr->id.gamma != 1.0 ) {
		fr = pow(fr, colorPtr->id.gamma);
	    }
	    colorPtr->colorQuant[0][i] = (int)(fr * 255.99);
	    colorPtr->redValues[i] = colors[r].pixel;
	} else {
	    g = (i * (nGreen - 1) + 127) / 255;
	    b = (i * (nBlue - 1) + 127) / 255;
	    if ((colorPtr->visualInfo.class == DirectColor)
		    || (colorPtr->visualInfo.class == TrueColor)) {
		colorPtr->redValues[i] = colors[r].pixel
		    & colorPtr->visualInfo.red_mask;
		colorPtr->greenValues[i] = colors[g].pixel
		    & colorPtr->visualInfo.green_mask;
		colorPtr->blueValues[i] = colors[b].pixel
		    & colorPtr->visualInfo.blue_mask;
	    } else {
		r *= rMult;
		g *= nBlue;
		colorPtr->redValues[i] = r;
		colorPtr->greenValues[i] = g;
		colorPtr->blueValues[i] = b;
	    }
	    fr = (double) colors[r].red / 65535.0;
	    fg = (double) colors[g].green / 65535.0;
	    fb = (double) colors[b].blue / 65535.0;
	    if (colorPtr->id.gamma != 1.0) {
		fr = pow(fr, colorPtr->id.gamma);
		fg = pow(fg, colorPtr->id.gamma);
		fb = pow(fb, colorPtr->id.gamma);
	    }
	    colorPtr->colorQuant[0][i] = (int)(fr * 255.99);
	    colorPtr->colorQuant[1][i] = (int)(fg * 255.99);
	    colorPtr->colorQuant[2][i] = (int)(fb * 255.99);
	}
    }

    ckfree((char *) colors);
}

/*
 *----------------------------------------------------------------------
 *
 * DisposeColorTable --
 *
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The colors in the argument color table are freed, as is the
 *	color table structure itself.  The color table is removed
 *	from the hash table which is used to locate color tables.
 *
 *----------------------------------------------------------------------
 */

static void
DisposeColorTable(clientData)
    ClientData clientData;	/* Pointer to the ColorTable whose
				 * colors are to be released. */
{
    ColorTable *colorPtr;
    Tcl_HashEntry *entry;

    colorPtr = (ColorTable *) clientData;
    if (colorPtr->pixelMap != NULL) {
	if (colorPtr->numColors > 0) {
	    XFreeColors(colorPtr->id.display, colorPtr->id.colormap,
		    colorPtr->pixelMap, colorPtr->numColors, 0);
	    Tk_FreeColormap(colorPtr->id.display, colorPtr->id.colormap);
	}
	ckfree((char *) colorPtr->pixelMap);
    }

    entry = Tcl_FindHashEntry(&imgPhotoColorHash, (char *) &colorPtr->id);
    if (entry == NULL) {
	panic("DisposeColorTable couldn't find hash entry");
    }
    Tcl_DeleteHashEntry(entry);

    ckfree((char *) colorPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * ReclaimColors --
 *
 *	This procedure is called to try to free up colors in the
 *	colormap used by a color table.  It looks for other color
 *	tables with the same colormap and with a zero live reference
 *	count, and frees their colors.  It only does so if there is
 *	the possibility of freeing up at least `numColors' colors.
 *
 * Results:
 *	The return value is TRUE if any colors were freed, FALSE
 *	otherwise.
 *
 * Side effects:
 *	ColorTables which are not currently in use may lose their
 *	color allocations.
 *
 *---------------------------------------------------------------------- */

static int
ReclaimColors(id, numColors)
    ColorTableId *id;		/* Pointer to information identifying
				 * the color table which needs more colors. */
    int numColors;		/* Number of colors required. */
{
    Tcl_HashSearch srch;
    Tcl_HashEntry *entry;
    ColorTable *colorPtr;
    int nAvail;

    /*
     * First scan through the color hash table to get an
     * upper bound on how many colors we might be able to free.
     */

    nAvail = 0;
    entry = Tcl_FirstHashEntry(&imgPhotoColorHash, &srch);
    while (entry != NULL) {
	colorPtr = (ColorTable *) Tcl_GetHashValue(entry);
	if ((colorPtr->id.display == id->display)
	    && (colorPtr->id.colormap == id->colormap)
	    && (colorPtr->liveRefCount == 0 )&& (colorPtr->numColors != 0)
	    && ((colorPtr->id.palette != id->palette)
		|| (colorPtr->id.gamma != id->gamma))) {

	    /*
	     * We could take this guy's colors off him.
	     */

	    nAvail += colorPtr->numColors;
	}
	entry = Tcl_NextHashEntry(&srch);
    }

    /*
     * nAvail is an (over)estimate of the number of colors we could free.
     */

    if (nAvail < numColors) {
	return 0;
    }

    /*
     * Scan through a second time freeing colors.
     */

    entry = Tcl_FirstHashEntry(&imgPhotoColorHash, &srch);
    while ((entry != NULL) && (numColors > 0)) {
	colorPtr = (ColorTable *) Tcl_GetHashValue(entry);
	if ((colorPtr->id.display == id->display)
		&& (colorPtr->id.colormap == id->colormap)
		&& (colorPtr->liveRefCount == 0) && (colorPtr->numColors != 0)
		&& ((colorPtr->id.palette != id->palette)
		    || (colorPtr->id.gamma != id->gamma))) {

	    /*
	     * Free the colors that this ColorTable has.
	     */

	    XFreeColors(colorPtr->id.display, colorPtr->id.colormap,
		    colorPtr->pixelMap, colorPtr->numColors, 0);
	    numColors -= colorPtr->numColors;
	    colorPtr->numColors = 0;
	    ckfree((char *) colorPtr->pixelMap);
	    colorPtr->pixelMap = NULL;
	}

	entry = Tcl_NextHashEntry(&srch);
    }
    return 1;			/* we freed some colors */
}

/*
 *----------------------------------------------------------------------
 *
 * DisposeInstance --
 *
 *	This procedure is called to finally free up an instance
 *	of a photo image which is no longer required.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The instance data structure and the resources it references
 *	are freed.
 *
 *----------------------------------------------------------------------
 */

static void
DisposeInstance(clientData)
    ClientData clientData;	/* Pointer to the instance whose resources
				 * are to be released. */
{
    PhotoInstance *instancePtr = (PhotoInstance *) clientData;
    PhotoInstance *prevPtr;

    if (instancePtr->pixels != None) {
	Tk_FreePixmap(instancePtr->display, instancePtr->pixels);
    }
    if (instancePtr->gc != None) {
	Tk_FreeGC(instancePtr->display, instancePtr->gc);
    }
    if (instancePtr->imagePtr != NULL) {
	XFree((char *) instancePtr->imagePtr);
    }
    if (instancePtr->error != NULL) {
	ckfree((char *) instancePtr->error);
    }
    if (instancePtr->colorTablePtr != NULL) {
	FreeColorTable(instancePtr->colorTablePtr, 1);
    }

    if (instancePtr->masterPtr->instancePtr == instancePtr) {
	instancePtr->masterPtr->instancePtr = instancePtr->nextPtr;
    } else {
	for (prevPtr = instancePtr->masterPtr->instancePtr;
		prevPtr->nextPtr != instancePtr; prevPtr = prevPtr->nextPtr) {
	    /* Empty loop body */
	}
	prevPtr->nextPtr = instancePtr->nextPtr;
    }
    Tk_FreeColormap(instancePtr->display, instancePtr->colormap);
    ckfree((char *) instancePtr);
}

/*
 *----------------------------------------------------------------------
 *
 * MatchFileFormat --
 *
 *	This procedure is called to find a photo image file format
 *	handler which can parse the image data in the given file.
 *	If a user-specified format string is provided, only handlers
 *	whose names match a prefix of the format string are tried.
 *
 * Results:
 *	A standard TCL return value.  If the return value is TCL_OK, a
 *	pointer to the image format record is returned in
 *	*imageFormatPtr, and the width and height of the image are
 *	returned in *widthPtr and *heightPtr.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
MatchFileFormat(interp, chan, fileName, formatObj, imageFormatPtr,
	widthPtr, heightPtr, oldformat)
    Tcl_Interp *interp;		/* Interpreter to use for reporting errors. */
    Tcl_Channel chan;		/* The image file, open for reading. */
    char *fileName;		/* The name of the image file. */
    Tcl_Obj *formatObj;		/* User-specified format string, or NULL. */
    Tk_PhotoImageFormat **imageFormatPtr;
				/* A pointer to the photo image format
				 * record is returned here. */
    int *widthPtr, *heightPtr;	/* The dimensions of the image are
				 * returned here. */
    int *oldformat;
{
    int matched;
    int useoldformat = 0;
    Tk_PhotoImageFormat *formatPtr;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    char *formatString = NULL;

    if (formatObj) {
	formatString = Tcl_GetString(formatObj);
    }

    /*
     * Scan through the table of file format handlers to find
     * one which can handle the image.
     */

    matched = 0;
    for (formatPtr = tsdPtr->formatList; formatPtr != NULL;
	 formatPtr = formatPtr->nextPtr) {
	if (formatObj != NULL) {
	    if (strncasecmp(formatString,
		    formatPtr->name, strlen(formatPtr->name)) != 0) {
		continue;
	    }
	    matched = 1;
	    if (formatPtr->fileMatchProc == NULL) {
		Tcl_AppendResult(interp, "-file option isn't supported for ",
			formatString, " images", (char *) NULL);
		return TCL_ERROR;
	    }
	}
	if (formatPtr->fileMatchProc != NULL) {
	    (void) Tcl_Seek(chan, Tcl_LongAsWide(0L), SEEK_SET);
	    
	    if ((*formatPtr->fileMatchProc)(chan, fileName, formatObj,
		    widthPtr, heightPtr, interp)) {
		if (*widthPtr < 1) {
		    *widthPtr = 1;
		}
		if (*heightPtr < 1) {
		    *heightPtr = 1;
		}
		break;
	    }
	}
    }
    if (formatPtr == NULL) {
	useoldformat = 1;
	for (formatPtr = tsdPtr->oldFormatList; formatPtr != NULL;
		formatPtr = formatPtr->nextPtr) {
	    if (formatString != NULL) {
		if (strncasecmp(formatString,
			formatPtr->name, strlen(formatPtr->name)) != 0) {
		    continue;
		}
		matched = 1;
		if (formatPtr->fileMatchProc == NULL) {
		    Tcl_AppendResult(interp, "-file option isn't supported",
			    " for ", formatString, " images", (char *) NULL);
		    return TCL_ERROR;
		}
	    }
	    if (formatPtr->fileMatchProc != NULL) {
		(void) Tcl_Seek(chan, Tcl_LongAsWide(0L), SEEK_SET);
		if ((*formatPtr->fileMatchProc)(chan, fileName, (Tcl_Obj *)
			formatString, widthPtr, heightPtr, interp)) {
		    if (*widthPtr < 1) {
			*widthPtr = 1;
		    }
		    if (*heightPtr < 1) {
			*heightPtr = 1;
		    }
		    break;
		}
	    }
	}
    }

    if (formatPtr == NULL) {
	if ((formatObj != NULL) && !matched) {
	    Tcl_AppendResult(interp, "image file format \"",
		    formatString,
		    "\" is not supported", (char *) NULL);
	} else {
	    Tcl_AppendResult(interp,
		    "couldn't recognize data in image file \"",
		    fileName, "\"", (char *) NULL);
	}
	return TCL_ERROR;
    }

    *imageFormatPtr = formatPtr;
    *oldformat = useoldformat;
    (void) Tcl_Seek(chan, Tcl_LongAsWide(0L), SEEK_SET);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * MatchStringFormat --
 *
 *	This procedure is called to find a photo image file format
 *	handler which can parse the image data in the given string.
 *	If a user-specified format string is provided, only handlers
 *	whose names match a prefix of the format string are tried.
 *
 * Results:
 *	A standard TCL return value.  If the return value is TCL_OK, a
 *	pointer to the image format record is returned in
 *	*imageFormatPtr, and the width and height of the image are
 *	returned in *widthPtr and *heightPtr.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
MatchStringFormat(interp, data, formatObj, imageFormatPtr,
	widthPtr, heightPtr, oldformat)
    Tcl_Interp *interp;		/* Interpreter to use for reporting errors. */
    Tcl_Obj *data;		/* Object containing the image data. */
    Tcl_Obj *formatObj;		/* User-specified format string, or NULL. */
    Tk_PhotoImageFormat **imageFormatPtr;
				/* A pointer to the photo image format
				 * record is returned here. */
    int *widthPtr, *heightPtr;	/* The dimensions of the image are
				 * returned here. */
    int *oldformat;		/* returns 1 if the old image API is used */
{
    int matched;
    int useoldformat = 0;
    Tk_PhotoImageFormat *formatPtr;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    char *formatString = NULL;
    
    if (formatObj) {
	formatString = Tcl_GetString(formatObj);
    }

    /*
     * Scan through the table of file format handlers to find
     * one which can handle the image.
     */

    matched = 0;
    for (formatPtr = tsdPtr->formatList; formatPtr != NULL;
	    formatPtr = formatPtr->nextPtr) {
	if (formatObj != NULL) {
	    if (strncasecmp(formatString,
		    formatPtr->name, strlen(formatPtr->name)) != 0) {
		continue;
	    }
	    matched = 1;
	    if (formatPtr->stringMatchProc == NULL) {
		Tcl_AppendResult(interp, "-data option isn't supported for ",
			formatString, " images", (char *) NULL);
		return TCL_ERROR;
	    }
	}
	if ((formatPtr->stringMatchProc != NULL)
		&& (formatPtr->stringReadProc != NULL)
		&& (*formatPtr->stringMatchProc)(data, formatObj,
		widthPtr, heightPtr, interp)) {
	    break;
	}
    }

    if (formatPtr == NULL) {
	useoldformat = 1;
	for (formatPtr = tsdPtr->oldFormatList; formatPtr != NULL;
		formatPtr = formatPtr->nextPtr) {
	    if (formatObj != NULL) {
		if (strncasecmp(formatString,
			formatPtr->name, strlen(formatPtr->name)) != 0) {
		    continue;
		}
		matched = 1;
		if (formatPtr->stringMatchProc == NULL) {
		    Tcl_AppendResult(interp, "-data option isn't supported",
			    " for ", formatString, " images", (char *) NULL);
		    return TCL_ERROR;
		}
	    }
	    if ((formatPtr->stringMatchProc != NULL)
		    && (formatPtr->stringReadProc != NULL)
		    && (*formatPtr->stringMatchProc)(
			    (Tcl_Obj *) Tcl_GetString(data),
			    (Tcl_Obj *) formatString,
			    widthPtr, heightPtr, interp)) {
		break;
	    }
	}
    }
    if (formatPtr == NULL) {
	if ((formatObj != NULL) && !matched) {
	    Tcl_AppendResult(interp, "image format \"", formatString,
		    "\" is not supported", (char *) NULL);
	} else {
	    Tcl_AppendResult(interp, "couldn't recognize image data",
		    (char *) NULL);
	}
	return TCL_ERROR;
    }

    *imageFormatPtr = formatPtr;
    *oldformat = useoldformat;
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_FindPhoto --
 *
 *	This procedure is called to get an opaque handle (actually a
 *	PhotoMaster *) for a given image, which can be used in
 *	subsequent calls to Tk_PhotoPutBlock, etc.  The `name'
 *	parameter is the name of the image.
 *
 * Results:
 *	The handle for the photo image, or NULL if there is no
 *	photo image with the name given.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tk_PhotoHandle
Tk_FindPhoto(interp, imageName)
    Tcl_Interp *interp;		/* Interpreter (application) in which image
				 * exists. */
    CONST char *imageName;	/* Name of the desired photo image. */
{
    ClientData clientData;
    Tk_ImageType *typePtr;

    clientData = Tk_GetImageMasterData(interp, imageName, &typePtr);
    if (typePtr != &tkPhotoImageType) {
	return NULL;
    }
    return (Tk_PhotoHandle) clientData;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_PhotoPutBlock --
 *
 *	This procedure is called to put image data into a photo image.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The image data is stored.  The image may be expanded.
 *	The Tk image code is informed that the image has changed.
 *
 *---------------------------------------------------------------------- */

void
Tk_PhotoPutBlock(handle, blockPtr, x, y, width, height, compRule)
    Tk_PhotoHandle handle;	/* Opaque handle for the photo image
				 * to be updated. */
    register Tk_PhotoImageBlock *blockPtr;
				/* Pointer to a structure describing the
				 * pixel data to be copied into the image. */
    int x, y;			/* Coordinates of the top-left pixel to
				 * be updated in the image. */
    int width, height;		/* Dimensions of the area of the image
				 * to be updated. */
    int compRule;		/* Compositing rule to use when processing
				 * transparent pixels. */
{
    register PhotoMaster *masterPtr;
    int xEnd, yEnd;
    int greenOffset, blueOffset, alphaOffset;
    int wLeft, hLeft;
    int wCopy, hCopy;
    unsigned char *srcPtr, *srcLinePtr;
    unsigned char *destPtr, *destLinePtr;
    int pitch;
    XRectangle rect;

    masterPtr = (PhotoMaster *) handle;

    if ((masterPtr->userWidth != 0) && ((x + width) > masterPtr->userWidth)) {
	width = masterPtr->userWidth - x;
    }
    if ((masterPtr->userHeight != 0)
	    && ((y + height) > masterPtr->userHeight)) {
	height = masterPtr->userHeight - y;
    }
    if ((width <= 0) || (height <= 0)) {
	return;
    }

    xEnd = x + width;
    yEnd = y + height;
    if ((xEnd > masterPtr->width) || (yEnd > masterPtr->height)) {
	if (ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width),
		MAX(yEnd, masterPtr->height)) == TCL_ERROR) {
	    panic(TK_PHOTO_ALLOC_FAILURE_MESSAGE);
	}
    }

    if ((y < masterPtr->ditherY) || ((y == masterPtr->ditherY)
	    && (x < masterPtr->ditherX))) {
	/*
	 * The dithering isn't correct past the start of this block.
	 */
	masterPtr->ditherX = x;
	masterPtr->ditherY = y;
    }

    /*
     * If this image block could have different red, green and blue
     * components, mark it as a color image.
     */

    greenOffset = blockPtr->offset[1] - blockPtr->offset[0];
    blueOffset = blockPtr->offset[2] - blockPtr->offset[0];
    alphaOffset = blockPtr->offset[3];
    if ((alphaOffset >= blockPtr->pixelSize) || (alphaOffset < 0)) {
	alphaOffset = 0;
    } else {
	alphaOffset -= blockPtr->offset[0];
    }
    if ((greenOffset != 0) || (blueOffset != 0)) {
	masterPtr->flags |= COLOR_IMAGE;
    }

    /*
     * Copy the data into our local 32-bit/pixel array.
     * If we can do it with a single memcpy, we do.
     */

    destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;
    pitch = masterPtr->width * 4;

    /*
     * This test is probably too restrictive.  We should also be able to
     * do a memcpy if pixelSize == 3 and alphaOffset == 0.  Maybe other cases
     * too.
     */
    if ((blockPtr->pixelSize == 4)
	    && (greenOffset == 1) && (blueOffset == 2) && (alphaOffset == 3)
	    && (width <= blockPtr->width) && (height <= blockPtr->height)
	    && ((height == 1) || ((x == 0) && (width == masterPtr->width)
		&& (blockPtr->pitch == pitch)))
	    && (compRule == TK_PHOTO_COMPOSITE_SET)) {
	memcpy((VOID *) destLinePtr,
		(VOID *) (blockPtr->pixelPtr + blockPtr->offset[0]),
		(size_t) (height * width * 4));
    } else {
	int alpha;
	for (hLeft = height; hLeft > 0;) {
	    srcLinePtr = blockPtr->pixelPtr + blockPtr->offset[0];
	    hCopy = MIN(hLeft, blockPtr->height);
	    hLeft -= hCopy;
	    for (; hCopy > 0; --hCopy) {
		if ((blockPtr->pixelSize == 4) && (greenOffset == 1)
		    && (blueOffset == 2) && (alphaOffset == 3)
		    && (width <= blockPtr->width)
		    && (compRule == TK_PHOTO_COMPOSITE_SET)) {
		    memcpy((VOID *) destLinePtr, (VOID *) srcLinePtr,
			   (size_t) (width * 4));
		} else {
		    destPtr = destLinePtr;
		    for (wLeft = width; wLeft > 0;) {
			wCopy = MIN(wLeft, blockPtr->width);
			wLeft -= wCopy;
			srcPtr = srcLinePtr;
			for (; wCopy > 0; --wCopy) {
			    alpha = srcPtr[alphaOffset];
			    /*
			     * In the easy case, we can just copy.
			     */
			    if (!alphaOffset || (alpha == 255)) {
				/* new solid part of the image */
				*destPtr++ = srcPtr[0];
				*destPtr++ = srcPtr[greenOffset];
				*destPtr++ = srcPtr[blueOffset];
				*destPtr++ = 255;
				srcPtr += blockPtr->pixelSize;
				continue;
			    }

			    /*
			     * Combine according to the compositing rule.
			     */
			    switch (compRule) {
			    case TK_PHOTO_COMPOSITE_SET:
				*destPtr++ = srcPtr[0];
				*destPtr++ = srcPtr[greenOffset];
				*destPtr++ = srcPtr[blueOffset];
				*destPtr++ = alpha;
				break;

			    case TK_PHOTO_COMPOSITE_OVERLAY:
				if (!destPtr[3]) {
				    /*
				     * There must be a better way to select a
				     * background colour!
				     */
				    destPtr[0] = destPtr[1] = destPtr[2] = 0xd9;
				}

				if (alpha) {
				    destPtr[0] += (srcPtr[0] - destPtr[0]) * alpha / 255;
				    destPtr[1] += (srcPtr[greenOffset] - destPtr[1]) * alpha / 255;
				    destPtr[2] += (srcPtr[blueOffset] - destPtr[2]) * alpha / 255;
				    destPtr[3] += (255 - destPtr[3]) * alpha / 255;
				}
				/*
				 * else should be empty space
				 */
				destPtr += 4;
				break;

			    default:
				panic("unknown compositing rule: %d", compRule);
			    }
			    srcPtr += blockPtr->pixelSize;
			}
		    }
		}
		srcLinePtr += blockPtr->pitch;
		destLinePtr += pitch;
	    }
	}
    }

    /*
     * Add this new block to the region which specifies which data is valid.
     */

    if (alphaOffset) {
	int x1, y1, end;

	/*
	 * This block is grossly inefficient.  For each row in the image, it
	 * finds each continguous string of nontransparent pixels, then marks
	 * those areas as valid in the validRegion mask.  This makes drawing
	 * very efficient, because of the way we use X: we just say, here's
	 * your mask, and here's your data.  We need not worry about the
	 * current background color, etc.  But this costs us a lot on the
	 * image setup.  Still, image setup only happens once, whereas the
	 * drawing happens many times, so this might be the best way to go.
	 *
	 * An alternative might be to not set up this mask, and instead, at
	 * drawing time, for each transparent pixel, set its color to the
	 * color of the background behind that pixel.  This is what I suspect
	 * most of programs do.  However, they don't have to deal with the
	 * canvas, which could have many different background colors.
	 * Determining the correct bg color for a given pixel might be
	 * expensive.
	 */

	if (compRule != TK_PHOTO_COMPOSITE_OVERLAY) {
	    /*
	     * Don't need this when using the OVERLAY compositing rule,
	     * which always strictly increases the valid region.
	     */
	    TkRegion workRgn = TkCreateRegion();

	    rect.x = x;
	    rect.y = y;
	    rect.width = width;
	    rect.height = height;
	    TkUnionRectWithRegion(&rect, workRgn, workRgn);
	    TkSubtractRegion(masterPtr->validRegion, workRgn,
		    masterPtr->validRegion);
	    TkDestroyRegion(workRgn);
	}

	destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4 + 3;
	for (y1 = 0; y1 < height; y1++) {
	    x1 = 0;
	    destPtr = destLinePtr;
	    while (x1 < width) {
		/* search for first non-transparent pixel */
		while ((x1 < width) && !*destPtr) {
		    x1++;
		    destPtr += 4;
		}
		end = x1;
		/* search for first transparent pixel */
		while ((end < width) && *destPtr) {
		    end++;
		    destPtr += 4;
		}
		if (end > x1) {
		    rect.x = x + x1;
		    rect.y = y + y1;
		    rect.width = end - x1;
		    rect.height = 1;
		    TkUnionRectWithRegion(&rect, masterPtr->validRegion,
			    masterPtr->validRegion);
		}
		x1 = end;
	    }
	    destLinePtr += masterPtr->width * 4;
	}
    } else {
	rect.x = x;
	rect.y = y;
	rect.width = width;
	rect.height = height;
	TkUnionRectWithRegion(&rect, masterPtr->validRegion,
		masterPtr->validRegion);
    }

    /*
     * Update each instance.
     */

    Tk_DitherPhoto((Tk_PhotoHandle)masterPtr, x, y, width, height);

    /*
     * Tell the core image code that this image has changed.
     */

    Tk_ImageChanged(masterPtr->tkMaster, x, y, width, height, masterPtr->width,
	    masterPtr->height);
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_PhotoPutZoomedBlock --
 *
 *	This procedure is called to put image data into a photo image,
 *	with possible subsampling and/or zooming of the pixels.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The image data is stored.  The image may be expanded.
 *	The Tk image code is informed that the image has changed.
 *
 *----------------------------------------------------------------------
 */

void
Tk_PhotoPutZoomedBlock(handle, blockPtr, x, y, width, height, zoomX, zoomY,
	subsampleX, subsampleY, compRule)
    Tk_PhotoHandle handle;	/* Opaque handle for the photo image
				 * to be updated. */
    register Tk_PhotoImageBlock *blockPtr;
				/* Pointer to a structure describing the
				 * pixel data to be copied into the image. */
    int x, y;			/* Coordinates of the top-left pixel to
				 * be updated in the image. */
    int width, height;		/* Dimensions of the area of the image
				 * to be updated. */
    int zoomX, zoomY;		/* Zoom factors for the X and Y axes. */
    int subsampleX, subsampleY;	/* Subsampling factors for the X and Y axes. */
    int compRule;		/* Compositing rule to use when processing
				 * transparent pixels. */
{
    register PhotoMaster *masterPtr;
    int xEnd, yEnd;
    int greenOffset, blueOffset, alphaOffset;
    int wLeft, hLeft;
    int wCopy, hCopy;
    int blockWid, blockHt;
    unsigned char *srcPtr, *srcLinePtr, *srcOrigPtr;
    unsigned char *destPtr, *destLinePtr;
    int pitch;
    int xRepeat, yRepeat;
    int blockXSkip, blockYSkip;
    XRectangle rect;

    if (zoomX==1 && zoomY==1 && subsampleX==1 && subsampleY==1) {
	Tk_PhotoPutBlock(handle, blockPtr, x, y, width, height, compRule);
	return;
    }

    masterPtr = (PhotoMaster *) handle;

    if (zoomX <= 0 || zoomY <= 0) {
	return;
    }
    if ((masterPtr->userWidth != 0) && ((x + width) > masterPtr->userWidth)) {
	width = masterPtr->userWidth - x;
    }
    if ((masterPtr->userHeight != 0)
	    && ((y + height) > masterPtr->userHeight)) {
	height = masterPtr->userHeight - y;
    }
    if (width <= 0 || height <= 0) {
	return;
    }

    xEnd = x + width;
    yEnd = y + height;
    if ((xEnd > masterPtr->width) || (yEnd > masterPtr->height)) {
	int sameSrc = (blockPtr->pixelPtr == masterPtr->pix32);
	if (ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width),
		MAX(yEnd, masterPtr->height)) == TCL_ERROR) {
	    panic(TK_PHOTO_ALLOC_FAILURE_MESSAGE);
	}
	if (sameSrc) {
	    blockPtr->pixelPtr = masterPtr->pix32;
	}
    }

    if ((y < masterPtr->ditherY) || ((y == masterPtr->ditherY)
	   && (x < masterPtr->ditherX))) {
	/*
	 * The dithering isn't correct past the start of this block.
	 */

	masterPtr->ditherX = x;
	masterPtr->ditherY = y;
    }

    /*
     * If this image block could have different red, green and blue
     * components, mark it as a color image.
     */

    greenOffset = blockPtr->offset[1] - blockPtr->offset[0];
    blueOffset = blockPtr->offset[2] - blockPtr->offset[0];
    alphaOffset = blockPtr->offset[3];
    if ((alphaOffset >= blockPtr->pixelSize) || (alphaOffset < 0)) {
	alphaOffset = 0;
    } else {
	alphaOffset -= blockPtr->offset[0];
    }
    if ((greenOffset != 0) || (blueOffset != 0)) {
	masterPtr->flags |= COLOR_IMAGE;
    }

    /*
     * Work out what area the pixel data in the block expands to after
     * subsampling and zooming.
     */

    blockXSkip = subsampleX * blockPtr->pixelSize;
    blockYSkip = subsampleY * blockPtr->pitch;
    if (subsampleX > 0) {
	blockWid = ((blockPtr->width + subsampleX - 1) / subsampleX) * zoomX;
    } else if (subsampleX == 0) {
	blockWid = width;
    } else {
	blockWid = ((blockPtr->width - subsampleX - 1) / -subsampleX) * zoomX;
    }
    if (subsampleY > 0) {
	blockHt = ((blockPtr->height + subsampleY - 1) / subsampleY) * zoomY;
    } else if (subsampleY == 0) {
	blockHt = height;
    } else {
	blockHt = ((blockPtr->height - subsampleY - 1) / -subsampleY) * zoomY;
    }

    /*
     * Copy the data into our local 32-bit/pixel array.
     */

    destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;
    srcOrigPtr = blockPtr->pixelPtr + blockPtr->offset[0];
    if (subsampleX < 0) {
	srcOrigPtr += (blockPtr->width - 1) * blockPtr->pixelSize;
    }
    if (subsampleY < 0) {
	srcOrigPtr += (blockPtr->height - 1) * blockPtr->pitch;
    }

    pitch = masterPtr->width * 4;
    for (hLeft = height; hLeft > 0; ) {
	hCopy = MIN(hLeft, blockHt);
	hLeft -= hCopy;
	yRepeat = zoomY;
	srcLinePtr = srcOrigPtr;
	for (; hCopy > 0; --hCopy) {
	    destPtr = destLinePtr;
	    for (wLeft = width; wLeft > 0;) {
		wCopy = MIN(wLeft, blockWid);
		wLeft -= wCopy;
		srcPtr = srcLinePtr;
		for (; wCopy > 0; wCopy -= zoomX) {
		    for (xRepeat = MIN(wCopy, zoomX); xRepeat > 0; xRepeat--) {
			/*
			 * Common case (solid pixels) first
			 */
			if (!alphaOffset || (srcPtr[alphaOffset] == 255)) {
			    *destPtr++ = srcPtr[0];
			    *destPtr++ = srcPtr[greenOffset];
			    *destPtr++ = srcPtr[blueOffset];
			    *destPtr++ = 255;
			    continue;
 			}

			switch (compRule) {
			case TK_PHOTO_COMPOSITE_SET:
			    *destPtr++ = srcPtr[0];
			    *destPtr++ = srcPtr[greenOffset];
			    *destPtr++ = srcPtr[blueOffset];
			    *destPtr++ = srcPtr[alphaOffset];
			    break;
			case TK_PHOTO_COMPOSITE_OVERLAY:
			    if (!destPtr[3]) {
				/*
				 * There must be a better way to select a
				 * background colour!
				 */
				destPtr[0] = destPtr[1] = destPtr[2] = 0xd9;
			    }
			    if (srcPtr[alphaOffset]) {
				destPtr[0] += (srcPtr[0] - destPtr[0]) * srcPtr[alphaOffset] / 255;
				destPtr[1] += (srcPtr[greenOffset] - destPtr[1]) * srcPtr[alphaOffset] / 255;
				destPtr[2] += (srcPtr[blueOffset] - destPtr[2]) * srcPtr[alphaOffset] / 255;
				destPtr[3] += (255 - destPtr[3]) * srcPtr[alphaOffset] / 255;
			    }
			    destPtr += 4;
			    break;
			default:
			    panic("unknown compositing rule: %d", compRule);
			}
		    }
		    srcPtr += blockXSkip;
		}
	    }
	    destLinePtr += pitch;
	    yRepeat--;
	    if (yRepeat <= 0) {
		srcLinePtr += blockYSkip;
		yRepeat = zoomY;
	    }
	}
    }

    /*
     * Recompute the region of data for which we have valid pixels to plot.
     */

    if (alphaOffset) {
	int x1, y1, end;

	if (compRule != TK_PHOTO_COMPOSITE_OVERLAY) {
	    /*
	     * Don't need this when using the OVERLAY compositing rule, which
	     * always strictly increases the valid region.
	     */
	    TkRegion workRgn = TkCreateRegion();

	    rect.x = x;
	    rect.y = y;
	    rect.width = width;
	    rect.height = 1;
	    TkUnionRectWithRegion(&rect, workRgn, workRgn);
	    TkSubtractRegion(masterPtr->validRegion, workRgn,
		    masterPtr->validRegion);
	    TkDestroyRegion(workRgn);
	}

	destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4 + 3;
	for (y1 = 0; y1 < height; y1++) {
	    x1 = 0;
	    destPtr = destLinePtr;
	    while (x1 < width) {
		/* search for first non-transparent pixel */
		while ((x1 < width) && !*destPtr) {
		    x1++;
		    destPtr += 4;
		}
		end = x1;
		/* search for first transparent pixel */
		while ((end < width) && *destPtr) {
		    end++;
		    destPtr += 4;
		}
		if (end > x1) {
		    rect.x = x + x1;
		    rect.y = y + y1;
		    rect.width = end - x1;
		    rect.height = 1;
		    TkUnionRectWithRegion(&rect, masterPtr->validRegion,
			    masterPtr->validRegion);
		}
		x1 = end;
	    }
	    destLinePtr += masterPtr->width * 4;
	}
    } else {
	rect.x = x;
	rect.y = y;
	rect.width = width;
	rect.height = height;
	TkUnionRectWithRegion(&rect, masterPtr->validRegion,
		masterPtr->validRegion);
    }

    /*
     * Update each instance.
     */

    Tk_DitherPhoto((Tk_PhotoHandle)masterPtr, x, y, width, height);

    /*
     * Tell the core image code that this image has changed.
     */

    Tk_ImageChanged(masterPtr->tkMaster, x, y, width, height, masterPtr->width,
	    masterPtr->height);
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_DitherPhoto --
 *
 *	This procedure is called to update an area of each instance's
 *	pixmap by dithering the corresponding area of the image master.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The pixmap of each instance of this image gets updated.
 *	The fields in *masterPtr indicating which area of the image
 *	is correctly dithered get updated.
 *
 *----------------------------------------------------------------------
 */

void
Tk_DitherPhoto(photo, x, y, width, height)
    Tk_PhotoHandle photo;	/* Image master whose instances are
				 * to be updated. */
    int x, y;			/* Coordinates of the top-left pixel
				 * in the area to be dithered. */
    int width, height;		/* Dimensions of the area to be dithered. */
{
    PhotoMaster *masterPtr = (PhotoMaster *) photo;
    PhotoInstance *instancePtr;

    if ((width <= 0) || (height <= 0)) {
	return;
    }

    for (instancePtr = masterPtr->instancePtr; instancePtr != NULL;
	    instancePtr = instancePtr->nextPtr) {
	DitherInstance(instancePtr, x, y, width, height);
    }

    /*
     * Work out whether this block will be correctly dithered
     * and whether it will extend the correctly dithered region.
     */

    if (((y < masterPtr->ditherY)
	    || ((y == masterPtr->ditherY) && (x <= masterPtr->ditherX)))
	    && ((y + height) > (masterPtr->ditherY))) {

	/*
	 * This block starts inside (or immediately after) the correctly
	 * dithered region, so the first scan line at least will be right.
	 * Furthermore this block extends into scanline masterPtr->ditherY.
	 */

	if ((x == 0) && (width == masterPtr->width)) {
	    /*
	     * We are doing the full width, therefore the dithering
	     * will be correct to the end.
	     */

	    masterPtr->ditherX = 0;
	    masterPtr->ditherY = y + height;
	} else {
	    /*
	     * We are doing partial scanlines, therefore the
	     * correctly-dithered region will be extended by
	     * at most one scan line.
	     */

	    if (x <= masterPtr->ditherX) {
		masterPtr->ditherX = x + width;
		if (masterPtr->ditherX >= masterPtr->width) {
		    masterPtr->ditherX = 0;
		    masterPtr->ditherY++;
		}
	    }
	}
    }

}    

/*
 *----------------------------------------------------------------------
 *
 * DitherInstance --
 *
 *	This procedure is called to update an area of an instance's
 *	pixmap by dithering the corresponding area of the master.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The instance's pixmap gets updated.
 *
 *----------------------------------------------------------------------
 */

static void
DitherInstance(instancePtr, xStart, yStart, width, height)
    PhotoInstance *instancePtr;	/* The instance to be updated. */
    int xStart, yStart;		/* Coordinates of the top-left pixel in the
				 * block to be dithered. */
    int width, height;		/* Dimensions of the block to be dithered. */
{
    PhotoMaster *masterPtr;
    ColorTable *colorPtr;
    XImage *imagePtr;
    int nLines, bigEndian;
    int i, c, x, y;
    int xEnd, yEnd;
    int bitsPerPixel, bytesPerLine, lineLength;
    unsigned char *srcLinePtr, *srcPtr;
    schar *errLinePtr, *errPtr;
    unsigned char *destBytePtr, *dstLinePtr;
    pixel *destLongPtr;
    pixel firstBit, word, mask;
    int col[3];
    int doDithering = 1;

    colorPtr = instancePtr->colorTablePtr;
    masterPtr = instancePtr->masterPtr;

    /*
     * Turn dithering off in certain cases where it is not
     * needed (TrueColor, DirectColor with many colors).
     */

    if ((colorPtr->visualInfo.class == DirectColor)
	    || (colorPtr->visualInfo.class == TrueColor)) {
	int nRed, nGreen, nBlue, result;

	result = sscanf(colorPtr->id.palette, "%d/%d/%d", &nRed,
		&nGreen, &nBlue);
	if ((nRed >= 256)
		&& ((result == 1) || ((nGreen >= 256) && (nBlue >= 256)))) {
	    doDithering = 0;
	}
    }

    /*
     * First work out how many lines to do at a time,
     * then how many bytes we'll need for pixel storage,
     * and allocate it.
     */

    nLines = (MAX_PIXELS + width - 1) / width;
    if (nLines < 1) {
	nLines = 1;
    }
    if (nLines > height ) {
	nLines = height;
    }

    imagePtr = instancePtr->imagePtr;
    if (imagePtr == NULL) {
	return;			/* we must be really tight on memory */
    }
    bitsPerPixel = imagePtr->bits_per_pixel;
    bytesPerLine = ((bitsPerPixel * width + 31) >> 3) & ~3;
    imagePtr->width = width;
    imagePtr->height = nLines;
    imagePtr->bytes_per_line = bytesPerLine;
    imagePtr->data = (char *) ckalloc((unsigned) (imagePtr->bytes_per_line * nLines));
    bigEndian = imagePtr->bitmap_bit_order == MSBFirst;
    firstBit = bigEndian? (1 << (imagePtr->bitmap_unit - 1)): 1;

    lineLength = masterPtr->width * 3;
    srcLinePtr = masterPtr->pix32 + (yStart * masterPtr->width + xStart) * 4;
    errLinePtr = instancePtr->error + yStart * lineLength + xStart * 3;
    xEnd = xStart + width;

    /*
     * Loop over the image, doing at most nLines lines before
     * updating the screen image.
     */

    for (; height > 0; height -= nLines) {
	if (nLines > height) {
	    nLines = height;
	}
	dstLinePtr = (unsigned char *) imagePtr->data;
	yEnd = yStart + nLines;
	for (y = yStart; y < yEnd; ++y) {
	    srcPtr = srcLinePtr;
	    errPtr = errLinePtr;
	    destBytePtr = dstLinePtr;
	    destLongPtr = (pixel *) dstLinePtr;
	    if (colorPtr->flags & COLOR_WINDOW) {
		/*
		 * Color window.  We dither the three components
		 * independently, using Floyd-Steinberg dithering,
		 * which propagates errors from the quantization of
		 * pixels to the pixels below and to the right.
		 */

		for (x = xStart; x < xEnd; ++x) {
		    if (doDithering) {
			for (i = 0; i < 3; ++i) {
			    /*
			     * Compute the error propagated into this pixel
			     * for this component.
			     * If e[x,y] is the array of quantization error
			     * values, we compute
			     *     7/16 * e[x-1,y] + 1/16 * e[x-1,y-1]
			     *   + 5/16 * e[x,y-1] + 3/16 * e[x+1,y-1]
			     * and round it to an integer.
			     *
			     * The expression ((c + 2056) >> 4) - 128
			     * computes round(c / 16), and works correctly on
			     * machines without a sign-extending right shift.
			     */
			    
			    c = (x > 0) ? errPtr[-3] * 7: 0;
			    if (y > 0) {
				if (x > 0) {
				    c += errPtr[-lineLength-3];
				}
				c += errPtr[-lineLength] * 5;
				if ((x + 1) < masterPtr->width) {
				    c += errPtr[-lineLength+3] * 3;
				}
			    }
			    
			    /*
			     * Add the propagated error to the value of this
			     * component, quantize it, and store the
			     * quantization error.
			     */
			    
			    c = ((c + 2056) >> 4) - 128 + *srcPtr++;
			    if (c < 0) {
				c = 0;
			    } else if (c > 255) {
				c = 255;
			    }
			    col[i] = colorPtr->colorQuant[i][c];
			    *errPtr++ = c - col[i];
			}
		    } else {
			/* 
			 * Output is virtually continuous in this case,
			 * so don't bother dithering.
			 */

			col[0] = *srcPtr++;
			col[1] = *srcPtr++;
			col[2] = *srcPtr++;
		    }
		    srcPtr++;

		    /*
		     * Translate the quantized component values into
		     * an X pixel value, and store it in the image.
		     */

		    i = colorPtr->redValues[col[0]]
			    + colorPtr->greenValues[col[1]]
			    + colorPtr->blueValues[col[2]];
		    if (colorPtr->flags & MAP_COLORS) {
			i = colorPtr->pixelMap[i];
		    }
		    switch (bitsPerPixel) {
			case NBBY:
			    *destBytePtr++ = i;
			    break;
#ifndef __WIN32__
/*
 * This case is not valid for Windows because the image format is different
 * from the pixel format in Win32.  Eventually we need to fix the image
 * code in Tk to use the Windows native image ordering.  This would speed
 * up the image code for all of the common sizes.
 */

			case NBBY * sizeof(pixel):
			    *destLongPtr++ = i;
			    break;
#endif
			default:
			    XPutPixel(imagePtr, x - xStart, y - yStart,
				    (unsigned) i);
		    }
		}

	    } else if (bitsPerPixel > 1) {
		/*
		 * Multibit monochrome window.  The operation here is similar
		 * to the color window case above, except that there is only
		 * one component.  If the master image is in color, use the
		 * luminance computed as
		 *	0.344 * red + 0.5 * green + 0.156 * blue.
		 */

		for (x = xStart; x < xEnd; ++x) {
		    c = (x > 0) ? errPtr[-1] * 7: 0;
		    if (y > 0) {
			if (x > 0)  {
			    c += errPtr[-lineLength-1];
			}
			c += errPtr[-lineLength] * 5;
			if (x + 1 < masterPtr->width) {
			    c += errPtr[-lineLength+1] * 3;
			}
		    }
		    c = ((c + 2056) >> 4) - 128;

		    if ((masterPtr->flags & COLOR_IMAGE) == 0) {
			c += srcPtr[0];
		    } else {
			c += (unsigned)(srcPtr[0] * 11 + srcPtr[1] * 16
					+ srcPtr[2] * 5 + 16) >> 5;
		    }
		    srcPtr += 4;

		    if (c < 0) {
			c = 0;
		    } else if (c > 255) {
			c = 255;
		    }
		    i = colorPtr->colorQuant[0][c];
		    *errPtr++ = c - i;
		    i = colorPtr->redValues[i];
		    switch (bitsPerPixel) {
			case NBBY:
			    *destBytePtr++ = i;
			    break;
#ifndef __WIN32__
/*
 * This case is not valid for Windows because the image format is different
 * from the pixel format in Win32.  Eventually we need to fix the image
 * code in Tk to use the Windows native image ordering.  This would speed
 * up the image code for all of the common sizes.
 */

			case NBBY * sizeof(pixel):
			    *destLongPtr++ = i;
			    break;
#endif
			default:
			    XPutPixel(imagePtr, x - xStart, y - yStart,
				    (unsigned) i);
		    }
		}
	    } else {
		/*
		 * 1-bit monochrome window.  This is similar to the
		 * multibit monochrome case above, except that the
		 * quantization is simpler (we only have black = 0
		 * and white = 255), and we produce an XY-Bitmap.
		 */

		word = 0;
		mask = firstBit;
		for (x = xStart; x < xEnd; ++x) {
		    /*
		     * If we have accumulated a whole word, store it
		     * in the image and start a new word.
		     */

		    if (mask == 0) {
			*destLongPtr++ = word;
			mask = firstBit;
			word = 0;
		    }

		    c = (x > 0) ? errPtr[-1] * 7: 0;
		    if (y > 0) {
			if (x > 0) {
			    c += errPtr[-lineLength-1];
			}
			c += errPtr[-lineLength] * 5;
			if (x + 1 < masterPtr->width) {
			    c += errPtr[-lineLength+1] * 3;
			}
		    }
		    c = ((c + 2056) >> 4) - 128;

		    if ((masterPtr->flags & COLOR_IMAGE) == 0) {
			c += srcPtr[0];
		    } else {
			c += (unsigned)(srcPtr[0] * 11 + srcPtr[1] * 16
					+ srcPtr[2] * 5 + 16) >> 5;
		    }
		    srcPtr += 4;

		    if (c < 0) {
			c = 0;
		    } else if (c > 255) {
			c = 255;
		    }
		    if (c >= 128) {
			word |= mask;
			*errPtr++ = c - 255;
		    } else {
			*errPtr++ = c;
		    }
		    mask = bigEndian? (mask >> 1): (mask << 1);
		}
		*destLongPtr = word;
	    }
	    srcLinePtr += masterPtr->width * 4;
	    errLinePtr += lineLength;
	    dstLinePtr += bytesPerLine;
	}

	/*
	 * Update the pixmap for this instance with the block of
	 * pixels that we have just computed.
	 */

	TkPutImage(colorPtr->pixelMap, colorPtr->numColors,
		instancePtr->display, instancePtr->pixels,
		instancePtr->gc, imagePtr, 0, 0, xStart, yStart,
		(unsigned) width, (unsigned) nLines);
	yStart = yEnd;
	
    }

    ckfree(imagePtr->data);
    imagePtr->data = NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_PhotoBlank --
 *
 *	This procedure is called to clear an entire photo image.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The valid region for the image is set to the null region.
 *	The generic image code is notified that the image has changed.
 *
 *----------------------------------------------------------------------
 */

void
Tk_PhotoBlank(handle)
    Tk_PhotoHandle handle;	/* Handle for the image to be blanked. */
{
    PhotoMaster *masterPtr;
    PhotoInstance *instancePtr;

    masterPtr = (PhotoMaster *) handle;
    masterPtr->ditherX = masterPtr->ditherY = 0;
    masterPtr->flags = 0;

    /*
     * The image has valid data nowhere.
     */

    if (masterPtr->validRegion != NULL) {
	TkDestroyRegion(masterPtr->validRegion);
    }
    masterPtr->validRegion = TkCreateRegion();

    /*
     * Clear out the 32-bit pixel storage array.
     * Clear out the dithering error arrays for each instance.
     */

    memset((VOID *) masterPtr->pix32, 0,
	    (size_t) (masterPtr->width * masterPtr->height * 4));
    for (instancePtr = masterPtr->instancePtr; instancePtr != NULL;
	    instancePtr = instancePtr->nextPtr) {
	if (instancePtr->error) {
	    memset((VOID *) instancePtr->error, 0,
		    (size_t) (masterPtr->width * masterPtr->height
		    * 3 * sizeof(schar)));
	}
    }

    /*
     * Tell the core image code that this image has changed.
     */

    Tk_ImageChanged(masterPtr->tkMaster, 0, 0, masterPtr->width,
	    masterPtr->height, masterPtr->width, masterPtr->height);
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_PhotoExpand --
 *
 *	This procedure is called to request that a photo image be
 *	expanded if necessary to be at least `width' pixels wide and
 *	`height' pixels high.  If the user has declared a definite
 *	image size (using the -width and -height configuration
 *	options) then this call has no effect.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The size of the photo image may change; if so the generic
 *	image code is informed.
 *
 *----------------------------------------------------------------------
 */

void
Tk_PhotoExpand(handle, width, height)
    Tk_PhotoHandle handle;	/* Handle for the image to be expanded. */
    int width, height;		/* Desired minimum dimensions of the image. */
{
    PhotoMaster *masterPtr;

    masterPtr = (PhotoMaster *) handle;

    if (width <= masterPtr->width) {
	width = masterPtr->width;
    }
    if (height <= masterPtr->height) {
	height = masterPtr->height;
    }
    if ((width != masterPtr->width) || (height != masterPtr->height)) {
	if (ImgPhotoSetSize(masterPtr, MAX(width, masterPtr->width),
		MAX(height, masterPtr->height)) == TCL_ERROR) {
	    panic(TK_PHOTO_ALLOC_FAILURE_MESSAGE);
	}
	Tk_ImageChanged(masterPtr->tkMaster, 0, 0, 0, 0, masterPtr->width,
		masterPtr->height);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_PhotoGetSize --
 *
 *	This procedure is called to obtain the current size of a photo
 *	image.
 *
 * Results:
 *	The image's width and height are returned in *widthp
 *	and *heightp.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
Tk_PhotoGetSize(handle, widthPtr, heightPtr)
    Tk_PhotoHandle handle;	/* Handle for the image whose dimensions
				 * are requested. */
    int *widthPtr, *heightPtr;	/* The dimensions of the image are returned
				 * here. */
{
    PhotoMaster *masterPtr;

    masterPtr = (PhotoMaster *) handle;
    *widthPtr = masterPtr->width;
    *heightPtr = masterPtr->height;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_PhotoSetSize --
 *
 *	This procedure is called to set size of a photo image.
 *	This call is equivalent to using the -width and -height
 *	configuration options.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The size of the image may change; if so the generic
 *	image code is informed.
 *
 *----------------------------------------------------------------------
 */

void
Tk_PhotoSetSize(handle, width, height)
    Tk_PhotoHandle handle;	/* Handle for the image whose size is to
				 * be set. */
    int width, height;		/* New dimensions for the image. */
{
    PhotoMaster *masterPtr;

    masterPtr = (PhotoMaster *) handle;

    masterPtr->userWidth = width;
    masterPtr->userHeight = height;
    if (ImgPhotoSetSize(masterPtr, ((width > 0) ? width: masterPtr->width),
	    ((height > 0) ? height: masterPtr->height)) == TCL_ERROR) {
	panic(TK_PHOTO_ALLOC_FAILURE_MESSAGE);
    }
    Tk_ImageChanged(masterPtr->tkMaster, 0, 0, 0, 0,
	    masterPtr->width, masterPtr->height);
}

/*
 *----------------------------------------------------------------------
 *
 * TkGetPhotoValidRegion --
 *
 *	This procedure is called to get the part of the photo where
 *	there is valid data.  Or, conversely, the part of the photo
 *	which is transparent.
 *
 * Results:
 *	A TkRegion value that indicates the current area of the photo
 *	that is valid.  This value should not be used after any
 *	modification to the photo image.
 *
 * Side Effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

TkRegion
TkPhotoGetValidRegion(handle)
    Tk_PhotoHandle handle; /* Handle for the image whose valid region
			    * is to obtained. */
{
    PhotoMaster *masterPtr;

    masterPtr = (PhotoMaster *) handle;
    return masterPtr->validRegion;
}

/*
 *----------------------------------------------------------------------
 *
 * ImgGetPhoto --
 *
 *	This procedure is called to obtain image data from a photo
 *	image.  This procedure fills in the Tk_PhotoImageBlock structure
 *	pointed to by `blockPtr' with details of the address and
 *	layout of the image data in memory.
 *
 * Results:
 *	A pointer to the allocated data which should be freed later.
 *	NULL if there is no need to free data because
 *	blockPtr->pixelPtr points directly to the image data.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static char *
ImgGetPhoto(masterPtr, blockPtr, optPtr)
    PhotoMaster *masterPtr;	/* Handle for the photo image from which
				 * image data is desired. */
    Tk_PhotoImageBlock *blockPtr;
				/* Information about the address and layout
				 * of the image data is returned here. */
    struct SubcommandOptions *optPtr;
{
    unsigned char *pixelPtr;
    int x, y, greenOffset, blueOffset, alphaOffset;

    Tk_PhotoGetImage((Tk_PhotoHandle) masterPtr, blockPtr);
    blockPtr->pixelPtr += optPtr->fromY * blockPtr->pitch
	    + optPtr->fromX * blockPtr->pixelSize;
    blockPtr->width = optPtr->fromX2 - optPtr->fromX;
    blockPtr->height = optPtr->fromY2 - optPtr->fromY;

    if (!(masterPtr->flags & COLOR_IMAGE) &&
	    (!(optPtr->options & OPT_BACKGROUND)
	    || ((optPtr->background->red == optPtr->background->green)
	    && (optPtr->background->red == optPtr->background->blue)))) {
	blockPtr->offset[0] = blockPtr->offset[1] =
		blockPtr->offset[2];
    }
    alphaOffset = 0;
    for (y = 0; y < blockPtr->height; y++) {
	pixelPtr = blockPtr->pixelPtr + (y * blockPtr->pitch)
		+ blockPtr->pixelSize - 1;
	for (x = 0; x < blockPtr->width; x++) {
	    if (*pixelPtr != 255) {
		alphaOffset = 3;
		break;
	    }
	    pixelPtr += blockPtr->pixelSize;
	}
	if (alphaOffset) {
	    break;
	}
    }
    if (!alphaOffset) {
	blockPtr->pixelPtr--;
	blockPtr->offset[0]++;
	blockPtr->offset[1]++;
	blockPtr->offset[2]++;
    }
    greenOffset = blockPtr->offset[1] - blockPtr->offset[0];
    blueOffset = blockPtr->offset[2] - blockPtr->offset[0];
    if (((optPtr->options & OPT_BACKGROUND) && alphaOffset) ||
	    ((optPtr->options & OPT_GRAYSCALE) && (greenOffset || blueOffset))) {
	int newPixelSize,x,y;
	unsigned char *srcPtr, *destPtr;
	char *data;

	newPixelSize =  (!(optPtr->options & OPT_BACKGROUND) && alphaOffset) ? 2 : 1;
	if ((greenOffset || blueOffset) && !(optPtr->options & OPT_GRAYSCALE)) {
	    newPixelSize += 2;
	}
	data = ckalloc((unsigned int) (newPixelSize *
		blockPtr->width * blockPtr->height));
	srcPtr = blockPtr->pixelPtr + blockPtr->offset[0];
	destPtr = (unsigned char *) data;
	if (!greenOffset && !blueOffset) {
	    for (y = blockPtr->height; y > 0; y--) {
		for (x = blockPtr->width; x > 0; x--) {
		    *destPtr = *srcPtr;
		    srcPtr += blockPtr->pixelSize;
		    destPtr += newPixelSize;
		}
		srcPtr += blockPtr->pitch - (blockPtr->width * blockPtr->pixelSize);
	    }
	} else if (optPtr->options & OPT_GRAYSCALE) {
	    for (y = blockPtr->height; y > 0; y--) {
		for (x = blockPtr->width; x > 0; x--) {
		    *destPtr = (unsigned char) ((srcPtr[0] * 11 + srcPtr[1] * 16
			    + srcPtr[2] * 5 + 16) >> 5);
		    srcPtr += blockPtr->pixelSize;
		    destPtr += newPixelSize;
		}
		srcPtr += blockPtr->pitch - (blockPtr->width * blockPtr->pixelSize);
	    }
	} else {
	    for (y = blockPtr->height; y > 0; y--) {
		for (x = blockPtr->width; x > 0; x--) {
		    destPtr[0] = srcPtr[0];
		    destPtr[1] = srcPtr[1];
		    destPtr[2] = srcPtr[2];
		    srcPtr += blockPtr->pixelSize;
		    destPtr += newPixelSize;
		}
		srcPtr += blockPtr->pitch - (blockPtr->width * blockPtr->pixelSize);
	    }
	}
	srcPtr = blockPtr->pixelPtr + alphaOffset;
	destPtr = (unsigned char *) data;
	if (!alphaOffset) {
	    /* nothing to be done */
	} else if (optPtr->options & OPT_BACKGROUND) {
	    if (newPixelSize > 2) {
	        int red = optPtr->background->red>>8;
	        int green = optPtr->background->green>>8;
	        int blue = optPtr->background->blue>>8;
		for (y = blockPtr->height; y > 0; y--) {
		    for (x = blockPtr->width; x > 0; x--) {
			destPtr[0] += (unsigned char) (((255 - *srcPtr) *
				(red-destPtr[0])) / 255);
			destPtr[1] += (unsigned char) (((255 - *srcPtr) *
				(green-destPtr[1])) / 255);
			destPtr[2] += (unsigned char) (((255 - *srcPtr) *
				(blue-destPtr[2])) / 255);
			srcPtr += blockPtr->pixelSize;
			destPtr += newPixelSize;
		    }
		    srcPtr += blockPtr->pitch - (blockPtr->width * blockPtr->pixelSize);
		}
	    } else {
	 	int gray = (unsigned char) (((optPtr->background->red>>8) * 11
			    + (optPtr->background->green>>8) * 16
			    + (optPtr->background->blue>>8) * 5 + 16) >> 5);
		for (y = blockPtr->height; y > 0; y--) {
		    for (x = blockPtr->width; x > 0; x--) {
			destPtr[0] += ((255 - *srcPtr) *
				(gray-destPtr[0])) / 255;
			srcPtr += blockPtr->pixelSize;
			destPtr += newPixelSize;
		    }
		    srcPtr += blockPtr->pitch - (blockPtr->width * blockPtr->pixelSize);
		}
	    }
	} else {
	    destPtr += newPixelSize-1;
	    for (y = blockPtr->height; y > 0; y--) {
		for (x = blockPtr->width; x > 0; x--) {
		    *destPtr = *srcPtr;
		    srcPtr += blockPtr->pixelSize;
		    destPtr += newPixelSize;
		}
		srcPtr += blockPtr->pitch - (blockPtr->width * blockPtr->pixelSize);
	    }
	}
	blockPtr->pixelPtr = (unsigned char *) data;
	blockPtr->pixelSize = newPixelSize;
	blockPtr->pitch = newPixelSize * blockPtr->width;
	blockPtr->offset[0] = 0;
	if (newPixelSize>2) {
	    blockPtr->offset[1]= 1;
	    blockPtr->offset[2]= 2;
	} else {
	    blockPtr->offset[1]= 0;
	    blockPtr->offset[2]= 0;
	}
	return data;
    }
    return NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * ImgStringWrite --
 *
 *	Default string write function. The data is formatted in
 *	the default format as accepted by the "<img> put" command.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

static int
ImgStringWrite(interp, formatString, blockPtr)
    Tcl_Interp *interp;
    Tcl_Obj *formatString;
    Tk_PhotoImageBlock *blockPtr;
{
    int row,col;
    char *line, *linePtr;
    unsigned char *pixelPtr;
    int greenOffset, blueOffset;
    Tcl_DString data;

    greenOffset = blockPtr->offset[1] - blockPtr->offset[0];
    blueOffset = blockPtr->offset[2] - blockPtr->offset[0];

    Tcl_DStringInit(&data);
    if ((blockPtr->width > 0) && (blockPtr->height > 0)) {
	line = (char *) ckalloc((unsigned int) ((8 * blockPtr->width) + 2));
	for (row=0; row<blockPtr->height; row++) {
	    pixelPtr = blockPtr->pixelPtr + blockPtr->offset[0] +
		    row * blockPtr->pitch;
	    linePtr = line;
	    for (col=0; col<blockPtr->width; col++) {
		sprintf(linePtr, " #%02x%02x%02x", *pixelPtr,
			pixelPtr[greenOffset], pixelPtr[blueOffset]);
		pixelPtr += blockPtr->pixelSize;
		linePtr += 8;
	    }
	    Tcl_DStringAppendElement(&data, line+1);
	}
	ckfree (line);
    }
    Tcl_DStringResult(interp, &data);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_PhotoGetImage --
 *
 *	This procedure is called to obtain image data from a photo
 *	image.  This procedure fills in the Tk_PhotoImageBlock structure
 *	pointed to by `blockPtr' with details of the address and
 *	layout of the image data in memory.
 *
 * Results:
 *	TRUE (1) indicating that image data is available,
 *	for backwards compatibility with the old photo widget.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tk_PhotoGetImage(handle, blockPtr)
    Tk_PhotoHandle handle;	/* Handle for the photo image from which
				 * image data is desired. */
    Tk_PhotoImageBlock *blockPtr;
				/* Information about the address and layout
				 * of the image data is returned here. */
{
    PhotoMaster *masterPtr;

    masterPtr = (PhotoMaster *) handle;
    blockPtr->pixelPtr = masterPtr->pix32;
    blockPtr->width = masterPtr->width;
    blockPtr->height = masterPtr->height;
    blockPtr->pitch = masterPtr->width * 4;
    blockPtr->pixelSize = 4;
    blockPtr->offset[0] = 0;
    blockPtr->offset[1] = 1;
    blockPtr->offset[2] = 2;
    blockPtr->offset[3] = 3;
    return 1;
}

/*
 *----------------------------------------------------------------------
 *
 * PhotoOptionFind --
 *
 *	Finds a specific Photo option.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	After commands are removed.
 *
 *----------------------------------------------------------------------
 */

typedef struct OptionAssocData {
    struct OptionAssocData *nextPtr;	/* pointer to next OptionAssocData */
    Tcl_ObjCmdProc *command;		/* command associated with this
					 * option */
    char name[1];			/* name of option (remaining chars) */
} OptionAssocData;

static Tcl_ObjCmdProc *
PhotoOptionFind(interp, obj)
    Tcl_Interp *interp;		/* Interpreter that is being deleted. */
    Tcl_Obj *obj;			/* Name of option to be found. */
{
    size_t length;
    char *name = Tcl_GetStringFromObj(obj, (int *) &length);
    OptionAssocData *list;
    char *prevname = NULL;
    Tcl_ObjCmdProc *proc = (Tcl_ObjCmdProc *) NULL;
    list = (OptionAssocData *) Tcl_GetAssocData(interp, "photoOption",
	    (Tcl_InterpDeleteProc **) NULL);
    while (list != (OptionAssocData *) NULL) {
	if (strncmp(name, list->name, length) == 0) {
	    if (proc != (Tcl_ObjCmdProc *) NULL) {
		Tcl_ResetResult(interp);
		Tcl_AppendResult(interp, "ambiguous option \"", name,
			"\": must be ", prevname, (char *) NULL);
		while (list->nextPtr != (OptionAssocData *) NULL) {
		    Tcl_AppendResult(interp, prevname, ", ",(char *) NULL);
		    list = list->nextPtr;
		    prevname = list->name;
		}
		Tcl_AppendResult(interp, ", or", prevname, (char *) NULL);
		return (Tcl_ObjCmdProc *) NULL;
	    }
	    proc = list->command;
	    prevname = list->name;
	}
	list = list->nextPtr;
    }
    if (proc != (Tcl_ObjCmdProc *) NULL) {
	Tcl_ResetResult(interp);
    }
    return proc;
}

/*
 *----------------------------------------------------------------------
 *
 * PhotoOptionCleanupProc --
 *
 *	This procedure is invoked whenever an interpreter is deleted
 *	to cleanup the AssocData for "photoVisitor".
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Photo Visitor options are removed.
 *
 *----------------------------------------------------------------------
 */

static void
PhotoOptionCleanupProc(clientData, interp)
    ClientData clientData;	/* Points to "photoVisitor" AssocData
				 * for the interpreter. */
    Tcl_Interp *interp;		/* Interpreter that is being deleted. */
{
    OptionAssocData *list = (OptionAssocData *) clientData;
    OptionAssocData *ptr;

    while (list != NULL) {
	list = (ptr = list)->nextPtr;
	ckfree((char *) ptr);
    }
}

/*
 *--------------------------------------------------------------
 *
 * Tk_CreatePhotoOption --
 *
 *	This procedure may be invoked to add a new kind of photo
 *	option to the core photo command supported by Tk.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	From now on, the new option will be useable by the
 *	photo command.
 *
 *--------------------------------------------------------------
 */

void
Tk_CreatePhotoOption(interp, name, proc)
    Tcl_Interp *interp;			/* interpreter */
    CONST char *name;			/* option name */
    Tcl_ObjCmdProc *proc;		/* proc to execute command */
{
    OptionAssocData *typePtr2, *prevPtr, *ptr;
    OptionAssocData *list;

    list = (OptionAssocData *) Tcl_GetAssocData(interp, "photoOption",
	    (Tcl_InterpDeleteProc **) NULL);

    /*
     * If there's already a photo option with the given name, remove it.
     */

    for (typePtr2 = list, prevPtr = NULL; typePtr2 != NULL;
	    prevPtr = typePtr2, typePtr2 = typePtr2->nextPtr) {
	if (strcmp(typePtr2->name, name) == 0) {
	    if (prevPtr == NULL) {
		list = typePtr2->nextPtr;
	    } else {
		prevPtr->nextPtr = typePtr2->nextPtr;
	    }
	    ckfree((char *) typePtr2);
	    break;
	}
    }
    ptr = (OptionAssocData *) ckalloc(sizeof(OptionAssocData) + strlen(name));
    strcpy(&(ptr->name[0]), name);
    ptr->command = proc;
    ptr->nextPtr = list;
    Tcl_SetAssocData(interp, "photoOption", PhotoOptionCleanupProc,
		(ClientData) ptr);
}

/*
 *--------------------------------------------------------------
 *
 * TkPostscriptPhoto --
 *
 *	This procedure is called to output the contents of a
 *	photo image in Postscript by calling the Tk_PostscriptPhoto
 *	function.
 *
 * Results:
 *	Returns a standard Tcl return value.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */
static int
ImgPhotoPostscript(clientData, interp, tkwin, psInfo,
        x, y, width, height, prepass)
     ClientData clientData;	/* Handle for the photo image */
    Tcl_Interp *interp;		/* Interpreter */
    Tk_Window tkwin;		/* (unused) */
    Tk_PostscriptInfo psInfo;	/* postscript info */
    int x, y;			/* First pixel to output */
    int width, height;		/* Width and height of area */
    int prepass;		/* (unused) */
{
    Tk_PhotoImageBlock block;

    Tk_PhotoGetImage((Tk_PhotoHandle) clientData, &block);
    block.pixelPtr += y * block.pitch + x * block.pixelSize;

    return Tk_PostscriptPhoto(interp, &block, psInfo, width, height);
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_PhotoPutBlock_NoComposite, Tk_PhotoPutZoomedBlock_NoComposite --
 *
 * These backward-compatability functions just exist to fill slots in
 * stubs table.  For the behaviour of *_NoComposite, refer to the
 * corresponding function without the extra suffix.
 *
 *----------------------------------------------------------------------
 */
void
Tk_PhotoPutBlock_NoComposite(handle, blockPtr, x, y, width, height)
     Tk_PhotoHandle handle;
     Tk_PhotoImageBlock *blockPtr;
     int x, y, width, height;
{
    Tk_PhotoPutBlock(handle, blockPtr, x, y, width, height,
	    TK_PHOTO_COMPOSITE_OVERLAY);
}

void
Tk_PhotoPutZoomedBlock_NoComposite(handle, blockPtr, x, y, width, height,
				   zoomX, zoomY, subsampleX, subsampleY)
     Tk_PhotoHandle handle;
     Tk_PhotoImageBlock *blockPtr;
     int x, y, width, height, zoomX, zoomY, subsampleX, subsampleY;
{
    Tk_PhotoPutZoomedBlock(handle, blockPtr, x, y, width, height,
	    zoomX, zoomY, subsampleX, subsampleY, TK_PHOTO_COMPOSITE_OVERLAY);
}
@


1.4
log
@touched all sources to ease next import
@
text
@d5 2
a6 2
 *	stored in full color (32 bits per pixel) and displayed using
 *	dithering if necessary.
d10 1
d19 1
a19 1
 * RCS: @@(#) $Id: tkImgPhoto.c,v 1.7.6.3 2000/09/26 16:08:05 spolk Exp $
d165 1
a165 1
    unsigned char *pix24;	/* Local storage for 24-bit image. */
d235 1
d246 1
d257 8
a264 7
#define OPT_FORMAT	2
#define OPT_FROM	4
#define OPT_GRAYSCALE	8
#define OPT_SHRINK	0x10
#define OPT_SUBSAMPLE	0x20
#define OPT_TO		0x40
#define OPT_ZOOM	0x80
d273 1
d285 8
a292 1
 * The type record for photo images:
d313 4
d333 1
d377 2
d392 1
a392 1
static void		ImgPhotoSetSize _ANSI_ARGS_((PhotoMaster *masterPtr,
d403 1
a403 1
			    char *palette));
d452 42
d506 4
d530 4
d592 1
a592 1
    masterPtr->pix24 = NULL;
d635 1
a635 1
    static char *photoOptions[] = {
d637 1
a637 1
	"read", "redither", "write", (char *) NULL
d641 2
a642 1
	PHOTO_GET, PHOTO_PUT, PHOTO_READ, PHOTO_REDITHER, PHOTO_WRITE
d651 2
a652 2
    char **listArgv;
    char **srcArgv;
d680 1
d682 1
a682 1
      case PHOTO_BLANK: {
d694 2
a695 2
      }
      case PHOTO_CGET: {
d697 1
d718 3
a720 2
      }
      case PHOTO_CONFIGURE: {
a723 1
	char *opt, *arg;
d752 13
a764 8
	  char *arg = Tcl_GetStringFromObj(objv[2], (int *) &length);
	  if (!strncmp(arg, "-data", length)) {
	    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		"-data {} {} {}", (char *) NULL);
	    if (masterPtr->dataString) {
		Tcl_ListObjAppendElement(interp, Tcl_GetObjResult(interp),
			masterPtr->dataString);
	    } else {
d766 9
a774 9
		" {}", (char *) NULL);
	    }
	    return TCL_OK;
	  } else if (!strncmp(arg, "-format", length)) {
	    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		"-format {} {} {}", (char *) NULL);
	    if (masterPtr->format) {
		Tcl_ListObjAppendElement(interp, Tcl_GetObjResult(interp),
			masterPtr->format);
d776 2
a777 2
		Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		" {}", (char *) NULL);
a778 5
	    return TCL_OK;
	  } else {
	    return Tk_ConfigureInfo(interp, Tk_MainWindow(interp),
		    configSpecs, (char *) masterPtr, arg, 0);
	  }
d782 2
a783 3
	break;
      }
      case PHOTO_COPY: {
d793 1
d795 2
a796 2
		OPT_FROM | OPT_TO | OPT_ZOOM | OPT_SUBSAMPLE | OPT_SHRINK,
		&index, objc, objv) != TCL_OK) {
d801 1
a801 1
		    "source-image ?-from x1 y1 x2 y2? ?-to x1 y1 x2 y2? ?-zoom x y? ?-subsample x y?");
d810 2
a811 1
	if ((srcHandle = Tk_FindPhoto(interp, Tcl_GetString(options.name))) == NULL) {
d830 1
a830 1
	if (((options.options & OPT_FROM) == 0) || (options.fromX2 < 0)) {
d834 1
a834 1
	if (((options.options & OPT_TO) == 0) || (options.toX2 < 0)) {
d863 7
a869 1
	    ImgPhotoSetSize(masterPtr, options.toX2, options.toY2);
d877 1
a877 1
	    + options.fromY * block.pitch;
d883 2
a884 1
		options.subsampleX, options.subsampleY);
d887 2
a888 2
      }
      case PHOTO_DATA: {
d961 1
a961 1
	result =  ((int	(*) _ANSI_ARGS_((Tcl_Interp *interp, Tcl_Obj *formatString,
d972 3
a974 2
      }
      case PHOTO_GET: {
d1000 1
a1000 1
	pixelPtr = masterPtr->pix24 + (y * masterPtr->width + x) * 4;
d1005 3
a1007 2
      }
      case PHOTO_PUT: {
d1016 1
a1016 1
	       &index, objc, objv) != TCL_OK) {
d1027 2
a1028 2
	    Tcl_Obj *format;
	    Tcl_Obj *data;
d1049 2
a1050 2
		    0, 0, imageWidth, imageHeight, options.toX, options.toY)
		    != TCL_OK) {
d1061 1
a1061 2
		&dataHeight, &srcArgv)
		!= TCL_OK) {
d1075 2
a1076 2
		pixelPtr = (unsigned char *) ckalloc((unsigned)
			dataWidth * dataHeight * 3);
d1078 5
a1082 8
	    } else {
		if (listArgc != dataWidth) {
		    Tcl_AppendResult(interp, "all elements of color list must",
			     " have the same number of elements",
			    (char *) NULL);
		    ckfree((char *) listArgv);
		    break;
		}
d1096 1
a1096 1
	    if (x < dataWidth)
d1098 1
d1116 1
a1116 1
	if (((options.options & OPT_TO) == 0) || (options.toX2 < 0)) {
d1130 1
a1130 1
		options.toY2 - options.toY);
d1133 4
a1136 2
      }
      case PHOTO_READ: {
a1140 1
	Tcl_Obj *format;
d1151 1
a1151 2
	    Tcl_WrongNumArgs(interp, 2, objv,
		    "fileName ?options?");
d1161 1
a1161 1
                    " safe interpreter", (char *) NULL);
d1176 1
d1181 1
d1186 2
a1187 2
		Tcl_GetString(options.name), options.format,
		&imageFormat, &imageWidth, &imageHeight, &oldformat) != TCL_OK) {
d1217 7
a1223 2
	    ImgPhotoSetSize(masterPtr, options.toX + width,
		    options.toY + height);
d1244 27
a1270 3
      }
      case PHOTO_REDITHER: {
	if (objc == 2) {
d1272 1
a1272 2
	     * Call Dither if any part of the image is not correctly
	     * dithered at present.
d1275 35
a1309 9
	    x = masterPtr->ditherX;
	    y = masterPtr->ditherY;
	    if (masterPtr->ditherX != 0) {
		Tk_DitherPhoto((Tk_PhotoHandle) masterPtr, x, y, masterPtr->width - x, 1);
	    }
	    if (masterPtr->ditherY < masterPtr->height) {
		x = 0;
		Tk_DitherPhoto((Tk_PhotoHandle)masterPtr, 0, masterPtr->ditherY, masterPtr->width,
			masterPtr->height - masterPtr->ditherY);
d1311 18
d1330 34
a1363 1
	    if (y < masterPtr->height) {
d1365 1
a1365 1
		 * Tell the core image code that part of the image has changed.
d1367 1
d1369 15
a1383 3
		Tk_ImageChanged(masterPtr->tkMaster, x, y,
			(masterPtr->width - x), (masterPtr->height - y),
			masterPtr->width, masterPtr->height);
d1386 10
a1395 3
	} else {
	    Tcl_WrongNumArgs(interp, 2, objv, (char *) NULL);
	    return TCL_ERROR;
d1397 4
a1400 3
	break;
      }
      case PHOTO_WRITE: {
d1410 1
a1410 1
                    " safe interpreter", (char *) NULL);
d1444 1
a1444 1
	if (((options.options & OPT_FROM) == 0) || (options.fromX2 < 0)) {
d1456 1
a1456 1
	     imageFormat = imageFormat->nextPtr) {
d1467 10
a1476 9
	  oldformat = 1;
	  for (imageFormat = tsdPtr->oldFormatList; imageFormat != NULL;
	     imageFormat = imageFormat->nextPtr) {
	    if ((options.format == NULL)
		    || (strncasecmp(Tcl_GetString(options.format),
		    imageFormat->name, strlen(imageFormat->name)) == 0)) {
		matched = 1;
		if (imageFormat->fileWriteProc != NULL) {
		    break;
a1478 1
	  }
d1508 1
a1508 2
		Tcl_GetString(options.name),
		format, &block);
a1515 2
	break;
      }
d1518 1
d1529 2
a1530 1
 *	namely, -from, -to, -zoom, -subsample, -format, and -shrink.
d1645 3
a1647 1
	     * The -format option takes a single string value.
d1658 28
d1827 1
a1827 1
    char *oldFileString, *oldPaletteString;
d1835 1
a1835 1
    char **args;
d1839 1
a1839 1
    args = (char **) ckalloc((objc + 1) * sizeof(char *));
d1844 3
a1846 3
		    !strncmp(args[j],"-data", (size_t) length)) {
		if (i < objc) {
		    data = objv[++i];
d1848 4
d1854 3
a1856 3
		    !strncmp(args[j],"-format", (size_t) length)) {
		if (i < objc) {
		    format = objv[++i];
d1858 4
d1877 8
a1884 1
    oldData = (oldFileString == NULL) ? masterPtr->dataString: NULL;
d1886 3
d1899 1
a1899 1
	return TCL_ERROR;
d1941 7
a1947 1
    ImgPhotoSetSize(masterPtr, masterPtr->width, masterPtr->height);
d1963 5
a1967 3
            Tcl_AppendResult(interp, "can't get image from a file in a",
                    " safe interpreter", (char *) NULL);
            return TCL_ERROR;
d1972 12
a1983 1
	    return TCL_ERROR;
d1985 2
a1986 11
        if (Tcl_SetChannelOption(interp, chan, "-translation", "binary")
		!= TCL_OK) {
            return TCL_ERROR;
        }
        if (Tcl_SetChannelOption(interp, chan, "-encoding", "binary")
		!= TCL_OK) {
            return TCL_ERROR;
        }
	if (MatchFileFormat(interp, chan, masterPtr->fileString,
		masterPtr->format, &imageFormat, &imageWidth,
		&imageHeight, &oldformat) != TCL_OK) {
d1988 4
a1991 1
	    return TCL_ERROR;
a1992 1
	ImgPhotoSetSize(masterPtr, imageWidth, imageHeight);
d2003 1
a2003 1
	    return TCL_ERROR;
d2012 1
a2012 1
	    || (masterPtr->format != oldFormat))) {
d2014 1
a2014 1
	if (MatchStringFormat(interp, masterPtr->dataString, 
d2017 7
a2023 1
	    return TCL_ERROR;
a2024 1
	ImgPhotoSetSize(masterPtr, imageWidth, imageHeight);
d2036 1
a2036 1
	    return TCL_ERROR;
d2076 6
d2083 9
d2189 2
a2267 1
    XRectangle validBox;
d2411 1
d2414 1
a2427 10
    /*
     * Dither the image to fill in this instance's pixmap.
     */

    TkClipBox(masterPtr->validRegion, &validBox);
    if ((validBox.width > 0) && (validBox.height > 0)) {
	DitherInstance(instancePtr, validBox.x, validBox.y, validBox.width,
		validBox.height);
    }

d2572 2
a2573 2
    if (masterPtr->pix24 != NULL) {
	ckfree((char *) masterPtr->pix24);
d2628 2
a2629 1
 *	None.
d2637 1
a2637 1
static void
d2642 1
a2642 1
    unsigned char *newPix24;
d2656 23
d2699 6
a2704 11
    if ((width != masterPtr->width) || (height != masterPtr->height)
	    || (masterPtr->pix24 == NULL)) {

	/*
	 * Reallocate storage for the 24-bit image and copy
	 * over valid regions.
	 */

	pitch = width * 4;
	newPix24 = (unsigned char *) ckalloc((unsigned) (height * pitch));

d2711 1
a2711 1
	if ((masterPtr->pix24 != NULL)
d2714 1
a2714 1
		memset((VOID *) newPix24, 0, (size_t) (validBox.y * pitch));
d2718 1
a2718 1
		memset((VOID *) (newPix24 + h * pitch), 0,
d2722 1
a2722 1
	    memset((VOID *) newPix24, 0, (size_t) (height * pitch));
d2725 1
a2725 1
	if (masterPtr->pix24 != NULL) {
d2739 2
a2740 2
		memcpy((VOID *) (newPix24 + offset),
			(VOID *) (masterPtr->pix24 + offset),
d2749 2
a2750 2
		destPtr = newPix24 + (validBox.y * width + validBox.x) * 4;
		srcPtr = masterPtr->pix24 + (validBox.y * masterPtr->width
d2760 1
a2760 1
	    ckfree((char *) masterPtr->pix24);
d2763 1
a2763 1
	masterPtr->pix24 = newPix24;
d2780 4
a2783 6
	} else {
	    if ((masterPtr->ditherY > 0)
		    || ((int) validBox.width < masterPtr->ditherX)) {
		masterPtr->ditherX = validBox.width;
		masterPtr->ditherY = 0;
	    }
d2795 2
d2841 4
d2959 1
a2959 1
    char *palette;			/* Palette specification string. */
a3236 1
    nRed = nGreen = nBlue = 0;
d3740 1
a3740 1
	    (void) Tcl_Seek(chan, 0L, SEEK_SET);
d3755 14
a3768 7
      useoldformat = 1;
      for (formatPtr = tsdPtr->oldFormatList; formatPtr != NULL;
	 formatPtr = formatPtr->nextPtr) {
	if (formatString != NULL) {
	    if (strncasecmp(formatString,
		    formatPtr->name, strlen(formatPtr->name)) != 0) {
		continue;
d3770 11
a3780 16
	    matched = 1;
	    if (formatPtr->fileMatchProc == NULL) {
		Tcl_AppendResult(interp, "-file option isn't supported for ",
			formatString, " images", (char *) NULL);
		return TCL_ERROR;
	    }
	}
	if (formatPtr->fileMatchProc != NULL) {
	    (void) Tcl_Seek(chan, 0L, SEEK_SET);
	    if ((*formatPtr->fileMatchProc)(chan, fileName, (Tcl_Obj *) formatString,
		    widthPtr, heightPtr, interp)) {
		if (*widthPtr < 1) {
		    *widthPtr = 1;
		}
		if (*heightPtr < 1) {
		    *heightPtr = 1;
a3781 1
		break;
a3783 1
      }
d3801 1
a3801 1
    (void) Tcl_Seek(chan, 0L, SEEK_SET);
d3880 14
a3893 7
      useoldformat = 1;
      for (formatPtr = tsdPtr->oldFormatList; formatPtr != NULL;
	    formatPtr = formatPtr->nextPtr) {
	if (formatObj != NULL) {
	    if (strncasecmp(formatString,
		    formatPtr->name, strlen(formatPtr->name)) != 0) {
		continue;
d3895 7
a3901 5
	    matched = 1;
	    if (formatPtr->stringMatchProc == NULL) {
		Tcl_AppendResult(interp, "-data option isn't supported for ",
			formatString, " images", (char *) NULL);
		return TCL_ERROR;
a3903 8
	if ((formatPtr->stringMatchProc != NULL)
		&& (formatPtr->stringReadProc != NULL)
		&& (*formatPtr->stringMatchProc)((Tcl_Obj *) Tcl_GetString(data),
			(Tcl_Obj *) formatString,
		widthPtr, heightPtr, interp)) {
	    break;
	}
      }	
d3907 1
a3907 2
	    Tcl_AppendResult(interp, "image format \"",
		    formatString,
d3945 1
a3945 1
    char *imageName;		/* Name of the desired photo image. */
d3974 1
a3974 1
Tk_PhotoPutBlock(handle, blockPtr, x, y, width, height)
d3984 2
d4006 1
a4006 1
    if ((width <= 0) || (height <= 0))
d4008 1
d4013 4
a4016 2
	ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width),
		MAX(yEnd, masterPtr->height));
d4046 1
a4046 1
     * Copy the data into our local 24-bit/pixel array.
d4050 1
a4050 1
    destLinePtr = masterPtr->pix24 + (y * masterPtr->width + x) * 4;
d4062 2
a4063 1
		&& (blockPtr->pitch == pitch)))) {
d4068 1
d4074 64
a4137 24
		destPtr = destLinePtr;
		for (wLeft = width; wLeft > 0;) {
		    wCopy = MIN(wLeft, blockPtr->width);
		    wLeft -= wCopy;
		    srcPtr = srcLinePtr;
		    for (; wCopy > 0; --wCopy) {
		      if (!destPtr[3]) {
			destPtr[0] = destPtr[1] = destPtr[2] = 0xd9;
		      }
		      if (!alphaOffset || (srcPtr[alphaOffset] == 255)) {
			*destPtr++ = srcPtr[0];
			*destPtr++ = srcPtr[greenOffset];
			*destPtr++ = srcPtr[blueOffset];
			*destPtr++ = 255;
		      } else {
			if (srcPtr[alphaOffset]) {
			    destPtr[0] += (srcPtr[0] - destPtr[0]) * srcPtr[alphaOffset] / 255;
			    destPtr[1] += (srcPtr[greenOffset] - destPtr[1]) * srcPtr[alphaOffset] / 255;
			    destPtr[2] += (srcPtr[blueOffset] - destPtr[2]) * srcPtr[alphaOffset] / 255;
			    destPtr[3] += (255 - destPtr[3]) * srcPtr[alphaOffset] / 255;
		  	}
			destPtr+=4;
		      }
		      srcPtr += blockPtr->pixelSize;
d4150 64
a4213 42
  if (alphaOffset) {
    int x1, y1, end;
    
    /*
     * This block is grossly inefficient.  For each row in the image, it
     * finds each continguous string of transparent pixels, then marks those
     * areas as invalid in the validRegion mask.  This makes drawing very
     * efficient, because of the way we use X:  we just say, here's your
     * mask, and here's your data.  We need not worry about the current
     * background color, etc.  But this costs us a lot on the image setup.
     * Still, image setup only happens once, whereas the drawing happens
     * many times, so this might be the best way to go.
     *
     * An alternative might be to not set up this mask, and instead, at
     * drawing time, for each transparent pixel, set its color to the
     * color of the background behind that pixel.  This is what I suspect
     * most of programs do.  However, they don't have to deal with the canvas,
     * which could have many different background colors.  Determining the
     * correct bg color for a given pixel might be expensive.
     */
     
    destLinePtr = masterPtr->pix24 + (y * masterPtr->width + x) * 4 + 3;
    for (y1 = 0; y1 < height; y1++) {
	x1 = 0;
	destPtr = destLinePtr;
	while (x1 < width) {
	    /* search for first non-transparent pixel */
	    while ((x1 < width) && !*destPtr) {
		    x1++; destPtr += 4;
	    }
	    end = x1;
	    /* search for first transparent pixel */
	    while ((end < width) && *destPtr) {
	        end++; destPtr += 4;
	    }
	    if (end > x1) {
		rect.x = x + x1;
		rect.y = y + y1;
		rect.width = end - x1;
		rect.height = 1;
		TkUnionRectWithRegion(&rect, masterPtr->validRegion,
			masterPtr->validRegion);
d4215 1
a4215 1
	    x1 = end;
d4217 7
a4223 1
	destLinePtr += masterPtr->width * 4;
a4224 8
  } else {
    rect.x = x;
    rect.y = y;
    rect.width = width;
    rect.height = height;
    TkUnionRectWithRegion(&rect, masterPtr->validRegion,
	    masterPtr->validRegion);
  }
d4260 1
a4260 1
	subsampleX, subsampleY)
d4272 2
d4288 2
a4289 3
    if ((zoomX == 1) && (zoomY == 1) && (subsampleX == 1)
	    && (subsampleY == 1)) {
	Tk_PhotoPutBlock(handle, blockPtr, x, y, width, height);
d4295 1
a4295 1
    if ((zoomX <= 0) || (zoomY <= 0))
d4297 1
d4305 1
a4305 1
    if ((width <= 0) || (height <= 0))
d4307 1
d4312 5
a4316 3
	int sameSrc = (blockPtr->pixelPtr == masterPtr->pix24);
	ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width),
		MAX(yEnd, masterPtr->height));
d4318 1
a4318 1
	    blockPtr->pixelPtr = masterPtr->pix24;
d4356 1
a4356 1
    if (subsampleX > 0)
d4358 1
a4358 1
    else if (subsampleX == 0)
d4360 1
a4360 1
    else
d4362 2
a4363 1
    if (subsampleY > 0)
d4365 1
a4365 1
    else if (subsampleY == 0)
d4367 1
a4367 1
    else
d4369 1
d4372 1
a4372 1
     * Copy the data into our local 24-bit/pixel array.
d4375 1
a4375 1
    destLinePtr = masterPtr->pix24 + (y * masterPtr->width + x) * 4;
d4398 37
a4434 17
		      if (!destPtr[3]) {
			destPtr[0] = destPtr[1] = destPtr[2] = 0xd9;
		      }
		      if (!alphaOffset || (srcPtr[alphaOffset] == 255)) {
			*destPtr++ = srcPtr[0];
			*destPtr++ = srcPtr[greenOffset];
			*destPtr++ = srcPtr[blueOffset];
			*destPtr++ = 255;
		      } else {
			if (srcPtr[alphaOffset]) {
			    destPtr[0] += (srcPtr[0] - destPtr[0]) * srcPtr[alphaOffset] / 255;
			    destPtr[1] += (srcPtr[greenOffset] - destPtr[1]) * srcPtr[alphaOffset] / 255;
			    destPtr[2] += (srcPtr[blueOffset] - destPtr[2]) * srcPtr[alphaOffset] / 255;
			    destPtr[3] += (255 - destPtr[3]) * srcPtr[alphaOffset] / 255;
		  	}
			destPtr+=4;
		      }
d4449 1
a4449 1
     * Add this new block to the region that specifies which data is valid.
d4452 2
a4453 2
  if (alphaOffset) {
    int x1, y1, end;
d4455 42
a4496 21
    destLinePtr = masterPtr->pix24 + (y * masterPtr->width + x) * 4 + 3;
    for (y1 = 0; y1 < height; y1++) {
	x1 = 0;
	destPtr = destLinePtr;
	while (x1 < width) {
	    /* search for first non-transparent pixel */
	    while ((x1 < width) && !*destPtr) {
		    x1++; destPtr += 4;
	    }
	    end = x1;
	    /* search for first transparent pixel */
	    while ((end < width) && *destPtr) {
	        end++; destPtr += 4;
	    }
	    if (end > x1) {
		rect.x = x + x1;
		rect.y = y + y1;
		rect.width = end - x1;
		rect.height = 1;
		TkUnionRectWithRegion(&rect, masterPtr->validRegion,
			masterPtr->validRegion);
d4498 1
a4498 1
	    x1 = end;
d4500 7
a4506 1
	destLinePtr += masterPtr->width * 4;
a4507 8
  } else {
    rect.x = x;
    rect.y = y;
    rect.width = width;
    rect.height = height;
    TkUnionRectWithRegion(&rect, masterPtr->validRegion,
	    masterPtr->validRegion);
  }
d4691 1
a4691 1
    srcLinePtr = masterPtr->pix24 + (yStart * masterPtr->width + xStart) * 4;
d4983 1
a4983 1
     * Clear out the 24-bit pixel storage array.
d4987 1
a4987 1
    memset((VOID *) masterPtr->pix24, 0,
d5043 4
a5046 2
	ImgPhotoSetSize(masterPtr, MAX(width, masterPtr->width),
		MAX(height, masterPtr->height));
d5115 4
a5118 2
    ImgPhotoSetSize(masterPtr, ((width > 0) ? width: masterPtr->width),
	    ((height > 0) ? height: masterPtr->height));
d5126 31
d5206 2
a5207 1
		alphaOffset = 3; break;
d5211 3
a5213 1
	if (alphaOffset) break;
d5415 1
a5415 1
    blockPtr->pixelPtr = masterPtr->pix24;
d5593 7
a5599 7
    ClientData clientData;
    Tcl_Interp *interp;
    Tk_Window tkwin;
    Tk_PostscriptInfo psInfo; /* postscript info */
    int x, y;   /* First pixel to output */
    int width, height;  /* Width and height of area */
    int prepass;
d5608 21
d5630 10
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
 *	stored in full color (24 bits per pixel) and displayed using
d14 5
a18 1
 * RCS: @@(#) $Id: tkImgPhoto.c,v 1.13 1999/01/26 04:11:23 jingham Exp $
d26 4
d34 1
a34 1
extern _XInitImageFuncPtrs _ANSI_ARGS_((XImage *image));
d132 3
d161 2
a162 2
    Tcl_Obj *dataObj;		/* Object to use as contents of image. */
    char *format;		/* User-specified format of data in image
d225 1
a225 1
    char *name;			/* Name specified without an option. */
d232 1
a232 1
    char *format;		/* Value specified for -format option. */
d284 1
a284 1
			    char *name, int argc, Tcl_Obj *CONST objv[],
d296 4
d308 1
d312 8
a332 2
    {TK_CONFIG_STRING, "-format", (char *) NULL, (char *) NULL,
	 (char *) NULL, Tk_Offset(PhotoMaster, format), TK_CONFIG_NULL_OK},
a356 6
 * Pointer to the first in the list of known photo image formats.
 */

static Tk_PhotoImageFormat *formatList = NULL;

/*
d361 1
a361 1
			    Tcl_Interp *interp, int argc, Tcl_Obj *CONST objv[]));
d365 1
a365 1
			    int *indexPtr, int argc, char **argv));
d370 1
a370 1
			    int argc, Tcl_Obj *CONST objv[], int flags));
d378 1
a378 1
			    Tcl_DString *dataPtr, char *formatString,
d395 1
a395 2
			    Tcl_Channel chan, char *fileName,
			    char *formatString,
d397 1
a397 1
			    int *widthPtr, int *heightPtr));
d399 1
a399 1
			    Tcl_Obj *dataObj, char *formatString,
d401 3
a403 3
			    int *widthPtr, int *heightPtr));
static void		Dither _ANSI_ARGS_((PhotoMaster *masterPtr,
			    int x, int y, int width, int height));
d406 2
d417 1
a417 1
 * Tk_CreatePhotoImageFormat --
d433 19
d462 2
d469 7
a475 2
    copyPtr->nextPtr = formatList;
    formatList = copyPtr;
d497 1
a497 1
ImgPhotoCreate(interp, name, argc, objv, typePtr, master, clientDataPtr)
d501 1
a501 1
    int argc;			/* Number of arguments. */
d531 1
a531 1
    if (ImgPhotoConfigureMaster(interp, masterPtr, argc, objv, 0) != TCL_OK) {
d559 1
a559 1
ImgPhotoCmd(clientData, interp, argc, objv)
d562 1
a562 1
    int argc;			/* Number of arguments. */
d565 10
d576 1
a576 1
    int c, result, index;
a585 1
    char string[16];
d593 2
a594 1
    static char **argv = NULL;
d596 2
a597 3
    if (argc < 2) {
	Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
		" option ?arg arg ...?\"", (char *) NULL);
d601 8
a608 7
    if (argv) {
	ckfree((char *) argv);
    }
    argv = (char **) ckalloc((argc+1) * sizeof(char *));
    argv[argc] = NULL;
    for (index = 0; index < argc; index++) {
	argv[index] = Tcl_GetStringFromObj(objv[index], (int *) NULL);
d610 2
a611 4
    c = argv[1][0];
    length = strlen(argv[1]);

    if ((c == 'b') && (strncmp(argv[1], "blank", length) == 0)) {
d616 1
a616 1
	if (argc == 2) {
d619 1
a619 2
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " blank\"", (char *) NULL);
d622 6
a627 6
    } else if ((c == 'c') && (length >= 2)
	    && (strncmp(argv[1], "cget", length) == 0)) {
	if (argc != 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " cget option\"",
		    (char *) NULL);
d630 10
a639 3
	if (strncmp(argv[2],"-data", length) == 0) {
	    if (masterPtr->dataObj) {
		Tcl_SetObjResult(interp, masterPtr->dataObj);
d644 4
a647 3
		(char *) masterPtr, argv[2], 0);
    } else if ((c == 'c') && (length >= 3)
	    && (strncmp(argv[1], "configure", length) == 0)) {
d653 2
a654 1
	if (argc == 2) {
d660 22
a681 4
	    opt = Tcl_GetStringFromObj(Tcl_GetObjResult(interp), &length);
	    arg = (char *) ckalloc(length + 1);
	    strcpy(arg, opt);
	    Tcl_ResetResult(interp);
d683 8
a690 2
		    "{-data {} {} {} {}} ", arg, (char*) NULL);
	    ckfree(arg);
d692 1
a692 6
	}
	if (argc == 3) {
	  if (strncmp(argv[2], "-data", length)) {
	    return Tk_ConfigureInfo(interp, Tk_MainWindow(interp),
		    configSpecs, (char *) masterPtr, argv[2], 0);
	  } else {
d694 2
a695 2
		"-data {} {} {} ", (char *) NULL);
	    if (masterPtr->dataObj) {
d697 1
a697 1
			masterPtr->dataObj);
d700 1
a700 1
		"{}", (char *) NULL);
d703 3
d708 1
a708 1
	return ImgPhotoConfigureMaster(interp, masterPtr, argc-2, objv+2,
d710 3
a712 2
    } else if ((c == 'c') && (length >= 3)
	    && (strncmp(argv[1], "copy", length) == 0)) {
d724 1
a724 1
		&index, argc, argv) != TCL_OK) {
d727 3
a729 5
	if (options.name == NULL || index < argc) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
		    " copy source-image ?-from x1 y1 x2 y2?",
		    " ?-to x1 y1 x2 y2? ?-zoom x y? ?-subsample x y?",
		    "\"", (char *) NULL);
d738 3
a740 2
	if ((srcHandle = Tk_FindPhoto(interp, options.name)) == NULL) {
	    Tcl_AppendResult(interp, "image \"", argv[2], "\" doesn't",
d806 3
a808 2
    } else if ((c == 'd') && (strncmp(argv[1], "data", length) == 0)) {
        Tcl_DString buffer;
d824 1
a824 1
		&index, argc, argv) != TCL_OK) {
d827 2
a828 4
	if ((options.name != NULL) || (index < argc)) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
		    " data ?-format format-name?",
		    "?-from x1 y1 x2 y2?\"", (char *) NULL);
d854 1
a854 1
	    for (imageFormat = formatList; imageFormat != NULL;
d856 2
a857 2
		if ((strncasecmp(options.format, imageFormat->name,
		    strlen(imageFormat->name)) == 0)) {
d865 2
a866 1
		Tcl_AppendResult(interp, "image string format \"", options.format,
a879 1
	Tcl_DStringInit(&buffer);
d881 3
a883 2
	result =  stringWriteProc(interp, &buffer,
		options.format, &block);
a889 5
	if (result == TCL_OK) {
	    Tcl_DStringResult(interp, &buffer);
	} else {
	    Tcl_DStringFree(&buffer);
	}
d891 3
a893 1
    } else if ((c == 'g') && (strncmp(argv[1], "get", length) == 0)) {
d898 4
a901 3
	if (argc != 4) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
		    " get x y\"", (char *) NULL);
d904 2
a905 2
	if ((Tcl_GetInt(interp, argv[2], &x) != TCL_OK)
		|| (Tcl_GetInt(interp, argv[3], &y) != TCL_OK)) {
d910 1
a910 1
	    Tcl_AppendResult(interp, argv[0], " get: ",
d923 3
a925 1
    } else if ((c == 'p') && (strncmp(argv[1], "put", length) == 0)) {
d934 1
a934 1
	       &index, argc, argv) != TCL_OK) {
d937 2
a938 4
	if ((options.name == NULL) || (index < argc)) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
		     " put data ?-format format? ?-to x1 y1 x2 y2?\"",
		     (char *) NULL);
d944 3
a946 1
		&imageHeight) == TCL_OK) {
d957 10
a966 2
	    if ((*imageFormat->stringReadProc)(interp, objv[2],
		    options.format, (Tk_PhotoHandle) masterPtr,
d978 2
a979 1
	if (Tcl_SplitList(interp, options.name, &dataHeight, &srcArgv)
d1048 1
d1053 3
a1055 2
    } else if ((c == 'r') && (length >= 3)
	       && (strncmp(argv[1], "read", length) == 0)) {
d1060 1
d1067 1
a1067 1
		&index, argc, argv) != TCL_OK) {
d1070 3
a1072 5
	if ((options.name == NULL) || (index < argc)) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
		    " read fileName ?-format format-name?",
		    " ?-from x1 y1 x2 y2? ?-to x y? ?-shrink?\"",
		    (char *) NULL);
d1090 2
a1091 1
	chan = Tcl_OpenFileChannel(interp, options.name, "r", 0);
d1099 8
a1106 2
	if (MatchFileFormat(interp, chan, options.name, options.format,
		&imageFormat, &imageWidth, &imageHeight) != TCL_OK) {
d1145 7
a1151 2
	result = (*imageFormat->fileReadProc)(interp, chan, options.name,
		options.format, (Tk_PhotoHandle) masterPtr, options.toX,
d1157 4
a1160 4
    } else if ((c == 'r') && (length >= 3)
	       && (strncmp(argv[1], "redither", length) == 0)) {

	if (argc == 2) {
d1169 1
a1169 1
		Dither(masterPtr, x, y, masterPtr->width - x, 1);
d1173 1
a1173 1
		Dither(masterPtr, 0, masterPtr->ditherY, masterPtr->width,
d1188 1
a1188 2
	    Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
		    " redither\"", (char *) NULL);
d1191 3
a1193 1
    } else if ((c == 'w') && (strncmp(argv[1], "write", length) == 0)) {
d1195 2
d1217 1
a1217 1
		&index, argc, argv) != TCL_OK) {
d1220 2
a1221 4
	if ((options.name == NULL) || (index < argc)) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
		    " write fileName ?-format format-name?",
		    "?-from x1 y1 x2 y2?\"", (char *) NULL);
d1248 14
a1261 1
	for (imageFormat = formatList; imageFormat != NULL;
d1264 2
a1265 2
		    || (strncasecmp(options.format, imageFormat->name,
		    strlen(imageFormat->name)) == 0)) {
d1271 1
d1279 2
a1280 1
			options.format, "\" is unknown", (char *) NULL);
d1283 2
a1284 1
			options.format, "\" has no file writing capability",
d1296 7
a1302 2
	result = (*imageFormat->fileWriteProc)(interp, options.name,
		options.format, &block);
d1310 2
a1311 5
    } else {
	Tcl_AppendResult(interp, "bad option \"", argv[1],
		"\": must be blank, cget, configure, copy, get, put,",
		" read, redither, or write", (char *) NULL);
	return TCL_ERROR;
d1336 1
a1336 1
ParseSubcommandOptions(optPtr, interp, allowedOptions, optIndexPtr, argc, argv)
d1344 1
a1344 1
				 * current index in argv; this variable is
d1346 2
a1347 2
    int argc;			/* Number of arguments in argv[]. */
    char **argv;		/* Arguments to be parsed. */
d1350 1
a1350 1
    size_t length;
d1355 1
a1355 1
    for (index = *optIndexPtr; index < argc; *optIndexPtr = ++index) {
d1361 1
a1361 1
	option = argv[index];
d1364 1
a1364 1
		optPtr->name = option;
a1373 1
	length = strlen(option);
d1379 1
a1379 1
		    && (strncmp(option, *listPtr, length) == 0)) {
d1395 2
a1396 1
	    Tcl_AppendResult(interp, "unrecognized option \"", argv[index],
d1425 1
a1425 1
	    if (index + 1 < argc) {
d1428 1
a1428 1
			Tk_GetUid(argv[index]));
d1442 1
a1442 1
	    if (index + 1 < argc) {
d1444 1
a1444 1
		optPtr->format = argv[index];
d1451 1
d1455 7
a1461 4
		if ((argIndex < argc) && (isdigit(UCHAR(argv[argIndex][0]))
			|| ((argv[argIndex][0] == '-')
			&& (isdigit(UCHAR(argv[argIndex][1])))))) {
		    if (Tcl_GetInt(interp, argv[argIndex], &values[numValues])
d1472 1
a1472 1
		Tcl_AppendResult(interp, "the \"", argv[index], "\" option ",
d1571 1
a1571 1
 *	an error message is left in masterPtr->interp->result.
d1581 1
a1581 1
ImgPhotoConfigureMaster(interp, masterPtr, argc, objv, flags)
d1585 1
a1585 1
    int argc;			/* Number of entries in argv. */
d1591 2
a1592 2
    char *oldFileString, *oldPaletteString, *oldFormat;
    Tcl_Obj *oldDataObj, *dataObj = NULL;
d1599 20
a1618 11
    static char **argv = NULL;

    if (argv) ckfree((char *) argv);
    argv = (char **) ckalloc((argc + 1) * sizeof(char *));
    for (i = 0, j = 0; i < argc; i++,j++) {
	argv[j] = Tcl_GetStringFromObj(objv[i], &length);
	if (argv[j][0] == '-' && argv[j][1] == 'd' &&
		strncmp(argv[j],"-data", length) == 0) {
	    if (i < argc) {
		dataObj = objv[++i];
		j--;
d1622 1
d1633 1
a1633 1
    oldDataObj = (oldFileString == NULL) ? masterPtr->dataObj: NULL;
d1643 2
a1644 1
	    j, argv, (char *) masterPtr, flags) != TCL_OK) {
d1647 1
d1658 5
a1662 3
    if (dataObj) {
	if (dataObj->length) {
	    Tcl_IncrRefCount(dataObj);
d1664 1
a1664 1
	    dataObj = NULL;
d1666 2
a1667 2
	if (masterPtr->dataObj) {
	    Tcl_DecrRefCount(masterPtr->dataObj);
d1669 1
a1669 1
	masterPtr->dataObj = dataObj;
d1671 10
a1680 3
    if ((masterPtr->format != NULL) && (masterPtr->format[0] == 0)) {
	ckfree(masterPtr->format);
	masterPtr->format = NULL;
a1681 1

d1716 4
d1722 1
a1722 1
		&imageHeight) != TCL_OK) {
d1727 4
d1732 1
a1732 1
		masterPtr->fileString, masterPtr->format,
d1740 1
d1744 2
a1745 2
    if ((masterPtr->fileString == NULL) && (masterPtr->dataObj != NULL)
	    && ((masterPtr->dataObj != oldDataObj)
d1748 1
a1748 1
	if (MatchStringFormat(interp, masterPtr->dataObj, 
d1750 1
a1750 1
		&imageHeight) != TCL_OK) {
d1754 10
a1763 2
	if ((*imageFormat->stringReadProc)(interp, masterPtr->dataObj,
		masterPtr->format, (Tk_PhotoHandle) masterPtr,
d1768 1
d1981 1
a1981 1
    char buf[16];
d2122 2
a2123 3
    instancePtr->gc = Tk_GetGCColor(tkwin,
	    GCForeground|GCBackground|GCGraphicsExposures, &gcValues,
	    white, black);
d2299 5
a2303 2
    if (masterPtr->dataObj != NULL) {
	Tcl_DecrRefCount(masterPtr->dataObj);
d3394 2
a3395 2
MatchFileFormat(interp, chan, fileName, formatString, imageFormatPtr,
	widthPtr, heightPtr)
d3399 1
a3399 1
    char *formatString;		/* User-specified format string, or NULL. */
d3405 1
d3408 1
d3410 7
d3424 32
a3455 1
    for (formatPtr = formatList; formatPtr != NULL;
d3458 2
a3459 2
	    if (strncasecmp(formatString, formatPtr->name,
		    strlen(formatPtr->name)) != 0) {
d3471 2
a3472 3
	    
	    if ((*formatPtr->fileMatchProc)(chan, fileName, formatString,
		    widthPtr, heightPtr)) {
d3482 1
d3486 3
a3488 2
	if ((formatString != NULL) && !matched) {
	    Tcl_AppendResult(interp, "image file format \"", formatString,
d3499 1
d3527 2
a3528 2
MatchStringFormat(interp, dataObj, formatString, imageFormatPtr,
	widthPtr, heightPtr)
d3530 2
a3531 2
    Tcl_Obj *dataObj;		/* Object containing the image data. */
    char *formatString;		/* User-specified format string, or NULL. */
d3537 1
d3540 1
d3542 7
d3556 1
a3556 1
    for (formatPtr = formatList; formatPtr != NULL;
d3558 3
a3560 3
	if (formatString != NULL) {
	    if (strncasecmp(formatString, formatPtr->name,
		    strlen(formatPtr->name)) != 0) {
d3572 2
a3573 2
		&& (*formatPtr->stringMatchProc)(dataObj, formatString,
		widthPtr, heightPtr)) {
d3579 28
a3606 2
	if ((formatString != NULL) && !matched) {
	    Tcl_AppendResult(interp, "image format \"", formatString,
d3616 1
d3729 2
a3730 7
    alphaOffset = 0;
    while ((alphaOffset != blockPtr->offset[0]) &&
	    (alphaOffset != blockPtr->offset[1]) &&
	    (alphaOffset != blockPtr->offset[2])) {
	alphaOffset++;
    }
    if (alphaOffset >= blockPtr->pixelSize) {
d3747 7
a3753 1
    if ((blockPtr->pixelSize == 4) && (greenOffset == 1) && (blueOffset == 2)
d3772 4
d3779 11
a3789 2
			*destPtr++ = alphaOffset ? srcPtr[alphaOffset] : 255;
			srcPtr += blockPtr->pixelSize;
d3802 48
d3856 1
d3862 1
a3862 1
    Dither(masterPtr, x, y, width, height);
d3966 2
a3967 7
    alphaOffset = 0;
    while ((alphaOffset != blockPtr->offset[0]) &&
	    (alphaOffset != blockPtr->offset[1]) &&
	    (alphaOffset != blockPtr->offset[2])) {
	alphaOffset++;
    }
    if (alphaOffset >= blockPtr->pixelSize) {
d4023 4
d4030 10
a4039 1
			*destPtr++ = alphaOffset ? srcPtr[alphaOffset] : 255;
d4057 30
d4093 1
d4099 1
a4099 1
    Dither(masterPtr, x, y, width, height);
d4112 1
a4112 1
 * Dither --
d4128 3
a4130 3
static void
Dither(masterPtr, x, y, width, height)
    PhotoMaster *masterPtr;	/* Image master whose instances are
d4136 1
d4781 2
a4782 1
	data = ckalloc(newPixelSize * blockPtr->width * blockPtr->height);
d4897 1
a4897 1
ImgStringWrite (interp, dataPtr, formatString, blockPtr)
d4899 1
a4899 2
    Tcl_DString *dataPtr;
    char *formatString;
d4906 1
d4911 1
d4913 1
a4913 1
	line = (char *) ckalloc(8 * blockPtr->width + 2);
d4924 1
a4924 1
	    Tcl_DStringAppendElement(dataPtr, line+1);
d4928 1
d4971 1
d4974 183
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d5 1
a5 1
 *	stored in full color (32 bits per pixel) and displayed using
d14 1
a14 5
 * Author: Paul Mackerras (paulus@@cs.anu.edu.au),
 *	   Department of Computer Science,
 *	   Australian National University.
 *
 * RCS: @@(#) $Id: tkImgPhoto.c,v 1.7.6.3 2000/09/26 16:08:05 spolk Exp $
a21 4
#ifdef __WIN32__
#include "tkWinInt.h"
#endif

d26 1
a26 1
extern int _XInitImageFuncPtrs _ANSI_ARGS_((XImage *image));
a123 3
#ifdef COLOR_WINDOW
#undef COLOR_WINDOW
#endif
d150 2
a151 2
    Tcl_Obj *dataString;	/* Object to use as contents of image. */
    Tcl_Obj *format;		/* User-specified format of data in image
d214 1
a214 1
    Tcl_Obj *name;		/* Name specified without an option. */
d221 1
a221 1
    Tcl_Obj *format;		/* Value specified for -format option. */
d273 1
a273 1
			    char *name, int objc, Tcl_Obj *CONST objv[],
a284 4
static int		ImgPhotoPostscript _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, Tk_Window tkwin,
			    Tk_PostscriptInfo psInfo, int x, int y, int width,
			    int height, int prepass));
a292 1
    ImgPhotoPostscript,		/* postscriptProc */
a295 8
typedef struct ThreadSpecificData {
    Tk_PhotoImageFormat *formatList;  /* Pointer to the first in the 
				       * list of known photo image formats.*/
    Tk_PhotoImageFormat *oldFormatList;  /* Pointer to the first in the 
				       * list of known photo image formats.*/
} ThreadSpecificData;
static Tcl_ThreadDataKey dataKey;

d309 2
d335 6
d345 1
a345 1
			    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
d349 1
a349 1
			    int *indexPtr, int objc, Tcl_Obj *CONST objv[]));
d354 1
a354 1
			    int objc, Tcl_Obj *CONST objv[], int flags));
d362 1
a362 1
			    Tcl_Obj *formatString,
d379 2
a380 1
			    Tcl_Channel chan, char *fileName, Tcl_Obj *formatString,
d382 1
a382 1
			    int *widthPtr, int *heightPtr, int *oldformat));
d384 1
a384 1
			    Tcl_Obj *data, Tcl_Obj *formatString,
d386 3
a388 3
			    int *widthPtr, int *heightPtr, int *oldformat));
static Tcl_ObjCmdProc *	PhotoOptionFind _ANSI_ARGS_((Tcl_Interp * interp,
			    Tcl_Obj *obj));
a390 2
static void		PhotoOptionCleanupProc _ANSI_ARGS_((
			    ClientData clientData, Tcl_Interp *interp));
d400 1
a400 1
 * Tk_CreateOldPhotoImageFormat, Tk_CreatePhotoImageFormat --
a415 19
void
Tk_CreateOldPhotoImageFormat(formatPtr)
    Tk_PhotoImageFormat *formatPtr;
				/* Structure describing the format.  All of
				 * the fields except "nextPtr" must be filled
				 * in by caller.  Must not have been passed
				 * to Tk_CreatePhotoImageFormat previously. */
{
    Tk_PhotoImageFormat *copyPtr;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    copyPtr = (Tk_PhotoImageFormat *) ckalloc(sizeof(Tk_PhotoImageFormat));
    *copyPtr = *formatPtr;
    copyPtr->name = (char *) ckalloc((unsigned) (strlen(formatPtr->name) + 1));
    strcpy(copyPtr->name, formatPtr->name);
    copyPtr->nextPtr = tsdPtr->oldFormatList;
    tsdPtr->oldFormatList = copyPtr;
}
a425 2
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
d431 2
a432 7
    if (isupper((unsigned char) *formatPtr->name)) {
	copyPtr->nextPtr = tsdPtr->oldFormatList;
	tsdPtr->oldFormatList = copyPtr;
    } else {
	copyPtr->nextPtr = tsdPtr->formatList;
	tsdPtr->formatList = copyPtr;
    }
d454 1
a454 1
ImgPhotoCreate(interp, name, objc, objv, typePtr, master, clientDataPtr)
d458 1
a458 1
    int objc;			/* Number of arguments. */
d488 1
a488 1
    if (ImgPhotoConfigureMaster(interp, masterPtr, objc, objv, 0) != TCL_OK) {
d516 1
a516 1
ImgPhotoCmd(clientData, interp, objc, objv)
d519 1
a519 1
    int objc;			/* Number of arguments. */
a521 10
    int oldformat = 0;
    static char *photoOptions[] = {
	"blank", "cget", "configure", "copy", "data", "get", "put",
	"read", "redither", "write", (char *) NULL
    };
    enum options {
	PHOTO_BLANK, PHOTO_CGET, PHOTO_CONFIGURE, PHOTO_COPY, PHOTO_DATA,
	PHOTO_GET, PHOTO_PUT, PHOTO_READ, PHOTO_REDITHER, PHOTO_WRITE
    };

d523 1
a523 1
    int result, index;
d533 1
d541 1
a541 2
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
d543 3
a545 2
    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "option ?arg arg ...?");
d549 7
a555 8
    if (Tcl_GetIndexFromObj(interp, objv[1], photoOptions, "option", 0,
	    &index) != TCL_OK) {
	Tcl_ObjCmdProc *proc;
	proc = PhotoOptionFind(interp, objv[1]);
	if (proc == (Tcl_ObjCmdProc *) NULL) {
	    return TCL_ERROR;
	}
	return proc(clientData, interp, objc, objv);
d557 4
a560 2
    switch ((enum options) index) {
      case PHOTO_BLANK: {
d565 1
a565 1
	if (objc == 2) {
d568 2
a569 1
	    Tcl_WrongNumArgs(interp, 2, objv, (char *) NULL);
d572 6
a577 6
	break;
      }
      case PHOTO_CGET: {
	char *arg;
	if (objc != 3) {
	    Tcl_WrongNumArgs(interp, 2, objv, "option");
d580 3
a582 10
	arg = Tcl_GetStringFromObj(objv[2], (int *) &length);
	if (strncmp(arg,"-data", length) == 0) {
	    if (masterPtr->dataString) {
		Tcl_SetObjResult(interp, masterPtr->dataString);
	    }
	    return TCL_OK;
	}
	if (strncmp(arg,"-format", length) == 0) {
	    if (masterPtr->format) {
		Tcl_SetObjResult(interp, masterPtr->format);
d587 3
a589 4
		(char *) masterPtr, Tcl_GetString(objv[2]), 0);
	break;
      }
      case PHOTO_CONFIGURE: {
d595 1
a595 2
	if (objc == 2) {
	    Tcl_Obj *obj, *subobj;
d601 7
a607 17
	    obj = Tcl_NewObj();
	    subobj = Tcl_NewStringObj("-data {} {} {}", 14);
	    if (masterPtr->dataString) {
		Tcl_ListObjAppendElement(interp, subobj, masterPtr->dataString);
	    } else {
		Tcl_AppendStringsToObj(subobj, " {}", (char *) NULL);
	    }
	    Tcl_ListObjAppendElement(interp, obj, subobj);
	    subobj = Tcl_NewStringObj("-format {} {} {}", 16);
	    if (masterPtr->format) {
		Tcl_ListObjAppendElement(interp, subobj, masterPtr->format);
	    } else {
		Tcl_AppendStringsToObj(subobj, " {}", (char *) NULL);
	    }
	    Tcl_ListObjAppendElement(interp, obj, subobj);
	    Tcl_ListObjAppendList(interp, obj, Tcl_GetObjResult(interp));
	    Tcl_SetObjResult(interp, obj);
d610 5
a614 3
	if (objc == 3) {
	  char *arg = Tcl_GetStringFromObj(objv[2], (int *) &length);
	  if (!strncmp(arg, "-data", length)) {
d616 2
a617 2
		"-data {} {} {}", (char *) NULL);
	    if (masterPtr->dataString) {
d619 1
a619 1
			masterPtr->dataString);
d622 1
a622 1
		" {}", (char *) NULL);
a624 14
	  } else if (!strncmp(arg, "-format", length)) {
	    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		"-format {} {} {}", (char *) NULL);
	    if (masterPtr->format) {
		Tcl_ListObjAppendElement(interp, Tcl_GetObjResult(interp),
			masterPtr->format);
	    } else {
		Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		" {}", (char *) NULL);
	    }
	    return TCL_OK;
	  } else {
	    return Tk_ConfigureInfo(interp, Tk_MainWindow(interp),
		    configSpecs, (char *) masterPtr, arg, 0);
d627 1
a627 1
	return ImgPhotoConfigureMaster(interp, masterPtr, objc-2, objv+2,
d629 2
a630 3
	break;
      }
      case PHOTO_COPY: {
d642 1
a642 1
		&index, objc, objv) != TCL_OK) {
d645 5
a649 3
	if (options.name == NULL || index < objc) {
	    Tcl_WrongNumArgs(interp, 2, objv,
		    "source-image ?-from x1 y1 x2 y2? ?-to x1 y1 x2 y2? ?-zoom x y? ?-subsample x y?");
d658 2
a659 3
	if ((srcHandle = Tk_FindPhoto(interp, Tcl_GetString(options.name))) == NULL) {
	    Tcl_AppendResult(interp, "image \"",
		    Tcl_GetString(options.name), "\" doesn't",
d725 2
a726 3
	break;
      }
      case PHOTO_DATA: {
d742 1
a742 1
		&index, objc, objv) != TCL_OK) {
d745 4
a748 2
	if ((options.name != NULL) || (index < objc)) {
	    Tcl_WrongNumArgs(interp, 2, objv, "?options?");
d774 1
a774 1
	    for (imageFormat = tsdPtr->formatList; imageFormat != NULL;
d776 2
a777 2
		if ((strncasecmp(Tcl_GetString(options.format),
			imageFormat->name, strlen(imageFormat->name)) == 0)) {
d785 1
a785 2
		Tcl_AppendResult(interp, "image string format \"",
			Tcl_GetString(options.format),
d799 1
d801 2
a802 3
	result =  ((int	(*) _ANSI_ARGS_((Tcl_Interp *interp, Tcl_Obj *formatString,
		Tk_PhotoImageBlock *blockPtr, VOID *dummy))) stringWriteProc)
		(interp, options.format, &block, (VOID *) NULL);
d809 5
d815 1
a815 3
	break;
      }
      case PHOTO_GET: {
d820 3
a822 4
	char string[TCL_INTEGER_SPACE * 3];

	if (objc != 4) {
	    Tcl_WrongNumArgs(interp, 2, objv, "x y");
d825 2
a826 2
	if ((Tcl_GetIntFromObj(interp, objv[2], &x) != TCL_OK)
		|| (Tcl_GetIntFromObj(interp, objv[3], &y) != TCL_OK)) {
d831 1
a831 1
	    Tcl_AppendResult(interp, Tcl_GetString(objv[0]), " get: ",
d844 1
a844 3
	break;
      }
      case PHOTO_PUT: {
d853 1
a853 1
	       &index, objc, objv) != TCL_OK) {
d856 4
a859 2
	if ((options.name == NULL) || (index < objc)) {
	    Tcl_WrongNumArgs(interp, 2, objv, "data ?options?");
d865 1
a865 3
		&imageHeight, &oldformat) == TCL_OK) {
	    Tcl_Obj *format;
	    Tcl_Obj *data;
d876 2
a877 10
	    format = options.format;
	    data = objv[2];
	    if (oldformat) {
		if (format) {
		    format = (Tcl_Obj *) Tcl_GetString(format);
		}
		data = (Tcl_Obj *) Tcl_GetString(data);
	    }
	    if ((*imageFormat->stringReadProc)(interp, data,
		    format, (Tk_PhotoHandle) masterPtr,
d889 1
a889 2
	if (Tcl_SplitList(interp, Tcl_GetString(options.name),
		&dataHeight, &srcArgv)
a957 1
	block.offset[3] = 0;
d962 2
a963 3
	break;
      }
      case PHOTO_READ: {
a967 1
	Tcl_Obj *format;
d974 1
a974 1
		&index, objc, objv) != TCL_OK) {
d977 5
a981 3
	if ((options.name == NULL) || (index < objc)) {
	    Tcl_WrongNumArgs(interp, 2, objv,
		    "fileName ?options?");
d999 1
a999 2
	chan = Tcl_OpenFileChannel(interp,
		Tcl_GetString(options.name), "r", 0);
d1007 2
a1008 8
        if (Tcl_SetChannelOption(interp, chan, "-encoding", "binary")
		!= TCL_OK) {
            return TCL_ERROR;
        }
    
	if (MatchFileFormat(interp, chan,
		Tcl_GetString(options.name), options.format,
		&imageFormat, &imageWidth, &imageHeight, &oldformat) != TCL_OK) {
d1047 2
a1048 7
	format = options.format;
	if (oldformat && format) {
	    format = (Tcl_Obj *) Tcl_GetString(format);
	}
	result = (*imageFormat->fileReadProc)(interp, chan,
		Tcl_GetString(options.name),
		format, (Tk_PhotoHandle) masterPtr, options.toX,
d1054 4
a1057 4
	break;
      }
      case PHOTO_REDITHER: {
	if (objc == 2) {
d1066 1
a1066 1
		Tk_DitherPhoto((Tk_PhotoHandle) masterPtr, x, y, masterPtr->width - x, 1);
d1070 1
a1070 1
		Tk_DitherPhoto((Tk_PhotoHandle)masterPtr, 0, masterPtr->ditherY, masterPtr->width,
d1085 2
a1086 1
	    Tcl_WrongNumArgs(interp, 2, objv, (char *) NULL);
d1089 1
a1089 3
	break;
      }
      case PHOTO_WRITE: {
a1090 2
	Tcl_Obj *format;

d1111 1
a1111 1
		&index, objc, objv) != TCL_OK) {
d1114 4
a1117 2
	if ((options.name == NULL) || (index < objc)) {
	    Tcl_WrongNumArgs(interp, 2, objv, "fileName ?options?");
d1144 1
a1144 14
	for (imageFormat = tsdPtr->formatList; imageFormat != NULL;
	     imageFormat = imageFormat->nextPtr) {
	    if ((options.format == NULL)
		    || (strncasecmp(Tcl_GetString(options.format),
		    imageFormat->name, strlen(imageFormat->name)) == 0)) {
		matched = 1;
		if (imageFormat->fileWriteProc != NULL) {
		    break;
		}
	    }
	}
	if (imageFormat == NULL) {
	  oldformat = 1;
	  for (imageFormat = tsdPtr->oldFormatList; imageFormat != NULL;
d1147 2
a1148 2
		    || (strncasecmp(Tcl_GetString(options.format),
		    imageFormat->name, strlen(imageFormat->name)) == 0)) {
a1153 1
	  }
d1161 1
a1161 2
			Tcl_GetString(options.format),
			"\" is unknown", (char *) NULL);
d1164 1
a1164 2
			Tcl_GetString(options.format),
			"\" has no file writing capability",
d1176 2
a1177 7
	format = options.format;
	if (oldformat && format) {
	    format = (Tcl_Obj *) Tcl_GetString(options.format);
	}
	result = (*imageFormat->fileWriteProc)(interp,
		Tcl_GetString(options.name),
		format, &block);
d1185 5
a1189 2
	break;
      }
d1214 1
a1214 1
ParseSubcommandOptions(optPtr, interp, allowedOptions, optIndexPtr, objc, objv)
d1222 1
a1222 1
				 * current index in objv; this variable is
d1224 2
a1225 2
    int objc;			/* Number of arguments in objv[]. */
    Tcl_Obj *CONST objv[];	/* Arguments to be parsed. */
d1228 1
a1228 1
    int length;
d1233 1
a1233 1
    for (index = *optIndexPtr; index < objc; *optIndexPtr = ++index) {
d1239 1
a1239 1
	option = Tcl_GetStringFromObj(objv[index], &length);
d1242 1
a1242 1
		optPtr->name = objv[index];
d1252 1
d1258 1
a1258 1
		    && (strncmp(option, *listPtr, (size_t) length) == 0)) {
d1274 1
a1274 2
	    Tcl_AppendResult(interp, "unrecognized option \"",
	    	    Tcl_GetString(objv[index]),
d1303 1
a1303 1
	    if (index + 1 < objc) {
d1306 1
a1306 1
			Tk_GetUid(Tcl_GetString(objv[index])));
d1320 1
a1320 1
	    if (index + 1 < objc) {
d1322 1
a1322 1
		optPtr->format = objv[index];
a1328 1
	    char *val;
d1332 4
a1335 7
		if (argIndex >= objc) {
		    break;
		}
	        val = Tcl_GetString(objv[argIndex]);
		if ((argIndex < objc) && (isdigit(UCHAR(val[0]))
			|| ((val[0] == '-') && isdigit(UCHAR(val[1]))))) {
		    if (Tcl_GetInt(interp, val, &values[numValues])
d1346 1
a1346 1
		Tcl_AppendResult(interp, "the \"", option, "\" option ",
d1445 1
a1445 1
 *	an error message is left in the masterPtr->interp's result.
d1455 1
a1455 1
ImgPhotoConfigureMaster(interp, masterPtr, objc, objv, flags)
d1459 1
a1459 1
    int objc;			/* Number of entries in objv. */
d1465 2
a1466 2
    char *oldFileString, *oldPaletteString;
    Tcl_Obj *oldData, *data = NULL, *oldFormat, *format = NULL;
d1473 11
a1483 20
    char **args;
    int oldformat;
    Tcl_Obj *tempdata, *tempformat;

    args = (char **) ckalloc((objc + 1) * sizeof(char *));
    for (i = 0, j = 0; i < objc; i++,j++) {
	args[j] = Tcl_GetStringFromObj(objv[i], &length);
	if ((length > 1) && (args[j][0] == '-')) {
	    if ((args[j][1] == 'd') &&
		    !strncmp(args[j],"-data", (size_t) length)) {
		if (i < objc) {
		    data = objv[++i];
		    j--;
		}
	    } else if ((args[j][1] == 'f') &&
		    !strncmp(args[j],"-format", (size_t) length)) {
		if (i < objc) {
		    format = objv[++i];
		    j--;
		}
a1486 1

d1497 1
a1497 1
    oldData = (oldFileString == NULL) ? masterPtr->dataString: NULL;
d1507 1
a1507 2
	    j, args, (char *) masterPtr, flags) != TCL_OK) {
	ckfree((char *) args);
a1509 1
    ckfree((char *) args);
d1520 3
a1522 5
    if (data) {
	if (data->length
		|| (data->typePtr == Tcl_GetObjType("bytearray")
			&& data->internalRep.otherValuePtr != NULL)) {
	    Tcl_IncrRefCount(data);
d1524 1
a1524 1
	    data = NULL;
d1526 2
a1527 2
	if (masterPtr->dataString) {
	    Tcl_DecrRefCount(masterPtr->dataString);
d1529 1
a1529 1
	masterPtr->dataString = data;
d1531 3
a1533 10
    if (format) {
	if (format->length) {
	    Tcl_IncrRefCount(format);
	} else {
	    format = NULL;
	}
	if (masterPtr->format) {
	    Tcl_DecrRefCount(masterPtr->format);
	}
	masterPtr->format = format;
d1535 1
a1569 4
        if (Tcl_SetChannelOption(interp, chan, "-encoding", "binary")
		!= TCL_OK) {
            return TCL_ERROR;
        }
d1572 1
a1572 1
		&imageHeight, &oldformat) != TCL_OK) {
a1576 4
	tempformat = masterPtr->format;
	if (oldformat && tempformat) {
	    tempformat = (Tcl_Obj *) Tcl_GetString(tempformat);
	}
d1578 1
a1578 1
		masterPtr->fileString, tempformat,
a1585 1
	Tcl_ResetResult(interp);
d1589 2
a1590 2
    if ((masterPtr->fileString == NULL) && (masterPtr->dataString != NULL)
	    && ((masterPtr->dataString != oldData)
d1593 1
a1593 1
	if (MatchStringFormat(interp, masterPtr->dataString, 
d1595 1
a1595 1
		&imageHeight, &oldformat) != TCL_OK) {
d1599 2
a1600 10
	tempformat = masterPtr->format;
	tempdata = masterPtr->dataString;
	if (oldformat) {
	    if (tempformat) {
		tempformat = (Tcl_Obj *) Tcl_GetString(tempformat);
	    }
	    tempdata = (Tcl_Obj *) Tcl_GetString(tempdata);
	}
	if ((*imageFormat->stringReadProc)(interp, tempdata,
		tempformat, (Tk_PhotoHandle) masterPtr,
a1604 1
	Tcl_ResetResult(interp);
d1817 1
a1817 1
    char buf[TCL_INTEGER_SPACE * 3];
d1958 3
a1960 2
    instancePtr->gc = Tk_GetGC(tkwin,
	    GCForeground|GCBackground|GCGraphicsExposures, &gcValues);
d2136 2
a2137 5
    if (masterPtr->dataString != NULL) {
	Tcl_DecrRefCount(masterPtr->dataString);
    }
    if (masterPtr->format != NULL) {
	Tcl_DecrRefCount(masterPtr->format);
d3228 2
a3229 2
MatchFileFormat(interp, chan, fileName, formatObj, imageFormatPtr,
	widthPtr, heightPtr, oldformat)
d3233 1
a3233 1
    Tcl_Obj *formatObj;		/* User-specified format string, or NULL. */
a3238 1
    int *oldformat;
a3240 1
    int useoldformat = 0;
a3241 7
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    char *formatString = NULL;

    if (formatObj) {
	formatString = Tcl_GetString(formatObj);
    }
d3249 1
a3249 1
    for (formatPtr = tsdPtr->formatList; formatPtr != NULL;
d3251 3
a3253 3
	if (formatObj != NULL) {
	    if (strncasecmp(formatString,
		    formatPtr->name, strlen(formatPtr->name)) != 0) {
d3266 2
a3267 2
	    if ((*formatPtr->fileMatchProc)(chan, fileName, formatObj,
		    widthPtr, heightPtr, interp)) {
a3277 31
    if (formatPtr == NULL) {
      useoldformat = 1;
      for (formatPtr = tsdPtr->oldFormatList; formatPtr != NULL;
	 formatPtr = formatPtr->nextPtr) {
	if (formatString != NULL) {
	    if (strncasecmp(formatString,
		    formatPtr->name, strlen(formatPtr->name)) != 0) {
		continue;
	    }
	    matched = 1;
	    if (formatPtr->fileMatchProc == NULL) {
		Tcl_AppendResult(interp, "-file option isn't supported for ",
			formatString, " images", (char *) NULL);
		return TCL_ERROR;
	    }
	}
	if (formatPtr->fileMatchProc != NULL) {
	    (void) Tcl_Seek(chan, 0L, SEEK_SET);
	    if ((*formatPtr->fileMatchProc)(chan, fileName, (Tcl_Obj *) formatString,
		    widthPtr, heightPtr, interp)) {
		if (*widthPtr < 1) {
		    *widthPtr = 1;
		}
		if (*heightPtr < 1) {
		    *heightPtr = 1;
		}
		break;
	    }
	}
      }
    }
d3280 2
a3281 3
	if ((formatObj != NULL) && !matched) {
	    Tcl_AppendResult(interp, "image file format \"",
		    formatString,
a3291 1
    *oldformat = useoldformat;
d3319 2
a3320 2
MatchStringFormat(interp, data, formatObj, imageFormatPtr,
	widthPtr, heightPtr, oldformat)
d3322 2
a3323 2
    Tcl_Obj *data;		/* Object containing the image data. */
    Tcl_Obj *formatObj;		/* User-specified format string, or NULL. */
a3328 1
    int *oldformat;		/* returns 1 if the old image API is used */
a3330 1
    int useoldformat = 0;
a3331 7
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    char *formatString = NULL;
    
    if (formatObj) {
	formatString = Tcl_GetString(formatObj);
    }
d3339 1
a3339 1
    for (formatPtr = tsdPtr->formatList; formatPtr != NULL;
d3341 3
a3343 3
	if (formatObj != NULL) {
	    if (strncasecmp(formatString,
		    formatPtr->name, strlen(formatPtr->name)) != 0) {
d3355 2
a3356 2
		&& (*formatPtr->stringMatchProc)(data, formatObj,
		widthPtr, heightPtr, interp)) {
d3362 2
a3363 28
      useoldformat = 1;
      for (formatPtr = tsdPtr->oldFormatList; formatPtr != NULL;
	    formatPtr = formatPtr->nextPtr) {
	if (formatObj != NULL) {
	    if (strncasecmp(formatString,
		    formatPtr->name, strlen(formatPtr->name)) != 0) {
		continue;
	    }
	    matched = 1;
	    if (formatPtr->stringMatchProc == NULL) {
		Tcl_AppendResult(interp, "-data option isn't supported for ",
			formatString, " images", (char *) NULL);
		return TCL_ERROR;
	    }
	}
	if ((formatPtr->stringMatchProc != NULL)
		&& (formatPtr->stringReadProc != NULL)
		&& (*formatPtr->stringMatchProc)((Tcl_Obj *) Tcl_GetString(data),
			(Tcl_Obj *) formatString,
		widthPtr, heightPtr, interp)) {
	    break;
	}
      }	
    }
    if (formatPtr == NULL) {
	if ((formatObj != NULL) && !matched) {
	    Tcl_AppendResult(interp, "image format \"",
		    formatString,
a3372 1
    *oldformat = useoldformat;
d3485 7
a3491 2
    alphaOffset = blockPtr->offset[3];
    if ((alphaOffset >= blockPtr->pixelSize) || (alphaOffset < 0)) {
d3508 1
a3508 7
    /*
     * This test is probably too restrictive.  We should also be able to
     * do a memcpy if pixelSize == 3 and alphaOffset == 0.  Maybe other cases
     * too.
     */
    if ((blockPtr->pixelSize == 4)
	    && (greenOffset == 1) && (blueOffset == 2) && (alphaOffset == 3)
a3526 4
		      if (!destPtr[3]) {
			destPtr[0] = destPtr[1] = destPtr[2] = 0xd9;
		      }
		      if (!alphaOffset || (srcPtr[alphaOffset] == 255)) {
d3530 2
a3531 11
			*destPtr++ = 255;
		      } else {
			if (srcPtr[alphaOffset]) {
			    destPtr[0] += (srcPtr[0] - destPtr[0]) * srcPtr[alphaOffset] / 255;
			    destPtr[1] += (srcPtr[greenOffset] - destPtr[1]) * srcPtr[alphaOffset] / 255;
			    destPtr[2] += (srcPtr[blueOffset] - destPtr[2]) * srcPtr[alphaOffset] / 255;
			    destPtr[3] += (255 - destPtr[3]) * srcPtr[alphaOffset] / 255;
		  	}
			destPtr+=4;
		      }
		      srcPtr += blockPtr->pixelSize;
a3543 48
  if (alphaOffset) {
    int x1, y1, end;
    
    /*
     * This block is grossly inefficient.  For each row in the image, it
     * finds each continguous string of transparent pixels, then marks those
     * areas as invalid in the validRegion mask.  This makes drawing very
     * efficient, because of the way we use X:  we just say, here's your
     * mask, and here's your data.  We need not worry about the current
     * background color, etc.  But this costs us a lot on the image setup.
     * Still, image setup only happens once, whereas the drawing happens
     * many times, so this might be the best way to go.
     *
     * An alternative might be to not set up this mask, and instead, at
     * drawing time, for each transparent pixel, set its color to the
     * color of the background behind that pixel.  This is what I suspect
     * most of programs do.  However, they don't have to deal with the canvas,
     * which could have many different background colors.  Determining the
     * correct bg color for a given pixel might be expensive.
     */
     
    destLinePtr = masterPtr->pix24 + (y * masterPtr->width + x) * 4 + 3;
    for (y1 = 0; y1 < height; y1++) {
	x1 = 0;
	destPtr = destLinePtr;
	while (x1 < width) {
	    /* search for first non-transparent pixel */
	    while ((x1 < width) && !*destPtr) {
		    x1++; destPtr += 4;
	    }
	    end = x1;
	    /* search for first transparent pixel */
	    while ((end < width) && *destPtr) {
	        end++; destPtr += 4;
	    }
	    if (end > x1) {
		rect.x = x + x1;
		rect.y = y + y1;
		rect.width = end - x1;
		rect.height = 1;
		TkUnionRectWithRegion(&rect, masterPtr->validRegion,
			masterPtr->validRegion);
	    }
	    x1 = end;
	}
	destLinePtr += masterPtr->width * 4;
    }
  } else {
a3549 1
  }
d3555 1
a3555 1
    Tk_DitherPhoto((Tk_PhotoHandle)masterPtr, x, y, width, height);
d3659 7
a3665 2
    alphaOffset = blockPtr->offset[3];
    if ((alphaOffset >= blockPtr->pixelSize) || (alphaOffset < 0)) {
a3720 4
		      if (!destPtr[3]) {
			destPtr[0] = destPtr[1] = destPtr[2] = 0xd9;
		      }
		      if (!alphaOffset || (srcPtr[alphaOffset] == 255)) {
d3724 1
a3724 10
			*destPtr++ = 255;
		      } else {
			if (srcPtr[alphaOffset]) {
			    destPtr[0] += (srcPtr[0] - destPtr[0]) * srcPtr[alphaOffset] / 255;
			    destPtr[1] += (srcPtr[greenOffset] - destPtr[1]) * srcPtr[alphaOffset] / 255;
			    destPtr[2] += (srcPtr[blueOffset] - destPtr[2]) * srcPtr[alphaOffset] / 255;
			    destPtr[3] += (255 - destPtr[3]) * srcPtr[alphaOffset] / 255;
		  	}
			destPtr+=4;
		      }
a3741 30
  if (alphaOffset) {
    int x1, y1, end;

    destLinePtr = masterPtr->pix24 + (y * masterPtr->width + x) * 4 + 3;
    for (y1 = 0; y1 < height; y1++) {
	x1 = 0;
	destPtr = destLinePtr;
	while (x1 < width) {
	    /* search for first non-transparent pixel */
	    while ((x1 < width) && !*destPtr) {
		    x1++; destPtr += 4;
	    }
	    end = x1;
	    /* search for first transparent pixel */
	    while ((end < width) && *destPtr) {
	        end++; destPtr += 4;
	    }
	    if (end > x1) {
		rect.x = x + x1;
		rect.y = y + y1;
		rect.width = end - x1;
		rect.height = 1;
		TkUnionRectWithRegion(&rect, masterPtr->validRegion,
			masterPtr->validRegion);
	    }
	    x1 = end;
	}
	destLinePtr += masterPtr->width * 4;
    }
  } else {
a3747 1
  }
d3753 1
a3753 1
    Tk_DitherPhoto((Tk_PhotoHandle)masterPtr, x, y, width, height);
d3766 1
a3766 1
 * Tk_DitherPhoto --
d3782 3
a3784 3
void
Tk_DitherPhoto(photo, x, y, width, height)
    Tk_PhotoHandle photo;	/* Image master whose instances are
a3789 1
    PhotoMaster *masterPtr = (PhotoMaster *) photo;
d4434 1
a4434 2
	data = ckalloc((unsigned int) (newPixelSize *
		blockPtr->width * blockPtr->height));
d4549 1
a4549 1
ImgStringWrite(interp, formatString, blockPtr)
d4551 2
a4552 1
    Tcl_Obj *formatString;
a4558 1
    Tcl_DString data;
a4562 1
    Tcl_DStringInit(&data);
d4564 1
a4564 1
	line = (char *) ckalloc((unsigned int) ((8 * blockPtr->width) + 2));
d4575 1
a4575 1
	    Tcl_DStringAppendElement(&data, line+1);
a4578 1
    Tcl_DStringResult(interp, &data);
a4620 1
    blockPtr->offset[3] = 3;
a4622 183

/*
 *----------------------------------------------------------------------
 *
 * PhotoOptionFind --
 *
 *	Finds a specific Photo option.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	After commands are removed.
 *
 *----------------------------------------------------------------------
 */

typedef struct OptionAssocData {
    struct OptionAssocData *nextPtr;	/* pointer to next OptionAssocData */
    Tcl_ObjCmdProc *command;		/* command associated with this
					 * option */
    char name[1];			/* name of option (remaining chars) */
} OptionAssocData;

static Tcl_ObjCmdProc *
PhotoOptionFind(interp, obj)
    Tcl_Interp *interp;		/* Interpreter that is being deleted. */
    Tcl_Obj *obj;			/* Name of option to be found. */
{
    size_t length;
    char *name = Tcl_GetStringFromObj(obj, (int *) &length);
    OptionAssocData *list;
    char *prevname = NULL;
    Tcl_ObjCmdProc *proc = (Tcl_ObjCmdProc *) NULL;
    list = (OptionAssocData *) Tcl_GetAssocData(interp, "photoOption",
	    (Tcl_InterpDeleteProc **) NULL);
    while (list != (OptionAssocData *) NULL) {
	if (strncmp(name, list->name, length) == 0) {
	    if (proc != (Tcl_ObjCmdProc *) NULL) {
		Tcl_ResetResult(interp);
		Tcl_AppendResult(interp, "ambiguous option \"", name,
			"\": must be ", prevname, (char *) NULL);
		while (list->nextPtr != (OptionAssocData *) NULL) {
		    Tcl_AppendResult(interp, prevname, ", ",(char *) NULL);
		    list = list->nextPtr;
		    prevname = list->name;
		}
		Tcl_AppendResult(interp, ", or", prevname, (char *) NULL);
		return (Tcl_ObjCmdProc *) NULL;
	    }
	    proc = list->command;
	    prevname = list->name;
	}
	list = list->nextPtr;
    }
    if (proc != (Tcl_ObjCmdProc *) NULL) {
	Tcl_ResetResult(interp);
    }
    return proc;
}

/*
 *----------------------------------------------------------------------
 *
 * PhotoOptionCleanupProc --
 *
 *	This procedure is invoked whenever an interpreter is deleted
 *	to cleanup the AssocData for "photoVisitor".
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Photo Visitor options are removed.
 *
 *----------------------------------------------------------------------
 */

static void
PhotoOptionCleanupProc(clientData, interp)
    ClientData clientData;	/* Points to "photoVisitor" AssocData
				 * for the interpreter. */
    Tcl_Interp *interp;		/* Interpreter that is being deleted. */
{
    OptionAssocData *list = (OptionAssocData *) clientData;
    OptionAssocData *ptr;

    while (list != NULL) {
	list = (ptr = list)->nextPtr;
	ckfree((char *) ptr);
    }
}

/*
 *--------------------------------------------------------------
 *
 * Tk_CreatePhotoOption --
 *
 *	This procedure may be invoked to add a new kind of photo
 *	option to the core photo command supported by Tk.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	From now on, the new option will be useable by the
 *	photo command.
 *
 *--------------------------------------------------------------
 */

void
Tk_CreatePhotoOption(interp, name, proc)
    Tcl_Interp *interp;			/* interpreter */
    CONST char *name;			/* option name */
    Tcl_ObjCmdProc *proc;		/* proc to execute command */
{
    OptionAssocData *typePtr2, *prevPtr, *ptr;
    OptionAssocData *list;

    list = (OptionAssocData *) Tcl_GetAssocData(interp, "photoOption",
	    (Tcl_InterpDeleteProc **) NULL);

    /*
     * If there's already a photo option with the given name, remove it.
     */

    for (typePtr2 = list, prevPtr = NULL; typePtr2 != NULL;
	    prevPtr = typePtr2, typePtr2 = typePtr2->nextPtr) {
	if (strcmp(typePtr2->name, name) == 0) {
	    if (prevPtr == NULL) {
		list = typePtr2->nextPtr;
	    } else {
		prevPtr->nextPtr = typePtr2->nextPtr;
	    }
	    ckfree((char *) typePtr2);
	    break;
	}
    }
    ptr = (OptionAssocData *) ckalloc(sizeof(OptionAssocData) + strlen(name));
    strcpy(&(ptr->name[0]), name);
    ptr->command = proc;
    ptr->nextPtr = list;
    Tcl_SetAssocData(interp, "photoOption", PhotoOptionCleanupProc,
		(ClientData) ptr);
}

/*
 *--------------------------------------------------------------
 *
 * TkPostscriptPhoto --
 *
 *	This procedure is called to output the contents of a
 *	photo image in Postscript by calling the Tk_PostscriptPhoto
 *	function.
 *
 * Results:
 *	Returns a standard Tcl return value.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */
static int
ImgPhotoPostscript(clientData, interp, tkwin, psInfo,
        x, y, width, height, prepass)
    ClientData clientData;
    Tcl_Interp *interp;
    Tk_Window tkwin;
    Tk_PostscriptInfo psInfo; /* postscript info */
    int x, y;   /* First pixel to output */
    int width, height;  /* Width and height of area */
    int prepass;
{
    Tk_PhotoImageBlock block;

    Tk_PhotoGetImage((Tk_PhotoHandle) clientData, &block);
    block.pixelPtr += y * block.pitch + x * block.pixelSize;

    return Tk_PostscriptPhoto(interp, &block, psInfo, width, height);
}

@


1.1.1.3
log
@import tk 8.4.0
@
text
@a9 1
 * Copyright (c) 2002 Donal K. Fellows
d18 1
a18 1
 * RCS: @@(#) $Id: tkImgPhoto.c,v 1.34 2002/08/05 04:30:39 dgp Exp $
a233 1
    int compositingRule;	/* Value specified for -compositingrule opt */
a243 1
 * OPT_COMPOSITE:		Set if -compositingrule option allowed/spec'd.
d254 7
a260 8
#define OPT_COMPOSITE	2
#define OPT_FORMAT	4
#define OPT_FROM	8
#define OPT_GRAYSCALE	0x10
#define OPT_SHRINK	0x20
#define OPT_SUBSAMPLE	0x40
#define OPT_TO		0x80
#define OPT_ZOOM	0x100
a268 1
    "-compositingrule",
d280 1
a280 8
 * Message to generate when an attempt to resize an image fails due
 * to memory problems.
 */
#define TK_PHOTO_ALLOC_FAILURE_MESSAGE \
	"not enough free memory for image buffer"

/*
 * Functions used in the type record for photo images.
a300 4
/*
 * The type record itself for photo images:
 */

a316 1
    int initialized;	/* set to 1 if we've initialized the strucuture */
a359 2
static void		PhotoFormatThreadExitProc _ANSI_ARGS_((
			    ClientData clientData));
d373 1
a373 1
static int		ImgPhotoSetSize _ANSI_ARGS_((PhotoMaster *masterPtr,
d384 1
a384 1
			    CONST char *palette));
a432 42

static void
PhotoFormatThreadExitProc(clientData)
    ClientData clientData;	/* not used */
{
    Tk_PhotoImageFormat *freePtr;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    while (tsdPtr->oldFormatList != NULL) {
	freePtr = tsdPtr->oldFormatList;
	tsdPtr->oldFormatList = tsdPtr->oldFormatList->nextPtr;
	ckfree((char *) freePtr->name);
	ckfree((char *) freePtr);
    }
    while (tsdPtr->formatList != NULL) {
	freePtr = tsdPtr->formatList;
	tsdPtr->formatList = tsdPtr->formatList->nextPtr;
	ckfree((char *) freePtr->name);
	ckfree((char *) freePtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_CreateOldPhotoImageFormat, Tk_CreatePhotoImageFormat --
 *
 *	This procedure is invoked by an image file handler to register
 *	a new photo image format and the procedures that handle the
 *	new format.  The procedure is typically invoked during
 *	Tcl_AppInit.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The new image file format is entered into a table used in the
 *	photo image "read" and "write" subcommands.
 *
 *----------------------------------------------------------------------
 */
a444 4
    if (!tsdPtr->initialized) {
	tsdPtr->initialized = 1;
	Tcl_CreateThreadExitHandler(PhotoFormatThreadExitProc, NULL);
    }
a464 4
    if (!tsdPtr->initialized) {
	tsdPtr->initialized = 1;
	Tcl_CreateThreadExitHandler(PhotoFormatThreadExitProc, NULL);
    }
d566 1
a566 1
    static CONST char *photoOptions[] = {
d568 1
a568 1
	"read", "redither", "transparency", "write", (char *) NULL
d572 1
a572 2
	PHOTO_GET, PHOTO_PUT, PHOTO_READ, PHOTO_REDITHER, PHOTO_TRANS,
	PHOTO_WRITE
d581 2
a582 2
    CONST char **listArgv;
    CONST char **srcArgv;
a609 1

d611 1
a611 1
    case PHOTO_BLANK:
d623 2
a624 2

    case PHOTO_CGET: {
a625 1

d646 2
a647 3
    }

    case PHOTO_CONFIGURE:
d651 1
d680 8
a687 2
	    char *arg = Tcl_GetStringFromObj(objv[2], (int *) &length);
	    if (!strncmp(arg, "-data", length)) {
d689 10
a698 10
			"-data {} {} {}", (char *) NULL);
		if (masterPtr->dataString) {
		    Tcl_ListObjAppendElement(interp, Tcl_GetObjResult(interp),
			    masterPtr->dataString);
		} else {
		    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
			    " {}", (char *) NULL);
		}
		return TCL_OK;
	    } else if (!strncmp(arg, "-format", length)) {
d700 1
a700 12
			"-format {} {} {}", (char *) NULL);
		if (masterPtr->format) {
		    Tcl_ListObjAppendElement(interp, Tcl_GetObjResult(interp),
			    masterPtr->format);
		} else {
		    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
			    " {}", (char *) NULL);
		}
		return TCL_OK;
	    } else {
		return Tk_ConfigureInfo(interp, Tk_MainWindow(interp),
			configSpecs, (char *) masterPtr, arg, 0);
d702 5
d710 3
a712 2

    case PHOTO_COPY:
a721 1
	options.compositingRule = TK_PHOTO_COMPOSITE_OVERLAY;
d723 2
a724 2
		OPT_FROM | OPT_TO | OPT_ZOOM | OPT_SUBSAMPLE | OPT_SHRINK |
		OPT_COMPOSITE, &index, objc, objv) != TCL_OK) {
d729 1
a729 1
		    "source-image ?-compositingrule rule? ?-from x1 y1 x2 y2? ?-to x1 y1 x2 y2? ?-zoom x y? ?-subsample x y?");
d738 1
a738 2
	srcHandle = Tk_FindPhoto(interp, Tcl_GetString(options.name));
	if (srcHandle == NULL) {
d757 1
a757 1
	if (!(options.options & OPT_FROM) || (options.fromX2 < 0)) {
d761 1
a761 1
	if (!(options.options & OPT_TO) || (options.toX2 < 0)) {
d790 1
a790 7
	    if (ImgPhotoSetSize(masterPtr, options.toX2,
		    options.toY2) != TCL_OK) {
		Tcl_ResetResult(interp);
		Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
			TK_PHOTO_ALLOC_FAILURE_MESSAGE, (char *) NULL);
		return TCL_ERROR;
	    }
d798 1
a798 1
		+ options.fromY * block.pitch;
d804 1
a804 2
		options.subsampleX, options.subsampleY,
		options.compositingRule);
d807 2
a808 2

    case PHOTO_DATA: {
d881 1
a881 1
	result = ((int (*) _ANSI_ARGS_((Tcl_Interp *interp, Tcl_Obj *formatString,
d892 2
a893 3
    }

    case PHOTO_GET: {
d924 2
a925 3
    }

    case PHOTO_PUT:
d934 1
a934 1
		&index, objc, objv) != TCL_OK) {
d945 2
a946 2
	    Tcl_Obj *format, *data;

d967 2
a968 2
		    options.toX, options.toY, imageWidth, imageHeight,
		    0, 0) != TCL_OK) {
d979 2
a980 1
		&dataHeight, &srcArgv) != TCL_OK) {
d994 2
a995 2
		pixelPtr = (unsigned char *)
			ckalloc((unsigned) dataWidth * dataHeight * 3);
d997 8
a1004 5
	    } else if (listArgc != dataWidth) {
		Tcl_AppendResult(interp, "all elements of color list must",
			" have the same number of elements", (char *) NULL);
		ckfree((char *) listArgv);
		break;
d1018 1
a1018 1
	    if (x < dataWidth) {
a1019 1
	    }
d1037 1
a1037 1
	if (!(options.options & OPT_TO) || (options.toX2 < 0)) {
d1051 1
a1051 1
		options.toY2 - options.toY, TK_PHOTO_COMPOSITE_SET);
d1054 2
a1055 4

    case PHOTO_READ: {
	Tcl_Obj *format;

d1060 1
d1071 2
a1072 1
	    Tcl_WrongNumArgs(interp, 2, objv, "fileName ?options?");
d1082 1
a1082 1
		    " safe interpreter", (char *) NULL);
a1096 1
	    Tcl_Close(NULL, chan);
a1100 1
	    Tcl_Close(NULL, chan);
d1105 2
a1106 2
		Tcl_GetString(options.name), options.format, &imageFormat,
		&imageWidth, &imageHeight, &oldformat) != TCL_OK) {
d1136 2
a1137 7
	    if (ImgPhotoSetSize(masterPtr, options.toX + width,
		    options.toY + height) != TCL_OK) {
		Tcl_ResetResult(interp);
		Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
			TK_PHOTO_ALLOC_FAILURE_MESSAGE, (char *) NULL);
		return TCL_ERROR;
	    }
d1158 3
a1160 27
    }

    case PHOTO_REDITHER:
	if (objc != 2) {
	    Tcl_WrongNumArgs(interp, 2, objv, (char *) NULL);
	    return TCL_ERROR;
	}

	/*
	 * Call Dither if any part of the image is not correctly
	 * dithered at present.
	 */

	x = masterPtr->ditherX;
	y = masterPtr->ditherY;
	if (masterPtr->ditherX != 0) {
	    Tk_DitherPhoto((Tk_PhotoHandle) masterPtr, x, y,
		    masterPtr->width - x, 1);
	}
	if (masterPtr->ditherY < masterPtr->height) {
	    x = 0;
	    Tk_DitherPhoto((Tk_PhotoHandle)masterPtr, 0,
		    masterPtr->ditherY, masterPtr->width,
		    masterPtr->height - masterPtr->ditherY);
	}

	if (y < masterPtr->height) {
d1162 2
a1163 1
	     * Tell the core image code that part of the image has changed.
d1166 9
a1174 67
	    Tk_ImageChanged(masterPtr->tkMaster, x, y,
		    (masterPtr->width - x), (masterPtr->height - y),
		    masterPtr->width, masterPtr->height);
	}
	break;

    case PHOTO_TRANS: {
	static CONST char *photoTransOptions[] = {
	    "get", "set", (char *) NULL
	};
	enum transOptions {
	    PHOTO_TRANS_GET, PHOTO_TRANS_SET
	};

	if (objc < 3) {
	    Tcl_WrongNumArgs(interp, 2, objv, "option ?arg arg ...?");
	    return TCL_ERROR;
	}
	if (Tcl_GetIndexFromObj(interp, objv[2], photoTransOptions, "option",
		0, &index) != TCL_OK) {
	    return TCL_ERROR;
	}

	switch ((enum transOptions) index) {
	case PHOTO_TRANS_GET: {
	    XRectangle testBox;
	    TkRegion testRegion;

	    if (objc != 5) {
		Tcl_WrongNumArgs(interp, 3, objv, "x y");
		return TCL_ERROR;
	    }
	    if ((Tcl_GetIntFromObj(interp, objv[3], &x) != TCL_OK)
		    || (Tcl_GetIntFromObj(interp, objv[4], &y) != TCL_OK)) {
		return TCL_ERROR;
	    }
	    if ((x < 0) || (x >= masterPtr->width)
		|| (y < 0) || (y >= masterPtr->height)) {
		Tcl_AppendResult(interp, Tcl_GetString(objv[0]),
			" transparency get: coordinates out of range",
			(char *) NULL);
		return TCL_ERROR;
	    }

	    testBox.x = x;
	    testBox.y = y;
	    testBox.width = 1;
	    testBox.height = 1;
	    /* What a way to do a test! */
	    testRegion = TkCreateRegion();
	    TkUnionRectWithRegion(&testBox, testRegion, testRegion);
	    TkIntersectRegion(testRegion, masterPtr->validRegion, testRegion);
	    TkClipBox(testRegion, &testBox);
	    TkDestroyRegion(testRegion);

	    Tcl_SetBooleanObj(Tcl_GetObjResult(interp),
		    (testBox.width==0 && testBox.height==0));
	    return TCL_OK;
	}

	case PHOTO_TRANS_SET: {
	    int transFlag;
	    XRectangle setBox;

	    if (objc != 6) {
		Tcl_WrongNumArgs(interp, 3, objv, "x y boolean");
		return TCL_ERROR;
a1175 19
	    if ((Tcl_GetIntFromObj(interp, objv[3], &x) != TCL_OK)
		    || (Tcl_GetIntFromObj(interp, objv[4], &y) != TCL_OK)
		    || (Tcl_GetBooleanFromObj(interp, objv[5],
		    &transFlag) != TCL_OK)) {
		return TCL_ERROR;
	    }
	    if ((x < 0) || (x >= masterPtr->width)
		|| (y < 0) || (y >= masterPtr->height)) {
		Tcl_AppendResult(interp, Tcl_GetString(objv[0]),
			" transparency set: coordinates out of range",
			(char *) NULL);
		return TCL_ERROR;
	    }

	    setBox.x = x;
	    setBox.y = y;
	    setBox.width = 1;
	    setBox.height = 1;
	    pixelPtr = masterPtr->pix24 + (y * masterPtr->width + x) * 4;
d1177 1
a1177 1
	    if (transFlag) {
d1179 1
a1179 1
		 * Make pixel transparent.
a1180 1
		TkRegion clearRegion = TkCreateRegion();
d1182 3
a1184 15
		TkUnionRectWithRegion(&setBox, clearRegion, clearRegion);
		TkSubtractRegion(masterPtr->validRegion, clearRegion,
			masterPtr->validRegion);
		TkDestroyRegion(clearRegion);
		/*
		 * Set the alpha value correctly.
		 */
		pixelPtr[3] = 0;
	    } else {
		/*
		 * Make pixel opaque.
		 */
		TkUnionRectWithRegion(&setBox, masterPtr->validRegion,
			masterPtr->validRegion);
		pixelPtr[3] = 255;
d1187 3
a1189 8
	    /*
	     * Inform the generic image code that the image
	     * has (potentially) changed.
	     */

	    Tk_ImageChanged(masterPtr->tkMaster, x, y, 1, 1,
		    masterPtr->width, masterPtr->height);
	    masterPtr->flags &= ~IMAGE_CHANGED;
d1191 3
a1193 6

	}
	return TCL_OK;
    }

    case PHOTO_WRITE: {
d1203 1
a1203 1
		    " safe interpreter", (char *) NULL);
d1237 1
a1237 1
	if (!(options.options & OPT_FROM) || (options.fromX2 < 0)) {
d1249 1
a1249 1
		imageFormat = imageFormat->nextPtr) {
d1260 9
a1268 10
	    oldformat = 1;
	    for (imageFormat = tsdPtr->oldFormatList; imageFormat != NULL;
		    imageFormat = imageFormat->nextPtr) {
		if ((options.format == NULL)
			|| (strncasecmp(Tcl_GetString(options.format),
			imageFormat->name, strlen(imageFormat->name)) == 0)) {
		    matched = 1;
		    if (imageFormat->fileWriteProc != NULL) {
			break;
		    }
d1271 1
d1301 2
a1302 1
		Tcl_GetString(options.name), format, &block);
d1310 2
a1313 1
    }
d1324 1
a1324 2
 *	namely, -from, -to, -zoom, -subsample, -format, -shrink,
 *	and -compositingrule.
d1439 1
a1439 3
	     * The -format option takes a single string value.  Note
	     * that parsing this is outside the scope of this
	     * function.
a1449 28
	} else if (bit == OPT_COMPOSITE) {
	    /*
	     * The -compositingrule option takes a single value from
	     * a well-known set.
	     */

	    if (index + 1 < objc) {
		/*
		 * Note that these must match the TK_PHOTO_COMPOSITE_*
		 * constants.
		 */
		static CONST char *compositingRules[] = {
		    "overlay", "set",
		    NULL
		};

		index++;
		if (Tcl_GetIndexFromObj(interp, objv[index], compositingRules,
			"compositing rule", 0, &optPtr->compositingRule)
			!= TCL_OK) {
		    return TCL_ERROR;
		}
		*optIndexPtr = index;
	    } else {
		Tcl_AppendResult(interp, "the \"-compositingrule\" option ",
			"requires a value", (char *) NULL);
		return TCL_ERROR;
	    }
d1591 1
a1591 1
    CONST char *oldFileString, *oldPaletteString;
d1599 1
a1599 1
    CONST char **args;
d1603 1
a1603 1
    args = (CONST char **) ckalloc((objc + 1) * sizeof(char *));
d1633 1
a1633 8
    if (oldFileString == NULL) {
	oldData = masterPtr->dataString;
	if (oldData != NULL) {
	    Tcl_IncrRefCount(oldData);
	}
    } else {
	oldData = NULL;
    }
a1634 3
    if (oldFormat != NULL) {
	Tcl_IncrRefCount(oldFormat);
    }
d1645 1
a1645 1
	goto errorExit;
d1687 1
a1687 7
    if (ImgPhotoSetSize(masterPtr, masterPtr->width,
	    masterPtr->height) != TCL_OK) {
	Tcl_ResetResult(interp);
	Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		TK_PHOTO_ALLOC_FAILURE_MESSAGE, (char *) NULL);
	goto errorExit;
    }
d1703 3
a1705 5
	    Tcl_ResetResult(interp);
            Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		    "can't get image from a file in a safe interpreter",
		    (char *) NULL);
	    goto errorExit;
d1710 1
a1710 1
	    goto errorExit;
d1712 11
a1722 8
	/*
	 * -translation binary also sets -encoding binary
	 */
        if ((Tcl_SetChannelOption(interp, chan,
		"-translation", "binary") != TCL_OK) ||
		(MatchFileFormat(interp, chan, masterPtr->fileString,
			masterPtr->format, &imageFormat, &imageWidth,
			&imageHeight, &oldformat) != TCL_OK)) {
d1724 1
a1724 9
	    goto errorExit;
	}
	result = ImgPhotoSetSize(masterPtr, imageWidth, imageHeight);
	if (result != TCL_OK) {
	    Tcl_Close(NULL, chan);
	    Tcl_ResetResult(interp);
	    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		    TK_PHOTO_ALLOC_FAILURE_MESSAGE, (char *) NULL);
	    goto errorExit;
d1726 1
d1737 1
a1737 1
	    goto errorExit;
d1746 1
a1746 1
		    || (masterPtr->format != oldFormat))) {
d1748 1
a1748 1
	if (MatchStringFormat(interp, masterPtr->dataString,
d1751 1
a1751 7
	    goto errorExit;
	}
	if (ImgPhotoSetSize(masterPtr, imageWidth, imageHeight) != TCL_OK) {
	    Tcl_ResetResult(interp);
	    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		    TK_PHOTO_ALLOC_FAILURE_MESSAGE, (char *) NULL);
	    goto errorExit;
d1753 1
d1765 1
a1765 1
	    goto errorExit;
a1804 6
    if (oldData != NULL) {
	Tcl_DecrRefCount(oldData);
    }
    if (oldFormat != NULL) {
	Tcl_DecrRefCount(oldFormat);
    }
a1805 9

  errorExit:
    if (oldData != NULL) {
	Tcl_DecrRefCount(oldData);
    }
    if (oldFormat != NULL) {
	Tcl_DecrRefCount(oldFormat);
    }
    return TCL_ERROR;
a1902 2
	     *
	     * Can't we use autoconf to figure this out?
d1980 1
a2123 1

a2125 1
     * This will also dither the image if necessary.
d2139 10
d2349 1
a2349 2
 *	TCL_OK if successful, TCL_ERROR if failure occurred (currently
 *	just with memory allocation.)
d2357 1
a2357 1
static int
d2362 1
a2362 1
    unsigned char *newPix24 = NULL;
a2375 15
    pitch = width * 4;

    /*
     * Test if we're going to (re)allocate the main buffer now, so
     * that any failures will leave the photo unchanged.
     */
    if ((width != masterPtr->width) || (height != masterPtr->height)
	    || (masterPtr->pix24 == NULL)) {
	newPix24 = (unsigned char *)
		attemptckalloc((unsigned) (height * pitch));
	if (newPix24 == NULL) {
	    return TCL_ERROR;
	}
    }

d2396 11
a2406 6
    /*
     * Use the reallocated storage (allocation above) for the 24-bit
     * image and copy over valid regions.  Note that this test is true
     * precisely when the allocation has already been done.
     */
    if (newPix24 != NULL) {
d2482 6
a2487 4
	} else if ((masterPtr->ditherY > 0)
		|| ((int) validBox.width < masterPtr->ditherX)) {
	    masterPtr->ditherX = validBox.width;
	    masterPtr->ditherY = 0;
a2498 2

    return TCL_OK;
a2542 4
        if (!newPixmap) {
            panic("Fail to create pixmap with Tk_GetPixmap in ImgPhotoInstanceSetSize.\n");
            return;
        }
d2657 1
a2657 1
    CONST char *palette;		/* Palette specification string. */
d2935 1
d3439 1
a3439 1
	    (void) Tcl_Seek(chan, Tcl_LongAsWide(0L), SEEK_SET);
d3454 21
a3474 7
	useoldformat = 1;
	for (formatPtr = tsdPtr->oldFormatList; formatPtr != NULL;
		formatPtr = formatPtr->nextPtr) {
	    if (formatString != NULL) {
		if (strncasecmp(formatString,
			formatPtr->name, strlen(formatPtr->name)) != 0) {
		    continue;
d3476 2
a3477 18
		matched = 1;
		if (formatPtr->fileMatchProc == NULL) {
		    Tcl_AppendResult(interp, "-file option isn't supported",
			    " for ", formatString, " images", (char *) NULL);
		    return TCL_ERROR;
		}
	    }
	    if (formatPtr->fileMatchProc != NULL) {
		(void) Tcl_Seek(chan, Tcl_LongAsWide(0L), SEEK_SET);
		if ((*formatPtr->fileMatchProc)(chan, fileName, (Tcl_Obj *)
			formatString, widthPtr, heightPtr, interp)) {
		    if (*widthPtr < 1) {
			*widthPtr = 1;
		    }
		    if (*heightPtr < 1) {
			*heightPtr = 1;
		    }
		    break;
d3479 1
d3482 1
d3500 1
a3500 1
    (void) Tcl_Seek(chan, Tcl_LongAsWide(0L), SEEK_SET);
d3579 7
a3585 14
	useoldformat = 1;
	for (formatPtr = tsdPtr->oldFormatList; formatPtr != NULL;
		formatPtr = formatPtr->nextPtr) {
	    if (formatObj != NULL) {
		if (strncasecmp(formatString,
			formatPtr->name, strlen(formatPtr->name)) != 0) {
		    continue;
		}
		matched = 1;
		if (formatPtr->stringMatchProc == NULL) {
		    Tcl_AppendResult(interp, "-data option isn't supported",
			    " for ", formatString, " images", (char *) NULL);
		    return TCL_ERROR;
		}
d3587 5
a3591 7
	    if ((formatPtr->stringMatchProc != NULL)
		    && (formatPtr->stringReadProc != NULL)
		    && (*formatPtr->stringMatchProc)(
			    (Tcl_Obj *) Tcl_GetString(data),
			    (Tcl_Obj *) formatString,
			    widthPtr, heightPtr, interp)) {
		break;
d3594 8
d3605 2
a3606 1
	    Tcl_AppendResult(interp, "image format \"", formatString,
d3644 1
a3644 1
    CONST char *imageName;	/* Name of the desired photo image. */
d3673 1
a3673 1
Tk_PhotoPutBlock(handle, blockPtr, x, y, width, height, compRule)
a3682 2
    int compRule;		/* Compositing rule to use when processing
				 * transparent pixels. */
d3703 1
a3703 1
    if ((width <= 0) || (height <= 0)) {
a3704 1
    }
d3709 2
a3710 4
	if (ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width),
		MAX(yEnd, masterPtr->height)) == TCL_ERROR) {
	    panic(TK_PHOTO_ALLOC_FAILURE_MESSAGE);
	}
d3756 1
a3756 2
		&& (blockPtr->pitch == pitch)))
	    && (compRule == TK_PHOTO_COMPOSITE_SET)) {
a3760 1
	int alpha;
d3766 24
a3789 64
		if ((blockPtr->pixelSize == 4) && (greenOffset == 1)
		    && (blueOffset == 2) && (alphaOffset == 3)
		    && (width <= blockPtr->width)
		    && (compRule == TK_PHOTO_COMPOSITE_SET)) {
		    memcpy((VOID *) destLinePtr, (VOID *) srcLinePtr,
			   (size_t) (width * 4));
		} else {
		    destPtr = destLinePtr;
		    for (wLeft = width; wLeft > 0;) {
			wCopy = MIN(wLeft, blockPtr->width);
			wLeft -= wCopy;
			srcPtr = srcLinePtr;
			for (; wCopy > 0; --wCopy) {
			    alpha = srcPtr[alphaOffset];
			    /*
			     * In the easy case, we can just copy.
			     */
			    if (!alphaOffset || (alpha == 255)) {
				/* new solid part of the image */
				*destPtr++ = srcPtr[0];
				*destPtr++ = srcPtr[greenOffset];
				*destPtr++ = srcPtr[blueOffset];
				*destPtr++ = 255;
				srcPtr += blockPtr->pixelSize;
				continue;
			    }

			    /*
			     * Combine according to the compositing rule.
			     */
			    switch (compRule) {
			    case TK_PHOTO_COMPOSITE_SET:
				*destPtr++ = srcPtr[0];
				*destPtr++ = srcPtr[greenOffset];
				*destPtr++ = srcPtr[blueOffset];
				*destPtr++ = alpha;
				break;

			    case TK_PHOTO_COMPOSITE_OVERLAY:
				if (!destPtr[3]) {
				    /*
				     * There must be a better way to select a
				     * background colour!
				     */
				    destPtr[0] = destPtr[1] = destPtr[2] = 0xd9;
				}

				if (alpha) {
				    destPtr[0] += (srcPtr[0] - destPtr[0]) * alpha / 255;
				    destPtr[1] += (srcPtr[greenOffset] - destPtr[1]) * alpha / 255;
				    destPtr[2] += (srcPtr[blueOffset] - destPtr[2]) * alpha / 255;
				    destPtr[3] += (255 - destPtr[3]) * alpha / 255;
				}
				/*
				 * else should be empty space
				 */
				destPtr += 4;
				break;

			    default:
				panic("unknown compositing rule: %d", compRule);
			    }
			    srcPtr += blockPtr->pixelSize;
			}
d3802 42
a3843 64
    if (alphaOffset) {
	int x1, y1, end;

	/*
	 * This block is grossly inefficient.  For each row in the image, it
	 * finds each continguous string of nontransparent pixels, then marks
	 * those areas as valid in the validRegion mask.  This makes drawing
	 * very efficient, because of the way we use X: we just say, here's
	 * your mask, and here's your data.  We need not worry about the
	 * current background color, etc.  But this costs us a lot on the
	 * image setup.  Still, image setup only happens once, whereas the
	 * drawing happens many times, so this might be the best way to go.
	 *
	 * An alternative might be to not set up this mask, and instead, at
	 * drawing time, for each transparent pixel, set its color to the
	 * color of the background behind that pixel.  This is what I suspect
	 * most of programs do.  However, they don't have to deal with the
	 * canvas, which could have many different background colors.
	 * Determining the correct bg color for a given pixel might be
	 * expensive.
	 */

	if (compRule != TK_PHOTO_COMPOSITE_OVERLAY) {
	    /*
	     * Don't need this when using the OVERLAY compositing rule,
	     * which always strictly increases the valid region.
	     */
	    TkRegion workRgn = TkCreateRegion();

	    rect.x = x;
	    rect.y = y;
	    rect.width = width;
	    rect.height = height;
	    TkUnionRectWithRegion(&rect, workRgn, workRgn);
	    TkSubtractRegion(masterPtr->validRegion, workRgn,
		    masterPtr->validRegion);
	    TkDestroyRegion(workRgn);
	}

	destLinePtr = masterPtr->pix24 + (y * masterPtr->width + x) * 4 + 3;
	for (y1 = 0; y1 < height; y1++) {
	    x1 = 0;
	    destPtr = destLinePtr;
	    while (x1 < width) {
		/* search for first non-transparent pixel */
		while ((x1 < width) && !*destPtr) {
		    x1++;
		    destPtr += 4;
		}
		end = x1;
		/* search for first transparent pixel */
		while ((end < width) && *destPtr) {
		    end++;
		    destPtr += 4;
		}
		if (end > x1) {
		    rect.x = x + x1;
		    rect.y = y + y1;
		    rect.width = end - x1;
		    rect.height = 1;
		    TkUnionRectWithRegion(&rect, masterPtr->validRegion,
			    masterPtr->validRegion);
		}
		x1 = end;
d3845 1
a3845 1
	    destLinePtr += masterPtr->width * 4;
d3847 1
a3847 7
    } else {
	rect.x = x;
	rect.y = y;
	rect.width = width;
	rect.height = height;
	TkUnionRectWithRegion(&rect, masterPtr->validRegion,
		masterPtr->validRegion);
d3849 8
d3892 1
a3892 1
	subsampleX, subsampleY, compRule)
a3903 2
    int compRule;		/* Compositing rule to use when processing
				 * transparent pixels. */
d3918 3
a3920 2
    if (zoomX==1 && zoomY==1 && subsampleX==1 && subsampleY==1) {
	Tk_PhotoPutBlock(handle, blockPtr, x, y, width, height, compRule);
d3926 1
a3926 1
    if (zoomX <= 0 || zoomY <= 0) {
a3927 1
    }
d3935 1
a3935 1
    if (width <= 0 || height <= 0) {
a3936 1
    }
d3942 2
a3943 4
	if (ImgPhotoSetSize(masterPtr, MAX(xEnd, masterPtr->width),
		MAX(yEnd, masterPtr->height)) == TCL_ERROR) {
	    panic(TK_PHOTO_ALLOC_FAILURE_MESSAGE);
	}
d3983 1
a3983 1
    if (subsampleX > 0) {
d3985 1
a3985 1
    } else if (subsampleX == 0) {
d3987 1
a3987 1
    } else {
d3989 1
a3989 2
    }
    if (subsampleY > 0) {
d3991 1
a3991 1
    } else if (subsampleY == 0) {
d3993 1
a3993 1
    } else {
a3994 1
    }
d4023 17
a4039 37
			/*
			 * Common case (solid pixels) first
			 */
			if (!alphaOffset || (srcPtr[alphaOffset] == 255)) {
			    *destPtr++ = srcPtr[0];
			    *destPtr++ = srcPtr[greenOffset];
			    *destPtr++ = srcPtr[blueOffset];
			    *destPtr++ = 255;
			    continue;
 			}

			switch (compRule) {
			case TK_PHOTO_COMPOSITE_SET:
			    *destPtr++ = srcPtr[0];
			    *destPtr++ = srcPtr[greenOffset];
			    *destPtr++ = srcPtr[blueOffset];
			    *destPtr++ = srcPtr[alphaOffset];
			    break;
			case TK_PHOTO_COMPOSITE_OVERLAY:
			    if (!destPtr[3]) {
				/*
				 * There must be a better way to select a
				 * background colour!
				 */
				destPtr[0] = destPtr[1] = destPtr[2] = 0xd9;
			    }
			    if (srcPtr[alphaOffset]) {
				destPtr[0] += (srcPtr[0] - destPtr[0]) * srcPtr[alphaOffset] / 255;
				destPtr[1] += (srcPtr[greenOffset] - destPtr[1]) * srcPtr[alphaOffset] / 255;
				destPtr[2] += (srcPtr[blueOffset] - destPtr[2]) * srcPtr[alphaOffset] / 255;
				destPtr[3] += (255 - destPtr[3]) * srcPtr[alphaOffset] / 255;
			    }
			    destPtr += 4;
			    break;
			default:
			    panic("unknown compositing rule: %d", compRule);
			}
d4054 1
a4054 1
     * Recompute the region of data for which we have valid pixels to plot.
d4057 2
a4058 2
    if (alphaOffset) {
	int x1, y1, end;
d4060 21
a4080 42
	if (compRule != TK_PHOTO_COMPOSITE_OVERLAY) {
	    /*
	     * Don't need this when using the OVERLAY compositing rule, which
	     * always strictly increases the valid region.
	     */
	    TkRegion workRgn = TkCreateRegion();

	    rect.x = x;
	    rect.y = y;
	    rect.width = width;
	    rect.height = 1;
	    TkUnionRectWithRegion(&rect, workRgn, workRgn);
	    TkSubtractRegion(masterPtr->validRegion, workRgn,
		    masterPtr->validRegion);
	    TkDestroyRegion(workRgn);
	}

	destLinePtr = masterPtr->pix24 + (y * masterPtr->width + x) * 4 + 3;
	for (y1 = 0; y1 < height; y1++) {
	    x1 = 0;
	    destPtr = destLinePtr;
	    while (x1 < width) {
		/* search for first non-transparent pixel */
		while ((x1 < width) && !*destPtr) {
		    x1++;
		    destPtr += 4;
		}
		end = x1;
		/* search for first transparent pixel */
		while ((end < width) && *destPtr) {
		    end++;
		    destPtr += 4;
		}
		if (end > x1) {
		    rect.x = x + x1;
		    rect.y = y + y1;
		    rect.width = end - x1;
		    rect.height = 1;
		    TkUnionRectWithRegion(&rect, masterPtr->validRegion,
			    masterPtr->validRegion);
		}
		x1 = end;
d4082 1
a4082 1
	    destLinePtr += masterPtr->width * 4;
d4084 1
a4084 7
    } else {
	rect.x = x;
	rect.y = y;
	rect.width = width;
	rect.height = height;
	TkUnionRectWithRegion(&rect, masterPtr->validRegion,
		masterPtr->validRegion);
d4086 8
d4629 2
a4630 4
	if (ImgPhotoSetSize(masterPtr, MAX(width, masterPtr->width),
		MAX(height, masterPtr->height)) == TCL_ERROR) {
	    panic(TK_PHOTO_ALLOC_FAILURE_MESSAGE);
	}
d4699 2
a4700 4
    if (ImgPhotoSetSize(masterPtr, ((width > 0) ? width: masterPtr->width),
	    ((height > 0) ? height: masterPtr->height)) == TCL_ERROR) {
	panic(TK_PHOTO_ALLOC_FAILURE_MESSAGE);
    }
a4707 31
 * TkGetPhotoValidRegion --
 *
 *	This procedure is called to get the part of the photo where
 *	there is valid data.  Or, conversely, the part of the photo
 *	which is transparent.
 *
 * Results:
 *	A TkRegion value that indicates the current area of the photo
 *	that is valid.  This value should not be used after any
 *	modification to the photo image.
 *
 * Side Effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

TkRegion
TkPhotoGetValidRegion(handle)
    Tk_PhotoHandle handle; /* Handle for the image whose valid region
			    * is to obtained. */
{
    PhotoMaster *masterPtr;

    masterPtr = (PhotoMaster *) handle;
    return masterPtr->validRegion;
}

/*
 *----------------------------------------------------------------------
 *
d4757 1
a4757 2
		alphaOffset = 3;
		break;
d4761 1
a4761 3
	if (alphaOffset) {
	    break;
	}
d5141 7
a5147 7
     ClientData clientData;	/* Handle for the photo image */
    Tcl_Interp *interp;		/* Interpreter */
    Tk_Window tkwin;		/* (unused) */
    Tk_PostscriptInfo psInfo;	/* postscript info */
    int x, y;			/* First pixel to output */
    int width, height;		/* Width and height of area */
    int prepass;		/* (unused) */
a5155 21

/*
 *----------------------------------------------------------------------
 *
 * Tk_PhotoPutBlock_NoComposite, Tk_PhotoPutZoomedBlock_NoComposite --
 *
 * These backward-compatability functions just exist to fill slots in
 * stubs table.  For the behaviour of *_NoComposite, refer to the
 * corresponding function without the extra suffix.
 *
 *----------------------------------------------------------------------
 */
void
Tk_PhotoPutBlock_NoComposite(handle, blockPtr, x, y, width, height)
     Tk_PhotoHandle handle;
     Tk_PhotoImageBlock *blockPtr;
     int x, y, width, height;
{
    Tk_PhotoPutBlock(handle, blockPtr, x, y, width, height,
	    TK_PHOTO_COMPOSITE_OVERLAY);
}
a5156 10
void
Tk_PhotoPutZoomedBlock_NoComposite(handle, blockPtr, x, y, width, height,
				   zoomX, zoomY, subsampleX, subsampleY)
     Tk_PhotoHandle handle;
     Tk_PhotoImageBlock *blockPtr;
     int x, y, width, height, zoomX, zoomY, subsampleX, subsampleY;
{
    Tk_PhotoPutZoomedBlock(handle, blockPtr, x, y, width, height,
	    zoomX, zoomY, subsampleX, subsampleY, TK_PHOTO_COMPOSITE_OVERLAY);
}
@


1.1.1.4
log
@imported tk 8.4.1
@
text
@d5 2
a6 2
 *	stored in full color (32 bits per pixel including alpha channel)
 *	and displayed using dithering if necessary.
d19 1
a19 1
 * RCS: @@(#) $Id: tkImgPhoto.c,v 1.36 2002/10/18 00:48:22 hobbs Exp $
d165 1
a165 1
    unsigned char *pix32;	/* Local storage for 32-bit image. */
d592 1
a592 1
    masterPtr->pix32 = NULL;
d1000 1
a1000 1
	pixelPtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;
d1361 1
a1361 1
	    pixelPtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;
d1844 3
a1846 3
		    !strncmp(args[j], "-data", (size_t) length)) {
		if (++i < objc) {
		    data = objv[i];
a1847 4
		} else {
		    Tcl_AppendResult(interp,
			    "value for \"-data\" missing", (char *) NULL);
		    return TCL_ERROR;
d1850 3
a1852 3
		    !strncmp(args[j], "-format", (size_t) length)) {
		if (++i < objc) {
		    format = objv[i];
a1853 4
		} else {
		    Tcl_AppendResult(interp,
			    "value for \"-format\" missing", (char *) NULL);
		    return TCL_ERROR;
d2182 1
a2182 1
	     * FIXME: use autoconf to figure this out.
d2564 2
a2565 2
    if (masterPtr->pix32 != NULL) {
	ckfree((char *) masterPtr->pix32);
d2634 1
a2634 1
    unsigned char *newPix32 = NULL;
d2655 4
a2658 12
	    || (masterPtr->pix32 == NULL)) {
	/*
	 * Not a u-long, but should be one.
	 */
	unsigned /*long*/ newPixSize = (unsigned /*long*/) (height * pitch);

	newPix32 = (unsigned char *) attemptckalloc(newPixSize);
	/*
	 * The result could validly be NULL if the number of bytes
	 * requested was 0. [Bug 619544]
	 */
	if (newPix32 == NULL && newPixSize != 0) {
d2684 1
a2684 1
     * Use the reallocated storage (allocation above) for the 32-bit
d2688 1
a2688 1
    if (newPix32 != NULL) {
d2695 1
a2695 1
	if ((masterPtr->pix32 != NULL)
d2698 1
a2698 1
		memset((VOID *) newPix32, 0, (size_t) (validBox.y * pitch));
d2702 1
a2702 1
		memset((VOID *) (newPix32 + h * pitch), 0,
d2706 1
a2706 1
	    memset((VOID *) newPix32, 0, (size_t) (height * pitch));
d2709 1
a2709 1
	if (masterPtr->pix32 != NULL) {
d2723 2
a2724 2
		memcpy((VOID *) (newPix32 + offset),
			(VOID *) (masterPtr->pix32 + offset),
d2733 2
a2734 2
		destPtr = newPix32 + (validBox.y * width + validBox.x) * 4;
		srcPtr = masterPtr->pix32 + (validBox.y * masterPtr->width
d2744 1
a2744 1
	    ckfree((char *) masterPtr->pix32);
d2747 1
a2747 1
	masterPtr->pix32 = newPix32;
d4030 1
a4030 1
     * Copy the data into our local 32-bit/pixel array.
d4034 1
a4034 1
    destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;
d4173 1
a4173 1
	destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4 + 3;
d4296 1
a4296 1
	int sameSrc = (blockPtr->pixelPtr == masterPtr->pix32);
d4302 1
a4302 1
	    blockPtr->pixelPtr = masterPtr->pix32;
d4356 1
a4356 1
     * Copy the data into our local 32-bit/pixel array.
d4359 1
a4359 1
    destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4;
d4456 1
a4456 1
	destLinePtr = masterPtr->pix32 + (y * masterPtr->width + x) * 4 + 3;
d4675 1
a4675 1
    srcLinePtr = masterPtr->pix32 + (yStart * masterPtr->width + xStart) * 4;
d4967 1
a4967 1
     * Clear out the 32-bit pixel storage array.
d4971 1
a4971 1
    memset((VOID *) masterPtr->pix32, 0,
d5399 1
a5399 1
    blockPtr->pixelPtr = masterPtr->pix32;
@


