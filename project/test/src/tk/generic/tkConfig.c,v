head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.20.24.43;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.13;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.24;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.50;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.31;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.09;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@/* 
 * tkConfig.c --
 *
 *	This file contains procedures that manage configuration options
 *	for widgets and other things.
 *
 * Copyright (c) 1997-1998 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkConfig.c,v 1.18 2002/08/05 04:30:38 dgp Exp $
 */

/*
 * Temporary flag for working on new config package.
 */

#if 0

/*
 * used only for removing the old config code
 */

#define __NO_OLD_CONFIG
#endif

#include "tk.h"
#include "tkInt.h"
#include "tkPort.h"
#include "tkFont.h"

/*
 * The following definition is an AssocData key used to keep track of
 * all of the option tables that have been created for an interpreter.
 */

#define OPTION_HASH_KEY "TkOptionTable"

/*
 * The following two structures are used along with Tk_OptionSpec
 * structures to manage configuration options.  Tk_OptionSpec is
 * static templates that are compiled into the code of a widget
 * or other object manager.  However, to look up options efficiently
 * we need to supplement the static information with additional
 * dynamic information, and this dynamic information may be different
 * for each application.  Thus we create structures of the following
 * two types to hold all of the dynamic information; this is done
 * by Tk_CreateOptionTable.
 * 
 * One of the following structures corresponds to each Tk_OptionSpec.
 * These structures exist as arrays inside TkOptionTable structures.
 */

typedef struct TkOption {
    CONST Tk_OptionSpec *specPtr;	/* The original spec from the template
					 * passed to Tk_CreateOptionTable.*/
    Tk_Uid dbNameUID;		 	/* The Uid form of the option database 
					 * name. */
    Tk_Uid dbClassUID;			/* The Uid form of the option database
					 * class name. */
    Tcl_Obj *defaultPtr;		/* Default value for this option. */
    union {
	Tcl_Obj *monoColorPtr;		/* For color and border options, this
					 * is an alternate default value to
					 * use on monochrome displays. */
	struct TkOption *synonymPtr;	/* For synonym options, this points to
					 * the master entry. */
	struct Tk_ObjCustomOption *custom;  /* For TK_OPTION_CUSTOM. */
    } extra;
    int flags;				/* Miscellaneous flag values; see
					 * below for definitions. */
} Option;

/*
 * Flag bits defined for Option structures:
 *
 * OPTION_NEEDS_FREEING -	1 means that FreeResources must be
 *				invoke to free resources associated with
 *				the option when it is no longer needed.
 */

#define OPTION_NEEDS_FREEING		1

/*
 * One of the following exists for each Tk_OptionSpec array that has
 * been passed to Tk_CreateOptionTable.
 */

typedef struct OptionTable {
    int refCount;			/* Counts the number of uses of this
					 * table (the number of times
					 * Tk_CreateOptionTable has returned
					 * it).  This can be greater than 1 if
					 * it is shared along several option
					 * table  chains, or if the same table
					 * is used for multiple purposes. */
    Tcl_HashEntry *hashEntryPtr;	/* Hash table entry that refers to this
					 * table; used to delete the entry. */
    struct OptionTable *nextPtr;	/* If templatePtr was part of a chain
					 * of templates, this points to the
					 * table corresponding to the next
					 * template in the chain. */
    int numOptions;			/* The number of items in the options
					 * array below. */
    Option options[1];			/* Information about the individual
					 * options in the table.  This must be
					 * the last field in the structure:
					 * the actual size of the array will
					 * be numOptions, not 1. */
} OptionTable;

/*
 * Forward declarations for procedures defined later in this file:
 */

static int		DoObjConfig _ANSI_ARGS_((Tcl_Interp *interp,
			    char *recordPtr, Option *optionPtr,
			    Tcl_Obj *valuePtr, Tk_Window tkwin, 
			    Tk_SavedOption *savePtr));
static void		DestroyOptionHashTable _ANSI_ARGS_((
			    ClientData clientData, Tcl_Interp *interp));
static void		FreeResources _ANSI_ARGS_((Option *optionPtr, 
			    Tcl_Obj *objPtr, char *internalPtr,
			    Tk_Window tkwin));
static Tcl_Obj *	GetConfigList _ANSI_ARGS_((char *recordPtr,
			    Option *optionPtr, Tk_Window tkwin));
static Tcl_Obj *	GetObjectForOption _ANSI_ARGS_((char *recordPtr,
			    Option *optionPtr, Tk_Window tkwin));
static Option *		GetOption _ANSI_ARGS_((CONST char *name,
			    OptionTable *tablePtr));
static Option *		GetOptionFromObj _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr, OptionTable *tablePtr));
static int		ObjectIsEmpty _ANSI_ARGS_((Tcl_Obj *objPtr));
static int		SetOptionFromAny _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr));

/*
 * The structure below defines an object type that is used to cache the
 * result of looking up an option name.  If an object has this type, then
 * its internalPtr1 field points to the OptionTable in which it was looked up,
 * and the internalPtr2 field points to the entry that matched.
 */

Tcl_ObjType tkOptionObjType = {
    "option",				/* name */
    (Tcl_FreeInternalRepProc *) NULL,	/* freeIntRepProc */
    (Tcl_DupInternalRepProc *) NULL,	/* dupIntRepProc */
    (Tcl_UpdateStringProc *) NULL,	/* updateStringProc */
    SetOptionFromAny			/* setFromAnyProc */
};

/*
 *--------------------------------------------------------------
 *
 * Tk_CreateOptionTable --
 *
 *	Given a template for configuration options, this procedure
 *	creates a table that may be used to look up options efficiently.
 *
 * Results:
 *	Returns a token to a structure that can be passed to procedures
 *	such as Tk_InitOptions, Tk_SetOptions, and Tk_FreeConfigOptions.
 *
 * Side effects:
 *	Storage is allocated.
 *
 *--------------------------------------------------------------
 */

Tk_OptionTable
Tk_CreateOptionTable(interp, templatePtr)
    Tcl_Interp *interp;			/* Interpreter associated with the
					 * application in which this table
					 * will be used. */
    CONST Tk_OptionSpec *templatePtr;	/* Static information about the
					 * configuration options. */
{
    Tcl_HashTable *hashTablePtr;
    Tcl_HashEntry *hashEntryPtr;
    int newEntry;
    OptionTable *tablePtr;
    CONST Tk_OptionSpec *specPtr, *specPtr2;
    Option *optionPtr;
    int numOptions, i;

    /*
     * We use an AssocData value in the interpreter to keep a hash
     * table of all the option tables we've created for this application.
     * This is used for two purposes.  First, it allows us to share the
     * tables (e.g. in several chains) and second, we use the deletion
     * callback for the AssocData to delete all the option tables when
     * the interpreter is deleted.  The code below finds the hash table
     * or creates a new one if it doesn't already exist.
     */

    hashTablePtr = (Tcl_HashTable *) Tcl_GetAssocData(interp, OPTION_HASH_KEY,
	    NULL);
    if (hashTablePtr == NULL) {
	hashTablePtr = (Tcl_HashTable *) ckalloc(sizeof(Tcl_HashTable));
	Tcl_InitHashTable(hashTablePtr, TCL_ONE_WORD_KEYS);
	Tcl_SetAssocData(interp, OPTION_HASH_KEY, DestroyOptionHashTable,
		(ClientData) hashTablePtr);
    }

    /*
     * See if a table has already been created for this template.  If
     * so, just reuse the existing table.
     */

    hashEntryPtr = Tcl_CreateHashEntry(hashTablePtr, (char *) templatePtr,
	    &newEntry);
    if (!newEntry) {
	tablePtr = (OptionTable *) Tcl_GetHashValue(hashEntryPtr);
	tablePtr->refCount++;
	return (Tk_OptionTable) tablePtr;
    }

    /*
     * Count the number of options in the template, then create the
     * table structure.
     */

    numOptions = 0;
    for (specPtr = templatePtr; specPtr->type != TK_OPTION_END; specPtr++) {
	numOptions++;
    }
    tablePtr = (OptionTable *) (ckalloc(sizeof(OptionTable)
	    + ((numOptions - 1)  * sizeof(Option))));
    tablePtr->refCount = 1;
    tablePtr->hashEntryPtr = hashEntryPtr;
    tablePtr->nextPtr = NULL;
    tablePtr->numOptions = numOptions;

    /*
     * Initialize all of the Option structures in the table.
     */

    for (specPtr = templatePtr, optionPtr = tablePtr->options;
	    specPtr->type != TK_OPTION_END; specPtr++, optionPtr++) {
	optionPtr->specPtr = specPtr;
	optionPtr->dbNameUID = NULL;
	optionPtr->dbClassUID = NULL;
	optionPtr->defaultPtr = NULL;
	optionPtr->extra.monoColorPtr = NULL;
	optionPtr->flags = 0;

	if (specPtr->type == TK_OPTION_SYNONYM) {
	    /*
	     * This is a synonym option; find the master option that it
	     * refers to and create a pointer from the synonym to the
	     * master.
	     */

	    for (specPtr2 = templatePtr, i = 0; ; specPtr2++, i++) {
		if (specPtr2->type == TK_OPTION_END) {
		    panic("Tk_CreateOptionTable couldn't find synonym");
		}
		if (strcmp(specPtr2->optionName,
			(char *) specPtr->clientData) == 0) {
		    optionPtr->extra.synonymPtr = tablePtr->options + i;
		    break;
		}
	    }
	} else {
	    if (specPtr->dbName != NULL) {
		optionPtr->dbNameUID = Tk_GetUid(specPtr->dbName);
	    }
	    if (specPtr->dbClass != NULL) {
		optionPtr->dbClassUID = 
			Tk_GetUid(specPtr->dbClass);
	    }
	    if (specPtr->defValue != NULL) {
		optionPtr->defaultPtr =
			Tcl_NewStringObj(specPtr->defValue, -1);
		Tcl_IncrRefCount(optionPtr->defaultPtr);
	    }
	    if (((specPtr->type == TK_OPTION_COLOR)
		    || (specPtr->type == TK_OPTION_BORDER))
		    && (specPtr->clientData != NULL)) {
		optionPtr->extra.monoColorPtr =
			Tcl_NewStringObj((char *) specPtr->clientData, -1);
		Tcl_IncrRefCount(optionPtr->extra.monoColorPtr);
	    }

	    if (specPtr->type == TK_OPTION_CUSTOM) {
		/*
		 * Get the custom parsing, etc., functions.
		 */
		optionPtr->extra.custom =
		    (Tk_ObjCustomOption *)specPtr->clientData;
	    }
	}
	if (((specPtr->type == TK_OPTION_STRING)
		&& (specPtr->internalOffset >= 0))
		|| (specPtr->type == TK_OPTION_COLOR)
		|| (specPtr->type == TK_OPTION_FONT)
		|| (specPtr->type == TK_OPTION_BITMAP)
		|| (specPtr->type == TK_OPTION_BORDER)
		|| (specPtr->type == TK_OPTION_CURSOR)
		|| (specPtr->type == TK_OPTION_CUSTOM)) {
	    optionPtr->flags |= OPTION_NEEDS_FREEING;
	}
    }
    tablePtr->hashEntryPtr = hashEntryPtr;
    Tcl_SetHashValue(hashEntryPtr, tablePtr);

    /*
     * Finally, check to see if this template chains to another template
     * with additional options.  If so, call ourselves recursively to
     * create the next table(s).
     */

    if (specPtr->clientData != NULL) {
	tablePtr->nextPtr = (OptionTable *) Tk_CreateOptionTable(interp,
		(Tk_OptionSpec *) specPtr->clientData);
    }

    return (Tk_OptionTable) tablePtr;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_DeleteOptionTable --
 *
 *	Called to release resources used by an option table when 
 *	the table is no longer needed.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The option table and associated resources (such as additional
 *	option tables chained off it) are destroyed.
 *
 *----------------------------------------------------------------------
 */

void
Tk_DeleteOptionTable(optionTable)
    Tk_OptionTable optionTable;		/* The option table to delete. */
{
    OptionTable *tablePtr = (OptionTable *) optionTable;
    Option *optionPtr;
    int count;

    tablePtr->refCount--;
    if (tablePtr->refCount > 0) {
	return;
    }

    if (tablePtr->nextPtr != NULL) {
	Tk_DeleteOptionTable((Tk_OptionTable) tablePtr->nextPtr);
    }

    for (count = tablePtr->numOptions - 1, optionPtr = tablePtr->options;
	    count > 0;  count--, optionPtr++) {
	if (optionPtr->defaultPtr != NULL) {
	    Tcl_DecrRefCount(optionPtr->defaultPtr);
	}
	if (((optionPtr->specPtr->type == TK_OPTION_COLOR)
		|| (optionPtr->specPtr->type == TK_OPTION_BORDER))
		&& (optionPtr->extra.monoColorPtr != NULL)) {
	    Tcl_DecrRefCount(optionPtr->extra.monoColorPtr);
	}
    }
    Tcl_DeleteHashEntry(tablePtr->hashEntryPtr);
    ckfree((char *) tablePtr);
}

/*
 *----------------------------------------------------------------------
 *
 * DestroyOptionHashTable --
 *
 *	This procedure is the deletion callback associated with the
 *	AssocData entry created by Tk_CreateOptionTable.  It is
 *	invoked when an interpreter is deleted, and deletes all of
 *	the option tables associated with that interpreter.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The option hash table is destroyed along with all of the
 *	OptionTable structures that it refers to.
 *
 *----------------------------------------------------------------------
 */

static void
DestroyOptionHashTable(clientData, interp)
    ClientData clientData;	/* The hash table we are destroying */
    Tcl_Interp *interp;		/* The interpreter we are destroying */
{
    Tcl_HashTable *hashTablePtr = (Tcl_HashTable *) clientData;
    Tcl_HashSearch search;
    Tcl_HashEntry *hashEntryPtr;
    OptionTable *tablePtr;

    for (hashEntryPtr = Tcl_FirstHashEntry(hashTablePtr, &search);
	    hashEntryPtr != NULL;
	    hashEntryPtr = Tcl_NextHashEntry(&search)) {
	tablePtr = (OptionTable *) Tcl_GetHashValue(hashEntryPtr);

	/*
	 * The following statements do two tricky things:
	 * 1. They ensure that the option table is deleted, even if
	 *    there are outstanding references to it.
	 * 2. They ensure that Tk_DeleteOptionTable doesn't delete
	 *    other tables chained from this one; we'll do it when
	 *    we come across the hash table entry for the chained
	 *    table (in fact, the chained table may already have
	 *    been deleted).
	 */

	tablePtr->refCount = 1;
	tablePtr->nextPtr = NULL;
	Tk_DeleteOptionTable((Tk_OptionTable) tablePtr);
    }
    Tcl_DeleteHashTable(hashTablePtr);
    ckfree((char *) hashTablePtr);
}

/*
 *--------------------------------------------------------------
 *
 * Tk_InitOptions --
 *
 *	This procedure is invoked when an object such as a widget
 *	is created.  It supplies an initial value for each configuration
 *	option (the value may come from the option database, a system
 *	default, or the default in the option table).
 *
 * Results:
 *	The return value is TCL_OK if the procedure completed
 *	successfully, and TCL_ERROR if one of the initial values was
 *	bogus.  If an error occurs and interp isn't NULL, then an
 *	error message will be left in its result.
 *
 * Side effects:
 *	Fields of recordPtr are filled in with initial values.
 *
 *--------------------------------------------------------------
 */

int
Tk_InitOptions(interp, recordPtr, optionTable, tkwin)
    Tcl_Interp *interp;		/* Interpreter for error reporting.    NULL
				 * means don't leave an error message. */
    char *recordPtr;		/* Pointer to the record to configure.
				 * Note: the caller should have properly
				 * initialized the record with NULL
				 * pointers for each option value. */
    Tk_OptionTable optionTable;	/* The token which matches the config
				 * specs for the widget in question. */
    Tk_Window tkwin;		/* Certain options types (such as
				 * TK_OPTION_COLOR) need fields out
				 * of the window they are used in to
				 * be able to calculate their values.
				 * Not needed unless one of these
				 * options is in the configSpecs record. */
{
    OptionTable *tablePtr = (OptionTable *) optionTable;
    Option *optionPtr;
    int count;
    Tk_Uid value;
    Tcl_Obj *valuePtr;
    enum {
	OPTION_DATABASE, SYSTEM_DEFAULT, TABLE_DEFAULT
    } source;

    /*
     * If this table chains to other tables, handle their initialization
     * first.  That way, if both tables refer to the same field of the
     * record, the value in the first table will win.
     */

    if (tablePtr->nextPtr != NULL) {
	if (Tk_InitOptions(interp, recordPtr,
		(Tk_OptionTable) tablePtr->nextPtr, tkwin) != TCL_OK) {
	    return TCL_ERROR;
	}
    }

    /*
     * Iterate over all of the options in the table, initializing each in
     * turn.
     */

    for (optionPtr = tablePtr->options, count = tablePtr->numOptions;
	    count > 0; optionPtr++, count--) {

	/*
	 * If we specify TK_OPTION_DONT_SET_DEFAULT, then the user has
	 * processed and set a default for this already.
	 */
	if ((optionPtr->specPtr->type == TK_OPTION_SYNONYM) ||
		(optionPtr->specPtr->flags & TK_OPTION_DONT_SET_DEFAULT)) {
	    continue;
	}
	source = TABLE_DEFAULT;

	/*
	 * We look in three places for the initial value, using the first
	 * non-NULL value that we find.  First, check the option database.
	 */

	valuePtr = NULL;
	if (optionPtr->dbNameUID != NULL) {
	    value = Tk_GetOption(tkwin, optionPtr->dbNameUID, 
		    optionPtr->dbClassUID);
	    if (value != NULL) {
		valuePtr = Tcl_NewStringObj(value, -1);
		source = OPTION_DATABASE;
	    }
	}

	/*
	 * Second, check for a system-specific default value.
	 */
	if ((valuePtr == NULL)
		&& (optionPtr->dbNameUID != NULL)) {
	    valuePtr = TkpGetSystemDefault(tkwin, optionPtr->dbNameUID,
		    optionPtr->dbClassUID);
	    if (valuePtr != NULL) {
		source = SYSTEM_DEFAULT;
	    }
	}

	/*
	 * Third and last, use the default value supplied by the option
	 * table.  In the case of color objects, we pick one of two
	 * values depending on whether the screen is mono or color.
	 */

	if (valuePtr == NULL) {
	    if ((tkwin != NULL) 
		    && ((optionPtr->specPtr->type == TK_OPTION_COLOR)
		    || (optionPtr->specPtr->type == TK_OPTION_BORDER))
		    && (Tk_Depth(tkwin) <= 1) 
		    && (optionPtr->extra.monoColorPtr != NULL)) {
		valuePtr = optionPtr->extra.monoColorPtr;
	    } else {
		valuePtr = optionPtr->defaultPtr;
	    }
	}

	if (valuePtr == NULL) {
	    continue;
	}

	/*
	 * Bump the reference count on valuePtr, so that it is strongly
	 * referenced here, and will be properly free'd when finished,
	 * regardless of what DoObjConfig does.
	 */
	Tcl_IncrRefCount(valuePtr);
	
	if (DoObjConfig(interp, recordPtr, optionPtr, valuePtr, tkwin,
		(Tk_SavedOption *) NULL) != TCL_OK) {
	    if (interp != NULL) {
		char msg[200];
    
		switch (source) {
		    case OPTION_DATABASE:
			sprintf(msg, "\n    (database entry for \"%.50s\")",
				optionPtr->specPtr->optionName);
			break;
		    case SYSTEM_DEFAULT:
			sprintf(msg, "\n    (system default for \"%.50s\")",
				optionPtr->specPtr->optionName);
			break;
		    case TABLE_DEFAULT:
			sprintf(msg, "\n    (default value for \"%.50s\")",
				optionPtr->specPtr->optionName);
		}
		if (tkwin != NULL) {
		    sprintf(msg + strlen(msg) - 1, " in widget \"%.50s\")",
			    Tk_PathName(tkwin));
		}
		Tcl_AddErrorInfo(interp, msg);
	    }
	    Tcl_DecrRefCount(valuePtr);
	    return TCL_ERROR;
	}
	Tcl_DecrRefCount(valuePtr);
    }
    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * DoObjConfig --
 *
 *	This procedure applies a new value for a configuration option
 *	to the record being configured.
 *
 * Results:
 *	The return value is TCL_OK if the procedure completed
 *	successfully.  If an error occurred then TCL_ERROR is
 *	returned and an error message is left in interp's result, if
 *	interp isn't NULL.  In addition, if oldValuePtrPtr isn't
 *	NULL then it *oldValuePtrPtr is filled in with a pointer
 *	to the option's old value.
 *
 * Side effects:
 *	RecordPtr gets modified to hold the new value in the form of
 *	a Tcl_Obj, an internal representation, or both.  The old
 *	value is freed if oldValuePtrPtr is NULL.
 *
 *--------------------------------------------------------------
 */

static int
DoObjConfig(interp, recordPtr, optionPtr, valuePtr, tkwin, savedOptionPtr)
    Tcl_Interp *interp;		/* Interpreter for error reporting.  If
				 * NULL, then no message is left if an error
				 * occurs. */
    char *recordPtr;		/* The record to modify to hold the new
				 * option value. */
    Option *optionPtr;		/* Pointer to information about the
				 * option. */
    Tcl_Obj *valuePtr;		/* New value for option. */
    Tk_Window tkwin;		/* Window in which option will be used (needed
				 * to allocate resources for some options).
				 * May be NULL if the option doesn't
				 * require window-related resources. */
    Tk_SavedOption *savedOptionPtr;
				/* If NULL, the old value for the option will
				 * be freed. If non-NULL, the old value will
				 * be stored here, and it becomes the property
				 * of the caller (the caller must eventually
				 * free the old value). */
{
    Tcl_Obj **slotPtrPtr, *oldPtr;
    char *internalPtr;		/* Points to location in record where
				 * internal representation of value should
				 * be stored, or NULL. */
    char *oldInternalPtr;	/* Points to location in which to save old
				 * internal representation of value. */
    Tk_SavedOption internal;	/* Used to save the old internal representation
				 * of the value if savedOptionPtr is NULL. */
    CONST Tk_OptionSpec *specPtr;
    int nullOK;

    /*
     * Save the old object form for the value, if there is one.
     */

    specPtr = optionPtr->specPtr;
    if (specPtr->objOffset >= 0) {
	slotPtrPtr = (Tcl_Obj **) (recordPtr + specPtr->objOffset);
	oldPtr = *slotPtrPtr;
    } else {
	slotPtrPtr = NULL;
	oldPtr = NULL;
    }

    /*
     * Apply the new value in a type-specific way.  Also remember the
     * old object and internal forms, if they exist.
     */

    if (specPtr->internalOffset >= 0) {
	internalPtr = recordPtr + specPtr->internalOffset;
    } else {
	internalPtr = NULL;
    }
    if (savedOptionPtr != NULL) {
	savedOptionPtr->optionPtr = optionPtr;
	savedOptionPtr->valuePtr = oldPtr;
	oldInternalPtr = (char *) &savedOptionPtr->internalForm;
    } else {
	oldInternalPtr = (char *) &internal.internalForm;
    }
    nullOK = (optionPtr->specPtr->flags & TK_OPTION_NULL_OK);
    switch (optionPtr->specPtr->type) {
	case TK_OPTION_BOOLEAN: {
	    int new;

	    if (Tcl_GetBooleanFromObj(interp, valuePtr, &new)
		    != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (internalPtr != NULL) {
		*((int *) oldInternalPtr) = *((int *) internalPtr);
		*((int *) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_INT: {
	    int new;
	    
	    if (Tcl_GetIntFromObj(interp, valuePtr, &new) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (internalPtr != NULL) {
		*((int *) oldInternalPtr) = *((int *) internalPtr);
		*((int *) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_DOUBLE: {
	    double new;
	    
	    if (nullOK && ObjectIsEmpty(valuePtr)) {
		valuePtr = NULL;
		new = 0;
	    } else {
		if (Tcl_GetDoubleFromObj(interp, valuePtr, &new) != TCL_OK) {
		    return TCL_ERROR;
		}
	    }

	    if (internalPtr != NULL) {
		*((double *) oldInternalPtr) = *((double *) internalPtr);
		*((double *) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_STRING: {
	    char *new, *value;
	    int length;

	    if (nullOK && ObjectIsEmpty(valuePtr)) {
		valuePtr = NULL;
	    }
	    if (internalPtr != NULL) {
		if (valuePtr != NULL) {
		    value = Tcl_GetStringFromObj(valuePtr, &length);
		    new = ckalloc((unsigned) (length + 1));
		    strcpy(new, value);
		} else {
		    new = NULL;
		}
		*((char **) oldInternalPtr) = *((char **) internalPtr);
		*((char **) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_STRING_TABLE: {
	    int new;

	    if (Tcl_GetIndexFromObj(interp, valuePtr,
		    (CONST char **) optionPtr->specPtr->clientData,
		    optionPtr->specPtr->optionName+1, 0, &new) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (internalPtr != NULL) {
		*((int *) oldInternalPtr) = *((int *) internalPtr);
		*((int *) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_COLOR: {
	    XColor *newPtr;

	    if (nullOK && ObjectIsEmpty(valuePtr)) {
		valuePtr = NULL;
		newPtr = NULL;
	    } else {
		newPtr = Tk_AllocColorFromObj(interp, tkwin, valuePtr);
		if (newPtr == NULL) {
		    return TCL_ERROR;
		}
	    }
	    if (internalPtr != NULL) {
		*((XColor **) oldInternalPtr) = *((XColor **) internalPtr);
		*((XColor **) internalPtr) = newPtr;
	    }
	    break;
	}
	case TK_OPTION_FONT: {
	    Tk_Font new;

	    if (nullOK && ObjectIsEmpty(valuePtr)) {
		valuePtr = NULL;
		new = NULL;
	    } else {
		new = Tk_AllocFontFromObj(interp, tkwin, valuePtr);
		if (new == NULL) {
		    return TCL_ERROR;
		}
	    }
	    if (internalPtr != NULL) {
		*((Tk_Font *) oldInternalPtr) = *((Tk_Font *) internalPtr);
		*((Tk_Font *) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_STYLE: {
	    Tk_Style new;

	    if (nullOK && ObjectIsEmpty(valuePtr)) {
		valuePtr = NULL;
		new = NULL;
	    } else {
		new = Tk_AllocStyleFromObj(interp, valuePtr);
		if (new == NULL) {
		    return TCL_ERROR;
		}
	    }
	    if (internalPtr != NULL) {
		*((Tk_Style *) oldInternalPtr) = *((Tk_Style *) internalPtr);
		*((Tk_Style *) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_BITMAP: {
	    Pixmap new;

	    if (nullOK && ObjectIsEmpty(valuePtr)) {
		valuePtr = NULL;
		new = None;
	    } else {
		new = Tk_AllocBitmapFromObj(interp, tkwin, valuePtr);
		if (new == None) {
		    return TCL_ERROR;
		}
	    }
	    if (internalPtr != NULL) {
		*((Pixmap *) oldInternalPtr) = *((Pixmap *) internalPtr);
		*((Pixmap *) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_BORDER: {
	    Tk_3DBorder new;

	    if (nullOK && ObjectIsEmpty(valuePtr)) {
		valuePtr = NULL;
		new = NULL;
	    } else {
		new = Tk_Alloc3DBorderFromObj(interp, tkwin, valuePtr);
		if (new == NULL) {
		    return TCL_ERROR;
		}
	    }
	    if (internalPtr != NULL) {
		*((Tk_3DBorder *) oldInternalPtr) =
			*((Tk_3DBorder *) internalPtr);
		*((Tk_3DBorder *) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_RELIEF: {
	    int new;

	    if (nullOK && ObjectIsEmpty(valuePtr)) {
		valuePtr = NULL;
		new = TK_RELIEF_NULL;
	    } else {
		if (Tk_GetReliefFromObj(interp, valuePtr, &new) != TCL_OK) {
		    return TCL_ERROR;
		}
	    }
	    if (internalPtr != NULL) {
		*((int *) oldInternalPtr) = *((int *) internalPtr);
		*((int *) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_CURSOR: {
	    Tk_Cursor new;

	    if (nullOK && ObjectIsEmpty(valuePtr)) {
		new = None;
		valuePtr = NULL;
	    } else {
		new = Tk_AllocCursorFromObj(interp, tkwin, valuePtr);
		if (new == None) {
		    return TCL_ERROR;
		}
	    }
	    if (internalPtr != NULL) {
		*((Tk_Cursor *) oldInternalPtr) = *((Tk_Cursor *) internalPtr);
		*((Tk_Cursor *) internalPtr) = new;
	    }
	    Tk_DefineCursor(tkwin, new);
	    break;
	}
	case TK_OPTION_JUSTIFY: {
	    Tk_Justify new;

	    if (Tk_GetJustifyFromObj(interp, valuePtr, &new) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (internalPtr != NULL) {
		*((Tk_Justify *) oldInternalPtr)
			= *((Tk_Justify *) internalPtr);
		*((Tk_Justify *) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_ANCHOR: {
	    Tk_Anchor new;

	    if (Tk_GetAnchorFromObj(interp, valuePtr, &new) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (internalPtr != NULL) {
		*((Tk_Anchor *) oldInternalPtr)
			= *((Tk_Anchor *) internalPtr);
		*((Tk_Anchor *) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_PIXELS: {
	    int new;

	    if (nullOK && ObjectIsEmpty(valuePtr)) {
		valuePtr = NULL;
		new = 0;
	    } else {
		if (Tk_GetPixelsFromObj(interp, tkwin, valuePtr,
			&new) != TCL_OK) {
		    return TCL_ERROR;
		}
	    }
	    if (internalPtr != NULL) {
		*((int *) oldInternalPtr) = *((int *) internalPtr);
		*((int *) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_WINDOW: {
	    Tk_Window new;

	    if (nullOK && ObjectIsEmpty(valuePtr)) {
		valuePtr = NULL;
		new = None;
	    } else {
		if (TkGetWindowFromObj(interp, tkwin, valuePtr, &new)
			!= TCL_OK) {
		    return TCL_ERROR;
		}
	    }
	    if (internalPtr != NULL) {
		*((Tk_Window *) oldInternalPtr) = *((Tk_Window *) internalPtr);
		*((Tk_Window *) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_CUSTOM: {
	    Tk_ObjCustomOption *custom = optionPtr->extra.custom;
	    if (custom->setProc(custom->clientData, interp, tkwin,
		    &valuePtr, recordPtr, optionPtr->specPtr->internalOffset,
		    (char *)oldInternalPtr,
		    optionPtr->specPtr->flags) != TCL_OK) {
		return TCL_ERROR;
	    }
	    break;
	}
	    
	default: {
	    char buf[40+TCL_INTEGER_SPACE];
	    sprintf(buf, "bad config table: unknown type %d",
		    optionPtr->specPtr->type);
	    Tcl_SetResult(interp, buf, TCL_VOLATILE);
	    return TCL_ERROR;
	}
    }

    /*
     * Release resources associated with the old value, if we're not
     * returning it to the caller, then install the new object value into
     * the record.
     */

    if (savedOptionPtr == NULL) {
	if (optionPtr->flags & OPTION_NEEDS_FREEING) {
	    FreeResources(optionPtr, oldPtr, oldInternalPtr, tkwin);
	}
	if (oldPtr != NULL) {
	    Tcl_DecrRefCount(oldPtr);
	}
    }
    if (slotPtrPtr != NULL) {
	*slotPtrPtr = valuePtr;
	if (valuePtr != NULL) {
	    Tcl_IncrRefCount(valuePtr);
	}
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ObjectIsEmpty --
 *
 *	This procedure tests whether the string value of an object is
 *	empty.
 *
 * Results:
 *	The return value is 1 if the string value of objPtr has length
 *	zero, and 0 otherwise.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
ObjectIsEmpty(objPtr)
    Tcl_Obj *objPtr;		/* Object to test.  May be NULL. */
{
    int length;

    if (objPtr == NULL) {
	return 1;
    }
    if (objPtr->bytes != NULL) {
	return (objPtr->length == 0);
    }
    Tcl_GetStringFromObj(objPtr, &length);
    return (length == 0);
}

/*
 *----------------------------------------------------------------------
 *
 * GetOption --
 *
 *	This procedure searches through a chained option table to find
 *	the entry for a particular option name.
 *
 * Results:
 *	The return value is a pointer to the matching entry, or NULL
 *	if no matching entry could be found.
 *	Note: if the matching entry is a synonym then this procedure
 *	returns a pointer to the synonym entry, *not* the "real" entry
 *	that the synonym refers to.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static Option *
GetOption(name, tablePtr)
    CONST char *name;		/* String balue to be looked up in the
				 * option table. */
    OptionTable *tablePtr;	/* Table in which to look up name. */
{
    Option *bestPtr, *optionPtr;
    OptionTable *tablePtr2;
    CONST char *p1, *p2;
    int count;

    /*
     * Search through all of the option tables in the chain to find the
     * best match.  Some tricky aspects:
     *
     * 1. We have to accept unique abbreviations.
     * 2. The same name could appear in different tables in the chain.
     *    If this happens, we use the entry from the first table. We
     *    have to be careful to distinguish this case from an ambiguous
     *    abbreviation.
     */

    bestPtr = NULL;
    for (tablePtr2 = tablePtr; tablePtr2 != NULL;
	    tablePtr2 = tablePtr2->nextPtr) {
	for (optionPtr = tablePtr2->options, count = tablePtr2->numOptions;
		count > 0; optionPtr++, count--) {
	    for (p1 = name, p2 = optionPtr->specPtr->optionName;
		    *p1 == *p2; p1++, p2++) {
		if (*p1 == 0) {
		    /*
		     * This is an exact match.  We're done.
		     */

		    bestPtr = optionPtr;
		    goto done;
		}
	    }
	    if (*p1 == 0) {
		/*
		 * The name is an abbreviation for this option.  Keep
		 * to make sure that the abbreviation only matches one
		 * option name.  If we've already found a match in the
		 * past, then it is an error unless the full names for
		 * the two options are identical; in this case, the first
		 * option overrides the second.
		 */

		if (bestPtr == NULL) {
		    bestPtr = optionPtr;
		} else {
		    if (strcmp(bestPtr->specPtr->optionName,
			    optionPtr->specPtr->optionName) != 0) {
			goto error;
		    }
		}
	    }
	}
    }

    done:
    return bestPtr;

    error:
    return NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * GetOptionFromObj --
 *
 *      This procedure searches through a chained option table to find
 *      the entry for a particular option name.
 *
 * Results:
 *      The return value is a pointer to the matching entry, or NULL
 *      if no matching entry could be found.  If NULL is returned and
 *      interp is not NULL than an error message is left in its result.
 *      Note: if the matching entry is a synonym then this procedure
 *      returns a pointer to the synonym entry, *not* the "real" entry
 *      that the synonym refers to.
 *
 * Side effects:
 *      Information about the matching entry is cached in the object
 *      containing the name, so that future lookups can proceed more
 *      quickly.
 *
 *----------------------------------------------------------------------
 */

static Option *
GetOptionFromObj(interp, objPtr, tablePtr)
    Tcl_Interp *interp;         /* Used only for error reporting; if NULL
                                 * no message is left after an error. */
    Tcl_Obj *objPtr;            /* Object whose string value is to be
                                 * looked up in the option table. */
    OptionTable *tablePtr;      /* Table in which to look up objPtr. */
{
    Option *bestPtr;
    char *name;

    /*
     * First, check to see if the object already has the answer cached.
     */

    if (objPtr->typePtr == &tkOptionObjType) {
        if (objPtr->internalRep.twoPtrValue.ptr1 == (VOID *) tablePtr) {
            return (Option *) objPtr->internalRep.twoPtrValue.ptr2;
        }
    }

    /*
     * The answer isn't cached.
     */

    name = Tcl_GetStringFromObj(objPtr, (int *) NULL);
    bestPtr = GetOption(name, tablePtr);
    if (bestPtr == NULL) {
	goto error;
    }

    if ((objPtr->typePtr != NULL)
	    && (objPtr->typePtr->freeIntRepProc != NULL)) {
	objPtr->typePtr->freeIntRepProc(objPtr);
    }
    objPtr->internalRep.twoPtrValue.ptr1 = (VOID *) tablePtr;
    objPtr->internalRep.twoPtrValue.ptr2 = (VOID *) bestPtr;
    objPtr->typePtr = &tkOptionObjType;
    return bestPtr;

    error:
    if (interp != NULL) {
	Tcl_AppendResult(interp, "unknown option \"", name,
		"\"", (char *) NULL);
    }
    return NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * TkGetOptionSpec --
 *
 *      This procedure searches through a chained option table to find
 *      the option spec for a particular option name.
 *
 * Results:
 *      The return value is a pointer to the option spec of the matching
 *      entry, or NULL if no matching entry could be found.
 *      Note: if the matching entry is a synonym then this procedure
 *      returns a pointer to the option spec of the synonym entry, *not*
 *      the "real" entry that the synonym refers to.
 *      Note: this call is primarily used by the style management code
 *      (tkStyle.c) to look up an element's option spec into a widget's
 *      option table.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */

CONST Tk_OptionSpec *
TkGetOptionSpec(name, optionTable)
    CONST char *name;			/* String value to be looked up. */
    Tk_OptionTable optionTable;		/* Table in which to look up name. */
{
    Option *optionPtr;

    optionPtr = GetOption(name, (OptionTable *) optionTable);
    if (optionPtr == NULL) {
	return NULL;
    }
    return optionPtr->specPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * SetOptionFromAny --
 *
 *	This procedure is called to convert a Tcl object to option
 *	internal form. However, this doesn't make sense (need to have a
 *	table of options in order to do the conversion) so the
 *	procedure always generates an error.
 *
 * Results:
 *	The return value is always TCL_ERROR, and an error message is
 *	left in interp's result if interp isn't NULL. 
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
SetOptionFromAny(interp, objPtr)
    Tcl_Interp *interp;		/* Used for error reporting if not NULL. */
    register Tcl_Obj *objPtr;	/* The object to convert. */
{
    Tcl_AppendToObj(Tcl_GetObjResult(interp),
	    "can't convert value to option except via GetOptionFromObj API",
	    -1);
    return TCL_ERROR;
}

/*
 *--------------------------------------------------------------
 *
 * Tk_SetOptions --
 *
 *	Process one or more name-value pairs for configuration options
 *	and fill in fields of a record with new values.
 *
 * Results:
 *	If all goes well then TCL_OK is returned and the old values of
 *	any modified objects are saved in *savePtr, if it isn't NULL (the
 *	caller must eventually call Tk_RestoreSavedOptions or
 *	Tk_FreeSavedOptions to free the contents of *savePtr).  In
 *	addition, if maskPtr isn't NULL then *maskPtr is filled in with
 *	the OR of the typeMask bits from all modified options.  If an
 *	error occurs then TCL_ERROR is returned and a message 
 *	is left in interp's result unless interp is NULL; nothing is
 *	saved in *savePtr or *maskPtr in this case.
 *
 * Side effects:
 *	The fields of recordPtr get filled in with object pointers
 *	from objc/objv.  Old information in widgRec's fields gets 
 * 	recycled.  Information may be left at *savePtr.
 *
 *--------------------------------------------------------------
 */

int
Tk_SetOptions(interp, recordPtr, optionTable, objc, objv, tkwin, savePtr,
	maskPtr)
    Tcl_Interp *interp;			/* Interpreter for error reporting.
					 * If NULL, then no error message is
					 * returned.*/
    char *recordPtr;	    		/* The record to configure. */
    Tk_OptionTable optionTable;		/* Describes valid options. */
    int objc;				/* The number of elements in objv. */
    Tcl_Obj *CONST objv[];		/* Contains one or more name-value
					 * pairs. */
    Tk_Window tkwin;			/* Window associated with the thing
					 * being configured; needed for some
					 * options (such as colors). */
    Tk_SavedOptions *savePtr;		/* If non-NULL, the old values of
					 * modified options are saved here
					 * so that they can be restored
					 * after an error. */
    int *maskPtr;			/* It non-NULL, this word is modified
					 * on a successful return to hold the
					 * bit-wise OR of the typeMask fields
					 * of all options that were modified
					 * by this call.  Used by the caller
					 * to figure out which options
					 * actually changed. */
{
    OptionTable *tablePtr = (OptionTable *) optionTable;
    Option *optionPtr;
    Tk_SavedOptions *lastSavePtr, *newSavePtr;
    int mask;

    if (savePtr != NULL) {
	savePtr->recordPtr = recordPtr;
	savePtr->tkwin = tkwin;
	savePtr->numItems = 0;
	savePtr->nextPtr = NULL;
    }
    lastSavePtr = savePtr;

    /*
     * Scan through all of the arguments, processing those
     * that match entries in the option table.
     */

    mask = 0;
    for ( ; objc > 0; objc -= 2, objv += 2) {
	optionPtr = GetOptionFromObj(interp, objv[0], tablePtr);
	if (optionPtr == NULL) {
	    goto error;
	}
	if (optionPtr->specPtr->type == TK_OPTION_SYNONYM) {
	    optionPtr = optionPtr->extra.synonymPtr;
	}

	if (objc < 2) {
	    if (interp != NULL) {
		Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
			"value for \"", Tcl_GetStringFromObj(*objv, NULL),
			"\" missing", (char *) NULL);
		goto error;
	    }
	}
	if ((savePtr != NULL)
		&& (lastSavePtr->numItems >= TK_NUM_SAVED_OPTIONS)) {
	    /*
	     * We've run out of space for saving old option values.  Allocate
	     * more space.
	     */

	    newSavePtr = (Tk_SavedOptions *) ckalloc(sizeof(
		    Tk_SavedOptions));
	    newSavePtr->recordPtr = recordPtr;
	    newSavePtr->tkwin = tkwin;
	    newSavePtr->numItems = 0;
	    newSavePtr->nextPtr = NULL;
	    lastSavePtr->nextPtr = newSavePtr;
	    lastSavePtr = newSavePtr;
	}
	if (DoObjConfig(interp, recordPtr, optionPtr, objv[1], tkwin,
		(savePtr != NULL) ? &lastSavePtr->items[lastSavePtr->numItems]
		: (Tk_SavedOption *) NULL) != TCL_OK) {
	    char msg[100];

	    sprintf(msg, "\n    (processing \"%.40s\" option)",
		    Tcl_GetStringFromObj(*objv, NULL));
	    Tcl_AddErrorInfo(interp, msg);
	    goto error;
	}
	if (savePtr != NULL) {
	    lastSavePtr->numItems++;
	}
	mask |= optionPtr->specPtr->typeMask;
    }
    if (maskPtr != NULL) {
	*maskPtr = mask;
    }
    return TCL_OK;

    error:
    if (savePtr != NULL) {
	Tk_RestoreSavedOptions(savePtr);
    }
    return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_RestoreSavedOptions --
 *
 *	This procedure undoes the effect of a previous call to
 *	Tk_SetOptions by restoring all of the options to their value
 *	before the call to Tk_SetOptions.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The configutation record is restored and all the information
 *	stored in savePtr is freed.
 *
 *----------------------------------------------------------------------
 */

void
Tk_RestoreSavedOptions(savePtr)
    Tk_SavedOptions *savePtr;	/* Holds saved option information; must
				 * have been passed to Tk_SetOptions. */
{
    int i;
    Option *optionPtr;
    Tcl_Obj *newPtr;		/* New object value of option, which we
				 * replace with old value and free.  Taken
				 * from record. */
    char *internalPtr;		/* Points to internal value of option in
				 * record. */
    CONST Tk_OptionSpec *specPtr;

    /*
     * Be sure to restore the options in the opposite order they were
     * set.  This is important because it's possible that the same
     * option name was used twice in a single call to Tk_SetOptions.
     */

    if (savePtr->nextPtr != NULL) {
	Tk_RestoreSavedOptions(savePtr->nextPtr);
	ckfree((char *) savePtr->nextPtr);
	savePtr->nextPtr = NULL;
    }
    for (i = savePtr->numItems - 1; i >= 0; i--) {
	optionPtr = savePtr->items[i].optionPtr;
	specPtr = optionPtr->specPtr;

	/*
	 * First free the new value of the option, which is currently
	 * in the record.
	 */

	if (specPtr->objOffset >= 0) {
	    newPtr = *((Tcl_Obj **) (savePtr->recordPtr + specPtr->objOffset));
	} else {
	    newPtr = NULL;
	}
	if (specPtr->internalOffset >= 0) {
	    internalPtr = savePtr->recordPtr + specPtr->internalOffset;
	} else {
	    internalPtr = NULL;
	}
	if (optionPtr->flags & OPTION_NEEDS_FREEING) {
	    FreeResources(optionPtr, newPtr, internalPtr, savePtr->tkwin);
	}
	if (newPtr != NULL) {
	    Tcl_DecrRefCount(newPtr);
	}

	/*
	 * Now restore the old value of the option.
	 */

	if (specPtr->objOffset >= 0) {
	    *((Tcl_Obj **) (savePtr->recordPtr + specPtr->objOffset))
		    = savePtr->items[i].valuePtr;
	}
	if (specPtr->internalOffset >= 0) {
	    switch (specPtr->type) {
		case TK_OPTION_BOOLEAN: {
		    *((int *) internalPtr)
			    = *((int *) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_INT: {
		    *((int *) internalPtr)
			    = *((int *) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_DOUBLE: {
		    *((double *) internalPtr)
			    = *((double *) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_STRING: {
		    *((char **) internalPtr)
			    = *((char **) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_STRING_TABLE: {
		    *((int *) internalPtr)
			    = *((int *) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_COLOR: {
		    *((XColor **) internalPtr)
			    = *((XColor **) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_FONT: {
		    *((Tk_Font *) internalPtr)
			    = *((Tk_Font *) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_STYLE: {
		    *((Tk_Style *) internalPtr)
			    = *((Tk_Style *) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_BITMAP: {
		    *((Pixmap *) internalPtr)
			    = *((Pixmap *) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_BORDER: {
		    *((Tk_3DBorder *) internalPtr)
			    = *((Tk_3DBorder *) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_RELIEF: {
		    *((int *) internalPtr)
			    = *((int *) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_CURSOR: {
		    *((Tk_Cursor *) internalPtr)
			    = *((Tk_Cursor *) &savePtr->items[i].internalForm);
		    Tk_DefineCursor(savePtr->tkwin,
			    *((Tk_Cursor *) internalPtr));
		    break;
		}
		case TK_OPTION_JUSTIFY: {
		    *((Tk_Justify *) internalPtr)
			    = *((Tk_Justify *) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_ANCHOR: {
		    *((Tk_Anchor *) internalPtr)
			    = *((Tk_Anchor *) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_PIXELS: {
		    *((int *) internalPtr)
			    = *((int *) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_WINDOW: {
		    *((Tk_Window *) internalPtr)
			    = *((Tk_Window *) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_CUSTOM: {
		    Tk_ObjCustomOption *custom = optionPtr->extra.custom;
		    if (custom->restoreProc != NULL) {
			custom->restoreProc(custom->clientData, savePtr->tkwin,
				internalPtr,
				(char *)&savePtr->items[i].internalForm);
		    }
		    break;
		}
		default: {
		    panic("bad option type in Tk_RestoreSavedOptions");
		}
	    }
	}
    }
    savePtr->numItems = 0;
}

/*
 *--------------------------------------------------------------
 *
 * Tk_FreeSavedOptions --
 *
 *	Free all of the saved configuration option values from a
 *	previous call to Tk_SetOptions.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Storage and system resources are freed.
 *
 *--------------------------------------------------------------
 */

void
Tk_FreeSavedOptions(savePtr)
    Tk_SavedOptions *savePtr;	/* Contains options saved in a previous
				 * call to Tk_SetOptions. */
{
    int count;
    Tk_SavedOption *savedOptionPtr;

    if (savePtr->nextPtr != NULL) {
	Tk_FreeSavedOptions(savePtr->nextPtr);
	ckfree((char *) savePtr->nextPtr);
    }
    for (count = savePtr->numItems,
	    savedOptionPtr = &savePtr->items[savePtr->numItems-1];
	    count > 0;  count--, savedOptionPtr--) {
	if (savedOptionPtr->optionPtr->flags & OPTION_NEEDS_FREEING) {
	    FreeResources(savedOptionPtr->optionPtr, savedOptionPtr->valuePtr,
		    (char *) &savedOptionPtr->internalForm, savePtr->tkwin);
	}
	if (savedOptionPtr->valuePtr != NULL) {
	    Tcl_DecrRefCount(savedOptionPtr->valuePtr);
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_FreeConfigOptions --
 *
 *	Free all resources associated with configuration options.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	All of the Tcl_Obj's in recordPtr that are controlled by
 *	configuration options in optionTable are freed.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
void
Tk_FreeConfigOptions(recordPtr, optionTable, tkwin)
    char *recordPtr;		/* Record whose fields contain current
				 * values for options. */
    Tk_OptionTable optionTable;	/* Describes legal options. */
    Tk_Window tkwin;		/* Window associated with recordPtr; needed
				 * for freeing some options. */
{
    OptionTable *tablePtr;
    Option *optionPtr;
    int count;
    Tcl_Obj **oldPtrPtr, *oldPtr; 
    char *oldInternalPtr;
    CONST Tk_OptionSpec *specPtr;

    for (tablePtr = (OptionTable *) optionTable; tablePtr != NULL;
	    tablePtr = tablePtr->nextPtr) {
	for (optionPtr = tablePtr->options, count = tablePtr->numOptions;
		count > 0; optionPtr++, count--) {
	    specPtr = optionPtr->specPtr;
	    if (specPtr->type == TK_OPTION_SYNONYM) {
		continue;
	    }
	    if (specPtr->objOffset >= 0) {
		oldPtrPtr = (Tcl_Obj **) (recordPtr + specPtr->objOffset);
		oldPtr = *oldPtrPtr;
		*oldPtrPtr = NULL;
	    } else {
		oldPtr = NULL;
	    }
	    if (specPtr->internalOffset >= 0) {
		oldInternalPtr = recordPtr + specPtr->internalOffset;
	    } else {
		oldInternalPtr = NULL;
	    }
	    if (optionPtr->flags & OPTION_NEEDS_FREEING) {
		FreeResources(optionPtr, oldPtr, oldInternalPtr, tkwin);
	    }
	    if (oldPtr != NULL) {
		Tcl_DecrRefCount(oldPtr);
	    }
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * FreeResources --
 *
 *	Free system resources associated with a configuration option,
 *	such as colors or fonts.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Any system resources associated with objPtr are released.  However,
 *	objPtr itself is not freed.
 *
 *----------------------------------------------------------------------
 */

static void
FreeResources(optionPtr, objPtr, internalPtr, tkwin)
    Option *optionPtr;		/* Description of the configuration option. */
    Tcl_Obj *objPtr;		/* The current value of the option, specified
				 * as an object. */
    char *internalPtr;		/* A pointer to an internal representation for
				 * the option's value, such as an int or
				 * (XColor *).  Only valid if
				 * optionPtr->specPtr->internalOffset >= 0. */
    Tk_Window tkwin;		/* The window in which this option is used. */
{
    int internalFormExists;

    /*
     * If there exists an internal form for the value, use it to free
     * resources (also zero out the internal form).  If there is no
     * internal form, then use the object form.
     */

    internalFormExists = optionPtr->specPtr->internalOffset >= 0;
    switch (optionPtr->specPtr->type) {
	case TK_OPTION_STRING:
	    if (internalFormExists) {
		if (*((char **) internalPtr) != NULL) {
		    ckfree(*((char **) internalPtr));
		    *((char **) internalPtr) = NULL;
		}
	    }
	    break;
	case TK_OPTION_COLOR:
	    if (internalFormExists) {
		if (*((XColor **) internalPtr) != NULL) {
		    Tk_FreeColor(*((XColor **) internalPtr));
		    *((XColor **) internalPtr) = NULL;
		}
	    } else if (objPtr != NULL) {
		Tk_FreeColorFromObj(tkwin, objPtr);
	    }
	    break;
	case TK_OPTION_FONT:
	    if (internalFormExists) {
		Tk_FreeFont(*((Tk_Font *) internalPtr));
		*((Tk_Font *) internalPtr) = NULL;
	    } else if (objPtr != NULL) {
		Tk_FreeFontFromObj(tkwin, objPtr);
	    }
	    break;
	case TK_OPTION_STYLE:
	    if (internalFormExists) {
		Tk_FreeStyle(*((Tk_Style *) internalPtr));
		*((Tk_Style *) internalPtr) = NULL;
	    } else if (objPtr != NULL) {
		Tk_FreeStyleFromObj(objPtr);
	    }
	    break;
	case TK_OPTION_BITMAP:
	    if (internalFormExists) {
		if (*((Pixmap *) internalPtr) != None) {
		    Tk_FreeBitmap(Tk_Display(tkwin), *((Pixmap *) internalPtr));
		    *((Pixmap *) internalPtr) = None;
		}
	    } else if (objPtr != NULL) {
		Tk_FreeBitmapFromObj(tkwin, objPtr);
	    }
	    break;
	case TK_OPTION_BORDER:
	    if (internalFormExists) {
		if (*((Tk_3DBorder *) internalPtr) != NULL) {
		    Tk_Free3DBorder(*((Tk_3DBorder *) internalPtr));
		    *((Tk_3DBorder *) internalPtr) = NULL;
		}
	    } else if (objPtr != NULL) {
		Tk_Free3DBorderFromObj(tkwin, objPtr);
	    }
	    break;
	case TK_OPTION_CURSOR:
	    if (internalFormExists) {
		if (*((Tk_Cursor *) internalPtr) != None) {
		    Tk_FreeCursor(Tk_Display(tkwin),
			    *((Tk_Cursor *) internalPtr));
		    *((Tk_Cursor *) internalPtr) = None;
		}
	    } else if (objPtr != NULL) {
		Tk_FreeCursorFromObj(tkwin, objPtr);
	    }
	    break;
	case TK_OPTION_CUSTOM: {
	    Tk_ObjCustomOption *custom = optionPtr->extra.custom;
	    if (internalFormExists && custom->freeProc != NULL) {
		custom->freeProc(custom->clientData, tkwin, internalPtr);
	    }
	    break;
	}
	default:
	    break;
    }
}

/*
 *--------------------------------------------------------------
 *
 * Tk_GetOptionInfo --
 *
 *	Returns a list object containing complete information about
 *	either a single option or all the configuration options in a
 *	table.
 *
 * Results:
 *	This procedure normally returns a pointer to an object.
 *	If namePtr isn't NULL, then the result object is a list with
 *	five elements: the option's name, its database name, database
 *	class, default value, and current value.  If the option is a
 *	synonym then the list will contain only two values: the option
 *	name and the name of the option it refers to.  If namePtr is
 *	NULL, then information is returned for every option in the
 *	option table: the result will have one sub-list (in the form
 *	described above) for each option in the table.  If an error
 *	occurs (e.g. because namePtr isn't valid) then NULL is returned
 *	and an error message will be left in interp's result unless
 *	interp is NULL.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

Tcl_Obj *
Tk_GetOptionInfo(interp, recordPtr, optionTable, namePtr, tkwin)
    Tcl_Interp *interp;		/* Interpreter for error reporting.  If	
				 * NULL, then no error message is created. */
    char *recordPtr;		/* Record whose fields contain current
				 * values for options. */
    Tk_OptionTable optionTable;	/* Describes all the legal options. */
    Tcl_Obj *namePtr;		/* If non-NULL, the string value selects
				 * a single option whose info is to be
				 * returned.  Otherwise info is returned for
				 * all options in optionTable. */
    Tk_Window tkwin;		/* Window associated with recordPtr; needed
				 * to compute correct default value for some
				 * options. */
{
    Tcl_Obj *resultPtr;
    OptionTable *tablePtr = (OptionTable *) optionTable;
    Option *optionPtr;
    int count;

    /*
     * If information is only wanted for a single configuration
     * spec, then handle that one spec specially.
     */

    if (namePtr != NULL) {
	optionPtr = GetOptionFromObj(interp, namePtr, tablePtr);
	if (optionPtr == NULL) {
	    return (Tcl_Obj *) NULL;
	}
	if (optionPtr->specPtr->type == TK_OPTION_SYNONYM) {
	    optionPtr = optionPtr->extra.synonymPtr;
	}
	return GetConfigList(recordPtr, optionPtr, tkwin);
    }

    /*
     * Loop through all the specs, creating a big list with all
     * their information.
     */

    resultPtr = Tcl_NewListObj(0, (Tcl_Obj **) NULL);
    for (; tablePtr != NULL; tablePtr = tablePtr->nextPtr) {
	for (optionPtr = tablePtr->options, count = tablePtr->numOptions;
		count > 0; optionPtr++, count--) {
	    Tcl_ListObjAppendElement(interp, resultPtr,
		    GetConfigList(recordPtr, optionPtr, tkwin));
	}
    }
    return resultPtr;
}

/*
 *--------------------------------------------------------------
 *
 * GetConfigList --
 *
 *	Create a valid Tcl list holding the configuration information
 *	for a single configuration option.
 *
 * Results:
 *	A Tcl list, dynamically allocated.  The caller is expected to
 *	arrange for this list to be freed eventually.
 *
 * Side effects:
 *	Memory is allocated.
 *
 *--------------------------------------------------------------
 */

static Tcl_Obj *
GetConfigList(recordPtr, optionPtr, tkwin)
    char *recordPtr;		/* Pointer to record holding current
				 * values of configuration options. */
    Option *optionPtr;		/* Pointer to information describing a
				 * particular option. */
    Tk_Window tkwin;		/* Window corresponding to recordPtr. */
{
    Tcl_Obj *listPtr, *elementPtr;

    listPtr = Tcl_NewListObj(0, (Tcl_Obj **) NULL);
    Tcl_ListObjAppendElement((Tcl_Interp *) NULL, listPtr, 
	    Tcl_NewStringObj(optionPtr->specPtr->optionName, -1));

    if (optionPtr->specPtr->type == TK_OPTION_SYNONYM) {
	elementPtr = Tcl_NewStringObj(
		optionPtr->extra.synonymPtr->specPtr->optionName, -1);
	Tcl_ListObjAppendElement((Tcl_Interp *) NULL, listPtr, elementPtr);
    } else {
	if (optionPtr->dbNameUID == NULL) {
	    elementPtr = Tcl_NewObj();
	} else {
	    elementPtr = Tcl_NewStringObj(optionPtr->dbNameUID, -1);
	}
	Tcl_ListObjAppendElement((Tcl_Interp *) NULL, listPtr, elementPtr);

	if (optionPtr->dbClassUID == NULL) {
	    elementPtr = Tcl_NewObj();
	} else {
	    elementPtr = Tcl_NewStringObj(optionPtr->dbClassUID, -1);
	}
	Tcl_ListObjAppendElement((Tcl_Interp *) NULL, listPtr, elementPtr);

	if ((tkwin != NULL) && ((optionPtr->specPtr->type == TK_OPTION_COLOR)
		|| (optionPtr->specPtr->type == TK_OPTION_BORDER))
		&& (Tk_Depth(tkwin) <= 1)
		&& (optionPtr->extra.monoColorPtr != NULL)) {
	    elementPtr = optionPtr->extra.monoColorPtr;
	} else if (optionPtr->defaultPtr != NULL) {
	    elementPtr = optionPtr->defaultPtr;
	} else {
	    elementPtr = Tcl_NewObj();
	}
	Tcl_ListObjAppendElement((Tcl_Interp *) NULL, listPtr, elementPtr);

	if (optionPtr->specPtr->objOffset >= 0) {
	    elementPtr = *((Tcl_Obj **) (recordPtr
		    + optionPtr->specPtr->objOffset));
	    if (elementPtr == NULL) {
		elementPtr = Tcl_NewObj();
	    }
	} else {
	    elementPtr = GetObjectForOption(recordPtr, optionPtr, tkwin);
	}
	Tcl_ListObjAppendElement((Tcl_Interp *) NULL, listPtr, elementPtr);
    }
    return listPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * GetObjectForOption --
 *
 *	This procedure is called to create an object that contains the
 *	value for an option.  It is invoked by GetConfigList and
 *	Tk_GetOptionValue when only the internal form of an option is
 *	stored in the record.
 *
 * Results:
 *	The return value is a pointer to a Tcl object.  The caller
 *	must call Tcl_IncrRefCount on this object to preserve it.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static Tcl_Obj *
GetObjectForOption(recordPtr, optionPtr, tkwin)
    char *recordPtr;		/* Pointer to record holding current
				 * values of configuration options. */
    Option *optionPtr;		/* Pointer to information describing an
				 * option whose internal value is stored
				 * in *recordPtr. */
    Tk_Window tkwin;		/* Window corresponding to recordPtr. */
{
    Tcl_Obj *objPtr;
    char *internalPtr;		/* Points to internal value of option in
				 * record. */

    internalPtr = recordPtr + optionPtr->specPtr->internalOffset;
    objPtr = NULL;
    switch (optionPtr->specPtr->type) {
	case TK_OPTION_BOOLEAN: {
	    objPtr = Tcl_NewIntObj(*((int *) internalPtr));
	    break;
	}
	case TK_OPTION_INT: {
	    objPtr = Tcl_NewIntObj(*((int *) internalPtr));
	    break;
	}
	case TK_OPTION_DOUBLE: {
	    objPtr = Tcl_NewDoubleObj(*((double *) internalPtr));
	    break;
	}
	case TK_OPTION_STRING: {
	    objPtr = Tcl_NewStringObj(*((char **) internalPtr), -1);
	    break;
	}
	case TK_OPTION_STRING_TABLE: {
	    objPtr = Tcl_NewStringObj(
		    ((char **) optionPtr->specPtr->clientData)[
		    *((int *) internalPtr)], -1);
	    break;
	}
	case TK_OPTION_COLOR: { 
	    XColor *colorPtr = *((XColor **) internalPtr);
	    if (colorPtr != NULL) {
		objPtr = Tcl_NewStringObj(Tk_NameOfColor(colorPtr), -1);
	    }
	    break;
	}
	case TK_OPTION_FONT: {
	    Tk_Font tkfont = *((Tk_Font *) internalPtr);
	    if (tkfont != NULL) {
		objPtr = Tcl_NewStringObj(Tk_NameOfFont(tkfont), -1);
	    }
	    break;
	}
	case TK_OPTION_STYLE: {
	    Tk_Style style = *((Tk_Style *) internalPtr);
	    if (style != NULL) {
		objPtr = Tcl_NewStringObj(Tk_NameOfStyle(style), -1);
	    }
	    break;
	}
	case TK_OPTION_BITMAP: {
	    Pixmap pixmap = *((Pixmap *) internalPtr);
	    if (pixmap != None) {
		objPtr = Tcl_NewStringObj(Tk_NameOfBitmap(Tk_Display(tkwin),
			pixmap), -1);
	    }
	    break;
	}
	case TK_OPTION_BORDER: {
	    Tk_3DBorder border = *((Tk_3DBorder *) internalPtr);
	    if (border != NULL) {
		objPtr = Tcl_NewStringObj(Tk_NameOf3DBorder(border), -1);
	    }
	    break;
	}
	case TK_OPTION_RELIEF: {
	    objPtr = Tcl_NewStringObj(Tk_NameOfRelief(
		    *((int *) internalPtr)), -1);
	    break;
	}
	case TK_OPTION_CURSOR: {
	    Tk_Cursor cursor = *((Tk_Cursor *) internalPtr);
	    if (cursor != None) {
		objPtr = Tcl_NewStringObj(
			Tk_NameOfCursor(Tk_Display(tkwin), cursor), -1);
	    }
	    break;
	}
	case TK_OPTION_JUSTIFY: {
	    objPtr = Tcl_NewStringObj(Tk_NameOfJustify(
		    *((Tk_Justify *) internalPtr)), -1);
	    break;
	}
	case TK_OPTION_ANCHOR: {
	    objPtr = Tcl_NewStringObj(Tk_NameOfAnchor(
		    *((Tk_Anchor *) internalPtr)), -1);
	    break;
	}
	case TK_OPTION_PIXELS: {
	    objPtr = Tcl_NewIntObj(*((int *) internalPtr));
	    break;
	}
	case TK_OPTION_WINDOW: {
	    Tk_Window tkwin = *((Tk_Window *) internalPtr);
	    if (tkwin != NULL) {
		objPtr = Tcl_NewStringObj(Tk_PathName(tkwin), -1);
	    }
	    break;
	}
	case TK_OPTION_CUSTOM: {
	    Tk_ObjCustomOption *custom = optionPtr->extra.custom;
	    objPtr = custom->getProc(custom->clientData, tkwin, recordPtr,
		    optionPtr->specPtr->internalOffset);
	    break;
	}
	default: {
	    panic("bad option type in GetObjectForOption");
	}
    }
    if (objPtr == NULL) {
	objPtr = Tcl_NewObj();
    }
    return objPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_GetOptionValue --
 *
 *	This procedure returns the current value of a configuration
 *	option.
 *
 * Results:
 *	The return value is the object holding the current value of
 *	the option given by namePtr.  If no such option exists, then
 *	the return value is NULL and an error message is left in
 *	interp's result (if interp isn't NULL).
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
Tk_GetOptionValue(interp, recordPtr, optionTable, namePtr, tkwin)
    Tcl_Interp *interp;		/* Interpreter for error reporting.  If
				 * NULL then no messages are provided for
				 * errors. */
    char *recordPtr;		/* Record whose fields contain current
				 * values for options. */
    Tk_OptionTable optionTable;	/* Describes legal options. */
    Tcl_Obj *namePtr;		/* Gives the command-line name for the
				 * option whose value is to be returned. */
    Tk_Window tkwin;		/* Window corresponding to recordPtr. */
{
    OptionTable *tablePtr = (OptionTable *) optionTable;
    Option *optionPtr;
    Tcl_Obj *resultPtr;

    optionPtr = GetOptionFromObj(interp, namePtr, tablePtr);
    if (optionPtr == NULL) {
	return NULL;
    }
    if (optionPtr->specPtr->type == TK_OPTION_SYNONYM) {
	optionPtr = optionPtr->extra.synonymPtr;
    }
    if (optionPtr->specPtr->objOffset >= 0) {
	resultPtr = *((Tcl_Obj **) (recordPtr + optionPtr->specPtr->objOffset));
	if (resultPtr == NULL) {
	    /*
	     * This option has a null value and is represented by a null
	     * object pointer.  We can't return the null pointer, since that
	     * would indicate an error.  Instead, return a new empty object.
	     */
    
	    resultPtr = Tcl_NewObj();
	} 
    } else {
	resultPtr = GetObjectForOption(recordPtr, optionPtr, tkwin);
    }
    return resultPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TkDebugConfig --
 *
 *	This is a debugging procedure that returns information about
 *	one of the configuration tables that currently exists for an
 *	interpreter.
 *
 * Results:
 *	If the specified table exists in the given interpreter, then a
 *	list is returned describing the table and any other tables that
 *	it chains to: for each table there will be three list elements
 *	giving the reference count for the table, the number of elements
 *	in the table, and the command-line name for the first option
 *	in the table.  If the table doesn't exist in the interpreter
 *	then an empty object is returned.  The reference count for the
 *	returned object is 0.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
TkDebugConfig(interp, table)
    Tcl_Interp *interp;			/* Interpreter in which the table is
					 * defined. */
    Tk_OptionTable table;		/* Table about which information is to
					 * be returned.  May not necessarily
					 * exist in the interpreter anymore. */
{
    OptionTable *tablePtr = (OptionTable *) table;
    Tcl_HashTable *hashTablePtr;
    Tcl_HashEntry *hashEntryPtr;
    Tcl_HashSearch search;
    Tcl_Obj *objPtr;

    objPtr = Tcl_NewObj();
    hashTablePtr = (Tcl_HashTable *) Tcl_GetAssocData(interp, OPTION_HASH_KEY,
	    NULL);
    if (hashTablePtr == NULL) {
	return objPtr;
    }

    /*
     * Scan all the tables for this interpreter to make sure that the
     * one we want still is valid.
     */

    for (hashEntryPtr = Tcl_FirstHashEntry(hashTablePtr, &search);
	    hashEntryPtr != NULL;
	    hashEntryPtr = Tcl_NextHashEntry(&search)) {
	if (tablePtr == (OptionTable *) Tcl_GetHashValue(hashEntryPtr)) {
	    for ( ; tablePtr != NULL; tablePtr = tablePtr->nextPtr) {
		Tcl_ListObjAppendElement((Tcl_Interp *) NULL, objPtr,
			Tcl_NewIntObj(tablePtr->refCount));
		Tcl_ListObjAppendElement((Tcl_Interp *) NULL, objPtr,
			Tcl_NewIntObj(tablePtr->numOptions));
		Tcl_ListObjAppendElement((Tcl_Interp *) NULL, objPtr,
			Tcl_NewStringObj(
				tablePtr->options[0].specPtr->optionName,
			-1));
	    }
	    break;
	}
    }
    return objPtr;
}
@


1.4
log
@touched all sources to ease next import
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tkConfig.c,v 1.7.6.2 2000/09/26 16:07:56 spolk Exp $
d69 1
d130 2
d145 1
a145 1
Tcl_ObjType optionType = {
d285 8
d300 2
a301 1
		|| (specPtr->type == TK_OPTION_CURSOR)) {
d468 1
a468 1
    char *value;
d554 7
d585 1
d588 1
d709 7
a715 3
	    if (Tcl_GetDoubleFromObj(interp, valuePtr, &new) 
		    != TCL_OK) {
		return TCL_ERROR;
d717 1
d748 1
a748 1
		    (char **) optionPtr->specPtr->clientData,
d794 18
d852 7
a858 2
	    if (Tk_GetReliefFromObj(interp, valuePtr, &new) != TCL_OK) {
		return TCL_ERROR;
d913 9
a921 4
	    
	    if (Tk_GetPixelsFromObj(interp, tkwin, valuePtr,
		    &new) != TCL_OK) {
		return TCL_ERROR;
d947 11
d1027 1
a1027 1
 * GetOptionFromObj --
d1034 1
a1034 2
 *	if no matching entry could be found.  If NULL is returned and
 *	interp is not NULL than an error message is left in its result.
d1040 1
a1040 3
 *	Information about the matching entry is cached in the object
 *	containing the name, so that future lookups can proceed more
 *	quickly.
d1046 4
a1049 6
GetOptionFromObj(interp, objPtr, tablePtr)
    Tcl_Interp *interp;		/* Used only for error reporting; if NULL
				 * no message is left after an error. */
    Tcl_Obj *objPtr;		/* Object whose string value is to be
				 * looked up in the option table. */
    OptionTable *tablePtr;	/* Table in which to look up objPtr. */
d1053 1
a1053 1
    char *p1, *p2, *name;
d1057 2
a1058 12
     * First, check to see if the object already has the answer cached.
     */

    if (objPtr->typePtr == &optionType) {
	if (objPtr->internalRep.twoPtrValue.ptr1 == (VOID *) tablePtr) {
	    return (Option *) objPtr->internalRep.twoPtrValue.ptr2;
	}
    }

    /*
     * The answer isn't cached.  Search through all of the option tables
     * in the chain to find the best match.  Some tricky aspects:
a1067 1
    name = Tcl_GetStringFromObj(objPtr, (int *) NULL);
d1104 59
a1166 1
    done:
d1173 1
a1173 1
    objPtr->typePtr = &optionType;
d1187 38
d1500 5
d1547 9
d1735 8
d1774 7
d2016 7
d2072 6
a2217 2


@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d4 2
a5 1
 *	This file contains the Tk_ConfigureWidget procedure.
d7 1
a7 2
 * Copyright (c) 1990-1994 The Regents of the University of California.
 * Copyright (c) 1994-1995 Sun Microsystems, Inc.
d12 1
a12 1
 * RCS: @@(#) $Id: tkConfig.c,v 1.8 1999/01/26 04:11:21 jingham Exp $
d15 15
d31 1062
a1092 6
#include "tk.h"

/*
 * Values for "flags" field of Tk_ConfigSpec structures.  Be sure
 * to coordinate these values with those defined in tk.h
 * (TK_CONFIG_COLOR_ONLY, etc.).  There must not be overlap!
d1094 1
a1094 2
 * INIT -		Non-zero means (char *) things have been
 *			converted to Tk_Uid's.
d1097 10
a1106 19
#define INIT		0x20

/*
 * Forward declarations for procedures defined later in this file:
 */

static int		DoConfig _ANSI_ARGS_((Tcl_Interp *interp,
			    Tk_Window tkwin, Tk_ConfigSpec *specPtr,
			    Tk_Uid value, int valueIsUid, char *widgRec));
static Tk_ConfigSpec *	FindConfigSpec _ANSI_ARGS_((Tcl_Interp *interp,
			    Tk_ConfigSpec *specs, char *argvName,
			    int needFlags, int hateFlags));
static char *		FormatConfigInfo _ANSI_ARGS_((Tcl_Interp *interp,
			    Tk_Window tkwin, Tk_ConfigSpec *specPtr,
			    char *widgRec));
static char *		FormatConfigValue _ANSI_ARGS_((Tcl_Interp *interp,
			    Tk_Window tkwin, Tk_ConfigSpec *specPtr,
			    char *widgRec, char *buffer,
			    Tcl_FreeProc **freeProcPtr));
d1111 1
a1111 1
 * Tk_ConfigureWidget --
d1113 2
a1114 3
 *	Process command-line options and database options to
 *	fill in fields of a widget record with resources and
 *	other parameters.
d1117 9
a1125 2
 *	A standard Tcl return value.  In case of an error,
 *	interp->result will hold an error message.
d1128 3
a1130 3
 *	The fields of widgRec get filled in with information
 *	from argc/argv and the option database.  Old information
 *	in widgRec's fields gets recycled.
d1136 35
a1170 27
Tk_ConfigureWidget(interp, tkwin, specs, argc, argv, widgRec, flags)
    Tcl_Interp *interp;		/* Interpreter for error reporting. */
    Tk_Window tkwin;		/* Window containing widget (needed to
				 * set up X resources). */
    Tk_ConfigSpec *specs;	/* Describes legal options. */
    int argc;			/* Number of elements in argv. */
    char **argv;		/* Command-line options. */
    char *widgRec;		/* Record whose fields are to be
				 * modified.  Values must be properly
				 * initialized. */
    int flags;			/* Used to specify additional flags
				 * that must be present in config specs
				 * for them to be considered.  Also,
				 * may have TK_CONFIG_ARGV_ONLY set. */
{
    register Tk_ConfigSpec *specPtr;
    Tk_Uid value;		/* Value of option from database. */
    int needFlags;		/* Specs must contain this set of flags
				 * or else they are not considered. */
    int hateFlags;		/* If a spec contains any bits here, it's
				 * not considered. */

    needFlags = flags & ~(TK_CONFIG_USER_BIT - 1);
    if (Tk_Depth(tkwin) <= 1) {
	hateFlags = TK_CONFIG_COLOR_ONLY;
    } else {
	hateFlags = TK_CONFIG_MONO_ONLY;
d1172 1
d1175 2
a1176 3
     * Pass one:  scan through all the option specs, replacing strings
     * with Tk_Uids (if this hasn't been done already) and clearing
     * the TK_CONFIG_OPTION_SPECIFIED flags.
d1179 46
a1224 11
    for (specPtr = specs; specPtr->type != TK_CONFIG_END; specPtr++) {
	if (!(specPtr->specFlags & INIT) && (specPtr->argvName != NULL)) {
	    if (specPtr->dbName != NULL) {
		specPtr->dbName = Tk_GetUid(specPtr->dbName);
	    }
	    if (specPtr->dbClass != NULL) {
		specPtr->dbClass = Tk_GetUid(specPtr->dbClass);
	    }
	    if (specPtr->defValue != NULL) {
		specPtr->defValue = Tk_GetUid(specPtr->defValue);
	    }
d1226 10
a1235 2
	specPtr->specFlags = (specPtr->specFlags & ~TK_CONFIG_OPTION_SPECIFIED)
		| INIT;
d1237 35
d1274 3
a1276 2
     * Pass two:  scan through all of the arguments, processing those
     * that match entries in the specs.
d1279 8
a1286 5
    for ( ; argc > 0; argc -= 2, argv += 2) {
	specPtr = FindConfigSpec(interp, specs, *argv, needFlags, hateFlags);
	if (specPtr == NULL) {
	    return TCL_ERROR;
	}
d1289 2
a1290 1
	 * Process the entry.
d1293 12
a1304 4
	if (argc < 2) {
	    Tcl_AppendResult(interp, "value for \"", *argv,
		    "\" missing", (char *) NULL);
	    return TCL_ERROR;
d1306 2
a1307 7
	if (DoConfig(interp, tkwin, specPtr, argv[1], 0, widgRec) != TCL_OK) {
	    char msg[100];

	    sprintf(msg, "\n    (processing \"%.40s\" option)",
		    specPtr->argvName);
	    Tcl_AddErrorInfo(interp, msg);
	    return TCL_ERROR;
a1308 2
	specPtr->specFlags |= TK_CONFIG_OPTION_SPECIFIED;
    }
d1310 3
a1312 6
    /*
     * Pass three:  scan through all of the specs again;  if no
     * command-line argument matched a spec, then check for info
     * in the option database.  If there was nothing in the
     * database, then use the default.
     */
d1314 82
a1395 25
    if (!(flags & TK_CONFIG_ARGV_ONLY)) {
	for (specPtr = specs; specPtr->type != TK_CONFIG_END; specPtr++) {
	    if ((specPtr->specFlags & TK_CONFIG_OPTION_SPECIFIED)
		    || (specPtr->argvName == NULL)
		    || (specPtr->type == TK_CONFIG_SYNONYM)) {
		continue;
	    }
	    if (((specPtr->specFlags & needFlags) != needFlags)
		    || (specPtr->specFlags & hateFlags)) {
		continue;
	    }
	    value = NULL;
	    if (specPtr->dbName != NULL) {
		value = Tk_GetOption(tkwin, specPtr->dbName, specPtr->dbClass);
	    }
	    if (value != NULL) {
		if (DoConfig(interp, tkwin, specPtr, value, 1, widgRec) !=
			TCL_OK) {
		    char msg[200];
    
		    sprintf(msg, "\n    (%s \"%.50s\" in widget \"%.50s\")",
			    "database entry for",
			    specPtr->dbName, Tk_PathName(tkwin));
		    Tcl_AddErrorInfo(interp, msg);
		    return TCL_ERROR;
d1397 2
a1398 15
	    } else {
		value = specPtr->defValue;
		if ((value != NULL) && !(specPtr->specFlags
			& TK_CONFIG_DONT_SET_DEFAULT)) {
		    if (DoConfig(interp, tkwin, specPtr, value, 1, widgRec) !=
			    TCL_OK) {
			char msg[200];
	
			sprintf(msg,
				"\n    (%s \"%.50s\" in widget \"%.50s\")",
				"default value for",
				specPtr->dbName, Tk_PathName(tkwin));
			Tcl_AddErrorInfo(interp, msg);
			return TCL_ERROR;
		    }
d1403 1
a1403 2

    return TCL_OK;
d1409 1
a1409 1
 * FindConfigSpec --
d1411 2
a1412 2
 *	Search through a table of configuration specs, looking for
 *	one that matches a given argvName.
d1415 1
a1415 3
 *	The return value is a pointer to the matching entry, or NULL
 *	if nothing matched.  In that case an error message is left
 *	in interp->result.
d1418 1
a1418 1
 *	None.
d1423 4
a1426 11
static Tk_ConfigSpec *
FindConfigSpec(interp, specs, argvName, needFlags, hateFlags)
    Tcl_Interp *interp;		/* Used for reporting errors. */
    Tk_ConfigSpec *specs;	/* Pointer to table of configuration
				 * specifications for a widget. */
    char *argvName;		/* Name (suitable for use in a "config"
				 * command) identifying particular option. */
    int needFlags;		/* Flags that must be present in matching
				 * entry. */
    int hateFlags;		/* Flags that must NOT be present in
				 * matching entry. */
d1428 2
a1429 4
    register Tk_ConfigSpec *specPtr;
    register char c;		/* First character of current argument. */
    Tk_ConfigSpec *matchPtr;	/* Matching spec, or NULL. */
    size_t length;
d1431 10
a1440 18
    c = argvName[1];
    length = strlen(argvName);
    matchPtr = NULL;
    for (specPtr = specs; specPtr->type != TK_CONFIG_END; specPtr++) {
	if (specPtr->argvName == NULL) {
	    continue;
	}
	if ((specPtr->argvName[1] != c)
		|| (strncmp(specPtr->argvName, argvName, length) != 0)) {
	    continue;
	}
	if (((specPtr->specFlags & needFlags) != needFlags)
		|| (specPtr->specFlags & hateFlags)) {
	    continue;
	}
	if (specPtr->argvName[length] == 0) {
	    matchPtr = specPtr;
	    goto gotMatch;
d1442 2
a1443 4
	if (matchPtr != NULL) {
	    Tcl_AppendResult(interp, "ambiguous option \"", argvName,
		    "\"", (char *) NULL);
	    return (Tk_ConfigSpec *) NULL;
a1444 1
	matchPtr = specPtr;
d1446 18
d1465 38
a1502 20
    if (matchPtr == NULL) {
	Tcl_AppendResult(interp, "unknown option \"", argvName,
		"\"", (char *) NULL);
	return (Tk_ConfigSpec *) NULL;
    }

    /*
     * Found a matching entry.  If it's a synonym, then find the
     * entry that it's a synonym for.
     */

    gotMatch:
    specPtr = matchPtr;
    if (specPtr->type == TK_CONFIG_SYNONYM) {
	for (specPtr = specs; ; specPtr++) {
	    if (specPtr->type == TK_CONFIG_END) {
		Tcl_AppendResult(interp,
			"couldn't find synonym for option \"",
			argvName, "\"", (char *) NULL);
		return (Tk_ConfigSpec *) NULL;
d1504 2
a1505 5
	    if ((specPtr->dbName == matchPtr->dbName) 
		    && (specPtr->type != TK_CONFIG_SYNONYM)
		    && ((specPtr->specFlags & needFlags) == needFlags)
		    && !(specPtr->specFlags & hateFlags)) {
		break;
a1508 1
    return specPtr;
d1512 1
a1512 1
 *--------------------------------------------------------------
d1514 1
a1514 1
 * DoConfig --
d1516 2
a1517 2
 *	This procedure applies a single configuration option
 *	to a widget record.
d1520 1
a1520 1
 *	A standard Tcl return value.
d1523 2
a1524 3
 *	WidgRec is modified as indicated by specPtr and value.
 *	The old value is recycled, if that is appropriate for
 *	the value type.
d1526 1
a1526 1
 *--------------------------------------------------------------
d1529 12
a1540 42
static int
DoConfig(interp, tkwin, specPtr, value, valueIsUid, widgRec)
    Tcl_Interp *interp;		/* Interpreter for error reporting. */
    Tk_Window tkwin;		/* Window containing widget (needed to
				 * set up X resources). */
    Tk_ConfigSpec *specPtr;	/* Specifier to apply. */
    char *value;		/* Value to use to fill in widgRec. */
    int valueIsUid;		/* Non-zero means value is a Tk_Uid;
				 * zero means it's an ordinary string. */
    char *widgRec;		/* Record whose fields are to be
				 * modified.  Values must be properly
				 * initialized. */
{
    char *ptr;
    Tk_Uid uid;
    int nullValue;

    nullValue = 0;
    if ((*value == 0) && (specPtr->specFlags & TK_CONFIG_NULL_OK)) {
	nullValue = 1;
    }

    do {
	ptr = widgRec + specPtr->offset;
	switch (specPtr->type) {
	    case TK_CONFIG_BOOLEAN:
		if (Tcl_GetBoolean(interp, value, (int *) ptr) != TCL_OK) {
		    return TCL_ERROR;
		}
		break;
	    case TK_CONFIG_INT:
		if (Tcl_GetInt(interp, value, (int *) ptr) != TCL_OK) {
		    return TCL_ERROR;
		}
		break;
	    case TK_CONFIG_DOUBLE:
		if (Tcl_GetDouble(interp, value, (double *) ptr) != TCL_OK) {
		    return TCL_ERROR;
		}
		break;
	    case TK_CONFIG_STRING: {
		char *old, *new;
d1542 5
a1546 23
		if (nullValue) {
		    new = NULL;
		} else {
		    new = (char *) ckalloc((unsigned) (strlen(value) + 1));
		    strcpy(new, value);
		}
		old = *((char **) ptr);
		if (old != NULL) {
		    ckfree(old);
		}
		*((char **) ptr) = new;
		break;
	    }
	    case TK_CONFIG_UID:
		if (nullValue) {
		    *((Tk_Uid *) ptr) = NULL;
		} else {
		    uid = valueIsUid ? (Tk_Uid) value : Tk_GetUid(value);
		    *((Tk_Uid *) ptr) = uid;
		}
		break;
	    case TK_CONFIG_COLOR: {
		XColor *newPtr, *oldPtr;
d1548 7
a1554 8
		if (nullValue) {
		    newPtr = NULL;
		} else {
		    uid = valueIsUid ? (Tk_Uid) value : Tk_GetUid(value);
		    newPtr = Tk_GetColor(interp, tkwin, uid);
		    if (newPtr == NULL) {
			return TCL_ERROR;
		    }
d1556 7
a1562 3
		oldPtr = *((XColor **) ptr);
		if (oldPtr != NULL) {
		    Tk_FreeColor(oldPtr);
d1564 10
a1573 2
		*((XColor **) ptr) = newPtr;
		break;
d1575 6
a1580 10
	    case TK_CONFIG_FONT: {
		Tk_Font new;

		if (nullValue) {
		    new = NULL;
		} else {
		    new = Tk_GetFont(interp, tkwin, value);
		    if (new == NULL) {
			return TCL_ERROR;
		    }
d1582 2
a1583 22
		Tk_FreeFont(*((Tk_Font *) ptr));
		*((Tk_Font *) ptr) = new;
		break;
	    }
	    case TK_CONFIG_BITMAP: {
		Pixmap new, old;

		if (nullValue) {
		    new = None;
	        } else {
		    uid = valueIsUid ? (Tk_Uid) value : Tk_GetUid(value);
		    new = Tk_GetBitmap(interp, tkwin, uid);
		    if (new == None) {
			return TCL_ERROR;
		    }
		}
		old = *((Pixmap *) ptr);
		if (old != None) {
		    Tk_FreeBitmap(Tk_Display(tkwin), old);
		}
		*((Pixmap *) ptr) = new;
		break;
d1585 6
a1590 82
	    case TK_CONFIG_BORDER: {
		Tk_3DBorder new, old;

		if (nullValue) {
		    new = NULL;
		} else {
		    uid = valueIsUid ? (Tk_Uid) value : Tk_GetUid(value);
		    new = Tk_Get3DBorder(interp, tkwin, uid);
		    if (new == NULL) {
			return TCL_ERROR;
		    }
		}
		old = *((Tk_3DBorder *) ptr);
		if (old != NULL) {
		    Tk_Free3DBorder(old);
		}
		*((Tk_3DBorder *) ptr) = new;
		break;
	    }
	    case TK_CONFIG_RELIEF:
		uid = valueIsUid ? (Tk_Uid) value : Tk_GetUid(value);
		if (Tk_GetRelief(interp, uid, (int *) ptr) != TCL_OK) {
		    return TCL_ERROR;
		}
		break;
	    case TK_CONFIG_CURSOR:
	    case TK_CONFIG_ACTIVE_CURSOR: {
		Tk_Cursor new, old;

		if (nullValue) {
		    new = None;
		} else {
		    uid = valueIsUid ? (Tk_Uid) value : Tk_GetUid(value);
		    new = Tk_GetCursor(interp, tkwin, uid);
		    if (new == None) {
			return TCL_ERROR;
		    }
		}
		old = *((Tk_Cursor *) ptr);
		if (old != None) {
		    Tk_FreeCursor(Tk_Display(tkwin), old);
		}
		*((Tk_Cursor *) ptr) = new;
		if (specPtr->type == TK_CONFIG_ACTIVE_CURSOR) {
		    Tk_DefineCursor(tkwin, new);
		}
		break;
	    }
	    case TK_CONFIG_JUSTIFY:
		uid = valueIsUid ? (Tk_Uid) value : Tk_GetUid(value);
		if (Tk_GetJustify(interp, uid, (Tk_Justify *) ptr) != TCL_OK) {
		    return TCL_ERROR;
		}
		break;
	    case TK_CONFIG_ANCHOR:
		uid = valueIsUid ? (Tk_Uid) value : Tk_GetUid(value);
		if (Tk_GetAnchor(interp, uid, (Tk_Anchor *) ptr) != TCL_OK) {
		    return TCL_ERROR;
		}
		break;
	    case TK_CONFIG_CAP_STYLE:
		uid = valueIsUid ? (Tk_Uid) value : Tk_GetUid(value);
		if (Tk_GetCapStyle(interp, uid, (int *) ptr) != TCL_OK) {
		    return TCL_ERROR;
		}
		break;
	    case TK_CONFIG_JOIN_STYLE:
		uid = valueIsUid ? (Tk_Uid) value : Tk_GetUid(value);
		if (Tk_GetJoinStyle(interp, uid, (int *) ptr) != TCL_OK) {
		    return TCL_ERROR;
		}
		break;
	    case TK_CONFIG_PIXELS:
		if (Tk_GetPixels(interp, tkwin, value, (int *) ptr)
			!= TCL_OK) {
		    return TCL_ERROR;
		}
		break;
	    case TK_CONFIG_MM:
		if (Tk_GetScreenMM(interp, tkwin, value, (double *) ptr)
			!= TCL_OK) {
		    return TCL_ERROR;
d1592 2
a1593 14
		break;
	    case TK_CONFIG_WINDOW: {
		Tk_Window tkwin2;

		if (nullValue) {
		    tkwin2 = NULL;
		} else {
		    tkwin2 = Tk_NameToWindow(interp, value, tkwin);
		    if (tkwin2 == NULL) {
			return TCL_ERROR;
		    }
		}
		*((Tk_Window *) ptr) = tkwin2;
		break;
d1595 7
a1601 5
	    case TK_CONFIG_CUSTOM:
		if ((*specPtr->customPtr->parseProc)(
			specPtr->customPtr->clientData, interp, tkwin,
			value, widgRec, specPtr->offset) != TCL_OK) {
		    return TCL_ERROR;
d1603 2
a1604 5
		break;
	    default: {
		sprintf(interp->result, "bad config table: unknown type %d",
			specPtr->type);
		return TCL_ERROR;
d1606 4
a1609 4
	}
	specPtr++;
    } while ((specPtr->argvName == NULL) && (specPtr->type != TK_CONFIG_END));
    return TCL_OK;
d1615 1
a1615 1
 * Tk_ConfigureInfo --
d1617 3
a1619 2
 *	Return information about the configuration options
 *	for a window, and their current values.
d1622 12
a1633 14
 *	Always returns TCL_OK.  Interp->result will be modified
 *	hold a description of either a single configuration option
 *	available for "widgRec" via "specs", or all the configuration
 *	options available.  In the "all" case, the result will
 *	available for "widgRec" via "specs".  The result will
 *	be a list, each of whose entries describes one option.
 *	Each entry will itself be a list containing the option's
 *	name for use on command lines, database name, database
 *	class, default value, and current value (empty string
 *	if none).  For options that are synonyms, the list will
 *	contain only two values:  name and synonym name.  If the
 *	"name" argument is non-NULL, then the only information
 *	returned is that for the named argument (i.e. the corresponding
 *	entry in the overall list is returned).
d1641 5
a1645 6
int
Tk_ConfigureInfo(interp, tkwin, specs, widgRec, argvName, flags)
    Tcl_Interp *interp;		/* Interpreter for error reporting. */
    Tk_Window tkwin;		/* Window corresponding to widgRec. */
    Tk_ConfigSpec *specs;	/* Describes legal options. */
    char *widgRec;		/* Record whose fields contain current
d1647 13
a1659 18
    char *argvName;		/* If non-NULL, indicates a single option
				 * whose info is to be returned.  Otherwise
				 * info is returned for all options. */
    int flags;			/* Used to specify additional flags
				 * that must be present in config specs
				 * for them to be considered. */
{
    register Tk_ConfigSpec *specPtr;
    int needFlags, hateFlags;
    char *list;
    char *leader = "{";

    needFlags = flags & ~(TK_CONFIG_USER_BIT - 1);
    if (Tk_Depth(tkwin) <= 1) {
	hateFlags = TK_CONFIG_COLOR_ONLY;
    } else {
	hateFlags = TK_CONFIG_MONO_ONLY;
    }
d1666 7
a1672 6
    Tcl_SetResult(interp, (char *) NULL, TCL_STATIC);
    if (argvName != NULL) {
	specPtr = FindConfigSpec(interp, specs, argvName, needFlags,
		hateFlags);
	if (specPtr == NULL) {
	    return TCL_ERROR;
d1674 1
a1674 3
	interp->result = FormatConfigInfo(interp, tkwin, specPtr, widgRec);
	interp->freeProc = TCL_DYNAMIC;
	return TCL_OK;
d1682 6
a1687 10
    for (specPtr = specs; specPtr->type != TK_CONFIG_END; specPtr++) {
	if ((argvName != NULL) && (specPtr->argvName != argvName)) {
	    continue;
	}
	if (((specPtr->specFlags & needFlags) != needFlags)
		|| (specPtr->specFlags & hateFlags)) {
	    continue;
	}
	if (specPtr->argvName == NULL) {
	    continue;
a1688 4
	list = FormatConfigInfo(interp, tkwin, specPtr, widgRec);
	Tcl_AppendResult(interp, leader, list, "}", (char *) NULL);
	ckfree(list);
	leader = " {";
d1690 1
a1690 1
    return TCL_OK;
d1696 1
a1696 1
 * FormatConfigInfo --
d1711 51
a1761 39
static char *
FormatConfigInfo(interp, tkwin, specPtr, widgRec)
    Tcl_Interp *interp;			/* Interpreter to use for things
					 * like floating-point precision. */
    Tk_Window tkwin;			/* Window corresponding to widget. */
    register Tk_ConfigSpec *specPtr;	/* Pointer to information describing
					 * option. */
    char *widgRec;			/* Pointer to record holding current
					 * values of info for widget. */
{
    char *argv[6], *result;
    char buffer[200];
    Tcl_FreeProc *freeProc = (Tcl_FreeProc *) NULL;

    argv[0] = specPtr->argvName;
    argv[1] = specPtr->dbName;
    argv[2] = specPtr->dbClass;
    argv[3] = specPtr->defValue;
    if (specPtr->type == TK_CONFIG_SYNONYM) {
	return Tcl_Merge(2, argv);
    }
    argv[4] = FormatConfigValue(interp, tkwin, specPtr, widgRec, buffer,
	    &freeProc);
    if (argv[1] == NULL) {
	argv[1] = "";
    }
    if (argv[2] == NULL) {
	argv[2] = "";
    }
    if (argv[3] == NULL) {
	argv[3] = "";
    }
    if (argv[4] == NULL) {
	argv[4] = "";
    }
    result = Tcl_Merge(5, argv);
    if (freeProc != NULL) {
	if ((freeProc == TCL_DYNAMIC) || (freeProc == (Tcl_FreeProc *) free)) {
	    ckfree(argv[4]);
d1763 1
a1763 1
	    (*freeProc)(argv[4]);
d1765 1
d1767 1
a1767 1
    return result;
d1773 1
a1773 1
 * FormatConfigValue --
d1775 4
a1778 2
 *	This procedure formats the current value of a configuration
 *	option.
d1781 2
a1782 6
 *	The return value is the formatted value of the option given
 *	by specPtr and widgRec.  If the value is static, so that it
 *	need not be freed, *freeProcPtr will be set to NULL;  otherwise
 *	*freeProcPtr will be set to the address of a procedure to
 *	free the result, and the caller must invoke this procedure
 *	when it is finished with the result.
d1790 18
a1807 26
static char *
FormatConfigValue(interp, tkwin, specPtr, widgRec, buffer, freeProcPtr)
    Tcl_Interp *interp;		/* Interpreter for use in real conversions. */
    Tk_Window tkwin;		/* Window corresponding to widget. */
    Tk_ConfigSpec *specPtr;	/* Pointer to information describing option.
				 * Must not point to a synonym option. */
    char *widgRec;		/* Pointer to record holding current
				 * values of info for widget. */
    char *buffer;		/* Static buffer to use for small values.
				 * Must have at least 200 bytes of storage. */
    Tcl_FreeProc **freeProcPtr;	/* Pointer to word to fill in with address
				 * of procedure to free the result, or NULL
				 * if result is static. */
{
    char *ptr, *result;

    *freeProcPtr = NULL;
    ptr = widgRec + specPtr->offset;
    result = "";
    switch (specPtr->type) {
	case TK_CONFIG_BOOLEAN:
	    if (*((int *) ptr) == 0) {
		result = "0";
	    } else {
		result = "1";
	    }
d1809 3
a1811 3
	case TK_CONFIG_INT:
	    sprintf(buffer, "%d", *((int *) ptr));
	    result = buffer;
d1813 3
a1815 3
	case TK_CONFIG_DOUBLE:
	    Tcl_PrintDouble(interp, *((double *) ptr), buffer);
	    result = buffer;
d1817 3
a1819 5
	case TK_CONFIG_STRING:
	    result = (*(char **) ptr);
	    if (result == NULL) {
		result = "";
	    }
d1821 5
a1825 5
	case TK_CONFIG_UID: {
	    Tk_Uid uid = *((Tk_Uid *) ptr);
	    if (uid != NULL) {
		result = uid;
	    }
d1828 2
a1829 2
	case TK_CONFIG_COLOR: {
	    XColor *colorPtr = *((XColor **) ptr);
d1831 1
a1831 1
		result = Tk_NameOfColor(colorPtr);
d1835 2
a1836 2
	case TK_CONFIG_FONT: {
	    Tk_Font tkfont = *((Tk_Font *) ptr);
d1838 1
a1838 1
		result = Tk_NameOfFont(tkfont);
d1842 2
a1843 2
	case TK_CONFIG_BITMAP: {
	    Pixmap pixmap = *((Pixmap *) ptr);
d1845 2
a1846 1
		result = Tk_NameOfBitmap(Tk_Display(tkwin), pixmap);
d1850 2
a1851 2
	case TK_CONFIG_BORDER: {
	    Tk_3DBorder border = *((Tk_3DBorder *) ptr);
d1853 1
a1853 1
		result = Tk_NameOf3DBorder(border);
d1857 3
a1859 2
	case TK_CONFIG_RELIEF:
	    result = Tk_NameOfRelief(*((int *) ptr));
d1861 3
a1863 3
	case TK_CONFIG_CURSOR:
	case TK_CONFIG_ACTIVE_CURSOR: {
	    Tk_Cursor cursor = *((Tk_Cursor *) ptr);
d1865 2
a1866 1
		result = Tk_NameOfCursor(Tk_Display(tkwin), cursor);
d1870 3
a1872 2
	case TK_CONFIG_JUSTIFY:
	    result = Tk_NameOfJustify(*((Tk_Justify *) ptr));
d1874 4
a1877 2
	case TK_CONFIG_ANCHOR:
	    result = Tk_NameOfAnchor(*((Tk_Anchor *) ptr));
d1879 3
a1881 2
	case TK_CONFIG_CAP_STYLE:
	    result = Tk_NameOfCapStyle(*((int *) ptr));
d1883 3
a1885 15
	case TK_CONFIG_JOIN_STYLE:
	    result = Tk_NameOfJoinStyle(*((int *) ptr));
	    break;
	case TK_CONFIG_PIXELS:
	    sprintf(buffer, "%d", *((int *) ptr));
	    result = buffer;
	    break;
	case TK_CONFIG_MM:
	    Tcl_PrintDouble(interp, *((double *) ptr), buffer);
	    result = buffer;
	    break;
	case TK_CONFIG_WINDOW: {
	    Tk_Window tkwin;

	    tkwin = *((Tk_Window *) ptr);
d1887 1
a1887 1
		result = Tk_PathName(tkwin);
d1891 6
a1896 7
	case TK_CONFIG_CUSTOM:
	    result = (*specPtr->customPtr->printProc)(
		    specPtr->customPtr->clientData, tkwin, widgRec,
		    specPtr->offset, freeProcPtr);
	    break;
	default: 
	    result = "?? unknown type ??";
d1898 1
a1898 1
    return result;
d1904 1
a1904 1
 * Tk_ConfigureValue --
d1907 1
a1907 1
 *	option for a widget.
d1910 4
a1913 4
 *	The return value is a standard Tcl completion code (TCL_OK or
 *	TCL_ERROR).  Interp->result will be set to hold either the value
 *	of the option given by argvName (if TCL_OK is returned) or
 *	an error message (if TCL_ERROR is returned).
d1921 6
a1926 6
int
Tk_ConfigureValue(interp, tkwin, specs, widgRec, argvName, flags)
    Tcl_Interp *interp;		/* Interpreter for error reporting. */
    Tk_Window tkwin;		/* Window corresponding to widgRec. */
    Tk_ConfigSpec *specs;	/* Describes legal options. */
    char *widgRec;		/* Record whose fields contain current
d1928 2
a1929 1
    char *argvName;		/* Gives the command-line name for the
d1931 24
a1954 10
    int flags;			/* Used to specify additional flags
				 * that must be present in config specs
				 * for them to be considered. */
{
    Tk_ConfigSpec *specPtr;
    int needFlags, hateFlags;

    needFlags = flags & ~(TK_CONFIG_USER_BIT - 1);
    if (Tk_Depth(tkwin) <= 1) {
	hateFlags = TK_CONFIG_COLOR_ONLY;
d1956 1
a1956 1
	hateFlags = TK_CONFIG_MONO_ONLY;
d1958 1
a1958 7
    specPtr = FindConfigSpec(interp, specs, argvName, needFlags, hateFlags);
    if (specPtr == NULL) {
	return TCL_ERROR;
    }
    interp->result = FormatConfigValue(interp, tkwin, specPtr, widgRec,
	    interp->result, &interp->freeProc);
    return TCL_OK;
d1964 1
a1964 1
 * Tk_FreeOptions --
d1966 3
a1968 1
 *	Free up all resources associated with configuration options.
d1971 8
a1978 1
 *	None.
d1981 1
a1981 3
 *	Any resource in widgRec that is controlled by a configuration
 *	option (e.g. a Tk_3DBorder or XColor) is freed in the appropriate
 *	fashion.
d1986 7
a1992 11
	/* ARGSUSED */
void
Tk_FreeOptions(specs, widgRec, display, needFlags)
    Tk_ConfigSpec *specs;	/* Describes legal options. */
    char *widgRec;		/* Record whose fields contain current
				 * values for options. */
    Display *display;		/* X display; needed for freeing some
				 * resources. */
    int needFlags;		/* Used to specify additional flags
				 * that must be present in config specs
				 * for them to be considered. */
d1994 17
a2010 2
    register Tk_ConfigSpec *specPtr;
    char *ptr;
d2012 15
a2026 40
    for (specPtr = specs; specPtr->type != TK_CONFIG_END; specPtr++) {
	if ((specPtr->specFlags & needFlags) != needFlags) {
	    continue;
	}
	ptr = widgRec + specPtr->offset;
	switch (specPtr->type) {
	    case TK_CONFIG_STRING:
		if (*((char **) ptr) != NULL) {
		    ckfree(*((char **) ptr));
		    *((char **) ptr) = NULL;
		}
		break;
	    case TK_CONFIG_COLOR:
		if (*((XColor **) ptr) != NULL) {
		    Tk_FreeColor(*((XColor **) ptr));
		    *((XColor **) ptr) = NULL;
		}
		break;
	    case TK_CONFIG_FONT:
		Tk_FreeFont(*((Tk_Font *) ptr));
		*((Tk_Font *) ptr) = NULL;
		break;
	    case TK_CONFIG_BITMAP:
		if (*((Pixmap *) ptr) != None) {
		    Tk_FreeBitmap(display, *((Pixmap *) ptr));
		    *((Pixmap *) ptr) = None;
		}
		break;
	    case TK_CONFIG_BORDER:
		if (*((Tk_3DBorder *) ptr) != NULL) {
		    Tk_Free3DBorder(*((Tk_3DBorder *) ptr));
		    *((Tk_3DBorder *) ptr) = NULL;
		}
		break;
	    case TK_CONFIG_CURSOR:
	    case TK_CONFIG_ACTIVE_CURSOR:
		if (*((Tk_Cursor *) ptr) != None) {
		    Tk_FreeCursor(display, *((Tk_Cursor *) ptr));
		    *((Tk_Cursor *) ptr) = None;
		}
d2029 1
d2031 2
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d4 1
a4 2
 *	This file contains procedures that manage configuration options
 *	for widgets and other things.
d6 2
a7 1
 * Copyright (c) 1997-1998 Sun Microsystems, Inc.
d12 1
a12 1
 * RCS: @@(#) $Id: tkConfig.c,v 1.7.6.2 2000/09/26 16:07:56 spolk Exp $
d15 1
a15 13
/*
 * Temporary flag for working on new config package.
 */

#if 0

/*
 * used only for removing the old config code
 */

#define __NO_OLD_CONFIG
#endif

a16 759
#include "tkInt.h"
#include "tkPort.h"
#include "tkFont.h"

/*
 * The following definition is an AssocData key used to keep track of
 * all of the option tables that have been created for an interpreter.
 */

#define OPTION_HASH_KEY "TkOptionTable"

/*
 * The following two structures are used along with Tk_OptionSpec
 * structures to manage configuration options.  Tk_OptionSpec is
 * static templates that are compiled into the code of a widget
 * or other object manager.  However, to look up options efficiently
 * we need to supplement the static information with additional
 * dynamic information, and this dynamic information may be different
 * for each application.  Thus we create structures of the following
 * two types to hold all of the dynamic information; this is done
 * by Tk_CreateOptionTable.
 * 
 * One of the following structures corresponds to each Tk_OptionSpec.
 * These structures exist as arrays inside TkOptionTable structures.
 */

typedef struct TkOption {
    CONST Tk_OptionSpec *specPtr;	/* The original spec from the template
					 * passed to Tk_CreateOptionTable.*/
    Tk_Uid dbNameUID;		 	/* The Uid form of the option database 
					 * name. */
    Tk_Uid dbClassUID;			/* The Uid form of the option database
					 * class name. */
    Tcl_Obj *defaultPtr;		/* Default value for this option. */
    union {
	Tcl_Obj *monoColorPtr;		/* For color and border options, this
					 * is an alternate default value to
					 * use on monochrome displays. */
	struct TkOption *synonymPtr;	/* For synonym options, this points to
					 * the master entry. */
    } extra;
    int flags;				/* Miscellaneous flag values; see
					 * below for definitions. */
} Option;

/*
 * Flag bits defined for Option structures:
 *
 * OPTION_NEEDS_FREEING -	1 means that FreeResources must be
 *				invoke to free resources associated with
 *				the option when it is no longer needed.
 */

#define OPTION_NEEDS_FREEING		1

/*
 * One of the following exists for each Tk_OptionSpec array that has
 * been passed to Tk_CreateOptionTable.
 */

typedef struct OptionTable {
    int refCount;			/* Counts the number of uses of this
					 * table (the number of times
					 * Tk_CreateOptionTable has returned
					 * it).  This can be greater than 1 if
					 * it is shared along several option
					 * table  chains, or if the same table
					 * is used for multiple purposes. */
    Tcl_HashEntry *hashEntryPtr;	/* Hash table entry that refers to this
					 * table; used to delete the entry. */
    struct OptionTable *nextPtr;	/* If templatePtr was part of a chain
					 * of templates, this points to the
					 * table corresponding to the next
					 * template in the chain. */
    int numOptions;			/* The number of items in the options
					 * array below. */
    Option options[1];			/* Information about the individual
					 * options in the table.  This must be
					 * the last field in the structure:
					 * the actual size of the array will
					 * be numOptions, not 1. */
} OptionTable;

/*
 * Forward declarations for procedures defined later in this file:
 */

static int		DoObjConfig _ANSI_ARGS_((Tcl_Interp *interp,
			    char *recordPtr, Option *optionPtr,
			    Tcl_Obj *valuePtr, Tk_Window tkwin, 
			    Tk_SavedOption *savePtr));
static void		DestroyOptionHashTable _ANSI_ARGS_((
			    ClientData clientData, Tcl_Interp *interp));
static void		FreeResources _ANSI_ARGS_((Option *optionPtr, 
			    Tcl_Obj *objPtr, char *internalPtr,
			    Tk_Window tkwin));
static Tcl_Obj *	GetConfigList _ANSI_ARGS_((char *recordPtr,
			    Option *optionPtr, Tk_Window tkwin));
static Tcl_Obj *	GetObjectForOption _ANSI_ARGS_((char *recordPtr,
			    Option *optionPtr, Tk_Window tkwin));
static Option *		GetOptionFromObj _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr, OptionTable *tablePtr));
static int		ObjectIsEmpty _ANSI_ARGS_((Tcl_Obj *objPtr));
static int		SetOptionFromAny _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr));

/*
 * The structure below defines an object type that is used to cache the
 * result of looking up an option name.  If an object has this type, then
 * its internalPtr1 field points to the OptionTable in which it was looked up,
 * and the internalPtr2 field points to the entry that matched.
 */

Tcl_ObjType optionType = {
    "option",				/* name */
    (Tcl_FreeInternalRepProc *) NULL,	/* freeIntRepProc */
    (Tcl_DupInternalRepProc *) NULL,	/* dupIntRepProc */
    (Tcl_UpdateStringProc *) NULL,	/* updateStringProc */
    SetOptionFromAny			/* setFromAnyProc */
};

/*
 *--------------------------------------------------------------
 *
 * Tk_CreateOptionTable --
 *
 *	Given a template for configuration options, this procedure
 *	creates a table that may be used to look up options efficiently.
 *
 * Results:
 *	Returns a token to a structure that can be passed to procedures
 *	such as Tk_InitOptions, Tk_SetOptions, and Tk_FreeConfigOptions.
 *
 * Side effects:
 *	Storage is allocated.
 *
 *--------------------------------------------------------------
 */

Tk_OptionTable
Tk_CreateOptionTable(interp, templatePtr)
    Tcl_Interp *interp;			/* Interpreter associated with the
					 * application in which this table
					 * will be used. */
    CONST Tk_OptionSpec *templatePtr;	/* Static information about the
					 * configuration options. */
{
    Tcl_HashTable *hashTablePtr;
    Tcl_HashEntry *hashEntryPtr;
    int newEntry;
    OptionTable *tablePtr;
    CONST Tk_OptionSpec *specPtr, *specPtr2;
    Option *optionPtr;
    int numOptions, i;

    /*
     * We use an AssocData value in the interpreter to keep a hash
     * table of all the option tables we've created for this application.
     * This is used for two purposes.  First, it allows us to share the
     * tables (e.g. in several chains) and second, we use the deletion
     * callback for the AssocData to delete all the option tables when
     * the interpreter is deleted.  The code below finds the hash table
     * or creates a new one if it doesn't already exist.
     */

    hashTablePtr = (Tcl_HashTable *) Tcl_GetAssocData(interp, OPTION_HASH_KEY,
	    NULL);
    if (hashTablePtr == NULL) {
	hashTablePtr = (Tcl_HashTable *) ckalloc(sizeof(Tcl_HashTable));
	Tcl_InitHashTable(hashTablePtr, TCL_ONE_WORD_KEYS);
	Tcl_SetAssocData(interp, OPTION_HASH_KEY, DestroyOptionHashTable,
		(ClientData) hashTablePtr);
    }

    /*
     * See if a table has already been created for this template.  If
     * so, just reuse the existing table.
     */

    hashEntryPtr = Tcl_CreateHashEntry(hashTablePtr, (char *) templatePtr,
	    &newEntry);
    if (!newEntry) {
	tablePtr = (OptionTable *) Tcl_GetHashValue(hashEntryPtr);
	tablePtr->refCount++;
	return (Tk_OptionTable) tablePtr;
    }

    /*
     * Count the number of options in the template, then create the
     * table structure.
     */

    numOptions = 0;
    for (specPtr = templatePtr; specPtr->type != TK_OPTION_END; specPtr++) {
	numOptions++;
    }
    tablePtr = (OptionTable *) (ckalloc(sizeof(OptionTable)
	    + ((numOptions - 1)  * sizeof(Option))));
    tablePtr->refCount = 1;
    tablePtr->hashEntryPtr = hashEntryPtr;
    tablePtr->nextPtr = NULL;
    tablePtr->numOptions = numOptions;

    /*
     * Initialize all of the Option structures in the table.
     */

    for (specPtr = templatePtr, optionPtr = tablePtr->options;
	    specPtr->type != TK_OPTION_END; specPtr++, optionPtr++) {
	optionPtr->specPtr = specPtr;
	optionPtr->dbNameUID = NULL;
	optionPtr->dbClassUID = NULL;
	optionPtr->defaultPtr = NULL;
	optionPtr->extra.monoColorPtr = NULL;
	optionPtr->flags = 0;

	if (specPtr->type == TK_OPTION_SYNONYM) {
	    /*
	     * This is a synonym option; find the master option that it
	     * refers to and create a pointer from the synonym to the
	     * master.
	     */

	    for (specPtr2 = templatePtr, i = 0; ; specPtr2++, i++) {
		if (specPtr2->type == TK_OPTION_END) {
		    panic("Tk_CreateOptionTable couldn't find synonym");
		}
		if (strcmp(specPtr2->optionName,
			(char *) specPtr->clientData) == 0) {
		    optionPtr->extra.synonymPtr = tablePtr->options + i;
		    break;
		}
	    }
	} else {
	    if (specPtr->dbName != NULL) {
		optionPtr->dbNameUID = Tk_GetUid(specPtr->dbName);
	    }
	    if (specPtr->dbClass != NULL) {
		optionPtr->dbClassUID = 
			Tk_GetUid(specPtr->dbClass);
	    }
	    if (specPtr->defValue != NULL) {
		optionPtr->defaultPtr =
			Tcl_NewStringObj(specPtr->defValue, -1);
		Tcl_IncrRefCount(optionPtr->defaultPtr);
	    }
	    if (((specPtr->type == TK_OPTION_COLOR)
		    || (specPtr->type == TK_OPTION_BORDER))
		    && (specPtr->clientData != NULL)) {
		optionPtr->extra.monoColorPtr =
			Tcl_NewStringObj((char *) specPtr->clientData, -1);
		Tcl_IncrRefCount(optionPtr->extra.monoColorPtr);
	    }
	}
	if (((specPtr->type == TK_OPTION_STRING)
		&& (specPtr->internalOffset >= 0))
		|| (specPtr->type == TK_OPTION_COLOR)
		|| (specPtr->type == TK_OPTION_FONT)
		|| (specPtr->type == TK_OPTION_BITMAP)
		|| (specPtr->type == TK_OPTION_BORDER)
		|| (specPtr->type == TK_OPTION_CURSOR)) {
	    optionPtr->flags |= OPTION_NEEDS_FREEING;
	}
    }
    tablePtr->hashEntryPtr = hashEntryPtr;
    Tcl_SetHashValue(hashEntryPtr, tablePtr);

    /*
     * Finally, check to see if this template chains to another template
     * with additional options.  If so, call ourselves recursively to
     * create the next table(s).
     */

    if (specPtr->clientData != NULL) {
	tablePtr->nextPtr = (OptionTable *) Tk_CreateOptionTable(interp,
		(Tk_OptionSpec *) specPtr->clientData);
    }

    return (Tk_OptionTable) tablePtr;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_DeleteOptionTable --
 *
 *	Called to release resources used by an option table when 
 *	the table is no longer needed.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The option table and associated resources (such as additional
 *	option tables chained off it) are destroyed.
 *
 *----------------------------------------------------------------------
 */

void
Tk_DeleteOptionTable(optionTable)
    Tk_OptionTable optionTable;		/* The option table to delete. */
{
    OptionTable *tablePtr = (OptionTable *) optionTable;
    Option *optionPtr;
    int count;

    tablePtr->refCount--;
    if (tablePtr->refCount > 0) {
	return;
    }

    if (tablePtr->nextPtr != NULL) {
	Tk_DeleteOptionTable((Tk_OptionTable) tablePtr->nextPtr);
    }

    for (count = tablePtr->numOptions - 1, optionPtr = tablePtr->options;
	    count > 0;  count--, optionPtr++) {
	if (optionPtr->defaultPtr != NULL) {
	    Tcl_DecrRefCount(optionPtr->defaultPtr);
	}
	if (((optionPtr->specPtr->type == TK_OPTION_COLOR)
		|| (optionPtr->specPtr->type == TK_OPTION_BORDER))
		&& (optionPtr->extra.monoColorPtr != NULL)) {
	    Tcl_DecrRefCount(optionPtr->extra.monoColorPtr);
	}
    }
    Tcl_DeleteHashEntry(tablePtr->hashEntryPtr);
    ckfree((char *) tablePtr);
}

/*
 *----------------------------------------------------------------------
 *
 * DestroyOptionHashTable --
 *
 *	This procedure is the deletion callback associated with the
 *	AssocData entry created by Tk_CreateOptionTable.  It is
 *	invoked when an interpreter is deleted, and deletes all of
 *	the option tables associated with that interpreter.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The option hash table is destroyed along with all of the
 *	OptionTable structures that it refers to.
 *
 *----------------------------------------------------------------------
 */

static void
DestroyOptionHashTable(clientData, interp)
    ClientData clientData;	/* The hash table we are destroying */
    Tcl_Interp *interp;		/* The interpreter we are destroying */
{
    Tcl_HashTable *hashTablePtr = (Tcl_HashTable *) clientData;
    Tcl_HashSearch search;
    Tcl_HashEntry *hashEntryPtr;
    OptionTable *tablePtr;

    for (hashEntryPtr = Tcl_FirstHashEntry(hashTablePtr, &search);
	    hashEntryPtr != NULL;
	    hashEntryPtr = Tcl_NextHashEntry(&search)) {
	tablePtr = (OptionTable *) Tcl_GetHashValue(hashEntryPtr);

	/*
	 * The following statements do two tricky things:
	 * 1. They ensure that the option table is deleted, even if
	 *    there are outstanding references to it.
	 * 2. They ensure that Tk_DeleteOptionTable doesn't delete
	 *    other tables chained from this one; we'll do it when
	 *    we come across the hash table entry for the chained
	 *    table (in fact, the chained table may already have
	 *    been deleted).
	 */

	tablePtr->refCount = 1;
	tablePtr->nextPtr = NULL;
	Tk_DeleteOptionTable((Tk_OptionTable) tablePtr);
    }
    Tcl_DeleteHashTable(hashTablePtr);
    ckfree((char *) hashTablePtr);
}

/*
 *--------------------------------------------------------------
 *
 * Tk_InitOptions --
 *
 *	This procedure is invoked when an object such as a widget
 *	is created.  It supplies an initial value for each configuration
 *	option (the value may come from the option database, a system
 *	default, or the default in the option table).
 *
 * Results:
 *	The return value is TCL_OK if the procedure completed
 *	successfully, and TCL_ERROR if one of the initial values was
 *	bogus.  If an error occurs and interp isn't NULL, then an
 *	error message will be left in its result.
 *
 * Side effects:
 *	Fields of recordPtr are filled in with initial values.
 *
 *--------------------------------------------------------------
 */

int
Tk_InitOptions(interp, recordPtr, optionTable, tkwin)
    Tcl_Interp *interp;		/* Interpreter for error reporting.    NULL
				 * means don't leave an error message. */
    char *recordPtr;		/* Pointer to the record to configure.
				 * Note: the caller should have properly
				 * initialized the record with NULL
				 * pointers for each option value. */
    Tk_OptionTable optionTable;	/* The token which matches the config
				 * specs for the widget in question. */
    Tk_Window tkwin;		/* Certain options types (such as
				 * TK_OPTION_COLOR) need fields out
				 * of the window they are used in to
				 * be able to calculate their values.
				 * Not needed unless one of these
				 * options is in the configSpecs record. */
{
    OptionTable *tablePtr = (OptionTable *) optionTable;
    Option *optionPtr;
    int count;
    char *value;
    Tcl_Obj *valuePtr;
    enum {
	OPTION_DATABASE, SYSTEM_DEFAULT, TABLE_DEFAULT
    } source;

    /*
     * If this table chains to other tables, handle their initialization
     * first.  That way, if both tables refer to the same field of the
     * record, the value in the first table will win.
     */

    if (tablePtr->nextPtr != NULL) {
	if (Tk_InitOptions(interp, recordPtr,
		(Tk_OptionTable) tablePtr->nextPtr, tkwin) != TCL_OK) {
	    return TCL_ERROR;
	}
    }

    /*
     * Iterate over all of the options in the table, initializing each in
     * turn.
     */

    for (optionPtr = tablePtr->options, count = tablePtr->numOptions;
	    count > 0; optionPtr++, count--) {

	/*
	 * If we specify TK_OPTION_DONT_SET_DEFAULT, then the user has
	 * processed and set a default for this already.
	 */
	if ((optionPtr->specPtr->type == TK_OPTION_SYNONYM) ||
		(optionPtr->specPtr->flags & TK_OPTION_DONT_SET_DEFAULT)) {
	    continue;
	}
	source = TABLE_DEFAULT;

	/*
	 * We look in three places for the initial value, using the first
	 * non-NULL value that we find.  First, check the option database.
	 */

	valuePtr = NULL;
	if (optionPtr->dbNameUID != NULL) {
	    value = Tk_GetOption(tkwin, optionPtr->dbNameUID, 
		    optionPtr->dbClassUID);
	    if (value != NULL) {
		valuePtr = Tcl_NewStringObj(value, -1);
		source = OPTION_DATABASE;
	    }
	}

	/*
	 * Second, check for a system-specific default value.
	 */
	if ((valuePtr == NULL)
		&& (optionPtr->dbNameUID != NULL)) {
	    valuePtr = TkpGetSystemDefault(tkwin, optionPtr->dbNameUID,
		    optionPtr->dbClassUID);
	    if (valuePtr != NULL) {
		source = SYSTEM_DEFAULT;
	    }
	}

	/*
	 * Third and last, use the default value supplied by the option
	 * table.  In the case of color objects, we pick one of two
	 * values depending on whether the screen is mono or color.
	 */

	if (valuePtr == NULL) {
	    if ((tkwin != NULL) 
		    && ((optionPtr->specPtr->type == TK_OPTION_COLOR)
		    || (optionPtr->specPtr->type == TK_OPTION_BORDER))
		    && (Tk_Depth(tkwin) <= 1) 
		    && (optionPtr->extra.monoColorPtr != NULL)) {
		valuePtr = optionPtr->extra.monoColorPtr;
	    } else {
		valuePtr = optionPtr->defaultPtr;
	    }
	}

	if (valuePtr == NULL) {
	    continue;
	}

	if (DoObjConfig(interp, recordPtr, optionPtr, valuePtr, tkwin,
		(Tk_SavedOption *) NULL) != TCL_OK) {
	    if (interp != NULL) {
		char msg[200];
    
		switch (source) {
		    case OPTION_DATABASE:
			sprintf(msg, "\n    (database entry for \"%.50s\")",
				optionPtr->specPtr->optionName);
			break;
		    case SYSTEM_DEFAULT:
			sprintf(msg, "\n    (system default for \"%.50s\")",
				optionPtr->specPtr->optionName);
			break;
		    case TABLE_DEFAULT:
			sprintf(msg, "\n    (default value for \"%.50s\")",
				optionPtr->specPtr->optionName);
		}
		if (tkwin != NULL) {
		    sprintf(msg + strlen(msg) - 1, " in widget \"%.50s\")",
			    Tk_PathName(tkwin));
		}
		Tcl_AddErrorInfo(interp, msg);
	    }
	    return TCL_ERROR;
	}
    }
    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * DoObjConfig --
 *
 *	This procedure applies a new value for a configuration option
 *	to the record being configured.
 *
 * Results:
 *	The return value is TCL_OK if the procedure completed
 *	successfully.  If an error occurred then TCL_ERROR is
 *	returned and an error message is left in interp's result, if
 *	interp isn't NULL.  In addition, if oldValuePtrPtr isn't
 *	NULL then it *oldValuePtrPtr is filled in with a pointer
 *	to the option's old value.
 *
 * Side effects:
 *	RecordPtr gets modified to hold the new value in the form of
 *	a Tcl_Obj, an internal representation, or both.  The old
 *	value is freed if oldValuePtrPtr is NULL.
 *
 *--------------------------------------------------------------
 */

static int
DoObjConfig(interp, recordPtr, optionPtr, valuePtr, tkwin, savedOptionPtr)
    Tcl_Interp *interp;		/* Interpreter for error reporting.  If
				 * NULL, then no message is left if an error
				 * occurs. */
    char *recordPtr;		/* The record to modify to hold the new
				 * option value. */
    Option *optionPtr;		/* Pointer to information about the
				 * option. */
    Tcl_Obj *valuePtr;		/* New value for option. */
    Tk_Window tkwin;		/* Window in which option will be used (needed
				 * to allocate resources for some options).
				 * May be NULL if the option doesn't
				 * require window-related resources. */
    Tk_SavedOption *savedOptionPtr;
				/* If NULL, the old value for the option will
				 * be freed. If non-NULL, the old value will
				 * be stored here, and it becomes the property
				 * of the caller (the caller must eventually
				 * free the old value). */
{
    Tcl_Obj **slotPtrPtr, *oldPtr;
    char *internalPtr;		/* Points to location in record where
				 * internal representation of value should
				 * be stored, or NULL. */
    char *oldInternalPtr;	/* Points to location in which to save old
				 * internal representation of value. */
    Tk_SavedOption internal;	/* Used to save the old internal representation
				 * of the value if savedOptionPtr is NULL. */
    CONST Tk_OptionSpec *specPtr;
    int nullOK;

    /*
     * Save the old object form for the value, if there is one.
     */

    specPtr = optionPtr->specPtr;
    if (specPtr->objOffset >= 0) {
	slotPtrPtr = (Tcl_Obj **) (recordPtr + specPtr->objOffset);
	oldPtr = *slotPtrPtr;
    } else {
	slotPtrPtr = NULL;
	oldPtr = NULL;
    }

    /*
     * Apply the new value in a type-specific way.  Also remember the
     * old object and internal forms, if they exist.
     */

    if (specPtr->internalOffset >= 0) {
	internalPtr = recordPtr + specPtr->internalOffset;
    } else {
	internalPtr = NULL;
    }
    if (savedOptionPtr != NULL) {
	savedOptionPtr->optionPtr = optionPtr;
	savedOptionPtr->valuePtr = oldPtr;
	oldInternalPtr = (char *) &savedOptionPtr->internalForm;
    } else {
	oldInternalPtr = (char *) &internal.internalForm;
    }
    nullOK = (optionPtr->specPtr->flags & TK_OPTION_NULL_OK);
    switch (optionPtr->specPtr->type) {
	case TK_OPTION_BOOLEAN: {
	    int new;

	    if (Tcl_GetBooleanFromObj(interp, valuePtr, &new)
		    != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (internalPtr != NULL) {
		*((int *) oldInternalPtr) = *((int *) internalPtr);
		*((int *) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_INT: {
	    int new;
	    
	    if (Tcl_GetIntFromObj(interp, valuePtr, &new) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (internalPtr != NULL) {
		*((int *) oldInternalPtr) = *((int *) internalPtr);
		*((int *) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_DOUBLE: {
	    double new;
	    
	    if (Tcl_GetDoubleFromObj(interp, valuePtr, &new) 
		    != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (internalPtr != NULL) {
		*((double *) oldInternalPtr) = *((double *) internalPtr);
		*((double *) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_STRING: {
	    char *new, *value;
	    int length;

	    if (nullOK && ObjectIsEmpty(valuePtr)) {
		valuePtr = NULL;
	    }
	    if (internalPtr != NULL) {
		if (valuePtr != NULL) {
		    value = Tcl_GetStringFromObj(valuePtr, &length);
		    new = ckalloc((unsigned) (length + 1));
		    strcpy(new, value);
		} else {
		    new = NULL;
		}
		*((char **) oldInternalPtr) = *((char **) internalPtr);
		*((char **) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_STRING_TABLE: {
	    int new;

	    if (Tcl_GetIndexFromObj(interp, valuePtr,
		    (char **) optionPtr->specPtr->clientData,
		    optionPtr->specPtr->optionName+1, 0, &new) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (internalPtr != NULL) {
		*((int *) oldInternalPtr) = *((int *) internalPtr);
		*((int *) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_COLOR: {
	    XColor *newPtr;

	    if (nullOK && ObjectIsEmpty(valuePtr)) {
		valuePtr = NULL;
		newPtr = NULL;
	    } else {
		newPtr = Tk_AllocColorFromObj(interp, tkwin, valuePtr);
		if (newPtr == NULL) {
		    return TCL_ERROR;
		}
	    }
	    if (internalPtr != NULL) {
		*((XColor **) oldInternalPtr) = *((XColor **) internalPtr);
		*((XColor **) internalPtr) = newPtr;
	    }
	    break;
	}
	case TK_OPTION_FONT: {
	    Tk_Font new;

	    if (nullOK && ObjectIsEmpty(valuePtr)) {
		valuePtr = NULL;
		new = NULL;
	    } else {
		new = Tk_AllocFontFromObj(interp, tkwin, valuePtr);
		if (new == NULL) {
		    return TCL_ERROR;
		}
	    }
	    if (internalPtr != NULL) {
		*((Tk_Font *) oldInternalPtr) = *((Tk_Font *) internalPtr);
		*((Tk_Font *) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_BITMAP: {
	    Pixmap new;

	    if (nullOK && ObjectIsEmpty(valuePtr)) {
		valuePtr = NULL;
		new = None;
	    } else {
		new = Tk_AllocBitmapFromObj(interp, tkwin, valuePtr);
		if (new == None) {
		    return TCL_ERROR;
		}
	    }
	    if (internalPtr != NULL) {
		*((Pixmap *) oldInternalPtr) = *((Pixmap *) internalPtr);
		*((Pixmap *) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_BORDER: {
	    Tk_3DBorder new;
a17 136
	    if (nullOK && ObjectIsEmpty(valuePtr)) {
		valuePtr = NULL;
		new = NULL;
	    } else {
		new = Tk_Alloc3DBorderFromObj(interp, tkwin, valuePtr);
		if (new == NULL) {
		    return TCL_ERROR;
		}
	    }
	    if (internalPtr != NULL) {
		*((Tk_3DBorder *) oldInternalPtr) =
			*((Tk_3DBorder *) internalPtr);
		*((Tk_3DBorder *) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_RELIEF: {
	    int new;

	    if (Tk_GetReliefFromObj(interp, valuePtr, &new) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (internalPtr != NULL) {
		*((int *) oldInternalPtr) = *((int *) internalPtr);
		*((int *) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_CURSOR: {
	    Tk_Cursor new;

	    if (nullOK && ObjectIsEmpty(valuePtr)) {
		new = None;
		valuePtr = NULL;
	    } else {
		new = Tk_AllocCursorFromObj(interp, tkwin, valuePtr);
		if (new == None) {
		    return TCL_ERROR;
		}
	    }
	    if (internalPtr != NULL) {
		*((Tk_Cursor *) oldInternalPtr) = *((Tk_Cursor *) internalPtr);
		*((Tk_Cursor *) internalPtr) = new;
	    }
	    Tk_DefineCursor(tkwin, new);
	    break;
	}
	case TK_OPTION_JUSTIFY: {
	    Tk_Justify new;

	    if (Tk_GetJustifyFromObj(interp, valuePtr, &new) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (internalPtr != NULL) {
		*((Tk_Justify *) oldInternalPtr)
			= *((Tk_Justify *) internalPtr);
		*((Tk_Justify *) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_ANCHOR: {
	    Tk_Anchor new;

	    if (Tk_GetAnchorFromObj(interp, valuePtr, &new) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (internalPtr != NULL) {
		*((Tk_Anchor *) oldInternalPtr)
			= *((Tk_Anchor *) internalPtr);
		*((Tk_Anchor *) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_PIXELS: {
	    int new;
	    
	    if (Tk_GetPixelsFromObj(interp, tkwin, valuePtr,
		    &new) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (internalPtr != NULL) {
		*((int *) oldInternalPtr) = *((int *) internalPtr);
		*((int *) internalPtr) = new;
	    }
	    break;
	}
	case TK_OPTION_WINDOW: {
	    Tk_Window new;

	    if (nullOK && ObjectIsEmpty(valuePtr)) {
		valuePtr = NULL;
		new = None;
	    } else {
		if (TkGetWindowFromObj(interp, tkwin, valuePtr, &new)
			!= TCL_OK) {
		    return TCL_ERROR;
		}
	    }
	    if (internalPtr != NULL) {
		*((Tk_Window *) oldInternalPtr) = *((Tk_Window *) internalPtr);
		*((Tk_Window *) internalPtr) = new;
	    }
	    break;
	}
	default: {
	    char buf[40+TCL_INTEGER_SPACE];
	    sprintf(buf, "bad config table: unknown type %d",
		    optionPtr->specPtr->type);
	    Tcl_SetResult(interp, buf, TCL_VOLATILE);
	    return TCL_ERROR;
	}
    }

    /*
     * Release resources associated with the old value, if we're not
     * returning it to the caller, then install the new object value into
     * the record.
     */

    if (savedOptionPtr == NULL) {
	if (optionPtr->flags & OPTION_NEEDS_FREEING) {
	    FreeResources(optionPtr, oldPtr, oldInternalPtr, tkwin);
	}
	if (oldPtr != NULL) {
	    Tcl_DecrRefCount(oldPtr);
	}
    }
    if (slotPtrPtr != NULL) {
	*slotPtrPtr = valuePtr;
	if (valuePtr != NULL) {
	    Tcl_IncrRefCount(valuePtr);
	}
    }
    return TCL_OK;
}

d19 3
a21 164
 *----------------------------------------------------------------------
 *
 * ObjectIsEmpty --
 *
 *	This procedure tests whether the string value of an object is
 *	empty.
 *
 * Results:
 *	The return value is 1 if the string value of objPtr has length
 *	zero, and 0 otherwise.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
ObjectIsEmpty(objPtr)
    Tcl_Obj *objPtr;		/* Object to test.  May be NULL. */
{
    int length;

    if (objPtr == NULL) {
	return 1;
    }
    if (objPtr->bytes != NULL) {
	return (objPtr->length == 0);
    }
    Tcl_GetStringFromObj(objPtr, &length);
    return (length == 0);
}

/*
 *----------------------------------------------------------------------
 *
 * GetOptionFromObj --
 *
 *	This procedure searches through a chained option table to find
 *	the entry for a particular option name.
 *
 * Results:
 *	The return value is a pointer to the matching entry, or NULL
 *	if no matching entry could be found.  If NULL is returned and
 *	interp is not NULL than an error message is left in its result.
 *	Note: if the matching entry is a synonym then this procedure
 *	returns a pointer to the synonym entry, *not* the "real" entry
 *	that the synonym refers to.
 *
 * Side effects:
 *	Information about the matching entry is cached in the object
 *	containing the name, so that future lookups can proceed more
 *	quickly.
 *
 *----------------------------------------------------------------------
 */

static Option *
GetOptionFromObj(interp, objPtr, tablePtr)
    Tcl_Interp *interp;		/* Used only for error reporting; if NULL
				 * no message is left after an error. */
    Tcl_Obj *objPtr;		/* Object whose string value is to be
				 * looked up in the option table. */
    OptionTable *tablePtr;	/* Table in which to look up objPtr. */
{
    Option *bestPtr, *optionPtr;
    OptionTable *tablePtr2;
    char *p1, *p2, *name;
    int count;

    /*
     * First, check to see if the object already has the answer cached.
     */

    if (objPtr->typePtr == &optionType) {
	if (objPtr->internalRep.twoPtrValue.ptr1 == (VOID *) tablePtr) {
	    return (Option *) objPtr->internalRep.twoPtrValue.ptr2;
	}
    }

    /*
     * The answer isn't cached.  Search through all of the option tables
     * in the chain to find the best match.  Some tricky aspects:
     *
     * 1. We have to accept unique abbreviations.
     * 2. The same name could appear in different tables in the chain.
     *    If this happens, we use the entry from the first table. We
     *    have to be careful to distinguish this case from an ambiguous
     *    abbreviation.
     */

    bestPtr = NULL;
    name = Tcl_GetStringFromObj(objPtr, (int *) NULL);
    for (tablePtr2 = tablePtr; tablePtr2 != NULL;
	    tablePtr2 = tablePtr2->nextPtr) {
	for (optionPtr = tablePtr2->options, count = tablePtr2->numOptions;
		count > 0; optionPtr++, count--) {
	    for (p1 = name, p2 = optionPtr->specPtr->optionName;
		    *p1 == *p2; p1++, p2++) {
		if (*p1 == 0) {
		    /*
		     * This is an exact match.  We're done.
		     */

		    bestPtr = optionPtr;
		    goto done;
		}
	    }
	    if (*p1 == 0) {
		/*
		 * The name is an abbreviation for this option.  Keep
		 * to make sure that the abbreviation only matches one
		 * option name.  If we've already found a match in the
		 * past, then it is an error unless the full names for
		 * the two options are identical; in this case, the first
		 * option overrides the second.
		 */

		if (bestPtr == NULL) {
		    bestPtr = optionPtr;
		} else {
		    if (strcmp(bestPtr->specPtr->optionName,
			    optionPtr->specPtr->optionName) != 0) {
			goto error;
		    }
		}
	    }
	}
    }
    if (bestPtr == NULL) {
	goto error;
    }

    done:
    if ((objPtr->typePtr != NULL)
	    && (objPtr->typePtr->freeIntRepProc != NULL)) {
	objPtr->typePtr->freeIntRepProc(objPtr);
    }
    objPtr->internalRep.twoPtrValue.ptr1 = (VOID *) tablePtr;
    objPtr->internalRep.twoPtrValue.ptr2 = (VOID *) bestPtr;
    objPtr->typePtr = &optionType;
    return bestPtr;

    error:
    if (interp != NULL) {
	Tcl_AppendResult(interp, "unknown option \"", name,
		"\"", (char *) NULL);
    }
    return NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * SetOptionFromAny --
 *
 *	This procedure is called to convert a Tcl object to option
 *	internal form. However, this doesn't make sense (need to have a
 *	table of options in order to do the conversion) so the
 *	procedure always generates an error.
 *
 * Results:
 *	The return value is always TCL_ERROR, and an error message is
 *	left in interp's result if interp isn't NULL. 
d23 8
a30 4
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
d33 13
a45 10
static int
SetOptionFromAny(interp, objPtr)
    Tcl_Interp *interp;		/* Used for error reporting if not NULL. */
    register Tcl_Obj *objPtr;	/* The object to convert. */
{
    Tcl_AppendToObj(Tcl_GetObjResult(interp),
	    "can't convert value to option except via GetOptionFromObj API",
	    -1);
    return TCL_ERROR;
}
d50 1
a50 1
 * Tk_SetOptions --
d52 3
a54 2
 *	Process one or more name-value pairs for configuration options
 *	and fill in fields of a record with new values.
d57 2
a58 9
 *	If all goes well then TCL_OK is returned and the old values of
 *	any modified objects are saved in *savePtr, if it isn't NULL (the
 *	caller must eventually call Tk_RestoreSavedOptions or
 *	Tk_FreeSavedOptions to free the contents of *savePtr).  In
 *	addition, if maskPtr isn't NULL then *maskPtr is filled in with
 *	the OR of the typeMask bits from all modified options.  If an
 *	error occurs then TCL_ERROR is returned and a message 
 *	is left in interp's result unless interp is NULL; nothing is
 *	saved in *savePtr or *maskPtr in this case.
d61 3
a63 3
 *	The fields of recordPtr get filled in with object pointers
 *	from objc/objv.  Old information in widgRec's fields gets 
 * 	recycled.  Information may be left at *savePtr.
d69 27
a95 35
Tk_SetOptions(interp, recordPtr, optionTable, objc, objv, tkwin, savePtr,
	maskPtr)
    Tcl_Interp *interp;			/* Interpreter for error reporting.
					 * If NULL, then no error message is
					 * returned.*/
    char *recordPtr;	    		/* The record to configure. */
    Tk_OptionTable optionTable;		/* Describes valid options. */
    int objc;				/* The number of elements in objv. */
    Tcl_Obj *CONST objv[];		/* Contains one or more name-value
					 * pairs. */
    Tk_Window tkwin;			/* Window associated with the thing
					 * being configured; needed for some
					 * options (such as colors). */
    Tk_SavedOptions *savePtr;		/* If non-NULL, the old values of
					 * modified options are saved here
					 * so that they can be restored
					 * after an error. */
    int *maskPtr;			/* It non-NULL, this word is modified
					 * on a successful return to hold the
					 * bit-wise OR of the typeMask fields
					 * of all options that were modified
					 * by this call.  Used by the caller
					 * to figure out which options
					 * actually changed. */
{
    OptionTable *tablePtr = (OptionTable *) optionTable;
    Option *optionPtr;
    Tk_SavedOptions *lastSavePtr, *newSavePtr;
    int mask;

    if (savePtr != NULL) {
	savePtr->recordPtr = recordPtr;
	savePtr->tkwin = tkwin;
	savePtr->numItems = 0;
	savePtr->nextPtr = NULL;
a96 1
    lastSavePtr = savePtr;
d99 3
a101 2
     * Scan through all of the arguments, processing those
     * that match entries in the option table.
d104 11
a114 43
    mask = 0;
    for ( ; objc > 0; objc -= 2, objv += 2) {
	optionPtr = GetOptionFromObj(interp, objv[0], tablePtr);
	if (optionPtr == NULL) {
	    goto error;
	}
	if (optionPtr->specPtr->type == TK_OPTION_SYNONYM) {
	    optionPtr = optionPtr->extra.synonymPtr;
	}

	if (objc < 2) {
	    if (interp != NULL) {
		Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
			"value for \"", Tcl_GetStringFromObj(*objv, NULL),
			"\" missing", (char *) NULL);
		goto error;
	    }
	}
	if ((savePtr != NULL)
		&& (lastSavePtr->numItems >= TK_NUM_SAVED_OPTIONS)) {
	    /*
	     * We've run out of space for saving old option values.  Allocate
	     * more space.
	     */

	    newSavePtr = (Tk_SavedOptions *) ckalloc(sizeof(
		    Tk_SavedOptions));
	    newSavePtr->recordPtr = recordPtr;
	    newSavePtr->tkwin = tkwin;
	    newSavePtr->numItems = 0;
	    newSavePtr->nextPtr = NULL;
	    lastSavePtr->nextPtr = newSavePtr;
	    lastSavePtr = newSavePtr;
	}
	if (DoObjConfig(interp, recordPtr, optionPtr, objv[1], tkwin,
		(savePtr != NULL) ? &lastSavePtr->items[lastSavePtr->numItems]
		: (Tk_SavedOption *) NULL) != TCL_OK) {
	    char msg[100];

	    sprintf(msg, "\n    (processing \"%.40s\" option)",
		    Tcl_GetStringFromObj(*objv, NULL));
	    Tcl_AddErrorInfo(interp, msg);
	    goto error;
d116 2
a117 13
	if (savePtr != NULL) {
	    lastSavePtr->numItems++;
	}
	mask |= optionPtr->specPtr->typeMask;
    }
    if (maskPtr != NULL) {
	*maskPtr = mask;
    }
    return TCL_OK;

    error:
    if (savePtr != NULL) {
	Tk_RestoreSavedOptions(savePtr);
a118 35
    return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_RestoreSavedOptions --
 *
 *	This procedure undoes the effect of a previous call to
 *	Tk_SetOptions by restoring all of the options to their value
 *	before the call to Tk_SetOptions.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The configutation record is restored and all the information
 *	stored in savePtr is freed.
 *
 *----------------------------------------------------------------------
 */

void
Tk_RestoreSavedOptions(savePtr)
    Tk_SavedOptions *savePtr;	/* Holds saved option information; must
				 * have been passed to Tk_SetOptions. */
{
    int i;
    Option *optionPtr;
    Tcl_Obj *newPtr;		/* New object value of option, which we
				 * replace with old value and free.  Taken
				 * from record. */
    char *internalPtr;		/* Points to internal value of option in
				 * record. */
    CONST Tk_OptionSpec *specPtr;
d121 2
a122 3
     * Be sure to restore the options in the opposite order they were
     * set.  This is important because it's possible that the same
     * option name was used twice in a single call to Tk_SetOptions.
d125 5
a129 8
    if (savePtr->nextPtr != NULL) {
	Tk_RestoreSavedOptions(savePtr->nextPtr);
	ckfree((char *) savePtr->nextPtr);
	savePtr->nextPtr = NULL;
    }
    for (i = savePtr->numItems - 1; i >= 0; i--) {
	optionPtr = savePtr->items[i].optionPtr;
	specPtr = optionPtr->specPtr;
d132 1
a132 2
	 * First free the new value of the option, which is currently
	 * in the record.
d135 4
a138 4
	if (specPtr->objOffset >= 0) {
	    newPtr = *((Tcl_Obj **) (savePtr->recordPtr + specPtr->objOffset));
	} else {
	    newPtr = NULL;
d140 7
a146 10
	if (specPtr->internalOffset >= 0) {
	    internalPtr = savePtr->recordPtr + specPtr->internalOffset;
	} else {
	    internalPtr = NULL;
	}
	if (optionPtr->flags & OPTION_NEEDS_FREEING) {
	    FreeResources(optionPtr, newPtr, internalPtr, savePtr->tkwin);
	}
	if (newPtr != NULL) {
	    Tcl_DecrRefCount(newPtr);
d148 2
d151 6
a156 3
	/*
	 * Now restore the old value of the option.
	 */
d158 25
a182 82
	if (specPtr->objOffset >= 0) {
	    *((Tcl_Obj **) (savePtr->recordPtr + specPtr->objOffset))
		    = savePtr->items[i].valuePtr;
	}
	if (specPtr->internalOffset >= 0) {
	    switch (specPtr->type) {
		case TK_OPTION_BOOLEAN: {
		    *((int *) internalPtr)
			    = *((int *) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_INT: {
		    *((int *) internalPtr)
			    = *((int *) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_DOUBLE: {
		    *((double *) internalPtr)
			    = *((double *) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_STRING: {
		    *((char **) internalPtr)
			    = *((char **) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_STRING_TABLE: {
		    *((int *) internalPtr)
			    = *((int *) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_COLOR: {
		    *((XColor **) internalPtr)
			    = *((XColor **) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_FONT: {
		    *((Tk_Font *) internalPtr)
			    = *((Tk_Font *) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_BITMAP: {
		    *((Pixmap *) internalPtr)
			    = *((Pixmap *) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_BORDER: {
		    *((Tk_3DBorder *) internalPtr)
			    = *((Tk_3DBorder *) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_RELIEF: {
		    *((int *) internalPtr)
			    = *((int *) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_CURSOR: {
		    *((Tk_Cursor *) internalPtr)
			    = *((Tk_Cursor *) &savePtr->items[i].internalForm);
		    Tk_DefineCursor(savePtr->tkwin,
			    *((Tk_Cursor *) internalPtr));
		    break;
		}
		case TK_OPTION_JUSTIFY: {
		    *((Tk_Justify *) internalPtr)
			    = *((Tk_Justify *) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_ANCHOR: {
		    *((Tk_Anchor *) internalPtr)
			    = *((Tk_Anchor *) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_PIXELS: {
		    *((int *) internalPtr)
			    = *((int *) &savePtr->items[i].internalForm);
		    break;
		}
		case TK_OPTION_WINDOW: {
		    *((Tk_Window *) internalPtr)
			    = *((Tk_Window *) &savePtr->items[i].internalForm);
		    break;
d184 15
a198 2
		default: {
		    panic("bad option type in Tk_RestoreSavedOptions");
d203 2
a204 1
    savePtr->numItems = 0;
d210 1
a210 1
 * Tk_FreeSavedOptions --
d212 2
a213 2
 *	Free all of the saved configuration option values from a
 *	previous call to Tk_SetOptions.
d216 3
a218 1
 *	None.
d221 1
a221 1
 *	Storage and system resources are freed.
d226 11
a236 4
void
Tk_FreeSavedOptions(savePtr)
    Tk_SavedOptions *savePtr;	/* Contains options saved in a previous
				 * call to Tk_SetOptions. */
d238 4
a241 2
    int count;
    Tk_SavedOption *savedOptionPtr;
d243 18
a260 10
    if (savePtr->nextPtr != NULL) {
	Tk_FreeSavedOptions(savePtr->nextPtr);
	ckfree((char *) savePtr->nextPtr);
    }
    for (count = savePtr->numItems,
	    savedOptionPtr = &savePtr->items[savePtr->numItems-1];
	    count > 0;  count--, savedOptionPtr--) {
	if (savedOptionPtr->optionPtr->flags & OPTION_NEEDS_FREEING) {
	    FreeResources(savedOptionPtr->optionPtr, savedOptionPtr->valuePtr,
		    (char *) &savedOptionPtr->internalForm, savePtr->tkwin);
d262 4
a265 2
	if (savedOptionPtr->valuePtr != NULL) {
	    Tcl_DecrRefCount(savedOptionPtr->valuePtr);
d267 7
a274 18
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_FreeConfigOptions --
 *
 *	Free all resources associated with configuration options.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	All of the Tcl_Obj's in recordPtr that are controlled by
 *	configuration options in optionTable are freed.
 *
 *----------------------------------------------------------------------
 */
d276 14
a289 38
	/* ARGSUSED */
void
Tk_FreeConfigOptions(recordPtr, optionTable, tkwin)
    char *recordPtr;		/* Record whose fields contain current
				 * values for options. */
    Tk_OptionTable optionTable;	/* Describes legal options. */
    Tk_Window tkwin;		/* Window associated with recordPtr; needed
				 * for freeing some options. */
{
    OptionTable *tablePtr;
    Option *optionPtr;
    int count;
    Tcl_Obj **oldPtrPtr, *oldPtr; 
    char *oldInternalPtr;
    CONST Tk_OptionSpec *specPtr;

    for (tablePtr = (OptionTable *) optionTable; tablePtr != NULL;
	    tablePtr = tablePtr->nextPtr) {
	for (optionPtr = tablePtr->options, count = tablePtr->numOptions;
		count > 0; optionPtr++, count--) {
	    specPtr = optionPtr->specPtr;
	    if (specPtr->type == TK_OPTION_SYNONYM) {
		continue;
	    }
	    if (specPtr->objOffset >= 0) {
		oldPtrPtr = (Tcl_Obj **) (recordPtr + specPtr->objOffset);
		oldPtr = *oldPtrPtr;
		*oldPtrPtr = NULL;
	    } else {
		oldPtr = NULL;
	    }
	    if (specPtr->internalOffset >= 0) {
		oldInternalPtr = recordPtr + specPtr->internalOffset;
	    } else {
		oldInternalPtr = NULL;
	    }
	    if (optionPtr->flags & OPTION_NEEDS_FREEING) {
		FreeResources(optionPtr, oldPtr, oldInternalPtr, tkwin);
d291 5
a295 2
	    if (oldPtr != NULL) {
		Tcl_DecrRefCount(oldPtr);
d299 1
d303 1
a303 1
 *----------------------------------------------------------------------
d305 1
a305 1
 * FreeResources --
d307 2
a308 2
 *	Free system resources associated with a configuration option,
 *	such as colors or fonts.
d311 1
a311 1
 *	None.
d314 3
a316 2
 *	Any system resources associated with objPtr are released.  However,
 *	objPtr itself is not freed.
d318 1
a318 1
 *----------------------------------------------------------------------
d321 42
a362 12
static void
FreeResources(optionPtr, objPtr, internalPtr, tkwin)
    Option *optionPtr;		/* Description of the configuration option. */
    Tcl_Obj *objPtr;		/* The current value of the option, specified
				 * as an object. */
    char *internalPtr;		/* A pointer to an internal representation for
				 * the option's value, such as an int or
				 * (XColor *).  Only valid if
				 * optionPtr->specPtr->internalOffset >= 0. */
    Tk_Window tkwin;		/* The window in which this option is used. */
{
    int internalFormExists;
d364 23
a386 5
    /*
     * If there exists an internal form for the value, use it to free
     * resources (also zero out the internal form).  If there is no
     * internal form, then use the object form.
     */
d388 12
a399 7
    internalFormExists = optionPtr->specPtr->internalOffset >= 0;
    switch (optionPtr->specPtr->type) {
	case TK_OPTION_STRING:
	    if (internalFormExists) {
		if (*((char **) internalPtr) != NULL) {
		    ckfree(*((char **) internalPtr));
		    *((char **) internalPtr) = NULL;
d401 2
d404 30
a433 6
	    break;
	case TK_OPTION_COLOR:
	    if (internalFormExists) {
		if (*((XColor **) internalPtr) != NULL) {
		    Tk_FreeColor(*((XColor **) internalPtr));
		    *((XColor **) internalPtr) = NULL;
d435 2
a436 2
	    } else if (objPtr != NULL) {
		Tk_FreeColorFromObj(tkwin, objPtr);
d438 82
a519 14
	    break;
	case TK_OPTION_FONT:
	    if (internalFormExists) {
		Tk_FreeFont(*((Tk_Font *) internalPtr));
		*((Tk_Font *) internalPtr) = NULL;
	    } else if (objPtr != NULL) {
		Tk_FreeFontFromObj(tkwin, objPtr);
	    }
	    break;
	case TK_OPTION_BITMAP:
	    if (internalFormExists) {
		if (*((Pixmap *) internalPtr) != None) {
		    Tk_FreeBitmap(Tk_Display(tkwin), *((Pixmap *) internalPtr));
		    *((Pixmap *) internalPtr) = None;
d521 11
a531 9
	    } else if (objPtr != NULL) {
		Tk_FreeBitmapFromObj(tkwin, objPtr);
	    }
	    break;
	case TK_OPTION_BORDER:
	    if (internalFormExists) {
		if (*((Tk_3DBorder *) internalPtr) != NULL) {
		    Tk_Free3DBorder(*((Tk_3DBorder *) internalPtr));
		    *((Tk_3DBorder *) internalPtr) = NULL;
d533 2
a534 2
	    } else if (objPtr != NULL) {
		Tk_Free3DBorderFromObj(tkwin, objPtr);
d536 5
a540 7
	    break;
	case TK_OPTION_CURSOR:
	    if (internalFormExists) {
		if (*((Tk_Cursor *) internalPtr) != None) {
		    Tk_FreeCursor(Tk_Display(tkwin),
			    *((Tk_Cursor *) internalPtr));
		    *((Tk_Cursor *) internalPtr) = None;
d542 5
a546 2
	    } else if (objPtr != NULL) {
		Tk_FreeCursorFromObj(tkwin, objPtr);
d548 4
a551 4
	    break;
	default:
	    break;
    }
d557 1
a557 1
 * Tk_GetOptionInfo --
d559 2
a560 3
 *	Returns a list object containing complete information about
 *	either a single option or all the configuration options in a
 *	table.
d563 14
a576 12
 *	This procedure normally returns a pointer to an object.
 *	If namePtr isn't NULL, then the result object is a list with
 *	five elements: the option's name, its database name, database
 *	class, default value, and current value.  If the option is a
 *	synonym then the list will contain only two values: the option
 *	name and the name of the option it refers to.  If namePtr is
 *	NULL, then information is returned for every option in the
 *	option table: the result will have one sub-list (in the form
 *	described above) for each option in the table.  If an error
 *	occurs (e.g. because namePtr isn't valid) then NULL is returned
 *	and an error message will be left in interp's result unless
 *	interp is NULL.
d584 6
a589 5
Tcl_Obj *
Tk_GetOptionInfo(interp, recordPtr, optionTable, namePtr, tkwin)
    Tcl_Interp *interp;		/* Interpreter for error reporting.  If	
				 * NULL, then no error message is created. */
    char *recordPtr;		/* Record whose fields contain current
d591 18
a608 13
    Tk_OptionTable optionTable;	/* Describes all the legal options. */
    Tcl_Obj *namePtr;		/* If non-NULL, the string value selects
				 * a single option whose info is to be
				 * returned.  Otherwise info is returned for
				 * all options in optionTable. */
    Tk_Window tkwin;		/* Window associated with recordPtr; needed
				 * to compute correct default value for some
				 * options. */
{
    Tcl_Obj *resultPtr;
    OptionTable *tablePtr = (OptionTable *) optionTable;
    Option *optionPtr;
    int count;
d615 6
a620 7
    if (namePtr != NULL) {
	optionPtr = GetOptionFromObj(interp, namePtr, tablePtr);
	if (optionPtr == NULL) {
	    return (Tcl_Obj *) NULL;
	}
	if (optionPtr->specPtr->type == TK_OPTION_SYNONYM) {
	    optionPtr = optionPtr->extra.synonymPtr;
d622 3
a624 1
	return GetConfigList(recordPtr, optionPtr, tkwin);
d632 10
a641 6
    resultPtr = Tcl_NewListObj(0, (Tcl_Obj **) NULL);
    for (; tablePtr != NULL; tablePtr = tablePtr->nextPtr) {
	for (optionPtr = tablePtr->options, count = tablePtr->numOptions;
		count > 0; optionPtr++, count--) {
	    Tcl_ListObjAppendElement(interp, resultPtr,
		    GetConfigList(recordPtr, optionPtr, tkwin));
d643 4
d648 1
a648 1
    return resultPtr;
d654 1
a654 1
 * GetConfigList --
d669 39
a707 51
static Tcl_Obj *
GetConfigList(recordPtr, optionPtr, tkwin)
    char *recordPtr;		/* Pointer to record holding current
				 * values of configuration options. */
    Option *optionPtr;		/* Pointer to information describing a
				 * particular option. */
    Tk_Window tkwin;		/* Window corresponding to recordPtr. */
{
    Tcl_Obj *listPtr, *elementPtr;

    listPtr = Tcl_NewListObj(0, (Tcl_Obj **) NULL);
    Tcl_ListObjAppendElement((Tcl_Interp *) NULL, listPtr, 
	    Tcl_NewStringObj(optionPtr->specPtr->optionName, -1));

    if (optionPtr->specPtr->type == TK_OPTION_SYNONYM) {
	elementPtr = Tcl_NewStringObj(
		optionPtr->extra.synonymPtr->specPtr->optionName, -1);
	Tcl_ListObjAppendElement((Tcl_Interp *) NULL, listPtr, elementPtr);
    } else {
	if (optionPtr->dbNameUID == NULL) {
	    elementPtr = Tcl_NewObj();
	} else {
	    elementPtr = Tcl_NewStringObj(optionPtr->dbNameUID, -1);
	}
	Tcl_ListObjAppendElement((Tcl_Interp *) NULL, listPtr, elementPtr);

	if (optionPtr->dbClassUID == NULL) {
	    elementPtr = Tcl_NewObj();
	} else {
	    elementPtr = Tcl_NewStringObj(optionPtr->dbClassUID, -1);
	}
	Tcl_ListObjAppendElement((Tcl_Interp *) NULL, listPtr, elementPtr);

	if ((tkwin != NULL) && ((optionPtr->specPtr->type == TK_OPTION_COLOR)
		|| (optionPtr->specPtr->type == TK_OPTION_BORDER))
		&& (Tk_Depth(tkwin) <= 1)
		&& (optionPtr->extra.monoColorPtr != NULL)) {
	    elementPtr = optionPtr->extra.monoColorPtr;
	} else if (optionPtr->defaultPtr != NULL) {
	    elementPtr = optionPtr->defaultPtr;
	} else {
	    elementPtr = Tcl_NewObj();
	}
	Tcl_ListObjAppendElement((Tcl_Interp *) NULL, listPtr, elementPtr);

	if (optionPtr->specPtr->objOffset >= 0) {
	    elementPtr = *((Tcl_Obj **) (recordPtr
		    + optionPtr->specPtr->objOffset));
	    if (elementPtr == NULL) {
		elementPtr = Tcl_NewObj();
	    }
d709 1
a709 1
	    elementPtr = GetObjectForOption(recordPtr, optionPtr, tkwin);
a710 1
	Tcl_ListObjAppendElement((Tcl_Interp *) NULL, listPtr, elementPtr);
d712 1
a712 1
    return listPtr;
d718 1
a718 1
 * GetObjectForOption --
d720 2
a721 4
 *	This procedure is called to create an object that contains the
 *	value for an option.  It is invoked by GetConfigList and
 *	Tk_GetOptionValue when only the internal form of an option is
 *	stored in the record.
d724 6
a729 2
 *	The return value is a pointer to a Tcl object.  The caller
 *	must call Tcl_IncrRefCount on this object to preserve it.
d737 26
a762 18
static Tcl_Obj *
GetObjectForOption(recordPtr, optionPtr, tkwin)
    char *recordPtr;		/* Pointer to record holding current
				 * values of configuration options. */
    Option *optionPtr;		/* Pointer to information describing an
				 * option whose internal value is stored
				 * in *recordPtr. */
    Tk_Window tkwin;		/* Window corresponding to recordPtr. */
{
    Tcl_Obj *objPtr;
    char *internalPtr;		/* Points to internal value of option in
				 * record. */

    internalPtr = recordPtr + optionPtr->specPtr->internalOffset;
    objPtr = NULL;
    switch (optionPtr->specPtr->type) {
	case TK_OPTION_BOOLEAN: {
	    objPtr = Tcl_NewIntObj(*((int *) internalPtr));
d764 3
a766 3
	}
	case TK_OPTION_INT: {
	    objPtr = Tcl_NewIntObj(*((int *) internalPtr));
d768 3
a770 3
	}
	case TK_OPTION_DOUBLE: {
	    objPtr = Tcl_NewDoubleObj(*((double *) internalPtr));
d772 5
a776 3
	}
	case TK_OPTION_STRING: {
	    objPtr = Tcl_NewStringObj(*((char **) internalPtr), -1);
d778 5
a782 5
	}
	case TK_OPTION_STRING_TABLE: {
	    objPtr = Tcl_NewStringObj(
		    ((char **) optionPtr->specPtr->clientData)[
		    *((int *) internalPtr)], -1);
d785 2
a786 2
	case TK_OPTION_COLOR: { 
	    XColor *colorPtr = *((XColor **) internalPtr);
d788 1
a788 1
		objPtr = Tcl_NewStringObj(Tk_NameOfColor(colorPtr), -1);
d792 2
a793 2
	case TK_OPTION_FONT: {
	    Tk_Font tkfont = *((Tk_Font *) internalPtr);
d795 1
a795 1
		objPtr = Tcl_NewStringObj(Tk_NameOfFont(tkfont), -1);
d799 2
a800 2
	case TK_OPTION_BITMAP: {
	    Pixmap pixmap = *((Pixmap *) internalPtr);
d802 1
a802 2
		objPtr = Tcl_NewStringObj(Tk_NameOfBitmap(Tk_Display(tkwin),
			pixmap), -1);
d806 2
a807 2
	case TK_OPTION_BORDER: {
	    Tk_3DBorder border = *((Tk_3DBorder *) internalPtr);
d809 1
a809 1
		objPtr = Tcl_NewStringObj(Tk_NameOf3DBorder(border), -1);
d813 2
a814 3
	case TK_OPTION_RELIEF: {
	    objPtr = Tcl_NewStringObj(Tk_NameOfRelief(
		    *((int *) internalPtr)), -1);
d816 3
a818 3
	}
	case TK_OPTION_CURSOR: {
	    Tk_Cursor cursor = *((Tk_Cursor *) internalPtr);
d820 1
a820 2
		objPtr = Tcl_NewStringObj(
			Tk_NameOfCursor(Tk_Display(tkwin), cursor), -1);
d824 2
a825 3
	case TK_OPTION_JUSTIFY: {
	    objPtr = Tcl_NewStringObj(Tk_NameOfJustify(
		    *((Tk_Justify *) internalPtr)), -1);
d827 12
a838 4
	}
	case TK_OPTION_ANCHOR: {
	    objPtr = Tcl_NewStringObj(Tk_NameOfAnchor(
		    *((Tk_Anchor *) internalPtr)), -1);
d840 3
a842 3
	}
	case TK_OPTION_PIXELS: {
	    objPtr = Tcl_NewIntObj(*((int *) internalPtr));
d844 4
a847 3
	}
	case TK_OPTION_WINDOW: {
	    Tk_Window tkwin = *((Tk_Window *) internalPtr);
d849 1
a849 1
		objPtr = Tcl_NewStringObj(Tk_PathName(tkwin), -1);
d853 7
a859 6
	default: {
	    panic("bad option type in GetObjectForOption");
	}
    }
    if (objPtr == NULL) {
	objPtr = Tcl_NewObj();
d861 1
a861 1
    return objPtr;
d867 1
a867 1
 * Tk_GetOptionValue --
d870 1
a870 1
 *	option.
d873 4
a876 4
 *	The return value is the object holding the current value of
 *	the option given by namePtr.  If no such option exists, then
 *	the return value is NULL and an error message is left in
 *	interp's result (if interp isn't NULL).
d884 6
a889 6
Tcl_Obj *
Tk_GetOptionValue(interp, recordPtr, optionTable, namePtr, tkwin)
    Tcl_Interp *interp;		/* Interpreter for error reporting.  If
				 * NULL then no messages are provided for
				 * errors. */
    char *recordPtr;		/* Record whose fields contain current
d891 1
a891 2
    Tk_OptionTable optionTable;	/* Describes legal options. */
    Tcl_Obj *namePtr;		/* Gives the command-line name for the
d893 10
a902 24
    Tk_Window tkwin;		/* Window corresponding to recordPtr. */
{
    OptionTable *tablePtr = (OptionTable *) optionTable;
    Option *optionPtr;
    Tcl_Obj *resultPtr;

    optionPtr = GetOptionFromObj(interp, namePtr, tablePtr);
    if (optionPtr == NULL) {
	return NULL;
    }
    if (optionPtr->specPtr->type == TK_OPTION_SYNONYM) {
	optionPtr = optionPtr->extra.synonymPtr;
    }
    if (optionPtr->specPtr->objOffset >= 0) {
	resultPtr = *((Tcl_Obj **) (recordPtr + optionPtr->specPtr->objOffset));
	if (resultPtr == NULL) {
	    /*
	     * This option has a null value and is represented by a null
	     * object pointer.  We can't return the null pointer, since that
	     * would indicate an error.  Instead, return a new empty object.
	     */
    
	    resultPtr = Tcl_NewObj();
	} 
d904 1
a904 1
	resultPtr = GetObjectForOption(recordPtr, optionPtr, tkwin);
d906 7
a912 1
    return resultPtr;
d918 1
a918 1
 * TkDebugConfig --
d920 1
a920 3
 *	This is a debugging procedure that returns information about
 *	one of the configuration tables that currently exists for an
 *	interpreter.
d923 1
a923 8
 *	If the specified table exists in the given interpreter, then a
 *	list is returned describing the table and any other tables that
 *	it chains to: for each table there will be three list elements
 *	giving the reference count for the table, the number of elements
 *	in the table, and the command-line name for the first option
 *	in the table.  If the table doesn't exist in the interpreter
 *	then an empty object is returned.  The reference count for the
 *	returned object is 0.
d926 3
a928 1
 *	None.
d933 11
a943 7
Tcl_Obj *
TkDebugConfig(interp, table)
    Tcl_Interp *interp;			/* Interpreter in which the table is
					 * defined. */
    Tk_OptionTable table;		/* Table about which information is to
					 * be returned.  May not necessarily
					 * exist in the interpreter anymore. */
d945 2
a946 12
    OptionTable *tablePtr = (OptionTable *) table;
    Tcl_HashTable *hashTablePtr;
    Tcl_HashEntry *hashEntryPtr;
    Tcl_HashSearch search;
    Tcl_Obj *objPtr;

    objPtr = Tcl_NewObj();
    hashTablePtr = (Tcl_HashTable *) Tcl_GetAssocData(interp, OPTION_HASH_KEY,
	    NULL);
    if (hashTablePtr == NULL) {
	return objPtr;
    }
d948 40
a987 20
    /*
     * Scan all the tables for this interpreter to make sure that the
     * one we want still is valid.
     */

    for (hashEntryPtr = Tcl_FirstHashEntry(hashTablePtr, &search);
	    hashEntryPtr != NULL;
	    hashEntryPtr = Tcl_NextHashEntry(&search)) {
	if (tablePtr == (OptionTable *) Tcl_GetHashValue(hashEntryPtr)) {
	    for ( ; tablePtr != NULL; tablePtr = tablePtr->nextPtr) {
		Tcl_ListObjAppendElement((Tcl_Interp *) NULL, objPtr,
			Tcl_NewIntObj(tablePtr->refCount));
		Tcl_ListObjAppendElement((Tcl_Interp *) NULL, objPtr,
			Tcl_NewIntObj(tablePtr->numOptions));
		Tcl_ListObjAppendElement((Tcl_Interp *) NULL, objPtr,
			Tcl_NewStringObj(
				tablePtr->options[0].specPtr->optionName,
			-1));
	    }
	    break;
a989 1
    return objPtr;
a990 2


@


1.1.1.3
log
@import tk 8.4.0
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tkConfig.c,v 1.18 2002/08/05 04:30:38 dgp Exp $
a68 1
	struct Tk_ObjCustomOption *custom;  /* For TK_OPTION_CUSTOM. */
a128 2
static Option *		GetOption _ANSI_ARGS_((CONST char *name,
			    OptionTable *tablePtr));
d142 1
a142 1
Tcl_ObjType tkOptionObjType = {
a281 8

	    if (specPtr->type == TK_OPTION_CUSTOM) {
		/*
		 * Get the custom parsing, etc., functions.
		 */
		optionPtr->extra.custom =
		    (Tk_ObjCustomOption *)specPtr->clientData;
	    }
d289 1
a289 2
		|| (specPtr->type == TK_OPTION_CURSOR)
		|| (specPtr->type == TK_OPTION_CUSTOM)) {
d456 1
a456 1
    Tk_Uid value;
a541 7
	/*
	 * Bump the reference count on valuePtr, so that it is strongly
	 * referenced here, and will be properly free'd when finished,
	 * regardless of what DoObjConfig does.
	 */
	Tcl_IncrRefCount(valuePtr);
	
a565 1
	    Tcl_DecrRefCount(valuePtr);
a567 1
	Tcl_DecrRefCount(valuePtr);
d688 3
a690 7
	    if (nullOK && ObjectIsEmpty(valuePtr)) {
		valuePtr = NULL;
		new = 0;
	    } else {
		if (Tcl_GetDoubleFromObj(interp, valuePtr, &new) != TCL_OK) {
		    return TCL_ERROR;
		}
a691 1

d722 1
a722 1
		    (CONST char **) optionPtr->specPtr->clientData,
a767 18
	case TK_OPTION_STYLE: {
	    Tk_Style new;

	    if (nullOK && ObjectIsEmpty(valuePtr)) {
		valuePtr = NULL;
		new = NULL;
	    } else {
		new = Tk_AllocStyleFromObj(interp, valuePtr);
		if (new == NULL) {
		    return TCL_ERROR;
		}
	    }
	    if (internalPtr != NULL) {
		*((Tk_Style *) oldInternalPtr) = *((Tk_Style *) internalPtr);
		*((Tk_Style *) internalPtr) = new;
	    }
	    break;
	}
d808 2
a809 7
	    if (nullOK && ObjectIsEmpty(valuePtr)) {
		valuePtr = NULL;
		new = TK_RELIEF_NULL;
	    } else {
		if (Tk_GetReliefFromObj(interp, valuePtr, &new) != TCL_OK) {
		    return TCL_ERROR;
		}
d864 4
a867 9

	    if (nullOK && ObjectIsEmpty(valuePtr)) {
		valuePtr = NULL;
		new = 0;
	    } else {
		if (Tk_GetPixelsFromObj(interp, tkwin, valuePtr,
			&new) != TCL_OK) {
		    return TCL_ERROR;
		}
a892 11
	case TK_OPTION_CUSTOM: {
	    Tk_ObjCustomOption *custom = optionPtr->extra.custom;
	    if (custom->setProc(custom->clientData, interp, tkwin,
		    &valuePtr, recordPtr, optionPtr->specPtr->internalOffset,
		    (char *)oldInternalPtr,
		    optionPtr->specPtr->flags) != TCL_OK) {
		return TCL_ERROR;
	    }
	    break;
	}
	    
d962 1
a962 1
 * GetOption --
d969 2
a970 1
 *	if no matching entry could be found.
d976 3
a978 1
 *	None.
d984 6
a989 4
GetOption(name, tablePtr)
    CONST char *name;		/* String balue to be looked up in the
				 * option table. */
    OptionTable *tablePtr;	/* Table in which to look up name. */
d993 1
a993 1
    CONST char *p1, *p2;
d997 12
a1008 2
     * Search through all of the option tables in the chain to find the
     * best match.  Some tricky aspects:
d1018 1
a1054 59

    done:
    return bestPtr;

    error:
    return NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * GetOptionFromObj --
 *
 *      This procedure searches through a chained option table to find
 *      the entry for a particular option name.
 *
 * Results:
 *      The return value is a pointer to the matching entry, or NULL
 *      if no matching entry could be found.  If NULL is returned and
 *      interp is not NULL than an error message is left in its result.
 *      Note: if the matching entry is a synonym then this procedure
 *      returns a pointer to the synonym entry, *not* the "real" entry
 *      that the synonym refers to.
 *
 * Side effects:
 *      Information about the matching entry is cached in the object
 *      containing the name, so that future lookups can proceed more
 *      quickly.
 *
 *----------------------------------------------------------------------
 */

static Option *
GetOptionFromObj(interp, objPtr, tablePtr)
    Tcl_Interp *interp;         /* Used only for error reporting; if NULL
                                 * no message is left after an error. */
    Tcl_Obj *objPtr;            /* Object whose string value is to be
                                 * looked up in the option table. */
    OptionTable *tablePtr;      /* Table in which to look up objPtr. */
{
    Option *bestPtr;
    char *name;

    /*
     * First, check to see if the object already has the answer cached.
     */

    if (objPtr->typePtr == &tkOptionObjType) {
        if (objPtr->internalRep.twoPtrValue.ptr1 == (VOID *) tablePtr) {
            return (Option *) objPtr->internalRep.twoPtrValue.ptr2;
        }
    }

    /*
     * The answer isn't cached.
     */

    name = Tcl_GetStringFromObj(objPtr, (int *) NULL);
    bestPtr = GetOption(name, tablePtr);
d1059 1
d1066 1
a1066 1
    objPtr->typePtr = &tkOptionObjType;
a1079 38
 * TkGetOptionSpec --
 *
 *      This procedure searches through a chained option table to find
 *      the option spec for a particular option name.
 *
 * Results:
 *      The return value is a pointer to the option spec of the matching
 *      entry, or NULL if no matching entry could be found.
 *      Note: if the matching entry is a synonym then this procedure
 *      returns a pointer to the option spec of the synonym entry, *not*
 *      the "real" entry that the synonym refers to.
 *      Note: this call is primarily used by the style management code
 *      (tkStyle.c) to look up an element's option spec into a widget's
 *      option table.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */

CONST Tk_OptionSpec *
TkGetOptionSpec(name, optionTable)
    CONST char *name;			/* String value to be looked up. */
    Tk_OptionTable optionTable;		/* Table in which to look up name. */
{
    Option *optionPtr;

    optionPtr = GetOption(name, (OptionTable *) optionTable);
    if (optionPtr == NULL) {
	return NULL;
    }
    return optionPtr->specPtr;
}

/*
 *----------------------------------------------------------------------
 *
a1354 5
		case TK_OPTION_STYLE: {
		    *((Tk_Style *) internalPtr)
			    = *((Tk_Style *) &savePtr->items[i].internalForm);
		    break;
		}
a1396 9
		case TK_OPTION_CUSTOM: {
		    Tk_ObjCustomOption *custom = optionPtr->extra.custom;
		    if (custom->restoreProc != NULL) {
			custom->restoreProc(custom->clientData, savePtr->tkwin,
				internalPtr,
				(char *)&savePtr->items[i].internalForm);
		    }
		    break;
		}
a1575 8
	case TK_OPTION_STYLE:
	    if (internalFormExists) {
		Tk_FreeStyle(*((Tk_Style *) internalPtr));
		*((Tk_Style *) internalPtr) = NULL;
	    } else if (objPtr != NULL) {
		Tk_FreeStyleFromObj(objPtr);
	    }
	    break;
a1606 7
	case TK_OPTION_CUSTOM: {
	    Tk_ObjCustomOption *custom = optionPtr->extra.custom;
	    if (internalFormExists && custom->freeProc != NULL) {
		custom->freeProc(custom->clientData, tkwin, internalPtr);
	    }
	    break;
	}
a1841 7
	case TK_OPTION_STYLE: {
	    Tk_Style style = *((Tk_Style *) internalPtr);
	    if (style != NULL) {
		objPtr = Tcl_NewStringObj(Tk_NameOfStyle(style), -1);
	    }
	    break;
	}
a1890 6
	case TK_OPTION_CUSTOM: {
	    Tk_ObjCustomOption *custom = optionPtr->extra.custom;
	    objPtr = custom->getProc(custom->clientData, tkwin, recordPtr,
		    optionPtr->specPtr->internalOffset);
	    break;
	}
d2031 2
@


