head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.20.24.43;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.13;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.24;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.50;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.31;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.09;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@/* 
 * tkCmds.c --
 *
 *	This file contains a collection of Tk-related Tcl commands
 *	that didn't fit in any particular file of the toolkit.
 *
 * Copyright (c) 1990-1994 The Regents of the University of California.
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
 * Copyright (c) 2000 Scriptics Corporation.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkCmds.c,v 1.31 2002/09/02 19:16:23 hobbs Exp $
 */

#include "tkPort.h"
#include "tkInt.h"
#include <errno.h>

#if defined(WIN32)
#include "tkWinInt.h"
#elif defined(MAC_TCL)
#include "tkMacInt.h"
#elif defined(MAC_OSX_TK) 
#include "tkMacOSXInt.h"
#else
#include "tkUnixInt.h"
#endif

/*
 * Forward declarations for procedures defined later in this file:
 */

static TkWindow *	GetToplevel _ANSI_ARGS_((Tk_Window tkwin));
static char *		WaitVariableProc _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, CONST char *name1,
			    CONST char *name2, int flags));
static void		WaitVisibilityProc _ANSI_ARGS_((ClientData clientData,
			    XEvent *eventPtr));
static void		WaitWindowProc _ANSI_ARGS_((ClientData clientData,
			    XEvent *eventPtr));

/*
 *----------------------------------------------------------------------
 *
 * Tk_BellObjCmd --
 *
 *	This procedure is invoked to process the "bell" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

int
Tk_BellObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Main window associated with interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    static CONST char *bellOptions[] = {"-displayof", "-nice", (char *) NULL};
    enum options { TK_BELL_DISPLAYOF, TK_BELL_NICE };
    Tk_Window tkwin = (Tk_Window) clientData;
    int i, index, nice = 0;

    if (objc > 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "?-displayof window? ?-nice?");
	return TCL_ERROR;
    }

    for (i = 1; i < objc; i++) {
	if (Tcl_GetIndexFromObj(interp, objv[i], bellOptions, "option", 0,
		&index) != TCL_OK) {
	    return TCL_ERROR;
	}
	switch ((enum options) index) {
	    case TK_BELL_DISPLAYOF:
		if (++i >= objc) {
		    Tcl_WrongNumArgs(interp, 1, objv,
			    "?-displayof window? ?-nice?");
		    return TCL_ERROR;
		}
		tkwin = Tk_NameToWindow(interp, Tcl_GetString(objv[i]), tkwin);
		if (tkwin == NULL) {
		    return TCL_ERROR;
		}
		break;
	    case TK_BELL_NICE:
		nice = 1;
		break;
	}
    }
    XBell(Tk_Display(tkwin), 0);
    if (!nice) {
	XForceScreenSaver(Tk_Display(tkwin), ScreenSaverReset);
    }
    XFlush(Tk_Display(tkwin));
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_BindObjCmd --
 *
 *	This procedure is invoked to process the "bind" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

int
Tk_BindObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Main window associated with interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Tk_Window tkwin = (Tk_Window) clientData;
    TkWindow *winPtr;
    ClientData object;
    char *string;
    
    if ((objc < 2) || (objc > 4)) {
	Tcl_WrongNumArgs(interp, 1, objv, "window ?pattern? ?command?");
	return TCL_ERROR;
    }
    string = Tcl_GetString(objv[1]);
    
    /*
     * Bind tags either a window name or a tag name for the first argument.
     * If the argument starts with ".", assume it is a window; otherwise, it
     * is a tag.
     */

    if (string[0] == '.') {
	winPtr = (TkWindow *) Tk_NameToWindow(interp, string, tkwin);
	if (winPtr == NULL) {
	    return TCL_ERROR;
	}
	object = (ClientData) winPtr->pathName;
    } else {
	winPtr = (TkWindow *) clientData;
	object = (ClientData) Tk_GetUid(string);
    }

    /*
     * If there are four arguments, the command is modifying a binding.  If
     * there are three arguments, the command is querying a binding.  If there
     * are only two arguments, the command is querying all the bindings for
     * the given tag/window.
     */

    if (objc == 4) {
	int append = 0;
	unsigned long mask;
	char *sequence, *script;
	sequence	= Tcl_GetString(objv[2]);
	script		= Tcl_GetString(objv[3]);
	
	/*
	 * If the script is null, just delete the binding.
	 */

	if (script[0] == 0) {
	    return Tk_DeleteBinding(interp, winPtr->mainPtr->bindingTable,
		    object, sequence);
	}

	/*
	 * If the script begins with "+", append this script to the existing
	 * binding.
	 */
	
	if (script[0] == '+') {
	    script++;
	    append = 1;
	}
	mask = Tk_CreateBinding(interp, winPtr->mainPtr->bindingTable,
		object, sequence, script, append);
	if (mask == 0) {
	    return TCL_ERROR;
	}
    } else if (objc == 3) {
	CONST char *command;

	command = Tk_GetBinding(interp, winPtr->mainPtr->bindingTable,
		object, Tcl_GetString(objv[2]));
	if (command == NULL) {
	    Tcl_ResetResult(interp);
	    return TCL_OK;
	}
	Tcl_SetResult(interp, (char *) command, TCL_STATIC);
    } else {
	Tk_GetAllBindings(interp, winPtr->mainPtr->bindingTable, object);
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * TkBindEventProc --
 *
 *	This procedure is invoked by Tk_HandleEvent for each event;  it
 *	causes any appropriate bindings for that event to be invoked.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Depends on what bindings have been established with the "bind"
 *	command.
 *
 *----------------------------------------------------------------------
 */

void
TkBindEventProc(winPtr, eventPtr)
    TkWindow *winPtr;			/* Pointer to info about window. */
    XEvent *eventPtr;			/* Information about event. */
{
#define MAX_OBJS 20
    ClientData objects[MAX_OBJS], *objPtr;
    TkWindow *topLevPtr;
    int i, count;
    char *p;
    Tcl_HashEntry *hPtr;

    if ((winPtr->mainPtr == NULL) || (winPtr->mainPtr->bindingTable == NULL)) {
	return;
    }

    objPtr = objects;
    if (winPtr->numTags != 0) {
	/*
	 * Make a copy of the tags for the window, replacing window names
	 * with pointers to the pathName from the appropriate window.
	 */

	if (winPtr->numTags > MAX_OBJS) {
	    objPtr = (ClientData *) ckalloc((unsigned)
		    (winPtr->numTags * sizeof(ClientData)));
	}
	for (i = 0; i < winPtr->numTags; i++) {
	    p = (char *) winPtr->tagPtr[i];
	    if (*p == '.') {
		hPtr = Tcl_FindHashEntry(&winPtr->mainPtr->nameTable, p);
		if (hPtr != NULL) {
		    p = ((TkWindow *) Tcl_GetHashValue(hPtr))->pathName;
		} else {
		    p = NULL;
		}
	    }
	    objPtr[i] = (ClientData) p;
	}
	count = winPtr->numTags;
    } else {
	objPtr[0] = (ClientData) winPtr->pathName;
	objPtr[1] = (ClientData) winPtr->classUid;
	for (topLevPtr = winPtr;
		(topLevPtr != NULL) && !(topLevPtr->flags & TK_TOP_HIERARCHY);
		topLevPtr = topLevPtr->parentPtr) {
	    /* Empty loop body. */
	}
	if ((winPtr != topLevPtr) && (topLevPtr != NULL)) {
	    count = 4;
	    objPtr[2] = (ClientData) topLevPtr->pathName;
	} else {
	    count = 3;
	}
	objPtr[count-1] = (ClientData) Tk_GetUid("all");
    }
    Tk_BindEvent(winPtr->mainPtr->bindingTable, eventPtr, (Tk_Window) winPtr,
	    count, objPtr);
    if (objPtr != objects) {
	ckfree((char *) objPtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_BindtagsObjCmd --
 *
 *	This procedure is invoked to process the "bindtags" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

int
Tk_BindtagsObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Main window associated with interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Tk_Window tkwin = (Tk_Window) clientData;
    TkWindow *winPtr, *winPtr2;
    int i, length;
    char *p;
    Tcl_Obj *listPtr, **tags;
    
    if ((objc < 2) || (objc > 3)) {
	Tcl_WrongNumArgs(interp, 1, objv, "window ?taglist?");
	return TCL_ERROR;
    }
    winPtr = (TkWindow *) Tk_NameToWindow(interp, Tcl_GetString(objv[1]),
	    tkwin);
    if (winPtr == NULL) {
	return TCL_ERROR;
    }
    if (objc == 2) {
	listPtr = Tcl_NewObj();
	Tcl_IncrRefCount(listPtr);
	if (winPtr->numTags == 0) {
	    Tcl_ListObjAppendElement(interp, listPtr,
		    Tcl_NewStringObj(winPtr->pathName, -1));
	    Tcl_ListObjAppendElement(interp, listPtr,
		    Tcl_NewStringObj(winPtr->classUid, -1));
	    winPtr2 = winPtr;
	    while ((winPtr2 != NULL) && !(Tk_TopWinHierarchy(winPtr2))) {
		winPtr2 = winPtr2->parentPtr;
	    }
	    if ((winPtr != winPtr2) && (winPtr2 != NULL)) {
		Tcl_ListObjAppendElement(interp, listPtr,
			Tcl_NewStringObj(winPtr2->pathName, -1));
	    }
	    Tcl_ListObjAppendElement(interp, listPtr,
		    Tcl_NewStringObj("all", -1));
	} else {
	    for (i = 0; i < winPtr->numTags; i++) {
		Tcl_ListObjAppendElement(interp, listPtr,
			Tcl_NewStringObj((char *)winPtr->tagPtr[i], -1));
	    }
	}
	Tcl_SetObjResult(interp, listPtr);
	Tcl_DecrRefCount(listPtr);
	return TCL_OK;
    }
    if (winPtr->tagPtr != NULL) {
	TkFreeBindingTags(winPtr);
    }
    if (Tcl_ListObjGetElements(interp, objv[2], &length, &tags) != TCL_OK) {
	return TCL_ERROR;
    }
    if (length == 0) {
	return TCL_OK;
    }

    winPtr->numTags = length;
    winPtr->tagPtr = (ClientData *) ckalloc((unsigned)
	    (length * sizeof(ClientData)));
    for (i = 0; i < length; i++) {
	p = Tcl_GetString(tags[i]);
	if (p[0] == '.') {
	    char *copy;

	    /*
	     * Handle names starting with "." specially: store a malloc'ed
	     * string, rather than a Uid;  at event time we'll look up the
	     * name in the window table and use the corresponding window,
	     * if there is one.
	     */

	    copy = (char *) ckalloc((unsigned) (strlen(p) + 1));
	    strcpy(copy, p);
	    winPtr->tagPtr[i] = (ClientData) copy;
	} else {
	    winPtr->tagPtr[i] = (ClientData) Tk_GetUid(p);
	}
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * TkFreeBindingTags --
 *
 *	This procedure is called to free all of the binding tags
 *	associated with a window;  typically it is only invoked where
 *	there are window-specific tags.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Any binding tags for winPtr are freed.
 *
 *----------------------------------------------------------------------
 */

void
TkFreeBindingTags(winPtr)
    TkWindow *winPtr;		/* Window whose tags are to be released. */
{
    int i;
    char *p;

    for (i = 0; i < winPtr->numTags; i++) {
	p = (char *) (winPtr->tagPtr[i]);
	if (*p == '.') {
	    /*
	     * Names starting with "." are malloced rather than Uids, so
	     * they have to be freed.
	     */
    
	    ckfree(p);
	}
    }
    ckfree((char *) winPtr->tagPtr);
    winPtr->numTags = 0;
    winPtr->tagPtr = NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_DestroyObjCmd --
 *
 *	This procedure is invoked to process the "destroy" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

int
Tk_DestroyObjCmd(clientData, interp, objc, objv)
    ClientData clientData;		/* Main window associated with
				 * interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Tk_Window window;
    Tk_Window tkwin = (Tk_Window) clientData;
    int i;

    for (i = 1; i < objc; i++) {
	window = Tk_NameToWindow(interp, Tcl_GetString(objv[i]), tkwin);
	if (window == NULL) {
	    Tcl_ResetResult(interp);
	    continue;
	}
	Tk_DestroyWindow(window);
	if (window == tkwin) {
	    /*
	     * We just deleted the main window for the application! This
	     * makes it impossible to do anything more (tkwin isn't
	     * valid anymore).
	     */

	    break;
	 }
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_LowerObjCmd --
 *
 *	This procedure is invoked to process the "lower" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tk_LowerObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Main window associated with
				 * interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Tk_Window mainwin = (Tk_Window) clientData;
    Tk_Window tkwin, other;

    if ((objc != 2) && (objc != 3)) {
	Tcl_WrongNumArgs(interp, 1, objv, "window ?belowThis?");
	return TCL_ERROR;
    }

    tkwin = Tk_NameToWindow(interp, Tcl_GetString(objv[1]), mainwin);
    if (tkwin == NULL) {
	return TCL_ERROR;
    }
    if (objc == 2) {
	other = NULL;
    } else {
	other = Tk_NameToWindow(interp, Tcl_GetString(objv[2]), mainwin);
	if (other == NULL) {
	    return TCL_ERROR;
	}
    }
    if (Tk_RestackWindow(tkwin, Below, other) != TCL_OK) {
	Tcl_AppendResult(interp, "can't lower \"", Tcl_GetString(objv[1]),
		"\" below \"", (other ? Tcl_GetString(objv[2]) : ""),
		"\"", (char *) NULL);
	return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_RaiseObjCmd --
 *
 *	This procedure is invoked to process the "raise" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tk_RaiseObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Main window associated with
				 * interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Tk_Window mainwin = (Tk_Window) clientData;
    Tk_Window tkwin, other;

    if ((objc != 2) && (objc != 3)) {
	Tcl_WrongNumArgs(interp, 1, objv, "window ?aboveThis?");
	return TCL_ERROR;
    }

    tkwin = Tk_NameToWindow(interp, Tcl_GetString(objv[1]), mainwin);
    if (tkwin == NULL) {
	return TCL_ERROR;
    }
    if (objc == 2) {
	other = NULL;
    } else {
	other = Tk_NameToWindow(interp, Tcl_GetString(objv[2]), mainwin);
	if (other == NULL) {
	    return TCL_ERROR;
	}
    }
    if (Tk_RestackWindow(tkwin, Above, other) != TCL_OK) {
	Tcl_AppendResult(interp, "can't raise \"", Tcl_GetString(objv[1]),
		"\" above \"", (other ? Tcl_GetString(objv[2]) : ""),
		"\"", (char *) NULL);
	return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_TkObjCmd --
 *
 *	This procedure is invoked to process the "tk" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

int
Tk_TkObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Main window associated with interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    int index;
    Tk_Window tkwin;
    static CONST char *optionStrings[] = {
	"appname",	"caret",	"scaling",	"useinputmethods",
	"windowingsystem",		NULL
    };
    enum options {
	TK_APPNAME,	TK_CARET,	TK_SCALING,	TK_USE_IM,
	TK_WINDOWINGSYSTEM
    };

    tkwin = (Tk_Window) clientData;

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "option ?arg?");
	return TCL_ERROR;
    }
    if (Tcl_GetIndexFromObj(interp, objv[1], optionStrings, "option", 0,
	    &index) != TCL_OK) {
	return TCL_ERROR;
    }

    switch ((enum options) index) {
        case TK_APPNAME: {
	    TkWindow *winPtr;
	    char *string;

	    if (Tcl_IsSafe(interp)) {
		Tcl_SetResult(interp,
			"appname not accessible in a safe interpreter",
			TCL_STATIC);
		return TCL_ERROR;
	    }

	    winPtr = (TkWindow *) tkwin;

	    if (objc > 3) {
	        Tcl_WrongNumArgs(interp, 2, objv, "?newName?");
		return TCL_ERROR;
	    }
	    if (objc == 3) {
		string = Tcl_GetStringFromObj(objv[2], NULL);
		winPtr->nameUid = Tk_GetUid(Tk_SetAppName(tkwin, string));
	    }
	    Tcl_AppendResult(interp, winPtr->nameUid, NULL);
	    break;
	}
	case TK_CARET: {
	    Tcl_Obj *objPtr;
	    TkCaret *caretPtr;
	    Tk_Window window;
	    static CONST char *caretStrings[]
		= { "-x",	"-y", "-height", NULL };
	    enum caretOptions
		{ TK_CARET_X, TK_CARET_Y, TK_CARET_HEIGHT };

	    if ((objc < 3) || ((objc > 4) && !(objc & 1))) {
	        Tcl_WrongNumArgs(interp, 2, objv,
			"window ?-x x? ?-y y? ?-height height?");
		return TCL_ERROR;
	    }
	    window = Tk_NameToWindow(interp, Tcl_GetString(objv[2]), tkwin);
	    if (window == NULL) {
		return TCL_ERROR;
	    }
	    caretPtr = &(((TkWindow *) window)->dispPtr->caret);
	    if (objc == 3) {
		/*
		 * Return all the current values
		 */
		objPtr = Tcl_NewObj();
		Tcl_ListObjAppendElement(interp, objPtr,
			Tcl_NewStringObj("-height", 7));
		Tcl_ListObjAppendElement(interp, objPtr,
			Tcl_NewIntObj(caretPtr->height));
		Tcl_ListObjAppendElement(interp, objPtr,
			Tcl_NewStringObj("-x", 2));
		Tcl_ListObjAppendElement(interp, objPtr,
			Tcl_NewIntObj(caretPtr->x));
		Tcl_ListObjAppendElement(interp, objPtr,
			Tcl_NewStringObj("-y", 2));
		Tcl_ListObjAppendElement(interp, objPtr,
			Tcl_NewIntObj(caretPtr->y));
		Tcl_SetObjResult(interp, objPtr);
	    } else if (objc == 4) {
		int value;
		/*
		 * Return the current value of the selected option
		 */
		if (Tcl_GetIndexFromObj(interp, objv[3], caretStrings,
			"caret option", 0, &index) != TCL_OK) {
		    return TCL_ERROR;
		}
		if (index == TK_CARET_X) {
		    value = caretPtr->x;
		} else if (index == TK_CARET_Y) {
		    value = caretPtr->y;
		} else /* if (index == TK_CARET_HEIGHT) -- last case */ {
		    value = caretPtr->height;
		}
		Tcl_SetIntObj(Tcl_GetObjResult(interp), value);
	    } else {
		int i, value, x = 0, y = 0, height = -1;

		for (i = 3; i < objc; i += 2) {
		    if ((Tcl_GetIndexFromObj(interp, objv[i], caretStrings,
			    "caret option", 0, &index) != TCL_OK) ||
			    (Tcl_GetIntFromObj(interp, objv[i+1], &value)
				!= TCL_OK)) {
			return TCL_ERROR;
		    }
		    if (index == TK_CARET_X) {
			x = value;
		    } else if (index == TK_CARET_Y) {
			y = value;
		    } else /* if (index == TK_CARET_HEIGHT) -- last case */ {
			height = value;
		    }
		}
		if (height < 0) {
		    height = Tk_Height(window);
		}
		Tk_SetCaretPos(window, x, y, height);
	    }
	    break;
	}
	case TK_SCALING: {
	    Screen *screenPtr;
	    int skip, width, height;
	    double d;

	    if (Tcl_IsSafe(interp)) {
		Tcl_SetResult(interp,
			"scaling not accessible in a safe interpreter",
			TCL_STATIC);
		return TCL_ERROR;
	    }

	    screenPtr = Tk_Screen(tkwin);

	    skip = TkGetDisplayOf(interp, objc - 2, objv + 2, &tkwin);
	    if (skip < 0) {
		return TCL_ERROR;
	    }
	    if (objc - skip == 2) {
		d = 25.4 / 72;
		d *= WidthOfScreen(screenPtr);
		d /= WidthMMOfScreen(screenPtr);
		Tcl_SetDoubleObj(Tcl_GetObjResult(interp), d);
	    } else if (objc - skip == 3) {
		if (Tcl_GetDoubleFromObj(interp, objv[2+skip], &d) != TCL_OK) {
		    return TCL_ERROR;
		}
		d = (25.4 / 72) / d;
		width = (int) (d * WidthOfScreen(screenPtr) + 0.5);
		if (width <= 0) {
		    width = 1;
		}
		height = (int) (d * HeightOfScreen(screenPtr) + 0.5); 
		if (height <= 0) {
		    height = 1;
		}
		WidthMMOfScreen(screenPtr) = width;
		HeightMMOfScreen(screenPtr) = height;
	    } else {
		Tcl_WrongNumArgs(interp, 2, objv,
			"?-displayof window? ?factor?");
		return TCL_ERROR;
	    }
	    break;
	}
	case TK_USE_IM: {
	    TkDisplay *dispPtr = ((TkWindow *) tkwin)->dispPtr;
	    int skip;

	    if (Tcl_IsSafe(interp)) {
		Tcl_SetResult(interp,
			"useinputmethods not accessible in a safe interpreter",
			TCL_STATIC);
		return TCL_ERROR;
	    }

	    skip = TkGetDisplayOf(interp, objc-2, objv+2, &tkwin);
	    if (skip < 0) {
		return TCL_ERROR;
	    } else if (skip) {
		dispPtr = ((TkWindow *) tkwin)->dispPtr;
	    }
	    if ((objc - skip) == 3) {
		/*
		 * In the case where TK_USE_INPUT_METHODS is not defined,
		 * this will be ignored and we will always return 0.
		 * That will indicate to the user that input methods
		 * are just not available.
		 */
		int boolVal;
		if (Tcl_GetBooleanFromObj(interp, objv[2+skip], &boolVal)
			!= TCL_OK) {
		    return TCL_ERROR;
		}
#ifdef TK_USE_INPUT_METHODS
		if (boolVal) {
		    dispPtr->flags |= TK_DISPLAY_USE_IM;
		} else {
		    dispPtr->flags &= ~TK_DISPLAY_USE_IM;
		}
#endif /* TK_USE_INPUT_METHODS */
	    } else if ((objc - skip) != 2) {
		Tcl_WrongNumArgs(interp, 2, objv,
			"?-displayof window? ?boolean?");
		return TCL_ERROR;
	    }
	    Tcl_SetBooleanObj(Tcl_GetObjResult(interp),
		    (int) (dispPtr->flags & TK_DISPLAY_USE_IM));
	    break;
	}
        case TK_WINDOWINGSYSTEM: {
	    CONST char *windowingsystem;
	    
	    if (objc != 2) {
	        Tcl_WrongNumArgs(interp, 2, objv, NULL);
		return TCL_ERROR;
	    }
#if defined(WIN32)
	    windowingsystem = "win32";
#elif defined(MAC_TCL)
	    windowingsystem = "classic";
#elif defined(MAC_OSX_TK)
	    windowingsystem = "aqua";
#else
	    windowingsystem = "x11";
#endif
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), windowingsystem, -1);
	    break;
	}
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_TkwaitObjCmd --
 *
 *	This procedure is invoked to process the "tkwait" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tk_TkwaitObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Main window associated with
				 * interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Tk_Window tkwin = (Tk_Window) clientData;
    int done, index;
    static CONST char *optionStrings[] = { "variable", "visibility", "window",
					 (char *) NULL };
    enum options { TKWAIT_VARIABLE, TKWAIT_VISIBILITY, TKWAIT_WINDOW };
    
    if (objc != 3) {
	Tcl_WrongNumArgs(interp, 1, objv, "variable|visibility|window name");
	return TCL_ERROR;
    }

    if (Tcl_GetIndexFromObj(interp, objv[1], optionStrings, "option", 0,
	    &index) != TCL_OK) {
	return TCL_ERROR;
    }

    switch ((enum options) index) {
	case TKWAIT_VARIABLE: {
	    if (Tcl_TraceVar(interp, Tcl_GetString(objv[2]),
		    TCL_GLOBAL_ONLY|TCL_TRACE_WRITES|TCL_TRACE_UNSETS,
		    WaitVariableProc, (ClientData) &done) != TCL_OK) {
		return TCL_ERROR;
	    }
	    done = 0;
	    while (!done) {
		Tcl_DoOneEvent(0);
	    }
	    Tcl_UntraceVar(interp, Tcl_GetString(objv[2]),
		    TCL_GLOBAL_ONLY|TCL_TRACE_WRITES|TCL_TRACE_UNSETS,
		    WaitVariableProc, (ClientData) &done);
	    break;
	}
	
	case TKWAIT_VISIBILITY: {
	    Tk_Window window;

	    window = Tk_NameToWindow(interp, Tcl_GetString(objv[2]), tkwin);
	    if (window == NULL) {
		return TCL_ERROR;
	    }
	    Tk_CreateEventHandler(window,
		    VisibilityChangeMask|StructureNotifyMask,
		    WaitVisibilityProc, (ClientData) &done);
	    done = 0;
	    while (!done) {
		Tcl_DoOneEvent(0);
	    }
	    if (done != 1) {
		/*
		 * Note that we do not delete the event handler because it
		 * was deleted automatically when the window was destroyed.
		 */
		
		Tcl_ResetResult(interp);
		Tcl_AppendResult(interp, "window \"", Tcl_GetString(objv[2]),
			"\" was deleted before its visibility changed",
			(char *) NULL);
		return TCL_ERROR;
	    }
	    Tk_DeleteEventHandler(window,
		    VisibilityChangeMask|StructureNotifyMask,
		    WaitVisibilityProc, (ClientData) &done);
	    break;
	}
	
	case TKWAIT_WINDOW: {
	    Tk_Window window;
	    
	    window = Tk_NameToWindow(interp, Tcl_GetString(objv[2]), tkwin);
	    if (window == NULL) {
		return TCL_ERROR;
	    }
	    Tk_CreateEventHandler(window, StructureNotifyMask,
		    WaitWindowProc, (ClientData) &done);
	    done = 0;
	    while (!done) {
		Tcl_DoOneEvent(0);
	    }
	    /*
	     * Note:  there's no need to delete the event handler.  It was
	     * deleted automatically when the window was destroyed.
	     */
	    break;
	}
    }

    /*
     * Clear out the interpreter's result, since it may have been set
     * by event handlers.
     */

    Tcl_ResetResult(interp);
    return TCL_OK;
}

	/* ARGSUSED */
static char *
WaitVariableProc(clientData, interp, name1, name2, flags)
    ClientData clientData;	/* Pointer to integer to set to 1. */
    Tcl_Interp *interp;		/* Interpreter containing variable. */
    CONST char *name1;		/* Name of variable. */
    CONST char *name2;		/* Second part of variable name. */
    int flags;			/* Information about what happened. */
{
    int *donePtr = (int *) clientData;

    *donePtr = 1;
    return (char *) NULL;
}

	/*ARGSUSED*/
static void
WaitVisibilityProc(clientData, eventPtr)
    ClientData clientData;	/* Pointer to integer to set to 1. */
    XEvent *eventPtr;		/* Information about event (not used). */
{
    int *donePtr = (int *) clientData;

    if (eventPtr->type == VisibilityNotify) {
	*donePtr = 1;
    }
    if (eventPtr->type == DestroyNotify) {
	*donePtr = 2;
    }
}

static void
WaitWindowProc(clientData, eventPtr)
    ClientData clientData;	/* Pointer to integer to set to 1. */
    XEvent *eventPtr;		/* Information about event. */
{
    int *donePtr = (int *) clientData;

    if (eventPtr->type == DestroyNotify) {
	*donePtr = 1;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_UpdateObjCmd --
 *
 *	This procedure is invoked to process the "update" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tk_UpdateObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Main window associated with
				 * interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    static CONST char *updateOptions[] = {"idletasks", (char *) NULL};
    int flags, index;
    TkDisplay *dispPtr;

    if (objc == 1) {
	flags = TCL_DONT_WAIT;
    } else if (objc == 2) {
	if (Tcl_GetIndexFromObj(interp, objv[1], updateOptions, "option", 0,
		&index) != TCL_OK) {
	    return TCL_ERROR;
	}
	flags = TCL_IDLE_EVENTS;
    } else {
        Tcl_WrongNumArgs(interp, 1, objv, "?idletasks?");
	return TCL_ERROR;
    }

    /*
     * Handle all pending events, sync all displays, and repeat over
     * and over again until all pending events have been handled.
     * Special note:  it's possible that the entire application could
     * be destroyed by an event handler that occurs during the update.
     * Thus, don't use any information from tkwin after calling
     * Tcl_DoOneEvent.
     */
  
    while (1) {
	while (Tcl_DoOneEvent(flags) != 0) {
	    /* Empty loop body */
	}
	for (dispPtr = TkGetDisplayList(); dispPtr != NULL;
		dispPtr = dispPtr->nextPtr) {
	    XSync(dispPtr->display, False);
	}
	if (Tcl_DoOneEvent(flags) == 0) {
	    break;
	}
    }

    /*
     * Must clear the interpreter's result because event handlers could
     * have executed commands.
     */

    Tcl_ResetResult(interp);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_WinfoObjCmd --
 *
 *	This procedure is invoked to process the "winfo" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

int
Tk_WinfoObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Main window associated with
				 * interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    int index, x, y, width, height, useX, useY, class, skip;
    char *string;
    TkWindow *winPtr;
    Tk_Window tkwin;
    Tcl_Obj *resultPtr;

    static TkStateMap visualMap[] = {
	{PseudoColor,	"pseudocolor"},
	{GrayScale,	"grayscale"},
	{DirectColor,	"directcolor"},
	{TrueColor,	"truecolor"},
	{StaticColor,	"staticcolor"},
	{StaticGray,	"staticgray"},
	{-1,		NULL}
    };
    static CONST char *optionStrings[] = {
	"cells",	"children",	"class",	"colormapfull",
	"depth",	"geometry",	"height",	"id",
	"ismapped",	"manager",	"name",		"parent",
	"pointerx",	"pointery",	"pointerxy",	"reqheight",
	"reqwidth",	"rootx",	"rooty",	"screen",
	"screencells",	"screendepth",	"screenheight",	"screenwidth",
	"screenmmheight","screenmmwidth","screenvisual","server",
	"toplevel",	"viewable",	"visual",	"visualid",
	"vrootheight",	"vrootwidth",	"vrootx",	"vrooty",
	"width",	"x",		"y",
	
	"atom",		"atomname",	"containing",	"interps",
	"pathname",

	"exists",	"fpixels",	"pixels",	"rgb",
	"visualsavailable",

	NULL
    };
    enum options {
	WIN_CELLS,	WIN_CHILDREN,	WIN_CLASS,	WIN_COLORMAPFULL,
	WIN_DEPTH,	WIN_GEOMETRY,	WIN_HEIGHT,	WIN_ID,
	WIN_ISMAPPED,	WIN_MANAGER,	WIN_NAME,	WIN_PARENT,
	WIN_POINTERX,	WIN_POINTERY,	WIN_POINTERXY,	WIN_REQHEIGHT,
	WIN_REQWIDTH,	WIN_ROOTX,	WIN_ROOTY,	WIN_SCREEN,
	WIN_SCREENCELLS,WIN_SCREENDEPTH,WIN_SCREENHEIGHT,WIN_SCREENWIDTH,
	WIN_SCREENMMHEIGHT,WIN_SCREENMMWIDTH,WIN_SCREENVISUAL,WIN_SERVER,
	WIN_TOPLEVEL,	WIN_VIEWABLE,	WIN_VISUAL,	WIN_VISUALID,
	WIN_VROOTHEIGHT,WIN_VROOTWIDTH,	WIN_VROOTX,	WIN_VROOTY,
	WIN_WIDTH,	WIN_X,		WIN_Y,
	
	WIN_ATOM,	WIN_ATOMNAME,	WIN_CONTAINING,	WIN_INTERPS,
	WIN_PATHNAME,

	WIN_EXISTS,	WIN_FPIXELS,	WIN_PIXELS,	WIN_RGB,
	WIN_VISUALSAVAILABLE
    };

    tkwin = (Tk_Window) clientData;
    
    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "option ?arg?");
	return TCL_ERROR;
    }
    if (Tcl_GetIndexFromObj(interp, objv[1], optionStrings, "option", 0,
	    &index) != TCL_OK) {
	return TCL_ERROR;
    }

    if (index < WIN_ATOM) {
	if (objc != 3) {
	    Tcl_WrongNumArgs(interp, 2, objv, "window");
	    return TCL_ERROR;
	}
	string = Tcl_GetStringFromObj(objv[2], NULL);
	tkwin = Tk_NameToWindow(interp, string, tkwin);
	if (tkwin == NULL) {
	    return TCL_ERROR;
	}
    }
    winPtr = (TkWindow *) tkwin;
    resultPtr = Tcl_GetObjResult(interp);

    switch ((enum options) index) {
	case WIN_CELLS: {
	    Tcl_SetIntObj(resultPtr, Tk_Visual(tkwin)->map_entries);
	    break;
	}
	case WIN_CHILDREN: {
	    Tcl_Obj *strPtr;

	    winPtr = winPtr->childList;
	    for ( ; winPtr != NULL; winPtr = winPtr->nextPtr) {
		if (!(winPtr->flags & TK_ANONYMOUS_WINDOW)) {
		    strPtr = Tcl_NewStringObj(winPtr->pathName, -1);
		    Tcl_ListObjAppendElement(NULL, resultPtr, strPtr);
		}
	    }
	    break;
	}
	case WIN_CLASS: {
	    Tcl_SetStringObj(resultPtr, Tk_Class(tkwin), -1);
	    break;
	}
	case WIN_COLORMAPFULL: {
	    Tcl_SetBooleanObj(resultPtr,
		    TkpCmapStressed(tkwin, Tk_Colormap(tkwin)));
	    break;
	}
	case WIN_DEPTH: {
	    Tcl_SetIntObj(resultPtr, Tk_Depth(tkwin));
	    break;
	}
	case WIN_GEOMETRY: {
	    char buf[16 + TCL_INTEGER_SPACE * 4];

	    sprintf(buf, "%dx%d+%d+%d", Tk_Width(tkwin), Tk_Height(tkwin),
		    Tk_X(tkwin), Tk_Y(tkwin));
	    Tcl_SetStringObj(resultPtr, buf, -1);
	    break;
	}
	case WIN_HEIGHT: {
	    Tcl_SetIntObj(resultPtr, Tk_Height(tkwin));
	    break;
	}
	case WIN_ID: {
	    char buf[TCL_INTEGER_SPACE];
	    
	    Tk_MakeWindowExist(tkwin);
	    TkpPrintWindowId(buf, Tk_WindowId(tkwin));
	    Tcl_SetStringObj(resultPtr, buf, -1);
	    break;
	}
	case WIN_ISMAPPED: {
	    Tcl_SetBooleanObj(resultPtr, (int) Tk_IsMapped(tkwin));
	    break;
	}
	case WIN_MANAGER: {
	    if (winPtr->geomMgrPtr != NULL) {
		Tcl_SetStringObj(resultPtr, winPtr->geomMgrPtr->name, -1);
	    }
	    break;
	}
	case WIN_NAME: {
	    Tcl_SetStringObj(resultPtr, Tk_Name(tkwin), -1);
	    break;
	}
	case WIN_PARENT: {
	    if (winPtr->parentPtr != NULL) {
		Tcl_SetStringObj(resultPtr, winPtr->parentPtr->pathName, -1);
	    }
	    break;
	}
	case WIN_POINTERX: {
	    useX = 1;
	    useY = 0;
	    goto pointerxy;
	}
	case WIN_POINTERY: {
	    useX = 0;
	    useY = 1;
	    goto pointerxy;
	}
	case WIN_POINTERXY: {
	    useX = 1;
	    useY = 1;

	    pointerxy:
	    winPtr = GetToplevel(tkwin);
	    if (winPtr == NULL) {
		x = -1;
		y = -1;
	    } else {
		TkGetPointerCoords((Tk_Window) winPtr, &x, &y);
	    }
	    if (useX & useY) {
		char buf[TCL_INTEGER_SPACE * 2];
		
		sprintf(buf, "%d %d", x, y);
		Tcl_SetStringObj(resultPtr, buf, -1);
	    } else if (useX) {
		Tcl_SetIntObj(resultPtr, x);
	    } else {
		Tcl_SetIntObj(resultPtr, y);
	    }
	    break;
	}
	case WIN_REQHEIGHT: {
	    Tcl_SetIntObj(resultPtr, Tk_ReqHeight(tkwin));
	    break;
	}
	case WIN_REQWIDTH: {
	    Tcl_SetIntObj(resultPtr, Tk_ReqWidth(tkwin));
	    break;
	}
	case WIN_ROOTX: {
	    Tk_GetRootCoords(tkwin, &x, &y);
	    Tcl_SetIntObj(resultPtr, x);
	    break;
	}
	case WIN_ROOTY: {
	    Tk_GetRootCoords(tkwin, &x, &y);
	    Tcl_SetIntObj(resultPtr, y);
	    break;
	}
	case WIN_SCREEN: {
	    char buf[TCL_INTEGER_SPACE];
	    
	    sprintf(buf, "%d", Tk_ScreenNumber(tkwin));
	    Tcl_AppendStringsToObj(resultPtr, Tk_DisplayName(tkwin), ".",
		    buf, NULL);
	    break;
	}
	case WIN_SCREENCELLS: {
	    Tcl_SetIntObj(resultPtr, CellsOfScreen(Tk_Screen(tkwin)));
	    break;
	}
	case WIN_SCREENDEPTH: {
	    Tcl_SetIntObj(resultPtr, DefaultDepthOfScreen(Tk_Screen(tkwin)));
	    break;
	}
	case WIN_SCREENHEIGHT: {
	    Tcl_SetIntObj(resultPtr, HeightOfScreen(Tk_Screen(tkwin)));
	    break;
	}
	case WIN_SCREENWIDTH: {
	    Tcl_SetIntObj(resultPtr, WidthOfScreen(Tk_Screen(tkwin)));
	    break;
	}
	case WIN_SCREENMMHEIGHT: {
	    Tcl_SetIntObj(resultPtr, HeightMMOfScreen(Tk_Screen(tkwin)));
	    break;
	}
	case WIN_SCREENMMWIDTH: {
	    Tcl_SetIntObj(resultPtr, WidthMMOfScreen(Tk_Screen(tkwin)));
	    break;
	}
	case WIN_SCREENVISUAL: {
	    class = DefaultVisualOfScreen(Tk_Screen(tkwin))->class;
	    goto visual;
	}
	case WIN_SERVER: {
	    TkGetServerInfo(interp, tkwin);
	    break;
	}
	case WIN_TOPLEVEL: {
	    winPtr = GetToplevel(tkwin);
	    if (winPtr != NULL) {
		Tcl_SetStringObj(resultPtr, winPtr->pathName, -1);
	    }
	    break;
	}
	case WIN_VIEWABLE: {
	    int viewable = 0;
	    for ( ; ; winPtr = winPtr->parentPtr) {
		if ((winPtr == NULL) || !(winPtr->flags & TK_MAPPED)) {
		    break;
		}
		if (winPtr->flags & TK_TOP_HIERARCHY) {
		    viewable = 1;
		    break;
		}
	    }

	    Tcl_SetBooleanObj(resultPtr, viewable);
	    break;
	}
	case WIN_VISUAL: {
	    class = Tk_Visual(tkwin)->class;

	    visual:
	    string = TkFindStateString(visualMap, class);
	    if (string == NULL) {
		string = "unknown";
	    }
	    Tcl_SetStringObj(resultPtr, string, -1);
	    break;
	}
	case WIN_VISUALID: {
	    char buf[TCL_INTEGER_SPACE];

	    sprintf(buf, "0x%x",
		    (unsigned int) XVisualIDFromVisual(Tk_Visual(tkwin)));
	    Tcl_SetStringObj(resultPtr, buf, -1);
	    break;
	}
	case WIN_VROOTHEIGHT: {
	    Tk_GetVRootGeometry(tkwin, &x, &y, &width, &height);
	    Tcl_SetIntObj(resultPtr, height);
	    break;
	}
	case WIN_VROOTWIDTH: {
	    Tk_GetVRootGeometry(tkwin, &x, &y, &width, &height);
	    Tcl_SetIntObj(resultPtr, width);
	    break;
	}
	case WIN_VROOTX: {
	    Tk_GetVRootGeometry(tkwin, &x, &y, &width, &height);
	    Tcl_SetIntObj(resultPtr, x);
	    break;
	}
	case WIN_VROOTY: {
	    Tk_GetVRootGeometry(tkwin, &x, &y, &width, &height);
	    Tcl_SetIntObj(resultPtr, y);
	    break;
	}
	case WIN_WIDTH: {
	    Tcl_SetIntObj(resultPtr, Tk_Width(tkwin));
	    break;
	}
	case WIN_X: {
	    Tcl_SetIntObj(resultPtr, Tk_X(tkwin));
	    break;
	}
	case WIN_Y: {
	    Tcl_SetIntObj(resultPtr, Tk_Y(tkwin));
	    break;
	}

	/*
	 * Uses -displayof.
	 */
	 
	case WIN_ATOM: {
	    skip = TkGetDisplayOf(interp, objc - 2, objv + 2, &tkwin);
	    if (skip < 0) {
		return TCL_ERROR;
	    }
	    if (objc - skip != 3) {
	        Tcl_WrongNumArgs(interp, 2, objv, "?-displayof window? name");
		return TCL_ERROR;
	    }
	    objv += skip;
	    string = Tcl_GetStringFromObj(objv[2], NULL);
	    Tcl_SetLongObj(resultPtr, (long) Tk_InternAtom(tkwin, string));
	    break;
	}
	case WIN_ATOMNAME: {
	    CONST char *name;
	    long id;
	    
	    skip = TkGetDisplayOf(interp, objc - 2, objv + 2, &tkwin);
	    if (skip < 0) {
		return TCL_ERROR;
	    }
	    if (objc - skip != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "?-displayof window? id");
		return TCL_ERROR;
	    }
	    objv += skip;
	    if (Tcl_GetLongFromObj(interp, objv[2], &id) != TCL_OK) {
		return TCL_ERROR;
	    }
	    name = Tk_GetAtomName(tkwin, (Atom) id);
	    if (strcmp(name, "?bad atom?") == 0) {
		string = Tcl_GetStringFromObj(objv[2], NULL);
		Tcl_AppendStringsToObj(resultPtr, 
			"no atom exists with id \"", string, "\"", NULL);
		return TCL_ERROR;
	    }
	    Tcl_SetStringObj(resultPtr, name, -1);
	    break;
	}
	case WIN_CONTAINING: {
	    skip = TkGetDisplayOf(interp, objc - 2, objv + 2, &tkwin);
	    if (skip < 0) {
		return TCL_ERROR;
	    }
	    if (objc - skip != 4) {
		Tcl_WrongNumArgs(interp, 2, objv,
			"?-displayof window? rootX rootY");
		return TCL_ERROR;
	    }
	    objv += skip;
	    string = Tcl_GetStringFromObj(objv[2], NULL);
	    if (Tk_GetPixels(interp, tkwin, string, &x) != TCL_OK) {
		return TCL_ERROR;
	    }
	    string = Tcl_GetStringFromObj(objv[3], NULL);
	    if (Tk_GetPixels(interp, tkwin, string, &y) != TCL_OK) {
		return TCL_ERROR;
	    }
	    tkwin = Tk_CoordsToWindow(x, y, tkwin);
	    if (tkwin != NULL) {
		Tcl_SetStringObj(resultPtr, Tk_PathName(tkwin), -1);
	    }
	    break;
	}
	case WIN_INTERPS: {
	    int result;
	    
	    skip = TkGetDisplayOf(interp, objc - 2, objv + 2, &tkwin);
	    if (skip < 0) {
		return TCL_ERROR;
	    }
	    if (objc - skip != 2) {
		Tcl_WrongNumArgs(interp, 2, objv, "?-displayof window?");
		return TCL_ERROR;
	    }
	    result = TkGetInterpNames(interp, tkwin);
	    return result;
	}
	case WIN_PATHNAME: {
	    Window id;

	    skip = TkGetDisplayOf(interp, objc - 2, objv + 2, &tkwin);
	    if (skip < 0) {
		return TCL_ERROR;
	    }
	    if (objc - skip != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "?-displayof window? id");
		return TCL_ERROR;
	    }
	    string = Tcl_GetStringFromObj(objv[2 + skip], NULL);
	    if (TkpScanWindowId(interp, string, &id) != TCL_OK) {
		return TCL_ERROR;
	    }
	    winPtr = (TkWindow *)Tk_IdToWindow(Tk_Display(tkwin), id);
	    if ((winPtr == NULL) ||
		    (winPtr->mainPtr != ((TkWindow *) tkwin)->mainPtr)) {
		Tcl_AppendStringsToObj(resultPtr, "window id \"", string,
			"\" doesn't exist in this application", (char *) NULL);
		return TCL_ERROR;
	    }

	    /*
	     * If the window is a utility window with no associated path
	     * (such as a wrapper window or send communication window), just
	     * return an empty string.
	     */

	    tkwin = (Tk_Window) winPtr;
	    if (Tk_PathName(tkwin) != NULL) {
		Tcl_SetStringObj(resultPtr, Tk_PathName(tkwin), -1);
	    }
	    break;
	}

	/*
	 * objv[3] is window.
	 */

	case WIN_EXISTS: {
	    int alive;

	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "window");
		return TCL_ERROR;
	    }
	    string = Tcl_GetStringFromObj(objv[2], NULL);
	    winPtr = (TkWindow *) Tk_NameToWindow(interp, string, tkwin);
	    Tcl_ResetResult(interp);
	    resultPtr = Tcl_GetObjResult(interp);

	    alive = 1;
	    if ((winPtr == NULL) || (winPtr->flags & TK_ALREADY_DEAD)) {
		alive = 0;
	    }
	    Tcl_SetBooleanObj(resultPtr, alive);
	    break;
	}
	case WIN_FPIXELS: {
	    double mm, pixels;

	    if (objc != 4) {
		Tcl_WrongNumArgs(interp, 2, objv, "window number");
		return TCL_ERROR;
	    }
	    string = Tcl_GetStringFromObj(objv[2], NULL);
	    tkwin = Tk_NameToWindow(interp, string, tkwin);
	    if (tkwin == NULL) {
		return TCL_ERROR;
	    }
	    string = Tcl_GetStringFromObj(objv[3], NULL);
	    if (Tk_GetScreenMM(interp, tkwin, string, &mm) != TCL_OK) {
		return TCL_ERROR;
	    }
	    pixels = mm * WidthOfScreen(Tk_Screen(tkwin))
		    / WidthMMOfScreen(Tk_Screen(tkwin));
	    Tcl_SetDoubleObj(resultPtr, pixels);
	    break;
	}
	case WIN_PIXELS: {
	    int pixels;
	    
	    if (objc != 4) {
		Tcl_WrongNumArgs(interp, 2, objv, "window number");
		return TCL_ERROR;
	    }
	    string = Tcl_GetStringFromObj(objv[2], NULL);
	    tkwin = Tk_NameToWindow(interp, string, tkwin);
	    if (tkwin == NULL) {
		return TCL_ERROR;
	    }
	    string = Tcl_GetStringFromObj(objv[3], NULL);
	    if (Tk_GetPixels(interp, tkwin, string, &pixels) != TCL_OK) {
		return TCL_ERROR;
	    }
	    Tcl_SetIntObj(resultPtr, pixels);
	    break;
	}
	case WIN_RGB: {
	    XColor *colorPtr;
	    char buf[TCL_INTEGER_SPACE * 3];

	    if (objc != 4) {
		Tcl_WrongNumArgs(interp, 2, objv, "window colorName");
		return TCL_ERROR;
	    }
	    string = Tcl_GetStringFromObj(objv[2], NULL);
	    tkwin = Tk_NameToWindow(interp, string, tkwin);
	    if (tkwin == NULL) {
		return TCL_ERROR;
	    }
	    string = Tcl_GetStringFromObj(objv[3], NULL);
	    colorPtr = Tk_GetColor(interp, tkwin, string);
	    if (colorPtr == NULL) {
		return TCL_ERROR;
	    }
	    sprintf(buf, "%d %d %d", colorPtr->red, colorPtr->green,
		    colorPtr->blue);
	    Tk_FreeColor(colorPtr);
	    Tcl_SetStringObj(resultPtr, buf, -1);
	    break;
	}
	case WIN_VISUALSAVAILABLE: {
	    XVisualInfo template, *visInfoPtr;
	    int count, i;
	    int includeVisualId;
	    Tcl_Obj *strPtr;
	    char buf[16 + TCL_INTEGER_SPACE];
	    char visualIdString[TCL_INTEGER_SPACE];

	    if (objc == 3) {
		includeVisualId = 0;
	    } else if ((objc == 4)
		    && (strcmp(Tcl_GetStringFromObj(objv[3], NULL),
			    "includeids") == 0)) {
		includeVisualId = 1;
	    } else {
		Tcl_WrongNumArgs(interp, 2, objv, "window ?includeids?");
		return TCL_ERROR;
	    }

	    string = Tcl_GetStringFromObj(objv[2], NULL);
	    tkwin = Tk_NameToWindow(interp, string, tkwin); 
	    if (tkwin == NULL) { 
		return TCL_ERROR; 
	    }

	    template.screen = Tk_ScreenNumber(tkwin);
	    visInfoPtr = XGetVisualInfo(Tk_Display(tkwin), VisualScreenMask,
		    &template, &count);
	    if (visInfoPtr == NULL) {
		Tcl_SetStringObj(resultPtr,
			"can't find any visuals for screen", -1);
		return TCL_ERROR;
	    }
	    for (i = 0; i < count; i++) {
		string = TkFindStateString(visualMap, visInfoPtr[i].class);
		if (string == NULL) {
		    strcpy(buf, "unknown");
		} else {
		    sprintf(buf, "%s %d", string, visInfoPtr[i].depth);
		}
		if (includeVisualId) {
		    sprintf(visualIdString, " 0x%x",
			    (unsigned int) visInfoPtr[i].visualid);
		    strcat(buf, visualIdString);
		}
		strPtr = Tcl_NewStringObj(buf, -1);
		Tcl_ListObjAppendElement(NULL, resultPtr, strPtr);
	    }
	    XFree((char *) visInfoPtr);
	    break;
	}
    }
    return TCL_OK;
}

#if 0
/*
 *----------------------------------------------------------------------
 *
 * Tk_WmObjCmd --
 *
 *	This procedure is invoked to process the "wm" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tk_WmObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Main window associated with
				 * interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Tk_Window tkwin;
    TkWindow *winPtr;

    static CONST char *optionStrings[] = {
	"aspect",	"client",	"command",	"deiconify",
	"focusmodel",	"frame",	"geometry",	"grid",
	"group",	"iconbitmap",	"iconify",	"iconmask",
	"iconname",	"iconposition",	"iconwindow",	"maxsize",
	"minsize",	"overrideredirect",	"positionfrom",	"protocol",
	"resizable",	"sizefrom",	"state",	"title",
	"tracing",	"transient",	"withdraw",	(char *) NULL
    };
    enum options {
	TKWM_ASPECT,	TKWM_CLIENT,	TKWM_COMMAND,	TKWM_DEICONIFY,
	TKWM_FOCUSMOD,	TKWM_FRAME,	TKWM_GEOMETRY,	TKWM_GRID,
	TKWM_GROUP,	TKWM_ICONBMP,	TKWM_ICONIFY,	TKWM_ICONMASK,
	TKWM_ICONNAME,	TKWM_ICONPOS,	TKWM_ICONWIN,	TKWM_MAXSIZE,
	TKWM_MINSIZE,	TKWM_OVERRIDE,	TKWM_POSFROM,	TKWM_PROTOCOL,
	TKWM_RESIZABLE,	TKWM_SIZEFROM,	TKWM_STATE,	TKWM_TITLE,
	TKWM_TRACING,	TKWM_TRANSIENT,	TKWM_WITHDRAW
    };

    tkwin = (Tk_Window) clientData;

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "option window ?arg?");
	return TCL_ERROR;
    }
    if (Tcl_GetIndexFromObj(interp, objv[1], optionStrings, "option", 0,
	    &index) != TCL_OK) {
	return TCL_ERROR;
    }

    if (index == TKWM_TRACING) {
	int wmTracing;
	TkDisplay *dispPtr = ((TkWindow *) tkwin)->dispPtr;

	if ((objc != 2) && (objc != 3)) {
	    Tcl_WrongNumArgs(interp, 1, objv, "tracing ?boolean?");
	    return TCL_ERROR;
	}
	if (objc == 2) {
	    Tcl_SetObjResult(interp,
		    Tcl_NewBooleanObj(dispPtr->flags & TK_DISPLAY_WM_TRACING));
	    return TCL_OK;
	}
	if (Tcl_GetBooleanFromObj(interp, objv[2], &wmTracing) != TCL_OK) {
	    return TCL_ERROR;
	}
	if (wmTracing) {
	    dispPtr->flags |= TK_DISPLAY_WM_TRACING;
	} else {
	    dispPtr->flags &= ~TK_DISPLAY_WM_TRACING;
	}
	return TCL_OK;
    }

    if (objc < 3) {
	Tcl_WrongNumArgs(interp, 2, objv, "window ?arg?");
	return TCL_ERROR;
    }

    winPtr = (TkWindow *) Tk_NameToWindow(interp,
	    Tcl_GetString(objv[2]), tkwin);
    if (winPtr == NULL) {
	return TCL_ERROR;
    }
    if (!(winPtr->flags & TK_TOP_LEVEL)) {
	Tcl_AppendResult(interp, "window \"", winPtr->pathName,
		"\" isn't a top-level window", (char *) NULL);
	return TCL_ERROR;
    }

    switch ((enum options) index) {
	case TKWM_ASPECT: {
	    TkpWmAspectCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_CLIENT: {
	    TkpWmClientCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_COMMAND: {
	    TkpWmCommandCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_DEICONIFY: {
	    TkpWmDeiconifyCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_FOCUSMOD: {
	    TkpWmFocusmodCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_FRAME: {
	    TkpWmFrameCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_GEOMETRY: {
	    TkpWmGeometryCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_GRID: {
	    TkpWmGridCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_GROUP: {
	    TkpWmGroupCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_ICONBMP: {
	    TkpWmIconbitmapCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_ICONIFY: {
	    TkpWmIconifyCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_ICONMASK: {
	    TkpWmIconmaskCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_ICONNAME: {
	    /* slight Unix variation */
	    TkpWmIconnameCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_ICONPOS: {
	    /* nearly same - 1 line more on Unix */
	    TkpWmIconpositionCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_ICONWIN: {
	    TkpWmIconwindowCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_MAXSIZE: {
	    /* nearly same, win diffs */
	    TkpWmMaxsizeCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_MINSIZE: {
	    /* nearly same, win diffs */
	    TkpWmMinsizeCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_OVERRIDE: {
	    /* almost same */
	    TkpWmOverrideCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_POSFROM: {
	    /* Equal across platforms */
	    TkpWmPositionfromCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_PROTOCOL: {
	    /* Equal across platforms */
	    TkpWmProtocolCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_RESIZABLE: {
	    /* almost same */
	    TkpWmResizableCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_SIZEFROM: {
	    /* Equal across platforms */
	    TkpWmSizefromCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_STATE: {
	    TkpWmStateCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_TITLE: {
	    TkpWmTitleCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_TRANSIENT: {
	    TkpWmTransientCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_WITHDRAW: {
	    TkpWmWithdrawCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
    }

    updateGeom:
    if (!(wmPtr->flags & (WM_UPDATE_PENDING|WM_NEVER_MAPPED))) {
	Tcl_DoWhenIdle(UpdateGeometryInfo, (ClientData) winPtr);
	wmPtr->flags |= WM_UPDATE_PENDING;
    }
    return TCL_OK;
}
#endif

/*
 *----------------------------------------------------------------------
 *
 * TkGetDisplayOf --
 *
 *	Parses a "-displayof window" option for various commands.  If
 *	present, the literal "-displayof" should be in objv[0] and the
 *	window name in objv[1].
 *
 * Results:
 *	The return value is 0 if the argument strings did not contain
 *	the "-displayof" option.  The return value is 2 if the
 *	argument strings contained both the "-displayof" option and
 *	a valid window name.  Otherwise, the return value is -1 if
 *	the window name was missing or did not specify a valid window.
 *
 *	If the return value was 2, *tkwinPtr is filled with the
 *	token for the window specified on the command line.  If the
 *	return value was -1, an error message is left in interp's
 *	result object.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
TkGetDisplayOf(interp, objc, objv, tkwinPtr)
    Tcl_Interp *interp;		/* Interpreter for error reporting. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. If it is present,
				 * "-displayof" should be in objv[0] and
				 * objv[1] the name of a window. */
    Tk_Window *tkwinPtr;	/* On input, contains main window of
				 * application associated with interp.  On
				 * output, filled with window specified as
				 * option to "-displayof" argument, or
				 * unmodified if "-displayof" argument was not
				 * present. */
{
    char *string;
    int length;
    
    if (objc < 1) {
	return 0;
    }
    string = Tcl_GetStringFromObj(objv[0], &length);
    if ((length >= 2) &&
	    (strncmp(string, "-displayof", (unsigned) length) == 0)) {
        if (objc < 2) {
	    Tcl_SetStringObj(Tcl_GetObjResult(interp),
		    "value for \"-displayof\" missing", -1);
	    return -1;
	}
	string = Tcl_GetStringFromObj(objv[1], NULL);
	*tkwinPtr = Tk_NameToWindow(interp, string, *tkwinPtr);
	if (*tkwinPtr == NULL) {
	    return -1;
	}
	return 2;
    }
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * TkDeadAppCmd --
 *
 *	If an application has been deleted then all Tk commands will be
 *	re-bound to this procedure.
 *
 * Results:
 *	A standard Tcl error is reported to let the user know that
 *	the application is dead.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
TkDeadAppCmd(clientData, interp, argc, argv)
    ClientData clientData;	/* Dummy. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int argc;			/* Number of arguments. */
    CONST char **argv;		/* Argument strings. */
{
    Tcl_AppendResult(interp, "can't invoke \"", argv[0],
	    "\" command:  application has been destroyed", (char *) NULL);
    return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 *
 * GetToplevel --
 *
 *	Retrieves the toplevel window which is the nearest ancestor of
 *	of the specified window.
 *
 * Results:
 *	Returns the toplevel window or NULL if the window has no
 *	ancestor which is a toplevel.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static TkWindow *
GetToplevel(tkwin)
    Tk_Window tkwin;		/* Window for which the toplevel should be
				 * deterined. */
{
     TkWindow *winPtr = (TkWindow *) tkwin;

     while (!(winPtr->flags & TK_TOP_LEVEL)) {
	 winPtr = winPtr->parentPtr;
	 if (winPtr == NULL) {
	     return NULL;
	 }
     }
     return winPtr;
}
@


1.4
log
@touched all sources to ease next import
@
text
@d9 1
d14 1
a14 1
 * RCS: @@(#) $Id: tkCmds.c,v 1.7.6.2 2000/09/26 16:07:54 spolk Exp $
d21 1
a21 1
#if defined(__WIN32__)
d25 2
d37 2
a38 2
			    Tcl_Interp *interp, char *name1, char *name2,
			    int flags));
d68 2
a69 1
    static char *bellOptions[] = {"-displayof", (char *) NULL};
d71 1
a71 2
    char *displayName;
    int index;
d73 2
a74 2
    if ((objc != 1) && (objc != 3)) {
	Tcl_WrongNumArgs(interp, 1, objv, "?-displayof window?");
d78 2
a79 2
    if (objc == 3) {
	if (Tcl_GetIndexFromObj(interp, objv[1], bellOptions, "option", 0,
d83 15
a97 5
	displayName = Tcl_GetStringFromObj(objv[2], (int *) NULL);
	
	tkwin = Tk_NameToWindow(interp, displayName, tkwin);
	if (tkwin == NULL) {
	    return TCL_ERROR;
d101 3
a103 1
    XForceScreenSaver(Tk_Display(tkwin), ScreenSaverReset);
d111 1
a111 1
 * Tk_BindCmd --
d126 1
a126 1
Tk_BindCmd(clientData, interp, argc, argv)
d129 2
a130 2
    int argc;			/* Number of arguments. */
    char **argv;		/* Argument strings. */
d135 4
a138 4

    if ((argc < 2) || (argc > 4)) {
	Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
		" window ?pattern? ?command?\"", (char *) NULL);
d141 10
a150 2
    if (argv[1][0] == '.') {
	winPtr = (TkWindow *) Tk_NameToWindow(interp, argv[1], tkwin);
d157 1
a157 1
	object = (ClientData) Tk_GetUid(argv[1]);
d160 8
a167 1
    if (argc == 4) {
d170 7
d178 1
a178 1
	if (argv[3][0] == 0) {
d180 1
a180 1
		    object, argv[2]);
d182 8
a189 2
	if (argv[3][0] == '+') {
	    argv[3]++;
d193 1
a193 1
		object, argv[2], argv[3], append);
d197 2
a198 2
    } else if (argc == 3) {
	char *command;
d201 1
a201 1
		object, argv[2]);
d206 1
a206 1
	Tcl_SetResult(interp, command, TCL_STATIC);
d275 1
a275 1
		(topLevPtr != NULL) && !(topLevPtr->flags & TK_TOP_LEVEL);
d297 1
a297 1
 * Tk_BindtagsCmd --
d312 1
a312 1
Tk_BindtagsCmd(clientData, interp, argc, argv)
d315 2
a316 2
    int argc;			/* Number of arguments. */
    char **argv;		/* Argument strings. */
d320 6
a325 6
    int i, tagArgc;
    char *p, **tagArgv;

    if ((argc < 2) || (argc > 3)) {
	Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
		" window ?tags?\"", (char *) NULL);
d328 2
a329 1
    winPtr = (TkWindow *) Tk_NameToWindow(interp, argv[1], tkwin);
d333 3
a335 1
    if (argc == 2) {
d337 7
a343 6
	    Tcl_AppendElement(interp, winPtr->pathName);
	    Tcl_AppendElement(interp, winPtr->classUid);
	    for (winPtr2 = winPtr;
		    (winPtr2 != NULL) && !(winPtr2->flags & TK_TOP_LEVEL);
		    winPtr2 = winPtr2->parentPtr) {
		/* Empty loop body. */
d346 2
a347 1
		Tcl_AppendElement(interp, winPtr2->pathName);
d349 2
a350 1
	    Tcl_AppendElement(interp, "all");
d353 2
a354 1
		Tcl_AppendElement(interp, (char *) winPtr->tagPtr[i]);
d357 2
d364 4
a367 1
    if (argv[2][0] == 0) {
d370 2
a371 4
    if (Tcl_SplitList(interp, argv[2], &tagArgc, &tagArgv) != TCL_OK) {
	return TCL_ERROR;
    }
    winPtr->numTags = tagArgc;
d373 3
a375 3
	    (tagArgc * sizeof(ClientData)));
    for (i = 0; i < tagArgc; i++) {
	p = tagArgv[i];
a392 1
    ckfree((char *) tagArgv);
d622 3
a624 2
    static char *optionStrings[] = {
	"appname",	"scaling",	"useinputmethods",	NULL
d627 2
a628 1
	TK_APPNAME,	TK_SCALING,	TK_USE_IM
d647 7
d667 79
d751 7
d795 7
d815 2
a816 2
		int bool;
		if (Tcl_GetBooleanFromObj(interp, objv[2+skip], &bool)
d821 5
a825 1
		dispPtr->useInputMethods = bool;
d833 20
a852 1
		    dispPtr->useInputMethods);
d862 1
a862 1
 * Tk_TkwaitCmd --
d878 1
a878 1
Tk_TkwaitCmd(clientData, interp, argc, argv)
d882 2
a883 2
    int argc;			/* Number of arguments. */
    char **argv;		/* Argument strings. */
d886 9
a894 2
    int c, done;
    size_t length;
d896 2
a897 3
    if (argc != 3) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
		argv[0], " variable|visibility|window name\"", (char *) NULL);
d900 16
a915 8
    c = argv[1][0];
    length = strlen(argv[1]);
    if ((c == 'v') && (strncmp(argv[1], "variable", length) == 0)
	    && (length >= 2)) {
	if (Tcl_TraceVar(interp, argv[2],
		TCL_GLOBAL_ONLY|TCL_TRACE_WRITES|TCL_TRACE_UNSETS,
		WaitVariableProc, (ClientData) &done) != TCL_OK) {
	    return TCL_ERROR;
d917 3
a919 10
	done = 0;
	while (!done) {
	    Tcl_DoOneEvent(0);
	}
	Tcl_UntraceVar(interp, argv[2],
		TCL_GLOBAL_ONLY|TCL_TRACE_WRITES|TCL_TRACE_UNSETS,
		WaitVariableProc, (ClientData) &done);
    } else if ((c == 'v') && (strncmp(argv[1], "visibility", length) == 0)
	    && (length >= 2)) {
	Tk_Window window;
d921 27
a947 3
	window = Tk_NameToWindow(interp, argv[2], tkwin);
	if (window == NULL) {
	    return TCL_ERROR;
d949 14
a962 7
	Tk_CreateEventHandler(window, VisibilityChangeMask|StructureNotifyMask,
	    WaitVisibilityProc, (ClientData) &done);
	done = 0;
	while (!done) {
	    Tcl_DoOneEvent(0);
	}
	if (done != 1) {
d964 2
a965 2
	     * Note that we do not delete the event handler because it
	     * was deleted automatically when the window was destroyed.
d967 1
a967 6

	    Tcl_ResetResult(interp);
	    Tcl_AppendResult(interp, "window \"", argv[2],
		    "\" was deleted before its visibility changed",
		    (char *) NULL);
	    return TCL_ERROR;
a968 23
	Tk_DeleteEventHandler(window, VisibilityChangeMask|StructureNotifyMask,
	    WaitVisibilityProc, (ClientData) &done);
    } else if ((c == 'w') && (strncmp(argv[1], "window", length) == 0)) {
	Tk_Window window;

	window = Tk_NameToWindow(interp, argv[2], tkwin);
	if (window == NULL) {
	    return TCL_ERROR;
	}
	Tk_CreateEventHandler(window, StructureNotifyMask,
	    WaitWindowProc, (ClientData) &done);
	done = 0;
	while (!done) {
	    Tcl_DoOneEvent(0);
	}
	/*
	 * Note:  there's no need to delete the event handler.  It was
	 * deleted automatically when the window was destroyed.
	 */
    } else {
	Tcl_AppendResult(interp, "bad option \"", argv[1],
		"\": must be variable, visibility, or window", (char *) NULL);
	return TCL_ERROR;
d985 2
a986 2
    char *name1;		/* Name of variable. */
    char *name2;		/* Second part of variable name. */
d1049 1
a1049 1
    static char *updateOptions[] = {"idletasks", (char *) NULL};
d1137 1
a1137 1
    static char *optionStrings[] = {
d1211 4
a1214 2
		strPtr = Tcl_NewStringObj(winPtr->pathName, -1);
		Tcl_ListObjAppendElement(NULL, resultPtr, strPtr);
d1376 1
a1376 1
		if (winPtr->flags & TK_TOP_LEVEL) {
d1456 1
a1456 1
	    char *name;
d1521 1
a1521 1
	    int id;
d1535 1
a1535 2
	    winPtr = (TkWindow *)
	            Tk_IdToWindow(Tk_Display(tkwin), (Window) id);
d1728 1
a1728 1
    static char *optionStrings[] = {
d1759 1
d1767 2
a1768 1
	    Tcl_SetObjResult(interp, Tcl_NewBooleanObj(dispPtr->wmTracing));
d1771 9
a1779 1
	return Tcl_GetBooleanFromObj(interp, objv[2], &dispPtr->wmTracing);
d2012 1
a2012 1
    char **argv;		/* Argument strings. */
a2051 2


@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d8 1
a8 2
 * Copyright (c) 1994-1996 Sun Microsystems, Inc.
 * Copyright (c) 1998 by Scriptics Corporation.
d13 1
a13 1
 * RCS: @@(#) $Id: tkCmds.c,v 1.8 1999/01/26 04:11:20 jingham Exp $
d20 8
d65 1
d67 1
a68 4
    char *string;
    static char *optionStrings[] = {
	"-displayof",	NULL
    };
d76 1
a76 1
	if (Tcl_GetIndexFromObj(interp, objv[1], optionStrings, "option", 0,
d80 3
a82 2
	string = Tcl_GetStringFromObj(objv[2], NULL);
	tkwin = Tk_NameToWindow(interp, string, tkwin);
d163 1
a163 1
	interp->result = command;
a194 1
    static Tk_Uid allUid = NULL;
d242 1
a242 4
	if (allUid == NULL) {
	    allUid = Tk_GetUid("all");
	}
	objPtr[count-1] = (ClientData) allUid;
d388 1
a388 1
 * Tk_DestroyCmd --
d403 1
a403 1
Tk_DestroyCmd(clientData, interp, argc, argv)
d407 2
a408 2
    int argc;			/* Number of arguments. */
    char **argv;		/* Argument strings. */
d414 2
a415 2
    for (i = 1; i < argc; i++) {
	window = Tk_NameToWindow(interp, argv[i], tkwin);
d437 1
a437 1
 * Tk_LowerCmd --
d453 1
a453 1
Tk_LowerCmd(clientData, interp, argc, argv)
d457 2
a458 2
    int argc;			/* Number of arguments. */
    char **argv;		/* Argument strings. */
d463 2
a464 3
    if ((argc != 2) && (argc != 3)) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
		argv[0], " window ?belowThis?\"", (char *) NULL);
d468 1
a468 1
    tkwin = Tk_NameToWindow(interp, argv[1], mainwin);
d472 1
a472 1
    if (argc == 2) {
d475 1
a475 1
	other = Tk_NameToWindow(interp, argv[2], mainwin);
d481 3
a483 2
	Tcl_AppendResult(interp, "can't lower \"", argv[1], "\" below \"",
		argv[2], "\"", (char *) NULL);
d492 1
a492 1
 * Tk_RaiseCmd --
d508 1
a508 1
Tk_RaiseCmd(clientData, interp, argc, argv)
d512 2
a513 2
    int argc;			/* Number of arguments. */
    char **argv;		/* Argument strings. */
d518 2
a519 3
    if ((argc != 2) && (argc != 3)) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
		argv[0], " window ?aboveThis?\"", (char *) NULL);
d523 1
a523 1
    tkwin = Tk_NameToWindow(interp, argv[1], mainwin);
d527 1
a527 1
    if (argc == 2) {
d530 1
a530 1
	other = Tk_NameToWindow(interp, argv[2], mainwin);
d536 3
a538 2
	Tcl_AppendResult(interp, "can't raise \"", argv[1], "\" above \"",
		argv[2], "\"", (char *) NULL);
d571 1
a571 1
	"appname",	"scaling",	NULL
d574 1
a574 1
	TK_APPNAME,	TK_SCALING
d603 1
a603 1
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), winPtr->nameUid, -1);
d610 1
a610 1
	    
d623 1
a623 1
		if (Tcl_GetDoubleFromObj(interp, objv[2 + skip], &d) != TCL_OK) {
d644 34
d839 1
a839 1
 * Tk_UpdateCmd --
d855 1
a855 1
Tk_UpdateCmd(clientData, interp, argc, argv)
d859 2
a860 2
    int argc;			/* Number of arguments. */
    char **argv;		/* Argument strings. */
d862 2
a863 1
    int flags;
d866 1
a866 1
    if (argc == 1) {
d868 3
a870 4
    } else if (argc == 2) {
	if (strncmp(argv[1], "idletasks", strlen(argv[1])) != 0) {
	    Tcl_AppendResult(interp, "bad option \"", argv[1],
		    "\": must be idletasks", (char *) NULL);
d875 1
a875 2
	Tcl_AppendResult(interp, "wrong # args: should be \"",
		argv[0], " ?idletasks?\"", (char *) NULL);
d887 1
a887 1

d892 1
a892 1
	for (dispPtr = tkDisplayList; dispPtr != NULL;
a935 1
    char buf[128];
d939 1
d1012 1
d1016 1
a1016 3
	    Tcl_ResetResult(interp);
	    Tcl_SetIntObj(Tcl_GetObjResult(interp),
		    Tk_Visual(tkwin)->map_entries);
a1021 1
	    Tcl_ResetResult(interp);
d1025 1
a1025 2
		Tcl_ListObjAppendElement(NULL,
		     Tcl_GetObjResult(interp), strPtr);
d1030 1
a1030 2
	    Tcl_ResetResult(interp);
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), Tk_Class(tkwin), -1);
d1034 1
a1034 2
	    Tcl_ResetResult(interp);
	    Tcl_SetBooleanObj(Tcl_GetObjResult(interp),
d1039 1
a1039 2
	    Tcl_ResetResult(interp);
	    Tcl_SetIntObj(Tcl_GetObjResult(interp), Tk_Depth(tkwin));
d1043 2
a1044 1
	    Tcl_ResetResult(interp);
d1047 1
a1047 1
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), buf, -1);
d1051 1
a1051 2
	    Tcl_ResetResult(interp);
	    Tcl_SetIntObj(Tcl_GetObjResult(interp), Tk_Height(tkwin));
d1055 2
d1059 1
a1059 2
	    Tcl_ResetResult(interp);
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), buf, -1);
d1063 1
a1063 3
	    Tcl_ResetResult(interp);
	    Tcl_SetBooleanObj(Tcl_GetObjResult(interp),
		    (int) Tk_IsMapped(tkwin));
a1066 1
	    Tcl_ResetResult(interp);
d1068 1
a1068 2
		Tcl_SetStringObj(Tcl_GetObjResult(interp),
		        winPtr->geomMgrPtr->name, -1);
d1073 1
a1073 2
	    Tcl_ResetResult(interp);
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), Tk_Name(tkwin), -1);
a1076 1
	    Tcl_ResetResult(interp);
d1078 1
a1078 2
		Tcl_SetStringObj(Tcl_GetObjResult(interp),
		        winPtr->parentPtr->pathName, -1);
a1103 1
	    Tcl_ResetResult(interp);
d1105 2
d1108 1
a1108 1
		Tcl_SetStringObj(Tcl_GetObjResult(interp), buf, -1);
d1110 1
a1110 1
		Tcl_SetIntObj(Tcl_GetObjResult(interp), x);
d1112 1
a1112 1
		Tcl_SetIntObj(Tcl_GetObjResult(interp), y);
d1117 1
a1117 2
	    Tcl_ResetResult(interp);
	    Tcl_SetIntObj(Tcl_GetObjResult(interp), Tk_ReqHeight(tkwin));
d1121 1
a1121 2
	    Tcl_ResetResult(interp);
	    Tcl_SetIntObj(Tcl_GetObjResult(interp), Tk_ReqWidth(tkwin));
d1126 1
a1126 2
	    Tcl_ResetResult(interp);
	    Tcl_SetIntObj(Tcl_GetObjResult(interp), x);
d1131 1
a1131 2
	    Tcl_ResetResult(interp);
	    Tcl_SetIntObj(Tcl_GetObjResult(interp), y);
d1135 2
d1138 2
a1139 3
	    Tcl_ResetResult(interp);
	    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		    Tk_DisplayName(tkwin), ".", buf, NULL);
d1143 1
a1143 3
	    Tcl_ResetResult(interp);
	    Tcl_SetIntObj(Tcl_GetObjResult(interp),
		    CellsOfScreen(Tk_Screen(tkwin)));
d1147 1
a1147 3
	    Tcl_ResetResult(interp);
	    Tcl_SetIntObj(Tcl_GetObjResult(interp),
		    DefaultDepthOfScreen(Tk_Screen(tkwin)));
d1151 1
a1151 3
	    Tcl_ResetResult(interp);
	    Tcl_SetIntObj(Tcl_GetObjResult(interp),
		    HeightOfScreen(Tk_Screen(tkwin)));
d1155 1
a1155 3
	    Tcl_ResetResult(interp);
	    Tcl_SetIntObj(Tcl_GetObjResult(interp),
		    WidthOfScreen(Tk_Screen(tkwin)));
d1159 1
a1159 3
	    Tcl_ResetResult(interp);
	    Tcl_SetIntObj(Tcl_GetObjResult(interp),
		    HeightMMOfScreen(Tk_Screen(tkwin)));
d1163 1
a1163 3
	    Tcl_ResetResult(interp);
	    Tcl_SetIntObj(Tcl_GetObjResult(interp),
		    WidthMMOfScreen(Tk_Screen(tkwin)));
d1177 1
a1177 3
		Tcl_ResetResult(interp);
		Tcl_SetStringObj(Tcl_GetObjResult(interp),
			winPtr->pathName, -1);
d1182 1
a1182 3
	    int viewable;

	    viewable = 0;
d1192 2
a1193 2
	    Tcl_ResetResult(interp);
	    Tcl_SetBooleanObj(Tcl_GetObjResult(interp), viewable);
d1204 1
a1204 2
	    Tcl_ResetResult(interp);
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), string, -1);
d1208 2
a1209 1
	    Tcl_ResetResult(interp);
d1212 1
a1212 1
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), buf, -1);
d1217 1
a1217 2
	    Tcl_ResetResult(interp);
	    Tcl_SetIntObj(Tcl_GetObjResult(interp), height);
d1222 1
a1222 2
	    Tcl_ResetResult(interp);
	    Tcl_SetIntObj(Tcl_GetObjResult(interp), width);
d1227 1
a1227 2
	    Tcl_ResetResult(interp);
	    Tcl_SetIntObj(Tcl_GetObjResult(interp), x);
d1232 1
a1232 2
	    Tcl_ResetResult(interp);
	    Tcl_SetIntObj(Tcl_GetObjResult(interp), y);
d1236 1
a1236 2
	    Tcl_ResetResult(interp);
	    Tcl_SetIntObj(Tcl_GetObjResult(interp), Tk_Width(tkwin));
d1240 1
a1240 2
	    Tcl_ResetResult(interp);
	    Tcl_SetIntObj(Tcl_GetObjResult(interp), Tk_X(tkwin));
d1244 1
a1244 2
	    Tcl_ResetResult(interp);
	    Tcl_SetIntObj(Tcl_GetObjResult(interp), Tk_Y(tkwin));
d1263 1
a1263 3
	    Tcl_ResetResult(interp);
	    Tcl_SetLongObj(Tcl_GetObjResult(interp),
		    (long) Tk_InternAtom(tkwin, string));
a1281 1
	    Tcl_ResetResult(interp);
d1285 1
a1285 1
		Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
d1289 1
a1289 1
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), name, -1);
d1313 1
a1313 3
		Tcl_ResetResult(interp);
		Tcl_SetStringObj(Tcl_GetObjResult(interp),
			Tk_PathName(tkwin), -1);
d1350 1
a1350 3
		Tcl_ResetResult(interp);
		Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
			"window id \"", string,
d1363 1
a1363 3
		Tcl_ResetResult(interp);
		Tcl_SetStringObj(Tcl_GetObjResult(interp),
		        Tk_PathName(tkwin), -1);
d1381 3
d1388 1
a1388 2
	    Tcl_ResetResult(interp); /* clear any error msg */
	    Tcl_SetBooleanObj(Tcl_GetObjResult(interp), alive);
d1408 2
a1409 3
		/ WidthMMOfScreen(Tk_Screen(tkwin));
	    Tcl_ResetResult(interp);
	    Tcl_SetDoubleObj(Tcl_GetObjResult(interp), pixels);
d1428 1
a1428 2
	    Tcl_ResetResult(interp);
	    Tcl_SetIntObj(Tcl_GetObjResult(interp), pixels);
d1433 1
d1452 1
a1452 2
	    Tcl_ResetResult(interp);
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), buf, -1);
a1457 1
	    char visualIdString[16];
d1460 2
a1482 1
	    Tcl_ResetResult(interp);
d1484 1
a1484 1
		Tcl_SetStringObj(Tcl_GetObjResult(interp),
d1501 1
a1501 2
		Tcl_ListObjAppendElement(NULL, Tcl_GetObjResult(interp),
		        strPtr);
d1510 215
d1773 2
a1774 1
    if ((length >= 2) && (strncmp(string, "-displayof", (unsigned) length) == 0)) {
d1854 2
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d8 2
a9 1
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
d14 1
a14 1
 * RCS: @@(#) $Id: tkCmds.c,v 1.7.6.2 2000/09/26 16:07:54 spolk Exp $
a20 8
#if defined(__WIN32__)
#include "tkWinInt.h"
#elif defined(MAC_TCL)
#include "tkMacInt.h"
#else
#include "tkUnixInt.h"
#endif

a57 1
    static char *bellOptions[] = {"-displayof", (char *) NULL};
a58 1
    char *displayName;
d60 4
d71 1
a71 1
	if (Tcl_GetIndexFromObj(interp, objv[1], bellOptions, "option", 0,
d75 2
a76 3
	displayName = Tcl_GetStringFromObj(objv[2], (int *) NULL);
	
	tkwin = Tk_NameToWindow(interp, displayName, tkwin);
d157 1
a157 1
	Tcl_SetResult(interp, command, TCL_STATIC);
d189 1
d237 4
a240 1
	objPtr[count-1] = (ClientData) Tk_GetUid("all");
d386 1
a386 1
 * Tk_DestroyObjCmd --
d401 1
a401 1
Tk_DestroyObjCmd(clientData, interp, objc, objv)
d405 2
a406 2
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
d412 2
a413 2
    for (i = 1; i < objc; i++) {
	window = Tk_NameToWindow(interp, Tcl_GetString(objv[i]), tkwin);
d435 1
a435 1
 * Tk_LowerObjCmd --
d451 1
a451 1
Tk_LowerObjCmd(clientData, interp, objc, objv)
d455 2
a456 2
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
d461 3
a463 2
    if ((objc != 2) && (objc != 3)) {
	Tcl_WrongNumArgs(interp, 1, objv, "window ?belowThis?");
d467 1
a467 1
    tkwin = Tk_NameToWindow(interp, Tcl_GetString(objv[1]), mainwin);
d471 1
a471 1
    if (objc == 2) {
d474 1
a474 1
	other = Tk_NameToWindow(interp, Tcl_GetString(objv[2]), mainwin);
d480 2
a481 3
	Tcl_AppendResult(interp, "can't lower \"", Tcl_GetString(objv[1]),
		"\" below \"", (other ? Tcl_GetString(objv[2]) : ""),
		"\"", (char *) NULL);
d490 1
a490 1
 * Tk_RaiseObjCmd --
d506 1
a506 1
Tk_RaiseObjCmd(clientData, interp, objc, objv)
d510 2
a511 2
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
d516 3
a518 2
    if ((objc != 2) && (objc != 3)) {
	Tcl_WrongNumArgs(interp, 1, objv, "window ?aboveThis?");
d522 1
a522 1
    tkwin = Tk_NameToWindow(interp, Tcl_GetString(objv[1]), mainwin);
d526 1
a526 1
    if (objc == 2) {
d529 1
a529 1
	other = Tk_NameToWindow(interp, Tcl_GetString(objv[2]), mainwin);
d535 2
a536 3
	Tcl_AppendResult(interp, "can't raise \"", Tcl_GetString(objv[1]),
		"\" above \"", (other ? Tcl_GetString(objv[2]) : ""),
		"\"", (char *) NULL);
d569 1
a569 1
	"appname",	"scaling",	"useinputmethods",	NULL
d572 1
a572 1
	TK_APPNAME,	TK_SCALING,	TK_USE_IM
d601 1
a601 1
	    Tcl_AppendResult(interp, winPtr->nameUid, NULL);
d608 1
a608 1

d621 1
a621 1
		if (Tcl_GetDoubleFromObj(interp, objv[2+skip], &d) != TCL_OK) {
a641 34
	case TK_USE_IM: {
	    TkDisplay *dispPtr = ((TkWindow *) tkwin)->dispPtr;
	    int skip;

	    skip = TkGetDisplayOf(interp, objc-2, objv+2, &tkwin);
	    if (skip < 0) {
		return TCL_ERROR;
	    } else if (skip) {
		dispPtr = ((TkWindow *) tkwin)->dispPtr;
	    }
	    if ((objc - skip) == 3) {
		/*
		 * In the case where TK_USE_INPUT_METHODS is not defined,
		 * this will be ignored and we will always return 0.
		 * That will indicate to the user that input methods
		 * are just not available.
		 */
		int bool;
		if (Tcl_GetBooleanFromObj(interp, objv[2+skip], &bool)
			!= TCL_OK) {
		    return TCL_ERROR;
		}
#ifdef TK_USE_INPUT_METHODS
		dispPtr->useInputMethods = bool;
#endif /* TK_USE_INPUT_METHODS */
	    } else if ((objc - skip) != 2) {
		Tcl_WrongNumArgs(interp, 2, objv,
			"?-displayof window? ?boolean?");
		return TCL_ERROR;
	    }
	    Tcl_SetBooleanObj(Tcl_GetObjResult(interp),
		    dispPtr->useInputMethods);
	    break;
	}
d803 1
a803 1
 * Tk_UpdateObjCmd --
d819 1
a819 1
Tk_UpdateObjCmd(clientData, interp, objc, objv)
d823 2
a824 2
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
d826 1
a826 2
    static char *updateOptions[] = {"idletasks", (char *) NULL};
    int flags, index;
d829 1
a829 1
    if (objc == 1) {
d831 4
a834 3
    } else if (objc == 2) {
	if (Tcl_GetIndexFromObj(interp, objv[1], updateOptions, "option", 0,
		&index) != TCL_OK) {
d839 2
a840 1
        Tcl_WrongNumArgs(interp, 1, objv, "?idletasks?");
d852 1
a852 1
  
d857 1
a857 1
	for (dispPtr = TkGetDisplayList(); dispPtr != NULL;
d901 1
a904 1
    Tcl_Obj *resultPtr;
a976 1
    resultPtr = Tcl_GetObjResult(interp);
d980 3
a982 1
	    Tcl_SetIntObj(resultPtr, Tk_Visual(tkwin)->map_entries);
d988 1
d992 2
a993 1
		Tcl_ListObjAppendElement(NULL, resultPtr, strPtr);
d998 2
a999 1
	    Tcl_SetStringObj(resultPtr, Tk_Class(tkwin), -1);
d1003 2
a1004 1
	    Tcl_SetBooleanObj(resultPtr,
d1009 2
a1010 1
	    Tcl_SetIntObj(resultPtr, Tk_Depth(tkwin));
d1014 1
a1014 2
	    char buf[16 + TCL_INTEGER_SPACE * 4];

d1017 1
a1017 1
	    Tcl_SetStringObj(resultPtr, buf, -1);
d1021 2
a1022 1
	    Tcl_SetIntObj(resultPtr, Tk_Height(tkwin));
a1025 2
	    char buf[TCL_INTEGER_SPACE];
	    
d1028 2
a1029 1
	    Tcl_SetStringObj(resultPtr, buf, -1);
d1033 3
a1035 1
	    Tcl_SetBooleanObj(resultPtr, (int) Tk_IsMapped(tkwin));
d1039 1
d1041 2
a1042 1
		Tcl_SetStringObj(resultPtr, winPtr->geomMgrPtr->name, -1);
d1047 2
a1048 1
	    Tcl_SetStringObj(resultPtr, Tk_Name(tkwin), -1);
d1052 1
d1054 2
a1055 1
		Tcl_SetStringObj(resultPtr, winPtr->parentPtr->pathName, -1);
d1081 1
a1082 2
		char buf[TCL_INTEGER_SPACE * 2];
		
d1084 1
a1084 1
		Tcl_SetStringObj(resultPtr, buf, -1);
d1086 1
a1086 1
		Tcl_SetIntObj(resultPtr, x);
d1088 1
a1088 1
		Tcl_SetIntObj(resultPtr, y);
d1093 2
a1094 1
	    Tcl_SetIntObj(resultPtr, Tk_ReqHeight(tkwin));
d1098 2
a1099 1
	    Tcl_SetIntObj(resultPtr, Tk_ReqWidth(tkwin));
d1104 2
a1105 1
	    Tcl_SetIntObj(resultPtr, x);
d1110 2
a1111 1
	    Tcl_SetIntObj(resultPtr, y);
a1114 2
	    char buf[TCL_INTEGER_SPACE];
	    
d1116 3
a1118 2
	    Tcl_AppendStringsToObj(resultPtr, Tk_DisplayName(tkwin), ".",
		    buf, NULL);
d1122 3
a1124 1
	    Tcl_SetIntObj(resultPtr, CellsOfScreen(Tk_Screen(tkwin)));
d1128 3
a1130 1
	    Tcl_SetIntObj(resultPtr, DefaultDepthOfScreen(Tk_Screen(tkwin)));
d1134 3
a1136 1
	    Tcl_SetIntObj(resultPtr, HeightOfScreen(Tk_Screen(tkwin)));
d1140 3
a1142 1
	    Tcl_SetIntObj(resultPtr, WidthOfScreen(Tk_Screen(tkwin)));
d1146 3
a1148 1
	    Tcl_SetIntObj(resultPtr, HeightMMOfScreen(Tk_Screen(tkwin)));
d1152 3
a1154 1
	    Tcl_SetIntObj(resultPtr, WidthMMOfScreen(Tk_Screen(tkwin)));
d1168 3
a1170 1
		Tcl_SetStringObj(resultPtr, winPtr->pathName, -1);
d1175 3
a1177 1
	    int viewable = 0;
d1187 2
a1188 2

	    Tcl_SetBooleanObj(resultPtr, viewable);
d1199 2
a1200 1
	    Tcl_SetStringObj(resultPtr, string, -1);
d1204 1
a1204 2
	    char buf[TCL_INTEGER_SPACE];

d1207 1
a1207 1
	    Tcl_SetStringObj(resultPtr, buf, -1);
d1212 2
a1213 1
	    Tcl_SetIntObj(resultPtr, height);
d1218 2
a1219 1
	    Tcl_SetIntObj(resultPtr, width);
d1224 2
a1225 1
	    Tcl_SetIntObj(resultPtr, x);
d1230 2
a1231 1
	    Tcl_SetIntObj(resultPtr, y);
d1235 2
a1236 1
	    Tcl_SetIntObj(resultPtr, Tk_Width(tkwin));
d1240 2
a1241 1
	    Tcl_SetIntObj(resultPtr, Tk_X(tkwin));
d1245 2
a1246 1
	    Tcl_SetIntObj(resultPtr, Tk_Y(tkwin));
d1265 3
a1267 1
	    Tcl_SetLongObj(resultPtr, (long) Tk_InternAtom(tkwin, string));
d1286 1
d1290 1
a1290 1
		Tcl_AppendStringsToObj(resultPtr, 
d1294 1
a1294 1
	    Tcl_SetStringObj(resultPtr, name, -1);
d1318 3
a1320 1
		Tcl_SetStringObj(resultPtr, Tk_PathName(tkwin), -1);
d1357 3
a1359 1
		Tcl_AppendStringsToObj(resultPtr, "window id \"", string,
d1372 3
a1374 1
		Tcl_SetStringObj(resultPtr, Tk_PathName(tkwin), -1);
a1391 3
	    Tcl_ResetResult(interp);
	    resultPtr = Tcl_GetObjResult(interp);

d1396 2
a1397 1
	    Tcl_SetBooleanObj(resultPtr, alive);
d1417 3
a1419 2
		    / WidthMMOfScreen(Tk_Screen(tkwin));
	    Tcl_SetDoubleObj(resultPtr, pixels);
d1438 2
a1439 1
	    Tcl_SetIntObj(resultPtr, pixels);
a1443 1
	    char buf[TCL_INTEGER_SPACE * 3];
d1462 2
a1463 1
	    Tcl_SetStringObj(resultPtr, buf, -1);
d1469 1
a1471 2
	    char buf[16 + TCL_INTEGER_SPACE];
	    char visualIdString[TCL_INTEGER_SPACE];
d1493 1
d1495 1
a1495 1
		Tcl_SetStringObj(resultPtr,
d1512 2
a1513 1
		Tcl_ListObjAppendElement(NULL, resultPtr, strPtr);
a1521 215
#if 0
/*
 *----------------------------------------------------------------------
 *
 * Tk_WmObjCmd --
 *
 *	This procedure is invoked to process the "wm" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tk_WmObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Main window associated with
				 * interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Tk_Window tkwin;
    TkWindow *winPtr;

    static char *optionStrings[] = {
	"aspect",	"client",	"command",	"deiconify",
	"focusmodel",	"frame",	"geometry",	"grid",
	"group",	"iconbitmap",	"iconify",	"iconmask",
	"iconname",	"iconposition",	"iconwindow",	"maxsize",
	"minsize",	"overrideredirect",	"positionfrom",	"protocol",
	"resizable",	"sizefrom",	"state",	"title",
	"tracing",	"transient",	"withdraw",	(char *) NULL
    };
    enum options {
	TKWM_ASPECT,	TKWM_CLIENT,	TKWM_COMMAND,	TKWM_DEICONIFY,
	TKWM_FOCUSMOD,	TKWM_FRAME,	TKWM_GEOMETRY,	TKWM_GRID,
	TKWM_GROUP,	TKWM_ICONBMP,	TKWM_ICONIFY,	TKWM_ICONMASK,
	TKWM_ICONNAME,	TKWM_ICONPOS,	TKWM_ICONWIN,	TKWM_MAXSIZE,
	TKWM_MINSIZE,	TKWM_OVERRIDE,	TKWM_POSFROM,	TKWM_PROTOCOL,
	TKWM_RESIZABLE,	TKWM_SIZEFROM,	TKWM_STATE,	TKWM_TITLE,
	TKWM_TRACING,	TKWM_TRANSIENT,	TKWM_WITHDRAW
    };

    tkwin = (Tk_Window) clientData;

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "option window ?arg?");
	return TCL_ERROR;
    }
    if (Tcl_GetIndexFromObj(interp, objv[1], optionStrings, "option", 0,
	    &index) != TCL_OK) {
	return TCL_ERROR;
    }

    if (index == TKWM_TRACING) {
	TkDisplay *dispPtr = ((TkWindow *) tkwin)->dispPtr;

	if ((objc != 2) && (objc != 3)) {
	    Tcl_WrongNumArgs(interp, 1, objv, "tracing ?boolean?");
	    return TCL_ERROR;
	}
	if (objc == 2) {
	    Tcl_SetObjResult(interp, Tcl_NewBooleanObj(dispPtr->wmTracing));
	    return TCL_OK;
	}
	return Tcl_GetBooleanFromObj(interp, objv[2], &dispPtr->wmTracing);
    }

    if (objc < 3) {
	Tcl_WrongNumArgs(interp, 2, objv, "window ?arg?");
	return TCL_ERROR;
    }

    winPtr = (TkWindow *) Tk_NameToWindow(interp,
	    Tcl_GetString(objv[2]), tkwin);
    if (winPtr == NULL) {
	return TCL_ERROR;
    }
    if (!(winPtr->flags & TK_TOP_LEVEL)) {
	Tcl_AppendResult(interp, "window \"", winPtr->pathName,
		"\" isn't a top-level window", (char *) NULL);
	return TCL_ERROR;
    }

    switch ((enum options) index) {
	case TKWM_ASPECT: {
	    TkpWmAspectCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_CLIENT: {
	    TkpWmClientCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_COMMAND: {
	    TkpWmCommandCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_DEICONIFY: {
	    TkpWmDeiconifyCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_FOCUSMOD: {
	    TkpWmFocusmodCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_FRAME: {
	    TkpWmFrameCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_GEOMETRY: {
	    TkpWmGeometryCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_GRID: {
	    TkpWmGridCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_GROUP: {
	    TkpWmGroupCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_ICONBMP: {
	    TkpWmIconbitmapCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_ICONIFY: {
	    TkpWmIconifyCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_ICONMASK: {
	    TkpWmIconmaskCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_ICONNAME: {
	    /* slight Unix variation */
	    TkpWmIconnameCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_ICONPOS: {
	    /* nearly same - 1 line more on Unix */
	    TkpWmIconpositionCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_ICONWIN: {
	    TkpWmIconwindowCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_MAXSIZE: {
	    /* nearly same, win diffs */
	    TkpWmMaxsizeCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_MINSIZE: {
	    /* nearly same, win diffs */
	    TkpWmMinsizeCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_OVERRIDE: {
	    /* almost same */
	    TkpWmOverrideCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_POSFROM: {
	    /* Equal across platforms */
	    TkpWmPositionfromCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_PROTOCOL: {
	    /* Equal across platforms */
	    TkpWmProtocolCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_RESIZABLE: {
	    /* almost same */
	    TkpWmResizableCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_SIZEFROM: {
	    /* Equal across platforms */
	    TkpWmSizefromCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_STATE: {
	    TkpWmStateCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_TITLE: {
	    TkpWmTitleCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_TRANSIENT: {
	    TkpWmTransientCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
	case TKWM_WITHDRAW: {
	    TkpWmWithdrawCmd(interp, tkwin, winPtr, objc, objv);
	    break;
	}
    }

    updateGeom:
    if (!(wmPtr->flags & (WM_UPDATE_PENDING|WM_NEVER_MAPPED))) {
	Tcl_DoWhenIdle(UpdateGeometryInfo, (ClientData) winPtr);
	wmPtr->flags |= WM_UPDATE_PENDING;
    }
    return TCL_OK;
}
#endif

d1570 1
a1570 2
    if ((length >= 2) &&
	    (strncmp(string, "-displayof", (unsigned) length) == 0)) {
a1649 2


@


1.1.1.3
log
@import tk 8.4.0
@
text
@a8 1
 * Copyright (c) 2000 Scriptics Corporation.
d13 1
a13 1
 * RCS: @@(#) $Id: tkCmds.c,v 1.31 2002/09/02 19:16:23 hobbs Exp $
d20 1
a20 1
#if defined(WIN32)
a23 2
#elif defined(MAC_OSX_TK) 
#include "tkMacOSXInt.h"
d34 2
a35 2
			    Tcl_Interp *interp, CONST char *name1,
			    CONST char *name2, int flags));
d65 1
a65 2
    static CONST char *bellOptions[] = {"-displayof", "-nice", (char *) NULL};
    enum options { TK_BELL_DISPLAYOF, TK_BELL_NICE };
d67 2
a68 1
    int i, index, nice = 0;
d70 2
a71 2
    if (objc > 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "?-displayof window? ?-nice?");
d75 2
a76 2
    for (i = 1; i < objc; i++) {
	if (Tcl_GetIndexFromObj(interp, objv[i], bellOptions, "option", 0,
d80 5
a84 15
	switch ((enum options) index) {
	    case TK_BELL_DISPLAYOF:
		if (++i >= objc) {
		    Tcl_WrongNumArgs(interp, 1, objv,
			    "?-displayof window? ?-nice?");
		    return TCL_ERROR;
		}
		tkwin = Tk_NameToWindow(interp, Tcl_GetString(objv[i]), tkwin);
		if (tkwin == NULL) {
		    return TCL_ERROR;
		}
		break;
	    case TK_BELL_NICE:
		nice = 1;
		break;
d88 1
a88 3
    if (!nice) {
	XForceScreenSaver(Tk_Display(tkwin), ScreenSaverReset);
    }
d96 1
a96 1
 * Tk_BindObjCmd --
d111 1
a111 1
Tk_BindObjCmd(clientData, interp, objc, objv)
d114 2
a115 2
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
d120 4
a123 4
    char *string;
    
    if ((objc < 2) || (objc > 4)) {
	Tcl_WrongNumArgs(interp, 1, objv, "window ?pattern? ?command?");
d126 2
a127 10
    string = Tcl_GetString(objv[1]);
    
    /*
     * Bind tags either a window name or a tag name for the first argument.
     * If the argument starts with ".", assume it is a window; otherwise, it
     * is a tag.
     */

    if (string[0] == '.') {
	winPtr = (TkWindow *) Tk_NameToWindow(interp, string, tkwin);
d134 1
a134 1
	object = (ClientData) Tk_GetUid(string);
d137 1
a137 8
    /*
     * If there are four arguments, the command is modifying a binding.  If
     * there are three arguments, the command is querying a binding.  If there
     * are only two arguments, the command is querying all the bindings for
     * the given tag/window.
     */

    if (objc == 4) {
a139 7
	char *sequence, *script;
	sequence	= Tcl_GetString(objv[2]);
	script		= Tcl_GetString(objv[3]);
	
	/*
	 * If the script is null, just delete the binding.
	 */
d141 1
a141 1
	if (script[0] == 0) {
d143 1
a143 1
		    object, sequence);
d145 2
a146 8

	/*
	 * If the script begins with "+", append this script to the existing
	 * binding.
	 */
	
	if (script[0] == '+') {
	    script++;
d150 1
a150 1
		object, sequence, script, append);
d154 2
a155 2
    } else if (objc == 3) {
	CONST char *command;
d158 1
a158 1
		object, Tcl_GetString(objv[2]));
d163 1
a163 1
	Tcl_SetResult(interp, (char *) command, TCL_STATIC);
d232 1
a232 1
		(topLevPtr != NULL) && !(topLevPtr->flags & TK_TOP_HIERARCHY);
d254 1
a254 1
 * Tk_BindtagsObjCmd --
d269 1
a269 1
Tk_BindtagsObjCmd(clientData, interp, objc, objv)
d272 2
a273 2
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
d277 6
a282 6
    int i, length;
    char *p;
    Tcl_Obj *listPtr, **tags;
    
    if ((objc < 2) || (objc > 3)) {
	Tcl_WrongNumArgs(interp, 1, objv, "window ?taglist?");
d285 1
a285 2
    winPtr = (TkWindow *) Tk_NameToWindow(interp, Tcl_GetString(objv[1]),
	    tkwin);
d289 1
a289 3
    if (objc == 2) {
	listPtr = Tcl_NewObj();
	Tcl_IncrRefCount(listPtr);
d291 6
a296 7
	    Tcl_ListObjAppendElement(interp, listPtr,
		    Tcl_NewStringObj(winPtr->pathName, -1));
	    Tcl_ListObjAppendElement(interp, listPtr,
		    Tcl_NewStringObj(winPtr->classUid, -1));
	    winPtr2 = winPtr;
	    while ((winPtr2 != NULL) && !(Tk_TopWinHierarchy(winPtr2))) {
		winPtr2 = winPtr2->parentPtr;
d299 1
a299 2
		Tcl_ListObjAppendElement(interp, listPtr,
			Tcl_NewStringObj(winPtr2->pathName, -1));
d301 1
a301 2
	    Tcl_ListObjAppendElement(interp, listPtr,
		    Tcl_NewStringObj("all", -1));
d304 1
a304 2
		Tcl_ListObjAppendElement(interp, listPtr,
			Tcl_NewStringObj((char *)winPtr->tagPtr[i], -1));
a306 2
	Tcl_SetObjResult(interp, listPtr);
	Tcl_DecrRefCount(listPtr);
d312 4
a315 1
    if (Tcl_ListObjGetElements(interp, objv[2], &length, &tags) != TCL_OK) {
d318 1
a318 5
    if (length == 0) {
	return TCL_OK;
    }

    winPtr->numTags = length;
d320 3
a322 3
	    (length * sizeof(ClientData)));
    for (i = 0; i < length; i++) {
	p = Tcl_GetString(tags[i]);
d340 1
d570 2
a571 3
    static CONST char *optionStrings[] = {
	"appname",	"caret",	"scaling",	"useinputmethods",
	"windowingsystem",		NULL
d574 1
a574 2
	TK_APPNAME,	TK_CARET,	TK_SCALING,	TK_USE_IM,
	TK_WINDOWINGSYSTEM
a592 7
	    if (Tcl_IsSafe(interp)) {
		Tcl_SetResult(interp,
			"appname not accessible in a safe interpreter",
			TCL_STATIC);
		return TCL_ERROR;
	    }

a605 79
	case TK_CARET: {
	    Tcl_Obj *objPtr;
	    TkCaret *caretPtr;
	    Tk_Window window;
	    static CONST char *caretStrings[]
		= { "-x",	"-y", "-height", NULL };
	    enum caretOptions
		{ TK_CARET_X, TK_CARET_Y, TK_CARET_HEIGHT };

	    if ((objc < 3) || ((objc > 4) && !(objc & 1))) {
	        Tcl_WrongNumArgs(interp, 2, objv,
			"window ?-x x? ?-y y? ?-height height?");
		return TCL_ERROR;
	    }
	    window = Tk_NameToWindow(interp, Tcl_GetString(objv[2]), tkwin);
	    if (window == NULL) {
		return TCL_ERROR;
	    }
	    caretPtr = &(((TkWindow *) window)->dispPtr->caret);
	    if (objc == 3) {
		/*
		 * Return all the current values
		 */
		objPtr = Tcl_NewObj();
		Tcl_ListObjAppendElement(interp, objPtr,
			Tcl_NewStringObj("-height", 7));
		Tcl_ListObjAppendElement(interp, objPtr,
			Tcl_NewIntObj(caretPtr->height));
		Tcl_ListObjAppendElement(interp, objPtr,
			Tcl_NewStringObj("-x", 2));
		Tcl_ListObjAppendElement(interp, objPtr,
			Tcl_NewIntObj(caretPtr->x));
		Tcl_ListObjAppendElement(interp, objPtr,
			Tcl_NewStringObj("-y", 2));
		Tcl_ListObjAppendElement(interp, objPtr,
			Tcl_NewIntObj(caretPtr->y));
		Tcl_SetObjResult(interp, objPtr);
	    } else if (objc == 4) {
		int value;
		/*
		 * Return the current value of the selected option
		 */
		if (Tcl_GetIndexFromObj(interp, objv[3], caretStrings,
			"caret option", 0, &index) != TCL_OK) {
		    return TCL_ERROR;
		}
		if (index == TK_CARET_X) {
		    value = caretPtr->x;
		} else if (index == TK_CARET_Y) {
		    value = caretPtr->y;
		} else /* if (index == TK_CARET_HEIGHT) -- last case */ {
		    value = caretPtr->height;
		}
		Tcl_SetIntObj(Tcl_GetObjResult(interp), value);
	    } else {
		int i, value, x = 0, y = 0, height = -1;

		for (i = 3; i < objc; i += 2) {
		    if ((Tcl_GetIndexFromObj(interp, objv[i], caretStrings,
			    "caret option", 0, &index) != TCL_OK) ||
			    (Tcl_GetIntFromObj(interp, objv[i+1], &value)
				!= TCL_OK)) {
			return TCL_ERROR;
		    }
		    if (index == TK_CARET_X) {
			x = value;
		    } else if (index == TK_CARET_Y) {
			y = value;
		    } else /* if (index == TK_CARET_HEIGHT) -- last case */ {
			height = value;
		    }
		}
		if (height < 0) {
		    height = Tk_Height(window);
		}
		Tk_SetCaretPos(window, x, y, height);
	    }
	    break;
	}
a610 7
	    if (Tcl_IsSafe(interp)) {
		Tcl_SetResult(interp,
			"scaling not accessible in a safe interpreter",
			TCL_STATIC);
		return TCL_ERROR;
	    }

a647 7
	    if (Tcl_IsSafe(interp)) {
		Tcl_SetResult(interp,
			"useinputmethods not accessible in a safe interpreter",
			TCL_STATIC);
		return TCL_ERROR;
	    }

d661 2
a662 2
		int boolVal;
		if (Tcl_GetBooleanFromObj(interp, objv[2+skip], &boolVal)
d667 1
a667 5
		if (boolVal) {
		    dispPtr->flags |= TK_DISPLAY_USE_IM;
		} else {
		    dispPtr->flags &= ~TK_DISPLAY_USE_IM;
		}
d675 1
a675 20
		    (int) (dispPtr->flags & TK_DISPLAY_USE_IM));
	    break;
	}
        case TK_WINDOWINGSYSTEM: {
	    CONST char *windowingsystem;
	    
	    if (objc != 2) {
	        Tcl_WrongNumArgs(interp, 2, objv, NULL);
		return TCL_ERROR;
	    }
#if defined(WIN32)
	    windowingsystem = "win32";
#elif defined(MAC_TCL)
	    windowingsystem = "classic";
#elif defined(MAC_OSX_TK)
	    windowingsystem = "aqua";
#else
	    windowingsystem = "x11";
#endif
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), windowingsystem, -1);
d685 1
a685 1
 * Tk_TkwaitObjCmd --
d701 1
a701 1
Tk_TkwaitObjCmd(clientData, interp, objc, objv)
d705 2
a706 2
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
d709 2
a710 9
    int done, index;
    static CONST char *optionStrings[] = { "variable", "visibility", "window",
					 (char *) NULL };
    enum options { TKWAIT_VARIABLE, TKWAIT_VISIBILITY, TKWAIT_WINDOW };
    
    if (objc != 3) {
	Tcl_WrongNumArgs(interp, 1, objv, "variable|visibility|window name");
	return TCL_ERROR;
    }
d712 3
a714 2
    if (Tcl_GetIndexFromObj(interp, objv[1], optionStrings, "option", 0,
	    &index) != TCL_OK) {
d717 19
d737 3
a739 15
    switch ((enum options) index) {
	case TKWAIT_VARIABLE: {
	    if (Tcl_TraceVar(interp, Tcl_GetString(objv[2]),
		    TCL_GLOBAL_ONLY|TCL_TRACE_WRITES|TCL_TRACE_UNSETS,
		    WaitVariableProc, (ClientData) &done) != TCL_OK) {
		return TCL_ERROR;
	    }
	    done = 0;
	    while (!done) {
		Tcl_DoOneEvent(0);
	    }
	    Tcl_UntraceVar(interp, Tcl_GetString(objv[2]),
		    TCL_GLOBAL_ONLY|TCL_TRACE_WRITES|TCL_TRACE_UNSETS,
		    WaitVariableProc, (ClientData) &done);
	    break;
d741 5
a745 31
	
	case TKWAIT_VISIBILITY: {
	    Tk_Window window;

	    window = Tk_NameToWindow(interp, Tcl_GetString(objv[2]), tkwin);
	    if (window == NULL) {
		return TCL_ERROR;
	    }
	    Tk_CreateEventHandler(window,
		    VisibilityChangeMask|StructureNotifyMask,
		    WaitVisibilityProc, (ClientData) &done);
	    done = 0;
	    while (!done) {
		Tcl_DoOneEvent(0);
	    }
	    if (done != 1) {
		/*
		 * Note that we do not delete the event handler because it
		 * was deleted automatically when the window was destroyed.
		 */
		
		Tcl_ResetResult(interp);
		Tcl_AppendResult(interp, "window \"", Tcl_GetString(objv[2]),
			"\" was deleted before its visibility changed",
			(char *) NULL);
		return TCL_ERROR;
	    }
	    Tk_DeleteEventHandler(window,
		    VisibilityChangeMask|StructureNotifyMask,
		    WaitVisibilityProc, (ClientData) &done);
	    break;
d747 1
a747 14
	
	case TKWAIT_WINDOW: {
	    Tk_Window window;
	    
	    window = Tk_NameToWindow(interp, Tcl_GetString(objv[2]), tkwin);
	    if (window == NULL) {
		return TCL_ERROR;
	    }
	    Tk_CreateEventHandler(window, StructureNotifyMask,
		    WaitWindowProc, (ClientData) &done);
	    done = 0;
	    while (!done) {
		Tcl_DoOneEvent(0);
	    }
d749 2
a750 2
	     * Note:  there's no need to delete the event handler.  It was
	     * deleted automatically when the window was destroyed.
d752 21
a772 1
	    break;
d774 8
d798 2
a799 2
    CONST char *name1;		/* Name of variable. */
    CONST char *name2;		/* Second part of variable name. */
d862 1
a862 1
    static CONST char *updateOptions[] = {"idletasks", (char *) NULL};
d950 1
a950 1
    static CONST char *optionStrings[] = {
d1024 2
a1025 4
		if (!(winPtr->flags & TK_ANONYMOUS_WINDOW)) {
		    strPtr = Tcl_NewStringObj(winPtr->pathName, -1);
		    Tcl_ListObjAppendElement(NULL, resultPtr, strPtr);
		}
d1187 1
a1187 1
		if (winPtr->flags & TK_TOP_HIERARCHY) {
d1267 1
a1267 1
	    CONST char *name;
d1332 1
a1332 1
	    Window id;
d1346 2
a1347 1
	    winPtr = (TkWindow *)Tk_IdToWindow(Tk_Display(tkwin), id);
d1540 1
a1540 1
    static CONST char *optionStrings[] = {
a1570 1
	int wmTracing;
d1578 1
a1578 2
	    Tcl_SetObjResult(interp,
		    Tcl_NewBooleanObj(dispPtr->flags & TK_DISPLAY_WM_TRACING));
d1581 1
a1581 9
	if (Tcl_GetBooleanFromObj(interp, objv[2], &wmTracing) != TCL_OK) {
	    return TCL_ERROR;
	}
	if (wmTracing) {
	    dispPtr->flags |= TK_DISPLAY_WM_TRACING;
	} else {
	    dispPtr->flags &= ~TK_DISPLAY_WM_TRACING;
	}
	return TCL_OK;
d1814 1
a1814 1
    CONST char **argv;		/* Argument strings. */
d1854 2
@


