head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.20.24.45;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.13;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.25;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.51;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.33;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.18;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@/* 
 * tkPlace.c --
 *
 *	This file contains code to implement a simple geometry manager
 *	for Tk based on absolute placement or "rubber-sheet" placement.
 *
 * Copyright (c) 1992-1994 The Regents of the University of California.
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkPlace.c,v 1.12 2002/06/14 22:25:12 jenglish Exp $
 */

#include "tkPort.h"
#include "tkInt.h"


/*
 * Border modes for relative placement:
 *
 * BM_INSIDE:		relative distances computed using area inside
 *			all borders of master window.
 * BM_OUTSIDE:		relative distances computed using outside area
 *			that includes all borders of master.
 * BM_IGNORE:		border issues are ignored:  place relative to
 *			master's actual window size.
 */

static char *borderModeStrings[] = {
    "inside", "outside", "ignore", (char *) NULL
};

typedef enum {BM_INSIDE, BM_OUTSIDE, BM_IGNORE} BorderMode;

/*
 * For each window whose geometry is managed by the placer there is
 * a structure of the following type:
 */

typedef struct Slave {
    Tk_Window tkwin;		/* Tk's token for window. */
    Tk_Window inTkwin;		/* Token for the -in window. */
    struct Master *masterPtr;	/* Pointer to information for window
				 * relative to which tkwin is placed.
				 * This isn't necessarily the logical
				 * parent of tkwin.  NULL means the
				 * master was deleted or never assigned. */
    struct Slave *nextPtr;	/* Next in list of windows placed relative
				 * to same master (NULL for end of list). */
    /*
     * Geometry information for window;  where there are both relative
     * and absolute values for the same attribute (e.g. x and relX) only
     * one of them is actually used, depending on flags.
     */

    int x, y;			/* X and Y pixel coordinates for tkwin. */
    Tcl_Obj *xPtr, *yPtr;	/* Tcl_Obj rep's of x, y coords, to keep
				 * pixel spec. information */
    double relX, relY;		/* X and Y coordinates relative to size of
				 * master. */
    int width, height;		/* Absolute dimensions for tkwin. */
    Tcl_Obj *widthPtr;		/* Tcl_Obj rep of width, to keep pixel spec */
    Tcl_Obj *heightPtr;		/* Tcl_Obj rep of height, to keep pixel spec */
    double relWidth, relHeight;	/* Dimensions for tkwin relative to size of
				 * master. */
    Tcl_Obj *relWidthPtr;
    Tcl_Obj *relHeightPtr;
    Tk_Anchor anchor;		/* Which point on tkwin is placed at the
				 * given position. */
    BorderMode borderMode;	/* How to treat borders of master window. */
    int flags;			/* Various flags;  see below for bit
				 * definitions. */
} Slave;

/*
 * Type masks for options:
 */
#define IN_MASK		1

static Tk_OptionSpec optionSpecs[] = {
    {TK_OPTION_ANCHOR, "-anchor", NULL, NULL, "nw", -1,
	 Tk_Offset(Slave, anchor), 0, 0, 0},
    {TK_OPTION_STRING_TABLE, "-bordermode", NULL, NULL, "inside", -1,
	 Tk_Offset(Slave, borderMode), 0, (ClientData) borderModeStrings, 0},
    {TK_OPTION_PIXELS, "-height", NULL, NULL, "", Tk_Offset(Slave, heightPtr),
	 Tk_Offset(Slave, height), TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_WINDOW, "-in", NULL, NULL, "", -1, Tk_Offset(Slave, inTkwin),
	 0, 0, IN_MASK},
    {TK_OPTION_DOUBLE, "-relheight", NULL, NULL, "",
	 Tk_Offset(Slave, relHeightPtr), Tk_Offset(Slave, relHeight),
	 TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_DOUBLE, "-relwidth", NULL, NULL, "",
	 Tk_Offset(Slave, relWidthPtr), Tk_Offset(Slave, relWidth),
	 TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_DOUBLE, "-relx", NULL, NULL, "0", -1,
	 Tk_Offset(Slave, relX), 0, 0, 0},
    {TK_OPTION_DOUBLE, "-rely", NULL, NULL, "0", -1,
	 Tk_Offset(Slave, relY), 0, 0, 0},
    {TK_OPTION_PIXELS, "-width", NULL, NULL, "", Tk_Offset(Slave, widthPtr),
	 Tk_Offset(Slave, width), TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_PIXELS, "-x", NULL, NULL, "0", Tk_Offset(Slave, xPtr),
	 Tk_Offset(Slave, x), TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_PIXELS, "-y", NULL, NULL, "0", Tk_Offset(Slave, yPtr),
	 Tk_Offset(Slave, y), TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_END, (char *) NULL, (char *) NULL, (char *) NULL,
	 (char *) NULL, 0, -1, 0, 0, 0}
};
	
/*
 * Flag definitions for Slave structures:
 *
 * CHILD_WIDTH -		1 means -width was specified;
 * CHILD_REL_WIDTH -		1 means -relwidth was specified.
 * CHILD_HEIGHT -		1 means -height was specified;
 * CHILD_REL_HEIGHT -		1 means -relheight was specified.
 */

#define CHILD_WIDTH		1
#define CHILD_REL_WIDTH		2
#define CHILD_HEIGHT		4
#define CHILD_REL_HEIGHT	8

/*
 * For each master window that has a slave managed by the placer there
 * is a structure of the following form:
 */

typedef struct Master {
    Tk_Window tkwin;		/* Tk's token for master window. */
    struct Slave *slavePtr;	/* First in linked list of slaves
				 * placed relative to this master. */
    int flags;			/* See below for bit definitions. */
} Master;

/*
 * Flag definitions for masters:
 *
 * PARENT_RECONFIG_PENDING -	1 means that a call to RecomputePlacement
 *				is already pending via a Do_When_Idle handler.
 */

#define PARENT_RECONFIG_PENDING	1

/*
 * The following structure is the official type record for the
 * placer:
 */

static void		PlaceRequestProc _ANSI_ARGS_((ClientData clientData,
			    Tk_Window tkwin));
static void		PlaceLostSlaveProc _ANSI_ARGS_((ClientData clientData,
			    Tk_Window tkwin));

static Tk_GeomMgr placerType = {
    "place",				/* name */
    PlaceRequestProc,			/* requestProc */
    PlaceLostSlaveProc,			/* lostSlaveProc */
};

/*
 * Forward declarations for procedures defined later in this file:
 */

static void		SlaveStructureProc _ANSI_ARGS_((ClientData clientData,
			    XEvent *eventPtr));
static int		ConfigureSlave _ANSI_ARGS_((Tcl_Interp *interp,
			    Tk_Window tkwin, Tk_OptionTable table,
			    int objc, Tcl_Obj *CONST objv[]));
static int		PlaceInfoCommand _ANSI_ARGS_((Tcl_Interp *interp,
			    Tk_Window tkwin));
static Slave *		CreateSlave _ANSI_ARGS_((Tk_Window tkwin));
static Slave *		FindSlave _ANSI_ARGS_((Tk_Window tkwin));
static Master *		CreateMaster _ANSI_ARGS_((Tk_Window tkwin));
static Master *		FindMaster _ANSI_ARGS_((Tk_Window tkwin));
static void		MasterStructureProc _ANSI_ARGS_((ClientData clientData,
			    XEvent *eventPtr));
static void		RecomputePlacement _ANSI_ARGS_((ClientData clientData));
static void		UnlinkSlave _ANSI_ARGS_((Slave *slavePtr));

/*
 *--------------------------------------------------------------
 *
 * Tk_PlaceObjCmd --
 *
 *	This procedure is invoked to process the "place" Tcl
 *	commands.  See the user documentation for details on
 *	what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *--------------------------------------------------------------
 */

int
Tk_PlaceObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* NULL. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Tk_Window tkwin;
    Slave *slavePtr;
    char *string;
    TkDisplay *dispPtr;
    Tk_OptionTable optionTable;
    static CONST char *optionStrings[] = {
	"configure", "forget", "info", "slaves", (char *) NULL
    };
    enum options { PLACE_CONFIGURE, PLACE_FORGET, PLACE_INFO, PLACE_SLAVES };
    int index;
    
    
    if (objc < 3) {
	Tcl_WrongNumArgs(interp, 1, objv, "option|pathName args");
	return TCL_ERROR;
    }

    /*
     * Create the option table for this widget class.  If it has already
     * been created, the cached pointer will be returned.
     */

    optionTable = Tk_CreateOptionTable(interp, optionSpecs);

    /*
     * Handle special shortcut where window name is first argument.
     */

    string = Tcl_GetString(objv[1]);
    if (string[0] == '.') {
	tkwin = Tk_NameToWindow(interp, string,	Tk_MainWindow(interp));
	if (tkwin == NULL) {
	    return TCL_ERROR;
	}

	/*
	 * Initialize, if that hasn't been done yet.
	 */

	dispPtr = ((TkWindow *) tkwin)->dispPtr;
	if (!dispPtr->placeInit) {
	    Tcl_InitHashTable(&dispPtr->masterTable, TCL_ONE_WORD_KEYS);
	    Tcl_InitHashTable(&dispPtr->slaveTable, TCL_ONE_WORD_KEYS);
	    dispPtr->placeInit = 1;
	}

	return ConfigureSlave(interp, tkwin, optionTable, objc-2, objv+2);
    }

    /*
     * Handle more general case of option followed by window name followed
     * by possible additional arguments.
     */

    tkwin = Tk_NameToWindow(interp, Tcl_GetString(objv[2]),
	    Tk_MainWindow(interp));
    if (tkwin == NULL) {
	return TCL_ERROR;
    }

    /*
     * Initialize, if that hasn't been done yet.
     */

    dispPtr = ((TkWindow *) tkwin)->dispPtr;
    if (!dispPtr->placeInit) {
	Tcl_InitHashTable(&dispPtr->masterTable, TCL_ONE_WORD_KEYS);
	Tcl_InitHashTable(&dispPtr->slaveTable, TCL_ONE_WORD_KEYS);
	dispPtr->placeInit = 1;
    }

    if (Tcl_GetIndexFromObj(interp, objv[1], optionStrings, "option", 0,
	    &index) != TCL_OK) {
	return TCL_ERROR;
    }

    switch ((enum options) index) {
	case PLACE_CONFIGURE: {
	    Tcl_Obj *objPtr;
	    if (objc == 3 || objc == 4) {
		slavePtr = FindSlave(tkwin);
		if (slavePtr == NULL) {
		    return TCL_OK;
		}
		objPtr = Tk_GetOptionInfo(interp, (char *) slavePtr,
			optionTable,
			(objc == 4) ? objv[3] : (Tcl_Obj *) NULL, tkwin);
		if (objPtr == NULL) {
		    return TCL_ERROR;
		} else {
		    Tcl_SetObjResult(interp, objPtr);
		    return TCL_OK;
		}
	    } else {
		return ConfigureSlave(interp, tkwin, optionTable, objc-3,
			objv+3);
	    }
	}
	
	case PLACE_FORGET: {
	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "pathName");
		return TCL_ERROR;
	    }
	    slavePtr = FindSlave(tkwin);
	    if (slavePtr == NULL) {
		return TCL_OK;
	    }
	    if ((slavePtr->masterPtr != NULL) &&
		    (slavePtr->masterPtr->tkwin !=
			    Tk_Parent(slavePtr->tkwin))) {
		Tk_UnmaintainGeometry(slavePtr->tkwin,
			slavePtr->masterPtr->tkwin);
	    }
	    UnlinkSlave(slavePtr);
	    Tcl_DeleteHashEntry(Tcl_FindHashEntry(&dispPtr->slaveTable,
		    (char *) tkwin));
	    Tk_DeleteEventHandler(tkwin, StructureNotifyMask,
		    SlaveStructureProc,	(ClientData) slavePtr);
	    Tk_ManageGeometry(tkwin, (Tk_GeomMgr *) NULL, (ClientData) NULL);
	    Tk_UnmapWindow(tkwin);
	    ckfree((char *) slavePtr);
	    break;
	}
	
	case PLACE_INFO: {
	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "pathName");
		return TCL_ERROR;
	    }
	    return PlaceInfoCommand(interp, tkwin);
	}

	case PLACE_SLAVES: {
	    Master *masterPtr;
	    Tcl_Obj *listPtr;
	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "pathName");
		return TCL_ERROR;
	    }
	    masterPtr = FindMaster(tkwin);
	    if (masterPtr != NULL) {
		listPtr = Tcl_NewObj();
		for (slavePtr = masterPtr->slavePtr; slavePtr != NULL;
		     slavePtr = slavePtr->nextPtr) {
		    Tcl_ListObjAppendElement(interp, listPtr,
			    Tcl_NewStringObj(Tk_PathName(slavePtr->tkwin),-1));
		}
		Tcl_SetObjResult(interp, listPtr);
	    }
	    break;
	}
    }

    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * CreateSlave --
 *
 *	Given a Tk_Window token, find the Slave structure corresponding
 *	to that token, creating a new one if necessary.
 *
 * Results:
 *	Pointer to the Slave structure.
 *
 * Side effects:
 *	A new Slave structure may be created.
 *
 *----------------------------------------------------------------------
 */

static Slave *
CreateSlave(tkwin)
    Tk_Window tkwin;		/* Token for desired slave. */
{
    Tcl_HashEntry *hPtr;
    register Slave *slavePtr;
    int new;
    TkDisplay * dispPtr = ((TkWindow *) tkwin)->dispPtr;

    hPtr = Tcl_CreateHashEntry(&dispPtr->slaveTable, (char *) tkwin, &new);
    if (new) {
	slavePtr = (Slave *) ckalloc(sizeof(Slave));
	memset(slavePtr, 0, sizeof(Slave));
	slavePtr->tkwin		= tkwin;
	slavePtr->inTkwin	= None;
	slavePtr->anchor	= TK_ANCHOR_NW;
	slavePtr->borderMode	= BM_INSIDE;
	Tcl_SetHashValue(hPtr, slavePtr);
	Tk_CreateEventHandler(tkwin, StructureNotifyMask, SlaveStructureProc,
		(ClientData) slavePtr);
	Tk_ManageGeometry(tkwin, &placerType, (ClientData) slavePtr);
    } else {
	slavePtr = (Slave *) Tcl_GetHashValue(hPtr);
    }
    return slavePtr;
}

/*
 *----------------------------------------------------------------------
 *
 * FindSlave --
 *
 *	Given a Tk_Window token, find the Slave structure corresponding
 *	to that token.  This is purely a lookup function; it will not
 *	create a record if one does not yet exist.
 *
 * Results:
 *	Pointer to Slave structure; NULL if none exists.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static Slave *
FindSlave(tkwin)
    Tk_Window tkwin;		/* Token for desired slave. */
{
    Tcl_HashEntry *hPtr;
    register Slave *slavePtr;
    TkDisplay * dispPtr = ((TkWindow *) tkwin)->dispPtr;

    hPtr = Tcl_FindHashEntry(&dispPtr->slaveTable, (char *) tkwin);
    if (hPtr == NULL) {
	return NULL;
    }
    slavePtr = (Slave *) Tcl_GetHashValue(hPtr);
    return slavePtr;
}

/*
 *----------------------------------------------------------------------
 *
 * UnlinkSlave --
 *
 *	This procedure removes a slave window from the chain of slaves
 *	in its master.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The slave list of slavePtr's master changes.
 *
 *----------------------------------------------------------------------
 */

static void
UnlinkSlave(slavePtr)
    Slave *slavePtr;		/* Slave structure to be unlinked. */
{
    register Master *masterPtr;
    register Slave *prevPtr;

    masterPtr = slavePtr->masterPtr;
    if (masterPtr == NULL) {
	return;
    }
    if (masterPtr->slavePtr == slavePtr) {
	masterPtr->slavePtr = slavePtr->nextPtr;
    } else {
	for (prevPtr = masterPtr->slavePtr; ;
		prevPtr = prevPtr->nextPtr) {
	    if (prevPtr == NULL) {
		panic("UnlinkSlave couldn't find slave to unlink");
	    }
	    if (prevPtr->nextPtr == slavePtr) {
		prevPtr->nextPtr = slavePtr->nextPtr;
		break;
	    }
	}
    }
    slavePtr->masterPtr = NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * CreateMaster --
 *
 *	Given a Tk_Window token, find the Master structure corresponding
 *	to that token, creating a new one if necessary.
 *
 * Results:
 *	Pointer to the Master structure.
 *
 * Side effects:
 *	A new Master structure may be created.
 *
 *----------------------------------------------------------------------
 */

static Master *
CreateMaster(tkwin)
    Tk_Window tkwin;		/* Token for desired master. */
{
    Tcl_HashEntry *hPtr;
    register Master *masterPtr;
    int new;
    TkDisplay * dispPtr = ((TkWindow *) tkwin)->dispPtr;

    hPtr = Tcl_CreateHashEntry(&dispPtr->masterTable, (char *) tkwin, &new);
    if (new) {
	masterPtr = (Master *) ckalloc(sizeof(Master));
	masterPtr->tkwin	= tkwin;
	masterPtr->slavePtr	= NULL;
	masterPtr->flags	= 0;
	Tcl_SetHashValue(hPtr, masterPtr);
	Tk_CreateEventHandler(masterPtr->tkwin, StructureNotifyMask,
		MasterStructureProc, (ClientData) masterPtr);
    } else {
	masterPtr = (Master *) Tcl_GetHashValue(hPtr);
    }
    return masterPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * FindMaster --
 *
 *	Given a Tk_Window token, find the Master structure corresponding
 *	to that token.  This is simply a lookup procedure; a new record
 *	will not be created if one does not already exist.
 *
 * Results:
 *	Pointer to the Master structure; NULL if one does not exist for
 *	the given Tk_Window token.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static Master *
FindMaster(tkwin)
    Tk_Window tkwin;		/* Token for desired master. */
{
    Tcl_HashEntry *hPtr;
    register Master *masterPtr;
    TkDisplay * dispPtr = ((TkWindow *) tkwin)->dispPtr;

    hPtr = Tcl_FindHashEntry(&dispPtr->masterTable, (char *) tkwin);
    if (hPtr == NULL) {
	return NULL;
    }
    masterPtr = (Master *) Tcl_GetHashValue(hPtr);
    return masterPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * ConfigureSlave --
 *
 *	This procedure is called to process an argv/argc list to
 *	reconfigure the placement of a window.
 *
 * Results:
 *	A standard Tcl result.  If an error occurs then a message is
 *	left in the interp's result.
 *
 * Side effects:
 *	Information in slavePtr may change, and slavePtr's master is
 *	scheduled for reconfiguration.
 *
 *----------------------------------------------------------------------
 */

static int
ConfigureSlave(interp, tkwin, table, objc, objv)
    Tcl_Interp *interp;		/* Used for error reporting. */
    Tk_Window tkwin;		/* Token for the window to manipulate. */
    Tk_OptionTable table;	/* Token for option table. */
    int objc;			/* Number of config arguments. */
    Tcl_Obj *CONST objv[];	/* Object values for arguments. */
{
    register Master *masterPtr;
    Tk_SavedOptions savedOptions;
    int mask;
    int result = TCL_OK;
    Slave *slavePtr;
    
    if (Tk_TopWinHierarchy(tkwin)) {
	Tcl_AppendResult(interp, "can't use placer on top-level window \"",
		Tk_PathName(tkwin), "\"; use wm command instead",
		(char *) NULL);
	return TCL_ERROR;
    }

    slavePtr = CreateSlave(tkwin);
    
    if (Tk_SetOptions(interp, (char *)slavePtr, table, objc, objv,
	    slavePtr->tkwin, &savedOptions, &mask) != TCL_OK) {
	Tk_RestoreSavedOptions(&savedOptions);
	result = TCL_ERROR;
	goto done;
    }

    if (mask & IN_MASK) {
	/* -in changed */
	Tk_Window tkwin;
	Tk_Window ancestor;
	
	tkwin = slavePtr->inTkwin;
	
	/*
	 * Make sure that the new master is either the logical parent
	 * of the slave or a descendant of that window, and that the
	 * master and slave aren't the same.
	 */
	
	for (ancestor = tkwin; ; ancestor = Tk_Parent(ancestor)) {
	    if (ancestor == Tk_Parent(slavePtr->tkwin)) {
		break;
	    }
	    if (Tk_TopWinHierarchy(ancestor)) {
		Tcl_AppendResult(interp, "can't place ",
			Tk_PathName(slavePtr->tkwin), " relative to ",
			Tk_PathName(tkwin), (char *) NULL);
		result = TCL_ERROR;
		Tk_RestoreSavedOptions(&savedOptions);
		goto done;
	    }
	}
	if (slavePtr->tkwin == tkwin) {
	    Tcl_AppendResult(interp, "can't place ",
		    Tk_PathName(slavePtr->tkwin), " relative to itself",
		    (char *) NULL);
	    result = TCL_ERROR;
	    Tk_RestoreSavedOptions(&savedOptions);
	    goto done;
	}
	if ((slavePtr->masterPtr != NULL)
		&& (slavePtr->masterPtr->tkwin == tkwin)) {
	    /*
	     * Re-using same old master.  Nothing to do.
	     */
	} else {
	    if ((slavePtr->masterPtr != NULL)
		    && (slavePtr->masterPtr->tkwin
			    != Tk_Parent(slavePtr->tkwin))) {
		Tk_UnmaintainGeometry(slavePtr->tkwin,
			slavePtr->masterPtr->tkwin);
	    }
	    UnlinkSlave(slavePtr);
	    slavePtr->masterPtr = CreateMaster(tkwin);
	    slavePtr->nextPtr = slavePtr->masterPtr->slavePtr;
	    slavePtr->masterPtr->slavePtr = slavePtr;
	}
    }

    /*
     * Set slave flags.  First clear the field, then add bits as needed.
     */

    slavePtr->flags = 0;
    if (slavePtr->heightPtr) {
	slavePtr->flags |= CHILD_HEIGHT;
    }

    if (slavePtr->relHeightPtr) {
	slavePtr->flags |= CHILD_REL_HEIGHT;
    }

    if (slavePtr->relWidthPtr) {
	slavePtr->flags |= CHILD_REL_WIDTH;
    }

    if (slavePtr->widthPtr) {
	slavePtr->flags |= CHILD_WIDTH;
    }

    /*
     * If there's no master specified for this slave, use its Tk_Parent.
     * Then arrange for a placement recalculation in the master.
     */

    Tk_FreeSavedOptions(&savedOptions);
    done:
    masterPtr = slavePtr->masterPtr;
    if (masterPtr == NULL) {
	masterPtr = CreateMaster(Tk_Parent(slavePtr->tkwin));
	slavePtr->masterPtr = masterPtr;
	slavePtr->nextPtr = masterPtr->slavePtr;
	masterPtr->slavePtr = slavePtr;
    }
    slavePtr->inTkwin = masterPtr->tkwin;
    if (!(masterPtr->flags & PARENT_RECONFIG_PENDING)) {
	masterPtr->flags |= PARENT_RECONFIG_PENDING;
	Tcl_DoWhenIdle(RecomputePlacement, (ClientData) masterPtr);
    }
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * PlaceInfoCommand --
 *
 *	Implementation of the [place info] subcommand.  See the user
 *	documentation for information on what it does.
 *
 * Results:
 *	Standard Tcl result.
 *
 * Side effects:
 *	If the given tkwin is managed by the placer, this function will
 *	put information about that placement in the interp's result.
 *
 *----------------------------------------------------------------------
 */

static int
PlaceInfoCommand(interp, tkwin)
    Tcl_Interp *interp;		/* Interp into which to place result. */
    Tk_Window tkwin;		/* Token for the window to get info on. */
{
    char buffer[32 + TCL_INTEGER_SPACE];
    Slave *slavePtr;
    
    slavePtr = FindSlave(tkwin);
    if (slavePtr == NULL) {
	return TCL_OK;
    }
    sprintf(buffer, "-x %d", slavePtr->x);
    Tcl_AppendResult(interp, buffer, (char *) NULL);
    sprintf(buffer, " -relx %.4g", slavePtr->relX);
    Tcl_AppendResult(interp, buffer, (char *) NULL);
    sprintf(buffer, " -y %d", slavePtr->y);
    Tcl_AppendResult(interp, buffer, (char *) NULL);
    sprintf(buffer, " -rely %.4g", slavePtr->relY);
    Tcl_AppendResult(interp, buffer, (char *) NULL);
    if (slavePtr->flags & CHILD_WIDTH) {
	sprintf(buffer, " -width %d", slavePtr->width);
	Tcl_AppendResult(interp, buffer, (char *) NULL);
    } else {
	Tcl_AppendResult(interp, " -width {}", (char *) NULL);
    }
    if (slavePtr->flags & CHILD_REL_WIDTH) {
	sprintf(buffer, " -relwidth %.4g", slavePtr->relWidth);
	Tcl_AppendResult(interp, buffer, (char *) NULL);
    } else {
	Tcl_AppendResult(interp, " -relwidth {}", (char *) NULL);
    }
    if (slavePtr->flags & CHILD_HEIGHT) {
	sprintf(buffer, " -height %d", slavePtr->height);
	Tcl_AppendResult(interp, buffer, (char *) NULL);
    } else {
	Tcl_AppendResult(interp, " -height {}", (char *) NULL);
    }
    if (slavePtr->flags & CHILD_REL_HEIGHT) {
	sprintf(buffer, " -relheight %.4g", slavePtr->relHeight);
	Tcl_AppendResult(interp, buffer, (char *) NULL);
    } else {
	Tcl_AppendResult(interp, " -relheight {}", (char *) NULL);
    }
    
    Tcl_AppendResult(interp, " -anchor ",
	    Tk_NameOfAnchor(slavePtr->anchor),
	    (char *) NULL);
    if (slavePtr->borderMode == BM_OUTSIDE) {
	Tcl_AppendResult(interp, " -bordermode outside",
		(char *) NULL);
    } else if (slavePtr->borderMode == BM_IGNORE) {
	Tcl_AppendResult(interp, " -bordermode ignore", (char *) NULL);
    }
    if ((slavePtr->masterPtr != NULL)
	    && (slavePtr->masterPtr->tkwin !=
		    Tk_Parent(slavePtr->tkwin))) {
	Tcl_AppendResult(interp, " -in ",
		Tk_PathName(slavePtr->masterPtr->tkwin),
		(char *) NULL);
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * RecomputePlacement --
 *
 *	This procedure is called as a when-idle handler.  It recomputes
 *	the geometries of all the slaves of a given master.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Windows may change size or shape.
 *
 *----------------------------------------------------------------------
 */

static void
RecomputePlacement(clientData)
    ClientData clientData;	/* Pointer to Master record. */
{
    register Master *masterPtr = (Master *) clientData;
    register Slave *slavePtr;
    int x, y, width, height, tmp;
    int masterWidth, masterHeight, masterX, masterY;
    double x1, y1, x2, y2;

    masterPtr->flags &= ~PARENT_RECONFIG_PENDING;

    /*
     * Iterate over all the slaves for the master.  Each slave's
     * geometry can be computed independently of the other slaves.
     */

    for (slavePtr = masterPtr->slavePtr; slavePtr != NULL;
	    slavePtr = slavePtr->nextPtr) {
	/*
	 * Step 1: compute size and borderwidth of master, taking into
	 * account desired border mode.
	 */

	masterX = masterY = 0;
	masterWidth = Tk_Width(masterPtr->tkwin);
	masterHeight = Tk_Height(masterPtr->tkwin);
	if (slavePtr->borderMode == BM_INSIDE) {
	    masterX = Tk_InternalBorderLeft(masterPtr->tkwin);
	    masterY = Tk_InternalBorderTop(masterPtr->tkwin);
            masterWidth -= masterX + Tk_InternalBorderRight(masterPtr->tkwin);
            masterHeight -= masterY +
		    Tk_InternalBorderBottom(masterPtr->tkwin);
	} else if (slavePtr->borderMode == BM_OUTSIDE) {
	    masterX = masterY = -Tk_Changes(masterPtr->tkwin)->border_width;
            masterWidth -= 2 * masterX;
            masterHeight -= 2 * masterY;
	}

	/*
	 * Step 2:  compute size of slave (outside dimensions including
	 * border) and location of anchor point within master.
	 */

	x1 = slavePtr->x + masterX + (slavePtr->relX*masterWidth);
	x = (int) (x1 + ((x1 > 0) ? 0.5 : -0.5));
	y1 = slavePtr->y + masterY + (slavePtr->relY*masterHeight);
	y = (int) (y1 + ((y1 > 0) ? 0.5 : -0.5));
	if (slavePtr->flags & (CHILD_WIDTH|CHILD_REL_WIDTH)) {
	    width = 0;
	    if (slavePtr->flags & CHILD_WIDTH) {
		width += slavePtr->width;
	    }
	    if (slavePtr->flags & CHILD_REL_WIDTH) {
		/*
		 * The code below is a bit tricky.  In order to round
		 * correctly when both relX and relWidth are specified,
		 * compute the location of the right edge and round that,
		 * then compute width.  If we compute the width and round
		 * it, rounding errors in relX and relWidth accumulate.
		 */

		x2 = x1 + (slavePtr->relWidth*masterWidth);
		tmp = (int) (x2 + ((x2 > 0) ? 0.5 : -0.5));
		width += tmp - x;
	    }
	} else {
	    width = Tk_ReqWidth(slavePtr->tkwin)
		    + 2*Tk_Changes(slavePtr->tkwin)->border_width;
	}
	if (slavePtr->flags & (CHILD_HEIGHT|CHILD_REL_HEIGHT)) {
	    height = 0;
	    if (slavePtr->flags & CHILD_HEIGHT) {
		height += slavePtr->height;
	    }
	    if (slavePtr->flags & CHILD_REL_HEIGHT) {
		/* 
		 * See note above for rounding errors in width computation.
		 */

		y2 = y1 + (slavePtr->relHeight*masterHeight);
		tmp = (int) (y2 + ((y2 > 0) ? 0.5 : -0.5));
		height += tmp - y;
	    }
	} else {
	    height = Tk_ReqHeight(slavePtr->tkwin)
		    + 2*Tk_Changes(slavePtr->tkwin)->border_width;
	}

	/*
	 * Step 3: adjust the x and y positions so that the desired
	 * anchor point on the slave appears at that position.  Also
	 * adjust for the border mode and master's border.
	 */

	switch (slavePtr->anchor) {
	    case TK_ANCHOR_N:
		x -= width/2;
		break;
	    case TK_ANCHOR_NE:
		x -= width;
		break;
	    case TK_ANCHOR_E:
		x -= width;
		y -= height/2;
		break;
	    case TK_ANCHOR_SE:
		x -= width;
		y -= height;
		break;
	    case TK_ANCHOR_S:
		x -= width/2;
		y -= height;
		break;
	    case TK_ANCHOR_SW:
		y -= height;
		break;
	    case TK_ANCHOR_W:
		y -= height/2;
		break;
	    case TK_ANCHOR_NW:
		break;
	    case TK_ANCHOR_CENTER:
		x -= width/2;
		y -= height/2;
		break;
	}

	/*
	 * Step 4: adjust width and height again to reflect inside dimensions
	 * of window rather than outside.  Also make sure that the width and
	 * height aren't zero.
	 */

	width -= 2*Tk_Changes(slavePtr->tkwin)->border_width;
	height -= 2*Tk_Changes(slavePtr->tkwin)->border_width;
	if (width <= 0) {
	    width = 1;
	}
	if (height <= 0) {
	    height = 1;
	}

	/*
	 * Step 5: reconfigure the window and map it if needed.  If the
	 * slave is a child of the master, we do this ourselves.  If the
	 * slave isn't a child of the master, let Tk_MaintainGeometry do
	 * the work (it will re-adjust things as relevant windows map,
	 * unmap, and move).
	 */

	if (masterPtr->tkwin == Tk_Parent(slavePtr->tkwin)) {
	    if ((x != Tk_X(slavePtr->tkwin))
		    || (y != Tk_Y(slavePtr->tkwin))
		    || (width != Tk_Width(slavePtr->tkwin))
		    || (height != Tk_Height(slavePtr->tkwin))) {
		Tk_MoveResizeWindow(slavePtr->tkwin, x, y, width, height);
	    }

	    /*
	     * Don't map the slave unless the master is mapped: the slave
	     * will get mapped later, when the master is mapped.
	     */

	    if (Tk_IsMapped(masterPtr->tkwin)) {
		Tk_MapWindow(slavePtr->tkwin);
	    }
	} else {
	    if ((width <= 0) || (height <= 0)) {
		Tk_UnmaintainGeometry(slavePtr->tkwin, masterPtr->tkwin);
		Tk_UnmapWindow(slavePtr->tkwin);
	    } else {
		Tk_MaintainGeometry(slavePtr->tkwin, masterPtr->tkwin,
			x, y, width, height);
	    }
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * MasterStructureProc --
 *
 *	This procedure is invoked by the Tk event handler when
 *	StructureNotify events occur for a master window.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Structures get cleaned up if the window was deleted.  If the
 *	window was resized then slave geometries get recomputed.
 *
 *----------------------------------------------------------------------
 */

static void
MasterStructureProc(clientData, eventPtr)
    ClientData clientData;	/* Pointer to Master structure for window
				 * referred to by eventPtr. */
    XEvent *eventPtr;		/* Describes what just happened. */
{
    register Master *masterPtr = (Master *) clientData;
    register Slave *slavePtr, *nextPtr;
    TkDisplay *dispPtr = ((TkWindow *) masterPtr->tkwin)->dispPtr;

    if (eventPtr->type == ConfigureNotify) {
	if ((masterPtr->slavePtr != NULL)
		&& !(masterPtr->flags & PARENT_RECONFIG_PENDING)) {
	    masterPtr->flags |= PARENT_RECONFIG_PENDING;
	    Tcl_DoWhenIdle(RecomputePlacement, (ClientData) masterPtr);
	}
    } else if (eventPtr->type == DestroyNotify) {
	for (slavePtr = masterPtr->slavePtr; slavePtr != NULL;
		slavePtr = nextPtr) {
	    slavePtr->masterPtr = NULL;
	    nextPtr = slavePtr->nextPtr;
	    slavePtr->nextPtr = NULL;
	}
	Tcl_DeleteHashEntry(Tcl_FindHashEntry(&dispPtr->masterTable,
		(char *) masterPtr->tkwin));
	if (masterPtr->flags & PARENT_RECONFIG_PENDING) {
	    Tcl_CancelIdleCall(RecomputePlacement, (ClientData) masterPtr);
	}
	masterPtr->tkwin = NULL;
	ckfree((char *) masterPtr);
    } else if (eventPtr->type == MapNotify) {
	/*
	 * When a master gets mapped, must redo the geometry computation
	 * so that all of its slaves get remapped.
	 */

	if ((masterPtr->slavePtr != NULL)
		&& !(masterPtr->flags & PARENT_RECONFIG_PENDING)) {
	    masterPtr->flags |= PARENT_RECONFIG_PENDING;
	    Tcl_DoWhenIdle(RecomputePlacement, (ClientData) masterPtr);
	}
    } else if (eventPtr->type == UnmapNotify) {
	/*
	 * Unmap all of the slaves when the master gets unmapped,
	 * so that they don't keep redisplaying themselves.
	 */

	for (slavePtr = masterPtr->slavePtr; slavePtr != NULL;
		slavePtr = slavePtr->nextPtr) {
	    Tk_UnmapWindow(slavePtr->tkwin);
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * SlaveStructureProc --
 *
 *	This procedure is invoked by the Tk event handler when
 *	StructureNotify events occur for a slave window.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Structures get cleaned up if the window was deleted.
 *
 *----------------------------------------------------------------------
 */

static void
SlaveStructureProc(clientData, eventPtr)
    ClientData clientData;	/* Pointer to Slave structure for window
				 * referred to by eventPtr. */
    XEvent *eventPtr;		/* Describes what just happened. */
{
    register Slave *slavePtr = (Slave *) clientData;
    TkDisplay * dispPtr = ((TkWindow *) slavePtr->tkwin)->dispPtr;

    if (eventPtr->type == DestroyNotify) {
	UnlinkSlave(slavePtr);
	Tcl_DeleteHashEntry(Tcl_FindHashEntry(&dispPtr->slaveTable,
		(char *) slavePtr->tkwin));
	ckfree((char *) slavePtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * PlaceRequestProc --
 *
 *	This procedure is invoked by Tk whenever a slave managed by us
 *	changes its requested geometry.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The window will get relayed out, if its requested size has
 *	anything to do with its actual size.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
static void
PlaceRequestProc(clientData, tkwin)
    ClientData clientData;		/* Pointer to our record for slave. */
    Tk_Window tkwin;			/* Window that changed its desired
					 * size. */
{
    Slave *slavePtr = (Slave *) clientData;
    Master *masterPtr;

    if (((slavePtr->flags & (CHILD_WIDTH|CHILD_REL_WIDTH)) != 0)
	    && ((slavePtr->flags & (CHILD_HEIGHT|CHILD_REL_HEIGHT)) != 0)) {
	return;
    }
    masterPtr = slavePtr->masterPtr;
    if (masterPtr == NULL) {
	return;
    }
    if (!(masterPtr->flags & PARENT_RECONFIG_PENDING)) {
	masterPtr->flags |= PARENT_RECONFIG_PENDING;
	Tcl_DoWhenIdle(RecomputePlacement, (ClientData) masterPtr);
    }
}

/*
 *--------------------------------------------------------------
 *
 * PlaceLostSlaveProc --
 *
 *	This procedure is invoked by Tk whenever some other geometry
 *	claims control over a slave that used to be managed by us.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Forgets all placer-related information about the slave.
 *
 *--------------------------------------------------------------
 */

	/* ARGSUSED */
static void
PlaceLostSlaveProc(clientData, tkwin)
    ClientData clientData;	/* Slave structure for slave window that
				 * was stolen away. */
    Tk_Window tkwin;		/* Tk's handle for the slave window. */
{
    register Slave *slavePtr = (Slave *) clientData;
    TkDisplay * dispPtr = ((TkWindow *) slavePtr->tkwin)->dispPtr;

    if (slavePtr->masterPtr->tkwin != Tk_Parent(slavePtr->tkwin)) {
	Tk_UnmaintainGeometry(slavePtr->tkwin, slavePtr->masterPtr->tkwin);
    }
    Tk_UnmapWindow(tkwin);
    UnlinkSlave(slavePtr);
    Tcl_DeleteHashEntry(Tcl_FindHashEntry(&dispPtr->slaveTable, 
            (char *) tkwin));
    Tk_DeleteEventHandler(tkwin, StructureNotifyMask, SlaveStructureProc,
	    (ClientData) slavePtr);
    ckfree((char *) slavePtr);
}
@


1.4
log
@touched all sources to ease next import
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tkPlace.c,v 1.7.6.2 2000/09/26 16:08:20 spolk Exp $
d19 1
d31 4
d44 1
a51 1

d59 3
a61 1
    float relX, relY;		/* X and Y coordinates relative to size of
d64 3
a66 1
    float relWidth, relHeight;	/* Dimensions for tkwin relative to size of
d68 2
d78 34
d169 5
a173 1
			    Slave *slavePtr, int argc, char **argv));
d175 1
d185 1
a185 1
 * Tk_PlaceCmd --
d201 2
a202 2
Tk_PlaceCmd(clientData, interp, argc, argv)
    ClientData clientData;	/* Main window associated with interpreter. */
d204 2
a205 2
    int argc;			/* Number of arguments. */
    char **argv;		/* Argument strings. */
d209 1
a209 3
    Tcl_HashEntry *hPtr;
    size_t length;
    int c;
d211 10
a220 4

    if (argc < 3) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
		argv[0], " option|pathName args", (char *) NULL);
d223 7
a229 2
    c = argv[1][0];
    length = strlen(argv[1]);
d235 3
a237 2
    if (c == '.') {
	tkwin = Tk_NameToWindow(interp, argv[1], (Tk_Window) clientData);
d253 1
a253 2
	slavePtr = FindSlave(tkwin);
	return ConfigureSlave(interp, slavePtr, argc-2, argv+2);
d261 2
a262 1
    tkwin = Tk_NameToWindow(interp, argv[2], (Tk_Window) clientData);
d278 4
a281 35
    if ((c == 'c') && (strncmp(argv[1], "configure", length) == 0)) {
	if (argc < 5) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0],
		    " configure pathName option value ?option value ...?\"",
		    (char *) NULL);
	    return TCL_ERROR;
	}
	slavePtr = FindSlave(tkwin);
	return ConfigureSlave(interp, slavePtr, argc-3, argv+3);
    } else if ((c == 'f') && (strncmp(argv[1], "forget", length) == 0)) {
	if (argc != 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " forget pathName\"", (char *) NULL);
	    return TCL_ERROR;
	}
	hPtr = Tcl_FindHashEntry(&dispPtr->slaveTable, (char *) tkwin);
	if (hPtr == NULL) {
	    return TCL_OK;
	}
	slavePtr = (Slave *) Tcl_GetHashValue(hPtr);
	if ((slavePtr->masterPtr != NULL) &&
		(slavePtr->masterPtr->tkwin != Tk_Parent(slavePtr->tkwin))) {
	    Tk_UnmaintainGeometry(slavePtr->tkwin,
		    slavePtr->masterPtr->tkwin);
	}
	UnlinkSlave(slavePtr);
	Tcl_DeleteHashEntry(hPtr);
	Tk_DeleteEventHandler(tkwin, StructureNotifyMask, SlaveStructureProc,
		(ClientData) slavePtr);
	Tk_ManageGeometry(tkwin, (Tk_GeomMgr *) NULL, (ClientData) NULL);
	Tk_UnmapWindow(tkwin);
	ckfree((char *) slavePtr);
    } else if ((c == 'i') && (strncmp(argv[1], "info", length) == 0)) {
	char buffer[32 + TCL_INTEGER_SPACE];
d283 21
a303 4
	if (argc != 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " info pathName\"", (char *) NULL);
	    return TCL_ERROR;
d305 33
a337 36
	hPtr = Tcl_FindHashEntry(&dispPtr->slaveTable, (char *) tkwin);
	if (hPtr == NULL) {
	    return TCL_OK;
	}
	slavePtr = (Slave *) Tcl_GetHashValue(hPtr);
	sprintf(buffer, "-x %d", slavePtr->x);
	Tcl_AppendResult(interp, buffer, (char *) NULL);
	sprintf(buffer, " -relx %.4g", slavePtr->relX);
	Tcl_AppendResult(interp, buffer, (char *) NULL);
	sprintf(buffer, " -y %d", slavePtr->y);
	Tcl_AppendResult(interp, buffer, (char *) NULL);
	sprintf(buffer, " -rely %.4g", slavePtr->relY);
	Tcl_AppendResult(interp, buffer, (char *) NULL);
	if (slavePtr->flags & CHILD_WIDTH) {
	    sprintf(buffer, " -width %d", slavePtr->width);
	    Tcl_AppendResult(interp, buffer, (char *) NULL);
	} else {
	    Tcl_AppendResult(interp, " -width {}", (char *) NULL);
	}
	if (slavePtr->flags & CHILD_REL_WIDTH) {
	    sprintf(buffer, " -relwidth %.4g", slavePtr->relWidth);
	    Tcl_AppendResult(interp, buffer, (char *) NULL);
	} else {
	    Tcl_AppendResult(interp, " -relwidth {}", (char *) NULL);
	}
	if (slavePtr->flags & CHILD_HEIGHT) {
	    sprintf(buffer, " -height %d", slavePtr->height);
	    Tcl_AppendResult(interp, buffer, (char *) NULL);
	} else {
	    Tcl_AppendResult(interp, " -height {}", (char *) NULL);
	}
	if (slavePtr->flags & CHILD_REL_HEIGHT) {
	    sprintf(buffer, " -relheight %.4g", slavePtr->relHeight);
	    Tcl_AppendResult(interp, buffer, (char *) NULL);
	} else {
	    Tcl_AppendResult(interp, " -relheight {}", (char *) NULL);
d340 1
a340 20
	Tcl_AppendResult(interp, " -anchor ", Tk_NameOfAnchor(slavePtr->anchor),
		(char *) NULL);
	if (slavePtr->borderMode == BM_OUTSIDE) {
	    Tcl_AppendResult(interp, " -bordermode outside", (char *) NULL);
	} else if (slavePtr->borderMode == BM_IGNORE) {
	    Tcl_AppendResult(interp, " -bordermode ignore", (char *) NULL);
	}
	if ((slavePtr->masterPtr != NULL)
		&& (slavePtr->masterPtr->tkwin != Tk_Parent(slavePtr->tkwin))) {
	    Tcl_AppendResult(interp, " -in ",
		    Tk_PathName(slavePtr->masterPtr->tkwin), (char *) NULL);
	}
    } else if ((c == 's') && (strncmp(argv[1], "slaves", length) == 0)) {
	if (argc != 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " slaves pathName\"", (char *) NULL);
	    return TCL_ERROR;
	}
	hPtr = Tcl_FindHashEntry(&dispPtr->masterTable, (char *) tkwin);
	if (hPtr != NULL) {
d342 14
a355 4
	    masterPtr = (Master *) Tcl_GetHashValue(hPtr);
	    for (slavePtr = masterPtr->slavePtr; slavePtr != NULL;
		    slavePtr = slavePtr->nextPtr) {
		Tcl_AppendElement(interp, Tk_PathName(slavePtr->tkwin));
d357 1
a358 5
    } else {
	Tcl_AppendResult(interp, "unknown or ambiguous option \"", argv[1],
		"\": must be configure, forget, info, or slaves",
		(char *) NULL);
	return TCL_ERROR;
d360 1
d367 1
a367 1
 * FindSlave --
d370 1
a370 1
 *	to that token (making a new one if necessary).
d373 1
a373 1
 *	None.
d382 1
a382 1
FindSlave(tkwin)
d393 5
a397 10
	slavePtr->tkwin = tkwin;
	slavePtr->masterPtr = NULL;
	slavePtr->nextPtr = NULL;
	slavePtr->x = slavePtr->y = 0;
	slavePtr->relX = slavePtr->relY = (float) 0.0;
	slavePtr->width = slavePtr->height = 0;
	slavePtr->relWidth = slavePtr->relHeight = (float) 0.0;
	slavePtr->anchor = TK_ANCHOR_NW;
	slavePtr->borderMode = BM_INSIDE;
	slavePtr->flags = 0;
d411 34
d490 1
a490 1
 * FindMaster --
d493 1
a493 1
 *	to that token (making a new one if necessary).
d496 1
a496 1
 *	None.
d505 1
a505 1
FindMaster(tkwin)
d516 3
a518 3
	masterPtr->tkwin = tkwin;
	masterPtr->slavePtr = NULL;
	masterPtr->flags = 0;
d531 35
d583 1
a583 1
ConfigureSlave(interp, slavePtr, argc, argv)
d585 4
a588 4
    Slave *slavePtr;		/* Pointer to current information
				 * about slave. */
    int argc;			/* Number of config arguments. */
    char **argv;		/* String values for arguments. */
d591 6
a596 6
    int c, result;
    size_t length;
    double d;

    result = TCL_OK;
    if (Tk_IsTopLevel(slavePtr->tkwin)) {
d598 1
a598 1
		Tk_PathName(slavePtr->tkwin), "\"; use wm command instead",
a601 48
    for ( ; argc > 0; argc -= 2, argv += 2) {
	if (argc < 2) {
	    Tcl_AppendResult(interp, "extra option \"", argv[0],
		    "\" (option with no value?)", (char *) NULL);
	    result = TCL_ERROR;
	    goto done;
	}
	length = strlen(argv[0]);
	c = argv[0][1];
	if ((c == 'a') && (strncmp(argv[0], "-anchor", length) == 0)) {
	    if (Tk_GetAnchor(interp, argv[1], &slavePtr->anchor) != TCL_OK) {
		result = TCL_ERROR;
		goto done;
	    }
	} else if ((c == 'b')
		&& (strncmp(argv[0], "-bordermode", length) == 0)) {
	    c = argv[1][0];
	    length = strlen(argv[1]);
	    if ((c == 'i') && (strncmp(argv[1], "ignore", length) == 0)
		    && (length >= 2)) {
		slavePtr->borderMode = BM_IGNORE;
	    } else if ((c == 'i') && (strncmp(argv[1], "inside", length) == 0)
		    && (length >= 2)) {
		slavePtr->borderMode = BM_INSIDE;
	    } else if ((c == 'o')
		    && (strncmp(argv[1], "outside", length) == 0)) {
		slavePtr->borderMode = BM_OUTSIDE;
	    } else {
		Tcl_AppendResult(interp, "bad border mode \"", argv[1],
			"\": must be ignore, inside, or outside",
			(char *) NULL);
		result = TCL_ERROR;
		goto done;
	    }
	} else if ((c == 'h') && (strncmp(argv[0], "-height", length) == 0)) {
	    if (argv[1][0] == 0) {
		slavePtr->flags &= ~CHILD_HEIGHT;
	    } else {
		if (Tk_GetPixels(interp, slavePtr->tkwin, argv[1],
			&slavePtr->height) != TCL_OK) {
		    result = TCL_ERROR;
		    goto done;
		}
		slavePtr->flags |= CHILD_HEIGHT;
	    }
	} else if ((c == 'i') && (strncmp(argv[0], "-in", length) == 0)) {
	    Tk_Window tkwin;
	    Tk_Window ancestor;
d603 8
a610 5
	    tkwin = Tk_NameToWindow(interp, argv[1], slavePtr->tkwin);
	    if (tkwin == NULL) {
		result = TCL_ERROR;
		goto done;
	    }
d612 16
a627 17
	    /*
	     * Make sure that the new master is either the logical parent
	     * of the slave or a descendant of that window, and that the
	     * master and slave aren't the same.
	     */

	    for (ancestor = tkwin; ; ancestor = Tk_Parent(ancestor)) {
		if (ancestor == Tk_Parent(slavePtr->tkwin)) {
		    break;
		}
		if (Tk_IsTopLevel(ancestor)) {
		    Tcl_AppendResult(interp, "can't place ",
			    Tk_PathName(slavePtr->tkwin), " relative to ",
			    Tk_PathName(tkwin), (char *) NULL);
		    result = TCL_ERROR;
		    goto done;
		}
d629 1
a629 1
	    if (slavePtr->tkwin == tkwin) {
d631 2
a632 2
			Tk_PathName(slavePtr->tkwin), " relative to itself",
			(char *) NULL);
d634 1
d637 5
a641 83
	    if ((slavePtr->masterPtr != NULL)
		    && (slavePtr->masterPtr->tkwin == tkwin)) {
		/*
		 * Re-using same old master.  Nothing to do.
		 */
	    } else {
		if ((slavePtr->masterPtr != NULL)
			&& (slavePtr->masterPtr->tkwin
			!= Tk_Parent(slavePtr->tkwin))) {
		    Tk_UnmaintainGeometry(slavePtr->tkwin,
			    slavePtr->masterPtr->tkwin);
		}
		UnlinkSlave(slavePtr);
		slavePtr->masterPtr = FindMaster(tkwin);
		slavePtr->nextPtr = slavePtr->masterPtr->slavePtr;
		slavePtr->masterPtr->slavePtr = slavePtr;
	    }
	} else if ((c == 'r') && (strncmp(argv[0], "-relheight", length) == 0)
		&& (length >= 5)) {
	    if (argv[1][0] == 0) {
		slavePtr->flags &= ~CHILD_REL_HEIGHT;
	    } else {
		if (Tcl_GetDouble(interp, argv[1], &d) != TCL_OK) {
		    result = TCL_ERROR;
		    goto done;
		}
		slavePtr->relHeight = (float) d;
		slavePtr->flags |= CHILD_REL_HEIGHT;
	    }
	} else if ((c == 'r') && (strncmp(argv[0], "-relwidth", length) == 0)
		&& (length >= 5)) {
	    if (argv[1][0] == 0) {
		slavePtr->flags &= ~CHILD_REL_WIDTH;
	    } else {
		if (Tcl_GetDouble(interp, argv[1], &d) != TCL_OK) {
		    result = TCL_ERROR;
		    goto done;
		}
		slavePtr->relWidth = (float) d;
		slavePtr->flags |= CHILD_REL_WIDTH;
	    }
	} else if ((c == 'r') && (strncmp(argv[0], "-relx", length) == 0)
		&& (length >= 5)) {
	    if (Tcl_GetDouble(interp, argv[1], &d) != TCL_OK) {
		result = TCL_ERROR;
		goto done;
	    }
	    slavePtr->relX = (float) d;
	} else if ((c == 'r') && (strncmp(argv[0], "-rely", length) == 0)
		&& (length >= 5)) {
	    if (Tcl_GetDouble(interp, argv[1], &d) != TCL_OK) {
		result = TCL_ERROR;
		goto done;
	    }
	    slavePtr->relY = (float) d;
	} else if ((c == 'w') && (strncmp(argv[0], "-width", length) == 0)) {
	    if (argv[1][0] == 0) {
		slavePtr->flags &= ~CHILD_WIDTH;
	    } else {
		if (Tk_GetPixels(interp, slavePtr->tkwin, argv[1],
			&slavePtr->width) != TCL_OK) {
		    result = TCL_ERROR;
		    goto done;
		}
		slavePtr->flags |= CHILD_WIDTH;
	    }
	} else if ((c == 'x') && (strncmp(argv[0], "-x", length) == 0)) {
	    if (Tk_GetPixels(interp, slavePtr->tkwin, argv[1],
		    &slavePtr->x) != TCL_OK) {
		result = TCL_ERROR;
		goto done;
	    }
	} else if ((c == 'y') && (strncmp(argv[0], "-y", length) == 0)) {
	    if (Tk_GetPixels(interp, slavePtr->tkwin, argv[1],
		    &slavePtr->y) != TCL_OK) {
		result = TCL_ERROR;
		goto done;
	    }
	} else {
	    Tcl_AppendResult(interp, "unknown or ambiguous option \"",
		    argv[0], "\": must be -anchor, -bordermode, -height, ",
		    "-in, -relheight, -relwidth, -relx, -rely, -width, ",
		    "-x, or -y", (char *) NULL);
d643 1
d646 38
d691 1
d695 1
a695 1
	masterPtr = FindMaster(Tk_Parent(slavePtr->tkwin));
d700 1
d711 82
d814 1
a814 1
    int masterWidth, masterHeight, masterBW;
d831 1
a831 1
	masterBW = 0;
d835 5
a839 1
	    masterBW = Tk_InternalBorderWidth(masterPtr->tkwin);
d841 3
a843 1
	    masterBW = -Tk_Changes(masterPtr->tkwin)->border_width;
a844 2
	masterWidth -= 2*masterBW;
	masterHeight -= 2*masterBW;
d851 1
a851 1
	x1 = slavePtr->x + masterBW + (slavePtr->relX*masterWidth);
d853 1
a853 1
	y1 = slavePtr->y + masterBW + (slavePtr->relY*masterHeight);
a1171 2


@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d8 1
a8 1
 * Copyright (c) 1994-1995 Sun Microsystems, Inc.
d13 1
a13 1
 * RCS: @@(#) $Id: tkPlace.c,v 1.8 1999/01/26 04:11:26 jingham Exp $
a101 9
 * The hash tables below both use Tk_Window tokens as keys.  They map
 * from Tk_Windows to Slave and Master structures for windows, if they
 * exist.
 */

static int initialized = 0;
static Tcl_HashTable masterTable;
static Tcl_HashTable slaveTable;
/*
d162 1
a162 10

    /*
     * Initialize, if that hasn't been done yet.
     */

    if (!initialized) {
	Tcl_InitHashTable(&masterTable, TCL_ONE_WORD_KEYS);
	Tcl_InitHashTable(&slaveTable, TCL_ONE_WORD_KEYS);
	initialized = 1;
    }
d181 12
d206 12
d234 1
a234 1
	hPtr = Tcl_FindHashEntry(&slaveTable, (char *) tkwin);
d252 1
a252 1
	char buffer[50];
d259 1
a259 1
	hPtr = Tcl_FindHashEntry(&slaveTable, (char *) tkwin);
d315 1
a315 1
	hPtr = Tcl_FindHashEntry(&masterTable, (char *) tkwin);
d357 1
d359 1
a359 1
    hPtr = Tcl_CreateHashEntry(&slaveTable, (char *) tkwin, &new);
d451 1
d453 1
a453 1
    hPtr = Tcl_CreateHashEntry(&masterTable, (char *) tkwin, &new);
d478 1
a478 1
 *	left in interp->result.
d854 1
a854 1
	 * slave isn't a child of the master, let Tk_MaintainWindow do
d913 1
d928 1
a928 1
	Tcl_DeleteHashEntry(Tcl_FindHashEntry(&masterTable,
d983 1
d987 1
a987 1
	Tcl_DeleteHashEntry(Tcl_FindHashEntry(&slaveTable,
d1060 1
d1067 2
a1068 1
    Tcl_DeleteHashEntry(Tcl_FindHashEntry(&slaveTable, (char *) tkwin));
d1073 2
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d8 1
a8 1
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
d13 1
a13 1
 * RCS: @@(#) $Id: tkPlace.c,v 1.7.6.2 2000/09/26 16:08:20 spolk Exp $
d102 9
d171 10
a180 1
    TkDisplay *dispPtr;
a198 12

	/*
	 * Initialize, if that hasn't been done yet.
	 */

	dispPtr = ((TkWindow *) tkwin)->dispPtr;
	if (!dispPtr->placeInit) {
	    Tcl_InitHashTable(&dispPtr->masterTable, TCL_ONE_WORD_KEYS);
	    Tcl_InitHashTable(&dispPtr->slaveTable, TCL_ONE_WORD_KEYS);
	    dispPtr->placeInit = 1;
	}

a211 12

    /*
     * Initialize, if that hasn't been done yet.
     */

    dispPtr = ((TkWindow *) tkwin)->dispPtr;
    if (!dispPtr->placeInit) {
	Tcl_InitHashTable(&dispPtr->masterTable, TCL_ONE_WORD_KEYS);
	Tcl_InitHashTable(&dispPtr->slaveTable, TCL_ONE_WORD_KEYS);
	dispPtr->placeInit = 1;
    }

d228 1
a228 1
	hPtr = Tcl_FindHashEntry(&dispPtr->slaveTable, (char *) tkwin);
d246 1
a246 1
	char buffer[32 + TCL_INTEGER_SPACE];
d253 1
a253 1
	hPtr = Tcl_FindHashEntry(&dispPtr->slaveTable, (char *) tkwin);
d309 1
a309 1
	hPtr = Tcl_FindHashEntry(&dispPtr->masterTable, (char *) tkwin);
a350 1
    TkDisplay * dispPtr = ((TkWindow *) tkwin)->dispPtr;
d352 1
a352 1
    hPtr = Tcl_CreateHashEntry(&dispPtr->slaveTable, (char *) tkwin, &new);
a443 1
    TkDisplay * dispPtr = ((TkWindow *) tkwin)->dispPtr;
d445 1
a445 1
    hPtr = Tcl_CreateHashEntry(&dispPtr->masterTable, (char *) tkwin, &new);
d470 1
a470 1
 *	left in the interp's result.
d846 1
a846 1
	 * slave isn't a child of the master, let Tk_MaintainGeometry do
a904 1
    TkDisplay *dispPtr = ((TkWindow *) masterPtr->tkwin)->dispPtr;
d919 1
a919 1
	Tcl_DeleteHashEntry(Tcl_FindHashEntry(&dispPtr->masterTable,
a973 1
    TkDisplay * dispPtr = ((TkWindow *) slavePtr->tkwin)->dispPtr;
d977 1
a977 1
	Tcl_DeleteHashEntry(Tcl_FindHashEntry(&dispPtr->slaveTable,
a1049 1
    TkDisplay * dispPtr = ((TkWindow *) slavePtr->tkwin)->dispPtr;
d1056 1
a1056 2
    Tcl_DeleteHashEntry(Tcl_FindHashEntry(&dispPtr->slaveTable, 
            (char *) tkwin));
a1060 2


@


1.1.1.3
log
@import tk 8.4.0
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tkPlace.c,v 1.12 2002/06/14 22:25:12 jenglish Exp $
a18 1

a29 4
static char *borderModeStrings[] = {
    "inside", "outside", "ignore", (char *) NULL
};

a38 1
    Tk_Window inTkwin;		/* Token for the -in window. */
d46 1
d54 1
a54 3
    Tcl_Obj *xPtr, *yPtr;	/* Tcl_Obj rep's of x, y coords, to keep
				 * pixel spec. information */
    double relX, relY;		/* X and Y coordinates relative to size of
d57 1
a57 3
    Tcl_Obj *widthPtr;		/* Tcl_Obj rep of width, to keep pixel spec */
    Tcl_Obj *heightPtr;		/* Tcl_Obj rep of height, to keep pixel spec */
    double relWidth, relHeight;	/* Dimensions for tkwin relative to size of
a58 2
    Tcl_Obj *relWidthPtr;
    Tcl_Obj *relHeightPtr;
a66 34
 * Type masks for options:
 */
#define IN_MASK		1

static Tk_OptionSpec optionSpecs[] = {
    {TK_OPTION_ANCHOR, "-anchor", NULL, NULL, "nw", -1,
	 Tk_Offset(Slave, anchor), 0, 0, 0},
    {TK_OPTION_STRING_TABLE, "-bordermode", NULL, NULL, "inside", -1,
	 Tk_Offset(Slave, borderMode), 0, (ClientData) borderModeStrings, 0},
    {TK_OPTION_PIXELS, "-height", NULL, NULL, "", Tk_Offset(Slave, heightPtr),
	 Tk_Offset(Slave, height), TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_WINDOW, "-in", NULL, NULL, "", -1, Tk_Offset(Slave, inTkwin),
	 0, 0, IN_MASK},
    {TK_OPTION_DOUBLE, "-relheight", NULL, NULL, "",
	 Tk_Offset(Slave, relHeightPtr), Tk_Offset(Slave, relHeight),
	 TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_DOUBLE, "-relwidth", NULL, NULL, "",
	 Tk_Offset(Slave, relWidthPtr), Tk_Offset(Slave, relWidth),
	 TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_DOUBLE, "-relx", NULL, NULL, "0", -1,
	 Tk_Offset(Slave, relX), 0, 0, 0},
    {TK_OPTION_DOUBLE, "-rely", NULL, NULL, "0", -1,
	 Tk_Offset(Slave, relY), 0, 0, 0},
    {TK_OPTION_PIXELS, "-width", NULL, NULL, "", Tk_Offset(Slave, widthPtr),
	 Tk_Offset(Slave, width), TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_PIXELS, "-x", NULL, NULL, "0", Tk_Offset(Slave, xPtr),
	 Tk_Offset(Slave, x), TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_PIXELS, "-y", NULL, NULL, "0", Tk_Offset(Slave, yPtr),
	 Tk_Offset(Slave, y), TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_END, (char *) NULL, (char *) NULL, (char *) NULL,
	 (char *) NULL, 0, -1, 0, 0, 0}
};
	
/*
d124 1
a124 5
			    Tk_Window tkwin, Tk_OptionTable table,
			    int objc, Tcl_Obj *CONST objv[]));
static int		PlaceInfoCommand _ANSI_ARGS_((Tcl_Interp *interp,
			    Tk_Window tkwin));
static Slave *		CreateSlave _ANSI_ARGS_((Tk_Window tkwin));
a125 1
static Master *		CreateMaster _ANSI_ARGS_((Tk_Window tkwin));
d135 1
a135 1
 * Tk_PlaceObjCmd --
d151 2
a152 2
Tk_PlaceObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* NULL. */
d154 2
a155 2
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
d159 3
a161 1
    char *string;
d163 4
a166 10
    Tk_OptionTable optionTable;
    static CONST char *optionStrings[] = {
	"configure", "forget", "info", "slaves", (char *) NULL
    };
    enum options { PLACE_CONFIGURE, PLACE_FORGET, PLACE_INFO, PLACE_SLAVES };
    int index;
    
    
    if (objc < 3) {
	Tcl_WrongNumArgs(interp, 1, objv, "option|pathName args");
d169 2
a170 7

    /*
     * Create the option table for this widget class.  If it has already
     * been created, the cached pointer will be returned.
     */

    optionTable = Tk_CreateOptionTable(interp, optionSpecs);
d176 2
a177 3
    string = Tcl_GetString(objv[1]);
    if (string[0] == '.') {
	tkwin = Tk_NameToWindow(interp, string,	Tk_MainWindow(interp));
d193 2
a194 1
	return ConfigureSlave(interp, tkwin, optionTable, objc-2, objv+2);
d202 1
a202 2
    tkwin = Tk_NameToWindow(interp, Tcl_GetString(objv[2]),
	    Tk_MainWindow(interp));
d218 35
a252 4
    if (Tcl_GetIndexFromObj(interp, objv[1], optionStrings, "option", 0,
	    &index) != TCL_OK) {
	return TCL_ERROR;
    }
d254 35
a288 21
    switch ((enum options) index) {
	case PLACE_CONFIGURE: {
	    Tcl_Obj *objPtr;
	    if (objc == 3 || objc == 4) {
		slavePtr = FindSlave(tkwin);
		if (slavePtr == NULL) {
		    return TCL_OK;
		}
		objPtr = Tk_GetOptionInfo(interp, (char *) slavePtr,
			optionTable,
			(objc == 4) ? objv[3] : (Tcl_Obj *) NULL, tkwin);
		if (objPtr == NULL) {
		    return TCL_ERROR;
		} else {
		    Tcl_SetObjResult(interp, objPtr);
		    return TCL_OK;
		}
	    } else {
		return ConfigureSlave(interp, tkwin, optionTable, objc-3,
			objv+3);
	    }
d290 5
a294 33
	
	case PLACE_FORGET: {
	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "pathName");
		return TCL_ERROR;
	    }
	    slavePtr = FindSlave(tkwin);
	    if (slavePtr == NULL) {
		return TCL_OK;
	    }
	    if ((slavePtr->masterPtr != NULL) &&
		    (slavePtr->masterPtr->tkwin !=
			    Tk_Parent(slavePtr->tkwin))) {
		Tk_UnmaintainGeometry(slavePtr->tkwin,
			slavePtr->masterPtr->tkwin);
	    }
	    UnlinkSlave(slavePtr);
	    Tcl_DeleteHashEntry(Tcl_FindHashEntry(&dispPtr->slaveTable,
		    (char *) tkwin));
	    Tk_DeleteEventHandler(tkwin, StructureNotifyMask,
		    SlaveStructureProc,	(ClientData) slavePtr);
	    Tk_ManageGeometry(tkwin, (Tk_GeomMgr *) NULL, (ClientData) NULL);
	    Tk_UnmapWindow(tkwin);
	    ckfree((char *) slavePtr);
	    break;
	}
	
	case PLACE_INFO: {
	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "pathName");
		return TCL_ERROR;
	    }
	    return PlaceInfoCommand(interp, tkwin);
d297 20
a316 1
	case PLACE_SLAVES: {
d318 4
a321 14
	    Tcl_Obj *listPtr;
	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "pathName");
		return TCL_ERROR;
	    }
	    masterPtr = FindMaster(tkwin);
	    if (masterPtr != NULL) {
		listPtr = Tcl_NewObj();
		for (slavePtr = masterPtr->slavePtr; slavePtr != NULL;
		     slavePtr = slavePtr->nextPtr) {
		    Tcl_ListObjAppendElement(interp, listPtr,
			    Tcl_NewStringObj(Tk_PathName(slavePtr->tkwin),-1));
		}
		Tcl_SetObjResult(interp, listPtr);
a322 1
	    break;
d324 5
a329 1

d336 1
a336 1
 * CreateSlave --
d339 1
a339 1
 *	to that token, creating a new one if necessary.
d342 1
a342 1
 *	Pointer to the Slave structure.
d351 1
a351 1
CreateSlave(tkwin)
d362 10
a371 5
	memset(slavePtr, 0, sizeof(Slave));
	slavePtr->tkwin		= tkwin;
	slavePtr->inTkwin	= None;
	slavePtr->anchor	= TK_ANCHOR_NW;
	slavePtr->borderMode	= BM_INSIDE;
a384 34
 * FindSlave --
 *
 *	Given a Tk_Window token, find the Slave structure corresponding
 *	to that token.  This is purely a lookup function; it will not
 *	create a record if one does not yet exist.
 *
 * Results:
 *	Pointer to Slave structure; NULL if none exists.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static Slave *
FindSlave(tkwin)
    Tk_Window tkwin;		/* Token for desired slave. */
{
    Tcl_HashEntry *hPtr;
    register Slave *slavePtr;
    TkDisplay * dispPtr = ((TkWindow *) tkwin)->dispPtr;

    hPtr = Tcl_FindHashEntry(&dispPtr->slaveTable, (char *) tkwin);
    if (hPtr == NULL) {
	return NULL;
    }
    slavePtr = (Slave *) Tcl_GetHashValue(hPtr);
    return slavePtr;
}

/*
 *----------------------------------------------------------------------
 *
d430 1
a430 1
 * CreateMaster --
d433 1
a433 1
 *	to that token, creating a new one if necessary.
d436 1
a436 1
 *	Pointer to the Master structure.
d445 1
a445 1
CreateMaster(tkwin)
d456 3
a458 3
	masterPtr->tkwin	= tkwin;
	masterPtr->slavePtr	= NULL;
	masterPtr->flags	= 0;
a470 35
 * FindMaster --
 *
 *	Given a Tk_Window token, find the Master structure corresponding
 *	to that token.  This is simply a lookup procedure; a new record
 *	will not be created if one does not already exist.
 *
 * Results:
 *	Pointer to the Master structure; NULL if one does not exist for
 *	the given Tk_Window token.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static Master *
FindMaster(tkwin)
    Tk_Window tkwin;		/* Token for desired master. */
{
    Tcl_HashEntry *hPtr;
    register Master *masterPtr;
    TkDisplay * dispPtr = ((TkWindow *) tkwin)->dispPtr;

    hPtr = Tcl_FindHashEntry(&dispPtr->masterTable, (char *) tkwin);
    if (hPtr == NULL) {
	return NULL;
    }
    masterPtr = (Master *) Tcl_GetHashValue(hPtr);
    return masterPtr;
}

/*
 *----------------------------------------------------------------------
 *
d488 1
a488 1
ConfigureSlave(interp, tkwin, table, objc, objv)
d490 4
a493 4
    Tk_Window tkwin;		/* Token for the window to manipulate. */
    Tk_OptionTable table;	/* Token for option table. */
    int objc;			/* Number of config arguments. */
    Tcl_Obj *CONST objv[];	/* Object values for arguments. */
d496 6
a501 6
    Tk_SavedOptions savedOptions;
    int mask;
    int result = TCL_OK;
    Slave *slavePtr;
    
    if (Tk_TopWinHierarchy(tkwin)) {
d503 1
a503 1
		Tk_PathName(tkwin), "\"; use wm command instead",
d507 54
d562 5
a566 8
    slavePtr = CreateSlave(tkwin);
    
    if (Tk_SetOptions(interp, (char *)slavePtr, table, objc, objv,
	    slavePtr->tkwin, &savedOptions, &mask) != TCL_OK) {
	Tk_RestoreSavedOptions(&savedOptions);
	result = TCL_ERROR;
	goto done;
    }
d568 11
a578 16
    if (mask & IN_MASK) {
	/* -in changed */
	Tk_Window tkwin;
	Tk_Window ancestor;
	
	tkwin = slavePtr->inTkwin;
	
	/*
	 * Make sure that the new master is either the logical parent
	 * of the slave or a descendant of that window, and that the
	 * master and slave aren't the same.
	 */
	
	for (ancestor = tkwin; ; ancestor = Tk_Parent(ancestor)) {
	    if (ancestor == Tk_Parent(slavePtr->tkwin)) {
		break;
d580 1
a580 1
	    if (Tk_TopWinHierarchy(ancestor)) {
d582 80
a661 2
			Tk_PathName(slavePtr->tkwin), " relative to ",
			Tk_PathName(tkwin), (char *) NULL);
a662 1
		Tk_RestoreSavedOptions(&savedOptions);
d665 5
a669 5
	}
	if (slavePtr->tkwin == tkwin) {
	    Tcl_AppendResult(interp, "can't place ",
		    Tk_PathName(slavePtr->tkwin), " relative to itself",
		    (char *) NULL);
a670 1
	    Tk_RestoreSavedOptions(&savedOptions);
a672 38
	if ((slavePtr->masterPtr != NULL)
		&& (slavePtr->masterPtr->tkwin == tkwin)) {
	    /*
	     * Re-using same old master.  Nothing to do.
	     */
	} else {
	    if ((slavePtr->masterPtr != NULL)
		    && (slavePtr->masterPtr->tkwin
			    != Tk_Parent(slavePtr->tkwin))) {
		Tk_UnmaintainGeometry(slavePtr->tkwin,
			slavePtr->masterPtr->tkwin);
	    }
	    UnlinkSlave(slavePtr);
	    slavePtr->masterPtr = CreateMaster(tkwin);
	    slavePtr->nextPtr = slavePtr->masterPtr->slavePtr;
	    slavePtr->masterPtr->slavePtr = slavePtr;
	}
    }

    /*
     * Set slave flags.  First clear the field, then add bits as needed.
     */

    slavePtr->flags = 0;
    if (slavePtr->heightPtr) {
	slavePtr->flags |= CHILD_HEIGHT;
    }

    if (slavePtr->relHeightPtr) {
	slavePtr->flags |= CHILD_REL_HEIGHT;
    }

    if (slavePtr->relWidthPtr) {
	slavePtr->flags |= CHILD_REL_WIDTH;
    }

    if (slavePtr->widthPtr) {
	slavePtr->flags |= CHILD_WIDTH;
a679 1
    Tk_FreeSavedOptions(&savedOptions);
d683 1
a683 1
	masterPtr = CreateMaster(Tk_Parent(slavePtr->tkwin));
a687 1
    slavePtr->inTkwin = masterPtr->tkwin;
a697 82
 * PlaceInfoCommand --
 *
 *	Implementation of the [place info] subcommand.  See the user
 *	documentation for information on what it does.
 *
 * Results:
 *	Standard Tcl result.
 *
 * Side effects:
 *	If the given tkwin is managed by the placer, this function will
 *	put information about that placement in the interp's result.
 *
 *----------------------------------------------------------------------
 */

static int
PlaceInfoCommand(interp, tkwin)
    Tcl_Interp *interp;		/* Interp into which to place result. */
    Tk_Window tkwin;		/* Token for the window to get info on. */
{
    char buffer[32 + TCL_INTEGER_SPACE];
    Slave *slavePtr;
    
    slavePtr = FindSlave(tkwin);
    if (slavePtr == NULL) {
	return TCL_OK;
    }
    sprintf(buffer, "-x %d", slavePtr->x);
    Tcl_AppendResult(interp, buffer, (char *) NULL);
    sprintf(buffer, " -relx %.4g", slavePtr->relX);
    Tcl_AppendResult(interp, buffer, (char *) NULL);
    sprintf(buffer, " -y %d", slavePtr->y);
    Tcl_AppendResult(interp, buffer, (char *) NULL);
    sprintf(buffer, " -rely %.4g", slavePtr->relY);
    Tcl_AppendResult(interp, buffer, (char *) NULL);
    if (slavePtr->flags & CHILD_WIDTH) {
	sprintf(buffer, " -width %d", slavePtr->width);
	Tcl_AppendResult(interp, buffer, (char *) NULL);
    } else {
	Tcl_AppendResult(interp, " -width {}", (char *) NULL);
    }
    if (slavePtr->flags & CHILD_REL_WIDTH) {
	sprintf(buffer, " -relwidth %.4g", slavePtr->relWidth);
	Tcl_AppendResult(interp, buffer, (char *) NULL);
    } else {
	Tcl_AppendResult(interp, " -relwidth {}", (char *) NULL);
    }
    if (slavePtr->flags & CHILD_HEIGHT) {
	sprintf(buffer, " -height %d", slavePtr->height);
	Tcl_AppendResult(interp, buffer, (char *) NULL);
    } else {
	Tcl_AppendResult(interp, " -height {}", (char *) NULL);
    }
    if (slavePtr->flags & CHILD_REL_HEIGHT) {
	sprintf(buffer, " -relheight %.4g", slavePtr->relHeight);
	Tcl_AppendResult(interp, buffer, (char *) NULL);
    } else {
	Tcl_AppendResult(interp, " -relheight {}", (char *) NULL);
    }
    
    Tcl_AppendResult(interp, " -anchor ",
	    Tk_NameOfAnchor(slavePtr->anchor),
	    (char *) NULL);
    if (slavePtr->borderMode == BM_OUTSIDE) {
	Tcl_AppendResult(interp, " -bordermode outside",
		(char *) NULL);
    } else if (slavePtr->borderMode == BM_IGNORE) {
	Tcl_AppendResult(interp, " -bordermode ignore", (char *) NULL);
    }
    if ((slavePtr->masterPtr != NULL)
	    && (slavePtr->masterPtr->tkwin !=
		    Tk_Parent(slavePtr->tkwin))) {
	Tcl_AppendResult(interp, " -in ",
		Tk_PathName(slavePtr->masterPtr->tkwin),
		(char *) NULL);
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
d719 1
a719 1
    int masterWidth, masterHeight, masterX, masterY;
d736 1
a736 1
	masterX = masterY = 0;
d740 1
a740 5
	    masterX = Tk_InternalBorderLeft(masterPtr->tkwin);
	    masterY = Tk_InternalBorderTop(masterPtr->tkwin);
            masterWidth -= masterX + Tk_InternalBorderRight(masterPtr->tkwin);
            masterHeight -= masterY +
		    Tk_InternalBorderBottom(masterPtr->tkwin);
d742 1
a742 3
	    masterX = masterY = -Tk_Changes(masterPtr->tkwin)->border_width;
            masterWidth -= 2 * masterX;
            masterHeight -= 2 * masterY;
d744 2
d752 1
a752 1
	x1 = slavePtr->x + masterX + (slavePtr->relX*masterWidth);
d754 1
a754 1
	y1 = slavePtr->y + masterY + (slavePtr->relY*masterHeight);
d1073 2
@


