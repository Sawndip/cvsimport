head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.20.24.44;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.13;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.25;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.51;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.32;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.13;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@/*
 * tkImgGIF.c --
 *
 *	A photo image file handler for GIF files. Reads 87a and 89a GIF
 *	files. At present, there only is a file write function. GIF images
 *	may be read using the -data option of the photo image.  The data may be
 *	given as a binary string in a Tcl_Obj or by representing
 *	the data as BASE64 encoded ascii.  Derived from the giftoppm code
 *	found in the pbmplus package and tkImgFmtPPM.c in the tk4.0b2
 *	distribution.
 *
 * Copyright (c) Reed Wade (wade@@cs.utk.edu), University of Tennessee
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
 * Copyright (c) 1997 Australian National University
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * This file also contains code from the giftoppm program, which is
 * copyrighted as follows:
 *
 * +--------------------------------------------------------------------+
 * | Copyright 1990, David Koblas.					|
 * |   Permission to use, copy, modify, and distribute this software	|
 * |   and its documentation for any purpose and without fee is hereby	|
 * |   granted, provided that the above copyright notice appear in all	|
 * |   copies and that both that copyright notice and this permission	|
 * |   notice appear in supporting documentation.  This software is	|
 * |   provided "as is" without express or implied warranty.		|
 * +-------------------------------------------------------------------+
 *
 * RCS: @@(#) $Id: tkImgGIF.c,v 1.22 2002/08/08 09:35:08 hobbs Exp $
 */

/*
 * GIF's are represented as data in base64 format.
 * base64 strings consist of 4 6-bit characters -> 3 8 bit bytes.
 * A-Z, a-z, 0-9, + and / represent the 64 values (in order).
 * '=' is a trailing padding char when the un-encoded data is not a
 * multiple of 3 bytes.  We'll ignore white space when encountered.
 * Any other invalid character is treated as an EOF
 */

#define GIF_SPECIAL	(256)
#define GIF_PAD		(GIF_SPECIAL+1)
#define GIF_SPACE	(GIF_SPECIAL+2)
#define GIF_BAD		(GIF_SPECIAL+3)
#define GIF_DONE	(GIF_SPECIAL+4)

/*
 * structure to "mimic" FILE for Mread, so we can look like fread.
 * The decoder state keeps track of which byte we are about to read,
 * or EOF.
 */

typedef struct mFile {
    unsigned char *data;	/* mmencoded source string */
    int c;			/* bits left over from previous character */
    int state;			/* decoder state (0-4 or GIF_DONE) */
} MFile;

#include "tkInt.h"
#include "tkPort.h"

/*
 * Non-ASCII encoding support:
 * Most data in a GIF image is binary and is treated as such.  However,
 * a few key bits are stashed in ASCII.  If we try to compare those pieces
 * to the char they represent, it will fail on any non-ASCII (eg, EBCDIC)
 * system.  To accomodate these systems, we test against the numeric value
 * of the ASCII characters instead of the characters themselves.  This is
 * encoding independant.
 */

static CONST char GIF87a[] = {			/* ASCII GIF87a */
    0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x00
};
static CONST char GIF89a[] = {			/* ASCII GIF89a */
    0x47, 0x49, 0x46, 0x38, 0x39, 0x61, 0x00
};
#  define GIF_TERMINATOR 0x3b			/* ASCII ; */
#  define GIF_EXTENSION  0x21			/* ASCII ! */
#  define GIF_START	 0x2c			/* ASCII , */

/*
 * 			 HACK ALERT!!  HACK ALERT!!  HACK ALERT!!
 * This code is hard-wired for reading from files.  In order to read
 * from a data stream, we'll trick fread so we can reuse the same code.
 * 0==from file; 1==from base64 encoded data; 2==from binary data
 */

typedef struct ThreadSpecificData {
    int fromData;
} ThreadSpecificData;
static Tcl_ThreadDataKey dataKey;

/*
 * The format record for the GIF file format:
 */

static int	FileMatchGIF _ANSI_ARGS_((Tcl_Channel chan, CONST char *fileName,
		    Tcl_Obj *format, int *widthPtr, int *heightPtr,
		    Tcl_Interp *interp));
static int	FileReadGIF  _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Channel chan, CONST char *fileName, Tcl_Obj *format,
		    Tk_PhotoHandle imageHandle, int destX, int destY,
		    int width, int height, int srcX, int srcY));
static int	StringMatchGIF _ANSI_ARGS_(( Tcl_Obj *dataObj,
		    Tcl_Obj *format, int *widthPtr, int *heightPtr,
		    Tcl_Interp *interp));
static int	StringReadGIF _ANSI_ARGS_((Tcl_Interp *interp, Tcl_Obj *dataObj,
		    Tcl_Obj *format, Tk_PhotoHandle imageHandle,
		    int destX, int destY, int width, int height,
		    int srcX, int srcY));
static int 	FileWriteGIF _ANSI_ARGS_((Tcl_Interp *interp,  
		    CONST char *filename, Tcl_Obj *format,
		    Tk_PhotoImageBlock *blockPtr));
static int	CommonWriteGIF _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Channel handle, Tcl_Obj *format,
		    Tk_PhotoImageBlock *blockPtr));

Tk_PhotoImageFormat tkImgFmtGIF = {
    "gif",		/* name */
    FileMatchGIF,	/* fileMatchProc */
    StringMatchGIF,	/* stringMatchProc */
    FileReadGIF,	/* fileReadProc */
    StringReadGIF,	/* stringReadProc */
    FileWriteGIF,	/* fileWriteProc */
    NULL,		/* stringWriteProc */
};

#define INTERLACE		0x40
#define LOCALCOLORMAP		0x80
#define BitSet(byte, bit)	(((byte) & (bit)) == (bit))
#define MAXCOLORMAPSIZE		256
#define CM_RED			0
#define CM_GREEN		1
#define CM_BLUE			2
#define CM_ALPHA		3
#define MAX_LWZ_BITS		12
#define LM_to_uint(a,b)		(((b)<<8)|(a))
#define ReadOK(file,buffer,len)	(Fread(buffer, len, 1, file) != 0)

/*
 * Prototypes for local procedures defined in this file:
 */

static int		DoExtension _ANSI_ARGS_((Tcl_Channel chan, int label,
			    int *transparent));
static int		GetCode _ANSI_ARGS_((Tcl_Channel chan, int code_size,
			    int flag));
static int		GetDataBlock _ANSI_ARGS_((Tcl_Channel chan,
			    unsigned char *buf));
static int		ReadColorMap _ANSI_ARGS_((Tcl_Channel chan, int number,
			    unsigned char buffer[MAXCOLORMAPSIZE][4]));
static int		ReadGIFHeader _ANSI_ARGS_((Tcl_Channel chan,
			    int *widthPtr, int *heightPtr));
static int		ReadImage _ANSI_ARGS_((Tcl_Interp *interp,
			    char *imagePtr, Tcl_Channel chan,
			    int len, int rows,
			    unsigned char cmap[MAXCOLORMAPSIZE][4],
			    int width, int height, int srcX, int srcY,
			    int interlace, int transparent));

/*
 * these are for the BASE64 image reader code only
 */

static int		Fread _ANSI_ARGS_((unsigned char *dst, size_t size,
			    size_t count, Tcl_Channel chan));
static int		Mread _ANSI_ARGS_((unsigned char *dst, size_t size,
			    size_t count, MFile *handle));
static int		Mgetc _ANSI_ARGS_((MFile *handle));
static int		char64 _ANSI_ARGS_((int c));
static void		mInit _ANSI_ARGS_((unsigned char *string,
			    MFile *handle));


/*
 *----------------------------------------------------------------------
 *
 * FileMatchGIF --
 *
 *	This procedure is invoked by the photo image type to see if
 *	a file contains image data in GIF format.
 *
 * Results:
 *	The return value is 1 if the first characters in file f look
 *	like GIF data, and 0 otherwise.
 *
 * Side effects:
 *	The access position in f may change.
 *
 *----------------------------------------------------------------------
 */

static int
FileMatchGIF(chan, fileName, format, widthPtr, heightPtr, interp)
    Tcl_Channel chan;		/* The image file, open for reading. */
    CONST char *fileName;	/* The name of the image file. */
    Tcl_Obj *format;		/* User-specified format object, or NULL. */
    int *widthPtr, *heightPtr;	/* The dimensions of the image are
				 * returned here if the file is a valid
				 * raw GIF file. */
    Tcl_Interp *interp;		/* not used */
{
	return ReadGIFHeader(chan, widthPtr, heightPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * FileReadGIF --
 *
 *	This procedure is called by the photo image type to read
 *	GIF format data from a file and write it into a given
 *	photo image.
 *
 * Results:
 *	A standard TCL completion code.  If TCL_ERROR is returned
 *	then an error message is left in the interp's result.
 *
 * Side effects:
 *	The access position in file f is changed, and new data is
 *	added to the image given by imageHandle.
 *
 *----------------------------------------------------------------------
 */

static int
FileReadGIF(interp, chan, fileName, format, imageHandle, destX, destY,
	width, height, srcX, srcY)
    Tcl_Interp *interp;		/* Interpreter to use for reporting errors. */
    Tcl_Channel chan;		/* The image file, open for reading. */
    CONST char *fileName;	/* The name of the image file. */
    Tcl_Obj *format;		/* User-specified format object, or NULL. */
    Tk_PhotoHandle imageHandle;	/* The photo image to write into. */
    int destX, destY;		/* Coordinates of top-left pixel in
				 * photo image to be written to. */
    int width, height;		/* Dimensions of block of photo image to
				 * be written to. */
    int srcX, srcY;		/* Coordinates of top-left pixel to be used
				 * in image being read. */
{
    int fileWidth, fileHeight;
    int nBytes, index = 0, argc = 0, i;
    Tcl_Obj **objv;
    Tk_PhotoImageBlock block;
    unsigned char buf[100];
    unsigned char *trashBuffer = NULL;
    int bitPixel;
    unsigned char colorMap[MAXCOLORMAPSIZE][4];
    int transparent = -1;
    static CONST char *optionStrings[] = {
	"-index",	NULL
    };

    if (format && Tcl_ListObjGetElements(interp, format,
	    &argc, &objv) != TCL_OK) {
	return TCL_ERROR;
    }
    for (i = 1; i < argc; i++) {
	if (Tcl_GetIndexFromObj(interp, objv[i], optionStrings, "option name", 0,
		&nBytes) != TCL_OK) {
	    return TCL_ERROR;
	}
	if (i == (argc-1)) {
	    Tcl_AppendResult(interp, "no value given for \"",
		    Tcl_GetStringFromObj(objv[i], NULL),
		    "\" option", (char *) NULL);
	    return TCL_ERROR;
	}
	if (Tcl_GetIntFromObj(interp, objv[++i], &index) != TCL_OK) {
	    return TCL_ERROR;
	}
    }
    if (!ReadGIFHeader(chan, &fileWidth, &fileHeight)) {
    	Tcl_AppendResult(interp, "couldn't read GIF header from file \"",
		fileName, "\"", NULL);
	return TCL_ERROR;
    }
    if ((fileWidth <= 0) || (fileHeight <= 0)) {
	Tcl_AppendResult(interp, "GIF image file \"", fileName,
		"\" has dimension(s) <= 0", (char *) NULL);
	return TCL_ERROR;
    }

    if (Fread(buf, 1, 3, chan) != 3) {
	return TCL_OK;
    }
    bitPixel = 2<<(buf[0]&0x07);

    if (BitSet(buf[0], LOCALCOLORMAP)) {	/* Global Colormap */
	if (!ReadColorMap(chan, bitPixel, colorMap)) {
	    Tcl_AppendResult(interp, "error reading color map",
		    (char *) NULL);
	    return TCL_ERROR;
	}
    }

    if ((srcX + width) > fileWidth) {
	width = fileWidth - srcX;
    }
    if ((srcY + height) > fileHeight) {
	height = fileHeight - srcY;
    }
    if ((width <= 0) || (height <= 0)
	    || (srcX >= fileWidth) || (srcY >= fileHeight)) {
	return TCL_OK;
    }

    Tk_PhotoExpand(imageHandle, destX + width, destY + height);

    block.width = width;
    block.height = height;
    block.pixelSize = 4;
    block.pitch = block.pixelSize * block.width;
    block.offset[0] = 0;
    block.offset[1] = 1;
    block.offset[2] = 2;
    block.offset[3] = 3;
    block.pixelPtr = NULL;

    while (1) {
	if (Fread(buf, 1, 1, chan) != 1) {
	    /*
	     * Premature end of image.  We should really notify
	     * the user, but for now just show garbage.
	     */

	    break;
	}

	if (buf[0] == GIF_TERMINATOR) {
	    /*
	     * GIF terminator.
	     */

	    Tcl_AppendResult(interp,"no image data for this index",
		    (char *) NULL);
	    goto error;
	}

	if (buf[0] == GIF_EXTENSION) {
	    /*
	     * This is a GIF extension.
	     */

	    if (Fread(buf, 1, 1, chan) != 1) {
		Tcl_SetResult(interp,
			"error reading extension function code in GIF image",
			TCL_STATIC);
		goto error;
	    }
	    if (DoExtension(chan, buf[0], &transparent) < 0) {
		Tcl_SetResult(interp, "error reading extension in GIF image",
			TCL_STATIC);
		goto error;
	    }
	    continue;
	}

	if (buf[0] != GIF_START) {
	    /*
	     * Not a valid start character; ignore it.
	     */
	    continue;
	}

	if (Fread(buf, 1, 9, chan) != 9) {
	    Tcl_SetResult(interp,
		    "couldn't read left/top/width/height in GIF image",
		    TCL_STATIC);
	    goto error;
	}

	fileWidth = LM_to_uint(buf[4],buf[5]);
	fileHeight = LM_to_uint(buf[6],buf[7]);

	bitPixel = 1<<((buf[8]&0x07)+1);

	if (index--) {
	    /*
	     * This is not the image we want to read: skip it.
	     */
	    if (BitSet(buf[8], LOCALCOLORMAP)) {
		if (!ReadColorMap(chan, bitPixel, colorMap)) {
		    Tcl_AppendResult(interp,
			    "error reading color map", (char *) NULL);
		    goto error;
		}
	    }

	    /*
	     * If we've not yet allocated a trash buffer, do so now.
	     */
	    if (trashBuffer == NULL) {
		nBytes = fileWidth * fileHeight * 3;
		trashBuffer =
		    (unsigned char *) ckalloc((unsigned int) nBytes);
	    }

	    /*
	     * Slurp!  Process the data for this image and stuff it in
	     * a trash buffer.
	     *
	     * Yes, it might be more efficient here to *not* store the
	     * data (we're just going to throw it away later).
	     * However, I elected to implement it this way for good
	     * reasons.  First, I wanted to avoid duplicating the
	     * (fairly complex) LWZ decoder in ReadImage.  Fine, you
	     * say, why didn't you just modify it to allow the use of
	     * a NULL specifier for the output buffer?  I tried that,
	     * but it negatively impacted the performance of what I
	     * think will be the common case: reading the first image
	     * in the file.  Rather than marginally improve the speed
	     * of the less frequent case, I chose to maintain high
	     * performance for the common case.
	     */
	    if (ReadImage(interp, (char *) trashBuffer, chan, fileWidth,
		    fileHeight, colorMap, 0, 0, 0, 0, 0, -1) != TCL_OK) {
		goto error;
	    }
	    continue;
	}

	/*
	 * If a trash buffer has been allocated, free it now.
	 */
	if (trashBuffer != NULL) {
	    ckfree((char *)trashBuffer);
	    trashBuffer = NULL;
	}
	if (BitSet(buf[8], LOCALCOLORMAP)) {
	    if (!ReadColorMap(chan, bitPixel, colorMap)) {
		    Tcl_AppendResult(interp, "error reading color map", 
			    (char *) NULL);
		    goto error;
	    }
	}

	index = LM_to_uint(buf[0],buf[1]);
	srcX -= index;
	if (srcX<0) {
	    destX -= srcX; width += srcX;
	    srcX = 0;
	}

	if (width > fileWidth) {
	    width = fileWidth;
	}

	index = LM_to_uint(buf[2],buf[3]);
	srcY -= index;
	if (index > srcY) {
	    destY -= srcY; height += srcY;
	    srcY = 0;
	}
	if (height > fileHeight) {
	    height = fileHeight;
	}

	if ((width <= 0) || (height <= 0)) {
	    block.pixelPtr = 0;
	    goto noerror;
	}

	block.width = width;
	block.height = height;
	block.pixelSize = (transparent>=0) ? 4 : 3;
	block.offset[3] = (transparent>=0) ? 3 : 0;
	block.pitch = block.pixelSize * fileWidth;
	nBytes = block.pitch * fileHeight;
	block.pixelPtr = (unsigned char *) ckalloc((unsigned) nBytes);

	if (ReadImage(interp, (char *) block.pixelPtr, chan, fileWidth,
		fileHeight, colorMap, fileWidth, fileHeight, srcX, srcY,
		BitSet(buf[8], INTERLACE), transparent) != TCL_OK) {
	    goto error;
	}
	break;
    }

    Tk_PhotoPutBlock(imageHandle, &block, destX, destY, width, height,
	    TK_PHOTO_COMPOSITE_SET);

    noerror:
    if (block.pixelPtr) {
	ckfree((char *) block.pixelPtr);
    }
    Tcl_AppendResult(interp, tkImgFmtGIF.name, (char *) NULL);
    return TCL_OK;

    error:
    if (block.pixelPtr) {
	ckfree((char *) block.pixelPtr);
    }
    return TCL_ERROR;

}

/*
 *----------------------------------------------------------------------
 *
 * StringMatchGIF --
 *
 *  This procedure is invoked by the photo image type to see if
 *  an object contains image data in GIF format.
 *
 * Results:
 *  The return value is 1 if the first characters in the data are
 *  like GIF data, and 0 otherwise.
 *
 * Side effects:
 *  the size of the image is placed in widthPre and heightPtr.
 *
 *----------------------------------------------------------------------
 */

static int
StringMatchGIF(dataObj, format, widthPtr, heightPtr, interp)
    Tcl_Obj *dataObj;		/* the object containing the image data */
    Tcl_Obj *format;		/* the image format object, or NULL */
    int *widthPtr;		/* where to put the string width */
    int *heightPtr;		/* where to put the string height */
    Tcl_Interp *interp;		/* not used */
{
    unsigned char *data, header[10];
    int got, length;
    MFile handle;

    data = Tcl_GetByteArrayFromObj(dataObj, &length);

    /*
     * Header is a minimum of 10 bytes.
     */
    if (length < 10) {
	return 0;
    }

    /*
     * Check whether the data is Base64 encoded.
     */

    if ((strncmp(GIF87a, (char *) data, 6) != 0) && 
	    (strncmp(GIF89a, (char *) data, 6) != 0)) {
	/*
	 * Try interpreting the data as Base64 encoded
	 */
	mInit((unsigned char *) data, &handle);
	got = Mread(header, 10, 1, &handle);
	if (got != 10
		|| ((strncmp(GIF87a, (char *) header, 6) != 0)
		&& (strncmp(GIF89a, (char *) header, 6) != 0))) {
	    return 0;
	}
    } else {
	memcpy((VOID *) header, (VOID *) data, 10);
    }
    *widthPtr = LM_to_uint(header[6],header[7]);
    *heightPtr = LM_to_uint(header[8],header[9]);
    return 1;
}

/*
 *----------------------------------------------------------------------
 *
 * StringReadGif -- --
 *
 *	This procedure is called by the photo image type to read
 *	GIF format data from an object, optionally base64 encoded, 
 *	and give it to the photo image.
 *
 * Results:
 *	A standard TCL completion code.  If TCL_ERROR is returned
 *	then an error message is left in the interp's result.
 *
 * Side effects:
 *	new data is added to the image given by imageHandle.  This
 *	procedure calls FileReadGif by redefining the operation of
 *	fprintf temporarily.
 *
 *----------------------------------------------------------------------
 */

static int
StringReadGIF(interp, dataObj, format, imageHandle,
	destX, destY, width, height, srcX, srcY)
    Tcl_Interp *interp;		/* interpreter for reporting errors in */
    Tcl_Obj *dataObj;		/* object containing the image */
    Tcl_Obj *format;		/* format object, or NULL */
    Tk_PhotoHandle imageHandle;	/* the image to write this data into */
    int destX, destY;		/* The rectangular region of the  */
    int width, height;		/*   image to copy */
    int srcX, srcY;
{
    int result;
    MFile handle;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
	    Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    Tcl_Channel dataSrc;
    char *data;

    /*
     * Check whether the data is Base64 encoded
     */
    data = (char *) Tcl_GetByteArrayFromObj(dataObj, NULL);
    if ((strncmp(GIF87a, data, 6) != 0) && (strncmp(GIF89a, data, 6) != 0)) {
	mInit((unsigned char *)data, &handle);
	tsdPtr->fromData = 1;
	dataSrc = (Tcl_Channel) &handle;
    } else {
	tsdPtr->fromData = 2;
	mInit((unsigned char *)data, &handle);
	dataSrc = (Tcl_Channel) &handle;
    }
    result = FileReadGIF(interp, dataSrc, "inline data",
	    format, imageHandle, destX, destY, width, height, srcX, srcY);
    tsdPtr->fromData = 0;
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * ReadGIFHeader --
 *
 *	This procedure reads the GIF header from the beginning of a
 *	GIF file and returns the dimensions of the image.
 *
 * Results:
 *	The return value is 1 if file "f" appears to start with
 *	a valid GIF header, 0 otherwise.  If the header is valid,
 *	then *widthPtr and *heightPtr are modified to hold the
 *	dimensions of the image.
 *
 * Side effects:
 *	The access position in f advances.
 *
 *----------------------------------------------------------------------
 */

static int
ReadGIFHeader(chan, widthPtr, heightPtr)
    Tcl_Channel chan;		/* Image file to read the header from */
    int *widthPtr, *heightPtr;	/* The dimensions of the image are
				 * returned here. */
{
    unsigned char buf[7];

    if ((Fread(buf, 1, 6, chan) != 6)
	    || ((strncmp(GIF87a, (char *) buf, 6) != 0)
	    && (strncmp(GIF89a, (char *) buf, 6) != 0))) {
	return 0;
    }

    if (Fread(buf, 1, 4, chan) != 4) {
	return 0;
    }

    *widthPtr = LM_to_uint(buf[0],buf[1]);
    *heightPtr = LM_to_uint(buf[2],buf[3]);
    return 1;
}

/*
 *-----------------------------------------------------------------
 * The code below is copied from the giftoppm program and modified
 * just slightly.
 *-----------------------------------------------------------------
 */

static int
ReadColorMap(chan, number, buffer)
    Tcl_Channel chan;
    int number;
    unsigned char buffer[MAXCOLORMAPSIZE][4];
{
    int i;
    unsigned char rgb[3];

    for (i = 0; i < number; ++i) {
	if (! ReadOK(chan, rgb, sizeof(rgb))) {
	    return 0;
	}

	if (buffer) {
	    buffer[i][CM_RED] = rgb[0] ;
	    buffer[i][CM_GREEN] = rgb[1] ;
	    buffer[i][CM_BLUE] = rgb[2] ;
	    buffer[i][CM_ALPHA] = 255 ;
	}
    }
    return 1;
}



static int
DoExtension(chan, label, transparent)
    Tcl_Channel chan;
    int label;
    int *transparent;
{
    static unsigned char buf[256];
    int count;

    switch (label) {
    case 0x01:		/* Plain Text Extension */
	break;

    case 0xff:		/* Application Extension */
	break;

    case 0xfe:		/* Comment Extension */
	do {
	    count = GetDataBlock(chan, (unsigned char*) buf);
	} while (count > 0);
	return count;

    case 0xf9:		/* Graphic Control Extension */
	count = GetDataBlock(chan, (unsigned char*) buf);
	if (count < 0) {
	    return 1;
	}
	if ((buf[0] & 0x1) != 0) {
	    *transparent = buf[3];
	}

	do {
	    count = GetDataBlock(chan, (unsigned char*) buf);
	} while (count > 0);
	return count;
    }

    do {
	count = GetDataBlock(chan, (unsigned char*) buf);
    } while (count > 0);
    return count;
}

static int ZeroDataBlock = 0;

static int
GetDataBlock(chan, buf)
    Tcl_Channel chan;
    unsigned char *buf;
{
    unsigned char count;

    if (! ReadOK(chan, &count,1)) {
	return -1;
    }

    ZeroDataBlock = count == 0;

    if ((count != 0) && (! ReadOK(chan, buf, count))) {
	return -1;
    }

    return count;
}



/*
 *----------------------------------------------------------------------
 *
 * ReadImage --
 *
 *	Process a GIF image from a given source, with a given height,
 *	width, transparency, etc.
 *
 *	This code is based on the code found in the ImageMagick GIF decoder,
 *	which is (c) 2000 ImageMagick Studio.
 *
 *	Some thoughts on our implementation:
 *	It sure would be nice if ReadImage didn't take 11 parameters!  I think
 *	that if we were smarter, we could avoid doing that.
 *
 *	Possible further optimizations:  we could pull the GetCode function
 *	directly into ReadImage, which would improve our speed.
 *
 * Results:
 *	Processes a GIF image and loads the pixel data into a memory array.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
ReadImage(interp, imagePtr, chan, len, rows, cmap,
	width, height, srcX, srcY, interlace, transparent)
    Tcl_Interp *interp;
    char *imagePtr;
    Tcl_Channel chan;
    int len, rows;
    unsigned char cmap[MAXCOLORMAPSIZE][4];
    int width, height;
    int srcX, srcY;
    int interlace;
    int transparent;
{
    unsigned char initialCodeSize;
    int v;
    int xpos = 0, ypos = 0, pass = 0, i;
    register char *pixelPtr;
    CONST static int interlaceStep[] = { 8, 8, 4, 2 };
    CONST static int interlaceStart[] = { 0, 4, 2, 1 };
    unsigned short prefix[(1 << MAX_LWZ_BITS)];
    unsigned char  append[(1 << MAX_LWZ_BITS)];
    unsigned char  stack[(1 << MAX_LWZ_BITS)*2];
    register unsigned char *top;
    int codeSize, clearCode, inCode, endCode, oldCode, maxCode;
    int code, firstCode;

    /*
     *  Initialize the decoder
     */
    if (! ReadOK(chan, &initialCodeSize, 1))  {
	Tcl_AppendResult(interp, "error reading GIF image: ",
		Tcl_PosixError(interp), (char *) NULL);
	return TCL_ERROR;
    }
    if (transparent != -1) {
	cmap[transparent][CM_RED] = 0;
	cmap[transparent][CM_GREEN] = 0;
	cmap[transparent][CM_BLUE] = 0;
	cmap[transparent][CM_ALPHA] = 0;
    }

    pixelPtr = imagePtr;

    /*
     * Initialize the decoder.
     *
     * Set values for "special" numbers:
     * clear code	reset the decoder
     * end code		stop decoding
     * code size	size of the next code to retrieve
     * max code		next available table position
     */
    clearCode = 1 << (int) initialCodeSize;
    endCode = clearCode + 1;
    codeSize = (int) initialCodeSize + 1;
    maxCode = clearCode + 2;
    oldCode = -1;
    firstCode = -1;
    
    memset((void *)prefix, 0, (1 << MAX_LWZ_BITS) * sizeof(short));
    memset((void *)append, 0, (1 << MAX_LWZ_BITS) * sizeof(char));
    for (i = 0; i < clearCode; i++) {
	append[i] = i;
    }
    top = stack;

    GetCode(chan, 0, 1);

    /*
     * Read until we finish the image
     */
    for (i = 0, ypos = 0; i < rows; i++) {
	for (xpos = 0; xpos < len; ) {

	    if (top == stack) {
		/*
		 * Bummer -- our stack is empty.  Now we have to work!
		 */
		code = GetCode(chan, codeSize, 0);
		if (code < 0) {
		    return TCL_OK;
		}

		if (code > maxCode || code == endCode) {
		    /*
		     * If we're doing things right, we should never
		     * receive a code that is greater than our current
		     * maximum code.  If we do, bail, because our decoder
		     * does not yet have that code set up.
		     *
		     * If the code is the magic endCode value, quit.
		     */
		    return TCL_OK;
		}

		if (code == clearCode) {
		    /*
		     * Reset the decoder.
		     */
		    codeSize = initialCodeSize + 1;
		    maxCode = clearCode + 2;
		    oldCode = -1;
		    continue;
		}
		
		if (oldCode == -1) {
		    /*
		     * Last pass reset the decoder, so the first code we
		     * see must be a singleton.  Seed the stack with it,
		     * and set up the old/first code pointers for
		     * insertion into the string table.  We can't just
		     * roll this into the clearCode test above, because
		     * at that point we have not yet read the next code.
		     */
		    *top++ = append[code];
		    oldCode = code;
		    firstCode = code;
		    continue;
		}
		
		inCode = code;

		if (code == maxCode) {
		    /*
		     * maxCode is always one bigger than our highest assigned
		     * code.  If the code we see is equal to maxCode, then
		     * we are about to add a new string to the table. ???
		     */
		    *top++ = firstCode;
		    code = oldCode;
		}

		while (code > clearCode) {
		    /*
		     * Populate the stack by tracing the string in the
		     * string table from its tail to its head
		     */
		    *top++ = append[code];
		    code = prefix[code];
		}
		firstCode = append[code];

		/*
		 * If there's no more room in our string table, quit.
		 * Otherwise, add a new string to the table
		 */
		if (maxCode >= (1 << MAX_LWZ_BITS)) {
		    return TCL_OK;
		}

		/*
		 * Push the head of the string onto the stack.
		 */
		*top++ = firstCode;

		/*
		 * Add a new string to the string table
		 */
		prefix[maxCode] = oldCode;
		append[maxCode] = firstCode;
		maxCode++;

		/*
		 * maxCode tells us the maximum code value we can accept.
		 * If we see that we need more bits to represent it than
		 * we are requesting from the unpacker, we need to increase
		 * the number we ask for.
		 */
		if ((maxCode >= (1 << codeSize))
			&& (maxCode < (1<<MAX_LWZ_BITS))) {
		    codeSize++;
		}
		oldCode = inCode;
	    }

	    /*
	     * Pop the next color index off the stack.
	     */
	    v = *(--top);
	    if (v < 0) {
		return TCL_OK;
	    }

	    /* 
	     * If pixelPtr is null, we're skipping this image (presumably
	     * there are more in the file and we will be called to read 
	     * one of them later)
	     */
	    *pixelPtr++ = cmap[v][CM_RED];
	    *pixelPtr++ = cmap[v][CM_GREEN];
	    *pixelPtr++ = cmap[v][CM_BLUE];
	    if (transparent >= 0) {
		*pixelPtr++ = cmap[v][CM_ALPHA];
	    }
	    xpos++;

	}

	/*
	 * If interlacing, the next ypos is not just +1
	 */
	if (interlace) {
	    ypos += interlaceStep[pass];
	    while (ypos >= height) {
		pass++;
		if (pass > 3) {
		    return TCL_OK;
		}
		ypos = interlaceStart[pass];
	    }
	} else {
	    ypos++;
	}
	pixelPtr = imagePtr + (ypos) * len * ((transparent>=0)?4:3);
    }
    return TCL_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * GetCode --
 *
 *	Extract the next compression code from the file.  In GIF's, the
 *	compression codes are between 3 and 12 bits long and are then
 *	packed into 8 bit bytes, left to right, for example:
 *		bbbaaaaa
 *		dcccccbb
 *		eeeedddd
 *		...
 *	We use a byte buffer read from the file and a sliding window
 *	to unpack the bytes.  Thanks to ImageMagick for the sliding window
 *	idea.
 *	args:  chan	    the channel to read from
 *	       code_size    size of the code to extract
 *	       flag	    boolean indicating whether the extractor
 *			    should be reset or not
 *
 * Results:
 *	code		    the next compression code
 *
 * Side effects:
 *	May consume more input from chan.
 *
 *----------------------------------------------------------------------
 */

static int
GetCode(chan, code_size, flag)
    Tcl_Channel chan;
    int code_size;
    int flag;
{
    static unsigned char buf[280];
    static int bytes = 0, done;
    static unsigned char *c;

    static unsigned int window;
    static int bitsInWindow = 0;
    int ret;
    
    if (flag) {
	/*
	 * Initialize the decoder.
	 */
	bitsInWindow = 0;
	bytes = 0;
	window = 0;
	done = 0;
	c = NULL;
	return 0;
    }

    while (bitsInWindow < code_size) {
	/*
	 * Not enough bits in our window to cover the request.
	 */
	if (done) {
	    return -1;
	}
	if (bytes == 0) {
	    /*
	     * Not enough bytes in our buffer to add to the window.
	     */
	    bytes = GetDataBlock(chan, buf);
	    c = buf;
	    if (bytes <= 0) {
		done = 1;
		break;
	    }
	}
	/*
	 * Tack another byte onto the window, see if that's enough.
	 */
	window += (*c) << bitsInWindow;
	c++;
	bitsInWindow += 8;
	bytes--;
    }


    /*
     * The next code will always be the last code_size bits of the window.
     */
    ret = window & ((1 << code_size) - 1);
    
    /*
     * Shift data in the window to put the next code at the end.
     */
    window >>= code_size;
    bitsInWindow -= code_size;
    return ret;
}

/*
 *----------------------------------------------------------------------
 *
 * Minit -- --
 *
 *  This procedure initializes a base64 decoder handle
 *
 * Results:
 *  none
 *
 * Side effects:
 *  the base64 handle is initialized
 *
 *----------------------------------------------------------------------
 */

static void
mInit(string, handle)
   unsigned char *string;	/* string containing initial mmencoded data */
   MFile *handle;		/* mmdecode "file" handle */
{
   handle->data = string;
   handle->state = 0;
   handle->c = 0;
}

/*
 *----------------------------------------------------------------------
 *
 * Mread --
 *
 *	This procedure is invoked by the GIF file reader as a 
 *	temporary replacement for "fread", to get GIF data out
 *	of a string (using Mgetc).
 *
 * Results:
 *	The return value is the number of characters "read"
 *
 * Side effects:
 *	The base64 handle will change state.
 *
 *----------------------------------------------------------------------
 */

static int
Mread(dst, chunkSize, numChunks, handle)  
   unsigned char *dst;	/* where to put the result */
   size_t chunkSize;	/* size of each transfer */
   size_t numChunks;	/* number of chunks */
   MFile *handle;	/* mmdecode "file" handle */
{
   register int i, c;
   int count = chunkSize * numChunks;

   for(i=0; i<count && (c=Mgetc(handle)) != GIF_DONE; i++) {
	*dst++ = c;
   }
   return i;
}

/*
 * get the next decoded character from an mmencode handle
 * This causes at least 1 character to be "read" from the encoded string
 */

/*
 *----------------------------------------------------------------------
 *
 * Mgetc --
 *
 *  This procedure decodes and returns the next byte from a base64
 *  encoded string.
 *
 * Results:
 *  The next byte (or GIF_DONE) is returned.
 *
 * Side effects:
 *  The base64 handle will change state.
 *
 *----------------------------------------------------------------------
 */

static int
Mgetc(handle)
   MFile *handle;		/* Handle containing decoder data and state */
{
    int c;
    int result = 0;		/* Initialization needed only to prevent
				 * gcc compiler warning. */

    if (handle->state == GIF_DONE) {
	return GIF_DONE;
    }

    do {
	c = char64(*handle->data);
	handle->data++;
    } while (c == GIF_SPACE);

    if (c>GIF_SPECIAL) {
	handle->state = GIF_DONE;
	return handle->c;
    }

    switch (handle->state++) {
    case 0:
	handle->c = c<<2;
	result = Mgetc(handle);
	break;
    case 1:
	result = handle->c | (c>>4);
	handle->c = (c&0xF)<<4;
	break;
    case 2:
	result = handle->c | (c>>2);
	handle->c = (c&0x3) << 6;
	break;
    case 3:
	result = handle->c | c;
	handle->state = 0;
	break;
    }
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * char64 --
 *
 *	This procedure converts a base64 ascii character into its binary
 *	equivalent.  This code is a slightly modified version of the
 *	char64 proc in N. Borenstein's metamail decoder.
 *
 * Results:
 *	The binary value, or an error code.
 *
 * Side effects:
 *	None.
 *----------------------------------------------------------------------
 */

static int
char64(c)
int c;
{
    switch(c) {
    case 'A': return 0;  case 'B': return 1;  case 'C': return 2;
    case 'D': return 3;  case 'E': return 4;  case 'F': return 5;
    case 'G': return 6;  case 'H': return 7;  case 'I': return 8;
    case 'J': return 9;  case 'K': return 10; case 'L': return 11;
    case 'M': return 12; case 'N': return 13; case 'O': return 14;
    case 'P': return 15; case 'Q': return 16; case 'R': return 17;
    case 'S': return 18; case 'T': return 19; case 'U': return 20;
    case 'V': return 21; case 'W': return 22; case 'X': return 23;
    case 'Y': return 24; case 'Z': return 25; case 'a': return 26;
    case 'b': return 27; case 'c': return 28; case 'd': return 29;
    case 'e': return 30; case 'f': return 31; case 'g': return 32;
    case 'h': return 33; case 'i': return 34; case 'j': return 35;
    case 'k': return 36; case 'l': return 37; case 'm': return 38;
    case 'n': return 39; case 'o': return 40; case 'p': return 41;
    case 'q': return 42; case 'r': return 43; case 's': return 44;
    case 't': return 45; case 'u': return 46; case 'v': return 47;
    case 'w': return 48; case 'x': return 49; case 'y': return 50;
    case 'z': return 51; case '0': return 52; case '1': return 53;
    case '2': return 54; case '3': return 55; case '4': return 56;
    case '5': return 57; case '6': return 58; case '7': return 59;
    case '8': return 60; case '9': return 61; case '+': return 62;
    case '/': return 63;

    case ' ': case '\t': case '\n': case '\r': case '\f':
	return GIF_SPACE;
    case '=':
	return GIF_PAD;
    case '\0':
	return GIF_DONE;
    default:
	return GIF_BAD;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Fread --
 *
 *  This procedure calls either fread or Mread to read data
 *  from a file or a base64 encoded string.
 *
 * Results: - same as fread
 *
 *----------------------------------------------------------------------
 */

static int
Fread(dst, hunk, count, chan)
    unsigned char *dst;		/* where to put the result */
    size_t hunk,count;		/* how many */
    Tcl_Channel chan;
{
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
	    Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    MFile *handle;

    switch (tsdPtr->fromData) {
    case 1:
	return Mread(dst, hunk, count, (MFile *) chan);
    case 2:
	handle = (MFile *) chan;
	memcpy((VOID *)dst, (VOID *) handle->data, (size_t) (hunk * count));
	handle->data += hunk * count;
	return (int)(hunk * count);
    default:
	return Tcl_Read(chan, (char *) dst, (int) (hunk * count));
    }
}


/*
 * ChanWriteGIF - writes a image in GIF format.
 *-------------------------------------------------------------------------
 * Author:			Lolo
 *				Engeneering Projects Area 
 *				Department of Mining 
 *				University of Oviedo
 * e-mail			zz11425958@@zeus.etsimo.uniovi.es
 *				lolo@@pcsig22.etsimo.uniovi.es
 * Date:			Fri September 20 1996
 *
 * Modified for transparency handling (gif89a) and miGIF compression
 * by Jan Nijtmans <j.nijtmans@@chello.nl>
 *
 *----------------------------------------------------------------------
 * FileWriteGIF-
 *
 *    This procedure is called by the photo image type to write
 *    GIF format data from a photo image into a given file 
 *
 * Results:
 *	A standard TCL completion code.  If TCL_ERROR is returned
 *	then an error message is left in interp->result.
 *
 *----------------------------------------------------------------------
 */

 /*
  *  Types, defines and variables needed to write and compress a GIF.
  */

typedef int (* ifunptr) _ANSI_ARGS_((void));	

#define LSB(a)			((unsigned char) (((short)(a)) & 0x00FF))
#define MSB(a)			((unsigned char) (((short)(a)) >> 8))

#define GIFBITS 12
#define HSIZE  5003		/* 80% occupancy */

static int ssize;
static int csize;
static int rsize;
static unsigned char *pixelo;
static int pixelSize;
static int pixelPitch;
static int greenOffset;
static int blueOffset;
static int alphaOffset;
static int num;
static unsigned char mapa[MAXCOLORMAPSIZE][3];

/*
 *	Definition of new functions to write GIFs
 */

static int color _ANSI_ARGS_((int red,int green, int blue,
		unsigned char mapa[MAXCOLORMAPSIZE][3]));
static void compress _ANSI_ARGS_((int init_bits, Tcl_Channel handle,
		ifunptr readValue));
static int nuevo _ANSI_ARGS_((int red, int green ,int blue,
		unsigned char mapa[MAXCOLORMAPSIZE][3]));
static void savemap _ANSI_ARGS_((Tk_PhotoImageBlock *blockPtr,
		unsigned char mapa[MAXCOLORMAPSIZE][3]));
static int ReadValue _ANSI_ARGS_((void));

static int
FileWriteGIF(interp, filename, format, blockPtr)
    Tcl_Interp *interp;		/* Interpreter to use for reporting errors. */
    CONST char	*filename;
    Tcl_Obj	*format;
    Tk_PhotoImageBlock *blockPtr;
{
    Tcl_Channel chan = NULL;
    int result;

    chan = Tcl_OpenFileChannel(interp, (char *) filename, "w", 0644);
    if (!chan) {
	return TCL_ERROR;
    }
    if (Tcl_SetChannelOption(interp, chan, "-translation", "binary") != TCL_OK) {
	Tcl_Close(NULL, chan);
	return TCL_ERROR;
    }

    result = CommonWriteGIF(interp, chan, format, blockPtr);
    if (Tcl_Close(interp, chan) == TCL_ERROR) {
	return TCL_ERROR;
    }
    return result;
}

#define Mputc(c,handle) Tcl_Write(handle,(char *) &c,1)

static int
CommonWriteGIF(interp, handle, format, blockPtr)
    Tcl_Interp *interp;
    Tcl_Channel handle;
    Tcl_Obj *format;
    Tk_PhotoImageBlock *blockPtr;
{
    int  resolution;

    long  width,height,x;
    unsigned char c;
    unsigned int top,left;

    top = 0;
    left = 0;

    pixelSize = blockPtr->pixelSize;
    greenOffset = blockPtr->offset[1]-blockPtr->offset[0];
    blueOffset = blockPtr->offset[2]-blockPtr->offset[0];
    alphaOffset = blockPtr->offset[0];
    if (alphaOffset < blockPtr->offset[2]) {
	alphaOffset = blockPtr->offset[2];
    }
    if (++alphaOffset < pixelSize) {
	alphaOffset -= blockPtr->offset[0];
    } else {
	alphaOffset = 0;
    }

    Tcl_Write(handle, (char *) (alphaOffset ? GIF89a : GIF87a), 6);

    for (x=0 ; x<MAXCOLORMAPSIZE ; x++) {
	mapa[x][CM_RED] = 255;
	mapa[x][CM_GREEN] = 255;
	mapa[x][CM_BLUE] = 255;
    }


    width = blockPtr->width;
    height = blockPtr->height;
    pixelo = blockPtr->pixelPtr + blockPtr->offset[0];
    pixelPitch = blockPtr->pitch;
    savemap(blockPtr,mapa);
    if (num >= MAXCOLORMAPSIZE) {
	Tcl_AppendResult(interp, "too many colors", (char *) NULL);
	return TCL_ERROR;
    }
    if (num<2) {
	num = 2;
    }
    c = LSB(width);
    Mputc(c,handle);
    c = MSB(width);
    Mputc(c,handle);
    c = LSB(height);
    Mputc(c,handle);
    c = MSB(height);
    Mputc(c,handle);

    resolution = 0;
    while (num >> resolution) {
	resolution++;
    }
    c = 111 + resolution * 17;
    Mputc(c,handle);

    num = 1 << resolution;

    /*
     * background color
     */

    c = 0;
    Mputc(c,handle);

    /*
     * zero for future expansion.
     */

    Mputc(c,handle);

    for (x=0 ; x<num ; x++) {
	c = mapa[x][CM_RED];
	Mputc(c,handle);
	c = mapa[x][CM_GREEN];
	Mputc(c,handle);
	c = mapa[x][CM_BLUE];
	Mputc(c,handle);
    }

    /*
     * Write out extension for transparent colour index, if necessary.
     */

    if (alphaOffset) {
	c = GIF_EXTENSION;
	Mputc(c, handle);
	Tcl_Write(handle, "\371\4\1\0\0\0", 7);
    }

    c = GIF_START;
    Mputc(c,handle);
    c = LSB(top);
    Mputc(c,handle);
    c = MSB(top);
    Mputc(c,handle);
    c = LSB(left);
    Mputc(c,handle);
    c = MSB(left);
    Mputc(c,handle);

    c = LSB(width);
    Mputc(c,handle);
    c = MSB(width);
    Mputc(c,handle);

    c = LSB(height);
    Mputc(c,handle);
    c = MSB(height);
    Mputc(c,handle);

    c = 0;
    Mputc(c,handle);
    c = resolution;
    Mputc(c,handle);

    ssize = rsize = blockPtr->width;
    csize = blockPtr->height;
    compress(resolution+1, handle, ReadValue);

    c = 0; 
    Mputc(c,handle);
    c = GIF_TERMINATOR;
    Mputc(c,handle);

    return TCL_OK;	
}

static int
color(red, green, blue, mapa)
    int red;
    int green;
    int blue;
    unsigned char mapa[MAXCOLORMAPSIZE][3];
{
    int x;
    for (x=(alphaOffset != 0) ; x<=MAXCOLORMAPSIZE ; x++) {
	if ((mapa[x][CM_RED] == red) && (mapa[x][CM_GREEN] == green) &&
		(mapa[x][CM_BLUE] == blue)) {
	    return x;
	}
    }
    return -1;
}


static int
nuevo(red, green, blue, mapa)
    int red,green,blue;
    unsigned char mapa[MAXCOLORMAPSIZE][3];
{
    int x = (alphaOffset != 0);
    for (; x<=num ; x++) {
	if ((mapa[x][CM_RED] == red) && (mapa[x][CM_GREEN] == green) &&
		(mapa[x][CM_BLUE] == blue)) {
	    return 0;
	}
    }
    return 1;
}

static void
savemap(blockPtr,mapa)
    Tk_PhotoImageBlock *blockPtr;
    unsigned char mapa[MAXCOLORMAPSIZE][3];
{
    unsigned char *colores;
    int x,y;
    unsigned char red,green,blue;

    if (alphaOffset) {
	num = 0;
	mapa[0][CM_RED] = 0xd9;
	mapa[0][CM_GREEN] = 0xd9;
	mapa[0][CM_BLUE] = 0xd9;
    } else {
	num = -1;
    }

    for(y=0 ; y<blockPtr->height ; y++) {
	colores = blockPtr->pixelPtr + blockPtr->offset[0]
		+ y * blockPtr->pitch;
	for(x=0 ; x<blockPtr->width ; x++) {
	    if (!alphaOffset || (colores[alphaOffset] != 0)) {
		red = colores[0];
		green = colores[greenOffset];
		blue = colores[blueOffset];
		if (nuevo(red,green,blue,mapa)) {
		    num++;
		    if (num >= MAXCOLORMAPSIZE) {
			return;
		    }
		    mapa[num][CM_RED] = red;
		    mapa[num][CM_GREEN] = green;
		    mapa[num][CM_BLUE] = blue;
		}
	    }
	    colores += pixelSize;
	}
    }
    return;
}

static int
ReadValue()
{
    unsigned int col;

    if (csize == 0) {
	return EOF;
    }
    if (alphaOffset && (pixelo[alphaOffset] == 0)) {
	col = 0;
    } else {
	col = color(pixelo[0], pixelo[greenOffset], pixelo[blueOffset], mapa);
    }
    pixelo += pixelSize;
    if (--ssize <= 0) {
	ssize = rsize;
	csize--;
	pixelo += pixelPitch - (rsize * pixelSize);
    }

    return col;
}



/*
 *-----------------------------------------------------------------------
 *
 * miGIF Compression - mouse and ivo's GIF-compatible compression
 *
 *		-run length encoding compression routines-
 *
 * Copyright (C) 1998 Hutchison Avenue Software Corporation
 *		 http://www.hasc.com
 *		 info@@hasc.com
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby
 * granted, provided that the above copyright notice appear in all
 * copies and that both that copyright notice and this permission
 * notice appear in supporting documentation.  This software is
 * provided "AS IS." The Hutchison Avenue Software Corporation
 * disclaims all warranties, either express or implied, including but
 * not limited to implied warranties of merchantability and fitness
 * for a particular purpose, with respect to this code and
 * accompanying documentation.
 * 
 * The miGIF compression routines do not, strictly speaking, generate
 * files conforming to the GIF spec, since the image data is not
 * LZW-compressed (this is the point: in order to avoid transgression
 * of the Unisys patent on the LZW algorithm.)  However, miGIF
 * generates data streams that any reasonably sane LZW decompresser
 * will decompress to what we want.
 *
 * miGIF compression uses run length encoding. It compresses
 * horizontal runs of pixels of the same color. This type of
 * compression gives good results on images with many runs, for
 * example images with lines, text and solid shapes on a solid-colored
 * background. It gives little or no compression on images with few
 * runs, for example digital or scanned photos.
 *
 *				 der Mouse
 *			mouse@@rodents.montreal.qc.ca
 *	      7D C8 61 52 5D E7 2D 39  4E F1 31 3E E8 B3 27 4B
 *
 *			       ivo@@hasc.com
 *
 * The Graphics Interchange Format(c) is the Copyright property of
 * CompuServe Incorporated.  GIF(sm) is a Service Mark property of
 * CompuServe Incorporated.
 *
 *-----------------------------------------------------------------------
 */

static int rl_pixel;
static int rl_basecode;
static int rl_count;
static int rl_table_pixel;
static int rl_table_max;
static int just_cleared;
static int out_bits;
static int out_bits_init;
static int out_count;
static int out_bump;
static int out_bump_init;
static int out_clear;
static int out_clear_init;
static int max_ocodes;
static int code_clear;
static int code_eof;
static unsigned int obuf;
static int obits;
static Tcl_Channel ofile;
static unsigned char oblock[256];
static int oblen;

/*
 * Used only when debugging GIF compression code
 */
/* #define MIGIF_DEBUGGING_ENVARS */

#ifdef MIGIF_DEBUGGING_ENVARS

static int verbose_set = 0;
static int verbose;
#define MIGIF_VERBOSE (verbose_set?verbose:set_verbose())
#define DEBUGMSG(printf_args) if (MIGIF_VERBOSE) { printf printf_args; }

static int
set_verbose(void)
{
    verbose = !!getenv("MIGIF_VERBOSE");
    verbose_set = 1;
    return verbose;
}

static CONST char *
binformat(v, nbits)
    unsigned int v;
    int nbits;
{
    static char bufs[8][64];
    static int bhand = 0;
    unsigned int bit;
    int bno;
    char *bp;

    bhand--;
    if (bhand < 0) {
	bhand = (sizeof(bufs) / sizeof(bufs[0])) - 1;
    }
    bp = &bufs[bhand][0];
    for (bno=nbits-1,bit=((unsigned int)1)<<bno ; bno>=0 ; bno--,bit>>=1) {
	*bp++ = (v & bit) ? '1' : '0';
	if (((bno&3) == 0) && (bno != 0)) {
	    *bp++ = '.';
	}
    }
    *bp = '\0';
    return &bufs[bhand][0];
}

#else

#define MIGIF_VERBOSE 0
#define DEBUGMSG(printf_args) /* do nothing */

#endif

static void
write_block()
{
    int i;
    unsigned char c;

    if (MIGIF_VERBOSE) {
	printf("write_block %d:", oblen);
	for (i=0 ; i<oblen ; i++) {
	    printf(" %02x", oblock[i]);
	}
	printf("\n");
    }
    c = oblen;
    Tcl_Write(ofile, (char *) &c, 1);
    Tcl_Write(ofile, (char *) &oblock[0], oblen);
    oblen = 0;
}

static void
block_out(c)
    unsigned char c;
{
    DEBUGMSG(("block_out %s\n", binformat(c, 8)));
    oblock[oblen++] = c;
    if (oblen >= 255) {
	write_block();
    }
}

static void
block_flush()
{
    DEBUGMSG(("block_flush\n"));
    if (oblen > 0) {
	write_block();
    }
}

static void
output(val)
    int val;
{
    DEBUGMSG(("output %s [%s %d %d]\n", binformat(val, out_bits),
	    binformat(obuf, obits), obits, out_bits));
    obuf |= val << obits;
    obits += out_bits;
    while (obits >= 8) {
	block_out(obuf&0xff);
	obuf >>= 8;
	obits -= 8;
    }
    DEBUGMSG(("output leaving [%s %d]\n", binformat(obuf, obits), obits));
}

static void
output_flush()
{
    DEBUGMSG(("output_flush\n"));
    if (obits > 0) {
	block_out(obuf);
    }
    block_flush();
}

static void
did_clear()
{
    DEBUGMSG(("did_clear\n"));
    out_bits = out_bits_init;
    out_bump = out_bump_init;
    out_clear = out_clear_init;
    out_count = 0;
    rl_table_max = 0;
    just_cleared = 1;
}

static void
output_plain(c)
    int c;
{
    DEBUGMSG(("output_plain %s\n", binformat(c, out_bits)));
    just_cleared = 0;
    output(c);
    out_count++;
    if (out_count >= out_bump) {
	out_bits++;
	out_bump += 1 << (out_bits - 1);
    }
    if (out_count >= out_clear) {
	output(code_clear);
	did_clear();
    }
}

static unsigned int
isqrt(x)
    unsigned int x;
{
    unsigned int r;
    unsigned int v;

    if (x < 2) {
	return x;
    }
    for (v=x,r=1 ; v ; v>>=2,r<<=1);
    while (1) {
	v = ((x / r) + r) / 2;
	if (v==r || v==r+1) {
	    return r;
	}
	r = v;
    }
}

static unsigned int
compute_triangle_count(count, nrepcodes)
    unsigned int count;
    unsigned int nrepcodes;
{
    unsigned int perrep;
    unsigned int cost;

    cost = 0;
    perrep = (nrepcodes * (nrepcodes+1)) / 2;
    while (count >= perrep) {
	cost += nrepcodes;
	count -= perrep;
    }
    if (count > 0) {
	unsigned int n;
	n = isqrt(count);
	while (n*(n+1) >= 2*count) {
	    n--;
	}
	while (n*(n+1) < 2*count) {
	    n++;
	}
	cost += n;
    }
    return cost;
}

static void
max_out_clear()
{
    out_clear = max_ocodes;
}

static void
reset_out_clear()
{
    out_clear = out_clear_init;
    if (out_count >= out_clear) {
	output(code_clear);
	did_clear();
    }
}

static void
rl_flush_fromclear(count)
    int count;
{
    int n;

    DEBUGMSG(("rl_flush_fromclear %d\n", count));
    max_out_clear();
    rl_table_pixel = rl_pixel;
    n = 1;
    while (count > 0) {
	if (n == 1) {
	    rl_table_max = 1;
	    output_plain(rl_pixel);
	    count--;
	} else if (count >= n) {
	    rl_table_max = n;
	    output_plain(rl_basecode+n-2);
	    count -= n;
	} else if (count == 1) {
	    rl_table_max++;
	    output_plain(rl_pixel);
	    count = 0;
	} else {
	    rl_table_max++;
	    output_plain(rl_basecode+count-2);
	    count = 0;
	}
	if (out_count == 0) {
	    n = 1;
	} else {
	    n++;
	}
    }
    reset_out_clear();
    DEBUGMSG(("rl_flush_fromclear leaving table_max=%d\n", rl_table_max));
}

static void
rl_flush_clearorrep(count)
    int count;
{
    int withclr;

    DEBUGMSG(("rl_flush_clearorrep %d\n", count));
    withclr = 1 + compute_triangle_count(count, max_ocodes);
    if (withclr < count) {
	output(code_clear);
	did_clear();
	rl_flush_fromclear(count);
    } else {
	for (; count>0 ; count--) {
	    output_plain(rl_pixel);
	}
    }
}

static void
rl_flush_withtable(count)
    int count;
{
    int repmax;
    int repleft;
    int leftover;

    DEBUGMSG(("rl_flush_withtable %d\n", count));
    repmax = count / rl_table_max;
    leftover = count % rl_table_max;
    repleft = (leftover ? 1 : 0);
    if (out_count+repmax+repleft > max_ocodes) {
	repmax = max_ocodes - out_count;
	leftover = count - (repmax * rl_table_max);
	repleft = 1 + compute_triangle_count(leftover, max_ocodes);
    }
    DEBUGMSG(("rl_flush_withtable repmax=%d leftover=%d repleft=%d\n",
	    repmax, leftover, repleft));
    if (1+(int)compute_triangle_count(count, max_ocodes) < repmax+repleft) {
	output(code_clear);
	did_clear();
	rl_flush_fromclear(count);
	return;
    }
    max_out_clear();
    for (; repmax>0 ; repmax--) {
	output_plain(rl_basecode + rl_table_max - 2);
    }
    if (leftover) {
	if (just_cleared) {
	    rl_flush_fromclear(leftover);
	} else if (leftover == 1) {
	    output_plain(rl_pixel);
	} else {
	    output_plain(rl_basecode + leftover - 2);
	}
    }
    reset_out_clear();
}

static void
rl_flush()
{
    DEBUGMSG(("rl_flush [ %d %d\n", rl_count, rl_pixel));
    if (rl_count == 1) {
	output_plain(rl_pixel);
	rl_count = 0;
	DEBUGMSG(("rl_flush ]\n"));
	return;
    }
    if (just_cleared) {
	rl_flush_fromclear(rl_count);
    } else if ((rl_table_max < 2) || (rl_table_pixel != rl_pixel)) {
	rl_flush_clearorrep(rl_count);
    } else {
	rl_flush_withtable(rl_count);
    }
    DEBUGMSG(("rl_flush ]\n"));
    rl_count = 0;
}


static void
compress(init_bits, handle, readValue)
    int init_bits;
    Tcl_Channel handle;
    ifunptr readValue;
{
    int c;

    ofile = handle;
    obuf = 0;
    obits = 0;
    oblen = 0;
    code_clear = 1 << (init_bits - 1);
    code_eof = code_clear + 1;
    rl_basecode = code_eof + 1;
    out_bump_init = (1 << (init_bits - 1)) - 1;
    /*
     * For images with a lot of runs, making out_clear_init larger
     * will give better compression.
     */
    out_clear_init = (init_bits <= 3) ? 9 : (out_bump_init-1);
#ifdef MIGIF_DEBUGGING_ENVARS
    {
	const char *ocienv;
	ocienv = getenv("MIGIF_OUT_CLEAR_INIT");
	if (ocienv) {
	    out_clear_init = atoi(ocienv);
	    DEBUGMSG(("[overriding out_clear_init to %d]\n", out_clear_init));
	}
    }
#endif
    out_bits_init = init_bits;
    max_ocodes = (1 << GIFBITS) - ((1 << (out_bits_init - 1)) + 3);
    did_clear();
    output(code_clear);
    rl_count = 0;
    while (1) {
	c = readValue();
	if ((rl_count > 0) && (c != rl_pixel)) {
	    rl_flush();
	}
	if (c == EOF) {
	    break;
	}
	if (rl_pixel == c) {
	    rl_count++;
	} else {
	    rl_pixel = c;
	    rl_count = 1;
	}
    }
    output(code_eof);
    output_flush();
}

/*
 *-----------------------------------------------------------------------
 *
 * End of miGIF section  - See copyright notice at start of section.
 *
 *-----------------------------------------------------------------------
 */
@


1.4
log
@touched all sources to ease next import
@
text
@d22 8
a29 8
 * +-------------------------------------------------------------------+
 * | Copyright 1990, David Koblas.                                     |
 * |   Permission to use, copy, modify, and distribute this software   |
 * |   and its documentation for any purpose and without fee is hereby |
 * |   granted, provided that the above copyright notice appear in all |
 * |   copies and that both that copyright notice and this permission  |
 * |   notice appear in supporting documentation.  This software is    |
 * |   provided "as is" without express or implied warranty.           |
d32 1
a32 1
 * RCS: @@(#) $Id: tkImgGIF.c,v 1.7.6.3 2000/09/26 16:08:03 spolk Exp $
d44 1
a44 1
#define GIF_SPECIAL	 (256)
d75 9
a83 7
static CONST char GIF87a[] =
	{ 0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x00 }; /* ASCII GIF87a */
static CONST char GIF89a[] =
	{ 0x47, 0x49, 0x46, 0x38, 0x39, 0x61, 0x00 }; /* ASCII GIF89a */
#  define GIF_TERMINATOR 0x3b                         /* ASCII ; */
#  define GIF_EXTENSION  0x21                         /* ASCII ! */
#  define GIF_START      0x2c                         /* ASCII , */
d101 1
a101 1
static int      FileMatchGIF _ANSI_ARGS_((Tcl_Channel chan, CONST char *fileName,
d104 1
a104 1
static int      FileReadGIF  _ANSI_ARGS_((Tcl_Interp *interp,
d123 7
a129 7
	"gif",			/* name */
	FileMatchGIF,   /* fileMatchProc */
	StringMatchGIF, /* stringMatchProc */
	FileReadGIF,    /* fileReadProc */
	StringReadGIF,  /* stringReadProc */
	FileWriteGIF,   /* fileWriteProc */
	NULL,           /* stringWriteProc */
d141 1
a141 1
#define LM_to_uint(a,b)         (((b)<<8)|(a))
d221 1
a221 1
 *	then an error message is left in interp->result.
d254 1
a254 1
    static char *optionStrings[] = {
d293 1
a293 1
    if (BitSet(buf[0], LOCALCOLORMAP)) {    /* Global Colormap */
d350 3
a352 2
		interp->result =
			"error reading extension function code in GIF image";
d356 2
a357 1
		interp->result = "error reading extension in GIF image";
d371 3
a373 1
	    interp->result = "couldn't read left/top/width/height in GIF image";
d383 3
a385 1
	    /* this is not the image we want to read: skip it. */
d394 3
a396 1
	    /* If we've not yet allocated a trash buffer, do so now */
d404 2
a405 2
	     * Slurp!  Process the data for this image and stuff it in a
	     * trash buffer.
d407 12
a418 10
	     * Yes, it might be more efficient here to *not* store the data
	     * (we're just going to throw it away later).  However, I elected
	     * to implement it this way for good reasons.  First, I wanted to
	     * avoid duplicating the (fairly complex) LWZ decoder in ReadImage.
	     * Fine, you say, why didn't you just modify it to allow the use of
	     * a NULL specifier for the output buffer?  I tried that, but it
	     * negatively impacted the performance of what I think will be the
	     * common case:  reading the first image in the file.  Rather than
	     * marginally improve the speed of the less frequent case, I chose
	     * to maintain high performance for the common case.
d421 2
a422 2
			  fileHeight, colorMap, 0, 0, 0, 0, 0, -1) != TCL_OK) {
	      goto error;
d427 3
a429 1
	/* If a trash buffer has been allocated, free it now */
d472 2
a473 2
	block.pitch = block.pixelSize * width;
	nBytes = block.pitch * height;
d476 2
a477 2
	if (ReadImage(interp, (char *) block.pixelPtr, chan, width,
		height, colorMap, fileWidth, fileHeight, srcX, srcY,
d484 2
a485 1
    Tk_PhotoPutBlock(imageHandle, &block, destX, destY, width, height);
d534 3
a536 1
    /* Header is a minimum of 10 bytes */
d538 1
a538 1
      return 0;
d541 3
a543 1
    /* Check whether the data is Base64 encoded */
d546 11
a556 9
	(strncmp(GIF89a, (char *) data, 6) != 0)) {
      /* Try interpreting the data as Base64 encoded */
      mInit((unsigned char *) data, &handle);
      got = Mread(header, 10, 1, &handle);
      if (got != 10
	      || ((strncmp(GIF87a, (char *) header, 6) != 0)
	      && (strncmp(GIF89a, (char *) header, 6) != 0))) {
	  return 0;
      }
d558 1
a558 1
      memcpy((VOID *) header, (VOID *) data, 10);
d576 1
a576 1
 *	then an error message is left in interp->result.
d594 1
a594 1
    int  width, height;		/*   image to copy */
d600 1
a600 1
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
d608 1
a608 2
    if ((strncmp(GIF87a, data, 6) != 0) && 
	    (strncmp(GIF89a, data, 6) != 0)) {
d620 1
a620 1
    return(result);
d675 17
a691 18
     Tcl_Channel chan;
     int number;
     unsigned char buffer[MAXCOLORMAPSIZE][4];
{
	int i;
	unsigned char rgb[3];

	for (i = 0; i < number; ++i) {
	    if (! ReadOK(chan, rgb, sizeof(rgb))) {
		return 0;
	    }
	    
	    if (buffer) {
		buffer[i][CM_RED] = rgb[0] ;
		buffer[i][CM_GREEN] = rgb[1] ;
		buffer[i][CM_BLUE] = rgb[2] ;
		buffer[i][CM_ALPHA] = 255 ;
	    }
d693 2
a694 1
	return 1;
d701 3
a703 3
     Tcl_Channel chan;
     int label;
     int *transparent;
d709 2
a710 5
	case 0x01:      /* Plain Text Extension */
	    break;
	    
	case 0xff:      /* Application Extension */
	    break;
d712 2
a713 5
	case 0xfe:      /* Comment Extension */
	    do {
		count = GetDataBlock(chan, (unsigned char*) buf);
	    } while (count > 0);
	    return count;
d715 2
a716 1
	case 0xf9:      /* Graphic Control Extension */
d718 11
a728 6
	    if (count < 0) {
		return 1;
	    }
	    if ((buf[0] & 0x1) != 0) {
		*transparent = buf[3];
	    }
d730 4
a733 4
	    do {
		count = GetDataBlock(chan, (unsigned char*) buf);
	    } while (count > 0);
	    return count;
d746 2
a747 2
     Tcl_Channel chan;
     unsigned char *buf;
d772 1
a772 1
 *      width, transparency, etc.
d774 2
a775 2
 *      This code is based on the code found in the ImageMagick GIF decoder,
 *      which is (c) 2000 ImageMagick Studio.
d777 3
a779 3
 *      Some thoughts on our implementation:
 *      It sure would be nice if ReadImage didn't take 11 parameters!  I think
 *      that if we were smarter, we could avoid doing that.
d781 2
a782 2
 *      Possible further optimizations:  we could pull the GetCode function
 *      directly into ReadImage, which would improve our speed.
d796 9
a804 9
     Tcl_Interp *interp;
     char *imagePtr;
     Tcl_Channel chan;
     int len, rows;
     unsigned char cmap[MAXCOLORMAPSIZE][4];
     int width, height;
     int srcX, srcY;
     int interlace;
     int transparent;
d816 3
a818 3
    int codeSize, clearCode, inCode, endCode, oldCode, maxCode,
	code, firstCode;
    
d827 1
a827 1
    if (transparent!=-1) {
d836 4
a839 2
    /* Initialize the decoder */
    /* Set values for "special" numbers:
d845 6
a850 6
    clearCode   = 1 << (int) initialCodeSize;
    endCode     = clearCode + 1;
    codeSize    = (int) initialCodeSize + 1;
    maxCode     = clearCode + 2;
    oldCode     = -1;
    firstCode   = -1;
d861 3
a863 1
    /* Read until we finish the image */
d868 3
a870 1
		/* Bummer -- our stack is empty.  Now we have to work! */
d889 6
a894 4
		    /* Reset the decoder */
		    codeSize    = initialCodeSize + 1;
		    maxCode     = clearCode + 2;
		    oldCode     = -1;
d907 1
a907 1
		    *top++=append[code];
d943 3
a945 1
		/* Push the head of the string onto the stack */
d948 3
a950 1
		/* Add a new string to the string table */
d955 2
a956 1
		/* maxCode tells us the maximum code value we can accept.
d968 3
a970 1
	    /* Pop the next color index off the stack */
d991 3
a993 1
	/* If interlacing, the next ypos is not just +1 */
d1017 14
a1030 14
 *      Extract the next compression code from the file.  In GIF's, the
 *      compression codes are between 3 and 12 bits long and are then
 *      packed into 8 bit bytes, left to right, for example:
 *                 bbbaaaaa
 *                 dcccccbb
 *                 eeeedddd
 *                 ...
 *      We use a byte buffer read from the file and a sliding window
 *      to unpack the bytes.  Thanks to ImageMagick for the sliding window
 *      idea.
 *      args:  chan         the channel to read from
 *             code_size    size of the code to extract
 *             flag         boolean indicating whether the extractor
 *                          should be reset or not
d1033 1
a1033 1
 *	code                the next compression code
d1043 3
a1045 3
     Tcl_Channel chan;
     int code_size;
     int flag;
d1056 3
a1058 1
	/* Initialize the decoder */
d1068 3
a1070 1
	/* Not enough bits in our window to cover the request */
d1075 3
a1077 1
	    /* Not enough bytes in our buffer to add to the window */
d1085 3
a1087 1
	/* Tack another byte onto the window, see if that's enough */
d1094 4
a1097 1
    /* The next code will always be the last code_size bits of the window */
d1100 3
a1102 1
    /* Shift data in the window to put the next code at the end */
d1192 1
a1192 1
   MFile *handle;		/* Handle containing decoder data and state. */
d1197 1
a1197 1
     
d1199 1
a1199 1
	return(GIF_DONE);
d1205 1
a1205 1
    } while (c==GIF_SPACE);
d1209 1
a1209 1
	return(handle->state ? handle->c : GIF_DONE);
d1213 16
a1228 16
	case 0:
	   handle->c = c<<2;
	   result = Mgetc(handle);
	   break;
	case 1:
	   result = handle->c | (c>>4);
	   handle->c = (c&0xF)<<4;
	   break;
	case 2:
	   result = handle->c | (c>>2);
	   handle->c = (c&0x3) << 6;
	   break;
	case 3:
	   result = handle->c | c;
	   handle->state = 0;
	   break;
d1230 1
a1230 1
    return(result);
d1255 31
a1285 27
        case 'A': return(0);  case 'B': return(1);  case 'C': return(2);
        case 'D': return(3);  case 'E': return(4);  case 'F': return(5);
        case 'G': return(6);  case 'H': return(7);  case 'I': return(8);
        case 'J': return(9);  case 'K': return(10); case 'L': return(11);
        case 'M': return(12); case 'N': return(13); case 'O': return(14);
        case 'P': return(15); case 'Q': return(16); case 'R': return(17);
        case 'S': return(18); case 'T': return(19); case 'U': return(20);
        case 'V': return(21); case 'W': return(22); case 'X': return(23);
        case 'Y': return(24); case 'Z': return(25); case 'a': return(26);
        case 'b': return(27); case 'c': return(28); case 'd': return(29);
        case 'e': return(30); case 'f': return(31); case 'g': return(32);
        case 'h': return(33); case 'i': return(34); case 'j': return(35);
        case 'k': return(36); case 'l': return(37); case 'm': return(38);
        case 'n': return(39); case 'o': return(40); case 'p': return(41);
        case 'q': return(42); case 'r': return(43); case 's': return(44);
        case 't': return(45); case 'u': return(46); case 'v': return(47);
        case 'w': return(48); case 'x': return(49); case 'y': return(50);
        case 'z': return(51); case '0': return(52); case '1': return(53);
        case '2': return(54); case '3': return(55); case '4': return(56);
        case '5': return(57); case '6': return(58); case '7': return(59);
        case '8': return(60); case '9': return(61); case '+': return(62);
        case '/': return(63);

	case ' ': case '\t': case '\n': case '\r': case '\f': return(GIF_SPACE);
	case '=':  return(GIF_PAD);
	case '\0': return(GIF_DONE);
	default: return(GIF_BAD);
d1309 1
a1309 1
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
d1313 3
a1315 3
      case 1:
	return(Mread(dst, hunk, count, (MFile *) chan));
      case 2:
d1319 2
a1320 2
	return((int) (hunk * count));
      default:
d1329 4
a1332 4
 * Author:          		Lolo
 *                              Engeneering Projects Area 
 *	            		Department of Mining 
 *                  		University of Oviedo
d1334 2
a1335 2
 *                  		lolo@@pcsig22.etsimo.uniovi.es
 * Date:            		Fri September 20 1996
d1359 2
a1360 2
#define LSB(a)                  ((unsigned char) (((short)(a)) & 0x00FF))
#define MSB(a)                  ((unsigned char) (((short)(a)) >> 8))
d1363 1
a1363 1
#define HSIZE  5003            /* 80% occupancy */
d1392 1
a1392 1
FileWriteGIF (interp, filename, format, blockPtr)
d1406 1
d1435 3
a1437 3
    pixelSize=blockPtr->pixelSize;
    greenOffset=blockPtr->offset[1]-blockPtr->offset[0];
    blueOffset=blockPtr->offset[2]-blockPtr->offset[0];
d1450 1
a1450 1
    for (x=0;x<MAXCOLORMAPSIZE;x++) {
d1457 4
a1460 4
    width=blockPtr->width;
    height=blockPtr->height;
    pixelo=blockPtr->pixelPtr + blockPtr->offset[0];
    pixelPitch=blockPtr->pitch;
d1462 1
a1462 1
    if (num>=MAXCOLORMAPSIZE) {
d1466 4
a1469 2
    if (num<2) num=2;
    c=LSB(width);
d1471 1
a1471 1
    c=MSB(width);
d1473 1
a1473 1
    c=LSB(height);
d1475 1
a1475 1
    c=MSB(height);
d1487 3
a1489 1
    /*  background color */
d1494 3
a1496 1
    /*  zero for future expansion  */
d1500 1
a1500 1
    for (x=0; x<num ;x++) {
d1521 1
a1521 1
    c=LSB(top);
d1523 1
a1523 1
    c=MSB(top);
d1525 1
a1525 1
    c=LSB(left);
d1527 1
a1527 1
    c=MSB(left);
d1530 1
a1530 1
    c=LSB(width);
d1532 1
a1532 1
    c=MSB(width);
d1535 1
a1535 1
    c=LSB(height);
d1537 1
a1537 1
    c=MSB(height);
d1540 1
a1540 1
    c=0;
d1542 1
a1542 1
    c=resolution;
d1565 3
a1567 3
    for (x=(alphaOffset != 0);x<=MAXCOLORMAPSIZE;x++) {
	if ((mapa[x][CM_RED]==red) && (mapa[x][CM_GREEN]==green) &&
		(mapa[x][CM_BLUE]==blue)) {
d1580 4
a1583 4
    int x;
    for (x=(alphaOffset != 0);x<=num;x++) {
	if ((mapa[x][CM_RED]==red) && (mapa[x][CM_GREEN]==green) &&
		(mapa[x][CM_BLUE]==blue)) {
d1595 1
a1595 1
    unsigned char  *colores;
d1597 1
a1597 1
    unsigned char  red,green,blue;
d1608 2
a1609 2
    for(y=0;y<blockPtr->height;y++) {
	colores=blockPtr->pixelPtr + blockPtr->offset[0]
d1611 1
a1611 1
	for(x=0;x<blockPtr->width;x++) {
d1618 1
a1618 1
		    if (num>=MAXCOLORMAPSIZE) {
d1621 3
a1623 3
		    mapa[num][CM_RED]=red;
		    mapa[num][CM_GREEN]=green;
		    mapa[num][CM_BLUE]=blue;
d1640 1
a1640 1
    if (alphaOffset && (pixelo[alphaOffset]==0)) {
d1643 1
a1643 1
	col = color(pixelo[0],pixelo[greenOffset],pixelo[blueOffset], mapa);
d1657 2
a1658 1
/*-----------------------------------------------------------------------
d1662 1
a1662 1
 *          -run length encoding compression routines-
d1665 2
a1666 2
 *               http://www.hasc.com
 *               info@@hasc.com
d1668 10
a1677 9
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted, provided
 * that the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation.  This software is provided "AS IS." The Hutchison Avenue 
 * Software Corporation disclaims all warranties, either express or implied, 
 * including but not limited to implied warranties of merchantability and 
 * fitness for a particular purpose, with respect to this code and accompanying
 * documentation. 
d1679 17
a1695 15
 * The miGIF compression routines do not, strictly speaking, generate files 
 * conforming to the GIF spec, since the image data is not LZW-compressed 
 * (this is the point: in order to avoid transgression of the Unisys patent 
 * on the LZW algorithm.)  However, miGIF generates data streams that any 
 * reasonably sane LZW decompresser will decompress to what we want.
 *
 * miGIF compression uses run length encoding. It compresses horizontal runs 
 * of pixels of the same color. This type of compression gives good results
 * on images with many runs, for example images with lines, text and solid 
 * shapes on a solid-colored background. It gives little or no compression 
 * on images with few runs, for example digital or scanned photos.
 *
 *                               der Mouse
 *                      mouse@@rodents.montreal.qc.ca
 *            7D C8 61 52 5D E7 2D 39  4E F1 31 3E E8 B3 27 4B
d1697 1
a1697 1
 *                             ivo@@hasc.com
d1703 1
d1728 4
a1731 2
/* Used only when debugging GIF compression code */
/* #define DEBUGGING_ENVARS */
d1733 1
a1733 1
#ifdef DEBUGGING_ENVARS
d1737 2
a1738 1
#define VERBOSE (verbose_set?verbose:set_verbose())
d1740 12
a1751 1
static int set_verbose(void)
d1753 19
a1771 3
 verbose = !!getenv("GIF_VERBOSE");
 verbose_set = 1;
 return(verbose);
d1776 2
a1777 1
#define VERBOSE 0
d1781 5
d1787 11
a1797 36
static CONST char *
binformat(v, nbits)
    unsigned int v;
    int nbits;
{
 static char bufs[8][64];
 static int bhand = 0;
 unsigned int bit;
 int bno;
 char *bp;

 bhand --;
 if (bhand < 0) bhand = (sizeof(bufs)/sizeof(bufs[0]))-1;
 bp = &bufs[bhand][0];
 for (bno=nbits-1,bit=((unsigned int)1)<<bno;bno>=0;bno--,bit>>=1)
  { *bp++ = (v & bit) ? '1' : '0';
    if (((bno&3) == 0) && (bno != 0)) *bp++ = '.';
  }
 *bp = '\0';
 return(&bufs[bhand][0]);
}

static void write_block()
{
 int i;
 unsigned char c;

 if (VERBOSE)
  { printf("write_block %d:",oblen);
    for (i=0;i<oblen;i++) printf(" %02x",oblock[i]);
    printf("\n");
  }
 c = oblen;
 Tcl_Write(ofile, (char *) &c, 1);
 Tcl_Write(ofile, (char *) &oblock[0], oblen);
 oblen = 0;
d1804 5
a1808 3
 if (VERBOSE) printf("block_out %s\n",binformat(c,8));
 oblock[oblen++] = c;
 if (oblen >= 255) write_block();
d1811 2
a1812 1
static void block_flush()
d1814 4
a1817 2
 if (VERBOSE) printf("block_flush\n");
 if (oblen > 0) write_block();
d1820 2
a1821 1
static void output(val)
d1824 32
a1855 27
 if (VERBOSE) printf("output %s [%s %d %d]\n",binformat(val,out_bits),binformat(obuf,obits),obits,out_bits);
 obuf |= val << obits;
 obits += out_bits;
 while (obits >= 8)
  { block_out(obuf&0xff);
    obuf >>= 8;
    obits -= 8;
  }
 if (VERBOSE) printf("output leaving [%s %d]\n",binformat(obuf,obits),obits);
}

static void output_flush()
{
 if (VERBOSE) printf("output_flush\n");
 if (obits > 0) block_out(obuf);
 block_flush();
}

static void did_clear()
{
 if (VERBOSE) printf("did_clear\n");
 out_bits = out_bits_init;
 out_bump = out_bump_init;
 out_clear = out_clear_init;
 out_count = 0;
 rl_table_max = 0;
 just_cleared = 1;
d1862 12
a1873 12
 if (VERBOSE) printf("output_plain %s\n",binformat(c,out_bits));
 just_cleared = 0;
 output(c);
 out_count ++;
 if (out_count >= out_bump)
  { out_bits ++;
    out_bump += 1 << (out_bits - 1);
  }
 if (out_count >= out_clear)
  { output(code_clear);
    did_clear();
  }
d1876 2
a1877 1
static unsigned int isqrt(x)
d1880 2
a1881 2
 unsigned int r;
 unsigned int v;
d1883 11
a1893 7
 if (x < 2) return(x);
 for (v=x,r=1;v;v>>=2,r<<=1) ;
 while (1)
  { v = ((x / r) + r) / 2;
    if ((v == r) || (v == r+1)) return(r);
    r = v;
  }
d1901 22
a1922 2
 unsigned int perrep;
 unsigned int cost;
d1924 14
a1937 28
 cost = 0;
 perrep = (nrepcodes * (nrepcodes+1)) / 2;
 while (count >= perrep)
  { cost += nrepcodes;
    count -= perrep;
  }
 if (count > 0)
  { unsigned int n;
    n = isqrt(count);
    while ((n*(n+1)) >= 2*count) n --;
    while ((n*(n+1)) < 2*count) n ++;
    cost += n;
  }
 return(cost);
}

static void max_out_clear()
{
 out_clear = max_ocodes;
}

static void reset_out_clear()
{
 out_clear = out_clear_init;
 if (out_count >= out_clear)
  { output(code_clear);
    did_clear();
  }
d1944 1
a1944 1
 int n;
d1946 30
a1975 29
 if (VERBOSE) printf("rl_flush_fromclear %d\n",count);
 max_out_clear();
 rl_table_pixel = rl_pixel;
 n = 1;
 while (count > 0)
  { if (n == 1)
     { rl_table_max = 1;
       output_plain(rl_pixel);
       count --;
     }
    else if (count >= n)
     { rl_table_max = n;
       output_plain(rl_basecode+n-2);
       count -= n;
     }
    else if (count == 1)
     { rl_table_max ++;
       output_plain(rl_pixel);
       count = 0;
     }
    else
     { rl_table_max ++;
       output_plain(rl_basecode+count-2);
       count = 0;
     }
    if (out_count == 0) n = 1; else n ++;
  }
 reset_out_clear();
 if (VERBOSE) printf("rl_flush_fromclear leaving table_max=%d\n",rl_table_max);
d1978 2
a1979 1
static void rl_flush_clearorrep(count)
d1982 1
a1982 1
 int withclr;
d1984 11
a1994 10
 if (VERBOSE) printf("rl_flush_clearorrep %d\n",count);
 withclr = 1 + compute_triangle_count(count,max_ocodes);
 if (withclr < count)
  { output(code_clear);
    did_clear();
    rl_flush_fromclear(count);
  }
 else
  { for (;count>0;count--) output_plain(rl_pixel);
  }
d1997 2
a1998 1
static void rl_flush_withtable(count)
d2001 55
a2055 41
 int repmax;
 int repleft;
 int leftover;

 if (VERBOSE) printf("rl_flush_withtable %d\n",count);
 repmax = count / rl_table_max;
 leftover = count % rl_table_max;
 repleft = (leftover ? 1 : 0);
 if (out_count+repmax+repleft > max_ocodes)
  { repmax = max_ocodes - out_count;
    leftover = count - (repmax * rl_table_max);
    repleft = 1 + compute_triangle_count(leftover,max_ocodes);
  }
 if (VERBOSE) printf("rl_flush_withtable repmax=%d leftover=%d repleft=%d\n",repmax,leftover,repleft);
 if (1+(int)compute_triangle_count(count,max_ocodes) < repmax+repleft)
  { output(code_clear);
    did_clear();
    rl_flush_fromclear(count);
    return;
  }
 max_out_clear();
 for (;repmax>0;repmax--) output_plain(rl_basecode+rl_table_max-2);
 if (leftover)
  { if (just_cleared)
     { rl_flush_fromclear(leftover);
     }
    else if (leftover == 1)
     { output_plain(rl_pixel);
     }
    else
     { output_plain(rl_basecode+leftover-2);
     }
  }
 reset_out_clear();
}

static void rl_flush()
{
 if (VERBOSE) printf("rl_flush [ %d %d\n",rl_count,rl_pixel);
 if (rl_count == 1)
  { output_plain(rl_pixel);
a2056 14
    if (VERBOSE) printf("rl_flush ]\n");
    return;
  }
 if (just_cleared)
  { rl_flush_fromclear(rl_count);
  }
 else if ((rl_table_max < 2) || (rl_table_pixel != rl_pixel))
  { rl_flush_clearorrep(rl_count);
  }
 else
  { rl_flush_withtable(rl_count);
  }
 if (VERBOSE) printf("rl_flush ]\n");
 rl_count = 0;
d2060 2
a2061 1
static void compress( init_bits, handle, readValue )
d2066 1
a2066 1
 int c;
d2068 22
a2089 19
 ofile = handle;
 obuf = 0;
 obits = 0;
 oblen = 0;
 code_clear = 1 << (init_bits - 1);
 code_eof = code_clear + 1;
 rl_basecode = code_eof + 1;
 out_bump_init = (1 << (init_bits - 1)) - 1;
 /* for images with a lot of runs, making out_clear_init larger will
    give better compression. */ 
 out_clear_init = (init_bits <= 3) ? 9 : (out_bump_init-1);
#ifdef DEBUGGING_ENVARS
  { const char *ocienv;
    ocienv = getenv("GIF_OUT_CLEAR_INIT");
    if (ocienv)
     { out_clear_init = atoi(ocienv);
       if (VERBOSE) printf("[overriding out_clear_init to %d]\n",out_clear_init);
     }
  }
d2091 22
a2112 19
 out_bits_init = init_bits;
 max_ocodes = (1 << GIFBITS) - ((1 << (out_bits_init - 1)) + 3);
 did_clear();
 output(code_clear);
 rl_count = 0;
 while (1)
  { c = readValue();
    if ((rl_count > 0) && (c != rl_pixel)) rl_flush();
    if (c == EOF) break;
    if (rl_pixel == c)
     { rl_count ++;
     }
    else
     { rl_pixel = c;
       rl_count = 1;
     }
  }
 output(code_eof);
 output_flush();
d2115 2
a2116 1
/*-----------------------------------------------------------------------
d2120 2
a2121 3
 *-----------------------------------------------------------------------*/


@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d5 2
a6 2
 *	files. At present there is no write function.  GIF images may be
 *	read using the -data option of the photo image.  The data may be
d32 1
a32 1
 * RCS: @@(#) $Id: tkImgGIF.c,v 1.12 1999/01/26 04:11:23 jingham Exp $
d66 30
d99 3
a101 2
static int      FileMatchGIF _ANSI_ARGS_((Tcl_Channel chan, char *fileName,
		    char *formatString, int *widthPtr, int *heightPtr));
d103 1
a103 1
		    Tcl_Channel chan, char *fileName, char *formatString,
d107 2
a108 1
		    char *formatString, int *widthPtr, int *heightPtr));
d110 1
a110 1
		    char *formatString, Tk_PhotoHandle imageHandle,
d113 6
d121 1
a121 1
	"GIF",			/* name */
d126 1
a126 1
	NULL,           /* fileWriteProc */
a142 9
 * 			 HACK ALERT!!  HACK ALERT!!  HACK ALERT!!
 * This code is hard-wired for reading from files.  In order to read
 * from a data stream, we'll trick fread so we can reuse the same code.
 * 0==from file; 1==from base64 encoded data; 2==from binary data
 */
 
static int fromData=0;

/*
a151 2
static int		LWZReadByte _ANSI_ARGS_((Tcl_Channel chan, int flag,
			    int input_code_size));
d175 1
d196 1
a196 1
FileMatchGIF(chan, fileName, formatString, widthPtr, heightPtr)
d198 2
a199 2
    char *fileName;		/* The name of the image file. */
    char *formatString;		/* User-specified format string, or NULL. */
d203 1
d229 1
a229 1
FileReadGIF(interp, chan, fileName, formatString, imageHandle, destX, destY,
d233 2
a234 2
    char *fileName;		/* The name of the image file. */
    char *formatString;		/* User-specified format string, or NULL. */
d244 2
a245 1
    int nBytes;
d248 1
d252 3
d256 19
d276 1
a276 1
	Tcl_AppendResult(interp, "couldn't read GIF header from file \"",
d319 2
a320 2
    nBytes = height * block.pitch;
    block.pixelPtr = (unsigned char *) ckalloc((unsigned) nBytes);
d332 1
a332 1
	if (buf[0] == ';') {
d337 3
a339 1
	    break;
d342 1
a342 1
	if (buf[0] == '!') {
d359 1
a359 1
	if (buf[0] != ',') {
d371 3
d376 44
d427 35
d468 1
a468 1
   }
d470 1
a470 5
    if (transparent == -1) {
	Tk_PhotoPutBlock(imageHandle, &block, destX, destY, width, height);
    } else {
	int x, y, end;
	unsigned char *imagePtr, *rowPtr, *pixelPtr;
d472 3
a474 24
	imagePtr = rowPtr = block.pixelPtr;
	for (y = 0; y < height; y++) {
	    x = 0;
	    pixelPtr = rowPtr;
	    while(x < width) {
		/* search for first non-transparent pixel */
		while ((x < width) && !(pixelPtr[CM_ALPHA])) {
		    x++; pixelPtr += 4;
		}
		end = x;
		/* search for first transparent pixel */
		while ((end < width) && pixelPtr[CM_ALPHA]) {
		    end++; pixelPtr += 4;
		}
		if (end > x) {
		    block.pixelPtr = rowPtr + 4 * x;
		    Tk_PhotoPutBlock(imageHandle, &block, destX+x,
			    destY+y, end-x, 1);
		}
		x = end;
	    }
	    rowPtr += block.pitch;
	}
	block.pixelPtr = imagePtr;
d476 1
a476 1
    ckfree((char *) block.pixelPtr);
d480 3
a482 1
    ckfree((char *) block.pixelPtr);
d506 1
a506 1
StringMatchGIF(dataObj, formatString, widthPtr, heightPtr)
d508 1
a508 1
    char *formatString;		/* the image format string */
d511 1
d517 1
a517 1
    data = Tcl_GetStringFromObj(dataObj, &length);
d526 2
a527 2
    if ((strncmp("GIF87a", data, 6) != 0) && 
	(strncmp("GIF89a", data, 6) != 0)) {
d532 2
a533 2
	      || ((strncmp("GIF87a", (char *) header, 6) != 0)
	      && (strncmp("GIF89a", (char *) header, 6) != 0))) {
d566 1
a566 1
StringReadGIF(interp,dataObj,formatString,imageHandle,
d570 1
a570 1
    char *formatString;		/* format string if any */
d576 25
a600 21
	int result;
	MFile handle;
	Tcl_Channel dataSrc;
	char *data;
	/* Check whether the data is Base64 encoded */
	data = Tcl_GetStringFromObj(dataObj, NULL);
	if ((strncmp("GIF87a", data, 6) != 0) && 
	    (strncmp("GIF89a", data, 6) != 0)) {
	  mInit((unsigned char *)data,&handle);
	  fromData = 1;
	  dataSrc = (Tcl_Channel) &handle;
	} else {
	  fromData = 2;
	  mInit((unsigned char *)data,&handle);
	  dataSrc = (Tcl_Channel) &handle;
	}
	result = FileReadGIF(interp, dataSrc, "inline data",
		formatString, imageHandle, destX, destY, width, height,
		srcX, srcY);
	fromData = 0;
	return(result);
d632 2
a633 2
	    || ((strncmp("GIF87a", (char *) buf, 6) != 0)
	    && (strncmp("GIF89a", (char *) buf, 6) != 0))) {
d667 6
a672 4
	    buffer[i][CM_RED] = rgb[0] ;
	    buffer[i][CM_GREEN] = rgb[1] ;
	    buffer[i][CM_BLUE] = rgb[2] ;
	    buffer[i][CM_ALPHA] = 255 ;
d745 28
d786 1
a786 1
    unsigned char c;
d788 11
a798 4
    int xpos = 0, ypos = 0, pass = 0;
    char *pixelPtr;


d800 1
a800 1
     *  Initialize the Compression routines
d802 1
a802 1
    if (! ReadOK(chan, &c, 1))  {
a806 6

    if (LWZReadByte(chan, 1, c) < 0) {
	interp->result = "format error in GIF image";
	return TCL_ERROR;
    }

a814 1
    while ((v = LWZReadByte(chan, 0, c)) >= 0 ) {
d816 45
a860 7
	if ((xpos>=srcX) && (xpos<srcX+len) &&
		(ypos>=srcY) && (ypos<srcY+rows)) {
	    *pixelPtr++ = cmap[v][CM_RED];
	    *pixelPtr++ = cmap[v][CM_GREEN];
	    *pixelPtr++ = cmap[v][CM_BLUE];
	    *pixelPtr++ = cmap[v][CM_ALPHA];
	}
d862 6
a867 12
	++xpos;
	if (xpos == width) {
	    xpos = 0;
	    if (interlace) {
		switch (pass) {
		    case 0:
		    case 1:
			ypos += 8; break;
		    case 2:
			ypos += 4; break;
		    case 3:
			ypos += 2; break;
d870 13
a882 12
		while (ypos >= height) {
		    ++pass;
		    switch (pass) {
			case 1:
			    ypos = 4; break;
			case 2:
			    ypos = 2; break;
			case 3:
			    ypos = 1; break;
			default:
			    return TCL_OK;
		    }
d884 2
a885 10
	    } else {
		++ypos;
	    }
	    pixelPtr = imagePtr + (ypos-srcY) * len * 4;
	}
	if (ypos >= height)
	    break;
    }
    return TCL_OK;
}
d887 9
a895 15
static int
LWZReadByte(chan, flag, input_code_size)
     Tcl_Channel chan;
     int flag;
     int input_code_size;
{
    static int  fresh = 0;
    int code, incode;
    static int code_size, set_code_size;
    static int max_code, max_code_size;
    static int firstcode, oldcode;
    static int clear_code, end_code;
    static int table[2][(1<< MAX_LWZ_BITS)];
    static int stack[(1<<(MAX_LWZ_BITS))*2], *sp;
    register int    i;
d897 9
a905 7
    if (flag) {
	set_code_size = input_code_size;
	code_size = set_code_size+1;
	clear_code = 1 << set_code_size ;
	end_code = clear_code + 1;
	max_code_size = 2*clear_code;
	max_code = clear_code+2;
d907 7
a913 1
	GetCode(chan, 0, 1);
d915 2
a916 1
	fresh = 1;
d918 15
a932 32
	for (i = 0; i < clear_code; ++i) {
	    table[0][i] = 0;
	    table[1][i] = i;
	}
	for (; i < (1<<MAX_LWZ_BITS); ++i) {
	    table[0][i] = table[1][0] = 0;
	}

	sp = stack;

	return 0;
    } else if (fresh) {
	fresh = 0;
	do {
	    firstcode = oldcode = GetCode(chan, code_size, 0);
	} while (firstcode == clear_code);
	return firstcode;
    }

    if (sp > stack) {
	return *--sp;
    }

    while ((code = GetCode(chan, code_size, 0)) >= 0) {
	if (code == clear_code) {
	    for (i = 0; i < clear_code; ++i) {
		table[0][i] = 0;
		table[1][i] = i;
	    }
	    
	    for (; i < (1<<MAX_LWZ_BITS); ++i) {
		table[0][i] = table[1][i] = 0;
d935 4
a938 13
	    code_size = set_code_size+1;
	    max_code_size = 2*clear_code;
	    max_code = clear_code+2;
	    sp = stack;
	    firstcode = oldcode = GetCode(chan, code_size, 0);
	    return firstcode;

	} else if (code == end_code) {
	    int count;
	    unsigned char buf[260];

	    if (ZeroDataBlock) {
		return -2;
a939 3
	    
	    while ((count = GetDataBlock(chan, buf)) > 0)
		/* Empty body */;
d941 10
a950 2
	    if (count != 0) {
		return -2;
d952 1
a952 3
	}

	incode = code;
a953 3
	if (code >= max_code) {
	    *sp++ = firstcode;
	    code = oldcode;
d956 9
a964 10
	while (code >= clear_code) {
	    *sp++ = table[1][code];
	    if (code == table[0][code]) {
		return -2;

		/*
		 * Used to be this instead, Steve Ball suggested
		 * the change to just return.
		 printf("circular table entry BIG ERROR\n");
		 */
d966 2
a967 1
	    code = table[0][code];
d969 3
a971 19

	*sp++ = firstcode = table[1][code];

	if ((code = max_code) <(1<<MAX_LWZ_BITS)) {
	    table[0][code] = oldcode;
	    table[1][code] = firstcode;
	    ++max_code;
	    if ((max_code>=max_code_size) && (max_code_size < (1<<MAX_LWZ_BITS))) {
		max_code_size *= 2;
		++code_size;
	    }
	}

	oldcode = incode;

	if (sp > stack)
	    return *--sp;
	}
	return code;
d974 29
d1011 2
a1012 3
    static int curbit, lastbit, done, last_byte;
    int i, j, ret;
    unsigned char count;
d1014 4
d1019 4
a1022 2
	curbit = 0;
	lastbit = 0;
d1024 1
d1028 2
a1029 2

    if ( (curbit+code_size) >= lastbit) {
a1030 1
	    /* ran off the end of my bits */
d1033 8
a1040 9
	if (last_byte >= 2) {
	    buf[0] = buf[last_byte-2];
	}
	if (last_byte >= 1) {
	    buf[1] = buf[last_byte-1];
	}

	if ((count = GetDataBlock(chan, &buf[2])) == 0) {
	    done = 1;
d1042 5
a1046 4

	last_byte = 2 + count;
	curbit = (curbit - lastbit) + 16;
	lastbit = (2+count)*8 ;
d1049 6
a1054 7
    ret = 0;
    for (i = curbit, j = 0; j < code_size; ++i, ++j) {
	ret |= ((buf[ i / 8 ] & (1 << (i % 8))) != 0) << j;
    }

    curbit += code_size;

d1254 5
a1258 4
  MFile *handle;
    switch (fromData) {
      case 0:
	return Tcl_Read(chan, (char *) dst, (int) (hunk * count));
d1263 1
a1263 1
	memcpy((VOID *)dst, (VOID *) handle->data, (int) (hunk * count));
d1266 2
d1270 742
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d5 2
a6 2
 *	files. At present, there only is a file write function. GIF images
 *	may be read using the -data option of the photo image.  The data may be
d32 1
a32 1
 * RCS: @@(#) $Id: tkImgGIF.c,v 1.7.6.3 2000/09/26 16:08:03 spolk Exp $
a65 30
 * Non-ASCII encoding support:
 * Most data in a GIF image is binary and is treated as such.  However,
 * a few key bits are stashed in ASCII.  If we try to compare those pieces
 * to the char they represent, it will fail on any non-ASCII (eg, EBCDIC)
 * system.  To accomodate these systems, we test against the numeric value
 * of the ASCII characters instead of the characters themselves.  This is
 * encoding independant.
 */

static CONST char GIF87a[] =
	{ 0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x00 }; /* ASCII GIF87a */
static CONST char GIF89a[] =
	{ 0x47, 0x49, 0x46, 0x38, 0x39, 0x61, 0x00 }; /* ASCII GIF89a */
#  define GIF_TERMINATOR 0x3b                         /* ASCII ; */
#  define GIF_EXTENSION  0x21                         /* ASCII ! */
#  define GIF_START      0x2c                         /* ASCII , */

/*
 * 			 HACK ALERT!!  HACK ALERT!!  HACK ALERT!!
 * This code is hard-wired for reading from files.  In order to read
 * from a data stream, we'll trick fread so we can reuse the same code.
 * 0==from file; 1==from base64 encoded data; 2==from binary data
 */

typedef struct ThreadSpecificData {
    int fromData;
} ThreadSpecificData;
static Tcl_ThreadDataKey dataKey;

/*
d69 2
a70 3
static int      FileMatchGIF _ANSI_ARGS_((Tcl_Channel chan, CONST char *fileName,
		    Tcl_Obj *format, int *widthPtr, int *heightPtr,
		    Tcl_Interp *interp));
d72 1
a72 1
		    Tcl_Channel chan, CONST char *fileName, Tcl_Obj *format,
d76 1
a76 2
		    Tcl_Obj *format, int *widthPtr, int *heightPtr,
		    Tcl_Interp *interp));
d78 1
a78 1
		    Tcl_Obj *format, Tk_PhotoHandle imageHandle,
a80 6
static int 	FileWriteGIF _ANSI_ARGS_((Tcl_Interp *interp,  
		    CONST char *filename, Tcl_Obj *format,
		    Tk_PhotoImageBlock *blockPtr));
static int	CommonWriteGIF _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Channel handle, Tcl_Obj *format,
		    Tk_PhotoImageBlock *blockPtr));
d83 1
a83 1
	"gif",			/* name */
d88 1
a88 1
	FileWriteGIF,   /* fileWriteProc */
d105 9
d123 2
a147 1

d168 1
a168 1
FileMatchGIF(chan, fileName, format, widthPtr, heightPtr, interp)
d170 2
a171 2
    CONST char *fileName;	/* The name of the image file. */
    Tcl_Obj *format;		/* User-specified format object, or NULL. */
a174 1
    Tcl_Interp *interp;		/* not used */
d200 1
a200 1
FileReadGIF(interp, chan, fileName, format, imageHandle, destX, destY,
d204 2
a205 2
    CONST char *fileName;	/* The name of the image file. */
    Tcl_Obj *format;		/* User-specified format object, or NULL. */
d215 1
a215 2
    int nBytes, index = 0, argc = 0, i;
    Tcl_Obj **objv;
a217 1
    unsigned char *trashBuffer = NULL;
a220 3
    static char *optionStrings[] = {
	"-index",	NULL
    };
a221 19
    if (format && Tcl_ListObjGetElements(interp, format,
	    &argc, &objv) != TCL_OK) {
	return TCL_ERROR;
    }
    for (i = 1; i < argc; i++) {
	if (Tcl_GetIndexFromObj(interp, objv[i], optionStrings, "option name", 0,
		&nBytes) != TCL_OK) {
	    return TCL_ERROR;
	}
	if (i == (argc-1)) {
	    Tcl_AppendResult(interp, "no value given for \"",
		    Tcl_GetStringFromObj(objv[i], NULL),
		    "\" option", (char *) NULL);
	    return TCL_ERROR;
	}
	if (Tcl_GetIntFromObj(interp, objv[++i], &index) != TCL_OK) {
	    return TCL_ERROR;
	}
    }
d223 1
a223 1
    	Tcl_AppendResult(interp, "couldn't read GIF header from file \"",
d266 2
a267 2
    block.offset[3] = 3;
    block.pixelPtr = NULL;
d279 1
a279 1
	if (buf[0] == GIF_TERMINATOR) {
d284 1
a284 3
	    Tcl_AppendResult(interp,"no image data for this index",
		    (char *) NULL);
	    goto error;
d287 1
a287 1
	if (buf[0] == GIF_EXTENSION) {
d304 1
a304 1
	if (buf[0] != GIF_START) {
a315 3
	fileWidth = LM_to_uint(buf[4],buf[5]);
	fileHeight = LM_to_uint(buf[6],buf[7]);

a317 44
	if (index--) {
	    /* this is not the image we want to read: skip it. */
	    if (BitSet(buf[8], LOCALCOLORMAP)) {
		if (!ReadColorMap(chan, bitPixel, colorMap)) {
		    Tcl_AppendResult(interp,
			    "error reading color map", (char *) NULL);
		    goto error;
		}
	    }

	    /* If we've not yet allocated a trash buffer, do so now */
	    if (trashBuffer == NULL) {
		nBytes = fileWidth * fileHeight * 3;
		trashBuffer =
		    (unsigned char *) ckalloc((unsigned int) nBytes);
	    }

	    /*
	     * Slurp!  Process the data for this image and stuff it in a
	     * trash buffer.
	     *
	     * Yes, it might be more efficient here to *not* store the data
	     * (we're just going to throw it away later).  However, I elected
	     * to implement it this way for good reasons.  First, I wanted to
	     * avoid duplicating the (fairly complex) LWZ decoder in ReadImage.
	     * Fine, you say, why didn't you just modify it to allow the use of
	     * a NULL specifier for the output buffer?  I tried that, but it
	     * negatively impacted the performance of what I think will be the
	     * common case:  reading the first image in the file.  Rather than
	     * marginally improve the speed of the less frequent case, I chose
	     * to maintain high performance for the common case.
	     */
	    if (ReadImage(interp, (char *) trashBuffer, chan, fileWidth,
			  fileHeight, colorMap, 0, 0, 0, 0, 0, -1) != TCL_OK) {
	      goto error;
	    }
	    continue;
	}

	/* If a trash buffer has been allocated, free it now */
	if (trashBuffer != NULL) {
	    ckfree((char *)trashBuffer);
	    trashBuffer = NULL;
	}
a324 35

	index = LM_to_uint(buf[0],buf[1]);
	srcX -= index;
	if (srcX<0) {
	    destX -= srcX; width += srcX;
	    srcX = 0;
	}

	if (width > fileWidth) {
	    width = fileWidth;
	}

	index = LM_to_uint(buf[2],buf[3]);
	srcY -= index;
	if (index > srcY) {
	    destY -= srcY; height += srcY;
	    srcY = 0;
	}
	if (height > fileHeight) {
	    height = fileHeight;
	}

	if ((width <= 0) || (height <= 0)) {
	    block.pixelPtr = 0;
	    goto noerror;
	}

	block.width = width;
	block.height = height;
	block.pixelSize = (transparent>=0) ? 4 : 3;
	block.offset[3] = (transparent>=0) ? 3 : 0;
	block.pitch = block.pixelSize * width;
	nBytes = block.pitch * height;
	block.pixelPtr = (unsigned char *) ckalloc((unsigned) nBytes);

d331 1
a331 1
    }
d333 5
a337 1
    Tk_PhotoPutBlock(imageHandle, &block, destX, destY, width, height);
d339 24
a362 3
    noerror:
    if (block.pixelPtr) {
	ckfree((char *) block.pixelPtr);
d364 1
a364 1
    Tcl_AppendResult(interp, tkImgFmtGIF.name, (char *) NULL);
d368 1
a368 3
    if (block.pixelPtr) {
	ckfree((char *) block.pixelPtr);
    }
d392 1
a392 1
StringMatchGIF(dataObj, format, widthPtr, heightPtr, interp)
d394 1
a394 1
    Tcl_Obj *format;		/* the image format object, or NULL */
a396 1
    Tcl_Interp *interp;		/* not used */
d402 1
a402 1
    data = Tcl_GetByteArrayFromObj(dataObj, &length);
d411 2
a412 2
    if ((strncmp(GIF87a, (char *) data, 6) != 0) && 
	(strncmp(GIF89a, (char *) data, 6) != 0)) {
d417 2
a418 2
	      || ((strncmp(GIF87a, (char *) header, 6) != 0)
	      && (strncmp(GIF89a, (char *) header, 6) != 0))) {
d451 1
a451 1
StringReadGIF(interp, dataObj, format, imageHandle,
d455 1
a455 1
    Tcl_Obj *format;		/* format object, or NULL */
d461 21
a481 25
    int result;
    MFile handle;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    Tcl_Channel dataSrc;
    char *data;

    /*
     * Check whether the data is Base64 encoded
     */
    data = (char *) Tcl_GetByteArrayFromObj(dataObj, NULL);
    if ((strncmp(GIF87a, data, 6) != 0) && 
	    (strncmp(GIF89a, data, 6) != 0)) {
	mInit((unsigned char *)data, &handle);
	tsdPtr->fromData = 1;
	dataSrc = (Tcl_Channel) &handle;
    } else {
	tsdPtr->fromData = 2;
	mInit((unsigned char *)data, &handle);
	dataSrc = (Tcl_Channel) &handle;
    }
    result = FileReadGIF(interp, dataSrc, "inline data",
	    format, imageHandle, destX, destY, width, height, srcX, srcY);
    tsdPtr->fromData = 0;
    return(result);
d513 2
a514 2
	    || ((strncmp(GIF87a, (char *) buf, 6) != 0)
	    && (strncmp(GIF89a, (char *) buf, 6) != 0))) {
d548 4
a551 6
	    if (buffer) {
		buffer[i][CM_RED] = rgb[0] ;
		buffer[i][CM_GREEN] = rgb[1] ;
		buffer[i][CM_BLUE] = rgb[2] ;
		buffer[i][CM_ALPHA] = 255 ;
	    }
a623 28

/*
 *----------------------------------------------------------------------
 *
 * ReadImage --
 *
 *	Process a GIF image from a given source, with a given height,
 *      width, transparency, etc.
 *
 *      This code is based on the code found in the ImageMagick GIF decoder,
 *      which is (c) 2000 ImageMagick Studio.
 *
 *      Some thoughts on our implementation:
 *      It sure would be nice if ReadImage didn't take 11 parameters!  I think
 *      that if we were smarter, we could avoid doing that.
 *
 *      Possible further optimizations:  we could pull the GetCode function
 *      directly into ReadImage, which would improve our speed.
 *
 * Results:
 *	Processes a GIF image and loads the pixel data into a memory array.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

d637 1
a637 1
    unsigned char initialCodeSize;
d639 4
a642 11
    int xpos = 0, ypos = 0, pass = 0, i;
    register char *pixelPtr;
    CONST static int interlaceStep[] = { 8, 8, 4, 2 };
    CONST static int interlaceStart[] = { 0, 4, 2, 1 };
    unsigned short prefix[(1 << MAX_LWZ_BITS)];
    unsigned char  append[(1 << MAX_LWZ_BITS)];
    unsigned char  stack[(1 << MAX_LWZ_BITS)*2];
    register unsigned char *top;
    int codeSize, clearCode, inCode, endCode, oldCode, maxCode,
	code, firstCode;
    
d644 1
a644 1
     *  Initialize the decoder
d646 1
a646 1
    if (! ReadOK(chan, &initialCodeSize, 1))  {
d651 6
d665 1
d667 7
a673 45
    /* Initialize the decoder */
    /* Set values for "special" numbers:
     * clear code	reset the decoder
     * end code		stop decoding
     * code size	size of the next code to retrieve
     * max code		next available table position
     */
    clearCode   = 1 << (int) initialCodeSize;
    endCode     = clearCode + 1;
    codeSize    = (int) initialCodeSize + 1;
    maxCode     = clearCode + 2;
    oldCode     = -1;
    firstCode   = -1;
    
    memset((void *)prefix, 0, (1 << MAX_LWZ_BITS) * sizeof(short));
    memset((void *)append, 0, (1 << MAX_LWZ_BITS) * sizeof(char));
    for (i = 0; i < clearCode; i++) {
	append[i] = i;
    }
    top = stack;

    GetCode(chan, 0, 1);

    /* Read until we finish the image */
    for (i = 0, ypos = 0; i < rows; i++) {
	for (xpos = 0; xpos < len; ) {

	    if (top == stack) {
		/* Bummer -- our stack is empty.  Now we have to work! */
		code = GetCode(chan, codeSize, 0);
		if (code < 0) {
		    return TCL_OK;
		}

		if (code > maxCode || code == endCode) {
		    /*
		     * If we're doing things right, we should never
		     * receive a code that is greater than our current
		     * maximum code.  If we do, bail, because our decoder
		     * does not yet have that code set up.
		     *
		     * If the code is the magic endCode value, quit.
		     */
		    return TCL_OK;
		}
d675 12
a686 6
		if (code == clearCode) {
		    /* Reset the decoder */
		    codeSize    = initialCodeSize + 1;
		    maxCode     = clearCode + 2;
		    oldCode     = -1;
		    continue;
d689 12
a700 13
		if (oldCode == -1) {
		    /*
		     * Last pass reset the decoder, so the first code we
		     * see must be a singleton.  Seed the stack with it,
		     * and set up the old/first code pointers for
		     * insertion into the string table.  We can't just
		     * roll this into the clearCode test above, because
		     * at that point we have not yet read the next code.
		     */
		    *top++=append[code];
		    oldCode = code;
		    firstCode = code;
		    continue;
d702 34
a735 2
		
		inCode = code;
d737 1
a737 9
		if (code == maxCode) {
		    /*
		     * maxCode is always one bigger than our highest assigned
		     * code.  If the code we see is equal to maxCode, then
		     * we are about to add a new string to the table. ???
		     */
		    *top++ = firstCode;
		    code = oldCode;
		}
d739 1
a739 9
		while (code > clearCode) {
		    /*
		     * Populate the stack by tracing the string in the
		     * string table from its tail to its head
		     */
		    *top++ = append[code];
		    code = prefix[code];
		}
		firstCode = append[code];
d741 7
a747 7
		/*
		 * If there's no more room in our string table, quit.
		 * Otherwise, add a new string to the table
		 */
		if (maxCode >= (1 << MAX_LWZ_BITS)) {
		    return TCL_OK;
		}
d749 1
a749 2
		/* Push the head of the string onto the stack */
		*top++ = firstCode;
d751 22
a772 15
		/* Add a new string to the string table */
		prefix[maxCode] = oldCode;
		append[maxCode] = firstCode;
		maxCode++;

		/* maxCode tells us the maximum code value we can accept.
		 * If we see that we need more bits to represent it than
		 * we are requesting from the unpacker, we need to increase
		 * the number we ask for.
		 */
		if ((maxCode >= (1 << codeSize))
			&& (maxCode < (1<<MAX_LWZ_BITS))) {
		    codeSize++;
		}
		oldCode = inCode;
d775 13
a787 4
	    /* Pop the next color index off the stack */
	    v = *(--top);
	    if (v < 0) {
		return TCL_OK;
d789 3
d793 2
a794 10
	    /* 
	     * If pixelPtr is null, we're skipping this image (presumably
	     * there are more in the file and we will be called to read 
	     * one of them later)
	     */
	    *pixelPtr++ = cmap[v][CM_RED];
	    *pixelPtr++ = cmap[v][CM_GREEN];
	    *pixelPtr++ = cmap[v][CM_BLUE];
	    if (transparent >= 0) {
		*pixelPtr++ = cmap[v][CM_ALPHA];
d796 3
a798 1
	    xpos++;
d800 17
d819 9
a827 9
	/* If interlacing, the next ypos is not just +1 */
	if (interlace) {
	    ypos += interlaceStep[pass];
	    while (ypos >= height) {
		pass++;
		if (pass > 3) {
		    return TCL_OK;
		}
		ypos = interlaceStart[pass];
a828 2
	} else {
	    ypos++;
d830 7
a836 3
	pixelPtr = imagePtr + (ypos) * len * ((transparent>=0)?4:3);
    }
    return TCL_OK;
a838 29

/*
 *----------------------------------------------------------------------
 *
 * GetCode --
 *
 *      Extract the next compression code from the file.  In GIF's, the
 *      compression codes are between 3 and 12 bits long and are then
 *      packed into 8 bit bytes, left to right, for example:
 *                 bbbaaaaa
 *                 dcccccbb
 *                 eeeedddd
 *                 ...
 *      We use a byte buffer read from the file and a sliding window
 *      to unpack the bytes.  Thanks to ImageMagick for the sliding window
 *      idea.
 *      args:  chan         the channel to read from
 *             code_size    size of the code to extract
 *             flag         boolean indicating whether the extractor
 *                          should be reset or not
 *
 * Results:
 *	code                the next compression code
 *
 * Side effects:
 *	May consume more input from chan.
 *
 *----------------------------------------------------------------------
 */
d847 3
a849 2
    static int bytes = 0, done;
    static unsigned char *c;
a850 4
    static unsigned int window;
    static int bitsInWindow = 0;
    int ret;
    
d852 2
a853 4
	/* Initialize the decoder */
	bitsInWindow = 0;
	bytes = 0;
	window = 0;
a854 1
	c = NULL;
d858 2
a859 2
    while (bitsInWindow < code_size) {
	/* Not enough bits in our window to cover the request */
d861 1
d864 9
a872 8
	if (bytes == 0) {
	    /* Not enough bytes in our buffer to add to the window */
	    bytes = GetDataBlock(chan, buf);
	    c = buf;
	    if (bytes <= 0) {
		done = 1;
		break;
	    }
d874 4
a877 5
	/* Tack another byte onto the window, see if that's enough */
	window += (*c) << bitsInWindow;
	c++;
	bitsInWindow += 8;
	bytes--;
d880 7
a886 6
    /* The next code will always be the last code_size bits of the window */
    ret = window & ((1 << code_size) - 1);
    
    /* Shift data in the window to put the next code at the end */
    window >>= code_size;
    bitsInWindow -= code_size;
d1086 4
a1089 5
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    MFile *handle;

    switch (tsdPtr->fromData) {
d1094 1
a1094 1
	memcpy((VOID *)dst, (VOID *) handle->data, (size_t) (hunk * count));
a1096 2
      default:
	return Tcl_Read(chan, (char *) dst, (int) (hunk * count));
a1098 742


/*
 * ChanWriteGIF - writes a image in GIF format.
 *-------------------------------------------------------------------------
 * Author:          		Lolo
 *                              Engeneering Projects Area 
 *	            		Department of Mining 
 *                  		University of Oviedo
 * e-mail			zz11425958@@zeus.etsimo.uniovi.es
 *                  		lolo@@pcsig22.etsimo.uniovi.es
 * Date:            		Fri September 20 1996
 *
 * Modified for transparency handling (gif89a) and miGIF compression
 * by Jan Nijtmans <j.nijtmans@@chello.nl>
 *
 *----------------------------------------------------------------------
 * FileWriteGIF-
 *
 *    This procedure is called by the photo image type to write
 *    GIF format data from a photo image into a given file 
 *
 * Results:
 *	A standard TCL completion code.  If TCL_ERROR is returned
 *	then an error message is left in interp->result.
 *
 *----------------------------------------------------------------------
 */

 /*
  *  Types, defines and variables needed to write and compress a GIF.
  */

typedef int (* ifunptr) _ANSI_ARGS_((void));	

#define LSB(a)                  ((unsigned char) (((short)(a)) & 0x00FF))
#define MSB(a)                  ((unsigned char) (((short)(a)) >> 8))

#define GIFBITS 12
#define HSIZE  5003            /* 80% occupancy */

static int ssize;
static int csize;
static int rsize;
static unsigned char *pixelo;
static int pixelSize;
static int pixelPitch;
static int greenOffset;
static int blueOffset;
static int alphaOffset;
static int num;
static unsigned char mapa[MAXCOLORMAPSIZE][3];

/*
 *	Definition of new functions to write GIFs
 */

static int color _ANSI_ARGS_((int red,int green, int blue,
		unsigned char mapa[MAXCOLORMAPSIZE][3]));
static void compress _ANSI_ARGS_((int init_bits, Tcl_Channel handle,
		ifunptr readValue));
static int nuevo _ANSI_ARGS_((int red, int green ,int blue,
		unsigned char mapa[MAXCOLORMAPSIZE][3]));
static void savemap _ANSI_ARGS_((Tk_PhotoImageBlock *blockPtr,
		unsigned char mapa[MAXCOLORMAPSIZE][3]));
static int ReadValue _ANSI_ARGS_((void));

static int
FileWriteGIF (interp, filename, format, blockPtr)
    Tcl_Interp *interp;		/* Interpreter to use for reporting errors. */
    CONST char	*filename;
    Tcl_Obj	*format;
    Tk_PhotoImageBlock *blockPtr;
{
    Tcl_Channel chan = NULL;
    int result;

    chan = Tcl_OpenFileChannel(interp, (char *) filename, "w", 0644);
    if (!chan) {
	return TCL_ERROR;
    }
    if (Tcl_SetChannelOption(interp, chan, "-translation", "binary") != TCL_OK) {
	return TCL_ERROR;
    }

    result = CommonWriteGIF(interp, chan, format, blockPtr);
    if (Tcl_Close(interp, chan) == TCL_ERROR) {
	return TCL_ERROR;
    }
    return result;
}

#define Mputc(c,handle) Tcl_Write(handle,(char *) &c,1)

static int
CommonWriteGIF(interp, handle, format, blockPtr)
    Tcl_Interp *interp;
    Tcl_Channel handle;
    Tcl_Obj *format;
    Tk_PhotoImageBlock *blockPtr;
{
    int  resolution;

    long  width,height,x;
    unsigned char c;
    unsigned int top,left;

    top = 0;
    left = 0;

    pixelSize=blockPtr->pixelSize;
    greenOffset=blockPtr->offset[1]-blockPtr->offset[0];
    blueOffset=blockPtr->offset[2]-blockPtr->offset[0];
    alphaOffset = blockPtr->offset[0];
    if (alphaOffset < blockPtr->offset[2]) {
	alphaOffset = blockPtr->offset[2];
    }
    if (++alphaOffset < pixelSize) {
	alphaOffset -= blockPtr->offset[0];
    } else {
	alphaOffset = 0;
    }

    Tcl_Write(handle, (char *) (alphaOffset ? GIF89a : GIF87a), 6);

    for (x=0;x<MAXCOLORMAPSIZE;x++) {
	mapa[x][CM_RED] = 255;
	mapa[x][CM_GREEN] = 255;
	mapa[x][CM_BLUE] = 255;
    }


    width=blockPtr->width;
    height=blockPtr->height;
    pixelo=blockPtr->pixelPtr + blockPtr->offset[0];
    pixelPitch=blockPtr->pitch;
    savemap(blockPtr,mapa);
    if (num>=MAXCOLORMAPSIZE) {
	Tcl_AppendResult(interp, "too many colors", (char *) NULL);
	return TCL_ERROR;
    }
    if (num<2) num=2;
    c=LSB(width);
    Mputc(c,handle);
    c=MSB(width);
    Mputc(c,handle);
    c=LSB(height);
    Mputc(c,handle);
    c=MSB(height);
    Mputc(c,handle);

    resolution = 0;
    while (num >> resolution) {
	resolution++;
    }
    c = 111 + resolution * 17;
    Mputc(c,handle);

    num = 1 << resolution;

    /*  background color */

    c = 0;
    Mputc(c,handle);

    /*  zero for future expansion  */

    Mputc(c,handle);

    for (x=0; x<num ;x++) {
	c = mapa[x][CM_RED];
	Mputc(c,handle);
	c = mapa[x][CM_GREEN];
	Mputc(c,handle);
	c = mapa[x][CM_BLUE];
	Mputc(c,handle);
    }

    /*
     * Write out extension for transparent colour index, if necessary.
     */

    if (alphaOffset) {
	c = GIF_EXTENSION;
	Mputc(c, handle);
	Tcl_Write(handle, "\371\4\1\0\0\0", 7);
    }

    c = GIF_START;
    Mputc(c,handle);
    c=LSB(top);
    Mputc(c,handle);
    c=MSB(top);
    Mputc(c,handle);
    c=LSB(left);
    Mputc(c,handle);
    c=MSB(left);
    Mputc(c,handle);

    c=LSB(width);
    Mputc(c,handle);
    c=MSB(width);
    Mputc(c,handle);

    c=LSB(height);
    Mputc(c,handle);
    c=MSB(height);
    Mputc(c,handle);

    c=0;
    Mputc(c,handle);
    c=resolution;
    Mputc(c,handle);

    ssize = rsize = blockPtr->width;
    csize = blockPtr->height;
    compress(resolution+1, handle, ReadValue);

    c = 0; 
    Mputc(c,handle);
    c = GIF_TERMINATOR;
    Mputc(c,handle);

    return TCL_OK;	
}

static int
color(red, green, blue, mapa)
    int red;
    int green;
    int blue;
    unsigned char mapa[MAXCOLORMAPSIZE][3];
{
    int x;
    for (x=(alphaOffset != 0);x<=MAXCOLORMAPSIZE;x++) {
	if ((mapa[x][CM_RED]==red) && (mapa[x][CM_GREEN]==green) &&
		(mapa[x][CM_BLUE]==blue)) {
	    return x;
	}
    }
    return -1;
}


static int
nuevo(red, green, blue, mapa)
    int red,green,blue;
    unsigned char mapa[MAXCOLORMAPSIZE][3];
{
    int x;
    for (x=(alphaOffset != 0);x<=num;x++) {
	if ((mapa[x][CM_RED]==red) && (mapa[x][CM_GREEN]==green) &&
		(mapa[x][CM_BLUE]==blue)) {
	    return 0;
	}
    }
    return 1;
}

static void
savemap(blockPtr,mapa)
    Tk_PhotoImageBlock *blockPtr;
    unsigned char mapa[MAXCOLORMAPSIZE][3];
{
    unsigned char  *colores;
    int x,y;
    unsigned char  red,green,blue;

    if (alphaOffset) {
	num = 0;
	mapa[0][CM_RED] = 0xd9;
	mapa[0][CM_GREEN] = 0xd9;
	mapa[0][CM_BLUE] = 0xd9;
    } else {
	num = -1;
    }

    for(y=0;y<blockPtr->height;y++) {
	colores=blockPtr->pixelPtr + blockPtr->offset[0]
		+ y * blockPtr->pitch;
	for(x=0;x<blockPtr->width;x++) {
	    if (!alphaOffset || (colores[alphaOffset] != 0)) {
		red = colores[0];
		green = colores[greenOffset];
		blue = colores[blueOffset];
		if (nuevo(red,green,blue,mapa)) {
		    num++;
		    if (num>=MAXCOLORMAPSIZE) {
			return;
		    }
		    mapa[num][CM_RED]=red;
		    mapa[num][CM_GREEN]=green;
		    mapa[num][CM_BLUE]=blue;
		}
	    }
	    colores += pixelSize;
	}
    }
    return;
}

static int
ReadValue()
{
    unsigned int col;

    if (csize == 0) {
	return EOF;
    }
    if (alphaOffset && (pixelo[alphaOffset]==0)) {
	col = 0;
    } else {
	col = color(pixelo[0],pixelo[greenOffset],pixelo[blueOffset], mapa);
    }
    pixelo += pixelSize;
    if (--ssize <= 0) {
	ssize = rsize;
	csize--;
	pixelo += pixelPitch - (rsize * pixelSize);
    }

    return col;
}



/*-----------------------------------------------------------------------
 *
 * miGIF Compression - mouse and ivo's GIF-compatible compression
 *
 *          -run length encoding compression routines-
 *
 * Copyright (C) 1998 Hutchison Avenue Software Corporation
 *               http://www.hasc.com
 *               info@@hasc.com
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted, provided
 * that the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation.  This software is provided "AS IS." The Hutchison Avenue 
 * Software Corporation disclaims all warranties, either express or implied, 
 * including but not limited to implied warranties of merchantability and 
 * fitness for a particular purpose, with respect to this code and accompanying
 * documentation. 
 * 
 * The miGIF compression routines do not, strictly speaking, generate files 
 * conforming to the GIF spec, since the image data is not LZW-compressed 
 * (this is the point: in order to avoid transgression of the Unisys patent 
 * on the LZW algorithm.)  However, miGIF generates data streams that any 
 * reasonably sane LZW decompresser will decompress to what we want.
 *
 * miGIF compression uses run length encoding. It compresses horizontal runs 
 * of pixels of the same color. This type of compression gives good results
 * on images with many runs, for example images with lines, text and solid 
 * shapes on a solid-colored background. It gives little or no compression 
 * on images with few runs, for example digital or scanned photos.
 *
 *                               der Mouse
 *                      mouse@@rodents.montreal.qc.ca
 *            7D C8 61 52 5D E7 2D 39  4E F1 31 3E E8 B3 27 4B
 *
 *                             ivo@@hasc.com
 *
 * The Graphics Interchange Format(c) is the Copyright property of
 * CompuServe Incorporated.  GIF(sm) is a Service Mark property of
 * CompuServe Incorporated.
 *
 */

static int rl_pixel;
static int rl_basecode;
static int rl_count;
static int rl_table_pixel;
static int rl_table_max;
static int just_cleared;
static int out_bits;
static int out_bits_init;
static int out_count;
static int out_bump;
static int out_bump_init;
static int out_clear;
static int out_clear_init;
static int max_ocodes;
static int code_clear;
static int code_eof;
static unsigned int obuf;
static int obits;
static Tcl_Channel ofile;
static unsigned char oblock[256];
static int oblen;

/* Used only when debugging GIF compression code */
/* #define DEBUGGING_ENVARS */

#ifdef DEBUGGING_ENVARS

static int verbose_set = 0;
static int verbose;
#define VERBOSE (verbose_set?verbose:set_verbose())

static int set_verbose(void)
{
 verbose = !!getenv("GIF_VERBOSE");
 verbose_set = 1;
 return(verbose);
}

#else

#define VERBOSE 0

#endif


static CONST char *
binformat(v, nbits)
    unsigned int v;
    int nbits;
{
 static char bufs[8][64];
 static int bhand = 0;
 unsigned int bit;
 int bno;
 char *bp;

 bhand --;
 if (bhand < 0) bhand = (sizeof(bufs)/sizeof(bufs[0]))-1;
 bp = &bufs[bhand][0];
 for (bno=nbits-1,bit=((unsigned int)1)<<bno;bno>=0;bno--,bit>>=1)
  { *bp++ = (v & bit) ? '1' : '0';
    if (((bno&3) == 0) && (bno != 0)) *bp++ = '.';
  }
 *bp = '\0';
 return(&bufs[bhand][0]);
}

static void write_block()
{
 int i;
 unsigned char c;

 if (VERBOSE)
  { printf("write_block %d:",oblen);
    for (i=0;i<oblen;i++) printf(" %02x",oblock[i]);
    printf("\n");
  }
 c = oblen;
 Tcl_Write(ofile, (char *) &c, 1);
 Tcl_Write(ofile, (char *) &oblock[0], oblen);
 oblen = 0;
}

static void
block_out(c)
    unsigned char c;
{
 if (VERBOSE) printf("block_out %s\n",binformat(c,8));
 oblock[oblen++] = c;
 if (oblen >= 255) write_block();
}

static void block_flush()
{
 if (VERBOSE) printf("block_flush\n");
 if (oblen > 0) write_block();
}

static void output(val)
    int val;
{
 if (VERBOSE) printf("output %s [%s %d %d]\n",binformat(val,out_bits),binformat(obuf,obits),obits,out_bits);
 obuf |= val << obits;
 obits += out_bits;
 while (obits >= 8)
  { block_out(obuf&0xff);
    obuf >>= 8;
    obits -= 8;
  }
 if (VERBOSE) printf("output leaving [%s %d]\n",binformat(obuf,obits),obits);
}

static void output_flush()
{
 if (VERBOSE) printf("output_flush\n");
 if (obits > 0) block_out(obuf);
 block_flush();
}

static void did_clear()
{
 if (VERBOSE) printf("did_clear\n");
 out_bits = out_bits_init;
 out_bump = out_bump_init;
 out_clear = out_clear_init;
 out_count = 0;
 rl_table_max = 0;
 just_cleared = 1;
}

static void
output_plain(c)
    int c;
{
 if (VERBOSE) printf("output_plain %s\n",binformat(c,out_bits));
 just_cleared = 0;
 output(c);
 out_count ++;
 if (out_count >= out_bump)
  { out_bits ++;
    out_bump += 1 << (out_bits - 1);
  }
 if (out_count >= out_clear)
  { output(code_clear);
    did_clear();
  }
}

static unsigned int isqrt(x)
    unsigned int x;
{
 unsigned int r;
 unsigned int v;

 if (x < 2) return(x);
 for (v=x,r=1;v;v>>=2,r<<=1) ;
 while (1)
  { v = ((x / r) + r) / 2;
    if ((v == r) || (v == r+1)) return(r);
    r = v;
  }
}

static unsigned int
compute_triangle_count(count, nrepcodes)
    unsigned int count;
    unsigned int nrepcodes;
{
 unsigned int perrep;
 unsigned int cost;

 cost = 0;
 perrep = (nrepcodes * (nrepcodes+1)) / 2;
 while (count >= perrep)
  { cost += nrepcodes;
    count -= perrep;
  }
 if (count > 0)
  { unsigned int n;
    n = isqrt(count);
    while ((n*(n+1)) >= 2*count) n --;
    while ((n*(n+1)) < 2*count) n ++;
    cost += n;
  }
 return(cost);
}

static void max_out_clear()
{
 out_clear = max_ocodes;
}

static void reset_out_clear()
{
 out_clear = out_clear_init;
 if (out_count >= out_clear)
  { output(code_clear);
    did_clear();
  }
}

static void
rl_flush_fromclear(count)
    int count;
{
 int n;

 if (VERBOSE) printf("rl_flush_fromclear %d\n",count);
 max_out_clear();
 rl_table_pixel = rl_pixel;
 n = 1;
 while (count > 0)
  { if (n == 1)
     { rl_table_max = 1;
       output_plain(rl_pixel);
       count --;
     }
    else if (count >= n)
     { rl_table_max = n;
       output_plain(rl_basecode+n-2);
       count -= n;
     }
    else if (count == 1)
     { rl_table_max ++;
       output_plain(rl_pixel);
       count = 0;
     }
    else
     { rl_table_max ++;
       output_plain(rl_basecode+count-2);
       count = 0;
     }
    if (out_count == 0) n = 1; else n ++;
  }
 reset_out_clear();
 if (VERBOSE) printf("rl_flush_fromclear leaving table_max=%d\n",rl_table_max);
}

static void rl_flush_clearorrep(count)
    int count;
{
 int withclr;

 if (VERBOSE) printf("rl_flush_clearorrep %d\n",count);
 withclr = 1 + compute_triangle_count(count,max_ocodes);
 if (withclr < count)
  { output(code_clear);
    did_clear();
    rl_flush_fromclear(count);
  }
 else
  { for (;count>0;count--) output_plain(rl_pixel);
  }
}

static void rl_flush_withtable(count)
    int count;
{
 int repmax;
 int repleft;
 int leftover;

 if (VERBOSE) printf("rl_flush_withtable %d\n",count);
 repmax = count / rl_table_max;
 leftover = count % rl_table_max;
 repleft = (leftover ? 1 : 0);
 if (out_count+repmax+repleft > max_ocodes)
  { repmax = max_ocodes - out_count;
    leftover = count - (repmax * rl_table_max);
    repleft = 1 + compute_triangle_count(leftover,max_ocodes);
  }
 if (VERBOSE) printf("rl_flush_withtable repmax=%d leftover=%d repleft=%d\n",repmax,leftover,repleft);
 if (1+(int)compute_triangle_count(count,max_ocodes) < repmax+repleft)
  { output(code_clear);
    did_clear();
    rl_flush_fromclear(count);
    return;
  }
 max_out_clear();
 for (;repmax>0;repmax--) output_plain(rl_basecode+rl_table_max-2);
 if (leftover)
  { if (just_cleared)
     { rl_flush_fromclear(leftover);
     }
    else if (leftover == 1)
     { output_plain(rl_pixel);
     }
    else
     { output_plain(rl_basecode+leftover-2);
     }
  }
 reset_out_clear();
}

static void rl_flush()
{
 if (VERBOSE) printf("rl_flush [ %d %d\n",rl_count,rl_pixel);
 if (rl_count == 1)
  { output_plain(rl_pixel);
    rl_count = 0;
    if (VERBOSE) printf("rl_flush ]\n");
    return;
  }
 if (just_cleared)
  { rl_flush_fromclear(rl_count);
  }
 else if ((rl_table_max < 2) || (rl_table_pixel != rl_pixel))
  { rl_flush_clearorrep(rl_count);
  }
 else
  { rl_flush_withtable(rl_count);
  }
 if (VERBOSE) printf("rl_flush ]\n");
 rl_count = 0;
}


static void compress( init_bits, handle, readValue )
    int init_bits;
    Tcl_Channel handle;
    ifunptr readValue;
{
 int c;

 ofile = handle;
 obuf = 0;
 obits = 0;
 oblen = 0;
 code_clear = 1 << (init_bits - 1);
 code_eof = code_clear + 1;
 rl_basecode = code_eof + 1;
 out_bump_init = (1 << (init_bits - 1)) - 1;
 /* for images with a lot of runs, making out_clear_init larger will
    give better compression. */ 
 out_clear_init = (init_bits <= 3) ? 9 : (out_bump_init-1);
#ifdef DEBUGGING_ENVARS
  { const char *ocienv;
    ocienv = getenv("GIF_OUT_CLEAR_INIT");
    if (ocienv)
     { out_clear_init = atoi(ocienv);
       if (VERBOSE) printf("[overriding out_clear_init to %d]\n",out_clear_init);
     }
  }
#endif
 out_bits_init = init_bits;
 max_ocodes = (1 << GIFBITS) - ((1 << (out_bits_init - 1)) + 3);
 did_clear();
 output(code_clear);
 rl_count = 0;
 while (1)
  { c = readValue();
    if ((rl_count > 0) && (c != rl_pixel)) rl_flush();
    if (c == EOF) break;
    if (rl_pixel == c)
     { rl_count ++;
     }
    else
     { rl_pixel = c;
       rl_count = 1;
     }
  }
 output(code_eof);
 output_flush();
}

/*-----------------------------------------------------------------------
 *
 * End of miGIF section  - See copyright notice at start of section.
 *
 *-----------------------------------------------------------------------*/


@


1.1.1.3
log
@import tk 8.4.0
@
text
@d22 8
a29 8
 * +--------------------------------------------------------------------+
 * | Copyright 1990, David Koblas.					|
 * |   Permission to use, copy, modify, and distribute this software	|
 * |   and its documentation for any purpose and without fee is hereby	|
 * |   granted, provided that the above copyright notice appear in all	|
 * |   copies and that both that copyright notice and this permission	|
 * |   notice appear in supporting documentation.  This software is	|
 * |   provided "as is" without express or implied warranty.		|
d32 1
a32 1
 * RCS: @@(#) $Id: tkImgGIF.c,v 1.22 2002/08/08 09:35:08 hobbs Exp $
d44 1
a44 1
#define GIF_SPECIAL	(256)
d75 7
a81 9
static CONST char GIF87a[] = {			/* ASCII GIF87a */
    0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x00
};
static CONST char GIF89a[] = {			/* ASCII GIF89a */
    0x47, 0x49, 0x46, 0x38, 0x39, 0x61, 0x00
};
#  define GIF_TERMINATOR 0x3b			/* ASCII ; */
#  define GIF_EXTENSION  0x21			/* ASCII ! */
#  define GIF_START	 0x2c			/* ASCII , */
d99 1
a99 1
static int	FileMatchGIF _ANSI_ARGS_((Tcl_Channel chan, CONST char *fileName,
d102 1
a102 1
static int	FileReadGIF  _ANSI_ARGS_((Tcl_Interp *interp,
d121 7
a127 7
    "gif",		/* name */
    FileMatchGIF,	/* fileMatchProc */
    StringMatchGIF,	/* stringMatchProc */
    FileReadGIF,	/* fileReadProc */
    StringReadGIF,	/* stringReadProc */
    FileWriteGIF,	/* fileWriteProc */
    NULL,		/* stringWriteProc */
d139 1
a139 1
#define LM_to_uint(a,b)		(((b)<<8)|(a))
d219 1
a219 1
 *	then an error message is left in the interp's result.
d252 1
a252 1
    static CONST char *optionStrings[] = {
d291 1
a291 1
    if (BitSet(buf[0], LOCALCOLORMAP)) {	/* Global Colormap */
d348 2
a349 3
		Tcl_SetResult(interp,
			"error reading extension function code in GIF image",
			TCL_STATIC);
d353 1
a353 2
		Tcl_SetResult(interp, "error reading extension in GIF image",
			TCL_STATIC);
d367 1
a367 3
	    Tcl_SetResult(interp,
		    "couldn't read left/top/width/height in GIF image",
		    TCL_STATIC);
d377 1
a377 3
	    /*
	     * This is not the image we want to read: skip it.
	     */
d386 1
a386 3
	    /*
	     * If we've not yet allocated a trash buffer, do so now.
	     */
d394 2
a395 2
	     * Slurp!  Process the data for this image and stuff it in
	     * a trash buffer.
d397 10
a406 12
	     * Yes, it might be more efficient here to *not* store the
	     * data (we're just going to throw it away later).
	     * However, I elected to implement it this way for good
	     * reasons.  First, I wanted to avoid duplicating the
	     * (fairly complex) LWZ decoder in ReadImage.  Fine, you
	     * say, why didn't you just modify it to allow the use of
	     * a NULL specifier for the output buffer?  I tried that,
	     * but it negatively impacted the performance of what I
	     * think will be the common case: reading the first image
	     * in the file.  Rather than marginally improve the speed
	     * of the less frequent case, I chose to maintain high
	     * performance for the common case.
d409 2
a410 2
		    fileHeight, colorMap, 0, 0, 0, 0, 0, -1) != TCL_OK) {
		goto error;
d415 1
a415 3
	/*
	 * If a trash buffer has been allocated, free it now.
	 */
d458 2
a459 2
	block.pitch = block.pixelSize * fileWidth;
	nBytes = block.pitch * fileHeight;
d462 2
a463 2
	if (ReadImage(interp, (char *) block.pixelPtr, chan, fileWidth,
		fileHeight, colorMap, fileWidth, fileHeight, srcX, srcY,
d470 1
a470 2
    Tk_PhotoPutBlock(imageHandle, &block, destX, destY, width, height,
	    TK_PHOTO_COMPOSITE_SET);
d519 1
a519 3
    /*
     * Header is a minimum of 10 bytes.
     */
d521 1
a521 1
	return 0;
d524 1
a524 3
    /*
     * Check whether the data is Base64 encoded.
     */
d527 9
a535 11
	    (strncmp(GIF89a, (char *) data, 6) != 0)) {
	/*
	 * Try interpreting the data as Base64 encoded
	 */
	mInit((unsigned char *) data, &handle);
	got = Mread(header, 10, 1, &handle);
	if (got != 10
		|| ((strncmp(GIF87a, (char *) header, 6) != 0)
		&& (strncmp(GIF89a, (char *) header, 6) != 0))) {
	    return 0;
	}
d537 1
a537 1
	memcpy((VOID *) header, (VOID *) data, 10);
d555 1
a555 1
 *	then an error message is left in the interp's result.
d573 1
a573 1
    int width, height;		/*   image to copy */
d579 1
a579 1
	    Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
d587 2
a588 1
    if ((strncmp(GIF87a, data, 6) != 0) && (strncmp(GIF89a, data, 6) != 0)) {
d600 1
a600 1
    return result;
d655 18
a672 17
    Tcl_Channel chan;
    int number;
    unsigned char buffer[MAXCOLORMAPSIZE][4];
{
    int i;
    unsigned char rgb[3];

    for (i = 0; i < number; ++i) {
	if (! ReadOK(chan, rgb, sizeof(rgb))) {
	    return 0;
	}

	if (buffer) {
	    buffer[i][CM_RED] = rgb[0] ;
	    buffer[i][CM_GREEN] = rgb[1] ;
	    buffer[i][CM_BLUE] = rgb[2] ;
	    buffer[i][CM_ALPHA] = 255 ;
d674 1
a674 2
    }
    return 1;
d681 3
a683 3
    Tcl_Channel chan;
    int label;
    int *transparent;
d689 5
a693 2
    case 0x01:		/* Plain Text Extension */
	break;
d695 5
a699 2
    case 0xff:		/* Application Extension */
	break;
d701 1
a701 2
    case 0xfe:		/* Comment Extension */
	do {
d703 6
a708 11
	} while (count > 0);
	return count;

    case 0xf9:		/* Graphic Control Extension */
	count = GetDataBlock(chan, (unsigned char*) buf);
	if (count < 0) {
	    return 1;
	}
	if ((buf[0] & 0x1) != 0) {
	    *transparent = buf[3];
	}
d710 4
a713 4
	do {
	    count = GetDataBlock(chan, (unsigned char*) buf);
	} while (count > 0);
	return count;
d726 2
a727 2
    Tcl_Channel chan;
    unsigned char *buf;
d752 1
a752 1
 *	width, transparency, etc.
d754 2
a755 2
 *	This code is based on the code found in the ImageMagick GIF decoder,
 *	which is (c) 2000 ImageMagick Studio.
d757 3
a759 3
 *	Some thoughts on our implementation:
 *	It sure would be nice if ReadImage didn't take 11 parameters!  I think
 *	that if we were smarter, we could avoid doing that.
d761 2
a762 2
 *	Possible further optimizations:  we could pull the GetCode function
 *	directly into ReadImage, which would improve our speed.
d776 9
a784 9
    Tcl_Interp *interp;
    char *imagePtr;
    Tcl_Channel chan;
    int len, rows;
    unsigned char cmap[MAXCOLORMAPSIZE][4];
    int width, height;
    int srcX, srcY;
    int interlace;
    int transparent;
d796 3
a798 3
    int codeSize, clearCode, inCode, endCode, oldCode, maxCode;
    int code, firstCode;

d807 1
a807 1
    if (transparent != -1) {
d816 2
a817 4
    /*
     * Initialize the decoder.
     *
     * Set values for "special" numbers:
d823 6
a828 6
    clearCode = 1 << (int) initialCodeSize;
    endCode = clearCode + 1;
    codeSize = (int) initialCodeSize + 1;
    maxCode = clearCode + 2;
    oldCode = -1;
    firstCode = -1;
d839 1
a839 3
    /*
     * Read until we finish the image
     */
d844 1
a844 3
		/*
		 * Bummer -- our stack is empty.  Now we have to work!
		 */
d863 4
a866 6
		    /*
		     * Reset the decoder.
		     */
		    codeSize = initialCodeSize + 1;
		    maxCode = clearCode + 2;
		    oldCode = -1;
d879 1
a879 1
		    *top++ = append[code];
d915 1
a915 3
		/*
		 * Push the head of the string onto the stack.
		 */
d918 1
a918 3
		/*
		 * Add a new string to the string table
		 */
d923 1
a923 2
		/*
		 * maxCode tells us the maximum code value we can accept.
d935 1
a935 3
	    /*
	     * Pop the next color index off the stack.
	     */
d956 1
a956 3
	/*
	 * If interlacing, the next ypos is not just +1
	 */
d980 14
a993 14
 *	Extract the next compression code from the file.  In GIF's, the
 *	compression codes are between 3 and 12 bits long and are then
 *	packed into 8 bit bytes, left to right, for example:
 *		bbbaaaaa
 *		dcccccbb
 *		eeeedddd
 *		...
 *	We use a byte buffer read from the file and a sliding window
 *	to unpack the bytes.  Thanks to ImageMagick for the sliding window
 *	idea.
 *	args:  chan	    the channel to read from
 *	       code_size    size of the code to extract
 *	       flag	    boolean indicating whether the extractor
 *			    should be reset or not
d996 1
a996 1
 *	code		    the next compression code
d1006 3
a1008 3
    Tcl_Channel chan;
    int code_size;
    int flag;
d1019 1
a1019 3
	/*
	 * Initialize the decoder.
	 */
d1029 1
a1029 3
	/*
	 * Not enough bits in our window to cover the request.
	 */
d1034 1
a1034 3
	    /*
	     * Not enough bytes in our buffer to add to the window.
	     */
d1042 1
a1042 3
	/*
	 * Tack another byte onto the window, see if that's enough.
	 */
d1049 1
a1049 4

    /*
     * The next code will always be the last code_size bits of the window.
     */
d1052 1
a1052 3
    /*
     * Shift data in the window to put the next code at the end.
     */
d1142 1
a1142 1
   MFile *handle;		/* Handle containing decoder data and state */
d1147 1
a1147 1

d1149 1
a1149 1
	return GIF_DONE;
d1155 1
a1155 1
    } while (c == GIF_SPACE);
d1159 1
a1159 1
	return handle->c;
d1163 16
a1178 16
    case 0:
	handle->c = c<<2;
	result = Mgetc(handle);
	break;
    case 1:
	result = handle->c | (c>>4);
	handle->c = (c&0xF)<<4;
	break;
    case 2:
	result = handle->c | (c>>2);
	handle->c = (c&0x3) << 6;
	break;
    case 3:
	result = handle->c | c;
	handle->state = 0;
	break;
d1180 1
a1180 1
    return result;
d1205 27
a1231 31
    case 'A': return 0;  case 'B': return 1;  case 'C': return 2;
    case 'D': return 3;  case 'E': return 4;  case 'F': return 5;
    case 'G': return 6;  case 'H': return 7;  case 'I': return 8;
    case 'J': return 9;  case 'K': return 10; case 'L': return 11;
    case 'M': return 12; case 'N': return 13; case 'O': return 14;
    case 'P': return 15; case 'Q': return 16; case 'R': return 17;
    case 'S': return 18; case 'T': return 19; case 'U': return 20;
    case 'V': return 21; case 'W': return 22; case 'X': return 23;
    case 'Y': return 24; case 'Z': return 25; case 'a': return 26;
    case 'b': return 27; case 'c': return 28; case 'd': return 29;
    case 'e': return 30; case 'f': return 31; case 'g': return 32;
    case 'h': return 33; case 'i': return 34; case 'j': return 35;
    case 'k': return 36; case 'l': return 37; case 'm': return 38;
    case 'n': return 39; case 'o': return 40; case 'p': return 41;
    case 'q': return 42; case 'r': return 43; case 's': return 44;
    case 't': return 45; case 'u': return 46; case 'v': return 47;
    case 'w': return 48; case 'x': return 49; case 'y': return 50;
    case 'z': return 51; case '0': return 52; case '1': return 53;
    case '2': return 54; case '3': return 55; case '4': return 56;
    case '5': return 57; case '6': return 58; case '7': return 59;
    case '8': return 60; case '9': return 61; case '+': return 62;
    case '/': return 63;

    case ' ': case '\t': case '\n': case '\r': case '\f':
	return GIF_SPACE;
    case '=':
	return GIF_PAD;
    case '\0':
	return GIF_DONE;
    default:
	return GIF_BAD;
d1255 1
a1255 1
	    Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
d1259 3
a1261 3
    case 1:
	return Mread(dst, hunk, count, (MFile *) chan);
    case 2:
d1265 2
a1266 2
	return (int)(hunk * count);
    default:
d1275 4
a1278 4
 * Author:			Lolo
 *				Engeneering Projects Area 
 *				Department of Mining 
 *				University of Oviedo
d1280 2
a1281 2
 *				lolo@@pcsig22.etsimo.uniovi.es
 * Date:			Fri September 20 1996
d1305 2
a1306 2
#define LSB(a)			((unsigned char) (((short)(a)) & 0x00FF))
#define MSB(a)			((unsigned char) (((short)(a)) >> 8))
d1309 1
a1309 1
#define HSIZE  5003		/* 80% occupancy */
d1338 1
a1338 1
FileWriteGIF(interp, filename, format, blockPtr)
a1351 1
	Tcl_Close(NULL, chan);
d1380 3
a1382 3
    pixelSize = blockPtr->pixelSize;
    greenOffset = blockPtr->offset[1]-blockPtr->offset[0];
    blueOffset = blockPtr->offset[2]-blockPtr->offset[0];
d1395 1
a1395 1
    for (x=0 ; x<MAXCOLORMAPSIZE ; x++) {
d1402 4
a1405 4
    width = blockPtr->width;
    height = blockPtr->height;
    pixelo = blockPtr->pixelPtr + blockPtr->offset[0];
    pixelPitch = blockPtr->pitch;
d1407 1
a1407 1
    if (num >= MAXCOLORMAPSIZE) {
d1411 2
a1412 4
    if (num<2) {
	num = 2;
    }
    c = LSB(width);
d1414 1
a1414 1
    c = MSB(width);
d1416 1
a1416 1
    c = LSB(height);
d1418 1
a1418 1
    c = MSB(height);
d1430 1
a1430 3
    /*
     * background color
     */
d1435 1
a1435 3
    /*
     * zero for future expansion.
     */
d1439 1
a1439 1
    for (x=0 ; x<num ; x++) {
d1460 1
a1460 1
    c = LSB(top);
d1462 1
a1462 1
    c = MSB(top);
d1464 1
a1464 1
    c = LSB(left);
d1466 1
a1466 1
    c = MSB(left);
d1469 1
a1469 1
    c = LSB(width);
d1471 1
a1471 1
    c = MSB(width);
d1474 1
a1474 1
    c = LSB(height);
d1476 1
a1476 1
    c = MSB(height);
d1479 1
a1479 1
    c = 0;
d1481 1
a1481 1
    c = resolution;
d1504 3
a1506 3
    for (x=(alphaOffset != 0) ; x<=MAXCOLORMAPSIZE ; x++) {
	if ((mapa[x][CM_RED] == red) && (mapa[x][CM_GREEN] == green) &&
		(mapa[x][CM_BLUE] == blue)) {
d1519 4
a1522 4
    int x = (alphaOffset != 0);
    for (; x<=num ; x++) {
	if ((mapa[x][CM_RED] == red) && (mapa[x][CM_GREEN] == green) &&
		(mapa[x][CM_BLUE] == blue)) {
d1534 1
a1534 1
    unsigned char *colores;
d1536 1
a1536 1
    unsigned char red,green,blue;
d1547 2
a1548 2
    for(y=0 ; y<blockPtr->height ; y++) {
	colores = blockPtr->pixelPtr + blockPtr->offset[0]
d1550 1
a1550 1
	for(x=0 ; x<blockPtr->width ; x++) {
d1557 1
a1557 1
		    if (num >= MAXCOLORMAPSIZE) {
d1560 3
a1562 3
		    mapa[num][CM_RED] = red;
		    mapa[num][CM_GREEN] = green;
		    mapa[num][CM_BLUE] = blue;
d1579 1
a1579 1
    if (alphaOffset && (pixelo[alphaOffset] == 0)) {
d1582 1
a1582 1
	col = color(pixelo[0], pixelo[greenOffset], pixelo[blueOffset], mapa);
d1596 1
a1596 2
/*
 *-----------------------------------------------------------------------
d1600 1
a1600 1
 *		-run length encoding compression routines-
d1603 2
a1604 2
 *		 http://www.hasc.com
 *		 info@@hasc.com
d1606 9
a1614 10
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby
 * granted, provided that the above copyright notice appear in all
 * copies and that both that copyright notice and this permission
 * notice appear in supporting documentation.  This software is
 * provided "AS IS." The Hutchison Avenue Software Corporation
 * disclaims all warranties, either express or implied, including but
 * not limited to implied warranties of merchantability and fitness
 * for a particular purpose, with respect to this code and
 * accompanying documentation.
d1616 15
a1630 17
 * The miGIF compression routines do not, strictly speaking, generate
 * files conforming to the GIF spec, since the image data is not
 * LZW-compressed (this is the point: in order to avoid transgression
 * of the Unisys patent on the LZW algorithm.)  However, miGIF
 * generates data streams that any reasonably sane LZW decompresser
 * will decompress to what we want.
 *
 * miGIF compression uses run length encoding. It compresses
 * horizontal runs of pixels of the same color. This type of
 * compression gives good results on images with many runs, for
 * example images with lines, text and solid shapes on a solid-colored
 * background. It gives little or no compression on images with few
 * runs, for example digital or scanned photos.
 *
 *				 der Mouse
 *			mouse@@rodents.montreal.qc.ca
 *	      7D C8 61 52 5D E7 2D 39  4E F1 31 3E E8 B3 27 4B
d1632 1
a1632 1
 *			       ivo@@hasc.com
a1637 1
 *-----------------------------------------------------------------------
d1662 2
a1663 4
/*
 * Used only when debugging GIF compression code
 */
/* #define MIGIF_DEBUGGING_ENVARS */
d1665 1
a1665 1
#ifdef MIGIF_DEBUGGING_ENVARS
d1669 1
a1669 2
#define MIGIF_VERBOSE (verbose_set?verbose:set_verbose())
#define DEBUGMSG(printf_args) if (MIGIF_VERBOSE) { printf printf_args; }
d1671 1
a1671 12
static int
set_verbose(void)
{
    verbose = !!getenv("MIGIF_VERBOSE");
    verbose_set = 1;
    return verbose;
}

static CONST char *
binformat(v, nbits)
    unsigned int v;
    int nbits;
d1673 3
a1675 19
    static char bufs[8][64];
    static int bhand = 0;
    unsigned int bit;
    int bno;
    char *bp;

    bhand--;
    if (bhand < 0) {
	bhand = (sizeof(bufs) / sizeof(bufs[0])) - 1;
    }
    bp = &bufs[bhand][0];
    for (bno=nbits-1,bit=((unsigned int)1)<<bno ; bno>=0 ; bno--,bit>>=1) {
	*bp++ = (v & bit) ? '1' : '0';
	if (((bno&3) == 0) && (bno != 0)) {
	    *bp++ = '.';
	}
    }
    *bp = '\0';
    return &bufs[bhand][0];
d1680 1
a1680 2
#define MIGIF_VERBOSE 0
#define DEBUGMSG(printf_args) /* do nothing */
d1684 5
a1688 2
static void
write_block()
d1690 31
a1720 14
    int i;
    unsigned char c;

    if (MIGIF_VERBOSE) {
	printf("write_block %d:", oblen);
	for (i=0 ; i<oblen ; i++) {
	    printf(" %02x", oblock[i]);
	}
	printf("\n");
    }
    c = oblen;
    Tcl_Write(ofile, (char *) &c, 1);
    Tcl_Write(ofile, (char *) &oblock[0], oblen);
    oblen = 0;
d1727 3
a1729 5
    DEBUGMSG(("block_out %s\n", binformat(c, 8)));
    oblock[oblen++] = c;
    if (oblen >= 255) {
	write_block();
    }
d1732 1
a1732 2
static void
block_flush()
d1734 2
a1735 4
    DEBUGMSG(("block_flush\n"));
    if (oblen > 0) {
	write_block();
    }
d1738 1
a1738 2
static void
output(val)
d1741 27
a1767 32
    DEBUGMSG(("output %s [%s %d %d]\n", binformat(val, out_bits),
	    binformat(obuf, obits), obits, out_bits));
    obuf |= val << obits;
    obits += out_bits;
    while (obits >= 8) {
	block_out(obuf&0xff);
	obuf >>= 8;
	obits -= 8;
    }
    DEBUGMSG(("output leaving [%s %d]\n", binformat(obuf, obits), obits));
}

static void
output_flush()
{
    DEBUGMSG(("output_flush\n"));
    if (obits > 0) {
	block_out(obuf);
    }
    block_flush();
}

static void
did_clear()
{
    DEBUGMSG(("did_clear\n"));
    out_bits = out_bits_init;
    out_bump = out_bump_init;
    out_clear = out_clear_init;
    out_count = 0;
    rl_table_max = 0;
    just_cleared = 1;
d1774 12
a1785 12
    DEBUGMSG(("output_plain %s\n", binformat(c, out_bits)));
    just_cleared = 0;
    output(c);
    out_count++;
    if (out_count >= out_bump) {
	out_bits++;
	out_bump += 1 << (out_bits - 1);
    }
    if (out_count >= out_clear) {
	output(code_clear);
	did_clear();
    }
d1788 1
a1788 2
static unsigned int
isqrt(x)
d1791 2
a1792 2
    unsigned int r;
    unsigned int v;
d1794 7
a1800 11
    if (x < 2) {
	return x;
    }
    for (v=x,r=1 ; v ; v>>=2,r<<=1);
    while (1) {
	v = ((x / r) + r) / 2;
	if (v==r || v==r+1) {
	    return r;
	}
	r = v;
    }
d1808 2
a1809 2
    unsigned int perrep;
    unsigned int cost;
d1811 28
a1838 34
    cost = 0;
    perrep = (nrepcodes * (nrepcodes+1)) / 2;
    while (count >= perrep) {
	cost += nrepcodes;
	count -= perrep;
    }
    if (count > 0) {
	unsigned int n;
	n = isqrt(count);
	while (n*(n+1) >= 2*count) {
	    n--;
	}
	while (n*(n+1) < 2*count) {
	    n++;
	}
	cost += n;
    }
    return cost;
}

static void
max_out_clear()
{
    out_clear = max_ocodes;
}

static void
reset_out_clear()
{
    out_clear = out_clear_init;
    if (out_count >= out_clear) {
	output(code_clear);
	did_clear();
    }
d1845 1
a1845 1
    int n;
d1847 29
a1875 30
    DEBUGMSG(("rl_flush_fromclear %d\n", count));
    max_out_clear();
    rl_table_pixel = rl_pixel;
    n = 1;
    while (count > 0) {
	if (n == 1) {
	    rl_table_max = 1;
	    output_plain(rl_pixel);
	    count--;
	} else if (count >= n) {
	    rl_table_max = n;
	    output_plain(rl_basecode+n-2);
	    count -= n;
	} else if (count == 1) {
	    rl_table_max++;
	    output_plain(rl_pixel);
	    count = 0;
	} else {
	    rl_table_max++;
	    output_plain(rl_basecode+count-2);
	    count = 0;
	}
	if (out_count == 0) {
	    n = 1;
	} else {
	    n++;
	}
    }
    reset_out_clear();
    DEBUGMSG(("rl_flush_fromclear leaving table_max=%d\n", rl_table_max));
d1878 1
a1878 2
static void
rl_flush_clearorrep(count)
d1881 1
a1881 1
    int withclr;
d1883 10
a1892 11
    DEBUGMSG(("rl_flush_clearorrep %d\n", count));
    withclr = 1 + compute_triangle_count(count, max_ocodes);
    if (withclr < count) {
	output(code_clear);
	did_clear();
	rl_flush_fromclear(count);
    } else {
	for (; count>0 ; count--) {
	    output_plain(rl_pixel);
	}
    }
d1895 1
a1895 2
static void
rl_flush_withtable(count)
d1898 41
a1938 55
    int repmax;
    int repleft;
    int leftover;

    DEBUGMSG(("rl_flush_withtable %d\n", count));
    repmax = count / rl_table_max;
    leftover = count % rl_table_max;
    repleft = (leftover ? 1 : 0);
    if (out_count+repmax+repleft > max_ocodes) {
	repmax = max_ocodes - out_count;
	leftover = count - (repmax * rl_table_max);
	repleft = 1 + compute_triangle_count(leftover, max_ocodes);
    }
    DEBUGMSG(("rl_flush_withtable repmax=%d leftover=%d repleft=%d\n",
	    repmax, leftover, repleft));
    if (1+(int)compute_triangle_count(count, max_ocodes) < repmax+repleft) {
	output(code_clear);
	did_clear();
	rl_flush_fromclear(count);
	return;
    }
    max_out_clear();
    for (; repmax>0 ; repmax--) {
	output_plain(rl_basecode + rl_table_max - 2);
    }
    if (leftover) {
	if (just_cleared) {
	    rl_flush_fromclear(leftover);
	} else if (leftover == 1) {
	    output_plain(rl_pixel);
	} else {
	    output_plain(rl_basecode + leftover - 2);
	}
    }
    reset_out_clear();
}

static void
rl_flush()
{
    DEBUGMSG(("rl_flush [ %d %d\n", rl_count, rl_pixel));
    if (rl_count == 1) {
	output_plain(rl_pixel);
	rl_count = 0;
	DEBUGMSG(("rl_flush ]\n"));
	return;
    }
    if (just_cleared) {
	rl_flush_fromclear(rl_count);
    } else if ((rl_table_max < 2) || (rl_table_pixel != rl_pixel)) {
	rl_flush_clearorrep(rl_count);
    } else {
	rl_flush_withtable(rl_count);
    }
    DEBUGMSG(("rl_flush ]\n"));
d1940 14
d1957 1
a1957 2
static void
compress(init_bits, handle, readValue)
d1962 1
a1962 1
    int c;
d1964 19
a1982 22
    ofile = handle;
    obuf = 0;
    obits = 0;
    oblen = 0;
    code_clear = 1 << (init_bits - 1);
    code_eof = code_clear + 1;
    rl_basecode = code_eof + 1;
    out_bump_init = (1 << (init_bits - 1)) - 1;
    /*
     * For images with a lot of runs, making out_clear_init larger
     * will give better compression.
     */
    out_clear_init = (init_bits <= 3) ? 9 : (out_bump_init-1);
#ifdef MIGIF_DEBUGGING_ENVARS
    {
	const char *ocienv;
	ocienv = getenv("MIGIF_OUT_CLEAR_INIT");
	if (ocienv) {
	    out_clear_init = atoi(ocienv);
	    DEBUGMSG(("[overriding out_clear_init to %d]\n", out_clear_init));
	}
    }
d1984 19
a2002 22
    out_bits_init = init_bits;
    max_ocodes = (1 << GIFBITS) - ((1 << (out_bits_init - 1)) + 3);
    did_clear();
    output(code_clear);
    rl_count = 0;
    while (1) {
	c = readValue();
	if ((rl_count > 0) && (c != rl_pixel)) {
	    rl_flush();
	}
	if (c == EOF) {
	    break;
	}
	if (rl_pixel == c) {
	    rl_count++;
	} else {
	    rl_pixel = c;
	    rl_count = 1;
	}
    }
    output(code_eof);
    output_flush();
d2005 1
a2005 2
/*
 *-----------------------------------------------------------------------
d2009 3
a2011 2
 *-----------------------------------------------------------------------
 */
@


