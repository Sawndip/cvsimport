head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.20.24.44;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.13;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.24;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.50;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.31;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.12;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@/* 
 * tkFrame.c --
 *
 *	This module implements "frame", "labelframe" and "toplevel" widgets
 *      for the Tk toolkit.  Frames are windows with a background color
 *	and possibly a 3-D effect, but not much else in the way of
 *	attributes.
 *
 * Copyright (c) 1990-1994 The Regents of the University of California.
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkFrame.c,v 1.13 2002/08/05 04:30:38 dgp Exp $
 */

#include "default.h"
#include "tkPort.h"
#include "tkInt.h"

/*
 * The following enum is used to define the type of the frame.
 */

enum FrameType {
    TYPE_FRAME, TYPE_TOPLEVEL, TYPE_LABELFRAME
};

/*
 * A data structure of the following type is kept for each
 * frame that currently exists for this process:
 */

typedef struct {
    Tk_Window tkwin;		/* Window that embodies the frame.  NULL
				 * means that the window has been destroyed
				 * but the data structures haven't yet been
				 * cleaned up. */
    Display *display;		/* Display containing widget.  Used, among
				 * other things, so that resources can be
				 * freed even after tkwin has gone away. */
    Tcl_Interp *interp;		/* Interpreter associated with widget.  Used
				 * to delete widget command. */
    Tcl_Command widgetCmd;	/* Token for frame's widget command. */
    Tk_OptionTable optionTable;	/* Table that defines configuration options
				 * available for this widget. */
    char *className;		/* Class name for widget (from configuration
				 * option).  Malloc-ed. */
    enum FrameType type;	/* Type of widget, such as TYPE_FRAME. */
    char *screenName;		/* Screen on which widget is created.  Non-null
				 * only for top-levels.  Malloc-ed, may be
				 * NULL. */
    char *visualName;		/* Textual description of visual for window,
				 * from -visual option.  Malloc-ed, may be
				 * NULL. */
    char *colormapName;		/* Textual description of colormap for window,
				 * from -colormap option.  Malloc-ed, may be
				 * NULL. */
    char *menuName;		/* Textual description of menu to use for
				 * menubar. Malloc-ed, may be NULL. */
    Colormap colormap;		/* If not None, identifies a colormap
				 * allocated for this window, which must be
				 * freed when the window is deleted. */
    Tk_3DBorder border;		/* Structure used to draw 3-D border and
				 * background.  NULL means no background
				 * or border. */
    int borderWidth;		/* Width of 3-D border (if any). */
    int relief;			/* 3-d effect: TK_RELIEF_RAISED etc. */
    int highlightWidth;		/* Width in pixels of highlight to draw
				 * around widget when it has the focus.
				 * 0 means don't draw a highlight. */
    XColor *highlightBgColorPtr;
				/* Color for drawing traversal highlight
				 * area when highlight is off. */
    XColor *highlightColorPtr;	/* Color for drawing traversal highlight. */
    int width;			/* Width to request for window.  <= 0 means
				 * don't request any size. */
    int height;			/* Height to request for window.  <= 0 means
				 * don't request any size. */
    Tk_Cursor cursor;		/* Current cursor for window, or None. */
    char *takeFocus;		/* Value of -takefocus option;  not used in
				 * the C code, but used by keyboard traversal
				 * scripts.  Malloc'ed, but may be NULL. */
    int isContainer;		/* 1 means this window is a container, 0 means
				 * that it isn't. */
    char *useThis;		/* If the window is embedded, this points to
				 * the name of the window in which it is
				 * embedded (malloc'ed).  For non-embedded
				 * windows this is NULL. */
    int flags;			/* Various flags;  see below for
				 * definitions. */
    Tcl_Obj *padXPtr;		/* Value of -padx option: specifies how many
				 * pixels of extra space to leave on left and
				 * right of child area. */
    int padX;			/* Integer value corresponding to padXPtr. */
    Tcl_Obj *padYPtr;		/* Value of -padx option: specifies how many
				 * pixels of extra space to leave above and
				 * below child area. */
    int padY;			/* Integer value corresponding to padYPtr. */
} Frame;

/*
 * A data structure of the following type is kept for each labelframe
 * widget managed by this file:
 */

typedef struct {
    Frame frame;		/* A pointer to the generic frame structure.
				 * This must be the first element of the
				 * Labelframe. */

    /*
     * Labelframe specific configuration settings.
     */

    Tcl_Obj *textPtr;		/* Value of -text option: specifies text to
				 * display in button. */
    Tk_Font tkfont;		/* Value of -font option: specifies font
				 * to use for display text. */
    XColor *textColorPtr;	/* Value of -fg option: specifies foreground
				 * color in normal mode. */
    int labelAnchor;		/* Value of -labelanchor option: specifies
				 * where to place the label. */
    Tk_Window labelWin;		/* Value of -labelwidget option: Window to
                                 * use as label for the frame. */

    /*
     * Labelframe specific fields for use with configuration settings above.
     */

    GC textGC;			/* GC for drawing text in normal mode. */
    Tk_TextLayout textLayout;	/* Stored text layout information. */
    XRectangle labelBox;	/* The label's actual size and position. */
    int labelReqWidth;		/* The label's requested width. */
    int labelReqHeight;		/* The label's requested height. */
    int labelTextX, labelTextY;	/* Position of the text to be drawn. */

} Labelframe;

/*
 * The following macros define how many extra pixels to leave
 * around a label's text.
 */

#define LABELSPACING 1
#define LABELMARGIN 4

/*
 * Flag bits for frames:
 *
 * REDRAW_PENDING:		Non-zero means a DoWhenIdle handler
 *				has already been queued to redraw
 *				this window.
 * GOT_FOCUS:			Non-zero means this widget currently
 *				has the input focus.
 */

#define REDRAW_PENDING		1
#define GOT_FOCUS		4

/*
 * The following enum is used to define a type for the -labelanchor option
 * of the Labelframe widget.  These values are used as indices into the 
 * string table below.
 */

enum labelanchor {
    LABELANCHOR_E, LABELANCHOR_EN, LABELANCHOR_ES,
    LABELANCHOR_N, LABELANCHOR_NE, LABELANCHOR_NW,
    LABELANCHOR_S, LABELANCHOR_SE, LABELANCHOR_SW,
    LABELANCHOR_W, LABELANCHOR_WN, LABELANCHOR_WS
};

static char *labelAnchorStrings[] = {
    "e", "en", "es", "n", "ne", "nw", "s", "se", "sw", "w", "wn", "ws",
    (char *) NULL
};

/*
 * Information used for parsing configuration options.  There are
 * one common table used by all and one table for each widget class.
 */

static Tk_OptionSpec commonOptSpec[] = {
    {TK_OPTION_BORDER, "-background", "background", "Background",
	DEF_FRAME_BG_COLOR, -1, Tk_Offset(Frame, border),
	TK_OPTION_NULL_OK, (ClientData) DEF_FRAME_BG_MONO, 0},
    {TK_OPTION_SYNONYM, "-bg", (char *) NULL, (char *) NULL,
	(char *) NULL, 0, -1, 0, (ClientData) "-background", 0},
    {TK_OPTION_STRING, "-colormap", "colormap", "Colormap",
	DEF_FRAME_COLORMAP, -1, Tk_Offset(Frame, colormapName),
	TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_BOOLEAN, "-container", "container", "Container",
	DEF_FRAME_CONTAINER, -1, Tk_Offset(Frame, isContainer),
	0, 0, 0},
    {TK_OPTION_CURSOR, "-cursor", "cursor", "Cursor",
	DEF_FRAME_CURSOR, -1, Tk_Offset(Frame, cursor),
	TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_PIXELS, "-height", "height", "Height",
	DEF_FRAME_HEIGHT, -1, Tk_Offset(Frame, height),
	0, 0, 0},
    {TK_OPTION_COLOR, "-highlightbackground", "highlightBackground",
	"HighlightBackground", DEF_FRAME_HIGHLIGHT_BG, -1,
	Tk_Offset(Frame, highlightBgColorPtr), 0, 0, 0},
    {TK_OPTION_COLOR, "-highlightcolor", "highlightColor", "HighlightColor",
	DEF_FRAME_HIGHLIGHT, -1, Tk_Offset(Frame, highlightColorPtr),
	0, 0, 0},
    {TK_OPTION_PIXELS, "-highlightthickness", "highlightThickness",
	"HighlightThickness", DEF_FRAME_HIGHLIGHT_WIDTH, -1,
	Tk_Offset(Frame, highlightWidth), 0, 0, 0},
    {TK_OPTION_PIXELS, "-padx", "padX", "Pad",
	DEF_FRAME_PADX, Tk_Offset(Frame, padXPtr),
	Tk_Offset(Frame, padX), 0, 0, 0},
    {TK_OPTION_PIXELS, "-pady", "padY", "Pad",
	DEF_FRAME_PADY, Tk_Offset(Frame, padYPtr),
	Tk_Offset(Frame, padY), 0, 0, 0},
    {TK_OPTION_STRING, "-takefocus", "takeFocus", "TakeFocus",
	DEF_FRAME_TAKE_FOCUS, -1, Tk_Offset(Frame, takeFocus),
	TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_STRING, "-visual", "visual", "Visual",
	DEF_FRAME_VISUAL, -1, Tk_Offset(Frame, visualName),
	TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_PIXELS, "-width", "width", "Width",
	DEF_FRAME_WIDTH, -1, Tk_Offset(Frame, width),
	0, 0, 0},
    {TK_OPTION_END, (char *) NULL, (char *) NULL, (char *) NULL,
	(char *) NULL, 0, 0, 0, 0, 0}
};

static Tk_OptionSpec frameOptSpec[] = {
    {TK_OPTION_SYNONYM, "-bd", (char *) NULL, (char *) NULL,
	(char *) NULL, 0, -1, 0, (ClientData) "-borderwidth", 0},
    {TK_OPTION_PIXELS, "-borderwidth", "borderWidth", "BorderWidth",
	DEF_FRAME_BORDER_WIDTH, -1, Tk_Offset(Frame, borderWidth),
        0, 0, 0},
    {TK_OPTION_STRING, "-class", "class", "Class",
	DEF_FRAME_CLASS, -1, Tk_Offset(Frame, className),
	0, 0, 0},
    {TK_OPTION_RELIEF, "-relief", "relief", "Relief",
	DEF_FRAME_RELIEF, -1, Tk_Offset(Frame, relief),
	0, 0, 0},
    {TK_OPTION_END, (char *) NULL, (char *) NULL, (char *) NULL,
	(char *) NULL, 0, 0, 0, (ClientData) commonOptSpec, 0}
};

static Tk_OptionSpec toplevelOptSpec[] = {
    {TK_OPTION_SYNONYM, "-bd", (char *) NULL, (char *) NULL,
	(char *) NULL, 0, -1, 0, (ClientData) "-borderwidth", 0},
    {TK_OPTION_PIXELS, "-borderwidth", "borderWidth", "BorderWidth",
	DEF_FRAME_BORDER_WIDTH, -1, Tk_Offset(Frame, borderWidth),
        0, 0, 0},
    {TK_OPTION_STRING, "-class", "class", "Class",
	DEF_TOPLEVEL_CLASS, -1, Tk_Offset(Frame, className),
	0, 0, 0},
    {TK_OPTION_STRING, "-menu", "menu", "Menu",
	DEF_TOPLEVEL_MENU, -1, Tk_Offset(Frame, menuName),
	TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_RELIEF, "-relief", "relief", "Relief",
	DEF_FRAME_RELIEF, -1, Tk_Offset(Frame, relief),
	0, 0, 0},
    {TK_OPTION_STRING, "-screen", "screen", "Screen",
	DEF_TOPLEVEL_SCREEN, -1, Tk_Offset(Frame, screenName),
	TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_STRING, "-use", "use", "Use",
	DEF_TOPLEVEL_USE, -1, Tk_Offset(Frame, useThis),
	TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_END, (char *) NULL, (char *) NULL, (char *) NULL,
	(char *) NULL, 0, 0, 0, (ClientData) commonOptSpec, 0}
};

static Tk_OptionSpec labelframeOptSpec[] = {
    {TK_OPTION_SYNONYM, "-bd", (char *) NULL, (char *) NULL,
	(char *) NULL, 0, -1, 0, (ClientData) "-borderwidth", 0},
    {TK_OPTION_PIXELS, "-borderwidth", "borderWidth", "BorderWidth",
	DEF_LABELFRAME_BORDER_WIDTH, -1, Tk_Offset(Frame, borderWidth),
        0, 0, 0},
    {TK_OPTION_STRING, "-class", "class", "Class",
	DEF_LABELFRAME_CLASS, -1, Tk_Offset(Frame, className),
	0, 0, 0},
    {TK_OPTION_SYNONYM, "-fg", "foreground", (char *) NULL,
	(char *) NULL, 0, -1, 0, (ClientData) "-foreground", 0},
    {TK_OPTION_FONT, "-font", "font", "Font",
	DEF_LABELFRAME_FONT, -1, Tk_Offset(Labelframe, tkfont), 0, 0, 0},
    {TK_OPTION_COLOR, "-foreground", "foreground", "Foreground",
	DEF_LABELFRAME_FG, -1, Tk_Offset(Labelframe, textColorPtr), 0, 0, 0},
    {TK_OPTION_STRING_TABLE, "-labelanchor", "labelAnchor", "LabelAnchor",
	DEF_LABELFRAME_LABELANCHOR, -1, Tk_Offset(Labelframe, labelAnchor),
        0, (ClientData) labelAnchorStrings, 0},
    {TK_OPTION_WINDOW, "-labelwidget", "labelWidget", "LabelWidget",
        (char *) NULL, -1, Tk_Offset(Labelframe, labelWin),
        TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_RELIEF, "-relief", "relief", "Relief",
	DEF_LABELFRAME_RELIEF, -1, Tk_Offset(Frame, relief),
	0, 0, 0},
    {TK_OPTION_STRING, "-text", "text", "Text",
	DEF_LABELFRAME_TEXT, Tk_Offset(Labelframe, textPtr), -1,
	TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_END, (char *) NULL, (char *) NULL, (char *) NULL,
	(char *) NULL, 0, 0, 0, (ClientData) commonOptSpec, 0}
};

/*
 * Class names for widgets, indexed by FrameType.
 */

static char *classNames[] = {"Frame", "Toplevel", "Labelframe"};

/*
 * The following table maps from FrameType to the option template for
 * that class of widgets.
 */

static Tk_OptionSpec *optionSpecs[] = {
    frameOptSpec,
    toplevelOptSpec,
    labelframeOptSpec,
};

/*
 * Forward declarations for procedures defined later in this file:
 */

static void		ComputeFrameGeometry _ANSI_ARGS_((Frame *framePtr));
static int		ConfigureFrame _ANSI_ARGS_((Tcl_Interp *interp,
			    Frame *framePtr, int objc, Tcl_Obj *CONST objv[]));
static int		CreateFrame _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, int objc, Tcl_Obj *CONST argv[],
			    enum FrameType type, char *appName));
static void		DestroyFrame _ANSI_ARGS_((char *memPtr));
static void		DestroyFramePartly _ANSI_ARGS_((Frame *framePtr));
static void		DisplayFrame _ANSI_ARGS_((ClientData clientData));
static void		FrameCmdDeletedProc _ANSI_ARGS_((
			    ClientData clientData));
static void		FrameEventProc _ANSI_ARGS_((ClientData clientData,
			    XEvent *eventPtr));
static void		FrameLostSlaveProc _ANSI_ARGS_((
			    ClientData clientData, Tk_Window tkwin));
static void		FrameRequestProc _ANSI_ARGS_((ClientData clientData,
			    Tk_Window tkwin));
static void		FrameStructureProc _ANSI_ARGS_((
			    ClientData clientData, XEvent *eventPtr));
static int		FrameWidgetObjCmd _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
static void		FrameWorldChanged _ANSI_ARGS_((
			    ClientData instanceData));
static void		MapFrame _ANSI_ARGS_((ClientData clientData));

/*
 * The structure below defines frame class behavior by means of procedures
 * that can be invoked from generic window code.
 */

static Tk_ClassProcs frameClass = {
    sizeof(Tk_ClassProcs),	/* size */
    FrameWorldChanged		/* worldChangedProc */
};

/*
 * The structure below defines the official type record for the
 * labelframe's geometry manager:
 */

static Tk_GeomMgr frameGeomType = {
    "labelframe",			/* name */
    FrameRequestProc,			/* requestProc */
    FrameLostSlaveProc			/* lostSlaveProc */
};


/*
 *--------------------------------------------------------------
 *
 * Tk_FrameObjCmd, Tk_ToplevelObjCmd, Tk_LabelframeObjCmd --
 *
 *	These procedures are invoked to process the "frame",
 *      "toplevel" and "labelframe" Tcl commands.  See the user
 *      documentation for details on what they do.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.  These procedures are just wrappers;
 *	they call CreateFrame to do all of the real work.
 *
 *--------------------------------------------------------------
 */

int
Tk_FrameObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Either NULL or pointer to option table. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    return CreateFrame(clientData, interp, objc, objv, TYPE_FRAME,
	    (char *) NULL);
}

int
Tk_ToplevelObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Either NULL or pointer to option table. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    return CreateFrame(clientData, interp, objc, objv, TYPE_TOPLEVEL,
	    (char *) NULL);
}

int
Tk_LabelframeObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Either NULL or pointer to option table. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    return CreateFrame(clientData, interp, objc, objv, TYPE_LABELFRAME,
	    (char *) NULL);
}

/*
 *--------------------------------------------------------------
 *
 * TkCreateFrame --
 *
 *	This procedure is the old command procedure for the "frame"
 *      and "toplevel" commands.  Now it is used directly by Tk_Init to
 *      create a new main window.  See the user documentation for the
 *      "frame" and "toplevel" commands for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *--------------------------------------------------------------
 */

int
TkCreateFrame(clientData, interp, argc, argv, toplevel, appName)
    ClientData clientData;	/* Either NULL or pointer to option table. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int argc;			/* Number of arguments. */
    char **argv;		/* Argument strings. */
    int toplevel;		/* Non-zero means create a toplevel window,
				 * zero means create a frame. */
    char *appName;		/* Should only be non-NULL if there is no main
				 * window associated with the interpreter.
				 * Gives the base name to use for the
				 * new application. */
{
    int result, i;
    Tcl_Obj **objv = (Tcl_Obj **) ckalloc((argc+1) * sizeof(Tcl_Obj **));
    for (i=0; i<argc; i++) {
	objv[i] = Tcl_NewStringObj(argv[i], -1);
	Tcl_IncrRefCount(objv[i]);
    }
    objv[argc] = NULL;
    result = CreateFrame(clientData, interp, argc, objv,
	    toplevel ? TYPE_TOPLEVEL : TYPE_FRAME, appName);
    for (i=0; i<argc; i++) {
	Tcl_DecrRefCount(objv[i]);
    }
    ckfree((char *) objv);
    return result;
}

static int
CreateFrame(clientData, interp, objc, objv, type, appName)
    ClientData clientData;	/* NULL. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
    enum FrameType type;	/* What widget type to create. */
    char *appName;		/* Should only be non-NULL if there are no
				 * Main window associated with the interpreter.
				 * Gives the base name to use for the
				 * new application. */
{
    Tk_Window tkwin;
    Frame *framePtr;
    Tk_OptionTable optionTable;
    Tk_Window new;
    CONST char *className, *screenName, *visualName, *colormapName, *arg, *useOption;
    int i, c, depth;
    size_t length;
    unsigned int mask;
    Colormap colormap;
    Visual *visual;

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "pathName ?options?");
	return TCL_ERROR;
    }

    /*
     * Create the option table for this widget class.  If it has already
     * been created, the cached pointer will be returned.
     */

    optionTable = Tk_CreateOptionTable(interp, optionSpecs[type]);

    /*
     * Pre-process the argument list.  Scan through it to find any
     * "-class", "-screen", "-visual", and "-colormap" options.  These
     * arguments need to be processed specially, before the window
     * is configured using the usual Tk mechanisms.
     */

    className = colormapName = screenName = visualName = useOption = NULL;
    colormap = None;
    for (i = 2; i < objc; i += 2) {
	arg = Tcl_GetStringFromObj(objv[i], (int *) &length);
	if (length < 2) {
	    continue;
	}
	c = arg[1];
	if ((c == 'c') && (strncmp(arg, "-class", length) == 0)
		&& (length >= 3)) {
	    className = Tcl_GetString(objv[i+1]);
	} else if ((c == 'c')
		&& (strncmp(arg, "-colormap", length) == 0)) {
	    colormapName = Tcl_GetString(objv[i+1]);
	} else if ((c == 's') && (type == TYPE_TOPLEVEL)
		&& (strncmp(arg, "-screen", length) == 0)) {
	    screenName = Tcl_GetString(objv[i+1]);
	} else if ((c == 'u') && (type == TYPE_TOPLEVEL)
		&& (strncmp(arg, "-use", length) == 0)) {
	    useOption = Tcl_GetString(objv[i+1]);
	} else if ((c == 'v')
		&& (strncmp(arg, "-visual", length) == 0)) {
	    visualName = Tcl_GetString(objv[i+1]);
	}
    }

    /*
     * Create the window, and deal with the special options -use,
     * -classname, -colormap, -screenname, and -visual.  These options
     * must be handle before calling ConfigureFrame below, and they must
     * also be processed in a particular order, for the following
     * reasons:
     * 1. Must set the window's class before calling ConfigureFrame,
     *    so that unspecified options are looked up in the option
     *    database using the correct class.
     * 2. Must set visual information before calling ConfigureFrame
     *    so that colors are allocated in a proper colormap.
     * 3. Must call TkpUseWindow before setting non-default visual
     *    information, since TkpUseWindow changes the defaults.
     */

    if (screenName == NULL) {
	screenName = (type == TYPE_TOPLEVEL) ? "" : NULL;
    }

    /*
     * Main window associated with interpreter.
     * If we're called by Tk_Init to create a
     * new application, then this is NULL.
     */

    tkwin = Tk_MainWindow(interp);
    if (tkwin != NULL) {
	new = Tk_CreateWindowFromPath(interp, tkwin, Tcl_GetString(objv[1]),
		screenName);
    } else {
	/*
	 * We were called from Tk_Init;  create a new application.
	 */

	if (appName == NULL) {
	    panic("TkCreateFrame didn't get application name");
	}
	new = TkCreateMainWindow(interp, screenName, appName);
    }
    if (new == NULL) {
	goto error;
    }
    if (className == NULL) {
	className = Tk_GetOption(new, "class", "Class");
	if (className == NULL) {
	    className = classNames[type];
	}
    }
    Tk_SetClass(new, className);
    if (useOption == NULL) {
	useOption = Tk_GetOption(new, "use", "Use");
    }
    if (useOption != NULL) {
	if (TkpUseWindow(interp, new, useOption) != TCL_OK) {
	    goto error;
	}
    }
    if (visualName == NULL) {
	visualName = Tk_GetOption(new, "visual", "Visual");
    }
    if (colormapName == NULL) {
	colormapName = Tk_GetOption(new, "colormap", "Colormap");
    }
    if (visualName != NULL) {
	visual = Tk_GetVisual(interp, new, visualName, &depth,
		(colormapName == NULL) ? &colormap : (Colormap *) NULL);
	if (visual == NULL) {
	    goto error;
	}
	Tk_SetWindowVisual(new, visual, depth, colormap);
    }
    if (colormapName != NULL) {
	colormap = Tk_GetColormap(interp, new, colormapName);
	if (colormap == None) {
	    goto error;
	}
	Tk_SetWindowColormap(new, colormap);
    }

    /*
     * For top-level windows, provide an initial geometry request of
     * 200x200,  just so the window looks nicer on the screen if it
     * doesn't request a size for itself.
     */

    if (type == TYPE_TOPLEVEL) {
	Tk_GeometryRequest(new, 200, 200);
    }

    /*
     * Create the widget record, process configuration options, and
     * create event handlers.  Then fill in a few additional fields
     * in the widget record from the special options.
     */

    if (type == TYPE_LABELFRAME) {
	framePtr = (Frame *) ckalloc(sizeof(Labelframe));
	memset((void *) framePtr, 0, (sizeof(Labelframe)));
    } else {
	framePtr = (Frame *) ckalloc(sizeof(Frame));
	memset((void *) framePtr, 0, (sizeof(Frame)));
    }
    framePtr->tkwin		= new;
    framePtr->display		= Tk_Display(new);
    framePtr->interp		= interp;
    framePtr->widgetCmd		= Tcl_CreateObjCommand(interp,
	    Tk_PathName(new), FrameWidgetObjCmd,
	    (ClientData) framePtr, FrameCmdDeletedProc);
    framePtr->optionTable = optionTable;
    framePtr->type = type;
    framePtr->colormap = colormap;
    framePtr->relief = TK_RELIEF_FLAT;
    framePtr->cursor = None;

    if (framePtr->type == TYPE_LABELFRAME) {
	Labelframe *labelframePtr = (Labelframe *) framePtr;
	labelframePtr->labelAnchor = LABELANCHOR_NW;
	labelframePtr->textGC = None;
    }

    /*
     * Store backreference to frame widget in window structure.
     */
    Tk_SetClassProcs(new, &frameClass, (ClientData) framePtr);

    mask = ExposureMask | StructureNotifyMask | FocusChangeMask;
    if (type == TYPE_TOPLEVEL) {
        mask |= ActivateMask;
    }
    Tk_CreateEventHandler(new, mask, FrameEventProc, (ClientData) framePtr);
    if ((Tk_InitOptions(interp, (char *) framePtr, optionTable, new)
	    != TCL_OK) ||
	    (ConfigureFrame(interp, framePtr, objc-2, objv+2) != TCL_OK)) {
	goto error;
    }
    if ((framePtr->isContainer)) {
	if (framePtr->useThis == NULL) {
	    TkpMakeContainer(framePtr->tkwin);
	} else {
	    Tcl_AppendResult(interp, "A window cannot have both the -use ",
		    "and the -container option set.", (char *) NULL);
	    goto error;
	}
    }
    if (type == TYPE_TOPLEVEL) {
	Tcl_DoWhenIdle(MapFrame, (ClientData) framePtr);
    }
    Tcl_SetResult(interp, Tk_PathName(new), TCL_STATIC);
    return TCL_OK;

    error:
    if (new != NULL) {
	Tk_DestroyWindow(new);
    }
    return TCL_ERROR;
}

/*
 *--------------------------------------------------------------
 *
 * FrameWidgetObjCmd --
 *
 *	This procedure is invoked to process the Tcl command
 *	that corresponds to a frame widget.  See the user
 *	documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *--------------------------------------------------------------
 */

static int
FrameWidgetObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Information about frame widget. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    static CONST char *frameOptions[] = {
	"cget", "configure", (char *) NULL
    };
    enum options {
	FRAME_CGET, FRAME_CONFIGURE
    };
    register Frame *framePtr = (Frame *) clientData;
    int result = TCL_OK, index;
    size_t length;
    int c, i;
    Tcl_Obj *objPtr;

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "option ?arg arg ...?");
	return TCL_ERROR;
    }
    if (Tcl_GetIndexFromObj(interp, objv[1], frameOptions, "option", 0,
	    &index) != TCL_OK) {
	return TCL_ERROR;
    }
    Tcl_Preserve((ClientData) framePtr);
    switch ((enum options) index) {
      case FRAME_CGET: {
	if (objc != 3) {
	    Tcl_WrongNumArgs(interp, 2, objv, "option");
	    result = TCL_ERROR;
	    goto done;
	}
        objPtr = Tk_GetOptionValue(interp, (char *) framePtr,
		framePtr->optionTable, objv[2], framePtr->tkwin);
        if (objPtr == NULL) {
	    result = TCL_ERROR;
	    goto done;
        } else {
	    Tcl_SetObjResult(interp, objPtr);
        }
	break;
      }
      case FRAME_CONFIGURE: {
	if (objc <= 3) {
	    objPtr = Tk_GetOptionInfo(interp, (char *) framePtr,
		    framePtr->optionTable,
		    (objc == 3) ? objv[2] : (Tcl_Obj *) NULL,
		    framePtr->tkwin);
	    if (objPtr == NULL) {
		result = TCL_ERROR;
		goto done;
	    } else {
		Tcl_SetObjResult(interp, objPtr);
	    }
	} else {
	    /*
	     * Don't allow the options -class, -colormap, -container,
	     * -newcmap, -screen, -use, or -visual to be changed.
	     */

	    for (i = 2; i < objc; i++) {
		char *arg = Tcl_GetStringFromObj(objv[i], (int *) &length);
		if (length < 2) {
		    continue;
		}
		c = arg[1];
		if (((c == 'c') && (strncmp(arg, "-class", length) == 0)
			&& (length >= 2))
			|| ((c == 'c')
			&& (strncmp(arg, "-colormap", length) == 0)
			&& (length >= 3))
			|| ((c == 'c')
			&& (strncmp(arg, "-container", length) == 0)
			&& (length >= 3))
			|| ((c == 's') && (framePtr->type == TYPE_TOPLEVEL)
			&& (strncmp(arg, "-screen", length) == 0))
			|| ((c == 'u') && (framePtr->type == TYPE_TOPLEVEL)
			&& (strncmp(arg, "-use", length) == 0))
			|| ((c == 'v')
			&& (strncmp(arg, "-visual", length) == 0))) {
		    Tcl_AppendResult(interp, "can't modify ", arg,
			    " option after widget is created", (char *) NULL);
		    result = TCL_ERROR;
		    goto done;
		}
	    }
	    result = ConfigureFrame(interp, framePtr, objc-2, objv+2);
	}
	break;
      }
    }

    done:
    Tcl_Release((ClientData) framePtr);
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * DestroyFrame --
 *
 *	This procedure is invoked by Tcl_EventuallyFree or Tcl_Release
 *	to clean up the internal structure of a frame at a safe time
 *	(when no-one is using it anymore).
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Everything associated with the frame is freed up.
 *
 *----------------------------------------------------------------------
 */

static void
DestroyFrame(memPtr)
    char *memPtr;		/* Info about frame widget. */
{
    register Frame *framePtr = (Frame *) memPtr;
    register Labelframe *labelframePtr = (Labelframe *) memPtr;

    if (framePtr->type == TYPE_LABELFRAME) {
	Tk_FreeTextLayout(labelframePtr->textLayout);
	if (labelframePtr->textGC != None) {
	    Tk_FreeGC(framePtr->display, labelframePtr->textGC);
	}
    }
    if (framePtr->colormap != None) {
	Tk_FreeColormap(framePtr->display, framePtr->colormap);
    }
    ckfree((char *) framePtr);
}

/*
 *----------------------------------------------------------------------
 *
 * DestroyFramePartly --
 *
 *	This procedure is invoked to clean up everything that needs
 *      tkwin to be defined when deleted.  During the destruction
 *      process tkwin is always set to NULL and this procedure must
 *      be called before that happens.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Some things associated with the frame are freed up.
 *
 *----------------------------------------------------------------------
 */

static void
DestroyFramePartly(framePtr)
    Frame *framePtr;		/* Info about frame widget. */
{
    register Labelframe *labelframePtr = (Labelframe *) framePtr;

    if (framePtr->type == TYPE_LABELFRAME && labelframePtr->labelWin != NULL) {
	Tk_DeleteEventHandler(labelframePtr->labelWin, StructureNotifyMask,
		FrameStructureProc, (ClientData) framePtr);
	Tk_ManageGeometry(labelframePtr->labelWin, (Tk_GeomMgr *) NULL,
		(ClientData) NULL);
	if (framePtr->tkwin != Tk_Parent(labelframePtr->labelWin)) {
	    Tk_UnmaintainGeometry(labelframePtr->labelWin, framePtr->tkwin);
	}
	Tk_UnmapWindow(labelframePtr->labelWin);
	labelframePtr->labelWin = NULL;
    }

    Tk_FreeConfigOptions((char *) framePtr, framePtr->optionTable,
            framePtr->tkwin);
}

/*
 *----------------------------------------------------------------------
 *
 * ConfigureFrame --
 *
 *	This procedure is called to process an objv/objc list, plus
 *	the Tk option database, in order to configure (or
 *	reconfigure) a frame widget.
 *
 * Results:
 *	The return value is a standard Tcl result.  If TCL_ERROR is
 *	returned, then the interp's result contains an error message.
 *
 * Side effects:
 *	Configuration information, such as text string, colors, font,
 *	etc. get set for framePtr;  old resources get freed, if there
 *	were any.
 *
 *----------------------------------------------------------------------
 */

static int
ConfigureFrame(interp, framePtr, objc, objv)
    Tcl_Interp *interp;		/* Used for error reporting. */
    register Frame *framePtr;	/* Information about widget;  may or may
				 * not already have values for some fields. */
    int objc;			/* Number of valid entries in objv. */
    Tcl_Obj *CONST objv[];	/* Arguments. */
{
    Tk_SavedOptions savedOptions;
    char *oldMenuName;
    Tk_Window oldWindow = NULL;
    Labelframe *labelframePtr = (Labelframe *) framePtr;

    /*
     * Need the old menubar name for the menu code to delete it.
     */
    
    if (framePtr->menuName == NULL) {
    	oldMenuName = NULL;
    } else {
    	oldMenuName = ckalloc(strlen(framePtr->menuName) + 1);
    	strcpy(oldMenuName, framePtr->menuName);
    }

    if (framePtr->type == TYPE_LABELFRAME) {
	oldWindow = labelframePtr->labelWin;
    }
    if (Tk_SetOptions(interp, (char *) framePtr,
	    framePtr->optionTable, objc, objv,
	    framePtr->tkwin, &savedOptions, (int *) NULL) != TCL_OK) {
	if (oldMenuName != NULL) {
	    ckfree(oldMenuName);
	}
	return TCL_ERROR;
    } else {
	Tk_FreeSavedOptions(&savedOptions);
    }

    /*
     * A few of the options require additional processing.
     */

    if (((oldMenuName == NULL) && (framePtr->menuName != NULL))
	    || ((oldMenuName != NULL) && (framePtr->menuName == NULL))
	    || ((oldMenuName != NULL) && (framePtr->menuName != NULL)
	    && strcmp(oldMenuName, framePtr->menuName) != 0)) {
	TkSetWindowMenuBar(interp, framePtr->tkwin, oldMenuName,
		framePtr->menuName);
    }

    if (oldMenuName != NULL) {
    	ckfree(oldMenuName);
    }

    if (framePtr->border != NULL) {
	Tk_SetBackgroundFromBorder(framePtr->tkwin, framePtr->border);
    } else {
	Tk_SetWindowBackgroundPixmap(framePtr->tkwin, None);
    }

    if (framePtr->highlightWidth < 0) {
	framePtr->highlightWidth = 0;
    }
    if (framePtr->padX < 0) {
	framePtr->padX = 0;
    }
    if (framePtr->padY < 0) {
	framePtr->padY = 0;
    }

    /*
     * If a -labelwidget is specified, check that it is valid and set
     * up geometry management for it.
     */

    if (framePtr->type == TYPE_LABELFRAME) {
	if (oldWindow != labelframePtr->labelWin) {
	    if (oldWindow != NULL) {
		Tk_DeleteEventHandler(oldWindow, StructureNotifyMask,
			FrameStructureProc, (ClientData) framePtr);
		Tk_ManageGeometry(oldWindow, (Tk_GeomMgr *) NULL,
			(ClientData) NULL);
		Tk_UnmaintainGeometry(oldWindow, framePtr->tkwin);
		Tk_UnmapWindow(oldWindow);
	    }
	    if (labelframePtr->labelWin != NULL) {
		Tk_Window ancestor, parent, sibling = NULL;

		/*
		 * Make sure that the frame is either the parent of the
		 * window used as label or a descendant of that
		 * parent.  Also, don't allow a top-level window to be
		 * managed inside the frame.
		 */

		parent = Tk_Parent(labelframePtr->labelWin);
		for (ancestor = framePtr->tkwin; ;
		     ancestor = Tk_Parent(ancestor)) {
		    if (ancestor == parent) {
			break;
		    }
		    sibling = ancestor;
		    if (Tk_IsTopLevel(ancestor)) {
			badWindow:
			Tcl_AppendResult(interp, "can't use ",
				Tk_PathName(labelframePtr->labelWin),
				" as label in this frame", (char *) NULL);
			labelframePtr->labelWin = NULL;
			return TCL_ERROR;
		    }
		}
		if (Tk_IsTopLevel(labelframePtr->labelWin)) {
		    goto badWindow;
		}
		if (labelframePtr->labelWin == framePtr->tkwin) {
		    goto badWindow;
		}
		Tk_CreateEventHandler(labelframePtr->labelWin,
			StructureNotifyMask, FrameStructureProc,
			(ClientData) framePtr);
		Tk_ManageGeometry(labelframePtr->labelWin, &frameGeomType,
			(ClientData) framePtr);

		/*
		 * If the frame is not parent to the label, make
		 * sure the label is above its sibling in the stacking
		 * order.
		 */

		if (sibling != NULL) {
		    Tk_RestackWindow(labelframePtr->labelWin, Above, sibling);
		}
	    }
	}
    }

    FrameWorldChanged((ClientData) framePtr);

    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * FrameWorldChanged --
 *
 *      This procedure is called when the world has changed in some
 *      way and the widget needs to recompute all its graphics contexts
 *	and determine its new geometry.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Frame will be relayed out and redisplayed.
 *
 *---------------------------------------------------------------------------
 */
 
static void
FrameWorldChanged(instanceData)
    ClientData instanceData;	/* Information about widget. */
{
    Frame *framePtr = (Frame *) instanceData;
    Labelframe *labelframePtr = (Labelframe *) framePtr;
    Tk_Window tkwin = framePtr->tkwin;
    XGCValues gcValues;
    GC gc;
    int anyTextLabel, anyWindowLabel;
    int bWidthLeft, bWidthRight, bWidthTop, bWidthBottom;
    char *labelText;

    anyTextLabel = (framePtr->type == TYPE_LABELFRAME) &&
	    (labelframePtr->textPtr != NULL) &&
	    (labelframePtr->labelWin == NULL);
    anyWindowLabel = (framePtr->type == TYPE_LABELFRAME) &&
	    (labelframePtr->labelWin != NULL);

    if (framePtr->type == TYPE_LABELFRAME) {
	/*
	 * The textGC is needed even in the labelWin case, so it's
	 * always created for a labelframe.
	 */

	gcValues.font = Tk_FontId(labelframePtr->tkfont);
	gcValues.foreground = labelframePtr->textColorPtr->pixel;
	gcValues.graphics_exposures = False;
	gc = Tk_GetGC(tkwin, GCForeground | GCFont | GCGraphicsExposures,
		&gcValues);
	if (labelframePtr->textGC != None) {
	    Tk_FreeGC(framePtr->display, labelframePtr->textGC);
	}
	labelframePtr->textGC = gc;

	/*
	 * Calculate label size.
	 */
	
	labelframePtr->labelReqWidth = labelframePtr->labelReqHeight = 0;

	if (anyTextLabel) {
	    labelText = Tcl_GetString(labelframePtr->textPtr);
	    Tk_FreeTextLayout(labelframePtr->textLayout);
	    labelframePtr->textLayout = Tk_ComputeTextLayout(labelframePtr->tkfont,
		    labelText, -1, 0, TK_JUSTIFY_CENTER, 0,
		    &labelframePtr->labelReqWidth, &labelframePtr->labelReqHeight);
	    labelframePtr->labelReqWidth += 2 * LABELSPACING;
	    labelframePtr->labelReqHeight += 2 * LABELSPACING;
	} else if (anyWindowLabel) {
	    labelframePtr->labelReqWidth = Tk_ReqWidth(labelframePtr->labelWin);
	    labelframePtr->labelReqHeight = Tk_ReqHeight(labelframePtr->labelWin);
	}

	/* 
	 * Make sure label size is at least as big as the border.
	 * This simplifies later calculations and gives a better
	 * appearance with thick borders.
	 */
     
	if ((labelframePtr->labelAnchor >= LABELANCHOR_N) && 
		(labelframePtr->labelAnchor <= LABELANCHOR_SW)) {
	    if (labelframePtr->labelReqHeight < framePtr->borderWidth) {
		labelframePtr->labelReqHeight = framePtr->borderWidth;
	    }
	} else {
	    if (labelframePtr->labelReqWidth < framePtr->borderWidth) {
		labelframePtr->labelReqWidth = framePtr->borderWidth;
	    }
	}
    }

    /*
     * Calculate individual border widths.
     */

    bWidthBottom = bWidthTop = bWidthRight = bWidthLeft = 
            framePtr->borderWidth + framePtr->highlightWidth;

    bWidthLeft   += framePtr->padX;
    bWidthRight  += framePtr->padX;
    bWidthTop    += framePtr->padY;
    bWidthBottom += framePtr->padY;
    
    if (anyTextLabel || anyWindowLabel) {
	switch (labelframePtr->labelAnchor) {
	  case LABELANCHOR_E:
	  case LABELANCHOR_EN:
	  case LABELANCHOR_ES:
	    bWidthRight += labelframePtr->labelReqWidth -
		    framePtr->borderWidth;
	    break;
	  case LABELANCHOR_N:
	  case LABELANCHOR_NE:
	  case LABELANCHOR_NW:
	    bWidthTop += labelframePtr->labelReqHeight - framePtr->borderWidth;
	    break;
	  case LABELANCHOR_S:
	  case LABELANCHOR_SE:
	  case LABELANCHOR_SW:
	    bWidthBottom += labelframePtr->labelReqHeight -
		    framePtr->borderWidth;
	    break;
	  default:
	    bWidthLeft += labelframePtr->labelReqWidth - framePtr->borderWidth;
	    break;
	}
    }

    Tk_SetInternalBorderEx(tkwin, bWidthLeft, bWidthRight, bWidthTop,
	    bWidthBottom);

    ComputeFrameGeometry(framePtr);

    /*
     * A labelframe should request size for its label.
     */

    if (framePtr->type == TYPE_LABELFRAME) {
	int minwidth = labelframePtr->labelReqWidth;
	int minheight = labelframePtr->labelReqHeight;
	int padding = framePtr->highlightWidth;
	if (framePtr->borderWidth > 0) {
	    padding += framePtr->borderWidth + LABELMARGIN;
	}
	padding *= 2;
	if ((labelframePtr->labelAnchor >= LABELANCHOR_N) && 
		(labelframePtr->labelAnchor <= LABELANCHOR_SW)) {
	    minwidth += padding;
	    minheight += framePtr->borderWidth + framePtr->highlightWidth;
	} else {
	    minheight += padding;
	    minwidth += framePtr->borderWidth + framePtr->highlightWidth;
	}
	Tk_SetMinimumRequestSize(tkwin, minwidth, minheight);
    }

    if ((framePtr->width > 0) || (framePtr->height > 0)) {
	Tk_GeometryRequest(tkwin, framePtr->width, framePtr->height);
    }

    if (Tk_IsMapped(tkwin)) {
	if (!(framePtr->flags & REDRAW_PENDING)) {
	    Tcl_DoWhenIdle(DisplayFrame, (ClientData) framePtr);
	}
	framePtr->flags |= REDRAW_PENDING;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ComputeFrameGeometry --
 *
 *	This procedure is called to compute various geometrical
 *	information for a frame, such as where various things get
 *	displayed.  It's called when the window is reconfigured.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Display-related numbers get changed in *framePtr.
 *
 *----------------------------------------------------------------------
 */

static void
ComputeFrameGeometry(framePtr)
    register Frame *framePtr;		/* Information about widget. */
{
    int otherWidth, otherHeight, otherWidthT, otherHeightT, padding;
    int maxWidth, maxHeight;
    Tk_Window tkwin;
    Labelframe *labelframePtr = (Labelframe *) framePtr;

    /*
     * We have nothing to do here unless there is a label.
     */

    if (framePtr->type != TYPE_LABELFRAME) return;
    if ((labelframePtr->textPtr == NULL) &&
	    (labelframePtr->labelWin == NULL))  return;

    tkwin = framePtr->tkwin;

    /* 
     * Calculate the available size for the label
     */

    labelframePtr->labelBox.width = labelframePtr->labelReqWidth;
    labelframePtr->labelBox.height = labelframePtr->labelReqHeight;

    padding = framePtr->highlightWidth;
    if (framePtr->borderWidth > 0) {
        padding += framePtr->borderWidth + LABELMARGIN;
    }
    padding *= 2;

    maxHeight = Tk_Height(tkwin);
    maxWidth  = Tk_Width(tkwin);

    if ((labelframePtr->labelAnchor >= LABELANCHOR_N) && 
            (labelframePtr->labelAnchor <= LABELANCHOR_SW)) {
	maxWidth -= padding;
	if (maxWidth < 1) maxWidth = 1;
    } else {
	maxHeight -= padding;
	if (maxHeight < 1) maxHeight = 1;
    }
    if (labelframePtr->labelBox.width > maxWidth) {
	labelframePtr->labelBox.width = maxWidth;
    }
    if (labelframePtr->labelBox.height > maxHeight) {
	labelframePtr->labelBox.height = maxHeight;
    }

    /*
     * Calculate label and text position.
     * The text's position is based on the requested size (= the text's
     * real size) to get proper alignment if the text does not fit.
     */

    otherWidth   = Tk_Width(tkwin)  - labelframePtr->labelBox.width;
    otherHeight  = Tk_Height(tkwin) - labelframePtr->labelBox.height;
    otherWidthT  = Tk_Width(tkwin)  - labelframePtr->labelReqWidth;
    otherHeightT = Tk_Height(tkwin) - labelframePtr->labelReqHeight;
    padding = framePtr->highlightWidth;

    switch (labelframePtr->labelAnchor) {
      case LABELANCHOR_E:
      case LABELANCHOR_EN:
      case LABELANCHOR_ES:
        labelframePtr->labelTextX = otherWidthT - padding;
        labelframePtr->labelBox.x = otherWidth - padding;
        break;
      case LABELANCHOR_N:
      case LABELANCHOR_NE:
      case LABELANCHOR_NW:
        labelframePtr->labelTextY = padding;
        labelframePtr->labelBox.y = padding;
        break;
      case LABELANCHOR_S:
      case LABELANCHOR_SE:
      case LABELANCHOR_SW:
        labelframePtr->labelTextY = otherHeightT - padding;
        labelframePtr->labelBox.y = otherHeight - padding;
        break;
      default:
        labelframePtr->labelTextX = padding;
        labelframePtr->labelBox.x = padding;
        break;
    }

    if (framePtr->borderWidth > 0) {
        padding += framePtr->borderWidth + LABELMARGIN;
    }

    switch (labelframePtr->labelAnchor) {
      case LABELANCHOR_NW:
      case LABELANCHOR_SW:
        labelframePtr->labelTextX = padding;
        labelframePtr->labelBox.x = padding;
        break;
      case LABELANCHOR_N:
      case LABELANCHOR_S:	
        labelframePtr->labelTextX = otherWidthT / 2;
        labelframePtr->labelBox.x = otherWidth / 2;
        break;
      case LABELANCHOR_NE:
      case LABELANCHOR_SE:
        labelframePtr->labelTextX = otherWidthT - padding;
        labelframePtr->labelBox.x = otherWidth - padding;
        break;
      case LABELANCHOR_EN:
      case LABELANCHOR_WN:
        labelframePtr->labelTextY = padding;
        labelframePtr->labelBox.y = padding;
        break;
      case LABELANCHOR_E:
      case LABELANCHOR_W:
        labelframePtr->labelTextY = otherHeightT / 2;
        labelframePtr->labelBox.y = otherHeight / 2;
        break;
      default:
	labelframePtr->labelTextY = otherHeightT - padding;
	labelframePtr->labelBox.y = otherHeight - padding;
        break;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * DisplayFrame --
 *
 *	This procedure is invoked to display a frame widget.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Commands are output to X to display the frame in its
 *	current mode.
 *
 *----------------------------------------------------------------------
 */

static void
DisplayFrame(clientData)
    ClientData clientData;	/* Information about widget. */
{
    register Frame *framePtr = (Frame *) clientData;
    register Tk_Window tkwin = framePtr->tkwin;
    int bdX1, bdY1, bdX2, bdY2, hlWidth;
    Pixmap pixmap;
    TkRegion clipRegion = NULL;

    framePtr->flags &= ~REDRAW_PENDING;
    if ((framePtr->tkwin == NULL) || !Tk_IsMapped(tkwin)
        || framePtr->isContainer) {
	return;
    }

    /*
     * Highlight shall always be drawn if it exists, so do that first.
     */

    hlWidth = framePtr->highlightWidth;

    if (hlWidth != 0) {
        GC fgGC, bgGC;
        
	bgGC = Tk_GCForColor(framePtr->highlightBgColorPtr,
		Tk_WindowId(tkwin));
	if (framePtr->flags & GOT_FOCUS) {
	    fgGC = Tk_GCForColor(framePtr->highlightColorPtr,
		    Tk_WindowId(tkwin));
	    TkpDrawHighlightBorder(tkwin, fgGC, bgGC, hlWidth,
		    Tk_WindowId(tkwin));
	} else {
	    TkpDrawHighlightBorder(tkwin, bgGC, bgGC, hlWidth,
		    Tk_WindowId(tkwin));
	}
    }

    /*
     * If -background is set to "", no interior is drawn.
     */

    if (framePtr->border == NULL) return;

    if (framePtr->type != TYPE_LABELFRAME) {
	/*
	 * There is no label so there is just a simple rectangle to draw.
	 */

	noLabel:
	Tk_Fill3DRectangle(tkwin, Tk_WindowId(tkwin),
		framePtr->border, hlWidth, hlWidth,
		Tk_Width(tkwin) - 2 * hlWidth,
		Tk_Height(tkwin) - 2 * hlWidth,
		framePtr->borderWidth, framePtr->relief);
    } else {
	Labelframe *labelframePtr = (Labelframe *) framePtr;

	if ((labelframePtr->textPtr == NULL) &&
		(labelframePtr->labelWin == NULL)) {
	    goto noLabel;
	}

	/*
	 * In order to avoid screen flashes, this procedure redraws the
	 * frame into off-screen memory, then copies it back on-screen 
	 * in a single operation.  This means there's no point in time 
	 * where the on-screen image has been cleared.
	 */

	pixmap = Tk_GetPixmap(framePtr->display, Tk_WindowId(tkwin),
		Tk_Width(tkwin), Tk_Height(tkwin), Tk_Depth(tkwin));
	
	/* 
	 * Clear the pixmap.
	 */

	Tk_Fill3DRectangle(tkwin, pixmap, framePtr->border, 0, 0,
		Tk_Width(tkwin), Tk_Height(tkwin), 0, TK_RELIEF_FLAT);

	/*
	 * Calculate how the label affects the border's position.
	 */

	bdX1 = bdY1 = hlWidth;
	bdX2 = Tk_Width(tkwin) - hlWidth;
	bdY2 = Tk_Height(tkwin) - hlWidth;

	switch (labelframePtr->labelAnchor) {
	  case LABELANCHOR_E:
	  case LABELANCHOR_EN:
	  case LABELANCHOR_ES:
	    bdX2 -= (labelframePtr->labelBox.width - framePtr->borderWidth)
		    / 2;
	    break;
	  case LABELANCHOR_N:
	  case LABELANCHOR_NE:
	  case LABELANCHOR_NW:
	    /* 
	     * Since the glyphs of the text tend to be in the lower part
             * we favor a lower border position by rounding up.
	     */

	    bdY1 += (labelframePtr->labelBox.height - framePtr->borderWidth +1)
		    / 2;
	    break;
	  case LABELANCHOR_S:
	  case LABELANCHOR_SE:
	  case LABELANCHOR_SW:
	    bdY2 -= (labelframePtr->labelBox.height - framePtr->borderWidth)
		    / 2;
	    break;
	  default:
	    bdX1 += (labelframePtr->labelBox.width - framePtr->borderWidth)
		    / 2;
	    break;
	}

	/* 
         * Draw border
         */

	Tk_Draw3DRectangle(tkwin, pixmap, framePtr->border, bdX1, bdY1,
		bdX2 - bdX1, bdY2 - bdY1, framePtr->borderWidth,
		framePtr->relief);

        if (labelframePtr->labelWin == NULL) {
            /* 
             * Clear behind the label
             */

            Tk_Fill3DRectangle(tkwin, pixmap,
                    framePtr->border, labelframePtr->labelBox.x,
                    labelframePtr->labelBox.y, labelframePtr->labelBox.width,
                    labelframePtr->labelBox.height, 0, TK_RELIEF_FLAT);

            /*
             * Draw label.
	     * If there is not room for the entire label, use clipping to
	     * get a nice appearance.
             */
	    
	    if ((labelframePtr->labelBox.width < labelframePtr->labelReqWidth)
		    || (labelframePtr->labelBox.height < 
			    labelframePtr->labelReqHeight)) {
		clipRegion = TkCreateRegion();
		TkUnionRectWithRegion(&labelframePtr->labelBox, clipRegion,
			clipRegion);
		TkSetRegion(framePtr->display, labelframePtr->textGC,
			clipRegion);
	    }

            Tk_DrawTextLayout(framePtr->display, pixmap,
                    labelframePtr->textGC, labelframePtr->textLayout,
                    labelframePtr->labelTextX + LABELSPACING,
                    labelframePtr->labelTextY + LABELSPACING, 0, -1);

	    if (clipRegion != NULL) {
		XSetClipMask(framePtr->display, labelframePtr->textGC, None);
		TkDestroyRegion(clipRegion);
	    }
        } else {
	    /*
	     * Reposition and map the window (but in different ways depending
	     * on whether the frame is the window's parent).
	     */
            
	    if (framePtr->tkwin == Tk_Parent(labelframePtr->labelWin)) {
		if ((labelframePtr->labelBox.x != Tk_X(labelframePtr->labelWin))
			|| (labelframePtr->labelBox.y !=
				Tk_Y(labelframePtr->labelWin))
			|| (labelframePtr->labelBox.width != 
				Tk_Width(labelframePtr->labelWin))
			|| (labelframePtr->labelBox.height != 
				Tk_Height(labelframePtr->labelWin))) {
		    Tk_MoveResizeWindow(labelframePtr->labelWin,
			    labelframePtr->labelBox.x, labelframePtr->labelBox.y, 
			    labelframePtr->labelBox.width,
			    labelframePtr->labelBox.height);
		}
		Tk_MapWindow(labelframePtr->labelWin);
	    } else {
		Tk_MaintainGeometry(labelframePtr->labelWin, framePtr->tkwin, 
			labelframePtr->labelBox.x, labelframePtr->labelBox.y,
			labelframePtr->labelBox.width,
			labelframePtr->labelBox.height);
	    }
	}


	/*
	 * Everything's been redisplayed;  now copy the pixmap onto the screen
	 * and free up the pixmap.
	 */

	XCopyArea(framePtr->display, pixmap, Tk_WindowId(tkwin),
		labelframePtr->textGC, hlWidth, hlWidth,
		(unsigned) (Tk_Width(tkwin) - 2 * hlWidth),
		(unsigned) (Tk_Height(tkwin) - 2 * hlWidth),
		hlWidth, hlWidth);
	Tk_FreePixmap(framePtr->display, pixmap);
    }

}

/*
 *--------------------------------------------------------------
 *
 * FrameEventProc --
 *
 *	This procedure is invoked by the Tk dispatcher on
 *	structure changes to a frame.  For frames with 3D
 *	borders, this procedure is also invoked for exposures.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	When the window gets deleted, internal structures get
 *	cleaned up.  When it gets exposed, it is redisplayed.
 *
 *--------------------------------------------------------------
 */

static void
FrameEventProc(clientData, eventPtr)
    ClientData clientData;	/* Information about window. */
    register XEvent *eventPtr;	/* Information about event. */
{
    register Frame *framePtr = (Frame *) clientData;

    if ((eventPtr->type == Expose) && (eventPtr->xexpose.count == 0)) {
	goto redraw;
    } else if (eventPtr->type == ConfigureNotify) {
	ComputeFrameGeometry(framePtr);
	goto redraw;
    } else if (eventPtr->type == DestroyNotify) {
	if (framePtr->menuName != NULL) {
	    TkSetWindowMenuBar(framePtr->interp, framePtr->tkwin,
		    framePtr->menuName, NULL);
	    ckfree(framePtr->menuName);
	    framePtr->menuName = NULL;
	}
	if (framePtr->tkwin != NULL) {

	    /*
	     * If this window is a container, then this event could be
	     * coming from the embedded application, in which case
	     * Tk_DestroyWindow hasn't been called yet.  When Tk_DestroyWindow
	     * is called later, then another destroy event will be generated.
	     * We need to be sure we ignore the second event, since the frame
	     * could be gone by then.  To do so, delete the event handler
	     * explicitly (normally it's done implicitly by Tk_DestroyWindow).
	     */

	    /*
	     * Since the tkwin pointer will be gone when we reach
	     * DestroyFrame, we must free all options now.
	     */

            DestroyFramePartly(framePtr);

	    Tk_DeleteEventHandler(framePtr->tkwin,
		    ExposureMask|StructureNotifyMask|FocusChangeMask,
		    FrameEventProc, (ClientData) framePtr);
	    framePtr->tkwin = NULL;
            Tcl_DeleteCommandFromToken(framePtr->interp, framePtr->widgetCmd);
	}
	if (framePtr->flags & REDRAW_PENDING) {
	    Tcl_CancelIdleCall(DisplayFrame, (ClientData) framePtr);
	}
	Tcl_CancelIdleCall(MapFrame, (ClientData) framePtr);
	Tcl_EventuallyFree((ClientData) framePtr, DestroyFrame);
    } else if (eventPtr->type == FocusIn) {
	if (eventPtr->xfocus.detail != NotifyInferior) {
	    framePtr->flags |= GOT_FOCUS;
	    if (framePtr->highlightWidth > 0) {
		goto redraw;
	    }
	}
    } else if (eventPtr->type == FocusOut) {
	if (eventPtr->xfocus.detail != NotifyInferior) {
	    framePtr->flags &= ~GOT_FOCUS;
	    if (framePtr->highlightWidth > 0) {
		goto redraw;
	    }
	}
    } else if (eventPtr->type == ActivateNotify) {
    	TkpSetMainMenubar(framePtr->interp, framePtr->tkwin,
    		framePtr->menuName);
    }
    return;

    redraw:
    if ((framePtr->tkwin != NULL) && !(framePtr->flags & REDRAW_PENDING)) {
	Tcl_DoWhenIdle(DisplayFrame, (ClientData) framePtr);
	framePtr->flags |= REDRAW_PENDING;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * FrameCmdDeletedProc --
 *
 *	This procedure is invoked when a widget command is deleted.  If
 *	the widget isn't already in the process of being destroyed,
 *	this command destroys it.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The widget is destroyed.
 *
 *----------------------------------------------------------------------
 */

static void
FrameCmdDeletedProc(clientData)
    ClientData clientData;	/* Pointer to widget record for widget. */
{
    Frame *framePtr = (Frame *) clientData;
    Tk_Window tkwin = framePtr->tkwin;

    if (framePtr->menuName != NULL) {
	TkSetWindowMenuBar(framePtr->interp, framePtr->tkwin,
		framePtr->menuName, NULL);
	ckfree(framePtr->menuName);
	framePtr->menuName = NULL;
    }

    /*
     * This procedure could be invoked either because the window was
     * destroyed and the command was then deleted (in which case tkwin
     * is NULL) or because the command was deleted, and then this procedure
     * destroys the widget.
     */

    if (tkwin != NULL) {
	/* 
	 * Some options need tkwin to be freed, so we free them here,
	 * before setting tkwin to NULL.
	 */

        DestroyFramePartly(framePtr);

	framePtr->tkwin = NULL;
	Tk_DestroyWindow(tkwin);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * MapFrame --
 *
 *	This procedure is invoked as a when-idle handler to map a
 *	newly-created top-level frame.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The frame given by the clientData argument is mapped.
 *
 *----------------------------------------------------------------------
 */

static void
MapFrame(clientData)
    ClientData clientData;		/* Pointer to frame structure. */
{
    Frame *framePtr = (Frame *) clientData;

    /*
     * Wait for all other background events to be processed before
     * mapping window.  This ensures that the window's correct geometry
     * will have been determined before it is first mapped, so that the
     * window manager doesn't get a false idea of its desired geometry.
     */

    Tcl_Preserve((ClientData) framePtr);
    while (1) {
	if (Tcl_DoOneEvent(TCL_IDLE_EVENTS) == 0) {
	    break;
	}

	/*
	 * After each event, make sure that the window still exists
	 * and quit if the window has been destroyed.
	 */

	if (framePtr->tkwin == NULL) {
	    Tcl_Release((ClientData) framePtr);
	    return;
	}
    }
    Tk_MapWindow(framePtr->tkwin);
    Tcl_Release((ClientData) framePtr);
}

/*
 *--------------------------------------------------------------
 *
 * TkInstallFrameMenu --
 *
 *	This function is needed when a Windows HWND is created
 *	and a menubar has been set to the window with a system
 *	menu. It notifies the menu package so that the system
 *	menu can be rebuilt.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The system menu (if any) is created for the menubar
 *	associated with this frame.
 *
 *--------------------------------------------------------------
 */

void
TkInstallFrameMenu(tkwin)
    Tk_Window tkwin;		/* The window that was just created. */
{
    TkWindow *winPtr = (TkWindow *) tkwin;

    if (winPtr->mainPtr != NULL) {
	Frame *framePtr;
	framePtr = (Frame*) winPtr->instanceData;
	if (framePtr == NULL) {
	    panic("TkInstallFrameMenu couldn't get frame pointer");
	}
	TkpMenuNotifyToplevelCreate(winPtr->mainPtr->interp, 
		framePtr->menuName);
    }
}

/*
 *--------------------------------------------------------------
 *
 * FrameStructureProc --
 *
 *	This procedure is invoked whenever StructureNotify events
 *	occur for a window that's managed as label for the frame.
 *	This procudure's only purpose is to clean up when windows
 *	are deleted.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The window is disassociated from the frame when it is
 *	deleted.
 *
 *--------------------------------------------------------------
 */

static void
FrameStructureProc(clientData, eventPtr)
    ClientData clientData;	/* Pointer to record describing frame. */
    XEvent *eventPtr;		/* Describes what just happened. */
{
    Labelframe *labelframePtr = (Labelframe *) clientData;

    if (eventPtr->type == DestroyNotify) {
	/*
	 * This should only happen in a labelframe but it doesn't
	 * hurt to be careful.
	 */

	if (labelframePtr->frame.type == TYPE_LABELFRAME) {
	    labelframePtr->labelWin = NULL;
	    FrameWorldChanged((ClientData) labelframePtr);
	}
    }
}

/*
 *--------------------------------------------------------------
 *
 * FrameRequestProc --
 *
 *	This procedure is invoked whenever a window that's associated
 *	with a frame changes its requested dimensions.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The size and location on the screen of the window may change.
 *	depending on the options specified for the frame.
 *
 *--------------------------------------------------------------
 */

static void
FrameRequestProc(clientData, tkwin)
    ClientData clientData;		/* Pointer to record for frame. */
    Tk_Window tkwin;			/* Window that changed its desired
					 * size. */
{
    Frame *framePtr = (Frame *) clientData;

    FrameWorldChanged((ClientData) framePtr);
}

/*
 *--------------------------------------------------------------
 *
 * FrameLostSlaveProc --
 *
 *	This procedure is invoked by Tk whenever some other geometry
 *	claims control over a slave that used to be managed by us.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Forgets all frame-related information about the slave.
 *
 *--------------------------------------------------------------
 */

static void
FrameLostSlaveProc(clientData, tkwin)
    ClientData clientData;	/* Frame structure for slave window that
				 * was stolen away. */
    Tk_Window tkwin;		/* Tk's handle for the slave window. */
{
    Frame *framePtr = (Frame *) clientData;
    Labelframe *labelframePtr = (Labelframe *) clientData;

    /*
     * This should only happen in a labelframe but it doesn't
     * hurt to be careful.
     */
    
    if (labelframePtr->frame.type == TYPE_LABELFRAME) {
	Tk_DeleteEventHandler(labelframePtr->labelWin, StructureNotifyMask,
		FrameStructureProc, (ClientData) labelframePtr);
	if (framePtr->tkwin != Tk_Parent(labelframePtr->labelWin)) {
	    Tk_UnmaintainGeometry(labelframePtr->labelWin, framePtr->tkwin);
	}
	Tk_UnmapWindow(labelframePtr->labelWin);
	labelframePtr->labelWin = NULL;
    }
    FrameWorldChanged((ClientData) framePtr);
}
@


1.4
log
@touched all sources to ease next import
@
text
@d4 2
a5 2
 *	This module implements "frame"  and "toplevel" widgets for
 *	the Tk toolkit.  Frames are windows with a background color
d15 1
a15 1
 * RCS: @@(#) $Id: tkFrame.c,v 1.7.6.1 2000/05/04 21:26:23 spolk Exp $
d23 8
d46 2
d50 1
a50 3
    int mask;			/* Either FRAME or TOPLEVEL;  used to select
				 * which configuration options are valid for
				 * widget. */
d93 8
d104 46
d163 149
a311 2
 * The following flag bits are used so that there can be separate
 * defaults for some configuration options for frames and toplevels.
d314 4
a317 58
#define FRAME		TK_CONFIG_USER_BIT
#define TOPLEVEL	(TK_CONFIG_USER_BIT << 1)
#define BOTH		(FRAME | TOPLEVEL)

static Tk_ConfigSpec configSpecs[] = {
    {TK_CONFIG_BORDER, "-background", "background", "Background",
	DEF_FRAME_BG_COLOR, Tk_Offset(Frame, border),
	BOTH|TK_CONFIG_COLOR_ONLY|TK_CONFIG_NULL_OK},
    {TK_CONFIG_BORDER, "-background", "background", "Background",
	DEF_FRAME_BG_MONO, Tk_Offset(Frame, border),
	BOTH|TK_CONFIG_MONO_ONLY|TK_CONFIG_NULL_OK},
    {TK_CONFIG_SYNONYM, "-bd", "borderWidth", (char *) NULL,
	(char *) NULL, 0, BOTH},
    {TK_CONFIG_SYNONYM, "-bg", "background", (char *) NULL,
	(char *) NULL, 0, BOTH},
    {TK_CONFIG_PIXELS, "-borderwidth", "borderWidth", "BorderWidth",
	DEF_FRAME_BORDER_WIDTH, Tk_Offset(Frame, borderWidth), BOTH},
    {TK_CONFIG_STRING, "-class", "class", "Class",
	DEF_FRAME_CLASS, Tk_Offset(Frame, className), FRAME},
    {TK_CONFIG_STRING, "-class", "class", "Class",
	DEF_TOPLEVEL_CLASS, Tk_Offset(Frame, className), TOPLEVEL},
    {TK_CONFIG_STRING, "-colormap", "colormap", "Colormap",
	DEF_FRAME_COLORMAP, Tk_Offset(Frame, colormapName),
	BOTH|TK_CONFIG_NULL_OK},
    {TK_CONFIG_BOOLEAN, "-container", "container", "Container",
	DEF_FRAME_CONTAINER, Tk_Offset(Frame, isContainer), BOTH},
    {TK_CONFIG_ACTIVE_CURSOR, "-cursor", "cursor", "Cursor",
	DEF_FRAME_CURSOR, Tk_Offset(Frame, cursor), BOTH|TK_CONFIG_NULL_OK},
    {TK_CONFIG_PIXELS, "-height", "height", "Height",
	DEF_FRAME_HEIGHT, Tk_Offset(Frame, height), BOTH},
    {TK_CONFIG_COLOR, "-highlightbackground", "highlightBackground",
	"HighlightBackground", DEF_FRAME_HIGHLIGHT_BG,
	Tk_Offset(Frame, highlightBgColorPtr), BOTH},
    {TK_CONFIG_COLOR, "-highlightcolor", "highlightColor", "HighlightColor",
	DEF_FRAME_HIGHLIGHT, Tk_Offset(Frame, highlightColorPtr), BOTH},
    {TK_CONFIG_PIXELS, "-highlightthickness", "highlightThickness",
	"HighlightThickness",
	DEF_FRAME_HIGHLIGHT_WIDTH, Tk_Offset(Frame, highlightWidth), BOTH},
    {TK_CONFIG_STRING, "-menu", "menu", "Menu",
	DEF_TOPLEVEL_MENU, Tk_Offset(Frame, menuName),
	TOPLEVEL|TK_CONFIG_NULL_OK},
    {TK_CONFIG_RELIEF, "-relief", "relief", "Relief",
	DEF_FRAME_RELIEF, Tk_Offset(Frame, relief), BOTH},
    {TK_CONFIG_STRING, "-screen", "screen", "Screen",
	DEF_TOPLEVEL_SCREEN, Tk_Offset(Frame, screenName),
	TOPLEVEL|TK_CONFIG_NULL_OK},
    {TK_CONFIG_STRING, "-takefocus", "takeFocus", "TakeFocus",
	DEF_FRAME_TAKE_FOCUS, Tk_Offset(Frame, takeFocus),
	BOTH|TK_CONFIG_NULL_OK},
    {TK_CONFIG_STRING, "-use", "use", "Use",
	DEF_FRAME_USE, Tk_Offset(Frame, useThis), TOPLEVEL|TK_CONFIG_NULL_OK},
    {TK_CONFIG_STRING, "-visual", "visual", "Visual",
	DEF_FRAME_VISUAL, Tk_Offset(Frame, visualName),
	BOTH|TK_CONFIG_NULL_OK},
    {TK_CONFIG_PIXELS, "-width", "width", "Width",
	DEF_FRAME_WIDTH, Tk_Offset(Frame, width), BOTH},
    {TK_CONFIG_END, (char *) NULL, (char *) NULL, (char *) NULL,
	(char *) NULL, 0, 0}
d324 1
d326 1
a326 2
			    Frame *framePtr, int objc, Tcl_Obj *CONST objv[],
			    int flags));
d329 1
a329 1
			    int toplevel, char *appName));
d331 1
d337 6
d345 2
d348 22
d374 1
a374 1
 * Tk_FrameObjCmd, Tk_ToplevelObjCmd --
d376 3
a378 3
 *	These procedures are invoked to process the "frame" and
 *	"toplevel" Tcl commands.  See the user documentation for
 *	details on what they do.
d385 1
a385 1
 *	they call ButtonCreate to do all of the real work.
d392 1
a392 2
    ClientData clientData;	/* Main window associated with
				 * interpreter. */
d397 2
a398 1
    return CreateFrame(clientData, interp, objc, objv, 0, (char *) NULL);
d403 1
a403 2
    ClientData clientData;	/* Main window associated with
				 * interpreter. */
d408 13
a420 1
    return CreateFrame(clientData, interp, objc, objv, 1, (char *) NULL);
d428 4
a431 4
 *	This procedure is invoked to process the "frame" and "toplevel"
 *	Tcl commands;  it is also invoked directly by Tk_Init to create
 *	a new main window.  See the user documentation for the "frame"
 *	and "toplevel" commands for details on what it does.
d444 1
a444 3
    ClientData clientData;	/* Main window associated with interpreter.
				 * If we're called by Tk_Init to create a
				 * new application, then this is NULL. */
d450 3
a452 2
    char *appName;		/* Should only be non-NULL if clientData is
				 * NULL:  gives the base name to use for the
d462 2
a463 1
    result = CreateFrame(clientData, interp, argc, objv, toplevel, appName);
d472 2
a473 4
CreateFrame(clientData, interp, objc, objv, toplevel, appName)
    ClientData clientData;	/* Main window associated with interpreter.
				 * If we're called by Tk_Init to create a
				 * new application, then this is NULL. */
d477 4
a480 4
    int toplevel;		/* Non-zero means create a toplevel window,
				 * zero means create a frame. */
    char *appName;		/* Should only be non-NULL if clientData is
				 * NULL:  gives the base name to use for the
d483 1
a483 1
    Tk_Window tkwin = (Tk_Window) clientData;
d485 1
d487 1
a487 1
    char *className, *screenName, *visualName, *colormapName, *arg, *useOption;
d500 7
d527 1
a527 1
	} else if ((c == 's') && toplevel
d530 1
a530 1
	} else if ((c == 'u') && toplevel
d555 1
a555 1
	screenName = (toplevel) ? "" : NULL;
d557 8
d584 1
a584 1
	    className = (toplevel) ? "Toplevel" : "Frame";
d624 1
a624 1
    if (toplevel) {
d634 11
a644 5
    framePtr = (Frame *) ckalloc(sizeof(Frame));
    framePtr->tkwin = new;
    framePtr->display = Tk_Display(new);
    framePtr->interp = interp;
    framePtr->widgetCmd = Tcl_CreateObjCommand(interp,
d647 2
a648 5
    framePtr->className = NULL;
    framePtr->mask = (toplevel) ? TOPLEVEL : FRAME;
    framePtr->screenName = NULL;
    framePtr->visualName = NULL;
    framePtr->colormapName = NULL;
a649 2
    framePtr->border = NULL;
    framePtr->borderWidth = 0;
a650 5
    framePtr->highlightWidth = 0;
    framePtr->highlightBgColorPtr = NULL;
    framePtr->highlightColorPtr = NULL;
    framePtr->width = 0;
    framePtr->height = 0;
d652 6
a657 5
    framePtr->takeFocus = NULL;
    framePtr->isContainer = 0;
    framePtr->useThis = NULL;
    framePtr->flags = 0;
    framePtr->menuName = NULL;
d662 1
a662 1
    TkSetClassProcs(new, NULL, (ClientData) framePtr);
d665 1
a665 1
    if (toplevel) {
d669 3
a671 1
    if (ConfigureFrame(interp, framePtr, objc-2, objv+2, 0) != TCL_OK) {
d678 3
a680 3
	    Tcl_AppendResult(interp,"A window cannot have both the -use ",
		    "and the -container option set.");
	    return TCL_ERROR;
d683 1
a683 1
    if (toplevel) {
d721 1
a721 1
    static char *frameOptions[] = {
d731 1
d749 8
a756 2
	result = Tk_ConfigureValue(interp, framePtr->tkwin, configSpecs,
		(char *) framePtr, Tcl_GetString(objv[2]), framePtr->mask);
d760 11
a770 6
	if (objc == 2) {
	    result = Tk_ConfigureInfo(interp, framePtr->tkwin, configSpecs,
		    (char *) framePtr, (char *) NULL, framePtr->mask);
	} else if (objc == 3) {
	    result = Tk_ConfigureInfo(interp, framePtr->tkwin, configSpecs,
		    (char *) framePtr, Tcl_GetString(objv[2]), framePtr->mask);
d785 1
a785 1
			|| ((c == 'c') && (framePtr->mask == TOPLEVEL)
d791 1
a791 1
			|| ((c == 's') && (framePtr->mask == TOPLEVEL)
d793 1
a793 1
			|| ((c == 'u') && (framePtr->mask == TOPLEVEL)
d795 1
a795 1
			|| ((c == 'v') && (framePtr->mask == TOPLEVEL)
d803 1
a803 2
	    result = ConfigureFrame(interp, framePtr, objc-2, objv+2,
		    TK_CONFIG_ARGV_ONLY);
d837 1
d839 6
a844 2
    Tk_FreeOptions(configSpecs, (char *) framePtr, framePtr->display,
	    framePtr->mask);
d854 41
d914 1
a914 1
ConfigureFrame(interp, framePtr, objc, objv, flags)
a919 1
    int flags;			/* Flags to pass to Tk_ConfigureWidget. */
d921 1
d923 3
a925 1
    
d936 10
a945 4
    
    if (Tk_ConfigureWidget(interp, framePtr->tkwin, configSpecs,
	    objc, (char **) objv, (char *) framePtr,
	    flags | framePtr->mask | TK_CONFIG_OBJS) != TCL_OK) {
d947 2
d951 4
d962 5
a966 1
    
d976 231
a1206 5
    Tk_SetInternalBorder(framePtr->tkwin,
	    framePtr->borderWidth + framePtr->highlightWidth);
    if ((framePtr->width > 0) || (framePtr->height > 0)) {
	Tk_GeometryRequest(framePtr->tkwin, framePtr->width,
		framePtr->height);
d1209 2
a1210 2
    if (oldMenuName != NULL) {
    	ckfree(oldMenuName);
d1213 1
a1213 1
    if (Tk_IsMapped(framePtr->tkwin)) {
d1219 142
a1360 1
    return TCL_OK;
d1386 3
a1388 2
    void (* drawFunction) _ANSI_ARGS_((Tk_Window, Drawable, Tk_3DBorder,
	    int, int, int, int, int, int)) = Tk_Fill3DRectangle;
d1396 7
a1402 9
    if (framePtr->border != NULL) {
	drawFunction(tkwin, Tk_WindowId(tkwin),
		framePtr->border, framePtr->highlightWidth,
		framePtr->highlightWidth,
		Tk_Width(tkwin) - 2*framePtr->highlightWidth,
		Tk_Height(tkwin) - 2*framePtr->highlightWidth,
		framePtr->borderWidth, framePtr->relief);
    }
    if (framePtr->highlightWidth != 0) {
d1410 1
a1410 1
	    TkpDrawHighlightBorder(tkwin, fgGC, bgGC, framePtr->highlightWidth,
d1413 1
a1413 1
	    TkpDrawHighlightBorder(tkwin, bgGC, bgGC, framePtr->highlightWidth,
d1417 166
d1611 4
a1614 2
    if (((eventPtr->type == Expose) && (eventPtr->xexpose.count == 0))
	    || (eventPtr->type == ConfigureNotify)) {
d1634 8
a1641 1
    
d1720 7
d1818 27
d1846 84
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d10 1
a10 1
 * Copyright (c) 1994-1995 Sun Microsystems, Inc.
d15 1
a15 1
 * RCS: @@(#) $Id: tkFrame.c,v 1.11 1999/01/26 04:11:22 jingham Exp $
d170 1
a170 1
			    Frame *framePtr, int argc, char **argv,
d172 3
d181 2
a182 2
static int		FrameWidgetCmd _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, int argc, char **argv));
d188 1
a188 1
 * Tk_FrameCmd, Tk_ToplevelCmd --
d205 1
a205 1
Tk_FrameCmd(clientData, interp, argc, argv)
d209 2
a210 2
    int argc;			/* Number of arguments. */
    char **argv;		/* Argument strings. */
d212 1
a212 1
    return TkCreateFrame(clientData, interp, argc, argv, 0, (char *) NULL);
d216 1
a216 1
Tk_ToplevelCmd(clientData, interp, argc, argv)
d220 2
a221 2
    int argc;			/* Number of arguments. */
    char **argv;		/* Argument strings. */
d223 1
a223 1
    return TkCreateFrame(clientData, interp, argc, argv, 1, (char *) NULL);
d229 1
a229 1
 * TkFrameCreate --
d259 29
d292 2
a293 1
    int i, c, length, depth;
d298 2
a299 3
    if (argc < 2) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
		argv[0], " pathName ?options?\"", (char *) NULL);
d312 2
a313 3
    for (i = 2; i < argc; i += 2) {
	arg = argv[i];
	length = strlen(arg);
d318 1
a318 1
	if ((c == 'c') && (strncmp(arg, "-class", strlen(arg)) == 0)
d320 1
a320 1
	    className = argv[i+1];
d322 2
a323 2
		&& (strncmp(arg, "-colormap", strlen(arg)) == 0)) {
	    colormapName = argv[i+1];
d325 2
a326 2
		&& (strncmp(arg, "-screen", strlen(arg)) == 0)) {
	    screenName = argv[i+1];
d328 2
a329 2
		&& (strncmp(arg, "-use", strlen(arg)) == 0)) {
	    useOption = argv[i+1];
d331 2
a332 2
		&& (strncmp(arg, "-visual", strlen(arg)) == 0)) {
	    visualName = argv[i+1];
d355 2
a356 1
	new = Tk_CreateWindowFromPath(interp, tkwin, argv[1], screenName);
d427 2
a428 2
    framePtr->widgetCmd = Tcl_CreateCommand(interp,
	    Tk_PathName(new), FrameWidgetCmd,
d461 1
a461 1
    if (ConfigureFrame(interp, framePtr, argc-2, argv+2, 0) != TCL_OK) {
d476 1
a476 1
    interp->result = Tk_PathName(new);
d489 1
a489 1
 * FrameWidgetCmd --
d505 1
a505 1
FrameWidgetCmd(clientData, interp, argc, argv)
d508 2
a509 2
    int argc;			/* Number of arguments. */
    char **argv;		/* Argument strings. */
d511 6
d518 1
a518 1
    int result;
d522 6
a527 3
    if (argc < 2) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
		argv[0], " option ?arg arg ...?\"", (char *) NULL);
d531 4
a534 8
    c = argv[1][0];
    length = strlen(argv[1]);
    if ((c == 'c') && (strncmp(argv[1], "cget", length) == 0)
	    && (length >= 2)) {
	if (argc != 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " cget option\"",
		    (char *) NULL);
d539 5
a543 4
		(char *) framePtr, argv[2], framePtr->mask);
    } else if ((c == 'c') && (strncmp(argv[1], "configure", length) == 0)
	    && (length >= 2)) {
	if (argc == 2) {
d546 1
a546 1
	} else if (argc == 3) {
d548 1
a548 1
		    (char *) framePtr, argv[2], framePtr->mask);
d555 2
a556 2
	    for (i = 2; i < argc; i++) {
		length = strlen(argv[i]);
d560 2
a561 2
		c = argv[i][1];
		if (((c == 'c') && (strncmp(argv[i], "-class", length) == 0)
d564 1
a564 1
			&& (strncmp(argv[i], "-colormap", length) == 0)
d567 1
a567 1
			&& (strncmp(argv[i], "-container", length) == 0)
d570 1
a570 1
			&& (strncmp(argv[i], "-screen", length) == 0))
d572 1
a572 1
			&& (strncmp(argv[i], "-use", length) == 0))
d574 2
a575 2
			&& (strncmp(argv[i], "-visual", length) == 0))) {
		    Tcl_AppendResult(interp, "can't modify ", argv[i],
d581 1
a581 1
	    result = ConfigureFrame(interp, framePtr, argc-2, argv+2,
d584 2
a585 4
    } else {
	Tcl_AppendResult(interp, "bad option \"", argv[1],
		"\": must be cget or configure", (char *) NULL);
	result = TCL_ERROR;
d630 1
a630 1
 *	This procedure is called to process an argv/argc list, plus
d636 1
a636 1
 *	returned, then interp->result contains an error message.
d647 1
a647 1
ConfigureFrame(interp, framePtr, argc, argv, flags)
d651 2
a652 2
    int argc;			/* Number of valid entries in argv. */
    char **argv;		/* Arguments. */
d669 2
a670 1
	    argc, argv, (char *) framePtr, flags | framePtr->mask) != TCL_OK) {
d734 2
a735 1
    GC gc;
d744 1
a744 1
	Tk_Fill3DRectangle(tkwin, Tk_WindowId(tkwin),
d752 4
d757 3
a759 1
	    gc = Tk_GCForColor(framePtr->highlightColorPtr,
d762 1
a762 1
	    gc = Tk_GCForColor(framePtr->highlightBgColorPtr,
a764 2
	Tk_DrawFocusHighlight(tkwin, gc, framePtr->highlightWidth,
		Tk_WindowId(tkwin));
d978 3
d985 1
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d10 1
a10 1
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
d15 1
a15 1
 * RCS: @@(#) $Id: tkFrame.c,v 1.7.6.1 2000/05/04 21:26:23 spolk Exp $
d170 1
a170 1
			    Frame *framePtr, int objc, Tcl_Obj *CONST objv[],
a171 3
static int		CreateFrame _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, int objc, Tcl_Obj *CONST argv[],
			    int toplevel, char *appName));
d178 2
a179 2
static int		FrameWidgetObjCmd _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
d185 1
a185 1
 * Tk_FrameObjCmd, Tk_ToplevelObjCmd --
d202 1
a202 1
Tk_FrameObjCmd(clientData, interp, objc, objv)
d206 2
a207 2
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
d209 1
a209 1
    return CreateFrame(clientData, interp, objc, objv, 0, (char *) NULL);
d213 1
a213 1
Tk_ToplevelObjCmd(clientData, interp, objc, objv)
d217 2
a218 2
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
d220 1
a220 1
    return CreateFrame(clientData, interp, objc, objv, 1, (char *) NULL);
d226 1
a226 1
 * TkCreateFrame --
a255 29
    int result, i;
    Tcl_Obj **objv = (Tcl_Obj **) ckalloc((argc+1) * sizeof(Tcl_Obj **));
    for (i=0; i<argc; i++) {
	objv[i] = Tcl_NewStringObj(argv[i], -1);
	Tcl_IncrRefCount(objv[i]);
    }
    objv[argc] = NULL;
    result = CreateFrame(clientData, interp, argc, objv, toplevel, appName);
    for (i=0; i<argc; i++) {
	Tcl_DecrRefCount(objv[i]);
    }
    ckfree((char *) objv);
    return result;
}

static int
CreateFrame(clientData, interp, objc, objv, toplevel, appName)
    ClientData clientData;	/* Main window associated with interpreter.
				 * If we're called by Tk_Init to create a
				 * new application, then this is NULL. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
    int toplevel;		/* Non-zero means create a toplevel window,
				 * zero means create a frame. */
    char *appName;		/* Should only be non-NULL if clientData is
				 * NULL:  gives the base name to use for the
				 * new application. */
{
d260 1
a260 2
    int i, c, depth;
    size_t length;
d265 3
a267 2
    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "pathName ?options?");
d280 3
a282 2
    for (i = 2; i < objc; i += 2) {
	arg = Tcl_GetStringFromObj(objv[i], (int *) &length);
d287 1
a287 1
	if ((c == 'c') && (strncmp(arg, "-class", length) == 0)
d289 1
a289 1
	    className = Tcl_GetString(objv[i+1]);
d291 2
a292 2
		&& (strncmp(arg, "-colormap", length) == 0)) {
	    colormapName = Tcl_GetString(objv[i+1]);
d294 2
a295 2
		&& (strncmp(arg, "-screen", length) == 0)) {
	    screenName = Tcl_GetString(objv[i+1]);
d297 2
a298 2
		&& (strncmp(arg, "-use", length) == 0)) {
	    useOption = Tcl_GetString(objv[i+1]);
d300 2
a301 2
		&& (strncmp(arg, "-visual", length) == 0)) {
	    visualName = Tcl_GetString(objv[i+1]);
d324 1
a324 2
	new = Tk_CreateWindowFromPath(interp, tkwin, Tcl_GetString(objv[1]),
		screenName);
d395 2
a396 2
    framePtr->widgetCmd = Tcl_CreateObjCommand(interp,
	    Tk_PathName(new), FrameWidgetObjCmd,
d429 1
a429 1
    if (ConfigureFrame(interp, framePtr, objc-2, objv+2, 0) != TCL_OK) {
d444 1
a444 1
    Tcl_SetResult(interp, Tk_PathName(new), TCL_STATIC);
d457 1
a457 1
 * FrameWidgetObjCmd --
d473 1
a473 1
FrameWidgetObjCmd(clientData, interp, objc, objv)
d476 2
a477 2
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
a478 6
    static char *frameOptions[] = {
	"cget", "configure", (char *) NULL
    };
    enum options {
	FRAME_CGET, FRAME_CONFIGURE
    };
d480 1
a480 1
    int result = TCL_OK, index;
d484 3
a486 6
    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "option ?arg arg ...?");
	return TCL_ERROR;
    }
    if (Tcl_GetIndexFromObj(interp, objv[1], frameOptions, "option", 0,
	    &index) != TCL_OK) {
d490 8
a497 4
    switch ((enum options) index) {
      case FRAME_CGET: {
	if (objc != 3) {
	    Tcl_WrongNumArgs(interp, 2, objv, "option");
d502 4
a505 5
		(char *) framePtr, Tcl_GetString(objv[2]), framePtr->mask);
	break;
      }
      case FRAME_CONFIGURE: {
	if (objc == 2) {
d508 1
a508 1
	} else if (objc == 3) {
d510 1
a510 1
		    (char *) framePtr, Tcl_GetString(objv[2]), framePtr->mask);
d517 2
a518 2
	    for (i = 2; i < objc; i++) {
		char *arg = Tcl_GetStringFromObj(objv[i], (int *) &length);
d522 2
a523 2
		c = arg[1];
		if (((c == 'c') && (strncmp(arg, "-class", length) == 0)
d526 1
a526 1
			&& (strncmp(arg, "-colormap", length) == 0)
d529 1
a529 1
			&& (strncmp(arg, "-container", length) == 0)
d532 1
a532 1
			&& (strncmp(arg, "-screen", length) == 0))
d534 1
a534 1
			&& (strncmp(arg, "-use", length) == 0))
d536 2
a537 2
			&& (strncmp(arg, "-visual", length) == 0))) {
		    Tcl_AppendResult(interp, "can't modify ", arg,
d543 1
a543 1
	    result = ConfigureFrame(interp, framePtr, objc-2, objv+2,
d546 4
a549 2
	break;
      }
d594 1
a594 1
 *	This procedure is called to process an objv/objc list, plus
d600 1
a600 1
 *	returned, then the interp's result contains an error message.
d611 1
a611 1
ConfigureFrame(interp, framePtr, objc, objv, flags)
d615 2
a616 2
    int objc;			/* Number of valid entries in objv. */
    Tcl_Obj *CONST objv[];	/* Arguments. */
d633 1
a633 2
	    objc, (char **) objv, (char *) framePtr,
	    flags | framePtr->mask | TK_CONFIG_OBJS) != TCL_OK) {
d697 1
a697 2
    void (* drawFunction) _ANSI_ARGS_((Tk_Window, Drawable, Tk_3DBorder,
	    int, int, int, int, int, int)) = Tk_Fill3DRectangle;
d706 1
a706 1
	drawFunction(tkwin, Tk_WindowId(tkwin),
a713 4
        GC fgGC, bgGC;
        
	bgGC = Tk_GCForColor(framePtr->highlightBgColorPtr,
		Tk_WindowId(tkwin));
d715 1
a715 3
	    fgGC = Tk_GCForColor(framePtr->highlightColorPtr,
		    Tk_WindowId(tkwin));
	    TkpDrawHighlightBorder(tkwin, fgGC, bgGC, framePtr->highlightWidth,
d718 1
a718 1
	    TkpDrawHighlightBorder(tkwin, bgGC, bgGC, framePtr->highlightWidth,
d721 2
a935 3
	if (framePtr == NULL) {
	    panic("TkInstallFrameMenu couldn't get frame pointer");
	}
a939 1

@


1.1.1.3
log
@import tk 8.4.0
@
text
@d4 2
a5 2
 *	This module implements "frame", "labelframe" and "toplevel" widgets
 *      for the Tk toolkit.  Frames are windows with a background color
d15 1
a15 1
 * RCS: @@(#) $Id: tkFrame.c,v 1.13 2002/08/05 04:30:38 dgp Exp $
a22 8
 * The following enum is used to define the type of the frame.
 */

enum FrameType {
    TYPE_FRAME, TYPE_TOPLEVEL, TYPE_LABELFRAME
};

/*
a37 2
    Tk_OptionTable optionTable;	/* Table that defines configuration options
				 * available for this widget. */
d40 3
a42 1
    enum FrameType type;	/* Type of widget, such as TYPE_FRAME. */
a84 8
    Tcl_Obj *padXPtr;		/* Value of -padx option: specifies how many
				 * pixels of extra space to leave on left and
				 * right of child area. */
    int padX;			/* Integer value corresponding to padXPtr. */
    Tcl_Obj *padYPtr;		/* Value of -padx option: specifies how many
				 * pixels of extra space to leave above and
				 * below child area. */
    int padY;			/* Integer value corresponding to padYPtr. */
a87 46
 * A data structure of the following type is kept for each labelframe
 * widget managed by this file:
 */

typedef struct {
    Frame frame;		/* A pointer to the generic frame structure.
				 * This must be the first element of the
				 * Labelframe. */

    /*
     * Labelframe specific configuration settings.
     */

    Tcl_Obj *textPtr;		/* Value of -text option: specifies text to
				 * display in button. */
    Tk_Font tkfont;		/* Value of -font option: specifies font
				 * to use for display text. */
    XColor *textColorPtr;	/* Value of -fg option: specifies foreground
				 * color in normal mode. */
    int labelAnchor;		/* Value of -labelanchor option: specifies
				 * where to place the label. */
    Tk_Window labelWin;		/* Value of -labelwidget option: Window to
                                 * use as label for the frame. */

    /*
     * Labelframe specific fields for use with configuration settings above.
     */

    GC textGC;			/* GC for drawing text in normal mode. */
    Tk_TextLayout textLayout;	/* Stored text layout information. */
    XRectangle labelBox;	/* The label's actual size and position. */
    int labelReqWidth;		/* The label's requested width. */
    int labelReqHeight;		/* The label's requested height. */
    int labelTextX, labelTextY;	/* Position of the text to be drawn. */

} Labelframe;

/*
 * The following macros define how many extra pixels to leave
 * around a label's text.
 */

#define LABELSPACING 1
#define LABELMARGIN 4

/*
d101 2
a102 149
 * The following enum is used to define a type for the -labelanchor option
 * of the Labelframe widget.  These values are used as indices into the 
 * string table below.
 */

enum labelanchor {
    LABELANCHOR_E, LABELANCHOR_EN, LABELANCHOR_ES,
    LABELANCHOR_N, LABELANCHOR_NE, LABELANCHOR_NW,
    LABELANCHOR_S, LABELANCHOR_SE, LABELANCHOR_SW,
    LABELANCHOR_W, LABELANCHOR_WN, LABELANCHOR_WS
};

static char *labelAnchorStrings[] = {
    "e", "en", "es", "n", "ne", "nw", "s", "se", "sw", "w", "wn", "ws",
    (char *) NULL
};

/*
 * Information used for parsing configuration options.  There are
 * one common table used by all and one table for each widget class.
 */

static Tk_OptionSpec commonOptSpec[] = {
    {TK_OPTION_BORDER, "-background", "background", "Background",
	DEF_FRAME_BG_COLOR, -1, Tk_Offset(Frame, border),
	TK_OPTION_NULL_OK, (ClientData) DEF_FRAME_BG_MONO, 0},
    {TK_OPTION_SYNONYM, "-bg", (char *) NULL, (char *) NULL,
	(char *) NULL, 0, -1, 0, (ClientData) "-background", 0},
    {TK_OPTION_STRING, "-colormap", "colormap", "Colormap",
	DEF_FRAME_COLORMAP, -1, Tk_Offset(Frame, colormapName),
	TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_BOOLEAN, "-container", "container", "Container",
	DEF_FRAME_CONTAINER, -1, Tk_Offset(Frame, isContainer),
	0, 0, 0},
    {TK_OPTION_CURSOR, "-cursor", "cursor", "Cursor",
	DEF_FRAME_CURSOR, -1, Tk_Offset(Frame, cursor),
	TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_PIXELS, "-height", "height", "Height",
	DEF_FRAME_HEIGHT, -1, Tk_Offset(Frame, height),
	0, 0, 0},
    {TK_OPTION_COLOR, "-highlightbackground", "highlightBackground",
	"HighlightBackground", DEF_FRAME_HIGHLIGHT_BG, -1,
	Tk_Offset(Frame, highlightBgColorPtr), 0, 0, 0},
    {TK_OPTION_COLOR, "-highlightcolor", "highlightColor", "HighlightColor",
	DEF_FRAME_HIGHLIGHT, -1, Tk_Offset(Frame, highlightColorPtr),
	0, 0, 0},
    {TK_OPTION_PIXELS, "-highlightthickness", "highlightThickness",
	"HighlightThickness", DEF_FRAME_HIGHLIGHT_WIDTH, -1,
	Tk_Offset(Frame, highlightWidth), 0, 0, 0},
    {TK_OPTION_PIXELS, "-padx", "padX", "Pad",
	DEF_FRAME_PADX, Tk_Offset(Frame, padXPtr),
	Tk_Offset(Frame, padX), 0, 0, 0},
    {TK_OPTION_PIXELS, "-pady", "padY", "Pad",
	DEF_FRAME_PADY, Tk_Offset(Frame, padYPtr),
	Tk_Offset(Frame, padY), 0, 0, 0},
    {TK_OPTION_STRING, "-takefocus", "takeFocus", "TakeFocus",
	DEF_FRAME_TAKE_FOCUS, -1, Tk_Offset(Frame, takeFocus),
	TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_STRING, "-visual", "visual", "Visual",
	DEF_FRAME_VISUAL, -1, Tk_Offset(Frame, visualName),
	TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_PIXELS, "-width", "width", "Width",
	DEF_FRAME_WIDTH, -1, Tk_Offset(Frame, width),
	0, 0, 0},
    {TK_OPTION_END, (char *) NULL, (char *) NULL, (char *) NULL,
	(char *) NULL, 0, 0, 0, 0, 0}
};

static Tk_OptionSpec frameOptSpec[] = {
    {TK_OPTION_SYNONYM, "-bd", (char *) NULL, (char *) NULL,
	(char *) NULL, 0, -1, 0, (ClientData) "-borderwidth", 0},
    {TK_OPTION_PIXELS, "-borderwidth", "borderWidth", "BorderWidth",
	DEF_FRAME_BORDER_WIDTH, -1, Tk_Offset(Frame, borderWidth),
        0, 0, 0},
    {TK_OPTION_STRING, "-class", "class", "Class",
	DEF_FRAME_CLASS, -1, Tk_Offset(Frame, className),
	0, 0, 0},
    {TK_OPTION_RELIEF, "-relief", "relief", "Relief",
	DEF_FRAME_RELIEF, -1, Tk_Offset(Frame, relief),
	0, 0, 0},
    {TK_OPTION_END, (char *) NULL, (char *) NULL, (char *) NULL,
	(char *) NULL, 0, 0, 0, (ClientData) commonOptSpec, 0}
};

static Tk_OptionSpec toplevelOptSpec[] = {
    {TK_OPTION_SYNONYM, "-bd", (char *) NULL, (char *) NULL,
	(char *) NULL, 0, -1, 0, (ClientData) "-borderwidth", 0},
    {TK_OPTION_PIXELS, "-borderwidth", "borderWidth", "BorderWidth",
	DEF_FRAME_BORDER_WIDTH, -1, Tk_Offset(Frame, borderWidth),
        0, 0, 0},
    {TK_OPTION_STRING, "-class", "class", "Class",
	DEF_TOPLEVEL_CLASS, -1, Tk_Offset(Frame, className),
	0, 0, 0},
    {TK_OPTION_STRING, "-menu", "menu", "Menu",
	DEF_TOPLEVEL_MENU, -1, Tk_Offset(Frame, menuName),
	TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_RELIEF, "-relief", "relief", "Relief",
	DEF_FRAME_RELIEF, -1, Tk_Offset(Frame, relief),
	0, 0, 0},
    {TK_OPTION_STRING, "-screen", "screen", "Screen",
	DEF_TOPLEVEL_SCREEN, -1, Tk_Offset(Frame, screenName),
	TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_STRING, "-use", "use", "Use",
	DEF_TOPLEVEL_USE, -1, Tk_Offset(Frame, useThis),
	TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_END, (char *) NULL, (char *) NULL, (char *) NULL,
	(char *) NULL, 0, 0, 0, (ClientData) commonOptSpec, 0}
};

static Tk_OptionSpec labelframeOptSpec[] = {
    {TK_OPTION_SYNONYM, "-bd", (char *) NULL, (char *) NULL,
	(char *) NULL, 0, -1, 0, (ClientData) "-borderwidth", 0},
    {TK_OPTION_PIXELS, "-borderwidth", "borderWidth", "BorderWidth",
	DEF_LABELFRAME_BORDER_WIDTH, -1, Tk_Offset(Frame, borderWidth),
        0, 0, 0},
    {TK_OPTION_STRING, "-class", "class", "Class",
	DEF_LABELFRAME_CLASS, -1, Tk_Offset(Frame, className),
	0, 0, 0},
    {TK_OPTION_SYNONYM, "-fg", "foreground", (char *) NULL,
	(char *) NULL, 0, -1, 0, (ClientData) "-foreground", 0},
    {TK_OPTION_FONT, "-font", "font", "Font",
	DEF_LABELFRAME_FONT, -1, Tk_Offset(Labelframe, tkfont), 0, 0, 0},
    {TK_OPTION_COLOR, "-foreground", "foreground", "Foreground",
	DEF_LABELFRAME_FG, -1, Tk_Offset(Labelframe, textColorPtr), 0, 0, 0},
    {TK_OPTION_STRING_TABLE, "-labelanchor", "labelAnchor", "LabelAnchor",
	DEF_LABELFRAME_LABELANCHOR, -1, Tk_Offset(Labelframe, labelAnchor),
        0, (ClientData) labelAnchorStrings, 0},
    {TK_OPTION_WINDOW, "-labelwidget", "labelWidget", "LabelWidget",
        (char *) NULL, -1, Tk_Offset(Labelframe, labelWin),
        TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_RELIEF, "-relief", "relief", "Relief",
	DEF_LABELFRAME_RELIEF, -1, Tk_Offset(Frame, relief),
	0, 0, 0},
    {TK_OPTION_STRING, "-text", "text", "Text",
	DEF_LABELFRAME_TEXT, Tk_Offset(Labelframe, textPtr), -1,
	TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_END, (char *) NULL, (char *) NULL, (char *) NULL,
	(char *) NULL, 0, 0, 0, (ClientData) commonOptSpec, 0}
};

/*
 * Class names for widgets, indexed by FrameType.
 */

static char *classNames[] = {"Frame", "Toplevel", "Labelframe"};

/*
 * The following table maps from FrameType to the option template for
 * that class of widgets.
d105 58
a162 4
static Tk_OptionSpec *optionSpecs[] = {
    frameOptSpec,
    toplevelOptSpec,
    labelframeOptSpec,
a168 1
static void		ComputeFrameGeometry _ANSI_ARGS_((Frame *framePtr));
d170 2
a171 1
			    Frame *framePtr, int objc, Tcl_Obj *CONST objv[]));
d174 1
a174 1
			    enum FrameType type, char *appName));
a175 1
static void		DestroyFramePartly _ANSI_ARGS_((Frame *framePtr));
a180 6
static void		FrameLostSlaveProc _ANSI_ARGS_((
			    ClientData clientData, Tk_Window tkwin));
static void		FrameRequestProc _ANSI_ARGS_((ClientData clientData,
			    Tk_Window tkwin));
static void		FrameStructureProc _ANSI_ARGS_((
			    ClientData clientData, XEvent *eventPtr));
a182 2
static void		FrameWorldChanged _ANSI_ARGS_((
			    ClientData instanceData));
a183 22

/*
 * The structure below defines frame class behavior by means of procedures
 * that can be invoked from generic window code.
 */

static Tk_ClassProcs frameClass = {
    sizeof(Tk_ClassProcs),	/* size */
    FrameWorldChanged		/* worldChangedProc */
};

/*
 * The structure below defines the official type record for the
 * labelframe's geometry manager:
 */

static Tk_GeomMgr frameGeomType = {
    "labelframe",			/* name */
    FrameRequestProc,			/* requestProc */
    FrameLostSlaveProc			/* lostSlaveProc */
};

d188 1
a188 1
 * Tk_FrameObjCmd, Tk_ToplevelObjCmd, Tk_LabelframeObjCmd --
d190 3
a192 3
 *	These procedures are invoked to process the "frame",
 *      "toplevel" and "labelframe" Tcl commands.  See the user
 *      documentation for details on what they do.
d199 1
a199 1
 *	they call CreateFrame to do all of the real work.
d206 2
a207 1
    ClientData clientData;	/* Either NULL or pointer to option table. */
d212 1
a212 2
    return CreateFrame(clientData, interp, objc, objv, TYPE_FRAME,
	    (char *) NULL);
d217 2
a218 1
    ClientData clientData;	/* Either NULL or pointer to option table. */
d223 1
a223 13
    return CreateFrame(clientData, interp, objc, objv, TYPE_TOPLEVEL,
	    (char *) NULL);
}

int
Tk_LabelframeObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Either NULL or pointer to option table. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    return CreateFrame(clientData, interp, objc, objv, TYPE_LABELFRAME,
	    (char *) NULL);
d231 4
a234 4
 *	This procedure is the old command procedure for the "frame"
 *      and "toplevel" commands.  Now it is used directly by Tk_Init to
 *      create a new main window.  See the user documentation for the
 *      "frame" and "toplevel" commands for details on what it does.
d247 3
a249 1
    ClientData clientData;	/* Either NULL or pointer to option table. */
d255 2
a256 3
    char *appName;		/* Should only be non-NULL if there is no main
				 * window associated with the interpreter.
				 * Gives the base name to use for the
d266 1
a266 2
    result = CreateFrame(clientData, interp, argc, objv,
	    toplevel ? TYPE_TOPLEVEL : TYPE_FRAME, appName);
d275 4
a278 2
CreateFrame(clientData, interp, objc, objv, type, appName)
    ClientData clientData;	/* NULL. */
d282 4
a285 4
    enum FrameType type;	/* What widget type to create. */
    char *appName;		/* Should only be non-NULL if there are no
				 * Main window associated with the interpreter.
				 * Gives the base name to use for the
d288 1
a288 1
    Tk_Window tkwin;
a289 1
    Tk_OptionTable optionTable;
d291 1
a291 1
    CONST char *className, *screenName, *visualName, *colormapName, *arg, *useOption;
a303 7
     * Create the option table for this widget class.  If it has already
     * been created, the cached pointer will be returned.
     */

    optionTable = Tk_CreateOptionTable(interp, optionSpecs[type]);

    /*
d324 1
a324 1
	} else if ((c == 's') && (type == TYPE_TOPLEVEL)
d327 1
a327 1
	} else if ((c == 'u') && (type == TYPE_TOPLEVEL)
d352 1
a352 1
	screenName = (type == TYPE_TOPLEVEL) ? "" : NULL;
a353 8

    /*
     * Main window associated with interpreter.
     * If we're called by Tk_Init to create a
     * new application, then this is NULL.
     */

    tkwin = Tk_MainWindow(interp);
d373 1
a373 1
	    className = classNames[type];
d413 1
a413 1
    if (type == TYPE_TOPLEVEL) {
d423 5
a427 11
    if (type == TYPE_LABELFRAME) {
	framePtr = (Frame *) ckalloc(sizeof(Labelframe));
	memset((void *) framePtr, 0, (sizeof(Labelframe)));
    } else {
	framePtr = (Frame *) ckalloc(sizeof(Frame));
	memset((void *) framePtr, 0, (sizeof(Frame)));
    }
    framePtr->tkwin		= new;
    framePtr->display		= Tk_Display(new);
    framePtr->interp		= interp;
    framePtr->widgetCmd		= Tcl_CreateObjCommand(interp,
d430 5
a434 2
    framePtr->optionTable = optionTable;
    framePtr->type = type;
d436 2
d439 5
d445 5
a449 6

    if (framePtr->type == TYPE_LABELFRAME) {
	Labelframe *labelframePtr = (Labelframe *) framePtr;
	labelframePtr->labelAnchor = LABELANCHOR_NW;
	labelframePtr->textGC = None;
    }
d454 1
a454 1
    Tk_SetClassProcs(new, &frameClass, (ClientData) framePtr);
d457 1
a457 1
    if (type == TYPE_TOPLEVEL) {
d461 1
a461 3
    if ((Tk_InitOptions(interp, (char *) framePtr, optionTable, new)
	    != TCL_OK) ||
	    (ConfigureFrame(interp, framePtr, objc-2, objv+2) != TCL_OK)) {
d468 3
a470 3
	    Tcl_AppendResult(interp, "A window cannot have both the -use ",
		    "and the -container option set.", (char *) NULL);
	    goto error;
d473 1
a473 1
    if (type == TYPE_TOPLEVEL) {
d511 1
a511 1
    static CONST char *frameOptions[] = {
a520 1
    Tcl_Obj *objPtr;
d538 2
a539 8
        objPtr = Tk_GetOptionValue(interp, (char *) framePtr,
		framePtr->optionTable, objv[2], framePtr->tkwin);
        if (objPtr == NULL) {
	    result = TCL_ERROR;
	    goto done;
        } else {
	    Tcl_SetObjResult(interp, objPtr);
        }
d543 6
a548 11
	if (objc <= 3) {
	    objPtr = Tk_GetOptionInfo(interp, (char *) framePtr,
		    framePtr->optionTable,
		    (objc == 3) ? objv[2] : (Tcl_Obj *) NULL,
		    framePtr->tkwin);
	    if (objPtr == NULL) {
		result = TCL_ERROR;
		goto done;
	    } else {
		Tcl_SetObjResult(interp, objPtr);
	    }
d563 1
a563 1
			|| ((c == 'c')
d569 1
a569 1
			|| ((c == 's') && (framePtr->type == TYPE_TOPLEVEL)
d571 1
a571 1
			|| ((c == 'u') && (framePtr->type == TYPE_TOPLEVEL)
d573 1
a573 1
			|| ((c == 'v')
d581 2
a582 1
	    result = ConfigureFrame(interp, framePtr, objc-2, objv+2);
a615 1
    register Labelframe *labelframePtr = (Labelframe *) memPtr;
d617 2
a618 6
    if (framePtr->type == TYPE_LABELFRAME) {
	Tk_FreeTextLayout(labelframePtr->textLayout);
	if (labelframePtr->textGC != None) {
	    Tk_FreeGC(framePtr->display, labelframePtr->textGC);
	}
    }
a627 41
 * DestroyFramePartly --
 *
 *	This procedure is invoked to clean up everything that needs
 *      tkwin to be defined when deleted.  During the destruction
 *      process tkwin is always set to NULL and this procedure must
 *      be called before that happens.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Some things associated with the frame are freed up.
 *
 *----------------------------------------------------------------------
 */

static void
DestroyFramePartly(framePtr)
    Frame *framePtr;		/* Info about frame widget. */
{
    register Labelframe *labelframePtr = (Labelframe *) framePtr;

    if (framePtr->type == TYPE_LABELFRAME && labelframePtr->labelWin != NULL) {
	Tk_DeleteEventHandler(labelframePtr->labelWin, StructureNotifyMask,
		FrameStructureProc, (ClientData) framePtr);
	Tk_ManageGeometry(labelframePtr->labelWin, (Tk_GeomMgr *) NULL,
		(ClientData) NULL);
	if (framePtr->tkwin != Tk_Parent(labelframePtr->labelWin)) {
	    Tk_UnmaintainGeometry(labelframePtr->labelWin, framePtr->tkwin);
	}
	Tk_UnmapWindow(labelframePtr->labelWin);
	labelframePtr->labelWin = NULL;
    }

    Tk_FreeConfigOptions((char *) framePtr, framePtr->optionTable,
            framePtr->tkwin);
}

/*
 *----------------------------------------------------------------------
 *
d647 1
a647 1
ConfigureFrame(interp, framePtr, objc, objv)
d653 1
a654 1
    Tk_SavedOptions savedOptions;
d656 1
a656 3
    Tk_Window oldWindow = NULL;
    Labelframe *labelframePtr = (Labelframe *) framePtr;

d667 4
a670 10

    if (framePtr->type == TYPE_LABELFRAME) {
	oldWindow = labelframePtr->labelWin;
    }
    if (Tk_SetOptions(interp, (char *) framePtr,
	    framePtr->optionTable, objc, objv,
	    framePtr->tkwin, &savedOptions, (int *) NULL) != TCL_OK) {
	if (oldMenuName != NULL) {
	    ckfree(oldMenuName);
	}
a671 2
    } else {
	Tk_FreeSavedOptions(&savedOptions);
a673 4
    /*
     * A few of the options require additional processing.
     */

d681 1
a681 5

    if (oldMenuName != NULL) {
    	ckfree(oldMenuName);
    }

d691 5
a695 5
    if (framePtr->padX < 0) {
	framePtr->padX = 0;
    }
    if (framePtr->padY < 0) {
	framePtr->padY = 0;
d698 2
a699 64
    /*
     * If a -labelwidget is specified, check that it is valid and set
     * up geometry management for it.
     */

    if (framePtr->type == TYPE_LABELFRAME) {
	if (oldWindow != labelframePtr->labelWin) {
	    if (oldWindow != NULL) {
		Tk_DeleteEventHandler(oldWindow, StructureNotifyMask,
			FrameStructureProc, (ClientData) framePtr);
		Tk_ManageGeometry(oldWindow, (Tk_GeomMgr *) NULL,
			(ClientData) NULL);
		Tk_UnmaintainGeometry(oldWindow, framePtr->tkwin);
		Tk_UnmapWindow(oldWindow);
	    }
	    if (labelframePtr->labelWin != NULL) {
		Tk_Window ancestor, parent, sibling = NULL;

		/*
		 * Make sure that the frame is either the parent of the
		 * window used as label or a descendant of that
		 * parent.  Also, don't allow a top-level window to be
		 * managed inside the frame.
		 */

		parent = Tk_Parent(labelframePtr->labelWin);
		for (ancestor = framePtr->tkwin; ;
		     ancestor = Tk_Parent(ancestor)) {
		    if (ancestor == parent) {
			break;
		    }
		    sibling = ancestor;
		    if (Tk_IsTopLevel(ancestor)) {
			badWindow:
			Tcl_AppendResult(interp, "can't use ",
				Tk_PathName(labelframePtr->labelWin),
				" as label in this frame", (char *) NULL);
			labelframePtr->labelWin = NULL;
			return TCL_ERROR;
		    }
		}
		if (Tk_IsTopLevel(labelframePtr->labelWin)) {
		    goto badWindow;
		}
		if (labelframePtr->labelWin == framePtr->tkwin) {
		    goto badWindow;
		}
		Tk_CreateEventHandler(labelframePtr->labelWin,
			StructureNotifyMask, FrameStructureProc,
			(ClientData) framePtr);
		Tk_ManageGeometry(labelframePtr->labelWin, &frameGeomType,
			(ClientData) framePtr);

		/*
		 * If the frame is not parent to the label, make
		 * sure the label is above its sibling in the stacking
		 * order.
		 */

		if (sibling != NULL) {
		    Tk_RestackWindow(labelframePtr->labelWin, Above, sibling);
		}
	    }
	}
d702 1
a702 165
    FrameWorldChanged((ClientData) framePtr);

    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * FrameWorldChanged --
 *
 *      This procedure is called when the world has changed in some
 *      way and the widget needs to recompute all its graphics contexts
 *	and determine its new geometry.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Frame will be relayed out and redisplayed.
 *
 *---------------------------------------------------------------------------
 */
 
static void
FrameWorldChanged(instanceData)
    ClientData instanceData;	/* Information about widget. */
{
    Frame *framePtr = (Frame *) instanceData;
    Labelframe *labelframePtr = (Labelframe *) framePtr;
    Tk_Window tkwin = framePtr->tkwin;
    XGCValues gcValues;
    GC gc;
    int anyTextLabel, anyWindowLabel;
    int bWidthLeft, bWidthRight, bWidthTop, bWidthBottom;
    char *labelText;

    anyTextLabel = (framePtr->type == TYPE_LABELFRAME) &&
	    (labelframePtr->textPtr != NULL) &&
	    (labelframePtr->labelWin == NULL);
    anyWindowLabel = (framePtr->type == TYPE_LABELFRAME) &&
	    (labelframePtr->labelWin != NULL);

    if (framePtr->type == TYPE_LABELFRAME) {
	/*
	 * The textGC is needed even in the labelWin case, so it's
	 * always created for a labelframe.
	 */

	gcValues.font = Tk_FontId(labelframePtr->tkfont);
	gcValues.foreground = labelframePtr->textColorPtr->pixel;
	gcValues.graphics_exposures = False;
	gc = Tk_GetGC(tkwin, GCForeground | GCFont | GCGraphicsExposures,
		&gcValues);
	if (labelframePtr->textGC != None) {
	    Tk_FreeGC(framePtr->display, labelframePtr->textGC);
	}
	labelframePtr->textGC = gc;

	/*
	 * Calculate label size.
	 */
	
	labelframePtr->labelReqWidth = labelframePtr->labelReqHeight = 0;

	if (anyTextLabel) {
	    labelText = Tcl_GetString(labelframePtr->textPtr);
	    Tk_FreeTextLayout(labelframePtr->textLayout);
	    labelframePtr->textLayout = Tk_ComputeTextLayout(labelframePtr->tkfont,
		    labelText, -1, 0, TK_JUSTIFY_CENTER, 0,
		    &labelframePtr->labelReqWidth, &labelframePtr->labelReqHeight);
	    labelframePtr->labelReqWidth += 2 * LABELSPACING;
	    labelframePtr->labelReqHeight += 2 * LABELSPACING;
	} else if (anyWindowLabel) {
	    labelframePtr->labelReqWidth = Tk_ReqWidth(labelframePtr->labelWin);
	    labelframePtr->labelReqHeight = Tk_ReqHeight(labelframePtr->labelWin);
	}

	/* 
	 * Make sure label size is at least as big as the border.
	 * This simplifies later calculations and gives a better
	 * appearance with thick borders.
	 */
     
	if ((labelframePtr->labelAnchor >= LABELANCHOR_N) && 
		(labelframePtr->labelAnchor <= LABELANCHOR_SW)) {
	    if (labelframePtr->labelReqHeight < framePtr->borderWidth) {
		labelframePtr->labelReqHeight = framePtr->borderWidth;
	    }
	} else {
	    if (labelframePtr->labelReqWidth < framePtr->borderWidth) {
		labelframePtr->labelReqWidth = framePtr->borderWidth;
	    }
	}
    }

    /*
     * Calculate individual border widths.
     */

    bWidthBottom = bWidthTop = bWidthRight = bWidthLeft = 
            framePtr->borderWidth + framePtr->highlightWidth;

    bWidthLeft   += framePtr->padX;
    bWidthRight  += framePtr->padX;
    bWidthTop    += framePtr->padY;
    bWidthBottom += framePtr->padY;
    
    if (anyTextLabel || anyWindowLabel) {
	switch (labelframePtr->labelAnchor) {
	  case LABELANCHOR_E:
	  case LABELANCHOR_EN:
	  case LABELANCHOR_ES:
	    bWidthRight += labelframePtr->labelReqWidth -
		    framePtr->borderWidth;
	    break;
	  case LABELANCHOR_N:
	  case LABELANCHOR_NE:
	  case LABELANCHOR_NW:
	    bWidthTop += labelframePtr->labelReqHeight - framePtr->borderWidth;
	    break;
	  case LABELANCHOR_S:
	  case LABELANCHOR_SE:
	  case LABELANCHOR_SW:
	    bWidthBottom += labelframePtr->labelReqHeight -
		    framePtr->borderWidth;
	    break;
	  default:
	    bWidthLeft += labelframePtr->labelReqWidth - framePtr->borderWidth;
	    break;
	}
    }

    Tk_SetInternalBorderEx(tkwin, bWidthLeft, bWidthRight, bWidthTop,
	    bWidthBottom);

    ComputeFrameGeometry(framePtr);

    /*
     * A labelframe should request size for its label.
     */

    if (framePtr->type == TYPE_LABELFRAME) {
	int minwidth = labelframePtr->labelReqWidth;
	int minheight = labelframePtr->labelReqHeight;
	int padding = framePtr->highlightWidth;
	if (framePtr->borderWidth > 0) {
	    padding += framePtr->borderWidth + LABELMARGIN;
	}
	padding *= 2;
	if ((labelframePtr->labelAnchor >= LABELANCHOR_N) && 
		(labelframePtr->labelAnchor <= LABELANCHOR_SW)) {
	    minwidth += padding;
	    minheight += framePtr->borderWidth + framePtr->highlightWidth;
	} else {
	    minheight += padding;
	    minwidth += framePtr->borderWidth + framePtr->highlightWidth;
	}
	Tk_SetMinimumRequestSize(tkwin, minwidth, minheight);
    }

    if ((framePtr->width > 0) || (framePtr->height > 0)) {
	Tk_GeometryRequest(tkwin, framePtr->width, framePtr->height);
    }

    if (Tk_IsMapped(tkwin)) {
d708 1
a708 142
}

/*
 *----------------------------------------------------------------------
 *
 * ComputeFrameGeometry --
 *
 *	This procedure is called to compute various geometrical
 *	information for a frame, such as where various things get
 *	displayed.  It's called when the window is reconfigured.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Display-related numbers get changed in *framePtr.
 *
 *----------------------------------------------------------------------
 */

static void
ComputeFrameGeometry(framePtr)
    register Frame *framePtr;		/* Information about widget. */
{
    int otherWidth, otherHeight, otherWidthT, otherHeightT, padding;
    int maxWidth, maxHeight;
    Tk_Window tkwin;
    Labelframe *labelframePtr = (Labelframe *) framePtr;

    /*
     * We have nothing to do here unless there is a label.
     */

    if (framePtr->type != TYPE_LABELFRAME) return;
    if ((labelframePtr->textPtr == NULL) &&
	    (labelframePtr->labelWin == NULL))  return;

    tkwin = framePtr->tkwin;

    /* 
     * Calculate the available size for the label
     */

    labelframePtr->labelBox.width = labelframePtr->labelReqWidth;
    labelframePtr->labelBox.height = labelframePtr->labelReqHeight;

    padding = framePtr->highlightWidth;
    if (framePtr->borderWidth > 0) {
        padding += framePtr->borderWidth + LABELMARGIN;
    }
    padding *= 2;

    maxHeight = Tk_Height(tkwin);
    maxWidth  = Tk_Width(tkwin);

    if ((labelframePtr->labelAnchor >= LABELANCHOR_N) && 
            (labelframePtr->labelAnchor <= LABELANCHOR_SW)) {
	maxWidth -= padding;
	if (maxWidth < 1) maxWidth = 1;
    } else {
	maxHeight -= padding;
	if (maxHeight < 1) maxHeight = 1;
    }
    if (labelframePtr->labelBox.width > maxWidth) {
	labelframePtr->labelBox.width = maxWidth;
    }
    if (labelframePtr->labelBox.height > maxHeight) {
	labelframePtr->labelBox.height = maxHeight;
    }

    /*
     * Calculate label and text position.
     * The text's position is based on the requested size (= the text's
     * real size) to get proper alignment if the text does not fit.
     */

    otherWidth   = Tk_Width(tkwin)  - labelframePtr->labelBox.width;
    otherHeight  = Tk_Height(tkwin) - labelframePtr->labelBox.height;
    otherWidthT  = Tk_Width(tkwin)  - labelframePtr->labelReqWidth;
    otherHeightT = Tk_Height(tkwin) - labelframePtr->labelReqHeight;
    padding = framePtr->highlightWidth;

    switch (labelframePtr->labelAnchor) {
      case LABELANCHOR_E:
      case LABELANCHOR_EN:
      case LABELANCHOR_ES:
        labelframePtr->labelTextX = otherWidthT - padding;
        labelframePtr->labelBox.x = otherWidth - padding;
        break;
      case LABELANCHOR_N:
      case LABELANCHOR_NE:
      case LABELANCHOR_NW:
        labelframePtr->labelTextY = padding;
        labelframePtr->labelBox.y = padding;
        break;
      case LABELANCHOR_S:
      case LABELANCHOR_SE:
      case LABELANCHOR_SW:
        labelframePtr->labelTextY = otherHeightT - padding;
        labelframePtr->labelBox.y = otherHeight - padding;
        break;
      default:
        labelframePtr->labelTextX = padding;
        labelframePtr->labelBox.x = padding;
        break;
    }

    if (framePtr->borderWidth > 0) {
        padding += framePtr->borderWidth + LABELMARGIN;
    }

    switch (labelframePtr->labelAnchor) {
      case LABELANCHOR_NW:
      case LABELANCHOR_SW:
        labelframePtr->labelTextX = padding;
        labelframePtr->labelBox.x = padding;
        break;
      case LABELANCHOR_N:
      case LABELANCHOR_S:	
        labelframePtr->labelTextX = otherWidthT / 2;
        labelframePtr->labelBox.x = otherWidth / 2;
        break;
      case LABELANCHOR_NE:
      case LABELANCHOR_SE:
        labelframePtr->labelTextX = otherWidthT - padding;
        labelframePtr->labelBox.x = otherWidth - padding;
        break;
      case LABELANCHOR_EN:
      case LABELANCHOR_WN:
        labelframePtr->labelTextY = padding;
        labelframePtr->labelBox.y = padding;
        break;
      case LABELANCHOR_E:
      case LABELANCHOR_W:
        labelframePtr->labelTextY = otherHeightT / 2;
        labelframePtr->labelBox.y = otherHeight / 2;
        break;
      default:
	labelframePtr->labelTextY = otherHeightT - padding;
	labelframePtr->labelBox.y = otherHeight - padding;
        break;
    }
d734 2
a735 3
    int bdX1, bdY1, bdX2, bdY2, hlWidth;
    Pixmap pixmap;
    TkRegion clipRegion = NULL;
d743 9
a751 7
    /*
     * Highlight shall always be drawn if it exists, so do that first.
     */

    hlWidth = framePtr->highlightWidth;

    if (hlWidth != 0) {
d759 1
a759 1
	    TkpDrawHighlightBorder(tkwin, fgGC, bgGC, hlWidth,
d762 1
a762 1
	    TkpDrawHighlightBorder(tkwin, bgGC, bgGC, hlWidth,
a765 166

    /*
     * If -background is set to "", no interior is drawn.
     */

    if (framePtr->border == NULL) return;

    if (framePtr->type != TYPE_LABELFRAME) {
	/*
	 * There is no label so there is just a simple rectangle to draw.
	 */

	noLabel:
	Tk_Fill3DRectangle(tkwin, Tk_WindowId(tkwin),
		framePtr->border, hlWidth, hlWidth,
		Tk_Width(tkwin) - 2 * hlWidth,
		Tk_Height(tkwin) - 2 * hlWidth,
		framePtr->borderWidth, framePtr->relief);
    } else {
	Labelframe *labelframePtr = (Labelframe *) framePtr;

	if ((labelframePtr->textPtr == NULL) &&
		(labelframePtr->labelWin == NULL)) {
	    goto noLabel;
	}

	/*
	 * In order to avoid screen flashes, this procedure redraws the
	 * frame into off-screen memory, then copies it back on-screen 
	 * in a single operation.  This means there's no point in time 
	 * where the on-screen image has been cleared.
	 */

	pixmap = Tk_GetPixmap(framePtr->display, Tk_WindowId(tkwin),
		Tk_Width(tkwin), Tk_Height(tkwin), Tk_Depth(tkwin));
	
	/* 
	 * Clear the pixmap.
	 */

	Tk_Fill3DRectangle(tkwin, pixmap, framePtr->border, 0, 0,
		Tk_Width(tkwin), Tk_Height(tkwin), 0, TK_RELIEF_FLAT);

	/*
	 * Calculate how the label affects the border's position.
	 */

	bdX1 = bdY1 = hlWidth;
	bdX2 = Tk_Width(tkwin) - hlWidth;
	bdY2 = Tk_Height(tkwin) - hlWidth;

	switch (labelframePtr->labelAnchor) {
	  case LABELANCHOR_E:
	  case LABELANCHOR_EN:
	  case LABELANCHOR_ES:
	    bdX2 -= (labelframePtr->labelBox.width - framePtr->borderWidth)
		    / 2;
	    break;
	  case LABELANCHOR_N:
	  case LABELANCHOR_NE:
	  case LABELANCHOR_NW:
	    /* 
	     * Since the glyphs of the text tend to be in the lower part
             * we favor a lower border position by rounding up.
	     */

	    bdY1 += (labelframePtr->labelBox.height - framePtr->borderWidth +1)
		    / 2;
	    break;
	  case LABELANCHOR_S:
	  case LABELANCHOR_SE:
	  case LABELANCHOR_SW:
	    bdY2 -= (labelframePtr->labelBox.height - framePtr->borderWidth)
		    / 2;
	    break;
	  default:
	    bdX1 += (labelframePtr->labelBox.width - framePtr->borderWidth)
		    / 2;
	    break;
	}

	/* 
         * Draw border
         */

	Tk_Draw3DRectangle(tkwin, pixmap, framePtr->border, bdX1, bdY1,
		bdX2 - bdX1, bdY2 - bdY1, framePtr->borderWidth,
		framePtr->relief);

        if (labelframePtr->labelWin == NULL) {
            /* 
             * Clear behind the label
             */

            Tk_Fill3DRectangle(tkwin, pixmap,
                    framePtr->border, labelframePtr->labelBox.x,
                    labelframePtr->labelBox.y, labelframePtr->labelBox.width,
                    labelframePtr->labelBox.height, 0, TK_RELIEF_FLAT);

            /*
             * Draw label.
	     * If there is not room for the entire label, use clipping to
	     * get a nice appearance.
             */
	    
	    if ((labelframePtr->labelBox.width < labelframePtr->labelReqWidth)
		    || (labelframePtr->labelBox.height < 
			    labelframePtr->labelReqHeight)) {
		clipRegion = TkCreateRegion();
		TkUnionRectWithRegion(&labelframePtr->labelBox, clipRegion,
			clipRegion);
		TkSetRegion(framePtr->display, labelframePtr->textGC,
			clipRegion);
	    }

            Tk_DrawTextLayout(framePtr->display, pixmap,
                    labelframePtr->textGC, labelframePtr->textLayout,
                    labelframePtr->labelTextX + LABELSPACING,
                    labelframePtr->labelTextY + LABELSPACING, 0, -1);

	    if (clipRegion != NULL) {
		XSetClipMask(framePtr->display, labelframePtr->textGC, None);
		TkDestroyRegion(clipRegion);
	    }
        } else {
	    /*
	     * Reposition and map the window (but in different ways depending
	     * on whether the frame is the window's parent).
	     */
            
	    if (framePtr->tkwin == Tk_Parent(labelframePtr->labelWin)) {
		if ((labelframePtr->labelBox.x != Tk_X(labelframePtr->labelWin))
			|| (labelframePtr->labelBox.y !=
				Tk_Y(labelframePtr->labelWin))
			|| (labelframePtr->labelBox.width != 
				Tk_Width(labelframePtr->labelWin))
			|| (labelframePtr->labelBox.height != 
				Tk_Height(labelframePtr->labelWin))) {
		    Tk_MoveResizeWindow(labelframePtr->labelWin,
			    labelframePtr->labelBox.x, labelframePtr->labelBox.y, 
			    labelframePtr->labelBox.width,
			    labelframePtr->labelBox.height);
		}
		Tk_MapWindow(labelframePtr->labelWin);
	    } else {
		Tk_MaintainGeometry(labelframePtr->labelWin, framePtr->tkwin, 
			labelframePtr->labelBox.x, labelframePtr->labelBox.y,
			labelframePtr->labelBox.width,
			labelframePtr->labelBox.height);
	    }
	}


	/*
	 * Everything's been redisplayed;  now copy the pixmap onto the screen
	 * and free up the pixmap.
	 */

	XCopyArea(framePtr->display, pixmap, Tk_WindowId(tkwin),
		labelframePtr->textGC, hlWidth, hlWidth,
		(unsigned) (Tk_Width(tkwin) - 2 * hlWidth),
		(unsigned) (Tk_Height(tkwin) - 2 * hlWidth),
		hlWidth, hlWidth);
	Tk_FreePixmap(framePtr->display, pixmap);
    }

d794 2
a795 4
    if ((eventPtr->type == Expose) && (eventPtr->xexpose.count == 0)) {
	goto redraw;
    } else if (eventPtr->type == ConfigureNotify) {
	ComputeFrameGeometry(framePtr);
d815 1
a815 8

	    /*
	     * Since the tkwin pointer will be gone when we reach
	     * DestroyFrame, we must free all options now.
	     */

            DestroyFramePartly(framePtr);

a893 7
	/* 
	 * Some options need tkwin to be freed, so we free them here,
	 * before setting tkwin to NULL.
	 */

        DestroyFramePartly(framePtr);

a984 27

/*
 *--------------------------------------------------------------
 *
 * FrameStructureProc --
 *
 *	This procedure is invoked whenever StructureNotify events
 *	occur for a window that's managed as label for the frame.
 *	This procudure's only purpose is to clean up when windows
 *	are deleted.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The window is disassociated from the frame when it is
 *	deleted.
 *
 *--------------------------------------------------------------
 */

static void
FrameStructureProc(clientData, eventPtr)
    ClientData clientData;	/* Pointer to record describing frame. */
    XEvent *eventPtr;		/* Describes what just happened. */
{
    Labelframe *labelframePtr = (Labelframe *) clientData;
a985 84
    if (eventPtr->type == DestroyNotify) {
	/*
	 * This should only happen in a labelframe but it doesn't
	 * hurt to be careful.
	 */

	if (labelframePtr->frame.type == TYPE_LABELFRAME) {
	    labelframePtr->labelWin = NULL;
	    FrameWorldChanged((ClientData) labelframePtr);
	}
    }
}

/*
 *--------------------------------------------------------------
 *
 * FrameRequestProc --
 *
 *	This procedure is invoked whenever a window that's associated
 *	with a frame changes its requested dimensions.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The size and location on the screen of the window may change.
 *	depending on the options specified for the frame.
 *
 *--------------------------------------------------------------
 */

static void
FrameRequestProc(clientData, tkwin)
    ClientData clientData;		/* Pointer to record for frame. */
    Tk_Window tkwin;			/* Window that changed its desired
					 * size. */
{
    Frame *framePtr = (Frame *) clientData;

    FrameWorldChanged((ClientData) framePtr);
}

/*
 *--------------------------------------------------------------
 *
 * FrameLostSlaveProc --
 *
 *	This procedure is invoked by Tk whenever some other geometry
 *	claims control over a slave that used to be managed by us.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Forgets all frame-related information about the slave.
 *
 *--------------------------------------------------------------
 */

static void
FrameLostSlaveProc(clientData, tkwin)
    ClientData clientData;	/* Frame structure for slave window that
				 * was stolen away. */
    Tk_Window tkwin;		/* Tk's handle for the slave window. */
{
    Frame *framePtr = (Frame *) clientData;
    Labelframe *labelframePtr = (Labelframe *) clientData;

    /*
     * This should only happen in a labelframe but it doesn't
     * hurt to be careful.
     */
    
    if (labelframePtr->frame.type == TYPE_LABELFRAME) {
	Tk_DeleteEventHandler(labelframePtr->labelWin, StructureNotifyMask,
		FrameStructureProc, (ClientData) labelframePtr);
	if (framePtr->tkwin != Tk_Parent(labelframePtr->labelWin)) {
	    Tk_UnmaintainGeometry(labelframePtr->labelWin, framePtr->tkwin);
	}
	Tk_UnmapWindow(labelframePtr->labelWin);
	labelframePtr->labelWin = NULL;
    }
    FrameWorldChanged((ClientData) framePtr);
}
@


