head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.20.24.42;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.13;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.24;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.50;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.31;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.08;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@/* 
 * tkCanvas.c --
 *
 *	This module implements canvas widgets for the Tk toolkit.
 *	A canvas displays a background and a collection of graphical
 *	objects such as rectangles, lines, and texts.
 *
 * Copyright (c) 1991-1994 The Regents of the University of California.
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
 * Copyright (c) 1998-1999 by Scriptics Corporation.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkCanvas.c,v 1.20 2002/08/05 04:30:38 dgp Exp $
 */

/* #define USE_OLD_TAG_SEARCH 1 */

#include "default.h"
#include "tkInt.h"
#include "tkPort.h"
#include "tkCanvas.h"

/*
 * See tkCanvas.h for key data structures used to implement canvases.
 */

#ifdef USE_OLD_TAG_SEARCH
/*
 * The structure defined below is used to keep track of a tag search
 * in progress.  No field should be accessed by anyone other than
 * StartTagSearch and NextItem.
 */

typedef struct TagSearch {
    TkCanvas *canvasPtr;	/* Canvas widget being searched. */
    Tk_Uid tag;			/* Tag to search for.   0 means return
				 * all items. */
    Tk_Item *currentPtr;	/* Pointer to last item returned. */
    Tk_Item *lastPtr;		/* The item right before the currentPtr
				 * is tracked so if the currentPtr is
				 * deleted we don't have to start from the
				 * beginning. */
    int searchOver;		/* Non-zero means NextItem should always
				 * return NULL. */
} TagSearch;

#else /* USE_OLD_TAG_SEARCH */
/*
 * The structure defined below is used to keep track of a tag search
 * in progress.  No field should be accessed by anyone other than
 * TagSearchScan, TagSearchFirst, TagSearchNext,
 * TagSearchScanExpr, TagSearchEvalExpr, 
 * TagSearchExprInit, TagSearchExprDestroy,
 * TagSearchDestroy.
 * (
 *   Not quite accurate: the TagSearch structure is also accessed from:
 *    CanvasWidgetCmd, FindItems, RelinkItems
 *   The only instances of the structure are owned by:
 *    CanvasWidgetCmd
 *   CanvasWidgetCmd is the only function that calls:
 *    FindItems, RelinkItems
 *   CanvasWidgetCmd, FindItems, RelinkItems, are the only functions that call
 *    TagSearch*
 * )
 */

typedef struct TagSearch {
    TkCanvas *canvasPtr;	/* Canvas widget being searched. */
    Tk_Item *currentPtr;	/* Pointer to last item returned. */
    Tk_Item *lastPtr;		/* The item right before the currentPtr
				 * is tracked so if the currentPtr is
				 * deleted we don't have to start from the
				 * beginning. */
    int searchOver;		/* Non-zero means NextItem should always
				 * return NULL. */
    int type;			/* search type */
    int id;			/* item id for searches by id */

    char *string;		/* tag expression string */
    int stringIndex;		/* current position in string scan */
    int stringLength;		/* length of tag expression string */

    char *rewritebuffer;	/* tag string (after removing escapes) */
    unsigned int rewritebufferAllocated;	/* available space for rewrites */

    TagSearchExpr *expr;	/* compiled tag expression */
} TagSearch;
#endif /* USE_OLD_TAG_SEARCH */

/*
 * Custom option for handling "-state" and "-offset"
 */

static Tk_CustomOption stateOption = {
    (Tk_OptionParseProc *) TkStateParseProc,
    TkStatePrintProc,
    (ClientData) NULL	/* only "normal" and "disabled" */
};

static Tk_CustomOption offsetOption = {
    (Tk_OptionParseProc *) TkOffsetParseProc,
    TkOffsetPrintProc,
    (ClientData) TK_OFFSET_RELATIVE
};

/*
 * Information used for argv parsing.
 */

static Tk_ConfigSpec configSpecs[] = {
    {TK_CONFIG_BORDER, "-background", "background", "Background",
	DEF_CANVAS_BG_COLOR, Tk_Offset(TkCanvas, bgBorder),
	TK_CONFIG_COLOR_ONLY},
    {TK_CONFIG_BORDER, "-background", "background", "Background",
	DEF_CANVAS_BG_MONO, Tk_Offset(TkCanvas, bgBorder),
	TK_CONFIG_MONO_ONLY},
    {TK_CONFIG_SYNONYM, "-bd", "borderWidth", (char *) NULL,
	(char *) NULL, 0, 0},
    {TK_CONFIG_SYNONYM, "-bg", "background", (char *) NULL,
	(char *) NULL, 0, 0},
    {TK_CONFIG_PIXELS, "-borderwidth", "borderWidth", "BorderWidth",
	DEF_CANVAS_BORDER_WIDTH, Tk_Offset(TkCanvas, borderWidth), 0},
    {TK_CONFIG_DOUBLE, "-closeenough", "closeEnough", "CloseEnough",
	DEF_CANVAS_CLOSE_ENOUGH, Tk_Offset(TkCanvas, closeEnough), 0},
    {TK_CONFIG_BOOLEAN, "-confine", "confine", "Confine",
	DEF_CANVAS_CONFINE, Tk_Offset(TkCanvas, confine), 0},
    {TK_CONFIG_ACTIVE_CURSOR, "-cursor", "cursor", "Cursor",
	DEF_CANVAS_CURSOR, Tk_Offset(TkCanvas, cursor), TK_CONFIG_NULL_OK},
    {TK_CONFIG_PIXELS, "-height", "height", "Height",
	DEF_CANVAS_HEIGHT, Tk_Offset(TkCanvas, height), 0},
    {TK_CONFIG_COLOR, "-highlightbackground", "highlightBackground",
	"HighlightBackground", DEF_CANVAS_HIGHLIGHT_BG,
	Tk_Offset(TkCanvas, highlightBgColorPtr), 0},
    {TK_CONFIG_COLOR, "-highlightcolor", "highlightColor", "HighlightColor",
	DEF_CANVAS_HIGHLIGHT, Tk_Offset(TkCanvas, highlightColorPtr), 0},
    {TK_CONFIG_PIXELS, "-highlightthickness", "highlightThickness",
	"HighlightThickness",
	DEF_CANVAS_HIGHLIGHT_WIDTH, Tk_Offset(TkCanvas, highlightWidth), 0},
    {TK_CONFIG_BORDER, "-insertbackground", "insertBackground", "Foreground",
	DEF_CANVAS_INSERT_BG, Tk_Offset(TkCanvas, textInfo.insertBorder), 0},
    {TK_CONFIG_PIXELS, "-insertborderwidth", "insertBorderWidth", "BorderWidth",
	DEF_CANVAS_INSERT_BD_COLOR,
	Tk_Offset(TkCanvas, textInfo.insertBorderWidth), TK_CONFIG_COLOR_ONLY},
    {TK_CONFIG_PIXELS, "-insertborderwidth", "insertBorderWidth", "BorderWidth",
	DEF_CANVAS_INSERT_BD_MONO,
	Tk_Offset(TkCanvas, textInfo.insertBorderWidth), TK_CONFIG_MONO_ONLY},
    {TK_CONFIG_INT, "-insertofftime", "insertOffTime", "OffTime",
	DEF_CANVAS_INSERT_OFF_TIME, Tk_Offset(TkCanvas, insertOffTime), 0},
    {TK_CONFIG_INT, "-insertontime", "insertOnTime", "OnTime",
	DEF_CANVAS_INSERT_ON_TIME, Tk_Offset(TkCanvas, insertOnTime), 0},
    {TK_CONFIG_PIXELS, "-insertwidth", "insertWidth", "InsertWidth",
	DEF_CANVAS_INSERT_WIDTH, Tk_Offset(TkCanvas, textInfo.insertWidth), 0},
    {TK_CONFIG_CUSTOM, "-offset", "offset", "Offset", "0,0",
	Tk_Offset(TkCanvas, tsoffset),TK_CONFIG_DONT_SET_DEFAULT,
	&offsetOption},
    {TK_CONFIG_RELIEF, "-relief", "relief", "Relief",
	DEF_CANVAS_RELIEF, Tk_Offset(TkCanvas, relief), 0},
    {TK_CONFIG_STRING, "-scrollregion", "scrollRegion", "ScrollRegion",
	DEF_CANVAS_SCROLL_REGION, Tk_Offset(TkCanvas, regionString),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_BORDER, "-selectbackground", "selectBackground", "Foreground",
	DEF_CANVAS_SELECT_COLOR, Tk_Offset(TkCanvas, textInfo.selBorder),
	TK_CONFIG_COLOR_ONLY},
    {TK_CONFIG_BORDER, "-selectbackground", "selectBackground", "Foreground",
	DEF_CANVAS_SELECT_MONO, Tk_Offset(TkCanvas, textInfo.selBorder),
	TK_CONFIG_MONO_ONLY},
    {TK_CONFIG_PIXELS, "-selectborderwidth", "selectBorderWidth", "BorderWidth",
	DEF_CANVAS_SELECT_BD_COLOR,
	Tk_Offset(TkCanvas, textInfo.selBorderWidth), TK_CONFIG_COLOR_ONLY},
    {TK_CONFIG_PIXELS, "-selectborderwidth", "selectBorderWidth", "BorderWidth",
	DEF_CANVAS_SELECT_BD_MONO, Tk_Offset(TkCanvas, textInfo.selBorderWidth),
	TK_CONFIG_MONO_ONLY},
    {TK_CONFIG_COLOR, "-selectforeground", "selectForeground", "Background",
	DEF_CANVAS_SELECT_FG_COLOR, Tk_Offset(TkCanvas, textInfo.selFgColorPtr),
	TK_CONFIG_COLOR_ONLY},
    {TK_CONFIG_COLOR, "-selectforeground", "selectForeground", "Background",
	DEF_CANVAS_SELECT_FG_MONO, Tk_Offset(TkCanvas, textInfo.selFgColorPtr),
	TK_CONFIG_MONO_ONLY},
    {TK_CONFIG_CUSTOM, "-state", "state", "State",
	"normal", Tk_Offset(TkCanvas, canvas_state), TK_CONFIG_DONT_SET_DEFAULT,
	&stateOption},
    {TK_CONFIG_STRING, "-takefocus", "takeFocus", "TakeFocus",
	DEF_CANVAS_TAKE_FOCUS, Tk_Offset(TkCanvas, takeFocus),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_PIXELS, "-width", "width", "Width",
	DEF_CANVAS_WIDTH, Tk_Offset(TkCanvas, width), 0},
    {TK_CONFIG_STRING, "-xscrollcommand", "xScrollCommand", "ScrollCommand",
	DEF_CANVAS_X_SCROLL_CMD, Tk_Offset(TkCanvas, xScrollCmd),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_PIXELS, "-xscrollincrement", "xScrollIncrement",
	"ScrollIncrement",
	DEF_CANVAS_X_SCROLL_INCREMENT, Tk_Offset(TkCanvas, xScrollIncrement),
	0},
    {TK_CONFIG_STRING, "-yscrollcommand", "yScrollCommand", "ScrollCommand",
	DEF_CANVAS_Y_SCROLL_CMD, Tk_Offset(TkCanvas, yScrollCmd),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_PIXELS, "-yscrollincrement", "yScrollIncrement",
	"ScrollIncrement",
	DEF_CANVAS_Y_SCROLL_INCREMENT, Tk_Offset(TkCanvas, yScrollIncrement),
	0},
    {TK_CONFIG_END, (char *) NULL, (char *) NULL, (char *) NULL,
	(char *) NULL, 0, 0}
};

/*
 * List of all the item types known at present:
 */

static Tk_ItemType *typeList = NULL;	/* NULL means initialization hasn't
					 * been done yet. */

#ifndef USE_OLD_TAG_SEARCH
/*
 * Uids for operands in compiled advanced tag search expressions
 * Initialization is done by InitCanvas()
 */
static Tk_Uid allUid = NULL;
static Tk_Uid currentUid = NULL;
static Tk_Uid andUid = NULL;
static Tk_Uid orUid = NULL;
static Tk_Uid xorUid = NULL;
static Tk_Uid parenUid = NULL;
static Tk_Uid negparenUid = NULL;
static Tk_Uid endparenUid = NULL;
static Tk_Uid tagvalUid = NULL;
static Tk_Uid negtagvalUid = NULL;
#endif /* USE_OLD_TAG_SEARCH */

/*
 * Standard item types provided by Tk:
 */

extern Tk_ItemType tkArcType, tkBitmapType, tkImageType, tkLineType;
extern Tk_ItemType tkOvalType, tkPolygonType;
extern Tk_ItemType tkRectangleType, tkTextType, tkWindowType;

/*
 * Prototypes for procedures defined later in this file:
 */

static void		CanvasBindProc _ANSI_ARGS_((ClientData clientData,
			    XEvent *eventPtr));
static void		CanvasBlinkProc _ANSI_ARGS_((ClientData clientData));
static void		CanvasCmdDeletedProc _ANSI_ARGS_((
			    ClientData clientData));
static void		CanvasDoEvent _ANSI_ARGS_((TkCanvas *canvasPtr,
			    XEvent *eventPtr));
static void		CanvasEventProc _ANSI_ARGS_((ClientData clientData,
			    XEvent *eventPtr));
static int		CanvasFetchSelection _ANSI_ARGS_((
			    ClientData clientData, int offset,
			    char *buffer, int maxBytes));
static Tk_Item *	CanvasFindClosest _ANSI_ARGS_((TkCanvas *canvasPtr,
			    double coords[2]));
static void		CanvasFocusProc _ANSI_ARGS_((TkCanvas *canvasPtr,
			    int gotFocus));
static void		CanvasLostSelection _ANSI_ARGS_((
			    ClientData clientData));
static void		CanvasSelectTo _ANSI_ARGS_((TkCanvas *canvasPtr,
			    Tk_Item *itemPtr, int index));
static void		CanvasSetOrigin _ANSI_ARGS_((TkCanvas *canvasPtr,
			    int xOrigin, int yOrigin));
static void		CanvasUpdateScrollbars _ANSI_ARGS_((
			    TkCanvas *canvasPtr));
static int		CanvasWidgetCmd _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, int argc, Tcl_Obj *CONST *argv));
static void		CanvasWorldChanged _ANSI_ARGS_((
			    ClientData instanceData));
static int		ConfigureCanvas _ANSI_ARGS_((Tcl_Interp *interp,
			    TkCanvas *canvasPtr, int argc, Tcl_Obj *CONST *argv,
			    int flags));
static void		DestroyCanvas _ANSI_ARGS_((char *memPtr));
static void		DisplayCanvas _ANSI_ARGS_((ClientData clientData));
static void		DoItem _ANSI_ARGS_((Tcl_Interp *interp,
			    Tk_Item *itemPtr, Tk_Uid tag));
static void		EventuallyRedrawItem _ANSI_ARGS_((Tk_Canvas canvas,
			    Tk_Item *itemPtr));
#ifdef USE_OLD_TAG_SEARCH
static int		FindItems _ANSI_ARGS_((Tcl_Interp *interp,
			    TkCanvas *canvasPtr, int argc, Tcl_Obj *CONST *argv,
			    Tcl_Obj *newTagObj, int first));
#else /* USE_OLD_TAG_SEARCH */
static int		FindItems _ANSI_ARGS_((Tcl_Interp *interp,
			    TkCanvas *canvasPtr, int argc, Tcl_Obj *CONST *argv,
			    Tcl_Obj *newTagObj, int first,
			    TagSearch **searchPtrPtr));
#endif /* USE_OLD_TAG_SEARCH */
static int		FindArea _ANSI_ARGS_((Tcl_Interp *interp,
			    TkCanvas *canvasPtr, Tcl_Obj *CONST *argv, Tk_Uid uid,
			    int enclosed));
static double		GridAlign _ANSI_ARGS_((double coord, double spacing));
static CONST char**	GetStringsFromObjs _ANSI_ARGS_((int argc,
			    Tcl_Obj *CONST *objv));
static void		InitCanvas _ANSI_ARGS_((void));
#ifdef USE_OLD_TAG_SEARCH
static Tk_Item *	NextItem _ANSI_ARGS_((TagSearch *searchPtr));
#endif /* USE_OLD_TAG_SEARCH */
static void		PickCurrentItem _ANSI_ARGS_((TkCanvas *canvasPtr,
			    XEvent *eventPtr));
static Tcl_Obj *	ScrollFractions _ANSI_ARGS_((int screen1,
			    int screen2, int object1, int object2));
#ifdef USE_OLD_TAG_SEARCH
static void		RelinkItems _ANSI_ARGS_((TkCanvas *canvasPtr,
			    Tcl_Obj *tag, Tk_Item *prevPtr));
static Tk_Item *	StartTagSearch _ANSI_ARGS_((TkCanvas *canvasPtr,
			    Tcl_Obj *tag, TagSearch *searchPtr));
#else /* USE_OLD_TAG_SEARCH */
static int		RelinkItems _ANSI_ARGS_((TkCanvas *canvasPtr,
			    Tcl_Obj *tag, Tk_Item *prevPtr,
			    TagSearch **searchPtrPtr));
static void 		TagSearchExprInit _ANSI_ARGS_ ((
			    TagSearchExpr **exprPtrPtr));
static void		TagSearchExprDestroy _ANSI_ARGS_((TagSearchExpr *expr));
static void		TagSearchDestroy _ANSI_ARGS_((TagSearch *searchPtr));
static int		TagSearchScan _ANSI_ARGS_((TkCanvas *canvasPtr,
			    Tcl_Obj *tag, TagSearch **searchPtrPtr));
static int		TagSearchScanExpr _ANSI_ARGS_((Tcl_Interp *interp,
			    TagSearch *searchPtr, TagSearchExpr *expr));
static int		TagSearchEvalExpr _ANSI_ARGS_((TagSearchExpr *expr,
			    Tk_Item *itemPtr));
static Tk_Item *	TagSearchFirst _ANSI_ARGS_((TagSearch *searchPtr));
static Tk_Item *	TagSearchNext _ANSI_ARGS_((TagSearch *searchPtr));
#endif /* USE_OLD_TAG_SEARCH */

/*
 * The structure below defines canvas class behavior by means of procedures
 * that can be invoked from generic window code.
 */

static Tk_ClassProcs canvasClass = {
    sizeof(Tk_ClassProcs),	/* size */
    CanvasWorldChanged,		/* worldChangedProc */
};


/*
 *--------------------------------------------------------------
 *
 * Tk_CanvasObjCmd --
 *
 *	This procedure is invoked to process the "canvas" Tcl
 *	command.  See the user documentation for details on what
 *	it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *--------------------------------------------------------------
 */

int
Tk_CanvasObjCmd(clientData, interp, argc, argv)
    ClientData clientData;		/* Main window associated with
				 * interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int argc;			/* Number of arguments. */
    Tcl_Obj *CONST argv[];	/* Argument objects. */
{
    Tk_Window tkwin = (Tk_Window) clientData;
    TkCanvas *canvasPtr;
    Tk_Window new;

    if (typeList == NULL) {
	InitCanvas();
    }

    if (argc < 2) {
	Tcl_WrongNumArgs(interp, 1, argv, "pathName ?options?");
	return TCL_ERROR;
    }

    new = Tk_CreateWindowFromPath(interp, tkwin,
	    Tcl_GetString(argv[1]), (char *) NULL);
    if (new == NULL) {
	return TCL_ERROR;
    }

    /*
     * Initialize fields that won't be initialized by ConfigureCanvas,
     * or which ConfigureCanvas expects to have reasonable values
     * (e.g. resource pointers).
     */

    canvasPtr = (TkCanvas *) ckalloc(sizeof(TkCanvas));
    canvasPtr->tkwin = new;
    canvasPtr->display = Tk_Display(new);
    canvasPtr->interp = interp;
    canvasPtr->widgetCmd = Tcl_CreateObjCommand(interp,
	    Tk_PathName(canvasPtr->tkwin), CanvasWidgetCmd,
	    (ClientData) canvasPtr, CanvasCmdDeletedProc);
    canvasPtr->firstItemPtr = NULL;
    canvasPtr->lastItemPtr = NULL;
    canvasPtr->borderWidth = 0;
    canvasPtr->bgBorder = NULL;
    canvasPtr->relief = TK_RELIEF_FLAT;
    canvasPtr->highlightWidth = 0;
    canvasPtr->highlightBgColorPtr = NULL;
    canvasPtr->highlightColorPtr = NULL;
    canvasPtr->inset = 0;
    canvasPtr->pixmapGC = None;
    canvasPtr->width = None;
    canvasPtr->height = None;
    canvasPtr->confine = 0;
    canvasPtr->textInfo.selBorder = NULL;
    canvasPtr->textInfo.selBorderWidth = 0;
    canvasPtr->textInfo.selFgColorPtr = NULL;
    canvasPtr->textInfo.selItemPtr = NULL;
    canvasPtr->textInfo.selectFirst = -1;
    canvasPtr->textInfo.selectLast = -1;
    canvasPtr->textInfo.anchorItemPtr = NULL;
    canvasPtr->textInfo.selectAnchor = 0;
    canvasPtr->textInfo.insertBorder = NULL;
    canvasPtr->textInfo.insertWidth = 0;
    canvasPtr->textInfo.insertBorderWidth = 0;
    canvasPtr->textInfo.focusItemPtr = NULL;
    canvasPtr->textInfo.gotFocus = 0;
    canvasPtr->textInfo.cursorOn = 0;
    canvasPtr->insertOnTime = 0;
    canvasPtr->insertOffTime = 0;
    canvasPtr->insertBlinkHandler = (Tcl_TimerToken) NULL;
    canvasPtr->xOrigin = canvasPtr->yOrigin = 0;
    canvasPtr->drawableXOrigin = canvasPtr->drawableYOrigin = 0;
    canvasPtr->bindingTable = NULL;
    canvasPtr->currentItemPtr = NULL;
    canvasPtr->newCurrentPtr = NULL;
    canvasPtr->closeEnough = 0.0;
    canvasPtr->pickEvent.type = LeaveNotify;
    canvasPtr->pickEvent.xcrossing.x = 0;
    canvasPtr->pickEvent.xcrossing.y = 0;
    canvasPtr->state = 0;
    canvasPtr->xScrollCmd = NULL;
    canvasPtr->yScrollCmd = NULL;
    canvasPtr->scrollX1 = 0;
    canvasPtr->scrollY1 = 0;
    canvasPtr->scrollX2 = 0;
    canvasPtr->scrollY2 = 0;
    canvasPtr->regionString = NULL;
    canvasPtr->xScrollIncrement = 0;
    canvasPtr->yScrollIncrement = 0;
    canvasPtr->scanX = 0;
    canvasPtr->scanXOrigin = 0;
    canvasPtr->scanY = 0;
    canvasPtr->scanYOrigin = 0;
    canvasPtr->hotPtr = NULL;
    canvasPtr->hotPrevPtr = NULL;
    canvasPtr->cursor = None;
    canvasPtr->takeFocus = NULL;
    canvasPtr->pixelsPerMM = WidthOfScreen(Tk_Screen(new));
    canvasPtr->pixelsPerMM /= WidthMMOfScreen(Tk_Screen(new));
    canvasPtr->flags = 0;
    canvasPtr->nextId = 1;
    canvasPtr->psInfo = NULL;
    canvasPtr->canvas_state = TK_STATE_NORMAL;
    canvasPtr->tsoffset.flags = 0;
    canvasPtr->tsoffset.xoffset = 0;
    canvasPtr->tsoffset.yoffset = 0;
#ifndef USE_OLD_TAG_SEARCH
    canvasPtr->bindTagExprs = NULL;
#endif
    Tcl_InitHashTable(&canvasPtr->idTable, TCL_ONE_WORD_KEYS);

    Tk_SetClass(canvasPtr->tkwin, "Canvas");
    Tk_SetClassProcs(canvasPtr->tkwin, &canvasClass, (ClientData) canvasPtr);
    Tk_CreateEventHandler(canvasPtr->tkwin,
	    ExposureMask|StructureNotifyMask|FocusChangeMask,
	    CanvasEventProc, (ClientData) canvasPtr);
    Tk_CreateEventHandler(canvasPtr->tkwin, KeyPressMask|KeyReleaseMask
	    |ButtonPressMask|ButtonReleaseMask|EnterWindowMask
	    |LeaveWindowMask|PointerMotionMask|VirtualEventMask,
	    CanvasBindProc, (ClientData) canvasPtr);
    Tk_CreateSelHandler(canvasPtr->tkwin, XA_PRIMARY, XA_STRING,
	    CanvasFetchSelection, (ClientData) canvasPtr, XA_STRING);
    if (ConfigureCanvas(interp, canvasPtr, argc-2, argv+2, 0) != TCL_OK) {
	goto error;
    }

    Tcl_SetResult(interp, Tk_PathName(canvasPtr->tkwin), TCL_STATIC);
    return TCL_OK;

    error:
    Tk_DestroyWindow(canvasPtr->tkwin);
    return TCL_ERROR;
}

/*
 *--------------------------------------------------------------
 *
 * CanvasWidgetCmd --
 *
 *	This procedure is invoked to process the Tcl command
 *	that corresponds to a widget managed by this module.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *--------------------------------------------------------------
 */

static int
CanvasWidgetCmd(clientData, interp, argc, argv)
    ClientData clientData;		/* Information about canvas
					 * widget. */
    Tcl_Interp *interp;			/* Current interpreter. */
    int argc;				/* Number of arguments. */
    Tcl_Obj *CONST argv[];		/* Argument objects. */
{
    TkCanvas *canvasPtr = (TkCanvas *) clientData;
    unsigned int length;
    int c, result;
    Tk_Item *itemPtr = NULL;		/* Initialization needed only to
					 * prevent compiler warning. */
#ifdef USE_OLD_TAG_SEARCH
    TagSearch search;
#else /* USE_OLD_TAG_SEARCH */
    TagSearch *searchPtr = NULL;	/* Allocated by first TagSearchScan
					 * Freed by TagSearchDestroy */
#endif /* USE_OLD_TAG_SEARCH */

    int index;
    static CONST char *optionStrings[] = {
	"addtag",	"bbox",		"bind",		"canvasx",
	"canvasy",	"cget",		"configure",	"coords",
	"create",	"dchars",	"delete",	"dtag",
	"find",		"focus",	"gettags",	"icursor",
	"index",	"insert",	"itemcget",	"itemconfigure",
	"lower",	"move",		"postscript",	"raise",
	"scale",	"scan",		"select",	"type",
	"xview",	"yview",
	NULL
    };
    enum options {
	CANV_ADDTAG,	CANV_BBOX,	CANV_BIND,	CANV_CANVASX,
	CANV_CANVASY,	CANV_CGET,	CANV_CONFIGURE,	CANV_COORDS,
	CANV_CREATE,	CANV_DCHARS,	CANV_DELETE,	CANV_DTAG,
	CANV_FIND,	CANV_FOCUS,	CANV_GETTAGS,	CANV_ICURSOR,
	CANV_INDEX,	CANV_INSERT,	CANV_ITEMCGET,	CANV_ITEMCONFIGURE,
	CANV_LOWER,	CANV_MOVE,	CANV_POSTSCRIPT,CANV_RAISE,
	CANV_SCALE,	CANV_SCAN,	CANV_SELECT,	CANV_TYPE,
	CANV_XVIEW,	CANV_YVIEW
    };

    if (argc < 2) {
	Tcl_WrongNumArgs(interp, 1, argv, "option ?arg arg ...?");
	return TCL_ERROR;
    }
    if (Tcl_GetIndexFromObj(interp, argv[1], optionStrings, "option", 0,
	    &index) != TCL_OK) {
	return TCL_ERROR;
    }
    Tcl_Preserve((ClientData) canvasPtr);

    result = TCL_OK;
    switch ((enum options) index) {
      case CANV_ADDTAG: {
	if (argc < 4) {
	    Tcl_WrongNumArgs(interp, 2, argv, "tag searchCommand ?arg arg ...?");
	    result = TCL_ERROR;
	    goto done;
	}
#ifdef USE_OLD_TAG_SEARCH
	result = FindItems(interp, canvasPtr, argc, argv, argv[2], 3);
#else /* USE_OLD_TAG_SEARCH */
	result = FindItems(interp, canvasPtr, argc, argv, argv[2], 3, &searchPtr);
#endif /* USE_OLD_TAG_SEARCH */
	break;
      }

      case CANV_BBOX: {
	int i, gotAny;
	int x1 = 0, y1 = 0, x2 = 0, y2 = 0;	/* Initializations needed
						 * only to prevent compiler
						 * warnings. */

	if (argc < 3) {
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId ?tagOrId ...?");
	    result = TCL_ERROR;
	    goto done;
	}
	gotAny = 0;
	for (i = 2; i < argc; i++) {
#ifdef USE_OLD_TAG_SEARCH
	    for (itemPtr = StartTagSearch(canvasPtr, argv[i], &search);
		    itemPtr != NULL; itemPtr = NextItem(&search)) {
#else /* USE_OLD_TAG_SEARCH */
	    if ((result = TagSearchScan(canvasPtr, argv[i], &searchPtr)) != TCL_OK) {
		goto done;
	    }
	    for (itemPtr = TagSearchFirst(searchPtr);
		    itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */

		if ((itemPtr->x1 >= itemPtr->x2)
			|| (itemPtr->y1 >= itemPtr->y2)) {
		    continue;
		}
		if (!gotAny) {
		    x1 = itemPtr->x1;
		    y1 = itemPtr->y1;
		    x2 = itemPtr->x2;
		    y2 = itemPtr->y2;
		    gotAny = 1;
		} else {
		    if (itemPtr->x1 < x1) {
			x1 = itemPtr->x1;
		    }
		    if (itemPtr->y1 < y1) {
			y1 = itemPtr->y1;
		    }
		    if (itemPtr->x2 > x2) {
			x2 = itemPtr->x2;
		    }
		    if (itemPtr->y2 > y2) {
			y2 = itemPtr->y2;
		    }
		}
	    }
	}
	if (gotAny) {
	    char buf[TCL_INTEGER_SPACE * 4];
	    
	    sprintf(buf, "%d %d %d %d", x1, y1, x2, y2);
	    Tcl_SetResult(interp, buf, TCL_VOLATILE);
	}
	break;
      }
      case CANV_BIND: {
	ClientData object;

	if ((argc < 3) || (argc > 5)) {
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId ?sequence? ?command?");
	    result = TCL_ERROR;
	    goto done;
	}

	/*
	 * Figure out what object to use for the binding (individual
	 * item vs. tag).
	 */

	object = 0;
#ifdef USE_OLD_TAG_SEARCH
	if (isdigit(UCHAR(Tcl_GetString(argv[2])[0]))) {
	    int id;
	    char *end;
	    Tcl_HashEntry *entryPtr;

	    id = strtoul(Tcl_GetString(argv[2]), &end, 0);
	    if (*end != 0) {
		goto bindByTag;
	    }
	    entryPtr = Tcl_FindHashEntry(&canvasPtr->idTable, (char *) id);
	    if (entryPtr != NULL) {
		itemPtr = (Tk_Item *) Tcl_GetHashValue(entryPtr);
		object = (ClientData) itemPtr;
	    }

	    if (object == 0) {
		Tcl_AppendResult(interp, "item \"", Tcl_GetString(argv[2]),
			"\" doesn't exist", (char *) NULL);
		result = TCL_ERROR;
		goto done;
	    }
	} else {
	    bindByTag:
	    object = (ClientData) Tk_GetUid(Tcl_GetString(argv[2]));
	}
#else /* USE_OLD_TAG_SEARCH */
	if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
	    goto done;
	}
	if (searchPtr->type == 1) {
	    Tcl_HashEntry *entryPtr;

	    entryPtr = Tcl_FindHashEntry(&canvasPtr->idTable, (char *) searchPtr->id);
	    if (entryPtr != NULL) {
		itemPtr = (Tk_Item *) Tcl_GetHashValue(entryPtr);
		object = (ClientData) itemPtr;
	    }

	    if (object == 0) {
		Tcl_AppendResult(interp, "item \"", Tcl_GetString(argv[2]),
			"\" doesn't exist", (char *) NULL);
		result = TCL_ERROR;
		goto done;
	    }
	} else {
    	    object = (ClientData) searchPtr->expr->uid;
	}
#endif /* USE_OLD_TAG_SEARCH */

	/*
	 * Make a binding table if the canvas doesn't already have
	 * one.
	 */

	if (canvasPtr->bindingTable == NULL) {
	    canvasPtr->bindingTable = Tk_CreateBindingTable(interp);
	}

	if (argc == 5) {
	    int append = 0;
	    unsigned long mask;
	    char* argv4 = Tcl_GetStringFromObj(argv[4],NULL);

	    if (argv4[0] == 0) {
		result = Tk_DeleteBinding(interp, canvasPtr->bindingTable,
			object, Tcl_GetStringFromObj(argv[3], NULL));
		goto done;
	    }
#ifndef USE_OLD_TAG_SEARCH
	    if (searchPtr->type == 4) {
	        /*
	         * if new tag expression, then insert in linked list
	         */
	    	TagSearchExpr *expr, **lastPtr;

		lastPtr = &(canvasPtr->bindTagExprs);
		while ((expr = *lastPtr) != NULL) {
		    if (expr->uid == searchPtr->expr->uid) {
			break;
		    }
		    lastPtr = &(expr->next);
		}
		if (!expr) {
		    /*
		     * transfer ownership of expr to bindTagExprs list
		     */
		    *lastPtr = searchPtr->expr;
		    searchPtr->expr->next = NULL;

		    /*
		     * flag in TagSearch that expr has changed ownership
		     * so that TagSearchDestroy doesn't try to free it
		     */
		    searchPtr->expr = NULL;
		}
            }
#endif /* not USE_OLD_TAG_SEARCH */
	    if (argv4[0] == '+') {
		argv4++;
		append = 1;
	    }
	    mask = Tk_CreateBinding(interp, canvasPtr->bindingTable,
		    object, Tcl_GetStringFromObj(argv[3],NULL), argv4, append);
	    if (mask == 0) {
		result = TCL_ERROR;
		goto done;
	    }
	    if (mask & (unsigned) ~(ButtonMotionMask|Button1MotionMask
		    |Button2MotionMask|Button3MotionMask|Button4MotionMask
		    |Button5MotionMask|ButtonPressMask|ButtonReleaseMask
		    |EnterWindowMask|LeaveWindowMask|KeyPressMask
		    |KeyReleaseMask|PointerMotionMask|VirtualEventMask)) {
		Tk_DeleteBinding(interp, canvasPtr->bindingTable,
			object, Tcl_GetStringFromObj(argv[3], NULL));
		Tcl_ResetResult(interp);
		Tcl_AppendResult(interp, "requested illegal events; ",
			"only key, button, motion, enter, leave, and virtual ",
			"events may be used", (char *) NULL);
		result = TCL_ERROR;
		goto done;
	    }
	} else if (argc == 4) {
	    CONST char *command;
    
	    command = Tk_GetBinding(interp, canvasPtr->bindingTable,
		    object, Tcl_GetStringFromObj(argv[3], NULL));
	    if (command == NULL) {
		CONST char *string;

		string = Tcl_GetStringResult(interp); 
		/*
		 * Ignore missing binding errors.  This is a special hack
		 * that relies on the error message returned by FindSequence
		 * in tkBind.c.
		 */

		if (string[0] != '\0') {
		    result = TCL_ERROR;
		    goto done;
		} else {
		    Tcl_ResetResult(interp);
		}
	    } else {
		Tcl_SetResult(interp, (char *) command, TCL_STATIC);
	    }
	} else {
	    Tk_GetAllBindings(interp, canvasPtr->bindingTable, object);
	}
	break;
      }
      case CANV_CANVASX: {
	int x;
	double grid;
	char buf[TCL_DOUBLE_SPACE];

	if ((argc < 3) || (argc > 4)) {
	    Tcl_WrongNumArgs(interp, 2, argv, "screenx ?gridspacing?");
	    result = TCL_ERROR;
	    goto done;
	}
	if (Tk_GetPixelsFromObj(interp, canvasPtr->tkwin, argv[2], &x) != TCL_OK) {
	    result = TCL_ERROR;
	    goto done;
	}
	if (argc == 4) {
	    if (Tk_CanvasGetCoordFromObj(interp, (Tk_Canvas) canvasPtr, argv[3],
		    &grid) != TCL_OK) {
		result = TCL_ERROR;
		goto done;
	    }
	} else {
	    grid = 0.0;
	}
	x += canvasPtr->xOrigin;
	Tcl_PrintDouble(interp, GridAlign((double) x, grid), buf);
	Tcl_SetResult(interp, buf, TCL_VOLATILE);
	break;
      }
      case CANV_CANVASY: {
	int y;
	double grid;
	char buf[TCL_DOUBLE_SPACE];

	if ((argc < 3) || (argc > 4)) {
	    Tcl_WrongNumArgs(interp, 2, argv, "screeny ?gridspacing?");
	    result = TCL_ERROR;
	    goto done;
	}
	if (Tk_GetPixelsFromObj(interp, canvasPtr->tkwin, argv[2], &y) != TCL_OK) {
	    result = TCL_ERROR;
	    goto done;
	}
	if (argc == 4) {
	    if (Tk_CanvasGetCoordFromObj(interp, (Tk_Canvas) canvasPtr,
		    argv[3], &grid) != TCL_OK) {
		result = TCL_ERROR;
		goto done;
	    }
	} else {
	    grid = 0.0;
	}
	y += canvasPtr->yOrigin;
	Tcl_PrintDouble(interp, GridAlign((double) y, grid), buf);
	Tcl_SetResult(interp, buf, TCL_VOLATILE);
	break;
      }
      case CANV_CGET: {
	if (argc != 3) {
	    Tcl_WrongNumArgs(interp, 2, argv, "option");
	    result = TCL_ERROR;
	    goto done;
	}
	result = Tk_ConfigureValue(interp, canvasPtr->tkwin, configSpecs,
		(char *) canvasPtr, Tcl_GetString(argv[2]), 0);
	break;
      }
      case CANV_CONFIGURE: {
	if (argc == 2) {
	    result = Tk_ConfigureInfo(interp, canvasPtr->tkwin, configSpecs,
		    (char *) canvasPtr, (char *) NULL, 0);
	} else if (argc == 3) {
	    result = Tk_ConfigureInfo(interp, canvasPtr->tkwin, configSpecs,
		    (char *) canvasPtr, Tcl_GetString(argv[2]), 0);
	} else {
	    result = ConfigureCanvas(interp, canvasPtr, argc-2, argv+2,
		    TK_CONFIG_ARGV_ONLY);
	}
	break;
      }
      case CANV_COORDS: {
	if (argc < 3) {
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId ?x y x y ...?");
	    result = TCL_ERROR;
	    goto done;
	}
#ifdef USE_OLD_TAG_SEARCH
	itemPtr = StartTagSearch(canvasPtr, argv[2], &search);
#else /* USE_OLD_TAG_SEARCH */
	if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
	    goto done;
	}
	itemPtr = TagSearchFirst(searchPtr);
#endif /* USE_OLD_TAG_SEARCH */
	if (itemPtr != NULL) {
	    if (argc != 3) {
		EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
	    }
	    if (itemPtr->typePtr->coordProc != NULL) {
	      if (itemPtr->typePtr->alwaysRedraw & TK_CONFIG_OBJS) {
		result = (*itemPtr->typePtr->coordProc)(interp,
			(Tk_Canvas) canvasPtr, itemPtr, argc-3, argv+3);
	      } else {
		CONST char **args = GetStringsFromObjs(argc-3, argv+3);
		result = (*itemPtr->typePtr->coordProc)(interp,
			(Tk_Canvas) canvasPtr, itemPtr, argc-3, (Tcl_Obj **) args);
		if (args) ckfree((char *) args);
	      }
	    }
	    if (argc != 3) {
		EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
	    }
	}
	break;
      }
      case CANV_CREATE: {
	Tk_ItemType *typePtr;
	Tk_ItemType *matchPtr = NULL;
	Tk_Item *itemPtr;
	char buf[TCL_INTEGER_SPACE];
	int isNew = 0;
	Tcl_HashEntry *entryPtr;
	char *arg;

	if (argc < 3) {
	    Tcl_WrongNumArgs(interp, 2, argv, "type ?arg arg ...?");
	    result = TCL_ERROR;
	    goto done;
	}
	arg = Tcl_GetStringFromObj(argv[2], (int *) &length);
	c = arg[0];
	for (typePtr = typeList; typePtr != NULL; typePtr = typePtr->nextPtr) {
	    if ((c == typePtr->name[0])
		    && (strncmp(arg, typePtr->name, length) == 0)) {
		if (matchPtr != NULL) {
		    badType:
		    Tcl_AppendResult(interp,
			    "unknown or ambiguous item type \"",
			    arg, "\"", (char *) NULL);
		    result = TCL_ERROR;
		    goto done;
		}
		matchPtr = typePtr;
	    }
	}
	if (matchPtr == NULL) {
	    goto badType;
	}
	typePtr = matchPtr;
	itemPtr = (Tk_Item *) ckalloc((unsigned) typePtr->itemSize);
	itemPtr->id = canvasPtr->nextId;
	canvasPtr->nextId++;
	itemPtr->tagPtr = itemPtr->staticTagSpace;
	itemPtr->tagSpace = TK_TAG_SPACE;
	itemPtr->numTags = 0;
	itemPtr->typePtr = typePtr;
	itemPtr->state = TK_STATE_NULL;
	itemPtr->redraw_flags = 0;
	if (itemPtr->typePtr->alwaysRedraw & TK_CONFIG_OBJS) {
	  result = (*typePtr->createProc)(interp, (Tk_Canvas) canvasPtr,
		itemPtr, argc-3, argv+3);
	} else {
	  CONST char **args = GetStringsFromObjs(argc-3, argv+3);
	  result = (*typePtr->createProc)(interp, (Tk_Canvas) canvasPtr,
		itemPtr, argc-3, (Tcl_Obj **) args);
	  if (args) ckfree((char *) args);
	}
	if (result != TCL_OK) {
	    ckfree((char *) itemPtr);
	    result = TCL_ERROR;
	    goto done;
	}
	itemPtr->nextPtr = NULL;
	entryPtr = Tcl_CreateHashEntry(&canvasPtr->idTable,
		(char *) itemPtr->id, &isNew);
	Tcl_SetHashValue(entryPtr, itemPtr);
	itemPtr->prevPtr = canvasPtr->lastItemPtr;
	canvasPtr->hotPtr = itemPtr;
	canvasPtr->hotPrevPtr = canvasPtr->lastItemPtr;
	if (canvasPtr->lastItemPtr == NULL) {
	    canvasPtr->firstItemPtr = itemPtr;
	} else {
	    canvasPtr->lastItemPtr->nextPtr = itemPtr;
	}
	canvasPtr->lastItemPtr = itemPtr;
	itemPtr->redraw_flags |= FORCE_REDRAW;
	EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
	canvasPtr->flags |= REPICK_NEEDED;
	sprintf(buf, "%d", itemPtr->id);
	Tcl_SetResult(interp, buf, TCL_VOLATILE);
	break;
      }
      case CANV_DCHARS: {
	int first, last;
	int x1,x2,y1,y2;

	if ((argc != 4) && (argc != 5)) {
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId first ?last?");
	    result = TCL_ERROR;
	    goto done;
	}
#ifdef USE_OLD_TAG_SEARCH
	for (itemPtr = StartTagSearch(canvasPtr, argv[2], &search);
		itemPtr != NULL; itemPtr = NextItem(&search)) {
#else /* USE_OLD_TAG_SEARCH */
	if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
	    goto done;
	}
	for (itemPtr = TagSearchFirst(searchPtr);
		itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
	    if ((itemPtr->typePtr->indexProc == NULL)
		    || (itemPtr->typePtr->dCharsProc == NULL)) {
		continue;
	    }
	    if (itemPtr->typePtr->alwaysRedraw & TK_CONFIG_OBJS) {
		result = itemPtr->typePtr->indexProc(interp, (Tk_Canvas) canvasPtr,
			itemPtr, (char *) argv[3], &first);
	    } else {
		result = itemPtr->typePtr->indexProc(interp, (Tk_Canvas) canvasPtr,
			itemPtr, Tcl_GetStringFromObj(argv[3], NULL), &first);
	    }
	    if (result != TCL_OK) {
		goto done;
	    }
	    if (argc == 5) {
		if (itemPtr->typePtr->alwaysRedraw & TK_CONFIG_OBJS) {
		    result = itemPtr->typePtr->indexProc(interp, (Tk_Canvas) canvasPtr,
			    itemPtr, (char *) argv[4], &last);
		} else {
		    result = itemPtr->typePtr->indexProc(interp, (Tk_Canvas) canvasPtr,
			    itemPtr, Tcl_GetStringFromObj(argv[4], NULL), &last);
		}
		if (result != TCL_OK) {
		    goto done;
		}
	    } else {
		last = first;
	    }

	    /*
	     * Redraw both item's old and new areas:  it's possible
	     * that a delete could result in a new area larger than
	     * the old area. Except if the insertProc sets the
	     * TK_ITEM_DONT_REDRAW flag, nothing more needs to be done.
	     */

	    x1 = itemPtr->x1; y1 = itemPtr->y1;
	    x2 = itemPtr->x2; y2 = itemPtr->y2;
	    itemPtr->redraw_flags &= ~TK_ITEM_DONT_REDRAW;
	    (*itemPtr->typePtr->dCharsProc)((Tk_Canvas) canvasPtr,
		    itemPtr, first, last);
	    if (!(itemPtr->redraw_flags & TK_ITEM_DONT_REDRAW)) {
		Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
			x1, y1, x2, y2);
		EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
	    }
	    itemPtr->redraw_flags &= ~TK_ITEM_DONT_REDRAW;
	}
	break;
      }
      case CANV_DELETE: {
	int i;
	Tcl_HashEntry *entryPtr;

	for (i = 2; i < argc; i++) {
#ifdef USE_OLD_TAG_SEARCH
	    for (itemPtr = StartTagSearch(canvasPtr, argv[i], &search);
		itemPtr != NULL; itemPtr = NextItem(&search)) {
#else /* USE_OLD_TAG_SEARCH */
	    if ((result = TagSearchScan(canvasPtr, argv[i], &searchPtr)) != TCL_OK) {
		goto done;
	    }
	    for (itemPtr = TagSearchFirst(searchPtr);
		itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
		EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
		if (canvasPtr->bindingTable != NULL) {
		    Tk_DeleteAllBindings(canvasPtr->bindingTable,
			    (ClientData) itemPtr);
		}
		(*itemPtr->typePtr->deleteProc)((Tk_Canvas) canvasPtr, itemPtr,
			canvasPtr->display);
		if (itemPtr->tagPtr != itemPtr->staticTagSpace) {
		    ckfree((char *) itemPtr->tagPtr);
		}
		entryPtr = Tcl_FindHashEntry(&canvasPtr->idTable,
			(char *) itemPtr->id);
		Tcl_DeleteHashEntry(entryPtr);
		if (itemPtr->nextPtr != NULL) {
		    itemPtr->nextPtr->prevPtr = itemPtr->prevPtr;
		}
		if (itemPtr->prevPtr != NULL) {
		    itemPtr->prevPtr->nextPtr = itemPtr->nextPtr;
		}
		if (canvasPtr->firstItemPtr == itemPtr) {
		    canvasPtr->firstItemPtr = itemPtr->nextPtr;
		    if (canvasPtr->firstItemPtr == NULL) {
			canvasPtr->lastItemPtr = NULL;
		    }
		}
		if (canvasPtr->lastItemPtr == itemPtr) {
		    canvasPtr->lastItemPtr = itemPtr->prevPtr;
		}
		ckfree((char *) itemPtr);
		if (itemPtr == canvasPtr->currentItemPtr) {
		    canvasPtr->currentItemPtr = NULL;
		    canvasPtr->flags |= REPICK_NEEDED;
		}
		if (itemPtr == canvasPtr->newCurrentPtr) {
		    canvasPtr->newCurrentPtr = NULL;
		    canvasPtr->flags |= REPICK_NEEDED;
		}
		if (itemPtr == canvasPtr->textInfo.focusItemPtr) {
		    canvasPtr->textInfo.focusItemPtr = NULL;
		}
		if (itemPtr == canvasPtr->textInfo.selItemPtr) {
		    canvasPtr->textInfo.selItemPtr = NULL;
		}
		if ((itemPtr == canvasPtr->hotPtr)
			|| (itemPtr == canvasPtr->hotPrevPtr)) {
		    canvasPtr->hotPtr = NULL;
		}
	    }
	}
	break;
      }
      case CANV_DTAG: {
	Tk_Uid tag;
	int i;

	if ((argc != 3) && (argc != 4)) {
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId ?tagToDelete?");
	    result = TCL_ERROR;
	    goto done;
	}
	if (argc == 4) {
	    tag = Tk_GetUid(Tcl_GetStringFromObj(argv[3], NULL));
	} else {
	    tag = Tk_GetUid(Tcl_GetStringFromObj(argv[2], NULL));
	}
#ifdef USE_OLD_TAG_SEARCH
	for (itemPtr = StartTagSearch(canvasPtr, argv[2], &search);
		itemPtr != NULL; itemPtr = NextItem(&search)) {
#else /* USE_OLD_TAG_SEARCH */
        if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
            goto done;
        }
        for (itemPtr = TagSearchFirst(searchPtr);
                itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
	    for (i = itemPtr->numTags-1; i >= 0; i--) {
		if (itemPtr->tagPtr[i] == tag) {
		    itemPtr->tagPtr[i] = itemPtr->tagPtr[itemPtr->numTags-1];
		    itemPtr->numTags--;
		}
	    }
	}
	break;
      }
      case CANV_FIND: {
	if (argc < 3) {
	    Tcl_WrongNumArgs(interp, 2, argv, "searchCommand ?arg arg ...?");
	    result = TCL_ERROR;
	    goto done;
	}
#ifdef USE_OLD_TAG_SEARCH
	result = FindItems(interp, canvasPtr, argc, argv, (Tcl_Obj *) NULL, 2);
#else /* USE_OLD_TAG_SEARCH */
	result = FindItems(interp, canvasPtr, argc, argv,
	    (Tcl_Obj *) NULL, 2, &searchPtr);
#endif /* USE_OLD_TAG_SEARCH */
	break;
      }
      case CANV_FOCUS: {
	if (argc > 3) {
	    Tcl_WrongNumArgs(interp, 2, argv, "?tagOrId?");
	    result = TCL_ERROR;
	    goto done;
	}
	itemPtr = canvasPtr->textInfo.focusItemPtr;
	if (argc == 2) {
	    if (itemPtr != NULL) {
		char buf[TCL_INTEGER_SPACE];
		
		sprintf(buf, "%d", itemPtr->id);
		Tcl_SetResult(interp, buf, TCL_VOLATILE);
	    }
	    goto done;
	}
	if ((itemPtr != NULL) && (canvasPtr->textInfo.gotFocus)) {
	    EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
	}
	if (Tcl_GetStringFromObj(argv[2], NULL)[0] == 0) {
	    canvasPtr->textInfo.focusItemPtr = NULL;
	    goto done;
	}
#ifdef USE_OLD_TAG_SEARCH
	for (itemPtr = StartTagSearch(canvasPtr, argv[2], &search);
		itemPtr != NULL; itemPtr = NextItem(&search)) {
#else /* USE_OLD_TAG_SEARCH */
        if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
            goto done;
        }
        for (itemPtr = TagSearchFirst(searchPtr);
                itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
	    if (itemPtr->typePtr->icursorProc != NULL) {
		break;
	    }
	}
	if (itemPtr == NULL) {
	    goto done;
	}
	canvasPtr->textInfo.focusItemPtr = itemPtr;
	if (canvasPtr->textInfo.gotFocus) {
	    EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
	}
	break;
      }
      case CANV_GETTAGS: {
	if (argc != 3) {
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId");
	    result = TCL_ERROR;
	    goto done;
	}
#ifdef USE_OLD_TAG_SEARCH
	itemPtr = StartTagSearch(canvasPtr, argv[2], &search);
#else /* USE_OLD_TAG_SEARCH */
        if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
            goto done;
        }
        itemPtr = TagSearchFirst(searchPtr);
#endif /* USE_OLD_TAG_SEARCH */
	if (itemPtr != NULL) {
	    int i;
	    for (i = 0; i < itemPtr->numTags; i++) {
		Tcl_AppendElement(interp, (char *) itemPtr->tagPtr[i]);
	    }
	}
	break;
      }
      case CANV_ICURSOR: {
	int index;

	if (argc != 4) {
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId index");
	    result = TCL_ERROR;
	    goto done;
	}
#ifdef USE_OLD_TAG_SEARCH
	for (itemPtr = StartTagSearch(canvasPtr, argv[2], &search);
		itemPtr != NULL; itemPtr = NextItem(&search)) {
#else /* USE_OLD_TAG_SEARCH */
        if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
            goto done;
        }
        for (itemPtr = TagSearchFirst(searchPtr);
                itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
	    if ((itemPtr->typePtr->indexProc == NULL)
		    || (itemPtr->typePtr->icursorProc == NULL)) {
		goto done;
	    }
	    if (itemPtr->typePtr->alwaysRedraw & TK_CONFIG_OBJS) {
		result = itemPtr->typePtr->indexProc(interp, (Tk_Canvas) canvasPtr,
			itemPtr, (char *) argv[3], &index);
	    } else {
		result = itemPtr->typePtr->indexProc(interp, (Tk_Canvas) canvasPtr,
			itemPtr, Tcl_GetStringFromObj(argv[3], NULL), &index);
	    }
	    if (result != TCL_OK) {
		goto done;
	    }
	    (*itemPtr->typePtr->icursorProc)((Tk_Canvas) canvasPtr, itemPtr,
		    index);
	    if ((itemPtr == canvasPtr->textInfo.focusItemPtr)
		    && (canvasPtr->textInfo.cursorOn)) {
		EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
	    }
	}
	break;
      }
      case CANV_INDEX: {

	int index;
	char buf[TCL_INTEGER_SPACE];

	if (argc != 4) {
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId string");
	    result = TCL_ERROR;
	    goto done;
	}
#ifdef USE_OLD_TAG_SEARCH
	for (itemPtr = StartTagSearch(canvasPtr, argv[2], &search);
		itemPtr != NULL; itemPtr = NextItem(&search)) {
#else /* USE_OLD_TAG_SEARCH */
        if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
            goto done;
        }
        for (itemPtr = TagSearchFirst(searchPtr);
                itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
	    if (itemPtr->typePtr->indexProc != NULL) {
		break;
	    }
	}
	if (itemPtr == NULL) {
	    Tcl_AppendResult(interp, "can't find an indexable item \"",
		    Tcl_GetStringFromObj(argv[2], NULL), "\"", (char *) NULL);
	    result = TCL_ERROR;
	    goto done;
	}
	if (itemPtr->typePtr->alwaysRedraw & TK_CONFIG_OBJS) {
	    result = itemPtr->typePtr->indexProc(interp, (Tk_Canvas) canvasPtr,
		    itemPtr, (char *) argv[3], &index);
	} else {
	    result = itemPtr->typePtr->indexProc(interp, (Tk_Canvas) canvasPtr,
		    itemPtr, Tcl_GetStringFromObj(argv[3], NULL), &index);
	}
	if (result != TCL_OK) {
	    goto done;
	}
	sprintf(buf, "%d", index);
	Tcl_SetResult(interp, buf, TCL_VOLATILE);
	break;
      }
      case CANV_INSERT: {
	int beforeThis;
	int x1,x2,y1,y2;

	if (argc != 5) {
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId beforeThis string");
	    result = TCL_ERROR;
	    goto done;
	}
#ifdef USE_OLD_TAG_SEARCH
	for (itemPtr = StartTagSearch(canvasPtr, argv[2], &search);
		itemPtr != NULL; itemPtr = NextItem(&search)) {
#else /* USE_OLD_TAG_SEARCH */
        if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
            goto done;
        }
        for (itemPtr = TagSearchFirst(searchPtr);
                itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
	    if ((itemPtr->typePtr->indexProc == NULL)
		    || (itemPtr->typePtr->insertProc == NULL)) {
		continue;
	    }
	    if (itemPtr->typePtr->alwaysRedraw & TK_CONFIG_OBJS) {
		result = itemPtr->typePtr->indexProc(interp, (Tk_Canvas) canvasPtr,
			itemPtr, (char *) argv[3], &beforeThis);
	    } else {
		result = itemPtr->typePtr->indexProc(interp, (Tk_Canvas) canvasPtr,
			itemPtr, Tcl_GetStringFromObj(argv[3], NULL), &beforeThis);
	    }
	    if (result != TCL_OK) {
		goto done;
	    }

	    /*
	     * Redraw both item's old and new areas:  it's possible
	     * that an insertion could result in a new area either
	     * larger or smaller than the old area. Except if the
	     * insertProc sets the TK_ITEM_DONT_REDRAW flag, nothing
	     * more needs to be done.
	     */

	    x1 = itemPtr->x1; y1 = itemPtr->y1;
	    x2 = itemPtr->x2; y2 = itemPtr->y2;
	    itemPtr->redraw_flags &= ~TK_ITEM_DONT_REDRAW;
	    if (itemPtr->typePtr->alwaysRedraw & TK_CONFIG_OBJS) {
		(*itemPtr->typePtr->insertProc)((Tk_Canvas) canvasPtr,
			itemPtr, beforeThis, (char *) argv[4]);
	    } else {
		(*itemPtr->typePtr->insertProc)((Tk_Canvas) canvasPtr,
			itemPtr, beforeThis, Tcl_GetStringFromObj(argv[4], NULL));
	    }
	    if (!(itemPtr->redraw_flags & TK_ITEM_DONT_REDRAW)) {
		Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
			x1, y1, x2, y2);
		EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
	    }
	    itemPtr->redraw_flags &= ~TK_ITEM_DONT_REDRAW;
	}
	break;
      }
      case CANV_ITEMCGET: {
	if (argc != 4) {
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId option");
	    result = TCL_ERROR;
	    goto done;
	}
#ifdef USE_OLD_TAG_SEARCH
	itemPtr = StartTagSearch(canvasPtr, argv[2], &search);
#else /* USE_OLD_TAG_SEARCH */
        if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
            goto done;
        }
        itemPtr = TagSearchFirst(searchPtr);
#endif /* USE_OLD_TAG_SEARCH */
	if (itemPtr != NULL) {
	    result = Tk_ConfigureValue(canvasPtr->interp, canvasPtr->tkwin,
		    itemPtr->typePtr->configSpecs, (char *) itemPtr,
		    Tcl_GetStringFromObj(argv[3], NULL), 0);
	}
	break;
      }
      case CANV_ITEMCONFIGURE: {
	if (argc < 3) {
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId ?option value ...?");
	    result = TCL_ERROR;
	    goto done;
	}
#ifdef USE_OLD_TAG_SEARCH
	for (itemPtr = StartTagSearch(canvasPtr, argv[2], &search);
		itemPtr != NULL; itemPtr = NextItem(&search)) {
#else /* USE_OLD_TAG_SEARCH */
        if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
            goto done;
        }
        for (itemPtr = TagSearchFirst(searchPtr);
                itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
	    if (argc == 3) {
		result = Tk_ConfigureInfo(canvasPtr->interp, canvasPtr->tkwin,
			itemPtr->typePtr->configSpecs, (char *) itemPtr,
			(char *) NULL, 0);
	    } else if (argc == 4) {
		result = Tk_ConfigureInfo(canvasPtr->interp, canvasPtr->tkwin,
			itemPtr->typePtr->configSpecs, (char *) itemPtr,
			Tcl_GetString(argv[3]), 0);
	    } else {
		EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
		if (itemPtr->typePtr->alwaysRedraw & TK_CONFIG_OBJS) {
		result = (*itemPtr->typePtr->configProc)(interp,
			(Tk_Canvas) canvasPtr, itemPtr, argc-3, argv+3,
			TK_CONFIG_ARGV_ONLY);
		} else {
		CONST char **args = GetStringsFromObjs(argc-3, argv+3);
		result = (*itemPtr->typePtr->configProc)(interp,
			(Tk_Canvas) canvasPtr, itemPtr, argc-3, (Tcl_Obj **) args,
			TK_CONFIG_ARGV_ONLY);
		if (args) ckfree((char *) args);
		}
		EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
		canvasPtr->flags |= REPICK_NEEDED;
	    }
	    if ((result != TCL_OK) || (argc < 5)) {
		break;
	    }
	}
	break;
      }
      case CANV_LOWER: {
	Tk_Item *itemPtr;

	if ((argc != 3) && (argc != 4)) {
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId ?belowThis?");
	    result = TCL_ERROR;
	    goto done;
	}

	/*
	 * First find the item just after which we'll insert the
	 * named items.
	 */

	if (argc == 3) {
	    itemPtr = NULL;
	} else {
#ifdef USE_OLD_TAG_SEARCH
	    itemPtr = StartTagSearch(canvasPtr, argv[3], &search);
#else /* USE_OLD_TAG_SEARCH */
            if ((result = TagSearchScan(canvasPtr, argv[3], &searchPtr)) != TCL_OK) {
                goto done;
            }
            itemPtr = TagSearchFirst(searchPtr);
#endif /* USE_OLD_TAG_SEARCH */
	    if (itemPtr == NULL) {
		Tcl_AppendResult(interp, "tag \"", Tcl_GetString(argv[3]),
			"\" doesn't match any items", (char *) NULL);
		goto done;
	    }
	    itemPtr = itemPtr->prevPtr;
	}
#ifdef USE_OLD_TAG_SEARCH
	RelinkItems(canvasPtr, argv[2], itemPtr);
#else /* USE_OLD_TAG_SEARCH */
        if ((result = RelinkItems(canvasPtr, argv[2], itemPtr, &searchPtr)) != TCL_OK) {
            goto done;
        }
#endif /* USE_OLD_TAG_SEARCH */
	break;
      }
      case CANV_MOVE: {
	double xAmount, yAmount;

	if (argc != 5) {
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId xAmount yAmount");
	    result = TCL_ERROR;
	    goto done;
	}
	if ((Tk_CanvasGetCoordFromObj(interp, (Tk_Canvas) canvasPtr, argv[3],
		&xAmount) != TCL_OK) || (Tk_CanvasGetCoordFromObj(interp,
		(Tk_Canvas) canvasPtr, argv[4], &yAmount) != TCL_OK)) {
	    result = TCL_ERROR;
	    goto done;
	}
#ifdef USE_OLD_TAG_SEARCH
	for (itemPtr = StartTagSearch(canvasPtr, argv[2], &search);
		itemPtr != NULL; itemPtr = NextItem(&search)) {
#else /* USE_OLD_TAG_SEARCH */
        if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
            goto done;
        }
        for (itemPtr = TagSearchFirst(searchPtr);
                itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
	    EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
	    (void) (*itemPtr->typePtr->translateProc)((Tk_Canvas) canvasPtr,
		    itemPtr,  xAmount, yAmount);
	    EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
	    canvasPtr->flags |= REPICK_NEEDED;
	}
	break;
      }
      case CANV_POSTSCRIPT: {
	CONST char **args = GetStringsFromObjs(argc, argv);
	result = TkCanvPostscriptCmd(canvasPtr, interp, argc, args);
	if (args) ckfree((char *) args);
	break;
      }
      case CANV_RAISE: {
	Tk_Item *prevPtr;

	if ((argc != 3) && (argc != 4)) {
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId ?aboveThis?");
	    result = TCL_ERROR;
	    goto done;
	}

	/*
	 * First find the item just after which we'll insert the
	 * named items.
	 */

	if (argc == 3) {
	    prevPtr = canvasPtr->lastItemPtr;
	} else {
	    prevPtr = NULL;
#ifdef USE_OLD_TAG_SEARCH
	    for (itemPtr = StartTagSearch(canvasPtr, argv[3], &search);
		    itemPtr != NULL; itemPtr = NextItem(&search)) {
#else /* USE_OLD_TAG_SEARCH */
            if ((result = TagSearchScan(canvasPtr, argv[3], &searchPtr)) != TCL_OK) {
                goto done;
            }
            for (itemPtr = TagSearchFirst(searchPtr);
                    itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
		prevPtr = itemPtr;
	    }
	    if (prevPtr == NULL) {
		Tcl_AppendResult(interp, "tagOrId \"", Tcl_GetStringFromObj(argv[3], NULL),
			"\" doesn't match any items", (char *) NULL);
		result = TCL_ERROR;
		goto done;
	    }
	}
#ifdef USE_OLD_TAG_SEARCH
	RelinkItems(canvasPtr, argv[2], prevPtr);
#else /* USE_OLD_TAG_SEARCH */
        result = RelinkItems(canvasPtr, argv[2], prevPtr, &searchPtr);
        if (result != TCL_OK) {
            goto done;
        }
#endif /* USE_OLD_TAG_SEARCH */
	break;
      }
      case CANV_SCALE: {
	double xOrigin, yOrigin, xScale, yScale;

	if (argc != 7) {
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId xOrigin yOrigin xScale yScale");
	    result = TCL_ERROR;
	    goto done;
	}
	if ((Tk_CanvasGetCoordFromObj(interp, (Tk_Canvas) canvasPtr,
		    argv[3], &xOrigin) != TCL_OK)
		|| (Tk_CanvasGetCoordFromObj(interp, (Tk_Canvas) canvasPtr,
		    argv[4], &yOrigin) != TCL_OK)
		|| (Tcl_GetDoubleFromObj(interp, argv[5], &xScale) != TCL_OK)
		|| (Tcl_GetDoubleFromObj(interp, argv[6], &yScale) != TCL_OK)) {
	    result = TCL_ERROR;
	    goto done;
	}
	if ((xScale == 0.0) || (yScale == 0.0)) {
	    Tcl_SetResult(interp, "scale factor cannot be zero", TCL_STATIC);
	    result = TCL_ERROR;
	    goto done;
	}
#ifdef USE_OLD_TAG_SEARCH
	for (itemPtr = StartTagSearch(canvasPtr, argv[2], &search);
		itemPtr != NULL; itemPtr = NextItem(&search)) {
#else /* USE_OLD_TAG_SEARCH */
        if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
            goto done;
        }
        for (itemPtr = TagSearchFirst(searchPtr);
                itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
	    EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
	    (void) (*itemPtr->typePtr->scaleProc)((Tk_Canvas) canvasPtr,
		    itemPtr, xOrigin, yOrigin, xScale, yScale);
	    EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
	    canvasPtr->flags |= REPICK_NEEDED;
	}
	break;
      }
      case CANV_SCAN: {
	int x, y, gain=10;
	static CONST char *optionStrings[] = {
	    "mark", "dragto", NULL
	};

	if (argc < 5) {
	    Tcl_WrongNumArgs(interp, 2, argv, "mark|dragto x y ?dragGain?");
	    result = TCL_ERROR;
	} else if (Tcl_GetIndexFromObj(interp, argv[2], optionStrings,
		"scan option", 0, &index) != TCL_OK) {
	    result = TCL_ERROR;
	} else if ((argc != 5) && (argc != 5+index)) {
	    Tcl_WrongNumArgs(interp, 3, argv, index?"x y ?gain?":"x y");
	    result = TCL_ERROR;
	} else if ((Tcl_GetIntFromObj(interp, argv[3], &x) != TCL_OK)
		|| (Tcl_GetIntFromObj(interp, argv[4], &y) != TCL_OK)){
	    result = TCL_ERROR;
	} else if ((argc == 6) &&
		(Tcl_GetIntFromObj(interp, argv[5], &gain) != TCL_OK)) {
	    result = TCL_ERROR;
	} else if (!index) {
	    canvasPtr->scanX = x;
	    canvasPtr->scanXOrigin = canvasPtr->xOrigin;
	    canvasPtr->scanY = y;
	    canvasPtr->scanYOrigin = canvasPtr->yOrigin;
	} else {
	    int newXOrigin, newYOrigin, tmp;

	    /*
	     * Compute a new view origin for the canvas, amplifying the
	     * mouse motion.
	     */

	    tmp = canvasPtr->scanXOrigin - gain*(x - canvasPtr->scanX)
		    - canvasPtr->scrollX1;
	    newXOrigin = canvasPtr->scrollX1 + tmp;
	    tmp = canvasPtr->scanYOrigin - gain*(y - canvasPtr->scanY)
		    - canvasPtr->scrollY1;
	    newYOrigin = canvasPtr->scrollY1 + tmp;
	    CanvasSetOrigin(canvasPtr, newXOrigin, newYOrigin);
	}
	break;
      }
      case CANV_SELECT: {
	int index, optionindex;
	static CONST char *optionStrings[] = {
	    "adjust", "clear", "from", "item", "to", NULL
	};
	enum options {
	    CANV_ADJUST, CANV_CLEAR, CANV_FROM, CANV_ITEM, CANV_TO
	};

	if (argc < 3) {
	    Tcl_WrongNumArgs(interp, 2, argv, "option ?tagOrId? ?arg?");
	    result = TCL_ERROR;
	    goto done;
	}
	if (argc >= 4) {
#ifdef USE_OLD_TAG_SEARCH
	    for (itemPtr = StartTagSearch(canvasPtr, argv[3], &search);
		    itemPtr != NULL; itemPtr = NextItem(&search)) {
#else /* USE_OLD_TAG_SEARCH */
            if ((result = TagSearchScan(canvasPtr, argv[3], &searchPtr)) != TCL_OK) {
                goto done;
            }
            for (itemPtr = TagSearchFirst(searchPtr);
                    itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
		if ((itemPtr->typePtr->indexProc != NULL)
			&& (itemPtr->typePtr->selectionProc != NULL)){
		    break;
		}
	    }
	    if (itemPtr == NULL) {
		Tcl_AppendResult(interp,
			"can't find an indexable and selectable item \"",
			Tcl_GetStringFromObj(argv[3], NULL), "\"", (char *) NULL);
		result = TCL_ERROR;
		goto done;
	    }
	}
	if (argc == 5) {
	    if (itemPtr->typePtr->alwaysRedraw & TK_CONFIG_OBJS) {
		result = itemPtr->typePtr->indexProc(interp, (Tk_Canvas) canvasPtr,
			itemPtr, (char *) argv[4], &index);
	    } else {
		result = itemPtr->typePtr->indexProc(interp, (Tk_Canvas) canvasPtr,
			itemPtr, Tcl_GetStringFromObj(argv[4], NULL), &index);
	    }
	    if (result != TCL_OK) {
		goto done;
	    }
	}
	if (Tcl_GetIndexFromObj(interp, argv[2], optionStrings, "select option", 0,
		&optionindex) != TCL_OK) {
	    result = TCL_ERROR;
	    goto done;
	}
	switch ((enum options) optionindex) {
	  case CANV_ADJUST: {
	    if (argc != 5) {
		Tcl_WrongNumArgs(interp, 3, argv, "tagOrId index");
		result = TCL_ERROR;
		goto done;
	    }
	    if (canvasPtr->textInfo.selItemPtr == itemPtr) {
		if (index < (canvasPtr->textInfo.selectFirst
			+ canvasPtr->textInfo.selectLast)/2) {
		    canvasPtr->textInfo.selectAnchor =
			    canvasPtr->textInfo.selectLast + 1;
		} else {
		    canvasPtr->textInfo.selectAnchor =
			    canvasPtr->textInfo.selectFirst;
		}
	    }
	    CanvasSelectTo(canvasPtr, itemPtr, index);
	    break;
	  }
	  case CANV_CLEAR: {
	    if (argc != 3) {
		Tcl_AppendResult(interp, 3, argv, (char *) NULL);
		result = TCL_ERROR;
		goto done;
	    }
	    if (canvasPtr->textInfo.selItemPtr != NULL) {
		EventuallyRedrawItem((Tk_Canvas) canvasPtr,
			canvasPtr->textInfo.selItemPtr);
		canvasPtr->textInfo.selItemPtr = NULL;
	    }
	    goto done;
	    break;
	  }
	  case CANV_FROM: {
	    if (argc != 5) {
		Tcl_WrongNumArgs(interp, 3, argv, "tagOrId index");
		result = TCL_ERROR;
		goto done;
	    }
	    canvasPtr->textInfo.anchorItemPtr = itemPtr;
	    canvasPtr->textInfo.selectAnchor = index;
	    break;
	  }
	  case CANV_ITEM: {
	    if (argc != 3) {
		Tcl_WrongNumArgs(interp, 3, argv, (char *) NULL);
		result = TCL_ERROR;
		goto done;
	    }
	    if (canvasPtr->textInfo.selItemPtr != NULL) {
		char buf[TCL_INTEGER_SPACE];
		
		sprintf(buf, "%d", canvasPtr->textInfo.selItemPtr->id);
		Tcl_SetResult(interp, buf, TCL_VOLATILE);
	    }
	    break;
	  }
	  case CANV_TO: {
	    if (argc != 5) {
		Tcl_WrongNumArgs(interp, 2, argv, "tagOrId index");
		result = TCL_ERROR;
		goto done;
	    }
	    CanvasSelectTo(canvasPtr, itemPtr, index);
	    break;
	  }
	}
	break;
      }
      case CANV_TYPE: {
	if (argc != 3) {
	    Tcl_WrongNumArgs(interp, 2, argv, "tag");
	    result = TCL_ERROR;
	    goto done;
	}
#ifdef USE_OLD_TAG_SEARCH
	itemPtr = StartTagSearch(canvasPtr, argv[2], &search);
#else /* USE_OLD_TAG_SEARCH */
        if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
            goto done;
        }
        itemPtr = TagSearchFirst(searchPtr);
#endif /* USE_OLD_TAG_SEARCH */
	if (itemPtr != NULL) {
	    Tcl_SetResult(interp, itemPtr->typePtr->name, TCL_STATIC);
	}
	break;
      }
      case CANV_XVIEW: {
	int count, type;
	int newX = 0;		/* Initialization needed only to prevent
				 * gcc warnings. */
	double fraction;

	if (argc == 2) {
	    Tcl_SetObjResult(interp, ScrollFractions(
		    canvasPtr->xOrigin + canvasPtr->inset,
		    canvasPtr->xOrigin + Tk_Width(canvasPtr->tkwin)
		    - canvasPtr->inset, canvasPtr->scrollX1,
		    canvasPtr->scrollX2));
	} else {
	    CONST char **args = GetStringsFromObjs(argc, argv);
	    type = Tk_GetScrollInfo(interp, argc, args, &fraction, &count);
	    if (args) ckfree((char *) args);
	    switch (type) {
		case TK_SCROLL_ERROR:
		    result = TCL_ERROR;
		    goto done;
		case TK_SCROLL_MOVETO:
		    newX = canvasPtr->scrollX1 - canvasPtr->inset
			    + (int) (fraction * (canvasPtr->scrollX2
			    - canvasPtr->scrollX1) + 0.5);
		    break;
		case TK_SCROLL_PAGES:
		    newX = (int) (canvasPtr->xOrigin + count * .9
			    * (Tk_Width(canvasPtr->tkwin) - 2*canvasPtr->inset));
		    break;
		case TK_SCROLL_UNITS:
		    if (canvasPtr->xScrollIncrement > 0) {
			newX = canvasPtr->xOrigin
				+ count*canvasPtr->xScrollIncrement;
		    } else {
			newX = (int) (canvasPtr->xOrigin + count * .1
				* (Tk_Width(canvasPtr->tkwin)
				- 2*canvasPtr->inset));
		    }
		    break;
	    }
	    CanvasSetOrigin(canvasPtr, newX, canvasPtr->yOrigin);
	}
	break;
      }
      case CANV_YVIEW: {
	int count, type;
	int newY = 0;		/* Initialization needed only to prevent
				 * gcc warnings. */
	double fraction;

	if (argc == 2) {
	    Tcl_SetObjResult(interp,ScrollFractions(\
		    canvasPtr->yOrigin + canvasPtr->inset,
		    canvasPtr->yOrigin + Tk_Height(canvasPtr->tkwin)
		    - canvasPtr->inset, canvasPtr->scrollY1,
		    canvasPtr->scrollY2));
	} else {
	    CONST char **args = GetStringsFromObjs(argc, argv);
	    type = Tk_GetScrollInfo(interp, argc, args, &fraction, &count);
	    if (args) ckfree((char *) args);
	    switch (type) {
		case TK_SCROLL_ERROR:
		    result = TCL_ERROR;
		    goto done;
		case TK_SCROLL_MOVETO:
		    newY = canvasPtr->scrollY1 - canvasPtr->inset
			    + (int) (fraction*(canvasPtr->scrollY2
			    - canvasPtr->scrollY1) + 0.5);
		    break;
		case TK_SCROLL_PAGES:
		    newY = (int) (canvasPtr->yOrigin + count * .9
			    * (Tk_Height(canvasPtr->tkwin)
			    - 2*canvasPtr->inset));
		    break;
		case TK_SCROLL_UNITS:
		    if (canvasPtr->yScrollIncrement > 0) {
			newY = canvasPtr->yOrigin
				+ count*canvasPtr->yScrollIncrement;
		    } else {
			newY = (int) (canvasPtr->yOrigin + count * .1
				* (Tk_Height(canvasPtr->tkwin)
				- 2*canvasPtr->inset));
		    }
		    break;
	    }
	    CanvasSetOrigin(canvasPtr, canvasPtr->xOrigin, newY);
	}
	break;
      }
    }
    done:
#ifndef USE_OLD_TAG_SEARCH
    TagSearchDestroy(searchPtr);
#endif /* not USE_OLD_TAG_SEARCH */
    Tcl_Release((ClientData) canvasPtr);
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * DestroyCanvas --
 *
 *	This procedure is invoked by Tcl_EventuallyFree or Tcl_Release
 *	to clean up the internal structure of a canvas at a safe time
 *	(when no-one is using it anymore).
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Everything associated with the canvas is freed up.
 *
 *----------------------------------------------------------------------
 */

static void
DestroyCanvas(memPtr)
    char *memPtr;		/* Info about canvas widget. */
{
    TkCanvas *canvasPtr = (TkCanvas *) memPtr;
    Tk_Item *itemPtr;
#ifndef USE_OLD_TAG_SEARCH
    TagSearchExpr *expr, *next;
#endif

    /*
     * Free up all of the items in the canvas.
     */

    for (itemPtr = canvasPtr->firstItemPtr; itemPtr != NULL;
	    itemPtr = canvasPtr->firstItemPtr) {
	canvasPtr->firstItemPtr = itemPtr->nextPtr;
	(*itemPtr->typePtr->deleteProc)((Tk_Canvas) canvasPtr, itemPtr,
		canvasPtr->display);
	if (itemPtr->tagPtr != itemPtr->staticTagSpace) {
	    ckfree((char *) itemPtr->tagPtr);
	}
	ckfree((char *) itemPtr);
    }

    /*
     * Free up all the stuff that requires special handling,
     * then let Tk_FreeOptions handle all the standard option-related
     * stuff.
     */

    Tcl_DeleteHashTable(&canvasPtr->idTable);
    if (canvasPtr->pixmapGC != None) {
	Tk_FreeGC(canvasPtr->display, canvasPtr->pixmapGC);
    }
#ifndef USE_OLD_TAG_SEARCH
    expr = canvasPtr->bindTagExprs;
    while (expr) {
	next = expr->next;
	TagSearchExprDestroy(expr);
	expr = next;
    }
#endif
    Tcl_DeleteTimerHandler(canvasPtr->insertBlinkHandler);
    if (canvasPtr->bindingTable != NULL) {
	Tk_DeleteBindingTable(canvasPtr->bindingTable);
    }
    Tk_FreeOptions(configSpecs, (char *) canvasPtr, canvasPtr->display, 0);
    canvasPtr->tkwin = NULL;
    ckfree((char *) canvasPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * ConfigureCanvas --
 *
 *	This procedure is called to process an argv/argc list, plus
 *	the Tk option database, in order to configure (or
 *	reconfigure) a canvas widget.
 *
 * Results:
 *	The return value is a standard Tcl result.  If TCL_ERROR is
 *	returned, then the interp's result contains an error message.
 *
 * Side effects:
 *	Configuration information, such as colors, border width,
 *	etc. get set for canvasPtr;  old resources get freed,
 *	if there were any.
 *
 *----------------------------------------------------------------------
 */

static int
ConfigureCanvas(interp, canvasPtr, argc, argv, flags)
    Tcl_Interp *interp;		/* Used for error reporting. */
    TkCanvas *canvasPtr;	/* Information about widget;  may or may
				 * not already have values for some fields. */
    int argc;			/* Number of valid entries in argv. */
    Tcl_Obj *CONST argv[];	/* Argument objects. */
    int flags;			/* Flags to pass to Tk_ConfigureWidget. */
{
    XGCValues gcValues;
    GC new;

    if (Tk_ConfigureWidget(interp, canvasPtr->tkwin, configSpecs,
	    argc, (CONST char **) argv, (char *) canvasPtr,
	    flags|TK_CONFIG_OBJS) != TCL_OK) {
	return TCL_ERROR;
    }

    /*
     * A few options need special processing, such as setting the
     * background from a 3-D border and creating a GC for copying
     * bits to the screen.
     */

    Tk_SetBackgroundFromBorder(canvasPtr->tkwin, canvasPtr->bgBorder);

    if (canvasPtr->highlightWidth < 0) {
	canvasPtr->highlightWidth = 0;
    }
    canvasPtr->inset = canvasPtr->borderWidth + canvasPtr->highlightWidth;

    gcValues.function = GXcopy;
    gcValues.graphics_exposures = False;
    gcValues.foreground = Tk_3DBorderColor(canvasPtr->bgBorder)->pixel;
    new = Tk_GetGC(canvasPtr->tkwin,
	    GCFunction|GCGraphicsExposures|GCForeground, &gcValues);
    if (canvasPtr->pixmapGC != None) {
	Tk_FreeGC(canvasPtr->display, canvasPtr->pixmapGC);
    }
    canvasPtr->pixmapGC = new;

    /*
     * Reset the desired dimensions for the window.
     */

    Tk_GeometryRequest(canvasPtr->tkwin, canvasPtr->width + 2*canvasPtr->inset,
	    canvasPtr->height + 2*canvasPtr->inset);

    /*
     * Restart the cursor timing sequence in case the on-time or off-time
     * just changed.
     */

    if (canvasPtr->textInfo.gotFocus) {
	CanvasFocusProc(canvasPtr, 1);
    }

    /*
     * Recompute the scroll region.
     */

    canvasPtr->scrollX1 = 0;
    canvasPtr->scrollY1 = 0;
    canvasPtr->scrollX2 = 0;
    canvasPtr->scrollY2 = 0;
    if (canvasPtr->regionString != NULL) {
	int argc2;
	CONST char **argv2;

	if (Tcl_SplitList(canvasPtr->interp, canvasPtr->regionString,
		&argc2, &argv2) != TCL_OK) {
	    return TCL_ERROR;
	}
	if (argc2 != 4) {
	    Tcl_AppendResult(interp, "bad scrollRegion \"",
		    canvasPtr->regionString, "\"", (char *) NULL);
	    badRegion:
	    ckfree(canvasPtr->regionString);
	    ckfree((char *) argv2);
	    canvasPtr->regionString = NULL;
	    return TCL_ERROR;
	}
	if ((Tk_GetPixels(canvasPtr->interp, canvasPtr->tkwin,
		    argv2[0], &canvasPtr->scrollX1) != TCL_OK)
		|| (Tk_GetPixels(canvasPtr->interp, canvasPtr->tkwin,
		    argv2[1], &canvasPtr->scrollY1) != TCL_OK)
		|| (Tk_GetPixels(canvasPtr->interp, canvasPtr->tkwin,
		    argv2[2], &canvasPtr->scrollX2) != TCL_OK)
		|| (Tk_GetPixels(canvasPtr->interp, canvasPtr->tkwin,
		    argv2[3], &canvasPtr->scrollY2) != TCL_OK)) {
	    goto badRegion;
	}
	ckfree((char *) argv2);
    }

    flags = canvasPtr->tsoffset.flags;
    if (flags & TK_OFFSET_LEFT) {
	canvasPtr->tsoffset.xoffset = 0;
    } else if (flags & TK_OFFSET_CENTER) {
	canvasPtr->tsoffset.xoffset = canvasPtr->width/2;
    } else if (flags & TK_OFFSET_RIGHT) {
	canvasPtr->tsoffset.xoffset = canvasPtr->width;
    }
    if (flags & TK_OFFSET_TOP) {
	canvasPtr->tsoffset.yoffset = 0;
    } else if (flags & TK_OFFSET_MIDDLE) {
	canvasPtr->tsoffset.yoffset = canvasPtr->height/2;
    } else if (flags & TK_OFFSET_BOTTOM) {
	canvasPtr->tsoffset.yoffset = canvasPtr->height;
    }

    /*
     * Reset the canvas's origin (this is a no-op unless confine
     * mode has just been turned on or the scroll region has changed).
     */

    CanvasSetOrigin(canvasPtr, canvasPtr->xOrigin, canvasPtr->yOrigin);
    canvasPtr->flags |= UPDATE_SCROLLBARS|REDRAW_BORDERS;
    Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
	    canvasPtr->xOrigin, canvasPtr->yOrigin,
	    canvasPtr->xOrigin + Tk_Width(canvasPtr->tkwin),
	    canvasPtr->yOrigin + Tk_Height(canvasPtr->tkwin));
    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * CanvasWorldChanged --
 *
 *      This procedure is called when the world has changed in some
 *      way and the widget needs to recompute all its graphics contexts
 *	and determine its new geometry.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *	Configures all items in the canvas with a empty argc/argv, for
 *	the side effect of causing all the items to recompute their
 *	geometry and to be redisplayed.
 *
 *---------------------------------------------------------------------------
 */
 
static void
CanvasWorldChanged(instanceData)
    ClientData instanceData;	/* Information about widget. */
{
    TkCanvas *canvasPtr;
    Tk_Item *itemPtr;
    int result;

    canvasPtr = (TkCanvas *) instanceData;
    itemPtr = canvasPtr->firstItemPtr;
    for ( ; itemPtr != NULL; itemPtr = itemPtr->nextPtr) {
	result = (*itemPtr->typePtr->configProc)(canvasPtr->interp,
		(Tk_Canvas) canvasPtr, itemPtr, 0, NULL,
		TK_CONFIG_ARGV_ONLY);
	if (result != TCL_OK) {
	    Tcl_ResetResult(canvasPtr->interp);
	}
    }
    canvasPtr->flags |= REPICK_NEEDED;
    Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
	    canvasPtr->xOrigin, canvasPtr->yOrigin,
	    canvasPtr->xOrigin + Tk_Width(canvasPtr->tkwin),
	    canvasPtr->yOrigin + Tk_Height(canvasPtr->tkwin));
}

/*
 *--------------------------------------------------------------
 *
 * DisplayCanvas --
 *
 *	This procedure redraws the contents of a canvas window.
 *	It is invoked as a do-when-idle handler, so it only runs
 *	when there's nothing else for the application to do.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Information appears on the screen.
 *
 *--------------------------------------------------------------
 */

static void
DisplayCanvas(clientData)
    ClientData clientData;	/* Information about widget. */
{
    TkCanvas *canvasPtr = (TkCanvas *) clientData;
    Tk_Window tkwin = canvasPtr->tkwin;
    Tk_Item *itemPtr;
    Pixmap pixmap;
    int screenX1, screenX2, screenY1, screenY2, width, height;

    if (canvasPtr->tkwin == NULL) {
	return;
    }

    if (!Tk_IsMapped(tkwin)) {
	goto done;
    }

    /*
     * Choose a new current item if that is needed (this could cause
     * event handlers to be invoked).
     */

    while (canvasPtr->flags & REPICK_NEEDED) {
	Tcl_Preserve((ClientData) canvasPtr);
	canvasPtr->flags &= ~REPICK_NEEDED;
	PickCurrentItem(canvasPtr, &canvasPtr->pickEvent);
	tkwin = canvasPtr->tkwin;
	Tcl_Release((ClientData) canvasPtr);
	if (tkwin == NULL) {
	    return;
	}
    }

    /*
     * Scan through the item list, registering the bounding box
     * for all items that didn't do that for the final coordinates
     * yet. This can be determined by the FORCE_REDRAW flag.
     */

    for (itemPtr = canvasPtr->firstItemPtr; itemPtr != NULL;
		itemPtr = itemPtr->nextPtr) {
	if (itemPtr->redraw_flags & FORCE_REDRAW) {
	    itemPtr->redraw_flags &= ~FORCE_REDRAW;
	    EventuallyRedrawItem((Tk_Canvas)canvasPtr, itemPtr);
	    itemPtr->redraw_flags &= ~FORCE_REDRAW;
	}
    }
    /*
     * Compute the intersection between the area that needs redrawing
     * and the area that's visible on the screen.
     */

    if ((canvasPtr->redrawX1 < canvasPtr->redrawX2)
	    && (canvasPtr->redrawY1 < canvasPtr->redrawY2)) {
	screenX1 = canvasPtr->xOrigin + canvasPtr->inset;
	screenY1 = canvasPtr->yOrigin + canvasPtr->inset;
	screenX2 = canvasPtr->xOrigin + Tk_Width(tkwin) - canvasPtr->inset;
	screenY2 = canvasPtr->yOrigin + Tk_Height(tkwin) - canvasPtr->inset;
	if (canvasPtr->redrawX1 > screenX1) {
	    screenX1 = canvasPtr->redrawX1;
	}
	if (canvasPtr->redrawY1 > screenY1) {
	    screenY1 = canvasPtr->redrawY1;
	}
	if (canvasPtr->redrawX2 < screenX2) {
	    screenX2 = canvasPtr->redrawX2;
	}
	if (canvasPtr->redrawY2 < screenY2) {
	    screenY2 = canvasPtr->redrawY2;
	}
	if ((screenX1 >= screenX2) || (screenY1 >= screenY2)) {
	    goto borders;
	}
    
	/*
	 * Redrawing is done in a temporary pixmap that is allocated
	 * here and freed at the end of the procedure.  All drawing
	 * is done to the pixmap, and the pixmap is copied to the
	 * screen at the end of the procedure. The temporary pixmap
	 * serves two purposes:
	 *
	 * 1. It provides a smoother visual effect (no clearing and
	 *    gradual redraw will be visible to users).
	 * 2. It allows us to redraw only the objects that overlap
	 *    the redraw area.  Otherwise incorrect results could
	 *	  occur from redrawing things that stick outside of
	 *	  the redraw area (we'd have to redraw everything in
	 *    order to make the overlaps look right).
	 *
	 * Some tricky points about the pixmap:
	 *
	 * 1. We only allocate a large enough pixmap to hold the
	 *    area that has to be redisplayed.  This saves time in
	 *    in the X server for large objects that cover much
	 *    more than the area being redisplayed:  only the area
	 *    of the pixmap will actually have to be redrawn.
	 * 2. Some X servers (e.g. the one for DECstations) have troubles
	 *    with characters that overlap an edge of the pixmap (on the
	 *    DEC servers, as of 8/18/92, such characters are drawn one
	 *    pixel too far to the right).  To handle this problem,
	 *    make the pixmap a bit larger than is absolutely needed
	 *    so that for normal-sized fonts the characters that overlap
	 *    the edge of the pixmap will be outside the area we care
	 *    about.
	 */
    
	canvasPtr->drawableXOrigin = screenX1 - 30;
	canvasPtr->drawableYOrigin = screenY1 - 30;
	pixmap = Tk_GetPixmap(Tk_Display(tkwin), Tk_WindowId(tkwin),
	    (screenX2 + 30 - canvasPtr->drawableXOrigin),
	    (screenY2 + 30 - canvasPtr->drawableYOrigin),
	    Tk_Depth(tkwin));
    
	/*
	 * Clear the area to be redrawn.
	 */
    
	width = screenX2 - screenX1;
	height = screenY2 - screenY1;
    
	XFillRectangle(Tk_Display(tkwin), pixmap, canvasPtr->pixmapGC,
		screenX1 - canvasPtr->drawableXOrigin,
		screenY1 - canvasPtr->drawableYOrigin, (unsigned int) width,
		(unsigned int) height);
    
	/*
	 * Scan through the item list, redrawing those items that need it.
	 * An item must be redraw if either (a) it intersects the smaller
	 * on-screen area or (b) it intersects the full canvas area and its
	 * type requests that it be redrawn always (e.g. so subwindows can
	 * be unmapped when they move off-screen).
	 */
    
	for (itemPtr = canvasPtr->firstItemPtr; itemPtr != NULL;
		itemPtr = itemPtr->nextPtr) {
	    if ((itemPtr->x1 >= screenX2)
		    || (itemPtr->y1 >= screenY2)
		    || (itemPtr->x2 < screenX1)
		    || (itemPtr->y2 < screenY1)) {
		if (!(itemPtr->typePtr->alwaysRedraw & 1)
			|| (itemPtr->x1 >= canvasPtr->redrawX2)
			|| (itemPtr->y1 >= canvasPtr->redrawY2)
			|| (itemPtr->x2 < canvasPtr->redrawX1)
			|| (itemPtr->y2 < canvasPtr->redrawY1)) {
		    continue;
		}
	    }
	    if (itemPtr->state == TK_STATE_HIDDEN ||
		(itemPtr->state == TK_STATE_NULL &&
		 canvasPtr->canvas_state == TK_STATE_HIDDEN)) {
		continue;
	    }
	    (*itemPtr->typePtr->displayProc)((Tk_Canvas) canvasPtr, itemPtr,
		    canvasPtr->display, pixmap, screenX1, screenY1, width,
		    height);
	}
    
	/*
	 * Copy from the temporary pixmap to the screen, then free up
	 * the temporary pixmap.
	 */
    
	XCopyArea(Tk_Display(tkwin), pixmap, Tk_WindowId(tkwin),
		canvasPtr->pixmapGC,
		screenX1 - canvasPtr->drawableXOrigin,
		screenY1 - canvasPtr->drawableYOrigin,
		(unsigned) (screenX2 - screenX1),
		(unsigned) (screenY2 - screenY1),
		screenX1 - canvasPtr->xOrigin, screenY1 - canvasPtr->yOrigin);
	Tk_FreePixmap(Tk_Display(tkwin), pixmap);
    }

    /*
     * Draw the window borders, if needed.
     */

    borders:
    if (canvasPtr->flags & REDRAW_BORDERS) {
	canvasPtr->flags &= ~REDRAW_BORDERS;
	if (canvasPtr->borderWidth > 0) {
	    Tk_Draw3DRectangle(tkwin, Tk_WindowId(tkwin),
		    canvasPtr->bgBorder, canvasPtr->highlightWidth,
		    canvasPtr->highlightWidth,
		    Tk_Width(tkwin) - 2*canvasPtr->highlightWidth,
		    Tk_Height(tkwin) - 2*canvasPtr->highlightWidth,
		    canvasPtr->borderWidth, canvasPtr->relief);
	}
	if (canvasPtr->highlightWidth != 0) {
	    GC fgGC, bgGC;

	    bgGC = Tk_GCForColor(canvasPtr->highlightBgColorPtr,
		    Tk_WindowId(tkwin));
	    if (canvasPtr->textInfo.gotFocus) {
		fgGC = Tk_GCForColor(canvasPtr->highlightColorPtr,
			Tk_WindowId(tkwin));
	    	TkpDrawHighlightBorder(tkwin, fgGC, bgGC,
			canvasPtr->highlightWidth, Tk_WindowId(tkwin));
	    } else {
	    	TkpDrawHighlightBorder(tkwin, bgGC, bgGC,
			canvasPtr->highlightWidth, Tk_WindowId(tkwin));
	    }
	}
    }

    done:
    canvasPtr->flags &= ~(REDRAW_PENDING|BBOX_NOT_EMPTY);
    canvasPtr->redrawX1 = canvasPtr->redrawX2 = 0;
    canvasPtr->redrawY1 = canvasPtr->redrawY2 = 0;
    if (canvasPtr->flags & UPDATE_SCROLLBARS) {
	CanvasUpdateScrollbars(canvasPtr);
    }
}

/*
 *--------------------------------------------------------------
 *
 * CanvasEventProc --
 *
 *	This procedure is invoked by the Tk dispatcher for various
 *	events on canvases.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	When the window gets deleted, internal structures get
 *	cleaned up.  When it gets exposed, it is redisplayed.
 *
 *--------------------------------------------------------------
 */

static void
CanvasEventProc(clientData, eventPtr)
    ClientData clientData;	/* Information about window. */
    XEvent *eventPtr;		/* Information about event. */
{
    TkCanvas *canvasPtr = (TkCanvas *) clientData;

    if (eventPtr->type == Expose) {
	int x, y;

	x = eventPtr->xexpose.x + canvasPtr->xOrigin;
	y = eventPtr->xexpose.y + canvasPtr->yOrigin;
	Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr, x, y,
		x + eventPtr->xexpose.width,
		y + eventPtr->xexpose.height);
	if ((eventPtr->xexpose.x < canvasPtr->inset)
		|| (eventPtr->xexpose.y < canvasPtr->inset)
		|| ((eventPtr->xexpose.x + eventPtr->xexpose.width)
		    > (Tk_Width(canvasPtr->tkwin) - canvasPtr->inset))
		|| ((eventPtr->xexpose.y + eventPtr->xexpose.height)
		    > (Tk_Height(canvasPtr->tkwin) - canvasPtr->inset))) {
	    canvasPtr->flags |= REDRAW_BORDERS;
	}
    } else if (eventPtr->type == DestroyNotify) {
	if (canvasPtr->tkwin != NULL) {
	    canvasPtr->tkwin = NULL;
	    Tcl_DeleteCommandFromToken(canvasPtr->interp,
		    canvasPtr->widgetCmd);
	}
	if (canvasPtr->flags & REDRAW_PENDING) {
	    Tcl_CancelIdleCall(DisplayCanvas, (ClientData) canvasPtr);
	}
	Tcl_EventuallyFree((ClientData) canvasPtr,
		(Tcl_FreeProc *) DestroyCanvas);
    } else if (eventPtr->type == ConfigureNotify) {
	canvasPtr->flags |= UPDATE_SCROLLBARS;

	/*
	 * The call below is needed in order to recenter the canvas if
	 * it's confined and its scroll region is smaller than the window.
	 */

	CanvasSetOrigin(canvasPtr, canvasPtr->xOrigin, canvasPtr->yOrigin);
	Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr, canvasPtr->xOrigin,
		canvasPtr->yOrigin,
		canvasPtr->xOrigin + Tk_Width(canvasPtr->tkwin),
		canvasPtr->yOrigin + Tk_Height(canvasPtr->tkwin));
	canvasPtr->flags |= REDRAW_BORDERS;
    } else if (eventPtr->type == FocusIn) {
	if (eventPtr->xfocus.detail != NotifyInferior) {
	    CanvasFocusProc(canvasPtr, 1);
	}
    } else if (eventPtr->type == FocusOut) {
	if (eventPtr->xfocus.detail != NotifyInferior) {
	    CanvasFocusProc(canvasPtr, 0);
	}
    } else if (eventPtr->type == UnmapNotify) {
	Tk_Item *itemPtr;

	/*
	 * Special hack:  if the canvas is unmapped, then must notify
	 * all items with "alwaysRedraw" set, so that they know that
	 * they are no longer displayed.
	 */

	for (itemPtr = canvasPtr->firstItemPtr; itemPtr != NULL;
		itemPtr = itemPtr->nextPtr) {
	    if (itemPtr->typePtr->alwaysRedraw & 1) {
		(*itemPtr->typePtr->displayProc)((Tk_Canvas) canvasPtr,
			itemPtr, canvasPtr->display, None, 0, 0, 0, 0);
	    }
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * CanvasCmdDeletedProc --
 *
 *	This procedure is invoked when a widget command is deleted.  If
 *	the widget isn't already in the process of being destroyed,
 *	this command destroys it.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The widget is destroyed.
 *
 *----------------------------------------------------------------------
 */

static void
CanvasCmdDeletedProc(clientData)
    ClientData clientData;	/* Pointer to widget record for widget. */
{
    TkCanvas *canvasPtr = (TkCanvas *) clientData;
    Tk_Window tkwin = canvasPtr->tkwin;

    /*
     * This procedure could be invoked either because the window was
     * destroyed and the command was then deleted (in which case tkwin
     * is NULL) or because the command was deleted, and then this procedure
     * destroys the widget.
     */

    if (tkwin != NULL) {
	canvasPtr->tkwin = NULL;
	Tk_DestroyWindow(tkwin);
    }
}

/*
 *--------------------------------------------------------------
 *
 * Tk_CanvasEventuallyRedraw --
 *
 *	Arrange for part or all of a canvas widget to redrawn at
 *	some convenient time in the future.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The screen will eventually be refreshed.
 *
 *--------------------------------------------------------------
 */

void
Tk_CanvasEventuallyRedraw(canvas, x1, y1, x2, y2)
    Tk_Canvas canvas;		/* Information about widget. */
    int x1, y1;			/* Upper left corner of area to redraw.
				 * Pixels on edge are redrawn. */
    int x2, y2;			/* Lower right corner of area to redraw.
				 * Pixels on edge are not redrawn. */
{
    TkCanvas *canvasPtr = (TkCanvas *) canvas;
    /*
     * If tkwin is NULL, the canvas has been destroyed, so we can't really
     * redraw it.
     */
    if (canvasPtr->tkwin == NULL) {
	return;
    }

    if ((x1 >= x2) || (y1 >= y2) ||
 	    (x2 < canvasPtr->xOrigin) || (y2 < canvasPtr->yOrigin) ||
	    (x1 >= canvasPtr->xOrigin + Tk_Width(canvasPtr->tkwin)) ||
	    (y1 >= canvasPtr->yOrigin + Tk_Height(canvasPtr->tkwin))) {
	return;
    }
    if (canvasPtr->flags & BBOX_NOT_EMPTY) {
	if (x1 <= canvasPtr->redrawX1) {
	    canvasPtr->redrawX1 = x1;
	}
	if (y1 <= canvasPtr->redrawY1) {
	    canvasPtr->redrawY1 = y1;
	}
	if (x2 >= canvasPtr->redrawX2) {
	    canvasPtr->redrawX2 = x2;
	}
	if (y2 >= canvasPtr->redrawY2) {
	    canvasPtr->redrawY2 = y2;
	}
    } else {
	canvasPtr->redrawX1 = x1;
	canvasPtr->redrawY1 = y1;
	canvasPtr->redrawX2 = x2;
	canvasPtr->redrawY2 = y2;
	canvasPtr->flags |= BBOX_NOT_EMPTY;
    }
    if (!(canvasPtr->flags & REDRAW_PENDING)) {
	Tcl_DoWhenIdle(DisplayCanvas, (ClientData) canvasPtr);
	canvasPtr->flags |= REDRAW_PENDING;
    }
}

/*
 *--------------------------------------------------------------
 *
 * EventuallyRedrawItem --
 *
 *	Arrange for part or all of a canvas widget to redrawn at
 *	some convenient time in the future.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The screen will eventually be refreshed.
 *
 *--------------------------------------------------------------
 */

static void
EventuallyRedrawItem(canvas, itemPtr)
    Tk_Canvas canvas;		/* Information about widget. */
    Tk_Item *itemPtr;		/* item to be redrawn. */
{
    TkCanvas *canvasPtr = (TkCanvas *) canvas;
    if ((itemPtr->x1 >= itemPtr->x2) || (itemPtr->y1 >= itemPtr->y2) ||
 	    (itemPtr->x2 < canvasPtr->xOrigin) ||
	    (itemPtr->y2 < canvasPtr->yOrigin) ||
	    (itemPtr->x1 >= canvasPtr->xOrigin + Tk_Width(canvasPtr->tkwin)) ||
	    (itemPtr->y1 >= canvasPtr->yOrigin + Tk_Height(canvasPtr->tkwin))) {
	if (!(itemPtr->typePtr->alwaysRedraw & 1)) {
	    return;
	}
    }
    if (!(itemPtr->redraw_flags & FORCE_REDRAW)) {
	if (canvasPtr->flags & BBOX_NOT_EMPTY) {
	    if (itemPtr->x1 <= canvasPtr->redrawX1) {
		canvasPtr->redrawX1 = itemPtr->x1;
	    }
	    if (itemPtr->y1 <= canvasPtr->redrawY1) {
		canvasPtr->redrawY1 = itemPtr->y1;
	    }
	    if (itemPtr->x2 >= canvasPtr->redrawX2) {
		canvasPtr->redrawX2 = itemPtr->x2;
	    }
	    if (itemPtr->y2 >= canvasPtr->redrawY2) {
		canvasPtr->redrawY2 = itemPtr->y2;
	    }
	} else {
	    canvasPtr->redrawX1 = itemPtr->x1;
	    canvasPtr->redrawY1 = itemPtr->y1;
	    canvasPtr->redrawX2 = itemPtr->x2;
	    canvasPtr->redrawY2 = itemPtr->y2;
	    canvasPtr->flags |= BBOX_NOT_EMPTY;
	}
	itemPtr->redraw_flags |= FORCE_REDRAW;
    }
    if (!(canvasPtr->flags & REDRAW_PENDING)) {
	Tcl_DoWhenIdle(DisplayCanvas, (ClientData) canvasPtr);
	canvasPtr->flags |= REDRAW_PENDING;
    }
}

/*
 *--------------------------------------------------------------
 *
 * Tk_CreateItemType --
 *
 *	This procedure may be invoked to add a new kind of canvas
 *	element to the core item types supported by Tk.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	From now on, the new item type will be useable in canvas
 *	widgets (e.g. typePtr->name can be used as the item type
 *	in "create" widget commands).  If there was already a
 *	type with the same name as in typePtr, it is replaced with
 *	the new type.
 *
 *--------------------------------------------------------------
 */

void
Tk_CreateItemType(typePtr)
    Tk_ItemType *typePtr;		/* Information about item type;
					 * storage must be statically
					 * allocated (must live forever). */
{
    Tk_ItemType *typePtr2, *prevPtr;

    if (typeList == NULL) {
	InitCanvas();
    }

    /*
     * If there's already an item type with the given name, remove it.
     */

    for (typePtr2 = typeList, prevPtr = NULL; typePtr2 != NULL;
	    prevPtr = typePtr2, typePtr2 = typePtr2->nextPtr) {
	if (strcmp(typePtr2->name, typePtr->name) == 0) {
	    if (prevPtr == NULL) {
		typeList = typePtr2->nextPtr;
	    } else {
		prevPtr->nextPtr = typePtr2->nextPtr;
	    }
	    break;
	}
    }
    typePtr->nextPtr = typeList;
    typeList = typePtr;
}

/*
 *----------------------------------------------------------------------
 *
 * Tk_GetItemTypes --
 *
 *	This procedure returns a pointer to the list of all item
 *	types.
 *
 * Results:
 *	The return value is a pointer to the first in the list
 *	of item types currently supported by canvases.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tk_ItemType *
Tk_GetItemTypes()
{
    if (typeList == NULL) {
	InitCanvas();
    }
    return typeList;
}

/*
 *--------------------------------------------------------------
 *
 * InitCanvas --
 *
 *	This procedure is invoked to perform once-only-ever
 *	initialization for the module, such as setting up
 *	the type table.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

static void
InitCanvas()
{
    if (typeList != NULL) {
	return;
    }
    typeList = &tkRectangleType;
    tkRectangleType.nextPtr = &tkTextType;
    tkTextType.nextPtr = &tkLineType;
    tkLineType.nextPtr = &tkPolygonType;
    tkPolygonType.nextPtr = &tkImageType;
    tkImageType.nextPtr = &tkOvalType;
    tkOvalType.nextPtr = &tkBitmapType;
    tkBitmapType.nextPtr = &tkArcType;
    tkArcType.nextPtr = &tkWindowType;
    tkWindowType.nextPtr = NULL;
#ifndef USE_OLD_TAG_SEARCH
    allUid = Tk_GetUid("all");
    currentUid = Tk_GetUid("current");
    andUid = Tk_GetUid("&&");
    orUid = Tk_GetUid("||");
    xorUid = Tk_GetUid("^");
    parenUid = Tk_GetUid("(");
    endparenUid = Tk_GetUid(")");
    negparenUid = Tk_GetUid("!(");
    tagvalUid = Tk_GetUid("!!");
    negtagvalUid = Tk_GetUid("!");
#endif /* USE_OLD_TAG_SEARCH */
}

#ifdef USE_OLD_TAG_SEARCH
/*
 *--------------------------------------------------------------
 *
 * StartTagSearch --
 *
 *	This procedure is called to initiate an enumeration of
 *	all items in a given canvas that contain a given tag.
 *
 * Results:
 *	The return value is a pointer to the first item in
 *	canvasPtr that matches tag, or NULL if there is no
 *	such item.  The information at *searchPtr is initialized
 *	such that successive calls to NextItem will return
 *	successive items that match tag.
 *
 * Side effects:
 *	SearchPtr is linked into a list of searches in progress
 *	on canvasPtr, so that elements can safely be deleted
 *	while the search is in progress.  EndTagSearch must be
 *	called at the end of the search to unlink searchPtr from
 *	this list.
 *
 *--------------------------------------------------------------
 */

static Tk_Item *
StartTagSearch(canvasPtr, tagObj, searchPtr)
    TkCanvas *canvasPtr;		/* Canvas whose items are to be
					 * searched. */
    Tcl_Obj *tagObj;			/* Object giving tag value. */
    TagSearch *searchPtr;		/* Record describing tag search;
					 * will be initialized here. */
{
    int id;
    Tk_Item *itemPtr, *lastPtr;
    Tk_Uid *tagPtr;
    Tk_Uid uid;
    char *tag = Tcl_GetString(tagObj);
    int count;
    TkWindow *tkwin;
    TkDisplay *dispPtr;

    tkwin = (TkWindow *) canvasPtr->tkwin;
    dispPtr = tkwin->dispPtr;

    /*
     * Initialize the search.
     */

    searchPtr->canvasPtr = canvasPtr;
    searchPtr->searchOver = 0;

    /*
     * Find the first matching item in one of several ways. If the tag
     * is a number then it selects the single item with the matching
     * identifier.  In this case see if the item being requested is the
     * hot item, in which case the search can be skipped.
     */

    if (isdigit(UCHAR(*tag))) {
	char *end;
	Tcl_HashEntry *entryPtr;

	dispPtr->numIdSearches++;
	id = strtoul(tag, &end, 0);
	if (*end == 0) {
	    itemPtr = canvasPtr->hotPtr;
            lastPtr = canvasPtr->hotPrevPtr;
	    if ((itemPtr == NULL) || (itemPtr->id != id) || (lastPtr == NULL)
		    || (lastPtr->nextPtr != itemPtr)) {
		dispPtr->numSlowSearches++;
		entryPtr = Tcl_FindHashEntry(&canvasPtr->idTable, (char *) id);
		if (entryPtr != NULL) {
		    itemPtr = (Tk_Item *)Tcl_GetHashValue(entryPtr);
		    lastPtr = itemPtr->prevPtr;
		} else {
		    lastPtr = itemPtr = NULL;
		}
	    }
	    searchPtr->lastPtr = lastPtr;
	    searchPtr->searchOver = 1;
	    canvasPtr->hotPtr = itemPtr;
	    canvasPtr->hotPrevPtr = lastPtr;
	    return itemPtr;
	}
    }

    searchPtr->tag = uid = Tk_GetUid(tag);
    if (uid == Tk_GetUid("all")) {
	/*
	 * All items match.
	 */

	searchPtr->tag = NULL;
	searchPtr->lastPtr = NULL;
	searchPtr->currentPtr = canvasPtr->firstItemPtr;
	return canvasPtr->firstItemPtr;
    }

    /*
     * None of the above.  Search for an item with a matching tag.
     */

    for (lastPtr = NULL, itemPtr = canvasPtr->firstItemPtr; itemPtr != NULL;
	    lastPtr = itemPtr, itemPtr = itemPtr->nextPtr) {
	for (tagPtr = itemPtr->tagPtr, count = itemPtr->numTags;
		count > 0; tagPtr++, count--) {
	    if (*tagPtr == uid) {
		searchPtr->lastPtr = lastPtr;
		searchPtr->currentPtr = itemPtr;
		return itemPtr;
	    }
	}
    }
    searchPtr->lastPtr = lastPtr;
    searchPtr->searchOver = 1;
    return NULL;
}

/*
 *--------------------------------------------------------------
 *
 * NextItem --
 *
 *	This procedure returns successive items that match a given
 *	tag;  it should be called only after StartTagSearch has been
 *	used to begin a search.
 *
 * Results:
 *	The return value is a pointer to the next item that matches
 *	the tag specified to StartTagSearch, or NULL if no such
 *	item exists.  *SearchPtr is updated so that the next call
 *	to this procedure will return the next item.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

static Tk_Item *
NextItem(searchPtr)
    TagSearch *searchPtr;		/* Record describing search in
					 * progress. */
{
    Tk_Item *itemPtr, *lastPtr;
    int count;
    Tk_Uid uid;
    Tk_Uid *tagPtr;

    /*
     * Find next item in list (this may not actually be a suitable
     * one to return), and return if there are no items left.
     */

    lastPtr = searchPtr->lastPtr;
    if (lastPtr == NULL) {
	itemPtr = searchPtr->canvasPtr->firstItemPtr;
    } else {
	itemPtr = lastPtr->nextPtr;
    }
    if ((itemPtr == NULL) || (searchPtr->searchOver)) {
	searchPtr->searchOver = 1;
	return NULL;
    }
    if (itemPtr != searchPtr->currentPtr) {
	/*
	 * The structure of the list has changed.  Probably the
	 * previously-returned item was removed from the list.
	 * In this case, don't advance lastPtr;  just return
	 * its new successor (i.e. do nothing here).
	 */
    } else {
	lastPtr = itemPtr;
	itemPtr = lastPtr->nextPtr;
    }

    /*
     * Handle special case of "all" search by returning next item.
     */

    uid = searchPtr->tag;
    if (uid == NULL) {
	searchPtr->lastPtr = lastPtr;
	searchPtr->currentPtr = itemPtr;
	return itemPtr;
    }

    /*
     * Look for an item with a particular tag.
     */

    for ( ; itemPtr != NULL; lastPtr = itemPtr, itemPtr = itemPtr->nextPtr) {
	for (tagPtr = itemPtr->tagPtr, count = itemPtr->numTags;
		count > 0; tagPtr++, count--) {
	    if (*tagPtr == uid) {
		searchPtr->lastPtr = lastPtr;
		searchPtr->currentPtr = itemPtr;
		return itemPtr;
	    }
	}
    }
    searchPtr->lastPtr = lastPtr;
    searchPtr->searchOver = 1;
    return NULL;
}

#else /* USE_OLD_TAG_SEARCH */
/*
 *--------------------------------------------------------------
 *
 * TagSearchExprInit --
 *
 *      This procedure allocates and initializes one TagSearchExpr struct.
 *
 * Results:
 *
 * Side effects:
 *
 *--------------------------------------------------------------
 */

static void
TagSearchExprInit(exprPtrPtr)
TagSearchExpr **exprPtrPtr;
{
    TagSearchExpr* expr = *exprPtrPtr;

    if (! expr) {
	expr = (TagSearchExpr *) ckalloc(sizeof(TagSearchExpr));
	expr->allocated = 0;
	expr->uids = NULL;
	expr->next = NULL;
    }
    expr->uid = NULL;
    expr->index = 0;
    expr->length = 0;
    *exprPtrPtr = expr;
}
 
/*
 *--------------------------------------------------------------
 *
 * TagSearchExprDestroy --
 *
 *      This procedure destroys one TagSearchExpr structure.
 *
 * Results:
 *
 * Side effects:
 *
 *--------------------------------------------------------------
     */

static void
TagSearchExprDestroy(expr)
    TagSearchExpr *expr;
{
    if (expr) {
    	if (expr->uids) {
        	ckfree((char *)expr->uids);
	}
        ckfree((char *)expr);
    }
}

/*
 *--------------------------------------------------------------
 *
 * TagSearchScan --
 *
 *      This procedure is called to initiate an enumeration of
 *      all items in a given canvas that contain a tag that matches
 *      the tagOrId expression.
 *
 * Results:
 *      The return value indicates if the tagOrId expression
 *      was successfully scanned (syntax).
 *      The information at *searchPtr is initialized
 *      such that a call to TagSearchFirst, followed by
 *      successive calls to TagSearchNext will return items
 *      that match tag.
 *
 * Side effects:
 *      SearchPtr is linked into a list of searches in progress
 *      on canvasPtr, so that elements can safely be deleted
 *      while the search is in progress.
 *
 *--------------------------------------------------------------
 */

static int
TagSearchScan(canvasPtr, tagObj, searchPtrPtr)
    TkCanvas *canvasPtr;                /* Canvas whose items are to be
                                         * searched. */
    Tcl_Obj *tagObj;                    /* Object giving tag value. */
    TagSearch **searchPtrPtr;           /* Record describing tag search;
                                         * will be initialized here. */
{
    char *tag = Tcl_GetStringFromObj(tagObj,NULL);
    int i;
    TagSearch *searchPtr;

    /*
     * Initialize the search.
     */

    if (*searchPtrPtr) {
        searchPtr = *searchPtrPtr;
    } else {
        /* Allocate primary search struct on first call */
        *searchPtrPtr = searchPtr = (TagSearch *) ckalloc(sizeof(TagSearch));
	searchPtr->expr = NULL;

        /* Allocate buffer for rewritten tags (after de-escaping) */
        searchPtr->rewritebufferAllocated = 100;
        searchPtr->rewritebuffer =
            ckalloc(searchPtr->rewritebufferAllocated);
    }
    TagSearchExprInit(&(searchPtr->expr));

    /* How long is the tagOrId ? */
    searchPtr->stringLength = strlen(tag);

    /* Make sure there is enough buffer to hold rewritten tags */
    if ((unsigned int)searchPtr->stringLength >=
	    searchPtr->rewritebufferAllocated) {
        searchPtr->rewritebufferAllocated = searchPtr->stringLength + 100;
        searchPtr->rewritebuffer =
            ckrealloc(searchPtr->rewritebuffer,
		    searchPtr->rewritebufferAllocated);
    }

    /* Initialize search */
    searchPtr->canvasPtr = canvasPtr;
    searchPtr->searchOver = 0;
    searchPtr->type = 0;

    /*
     * Find the first matching item in one of several ways. If the tag
     * is a number then it selects the single item with the matching
     * identifier.  In this case see if the item being requested is the
     * hot item, in which case the search can be skipped.
     */

    if (searchPtr->stringLength && isdigit(UCHAR(*tag))) {
        char *end;

        searchPtr->id = strtoul(tag, &end, 0);
        if (*end == 0) {
            searchPtr->type = 1;
            return TCL_OK;
	}
    }

    /*
     * For all other tags and tag expressions convert to a UID.
     * This UID is kept forever, but this should be thought of
     * as a cache rather than as a memory leak.
     */
    searchPtr->expr->uid = Tk_GetUid(tag);

    /* short circuit impossible searches for null tags */
    if (searchPtr->stringLength == 0) {
	return TCL_OK;
    }

    /*
     * Pre-scan tag for at least one unquoted "&&" "||" "^" "!"
     *   if not found then use string as simple tag
     */
    for (i = 0; i < searchPtr->stringLength ; i++) {
        if (tag[i] == '"') {
            i++;
            for ( ; i < searchPtr->stringLength; i++) {
                if (tag[i] == '\\') {
                    i++;
                    continue;
                }
                if (tag[i] == '"') {
                    break;
                }
            }
        } else {
            if ((tag[i] == '&' && tag[i+1] == '&')
             || (tag[i] == '|' && tag[i+1] == '|')
             || (tag[i] == '^')
             || (tag[i] == '!')) {
                searchPtr->type = 4;
                break;
            }
        }
    }

    searchPtr->string = tag;
    searchPtr->stringIndex = 0;
    if (searchPtr->type == 4) {
        /*
         * an operator was found in the prescan, so
         * now compile the tag expression into array of Tk_Uid
         * flagging any syntax errors found
         */
	if (TagSearchScanExpr(canvasPtr->interp, searchPtr, searchPtr->expr) != TCL_OK) {
            /* Syntax error in tag expression */
	    /* Result message set by TagSearchScanExpr */
	    return TCL_ERROR;
	}
	searchPtr->expr->length = searchPtr->expr->index;
    } else {
        if (searchPtr->expr->uid == allUid) {
            /*
             * All items match.
             */
            searchPtr->type = 2;
        } else {
            /*
             * Optimized single-tag search
             */
            searchPtr->type = 3;
        }
    }
    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * TagSearchDestroy --
 *
 *      This procedure destroys any dynamic structures that
 *      may have been allocated by TagSearchScan.
 *
 * Results:
 *
 * Side effects:
 *
 *--------------------------------------------------------------
 */

static void
TagSearchDestroy(searchPtr)
    TagSearch *searchPtr;               /* Record describing tag search */
{
    if (searchPtr) {
        TagSearchExprDestroy(searchPtr->expr);
        ckfree((char *)searchPtr->rewritebuffer);
        ckfree((char *)searchPtr);
    }
}

/*
 *--------------------------------------------------------------
 *
 * TagSearchScanExpr --
 *
 *      This recursive procedure is called to scan a tag expression
 *      and compile it into an array of Tk_Uids.
 *
 * Results:
 *      The return value indicates if the tagOrId expression
 *      was successfully scanned (syntax).
 *      The information at *searchPtr is initialized
 *      such that a call to TagSearchFirst, followed by
 *      successive calls to TagSearchNext will return items
 *      that match tag.
 *
 * Side effects:
 *
 *--------------------------------------------------------------
 */

static int
TagSearchScanExpr(interp, searchPtr, expr)
    Tcl_Interp *interp;         /* Current interpreter. */
    TagSearch *searchPtr;       /* Search data */
    TagSearchExpr *expr;	/* compiled expression result */
{
    int looking_for_tag;        /* When true, scanner expects
                                 * next char(s) to be a tag,
                                 * else operand expected */
    int found_tag;              /* One or more tags found */
    int found_endquote;         /* For quoted tag string parsing */
    int negate_result;          /* Pending negation of next tag value */
    char *tag;                  /* tag from tag expression string */
    char c;

    negate_result = 0;
    found_tag = 0;
    looking_for_tag = 1;
    while (searchPtr->stringIndex < searchPtr->stringLength) {
        c = searchPtr->string[searchPtr->stringIndex++];

        if (expr->allocated == expr->index) {
            expr->allocated += 15;
	    if (expr->uids) {
		expr->uids =
                    (Tk_Uid *) ckrealloc((char *)(expr->uids),
                    (expr->allocated)*sizeof(Tk_Uid));
	    } else {
		expr->uids =
		(Tk_Uid *) ckalloc((expr->allocated)*sizeof(Tk_Uid));
	    }
        }

        if (looking_for_tag) {

            switch (c) {
                case ' '  :	/* ignore unquoted whitespace */
                case '\t' :
                case '\n' :
                case '\r' :
                    break;

                case '!'  :	/* negate next tag or subexpr */
                    if (looking_for_tag > 1) {
                        Tcl_AppendResult(interp,
                            "Too many '!' in tag search expression",
                            (char *) NULL);
                        return TCL_ERROR;
                    }
                    looking_for_tag++;
                    negate_result = 1;
                    break;

                case '('  :	/* scan (negated) subexpr recursively */
                    if (negate_result) {
                        expr->uids[expr->index++] = negparenUid;
                        negate_result = 0;
		    } else {
                        expr->uids[expr->index++] = parenUid;
		    }
                    if (TagSearchScanExpr(interp, searchPtr, expr) != TCL_OK) {
                        /* Result string should be already set
                         * by nested call to tag_expr_scan() */
			return TCL_ERROR;
		    }
                    looking_for_tag = 0;
                    found_tag = 1;
                    break;

                case '"'  :	/* quoted tag string */
                    if (negate_result) {
                        expr->uids[expr->index++] = negtagvalUid;
                        negate_result = 0;
                    } else {
                        expr->uids[expr->index++] = tagvalUid;
		    }
                    tag = searchPtr->rewritebuffer;
                    found_endquote = 0;
                    while (searchPtr->stringIndex < searchPtr->stringLength) {
                        c = searchPtr->string[searchPtr->stringIndex++];
                        if (c == '\\') {
                            c = searchPtr->string[searchPtr->stringIndex++];
			}
                        if (c == '"') {
                            found_endquote = 1;
			    break;
			}
                        *tag++ = c;
                    }
                    if (! found_endquote) {
                        Tcl_AppendResult(interp,
				"Missing endquote in tag search expression",
				(char *) NULL);
                        return TCL_ERROR;
                    }
                    if (! (tag - searchPtr->rewritebuffer)) {
                        Tcl_AppendResult(interp,
                            "Null quoted tag string in tag search expression",
                            (char *) NULL);
                        return TCL_ERROR;
                    }
                    *tag++ = '\0';
                    expr->uids[expr->index++] =
                        Tk_GetUid(searchPtr->rewritebuffer);
                    looking_for_tag = 0;
                    found_tag = 1;
                    break;

                case '&'  :	/* illegal chars when looking for tag */
                case '|'  :
                case '^'  :
                case ')'  :
                    Tcl_AppendResult(interp,
			    "Unexpected operator in tag search expression",
			    (char *) NULL);
                    return TCL_ERROR;

                default :	/* unquoted tag string */
                    if (negate_result) {
                        expr->uids[expr->index++] = negtagvalUid;
                        negate_result = 0;
                    } else {
                        expr->uids[expr->index++] = tagvalUid;
                    }
                    tag = searchPtr->rewritebuffer;
                    *tag++ = c;
                    /* copy rest of tag, including any embedded whitespace */
                    while (searchPtr->stringIndex < searchPtr->stringLength) {
                        c = searchPtr->string[searchPtr->stringIndex];
                        if (c == '!' || c == '&' || c == '|' || c == '^'
				|| c == '(' || c == ')' || c == '"') {
			    break;
                        }
                        *tag++ = c;
                        searchPtr->stringIndex++;
                    }
                    /* remove trailing whitespace */
                    while (1) {
                        c = *--tag;
                        /* there must have been one non-whitespace char,
                         *  so this will terminate */
                        if (c != ' ' && c != '\t' && c != '\n' && c != '\r') {
                            break;
			}
                    }
                    *++tag = '\0';
                    expr->uids[expr->index++] =
                        Tk_GetUid(searchPtr->rewritebuffer);
                    looking_for_tag = 0;
                    found_tag = 1;
            }

        } else {    /* ! looking_for_tag */

            switch (c) {
                case ' '  :	/* ignore whitespace */
                case '\t' :
                case '\n' :
                case '\r' :
                    break;

                case '&'  :	/* AND operator */
                    c = searchPtr->string[searchPtr->stringIndex++];
                    if (c != '&') {
                        Tcl_AppendResult(interp,
                                "Singleton '&' in tag search expression",
                                (char *) NULL);
                        return TCL_ERROR;
                    }
                    expr->uids[expr->index++] = andUid;
                    looking_for_tag = 1;
                    break;

                case '|'  :	/* OR operator */
                    c = searchPtr->string[searchPtr->stringIndex++];
                    if (c != '|') {
                        Tcl_AppendResult(interp,
                                "Singleton '|' in tag search expression",
                                (char *) NULL);
                        return TCL_ERROR;
                    }
                    expr->uids[expr->index++] = orUid;
                    looking_for_tag = 1;
                    break;

                case '^'  :	/* XOR operator */
                    expr->uids[expr->index++] = xorUid;
                    looking_for_tag = 1;
                    break;

                case ')'  :	/* end subexpression */
                    expr->uids[expr->index++] = endparenUid;
                    goto breakwhile;

                default   :	/* syntax error */
                    Tcl_AppendResult(interp,
			    "Invalid boolean operator in tag search expression",
			    (char *) NULL);
                    return TCL_ERROR;
            }
        }
    }
    breakwhile:
    if (found_tag && ! looking_for_tag) {
        return TCL_OK;
    }
    Tcl_AppendResult(interp, "Missing tag in tag search expression",
	    (char *) NULL);
    return TCL_ERROR;
}

/*
 *--------------------------------------------------------------
 *
 * TagSearchEvalExpr --
 *
 *      This recursive procedure is called to eval a tag expression.
 *
 * Results:
 *      The return value indicates if the tagOrId expression
 *      successfully matched the tags of the current item.
 *
 * Side effects:
 *
 *--------------------------------------------------------------
 */

static int
TagSearchEvalExpr(expr, itemPtr)
    TagSearchExpr *expr;        /* Search expression */
    Tk_Item *itemPtr;           /* Item being test for match */
{
    int looking_for_tag;        /* When true, scanner expects
                                 * next char(s) to be a tag,
                                 * else operand expected */
    int negate_result;          /* Pending negation of next tag value */
    Tk_Uid uid;
    Tk_Uid *tagPtr;
    int count;
    int result;                 /* Value of expr so far */
    int parendepth;

    result = 0;  /* just to keep the compiler quiet */

    negate_result = 0;
    looking_for_tag = 1;
    while (expr->index < expr->length) {
        uid = expr->uids[expr->index++];
        if (looking_for_tag) {
            if (uid == tagvalUid) {
/*
 *              assert(expr->index < expr->length);
 */
                uid = expr->uids[expr->index++];
                result = 0;
                /*
                 * set result 1 if tag is found in item's tags
                 */
                for (tagPtr = itemPtr->tagPtr, count = itemPtr->numTags;
                    count > 0; tagPtr++, count--) {
                    if (*tagPtr == uid) {
                        result = 1;
                        break;
                    }
                }

            } else if (uid == negtagvalUid) {
                negate_result = ! negate_result;
/*
 *              assert(expr->index < expr->length);
 */
                uid = expr->uids[expr->index++];
                result = 0;
                /*
                 * set result 1 if tag is found in item's tags
                 */
                for (tagPtr = itemPtr->tagPtr, count = itemPtr->numTags;
                    count > 0; tagPtr++, count--) {
                    if (*tagPtr == uid) {
                        result = 1;
                        break;
                    }
                }

            } else if (uid == parenUid) {
                /*
                 * evaluate subexpressions with recursion
                 */
                result = TagSearchEvalExpr(expr, itemPtr);

            } else if (uid == negparenUid) {
                negate_result = ! negate_result;
                /*
                 * evaluate subexpressions with recursion
                 */
                result = TagSearchEvalExpr(expr, itemPtr);
/*
 *          } else {
 *              assert(0);
 */
            }
            if (negate_result) {
                result = ! result;
                negate_result = 0;
            }
            looking_for_tag = 0;
        } else {    /* ! looking_for_tag */
            if (((uid == andUid) && (!result)) || ((uid == orUid) && result)) {
                /*
                 * short circuit expression evaluation
                 *
                 * if result before && is 0, or result before || is 1,
                 *   then the expression is decided and no further
                 *   evaluation is needed.
                 */

                    parendepth = 0;
		while (expr->index < expr->length) {
		    uid = expr->uids[expr->index++];
		    if (uid == tagvalUid || uid == negtagvalUid) {
			expr->index++;
			continue;
		    }
                        if (uid == parenUid || uid == negparenUid) {
                            parendepth++;
			continue;
		    } 
		    if (uid == endparenUid) {
                            parendepth--;
                            if (parendepth < 0) {
                                break;
                            }
                        }
                    }
                return result;

            } else if (uid == xorUid) {
                /*
                 * if the previous result was 1
                 *   then negate the next result
                 */
                negate_result = result;

            } else if (uid == endparenUid) {
                return result;
/*
 *          } else {
 *               assert(0);
 */
            }
            looking_for_tag = 1;
        }
    }
/*
 *  assert(! looking_for_tag);
 */
    return result;
}

/*
 *--------------------------------------------------------------
 *
 * TagSearchFirst --
 *
 *      This procedure is called to get the first item
 *      item that matches a preestablished search predicate
 *      that was set by TagSearchScan.
 *
 * Results:
 *      The return value is a pointer to the first item, or NULL
 *      if there is no such item.  The information at *searchPtr
 *      is updated such that successive calls to TagSearchNext
 *      will return successive items.
 *
 * Side effects:
 *      SearchPtr is linked into a list of searches in progress
 *      on canvasPtr, so that elements can safely be deleted
 *      while the search is in progress.
 *
 *--------------------------------------------------------------
 */

static Tk_Item *
TagSearchFirst(searchPtr)
    TagSearch *searchPtr;               /* Record describing tag search */
{
    Tk_Item *itemPtr, *lastPtr;
    Tk_Uid uid, *tagPtr;
    int count;

    /* short circuit impossible searches for null tags */
    if (searchPtr->stringLength == 0) {
        return NULL;
    }

    /*
     * Find the first matching item in one of several ways. If the tag
     * is a number then it selects the single item with the matching
     * identifier.  In this case see if the item being requested is the
     * hot item, in which case the search can be skipped.
     */

    if (searchPtr->type == 1) {
        Tcl_HashEntry *entryPtr;

        itemPtr = searchPtr->canvasPtr->hotPtr;
        lastPtr = searchPtr->canvasPtr->hotPrevPtr;
        if ((itemPtr == NULL) || (itemPtr->id != searchPtr->id) || (lastPtr == NULL)
            || (lastPtr->nextPtr != itemPtr)) {
            entryPtr = Tcl_FindHashEntry(&searchPtr->canvasPtr->idTable,
                (char *) searchPtr->id);
            if (entryPtr != NULL) {
                itemPtr = (Tk_Item *)Tcl_GetHashValue(entryPtr);
                lastPtr = itemPtr->prevPtr;
            } else {
                lastPtr = itemPtr = NULL;
            }
        }
        searchPtr->lastPtr = lastPtr;
        searchPtr->searchOver = 1;
        searchPtr->canvasPtr->hotPtr = itemPtr;
        searchPtr->canvasPtr->hotPrevPtr = lastPtr;
        return itemPtr;
    }

    if (searchPtr->type == 2) {

        /*
         * All items match.
         */

        searchPtr->lastPtr = NULL;
        searchPtr->currentPtr = searchPtr->canvasPtr->firstItemPtr;
        return searchPtr->canvasPtr->firstItemPtr;
    }

    if (searchPtr->type == 3) {

        /*
         * Optimized single-tag search
         */

        uid = searchPtr->expr->uid;
        for (lastPtr = NULL, itemPtr = searchPtr->canvasPtr->firstItemPtr;
                itemPtr != NULL; lastPtr = itemPtr, itemPtr = itemPtr->nextPtr) {
            for (tagPtr = itemPtr->tagPtr, count = itemPtr->numTags;
                    count > 0; tagPtr++, count--) {
                if (*tagPtr == uid) {
                    searchPtr->lastPtr = lastPtr;
                    searchPtr->currentPtr = itemPtr;
                    return itemPtr;
                }
            }
        }
    } else {

    /*
         * None of the above.  Search for an item matching the tag expression.
     */

    for (lastPtr = NULL, itemPtr = searchPtr->canvasPtr->firstItemPtr;
                itemPtr != NULL; lastPtr = itemPtr, itemPtr = itemPtr->nextPtr) {
	    searchPtr->expr->index = 0;
	    if (TagSearchEvalExpr(searchPtr->expr, itemPtr)) {
            searchPtr->lastPtr = lastPtr;
            searchPtr->currentPtr = itemPtr;
            return itemPtr;
        }
        }
    }
    searchPtr->lastPtr = lastPtr;
    searchPtr->searchOver = 1;
    return NULL;
}

/*
 *--------------------------------------------------------------
 *
 * TagSearchNext --
 *
 *      This procedure returns successive items that match a given
 *      tag;  it should be called only after TagSearchFirst has been
 *      used to begin a search.
 *
 * Results:
 *      The return value is a pointer to the next item that matches
 *      the tag expr specified to TagSearchScan, or NULL if no such
 *      item exists.  *SearchPtr is updated so that the next call
 *      to this procedure will return the next item.
 *
 * Side effects:
 *      None.
 *
 *--------------------------------------------------------------
 */

static Tk_Item *
TagSearchNext(searchPtr)
    TagSearch *searchPtr;               /* Record describing search in
                                         * progress. */
{
    Tk_Item *itemPtr, *lastPtr;
    Tk_Uid uid, *tagPtr;
    int count;

    /*
     * Find next item in list (this may not actually be a suitable
     * one to return), and return if there are no items left.
     */

    lastPtr = searchPtr->lastPtr;
    if (lastPtr == NULL) {
        itemPtr = searchPtr->canvasPtr->firstItemPtr;
    } else {
        itemPtr = lastPtr->nextPtr;
    }
    if ((itemPtr == NULL) || (searchPtr->searchOver)) {
        searchPtr->searchOver = 1;
        return NULL;
    }
    if (itemPtr != searchPtr->currentPtr) {
        /*
         * The structure of the list has changed.  Probably the
         * previously-returned item was removed from the list.
         * In this case, don't advance lastPtr;  just return
         * its new successor (i.e. do nothing here).
         */
    } else {
        lastPtr = itemPtr;
        itemPtr = lastPtr->nextPtr;
    }

    if (searchPtr->type == 2) {

        /*
         * All items match.
         */

        searchPtr->lastPtr = lastPtr;
        searchPtr->currentPtr = itemPtr;
        return itemPtr;
    }

    if (searchPtr->type == 3) {

        /*
         * Optimized single-tag search
         */

        uid = searchPtr->expr->uid;
        for ( ; itemPtr != NULL; lastPtr = itemPtr, itemPtr = itemPtr->nextPtr) {
            for (tagPtr = itemPtr->tagPtr, count = itemPtr->numTags;
                    count > 0; tagPtr++, count--) {
                if (*tagPtr == uid) {
                    searchPtr->lastPtr = lastPtr;
                    searchPtr->currentPtr = itemPtr;
                    return itemPtr;
                }
            }
        }
        searchPtr->lastPtr = lastPtr;
        searchPtr->searchOver = 1;
        return NULL;
    }

    /*
     * Else.... evaluate tag expression
     */

    for ( ; itemPtr != NULL; lastPtr = itemPtr, itemPtr = itemPtr->nextPtr) {
        searchPtr->expr->index = 0;
        if (TagSearchEvalExpr(searchPtr->expr, itemPtr)) {
            searchPtr->lastPtr = lastPtr;
            searchPtr->currentPtr = itemPtr;
            return itemPtr;
        }
    }
    searchPtr->lastPtr = lastPtr;
    searchPtr->searchOver = 1;
    return NULL;
}
#endif /* USE_OLD_TAG_SEARCH */

/*
 *--------------------------------------------------------------
 *
 * DoItem --
 *
 *	This is a utility procedure called by FindItems.  It
 *	either adds itemPtr's id to the result forming in interp,
 *	or it adds a new tag to itemPtr, depending on the value
 *	of tag.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	If tag is NULL then itemPtr's id is added as a list element
 *	to the interp's result;  otherwise tag is added to itemPtr's
 *	list of tags.
 *
 *--------------------------------------------------------------
 */

static void
DoItem(interp, itemPtr, tag)
    Tcl_Interp *interp;			/* Interpreter in which to (possibly)
					 * record item id. */
    Tk_Item *itemPtr;			/* Item to (possibly) modify. */
    Tk_Uid tag;				/* Tag to add to those already
					 * present for item, or NULL. */
{
    Tk_Uid *tagPtr;
    int count;

    /*
     * Handle the "add-to-result" case and return, if appropriate.
     */

    if (tag == NULL) {
	char msg[TCL_INTEGER_SPACE];

	sprintf(msg, "%d", itemPtr->id);
	Tcl_AppendElement(interp, msg);
	return;
    }

    for (tagPtr = itemPtr->tagPtr, count = itemPtr->numTags;
	    count > 0; tagPtr++, count--) {
	if (tag == *tagPtr) {
	    return;
	}
    }

    /*
     * Grow the tag space if there's no more room left in the current
     * block.
     */

    if (itemPtr->tagSpace == itemPtr->numTags) {
	Tk_Uid *newTagPtr;

	itemPtr->tagSpace += 5;
	newTagPtr = (Tk_Uid *) ckalloc((unsigned)
		(itemPtr->tagSpace * sizeof(Tk_Uid)));
	memcpy((VOID *) newTagPtr, (VOID *) itemPtr->tagPtr,
		(itemPtr->numTags * sizeof(Tk_Uid)));
	if (itemPtr->tagPtr != itemPtr->staticTagSpace) {
	    ckfree((char *) itemPtr->tagPtr);
	}
	itemPtr->tagPtr = newTagPtr;
	tagPtr = &itemPtr->tagPtr[itemPtr->numTags];
    }

    /*
     * Add in the new tag.
     */

    *tagPtr = tag;
    itemPtr->numTags++;
}

/*
 *--------------------------------------------------------------
 *
 * FindItems --
 *
 *	This procedure does all the work of implementing the
 *	"find" and "addtag" options of the canvas widget command,
 *	which locate items that have certain features (location,
 *	tags, position in display list, etc.).
 *
 * Results:
 *	A standard Tcl return value.  If newTag is NULL, then a
 *	list of ids from all the items that match argc/argv is
 *	returned in the interp's result.  If newTag is NULL, then
 *	the normal the interp's result is an empty string.  If an error
 *	occurs, then the interp's result will hold an error message.
 *
 * Side effects:
 *	If newTag is non-NULL, then all the items that match the
 *	information in argc/argv have that tag added to their
 *	lists of tags.
 *
 *--------------------------------------------------------------
 */

static int
#ifdef USE_OLD_TAG_SEARCH
FindItems(interp, canvasPtr, argc, argv, newTag, first)
#else /* USE_OLD_TAG_SEARCH */
FindItems(interp, canvasPtr, argc, argv, newTag, first, searchPtrPtr)
#endif /* USE_OLD_TAG_SEARCH */
    Tcl_Interp *interp;			/* Interpreter for error reporting. */
    TkCanvas *canvasPtr;		/* Canvas whose items are to be
					 * searched. */
    int argc;				/* Number of entries in argv.  Must be
					 * greater than zero. */
    Tcl_Obj *CONST *argv;		/* Arguments that describe what items
					 * to search for (see user doc on
					 * "find" and "addtag" options). */
    Tcl_Obj *newTag;			/* If non-NULL, gives new tag to set
					 * on all found items;  if NULL, then
					 * ids of found items are returned
					 * in the interp's result. */
    int first;				/* For error messages:  gives number
					 * of elements of argv which are already
					 * handled. */
#ifndef USE_OLD_TAG_SEARCH
    TagSearch **searchPtrPtr;           /* From CanvasWidgetCmd local vars*/
#endif /* not USE_OLD_TAG_SEARCH */
{
#ifdef USE_OLD_TAG_SEARCH
    TagSearch search;
#endif /* USE_OLD_TAG_SEARCH */
    Tk_Item *itemPtr;
    Tk_Uid uid;
    int index;
    static CONST char *optionStrings[] = {
	"above", "all", "below", "closest",
	"enclosed", "overlapping", "withtag", NULL
    };
    enum options {
	CANV_ABOVE, CANV_ALL, CANV_BELOW, CANV_CLOSEST,
	CANV_ENCLOSED, CANV_OVERLAPPING, CANV_WITHTAG
    };

    if (newTag != NULL) {
	uid = Tk_GetUid(Tcl_GetStringFromObj(newTag, NULL));
    } else {
	uid = NULL;
    }
    if (Tcl_GetIndexFromObj(interp, argv[first], optionStrings, "search command", 0,
	    &index) != TCL_OK) {
	return TCL_ERROR;
    }
    switch ((enum options) index) {
      case CANV_ABOVE: {
	Tk_Item *lastPtr = NULL;
	if (argc != first+2) {
	    Tcl_WrongNumArgs(interp, first+1, argv, "tagOrId");
	    return TCL_ERROR;
	}
#ifdef USE_OLD_TAG_SEARCH
	for (itemPtr = StartTagSearch(canvasPtr, argv[first+1], &search);
		itemPtr != NULL; itemPtr = NextItem(&search)) {
#else /* USE_OLD_TAG_SEARCH */
        if (TagSearchScan(canvasPtr, argv[first+1], searchPtrPtr) != TCL_OK) {
            return TCL_ERROR;
        }
        for (itemPtr = TagSearchFirst(*searchPtrPtr);
                itemPtr != NULL; itemPtr = TagSearchNext(*searchPtrPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
	    lastPtr = itemPtr;
	}
	if ((lastPtr != NULL) && (lastPtr->nextPtr != NULL)) {
	    DoItem(interp, lastPtr->nextPtr, uid);
	}
	break;
      }
      case CANV_ALL: {
	if (argc != first+1) {
	    Tcl_WrongNumArgs(interp, first+1, argv, (char *) NULL);
	    return TCL_ERROR;
	}

	for (itemPtr = canvasPtr->firstItemPtr; itemPtr != NULL;
		itemPtr = itemPtr->nextPtr) {
	    DoItem(interp, itemPtr, uid);
	}
	break;
      }
      case CANV_BELOW: {
	Tk_Item *itemPtr;

	if (argc != first+2) {
	    Tcl_WrongNumArgs(interp, first+1, argv, "tagOrId");
	    return TCL_ERROR;
	}
#ifdef USE_OLD_TAG_SEARCH
	itemPtr = StartTagSearch(canvasPtr, argv[first+1], &search);
#else /* USE_OLD_TAG_SEARCH */
        if (TagSearchScan(canvasPtr, argv[first+1], searchPtrPtr) != TCL_OK) {
            return TCL_ERROR;
        }
        itemPtr = TagSearchFirst(*searchPtrPtr);
#endif /* USE_OLD_TAG_SEARCH */
	if (itemPtr != NULL) {
	    if (itemPtr->prevPtr != NULL) {
		DoItem(interp, itemPtr->prevPtr, uid);
	    }
	}
	break;
      }
      case CANV_CLOSEST: {
	double closestDist;
	Tk_Item *startPtr, *closestPtr;
	double coords[2], halo;
	int x1, y1, x2, y2;

	if ((argc < first+3) || (argc > first+5)) {
	    Tcl_WrongNumArgs(interp, first+1, argv, "x y ?halo? ?start?");
	    return TCL_ERROR;
	}
	if ((Tk_CanvasGetCoordFromObj(interp, (Tk_Canvas) canvasPtr, argv[first+1],
		&coords[0]) != TCL_OK) || (Tk_CanvasGetCoordFromObj(interp,
		(Tk_Canvas) canvasPtr, argv[first+2], &coords[1]) != TCL_OK)) {
	    return TCL_ERROR;
	}
	if (argc > first+3) {
	    if (Tk_CanvasGetCoordFromObj(interp, (Tk_Canvas) canvasPtr, argv[first+3],
		    &halo) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (halo < 0.0) {
		Tcl_AppendResult(interp, "can't have negative halo value \"",
			Tcl_GetString(argv[3]), "\"", (char *) NULL);
		return TCL_ERROR;
	    }
	} else {
	    halo = 0.0;
	}

	/*
	 * Find the item at which to start the search.
	 */

	startPtr = canvasPtr->firstItemPtr;
	if (argc == first+5) {
#ifdef USE_OLD_TAG_SEARCH
	    itemPtr = StartTagSearch(canvasPtr, argv[first+4], &search);
#else /* USE_OLD_TAG_SEARCH */
            if (TagSearchScan(canvasPtr, argv[first+4], searchPtrPtr) != TCL_OK) {
                return TCL_ERROR;
            }
            itemPtr = TagSearchFirst(*searchPtrPtr);
#endif /* USE_OLD_TAG_SEARCH */
	    if (itemPtr != NULL) {
		startPtr = itemPtr;
	    }
	}

	/*
	 * The code below is optimized so that it can eliminate most
	 * items without having to call their item-specific procedures.
	 * This is done by keeping a bounding box (x1, y1, x2, y2) that
	 * an item's bbox must overlap if the item is to have any
	 * chance of being closer than the closest so far.
	 */

	itemPtr = startPtr;
	while(itemPtr && (itemPtr->state == TK_STATE_HIDDEN ||
	    (itemPtr->state == TK_STATE_NULL && canvasPtr->canvas_state == TK_STATE_HIDDEN))) {
	    itemPtr = itemPtr->nextPtr;
	}
	if (itemPtr == NULL) {
	    return TCL_OK;
	}
	closestDist = (*itemPtr->typePtr->pointProc)((Tk_Canvas) canvasPtr,
		itemPtr, coords) - halo;
	if (closestDist < 0.0) {
	    closestDist = 0.0;
	}
	while (1) {
	    double newDist;

	    /*
	     * Update the bounding box using itemPtr, which is the
	     * new closest item.
	     */

	    x1 = (int) (coords[0] - closestDist - halo - 1);
	    y1 = (int) (coords[1] - closestDist - halo - 1);
	    x2 = (int) (coords[0] + closestDist + halo + 1);
	    y2 = (int) (coords[1] + closestDist + halo + 1);
	    closestPtr = itemPtr;

	    /*
	     * Search for an item that beats the current closest one.
	     * Work circularly through the canvas's item list until
	     * getting back to the starting item.
	     */

	    while (1) {
		itemPtr = itemPtr->nextPtr;
		if (itemPtr == NULL) {
		    itemPtr = canvasPtr->firstItemPtr;
		}
		if (itemPtr == startPtr) {
		    DoItem(interp, closestPtr, uid);
		    return TCL_OK;
		}
		if (itemPtr->state == TK_STATE_HIDDEN || (itemPtr->state == TK_STATE_NULL &&
			canvasPtr->canvas_state == TK_STATE_HIDDEN)) {
		    continue;
		}
		if ((itemPtr->x1 >= x2) || (itemPtr->x2 <= x1)
			|| (itemPtr->y1 >= y2) || (itemPtr->y2 <= y1)) {
		    continue;
		}
		newDist = (*itemPtr->typePtr->pointProc)((Tk_Canvas) canvasPtr,
			itemPtr, coords) - halo;
		if (newDist < 0.0) {
		    newDist = 0.0;
		}
		if (newDist <= closestDist) {
		    closestDist = newDist;
		    break;
		}
	    }
	}
	break;
      }
      case CANV_ENCLOSED: {
	if (argc != first+5) {
	    Tcl_WrongNumArgs(interp, first+1, argv, "x1 y1 x2 y2");
	    return TCL_ERROR;
	}
	return FindArea(interp, canvasPtr, argv+first+1, uid, 1);
      }
      case CANV_OVERLAPPING: {
	if (argc != first+5) {
	    Tcl_WrongNumArgs(interp, first+1, argv, "x1 y1 x2 y2");
	    return TCL_ERROR;
	}
	return FindArea(interp, canvasPtr, argv+first+1, uid, 0);
      }
      case CANV_WITHTAG: {
	if (argc != first+2) {
	    Tcl_WrongNumArgs(interp, first+1, argv, "tagOrId");
	    return TCL_ERROR;
	}
#ifdef USE_OLD_TAG_SEARCH
	for (itemPtr = StartTagSearch(canvasPtr, argv[first+1], &search);
		itemPtr != NULL; itemPtr = NextItem(&search)) {
#else /* USE_OLD_TAG_SEARCH */
        if (TagSearchScan(canvasPtr, argv[first+1], searchPtrPtr) != TCL_OK) {
            return TCL_ERROR;
        }
        for (itemPtr = TagSearchFirst(*searchPtrPtr);
                itemPtr != NULL; itemPtr = TagSearchNext(*searchPtrPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
	    DoItem(interp, itemPtr, uid);
	}
      }
    }
    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * FindArea --
 *
 *	This procedure implements area searches for the "find"
 *	and "addtag" options.
 *
 * Results:
 *	A standard Tcl return value.  If newTag is NULL, then a
 *	list of ids from all the items overlapping or enclosed
 *	by the rectangle given by argc is returned in the interp's result.
 *	If newTag is NULL, then the normal the interp's result is an
 *	empty string.  If an error occurs, then the interp's result will
 *	hold an error message.
 *
 * Side effects:
 *	If uid is non-NULL, then all the items overlapping
 *	or enclosed by the area in argv have that tag added to
 *	their lists of tags.
 *
 *--------------------------------------------------------------
 */

static int
FindArea(interp, canvasPtr, argv, uid, enclosed)
    Tcl_Interp *interp;			/* Interpreter for error reporting
					 * and result storing. */
    TkCanvas *canvasPtr;		/* Canvas whose items are to be
					 * searched. */
    Tcl_Obj *CONST *argv;		/* Array of four arguments that
					 * give the coordinates of the
					 * rectangular area to search. */
    Tk_Uid uid;				/* If non-NULL, gives new tag to set
					 * on all found items;  if NULL, then
					 * ids of found items are returned
					 * in the interp's result. */
    int enclosed;			/* 0 means overlapping or enclosed
					 * items are OK, 1 means only enclosed
					 * items are OK. */
{
    double rect[4], tmp;
    int x1, y1, x2, y2;
    Tk_Item *itemPtr;

    if ((Tk_CanvasGetCoordFromObj(interp, (Tk_Canvas) canvasPtr, argv[0],
		&rect[0]) != TCL_OK)
	    || (Tk_CanvasGetCoordFromObj(interp, (Tk_Canvas) canvasPtr, argv[1],
		&rect[1]) != TCL_OK)
	    || (Tk_CanvasGetCoordFromObj(interp, (Tk_Canvas) canvasPtr, argv[2],
		&rect[2]) != TCL_OK)
	    || (Tk_CanvasGetCoordFromObj(interp, (Tk_Canvas) canvasPtr, argv[3],
		&rect[3]) != TCL_OK)) {
	return TCL_ERROR;
    }
    if (rect[0] > rect[2]) {
	tmp = rect[0]; rect[0] = rect[2]; rect[2] = tmp;
    }
    if (rect[1] > rect[3]) {
	tmp = rect[1]; rect[1] = rect[3]; rect[3] = tmp;
    }

    /*
     * Use an integer bounding box for a quick test, to avoid
     * calling item-specific code except for items that are close.
     */

    x1 = (int) (rect[0]-1.0);
    y1 = (int) (rect[1]-1.0);
    x2 = (int) (rect[2]+1.0);
    y2 = (int) (rect[3]+1.0);
    for (itemPtr = canvasPtr->firstItemPtr; itemPtr != NULL;
	    itemPtr = itemPtr->nextPtr) {
	if (itemPtr->state == TK_STATE_HIDDEN || (itemPtr->state == TK_STATE_NULL &&
		canvasPtr->canvas_state == TK_STATE_HIDDEN)) {
	    continue;
	}
	if ((itemPtr->x1 >= x2) || (itemPtr->x2 <= x1)
		|| (itemPtr->y1 >= y2) || (itemPtr->y2 <= y1)) {
	    continue;
	}
	if ((*itemPtr->typePtr->areaProc)((Tk_Canvas) canvasPtr, itemPtr, rect)
		>= enclosed) {
	    DoItem(interp, itemPtr, uid);
	}
    }
    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * RelinkItems --
 *
 *	Move one or more items to a different place in the
 *	display order for a canvas.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The items identified by "tag" are moved so that they
 *	are all together in the display list and immediately
 *	after prevPtr.  The order of the moved items relative
 *	to each other is not changed.
 *
 *--------------------------------------------------------------
 */

#ifdef USE_OLD_TAG_SEARCH
static void
RelinkItems(canvasPtr, tag, prevPtr)
#else /* USE_OLD_TAG_SEARCH */
static int
RelinkItems(canvasPtr, tag, prevPtr, searchPtrPtr)
#endif /* USE_OLD_TAG_SEARCH */
    TkCanvas *canvasPtr;	/* Canvas to be modified. */
    Tcl_Obj *tag;		/* Tag identifying items to be moved
				 * in the redisplay list. */
    Tk_Item *prevPtr;		/* Reposition the items so that they
				 * go just after this item (NULL means
				 * put at beginning of list). */
#ifndef USE_OLD_TAG_SEARCH
    TagSearch **searchPtrPtr;   /* From CanvasWidgetCmd local vars */
#endif /* not USE_OLD_TAG_SEARCH */
{
    Tk_Item *itemPtr;
#ifdef USE_OLD_TAG_SEARCH
    TagSearch search;
#endif /* USE_OLD_TAG_SEARCH */
    Tk_Item *firstMovePtr, *lastMovePtr;

    /*
     * Find all of the items to be moved and remove them from
     * the list, making an auxiliary list running from firstMovePtr
     * to lastMovePtr.  Record their areas for redisplay.
     */

    firstMovePtr = lastMovePtr = NULL;
#ifdef USE_OLD_TAG_SEARCH
    for (itemPtr = StartTagSearch(canvasPtr, tag, &search);
	    itemPtr != NULL; itemPtr = NextItem(&search)) {
#else /* USE_OLD_TAG_SEARCH */
    if (TagSearchScan(canvasPtr, tag, searchPtrPtr) != TCL_OK) {
        return TCL_ERROR;
    }
    for (itemPtr = TagSearchFirst(*searchPtrPtr);
            itemPtr != NULL; itemPtr = TagSearchNext(*searchPtrPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
	if (itemPtr == prevPtr) {
	    /*
	     * Item after which insertion is to occur is being
	     * moved!  Switch to insert after its predecessor.
	     */

	    prevPtr = prevPtr->prevPtr;
	}
	if (itemPtr->prevPtr == NULL) {
	    if (itemPtr->nextPtr != NULL) {
		itemPtr->nextPtr->prevPtr = NULL;
	    }
	    canvasPtr->firstItemPtr = itemPtr->nextPtr;
	} else {
	    if (itemPtr->nextPtr != NULL) {
		itemPtr->nextPtr->prevPtr = itemPtr->prevPtr;
	    }
	    itemPtr->prevPtr->nextPtr = itemPtr->nextPtr;
	}
	if (canvasPtr->lastItemPtr == itemPtr) {
	    canvasPtr->lastItemPtr = itemPtr->prevPtr;
	}
	if (firstMovePtr == NULL) {
	    itemPtr->prevPtr = NULL;
	    firstMovePtr = itemPtr;
	} else {
	    itemPtr->prevPtr = lastMovePtr;
	    lastMovePtr->nextPtr = itemPtr;
	}
	lastMovePtr = itemPtr;
	EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
	canvasPtr->flags |= REPICK_NEEDED;
    }

    /*
     * Insert the list of to-be-moved items back into the canvas's
     * at the desired position.
     */

    if (firstMovePtr == NULL) {
#ifdef USE_OLD_TAG_SEARCH
	return;
#else /* USE_OLD_TAG_SEARCH */
        return TCL_OK;
#endif /* USE_OLD_TAG_SEARCH */
    }
    if (prevPtr == NULL) {
	if (canvasPtr->firstItemPtr != NULL) {
	    canvasPtr->firstItemPtr->prevPtr = lastMovePtr;
	}
	lastMovePtr->nextPtr = canvasPtr->firstItemPtr;
	canvasPtr->firstItemPtr = firstMovePtr;
    } else {
	if (prevPtr->nextPtr != NULL) {
	    prevPtr->nextPtr->prevPtr = lastMovePtr;
	}
	lastMovePtr->nextPtr = prevPtr->nextPtr;
	if (firstMovePtr != NULL) {
	    firstMovePtr->prevPtr = prevPtr;
	}
	prevPtr->nextPtr = firstMovePtr;
    }
    if (canvasPtr->lastItemPtr == prevPtr) {
	canvasPtr->lastItemPtr = lastMovePtr;
    }
#ifndef USE_OLD_TAG_SEARCH
    return TCL_OK;
#endif /* not USE_OLD_TAG_SEARCH */
}

/*
 *--------------------------------------------------------------
 *
 * CanvasBindProc --
 *
 *	This procedure is invoked by the Tk dispatcher to handle
 *	events associated with bindings on items.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Depends on the command invoked as part of the binding
 *	(if there was any).
 *
 *--------------------------------------------------------------
 */

static void
CanvasBindProc(clientData, eventPtr)
    ClientData clientData;		/* Pointer to canvas structure. */
    XEvent *eventPtr;			/* Pointer to X event that just
					 * happened. */
{
    TkCanvas *canvasPtr = (TkCanvas *) clientData;

    Tcl_Preserve((ClientData) canvasPtr);

    /*
     * This code below keeps track of the current modifier state in
     * canvasPtr>state.  This information is used to defer repicks of
     * the current item while buttons are down.
     */

    if ((eventPtr->type == ButtonPress) || (eventPtr->type == ButtonRelease)) {
	int mask;

	switch (eventPtr->xbutton.button) {
	    case Button1:
		mask = Button1Mask;
		break;
	    case Button2:
		mask = Button2Mask;
		break;
	    case Button3:
		mask = Button3Mask;
		break;
	    case Button4:
		mask = Button4Mask;
		break;
	    case Button5:
		mask = Button5Mask;
		break;
	    default:
		mask = 0;
		break;
	}

	/*
	 * For button press events, repick the current item using the
	 * button state before the event, then process the event.  For
	 * button release events, first process the event, then repick
	 * the current item using the button state *after* the event
	 * (the button has logically gone up before we change the
	 * current item).
	 */

	if (eventPtr->type == ButtonPress) {
	    /*
	     * On a button press, first repick the current item using
	     * the button state before the event, the process the event.
	     */

	    canvasPtr->state = eventPtr->xbutton.state;
	    PickCurrentItem(canvasPtr, eventPtr);
	    canvasPtr->state ^= mask;
	    CanvasDoEvent(canvasPtr, eventPtr);
	} else {
	    /*
	     * Button release: first process the event, with the button
	     * still considered to be down.  Then repick the current
	     * item under the assumption that the button is no longer down.
	     */

	    canvasPtr->state = eventPtr->xbutton.state;
	    CanvasDoEvent(canvasPtr, eventPtr);
	    eventPtr->xbutton.state ^= mask;
	    canvasPtr->state = eventPtr->xbutton.state;
	    PickCurrentItem(canvasPtr, eventPtr);
	    eventPtr->xbutton.state ^= mask;
	}
	goto done;
    } else if ((eventPtr->type == EnterNotify)
	    || (eventPtr->type == LeaveNotify)) {
	canvasPtr->state = eventPtr->xcrossing.state;
	PickCurrentItem(canvasPtr, eventPtr);
	goto done;
    } else if (eventPtr->type == MotionNotify) {
	canvasPtr->state = eventPtr->xmotion.state;
	PickCurrentItem(canvasPtr, eventPtr);
    }
    CanvasDoEvent(canvasPtr, eventPtr);

    done:
    Tcl_Release((ClientData) canvasPtr);
}

/*
 *--------------------------------------------------------------
 *
 * PickCurrentItem --
 *
 *	Find the topmost item in a canvas that contains a given
 *	location and mark the the current item.  If the current
 *	item has changed, generate a fake exit event on the old
 *	current item, a fake enter event on the new current item
 *	item and force a redraw of the two items. Canvas items
 *      that are hidden or disabled are ignored.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The current item for canvasPtr may change.  If it does,
 *	then the commands associated with item entry and exit
 *	could do just about anything.  A binding script could
 *	delete the canvas, so callers should protect themselves
 *	with Tcl_Preserve and Tcl_Release.
 *
 *--------------------------------------------------------------
 */

static void
PickCurrentItem(canvasPtr, eventPtr)
    TkCanvas *canvasPtr;		/* Canvas widget in which to select
					 * current item. */
    XEvent *eventPtr;			/* Event describing location of
					 * mouse cursor.  Must be EnterWindow,
					 * LeaveWindow, ButtonRelease, or
					 * MotionNotify. */
{
    double coords[2];
    int buttonDown;
    Tk_Item *prevItemPtr;

    /*
     * Check whether or not a button is down.  If so, we'll log entry
     * and exit into and out of the current item, but not entry into
     * any other item.  This implements a form of grabbing equivalent
     * to what the X server does for windows.
     */

    buttonDown = canvasPtr->state
	    & (Button1Mask|Button2Mask|Button3Mask|Button4Mask|Button5Mask);
    if (!buttonDown) {
	canvasPtr->flags &= ~LEFT_GRABBED_ITEM;
    }

    /*
     * Save information about this event in the canvas.  The event in
     * the canvas is used for two purposes:
     *
     * 1. Event bindings: if the current item changes, fake events are
     *    generated to allow item-enter and item-leave bindings to trigger.
     * 2. Reselection: if the current item gets deleted, can use the
     *    saved event to find a new current item.
     * Translate MotionNotify events into EnterNotify events, since that's
     * what gets reported to item handlers.
     */

    if (eventPtr != &canvasPtr->pickEvent) {
	if ((eventPtr->type == MotionNotify)
		|| (eventPtr->type == ButtonRelease)) {
	    canvasPtr->pickEvent.xcrossing.type = EnterNotify;
	    canvasPtr->pickEvent.xcrossing.serial = eventPtr->xmotion.serial;
	    canvasPtr->pickEvent.xcrossing.send_event
		    = eventPtr->xmotion.send_event;
	    canvasPtr->pickEvent.xcrossing.display = eventPtr->xmotion.display;
	    canvasPtr->pickEvent.xcrossing.window = eventPtr->xmotion.window;
	    canvasPtr->pickEvent.xcrossing.root = eventPtr->xmotion.root;
	    canvasPtr->pickEvent.xcrossing.subwindow = None;
	    canvasPtr->pickEvent.xcrossing.time = eventPtr->xmotion.time;
	    canvasPtr->pickEvent.xcrossing.x = eventPtr->xmotion.x;
	    canvasPtr->pickEvent.xcrossing.y = eventPtr->xmotion.y;
	    canvasPtr->pickEvent.xcrossing.x_root = eventPtr->xmotion.x_root;
	    canvasPtr->pickEvent.xcrossing.y_root = eventPtr->xmotion.y_root;
	    canvasPtr->pickEvent.xcrossing.mode = NotifyNormal;
	    canvasPtr->pickEvent.xcrossing.detail = NotifyNonlinear;
	    canvasPtr->pickEvent.xcrossing.same_screen
		    = eventPtr->xmotion.same_screen;
	    canvasPtr->pickEvent.xcrossing.focus = False;
	    canvasPtr->pickEvent.xcrossing.state = eventPtr->xmotion.state;
	} else  {
	    canvasPtr->pickEvent = *eventPtr;
	}
    }

    /*
     * If this is a recursive call (there's already a partially completed
     * call pending on the stack;  it's in the middle of processing a
     * Leave event handler for the old current item) then just return;
     * the pending call will do everything that's needed.
     */

    if (canvasPtr->flags & REPICK_IN_PROGRESS) {
	return;
    }

    /*
     * A LeaveNotify event automatically means that there's no current
     * object, so the check for closest item can be skipped.
     */

    coords[0] = canvasPtr->pickEvent.xcrossing.x + canvasPtr->xOrigin;
    coords[1] = canvasPtr->pickEvent.xcrossing.y + canvasPtr->yOrigin;
    if (canvasPtr->pickEvent.type != LeaveNotify) {
	canvasPtr->newCurrentPtr = CanvasFindClosest(canvasPtr, coords);
    } else {
	canvasPtr->newCurrentPtr = NULL;
    }

    if ((canvasPtr->newCurrentPtr == canvasPtr->currentItemPtr)
	    && !(canvasPtr->flags & LEFT_GRABBED_ITEM)) {
	/*
	 * Nothing to do:  the current item hasn't changed.
	 */

	return;
    }

    /*
     * Simulate a LeaveNotify event on the previous current item and
     * an EnterNotify event on the new current item.  Remove the "current"
     * tag from the previous current item and place it on the new current
     * item.
     */

    if ((canvasPtr->newCurrentPtr != canvasPtr->currentItemPtr)
	    && (canvasPtr->currentItemPtr != NULL)
	    && !(canvasPtr->flags & LEFT_GRABBED_ITEM)) {
	XEvent event;
	Tk_Item *itemPtr = canvasPtr->currentItemPtr;
	int i;

	event = canvasPtr->pickEvent;
	event.type = LeaveNotify;

	/*
	 * If the event's detail happens to be NotifyInferior the
	 * binding mechanism will discard the event.  To be consistent,
	 * always use NotifyAncestor.
	 */

	event.xcrossing.detail = NotifyAncestor;
	canvasPtr->flags |= REPICK_IN_PROGRESS;
	CanvasDoEvent(canvasPtr, &event);
	canvasPtr->flags &= ~REPICK_IN_PROGRESS;

	/*
	 * The check below is needed because there could be an event
	 * handler for <LeaveNotify> that deletes the current item.
	 */

	if ((itemPtr == canvasPtr->currentItemPtr) && !buttonDown) {
	    for (i = itemPtr->numTags-1; i >= 0; i--) {
#ifdef USE_OLD_TAG_SEARCH
		if (itemPtr->tagPtr[i] == Tk_GetUid("current")) {
#else /* USE_OLD_TAG_SEARCH */
		if (itemPtr->tagPtr[i] == currentUid) {
#endif /* USE_OLD_TAG_SEARCH */
		    itemPtr->tagPtr[i] = itemPtr->tagPtr[itemPtr->numTags-1];
		    itemPtr->numTags--;
		    break;
		}
	    }
	}
    
	/*
	 * Note:  during CanvasDoEvent above, it's possible that
	 * canvasPtr->newCurrentPtr got reset to NULL because the
	 * item was deleted.
	 */
    }
    if ((canvasPtr->newCurrentPtr != canvasPtr->currentItemPtr) && buttonDown) {
	canvasPtr->flags |= LEFT_GRABBED_ITEM;
	return;
    }

    /*
     * Special note:  it's possible that canvasPtr->newCurrentPtr ==
     * canvasPtr->currentItemPtr here.  This can happen, for example,
     * if LEFT_GRABBED_ITEM was set.
     */

    prevItemPtr = canvasPtr->currentItemPtr;
    canvasPtr->flags &= ~LEFT_GRABBED_ITEM;
    canvasPtr->currentItemPtr = canvasPtr->newCurrentPtr;
    if (prevItemPtr != NULL && prevItemPtr != canvasPtr->currentItemPtr &&
	    (prevItemPtr->redraw_flags & TK_ITEM_STATE_DEPENDANT)) {
	EventuallyRedrawItem((Tk_Canvas) canvasPtr, prevItemPtr);
	(*prevItemPtr->typePtr->configProc)(canvasPtr->interp,
		(Tk_Canvas) canvasPtr, prevItemPtr, 0, (Tcl_Obj **) NULL,
		TK_CONFIG_ARGV_ONLY);
    }
    if (canvasPtr->currentItemPtr != NULL) {
	XEvent event;

#ifdef USE_OLD_TAG_SEARCH
	DoItem((Tcl_Interp *) NULL, canvasPtr->currentItemPtr, 
                Tk_GetUid("current"));
#else /* USE_OLD_TAG_SEARCH */
	DoItem((Tcl_Interp *) NULL, canvasPtr->currentItemPtr, currentUid);
#endif /* USE_OLD_TAG_SEA */
	if ((canvasPtr->currentItemPtr->redraw_flags & TK_ITEM_STATE_DEPENDANT &&
		prevItemPtr != canvasPtr->currentItemPtr)) {
	    (*canvasPtr->currentItemPtr->typePtr->configProc)(canvasPtr->interp,
		    (Tk_Canvas) canvasPtr, canvasPtr->currentItemPtr, 0, (Tcl_Obj **) NULL,
		    TK_CONFIG_ARGV_ONLY);
	    EventuallyRedrawItem((Tk_Canvas) canvasPtr,
		    canvasPtr->currentItemPtr);
	}
	event = canvasPtr->pickEvent;
	event.type = EnterNotify;
	event.xcrossing.detail = NotifyAncestor;
	CanvasDoEvent(canvasPtr, &event);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * CanvasFindClosest --
 *
 *	Given x and y coordinates, find the topmost canvas item that
 *	is "close" to the coordinates. Canvas items that are hidden
 *	or disabled are ignored.
 *
 * Results:
 *	The return value is a pointer to the topmost item that is
 *	close to (x,y), or NULL if no item is close.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static Tk_Item *
CanvasFindClosest(canvasPtr, coords)
    TkCanvas *canvasPtr;		/* Canvas widget to search. */
    double coords[2];			/* Desired x,y position in canvas,
					 * not screen, coordinates.) */
{
    Tk_Item *itemPtr;
    Tk_Item *bestPtr;
    int x1, y1, x2, y2;

    x1 = (int) (coords[0] - canvasPtr->closeEnough);
    y1 = (int) (coords[1] - canvasPtr->closeEnough);
    x2 = (int) (coords[0] + canvasPtr->closeEnough);
    y2 = (int) (coords[1] + canvasPtr->closeEnough);

    bestPtr = NULL;
    for (itemPtr = canvasPtr->firstItemPtr; itemPtr != NULL;
	    itemPtr = itemPtr->nextPtr) {
	if (itemPtr->state == TK_STATE_HIDDEN || itemPtr->state==TK_STATE_DISABLED ||
		(itemPtr->state == TK_STATE_NULL && (canvasPtr->canvas_state == TK_STATE_HIDDEN ||
		canvasPtr->canvas_state == TK_STATE_DISABLED))) {
	    continue;
	}
	if ((itemPtr->x1 > x2) || (itemPtr->x2 < x1)
		|| (itemPtr->y1 > y2) || (itemPtr->y2 < y1)) {
	    continue;
	}
	if ((*itemPtr->typePtr->pointProc)((Tk_Canvas) canvasPtr,
		itemPtr, coords) <= canvasPtr->closeEnough) {
	    bestPtr = itemPtr;
	}
    }
    return bestPtr;
}

/*
 *--------------------------------------------------------------
 *
 * CanvasDoEvent --
 *
 *	This procedure is called to invoke binding processing
 *	for a new event that is associated with the current item
 *	for a canvas.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Depends on the bindings for the canvas.  A binding script
 *	could delete the canvas, so callers should protect themselves
 *	with Tcl_Preserve and Tcl_Release.
 *
 *--------------------------------------------------------------
 */

static void
CanvasDoEvent(canvasPtr, eventPtr)
    TkCanvas *canvasPtr;		/* Canvas widget in which event
					 * occurred. */
    XEvent *eventPtr;			/* Real or simulated X event that
					 * is to be processed. */
{
#define NUM_STATIC 3
    ClientData staticObjects[NUM_STATIC];
    ClientData *objectPtr;
    int numObjects, i;
    Tk_Item *itemPtr;
#ifndef USE_OLD_TAG_SEARCH
    TagSearchExpr *expr;
    int numExprs;
#endif /* not USE_OLD_TAG_SEARCH */

    if (canvasPtr->bindingTable == NULL) {
	return;
    }

    itemPtr = canvasPtr->currentItemPtr;
    if ((eventPtr->type == KeyPress) || (eventPtr->type == KeyRelease)) {
	itemPtr = canvasPtr->textInfo.focusItemPtr;
    }
    if (itemPtr == NULL) {
	return;
    }

#ifdef USE_OLD_TAG_SEARCH
    /*
     * Set up an array with all the relevant objects for processing
     * this event.  The relevant objects are (a) the event's item,
     * (b) the tags associated with the event's item, and (c) the
     * tag "all".  If there are a lot of tags then malloc an array
     * to hold all of the objects.
     */

    numObjects = itemPtr->numTags + 2;
#else /* USE_OLD_TAG_SEARCH */
    /*
     * Set up an array with all the relevant objects for processing
     * this event.  The relevant objects are:
     * (a) the event's item,
     * (b) the tags associated with the event's item, 
     * (c) the expressions that are true for the event's item's tags, and
     * (d) the tag "all". 
     *
     * If there are a lot of tags then malloc an array to hold all of
     * the objects.
     */

    /*
     * flag and count all expressions that match item's tags
     */
    numExprs = 0;
    expr = canvasPtr->bindTagExprs;
    while (expr) {
	expr->index = 0;
    	expr->match = TagSearchEvalExpr(expr, itemPtr);
	if (expr->match) {
	    numExprs++;
	}
	expr = expr->next;
    }

    numObjects = itemPtr->numTags + numExprs + 2;
#endif /* not USE_OLD_TAG_SEARCH */
    if (numObjects <= NUM_STATIC) {
	objectPtr = staticObjects;
    } else {
	objectPtr = (ClientData *) ckalloc((unsigned)
		(numObjects * sizeof(ClientData)));
    }
#ifdef USE_OLD_TAG_SEARCH
    objectPtr[0] = (ClientData) Tk_GetUid("all");
#else /* USE_OLD_TAG_SEARCH */
    objectPtr[0] = (ClientData) allUid;
#endif /* USE_OLD_TAG_SEARCH */
    for (i = itemPtr->numTags-1; i >= 0; i--) {
	objectPtr[i+1] = (ClientData) itemPtr->tagPtr[i];
    }
    objectPtr[itemPtr->numTags+1] = (ClientData) itemPtr;
#ifndef USE_OLD_TAG_SEARCH
    /*
     * copy uids of matching expressions into object array
     */
    i = itemPtr->numTags+2;
    expr = canvasPtr->bindTagExprs;
    while (expr) {
    	if (expr->match) {
	    objectPtr[i++] = (int *) expr->uid;
	}
	expr = expr->next;
    }
#endif /* not USE_OLD_TAG_SEARCH */

    /*
     * Invoke the binding system, then free up the object array if
     * it was malloc-ed.
     */

    if (canvasPtr->tkwin != NULL) {
	Tk_BindEvent(canvasPtr->bindingTable, eventPtr, canvasPtr->tkwin,
		numObjects, objectPtr);
    }
    if (objectPtr != staticObjects) {
	ckfree((char *) objectPtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * CanvasBlinkProc --
 *
 *	This procedure is called as a timer handler to blink the
 *	insertion cursor off and on.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The cursor gets turned on or off, redisplay gets invoked,
 *	and this procedure reschedules itself.
 *
 *----------------------------------------------------------------------
 */

static void
CanvasBlinkProc(clientData)
    ClientData clientData;	/* Pointer to record describing entry. */
{
    TkCanvas *canvasPtr = (TkCanvas *) clientData;

    if (!canvasPtr->textInfo.gotFocus || (canvasPtr->insertOffTime == 0)) {
	return;
    }
    if (canvasPtr->textInfo.cursorOn) {
	canvasPtr->textInfo.cursorOn = 0;
	canvasPtr->insertBlinkHandler = Tcl_CreateTimerHandler(
		canvasPtr->insertOffTime, CanvasBlinkProc,
		(ClientData) canvasPtr);
    } else {
	canvasPtr->textInfo.cursorOn = 1;
	canvasPtr->insertBlinkHandler = Tcl_CreateTimerHandler(
		canvasPtr->insertOnTime, CanvasBlinkProc,
		(ClientData) canvasPtr);
    }
    if (canvasPtr->textInfo.focusItemPtr != NULL) {
	EventuallyRedrawItem((Tk_Canvas) canvasPtr,
		canvasPtr->textInfo.focusItemPtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * CanvasFocusProc --
 *
 *	This procedure is called whenever a canvas gets or loses the
 *	input focus.  It's also called whenever the window is
 *	reconfigured while it has the focus.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The cursor gets turned on or off.
 *
 *----------------------------------------------------------------------
 */

static void
CanvasFocusProc(canvasPtr, gotFocus)
    TkCanvas *canvasPtr;	/* Canvas that just got or lost focus. */
    int gotFocus;		/* 1 means window is getting focus, 0 means
				 * it's losing it. */
{
    Tcl_DeleteTimerHandler(canvasPtr->insertBlinkHandler);
    if (gotFocus) {
	canvasPtr->textInfo.gotFocus = 1;
	canvasPtr->textInfo.cursorOn = 1;
	if (canvasPtr->insertOffTime != 0) {
	    canvasPtr->insertBlinkHandler = Tcl_CreateTimerHandler(
		    canvasPtr->insertOffTime, CanvasBlinkProc,
		    (ClientData) canvasPtr);
	}
    } else {
	canvasPtr->textInfo.gotFocus = 0;
	canvasPtr->textInfo.cursorOn = 0;
	canvasPtr->insertBlinkHandler = (Tcl_TimerToken) NULL;
    }
    if (canvasPtr->textInfo.focusItemPtr != NULL) {
	EventuallyRedrawItem((Tk_Canvas) canvasPtr,
		canvasPtr->textInfo.focusItemPtr);
    }
    if (canvasPtr->highlightWidth > 0) {
	canvasPtr->flags |= REDRAW_BORDERS;
	if (!(canvasPtr->flags & REDRAW_PENDING)) {
	    Tcl_DoWhenIdle(DisplayCanvas, (ClientData) canvasPtr);
	    canvasPtr->flags |= REDRAW_PENDING;
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * CanvasSelectTo --
 *
 *	Modify the selection by moving its un-anchored end.  This could
 *	make the selection either larger or smaller.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The selection changes.
 *
 *----------------------------------------------------------------------
 */

static void
CanvasSelectTo(canvasPtr, itemPtr, index)
    TkCanvas *canvasPtr;	/* Information about widget. */
    Tk_Item *itemPtr;		/* Item that is to hold selection. */
    int index;			/* Index of element that is to become the
				 * "other" end of the selection. */
{
    int oldFirst, oldLast;
    Tk_Item *oldSelPtr;

    oldFirst = canvasPtr->textInfo.selectFirst;
    oldLast = canvasPtr->textInfo.selectLast;
    oldSelPtr = canvasPtr->textInfo.selItemPtr;

    /*
     * Grab the selection if we don't own it already.
     */

    if (canvasPtr->textInfo.selItemPtr == NULL) {
	Tk_OwnSelection(canvasPtr->tkwin, XA_PRIMARY, CanvasLostSelection,
		(ClientData) canvasPtr);
    } else if (canvasPtr->textInfo.selItemPtr != itemPtr) {
	EventuallyRedrawItem((Tk_Canvas) canvasPtr,
		canvasPtr->textInfo.selItemPtr);
    }
    canvasPtr->textInfo.selItemPtr = itemPtr;

    if (canvasPtr->textInfo.anchorItemPtr != itemPtr) {
	canvasPtr->textInfo.anchorItemPtr = itemPtr;
	canvasPtr->textInfo.selectAnchor = index;
    }
    if (canvasPtr->textInfo.selectAnchor <= index) {
	canvasPtr->textInfo.selectFirst = canvasPtr->textInfo.selectAnchor;
	canvasPtr->textInfo.selectLast = index;
    } else {
	canvasPtr->textInfo.selectFirst = index;
	canvasPtr->textInfo.selectLast = canvasPtr->textInfo.selectAnchor - 1;
    }
    if ((canvasPtr->textInfo.selectFirst != oldFirst)
	    || (canvasPtr->textInfo.selectLast != oldLast)
	    || (itemPtr != oldSelPtr)) {
	EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
    }
}

/*
 *--------------------------------------------------------------
 *
 * CanvasFetchSelection --
 *
 *	This procedure is invoked by Tk to return part or all of
 *	the selection, when the selection is in a canvas widget.
 *	This procedure always returns the selection as a STRING.
 *
 * Results:
 *	The return value is the number of non-NULL bytes stored
 *	at buffer.  Buffer is filled (or partially filled) with a
 *	NULL-terminated string containing part or all of the selection,
 *	as given by offset and maxBytes.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

static int
CanvasFetchSelection(clientData, offset, buffer, maxBytes)
    ClientData clientData;		/* Information about canvas widget. */
    int offset;				/* Offset within selection of first
					 * character to be returned. */
    char *buffer;			/* Location in which to place
					 * selection. */
    int maxBytes;			/* Maximum number of bytes to place
					 * at buffer, not including terminating
					 * NULL character. */
{
    TkCanvas *canvasPtr = (TkCanvas *) clientData;

    if (canvasPtr->textInfo.selItemPtr == NULL) {
	return -1;
    }
    if (canvasPtr->textInfo.selItemPtr->typePtr->selectionProc == NULL) {
	return -1;
    }
    return (*canvasPtr->textInfo.selItemPtr->typePtr->selectionProc)(
	    (Tk_Canvas) canvasPtr, canvasPtr->textInfo.selItemPtr, offset,
	    buffer, maxBytes);
}

/*
 *----------------------------------------------------------------------
 *
 * CanvasLostSelection --
 *
 *	This procedure is called back by Tk when the selection is
 *	grabbed away from a canvas widget.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The existing selection is unhighlighted, and the window is
 *	marked as not containing a selection.
 *
 *----------------------------------------------------------------------
 */

static void
CanvasLostSelection(clientData)
    ClientData clientData;		/* Information about entry widget. */
{
    TkCanvas *canvasPtr = (TkCanvas *) clientData;

    if (canvasPtr->textInfo.selItemPtr != NULL) {
	EventuallyRedrawItem((Tk_Canvas) canvasPtr,
		canvasPtr->textInfo.selItemPtr);
    }
    canvasPtr->textInfo.selItemPtr = NULL;
}

/*
 *--------------------------------------------------------------
 *
 * GridAlign --
 *
 *	Given a coordinate and a grid spacing, this procedure
 *	computes the location of the nearest grid line to the
 *	coordinate.
 *
 * Results:
 *	The return value is the location of the grid line nearest
 *	to coord.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

static double
GridAlign(coord, spacing)
    double coord;		/* Coordinate to grid-align. */
    double spacing;		/* Spacing between grid lines.   If <= 0
				 * then no alignment is done. */
{
    if (spacing <= 0.0) {
	return coord;
    }
    if (coord < 0) {
	return -((int) ((-coord)/spacing + 0.5)) * spacing;
    }
    return ((int) (coord/spacing + 0.5)) * spacing;
}

/*
 *----------------------------------------------------------------------
 *
 * ScrollFractions --
 *
 *	Given the range that's visible in the window and the "100%
 *	range" for what's in the canvas, return a list of two
 *	doubles representing the scroll fractions.  This procedure
 *	is used for both x and y scrolling.
 *
 * Results:
 *	The memory pointed to by string is modified to hold
 *	two real numbers containing the scroll fractions (between
 *	0 and 1) corresponding to the other arguments.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static Tcl_Obj *
ScrollFractions(screen1, screen2, object1, object2)
    int screen1;		/* Lowest coordinate visible in the window. */
    int screen2;		/* Highest coordinate visible in the window. */
    int object1;		/* Lowest coordinate in the object. */
    int object2;		/* Highest coordinate in the object. */
{
    double range, f1, f2;
    char buffer[2*TCL_DOUBLE_SPACE+2];

    range = object2 - object1;
    if (range <= 0) {
	f1 = 0;
	f2 = 1.0;
    } else {
	f1 = (screen1 - object1)/range;
	if (f1 < 0) {
	    f1 = 0.0;
	}
	f2 = (screen2 - object1)/range;
	if (f2 > 1.0) {
	    f2 = 1.0;
	}
	if (f2 < f1) {
	    f2 = f1;
	}
    }
    sprintf(buffer, "%g %g", f1, f2);
    return Tcl_NewStringObj(buffer, -1);
}

/*
 *--------------------------------------------------------------
 *
 * CanvasUpdateScrollbars --
 *
 *	This procedure is invoked whenever a canvas has changed in
 *	a way that requires scrollbars to be redisplayed (e.g. the
 *	view in the canvas has changed).
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	If there are scrollbars associated with the canvas, then
 *	their scrolling commands are invoked to cause them to
 *	redisplay.  If errors occur, additional Tcl commands may
 *	be invoked to process the errors.
 *
 *--------------------------------------------------------------
 */

static void
CanvasUpdateScrollbars(canvasPtr)
    TkCanvas *canvasPtr;		/* Information about canvas. */
{
    int result;
    Tcl_Interp *interp;
    int xOrigin, yOrigin, inset, width, height, scrollX1, scrollX2,
        scrollY1, scrollY2;
    char *xScrollCmd, *yScrollCmd;

    /*
     * Save all the relevant values from the canvasPtr, because it might be
     * deleted as part of either of the two calls to Tcl_VarEval below.
     */
    
    interp = canvasPtr->interp;
    Tcl_Preserve((ClientData) interp);
    xScrollCmd = canvasPtr->xScrollCmd;
    if (xScrollCmd != (char *) NULL) {
        Tcl_Preserve((ClientData) xScrollCmd);
    }
    yScrollCmd = canvasPtr->yScrollCmd;
    if (yScrollCmd != (char *) NULL) {
        Tcl_Preserve((ClientData) yScrollCmd);
    }
    xOrigin = canvasPtr->xOrigin;
    yOrigin = canvasPtr->yOrigin;
    inset = canvasPtr->inset;
    width = Tk_Width(canvasPtr->tkwin);
    height = Tk_Height(canvasPtr->tkwin);
    scrollX1 = canvasPtr->scrollX1;
    scrollX2 = canvasPtr->scrollX2;
    scrollY1 = canvasPtr->scrollY1;
    scrollY2 = canvasPtr->scrollY2;
    canvasPtr->flags &= ~UPDATE_SCROLLBARS;
    if (canvasPtr->xScrollCmd != NULL) {
	Tcl_Obj *fractions = ScrollFractions(xOrigin + inset,
		xOrigin + width - inset, scrollX1, scrollX2);
	result = Tcl_VarEval(interp, xScrollCmd, " ", 
		Tcl_GetString(fractions), (char *) NULL);
	Tcl_DecrRefCount(fractions);
	if (result != TCL_OK) {
	    Tcl_BackgroundError(interp);
	}
	Tcl_ResetResult(interp);
        Tcl_Release((ClientData) xScrollCmd);
    }

    if (yScrollCmd != NULL) {
	Tcl_Obj *fractions = ScrollFractions(yOrigin + inset,
		yOrigin + height - inset, scrollY1, scrollY2);
	result = Tcl_VarEval(interp, yScrollCmd, " ", 
		Tcl_GetString(fractions), (char *) NULL);
	Tcl_DecrRefCount(fractions);
	if (result != TCL_OK) {
	    Tcl_BackgroundError(interp);
	}
	Tcl_ResetResult(interp);
        Tcl_Release((ClientData) yScrollCmd);
    }
    Tcl_Release((ClientData) interp);
}

/*
 *--------------------------------------------------------------
 *
 * CanvasSetOrigin --
 *
 *	This procedure is invoked to change the mapping between
 *	canvas coordinates and screen coordinates in the canvas
 *	window.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The canvas will be redisplayed to reflect the change in
 *	view.  In addition, scrollbars will be updated if there
 *	are any.
 *
 *--------------------------------------------------------------
 */

static void
CanvasSetOrigin(canvasPtr, xOrigin, yOrigin)
    TkCanvas *canvasPtr;	/* Information about canvas. */
    int xOrigin;		/* New X origin for canvas (canvas x-coord
				 * corresponding to left edge of canvas
				 * window). */
    int yOrigin;		/* New Y origin for canvas (canvas y-coord
				 * corresponding to top edge of canvas
				 * window). */
{
    int left, right, top, bottom, delta;

    /*
     * If scroll increments have been set, round the window origin
     * to the nearest multiple of the increments.  Remember, the
     * origin is the place just inside the borders,  not the upper
     * left corner.
     */

    if (canvasPtr->xScrollIncrement > 0) {
	if (xOrigin >= 0) {
	    xOrigin += canvasPtr->xScrollIncrement/2;
	    xOrigin -= (xOrigin + canvasPtr->inset)
		    % canvasPtr->xScrollIncrement;
	} else {
	    xOrigin = (-xOrigin) + canvasPtr->xScrollIncrement/2;
	    xOrigin = -(xOrigin - (xOrigin - canvasPtr->inset)
		    % canvasPtr->xScrollIncrement);
	}
    }
    if (canvasPtr->yScrollIncrement > 0) {
	if (yOrigin >= 0) {
	    yOrigin += canvasPtr->yScrollIncrement/2;
	    yOrigin -= (yOrigin + canvasPtr->inset)
		    % canvasPtr->yScrollIncrement;
	} else {
	    yOrigin = (-yOrigin) + canvasPtr->yScrollIncrement/2;
	    yOrigin = -(yOrigin - (yOrigin - canvasPtr->inset)
		    % canvasPtr->yScrollIncrement);
	}
    }

    /*
     * Adjust the origin if necessary to keep as much as possible of the
     * canvas in the view.  The variables left, right, etc. keep track of
     * how much extra space there is on each side of the view before it
     * will stick out past the scroll region.  If one side sticks out past
     * the edge of the scroll region, adjust the view to bring that side
     * back to the edge of the scrollregion (but don't move it so much that
     * the other side sticks out now).  If scroll increments are in effect,
     * be sure to adjust only by full increments.
     */

    if ((canvasPtr->confine) && (canvasPtr->regionString != NULL)) {
	left = xOrigin + canvasPtr->inset - canvasPtr->scrollX1;
	right = canvasPtr->scrollX2
		- (xOrigin + Tk_Width(canvasPtr->tkwin) - canvasPtr->inset);
	top = yOrigin + canvasPtr->inset - canvasPtr->scrollY1;
	bottom = canvasPtr->scrollY2
		- (yOrigin + Tk_Height(canvasPtr->tkwin) - canvasPtr->inset);
	if ((left < 0) && (right > 0)) {
	    delta = (right > -left) ? -left : right;
	    if (canvasPtr->xScrollIncrement > 0) {
		delta -= delta % canvasPtr->xScrollIncrement;
	    }
	    xOrigin += delta;
	} else if ((right < 0) && (left > 0)) {
	    delta = (left > -right) ? -right : left;
	    if (canvasPtr->xScrollIncrement > 0) {
		delta -= delta % canvasPtr->xScrollIncrement;
	    }
	    xOrigin -= delta;
	}
	if ((top < 0) && (bottom > 0)) {
	    delta = (bottom > -top) ? -top : bottom;
	    if (canvasPtr->yScrollIncrement > 0) {
		delta -= delta % canvasPtr->yScrollIncrement;
	    }
	    yOrigin += delta;
	} else if ((bottom < 0) && (top > 0)) {
	    delta = (top > -bottom) ? -bottom : top;
	    if (canvasPtr->yScrollIncrement > 0) {
		delta -= delta % canvasPtr->yScrollIncrement;
	    }
	    yOrigin -= delta;
	}
    }

    if ((xOrigin == canvasPtr->xOrigin) && (yOrigin == canvasPtr->yOrigin)) {
	return;
    }

    /*
     * Tricky point: must redisplay not only everything that's visible
     * in the window's final configuration, but also everything that was
     * visible in the initial configuration.  This is needed because some
     * item types, like windows, need to know when they move off-screen
     * so they can explicitly undisplay themselves.
     */

    Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
	    canvasPtr->xOrigin, canvasPtr->yOrigin,
	    canvasPtr->xOrigin + Tk_Width(canvasPtr->tkwin),
	    canvasPtr->yOrigin + Tk_Height(canvasPtr->tkwin));
    canvasPtr->xOrigin = xOrigin;
    canvasPtr->yOrigin = yOrigin;
    canvasPtr->flags |= UPDATE_SCROLLBARS;
    Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
	    canvasPtr->xOrigin, canvasPtr->yOrigin,
	    canvasPtr->xOrigin + Tk_Width(canvasPtr->tkwin),
	    canvasPtr->yOrigin + Tk_Height(canvasPtr->tkwin));
}

/*
 *----------------------------------------------------------------------
 *
 * GetStringsFromObjs
 *
 * Results:
 *	Converts object list into string list.
 *
 * Side effects:
 *	Memory is allocated for the argv array, which must
 *	be freed using ckfree() when no longer needed.
 *
 *----------------------------------------------------------------------
 */
/* ARGSUSED */
static CONST char **
GetStringsFromObjs(argc, objv)
    int argc;
    Tcl_Obj *CONST objv[];
{
    register int i;
    CONST char **argv;
    if (argc <= 0) {
	return NULL;
    }
    argv = (CONST char **) ckalloc((argc+1) * sizeof(char *));
    for (i = 0; i < argc; i++) {
	argv[i]=Tcl_GetStringFromObj(objv[i], (int *) NULL);
    }
    argv[argc] = 0;
    return argv;
}

/*
 *--------------------------------------------------------------
 *
 * Tk_CanvasPsColor --
 *
 *	This procedure is called by individual canvas items when
 *	they want to set a color value for output.  Given information
 *	about an X color, this procedure will generate Postscript
 *	commands to set up an appropriate color in Postscript.
 *
 * Results:
 *	Returns a standard Tcl return value.  If an error occurs
 *	then an error message will be left in interp->result.
 *	If no error occurs, then additional Postscript will be
 *	appended to interp->result.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

int
Tk_CanvasPsColor(interp, canvas, colorPtr)
    Tcl_Interp *interp;			/* Interpreter for returning Postscript
					 * or error message. */
    Tk_Canvas canvas;			/* Information about canvas. */
    XColor *colorPtr;			/* Information about color. */
{
    return Tk_PostscriptColor(interp, ((TkCanvas *) canvas)->psInfo,
	    colorPtr);
}

/*
 *--------------------------------------------------------------
 *
 * Tk_CanvasPsFont --
 *
 *	This procedure is called by individual canvas items when
 *	they want to output text.  Given information about an X
 *	font, this procedure will generate Postscript commands
 *	to set up an appropriate font in Postscript.
 *
 * Results:
 *	Returns a standard Tcl return value.  If an error occurs
 *	then an error message will be left in interp->result.
 *	If no error occurs, then additional Postscript will be
 *	appended to the interp->result.
 *
 * Side effects:
 *	The Postscript font name is entered into psInfoPtr->fontTable
 *	if it wasn't already there.
 *
 *--------------------------------------------------------------
 */

int
Tk_CanvasPsFont(interp, canvas, tkfont)
    Tcl_Interp *interp;			/* Interpreter for returning Postscript
					 * or error message. */
    Tk_Canvas canvas;			/* Information about canvas. */
    Tk_Font tkfont;			/* Information about font in which text
					 * is to be printed. */
{
    return Tk_PostscriptFont(interp, ((TkCanvas *) canvas)->psInfo, tkfont);
}

/*
 *--------------------------------------------------------------
 *
 * Tk_CanvasPsBitmap --
 *
 *	This procedure is called to output the contents of a
 *	sub-region of a bitmap in proper image data format for
 *	Postscript (i.e. data between angle brackets, one bit
 *	per pixel).
 *
 * Results:
 *	Returns a standard Tcl return value.  If an error occurs
 *	then an error message will be left in interp->result.
 *	If no error occurs, then additional Postscript will be
 *	appended to interp->result.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

int
Tk_CanvasPsBitmap(interp, canvas, bitmap, startX, startY, width, height)
    Tcl_Interp *interp;			/* Interpreter for returning Postscript
					 * or error message. */
    Tk_Canvas canvas;			/* Information about canvas. */
    Pixmap bitmap;			/* Bitmap for which to generate
					 * Postscript. */
    int startX, startY;			/* Coordinates of upper-left corner
					 * of rectangular region to output. */
    int width, height;			/* Height of rectangular region. */
{
    return Tk_PostscriptBitmap(interp, ((TkCanvas *) canvas)->tkwin,
	    ((TkCanvas *) canvas)->psInfo, bitmap, startX, startY,
	    width, height);
}

/*
 *--------------------------------------------------------------
 *
 * Tk_CanvasPsStipple --
 *
 *	This procedure is called by individual canvas items when
 *	they have created a path that they'd like to be filled with
 *	a stipple pattern.  Given information about an X bitmap,
 *	this procedure will generate Postscript commands to fill
 *	the current clip region using a stipple pattern defined by the
 *	bitmap.
 *
 * Results:
 *	Returns a standard Tcl return value.  If an error occurs
 *	then an error message will be left in interp->result.
 *	If no error occurs, then additional Postscript will be
 *	appended to interp->result.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

int
Tk_CanvasPsStipple(interp, canvas, bitmap)
    Tcl_Interp *interp;			/* Interpreter for returning Postscript
					 * or error message. */
    Tk_Canvas canvas;			/* Information about canvas. */
    Pixmap bitmap;			/* Bitmap to use for stippling. */
{
    return Tk_PostscriptStipple(interp, ((TkCanvas *) canvas)->tkwin,
	    ((TkCanvas *) canvas)->psInfo, bitmap);
}

/*
 *--------------------------------------------------------------
 *
 * Tk_CanvasPsY --
 *
 *	Given a y-coordinate in canvas coordinates, this procedure
 *	returns a y-coordinate to use for Postscript output.
 *
 * Results:
 *	Returns the Postscript coordinate that corresponds to
 *	"y".
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

double
Tk_CanvasPsY(canvas, y)
    Tk_Canvas canvas;			/* Token for canvas on whose behalf
					 * Postscript is being generated. */
    double y;				/* Y-coordinate in canvas coords. */
{
    return Tk_PostscriptY(y, ((TkCanvas *) canvas)->psInfo);
}

/*
 *--------------------------------------------------------------
 *
 * Tk_CanvasPsPath --
 *
 *	Given an array of points for a path, generate Postscript
 *	commands to create the path.
 *
 * Results:
 *	Postscript commands get appended to what's in interp->result.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

void
Tk_CanvasPsPath(interp, canvas, coordPtr, numPoints)
    Tcl_Interp *interp;			/* Put generated Postscript in this
					 * interpreter's result field. */
    Tk_Canvas canvas;			/* Canvas on whose behalf Postscript
					 * is being generated. */
    double *coordPtr;			/* Pointer to first in array of
					 * 2*numPoints coordinates giving
					 * points for path. */
    int numPoints;			/* Number of points at *coordPtr. */
{
    Tk_PostscriptPath(interp, ((TkCanvas *) canvas)->psInfo,
	    coordPtr, numPoints);
}
@


1.4
log
@touched all sources to ease next import
@
text
@d15 1
a15 1
 * RCS: @@(#) $Id: tkCanvas.c,v 1.7.6.2 2000/09/26 16:07:52 spolk Exp $
d294 1
a294 1
static char**		GetStringsFromObjs _ANSI_ARGS_((int argc,
d302 2
a303 3
static void		PrintScrollFractions _ANSI_ARGS_((int screen1,
			    int screen2, int object1, int object2,
			    char *string));
d332 3
a334 4
static TkClassProcs canvasClass = {
    NULL,			/* createProc. */
    CanvasWorldChanged,		/* geometryProc. */
    NULL			/* modalProc. */
d468 1
a468 1
    TkSetClassProcs(canvasPtr->tkwin, &canvasClass, (ClientData) canvasPtr);
d529 1
a529 1
    static char *optionStrings[] = {
d773 1
a773 1
	    char *command;
d778 1
a778 1
		char *string;
d794 1
a794 1
		Tcl_SetResult(interp, command, TCL_STATIC);
d903 1
a903 1
		char **args = GetStringsFromObjs(argc-3, argv+3);
d962 1
a962 1
	  char **args = GetStringsFromObjs(argc-3, argv+3);
d1391 2
a1392 1
	    return TCL_ERROR;
d1440 1
a1440 1
		char **args = GetStringsFromObjs(argc-3, argv+3);
d1529 1
a1529 1
	char **args = GetStringsFromObjs(argc, argv);
d1623 1
a1623 1
	static char *optionStrings[] = {
d1627 7
a1633 6
	if (Tcl_GetIndexFromObj(interp, argv[2], optionStrings, "scan option", 0,
		&index) != TCL_OK) {
	    return TCL_ERROR;
	}

	if ((argc != 5) && (argc != 5+index)) {
d1636 1
a1636 3
	    goto done;
	}
	if ((Tcl_GetIntFromObj(interp, argv[3], &x) != TCL_OK)
d1639 2
a1640 3
	    goto done;
	}
	if ((argc == 6) && (Tcl_GetIntFromObj(interp, argv[5], &gain) != TCL_OK)) {
d1642 1
a1642 3
            goto done;
	}
	if (!index) {
d1667 1
a1667 1
	static char *optionStrings[] = {
d1717 2
a1718 1
	    return TCL_ERROR;
d1816 2
a1817 1
	    PrintScrollFractions(canvasPtr->xOrigin + canvasPtr->inset,
d1820 1
a1820 1
		    canvasPtr->scrollX2, Tcl_GetStringResult(interp));
d1822 1
a1822 1
	    char **args = GetStringsFromObjs(argc, argv);
d1860 2
a1861 1
	    PrintScrollFractions(canvasPtr->yOrigin + canvasPtr->inset,
d1864 1
a1864 1
		    canvasPtr->scrollY2, Tcl_GetStringResult(interp));
d1866 1
a1866 1
	    char **args = GetStringsFromObjs(argc, argv);
d1931 3
a1934 7
    if (canvasPtr->tkwin != NULL) {
	Tcl_DeleteCommandFromToken(canvasPtr->interp, canvasPtr->widgetCmd);
    }
    if (canvasPtr->flags & REDRAW_PENDING) {
	Tcl_CancelIdleCall(DisplayCanvas, (ClientData) canvasPtr);
    }
	
d1961 5
a1965 9
    {
    	TagSearchExpr *expr, *next;

	expr = canvasPtr->bindTagExprs;
	while (expr) {
	    next = expr->next;
	    TagSearchExprDestroy(expr);
	    expr = next;
	}
d2011 2
a2012 1
	    argc, (char **) argv, (char *) canvasPtr, flags|TK_CONFIG_OBJS) != TCL_OK) {
d2065 1
a2065 1
	char **argv2;
d2442 10
a2451 1
	DestroyCanvas((char *) canvasPtr);
d3975 1
a3975 1
    static char *optionStrings[] = {
d5208 1
a5208 1
 * PrintScrollFractions --
d5211 3
a5213 3
 *	range" for what's in the canvas, print a string containing
 *	the scroll fractions.  This procedure is used for both x
 *	and y scrolling.
d5226 2
a5227 2
static void
PrintScrollFractions(screen1, screen2, object1, object2, string)
a5231 3
    char *string;		/* Two real numbers get printed here.  Must
				 * have enough storage for two %g
				 * conversions. */
d5234 1
d5253 2
a5254 1
    sprintf(string, "%g %g", f1, f2);
a5282 1
    char buffer[200];
d5314 5
a5318 3
	PrintScrollFractions(xOrigin + inset, xOrigin + width - inset,
                scrollX1, scrollX2, buffer);
	result = Tcl_VarEval(interp, xScrollCmd, " ", buffer, (char *) NULL);
d5327 5
a5331 3
	PrintScrollFractions(yOrigin + inset, yOrigin + height - inset,
                scrollY1, scrollY2, buffer);
	result = Tcl_VarEval(interp, yScrollCmd, " ", buffer, (char *) NULL);
d5489 1
a5489 1
static char **
d5495 1
a5495 1
    char **argv;
d5499 1
a5499 1
    argv = (char **) ckalloc((argc+1) * sizeof(char *));
a5704 2


@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d9 2
a10 2
 * Copyright (c) 1994-1995 Sun Microsystems, Inc.
 * Copyright (c) 1998 by Scriptics Corporation.
d15 1
a15 1
 * RCS: @@(#) $Id: tkCanvas.c,v 1.10 1999/01/26 04:11:20 jingham Exp $
d18 2
d29 1
d49 59
d155 3
d181 3
d214 1
d216 2
a217 9
 * Standard item types provided by Tk:
 */

extern Tk_ItemType tkArcType, tkBitmapType, tkImageType, tkLineType;
extern Tk_ItemType tkOvalType, tkPolygonType;
extern Tk_ItemType tkRectangleType, tkTextType, tkWindowType;

/*
 * Various Tk_Uid's used by this module (set up during initialization):
a218 1

d221 9
d232 1
a232 1
 * Statistics counters:
d235 3
a237 2
static int numIdSearches;
static int numSlowSearches;
d268 1
a268 1
			    Tcl_Interp *interp, int argc, char **argv));
d272 1
a272 1
			    TkCanvas *canvasPtr, int argc, char **argv,
d278 3
d282 8
a289 2
			    TkCanvas *canvasPtr, int argc, char **argv,
			    char *newTag, char *cmdName, char *option));
d291 1
a291 1
			    TkCanvas *canvasPtr, char **argv, Tk_Uid uid,
d294 2
d297 1
d299 1
d305 1
d307 1
a307 1
			    char *tag, Tk_Item *prevPtr));
d309 18
a326 1
			    char *tag, TagSearch *searchPtr));
d343 1
a343 1
 * Tk_CanvasCmd --
d359 1
a359 1
Tk_CanvasCmd(clientData, interp, argc, argv)
d364 1
a364 1
    char **argv;		/* Argument strings. */
d375 1
a375 2
	Tcl_AppendResult(interp, "wrong # args: should be \"",
		argv[0], " pathName ?options?\"", (char *) NULL);
d379 2
a380 1
    new = Tk_CreateWindowFromPath(interp, tkwin, argv[1], (char *) NULL);
d395 1
a395 1
    canvasPtr->widgetCmd = Tcl_CreateCommand(interp,
d459 8
a466 1
    canvasPtr->psInfoPtr = NULL;
d468 1
a468 1
    
d484 1
a484 1
    interp->result = Tk_PathName(canvasPtr->tkwin);
d516 1
a516 1
    char **argv;			/* Argument strings. */
d519 1
a519 1
    size_t length;
d523 1
d525 27
d554 5
a558 2
	Tcl_AppendResult(interp, "wrong # args: should be \"",
		argv[0], " option ?arg arg ...?\"", (char *) NULL);
d562 1
d564 2
a565 3
    c = argv[1][0];
    length = strlen(argv[1]);
    if ((c == 'a') && (strncmp(argv[1], "addtag", length) == 0)) {
d567 13
a579 9
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " addtags tag searchCommand ?arg arg ...?\"",
		    (char *) NULL);
	    goto error;
	}
	result = FindItems(interp, canvasPtr, argc-3, argv+3, argv[2], argv[0],
		" addtag tag");
    } else if ((c == 'b') && (strncmp(argv[1], "bbox", length) == 0)
	    && (length >= 2)) {
d586 3
a588 4
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " bbox tagOrId ?tagOrId ...?\"",
		    (char *) NULL);
	    goto error;
d592 1
d595 8
d630 8
a637 4
	    sprintf(interp->result, "%d %d %d %d", x1, y1, x2, y2);
	}
    } else if ((c == 'b') && (strncmp(argv[1], "bind", length) == 0)
	    && (length >= 2)) {
d641 3
a643 4
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " bind tagOrId ?sequence? ?command?\"",
		    (char *) NULL);
	    goto error;
d652 2
a653 1
	if (isdigit(UCHAR(argv[2][0]))) {
d658 1
a658 1
	    id = strtoul(argv[2], &end, 0);
d669 1
a669 1
		Tcl_AppendResult(interp, "item \"", argv[2],
d671 2
a672 1
		goto error;
d676 23
a698 1
	    object = (ClientData) Tk_GetUid(argv[2]);
d700 1
d714 1
d716 1
a716 1
	    if (argv[4][0] == 0) {
d718 1
a718 1
			object, argv[3]);
d721 31
a751 2
	    if (argv[4][0] == '+') {
		argv[4]++;
d755 1
a755 1
		    object, argv[3], argv[4], append);
d757 2
a758 1
		goto error;
d766 1
a766 1
			object, argv[3]);
d771 2
a772 1
		goto error;
d778 1
a778 1
		    object, argv[3]);
d780 17
a796 1
		goto error;
a797 1
	    interp->result = command;
d801 3
a803 1
    } else if ((c == 'c') && (strcmp(argv[1], "canvasx") == 0)) {
d806 1
d809 3
a811 4
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " canvasx screenx ?gridspacing?\"",
		    (char *) NULL);
	    goto error;
d813 3
a815 2
	if (Tk_GetPixels(interp, canvasPtr->tkwin, argv[2], &x) != TCL_OK) {
	    goto error;
d818 1
a818 1
	    if (Tk_CanvasGetCoord(interp, (Tk_Canvas) canvasPtr, argv[3],
d820 2
a821 1
		goto error;
d827 5
a831 2
	Tcl_PrintDouble(interp, GridAlign((double) x, grid), interp->result);
    } else if ((c == 'c') && (strcmp(argv[1], "canvasy") == 0)) {
d834 1
d837 3
a839 4
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " canvasy screeny ?gridspacing?\"",
		    (char *) NULL);
	    goto error;
d841 3
a843 2
	if (Tk_GetPixels(interp, canvasPtr->tkwin, argv[2], &y) != TCL_OK) {
	    goto error;
d846 1
a846 1
	    if (Tk_CanvasGetCoord(interp, (Tk_Canvas) canvasPtr,
d848 2
a849 1
		goto error;
d855 5
a859 3
	Tcl_PrintDouble(interp, GridAlign((double) y, grid), interp->result);
    } else if ((c == 'c') && (strncmp(argv[1], "cget", length) == 0)
	    && (length >= 2)) {
d861 3
a863 4
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " cget option\"",
		    (char *) NULL);
	    goto error;
d866 4
a869 3
		(char *) canvasPtr, argv[2], 0);
    } else if ((c == 'c') && (strncmp(argv[1], "configure", length) == 0)
	    && (length >= 3)) {
d875 1
a875 1
		    (char *) canvasPtr, argv[2], 0);
d880 3
a882 2
    } else if ((c == 'c') && (strncmp(argv[1], "coords", length) == 0)
	    && (length >= 3)) {
d884 3
a886 4
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " coords tagOrId ?x y x y ...?\"",
		    (char *) NULL);
	    goto error;
d888 1
d890 6
d898 1
a898 2
		Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
			itemPtr->x1, itemPtr->y1, itemPtr->x2, itemPtr->y2);
d901 1
d904 6
d912 1
a912 2
		Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
			itemPtr->x1, itemPtr->y1, itemPtr->x2, itemPtr->y2);
d915 3
a917 2
    } else if ((c == 'c') && (strncmp(argv[1], "create", length) == 0)
	    && (length >= 2)) {
d921 1
d924 2
a925 1
	
d927 3
a929 3
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " create type ?arg arg ...?\"", (char *) NULL);
	    goto error;
d931 2
a932 2
	c = argv[2][0];
	length = strlen(argv[2]);
d935 1
a935 1
		    && (strncmp(argv[2], typePtr->name, length) == 0)) {
d940 3
a942 2
			    argv[2], "\"", (char *) NULL);
		    goto error;
d958 12
a969 2
	if ((*typePtr->createProc)(interp, (Tk_Canvas) canvasPtr,
		itemPtr, argc-3, argv+3) != TCL_OK) {
d971 2
a972 1
	    goto error;
d987 2
a988 2
	Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
		itemPtr->x1, itemPtr->y1, itemPtr->x2, itemPtr->y2);
d990 5
a994 3
	sprintf(interp->result, "%d", itemPtr->id);
    } else if ((c == 'd') && (strncmp(argv[1], "dchars", length) == 0)
	    && (length >= 2)) {
d996 1
d999 3
a1001 4
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " dchars tagOrId first ?last?\"",
		    (char *) NULL);
	    goto error;
d1003 1
d1006 7
d1017 9
a1025 3
	    if ((*itemPtr->typePtr->indexProc)(interp, (Tk_Canvas) canvasPtr,
		    itemPtr, argv[3], &first) != TCL_OK) {
		goto error;
d1028 9
a1036 4
		if ((*itemPtr->typePtr->indexProc)(interp,
			(Tk_Canvas) canvasPtr, itemPtr, argv[4], &last)
			!= TCL_OK) {
		    goto error;
d1045 2
a1046 1
	     * the old area.
d1049 3
a1051 2
	    Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
		    itemPtr->x1, itemPtr->y1, itemPtr->x2, itemPtr->y2);
d1054 6
a1059 2
	    Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
		    itemPtr->x1, itemPtr->y1, itemPtr->x2, itemPtr->y2);
d1061 3
a1063 2
    } else if ((c == 'd') && (strncmp(argv[1], "delete", length) == 0)
	    && (length >= 2)) {
d1068 1
d1071 8
a1078 2
		Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
			itemPtr->x1, itemPtr->y1, itemPtr->x2, itemPtr->y2);
d1127 3
a1129 2
    } else if ((c == 'd') && (strncmp(argv[1], "dtag", length) == 0)
	    && (length >= 2)) {
d1134 3
a1136 4
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " dtag tagOrId ?tagToDelete?\"",
		    (char *) NULL);
	    goto error;
d1139 1
a1139 1
	    tag = Tk_GetUid(argv[3]);
d1141 1
a1141 1
	    tag = Tk_GetUid(argv[2]);
d1143 1
d1146 7
d1160 3
a1162 2
    } else if ((c == 'f') && (strncmp(argv[1], "find", length) == 0)
	    && (length >= 2)) {
d1164 13
a1176 9
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " find searchCommand ?arg arg ...?\"",
		    (char *) NULL);
	    goto error;
	}
	result = FindItems(interp, canvasPtr, argc-2, argv+2, (char *) NULL,
		argv[0]," find");
    } else if ((c == 'f') && (strncmp(argv[1], "focus", length) == 0)
	    && (length >= 2)) {
d1178 3
a1180 4
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " focus ?tagOrId?\"",
		    (char *) NULL);
	    goto error;
d1185 4
a1188 1
		sprintf(interp->result, "%d", itemPtr->id);
d1193 1
a1193 2
	    Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
		    itemPtr->x1, itemPtr->y1, itemPtr->x2, itemPtr->y2);
d1195 1
a1195 1
	if (argv[2][0] == 0) {
d1199 1
d1202 7
d1218 1
a1218 2
	    Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
		    itemPtr->x1, itemPtr->y1, itemPtr->x2, itemPtr->y2);
d1220 3
a1222 1
    } else if ((c == 'g') && (strncmp(argv[1], "gettags", length) == 0)) {
d1224 3
a1226 3
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " gettags tagOrId\"", (char *) NULL);
	    goto error;
d1228 1
d1230 6
d1242 3
a1244 2
    } else if ((c == 'i') && (strncmp(argv[1], "icursor", length) == 0)
	    && (length >= 2)) {
d1248 3
a1250 4
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " icursor tagOrId index\"",
		    (char *) NULL);
	    goto error;
d1252 1
d1255 7
d1266 9
a1274 3
	    if ((*itemPtr->typePtr->indexProc)(interp, (Tk_Canvas) canvasPtr,
		    itemPtr, argv[3], &index) != TCL_OK) {
		goto error;
d1280 1
a1280 2
		Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
			itemPtr->x1, itemPtr->y1, itemPtr->x2, itemPtr->y2);
d1283 4
a1286 2
    } else if ((c == 'i') && (strncmp(argv[1], "index", length) == 0)
	    && (length >= 3)) {
d1288 1
d1291 3
a1293 4
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " index tagOrId string\"",
		    (char *) NULL);
	    goto error;
d1295 1
d1298 7
d1311 10
a1320 2
		    argv[2], "\"", (char *) NULL);
	    goto error;
d1322 8
a1329 7
	if ((*itemPtr->typePtr->indexProc)(interp, (Tk_Canvas) canvasPtr,
		itemPtr, argv[3], &index) != TCL_OK) {
	    goto error;
	}
	sprintf(interp->result, "%d", index);
    } else if ((c == 'i') && (strncmp(argv[1], "insert", length) == 0)
	    && (length >= 3)) {
d1331 1
d1334 3
a1336 4
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " insert tagOrId beforeThis string\"",
		    (char *) NULL);
	    goto error;
d1338 1
d1341 7
d1352 9
a1360 3
	    if ((*itemPtr->typePtr->indexProc)(interp, (Tk_Canvas) canvasPtr,
		    itemPtr, argv[3], &beforeThis) != TCL_OK) {
		goto error;
d1366 3
a1368 1
	     * larger or smaller than the old area.
d1371 16
a1386 6
	    Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
		    itemPtr->x1, itemPtr->y1, itemPtr->x2, itemPtr->y2);
	    (*itemPtr->typePtr->insertProc)((Tk_Canvas) canvasPtr,
		    itemPtr, beforeThis, argv[4]);
	    Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr, itemPtr->x1,
		    itemPtr->y1, itemPtr->x2, itemPtr->y2);
d1388 3
a1390 2
    } else if ((c == 'i') && (strncmp(argv[1], "itemcget", length) == 0)
	    && (length >= 6)) {
d1392 1
a1392 3
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " itemcget tagOrId option\"",
		    (char *) NULL);
d1395 1
d1397 6
d1406 1
a1406 1
		    argv[3], 0);
d1408 3
a1410 2
    } else if ((c == 'i') && (strncmp(argv[1], "itemconfigure", length) == 0)
	    && (length >= 6)) {
d1412 3
a1414 4
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " itemconfigure tagOrId ?option value ...?\"",
		    (char *) NULL);
	    goto error;
d1416 1
d1419 7
d1433 1
a1433 1
			argv[3], 0);
d1435 2
a1436 2
		Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
			itemPtr->x1, itemPtr->y1, itemPtr->x2, itemPtr->y2);
d1440 8
a1447 2
		Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
			itemPtr->x1, itemPtr->y1, itemPtr->x2, itemPtr->y2);
d1454 3
a1456 1
    } else if ((c == 'l') && (strncmp(argv[1], "lower", length) == 0)) {
d1460 3
a1462 4
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " lower tagOrId ?belowThis?\"",
		    (char *) NULL);
	    goto error;
d1473 1
d1475 6
d1482 1
a1482 1
		Tcl_AppendResult(interp, "tag \"", argv[3],
d1484 1
a1484 1
		goto error;
d1488 1
d1490 8
a1497 1
    } else if ((c == 'm') && (strncmp(argv[1], "move", length) == 0)) {
d1501 3
a1503 4
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " move tagOrId xAmount yAmount\"",
		    (char *) NULL);
	    goto error;
d1505 2
a1506 2
	if ((Tk_CanvasGetCoord(interp, (Tk_Canvas) canvasPtr, argv[3],
		&xAmount) != TCL_OK) || (Tk_CanvasGetCoord(interp,
d1508 2
a1509 1
	    goto error;
d1511 1
d1514 8
a1521 2
	    Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
		    itemPtr->x1, itemPtr->y1, itemPtr->x2, itemPtr->y2);
d1524 1
a1524 2
	    Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
		    itemPtr->x1, itemPtr->y1, itemPtr->x2, itemPtr->y2);
d1527 9
a1535 3
    } else if ((c == 'p') && (strncmp(argv[1], "postscript", length) == 0)) {
	result = TkCanvPostscriptCmd(canvasPtr, interp, argc, argv);
    } else if ((c == 'r') && (strncmp(argv[1], "raise", length) == 0)) {
d1539 3
a1541 4
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " raise tagOrId ?aboveThis?\"",
		    (char *) NULL);
	    goto error;
d1553 1
d1556 7
d1566 1
a1566 1
		Tcl_AppendResult(interp, "tagOrId \"", argv[3],
d1568 2
a1569 1
		goto error;
d1572 1
d1574 9
a1582 2
    } else if ((c == 's') && (strncmp(argv[1], "scale", length) == 0)
	    && (length >= 3)) {
d1586 3
a1588 4
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " scale tagOrId xOrigin yOrigin xScale yScale\"",
		    (char *) NULL);
	    goto error;
d1590 1
a1590 1
	if ((Tk_CanvasGetCoord(interp, (Tk_Canvas) canvasPtr,
d1592 1
a1592 1
		|| (Tk_CanvasGetCoord(interp, (Tk_Canvas) canvasPtr,
d1594 4
a1597 3
		|| (Tcl_GetDouble(interp, argv[5], &xScale) != TCL_OK)
		|| (Tcl_GetDouble(interp, argv[6], &yScale) != TCL_OK)) {
	    goto error;
d1600 3
a1602 2
	    interp->result = "scale factor cannot be zero";
	    goto error;
d1604 1
d1607 8
a1614 2
	    Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
		    itemPtr->x1, itemPtr->y1, itemPtr->x2, itemPtr->y2);
d1617 1
a1617 2
	    Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
		    itemPtr->x1, itemPtr->y1, itemPtr->x2, itemPtr->y2);
d1620 12
a1631 3
    } else if ((c == 's') && (strncmp(argv[1], "scan", length) == 0)
	    && (length >= 3)) {
	int x, y;
d1633 13
a1645 8
	if (argc != 5) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " scan mark|dragto x y\"", (char *) NULL);
	    goto error;
	}
	if ((Tcl_GetInt(interp, argv[3], &x) != TCL_OK)
		|| (Tcl_GetInt(interp, argv[4], &y) != TCL_OK)){
	    goto error;
d1647 1
a1647 2
	if ((argv[2][0] == 'm')
		&& (strncmp(argv[2], "mark", strlen(argv[2])) == 0)) {
d1652 1
a1652 2
	} else if ((argv[2][0] == 'd')
		&& (strncmp(argv[2], "dragto", strlen(argv[2])) == 0)) {
d1660 1
a1660 1
	    tmp = canvasPtr->scanXOrigin - 10*(x - canvasPtr->scanX)
d1663 1
a1663 1
	    tmp = canvasPtr->scanYOrigin - 10*(y - canvasPtr->scanY)
a1666 4
	} else {
	    Tcl_AppendResult(interp, "bad scan option \"", argv[2],
		    "\": must be mark or dragto", (char *) NULL);
	    goto error;
d1668 10
a1677 3
    } else if ((c == 's') && (strncmp(argv[1], "select", length) == 0)
	    && (length >= 2)) {
	int index;
d1680 3
a1682 3
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " select option ?tagOrId? ?arg?\"", (char *) NULL);
	    goto error;
d1685 1
d1688 7
d1703 3
a1705 2
			argv[3], "\"", (char *) NULL);
		goto error;
d1709 9
a1717 3
	    if ((*itemPtr->typePtr->indexProc)(interp, (Tk_Canvas) canvasPtr,
		    itemPtr, argv[4], &index) != TCL_OK) {
		goto error;
d1720 6
a1725 3
	length = strlen(argv[2]);
	c = argv[2][0];
	if ((c == 'a') && (strncmp(argv[2], "adjust", length) == 0)) {
d1727 3
a1729 4
		Tcl_AppendResult(interp, "wrong # args: should be \"",
			argv[0], " select adjust tagOrId index\"",
			(char *) NULL);
		goto error;
d1742 3
a1744 2
	} else if ((c == 'c') && (argv[2] != NULL)
		&& (strncmp(argv[2], "clear", length) == 0)) {
d1746 3
a1748 3
		Tcl_AppendResult(interp, "wrong # args: should be \"",
			argv[0], " select clear\"", (char *) NULL);
		goto error;
d1751 2
a1752 5
		Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
			canvasPtr->textInfo.selItemPtr->x1,
			canvasPtr->textInfo.selItemPtr->y1,
			canvasPtr->textInfo.selItemPtr->x2,
			canvasPtr->textInfo.selItemPtr->y2);
d1756 3
a1758 1
	} else if ((c == 'f') && (strncmp(argv[2], "from", length) == 0)) {
d1760 3
a1762 4
		Tcl_AppendResult(interp, "wrong # args: should be \"",
			argv[0], " select from tagOrId index\"",
			(char *) NULL);
		goto error;
d1766 3
a1768 1
	} else if ((c == 'i') && (strncmp(argv[2], "item", length) == 0)) {
d1770 3
a1772 3
		Tcl_AppendResult(interp, "wrong # args: should be \"",
			argv[0], " select item\"", (char *) NULL);
		goto error;
d1775 4
a1778 2
		sprintf(interp->result, "%d",
			canvasPtr->textInfo.selItemPtr->id);
d1780 3
a1782 1
	} else if ((c == 't') && (strncmp(argv[2], "to", length) == 0)) {
d1784 3
a1786 4
		Tcl_AppendResult(interp, "wrong # args: should be \"",
			argv[0], " select to tagOrId index\"",
			(char *) NULL);
		goto error;
d1789 2
a1790 5
	} else {
	    Tcl_AppendResult(interp, "bad select option \"", argv[2],
		    "\": must be adjust, clear, from, item, or to",
		    (char *) NULL);
	    goto error;
d1792 3
a1794 1
    } else if ((c == 't') && (strncmp(argv[1], "type", length) == 0)) {
d1796 3
a1798 3
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " type tag\"", (char *) NULL);
	    goto error;
d1800 1
d1802 6
d1809 1
a1809 1
	    interp->result = itemPtr->typePtr->name;
d1811 3
a1813 1
    } else if ((c == 'x') && (strncmp(argv[1], "xview", length) == 0)) {
d1823 1
a1823 1
		    canvasPtr->scrollX2, interp->result);
d1825 3
a1827 1
	    type = Tk_GetScrollInfo(interp, argc, argv, &fraction, &count);
d1830 2
a1831 1
		    goto error;
d1854 3
a1856 1
    } else if ((c == 'y') && (strncmp(argv[1], "yview", length) == 0)) {
d1866 1
a1866 1
		    canvasPtr->scrollY2, interp->result);
d1868 3
a1870 1
	    type = Tk_GetScrollInfo(interp, argc, argv, &fraction, &count);
d1873 2
a1874 1
		    goto error;
d1898 2
a1899 10
    } else {
	Tcl_AppendResult(interp, "bad option \"", argv[1],
		"\": must be addtag, bbox, bind, ",
		"canvasx, canvasy, cget, configure, coords, create, ",
		"dchars, delete, dtag, find, focus, ",
		"gettags, icursor, index, insert, itemcget, itemconfigure, ",
		"lower, move, postscript, raise, scale, scan, ",
		"select, type, xview, or yview",
		(char *) NULL);  
	goto error;
d1902 3
a1906 4

    error:
    Tcl_Release((ClientData) canvasPtr);
    return TCL_ERROR;
d1934 7
d1966 12
d1983 1
d1998 1
a1998 1
 *	returned, then interp->result contains an error message.
d2014 1
a2014 1
    char **argv;		/* Arguments. */
d2021 1
a2021 1
	    argc, argv, (char *) canvasPtr, flags) != TCL_OK) {
d2039 1
d2041 2
a2042 4
    gcValues.graphics_exposures = False;
    new = Tk_GetGCColor(canvasPtr->tkwin,
	    GCFunction|GCForeground|GCGraphicsExposures, &gcValues,
	    Tk_3DBorderColor(canvasPtr->bgBorder), NULL);
d2102 16
d2208 1
d2230 14
d2335 1
a2335 1
		if (!itemPtr->typePtr->alwaysRedraw
d2343 5
d2384 4
a2387 2
	    GC gc;
    
d2389 1
a2389 1
		gc = Tk_GCForColor(canvasPtr->highlightColorPtr,
d2391 2
d2394 2
a2395 2
		gc = Tk_GCForColor(canvasPtr->highlightBgColorPtr,
			Tk_WindowId(tkwin));
a2396 2
	    Tk_DrawFocusHighlight(tkwin, gc, canvasPtr->highlightWidth,
		    Tk_WindowId(tkwin));
d2401 1
a2401 1
    canvasPtr->flags &= ~REDRAW_PENDING;
d2451 1
a2451 9
	if (canvasPtr->tkwin != NULL) {
	    canvasPtr->tkwin = NULL;
            Tcl_DeleteCommandFromToken(canvasPtr->interp,
		    canvasPtr->widgetCmd);
	}
	if (canvasPtr->flags & REDRAW_PENDING) {
	    Tcl_CancelIdleCall(DisplayCanvas, (ClientData) canvasPtr);
	}
	Tcl_EventuallyFree((ClientData) canvasPtr, DestroyCanvas);
d2485 1
a2485 1
	    if (itemPtr->typePtr->alwaysRedraw) {
d2557 5
a2561 1
    if ((x1 == x2) || (y1 == y2)) {
d2564 8
a2571 1
    if (canvasPtr->flags & REDRAW_PENDING) {
d2589 3
d2600 1
a2600 1
 * Tk_CreateItemType --
d2602 2
a2603 2
 *	This procedure may be invoked to add a new kind of canvas
 *	element to the core item types supported by Tk.
d2609 1
a2609 5
 *	From now on, the new item type will be useable in canvas
 *	widgets (e.g. typePtr->name can be used as the item type
 *	in "create" widget commands).  If there was already a
 *	type with the same name as in typePtr, it is replaced with
 *	the new type.
d2614 4
a2617 5
void
Tk_CreateItemType(typePtr)
    Tk_ItemType *typePtr;		/* Information about item type;
					 * storage must be statically
					 * allocated (must live forever). */
d2619 70
a2688 4
    Tk_ItemType *typePtr2, *prevPtr;

    if (typeList == NULL) {
	InitCanvas();
d2771 1
d2774 9
d2785 1
d2812 1
a2812 1
StartTagSearch(canvasPtr, tag, searchPtr)
d2815 1
a2815 1
    char *tag;				/* String giving tag value. */
d2823 1
d2825 5
d2848 2
a2849 2
	
	numIdSearches++;
d2853 1
a2853 1
	    lastPtr = canvasPtr->hotPrevPtr;
d2856 1
a2856 1
		numSlowSearches++;
d2874 1
a2874 2
    if (uid == allUid) {

d2993 847
d3855 1
a3855 1
 *	to interp->result;  otherwise tag is added to itemPtr's
d3877 2
a3878 1
	char msg[30];
d3932 3
a3934 3
 *	returned in interp->result.  If newTag is NULL, then
 *	the normal interp->result is an empty string.  If an error
 *	occurs, then interp->result will hold an error message.
d3945 5
a3949 1
FindItems(interp, canvasPtr, argc, argv, newTag, cmdName, option)
d3955 1
a3955 1
    char **argv;			/* Arguments that describe what items
d3958 1
a3958 1
    char *newTag;			/* If non-NULL, gives new tag to set
d3961 7
a3967 6
					 * in interp->result. */
    char *cmdName;			/* Name of original Tcl command, for
					 * use in error messages. */
    char *option;			/* For error messages:  gives option
					 * from Tcl command and other stuff
					 * up to what's in argc/argv. */
d3969 1
a3969 2
    int c;
    size_t length;
d3971 1
d3974 9
d3985 1
a3985 1
	uid = Tk_GetUid(newTag);
d3989 6
a3994 4
    c = argv[0][0];
    length = strlen(argv[0]);
    if ((c == 'a') && (strncmp(argv[0], "above", length) == 0)
	    && (length >= 2)) {
d3996 2
a3997 3
	if (argc != 2) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    cmdName, option, " above tagOrId", (char *) NULL);
d4000 2
a4001 1
	for (itemPtr = StartTagSearch(canvasPtr, argv[1], &search);
d4003 7
d4015 5
a4019 5
    } else if ((c == 'a') && (strncmp(argv[0], "all", length) == 0)
	    && (length >= 2)) {
	if (argc != 1) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    cmdName, option, " all", (char *) NULL);
d4027 3
a4029 1
    } else if ((c == 'b') && (strncmp(argv[0], "below", length) == 0)) {
d4032 2
a4033 3
	if (argc != 2) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    cmdName, option, " below tagOrId", (char *) NULL);
d4036 12
a4047 3
	itemPtr = StartTagSearch(canvasPtr, argv[1], &search);
	if (itemPtr->prevPtr != NULL) {
	    DoItem(interp, itemPtr->prevPtr, uid);
d4049 3
a4051 1
    } else if ((c == 'c') && (strncmp(argv[0], "closest", length) == 0)) {
d4057 2
a4058 4
	if ((argc < 3) || (argc > 5)) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    cmdName, option, " closest x y ?halo? ?start?",
		    (char *) NULL);
d4061 3
a4063 3
	if ((Tk_CanvasGetCoord(interp, (Tk_Canvas) canvasPtr, argv[1],
		&coords[0]) != TCL_OK) || (Tk_CanvasGetCoord(interp,
		(Tk_Canvas) canvasPtr, argv[2], &coords[1]) != TCL_OK)) {
d4066 2
a4067 2
	if (argc > 3) {
	    if (Tk_CanvasGetCoord(interp, (Tk_Canvas) canvasPtr, argv[3],
d4073 1
a4073 1
			argv[3], "\"", (char *) NULL);
d4085 9
a4093 2
	if (argc == 5) {
	    itemPtr = StartTagSearch(canvasPtr, argv[4], &search);
d4108 4
d4149 4
d4168 5
a4172 4
    } else if ((c == 'e') && (strncmp(argv[0], "enclosed", length) == 0)) {
	if (argc != 5) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    cmdName, option, " enclosed x1 y1 x2 y2", (char *) NULL);
d4175 5
a4179 6
	return FindArea(interp, canvasPtr, argv+1, uid, 1);
    } else if ((c == 'o') && (strncmp(argv[0], "overlapping", length) == 0)) {
	if (argc != 5) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    cmdName, option, " overlapping x1 y1 x2 y2",
		    (char *) NULL);
d4182 5
a4186 5
	return FindArea(interp, canvasPtr, argv+1, uid, 0);
    } else if ((c == 'w') && (strncmp(argv[0], "withtag", length) == 0)) {
		if (argc != 2) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    cmdName, option, " withtag tagOrId", (char *) NULL);
d4189 2
a4190 1
	for (itemPtr = StartTagSearch(canvasPtr, argv[1], &search);
d4192 7
d4201 1
a4201 5
    } else  {
	Tcl_AppendResult(interp, "bad search command \"", argv[0],
		"\": must be above, all, below, closest, enclosed, ",
		"overlapping, or withtag", (char *) NULL);
	return TCL_ERROR;
d4217 3
a4219 3
 *	by the rectangle given by argc is returned in interp->result.
 *	If newTag is NULL, then the normal interp->result is an
 *	empty string.  If an error occurs, then interp->result will
d4236 1
a4236 1
    char **argv;			/* Array of four arguments that
d4242 1
a4242 1
					 * in interp->result. */
d4251 1
a4251 1
    if ((Tk_CanvasGetCoord(interp, (Tk_Canvas) canvasPtr, argv[0],
d4253 1
a4253 1
	    || (Tk_CanvasGetCoord(interp, (Tk_Canvas) canvasPtr, argv[1],
d4255 1
a4255 1
	    || (Tk_CanvasGetCoord(interp, (Tk_Canvas) canvasPtr, argv[2],
d4257 1
a4257 1
	    || (Tk_CanvasGetCoord(interp, (Tk_Canvas) canvasPtr, argv[3],
d4279 4
d4315 1
d4318 4
d4323 1
a4323 1
    char *tag;			/* Tag identifying items to be moved
d4328 3
d4333 1
d4335 1
d4345 1
d4348 7
d4385 1
a4385 2
	Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr, itemPtr->x1, itemPtr->y1,
		itemPtr->x2, itemPtr->y2);
d4395 1
d4397 3
d4420 3
d4540 3
a4542 2
 *	current item and a fake enter event on the new current
 *	item.
d4568 1
d4690 3
d4694 1
d4719 1
d4722 7
d4732 4
d4737 9
d4759 2
a4760 1
 *	is "close" to the coordinates.
d4790 5
d4839 4
d4856 1
d4866 29
d4901 3
d4905 1
d4910 13
d4977 2
a4978 5
	Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
		canvasPtr->textInfo.focusItemPtr->x1,
		canvasPtr->textInfo.focusItemPtr->y1,
		canvasPtr->textInfo.focusItemPtr->x2,
		canvasPtr->textInfo.focusItemPtr->y2);
d5021 2
a5022 5
	Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
		canvasPtr->textInfo.focusItemPtr->x1,
		canvasPtr->textInfo.focusItemPtr->y1,
		canvasPtr->textInfo.focusItemPtr->x2,
		canvasPtr->textInfo.focusItemPtr->y2);
d5072 2
a5073 5
	Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
		canvasPtr->textInfo.selItemPtr->x1,
		canvasPtr->textInfo.selItemPtr->y1,
		canvasPtr->textInfo.selItemPtr->x2,
		canvasPtr->textInfo.selItemPtr->y2);
d5091 1
a5091 2
	Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
		itemPtr->x1, itemPtr->y1, itemPtr->x2, itemPtr->y2);
d5165 2
a5166 5
	Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
		canvasPtr->textInfo.selItemPtr->x1,
		canvasPtr->textInfo.selItemPtr->y1,
		canvasPtr->textInfo.selItemPtr->x2,
		canvasPtr->textInfo.selItemPtr->y2);
d5471 234
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d9 2
a10 2
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
 * Copyright (c) 1998-1999 by Scriptics Corporation.
d15 1
a15 1
 * RCS: @@(#) $Id: tkCanvas.c,v 1.7.6.2 2000/09/26 16:07:52 spolk Exp $
a17 2
/* #define USE_OLD_TAG_SEARCH 1 */

a26 1
#ifdef USE_OLD_TAG_SEARCH
a45 59
#else /* USE_OLD_TAG_SEARCH */
/*
 * The structure defined below is used to keep track of a tag search
 * in progress.  No field should be accessed by anyone other than
 * TagSearchScan, TagSearchFirst, TagSearchNext,
 * TagSearchScanExpr, TagSearchEvalExpr, 
 * TagSearchExprInit, TagSearchExprDestroy,
 * TagSearchDestroy.
 * (
 *   Not quite accurate: the TagSearch structure is also accessed from:
 *    CanvasWidgetCmd, FindItems, RelinkItems
 *   The only instances of the structure are owned by:
 *    CanvasWidgetCmd
 *   CanvasWidgetCmd is the only function that calls:
 *    FindItems, RelinkItems
 *   CanvasWidgetCmd, FindItems, RelinkItems, are the only functions that call
 *    TagSearch*
 * )
 */

typedef struct TagSearch {
    TkCanvas *canvasPtr;	/* Canvas widget being searched. */
    Tk_Item *currentPtr;	/* Pointer to last item returned. */
    Tk_Item *lastPtr;		/* The item right before the currentPtr
				 * is tracked so if the currentPtr is
				 * deleted we don't have to start from the
				 * beginning. */
    int searchOver;		/* Non-zero means NextItem should always
				 * return NULL. */
    int type;			/* search type */
    int id;			/* item id for searches by id */

    char *string;		/* tag expression string */
    int stringIndex;		/* current position in string scan */
    int stringLength;		/* length of tag expression string */

    char *rewritebuffer;	/* tag string (after removing escapes) */
    unsigned int rewritebufferAllocated;	/* available space for rewrites */

    TagSearchExpr *expr;	/* compiled tag expression */
} TagSearch;
#endif /* USE_OLD_TAG_SEARCH */

/*
 * Custom option for handling "-state" and "-offset"
 */

static Tk_CustomOption stateOption = {
    (Tk_OptionParseProc *) TkStateParseProc,
    TkStatePrintProc,
    (ClientData) NULL	/* only "normal" and "disabled" */
};

static Tk_CustomOption offsetOption = {
    (Tk_OptionParseProc *) TkOffsetParseProc,
    TkOffsetPrintProc,
    (ClientData) TK_OFFSET_RELATIVE
};

a92 3
    {TK_CONFIG_CUSTOM, "-offset", "offset", "Offset", "0,0",
	Tk_Offset(TkCanvas, tsoffset),TK_CONFIG_DONT_SET_DEFAULT,
	&offsetOption},
a115 3
    {TK_CONFIG_CUSTOM, "-state", "state", "State",
	"normal", Tk_Offset(TkCanvas, canvas_state), TK_CONFIG_DONT_SET_DEFAULT,
	&stateOption},
a145 1
#ifndef USE_OLD_TAG_SEARCH
d147 9
a155 2
 * Uids for operands in compiled advanced tag search expressions
 * Initialization is done by InitCanvas()
d157 1
a159 9
static Tk_Uid andUid = NULL;
static Tk_Uid orUid = NULL;
static Tk_Uid xorUid = NULL;
static Tk_Uid parenUid = NULL;
static Tk_Uid negparenUid = NULL;
static Tk_Uid endparenUid = NULL;
static Tk_Uid tagvalUid = NULL;
static Tk_Uid negtagvalUid = NULL;
#endif /* USE_OLD_TAG_SEARCH */
d162 1
a162 1
 * Standard item types provided by Tk:
d165 2
a166 3
extern Tk_ItemType tkArcType, tkBitmapType, tkImageType, tkLineType;
extern Tk_ItemType tkOvalType, tkPolygonType;
extern Tk_ItemType tkRectangleType, tkTextType, tkWindowType;
d197 1
a197 1
			    Tcl_Interp *interp, int argc, Tcl_Obj *CONST *argv));
d201 1
a201 1
			    TkCanvas *canvasPtr, int argc, Tcl_Obj *CONST *argv,
a206 3
static void		EventuallyRedrawItem _ANSI_ARGS_((Tk_Canvas canvas,
			    Tk_Item *itemPtr));
#ifdef USE_OLD_TAG_SEARCH
d208 2
a209 8
			    TkCanvas *canvasPtr, int argc, Tcl_Obj *CONST *argv,
			    Tcl_Obj *newTagObj, int first));
#else /* USE_OLD_TAG_SEARCH */
static int		FindItems _ANSI_ARGS_((Tcl_Interp *interp,
			    TkCanvas *canvasPtr, int argc, Tcl_Obj *CONST *argv,
			    Tcl_Obj *newTagObj, int first,
			    TagSearch **searchPtrPtr));
#endif /* USE_OLD_TAG_SEARCH */
d211 1
a211 1
			    TkCanvas *canvasPtr, Tcl_Obj *CONST *argv, Tk_Uid uid,
a213 2
static char**		GetStringsFromObjs _ANSI_ARGS_((int argc,
			    Tcl_Obj *CONST *objv));
a214 1
#ifdef USE_OLD_TAG_SEARCH
a215 1
#endif /* USE_OLD_TAG_SEARCH */
a220 1
#ifdef USE_OLD_TAG_SEARCH
d222 1
a222 1
			    Tcl_Obj *tag, Tk_Item *prevPtr));
d224 1
a224 18
			    Tcl_Obj *tag, TagSearch *searchPtr));
#else /* USE_OLD_TAG_SEARCH */
static int		RelinkItems _ANSI_ARGS_((TkCanvas *canvasPtr,
			    Tcl_Obj *tag, Tk_Item *prevPtr,
			    TagSearch **searchPtrPtr));
static void 		TagSearchExprInit _ANSI_ARGS_ ((
			    TagSearchExpr **exprPtrPtr));
static void		TagSearchExprDestroy _ANSI_ARGS_((TagSearchExpr *expr));
static void		TagSearchDestroy _ANSI_ARGS_((TagSearch *searchPtr));
static int		TagSearchScan _ANSI_ARGS_((TkCanvas *canvasPtr,
			    Tcl_Obj *tag, TagSearch **searchPtrPtr));
static int		TagSearchScanExpr _ANSI_ARGS_((Tcl_Interp *interp,
			    TagSearch *searchPtr, TagSearchExpr *expr));
static int		TagSearchEvalExpr _ANSI_ARGS_((TagSearchExpr *expr,
			    Tk_Item *itemPtr));
static Tk_Item *	TagSearchFirst _ANSI_ARGS_((TagSearch *searchPtr));
static Tk_Item *	TagSearchNext _ANSI_ARGS_((TagSearch *searchPtr));
#endif /* USE_OLD_TAG_SEARCH */
d241 1
a241 1
 * Tk_CanvasObjCmd --
d257 1
a257 1
Tk_CanvasObjCmd(clientData, interp, argc, argv)
d262 1
a262 1
    Tcl_Obj *CONST argv[];	/* Argument objects. */
d273 2
a274 1
	Tcl_WrongNumArgs(interp, 1, argv, "pathName ?options?");
d278 1
a278 2
    new = Tk_CreateWindowFromPath(interp, tkwin,
	    Tcl_GetString(argv[1]), (char *) NULL);
d293 1
a293 1
    canvasPtr->widgetCmd = Tcl_CreateObjCommand(interp,
d357 1
a357 8
    canvasPtr->psInfo = NULL;
    canvasPtr->canvas_state = TK_STATE_NORMAL;
    canvasPtr->tsoffset.flags = 0;
    canvasPtr->tsoffset.xoffset = 0;
    canvasPtr->tsoffset.yoffset = 0;
#ifndef USE_OLD_TAG_SEARCH
    canvasPtr->bindTagExprs = NULL;
#endif
d359 1
a359 1

d375 1
a375 1
    Tcl_SetResult(interp, Tk_PathName(canvasPtr->tkwin), TCL_STATIC);
d407 1
a407 1
    Tcl_Obj *CONST argv[];		/* Argument objects. */
d410 1
a410 1
    unsigned int length;
a413 1
#ifdef USE_OLD_TAG_SEARCH
a414 27
#else /* USE_OLD_TAG_SEARCH */
    TagSearch *searchPtr = NULL;	/* Allocated by first TagSearchScan
					 * Freed by TagSearchDestroy */
#endif /* USE_OLD_TAG_SEARCH */

    int index;
    static char *optionStrings[] = {
	"addtag",	"bbox",		"bind",		"canvasx",
	"canvasy",	"cget",		"configure",	"coords",
	"create",	"dchars",	"delete",	"dtag",
	"find",		"focus",	"gettags",	"icursor",
	"index",	"insert",	"itemcget",	"itemconfigure",
	"lower",	"move",		"postscript",	"raise",
	"scale",	"scan",		"select",	"type",
	"xview",	"yview",
	NULL
    };
    enum options {
	CANV_ADDTAG,	CANV_BBOX,	CANV_BIND,	CANV_CANVASX,
	CANV_CANVASY,	CANV_CGET,	CANV_CONFIGURE,	CANV_COORDS,
	CANV_CREATE,	CANV_DCHARS,	CANV_DELETE,	CANV_DTAG,
	CANV_FIND,	CANV_FOCUS,	CANV_GETTAGS,	CANV_ICURSOR,
	CANV_INDEX,	CANV_INSERT,	CANV_ITEMCGET,	CANV_ITEMCONFIGURE,
	CANV_LOWER,	CANV_MOVE,	CANV_POSTSCRIPT,CANV_RAISE,
	CANV_SCALE,	CANV_SCAN,	CANV_SELECT,	CANV_TYPE,
	CANV_XVIEW,	CANV_YVIEW
    };
d417 2
a418 5
	Tcl_WrongNumArgs(interp, 1, argv, "option ?arg arg ...?");
	return TCL_ERROR;
    }
    if (Tcl_GetIndexFromObj(interp, argv[1], optionStrings, "option", 0,
	    &index) != TCL_OK) {
a421 1

d423 3
a425 2
    switch ((enum options) index) {
      case CANV_ADDTAG: {
d427 9
a435 13
	    Tcl_WrongNumArgs(interp, 2, argv, "tag searchCommand ?arg arg ...?");
	    result = TCL_ERROR;
	    goto done;
	}
#ifdef USE_OLD_TAG_SEARCH
	result = FindItems(interp, canvasPtr, argc, argv, argv[2], 3);
#else /* USE_OLD_TAG_SEARCH */
	result = FindItems(interp, canvasPtr, argc, argv, argv[2], 3, &searchPtr);
#endif /* USE_OLD_TAG_SEARCH */
	break;
      }

      case CANV_BBOX: {
d442 4
a445 3
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId ?tagOrId ...?");
	    result = TCL_ERROR;
	    goto done;
a448 1
#ifdef USE_OLD_TAG_SEARCH
a450 8
#else /* USE_OLD_TAG_SEARCH */
	    if ((result = TagSearchScan(canvasPtr, argv[i], &searchPtr)) != TCL_OK) {
		goto done;
	    }
	    for (itemPtr = TagSearchFirst(searchPtr);
		    itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */

d478 4
a481 8
	    char buf[TCL_INTEGER_SPACE * 4];
	    
	    sprintf(buf, "%d %d %d %d", x1, y1, x2, y2);
	    Tcl_SetResult(interp, buf, TCL_VOLATILE);
	}
	break;
      }
      case CANV_BIND: {
d485 4
a488 3
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId ?sequence? ?command?");
	    result = TCL_ERROR;
	    goto done;
d497 1
a497 2
#ifdef USE_OLD_TAG_SEARCH
	if (isdigit(UCHAR(Tcl_GetString(argv[2])[0]))) {
d502 1
a502 1
	    id = strtoul(Tcl_GetString(argv[2]), &end, 0);
d513 1
a513 1
		Tcl_AppendResult(interp, "item \"", Tcl_GetString(argv[2]),
d515 1
a515 2
		result = TCL_ERROR;
		goto done;
d519 1
a519 23
	    object = (ClientData) Tk_GetUid(Tcl_GetString(argv[2]));
	}
#else /* USE_OLD_TAG_SEARCH */
	if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
	    goto done;
	}
	if (searchPtr->type == 1) {
	    Tcl_HashEntry *entryPtr;

	    entryPtr = Tcl_FindHashEntry(&canvasPtr->idTable, (char *) searchPtr->id);
	    if (entryPtr != NULL) {
		itemPtr = (Tk_Item *) Tcl_GetHashValue(entryPtr);
		object = (ClientData) itemPtr;
	    }

	    if (object == 0) {
		Tcl_AppendResult(interp, "item \"", Tcl_GetString(argv[2]),
			"\" doesn't exist", (char *) NULL);
		result = TCL_ERROR;
		goto done;
	    }
	} else {
    	    object = (ClientData) searchPtr->expr->uid;
a520 1
#endif /* USE_OLD_TAG_SEARCH */
a533 1
	    char* argv4 = Tcl_GetStringFromObj(argv[4],NULL);
d535 1
a535 1
	    if (argv4[0] == 0) {
d537 1
a537 1
			object, Tcl_GetStringFromObj(argv[3], NULL));
d540 2
a541 31
#ifndef USE_OLD_TAG_SEARCH
	    if (searchPtr->type == 4) {
	        /*
	         * if new tag expression, then insert in linked list
	         */
	    	TagSearchExpr *expr, **lastPtr;

		lastPtr = &(canvasPtr->bindTagExprs);
		while ((expr = *lastPtr) != NULL) {
		    if (expr->uid == searchPtr->expr->uid) {
			break;
		    }
		    lastPtr = &(expr->next);
		}
		if (!expr) {
		    /*
		     * transfer ownership of expr to bindTagExprs list
		     */
		    *lastPtr = searchPtr->expr;
		    searchPtr->expr->next = NULL;

		    /*
		     * flag in TagSearch that expr has changed ownership
		     * so that TagSearchDestroy doesn't try to free it
		     */
		    searchPtr->expr = NULL;
		}
            }
#endif /* not USE_OLD_TAG_SEARCH */
	    if (argv4[0] == '+') {
		argv4++;
d545 1
a545 1
		    object, Tcl_GetStringFromObj(argv[3],NULL), argv4, append);
d547 1
a547 2
		result = TCL_ERROR;
		goto done;
d555 1
a555 1
			object, Tcl_GetStringFromObj(argv[3], NULL));
d560 1
a560 2
		result = TCL_ERROR;
		goto done;
d566 1
a566 1
		    object, Tcl_GetStringFromObj(argv[3], NULL));
d568 1
a568 17
		char *string;

		string = Tcl_GetStringResult(interp); 
		/*
		 * Ignore missing binding errors.  This is a special hack
		 * that relies on the error message returned by FindSequence
		 * in tkBind.c.
		 */

		if (string[0] != '\0') {
		    result = TCL_ERROR;
		    goto done;
		} else {
		    Tcl_ResetResult(interp);
		}
	    } else {
		Tcl_SetResult(interp, command, TCL_STATIC);
d570 1
d574 1
a574 3
	break;
      }
      case CANV_CANVASX: {
a576 1
	char buf[TCL_DOUBLE_SPACE];
d579 4
a582 3
	    Tcl_WrongNumArgs(interp, 2, argv, "screenx ?gridspacing?");
	    result = TCL_ERROR;
	    goto done;
d584 2
a585 3
	if (Tk_GetPixelsFromObj(interp, canvasPtr->tkwin, argv[2], &x) != TCL_OK) {
	    result = TCL_ERROR;
	    goto done;
d588 1
a588 1
	    if (Tk_CanvasGetCoordFromObj(interp, (Tk_Canvas) canvasPtr, argv[3],
d590 1
a590 2
		result = TCL_ERROR;
		goto done;
d596 2
a597 5
	Tcl_PrintDouble(interp, GridAlign((double) x, grid), buf);
	Tcl_SetResult(interp, buf, TCL_VOLATILE);
	break;
      }
      case CANV_CANVASY: {
a599 1
	char buf[TCL_DOUBLE_SPACE];
d602 4
a605 3
	    Tcl_WrongNumArgs(interp, 2, argv, "screeny ?gridspacing?");
	    result = TCL_ERROR;
	    goto done;
d607 2
a608 3
	if (Tk_GetPixelsFromObj(interp, canvasPtr->tkwin, argv[2], &y) != TCL_OK) {
	    result = TCL_ERROR;
	    goto done;
d611 1
a611 1
	    if (Tk_CanvasGetCoordFromObj(interp, (Tk_Canvas) canvasPtr,
d613 1
a613 2
		result = TCL_ERROR;
		goto done;
d619 3
a621 5
	Tcl_PrintDouble(interp, GridAlign((double) y, grid), buf);
	Tcl_SetResult(interp, buf, TCL_VOLATILE);
	break;
      }
      case CANV_CGET: {
d623 4
a626 3
	    Tcl_WrongNumArgs(interp, 2, argv, "option");
	    result = TCL_ERROR;
	    goto done;
d629 3
a631 4
		(char *) canvasPtr, Tcl_GetString(argv[2]), 0);
	break;
      }
      case CANV_CONFIGURE: {
d637 1
a637 1
		    (char *) canvasPtr, Tcl_GetString(argv[2]), 0);
d642 2
a643 3
	break;
      }
      case CANV_COORDS: {
d645 4
a648 3
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId ?x y x y ...?");
	    result = TCL_ERROR;
	    goto done;
a649 1
#ifdef USE_OLD_TAG_SEARCH
a650 6
#else /* USE_OLD_TAG_SEARCH */
	if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
	    goto done;
	}
	itemPtr = TagSearchFirst(searchPtr);
#endif /* USE_OLD_TAG_SEARCH */
d653 2
a654 1
		EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
a656 1
	      if (itemPtr->typePtr->alwaysRedraw & TK_CONFIG_OBJS) {
a658 6
	      } else {
		char **args = GetStringsFromObjs(argc-3, argv+3);
		result = (*itemPtr->typePtr->coordProc)(interp,
			(Tk_Canvas) canvasPtr, itemPtr, argc-3, (Tcl_Obj **) args);
		if (args) ckfree((char *) args);
	      }
d661 2
a662 1
		EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
d665 2
a666 3
	break;
      }
      case CANV_CREATE: {
a669 1
	char buf[TCL_INTEGER_SPACE];
d672 1
a672 2
	char *arg;

d674 3
a676 3
	    Tcl_WrongNumArgs(interp, 2, argv, "type ?arg arg ...?");
	    result = TCL_ERROR;
	    goto done;
d678 2
a679 2
	arg = Tcl_GetStringFromObj(argv[2], (int *) &length);
	c = arg[0];
d682 1
a682 1
		    && (strncmp(arg, typePtr->name, length) == 0)) {
d687 2
a688 3
			    arg, "\"", (char *) NULL);
		    result = TCL_ERROR;
		    goto done;
d704 2
a705 12
	itemPtr->state = TK_STATE_NULL;
	itemPtr->redraw_flags = 0;
	if (itemPtr->typePtr->alwaysRedraw & TK_CONFIG_OBJS) {
	  result = (*typePtr->createProc)(interp, (Tk_Canvas) canvasPtr,
		itemPtr, argc-3, argv+3);
	} else {
	  char **args = GetStringsFromObjs(argc-3, argv+3);
	  result = (*typePtr->createProc)(interp, (Tk_Canvas) canvasPtr,
		itemPtr, argc-3, (Tcl_Obj **) args);
	  if (args) ckfree((char *) args);
	}
	if (result != TCL_OK) {
d707 1
a707 2
	    result = TCL_ERROR;
	    goto done;
d722 2
a723 2
	itemPtr->redraw_flags |= FORCE_REDRAW;
	EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
d725 3
a727 5
	sprintf(buf, "%d", itemPtr->id);
	Tcl_SetResult(interp, buf, TCL_VOLATILE);
	break;
      }
      case CANV_DCHARS: {
a728 1
	int x1,x2,y1,y2;
d731 4
a734 3
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId first ?last?");
	    result = TCL_ERROR;
	    goto done;
a735 1
#ifdef USE_OLD_TAG_SEARCH
a737 7
#else /* USE_OLD_TAG_SEARCH */
	if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
	    goto done;
	}
	for (itemPtr = TagSearchFirst(searchPtr);
		itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
d742 3
a744 9
	    if (itemPtr->typePtr->alwaysRedraw & TK_CONFIG_OBJS) {
		result = itemPtr->typePtr->indexProc(interp, (Tk_Canvas) canvasPtr,
			itemPtr, (char *) argv[3], &first);
	    } else {
		result = itemPtr->typePtr->indexProc(interp, (Tk_Canvas) canvasPtr,
			itemPtr, Tcl_GetStringFromObj(argv[3], NULL), &first);
	    }
	    if (result != TCL_OK) {
		goto done;
d747 4
a750 9
		if (itemPtr->typePtr->alwaysRedraw & TK_CONFIG_OBJS) {
		    result = itemPtr->typePtr->indexProc(interp, (Tk_Canvas) canvasPtr,
			    itemPtr, (char *) argv[4], &last);
		} else {
		    result = itemPtr->typePtr->indexProc(interp, (Tk_Canvas) canvasPtr,
			    itemPtr, Tcl_GetStringFromObj(argv[4], NULL), &last);
		}
		if (result != TCL_OK) {
		    goto done;
d759 1
a759 2
	     * the old area. Except if the insertProc sets the
	     * TK_ITEM_DONT_REDRAW flag, nothing more needs to be done.
d762 2
a763 3
	    x1 = itemPtr->x1; y1 = itemPtr->y1;
	    x2 = itemPtr->x2; y2 = itemPtr->y2;
	    itemPtr->redraw_flags &= ~TK_ITEM_DONT_REDRAW;
d766 2
a767 6
	    if (!(itemPtr->redraw_flags & TK_ITEM_DONT_REDRAW)) {
		Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
			x1, y1, x2, y2);
		EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
	    }
	    itemPtr->redraw_flags &= ~TK_ITEM_DONT_REDRAW;
d769 2
a770 3
	break;
      }
      case CANV_DELETE: {
a774 1
#ifdef USE_OLD_TAG_SEARCH
d777 2
a778 8
#else /* USE_OLD_TAG_SEARCH */
	    if ((result = TagSearchScan(canvasPtr, argv[i], &searchPtr)) != TCL_OK) {
		goto done;
	    }
	    for (itemPtr = TagSearchFirst(searchPtr);
		itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
		EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
d827 2
a828 3
	break;
      }
      case CANV_DTAG: {
d833 4
a836 3
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId ?tagToDelete?");
	    result = TCL_ERROR;
	    goto done;
d839 1
a839 1
	    tag = Tk_GetUid(Tcl_GetStringFromObj(argv[3], NULL));
d841 1
a841 1
	    tag = Tk_GetUid(Tcl_GetStringFromObj(argv[2], NULL));
a842 1
#ifdef USE_OLD_TAG_SEARCH
a844 7
#else /* USE_OLD_TAG_SEARCH */
        if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
            goto done;
        }
        for (itemPtr = TagSearchFirst(searchPtr);
                itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
d852 2
a853 3
	break;
      }
      case CANV_FIND: {
d855 9
a863 13
	    Tcl_WrongNumArgs(interp, 2, argv, "searchCommand ?arg arg ...?");
	    result = TCL_ERROR;
	    goto done;
	}
#ifdef USE_OLD_TAG_SEARCH
	result = FindItems(interp, canvasPtr, argc, argv, (Tcl_Obj *) NULL, 2);
#else /* USE_OLD_TAG_SEARCH */
	result = FindItems(interp, canvasPtr, argc, argv,
	    (Tcl_Obj *) NULL, 2, &searchPtr);
#endif /* USE_OLD_TAG_SEARCH */
	break;
      }
      case CANV_FOCUS: {
d865 4
a868 3
	    Tcl_WrongNumArgs(interp, 2, argv, "?tagOrId?");
	    result = TCL_ERROR;
	    goto done;
d873 1
a873 4
		char buf[TCL_INTEGER_SPACE];
		
		sprintf(buf, "%d", itemPtr->id);
		Tcl_SetResult(interp, buf, TCL_VOLATILE);
d878 2
a879 1
	    EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
d881 1
a881 1
	if (Tcl_GetStringFromObj(argv[2], NULL)[0] == 0) {
a884 1
#ifdef USE_OLD_TAG_SEARCH
a886 7
#else /* USE_OLD_TAG_SEARCH */
        if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
            goto done;
        }
        for (itemPtr = TagSearchFirst(searchPtr);
                itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
d896 2
a897 1
	    EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
d899 1
a899 3
	break;
      }
      case CANV_GETTAGS: {
d901 3
a903 3
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId");
	    result = TCL_ERROR;
	    goto done;
a904 1
#ifdef USE_OLD_TAG_SEARCH
a905 6
#else /* USE_OLD_TAG_SEARCH */
        if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
            goto done;
        }
        itemPtr = TagSearchFirst(searchPtr);
#endif /* USE_OLD_TAG_SEARCH */
d912 2
a913 3
	break;
      }
      case CANV_ICURSOR: {
d917 4
a920 3
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId index");
	    result = TCL_ERROR;
	    goto done;
a921 1
#ifdef USE_OLD_TAG_SEARCH
a923 7
#else /* USE_OLD_TAG_SEARCH */
        if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
            goto done;
        }
        for (itemPtr = TagSearchFirst(searchPtr);
                itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
d928 3
a930 9
	    if (itemPtr->typePtr->alwaysRedraw & TK_CONFIG_OBJS) {
		result = itemPtr->typePtr->indexProc(interp, (Tk_Canvas) canvasPtr,
			itemPtr, (char *) argv[3], &index);
	    } else {
		result = itemPtr->typePtr->indexProc(interp, (Tk_Canvas) canvasPtr,
			itemPtr, Tcl_GetStringFromObj(argv[3], NULL), &index);
	    }
	    if (result != TCL_OK) {
		goto done;
d936 2
a937 1
		EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
d940 2
a941 4
	break;
      }
      case CANV_INDEX: {

a942 1
	char buf[TCL_INTEGER_SPACE];
d945 4
a948 3
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId string");
	    result = TCL_ERROR;
	    goto done;
a949 1
#ifdef USE_OLD_TAG_SEARCH
a951 7
#else /* USE_OLD_TAG_SEARCH */
        if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
            goto done;
        }
        for (itemPtr = TagSearchFirst(searchPtr);
                itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
d958 2
a959 10
		    Tcl_GetStringFromObj(argv[2], NULL), "\"", (char *) NULL);
	    result = TCL_ERROR;
	    goto done;
	}
	if (itemPtr->typePtr->alwaysRedraw & TK_CONFIG_OBJS) {
	    result = itemPtr->typePtr->indexProc(interp, (Tk_Canvas) canvasPtr,
		    itemPtr, (char *) argv[3], &index);
	} else {
	    result = itemPtr->typePtr->indexProc(interp, (Tk_Canvas) canvasPtr,
		    itemPtr, Tcl_GetStringFromObj(argv[3], NULL), &index);
d961 7
a967 8
	if (result != TCL_OK) {
	    goto done;
	}
	sprintf(buf, "%d", index);
	Tcl_SetResult(interp, buf, TCL_VOLATILE);
	break;
      }
      case CANV_INSERT: {
a968 1
	int x1,x2,y1,y2;
d971 4
a974 3
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId beforeThis string");
	    result = TCL_ERROR;
	    goto done;
a975 1
#ifdef USE_OLD_TAG_SEARCH
a977 7
#else /* USE_OLD_TAG_SEARCH */
        if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
            goto done;
        }
        for (itemPtr = TagSearchFirst(searchPtr);
                itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
d982 3
a984 9
	    if (itemPtr->typePtr->alwaysRedraw & TK_CONFIG_OBJS) {
		result = itemPtr->typePtr->indexProc(interp, (Tk_Canvas) canvasPtr,
			itemPtr, (char *) argv[3], &beforeThis);
	    } else {
		result = itemPtr->typePtr->indexProc(interp, (Tk_Canvas) canvasPtr,
			itemPtr, Tcl_GetStringFromObj(argv[3], NULL), &beforeThis);
	    }
	    if (result != TCL_OK) {
		goto done;
d990 1
a990 3
	     * larger or smaller than the old area. Except if the
	     * insertProc sets the TK_ITEM_DONT_REDRAW flag, nothing
	     * more needs to be done.
d993 6
a998 16
	    x1 = itemPtr->x1; y1 = itemPtr->y1;
	    x2 = itemPtr->x2; y2 = itemPtr->y2;
	    itemPtr->redraw_flags &= ~TK_ITEM_DONT_REDRAW;
	    if (itemPtr->typePtr->alwaysRedraw & TK_CONFIG_OBJS) {
		(*itemPtr->typePtr->insertProc)((Tk_Canvas) canvasPtr,
			itemPtr, beforeThis, (char *) argv[4]);
	    } else {
		(*itemPtr->typePtr->insertProc)((Tk_Canvas) canvasPtr,
			itemPtr, beforeThis, Tcl_GetStringFromObj(argv[4], NULL));
	    }
	    if (!(itemPtr->redraw_flags & TK_ITEM_DONT_REDRAW)) {
		Tk_CanvasEventuallyRedraw((Tk_Canvas) canvasPtr,
			x1, y1, x2, y2);
		EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
	    }
	    itemPtr->redraw_flags &= ~TK_ITEM_DONT_REDRAW;
d1000 2
a1001 3
	break;
      }
      case CANV_ITEMCGET: {
d1003 3
a1005 1
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId option");
a1007 1
#ifdef USE_OLD_TAG_SEARCH
a1008 6
#else /* USE_OLD_TAG_SEARCH */
        if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
            goto done;
        }
        itemPtr = TagSearchFirst(searchPtr);
#endif /* USE_OLD_TAG_SEARCH */
d1012 1
a1012 1
		    Tcl_GetStringFromObj(argv[3], NULL), 0);
d1014 2
a1015 3
	break;
      }
      case CANV_ITEMCONFIGURE: {
d1017 4
a1020 3
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId ?option value ...?");
	    result = TCL_ERROR;
	    goto done;
a1021 1
#ifdef USE_OLD_TAG_SEARCH
a1023 7
#else /* USE_OLD_TAG_SEARCH */
        if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
            goto done;
        }
        for (itemPtr = TagSearchFirst(searchPtr);
                itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
d1031 1
a1031 1
			Tcl_GetString(argv[3]), 0);
d1033 2
a1034 2
		EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
		if (itemPtr->typePtr->alwaysRedraw & TK_CONFIG_OBJS) {
d1038 2
a1039 8
		} else {
		char **args = GetStringsFromObjs(argc-3, argv+3);
		result = (*itemPtr->typePtr->configProc)(interp,
			(Tk_Canvas) canvasPtr, itemPtr, argc-3, (Tcl_Obj **) args,
			TK_CONFIG_ARGV_ONLY);
		if (args) ckfree((char *) args);
		}
		EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
d1046 1
a1046 3
	break;
      }
      case CANV_LOWER: {
d1050 4
a1053 3
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId ?belowThis?");
	    result = TCL_ERROR;
	    goto done;
a1063 1
#ifdef USE_OLD_TAG_SEARCH
a1064 6
#else /* USE_OLD_TAG_SEARCH */
            if ((result = TagSearchScan(canvasPtr, argv[3], &searchPtr)) != TCL_OK) {
                goto done;
            }
            itemPtr = TagSearchFirst(searchPtr);
#endif /* USE_OLD_TAG_SEARCH */
d1066 1
a1066 1
		Tcl_AppendResult(interp, "tag \"", Tcl_GetString(argv[3]),
d1068 1
a1068 1
		goto done;
a1071 1
#ifdef USE_OLD_TAG_SEARCH
d1073 1
a1073 8
#else /* USE_OLD_TAG_SEARCH */
        if ((result = RelinkItems(canvasPtr, argv[2], itemPtr, &searchPtr)) != TCL_OK) {
            goto done;
        }
#endif /* USE_OLD_TAG_SEARCH */
	break;
      }
      case CANV_MOVE: {
d1077 4
a1080 3
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId xAmount yAmount");
	    result = TCL_ERROR;
	    goto done;
d1082 2
a1083 2
	if ((Tk_CanvasGetCoordFromObj(interp, (Tk_Canvas) canvasPtr, argv[3],
		&xAmount) != TCL_OK) || (Tk_CanvasGetCoordFromObj(interp,
d1085 1
a1085 2
	    result = TCL_ERROR;
	    goto done;
a1086 1
#ifdef USE_OLD_TAG_SEARCH
d1089 2
a1090 8
#else /* USE_OLD_TAG_SEARCH */
        if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
            goto done;
        }
        for (itemPtr = TagSearchFirst(searchPtr);
                itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
	    EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
d1093 2
a1094 1
	    EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
d1097 3
a1099 9
	break;
      }
      case CANV_POSTSCRIPT: {
	char **args = GetStringsFromObjs(argc, argv);
	result = TkCanvPostscriptCmd(canvasPtr, interp, argc, args);
	if (args) ckfree((char *) args);
	break;
      }
      case CANV_RAISE: {
d1103 4
a1106 3
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId ?aboveThis?");
	    result = TCL_ERROR;
	    goto done;
a1117 1
#ifdef USE_OLD_TAG_SEARCH
a1119 7
#else /* USE_OLD_TAG_SEARCH */
            if ((result = TagSearchScan(canvasPtr, argv[3], &searchPtr)) != TCL_OK) {
                goto done;
            }
            for (itemPtr = TagSearchFirst(searchPtr);
                    itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
d1123 1
a1123 1
		Tcl_AppendResult(interp, "tagOrId \"", Tcl_GetStringFromObj(argv[3], NULL),
d1125 1
a1125 2
		result = TCL_ERROR;
		goto done;
a1127 1
#ifdef USE_OLD_TAG_SEARCH
d1129 2
a1130 9
#else /* USE_OLD_TAG_SEARCH */
        result = RelinkItems(canvasPtr, argv[2], prevPtr, &searchPtr);
        if (result != TCL_OK) {
            goto done;
        }
#endif /* USE_OLD_TAG_SEARCH */
	break;
      }
      case CANV_SCALE: {
d1134 4
a1137 3
	    Tcl_WrongNumArgs(interp, 2, argv, "tagOrId xOrigin yOrigin xScale yScale");
	    result = TCL_ERROR;
	    goto done;
d1139 1
a1139 1
	if ((Tk_CanvasGetCoordFromObj(interp, (Tk_Canvas) canvasPtr,
d1141 1
a1141 1
		|| (Tk_CanvasGetCoordFromObj(interp, (Tk_Canvas) canvasPtr,
d1143 3
a1145 4
		|| (Tcl_GetDoubleFromObj(interp, argv[5], &xScale) != TCL_OK)
		|| (Tcl_GetDoubleFromObj(interp, argv[6], &yScale) != TCL_OK)) {
	    result = TCL_ERROR;
	    goto done;
d1148 2
a1149 3
	    Tcl_SetResult(interp, "scale factor cannot be zero", TCL_STATIC);
	    result = TCL_ERROR;
	    goto done;
a1150 1
#ifdef USE_OLD_TAG_SEARCH
d1153 2
a1154 8
#else /* USE_OLD_TAG_SEARCH */
        if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
            goto done;
        }
        for (itemPtr = TagSearchFirst(searchPtr);
                itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
	    EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
d1157 2
a1158 1
	    EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
d1161 3
a1163 7
	break;
      }
      case CANV_SCAN: {
	int x, y, gain=10;
	static char *optionStrings[] = {
	    "mark", "dragto", NULL
	};
d1165 8
a1172 18
	if (Tcl_GetIndexFromObj(interp, argv[2], optionStrings, "scan option", 0,
		&index) != TCL_OK) {
	    return TCL_ERROR;
	}

	if ((argc != 5) && (argc != 5+index)) {
	    Tcl_WrongNumArgs(interp, 3, argv, index?"x y ?gain?":"x y");
	    result = TCL_ERROR;
	    goto done;
	}
	if ((Tcl_GetIntFromObj(interp, argv[3], &x) != TCL_OK)
		|| (Tcl_GetIntFromObj(interp, argv[4], &y) != TCL_OK)){
	    result = TCL_ERROR;
	    goto done;
	}
	if ((argc == 6) && (Tcl_GetIntFromObj(interp, argv[5], &gain) != TCL_OK)) {
	    result = TCL_ERROR;
            goto done;
d1174 2
a1175 1
	if (!index) {
d1180 2
a1181 1
	} else {
d1189 1
a1189 1
	    tmp = canvasPtr->scanXOrigin - gain*(x - canvasPtr->scanX)
d1192 1
a1192 1
	    tmp = canvasPtr->scanYOrigin - gain*(y - canvasPtr->scanY)
d1196 4
d1201 3
a1203 10
	break;
      }
      case CANV_SELECT: {
	int index, optionindex;
	static char *optionStrings[] = {
	    "adjust", "clear", "from", "item", "to", NULL
	};
	enum options {
	    CANV_ADJUST, CANV_CLEAR, CANV_FROM, CANV_ITEM, CANV_TO
	};
d1206 3
a1208 3
	    Tcl_WrongNumArgs(interp, 2, argv, "option ?tagOrId? ?arg?");
	    result = TCL_ERROR;
	    goto done;
a1210 1
#ifdef USE_OLD_TAG_SEARCH
a1212 7
#else /* USE_OLD_TAG_SEARCH */
            if ((result = TagSearchScan(canvasPtr, argv[3], &searchPtr)) != TCL_OK) {
                goto done;
            }
            for (itemPtr = TagSearchFirst(searchPtr);
                    itemPtr != NULL; itemPtr = TagSearchNext(searchPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
d1221 2
a1222 3
			Tcl_GetStringFromObj(argv[3], NULL), "\"", (char *) NULL);
		result = TCL_ERROR;
		goto done;
d1226 3
a1228 9
	    if (itemPtr->typePtr->alwaysRedraw & TK_CONFIG_OBJS) {
		result = itemPtr->typePtr->indexProc(interp, (Tk_Canvas) canvasPtr,
			itemPtr, (char *) argv[4], &index);
	    } else {
		result = itemPtr->typePtr->indexProc(interp, (Tk_Canvas) canvasPtr,
			itemPtr, Tcl_GetStringFromObj(argv[4], NULL), &index);
	    }
	    if (result != TCL_OK) {
		goto done;
d1231 3
a1233 6
	if (Tcl_GetIndexFromObj(interp, argv[2], optionStrings, "select option", 0,
		&optionindex) != TCL_OK) {
	    return TCL_ERROR;
	}
	switch ((enum options) optionindex) {
	  case CANV_ADJUST: {
d1235 4
a1238 3
		Tcl_WrongNumArgs(interp, 3, argv, "tagOrId index");
		result = TCL_ERROR;
		goto done;
d1251 2
a1252 3
	    break;
	  }
	  case CANV_CLEAR: {
d1254 3
a1256 3
		Tcl_AppendResult(interp, 3, argv, (char *) NULL);
		result = TCL_ERROR;
		goto done;
d1259 5
a1263 2
		EventuallyRedrawItem((Tk_Canvas) canvasPtr,
			canvasPtr->textInfo.selItemPtr);
d1267 1
a1267 3
	    break;
	  }
	  case CANV_FROM: {
d1269 4
a1272 3
		Tcl_WrongNumArgs(interp, 3, argv, "tagOrId index");
		result = TCL_ERROR;
		goto done;
d1276 1
a1276 3
	    break;
	  }
	  case CANV_ITEM: {
d1278 3
a1280 3
		Tcl_WrongNumArgs(interp, 3, argv, (char *) NULL);
		result = TCL_ERROR;
		goto done;
d1283 2
a1284 4
		char buf[TCL_INTEGER_SPACE];
		
		sprintf(buf, "%d", canvasPtr->textInfo.selItemPtr->id);
		Tcl_SetResult(interp, buf, TCL_VOLATILE);
d1286 1
a1286 3
	    break;
	  }
	  case CANV_TO: {
d1288 4
a1291 3
		Tcl_WrongNumArgs(interp, 2, argv, "tagOrId index");
		result = TCL_ERROR;
		goto done;
d1294 5
a1298 2
	    break;
	  }
d1300 1
a1300 3
	break;
      }
      case CANV_TYPE: {
d1302 3
a1304 3
	    Tcl_WrongNumArgs(interp, 2, argv, "tag");
	    result = TCL_ERROR;
	    goto done;
a1305 1
#ifdef USE_OLD_TAG_SEARCH
a1306 6
#else /* USE_OLD_TAG_SEARCH */
        if ((result = TagSearchScan(canvasPtr, argv[2], &searchPtr)) != TCL_OK) {
            goto done;
        }
        itemPtr = TagSearchFirst(searchPtr);
#endif /* USE_OLD_TAG_SEARCH */
d1308 1
a1308 1
	    Tcl_SetResult(interp, itemPtr->typePtr->name, TCL_STATIC);
d1310 1
a1310 3
	break;
      }
      case CANV_XVIEW: {
d1320 1
a1320 1
		    canvasPtr->scrollX2, Tcl_GetStringResult(interp));
d1322 1
a1322 3
	    char **args = GetStringsFromObjs(argc, argv);
	    type = Tk_GetScrollInfo(interp, argc, args, &fraction, &count);
	    if (args) ckfree((char *) args);
d1325 1
a1325 2
		    result = TCL_ERROR;
		    goto done;
d1348 1
a1348 3
	break;
      }
      case CANV_YVIEW: {
d1358 1
a1358 1
		    canvasPtr->scrollY2, Tcl_GetStringResult(interp));
d1360 1
a1360 3
	    char **args = GetStringsFromObjs(argc, argv);
	    type = Tk_GetScrollInfo(interp, argc, args, &fraction, &count);
	    if (args) ckfree((char *) args);
d1363 1
a1363 2
		    result = TCL_ERROR;
		    goto done;
d1387 10
a1396 2
	break;
      }
a1398 3
#ifndef USE_OLD_TAG_SEARCH
    TagSearchDestroy(searchPtr);
#endif /* not USE_OLD_TAG_SEARCH */
d1401 4
a1431 7
    if (canvasPtr->tkwin != NULL) {
	Tcl_DeleteCommandFromToken(canvasPtr->interp, canvasPtr->widgetCmd);
    }
    if (canvasPtr->flags & REDRAW_PENDING) {
	Tcl_CancelIdleCall(DisplayCanvas, (ClientData) canvasPtr);
    }
	
a1456 12
#ifndef USE_OLD_TAG_SEARCH
    {
    	TagSearchExpr *expr, *next;

	expr = canvasPtr->bindTagExprs;
	while (expr) {
	    next = expr->next;
	    TagSearchExprDestroy(expr);
	    expr = next;
	}
    }
#endif
a1461 1
    canvasPtr->tkwin = NULL;
d1476 1
a1476 1
 *	returned, then the interp's result contains an error message.
d1492 1
a1492 1
    Tcl_Obj *CONST argv[];	/* Argument objects. */
d1499 1
a1499 1
	    argc, (char **) argv, (char *) canvasPtr, flags|TK_CONFIG_OBJS) != TCL_OK) {
d1517 1
d1519 3
a1521 3
    gcValues.foreground = Tk_3DBorderColor(canvasPtr->bgBorder)->pixel;
    new = Tk_GetGC(canvasPtr->tkwin,
	    GCFunction|GCGraphicsExposures|GCForeground, &gcValues);
a1580 16
    flags = canvasPtr->tsoffset.flags;
    if (flags & TK_OFFSET_LEFT) {
	canvasPtr->tsoffset.xoffset = 0;
    } else if (flags & TK_OFFSET_CENTER) {
	canvasPtr->tsoffset.xoffset = canvasPtr->width/2;
    } else if (flags & TK_OFFSET_RIGHT) {
	canvasPtr->tsoffset.xoffset = canvasPtr->width;
    }
    if (flags & TK_OFFSET_TOP) {
	canvasPtr->tsoffset.yoffset = 0;
    } else if (flags & TK_OFFSET_MIDDLE) {
	canvasPtr->tsoffset.yoffset = canvasPtr->height/2;
    } else if (flags & TK_OFFSET_BOTTOM) {
	canvasPtr->tsoffset.yoffset = canvasPtr->height;
    }

a1670 1

a1691 14
     * Scan through the item list, registering the bounding box
     * for all items that didn't do that for the final coordinates
     * yet. This can be determined by the FORCE_REDRAW flag.
     */

    for (itemPtr = canvasPtr->firstItemPtr; itemPtr != NULL;
		itemPtr = itemPtr->nextPtr) {
	if (itemPtr->redraw_flags & FORCE_REDRAW) {
	    itemPtr->redraw_flags &= ~FORCE_REDRAW;
	    EventuallyRedrawItem((Tk_Canvas)canvasPtr, itemPtr);
	    itemPtr->redraw_flags &= ~FORCE_REDRAW;
	}
    }
    /*
d1783 1
a1783 1
		if (!(itemPtr->typePtr->alwaysRedraw & 1)
a1790 5
	    if (itemPtr->state == TK_STATE_HIDDEN ||
		(itemPtr->state == TK_STATE_NULL &&
		 canvasPtr->canvas_state == TK_STATE_HIDDEN)) {
		continue;
	    }
d1827 2
a1828 4
	    GC fgGC, bgGC;

	    bgGC = Tk_GCForColor(canvasPtr->highlightBgColorPtr,
		    Tk_WindowId(tkwin));
d1830 1
a1830 1
		fgGC = Tk_GCForColor(canvasPtr->highlightColorPtr,
a1831 2
	    	TkpDrawHighlightBorder(tkwin, fgGC, bgGC,
			canvasPtr->highlightWidth, Tk_WindowId(tkwin));
d1833 2
a1834 2
	    	TkpDrawHighlightBorder(tkwin, bgGC, bgGC,
			canvasPtr->highlightWidth, Tk_WindowId(tkwin));
d1836 2
d1842 1
a1842 1
    canvasPtr->flags &= ~(REDRAW_PENDING|BBOX_NOT_EMPTY);
d1892 9
a1900 1
	DestroyCanvas((char *) canvasPtr);
d1934 1
a1934 1
	    if (itemPtr->typePtr->alwaysRedraw & 1) {
d2006 1
a2006 5
    /*
     * If tkwin is NULL, the canvas has been destroyed, so we can't really
     * redraw it.
     */
    if (canvasPtr->tkwin == NULL) {
d2009 1
a2009 8

    if ((x1 >= x2) || (y1 >= y2) ||
 	    (x2 < canvasPtr->xOrigin) || (y2 < canvasPtr->yOrigin) ||
	    (x1 >= canvasPtr->xOrigin + Tk_Width(canvasPtr->tkwin)) ||
	    (y1 >= canvasPtr->yOrigin + Tk_Height(canvasPtr->tkwin))) {
	return;
    }
    if (canvasPtr->flags & BBOX_NOT_EMPTY) {
a2026 3
	canvasPtr->flags |= BBOX_NOT_EMPTY;
    }
    if (!(canvasPtr->flags & REDRAW_PENDING)) {
d2035 1
a2035 1
 * EventuallyRedrawItem --
d2037 2
a2038 2
 *	Arrange for part or all of a canvas widget to redrawn at
 *	some convenient time in the future.
d2044 5
a2048 1
 *	The screen will eventually be refreshed.
d2053 5
a2057 4
static void
EventuallyRedrawItem(canvas, itemPtr)
    Tk_Canvas canvas;		/* Information about widget. */
    Tk_Item *itemPtr;		/* item to be redrawn. */
d2059 4
a2062 9
    TkCanvas *canvasPtr = (TkCanvas *) canvas;
    if ((itemPtr->x1 >= itemPtr->x2) || (itemPtr->y1 >= itemPtr->y2) ||
 	    (itemPtr->x2 < canvasPtr->xOrigin) ||
	    (itemPtr->y2 < canvasPtr->yOrigin) ||
	    (itemPtr->x1 >= canvasPtr->xOrigin + Tk_Width(canvasPtr->tkwin)) ||
	    (itemPtr->y1 >= canvasPtr->yOrigin + Tk_Height(canvasPtr->tkwin))) {
	if (!(itemPtr->typePtr->alwaysRedraw & 1)) {
	    return;
	}
d2064 2
a2065 63
    if (!(itemPtr->redraw_flags & FORCE_REDRAW)) {
	if (canvasPtr->flags & BBOX_NOT_EMPTY) {
	    if (itemPtr->x1 <= canvasPtr->redrawX1) {
		canvasPtr->redrawX1 = itemPtr->x1;
	    }
	    if (itemPtr->y1 <= canvasPtr->redrawY1) {
		canvasPtr->redrawY1 = itemPtr->y1;
	    }
	    if (itemPtr->x2 >= canvasPtr->redrawX2) {
		canvasPtr->redrawX2 = itemPtr->x2;
	    }
	    if (itemPtr->y2 >= canvasPtr->redrawY2) {
		canvasPtr->redrawY2 = itemPtr->y2;
	    }
	} else {
	    canvasPtr->redrawX1 = itemPtr->x1;
	    canvasPtr->redrawY1 = itemPtr->y1;
	    canvasPtr->redrawX2 = itemPtr->x2;
	    canvasPtr->redrawY2 = itemPtr->y2;
	    canvasPtr->flags |= BBOX_NOT_EMPTY;
	}
	itemPtr->redraw_flags |= FORCE_REDRAW;
    }
    if (!(canvasPtr->flags & REDRAW_PENDING)) {
	Tcl_DoWhenIdle(DisplayCanvas, (ClientData) canvasPtr);
	canvasPtr->flags |= REDRAW_PENDING;
    }
}

/*
 *--------------------------------------------------------------
 *
 * Tk_CreateItemType --
 *
 *	This procedure may be invoked to add a new kind of canvas
 *	element to the core item types supported by Tk.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	From now on, the new item type will be useable in canvas
 *	widgets (e.g. typePtr->name can be used as the item type
 *	in "create" widget commands).  If there was already a
 *	type with the same name as in typePtr, it is replaced with
 *	the new type.
 *
 *--------------------------------------------------------------
 */

void
Tk_CreateItemType(typePtr)
    Tk_ItemType *typePtr;		/* Information about item type;
					 * storage must be statically
					 * allocated (must live forever). */
{
    Tk_ItemType *typePtr2, *prevPtr;

    if (typeList == NULL) {
	InitCanvas();
    }

    /*
a2144 1
#ifndef USE_OLD_TAG_SEARCH
a2146 9
    andUid = Tk_GetUid("&&");
    orUid = Tk_GetUid("||");
    xorUid = Tk_GetUid("^");
    parenUid = Tk_GetUid("(");
    endparenUid = Tk_GetUid(")");
    negparenUid = Tk_GetUid("!(");
    tagvalUid = Tk_GetUid("!!");
    negtagvalUid = Tk_GetUid("!");
#endif /* USE_OLD_TAG_SEARCH */
a2148 1
#ifdef USE_OLD_TAG_SEARCH
d2175 1
a2175 1
StartTagSearch(canvasPtr, tagObj, searchPtr)
d2178 1
a2178 1
    Tcl_Obj *tagObj;			/* Object giving tag value. */
a2185 1
    char *tag = Tcl_GetString(tagObj);
a2186 5
    TkWindow *tkwin;
    TkDisplay *dispPtr;

    tkwin = (TkWindow *) canvasPtr->tkwin;
    dispPtr = tkwin->dispPtr;
d2205 2
a2206 2

	dispPtr->numIdSearches++;
d2210 1
a2210 1
            lastPtr = canvasPtr->hotPrevPtr;
d2213 1
a2213 1
		dispPtr->numSlowSearches++;
d2231 2
a2232 1
    if (uid == Tk_GetUid("all")) {
a2350 847
#else /* USE_OLD_TAG_SEARCH */
/*
 *--------------------------------------------------------------
 *
 * TagSearchExprInit --
 *
 *      This procedure allocates and initializes one TagSearchExpr struct.
 *
 * Results:
 *
 * Side effects:
 *
 *--------------------------------------------------------------
 */

static void
TagSearchExprInit(exprPtrPtr)
TagSearchExpr **exprPtrPtr;
{
    TagSearchExpr* expr = *exprPtrPtr;

    if (! expr) {
	expr = (TagSearchExpr *) ckalloc(sizeof(TagSearchExpr));
	expr->allocated = 0;
	expr->uids = NULL;
	expr->next = NULL;
    }
    expr->uid = NULL;
    expr->index = 0;
    expr->length = 0;
    *exprPtrPtr = expr;
}
 
/*
 *--------------------------------------------------------------
 *
 * TagSearchExprDestroy --
 *
 *      This procedure destroys one TagSearchExpr structure.
 *
 * Results:
 *
 * Side effects:
 *
 *--------------------------------------------------------------
     */

static void
TagSearchExprDestroy(expr)
    TagSearchExpr *expr;
{
    if (expr) {
    	if (expr->uids) {
        	ckfree((char *)expr->uids);
	}
        ckfree((char *)expr);
    }
}

/*
 *--------------------------------------------------------------
 *
 * TagSearchScan --
 *
 *      This procedure is called to initiate an enumeration of
 *      all items in a given canvas that contain a tag that matches
 *      the tagOrId expression.
 *
 * Results:
 *      The return value indicates if the tagOrId expression
 *      was successfully scanned (syntax).
 *      The information at *searchPtr is initialized
 *      such that a call to TagSearchFirst, followed by
 *      successive calls to TagSearchNext will return items
 *      that match tag.
 *
 * Side effects:
 *      SearchPtr is linked into a list of searches in progress
 *      on canvasPtr, so that elements can safely be deleted
 *      while the search is in progress.
 *
 *--------------------------------------------------------------
 */

static int
TagSearchScan(canvasPtr, tagObj, searchPtrPtr)
    TkCanvas *canvasPtr;                /* Canvas whose items are to be
                                         * searched. */
    Tcl_Obj *tagObj;                    /* Object giving tag value. */
    TagSearch **searchPtrPtr;           /* Record describing tag search;
                                         * will be initialized here. */
{
    char *tag = Tcl_GetStringFromObj(tagObj,NULL);
    int i;
    TagSearch *searchPtr;

    /*
     * Initialize the search.
     */

    if (*searchPtrPtr) {
        searchPtr = *searchPtrPtr;
    } else {
        /* Allocate primary search struct on first call */
        *searchPtrPtr = searchPtr = (TagSearch *) ckalloc(sizeof(TagSearch));
	searchPtr->expr = NULL;

        /* Allocate buffer for rewritten tags (after de-escaping) */
        searchPtr->rewritebufferAllocated = 100;
        searchPtr->rewritebuffer =
            ckalloc(searchPtr->rewritebufferAllocated);
    }
    TagSearchExprInit(&(searchPtr->expr));

    /* How long is the tagOrId ? */
    searchPtr->stringLength = strlen(tag);

    /* Make sure there is enough buffer to hold rewritten tags */
    if ((unsigned int)searchPtr->stringLength >=
	    searchPtr->rewritebufferAllocated) {
        searchPtr->rewritebufferAllocated = searchPtr->stringLength + 100;
        searchPtr->rewritebuffer =
            ckrealloc(searchPtr->rewritebuffer,
		    searchPtr->rewritebufferAllocated);
    }

    /* Initialize search */
    searchPtr->canvasPtr = canvasPtr;
    searchPtr->searchOver = 0;
    searchPtr->type = 0;

    /*
     * Find the first matching item in one of several ways. If the tag
     * is a number then it selects the single item with the matching
     * identifier.  In this case see if the item being requested is the
     * hot item, in which case the search can be skipped.
     */

    if (searchPtr->stringLength && isdigit(UCHAR(*tag))) {
        char *end;

        searchPtr->id = strtoul(tag, &end, 0);
        if (*end == 0) {
            searchPtr->type = 1;
            return TCL_OK;
	}
    }

    /*
     * For all other tags and tag expressions convert to a UID.
     * This UID is kept forever, but this should be thought of
     * as a cache rather than as a memory leak.
     */
    searchPtr->expr->uid = Tk_GetUid(tag);

    /* short circuit impossible searches for null tags */
    if (searchPtr->stringLength == 0) {
	return TCL_OK;
    }

    /*
     * Pre-scan tag for at least one unquoted "&&" "||" "^" "!"
     *   if not found then use string as simple tag
     */
    for (i = 0; i < searchPtr->stringLength ; i++) {
        if (tag[i] == '"') {
            i++;
            for ( ; i < searchPtr->stringLength; i++) {
                if (tag[i] == '\\') {
                    i++;
                    continue;
                }
                if (tag[i] == '"') {
                    break;
                }
            }
        } else {
            if ((tag[i] == '&' && tag[i+1] == '&')
             || (tag[i] == '|' && tag[i+1] == '|')
             || (tag[i] == '^')
             || (tag[i] == '!')) {
                searchPtr->type = 4;
                break;
            }
        }
    }

    searchPtr->string = tag;
    searchPtr->stringIndex = 0;
    if (searchPtr->type == 4) {
        /*
         * an operator was found in the prescan, so
         * now compile the tag expression into array of Tk_Uid
         * flagging any syntax errors found
         */
	if (TagSearchScanExpr(canvasPtr->interp, searchPtr, searchPtr->expr) != TCL_OK) {
            /* Syntax error in tag expression */
	    /* Result message set by TagSearchScanExpr */
	    return TCL_ERROR;
	}
	searchPtr->expr->length = searchPtr->expr->index;
    } else {
        if (searchPtr->expr->uid == allUid) {
            /*
             * All items match.
             */
            searchPtr->type = 2;
        } else {
            /*
             * Optimized single-tag search
             */
            searchPtr->type = 3;
        }
    }
    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * TagSearchDestroy --
 *
 *      This procedure destroys any dynamic structures that
 *      may have been allocated by TagSearchScan.
 *
 * Results:
 *
 * Side effects:
 *
 *--------------------------------------------------------------
 */

static void
TagSearchDestroy(searchPtr)
    TagSearch *searchPtr;               /* Record describing tag search */
{
    if (searchPtr) {
        TagSearchExprDestroy(searchPtr->expr);
        ckfree((char *)searchPtr->rewritebuffer);
        ckfree((char *)searchPtr);
    }
}

/*
 *--------------------------------------------------------------
 *
 * TagSearchScanExpr --
 *
 *      This recursive procedure is called to scan a tag expression
 *      and compile it into an array of Tk_Uids.
 *
 * Results:
 *      The return value indicates if the tagOrId expression
 *      was successfully scanned (syntax).
 *      The information at *searchPtr is initialized
 *      such that a call to TagSearchFirst, followed by
 *      successive calls to TagSearchNext will return items
 *      that match tag.
 *
 * Side effects:
 *
 *--------------------------------------------------------------
 */

static int
TagSearchScanExpr(interp, searchPtr, expr)
    Tcl_Interp *interp;         /* Current interpreter. */
    TagSearch *searchPtr;       /* Search data */
    TagSearchExpr *expr;	/* compiled expression result */
{
    int looking_for_tag;        /* When true, scanner expects
                                 * next char(s) to be a tag,
                                 * else operand expected */
    int found_tag;              /* One or more tags found */
    int found_endquote;         /* For quoted tag string parsing */
    int negate_result;          /* Pending negation of next tag value */
    char *tag;                  /* tag from tag expression string */
    char c;

    negate_result = 0;
    found_tag = 0;
    looking_for_tag = 1;
    while (searchPtr->stringIndex < searchPtr->stringLength) {
        c = searchPtr->string[searchPtr->stringIndex++];

        if (expr->allocated == expr->index) {
            expr->allocated += 15;
	    if (expr->uids) {
		expr->uids =
                    (Tk_Uid *) ckrealloc((char *)(expr->uids),
                    (expr->allocated)*sizeof(Tk_Uid));
	    } else {
		expr->uids =
		(Tk_Uid *) ckalloc((expr->allocated)*sizeof(Tk_Uid));
	    }
        }

        if (looking_for_tag) {

            switch (c) {
                case ' '  :	/* ignore unquoted whitespace */
                case '\t' :
                case '\n' :
                case '\r' :
                    break;

                case '!'  :	/* negate next tag or subexpr */
                    if (looking_for_tag > 1) {
                        Tcl_AppendResult(interp,
                            "Too many '!' in tag search expression",
                            (char *) NULL);
                        return TCL_ERROR;
                    }
                    looking_for_tag++;
                    negate_result = 1;
                    break;

                case '('  :	/* scan (negated) subexpr recursively */
                    if (negate_result) {
                        expr->uids[expr->index++] = negparenUid;
                        negate_result = 0;
		    } else {
                        expr->uids[expr->index++] = parenUid;
		    }
                    if (TagSearchScanExpr(interp, searchPtr, expr) != TCL_OK) {
                        /* Result string should be already set
                         * by nested call to tag_expr_scan() */
			return TCL_ERROR;
		    }
                    looking_for_tag = 0;
                    found_tag = 1;
                    break;

                case '"'  :	/* quoted tag string */
                    if (negate_result) {
                        expr->uids[expr->index++] = negtagvalUid;
                        negate_result = 0;
                    } else {
                        expr->uids[expr->index++] = tagvalUid;
		    }
                    tag = searchPtr->rewritebuffer;
                    found_endquote = 0;
                    while (searchPtr->stringIndex < searchPtr->stringLength) {
                        c = searchPtr->string[searchPtr->stringIndex++];
                        if (c == '\\') {
                            c = searchPtr->string[searchPtr->stringIndex++];
			}
                        if (c == '"') {
                            found_endquote = 1;
			    break;
			}
                        *tag++ = c;
                    }
                    if (! found_endquote) {
                        Tcl_AppendResult(interp,
				"Missing endquote in tag search expression",
				(char *) NULL);
                        return TCL_ERROR;
                    }
                    if (! (tag - searchPtr->rewritebuffer)) {
                        Tcl_AppendResult(interp,
                            "Null quoted tag string in tag search expression",
                            (char *) NULL);
                        return TCL_ERROR;
                    }
                    *tag++ = '\0';
                    expr->uids[expr->index++] =
                        Tk_GetUid(searchPtr->rewritebuffer);
                    looking_for_tag = 0;
                    found_tag = 1;
                    break;

                case '&'  :	/* illegal chars when looking for tag */
                case '|'  :
                case '^'  :
                case ')'  :
                    Tcl_AppendResult(interp,
			    "Unexpected operator in tag search expression",
			    (char *) NULL);
                    return TCL_ERROR;

                default :	/* unquoted tag string */
                    if (negate_result) {
                        expr->uids[expr->index++] = negtagvalUid;
                        negate_result = 0;
                    } else {
                        expr->uids[expr->index++] = tagvalUid;
                    }
                    tag = searchPtr->rewritebuffer;
                    *tag++ = c;
                    /* copy rest of tag, including any embedded whitespace */
                    while (searchPtr->stringIndex < searchPtr->stringLength) {
                        c = searchPtr->string[searchPtr->stringIndex];
                        if (c == '!' || c == '&' || c == '|' || c == '^'
				|| c == '(' || c == ')' || c == '"') {
			    break;
                        }
                        *tag++ = c;
                        searchPtr->stringIndex++;
                    }
                    /* remove trailing whitespace */
                    while (1) {
                        c = *--tag;
                        /* there must have been one non-whitespace char,
                         *  so this will terminate */
                        if (c != ' ' && c != '\t' && c != '\n' && c != '\r') {
                            break;
			}
                    }
                    *++tag = '\0';
                    expr->uids[expr->index++] =
                        Tk_GetUid(searchPtr->rewritebuffer);
                    looking_for_tag = 0;
                    found_tag = 1;
            }

        } else {    /* ! looking_for_tag */

            switch (c) {
                case ' '  :	/* ignore whitespace */
                case '\t' :
                case '\n' :
                case '\r' :
                    break;

                case '&'  :	/* AND operator */
                    c = searchPtr->string[searchPtr->stringIndex++];
                    if (c != '&') {
                        Tcl_AppendResult(interp,
                                "Singleton '&' in tag search expression",
                                (char *) NULL);
                        return TCL_ERROR;
                    }
                    expr->uids[expr->index++] = andUid;
                    looking_for_tag = 1;
                    break;

                case '|'  :	/* OR operator */
                    c = searchPtr->string[searchPtr->stringIndex++];
                    if (c != '|') {
                        Tcl_AppendResult(interp,
                                "Singleton '|' in tag search expression",
                                (char *) NULL);
                        return TCL_ERROR;
                    }
                    expr->uids[expr->index++] = orUid;
                    looking_for_tag = 1;
                    break;

                case '^'  :	/* XOR operator */
                    expr->uids[expr->index++] = xorUid;
                    looking_for_tag = 1;
                    break;

                case ')'  :	/* end subexpression */
                    expr->uids[expr->index++] = endparenUid;
                    goto breakwhile;

                default   :	/* syntax error */
                    Tcl_AppendResult(interp,
			    "Invalid boolean operator in tag search expression",
			    (char *) NULL);
                    return TCL_ERROR;
            }
        }
    }
    breakwhile:
    if (found_tag && ! looking_for_tag) {
        return TCL_OK;
    }
    Tcl_AppendResult(interp, "Missing tag in tag search expression",
	    (char *) NULL);
    return TCL_ERROR;
}

/*
 *--------------------------------------------------------------
 *
 * TagSearchEvalExpr --
 *
 *      This recursive procedure is called to eval a tag expression.
 *
 * Results:
 *      The return value indicates if the tagOrId expression
 *      successfully matched the tags of the current item.
 *
 * Side effects:
 *
 *--------------------------------------------------------------
 */

static int
TagSearchEvalExpr(expr, itemPtr)
    TagSearchExpr *expr;        /* Search expression */
    Tk_Item *itemPtr;           /* Item being test for match */
{
    int looking_for_tag;        /* When true, scanner expects
                                 * next char(s) to be a tag,
                                 * else operand expected */
    int negate_result;          /* Pending negation of next tag value */
    Tk_Uid uid;
    Tk_Uid *tagPtr;
    int count;
    int result;                 /* Value of expr so far */
    int parendepth;

    result = 0;  /* just to keep the compiler quiet */

    negate_result = 0;
    looking_for_tag = 1;
    while (expr->index < expr->length) {
        uid = expr->uids[expr->index++];
        if (looking_for_tag) {
            if (uid == tagvalUid) {
/*
 *              assert(expr->index < expr->length);
 */
                uid = expr->uids[expr->index++];
                result = 0;
                /*
                 * set result 1 if tag is found in item's tags
                 */
                for (tagPtr = itemPtr->tagPtr, count = itemPtr->numTags;
                    count > 0; tagPtr++, count--) {
                    if (*tagPtr == uid) {
                        result = 1;
                        break;
                    }
                }

            } else if (uid == negtagvalUid) {
                negate_result = ! negate_result;
/*
 *              assert(expr->index < expr->length);
 */
                uid = expr->uids[expr->index++];
                result = 0;
                /*
                 * set result 1 if tag is found in item's tags
                 */
                for (tagPtr = itemPtr->tagPtr, count = itemPtr->numTags;
                    count > 0; tagPtr++, count--) {
                    if (*tagPtr == uid) {
                        result = 1;
                        break;
                    }
                }

            } else if (uid == parenUid) {
                /*
                 * evaluate subexpressions with recursion
                 */
                result = TagSearchEvalExpr(expr, itemPtr);

            } else if (uid == negparenUid) {
                negate_result = ! negate_result;
                /*
                 * evaluate subexpressions with recursion
                 */
                result = TagSearchEvalExpr(expr, itemPtr);
/*
 *          } else {
 *              assert(0);
 */
            }
            if (negate_result) {
                result = ! result;
                negate_result = 0;
            }
            looking_for_tag = 0;
        } else {    /* ! looking_for_tag */
            if (((uid == andUid) && (!result)) || ((uid == orUid) && result)) {
                /*
                 * short circuit expression evaluation
                 *
                 * if result before && is 0, or result before || is 1,
                 *   then the expression is decided and no further
                 *   evaluation is needed.
                 */

                    parendepth = 0;
		while (expr->index < expr->length) {
		    uid = expr->uids[expr->index++];
		    if (uid == tagvalUid || uid == negtagvalUid) {
			expr->index++;
			continue;
		    }
                        if (uid == parenUid || uid == negparenUid) {
                            parendepth++;
			continue;
		    } 
		    if (uid == endparenUid) {
                            parendepth--;
                            if (parendepth < 0) {
                                break;
                            }
                        }
                    }
                return result;

            } else if (uid == xorUid) {
                /*
                 * if the previous result was 1
                 *   then negate the next result
                 */
                negate_result = result;

            } else if (uid == endparenUid) {
                return result;
/*
 *          } else {
 *               assert(0);
 */
            }
            looking_for_tag = 1;
        }
    }
/*
 *  assert(! looking_for_tag);
 */
    return result;
}

/*
 *--------------------------------------------------------------
 *
 * TagSearchFirst --
 *
 *      This procedure is called to get the first item
 *      item that matches a preestablished search predicate
 *      that was set by TagSearchScan.
 *
 * Results:
 *      The return value is a pointer to the first item, or NULL
 *      if there is no such item.  The information at *searchPtr
 *      is updated such that successive calls to TagSearchNext
 *      will return successive items.
 *
 * Side effects:
 *      SearchPtr is linked into a list of searches in progress
 *      on canvasPtr, so that elements can safely be deleted
 *      while the search is in progress.
 *
 *--------------------------------------------------------------
 */

static Tk_Item *
TagSearchFirst(searchPtr)
    TagSearch *searchPtr;               /* Record describing tag search */
{
    Tk_Item *itemPtr, *lastPtr;
    Tk_Uid uid, *tagPtr;
    int count;

    /* short circuit impossible searches for null tags */
    if (searchPtr->stringLength == 0) {
        return NULL;
    }

    /*
     * Find the first matching item in one of several ways. If the tag
     * is a number then it selects the single item with the matching
     * identifier.  In this case see if the item being requested is the
     * hot item, in which case the search can be skipped.
     */

    if (searchPtr->type == 1) {
        Tcl_HashEntry *entryPtr;

        itemPtr = searchPtr->canvasPtr->hotPtr;
        lastPtr = searchPtr->canvasPtr->hotPrevPtr;
        if ((itemPtr == NULL) || (itemPtr->id != searchPtr->id) || (lastPtr == NULL)
            || (lastPtr->nextPtr != itemPtr)) {
            entryPtr = Tcl_FindHashEntry(&searchPtr->canvasPtr->idTable,
                (char *) searchPtr->id);
            if (entryPtr != NULL) {
                itemPtr = (Tk_Item *)Tcl_GetHashValue(entryPtr);
                lastPtr = itemPtr->prevPtr;
            } else {
                lastPtr = itemPtr = NULL;
            }
        }
        searchPtr->lastPtr = lastPtr;
        searchPtr->searchOver = 1;
        searchPtr->canvasPtr->hotPtr = itemPtr;
        searchPtr->canvasPtr->hotPrevPtr = lastPtr;
        return itemPtr;
    }

    if (searchPtr->type == 2) {

        /*
         * All items match.
         */

        searchPtr->lastPtr = NULL;
        searchPtr->currentPtr = searchPtr->canvasPtr->firstItemPtr;
        return searchPtr->canvasPtr->firstItemPtr;
    }

    if (searchPtr->type == 3) {

        /*
         * Optimized single-tag search
         */

        uid = searchPtr->expr->uid;
        for (lastPtr = NULL, itemPtr = searchPtr->canvasPtr->firstItemPtr;
                itemPtr != NULL; lastPtr = itemPtr, itemPtr = itemPtr->nextPtr) {
            for (tagPtr = itemPtr->tagPtr, count = itemPtr->numTags;
                    count > 0; tagPtr++, count--) {
                if (*tagPtr == uid) {
                    searchPtr->lastPtr = lastPtr;
                    searchPtr->currentPtr = itemPtr;
                    return itemPtr;
                }
            }
        }
    } else {

    /*
         * None of the above.  Search for an item matching the tag expression.
     */

    for (lastPtr = NULL, itemPtr = searchPtr->canvasPtr->firstItemPtr;
                itemPtr != NULL; lastPtr = itemPtr, itemPtr = itemPtr->nextPtr) {
	    searchPtr->expr->index = 0;
	    if (TagSearchEvalExpr(searchPtr->expr, itemPtr)) {
            searchPtr->lastPtr = lastPtr;
            searchPtr->currentPtr = itemPtr;
            return itemPtr;
        }
        }
    }
    searchPtr->lastPtr = lastPtr;
    searchPtr->searchOver = 1;
    return NULL;
}

/*
 *--------------------------------------------------------------
 *
 * TagSearchNext --
 *
 *      This procedure returns successive items that match a given
 *      tag;  it should be called only after TagSearchFirst has been
 *      used to begin a search.
 *
 * Results:
 *      The return value is a pointer to the next item that matches
 *      the tag expr specified to TagSearchScan, or NULL if no such
 *      item exists.  *SearchPtr is updated so that the next call
 *      to this procedure will return the next item.
 *
 * Side effects:
 *      None.
 *
 *--------------------------------------------------------------
 */

static Tk_Item *
TagSearchNext(searchPtr)
    TagSearch *searchPtr;               /* Record describing search in
                                         * progress. */
{
    Tk_Item *itemPtr, *lastPtr;
    Tk_Uid uid, *tagPtr;
    int count;

    /*
     * Find next item in list (this may not actually be a suitable
     * one to return), and return if there are no items left.
     */

    lastPtr = searchPtr->lastPtr;
    if (lastPtr == NULL) {
        itemPtr = searchPtr->canvasPtr->firstItemPtr;
    } else {
        itemPtr = lastPtr->nextPtr;
    }
    if ((itemPtr == NULL) || (searchPtr->searchOver)) {
        searchPtr->searchOver = 1;
        return NULL;
    }
    if (itemPtr != searchPtr->currentPtr) {
        /*
         * The structure of the list has changed.  Probably the
         * previously-returned item was removed from the list.
         * In this case, don't advance lastPtr;  just return
         * its new successor (i.e. do nothing here).
         */
    } else {
        lastPtr = itemPtr;
        itemPtr = lastPtr->nextPtr;
    }

    if (searchPtr->type == 2) {

        /*
         * All items match.
         */

        searchPtr->lastPtr = lastPtr;
        searchPtr->currentPtr = itemPtr;
        return itemPtr;
    }

    if (searchPtr->type == 3) {

        /*
         * Optimized single-tag search
         */

        uid = searchPtr->expr->uid;
        for ( ; itemPtr != NULL; lastPtr = itemPtr, itemPtr = itemPtr->nextPtr) {
            for (tagPtr = itemPtr->tagPtr, count = itemPtr->numTags;
                    count > 0; tagPtr++, count--) {
                if (*tagPtr == uid) {
                    searchPtr->lastPtr = lastPtr;
                    searchPtr->currentPtr = itemPtr;
                    return itemPtr;
                }
            }
        }
        searchPtr->lastPtr = lastPtr;
        searchPtr->searchOver = 1;
        return NULL;
    }

    /*
     * Else.... evaluate tag expression
     */

    for ( ; itemPtr != NULL; lastPtr = itemPtr, itemPtr = itemPtr->nextPtr) {
        searchPtr->expr->index = 0;
        if (TagSearchEvalExpr(searchPtr->expr, itemPtr)) {
            searchPtr->lastPtr = lastPtr;
            searchPtr->currentPtr = itemPtr;
            return itemPtr;
        }
    }
    searchPtr->lastPtr = lastPtr;
    searchPtr->searchOver = 1;
    return NULL;
}
#endif /* USE_OLD_TAG_SEARCH */

d2366 1
a2366 1
 *	to the interp's result;  otherwise tag is added to itemPtr's
d2388 1
a2388 2
	char msg[TCL_INTEGER_SPACE];

d2442 3
a2444 3
 *	returned in the interp's result.  If newTag is NULL, then
 *	the normal the interp's result is an empty string.  If an error
 *	occurs, then the interp's result will hold an error message.
d2455 1
a2455 5
#ifdef USE_OLD_TAG_SEARCH
FindItems(interp, canvasPtr, argc, argv, newTag, first)
#else /* USE_OLD_TAG_SEARCH */
FindItems(interp, canvasPtr, argc, argv, newTag, first, searchPtrPtr)
#endif /* USE_OLD_TAG_SEARCH */
d2461 1
a2461 1
    Tcl_Obj *CONST *argv;		/* Arguments that describe what items
d2464 1
a2464 1
    Tcl_Obj *newTag;			/* If non-NULL, gives new tag to set
d2467 6
a2472 7
					 * in the interp's result. */
    int first;				/* For error messages:  gives number
					 * of elements of argv which are already
					 * handled. */
#ifndef USE_OLD_TAG_SEARCH
    TagSearch **searchPtrPtr;           /* From CanvasWidgetCmd local vars*/
#endif /* not USE_OLD_TAG_SEARCH */
d2474 2
a2475 1
#ifdef USE_OLD_TAG_SEARCH
a2476 1
#endif /* USE_OLD_TAG_SEARCH */
a2478 9
    int index;
    static char *optionStrings[] = {
	"above", "all", "below", "closest",
	"enclosed", "overlapping", "withtag", NULL
    };
    enum options {
	CANV_ABOVE, CANV_ALL, CANV_BELOW, CANV_CLOSEST,
	CANV_ENCLOSED, CANV_OVERLAPPING, CANV_WITHTAG
    };
d2481 1
a2481 1
	uid = Tk_GetUid(Tcl_GetStringFromObj(newTag, NULL));
d2485 4
a2488 6
    if (Tcl_GetIndexFromObj(interp, argv[first], optionStrings, "search command", 0,
	    &index) != TCL_OK) {
	return TCL_ERROR;
    }
    switch ((enum options) index) {
      case CANV_ABOVE: {
d2490 3
a2492 2
	if (argc != first+2) {
	    Tcl_WrongNumArgs(interp, first+1, argv, "tagOrId");
d2495 1
a2495 2
#ifdef USE_OLD_TAG_SEARCH
	for (itemPtr = StartTagSearch(canvasPtr, argv[first+1], &search);
a2496 7
#else /* USE_OLD_TAG_SEARCH */
        if (TagSearchScan(canvasPtr, argv[first+1], searchPtrPtr) != TCL_OK) {
            return TCL_ERROR;
        }
        for (itemPtr = TagSearchFirst(*searchPtrPtr);
                itemPtr != NULL; itemPtr = TagSearchNext(*searchPtrPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
d2502 5
a2506 5
	break;
      }
      case CANV_ALL: {
	if (argc != first+1) {
	    Tcl_WrongNumArgs(interp, first+1, argv, (char *) NULL);
d2514 1
a2514 3
	break;
      }
      case CANV_BELOW: {
d2517 3
a2519 2
	if (argc != first+2) {
	    Tcl_WrongNumArgs(interp, first+1, argv, "tagOrId");
d2522 3
a2524 12
#ifdef USE_OLD_TAG_SEARCH
	itemPtr = StartTagSearch(canvasPtr, argv[first+1], &search);
#else /* USE_OLD_TAG_SEARCH */
        if (TagSearchScan(canvasPtr, argv[first+1], searchPtrPtr) != TCL_OK) {
            return TCL_ERROR;
        }
        itemPtr = TagSearchFirst(*searchPtrPtr);
#endif /* USE_OLD_TAG_SEARCH */
	if (itemPtr != NULL) {
	    if (itemPtr->prevPtr != NULL) {
		DoItem(interp, itemPtr->prevPtr, uid);
	    }
d2526 1
a2526 3
	break;
      }
      case CANV_CLOSEST: {
d2532 4
a2535 2
	if ((argc < first+3) || (argc > first+5)) {
	    Tcl_WrongNumArgs(interp, first+1, argv, "x y ?halo? ?start?");
d2538 3
a2540 3
	if ((Tk_CanvasGetCoordFromObj(interp, (Tk_Canvas) canvasPtr, argv[first+1],
		&coords[0]) != TCL_OK) || (Tk_CanvasGetCoordFromObj(interp,
		(Tk_Canvas) canvasPtr, argv[first+2], &coords[1]) != TCL_OK)) {
d2543 2
a2544 2
	if (argc > first+3) {
	    if (Tk_CanvasGetCoordFromObj(interp, (Tk_Canvas) canvasPtr, argv[first+3],
d2550 1
a2550 1
			Tcl_GetString(argv[3]), "\"", (char *) NULL);
d2562 2
a2563 9
	if (argc == first+5) {
#ifdef USE_OLD_TAG_SEARCH
	    itemPtr = StartTagSearch(canvasPtr, argv[first+4], &search);
#else /* USE_OLD_TAG_SEARCH */
            if (TagSearchScan(canvasPtr, argv[first+4], searchPtrPtr) != TCL_OK) {
                return TCL_ERROR;
            }
            itemPtr = TagSearchFirst(*searchPtrPtr);
#endif /* USE_OLD_TAG_SEARCH */
a2577 4
	while(itemPtr && (itemPtr->state == TK_STATE_HIDDEN ||
	    (itemPtr->state == TK_STATE_NULL && canvasPtr->canvas_state == TK_STATE_HIDDEN))) {
	    itemPtr = itemPtr->nextPtr;
	}
a2614 4
		if (itemPtr->state == TK_STATE_HIDDEN || (itemPtr->state == TK_STATE_NULL &&
			canvasPtr->canvas_state == TK_STATE_HIDDEN)) {
		    continue;
		}
d2630 4
a2633 5
	break;
      }
      case CANV_ENCLOSED: {
	if (argc != first+5) {
	    Tcl_WrongNumArgs(interp, first+1, argv, "x1 y1 x2 y2");
d2636 6
a2641 5
	return FindArea(interp, canvasPtr, argv+first+1, uid, 1);
      }
      case CANV_OVERLAPPING: {
	if (argc != first+5) {
	    Tcl_WrongNumArgs(interp, first+1, argv, "x1 y1 x2 y2");
d2644 5
a2648 5
	return FindArea(interp, canvasPtr, argv+first+1, uid, 0);
      }
      case CANV_WITHTAG: {
	if (argc != first+2) {
	    Tcl_WrongNumArgs(interp, first+1, argv, "tagOrId");
d2651 1
a2651 2
#ifdef USE_OLD_TAG_SEARCH
	for (itemPtr = StartTagSearch(canvasPtr, argv[first+1], &search);
a2652 7
#else /* USE_OLD_TAG_SEARCH */
        if (TagSearchScan(canvasPtr, argv[first+1], searchPtrPtr) != TCL_OK) {
            return TCL_ERROR;
        }
        for (itemPtr = TagSearchFirst(*searchPtrPtr);
                itemPtr != NULL; itemPtr = TagSearchNext(*searchPtrPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
d2655 5
a2659 1
      }
d2675 3
a2677 3
 *	by the rectangle given by argc is returned in the interp's result.
 *	If newTag is NULL, then the normal the interp's result is an
 *	empty string.  If an error occurs, then the interp's result will
d2694 1
a2694 1
    Tcl_Obj *CONST *argv;		/* Array of four arguments that
d2700 1
a2700 1
					 * in the interp's result. */
d2709 1
a2709 1
    if ((Tk_CanvasGetCoordFromObj(interp, (Tk_Canvas) canvasPtr, argv[0],
d2711 1
a2711 1
	    || (Tk_CanvasGetCoordFromObj(interp, (Tk_Canvas) canvasPtr, argv[1],
d2713 1
a2713 1
	    || (Tk_CanvasGetCoordFromObj(interp, (Tk_Canvas) canvasPtr, argv[2],
d2715 1
a2715 1
	    || (Tk_CanvasGetCoordFromObj(interp, (Tk_Canvas) canvasPtr, argv[3],
a2736 4
	if (itemPtr->state == TK_STATE_HIDDEN || (itemPtr->state == TK_STATE_NULL &&
		canvasPtr->canvas_state == TK_STATE_HIDDEN)) {
	    continue;
	}
a2768 1
#ifdef USE_OLD_TAG_SEARCH
a2770 4
#else /* USE_OLD_TAG_SEARCH */
static int
RelinkItems(canvasPtr, tag, prevPtr, searchPtrPtr)
#endif /* USE_OLD_TAG_SEARCH */
d2772 1
a2772 1
    Tcl_Obj *tag;		/* Tag identifying items to be moved
a2776 3
#ifndef USE_OLD_TAG_SEARCH
    TagSearch **searchPtrPtr;   /* From CanvasWidgetCmd local vars */
#endif /* not USE_OLD_TAG_SEARCH */
a2778 1
#ifdef USE_OLD_TAG_SEARCH
a2779 1
#endif /* USE_OLD_TAG_SEARCH */
a2788 1
#ifdef USE_OLD_TAG_SEARCH
a2790 7
#else /* USE_OLD_TAG_SEARCH */
    if (TagSearchScan(canvasPtr, tag, searchPtrPtr) != TCL_OK) {
        return TCL_ERROR;
    }
    for (itemPtr = TagSearchFirst(*searchPtrPtr);
            itemPtr != NULL; itemPtr = TagSearchNext(*searchPtrPtr)) {
#endif /* USE_OLD_TAG_SEARCH */
d2821 2
a2822 1
	EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
a2831 1
#ifdef USE_OLD_TAG_SEARCH
a2832 3
#else /* USE_OLD_TAG_SEARCH */
        return TCL_OK;
#endif /* USE_OLD_TAG_SEARCH */
a2852 3
#ifndef USE_OLD_TAG_SEARCH
    return TCL_OK;
#endif /* not USE_OLD_TAG_SEARCH */
d2970 2
a2971 3
 *	current item, a fake enter event on the new current item
 *	item and force a redraw of the two items. Canvas items
 *      that are hidden or disabled are ignored.
a2996 1
    Tk_Item *prevItemPtr;
a3117 3
#ifdef USE_OLD_TAG_SEARCH
		if (itemPtr->tagPtr[i] == Tk_GetUid("current")) {
#else /* USE_OLD_TAG_SEARCH */
a3118 1
#endif /* USE_OLD_TAG_SEARCH */
a3142 1
    prevItemPtr = canvasPtr->currentItemPtr;
a3144 7
    if (prevItemPtr != NULL && prevItemPtr != canvasPtr->currentItemPtr &&
	    (prevItemPtr->redraw_flags & TK_ITEM_STATE_DEPENDANT)) {
	EventuallyRedrawItem((Tk_Canvas) canvasPtr, prevItemPtr);
	(*prevItemPtr->typePtr->configProc)(canvasPtr->interp,
		(Tk_Canvas) canvasPtr, prevItemPtr, 0, (Tcl_Obj **) NULL,
		TK_CONFIG_ARGV_ONLY);
    }
a3147 4
#ifdef USE_OLD_TAG_SEARCH
	DoItem((Tcl_Interp *) NULL, canvasPtr->currentItemPtr, 
                Tk_GetUid("current"));
#else /* USE_OLD_TAG_SEARCH */
a3148 9
#endif /* USE_OLD_TAG_SEA */
	if ((canvasPtr->currentItemPtr->redraw_flags & TK_ITEM_STATE_DEPENDANT &&
		prevItemPtr != canvasPtr->currentItemPtr)) {
	    (*canvasPtr->currentItemPtr->typePtr->configProc)(canvasPtr->interp,
		    (Tk_Canvas) canvasPtr, canvasPtr->currentItemPtr, 0, (Tcl_Obj **) NULL,
		    TK_CONFIG_ARGV_ONLY);
	    EventuallyRedrawItem((Tk_Canvas) canvasPtr,
		    canvasPtr->currentItemPtr);
	}
d3162 1
a3162 2
 *	is "close" to the coordinates. Canvas items that are hidden
 *	or disabled are ignored.
a3191 5
	if (itemPtr->state == TK_STATE_HIDDEN || itemPtr->state==TK_STATE_DISABLED ||
		(itemPtr->state == TK_STATE_NULL && (canvasPtr->canvas_state == TK_STATE_HIDDEN ||
		canvasPtr->canvas_state == TK_STATE_DISABLED))) {
	    continue;
	}
a3235 4
#ifndef USE_OLD_TAG_SEARCH
    TagSearchExpr *expr;
    int numExprs;
#endif /* not USE_OLD_TAG_SEARCH */
a3248 1
#ifdef USE_OLD_TAG_SEARCH
a3257 29
#else /* USE_OLD_TAG_SEARCH */
    /*
     * Set up an array with all the relevant objects for processing
     * this event.  The relevant objects are:
     * (a) the event's item,
     * (b) the tags associated with the event's item, 
     * (c) the expressions that are true for the event's item's tags, and
     * (d) the tag "all". 
     *
     * If there are a lot of tags then malloc an array to hold all of
     * the objects.
     */

    /*
     * flag and count all expressions that match item's tags
     */
    numExprs = 0;
    expr = canvasPtr->bindTagExprs;
    while (expr) {
	expr->index = 0;
    	expr->match = TagSearchEvalExpr(expr, itemPtr);
	if (expr->match) {
	    numExprs++;
	}
	expr = expr->next;
    }

    numObjects = itemPtr->numTags + numExprs + 2;
#endif /* not USE_OLD_TAG_SEARCH */
a3263 3
#ifdef USE_OLD_TAG_SEARCH
    objectPtr[0] = (ClientData) Tk_GetUid("all");
#else /* USE_OLD_TAG_SEARCH */
a3264 1
#endif /* USE_OLD_TAG_SEARCH */
a3268 13
#ifndef USE_OLD_TAG_SEARCH
    /*
     * copy uids of matching expressions into object array
     */
    i = itemPtr->numTags+2;
    expr = canvasPtr->bindTagExprs;
    while (expr) {
    	if (expr->match) {
	    objectPtr[i++] = (int *) expr->uid;
	}
	expr = expr->next;
    }
#endif /* not USE_OLD_TAG_SEARCH */
d3323 5
a3327 2
	EventuallyRedrawItem((Tk_Canvas) canvasPtr,
		canvasPtr->textInfo.focusItemPtr);
d3370 5
a3374 2
	EventuallyRedrawItem((Tk_Canvas) canvasPtr,
		canvasPtr->textInfo.focusItemPtr);
d3424 5
a3428 2
	EventuallyRedrawItem((Tk_Canvas) canvasPtr,
		canvasPtr->textInfo.selItemPtr);
d3446 2
a3447 1
	EventuallyRedrawItem((Tk_Canvas) canvasPtr, itemPtr);
d3521 5
a3525 2
	EventuallyRedrawItem((Tk_Canvas) canvasPtr,
		canvasPtr->textInfo.selItemPtr);
a3829 234

/*
 *----------------------------------------------------------------------
 *
 * GetStringsFromObjs
 *
 * Results:
 *	Converts object list into string list.
 *
 * Side effects:
 *	Memory is allocated for the argv array, which must
 *	be freed using ckfree() when no longer needed.
 *
 *----------------------------------------------------------------------
 */
/* ARGSUSED */
static char **
GetStringsFromObjs(argc, objv)
    int argc;
    Tcl_Obj *CONST objv[];
{
    register int i;
    char **argv;
    if (argc <= 0) {
	return NULL;
    }
    argv = (char **) ckalloc((argc+1) * sizeof(char *));
    for (i = 0; i < argc; i++) {
	argv[i]=Tcl_GetStringFromObj(objv[i], (int *) NULL);
    }
    argv[argc] = 0;
    return argv;
}

/*
 *--------------------------------------------------------------
 *
 * Tk_CanvasPsColor --
 *
 *	This procedure is called by individual canvas items when
 *	they want to set a color value for output.  Given information
 *	about an X color, this procedure will generate Postscript
 *	commands to set up an appropriate color in Postscript.
 *
 * Results:
 *	Returns a standard Tcl return value.  If an error occurs
 *	then an error message will be left in interp->result.
 *	If no error occurs, then additional Postscript will be
 *	appended to interp->result.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

int
Tk_CanvasPsColor(interp, canvas, colorPtr)
    Tcl_Interp *interp;			/* Interpreter for returning Postscript
					 * or error message. */
    Tk_Canvas canvas;			/* Information about canvas. */
    XColor *colorPtr;			/* Information about color. */
{
    return Tk_PostscriptColor(interp, ((TkCanvas *) canvas)->psInfo,
	    colorPtr);
}

/*
 *--------------------------------------------------------------
 *
 * Tk_CanvasPsFont --
 *
 *	This procedure is called by individual canvas items when
 *	they want to output text.  Given information about an X
 *	font, this procedure will generate Postscript commands
 *	to set up an appropriate font in Postscript.
 *
 * Results:
 *	Returns a standard Tcl return value.  If an error occurs
 *	then an error message will be left in interp->result.
 *	If no error occurs, then additional Postscript will be
 *	appended to the interp->result.
 *
 * Side effects:
 *	The Postscript font name is entered into psInfoPtr->fontTable
 *	if it wasn't already there.
 *
 *--------------------------------------------------------------
 */

int
Tk_CanvasPsFont(interp, canvas, tkfont)
    Tcl_Interp *interp;			/* Interpreter for returning Postscript
					 * or error message. */
    Tk_Canvas canvas;			/* Information about canvas. */
    Tk_Font tkfont;			/* Information about font in which text
					 * is to be printed. */
{
    return Tk_PostscriptFont(interp, ((TkCanvas *) canvas)->psInfo, tkfont);
}

/*
 *--------------------------------------------------------------
 *
 * Tk_CanvasPsBitmap --
 *
 *	This procedure is called to output the contents of a
 *	sub-region of a bitmap in proper image data format for
 *	Postscript (i.e. data between angle brackets, one bit
 *	per pixel).
 *
 * Results:
 *	Returns a standard Tcl return value.  If an error occurs
 *	then an error message will be left in interp->result.
 *	If no error occurs, then additional Postscript will be
 *	appended to interp->result.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

int
Tk_CanvasPsBitmap(interp, canvas, bitmap, startX, startY, width, height)
    Tcl_Interp *interp;			/* Interpreter for returning Postscript
					 * or error message. */
    Tk_Canvas canvas;			/* Information about canvas. */
    Pixmap bitmap;			/* Bitmap for which to generate
					 * Postscript. */
    int startX, startY;			/* Coordinates of upper-left corner
					 * of rectangular region to output. */
    int width, height;			/* Height of rectangular region. */
{
    return Tk_PostscriptBitmap(interp, ((TkCanvas *) canvas)->tkwin,
	    ((TkCanvas *) canvas)->psInfo, bitmap, startX, startY,
	    width, height);
}

/*
 *--------------------------------------------------------------
 *
 * Tk_CanvasPsStipple --
 *
 *	This procedure is called by individual canvas items when
 *	they have created a path that they'd like to be filled with
 *	a stipple pattern.  Given information about an X bitmap,
 *	this procedure will generate Postscript commands to fill
 *	the current clip region using a stipple pattern defined by the
 *	bitmap.
 *
 * Results:
 *	Returns a standard Tcl return value.  If an error occurs
 *	then an error message will be left in interp->result.
 *	If no error occurs, then additional Postscript will be
 *	appended to interp->result.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

int
Tk_CanvasPsStipple(interp, canvas, bitmap)
    Tcl_Interp *interp;			/* Interpreter for returning Postscript
					 * or error message. */
    Tk_Canvas canvas;			/* Information about canvas. */
    Pixmap bitmap;			/* Bitmap to use for stippling. */
{
    return Tk_PostscriptStipple(interp, ((TkCanvas *) canvas)->tkwin,
	    ((TkCanvas *) canvas)->psInfo, bitmap);
}

/*
 *--------------------------------------------------------------
 *
 * Tk_CanvasPsY --
 *
 *	Given a y-coordinate in canvas coordinates, this procedure
 *	returns a y-coordinate to use for Postscript output.
 *
 * Results:
 *	Returns the Postscript coordinate that corresponds to
 *	"y".
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

double
Tk_CanvasPsY(canvas, y)
    Tk_Canvas canvas;			/* Token for canvas on whose behalf
					 * Postscript is being generated. */
    double y;				/* Y-coordinate in canvas coords. */
{
    return Tk_PostscriptY(y, ((TkCanvas *) canvas)->psInfo);
}

/*
 *--------------------------------------------------------------
 *
 * Tk_CanvasPsPath --
 *
 *	Given an array of points for a path, generate Postscript
 *	commands to create the path.
 *
 * Results:
 *	Postscript commands get appended to what's in interp->result.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

void
Tk_CanvasPsPath(interp, canvas, coordPtr, numPoints)
    Tcl_Interp *interp;			/* Put generated Postscript in this
					 * interpreter's result field. */
    Tk_Canvas canvas;			/* Canvas on whose behalf Postscript
					 * is being generated. */
    double *coordPtr;			/* Pointer to first in array of
					 * 2*numPoints coordinates giving
					 * points for path. */
    int numPoints;			/* Number of points at *coordPtr. */
{
    Tk_PostscriptPath(interp, ((TkCanvas *) canvas)->psInfo,
	    coordPtr, numPoints);
}


@


1.1.1.3
log
@import tk 8.4.0
@
text
@d15 1
a15 1
 * RCS: @@(#) $Id: tkCanvas.c,v 1.20 2002/08/05 04:30:38 dgp Exp $
d294 1
a294 1
static CONST char**	GetStringsFromObjs _ANSI_ARGS_((int argc,
d302 3
a304 2
static Tcl_Obj *	ScrollFractions _ANSI_ARGS_((int screen1,
			    int screen2, int object1, int object2));
d333 4
a336 3
static Tk_ClassProcs canvasClass = {
    sizeof(Tk_ClassProcs),	/* size */
    CanvasWorldChanged,		/* worldChangedProc */
d470 1
a470 1
    Tk_SetClassProcs(canvasPtr->tkwin, &canvasClass, (ClientData) canvasPtr);
d531 1
a531 1
    static CONST char *optionStrings[] = {
d775 1
a775 1
	    CONST char *command;
d780 1
a780 1
		CONST char *string;
d796 1
a796 1
		Tcl_SetResult(interp, (char *) command, TCL_STATIC);
d905 1
a905 1
		CONST char **args = GetStringsFromObjs(argc-3, argv+3);
d964 1
a964 1
	  CONST char **args = GetStringsFromObjs(argc-3, argv+3);
d1393 1
a1393 2
	    result = TCL_ERROR;
	    goto done;
d1441 1
a1441 1
		CONST char **args = GetStringsFromObjs(argc-3, argv+3);
d1530 1
a1530 1
	CONST char **args = GetStringsFromObjs(argc, argv);
d1624 1
a1624 1
	static CONST char *optionStrings[] = {
d1628 6
a1633 7
	if (argc < 5) {
	    Tcl_WrongNumArgs(interp, 2, argv, "mark|dragto x y ?dragGain?");
	    result = TCL_ERROR;
	} else if (Tcl_GetIndexFromObj(interp, argv[2], optionStrings,
		"scan option", 0, &index) != TCL_OK) {
	    result = TCL_ERROR;
	} else if ((argc != 5) && (argc != 5+index)) {
d1636 3
a1638 1
	} else if ((Tcl_GetIntFromObj(interp, argv[3], &x) != TCL_OK)
d1641 3
a1643 2
	} else if ((argc == 6) &&
		(Tcl_GetIntFromObj(interp, argv[5], &gain) != TCL_OK)) {
d1645 3
a1647 1
	} else if (!index) {
d1672 1
a1672 1
	static CONST char *optionStrings[] = {
d1722 1
a1722 2
	    result = TCL_ERROR;
	    goto done;
d1820 1
a1820 2
	    Tcl_SetObjResult(interp, ScrollFractions(
		    canvasPtr->xOrigin + canvasPtr->inset,
d1823 1
a1823 1
		    canvasPtr->scrollX2));
d1825 1
a1825 1
	    CONST char **args = GetStringsFromObjs(argc, argv);
d1863 1
a1863 2
	    Tcl_SetObjResult(interp,ScrollFractions(\
		    canvasPtr->yOrigin + canvasPtr->inset,
d1866 1
a1866 1
		    canvasPtr->scrollY2));
d1868 1
a1868 1
	    CONST char **args = GetStringsFromObjs(argc, argv);
a1932 3
#ifndef USE_OLD_TAG_SEARCH
    TagSearchExpr *expr, *next;
#endif
d1934 7
d1967 9
a1975 5
    expr = canvasPtr->bindTagExprs;
    while (expr) {
	next = expr->next;
	TagSearchExprDestroy(expr);
	expr = next;
d2021 1
a2021 2
	    argc, (CONST char **) argv, (char *) canvasPtr,
	    flags|TK_CONFIG_OBJS) != TCL_OK) {
d2074 1
a2074 1
	CONST char **argv2;
d2451 1
a2451 10
	if (canvasPtr->tkwin != NULL) {
	    canvasPtr->tkwin = NULL;
	    Tcl_DeleteCommandFromToken(canvasPtr->interp,
		    canvasPtr->widgetCmd);
	}
	if (canvasPtr->flags & REDRAW_PENDING) {
	    Tcl_CancelIdleCall(DisplayCanvas, (ClientData) canvasPtr);
	}
	Tcl_EventuallyFree((ClientData) canvasPtr,
		(Tcl_FreeProc *) DestroyCanvas);
d3975 1
a3975 1
    static CONST char *optionStrings[] = {
d5208 1
a5208 1
 * ScrollFractions --
d5211 3
a5213 3
 *	range" for what's in the canvas, return a list of two
 *	doubles representing the scroll fractions.  This procedure
 *	is used for both x and y scrolling.
d5226 2
a5227 2
static Tcl_Obj *
ScrollFractions(screen1, screen2, object1, object2)
d5232 3
a5236 1
    char buffer[2*TCL_DOUBLE_SPACE+2];
d5255 1
a5255 2
    sprintf(buffer, "%g %g", f1, f2);
    return Tcl_NewStringObj(buffer, -1);
d5284 1
d5316 3
a5318 5
	Tcl_Obj *fractions = ScrollFractions(xOrigin + inset,
		xOrigin + width - inset, scrollX1, scrollX2);
	result = Tcl_VarEval(interp, xScrollCmd, " ", 
		Tcl_GetString(fractions), (char *) NULL);
	Tcl_DecrRefCount(fractions);
d5327 3
a5329 5
	Tcl_Obj *fractions = ScrollFractions(yOrigin + inset,
		yOrigin + height - inset, scrollY1, scrollY2);
	result = Tcl_VarEval(interp, yScrollCmd, " ", 
		Tcl_GetString(fractions), (char *) NULL);
	Tcl_DecrRefCount(fractions);
d5487 1
a5487 1
static CONST char **
d5493 1
a5493 1
    CONST char **argv;
d5497 1
a5497 1
    argv = (CONST char **) ckalloc((argc+1) * sizeof(char *));
d5703 2
@


