head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.20.24.44;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.13;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.25;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.51;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.32;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.15;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@/* 
 * tkListbox.c --
 *
 *	This module implements listbox widgets for the Tk
 *	toolkit.  A listbox displays a collection of strings,
 *	one per line, and provides scrolling and selection.
 *
 * Copyright (c) 1990-1994 The Regents of the University of California.
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkListbox.c,v 1.28 2002/08/05 04:30:39 dgp Exp $
 */

#include "tkPort.h"
#include "default.h"
#include "tkInt.h"

#ifdef WIN32
#include "tkWinInt.h"
#endif

typedef struct {
    Tk_OptionTable listboxOptionTable;	/* Table defining configuration options
					 * available for the listbox */
    Tk_OptionTable itemAttrOptionTable;	/* Table definining configuration
					 * options available for listbox
					 * items */
} ListboxOptionTables;

/*
 * A data structure of the following type is kept for each listbox
 * widget managed by this file:
 */

typedef struct {
    Tk_Window tkwin;		/* Window that embodies the listbox.  NULL
				 * means that the window has been destroyed
				 * but the data structures haven't yet been
				 * cleaned up.*/
    Display *display;		/* Display containing widget.  Used, among
				 * other things, so that resources can be
				 * freed even after tkwin has gone away. */
    Tcl_Interp *interp;		/* Interpreter associated with listbox. */
    Tcl_Command widgetCmd;	/* Token for listbox's widget command. */
    Tk_OptionTable optionTable;	/* Table that defines configuration options
				 * available for this widget. */
    Tk_OptionTable itemAttrOptionTable;	/* Table that defines configuration
					 * options available for listbox
					 * items */
    char *listVarName;          /* List variable name */
    Tcl_Obj *listObj;           /* Pointer to the list object being used */
    int nElements;              /* Holds the current count of elements */
    Tcl_HashTable *selection;   /* Tracks selection */
    Tcl_HashTable *itemAttrTable;	/* Tracks item attributes */

    /*
     * Information used when displaying widget:
     */

    Tk_3DBorder normalBorder;	/* Used for drawing border around whole
				 * window, plus used for background. */
    int borderWidth;		/* Width of 3-D border around window. */
    int relief;			/* 3-D effect: TK_RELIEF_RAISED, etc. */
    int highlightWidth;		/* Width in pixels of highlight to draw
				 * around widget when it has the focus.
				 * <= 0 means don't draw a highlight. */
    XColor *highlightBgColorPtr;
				/* Color for drawing traversal highlight
				 * area when highlight is off. */
    XColor *highlightColorPtr;	/* Color for drawing traversal highlight. */
    int inset;			/* Total width of all borders, including
				 * traversal highlight and 3-D border.
				 * Indicates how much interior stuff must
				 * be offset from outside edges to leave
				 * room for borders. */
    Tk_Font tkfont;		/* Information about text font, or NULL. */
    XColor *fgColorPtr;		/* Text color in normal mode. */
    XColor *dfgColorPtr;	/* Text color in disabled mode. */
    GC textGC;			/* For drawing normal text. */
    Tk_3DBorder selBorder;	/* Borders and backgrounds for selected
				 * elements. */
    int selBorderWidth;		/* Width of border around selection. */
    XColor *selFgColorPtr;	/* Foreground color for selected elements. */
    GC selTextGC;		/* For drawing selected text. */
    int width;			/* Desired width of window, in characters. */
    int height;			/* Desired height of window, in lines. */
    int lineHeight;		/* Number of pixels allocated for each line
				 * in display. */
    int topIndex;		/* Index of top-most element visible in
				 * window. */
    int fullLines;		/* Number of lines that fit are completely
				 * visible in window.  There may be one
				 * additional line at the bottom that is
				 * partially visible. */
    int partialLine;		/* 0 means that the window holds exactly
				 * fullLines lines.  1 means that there is
				 * one additional line that is partially
				 * visble. */
    int setGrid;		/* Non-zero means pass gridding information
				 * to window manager. */

    /*
     * Information to support horizontal scrolling:
     */

    int maxWidth;		/* Width (in pixels) of widest string in
				 * listbox. */
    int xScrollUnit;		/* Number of pixels in one "unit" for
				 * horizontal scrolling (window scrolls
				 * horizontally in increments of this size).
				 * This is an average character size. */
    int xOffset;		/* The left edge of each string in the
				 * listbox is offset to the left by this
				 * many pixels (0 means no offset, positive
				 * means there is an offset). */

    /*
     * Information about what's selected or active, if any.
     */

    Tk_Uid selectMode;		/* Selection style: single, browse, multiple,
				 * or extended.  This value isn't used in C
				 * code, but the Tcl bindings use it. */
    int numSelected;		/* Number of elements currently selected. */
    int selectAnchor;		/* Fixed end of selection (i.e. element
				 * at which selection was started.) */
    int exportSelection;	/* Non-zero means tie internal listbox
				 * to X selection. */
    int active;			/* Index of "active" element (the one that
				 * has been selected by keyboard traversal).
				 * -1 means none. */
    int activeStyle;		/* style in which to draw the active element.
				 * One of: underline, none, dotbox */

    /*
     * Information for scanning:
     */

    int scanMarkX;		/* X-position at which scan started (e.g.
				 * button was pressed here). */
    int scanMarkY;		/* Y-position at which scan started (e.g.
				 * button was pressed here). */
    int scanMarkXOffset;	/* Value of "xOffset" field when scan
				 * started. */
    int scanMarkYIndex;		/* Index of line that was at top of window
				 * when scan started. */

    /*
     * Miscellaneous information:
     */

    Tk_Cursor cursor;		/* Current cursor for window, or None. */
    char *takeFocus;		/* Value of -takefocus option;  not used in
				 * the C code, but used by keyboard traversal
				 * scripts.  Malloc'ed, but may be NULL. */
    char *yScrollCmd;		/* Command prefix for communicating with
				 * vertical scrollbar.  NULL means no command
				 * to issue.  Malloc'ed. */
    char *xScrollCmd;		/* Command prefix for communicating with
				 * horizontal scrollbar.  NULL means no command
				 * to issue.  Malloc'ed. */
    int state;			/* Listbox state. */
    Pixmap gray;		/* Pixmap for displaying disabled text. */
    int flags;			/* Various flag bits:  see below for
				 * definitions. */
} Listbox;

/*
 * ItemAttr structures are used to store item configuration information for
 * the items in a listbox
 */
typedef struct {
    Tk_3DBorder border;		/* Used for drawing background around text */
    Tk_3DBorder selBorder;	/* Used for selected text */
    XColor *fgColor;		/* Text color in normal mode. */
    XColor *selFgColor;		/* Text color in selected mode. */
} ItemAttr;    

/*
 * Flag bits for listboxes:
 *
 * REDRAW_PENDING:		Non-zero means a DoWhenIdle handler
 *				has already been queued to redraw
 *				this window.
 * UPDATE_V_SCROLLBAR:		Non-zero means vertical scrollbar needs
 *				to be updated.
 * UPDATE_H_SCROLLBAR:		Non-zero means horizontal scrollbar needs
 *				to be updated.
 * GOT_FOCUS:			Non-zero means this widget currently
 *				has the input focus.
 * MAXWIDTH_IS_STALE:           Stored maxWidth may be out-of-date
 * LISTBOX_DELETED:		This listbox has been effectively destroyed.
 */

#define REDRAW_PENDING		1
#define UPDATE_V_SCROLLBAR	2
#define UPDATE_H_SCROLLBAR	4
#define GOT_FOCUS		8
#define MAXWIDTH_IS_STALE	16
#define LISTBOX_DELETED		32

/*
 * The following enum is used to define a type for the -state option
 * of the Entry widget.  These values are used as indices into the 
 * string table below.
 */

enum state {
    STATE_DISABLED, STATE_NORMAL
};

static char *stateStrings[] = {
    "disabled", "normal", (char *) NULL
};

enum activeStyle {
    ACTIVE_STYLE_DOTBOX, ACTIVE_STYLE_NONE, ACTIVE_STYLE_UNDERLINE
};

static char *activeStyleStrings[] = {
    "dotbox", "none", "underline", (char *) NULL
};

/*
 * The optionSpecs table defines the valid configuration options for the
 * listbox widget
 */
static Tk_OptionSpec optionSpecs[] = {
    {TK_OPTION_STRING_TABLE, "-activestyle", "activeStyle", "ActiveStyle",
	DEF_LISTBOX_ACTIVE_STYLE, -1, Tk_Offset(Listbox, activeStyle),
        0, (ClientData) activeStyleStrings, 0},
    {TK_OPTION_BORDER, "-background", "background", "Background",
	 DEF_LISTBOX_BG_COLOR, -1, Tk_Offset(Listbox, normalBorder),
	 0, (ClientData) DEF_LISTBOX_BG_MONO, 0},
    {TK_OPTION_SYNONYM, "-bd", (char *) NULL, (char *) NULL,
	 (char *) NULL, 0, -1, 0, (ClientData) "-borderwidth", 0},
    {TK_OPTION_SYNONYM, "-bg", (char *) NULL, (char *) NULL,
	 (char *) NULL, 0, -1, 0, (ClientData) "-background", 0},
    {TK_OPTION_PIXELS, "-borderwidth", "borderWidth", "BorderWidth",
	 DEF_LISTBOX_BORDER_WIDTH, -1, Tk_Offset(Listbox, borderWidth),
	 0, 0, 0},
    {TK_OPTION_CURSOR, "-cursor", "cursor", "Cursor",
	 DEF_LISTBOX_CURSOR, -1, Tk_Offset(Listbox, cursor),
	 TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_COLOR, "-disabledforeground", "disabledForeground",
	 "DisabledForeground", DEF_LISTBOX_DISABLED_FG, -1,
	 Tk_Offset(Listbox, dfgColorPtr), TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_BOOLEAN, "-exportselection", "exportSelection",
	 "ExportSelection", DEF_LISTBOX_EXPORT_SELECTION, -1,
	 Tk_Offset(Listbox, exportSelection), 0, 0, 0},
    {TK_OPTION_SYNONYM, "-fg", "foreground", (char *) NULL,
	 (char *) NULL, 0, -1, 0, (ClientData) "-foreground", 0},
    {TK_OPTION_FONT, "-font", "font", "Font",
	 DEF_LISTBOX_FONT, -1, Tk_Offset(Listbox, tkfont), 0, 0, 0},
    {TK_OPTION_COLOR, "-foreground", "foreground", "Foreground",
	 DEF_LISTBOX_FG, -1, Tk_Offset(Listbox, fgColorPtr), 0, 0, 0},
    {TK_OPTION_INT, "-height", "height", "Height",
	 DEF_LISTBOX_HEIGHT, -1, Tk_Offset(Listbox, height), 0, 0, 0},
    {TK_OPTION_COLOR, "-highlightbackground", "highlightBackground",
	 "HighlightBackground", DEF_LISTBOX_HIGHLIGHT_BG, -1, 
	 Tk_Offset(Listbox, highlightBgColorPtr), 0, 0, 0},
    {TK_OPTION_COLOR, "-highlightcolor", "highlightColor", "HighlightColor",
	 DEF_LISTBOX_HIGHLIGHT, -1, Tk_Offset(Listbox, highlightColorPtr),
	 0, 0, 0},
    {TK_OPTION_PIXELS, "-highlightthickness", "highlightThickness",
	 "HighlightThickness", DEF_LISTBOX_HIGHLIGHT_WIDTH, -1,
	 Tk_Offset(Listbox, highlightWidth), 0, 0, 0},
    {TK_OPTION_RELIEF, "-relief", "relief", "Relief",
	 DEF_LISTBOX_RELIEF, -1, Tk_Offset(Listbox, relief), 0, 0, 0},
    {TK_OPTION_BORDER, "-selectbackground", "selectBackground", "Foreground",
	 DEF_LISTBOX_SELECT_COLOR, -1, Tk_Offset(Listbox, selBorder),
	 0, (ClientData) DEF_LISTBOX_SELECT_MONO, 0},
    {TK_OPTION_PIXELS, "-selectborderwidth", "selectBorderWidth",
	 "BorderWidth", DEF_LISTBOX_SELECT_BD, -1,
	 Tk_Offset(Listbox, selBorderWidth), 0, 0, 0},
    {TK_OPTION_COLOR, "-selectforeground", "selectForeground", "Background",
	 DEF_LISTBOX_SELECT_FG_COLOR, -1, Tk_Offset(Listbox, selFgColorPtr),
	 0, (ClientData) DEF_LISTBOX_SELECT_FG_MONO, 0},
    {TK_OPTION_STRING, "-selectmode", "selectMode", "SelectMode",
	 DEF_LISTBOX_SELECT_MODE, -1, Tk_Offset(Listbox, selectMode),
	 TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_BOOLEAN, "-setgrid", "setGrid", "SetGrid",
	 DEF_LISTBOX_SET_GRID, -1, Tk_Offset(Listbox, setGrid), 0, 0, 0},
    {TK_OPTION_STRING_TABLE, "-state", "state", "State",
	DEF_LISTBOX_STATE, -1, Tk_Offset(Listbox, state), 
        0, (ClientData) stateStrings, 0},
    {TK_OPTION_STRING, "-takefocus", "takeFocus", "TakeFocus",
	 DEF_LISTBOX_TAKE_FOCUS, -1, Tk_Offset(Listbox, takeFocus),
	 TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_INT, "-width", "width", "Width",
	 DEF_LISTBOX_WIDTH, -1, Tk_Offset(Listbox, width), 0, 0, 0},
    {TK_OPTION_STRING, "-xscrollcommand", "xScrollCommand", "ScrollCommand",
	 DEF_LISTBOX_SCROLL_COMMAND, -1, Tk_Offset(Listbox, xScrollCmd),
	 TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_STRING, "-yscrollcommand", "yScrollCommand", "ScrollCommand",
	 DEF_LISTBOX_SCROLL_COMMAND, -1, Tk_Offset(Listbox, yScrollCmd),
	 TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_STRING, "-listvariable", "listVariable", "Variable",
	 DEF_LISTBOX_LIST_VARIABLE, -1, Tk_Offset(Listbox, listVarName),
	 TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_END, (char *) NULL, (char *) NULL, (char *) NULL,
	 (char *) NULL, 0, -1, 0, 0, 0}
};

/*
 * The itemAttrOptionSpecs table defines the valid configuration options for
 * listbox items
 */
static Tk_OptionSpec itemAttrOptionSpecs[] = {
    {TK_OPTION_BORDER, "-background", "background", "Background",
     (char *)NULL, -1, Tk_Offset(ItemAttr, border),
     TK_OPTION_NULL_OK|TK_OPTION_DONT_SET_DEFAULT,
     (ClientData) DEF_LISTBOX_BG_MONO, 0},
    {TK_OPTION_SYNONYM, "-bg", (char *) NULL, (char *) NULL,
     (char *) NULL, 0, -1, 0, (ClientData) "-background", 0},
    {TK_OPTION_SYNONYM, "-fg", "foreground", (char *) NULL,
     (char *) NULL, 0, -1, 0, (ClientData) "-foreground", 0},
    {TK_OPTION_COLOR, "-foreground", "foreground", "Foreground",
     (char *) NULL, -1, Tk_Offset(ItemAttr, fgColor),
     TK_OPTION_NULL_OK|TK_OPTION_DONT_SET_DEFAULT, 0, 0},
    {TK_OPTION_BORDER, "-selectbackground", "selectBackground", "Foreground",
     (char *) NULL, -1, Tk_Offset(ItemAttr, selBorder),
     TK_OPTION_NULL_OK|TK_OPTION_DONT_SET_DEFAULT,
     (ClientData) DEF_LISTBOX_SELECT_MONO, 0},
    {TK_OPTION_COLOR, "-selectforeground", "selectForeground", "Background",
     (char *) NULL, -1, Tk_Offset(ItemAttr, selFgColor),
     TK_OPTION_NULL_OK|TK_OPTION_DONT_SET_DEFAULT,
     (ClientData) DEF_LISTBOX_SELECT_FG_MONO, 0},
    {TK_OPTION_END, (char *) NULL, (char *) NULL, (char *) NULL,
     (char *) NULL, 0, -1, 0, 0, 0}
};

/*
 * The following tables define the listbox widget commands (and sub-
 * commands) and map the indexes into the string tables into 
 * enumerated types used to dispatch the listbox widget command.
 */
static CONST char *commandNames[] = {
    "activate", "bbox", "cget", "configure", "curselection", "delete", "get",
    "index", "insert", "itemcget", "itemconfigure", "nearest", "scan",
    "see", "selection", "size", "xview", "yview",
    (char *) NULL
};

enum command {
    COMMAND_ACTIVATE, COMMAND_BBOX, COMMAND_CGET, COMMAND_CONFIGURE,
    COMMAND_CURSELECTION, COMMAND_DELETE, COMMAND_GET, COMMAND_INDEX,
    COMMAND_INSERT, COMMAND_ITEMCGET, COMMAND_ITEMCONFIGURE,
    COMMAND_NEAREST, COMMAND_SCAN, COMMAND_SEE, COMMAND_SELECTION,
    COMMAND_SIZE, COMMAND_XVIEW, COMMAND_YVIEW
};

static CONST char *selCommandNames[] = {
    "anchor", "clear", "includes", "set", (char *) NULL
};

enum selcommand {
    SELECTION_ANCHOR, SELECTION_CLEAR, SELECTION_INCLUDES, SELECTION_SET
};

static CONST char *scanCommandNames[] = {
    "mark", "dragto", (char *) NULL
};

enum scancommand {
    SCAN_MARK, SCAN_DRAGTO
};

static CONST char *indexNames[] = {
    "active", "anchor", "end", (char *)NULL
};

enum indices {
    INDEX_ACTIVE, INDEX_ANCHOR, INDEX_END
};


/* Declarations for procedures defined later in this file */
static void		ChangeListboxOffset _ANSI_ARGS_((Listbox *listPtr,
			    int offset));
static void		ChangeListboxView _ANSI_ARGS_((Listbox *listPtr,
			    int index));
static int		ConfigureListbox _ANSI_ARGS_((Tcl_Interp *interp,
			    Listbox *listPtr, int objc, Tcl_Obj *CONST objv[],
			    int flags));
static int		ConfigureListboxItem _ANSI_ARGS_ ((Tcl_Interp *interp,
			    Listbox *listPtr, ItemAttr *attrs, int objc,
			    Tcl_Obj *CONST objv[]));
static int		ListboxDeleteSubCmd _ANSI_ARGS_((Listbox *listPtr,
			    int first, int last));
static void		DestroyListbox _ANSI_ARGS_((char *memPtr));
static void		DestroyListboxOptionTables _ANSI_ARGS_ (
			    (ClientData clientData, Tcl_Interp *interp));
static void		DisplayListbox _ANSI_ARGS_((ClientData clientData));
static int		GetListboxIndex _ANSI_ARGS_((Tcl_Interp *interp,
			    Listbox *listPtr, Tcl_Obj *index, int endIsSize,
			    int *indexPtr));
static int		ListboxInsertSubCmd _ANSI_ARGS_((Listbox *listPtr,
			    int index, int objc, Tcl_Obj *CONST objv[]));
static void		ListboxCmdDeletedProc _ANSI_ARGS_((
			    ClientData clientData));
static void		ListboxComputeGeometry _ANSI_ARGS_((Listbox *listPtr,
			    int fontChanged, int maxIsStale, int updateGrid));
static void		ListboxEventProc _ANSI_ARGS_((ClientData clientData,
			    XEvent *eventPtr));
static int		ListboxFetchSelection _ANSI_ARGS_((
			    ClientData clientData, int offset, char *buffer,
			    int maxBytes));
static void		ListboxLostSelection _ANSI_ARGS_((
			    ClientData clientData));
static void		EventuallyRedrawRange _ANSI_ARGS_((Listbox *listPtr,
			    int first, int last));
static void		ListboxScanTo _ANSI_ARGS_((Listbox *listPtr,
			    int x, int y));
static int		ListboxSelect _ANSI_ARGS_((Listbox *listPtr,
			    int first, int last, int select));
static void		ListboxUpdateHScrollbar _ANSI_ARGS_(
    			    (Listbox *listPtr));
static void		ListboxUpdateVScrollbar _ANSI_ARGS_(
			    (Listbox *listPtr));
static int		ListboxWidgetObjCmd _ANSI_ARGS_((ClientData clientData,
	                    Tcl_Interp *interp, int objc,
	                    Tcl_Obj *CONST objv[]));
static int		ListboxBboxSubCmd _ANSI_ARGS_ ((Tcl_Interp *interp,
	                    Listbox *listPtr, int index));
static int		ListboxSelectionSubCmd _ANSI_ARGS_ (
			    (Tcl_Interp *interp, Listbox *listPtr, int objc,
			    Tcl_Obj *CONST objv[]));
static int		ListboxXviewSubCmd _ANSI_ARGS_ ((Tcl_Interp *interp,
			    Listbox *listPtr, int objc,
			    Tcl_Obj *CONST objv[]));
static int		ListboxYviewSubCmd _ANSI_ARGS_ ((Tcl_Interp *interp,
			    Listbox *listPtr, int objc,
			    Tcl_Obj *CONST objv[]));
static ItemAttr *	ListboxGetItemAttributes _ANSI_ARGS_ (
    			    (Tcl_Interp *interp, Listbox *listPtr, int index));
static void		ListboxWorldChanged _ANSI_ARGS_((
			    ClientData instanceData));
static int		NearestListboxElement _ANSI_ARGS_((Listbox *listPtr,
			    int y));
static char *		ListboxListVarProc _ANSI_ARGS_ ((ClientData clientData,
	                    Tcl_Interp *interp, CONST char *name1,
			    CONST char *name2, int flags));
static void		MigrateHashEntries _ANSI_ARGS_ ((Tcl_HashTable *table,
			    int first, int last, int offset));
/*
 * The structure below defines button class behavior by means of procedures
 * that can be invoked from generic window code.
 */

static Tk_ClassProcs listboxClass = {
    sizeof(Tk_ClassProcs),	/* size */
    ListboxWorldChanged,	/* worldChangedProc */
};


/*
 *--------------------------------------------------------------
 *
 * Tk_ListboxObjCmd --
 *
 *	This procedure is invoked to process the "listbox" Tcl
 *	command.  See the user documentation for details on what
 *	it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *--------------------------------------------------------------
 */

int
Tk_ListboxObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* NULL. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    register Listbox *listPtr;
    Tk_Window tkwin;
    ListboxOptionTables *optionTables;

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "pathName ?options?");
	return TCL_ERROR;
    }

    tkwin = Tk_CreateWindowFromPath(interp, Tk_MainWindow(interp),
	    Tcl_GetString(objv[1]), (char *) NULL);
    if (tkwin == NULL) {
	return TCL_ERROR;
    }

    optionTables = (ListboxOptionTables *)
	Tcl_GetAssocData(interp, "ListboxOptionTables", NULL);
    if (optionTables == NULL) {
	/*
	 * We haven't created the option tables for this widget class yet.
	 * Do it now and save the a pointer to them as the ClientData for
	 * the command, so future invocations will have access to it.
	 */

	optionTables = (ListboxOptionTables *)
	    ckalloc(sizeof(ListboxOptionTables));
	/* Set up an exit handler to free the optionTables struct */
	Tcl_SetAssocData(interp, "ListboxOptionTables",
		DestroyListboxOptionTables, (ClientData) optionTables);

	/* Create the listbox option table and the listbox item option table */
	optionTables->listboxOptionTable =
	    Tk_CreateOptionTable(interp, optionSpecs);
	optionTables->itemAttrOptionTable =
	    Tk_CreateOptionTable(interp, itemAttrOptionSpecs);
    }

    /*
     * Initialize the fields of the structure that won't be initialized
     * by ConfigureListbox, or that ConfigureListbox requires to be
     * initialized already (e.g. resource pointers).
     */
    listPtr 				= (Listbox *) ckalloc(sizeof(Listbox));
    memset((void *) listPtr, 0, (sizeof(Listbox)));

    listPtr->tkwin 			= tkwin;
    listPtr->display 			= Tk_Display(tkwin);
    listPtr->interp 			= interp;
    listPtr->widgetCmd 			= Tcl_CreateObjCommand(interp,
	    Tk_PathName(listPtr->tkwin), ListboxWidgetObjCmd,
	    (ClientData) listPtr, ListboxCmdDeletedProc);
    listPtr->optionTable 		= optionTables->listboxOptionTable;
    listPtr->itemAttrOptionTable	= optionTables->itemAttrOptionTable;
    listPtr->selection 			=
	(Tcl_HashTable *) ckalloc(sizeof(Tcl_HashTable));
    Tcl_InitHashTable(listPtr->selection, TCL_ONE_WORD_KEYS);
    listPtr->itemAttrTable 		=
	(Tcl_HashTable *) ckalloc(sizeof(Tcl_HashTable));
    Tcl_InitHashTable(listPtr->itemAttrTable, TCL_ONE_WORD_KEYS);
    listPtr->relief 			= TK_RELIEF_RAISED;
    listPtr->textGC 			= None;
    listPtr->selFgColorPtr 		= None;
    listPtr->selTextGC 			= None;
    listPtr->fullLines 			= 1;
    listPtr->xScrollUnit 		= 1;
    listPtr->exportSelection 		= 1;
    listPtr->cursor 			= None;
    listPtr->state			= STATE_NORMAL;
    listPtr->gray			= None;

    /*
     * Keep a hold of the associated tkwin until we destroy the listbox,
     * otherwise Tk might free it while we still need it.
     */

    Tcl_Preserve((ClientData) listPtr->tkwin);

    Tk_SetClass(listPtr->tkwin, "Listbox");
    Tk_SetClassProcs(listPtr->tkwin, &listboxClass, (ClientData) listPtr);
    Tk_CreateEventHandler(listPtr->tkwin,
	    ExposureMask|StructureNotifyMask|FocusChangeMask,
	    ListboxEventProc, (ClientData) listPtr);
    Tk_CreateSelHandler(listPtr->tkwin, XA_PRIMARY, XA_STRING,
	    ListboxFetchSelection, (ClientData) listPtr, XA_STRING);
    if (Tk_InitOptions(interp, (char *)listPtr,
	    optionTables->listboxOptionTable, tkwin) != TCL_OK) {
	Tk_DestroyWindow(listPtr->tkwin);
	return TCL_ERROR;
    }

    if (ConfigureListbox(interp, listPtr, objc-2, objv+2, 0) != TCL_OK) {
	Tk_DestroyWindow(listPtr->tkwin);
	return TCL_ERROR;
    }

    Tcl_SetResult(interp, Tk_PathName(listPtr->tkwin), TCL_STATIC);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ListboxWidgetObjCmd --
 *
 *	This Tcl_Obj based procedure is invoked to process the Tcl command
 *      that corresponds to a widget managed by this module.  See the user
 *      documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

static int
ListboxWidgetObjCmd(clientData, interp, objc, objv)
    ClientData clientData;		/* Information about listbox widget. */
    Tcl_Interp *interp;			/* Current interpreter. */
    int objc;				/* Number of arguments. */
    Tcl_Obj *CONST objv[];		/* Arguments as Tcl_Obj's. */
{
    register Listbox *listPtr = (Listbox *) clientData;
    int cmdIndex, index;
    int result = TCL_OK;
    
    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "option ?arg arg ...?");
	return TCL_ERROR;
    }

    /*
     * Parse the command by looking up the second argument in the list
     * of valid subcommand names
     */
    result = Tcl_GetIndexFromObj(interp, objv[1], commandNames,
	    "option", 0, &cmdIndex);
    if (result != TCL_OK) {
	return result;
    }

    Tcl_Preserve((ClientData)listPtr);
    /* The subcommand was valid, so continue processing */
    switch (cmdIndex) {
	case COMMAND_ACTIVATE: {
	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "index");
		result = TCL_ERROR;
		break;
	    }
	    result = GetListboxIndex(interp, listPtr, objv[2], 0, &index);
	    if (result != TCL_OK) {
		break;
	    }

	    if (!(listPtr->state & STATE_NORMAL)) {
		break;
	    }

	    if (index >= listPtr->nElements) {
		index = listPtr->nElements-1;
	    }
	    if (index < 0) {
		index = 0;
	    }
	    listPtr->active = index;
	    EventuallyRedrawRange(listPtr, listPtr->active, listPtr->active);
	    result = TCL_OK;
	    break;
	}

	case COMMAND_BBOX: {
	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "index");
		result = TCL_ERROR;
		break;
	    }
	    result = GetListboxIndex(interp, listPtr, objv[2], 0, &index);
	    if (result != TCL_OK) {
		break;
	    }
	    
	    result = ListboxBboxSubCmd(interp, listPtr, index);
	    break;
	}

	case COMMAND_CGET: {
	    Tcl_Obj *objPtr;
	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "option");
		result = TCL_ERROR;
		break;
	    }

	    objPtr = Tk_GetOptionValue(interp, (char *)listPtr,
		    listPtr->optionTable, objv[2], listPtr->tkwin);
	    if (objPtr == NULL) {
		result = TCL_ERROR;
		break;
	    }
	    Tcl_SetObjResult(interp, objPtr);
	    result = TCL_OK;
	    break;
	}
	
	case COMMAND_CONFIGURE: {
	    Tcl_Obj *objPtr;
	    if (objc <= 3) {
		objPtr = Tk_GetOptionInfo(interp, (char *) listPtr,
			listPtr->optionTable,
			(objc == 3) ? objv[2] : (Tcl_Obj *) NULL,
			listPtr->tkwin);
		if (objPtr == NULL) {
		    result = TCL_ERROR;
		    break;
		} else {
		    Tcl_SetObjResult(interp, objPtr);
		    result = TCL_OK;
		}
	    } else {
		result = ConfigureListbox(interp, listPtr, objc-2, objv+2, 0);
	    }
	    break;
	}

	case COMMAND_CURSELECTION: {
	    char indexStringRep[TCL_INTEGER_SPACE];
	    int i;
	    if (objc != 2) {
		Tcl_WrongNumArgs(interp, 2, objv, NULL);
		result = TCL_ERROR;
		break;
	    }
	    /*
	     * Of course, it would be more efficient to use the Tcl_HashTable
	     * search functions (Tcl_FirstHashEntry, Tcl_NextHashEntry), but
	     * then the result wouldn't be in sorted order.  So instead we
	     * loop through the indices in order, adding them to the result
	     * if they are selected
	     */
	    for (i = 0; i < listPtr->nElements; i++) {
		if (Tcl_FindHashEntry(listPtr->selection, (char *)i) != NULL) {
		    sprintf(indexStringRep, "%d", i);
		    Tcl_AppendElement(interp, indexStringRep);
		}
	    }
	    result = TCL_OK;
	    break;
	}
	
	case COMMAND_DELETE: {
	    int first, last;
	    if ((objc < 3) || (objc > 4)) {
		Tcl_WrongNumArgs(interp, 2, objv,
			"firstIndex ?lastIndex?");
		result = TCL_ERROR;
		break;
	    }

	    result = GetListboxIndex(interp, listPtr, objv[2], 0, &first);
	    if (result != TCL_OK) {
		break;
	    }

	    if (!(listPtr->state & STATE_NORMAL)) {
		break;
	    }

	    if (first < listPtr->nElements) {
		/*
		 * if a "last index" was given, get it now; otherwise, use the
		 * first index as the last index
		 */
		if (objc == 4) {
		    result = GetListboxIndex(interp, listPtr,
			    objv[3], 0, &last);
		    if (result != TCL_OK) {
			break;
		    }
		} else {
		    last = first;
		}
		if (last >= listPtr->nElements) {
		    last = listPtr->nElements - 1;
		}
		result = ListboxDeleteSubCmd(listPtr, first, last);
	    } else {
		result = TCL_OK;
	    }
	    break;
	}

	case COMMAND_GET: {
	    int first, last;
	    Tcl_Obj **elemPtrs;
	    int listLen;
	    if (objc != 3 && objc != 4) {
		Tcl_WrongNumArgs(interp, 2, objv, "firstIndex ?lastIndex?");
		result = TCL_ERROR;
		break;
	    }
	    result = GetListboxIndex(interp, listPtr, objv[2], 0, &first);
	    if (result != TCL_OK) {
		break;
	    }
	    last = first;
	    if (objc == 4) {
		result = GetListboxIndex(interp, listPtr, objv[3], 0, &last);
		if (result != TCL_OK) {
		    break;
		}
	    }
	    if (first >= listPtr->nElements) {
		result = TCL_OK;
		break;
	    }
	    if (last >= listPtr->nElements) {
		last = listPtr->nElements - 1;
	    }
	    if (first < 0) {
		first = 0;
	    }
	    if (first > last) {
		result = TCL_OK;
		break;
	    }
	    result = Tcl_ListObjGetElements(interp, listPtr->listObj, &listLen,
		    &elemPtrs);
	    if (result != TCL_OK) {
		break;
	    }
	    if (objc == 3) {
		/*
		 * One element request - we return a string
		 */
		Tcl_SetObjResult(interp, elemPtrs[first]);
	    } else {
		Tcl_SetListObj(Tcl_GetObjResult(interp), (last - first + 1),
			&(elemPtrs[first]));
	    }
	    result = TCL_OK;
	    break;
	}

	case COMMAND_INDEX:{
	    char buf[TCL_INTEGER_SPACE];
	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "index");
		result = TCL_ERROR;
		break;
	    }
	    result = GetListboxIndex(interp, listPtr, objv[2], 1, &index);
	    if (result != TCL_OK) {
		break;
	    }
	    sprintf(buf, "%d", index);
	    Tcl_SetResult(interp, buf, TCL_VOLATILE);
	    result = TCL_OK;
	    break;
	}

	case COMMAND_INSERT: {
	    if (objc < 3) {
		Tcl_WrongNumArgs(interp, 2, objv,
			"index ?element element ...?");
		result = TCL_ERROR;
		break;
	    }

	    result = GetListboxIndex(interp, listPtr, objv[2], 1, &index);
	    if (result != TCL_OK) {
		break;
	    }

	    if (!(listPtr->state & STATE_NORMAL)) {
		break;
	    }

	    result = ListboxInsertSubCmd(listPtr, index, objc-3, objv+3);
	    break;
	}

	case COMMAND_ITEMCGET: {
	    Tcl_Obj *objPtr;
	    ItemAttr *attrPtr;
	    if (objc != 4) {
		Tcl_WrongNumArgs(interp, 2, objv, "index option");
		result = TCL_ERROR;
		break;
	    }

	    result = GetListboxIndex(interp, listPtr, objv[2], 0, &index);
	    if (result != TCL_OK) {
		break;
	    }

	    if (index < 0 || index >= listPtr->nElements) {
		Tcl_AppendResult(interp, "item number \"",
			Tcl_GetString(objv[2]), "\" out of range",
			(char *)NULL);
		result = TCL_ERROR;
		break;
	    }
	    
	    attrPtr = ListboxGetItemAttributes(interp, listPtr, index);

	    objPtr = Tk_GetOptionValue(interp, (char *)attrPtr,
		    listPtr->itemAttrOptionTable, objv[3], listPtr->tkwin);
	    if (objPtr == NULL) {
		result = TCL_ERROR;
		break;
	    }
	    Tcl_SetObjResult(interp, objPtr);
	    result = TCL_OK;
	    break;
	}

	case COMMAND_ITEMCONFIGURE: {
	    Tcl_Obj *objPtr;
	    ItemAttr *attrPtr;
	    if (objc < 3) {
		Tcl_WrongNumArgs(interp, 2, objv,
			"index ?option? ?value? ?option value ...?");
		result = TCL_ERROR;
		break;
	    }

	    result = GetListboxIndex(interp, listPtr, objv[2], 0, &index);
	    if (result != TCL_OK) {
		break;
	    }
	    
	    if (index < 0 || index >= listPtr->nElements) {
		Tcl_AppendResult(interp, "item number \"",
			Tcl_GetString(objv[2]), "\" out of range",
			(char *)NULL);
		result = TCL_ERROR;
		break;
	    }
	    
	    attrPtr = ListboxGetItemAttributes(interp, listPtr, index);
	    if (objc <= 4) {
		objPtr = Tk_GetOptionInfo(interp, (char *)attrPtr,
			listPtr->itemAttrOptionTable,
			(objc == 4) ? objv[3] : (Tcl_Obj *) NULL,
			listPtr->tkwin);
		if (objPtr == NULL) {
		    result = TCL_ERROR;
		    break;
		} else {
		    Tcl_SetObjResult(interp, objPtr);
		    result = TCL_OK;
		}
	    } else {
		result = ConfigureListboxItem(interp, listPtr, attrPtr,
			objc-3, objv+3);
	    }
	    break;
	}
	
	case COMMAND_NEAREST: {
	    char buf[TCL_INTEGER_SPACE];
	    int y;
	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "y");
		result = TCL_ERROR;
		break;
	    }
	    
	    result = Tcl_GetIntFromObj(interp, objv[2], &y);
	    if (result != TCL_OK) {
		break;
	    }
	    index = NearestListboxElement(listPtr, y);
	    sprintf(buf, "%d", index);
	    Tcl_SetResult(interp, buf, TCL_VOLATILE);
	    result = TCL_OK;
	    break;
	}
	
	case COMMAND_SCAN: {
	    int x, y, scanCmdIndex;

	    if (objc != 5) {
		Tcl_WrongNumArgs(interp, 2, objv, "mark|dragto x y");
		result = TCL_ERROR;
		break;
	    }

	    if (Tcl_GetIntFromObj(interp, objv[3], &x) != TCL_OK
		    || Tcl_GetIntFromObj(interp, objv[4], &y) != TCL_OK) {
		result = TCL_ERROR;
		break;
	    }

	    result = Tcl_GetIndexFromObj(interp, objv[2], scanCommandNames,
		    "option", 0, &scanCmdIndex);
	    if (result != TCL_OK) {
		break;
	    }
	    switch (scanCmdIndex) {
		case SCAN_MARK: {
		    listPtr->scanMarkX = x;
		    listPtr->scanMarkY = y;
		    listPtr->scanMarkXOffset = listPtr->xOffset;
		    listPtr->scanMarkYIndex = listPtr->topIndex;
		    break;
		}
		case SCAN_DRAGTO: {
		    ListboxScanTo(listPtr, x, y);
		    break;
		}
	    }
	    result = TCL_OK;
	    break;
	}

	case COMMAND_SEE: {
	    int diff;
	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "index");
		result = TCL_ERROR;
		break;
	    }
	    result = GetListboxIndex(interp, listPtr, objv[2], 0, &index);
	    if (result != TCL_OK) {
		break;
	    }
	    if (index >= listPtr->nElements) {
		index = listPtr->nElements - 1;
	    }
	    if (index < 0) {
		index = 0;
	    }
	    diff = listPtr->topIndex - index;
	    if (diff > 0) {
		if (diff <= (listPtr->fullLines/3)) {
		    ChangeListboxView(listPtr, index);
		} else {
		    ChangeListboxView(listPtr,
			    index - (listPtr->fullLines-1)/2);
		}
	    } else {
		diff = index - (listPtr->topIndex + listPtr->fullLines - 1);
		if (diff > 0) {
		    if (diff <= (listPtr->fullLines/3)) {
			ChangeListboxView(listPtr, listPtr->topIndex + diff);
		    } else {
			ChangeListboxView(listPtr,
				index - (listPtr->fullLines-1)/2);
		    }
		}
	    }
	    result = TCL_OK;
	    break;
	}

	case COMMAND_SELECTION: {
	    if (!(listPtr->state & STATE_NORMAL)) {
		break;
	    }

	    result = ListboxSelectionSubCmd(interp, listPtr, objc, objv);
	    break;
	}
	
	case COMMAND_SIZE: {
	    char buf[TCL_INTEGER_SPACE];
	    if (objc != 2) {
		Tcl_WrongNumArgs(interp, 2, objv, NULL);
		result = TCL_ERROR;
		break;
	    }
	    sprintf(buf, "%d", listPtr->nElements);
	    Tcl_SetResult(interp, buf, TCL_VOLATILE);
	    result = TCL_OK;
	    break;
	}

	case COMMAND_XVIEW: {
	    result = ListboxXviewSubCmd(interp, listPtr, objc, objv);
	    break;
	}
	
	case COMMAND_YVIEW: {
	    result = ListboxYviewSubCmd(interp, listPtr, objc, objv);
	    break;
	}
    }
    Tcl_Release((ClientData)listPtr);
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * ListboxBboxSubCmd --
 *
 *	This procedure is invoked to process a listbox bbox request.
 *      See the user documentation for more information.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	For valid indices, places the bbox of the requested element in
 *      the interpreter's result.
 *
 *----------------------------------------------------------------------
 */

static int
ListboxBboxSubCmd(interp, listPtr, index)
    Tcl_Interp *interp;          /* Pointer to the calling Tcl interpreter */
    Listbox *listPtr;            /* Information about the listbox */
    int index;                   /* Index of the element to get bbox info on */
{
    int lastVisibleIndex;
    /* Determine the index of the last visible item in the listbox */
    lastVisibleIndex = listPtr->topIndex + listPtr->fullLines
	+ listPtr->partialLine;
    if (listPtr->nElements < lastVisibleIndex) {
	lastVisibleIndex = listPtr->nElements;
    }

    /* Only allow bbox requests for indices that are visible */
    if ((listPtr->topIndex <= index) && (index < lastVisibleIndex)) {
	char buf[TCL_INTEGER_SPACE * 4];
	Tcl_Obj *el;
	char *stringRep;
	int pixelWidth, stringLen, x, y, result;
	Tk_FontMetrics fm;

	/* Compute the pixel width of the requested element */
	result = Tcl_ListObjIndex(interp, listPtr->listObj, index, &el);
	if (result != TCL_OK) {
	    return result;
	}

	stringRep = Tcl_GetStringFromObj(el, &stringLen);
	Tk_GetFontMetrics(listPtr->tkfont, &fm);
	pixelWidth = Tk_TextWidth(listPtr->tkfont, stringRep, stringLen);

	x = listPtr->inset + listPtr->selBorderWidth - listPtr->xOffset;
	y = ((index - listPtr->topIndex)*listPtr->lineHeight)
	    + listPtr->inset + listPtr->selBorderWidth;
	sprintf(buf, "%d %d %d %d", x, y, pixelWidth, fm.linespace);
	Tcl_SetResult(interp, buf, TCL_VOLATILE);
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ListboxSelectionSubCmd --
 *
 *	This procedure is invoked to process the selection sub command
 *      for listbox widgets.
 *
 * Results:
 *	Standard Tcl result.
 *
 * Side effects:
 *	May set the interpreter's result field.
 *
 *----------------------------------------------------------------------
 */

static int
ListboxSelectionSubCmd(interp, listPtr, objc, objv)
    Tcl_Interp *interp;          /* Pointer to the calling Tcl interpreter */
    Listbox *listPtr;            /* Information about the listbox */
    int objc;                    /* Number of arguments in the objv array */
    Tcl_Obj *CONST objv[];       /* Array of arguments to the procedure */
{
    int selCmdIndex, first, last;
    int result = TCL_OK;
    if (objc != 4 && objc != 5) {
	Tcl_WrongNumArgs(interp, 2, objv, "option index ?index?");
	return TCL_ERROR;
    }
    result = GetListboxIndex(interp, listPtr, objv[3], 0, &first);
    if (result != TCL_OK) {
	return result;
    }
    last = first;
    if (objc == 5) {
	result = GetListboxIndex(interp, listPtr, objv[4], 0, &last);
	if (result != TCL_OK) {
	    return result;
	}
    }
    result = Tcl_GetIndexFromObj(interp, objv[2], selCommandNames,
	    "option", 0, &selCmdIndex);
    if (result != TCL_OK) {
	return result;
    }
    switch (selCmdIndex) {
	case SELECTION_ANCHOR: {
	    if (objc != 4) {
		Tcl_WrongNumArgs(interp, 3, objv, "index");
		return TCL_ERROR;
	    }
	    if (first >= listPtr->nElements) {
		first = listPtr->nElements - 1;
	    }
	    if (first < 0) {
		first = 0;
	    }
	    listPtr->selectAnchor = first;
	    result = TCL_OK;
	    break;
	}
	case SELECTION_CLEAR: {
	    result = ListboxSelect(listPtr, first, last, 0);
	    break;
	}
	case SELECTION_INCLUDES: {
	    if (objc != 4) {
		Tcl_WrongNumArgs(interp, 3, objv, "index");
		return TCL_ERROR;
	    }
	    if (Tcl_FindHashEntry(listPtr->selection, (char *)first)) {
		Tcl_SetResult(interp, "1", TCL_STATIC);
	    } else {
		Tcl_SetResult(interp, "0", TCL_STATIC);
	    }
	    result = TCL_OK;
	    break;
	}
	case SELECTION_SET: {
	    result = ListboxSelect(listPtr, first, last, 1);
	    break;
	}
    }
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * ListboxXviewSubCmd --
 *
 *	Process the listbox "xview" subcommand.
 *
 * Results:
 *	Standard Tcl result.
 *
 * Side effects:
 *	May change the listbox viewing area; may set the interpreter's result.
 *
 *----------------------------------------------------------------------
 */

static int
ListboxXviewSubCmd(interp, listPtr, objc, objv)
    Tcl_Interp *interp;          /* Pointer to the calling Tcl interpreter */
    Listbox *listPtr;            /* Information about the listbox */
    int objc;                    /* Number of arguments in the objv array */
    Tcl_Obj *CONST objv[];       /* Array of arguments to the procedure */
{

    int index, count, type, windowWidth, windowUnits;
    int offset = 0;		/* Initialized to stop gcc warnings. */
    double fraction, fraction2;
    
    windowWidth = Tk_Width(listPtr->tkwin)
	- 2*(listPtr->inset + listPtr->selBorderWidth);
    if (objc == 2) {
	if (listPtr->maxWidth == 0) {
	    Tcl_SetResult(interp, "0 1", TCL_STATIC);
	} else {
	    char buf[TCL_DOUBLE_SPACE * 2];
	    
	    fraction = listPtr->xOffset/((double) listPtr->maxWidth);
	    fraction2 = (listPtr->xOffset + windowWidth)
		/((double) listPtr->maxWidth);
	    if (fraction2 > 1.0) {
		fraction2 = 1.0;
	    }
	    sprintf(buf, "%g %g", fraction, fraction2);
	    Tcl_SetResult(interp, buf, TCL_VOLATILE);
	}
    } else if (objc == 3) {
	if (Tcl_GetIntFromObj(interp, objv[2], &index) != TCL_OK) {
	    return TCL_ERROR;
	}
	ChangeListboxOffset(listPtr, index*listPtr->xScrollUnit);
    } else {
	type = Tk_GetScrollInfoObj(interp, objc, objv, &fraction, &count);
	switch (type) {
	    case TK_SCROLL_ERROR:
		return TCL_ERROR;
	    case TK_SCROLL_MOVETO:
		offset = (int) (fraction*listPtr->maxWidth + 0.5);
		break;
	    case TK_SCROLL_PAGES:
		windowUnits = windowWidth/listPtr->xScrollUnit;
		if (windowUnits > 2) {
		    offset = listPtr->xOffset
			+ count*listPtr->xScrollUnit*(windowUnits-2);
		} else {
		    offset = listPtr->xOffset + count*listPtr->xScrollUnit;
		}
		break;
	    case TK_SCROLL_UNITS:
		offset = listPtr->xOffset + count*listPtr->xScrollUnit;
		break;
	}
	ChangeListboxOffset(listPtr, offset);
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ListboxYviewSubCmd --
 *
 *	Process the listbox "yview" subcommand.
 *
 * Results:
 *	Standard Tcl result.
 *
 * Side effects:
 *	May change the listbox viewing area; may set the interpreter's result.
 *
 *----------------------------------------------------------------------
 */

static int
ListboxYviewSubCmd(interp, listPtr, objc, objv)
    Tcl_Interp *interp;          /* Pointer to the calling Tcl interpreter */
    Listbox *listPtr;            /* Information about the listbox */
    int objc;                    /* Number of arguments in the objv array */
    Tcl_Obj *CONST objv[];       /* Array of arguments to the procedure */
{
    int index, count, type;
    double fraction, fraction2;
    
    if (objc == 2) {
	if (listPtr->nElements == 0) {
	    Tcl_SetResult(interp, "0 1", TCL_STATIC);
	} else {
	    char buf[TCL_DOUBLE_SPACE * 2];
	    
	    fraction = listPtr->topIndex/((double) listPtr->nElements);
	    fraction2 = (listPtr->topIndex+listPtr->fullLines)
		/((double) listPtr->nElements);
	    if (fraction2 > 1.0) {
		fraction2 = 1.0;
	    }
	    sprintf(buf, "%g %g", fraction, fraction2);
	    Tcl_SetResult(interp, buf, TCL_VOLATILE);
	}
    } else if (objc == 3) {
	if (GetListboxIndex(interp, listPtr, objv[2], 0, &index) != TCL_OK) {
	    return TCL_ERROR;
	}
	ChangeListboxView(listPtr, index);
    } else {
	type = Tk_GetScrollInfoObj(interp, objc, objv, &fraction, &count);
	switch (type) {
	    case TK_SCROLL_ERROR:
		return TCL_ERROR;
	    case TK_SCROLL_MOVETO:
		index = (int) (listPtr->nElements*fraction + 0.5);
		break;
	    case TK_SCROLL_PAGES:
		if (listPtr->fullLines > 2) {
		    index = listPtr->topIndex
			+ count*(listPtr->fullLines-2);
		} else {
		    index = listPtr->topIndex + count;
		}
		break;
	    case TK_SCROLL_UNITS:
		index = listPtr->topIndex + count;
		break;
	}
	ChangeListboxView(listPtr, index);
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ListboxGetItemAttributes --
 *
 *	Returns a pointer to the ItemAttr record for a given index,
 *	creating one if it does not already exist.
 *
 * Results:
 *	Pointer to an ItemAttr record.
 *
 * Side effects:
 *	Memory may be allocated for the ItemAttr record.
 *
 *----------------------------------------------------------------------
 */

static ItemAttr *
ListboxGetItemAttributes(interp, listPtr, index)
    Tcl_Interp *interp;          /* Pointer to the calling Tcl interpreter */
    Listbox *listPtr;            /* Information about the listbox */
    int index;                   /* Index of the item to retrieve attributes
				  * for */
{
    int new;
    Tcl_HashEntry *entry;
    ItemAttr *attrs;

    entry = Tcl_CreateHashEntry(listPtr->itemAttrTable, (char *)index,
	    &new);
    if (new) {
	attrs = (ItemAttr *) ckalloc(sizeof(ItemAttr));
	attrs->border = NULL;
	attrs->selBorder = NULL;
	attrs->fgColor = NULL;
	attrs->selFgColor = NULL;
	Tk_InitOptions(interp, (char *)attrs, listPtr->itemAttrOptionTable,
		listPtr->tkwin);
	Tcl_SetHashValue(entry, (ClientData) attrs);
    }
    attrs = (ItemAttr *)Tcl_GetHashValue(entry);
    return attrs;
}

/*
 *----------------------------------------------------------------------
 *
 * DestroyListbox --
 *
 *	This procedure is invoked by Tcl_EventuallyFree or Tcl_Release
 *	to clean up the internal structure of a listbox at a safe time
 *	(when no-one is using it anymore).
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Everything associated with the listbox is freed up.
 *
 *----------------------------------------------------------------------
 */

static void
DestroyListbox(memPtr)
    char *memPtr;	/* Info about listbox widget. */
{
    register Listbox *listPtr = (Listbox *) memPtr;
    Tcl_HashEntry *entry;
    Tcl_HashSearch search;

    /* If we have an internal list object, free it */
    if (listPtr->listObj != NULL) {
	Tcl_DecrRefCount(listPtr->listObj);
	listPtr->listObj = NULL;
    }

    if (listPtr->listVarName != NULL) {
	Tcl_UntraceVar(listPtr->interp, listPtr->listVarName,
		TCL_GLOBAL_ONLY|TCL_TRACE_WRITES|TCL_TRACE_UNSETS,
		ListboxListVarProc, (ClientData) listPtr);
    }
    
    /* Free the selection hash table */
    Tcl_DeleteHashTable(listPtr->selection);
    ckfree((char *)listPtr->selection);

    /* Free the item attribute hash table */
    for (entry = Tcl_FirstHashEntry(listPtr->itemAttrTable, &search);
	 entry != NULL; entry = Tcl_NextHashEntry(&search)) {
	ckfree((char *)Tcl_GetHashValue(entry));
    }
    Tcl_DeleteHashTable(listPtr->itemAttrTable);
    ckfree((char *)listPtr->itemAttrTable);

    /*
     * Free up all the stuff that requires special handling, then
     * let Tk_FreeOptions handle all the standard option-related
     * stuff.
     */

    if (listPtr->textGC != None) {
	Tk_FreeGC(listPtr->display, listPtr->textGC);
    }
    if (listPtr->selTextGC != None) {
	Tk_FreeGC(listPtr->display, listPtr->selTextGC);
    }
    if (listPtr->gray != None) {
	Tk_FreeBitmap(Tk_Display(listPtr->tkwin), listPtr->gray);
    }

    Tk_FreeConfigOptions((char *)listPtr, listPtr->optionTable,
	    listPtr->tkwin);
    Tcl_Release((ClientData) listPtr->tkwin);
    listPtr->tkwin = NULL;
    ckfree((char *) listPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * DestroyListboxOptionTables --
 *
 *	This procedure is registered as an exit callback when the listbox
 *	command is first called.  It cleans up the OptionTables structure
 *	allocated by that command.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Frees memory.
 *
 *----------------------------------------------------------------------
 */

static void
DestroyListboxOptionTables(clientData, interp)
    ClientData clientData;	/* Pointer to the OptionTables struct */
    Tcl_Interp *interp;		/* Pointer to the calling interp */
{
    ckfree((char *)clientData);
    return;
}

/*
 *----------------------------------------------------------------------
 *
 * ConfigureListbox --
 *
 *	This procedure is called to process an objv/objc list, plus
 *	the Tk option database, in order to configure (or reconfigure)
 *	a listbox widget.
 *
 * Results:
 *	The return value is a standard Tcl result.  If TCL_ERROR is
 *	returned, then the interp's result contains an error message.
 *
 * Side effects:
 *	Configuration information, such as colors, border width,
 *	etc. get set for listPtr;  old resources get freed,
 *	if there were any.
 *
 *----------------------------------------------------------------------
 */

static int
ConfigureListbox(interp, listPtr, objc, objv, flags)
    Tcl_Interp *interp;		/* Used for error reporting. */
    register Listbox *listPtr;	/* Information about widget;  may or may
				 * not already have values for some fields. */
    int objc;			/* Number of valid entries in argv. */
    Tcl_Obj *CONST objv[];	/* Arguments. */
    int flags;			/* Flags to pass to Tk_ConfigureWidget. */
{
    Tk_SavedOptions savedOptions;
    Tcl_Obj *oldListObj = NULL;
    Tcl_Obj *errorResult = NULL;
    int oldExport, error;

    oldExport = listPtr->exportSelection;
    if (listPtr->listVarName != NULL) {
	Tcl_UntraceVar(interp, listPtr->listVarName,
		TCL_GLOBAL_ONLY|TCL_TRACE_WRITES|TCL_TRACE_UNSETS,
		ListboxListVarProc, (ClientData) listPtr);
    }

    for (error = 0; error <= 1; error++) {
	if (!error) {
	    /*
	     * First pass: set options to new values.
	     */

	    if (Tk_SetOptions(interp, (char *) listPtr,
		    listPtr->optionTable, objc, objv,
		    listPtr->tkwin, &savedOptions, (int *) NULL) != TCL_OK) {
		continue;
	    }
	} else {
	    /*
	     * Second pass: restore options to old values.
	     */

	    errorResult = Tcl_GetObjResult(interp);
	    Tcl_IncrRefCount(errorResult);
	    Tk_RestoreSavedOptions(&savedOptions);
	}

	/*
	 * A few options need special processing, such as setting the
	 * background from a 3-D border.
	 */

	Tk_SetBackgroundFromBorder(listPtr->tkwin, listPtr->normalBorder);

	if (listPtr->highlightWidth < 0) {
	    listPtr->highlightWidth = 0;
	}
	listPtr->inset = listPtr->highlightWidth + listPtr->borderWidth;

	/*
	 * Claim the selection if we've suddenly started exporting it and
	 * there is a selection to export.
	 */

	if (listPtr->exportSelection && !oldExport
		&& (listPtr->numSelected != 0)) {
	    Tk_OwnSelection(listPtr->tkwin, XA_PRIMARY, ListboxLostSelection,
		    (ClientData) listPtr);
	}

	/* Verify the current status of the list var.
	 * PREVIOUS STATE | NEW STATE  | ACTION
	 * ---------------+------------+----------------------------------
	 * no listvar     | listvar    | If listvar does not exist, create
	 *                               it and copy the internal list obj's
	 *                               content to the new var.  If it does
	 *                               exist, toss the internal list obj.
	 *
	 * listvar        | no listvar | Copy old listvar content to the
	 *                               internal list obj
	 *
	 * listvar        | listvar    | no special action
	 *
	 * no listvar     | no listvar | no special action
	 */
	oldListObj = listPtr->listObj;
	if (listPtr->listVarName != NULL) {
	    Tcl_Obj *listVarObj = Tcl_GetVar2Ex(interp, listPtr->listVarName,
		    (char *) NULL, TCL_GLOBAL_ONLY);
	    int dummy;
	    if (listVarObj == NULL) {
		listVarObj = (oldListObj ? oldListObj : Tcl_NewObj());
		if (Tcl_SetVar2Ex(interp, listPtr->listVarName, (char *) NULL,
			listVarObj, TCL_GLOBAL_ONLY|TCL_LEAVE_ERR_MSG)
			== NULL) {
		    if (oldListObj == NULL) {
			Tcl_DecrRefCount(listVarObj);
		    }
		    continue;
		}
	    }
	    /* Make sure the object is a good list object */
	    if (Tcl_ListObjLength(listPtr->interp, listVarObj, &dummy)
		    != TCL_OK) {
		Tcl_AppendResult(listPtr->interp,
			": invalid -listvariable value", (char *) NULL);
		continue;
	    }

	    listPtr->listObj = listVarObj;
	    Tcl_TraceVar(listPtr->interp, listPtr->listVarName,
		    TCL_GLOBAL_ONLY|TCL_TRACE_WRITES|TCL_TRACE_UNSETS,
		    ListboxListVarProc, (ClientData) listPtr);
	} else if (listPtr->listObj == NULL) {
	    listPtr->listObj = Tcl_NewObj();
	}
	Tcl_IncrRefCount(listPtr->listObj);
	if (oldListObj != NULL) {
	    Tcl_DecrRefCount(oldListObj);
	}
	break;
    }
    if (!error) {
	Tk_FreeSavedOptions(&savedOptions);
    }

    /* Make sure that the list length is correct */
    Tcl_ListObjLength(listPtr->interp, listPtr->listObj, &listPtr->nElements);
    
    if (error) {
        Tcl_SetObjResult(interp, errorResult);
	Tcl_DecrRefCount(errorResult);
	return TCL_ERROR;
    } else {
	ListboxWorldChanged((ClientData) listPtr);
	return TCL_OK;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ConfigureListboxItem --
 *
 *	This procedure is called to process an objv/objc list, plus
 *	the Tk option database, in order to configure (or reconfigure)
 *	a listbox item.
 *
 * Results:
 *	The return value is a standard Tcl result.  If TCL_ERROR is
 *	returned, then the interp's result contains an error message.
 *
 * Side effects:
 *	Configuration information, such as colors, border width,
 *	etc. get set for a listbox item;  old resources get freed,
 *	if there were any.
 *
 *----------------------------------------------------------------------
 */

static int
ConfigureListboxItem(interp, listPtr, attrs, objc, objv)
    Tcl_Interp *interp;		/* Used for error reporting. */
    register Listbox *listPtr;	/* Information about widget;  may or may
				 * not already have values for some fields. */
    ItemAttr *attrs;		/* Information about the item to configure */
    int objc;			/* Number of valid entries in argv. */
    Tcl_Obj *CONST objv[];	/* Arguments. */
{
    Tk_SavedOptions savedOptions;

    if (Tk_SetOptions(interp, (char *)attrs,
	    listPtr->itemAttrOptionTable, objc, objv, listPtr->tkwin,
	    &savedOptions, (int *)NULL) != TCL_OK) {
	Tk_RestoreSavedOptions(&savedOptions);
	return TCL_ERROR;
    }
    Tk_FreeSavedOptions(&savedOptions);
    ListboxWorldChanged((ClientData) listPtr);
    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * ListboxWorldChanged --
 *
 *      This procedure is called when the world has changed in some
 *      way and the widget needs to recompute all its graphics contexts
 *	and determine its new geometry.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Listbox will be relayed out and redisplayed.
 *
 *---------------------------------------------------------------------------
 */
 
static void
ListboxWorldChanged(instanceData)
    ClientData instanceData;	/* Information about widget. */
{
    XGCValues gcValues;
    GC gc;
    unsigned long mask;
    Listbox *listPtr;
    
    listPtr = (Listbox *) instanceData;

    if (listPtr->state & STATE_NORMAL) {
	gcValues.foreground = listPtr->fgColorPtr->pixel;
	gcValues.graphics_exposures = False;
	mask = GCForeground | GCFont | GCGraphicsExposures;
    } else {
	if (listPtr->dfgColorPtr != NULL) {
	    gcValues.foreground = listPtr->dfgColorPtr->pixel;
	    gcValues.graphics_exposures = False;
	    mask = GCForeground | GCFont | GCGraphicsExposures;
	} else {
	    gcValues.foreground = listPtr->fgColorPtr->pixel;
	    mask = GCForeground | GCFont;
	    if (listPtr->gray == None) {
		listPtr->gray = Tk_GetBitmap(NULL, listPtr->tkwin, "gray50");
	    }
	    if (listPtr->gray != None) {
		gcValues.fill_style = FillStippled;
		gcValues.stipple = listPtr->gray;
		mask |= GCFillStyle | GCStipple;
	    }
	}
    }

    gcValues.font = Tk_FontId(listPtr->tkfont);
    gc = Tk_GetGC(listPtr->tkwin, mask, &gcValues);
    if (listPtr->textGC != None) {
	Tk_FreeGC(listPtr->display, listPtr->textGC);
    }
    listPtr->textGC = gc;

    gcValues.foreground = listPtr->selFgColorPtr->pixel;
    gcValues.font = Tk_FontId(listPtr->tkfont);
    mask = GCForeground | GCFont;
    gc = Tk_GetGC(listPtr->tkwin, mask, &gcValues);
    if (listPtr->selTextGC != None) {
	Tk_FreeGC(listPtr->display, listPtr->selTextGC);
    }
    listPtr->selTextGC = gc;

    /*
     * Register the desired geometry for the window and arrange for
     * the window to be redisplayed.
     */

    ListboxComputeGeometry(listPtr, 1, 1, 1);
    listPtr->flags |= UPDATE_V_SCROLLBAR|UPDATE_H_SCROLLBAR;
    EventuallyRedrawRange(listPtr, 0, listPtr->nElements-1);
}

/*
 *--------------------------------------------------------------
 *
 * DisplayListbox --
 *
 *	This procedure redraws the contents of a listbox window.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Information appears on the screen.
 *
 *--------------------------------------------------------------
 */

static void
DisplayListbox(clientData)
    ClientData clientData;	/* Information about window. */
{
    register Listbox *listPtr = (Listbox *) clientData;
    register Tk_Window tkwin = listPtr->tkwin;
    GC gc;
    int i, limit, x, y, width, prevSelected, freeGC;
    Tk_FontMetrics fm;
    Tcl_Obj *curElement;
    Tcl_HashEntry *entry;
    char *stringRep;
    int stringLen;
    ItemAttr *attrs;
    Tk_3DBorder selectedBg;
    XGCValues gcValues;
    unsigned long mask;
    int left, right;			/* Non-zero values here indicate
					 * that the left or right edge of
					 * the listbox is off-screen. */
    Pixmap pixmap;

    listPtr->flags &= ~REDRAW_PENDING;
    if (listPtr->flags & LISTBOX_DELETED) {
	return;
    }

    if (listPtr->flags & MAXWIDTH_IS_STALE) {
	ListboxComputeGeometry(listPtr, 0, 1, 0);
	listPtr->flags &= ~MAXWIDTH_IS_STALE;
	listPtr->flags |= UPDATE_H_SCROLLBAR;
    }

    Tcl_Preserve((ClientData) listPtr);
    if (listPtr->flags & UPDATE_V_SCROLLBAR) {
	ListboxUpdateVScrollbar(listPtr);
	if ((listPtr->flags & LISTBOX_DELETED) || !Tk_IsMapped(tkwin)) {
	    Tcl_Release((ClientData) listPtr);
	    return;
	}
    }
    if (listPtr->flags & UPDATE_H_SCROLLBAR) {
	ListboxUpdateHScrollbar(listPtr);
	if ((listPtr->flags & LISTBOX_DELETED) || !Tk_IsMapped(tkwin)) {
	    Tcl_Release((ClientData) listPtr);
	    return;
	}
    }
    listPtr->flags &= ~(REDRAW_PENDING|UPDATE_V_SCROLLBAR|UPDATE_H_SCROLLBAR);
    Tcl_Release((ClientData) listPtr);

    /*
     * Redrawing is done in a temporary pixmap that is allocated
     * here and freed at the end of the procedure.  All drawing is
     * done to the pixmap, and the pixmap is copied to the screen
     * at the end of the procedure.  This provides the smoothest
     * possible visual effects (no flashing on the screen).
     */

    pixmap = Tk_GetPixmap(listPtr->display, Tk_WindowId(tkwin),
	    Tk_Width(tkwin), Tk_Height(tkwin), Tk_Depth(tkwin));
    Tk_Fill3DRectangle(tkwin, pixmap, listPtr->normalBorder, 0, 0,
	    Tk_Width(tkwin), Tk_Height(tkwin), 0, TK_RELIEF_FLAT);

    /* Display each item in the listbox */
    limit = listPtr->topIndex + listPtr->fullLines + listPtr->partialLine - 1;
    if (limit >= listPtr->nElements) {
	limit = listPtr->nElements-1;
    }
    left = right = 0;
    if (listPtr->xOffset > 0) {
	left = listPtr->selBorderWidth+1;
    }
    if ((listPtr->maxWidth - listPtr->xOffset) > (Tk_Width(listPtr->tkwin)
	    - 2*(listPtr->inset + listPtr->selBorderWidth)))  {
	right = listPtr->selBorderWidth+1;
    }
    prevSelected = 0;
    
    for (i = listPtr->topIndex; i <= limit; i++) {
	x = listPtr->inset;
	y = ((i - listPtr->topIndex) * listPtr->lineHeight) 
		+ listPtr->inset;
	gc = listPtr->textGC;
	freeGC = 0;
	/*
	 * Lookup this item in the item attributes table, to see if it has
	 * special foreground/background colors
	 */
	entry = Tcl_FindHashEntry(listPtr->itemAttrTable, (char *)i);

	/*
	 * If the listbox is enabled, items may be drawn differently;
	 * they may be drawn selected, or they may have special foreground
	 * or background colors.
	 */
	if (listPtr->state & STATE_NORMAL) {
	    if (Tcl_FindHashEntry(listPtr->selection, (char *)i) != NULL) {
		/* Selected items are drawn differently. */
		gc = listPtr->selTextGC;
		width = Tk_Width(tkwin) - 2*listPtr->inset;
		selectedBg = listPtr->selBorder;
		
		/* If there is attribute information for this item,
		 * adjust the drawing accordingly */
		if (entry != NULL) {
		    attrs = (ItemAttr *)Tcl_GetHashValue(entry);
		    /* Default GC has the values from the widget at large */
		    gcValues.foreground = listPtr->selFgColorPtr->pixel;
		    gcValues.font = Tk_FontId(listPtr->tkfont);
		    gcValues.graphics_exposures = False;
		    mask = GCForeground | GCFont | GCGraphicsExposures;
		    
		    if (attrs->selBorder != NULL) {
			selectedBg = attrs->selBorder;
		    }
		    
		    if (attrs->selFgColor != NULL) {
			gcValues.foreground = attrs->selFgColor->pixel;
			gc = Tk_GetGC(listPtr->tkwin, mask, &gcValues);
			freeGC = 1;
		    }
		}

		Tk_Fill3DRectangle(tkwin, pixmap, selectedBg, x, y,
			width, listPtr->lineHeight, 0, TK_RELIEF_FLAT);

		/*
		 * Draw beveled edges around the selection, if there are
		 * visible edges next to this element. Special considerations:
		 *
		 * 1. The left and right bevels may not be visible if
		 *	horizontal scrolling is enabled (the "left" & "right"
		 *	variables are zero to indicate that the corresponding
		 *	bevel is visible).
		 * 2. Top and bottom bevels are only drawn if this is the
		 *	first or last seleted item.
		 * 3. If the left or right bevel isn't visible, then the
		 *	"left" & "right" vars, computed above, have non-zero
		 *	values that extend the top and bottom bevels so that
		 *	the mitered corners are off-screen.
		 */

		/* Draw left bevel */
		if (left == 0) {
		    Tk_3DVerticalBevel(tkwin, pixmap, selectedBg,
			    x, y, listPtr->selBorderWidth, listPtr->lineHeight,
			    1, TK_RELIEF_RAISED);
		}
		/* Draw right bevel */
		if (right == 0) {
		    Tk_3DVerticalBevel(tkwin, pixmap, selectedBg,
			    x + width - listPtr->selBorderWidth, y,
			    listPtr->selBorderWidth, listPtr->lineHeight,
			    0, TK_RELIEF_RAISED);
		}
		/* Draw top bevel */
		if (!prevSelected) {
		    Tk_3DHorizontalBevel(tkwin, pixmap, selectedBg,
			    x-left, y, width+left+right,
			    listPtr->selBorderWidth,
			    1, 1, 1, TK_RELIEF_RAISED);
		}
		/* Draw bottom bevel */
		if (i + 1 == listPtr->nElements ||
			Tcl_FindHashEntry(listPtr->selection,
				(char *)(i + 1)) == NULL ) {
		    Tk_3DHorizontalBevel(tkwin, pixmap, selectedBg, x-left,
			    y + listPtr->lineHeight - listPtr->selBorderWidth,
			    width+left+right, listPtr->selBorderWidth, 0, 0, 0,
			    TK_RELIEF_RAISED);
		}
		prevSelected = 1;
	    } else {
		/*
		 * If there is an item attributes record for this item, draw
		 * the background box and set the foreground color accordingly
		 */
		if (entry != NULL) {
		    attrs = (ItemAttr *)Tcl_GetHashValue(entry);
		    gcValues.foreground = listPtr->fgColorPtr->pixel;
		    gcValues.font = Tk_FontId(listPtr->tkfont);
		    gcValues.graphics_exposures = False;
		    mask = GCForeground | GCFont | GCGraphicsExposures;
		    
		    /*
		     * If the item has its own background color, draw it now.
		     */
		    
		    if (attrs->border != NULL) {
			width = Tk_Width(tkwin) - 2*listPtr->inset;
			Tk_Fill3DRectangle(tkwin, pixmap, attrs->border, x, y,
				width, listPtr->lineHeight, 0, TK_RELIEF_FLAT);
		    }
		    
		    /*
		     * If the item has its own foreground, use it to override
		     * the value in the gcValues structure.
		     */
		    
		    if ((listPtr->state & STATE_NORMAL)
			    && attrs->fgColor != NULL) {
			gcValues.foreground = attrs->fgColor->pixel;
			gc = Tk_GetGC(listPtr->tkwin, mask, &gcValues);
			freeGC = 1;
		    }
		}
		prevSelected = 0;
	    }
	}

	/* Draw the actual text of this item */
	Tk_GetFontMetrics(listPtr->tkfont, &fm);
	y += fm.ascent + listPtr->selBorderWidth;
	x = listPtr->inset + listPtr->selBorderWidth - listPtr->xOffset;
	Tcl_ListObjIndex(listPtr->interp, listPtr->listObj, i, &curElement);
	stringRep = Tcl_GetStringFromObj(curElement, &stringLen);
	Tk_DrawChars(listPtr->display, pixmap, gc, listPtr->tkfont,
		stringRep, stringLen, x, y);

	/* If this is the active element, apply the activestyle to it. */
	if ((i == listPtr->active) && (listPtr->flags & GOT_FOCUS)) {
	    if (listPtr->activeStyle == ACTIVE_STYLE_UNDERLINE) {
		/* Underline the text. */
		Tk_UnderlineChars(listPtr->display, pixmap, gc,
			listPtr->tkfont, stringRep, x, y, 0, stringLen);
	    } else if (listPtr->activeStyle == ACTIVE_STYLE_DOTBOX) {
#ifdef WIN32
		/*
		 * This provides for exact default look and feel on Windows.
		 */
		TkWinDCState state;
		HDC dc;
		RECT rect;

		dc = TkWinGetDrawableDC(listPtr->display, pixmap, &state);
		rect.left   = listPtr->inset;
		rect.top    = ((i - listPtr->topIndex) * listPtr->lineHeight) 
		    + listPtr->inset;
		rect.right  = rect.left + width;
		rect.bottom = rect.top + listPtr->lineHeight;
		DrawFocusRect(dc, &rect);
		TkWinReleaseDrawableDC(pixmap, dc, &state);
#else
		/*
		 * Draw a dotted box around the text.
		 */
		x = listPtr->inset;
		y = ((i - listPtr->topIndex) * listPtr->lineHeight)
		    + listPtr->inset;
		width = Tk_Width(tkwin) - 2*listPtr->inset - 1;

		gcValues.line_style  = LineOnOffDash;
		gcValues.line_width  = listPtr->selBorderWidth;
		if (gcValues.line_width <= 0) {
		    gcValues.line_width  = 1;
		}
		gcValues.dash_offset = 0;
		gcValues.dashes      = 1;
		/*
		 * You would think the XSetDashes was necessary, but it
		 * appears that the default dotting for just saying we
		 * want dashes appears to work correctly.
		 static char dashList[] = { 1 };
		 static int  dashLen    = sizeof(dashList);
		 XSetDashes(listPtr->display, gc, 0, dashList, dashLen);
		 */
		mask = GCLineWidth | GCLineStyle | GCDashList | GCDashOffset;
		XChangeGC(listPtr->display, gc, mask, &gcValues);
		XDrawRectangle(listPtr->display, pixmap, gc, x, y,
			(unsigned) width, (unsigned) listPtr->lineHeight - 1);
		if (!freeGC) {
		    /* Don't bother changing if it is about to be freed. */
		    gcValues.line_style = LineSolid;
		    XChangeGC(listPtr->display, gc, GCLineStyle, &gcValues);
		}
#endif
	    }
	}

	if (freeGC) {
	    Tk_FreeGC(listPtr->display, gc);
	}
    }

    /*
     * Redraw the border for the listbox to make sure that it's on top
     * of any of the text of the listbox entries.
     */

    Tk_Draw3DRectangle(tkwin, pixmap, listPtr->normalBorder,
	    listPtr->highlightWidth, listPtr->highlightWidth,
	    Tk_Width(tkwin) - 2*listPtr->highlightWidth,
	    Tk_Height(tkwin) - 2*listPtr->highlightWidth,
	    listPtr->borderWidth, listPtr->relief);
    if (listPtr->highlightWidth > 0) {
	GC fgGC, bgGC;

	bgGC = Tk_GCForColor(listPtr->highlightBgColorPtr, pixmap);
	if (listPtr->flags & GOT_FOCUS) {
	    fgGC = Tk_GCForColor(listPtr->highlightColorPtr, pixmap);
	    TkpDrawHighlightBorder(tkwin, fgGC, bgGC, 
	            listPtr->highlightWidth, pixmap);
	} else {
	    TkpDrawHighlightBorder(tkwin, bgGC, bgGC, 
	            listPtr->highlightWidth, pixmap);
	}
    }
    XCopyArea(listPtr->display, pixmap, Tk_WindowId(tkwin),
	    listPtr->textGC, 0, 0, (unsigned) Tk_Width(tkwin),
	    (unsigned) Tk_Height(tkwin), 0, 0);
    Tk_FreePixmap(listPtr->display, pixmap);
}

/*
 *----------------------------------------------------------------------
 *
 * ListboxComputeGeometry --
 *
 *	This procedure is invoked to recompute geometry information
 *	such as the sizes of the elements and the overall dimensions
 *	desired for the listbox.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Geometry information is updated and a new requested size is
 *	registered for the widget.  Internal border and gridding
 *	information is also set.
 *
 *----------------------------------------------------------------------
 */

static void
ListboxComputeGeometry(listPtr, fontChanged, maxIsStale, updateGrid)
    Listbox *listPtr;		/* Listbox whose geometry is to be
				 * recomputed. */
    int fontChanged;		/* Non-zero means the font may have changed
				 * so per-element width information also
				 * has to be computed. */
    int maxIsStale;		/* Non-zero means the "maxWidth" field may
				 * no longer be up-to-date and must
				 * be recomputed.  If fontChanged is 1 then
				 * this must be 1. */
    int updateGrid;		/* Non-zero means call Tk_SetGrid or
				 * Tk_UnsetGrid to update gridding for
				 * the window. */
{
    int width, height, pixelWidth, pixelHeight;
    Tk_FontMetrics fm;
    Tcl_Obj *element;
    int textLength;
    char *text;
    int i, result;
    
    if (fontChanged  || maxIsStale) {
	listPtr->xScrollUnit = Tk_TextWidth(listPtr->tkfont, "0", 1);
	if (listPtr->xScrollUnit == 0) {
	    listPtr->xScrollUnit = 1;
	}
	listPtr->maxWidth = 0;
	for (i = 0; i < listPtr->nElements; i++) {
	    /* Compute the pixel width of the current element */
	    result = Tcl_ListObjIndex(listPtr->interp, listPtr->listObj, i,
		    &element);
	    if (result != TCL_OK) {
		continue;
	    }
	    text = Tcl_GetStringFromObj(element, &textLength);
	    Tk_GetFontMetrics(listPtr->tkfont, &fm);
	    pixelWidth = Tk_TextWidth(listPtr->tkfont, text, textLength);
	    if (pixelWidth > listPtr->maxWidth) {
		listPtr->maxWidth = pixelWidth;
	    }
	}
    }

    Tk_GetFontMetrics(listPtr->tkfont, &fm);
    listPtr->lineHeight = fm.linespace + 1 + 2*listPtr->selBorderWidth;
    width = listPtr->width;
    if (width <= 0) {
	width = (listPtr->maxWidth + listPtr->xScrollUnit - 1)
		/listPtr->xScrollUnit;
	if (width < 1) {
	    width = 1;
	}
    }
    pixelWidth = width*listPtr->xScrollUnit + 2*listPtr->inset
	    + 2*listPtr->selBorderWidth;
    height = listPtr->height;
    if (listPtr->height <= 0) {
	height = listPtr->nElements;
	if (height < 1) {
	    height = 1;
	}
    }
    pixelHeight = height*listPtr->lineHeight + 2*listPtr->inset;
    Tk_GeometryRequest(listPtr->tkwin, pixelWidth, pixelHeight);
    Tk_SetInternalBorder(listPtr->tkwin, listPtr->inset);
    if (updateGrid) {
	if (listPtr->setGrid) {
	    Tk_SetGrid(listPtr->tkwin, width, height, listPtr->xScrollUnit,
		    listPtr->lineHeight);
	} else {
	    Tk_UnsetGrid(listPtr->tkwin);
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ListboxInsertSubCmd --
 *
 *	This procedure is invoked to handle the listbox "insert"
 *      subcommand.
 *
 * Results:
 *	Standard Tcl result.
 *
 * Side effects:
 *	New elements are added to the listbox pointed to by listPtr;
 *      a refresh callback is registered for the listbox.
 *
 *----------------------------------------------------------------------
 */

static int
ListboxInsertSubCmd(listPtr, index, objc, objv)
    register Listbox *listPtr;	/* Listbox that is to get the new
				 * elements. */
    int index;			/* Add the new elements before this
				 * element. */
    int objc;			/* Number of new elements to add. */
    Tcl_Obj *CONST objv[];	/* New elements (one per entry). */
{
    int i, oldMaxWidth;
    Tcl_Obj *newListObj;
    int pixelWidth;
    int result;
    char *stringRep;
    int length;
    
    oldMaxWidth = listPtr->maxWidth;
    for (i = 0; i < objc; i++) {
	/*
	 * Check if any of the new elements are wider than the current widest;
	 * if so, update our notion of "widest."
	 */
	stringRep = Tcl_GetStringFromObj(objv[i], &length);
	pixelWidth = Tk_TextWidth(listPtr->tkfont, stringRep, length);
	if (pixelWidth > listPtr->maxWidth) {
	    listPtr->maxWidth = pixelWidth;
	}
    }
    
    /* Adjust selection and attribute information for every index after
     * the first index */
    MigrateHashEntries(listPtr->selection, index, listPtr->nElements-1, objc);
    MigrateHashEntries(listPtr->itemAttrTable, index, listPtr->nElements-1,
	    objc);
    
    /* If the object is shared, duplicate it before writing to it */
    if (Tcl_IsShared(listPtr->listObj)) {
	newListObj = Tcl_DuplicateObj(listPtr->listObj);
    } else {
	newListObj = listPtr->listObj;
    }
    result =
	Tcl_ListObjReplace(listPtr->interp, newListObj, index, 0, objc, objv);
    if (result != TCL_OK) {
	return result;
    }

    Tcl_IncrRefCount(newListObj);
    /* Clean up the old reference */
    Tcl_DecrRefCount(listPtr->listObj);

    /* Set the internal pointer to the new obj */
    listPtr->listObj = newListObj;

    /* If there is a listvar, make sure it points at the new object */
    if (listPtr->listVarName != NULL) {
	if (Tcl_SetVar2Ex(listPtr->interp, listPtr->listVarName,
		(char *)NULL, newListObj, TCL_GLOBAL_ONLY) == NULL) {
	    Tcl_DecrRefCount(newListObj);
	    return TCL_ERROR;
	}
    }

    /* Get the new list length */
    Tcl_ListObjLength(listPtr->interp, listPtr->listObj, &listPtr->nElements);
    
    /*
     * Update the "special" indices (anchor, topIndex, active) to account
     * for the renumbering that just occurred.  Then arrange for the new
     * information to be displayed.
     */

    if (index <= listPtr->selectAnchor) {
	listPtr->selectAnchor += objc;
    }
    if (index < listPtr->topIndex) {
	listPtr->topIndex += objc;
    }
    if (index <= listPtr->active) {
	listPtr->active += objc;
	if ((listPtr->active >= listPtr->nElements) &&
		(listPtr->nElements > 0)) {
	    listPtr->active = listPtr->nElements-1;
	}
    }
    listPtr->flags |= UPDATE_V_SCROLLBAR;
    if (listPtr->maxWidth != oldMaxWidth) {
	listPtr->flags |= UPDATE_H_SCROLLBAR;
    }
    ListboxComputeGeometry(listPtr, 0, 0, 0);
    EventuallyRedrawRange(listPtr, index, listPtr->nElements-1);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ListboxDeleteSubCmd --
 *
 *	Process a listbox "delete" subcommand by removing one or more
 *      elements from a listbox widget.
 *
 * Results:
 *	Standard Tcl result.
 *
 * Side effects:
 *	The listbox will be modified and (eventually) redisplayed.
 *
 *----------------------------------------------------------------------
 */

static int
ListboxDeleteSubCmd(listPtr, first, last)
    register Listbox *listPtr;	/* Listbox widget to modify. */
    int first;			/* Index of first element to delete. */
    int last;			/* Index of last element to delete. */
{
    int count, i, widthChanged;
    Tcl_Obj *newListObj;
    Tcl_Obj *element;
    int length;
    char *stringRep;
    int result;
    int pixelWidth;
    Tcl_HashEntry *entry;
    
    /*
     * Adjust the range to fit within the existing elements of the
     * listbox, and make sure there's something to delete.
     */

    if (first < 0) {
	first = 0;
    }
    if (last >= listPtr->nElements) {
	last = listPtr->nElements-1;
    }
    count = last + 1 - first;
    if (count <= 0) {
	return TCL_OK;
    }

    /*
     * Foreach deleted index we must:
     * a) remove selection information
     * b) check the width of the element; if it is equal to the max, set
     *    widthChanged to 1, because it may be the only element with that
     *    width
     */
    widthChanged = 0;
    for (i = first; i <= last; i++) {
	/* Remove selection information */
	entry = Tcl_FindHashEntry(listPtr->selection, (char *)i);
	if (entry != NULL) {
	    listPtr->numSelected--;
	    Tcl_DeleteHashEntry(entry);
	}

	entry = Tcl_FindHashEntry(listPtr->itemAttrTable, (char *)i);
	if (entry != NULL) {
	    Tcl_DeleteHashEntry(entry);
	}
	
	/* Check width of the element.  We only have to check if widthChanged
	 * has not already been set to 1, because we only need one maxWidth
	 * element to disappear for us to have to recompute the width
	 */
	if (widthChanged == 0) {
	    Tcl_ListObjIndex(listPtr->interp, listPtr->listObj, i, &element);
	    stringRep = Tcl_GetStringFromObj(element, &length);
	    pixelWidth = Tk_TextWidth(listPtr->tkfont, stringRep, length);
	    if (pixelWidth == listPtr->maxWidth) {
		widthChanged = 1;
	    }
	}
    }

    /* Adjust selection and attribute info for indices after lastIndex */
    MigrateHashEntries(listPtr->selection, last+1,
	    listPtr->nElements-1, count*-1);
    MigrateHashEntries(listPtr->itemAttrTable, last+1,
	    listPtr->nElements-1, count*-1);

    /* Delete the requested elements */
    if (Tcl_IsShared(listPtr->listObj)) {
	newListObj = Tcl_DuplicateObj(listPtr->listObj);
    } else {
	newListObj = listPtr->listObj;
    }
    result = Tcl_ListObjReplace(listPtr->interp,
	    newListObj, first, count, 0, NULL);
    if (result != TCL_OK) {
	return result;
    }

    Tcl_IncrRefCount(newListObj);
    /* Clean up the old reference */
    Tcl_DecrRefCount(listPtr->listObj);

    /* Set the internal pointer to the new obj */
    listPtr->listObj = newListObj;

    /* Get the new list length */
    Tcl_ListObjLength(listPtr->interp, listPtr->listObj, &listPtr->nElements);
    
    /* If there is a listvar, make sure it points at the new object */
    if (listPtr->listVarName != NULL) {
	if (Tcl_SetVar2Ex(listPtr->interp, listPtr->listVarName,
		(char *)NULL, newListObj, TCL_GLOBAL_ONLY) == NULL) {
	    Tcl_DecrRefCount(newListObj);
	    return TCL_ERROR;
	}
    }

    /*
     * Update the selection and viewing information to reflect the change
     * in the element numbering, and redisplay to slide information up over
     * the elements that were deleted.
     */

    if (first <= listPtr->selectAnchor) {
	listPtr->selectAnchor -= count;
	if (listPtr->selectAnchor < first) {
	    listPtr->selectAnchor = first;
	}
    }
    if (first <= listPtr->topIndex) {
	listPtr->topIndex -= count;
	if (listPtr->topIndex < first) {
	    listPtr->topIndex = first;
	}
    }
    if (listPtr->topIndex > (listPtr->nElements - listPtr->fullLines)) {
	listPtr->topIndex = listPtr->nElements - listPtr->fullLines;
	if (listPtr->topIndex < 0) {
	    listPtr->topIndex = 0;
	}
    }
    if (listPtr->active > last) {
	listPtr->active -= count;
    } else if (listPtr->active >= first) {
	listPtr->active = first;
	if ((listPtr->active >= listPtr->nElements) &&
		(listPtr->nElements > 0)) {
	    listPtr->active = listPtr->nElements-1;
	}
    }
    listPtr->flags |= UPDATE_V_SCROLLBAR;
    ListboxComputeGeometry(listPtr, 0, widthChanged, 0);
    if (widthChanged) {
	listPtr->flags |= UPDATE_H_SCROLLBAR;
    }
    EventuallyRedrawRange(listPtr, first, listPtr->nElements-1);
    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * ListboxEventProc --
 *
 *	This procedure is invoked by the Tk dispatcher for various
 *	events on listboxes.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	When the window gets deleted, internal structures get
 *	cleaned up.  When it gets exposed, it is redisplayed.
 *
 *--------------------------------------------------------------
 */

static void
ListboxEventProc(clientData, eventPtr)
    ClientData clientData;	/* Information about window. */
    XEvent *eventPtr;		/* Information about event. */
{
    Listbox *listPtr = (Listbox *) clientData;
    
    if (eventPtr->type == Expose) {
	EventuallyRedrawRange(listPtr,
		NearestListboxElement(listPtr, eventPtr->xexpose.y),
		NearestListboxElement(listPtr, eventPtr->xexpose.y
		+ eventPtr->xexpose.height));
    } else if (eventPtr->type == DestroyNotify) {
	if (!(listPtr->flags & LISTBOX_DELETED)) {
	    listPtr->flags |= LISTBOX_DELETED;
	    Tcl_DeleteCommandFromToken(listPtr->interp, listPtr->widgetCmd);
	    if (listPtr->setGrid) {
		Tk_UnsetGrid(listPtr->tkwin);
	    }
	    if (listPtr->flags & REDRAW_PENDING) {
		Tcl_CancelIdleCall(DisplayListbox, clientData);
	    }
	    Tcl_EventuallyFree(clientData, DestroyListbox);
	}
    } else if (eventPtr->type == ConfigureNotify) {
	int vertSpace;

	vertSpace = Tk_Height(listPtr->tkwin) - 2*listPtr->inset;
	listPtr->fullLines = vertSpace / listPtr->lineHeight;
	if ((listPtr->fullLines*listPtr->lineHeight) < vertSpace) {
	    listPtr->partialLine = 1;
	} else {
	    listPtr->partialLine = 0;
	}
	listPtr->flags |= UPDATE_V_SCROLLBAR|UPDATE_H_SCROLLBAR;
	ChangeListboxView(listPtr, listPtr->topIndex);
	ChangeListboxOffset(listPtr, listPtr->xOffset);

	/*
	 * Redraw the whole listbox.  It's hard to tell what needs
	 * to be redrawn (e.g. if the listbox has shrunk then we
	 * may only need to redraw the borders), so just redraw
	 * everything for safety.
	 */

	EventuallyRedrawRange(listPtr, 0, listPtr->nElements-1);
    } else if (eventPtr->type == FocusIn) {
	if (eventPtr->xfocus.detail != NotifyInferior) {
	    listPtr->flags |= GOT_FOCUS;
	    EventuallyRedrawRange(listPtr, 0, listPtr->nElements-1);
	}
    } else if (eventPtr->type == FocusOut) {
	if (eventPtr->xfocus.detail != NotifyInferior) {
	    listPtr->flags &= ~GOT_FOCUS;
	    EventuallyRedrawRange(listPtr, 0, listPtr->nElements-1);
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ListboxCmdDeletedProc --
 *
 *	This procedure is invoked when a widget command is deleted.  If
 *	the widget isn't already in the process of being destroyed,
 *	this command destroys it.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The widget is destroyed.
 *
 *----------------------------------------------------------------------
 */

static void
ListboxCmdDeletedProc(clientData)
    ClientData clientData;	/* Pointer to widget record for widget. */
{
    Listbox *listPtr = (Listbox *) clientData;

    /*
     * This procedure could be invoked either because the window was
     * destroyed and the command was then deleted (in which case tkwin
     * is NULL) or because the command was deleted, and then this procedure
     * destroys the widget.
     */

    if (!(listPtr->flags & LISTBOX_DELETED)) {
	Tk_DestroyWindow(listPtr->tkwin);
    }
}

/*
 *--------------------------------------------------------------
 *
 * GetListboxIndex --
 *
 *	Parse an index into a listbox and return either its value
 *	or an error.
 *
 * Results:
 *	A standard Tcl result.  If all went well, then *indexPtr is
 *	filled in with the index (into listPtr) corresponding to
 *	string.  Otherwise an error message is left in the interp's result.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------
 */

static int
GetListboxIndex(interp, listPtr, indexObj, endIsSize, indexPtr)
    Tcl_Interp *interp;		/* For error messages. */
    Listbox *listPtr;		/* Listbox for which the index is being
				 * specified. */
    Tcl_Obj *indexObj;		/* Specifies an element in the listbox. */
    int endIsSize;		/* If 1, "end" refers to the number of
				 * entries in the listbox.  If 0, "end"
				 * refers to 1 less than the number of
				 * entries. */
    int *indexPtr;		/* Where to store converted index. */
{
    int result;
    int index;
    char *stringRep;
    
    /* First see if the index is one of the named indices */
    result = Tcl_GetIndexFromObj(NULL, indexObj, indexNames, "", 0, &index);
    if (result == TCL_OK) {
	switch (index) {
	    case INDEX_ACTIVE: {
		/* "active" index */
		*indexPtr = listPtr->active;
		break;
	    }

	    case INDEX_ANCHOR: {
		/* "anchor" index */
		*indexPtr = listPtr->selectAnchor;
		break;
	    }

	    case INDEX_END: {
		/* "end" index */
		if (endIsSize) {
		    *indexPtr = listPtr->nElements;
		} else {
		    *indexPtr = listPtr->nElements - 1;
		}
		break;
	    }
	}
	return TCL_OK;
    }

    /* The index didn't match any of the named indices; maybe it's an @@x,y */
    stringRep = Tcl_GetString(indexObj);
    if (stringRep[0] == '@@') {
	/* @@x,y index */
	int y;
	char *start, *end;
	start = stringRep + 1;
	strtol(start, &end, 0);
	if ((start == end) || (*end != ',')) {
	    Tcl_AppendResult(interp, "bad listbox index \"", stringRep,
		    "\": must be active, anchor, end, @@x,y, or a number",
		    (char *)NULL);
	    return TCL_ERROR;
	}
	start = end+1;
	y = strtol(start, &end, 0);
	if ((start == end) || (*end != '\0')) {
	    Tcl_AppendResult(interp, "bad listbox index \"", stringRep,
		    "\": must be active, anchor, end, @@x,y, or a number",
		    (char *)NULL);
	    return TCL_ERROR;
	}
	*indexPtr = NearestListboxElement(listPtr, y);
	return TCL_OK;
    }
    
    /* Maybe the index is just an integer */
    if (Tcl_GetIntFromObj(interp, indexObj, indexPtr) == TCL_OK) {
	return TCL_OK;
    }

    /* Everything failed, nothing matched.  Throw up an error message */
    Tcl_ResetResult(interp);
    Tcl_AppendResult(interp, "bad listbox index \"",
	    Tcl_GetString(indexObj), "\": must be active, anchor, ",
	    "end, @@x,y, or a number", (char *) NULL);
    return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 *
 * ChangeListboxView --
 *
 *	Change the view on a listbox widget so that a given element
 *	is displayed at the top.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	What's displayed on the screen is changed.  If there is a
 *	scrollbar associated with this widget, then the scrollbar
 *	is instructed to change its display too.
 *
 *----------------------------------------------------------------------
 */

static void
ChangeListboxView(listPtr, index)
    register Listbox *listPtr;		/* Information about widget. */
    int index;				/* Index of element in listPtr
					 * that should now appear at the
					 * top of the listbox. */
{
    if (index >= (listPtr->nElements - listPtr->fullLines)) {
	index = listPtr->nElements - listPtr->fullLines;
    }
    if (index < 0) {
	index = 0;
    }
    if (listPtr->topIndex != index) {
	listPtr->topIndex = index;
	EventuallyRedrawRange(listPtr, 0, listPtr->nElements-1);
	listPtr->flags |= UPDATE_V_SCROLLBAR;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ChangListboxOffset --
 *
 *	Change the horizontal offset for a listbox.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The listbox may be redrawn to reflect its new horizontal
 *	offset.
 *
 *----------------------------------------------------------------------
 */

static void
ChangeListboxOffset(listPtr, offset)
    register Listbox *listPtr;		/* Information about widget. */
    int offset;				/* Desired new "xOffset" for
					 * listbox. */
{
    int maxOffset;
    
    /*
     * Make sure that the new offset is within the allowable range, and
     * round it off to an even multiple of xScrollUnit.
     *
     * Add half a scroll unit to do entry/text-like synchronization.
     * [Bug #225025]
     */

    offset += listPtr->xScrollUnit / 2;
    maxOffset = listPtr->maxWidth - (Tk_Width(listPtr->tkwin) -
	    2*listPtr->inset - 2*listPtr->selBorderWidth)
	    + listPtr->xScrollUnit - 1;
    if (offset > maxOffset) {
	offset = maxOffset;
    }
    if (offset < 0) {
	offset = 0;
    }
    offset -= offset % listPtr->xScrollUnit;
    if (offset != listPtr->xOffset) {
	listPtr->xOffset = offset;
	listPtr->flags |= UPDATE_H_SCROLLBAR;
	EventuallyRedrawRange(listPtr, 0, listPtr->nElements-1);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ListboxScanTo --
 *
 *	Given a point (presumably of the curent mouse location)
 *	drag the view in the window to implement the scan operation.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The view in the window may change.
 *
 *----------------------------------------------------------------------
 */

static void
ListboxScanTo(listPtr, x, y)
    register Listbox *listPtr;		/* Information about widget. */
    int x;				/* X-coordinate to use for scan
					 * operation. */
    int y;				/* Y-coordinate to use for scan
					 * operation. */
{
    int newTopIndex, newOffset, maxIndex, maxOffset;
    
    maxIndex = listPtr->nElements - listPtr->fullLines;
    maxOffset = listPtr->maxWidth + (listPtr->xScrollUnit - 1)
	    - (Tk_Width(listPtr->tkwin) - 2*listPtr->inset
	    - 2*listPtr->selBorderWidth - listPtr->xScrollUnit);

    /*
     * Compute new top line for screen by amplifying the difference
     * between the current position and the place where the scan
     * started (the "mark" position).  If we run off the top or bottom
     * of the list, then reset the mark point so that the current
     * position continues to correspond to the edge of the window.
     * This means that the picture will start dragging as soon as the
     * mouse reverses direction (without this reset, might have to slide
     * mouse a long ways back before the picture starts moving again).
     */

    newTopIndex = listPtr->scanMarkYIndex
	    - (10*(y - listPtr->scanMarkY))/listPtr->lineHeight;
    if (newTopIndex > maxIndex) {
	newTopIndex = listPtr->scanMarkYIndex = maxIndex;
	listPtr->scanMarkY = y;
    } else if (newTopIndex < 0) {
	newTopIndex = listPtr->scanMarkYIndex = 0;
	listPtr->scanMarkY = y;
    }
    ChangeListboxView(listPtr, newTopIndex);

    /*
     * Compute new left edge for display in a similar fashion by amplifying
     * the difference between the current position and the place where the
     * scan started.
     */

    newOffset = listPtr->scanMarkXOffset - (10*(x - listPtr->scanMarkX));
    if (newOffset > maxOffset) {
	newOffset = listPtr->scanMarkXOffset = maxOffset;
	listPtr->scanMarkX = x;
    } else if (newOffset < 0) {
	newOffset = listPtr->scanMarkXOffset = 0;
	listPtr->scanMarkX = x;
    }
    ChangeListboxOffset(listPtr, newOffset);
}

/*
 *----------------------------------------------------------------------
 *
 * NearestListboxElement --
 *
 *	Given a y-coordinate inside a listbox, compute the index of
 *	the element under that y-coordinate (or closest to that
 *	y-coordinate).
 *
 * Results:
 *	The return value is an index of an element of listPtr.  If
 *	listPtr has no elements, then 0 is always returned.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
NearestListboxElement(listPtr, y)
    register Listbox *listPtr;		/* Information about widget. */
    int y;				/* Y-coordinate in listPtr's window. */
{
    int index;

    index = (y - listPtr->inset)/listPtr->lineHeight;
    if (index >= (listPtr->fullLines + listPtr->partialLine)) {
	index = listPtr->fullLines + listPtr->partialLine - 1;
    }
    if (index < 0) {
	index = 0;
    }
    index += listPtr->topIndex;
    if (index >= listPtr->nElements) {
	index = listPtr->nElements-1;
    }
    return index;
}

/*
 *----------------------------------------------------------------------
 *
 * ListboxSelect --
 *
 *	Select or deselect one or more elements in a listbox..
 *
 * Results:
 *	Standard Tcl result.
 *
 * Side effects:
 *	All of the elements in the range between first and last are
 *	marked as either selected or deselected, depending on the
 *	"select" argument.  Any items whose state changes are redisplayed.
 *	The selection is claimed from X when the number of selected
 *	elements changes from zero to non-zero.
 *
 *----------------------------------------------------------------------
 */

static int
ListboxSelect(listPtr, first, last, select)
    register Listbox *listPtr;		/* Information about widget. */
    int first;				/* Index of first element to
					 * select or deselect. */
    int last;				/* Index of last element to
					 * select or deselect. */
    int select;				/* 1 means select items, 0 means
					 * deselect them. */
{
    int i, firstRedisplay, increment, oldCount;
    Tcl_HashEntry *entry;
    int new;
    
    if (last < first) {
	i = first;
	first = last;
	last = i;
    }
    if ((last < 0) || (first >= listPtr->nElements)) {
	return TCL_OK;
    }
    if (first < 0) {
	first = 0;
    }
    if (last >= listPtr->nElements) {
	last = listPtr->nElements - 1;
    }
    oldCount = listPtr->numSelected;
    firstRedisplay = -1;
    increment = select ? 1 : -1;

    /*
     * For each index in the range, find it in our selection hash table.
     * If it's not there but should be, add it.  If it's there but shouldn't
     * be, remove it.
     */
    for (i = first; i <= last; i++) {
	entry = Tcl_FindHashEntry(listPtr->selection, (char *)i);
	if (entry != NULL) {
	    if (!select) {
		Tcl_DeleteHashEntry(entry);
		listPtr->numSelected--;
		if (firstRedisplay < 0) {
		    firstRedisplay = i;
		}
	    }
	} else {
	    if (select) {
		entry = Tcl_CreateHashEntry(listPtr->selection,
			(char *)i, &new);
		Tcl_SetHashValue(entry, (ClientData) NULL);
		listPtr->numSelected++;
		if (firstRedisplay < 0) {
		    firstRedisplay = i;
		}
	    }
	}
    }

    if (firstRedisplay >= 0) {
	EventuallyRedrawRange(listPtr, first, last);
    }
    if ((oldCount == 0) && (listPtr->numSelected > 0)
	    && (listPtr->exportSelection)) {
	Tk_OwnSelection(listPtr->tkwin, XA_PRIMARY, ListboxLostSelection,
		(ClientData) listPtr);
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ListboxFetchSelection --
 *
 *	This procedure is called back by Tk when the selection is
 *	requested by someone.  It returns part or all of the selection
 *	in a buffer provided by the caller.
 *
 * Results:
 *	The return value is the number of non-NULL bytes stored
 *	at buffer.  Buffer is filled (or partially filled) with a
 *	NULL-terminated string containing part or all of the selection,
 *	as given by offset and maxBytes.  The selection is returned
 *	as a Tcl list with one list element for each element in the
 *	listbox.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
ListboxFetchSelection(clientData, offset, buffer, maxBytes)
    ClientData clientData;		/* Information about listbox widget. */
    int offset;				/* Offset within selection of first
					 * byte to be returned. */
    char *buffer;			/* Location in which to place
					 * selection. */
    int maxBytes;			/* Maximum number of bytes to place
					 * at buffer, not including terminating
					 * NULL character. */
{
    register Listbox *listPtr = (Listbox *) clientData;
    Tcl_DString selection;
    int length, count, needNewline;
    Tcl_Obj *curElement;
    char *stringRep;
    int stringLen;
    Tcl_HashEntry *entry;
    int i;
    
    if (!listPtr->exportSelection) {
	return -1;
    }

    /*
     * Use a dynamic string to accumulate the contents of the selection.
     */

    needNewline = 0;
    Tcl_DStringInit(&selection);
    for (i = 0; i < listPtr->nElements; i++) {
	entry = Tcl_FindHashEntry(listPtr->selection, (char *)i);
	if (entry != NULL) {
	    if (needNewline) {
		Tcl_DStringAppend(&selection, "\n", 1);
	    }
	    Tcl_ListObjIndex(listPtr->interp, listPtr->listObj, i,
		    &curElement);
	    stringRep = Tcl_GetStringFromObj(curElement, &stringLen);
	    Tcl_DStringAppend(&selection, stringRep, stringLen);
	    needNewline = 1;
	}
    }

    length = Tcl_DStringLength(&selection);
    if (length == 0) {
	return -1;
    }

    /*
     * Copy the requested portion of the selection to the buffer.
     */

    count = length - offset;
    if (count <= 0) {
	count = 0;
    } else {
	if (count > maxBytes) {
	    count = maxBytes;
	}
	memcpy((VOID *) buffer,
		(VOID *) (Tcl_DStringValue(&selection) + offset),
		(size_t) count);
    }
    buffer[count] = '\0';
    Tcl_DStringFree(&selection);
    return count;
}

/*
 *----------------------------------------------------------------------
 *
 * ListboxLostSelection --
 *
 *	This procedure is called back by Tk when the selection is
 *	grabbed away from a listbox widget.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The existing selection is unhighlighted, and the window is
 *	marked as not containing a selection.
 *
 *----------------------------------------------------------------------
 */

static void
ListboxLostSelection(clientData)
    ClientData clientData;		/* Information about listbox widget. */
{
    register Listbox *listPtr = (Listbox *) clientData;
    
    if ((listPtr->exportSelection) && (listPtr->nElements > 0)) {
	ListboxSelect(listPtr, 0, listPtr->nElements-1, 0);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * EventuallyRedrawRange --
 *
 *	Ensure that a given range of elements is eventually redrawn on
 *	the display (if those elements in fact appear on the display).
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Information gets redisplayed.
 *
 *----------------------------------------------------------------------
 */

static void
EventuallyRedrawRange(listPtr, first, last)
    register Listbox *listPtr;		/* Information about widget. */
    int first;				/* Index of first element in list
					 * that needs to be redrawn. */
    int last;				/* Index of last element in list
					 * that needs to be redrawn.  May
					 * be less than first;
					 * these just bracket a range. */
{
    /* We don't have to register a redraw callback if one is already pending,
     * or if the window doesn't exist, or if the window isn't mapped */
    if ((listPtr->flags & REDRAW_PENDING)
	    || (listPtr->flags & LISTBOX_DELETED)
	    || !Tk_IsMapped(listPtr->tkwin)) {
	return;
    }
    listPtr->flags |= REDRAW_PENDING;
    Tcl_DoWhenIdle(DisplayListbox, (ClientData) listPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * ListboxUpdateVScrollbar --
 *
 *	This procedure is invoked whenever information has changed in
 *	a listbox in a way that would invalidate a vertical scrollbar
 *	display.  If there is an associated scrollbar, then this command
 *	updates it by invoking a Tcl command.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	A Tcl command is invoked, and an additional command may be
 *	invoked to process errors in the command.
 *
 *----------------------------------------------------------------------
 */

static void
ListboxUpdateVScrollbar(listPtr)
    register Listbox *listPtr;		/* Information about widget. */
{
    char string[TCL_DOUBLE_SPACE * 2];
    double first, last;
    int result;
    Tcl_Interp *interp;
    
    if (listPtr->yScrollCmd == NULL) {
	return;
    }
    if (listPtr->nElements == 0) {
	first = 0.0;
	last = 1.0;
    } else {
	first = listPtr->topIndex/((double) listPtr->nElements);
	last = (listPtr->topIndex+listPtr->fullLines)
		/((double) listPtr->nElements);
	if (last > 1.0) {
	    last = 1.0;
	}
    }
    sprintf(string, " %g %g", first, last);

    /*
     * We must hold onto the interpreter from the listPtr because the data
     * at listPtr might be freed as a result of the Tcl_VarEval.
     */
    
    interp = listPtr->interp;
    Tcl_Preserve((ClientData) interp);
    result = Tcl_VarEval(interp, listPtr->yScrollCmd, string,
	    (char *) NULL);
    if (result != TCL_OK) {
	Tcl_AddErrorInfo(interp,
		"\n    (vertical scrolling command executed by listbox)");
	Tcl_BackgroundError(interp);
    }
    Tcl_Release((ClientData) interp);
}

/*
 *----------------------------------------------------------------------
 *
 * ListboxUpdateHScrollbar --
 *
 *	This procedure is invoked whenever information has changed in
 *	a listbox in a way that would invalidate a horizontal scrollbar
 *	display.  If there is an associated horizontal scrollbar, then
 *	this command updates it by invoking a Tcl command.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	A Tcl command is invoked, and an additional command may be
 *	invoked to process errors in the command.
 *
 *----------------------------------------------------------------------
 */

static void
ListboxUpdateHScrollbar(listPtr)
    register Listbox *listPtr;		/* Information about widget. */
{
    char string[TCL_DOUBLE_SPACE * 2];
    int result, windowWidth;
    double first, last;
    Tcl_Interp *interp;

    if (listPtr->xScrollCmd == NULL) {
	return;
    }
    windowWidth = Tk_Width(listPtr->tkwin) - 2*(listPtr->inset
	    + listPtr->selBorderWidth);
    if (listPtr->maxWidth == 0) {
	first = 0;
	last = 1.0;
    } else {
	first = listPtr->xOffset/((double) listPtr->maxWidth);
	last = (listPtr->xOffset + windowWidth)
		/((double) listPtr->maxWidth);
	if (last > 1.0) {
	    last = 1.0;
	}
    }
    sprintf(string, " %g %g", first, last);

    /*
     * We must hold onto the interpreter because the data referred to at
     * listPtr might be freed as a result of the call to Tcl_VarEval.
     */
    
    interp = listPtr->interp;
    Tcl_Preserve((ClientData) interp);
    result = Tcl_VarEval(interp, listPtr->xScrollCmd, string,
	    (char *) NULL);
    if (result != TCL_OK) {
	Tcl_AddErrorInfo(interp,
		"\n    (horizontal scrolling command executed by listbox)");
	Tcl_BackgroundError(interp);
    }
    Tcl_Release((ClientData) interp);
}

/*
 *----------------------------------------------------------------------
 *
 * ListboxListVarProc --
 *
 *      Called whenever the trace on the listbox list var fires.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */

static char *
ListboxListVarProc(clientData, interp, name1, name2, flags)
    ClientData clientData;      /* Information about button. */
    Tcl_Interp *interp;         /* Interpreter containing variable. */
    CONST char *name1;          /* Not used. */
    CONST char *name2;          /* Not used. */
    int flags;                  /* Information about what happened. */
{
    Listbox *listPtr = (Listbox *)clientData;
    Tcl_Obj *oldListObj, *varListObj;
    int oldLength;
    int i;
    Tcl_HashEntry *entry;
    
    /* Bwah hahahaha -- puny mortal, you can't unset a -listvar'd variable! */
    if (flags & TCL_TRACE_UNSETS) {
	if ((flags & TCL_TRACE_DESTROYED) && !(flags & TCL_INTERP_DESTROYED)) {
	    Tcl_SetVar2Ex(interp, listPtr->listVarName,
		    (char *)NULL, listPtr->listObj, TCL_GLOBAL_ONLY);
	    Tcl_TraceVar(interp, listPtr->listVarName,
		    TCL_GLOBAL_ONLY|TCL_TRACE_WRITES|TCL_TRACE_UNSETS,
		    ListboxListVarProc, clientData);
	    return (char *)NULL;
	}
    } else {
	oldListObj = listPtr->listObj;
	varListObj = Tcl_GetVar2Ex(listPtr->interp, listPtr->listVarName,
		(char *)NULL, TCL_GLOBAL_ONLY);
	/*
	 * Make sure the new value is a good list; if it's not, disallow
	 * the change -- the fact that it is a listvar means that it must
	 * always be a valid list -- and return an error message.
	 */
	if (Tcl_ListObjLength(listPtr->interp, varListObj, &i) != TCL_OK) {
	    Tcl_SetVar2Ex(interp, listPtr->listVarName, (char *)NULL,
		    oldListObj, TCL_GLOBAL_ONLY);
	    return("invalid listvar value");
	}
	
	listPtr->listObj = varListObj;
	/* Incr the obj ref count so it doesn't vanish if the var is unset */
	Tcl_IncrRefCount(listPtr->listObj);
	/* Clean up the ref to our old list obj */
	Tcl_DecrRefCount(oldListObj);
    }

    /*
     * If the list length has decreased, then we should clean up selection and
     * attributes information for elements past the end of the new list
     */
    oldLength = listPtr->nElements;
    Tcl_ListObjLength(listPtr->interp, listPtr->listObj, &listPtr->nElements);
    if (listPtr->nElements < oldLength) {
	for (i = listPtr->nElements; i < oldLength; i++) {
	    /* Clean up selection */
	    entry = Tcl_FindHashEntry(listPtr->selection, (char *)i);
	    if (entry != NULL) {
		listPtr->numSelected--;
		Tcl_DeleteHashEntry(entry);
	    }

	    /* Clean up attributes */
	    entry = Tcl_FindHashEntry(listPtr->itemAttrTable, (char *)i);
	    if (entry != NULL) {
		Tcl_DeleteHashEntry(entry);
	    }
	}
    }

    if (oldLength != listPtr->nElements) {
	listPtr->flags |= UPDATE_V_SCROLLBAR;
	if (listPtr->topIndex > (listPtr->nElements - listPtr->fullLines)) {
	    listPtr->topIndex = listPtr->nElements - listPtr->fullLines;
	    if (listPtr->topIndex < 0) {
		listPtr->topIndex = 0;
	    }
	}
    }

    /*
     * The computed maxWidth may have changed as a result of this operation.
     * However, we don't want to recompute it every time this trace fires
     * (imagine the user doing 1000 lappends to the listvar).  Therefore, set
     * the MAXWIDTH_IS_STALE flag, which will cause the width to be recomputed
     * next time the list is redrawn.
     */
    listPtr->flags |= MAXWIDTH_IS_STALE;
    
    EventuallyRedrawRange(listPtr, 0, listPtr->nElements-1);
    return (char*)NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * MigrateHashEntries --
 *
 *	Given a hash table with entries keyed by a single integer value,
 *	move all entries in a given range by a fixed amount, so that
 *	if in the original table there was an entry with key n and
 *	the offset was i, in the new table that entry would have key n + i.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Rekeys some hash table entries.
 *
 *----------------------------------------------------------------------
 */

static void
MigrateHashEntries(table, first, last, offset)
    Tcl_HashTable *table;
    int first;
    int last;
    int offset;
{
    int i, new;
    Tcl_HashEntry *entry;
    ClientData clientData;

    if (offset == 0) {
	return;
    }
    /* It's more efficient to do one if/else and nest the for loops inside,
     * although we could avoid some code duplication if we nested the if/else
     * inside the for loops */
    if (offset > 0) {
	for (i = last; i >= first; i--) {
	    entry = Tcl_FindHashEntry(table, (char *)i);
	    if (entry != NULL) {
		clientData = Tcl_GetHashValue(entry);
		Tcl_DeleteHashEntry(entry);
		entry = Tcl_CreateHashEntry(table, (char *)(i + offset), &new);
		Tcl_SetHashValue(entry, clientData);
	    }
	}
    } else {
	for (i = first; i <= last; i++) {
	    entry = Tcl_FindHashEntry(table, (char *)i);
	    if (entry != NULL) {
		clientData = Tcl_GetHashValue(entry);
		Tcl_DeleteHashEntry(entry);
		entry = Tcl_CreateHashEntry(table, (char *)(i + offset), &new);
		Tcl_SetHashValue(entry, clientData);
	    }
	}
    }
    return;
}

@


1.4
log
@touched all sources to ease next import
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tkListbox.c,v 1.7.6.2 2000/09/26 16:08:10 spolk Exp $
d21 4
d81 1
d135 2
d165 2
d206 22
d232 3
d248 3
d287 3
d314 2
a315 2
	 (char *)NULL, -1, Tk_Offset(ItemAttr, border),
	 TK_OPTION_NULL_OK|TK_OPTION_DONT_SET_DEFAULT,
d318 1
a318 1
	 (char *) NULL, 0, -1, 0, (ClientData) "-background", 0},
d320 1
a320 1
	 (char *) NULL, 0, -1, 0, (ClientData) "-foreground", 0},
d322 2
a323 2
	 (char *) NULL, -1, Tk_Offset(ItemAttr, fgColor),
	 TK_OPTION_NULL_OK|TK_OPTION_DONT_SET_DEFAULT, 0, 0},
d325 2
a326 2
	 (char *) NULL, -1, Tk_Offset(ItemAttr, selBorder),
	 TK_OPTION_NULL_OK|TK_OPTION_DONT_SET_DEFAULT,
d329 2
a330 2
	 (char *) NULL, -1, Tk_Offset(ItemAttr, selFgColor),
	 TK_OPTION_NULL_OK|TK_OPTION_DONT_SET_DEFAULT,
d333 1
a333 1
	 (char *) NULL, 0, -1, 0, 0, 0}
d341 1
a341 1
static char *commandNames[] = {
d343 2
a344 2
	"index", "insert", "itemcget", "itemconfigure", "nearest", "scan",
	"see", "selection", "size", "xview", "yview",
d350 4
a353 4
	COMMAND_CURSELECTION, COMMAND_DELETE, COMMAND_GET, COMMAND_INDEX,
	COMMAND_INSERT, COMMAND_ITEMCGET, COMMAND_ITEMCONFIGURE,
	COMMAND_NEAREST, COMMAND_SCAN, COMMAND_SEE, COMMAND_SELECTION,
	COMMAND_SIZE, COMMAND_XVIEW, COMMAND_YVIEW
d356 1
a356 1
static char *selCommandNames[] = {
d364 1
a364 1
static char *scanCommandNames[] = {
d372 1
a372 1
static char *indexNames[] = {
d445 2
a446 2
	                    Tcl_Interp *interp, char *name1, char *name2,
 	                    int flags));
d454 3
a456 4
static TkClassProcs listboxClass = {
    NULL,			/* createProc. */
    ListboxWorldChanged,	/* geometryProc. */
    NULL			/* modalProc. */
d480 1
a480 1
    ClientData clientData;	/* Either NULL or pointer to option table */
d489 13
a501 1
    optionTables = (ListboxOptionTables *)clientData;
a502 3
	Tcl_CmdInfo info;
	char *name;

d508 3
a510 2
	optionTables =
	    (ListboxOptionTables *) ckalloc(sizeof(ListboxOptionTables));
a519 17

	/* Store a pointer to the tables as the ClientData for the command */
	name = Tcl_GetString(objv[0]);
	Tcl_GetCommandInfo(interp, name, &info);
	info.objClientData = (ClientData) optionTables;
	Tcl_SetCommandInfo(interp, name, &info);
    }

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "pathName ?options?");
	return TCL_ERROR;
    }

    tkwin = Tk_CreateWindowFromPath(interp, Tk_MainWindow(interp),
            Tcl_GetString(objv[1]), (char *) NULL);
    if (tkwin == NULL) {
	return TCL_ERROR;
d528 2
a537 2
    listPtr->listVarName 		= NULL;
    listPtr->listObj 			= NULL;
a543 3
    listPtr->nElements 			= 0;
    listPtr->normalBorder 		= NULL;
    listPtr->borderWidth 		= 0;
a544 6
    listPtr->highlightWidth 		= 0;
    listPtr->highlightBgColorPtr 	= NULL;
    listPtr->highlightColorPtr 		= NULL;
    listPtr->inset 			= 0;
    listPtr->tkfont 			= NULL;
    listPtr->fgColorPtr 		= NULL;
a545 2
    listPtr->selBorder 			= NULL;
    listPtr->selBorderWidth 		= 0;
a547 4
    listPtr->width 			= 0;
    listPtr->height 			= 0;
    listPtr->lineHeight 		= 0;
    listPtr->topIndex 			= 0;
a548 3
    listPtr->partialLine 		= 0;
    listPtr->setGrid 			= 0;
    listPtr->maxWidth 			= 0;
a549 4
    listPtr->xOffset 			= 0;
    listPtr->selectMode 		= NULL;
    listPtr->numSelected 		= 0;
    listPtr->selectAnchor 		= 0;
a550 5
    listPtr->active 			= 0;
    listPtr->scanMarkX 			= 0;
    listPtr->scanMarkY 			= 0;
    listPtr->scanMarkXOffset 		= 0;
    listPtr->scanMarkYIndex 		= 0;
d552 9
a560 4
    listPtr->takeFocus 			= NULL;
    listPtr->xScrollCmd 		= NULL;
    listPtr->yScrollCmd 		= NULL;
    listPtr->flags 			= 0;
d563 1
a563 1
    TkSetClassProcs(listPtr->tkwin, &listboxClass, (ClientData) listPtr);
a616 1
    Tcl_Preserve((ClientData)listPtr);
a624 1
	Tcl_Release((ClientData)listPtr);
d628 1
d641 5
d750 5
d860 5
d1045 4
a1442 10
    listPtr->flags |= LISTBOX_DELETED;

    Tcl_DeleteCommandFromToken(listPtr->interp, listPtr->widgetCmd);
    if (listPtr->setGrid) {
	Tk_UnsetGrid(listPtr->tkwin);
    }
    if (listPtr->flags & REDRAW_PENDING) {
	Tcl_CancelIdleCall(DisplayListbox, (ClientData) listPtr);
    }

d1479 4
d1485 1
d1549 2
a1550 1
    int oldExport;
a1557 12
    
    if (Tk_SetOptions(interp, (char *)listPtr,
	    listPtr->optionTable, objc, objv, listPtr->tkwin,
	    &savedOptions, (int *)NULL) != TCL_OK) {
	Tk_RestoreSavedOptions(&savedOptions);
	return TCL_ERROR;
    }
    
    /*
     * A few options need special processing, such as setting the
     * background from a 3-D border.
     */
d1559 25
a1583 1
    Tk_SetBackgroundFromBorder(listPtr->tkwin, listPtr->normalBorder);
d1585 1
a1585 4
    if (listPtr->highlightWidth < 0) {
	listPtr->highlightWidth = 0;
    }
    listPtr->inset = listPtr->highlightWidth + listPtr->borderWidth;
d1587 4
a1590 4
    /*
     * Claim the selection if we've suddenly started exporting it and
     * there is a selection to export.
     */
d1592 4
a1595 5
    if (listPtr->exportSelection && !oldExport
	    && (listPtr->numSelected != 0)) {
	Tk_OwnSelection(listPtr->tkwin, XA_PRIMARY, ListboxLostSelection,
		(ClientData) listPtr);
    }
d1597 36
a1632 26
    
    /* Verify the current status of the list var.
     * PREVIOUS STATE    | NEW STATE     | ACTION
     * ------------------+---------------+----------------------------------
     * no listvar        | listvar       | If listvar does not exist, create
     *                                     it and copy the internal list obj's
     *                                     content to the new var.  If it does
     *                                     exist, toss the internal list obj.
     *
     * listvar           | no listvar    | Copy old listvar content to the
     *                                     internal list obj
     *
     * listvar           | listvar       | no special action
     *
     * no listvar        | no listvar    | no special action
     */
    oldListObj = listPtr->listObj;
    if (listPtr->listVarName != NULL) {
	Tcl_Obj *listVarObj = Tcl_GetVar2Ex(interp, listPtr->listVarName,
		(char *)NULL, TCL_GLOBAL_ONLY);
	int dummy;
	if (listVarObj == NULL) {
	    if (listPtr->listObj != NULL) {
		listVarObj = listPtr->listObj;
	    } else {
		listVarObj = Tcl_NewObj();
d1634 6
a1639 5
	    if (Tcl_SetVar2Ex(interp, listPtr->listVarName, (char *)NULL,
		    listVarObj, TCL_GLOBAL_ONLY) == NULL) {
		Tcl_DecrRefCount(listVarObj);
		Tk_RestoreSavedOptions(&savedOptions);
		return TCL_ERROR;
d1641 7
d1649 3
a1651 15
	/* Make sure the object is a good list object */
	if (Tcl_ListObjLength(listPtr->interp, listVarObj, &dummy) != TCL_OK) {
	    Tk_RestoreSavedOptions(&savedOptions);
	    Tcl_AppendResult(listPtr->interp, ": invalid listvar value",
		    (char *)NULL);
	    return TCL_ERROR;
	}
    
	listPtr->listObj = listVarObj;
	Tcl_TraceVar(listPtr->interp, listPtr->listVarName,
                TCL_GLOBAL_ONLY|TCL_TRACE_WRITES|TCL_TRACE_UNSETS,
                ListboxListVarProc, (ClientData) listPtr);
    } else {
	if (listPtr->listObj == NULL) {
	    listPtr->listObj = Tcl_NewObj();
d1653 1
d1655 2
a1656 3
    Tcl_IncrRefCount(listPtr->listObj);
    if (oldListObj != NULL) {
	Tcl_DecrRefCount(oldListObj);
d1662 8
a1669 3
    Tk_FreeSavedOptions(&savedOptions);
    ListboxWorldChanged((ClientData) listPtr);
    return TCL_OK;
d1744 23
a1766 1
    gcValues.foreground = listPtr->fgColorPtr->pixel;
a1767 2
    gcValues.graphics_exposures = False;
    mask = GCForeground | GCFont | GCGraphicsExposures;
d1816 1
a1816 1
    int i, limit, x, y, width, prevSelected;
d1832 3
d1842 1
d1845 4
d1852 4
d1858 1
a1858 3
    if ((listPtr->tkwin == NULL) || !Tk_IsMapped(tkwin)) {
	return;
    }
d1893 1
d1900 35
a1934 5
	/* If the item is selected, it is drawn differently */
	if (Tcl_FindHashEntry(listPtr->selection, (char *)i) != NULL) {
	    gc = listPtr->selTextGC;
	    width = Tk_Width(tkwin) - 2*listPtr->inset;
	    selectedBg = listPtr->selBorder;
d1936 15
a1950 9
	    /* If there is attribute information for this item,
	     * adjust the drawing accordingly */
	    if (entry != NULL) {
		attrs = (ItemAttr *)Tcl_GetHashValue(entry);
		/* The default GC has the settings from the widget at large */
		gcValues.foreground = listPtr->selFgColorPtr->pixel;
		gcValues.font = Tk_FontId(listPtr->tkfont);
		gcValues.graphics_exposures = False;
		mask = GCForeground | GCFont | GCGraphicsExposures;
d1952 5
a1956 2
		if (attrs->selBorder != NULL) {
		    selectedBg = attrs->selBorder;
d1958 22
a1979 4

		if (attrs->selFgColor != NULL) {
		    gcValues.foreground = attrs->selFgColor->pixel;
		    gc = Tk_GetGC(listPtr->tkwin, mask, &gcValues);
d1981 34
a2014 67
	    }

	    Tk_Fill3DRectangle(tkwin, pixmap, selectedBg, x, y,
		    width, listPtr->lineHeight, 0, TK_RELIEF_FLAT);

	    /*
	     * Draw beveled edges around the selection, if there are visible
	     * edges next to this element.  Special considerations:
	     * 1. The left and right bevels may not be visible if horizontal
	     *    scrolling is enabled (the "left" and "right" variables
	     *    are zero to indicate that the corresponding bevel is
	     *    visible).
	     * 2. Top and bottom bevels are only drawn if this is the
	     *    first or last seleted item.
	     * 3. If the left or right bevel isn't visible, then the "left"
	     *    and "right" variables, computed above, have non-zero values
	     *    that extend the top and bottom bevels so that the mitered
	     *    corners are off-screen.
	     */

	    /* Draw left bevel */
	    if (left == 0) {
		Tk_3DVerticalBevel(tkwin, pixmap, selectedBg,
			x, y, listPtr->selBorderWidth, listPtr->lineHeight,
			1, TK_RELIEF_RAISED);
	    }
	    /* Draw right bevel */
	    if (right == 0) {
		Tk_3DVerticalBevel(tkwin, pixmap, selectedBg,
			x + width - listPtr->selBorderWidth, y,
			listPtr->selBorderWidth, listPtr->lineHeight,
			0, TK_RELIEF_RAISED);
	    }
	    /* Draw top bevel */
	    if (!prevSelected) {
		Tk_3DHorizontalBevel(tkwin, pixmap, selectedBg,
			x-left, y, width+left+right, listPtr->selBorderWidth,
			1, 1, 1, TK_RELIEF_RAISED);
	    }
	    /* Draw bottom bevel */
	    if (i + 1 == listPtr->nElements ||
		    Tcl_FindHashEntry(listPtr->selection,
			    (char *)(i + 1)) == NULL ) {
		Tk_3DHorizontalBevel(tkwin, pixmap, selectedBg, x-left,
			y + listPtr->lineHeight - listPtr->selBorderWidth,
			width+left+right, listPtr->selBorderWidth, 0, 0, 0,
			TK_RELIEF_RAISED);
	    }
	    prevSelected = 1;
	} else {
	    /* If there is an item attributes record for this item,
	     * draw the background box and set the foreground color
	     * accordingly */
	    if (entry != NULL) {
		attrs = (ItemAttr *)Tcl_GetHashValue(entry);
		gcValues.foreground = listPtr->fgColorPtr->pixel;
		gcValues.font = Tk_FontId(listPtr->tkfont);
		gcValues.graphics_exposures = False;
		mask = GCForeground | GCFont | GCGraphicsExposures;
		if (attrs->border != NULL) {
		    width = Tk_Width(tkwin) - 2*listPtr->inset;
		    Tk_Fill3DRectangle(tkwin, pixmap, attrs->border, x, y,
			    width, listPtr->lineHeight, 0, TK_RELIEF_FLAT);
		}
		if (attrs->fgColor != NULL) {
		    gcValues.foreground = attrs->fgColor->pixel;
		    gc = Tk_GetGC(listPtr->tkwin, mask, &gcValues);
d2016 1
a2017 1
	    prevSelected = 0;
d2029 1
a2029 1
	/* If this is the active element, underline it. */
d2031 60
a2090 2
	    Tk_UnderlineChars(listPtr->display, pixmap, gc, listPtr->tkfont,
		    stringRep, x, y, 0, stringLen);
d2524 11
a2534 1
	DestroyListbox((char *) clientData);
d2776 3
d2781 1
d3152 1
a3152 1
	    || (listPtr->tkwin == NULL)
d3306 2
a3307 2
    char *name1;                /* Not used. */
    char *name2;                /* Not used. */
a3453 2


@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tkListbox.c,v 1.12 1999/01/26 04:11:23 jingham Exp $
d21 7
a27 24
/*
 * One record of the following type is kept for each element
 * associated with a listbox widget:
 */

typedef struct Element {
    int textLength;		/* # non-NULL characters in text. */
    int lBearing;		/* Distance from first character's
				 * origin to left edge of character. */
    int pixelWidth;		/* Total width of element in pixels (including
				 * left bearing and right bearing). */
    int selected;		/* 1 means this item is selected, 0 means
				 * it isn't. */
    struct Element *nextPtr;	/* Next in list of all elements of this
				 * listbox, or NULL for last element. */
    char text[4];		/* Characters of this element, NULL-
				 * terminated.  The actual space allocated
				 * here will be as large as needed (> 4,
				 * most likely).  Must be the last field
				 * of the record. */
} Element;

#define ElementSize(stringLength) \
	((unsigned) (sizeof(Element) - 3 + stringLength))
d44 10
a53 5
    int numElements;		/* Total number of elements in this listbox. */
    Element *firstPtr;		/* First in list of elements (NULL if no
				 * elements). */
    Element *lastPtr;		/* Last in list of elements (NULL if no
				 * elements). */
d163 11
d185 2
d193 2
d197 2
a198 1
 * Information used for argv parsing:
d200 67
d268 26
a293 67
static Tk_ConfigSpec configSpecs[] = {
    {TK_CONFIG_BORDER, "-background", "background", "Background",
	DEF_LISTBOX_BG_COLOR, Tk_Offset(Listbox, normalBorder),
	TK_CONFIG_COLOR_ONLY},
    {TK_CONFIG_BORDER, "-background", "background", "Background",
	DEF_LISTBOX_BG_MONO, Tk_Offset(Listbox, normalBorder),
	TK_CONFIG_MONO_ONLY},
    {TK_CONFIG_SYNONYM, "-bd", "borderWidth", (char *) NULL,
	(char *) NULL, 0, 0},
    {TK_CONFIG_SYNONYM, "-bg", "background", (char *) NULL,
	(char *) NULL, 0, 0},
    {TK_CONFIG_PIXELS, "-borderwidth", "borderWidth", "BorderWidth",
	DEF_LISTBOX_BORDER_WIDTH, Tk_Offset(Listbox, borderWidth), 0},
    {TK_CONFIG_ACTIVE_CURSOR, "-cursor", "cursor", "Cursor",
	DEF_LISTBOX_CURSOR, Tk_Offset(Listbox, cursor), TK_CONFIG_NULL_OK},
    {TK_CONFIG_BOOLEAN, "-exportselection", "exportSelection",
	"ExportSelection", DEF_LISTBOX_EXPORT_SELECTION,
	Tk_Offset(Listbox, exportSelection), 0},
    {TK_CONFIG_SYNONYM, "-fg", "foreground", (char *) NULL,
	(char *) NULL, 0, 0},
    {TK_CONFIG_FONT, "-font", "font", "Font",
	DEF_LISTBOX_FONT, Tk_Offset(Listbox, tkfont), 0},
    {TK_CONFIG_COLOR, "-foreground", "foreground", "Foreground",
	DEF_LISTBOX_FG, Tk_Offset(Listbox, fgColorPtr), 0},
    {TK_CONFIG_INT, "-height", "height", "Height",
	DEF_LISTBOX_HEIGHT, Tk_Offset(Listbox, height), 0},
    {TK_CONFIG_COLOR, "-highlightbackground", "highlightBackground",
	"HighlightBackground", DEF_LISTBOX_HIGHLIGHT_BG,
	Tk_Offset(Listbox, highlightBgColorPtr), 0},
    {TK_CONFIG_COLOR, "-highlightcolor", "highlightColor", "HighlightColor",
	DEF_LISTBOX_HIGHLIGHT, Tk_Offset(Listbox, highlightColorPtr), 0},
    {TK_CONFIG_PIXELS, "-highlightthickness", "highlightThickness",
	"HighlightThickness",
	DEF_LISTBOX_HIGHLIGHT_WIDTH, Tk_Offset(Listbox, highlightWidth), 0},
    {TK_CONFIG_RELIEF, "-relief", "relief", "Relief",
	DEF_LISTBOX_RELIEF, Tk_Offset(Listbox, relief), 0},
    {TK_CONFIG_BORDER, "-selectbackground", "selectBackground", "Foreground",
	DEF_LISTBOX_SELECT_COLOR, Tk_Offset(Listbox, selBorder),
	TK_CONFIG_COLOR_ONLY},
    {TK_CONFIG_BORDER, "-selectbackground", "selectBackground", "Foreground",
	DEF_LISTBOX_SELECT_MONO, Tk_Offset(Listbox, selBorder),
	TK_CONFIG_MONO_ONLY},
    {TK_CONFIG_PIXELS, "-selectborderwidth", "selectBorderWidth", "BorderWidth",
	DEF_LISTBOX_SELECT_BD, Tk_Offset(Listbox, selBorderWidth), 0},
    {TK_CONFIG_COLOR, "-selectforeground", "selectForeground", "Background",
	DEF_LISTBOX_SELECT_FG_COLOR, Tk_Offset(Listbox, selFgColorPtr),
	TK_CONFIG_COLOR_ONLY},
    {TK_CONFIG_COLOR, "-selectforeground", "selectForeground", "Background",
	DEF_LISTBOX_SELECT_FG_MONO, Tk_Offset(Listbox, selFgColorPtr),
	TK_CONFIG_MONO_ONLY},
    {TK_CONFIG_UID, "-selectmode", "selectMode", "SelectMode",
	DEF_LISTBOX_SELECT_MODE, Tk_Offset(Listbox, selectMode), 0},
    {TK_CONFIG_BOOLEAN, "-setgrid", "setGrid", "SetGrid",
	DEF_LISTBOX_SET_GRID, Tk_Offset(Listbox, setGrid), 0},
    {TK_CONFIG_STRING, "-takefocus", "takeFocus", "TakeFocus",
	DEF_LISTBOX_TAKE_FOCUS, Tk_Offset(Listbox, takeFocus),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_INT, "-width", "width", "Width",
	DEF_LISTBOX_WIDTH, Tk_Offset(Listbox, width), 0},
    {TK_CONFIG_STRING, "-xscrollcommand", "xScrollCommand", "ScrollCommand",
	DEF_LISTBOX_SCROLL_COMMAND, Tk_Offset(Listbox, xScrollCmd),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_STRING, "-yscrollcommand", "yScrollCommand", "ScrollCommand",
	DEF_LISTBOX_SCROLL_COMMAND, Tk_Offset(Listbox, yScrollCmd),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_END, (char *) NULL, (char *) NULL, (char *) NULL,
	(char *) NULL, 0, 0}
d297 43
a339 2
 * Forward declarations for procedures defined later in this file:
 */
d341 1
d347 1
a347 1
			    Listbox *listPtr, int argc, char **argv,
d349 5
a353 2
static void		DeleteEls _ANSI_ARGS_((Listbox *listPtr, int first,
			    int last));
d355 2
d359 1
a359 1
			    Listbox *listPtr, char *string, int endIsSize,
d361 2
a362 2
static void		InsertEls _ANSI_ARGS_((Listbox *listPtr, int index,
			    int argc, char **argv));
d374 1
a374 1
static void		ListboxRedrawRange _ANSI_ARGS_((Listbox *listPtr,
d378 1
a378 1
static void		ListboxSelect _ANSI_ARGS_((Listbox *listPtr,
d380 20
a399 4
static void		ListboxUpdateHScrollbar _ANSI_ARGS_((Listbox *listPtr));
static void		ListboxUpdateVScrollbar _ANSI_ARGS_((Listbox *listPtr));
static int		ListboxWidgetCmd _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, int argc, char **argv));
d404 5
a408 1

d424 1
a424 1
 * Tk_ListboxCmd --
d440 2
a441 3
Tk_ListboxCmd(clientData, interp, argc, argv)
    ClientData clientData;	/* Main window associated with
				 * interpreter. */
d443 2
a444 2
    int argc;			/* Number of arguments. */
    char **argv;		/* Argument strings. */
d447 2
a448 2
    Tk_Window new;
    Tk_Window tkwin = (Tk_Window) clientData;
d450 31
a480 3
    if (argc < 2) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
		argv[0], " pathName ?options?\"", (char *) NULL);
d484 3
a486 2
    new = Tk_CreateWindowFromPath(interp, tkwin, argv[1], (char *) NULL);
    if (new == NULL) {
d495 6
a500 7

    listPtr = (Listbox *) ckalloc(sizeof(Listbox));
    listPtr->tkwin = new;
    listPtr->display = Tk_Display(new);
    listPtr->interp = interp;
    listPtr->widgetCmd = Tcl_CreateCommand(interp,
	    Tk_PathName(listPtr->tkwin), ListboxWidgetCmd,
d502 49
a550 41
    listPtr->numElements = 0;
    listPtr->firstPtr = NULL;
    listPtr->lastPtr = NULL;
    listPtr->normalBorder = NULL;
    listPtr->borderWidth = 0;
    listPtr->relief = TK_RELIEF_RAISED;
    listPtr->highlightWidth = 0;
    listPtr->highlightBgColorPtr = NULL;
    listPtr->highlightColorPtr = NULL;
    listPtr->inset = 0;
    listPtr->tkfont = NULL;
    listPtr->fgColorPtr = NULL;
    listPtr->textGC = None;
    listPtr->selBorder = NULL;
    listPtr->selBorderWidth = 0;
    listPtr->selFgColorPtr = None;
    listPtr->selTextGC = None;
    listPtr->width = 0;
    listPtr->height = 0;
    listPtr->lineHeight = 0;
    listPtr->topIndex = 0;
    listPtr->fullLines = 1;
    listPtr->partialLine = 0;
    listPtr->setGrid = 0;
    listPtr->maxWidth = 0;
    listPtr->xScrollUnit = 1;
    listPtr->xOffset = 0;
    listPtr->selectMode = NULL;
    listPtr->numSelected = 0;
    listPtr->selectAnchor = 0;
    listPtr->exportSelection = 1;
    listPtr->active = 0;
    listPtr->scanMarkX = 0;
    listPtr->scanMarkY = 0;
    listPtr->scanMarkXOffset = 0;
    listPtr->scanMarkYIndex = 0;
    listPtr->cursor = None;
    listPtr->takeFocus = NULL;
    listPtr->xScrollCmd = NULL;
    listPtr->yScrollCmd = NULL;
    listPtr->flags = 0;
d559 4
a562 2
    if (ConfigureListbox(interp, listPtr, argc-2, argv+2, 0) != TCL_OK) {
	goto error;
d565 6
a570 1
    interp->result = Tk_PathName(listPtr->tkwin);
a571 4

    error:
    Tk_DestroyWindow(listPtr->tkwin);
    return TCL_ERROR;
d575 1
a575 1
 *--------------------------------------------------------------
d577 1
a577 1
 * ListboxWidgetCmd --
d579 3
a581 3
 *	This procedure is invoked to process the Tcl command
 *	that corresponds to a widget managed by this module.
 *	See the user documentation for details on what it does.
d589 1
a589 1
 *--------------------------------------------------------------
d593 1
a593 1
ListboxWidgetCmd(clientData, interp, argc, argv)
d596 2
a597 2
    int argc;				/* Number of arguments. */
    char **argv;			/* Argument strings. */
d600 1
d602 6
a607 3
    size_t length;
    int c;
    Tk_FontMetrics fm;
d609 9
a617 4
    if (argc < 2) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
		argv[0], " option ?arg arg ...?\"", (char *) NULL);
	return TCL_ERROR;
d619 77
a695 52
    Tcl_Preserve((ClientData) listPtr);
    c = argv[1][0];
    length = strlen(argv[1]);
    if ((c == 'a') && (strncmp(argv[1], "activate", length) == 0)) {
	int index;

	if (argc != 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " activate index\"",
		    (char *) NULL);
	    goto error;
	}
	ListboxRedrawRange(listPtr, listPtr->active, listPtr->active);
	if (GetListboxIndex(interp, listPtr, argv[2], 0, &index) != TCL_OK) {
	    goto error;
	}
	if (index >= listPtr->numElements) {
	    index = listPtr->numElements-1;
	}
	if (index < 0) {
	    index = 0;
	}
	listPtr->active = index;
	ListboxRedrawRange(listPtr, listPtr->active, listPtr->active);
    } else if ((c == 'b') && (strncmp(argv[1], "bbox", length) == 0)) {
	int index, x, y, i;
	Element *elPtr;

	if (argc != 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " bbox index\"", (char *) NULL);
	    goto error;
	}
	if (GetListboxIndex(interp, listPtr, argv[2], 0, &index) != TCL_OK) {
	    goto error;
	}
	if ((index >= listPtr->numElements) || (index < 0)) {
	    goto done;
	}
	for (i = 0, elPtr = listPtr->firstPtr; i < index;
		i++, elPtr = elPtr->nextPtr) {
	    /* Empty loop body. */
	}
	if ((index >= listPtr->topIndex) && (index < listPtr->numElements)
		    && (index < (listPtr->topIndex + listPtr->fullLines
		    + listPtr->partialLine))) {
	    x = listPtr->inset + listPtr->selBorderWidth - listPtr->xOffset;
	    y = ((index - listPtr->topIndex)*listPtr->lineHeight)
		    + listPtr->inset + listPtr->selBorderWidth;
	    Tk_GetFontMetrics(listPtr->tkfont, &fm);
	    sprintf(interp->result, "%d %d %d %d", x, y, elPtr->pixelWidth,
		    fm.linespace);
d697 24
a720 21
    } else if ((c == 'c') && (strncmp(argv[1], "cget", length) == 0)
	    && (length >= 2)) {
	if (argc != 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " cget option\"",
		    (char *) NULL);
	    goto error;
	}
	result = Tk_ConfigureValue(interp, listPtr->tkwin, configSpecs,
		(char *) listPtr, argv[2], 0);
    } else if ((c == 'c') && (strncmp(argv[1], "configure", length) == 0)
	    && (length >= 2)) {
	if (argc == 2) {
	    result = Tk_ConfigureInfo(interp, listPtr->tkwin, configSpecs,
		    (char *) listPtr, (char *) NULL, 0);
	} else if (argc == 3) {
	    result = Tk_ConfigureInfo(interp, listPtr->tkwin, configSpecs,
		    (char *) listPtr, argv[2], 0);
	} else {
	    result = ConfigureListbox(interp, listPtr, argc-2, argv+2,
		    TK_CONFIG_ARGV_ONLY);
d722 27
a748 43
    } else if ((c == 'c') && (strncmp(argv[1], "curselection", length) == 0)
	    && (length >= 2)) {
	int i, count;
	char index[20];
	Element *elPtr;

	if (argc != 2) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " curselection\"",
		    (char *) NULL);
	    goto error;
	}
	count = 0;
	for (i = 0, elPtr = listPtr->firstPtr; elPtr != NULL;
		i++, elPtr = elPtr->nextPtr) {
	    if (elPtr->selected) {
		sprintf(index, "%d", i);
		Tcl_AppendElement(interp, index);
		count++;
	    }
	}
	if (count != listPtr->numSelected) {
	    panic("ListboxWidgetCmd: selection count incorrect");
	}
    } else if ((c == 'd') && (strncmp(argv[1], "delete", length) == 0)) {
	int first, last;

	if ((argc < 3) || (argc > 4)) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " delete firstIndex ?lastIndex?\"",
		    (char *) NULL);
	    goto error;
	}
	if (GetListboxIndex(interp, listPtr, argv[2], 0, &first) != TCL_OK) {
	    goto error;
	}
	if (first < listPtr->numElements) {
	    if (argc == 3) {
		last = first;
	    } else {
		if (GetListboxIndex(interp, listPtr, argv[3], 0,
			&last) != TCL_OK) {
		    goto error;
d750 2
a751 2
		if (last >= listPtr->numElements) {
		    last = listPtr->numElements-1;
d753 3
d757 1
a757 1
	    DeleteEls(listPtr, first, last);
a758 3
    } else if ((c == 'g') && (strncmp(argv[1], "get", length) == 0)) {
	int first, last, i;
	Element *elPtr;
d760 50
a809 17
	if ((argc != 3) && (argc != 4)) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " get first ?last?\"", (char *) NULL);
	    goto error;
	}
	if (GetListboxIndex(interp, listPtr, argv[2], 0, &first) != TCL_OK) {
	    goto error;
	}
	if ((argc == 4) && (GetListboxIndex(interp, listPtr, argv[3],
		0, &last) != TCL_OK)) {
	    goto error;
	}
	if (first >= listPtr->numElements) {
	    goto done;
	}
	if (last >= listPtr->numElements) {
	    last = listPtr->numElements-1;
d812 109
a920 3
	for (elPtr = listPtr->firstPtr, i = 0; i < first;
		i++, elPtr = elPtr->nextPtr) {
	    /* Empty loop body. */
d922 48
a969 4
	if (elPtr != NULL) {
	    if (argc == 3) {
		if (first >= 0) {
		    interp->result = elPtr->text;
d971 3
a973 3
	    } else {
		for (  ; i <= last; i++, elPtr = elPtr->nextPtr) {
		    Tcl_AppendElement(interp, elPtr->text);
d976 2
d979 17
a995 94
    } else if ((c == 'i') && (strncmp(argv[1], "index", length) == 0)
	    && (length >= 3)) {
	int index;

	if (argc != 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " index index\"",
		    (char *) NULL);
	    goto error;
	}
	if (GetListboxIndex(interp, listPtr, argv[2], 1, &index)
		!= TCL_OK) {
	    goto error;
	}
	sprintf(interp->result, "%d", index);
    } else if ((c == 'i') && (strncmp(argv[1], "insert", length) == 0)
	    && (length >= 3)) {
	int index;

	if (argc < 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " insert index ?element element ...?\"",
		    (char *) NULL);
	    goto error;
	}
	if (GetListboxIndex(interp, listPtr, argv[2], 1, &index)
		!= TCL_OK) {
	    goto error;
	}
	InsertEls(listPtr, index, argc-3, argv+3);
    } else if ((c == 'n') && (strncmp(argv[1], "nearest", length) == 0)) {
	int index, y;

	if (argc != 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " nearest y\"", (char *) NULL);
	    goto error;
	}
	if (Tcl_GetInt(interp, argv[2], &y) != TCL_OK) {
	    goto error;
	}
	index = NearestListboxElement(listPtr, y);
	sprintf(interp->result, "%d", index);
    } else if ((c == 's') && (length >= 2)
	    && (strncmp(argv[1], "scan", length) == 0)) {
	int x, y;

	if (argc != 5) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " scan mark|dragto x y\"", (char *) NULL);
	    goto error;
	}
	if ((Tcl_GetInt(interp, argv[3], &x) != TCL_OK)
		|| (Tcl_GetInt(interp, argv[4], &y) != TCL_OK)) {
	    goto error;
	}
	if ((argv[2][0] == 'm')
		&& (strncmp(argv[2], "mark", strlen(argv[2])) == 0)) {
	    listPtr->scanMarkX = x;
	    listPtr->scanMarkY = y;
	    listPtr->scanMarkXOffset = listPtr->xOffset;
	    listPtr->scanMarkYIndex = listPtr->topIndex;
	} else if ((argv[2][0] == 'd')
		&& (strncmp(argv[2], "dragto", strlen(argv[2])) == 0)) {
	    ListboxScanTo(listPtr, x, y);
	} else {
	    Tcl_AppendResult(interp, "bad scan option \"", argv[2],
		    "\": must be mark or dragto", (char *) NULL);
	    goto error;
	}
    } else if ((c == 's') && (strncmp(argv[1], "see", length) == 0)
	    && (length >= 3)) {
	int index, diff;
	if (argc != 3) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " see index\"",
		    (char *) NULL);
	    goto error;
	}
	if (GetListboxIndex(interp, listPtr, argv[2], 0, &index) != TCL_OK) {
	    goto error;
	}
	if (index >= listPtr->numElements) {
	    index = listPtr->numElements-1;
	}
	if (index < 0) {
	    index = 0;
	}
	diff = listPtr->topIndex-index;
	if (diff > 0) {
	    if (diff <= (listPtr->fullLines/3)) {
		ChangeListboxView(listPtr, index);
	    } else {
		ChangeListboxView(listPtr, index - (listPtr->fullLines-1)/2);
d997 1
a997 2
	} else {
	    diff = index - (listPtr->topIndex + listPtr->fullLines - 1);
d1000 1
a1000 1
		    ChangeListboxView(listPtr, listPtr->topIndex + diff);
d1005 10
d1016 2
d1019 12
a1030 16
    } else if ((c == 's') && (length >= 3)
	    && (strncmp(argv[1], "selection", length) == 0)) {
	int first, last;

	if ((argc != 4) && (argc != 5)) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " selection option index ?index?\"",
		    (char *) NULL);
	    goto error;
	}
	if (GetListboxIndex(interp, listPtr, argv[3], 0, &first) != TCL_OK) {
	    goto error;
	}
	if (argc == 5) {
	    if (GetListboxIndex(interp, listPtr, argv[4], 0, &last) != TCL_OK) {
		goto error;
d1032 118
a1149 2
	} else {
	    last = first;
d1151 11
a1161 7
	length = strlen(argv[2]);
	c = argv[2][0];
	if ((c == 'a') && (strncmp(argv[2], "anchor", length) == 0)) {
	    if (argc != 4) {
		Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " selection anchor index\"", (char *) NULL);
		goto error;
d1163 2
a1164 2
	    if (first >= listPtr->numElements) {
		first = listPtr->numElements-1;
d1170 11
a1180 18
	} else if ((c == 'c') && (strncmp(argv[2], "clear", length) == 0)) {
	    ListboxSelect(listPtr, first, last, 0);
	} else if ((c == 'i') && (strncmp(argv[2], "includes", length) == 0)) {
	    int i;
	    Element *elPtr;
    
	    if (argc != 4) {
		Tcl_AppendResult(interp, "wrong # args: should be \"",
			argv[0], " selection includes index\"", (char *) NULL);
		goto error;
	    }
	    if ((first < 0) || (first >= listPtr->numElements)) {
		interp->result = "0";
		goto done;
	    }
	    for (elPtr = listPtr->firstPtr, i = 0; i < first;
		    i++, elPtr = elPtr->nextPtr) {
		/* Empty loop body. */
d1182 2
a1183 2
	    if (elPtr->selected) {
		interp->result = "1";
d1185 1
a1185 1
		interp->result = "0";
d1187 44
a1230 2
	} else if ((c == 's') && (strncmp(argv[2], "set", length) == 0)) {
	    ListboxSelect(listPtr, first, last, 1);
d1232 7
a1238 31
	    Tcl_AppendResult(interp, "bad selection option \"", argv[2],
		    "\": must be anchor, clear, includes, or set",
		    (char *) NULL);
	    goto error;
	}
    } else if ((c == 's') && (length >= 2)
	    && (strncmp(argv[1], "size", length) == 0)) {
	if (argc != 2) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " size\"", (char *) NULL);
	    goto error;
	}
	sprintf(interp->result, "%d", listPtr->numElements);
    } else if ((c == 'x') && (strncmp(argv[1], "xview", length) == 0)) {
	int index, count, type, windowWidth, windowUnits;
	int offset = 0;		/* Initialized to stop gcc warnings. */
	double fraction, fraction2;

	windowWidth = Tk_Width(listPtr->tkwin)
	    - 2*(listPtr->inset + listPtr->selBorderWidth);
	if (argc == 2) {
	    if (listPtr->maxWidth == 0) {
		interp->result = "0 1";
	    } else {
		fraction = listPtr->xOffset/((double) listPtr->maxWidth);
		fraction2 = (listPtr->xOffset + windowWidth)
			/((double) listPtr->maxWidth);
		if (fraction2 > 1.0) {
		    fraction2 = 1.0;
		}
		sprintf(interp->result, "%g %g", fraction, fraction2);
d1240 22
a1261 23
	} else if (argc == 3) {
	    if (Tcl_GetInt(interp, argv[2], &index) != TCL_OK) {
		goto error;
	    }
	    ChangeListboxOffset(listPtr, index*listPtr->xScrollUnit);
	} else {
	    type = Tk_GetScrollInfo(interp, argc, argv, &fraction, &count);
	    switch (type) {
		case TK_SCROLL_ERROR:
		    goto error;
		case TK_SCROLL_MOVETO:
		    offset = (int) (fraction*listPtr->maxWidth + 0.5);
		    break;
		case TK_SCROLL_PAGES:
		    windowUnits = windowWidth/listPtr->xScrollUnit;
		    if (windowUnits > 2) {
			offset = listPtr->xOffset
				+ count*listPtr->xScrollUnit*(windowUnits-2);
		    } else {
			offset = listPtr->xOffset + count*listPtr->xScrollUnit;
		    }
		    break;
		case TK_SCROLL_UNITS:
d1263 5
a1267 3
		    break;
	    }
	    ChangeListboxOffset(listPtr, offset);
d1269 34
a1302 22
    } else if ((c == 'y') && (strncmp(argv[1], "yview", length) == 0)) {
	int index, count, type;
	double fraction, fraction2;

	if (argc == 2) {
	    if (listPtr->numElements == 0) {
		interp->result = "0 1";
	    } else {
		fraction = listPtr->topIndex/((double) listPtr->numElements);
		fraction2 = (listPtr->topIndex+listPtr->fullLines)
			/((double) listPtr->numElements);
		if (fraction2 > 1.0) {
		    fraction2 = 1.0;
		}
		sprintf(interp->result, "%g %g", fraction, fraction2);
	    }
	} else if (argc == 3) {
	    if (GetListboxIndex(interp, listPtr, argv[2], 0, &index)
		    != TCL_OK) {
		goto error;
	    }
	    ChangeListboxView(listPtr, index);
d1304 29
a1332 16
	    type = Tk_GetScrollInfo(interp, argc, argv, &fraction, &count);
	    switch (type) {
		case TK_SCROLL_ERROR:
		    goto error;
		case TK_SCROLL_MOVETO:
		    index = (int) (listPtr->numElements*fraction + 0.5);
		    break;
		case TK_SCROLL_PAGES:
		    if (listPtr->fullLines > 2) {
			index = listPtr->topIndex
				+ count*(listPtr->fullLines-2);
		    } else {
			index = listPtr->topIndex + count;
		    }
		    break;
		case TK_SCROLL_UNITS:
d1334 5
a1338 3
		    break;
	    }
	    ChangeListboxView(listPtr, index);
d1340 1
a1340 7
    } else {
	Tcl_AppendResult(interp, "bad option \"", argv[1],
		"\": must be activate, bbox, cget, configure, ",
		"curselection, delete, get, index, insert, nearest, ",
		"scan, see, selection, size, ",
		"xview, or yview", (char *) NULL);
	goto error;
d1342 30
a1371 3
    done:
    Tcl_Release((ClientData) listPtr);
    return result;
d1373 14
a1386 3
    error:
    Tcl_Release((ClientData) listPtr);
    return TCL_ERROR;
d1412 12
a1423 1
    register Element *elPtr, *nextPtr;
d1425 5
a1429 3
    /*
     * Free up all of the list elements.
     */
d1431 4
a1434 4
    for (elPtr = listPtr->firstPtr; elPtr != NULL; ) {
	nextPtr = elPtr->nextPtr;
	ckfree((char *) elPtr);
	elPtr = nextPtr;
d1436 12
d1459 33
a1491 4
	Tk_FreeGC(listPtr->display, listPtr->selTextGC);
    }
    Tk_FreeOptions(configSpecs, (char *) listPtr, listPtr->display, 0);
    ckfree((char *) listPtr);
d1499 1
a1499 1
 *	This procedure is called to process an argv/argc list, plus
d1505 1
a1505 1
 *	returned, then interp->result contains an error message.
d1516 1
a1516 1
ConfigureListbox(interp, listPtr, argc, argv, flags)
d1520 2
a1521 2
    int argc;			/* Number of valid entries in argv. */
    char **argv;		/* Arguments. */
d1524 2
d1529 10
a1538 2
    if (Tk_ConfigureWidget(interp, listPtr->tkwin, configSpecs,
	    argc, argv, (char *) listPtr, flags) != TCL_OK) {
d1541 1
a1541 1

d1565 103
d1698 1
a1698 1

d1705 1
a1705 2
    gc = Tk_GetGCColor(listPtr->tkwin, mask, &gcValues, listPtr->fgColorPtr,
		       NULL);
d1714 1
a1714 2
    gc = Tk_GetGCColor(listPtr->tkwin, mask, &gcValues, listPtr->selFgColorPtr,
		       NULL);
d1727 1
a1727 1
    ListboxRedrawRange(listPtr, 0, listPtr->numElements-1);
a1751 1
    register Element *elPtr;
d1755 8
d1769 7
d1800 1
a1800 6
    /*
     * Iterate through all of the elements of the listbox, displaying each
     * in turn.  Selected elements use a different GC and have a raised
     * background.
     */

d1802 2
a1803 2
    if (limit >= listPtr->numElements) {
	limit = listPtr->numElements-1;
d1814 2
a1815 5
    for (elPtr = listPtr->firstPtr, i = 0; (elPtr != NULL) && (i <= limit);
	    prevSelected = elPtr->selected, elPtr = elPtr->nextPtr, i++) {
	if (i < listPtr->topIndex) {
	    continue;
	}
d1820 8
a1827 1
	if (elPtr->selected) {
d1830 23
a1852 1
	    Tk_Fill3DRectangle(tkwin, pixmap, listPtr->selBorder, x, y,
d1870 1
d1872 1
a1872 1
		Tk_3DVerticalBevel(tkwin, pixmap, listPtr->selBorder,
d1876 1
d1878 1
a1878 1
		Tk_3DVerticalBevel(tkwin, pixmap, listPtr->selBorder,
d1883 1
d1885 1
a1885 1
		Tk_3DHorizontalBevel(tkwin, pixmap, listPtr->selBorder,
d1889 5
a1893 2
	    if ((elPtr->nextPtr == NULL) || !elPtr->nextPtr->selected) {
		Tk_3DHorizontalBevel(tkwin, pixmap, listPtr->selBorder, x-left,
d1898 22
d1921 2
d1925 3
a1927 2
	x = listPtr->inset + listPtr->selBorderWidth - elPtr->lBearing
		- listPtr->xOffset;
d1929 1
a1929 5
		elPtr->text, elPtr->textLength, x, y);

	/*
	 * If this is the active element, underline it.
	 */
d1931 1
d1934 1
a1934 1
		    elPtr->text, x, y, 0, elPtr->textLength);
d1949 1
a1949 1
	GC gc;
d1951 1
d1953 3
a1955 1
	    gc = Tk_GCForColor(listPtr->highlightColorPtr, pixmap);
d1957 2
a1958 1
	    gc = Tk_GCForColor(listPtr->highlightBgColorPtr, pixmap);
a1959 1
	Tk_DrawFocusHighlight(tkwin, gc, listPtr->highlightWidth, pixmap);
a2001 1
    register Element *elPtr;
d2004 5
a2008 1

d2015 6
a2020 5
	for (elPtr = listPtr->firstPtr; elPtr != NULL; elPtr = elPtr->nextPtr) {
	    if (fontChanged) {
		elPtr->pixelWidth = Tk_TextWidth(listPtr->tkfont,
			elPtr->text, elPtr->textLength);
		elPtr->lBearing = 0;
d2022 5
a2026 2
	    if (elPtr->pixelWidth > listPtr->maxWidth) {
		listPtr->maxWidth = elPtr->pixelWidth;
d2045 1
a2045 1
	height = listPtr->numElements;
d2066 1
a2066 1
 * InsertEls --
d2068 2
a2069 1
 *	Add new elements to a listbox widget.
d2072 1
a2072 1
 *	None.
d2075 2
a2076 2
 *	New information gets added to listPtr;  it will be redisplayed
 *	soon, but not immediately.
d2081 2
a2082 2
static void
InsertEls(listPtr, index, argc, argv)
d2087 2
a2088 2
    int argc;			/* Number of new elements to add. */
    char **argv;		/* New elements (one per entry). */
d2090 18
a2107 9
    register Element *prevPtr, *newPtr;
    int length, i, oldMaxWidth;

    /*
     * Find the element before which the new ones will be inserted.
     */

    if (index <= 0) {
	index = 0;
d2109 12
a2120 2
    if (index > listPtr->numElements) {
	index = listPtr->numElements;
d2122 4
a2125 8
    if (index == 0) {
	prevPtr = NULL;
    } else if (index == listPtr->numElements) {
          prevPtr = listPtr->lastPtr;
    } else {
	for (prevPtr = listPtr->firstPtr, i = index - 1; i > 0; i--) {
	    prevPtr = prevPtr->nextPtr;
	}
d2128 6
a2133 4
    /*
     * For each new element, create a record, initialize it, and link
     * it into the list of elements.
     */
d2135 6
a2140 19
    oldMaxWidth = listPtr->maxWidth;
    for (i = argc ; i > 0; i--, argv++, prevPtr = newPtr) {
	length = strlen(*argv);
	newPtr = (Element *) ckalloc(ElementSize(length));
	newPtr->textLength = length;
	strcpy(newPtr->text, *argv);
	newPtr->pixelWidth = Tk_TextWidth(listPtr->tkfont, newPtr->text,
		newPtr->textLength);
	newPtr->lBearing = 0;
	if (newPtr->pixelWidth > listPtr->maxWidth) {
	    listPtr->maxWidth = newPtr->pixelWidth;
	}
	newPtr->selected = 0;
	if (prevPtr == NULL) {
	    newPtr->nextPtr = listPtr->firstPtr;
	    listPtr->firstPtr = newPtr;
	} else {
	    newPtr->nextPtr = prevPtr->nextPtr;
	    prevPtr->nextPtr = newPtr;
a2142 4
    if ((prevPtr != NULL) && (prevPtr->nextPtr == NULL)) {
	listPtr->lastPtr = prevPtr;
    }
    listPtr->numElements += argc;
d2144 3
d2148 2
a2149 2
     * Update the selection and other indexes to account for the
     * renumbering that has just occurred.  Then arrange for the new
d2154 1
a2154 1
	listPtr->selectAnchor += argc;
d2157 1
a2157 1
	listPtr->topIndex += argc;
d2160 4
a2163 4
	listPtr->active += argc;
	if ((listPtr->active >= listPtr->numElements)
		&& (listPtr->numElements > 0)) {
	    listPtr->active = listPtr->numElements-1;
d2171 2
a2172 1
    ListboxRedrawRange(listPtr, index, listPtr->numElements-1);
d2178 1
a2178 1
 * DeleteEls --
d2180 2
a2181 1
 *	Remove one or more elements from a listbox widget.
d2184 1
a2184 1
 *	None.
d2187 1
a2187 2
 *	Memory gets freed, the listbox gets modified and (eventually)
 *	redisplayed.
d2192 2
a2193 2
static void
DeleteEls(listPtr, first, last)
a2197 1
    register Element *prevPtr, *elPtr;
d2199 8
a2206 1

d2215 2
a2216 2
    if (last >= listPtr->numElements) {
	last = listPtr->numElements-1;
d2220 1
a2220 1
	return;
d2224 5
a2228 1
     * Find the element just before the ones to delete.
d2230 27
d2258 9
a2266 2
    if (first == 0) {
	prevPtr = NULL;
d2268 6
a2273 3
	for (i = first-1, prevPtr = listPtr->firstPtr; i > 0; i--) {
	    prevPtr = prevPtr->nextPtr;
	}
d2276 6
a2281 3
    /*
     * Delete the requested number of elements.
     */
d2283 9
a2291 14
    widthChanged = 0;
    for (i = count; i > 0; i--) {
	if (prevPtr == NULL) {
	    elPtr = listPtr->firstPtr;
	    listPtr->firstPtr = elPtr->nextPtr;
	    if (listPtr->firstPtr == NULL) {
		listPtr->lastPtr = NULL;
	    }
	} else {
	    elPtr = prevPtr->nextPtr;
	    prevPtr->nextPtr = elPtr->nextPtr;
	    if (prevPtr->nextPtr == NULL) {
		listPtr->lastPtr = prevPtr;
	    }
a2292 7
	if (elPtr->pixelWidth == listPtr->maxWidth) {
	    widthChanged = 1;
	}
	if (elPtr->selected) {
	    listPtr->numSelected -= 1;
	}
	ckfree((char *) elPtr);
a2293 1
    listPtr->numElements -= count;
d2313 2
a2314 2
    if (listPtr->topIndex > (listPtr->numElements - listPtr->fullLines)) {
	listPtr->topIndex = listPtr->numElements - listPtr->fullLines;
d2323 3
a2325 3
	if ((listPtr->active >= listPtr->numElements)
		&& (listPtr->numElements > 0)) {
	    listPtr->active = listPtr->numElements-1;
d2333 2
a2334 1
    ListboxRedrawRange(listPtr, first, listPtr->numElements-1);
d2361 1
a2361 1

d2363 1
a2363 1
	ListboxRedrawRange(listPtr,
d2368 1
a2368 11
	if (listPtr->tkwin != NULL) {
	    if (listPtr->setGrid) {
		Tk_UnsetGrid(listPtr->tkwin);
	    }
	    listPtr->tkwin = NULL;
	    Tcl_DeleteCommandFromToken(listPtr->interp, listPtr->widgetCmd);
	}
	if (listPtr->flags & REDRAW_PENDING) {
	    Tcl_CancelIdleCall(DisplayListbox, (ClientData) listPtr);
	}
	Tcl_EventuallyFree((ClientData) listPtr, DestroyListbox);
d2390 1
a2390 1
	ListboxRedrawRange(listPtr, 0, listPtr->numElements-1);
d2394 1
a2394 1
	    ListboxRedrawRange(listPtr, 0, listPtr->numElements-1);
d2399 1
a2399 1
	    ListboxRedrawRange(listPtr, 0, listPtr->numElements-1);
a2426 1
    Tk_Window tkwin = listPtr->tkwin;
d2435 2
a2436 6
    if (tkwin != NULL) {
	if (listPtr->setGrid) {
	    Tk_UnsetGrid(listPtr->tkwin);
	}
	listPtr->tkwin = NULL;
	Tk_DestroyWindow(tkwin);
d2451 1
a2451 1
 *	string.  Otherwise an error message is left in interp->result.
d2460 1
a2460 1
GetListboxIndex(interp, listPtr, string, endIsSize, indexPtr)
d2464 1
a2464 1
    char *string;		/* Specifies an element in the listbox. */
d2471 32
a2502 2
    int c;
    size_t length;
d2504 4
a2507 15
    length = strlen(string);
    c = string[0];
    if ((c == 'a') && (strncmp(string, "active", length) == 0)
	    && (length >= 2)) {
	*indexPtr = listPtr->active;
    } else if ((c == 'a') && (strncmp(string, "anchor", length) == 0)
	    && (length >= 2)) {
	*indexPtr = listPtr->selectAnchor;
    } else if ((c == 'e') && (strncmp(string, "end", length) == 0)) {
	if (endIsSize) {
	    *indexPtr = listPtr->numElements;
	} else {
	    *indexPtr = listPtr->numElements - 1;
	}
    } else if (c == '@@') {
d2509 16
a2524 11
	char *p, *end;

	p = string+1;
	strtol(p, &end, 0);
	if ((end == p) || (*end != ',')) {
	    goto badIndex;
	}
	p = end+1;
	y = strtol(p, &end, 0);
	if ((end == p) || (*end != 0)) {
	    goto badIndex;
d2527 6
a2532 5
    } else {
	if (Tcl_GetInt(interp, string, indexPtr) != TCL_OK) {
	    Tcl_ResetResult(interp);
	    goto badIndex;
	}
a2533 1
    return TCL_OK;
d2535 5
a2539 4
    badIndex:
    Tcl_AppendResult(interp, "bad listbox index \"", string,
	    "\": must be active, anchor, end, @@x,y, or a number",
	    (char *) NULL);
d2569 2
a2570 2
    if (index >= (listPtr->numElements - listPtr->fullLines)) {
	index = listPtr->numElements - listPtr->fullLines;
d2577 1
a2577 4
	if (!(listPtr->flags & REDRAW_PENDING)) {
	    Tcl_DoWhenIdle(DisplayListbox, (ClientData) listPtr);
	    listPtr->flags |= REDRAW_PENDING;
	}
d2606 1
a2606 1

d2625 1
a2625 1
	ListboxRedrawRange(listPtr, 0, listPtr->numElements);
d2655 2
a2656 2

    maxIndex = listPtr->numElements - listPtr->fullLines;
d2734 2
a2735 2
    if (index >= listPtr->numElements) {
	index = listPtr->numElements-1;
d2748 1
a2748 1
 *	None.
d2760 1
a2760 1
static void
d2771 3
a2773 2
    Element *elPtr;

d2779 2
a2780 2
    if ((last < 0) || (first >= listPtr->numElements)) {
	return;
d2785 2
a2786 2
    if (last >= listPtr->numElements) {
	last = listPtr->numElements - 1;
d2791 26
a2816 12
    for (i = 0, elPtr = listPtr->firstPtr; i < first;
	    i++, elPtr = elPtr->nextPtr) {
	/* Empty loop body. */
    }
    for ( ; i <= last; i++, elPtr = elPtr->nextPtr) {
	if (elPtr->selected == select) {
	    continue;
	}
	listPtr->numSelected += increment;
	elPtr->selected = select;
	if (firstRedisplay < 0) {
	    firstRedisplay = i;
d2819 1
d2821 1
a2821 1
	ListboxRedrawRange(listPtr, first, last);
d2828 1
a2865 1
    register Element *elPtr;
d2868 6
a2873 1

d2884 3
a2886 2
    for (elPtr = listPtr->firstPtr; elPtr != NULL; elPtr = elPtr->nextPtr) {
	if (elPtr->selected) {
d2890 4
a2893 1
	    Tcl_DStringAppend(&selection, elPtr->text, elPtr->textLength);
d2946 3
a2948 3

    if ((listPtr->exportSelection) && (listPtr->numElements > 0)) {
	ListboxSelect(listPtr, 0, listPtr->numElements-1, 0);
d2955 1
a2955 1
 * ListboxRedrawRange --
a2968 1
	/* ARGSUSED */
d2970 1
a2970 1
ListboxRedrawRange(listPtr, first, last)
d2979 5
a2983 2
    if ((listPtr->tkwin == NULL) || !Tk_IsMapped(listPtr->tkwin)
	    || (listPtr->flags & REDRAW_PENDING)) {
d2986 1
a2987 1
    listPtr->flags |= REDRAW_PENDING;
d3014 1
a3014 1
    char string[100];
d3018 1
a3018 1

d3022 1
a3022 1
    if (listPtr->numElements == 0) {
d3026 1
a3026 1
	first = listPtr->topIndex/((double) listPtr->numElements);
d3028 1
a3028 1
		/((double) listPtr->numElements);
d3076 1
a3076 1
    char string[60];
d3115 171
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tkListbox.c,v 1.7.6.2 2000/09/26 16:08:10 spolk Exp $
d21 24
a44 7
typedef struct {
    Tk_OptionTable listboxOptionTable;	/* Table defining configuration options
					 * available for the listbox */
    Tk_OptionTable itemAttrOptionTable;	/* Table definining configuration
					 * options available for listbox
					 * items */
} ListboxOptionTables;
d61 5
a65 10
    Tk_OptionTable optionTable;	/* Table that defines configuration options
				 * available for this widget. */
    Tk_OptionTable itemAttrOptionTable;	/* Table that defines configuration
					 * options available for listbox
					 * items */
    char *listVarName;          /* List variable name */
    Tcl_Obj *listObj;           /* Pointer to the list object being used */
    int nElements;              /* Holds the current count of elements */
    Tcl_HashTable *selection;   /* Tracks selection */
    Tcl_HashTable *itemAttrTable;	/* Tracks item attributes */
a174 11
 * ItemAttr structures are used to store item configuration information for
 * the items in a listbox
 */
typedef struct {
    Tk_3DBorder border;		/* Used for drawing background around text */
    Tk_3DBorder selBorder;	/* Used for selected text */
    XColor *fgColor;		/* Text color in normal mode. */
    XColor *selFgColor;		/* Text color in selected mode. */
} ItemAttr;    

/*
a185 2
 * MAXWIDTH_IS_STALE:           Stored maxWidth may be out-of-date
 * LISTBOX_DELETED:		This listbox has been effectively destroyed.
a191 2
#define MAXWIDTH_IS_STALE	16
#define LISTBOX_DELETED		32
d194 1
a194 2
 * The optionSpecs table defines the valid configuration options for the
 * listbox widget
d196 68
a263 66
static Tk_OptionSpec optionSpecs[] = {
    {TK_OPTION_BORDER, "-background", "background", "Background",
	 DEF_LISTBOX_BG_COLOR, -1, Tk_Offset(Listbox, normalBorder),
	 0, (ClientData) DEF_LISTBOX_BG_MONO, 0},
    {TK_OPTION_SYNONYM, "-bd", (char *) NULL, (char *) NULL,
	 (char *) NULL, 0, -1, 0, (ClientData) "-borderwidth", 0},
    {TK_OPTION_SYNONYM, "-bg", (char *) NULL, (char *) NULL,
	 (char *) NULL, 0, -1, 0, (ClientData) "-background", 0},
    {TK_OPTION_PIXELS, "-borderwidth", "borderWidth", "BorderWidth",
	 DEF_LISTBOX_BORDER_WIDTH, -1, Tk_Offset(Listbox, borderWidth),
	 0, 0, 0},
    {TK_OPTION_CURSOR, "-cursor", "cursor", "Cursor",
	 DEF_LISTBOX_CURSOR, -1, Tk_Offset(Listbox, cursor),
	 TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_BOOLEAN, "-exportselection", "exportSelection",
	 "ExportSelection", DEF_LISTBOX_EXPORT_SELECTION, -1,
	 Tk_Offset(Listbox, exportSelection), 0, 0, 0},
    {TK_OPTION_SYNONYM, "-fg", "foreground", (char *) NULL,
	 (char *) NULL, 0, -1, 0, (ClientData) "-foreground", 0},
    {TK_OPTION_FONT, "-font", "font", "Font",
	 DEF_LISTBOX_FONT, -1, Tk_Offset(Listbox, tkfont), 0, 0, 0},
    {TK_OPTION_COLOR, "-foreground", "foreground", "Foreground",
	 DEF_LISTBOX_FG, -1, Tk_Offset(Listbox, fgColorPtr), 0, 0, 0},
    {TK_OPTION_INT, "-height", "height", "Height",
	 DEF_LISTBOX_HEIGHT, -1, Tk_Offset(Listbox, height), 0, 0, 0},
    {TK_OPTION_COLOR, "-highlightbackground", "highlightBackground",
	 "HighlightBackground", DEF_LISTBOX_HIGHLIGHT_BG, -1, 
	 Tk_Offset(Listbox, highlightBgColorPtr), 0, 0, 0},
    {TK_OPTION_COLOR, "-highlightcolor", "highlightColor", "HighlightColor",
	 DEF_LISTBOX_HIGHLIGHT, -1, Tk_Offset(Listbox, highlightColorPtr),
	 0, 0, 0},
    {TK_OPTION_PIXELS, "-highlightthickness", "highlightThickness",
	 "HighlightThickness", DEF_LISTBOX_HIGHLIGHT_WIDTH, -1,
	 Tk_Offset(Listbox, highlightWidth), 0, 0, 0},
    {TK_OPTION_RELIEF, "-relief", "relief", "Relief",
	 DEF_LISTBOX_RELIEF, -1, Tk_Offset(Listbox, relief), 0, 0, 0},
    {TK_OPTION_BORDER, "-selectbackground", "selectBackground", "Foreground",
	 DEF_LISTBOX_SELECT_COLOR, -1, Tk_Offset(Listbox, selBorder),
	 0, (ClientData) DEF_LISTBOX_SELECT_MONO, 0},
    {TK_OPTION_PIXELS, "-selectborderwidth", "selectBorderWidth",
	 "BorderWidth", DEF_LISTBOX_SELECT_BD, -1,
	 Tk_Offset(Listbox, selBorderWidth), 0, 0, 0},
    {TK_OPTION_COLOR, "-selectforeground", "selectForeground", "Background",
	 DEF_LISTBOX_SELECT_FG_COLOR, -1, Tk_Offset(Listbox, selFgColorPtr),
	 0, (ClientData) DEF_LISTBOX_SELECT_FG_MONO, 0},
    {TK_OPTION_STRING, "-selectmode", "selectMode", "SelectMode",
	 DEF_LISTBOX_SELECT_MODE, -1, Tk_Offset(Listbox, selectMode),
	 TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_BOOLEAN, "-setgrid", "setGrid", "SetGrid",
	 DEF_LISTBOX_SET_GRID, -1, Tk_Offset(Listbox, setGrid), 0, 0, 0},
    {TK_OPTION_STRING, "-takefocus", "takeFocus", "TakeFocus",
	 DEF_LISTBOX_TAKE_FOCUS, -1, Tk_Offset(Listbox, takeFocus),
	 TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_INT, "-width", "width", "Width",
	 DEF_LISTBOX_WIDTH, -1, Tk_Offset(Listbox, width), 0, 0, 0},
    {TK_OPTION_STRING, "-xscrollcommand", "xScrollCommand", "ScrollCommand",
	 DEF_LISTBOX_SCROLL_COMMAND, -1, Tk_Offset(Listbox, xScrollCmd),
	 TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_STRING, "-yscrollcommand", "yScrollCommand", "ScrollCommand",
	 DEF_LISTBOX_SCROLL_COMMAND, -1, Tk_Offset(Listbox, yScrollCmd),
	 TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_STRING, "-listvariable", "listVariable", "Variable",
	 DEF_LISTBOX_LIST_VARIABLE, -1, Tk_Offset(Listbox, listVarName),
	 TK_OPTION_NULL_OK, 0, 0},
    {TK_OPTION_END, (char *) NULL, (char *) NULL, (char *) NULL,
	 (char *) NULL, 0, -1, 0, 0, 0}
d267 1
a267 2
 * The itemAttrOptionSpecs table defines the valid configuration options for
 * listbox items
a268 47
static Tk_OptionSpec itemAttrOptionSpecs[] = {
    {TK_OPTION_BORDER, "-background", "background", "Background",
	 (char *)NULL, -1, Tk_Offset(ItemAttr, border),
	 TK_OPTION_NULL_OK|TK_OPTION_DONT_SET_DEFAULT,
     (ClientData) DEF_LISTBOX_BG_MONO, 0},
    {TK_OPTION_SYNONYM, "-bg", (char *) NULL, (char *) NULL,
	 (char *) NULL, 0, -1, 0, (ClientData) "-background", 0},
    {TK_OPTION_SYNONYM, "-fg", "foreground", (char *) NULL,
	 (char *) NULL, 0, -1, 0, (ClientData) "-foreground", 0},
    {TK_OPTION_COLOR, "-foreground", "foreground", "Foreground",
	 (char *) NULL, -1, Tk_Offset(ItemAttr, fgColor),
	 TK_OPTION_NULL_OK|TK_OPTION_DONT_SET_DEFAULT, 0, 0},
    {TK_OPTION_BORDER, "-selectbackground", "selectBackground", "Foreground",
	 (char *) NULL, -1, Tk_Offset(ItemAttr, selBorder),
	 TK_OPTION_NULL_OK|TK_OPTION_DONT_SET_DEFAULT,
     (ClientData) DEF_LISTBOX_SELECT_MONO, 0},
    {TK_OPTION_COLOR, "-selectforeground", "selectForeground", "Background",
	 (char *) NULL, -1, Tk_Offset(ItemAttr, selFgColor),
	 TK_OPTION_NULL_OK|TK_OPTION_DONT_SET_DEFAULT,
     (ClientData) DEF_LISTBOX_SELECT_FG_MONO, 0},
    {TK_OPTION_END, (char *) NULL, (char *) NULL, (char *) NULL,
	 (char *) NULL, 0, -1, 0, 0, 0}
};

/*
 * The following tables define the listbox widget commands (and sub-
 * commands) and map the indexes into the string tables into 
 * enumerated types used to dispatch the listbox widget command.
 */
static char *commandNames[] = {
    "activate", "bbox", "cget", "configure", "curselection", "delete", "get",
	"index", "insert", "itemcget", "itemconfigure", "nearest", "scan",
	"see", "selection", "size", "xview", "yview",
    (char *) NULL
};

enum command {
    COMMAND_ACTIVATE, COMMAND_BBOX, COMMAND_CGET, COMMAND_CONFIGURE,
	COMMAND_CURSELECTION, COMMAND_DELETE, COMMAND_GET, COMMAND_INDEX,
	COMMAND_INSERT, COMMAND_ITEMCGET, COMMAND_ITEMCONFIGURE,
	COMMAND_NEAREST, COMMAND_SCAN, COMMAND_SEE, COMMAND_SELECTION,
	COMMAND_SIZE, COMMAND_XVIEW, COMMAND_YVIEW
};

static char *selCommandNames[] = {
    "anchor", "clear", "includes", "set", (char *) NULL
};
a269 22
enum selcommand {
    SELECTION_ANCHOR, SELECTION_CLEAR, SELECTION_INCLUDES, SELECTION_SET
};

static char *scanCommandNames[] = {
    "mark", "dragto", (char *) NULL
};

enum scancommand {
    SCAN_MARK, SCAN_DRAGTO
};

static char *indexNames[] = {
    "active", "anchor", "end", (char *)NULL
};

enum indices {
    INDEX_ACTIVE, INDEX_ANCHOR, INDEX_END
};


/* Declarations for procedures defined later in this file */
d275 1
a275 1
			    Listbox *listPtr, int objc, Tcl_Obj *CONST objv[],
d277 2
a278 5
static int		ConfigureListboxItem _ANSI_ARGS_ ((Tcl_Interp *interp,
			    Listbox *listPtr, ItemAttr *attrs, int objc,
			    Tcl_Obj *CONST objv[]));
static int		ListboxDeleteSubCmd _ANSI_ARGS_((Listbox *listPtr,
			    int first, int last));
a279 2
static void		DestroyListboxOptionTables _ANSI_ARGS_ (
			    (ClientData clientData, Tcl_Interp *interp));
d282 1
a282 1
			    Listbox *listPtr, Tcl_Obj *index, int endIsSize,
d284 2
a285 2
static int		ListboxInsertSubCmd _ANSI_ARGS_((Listbox *listPtr,
			    int index, int objc, Tcl_Obj *CONST objv[]));
d297 1
a297 1
static void		EventuallyRedrawRange _ANSI_ARGS_((Listbox *listPtr,
d301 1
a301 1
static int		ListboxSelect _ANSI_ARGS_((Listbox *listPtr,
d303 4
a306 20
static void		ListboxUpdateHScrollbar _ANSI_ARGS_(
    			    (Listbox *listPtr));
static void		ListboxUpdateVScrollbar _ANSI_ARGS_(
			    (Listbox *listPtr));
static int		ListboxWidgetObjCmd _ANSI_ARGS_((ClientData clientData,
	                    Tcl_Interp *interp, int objc,
	                    Tcl_Obj *CONST objv[]));
static int		ListboxBboxSubCmd _ANSI_ARGS_ ((Tcl_Interp *interp,
	                    Listbox *listPtr, int index));
static int		ListboxSelectionSubCmd _ANSI_ARGS_ (
			    (Tcl_Interp *interp, Listbox *listPtr, int objc,
			    Tcl_Obj *CONST objv[]));
static int		ListboxXviewSubCmd _ANSI_ARGS_ ((Tcl_Interp *interp,
			    Listbox *listPtr, int objc,
			    Tcl_Obj *CONST objv[]));
static int		ListboxYviewSubCmd _ANSI_ARGS_ ((Tcl_Interp *interp,
			    Listbox *listPtr, int objc,
			    Tcl_Obj *CONST objv[]));
static ItemAttr *	ListboxGetItemAttributes _ANSI_ARGS_ (
    			    (Tcl_Interp *interp, Listbox *listPtr, int index));
d311 1
a311 5
static char *		ListboxListVarProc _ANSI_ARGS_ ((ClientData clientData,
	                    Tcl_Interp *interp, char *name1, char *name2,
 	                    int flags));
static void		MigrateHashEntries _ANSI_ARGS_ ((Tcl_HashTable *table,
			    int first, int last, int offset));
d327 1
a327 1
 * Tk_ListboxObjCmd --
d343 3
a345 2
Tk_ListboxObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Either NULL or pointer to option table */
d347 2
a348 2
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
d351 2
a352 31
    Tk_Window tkwin;
    ListboxOptionTables *optionTables;

    optionTables = (ListboxOptionTables *)clientData;
    if (optionTables == NULL) {
	Tcl_CmdInfo info;
	char *name;

	/*
	 * We haven't created the option tables for this widget class yet.
	 * Do it now and save the a pointer to them as the ClientData for
	 * the command, so future invocations will have access to it.
	 */
	optionTables =
	    (ListboxOptionTables *) ckalloc(sizeof(ListboxOptionTables));
	/* Set up an exit handler to free the optionTables struct */
	Tcl_SetAssocData(interp, "ListboxOptionTables",
		DestroyListboxOptionTables, (ClientData) optionTables);

	/* Create the listbox option table and the listbox item option table */
	optionTables->listboxOptionTable =
	    Tk_CreateOptionTable(interp, optionSpecs);
	optionTables->itemAttrOptionTable =
	    Tk_CreateOptionTable(interp, itemAttrOptionSpecs);

	/* Store a pointer to the tables as the ClientData for the command */
	name = Tcl_GetString(objv[0]);
	Tcl_GetCommandInfo(interp, name, &info);
	info.objClientData = (ClientData) optionTables;
	Tcl_SetCommandInfo(interp, name, &info);
    }
d354 3
a356 2
    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "pathName ?options?");
d360 2
a361 3
    tkwin = Tk_CreateWindowFromPath(interp, Tk_MainWindow(interp),
            Tcl_GetString(objv[1]), (char *) NULL);
    if (tkwin == NULL) {
d370 7
a376 6
    listPtr 				= (Listbox *) ckalloc(sizeof(Listbox));
    listPtr->tkwin 			= tkwin;
    listPtr->display 			= Tk_Display(tkwin);
    listPtr->interp 			= interp;
    listPtr->widgetCmd 			= Tcl_CreateObjCommand(interp,
	    Tk_PathName(listPtr->tkwin), ListboxWidgetObjCmd,
d378 41
a418 49
    listPtr->optionTable 		= optionTables->listboxOptionTable;
    listPtr->itemAttrOptionTable	= optionTables->itemAttrOptionTable;
    listPtr->listVarName 		= NULL;
    listPtr->listObj 			= NULL;
    listPtr->selection 			=
	(Tcl_HashTable *) ckalloc(sizeof(Tcl_HashTable));
    Tcl_InitHashTable(listPtr->selection, TCL_ONE_WORD_KEYS);
    listPtr->itemAttrTable 		=
	(Tcl_HashTable *) ckalloc(sizeof(Tcl_HashTable));
    Tcl_InitHashTable(listPtr->itemAttrTable, TCL_ONE_WORD_KEYS);
    listPtr->nElements 			= 0;
    listPtr->normalBorder 		= NULL;
    listPtr->borderWidth 		= 0;
    listPtr->relief 			= TK_RELIEF_RAISED;
    listPtr->highlightWidth 		= 0;
    listPtr->highlightBgColorPtr 	= NULL;
    listPtr->highlightColorPtr 		= NULL;
    listPtr->inset 			= 0;
    listPtr->tkfont 			= NULL;
    listPtr->fgColorPtr 		= NULL;
    listPtr->textGC 			= None;
    listPtr->selBorder 			= NULL;
    listPtr->selBorderWidth 		= 0;
    listPtr->selFgColorPtr 		= None;
    listPtr->selTextGC 			= None;
    listPtr->width 			= 0;
    listPtr->height 			= 0;
    listPtr->lineHeight 		= 0;
    listPtr->topIndex 			= 0;
    listPtr->fullLines 			= 1;
    listPtr->partialLine 		= 0;
    listPtr->setGrid 			= 0;
    listPtr->maxWidth 			= 0;
    listPtr->xScrollUnit 		= 1;
    listPtr->xOffset 			= 0;
    listPtr->selectMode 		= NULL;
    listPtr->numSelected 		= 0;
    listPtr->selectAnchor 		= 0;
    listPtr->exportSelection 		= 1;
    listPtr->active 			= 0;
    listPtr->scanMarkX 			= 0;
    listPtr->scanMarkY 			= 0;
    listPtr->scanMarkXOffset 		= 0;
    listPtr->scanMarkYIndex 		= 0;
    listPtr->cursor 			= None;
    listPtr->takeFocus 			= NULL;
    listPtr->xScrollCmd 		= NULL;
    listPtr->yScrollCmd 		= NULL;
    listPtr->flags 			= 0;
d427 2
a428 4
    if (Tk_InitOptions(interp, (char *)listPtr,
	    optionTables->listboxOptionTable, tkwin) != TCL_OK) {
	Tk_DestroyWindow(listPtr->tkwin);
	return TCL_ERROR;
d431 2
a432 4
    if (ConfigureListbox(interp, listPtr, objc-2, objv+2, 0) != TCL_OK) {
	Tk_DestroyWindow(listPtr->tkwin);
	return TCL_ERROR;
    }
d434 3
a436 2
    Tcl_SetResult(interp, Tk_PathName(listPtr->tkwin), TCL_STATIC);
    return TCL_OK;
d440 1
a440 1
 *----------------------------------------------------------------------
d442 1
a442 1
 * ListboxWidgetObjCmd --
d444 3
a446 3
 *	This Tcl_Obj based procedure is invoked to process the Tcl command
 *      that corresponds to a widget managed by this module.  See the user
 *      documentation for details on what it does.
d454 1
a454 1
 *----------------------------------------------------------------------
d458 1
a458 1
ListboxWidgetObjCmd(clientData, interp, objc, objv)
d461 2
a462 2
    int objc;				/* Number of arguments. */
    Tcl_Obj *CONST objv[];		/* Arguments as Tcl_Obj's. */
a464 1
    int cmdIndex, index;
d466 7
a472 3
    
    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "option ?arg arg ...?");
d475 74
a548 89
    Tcl_Preserve((ClientData)listPtr);

    /*
     * Parse the command by looking up the second argument in the list
     * of valid subcommand names
     */
    result = Tcl_GetIndexFromObj(interp, objv[1], commandNames,
	    "option", 0, &cmdIndex);
    if (result != TCL_OK) {
	Tcl_Release((ClientData)listPtr);
	return result;
    }

    /* The subcommand was valid, so continue processing */
    switch (cmdIndex) {
	case COMMAND_ACTIVATE: {
	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "index");
		result = TCL_ERROR;
		break;
	    }
	    result = GetListboxIndex(interp, listPtr, objv[2], 0, &index);
	    if (result != TCL_OK) {
		break;
	    }
	    if (index >= listPtr->nElements) {
		index = listPtr->nElements-1;
	    }
	    if (index < 0) {
		index = 0;
	    }
	    listPtr->active = index;
	    EventuallyRedrawRange(listPtr, listPtr->active, listPtr->active);
	    result = TCL_OK;
	    break;
	}

	case COMMAND_BBOX: {
	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "index");
		result = TCL_ERROR;
		break;
	    }
	    result = GetListboxIndex(interp, listPtr, objv[2], 0, &index);
	    if (result != TCL_OK) {
		break;
	    }
	    
	    result = ListboxBboxSubCmd(interp, listPtr, index);
	    break;
	}

	case COMMAND_CGET: {
	    Tcl_Obj *objPtr;
	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "option");
		result = TCL_ERROR;
		break;
	    }

	    objPtr = Tk_GetOptionValue(interp, (char *)listPtr,
		    listPtr->optionTable, objv[2], listPtr->tkwin);
	    if (objPtr == NULL) {
		result = TCL_ERROR;
		break;
	    }
	    Tcl_SetObjResult(interp, objPtr);
	    result = TCL_OK;
	    break;
	}
	
	case COMMAND_CONFIGURE: {
	    Tcl_Obj *objPtr;
	    if (objc <= 3) {
		objPtr = Tk_GetOptionInfo(interp, (char *) listPtr,
			listPtr->optionTable,
			(objc == 3) ? objv[2] : (Tcl_Obj *) NULL,
			listPtr->tkwin);
		if (objPtr == NULL) {
		    result = TCL_ERROR;
		    break;
		} else {
		    Tcl_SetObjResult(interp, objPtr);
		    result = TCL_OK;
		}
	    } else {
		result = ConfigureListbox(interp, listPtr, objc-2, objv+2, 0);
	    }
	    break;
d550 11
a560 24

	case COMMAND_CURSELECTION: {
	    char indexStringRep[TCL_INTEGER_SPACE];
	    int i;
	    if (objc != 2) {
		Tcl_WrongNumArgs(interp, 2, objv, NULL);
		result = TCL_ERROR;
		break;
	    }
	    /*
	     * Of course, it would be more efficient to use the Tcl_HashTable
	     * search functions (Tcl_FirstHashEntry, Tcl_NextHashEntry), but
	     * then the result wouldn't be in sorted order.  So instead we
	     * loop through the indices in order, adding them to the result
	     * if they are selected
	     */
	    for (i = 0; i < listPtr->nElements; i++) {
		if (Tcl_FindHashEntry(listPtr->selection, (char *)i) != NULL) {
		    sprintf(indexStringRep, "%d", i);
		    Tcl_AppendElement(interp, indexStringRep);
		}
	    }
	    result = TCL_OK;
	    break;
d562 31
a592 27
	
	case COMMAND_DELETE: {
	    int first, last;
	    if ((objc < 3) || (objc > 4)) {
		Tcl_WrongNumArgs(interp, 2, objv,
			"firstIndex ?lastIndex?");
		result = TCL_ERROR;
		break;
	    }

	    result = GetListboxIndex(interp, listPtr, objv[2], 0, &first);
	    if (result != TCL_OK) {
		break;
	    }
	    if (first < listPtr->nElements) {
		/*
		 * if a "last index" was given, get it now; otherwise, use the
		 * first index as the last index
		 */
		if (objc == 4) {
		    result = GetListboxIndex(interp, listPtr,
			    objv[3], 0, &last);
		    if (result != TCL_OK) {
			break;
		    }
		} else {
		    last = first;
d594 2
a595 2
		if (last >= listPtr->nElements) {
		    last = listPtr->nElements - 1;
a596 3
		result = ListboxDeleteSubCmd(listPtr, first, last);
	    } else {
		result = TCL_OK;
d598 1
a598 1
	    break;
d600 3
d604 17
a620 50
	case COMMAND_GET: {
	    int first, last;
	    Tcl_Obj **elemPtrs;
	    int listLen;
	    if (objc != 3 && objc != 4) {
		Tcl_WrongNumArgs(interp, 2, objv, "firstIndex ?lastIndex?");
		result = TCL_ERROR;
		break;
	    }
	    result = GetListboxIndex(interp, listPtr, objv[2], 0, &first);
	    if (result != TCL_OK) {
		break;
	    }
	    last = first;
	    if (objc == 4) {
		result = GetListboxIndex(interp, listPtr, objv[3], 0, &last);
		if (result != TCL_OK) {
		    break;
		}
	    }
	    if (first >= listPtr->nElements) {
		result = TCL_OK;
		break;
	    }
	    if (last >= listPtr->nElements) {
		last = listPtr->nElements - 1;
	    }
	    if (first < 0) {
		first = 0;
	    }
	    if (first > last) {
		result = TCL_OK;
		break;
	    }
	    result = Tcl_ListObjGetElements(interp, listPtr->listObj, &listLen,
		    &elemPtrs);
	    if (result != TCL_OK) {
		break;
	    }
	    if (objc == 3) {
		/*
		 * One element request - we return a string
		 */
		Tcl_SetObjResult(interp, elemPtrs[first]);
	    } else {
		Tcl_SetListObj(Tcl_GetObjResult(interp), (last - first + 1),
			&(elemPtrs[first]));
	    }
	    result = TCL_OK;
	    break;
d623 8
a630 103
	case COMMAND_INDEX:{
	    char buf[TCL_INTEGER_SPACE];
	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "index");
		result = TCL_ERROR;
		break;
	    }
	    result = GetListboxIndex(interp, listPtr, objv[2], 1, &index);
	    if (result != TCL_OK) {
		break;
	    }
	    sprintf(buf, "%d", index);
	    Tcl_SetResult(interp, buf, TCL_VOLATILE);
	    result = TCL_OK;
	    break;
	}

	case COMMAND_INSERT: {
	    if (objc < 3) {
		Tcl_WrongNumArgs(interp, 2, objv,
			"index ?element element ...?");
		result = TCL_ERROR;
		break;
	    }

	    result = GetListboxIndex(interp, listPtr, objv[2], 1, &index);
	    if (result != TCL_OK) {
		break;
	    }
	    result = ListboxInsertSubCmd(listPtr, index, objc-3, objv+3);
	    break;
	}

	case COMMAND_ITEMCGET: {
	    Tcl_Obj *objPtr;
	    ItemAttr *attrPtr;
	    if (objc != 4) {
		Tcl_WrongNumArgs(interp, 2, objv, "index option");
		result = TCL_ERROR;
		break;
	    }

	    result = GetListboxIndex(interp, listPtr, objv[2], 0, &index);
	    if (result != TCL_OK) {
		break;
	    }

	    if (index < 0 || index >= listPtr->nElements) {
		Tcl_AppendResult(interp, "item number \"",
			Tcl_GetString(objv[2]), "\" out of range",
			(char *)NULL);
		result = TCL_ERROR;
		break;
	    }
	    
	    attrPtr = ListboxGetItemAttributes(interp, listPtr, index);

	    objPtr = Tk_GetOptionValue(interp, (char *)attrPtr,
		    listPtr->itemAttrOptionTable, objv[3], listPtr->tkwin);
	    if (objPtr == NULL) {
		result = TCL_ERROR;
		break;
	    }
	    Tcl_SetObjResult(interp, objPtr);
	    result = TCL_OK;
	    break;
	}

	case COMMAND_ITEMCONFIGURE: {
	    Tcl_Obj *objPtr;
	    ItemAttr *attrPtr;
	    if (objc < 3) {
		Tcl_WrongNumArgs(interp, 2, objv,
			"index ?option? ?value? ?option value ...?");
		result = TCL_ERROR;
		break;
	    }

	    result = GetListboxIndex(interp, listPtr, objv[2], 0, &index);
	    if (result != TCL_OK) {
		break;
	    }
	    
	    if (index < 0 || index >= listPtr->nElements) {
		Tcl_AppendResult(interp, "item number \"",
			Tcl_GetString(objv[2]), "\" out of range",
			(char *)NULL);
		result = TCL_ERROR;
		break;
	    }
	    
	    attrPtr = ListboxGetItemAttributes(interp, listPtr, index);
	    if (objc <= 4) {
		objPtr = Tk_GetOptionInfo(interp, (char *)attrPtr,
			listPtr->itemAttrOptionTable,
			(objc == 4) ? objv[3] : (Tcl_Obj *) NULL,
			listPtr->tkwin);
		if (objPtr == NULL) {
		    result = TCL_ERROR;
		    break;
		} else {
		    Tcl_SetObjResult(interp, objPtr);
		    result = TCL_OK;
d633 2
a634 57
		result = ConfigureListboxItem(interp, listPtr, attrPtr,
			objc-3, objv+3);
	    }
	    break;
	}
	
	case COMMAND_NEAREST: {
	    char buf[TCL_INTEGER_SPACE];
	    int y;
	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "y");
		result = TCL_ERROR;
		break;
	    }
	    
	    result = Tcl_GetIntFromObj(interp, objv[2], &y);
	    if (result != TCL_OK) {
		break;
	    }
	    index = NearestListboxElement(listPtr, y);
	    sprintf(buf, "%d", index);
	    Tcl_SetResult(interp, buf, TCL_VOLATILE);
	    result = TCL_OK;
	    break;
	}
	
	case COMMAND_SCAN: {
	    int x, y, scanCmdIndex;

	    if (objc != 5) {
		Tcl_WrongNumArgs(interp, 2, objv, "mark|dragto x y");
		result = TCL_ERROR;
		break;
	    }

	    if (Tcl_GetIntFromObj(interp, objv[3], &x) != TCL_OK
		    || Tcl_GetIntFromObj(interp, objv[4], &y) != TCL_OK) {
		result = TCL_ERROR;
		break;
	    }

	    result = Tcl_GetIndexFromObj(interp, objv[2], scanCommandNames,
		    "option", 0, &scanCmdIndex);
	    if (result != TCL_OK) {
		break;
	    }
	    switch (scanCmdIndex) {
		case SCAN_MARK: {
		    listPtr->scanMarkX = x;
		    listPtr->scanMarkY = y;
		    listPtr->scanMarkXOffset = listPtr->xOffset;
		    listPtr->scanMarkYIndex = listPtr->topIndex;
		    break;
		}
		case SCAN_DRAGTO: {
		    ListboxScanTo(listPtr, x, y);
		    break;
a636 2
	    result = TCL_OK;
	    break;
d638 94
a731 7

	case COMMAND_SEE: {
	    int diff;
	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "index");
		result = TCL_ERROR;
		break;
d733 2
a734 11
	    result = GetListboxIndex(interp, listPtr, objv[2], 0, &index);
	    if (result != TCL_OK) {
		break;
	    }
	    if (index >= listPtr->nElements) {
		index = listPtr->nElements - 1;
	    }
	    if (index < 0) {
		index = 0;
	    }
	    diff = listPtr->topIndex - index;
d737 1
a737 1
		    ChangeListboxView(listPtr, index);
a741 10
	    } else {
		diff = index - (listPtr->topIndex + listPtr->fullLines - 1);
		if (diff > 0) {
		    if (diff <= (listPtr->fullLines/3)) {
			ChangeListboxView(listPtr, listPtr->topIndex + diff);
		    } else {
			ChangeListboxView(listPtr,
				index - (listPtr->fullLines-1)/2);
		    }
		}
a742 2
	    result = TCL_OK;
	    break;
d744 16
a759 12

	case COMMAND_SELECTION: {
	    result = ListboxSelectionSubCmd(interp, listPtr, objc, objv);
	    break;
	}
	
	case COMMAND_SIZE: {
	    char buf[TCL_INTEGER_SPACE];
	    if (objc != 2) {
		Tcl_WrongNumArgs(interp, 2, objv, NULL);
		result = TCL_ERROR;
		break;
d761 2
a762 118
	    sprintf(buf, "%d", listPtr->nElements);
	    Tcl_SetResult(interp, buf, TCL_VOLATILE);
	    result = TCL_OK;
	    break;
	}

	case COMMAND_XVIEW: {
	    result = ListboxXviewSubCmd(interp, listPtr, objc, objv);
	    break;
	}
	
	case COMMAND_YVIEW: {
	    result = ListboxYviewSubCmd(interp, listPtr, objc, objv);
	    break;
	}
    }
    Tcl_Release((ClientData)listPtr);
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * ListboxBboxSubCmd --
 *
 *	This procedure is invoked to process a listbox bbox request.
 *      See the user documentation for more information.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	For valid indices, places the bbox of the requested element in
 *      the interpreter's result.
 *
 *----------------------------------------------------------------------
 */

static int
ListboxBboxSubCmd(interp, listPtr, index)
    Tcl_Interp *interp;          /* Pointer to the calling Tcl interpreter */
    Listbox *listPtr;            /* Information about the listbox */
    int index;                   /* Index of the element to get bbox info on */
{
    int lastVisibleIndex;
    /* Determine the index of the last visible item in the listbox */
    lastVisibleIndex = listPtr->topIndex + listPtr->fullLines
	+ listPtr->partialLine;
    if (listPtr->nElements < lastVisibleIndex) {
	lastVisibleIndex = listPtr->nElements;
    }

    /* Only allow bbox requests for indices that are visible */
    if ((listPtr->topIndex <= index) && (index < lastVisibleIndex)) {
	char buf[TCL_INTEGER_SPACE * 4];
	Tcl_Obj *el;
	char *stringRep;
	int pixelWidth, stringLen, x, y, result;
	Tk_FontMetrics fm;

	/* Compute the pixel width of the requested element */
	result = Tcl_ListObjIndex(interp, listPtr->listObj, index, &el);
	if (result != TCL_OK) {
	    return result;
	}

	stringRep = Tcl_GetStringFromObj(el, &stringLen);
	Tk_GetFontMetrics(listPtr->tkfont, &fm);
	pixelWidth = Tk_TextWidth(listPtr->tkfont, stringRep, stringLen);

	x = listPtr->inset + listPtr->selBorderWidth - listPtr->xOffset;
	y = ((index - listPtr->topIndex)*listPtr->lineHeight)
	    + listPtr->inset + listPtr->selBorderWidth;
	sprintf(buf, "%d %d %d %d", x, y, pixelWidth, fm.linespace);
	Tcl_SetResult(interp, buf, TCL_VOLATILE);
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ListboxSelectionSubCmd --
 *
 *	This procedure is invoked to process the selection sub command
 *      for listbox widgets.
 *
 * Results:
 *	Standard Tcl result.
 *
 * Side effects:
 *	May set the interpreter's result field.
 *
 *----------------------------------------------------------------------
 */

static int
ListboxSelectionSubCmd(interp, listPtr, objc, objv)
    Tcl_Interp *interp;          /* Pointer to the calling Tcl interpreter */
    Listbox *listPtr;            /* Information about the listbox */
    int objc;                    /* Number of arguments in the objv array */
    Tcl_Obj *CONST objv[];       /* Array of arguments to the procedure */
{
    int selCmdIndex, first, last;
    int result = TCL_OK;
    if (objc != 4 && objc != 5) {
	Tcl_WrongNumArgs(interp, 2, objv, "option index ?index?");
	return TCL_ERROR;
    }
    result = GetListboxIndex(interp, listPtr, objv[3], 0, &first);
    if (result != TCL_OK) {
	return result;
    }
    last = first;
    if (objc == 5) {
	result = GetListboxIndex(interp, listPtr, objv[4], 0, &last);
	if (result != TCL_OK) {
	    return result;
d764 7
a770 11
    }
    result = Tcl_GetIndexFromObj(interp, objv[2], selCommandNames,
	    "option", 0, &selCmdIndex);
    if (result != TCL_OK) {
	return result;
    }
    switch (selCmdIndex) {
	case SELECTION_ANCHOR: {
	    if (objc != 4) {
		Tcl_WrongNumArgs(interp, 3, objv, "index");
		return TCL_ERROR;
d772 2
a773 2
	    if (first >= listPtr->nElements) {
		first = listPtr->nElements - 1;
d779 18
a796 11
	    result = TCL_OK;
	    break;
	}
	case SELECTION_CLEAR: {
	    result = ListboxSelect(listPtr, first, last, 0);
	    break;
	}
	case SELECTION_INCLUDES: {
	    if (objc != 4) {
		Tcl_WrongNumArgs(interp, 3, objv, "index");
		return TCL_ERROR;
d798 2
a799 2
	    if (Tcl_FindHashEntry(listPtr->selection, (char *)first)) {
		Tcl_SetResult(interp, "1", TCL_STATIC);
d801 36
a836 1
		Tcl_SetResult(interp, "0", TCL_STATIC);
d838 5
a842 44
	    result = TCL_OK;
	    break;
	}
	case SELECTION_SET: {
	    result = ListboxSelect(listPtr, first, last, 1);
	    break;
	}
    }
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * ListboxXviewSubCmd --
 *
 *	Process the listbox "xview" subcommand.
 *
 * Results:
 *	Standard Tcl result.
 *
 * Side effects:
 *	May change the listbox viewing area; may set the interpreter's result.
 *
 *----------------------------------------------------------------------
 */

static int
ListboxXviewSubCmd(interp, listPtr, objc, objv)
    Tcl_Interp *interp;          /* Pointer to the calling Tcl interpreter */
    Listbox *listPtr;            /* Information about the listbox */
    int objc;                    /* Number of arguments in the objv array */
    Tcl_Obj *CONST objv[];       /* Array of arguments to the procedure */
{

    int index, count, type, windowWidth, windowUnits;
    int offset = 0;		/* Initialized to stop gcc warnings. */
    double fraction, fraction2;
    
    windowWidth = Tk_Width(listPtr->tkwin)
	- 2*(listPtr->inset + listPtr->selBorderWidth);
    if (objc == 2) {
	if (listPtr->maxWidth == 0) {
	    Tcl_SetResult(interp, "0 1", TCL_STATIC);
d844 19
a862 7
	    char buf[TCL_DOUBLE_SPACE * 2];
	    
	    fraction = listPtr->xOffset/((double) listPtr->maxWidth);
	    fraction2 = (listPtr->xOffset + windowWidth)
		/((double) listPtr->maxWidth);
	    if (fraction2 > 1.0) {
		fraction2 = 1.0;
d864 1
a864 2
	    sprintf(buf, "%g %g", fraction, fraction2);
	    Tcl_SetResult(interp, buf, TCL_VOLATILE);
d866 13
a878 20
    } else if (objc == 3) {
	if (Tcl_GetIntFromObj(interp, objv[2], &index) != TCL_OK) {
	    return TCL_ERROR;
	}
	ChangeListboxOffset(listPtr, index*listPtr->xScrollUnit);
    } else {
	type = Tk_GetScrollInfoObj(interp, objc, objv, &fraction, &count);
	switch (type) {
	    case TK_SCROLL_ERROR:
		return TCL_ERROR;
	    case TK_SCROLL_MOVETO:
		offset = (int) (fraction*listPtr->maxWidth + 0.5);
		break;
	    case TK_SCROLL_PAGES:
		windowUnits = windowWidth/listPtr->xScrollUnit;
		if (windowUnits > 2) {
		    offset = listPtr->xOffset
			+ count*listPtr->xScrollUnit*(windowUnits-2);
		} else {
		    offset = listPtr->xOffset + count*listPtr->xScrollUnit;
d880 8
a887 39
		break;
	    case TK_SCROLL_UNITS:
		offset = listPtr->xOffset + count*listPtr->xScrollUnit;
		break;
	}
	ChangeListboxOffset(listPtr, offset);
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ListboxYviewSubCmd --
 *
 *	Process the listbox "yview" subcommand.
 *
 * Results:
 *	Standard Tcl result.
 *
 * Side effects:
 *	May change the listbox viewing area; may set the interpreter's result.
 *
 *----------------------------------------------------------------------
 */

static int
ListboxYviewSubCmd(interp, listPtr, objc, objv)
    Tcl_Interp *interp;          /* Pointer to the calling Tcl interpreter */
    Listbox *listPtr;            /* Information about the listbox */
    int objc;                    /* Number of arguments in the objv array */
    Tcl_Obj *CONST objv[];       /* Array of arguments to the procedure */
{
    int index, count, type;
    double fraction, fraction2;
    
    if (objc == 2) {
	if (listPtr->nElements == 0) {
	    Tcl_SetResult(interp, "0 1", TCL_STATIC);
d889 20
a908 14
	    char buf[TCL_DOUBLE_SPACE * 2];
	    
	    fraction = listPtr->topIndex/((double) listPtr->nElements);
	    fraction2 = (listPtr->topIndex+listPtr->fullLines)
		/((double) listPtr->nElements);
	    if (fraction2 > 1.0) {
		fraction2 = 1.0;
	    }
	    sprintf(buf, "%g %g", fraction, fraction2);
	    Tcl_SetResult(interp, buf, TCL_VOLATILE);
	}
    } else if (objc == 3) {
	if (GetListboxIndex(interp, listPtr, objv[2], 0, &index) != TCL_OK) {
	    return TCL_ERROR;
a909 1
	ChangeListboxView(listPtr, index);
d911 6
a916 20
	type = Tk_GetScrollInfoObj(interp, objc, objv, &fraction, &count);
	switch (type) {
	    case TK_SCROLL_ERROR:
		return TCL_ERROR;
	    case TK_SCROLL_MOVETO:
		index = (int) (listPtr->nElements*fraction + 0.5);
		break;
	    case TK_SCROLL_PAGES:
		if (listPtr->fullLines > 2) {
		    index = listPtr->topIndex
			+ count*(listPtr->fullLines-2);
		} else {
		    index = listPtr->topIndex + count;
		}
		break;
	    case TK_SCROLL_UNITS:
		index = listPtr->topIndex + count;
		break;
	}
	ChangeListboxView(listPtr, index);
d918 3
a920 19
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ListboxGetItemAttributes --
 *
 *	Returns a pointer to the ItemAttr record for a given index,
 *	creating one if it does not already exist.
 *
 * Results:
 *	Pointer to an ItemAttr record.
 *
 * Side effects:
 *	Memory may be allocated for the ItemAttr record.
 *
 *----------------------------------------------------------------------
 */
d922 3
a924 25
static ItemAttr *
ListboxGetItemAttributes(interp, listPtr, index)
    Tcl_Interp *interp;          /* Pointer to the calling Tcl interpreter */
    Listbox *listPtr;            /* Information about the listbox */
    int index;                   /* Index of the item to retrieve attributes
				  * for */
{
    int new;
    Tcl_HashEntry *entry;
    ItemAttr *attrs;

    entry = Tcl_CreateHashEntry(listPtr->itemAttrTable, (char *)index,
	    &new);
    if (new) {
	attrs = (ItemAttr *) ckalloc(sizeof(ItemAttr));
	attrs->border = NULL;
	attrs->selBorder = NULL;
	attrs->fgColor = NULL;
	attrs->selFgColor = NULL;
	Tk_InitOptions(interp, (char *)attrs, listPtr->itemAttrOptionTable,
		listPtr->tkwin);
	Tcl_SetHashValue(entry, (ClientData) attrs);
    }
    attrs = (ItemAttr *)Tcl_GetHashValue(entry);
    return attrs;
d950 1
a950 2
    Tcl_HashEntry *entry;
    Tcl_HashSearch search;
d952 3
a954 1
    listPtr->flags |= LISTBOX_DELETED;
d956 4
a959 12
    Tcl_DeleteCommandFromToken(listPtr->interp, listPtr->widgetCmd);
    if (listPtr->setGrid) {
	Tk_UnsetGrid(listPtr->tkwin);
    }
    if (listPtr->flags & REDRAW_PENDING) {
	Tcl_CancelIdleCall(DisplayListbox, (ClientData) listPtr);
    }

    /* If we have an internal list object, free it */
    if (listPtr->listObj != NULL) {
	Tcl_DecrRefCount(listPtr->listObj);
	listPtr->listObj = NULL;
a961 18
    if (listPtr->listVarName != NULL) {
	Tcl_UntraceVar(listPtr->interp, listPtr->listVarName,
		TCL_GLOBAL_ONLY|TCL_TRACE_WRITES|TCL_TRACE_UNSETS,
		ListboxListVarProc, (ClientData) listPtr);
    }
    
    /* Free the selection hash table */
    Tcl_DeleteHashTable(listPtr->selection);
    ckfree((char *)listPtr->selection);

    /* Free the item attribute hash table */
    for (entry = Tcl_FirstHashEntry(listPtr->itemAttrTable, &search);
	 entry != NULL; entry = Tcl_NextHashEntry(&search)) {
	ckfree((char *)Tcl_GetHashValue(entry));
    }
    Tcl_DeleteHashTable(listPtr->itemAttrTable);
    ckfree((char *)listPtr->itemAttrTable);

d974 1
a974 3
    Tk_FreeConfigOptions((char *)listPtr, listPtr->optionTable,
	    listPtr->tkwin);
    listPtr->tkwin = NULL;
a980 27
 * DestroyListboxOptionTables --
 *
 *	This procedure is registered as an exit callback when the listbox
 *	command is first called.  It cleans up the OptionTables structure
 *	allocated by that command.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Frees memory.
 *
 *----------------------------------------------------------------------
 */

static void
DestroyListboxOptionTables(clientData, interp)
    ClientData clientData;	/* Pointer to the OptionTables struct */
    Tcl_Interp *interp;		/* Pointer to the calling interp */
{
    ckfree((char *)clientData);
    return;
}

/*
 *----------------------------------------------------------------------
 *
d983 1
a983 1
 *	This procedure is called to process an objv/objc list, plus
d989 1
a989 1
 *	returned, then the interp's result contains an error message.
d1000 1
a1000 1
ConfigureListbox(interp, listPtr, objc, objv, flags)
d1004 2
a1005 2
    int objc;			/* Number of valid entries in argv. */
    Tcl_Obj *CONST objv[];	/* Arguments. */
a1007 2
    Tk_SavedOptions savedOptions;
    Tcl_Obj *oldListObj = NULL;
d1011 2
a1012 10
    if (listPtr->listVarName != NULL) {
	Tcl_UntraceVar(interp, listPtr->listVarName,
		TCL_GLOBAL_ONLY|TCL_TRACE_WRITES|TCL_TRACE_UNSETS,
		ListboxListVarProc, (ClientData) listPtr);
    }
    
    if (Tk_SetOptions(interp, (char *)listPtr,
	    listPtr->optionTable, objc, objv, listPtr->tkwin,
	    &savedOptions, (int *)NULL) != TCL_OK) {
	Tk_RestoreSavedOptions(&savedOptions);
d1015 1
a1015 1
    
a1038 103
    
    /* Verify the current status of the list var.
     * PREVIOUS STATE    | NEW STATE     | ACTION
     * ------------------+---------------+----------------------------------
     * no listvar        | listvar       | If listvar does not exist, create
     *                                     it and copy the internal list obj's
     *                                     content to the new var.  If it does
     *                                     exist, toss the internal list obj.
     *
     * listvar           | no listvar    | Copy old listvar content to the
     *                                     internal list obj
     *
     * listvar           | listvar       | no special action
     *
     * no listvar        | no listvar    | no special action
     */
    oldListObj = listPtr->listObj;
    if (listPtr->listVarName != NULL) {
	Tcl_Obj *listVarObj = Tcl_GetVar2Ex(interp, listPtr->listVarName,
		(char *)NULL, TCL_GLOBAL_ONLY);
	int dummy;
	if (listVarObj == NULL) {
	    if (listPtr->listObj != NULL) {
		listVarObj = listPtr->listObj;
	    } else {
		listVarObj = Tcl_NewObj();
	    }
	    if (Tcl_SetVar2Ex(interp, listPtr->listVarName, (char *)NULL,
		    listVarObj, TCL_GLOBAL_ONLY) == NULL) {
		Tcl_DecrRefCount(listVarObj);
		Tk_RestoreSavedOptions(&savedOptions);
		return TCL_ERROR;
	    }
	}
	/* Make sure the object is a good list object */
	if (Tcl_ListObjLength(listPtr->interp, listVarObj, &dummy) != TCL_OK) {
	    Tk_RestoreSavedOptions(&savedOptions);
	    Tcl_AppendResult(listPtr->interp, ": invalid listvar value",
		    (char *)NULL);
	    return TCL_ERROR;
	}
    
	listPtr->listObj = listVarObj;
	Tcl_TraceVar(listPtr->interp, listPtr->listVarName,
                TCL_GLOBAL_ONLY|TCL_TRACE_WRITES|TCL_TRACE_UNSETS,
                ListboxListVarProc, (ClientData) listPtr);
    } else {
	if (listPtr->listObj == NULL) {
	    listPtr->listObj = Tcl_NewObj();
	}
    }
    Tcl_IncrRefCount(listPtr->listObj);
    if (oldListObj != NULL) {
	Tcl_DecrRefCount(oldListObj);
    }

    /* Make sure that the list length is correct */
    Tcl_ListObjLength(listPtr->interp, listPtr->listObj, &listPtr->nElements);
    
    Tk_FreeSavedOptions(&savedOptions);
    ListboxWorldChanged((ClientData) listPtr);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ConfigureListboxItem --
 *
 *	This procedure is called to process an objv/objc list, plus
 *	the Tk option database, in order to configure (or reconfigure)
 *	a listbox item.
 *
 * Results:
 *	The return value is a standard Tcl result.  If TCL_ERROR is
 *	returned, then the interp's result contains an error message.
 *
 * Side effects:
 *	Configuration information, such as colors, border width,
 *	etc. get set for a listbox item;  old resources get freed,
 *	if there were any.
 *
 *----------------------------------------------------------------------
 */

static int
ConfigureListboxItem(interp, listPtr, attrs, objc, objv)
    Tcl_Interp *interp;		/* Used for error reporting. */
    register Listbox *listPtr;	/* Information about widget;  may or may
				 * not already have values for some fields. */
    ItemAttr *attrs;		/* Information about the item to configure */
    int objc;			/* Number of valid entries in argv. */
    Tcl_Obj *CONST objv[];	/* Arguments. */
{
    Tk_SavedOptions savedOptions;

    if (Tk_SetOptions(interp, (char *)attrs,
	    listPtr->itemAttrOptionTable, objc, objv, listPtr->tkwin,
	    &savedOptions, (int *)NULL) != TCL_OK) {
	Tk_RestoreSavedOptions(&savedOptions);
	return TCL_ERROR;
    }
    Tk_FreeSavedOptions(&savedOptions);
d1069 1
a1069 1
    
d1076 2
a1077 1
    gc = Tk_GetGC(listPtr->tkwin, mask, &gcValues);
d1086 2
a1087 1
    gc = Tk_GetGC(listPtr->tkwin, mask, &gcValues);
d1100 1
a1100 1
    EventuallyRedrawRange(listPtr, 0, listPtr->nElements-1);
d1125 1
a1128 8
    Tcl_Obj *curElement;
    Tcl_HashEntry *entry;
    char *stringRep;
    int stringLen;
    ItemAttr *attrs;
    Tk_3DBorder selectedBg;
    XGCValues gcValues;
    unsigned long mask;
a1134 7

    if (listPtr->flags & MAXWIDTH_IS_STALE) {
	ListboxComputeGeometry(listPtr, 0, 1, 0);
	listPtr->flags &= ~MAXWIDTH_IS_STALE;
	listPtr->flags |= UPDATE_H_SCROLLBAR;
    }

d1159 6
a1164 1
    /* Display each item in the listbox */
d1166 2
a1167 2
    if (limit >= listPtr->nElements) {
	limit = listPtr->nElements-1;
d1178 5
a1182 2
    
    for (i = listPtr->topIndex; i <= limit; i++) {
d1187 1
a1187 8
	/*
	 * Lookup this item in the item attributes table, to see if it has
	 * special foreground/background colors
	 */
	entry = Tcl_FindHashEntry(listPtr->itemAttrTable, (char *)i);

	/* If the item is selected, it is drawn differently */
	if (Tcl_FindHashEntry(listPtr->selection, (char *)i) != NULL) {
d1190 1
a1190 23
	    selectedBg = listPtr->selBorder;

	    /* If there is attribute information for this item,
	     * adjust the drawing accordingly */
	    if (entry != NULL) {
		attrs = (ItemAttr *)Tcl_GetHashValue(entry);
		/* The default GC has the settings from the widget at large */
		gcValues.foreground = listPtr->selFgColorPtr->pixel;
		gcValues.font = Tk_FontId(listPtr->tkfont);
		gcValues.graphics_exposures = False;
		mask = GCForeground | GCFont | GCGraphicsExposures;

		if (attrs->selBorder != NULL) {
		    selectedBg = attrs->selBorder;
		}

		if (attrs->selFgColor != NULL) {
		    gcValues.foreground = attrs->selFgColor->pixel;
		    gc = Tk_GetGC(listPtr->tkwin, mask, &gcValues);
		}
	    }

	    Tk_Fill3DRectangle(tkwin, pixmap, selectedBg, x, y,
a1207 1
	    /* Draw left bevel */
d1209 1
a1209 1
		Tk_3DVerticalBevel(tkwin, pixmap, selectedBg,
a1212 1
	    /* Draw right bevel */
d1214 1
a1214 1
		Tk_3DVerticalBevel(tkwin, pixmap, selectedBg,
a1218 1
	    /* Draw top bevel */
d1220 1
a1220 1
		Tk_3DHorizontalBevel(tkwin, pixmap, selectedBg,
d1224 2
a1225 5
	    /* Draw bottom bevel */
	    if (i + 1 == listPtr->nElements ||
		    Tcl_FindHashEntry(listPtr->selection,
			    (char *)(i + 1)) == NULL ) {
		Tk_3DHorizontalBevel(tkwin, pixmap, selectedBg, x-left,
a1229 22
	    prevSelected = 1;
	} else {
	    /* If there is an item attributes record for this item,
	     * draw the background box and set the foreground color
	     * accordingly */
	    if (entry != NULL) {
		attrs = (ItemAttr *)Tcl_GetHashValue(entry);
		gcValues.foreground = listPtr->fgColorPtr->pixel;
		gcValues.font = Tk_FontId(listPtr->tkfont);
		gcValues.graphics_exposures = False;
		mask = GCForeground | GCFont | GCGraphicsExposures;
		if (attrs->border != NULL) {
		    width = Tk_Width(tkwin) - 2*listPtr->inset;
		    Tk_Fill3DRectangle(tkwin, pixmap, attrs->border, x, y,
			    width, listPtr->lineHeight, 0, TK_RELIEF_FLAT);
		}
		if (attrs->fgColor != NULL) {
		    gcValues.foreground = attrs->fgColor->pixel;
		    gc = Tk_GetGC(listPtr->tkwin, mask, &gcValues);
		}
	    }
	    prevSelected = 0;
a1230 2

	/* Draw the actual text of this item */
d1233 2
a1234 3
	x = listPtr->inset + listPtr->selBorderWidth - listPtr->xOffset;
	Tcl_ListObjIndex(listPtr->interp, listPtr->listObj, i, &curElement);
	stringRep = Tcl_GetStringFromObj(curElement, &stringLen);
d1236 5
a1240 1
		stringRep, stringLen, x, y);
a1241 1
	/* If this is the active element, underline it. */
d1244 1
a1244 1
		    stringRep, x, y, 0, stringLen);
d1259 1
a1259 1
	GC fgGC, bgGC;
a1260 1
	bgGC = Tk_GCForColor(listPtr->highlightBgColorPtr, pixmap);
d1262 1
a1262 3
	    fgGC = Tk_GCForColor(listPtr->highlightColorPtr, pixmap);
	    TkpDrawHighlightBorder(tkwin, fgGC, bgGC, 
	            listPtr->highlightWidth, pixmap);
d1264 1
a1264 2
	    TkpDrawHighlightBorder(tkwin, bgGC, bgGC, 
	            listPtr->highlightWidth, pixmap);
d1266 1
d1309 1
d1312 1
a1312 5
    Tcl_Obj *element;
    int textLength;
    char *text;
    int i, result;
    
d1319 5
a1323 6
	for (i = 0; i < listPtr->nElements; i++) {
	    /* Compute the pixel width of the current element */
	    result = Tcl_ListObjIndex(listPtr->interp, listPtr->listObj, i,
		    &element);
	    if (result != TCL_OK) {
		continue;
d1325 2
a1326 5
	    text = Tcl_GetStringFromObj(element, &textLength);
	    Tk_GetFontMetrics(listPtr->tkfont, &fm);
	    pixelWidth = Tk_TextWidth(listPtr->tkfont, text, textLength);
	    if (pixelWidth > listPtr->maxWidth) {
		listPtr->maxWidth = pixelWidth;
d1345 1
a1345 1
	height = listPtr->nElements;
d1366 1
a1366 1
 * ListboxInsertSubCmd --
d1368 1
a1368 2
 *	This procedure is invoked to handle the listbox "insert"
 *      subcommand.
d1371 1
a1371 1
 *	Standard Tcl result.
d1374 2
a1375 2
 *	New elements are added to the listbox pointed to by listPtr;
 *      a refresh callback is registered for the listbox.
d1380 2
a1381 2
static int
ListboxInsertSubCmd(listPtr, index, objc, objv)
d1386 2
a1387 2
    int objc;			/* Number of new elements to add. */
    Tcl_Obj *CONST objv[];	/* New elements (one per entry). */
d1389 12
a1400 18
    int i, oldMaxWidth;
    Tcl_Obj *newListObj;
    int pixelWidth;
    int result;
    char *stringRep;
    int length;
    
    oldMaxWidth = listPtr->maxWidth;
    for (i = 0; i < objc; i++) {
	/*
	 * Check if any of the new elements are wider than the current widest;
	 * if so, update our notion of "widest."
	 */
	stringRep = Tcl_GetStringFromObj(objv[i], &length);
	pixelWidth = Tk_TextWidth(listPtr->tkfont, stringRep, length);
	if (pixelWidth > listPtr->maxWidth) {
	    listPtr->maxWidth = pixelWidth;
	}
d1402 4
a1405 10
    
    /* Adjust selection and attribute information for every index after
     * the first index */
    MigrateHashEntries(listPtr->selection, index, listPtr->nElements-1, objc);
    MigrateHashEntries(listPtr->itemAttrTable, index, listPtr->nElements-1,
	    objc);
    
    /* If the object is shared, duplicate it before writing to it */
    if (Tcl_IsShared(listPtr->listObj)) {
	newListObj = Tcl_DuplicateObj(listPtr->listObj);
d1407 3
a1409 6
	newListObj = listPtr->listObj;
    }
    result =
	Tcl_ListObjReplace(listPtr->interp, newListObj, index, 0, objc, objv);
    if (result != TCL_OK) {
	return result;
d1412 4
a1415 3
    Tcl_IncrRefCount(newListObj);
    /* Clean up the old reference */
    Tcl_DecrRefCount(listPtr->listObj);
d1417 19
a1435 9
    /* Set the internal pointer to the new obj */
    listPtr->listObj = newListObj;

    /* If there is a listvar, make sure it points at the new object */
    if (listPtr->listVarName != NULL) {
	if (Tcl_SetVar2Ex(listPtr->interp, listPtr->listVarName,
		(char *)NULL, newListObj, TCL_GLOBAL_ONLY) == NULL) {
	    Tcl_DecrRefCount(newListObj);
	    return TCL_ERROR;
d1438 4
a1442 3
    /* Get the new list length */
    Tcl_ListObjLength(listPtr->interp, listPtr->listObj, &listPtr->nElements);
    
d1444 2
a1445 2
     * Update the "special" indices (anchor, topIndex, active) to account
     * for the renumbering that just occurred.  Then arrange for the new
d1450 1
a1450 1
	listPtr->selectAnchor += objc;
d1453 1
a1453 1
	listPtr->topIndex += objc;
d1456 4
a1459 4
	listPtr->active += objc;
	if ((listPtr->active >= listPtr->nElements) &&
		(listPtr->nElements > 0)) {
	    listPtr->active = listPtr->nElements-1;
d1467 1
a1467 2
    EventuallyRedrawRange(listPtr, index, listPtr->nElements-1);
    return TCL_OK;
d1473 1
a1473 1
 * ListboxDeleteSubCmd --
d1475 1
a1475 2
 *	Process a listbox "delete" subcommand by removing one or more
 *      elements from a listbox widget.
d1478 1
a1478 1
 *	Standard Tcl result.
d1481 2
a1482 1
 *	The listbox will be modified and (eventually) redisplayed.
d1487 2
a1488 2
static int
ListboxDeleteSubCmd(listPtr, first, last)
d1493 1
d1495 1
a1495 8
    Tcl_Obj *newListObj;
    Tcl_Obj *element;
    int length;
    char *stringRep;
    int result;
    int pixelWidth;
    Tcl_HashEntry *entry;
    
d1504 2
a1505 2
    if (last >= listPtr->nElements) {
	last = listPtr->nElements-1;
d1509 1
a1509 1
	return TCL_OK;
d1513 1
a1513 5
     * Foreach deleted index we must:
     * a) remove selection information
     * b) check the width of the element; if it is equal to the max, set
     *    widthChanged to 1, because it may be the only element with that
     *    width
a1514 27
    widthChanged = 0;
    for (i = first; i <= last; i++) {
	/* Remove selection information */
	entry = Tcl_FindHashEntry(listPtr->selection, (char *)i);
	if (entry != NULL) {
	    listPtr->numSelected--;
	    Tcl_DeleteHashEntry(entry);
	}

	entry = Tcl_FindHashEntry(listPtr->itemAttrTable, (char *)i);
	if (entry != NULL) {
	    Tcl_DeleteHashEntry(entry);
	}
	
	/* Check width of the element.  We only have to check if widthChanged
	 * has not already been set to 1, because we only need one maxWidth
	 * element to disappear for us to have to recompute the width
	 */
	if (widthChanged == 0) {
	    Tcl_ListObjIndex(listPtr->interp, listPtr->listObj, i, &element);
	    stringRep = Tcl_GetStringFromObj(element, &length);
	    pixelWidth = Tk_TextWidth(listPtr->tkfont, stringRep, length);
	    if (pixelWidth == listPtr->maxWidth) {
		widthChanged = 1;
	    }
	}
    }
d1516 2
a1517 9
    /* Adjust selection and attribute info for indices after lastIndex */
    MigrateHashEntries(listPtr->selection, last+1,
	    listPtr->nElements-1, count*-1);
    MigrateHashEntries(listPtr->itemAttrTable, last+1,
	    listPtr->nElements-1, count*-1);

    /* Delete the requested elements */
    if (Tcl_IsShared(listPtr->listObj)) {
	newListObj = Tcl_DuplicateObj(listPtr->listObj);
d1519 3
a1521 6
	newListObj = listPtr->listObj;
    }
    result = Tcl_ListObjReplace(listPtr->interp,
	    newListObj, first, count, 0, NULL);
    if (result != TCL_OK) {
	return result;
d1524 3
a1526 3
    Tcl_IncrRefCount(newListObj);
    /* Clean up the old reference */
    Tcl_DecrRefCount(listPtr->listObj);
d1528 20
a1547 12
    /* Set the internal pointer to the new obj */
    listPtr->listObj = newListObj;

    /* Get the new list length */
    Tcl_ListObjLength(listPtr->interp, listPtr->listObj, &listPtr->nElements);
    
    /* If there is a listvar, make sure it points at the new object */
    if (listPtr->listVarName != NULL) {
	if (Tcl_SetVar2Ex(listPtr->interp, listPtr->listVarName,
		(char *)NULL, newListObj, TCL_GLOBAL_ONLY) == NULL) {
	    Tcl_DecrRefCount(newListObj);
	    return TCL_ERROR;
d1549 1
d1551 1
d1571 2
a1572 2
    if (listPtr->topIndex > (listPtr->nElements - listPtr->fullLines)) {
	listPtr->topIndex = listPtr->nElements - listPtr->fullLines;
d1581 3
a1583 3
	if ((listPtr->active >= listPtr->nElements) &&
		(listPtr->nElements > 0)) {
	    listPtr->active = listPtr->nElements-1;
d1591 1
a1591 2
    EventuallyRedrawRange(listPtr, first, listPtr->nElements-1);
    return TCL_OK;
d1618 1
a1618 1
    
d1620 1
a1620 1
	EventuallyRedrawRange(listPtr,
d1625 11
a1635 1
	DestroyListbox((char *) clientData);
d1657 1
a1657 1
	EventuallyRedrawRange(listPtr, 0, listPtr->nElements-1);
d1661 1
a1661 1
	    EventuallyRedrawRange(listPtr, 0, listPtr->nElements-1);
d1666 1
a1666 1
	    EventuallyRedrawRange(listPtr, 0, listPtr->nElements-1);
d1694 1
d1703 6
a1708 2
    if (!(listPtr->flags & LISTBOX_DELETED)) {
	Tk_DestroyWindow(listPtr->tkwin);
d1723 1
a1723 1
 *	string.  Otherwise an error message is left in the interp's result.
d1732 1
a1732 1
GetListboxIndex(interp, listPtr, indexObj, endIsSize, indexPtr)
d1736 1
a1736 1
    Tcl_Obj *indexObj;		/* Specifies an element in the listbox. */
d1743 16
a1758 29
    int result;
    int index;
    char *stringRep;
    
    /* First see if the index is one of the named indices */
    result = Tcl_GetIndexFromObj(NULL, indexObj, indexNames, "", 0, &index);
    if (result == TCL_OK) {
	switch (index) {
	    case INDEX_ACTIVE: {
		/* "active" index */
		*indexPtr = listPtr->active;
		break;
	    }

	    case INDEX_ANCHOR: {
		/* "anchor" index */
		*indexPtr = listPtr->selectAnchor;
		break;
	    }

	    case INDEX_END: {
		/* "end" index */
		if (endIsSize) {
		    *indexPtr = listPtr->nElements;
		} else {
		    *indexPtr = listPtr->nElements - 1;
		}
		break;
	    }
d1760 3
a1762 2
	return TCL_OK;
    }
d1764 9
a1772 21
    /* The index didn't match any of the named indices; maybe it's an @@x,y */
    stringRep = Tcl_GetString(indexObj);
    if (stringRep[0] == '@@') {
	/* @@x,y index */
	int y;
	char *start, *end;
	start = stringRep + 1;
	strtol(start, &end, 0);
	if ((start == end) || (*end != ',')) {
	    Tcl_AppendResult(interp, "bad listbox index \"", stringRep,
		    "\": must be active, anchor, end, @@x,y, or a number",
		    (char *)NULL);
	    return TCL_ERROR;
	}
	start = end+1;
	y = strtol(start, &end, 0);
	if ((start == end) || (*end != '\0')) {
	    Tcl_AppendResult(interp, "bad listbox index \"", stringRep,
		    "\": must be active, anchor, end, @@x,y, or a number",
		    (char *)NULL);
	    return TCL_ERROR;
d1775 5
a1779 6
	return TCL_OK;
    }
    
    /* Maybe the index is just an integer */
    if (Tcl_GetIntFromObj(interp, indexObj, indexPtr) == TCL_OK) {
	return TCL_OK;
d1781 1
d1783 4
a1786 5
    /* Everything failed, nothing matched.  Throw up an error message */
    Tcl_ResetResult(interp);
    Tcl_AppendResult(interp, "bad listbox index \"",
	    Tcl_GetString(indexObj), "\": must be active, anchor, ",
	    "end, @@x,y, or a number", (char *) NULL);
d1816 2
a1817 2
    if (index >= (listPtr->nElements - listPtr->fullLines)) {
	index = listPtr->nElements - listPtr->fullLines;
d1824 4
a1827 1
	EventuallyRedrawRange(listPtr, 0, listPtr->nElements-1);
d1856 1
a1856 1
    
d1875 1
a1875 1
	EventuallyRedrawRange(listPtr, 0, listPtr->nElements-1);
d1905 2
a1906 2
    
    maxIndex = listPtr->nElements - listPtr->fullLines;
d1984 2
a1985 2
    if (index >= listPtr->nElements) {
	index = listPtr->nElements-1;
d1998 1
a1998 1
 *	Standard Tcl result.
d2010 1
a2010 1
static int
d2021 2
a2022 3
    Tcl_HashEntry *entry;
    int new;
    
d2028 2
a2029 2
    if ((last < 0) || (first >= listPtr->nElements)) {
	return TCL_OK;
d2034 2
a2035 2
    if (last >= listPtr->nElements) {
	last = listPtr->nElements - 1;
d2040 12
a2051 26

    /*
     * For each index in the range, find it in our selection hash table.
     * If it's not there but should be, add it.  If it's there but shouldn't
     * be, remove it.
     */
    for (i = first; i <= last; i++) {
	entry = Tcl_FindHashEntry(listPtr->selection, (char *)i);
	if (entry != NULL) {
	    if (!select) {
		Tcl_DeleteHashEntry(entry);
		listPtr->numSelected--;
		if (firstRedisplay < 0) {
		    firstRedisplay = i;
		}
	    }
	} else {
	    if (select) {
		entry = Tcl_CreateHashEntry(listPtr->selection,
			(char *)i, &new);
		Tcl_SetHashValue(entry, (ClientData) NULL);
		listPtr->numSelected++;
		if (firstRedisplay < 0) {
		    firstRedisplay = i;
		}
	    }
a2053 1

d2055 1
a2055 1
	EventuallyRedrawRange(listPtr, first, last);
a2061 1
    return TCL_OK;
d2099 1
d2102 1
a2102 6
    Tcl_Obj *curElement;
    char *stringRep;
    int stringLen;
    Tcl_HashEntry *entry;
    int i;
    
d2113 2
a2114 3
    for (i = 0; i < listPtr->nElements; i++) {
	entry = Tcl_FindHashEntry(listPtr->selection, (char *)i);
	if (entry != NULL) {
d2118 1
a2118 4
	    Tcl_ListObjIndex(listPtr->interp, listPtr->listObj, i,
		    &curElement);
	    stringRep = Tcl_GetStringFromObj(curElement, &stringLen);
	    Tcl_DStringAppend(&selection, stringRep, stringLen);
d2171 3
a2173 3
    
    if ((listPtr->exportSelection) && (listPtr->nElements > 0)) {
	ListboxSelect(listPtr, 0, listPtr->nElements-1, 0);
d2180 1
a2180 1
 * EventuallyRedrawRange --
d2194 1
d2196 1
a2196 1
EventuallyRedrawRange(listPtr, first, last)
d2205 2
a2206 5
    /* We don't have to register a redraw callback if one is already pending,
     * or if the window doesn't exist, or if the window isn't mapped */
    if ((listPtr->flags & REDRAW_PENDING)
	    || (listPtr->tkwin == NULL)
	    || !Tk_IsMapped(listPtr->tkwin)) {
d2209 1
a2210 1
    Tcl_DoWhenIdle(DisplayListbox, (ClientData) listPtr);
d2237 1
a2237 1
    char string[TCL_DOUBLE_SPACE * 2];
d2241 1
a2241 1
    
d2245 1
a2245 1
    if (listPtr->nElements == 0) {
d2249 1
a2249 1
	first = listPtr->topIndex/((double) listPtr->nElements);
d2251 1
a2251 1
		/((double) listPtr->nElements);
d2299 1
a2299 1
    char string[TCL_DOUBLE_SPACE * 2];
a2337 171

/*
 *----------------------------------------------------------------------
 *
 * ListboxListVarProc --
 *
 *      Called whenever the trace on the listbox list var fires.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */

static char *
ListboxListVarProc(clientData, interp, name1, name2, flags)
    ClientData clientData;      /* Information about button. */
    Tcl_Interp *interp;         /* Interpreter containing variable. */
    char *name1;                /* Not used. */
    char *name2;                /* Not used. */
    int flags;                  /* Information about what happened. */
{
    Listbox *listPtr = (Listbox *)clientData;
    Tcl_Obj *oldListObj, *varListObj;
    int oldLength;
    int i;
    Tcl_HashEntry *entry;
    
    /* Bwah hahahaha -- puny mortal, you can't unset a -listvar'd variable! */
    if (flags & TCL_TRACE_UNSETS) {
	if ((flags & TCL_TRACE_DESTROYED) && !(flags & TCL_INTERP_DESTROYED)) {
	    Tcl_SetVar2Ex(interp, listPtr->listVarName,
		    (char *)NULL, listPtr->listObj, TCL_GLOBAL_ONLY);
	    Tcl_TraceVar(interp, listPtr->listVarName,
		    TCL_GLOBAL_ONLY|TCL_TRACE_WRITES|TCL_TRACE_UNSETS,
		    ListboxListVarProc, clientData);
	    return (char *)NULL;
	}
    } else {
	oldListObj = listPtr->listObj;
	varListObj = Tcl_GetVar2Ex(listPtr->interp, listPtr->listVarName,
		(char *)NULL, TCL_GLOBAL_ONLY);
	/*
	 * Make sure the new value is a good list; if it's not, disallow
	 * the change -- the fact that it is a listvar means that it must
	 * always be a valid list -- and return an error message.
	 */
	if (Tcl_ListObjLength(listPtr->interp, varListObj, &i) != TCL_OK) {
	    Tcl_SetVar2Ex(interp, listPtr->listVarName, (char *)NULL,
		    oldListObj, TCL_GLOBAL_ONLY);
	    return("invalid listvar value");
	}
	
	listPtr->listObj = varListObj;
	/* Incr the obj ref count so it doesn't vanish if the var is unset */
	Tcl_IncrRefCount(listPtr->listObj);
	/* Clean up the ref to our old list obj */
	Tcl_DecrRefCount(oldListObj);
    }

    /*
     * If the list length has decreased, then we should clean up selection and
     * attributes information for elements past the end of the new list
     */
    oldLength = listPtr->nElements;
    Tcl_ListObjLength(listPtr->interp, listPtr->listObj, &listPtr->nElements);
    if (listPtr->nElements < oldLength) {
	for (i = listPtr->nElements; i < oldLength; i++) {
	    /* Clean up selection */
	    entry = Tcl_FindHashEntry(listPtr->selection, (char *)i);
	    if (entry != NULL) {
		listPtr->numSelected--;
		Tcl_DeleteHashEntry(entry);
	    }

	    /* Clean up attributes */
	    entry = Tcl_FindHashEntry(listPtr->itemAttrTable, (char *)i);
	    if (entry != NULL) {
		Tcl_DeleteHashEntry(entry);
	    }
	}
    }

    if (oldLength != listPtr->nElements) {
	listPtr->flags |= UPDATE_V_SCROLLBAR;
	if (listPtr->topIndex > (listPtr->nElements - listPtr->fullLines)) {
	    listPtr->topIndex = listPtr->nElements - listPtr->fullLines;
	    if (listPtr->topIndex < 0) {
		listPtr->topIndex = 0;
	    }
	}
    }

    /*
     * The computed maxWidth may have changed as a result of this operation.
     * However, we don't want to recompute it every time this trace fires
     * (imagine the user doing 1000 lappends to the listvar).  Therefore, set
     * the MAXWIDTH_IS_STALE flag, which will cause the width to be recomputed
     * next time the list is redrawn.
     */
    listPtr->flags |= MAXWIDTH_IS_STALE;
    
    EventuallyRedrawRange(listPtr, 0, listPtr->nElements-1);
    return (char*)NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * MigrateHashEntries --
 *
 *	Given a hash table with entries keyed by a single integer value,
 *	move all entries in a given range by a fixed amount, so that
 *	if in the original table there was an entry with key n and
 *	the offset was i, in the new table that entry would have key n + i.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Rekeys some hash table entries.
 *
 *----------------------------------------------------------------------
 */

static void
MigrateHashEntries(table, first, last, offset)
    Tcl_HashTable *table;
    int first;
    int last;
    int offset;
{
    int i, new;
    Tcl_HashEntry *entry;
    ClientData clientData;

    if (offset == 0) {
	return;
    }
    /* It's more efficient to do one if/else and nest the for loops inside,
     * although we could avoid some code duplication if we nested the if/else
     * inside the for loops */
    if (offset > 0) {
	for (i = last; i >= first; i--) {
	    entry = Tcl_FindHashEntry(table, (char *)i);
	    if (entry != NULL) {
		clientData = Tcl_GetHashValue(entry);
		Tcl_DeleteHashEntry(entry);
		entry = Tcl_CreateHashEntry(table, (char *)(i + offset), &new);
		Tcl_SetHashValue(entry, clientData);
	    }
	}
    } else {
	for (i = first; i <= last; i++) {
	    entry = Tcl_FindHashEntry(table, (char *)i);
	    if (entry != NULL) {
		clientData = Tcl_GetHashValue(entry);
		Tcl_DeleteHashEntry(entry);
		entry = Tcl_CreateHashEntry(table, (char *)(i + offset), &new);
		Tcl_SetHashValue(entry, clientData);
	    }
	}
    }
    return;
}



@


1.1.1.3
log
@import tk 8.4.0
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tkListbox.c,v 1.28 2002/08/05 04:30:39 dgp Exp $
a20 4
#ifdef WIN32
#include "tkWinInt.h"
#endif

a76 1
    XColor *dfgColorPtr;	/* Text color in disabled mode. */
a129 2
    int activeStyle;		/* style in which to draw the active element.
				 * One of: underline, none, dotbox */
a157 2
    int state;			/* Listbox state. */
    Pixmap gray;		/* Pixmap for displaying disabled text. */
a196 22
 * The following enum is used to define a type for the -state option
 * of the Entry widget.  These values are used as indices into the 
 * string table below.
 */

enum state {
    STATE_DISABLED, STATE_NORMAL
};

static char *stateStrings[] = {
    "disabled", "normal", (char *) NULL
};

enum activeStyle {
    ACTIVE_STYLE_DOTBOX, ACTIVE_STYLE_NONE, ACTIVE_STYLE_UNDERLINE
};

static char *activeStyleStrings[] = {
    "dotbox", "none", "underline", (char *) NULL
};

/*
a200 3
    {TK_OPTION_STRING_TABLE, "-activestyle", "activeStyle", "ActiveStyle",
	DEF_LISTBOX_ACTIVE_STYLE, -1, Tk_Offset(Listbox, activeStyle),
        0, (ClientData) activeStyleStrings, 0},
a213 3
    {TK_OPTION_COLOR, "-disabledforeground", "disabledForeground",
	 "DisabledForeground", DEF_LISTBOX_DISABLED_FG, -1,
	 Tk_Offset(Listbox, dfgColorPtr), TK_OPTION_NULL_OK, 0, 0},
a249 3
    {TK_OPTION_STRING_TABLE, "-state", "state", "State",
	DEF_LISTBOX_STATE, -1, Tk_Offset(Listbox, state), 
        0, (ClientData) stateStrings, 0},
d274 2
a275 2
     (char *)NULL, -1, Tk_Offset(ItemAttr, border),
     TK_OPTION_NULL_OK|TK_OPTION_DONT_SET_DEFAULT,
d278 1
a278 1
     (char *) NULL, 0, -1, 0, (ClientData) "-background", 0},
d280 1
a280 1
     (char *) NULL, 0, -1, 0, (ClientData) "-foreground", 0},
d282 2
a283 2
     (char *) NULL, -1, Tk_Offset(ItemAttr, fgColor),
     TK_OPTION_NULL_OK|TK_OPTION_DONT_SET_DEFAULT, 0, 0},
d285 2
a286 2
     (char *) NULL, -1, Tk_Offset(ItemAttr, selBorder),
     TK_OPTION_NULL_OK|TK_OPTION_DONT_SET_DEFAULT,
d289 2
a290 2
     (char *) NULL, -1, Tk_Offset(ItemAttr, selFgColor),
     TK_OPTION_NULL_OK|TK_OPTION_DONT_SET_DEFAULT,
d293 1
a293 1
     (char *) NULL, 0, -1, 0, 0, 0}
d301 1
a301 1
static CONST char *commandNames[] = {
d303 2
a304 2
    "index", "insert", "itemcget", "itemconfigure", "nearest", "scan",
    "see", "selection", "size", "xview", "yview",
d310 4
a313 4
    COMMAND_CURSELECTION, COMMAND_DELETE, COMMAND_GET, COMMAND_INDEX,
    COMMAND_INSERT, COMMAND_ITEMCGET, COMMAND_ITEMCONFIGURE,
    COMMAND_NEAREST, COMMAND_SCAN, COMMAND_SEE, COMMAND_SELECTION,
    COMMAND_SIZE, COMMAND_XVIEW, COMMAND_YVIEW
d316 1
a316 1
static CONST char *selCommandNames[] = {
d324 1
a324 1
static CONST char *scanCommandNames[] = {
d332 1
a332 1
static CONST char *indexNames[] = {
d405 2
a406 2
	                    Tcl_Interp *interp, CONST char *name1,
			    CONST char *name2, int flags));
d414 4
a417 3
static Tk_ClassProcs listboxClass = {
    sizeof(Tk_ClassProcs),	/* size */
    ListboxWorldChanged,	/* worldChangedProc */
d441 1
a441 1
    ClientData clientData;	/* NULL. */
d450 4
a453 4
    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "pathName ?options?");
	return TCL_ERROR;
    }
a454 9
    tkwin = Tk_CreateWindowFromPath(interp, Tk_MainWindow(interp),
	    Tcl_GetString(objv[1]), (char *) NULL);
    if (tkwin == NULL) {
	return TCL_ERROR;
    }

    optionTables = (ListboxOptionTables *)
	Tcl_GetAssocData(interp, "ListboxOptionTables", NULL);
    if (optionTables == NULL) {
d460 2
a461 3

	optionTables = (ListboxOptionTables *)
	    ckalloc(sizeof(ListboxOptionTables));
d471 17
a495 2
    memset((void *) listPtr, 0, (sizeof(Listbox)));

d504 2
d512 3
d516 6
d523 2
d527 4
d532 3
d536 4
d541 5
d547 4
a550 9
    listPtr->state			= STATE_NORMAL;
    listPtr->gray			= None;

    /*
     * Keep a hold of the associated tkwin until we destroy the listbox,
     * otherwise Tk might free it while we still need it.
     */

    Tcl_Preserve((ClientData) listPtr->tkwin);
d553 1
a553 1
    Tk_SetClassProcs(listPtr->tkwin, &listboxClass, (ClientData) listPtr);
d607 1
d616 1
a619 1
    Tcl_Preserve((ClientData)listPtr);
a631 5

	    if (!(listPtr->state & STATE_NORMAL)) {
		break;
	    }

a735 5

	    if (!(listPtr->state & STATE_NORMAL)) {
		break;
	    }

a840 5

	    if (!(listPtr->state & STATE_NORMAL)) {
		break;
	    }

a1020 4
	    if (!(listPtr->state & STATE_NORMAL)) {
		break;
	    }

d1415 10
a1460 4
    if (listPtr->gray != None) {
	Tk_FreeBitmap(Tk_Display(listPtr->tkwin), listPtr->gray);
    }

a1462 1
    Tcl_Release((ClientData) listPtr->tkwin);
d1526 1
a1526 2
    Tcl_Obj *errorResult = NULL;
    int oldExport, error;
d1534 12
d1547 1
a1547 5
    for (error = 0; error <= 1; error++) {
	if (!error) {
	    /*
	     * First pass: set options to new values.
	     */
d1549 4
a1552 9
	    if (Tk_SetOptions(interp, (char *) listPtr,
		    listPtr->optionTable, objc, objv,
		    listPtr->tkwin, &savedOptions, (int *) NULL) != TCL_OK) {
		continue;
	    }
	} else {
	    /*
	     * Second pass: restore options to old values.
	     */
d1554 4
a1557 4
	    errorResult = Tcl_GetObjResult(interp);
	    Tcl_IncrRefCount(errorResult);
	    Tk_RestoreSavedOptions(&savedOptions);
	}
d1559 5
a1563 4
	/*
	 * A few options need special processing, such as setting the
	 * background from a 3-D border.
	 */
d1565 26
a1590 48
	Tk_SetBackgroundFromBorder(listPtr->tkwin, listPtr->normalBorder);

	if (listPtr->highlightWidth < 0) {
	    listPtr->highlightWidth = 0;
	}
	listPtr->inset = listPtr->highlightWidth + listPtr->borderWidth;

	/*
	 * Claim the selection if we've suddenly started exporting it and
	 * there is a selection to export.
	 */

	if (listPtr->exportSelection && !oldExport
		&& (listPtr->numSelected != 0)) {
	    Tk_OwnSelection(listPtr->tkwin, XA_PRIMARY, ListboxLostSelection,
		    (ClientData) listPtr);
	}

	/* Verify the current status of the list var.
	 * PREVIOUS STATE | NEW STATE  | ACTION
	 * ---------------+------------+----------------------------------
	 * no listvar     | listvar    | If listvar does not exist, create
	 *                               it and copy the internal list obj's
	 *                               content to the new var.  If it does
	 *                               exist, toss the internal list obj.
	 *
	 * listvar        | no listvar | Copy old listvar content to the
	 *                               internal list obj
	 *
	 * listvar        | listvar    | no special action
	 *
	 * no listvar     | no listvar | no special action
	 */
	oldListObj = listPtr->listObj;
	if (listPtr->listVarName != NULL) {
	    Tcl_Obj *listVarObj = Tcl_GetVar2Ex(interp, listPtr->listVarName,
		    (char *) NULL, TCL_GLOBAL_ONLY);
	    int dummy;
	    if (listVarObj == NULL) {
		listVarObj = (oldListObj ? oldListObj : Tcl_NewObj());
		if (Tcl_SetVar2Ex(interp, listPtr->listVarName, (char *) NULL,
			listVarObj, TCL_GLOBAL_ONLY|TCL_LEAVE_ERR_MSG)
			== NULL) {
		    if (oldListObj == NULL) {
			Tcl_DecrRefCount(listVarObj);
		    }
		    continue;
		}
d1592 5
a1596 6
	    /* Make sure the object is a good list object */
	    if (Tcl_ListObjLength(listPtr->interp, listVarObj, &dummy)
		    != TCL_OK) {
		Tcl_AppendResult(listPtr->interp,
			": invalid -listvariable value", (char *) NULL);
		continue;
d1598 15
a1612 6

	    listPtr->listObj = listVarObj;
	    Tcl_TraceVar(listPtr->interp, listPtr->listVarName,
		    TCL_GLOBAL_ONLY|TCL_TRACE_WRITES|TCL_TRACE_UNSETS,
		    ListboxListVarProc, (ClientData) listPtr);
	} else if (listPtr->listObj == NULL) {
a1614 5
	Tcl_IncrRefCount(listPtr->listObj);
	if (oldListObj != NULL) {
	    Tcl_DecrRefCount(oldListObj);
	}
	break;
d1616 3
a1618 2
    if (!error) {
	Tk_FreeSavedOptions(&savedOptions);
d1624 3
a1626 8
    if (error) {
        Tcl_SetObjResult(interp, errorResult);
	Tcl_DecrRefCount(errorResult);
	return TCL_ERROR;
    } else {
	ListboxWorldChanged((ClientData) listPtr);
	return TCL_OK;
    }
d1701 1
a1701 23
    if (listPtr->state & STATE_NORMAL) {
	gcValues.foreground = listPtr->fgColorPtr->pixel;
	gcValues.graphics_exposures = False;
	mask = GCForeground | GCFont | GCGraphicsExposures;
    } else {
	if (listPtr->dfgColorPtr != NULL) {
	    gcValues.foreground = listPtr->dfgColorPtr->pixel;
	    gcValues.graphics_exposures = False;
	    mask = GCForeground | GCFont | GCGraphicsExposures;
	} else {
	    gcValues.foreground = listPtr->fgColorPtr->pixel;
	    mask = GCForeground | GCFont;
	    if (listPtr->gray == None) {
		listPtr->gray = Tk_GetBitmap(NULL, listPtr->tkwin, "gray50");
	    }
	    if (listPtr->gray != None) {
		gcValues.fill_style = FillStippled;
		gcValues.stipple = listPtr->gray;
		mask |= GCFillStyle | GCStipple;
	    }
	}
    }

d1703 2
d1753 1
a1753 1
    int i, limit, x, y, width, prevSelected, freeGC;
a1768 3
    if (listPtr->flags & LISTBOX_DELETED) {
	return;
    }
a1775 1
    Tcl_Preserve((ClientData) listPtr);
a1777 4
	if ((listPtr->flags & LISTBOX_DELETED) || !Tk_IsMapped(tkwin)) {
	    Tcl_Release((ClientData) listPtr);
	    return;
	}
a1780 4
	if ((listPtr->flags & LISTBOX_DELETED) || !Tk_IsMapped(tkwin)) {
	    Tcl_Release((ClientData) listPtr);
	    return;
	}
d1783 3
a1785 1
    Tcl_Release((ClientData) listPtr);
a1819 1
	freeGC = 0;
d1826 18
a1843 31
	/*
	 * If the listbox is enabled, items may be drawn differently;
	 * they may be drawn selected, or they may have special foreground
	 * or background colors.
	 */
	if (listPtr->state & STATE_NORMAL) {
	    if (Tcl_FindHashEntry(listPtr->selection, (char *)i) != NULL) {
		/* Selected items are drawn differently. */
		gc = listPtr->selTextGC;
		width = Tk_Width(tkwin) - 2*listPtr->inset;
		selectedBg = listPtr->selBorder;
		
		/* If there is attribute information for this item,
		 * adjust the drawing accordingly */
		if (entry != NULL) {
		    attrs = (ItemAttr *)Tcl_GetHashValue(entry);
		    /* Default GC has the values from the widget at large */
		    gcValues.foreground = listPtr->selFgColorPtr->pixel;
		    gcValues.font = Tk_FontId(listPtr->tkfont);
		    gcValues.graphics_exposures = False;
		    mask = GCForeground | GCFont | GCGraphicsExposures;
		    
		    if (attrs->selBorder != NULL) {
			selectedBg = attrs->selBorder;
		    }
		    
		    if (attrs->selFgColor != NULL) {
			gcValues.foreground = attrs->selFgColor->pixel;
			gc = Tk_GetGC(listPtr->tkwin, mask, &gcValues);
			freeGC = 1;
		    }
d1846 5
a1850 2
		Tk_Fill3DRectangle(tkwin, pixmap, selectedBg, x, y,
			width, listPtr->lineHeight, 0, TK_RELIEF_FLAT);
d1852 17
a1868 15
		/*
		 * Draw beveled edges around the selection, if there are
		 * visible edges next to this element. Special considerations:
		 *
		 * 1. The left and right bevels may not be visible if
		 *	horizontal scrolling is enabled (the "left" & "right"
		 *	variables are zero to indicate that the corresponding
		 *	bevel is visible).
		 * 2. Top and bottom bevels are only drawn if this is the
		 *	first or last seleted item.
		 * 3. If the left or right bevel isn't visible, then the
		 *	"left" & "right" vars, computed above, have non-zero
		 *	values that extend the top and bottom bevels so that
		 *	the mitered corners are off-screen.
		 */
d1870 47
a1916 28
		/* Draw left bevel */
		if (left == 0) {
		    Tk_3DVerticalBevel(tkwin, pixmap, selectedBg,
			    x, y, listPtr->selBorderWidth, listPtr->lineHeight,
			    1, TK_RELIEF_RAISED);
		}
		/* Draw right bevel */
		if (right == 0) {
		    Tk_3DVerticalBevel(tkwin, pixmap, selectedBg,
			    x + width - listPtr->selBorderWidth, y,
			    listPtr->selBorderWidth, listPtr->lineHeight,
			    0, TK_RELIEF_RAISED);
		}
		/* Draw top bevel */
		if (!prevSelected) {
		    Tk_3DHorizontalBevel(tkwin, pixmap, selectedBg,
			    x-left, y, width+left+right,
			    listPtr->selBorderWidth,
			    1, 1, 1, TK_RELIEF_RAISED);
		}
		/* Draw bottom bevel */
		if (i + 1 == listPtr->nElements ||
			Tcl_FindHashEntry(listPtr->selection,
				(char *)(i + 1)) == NULL ) {
		    Tk_3DHorizontalBevel(tkwin, pixmap, selectedBg, x-left,
			    y + listPtr->lineHeight - listPtr->selBorderWidth,
			    width+left+right, listPtr->selBorderWidth, 0, 0, 0,
			    TK_RELIEF_RAISED);
a1917 36
		prevSelected = 1;
	    } else {
		/*
		 * If there is an item attributes record for this item, draw
		 * the background box and set the foreground color accordingly
		 */
		if (entry != NULL) {
		    attrs = (ItemAttr *)Tcl_GetHashValue(entry);
		    gcValues.foreground = listPtr->fgColorPtr->pixel;
		    gcValues.font = Tk_FontId(listPtr->tkfont);
		    gcValues.graphics_exposures = False;
		    mask = GCForeground | GCFont | GCGraphicsExposures;
		    
		    /*
		     * If the item has its own background color, draw it now.
		     */
		    
		    if (attrs->border != NULL) {
			width = Tk_Width(tkwin) - 2*listPtr->inset;
			Tk_Fill3DRectangle(tkwin, pixmap, attrs->border, x, y,
				width, listPtr->lineHeight, 0, TK_RELIEF_FLAT);
		    }
		    
		    /*
		     * If the item has its own foreground, use it to override
		     * the value in the gcValues structure.
		     */
		    
		    if ((listPtr->state & STATE_NORMAL)
			    && attrs->fgColor != NULL) {
			gcValues.foreground = attrs->fgColor->pixel;
			gc = Tk_GetGC(listPtr->tkwin, mask, &gcValues);
			freeGC = 1;
		    }
		}
		prevSelected = 0;
d1919 1
d1931 1
a1931 1
	/* If this is the active element, apply the activestyle to it. */
d1933 2
a1934 60
	    if (listPtr->activeStyle == ACTIVE_STYLE_UNDERLINE) {
		/* Underline the text. */
		Tk_UnderlineChars(listPtr->display, pixmap, gc,
			listPtr->tkfont, stringRep, x, y, 0, stringLen);
	    } else if (listPtr->activeStyle == ACTIVE_STYLE_DOTBOX) {
#ifdef WIN32
		/*
		 * This provides for exact default look and feel on Windows.
		 */
		TkWinDCState state;
		HDC dc;
		RECT rect;

		dc = TkWinGetDrawableDC(listPtr->display, pixmap, &state);
		rect.left   = listPtr->inset;
		rect.top    = ((i - listPtr->topIndex) * listPtr->lineHeight) 
		    + listPtr->inset;
		rect.right  = rect.left + width;
		rect.bottom = rect.top + listPtr->lineHeight;
		DrawFocusRect(dc, &rect);
		TkWinReleaseDrawableDC(pixmap, dc, &state);
#else
		/*
		 * Draw a dotted box around the text.
		 */
		x = listPtr->inset;
		y = ((i - listPtr->topIndex) * listPtr->lineHeight)
		    + listPtr->inset;
		width = Tk_Width(tkwin) - 2*listPtr->inset - 1;

		gcValues.line_style  = LineOnOffDash;
		gcValues.line_width  = listPtr->selBorderWidth;
		if (gcValues.line_width <= 0) {
		    gcValues.line_width  = 1;
		}
		gcValues.dash_offset = 0;
		gcValues.dashes      = 1;
		/*
		 * You would think the XSetDashes was necessary, but it
		 * appears that the default dotting for just saying we
		 * want dashes appears to work correctly.
		 static char dashList[] = { 1 };
		 static int  dashLen    = sizeof(dashList);
		 XSetDashes(listPtr->display, gc, 0, dashList, dashLen);
		 */
		mask = GCLineWidth | GCLineStyle | GCDashList | GCDashOffset;
		XChangeGC(listPtr->display, gc, mask, &gcValues);
		XDrawRectangle(listPtr->display, pixmap, gc, x, y,
			(unsigned) width, (unsigned) listPtr->lineHeight - 1);
		if (!freeGC) {
		    /* Don't bother changing if it is about to be freed. */
		    gcValues.line_style = LineSolid;
		    XChangeGC(listPtr->display, gc, GCLineStyle, &gcValues);
		}
#endif
	    }
	}

	if (freeGC) {
	    Tk_FreeGC(listPtr->display, gc);
d2368 1
a2368 11
	if (!(listPtr->flags & LISTBOX_DELETED)) {
	    listPtr->flags |= LISTBOX_DELETED;
	    Tcl_DeleteCommandFromToken(listPtr->interp, listPtr->widgetCmd);
	    if (listPtr->setGrid) {
		Tk_UnsetGrid(listPtr->tkwin);
	    }
	    if (listPtr->flags & REDRAW_PENDING) {
		Tcl_CancelIdleCall(DisplayListbox, clientData);
	    }
	    Tcl_EventuallyFree(clientData, DestroyListbox);
	}
a2609 3
     *
     * Add half a scroll unit to do entry/text-like synchronization.
     * [Bug #225025]
a2611 1
    offset += listPtr->xScrollUnit / 2;
d2982 1
a2982 1
	    || (listPtr->flags & LISTBOX_DELETED)
d3136 2
a3137 2
    CONST char *name1;          /* Not used. */
    CONST char *name2;          /* Not used. */
d3284 2
@


