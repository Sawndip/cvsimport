head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.20.24.44;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.13;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.25;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.51;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.32;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.17;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@/* 
 * tkOption.c --
 *
 *	This module contains procedures to manage the option
 *	database, which allows various strings to be associated
 *	with windows either by name or by class or both.
 *
 * Copyright (c) 1990-1994 The Regents of the University of California.
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkOption.c,v 1.15 2002/08/05 04:30:40 dgp Exp $
 */

#include "tkPort.h"
#include "tkInt.h"

/*
 * The option database is stored as one tree for each main window.
 * Each name or class field in an option is associated with a node or
 * leaf of the tree.  For example, the options "x.y.z" and "x.y*a"
 * each correspond to three nodes in the tree;  they share the nodes
 * "x" and "x.y", but have different leaf nodes.  One of the following
 * structures exists for each node or leaf in the option tree.  It is
 * actually stored as part of the parent node, and describes a particular
 * child of the parent.
 *
 * The structure of the option db tree is a little confusing.  There are
 * four different kinds of nodes in the tree:
 *	interior class nodes
 *	interior name nodes
 *	leaf class nodes
 *	leaf name nodes
 *
 * All interior nodes refer to _window_ classes and names; all leaf nodes
 * refer to _option_ classes and names.  When looking for a particular option,
 * therefore, you must compare interior node values to corresponding window
 * values, and compare leaf node values to corresponding option values.
 *
 * The tree is actually stored in a collection of arrays; there is one each
 * combination of WILDCARD/EXACT and CLASS/NAME and NODE/LEAF.  The NODE arrays
 * contain the interior nodes of the tree; each element has a pointer to an
 * array of elements which are the leaves of the tree.  The LEAF arrays, rather
 * than holding the leaves of the tree, hold a cached subset of the option
 * database, consisting of the values of all defined options for a single
 * window, and some additional information about each ancestor of the window
 * (since some options may be inherited from a parent), all the way back to the
 * root window.
 *
 * Each time a call is made to Tk_GetOption, Tk will attempt to use the cached
 * information to satisfy the lookup.  If the call is for a window other than
 * that for which options are currently cached, the portion of the cache that
 * contains information for common ancestors of the two windows is retained and
 * the remainder is discarded and rebuilt with new information for the new
 * window.
 */

typedef struct Element {
    Tk_Uid nameUid;			/* Name or class from one element of
					 * an option spec. */
    union {
	struct ElArray *arrayPtr;	/* If this is an intermediate node,
					 * a pointer to a structure describing
					 * the remaining elements of all
					 * options whose prefixes are the
					 * same up through this element. */
	Tk_Uid valueUid;		/* For leaf nodes, this is the string
					 * value of the option. */
    } child;
    int priority;			/* Used to select among matching
					 * options.  Includes both the
					 * priority level and a serial #.
					 * Greater value means higher
					 * priority.  Irrelevant except in
					 * leaf nodes. */
    int flags;				/* OR-ed combination of bits.  See
					 * below for values. */
} Element;

/*
 * Flags in Element structures:
 *
 * CLASS -		Non-zero means this element refers to a class,
 *			Zero means this element refers to a name.
 * NODE -		Zero means this is a leaf element (the child
 *			field is a value, not a pointer to another node).
 *			One means this is a node element.
 * WILDCARD -		Non-zero means this there was a star in the
 *			original specification just before this element.
 *			Zero means there was a dot.
 */

#define TYPE_MASK		0x7

#define CLASS			0x1
#define NODE			0x2
#define WILDCARD		0x4

#define EXACT_LEAF_NAME		0x0
#define EXACT_LEAF_CLASS	0x1
#define EXACT_NODE_NAME		0x2
#define EXACT_NODE_CLASS	0x3
#define WILDCARD_LEAF_NAME	0x4
#define WILDCARD_LEAF_CLASS	0x5
#define WILDCARD_NODE_NAME	0x6
#define WILDCARD_NODE_CLASS	0x7

/*
 * The following structure is used to manage a dynamic array of
 * Elements.  These structures are used for two purposes:  to store
 * the contents of a node in the option tree, and for the option
 * stacks described below.
 */

typedef struct ElArray {
    int arraySize;		/* Number of elements actually
				 * allocated in the "els" array. */
    int numUsed;		/* Number of elements currently in
				 * use out of els. */
    Element *nextToUse;		/* Pointer to &els[numUsed]. */
    Element els[1];		/* Array of structures describing
				 * children of this node.  The
				 * array will actually contain enough
				 * elements for all of the children
				 * (and even a few extras, perhaps).
				 * This must be the last field in
				 * the structure. */
} ElArray;

#define EL_ARRAY_SIZE(numEls) ((unsigned) (sizeof(ElArray) \
	+ ((numEls)-1)*sizeof(Element)))
#define INITIAL_SIZE 5

/*
 * In addition to the option tree, which is a relatively static structure,
 * there are eight additional structures called "stacks", which are used
 * to speed up queries into the option database.  The stack structures
 * are designed for the situation where an individual widget makes repeated
 * requests for its particular options.  The requests differ only in
 * their last name/class, so during the first request we extract all
 * the options pertaining to the particular widget and save them in a
 * stack-like cache;  subsequent requests for the same widget can search
 * the cache relatively quickly.  In fact, the cache is a hierarchical
 * one, storing a list of relevant options for this widget and all of
 * its ancestors up to the application root;  hence the name "stack".
 *
 * Each of the eight stacks consists of an array of Elements, ordered in
 * terms of levels in the window hierarchy.  All the elements relevant
 * for the top-level widget appear first in the array, followed by all
 * those from the next-level widget on the path to the current widget,
 * etc. down to those for the current widget.
 *
 * Cached information is divided into eight stacks according to the
 * CLASS, NODE, and WILDCARD flags.  Leaf and non-leaf information is
 * kept separate to speed up individual probes (non-leaf information is
 * only relevant when building the stacks, but isn't relevant when
 * making probes;  similarly, only non-leaf information is relevant
 * when the stacks are being extended to the next widget down in the
 * widget hierarchy).  Wildcard elements are handled separately from
 * "exact" elements because once they appear at a particular level in
 * the stack they remain active for all deeper levels;  exact elements
 * are only relevant at a particular level.  For example, when searching
 * for options relevant in a particular window, the entire wildcard
 * stacks get checked, but only the portions of the exact stacks that
 * pertain to the window's parent.  Lastly, name and class stacks are
 * kept separate because different search keys are used when searching
 * them;  keeping them separate speeds up the searches.
 */

#define NUM_STACKS 8

/*
 * One of the following structures is used to keep track of each
 * level in the stacks.
 */

typedef struct StackLevel {
    TkWindow *winPtr;		/* Window corresponding to this stack
				 * level. */
    int bases[NUM_STACKS];	/* For each stack, index of first
				 * element on stack corresponding to
				 * this level (used to restore "numUsed"
				 * fields when popping out of a level. */
} StackLevel;

typedef struct ThreadSpecificData {
    int initialized;            /* 0 means the ThreadSpecific Data structure
				 * for the current thread needs to be
				 * initialized. */
    ElArray *stacks[NUM_STACKS];
    TkWindow *cachedWindow;
                                /* Lowest-level window currently
				 * loaded in stacks at present. 
				 * NULL means stacks have never
				 * been used, or have been
				 * invalidated because of a change
				 * to the database. */
    /*
     * Information about all of the stack levels that are currently
     * active.  This array grows dynamically to become as large as needed.
     */

    StackLevel *levels;	        /* Array describing current stack. */
    int numLevels;	        /* Total space allocated. */
    int curLevel;	        /* Highest level currently in use.  Note:
				 * curLevel is never 0!  (I don't remember
				 * why anymore...) */
    /*
     * The variable below is a serial number for all options entered into
     * the database so far.  It increments on each addition to the option
     * database.  It is used in computing option priorities, so that the
     * most recent entry wins when choosing between options at the same
     * priority level.
     */

    int serial;
    Element defaultMatch;       /* Special "no match" Element to use as 
				 * default for searches.*/
} ThreadSpecificData;
static Tcl_ThreadDataKey dataKey;

/*
 * Forward declarations for procedures defined in this file:
 */

static int		AddFromString _ANSI_ARGS_((Tcl_Interp *interp,
			    Tk_Window tkwin, char *string, int priority));
static void		ClearOptionTree _ANSI_ARGS_((ElArray *arrayPtr));
static ElArray *	ExtendArray _ANSI_ARGS_((ElArray *arrayPtr,
			    Element *elPtr));
static void		ExtendStacks _ANSI_ARGS_((ElArray *arrayPtr,
			    int leaf));
static int		GetDefaultOptions _ANSI_ARGS_((Tcl_Interp *interp,
			    TkWindow *winPtr));	
static ElArray *	NewArray _ANSI_ARGS_((int numEls));	
static void		OptionThreadExitProc _ANSI_ARGS_((
			    ClientData clientData));
static void		OptionInit _ANSI_ARGS_((TkMainInfo *mainPtr));
static int		ParsePriority _ANSI_ARGS_((Tcl_Interp *interp,
			    char *string));
static int		ReadOptionFile _ANSI_ARGS_((Tcl_Interp *interp,
			    Tk_Window tkwin, char *fileName, int priority));
static void		SetupStacks _ANSI_ARGS_((TkWindow *winPtr, int leaf));

/*
 *--------------------------------------------------------------
 *
 * Tk_AddOption --
 *
 *	Add a new option to the option database.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Information is added to the option database.
 *
 *--------------------------------------------------------------
 */

void
Tk_AddOption(tkwin, name, value, priority)
    Tk_Window tkwin;		/* Window token;  option will be associated
				 * with main window for this window. */
    CONST char *name;		/* Multi-element name of option. */
    CONST char *value;		/* String value for option. */
    int priority;		/* Overall priority level to use for
				 * this option, such as TK_USER_DEFAULT_PRIO
				 * or TK_INTERACTIVE_PRIO.  Must be between
				 * 0 and TK_MAX_PRIO. */
{
    TkWindow *winPtr = ((TkWindow *) tkwin)->mainPtr->winPtr;
    register ElArray **arrayPtrPtr;
    register Element *elPtr;
    Element newEl;
    register CONST char *p;
    CONST char *field;
    int count, firstField, length;
#define TMP_SIZE 100
    char tmp[TMP_SIZE+1];
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    if (winPtr->mainPtr->optionRootPtr == NULL) {
	OptionInit(winPtr->mainPtr);
    }
    tsdPtr->cachedWindow = NULL;	/* Invalidate the cache. */

    /*
     * Compute the priority for the new element, including both the
     * overall level and the serial number (to disambiguate with the
     * level).
     */

    if (priority < 0) {
	priority = 0;
    } else if (priority > TK_MAX_PRIO) {
	priority = TK_MAX_PRIO;
    }
    newEl.priority = (priority << 24) + tsdPtr->serial;
    tsdPtr->serial++;

    /*
     * Parse the option one field at a time.
     */

    arrayPtrPtr = &(((TkWindow *) tkwin)->mainPtr->optionRootPtr);
    p = name;
    for (firstField = 1; ; firstField = 0) {

	/*
	 * Scan the next field from the name and convert it to a Tk_Uid.
	 * Must copy the field before calling Tk_Uid, so that a terminating
	 * NULL may be added without modifying the source string.
	 */

	if (*p == '*') {
	    newEl.flags = WILDCARD;
	    p++;
	} else {
	    newEl.flags = 0;
	}
	field = p;
	while ((*p != 0) && (*p != '.') && (*p != '*')) {
	    p++;
	}
	length = p - field;
	if (length > TMP_SIZE) {
	    length = TMP_SIZE;
	}
	strncpy(tmp, field, (size_t) length);
	tmp[length] = 0;
	newEl.nameUid = Tk_GetUid(tmp);
	if (isupper(UCHAR(*field))) {
	    newEl.flags |= CLASS;
	}

	if (*p != 0) {

	    /*
	     * New element will be a node.  If this option can't possibly
	     * apply to this main window, then just skip it.  Otherwise,
	     * add it to the parent, if it isn't already there, and descend
	     * into it.
	     */

	    newEl.flags |= NODE;
	    if (firstField && !(newEl.flags & WILDCARD)
		    && (newEl.nameUid != winPtr->nameUid)
		    && (newEl.nameUid != winPtr->classUid)) {
		return;
	    }
	    for (elPtr = (*arrayPtrPtr)->els, count = (*arrayPtrPtr)->numUsed;
		    ; elPtr++, count--) {
		if (count == 0) {
		    newEl.child.arrayPtr = NewArray(5);
		    *arrayPtrPtr = ExtendArray(*arrayPtrPtr, &newEl);
		    arrayPtrPtr = &((*arrayPtrPtr)->nextToUse[-1].child.arrayPtr);
		    break;
		}
		if ((elPtr->nameUid == newEl.nameUid)
			&& (elPtr->flags == newEl.flags)) {
		    arrayPtrPtr = &(elPtr->child.arrayPtr);
		    break;
		}
	    }
	    if (*p == '.') {
		p++;
	    }
	} else {

	    /*
	     * New element is a leaf.  Add it to the parent, if it isn't
	     * already there.  If it exists already, keep whichever value
	     * has highest priority.
	     */

	    newEl.child.valueUid = Tk_GetUid(value);
	    for (elPtr = (*arrayPtrPtr)->els, count = (*arrayPtrPtr)->numUsed;
		    ; elPtr++, count--) {
		if (count == 0) {
		    *arrayPtrPtr = ExtendArray(*arrayPtrPtr, &newEl);
		    return;
		}
		if ((elPtr->nameUid == newEl.nameUid)
			&& (elPtr->flags == newEl.flags)) {
		    if (elPtr->priority < newEl.priority) {
			elPtr->priority = newEl.priority;
			elPtr->child.valueUid = newEl.child.valueUid;
		    }
		    return;
		}
	    }
	}
    }
}

/*
 *--------------------------------------------------------------
 *
 * Tk_GetOption --
 *
 *	Retrieve an option from the option database.
 *
 * Results:
 *	The return value is the value specified in the option
 *	database for the given name and class on the given
 *	window.  If there is nothing specified in the database
 *	for that option, then NULL is returned.
 *
 * Side effects:
 *	The internal caches used to speed up option mapping
 *	may be modified, if this tkwin is different from the
 *	last tkwin used for option retrieval.
 *
 *--------------------------------------------------------------
 */

Tk_Uid
Tk_GetOption(tkwin, name, className)
    Tk_Window tkwin;		/* Token for window that option is
				 * associated with. */
    CONST char *name;		/* Name of option. */
    CONST char *className;	/* Class of option.  NULL means there
				 * is no class for this option:  just
				 * check for name. */
{
    Tk_Uid nameId, classId = NULL;
    char *masqName;
    register Element *elPtr, *bestPtr;
    register int count;
    StackLevel *levelPtr;
    int stackDepth[NUM_STACKS];
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    /*
     * Note:  no need to call OptionInit here:  it will be done by
     * the SetupStacks call below (squeeze out those nanoseconds).
     */

    if (tkwin != (Tk_Window) tsdPtr->cachedWindow) {
	SetupStacks((TkWindow *) tkwin, 1);
    }

    /*
     * Get a default "best" match.
     */
    
    bestPtr = &tsdPtr->defaultMatch;

    /*
     * For megawidget support, we want to have some widget options masquerade
     * as options for other widgets.  For example, a combobox has a button in
     * it; this button ought to pick up the *Button.background, etc., options.
     * But because the class of the widget is Combobox, our normal search
     * won't get that option.
     *
     * To work around this, the option name field syntax was extended to allow
     * for a "." in the name; if this character occurs in the name, then it
     * indicates that this name contains a new window class and an option name,
     * ie, "Button.foreground".  If we see this form in the name field, we 
     * query the option database directly (since the option stacks will not
     * have the information we need).
     */

    masqName = strchr(name, (int)'.');
    if (masqName != NULL) {
	/*
	 * This option is masquerading with a different window class.
	 * Search the stack to the depth it was before the current window's
	 * information was pushed (the value for which is stored in the bases
	 * field).
	 */
	levelPtr = &tsdPtr->levels[tsdPtr->curLevel];
	nameId = Tk_GetUid(masqName+1);
	for (count = 0; count < NUM_STACKS; count++) {
	    stackDepth[count] = levelPtr->bases[count];
	}
    } else {
	/*
	 * No option masquerading here.  Just use the current level to get the
	 * stack depths.
	 */
	nameId = Tk_GetUid(name);
	for (count = 0; count < NUM_STACKS; count++) {
	    stackDepth[count] = tsdPtr->stacks[count]->numUsed;
	}
    }

    /*
     * Probe the stacks for matches.
     */

    for (elPtr = tsdPtr->stacks[EXACT_LEAF_NAME]->els,
	     count = stackDepth[EXACT_LEAF_NAME]; count > 0;
	 elPtr++, count--) {
	if ((elPtr->nameUid == nameId)
		&& (elPtr->priority > bestPtr->priority)) {
	    bestPtr = elPtr;
	}
    }
    for (elPtr = tsdPtr->stacks[WILDCARD_LEAF_NAME]->els,
	     count = stackDepth[WILDCARD_LEAF_NAME]; count > 0;
	 elPtr++, count--) {
	if ((elPtr->nameUid == nameId)
		&& (elPtr->priority > bestPtr->priority)) {
	    bestPtr = elPtr;
	}
    }

    if (className != NULL) {
	classId = Tk_GetUid(className);
	for (elPtr = tsdPtr->stacks[EXACT_LEAF_CLASS]->els,
		 count = stackDepth[EXACT_LEAF_CLASS]; count > 0;
	     elPtr++, count--) {
	    if ((elPtr->nameUid == classId)
		    && (elPtr->priority > bestPtr->priority)) {
		bestPtr = elPtr;
	    }
	}
	for (elPtr = tsdPtr->stacks[WILDCARD_LEAF_CLASS]->els,
		 count = stackDepth[WILDCARD_LEAF_CLASS]; count > 0;
	     elPtr++, count--) {
	    if ((elPtr->nameUid == classId)
		    && (elPtr->priority > bestPtr->priority)) {
		bestPtr = elPtr;
	    }
	}
    }
    
    /*
     * If this option was masquerading with a different window class,
     * probe the option database now.  Note that this will be inefficient
     * if the option database is densely populated, or if the widget has many
     * masquerading options.
     */

    if (masqName != NULL) {
	char *masqClass;
	Tk_Uid nodeId, winClassId, winNameId;
	unsigned int classNameLength;
	register Element *nodePtr, *leafPtr;
	static int searchOrder[] = { EXACT_NODE_NAME,
					 WILDCARD_NODE_NAME,
					 EXACT_NODE_CLASS,
					 WILDCARD_NODE_CLASS,
					 -1 };
	int *currentPtr, currentStack, leafCount;
	
	/*
	 * Extract the masquerade class name from the name field.
	 */
	
	classNameLength	= (unsigned int)(masqName - name);
	masqClass	= (char *)ckalloc(classNameLength + 1);
	strncpy(masqClass, name, classNameLength);
	masqClass[classNameLength] = '\0';
	
	winClassId	= Tk_GetUid(masqClass);
	ckfree(masqClass);
	winNameId	= ((TkWindow *)tkwin)->nameUid;

	levelPtr = &tsdPtr->levels[tsdPtr->curLevel];

	for (currentPtr = searchOrder; *currentPtr != -1; currentPtr++) {
	    currentStack = *currentPtr;
	    nodePtr	= tsdPtr->stacks[currentStack]->els;
	    count	= levelPtr->bases[currentStack];

	    /*
	     * For wildcard stacks, check all entries;  for non-wildcard
	     * stacks, only check things that matched in the parent.
	     */
	    
	    if (!(currentStack & WILDCARD)) {
		nodePtr += levelPtr[-1].bases[currentStack];
		count	-= levelPtr[-1].bases[currentStack];
	    }
	    
	    if (currentStack && CLASS) {
		nodeId = winClassId;
	    } else {
		nodeId = winNameId;
	    }

	    for ( ; count > 0; nodePtr++, count--) {
		if (nodePtr->nameUid == nodeId) {
		    leafPtr	= nodePtr->child.arrayPtr->els;
		    leafCount	= nodePtr->child.arrayPtr->numUsed;
		    for ( ; leafCount > 0; leafPtr++, leafCount--) {
			if (leafPtr->flags & CLASS && className != NULL) {
			    if (leafPtr->nameUid == classId &&
				    leafPtr->priority > bestPtr->priority) {
				bestPtr = leafPtr;
			    }
			} else {
			    if (leafPtr->nameUid == nameId &&
				    leafPtr->priority > bestPtr->priority) {
				bestPtr = leafPtr;
			    }
			}
		    }
		}
	    }
	}
    }
    
    return bestPtr->child.valueUid;
}

/*
 *--------------------------------------------------------------
 *
 * Tk_OptionObjCmd --
 *
 *	This procedure is invoked to process the "option" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *--------------------------------------------------------------
 */

int
Tk_OptionObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Main window associated with
				 * interpreter. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of Tcl_Obj arguments. */
    Tcl_Obj *CONST objv[];	/* Tcl_Obj arguments. */
{
    Tk_Window tkwin = (Tk_Window) clientData;
    int index, result;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    static CONST char *optionCmds[] = {
	"add", "clear", "get", "readfile", NULL
    };

    enum optionVals {
	OPTION_ADD, OPTION_CLEAR, OPTION_GET, OPTION_READFILE
    };

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "cmd arg ?arg ...?");
	return TCL_ERROR;
    }

    result = Tcl_GetIndexFromObj(interp, objv[1], optionCmds, "option", 0,
	    &index);
    if (result != TCL_OK) {
	return result;
    }
    
    result = TCL_OK;
    switch ((enum optionVals) index) {
	case OPTION_ADD: {
	    int priority;
	    if ((objc != 4) && (objc != 5)) {
		Tcl_WrongNumArgs(interp, 2, objv, "pattern value ?priority?");
		return TCL_ERROR;
	    }

	    if (objc == 4) {
		priority = TK_INTERACTIVE_PRIO;
	    } else {
		priority = ParsePriority(interp, Tcl_GetString(objv[4]));
		if (priority < 0) {
		    return TCL_ERROR;
		}
	    }
	    Tk_AddOption(tkwin, Tcl_GetString(objv[2]),
		    Tcl_GetString(objv[3]), priority);
	    break;
	}

	case OPTION_CLEAR: {
	    TkMainInfo *mainPtr;

	    if (objc != 2) {
		Tcl_WrongNumArgs(interp, 2, objv, "");
		return TCL_ERROR;
	    }
	    mainPtr = ((TkWindow *) tkwin)->mainPtr;
	    if (mainPtr->optionRootPtr != NULL) {
		ClearOptionTree(mainPtr->optionRootPtr);
		mainPtr->optionRootPtr = NULL;
	    }
	    tsdPtr->cachedWindow = NULL;
	    break;
	}

	case OPTION_GET: {
	    Tk_Window window;
	    Tk_Uid value;
	    
	    if (objc != 5) {
		Tcl_WrongNumArgs(interp, 2, objv, "window name class");
		return TCL_ERROR;
	    }
	    window = Tk_NameToWindow(interp, Tcl_GetString(objv[2]), tkwin);
	    if (window == NULL) {
		return TCL_ERROR;
	    }
	    value = Tk_GetOption(window, Tcl_GetString(objv[3]),
		    Tcl_GetString(objv[4]));
	    if (value != NULL) {
		Tcl_SetResult(interp, (char *)value, TCL_STATIC);
	    }
	    break;
	}

	case OPTION_READFILE: {
	    int priority;
	    
	    if ((objc != 3) && (objc != 4)) {
		Tcl_WrongNumArgs(interp, 2, objv, "fileName ?priority?");
		return TCL_ERROR;
	    }

	    if (objc == 4) {
		priority = ParsePriority(interp, Tcl_GetString(objv[3]));
		if (priority < 0) {
		    return TCL_ERROR;
		}
	    } else {
		priority = TK_INTERACTIVE_PRIO;
	    }
	    result = ReadOptionFile(interp, tkwin, Tcl_GetString(objv[2]),
		    priority);
	    break;
	}
    }
    return result;
}

/*
 *--------------------------------------------------------------
 *
 * TkOptionDeadWindow --
 *
 *	This procedure is called whenever a window is deleted.
 *	It cleans up any option-related stuff associated with
 *	the window.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Option-related resources are freed.  See code below
 *	for details.
 *
 *--------------------------------------------------------------
 */

void
TkOptionDeadWindow(winPtr)
    register TkWindow *winPtr;		/* Window to be cleaned up. */
{
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    /*
     * If this window is in the option stacks, then clear the stacks.
     */

    if (winPtr->optionLevel != -1) {
	int i;

	for (i = 1; i <= tsdPtr->curLevel; i++) {
	    tsdPtr->levels[i].winPtr->optionLevel = -1;
	}
	tsdPtr->curLevel = -1;
	tsdPtr->cachedWindow = NULL;
    }

    /*
     * If this window was a main window, then delete its option
     * database.
     */

    if ((winPtr->mainPtr != NULL) && (winPtr->mainPtr->winPtr == winPtr)
	    && (winPtr->mainPtr->optionRootPtr != NULL)) {
	ClearOptionTree(winPtr->mainPtr->optionRootPtr);
	winPtr->mainPtr->optionRootPtr = NULL;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkOptionClassChanged --
 *
 *	This procedure is invoked when a window's class changes.  If
 *	the window is on the option cache, this procedure flushes
 *	any information for the window, since the new class could change
 *	what is relevant.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The option cache may be flushed in part or in whole.
 *
 *----------------------------------------------------------------------
 */

void
TkOptionClassChanged(winPtr)
    TkWindow *winPtr;			/* Window whose class changed. */
{
    int i, j, *basePtr;
    ElArray *arrayPtr;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    if (winPtr->optionLevel == -1) {
	return;
    }

    /*
     * Find the lowest stack level that refers to this window, then
     * flush all of the levels above the matching one.
     */

    for (i = 1; i <= tsdPtr->curLevel; i++) {
	if (tsdPtr->levels[i].winPtr == winPtr) {
	    for (j = i; j <= tsdPtr->curLevel; j++) {
		tsdPtr->levels[j].winPtr->optionLevel = -1;
	    }
	    tsdPtr->curLevel = i-1;
	    basePtr = tsdPtr->levels[i].bases;
	    for (j = 0; j < NUM_STACKS; j++) {
		arrayPtr = tsdPtr->stacks[j];
		arrayPtr->numUsed = basePtr[j];
		arrayPtr->nextToUse = &arrayPtr->els[arrayPtr->numUsed];
	    }
	    if (tsdPtr->curLevel <= 0) {
		tsdPtr->cachedWindow = NULL;
	    } else {
		tsdPtr->cachedWindow = tsdPtr->levels[tsdPtr->curLevel].winPtr;
	    }
	    break;
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ParsePriority --
 *
 *	Parse a string priority value.
 *
 * Results:
 *	The return value is the integer priority level corresponding
 *	to string, or -1 if string doesn't point to a valid priority level.
 *	In this case, an error message is left in the interp's result.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
ParsePriority(interp, string)
    Tcl_Interp *interp;		/* Interpreter to use for error reporting. */
    char *string;		/* Describes a priority level, either
				 * symbolically or numerically. */
{
    int priority, c;
    size_t length;

    c = string[0];
    length = strlen(string);
    if ((c == 'w')
	    && (strncmp(string, "widgetDefault", length) == 0)) {
	return TK_WIDGET_DEFAULT_PRIO;
    } else if ((c == 's')
	    && (strncmp(string, "startupFile", length) == 0)) {
	return TK_STARTUP_FILE_PRIO;
    } else if ((c == 'u')
	    && (strncmp(string, "userDefault", length) == 0)) {
	return TK_USER_DEFAULT_PRIO;
    } else if ((c == 'i')
	    && (strncmp(string, "interactive", length) == 0)) {
	return TK_INTERACTIVE_PRIO;
    } else {
	char *end;

	priority = strtoul(string, &end, 0);
	if ((end == string) || (*end != 0) || (priority < 0)
		|| (priority > 100)) {
	    Tcl_AppendResult(interp,  "bad priority level \"", string,
		    "\": must be widgetDefault, startupFile, userDefault, ",
		    "interactive, or a number between 0 and 100",
		    (char *) NULL);
	    return -1;
	}
    }
    return priority;
}

/*
 *----------------------------------------------------------------------
 *
 * AddFromString --
 *
 *	Given a string containing lines in the standard format for
 *	X resources (see other documentation for details on what this
 *	is), parse the resource specifications and enter them as options
 *	for tkwin's main window.
 *
 * Results:
 *	The return value is a standard Tcl return code.  In the case of
 *	an error in parsing string, TCL_ERROR will be returned and an
 *	error message will be left in the interp's result.  The memory at
 *	string is totally trashed by this procedure.  If you care about
 *	its contents, make a copy before calling here.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
AddFromString(interp, tkwin, string, priority)
    Tcl_Interp *interp;		/* Interpreter to use for reporting results. */
    Tk_Window tkwin;		/* Token for window:  options are entered
				 * for this window's main window. */
    char *string;		/* String containing option specifiers. */
    int priority;		/* Priority level to use for options in
				 * this string, such as TK_USER_DEFAULT_PRIO
				 * or TK_INTERACTIVE_PRIO.  Must be between
				 * 0 and TK_MAX_PRIO. */
{
    register char *src, *dst;
    char *name, *value;
    int lineNum;

    src = string;
    lineNum = 1;
    while (1) {

	/*
	 * Skip leading white space and empty lines and comment lines, and
	 * check for the end of the spec.
	 */

	while ((*src == ' ') || (*src == '\t')) {
	    src++;
	}
	if ((*src == '#') || (*src == '!')) {
	    do {
		src++;
		if ((src[0] == '\\') && (src[1] == '\n')) {
		    src += 2;
		    lineNum++;
		}
	    } while ((*src != '\n') && (*src != 0));
	}
	if (*src == '\n') {
	    src++;
	    lineNum++;
	    continue;
	} 
	if (*src == '\0') {
	    break;
	}

	/*
	 * Parse off the option name, collapsing out backslash-newline
	 * sequences of course.
	 */

	dst = name = src;
	while (*src != ':') {
	    if ((*src == '\0') || (*src == '\n')) {
		char buf[32 + TCL_INTEGER_SPACE];
		
		sprintf(buf, "missing colon on line %d", lineNum);
		Tcl_SetResult(interp, buf, TCL_VOLATILE);
		return TCL_ERROR;
	    }
	    if ((src[0] == '\\') && (src[1] == '\n')) {
		src += 2;
		lineNum++;
	    } else {
		*dst = *src;
		dst++;
		src++;
	    }
	}

	/*
	 * Eliminate trailing white space on the name, and null-terminate
	 * it.
	 */

	while ((dst != name) && ((dst[-1] == ' ') || (dst[-1] == '\t'))) {
	    dst--;
	}
	*dst = '\0';

	/*
	 * Skip white space between the name and the value.
	 */

	src++;
	while ((*src == ' ') || (*src == '\t')) {
	    src++;
	}
	if (*src == '\0') {
	    char buf[32 + TCL_INTEGER_SPACE];
	    
	    sprintf(buf, "missing value on line %d", lineNum);
	    Tcl_SetResult(interp, buf, TCL_VOLATILE);
	    return TCL_ERROR;
	}

	/*
	 * Parse off the value, squeezing out backslash-newline sequences
	 * along the way.
	 */

	dst = value = src;
	while (*src != '\n') {
	    if (*src == '\0') {
		char buf[32 + TCL_INTEGER_SPACE];
		
		sprintf(buf, "missing newline on line %d", lineNum);
		Tcl_SetResult(interp, buf, TCL_VOLATILE);
		return TCL_ERROR;
	    }
	    if ((src[0] == '\\') && (src[1] == '\n')) {
		src += 2;
		lineNum++;
	    } else {
		*dst = *src;
		dst++;
		src++;
	    }
	}
	*dst = 0;

	/*
	 * Enter the option into the database.
	 */

	Tk_AddOption(tkwin, name, value, priority);
	src++;
	lineNum++;
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ReadOptionFile --
 *
 * 	Read a file of options ("resources" in the old X terminology)
 *	and load them into the option database.
 *
 * Results:
 *	The return value is a standard Tcl return code.  In the case of
 *	an error in parsing string, TCL_ERROR will be returned and an
 *	error message will be left in the interp's result.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
ReadOptionFile(interp, tkwin, fileName, priority)
    Tcl_Interp *interp;		/* Interpreter to use for reporting results. */
    Tk_Window tkwin;		/* Token for window:  options are entered
				 * for this window's main window. */
    char *fileName;		/* Name of file containing options. */
    int priority;		/* Priority level to use for options in
				 * this file, such as TK_USER_DEFAULT_PRIO
				 * or TK_INTERACTIVE_PRIO.  Must be between
				 * 0 and TK_MAX_PRIO. */
{
    CONST char *realName;
    char *buffer;
    int result, bufferSize;
    Tcl_Channel chan;
    Tcl_DString newName;

    /*
     * Prevent file system access in a safe interpreter.
     */
    
    if (Tcl_IsSafe(interp)) {
        Tcl_AppendResult(interp, "can't read options from a file in a",
                " safe interpreter", (char *) NULL);
        return TCL_ERROR;
    }
    
    realName = Tcl_TranslateFileName(interp, fileName, &newName);
    if (realName == NULL) {
	return TCL_ERROR;
    }
    chan = Tcl_OpenFileChannel(interp, realName, "r", 0);
    Tcl_DStringFree(&newName);
    if (chan == NULL) {
        Tcl_ResetResult(interp);
	Tcl_AppendResult(interp, "couldn't open \"", fileName,
		"\": ", Tcl_PosixError(interp), (char *) NULL);
	return TCL_ERROR;
    }

    /*
     * Compute size of file by seeking to the end of the file.  This will
     * overallocate if we are performing CRLF translation.
     */
    
    bufferSize = (int) Tcl_Seek(chan, (Tcl_WideInt) 0, SEEK_END);
    (void) Tcl_Seek(chan, (Tcl_WideInt) 0, SEEK_SET);

    if (bufferSize < 0) {
	Tcl_AppendResult(interp, "error seeking to end of file \"",
		fileName, "\":", Tcl_PosixError(interp), (char *) NULL);
	Tcl_Close(NULL, chan);
	return TCL_ERROR;

    }
    buffer = (char *) ckalloc((unsigned) bufferSize+1);
    bufferSize = Tcl_Read(chan, buffer, bufferSize);
    if (bufferSize < 0) {
	Tcl_AppendResult(interp, "error reading file \"", fileName, "\":",
		Tcl_PosixError(interp), (char *) NULL);
	Tcl_Close(NULL, chan);
	return TCL_ERROR;
    }
    Tcl_Close(NULL, chan);
    buffer[bufferSize] = 0;
    result = AddFromString(interp, tkwin, buffer, priority);
    ckfree(buffer);
    return result;
}

/*
 *--------------------------------------------------------------
 *
 * NewArray --
 *
 *	Create a new ElArray structure of a given size.
 *
 * Results:
 *	The return value is a pointer to a properly initialized
 *	element array with "numEls" space.  The array is marked
 *	as having no active elements.
 *
 * Side effects:
 *	Memory is allocated.
 *
 *--------------------------------------------------------------
 */

static ElArray *
NewArray(numEls)
    int numEls;			/* How many elements of space to allocate. */
{
    register ElArray *arrayPtr;

    arrayPtr = (ElArray *) ckalloc(EL_ARRAY_SIZE(numEls));
    arrayPtr->arraySize = numEls;
    arrayPtr->numUsed = 0;
    arrayPtr->nextToUse = arrayPtr->els;
    return arrayPtr;
}

/*
 *--------------------------------------------------------------
 *
 * ExtendArray --
 *
 *	Add a new element to an array, extending the array if
 *	necessary.
 *
 * Results:
 *	The return value is a pointer to the new array, which
 *	will be different from arrayPtr if the array got expanded.
 *
 * Side effects:
 *	Memory may be allocated or freed.
 *
 *--------------------------------------------------------------
 */

static ElArray *
ExtendArray(arrayPtr, elPtr)
    register ElArray *arrayPtr;		/* Array to be extended. */
    register Element *elPtr;		/* Element to be copied into array. */
{
    /*
     * If the current array has filled up, make it bigger.
     */

    if (arrayPtr->numUsed >= arrayPtr->arraySize) {
	register ElArray *newPtr;

	newPtr = (ElArray *) ckalloc(EL_ARRAY_SIZE(2*arrayPtr->arraySize));
	newPtr->arraySize = 2*arrayPtr->arraySize;
	newPtr->numUsed = arrayPtr->numUsed;
	newPtr->nextToUse = &newPtr->els[newPtr->numUsed];
	memcpy((VOID *) newPtr->els, (VOID *) arrayPtr->els,
		(arrayPtr->arraySize*sizeof(Element)));
	ckfree((char *) arrayPtr);
	arrayPtr = newPtr;
    }

    *arrayPtr->nextToUse = *elPtr;
    arrayPtr->nextToUse++;
    arrayPtr->numUsed++;
    return arrayPtr;
}

/*
 *--------------------------------------------------------------
 *
 * SetupStacks --
 *
 *	Arrange the stacks so that they cache all the option
 *	information for a particular window.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The stacks are modified to hold information for tkwin
 *	and all its ancestors in the window hierarchy.
 *
 *--------------------------------------------------------------
 */

static void
SetupStacks(winPtr, leaf)
    TkWindow *winPtr;		/* Window for which information is to
				 * be cached. */
    int leaf;			/* Non-zero means this is the leaf
				 * window being probed.  Zero means this
				 * is an ancestor of the desired leaf. */
{
    int level, i, *iPtr;
    register StackLevel *levelPtr;
    register ElArray *arrayPtr;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    /*
     * The following array defines the order in which the current
     * stacks are searched to find matching entries to add to the
     * stacks.  Given the current priority-based scheme, the order
     * below is no longer relevant;  all that matters is that an
     * element is on the list *somewhere*.  The ordering is a relic
     * of the old days when priorities were determined differently.
     */

    static int searchOrder[] = {WILDCARD_NODE_CLASS, WILDCARD_NODE_NAME,
	    EXACT_NODE_CLASS, EXACT_NODE_NAME, -1};

    if (winPtr->mainPtr->optionRootPtr == NULL) {
	OptionInit(winPtr->mainPtr);
    }

    /*
     * Step 1:  make sure that options are cached for this window's
     * parent.
     */

    if (winPtr->parentPtr != NULL) {
	level = winPtr->parentPtr->optionLevel;
	if ((level == -1) || (tsdPtr->cachedWindow == NULL)) {
	    SetupStacks(winPtr->parentPtr, 0);
	    level = winPtr->parentPtr->optionLevel;
	}
	level++;
    } else {
	level = 1;
    }

    /*
     * Step 2:  pop extra unneeded information off the stacks and
     * mark those windows as no longer having cached information.
     */

    if (tsdPtr->curLevel >= level) {
	while (tsdPtr->curLevel >= level) {
	    tsdPtr->levels[tsdPtr->curLevel].winPtr->optionLevel = -1;
	    tsdPtr->curLevel--;
	}
	levelPtr = &tsdPtr->levels[level];
	for (i = 0; i < NUM_STACKS; i++) {
	    arrayPtr = tsdPtr->stacks[i];
	    arrayPtr->numUsed = levelPtr->bases[i];
	    arrayPtr->nextToUse = &arrayPtr->els[arrayPtr->numUsed];
	}
    }
    tsdPtr->curLevel = winPtr->optionLevel = level;

    /*
     * Step 3:  if the root database information isn't loaded or
     * isn't valid, initialize level 0 of the stack from the
     * database root (this only happens if winPtr is a main window).
     */

    if ((tsdPtr->curLevel == 1)
	    && ((tsdPtr->cachedWindow == NULL)
	    || (tsdPtr->cachedWindow->mainPtr != winPtr->mainPtr))) {
	for (i = 0; i < NUM_STACKS; i++) {
	    arrayPtr = tsdPtr->stacks[i];
	    arrayPtr->numUsed = 0;
	    arrayPtr->nextToUse = arrayPtr->els;
	}
	ExtendStacks(winPtr->mainPtr->optionRootPtr, 0);
    }

    /*
     * Step 4: create a new stack level;  grow the level array if
     * we've run out of levels.  Clear the stacks for EXACT_LEAF_NAME
     * and EXACT_LEAF_CLASS (anything that was there is of no use
     * any more).
     */

    if (tsdPtr->curLevel >= tsdPtr->numLevels) {
	StackLevel *newLevels;

	newLevels = (StackLevel *) ckalloc((unsigned)
		(tsdPtr->numLevels*2*sizeof(StackLevel)));
	memcpy((VOID *) newLevels, (VOID *) tsdPtr->levels,
		(tsdPtr->numLevels*sizeof(StackLevel)));
	ckfree((char *) tsdPtr->levels);
	tsdPtr->numLevels *= 2;
	tsdPtr->levels = newLevels;
    }
    levelPtr = &tsdPtr->levels[tsdPtr->curLevel];
    levelPtr->winPtr = winPtr;
    arrayPtr = tsdPtr->stacks[EXACT_LEAF_NAME];
    arrayPtr->numUsed = 0;
    arrayPtr->nextToUse = arrayPtr->els;
    arrayPtr = tsdPtr->stacks[EXACT_LEAF_CLASS];
    arrayPtr->numUsed = 0;
    arrayPtr->nextToUse = arrayPtr->els;
    for (i = 0; i < NUM_STACKS; i++) {
	levelPtr->bases[i] = tsdPtr->stacks[i]->numUsed;
    }
    /*
     * Step 5: scan the current stack level looking for matches to this
     * window's name or class;  where found, add new information to the
     * stacks.
     */

    for (iPtr = searchOrder; *iPtr != -1; iPtr++) {
	register Element *elPtr;
	int count;
	Tk_Uid id;

	i = *iPtr;
	if (i & CLASS) {
	    id = winPtr->classUid;
	} else {
	    id = winPtr->nameUid;
	}
	elPtr = tsdPtr->stacks[i]->els;
	count = levelPtr->bases[i];

	/*
	 * For wildcard stacks, check all entries;  for non-wildcard
	 * stacks, only check things that matched in the parent.
	 */

	if (!(i & WILDCARD)) {
	    elPtr += levelPtr[-1].bases[i];
	    count -= levelPtr[-1].bases[i];
	}
	for ( ; count > 0; elPtr++, count--) {
	    if (elPtr->nameUid != id) {
		continue;
	    }
	    ExtendStacks(elPtr->child.arrayPtr, leaf);
	}
    }
    tsdPtr->cachedWindow = winPtr;
}

/*
 *--------------------------------------------------------------
 *
 * ExtendStacks --
 *
 *	Given an element array, copy all the elements from the
 *	array onto the system stacks (except for irrelevant leaf
 *	elements).
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The option stacks are extended.
 *
 *--------------------------------------------------------------
 */

static void
ExtendStacks(arrayPtr, leaf)
    ElArray *arrayPtr;		/* Array of elements to copy onto stacks. */
    int leaf;			/* If zero, then don't copy exact leaf
				 * elements. */
{
    register int count;
    register Element *elPtr;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    for (elPtr = arrayPtr->els, count = arrayPtr->numUsed;
	    count > 0; elPtr++, count--) {
	if (!(elPtr->flags & (NODE|WILDCARD)) && !leaf) {
	    continue;
	}
	tsdPtr->stacks[elPtr->flags] = ExtendArray(
                tsdPtr->stacks[elPtr->flags], elPtr);
    }
}

/*
 *--------------------------------------------------------------
 *
 * OptionThreadExitProc --
 *
 *	Free data structures for option handling.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Option-related data structures get freed.
 *
 *--------------------------------------------------------------
 */

static void
OptionThreadExitProc(clientData)
    ClientData clientData;	/* not used */
{
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    if (tsdPtr->initialized) {
	int i;
	for (i = 0; i < NUM_STACKS; i++) {
	    ckfree((char *) tsdPtr->stacks[i]);
	}
	ckfree((char *) tsdPtr->levels);
	tsdPtr->initialized = 0;
    }
}

/*
 *--------------------------------------------------------------
 *
 * OptionInit --
 *
 *	Initialize data structures for option handling.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Option-related data structures get initialized.
 *
 *--------------------------------------------------------------
 */

static void
OptionInit(mainPtr)
    register TkMainInfo *mainPtr;	/* Top-level information about
					 * window that isn't initialized
					 * yet. */
{
    int i;
    Tcl_Interp *interp;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    Element *defaultMatchPtr = &tsdPtr->defaultMatch;

    /*
     * First, once-only initialization.
     */
    
    if (tsdPtr->initialized == 0) {
        tsdPtr->initialized = 1;
        tsdPtr->cachedWindow = NULL;
	tsdPtr->numLevels = 5;
	tsdPtr->curLevel = -1;
	tsdPtr->serial = 0;

	tsdPtr->levels = (StackLevel *) ckalloc((unsigned) 
                (5*sizeof(StackLevel)));
	for (i = 0; i < NUM_STACKS; i++) {
	    tsdPtr->stacks[i] = NewArray(10);
	    tsdPtr->levels[0].bases[i] = 0;
	}
    
	defaultMatchPtr->nameUid = NULL;
	defaultMatchPtr->child.valueUid = NULL;
	defaultMatchPtr->priority = -1;
	defaultMatchPtr->flags = 0;
	Tcl_CreateThreadExitHandler(OptionThreadExitProc, NULL);
    }

    /*
     * Then, per-main-window initialization.  Create and delete dummy
     * interpreter for message logging.
     */

    mainPtr->optionRootPtr = NewArray(20);
    interp = Tcl_CreateInterp();
    (void) GetDefaultOptions(interp, mainPtr->winPtr);
    Tcl_DeleteInterp(interp);
}

/*
 *--------------------------------------------------------------
 *
 * ClearOptionTree --
 *
 *	This procedure is called to erase everything in a
 *	hierarchical option database.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	All the options associated with arrayPtr are deleted,
 *	along with all option subtrees.  The space pointed to
 *	by arrayPtr is freed.
 *
 *--------------------------------------------------------------
 */

static void
ClearOptionTree(arrayPtr)
    ElArray *arrayPtr;		/* Array of options;  delete everything
				 * referred to recursively by this. */
{
    register Element *elPtr;
    int count;

    for (count = arrayPtr->numUsed, elPtr = arrayPtr->els;  count > 0;
	    count--, elPtr++) {
	if (elPtr->flags & NODE) {
	    ClearOptionTree(elPtr->child.arrayPtr);
	}
    }
    ckfree((char *) arrayPtr);
}

/*
 *--------------------------------------------------------------
 *
 * GetDefaultOptions --
 *
 *	This procedure is invoked to load the default set of options
 *	for a window.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Options are added to those for winPtr's main window.  If
 *	there exists a RESOURCE_MANAGER proprety for winPtr's
 *	display, that is used.  Otherwise, the .Xdefaults file in
 *	the user's home directory is used.
 *
 *--------------------------------------------------------------
 */

static int
GetDefaultOptions(interp, winPtr)
    Tcl_Interp *interp;		/* Interpreter to use for error reporting. */
    TkWindow *winPtr;		/* Fetch option defaults for main window
				 * associated with this. */
{
    char *regProp;
    int result, actualFormat;
    unsigned long numItems, bytesAfter;
    Atom actualType;

    /*
     * Try the RESOURCE_MANAGER property on the root window first.
     */

    regProp = NULL;
    result = XGetWindowProperty(winPtr->display,
	    RootWindow(winPtr->display, 0),
	    XA_RESOURCE_MANAGER, 0, 100000,
	    False, XA_STRING, &actualType, &actualFormat,
	    &numItems, &bytesAfter, (unsigned char **) &regProp);

    if ((result == Success) && (actualType == XA_STRING)
	    && (actualFormat == 8)) {
	result = AddFromString(interp, (Tk_Window) winPtr, regProp,
		TK_USER_DEFAULT_PRIO);
	XFree(regProp);
	return result;
    }

    /*
     * No luck there.  Try a .Xdefaults file in the user's home
     * directory.
     */

    if (regProp != NULL) {
	XFree(regProp);
    }
    result = ReadOptionFile(interp, (Tk_Window) winPtr, "~/.Xdefaults",
	    TK_USER_DEFAULT_PRIO);
    return result;
}
@


1.4
log
@touched all sources to ease next import
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tkOption.c,v 1.7.6.2 2000/09/26 16:08:18 spolk Exp $
d29 29
d238 2
d267 2
a268 2
    char *name;			/* Multi-element name of option. */
    char *value;		/* String value for option. */
d278 2
a279 2
    register char *p;
    char *field;
d425 2
a426 2
    char *name;			/* Name of option. */
    char *className;		/* Class of option.  NULL means there
d430 2
a431 1
    Tk_Uid nameId, classId;
d434 2
d448 4
a451 1
    nameId = Tk_GetUid(name);
d453 44
d498 2
a499 2
	    count = tsdPtr->stacks[EXACT_LEAF_NAME]->numUsed; count > 0;
	    elPtr++, count--) {
d506 2
a507 2
	    count = tsdPtr->stacks[WILDCARD_LEAF_NAME]->numUsed; count > 0;
	    elPtr++, count--) {
d513 1
d517 2
a518 2
		count = tsdPtr->stacks[EXACT_LEAF_CLASS]->numUsed; count > 0;
		elPtr++, count--) {
d525 2
a526 2
		count = tsdPtr->stacks[WILDCARD_LEAF_CLASS]->numUsed; 
                count > 0; elPtr++, count--) {
d533 78
d644 1
a644 1
    static char *optionCmds[] = {
d716 1
a716 1
		Tcl_SetResult(interp, value, TCL_STATIC);
d790 1
a790 1
    if ((winPtr->mainPtr->winPtr == winPtr)
d1097 2
a1098 1
    char *realName, *buffer;
d1131 2
a1132 2
    bufferSize = Tcl_Seek(chan, 0L, SEEK_END);
    (void) Tcl_Seek(chan, 0L, SEEK_SET);
d1359 3
a1361 18
    levelPtr->bases[EXACT_LEAF_NAME] = tsdPtr->stacks[EXACT_LEAF_NAME]
            ->numUsed;
    levelPtr->bases[EXACT_LEAF_CLASS] = tsdPtr->stacks[EXACT_LEAF_CLASS]
            ->numUsed;
    levelPtr->bases[EXACT_NODE_NAME] = tsdPtr->stacks[EXACT_NODE_NAME]
            ->numUsed;
    levelPtr->bases[EXACT_NODE_CLASS] = tsdPtr->stacks[EXACT_NODE_CLASS]
            ->numUsed;
    levelPtr->bases[WILDCARD_LEAF_NAME] = tsdPtr->stacks[WILDCARD_LEAF_NAME]
            ->numUsed;
    levelPtr->bases[WILDCARD_LEAF_CLASS] = tsdPtr->stacks[WILDCARD_LEAF_CLASS]
            ->numUsed;
    levelPtr->bases[WILDCARD_NODE_NAME] = tsdPtr->stacks[WILDCARD_NODE_NAME]
            ->numUsed;
    levelPtr->bases[WILDCARD_NODE_CLASS] = tsdPtr->stacks[WILDCARD_NODE_CLASS]
            ->numUsed;


d1443 33
d1523 1
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
 * Copyright (c) 1994-1996 Sun Microsystems, Inc.
d14 1
a14 1
 * RCS: @@(#) $Id: tkOption.c,v 1.9 1999/01/26 04:11:26 jingham Exp $
a143 7
static ElArray *stacks[NUM_STACKS];
static TkWindow *cachedWindow = NULL;	/* Lowest-level window currently
					 * loaded in stacks at present. 
					 * NULL means stacks have never
					 * been used, or have been
					 * invalidated because of a change
					 * to the database. */
d159 16
a174 4
/*
 * Information about all of the stack levels that are currently
 * active.  This array grows dynamically to become as large as needed.
 */
d176 3
a178 4
static StackLevel *levels = NULL;
				/* Array describing current stack. */
static int numLevels = 0;	/* Total space allocated. */
static int curLevel = -1;	/* Highest level currently in use.  Note:
d181 7
d189 5
a193 15
/*
 * The variable below is a serial number for all options entered into
 * the database so far.  It increments on each addition to the option
 * database.  It is used in computing option priorities, so that the
 * most recent entry wins when choosing between options at the same
 * priority level.
 */

static int serial = 0;

/*
 * Special "no match" Element to use as default for searches.
 */

static Element defaultMatch;
d252 2
d258 1
a258 1
    cachedWindow = NULL;	/* Invalidate the cache. */
d271 2
a272 2
    newEl.priority = (priority << 24) + serial;
    serial++;
d402 2
d410 1
a410 1
    if (tkwin != (Tk_Window) cachedWindow) {
d415 3
a417 3
    bestPtr = &defaultMatch;
    for (elPtr = stacks[EXACT_LEAF_NAME]->els,
	    count = stacks[EXACT_LEAF_NAME]->numUsed; count > 0;
d424 2
a425 2
    for (elPtr = stacks[WILDCARD_LEAF_NAME]->els,
	    count = stacks[WILDCARD_LEAF_NAME]->numUsed; count > 0;
d434 2
a435 2
	for (elPtr = stacks[EXACT_LEAF_CLASS]->els,
		count = stacks[EXACT_LEAF_CLASS]->numUsed; count > 0;
d442 3
a444 3
	for (elPtr = stacks[WILDCARD_LEAF_CLASS]->els,
		count = stacks[WILDCARD_LEAF_CLASS]->numUsed; count > 0;
		elPtr++, count--) {
d457 1
a457 1
 * Tk_OptionCmd --
d472 1
a472 1
Tk_OptionCmd(clientData, interp, argc, argv)
d476 2
a477 2
    int argc;			/* Number of arguments. */
    char **argv;		/* Argument strings. */
d480 11
a490 2
    size_t length;
    char c;
d492 2
a493 3
    if (argc < 2) {
	Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
		" cmd arg ?arg ...?\"", (char *) NULL);
d496 27
a522 9
    c = argv[1][0];
    length = strlen(argv[1]);
    if ((c == 'a') && (strncmp(argv[1], "add", length) == 0)) {
	int priority;

	if ((argc != 4) && (argc != 5)) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " add pattern value ?priority?\"", (char *) NULL);
	    return TCL_ERROR;
d524 6
a529 5
	if (argc == 4) {
	    priority = TK_INTERACTIVE_PRIO;
	} else {
	    priority = ParsePriority(interp, argv[4]);
	    if (priority < 0) {
d532 7
d540 19
a558 9
	Tk_AddOption(tkwin, argv[2], argv[3], priority);
	return TCL_OK;
    } else if ((c == 'c') && (strncmp(argv[1], "clear", length) == 0)) {
	TkMainInfo *mainPtr;

	if (argc != 2) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " clear\"", (char *) NULL);
	    return TCL_ERROR;
d560 6
a565 37
	mainPtr = ((TkWindow *) tkwin)->mainPtr;
	if (mainPtr->optionRootPtr != NULL) {
	    ClearOptionTree(mainPtr->optionRootPtr);
	    mainPtr->optionRootPtr = NULL;
	}
	cachedWindow = NULL;
	return TCL_OK;
    } else if ((c == 'g') && (strncmp(argv[1], "get", length) == 0)) {
	Tk_Window window;
	Tk_Uid value;

	if (argc != 5) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " get window name class\"", (char *) NULL);
	    return TCL_ERROR;
	}
	window = Tk_NameToWindow(interp, argv[2], tkwin);
	if (window == NULL) {
	    return TCL_ERROR;
	}
	value = Tk_GetOption(window, argv[3], argv[4]);
	if (value != NULL) {
	    interp->result = value;
	}
	return TCL_OK;
    } else if ((c == 'r') && (strncmp(argv[1], "readfile", length) == 0)) {
	int priority;

	if ((argc != 3) && (argc != 4)) {
	    Tcl_AppendResult(interp, "wrong # args: should be \"",
		    argv[0], " readfile fileName ?priority?\"",
		    (char *) NULL);
	    return TCL_ERROR;
	}
	if (argc == 4) {
	    priority = ParsePriority(interp, argv[3]);
	    if (priority < 0) {
d568 12
a579 2
	} else {
	    priority = TK_INTERACTIVE_PRIO;
a580 5
	return ReadOptionFile(interp, tkwin, argv[2], priority);
    } else {
	Tcl_AppendResult(interp, "bad option \"", argv[1],
		"\": must be add, clear, get, or readfile", (char *) NULL);
	return TCL_ERROR;
d582 1
d608 3
d618 2
a619 2
	for (i = 1; i <= curLevel; i++) {
	    levels[i].winPtr->optionLevel = -1;
d621 2
a622 2
	curLevel = -1;
	cachedWindow = NULL;
d662 2
d674 4
a677 4
    for (i = 1; i <= curLevel; i++) {
	if (levels[i].winPtr == winPtr) {
	    for (j = i; j <= curLevel; j++) {
		levels[j].winPtr->optionLevel = -1;
d679 2
a680 2
	    curLevel = i-1;
	    basePtr = levels[i].bases;
d682 1
a682 1
		arrayPtr = stacks[j];
d686 2
a687 2
	    if (curLevel <= 0) {
		cachedWindow = NULL;
d689 1
a689 1
		cachedWindow = levels[curLevel].winPtr;
d706 1
a706 1
 *	In this case, an error message is left in interp->result.
d766 1
a766 1
 *	error message will be left in interp->result.  The memory at
d829 4
a832 2
		sprintf(interp->result, "missing colon on line %d",
			lineNum);
d864 4
a867 1
	    sprintf(interp->result, "missing value on line %d", lineNum);
d879 4
a882 2
		sprintf(interp->result, "missing newline on line %d",
			lineNum);
d918 1
a918 1
 *	error message will be left in interp->result.
d1101 2
d1127 1
a1127 1
	if ((level == -1) || (cachedWindow == NULL)) {
d1141 4
a1144 4
    if (curLevel >= level) {
	while (curLevel >= level) {
	    levels[curLevel].winPtr->optionLevel = -1;
	    curLevel--;
d1146 1
a1146 1
	levelPtr = &levels[level];
d1148 1
a1148 1
	    arrayPtr = stacks[i];
d1153 1
a1153 1
    curLevel = winPtr->optionLevel = level;
d1161 3
a1163 3
    if ((curLevel == 1)
	    && ((cachedWindow == NULL)
	    || (cachedWindow->mainPtr != winPtr->mainPtr))) {
d1165 1
a1165 1
	    arrayPtr = stacks[i];
d1179 1
a1179 1
    if (curLevel >= numLevels) {
d1183 6
a1188 6
		(numLevels*2*sizeof(StackLevel)));
	memcpy((VOID *) newLevels, (VOID *) levels,
		(numLevels*sizeof(StackLevel)));
	ckfree((char *) levels);
	numLevels *= 2;
	levels = newLevels;
d1190 1
a1190 1
    levelPtr = &levels[curLevel];
d1192 1
a1192 1
    arrayPtr = stacks[EXACT_LEAF_NAME];
d1195 1
a1195 1
    arrayPtr = stacks[EXACT_LEAF_CLASS];
d1198 16
a1213 8
    levelPtr->bases[EXACT_LEAF_NAME] = stacks[EXACT_LEAF_NAME]->numUsed;
    levelPtr->bases[EXACT_LEAF_CLASS] = stacks[EXACT_LEAF_CLASS]->numUsed;
    levelPtr->bases[EXACT_NODE_NAME] = stacks[EXACT_NODE_NAME]->numUsed;
    levelPtr->bases[EXACT_NODE_CLASS] = stacks[EXACT_NODE_CLASS]->numUsed;
    levelPtr->bases[WILDCARD_LEAF_NAME] = stacks[WILDCARD_LEAF_NAME]->numUsed;
    levelPtr->bases[WILDCARD_LEAF_CLASS] = stacks[WILDCARD_LEAF_CLASS]->numUsed;
    levelPtr->bases[WILDCARD_NODE_NAME] = stacks[WILDCARD_NODE_NAME]->numUsed;
    levelPtr->bases[WILDCARD_NODE_CLASS] = stacks[WILDCARD_NODE_CLASS]->numUsed;
d1233 1
a1233 1
	elPtr = stacks[i]->els;
d1252 1
a1252 1
    cachedWindow = winPtr;
d1281 2
d1289 2
a1290 1
	stacks[elPtr->flags] = ExtendArray(stacks[elPtr->flags], elPtr);
d1318 3
d1325 7
d1333 2
a1334 4
    if (numLevels == 0) {

	numLevels = 5;
	levels = (StackLevel *) ckalloc((unsigned) (5*sizeof(StackLevel)));
d1336 2
a1337 2
	    stacks[i] = NewArray(10);
	    levels[0].bases[i] = 0;
d1340 4
a1343 4
	defaultMatch.nameUid = NULL;
	defaultMatch.child.valueUid = NULL;
	defaultMatch.priority = -1;
	defaultMatch.flags = 0;
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d9 1
a9 1
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
d14 1
a14 1
 * RCS: @@(#) $Id: tkOption.c,v 1.7.6.2 2000/09/26 16:08:18 spolk Exp $
d144 7
d166 4
a169 16
typedef struct ThreadSpecificData {
    int initialized;            /* 0 means the ThreadSpecific Data structure
				 * for the current thread needs to be
				 * initialized. */
    ElArray *stacks[NUM_STACKS];
    TkWindow *cachedWindow;
                                /* Lowest-level window currently
				 * loaded in stacks at present. 
				 * NULL means stacks have never
				 * been used, or have been
				 * invalidated because of a change
				 * to the database. */
    /*
     * Information about all of the stack levels that are currently
     * active.  This array grows dynamically to become as large as needed.
     */
d171 4
a174 3
    StackLevel *levels;	        /* Array describing current stack. */
    int numLevels;	        /* Total space allocated. */
    int curLevel;	        /* Highest level currently in use.  Note:
a176 7
    /*
     * The variable below is a serial number for all options entered into
     * the database so far.  It increments on each addition to the option
     * database.  It is used in computing option priorities, so that the
     * most recent entry wins when choosing between options at the same
     * priority level.
     */
d178 15
a192 5
    int serial;
    Element defaultMatch;       /* Special "no match" Element to use as 
				 * default for searches.*/
} ThreadSpecificData;
static Tcl_ThreadDataKey dataKey;
a250 2
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
d255 1
a255 1
    tsdPtr->cachedWindow = NULL;	/* Invalidate the cache. */
d268 2
a269 2
    newEl.priority = (priority << 24) + tsdPtr->serial;
    tsdPtr->serial++;
a398 2
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
d405 1
a405 1
    if (tkwin != (Tk_Window) tsdPtr->cachedWindow) {
d410 3
a412 3
    bestPtr = &tsdPtr->defaultMatch;
    for (elPtr = tsdPtr->stacks[EXACT_LEAF_NAME]->els,
	    count = tsdPtr->stacks[EXACT_LEAF_NAME]->numUsed; count > 0;
d419 2
a420 2
    for (elPtr = tsdPtr->stacks[WILDCARD_LEAF_NAME]->els,
	    count = tsdPtr->stacks[WILDCARD_LEAF_NAME]->numUsed; count > 0;
d429 2
a430 2
	for (elPtr = tsdPtr->stacks[EXACT_LEAF_CLASS]->els,
		count = tsdPtr->stacks[EXACT_LEAF_CLASS]->numUsed; count > 0;
d437 3
a439 3
	for (elPtr = tsdPtr->stacks[WILDCARD_LEAF_CLASS]->els,
		count = tsdPtr->stacks[WILDCARD_LEAF_CLASS]->numUsed; 
                count > 0; elPtr++, count--) {
d452 1
a452 1
 * Tk_OptionObjCmd --
d467 1
a467 1
Tk_OptionObjCmd(clientData, interp, objc, objv)
d471 2
a472 2
    int objc;			/* Number of Tcl_Obj arguments. */
    Tcl_Obj *CONST objv[];	/* Tcl_Obj arguments. */
d475 2
a476 11
    int index, result;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    static char *optionCmds[] = {
	"add", "clear", "get", "readfile", NULL
    };

    enum optionVals {
	OPTION_ADD, OPTION_CLEAR, OPTION_GET, OPTION_READFILE
    };
d478 3
a480 2
    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "cmd arg ?arg ...?");
d483 15
a497 13

    result = Tcl_GetIndexFromObj(interp, objv[1], optionCmds, "option", 0,
	    &index);
    if (result != TCL_OK) {
	return result;
    }
    
    result = TCL_OK;
    switch ((enum optionVals) index) {
	case OPTION_ADD: {
	    int priority;
	    if ((objc != 4) && (objc != 5)) {
		Tcl_WrongNumArgs(interp, 2, objv, "pattern value ?priority?");
a499 12

	    if (objc == 4) {
		priority = TK_INTERACTIVE_PRIO;
	    } else {
		priority = ParsePriority(interp, Tcl_GetString(objv[4]));
		if (priority < 0) {
		    return TCL_ERROR;
		}
	    }
	    Tk_AddOption(tkwin, Tcl_GetString(objv[2]),
		    Tcl_GetString(objv[3]), priority);
	    break;
d501 29
a529 15

	case OPTION_CLEAR: {
	    TkMainInfo *mainPtr;

	    if (objc != 2) {
		Tcl_WrongNumArgs(interp, 2, objv, "");
		return TCL_ERROR;
	    }
	    mainPtr = ((TkWindow *) tkwin)->mainPtr;
	    if (mainPtr->optionRootPtr != NULL) {
		ClearOptionTree(mainPtr->optionRootPtr);
		mainPtr->optionRootPtr = NULL;
	    }
	    tsdPtr->cachedWindow = NULL;
	    break;
d531 13
a543 19

	case OPTION_GET: {
	    Tk_Window window;
	    Tk_Uid value;
	    
	    if (objc != 5) {
		Tcl_WrongNumArgs(interp, 2, objv, "window name class");
		return TCL_ERROR;
	    }
	    window = Tk_NameToWindow(interp, Tcl_GetString(objv[2]), tkwin);
	    if (window == NULL) {
		return TCL_ERROR;
	    }
	    value = Tk_GetOption(window, Tcl_GetString(objv[3]),
		    Tcl_GetString(objv[4]));
	    if (value != NULL) {
		Tcl_SetResult(interp, value, TCL_STATIC);
	    }
	    break;
d545 3
a547 6

	case OPTION_READFILE: {
	    int priority;
	    
	    if ((objc != 3) && (objc != 4)) {
		Tcl_WrongNumArgs(interp, 2, objv, "fileName ?priority?");
d550 2
a551 12

	    if (objc == 4) {
		priority = ParsePriority(interp, Tcl_GetString(objv[3]));
		if (priority < 0) {
		    return TCL_ERROR;
		}
	    } else {
		priority = TK_INTERACTIVE_PRIO;
	    }
	    result = ReadOptionFile(interp, tkwin, Tcl_GetString(objv[2]),
		    priority);
	    break;
d553 5
a558 1
    return result;
a583 3
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

d591 2
a592 2
	for (i = 1; i <= tsdPtr->curLevel; i++) {
	    tsdPtr->levels[i].winPtr->optionLevel = -1;
d594 2
a595 2
	tsdPtr->curLevel = -1;
	tsdPtr->cachedWindow = NULL;
a634 2
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
d645 4
a648 4
    for (i = 1; i <= tsdPtr->curLevel; i++) {
	if (tsdPtr->levels[i].winPtr == winPtr) {
	    for (j = i; j <= tsdPtr->curLevel; j++) {
		tsdPtr->levels[j].winPtr->optionLevel = -1;
d650 2
a651 2
	    tsdPtr->curLevel = i-1;
	    basePtr = tsdPtr->levels[i].bases;
d653 1
a653 1
		arrayPtr = tsdPtr->stacks[j];
d657 2
a658 2
	    if (tsdPtr->curLevel <= 0) {
		tsdPtr->cachedWindow = NULL;
d660 1
a660 1
		tsdPtr->cachedWindow = tsdPtr->levels[tsdPtr->curLevel].winPtr;
d677 1
a677 1
 *	In this case, an error message is left in the interp's result.
d737 1
a737 1
 *	error message will be left in the interp's result.  The memory at
d800 2
a801 4
		char buf[32 + TCL_INTEGER_SPACE];
		
		sprintf(buf, "missing colon on line %d", lineNum);
		Tcl_SetResult(interp, buf, TCL_VOLATILE);
d833 1
a833 4
	    char buf[32 + TCL_INTEGER_SPACE];
	    
	    sprintf(buf, "missing value on line %d", lineNum);
	    Tcl_SetResult(interp, buf, TCL_VOLATILE);
d845 2
a846 4
		char buf[32 + TCL_INTEGER_SPACE];
		
		sprintf(buf, "missing newline on line %d", lineNum);
		Tcl_SetResult(interp, buf, TCL_VOLATILE);
d882 1
a882 1
 *	error message will be left in the interp's result.
a1064 2
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
d1089 1
a1089 1
	if ((level == -1) || (tsdPtr->cachedWindow == NULL)) {
d1103 4
a1106 4
    if (tsdPtr->curLevel >= level) {
	while (tsdPtr->curLevel >= level) {
	    tsdPtr->levels[tsdPtr->curLevel].winPtr->optionLevel = -1;
	    tsdPtr->curLevel--;
d1108 1
a1108 1
	levelPtr = &tsdPtr->levels[level];
d1110 1
a1110 1
	    arrayPtr = tsdPtr->stacks[i];
d1115 1
a1115 1
    tsdPtr->curLevel = winPtr->optionLevel = level;
d1123 3
a1125 3
    if ((tsdPtr->curLevel == 1)
	    && ((tsdPtr->cachedWindow == NULL)
	    || (tsdPtr->cachedWindow->mainPtr != winPtr->mainPtr))) {
d1127 1
a1127 1
	    arrayPtr = tsdPtr->stacks[i];
d1141 1
a1141 1
    if (tsdPtr->curLevel >= tsdPtr->numLevels) {
d1145 6
a1150 6
		(tsdPtr->numLevels*2*sizeof(StackLevel)));
	memcpy((VOID *) newLevels, (VOID *) tsdPtr->levels,
		(tsdPtr->numLevels*sizeof(StackLevel)));
	ckfree((char *) tsdPtr->levels);
	tsdPtr->numLevels *= 2;
	tsdPtr->levels = newLevels;
d1152 1
a1152 1
    levelPtr = &tsdPtr->levels[tsdPtr->curLevel];
d1154 1
a1154 1
    arrayPtr = tsdPtr->stacks[EXACT_LEAF_NAME];
d1157 1
a1157 1
    arrayPtr = tsdPtr->stacks[EXACT_LEAF_CLASS];
d1160 8
a1167 16
    levelPtr->bases[EXACT_LEAF_NAME] = tsdPtr->stacks[EXACT_LEAF_NAME]
            ->numUsed;
    levelPtr->bases[EXACT_LEAF_CLASS] = tsdPtr->stacks[EXACT_LEAF_CLASS]
            ->numUsed;
    levelPtr->bases[EXACT_NODE_NAME] = tsdPtr->stacks[EXACT_NODE_NAME]
            ->numUsed;
    levelPtr->bases[EXACT_NODE_CLASS] = tsdPtr->stacks[EXACT_NODE_CLASS]
            ->numUsed;
    levelPtr->bases[WILDCARD_LEAF_NAME] = tsdPtr->stacks[WILDCARD_LEAF_NAME]
            ->numUsed;
    levelPtr->bases[WILDCARD_LEAF_CLASS] = tsdPtr->stacks[WILDCARD_LEAF_CLASS]
            ->numUsed;
    levelPtr->bases[WILDCARD_NODE_NAME] = tsdPtr->stacks[WILDCARD_NODE_NAME]
            ->numUsed;
    levelPtr->bases[WILDCARD_NODE_CLASS] = tsdPtr->stacks[WILDCARD_NODE_CLASS]
            ->numUsed;
d1187 1
a1187 1
	elPtr = tsdPtr->stacks[i]->els;
d1206 1
a1206 1
    tsdPtr->cachedWindow = winPtr;
a1234 2
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
d1241 1
a1241 2
	tsdPtr->stacks[elPtr->flags] = ExtendArray(
                tsdPtr->stacks[elPtr->flags], elPtr);
a1268 3
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));
    Element *defaultMatchPtr = &tsdPtr->defaultMatch;
a1272 7
    
    if (tsdPtr->initialized == 0) {
        tsdPtr->initialized = 1;
        tsdPtr->cachedWindow = NULL;
	tsdPtr->numLevels = 5;
	tsdPtr->curLevel = -1;
	tsdPtr->serial = 0;
d1274 4
a1277 2
	tsdPtr->levels = (StackLevel *) ckalloc((unsigned) 
                (5*sizeof(StackLevel)));
d1279 2
a1280 2
	    tsdPtr->stacks[i] = NewArray(10);
	    tsdPtr->levels[0].bases[i] = 0;
d1283 4
a1286 4
	defaultMatchPtr->nameUid = NULL;
	defaultMatchPtr->child.valueUid = NULL;
	defaultMatchPtr->priority = -1;
	defaultMatchPtr->flags = 0;
@


1.1.1.3
log
@import tk 8.4.0
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tkOption.c,v 1.15 2002/08/05 04:30:40 dgp Exp $
a28 29
 *
 * The structure of the option db tree is a little confusing.  There are
 * four different kinds of nodes in the tree:
 *	interior class nodes
 *	interior name nodes
 *	leaf class nodes
 *	leaf name nodes
 *
 * All interior nodes refer to _window_ classes and names; all leaf nodes
 * refer to _option_ classes and names.  When looking for a particular option,
 * therefore, you must compare interior node values to corresponding window
 * values, and compare leaf node values to corresponding option values.
 *
 * The tree is actually stored in a collection of arrays; there is one each
 * combination of WILDCARD/EXACT and CLASS/NAME and NODE/LEAF.  The NODE arrays
 * contain the interior nodes of the tree; each element has a pointer to an
 * array of elements which are the leaves of the tree.  The LEAF arrays, rather
 * than holding the leaves of the tree, hold a cached subset of the option
 * database, consisting of the values of all defined options for a single
 * window, and some additional information about each ancestor of the window
 * (since some options may be inherited from a parent), all the way back to the
 * root window.
 *
 * Each time a call is made to Tk_GetOption, Tk will attempt to use the cached
 * information to satisfy the lookup.  If the call is for a window other than
 * that for which options are currently cached, the portion of the cache that
 * contains information for common ancestors of the two windows is retained and
 * the remainder is discarded and rebuilt with new information for the new
 * window.
a208 2
static void		OptionThreadExitProc _ANSI_ARGS_((
			    ClientData clientData));
d236 2
a237 2
    CONST char *name;		/* Multi-element name of option. */
    CONST char *value;		/* String value for option. */
d247 2
a248 2
    register CONST char *p;
    CONST char *field;
d394 2
a395 2
    CONST char *name;		/* Name of option. */
    CONST char *className;	/* Class of option.  NULL means there
d399 1
a399 2
    Tk_Uid nameId, classId = NULL;
    char *masqName;
a401 2
    StackLevel *levelPtr;
    int stackDepth[NUM_STACKS];
d414 1
a414 4
    /*
     * Get a default "best" match.
     */
    
a415 44

    /*
     * For megawidget support, we want to have some widget options masquerade
     * as options for other widgets.  For example, a combobox has a button in
     * it; this button ought to pick up the *Button.background, etc., options.
     * But because the class of the widget is Combobox, our normal search
     * won't get that option.
     *
     * To work around this, the option name field syntax was extended to allow
     * for a "." in the name; if this character occurs in the name, then it
     * indicates that this name contains a new window class and an option name,
     * ie, "Button.foreground".  If we see this form in the name field, we 
     * query the option database directly (since the option stacks will not
     * have the information we need).
     */

    masqName = strchr(name, (int)'.');
    if (masqName != NULL) {
	/*
	 * This option is masquerading with a different window class.
	 * Search the stack to the depth it was before the current window's
	 * information was pushed (the value for which is stored in the bases
	 * field).
	 */
	levelPtr = &tsdPtr->levels[tsdPtr->curLevel];
	nameId = Tk_GetUid(masqName+1);
	for (count = 0; count < NUM_STACKS; count++) {
	    stackDepth[count] = levelPtr->bases[count];
	}
    } else {
	/*
	 * No option masquerading here.  Just use the current level to get the
	 * stack depths.
	 */
	nameId = Tk_GetUid(name);
	for (count = 0; count < NUM_STACKS; count++) {
	    stackDepth[count] = tsdPtr->stacks[count]->numUsed;
	}
    }

    /*
     * Probe the stacks for matches.
     */

d417 2
a418 2
	     count = stackDepth[EXACT_LEAF_NAME]; count > 0;
	 elPtr++, count--) {
d425 2
a426 2
	     count = stackDepth[WILDCARD_LEAF_NAME]; count > 0;
	 elPtr++, count--) {
a431 1

d435 2
a436 2
		 count = stackDepth[EXACT_LEAF_CLASS]; count > 0;
	     elPtr++, count--) {
d443 2
a444 2
		 count = stackDepth[WILDCARD_LEAF_CLASS]; count > 0;
	     elPtr++, count--) {
a450 78
    
    /*
     * If this option was masquerading with a different window class,
     * probe the option database now.  Note that this will be inefficient
     * if the option database is densely populated, or if the widget has many
     * masquerading options.
     */

    if (masqName != NULL) {
	char *masqClass;
	Tk_Uid nodeId, winClassId, winNameId;
	unsigned int classNameLength;
	register Element *nodePtr, *leafPtr;
	static int searchOrder[] = { EXACT_NODE_NAME,
					 WILDCARD_NODE_NAME,
					 EXACT_NODE_CLASS,
					 WILDCARD_NODE_CLASS,
					 -1 };
	int *currentPtr, currentStack, leafCount;
	
	/*
	 * Extract the masquerade class name from the name field.
	 */
	
	classNameLength	= (unsigned int)(masqName - name);
	masqClass	= (char *)ckalloc(classNameLength + 1);
	strncpy(masqClass, name, classNameLength);
	masqClass[classNameLength] = '\0';
	
	winClassId	= Tk_GetUid(masqClass);
	ckfree(masqClass);
	winNameId	= ((TkWindow *)tkwin)->nameUid;

	levelPtr = &tsdPtr->levels[tsdPtr->curLevel];

	for (currentPtr = searchOrder; *currentPtr != -1; currentPtr++) {
	    currentStack = *currentPtr;
	    nodePtr	= tsdPtr->stacks[currentStack]->els;
	    count	= levelPtr->bases[currentStack];

	    /*
	     * For wildcard stacks, check all entries;  for non-wildcard
	     * stacks, only check things that matched in the parent.
	     */
	    
	    if (!(currentStack & WILDCARD)) {
		nodePtr += levelPtr[-1].bases[currentStack];
		count	-= levelPtr[-1].bases[currentStack];
	    }
	    
	    if (currentStack && CLASS) {
		nodeId = winClassId;
	    } else {
		nodeId = winNameId;
	    }

	    for ( ; count > 0; nodePtr++, count--) {
		if (nodePtr->nameUid == nodeId) {
		    leafPtr	= nodePtr->child.arrayPtr->els;
		    leafCount	= nodePtr->child.arrayPtr->numUsed;
		    for ( ; leafCount > 0; leafPtr++, leafCount--) {
			if (leafPtr->flags & CLASS && className != NULL) {
			    if (leafPtr->nameUid == classId &&
				    leafPtr->priority > bestPtr->priority) {
				bestPtr = leafPtr;
			    }
			} else {
			    if (leafPtr->nameUid == nameId &&
				    leafPtr->priority > bestPtr->priority) {
				bestPtr = leafPtr;
			    }
			}
		    }
		}
	    }
	}
    }
    
d484 1
a484 1
    static CONST char *optionCmds[] = {
d556 1
a556 1
		Tcl_SetResult(interp, (char *)value, TCL_STATIC);
d630 1
a630 1
    if ((winPtr->mainPtr != NULL) && (winPtr->mainPtr->winPtr == winPtr)
d937 1
a937 2
    CONST char *realName;
    char *buffer;
d970 2
a971 2
    bufferSize = (int) Tcl_Seek(chan, (Tcl_WideInt) 0, SEEK_END);
    (void) Tcl_Seek(chan, (Tcl_WideInt) 0, SEEK_SET);
d1198 18
a1215 3
    for (i = 0; i < NUM_STACKS; i++) {
	levelPtr->bases[i] = tsdPtr->stacks[i]->numUsed;
    }
a1296 33
 * OptionThreadExitProc --
 *
 *	Free data structures for option handling.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Option-related data structures get freed.
 *
 *--------------------------------------------------------------
 */

static void
OptionThreadExitProc(clientData)
    ClientData clientData;	/* not used */
{
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *) 
            Tcl_GetThreadData(&dataKey, sizeof(ThreadSpecificData));

    if (tsdPtr->initialized) {
	int i;
	for (i = 0; i < NUM_STACKS; i++) {
	    ckfree((char *) tsdPtr->stacks[i]);
	}
	ckfree((char *) tsdPtr->levels);
	tsdPtr->initialized = 0;
    }
}

/*
 *--------------------------------------------------------------
 *
a1343 1
	Tcl_CreateThreadExitHandler(OptionThreadExitProc, NULL);
@


