head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.28
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.26
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.24
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.22
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.20
	gdb_7_0-branch:1.5.0.18
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tk8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.12
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.10
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.8
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb_6_4-branch:1.5.0.6
	gdb_6_4-2005-11-01-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	gdb_6_1-branch:1.5.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	gdb_6_0-2003-10-04-release:1.5
	gdb_6_0-branch:1.5.0.2
	gdb_6_0-2003-06-23-branchpoint:1.5
	TK8_4_1:1.1.1.3
	gdb_5_3-2002-12-12-release:1.2
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.3
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.6
	gdb_5_3-branch:1.2.0.4
	gdb_5_3-2002-09-04-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TK_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	insight-2000-02-04:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.20.24.43;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.21.19.53.13;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.39.24;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.10.01.16.50;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.07.00.19.29;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.10.00.22.31;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.20.38.10;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tk 8.4.1
@
text
@/*
 * tkFileFilter.c --
 *
 *	Process the -filetypes option for the file dialogs on Windows and the
 *	Mac.
 *
 * Copyright (c) 1996 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkFileFilter.c,v 1.5 2002/01/27 11:10:50 das Exp $
 */

#include "tkInt.h"
#include "tkFileFilter.h"

static int		AddClause _ANSI_ARGS_((
			    Tcl_Interp * interp, FileFilter * filterPtr,
			    CONST char * patternsStr, CONST char * ostypesStr,
			    int isWindows));
static void		FreeClauses _ANSI_ARGS_((FileFilter * filterPtr));
static void		FreeGlobPatterns _ANSI_ARGS_((
			    FileFilterClause * clausePtr));
static void		FreeMacFileTypes _ANSI_ARGS_((
			    FileFilterClause * clausePtr));
static FileFilter *	GetFilter _ANSI_ARGS_((FileFilterList * flistPtr,
			    CONST char * name));

/*
 *----------------------------------------------------------------------
 *
 * TkInitFileFilters --
 *
 *	Initializes a FileFilterList data structure. A FileFilterList
 *	must be initialized EXACTLY ONCE before any calls to
 *	TkGetFileFilters() is made. The usual flow of control is:
 *		TkInitFileFilters(&flist);
 *		    TkGetFileFilters(&flist, ...);
 *		    TkGetFileFilters(&flist, ...);
 *		    ...
 *		TkFreeFileFilters(&flist);
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The fields in flistPtr are initialized.
 *----------------------------------------------------------------------
 */

void
TkInitFileFilters(flistPtr)
    FileFilterList * flistPtr;	/* The structure to be initialized. */
{
    flistPtr->filters = NULL;
    flistPtr->filtersTail = NULL;
    flistPtr->numFilters = 0;
}

/*
 *----------------------------------------------------------------------
 *
 * TkGetFileFilters --
 *
 *	This function is called by the Mac and Windows implementation
 *	of tk_getOpenFile and tk_getSaveFile to translate the string
 *	value of the -filetypes option of into an easy-to-parse C
 *	structure (flistPtr). The caller of this function will then use
 *	flistPtr to perform filetype matching in a platform specific way.
 *
 *	flistPtr must be initialized (See comments in TkInitFileFilters).
 *
 * Results:
 *	A standard TCL return value.
 *
 * Side effects:
 *	The fields in flistPtr are changed according to string.
 *----------------------------------------------------------------------
 */
int
TkGetFileFilters(interp, flistPtr, string, isWindows)
    Tcl_Interp *interp;		/* Interpreter to use for error reporting. */
    FileFilterList * flistPtr;	/* Stores the list of file filters. */
    char * string;		/* Value of the -filetypes option. */
    int isWindows;		/* True if we are running on Windows. */
{
    int listArgc;
    CONST char ** listArgv = NULL;
    CONST char ** typeInfo = NULL;
    int code = TCL_OK;
    int i;

    if (Tcl_SplitList(interp, string, &listArgc, &listArgv) != TCL_OK) {
	return TCL_ERROR;
    }
    if (listArgc == 0) {
	goto done;
    }

    /*
     * Free the filter information that have been allocated the previous
     * time -- the -filefilters option may have been used more than once in
     * the command line.
     */
    TkFreeFileFilters(flistPtr);

    for (i = 0; i<listArgc; i++) {
	/*
	 * Each file type should have two or three elements: the first one
	 * is the name of the type and the second is the filter of the type.
	 * The third is the Mac OSType ID, but we don't care about them here.
	 */
	int count;
	FileFilter * filterPtr;

	if (Tcl_SplitList(interp, listArgv[i], &count, &typeInfo) != TCL_OK) {
	    code = TCL_ERROR;
	    goto done;
	}
	
	if (count != 2 && count != 3) {
	    Tcl_AppendResult(interp, "bad file type \"", listArgv[i], "\", ",
		"should be \"typeName {extension ?extensions ...?} ",
		"?{macType ?macTypes ...?}?\"",	NULL);
	    code = TCL_ERROR;
	    goto done;
	}

	filterPtr = GetFilter(flistPtr, typeInfo[0]);

	if (count == 2) {
	    code = AddClause(interp, filterPtr, typeInfo[1], NULL,
		isWindows);
	} else {
	    code = AddClause(interp, filterPtr, typeInfo[1], typeInfo[2],
		isWindows);
	}
	if (code != TCL_OK) {
	    goto done;
	}

        if (typeInfo) {
	    ckfree((char*)typeInfo);
	}
	typeInfo = NULL;
    }

  done:
    if (typeInfo) {
       ckfree((char*)typeInfo);
    }
    if (listArgv) {
	ckfree((char*)listArgv);
    }
    return code;
}

/*
 *----------------------------------------------------------------------
 *
 * TkFreeFileFilters --
 *
 *	Frees the malloc'ed file filter information.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The fields allocated by TkGetFileFilters() are freed.
 *----------------------------------------------------------------------
 */

void
TkFreeFileFilters(flistPtr)
    FileFilterList * flistPtr;	/* List of file filters to free */
{
    FileFilter * filterPtr, *toFree;

    filterPtr=flistPtr->filters;
    while (filterPtr) {
	toFree = filterPtr;
	filterPtr=filterPtr->next;
	FreeClauses(toFree);
	ckfree((char*)toFree->name);
	ckfree((char*)toFree);
    }
    flistPtr->filters = NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * AddClause --
 *
 *	Add one FileFilterClause to filterPtr.
 *
 * Results:
 *	A standard TCL result.
 *
 * Side effects:
 *	The list of filter clauses are updated in filterPtr.
 *----------------------------------------------------------------------
 */

static int AddClause(interp, filterPtr, patternsStr, ostypesStr, isWindows)
    Tcl_Interp * interp;	/* Interpreter to use for error reporting. */
    FileFilter * filterPtr;	/* Stores the new filter clause */
    CONST char * patternsStr;		/* A TCL list of glob patterns. */
    CONST char * ostypesStr;		/* A TCL list of Mac OSType strings. */
    int isWindows;		/* True if we are running on Windows; False
				 * if we are running on the Mac; Glob
				 * patterns need to be processed differently
				 * on these two platforms */
{
    CONST char ** globList = NULL;
    int globCount;
    CONST char ** ostypeList = NULL;
    int ostypeCount;
    FileFilterClause * clausePtr;
    int i;
    int code = TCL_OK;

    if (Tcl_SplitList(interp, patternsStr, &globCount, &globList)!= TCL_OK) {
	code = TCL_ERROR;
	goto done;
    }
    if (ostypesStr != NULL) {
	if (Tcl_SplitList(interp, ostypesStr, &ostypeCount, &ostypeList)
		!= TCL_OK) {
	    code = TCL_ERROR;
	    goto done;
	}
	for (i=0; i<ostypeCount; i++) {
	    if (strlen(ostypeList[i]) != 4) {
		Tcl_AppendResult(interp, "bad Macintosh file type \"",
		    ostypeList[i], "\"", NULL);
		code = TCL_ERROR;
		goto done;
	    }
	}
    }

    /*
     * Add the clause into the list of clauses 
     */

    clausePtr = (FileFilterClause*)ckalloc(sizeof(FileFilterClause));
    clausePtr->patterns     = NULL;
    clausePtr->patternsTail = NULL;
    clausePtr->macTypes     = NULL;
    clausePtr->macTypesTail = NULL;

    if (filterPtr->clauses == NULL) {
	filterPtr->clauses = filterPtr->clausesTail = clausePtr;
    } else {
	filterPtr->clausesTail->next = clausePtr;
	filterPtr->clausesTail = clausePtr;
    }
    clausePtr->next = NULL;

    if (globCount > 0 && globList != NULL) {
	for (i=0; i<globCount; i++) {
	    GlobPattern * globPtr = (GlobPattern*)ckalloc(sizeof(GlobPattern));
	    int len;
	    
	    len = (strlen(globList[i]) + 1) * sizeof(char);

	    if (globList[i][0] && globList[i][0] != '*') {
		/*
		 * Prepend a "*" to patterns that do not have a leading "*"
		 */
		globPtr->pattern = (char*)ckalloc((unsigned int) len+1);
		globPtr->pattern[0] = '*';
		strcpy(globPtr->pattern+1, globList[i]);
	    }
	    else if (isWindows) {
		if (strcmp(globList[i], "*") == 0) {
		    globPtr->pattern = (char*)ckalloc(4*sizeof(char));
		    strcpy(globPtr->pattern, "*.*");
		}
		else if (strcmp(globList[i], "") == 0) {
		    /*
		     * An empty string means "match all files with no
		     * extensions"
		     * BUG: "*." actually matches with all files on Win95
		     */
		    globPtr->pattern = (char*)ckalloc(3*sizeof(char));
		    strcpy(globPtr->pattern, "*.");
		}
		else {
		    globPtr->pattern = (char*)ckalloc((unsigned int) len);
		    strcpy(globPtr->pattern, globList[i]);
		}
	    } else {
		globPtr->pattern = (char*)ckalloc((unsigned int) len);
		strcpy(globPtr->pattern, globList[i]);
	    }

	    /*
	     * Add the glob pattern into the list of patterns.
	     */

	    if (clausePtr->patterns == NULL) {
		clausePtr->patterns = clausePtr->patternsTail = globPtr;
	    } else {
		clausePtr->patternsTail->next = globPtr;
		clausePtr->patternsTail = globPtr;
	    }
	    globPtr->next = NULL;
	}
    }
    if (ostypeCount > 0 && ostypeList != NULL) {
	for (i=0; i<ostypeCount; i++) {
	    MacFileType * mfPtr = (MacFileType*)ckalloc(sizeof(MacFileType));

	    memcpy(&mfPtr->type, ostypeList[i], sizeof(OSType));

	    /*
	     * Add the Mac type pattern into the list of Mac types
	     */
	    if (clausePtr->macTypes == NULL) {
		clausePtr->macTypes = clausePtr->macTypesTail = mfPtr;
	    } else {
		clausePtr->macTypesTail->next = mfPtr;
		clausePtr->macTypesTail = mfPtr;
	    }
	    mfPtr->next = NULL;
	}
    }

  done:
    if (globList) {
	ckfree((char*)globList);
    }
    if (ostypeList) {
	ckfree((char*)ostypeList);
    }

    return code;
}	

/*
 *----------------------------------------------------------------------
 *
 * GetFilter --
 *
 *	Add one FileFilter to flistPtr.
 *
 * Results:
 *	A standard TCL result.
 *
 * Side effects:
 *	The list of filters are updated in flistPtr.
 *----------------------------------------------------------------------
 */

static FileFilter * GetFilter(flistPtr, name)
    FileFilterList * flistPtr;	/* The FileFilterList that contains the
				 * newly created filter */
    CONST char * name;		/* Name of the filter. It is usually displayed
				 * in the "File Types" listbox in the file
				 * dialogs. */
{
    FileFilter * filterPtr;

    for (filterPtr=flistPtr->filters; filterPtr; filterPtr=filterPtr->next) {
	if (strcmp(filterPtr->name, name)==0) {
	    return filterPtr;
	}
    }

    filterPtr = (FileFilter*)ckalloc(sizeof(FileFilter));
    filterPtr->clauses = NULL;
    filterPtr->clausesTail = NULL;
    filterPtr->name = (char*)ckalloc((strlen(name)+1) * sizeof(char));
    strcpy(filterPtr->name, name);

    if (flistPtr->filters == NULL) {
	flistPtr->filters = flistPtr->filtersTail = filterPtr;
    } else {
	flistPtr->filtersTail->next = filterPtr;
	flistPtr->filtersTail = filterPtr;
    }
    filterPtr->next = NULL;

    ++flistPtr->numFilters;
    return filterPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * FreeClauses --
 *
 *	Frees the malloc'ed file type clause
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The list of clauses in filterPtr->clauses are freed.
 *----------------------------------------------------------------------
 */

static void
FreeClauses(filterPtr)
    FileFilter * filterPtr;	/* FileFilter whose clauses are to be freed */
{
    FileFilterClause * clausePtr, * toFree;

    clausePtr = filterPtr->clauses;
    while (clausePtr) {
	toFree = clausePtr;
	clausePtr=clausePtr->next;
	FreeGlobPatterns(toFree);
	FreeMacFileTypes(toFree);
	ckfree((char*)toFree);
    }
    filterPtr->clauses = NULL;
    filterPtr->clausesTail = NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * FreeGlobPatterns --
 *
 *	Frees the malloc'ed glob patterns in a clause
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The list of glob patterns in clausePtr->patterns are freed.
 *----------------------------------------------------------------------
 */

static void
FreeGlobPatterns(clausePtr)
    FileFilterClause * clausePtr;/* The clause whose patterns are to be freed*/
{
    GlobPattern * globPtr, * toFree;

    globPtr = clausePtr->patterns;
    while (globPtr) {
	toFree = globPtr;
	globPtr=globPtr->next;

	ckfree((char*)toFree->pattern);
	ckfree((char*)toFree);
    }
    clausePtr->patterns = NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * FreeMacFileTypes --
 *
 *	Frees the malloc'ed Mac file types in a clause
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The list of Mac file types in clausePtr->macTypes are freed.
 *----------------------------------------------------------------------
 */

static void
FreeMacFileTypes(clausePtr)
    FileFilterClause * clausePtr;  /* The clause whose mac types are to be
				    * freed */
{
    MacFileType * mfPtr, * toFree;

    mfPtr = clausePtr->macTypes;
    while (mfPtr) {
	toFree = mfPtr;
	mfPtr=mfPtr->next;
	ckfree((char*)toFree);
    }
    clausePtr->macTypes = NULL;
}
@


1.4
log
@touched all sources to ease next import
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tkFileFilter.c,v 1.7.6.1 2000/05/04 21:26:23 spolk Exp $
d20 1
a20 1
			    char * patternsStr, char * ostypesStr,
d28 1
a28 1
			    char * name));
d89 2
a90 2
    char ** listArgv = NULL;
    char ** typeInfo = NULL;
d209 2
a210 2
    char * patternsStr;		/* A TCL list of glob patterns. */
    char * ostypesStr;		/* A TCL list of Mac OSType strings. */
d216 1
a216 1
    char ** globList = NULL;
d218 1
a218 1
    char ** ostypeList = NULL;
d273 1
a273 1
		globPtr->pattern = (char*)ckalloc(len+1);
d292 1
a292 1
		    globPtr->pattern = (char*)ckalloc(len);
d296 1
a296 1
		globPtr->pattern = (char*)ckalloc(len);
d361 1
a361 1
    char * name;		/* Name of the filter. It is usually displayed
a485 1

@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all tk files to ease next import
@
text
@@


1.1
log
@Initial revision
@
text
@d12 1
a12 2
 * RCS: @@(#) $Id: tkFileFilter.c,v 1.7 1999/01/26 04:11:21 jingham Exp $
 *
d486 1
@


1.1.1.1
log
@import insight-2000-02-04 snapshot (2nd try)
@
text
@@


1.1.1.2
log
@Tk 8.3 upgrade
@
text
@d12 2
a13 1
 * RCS: @@(#) $Id: tkFileFilter.c,v 1.7.6.1 2000/05/04 21:26:23 spolk Exp $
a486 1

@


1.1.1.3
log
@import tk 8.4.0
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tkFileFilter.c,v 1.5 2002/01/27 11:10:50 das Exp $
d20 1
a20 1
			    CONST char * patternsStr, CONST char * ostypesStr,
d28 1
a28 1
			    CONST char * name));
d89 2
a90 2
    CONST char ** listArgv = NULL;
    CONST char ** typeInfo = NULL;
d209 2
a210 2
    CONST char * patternsStr;		/* A TCL list of glob patterns. */
    CONST char * ostypesStr;		/* A TCL list of Mac OSType strings. */
d216 1
a216 1
    CONST char ** globList = NULL;
d218 1
a218 1
    CONST char ** ostypeList = NULL;
d273 1
a273 1
		globPtr->pattern = (char*)ckalloc((unsigned int) len+1);
d292 1
a292 1
		    globPtr->pattern = (char*)ckalloc((unsigned int) len);
d296 1
a296 1
		globPtr->pattern = (char*)ckalloc((unsigned int) len);
d361 1
a361 1
    CONST char * name;		/* Name of the filter. It is usually displayed
d486 1
@


