head	1.3;
access;
symbols
	sid-snapshot-20180601:1.3
	sid-snapshot-20180501:1.3
	sid-snapshot-20180401:1.3
	sid-snapshot-20180301:1.3
	sid-snapshot-20180201:1.3
	sid-snapshot-20180101:1.3
	sid-snapshot-20171201:1.3
	sid-snapshot-20171101:1.3
	sid-snapshot-20171001:1.3
	sid-snapshot-20170901:1.3
	sid-snapshot-20170801:1.3
	sid-snapshot-20170701:1.3
	sid-snapshot-20170601:1.3
	sid-snapshot-20170501:1.3
	sid-snapshot-20170401:1.3
	sid-snapshot-20170301:1.3
	sid-snapshot-20170201:1.3
	sid-snapshot-20170101:1.3
	sid-snapshot-20161201:1.3
	sid-snapshot-20161101:1.3
	sid-snapshot-20160901:1.3
	sid-snapshot-20160801:1.3
	sid-snapshot-20160701:1.3
	sid-snapshot-20160601:1.3
	sid-snapshot-20160501:1.3
	sid-snapshot-20160401:1.3
	sid-snapshot-20160301:1.3
	sid-snapshot-20160201:1.3
	sid-snapshot-20160101:1.3
	sid-snapshot-20151201:1.3
	sid-snapshot-20151101:1.3
	sid-snapshot-20151001:1.3
	sid-snapshot-20150901:1.3
	sid-snapshot-20150801:1.3
	sid-snapshot-20150701:1.3
	sid-snapshot-20150601:1.3
	sid-snapshot-20150501:1.3
	sid-snapshot-20150401:1.3
	sid-snapshot-20150301:1.3
	sid-snapshot-20150201:1.3
	sid-snapshot-20150101:1.3
	sid-snapshot-20141201:1.3
	sid-snapshot-20141101:1.3
	sid-snapshot-20141001:1.3
	sid-snapshot-20140901:1.3
	sid-snapshot-20140801:1.3
	sid-snapshot-20140701:1.3
	sid-snapshot-20140601:1.3
	sid-snapshot-20140501:1.3
	sid-snapshot-20140401:1.3
	sid-snapshot-20140301:1.3
	sid-snapshot-20140201:1.3
	sid-snapshot-20140101:1.3
	sid-snapshot-20131201:1.3
	sid-snapshot-20131101:1.3
	sid-snapshot-20131001:1.3
	sid-snapshot-20130901:1.3
	sid-snapshot-20130801:1.3
	sid-snapshot-20130701:1.3
	sid-snapshot-20130601:1.3
	insight_7_6-2013-04-10-branchpoint:1.3
	gdb_7_6-branch:1.3.0.28
	sid-snapshot-20130501:1.3
	sid-snapshot-20130401:1.3
	sid-snapshot-20130301:1.3
	sid-snapshot-20130201:1.3
	sid-snapshot-20130101:1.3
	sid-snapshot-20121201:1.3
	sid-snapshot-20121101:1.3
	sid-snapshot-20121001:1.3
	sid-snapshot-20120901:1.3
	gdb_7_5-branch:1.3.0.26
	sid-snapshot-20120801:1.3
	sid-snapshot-20120701:1.3
	sid-snapshot-20120601:1.3
	sid-snapshot-20120501:1.3
	sid-snapshot-20120401:1.3
	gdb_7_4-branch:1.3.0.24
	sid-snapshot-20120301:1.3
	sid-snapshot-20120201:1.3
	sid-snapshot-20120101:1.3
	sid-snapshot-20111201:1.3
	sid-snapshot-20111101:1.3
	sid-snapshot-20111001:1.3
	sid-snapshot-20110901:1.3
	gdb_7_3-branch:1.3.0.22
	sid-snapshot-20110801:1.3
	sid-snapshot-20110701:1.3
	sid-snapshot-20110601:1.3
	sid-snapshot-20110501:1.3
	sid-snapshot-20110401:1.3
	sid-snapshot-20110301:1.3
	sid-snapshot-20110201:1.3
	sid-snapshot-20110101:1.3
	sid-snapshot-20101201:1.3
	sid-snapshot-20101101:1.3
	sid-snapshot-20101001:1.3
	sid-snapshot-20100901:1.3
	sid-snapshot-20100801:1.3
	sid-snapshot-20100701:1.3
	sid-snapshot-20100601:1.3
	sid-snapshot-20100501:1.3
	sid-snapshot-20100401:1.3
	sid-snapshot-20100301:1.3
	gdb_7_1-branch:1.3.0.20
	gdb_7_0-branch:1.3.0.18
	sid-snapshot-20100201:1.3
	sid-snapshot-20100101:1.3
	sid-snapshot-20091201:1.3
	sid-snapshot-20091101:1.3
	sid-snapshot-20091001:1.3
	arc-sim-20090309:1.3
	sid-snapshot-20090901:1.3
	sid-snapshot-20090801:1.3
	sid-snapshot-20090701:1.3
	sid-snapshot-20090601:1.3
	sid-snapshot-20090501:1.3
	kevinb-pre-tk8_5_7_merge:1.3
	sid-snapshot-20090401:1.3
	arc-insight_6_8-branch:1.3.0.16
	arc-insight_6_8-branchpoint:1.3
	insight_6_8-branch:1.3.0.14
	insight_6_8-branchpoint:1.3
	sid-snapshot-20090301:1.3
	sid-snapshot-20090201:1.3
	sid-snapshot-20090101:1.3
	sid-snapshot-20081201:1.3
	sid-snapshot-20081101:1.3
	sid-snapshot-20081001:1.3
	sid-snapshot-20080901:1.3
	sid-snapshot-20080801:1.3
	sid-snapshot-20080701:1.3
	sid-snapshot-20080601:1.3
	sid-snapshot-20080501:1.3
	sid-snapshot-20080403:1.3
	sid-snapshot-20080401:1.3
	gdb_6_8-branch:1.3.0.12
	sid-snapshot-20080301:1.3
	sid-snapshot-20080201:1.3
	sid-snapshot-20080101:1.3
	sid-snapshot-20071201:1.3
	sid-snapshot-20071101:1.3
	sid-snapshot-20071001:1.3
	insight_6_6-20070208-release:1.3
	gdb_6_6-branch:1.3.0.10
	gdb_6_6-2006-11-15-branchpoint:1.3
	insight_6_5-20061003-release:1.3
	gdb_6_5-branch:1.3.0.8
	gdb_6_5-2006-05-14-branchpoint:1.3
	gdb_6_4-branch:1.3.0.6
	gdb_6_4-2005-11-01-branchpoint:1.3
	gdb_6_1-2004-04-05-release:1.3
	gdb_6_1-branch:1.3.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.3
	gdb_6_0-2003-10-04-release:1.3
	gdb_6_0-branch:1.3.0.2
	gdb_6_0-2003-06-23-branchpoint:1.3
	TK8_4_1:1.1.1.2
	tcltk840-20020924-branch:1.1.1.1.0.2
	tcltk840-20020924-branchpoint:1.1.1.1
	TK_8_4_0:1.1.1.1
	NET:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2003.01.21.20.24.49;	author hunt;	state Exp;
branches
	1.3.16.1;
next	1.2;

1.2
date	2003.01.21.19.53.15;	author hunt;	state Exp;
branches;
next	1.1;

1.1
date	2002.09.24.20.38.44;	author kseitz;	state Exp;
branches
	1.1.1.1;
next	;

1.3.16.1
date	2009.09.11.04.46.04;	author amylaar;	state Exp;
branches;
next	;

1.1.1.1
date	2002.09.24.20.38.44;	author kseitz;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.01.21.19.54.37;	author hunt;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Updated to tk 8.4.1
@
text
@/* 
 * tkMacOSXHLEvents.c --
 *
 *        Implements high level event support for the Macintosh.  Currently, 
 *        the only event that really does anything is the Quit event.
 *
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
 * Copyright 2001, Apple Computer, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tkMacOSXHLEvents.c,v 1.3 2002/09/12 17:34:16 das Exp $
 */

#include "tkMacOSXUtil.h"
#include "tkMacOSXInt.h"

#include <Carbon/Carbon.h>

/*
 * This is a Tcl_Event structure that the Quit AppleEvent handler
 * uses to schedule the tkReallyKillMe function.
 */
 
typedef struct KillEvent {
    Tcl_Event header;                /* Information that is standard for
                                 * all events. */
    Tcl_Interp *interp;                /* Interp that was passed to the
                                 * Quit AppleEvent */
} KillEvent;

/*
 * Static functions used only in this file.
 */

static OSErr QuitHandler (const AppleEvent * event, AppleEvent * reply, long handlerRefcon);
static OSErr OappHandler (const AppleEvent * event, AppleEvent * reply, long handlerRefcon);
static OSErr RappHandler (const AppleEvent * event, AppleEvent * reply, long handlerRefcon);
static OSErr OdocHandler (const AppleEvent * event, AppleEvent * reply, long handlerRefcon);
static OSErr PrintHandler (const AppleEvent * event, AppleEvent * reply, long handlerRefcon);
static OSErr ScriptHandler (const AppleEvent * event, AppleEvent * reply, long handlerRefcon);
static OSErr PrefsHandler (const AppleEvent * event, AppleEvent * reply, long handlerRefcon);

static int MissedAnyParameters _ANSI_ARGS_((const AppleEvent *theEvent));
static int ReallyKillMe _ANSI_ARGS_((Tcl_Event *eventPtr, int flags));

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXInitAppleEvents --
 *
 *        Initilize the Apple Events on the Macintosh.  This registers the
 *        core event handlers.
 *
 * Results:
 *        None.
 *
 * Side effects:
 *        None.
 *
 *----------------------------------------------------------------------
 */

void 
TkMacOSXInitAppleEvents(
    Tcl_Interp *interp)                /* Interp to handle basic events. */
{
    OSErr err;
    AEEventHandlerUPP        OappHandlerUPP, RappHandlerUPP, OdocHandlerUPP,
        PrintHandlerUPP, QuitHandlerUPP, ScriptHandlerUPP,
        PrefsHandlerUPP;
        
    /*
     * Install event handlers for the core apple events.
     */
    QuitHandlerUPP = NewAEEventHandlerUPP(QuitHandler);
    err = AEInstallEventHandler(kCoreEventClass, kAEQuitApplication,
            QuitHandlerUPP, (long) interp, false);

    OappHandlerUPP = NewAEEventHandlerUPP(OappHandler);
    err = AEInstallEventHandler(kCoreEventClass, kAEOpenApplication,
            OappHandlerUPP, (long) interp, false);

    RappHandlerUPP = NewAEEventHandlerUPP(RappHandler);
    err = AEInstallEventHandler(kCoreEventClass, kAEReopenApplication,
            RappHandlerUPP, (long) interp, false);

    OdocHandlerUPP = NewAEEventHandlerUPP(OdocHandler);
    err = AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,
            OdocHandlerUPP, (long) interp, false);

    PrintHandlerUPP = NewAEEventHandlerUPP(PrintHandler);
    err = AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments,
            PrintHandlerUPP, (long) interp, false);

    PrefsHandlerUPP = NewAEEventHandlerUPP(PrefsHandler);
    err = AEInstallEventHandler(kCoreEventClass, kAEShowPreferences,
            PrefsHandlerUPP, (long) interp, false);

    if (interp != NULL) {
        ScriptHandlerUPP = NewAEEventHandlerUPP(ScriptHandler);
        err = AEInstallEventHandler('misc', 'dosc',
            ScriptHandlerUPP, (long) interp, false);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TkMacOSXDoHLEvent --
 *
 *        Dispatch incomming highlevel events.
 *
 * Results:
 *        None.
 *
 * Side effects:
 *        Depends on the incoming event.
 *
 *----------------------------------------------------------------------
 */

int
TkMacOSXDoHLEvent(EventRecord *theEvent)
{
    return AEProcessAppleEvent(theEvent);
}

/*
 *----------------------------------------------------------------------
 *
 * QuitHandler, OappHandler, etc. --
 *
 *        These are the core Apple event handlers.  Only the Quit event does
 *        anything interesting.
 *
 * Results:
 *        None.
 *
 * Side effects:
 *        None.
 *
 *----------------------------------------------------------------------
 */
OSErr QuitHandler (const AppleEvent * event, AppleEvent * reply, long handlerRefcon)
{
    Tcl_Interp *interp = (Tcl_Interp *) handlerRefcon;
    KillEvent *eventPtr;
    
    /*
     * Call the exit command from the event loop, since you are not supposed
     * to call ExitToShell in an Apple Event Handler.  We put this at the head
     * of Tcl's event queue because this message usually comes when the Mac is
     * shutting down, and we want to kill the shell as quickly as possible.
     */
    
    eventPtr = (KillEvent *) ckalloc(sizeof(KillEvent));
    eventPtr->header.proc = ReallyKillMe;
    eventPtr->interp = interp;
     
    Tcl_QueueEvent((Tcl_Event *) eventPtr, TCL_QUEUE_HEAD);

    return noErr;
}

static OSErr 
OappHandler (const AppleEvent * event, AppleEvent * reply, long handlerRefcon)
{
    return noErr;
}

static OSErr 
RappHandler (const AppleEvent * event, AppleEvent * reply, long handlerRefcon)
{
    ProcessSerialNumber thePSN = {0, kCurrentProcess};
    return SetFrontProcess(&thePSN);
}

/* Called when the user selects 'Preferences...' in MacOS X */
static OSErr 
PrefsHandler (const AppleEvent * event, AppleEvent * reply, long handlerRefcon)
{
    Tcl_CmdInfo dummy;
    Tcl_Interp *interp = (Tcl_Interp *) handlerRefcon;
    /*
     * Don't bother if we don't have an interp or
     * the show preferences procedure doesn't exist.
     */

    if ((interp == NULL) || 
            (Tcl_GetCommandInfo(interp, "::tk::mac::ShowPreferences", &dummy)) == 0) {
            return noErr;
    }
    Tcl_GlobalEval(interp, "::tk::mac::ShowPreferences");
    return noErr;
}

static OSErr 
OdocHandler (const AppleEvent * event, AppleEvent * reply, long handlerRefcon)
{
    Tcl_Interp *interp = (Tcl_Interp *) handlerRefcon;
    AEDescList fileSpecList;
    FSSpec file;
    OSErr err;
    DescType type;
    Size actual;
    long count;
    AEKeyword keyword;
    long index;
    Tcl_DString command;
    Tcl_DString pathName;
    Tcl_CmdInfo dummy;

    /*
     * Don't bother if we don't have an interp or
     * the open document procedure doesn't exist.
     */

    if ((interp == NULL) || 
            (Tcl_GetCommandInfo(interp, "::tk::mac::OpenDocument", &dummy)) == 0) {
            return noErr;
    }
    
    /*
     * If we get any errors wil retrieving our parameters
     * we just return with no error.
     */

    err = AEGetParamDesc(event, keyDirectObject,
            typeAEList, &fileSpecList);
    if (err != noErr) {
        return noErr;
    }

    err = MissedAnyParameters(event);
    if (err != noErr) {
        return noErr;
    }

    err = AECountItems(&fileSpecList, &count);
    if (err != noErr) {
        return noErr;
    }

    Tcl_DStringInit(&command);
    Tcl_DStringAppend(&command, "::tk::mac::OpenDocument", -1);
    for (index = 1; index <= count; index++) {
        int length;
        Handle fullPath;
        
        err = AEGetNthPtr(&fileSpecList, index, typeFSS,
                &keyword, &type, (Ptr) &file, sizeof(FSSpec), &actual);
        if ( err != noErr ) {
            continue;
        }

        err = FSpPathFromLocation(&file, &length, &fullPath);
        HLock(fullPath);
        Tcl_ExternalToUtfDString(NULL, *fullPath, length, &pathName);
        HUnlock(fullPath);
        DisposeHandle(fullPath);

        Tcl_DStringAppendElement(&command, Tcl_DStringValue(&pathName));
        Tcl_DStringFree(&pathName);
    }
    
    Tcl_GlobalEval(interp, Tcl_DStringValue(&command));

    Tcl_DStringFree(&command);
    return noErr;
}

static OSErr 
PrintHandler (const AppleEvent * event, AppleEvent * reply, long handlerRefcon)
{
    return noErr;
}

/*
 *----------------------------------------------------------------------
 *
 * ScriptHandler --
 *
 *        This handler process the script event.  
 *
 * Results:
 *        Schedules the given event to be processed.
 *
 * Side effects:
 *        None.
 *
 *----------------------------------------------------------------------
 */

static OSErr 
ScriptHandler (const AppleEvent * event, AppleEvent * reply, long handlerRefcon)
{
    OSErr theErr;
    AEDescList theDesc;
    int tclErr = -1;
    Tcl_Interp *interp;
    char errString[128];

    interp = (Tcl_Interp *) handlerRefcon;

    /*
     * The do script event receives one parameter that should be data or a file.
     */
    theErr = AEGetParamDesc(event, keyDirectObject, typeWildCard,
            &theDesc);
    if (theErr != noErr) {
        sprintf(errString, "AEDoScriptHandler: GetParamDesc error %d", theErr);
        theErr = AEPutParamPtr(reply, keyErrorString, typeChar, errString,
                strlen(errString));
    } else if (MissedAnyParameters(event)) {
        sprintf(errString, "AEDoScriptHandler: extra parameters");
        AEPutParamPtr(reply, keyErrorString, typeChar, errString,
                strlen(errString));
        theErr = -1771;
    } else {
        if (theDesc.descriptorType == (DescType)'TEXT') {
            Tcl_DString encodedText;
            short i;
            Size  size;
            char  * data;
            
            size = AEGetDescDataSize(&theDesc);
            
            data = (char *)ckalloc(size + 1);
            if ( !data ) {
                theErr = -1771;
            }
            else {
                   AEGetDescData(&theDesc,data,size);
                   data [ size ] = 0;
                   for (i=0; i<size; i++)
                    if (data[i] == '\r')
                     data[i] = '\n';
                   AEReplaceDescData(theDesc.descriptorType,data,size+1,&theDesc);
            }
            Tcl_ExternalToUtfDString(NULL, data, size,
                    &encodedText);
            tclErr = Tcl_GlobalEval(interp, Tcl_DStringValue(&encodedText));
            Tcl_DStringFree(&encodedText);
        } else if (theDesc.descriptorType == (DescType)'alis') {
            Boolean dummy;
            FSSpec theFSS;
            Handle fullPath;
            int length;
            AliasHandle aliasHandle;

            AEGetDescData (&theDesc,&aliasHandle,sizeof(aliasHandle ) );
            
            theErr = ResolveAlias(NULL, aliasHandle,
                    &theFSS, &dummy);
            if (theErr == noErr) {
                FSpPathFromLocation(&theFSS, &length, &fullPath);
                HLock(fullPath);
                Tcl_EvalFile(interp, *fullPath);
                HUnlock(fullPath);
                DisposeHandle(fullPath);
            } else {
                sprintf(errString, "AEDoScriptHandler: file not found");
                AEPutParamPtr(reply, keyErrorString, typeChar,
                        errString, strlen(errString));
            }
        } else {
            sprintf(errString,
                    "AEDoScriptHandler: invalid script type '%-4.4s', must be 'alis' or 'TEXT'",
                    (char *)(&theDesc.descriptorType));
            AEPutParamPtr(reply, keyErrorString, typeChar,
                    errString, strlen(errString));
            theErr = -1770;
        }
    }

    /*
     * If we actually go to run Tcl code - put the result in the reply.
     */
    if (tclErr >= 0) {
        if (tclErr == TCL_OK)  {
            AEPutParamPtr(reply, keyDirectObject, typeChar,
                Tcl_GetStringResult(interp),
                strlen(Tcl_GetStringResult(interp)));
        } else {
            AEPutParamPtr(reply, keyErrorString, typeChar,
                Tcl_GetStringResult(interp),
                strlen(Tcl_GetStringResult(interp)));
            AEPutParamPtr(reply, keyErrorNumber, typeInteger,
                (Ptr) &tclErr, sizeof(int));
        }
    }
        
    AEDisposeDesc(&theDesc);

    return theErr;
}

/*
 *----------------------------------------------------------------------
 *
 * ReallyKillMe --
 *
 *        This proc tries to kill the shell by running exit, and if that 
 *      has not succeeded (e.g. because someone has renamed the exit 
 *      command), calls Tcl_Exit to really kill the shell.  Called from 
 *      an event scheduled by the "Quit" AppleEvent handler.
 *
 * Results:
 *        Kills the shell.
 *
 * Side effects:
 *        None.
 *
 *----------------------------------------------------------------------
 */

static int 
ReallyKillMe(Tcl_Event *eventPtr, int flags) 
{
    Tcl_Interp *interp = ((KillEvent *) eventPtr)->interp;
    if (interp != NULL) {
        Tcl_GlobalEval(interp, "exit");
    }
    Tcl_Exit(0);
    
    return 1;
}

/*
 *----------------------------------------------------------------------
 *
 * MissedAnyParameters --
 *
 *        Checks to see if parameters are still left in the event.  
 *
 * Results:
 *        True or false.
 *
 * Side effects:
 *        None.
 *
 *----------------------------------------------------------------------
 */
 
static int 
MissedAnyParameters(
    const AppleEvent *theEvent)
{
   DescType returnedType;
   Size actualSize;
   OSErr err;

   err = AEGetAttributePtr(theEvent, keyMissedKeywordAttr, typeWildCard, 
                   &returnedType, NULL, 0, &actualSize);
   
   return (err != errAEDescNotFound);
}
@


1.3.16.1
log
@gdb/insight for ARCompact (from Richard Stuckey)
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tkMacOSXHLEvents.c,v 1.3 2003/01/21 20:24:49 hunt Exp $
@


1.2
log
@touched all sources to ease next import
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tkMacOSXHLEvents.c,v 1.1.1.1 2002/09/24 20:38:44 kseitz Exp $
d39 1
d70 1
a70 1
    AEEventHandlerUPP        OappHandlerUPP, OdocHandlerUPP,
d85 4
d171 7
@


1.1
log
@Initial revision
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tkMacOSXHLEvents.c,v 1.2 2002/08/31 06:12:30 das Exp $
@


1.1.1.1
log
@import tk 8.4.0
@
text
@@


1.1.1.2
log
@imported tk 8.4.1
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tkMacOSXHLEvents.c,v 1.3 2002/09/12 17:34:16 das Exp $
a38 1
static OSErr RappHandler (const AppleEvent * event, AppleEvent * reply, long handlerRefcon);
d69 1
a69 1
    AEEventHandlerUPP        OappHandlerUPP, RappHandlerUPP, OdocHandlerUPP,
a83 4
    RappHandlerUPP = NewAEEventHandlerUPP(RappHandler);
    err = AEInstallEventHandler(kCoreEventClass, kAEReopenApplication,
            RappHandlerUPP, (long) interp, false);

a165 7
}

static OSErr 
RappHandler (const AppleEvent * event, AppleEvent * reply, long handlerRefcon)
{
    ProcessSerialNumber thePSN = {0, kCurrentProcess};
    return SetFrontProcess(&thePSN);
@

